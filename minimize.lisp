;;; minimize.lisp --- Minimally sufficient conditions for a MIZAR text

(in-package :mizar)

(defgeneric minimize (article)
  (:documentation "Find the smallest envionment with respect to which ARTICLE is a verifiable MIZAR article."))

(defgeneric verifiable-wrt-environment (article environment-kind environment)
  (:documentation "Is ARTICLE verifiable with respect to
  ENVIRONMENT?

ENVIRONMENT is to be the content of or a reference to a particular
MIZAR environment file, e.g., the .atr file, or the .eno file, etc.
It is not intended to be the \"full\" environment of an article (i.e.,
the result of the accommodator).

ENVIRONMENT-KIND indicates what kind of environment ENVIRONMENT is,
e.g., constructor environment, notation environment, etc."))

(defparameter *environment-kinds*
  '("aco" "atr" "eno" "dfs" "ecl" "eid")
  "File extensions of known environment files generated by the
  accommodator.")

;; (defmethod verifiable-wrt-environment ((article pathname)
;; 				       (environment-kind stringl)
;; 				       (environment string))
;;   (unless (member article-kind *environment-kinds* :test #'string=)
;;     (error "The article kind '~a' is not a known envionment kind; the known kinds are:~%~%~{* ~a~%~}" *environment-kinds*)))

(defgeneric minimize-environment-for-article (article environment)
  (:documentation "Given ENVIRONMENT for ARTICLE, compute the smallest subenvironment of ENVIRONMENT with respect to which ARTICLE is MIZAR verifiable."))

(defmethod minimize-environment-for-article ((article pathname)
					     (environment pathname))
  (flet ((verifiable-wrt-environment (environment))
	 (handler-case
	     (verifier article :flags '("-q" "-l"))
	   (mizar-error () nil)))))

(defmethod minimize ((article pathname))
  ())

(defgeneric minimize-requirements (article)
  (:documentation "From the explicitly required set of requirements
  for ARTICLE, compute the smallest subset with respect to which the article is still verifiable."))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Minimizing requirements
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defgeneric requirements-of-article (article)
  (:documentation "The contents of the requirements environment directive of ARTICLE."))

(defmethod requirements-of-article :around ((article-path pathname))
  (if (file-exists-p article-path)
      (let ((evl-file (replace-extension article-path "miz" "evl")))
	(if (file-exists-p evl-file)
	    (call-next-method)
	    (error "The .evl file for~%~%  ~a~%~%does not exist at the expected location~%~%  ~a~%" article-path evl-file)))
      (error "The file~%~%  ~a~%~%does not exist~%" article-path)))

(defmethod requirements-of-article ((article-path pathname))
  (let* ((evl-file (replace-extension article-path "miz" "evl"))
	 (doc (cxml:parse-file evl-file (cxml-dom:make-dom-builder))))
    (mapcar #'xpath:string-value
	    (xpath:all-nodes
	     (xpath:evaluate "/Environ/Directive[@name = 'Requirements']/Ident/@name"
			     doc)))))

(defgeneric update-requirements (article new-requirements)
  (:documentation "Force the requirements directive of ARTICLE to have the contents NEW-REQUIREMENTS."))

(defmethod update-requirements ((article-path pathname) (new-requirements list))
  (let ((token-string-requirements (if new-requirements
				       (format nil "~{,~a~}," new-requirements)
				       ""))
	(evl-file (replace-extension article-path "miz" "evl")))
    (let ((new-evl-as-string (apply-stylesheet (mizar-items-config 'update-requirements-stylesheet) evl-file (list (cons "new-requirements" token-string-requirements)) nil)))
      (write-string-into-file new-evl-as-string evl-file
			      :if-does-not-exist :error
			      :if-exists :supersede))))

(defmethod minimize-requirements :around ((article-path pathname))
  (if (file-exists-p article-path)
      (call-next-method)
      (error "There is no file at~%~%  ~a~%" article-path)))

(defmethod minimize-requirements ((article-path pathname))
  (loop
     with requirements = (remove "HIDDEN" (requirements-of-article article-path)
				 :test #'string=)
     with final-trimmed-requirements = requirements
     for requirement in requirements
     do
       (let ((trimmed-requirements (remove requirement final-trimmed-requirements)))
	 (update-requirements article-path trimmed-requirements)
	 (handler-case
	     (progn
	       (verifier article-path :flags '("-q" "-s" "-l"))
	       (setf final-trimmed-requirements trimmed-requirements)
	       (format t "We don't need the requirement ~a~%" requirement))
	   (mizar-error ()
	     (progn
	       (push requirement trimmed-requirements)
	       (update-requirements article-path trimmed-requirements)
	       (format t "We do need the requirement ~a~%" requirement)))))
     finally
       (return final-trimmed-requirements)))

;;; minimize.lisp ends here
