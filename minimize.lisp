;;; minimize.lisp --- Minimally sufficient conditions for a MIZAR text

(in-package :mizar)

(defgeneric minimize (article)
  (:documentation "Find the smallest envionment with respect to which ARTICLE is a verifiable MIZAR article."))

(defgeneric verifiable-wrt-environment (article environment-kind environment)
  (:documentation "Is ARTICLE verifiable with respect to
  ENVIRONMENT?

ENVIRONMENT is to be the content of or a reference to a particular
MIZAR environment file, e.g., the .atr file, or the .eno file, etc.
It is not intended to be the \"full\" environment of an article (i.e.,
the result of the accommodator).

ENVIRONMENT-KIND indicates what kind of environment ENVIRONMENT is,
e.g., constructor environment, notation environment, etc."))

(defparameter *environment-kinds*
  '("aco" "atr" "eno" "dfs" "ecl" "eid")
  "File extensions of known environment files generated by the
  accommodator.")

;; (defmethod verifiable-wrt-environment ((article pathname)
;; 				       (environment-kind stringl)
;; 				       (environment string))
;;   (unless (member article-kind *environment-kinds* :test #'string=)
;;     (error "The article kind '~a' is not a known envionment kind; the known kinds are:~%~%~{* ~a~%~}" *environment-kinds*)))

(defgeneric minimize-environment-for-article (article environment)
  (:documentation "Given ENVIRONMENT for ARTICLE, compute the smallest subenvironment of ENVIRONMENT with respect to which ARTICLE is MIZAR verifiable."))

(defmethod minimize-environment-for-article ((article pathname)
					     (environment pathname))
  (flet ((verifiable-wrt-environment (environment))
	 (handler-case
	     (verifier article :flags '("-q" "-l"))
	   (mizar-error () nil)))))

(defmethod minimize ((article pathname))
  ())

(defgeneric minimize-requirements (article &optional working-directory)
  (:documentation "From the explicitly required set of requirements
  for ARTICLE, compute the smallest subset with respect to which the article is still verifiable.  Verification will take place in WORKING-DIRECTORY, if supplied."))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Minimizing requirements
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defgeneric requirements-of-article (article)
  (:documentation "The contents of the requirements environment directive of ARTICLE."))

(defmethod requirements-of-article :around ((article-path pathname))
  (if (file-exists-p article-path)
      (let ((evl-file (replace-extension article-path "miz" "evl")))
	(if (file-exists-p evl-file)
	    (call-next-method)
	    (error "The .evl file for~%~%  ~a~%~%does not exist at the expected location~%~%  ~a~%" article-path evl-file)))
      (error "The file~%~%  ~a~%~%does not exist~%" article-path)))

(defmethod requirements-of-article ((article-path pathname))
  (let* ((evl-file (replace-extension article-path "miz" "evl"))
	 (doc (cxml:parse-file evl-file (cxml-dom:make-dom-builder))))
    (mapcar #'xpath:string-value
	    (xpath:all-nodes
	     (xpath:evaluate "/Environ/Directive[@name = 'Requirements']/Ident/@name"
			     doc)))))

(defgeneric update-requirements (article new-requirements &optional working-directory)
  (:documentation "Force the requirements directive of ARTICLE to have the contents NEW-REQUIREMENTS.  Any invocations of mizar tools will be carried out in WORKING-DIRECTORY."))

(defmethod update-requirements :around ((article-path pathname) (new-requirements list) &optional working-directory)
  (if (file-exists-p article-path)
      (if working-directory
	  (if (file-exists-p working-directory)
	      (if (directory-p working-directory)
		  (call-next-method)
		  (error "The supplied working directory,~%~%  ~a~%~%is not actually a directory!~%" working-directory))
	      (error "The supplied working directory,~%~%  ~a~%~%does not exist~%" working-directory))
	  (call-next-method))
      (error "The given article path,~%~%  ~a~%~%does not exist!~%" article-path)))

(defparameter *requirements-regexp* "requirements ([^;]+);")

(defun split-requirements-line (requirements-line)
  (if (scan *requirements-regexp* requirements-line)
      (register-groups-bind (comma-delimited-list)
	  (*requirements-regexp* requirements-line)
	(mapcar #'delete-space
		(split #\, comma-delimited-list)))
      (error "The supplied requirements line~%~%  ~a~%~%does not match the regular expressio~%~%  ~a~%" requirements-line *requirements-regexp*)))

(defmethod update-requirements ((article-path pathname) (new-requirements list) &optional working-directory)
  (let ((new-miz-text
	 (with-open-file (miz article-path
			      :direction :input
			      :if-does-not-exist :error)
	   (with-output-to-string (s)
	     (loop
		for line = (read-line miz nil nil)
		do
		  (if line
		      (if (cl-ppcre:scan *requirements-regexp* line)
			  (when new-requirements
			    (format s "requirements ~{~a~#[~:;,~]~};~%" new-requirements))
			  (format s "~a~%" line))
		      (return)))))))
    (with-open-file (new-miz article-path
			     :direction :output
			     :if-exists :supersede)
      (format new-miz new-miz-text))
    (accom article-path
	   :flags '("-q" "-s" "-l")
	   :working-directory working-directory)))

;; This method works by using the .wsx file output by Czeslaw's
;; newparser.  For libraries where newparser is unavailable, a more
;; brutish method is required.
;;
;; (defmethod update-requirements ((article-path pathname) (new-requirements list) &optional working-directory)
;;   (let ((token-string-requirements (if new-requirements
;; 				       (format nil "~{,~a~}," new-requirements)
;; 				       ""))
;; 	(evl-file (replace-extension article-path "miz" "evl"))
;; 	(wsx-file (replace-extension article-path "miz" "wsx")))
;;     (handler-case
;; 	(newparser article-path
;; 		   :flags '("-q" "-s" "-l")
;; 		   :working-directory working-directory)
;;       (mizar-error () (error "Something went wrong generating the .wsx for~%~%  ~a" article-path)))
;;     (let ((new-evl-as-string (apply-stylesheet (mizar-items-config 'update-requirements-stylesheet) evl-file (list (cons "new-requirements" token-string-requirements)) nil)))
;;       (write-string-into-file new-evl-as-string evl-file
;; 			      :if-does-not-exist :error
;; 			      :if-exists :supersede)
;;       ;; now regenerate the text of the article
;;       (let ((new-article-text (apply-stylesheet (mizar-items-config 'wsm-stylesheet)
;; 						wsx-file
;; 						nil
;; 						nil)))
;; 	(write-string-into-file new-article-text
;; 				article-path
;; 				:if-exists :supersede
;; 				:if-does-not-exist :error))
;;       ;; re-accommodate (effectively generating a new .ere using the trimmed requirements directive)
;;       (accom article-path
;; 	     :flags '("-q" "-s" "-l")
;; 	     :working-directory working-directory))))

(defmethod minimize-requirements :around ((article-path pathname) &optional working-directory)
  (if (file-exists-p article-path)
      (if working-directory
	  (if (directory-p working-directory)
	      (call-next-method)
	      (error "The supplied working directory,~%~%  ~a~%~%is not a directory!" working-directory))
	  (call-next-method))
      (error "There is no file at~%~%  ~a~%" article-path)))

(defmethod minimize-requirements ((article-path pathname) &optional working-directory)
  (loop
     with requirements = (remove "HIDDEN" (requirements-of-article article-path)
				 :test #'string=)
     with final-trimmed-requirements = requirements
     for requirement in requirements
     do
       (let ((trimmed-requirements (remove requirement final-trimmed-requirements)))
	 (update-requirements article-path trimmed-requirements working-directory)
	 (handler-case
	     (progn
	       (verifier article-path
			 :flags '("-q" "-s" "-l")
			 :working-directory working-directory)
	       (setf final-trimmed-requirements trimmed-requirements)
	       (format t "We don't need the requirement ~a~%" requirement))
	   (mizar-error ()
	     (progn
	       (push requirement trimmed-requirements)
	       (update-requirements article-path trimmed-requirements working-directory)
	       (format t "We do need the requirement ~a~%" requirement)))))
     finally
       (return final-trimmed-requirements)))

(defgeneric minimize-requirements-of-itemized-db (miz-db)
  (:documentation "Minimize the requirements of every article fragment appearing under MIZ-DB."))

(defmethod minimize-requirements-of-itemized-db :around ((miz-db-path pathname))
  (if (file-exists-p miz-db-path)
      (if (directory-p miz-db-path)
	  (let ((text-subdir (merge-pathnames "text/" miz-db-path)))
	    (if (file-exists-p text-subdir)
		(call-next-method)
		(error "The supplied mizar database directory,~%~%  ~a~%~%lacks a text subdirectory!~%" miz-db-path)))
	  (error "The supplied mizar database directory,~%~%  ~a~%~%is not actually a directory!~%" miz-db-path))
      (error "The mizar database directory~%~%  ~a~%~%does not exist!~%" miz-db-path)))

(defmethod minimize-requirements-of-itemized-db ((miz-db-path pathname))
  (loop
     with text-subdir = (merge-pathnames "text/" miz-db-path)
     with ckbs = (directory (merge-pathnames "ckb*.miz" text-subdir))
     for ckb in ckbs
     do
       (minimize-requirements ckb miz-db-path)
     finally
       (return t)))

;;; minimize.lisp ends here
