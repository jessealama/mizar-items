;;; minimize.lisp --- Minimally sufficient conditions for a MIZAR text

(in-package :mizar)

(defgeneric minimize (article)
  (:documentation "Find the smallest envionment with respect to which ARTICLE is a verifiable MIZAR article."))

(defgeneric verifiable-wrt-environment (article environment-kind environment)
  (:documentation "Is ARTICLE verifiable with respect to
  ENVIRONMENT?

ENVIRONMENT is to be the content of or a reference to a particular
MIZAR environment file, e.g., the .atr file, or the .eno file, etc.
It is not intended to be the \"full\" environment of an article (i.e.,
the result of the accommodator).

ENVIRONMENT-KIND indicates what kind of environment ENVIRONMENT is,
e.g., constructor environment, notation environment, etc."))

(defparameter *environment-kinds*
  '("aco" "atr" "eno" "dfs" "ecl" "eid")
  "File extensions of known environment files generated by the
  accommodator.")

;; (defmethod verifiable-wrt-environment ((article pathname)
;; 				       (environment-kind stringl)
;; 				       (environment string))
;;   (unless (member article-kind *environment-kinds* :test #'string=)
;;     (error "The article kind '~a' is not a known envionment kind; the known kinds are:~%~%~{* ~a~%~}" *environment-kinds*)))

(defgeneric minimize-environment-for-article (article environment)
  (:documentation "Given ENVIRONMENT for ARTICLE, compute the smallest subenvironment of ENVIRONMENT with respect to which ARTICLE is MIZAR verifiable."))

(defmethod minimize-environment-for-article ((article pathname)
					     (environment pathname))
  (flet ((verifiable-wrt-environment (environment))
	 (handler-case
	     (verifier article :flags '("-q" "-l"))
	   (mizar-error () nil)))))

(defmethod minimize :around ((article pathname))
  (if (file-exists-p article)
      (call-next-method)
      (error "There is no article at '~a'." article)))

(defmethod minimize ((article-path pathname))
  (minimize (make-instance 'article
			   :path article-path)))

(defparameter *extension-to-root-element-table*
  (let ((table (make-hash-table :test #'equal)))
    (setf (gethash "eno" table) "Notations"
	  (gethash "erd" table) "ReductionRegistrations"
	  (gethash "epr" table) "PropertyRegistration" ; sic
	  (gethash "dfs" table) "Definientia"
	  (gethash "eid" table) "IdentifyRegistrations"
	  (gethash "ecl" table) "Registrations"
	  (gethash "esh" table) "Schemes"
	  (gethash "eth" table) "Theorems")
    table)
  "A hash table mapping Mizar file extensions for XML files to the expected root elements of these files.")

(defgeneric minimize-extension (article extension))

(defmethod minimize-extension :around ((article article) (extension string))
  (multiple-value-bind (root present?)
      (gethash extension *extension-to-root-element-table*)
    (declare (ignore root))
    (if present?
	(call-next-method)
	(error "The extension '~a' is not registered in the root element table." extension))))

(defmethod minimize-extension ((article article) (extension string))
  (let* ((file-to-minimize (file-with-extension article extension)))
    (if (file-exists-p file-to-minimize)
	(let* ((safe-sha1 (ironclad:digest-file :sha1 file-to-minimize))
	       (doc (cxml:parse-file file-to-minimize (cxml-dom:make-dom-builder)))
	       (document-element (dom:document-element doc))
	       (nodes (dom:child-nodes document-element)))
	  (flet ((analyzable-and-has-same-meaning (dummy)
		   (declare (ignore dummy))
		   (when (analyzer article)
		     (let ((new-sha1 (ironclad:digest-file :sha1 file-to-minimize)))
		       (starts-with-subseq new-sha1 safe-sha1))))
		 (write-new-nodes (new-nodes)
		   (let ((new-doc (cxml-dom:create-document document-element)))
		     (dolist (node new-nodes)
		       (dom:append-child node document-element))
		     (with-open-file
			 (xml-file
			  file-to-minimize
			  :direction :output
			  :if-exists :supersede
			  :element-type '(unsigned-byte 8))
		       (dom:map-document (cxml:make-octet-stream-sink xml-file)
					 new-doc)))))
	    (minimal-sublist-satisfying nodes #'analyzable-and-has-same-meaning
					:change-hook #'write-new-nodes))))))

(defgeneric minimize-notations (article))

(defmethod minimize-notations ((article article))
  (minimize-extension article "eno"))

(defgeneric minimize-reductions (article))

(defmethod minimize-reductions ((article article))
  (minimize-extension article "erd"))

(defgeneric minimize-property-registrations (article))

(defmethod minimize-property-registrations ((article article))
  (minimize-extension article "epr"))

(defgeneric minimize-definientia (article))

(defmethod minimize-definientia ((article article))
  (minimize-extension article "dfs"))

(defgeneric minimize-identifications (article))

(defmethod minimize-identifications ((article article))
  (minimize-extension article "eid"))

(defgeneric minimize-clusters (article))

(defmethod minimize-clusters ((article article))
  (minimize-extension article "ecl"))

(defgeneric minimize-environment (article))

(defmethod minimize-environment ((article article))
  (minimize-notations article)              ;; .eno
  (minimize-reductions article)             ;; .erd
  (minimize-property-registrations article) ;; .epr
  (minimize-definientia article)            ;; .dfs
  (minimize-identifications article)        ;; .eid
  (minimize-clusters article))              ;; .ecl


(defmethod minimize ((article article))
  (minimize-environment article)
  ;; (minimize-properties article)
  ;; (minimize-requirements article)
  )

(defgeneric minimize-requirements (article &optional working-directory)
  (:documentation "From the explicitly required set of requirements
  for ARTICLE, compute the smallest subset with respect to which the article is still verifiable.  Verification will take place in WORKING-DIRECTORY, if supplied."))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Minimizing requirements
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defgeneric requirements-of-article (article)
  (:documentation "The contents of the requirements environment directive of ARTICLE."))

(defmethod requirements-of-article :around ((article-path pathname))
  (if (file-exists-p article-path)
      (let ((evl-file (replace-extension article-path "miz" "evl")))
	(if (file-exists-p evl-file)
	    (call-next-method)
	    (error "The .evl file for~%~%  ~a~%~%does not exist at the expected location~%~%  ~a~%" article-path evl-file)))
      (error "The file~%~%  ~a~%~%does not exist~%" article-path)))

(defgeneric minimize-requirements-of-itemized-db (miz-db)
  (:documentation "Minimize the requirements of every article fragment appearing under MIZ-DB."))

(defmethod minimize-requirements-of-itemized-db :around ((miz-db-path pathname))
  (if (file-exists-p miz-db-path)
      (if (directory-pathname-p miz-db-path)
	  (let ((text-subdir (merge-pathnames "text/" miz-db-path)))
	    (if (file-exists-p text-subdir)
		(call-next-method)
		(error "The supplied mizar database directory,~%~%  ~a~%~%lacks a text subdirectory!~%" miz-db-path)))
	  (error "The supplied mizar database directory,~%~%  ~a~%~%is not actually a directory!~%" miz-db-path))
      (error "The mizar database directory~%~%  ~a~%~%does not exist!~%" miz-db-path)))

(defmethod minimize-requirements-of-itemized-db ((miz-db-path pathname))
  (loop
     with text-subdir = (merge-pathnames "text/" miz-db-path)
     with ckbs = (directory (merge-pathnames "ckb*.miz" text-subdir))
     for ckb in ckbs
     do
       (minimize-requirements ckb miz-db-path)
     finally
       (return t)))

(defun minimize-requirements-of-itemized-db-no-errors (miz-db-path)
  (handler-case
      (progn
	(handler-bind ((warning #'muffle-warning))
	  (minimize-requirements-of-itemized-db miz-db-path))
	(format t "~a: success~%" miz-db-path)
	t)
      (error ()
	(format *error-output* "~a: failure~%" miz-db-path))))

;;; minimize.lisp ends here
