stylesheet "1.0";
import "utils/die.xsl";
import "utils/copy.xsl";
output method="xml" indent="yes";

// conditions
$consistency-lemma   = "ConsistencyLemma";
$existence-lemma     = "ExistenceLemma";
$uniqueness-lemma    = "UniquenessLemma";
$coherence-lemma     = "CoherenceLemma";
$compatibility-lemma = "CompatibilityLemma";

// function properties
$projectivity-lemma   = "ProjectivityLemma";
$involutiveness-lemma = "InvolutivenessLemma";
$idempotence-lemma    = "IdempotenceLemma";
$commutativity-lemma  = "CommutativityLemma";

// predicate properties
$reflexivity-lemma    = "ReflexivityLemma";
$irreflexivity-lemma  = "IrreflexivityLemma";
$symmetry-lemma       = "SymmetryLemma";
$asymmetry-lemma      = "AsymmetryLemma";
$connectedness-lemma  = "ConnectednessLemma";

// mode properties
$sethood-lemma = "SethoodLemma";

tpl try-fresh-variable (#prefix, #try) {
  $trial-name = `concat ($prefix, $try)`;
  $next-try = `$try + 1`;
  choose {
    when [descendant::Simple-Term[@spelling = $trial-name]] {
      try-fresh-variable (#prefix = $prefix,
                          #try = $next-try);
    }
    when [descendant::Variable[@spelling = $trial-name]] {
      try-fresh-variable (#prefix = $prefix,
                          #try = $next-try);
    }
    otherwise {
      $trial-name;
    }
  }
}

tpl fresh-variable (#prefix) {
  for-each [ancestor::Text-Proper] {
    if [$prefix = ""] {
      try-fresh-variable (#prefix = "z", #try = "1");
    } else {
      try-fresh-variable (#prefix = $prefix, #try = "1");
    }
  }
}

tpl emit-conjunction-of-attributive-adjectives (#term-name, #adjectives) {
  choose {
    when [count ($adjectives) = 0] {
      die (#message = "Error: zero adjectives were given.");
    }
    when [count ($adjectives) = 1] {
      $adjective = `$adjectives[1]`;
      <Attributive-Formula {
        <Simple-Term {
          @spelling = $term-name;
        }
        apply [$adjective];
      }
    }
    otherwise {
      $first-adjective = `$adjectives[1]`;
      $remaining-adjectives = `$adjectives[position () > 1]`;
      <Conjunctive-Formula {
        <Attributive-Formula {
          <Simple-Term {
            @spelling = $term-name;
          }
          apply [$first-adjective];
        }
        emit-conjunction-of-attributive-adjectives (#term-name = $term-name,
                                                    #adjectives = $remaining-adjectives);
      }
    }
  }
}

// By default, copy
tpl [*] {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

// Sanity check
tpl [Text-Proper] {
  if [count (descendant::Implicitly-Qualified-Segment) > 0] {
    die (#message = "There are not supposed to be any Implicitly-Qualified-Segments");
  } else {
    <Text-Proper {
      for-each [@*] { copy-of `.`; }
      apply [*];
    }
  }
}

tpl universally-bind-conjunction-of-adjectives (#adjectives,
                                                #it,
                                                #type,
                                                #segments) {
  $num-adjectives = `count ($adjectives)`;
  // msg `concat ($num-adjectives, " adjectives")`;
  if [count ($segments) = 0] {
    <Existential-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable {
            @spelling = $it;
          }
        }
        apply [$type];
      }
      emit-conjunction-of-attributive-adjectives (#term-name  = $it,
                                                  #adjectives = $adjectives);
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-conjunction-of-adjectives (#segments   = $rest,
                                                  #type       = $type,
                                                  #it         = $it,
                                                  #adjectives = $adjectives);
    }
  }
}

tpl
[
  Item
  [
        @kind = "Definition-Item"
    and Block
        [
              @kind = "Registration-Block"
          and Item
              [
                    @kind = "Cluster"
                and Existential-Registration
              ]
          and Item
              [
                    @kind = "Correctness-Condition"
                and Block[@kind = "Proof"]
              ]
        ]
 ]
] {
  // Emit a lemma before the condition
  $fresh-variable = fresh-variable (#prefix = "Z");
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "Existence"; }
      for-each [Block[@kind = "Registration-Block"]] {
        $locus = `Item[@kind = "Loci-Declaration"]`;
        $segments = `$locus/Explicitly-Qualified-Segment`;
        $cluster = `Item[@kind = "Cluster"]`;
        $exreg = `$cluster/Existential-Registration`;
        $adcluster = `$exreg/Adjective-Cluster`;
        $type = `$exreg/*[position() = last()]`;
        $adjectives = `$adcluster/Adjective | $adcluster/NegatedAdjective`;
        universally-bind-conjunction-of-adjectives
          (#segments   = $segments,
           #type       = $type,
           #adjectives = $adjectives,
           #it         = $fresh-variable);
      }
    }
    for-each [Block[@kind = "Registration-Block"]] {
      for-each [Item[@kind = "Correctness-Condition"]] {
        for-each [Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Registration-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Cluster"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl
[
  Block
  [
        @kind = "Proof"
    and parent::Item
        [
              @kind      = "Correctness-Condition"
          and @condition = "existence"
          and parent::Block
              [
                    @kind = "Registration-Block"
                and parent::Item
                    [
                          @kind = "Definition-Item"
                      and parent::Text-Proper
                    ]
              ]
        ]
  ]
]
{
  <Straightforward-Justification { <Local-Reference { @spelling = "Existence"; } }
}

tpl universally-bind-conditional-registration (#cluster-1,
                                               #cluster-2,
                                               #it,
                                               #type,
                                               #segments) {
  if [count ($segments) = 0] {
    <Universal-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables { <Variable { @spelling = $it; } }
        apply [$type];
      }
      if [count ($cluster-1/*) > 0] {
        <Conditional-Formula {
          <Attributive-Formula {
            <Simple-Term { @spelling = $it; }
            apply [$cluster-1];
          }
          <Attributive-Formula {
            <Simple-Term { @spelling = $it; }
            apply [$cluster-2];
          }
        }
      } else {
        <Attributive-Formula {
          <Simple-Term { @spelling = $it; }
          apply [$cluster-2];
        }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-conditional-registration (#segments  = $rest,
                                                 #type      = $type,
                                                 #it        = $it,
                                                 #cluster-1 = $cluster-1,
                                                 #cluster-2 = $cluster-2);
    }
  }
}

tpl
[
  Item
  [
        @kind = "Definition-Item"
    and Block
        [
              @kind = "Registration-Block"
          and Item
              [
                    @kind = "Cluster"
                and Conditional-Registration
              ]
          and Item
              [
                    @kind = "Correctness-Condition"
                and Block[@kind = "Proof"]
              ]
        ]
 ]
] {
  // Emit a lemma before the condition
  $fresh-variable = fresh-variable (#prefix = "Z");
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "Conditional"; }
      for-each [Block[@kind = "Registration-Block"]] {
        $locus = `Item[@kind = "Loci-Declaration"]`;
        $segments = `$locus/Explicitly-Qualified-Segment`;
        $cluster = `Item[@kind = "Cluster"]`;
        $condreg = `$cluster/Conditional-Registration`;
        $cluster-1 = `$condreg/Adjective-Cluster[1]`;
        $cluster-2 = `$condreg/Adjective-Cluster[2]`;
        $type = `$condreg/*[position() = last()]`;
        universally-bind-conditional-registration
          (#segments  = $segments,
           #cluster-1 = $cluster-1,
           #cluster-2 = $cluster-2,
           #type      = $type,
           #it        = $fresh-variable);
      }
    }
    for-each [Block[@kind = "Registration-Block"]] {
      for-each [Item[@kind = "Correctness-Condition"]] {
        for-each [Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Registration-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Cluster"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl
[
  Item
  [
        @kind = "Definition-Item"
    and Block
        [
              @kind = "Registration-Block"
          and Item
              [
                    @kind = "Cluster"
                and Conditional-Registration
              ]
          and Item
              [
                    @kind = "Correctness-Condition"
                and Straightforward-Justification
              ]
        ]
 ]
] {
  // Emit a lemma before the condition
  $fresh-variable = fresh-variable (#prefix = "Z");
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "Conditional"; }
      for-each [Block[@kind = "Registration-Block"]] {
        $locus = `Item[@kind = "Loci-Declaration"]`;
        $segments = `$locus/Explicitly-Qualified-Segment`;
        $cluster = `Item[@kind = "Cluster"]`;
        $condreg = `$cluster/Conditional-Registration`;
        $cluster-1 = `$condreg/Adjective-Cluster[1]`;
        $cluster-2 = `$condreg/Adjective-Cluster[2]`;
        $type = `$condreg/*[position() = last()]`;
        universally-bind-conditional-registration
          (#segments  = $segments,
           #cluster-1 = $cluster-1,
           #cluster-2 = $cluster-2,
           #type      = $type,
           #it        = $fresh-variable);
      }
    }
    <Straightforward-Justification {
      for-each [Block[@kind = "Registration-Block"]] {
        for-each [Item[@kind = "Correctness-Condition"]] {
          for-each [Straightforward-Justification] {
            apply [*];
          }
        }
      }
    }
  }
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl
[
  Block
  [
        @kind = "Proof"
    and parent::Item
        [
              @kind      = "Correctness-Condition"
          and @condition = "coherence"
          and preceding-sibling::Item
              [
                      @kind = "Cluster"
                  and Conditional-Registration
              ]
          and parent::Block
              [
                    @kind = "Registration-Block"
                and parent::Item
                    [
                          @kind = "Definition-Item"
                      and parent::Text-Proper
                    ]
              ]
        ]
  ]
]
{
  <Straightforward-Justification { <Local-Reference { @spelling = "Conditional"; } }
}

tpl
[
  Straightforward-Justification
  [
      parent::Item
      [
            @kind      = "Correctness-Condition"
        and @condition = "coherence"
        and preceding-sibling::Item
            [
                    @kind = "Cluster"
                and Conditional-Registration
            ]
        and parent::Block
            [
                  @kind = "Registration-Block"
              and parent::Item
                  [
                        @kind = "Definition-Item"
                    and parent::Text-Proper
                  ]
            ]
      ]
  ]
]
{
  <Straightforward-Justification { <Local-Reference { @spelling = "Conditional"; } }
}

tpl universally-bind-reduction (#segments, #lhs, #rhs) {
  if [count ($segments) = 0] {
    <Predicative-Formula {
      @spelling = "=";
      <Arguments {
        apply [$lhs];
      }
      <Arguments {
        apply [$rhs];
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-reduction (#segments = $rest,
                                  #lhs      = $lhs,
                                  #rhs      = $rhs);
    }
  }
}

tpl
[
  Item
  [
        @kind = "Definition-Item"
    and Block
        [
              @kind = "Registration-Block"
          and Item
              [
                    @kind = "Reduction"
              ]
          and Item
              [
                    @kind = "Correctness-Condition"
                and @condition = "reducibility"
                and Straightforward-Justification
              ]
        ]
 ]
] {
  // Emit a lemma before the condition
  $fresh-variable = fresh-variable (#prefix = "Z");
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "Reducibility"; }
      for-each [Block[@kind = "Registration-Block"]] {
        $locus = `Item[@kind = "Loci-Declaration"]`;
        $segments = `$locus/Explicitly-Qualified-Segment`;
        $reduction = `Item[@kind = "Reduction"]`;
        $lhs = `$reduction/*[2]`;
        $rhs = `$reduction/*[1]`;
        universally-bind-reduction (#segments = $segments,
                                    #lhs      = $lhs,
                                    #rhs      = $rhs);
      }
    }
    for-each [Block[@kind = "Registration-Block"]] {
      for-each [Item[@kind = "Correctness-Condition"]] {
        for-each [Straightforward-Justification] {
          <Straightforward-Justification {
            apply [*];
          }
        }
      }
    }
  }
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl
[
  Item
  [
        @kind = "Definition-Item"
    and Block
        [
              @kind = "Registration-Block"
          and Item
              [
                    @kind = "Reduction"
              ]
          and Item
              [
                    @kind = "Correctness-Condition"
                and Block[@kind = "Proof"]
              ]
        ]
 ]
] {
  // Emit a lemma before the condition
  $fresh-variable = fresh-variable (#prefix = "Z");
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "Reducibility"; }
      for-each [Block[@kind = "Registration-Block"]] {
        $locus = `Item[@kind = "Loci-Declaration"]`;
        $segments = `$locus/Explicitly-Qualified-Segment`;
        $reduction = `Item[@kind = "Reduction"]`;
        $lhs = `$reduction/*[2]`;
        $rhs = `$reduction/*[1]`;
        universally-bind-reduction (#segments = $segments,
                                    #lhs      = $lhs,
                                    #rhs      = $rhs);
      }
    }
    for-each [Block[@kind = "Registration-Block"]] {
      for-each [Item[@kind = "Correctness-Condition"]] {
        for-each [Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Registration-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Reduction"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl
[
  Block
  [
        @kind = "Proof"
    and parent::Item
        [
              @kind      = "Correctness-Condition"
          and @condition = "reducibility"
          and parent::Block
              [
                    @kind = "Registration-Block"
                and parent::Item
                    [
                          @kind = "Definition-Item"
                      and parent::Text-Proper
                    ]
              ]
        ]
  ]
]
{
  <Straightforward-Justification { <Local-Reference { @spelling = "Reducibility"; } }
}

tpl
[
  Straightforward-Justification
  [
      parent::Item
      [
            @kind      = "Correctness-Condition"
        and @condition = "reducibility"
        and parent::Block
            [
                  @kind = "Registration-Block"
              and parent::Item
                  [
                        @kind = "Definition-Item"
                    and parent::Text-Proper
                  ]
            ]
      ]
  ]
]
{
  <Straightforward-Justification {
    <Local-Reference { @spelling = "Reducibility"; }
    apply [*];
  }
}

tpl universally-bind-segments-existential-assumption-existence (#segments,
                                                                #it,
                                                                #formula,
                                                                #type,
                                                                #assumption) {
  if [count ($segments) = 0] {
    <Conditional-Formula {
      for-each [$assumption] {
        <Existential-Quantifier-Formula {
          apply [Explicitly-Qualified-Segment];
          for-each [Conditions] {
            for-each [Proposition] {
              apply [*[position() = last()]];
            }
          }
        }
      }
      <Existential-Quantifier-Formula {
        <Explicitly-Qualified-Segment {
           <Variables { <Variable { @spelling = $it; } }

          if [$type] {
            apply [$type];
          } else {
            <Standard-Type { @nr = "1"; @spelling = "set"; }
          }

         }

         for-each [$formula] {
          if [Partial-Definiens] {
            die (#message = "We do not yet handle partial definientia made under an assumption.");
          } else {
            apply [.] (#it = $it) mode="replace-it-term";
          }
        }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-existential-assumption-existence (#segments   = $rest,
                                                                  #it         = $it,
                                                                  #formula    = $formula,
                                                                  #type       = $type,
                                                                  #assumption = $assumption);
    }
  }
}

tpl universally-bind-segments-function-means-existence-partial (#segments,
                                                                #default,
                                                                #partial-definientia,
                                                                #original-definientia,
                                                                #type) {
  if [count ($segments) = 0] {
    choose {
      when [count ($partial-definientia) < 1] {
        // nothing to do
      }
      when [count ($partial-definientia) = 1] {
        $fresh = fresh-variable ();
        $definiens-1 = `$partial-definientia[1]`;
        $value-1 = `$definiens-1/*[1]`;
        $condition-1 = `$definiens-1/*[2]`;
        <Conjunctive-Formula {
          <Conditional-Formula {
            apply [$condition-1];
            <Existential-Quantifier-Formula {
              <Explicitly-Qualified-Segment {
                <Variables { <Variable { @spelling = $fresh; } }
                type-or-set (#type = $type);
              }
              apply [$value-1] (#it = $fresh) mode="replace-it-term";
            }
          }
          <Conditional-Formula {
            conjunction-of-negated-partial-definientia (#definientia = $original-definientia);
            <Existential-Quantifier-Formula {
              <Explicitly-Qualified-Segment {
                <Variables { <Variable { @spelling = $fresh; } }
                type-or-set (#type = $type);
              }
              apply [$default] (#it = $fresh) mode="replace-it-term";
            }
          }
        }
      }
      when [count ($partial-definientia) > 1] {
        $definiens-1 = `$partial-definientia[1]`;
        $more-partial-definientia = `$partial-definientia[position() > 1]`;
        $value-1 = `$definiens-1/*[1]`;
        $condition-1 = `$definiens-1/*[2]`;
        $fresh = fresh-variable ();
        <Conjunctive-Formula {
          <Conditional-Formula {
            apply [$condition-1];
            <Existential-Quantifier-Formula {
              <Explicitly-Qualified-Segment {
                <Variables { <Variable { @spelling = $fresh; } }
                type-or-set (#type = $type);
              }
              apply [$value-1] (#it = $fresh) mode="replace-it-term";
            }
          }
          universally-bind-segments-function-means-existence-partial
            (#partial-definientia  = $more-partial-definientia,
             #original-definientia = $original-definientia,
             #type                 = $type,
             #default              = $default,
             #segments             = $segments);
        }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-function-means-existence-partial
        (#segments             = $rest,
         #type                 = $type,
         #partial-definientia  = $partial-definientia,
         #original-definientia = $original-definientia,
         #default              = $default);
    }
  }
}

tpl universally-bind-segments-function-means-uniqueness-partial (#segments,
                                                                 #default,
                                                                 #partial-definientia,
                                                                 #original-definientia,
                                                                 #variable-1,
                                                                 #variable-2,
                                                                 #type) {
  if [count ($segments) = 0] {
    choose {
      when [count ($partial-definientia) = 0] {
        <Conditional-Formula {
          <Conjunctive-Formula {
            conjunction-of-negated-partial-definientia (#definientia = $original-definientia);
            <Conjunctive-Formula {
              apply [$default] (#it = $variable-1) mode="replace-it-term";
              apply [$default] (#it = $variable-2) mode="replace-it-term";
            }
          }
          <Predicative-Formula {
            @spelling = "=";
            <Arguments { <Simple-Term { @spelling = $variable-1; } }
            <Arguments { <Simple-Term { @spelling = $variable-2; } }
          }
        }
      }
      when [count ($partial-definientia) > 0] {
        $definiens-1 = `$partial-definientia[1]`;
        $value-1 = `$definiens-1/*[1]`;
        $condition-1 = `$definiens-1/*[2]`;
        <Conjunctive-Formula {
          <Conditional-Formula {
            <Conjunctive-Formula {
              apply [$condition-1];
              <Conjunctive-Formula {
                apply [$value-1] (#it = $variable-1) mode="replace-it-term";
                apply [$value-1] (#it = $variable-2) mode="replace-it-term";
              }
            }
            <Predicative-Formula {
              @spelling = "=";
              <Arguments { <Simple-Term { @spelling = $variable-1; } }
              <Arguments { <Simple-Term { @spelling = $variable-2; } }
            }
          }
          universally-bind-segments-function-means-uniqueness-partial
            (#segments             = $segments,
             #partial-definientia  = `$partial-definientia[position() > 1]`,
             #original-definientia = $original-definientia,
             #variable-1           = $variable-1,
             #variable-2           = $variable-2,
             #default              = $default,
             #type                 = $type);
        }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      if [count ($rest) = 0] {
        <Universal-Quantifier-Formula {
          <Explicitly-Qualified-Segment {
            <Variables {
              <Variable { @spelling = $variable-1; }
              <Variable { @spelling = $variable-2; }
            }
            type-or-set (#type = $type);
          }
          universally-bind-segments-function-means-uniqueness-partial
            (#segments             = $rest,
             #type                 = $type,
             #partial-definientia  = $partial-definientia,
             #original-definientia = $original-definientia,
             #variable-1           = $variable-1,
             #variable-2           = $variable-2,
             #default              = $default);
        }
      } else {
        universally-bind-segments-function-means-uniqueness-partial
          (#segments             = $rest,
           #type                 = $type,
           #partial-definientia  = $partial-definientia,
           #original-definientia = $original-definientia,
           #variable-1           = $variable-1,
           #variable-2           = $variable-2,
           #default              = $default);
      }
    }
  }
}

tpl universally-bind-segments-existence (#segments,
                                         #it,
                                         #formula,
                                         #type,
                                         #assumption) {
  if [count ($segments) = 0] {
    if [$assumption] {
      <Conditional-Formula {
        apply [$assumption];
        <Existential-Quantifier-Formula {
          <Explicitly-Qualified-Segment {
            <Variables { <Variable { @spelling = $it; } }
            type-or-set (#type = $type);
          }

          for-each [$formula] {
            if [Partial-Definiens] {
              die (#message = "We do not yet handle partial definientia made under an assumption.");
            } else {
              for-each [*[1]] {
                apply [*[position() = last()]] (#it = $it) mode="replace-it-term";
              }
            }
          }
        }
      }
    } else {
      for-each [$formula] {
        if [Partial-Definiens] {
          $alternative-val = `*[position() = last()]`;
          for-each [Partial-Definiens] {
            <Conjunctive-Formula {
              $val = `*[1]`;
              $condition = `*[position() = last()]`;
              <Conditional-Formula {
                apply [$condition];
                <Existential-Quantifier-Formula {
                  <Explicitly-Qualified-Segment {
                    <Variables { <Variable { @spelling = $it; } }
                    if [$type] {
                      apply [$type];
                    } else {
                      <Standard-Type { @nr = "1"; @spelling = "set"; }
                    }
                  }
                  apply [$val] (#it = $it) mode="replace-it-term";
                }
              }
              <Conditional-Formula {
                <Negated-Formula { apply [$condition]; }
                <Existential-Quantifier-Formula {
                  <Explicitly-Qualified-Segment {
                    <Variables { <Variable { @spelling = $it; } }
                    if [$type] {
                      apply [$type];
                    } else {
                      <Standard-Type { @nr = "1"; @spelling = "set"; }
                    }
                  }
                  apply [$alternative-val] (#it = $it) mode="replace-it-term";
                }
              }
            }
          }
        } else {
          for-each [*[position() = last()]] {
            <Existential-Quantifier-Formula {
                <Explicitly-Qualified-Segment {

                  <Variables { <Variable { @spelling = $it; } }

                  if [$type] {
                    apply [$type];
                  } else {
                    <Standard-Type { @nr = "1"; @spelling = "set"; }
                  }

                }

                apply [.] (#it = $it) mode="replace-it-term";
              }
            }
          }
        }
      }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-existence (#segments   = $rest,
                                           #it         = $it,
                                           #formula    = $formula,
                                           #type       = $type,
                                           #assumption = $assumption);
    }
  }
}

tpl equality-of-terms (#spelling-1, #spelling-2) {
  <Predicative-Formula {
    @spelling = "=";
    <Arguments { <Simple-Term { @spelling = $spelling-1; } }
    <Arguments { <Simple-Term { @spelling = $spelling-2; } }
  }
}

tpl universally-bind-segments-uniqueness (#segments,
                                          #variable-1,
                                          #variable-2,
                                          #formula,
                                          #type,
                                          #assumption) {
  if [count ($segments) = 0] {
    for-each [$formula] {
      <Universal-Quantifier-Formula {
        <Explicitly-Qualified-Segment {
          <Variables {
            <Variable { @spelling = $variable-1; }
            <Variable { @spelling = $variable-2; }
          }

          if [$type] {
            apply [$type];
          } else {
            <Standard-Type { @nr = "1"; @spelling = "set"; }
          }
        }
        if [Partial-Definiens] {
          $alternative-val = `*[position() = last()]`;
          for-each [Partial-Definiens] {
            $val = `*[1]`;
            $condition = `*[position() = last()]`;
            <Conjunctive-Formula {
              <Conditional-Formula {
                apply [$condition];
                if [$assumption] {
                  <Conditional-Formula {
                    <Conjunctive-Formula {
                      <Conditional-Formula {
                        apply [$assumption];
                        apply [$val] (#it = $variable-1) mode="replace-it-term";
                      }
                      <Conditional-Formula {
                        apply [$assumption];
                        apply [$val] (#it = $variable-2) mode="replace-it-term";
                      }
                    }
                    equality-of-terms (#spelling-1 = $variable-1,
                                       #spelling-2 = $variable-2);
                  }
                } else {
                  <Conditional-Formula {
                    <Conjunctive-Formula {
                      apply [$val] (#it = $variable-1) mode="replace-it-term";
                      apply [$val] (#it = $variable-2) mode="replace-it-term";
                    }
                    equality-of-terms (#spelling-1 = $variable-1,
                                       #spelling-2 = $variable-2);
                  }
                }
              }
              <Conditional-Formula {
                <Negated-Formula {
                  apply [$condition];
                }
                if [$assumption] {
                  <Conditional-Formula {
                    <Conjunctive-Formula {
                      <Conditional-Formula {
                        apply [$assumption];
                        apply [$alternative-val] (#it = $variable-1) mode="replace-it-term";
                      }
                      <Conditional-Formula {
                        apply [$assumption];
                        apply [$alternative-val] (#it = $variable-2) mode="replace-it-term";
                      }
                    }
                    equality-of-terms (#spelling-1 = $variable-1,
                       #spelling-2 = $variable-2);
                  }
                } else {
                  <Conditional-Formula {
                    <Conjunctive-Formula {
                      apply [$alternative-val] (#it = $variable-1) mode="replace-it-term";
                      apply [$alternative-val] (#it = $variable-2) mode="replace-it-term";
                    }
                    equality-of-terms (#spelling-1 = $variable-1,
                       #spelling-2 = $variable-2);
                  }
                }
              }
            }
          }
        } else {
          $definiens = `*[position() = last()]`;
          if [$assumption] {
            <Conditional-Formula {
              <Conjunctive-Formula {
                <Conditional-Formula {
                  apply [$assumption];
                  apply [$definiens] (#it = $variable-1) mode="replace-it-term";
                }
                <Conditional-Formula {
                  apply [$assumption];
                  apply [$definiens] (#it = $variable-2) mode="replace-it-term";
                }
              }
              equality-of-terms (#spelling-1 = $variable-1,
                                 #spelling-2 = $variable-2);
            }
          } else {
            <Conditional-Formula {
              <Conjunctive-Formula {
                apply [$definiens] (#it = $variable-1) mode="replace-it-term";
                apply [$definiens] (#it = $variable-2) mode="replace-it-term";
              }
              equality-of-terms (#spelling-1 = $variable-1,
                                 #spelling-2 = $variable-2);
            }
          }
        }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-uniqueness (#segments   = $rest,
                                            #variable-1 = $variable-1,
                                            #variable-2 = $variable-2,
                                            #formula    = $formula,
                                            #type       = $type,
                                            #assumption = $assumption);
    }
  }
}

tpl universally-bind-segments-compatibility (#segments,
                                             #original-formula,
                                             #new-formula,
					     #it,
					     #shape,
					     #value-type)
{
  if [count ($segments) = 0] {
    msg `concat ("compatibility with shape = ", $shape)`;
    if [$it] {
      msg `concat ("it = ", $it)`;
      <Universal-Quantifier-Formula {
        <Explicitly-Qualified-Segment {
          <Variables {
            <Variable { @spelling = $it; }
          }

          if [$value-type] {
            apply [$value-type];
          } else {
            <Standard-Type { @nr = "1"; @spelling = "set"; }
          }
        }
        <Biconditional-Formula {
          <Predicative-Formula {
            @spelling = "=";
            <Arguments {
              <Simple-Term { @spelling = $it; }
            }
            <Arguments {
              apply [$original-formula];
            }
          }
          if [$shape = "Means"] {
	    msg `concat ("shape is Means; it = ", $it)`;
            apply [$new-formula] (#it = $it) mode="replace-it-term";
          } else {
            <Predicative-Formula {
              @spelling = "=";
              <Arguments {
                <Simple-Term { @spelling = $it; }
              }
              <Arguments {
                apply [$new-formula];
              }
            }
          }
        }
      }
    } else {
      msg "it is unset.";
      <Biconditional-Formula {
        apply [$original-formula];
        apply [$new-formula];
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-compatibility
        (#segments         = $rest,
         #original-formula = $original-formula,
         #new-formula      = $new-formula,
	 #it               = $it,
	 #shape            = $shape,
	 #value-type       = $value-type);
    }
  }
}

tpl universally-bind-segments-commutativity (#segments,
                                             #formula,
                                             #type,
                                             #it,
                                             #shape,
                                             #arg-type,
                                             #arg-1,
                                             #arg-2) {
  if [count ($segments) = 0] {
    choose {
      when [$shape = "Means"] {
        <Universal-Quantifier-Formula {

          <Explicitly-Qualified-Segment {
            <Variables {
              <Variable { @spelling = $it; }
            }

            if [$arg-type] {
              apply [$arg-type];
            } else {
              <Standard-Type { @nr = "1"; @spelling = "set"; }
            }

          }

          <Universal-Quantifier-Formula {
            <Explicitly-Qualified-Segment {
              <Variables {
                <Variable { @spelling = `$arg-1`; }
                <Variable { @spelling = `$arg-2`; }
              }

              if [$arg-type] {
                apply [$arg-type];
              } else {
                <Standard-Type { @nr = "1"; @spelling = "set"; }
              }

            }

            <Conditional-Formula {
              apply [$formula] (#it = $it) mode="replace-it-term";
              apply [$formula] (#x  = $arg-1,
                            #y  = $arg-2,
                            #it = $it) mode="swap";
            }
          }
        }
      }
      when [$shape = "Equals"] {
        <Universal-Quantifier-Formula {
          <Explicitly-Qualified-Segment {
            <Variables {
              <Variable { @spelling = `$arg-1`; }
              <Variable { @spelling = `$arg-2`; }
            }

            if [$arg-type] {
              apply [$arg-type];
            } else {
              <Standard-Type { @nr = "1"; @spelling = "set"; }
            }

          }

          <Predicative-Formula {
             @spelling = "=";
             <Arguments {
               apply [$formula] (#it = $it) mode="replace-it-term";
             }
             <Arguments {
               apply [$formula] (#x  = $arg-1,
                                 #y  = $arg-2,
                                 #it = $it) mode="swap";
            }
          }
        }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-commutativity (#segments = $rest,
                                               #formula  = $formula,
                                               #type     = $type,
                                               #it       = $it,
                                               #shape    = $shape,
                                               #arg-type = $arg-type,
                                               #arg-1    = $arg-1,
                                               #arg-2    = $arg-2);
    }
  }
}

tpl universally-bind-segments-projectivity (#segments,
                                             #formula,
                                             #type,
                                             #it,
                                             #shape,
                                             #arg,
                                             #arg-type) {
  if [count ($segments) = 0] {
    choose {
      when [$shape = "Means"] {
        <Universal-Quantifier-Formula {

          <Explicitly-Qualified-Segment {
            <Variables { <Variable { @spelling = $it; } }

            if [$type] {
              apply [$type];
            } else {
              <Standard-Type { @nr = "1"; @spelling = "set"; }
            }

          }

          <Universal-Quantifier-Formula {
            <Explicitly-Qualified-Segment {
              <Variables { <Variable { @spelling = $arg; } }

              if [$arg-type] {
                apply [$arg-type];
              } else {
                <Standard-Type { @nr = "1"; @spelling = "set"; }
              }

            }

            <Conditional-Formula {
              apply [$formula] (#it = $it) mode="replace-it-term";
              apply [$formula] (#it = $arg) mode="replace-it-term";
            }
          }
        }
      }
      when [$shape = "Equals"] {
        <Universal-Quantifier-Formula {
          <Explicitly-Qualified-Segment {
            <Variables {
              <Variable { @spelling = `$arg`; }
            }

            if [$arg-type] {
              apply [$arg-type];
            } else {
              <Standard-Type { @nr = "1"; @spelling = "set"; }
            }

          }

          <Predicative-Formula {
             @spelling = "=";
             <Arguments {
               apply [$formula] (#it = $it) mode="replace-it-term";
             }
             <Arguments {
               apply [$formula] (#it = $arg);
            }
          }
        }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-projectivity (#segments = $rest,
                                               #formula  = $formula,
                                               #type     = $type,
                                               #it       = $it,
                                               #shape    = $shape,
                                               #arg-type = $arg-type,
                                               #arg      = $arg);
    }
  }
}

tpl universally-bind-segments-coherence (#segments,
                                         #formula,
                                         #type)
{
  if [count ($segments) = 0] {
    <Attributive-Formula {
      apply [$formula];

      if [$type] {
        apply [$type];
      } else {
        <Standard-Type { @nr = "1"; @spelling = "set"; }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-coherence (#segments = $rest,
                                           #formula  = $formula,
                                           #type     = $type);
    }
  }
}

tpl universally-bind-segments-conditional-coherence (#segments,
                                                     #formula,
                                                     #adjective,
                                                     #type)
{
  if [count ($segments) = 0] {
    $fresh = fresh-variable ();
    <Universal-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable {
            @spelling = $fresh;
          }
        }
        if [$type] {
          apply [$type];
        } else {
          <Standard-Type { @nr = "1"; @spelling = "set"; }
        }
      }
      <Attributive-Formula {
        apply [$formula];
        apply [$adjective];
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-conditional-coherence (#segments  = $rest,
                                                       #formula   = $formula,
                                                       #adjective = $adjective,
                                                       #type      = $type);
    }
  }
}

tpl type-or-set (#type) {
  if [$type] {
    apply [$type];
  } else {
    <Standard-Type { @nr = "1"; @spelling = "set"; }
  }
}

tpl conjunction-of-negated-partial-definientia (#definientia) {
  if [count ($definientia) > 0] {
    $partial-definiens = `$definientia[1]`;
    $condition = `$partial-definiens/*[2]`;
    if [count ($definientia) > 1] {
      <Conjunctive-Formula {
        <Negated-Formula { apply [$condition]; }
        conjunction-of-negated-partial-definientia (#definientia = `$definientia[position() > 1]`);
      }
    } else {
      <Negated-Formula { apply [$condition]; }
    }
  }
}

tpl universally-bind-segments-coherence-partial-function-definiens (#segments,
                                                                    #default,
                                                                    #original-definientia,
                                                                    #definientia,
                                                                    #type)
{
  if [count ($segments) = 0] {
    if [count ($definientia) = 0] {
      msg terminate="yes" "Error: arrived at an unexpected state computing coherence.";
    } else {
      $partial-definiens = `$definientia[1]`;
      $case = `$partial-definiens/*[2]`;
      $val = `$partial-definiens/*[1]`;
      <Conjunctive-Formula {
        <Conditional-Formula {
          apply [$case];
          <Attributive-Formula {
            apply [$val];
            type-or-set (#type = $type);
          }
        }
        if [count ($definientia) > 1] {
          universally-bind-segments-coherence-partial-function-definiens
            (#segments = $segments,
             #default = $default,
             #original-definientia = $original-definientia,
             #definientia = `$definientia[position() > 1]`,
             #type = $type);
        } else {
          <Conditional-Formula {
            conjunction-of-negated-partial-definientia (#definientia = $original-definientia);
            <Attributive-Formula {
              apply [$default];
              type-or-set (#type = $type);
            }
          }
        }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-coherence-partial-function-definiens
        (#segments = $rest,
         #default = $default,
         #original-definientia = $original-definientia,
         #definientia = $definientia,
         #type = $type);
    }
  }
}

tpl universally-bind-segments-involutiveness (#segments,
                                              #formula,
                                              #type,
                                              #shape,
                                              #arg-type,
                                              #arg-1) {
  if [count ($segments) = 0] {
    $value-1 = fresh-variable (#prefix = "u");
    $value-2 = fresh-variable (#prefix = "v");
    choose {
      when [$shape = "Means"] {
        <Universal-Quantifier-Formula {
          <Explicitly-Qualified-Segment {
            <Variables {
              <Variable { @spelling = $value-1; }
              <Variable { @spelling = $value-2; }
            }

            if [$arg-type] {
              apply [$arg-type];
            } else {
              <Standard-Type { @nr = "1"; @spelling = "set"; }
            }

          }

          <Conditional-Formula {
            apply [$formula] (#x  = $arg-1,
                              #y  = $value-2,
                              #it = $value-1) mode="replace";
            apply [$formula] (#x  = $arg-1,
                              #y  = $value-1,
                              #it = $value-2) mode="replace";
          }
        }
      }
      when [$shape = "Equals"] {
        <Universal-Quantifier-Formula {
          <Explicitly-Qualified-Segment {
            <Variables {
              <Variable { @spelling = $value-1; }
              <Variable { @spelling = $value-2; }
            }

            if [$arg-type] {
              apply [$arg-type];
            } else {
              <Standard-Type { @nr = "1"; @spelling = "set"; }
            }

          }

          <Conditional-Formula {
            <Predicative-Formula {
              @spelling = "=";
              <Arguments {
                <Simple-Term { @spelling = $value-1; }
              }
              <Arguments {
                apply [$formula] (#target = $arg-1, #val = $value-2) mode="plug-in";
              }
            }
            <Predicative-Formula {
               @spelling = "=";
               <Arguments {
                 <Simple-Term { @spelling = $value-2; }
               }
               <Arguments {
                apply [$formula] (#target = $arg-1, #val = $value-1) mode="plug-in";
              }
            }
          }
        }
      }
      otherwise {
        die (#message = `concat ("Unknown shape '", $shape, "' for involutiveness.")`);
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-involutiveness (#segments = $rest,
                                                #formula  = $formula,
                                                #type     = $type,
                                                #shape    = $shape,
                                                #arg-type = $arg-type,
                                                #arg-1    = $arg-1);
    }
  }
}

tpl universally-bind-segments-idempotence (#segments,
                                           #formula,
                                           #type,
                                           #it,
                                           #shape,
                                           #arg-type,
                                           #arg-1,
                                           #arg-2) {
  if [count ($segments) = 0] {
    choose {
      when [$shape = "Means"] {
        <Universal-Quantifier-Formula {

          <Explicitly-Qualified-Segment {
            <Variables { <Variable { @spelling = $it; } }

            if [$arg-type] {
              apply [$arg-type];
            } else {
              <Standard-Type { @nr = "1"; @spelling = "set"; }
            }

          }

          <Universal-Quantifier-Formula {
            <Explicitly-Qualified-Segment {
              <Variables { <Variable { @spelling = `$arg-1`; } }

              if [$arg-type] {
                apply [$arg-type];
              } else {
                <Standard-Type { @nr = "1"; @spelling = "set"; }
              }

            }
            apply [$formula] (#x  = $arg-2,
                              #y  = $arg-1,
                              #it = $arg-1) mode="replace";
          }
        }
      }
      when [$shape = "Equals"] {
        die (#message = "We don't yet handle idempotence for functors defined by an equation.");
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-idempotence (#segments = $rest,
                                             #formula  = $formula,
                                             #type     = $type,
                                             #shape    = $shape,
                                             #it       = $it,
                                             #arg-type = $arg-type,
                                             #arg-1    = $arg-1,
                                             #arg-2    = $arg-2);
    }
  }
}

tpl universally-bind-segments-symmetry (#segments,
                                        #formula,
                                        #it,
                                        #arg-type,
                                        #arg-1,
                                        #arg-2) {
  if [count ($segments) = 0] {
    <Universal-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable { @spelling = `$arg-1`; }
          <Variable { @spelling = `$arg-2`; }
        }

         if [$arg-type] {
           apply [$arg-type];
        } else {
          <Standard-Type { @nr = "1"; @spelling = "set"; }
        }
      }

      <Conditional-Formula {
        apply [$formula];
        apply [$formula] (#x  = $arg-1,
                          #y  = $arg-2,
                          #it = $it) mode="swap";
      }
    }

  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-symmetry (#segments = $rest,
                                          #formula  = $formula,
                                          #it       = $it,
                                          #arg-type = $arg-type,
                                          #arg-1    = $arg-1,
                                          #arg-2    = $arg-2);
    }
  }
}

tpl universally-bind-segments-connectedness (#segments,
                                             #formula,
                                             #it,
                                             #arg-type,
                                             #arg-1,
                                             #arg-2) {
  if [count ($segments) = 0] {
    <Universal-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable { @spelling = `$arg-1`; }
          <Variable { @spelling = `$arg-2`; }
        }

         if [$arg-type] {
           apply [$arg-type];
        } else {
          <Standard-Type { @nr = "1"; @spelling = "set"; }
        }
      }

      <Conditional-Formula {
        <Negated-Formula {
          apply [$formula];
        }
        apply [$formula] (#x  = $arg-1,
                          #y  = $arg-2,
                          #it = $it) mode="swap";
      }
    }

  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-connectedness (#segments = $rest,
                                               #formula  = $formula,
                                               #it       = $it,
                                               #arg-type = $arg-type,
                                               #arg-1    = $arg-1,
                                               #arg-2    = $arg-2);
    }
  }
}

tpl universally-bind-segments-asymmetry (#segments,
                                         #formula,
                                         #it,
                                         #arg-type,
                                         #arg-1,
                                         #arg-2) {
  if [count ($segments) = 0] {
    <Universal-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable { @spelling = `$arg-1`; }
          <Variable { @spelling = `$arg-2`; }
        }

         if [$arg-type] {
           apply [$arg-type];
        } else {
          <Standard-Type { @nr = "1"; @spelling = "set"; }
        }
      }

      <Conditional-Formula {
        apply [$formula];
        <Negated-Formula {
          apply [$formula] (#x  = $arg-2,
                            #y  = $arg-1,
                            #it = $it) mode="swap";
        }
      }
    }

  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-asymmetry (#segments = $rest,
                                           #formula  = $formula,
                                           #it       = $it,
                                           #arg-type = $arg-type,
                                           #arg-1    = $arg-1,
                                           #arg-2    = $arg-2);
    }
  }
}

tpl universally-bind-segments-irreflexivity (#segments,
                                             #formula,
                                             #it,
                                             #arg-type,
                                             #arg-1,
                                             #arg-2) {
  if [count ($segments) = 0] {
    <Universal-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable { @spelling = `$arg-1`; }
        }

         if [$arg-type] {
           apply [$arg-type];
        } else {
          <Standard-Type { @nr = "1"; @spelling = "set"; }
        }
      }

      <Negated-Formula {
        apply [$formula] (#x  = $arg-2,
                          #y  = $arg-1,
                          #it = $arg-1) mode="replace";
      }
    }

  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-irreflexivity (#segments = $rest,
                                               #formula  = $formula,
                                               #it       = $it,
                                               #arg-type = $arg-type,
                                               #arg-1    = $arg-1,
                                               #arg-2    = $arg-2);
    }
  }
}

tpl universally-bind-segments-reflexivity (#segments,
                                           #formula,
                                           #it,
                                           #arg-type,
                                           #arg-1,
                                           #arg-2) {
  if [count ($segments) = 0] {
    <Universal-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable { @spelling = `$arg-1`; }
          // <Variable { @spelling = `$arg-2`; }
        }

         if [$arg-type] {
           apply [$arg-type];
        } else {
          <Standard-Type { @nr = "1"; @spelling = "set"; }
        }
      }

      apply [$formula] (#x  = $arg-2,
                        #y  = $arg-1,
                        #it = $arg-1) mode="replace";
    }

  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-reflexivity (#segments = $rest,
                                             #formula  = $formula,
                                             #it       = $it,
                                             #arg-type = $arg-type,
                                             #arg-1    = $arg-1,
                                             #arg-2    = $arg-2);
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "compatibility"
    and preceding-sibling::Item
        [
              @kind = "Predicate-Definition"
          and Redefine]]] {
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "CompatibilityLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {
       $locus = `Item[@kind = "Loci-Declaration"]`;
       $segments = `$locus/Explicitly-Qualified-Segment`;
       $pd = `Item[@kind = "Predicate-Definition"]`;
       $original-formula = `$pd/Predicate-Pattern`;
       $new-formula = `$pd/Definiens/*[position() = last()]`;
       universally-bind-segments-compatibility
         (#segments         = $segments,
          #original-formula = $original-formula,
          #new-formula      = $new-formula);
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Predicate-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "compatibility"
    and preceding-sibling::Item
        [
              @kind = "Functor-Definition"
          and Redefine
	  and count(preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $compatibility-lemma; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {
       $locus = `Item[@kind = "Loci-Declaration"]`;
       $segments = `$locus/Explicitly-Qualified-Segment`;
       $fd = `Item[@kind = "Functor-Definition"]`;
       $original-formula = `$fd/Operation-Functor-Pattern`;
       $new-formula = `$fd/Definiens/*[position() = last()]`;
       $type = `$fd/Type-Specification/*[1]`;
       $shape = `$fd/@shape`;
       universally-bind-segments-compatibility
         (#segments         = $segments,
          #original-formula = $original-formula,
          #new-formula      = $new-formula,
	  #it               = $it,
	  #shape            = $shape,
	  #value-type       = $type);
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "compatibility"
    and preceding-sibling::Item
        [
              @kind = "Functor-Definition"
          and Redefine
	  and count(preceding-sibling::Item[@kind = "Assumption"]) = 1
        ]
  ]
]
{
  $definiens = `preceding-sibling::Item[@kind = "Functor-Definition" and @shape = "Means"]/Definiens/*[position() = last()]`;
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Diffuse-Statement";
    <Label { @spelling = $compatibility-lemma; }
    <Block {
      @kind = "Now-Reasoning";
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {
        for-each [Item[@kind = "Loci-Declaration" or @kind = "Choice-Statement" or @kind = "Assumption"]] {
          choose {
            when [self::Item[@kind = "Loci-Declaration"]] {
              <Item { @kind = "Generalization"; apply [*]; }
            }
            otherwise {
              // nothing special to do; apply the default template
              apply [.];
            }
          }
        }
      }
      <Item {
        @kind = "Conclusion";
        @shape = "Compact-Statement";
        $fd = `preceding-sibling::Item[@kind = "Functor-Definition"]`;
        $formula = `$fd/Definiens/*[position() = last()]`;
        $type = `$fd/Type-Specification/*[1]`;
        $original-formula = `$fd/Operation-Functor-Pattern`;
        $new-formula = `$fd/Definiens/*[position() = last()]`;
        $pattern    = `$fd/Operation-Functor-Pattern`;
        <Proposition {
          <Universal-Quantifier-Formula {
            <Explicitly-Qualified-Segment {
              <Variables {
                <Variable { @spelling = $it; }
              }
              if [$type] {
                apply [$type];
              } else {
                // guess the type by looking into the justification
                if [Block[@kind = "Proof"]] {
                  for-each [Block[@kind = "Proof"]] {
                    if [*[1][self::Item[@kind = "Generalization"]]] {
                      for-each [Item[@kind = "Generalization"][1]] {
                        for-each [Explicitly-Qualified-Segment] {
                          // msg "we sniffed out a type!";
                          apply [*[position() = last()]];
                        }
                      }
                    } else {
                      die (#message = "We can't sniff out the value type for a redefined functor: the proof for the compatibility condition does not begin with a generalization.");
                    }
                  }
                } else {
                  die (#message = "We can't sniff out the value type for a redefined functor.");
                }
              }
            }
            <Biconditional-Formula {
              <Predicative-Formula {
                @spelling = "=";
                <Arguments { <Simple-Term { @spelling = $it; } }
                <Arguments { apply [$original-formula]; }
              }
              <Predicative-Formula {
                @spelling = "=";
                <Arguments { <Simple-Term { @spelling = $it; } }
                <Arguments { apply [$new-formula]; }
              }
            }
          }
        }
        apply [*[position() = last()]];
      }
    }
  }
}

tpl
[
  Item
  [
        @kind = "Property"
    and (   @property = "reflexivity"
         or @property = "irreflexivity"
         or @property = "symmetry"
         or @property = "asymmetry"
         or @property = "connectedness")
    and preceding-sibling::Item
        [
              @kind = "Predicate-Definition"
          and Redefine
	  and not(Definiens)]]] {
  $p = `@property`;
  msg `concat ("Unsupported property ", $p, " of a redefined predicate.")`;
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "coherence"
    and parent::Block
        [
            @kind = "Registration-Block"
        ]
    and preceding-sibling::Item
        [
                @kind = "Cluster"
            and Functorial-Registration
                [
                  count (*) = 3
                ]
        ]
  ]
]
{
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "CoherenceLemma"; }
      for-each [ancestor::Block[@kind = "Registration-Block"]] {

        $locus     = `Item[@kind = "Loci-Declaration"]`;
        $fd        = `Item[@kind = "Cluster"]/Functorial-Registration[1]`;
        $formula   = `$fd/*[1]`;
        $adjective = `$fd/*[2]`;
        $type      = `$fd/*[3]`;
        $segments  = `$locus/Explicitly-Qualified-Segment`;
        universally-bind-segments-conditional-coherence (#segments  = $segments,
                                                         #formula   = $formula,
                                                         #adjective = $adjective,
                                                         #type      = $type);
      }
    }

    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Registration-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Cluster"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }

}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "coherence"
    and parent::Block
        [
            @kind = "Registration-Block"
        ]
    and preceding-sibling::Item
        [
                @kind = "Cluster"
            and Functorial-Registration
                [
                  count (*) = 2
                ]
        ]
  ]
]
{
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "CoherenceLemma"; }
      for-each [ancestor::Block[@kind = "Registration-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Cluster"]/Functorial-Registration[1]`;
        $formula    = `$fd/*[1]`;
        $type       = `$fd/*[position() = last()]`;
        $segments   = `$locus/Explicitly-Qualified-Segment`;
        universally-bind-segments-coherence (#segments   = $segments,
                                             #formula    = $formula,
                                             #type       = $type);
      }
    }

    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Registration-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Cluster"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }

}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "coherence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Equals"
          and not(Redefine)
          and count(preceding-sibling::Item[@kind = "Assumption"]) = 0
          and not(Definiens/Partial-Definiens)
        ]
  ]
]
{
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "CoherenceLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Functor-Definition"]`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $ts         = `$fd/Type-Specification`;
        $type       = `$ts/*[1]`;
        $segments   = `$locus/Explicitly-Qualified-Segment`;
        universally-bind-segments-coherence (#segments   = $segments,
                                             #formula    = $formula,
                                             #type       = $type);
      }
    }

    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }

}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "coherence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Equals"
          and not(Redefine)
          and count(preceding-sibling::Item[@kind = "Assumption"]) = 0
          and Definiens/Partial-Definiens
        ]
  ]
]
{
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "CoherenceLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus               = `Item[@kind = "Loci-Declaration"]`;
        $fd                  = `Item[@kind = "Functor-Definition"]`;
        $definiens           = `$fd/Definiens`;
        $formula             = `$fd/Definiens/*[position() = last()]`;
        $ts                  = `$fd/Type-Specification`;
        $type                = `$ts/*[1]`;
        $segments            = `$locus/Explicitly-Qualified-Segment`;
        $partial-definientia = `$definiens/Partial-Definiens`;
        $default             = `$definiens/*[not(self::Partial-Definiens) and count(preceding-sibling::Partial-Definiens) > 0]`;
        universally-bind-segments-coherence-partial-function-definiens
          (#segments  = $segments,
           #definientia = $partial-definientia,
           #original-definientia = $partial-definientia,
           #default = $default,
           #type      = $type);
      }
    }

    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }

}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "coherence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 1
         ]
  ]
]
{
  $definiens = `preceding-sibling::Item[@kind = "Functor-Definition" and @shape = "Means"]/Definiens/*[position() = last()]`;
  $existential-variable = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Diffuse-Statement";
    <Label { @spelling = $coherence-lemma; }
    <Block {
      @kind = "Now-Reasoning";
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {
        for-each [Item[@kind = "Loci-Declaration" or @kind = "Choice-Statement" or @kind = "Assumption"]] {
          choose {
            when [self::Item[@kind = "Loci-Declaration"]] {
              <Item { @kind = "Generalization"; apply [*]; }
            }
            otherwise {
              // nothing special to do; apply the default template
              apply [.];
            }
          }
        }
      }
      <Item {
        @kind = "Conclusion";
        @shape = "Compact-Statement";
        $fd = `preceding-sibling::Item[@kind = "Functor-Definition"]`;
        $formula = `$fd/Definiens/*[position() = last()]`;
        $type = `$fd/Type-Specification/*[1]`;
        <Proposition {
	  <Attributive-Formula {
            apply [$formula];
            if [$type] {
              apply [$type];
            } else {
              <Standard-Type { @nr = "1"; @spelling = "set"; }
            }

          }
        }
        apply [*[position() = last()]];
      }
    }
  }
}

tpl
[
  Item
  [
    @kind = "Definition-Item"
    and Block
        [
          @kind = "Registration-Block"
          and Item
              [
                      @kind = "Cluster"
                  and Functorial-Registration
              ]
        ]
  ]
]
{
  for-each [Block[@kind = "Registration-Block"]] {
    for-each [Item[@kind = "Correctness-Condition" or @kind = "Property"]] {

      choose {
        when [self::Item[@kind = "Correctness-Condition"]] {
          $c = `@condition`;
          msg `concat ("working on condition ", $c, " inside a cluster")`;
        }
        when [self::Item[@kind = "Property"]] {
          $p = `@property`;
          msg `concat ("working on property ", $p, " inside a cluster")`;
        }
        when [self::Item[@kind = "Correctness"]] {
          msg "working on correctness inside a cluster";
        }
      }

      apply [.];
      msg "done.";
    }
  }

  <Item {
    for-each [@*] { copy-of `.`; }
    for-each [Block[@kind = "Registration-Block"]] {
      <Block {
        for-each [@*] { copy-of `.`; }
        for-each [*] {
          choose {
            when [self::Item[@kind = "Correctness-Condition"]] {
              apply [.] mode="straightforward-correctness";
            }
            when [self::Item[@kind = "Property"]] {
              apply [.] mode="straightforward-correctness";
            }
            otherwise {
              apply [.];
            }
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
    @kind = "Definition-Item"
    and Block
        [
          @kind = "Definitional-Block"
          and Item
              [
                    @kind = "Functor-Definition"
                and not(Redefine and not(Definiens))
              ]
        ]
  ]
]
{
  for-each [Block[@kind = "Definitional-Block"]] {
    for-each [Item[@kind = "Correctness-Condition" or @kind = "Property"]] {

      choose {
        when [self::Item[@kind = "Correctness-Condition"]] {
          $c = `@condition`;
          msg `concat ("working on condition ", $c)`;
        }
        when [self::Item[@kind = "Property"]] {
          $p = `@property`;
          msg `concat ("working on property ", $p)`;
        }
        when [self::Item[@kind = "Correctness"]] {
          msg "working on correctness";
        }
      }

      apply [.];
      msg "done.";
    }
  }

  <Item {
    for-each [@*] { copy-of `.`; }
    for-each [Block[@kind = "Definitional-Block"]] {
      <Block {
        for-each [@*] { copy-of `.`; }
        for-each [*] {
          choose {
            when [self::Item[@kind = "Correctness-Condition"]] {
              apply [.] mode="straightforward-correctness";
            }
            when [self::Item[@kind = "Property"]] {
              apply [.] mode="straightforward-correctness";
            }
            otherwise {
              apply [.];
            }
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Property"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and Redefine
        ]
  ]
]
{
  $p = `@property`;
  msg `concat ("Warning: unsupported property '", $p, "' of a redefined functor.")`;
  apply [.] mode="copy";
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "coherence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
        ]
  ]
]
{
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "CoherenceLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Functor-Definition"]`;
        $formula    = `$fd/Operation-Functor-Pattern`;
        $type       = `$fd/Type-Specification/*[1]`;
        $segments   = `$locus/Explicitly-Qualified-Segment`;
        universally-bind-segments-coherence (#segments   = $segments,
                                             #formula    = $formula,
                                             #type       = $type);
      }
    }

    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
    @kind = "Definition-Item"
    and Block
        [
          @kind = "Definitional-Block"
          and Item
              [
                    @kind = "Predicate-Definition"
                and not(Redefine and not(Definiens))
              ]
        ]
  ]
]
{
  for-each [Block[@kind = "Definitional-Block"]] {
    for-each [Item[@kind = "Correctness-Condition" or @kind = "Property"]] {
      apply [.];
    }
  }
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*] mode="straightforward-correctness";
  }
}

tpl
[
  Item
  [
    @kind = "Definition-Item"
    and Block
        [
          @kind = "Definitional-Block"
          and Item
              [
                    @kind = "Predicate-Definition"
                and Redefine
		and not(Definiens)
              ]
        ]
  ]
]
{
  msg "Warning: don't know how to handle a redefined predicate that lacks a definiens.";
  apply [.] mode="copy";
}

tpl [*] (#it) mode="replace-it-term" {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*] (#it = $it) mode="replace-it-term";
  }
}

tpl [it-Term] (#it) mode="replace-it-term" {
  <Simple-Term {
    @spelling = $it;
  }
}

tpl [*] (#x, #y, #it) mode="swap" {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*] (#x = $x, #y = $y, #it = $it) mode="swap";
  }
}

tpl [it-Term] (#x, #y, #it) mode="swap" {
  <Simple-Term {
    @spelling = $it;
  }
}

tpl [Simple-Term] (#x, #y, #it) mode="swap" {
  $s = `@spelling`;
  <Simple-Term {
    for-each [@*] { copy-of `.`; }
    choose {
      when [$s = $x] { @spelling = $y; }
      when [$s = $y] { @spelling = $x; }
      otherwise { @spelling = $s; }
    }
  }
}

tpl [*] (#x, #y, #it) mode="replace" {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*] (#x = $x, #y = $y, #it = $it) mode="replace";
  }
}

tpl [it-Term] (#x, #y, #it) mode="replace" {
  <Simple-Term {
    @spelling = $it;
  }
}

tpl [Simple-Term] (#x, #y, #it) mode="replace" {
  $s = `@spelling`;
  <Simple-Term {
    for-each [@*] { copy-of `.`; }
    if [$s = $x] {
      @spelling = $y;
    } else {
      @spelling = $s;
    }
  }
}

tpl [*] (#target, #val) mode="plug-in" {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*] (#target = $target, #val = $val) mode="plug-in";
  }
}

tpl [Simple-Term] (#target, #val) mode="plug-in" {
  $s = `@spelling`;
  if [$s = $target] {
    <Simple-Term { @spelling = $val; }
  } else {
    <Simple-Term {
      for-each [@*] { copy-of `.`; }
      apply [*] (#target = $target, #val = $val) mode="plug-in";
    }
  }
}

tpl [*] mode="straightforward-correctness" {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*] mode="straightforward-correctness";
  }
}

tpl [Item[@kind = "Property" and @property = "sethood"]] mode="local-reference"
{
  <Local-Reference { @spelling = $sethood-lemma; }
}

tpl [Item[@kind = "Property" and @property = "reflexivity"]] mode="local-reference"
{
  <Local-Reference { @spelling = $reflexivity-lemma; }
}

tpl [Item[@kind = "Property" and @property = "irreflexivity"]] mode="local-reference"
{
  <Local-Reference { @spelling = $irreflexivity-lemma; }
}

tpl [Item[@kind = "Property" and @property = "symmetry"]] mode="local-reference"
{
  <Local-Reference { @spelling = $symmetry-lemma; }
}

tpl [Item[@kind = "Property" and @property = "asymmetry"]] mode="local-reference"
{
  <Local-Reference { @spelling = $asymmetry-lemma; }
}

tpl [Item[@kind = "Property" and @property = "connectedness"]] mode="local-reference"
{
  <Local-Reference { @spelling = $connectedness-lemma; }
}

tpl [Item[@kind = "Property" and @property = "projectivity"]] mode="local-reference"
{
  <Local-Reference { @spelling = $projectivity-lemma; }
}

tpl [Item[@kind = "Property" and @property = "involutiveness"]] mode="local-reference"
{
  <Local-Reference { @spelling = $involutiveness-lemma; }
}

tpl [Item[@kind = "Property" and @property = "projectivity"]] mode="local-reference"
{
  <Local-Reference { @spelling = $projectivity-lemma; }
}

tpl [Item[@kind = "Property" and @property = "commutativity"]] mode="local-reference"
{
  <Local-Reference { @spelling = $commutativity-lemma; }
}

tpl [Item[@kind = "Property" and @property = "idempotence"]] mode="local-reference"
{
  <Local-Reference { @spelling = $idempotence-lemma; }
}

tpl [Item[@kind = "Correctness-Condition" and @condition = "consistency"]] mode="local-reference"
{
  <Local-Reference { @spelling = $consistency-lemma; }
}

tpl [Item[@kind = "Correctness-Condition" and @condition = "existence"]] mode="local-reference"
{
  <Local-Reference { @spelling = $existence-lemma; }
}

tpl [Item[@kind = "Correctness-Condition" and @condition = "uniqueness"]] mode="local-reference"
{
  <Local-Reference { @spelling = $uniqueness-lemma; }
}

tpl [Item[@kind = "Correctness-Condition" and @condition = "compatibility"]] mode="local-reference"
{
  <Local-Reference { @spelling = $compatibility-lemma; }
}

tpl [Item[@kind = "Correctness-Condition" and @condition = "coherence"]] mode="local-reference"
{
  <Local-Reference { @spelling = $coherence-lemma; }
}

tpl
[
  Block
  [
        @kind = "Proof"
    and parent::Item
        [
          @kind = "Property"
        ]
  ]
]
mode="straightforward-correctness"
{
  <Straightforward-Justification {
    apply [parent::Item[@kind = "Property"]] mode="local-reference";
    for-each [ancestor::Block[@kind = "Definitional-Block"]] {
      for-each [Item[@kind = "Choice-Statement"]/Conditions/Proposition/Label] {
        <Local-Reference { @spelling = `@spelling`; }
      }
      for-each [Item[@kind = "Existential-Assumption"]/Conditions/Proposition/Label] {
        <Local-Reference { @spelling = `@spelling`; }
      }
    }
  }
}

tpl
[
  Straightforward-Justification
  [
    parent::Item
    [
      @kind = "Property"
    ]
  ]
]
mode="straightforward-correctness"
{
  <Straightforward-Justification {
    apply [parent::Item[@kind = "Property"]] mode="local-reference";
    for-each [ancestor::Block[@kind = "Definitional-Block"]] {
      for-each [Item[@kind = "Choice-Statement"]/Conditions/Proposition/Label] {
        <Local-Reference {
          @spelling = `@spelling`;
        }
      }
      for-each [Item[@kind = "Existential-Assumption"]/Conditions/Proposition/Label] {
        <Local-Reference {
          @spelling = `@spelling`;
        }
      }
    }
  }
}

tpl
[
  Block
  [
        @kind = "Proof"
    and parent::Item
        [
          @kind = "Correctness-Condition"
        ]
  ]
]
mode="straightforward-correctness"
{
  <Straightforward-Justification {
    apply [parent::Item[@kind = "Correctness-Condition"]] mode="local-reference";
    for-each [ancestor::Block[@kind = "Definitional-Block"]] {
      for-each [Item[@kind = "Choice-Statement"]/Conditions/Proposition/Label | Item[@kind = "Assumption"]/Single-Assumption/Proposition/Label | Item[@kind = "Assumption"]/Collective-Assumption/Conditions/Proposition/Label] {
        <Local-Reference {
          @spelling = `@spelling`;
        }
      }
    }
  }
}

tpl
[
  Straightforward-Justification
  [
    parent::Item
    [
      @kind = "Correctness-Condition"
    ]
  ]
]
mode="straightforward-correctness"
{
  <Straightforward-Justification {
    apply [parent::Item[@kind = "Correctness-Condition"]] mode="local-reference";
    for-each [ancestor::Block[@kind = "Definitional-Block"]] {
      for-each [Item[@kind = "Choice-Statement"]/Conditions/Proposition/Label] {
        <Local-Reference {
          @spelling = `@spelling`;
        }
      }
      for-each [Item[@kind = "Assumption"]/Single-Assumption/Proposition/Label] {
        <Local-Reference {
          @spelling = `@spelling`;
        }
      }
      for-each [Item[@kind = "Assumption"]/Collective-Assumption/Conditions/Proposition/Label] {
        <Local-Reference {
          @spelling = `@spelling`;
        }
      }
      for-each [Item[@kind = "Existential-Assumption"]/Conditions/Proposition/Label] {
        <Local-Reference {
          @spelling = `@spelling`;
        }
      }
    }
  }
}

tpl
[
  Definiens
  [
    @kind = "Simple-Definiens"
    and @shape = "Formula-Expression"
    and parent::Item
        [
          @kind = "Functor-Definition"
          and @shape = "Means"
          and count(preceding-sibling::Item[@kind = "Assumption"]) > 1
        ]
  ]
]
{
  die (#message = "Don't know how to handle multiple Assumption definitions.");
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "existence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
          and count (preceding-sibling::Item[@kind = "Existential-Assumption"]) = 0
          and count (Definiens/Partial-Definiens) > 0
         ]
  ]
]
{
  $fd = `preceding-sibling::Item[@kind = "Functor-Definition" and @shape = "Means"]`;
  $loci = `preceding-sibling::Item[@kind = "Loci-Declaration"]`;
  $segments = `$loci/Explicitly-Qualified-Segment`;
  $definiens = `$fd/Definiens`;
  $type-specification = `$fd/Type-Specification`;
  $type = `$type-specification/*[1]`;
  $default = `$definiens/*[position() = last()]`;
  $partial-definientia = `$definiens/Partial-Definiens`;
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $existence-lemma; }
      universally-bind-segments-function-means-existence-partial
        (#segments             = $segments,
         #default              = $default,
         #partial-definientia  = $partial-definientia,
         #original-definientia = $partial-definientia,
         #type                 = $type);

    }
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "existence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
          and count (preceding-sibling::Item[@kind = "Existential-Assumption"]) = 0
          and count (Definiens/Partial-Definiens) = 0
         ]
  ]
]
{
  $definiens = `preceding-sibling::Item[@kind = "Functor-Definition" and @shape = "Means"]/Definiens`;
  $existential-variable = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $existence-lemma; }
      $segments = `preceding-sibling::Item[@kind = "Loci-Declaration"]/Explicitly-Qualified-Segment`;
      $fd = `preceding-sibling::Item[@kind = "Functor-Definition" and @shape = "Means"]`;
      $type-specification = `$fd/Type-Specification`;
      $type = `$type-specification/*[1]`;
      universally-bind-segments-existence (#segments   = $segments,
                                           #formula    = $definiens,
                                           #type       = $type,
                                           #it         = $existential-variable);
    }
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "existence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 1
         ]
  ]
]
{
  $definiens = `preceding-sibling::Item[@kind = "Functor-Definition" and @shape = "Means"]/Definiens/*[position() = last()]`;
  $existential-variable = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Diffuse-Statement";
    <Label { @spelling = $existence-lemma; }
    <Block {
      @kind = "Now-Reasoning";
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {
        for-each [Item[@kind = "Loci-Declaration" or @kind = "Choice-Statement" or @kind = "Assumption"]] {
          choose {
            when [self::Item[@kind = "Loci-Declaration"]] {
              <Item { @kind = "Generalization"; apply [*]; }
            }
            otherwise {
              // nothing special to do; apply the default template
              apply [.];
            }
          }
        }
      }
      <Item {
        @kind = "Conclusion";
        @shape = "Compact-Statement";
        $fd = `preceding-sibling::Item[@kind = "Functor-Definition"]`;
        $formula = `$fd/Definiens/*[position() = last()]`;
        $type = `$fd/Type-Specification/*[1]`;
        <Proposition {
          <Existential-Quantifier-Formula {
            <Explicitly-Qualified-Segment {
              <Variables {
                <Variable { @spelling = $existential-variable; }
              }
              if [$type] {
                apply [$type];
              } else {
                <Standard-Type { @nr = "1"; @spelling = "set"; }
              }
            }
            apply [$formula] (#it = $existential-variable) mode="replace-it-term";
          }
        }
        apply [*[position() = last()]];
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "existence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) > 1
         ]
  ]
]
{
  die (#message = "We do not yet handle existence conditions for functor definitions that have multiple assumtions.");
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "existence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Existential-Assumption"]) = 1
         ]
  ]
]
{
  $locus      = `preceding-sibling::Item[@kind = "Loci-Declaration"]`;
  $segments   = `$locus/Explicitly-Qualified-Segment`;
  $fd = `preceding-sibling::Item[@kind = "Functor-Definition" and @shape = "Means"]`;
  $definiens = `$fd/Definiens`;
  $pattern = `$fd/Operation-Functor-Pattern`;
  $type-specification = `$fd/Type-Specification`;
  $type = `$type-specification/*[1]`;
  $formula = `$definiens/*[position() = last()]`;
  $assumption = `preceding-sibling::Item[@kind = "Existential-Assumption"]`;
  $existential-variable = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Label { @spelling = $existence-lemma; }
    <Proposition {
      universally-bind-segments-existential-assumption-existence (#formula = $formula,
                                                                  #segments = $segments,
                                                                  #assumption = $assumption,
                                                                  #it = $existential-variable,
                                                                  #type = $type);
    }


    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          <Straightforward-Justification {
            for-each [*] {
              if [@spelling = preceding::Item[@kind = "Existential-Assumption"]/Conditions/Proposition/Label/@spelling] {
                // ignore: this is a reference to the existential assumption
              } else {
                apply [.];
              }
            }
          }
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "uniqueness"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
          and count (Definiens/Partial-Definiens) = 0
        ]
  ]
]
{
  $uniqueness-variable-1 = fresh-variable (#prefix = "A");
  $uniqueness-variable-2 = fresh-variable (#prefix = "B");
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "UniquenessLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $segments   = `$locus/Explicitly-Qualified-Segment`;
        $fd         = `Item[@kind = "Functor-Definition"]`;
        $formula    = `$fd/Definiens`;
        $type       = `$fd/Type-Specification/*[1]`;

        universally-bind-segments-uniqueness
          (#segments   = $segments,
           #variable-1 = $uniqueness-variable-1,
           #variable-2 = $uniqueness-variable-2,
           #formula    = $formula,
           #type       = $type);
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                choose {
                  when [self::Item[@kind = "Loci-Declaration"]] {
                    <Item { @kind = "Generalization"; apply [*]; }
                  }
                  when [self::Item[@kind = "Existential-Assumption"]] {
                    // ignore
                  }
                  otherwise {
                    apply [.];
                  }
                }
              }
            }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "uniqueness"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
          and count (Definiens/Partial-Definiens) > 0
        ]
  ]
]
{
  $uniqueness-variable-1 = fresh-variable (#prefix = "A");
  $uniqueness-variable-2 = fresh-variable (#prefix = "B");
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "UniquenessLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $segments   = `$locus/Explicitly-Qualified-Segment`;
        $fd         = `Item[@kind = "Functor-Definition"]`;
        $definiens = `$fd/Definiens`;
        $partial-definientia = `$definiens/Partial-Definiens`;
        $default = `$definiens/*[position() = last()]`;
        $type       = `$fd/Type-Specification/*[1]`;

        universally-bind-segments-function-means-uniqueness-partial
          (#segments             = $segments,
           #variable-1           = $uniqueness-variable-1,
           #variable-2           = $uniqueness-variable-2,
           #default              = $default,
           #original-definientia = $partial-definientia,
           #partial-definientia  = $partial-definientia,
           #type                 = $type);
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                choose {
                  when [self::Item[@kind = "Loci-Declaration"]] {
                    <Item { @kind = "Generalization"; apply [*]; }
                  }
                  when [self::Item[@kind = "Existential-Assumption"]] {
                    // ignore
                  }
                  otherwise {
                    apply [.];
                  }
                }
              }
            }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "uniqueness"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 1
        ]
  ]
]
{
  $uniqueness-variable-1 = fresh-variable (#prefix = "A");
  $uniqueness-variable-2 = fresh-variable (#prefix = "B");
  <Item {
    @kind = "Regular-Statement";
    @shape = "Diffuse-Statement";
    <Label { @spelling = "UniquenessLemma"; }
    <Block {
      @kind = "Now-Reasoning";
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {
        for-each [Item[@kind = "Loci-Declaration" or @kind = "Choice-Statement" or @kind = "Assumption"]] {
          choose {
            when [self::Item[@kind = "Loci-Declaration"]] {
              <Item { @kind = "Generalization"; apply [*]; }

            }
            otherwise {
              // nothing special to do; apply the default template
              apply [.];
            }
          }
        }
      }
      <Item {
        @kind = "Conclusion";
        @shape = "Compact-Statement";
        $fd = `preceding-sibling::Item[@kind = "Functor-Definition"]`;
        $formula = `$fd/Definiens/*[position() = last()]`;
        $type = `$fd/Type-Specification/*[1]`;
        <Proposition {
          <Universal-Quantifier-Formula {
            <Explicitly-Qualified-Segment {
              <Variables {
                <Variable { @spelling = $uniqueness-variable-1; }
                <Variable { @spelling = $uniqueness-variable-2; }
              }
              if [$type] {
                apply [$type];
              } else {
                <Standard-Type { @nr = "1"; @spelling = "set"; }
              }
            }
            <Conditional-Formula {
              <Conjunctive-Formula {
                apply [$formula] (#it = $uniqueness-variable-1) mode="replace-it-term";
                apply [$formula] (#it = $uniqueness-variable-2) mode="replace-it-term";
              }
              <Predicative-Formula {
               @spelling = "=";
                <Arguments { <Simple-Term { @spelling = $uniqueness-variable-1; } }
                <Arguments { <Simple-Term { @spelling = $uniqueness-variable-2; } }
              }
            }
          }
        }
        apply [*[position() = last()]];
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "uniqueness"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) > 1
        ]
  ]
]
{
  die (#message = "We do not handle uniqueness conditions for functor definitions that have assumptions.");
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "commutativity"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and not(Redefine)
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $commutativity-lemma; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus   = `Item[@kind = "Loci-Declaration"]`;
        $fd      = `Item[@kind = "Functor-Definition"]`;
        $formula = `$fd/Definiens/*[position() = last()]`;
        $type    = `$fd/Type-Specification/*[1]`;
        $pattern = `$fd/Operation-Functor-Pattern`;
        $shape   = `$fd/@shape`;
        for-each [$pattern] {
          $arg-1 = `descendant::Locus[1]`;
          $arg-2 = `descendant::Locus[2]`;
          $arg-1-spelling = `$arg-1/@spelling`;
          $arg-2-spelling = `$arg-2/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment[not(Variables/Variable[@spelling = $arg-1-spelling or @spelling = $arg-2-spelling])]`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg-1-spelling]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              $arg-type = `*[position() = last()]`;
              universally-bind-segments-commutativity
                (#segments = $segments,
                 #formula  = $formula,
                 #shape    = $shape,
                 #type     = $type,
                 #it       = $it,
                 #arg-type = $arg-type,
                 #arg-1    = $arg-1-spelling,
                 #arg-2    = $arg-2-spelling);
            }
          }
        }
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            // for-each [ancestor::Block[@kind = "Definitional-Block"]] {
            //   for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
            //     if [self::Item[@kind = "Loci-Declaration"]] {
            //       <Item {
            //         @kind = "Generalization";
            //         apply [*];
            //       }
            //     } else {
            //       apply [.];
            //     }
            //   }
            // }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "projectivity"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $projectivity-lemma; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus   = `Item[@kind = "Loci-Declaration"]`;
        $fd      = `Item[@kind = "Functor-Definition"]`;
        $formula = `$fd/Definiens/*[position() = last()]`;
        $type    = `$fd/Type-Specification/*[1]`;
        $pattern = `$fd/Operation-Functor-Pattern`;
        $shape   = `$fd/@shape`;
        for-each [$pattern] {
          $arg = `descendant::Locus[1]/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              for-each [*[position() = last()]] {
                $arg-type = `*[position() = last()]`;
                universally-bind-segments-projectivity
                  (#segments = $segments,
                   #formula  = $formula,
                   #shape    = $shape,
                   #type     = $type,
                   #it       = $it,
                   #arg-type = $arg-type,
                   #arg      = $arg);
              }
            }
          }
        }
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            // for-each [ancestor::Block[@kind = "Definitional-Block"]] {
            //   for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
            //     if [self::Item[@kind = "Loci-Declaration"]] {
            //       <Item {
            //         @kind = "Generalization";
            //         apply [*];
            //       }
            //     } else {
            //       apply [.];
            //     }
            //   }
            // }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind     = "Property"
    and @property = "idempotence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and not(Redefine)
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $idempotence-lemma; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus     = `Item[@kind = "Loci-Declaration"]`;
        $fd        = `Item[@kind = "Functor-Definition"]`;
        $definiens = `$fd/Definiens`;
        $formula   = `$definiens/*[position() = last()]`;
        $type      = `$fd/Type-Specification/*[1]`;
        $pattern   = `$fd/Operation-Functor-Pattern`;
        $shape     = `$fd/@shape`;
        for-each [$pattern] {
          $arg-1 = `descendant::Locus[1]`;
          $arg-2 = `descendant::Locus[2]`;
          $arg-1-spelling = `$arg-1/@spelling`;
          $arg-2-spelling = `$arg-2/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment[not(Variables/Variable[@spelling = $arg-1-spelling or @spelling = $arg-2-spelling])]`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg-1-spelling]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              $arg-type = `*[position() = last()]`;
              universally-bind-segments-idempotence
                (#segments = $segments,
                 #formula  = $formula,
                 #shape    = $shape,
                 #type     = $type,
                 #it       = $it,
                 #arg-type = $arg-type,
                 #arg-1    = $arg-1-spelling,
                 #arg-2    = $arg-2-spelling);
            }
          }
        }
      }

    }


    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "involutiveness"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $involutiveness-lemma; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Functor-Definition"]`;
        $shape      = `$fd/@shape`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $type       = `$fd/Type-Specification/*[1]`;
        $pattern    = `$fd/Operation-Functor-Pattern`;
        for-each [$pattern] {
          $arg-1 = `descendant::Locus[1]`;
          $arg-1-spelling = `$arg-1/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment[not(Variables/Variable[@spelling = $arg-1-spelling])]`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg-1-spelling]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              for-each [*[position() = last()]] {
                $arg-type = `.`;
                universally-bind-segments-involutiveness
                  (#segments = $segments,
                   #formula  = $formula,
                   #type     = $type,
                   #it       = $it,
                   #shape    = $shape,
                   #arg-type = $arg-type,
                   #arg-1    = $arg-1-spelling);
              }
            }
          }
        }
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              $fd      = `Item[@kind = "Functor-Definition"]`;
              $pattern = `$fd/Operation-Functor-Pattern`;
              $block = `.`;
              for-each [$pattern] {
                $loci = `descendant::Locus`;
                for-each [$block] {
                  for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                    if [self::Item[@kind = "Loci-Declaration"]] {
                      if [Explicitly-Qualified-Segment/Variables/Variable/@spelling = $loci/@spelling] {
                        // ignore
                      } else {
                        <Item {
                          @kind = "Generalization";
                          apply [*];
                        }
                      }
                    } else {
                      apply [.];
                    }
                  }
                }
              }
            }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "symmetry"
    and preceding-sibling::Item
        [
              @kind  = "Predicate-Definition"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $symmetry-lemma; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Predicate-Definition"]`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $pattern    = `$fd/Predicate-Pattern`;
        for-each [$pattern] {
          $arg-1 = `descendant::Locus[1]`;
          $arg-2 = `descendant::Locus[2]`;
          $arg-1-spelling = `$arg-1/@spelling`;
          $arg-2-spelling = `$arg-2/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment[not(Variables/Variable[@spelling = $arg-1-spelling or @spelling = $arg-2-spelling])]`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg-1-spelling]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              for-each [*[position() = last()]] {
                $arg-type = `.`;
                universally-bind-segments-symmetry
                  (#segments = $segments,
                   #formula  = $formula,
                   #it       = $it,
                   #arg-type = $arg-type,
                   #arg-1    = $arg-1-spelling,
                   #arg-2    = $arg-2-spelling);
              }
            }
          }
        }
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            // for-each [ancestor::Block[@kind = "Definitional-Block"]] {
            //   for-each [*[following-sibling::Item[@kind = "Predicate-Definition"]]] {
            //     if [self::Item[@kind = "Loci-Declaration"]] {
            //       <Item {
            //         @kind = "Generalization";
            //         apply [*];
            //       }
            //     } else {
            //       apply [.];
            //     }
            //   }
            // }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "asymmetry"
    and preceding-sibling::Item
        [
              @kind  = "Predicate-Definition"
          and not(Redefine)
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $asymmetry-lemma; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Predicate-Definition"]`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $pattern    = `$fd/Predicate-Pattern`;
        for-each [$pattern] {
          $arg-1 = `descendant::Locus[1]`;
          $arg-2 = `descendant::Locus[2]`;
          $arg-1-spelling = `$arg-1/@spelling`;
          $arg-2-spelling = `$arg-2/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment[not(Variables/Variable[@spelling = $arg-1-spelling or @spelling = $arg-2-spelling])]`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg-1-spelling]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              for-each [*[position() = last()]] {
                $arg-type = `*[position() = last()]`;
                universally-bind-segments-asymmetry
                  (#segments = $segments,
                   #formula  = $formula,
                   #it       = $it,
                   #arg-type = $arg-type,
                   #arg-1    = $arg-1-spelling,
                   #arg-2    = $arg-2-spelling);
              }
            }
          }
        }
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            // for-each [ancestor::Block[@kind = "Definitional-Block"]] {
            //   for-each [*[following-sibling::Item[@kind = "Predicate-Definition"]]] {
            //     if [self::Item[@kind = "Loci-Declaration"]] {
            //       <Item {
            //         @kind = "Generalization";
            //         apply [*];
            //       }
            //     } else {
            //       apply [.];
            //     }
            //   }
            // }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "irreflexivity"
    and preceding-sibling::Item
        [
              @kind  = "Predicate-Definition"
          and not(Redefine)
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $irreflexivity-lemma; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Predicate-Definition"]`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $pattern    = `$fd/Predicate-Pattern`;
        for-each [$pattern] {
          $arg-1 = `descendant::Locus[1]`;
          $arg-2 = `descendant::Locus[2]`;
          $arg-1-spelling = `$arg-1/@spelling`;
          $arg-2-spelling = `$arg-2/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment[not(Variables/Variable[@spelling = $arg-1-spelling or @spelling = $arg-2-spelling])]`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg-1-spelling]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              for-each [*[position() = last()]] {
                $arg-type = `*[position() = last()]`;
                universally-bind-segments-irreflexivity
                  (#segments = $segments,
                   #formula  = $formula,
                   #it       = $it,
                   #arg-type = $arg-type,
                   #arg-1    = $arg-1-spelling,
                   #arg-2    = $arg-2-spelling);
              }
            }
          }
        }
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Predicate-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "reflexivity"
    and preceding-sibling::Item
        [
              @kind  = "Predicate-Definition"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $reflexivity-lemma; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Predicate-Definition"]`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $pattern    = `$fd/Predicate-Pattern`;
        for-each [$pattern] {
          $arg-1 = `descendant::Locus[1]`;
          $arg-2 = `descendant::Locus[2]`;
          $arg-1-spelling = `$arg-1/@spelling`;
          $arg-2-spelling = `$arg-2/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment[not(Variables/Variable[@spelling = $arg-1-spelling or @spelling = $arg-2-spelling])]`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg-1-spelling]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              for-each [*[position() = last()]] {
                $arg-type = `.`;
                universally-bind-segments-reflexivity
                  (#segments = $segments,
                   #formula  = $formula,
                   #it       = $it,
                   #arg-type = $arg-type,
                   #arg-1    = $arg-1-spelling,
                   #arg-2    = $arg-2-spelling);
              }
            }
          }
        }
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            // for-each [ancestor::Block[@kind = "Definitional-Block"]] {
            //   for-each [*[following-sibling::Item[@kind = "Predicate-Definition"]]] {
            //     if [self::Item[@kind = "Loci-Declaration"]] {
            //       <Item {
            //         @kind = "Generalization";
            //         apply [*];
            //       }
            //     } else {
            //       apply [.];
            //     }
            //   }
            // }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "connectedness"
    and preceding-sibling::Item
        [
              @kind  = "Predicate-Definition"
          and not(Redefine and not(Definiens))
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $connectedness-lemma; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Predicate-Definition"]`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $pattern    = `$fd/Predicate-Pattern`;
        for-each [$pattern] {
          $arg-1 = `descendant::Locus[1]`;
          $arg-2 = `descendant::Locus[2]`;
          $arg-1-spelling = `$arg-1/@spelling`;
          $arg-2-spelling = `$arg-2/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment[not(Variables/Variable[@spelling = $arg-1-spelling or @spelling = $arg-2-spelling])]`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg-1-spelling]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              for-each [*[position() = last()]] {
                $arg-type = `.`;
                universally-bind-segments-connectedness
                  (#segments = $segments,
                   #formula  = $formula,
                   #it       = $it,
                   #arg-type = $arg-type,
                   #arg-1    = $arg-1-spelling,
                   #arg-2    = $arg-2-spelling);
              }
            }
          }
        }
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            // for-each [ancestor::Block[@kind = "Definitional-Block"]] {
            //   for-each [*[following-sibling::Item[@kind = "Predicate-Definition"]]] {
            //     if [self::Item[@kind = "Loci-Declaration"]] {
            //       <Item {
            //         @kind = "Generalization";
            //         apply [*];
            //       }
            //     } else {
            //       apply [.];
            //     }
            //   }
            // }
            apply [*];
          }
        }
      }
    }

  }
}

tpl universally-bind-segments-consistency-means (#segments,
                                                  #it,
                                                  #partial-definientia,
                                                  #type)
{
  if [count ($segments) = 0] {
    choose {
      when [count ($partial-definientia) < 2] {
        // nothing more to do
      }
      when [count ($partial-definientia) = 2] {
        $definiens-1 = `$partial-definientia[1]`;
        $definiens-2 = `$partial-definientia[2]`;
        $value-1 = `$definiens-1/*[1]`;
        $value-2 = `$definiens-2/*[1]`;
        $condition-1 = `$definiens-1/*[2]`;
        $condition-2 = `$definiens-2/*[2]`;
        <Conditional-Formula {
          <Conjunctive-Formula {
            apply [$condition-1] (#it = $it) mode="replace-it-term";
            apply [$condition-2] (#it = $it) mode="replace-it-term";
          }
          <Biconditional-Formula {
            apply [$value-1] (#it = $it) mode="replace-it-term";
            apply [$value-2] (#it = $it) mode="replace-it-term";
          }
        }
      }
      when [count ($partial-definientia) > 2] {
        $definiens-1 = `$partial-definientia[1]`;
        $rest = `$partial-definientia[position() > 1]`;
        $value-1 = `$definiens-1/*[1]`;
        $condition-1 = `$definiens-1/*[2]`;
        <Conjunctive-Formula {
          for-each [$rest] {
            $definiens-2 = `.`;
            universally-bind-segments-consistency-means (#segments = $segments,
                                                         #type     = $type,
                                                         #it       = $it,
                                                         #partial-definientia = `$definiens-1 | $definiens-2`);
          }
          universally-bind-segments-consistency-means (#segments = $segments,
                                                       #type     = $type,
                                                       #it       = $it,
                                                       #partial-definientia = $rest);
        }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      if [count ($rest) = 0] {
        $fresh = fresh-variable ();
        <Universal-Quantifier-Formula {
          <Explicitly-Qualified-Segment {
            <Variables {
              <Variable { @spelling = $fresh; }
            }
            type-or-set (#type = $type);
          }
          universally-bind-segments-consistency-means (#segments = $rest,
                                                       #type     = $type,
                                                       #it       = $fresh,
                                                       #partial-definientia = $partial-definientia);
        }
      } else {
        universally-bind-segments-consistency-means (#segments  = $rest,
                                                     #type = $type,
                                                     #partial-definientia = $partial-definientia);
      }
    }
  }
}

tpl universally-bind-segments-consistency-equals (#segments,
                                                 #type,
                                                 #partial-definientia)
{
  if [count ($segments) = 0] {
    choose {
      when [count ($partial-definientia) > 2] {
        msg terminate="yes" "Error: unable to handle more than 2 partial definientia for a consistency lemma";
      }
      when [count ($partial-definientia) < 2] {
        <Negated-Formula { <Contradiction; }
      }
      when [count ($partial-definientia) = 2] {
        $definiens-1 = `$partial-definientia[1]`;
        $definiens-2 = `$partial-definientia[2]`;
        $value-1 = `$definiens-1/*[1]`;
        $value-2 = `$definiens-2/*[1]`;
        $condition-1 = `$definiens-1/*[2]`;
        $condition-2 = `$definiens-2/*[2]`;
        $fresh = fresh-variable ();
        <Universal-Quantifier-Formula {
          <Explicitly-Qualified-Segment {
            <Variables { <Variable { @spelling = $fresh; } }
            type-or-set (#type = $type);
          }
          <Conditional-Formula {
            <Conjunctive-Formula {
              apply [$condition-1];
              apply [$condition-2];
            }
            <Biconditional-Formula {
              <Predicative-Formula {
                @spelling = "=";
                <Arguments {
                  <Simple-Term { @spelling = $fresh; }
                }
                <Arguments {
                  apply [$value-1];
                }
              }
              <Predicative-Formula {
                @spelling = "=";
                <Arguments {
                  <Simple-Term { @spelling = $fresh; }
                }
                <Arguments {
                  apply [$value-2];
                }
              }
            }
          }
        }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-consistency-equals (#segments  = $rest,
                                                    #type = $type,
                                                    #partial-definientia = $partial-definientia);
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "consistency"
    and preceding-sibling::Item
        [
              @kind = "Functor-Definition"
          and @shape = "Equals"
          and count (Definiens/Partial-Definiens) > 0
        ]
  ]
]
{
  $context = `.`;
  $segments = `preceding-sibling::Item[@kind = "Loci-Declaration"]/Explicitly-Qualified-Segment`;
  for-each [preceding-sibling::Item[@kind = "Functor-Definition"]] {
    $ts = `Type-Specification`;
    $type = `$ts/*[1]`;
    $definiens = `Definiens`;
    $partial-definientia = `$definiens/Partial-Definiens`;
    <Item {
      @kind = "Regular-Statement";
      @shape = "Compact-Statement";
      <Proposition {
        <Label { @spelling = $consistency-lemma; }
        universally-bind-segments-consistency-equals (#segments = $segments,
                                                      #type = $type,
                                                      #partial-definientia = $partial-definientia);
      }
      for-each [$context] {
        for-each [*[position() = last()]] {
          choose {
            when [self::Straightforward-Justification] {
              apply [.];
            }
            when [self::Block[@kind = "Proof"]] {
              <Block {
                for-each [@*] { copy-of `.`; }
                for-each [ancestor::Block[@kind = "Definitional-Block"]] {
                  for-each [*[following-sibling::Item[@kind = "Mode-Definition"]]] {
                    if [self::Item[@kind = "Loci-Declaration"]] {
                      <Item {
                        @kind = "Generalization";
                        apply [*];
                      }
                    } else {
                      apply [.];
                    }
                  }
                }
                apply [*];
              }
            }
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "consistency"
    and preceding-sibling::Item
        [
              @kind = "Functor-Definition"
          and @shape = "Means"
          and count (Definiens/Partial-Definiens) > 0
        ]
  ]
]
{
  $context = `.`;
  $segments = `preceding-sibling::Item[@kind = "Loci-Declaration"]/Explicitly-Qualified-Segment`;
  for-each [preceding-sibling::Item[@kind = "Functor-Definition"]] {
    $ts = `Type-Specification`;
    $type = `$ts/*[1]`;
    $definiens = `Definiens`;
    $partial-definientia = `$definiens/Partial-Definiens`;
    <Item {
      @kind = "Regular-Statement";
      @shape = "Compact-Statement";
      <Proposition {
        <Label { @spelling = $consistency-lemma; }
        universally-bind-segments-consistency-means (#segments = $segments,
                                                     #type = $type,
                                                     #partial-definientia = $partial-definientia);
      }
      for-each [$context] {
        for-each [*[position() = last()]] {
          choose {
            when [self::Straightforward-Justification] {
              apply [.];
            }
            when [self::Block[@kind = "Proof"]] {
              <Block {
                for-each [@*] { copy-of `.`; }
                for-each [ancestor::Block[@kind = "Definitional-Block"]] {
                  for-each [*[following-sibling::Item[@kind = "Mode-Definition"]]] {
                    if [self::Item[@kind = "Loci-Declaration"]] {
                      <Item {
                        @kind = "Generalization";
                        apply [*];
                      }
                    } else {
                      apply [.];
                    }
                  }
                }
                apply [*];
              }
            }
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "consistency"
    and preceding-sibling::Item
        [
              @kind = "Functor-Definition"
          and count (Definiens/Partial-Definiens) <= 1
        ]
  ]
]
{
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $consistency-lemma; }
      <Universal-Quantifier-Formula {
        <Explicitly-Qualified-Segment {
          <Variables { <Variable { @spelling = "x"; } }
          <Standard-Type { @nr = "1"; @spelling = "set"; }
        }
        <Negated-Formula { <Contradiction; }
      }
    }

    <Straightforward-Justification;

  }
}

//////////////////////////////////////////////////////////////////////
// Modes
//////////////////////////////////////////////////////////////////////

tpl
[
  Item
  [
    @kind = "Definition-Item"
    and Block
        [
          @kind = "Definitional-Block"
          and Item
              [
                    @kind = "Mode-Definition"
                and not(Redefine)
              ]
        ]
  ]
]
{
  for-each [Block[@kind = "Definitional-Block"]] {
    for-each [Item[@kind = "Correctness-Condition" or @kind = "Property"]] {

      choose {
        when [self::Item[@kind = "Correctness-Condition"]] {
          $c = `@condition`;
          msg `concat ("working on condition ", $c)`;
        }
        when [self::Item[@kind = "Property"]] {
          $p = `@property`;
          msg `concat ("working on property ", $p)`;
        }
        when [self::Item[@kind = "Correctness"]] {
          msg "working on correctness";
        }
      }

      apply [.];
      msg "done.";
    }
  }

  <Item {
    for-each [@*] { copy-of `.`; }
    for-each [Block[@kind = "Definitional-Block"]] {
      <Block {
        for-each [@*] { copy-of `.`; }
        for-each [*] {
          choose {
            when [self::Item[@kind = "Correctness-Condition"]] {
              apply [.] mode="straightforward-correctness";
            }
            when [self::Item[@kind = "Property"]] {
              apply [.] mode="straightforward-correctness";
            }
            otherwise {
              apply [.];
            }
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "existence"
    and preceding-sibling::Item
        [
              @kind  = "Mode-Definition"
          and Standard-Mode
         ]
  ]
]
{
  $existential-variable = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $existence-lemma; }
      $segments = `preceding-sibling::Item[@kind = "Loci-Declaration"]/Explicitly-Qualified-Segment`;
      $fd = `preceding-sibling::Item[@kind = "Mode-Definition"]/Standard-Mode`;
      $definiens = `$fd/Definiens`;
      $type-specification = `$fd/Type-Specification`;
      $type = `$type-specification/*[1]`;
      universally-bind-segments-mode-existence (#segments   = $segments,
                                                #formula    = $definiens,
                                                #type       = $type,
                                                #it         = $existential-variable);
    }
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Mode-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "sethood"
    and preceding-sibling::Item
        [
              @kind  = "Mode-Definition"
          and Standard-Mode
         ]
  ]
]
{
  $existential-variable = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $sethood-lemma; }
      $segments = `preceding-sibling::Item[@kind = "Loci-Declaration"]/Explicitly-Qualified-Segment`;
      $fd = `preceding-sibling::Item[@kind = "Mode-Definition"]/Standard-Mode`;
      $definiens = `$fd/Definiens`;
      $type-specification = `$fd/Type-Specification`;
      $type = `$type-specification/*[1]`;
      universally-bind-segments-mode-sethood (#segments   = $segments,
                                              #formula    = $definiens,
                                              #type       = $type,
                                              #it         = $existential-variable);
    }
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Mode-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }
}

tpl universally-bind-segments-mode-sethood (#segments,
                                            #it,
                                            #formula,
                                            #type) {
  if [count ($segments) = 0] {
    for-each [$formula] {
      if [Partial-Definiens] {
        $alternative-val = `*[position() = last()]`;
        <Disjunctive-Formula {
          for-each [Partial-Definiens] {
            $val = `*[1]`;
            $condition = `*[position() = last()]`;
            <Conjunctive-Formula {
              apply [$condition];
              <Existential-Quantifier-Formula {
                <Explicitly-Qualified-Segment {
                  <Variables { <Variable { @spelling = $it; } }
                  if [$type] {
                    apply [$type];
                  } else {
                    <Standard-Type { @nr = "1"; @spelling = "set"; }
                  }
                }
                <Universal-Quantifier-Formula {
                  <Explicitly-Qualified-Segment {
                    <Variables { <Variable { @spelling = `concat ($it, "1")`; } }
                    <Standard-Type { @nr = "1"; @spelling = "set"; }
                  }
                  <Conditional-Formula {
                    apply [$val] (#it = `concat ($it, "1")`) mode="replace-it-term";
                    <Predicative-Formula {
                      @spelling = "in";
                      <Arguments {
                        <Simple-Term {
                          @spelling = `concat ($it, "1")`;
                        }
                      }
                      <Arguments {
                        <Simple-Term {
                          @spelling = $it;
                        }
                      }
                    }
                  }
                }
              }
            }
            <Conjunctive-Formula {
              <Negated-Formula { apply [$condition]; }
              <Existential-Quantifier-Formula {
                <Explicitly-Qualified-Segment {
                  <Variables { <Variable { @spelling = $it; } }
                  if [$type] {
                    apply [$type];
                  } else {
                    <Standard-Type { @nr = "1"; @spelling = "set"; }
                  }
                }

                <Universal-Quantifier-Formula {
                  <Explicitly-Qualified-Segment {
                    <Variables { <Variable { @spelling = `concat ($it, "1")`; } }
                    <Standard-Type { @nr = "1"; @spelling = "set"; }
                  }
                  <Conditional-Formula {
                    apply [$alternative-val] (#it = `concat ($it, "1")`) mode="replace-it-term";
                    <Predicative-Formula {
                      @spelling = "in";
                      <Arguments {
                        <Simple-Term {
                          @spelling = `concat ($it, "1")`;
                        }
                      }
                      <Arguments {
                        <Simple-Term {
                          @spelling = $it;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        for-each [*[position() = last()]] {
          <Existential-Quantifier-Formula {
            <Explicitly-Qualified-Segment {
               <Variables { <Variable { @spelling = $it; } }
               if [$type] {
                apply [$type];
              } else {
                <Standard-Type { @nr = "1"; @spelling = "set"; }
              }
            }
            apply [.] (#it = $it) mode="replace-it-term";
          }
        }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-mode-sethood (#segments   = $rest,
                                              #it         = $it,
                                              #formula    = $formula,
                                              #type       = $type);
    }
  }}


tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "consistency"
    and preceding-sibling::Item
        [
              @kind  = "Mode-Definition"
          and Standard-Mode
         ]
  ]
]
{
  $definiens = `preceding-sibling::Item[@kind = "Mode-Definition"]/Definiens`;
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $consistency-lemma; }
      $segments = `preceding-sibling::Item[@kind = "Loci-Declaration"]/Explicitly-Qualified-Segment`;
      universally-bind-segments-mode-consistency (#segments   = $segments);
    }
    <Straightforward-Justification;
  }
}

tpl universally-bind-segments-mode-existence (#segments,
                                              #it,
                                              #formula,
                                              #type,
                                              #assumption) {
  if [count ($segments) = 0] {
    for-each [$formula] {
      if [Partial-Definiens] {
        $alternative-val = `*[position() = last()]`;
        <Conjunctive-Formula {
          for-each [Partial-Definiens] {
            $val = `*[1]`;
            $condition = `*[position() = last()]`;
            <Conditional-Formula {
              apply [$condition];
              <Existential-Quantifier-Formula {
                <Explicitly-Qualified-Segment {
                  <Variables { <Variable { @spelling = $it; } }
                  if [$type] {
                    apply [$type];
                  } else {
                    <Standard-Type { @nr = "1"; @spelling = "set"; }
                  }
                }
                apply [$val] (#it = $it) mode="replace-it-term";
              }
            }
            <Conditional-Formula {
              <Negated-Formula { apply [$condition]; }
              <Existential-Quantifier-Formula {
                <Explicitly-Qualified-Segment {
                  <Variables { <Variable { @spelling = $it; } }
                  if [$type] {
                    apply [$type];
                  } else {
                    <Standard-Type { @nr = "1"; @spelling = "set"; }
                  }
                }
                apply [$alternative-val] (#it = $it) mode="replace-it-term";
              }
            }
          }
        }
      } else {
        for-each [*[position() = last()]] {
          <Existential-Quantifier-Formula {
            <Explicitly-Qualified-Segment {
               <Variables { <Variable { @spelling = $it; } }
               if [$type] {
                apply [$type];
              } else {
                <Standard-Type { @nr = "1"; @spelling = "set"; }
              }
            }
            apply [.] (#it = $it) mode="replace-it-term";
          }
        }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-mode-existence (#segments   = $rest,
                                                #it         = $it,
                                                #formula    = $formula,
                                                #type       = $type);
    }
  }
}

tpl universally-bind-segments-mode-consistency (#segments) {
  if [count ($segments) = 0] {
    <Negated-Formula { <Contradiction; }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-mode-consistency (#segments = $rest);
    }
  }
}

//////////////////////////////////////////////////////////////////////
// Attributes
//////////////////////////////////////////////////////////////////////

tpl
[
  Item
  [
    @kind = "Definition-Item"
    and Block
        [
          @kind = "Definitional-Block"
          and Item
              [
                    @kind = "Attribute-Definition"
                and not(Redefine)
              ]
        ]
  ]
]
{
  for-each [Block[@kind = "Definitional-Block"]] {
    for-each [Item[@kind = "Correctness-Condition" or @kind = "Property"]] {

      choose {
        when [self::Item[@kind = "Correctness-Condition"]] {
          $c = `@condition`;
          msg `concat ("working on condition ", $c)`;
        }
        when [self::Item[@kind = "Property"]] {
          $p = `@property`;
          msg `concat ("working on property ", $p)`;
        }
        when [self::Item[@kind = "Correctness"]] {
          msg "working on correctness";
        }
      }

      apply [.];
      msg "done.";
    }
  }

  <Item {
    for-each [@*] { copy-of `.`; }
    for-each [Block[@kind = "Definitional-Block"]] {
      <Block {
        for-each [@*] { copy-of `.`; }
        for-each [*] {
          choose {
            when [self::Item[@kind = "Correctness-Condition"]] {
              apply [.] mode="straightforward-correctness";
            }
            when [self::Item[@kind = "Property"]] {
              apply [.] mode="straightforward-correctness";
            }
            otherwise {
              apply [.];
            }
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "consistency"
    and preceding-sibling::Item
        [
              @kind  = "Attribute-Definition"
          and Definiens
        ]
  ]
]
{
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $consistency-lemma; }
      $segments = `preceding-sibling::Item[@kind = "Loci-Declaration"]/Explicitly-Qualified-Segment`;
      // mode consistency works as well for attribute consistency (for now)
      universally-bind-segments-mode-consistency (#segments = $segments);
    }
    <Straightforward-Justification;
  }
}

//////////////////////////////////////////////////////////////////////
// Predicates
//////////////////////////////////////////////////////////////////////

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "consistency"
    and preceding-sibling::Item
        [
              @kind  = "Predicate-Definition"
          and Definiens
        ]
  ]
]
{
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = $consistency-lemma; }
      $segments = `preceding-sibling::Item[@kind = "Loci-Declaration"]/Explicitly-Qualified-Segment`;
      // mode consistency works as well for predicate consistency (for now)
      universally-bind-segments-mode-consistency (#segments = $segments);
    }
    <Straightforward-Justification;
  }
}

//////////////////////////////////////////////////////////////////////
// Identifications
//////////////////////////////////////////////////////////////////////

tpl
[
  Item
  [
        @kind = "Definition-Item"
    and Block
        [
              @kind = "Registration-Block"
          and Item
              [
                    @kind = "Identify"
              ]
          and Item
              [
                    @kind = "Correctness-Condition"
                and @condition = "compatibility"
              ]
        ]
 ]
] {
  // Emit a lemma before the condition
  $fresh-variable = fresh-variable (#prefix = "Z");
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "Compatibility"; }
      for-each [Block[@kind = "Registration-Block"]] {
        $locus = `Item[@kind = "Loci-Declaration"]`;
        $segments = `$locus/Explicitly-Qualified-Segment`;
        $identification = `Item[@kind = "Identify"]`;
        $lhs = `$identification/*[1]`;
        $rhs = `$identification/*[2]`;
        $condition = `$identification/*[3]`;
        universally-bind-identification (#segments  = $segments,
                                         #lhs       = $lhs,
                                         #rhs       = $rhs,
                                         #condition = $condition);
      }
    }
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Identify"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl universally-bind-identification (#segments,
                                     #lhs,
                                     #rhs,
                                     #condition) {
  if [count ($segments) = 0] {
    <Conditional-Formula {
      apply [$condition];
      <Predicative-Formula {
        @spelling = "=";
        <Arguments {
          apply [$lhs];
        }
        <Arguments {
          apply [$rhs];
        }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-identification (#segments = $rest,
                                       #lhs = $lhs,
                                       #rhs = $rhs,
                                       #condition = $condition);
    }
  }
}

tpl
[
  Block
  [
        @kind = "Proof"
    and parent::Item
        [
              @kind      = "Correctness-Condition"
          and @condition = "compatibility"
          and parent::Block
              [
                    @kind = "Registration-Block"
                and parent::Item
                    [
                          @kind = "Definition-Item"
                      and parent::Text-Proper
                    ]
              ]
        ]
  ]
]
{
  <Straightforward-Justification { <Local-Reference { @spelling = "Compatibility"; } }
}

tpl
[
  Straightforward-Justification
  [
      parent::Item
      [
            @kind      = "Correctness-Condition"
        and @condition = "compatibility"
        and parent::Block
            [
                  @kind = "Registration-Block"
              and parent::Item
                  [
                        @kind = "Definition-Item"
                    and parent::Text-Proper
                  ]
            ]
      ]
  ]
]
{
  <Straightforward-Justification { <Local-Reference { @spelling = "Compatibility"; } }
}