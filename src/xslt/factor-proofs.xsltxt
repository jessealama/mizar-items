stylesheet "1.0";
import "utils/die.xsl";
import "utils/copy.xsl";
output method="xml" indent="yes";

tpl try-fresh-variable (#prefix, #try) {
  $trial-name = `concat ($prefix, $try)`;
  $next-try = `$try + 1`;
  choose {
    when [descendant::Simple-Term[@spelling = $trial-name]] {
      try-fresh-variable (#prefix = $prefix,
                          #try = $next-try);
    }
    when [descendant::Variable[@spelling = $trial-name]] {
      try-fresh-variable (#prefix = $prefix,
                          #try = $next-try);
    }
    otherwise {
      $trial-name;
    }
  }
}

tpl fresh-variable (#prefix) {
  for-each [ancestor::Text-Proper] {
    if [$prefix = ""] {
      try-fresh-variable (#prefix = "z", #try = "1");
    } else {
      try-fresh-variable (#prefix = $prefix, #try = "1");
    }
  }
}

tpl emit-conjunction-of-attributive-adjectives (#term-name, #adjectives) {
  choose {
    when [count ($adjectives) = 0] {
      die (#message = "Error: zero adjectives were given.");
    }
    when [count ($adjectives) = 1] {
      $adjective = `$adjectives[1]`;
      <Attributive-Formula {
        <Simple-Term {
          @spelling = $term-name;
        }
        apply [$adjective];
      }
    }
    otherwise {
      $first-adjective = `$adjectives[1]`;
      $remaining-adjectives = `$adjectives[position () > 1]`;
      <Conjunctive-Formula {
        <Attributive-Formula {
          <Simple-Term {
            @spelling = $term-name;
          }
          apply [$first-adjective];
        }
        emit-conjunction-of-attributive-adjectives (#term-name = $term-name,
                                                    #adjectives = $remaining-adjectives);
      }
    }
  }
}

// By default, copy
tpl [*] {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

// Sanity check
tpl [Text-Proper] {
  if [count (descendant::Implicitly-Qualified-Segment) > 0] {
    die (#message = "There are not supposed to be any Implicitly-Qualified-Segments");
  } else {
    <Text-Proper {
      for-each [@*] { copy-of `.`; }
      apply [*];
    }
  }
}

tpl universally-bind-conjunction-of-adjectives (#adjectives,
                                                #it,
                                                #type,
                                                #segments) {
  $num-adjectives = `count ($adjectives)`;
  // msg `concat ($num-adjectives, " adjectives")`;
  if [count ($segments) = 0] {
    <Existential-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable {
            @spelling = $it;
          }
        }
        apply [$type];
      }
      emit-conjunction-of-attributive-adjectives (#term-name  = $it,
                                                  #adjectives = $adjectives);
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-conjunction-of-adjectives (#segments   = $rest,
                                                  #type       = $type,
                                                  #it         = $it,
                                                  #adjectives = $adjectives);
    }
  }
}

tpl
[
  Item
  [
        @kind = "Definition-Item"
    and Block
        [
              @kind = "Registration-Block"
          and Item
              [
                    @kind = "Cluster"
                and Existential-Registration
              ]
          and Item
              [
                    @kind = "Correctness-Condition"
                and Block[@kind = "Proof"]
              ]
        ]
 ]
] {
  // Emit a lemma before the condition
  $fresh-variable = fresh-variable (#prefix = "Z");
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "Existence"; }
      for-each [Block[@kind = "Registration-Block"]] {
        $locus = `Item[@kind = "Loci-Declaration"]`;
        $segments = `$locus/Explicitly-Qualified-Segment`;
        $cluster = `Item[@kind = "Cluster"]`;
        $exreg = `$cluster/Existential-Registration`;
        $adcluster = `$exreg/Adjective-Cluster`;
        $type = `$exreg/*[position() = last()]`;
        $adjectives = `$adcluster/Adjective | $adcluster/NegatedAdjective`;
        universally-bind-conjunction-of-adjectives
          (#segments   = $segments,
           #type       = $type,
           #adjectives = $adjectives,
           #it         = $fresh-variable);
      }
    }
    for-each [Block[@kind = "Registration-Block"]] {
      for-each [Item[@kind = "Correctness-Condition"]] {
        for-each [Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Registration-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Cluster"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl
[
  Block
  [
        @kind = "Proof"
    and parent::Item
        [
              @kind      = "Correctness-Condition"
          and @condition = "existence"
          and parent::Block
              [
                    @kind = "Registration-Block"
                and parent::Item
                    [
                          @kind = "Definition-Item"
                      and parent::Text-Proper
                    ]
              ]
        ]
  ]
]
{
  <Straightforward-Justification { <Local-Reference { @spelling = "Existence"; } }
}

tpl universally-bind-segments-existence (#segments,
                                         #it,
                                         #formula,
                                         #type,
                                         #assumption) {
  if [count ($segments) = 0] {
    if [$assumption] {
      <Conditional-Formula {
        apply [$assumption];
        <Existential-Quantifier-Formula {
          <Explicitly-Qualified-Segment {

            <Variables {
              <Variable {
                @spelling = $it;
              }
            }

            if [$type] {
              apply [$type];
            } else {
              <Standard-Type { @nr = "1"; @spelling = "set"; }
            }

          }

          apply [$formula] (#it = $it) mode="replace-it-term";

        }
      }
    } else {
      <Existential-Quantifier-Formula {
        <Explicitly-Qualified-Segment {

          <Variables {
            <Variable {
              @spelling = $it;
            }
          }

          if [$type] {
            apply [$type];
          } else {
            <Standard-Type { @nr = "1"; @spelling = "set"; }
          }

        }

        apply [$formula] (#it = $it) mode="replace-it-term";

      }

    }

  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-existence (#segments   = $rest,
                                           #it         = $it,
                                           #formula    = $formula,
                                           #type       = $type,
                                           #assumption = $assumption);
    }
  }
}

tpl universally-bind-segments-uniqueness (#segments,
                                          #variable-1,
                                          #variable-2,
                                          #formula,
                                          #type,
                                          #assumption) {
  if [count ($segments) = 0] {
    <Universal-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable { @spelling = $variable-1; }
          <Variable { @spelling = $variable-2; }
        }

        if [$type] {
          apply [$type];
        } else {
          <Standard-Type { @nr = "1"; @spelling = "set"; }
        }

      }
      if [$assumption] {
        <Conditional-Formula {
          <Conjunctive-Formula {
            <Conditional-Formula {
              apply [$assumption];
              apply [$formula] (#it = $variable-1) mode="replace-it-term";
            }
            <Conditional-Formula {
              apply [$assumption];
              apply [$formula] (#it = $variable-2) mode="replace-it-term";
            }
          }
          <Predicative-Formula {
            @spelling = "=";
            <Arguments { <Simple-Term { @spelling = $variable-1; } }
            <Arguments { <Simple-Term { @spelling = $variable-2; } }
          }
        }
      } else {
        <Conditional-Formula {
          <Conjunctive-Formula {
            apply [$formula] (#it = $variable-1) mode="replace-it-term";
            apply [$formula] (#it = $variable-2) mode="replace-it-term";
          }
          <Predicative-Formula {
            @spelling = "=";
            <Arguments { <Simple-Term { @spelling = $variable-1; } }
            <Arguments { <Simple-Term { @spelling = $variable-2; } }
          }
        }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-uniqueness (#segments   = $rest,
                                            #variable-1 = $variable-1,
                                            #variable-2 = $variable-2,
                                            #formula    = $formula,
                                            #type       = $type,
                                            #assumption = $assumption);
    }
  }
}

tpl universally-bind-segments-compatibility (#segments,
                                             #original-formula,
                                             #new-formula) {
  if [count ($segments) = 0] {
    <Biconditional-Formula {
      apply [$original-formula];
      apply [$new-formula];
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-compatibility
        (#segments         = $rest,
         #original-formula = $original-formula,
         #new-formula      = $new-formula);
    }
  }
}

tpl universally-bind-segments-commutativity (#segments,
                                             #formula,
                                             #type,
                                             #it,
                                             #shape,
                                             #arg-type,
                                             #arg-1,
                                             #arg-2) {
  if [count ($segments) = 0] {
    choose {
      when [$shape = "means"] {
        <Universal-Quantifier-Formula {

          <Explicitly-Qualified-Segment {
            <Variables {
              <Variable { @spelling = $it; }
            }

            if [$arg-type] {
              apply [$arg-type];
            } else {
              <Standard-Type { @nr = "1"; @spelling = "set"; }
            }

          }

          <Universal-Quantifier-Formula {
            <Explicitly-Qualified-Segment {
              <Variables {
                <Variable { @spelling = `$arg-1`; }
                <Variable { @spelling = `$arg-2`; }
              }

              if [$arg-type] {
                apply [$arg-type];
              } else {
                <Standard-Type { @nr = "1"; @spelling = "set"; }
              }

            }

            <Conditional-Formula {
              apply [$formula] (#it = $it) mode="replace-it-term";
              apply [$formula] (#x  = $arg-1,
                            #y  = $arg-2,
                            #it = $it) mode="swap";
            }
          }
        }
      }
      when [$shape = "equals"] {
        <Universal-Quantifier-Formula {
          <Explicitly-Qualified-Segment {
            <Variables {
              <Variable { @spelling = `$arg-1`; }
              <Variable { @spelling = `$arg-2`; }
            }

            if [$arg-type] {
              apply [$arg-type];
            } else {
              <Standard-Type { @nr = "1"; @spelling = "set"; }
            }

          }

          <Predicative-Formula {
             @spelling = "=";
             <Arguments {
               apply [$formula] (#it = $it) mode="replace-it-term";
             }
             <Arguments {
               apply [$formula] (#x  = $arg-1,
                                 #y  = $arg-2,
                                 #it = $it) mode="swap";
            }
          }
        }
      }
      otherwise {
        die (#message = `concat ("Unknown shape '", $shape, "' for commutativity.")`);
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-commutativity (#segments = $rest,
                                               #formula  = $formula,
                                               #type     = $type,
                                               #it       = $it,
                                               #shape    = $shape,
                                               #arg-type = $arg-type,
                                               #arg-1    = $arg-1,
                                               #arg-2    = $arg-2);
    }
  }
}

tpl universally-bind-segments-coherence (#segments,
                                         #formula,
                                         #type) {
  if [count ($segments) = 0] {
    <Attributive-Formula {
      apply [$formula];

      if [$type] {
        apply [$type];
      } else {
        <Standard-Type { @nr = "1"; @spelling = "set"; }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-coherence (#segments = $rest,
                                           #formula  = $formula,
                                           #type     = $type);
    }
  }
}

tpl universally-bind-segments-involutiveness (#segments,
                                              #formula,
                                              #type,
                                              #it,
                                              #shape,
                                              #arg-type,
                                              #arg-1) {
  if [count ($segments) = 0] {
    $value-1 = fresh-variable (#prefix = "u");
    $value-2 = fresh-variable (#prefix = "v");
    choose {
      when [$shape = "Means"] {
        die (#message = "We don't yet handle involutiveness for functors defined by a formula.");
      }
      when [$shape = "Equals"] {
        <Universal-Quantifier-Formula {
          <Explicitly-Qualified-Segment {
            <Variables {
              <Variable { @spelling = $value-1; }
	      <Variable { @spelling = $value-2; }
            }

            if [$arg-type] {
              apply [$arg-type];
            } else {
              <Standard-Type { @nr = "1"; @spelling = "set"; }
            }

          }

	  <Conditional-Formula {
	    <Predicative-Formula {
              @spelling = "=";
	      <Arguments {
                <Simple-Term { @spelling = $value-1; }
              }
	      <Arguments {
                apply [$formula] (#target = $arg-1, #val = $value-2) mode="plug-in";
              }
            }
            <Predicative-Formula {
               @spelling = "=";
               <Arguments {
                 <Simple-Term { @spelling = $value-2; }
               }
               <Arguments {
                apply [$formula] (#target = $arg-1, #val = $value-1) mode="plug-in";
              }
            }
          }
        }
      }
      otherwise {
        die (#message = `concat ("Unknown shape '", $shape, "' for involutiveness.")`);
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-involutiveness (#segments = $rest,
                                                #formula  = $formula,
                                                #type     = $type,
                                                #it       = $it,
                                                #shape    = $shape,
                                                #arg-type = $arg-type,
                                                #arg-1    = $arg-1);
    }
  }
}

tpl universally-bind-segments-idempotence (#segments,
                                           #formula,
                                           #type,
                                           #it,
                                           #arg-type,
                                           #arg-1,
                                           #arg-2) {
  if [count ($segments) = 0] {
    <Universal-Quantifier-Formula {

      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable { @spelling = $it; }
        }

        if [$arg-type] {
          apply [$arg-type];
        } else {
          <Standard-Type { @nr = "1"; @spelling = "set"; }
        }

      }

      <Universal-Quantifier-Formula {
        <Explicitly-Qualified-Segment {
          <Variables {
            <Variable { @spelling = `$arg-1`; }
          }

          if [$arg-type] {
            apply [$arg-type];
          } else {
            <Standard-Type { @nr = "1"; @spelling = "set"; }
          }

        }
        apply [$formula] (#x  = $arg-2,
                          #y  = $arg-1,
                          #it = $arg-1) mode="replace";
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-idempotence (#segments = $rest,
                                             #formula  = $formula,
                                             #type     = $type,
                                             #it       = $it,
                                             #arg-type = $arg-type,
                                             #arg-1    = $arg-1,
                                             #arg-2    = $arg-2);
    }
  }
}

tpl universally-bind-segments-symmetry (#segments,
                                        #formula,
                                        #it,
                                        #arg-type,
                                        #arg-1,
                                        #arg-2) {
  if [count ($segments) = 0] {
    <Universal-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable { @spelling = `$arg-1`; }
          <Variable { @spelling = `$arg-2`; }
        }

         if [$arg-type] {
           apply [$arg-type];
        } else {
          <Standard-Type { @nr = "1"; @spelling = "set"; }
        }
      }

      <Conditional-Formula {
        apply [$formula];
        apply [$formula] (#x  = $arg-1,
                          #y  = $arg-2,
                          #it = $it) mode="swap";
      }
    }

  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-symmetry (#segments = $rest,
                                          #formula  = $formula,
                                          #it       = $it,
                                          #arg-type = $arg-type,
                                          #arg-1    = $arg-1,
                                          #arg-2    = $arg-2);
    }
  }
}

tpl universally-bind-segments-asymmetry (#segments,
                                         #formula,
                                         #it,
                                         #arg-type,
                                         #arg-1,
                                         #arg-2) {
  if [count ($segments) = 0] {
    <Universal-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable { @spelling = `$arg-1`; }
          <Variable { @spelling = `$arg-2`; }
        }

         if [$arg-type] {
           apply [$arg-type];
        } else {
          <Standard-Type { @nr = "1"; @spelling = "set"; }
        }
      }

      <Conditional-Formula {
        apply [$formula];
        <Negated-Formula {
          apply [$formula] (#x  = $arg-2,
                            #y  = $arg-1,
                            #it = $it) mode="swap";
        }
      }
    }

  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-asymmetry (#segments = $rest,
                                           #formula  = $formula,
                                           #it       = $it,
                                           #arg-type = $arg-type,
                                           #arg-1    = $arg-1,
                                           #arg-2    = $arg-2);
    }
  }
}

tpl universally-bind-segments-irreflexivity (#segments,
                                             #formula,
                                             #it,
                                             #arg-type,
                                             #arg-1,
                                             #arg-2) {
  if [count ($segments) = 0] {
    <Universal-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable { @spelling = `$arg-1`; }
        }

         if [$arg-type] {
           apply [$arg-type];
        } else {
          <Standard-Type { @nr = "1"; @spelling = "set"; }
        }
      }

      <Negated-Formula {
        apply [$formula] (#x  = $arg-2,
                          #y  = $arg-1,
                          #it = $arg-1) mode="replace";
      }
    }

  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-irreflexivity (#segments = $rest,
                                               #formula  = $formula,
                                               #it       = $it,
                                               #arg-type = $arg-type,
                                               #arg-1    = $arg-1,
                                               #arg-2    = $arg-2);
    }
  }
}

tpl universally-bind-segments-reflexivity (#segments,
                                           #formula,
                                           #it,
                                           #arg-type,
                                           #arg-1,
                                           #arg-2) {
  if [count ($segments) = 0] {
    <Universal-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable { @spelling = `$arg-1`; }
          <Variable { @spelling = `$arg-2`; }
        }

         if [$arg-type] {
           apply [$arg-type];
        } else {
          <Standard-Type { @nr = "1"; @spelling = "set"; }
        }
      }

      apply [$formula] (#x  = $arg-2,
                        #y  = $arg-1,
                        #it = $arg-1) mode="replace";
    }

  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-reflexivity (#segments = $rest,
                                             #formula  = $formula,
                                             #it       = $it,
                                             #arg-type = $arg-type,
                                             #arg-1    = $arg-1,
                                             #arg-2    = $arg-2);
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "compatibility"
    and preceding-sibling::Item
        [
              @kind = "Predicate-Definition"
          and Redefine]]] {
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "CompatibilityLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {
       $locus = `Item[@kind = "Loci-Declaration"]`;
       $segments = `$locus/Explicitly-Qualified-Segment`;
       $pd = `Item[@kind = "Predicate-Definition"]`;
       $original-formula = `$pd/Predicate-Pattern`;
       $new-formula = `$pd/Definiens/*[position() = last()]`;
       universally-bind-segments-compatibility
         (#segments         = $segments,
          #original-formula = $original-formula,
          #new-formula      = $new-formula);
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Predicate-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind = "Property"
    and (   @property = "reflexivity"
         or @property = "irreflexivity"
         or @property = "symmetry"
         or @property = "asymmetry"
         or @property = "connectedness")
    and preceding-sibling::Item
        [
              @kind = "Predicate-Definition"
          and Redefine]]] {
  $p = `@property`;
  msg `concat ("Unsupported property ", $p, " of a redefined predicate.")`;
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "coherence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Equals"
	  and not(Redefine)
        ]
  ]
]
{
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "CoherenceLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Functor-Definition"]`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $type       = `$fd/Type-Specification/*[1]`;
        $segments   = `$locus/Explicitly-Qualified-Segment`;
        universally-bind-segments-coherence
          (#segments = $segments,
           #formula  = $formula,
           #type     = $type);
      }
    }

    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }

}

tpl
[
  Item
  [
    @kind = "Definition-Item"
    and Block
        [
          @kind = "Definitional-Block"
          and Item
              [
                    @kind = "Functor-Definition"
                and not(Redefine)
              ]
        ]
  ]
]
{
  for-each [Block[@kind = "Definitional-Block"]] {
    for-each [Item[@kind = "Correctness-Condition" or @kind = "Property"]] {

      choose {
        when [self::Item[@kind = "Correctness-Condition"]] {
          $c = `@condition`;
          msg `concat ("working on condition ", $c)`;
        }
        when [self::Item[@kind = "Property"]] {
          $p = `@property`;
          msg `concat ("working on property ", $p)`;
        }
        when [self::Item[@kind = "Correctness"]] {
          msg "working on correctness";
        }
      }

      apply [.];
      msg "done.";
    }
  }

  <Item {
    for-each [@*] { copy-of `.`; }
    for-each [Block[@kind = "Definitional-Block"]] {
      <Block {
        for-each [@*] { copy-of `.`; }
        for-each [*] {
          choose {
            when [self::Item[@kind = "Correctness-Condition"]] {
              apply [.] mode="straightforward-correctness";
            }
            when [self::Item[@kind = "Property"]] {
              apply [.] mode="straightforward-correctness";
            }
            otherwise {
              apply [.];
            }
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and Redefine
        ]
  ]
]
{
  $c = `@condition`;
  msg `concat ("Warning: unsupported correctness condition '", $c, "' for a redefined functor.")`;
  apply [.] mode="copy";
}

tpl
[
  Item
  [
        @kind      = "Property"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and Redefine
        ]
  ]
]
{
  $p = `@property`;
  msg `concat ("Warning: unsupported property '", $p, "' of a redefined functor.")`;
  apply [.] mode="copy";
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "coherence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
        ]
  ]
]
{
  die (#message = "We don't handle coherence conditions yet.");
}

tpl
[
  Item
  [
    @kind = "Definition-Item"
    and Block
        [
          @kind = "Definitional-Block"
          and Item
              [
                    @kind = "Predicate-Definition"
                and not(Redefine)
              ]
        ]
  ]
]
{
  for-each [Block[@kind = "Definitional-Block"]] {
    for-each [Item[@kind = "Correctness-Condition" or @kind = "Property"]] {
      apply [.];
    }
  }
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*] mode="straightforward-correctness";
  }
}

tpl [*] (#it) mode="replace-it-term" {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*] (#it = $it) mode="replace-it-term";
  }
}

tpl [it-Term] (#it) mode="replace-it-term" {
  <Simple-Term {
    @spelling = $it;
  }
}

tpl [*] (#x, #y, #it) mode="swap" {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*] (#x = $x, #y = $y, #it = $it) mode="swap";
  }
}

tpl [it-Term] (#x, #y, #it) mode="swap" {
  <Simple-Term {
    @spelling = $it;
  }
}

tpl [Simple-Term] (#x, #y, #it) mode="swap" {
  $s = `@spelling`;
  <Simple-Term {
    for-each [@*] { copy-of `.`; }
    choose {
      when [$s = $x] { @spelling = $y; }
      when [$s = $y] { @spelling = $x; }
      otherwise { @spelling = $s; }
    }
  }
}

tpl [*] (#x, #y, #it) mode="replace" {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*] (#x = $x, #y = $y, #it = $it) mode="replace";
  }
}

tpl [it-Term] (#x, #y, #it) mode="replace" {
  <Simple-Term {
    @spelling = $it;
  }
}

tpl [Simple-Term] (#x, #y, #it) mode="replace" {
  $s = `@spelling`;
  <Simple-Term {
    for-each [@*] { copy-of `.`; }
    if [$s = $x] {
      @spelling = $y;
    } else {
      @spelling = $s;
    }
  }
}



tpl [*] (#target, #val) mode="plug-in" {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*] (#target = $target, #val = $val) mode="plug-in";
  }
}

tpl [Simple-Term] (#target, #val) mode="plug-in" {
  $s = `@spelling`;
  if [$s = $target] {
    <Simple-Term { @spelling = $val; }
  } else {
    <Simple-Term {
      for-each [@*] { copy-of `.`; }
      apply [*] (#target = $target, #val = $val) mode="plug-in";
    }
  }
}

tpl [*] mode="straightforward-correctness" {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*] mode="straightforward-correctness";
  }
}

tpl
[
  Block
  [
        @kind = "Proof"
    and parent::Item
        [
          @kind = "Correctness-Condition"
        ]
  ]
] mode="straightforward-correctness"
{
  $c = `parent::Item[@kind = "Correctness-Condition"]/@condition`;
  <Straightforward-Justification {
    choose {
      when [$c = "existence"] {
        <Local-Reference { @spelling = "ExistenceLemma"; }
      }
      when [$c = "uniqueness"] {
        <Local-Reference { @spelling = "UniquenessLemma"; }
      }
      when [$c = "coherence"] {
        <Local-Reference { @spelling = "CoherenceLemma"; }
      }
      when [$c = "compatibility"] {
        <Local-Reference { @spelling = "CompatibilityLemma"; }
      }
      otherwise {
        die (#message = `concat ("Don't know how to handle a '", $c, "' correctness condition.")`);
      }
    }
    for-each [ancestor::Block[@kind = "Definitional-Block"]] {
      for-each [Item[@kind = "Choice-Statement"]/Conditions/Proposition/Label] {
        <Local-Reference {
          @spelling = `@spelling`;
        }
      }
    }
  }
}

tpl
[
  Block
  [
        @kind = "Proof"
    and parent::Item
        [
          @kind = "Property"
        ]
  ]
]
mode="straightforward-correctness"
{
  $p = `parent::Item[@kind = "Property"]/@property`;
  choose {
    when [$p = "idempotence"] {
      <Straightforward-Justification {
        <Local-Reference { @spelling = "IdempotenceLemma"; }
      }
    }
    when [$p = "commutativity"] {
      <Straightforward-Justification {
        <Local-Reference { @spelling = "CommutativityLemma"; }
      }
    }
   when [$p = "involutiveness"] {
      <Straightforward-Justification {
        <Local-Reference { @spelling = "InvolutivenessLemma"; }
      }
    }
    when [$p = "asymmetry"] {
      <Straightforward-Justification {
        <Local-Reference { @spelling = "AsymmetryLemma"; }
      }
    }
    when [$p = "reflexivity"] {
      <Straightforward-Justification {
        <Local-Reference { @spelling = "ReflexivityLemma"; }
      }
    }
    when [$p = "irreflexivity"] {
      <Straightforward-Justification {
        <Local-Reference { @spelling = "IrreflexivityLemma"; }
      }
    }
    otherwise {
      die (#message = `concat ("Don't know how to handle a '", $p, "' property.")`);
    }
  }
}

tpl
[
  Straightforward-Justification
  [
    parent::Item
    [
      @kind = "Property"
    ]
  ]
]
mode="straightforward-correctness"
{
  $p = `parent::Item[@kind = "Property"]/@property`;
  <Straightforward-Justification {
    choose {
      when [$p = "idempotence"] {
        <Local-Reference { @spelling = "IdempotenceLemma"; }
      }
      when [$p = "involutiveness"] {
        <Local-Reference { @spelling = "InvolutivenessLemma"; }
      }
      when [$p = "commutativity"] {
        <Local-Reference { @spelling = "CommutativityLemma"; }
      }
      when [$p = "asymmetry"] {
        <Local-Reference { @spelling = "AsymmetryLemma"; }
      }
     when [$p = "symmetry"] {
        <Local-Reference { @spelling = "SymmetryLemma"; }
      }
      when [$p = "reflexivity"] {
        <Local-Reference { @spelling = "ReflexivityLemma"; }
      }
      when [$p = "irreflexivity"] {
        <Local-Reference { @spelling = "IrreflexivityLemma"; }
      }
      otherwise {
        die (#message = `concat ("Don't know how to handle a '", $p, "' property.")`);
      }
    }
    for-each [ancestor::Block[@kind = "Definitional-Block"]] {
      for-each [Item[@kind = "Choice-Statement"]/Conditions/Proposition/Label] {
        <Local-Reference {
          @spelling = `@spelling`;
        }
      }
    }
  }
}

tpl
[
  Definiens
  [
    @kind = "Simple-Definiens"
    and @shape = "Formula-Expression"
    and parent::Item
        [
          @kind = "Functor-Definition"
          and @shape = "Means"
          and preceding-sibling::Item
              [
                @kind = "Assumption"
                and not(Single-Assumption)
              ]
        ]
  ]
]
{
  die (#message = "Don't know how to handle non-Single-Assumption definitions.");
}

tpl
[
  Definiens
  [
    @kind = "Simple-Definiens"
    and @shape = "Formula-Expression"
    and parent::Item
        [
          @kind = "Functor-Definition"
          and @shape = "Means"
          and count(preceding-sibling::Item
                    [
                      @kind = "Assumption"
                      and Single-Assumption
                    ]) > 1
        ]
  ]
]
{
  die (#message = "Don't know how to handle multiple Single-Assumption definitions.");
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "existence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
         ]
  ]
]
{
  $definiens = `preceding-sibling::Item[@kind = "Functor-Definition" and @shape = "Means"]/Definiens/*[position() = last()]`;
  $existential-variable = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "ExistenceLemma"; }
      $segments = `preceding-sibling::Item[@kind = "Loci-Declaration"]/Explicitly-Qualified-Segment`;
      $fd = `preceding-sibling::Item[@kind = "Functor-Definition" and @shape = "Means"]`;
      $type = `$fd/Operation-Functor-Pattern/Type-Specification/*[1]`;
      universally-bind-segments-existence (#segments   = $segments,
                                           #formula    = $definiens,
                                           #type       = $type,
                                           #it         = $existential-variable);
    }
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "existence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 1
         ]
  ]
]
{
  $definiens = `preceding-sibling::Item[@kind = "Functor-Definition" and @shape = "Means"]/Definiens/*[position() = last()]`;
  $existential-variable = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Diffuse-Statement";
    <Label { @spelling = "ExistenceLemma"; }
    <Block {
      @kind = "Now-Reasoning";
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {
        for-each [Item[@kind = "Loci-Declaration" or @kind = "Choice-Statement" or @kind = "Assumption"]] {
          choose {
            when [self::Item[@kind = "Loci-Declaration"]] {
              <Item { @kind = "Generalization"; apply [*]; }
            }
            otherwise {
              // nothing special to do; apply the default template
              apply [.];
            }
          }
        }
      }
      <Item {
        @kind = "Conclusion";
        @shape = "Compact-Statement";
        $fd = `preceding-sibling::Item[@kind = "Functor-Definition"]`;
        $formula = `$fd/Definiens/*[position() = last()]`;
        $type = `$fd/Type-Specification/*[1]`;
        <Proposition {
          <Existential-Quantifier-Formula {
            <Explicitly-Qualified-Segment {
              <Variables {
                <Variable { @spelling = $existential-variable; }
              }
              if [$type] {
                apply [$type];
              } else {
                <Standard-Type { @nr = "1"; @spelling = "set"; }
              }
            }
            apply [$formula] (#it = $existential-variable) mode="replace-it-term";
          }
        }
        apply [*[position() = last()]];
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "existence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and (count (preceding-sibling::Item[@kind = "Assumption"]) > 1)
         ]
  ]
]
{
  die (#message = "We do not yet handle existence conditions for functor definitions that have multiple assumtions.");
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "uniqueness"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $uniqueness-variable-1 = fresh-variable (#prefix = "A");
  $uniqueness-variable-2 = fresh-variable (#prefix = "B");
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "UniquenessLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $segments   = `$locus/Explicitly-Qualified-Segment`;
        $fd         = `Item[@kind = "Functor-Definition"]`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $type       = `$fd/Type-Specification/*[1]`;
        $assumption = `Item[@kind = "Assumption"]/Single-Assumption/Proposition/*[position() = last()]`;

        universally-bind-segments-uniqueness
          (#segments   = $segments,
           #variable-1 = $uniqueness-variable-1,
           #variable-2 = $uniqueness-variable-2,
           #formula    = $formula,
           #type       = $type);
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "uniqueness"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 1
        ]
  ]
]
{
  $uniqueness-variable-1 = fresh-variable (#prefix = "A");
  $uniqueness-variable-2 = fresh-variable (#prefix = "B");
  <Item {
    @kind = "Regular-Statement";
    @shape = "Diffuse-Statement";
    <Label { @spelling = "UniquenessLemma"; }
    <Block {
      @kind = "Now-Reasoning";
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {
        for-each [Item[@kind = "Loci-Declaration" or @kind = "Choice-Statement" or @kind = "Assumption"]] {
          choose {
            when [self::Item[@kind = "Loci-Declaration"]] {
              <Item { @kind = "Generalization"; apply [*]; }

            }
            otherwise {
              // nothing special to do; apply the default template
              apply [.];
            }
          }
        }
      }
      <Item {
        @kind = "Conclusion";
        @shape = "Compact-Statement";
        $fd = `preceding-sibling::Item[@kind = "Functor-Definition"]`;
        $formula = `$fd/Definiens/*[position() = last()]`;
        $type = `$fd/Type-Specification/*[1]`;
        <Proposition {
          <Universal-Quantifier-Formula {
            <Explicitly-Qualified-Segment {
              <Variables {
                <Variable { @spelling = $uniqueness-variable-1; }
                <Variable { @spelling = $uniqueness-variable-2; }
              }
              if [$type] {
                apply [$type];
              } else {
                <Standard-Type { @nr = "1"; @spelling = "set"; }
              }
            }
            <Conditional-Formula {
              <Conjunctive-Formula {
                apply [$formula] (#it = $uniqueness-variable-1) mode="replace-it-term";
                apply [$formula] (#it = $uniqueness-variable-2) mode="replace-it-term";
              }
              <Predicative-Formula {
               @spelling = "=";
                <Arguments { <Simple-Term { @spelling = $uniqueness-variable-1; } }
                <Arguments { <Simple-Term { @spelling = $uniqueness-variable-2; } }
              }
            }
          }
        }
        apply [*[position() = last()]];
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "uniqueness"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) > 1
        ]
  ]
]
{
  die (#message = "We do not handle uniqueness conditions for functor definitions that have assumptions.");
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "commutativity"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "CommutativityLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Functor-Definition"]`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $type       = `$fd/Type-Specification/*[1]`;
        $pattern    = `$fd/Operation-Functor-Pattern`;
        for-each [$pattern] {
          $arg-1 = `descendant::Locus[1]`;
          $arg-2 = `descendant::Locus[2]`;
          $arg-1-spelling = `$arg-1/@spelling`;
          $arg-2-spelling = `$arg-2/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment[not(Variables/Variable[@spelling = $arg-1-spelling or @spelling = $arg-2-spelling])]`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg-1-spelling]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              for-each [*[position() = last()]] {
                $arg-type = `*[position() = last()]`;
                universally-bind-segments-commutativity
                  (#segments = $segments,
                   #formula  = $formula,
                   #type     = $type,
                   #it       = $it,
                   #shape    = "means",
                   #arg-type = $arg-type,
                   #arg-1    = $arg-1-spelling,
                   #arg-2    = $arg-2-spelling);
              }
            }
          }
        }
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "commutativity"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Equals"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "CommutativityLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Functor-Definition"]`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $type       = `$fd/Type-Specification/*[1]`;
        $pattern    = `$fd/Operation-Functor-Pattern`;
        for-each [$pattern] {
          $arg-1 = `descendant::Locus[1]`;
          $arg-2 = `descendant::Locus[2]`;
          $arg-1-spelling = `$arg-1/@spelling`;
          $arg-2-spelling = `$arg-2/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment[not(Variables/Variable[@spelling = $arg-1-spelling or @spelling = $arg-2-spelling])]`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg-1-spelling]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              for-each [*[position() = last()]] {
                $arg-type = `*[position() = last()]`;
                universally-bind-segments-commutativity
                  (#segments = $segments,
                   #formula  = $formula,
                   #shape    = "equals",
                   #type     = $type,
                   #it       = $it,
                   #arg-type = $arg-type,
                   #arg-1    = $arg-1-spelling,
                   #arg-2    = $arg-2-spelling);
              }
            }
          }
        }
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "idempotence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "IdempotenceLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Functor-Definition"]`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $type       = `$fd/Type-Specification/*[1]`;
        $pattern    = `$fd/Operation-Functor-Pattern`;
        for-each [$pattern] {
          $arg-1 = `descendant::Locus[1]`;
          $arg-2 = `descendant::Locus[2]`;
          $arg-1-spelling = `$arg-1/@spelling`;
          $arg-2-spelling = `$arg-2/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment[not(Variables/Variable[@spelling = $arg-1-spelling or @spelling = $arg-2-spelling])]`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg-1-spelling]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              for-each [*[position() = last()]] {
                $arg-type = `*[position() = last()]`;
                universally-bind-segments-idempotence
                  (#segments = $segments,
                   #formula  = $formula,
                   #type     = $type,
                   #it       = $it,
                   #arg-type = $arg-type,
                   #arg-1    = $arg-1-spelling,
                   #arg-2    = $arg-2-spelling);
              }
            }
          }
        }
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "involutiveness"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "InvolutivenessLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Functor-Definition"]`;
	$shape      = `$fd/@shape`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $type       = `$fd/Type-Specification/*[1]`;
        $pattern    = `$fd/Operation-Functor-Pattern`;
        for-each [$pattern] {
          $arg-1 = `descendant::Locus[1]`;
          $arg-1-spelling = `$arg-1/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment[not(Variables/Variable[@spelling = $arg-1-spelling])]`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg-1-spelling]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              for-each [*[position() = last()]] {
                $arg-type = `.`;
                universally-bind-segments-involutiveness
                  (#segments = $segments,
                   #formula  = $formula,
                   #type     = $type,
                   #it       = $it,
		   #shape    = $shape,
                   #arg-type = $arg-type,
                   #arg-1    = $arg-1-spelling);
              }
            }
          }
        }
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              $fd      = `Item[@kind = "Functor-Definition"]`;
              $pattern = `$fd/Operation-Functor-Pattern`;
              $block = `.`;
              for-each [$pattern] {
                $loci = `descendant::Locus`;
                for-each [$block] {
                  for-each [*[following-sibling::Item[@kind = "Functor-Definition"]]] {
                  if [self::Item[@kind = "Loci-Declaration"]] {
                    if [@spelling = $loci/@spelling] {
                      // ignore
                    } else {
                      <Item {
                        @kind = "Generalization";
                        apply [*];
                      }
                    }
                  } else {
                    apply [.];
                  }
                }
              }

              }
            }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "symmetry"
    and preceding-sibling::Item
        [
              @kind  = "Predicate-Definition"
          and not(Redefine)
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "SymmetryLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Predicate-Definition"]`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $pattern    = `$fd/Predicate-Pattern`;
        for-each [$pattern] {
          $arg-1 = `descendant::Locus[1]`;
          $arg-2 = `descendant::Locus[2]`;
          $arg-1-spelling = `$arg-1/@spelling`;
          $arg-2-spelling = `$arg-2/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment[not(Variables/Variable[@spelling = $arg-1-spelling or @spelling = $arg-2-spelling])]`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg-1-spelling]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              for-each [*[position() = last()]] {
                $arg-type = `*[position() = last()]`;
                universally-bind-segments-symmetry
                  (#segments = $segments,
                   #formula  = $formula,
                   #it       = $it,
                   #arg-type = $arg-type,
                   #arg-1    = $arg-1-spelling,
                   #arg-2    = $arg-2-spelling);
              }
            }
          }
        }
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Predicate-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "asymmetry"
    and preceding-sibling::Item
        [
              @kind  = "Predicate-Definition"
	  and not(Redefine)
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "AsymmetryLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Predicate-Definition"]`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $pattern    = `$fd/Predicate-Pattern`;
        for-each [$pattern] {
          $arg-1 = `descendant::Locus[1]`;
          $arg-2 = `descendant::Locus[2]`;
          $arg-1-spelling = `$arg-1/@spelling`;
          $arg-2-spelling = `$arg-2/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment[not(Variables/Variable[@spelling = $arg-1-spelling or @spelling = $arg-2-spelling])]`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg-1-spelling]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              for-each [*[position() = last()]] {
                $arg-type = `*[position() = last()]`;
                universally-bind-segments-asymmetry
                  (#segments = $segments,
                   #formula  = $formula,
                   #it       = $it,
                   #arg-type = $arg-type,
                   #arg-1    = $arg-1-spelling,
                   #arg-2    = $arg-2-spelling);
              }
            }
          }
        }
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            // for-each [ancestor::Block[@kind = "Definitional-Block"]] {
            //   for-each [*[following-sibling::Item[@kind = "Predicate-Definition"]]] {
            //     if [self::Item[@kind = "Loci-Declaration"]] {
            //       <Item {
            //         @kind = "Generalization";
            //         apply [*];
            //       }
            //     } else {
            //       apply [.];
            //     }
            //   }
            // }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "irreflexivity"
    and preceding-sibling::Item
        [
              @kind  = "Predicate-Definition"
	  and not(Redefine)
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "IrreflexivityLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Predicate-Definition"]`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $pattern    = `$fd/Predicate-Pattern`;
        for-each [$pattern] {
          $arg-1 = `descendant::Locus[1]`;
          $arg-2 = `descendant::Locus[2]`;
          $arg-1-spelling = `$arg-1/@spelling`;
          $arg-2-spelling = `$arg-2/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment[not(Variables/Variable[@spelling = $arg-1-spelling or @spelling = $arg-2-spelling])]`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg-1-spelling]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              for-each [*[position() = last()]] {
                $arg-type = `*[position() = last()]`;
                universally-bind-segments-irreflexivity
                  (#segments = $segments,
                   #formula  = $formula,
                   #it       = $it,
                   #arg-type = $arg-type,
                   #arg-1    = $arg-1-spelling,
                   #arg-2    = $arg-2-spelling);
              }
            }
          }
        }
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Predicate-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Property"
    and @property = "reflexivity"
    and preceding-sibling::Item
        [
              @kind  = "Predicate-Definition"
	  and not(Redefine)
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $it = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "ReflexivityLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {

        $locus      = `Item[@kind = "Loci-Declaration"]`;
        $fd         = `Item[@kind = "Predicate-Definition"]`;
        $formula    = `$fd/Definiens/*[position() = last()]`;
        $pattern    = `$fd/Predicate-Pattern`;
        for-each [$pattern] {
          $arg-1 = `descendant::Locus[1]`;
          $arg-2 = `descendant::Locus[2]`;
          $arg-1-spelling = `$arg-1/@spelling`;
          $arg-2-spelling = `$arg-2/@spelling`;

          $segments   = `$locus/Explicitly-Qualified-Segment[not(Variables/Variable[@spelling = $arg-1-spelling or @spelling = $arg-2-spelling])]`;

          for-each [$locus/Explicitly-Qualified-Segment/Variables/Variable[@spelling = $arg-1-spelling]] {
            for-each [ancestor::Explicitly-Qualified-Segment] {
              for-each [*[position() = last()]] {
                $arg-type = `*[position() = last()]`;
                universally-bind-segments-reflexivity
                  (#segments = $segments,
                   #formula  = $formula,
                   #it       = $it,
                   #arg-type = $arg-type,
                   #arg-1    = $arg-1-spelling,
                   #arg-2    = $arg-2-spelling);
              }
            }
          }
        }
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [ancestor::Block[@kind = "Definitional-Block"]] {
              for-each [*[following-sibling::Item[@kind = "Predicate-Definition"]]] {
                if [self::Item[@kind = "Loci-Declaration"]] {
                  <Item {
                    @kind = "Generalization";
                    apply [*];
                  }
                } else {
                  apply [.];
                }
              }
            }
            apply [*];
          }
        }
      }
    }

  }
}