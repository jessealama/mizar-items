stylesheet "1.0";
import "utils/die.xsl";
import "utils/copy.xsl";
output method="xml" indent="yes";

tpl try-fresh-variable (#prefix, #try) {
  $trial-name = `concat ($prefix, $try)`;
  $next-try = `$try + 1`;
  choose {
    when [descendant::Simple-Term[@spelling = $trial-name]] {
      try-fresh-variable (#prefix = $prefix,
                          #try = $next-try);
    }
    when [descendant::Variable[@spelling = $trial-name]] {
      try-fresh-variable (#prefix = $prefix,
                          #try = $next-try);
    }
    otherwise {
      $trial-name;
    }
  }
}

tpl fresh-variable (#prefix) {
  for-each [ancestor::Text-Proper] {
    if [$prefix = ""] {
      try-fresh-variable (#prefix = "z", #try = "1");
    } else {
      try-fresh-variable (#prefix = $prefix, #try = "1");
    }
  }
}

tpl emit-conjunction-of-attributive-adjectives (#term-name, #adjectives) {
  choose {
    when [count ($adjectives) = 0] {
      die (#message = "Error: zero adjectives were given.");
    }
    when [count ($adjectives) = 1] {
      $adjective = `$adjectives[1]`;
      <Attributive-Formula {
        <Simple-Term {
          @spelling = $term-name;
        }
        apply [$adjective];
      }
    }
    otherwise {
      $first-adjective = `$adjectives[1]`;
      $remaining-adjectives = `$adjectives[position () > 1]`;
      <Conjunctive-Formula {
        <Attributive-Formula {
          <Simple-Term {
            @spelling = $term-name;
          }
          apply [$first-adjective];
        }
        emit-conjunction-of-attributive-adjectives (#term-name = $term-name,
                                                    #adjectives = $remaining-adjectives);
      }
    }
  }
}

// By default, copy
tpl [*] {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

// Sanity check
tpl [Text-Proper] {
  if [count (descendant::Implicitly-Qualified-Segment) > 0] {
    die (#message = "There are not supposed to be any Implicitly-Qualified-Segments");
  } else {
    <Text-Proper {
      for-each [@*] { copy-of `.`; }
      apply [*];
    }
  }
}

tpl universally-bind-conjunction-of-adjectives (#adjectives,
                                                #it,
                                                #type,
                                                #segments) {
  $num-adjectives = `count ($adjectives)`;
  // msg `concat ($num-adjectives, " adjectives")`;
  if [count ($segments) = 0] {
    <Existential-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable {
            @spelling = $it;
          }
        }
        apply [$type];
      }
      emit-conjunction-of-attributive-adjectives (#term-name  = $it,
                                                  #adjectives = $adjectives);
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-conjunction-of-adjectives (#segments   = $rest,
                                                  #type       = $type,
                                                  #it         = $it,
                                                  #adjectives = $adjectives);
    }
  }
}

tpl
[
  Item
  [
        @kind = "Definition-Item"
    and Block
        [
              @kind = "Registration-Block"
          and Item
              [
                    @kind = "Cluster"
                and Existential-Registration
              ]
          and Item
              [
                    @kind = "Correctness-Condition"
                and Block[@kind = "Proof"]
              ]
        ]
 ]
] {
  // Emit a lemma before the condition
  $fresh-variable = fresh-variable (#prefix = "Z");
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "Existence"; }
      for-each [Block[@kind = "Registration-Block"]] {
        $locus = `Item[@kind = "Loci-Declaration"]`;
        $segments = `$locus/Explicitly-Qualified-Segment`;
        $cluster = `Item[@kind = "Cluster"]`;
        $exreg = `$cluster/Existential-Registration`;
        $adcluster = `$exreg/Adjective-Cluster`;
        $type = `$exreg/*[position() = last()]`;
        $adjectives = `$adcluster/Adjective | $adcluster/NegatedAdjective`;
        universally-bind-conjunction-of-adjectives
          (#segments   = $segments,
           #type       = $type,
           #adjectives = $adjectives,
           #it         = $fresh-variable);
      }
    }
    <Block {
      @kind = "Proof";
      for-each [Block[@kind = "Registration-Block"]] {
        for-each [Item[@kind = "Correctness-Condition" and @condition = "existence"]] {
          for-each [Block[@kind = "Proof"]] {
            apply [*];
          }
        }
      }
    }
  }
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl
[
  Block
  [
        @kind = "Proof"
    and parent::Item
        [
              @kind      = "Correctness-Condition"
          and @condition = "existence"
          and parent::Block
              [
                    @kind = "Registration-Block"
                and parent::Item
                    [
                          @kind = "Definition-Item"
                      and parent::Text-Proper
                    ]
              ]
        ]
  ]
]
{
  <Straightforward-Justification { <Local-Reference { @spelling = "Existence"; } }
}

tpl universally-bind-segments-existence (#segments,
                                         #it,
                                         #formula,
                                         #type,
                                         #assumption) {
  if [count ($segments) = 0] {
    if [$assumption] {
      <Conditional-Formula {
        apply [$assumption];
        <Existential-Quantifier-Formula {
          <Explicitly-Qualified-Segment {

            <Variables {
              <Variable {
                @spelling = $it;
              }
            }

            if [$type] {
              apply [$type];
            } else {
              <Standard-Type { @nr = "1"; @spelling = "set"; }
            }

          }

          apply [$formula] (#it = $it) mode="replace-it-term";

        }
      }
    } else {
      <Existential-Quantifier-Formula {
        <Explicitly-Qualified-Segment {

          <Variables {
            <Variable {
              @spelling = $it;
            }
          }

          if [$type] {
            apply [$type];
          } else {
            <Standard-Type { @nr = "1"; @spelling = "set"; }
          }

        }

        apply [$formula] (#it = $it) mode="replace-it-term";

      }

    }

  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-existence (#segments   = $rest,
      					   #it         = $it,
	                                   #formula    = $formula,
	                                   #type       = $type,
	                                   #assumption = $assumption);
    }
  }
}

tpl universally-bind-segments-uniqueness (#segments,
                                          #variable-1,
                                          #variable-2,
                                          #formula,
                                          #type,
					  #assumption) {
  if [count ($segments) = 0] {
    <Universal-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable { @spelling = $variable-1; }
          <Variable { @spelling = $variable-2; }
        }

        if [$type] {
          apply [$type];
        } else {
          <Standard-Type { @nr = "1"; @spelling = "set"; }
        }

      }
      if [$assumption] {
        <Conditional-Formula {
          <Conjunctive-Formula {
            <Conditional-Formula {
              apply [$assumption];
              apply [$formula] (#it = $variable-1) mode="replace-it-term";
            }
            <Conditional-Formula {
              apply [$assumption];
              apply [$formula] (#it = $variable-2) mode="replace-it-term";
            }
          }
          <Predicative-Formula {
            @spelling = "=";
            <Arguments { <Simple-Term { @spelling = $variable-1; } }
            <Arguments { <Simple-Term { @spelling = $variable-2; } }
          }
        }
      } else {
        <Conditional-Formula {
          <Conjunctive-Formula {
            apply [$formula] (#it = $variable-1) mode="replace-it-term";
            apply [$formula] (#it = $variable-2) mode="replace-it-term";
          }
          <Predicative-Formula {
            @spelling = "=";
            <Arguments { <Simple-Term { @spelling = $variable-1; } }
            <Arguments { <Simple-Term { @spelling = $variable-2; } }
          }
        }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-uniqueness (#segments   = $rest,
                                            #variable-1 = $variable-1,
                                            #variable-2 = $variable-2,
                                            #formula    = $formula,
                                            #type       = $type,
					    #assumption = $assumption);
    }
  }
}

tpl universally-bind-segments-compatibility (#segments,
                                             #original-formula,
                                             #new-formula) {
  if [count ($segments) = 0] {
    <Biconditional-Formula {
      apply [$original-formula];
      apply [$new-formula];
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-compatibility
        (#segments         = $rest,
         #original-formula = $original-formula,
         #new-formula      = $new-formula);
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "compatibility"
    and preceding-sibling::Item
        [
              @kind = "Predicate-Definition"
          and Redefine]]] {
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "CompatibilityLemma"; }
      for-each [Block[@kind = "Definitional-Block"]] {
       $locus = `Item[@kind = "Loci-Declaration"]`;
       $segments = `$locus/Explicitly-Qualified-Segment`;
       $pd = `Item[@kind = "Predicate-Definition"]`;
       $original-formula = `$pd/Predicate-Pattern`;
       $new-formula = `$pd/Definiens/*[position() = last()]`;
       universally-bind-segments-compatibility
         (#segments         = $segments,
          #original-formula = $original-formula,
          #new-formula      = $new-formula);
      }
    }
    <Block {
      @kind = "Proof";
      for-each [Block[@kind = "Definitional-Block"]] {
        for-each [Item[@kind = "Loci-Declaration"]] {
          <Item {
            @kind = "Generalization";
            apply [Explicitly-Qualified-Segment];
          }
        }
        for-each [Item[    @kind      = "Correctness-Condition"
                       and @condition = "compatibility"]] {
          for-each [Block[@kind = "Proof"]] {
            apply [*];
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "coherence"
    and preceding-sibling::Item
        [
          @kind = "Functor-Definition"
        ]
  ]
]
{
  choose {
    when [Proof] {
      die (#message = "Don't know how to handle a coherence item justified by a proof.");
    }
    when [Straightforward-Justification and count (Straightforward-Justification/*) = 1] {
      // skip: there's already a single lemma/theorem/scheme that
      // justifies this
    }
    when [Straightforward-Justification and count (Straightforward-Justification/*) = 0] {
      // skip: this is obvious for the checker
    }
    when [Straightforward-Justification and count (Straightforward-Justification/*) > 1] {
      die (#message = "Don't know how to handle a coherence item justified by multiple items.");
    }
  }
}

tpl
[
  Item
  [
    @kind = "Definition-Item"
    and Block
        [
          @kind = "Definitional-Block"
          and Item
              [
                @kind = "Functor-Definition"
              ]
        ]
  ]
]
{
  for-each [Block[@kind = "Definitional-Block"]] {
    for-each [Item[@kind = "Correctness-Condition" and @condition]] {
      $c = `@condition`;
      msg `concat ("working on condition ", $c)`;
      apply [.];
      msg "done.";
    }
  }

  <Item {
    for-each [@*] { copy-of `.`; }
    for-each [Block[@kind = "Definitional-Block"]] {
      <Block {
        for-each [@*] { copy-of `.`; }
          for-each [*] {
            if [self::Item[@kind = "Correctness-Condition"]] {
              // ignore
            } else {
              apply [.];
            }
          }

          apply [Item[@kind = "Correctness-Condition"]]
            mode="straightforward-correctness";

      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "coherence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
        ]
  ]
]
{
  die (#message = "We don't handle coherence conditions yet.");
}

tpl
[
  Item
  [
    @kind = "Definition-Item"
    and Block
        [
          @kind = "Definitional-Block"
          and Item
              [
                @kind = "Predicate-Definition"
              ]
        ]
  ]
]
{
  for-each [Block[@kind = "Definitional-Block"]] {
    for-each [Item[@kind = "Correctness-Condition"]] {
      apply [.];
    }
  }
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*] mode="straightforward-correctness";
  }
}

tpl [*] (#it) mode="replace-it-term" {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*] (#it = $it) mode="replace-it-term";
  }
}

tpl [it-Term] (#it) mode="replace-it-term" {
  <Simple-Term {
    @spelling = $it;
  }
}

tpl [*] mode="straightforward-correctness" {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*] mode="straightforward-correctness";
  }
}

tpl
[
  Block
  [
        @kind = "Proof"
    and parent::Item
        [
          @kind = "Correctness-Condition"
        ]
  ]
]
mode="straightforward-correctness"
{
  $c = `parent::Item[@kind = "Correctness-Condition"]/@condition`;
  choose {
    when [$c = "existence"] {
      <Straightforward-Justification {
        <Local-Reference { @spelling = "ExistenceLemma"; }
      }
    }
    when [$c = "uniqueness"] {
      <Straightforward-Justification {
        <Local-Reference { @spelling = "UniquenessLemma"; }
      }
    }
    when [$c = "coherence"] {
      <Straightforward-Justification {
        <Local-Reference { @spelling = "CoherenceLemma"; }
      }
    }
    when [$c = "compatibility"] {
      <Straightforward-Justification {
        <Local-Reference { @spelling = "CompatibilityLemma"; }
      }
    }
    otherwise {
      die (#message = `concat ("Don't know how to handle a '", $c, "' correctness condition.")`);
    }
  }
}

tpl
[
  Definiens
  [
    @kind = "Simple-Definiens"
    and @shape = "Formula-Expression"
    and parent::Item
        [
          @kind = "Functor-Definition"
          and @shape = "Means"
          and preceding-sibling::Item
              [
                @kind = "Assumption"
                and not(Single-Assumption)
              ]
        ]
  ]
]
{
  die (#message = "Don't know how to handle non-Single-Assumption definitions.");
}

tpl
[
  Definiens
  [
    @kind = "Simple-Definiens"
    and @shape = "Formula-Expression"
    and parent::Item
        [
          @kind = "Functor-Definition"
          and @shape = "Means"
          and count(preceding-sibling::Item
                    [
                      @kind = "Assumption"
                      and Single-Assumption
                    ]) > 1
        ]
  ]
]
{
  die (#message = "Don't know how to handle multiple Single-Assumption definitions.");
}

// tpl
// [
//   Definiens
//   [
//         @kind  = "Simple-Definiens"
//     and @shape = "Formula-Expression"
//     and parent::Item
//         [
//               @kind  = "Functor-Definition"
//           and @shape = "Means"
//           and preceding-sibling::Item
//               [
//                     @kind = "Assumption"
//                 and Single-Assumption
//               ]
//         ]
//   ]
// ] {
//   msg "making a conditional definiens";
//   $definiens = `.`;
//   <Definiens {
//     @kind = "Simple-Definiens";
//     @shape = "Formula-Expression";
//     <Conditional-Formula {
//       for-each [parent::Item[@kind = "Functor-Definition"
//                              and @shape = "Means"]] {
//         for-each [preceding-sibling::Item[@kind = "Assumption"]] {
//           for-each [Single-Assumption] {
//             for-each [Proposition] {
//               apply [*[position() = last()]];
//             }
//           }
//         }
//       }
//       apply [*[position() = last()]];
//     }
//   }

//   // emit a label if there is one
//   if [Label] {
//     apply [Label];
//   }

// }

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "existence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
         ]
  ]
]
{
  $definiens = `preceding-sibling::Item[@kind = "Functor-Definition" and @shape = "Means"]/Definiens/*[position() = last()]`;
  $existential-variable = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "ExistenceLemma"; }
      $segments = `preceding-sibling::Item[@kind = "Loci-Declaration"]/Explicitly-Qualified-Segment`;
      $fd = `preceding-sibling::Item[@kind = "Functor-Definition" and @shape = "Means"]`;
      $type = `$fd/Operation-Functor-Pattern/Type-Specification/*[1]`;
      universally-bind-segments-existence (#segments   = $segments,
                                           #formula    = $definiens,
                                           #type       = $type,
					   #it         = $existential-variable);
    }
    apply [*[position() = last()]];
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "existence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 1
         ]
  ]
]
{
  $definiens = `preceding-sibling::Item[@kind = "Functor-Definition" and @shape = "Means"]/Definiens/*[position() = last()]`;
  $existential-variable = fresh-variable ();
  <Item {
    @kind = "Regular-Statement";
    @shape = "Diffuse-Statement";
    <Label { @spelling = "ExistenceLemma"; }
    <Block {
      @kind = "Now-Reasoning";
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {
        for-each [Item[@kind = "Loci-Declaration" or @kind = "Choice-Statement" or @kind = "Assumption"]] {
          choose {
            when [self::Item[@kind = "Loci-Declaration"]] {
              <Item { @kind = "Generalization"; apply [*]; }
            }
            otherwise {
              // nothing special to do; apply the default template
              apply [.];
            }
          }
        }
      }
      <Item {
        @kind = "Conclusion";
        @shape = "Compact-Statement";
        $fd = `preceding-sibling::Item[@kind = "Functor-Definition"]`;
        $formula = `$fd/Definiens/*[position() = last()]`;
        $type = `$fd/Type-Specification/*[1]`;
        <Proposition {
          <Existential-Quantifier-Formula {
            <Explicitly-Qualified-Segment {
              <Variables {
                <Variable { @spelling = $existential-variable; }
              }
              if [$type] {
                apply [$type];
              } else {
                <Standard-Type { @nr = "1"; @spelling = "set"; }
              }
            }
            apply [$formula] (#it = $existential-variable) mode="replace-it-term";
          }
        }
        apply [*[position() = last()]];
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "existence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and (count (preceding-sibling::Item[@kind = "Assumption"]) > 1)
         ]
  ]
]
{
  die (#message = "We do not yet handle existence conditions for functor definitions that have multiple assumtions.");
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "uniqueness"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
        ]
  ]
]
{
  $uniqueness-variable-1 = fresh-variable (#prefix = "A");
  $uniqueness-variable-2 = fresh-variable (#prefix = "B");
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "UniquenessLemma"; }
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {
        $locus = `Item[@kind = "Loci-Declaration"]`;
        $segments = `$locus/Explicitly-Qualified-Segment`;
        $fd = `Item[@kind = "Functor-Definition"]`;
        $formula = `$fd/Definiens/*[position() = last()]`;
        $type = `$fd/Type-Specification/*[1]`;
 $assumption = `Item[@kind = "Assumption"]/Single-Assumption/Proposition/*[position() = last()]`;
        universally-bind-segments-uniqueness
          (#segments   = $segments,
           #variable-1 = $uniqueness-variable-1,
           #variable-2 = $uniqueness-variable-2,
           #formula    = $formula,
           #type       = $type);
      }
    }

    // justification
    for-each [*[position() = last()]] {
      choose {
        when [self::Straightforward-Justification] {
          apply [.];
        }
        when [self::Block[@kind = "Proof"]] {
          <Block {
            for-each [@*] { copy-of `.`; }
            for-each [*] {
              if [self::Item[@kind = "Loci-Declaration"]] {
                <Item {
                  @kind = "Generalization";
                  apply [*];
                }
              } else {
                apply [.];
              }
            }
          }
        }
      }
    }

  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "uniqueness"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 1
        ]
  ]
]
{
  msg "hey assumption uniqueness";
  $uniqueness-variable-1 = fresh-variable (#prefix = "A");
  $uniqueness-variable-2 = fresh-variable (#prefix = "B");
  <Item {
    @kind = "Regular-Statement";
    @shape = "Diffuse-Statement";
    <Label { @spelling = "UniquenessLemma"; }
    <Block {
      @kind = "Now-Reasoning";
      for-each [ancestor::Block[@kind = "Definitional-Block"]] {
        for-each [Item[@kind = "Loci-Declaration" or @kind = "Choice-Statement" or @kind = "Assumption"]] {
          choose {
            when [self::Item[@kind = "Loci-Declaration"]] {
              <Item { @kind = "Generalization"; apply [*]; }

            }
            otherwise {
              // nothing special to do; apply the default template
              apply [.];
            }
          }
        }
      }
      <Item {
        @kind = "Conclusion";
        @shape = "Compact-Statement";
        $fd = `preceding-sibling::Item[@kind = "Functor-Definition"]`;
        $formula = `$fd/Definiens/*[position() = last()]`;
        $type = `$fd/Type-Specification/*[1]`;
        <Proposition {
          <Universal-Quantifier-Formula {
            <Explicitly-Qualified-Segment {
              <Variables {
                <Variable { @spelling = $uniqueness-variable-1; }
                <Variable { @spelling = $uniqueness-variable-2; }
              }
              if [$type] {
                apply [$type];
              } else {
                <Standard-Type { @nr = "1"; @spelling = "set"; }
              }
            }
            <Conditional-Formula {
              <Conjunctive-Formula {
                apply [$formula] (#it = $uniqueness-variable-1) mode="replace-it-term";
                apply [$formula] (#it = $uniqueness-variable-2) mode="replace-it-term";
              }
              <Predicative-Formula {
               @spelling = "=";
                <Arguments { <Simple-Term { @spelling = $uniqueness-variable-1; } }
                <Arguments { <Simple-Term { @spelling = $uniqueness-variable-2; } }
              }
            }
          }
        }
        apply [*[position() = last()]];
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "uniqueness"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) > 1
        ]
  ]
]
{
  die (#message = "We do not handle uniqueness conditions for functor definitions that have assumptions.");
}