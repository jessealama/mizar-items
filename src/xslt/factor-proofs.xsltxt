stylesheet "1.0";
import "utils/die.xsl";
import "fresh-variable.xsl";
output method="xml" indent="yes";

tpl emit-conjunction-of-attributive-adjectives (#term-name, #adjectives) {
  choose {
    when [count ($adjectives) = 0] {
      die (#message = "Error: zero adjectives were given.");
    }
    when [count ($adjectives) = 1] {
      $adjective = `$adjectives[1]`;
      <Attributive-Formula {
        <Simple-Term {
          @spelling = $term-name;
        }
        apply [$adjective];
      }
    }
    otherwise {
      $first-adjective = `$adjectives[1]`;
      $remaining-adjectives = `$adjectives[position () > 1]`;
      <Conjunctive-Formula {
        <Attributive-Formula {
          <Simple-Term {
            @spelling = $term-name;
          }
          apply [$first-adjective];
        }
        emit-conjunction-of-attributive-adjectives (#term-name = $term-name,
                                                    #adjectives = $remaining-adjectives);
      }
    }
  }
}

// By default, copy
tpl [*] {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

// Sanity check
tpl [Text-Proper] {
  if [descendant::Implicitly-Qualified-Segment] {
    die (#message = "There are not supposed to be any Implicitly-Qualified-Segments");
  } else {
    <Text-Proper {
      for-each [@*] { copy-of `.`; }
      apply [*];
    }
  }
}

tpl universally-bind-conjunction-of-adjectives (#adjectives,
                                                #it,
                                                #type,
                                                #segments) {
  $num-adjectives = `count ($adjectives)`;
  // msg `concat ($num-adjectives, " adjectives")`;
  if [count ($segments) = 0] {
    <Existential-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable {
            @spelling = $it;
          }
        }
        apply [$type];
      }
      emit-conjunction-of-attributive-adjectives (#term-name  = $it,
                                                  #adjectives = $adjectives);
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-conjunction-of-adjectives (#segments   = $rest,
                                                  #type       = $type,
                                                  #it         = $it,
                                                  #adjectives = $adjectives);
    }
  }
}

tpl
[
  Item
  [
        @kind = "Definition-Item"
    and Block
        [
              @kind = "Registration-Block"
          and Item
              [
                    @kind = "Cluster"
                and Existential-Registration
              ]
          and Item
              [
                    @kind = "Correctness-Condition"
                and Block[@kind = "Proof"]
              ]
        ]
 ]
] {
  // Emit a lemma before the condition
  $fresh-variable = fresh-variable (#prefix = "Z");
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label { @spelling = "Existence"; }
      for-each [Block[@kind = "Registration-Block"]] {
        $locus = `Item[@kind = "Loci-Declaration"]`;
        $segments = `$locus/Explicitly-Qualified-Segment`;
        $cluster = `Item[@kind = "Cluster"]`;
        $exreg = `$cluster/Existential-Registration`;
        $adcluster = `$exreg/Adjective-Cluster`;
        $type = `$exreg/*[position() = last()]`;
        $adjectives = `$adcluster/Adjective | $adcluster/NegatedAdjective`;
        universally-bind-conjunction-of-adjectives
          (#segments   = $segments,
           #type       = $type,
           #adjectives = $adjectives,
           #it         = $fresh-variable);
      }
    }
    <Block {
      @kind = "Proof";
      apply [Block[@kind = "Registration-Block"]
             /
             Item[@kind = "Correctness-Condition"
                  and @condition = "existence"]
             /
             Block[@kind = "Proof"]];
    }
  }
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl
[
  Block
  [
        @kind = "Proof"
    and parent::Item
        [
              @kind      = "Correctness-Condition"
          and @condition = "existence"
          and parent::Block
              [
                    @kind = "Registration-Block"
                and parent::Item
                    [
                          @kind = "Definition-Item"
                      and parent::Text-Proper
                    ]
              ]
        ]
  ]
]
{
  <Straightforward-Justification {
    <Local-Reference {
      @spelling = "Existence";
    }
  }
}

tpl universally-bind-segments (#segments, #it, #formula, #type) {
  if [count ($segments) = 0] {
    <Existential-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable {
            @spelling = $it;
          }
        }
        apply [$type];
      }
      apply [$formula] (#it = $it) mode="replace-it-term";
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments (#segments = $rest, #it = $it, #formula = $formula, #type = $type);
    }
  }
}

tpl universally-bind-segments-uniqueness (#segments,
                                                   #variable-1,
                                                   #variable-2,
                                                   #formula,
                                                   #type) {
  if [count ($segments) = 0] {
    <Universal-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        <Variables {
          <Variable { @spelling = $variable-1; }
          <Variable { @spelling = $variable-2; }
        }
        apply [$type];
      }
      <Conditional-Formula {
        <Conjunctive-Formula {
          apply [$formula] (#it = $variable-1) mode="replace-it-term";
          apply [$formula] (#it = $variable-2) mode="replace-it-term";
        }
        <Predicative-Formula {
          @spelling = "=";
          <Arguments { <Simple-Term { @spelling = $variable-1; } }
          <Arguments { <Simple-Term { @spelling = $variable-2; } }
        }
      }
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-uniqueness (#segments = $rest,
                                            #variable-1 = $variable-1,
                                            #variable-2 = $variable-2,
                                            #formula = $formula,
                                            #type = $type);
    }
  }
}

tpl universally-bind-segments-compatibility (#segments,
                                             #original-formula,
                                             #new-formula) {
  if [count ($segments) = 0] {
    <Biconditional-Formula {
      apply [$original-formula];
      apply [$new-formula];
    }
  } else {
    $segment = `$segments[1]`;
    $rest = `$segments[position() > 1]`;
    <Universal-Quantifier-Formula {
      apply [$segment];
      universally-bind-segments-compatibility
        (#segments         = $rest,
         #original-formula = $original-formula,
         #new-formula      = $new-formula);
    }
  }
}

tpl
[
  Item
  [
        @kind = "Correctness-Condition"
    and @condition = "existence"
    and preceding-sibling::Item
        [
              @kind = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) = 0
         ]
  ]
]
{
  for-each [ancestor::Item[parent::Text-Proper]] {
    $existential-variable = fresh-variable ();
    <Item {
      @kind = "Regular-Statement";
      @shape = "Compact-Statement";
      <Proposition {
        <Label { @spelling = "ExistenceLemma"; }
        for-each [Block] {
          $locus = `Item[@kind = "Loci-Declaration"]`;
          $segments = `$locus/Explicitly-Qualified-Segment`;
          $fd = `Item[@kind = "Functor-Definition"]`;
          $formula = `$fd/Definiens/*[position() = last()]`;
          $type = `$fd/Type-Specification/*[1]`;
          universally-bind-segments (#segments = $segments,
                                     #it       = $existential-variable,
                                     #formula  = $formula,
                                     #type     = $type);
        }
      }
      <Block {
        @kind = "Proof";
        for-each [Block[@kind = "Definitional-Block"]] {
          for-each [Item[@kind = "Loci-Declaration"]] {
            <Item {
              @kind = "Generalization";
              apply [Explicitly-Qualified-Segment];
            }
          }
          for-each [Item[@kind = "Correctness-Condition"
                         and @condition = "existence"]] {
            for-each [Block[@kind = "Proof"]] {
              apply [*];
            }
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind = "Correctness-Condition"
    and @condition = "existence"
    and preceding-sibling::Item
        [
              @kind = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"]) > 0
         ]
  ]
]
{
  die (#message = "We do not yet handle existence conditions for functor definitions that have assumtions.");
}

tpl
[
  Item
  [
        @kind = "Correctness-Condition"
    and @condition = "uniqueness"
    and preceding-sibling::Item
        [
              @kind = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"] = 0)
        ]
  ]
]
{
  $uniqueness-variable-1 = fresh-variable (#prefix = "A");
  $uniqueness-variable-2 = fresh-variable (#prefix = "B");
  for-each [ancestor::Item[parent::Text-Proper]] {
    <Item {
      @kind = "Regular-Statement";
      @shape = "Compact-Statement";
      <Proposition {
        <Label { @spelling = "UniquenessLemma"; }
        for-each [Block[@kind = "Definitional-Block"]] {
          $locus = `Item[@kind = "Loci-Declaration"]`;
          $segments = `$locus/Explicitly-Qualified-Segment`;
          $fd = `Item[@kind = "Functor-Definition"]`;
          $formula = `$fd/Definiens/*[position() = last()]`;
          $type = `$fd/Type-Specification/*[1]`;
          universally-bind-segments-uniqueness
            (#segments   = $segments,
             #variable-1 = $uniqueness-variable-1,
             #variable-2 = $uniqueness-variable-2,
             #formula    = $formula,
             #type       = $type);
        }
      }
      <Block {
        @kind = "Proof";
        for-each [Block[@kind = "Definitional-Block"]] {
          for-each [Item[@kind = "Loci-Declaration"]] {
            <Item {
              @kind = "Generalization";
              apply [Explicitly-Qualified-Segment];
            }
          }
          for-each [Item[    @kind      = "Correctness-Condition"
                         and @condition = "uniqueness"]] {
            for-each [Block[@kind = "Proof"]] {
              apply [*];
            }
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "uniqueness"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and count (preceding-sibling::Item[@kind = "Assumption"] > 0)
        ]
  ]
]
{
  die (#message = "We do not handle uniqueness conditions for functor definitions that have assumptions.");
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "compatibility"
    and preceding-sibling::Item
        [
              @kind = "Predicate-Definition"
          and Redefine]]] {
  for-each [ancestor::Item[parent::Text-Proper]] {
    <Item {
      @kind = "Regular-Statement";
      @shape = "Compact-Statement";
      <Proposition {
        <Label { @spelling = "CompatibilityLemma"; }
        for-each [Block[@kind = "Definitional-Block"]] {
         $locus = `Item[@kind = "Loci-Declaration"]`;
         $segments = `$locus/Explicitly-Qualified-Segment`;
         $pd = `Item[@kind = "Predicate-Definition"]`;
         $original-formula = `$pd/Predicate-Pattern`;
         $new-formula = `$pd/Definiens/*[position() = last()]`;
         universally-bind-segments-compatibility
           (#segments         = $segments,
            #original-formula = $original-formula,
            #new-formula      = $new-formula);
        }
      }
      <Block {
        @kind = "Proof";
        for-each [Block[@kind = "Definitional-Block"]] {
          for-each [Item[@kind = "Loci-Declaration"]] {
            <Item {
              @kind = "Generalization";
              apply [Explicitly-Qualified-Segment];
            }
          }
          for-each [Item[    @kind      = "Correctness-Condition"
                         and @condition = "compatibility"]] {
            for-each [Block[@kind = "Proof"]] {
              apply [*];
            }
          }
        }
      }
    }
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "coherence"
    and preceding-sibling::Item
        [
          @kind = "Functor-Definition"
        ]
  ]
]
{
  choose {
    when [Proof] {
      die (#message = "Don't know how to handle a coherence item justified by a proof.");
    }
    when [count (Straightforward-Justification/*) = 0] {
      // skip: this is obvious for the checker
    }
    when [count (Straightforward-Justification/*) = 1] {
      // skip: there's already a single lemma/theorem/scheme that
      // justifies this
    }
    otherwise {
      die (#message = "Don't know how to handle a coherence item justified by multiple items.");
    }
  }
}

tpl
[
  Item
  [
    @kind = "Definition-Item"
    and Block
        [
          @kind = "Definitional-Block"
          and Item
              [
                @kind = "Functor-Definition"
              ]
        ]
  ]
]
{
  for-each [Block[@kind = "Definitional-Block"]] {
    for-each [Item[@kind = "Correctness-Condition"]] {
      choose {
        when [@condition = "existence"] {
          apply [.];
        }
        when [@condition = "uniqueness"] {
          apply [.];
        }
        when [@condition = "coherence"] {
          apply [.];
        }
        otherwise {
          die (#message = "Unhandled correctness condition.");
        }
      }
    }
  }
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*] mode="straightforward-correctness";
  }
}

tpl
[
  Item
  [
        @kind      = "Correctness-Condition"
    and @condition = "coherence"
    and preceding-sibling::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
        ]
  ]
]
{
  die (#message = "We don't handle coherence conditions yet.");
}

tpl
[
  Item
  [
    @kind = "Definition-Item"
    and Block
        [
          @kind = "Definitional-Block"
          and Item
              [
                @kind = "Predicate-Definition"
              ]
        ]
  ]
]
{
  for-each [Block[@kind = "Definitional-Block"]] {
    for-each [Item[@kind = "Correctness-Condition"]] {
      $c = `@condition`;
      choose {
        when [$c = "compatibility"] {
          apply [.];
        }
        otherwise {
          die (#message = "Unhandled predicate correctness condition.");
        }
      }
    }
  }
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*] mode="straightforward-correctness";
  }
}

tpl [*] (#it) mode="replace-it-term" {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*] (#it = $it) mode="replace-it-term";
  }
}

tpl [it-Term] (#it) mode="replace-it-term" {
  <Simple-Term {
    @spelling = $it;
  }
}

tpl [*] (#it) mode="straightforward-correctness" {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*] (#it = $it) mode="straightforward-correctness";
  }
}

tpl
[
  Block
  [
        @kind = "Proof"
    and parent::Item
        [
          @kind = "Correctness-Condition"
        ]
  ]
]
mode="straightforward-correctness"
{
  $c = `parent::Item[@kind = "Correctness-Condition"]/@condition`;
  choose {
    when [$c = "existence"] {
      <Straightforward-Justification {
        <Local-Reference { @spelling = "ExistenceLemma"; }
      }
    }
    when [$c = "uniqueness"] {
      <Straightforward-Justification {
        <Local-Reference { @spelling = "UniquenessLemma"; }
      }
    }
    when [$c = "coherence"] {
      <Straightforward-Justification {
        <Local-Reference { @spelling = "CoherenceLemma"; }
      }
    }
    when [$c = "compatibility"] {
      <Straightforward-Justification {
        <Local-Reference { @spelling = "CompatibilityLemma"; }
      }
    }
    otherwise {
      die (#message = `concat ("Don't know how to handle a '", $c, "' correctness condition.")`);
    }
  }
}

// Rewriting definition block content

tpl
[
  Item [
           @kind = "Assumption"
       and parent::Block
           [
                 @kind = "Definitional-Block"
             and parent::Item
                 [
                   @kind = "Definition-Item"
                 ]
           ]
  ]
]
{
  // ignore: We'll take care of this later
}

tpl
[
  Item
  [
    @kind = "Choice-Statement"
    and parent::Block
        [
          @kind = "Definitional-Block"
          and parent::Item
              [
                @kind = "Definition-Item"
              ]
        ]
  ]
]
{
  // ignore: We'll take care of this later
}

tpl
[
  Definiens
  [
    @kind = "Simple-Definiens"
    and @shape = "Formula-Expression"
    and parent::Item
        [
          @kind = "Functor-Definition"
          and @shape = "Means"
          and preceding-sibling::Item
              [
                @kind = "Assumption"
                and not(Single-Assumption)
              ]
        ]
  ]
]
{
  die (#message = "Don't know how to handle non-Single-Assumption definitions.");
}

tpl
[
  Definiens
  [
    @kind = "Simple-Definiens"
    and @shape = "Formula-Expression"
    and parent::Item
        [
          @kind = "Functor-Definition"
          and @shape = "Means"
          and count(preceding-sibling::Item
                    [
                      @kind = "Assumption"
                      and Single-Assumption
                    ]) > 1
        ]
  ]
]
{
  die (#message = "Don't know how to handle multiple Single-Assumption definitions.");
}

tpl
[
  Definiens
  [
        @kind  = "Simple-Definiens"
    and @shape = "Formula-Expression"
    and parent::Item
        [
              @kind  = "Functor-Definition"
          and @shape = "Means"
          and preceding-sibling::Item
              [
                    @kind = "Assumption"
                and Single-Assumption
              ]
        ]
  ]
] {
  $definiens = `.`;
  <Definiens {
    @kind = "Simple-Definiens";
    @shape = "Formula-Expression";
    <Conditional-Formula {
      for-each [parent::Item[@kind = "Functor-Definition"
                             and @shape = "Means"]] {
        for-each [preceding-sibling::Item[@kind = "Assumption"
                                          and Single-Assumption]] {
          apply [Proposition];
        }
      }
      apply [*[position() = last()]];
    }
  }

  // emit a label if there is one
  if [Label] {
    apply [Label];
  }

}
