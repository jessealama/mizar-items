stylesheet "1.0";
import "utils/strings.xsl";
import "utils/list.xsl";
output method="text";

tpl [@*] {
  $attr = `name (.)`;
  $val = `string (.)`;
  " "; ":"; $attr; " "; "\""; $val; "\"";
}

tpl [@line] {
  // ignore
}

tpl [@col] {
  // ignore
}

tpl [@articleext] {
  // ignore
}

tpl [*] {
  $n = lc (#s = `name (.)`);
  "("; $n;
  for-each [@*] {
    apply [.];
  }
  if [*] {
    "\n";
    list (#separ = " ", #elems = `*`);
  }
  ")"; "\n";
}

tpl [Text-Proper] {
  "(text-proper ("; lc (#s = `@articleid`); ")"; "\n";
  list (#separ = "\n", #elems = `*`);
  ")"; "\n";
}

tpl [/] {
  if [Text-Proper] {
    apply [Text-Proper];
  } else {
    msg terminate="yes" "Error: the Text-Proper document element is missing.";
  }
}

tpl [Variables] {
  "("; list (#separ = " ", #elems = `*`); ")";
}

tpl [Item[@kind]] {
  $n = lc (#s = `@kind`);
  "("; $n;
  for-each [@*] {
    if [name(.) = "kind"] {
      // ignore
    } else {
      apply [.];
    }
  }
  if [*] {
    "\n";
    apply [*];
  }
  ")"; "\n";
}

tpl [Block[@kind = "Proof"]] {
  "(proof"; "\n"; list (#separ = "\n", #elems = `*`); ")"; "\n";
}

tpl [Block[@kind = "Suppose"]] {
  "(suppose-block ";
  for-each [Item[@kind = "Suppose-Head"]] {
    choose {
      when [Single-Assumption] {
        for-each [Single-Assumption] {
          "("; apply [Proposition]; ")";
        }
      }
      when [Collective-Assumption] {
        for-each [Collective-Assumption] {
          for-each [Conditions] {
            "("; list (#separ = "\n", #elems = `*`); ")";
          }
        }
      }
      otherwise {
        msg terminate="yes" "Don't know how to handle a Suppose-Block item.";
      }
    }
    " "; list (#separ = "\n", #elems = `following-sibling::*`);
  }
  ")";
}

tpl [Item[@kind = "Scheme-Block-Item"]] {
  apply [Block[@kind = "Scheme-Block"]];
}

tpl [Block[@kind = "Scheme-Block"]] {
  for-each [Item[@kind = "Scheme-Head"]] {
    "(scheme ";
    apply [Scheme];
    " ";
    for-each [Schematic-Variables] {
      apply [.];
      " "; apply [following-sibling::*[1]];
    }
    if [Provisional-Formulas] {
      apply [Provisional-Formulas];
    } else {
      "()";
    }
  }
  " ";
  "(proof "; "\n"; list (#separ = "\n", #elems = `following-sibling::*`); ")";
  ")";
}

tpl [Provisional-Formulas] {
  "("; list (#separ = "\n", #elems = `*`); ")";
}

tpl [Scheme] {
  `@spelling`;
}

tpl [Schematic-Variables] {
  "("; list (#separ = " ", #elems = `*`); ")";
}

tpl [Functor-Segment] {
  "(functor-segment "; apply [Variables]; " "; apply [Type-List]; " "; apply [Type-Specification]; ")";
}

tpl [Type-Specification] {
  apply [*[1]];
}

tpl [Type-List] {
  "("; list (#separ = " ", #elems = `*`); ")";
}

tpl [Placeholder-Term] {
  `@spelling`;
}

tpl [Arguments] {
  "("; apply [*]; ")";
}

tpl [Simple-Term] {
  `@spelling`;
}

tpl [Variable] {
  `@spelling`;
}

tpl [Predicative-Formula] {
  "(predicative-formula "; `@spelling`; if [count(*) > 0] { " "; list (#separ = " ", #elems = `*`); } ")";
}

tpl [Infix-Term] {
  "(infix-term "; `@spelling`; " "; apply [*[1]]; " "; apply [*[2]]; ")";
}

tpl [Circumfix-Term] {
  "(circumfix-term "; `@spelling`; " "; list (#separ = " ", #elems = `*`); ")";
}

tpl [Right-Circumflex-Symbol] {
  `@spelling`;
}

tpl [Private-Predicate-Formula] {
  "(private-predicate-formula "; `@spelling`; if [count(*) > 0] { " "; list (#separ = " ", #elems = `*`); } ")";
}

tpl [Private-Functor-Term] {
  "(private-functor-term "; `@spelling`; if [*] { " "; list (#separ = " ", #elems = `*`); } ")";
}

tpl [Proposition[Label]] {
  "(proposition "; apply [Label]; " "; apply [*[not(self::Label)]]; ")";
}

tpl [Proposition[not(Label)]] {
  "(proposition nil "; apply [*]; ")";
}

tpl [Label] {
  `@spelling`;
}

tpl [Conjunctive-Formula] {
  "(∧ "; apply [*[1]]; " "; apply [*[2]]; ")";
}

tpl [Disjunctive-Formula] {
  "(∨ "; apply [*[1]]; " "; apply [*[2]]; ")";
}

tpl [Biconditional-Formula] {
  "(iff "; apply [*[1]]; " "; apply [*[2]]; ")";
}

tpl [Conditional-Formula] {
  "(→ "; apply [*[1]]; " "; apply [*[2]]; ")";
}

tpl [Negated-Formula] {
  "(¬ "; apply [*[1]]; ")";
}

tpl [Local-Reference] {
  `@spelling`;
}

tpl [Definition-Reference] {
  "(definition-reference "; `@spelling`; " "; `@nr`; ")";
}

tpl [Theorem-Reference] {
  "(theorem-reference "; `@spelling`; " "; `@nr`; ")";
}

tpl [Thesis] {
  "thesis";
}

tpl [Item[@kind = "Reservation"]] {
  "(reserve "; apply [Variables]; " "; apply [*[position() = last()]]; ")";
}

tpl [Item[@kind = "Property"]] {
  "("; `@property`; if [*] { " "; list (#separ = " ", #elems = `*`); } ")";
}

tpl [Item[@kind = "Correctness-Condition"]] {
  "("; `@condition`; if [*] { " "; list (#separ = " ", #elems = `*`); } ")";
}

tpl [Item[@kind = "Correctness"]] {
  $justification = `*[position() = last()]`;
  for-each [Conditions] {
    for-each [Correctness] {
      "("; `@condition`; " "; apply [$justification]; ")";
    }
  }
}

tpl [Global-Choice-Term] {
  "(the "; list (#separ = " ", #elems = `*`); ")";
}

tpl [Standard-Type] {
  "(standard-type "; `@spelling`; if [*] { list (#separ = " ", #elems = `*`); } ")";
}

tpl variable-segments (#segments) {
  if [$segments] {
    $segment = `$segments[1]`;
    $more-segments = `$segments[position() > 1]`;
    for-each [$segment] {
      choose {
        when [self::Implicitly-Qualified-Segment] {
          list (#separ = " ", #elems = `Variable`);
        }
        when [self::Explicitly-Qualified-Segment] {
          $type = `*[position() = last()]`;
          for-each [Variables] {
            for-each [*] {
              "("; apply [.]; " "; apply [$type]; ")";
            }
            if [position() < last()] {
              " ";
            }
          }
        }
      }
    }
  }
}

tpl [Existential-Quantifier-Formula] {
  "(∃ "; "("; variable-segments (#segments = `*[position() < last()]`); ") "; apply [*[position() = last()]]; ")";
}

tpl [Universal-Quantifier-Formula] {
  "(∀ "; "("; variable-segments (#segments = `*[position() < last()]`); ") "; apply [*[position() = last()]]; ")";
}

tpl [Item[@kind = "Regular-Statement" and @shape = "Compact-Statement"]] {
  "(regular-statement "; apply [*[1]]; " "; apply [*[2]]; ")";
}

tpl [Item[@kind = "Regular-Statement" and @shape = "Diffuse-Statement"]] {
  "(diffuse-statement "; list (#separ = "\n", #elems = `Block[@kind = "Now-Reasoning"]/*`); ")";
}

tpl [Item[@kind = "Choice-Statement"]] {
  "(consider "; "("; variable-segments (#segments = `Implicitly-Qualified-Segment | Explicitly-Qualified-Segment`); ") "; "("; list (#separ = " ", #elems = `Conditions/*`); ") "; apply [*[position() = last()]]; ")";
}

tpl [Scheme-Justification[@nr = "0"]] {
  "(internal-scheme-justification "; `@spelling`; if [*] { list (#separ = " ", #elems = `*`); } ")";
}

tpl [Scheme-Justification[not(@nr = "0")]] {
  "(external-scheme-justification "; `@spelling`; " "; `@nr`; " "; if [*] { list (#separ = " ", #elems = `*`); } ")";
}

tpl [Item[@kind = "Exemplification"]] {
  "(take "; list (#separ = " ", #elems = `*`); ")";
}

tpl [Item[@kind = "Generalization"]] {
  "(generalization "; variable-segments (#segments = `Implicitly-Qualified-Segment | Explicitly-Qualified-Segment`); ")";
}

tpl [Item[@kind = "Loci-Declaration"]] {
  "(loci-declaration "; variable-segments (#segments = `Implicitly-Qualified-Segment | Explicitly-Qualified-Segment`); ")";
}

tpl [Item[@kind = "Conclusion" and @shape = "Compact-Statement"]] {
  "(thus "; apply [*[1]]; " "; apply [*[2]]; ")";
}

tpl [Item[@kind = "Conclusion" and @shape = "Diffuse-Statement"]] {
  "(thus-diffuse "; apply [*[1]]; ")";
}

tpl [Item[@kind = "Conclusion" and @shape = "Iterative-Equality"]] {
  "(thus (iterative-equality ";
  for-each [Proposition] {
    apply [.];
    " "; apply [following-sibling::*[1]];
  }
  for-each [Iterative-Step] {
    " "; apply [*[1]]; " "; apply [*[2]];
  }
  "))";
}

tpl [Item[@kind = "Definition-Item"]] {
  apply [Block[@kind = "Definitional-Block"]];
}

tpl [Block[@kind = "Definitional-Block"]] {
  "(definitional-block "; list (#separ = " ", #elems = `*`); ")";
}

tpl [Block[@kind = "Hereby-Reasoning"]] {
  "(hereby "; list (#separ = "\n", #elems = `*`); ")";
}

tpl [Item[@kind = "Attribute-Definition"]] {
  "(attribute-definition "; apply [Attribute-Pattern]; " "; apply [Definiens/Label]; " "; apply [Definiens/*[position() = last()]]; ")";
}

tpl [Attribute-Pattern] {
  `@spelling`;
}

tpl [Straightforward-Justification] {
  "(straightforward-justification ";
  if [Link] {
    "t";
  } else {
    "nil";
  }
  if [*] {
    " "; list (#elems = `*`, #separ = " ");
  }
  ")";
}

tpl [Link] {
  ""; // links are accounted for elsewhere
}

tpl [Item[@kind = "Functor-Definition"]] {
  "(functor-definition ";
  if [@shape = "Equals"] {
    "term";
  } else {
    "formula";
  }
  " "; apply [Operation-Functor-Pattern | Bracket-Functor-Pattern];
  " ";
  for-each [Definiens] {
    if [Label] {
      apply [Label];
    } else {
      "nil";
    }
    " ";
    apply [.];
  }
  ")";
}

tpl [Item[@kind = "Predicate-Definition"]] {
  "(predicate-definition ";
  apply [Predicate-Pattern];
  " ";
  for-each [Definiens] {
    if [Label] {
      apply [Label];
    } else {
      "nil";
    }
    " ";
    apply [.];
  }
  ")";
}

tpl [Operation-Functor-Pattern] {
  "(operation-functor-pattern "; `@spelling`; " "; apply [*[1]]; " "; apply [*[2]]; ")";
}

tpl [Bracket-Functor-Pattern] {
  "(bracket-functor-pattern "; `@spelling`; " "; apply [Right-Circumflex-Symbol]; " "; list (#separ = " ", #elems = `Loci/*`); ")";
}

tpl [Predicate-Pattern] {
  "(predicate-pattern "; `@spelling`; " "; apply [*[1]]; " "; apply [*[2]]; ")";
}

tpl [Definiens] {
  apply [*[position() = last()]];
}

tpl [Adjective-Cluster] {
  "(adjective-cluster "; list (#separ = " ", #elems = `*`); ")";
}

tpl [Adjective] {
  "(adjective "; `@spelling`; ")";
}

tpl [NegatedAdjective] {
  "(negated-adjective "; `Adjective/@spelling`; ")";
}

tpl [Locus] {
  `@spelling`;
}

tpl [it-Term] {
  "it";
}
