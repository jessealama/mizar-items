stylesheet "1.0";
import "utils/strings.xsl";
import "utils/list.xsl";
output method="text";

tpl [@*] {
  $attr = `name (.)`;
  $val = `string (.)`;
  " "; ":"; $attr; " "; "\""; $val; "\"";
}

tpl [@line] {
  // ignore
}

tpl [@col] {
  // ignore
}

tpl [@articleext] {
  // ignore
}

tpl [*] {
  $n = lc (#s = `name (.)`);
  "("; $n;
  for-each [@*] {
    apply [.];
  }
  if [*] {
    "\n";
    list (#separ = " ", #elems = `*`);
  }
  ")"; "\n";
}

tpl [Text-Proper] {
  "(text-proper ("; lc (#s = `@articleid`); ")"; "\n";
  list (#separ = "\n", #elems = `*`);
  ")"; "\n";
}

tpl [/] {
  if [Text-Proper] {
    apply [Text-Proper];
  } else {
    msg terminate="yes" "Error: the Text-Proper document element is missing.";
  }
}

tpl [Variables] {
  "("; list (#separ = " ", #elems = `*`); ")";
}

tpl [Item[@kind]] {
  $n = lc (#s = `@kind`);
  "("; $n;
  for-each [@*] {
    if [name(.) = "kind"] {
      // ignore
    } else {
      apply [.];
    }
  }
  if [*] {
    "\n";
    apply [*];
  }
  ")"; "\n";
}

// tpl [Block] {
//   apply [*];
// }

tpl [Block[@kind = "Proof"]] {
  "(proof"; "\n"; list (#separ = "\n", #elems = `*`); ")"; "\n";
}

tpl [Item[@kind = "Scheme-Block-Item"]] {
  apply [Block[@kind = "Scheme-Block"]];
}

tpl [Block[@kind = "Scheme-Block"]] {
  for-each [Item[@kind = "Scheme-Head"]] {
    "(scheme ";
    apply [Scheme]; " ";
    if [Schematic-Variables] { apply [Schematic-Variables]; } else { "nil"; } "\n";
    "  "; apply [*[position() = last()]]; "\n";
  }
  "  "; if [Provisional-Formulas] { apply [Provisional-Formulas]; } else { "nil"; } "\n";
  for-each [Item[@kind = "Scheme-Head"]] {
    list (#separ = "\n", #elems = `following-sibling::*`);
  }
}

tpl [Scheme] {
  `@spelling`;
}

tpl [Schematic-Variables] {
  "("; list (#separ = " ", #elems = `*`); ")";
}

tpl [Functor-Segment] {
  "(functor-segment "; apply [Variables]; " "; apply [Type-List]; " "; apply [Type-Specification]; ")";
}

tpl [Type-Specification] {
  apply [*[1]];
}

tpl [Type-List] {
  "("; list (#separ = " ", #elems = `*`); ")";
}

tpl [Placeholder-Term] {
  `@spelling`;
}

tpl [Arguments] {
  "("; apply [*]; ")";
}

tpl [Simple-Term] {
  `@spelling`;
}

tpl [Variable] {
  `@spelling`;
}

tpl [Predicative-Formula] {
  "(predicative-formula "; `@spelling`; if [count(*) > 0] { " "; list (#separ = " ", #elems = `*`); } ")";
}

tpl [Private-Predicate-Formula] {
  "(private-predicate-formula "; `@spelling`; if [count(*) > 0] { " "; list (#separ = " ", #elems = `*`); } ")";
}

tpl [Private-Functor-Term] {
  "(private-functor-term "; `@spelling`; if [*] { " "; list (#separ = " ", #elems = `*`); } ")";
}

tpl [Proposition[Label]] {
  "(proposition "; apply [Label]; " "; apply [*[not(self::Label)]]; ")";
}

tpl [Proposition[not(Label)]] {
  "(proposition nil "; apply [*]; ")";
}

tpl [Label] {
  `@spelling`;
}

tpl [Biconditional-Formula] {
  "(iff "; apply [*[1]]; " "; apply [*[2]]; ")";
}

tpl [Conditional-Formula] {
  "(→ "; apply [*[1]]; " "; apply [*[2]]; ")";
}

tpl [Negated-Formula] {
  "(¬ "; apply [*[1]]; ")";
}

tpl [Local-Reference] {
  `@spelling`;
}

tpl [Thesis] {
  "thesis";
}

tpl [Item[@kind = "Reservation"]] {
  "(reserve "; apply [Variables]; " "; apply [*[position() = last()]]; ")";
}

tpl [Item[@kind = "Property"]] {
  "("; `@property`; if [*] { " "; list (#separ = " ", #elems = `*`); } ")";
}

tpl [Item[@kind = "Correctness-Condition"]] {
  "("; `@condition`; if [*] { " "; list (#separ = " ", #elems = `*`); } ")";
}

tpl [Global-Choice-Term] {
  "(the "; list (#separ = " ", #elems = `*`); ")";
}

tpl [Standard-Type] {
  "(standard-type "; `@spelling`; if [*] { list (#separ = " ", #elems = `*`); } ")";
}

tpl variable-segments (#segments) {
  if [$segments] {
    $segment = `$segments[1]`;
    $more-segments = `$segments[position() > 1]`;
    for-each [$segment] {
      choose {
        when [self::Implicitly-Qualified-Segment] {
          list (#separ = " ", #elems = `Variable`);
        }
        when [self::Explicitly-Qualified-Segment] {
          $type = `*[position() = last()]`;
          for-each [Variables] {
            for-each [*] {
              "("; apply [.]; " "; apply [$type]; ")";
            }
            if [position() < last()] {
              " ";
            }
          }
        }
      }
    }
  }
}

tpl [Existential-Quantifier-Formula] {
  "(∃ "; "("; variable-segments (#segments = `*[position() < last()]`); ") "; apply [*[position() = last()]]; ")";
}

tpl [Universal-Quantifier-Formula] {
  "(∀ "; "("; variable-segments (#segments = `*[position() < last()]`); ") "; apply [*[position() = last()]]; ")";
}

tpl [Item[@kind = "Regular-Statement" and @shape = "Compact-Statement"]] {
  "(regular-statement "; apply [*[1]]; " "; apply [*[2]]; ")";
}

tpl [Item[@kind = "Choice-Statement"]] {
  "(consider "; "("; variable-segments (#segments = `Implicitly-Qualified-Segment | Explicitly-Qualified-Segment`); ") "; "("; list (#separ = " ", #elems = `Conditions/*`); ") "; apply [*[position() = last()]]; ")";
}

tpl [Scheme-Justification[@nr = "0"]] {
  "(internal-scheme-justification "; `@spelling`; if [*] { list (#separ = " ", #elems = `*`); } ")";
}

tpl [Scheme-Justification[not(@nr = "0")]] {
  "(external-scheme-justification "; `@spelling`; " "; `@nr`; " "; if [*] { list (#separ = " ", #elems = `*`); } ")";
}

tpl [Item[@kind = "Exemplification"]] {
  "(take "; list (#separ = " ", #elems = `*`); ")";
}

tpl [Item[@kind = "Generalization"]] {
  "(generalization "; variable-segments (#segments = `Implicitly-Qualified-Segment | Explicitly-Qualified-Segment`); ")";
}

tpl [Item[@kind = "Loci-Declaration"]] {
  "(loci-declaration "; variable-segments (#segments = `Implicitly-Qualified-Segment | Explicitly-Qualified-Segment`); ")";
}

tpl [Item[@kind = "Conclusion"]] {
  "(thus "; apply [*[1]]; " "; apply [*[2]]; ")";
}

tpl [Item[@kind = "Definition-Item"]] {
  apply [Block[@kind = "Definitional-Block"]];
}

tpl [Block[@kind = "Definitional-Block"]] {
  "(definitional-block "; list (#separ = " ", #elems = `*`); ")";
}

tpl [Item[@kind = "Attribute-Definition"]] {
  "(attribute-definition "; apply [Attribute-Pattern]; " "; apply [Definiens/Label]; " "; apply [Definiens/*[position() = last()]]; ")";
}

tpl [Attribute-Pattern] {
  `@spelling`;
}