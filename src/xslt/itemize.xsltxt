stylesheet "1.0";
import "utils/die.xsl";
import "tokens.xsl";
output method="xml" indent="yes";

tpl count-previous ()
{
  for-each [ancestor-or-self::*[parent::Text-Proper]] {
    `count (preceding-sibling::*[not(self::Item[@kind = "Pragma" or @kind = "Section-Pragma"])])`;
  }
}

tpl position-in-text ()
{
  $prev = count-previous ();
  `$prev + 1`;
}

tpl [*] {
  $element = `local-name ()`;
  <$element {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl [/] {
  apply [Text-Proper];
}

tpl [Text-Proper[not(@articleid)]] {
  die (#message = "The Text-Proper element lacks an articleid attribute.");
}

tpl [Text-Proper[@articleid]] {
  $num-items = `count (*[not(self::Item[@kind = "Pragma"])])`;
  // msg `concat ("Number of items: ", $num-items)`;
  <Fragments {
    @articleid = `@articleid`;
    for-each [*[not(self::Item[@kind = "Pragma"])]] {
      <Text-Proper {
        @fragment-number = position-in-text ();
        <Item { @kind = "Section-Pragma"; }
        if [preceding-sibling::*[1][self::Item[@kind = "Pragma"]]] {
          apply [preceding-sibling::*[1]];
        }
        apply [.];
      }
    }
  }
}

tpl [Text-Proper/*/Straightforward-Justification/Link] {
  die (#message = "We assume that toplevel linking justifications have been removed, but we found one!");
}

//////////////////////////////////////////////////////////////////////
// Resolving article-local references
//////////////////////////////////////////////////////////////////////

tpl [Scheme-Justification[@idnr and @nr = "0"]] {
  $context = `.`;
  $idnr = `@idnr`;
  for-each [ancestor::Item[parent::Text-Proper]] {
    if [$idnr = preceding-sibling::Item[@kind = "Scheme-Block-Item"]/Block[@kind = "Scheme-Block"]/Item[@kind = "Scheme-Head"]/Scheme[@idnr]/@idnr] {
      for-each [preceding-sibling::Item[@kind = "Scheme-Block-Item" and descendant::Scheme[@idnr = $idnr]][1]] {
        $position = position-in-text ();
        $spelling = `concat ("CKB", $position)`;
        <Scheme-Justification {
          @spelling = $spelling;
          @idnr = "1";
          @nr = "1"; // might not be right
          @promoted = "promoted";
          apply [`$context/*`];
        }
      }
    } else {
      die (#message = "Unable to resolve an article-local Scheme-Justification");
    }
  }
}

tpl [Theorem-Reference[ancestor::Item[parent::Text-Proper and @kind = "Type-Changing-Statement" and preceding-sibling::Item[1][@promotable = "yes"]]]] {
  for-each [ancestor::Item[parent::Text-Proper]] {
    $num-previous = position-in-text ();
    $new_spelling = `concat ("CKB", $num-previous)`;
    <Theorem-Reference {
      @spelling = $new_spelling;
      @promoted = "promoted";
      @"number" = "1";
    }
  }
}

tpl [Scheme-Reference[ancestor::Item[parent::Text-Proper and @kind = "Type-Changing-Statement" and preceding-sibling::Item[1][@promotable = "yes"]]]] {
  for-each [ancestor::Item[parent::Text-Proper]] {
    $num-previous = position-in-text ();
    $new_spelling = `concat ("CKB", $num-previous)`;
    <Theorem-Reference {
      @spelling = $new_spelling;
      @promoted = "promoted";
      @"number" = "1";
    }
  }
}

tpl [Definition-Reference[ancestor::Item[parent::Text-Proper and @kind = "Type-Changing-Statement" and preceding-sibling::Item[1][@promotable = "yes"]]]] {
  for-each [ancestor::Item[parent::Text-Proper]] {
    $num-previous = position-in-text ();
    $new_spelling = `concat ("CKB", $num-previous)`;
    <Theorem-Reference {
      @spelling = $new_spelling;
      @promoted = "promoted";
      @"number" = "1";
    }
  }
}

tpl [Local-Reference[not(@idnr)]] {
  apply [.] (#message = "We found a Local-Reference that lacks an idnr attribute.") mode="die";
}

tpl [Local-Reference[@idnr = preceding::*[parent::Text-Proper]/Proposition/Label/@idnr]]
{
  $idnr = `@idnr`;
  for-each [ancestor::*[parent::Text-Proper]] {
    for-each [preceding-sibling::*[Proposition/Label[@idnr = $idnr]][1]] {
      $pos = position-in-text ();
      <Theorem-Reference {
        @spelling = `concat ("CKB", $pos)`;
        @"number" = "1";
      }
    }
  }
}

tpl [Local-Reference[@idnr = preceding::*[parent::Text-Proper]/Block/Item/Definiens/Label/@idnr]]
{
  $idnr = `@idnr`;
  for-each [ancestor::*[parent::Text-Proper]] {
    for-each [preceding-sibling::Item[Block/Item/Definiens/Label[@idnr = $idnr]][1]] {
      $pos = position-in-text ();
      <Definition-Reference {
        @spelling = `concat ("CKB", $pos)`;
        @"number" = "1";
      }
    }
  }
}

// tpl [Local-Reference[@idnr]] {
//   $context = `.`;
//   $idnr = `@idnr`;
//   for-each [ancestor::Item[parent::Text-Proper]] {
//     choose {
//       when [$idnr = preceding-sibling::Item[@kind = "Regular-Statement"
//                                             and @shape = "Compact-Statement"
//                                             and @exportable = "yes"]/Proposition/Label[@idnr]/@idnr] {
//         for-each [preceding-sibling::Item[@kind = "Regular-Statement"
//                                           and @shape = "Compact-Statement"
//                                           and @exportable = "yes"
//                                           and Proposition/Label[@idnr = $idnr]][1]] {
//           $num-previous = `count (preceding-sibling::Item)`;
//           $position = `$num-previous + 1`;
//           $new_spelling = `concat ("CKB", $position)`;
//           <Theorem-Reference {
//             @spelling = $new_spelling;
//             @promoted = "promoted";
//             @"number" = "1";
//           }
//         }
//       }
//       when [$idnr = preceding-sibling::Item[parent::Text-Proper
//                                             and @kind = "Theorem-Item"]/Proposition/Label[@idnr]/@idnr] {
//         for-each [preceding-sibling::Item[@kind = "Theorem-Item" and Proposition/Label[@idnr = $idnr]]] {
//           $num-previous = `count (preceding-sibling::Item)`;
//           $position = `$num-previous + 1`;
//           $new_spelling = `concat ("CKB", $position)`;
//           <Theorem-Reference {
//             @spelling = $new_spelling;
//             @promoted = "promoted";
//             @"number" = "1";
//           }
//         }
//       }
//       when [$idnr = preceding-sibling::Item[@kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Functor-Definition"
//                                                                                                                 or @kind = "Attribute-Definition"
//                                                                                                                 or @kind = "Predicate-Definition"
//                                                                                                                 or @kind = "Structure-Definition"]/Definiens/Label[@idnr]/@idnr] {

//         for-each [preceding-sibling::Item[@kind = "Definition-Item" and Block[@kind = "Definitional-Block"]/Item[@kind = "Functor-Definition"
//                                                                                                                  or @kind = "Attribute-Definition"
//                                                                                                                  or @kind = "Predicate-Definition"
//                                                                                                                  or @kind = "Structure-Definition"]/Definiens/Label[@idnr = $idnr]]] {
//           $num-previous = `count (preceding-sibling::Item)`;
//           $position = `$num-previous + 1`;
//           $new_spelling = `concat ("CKB", $position)`;
//           <Definition-Reference {
//             @spelling = $new_spelling;
//             @promoted = "promoted";
//             @"number" = "1";
//           }
//         }
//       }
//       when [$idnr = preceding-sibling::Item[@kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Mode-Definition"]/*/Definiens/Label/@idnr] {
//         for-each [preceding-sibling::Item[@kind = "Definition-Item" and Block[@kind = "Definitional-Block"]/Item[@kind = "Mode-Definition"]/*/Definiens/Label[@idnr = $idnr]]] {
//           $num-previous = `count (preceding-sibling::Item)`;
//           $position = `$num-previous + 1`;
//           $new_spelling = `concat ("CKB", $position)`;
//           <Definition-Reference {
//             @spelling = $new_spelling;
//             @promoted = "promoted";
//             @"number" = "1";
//           }
//         }
//       }
//       otherwise {
//         copy-of `$context`;
//       }
//     }
//   }
// }
