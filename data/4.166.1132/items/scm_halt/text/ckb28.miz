environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMFSA_2,FSM_1,SCMFSA6A,TARSKI,CIRCUIT2,RELAT_1,FUNCT_1,CARD_1,FUNCOP_1,FUNCT_4,XBOOLE_0,SCMFSA6B,NAT_1,XXREAL_0,ARYTM_3,AMI_3,SF_MASTR,GRAPHSP,MSUALG_1,AMISTD_2,TURING_1,STRUCT_0,VALUED_1,SCMFSA6C,SCMFSA7B,UNIALG_2,SCMFSA8B,ARYTM_1,SCMFSA8C,SCMFSA8A,SCM_HALT,PARTFUN1,SCMNORM,RELOC,COMPOS_1;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,RELAT_1,FINSEQ_1,FUNCT_1,PARTFUN1,FUNCT_4,FUNCT_7,PBOOLE,VALUED_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,FUNCOP_1,SCMFSA6B,SCMFSA6A,SF_MASTR,SCMFSA8A,SCMFSA8B,SFMASTR1,SCMFSA8C,SCMFSA7B,NAT_D,SCMFSA_3,SCMFSA6C,XXREAL_0,CKB1,CKB2,CKB3;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,XBOOLE_0,SCMFSA_2,SCMFSA8C,SCMFSA6A,AMISTD_2,SCMFSA7B,MEMSTR_0,CKB1,CKB2,CKB3;
theorems SF_MASTR,FUNCT_1,FUNCT_7,FUNCOP_1,RELAT_1,SCMFSA6A,FUNCT_4,ENUMSET1,AMI_3,NAT_1,TARSKI,INT_1,GRFUNC_1,SCMFSA_2,SCMFSA6B,SCMFSA7B,SCMFSA8B,SCMFSA8A,SCMFSA8C,SCMFSA_3,SCMFSA6C,CARD_1,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,XXREAL_0,VALUED_1,XREAL_0,PBOOLE,PARTFUN1,AFINSQ_1,FINSEQ_4,COMPOS_1,SFMASTR1,EXTPRO_1,AMISTD_2,AMISTD_5,ZFMISC_1,MEMSTR_0,AMISTD_1,STRUCT_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB7,CKB13,CKB14,CKB16,CKB17,CKB18,CKB21,CKB23,CKB24,CKB25,CKB26,CKB27;
schemes NAT_1;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8C,SCMFSA_9,ORDINAL1,RELAT_1,SCMFSA10,AMISTD_2,COMPOS_1,SFMASTR1,EXTPRO_1,SCMFSA_4,PBOOLE,FUNCT_4,FUNCT_7,PRE_POLY,STRUCT_0,FUNCOP_1,MEMSTR_0,CKB6,CKB8,CKB9,CKB10,CKB11,CKB12,CKB15,CKB19,CKB20,CKB22;
constructors SFMASTR1,DOMAIN_1,XXREAL_0,REAL_1,SCM_1,SCMFSA_3,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA8C,AMISTD_1,AMISTD_2,NAT_D,RELSET_1,VALUED_1,SCMFSA7B,SCMFSA_9,AMISTD_5,PBOOLE,PRE_POLY,MEMSTR_0,CKB1,CKB2,CKB3;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve I for (Program of ( SCM+FSA ));
reserve s for (State of ( SCM+FSA ));
reserve p for (Instruction-Sequence of ( SCM+FSA ));
set iS = ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) );
reconsider EP = ( {} ) as (PartState of ( SCM+FSA )) by FUNCT_1:104,RELAT_1:171;
diS: ( dom iS ) = ( ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) \/ ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) ) by FUNCT_4:def 1
.= ( { ( intloc ( 0 ) ) } \/ ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) ) by FUNCOP_1:13
.= ( { ( intloc ( 0 ) ) } \/ { ( IC ( SCM+FSA ) ) } ) by FUNCOP_1:13;
theorem
Th25: (for I being  keepInt0_1  InitHalting (Program of ( SCM+FSA )) holds (for J being  InitHalting (Program of ( SCM+FSA )) holds (for s being (State of ( SCM+FSA )) holds ((( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= s & ( I ';' J ) c= p) implies ((((((( IC ( Comput (p,s,( ( LifeSpan (( p +* I ),s) ) + 1 )) ) ) = ( card I ) & ( DataPart ( Comput (p,s,( ( LifeSpan (( p +* I ),s) ) + 1 )) ) ) = ( DataPart ( ( Comput (( p +* I ),s,( LifeSpan (( p +* I ),s) )) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) )) & ( Reloc (J,( card I )) ) c= p) & ( ( Comput (p,s,( ( LifeSpan (( p +* I ),s) ) + 1 )) ) . ( intloc ( 0 ) ) ) = 1) & p halts_on s) & ( LifeSpan (p,s) ) = ( ( ( LifeSpan (( p +* I ),s) ) + 1 ) + ( LifeSpan (( ( p +* I ) +* J ),( ( Result (( p +* I ),s) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) )) & (J is  keeping_0 implies ( ( Result (p,s) ) . ( intloc ( 0 ) ) ) = 1))))))
proof
set D = ( Data-Locations ( SCM+FSA ) );
let I being  keepInt0_1  InitHalting (Program of ( SCM+FSA ));
let J being  InitHalting (Program of ( SCM+FSA ));
let s being (State of ( SCM+FSA ));
set s1 = ( s +* EP );
set p1 = ( p +* I );
set s3 = ( ( Comput (p1,s,( LifeSpan (p1,s) )) ) +* iS );
set p3 = ( p1 +* J );
set m1 = ( LifeSpan (p1,s) );
set m3 = ( LifeSpan (p3,s3) );
A2: J c= p3 by FUNCT_4:25;
assume A3: iS c= s;
then A4: s = ( Initialized s ) by FUNCT_4:98;
assume A5: ( I ';' J ) c= p;
then A6: ( p +* ( I ';' J ) ) = p by FUNCT_4:98;
A7: I c= p1 by FUNCT_4:25;
set s4 = ( Comput (p,s,( m1 + 1 )) );
set p4 = p;
B9: ( Directed I ) c= ( I ';' J ) by SCMFSA6A:16;
then A9: ( Directed I ) c= p by A5,XBOOLE_1:1;
A10: p = ( p +* ( Directed I ) ) by A5,B9,FUNCT_4:98,XBOOLE_1:1;
reconsider m = ( ( m1 + 1 ) + m3 ) as (Element of ( NAT ));
A11: ( dom ( Directed I ) ) = ( dom I ) by FUNCT_4:99;
A14: ( p1 +* ( Directed I ) ) = ( p +* ( I +* ( Directed I ) ) ) by FUNCT_4:14
.= p by A10,A11,FUNCT_4:19;
A15: iS c= s3 by FUNCT_4:25;
then ( dom iS ) c= ( dom s3 ) by GRFUNC_1:2;
then A16: ( dom iS ) c= (the carrier of ( SCM+FSA )) by PARTFUN1:def 2;
A17: ( Reloc (J,( card I )) ) c= ( I ';' J ) by FUNCT_4:25;
JJ: I c= ( p +* I ) by FUNCT_4:25;
then A20: ( p +* I ) halts_on s by CKB2:def 1,A3;
hence A21: ( IC ( Comput (p,s,( ( LifeSpan (( p +* I ),s) ) + 1 )) ) ) = ( card I ) by A3,CKB24:1,A9;
A22:now
let x being set;
assume x in ( dom ( DataPart iS ) );
then A23: x in ( ( dom iS ) /\ D ) by RELAT_1:61;
then x in ( dom iS ) by XBOOLE_0:def 4;
then B24: x in { ( IC ( SCM+FSA ) ),( intloc ( 0 ) ) } by diS,ENUMSET1:1;
A25: x in D by A23,XBOOLE_0:def 4;
per cases  by B24,TARSKI:def 2;
suppose A27: x = ( intloc ( 0 ) );

thus ( ( DataPart iS ) . x ) = 1 by A27,A25,FUNCT_1:49,SCMFSA6A:43
.= ( ( Comput (p1,s,m1) ) . x ) by A27,CKB3:def 1,A7,A3
.= ( ( DataPart ( Comput (p1,s,m1) ) ) . x ) by A25,FUNCT_1:49;
end;
suppose x = ( IC ( SCM+FSA ) );

then (not x in ( Data-Locations ( SCM+FSA ) )) by STRUCT_0:3;
hence ( ( DataPart iS ) . x ) = ( ( DataPart ( Comput (p1,s,m1) ) ) . x ) by A23,XBOOLE_0:def 4;
end;
end;
A29: p3 halts_on s3 by CKB2:def 1,A2,A15;
( dom ( DataPart iS ) ) = ( ( dom iS ) /\ D ) by RELAT_1:61;
then ( dom ( DataPart iS ) ) c= ( (the carrier of ( SCM+FSA )) /\ D ) by A16,XBOOLE_1:26;
then ( dom ( DataPart iS ) ) c= ( ( dom ( Comput (p1,s,m1) ) ) /\ D ) by PARTFUN1:def 2;
then BB: ( dom ( DataPart iS ) ) c= ( dom ( DataPart ( Comput (p1,s,m1) ) ) ) by RELAT_1:61;
AA: ( DataPart s3 ) = ( ( DataPart ( Comput (p1,s,m1) ) ) +* ( DataPart iS ) ) by FUNCT_4:71;
CC: ( DataPart iS ) c= ( DataPart ( Comput (p1,s,m1) ) ) by A22,BB,GRFUNC_1:2;
A30: ( DataPart ( Comput (p1,s,m1) ) ) = ( DataPart s3 ) by CC,AA,FUNCT_4:98;
KK: ( p +* I ) halts_on s by A3,CKB2:def 1,JJ;
( DataPart ( Comput (p,s,m1) ) ) = ( DataPart s3 ) by A30,A4,A20,CKB27:1,A6;
hence A31: ( DataPart ( Comput (p,s,( m1 + 1 )) ) ) = ( DataPart s3 ) by A3,CKB25:1,A9,KK;
thus ( Reloc (J,( card I )) ) c= p by A5,A17,XBOOLE_1:1;
A33: ( Reloc (J,( card I )) ) c= p4 by A17,A5,XBOOLE_1:1;
( intloc ( 0 ) ) in ( Int-Locations ) by SCMFSA_2:2;
then A35: ( intloc ( 0 ) ) in D by SCMFSA_2:100,XBOOLE_0:def 3;
hence ( s4 . ( intloc ( 0 ) ) ) = ( ( DataPart s3 ) . ( intloc ( 0 ) ) ) by A31,FUNCT_1:49
.= ( s3 . ( intloc ( 0 ) ) ) by A35,FUNCT_1:49
.= 1 by FUNCT_4:13,SCMFSA6A:41,SCMFSA6A:43;
A36: ( Comput (p,s,( ( m1 + 1 ) + m3 )) ) = ( Comput (p,( Comput (p,s,( m1 + 1 )) ),m3) ) by EXTPRO_1:4;
A37: iS c= s3 by FUNCT_4:25;
then ( IncAddr (( CurInstr (p3,( Comput (p3,s3,m3) )) ),( card I )) ) = ( CurInstr (p,( Comput (p,s,( ( m1 + 1 ) + m3 )) )) ) by A36,A21,A31,CKB16:1,A2,A33;
then A38: ( CurInstr (p,( Comput (p,s,m) )) ) = ( IncAddr (( halt ( SCM+FSA ) ),( card I )) ) by A29,EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_1:11;
hence A39: p halts_on s by EXTPRO_1:29;
A40:now
let k being (Element of ( NAT ));
assume ( ( m1 + 1 ) + k ) < m;
then A41: k < m3 by XREAL_1:6;
assume A42: ( CurInstr (p,( Comput (p,s,( ( m1 + 1 ) + k )) )) ) = ( halt ( SCM+FSA ) );
( IncAddr (( CurInstr (p3,( Comput (p3,s3,k) )) ),( card I )) ) = ( CurInstr (p4,( Comput (p,s4,k) )) ) by A21,A31,A37,CKB16:1,A2,A33
.= ( halt ( SCM+FSA ) ) by A42,EXTPRO_1:4;
then ( InsCode ( CurInstr (p3,( Comput (p3,s3,k) )) ) ) = ( 0 ) by COMPOS_1:def 17,SCMFSA_2:97;
then ( CurInstr (p3,( Comput (p3,s3,k) )) ) = ( halt ( SCM+FSA ) ) by SCMFSA_2:95;
hence contradiction by A29,A41,EXTPRO_1:def 15;
end;
now
let k being (Element of ( NAT ));
assume A43: k < m;
per cases ;
suppose k <= m1;

hence ( CurInstr (p,( Comput (p,s,k) )) ) <> ( halt ( SCM+FSA ) ) by CKB26:1,A14,A3,FUNCT_4:25;
end;
suppose m1 < k;

then ( m1 + 1 ) <= k by NAT_1:13;
then consider kk being Nat such that A44: ( ( m1 + 1 ) + kk ) = k by NAT_1:10;
reconsider kk as (Element of ( NAT )) by ORDINAL1:def 12;
( ( m1 + 1 ) + kk ) = k by A44;
hence ( CurInstr (p,( Comput (p,s,k) )) ) <> ( halt ( SCM+FSA ) ) by A40,A43;
end;
end;
then A45: (for k being (Element of ( NAT )) holds (( CurInstr (p,( Comput (p,s,k) )) ) = ( halt ( SCM+FSA ) ) implies m <= k));
then A46: ( LifeSpan (p,s) ) = m by A38,A39,EXTPRO_1:def 15;
I c= ( p +* I ) by FUNCT_4:25;
then A49: p1 halts_on s by CKB2:def 1,A3;
( Comput (p1,s,( LifeSpan (p1,s) )) ) = ( Result (( p +* I ),s) ) by A49,EXTPRO_1:23;
hence ( LifeSpan (p,s) ) = ( ( ( LifeSpan (( p +* I ),s) ) + 1 ) + ( LifeSpan (( ( p +* I ) +* J ),( ( Result (( p +* I ),s) ) +* iS )) ) ) by A45,A38,A39,EXTPRO_1:def 15;
A50: iS c= s3 by FUNCT_4:25;
A51: ( DataPart ( Comput (p3,s3,m3) ) ) = ( DataPart ( Comput (p4,s4,m3) ) ) by A21,A31,A37,CKB16:1,A2,A33;
assume A52: J is  keeping_0;
thus ( ( Result (p,s) ) . ( intloc ( 0 ) ) ) = ( ( Comput (p,s,m) ) . ( intloc ( 0 ) ) ) by A39,A46,EXTPRO_1:23
.= ( ( Comput (p,s4,m3) ) . ( intloc ( 0 ) ) ) by EXTPRO_1:4
.= ( ( Comput (p3,s3,m3) ) . ( intloc ( 0 ) ) ) by A51,SCMFSA6A:7
.= ( s3 . ( intloc ( 0 ) ) ) by A52,A2,SCMFSA6B:def 4
.= 1 by A50,GRFUNC_1:2,SCMFSA6A:41,SCMFSA6A:43;
end;
