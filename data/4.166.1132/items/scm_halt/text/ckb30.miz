environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMFSA_2,FSM_1,SCMFSA6A,TARSKI,CIRCUIT2,RELAT_1,FUNCT_1,CARD_1,FUNCOP_1,FUNCT_4,XBOOLE_0,SCMFSA6B,NAT_1,XXREAL_0,ARYTM_3,AMI_3,SF_MASTR,GRAPHSP,MSUALG_1,AMISTD_2,TURING_1,STRUCT_0,VALUED_1,SCMFSA6C,SCMFSA7B,UNIALG_2,SCMFSA8B,ARYTM_1,SCMFSA8C,SCMFSA8A,SCM_HALT,PARTFUN1,SCMNORM,RELOC,COMPOS_1;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,RELAT_1,FINSEQ_1,FUNCT_1,PARTFUN1,FUNCT_4,FUNCT_7,PBOOLE,VALUED_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,FUNCOP_1,SCMFSA6B,SCMFSA6A,SF_MASTR,SCMFSA8A,SCMFSA8B,SFMASTR1,SCMFSA8C,SCMFSA7B,NAT_D,SCMFSA_3,SCMFSA6C,XXREAL_0,CKB1,CKB2,CKB3;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,XBOOLE_0,SCMFSA_2,SCMFSA8C,SCMFSA6A,AMISTD_2,SCMFSA7B,MEMSTR_0,CKB1,CKB2,CKB3;
theorems SF_MASTR,FUNCT_1,FUNCT_7,FUNCOP_1,RELAT_1,SCMFSA6A,FUNCT_4,ENUMSET1,AMI_3,NAT_1,TARSKI,INT_1,GRFUNC_1,SCMFSA_2,SCMFSA6B,SCMFSA7B,SCMFSA8B,SCMFSA8A,SCMFSA8C,SCMFSA_3,SCMFSA6C,CARD_1,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,XXREAL_0,VALUED_1,XREAL_0,PBOOLE,PARTFUN1,AFINSQ_1,FINSEQ_4,COMPOS_1,SFMASTR1,EXTPRO_1,AMISTD_2,AMISTD_5,ZFMISC_1,MEMSTR_0,AMISTD_1,STRUCT_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB7,CKB13,CKB14,CKB16,CKB17,CKB18,CKB21,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28;
schemes NAT_1;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8C,SCMFSA_9,ORDINAL1,RELAT_1,SCMFSA10,AMISTD_2,COMPOS_1,SFMASTR1,EXTPRO_1,SCMFSA_4,PBOOLE,FUNCT_4,FUNCT_7,PRE_POLY,STRUCT_0,FUNCOP_1,MEMSTR_0,CKB6,CKB8,CKB9,CKB10,CKB11,CKB12,CKB15,CKB19,CKB20,CKB22,CKB29;
constructors SFMASTR1,DOMAIN_1,XXREAL_0,REAL_1,SCM_1,SCMFSA_3,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA8C,AMISTD_1,AMISTD_2,NAT_D,RELSET_1,VALUED_1,SCMFSA7B,SCMFSA_9,AMISTD_5,PBOOLE,PRE_POLY,MEMSTR_0,CKB1,CKB2,CKB3;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve I for (Program of ( SCM+FSA ));
reserve s for (State of ( SCM+FSA ));
reserve a for Int-Location;
reserve f for FinSeq-Location;
reserve p for (Instruction-Sequence of ( SCM+FSA ));
set iS = ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) );
theorem
Th26: (for I being  keepInt0_1 (Program of ( SCM+FSA )) holds (( p +* I ) halts_on s implies (for J being  InitClosed (Program of ( SCM+FSA )) holds ((( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= s & ( I ';' J ) c= p) implies (for k being (Element of ( NAT )) holds ( ( Comput (( ( p +* I ) +* J ),( ( Result (( p +* I ),s) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ),k) ) +* ( Start-At (( ( IC ( Comput (( ( p +* I ) +* J ),( ( Result (( p +* I ),s) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ),k) ) ) + ( card I ) ),( SCM+FSA )) ) ) = ( Comput (( p +* ( I ';' J ) ),s,( ( ( LifeSpan (( p +* I ),s) ) + 1 ) + k )) ))))))
proof
let I being  keepInt0_1 (Program of ( SCM+FSA ));
assume A1: ( p +* I ) halts_on s;
let J being  InitClosed (Program of ( SCM+FSA ));
set sISA0 = ( s +* iS );
set pISA0 = ( p +* I );
A2: I c= pISA0 by FUNCT_4:25;
A3: iS c= sISA0 by FUNCT_4:25;
set RI = ( Result (( p +* I ),( s +* iS )) );
set pRI = ( p +* I );
set RIJ = ( RI +* iS );
set pRIJ = ( pRI +* J );
set sIJSA0 = ( Initialized s );
set pIJSA0 = ( p +* ( I ';' J ) );
defpred X[ Nat ]
 means
( ( Comput (pRIJ,RIJ,$1) ) +* ( Start-At (( ( IC ( Comput (pRIJ,RIJ,$1) ) ) + ( card I ) ),( SCM+FSA )) ) ) = ( Comput (pIJSA0,sIJSA0,( ( ( LifeSpan (pISA0,sISA0) ) + 1 ) + $1 )) );
assume B4: iS c= s;
then A4: s = sIJSA0 by FUNCT_4:98;
assume A5: ( I ';' J ) c= p;
then A6: pIJSA0 = p by FUNCT_4:98;
A10: (for k being (Element of ( NAT )) holds (X[ k ] implies X[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
set k1 = ( k + 1 );
set CRk = ( Comput (pRIJ,RIJ,k) );
set CRSk = ( IncIC (CRk,( card I )) );
set CIJk = ( Comput (pIJSA0,sIJSA0,( ( ( LifeSpan (pISA0,sISA0) ) + 1 ) + k )) );
set CRk1 = ( Comput (pRIJ,RIJ,k1) );
set CRSk1 = ( CRk1 +* ( Start-At (( ( IC CRk1 ) + ( card I ) ),( SCM+FSA )) ) );
set CIJk1 = ( Comput (pIJSA0,sIJSA0,( ( ( LifeSpan (pISA0,sISA0) ) + 1 ) + k1 )) );
assume A11: ( ( Comput (pRIJ,RIJ,k) ) +* ( Start-At (( ( IC ( Comput (pRIJ,RIJ,k) ) ) + ( card I ) ),( SCM+FSA )) ) ) = ( Comput (pIJSA0,sIJSA0,( ( ( LifeSpan (pISA0,sISA0) ) + 1 ) + k )) );
A12: ( IncAddr (( CurInstr (pRIJ,CRk) ),( card I )) ) = ( CurInstr (pIJSA0,CIJk) )
proof
A13: J c= pRIJ by FUNCT_4:25;
A14: iS c= RIJ by FUNCT_4:25;
A15: ( Reloc (J,( card I )) ) c= ( I ';' J ) by FUNCT_4:25;
( I ';' J ) c= pIJSA0 by FUNCT_4:25;
then A16: ( Reloc (J,( card I )) ) c= pIJSA0 by A15,XBOOLE_1:1;
A17: ( pIJSA0 /. ( IC CIJk ) ) = ( pIJSA0 . ( IC CIJk ) ) by PBOOLE:143;
A18: ( CurInstr (pIJSA0,CIJk) ) = ( pIJSA0 . ( ( IC CRk ) + ( card I ) ) ) by A11,A17,FUNCT_4:113;
reconsider ii = ( IC CRk ) as (Element of ( NAT ));
A19: ( Reloc (J,( card I )) ) = ( Shift (( IncAddr (J,( card I )) ),( card I )) ) by COMPOS_1:34;
A20: ( IC CRk ) in ( dom J ) by CKB1:def 1,A13,A14;
then A21: ii in ( dom ( IncAddr (J,( card I )) ) ) by COMPOS_1:def 19;
then A22: ( ( Shift (( IncAddr (J,( card I )) ),( card I )) ) . ( ( IC CRk ) + ( card I ) ) ) = ( ( IncAddr (J,( card I )) ) . ii ) by VALUED_1:def 12
.= ( IncAddr (( J /. ii ),( card I )) ) by A20,COMPOS_1:def 19;
( dom ( Shift (( IncAddr (J,( card I )) ),( card I )) ) ) = { ( il + ( card I ) ) where il is (Element of ( NAT )): il in ( dom ( IncAddr (J,( card I )) ) ) } by VALUED_1:def 12;
then A23: ( ( IC CRk ) + ( card I ) ) in ( dom ( Shift (( IncAddr (J,( card I )) ),( card I )) ) ) by A21;
A24: ( J /. ii ) = ( J . ( IC CRk ) ) by A20,PARTFUN1:def 6
.= ( pRIJ . ( IC CRk ) ) by A20,A13,GRFUNC_1:2;
( CurInstr (pRIJ,CRk) ) = ( pRIJ . ( IC CRk ) ) by PBOOLE:143;
hence ( IncAddr (( CurInstr (pRIJ,CRk) ),( card I )) ) = ( CurInstr (pIJSA0,CIJk) ) by A18,A22,A19,A23,A24,A16,GRFUNC_1:2;
end;
B25: ( Exec (( CurInstr (pIJSA0,CIJk) ),CIJk) ) = ( Exec (( IncAddr (( CurInstr (pRIJ,CRk) ),( card I )) ),CRSk) ) by A11,A12;
then A25: ( Exec (( CurInstr (pIJSA0,CIJk) ),CIJk) ) = ( IncIC (( Following (pRIJ,CRk) ),( card I )) ) by AMISTD_5:4;
CIJk1 = ( Comput (pIJSA0,sIJSA0,( ( ( ( LifeSpan (pISA0,sISA0) ) + 1 ) + k ) + 1 )) );
then A26: CIJk1 = ( Following (pIJSA0,CIJk) ) by EXTPRO_1:3;
A27:now
let a being Int-Location;
thus ( CRSk1 . a ) = ( CRk1 . a ) by SCMFSA_3:3
.= ( ( Following (pRIJ,CRk) ) . a ) by EXTPRO_1:3
.= ( CIJk1 . a ) by A26,A25,SCMFSA_3:3;
end;
A28:now
let f being FinSeq-Location;
thus ( CRSk1 . f ) = ( CRk1 . f ) by SCMFSA_3:4
.= ( ( Following (pRIJ,CRk) ) . f ) by EXTPRO_1:3
.= ( ( IncIC (( Following (pRIJ,CRk) ),( card I )) ) . f ) by SCMFSA_3:4
.= ( CIJk1 . f ) by A26,B25,AMISTD_5:4;
end;
( IC CRSk1 ) = ( ( IC CRk1 ) + ( card I ) ) by FUNCT_4:113
.= ( ( IC ( Following (pRIJ,CRk) ) ) + ( card I ) ) by EXTPRO_1:3;
then ( IC CRSk1 ) = ( IC ( IncIC (( Following (pRIJ,CRk) ),( card I )) ) ) by FUNCT_4:113
.= ( IC CIJk1 ) by A26,B25,AMISTD_5:4;
hence thesis by A27,A28,SCMFSA_2:61;
end;
A31: sISA0 = s by B4,FUNCT_4:98;
A32: ( Directed I ) c= ( I ';' J ) by SCMFSA6A:16;
A34: ( Directed I ) c= p by A32,A5,XBOOLE_1:1;
A35:now
set s2 = ( Comput (pIJSA0,sIJSA0,( ( ( LifeSpan (pISA0,sISA0) ) + 1 ) + ( 0 ) )) );
set s1 = ( IncIC (RIJ,( card I )) );
reconsider RIJ1 = ( RI +* ( ( intloc ( 0 ) ) .--> 1 ) ) as (State of ( SCM+FSA ));
A37: RIJ = ( Initialize RIJ1 ) by FUNCT_4:14;
thus ( IC s1 ) = ( ( IC RIJ ) + ( card I ) ) by FUNCT_4:113
.= ( ( 0 ) + ( card I ) ) by A37,FUNCT_4:113
.= ( IC s2 ) by A1,A31,CKB24:1,A34,A6,FUNCT_4:25;
A38: ( DataPart ( Comput (p,s,( LifeSpan (pISA0,sISA0) )) ) ) = ( DataPart ( Comput (p,s,( ( LifeSpan (pISA0,sISA0) ) + 1 )) ) ) by A1,A4,CKB25:1,A34,FUNCT_4:25;
hereby
let a being Int-Location;
(not a in ( dom ( Start-At (( ( IC RIJ ) + ( card I ) ),( SCM+FSA )) ) )) by SCMFSA_2:102;
then A39: ( s1 . a ) = ( RIJ . a ) by FUNCT_4:11;
A40: ( ( Comput (pISA0,sISA0,( LifeSpan (pISA0,sISA0) )) ) . a ) = ( ( Comput (pIJSA0,sIJSA0,( LifeSpan (pISA0,sISA0) )) ) . a ) by A1,A31,CKB27:1
.= ( s2 . a ) by A4,A38,A6,SCMFSA6A:7;
per cases ;
suppose S: a <> ( intloc ( 0 ) );

a <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
then (not a in ( dom iS )) by S,SCMFSA6A:42,TARSKI:def 2;
hence ( s1 . a ) = ( RI . a ) by A39,FUNCT_4:11
.= ( s2 . a ) by A1,A31,A40,EXTPRO_1:23;
end;
suppose A41: a = ( intloc ( 0 ) );

then a in ( dom iS ) by SCMFSA6A:42,TARSKI:def 2;
hence ( s1 . a ) = 1 by A41,A39,FUNCT_4:13,SCMFSA6A:43
.= ( s2 . a ) by A40,A41,CKB3:def 1,A2,A3;
end;
end;
let f being FinSeq-Location;
(f <> ( intloc ( 0 ) ) & f <> ( IC ( SCM+FSA ) )) by SCMFSA_2:57,SCMFSA_2:58;
then A42: (not f in ( dom iS )) by SCMFSA6A:42,TARSKI:def 2;
(not f in ( dom ( Start-At (( ( IC RIJ ) + ( card I ) ),( SCM+FSA )) ) )) by SCMFSA_2:103;
hence ( s1 . f ) = ( RIJ . f ) by FUNCT_4:11
.= ( RI . f ) by A42,FUNCT_4:11
.= ( ( Comput (pISA0,sISA0,( LifeSpan (pISA0,sISA0) )) ) . f ) by A1,A31,EXTPRO_1:23
.= ( ( Comput (pIJSA0,sIJSA0,( LifeSpan (pISA0,sISA0) )) ) . f ) by A1,A31,CKB27:1
.= ( s2 . f ) by A4,A38,A6,SCMFSA6A:7;
end;
( Comput (pRIJ,RIJ,( 0 )) ) = RIJ by EXTPRO_1:2;
then A43: X[ ( 0 ) ] by A35,SCMFSA_2:61;
(for k being (Element of ( NAT )) holds X[ k ]) from NAT_1:sch 1(A43,A10);
hence thesis by A31;
end;
