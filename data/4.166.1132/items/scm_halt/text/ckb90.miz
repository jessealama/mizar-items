environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMFSA_2,FSM_1,SCMFSA6A,TARSKI,CIRCUIT2,RELAT_1,FUNCT_1,CARD_1,FUNCOP_1,FUNCT_4,XBOOLE_0,SCMFSA6B,NAT_1,XXREAL_0,ARYTM_3,AMI_3,SF_MASTR,GRAPHSP,MSUALG_1,AMISTD_2,TURING_1,STRUCT_0,VALUED_1,SCMFSA6C,SCMFSA7B,UNIALG_2,SCMFSA8B,ARYTM_1,SCMFSA8C,SCMFSA8A,SCM_HALT,PARTFUN1,SCMNORM,RELOC,COMPOS_1;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,RELAT_1,FINSEQ_1,FUNCT_1,PARTFUN1,FUNCT_4,FUNCT_7,PBOOLE,VALUED_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,FUNCOP_1,SCMFSA6B,SCMFSA6A,SF_MASTR,SCMFSA8A,SCMFSA8B,SFMASTR1,SCMFSA8C,SCMFSA7B,NAT_D,SCMFSA_3,SCMFSA6C,XXREAL_0,CKB1,CKB2,CKB3,CKB47,CKB48;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,XBOOLE_0,SCMFSA_2,SCMFSA8C,SCMFSA6A,AMISTD_2,SCMFSA7B,MEMSTR_0,CKB1,CKB2,CKB3,CKB47,CKB48;
theorems SF_MASTR,FUNCT_1,FUNCT_7,FUNCOP_1,RELAT_1,SCMFSA6A,FUNCT_4,ENUMSET1,AMI_3,NAT_1,TARSKI,INT_1,GRFUNC_1,SCMFSA_2,SCMFSA6B,SCMFSA7B,SCMFSA8B,SCMFSA8A,SCMFSA8C,SCMFSA_3,SCMFSA6C,CARD_1,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,XXREAL_0,VALUED_1,XREAL_0,PBOOLE,PARTFUN1,AFINSQ_1,FINSEQ_4,COMPOS_1,SFMASTR1,EXTPRO_1,AMISTD_2,AMISTD_5,ZFMISC_1,MEMSTR_0,AMISTD_1,STRUCT_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB7,CKB13,CKB14,CKB16,CKB17,CKB18,CKB21,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB30,CKB31,CKB32,CKB33,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB55,CKB56,CKB57,CKB58,CKB59,CKB60,CKB61,CKB62,CKB63,CKB64,CKB65,CKB66,CKB67,CKB68,CKB69,CKB70,CKB71,CKB72,CKB73,CKB74,CKB75,CKB79,CKB80,CKB81,CKB82,CKB83,CKB84,CKB85,CKB86,CKB87,CKB88,CKB89;
schemes NAT_1;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8C,SCMFSA_9,ORDINAL1,RELAT_1,SCMFSA10,AMISTD_2,COMPOS_1,SFMASTR1,EXTPRO_1,SCMFSA_4,PBOOLE,FUNCT_4,FUNCT_7,PRE_POLY,STRUCT_0,FUNCOP_1,MEMSTR_0,CKB6,CKB8,CKB9,CKB10,CKB11,CKB12,CKB15,CKB19,CKB20,CKB22,CKB29,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB52,CKB53,CKB54,CKB76,CKB77,CKB78;
constructors SFMASTR1,DOMAIN_1,XXREAL_0,REAL_1,SCM_1,SCMFSA_3,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA8C,AMISTD_1,AMISTD_2,NAT_D,RELSET_1,VALUED_1,SCMFSA7B,SCMFSA_9,AMISTD_5,PBOOLE,PRE_POLY,MEMSTR_0,CKB1,CKB2,CKB3,CKB47,CKB48;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve m for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
reserve I for (Program of ( SCM+FSA ));
reserve s for (State of ( SCM+FSA ));
reserve a for Int-Location;
reserve p for (Instruction-Sequence of ( SCM+FSA ));
set SA0 = ( Start-At (( 0 ),( SCM+FSA )) );
set iS = ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) );
theorem
Th73: (for s being (State of ( SCM+FSA )) holds (for p holds (for I being  good  InitHalting (Program of ( SCM+FSA )) holds (for a being  read-write Int-Location holds ((((not I destroy a) & ( s . ( intloc ( 0 ) ) ) = 1) & ( s . a ) > ( 0 )) implies ( loop ( if=0 (a,( Goto 2 ),( I ';' ( SubFrom (a,( intloc ( 0 ) )) ) )) ) ) is_pseudo-closed_on s,p)))))
proof
let s being (State of ( SCM+FSA ));
let p;
let I being  good  InitHalting (Program of ( SCM+FSA ));
let a being  read-write Int-Location;
set P = ( if=0 (a,( Goto 2 ),( I ';' ( SubFrom (a,( intloc ( 0 ) )) ) )) );
reconsider I1 = ( I ';' ( SubFrom (a,( intloc ( 0 ) )) ) ) as  InitHalting (Program of ( SCM+FSA ));
set i = ( a =0_goto ( ( card I1 ) + 3 ) );
defpred P[ Nat ]
 means
(for s being (State of ( SCM+FSA )) holds (for p holds (((( s . ( intloc ( 0 ) ) ) = 1 & ( s . a ) = $1) & ( s . a ) > ( 0 )) implies ((( ( Comput (( p +* ( loop P ) ),( Initialized s ),( ( LifeSpan (( p +* P ),( Initialized s )) ) + 1 )) ) . a ) = ( ( s . a ) - 1 ) & ( ( Comput (( p +* ( loop P ) ),( Initialized s ),( ( LifeSpan (( p +* P ),( Initialized s )) ) + 1 )) ) . ( intloc ( 0 ) ) ) = 1) & (ex k being (Element of ( NAT )) st (( IC ( Comput (( p +* ( loop P ) ),( Initialized s ),k) ) ) = ( card ( loop P ) ) & (for n being (Element of ( NAT )) holds (n < k implies ( IC ( Comput (( p +* ( loop P ) ),( Initialized s ),n) ) ) in ( dom ( loop P ) )))))))));
assume A1: (not I destroy a);
A2: (for k being (Element of ( NAT )) holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
A3:now
A4: (( 0 ) in ( dom ( Macro i ) ) & ( ( Macro i ) . ( 0 ) ) <> ( halt ( SCM+FSA ) )) by COMPOS_1:58,COMPOS_1:60;
P = ( ( ( ( i ';' I1 ) ';' ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ';' ( Goto 2 ) ) ';' ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1
.= ( ( ( i ';' ( I1 ';' ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ) ';' ( Goto 2 ) ) ';' ( Stop ( SCM+FSA ) ) ) by SCMFSA6A:29
.= ( ( i ';' ( ( I1 ';' ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ';' ( Goto 2 ) ) ) ';' ( Stop ( SCM+FSA ) ) ) by SCMFSA6A:29
.= ( i ';' ( ( ( I1 ';' ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ';' ( Goto 2 ) ) ';' ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:29
.= ( ( Macro i ) ';' ( ( ( I1 ';' ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ';' ( Goto 2 ) ) ';' ( Stop ( SCM+FSA ) ) ) );
hence ( P . ( 0 ) ) = ( ( Macro i ) . ( 0 ) ) by A4,SCMFSA6A:15
.= i by COMPOS_1:58;
hence ( P . ( 0 ) ) <> ( halt ( SCM+FSA ) );
A5: ( card P ) = ( ( ( card ( Goto 2 ) ) + ( card I1 ) ) + 4 ) by SCMFSA8B:11
.= ( ( ( card I1 ) + 1 ) + 4 ) by SCMFSA8A:15
.= ( ( ( card I1 ) + 3 ) + 2 );
hence ( 0 ) in ( dom P ) by AFINSQ_1:66;
( card ( loop P ) ) = ( card ( dom ( loop P ) ) ) by CARD_1:62
.= ( card ( dom P ) ) by FUNCT_4:99
.= ( card P ) by CARD_1:62;
then ( card ( loop P ) ) = ( ( card I1 ) + ( 3 + 2 ) ) by A5;
hence ( P . ( ( card I1 ) + 3 ) ) = ( goto ( card ( loop P ) ) ) by SCMFSA8C:83;
hence ( P . ( ( card I1 ) + 3 ) ) <> ( halt ( SCM+FSA ) );
hereby
( ( ( card I1 ) + 3 ) + ( 0 ) ) < ( card P ) by A5,XREAL_1:6;
hence ( ( card I1 ) + 3 ) in ( dom P ) by AFINSQ_1:66;
end;
end;
let k being (Element of ( NAT ));
assume A6: P[ k ];
let ss being (State of ( SCM+FSA ));
let pp being (Instruction-Sequence of ( SCM+FSA ));
assume ( ss . ( intloc ( 0 ) ) ) = 1;
set s2 = ( Initialized ss );
set p2 = ( pp +* ( loop P ) );
A7: ( loop P ) c= p2 by FUNCT_4:25;
set s1 = ( Initialized ss );
set p1 = ( pp +* P );
assume A8: ( ss . a ) = ( k + 1 );
A9: ( Comput (p2,s2,( ( LifeSpan (p1,s1) ) + 1 )) ) = ( Following (p2,( Comput (p2,s2,( LifeSpan (p1,s1) )) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (p2,( Comput (p2,s2,( LifeSpan (p1,s1) )) )) ),( Comput (p2,s2,( LifeSpan (p1,s1) )) )) );
set s3 = ( Comput (p2,s2,( ( LifeSpan (p1,s1) ) + 1 )) );
set p3 = p2;
assume A10: ( ss . a ) > ( 0 );
A11: (I1 is_closed_onInit ss,pp & I1 is_halting_onInit ss,pp) by CKB49:1,CKB50:1;
then A12: P is_halting_onInit ss,pp by A10,CKB62:1;
P is_closed_onInit ss,pp by A10,A11,CKB62:1;
then A13: ( Comput (p2,s2,( ( LifeSpan (p1,s1) ) + 1 )) ) = ( Exec (( goto ( 0 ) ),( Comput (p2,s2,( LifeSpan (p1,s1) )) )) ) by A12,A9,CKB89:1;
A14: P is_closed_onInit ss,pp by A10,A11,CKB62:1;
A15: ( card P ) = ( ( ( card ( Goto 2 ) ) + ( card I1 ) ) + 4 ) by SCMFSA8B:11
.= ( ( ( card I1 ) + 1 ) + 4 ) by SCMFSA8A:15
.= ( ( ( card I1 ) + 3 ) + 2 );
A16: ( card ( loop P ) ) = ( card ( dom ( loop P ) ) ) by CARD_1:62
.= ( card ( dom P ) ) by FUNCT_4:99
.= ( card P ) by CARD_1:62;
A17:now
A18: I1 is_halting_onInit ss,pp by CKB50:1;
then A19: I1 is_halting_on ( Initialized ss ),pp by CKB58:1;
I1 is_closed_onInit ss,pp by CKB49:1;
then ( IExec (P,pp,ss) ) = ( ( IExec (I1,pp,ss) ) +* ( Start-At (( ( ( card ( Goto 2 ) ) + ( card I1 ) ) + 3 ),( SCM+FSA )) ) ) by A10,A18,CKB63:1;
then A20: ( ( IExec (P,pp,ss) ) . a ) = ( ( IExec (I1,pp,ss) ) . a ) by SCMFSA_3:3;
hereby
thus ( 0 ) in ( dom ( loop P ) ) by A16,A15,AFINSQ_1:66;
( ( ( card I1 ) + 3 ) + ( 1 + 1 ) ) = ( ( ( ( card I1 ) + 3 ) + 1 ) + 1 );
then ( ( ( card I1 ) + 3 ) + 1 ) < ( card P ) by A15,NAT_1:13;
then ( ( card I1 ) + 3 ) < ( card ( loop P ) ) by A16,NAT_1:13;
hence ( ( card I1 ) + 3 ) in ( dom ( loop P ) ) by AFINSQ_1:66;
end;
consider Is being (State of ( SCM+FSA )) such that A21: Is = ( Initialized ( Initialized ss ) );
A22: Is = ( ( Initialized ss ) +* ( ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) +* SA0 ) ) by A21,FUNCT_4:93
.= ( ( ( Initialized ss ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) +* SA0 ) by FUNCT_4:14
.= ( Initialize ( Initialized ss ) ) by FUNCT_4:93;
I1 is_closed_onInit ss,pp by CKB49:1;
then A23: I1 is_closed_on ( Initialized ss ),pp by CKB57:1;
I1 is_halting_onInit ss,pp by CKB50:1;
then A24: I1 is_halting_on ( Initialized ss ),pp by CKB58:1;
A25: ( ( Initialized ss ) . a ) > ( 0 ) by A10,SCMFSA6C:3;
then A26: P is_halting_on ( Initialized ss ),pp by A23,A24,SCMFSA8B:15;
thus ( Initialized ( Initialized ss ) ) = ( Initialized ss );
A28:now
let b being Int-Location;
( ( Comput (p2,s2,( ( LifeSpan (p1,s1) ) + 1 )) ) . b ) = ( ( Comput (p2,s2,( LifeSpan (p1,s1) )) ) . b ) by A13,SCMFSA_2:69;
hence ( ( Comput (p2,s2,( ( LifeSpan (p1,s1) ) + 1 )) ) . b ) = ( ( Comput (( pp +* P ),Is,( LifeSpan (( pp +* P ),Is) )) ) . b ) by A21,A12,A14,CKB87:1;
end;
then ( ( Comput (p2,s2,( ( LifeSpan (p1,s1) ) + 1 )) ) . a ) = ( ( Comput (( pp +* P ),Is,( LifeSpan (( pp +* P ),Is) )) ) . a )
.= ( ( IExec (P,pp,ss) ) . a ) by A26,A22,SCMFSA8C:58;
hence ( ( Comput (p2,s2,( ( LifeSpan (p1,s1) ) + 1 )) ) . a ) = ( ( Comput (( pp +* I1 ),( Initialize ( Initialized ss ) ),( LifeSpan (( pp +* I1 ),( Initialize ( Initialized ss ) )) )) ) . a ) by A19,A20,SCMFSA8C:58
.= ( ( ss . a ) - 1 ) by A1,CKB84:1;
A29: P is_closed_on ( Initialized ss ),pp by A25,A23,A24,SCMFSA8B:15;
( ( Comput (p2,s2,( ( LifeSpan (p1,s1) ) + 1 )) ) . ( intloc ( 0 ) ) ) = ( ( Comput (( pp +* P ),Is,( LifeSpan (( pp +* P ),Is) )) ) . ( intloc ( 0 ) ) ) by A28
.= 1 by A26,A29,A22,SCMFSA8C:67;
hence ( ( Comput (p2,s2,( ( LifeSpan (p1,s1) ) + 1 )) ) . ( intloc ( 0 ) ) ) = 1;
end;
hence (( s3 . a ) = ( ( ss . a ) - 1 ) & ( s3 . ( intloc ( 0 ) ) ) = 1);
A30: ( IC ( Comput (p2,s2,( ( LifeSpan (p1,s1) ) + 1 )) ) ) = ( 0 ) by A13,SCMFSA_2:69;
per cases ;
suppose A31: k = ( 0 );

take m = ( ( ( ( LifeSpan (p1,s1) ) + 1 ) + 1 ) + 1 );
A32: ( CurInstr (p2,( Comput (p2,s2,( ( LifeSpan (p1,s1) ) + 1 )) )) ) = ( p2 . ( 0 ) ) by A30,PBOOLE:143
.= ( ( loop P ) . ( 0 ) ) by A17,A7,GRFUNC_1:2
.= i by A3,FUNCT_4:105;
A33: ( Comput (p2,s2,( ( ( LifeSpan (p1,s1) ) + 1 ) + 1 )) ) = ( Following (p2,( Comput (p2,s2,( ( LifeSpan (p1,s1) ) + 1 )) )) ) by EXTPRO_1:3
.= ( Exec (i,( Comput (p2,s2,( ( LifeSpan (p1,s1) ) + 1 )) )) ) by A32;
then ( IC ( Comput (p2,s2,( ( ( LifeSpan (p1,s1) ) + 1 ) + 1 )) ) ) = ( ( card I1 ) + 3 ) by A8,A17,A31,SCMFSA_2:70;
then A34: ( CurInstr (p2,( Comput (p2,s2,( ( ( LifeSpan (p1,s1) ) + 1 ) + 1 )) )) ) = ( p2 . ( ( card I1 ) + 3 ) ) by PBOOLE:143
.= ( ( loop P ) . ( ( card I1 ) + 3 ) ) by A17,A7,GRFUNC_1:2
.= ( goto ( card ( loop P ) ) ) by A3,FUNCT_4:105;
( Comput (p2,s2,m) ) = ( Following (p2,( Comput (p2,s2,( ( ( LifeSpan (p1,s1) ) + 1 ) + 1 )) )) ) by EXTPRO_1:3
.= ( Exec (( goto ( card ( loop P ) ) ),( Comput (p2,s2,( ( ( LifeSpan (p1,s1) ) + 1 ) + 1 )) )) ) by A34;
hence ( IC ( Comput (p2,s2,m) ) ) = ( card ( loop P ) ) by SCMFSA_2:69;
hereby
let n being (Element of ( NAT ));
assume n < m;
then n <= ( ( ( LifeSpan (p1,s1) ) + 1 ) + 1 ) by NAT_1:13;
then A35: (n <= ( ( LifeSpan (p1,s1) ) + 1 ) or n = ( ( ( LifeSpan (p1,s1) ) + 1 ) + 1 )) by NAT_1:8;
per cases  by A35,NAT_1:8;
suppose A36: n <= ( LifeSpan (p1,s1) );

A37: (I1 is_closed_onInit ss,pp & I1 is_halting_onInit ss,pp) by CKB49:1,CKB50:1;
then A38: P is_closed_onInit ss,pp by A10,CKB62:1;
P is_halting_onInit ss,pp by A10,A37,CKB62:1;
then A39: ( IC ( Comput (p2,s2,n) ) ) = ( IC ( Comput (p1,s1,n) ) ) by A36,A38,CKB87:1;
( IC ( Comput (p1,s1,n) ) ) in ( dom P ) by A38,CKB47:def 1;
hence ( IC ( Comput (p2,s2,n) ) ) in ( dom ( loop P ) ) by A39,FUNCT_4:99;
end;
suppose n = ( ( LifeSpan (p1,s1) ) + 1 );

hence ( IC ( Comput (p2,s2,n) ) ) in ( dom ( loop P ) ) by A13,A17,SCMFSA_2:69;
end;
suppose n = ( ( ( LifeSpan (p1,s1) ) + 1 ) + 1 );

hence ( IC ( Comput (p2,s2,n) ) ) in ( dom ( loop P ) ) by A8,A17,A31,A33,SCMFSA_2:70;
end;
end;
end;
suppose A40: k > ( 0 );

consider Is3 being (State of ( SCM+FSA )) such that A41: Is3 = ( Initialized s3 );
consider m0 being (Element of ( NAT )) such that A44: ( IC ( Comput (( p3 +* ( loop P ) ),( Is3 +* iS ),m0) ) ) = ( card ( loop P ) ) and A45: (for n being (Element of ( NAT )) holds (n < m0 implies ( IC ( Comput (( p3 +* ( loop P ) ),( Initialized Is3 ),n) ) ) in ( dom ( loop P ) ))) by A6,A40,A8,A17,A41;
take m = ( ( ( LifeSpan (p1,s1) ) + 1 ) + m0 );
A46: ( Initialized ( Initialized s3 ) ) = s3 by A30,A17,SCMFSA6A:37;
A47: ( p3 +* ( loop P ) ) = p3 by FUNCT_4:25,FUNCT_4:98;
hence ( IC ( Comput (p2,s2,m) ) ) = ( card ( loop P ) ) by A41,A44,A46,EXTPRO_1:4;
hereby
let n being (Element of ( NAT ));
assume A48: n < m;
A49: (I1 is_closed_onInit ss,pp & I1 is_halting_onInit ss,pp) by CKB49:1,CKB50:1;
then A50: P is_closed_onInit ss,pp by A10,CKB62:1;
A51: P is_halting_onInit ss,pp by A10,A49,CKB62:1;
per cases  by NAT_1:13;
suppose n <= ( LifeSpan (p1,s1) );

then A52: ( IC ( Comput (p2,s2,n) ) ) = ( IC ( Comput (p1,s1,n) ) ) by A50,A51,CKB87:1;
( IC ( Comput (p1,s1,n) ) ) in ( dom P ) by A50,CKB47:def 1;
hence ( IC ( Comput (p2,s2,n) ) ) in ( dom ( loop P ) ) by A52,FUNCT_4:99;
end;
suppose A53: ( ( LifeSpan (p1,s1) ) + 1 ) <= n;

consider mm being (Element of ( NAT )) such that A54: mm = ( n -' ( ( LifeSpan (p1,s1) ) + 1 ) );
( n - ( ( LifeSpan (p1,s1) ) + 1 ) ) >= ( 0 ) by A53,XREAL_1:48;
then A55: mm = ( n - ( ( LifeSpan (p1,s1) ) + 1 ) ) by A54,XREAL_0:def 2;
( mm + ( ( LifeSpan (p1,s1) ) + 1 ) ) = n by A53,A54,XREAL_1:235;
then A56: ( IC ( Comput (p2,s2,n) ) ) = ( IC ( Comput (p2,s3,mm) ) ) by EXTPRO_1:4;
m0 = ( m - ( ( LifeSpan (p1,s1) ) + 1 ) );
then mm < m0 by A48,A55,XREAL_1:9;
hence ( IC ( Comput (p2,s2,n) ) ) in ( dom ( loop P ) ) by A41,A45,A46,A47,A56;
end;
end;
end;
end;
assume A57: ( s . ( intloc ( 0 ) ) ) = 1;
assume A58: ( s . a ) > ( 0 );
then reconsider sa = ( s . a ) as (Element of ( NAT )) by INT_1:3;
A59: P[ ( 0 ) ];
(for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A59,A2);
then B60: P[ sa ];
X4: ( dom SA0 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
( IC ( SCM+FSA ) ) <> ( intloc ( 0 ) ) by SCMFSA_2:56;
then (not ( intloc ( 0 ) ) in ( dom SA0 )) by X4,TARSKI:def 1;
then X1: ( ( Initialize s ) . ( intloc ( 0 ) ) ) = 1 by A57,FUNCT_4:11;
( IC ( SCM+FSA ) ) in ( dom SA0 ) by X4,TARSKI:def 1;
then X2: ( IC ( Initialize s ) ) = ( IC SA0 ) by FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
( dom ( ( intloc ( 0 ) ) .--> 1 ) ) = { ( intloc ( 0 ) ) } by FUNCOP_1:13;
then X3: ( dom SA0 ) misses ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) by X4,SCMFSA_2:56,ZFMISC_1:11;
( Initialized s ) = ( s +* ( SA0 +* ( ( intloc ( 0 ) ) .--> 1 ) ) ) by X3,FUNCT_4:35
.= ( ( Initialize s ) +* ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCT_4:14
.= ( ( ( Initialize s ) +* ( ( intloc ( 0 ) ) .--> 1 ) ) +* SA0 ) by X3,FUNCT_4:115
.= ( Initialized ( Initialize s ) ) by FUNCT_4:14
.= ( Initialize s ) by X1,X2,SCMFSA6A:37;
then (ex k being (Element of ( NAT )) st (( IC ( Comput (( p +* ( loop P ) ),( Initialize s ),k) ) ) = ( card ( loop P ) ) & (for n being (Element of ( NAT )) holds (n < k implies ( IC ( Comput (( p +* ( loop P ) ),( Initialize s ),n) ) ) in ( dom ( loop P ) ))))) by B60,A57,A58;
hence ( loop P ) is_pseudo-closed_on s,p by SCMFSA8A:def 2;
end;
