environ
vocabularies NUMBERS,NAT_1,INT_1,RELAT_1,ARYTM_3,CARD_1,XXREAL_0,SUBSET_1,ARYTM_1,INT_2,COMPLEX1,ORDINAL1,ZFMISC_1,XBOOLE_0,FINSET_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,CARD_1,FINSET_1,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,NAT_1,INT_1,INT_2;
theorems ORDINAL1,XCMPLX_1,XREAL_1,XXREAL_0,NAT_1,INT_1,INT_2,ABSVALUE,XREAL_0,CARD_1,ZFMISC_1,COMPLEX1,XCMPLX_0,TARSKI;
schemes NAT_1;
registrations XXREAL_0,XREAL_0,NAT_1,INT_1,ORDINAL1,XBOOLE_0,CARD_1,ZFMISC_1;
constructors XXREAL_0,NAT_1,INT_2,REAL_1,FINSET_1,CARD_1;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve k for Nat;
reserve l for Nat;
Lm1:now
let k;
let l;
( k div l ) in ( NAT ) by INT_1:3,INT_1:55;
hence ( k div l ) is Nat;
end;
Lm2:now
let k;
let l;
( k mod l ) in ( NAT ) by INT_1:3,INT_1:57;
hence ( k mod l ) is Nat;
end;
definition
let k being Nat;
let l being Nat;
redefine func k div l -> Nat
means
:Def1: ((ex t being Nat st (k = ( ( l * it ) + t ) & t < l)) or (it = ( 0 ) & l = ( 0 )));
compatibility
proof
let r being Nat;
per cases ;
suppose l = ( 0 );

hence thesis by INT_1:48;
end;
suppose A1: l > ( 0 );

then A2: k = ( ( l * ( k div l ) ) + ( k mod l ) ) by INT_1:59;
A3: ( k mod l ) is Nat by Lm2;
hence (r = ( k div l ) implies ((ex t being Nat st (k = ( ( l * r ) + t ) & t < l)) or (r = ( 0 ) & l = ( 0 )))) by A1,A2,INT_1:58;
assume A4: ((ex t being Nat st (k = ( ( l * r ) + t ) & t < l)) or (r = ( 0 ) & l = ( 0 )));
A5: ( k mod l ) < l by A1,INT_1:58;
( k div l ) is Nat by Lm1;
hence thesis by A2,A3,A4,A5,NAT_1:18;
end;
end;
coherence by Lm1;
end;
