environ
vocabularies NUMBERS,NAT_1,INT_1,RELAT_1,ARYTM_3,CARD_1,XXREAL_0,SUBSET_1,ARYTM_1,INT_2,COMPLEX1,ORDINAL1,ZFMISC_1,XBOOLE_0,FINSET_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,CARD_1,FINSET_1,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,NAT_1,INT_1,INT_2,CKB1;
definitions CKB1;
theorems ORDINAL1,XCMPLX_1,XREAL_1,XXREAL_0,NAT_1,INT_1,INT_2,ABSVALUE,XREAL_0,CARD_1,ZFMISC_1,COMPLEX1,XCMPLX_0,TARSKI,CKB1;
schemes NAT_1;
registrations XXREAL_0,XREAL_0,NAT_1,INT_1,ORDINAL1,XBOOLE_0,CARD_1,ZFMISC_1;
constructors XXREAL_0,NAT_1,INT_2,REAL_1,FINSET_1,CARD_1,CKB1;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve k for Nat;
reserve l for Nat;
Lm2:now
let k;
let l;
( k mod l ) in ( NAT ) by INT_1:3,INT_1:57;
hence ( k mod l ) is Nat;
end;
definition
let k being Nat;
let l being Nat;
redefine func k mod l -> Nat
means
:Def2: ((ex t being Nat st (k = ( ( l * t ) + it ) & it < l)) or (it = ( 0 ) & l = ( 0 )));
compatibility
proof
let r being Nat;
per cases ;
suppose l = ( 0 );

hence thesis by INT_1:def 10;
end;
suppose A1: l > ( 0 );

then A2: k = ( ( l * ( k div l ) ) + ( k mod l ) ) by INT_1:59;
hence (r = ( k mod l ) implies ((ex t being Nat st (k = ( ( l * t ) + r ) & r < l)) or (r = ( 0 ) & l = ( 0 )))) by A1,INT_1:58;
assume A3: ((ex t being Nat st (k = ( ( l * t ) + r ) & r < l)) or (r = ( 0 ) & l = ( 0 )));
A4: ( k mod l ) < l by A1,INT_1:58;
( k mod l ) is Nat by Lm2;
hence thesis by A2,A3,A4,NAT_1:18;
end;
end;
coherence by Lm2;
end;
