environ
vocabularies NUMBERS,NAT_1,INT_1,RELAT_1,ARYTM_3,CARD_1,XXREAL_0,SUBSET_1,ARYTM_1,INT_2,COMPLEX1,ORDINAL1,ZFMISC_1,XBOOLE_0,FINSET_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,CARD_1,FINSET_1,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,NAT_1,INT_1,INT_2,CKB1,CKB2,CKB3,CKB4,CKB7,CKB17,CKB18,CKB19,CKB20;
definitions CKB1,CKB2,CKB7,CKB17,CKB19;
theorems ORDINAL1,XCMPLX_1,XREAL_1,XXREAL_0,NAT_1,INT_1,INT_2,ABSVALUE,XREAL_0,CARD_1,ZFMISC_1,COMPLEX1,XCMPLX_0,TARSKI,CKB1,CKB2,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB19,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38;
schemes NAT_1,CKB21;
registrations XXREAL_0,XREAL_0,NAT_1,INT_1,ORDINAL1,XBOOLE_0,CARD_1,ZFMISC_1;
constructors XXREAL_0,NAT_1,INT_2,REAL_1,FINSET_1,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB7,CKB18,CKB20;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve i for Nat;
reserve j for Nat;
scheme INDI { k,n() -> (Element of ( NAT )),P[set] } : P[ n() ]
provided
A1: P[ ( 0 ) ]
and
A2: k() > ( 0 )
and
A3: (for i holds (for j holds (((P[ ( k() * i ) ] & j <> ( 0 )) & j <= k()) implies P[ ( ( k() * i ) + j ) ])))
proof
defpred R[ Nat ]
 means
P[ ( k() * $1 ) ];
A4: R[ ( 0 ) ] by A1;
A5:now
let i;
assume A6: R[ i ];
( k() * ( i + 1 ) ) = ( ( k() * i ) + k() );
hence R[ ( i + 1 ) ] by A2,A3,A6;
end;
A7: (for i holds R[ i ]) from NAT_1:sch 2(A4,A5);
per cases ;
suppose ( n() mod k() ) = ( 0 );

then n() = ( ( k() * ( n() div k() ) ) + ( 0 ) ) by A2,INT_1:59;
hence thesis by A7;
end;
suppose A8: ( n() mod k() ) <> ( 0 );

A9: n() = ( ( k() * ( n() div k() ) ) + ( n() mod k() ) ) by A2,INT_1:59;
( n() mod k() ) <= k() by A2,CKB5:1;
hence thesis by A3,A7,A8,A9;
end;
end;
