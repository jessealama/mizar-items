environ
vocabularies NUMBERS,ORDINAL1,RELAT_1,FUNCOP_1,FINSET_1,FUNCT_1,CARD_1,WELLORD2,XBOOLE_0,TARSKI,SUBSET_1,ZFMISC_1,WELLORD1,ORDINAL2,FINSEQ_2,FINSEQ_1,TREES_1,TREES_2,NAT_1,XXREAL_0,ARYTM_3,ORDINAL4,SETFAM_1,GOBOARD5,AMI_1,AMISTD_1,GLIB_000,AMISTD_2,AMISTD_3,PARTFUN1,CAT_1,AFINSQ_1,SCMNORM;
notations TARSKI,XBOOLE_0,SETFAM_1,ZFMISC_1,SUBSET_1,FINSET_1,CARD_1,NUMBERS,ORDINAL1,ORDINAL2,SEQ_4,XXREAL_0,NAT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,BINOP_1,WELLORD1,WELLORD2,FUNCOP_1,FINSEQ_1,FINSEQ_2,TREES_1,TREES_2,VALUED_1,AFINSQ_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,CKB1;
definitions RELAT_1,TARSKI,XBOOLE_0,WELLORD2,FUNCT_1,FINSEQ_2,FUNCOP_1,AFINSQ_1,VALUED_1,MEMSTR_0,CKB1;
theorems AMISTD_1,GRFUNC_1,NAT_1,ORDINAL1,CARD_1,TREES_2,TREES_1,FINSEQ_1,FUNCT_1,RELAT_1,FINSEQ_3,FINSEQ_5,TARSKI,CARD_5,FINSEQ_2,AMISTD_2,FUNCOP_1,XXREAL_0,XXREAL_2,PARTFUN1,TREES_9,AFINSQ_1,VALUED_1,COMPOS_1,MEMSTR_0,CKB1,CKB2;
schemes TREES_2,NAT_1,HILBERT2,ORDINAL2,BINOP_1,FRAENKEL;
registrations XBOOLE_0,RELAT_1,ORDINAL1,FUNCOP_1,FINSET_1,XXREAL_0,NAT_1,CARD_1,MEMBERED,FINSEQ_1,TREES_2,FINSEQ_6,AMISTD_1,SETFAM_1,VALUED_0,XXREAL_2,RELSET_1,FINSEQ_2,SUBSET_1,CARD_5,TREES_1,VALUED_1,AMISTD_2,COMPOS_1,EXTPRO_1,MEMSTR_0;
constructors WELLORD1,WELLORD2,BINOP_1,ORDINAL2,FINSEQ_2,SEQ_4,REALSET1,AMISTD_2,SEQ_2,RELSET_1,TREES_2,VALUED_1,PRE_POLY,AMISTD_1,FUNCOP_1,MEMSTR_0,CKB1;
requirements BOOLE,SUBSET,NUMERALS,REAL;
begin
reserve N for  with_non-empty_elements non  empty set;
reserve S for  standard  IC-Ins-separated non  empty AMI-Struct over N;
registration
let N being  with_non-empty_elements non  empty set;
let S being  standard  IC-Ins-separated non  empty AMI-Struct over N;
let M being (Subset of ( NAT ));
cluster ( LocSeq (M,S) ) ->  one-to-one;
coherence
proof
set f = ( LocSeq (M,S) );
set C = ( canonical_isomorphism_of (( RelIncl ( order_type_of ( RelIncl M ) ) ),( RelIncl M )) );
let x1 being set;
let x2 being set;
assume that
A1: (x1 in ( dom f ) & x2 in ( dom f ))
and
A2: ( f . x1 ) = ( f . x2 );
A3: ( dom f ) = ( card M ) by CKB1:def 1;
then A4: (( f . x1 ) = ( C . x1 ) & ( f . x2 ) = ( C . x2 )) by A1,CKB1:def 1;
A5: ( card M ) c= ( order_type_of ( RelIncl M ) ) by CARD_5:39;
consider phi being Ordinal-Sequence such that A6: phi = C and A7: phi is  increasing and A8: ( dom phi ) = ( order_type_of ( RelIncl M ) ) and ( rng phi ) = M by CARD_5:5;
phi is  one-to-one by A7,CARD_5:11;
hence thesis by A1,A2,A3,A4,A6,A8,A5,FUNCT_1:def 4;
end;
end;
