environ
vocabularies NUMBERS,ORDINAL1,RELAT_1,FUNCOP_1,FINSET_1,FUNCT_1,CARD_1,WELLORD2,XBOOLE_0,TARSKI,SUBSET_1,ZFMISC_1,WELLORD1,ORDINAL2,FINSEQ_2,FINSEQ_1,TREES_1,TREES_2,NAT_1,XXREAL_0,ARYTM_3,ORDINAL4,SETFAM_1,GOBOARD5,AMI_1,AMISTD_1,GLIB_000,AMISTD_2,AMISTD_3,PARTFUN1,CAT_1,AFINSQ_1,SCMNORM;
notations TARSKI,XBOOLE_0,SETFAM_1,ZFMISC_1,SUBSET_1,FINSET_1,CARD_1,NUMBERS,ORDINAL1,ORDINAL2,SEQ_4,XXREAL_0,NAT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,BINOP_1,WELLORD1,WELLORD2,FUNCOP_1,FINSEQ_1,FINSEQ_2,TREES_1,TREES_2,VALUED_1,AFINSQ_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,CKB1,CKB4;
definitions RELAT_1,TARSKI,XBOOLE_0,WELLORD2,FUNCT_1,FINSEQ_2,FUNCOP_1,AFINSQ_1,VALUED_1,MEMSTR_0,CKB1,CKB4;
theorems AMISTD_1,GRFUNC_1,NAT_1,ORDINAL1,CARD_1,TREES_2,TREES_1,FINSEQ_1,FUNCT_1,RELAT_1,FINSEQ_3,FINSEQ_5,TARSKI,CARD_5,FINSEQ_2,AMISTD_2,FUNCOP_1,XXREAL_0,XXREAL_2,PARTFUN1,TREES_9,AFINSQ_1,VALUED_1,COMPOS_1,MEMSTR_0,CKB1,CKB2,CKB4;
schemes TREES_2,NAT_1,HILBERT2,ORDINAL2,BINOP_1,FRAENKEL;
registrations XBOOLE_0,RELAT_1,ORDINAL1,FUNCOP_1,FINSET_1,XXREAL_0,NAT_1,CARD_1,MEMBERED,FINSEQ_1,TREES_2,FINSEQ_6,AMISTD_1,SETFAM_1,VALUED_0,XXREAL_2,RELSET_1,FINSEQ_2,SUBSET_1,CARD_5,TREES_1,VALUED_1,AMISTD_2,COMPOS_1,EXTPRO_1,MEMSTR_0,CKB3;
constructors WELLORD1,WELLORD2,BINOP_1,ORDINAL2,FINSEQ_2,SEQ_4,REALSET1,AMISTD_2,SEQ_2,RELSET_1,TREES_2,VALUED_1,PRE_POLY,AMISTD_1,FUNCOP_1,MEMSTR_0,CKB1,CKB4;
requirements BOOLE,SUBSET,NUMERALS,REAL;
begin
reserve x for set;
reserve n for  natural number;
reserve N for  with_non-empty_elements non  empty set;
reserve S for  standard  IC-Ins-separated non  empty AMI-Struct over N;
theorem
(for S being  standard  halting  IC-Ins-separated non  empty AMI-Struct over N holds ( ExecTree ( Stop S ) ) = ( ( TrivialInfiniteTree ) --> ( 0 ) ))
proof
set D = ( TrivialInfiniteTree );
let S being  standard  halting  IC-Ins-separated non  empty AMI-Struct over N;
set M = ( Stop S );
set E = ( ExecTree M );
defpred R[ set ]
 means
( E . $1 ) in ( dom M );
defpred X[ (Element of ( NAT )) ]
 means
( ( dom E ) -level $1 ) = ( D -level $1 );
A1: M = <% ( halt S ) %> by COMPOS_1:def 10;
then A2: ( dom M ) = { ( 0 ) } by FUNCOP_1:13;
A3: ( M . ( 0 ) ) = ( halt S ) by A1,FUNCOP_1:72;
A4: (for t being (Element of ( dom E )) holds ( card ( NIC (( halt S ),( E . t )) ) ) = { ( 0 ) })
proof
let t being (Element of ( dom E ));
reconsider Et = ( E . t ) as (Element of ( NAT ));
( NIC (( halt S ),Et) ) = { Et } by AMISTD_1:2;
hence thesis by CARD_1:30,CARD_1:49;
end;
A5: (for f being (Element of ( dom E )) holds (R[ f ] implies (for a being (Element of ( NAT )) holds (( f ^ <* a *> ) in ( dom E ) implies R[ ( f ^ <* a *> ) ]))))
proof
let f being (Element of ( dom E ));
assume that
A6: R[ f ];
A7: ( M /. ( E . f ) ) = ( M . ( E . f ) ) by A6,PARTFUN1:def 6;
reconsider Ef = ( E . f ) as (Element of ( NAT ));
A8: ( E . f ) = ( 0 ) by A2,A6,TARSKI:def 1;
then ( NIC (( halt S ),( E . f )) ) = { ( 0 ) } by AMISTD_1:2;
then ( canonical_isomorphism_of (( RelIncl ( order_type_of ( RelIncl ( NIC (( M /. ( E . f ) ),( E . f )) ) ) ) ),( RelIncl ( NIC (( M /. ( E . f ) ),( E . f )) ) )) ) = ( ( 0 ) .--> Ef ) by A3,A8,A7,CARD_5:38;
then A9: ( ( canonical_isomorphism_of (( RelIncl ( order_type_of ( RelIncl ( NIC (( M /. ( E . f ) ),( E . f )) ) ) ) ),( RelIncl ( NIC (( M /. ( E . f ) ),( E . f )) ) )) ) . ( 0 ) ) = Ef by FUNCOP_1:72
.= ( 0 ) by A2,A6,TARSKI:def 1;
A10: ( card ( NIC (( halt S ),( E . f )) ) ) = { ( 0 ) } by A4;
then A11: ( 0 ) in ( card ( NIC (( M /. ( E . f ) ),( E . f )) ) ) by A3,A8,A7,TARSKI:def 1;
A12: ( succ f ) = { ( f ^ <* k *> ) where k is (Element of ( NAT )): k in ( card ( NIC (( M /. ( E . f ) ),( E . f )) ) ) } by CKB4:def 1;
A13: ( succ f ) = { ( f ^ <* ( 0 ) *> ) }
proof
hereby
let s being set;
assume s in ( succ f );
then consider k being (Element of ( NAT )) such that A14: s = ( f ^ <* k *> ) and A15: k in ( card ( NIC (( M /. ( E . f ) ),( E . f )) ) ) by A12;
k = ( 0 ) by A3,A10,A8,A7,A15,TARSKI:def 1;
hence s in { ( f ^ <* ( 0 ) *> ) } by A14,TARSKI:def 1;
end;
let s being set;
assume s in { ( f ^ <* ( 0 ) *> ) };
then s = ( f ^ <* ( 0 ) *> ) by TARSKI:def 1;
hence thesis by A12,A11;
end;
let a being (Element of ( NAT ));
assume ( f ^ <* a *> ) in ( dom E );
then ( f ^ <* a *> ) in ( succ f ) by TREES_2:12;
then ( f ^ <* a *> ) = ( f ^ <* ( 0 ) *> ) by A13,TARSKI:def 1;
then ( E . ( f ^ <* a *> ) ) = ( ( LocSeq (( NIC (( M /. ( E . f ) ),( E . f )) ),S) ) . ( 0 ) ) by A11,CKB4:def 1
.= ( 0 ) by A11,A9,CKB1:def 1;
hence thesis by A2,TARSKI:def 1;
end;
( E . ( {} ) ) = ( FirstLoc M ) by CKB4:def 1;
then A16: R[ ( <*> ( NAT ) ) ] by VALUED_1:33;
A17: (for f being (Element of ( dom E )) holds R[ f ]) from HILBERT2:sch 1(A16,A5);
A18: (for x being set holds (x in ( dom E ) implies ( (E qua Function) . x ) = ( 0 )))
proof
let x being set;
assume x in ( dom E );
then reconsider x as (Element of ( dom E ));
( E . x ) in ( dom M ) by A17;
then ( E . x ) in { ( 0 ) } by A2;
hence thesis by TARSKI:def 1;
end;
A19: (for n being (Element of ( NAT )) holds (X[ n ] implies X[ ( n + 1 ) ]))
proof
let n being (Element of ( NAT ));
set f0 = ( n |-> ( 0 ) );
set f1 = ( ( n + 1 ) |-> ( 0 ) );
A20: ( ( dom E ) -level ( n + 1 ) ) = { w where w is (Element of ( dom E )): ( len w ) = ( n + 1 ) } by TREES_2:def 6;
A21: ( len f1 ) = ( n + 1 ) by CARD_1:def 7;
assume A22: X[ n ];
( ( dom E ) -level ( n + 1 ) ) = { f1 }
proof
hereby
let a being set;
assume a in ( ( dom E ) -level ( n + 1 ) );
then consider t1 being (Element of ( dom E )) such that A23: a = t1 and A24: ( len t1 ) = ( n + 1 ) by A20;
reconsider t0 = ( t1 | ( Seg n ) ) as (Element of ( dom E )) by RELAT_1:59,TREES_1:20;
A25: ( succ t0 ) = { ( t0 ^ <* k *> ) where k is (Element of ( NAT )): k in ( card ( NIC (( M /. ( E . t0 ) ),( E . t0 )) ) ) } by CKB4:def 1;
( E . t0 ) in ( dom M ) by A17;
then A26: ( E . t0 ) = ( 0 ) by A2,TARSKI:def 1;
A27: (( card ( NIC (( halt S ),( E . t0 )) ) ) = { ( 0 ) } & ( M /. ( E . t0 ) ) = ( M . ( E . t0 ) )) by A4,A17,PARTFUN1:def 6;
then A28: ( 0 ) in ( card ( NIC (( M /. ( E . t0 ) ),( E . t0 )) ) ) by A3,A26,TARSKI:def 1;
A29: ( succ t0 ) = { ( t0 ^ <* ( 0 ) *> ) }
proof
hereby
let s being set;
assume s in ( succ t0 );
then consider k being (Element of ( NAT )) such that A30: s = ( t0 ^ <* k *> ) and A31: k in ( card ( NIC (( M /. ( E . t0 ) ),( E . t0 )) ) ) by A25;
k = ( 0 ) by A3,A26,A27,A31,TARSKI:def 1;
hence s in { ( t0 ^ <* ( 0 ) *> ) } by A30,TARSKI:def 1;
end;
let s being set;
assume s in { ( t0 ^ <* ( 0 ) *> ) };
then s = ( t0 ^ <* ( 0 ) *> ) by TARSKI:def 1;
hence thesis by A25,A28;
end;
(( t1 . ( n + 1 ) ) is (Element of ( NAT )) & t1 = ( t0 ^ <* ( t1 . ( n + 1 ) ) *> )) by A24,FINSEQ_3:55,ORDINAL1:def 12;
then ( t0 ^ <* ( t1 . ( n + 1 ) ) *> ) in ( succ t0 ) by TREES_2:12;
then A32: ( t0 ^ <* ( t1 . ( n + 1 ) ) *> ) = ( t0 ^ <* ( 0 ) *> ) by A29,TARSKI:def 1;
n <= ( n + 1 ) by NAT_1:11;
then ( Seg n ) c= ( Seg ( n + 1 ) ) by FINSEQ_1:5;
then ( Seg n ) c= ( dom t1 ) by A24,FINSEQ_1:def 3;
then ( dom t0 ) = ( Seg n ) by RELAT_1:62;
then (( ( dom E ) -level n ) = { w where w is (Element of ( dom E )): ( len w ) = n } & ( len t0 ) = n) by FINSEQ_1:def 3,TREES_2:def 6;
then A33: t0 in ( ( dom E ) -level n );
A34: ( ( dom E ) -level n ) = { f0 } by A22,TREES_2:39;
(for k being Nat holds ((1 <= k & k <= ( len t1 )) implies ( t1 . k ) = ( f1 . k )))
proof
let k being Nat;
assume (1 <= k & k <= ( len t1 ));
then A35: k in ( Seg ( n + 1 ) ) by A24,FINSEQ_1:1;
now
per cases  by A35,FINSEQ_2:7;
suppose A36: k in ( Seg n );

hence ( t1 . k ) = ( t0 . k ) by FUNCT_1:49
.= ( f0 . k ) by A34,A33,TARSKI:def 1
.= ( 0 ) by A36,FUNCOP_1:7;
end;
suppose k = ( n + 1 );

hence ( t1 . k ) = ( 0 ) by A32,FINSEQ_2:17;
end;
end;
hence thesis by A35,FUNCOP_1:7;
end;
then t1 = f1 by A21,A24,FINSEQ_1:14;
hence a in { f1 } by A23,TARSKI:def 1;
end;
defpred P[ (Element of ( NAT )) ]
 means
( $1 |-> ( 0 ) ) in ( dom E );
let a being set;
A37: (for n being (Element of ( NAT )) holds (P[ n ] implies P[ ( n + 1 ) ]))
proof
let n being (Element of ( NAT ));
assume P[ n ];
then reconsider t = ( n |-> ( 0 ) ) as (Element of ( dom E ));
A38: ( succ t ) = { ( t ^ <* k *> ) where k is (Element of ( NAT )): k in ( card ( NIC (( M /. ( E . t ) ),( E . t )) ) ) } by CKB4:def 1;
( E . t ) in ( dom M ) by A17;
then A39: ( E . t ) = ( 0 ) by A2,TARSKI:def 1;
(( card ( NIC (( halt S ),( E . t )) ) ) = { ( 0 ) } & ( M /. ( E . t ) ) = ( M . ( E . t ) )) by A4,A17,PARTFUN1:def 6;
then ( 0 ) in ( card ( NIC (( M /. ( E . t ) ),( E . t )) ) ) by A3,A39,TARSKI:def 1;
then ( t ^ <* ( 0 ) *> ) in ( succ t ) by A38;
then ( t ^ <* ( 0 ) *> ) in ( dom E );
hence thesis by FINSEQ_2:60;
end;
A40: P[ ( 0 ) ] by TREES_1:22;
(for n being (Element of ( NAT )) holds P[ n ]) from NAT_1:sch 1(A40,A37);
then A41: f1 is (Element of ( dom E ));
assume a in { f1 };
then a = f1 by TARSKI:def 1;
hence thesis by A20,A21,A41;
end;
hence thesis by TREES_2:39;
end;
( ( dom E ) -level ( 0 ) ) = { ( {} ) } by TREES_9:44
.= ( D -level ( 0 ) ) by TREES_9:44;
then A42: X[ ( 0 ) ];
(for x being (Element of ( NAT )) holds X[ x ]) from NAT_1:sch 1(A42,A19);
then ( dom E ) = D by TREES_2:38;
hence thesis by A18,FUNCOP_1:11;
end;
