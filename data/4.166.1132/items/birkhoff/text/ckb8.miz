environ
vocabularies XBOOLE_0,STRUCT_0,MSUALG_1,RELAT_1,PBOOLE,MSAFREE,MSUALG_3,REALSET1,MEMBER_1,FUNCT_6,TARSKI,FUNCT_1,WELLORD1,MSUALG_2,PRALG_2,CARD_3,SUBSET_1,MSUALG_5,MSUALG_4,FUNCOP_1,RLVECT_2,PRALG_1,EQREL_1,CLOSURE2,SETFAM_1,FUNCT_4,ZFMISC_1,GROUP_6,NUMBERS,EQUATION,ZF_MODEL,ZF_LANG,MCART_1,PZFMISC1,MSAFREE2,FINSET_1,BIRKHOFF;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,SETFAM_1,RELAT_1,MCART_1,STRUCT_0,FUNCT_1,PBOOLE,RELSET_1,PARTFUN1,FUNCT_2,FINSET_1,CARD_3,FUNCT_6,FUNCOP_1,MSUALG_1,MSUALG_2,PRALG_3,MSUALG_3,MSAFREE,MSAFREE2,PRALG_2,MSUALG_4,PZFMISC1,MSSUBFAM,CLOSURE2,MSUALG_5,EQUATION,CKB1;
definitions FUNCT_1,RELAT_1,TARSKI,PBOOLE,MSUALG_3,PRALG_2,MSUALG_4,EQUATION,FUNCOP_1,PZFMISC1,CKB1;
theorems AUTALG_1,CARD_3,CLOSURE2,EXTENS_1,FUNCOP_1,FUNCT_1,FUNCT_2,MCART_1,MSAFREE,MSAFREE2,MSSCYC_1,MSSUBFAM,MSUALG_2,MSUALG_3,MSUALG_4,MSUALG_5,MSUALG_7,MSUALG_9,PBOOLE,PRALG_2,PRALG_3,EQUATION,RELAT_1,ZFMISC_1,SETFAM_1,PARTFUN1,CKB1,CKB2;
schemes DOMAIN_1,PBOOLE,CKB3,CKB4,CKB5,CKB6,CKB7;
registrations XBOOLE_0,ORDINAL1,RELSET_1,FUNCT_2,FUNCOP_1,PBOOLE,STRUCT_0,MSUALG_1,MSUALG_2,MSUALG_4,MSAFREE1,MSAFREE2,EXTENS_1,MSUALG_5,CLOSURE2,PRALG_3,MSUALG_9,EQUATION,MSSUBFAM,AUTALG_1;
constructors SETFAM_1,BINOP_1,PZFMISC1,MSSUBFAM,MSUALG_3,MSAFREE2,MSUALG_5,CLOSURE2,PRALG_3,EQUATION,RELSET_1,CKB1;
requirements SUBSET,BOOLE;
begin
scheme Hashisonto { S() -> non  empty non  void ManySortedSign,A() ->  strict  non-empty MSAlgebra over S(),F() -> (ManySortedFunction of ( (the carrier of S()) --> ( NAT ) ),(the Sorts of A())),P[set] } : ( F() -hash ) is_epimorphism ( FreeMSA ( (the carrier of S()) --> ( NAT ) ) ),A()
provided
A1: (for C being  non-empty MSAlgebra over S() holds (for G being (ManySortedFunction of ( (the carrier of S()) --> ( NAT ) ),(the Sorts of C)) holds (P[ C ] implies (ex H being (ManySortedFunction of A(),C) st ((H is_homomorphism A(),C & ( H ** F() ) = G) & (for K being (ManySortedFunction of A(),C) holds ((K is_homomorphism A(),C & ( K ** F() ) = G) implies H = K)))))))
and
A2: P[ A() ]
and
A3: (for A being  non-empty MSAlgebra over S() holds (for B being  strict  non-empty (MSSubAlgebra of A) holds (P[ A ] implies P[ B ])))
proof
A4: P[ A() ] by A2;
set V = ( (the carrier of S()) --> ( NAT ) );
reconsider Gen = (the Sorts of ( FreeMSA V )) as (GeneratorSet of ( FreeMSA V )) by MSAFREE2:6;
A5: ( F() .:.: V ) c= ( rngs F() ) by EQUATION:12;
(the Sorts of ( FreeMSA V )) is_transformable_to (the Sorts of A())
proof
let i being set;
assume that
A6: i in (the carrier of S());
assume ( (the Sorts of A()) . i ) = ( {} );
hence thesis by A6;
end;
then ( doms ( F() -hash ) ) = (the Sorts of ( FreeMSA V )) by MSSUBFAM:17;
then A7: ( ( F() -hash ) .:.: (the Sorts of ( FreeMSA V )) ) = ( rngs ( F() -hash ) ) by EQUATION:13;
( rngs F() ) c= ( rngs ( F() -hash ) ) by CKB2:1;
then A8: ( F() .:.: V ) c= ( ( F() -hash ) .:.: Gen ) by A7,A5,PBOOLE:13;
A9: ( F() -hash ) is_homomorphism ( FreeMSA V ),A() by CKB1:def 1;
A10: (for A being  non-empty MSAlgebra over S() holds (for B being  strict  non-empty (MSSubAlgebra of A) holds (P[ A ] implies P[ B ]))) by A3;
A11: (for C being  non-empty MSAlgebra over S() holds (for G being (ManySortedFunction of ( (the carrier of S()) --> ( NAT ) ),(the Sorts of C)) holds (P[ C ] implies (ex H being (ManySortedFunction of A(),C) st ((H is_homomorphism A(),C & ( H ** F() ) = G) & (for K being (ManySortedFunction of A(),C) holds ((K is_homomorphism A(),C & ( K ** F() ) = G) implies H = K))))))) by A1;
( F() .:.: V ) is  non-empty  non-empty (GeneratorSet of A()) from CKB7:sch 1(A11,A4,A10);
hence thesis by A8,A9,EQUATION:23;
end;
