environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMPDS_2,TURING_1,FUNCT_1,CARD_1,SCMFSA_7,RELAT_1,ARYTM_3,CARD_3,FSM_1,XXREAL_0,COMPLEX1,ARYTM_1,AMI_2,SCMPDS_5,SCMPDS_4,INT_1,SCMPDS_8,SCMFSA6B,SCMFSA_9,UNIALG_2,SCMFSA7B,SCMP_GCD,SEMI_AF1,GRAPHSP,AMI_3,FINSEQ_1,SCPISORT,NAT_1,ORDINAL4,SFMASTR2,PRE_FF,FUNCT_4,CIRCUIT2,TARSKI,PBOOLE,MSUALG_1,STRUCT_0,VALUED_1,SCMFSA8B,INT_2,SCPINVAR,ORDINAL1,PARTFUN1,SCMNORM,SCMFSA6C,COMPOS_1;
notations XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,PARTFUN1,VALUED_1,XCMPLX_0,FUNCT_4,PBOOLE,INT_1,INT_2,NAT_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,SCMPDS_2,SCMPDS_4,SCMPDS_6,SCMP_GCD,SCMPDS_5,SCMPDS_8,FUNCT_2,CARD_3,DOMAIN_1,FINSEQ_1,GR_CY_1,PRE_FF,SCPISORT,XXREAL_0,CKB5,CKB6,CKB10,CKB13,CKB31;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,AMI_3,SCMPDS_2,SCMP_GCD,SCPISORT,MEMSTR_0,CKB5,CKB10,CKB13,CKB31;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,INT_1,SCMPDS_2,ABSVALUE,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,ENUMSET1,INT_2,SCMPDS_8,SCMP_GCD,SCMPDS_7,FUNCT_1,FINSEQ_1,RVSUM_1,FINSEQ_2,MEMSTR_0,PRE_FF,SCPISORT,XBOOLE_1,XREAL_1,COMPLEX1,XXREAL_0,PREPOWER,ORDINAL1,FUNCOP_1,ZFMISC_1,NAT_D,FINSEQ_3,PBOOLE,PARTFUN1,AFINSQ_1,COMPOS_1,EXTPRO_1,CARD_3,CKB1,CKB2,CKB3,CKB5,CKB7,CKB8,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB30,CKB31;
schemes NAT_1,SCMPDS_8,FUNCT_2,CKB4,CKB9,CKB27,CKB28,CKB29;
registrations SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,CARD_3,STRUCT_0,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,XBOOLE_0,FINSEQ_1,CARD_1,VALUED_1,VALUED_0,MEMSTR_0,RELAT_1,FUNCT_2,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,FUNCT_4,CKB25,CKB26;
constructors DOMAIN_1,REAL_1,NAT_D,RECDEF_1,PRE_FF,MESFUNC1,GR_CY_1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,BINOP_2,AMI_2,MEMSTR_0,RELSET_1,CKB5,CKB6,CKB10,CKB13,CKB31;
requirements NUMERALS,REAL,SUBSET,ARITHM,BOOLE;
begin
reserve i for (Instruction of ( SCMPDS ));
reserve I for (Program of ( SCMPDS ));
reserve a for Int_position;
reserve Q for (Instruction-Sequence of ( SCMPDS ));
reserve P for (Instruction-Sequence of ( SCMPDS ));
theorem
Th21: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (for I being  halt-free  shiftable (Program of ( SCMPDS )) holds (for a,b,c being Int_position holds (for i,d being Integer holds (((((( s . a ) = d & ( s . b ) > ( 0 )) & ( s . c ) > ( 0 )) & ( s . ( DataLoc (d,i) ) ) = ( ( s . b ) - ( s . c ) )) & (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((((( t . b ) > ( 0 ) & ( t . c ) > ( 0 )) & ( t . a ) = d) & ( t . ( DataLoc (d,i) ) ) = ( ( t . b ) - ( t . c ) )) & ( t . b ) <> ( t . c )) implies (((((( ( IExec (I,Q,t) ) . a ) = d & I is_closed_on t,Q) & I is_halting_on t,Q) & (( t . b ) > ( t . c ) implies (( ( IExec (I,Q,t) ) . b ) = ( ( t . b ) - ( t . c ) ) & ( ( IExec (I,Q,t) ) . c ) = ( t . c )))) & (( t . b ) <= ( t . c ) implies (( ( IExec (I,Q,t) ) . c ) = ( ( t . c ) - ( t . b ) ) & ( ( IExec (I,Q,t) ) . b ) = ( t . b )))) & ( ( IExec (I,Q,t) ) . ( DataLoc (d,i) ) ) = ( ( ( IExec (I,Q,t) ) . b ) - ( ( IExec (I,Q,t) ) . c ) )))))) implies (( ( IExec (( while<>0 (a,i,I) ),P,s) ) . b ) = ( ( s . b ) gcd ( s . c ) ) & ( ( IExec (( while<>0 (a,i,I) ),P,s) ) . c ) = ( ( s . b ) gcd ( s . c ) )))))))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
let I being  halt-free  shiftable (Program of ( SCMPDS ));
let a being Int_position;
let b being Int_position;
let c being Int_position;
let i being Integer;
let d being Integer;
set ci = ( DataLoc (( s . a ),i) );
consider f being (Function of ( product (the Object-Kind of ( SCMPDS )) ),( NAT )) such that A2: (for s being (State of ( SCMPDS )) holds ((( s . b ) = ( s . c ) implies ( f . s ) = ( 0 )) & (( s . b ) <> ( s . c ) implies ( f . s ) = ( max (( abs ( s . b ) ),( abs ( s . c ) )) )))) by CKB2:1;
deffunc F((State of ( SCMPDS ))) = ( f . $1 );
set s1 = ( IExec (( while<>0 (a,i,I) ),P,s) );
set ss = s1;
defpred P[ set ]
 means
(ex t being ( 0 ) -started (State of ( SCMPDS )) st ((((t = $1 & ( t . b ) > ( 0 )) & ( t . c ) > ( 0 )) & ( ( t . b ) gcd ( t . c ) ) = ( ( s . b ) gcd ( s . c ) )) & ( t . ( DataLoc (d,i) ) ) = ( ( t . b ) - ( t . c ) )));
assume that
A3: ( s . a ) = d
and
A4: ( s . b ) > ( 0 )
and
A5: ( s . c ) > ( 0 )
and
A6: ( s . ( DataLoc (d,i) ) ) = ( ( s . b ) - ( s . c ) );
assume A7: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((((( t . b ) > ( 0 ) & ( t . c ) > ( 0 )) & ( t . a ) = d) & ( t . ( DataLoc (d,i) ) ) = ( ( t . b ) - ( t . c ) )) & ( t . b ) <> ( t . c )) implies (((((( ( IExec (I,Q,t) ) . a ) = d & I is_closed_on t,Q) & I is_halting_on t,Q) & (( t . b ) > ( t . c ) implies (( ( IExec (I,Q,t) ) . b ) = ( ( t . b ) - ( t . c ) ) & ( ( IExec (I,Q,t) ) . c ) = ( t . c )))) & (( t . b ) <= ( t . c ) implies (( ( IExec (I,Q,t) ) . c ) = ( ( t . c ) - ( t . b ) ) & ( ( IExec (I,Q,t) ) . b ) = ( t . b )))) & ( ( IExec (I,Q,t) ) . ( DataLoc (d,i) ) ) = ( ( ( IExec (I,Q,t) ) . b ) - ( ( IExec (I,Q,t) ) . c ) )))));
A8:now
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
assume that
A9: P[ t ]
and
A10: ( t . a ) = ( s . a )
and
A11: ( t . ci ) <> ( 0 );
set It = ( IExec (I,Q,t) );
set t2 = ( Initialize It );
set t1 = t;
set x = ( ( IExec (I,Q,t) ) . b );
set y = ( ( IExec (I,Q,t) ) . c );
consider v being (State of ( SCMPDS )) such that A12: v = t and A13: ( v . b ) > ( 0 ) and A14: ( v . c ) > ( 0 ) and A15: ( ( v . b ) gcd ( v . c ) ) = ( ( s . b ) gcd ( s . c ) ) and A16: ( v . ( DataLoc (d,i) ) ) = ( ( v . b ) - ( v . c ) ) by A9;
A17: ( t . b ) > ( 0 ) by A12,A13;
A18: ( t . c ) > ( 0 ) by A12,A14;
A19: ( t . ( DataLoc (d,i) ) ) = ( ( v . b ) - ( v . c ) ) by A12,A16
.= ( ( t . b ) - ( v . c ) ) by A12
.= ( ( t . b ) - ( t . c ) ) by A12;
then A20: (( t . b ) > ( t . c ) implies (( ( IExec (I,Q,t) ) . b ) = ( ( t . b ) - ( t . c ) ) & ( ( IExec (I,Q,t) ) . c ) = ( t . c ))) by A3,A7,A10,A17,A18;
A21: ( t . b ) <> ( t . c ) by A3,A11,A19;
hence ( ( IExec (I,Q,t) ) . a ) = ( t . a ) by A3,A7,A10,A17,A18,A19;
thus (I is_closed_on t,Q & I is_halting_on t,Q) by A3,A7,A10,A17,A18,A19,A21;
A22: (( t . b ) <= ( t . c ) implies (( ( IExec (I,Q,t) ) . c ) = ( ( t . c ) - ( t . b ) ) & ( ( IExec (I,Q,t) ) . b ) = ( t . b ))) by A3,A7,A10,A17,A18,A19,A21;
A23:now
per cases ;
suppose A24: ( t . b ) > ( t . c );

then ( ( t . b ) - ( t . c ) ) > ( 0 ) by XREAL_1:50;
hence x > ( 0 ) by A3,A7,A10,A17,A18,A19,A24;
thus y > ( 0 ) by A3,A7,A10,A17,A18,A19,A24;
thus ( x gcd y ) = ( ( t . b ) gcd ( t . c ) ) by A17,A18,A20,A22,PREPOWER:97;
A25: x = ( ( t . b ) - ( t . c ) ) by A3,A7,A10,A17,A18,A19,A24;
hereby
A26: ( max (( t . b ),( t . c )) ) = ( t . b ) by A24,XXREAL_0:def 10;
per cases  by XXREAL_0:16;
suppose ( max (x,y) ) = x;

hence ( max (x,y) ) < ( max (( t . b ),( t . c )) ) by A18,A25,A26,XREAL_1:44;
end;
suppose ( max (x,y) ) = y;

hence ( max (x,y) ) < ( max (( t . b ),( t . c )) ) by A3,A7,A10,A17,A18,A19,A24,A26;
end;
end;
end;
suppose A27: ( t . b ) <= ( t . c );

hence x > ( 0 ) by A3,A7,A10,A17,A18,A19,A21;
( t . b ) < ( t . c ) by A21,A27,XXREAL_0:1;
then ( ( t . c ) - ( t . b ) ) > ( 0 ) by XREAL_1:50;
hence y > ( 0 ) by A3,A7,A10,A17,A18,A19,A21,A27;
thus ( x gcd y ) = ( ( t . b ) gcd ( t . c ) ) by A17,A18,A20,A22,PREPOWER:97;
A28: y = ( ( t . c ) - ( t . b ) ) by A3,A7,A10,A17,A18,A19,A21,A27;
A29: x = ( t . b ) by A3,A7,A10,A17,A18,A19,A21,A27;
hereby
A30: ( max (( t . b ),( t . c )) ) = ( t . c ) by A27,XXREAL_0:def 10;
per cases  by XXREAL_0:16;
suppose ( max (x,y) ) = y;

hence ( max (x,y) ) < ( max (( t . b ),( t . c )) ) by A17,A28,A30,XREAL_1:44;
end;
suppose ( max (x,y) ) = x;

hence ( max (x,y) ) < ( max (( t . b ),( t . c )) ) by A21,A27,A29,A30,XXREAL_0:1;
end;
end;
end;
end;
thus F(t2) < F(t1)
proof
( t1 . b ) <> ( t . c ) by A21;
then ( t1 . b ) <> ( t1 . c );
then A31: F(t1) = ( max (( abs ( t1 . b ) ),( abs ( t1 . c ) )) ) by A2
.= ( max (( abs ( t . b ) ),( abs ( t1 . c ) )) )
.= ( max (( abs ( t . b ) ),( abs ( t . c ) )) )
.= ( max (( t . b ),( abs ( t . c ) )) ) by A17,ABSVALUE:def 1
.= ( max (( t . b ),( t . c )) ) by A18,ABSVALUE:def 1;
then F(t1) >= ( t . b ) by XXREAL_0:25;
then A32: F(t1) > ( 0 ) by A17,XXREAL_0:2;
per cases ;
suppose ( t2 . b ) = ( t2 . c );

hence thesis by A2,A32;
end;
suppose ( t2 . b ) <> ( t2 . c );

then F(t2) = ( max (( abs ( t2 . b ) ),( abs ( t2 . c ) )) ) by A2
.= ( max (( abs x ),( abs ( t2 . c ) )) ) by SCMPDS_5:15
.= ( max (( abs x ),( abs y )) ) by SCMPDS_5:15
.= ( max (x,( abs y )) ) by A23,ABSVALUE:def 1
.= ( max (x,y) ) by A23,ABSVALUE:def 1;
hence thesis by A23,A31;
end;
end;

A33: ( ( IExec (I,Q,t) ) . ( DataLoc (d,i) ) ) = ( ( ( IExec (I,Q,t) ) . b ) - ( ( IExec (I,Q,t) ) . c ) ) by A3,A7,A10,A17,A18,A19,A21;
thus P[ ( Initialize It ) ]
proof
take u = ( Initialize It );
thus u = ( Initialize It );
thus (( u . b ) > ( 0 ) & ( u . c ) > ( 0 )) by A23,SCMPDS_5:15;
thus ( ( u . b ) gcd ( u . c ) ) = ( ( It . b ) gcd ( u . c ) ) by SCMPDS_5:15
.= ( ( t . b ) gcd ( t . c ) ) by A23,SCMPDS_5:15
.= ( ( v . b ) gcd ( t . c ) ) by A12
.= ( ( s . b ) gcd ( s . c ) ) by A12,A15;
thus ( u . ( DataLoc (d,i) ) ) = ( x - y ) by A33,SCMPDS_5:15
.= ( ( u . b ) - y ) by SCMPDS_5:15
.= ( ( u . b ) - ( u . c ) ) by SCMPDS_5:15;
end;

end;
A34: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (P[ t ] implies (F(t) = ( 0 ) iff ( t . ci ) = ( 0 ))))
proof
let t being ( 0 ) -started (State of ( SCMPDS ));
assume P[ t ];
then consider v being (State of ( SCMPDS )) such that A35: v = t and A36: ( v . b ) > ( 0 ) and ( v . c ) > ( 0 ) and ( ( v . b ) gcd ( v . c ) ) = ( ( s . b ) gcd ( s . c ) ) and A37: ( v . ( DataLoc (d,i) ) ) = ( ( v . b ) - ( v . c ) );
A38: ( t . ci ) = ( ( v . b ) - ( v . c ) ) by A3,A35,A37
.= ( ( t . b ) - ( v . c ) ) by A35
.= ( ( t . b ) - ( t . c ) ) by A35;
hereby
assume A39: F(t) = ( 0 );
now
assume ( t . b ) <> ( t . c );
then ( t . b ) <> ( t . c );
then ( t . b ) <> ( t . c );
then A40: F(t) = ( max (( abs ( t . b ) ),( abs ( t . c ) )) ) by A2
.= ( max (( abs ( t . b ) ),( abs ( t . c ) )) )
.= ( max (( abs ( t . b ) ),( abs ( t . c ) )) );
( t . b ) > ( 0 ) by A35,A36;
then ( abs ( t . b ) ) > ( 0 ) by COMPLEX1:47;
hence contradiction by A39,A40,XXREAL_0:25;
end;
hence ( t . ci ) = ( 0 ) by A38;
end;
thus (( t . ci ) = ( 0 ) implies F(t) = ( 0 )) by A2,A38;
end;
A41: P[ s ] by A4,A5,A6;
A42: (F(( Initialize ss )) = ( 0 ) & P[ ( Initialize ss ) ]) from CKB29:sch 1(A34,A41,A8);
then consider w being ( 0 ) -started (State of ( SCMPDS )) such that A43: w = ( Initialize ss ) and A44: ( w . b ) > ( 0 ) and ( w . c ) > ( 0 ) and A45: ( ( w . b ) gcd ( w . c ) ) = ( ( s . b ) gcd ( s . c ) ) and A46: ( w . ( DataLoc (d,i) ) ) = ( ( w . b ) - ( w . c ) );
CI: ( ( Initialize ss ) . ci ) = ( ss . ci ) by SCMPDS_5:15;
B: ( ( Initialize ss ) . b ) = ( ss . b ) by SCMPDS_5:15;
C: ( ( Initialize ss ) . c ) = ( ss . c ) by SCMPDS_5:15;
A47: ( ( w . b ) - ( w . c ) ) = ( s1 . ci ) by A3,A43,A46,SCMPDS_5:15
.= ( 0 ) by A34,A42,CI;
then A48: ( abs ( w . b ) ) = ( ( abs ( w . b ) ) gcd ( abs ( w . c ) ) ) by NAT_D:32
.= ( ( s . b ) gcd ( s . c ) ) by A45,INT_2:34;
thus ( ( IExec (( while<>0 (a,i,I) ),P,s) ) . b ) = ( ss . b )
.= ( ( s . b ) gcd ( s . c ) ) by A43,A44,A48,B,ABSVALUE:def 1;
thus ( ( IExec (( while<>0 (a,i,I) ),P,s) ) . c ) = ( ss . c )
.= ( ( s . b ) gcd ( s . c ) ) by A43,A44,A47,A48,C,ABSVALUE:def 1;
end;
