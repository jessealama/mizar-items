environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMPDS_2,TURING_1,FUNCT_1,CARD_1,SCMFSA_7,RELAT_1,ARYTM_3,CARD_3,FSM_1,XXREAL_0,COMPLEX1,ARYTM_1,AMI_2,SCMPDS_5,SCMPDS_4,INT_1,SCMPDS_8,SCMFSA6B,SCMFSA_9,UNIALG_2,SCMFSA7B,SCMP_GCD,SEMI_AF1,GRAPHSP,AMI_3,FINSEQ_1,SCPISORT,NAT_1,ORDINAL4,SFMASTR2,PRE_FF,FUNCT_4,CIRCUIT2,TARSKI,PBOOLE,MSUALG_1,STRUCT_0,VALUED_1,SCMFSA8B,INT_2,SCPINVAR,ORDINAL1,PARTFUN1,SCMNORM,SCMFSA6C,COMPOS_1;
notations XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,PARTFUN1,VALUED_1,XCMPLX_0,FUNCT_4,PBOOLE,INT_1,INT_2,NAT_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,SCMPDS_2,SCMPDS_4,SCMPDS_6,SCMP_GCD,SCMPDS_5,SCMPDS_8,FUNCT_2,CARD_3,DOMAIN_1,FINSEQ_1,GR_CY_1,PRE_FF,SCPISORT,XXREAL_0,CKB5,CKB6,CKB10,CKB13;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,AMI_3,SCMPDS_2,SCMP_GCD,SCPISORT,MEMSTR_0,CKB5,CKB10,CKB13;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,INT_1,SCMPDS_2,ABSVALUE,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,ENUMSET1,INT_2,SCMPDS_8,SCMP_GCD,SCMPDS_7,FUNCT_1,FINSEQ_1,RVSUM_1,FINSEQ_2,MEMSTR_0,PRE_FF,SCPISORT,XBOOLE_1,XREAL_1,COMPLEX1,XXREAL_0,PREPOWER,ORDINAL1,FUNCOP_1,ZFMISC_1,NAT_D,FINSEQ_3,PBOOLE,PARTFUN1,AFINSQ_1,COMPOS_1,EXTPRO_1,CARD_3,CKB1,CKB2,CKB3,CKB5,CKB7,CKB8,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24;
schemes NAT_1,SCMPDS_8,FUNCT_2,CKB4,CKB9,CKB27,CKB28,CKB29;
registrations SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,CARD_3,STRUCT_0,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,XBOOLE_0,FINSEQ_1,CARD_1,VALUED_1,VALUED_0,MEMSTR_0,RELAT_1,FUNCT_2,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,FUNCT_4,CKB25,CKB26;
constructors DOMAIN_1,REAL_1,NAT_D,RECDEF_1,PRE_FF,MESFUNC1,GR_CY_1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,BINOP_2,AMI_2,MEMSTR_0,RELSET_1,CKB5,CKB6,CKB10,CKB13;
requirements NUMERALS,REAL,SUBSET,ARITHM,BOOLE;
begin
reserve i for (Instruction of ( SCMPDS ));
reserve I for (Program of ( SCMPDS ));
reserve a for Int_position;
reserve Q for (Instruction-Sequence of ( SCMPDS ));
reserve P for (Instruction-Sequence of ( SCMPDS ));
theorem
Th20: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (for I being  halt-free  shiftable (Program of ( SCMPDS )) holds (for a,b,c being Int_position holds (for i,d being Integer holds ((((((( card I ) > ( 0 ) & ( s . a ) = d) & ( s . b ) > ( 0 )) & ( s . c ) > ( 0 )) & ( s . ( DataLoc (d,i) ) ) = ( ( s . b ) - ( s . c ) )) & (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((((( t . b ) > ( 0 ) & ( t . c ) > ( 0 )) & ( t . a ) = d) & ( t . ( DataLoc (d,i) ) ) = ( ( t . b ) - ( t . c ) )) & ( t . b ) <> ( t . c )) implies (((((( ( IExec (I,Q,t) ) . a ) = d & I is_closed_on t,Q) & I is_halting_on t,Q) & (( t . b ) > ( t . c ) implies (( ( IExec (I,Q,t) ) . b ) = ( ( t . b ) - ( t . c ) ) & ( ( IExec (I,Q,t) ) . c ) = ( t . c )))) & (( t . b ) <= ( t . c ) implies (( ( IExec (I,Q,t) ) . c ) = ( ( t . c ) - ( t . b ) ) & ( ( IExec (I,Q,t) ) . b ) = ( t . b )))) & ( ( IExec (I,Q,t) ) . ( DataLoc (d,i) ) ) = ( ( ( IExec (I,Q,t) ) . b ) - ( ( IExec (I,Q,t) ) . c ) )))))) implies ((( while<>0 (a,i,I) ) is_closed_on s,P & ( while<>0 (a,i,I) ) is_halting_on s,P) & (( s . ( DataLoc (( s . a ),i) ) ) <> ( 0 ) implies ( IExec (( while<>0 (a,i,I) ),P,s) ) = ( IExec (( while<>0 (a,i,I) ),P,( Initialize ( IExec (I,P,s) ) )) ))))))))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
let I being  halt-free  shiftable (Program of ( SCMPDS ));
let a being Int_position;
let b being Int_position;
let c being Int_position;
let i being Integer;
let d being Integer;
set ci = ( DataLoc (( s . a ),i) );
assume ( card I ) > ( 0 );
consider f being (Function of ( product (the Object-Kind of ( SCMPDS )) ),( NAT )) such that A2: (for s being (State of ( SCMPDS )) holds ((( s . b ) = ( s . c ) implies ( f . s ) = ( 0 )) & (( s . b ) <> ( s . c ) implies ( f . s ) = ( max (( abs ( s . b ) ),( abs ( s . c ) )) )))) by CKB2:1;
deffunc F((State of ( SCMPDS ))) = ( f . $1 );
defpred P[ set ]
 means
(ex t being (State of ( SCMPDS )) st (((t = $1 & ( t . b ) > ( 0 )) & ( t . c ) > ( 0 )) & ( t . ( DataLoc (d,i) ) ) = ( ( t . b ) - ( t . c ) )));
assume that
A3: ( s . a ) = d
and
A4: ( s . b ) > ( 0 )
and
A5: ( s . c ) > ( 0 )
and
A6: ( s . ( DataLoc (d,i) ) ) = ( ( s . b ) - ( s . c ) );
assume A7: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((((( t . b ) > ( 0 ) & ( t . c ) > ( 0 )) & ( t . a ) = d) & ( t . ( DataLoc (d,i) ) ) = ( ( t . b ) - ( t . c ) )) & ( t . b ) <> ( t . c )) implies (((((( ( IExec (I,Q,t) ) . a ) = d & I is_closed_on t,Q) & I is_halting_on t,Q) & (( t . b ) > ( t . c ) implies (( ( IExec (I,Q,t) ) . b ) = ( ( t . b ) - ( t . c ) ) & ( ( IExec (I,Q,t) ) . c ) = ( t . c )))) & (( t . b ) <= ( t . c ) implies (( ( IExec (I,Q,t) ) . c ) = ( ( t . c ) - ( t . b ) ) & ( ( IExec (I,Q,t) ) . b ) = ( t . b )))) & ( ( IExec (I,Q,t) ) . ( DataLoc (d,i) ) ) = ( ( ( IExec (I,Q,t) ) . b ) - ( ( IExec (I,Q,t) ) . c ) )))));
A8:now
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
assume that
A9: P[ t ]
and
A10: ( t . a ) = ( s . a )
and
A11: ( t . ci ) <> ( 0 );
set It = ( IExec (I,Q,t) );
set t2 = ( Initialize It );
set t1 = t;
set x = ( ( IExec (I,Q,t) ) . b );
set y = ( ( IExec (I,Q,t) ) . c );
consider v being (State of ( SCMPDS )) such that A12: v = t and A13: ( v . b ) > ( 0 ) and A14: ( v . c ) > ( 0 ) and A15: ( v . ( DataLoc (d,i) ) ) = ( ( v . b ) - ( v . c ) ) by A9;
A16: ( t . b ) > ( 0 ) by A12,A13;
A17: ( t . c ) > ( 0 ) by A12,A14;
A18: ( t . ( DataLoc (d,i) ) ) = ( ( v . b ) - ( v . c ) ) by A12,A15
.= ( ( t . b ) - ( v . c ) ) by A12
.= ( ( t . b ) - ( t . c ) ) by A12;
then A19: ( t . b ) <> ( t . c ) by A3,A11;
hence ( ( IExec (I,Q,t) ) . a ) = ( t . a ) by A3,A7,A10,A16,A17,A18;
thus (I is_closed_on t,Q & I is_halting_on t,Q) by A3,A7,A10,A16,A17,A18,A19;
A20:now
per cases ;
suppose A21: ( t . b ) > ( t . c );

then ( ( t . b ) - ( t . c ) ) > ( 0 ) by XREAL_1:50;
hence x > ( 0 ) by A3,A7,A10,A16,A17,A18,A21;
thus y > ( 0 ) by A3,A7,A10,A16,A17,A18,A21;
A22: x = ( ( t . b ) - ( t . c ) ) by A3,A7,A10,A16,A17,A18,A21;
hereby
A23: ( max (( t . b ),( t . c )) ) = ( t . b ) by A21,XXREAL_0:def 10;
per cases  by XXREAL_0:16;
suppose ( max (x,y) ) = x;

hence ( max (x,y) ) < ( max (( t . b ),( t . c )) ) by A17,A22,A23,XREAL_1:44;
end;
suppose ( max (x,y) ) = y;

hence ( max (x,y) ) < ( max (( t . b ),( t . c )) ) by A3,A7,A10,A16,A17,A18,A21,A23;
end;
end;
end;
suppose A24: ( t . b ) <= ( t . c );

hence x > ( 0 ) by A3,A7,A10,A16,A17,A18,A19;
( t . b ) < ( t . c ) by A19,A24,XXREAL_0:1;
then ( ( t . c ) - ( t . b ) ) > ( 0 ) by XREAL_1:50;
hence y > ( 0 ) by A3,A7,A10,A16,A17,A18,A19,A24;
A25: y = ( ( t . c ) - ( t . b ) ) by A3,A7,A10,A16,A17,A18,A19,A24;
A26: x = ( t . b ) by A3,A7,A10,A16,A17,A18,A19,A24;
hereby
A27: ( max (( t . b ),( t . c )) ) = ( t . c ) by A24,XXREAL_0:def 10;
per cases  by XXREAL_0:16;
suppose ( max (x,y) ) = y;

hence ( max (x,y) ) < ( max (( t . b ),( t . c )) ) by A16,A25,A27,XREAL_1:44;
end;
suppose ( max (x,y) ) = x;

hence ( max (x,y) ) < ( max (( t . b ),( t . c )) ) by A19,A24,A26,A27,XXREAL_0:1;
end;
end;
end;
end;
thus F(t2) < F(t1)
proof
( t1 . b ) <> ( t . c ) by A19;
then ( t1 . b ) <> ( t1 . c );
then A28: F(t1) = ( max (( abs ( t1 . b ) ),( abs ( t1 . c ) )) ) by A2
.= ( max (( abs ( t . b ) ),( abs ( t1 . c ) )) )
.= ( max (( abs ( t . b ) ),( abs ( t . c ) )) )
.= ( max (( t . b ),( abs ( t . c ) )) ) by A16,ABSVALUE:def 1
.= ( max (( t . b ),( t . c )) ) by A17,ABSVALUE:def 1;
then F(t1) >= ( t . b ) by XXREAL_0:25;
then A29: F(t1) > ( 0 ) by A16,XXREAL_0:2;
per cases ;
suppose ( t2 . b ) = ( t2 . c );

hence thesis by A2,A29;
end;
suppose ( t2 . b ) <> ( t2 . c );

then F(t2) = ( max (( abs ( t2 . b ) ),( abs ( t2 . c ) )) ) by A2
.= ( max (( abs x ),( abs ( t2 . c ) )) ) by SCMPDS_5:15
.= ( max (( abs x ),( abs y )) ) by SCMPDS_5:15
.= ( max (x,( abs y )) ) by A20,ABSVALUE:def 1
.= ( max (x,y) ) by A20,ABSVALUE:def 1;
hence thesis by A20,A28;
end;
end;

A30: ( ( IExec (I,Q,t) ) . ( DataLoc (d,i) ) ) = ( ( ( IExec (I,Q,t) ) . b ) - ( ( IExec (I,Q,t) ) . c ) ) by A3,A7,A10,A16,A17,A18,A19;
thus P[ ( Initialize It ) ]
proof
take v = ( Initialize It );
thus v = ( Initialize It );
thus (( v . b ) > ( 0 ) & ( v . c ) > ( 0 )) by A20,SCMPDS_5:15;
thus ( v . ( DataLoc (d,i) ) ) = ( x - y ) by A30,SCMPDS_5:15
.= ( ( v . b ) - y ) by SCMPDS_5:15
.= ( ( v . b ) - ( v . c ) ) by SCMPDS_5:15;
end;

end;
A31: (for t being ( 0 ) -started (State of ( SCMPDS )) holds ((P[ t ] & F(t) = ( 0 )) implies ( t . ci ) = ( 0 )))
proof
let t being ( 0 ) -started (State of ( SCMPDS ));
assume that
A32: P[ t ]
and
A33: F(t) = ( 0 );
consider v being (State of ( SCMPDS )) such that A34: v = t and A35: ( v . b ) > ( 0 ) and ( v . c ) > ( 0 ) and A36: ( v . ( DataLoc (d,i) ) ) = ( ( v . b ) - ( v . c ) ) by A32;
A37:now
assume ( t . b ) <> ( t . c );
then ( t . b ) <> ( t . c );
then ( t . b ) <> ( t . c );
then A38: F(t) = ( max (( abs ( t . b ) ),( abs ( t . c ) )) ) by A2
.= ( max (( abs ( t . b ) ),( abs ( t . c ) )) )
.= ( max (( abs ( t . b ) ),( abs ( t . c ) )) );
( t . b ) > ( 0 ) by A34,A35;
then ( abs ( t . b ) ) > ( 0 ) by COMPLEX1:47;
hence contradiction by A33,A38,XXREAL_0:25;
end;
thus ( t . ci ) = ( ( v . b ) - ( v . c ) ) by A3,A34,A36
.= ( ( t . b ) - ( v . c ) ) by A34
.= ( ( t . b ) - ( t . c ) ) by A34
.= ( 0 ) by A37;
end;
A39: P[ s ] by A4,A5,A6;
(( while<>0 (a,i,I) ) is_closed_on s,P & ( while<>0 (a,i,I) ) is_halting_on s,P) from CKB27:sch 1(A31,A39,A8);
hence (( while<>0 (a,i,I) ) is_closed_on s,P & ( while<>0 (a,i,I) ) is_halting_on s,P);
assume A40: ( s . ( DataLoc (( s . a ),i) ) ) <> ( 0 );
( IExec (( while<>0 (a,i,I) ),P,s) ) = ( IExec (( while<>0 (a,i,I) ),P,( Initialize ( IExec (I,P,s) ) )) ) from CKB28:sch 1(A40,A31,A39,A8);
hence thesis;
end;
