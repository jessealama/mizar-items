environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMPDS_2,TURING_1,FUNCT_1,CARD_1,SCMFSA_7,RELAT_1,ARYTM_3,CARD_3,FSM_1,XXREAL_0,COMPLEX1,ARYTM_1,AMI_2,SCMPDS_5,SCMPDS_4,INT_1,SCMPDS_8,SCMFSA6B,SCMFSA_9,UNIALG_2,SCMFSA7B,SCMP_GCD,SEMI_AF1,GRAPHSP,AMI_3,FINSEQ_1,SCPISORT,NAT_1,ORDINAL4,SFMASTR2,PRE_FF,FUNCT_4,CIRCUIT2,TARSKI,PBOOLE,MSUALG_1,STRUCT_0,VALUED_1,SCMFSA8B,INT_2,SCPINVAR,ORDINAL1,PARTFUN1,SCMNORM,SCMFSA6C,COMPOS_1;
notations XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,PARTFUN1,VALUED_1,XCMPLX_0,FUNCT_4,PBOOLE,INT_1,INT_2,NAT_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,SCMPDS_2,SCMPDS_4,SCMPDS_6,SCMP_GCD,SCMPDS_5,SCMPDS_8,FUNCT_2,CARD_3,DOMAIN_1,FINSEQ_1,GR_CY_1,PRE_FF,SCPISORT,XXREAL_0,CKB5,CKB6;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,AMI_3,SCMPDS_2,SCMP_GCD,SCPISORT,MEMSTR_0,CKB5;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,INT_1,SCMPDS_2,ABSVALUE,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,ENUMSET1,INT_2,SCMPDS_8,SCMP_GCD,SCMPDS_7,FUNCT_1,FINSEQ_1,RVSUM_1,FINSEQ_2,MEMSTR_0,PRE_FF,SCPISORT,XBOOLE_1,XREAL_1,COMPLEX1,XXREAL_0,PREPOWER,ORDINAL1,FUNCOP_1,ZFMISC_1,NAT_D,FINSEQ_3,PBOOLE,PARTFUN1,AFINSQ_1,COMPOS_1,EXTPRO_1,CARD_3,CKB1,CKB2,CKB3,CKB5,CKB7,CKB8;
schemes NAT_1,SCMPDS_8,FUNCT_2,CKB4;
registrations SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,CARD_3,STRUCT_0,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,XBOOLE_0,FINSEQ_1,CARD_1,VALUED_1,VALUED_0,MEMSTR_0,RELAT_1,FUNCT_2,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,FUNCT_4;
constructors DOMAIN_1,REAL_1,NAT_D,RECDEF_1,PRE_FF,MESFUNC1,GR_CY_1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,BINOP_2,AMI_2,MEMSTR_0,RELSET_1,CKB5,CKB6;
requirements NUMERALS,REAL,SUBSET,ARITHM,BOOLE;
begin
reserve i for (Instruction of ( SCMPDS ));
reserve I for (Program of ( SCMPDS ));
reserve a for Int_position;
reserve Q for (Instruction-Sequence of ( SCMPDS ));
reserve U for (Instruction-Sequence of ( SCMPDS ));
reserve P for (Instruction-Sequence of ( SCMPDS ));
scheme WhileGEnd { F((State of ( SCMPDS ))) -> (Element of ( NAT )),s() -> ( 0 ) -started (State of ( SCMPDS )),P() -> (Instruction-Sequence of ( SCMPDS )),I() ->  halt-free  shiftable (Program of ( SCMPDS )),a() -> Int_position,i() -> Integer,P[set] } : (F(( Initialize ( IExec (( while>0 (a(),i(),I()) ),P(),s()) ) )) = ( 0 ) & P[ ( Initialize ( IExec (( while>0 (a(),i(),I()) ),P(),s()) ) ) ])
provided
A2: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (P[ t ] implies (F(t) = ( 0 ) iff ( t . ( DataLoc (( s() . a() ),i()) ) ) <= ( 0 ))))
and
A3: P[ s() ]
and
A4: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((P[ t ] & ( t . a() ) = ( s() . a() )) & ( t . ( DataLoc (( s() . a() ),i()) ) ) > ( 0 )) implies ((((( ( IExec (I(),Q,t) ) . a() ) = ( t . a() ) & I() is_closed_on t,Q) & I() is_halting_on t,Q) & F(( Initialize ( IExec (I(),Q,t) ) )) < F(t)) & P[ ( Initialize ( IExec (I(),Q,t) ) ) ]))))
proof
set b = ( DataLoc (( s() . a() ),i()) );
set WHL = ( while>0 (a(),i(),I()) );
defpred Q[ (Element of ( NAT )) ]
 means
(for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((F(t) <= $1 & ( t . a() ) = ( s() . a() )) & P[ t ]) implies (F(( Initialize ( IExec (WHL,Q,t) ) )) = ( 0 ) & P[ ( Initialize ( IExec (WHL,Q,t) ) ) ]))));
A5: Q[ ( 0 ) ]
proof
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
T: ( Initialize t ) = t by MEMSTR_0:44;
assume that
A6: F(t) <= ( 0 )
and
A7: ( t . a() ) = ( s() . a() )
and
A8: P[ t ];
F(t) >= ( 0 ) by NAT_1:2;
then A9: F(t) = ( 0 ) by A6,XXREAL_0:1;
then ( t . ( DataLoc (( s() . a() ),i()) ) ) <= ( 0 ) by A2,A8;
then (for b being Int_position holds ( ( IExec (WHL,Q,t) ) . b ) = ( t . b )) by A7,SCMPDS_8:23;
hence thesis by A8,A9,T,SCPISORT:4;
end;
A10:now
let k being (Element of ( NAT ));
assume A11: Q[ k ];
now
let u being ( 0 ) -started (State of ( SCMPDS ));
let U;
assume that
A12: F(u) <= ( k + 1 )
and
A13: ( u . a() ) = ( s() . a() )
and
A14: P[ u ];
per cases ;
suppose F(u) = ( 0 );

hence (F(( Initialize ( IExec (WHL,U,u) ) )) = ( 0 ) & P[ ( Initialize ( IExec (WHL,U,u) ) ) ]) by A5,A13,A14;
end;
suppose A15: F(u) <> ( 0 );

set Iu = ( IExec (I(),U,u) );
A16: ( u . b ) > ( 0 ) by A2,A14,A15;
then A17: (( Iu . a() ) = ( s() . a() ) & P[ ( Initialize Iu ) ]) by A4,A13,A14;
deffunc F((State of ( SCMPDS ))) = F($1);
A18: P[ u ] by A14;
A19: (for t being ( 0 ) -started (State of ( SCMPDS )) holds ((P[ t ] & F(t) = ( 0 )) implies ( t . ( DataLoc (( u . a() ),i()) ) ) <= ( 0 ))) by A2,A13;
F(( Initialize Iu )) < F(u) by A4,A13,A14,A16;
then ( F(( Initialize Iu )) + 1 ) <= F(u) by INT_1:7;
then ( F(( Initialize Iu )) + 1 ) <= ( k + 1 ) by A12,XXREAL_0:2;
then A20: F(( Initialize Iu )) <= k by XREAL_1:6;
A21: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((P[ t ] & ( t . a() ) = ( u . a() )) & ( t . ( DataLoc (( u . a() ),i()) ) ) > ( 0 )) implies ((((( ( IExec (I(),Q,t) ) . a() ) = ( t . a() ) & I() is_closed_on t,Q) & I() is_halting_on t,Q) & F(( Initialize ( IExec (I(),Q,t) ) )) < F(t)) & P[ ( Initialize ( IExec (I(),Q,t) ) ) ])))) by A4,A13;
A22: ( u . ( DataLoc (( u . a() ),i()) ) ) > ( 0 ) by A2,A13,A14,A15;
XX: ( IExec (WHL,U,u) ) = ( IExec (WHL,U,( Initialize Iu )) ) from SCMPDS_8:sch 4(A22,A19,A18,A21);
( ( Initialize Iu ) . a() ) = ( Iu . a() ) by SCMPDS_5:15;
hence (F(( Initialize ( IExec (WHL,U,u) ) )) = ( 0 ) & P[ ( Initialize ( IExec (WHL,U,u) ) ) ]) by A11,A20,A17,XX;
end;
end;
hence Q[ ( k + 1 ) ];
end;
(for k being (Element of ( NAT )) holds Q[ k ]) from NAT_1:sch 1(A5,A10);
then Q[ F(s()) ];
hence thesis by A3;
end;
