environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMPDS_2,TURING_1,FUNCT_1,CARD_1,SCMFSA_7,RELAT_1,ARYTM_3,CARD_3,FSM_1,XXREAL_0,COMPLEX1,ARYTM_1,AMI_2,SCMPDS_5,SCMPDS_4,INT_1,SCMPDS_8,SCMFSA6B,SCMFSA_9,UNIALG_2,SCMFSA7B,SCMP_GCD,SEMI_AF1,GRAPHSP,AMI_3,FINSEQ_1,SCPISORT,NAT_1,ORDINAL4,SFMASTR2,PRE_FF,FUNCT_4,CIRCUIT2,TARSKI,PBOOLE,MSUALG_1,STRUCT_0,VALUED_1,SCMFSA8B,INT_2,SCPINVAR,ORDINAL1,PARTFUN1,SCMNORM,SCMFSA6C,COMPOS_1;
notations XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,PARTFUN1,VALUED_1,XCMPLX_0,FUNCT_4,PBOOLE,INT_1,INT_2,NAT_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,SCMPDS_2,SCMPDS_4,SCMPDS_6,SCMP_GCD,SCMPDS_5,SCMPDS_8,FUNCT_2,CARD_3,DOMAIN_1,FINSEQ_1,GR_CY_1,PRE_FF,SCPISORT,XXREAL_0,CKB5,CKB6,CKB10,CKB13;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,AMI_3,SCMPDS_2,SCMP_GCD,SCPISORT,MEMSTR_0,CKB5,CKB10,CKB13;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,INT_1,SCMPDS_2,ABSVALUE,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,ENUMSET1,INT_2,SCMPDS_8,SCMP_GCD,SCMPDS_7,FUNCT_1,FINSEQ_1,RVSUM_1,FINSEQ_2,MEMSTR_0,PRE_FF,SCPISORT,XBOOLE_1,XREAL_1,COMPLEX1,XXREAL_0,PREPOWER,ORDINAL1,FUNCOP_1,ZFMISC_1,NAT_D,FINSEQ_3,PBOOLE,PARTFUN1,AFINSQ_1,COMPOS_1,EXTPRO_1,CARD_3,CKB1,CKB2,CKB3,CKB5,CKB7,CKB8,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24;
schemes NAT_1,SCMPDS_8,FUNCT_2,CKB4,CKB9;
registrations SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,CARD_3,STRUCT_0,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,XBOOLE_0,FINSEQ_1,CARD_1,VALUED_1,VALUED_0,MEMSTR_0,RELAT_1,FUNCT_2,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,FUNCT_4,CKB25,CKB26;
constructors DOMAIN_1,REAL_1,NAT_D,RECDEF_1,PRE_FF,MESFUNC1,GR_CY_1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,BINOP_2,AMI_2,MEMSTR_0,RELSET_1,CKB5,CKB6,CKB10,CKB13;
requirements NUMERALS,REAL,SUBSET,ARITHM,BOOLE;
begin
reserve i for (Instruction of ( SCMPDS ));
reserve I for (Program of ( SCMPDS ));
reserve a for Int_position;
reserve Q for (Instruction-Sequence of ( SCMPDS ));
reserve P for (Instruction-Sequence of ( SCMPDS ));
scheme WhileNHalt { F((State of ( SCMPDS ))) -> (Element of ( NAT )),s() -> ( 0 ) -started (State of ( SCMPDS )),P() -> (Instruction-Sequence of ( SCMPDS )),I() ->  halt-free  shiftable (Program of ( SCMPDS )),a() -> Int_position,i() -> Integer,P[set] } : (( while<>0 (a(),i(),I()) ) is_closed_on s(),P() & ( while<>0 (a(),i(),I()) ) is_halting_on s(),P())
provided
A2: (for t being ( 0 ) -started (State of ( SCMPDS )) holds ((P[ t ] & F(t) = ( 0 )) implies ( t . ( DataLoc (( s() . a() ),i()) ) ) = ( 0 )))
and
A3: P[ s() ]
and
A4: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((P[ t ] & ( t . a() ) = ( s() . a() )) & ( t . ( DataLoc (( s() . a() ),i()) ) ) <> ( 0 )) implies ((((( ( IExec (I(),Q,t) ) . a() ) = ( t . a() ) & I() is_closed_on t,Q) & I() is_halting_on t,Q) & F(( Initialize ( IExec (I(),Q,t) ) )) < F(t)) & P[ ( Initialize ( IExec (I(),Q,t) ) ) ]))))
proof
I: ( Initialize s() ) = s() by MEMSTR_0:44;
set i1 = ( (a(),i()) <>0_goto 2 );
set i2 = ( goto ( ( card I() ) + 2 ) );
set i3 = ( goto ( - ( ( card I() ) + 2 ) ) );
set WHL = ( while<>0 (a(),i(),I()) );
set pWH = ( stop WHL );
set pI = ( stop I() );
set b = ( DataLoc (( s() . a() ),i()) );
defpred Q[ (Element of ( NAT )) ]
 means
(for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((F(( Initialize t )) <= $1 & P[ ( Initialize t ) ]) & ( t . a() ) = ( s() . a() )) implies (WHL is_closed_on t,Q & WHL is_halting_on t,Q))));
A5: (for k being (Element of ( NAT )) holds (Q[ k ] implies Q[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume A6: Q[ k ];
now
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
T: ( Initialize t ) = t by MEMSTR_0:44;
assume A7: F(( Initialize t )) <= ( k + 1 );
assume A8: P[ ( Initialize t ) ];
assume A9: ( t . a() ) = ( s() . a() );
per cases ;
suppose ( t . b ) = ( 0 );

hence (WHL is_closed_on t,Q & WHL is_halting_on t,Q) by A9,CKB20:1;
end;
suppose A10: ( t . b ) <> ( 0 );

A13: ( ( IExec (I(),Q,t) ) . a() ) = ( t . a() ) by A4,A8,A9,A10,T;
A14: ( 0 ) in ( dom pWH ) by COMPOS_1:36;
A16: WHL = ( i1 ';' ( ( i2 ';' I() ) ';' i3 ) ) by CKB19:1;
A17: (not b in ( dom ( Start-At (( 0 ),( SCMPDS )) ) )) by SCMPDS_4:18;
set t2 = ( Initialize t );
set Q2 = ( Q +* pI );
set t3 = ( Initialize t );
set Q3 = ( Q +* pWH );
set t4 = ( Comput (Q3,t3,1) );
set Q4 = Q3;
A20: pI c= Q2 by FUNCT_4:25;
set m2 = ( LifeSpan (Q2,t2) );
set t5 = ( Comput (Q4,t4,m2) );
set Q5 = Q4;
set l2 = ( ( card I() ) + 2 );
A21: ( IC t3 ) = ( 0 ) by MEMSTR_0:47;
set m3 = ( m2 + 1 );
set t6 = ( Comput (Q3,t3,m3) );
set Q6 = Q3;
set t7 = ( Comput (Q3,t3,( m3 + 1 )) );
set Q7 = Q3;
( ( card I() ) + 2 ) < ( ( card I() ) + 3 ) by XREAL_1:6;
then A22: l2 in ( dom WHL ) by CKB16:1;
QQ: pWH c= Q3 by FUNCT_4:25;
WHL c= pWH by AFINSQ_1:74;
then A23: WHL c= Q3 by QQ,XBOOLE_1:1;
( Shift (I(),2) ) c= WHL by CKB24:1;
then ( Shift (I(),2) ) c= Q3 by A23,XBOOLE_1:1;
then A24: ( Shift (I(),2) ) c= Q4;
A25: ( Comput (Q3,t3,( ( 0 ) + 1 )) ) = ( Following (Q3,( Comput (Q3,t3,( 0 )) )) ) by EXTPRO_1:3
.= ( Following (Q3,t3) ) by EXTPRO_1:2
.= ( Exec (i1,t3) ) by A16,SCMPDS_6:11;
(for a holds ( t2 . a ) = ( t4 . a )) by A25,SCMPDS_2:55;
then A27: ( DataPart t2 ) = ( DataPart t4 ) by SCMPDS_4:8;
I() is_halting_on t,Q by A4,A8,A9,A10,T;
then A28: Q2 halts_on t2 by SCMPDS_6:def 3;
Q2 = ( Q2 +* pI ) by A20,FUNCT_4:98;
then ( Q2 +* pI ) halts_on ( Initialize t2 ) by A28;
then A30: I() is_halting_on t2,Q2 by SCMPDS_6:def 3;
A31: ( IExec (I(),Q,( Initialize t )) ) = ( Result (Q2,t2) ) by SCMPDS_4:def 5;
A32: P[ ( Initialize ( IExec (I(),Q,( Initialize t )) ) ) ] by A4,A8,A9,A10,T;
A33: I() is_closed_on t,Q by A4,A8,A9,A10,T;
then A34: I() is_closed_on t2,Q2 by SCMPDS_6:24;
(not a() in ( dom ( Start-At (( 0 ),( SCMPDS )) ) )) by SCMPDS_4:18;
then ( t3 . ( DataLoc (( t3 . a() ),i()) ) ) = ( t3 . b ) by A9,FUNCT_4:11
.= ( t . b ) by A17,FUNCT_4:11;
then A35: ( IC t4 ) = ( ICplusConst (t3,2) ) by A10,A25,SCMPDS_2:55
.= ( ( 0 ) + 2 ) by A21,SCMPDS_6:12;
then A36: ( IC t5 ) = l2 by A20,A30,A34,A27,A24,SCMPDS_7:18;
A37: ( Q6 /. ( IC t6 ) ) = ( Q6 . ( IC t6 ) ) by PBOOLE:143;
A38: t6 = t5 by EXTPRO_1:4;
then A39: ( CurInstr (Q6,t6) ) = ( Q5 . l2 ) by A20,A30,A34,A35,A27,A24,A37,SCMPDS_7:18
.= ( Q4 . l2 )
.= ( Q3 . l2 )
.= ( WHL . l2 ) by A22,A23,GRFUNC_1:2
.= i3 by CKB18:1;
A41: t7 = ( Following (Q3,t6) ) by EXTPRO_1:3
.= ( Exec (i3,t6) ) by A39;
then ( IC t7 ) = ( ICplusConst (t6,( ( 0 ) - ( ( card I() ) + 2 ) )) ) by SCMPDS_2:54
.= ( 0 ) by A36,A38,SCMPDS_7:1;
then B42: ( Initialize t7 ) = t7 by MEMSTR_0:46;
A42: ( Q7 +* pWH ) = Q7 by FUNCT_4:93;
A43: ( DataPart ( Comput (Q2,t2,m2) ) ) = ( DataPart t5 ) by A20,A30,A34,A35,A27,A24,SCMPDS_7:18;
then A44: ( DataPart t5 ) = ( DataPart ( Result (Q2,t2) ) ) by A28,EXTPRO_1:23
.= ( DataPart ( Result (Q2,t2) ) )
.= ( DataPart ( IExec (I(),Q,( Initialize t )) ) ) by SCMPDS_4:def 5;
( InsCode i3 ) = ( 0 ) by SCMPDS_2:12;
then ( InsCode i3 ) in { ( 0 ),4,5,6 } by ENUMSET1:def 2;
then A45: ( Initialize t7 ) = ( Initialize t6 ) by A41,SCMPDS_8:3
.= ( Initialize ( IExec (I(),Q,( Initialize t )) ) ) by A44,A38,MEMSTR_0:80;
A46:now
F(( Initialize ( IExec (I(),Q,( Initialize t )) ) )) < F(( Initialize t )) by A4,A8,A9,A10,T;
then A47: F(( Initialize t7 )) < ( k + 1 ) by A7,A45,XXREAL_0:2;
assume F(( Initialize t7 )) > k;
hence contradiction by A47,INT_1:7;
end;
A48: ( t5 . a() ) = ( ( Comput (Q2,t2,m2) ) . a() ) by A43,SCMPDS_4:8
.= ( ( Result (Q2,t2) ) . a() ) by A28,EXTPRO_1:23
.= ( s() . a() ) by A9,A13,A31,T;
A50: ( t7 . a() ) = ( t6 . a() ) by A41,SCMPDS_2:54
.= ( s() . a() ) by A48,EXTPRO_1:4;
X1: ( ( Initialize t7 ) . a() ) = ( t7 . a() ) by SCMPDS_5:15;
P[ ( Initialize ( Initialize t7 ) ) ] by A32,A45;
then X3: (WHL is_closed_on ( Initialize t7 ),Q7 & WHL is_halting_on ( Initialize t7 ),Q7) by A6,A46,A50,X1;
A51: WHL is_closed_on t7,Q7
proof
(for k being (Element of ( NAT )) holds ( IC ( Comput (( Q7 +* ( stop WHL ) ),( Initialize ( Initialize t7 ) ),k) ) ) in ( dom ( stop WHL ) )) by X3,SCMPDS_6:def 2;
hence thesis by SCMPDS_6:def 2;
end;
now
let k being (Element of ( NAT ));
per cases ;
suppose k < ( m3 + 1 );

then A52: k <= m3 by INT_1:7;
hereby
per cases  by A52,NAT_1:8;
suppose A53: k <= m2;

hereby
per cases ;
suppose k = ( 0 );

hence ( IC ( Comput (Q3,t3,k) ) ) in ( dom pWH ) by A14,A21,EXTPRO_1:2;
end;
suppose k <> ( 0 );

then consider kn being Nat such that A54: k = ( kn + 1 ) by NAT_1:6;
reconsider kn as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider lm = ( IC ( Comput (Q2,t2,kn) ) ) as (Element of ( NAT ));
kn < k by A54,XREAL_1:29;
then kn < m2 by A53,XXREAL_0:2;
then ( ( IC ( Comput (Q2,t2,kn) ) ) + 2 ) = ( IC ( Comput (Q4,t4,kn) ) ) by A20,A30,A34,A35,A27,A24,SCMPDS_7:16;
then A56: ( IC ( Comput (Q3,t3,k) ) ) = ( lm + 2 ) by A54,EXTPRO_1:4;
( IC ( Comput (Q2,t2,kn) ) ) in ( dom pI ) by A33,SCMPDS_6:def 2;
then lm < ( card pI ) by AFINSQ_1:66;
then lm < ( ( card I() ) + 1 ) by COMPOS_1:55;
then A57: ( lm + 2 ) < ( ( ( card I() ) + 1 ) + 2 ) by XREAL_1:6;
( ( card I() ) + 3 ) < ( ( card I() ) + 4 ) by XREAL_1:6;
then ( lm + 2 ) < ( ( card I() ) + 4 ) by A57,XXREAL_0:2;
then ( lm + 2 ) < ( card pWH ) by CKB15:1;
hence ( IC ( Comput (Q3,t3,k) ) ) in ( dom pWH ) by A56,AFINSQ_1:66;
end;
end;
end;
suppose A58: k = m3;

l2 in ( dom pWH ) by A22,COMPOS_1:62;
hence ( IC ( Comput (Q3,t3,k) ) ) in ( dom pWH ) by A20,A30,A34,A35,A27,A24,A38,A58,SCMPDS_7:18;
end;
end;
end;
suppose k >= ( m3 + 1 );

then consider nn being Nat such that A59: k = ( ( m3 + 1 ) + nn ) by NAT_1:10;
reconsider nn as (Element of ( NAT )) by ORDINAL1:def 12;
Q3 = ( Q7 +* pWH ) by FUNCT_4:93;
then ( Comput (Q3,t3,k) ) = ( Comput (( Q7 +* pWH ),( Initialize t7 ),nn) ) by A59,B42,EXTPRO_1:4;
hence ( IC ( Comput (Q3,t3,k) ) ) in ( dom pWH ) by A51,SCMPDS_6:def 2;
end;
end;
hence WHL is_closed_on t,Q by SCMPDS_6:def 2;
WHL is_halting_on t7,Q7
proof
( Q7 +* ( stop WHL ) ) halts_on ( Initialize ( Initialize t7 ) ) by X3,SCMPDS_6:def 3;
hence thesis by SCMPDS_6:def 3;
end;
then Q7 halts_on t7 by A42,B42,SCMPDS_6:def 3;
then Q3 halts_on t7;
then Q3 halts_on t3 by EXTPRO_1:22;
hence WHL is_halting_on t,Q by SCMPDS_6:def 3;
end;
end;
hence thesis;
end;
set n = F(s());
A60: Q[ ( 0 ) ]
proof
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
assume that
A61: (F(( Initialize t )) <= ( 0 ) & P[ ( Initialize t ) ])
and
A62: ( t . a() ) = ( s() . a() );
X: F(( Initialize t )) >= ( 0 ) by NAT_1:2;
( ( Initialize t ) . b ) = ( t . b ) by SCMPDS_5:15;
then ( t . b ) = ( 0 ) by A2,A61,X,XXREAL_0:1;
hence thesis by A62,CKB20:1;
end;
(for k being (Element of ( NAT )) holds Q[ k ]) from NAT_1:sch 1(A60,A5);
then Q[ n ];
hence thesis by A3,I;
end;
