environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMPDS_2,TURING_1,FUNCT_1,CARD_1,SCMFSA_7,RELAT_1,ARYTM_3,CARD_3,FSM_1,XXREAL_0,COMPLEX1,ARYTM_1,AMI_2,SCMPDS_5,SCMPDS_4,INT_1,SCMPDS_8,SCMFSA6B,SCMFSA_9,UNIALG_2,SCMFSA7B,SCMP_GCD,SEMI_AF1,GRAPHSP,AMI_3,FINSEQ_1,SCPISORT,NAT_1,ORDINAL4,SFMASTR2,PRE_FF,FUNCT_4,CIRCUIT2,TARSKI,PBOOLE,MSUALG_1,STRUCT_0,VALUED_1,SCMFSA8B,INT_2,SCPINVAR,ORDINAL1,PARTFUN1,SCMNORM,SCMFSA6C,COMPOS_1;
notations XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,PARTFUN1,VALUED_1,XCMPLX_0,FUNCT_4,PBOOLE,INT_1,INT_2,NAT_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,SCMPDS_2,SCMPDS_4,SCMPDS_6,SCMP_GCD,SCMPDS_5,SCMPDS_8,FUNCT_2,CARD_3,DOMAIN_1,FINSEQ_1,GR_CY_1,PRE_FF,SCPISORT,XXREAL_0,CKB5,CKB6,CKB10,CKB13,CKB31;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,AMI_3,SCMPDS_2,SCMP_GCD,SCPISORT,MEMSTR_0,CKB5,CKB10,CKB13,CKB31;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,INT_1,SCMPDS_2,ABSVALUE,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,ENUMSET1,INT_2,SCMPDS_8,SCMP_GCD,SCMPDS_7,FUNCT_1,FINSEQ_1,RVSUM_1,FINSEQ_2,MEMSTR_0,PRE_FF,SCPISORT,XBOOLE_1,XREAL_1,COMPLEX1,XXREAL_0,PREPOWER,ORDINAL1,FUNCOP_1,ZFMISC_1,NAT_D,FINSEQ_3,PBOOLE,PARTFUN1,AFINSQ_1,COMPOS_1,EXTPRO_1,CARD_3,CKB1,CKB2,CKB3,CKB5,CKB7,CKB8,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB30,CKB31,CKB32,CKB33;
schemes NAT_1,SCMPDS_8,FUNCT_2,CKB4,CKB9,CKB27,CKB28,CKB29;
registrations SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,CARD_3,STRUCT_0,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,XBOOLE_0,FINSEQ_1,CARD_1,VALUED_1,VALUED_0,MEMSTR_0,RELAT_1,FUNCT_2,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,FUNCT_4,CKB25,CKB26;
constructors DOMAIN_1,REAL_1,NAT_D,RECDEF_1,PRE_FF,MESFUNC1,GR_CY_1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,BINOP_2,AMI_2,MEMSTR_0,RELSET_1,CKB5,CKB6,CKB10,CKB13,CKB31;
requirements NUMERALS,REAL,SUBSET,ARITHM,BOOLE;
begin
reserve Q for (Instruction-Sequence of ( SCMPDS ));
reserve P for (Instruction-Sequence of ( SCMPDS ));
set a1 = ( intpos 1 );
set a2 = ( intpos 2 );
set a3 = ( intpos 3 );
set i1 = ( ( GBP ) := ( 0 ) );
set i2 = ( (( GBP ),3) := (( GBP ),1) );
set i3 = ( SubFrom (( GBP ),3,( GBP ),2) );
set j1 = ( Load ( SubFrom (( GBP ),1,( GBP ),2) ) );
set j2 = ( Load ( SubFrom (( GBP ),2,( GBP ),1) ) );
set IF = ( if>0 (( GBP ),3,j1,j2) );
set k1 = ( (( GBP ),3) := (( GBP ),1) );
set k2 = ( SubFrom (( GBP ),3,( GBP ),2) );
set WB = ( ( IF ';' k1 ) ';' k2 );
set WH = ( while<>0 (( GBP ),3,WB) );
Lm12: ( card WB ) = 6
proof
thus ( card WB ) = ( ( card ( IF ';' k1 ) ) + 1 ) by SCMP_GCD:4
.= ( ( ( card IF ) + 1 ) + 1 ) by SCMP_GCD:4
.= ( ( ( ( ( card j1 ) + ( card j2 ) ) + 2 ) + 1 ) + 1 ) by SCMPDS_6:65
.= ( ( ( ( 1 + ( card j2 ) ) + 2 ) + 1 ) + 1 ) by COMPOS_1:54
.= ( ( ( ( 1 + 1 ) + 2 ) + 1 ) + 1 ) by COMPOS_1:54
.= 6;
end;
Lm14: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (( s . ( GBP ) ) = ( 0 ) implies ((((( s . a3 ) > ( 0 ) implies (( ( IExec (WB,P,s) ) . a1 ) = ( ( s . a1 ) - ( s . a2 ) ) & ( ( IExec (WB,P,s) ) . a2 ) = ( s . a2 ))) & (( s . a3 ) <= ( 0 ) implies (( ( IExec (WB,P,s) ) . a2 ) = ( ( s . a2 ) - ( s . a1 ) ) & ( ( IExec (WB,P,s) ) . a1 ) = ( s . a1 )))) & ( ( IExec (WB,P,s) ) . ( GBP ) ) = ( 0 )) & ( ( IExec (WB,P,s) ) . a3 ) = ( ( ( IExec (WB,P,s) ) . a1 ) - ( ( IExec (WB,P,s) ) . a2 ) ))))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
set s1 = ( IExec (IF,P,s) );
set s2 = ( IExec (( IF ';' k1 ),P,s) );
set a = ( GBP );
set t0 = s;
set Q0 = P;
A4:now
assume A5: ( s1 . ( GBP ) ) = ( 0 );
then A6: ( DataLoc (( s1 . a ),3) ) = ( intpos ( ( 0 ) + 3 ) ) by SCMP_GCD:1;
A7: ( s2 . a3 ) = ( ( Exec (k1,s1) ) . a3 ) by SCMPDS_5:41
.= ( s1 . ( DataLoc (( s1 . a ),1) ) ) by A6,SCMPDS_2:47
.= ( s1 . ( intpos ( ( 0 ) + 1 ) ) ) by A5,SCMP_GCD:1;
1 <> ( abs ( ( s1 . ( GBP ) ) + 3 ) ) by A5,ABSVALUE:def 1;
then A8: a1 <> ( DataLoc (( s1 . ( GBP ) ),3) ) by ZFMISC_1:27;
A9: ( s2 . a1 ) = ( ( Exec (k1,s1) ) . a1 ) by SCMPDS_5:41
.= ( s1 . a1 ) by A8,SCMPDS_2:47;
2 <> ( abs ( ( s1 . ( GBP ) ) + 3 ) ) by A5,ABSVALUE:def 1;
then A10: a2 <> ( DataLoc (( s1 . ( GBP ) ),3) ) by ZFMISC_1:27;
A11: ( s2 . a2 ) = ( ( Exec (k1,s1) ) . a2 ) by SCMPDS_5:41
.= ( s1 . a2 ) by A10,SCMPDS_2:47;
( 0 ) <> ( abs ( ( s1 . ( GBP ) ) + 3 ) ) by A5,ABSVALUE:def 1;
then A12: a <> ( DataLoc (( s1 . ( GBP ) ),3) ) by ZFMISC_1:27;
A13: ( s2 . a ) = ( ( Exec (k1,s1) ) . a ) by SCMPDS_5:41
.= ( 0 ) by A5,A12,SCMPDS_2:47;
then A14: ( DataLoc (( s2 . a ),3) ) = ( intpos ( ( 0 ) + 3 ) ) by SCMP_GCD:1;
( 0 ) <> ( abs ( ( s2 . ( GBP ) ) + 3 ) ) by A13,ABSVALUE:def 1;
then A15: a <> ( DataLoc (( s2 . ( GBP ) ),3) ) by ZFMISC_1:27;
thus ( ( IExec (WB,P,s) ) . a ) = ( ( Exec (k2,s2) ) . a ) by SCMPDS_5:41
.= ( 0 ) by A13,A15,SCMPDS_2:50;
1 <> ( abs ( ( s2 . ( GBP ) ) + 3 ) ) by A13,ABSVALUE:def 1;
then A16: a1 <> ( DataLoc (( s2 . ( GBP ) ),3) ) by ZFMISC_1:27;
thus A17: ( ( IExec (WB,P,s) ) . a1 ) = ( ( Exec (k2,s2) ) . a1 ) by SCMPDS_5:41
.= ( s1 . a1 ) by A9,A16,SCMPDS_2:50;
2 <> ( abs ( ( s2 . ( GBP ) ) + 3 ) ) by A13,ABSVALUE:def 1;
then A18: a2 <> ( DataLoc (( s2 . ( GBP ) ),3) ) by ZFMISC_1:27;
thus A19: ( ( IExec (WB,P,s) ) . a2 ) = ( ( Exec (k2,s2) ) . a2 ) by SCMPDS_5:41
.= ( s1 . a2 ) by A11,A18,SCMPDS_2:50;
thus ( ( IExec (WB,P,s) ) . a3 ) = ( ( Exec (k2,s2) ) . a3 ) by SCMPDS_5:41
.= ( ( s2 . a3 ) - ( s2 . ( DataLoc (( s2 . a ),2) ) ) ) by A14,SCMPDS_2:50
.= ( ( ( IExec (WB,P,s) ) . a1 ) - ( ( IExec (WB,P,s) ) . a2 ) ) by A13,A11,A7,A17,A19,SCMP_GCD:1;
end;
set s0 = s;
set m1 = ( SubFrom (( GBP ),1,( GBP ),2) );
set m2 = ( SubFrom (( GBP ),2,( GBP ),1) );
assume A20: ( s . ( GBP ) ) = ( 0 );
then A21: ( s0 . a ) = ( 0 );
A22: ( DataLoc (( s . a ),3) ) = ( intpos ( ( 0 ) + 3 ) ) by A20,SCMP_GCD:1;
A24:now
2 <> ( abs ( ( s0 . ( GBP ) ) + 1 ) ) by A21,ABSVALUE:def 1;
then A25: a2 <> ( DataLoc (( s0 . ( GBP ) ),1) ) by ZFMISC_1:27;
( 0 ) <> ( abs ( ( s0 . ( GBP ) ) + 1 ) ) by A21,ABSVALUE:def 1;
then A26: a <> ( DataLoc (( s0 . ( GBP ) ),1) ) by ZFMISC_1:27;
assume A27: ( s . a3 ) > ( 0 );
hence ( s1 . a ) = ( ( IExec (j1,P,s) ) . a ) by A22,SCMPDS_6:73
.= ( ( Exec (m1,s0) ) . a ) by SCMPDS_5:40
.= ( 0 ) by A21,A26,SCMPDS_2:50;
A28: ( DataLoc (( s0 . a ),1) ) = ( intpos ( ( 0 ) + 1 ) ) by A21,SCMP_GCD:1;
thus ( s1 . a1 ) = ( ( IExec (j1,P,s) ) . a1 ) by A22,A27,SCMPDS_6:73
.= ( ( Exec (m1,s0) ) . a1 ) by SCMPDS_5:40
.= ( ( s0 . a1 ) - ( s0 . ( DataLoc (( s0 . a ),2) ) ) ) by A28,SCMPDS_2:50
.= ( ( s0 . a1 ) - ( s0 . ( intpos ( ( 0 ) + 2 ) ) ) ) by A21,SCMP_GCD:1
.= ( ( s . a1 ) - ( s . a2 ) );
thus ( s1 . a2 ) = ( ( IExec (j1,P,s) ) . a2 ) by A22,A27,SCMPDS_6:73
.= ( ( Exec (m1,s0) ) . a2 ) by SCMPDS_5:40
.= ( s . a2 ) by A25,SCMPDS_2:50;
end;
hence (( s . a3 ) > ( 0 ) implies (( ( IExec (WB,P,s) ) . a1 ) = ( ( s . a1 ) - ( s . a2 ) ) & ( ( IExec (WB,P,s) ) . a2 ) = ( s . a2 ))) by A4;
A30:now
1 <> ( abs ( ( s0 . ( GBP ) ) + 2 ) ) by A21,ABSVALUE:def 1;
then A31: a1 <> ( DataLoc (( s0 . ( GBP ) ),2) ) by ZFMISC_1:27;
( 0 ) <> ( abs ( ( s0 . ( GBP ) ) + 2 ) ) by A21,ABSVALUE:def 1;
then A32: a <> ( DataLoc (( s0 . ( GBP ) ),2) ) by ZFMISC_1:27;
assume A33: ( s . a3 ) <= ( 0 );
hence ( s1 . a ) = ( ( IExec (j2,P,s) ) . a ) by A22,SCMPDS_6:74
.= ( ( Exec (m2,s0) ) . a ) by SCMPDS_5:40
.= ( 0 ) by A21,A32,SCMPDS_2:50;
A34: ( DataLoc (( s0 . a ),2) ) = ( intpos ( ( 0 ) + 2 ) ) by A21,SCMP_GCD:1;
thus ( s1 . a2 ) = ( ( IExec (j2,P,s) ) . a2 ) by A22,A33,SCMPDS_6:74
.= ( ( Exec (m2,s0) ) . a2 ) by SCMPDS_5:40
.= ( ( s0 . a2 ) - ( s0 . ( DataLoc (( s0 . a ),1) ) ) ) by A34,SCMPDS_2:50
.= ( ( s0 . a2 ) - ( s0 . ( intpos ( ( 0 ) + 1 ) ) ) ) by A21,SCMP_GCD:1
.= ( ( s . a2 ) - ( s . a1 ) );
thus ( s1 . a1 ) = ( ( IExec (j2,P,s) ) . a1 ) by A22,A33,SCMPDS_6:74
.= ( ( Exec (m2,s0) ) . a1 ) by SCMPDS_5:40
.= ( s . a1 ) by A31,SCMPDS_2:50;
end;
hence (( s . a3 ) <= ( 0 ) implies (( ( IExec (WB,P,s) ) . a2 ) = ( ( s . a2 ) - ( s . a1 ) ) & ( ( IExec (WB,P,s) ) . a1 ) = ( s . a1 ))) by A4;
now
per cases ;
suppose ( s . a3 ) > ( 0 );

hence ( s1 . a ) = ( 0 ) by A24;
end;
suppose ( s . a3 ) <= ( 0 );

hence ( s1 . a ) = ( 0 ) by A30;
end;
end;
hence thesis by A4;
end;
Lm15: (for s being ( 0 ) -started (State of ( SCMPDS )) holds ((((( s . ( GBP ) ) = ( 0 ) & ( s . a1 ) > ( 0 )) & ( s . a2 ) > ( 0 )) & ( s . a3 ) = ( ( s . a1 ) - ( s . a2 ) )) implies (((( ( IExec (WH,P,s) ) . a1 ) = ( ( s . a1 ) gcd ( s . a2 ) ) & ( ( IExec (WH,P,s) ) . a2 ) = ( ( s . a1 ) gcd ( s . a2 ) )) & WH is_closed_on s,P) & WH is_halting_on s,P)))
proof
set a = ( GBP );
let s being ( 0 ) -started (State of ( SCMPDS ));
A1: ( DataLoc (( 0 ),3) ) = ( intpos ( ( 0 ) + 3 ) ) by SCMP_GCD:1;
A2:now
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
assume that
( t . a1 ) > ( 0 )
and
( t . a2 ) > ( 0 )
and
A3: ( t . a ) = ( 0 )
and
A4: ( t . ( DataLoc (( 0 ),3) ) ) = ( ( t . a1 ) - ( t . a2 ) )
and
( t . a1 ) <> ( t . a2 );
thus ( ( IExec (WB,Q,t) ) . a ) = ( 0 ) by A3,Lm14;
thus WB is_closed_on t,Q by SCMPDS_6:20;
thus WB is_halting_on t,Q by SCMPDS_6:21;
hereby
assume ( t . a1 ) > ( t . a2 );
then ( t . a3 ) > ( 0 ) by A1,A4,XREAL_1:50;
hence (( ( IExec (WB,Q,t) ) . a1 ) = ( ( t . a1 ) - ( t . a2 ) ) & ( ( IExec (WB,Q,t) ) . a2 ) = ( t . a2 )) by A3,Lm14;
end;
hereby
assume ( t . a1 ) <= ( t . a2 );
then ( t . a3 ) <= ( 0 ) by A1,A4,XREAL_1:47;
hence (( ( IExec (WB,Q,t) ) . a2 ) = ( ( t . a2 ) - ( t . a1 ) ) & ( ( IExec (WB,Q,t) ) . a1 ) = ( t . a1 )) by A3,Lm14;
end;
thus ( ( IExec (WB,Q,t) ) . ( DataLoc (( 0 ),3) ) ) = ( ( ( IExec (WB,Q,t) ) . a1 ) - ( ( IExec (WB,Q,t) ) . a2 ) ) by A1,A3,Lm14;
end;
assume A5: (((( s . a ) = ( 0 ) & ( s . a1 ) > ( 0 )) & ( s . a2 ) > ( 0 )) & ( s . a3 ) = ( ( s . a1 ) - ( s . a2 ) ));
hence (( ( IExec (WH,P,s) ) . a1 ) = ( ( s . a1 ) gcd ( s . a2 ) ) & ( ( IExec (WH,P,s) ) . a2 ) = ( ( s . a1 ) gcd ( s . a2 ) )) by A1,A2,CKB32:1;
thus (WH is_closed_on s,P & WH is_halting_on s,P) by A5,A1,A2,Lm12,CKB30:1;
end;
set GA = ( ( ( i1 ';' i2 ) ';' i3 ) ';' WH );
Lm16: (for s being ( 0 ) -started (State of ( SCMPDS )) holds ((( s . a1 ) > ( 0 ) & ( s . a2 ) > ( 0 )) implies (((( ( IExec (GA,P,s) ) . a1 ) = ( ( s . a1 ) gcd ( s . a2 ) ) & ( ( IExec (GA,P,s) ) . a2 ) = ( ( s . a1 ) gcd ( s . a2 ) )) & GA is_closed_on s,P) & GA is_halting_on s,P)))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
I: ( Initialize s ) = s by MEMSTR_0:44;
assume A1: (( s . a1 ) > ( 0 ) & ( s . a2 ) > ( 0 ));
set t0 = s;
set Q0 = P;
set t1 = ( IExec (( ( i1 ';' i2 ) ';' i3 ),P,s) );
set t2 = ( IExec (( i1 ';' i2 ),P,s) );
set Q1 = P;
set t3 = ( Exec (i1,t0) );
set a = ( GBP );
A5: ( t3 . a1 ) = ( t0 . a1 ) by AMI_3:10,SCMPDS_2:45
.= ( s . a1 );
A6: ( t3 . a ) = ( 0 ) by SCMPDS_2:45;
then A7: ( DataLoc (( t3 . a ),3) ) = ( intpos ( ( 0 ) + 3 ) ) by SCMP_GCD:1;
1 <> ( abs ( ( t3 . ( GBP ) ) + 3 ) ) by A6,ABSVALUE:def 1;
then A8: a1 <> ( DataLoc (( t3 . ( GBP ) ),3) ) by ZFMISC_1:27;
A9: ( t2 . a1 ) = ( ( Exec (i2,t3) ) . a1 ) by SCMPDS_5:42
.= ( s . a1 ) by A5,A8,SCMPDS_2:47;
A10: ( t3 . a2 ) = ( t0 . a2 ) by AMI_3:10,SCMPDS_2:45
.= ( s . a2 );
A11: ( t2 . a3 ) = ( ( Exec (i2,t3) ) . a3 ) by SCMPDS_5:42
.= ( t3 . ( DataLoc (( t3 . a ),1) ) ) by A7,SCMPDS_2:47
.= ( s . a1 ) by A6,A5,SCMP_GCD:1;
2 <> ( abs ( ( t3 . ( GBP ) ) + 3 ) ) by A6,ABSVALUE:def 1;
then A12: a2 <> ( DataLoc (( t3 . ( GBP ) ),3) ) by ZFMISC_1:27;
A13: ( t2 . a2 ) = ( ( Exec (i2,t3) ) . a2 ) by SCMPDS_5:42
.= ( s . a2 ) by A10,A12,SCMPDS_2:47;
( 0 ) <> ( abs ( ( t3 . ( GBP ) ) + 3 ) ) by A6,ABSVALUE:def 1;
then A14: a <> ( DataLoc (( t3 . ( GBP ) ),3) ) by ZFMISC_1:27;
A15: ( t2 . a ) = ( ( Exec (i2,t3) ) . a ) by SCMPDS_5:42
.= ( 0 ) by A6,A14,SCMPDS_2:47;
then A16: ( DataLoc (( t2 . a ),3) ) = ( intpos ( ( 0 ) + 3 ) ) by SCMP_GCD:1;
( 0 ) <> ( abs ( ( t2 . ( GBP ) ) + 3 ) ) by A15,ABSVALUE:def 1;
then A17: a <> ( DataLoc (( t2 . ( GBP ) ),3) ) by ZFMISC_1:27;
A18: ( t1 . a ) = ( ( Exec (i3,t2) ) . a ) by SCMPDS_5:41
.= ( 0 ) by A15,A17,SCMPDS_2:50;
1 <> ( abs ( ( t2 . ( GBP ) ) + 3 ) ) by A15,ABSVALUE:def 1;
then A19: a1 <> ( DataLoc (( t2 . ( GBP ) ),3) ) by ZFMISC_1:27;
A20: ( t1 . a1 ) = ( ( Exec (i3,t2) ) . a1 ) by SCMPDS_5:41
.= ( s . a1 ) by A9,A19,SCMPDS_2:50;
2 <> ( abs ( ( t2 . ( GBP ) ) + 3 ) ) by A15,ABSVALUE:def 1;
then A21: a2 <> ( DataLoc (( t2 . ( GBP ) ),3) ) by ZFMISC_1:27;
A22: ( t1 . a2 ) = ( ( Exec (i3,t2) ) . a2 ) by SCMPDS_5:41
.= ( s . a2 ) by A13,A21,SCMPDS_2:50;
X1: ( ( Initialize t1 ) . a1 ) = ( t1 . a1 ) by SCMPDS_5:15;
X2: ( ( Initialize t1 ) . a2 ) = ( t1 . a2 ) by SCMPDS_5:15;
A23: ( t1 . a3 ) = ( ( Exec (i3,t2) ) . a3 ) by SCMPDS_5:41
.= ( ( t2 . a3 ) - ( t2 . ( DataLoc (( t2 . a ),2) ) ) ) by A16,SCMPDS_2:50
.= ( ( t1 . a1 ) - ( t1 . a2 ) ) by A15,A13,A11,A20,A22,SCMP_GCD:1;
X0: ( ( Initialize t1 ) . ( GBP ) ) = ( t1 . ( GBP ) ) by SCMPDS_5:15;
X3: ( ( Initialize t1 ) . a3 ) = ( t1 . a3 ) by SCMPDS_5:15;
B25: (WH is_closed_on ( Initialize t1 ),P & WH is_halting_on ( Initialize t1 ),P) by A1,A18,A20,A22,Lm15,X1,X2,A23,X0,X3;
A24: WH is_closed_on t1,Q1
proof
(for k being (Element of ( NAT )) holds ( IC ( Comput (( Q1 +* ( stop WH ) ),( Initialize ( Initialize t1 ) ),k) ) ) in ( dom ( stop WH ) )) by B25,SCMPDS_6:def 2;
hence thesis by SCMPDS_6:def 2;
end;
A25: WH is_halting_on t1,Q1
proof
( Q1 +* ( stop WH ) ) halts_on ( Initialize ( Initialize t1 ) ) by B25,SCMPDS_6:def 3;
hence thesis by SCMPDS_6:def 3;
end;
( ( IExec (WH,Q1,( Initialize t1 )) ) . a1 ) = ( ( t1 . a1 ) gcd ( t1 . a2 ) ) by A1,A18,A20,A22,A23,Lm15,X1,X2,X3,X0;
hence ( ( IExec (GA,P,s) ) . a1 ) = ( ( s . a1 ) gcd ( s . a2 ) ) by A20,A22,A24,A25,SCPISORT:7;
( ( IExec (WH,Q1,( Initialize t1 )) ) . a2 ) = ( ( t1 . a1 ) gcd ( t1 . a2 ) ) by A1,A18,A20,A22,A23,Lm15,X1,X2,X3,X0;
hence ( ( IExec (GA,P,s) ) . a2 ) = ( ( s . a1 ) gcd ( s . a2 ) ) by A20,A22,A24,A25,SCPISORT:7;
thus thesis by A24,I,A25,SCPISORT:9;
end;
theorem
(for s being ( 0 ) -started (State of ( SCMPDS )) holds (for x,y being Integer holds ((((( s . ( intpos 1 ) ) = x & ( s . ( intpos 2 ) ) = y) & x > ( 0 )) & y > ( 0 )) implies (((( ( IExec (( GCD-Algorithm ),P,s) ) . ( intpos 1 ) ) = ( x gcd y ) & ( ( IExec (( GCD-Algorithm ),P,s) ) . ( intpos 2 ) ) = ( x gcd y )) & ( GCD-Algorithm ) is_closed_on s,P) & ( GCD-Algorithm ) is_halting_on s,P)))) by Lm16;
