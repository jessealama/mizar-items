environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMPDS_2,TURING_1,FUNCT_1,CARD_1,SCMFSA_7,RELAT_1,ARYTM_3,CARD_3,FSM_1,XXREAL_0,COMPLEX1,ARYTM_1,AMI_2,SCMPDS_5,SCMPDS_4,INT_1,SCMPDS_8,SCMFSA6B,SCMFSA_9,UNIALG_2,SCMFSA7B,SCMP_GCD,SEMI_AF1,GRAPHSP,AMI_3,FINSEQ_1,SCPISORT,NAT_1,ORDINAL4,SFMASTR2,PRE_FF,FUNCT_4,CIRCUIT2,TARSKI,PBOOLE,MSUALG_1,STRUCT_0,VALUED_1,SCMFSA8B,INT_2,SCPINVAR,ORDINAL1,PARTFUN1,SCMNORM,SCMFSA6C,COMPOS_1;
notations XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,PARTFUN1,VALUED_1,XCMPLX_0,FUNCT_4,PBOOLE,INT_1,INT_2,NAT_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,SCMPDS_2,SCMPDS_4,SCMPDS_6,SCMP_GCD,SCMPDS_5,SCMPDS_8,FUNCT_2,CARD_3,DOMAIN_1,FINSEQ_1,GR_CY_1,PRE_FF,SCPISORT,XXREAL_0,CKB5,CKB6;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,AMI_3,SCMPDS_2,SCMP_GCD,SCPISORT,MEMSTR_0,CKB5;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,INT_1,SCMPDS_2,ABSVALUE,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,ENUMSET1,INT_2,SCMPDS_8,SCMP_GCD,SCMPDS_7,FUNCT_1,FINSEQ_1,RVSUM_1,FINSEQ_2,MEMSTR_0,PRE_FF,SCPISORT,XBOOLE_1,XREAL_1,COMPLEX1,XXREAL_0,PREPOWER,ORDINAL1,FUNCOP_1,ZFMISC_1,NAT_D,FINSEQ_3,PBOOLE,PARTFUN1,AFINSQ_1,COMPOS_1,EXTPRO_1,CARD_3,CKB1,CKB2,CKB3,CKB5;
schemes NAT_1,SCMPDS_8,FUNCT_2,CKB4;
registrations SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,CARD_3,STRUCT_0,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,XBOOLE_0,FINSEQ_1,CARD_1,VALUED_1,VALUED_0,MEMSTR_0,RELAT_1,FUNCT_2,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,FUNCT_4;
constructors DOMAIN_1,REAL_1,NAT_D,RECDEF_1,PRE_FF,MESFUNC1,GR_CY_1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,BINOP_2,AMI_2,MEMSTR_0,RELSET_1,CKB5,CKB6;
requirements NUMERALS,REAL,SUBSET,ARITHM,BOOLE;
begin
reserve n for (Element of ( NAT ));
reserve i for (Instruction of ( SCMPDS ));
reserve I for (Program of ( SCMPDS ));
reserve a for Int_position;
reserve Q for (Instruction-Sequence of ( SCMPDS ));
reserve P for (Instruction-Sequence of ( SCMPDS ));
theorem
Th8: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (for I being  halt-free  shiftable (Program of ( SCMPDS )) holds (for a,b,c being Int_position holds (for n,i,p0 being (Element of ( NAT )) holds (for f being (FinSequence of ( INT )) holds (((((((f is_FinSequence_on s,p0 & ( len f ) = n) & ( s . b ) = ( 0 )) & ( s . a ) = ( 0 )) & ( s . ( intpos i ) ) = ( - n )) & ( s . c ) = ( p0 + 1 )) & (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((((ex g being (FinSequence of ( INT )) st (((g is_FinSequence_on s,p0 & ( len g ) = ( ( t . ( intpos i ) ) + n )) & ( t . b ) = ( Sum g )) & ( t . c ) = ( ( p0 + 1 ) + ( len g ) ))) & ( t . a ) = ( 0 )) & ( t . ( intpos i ) ) < ( 0 )) & (for i being (Element of ( NAT )) holds (i > p0 implies ( t . ( intpos i ) ) = ( s . ( intpos i ) )))) implies (((((( ( IExec (I,Q,t) ) . a ) = ( 0 ) & I is_closed_on t,Q) & I is_halting_on t,Q) & ( ( IExec (I,Q,t) ) . ( intpos i ) ) = ( ( t . ( intpos i ) ) + 1 )) & (ex g being (FinSequence of ( INT )) st (((g is_FinSequence_on s,p0 & ( len g ) = ( ( ( t . ( intpos i ) ) + n ) + 1 )) & ( ( IExec (I,Q,t) ) . c ) = ( ( p0 + 1 ) + ( len g ) )) & ( ( IExec (I,Q,t) ) . b ) = ( Sum g )))) & (for i being (Element of ( NAT )) holds (i > p0 implies ( ( IExec (I,Q,t) ) . ( intpos i ) ) = ( s . ( intpos i ) )))))))) implies ((( ( IExec (( while<0 (a,i,I) ),P,s) ) . b ) = ( Sum f ) & ( while<0 (a,i,I) ) is_closed_on s,P) & ( while<0 (a,i,I) ) is_halting_on s,P)))))))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
let I being  halt-free  shiftable (Program of ( SCMPDS ));
let a being Int_position;
let b being Int_position;
let c being Int_position;
let n being (Element of ( NAT ));
let i being (Element of ( NAT ));
let p0 being (Element of ( NAT ));
let f being (FinSequence of ( INT ));
set Iw = ( IExec (( while<0 (a,i,I) ),P,s) );
set Dw = ( Initialize Iw );
set da = ( DataLoc (( s . a ),i) );
defpred P[ (State of ( SCMPDS )) ]
 means
((for i being (Element of ( NAT )) holds (i > p0 implies ( $1 . ( intpos i ) ) = ( s . ( intpos i ) ))) & (ex g being (FinSequence of ( INT )) st ((((g is_FinSequence_on s,p0 & ( len g ) = ( ( $1 . ( intpos i ) ) + n )) & ( $1 . b ) = ( Sum g )) & ( $1 . ( intpos i ) ) <= ( 0 )) & ( $1 . c ) = ( ( p0 + 1 ) + ( len g ) ))));
assume that
A2: f is_FinSequence_on s,p0
and
A3: ( len f ) = n
and
A4: ( s . b ) = ( 0 )
and
A5: ( s . a ) = ( 0 )
and
A6: ( s . ( intpos i ) ) = ( - n )
and
A7: ( s . c ) = ( p0 + 1 );
consider ff being (Function of ( product (the Object-Kind of ( SCMPDS )) ),( NAT )) such that A8: (for t being (State of ( SCMPDS )) holds ((( t . da ) >= ( 0 ) implies ( ff . t ) = ( 0 )) & (( t . da ) < ( 0 ) implies ( ff . t ) = ( - ( t . da ) )))) by CKB3:1;
deffunc F((State of ( SCMPDS ))) = ( ff . $1 );
assume A9: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((((ex g being (FinSequence of ( INT )) st (((g is_FinSequence_on s,p0 & ( len g ) = ( ( t . ( intpos i ) ) + n )) & ( t . b ) = ( Sum g )) & ( t . c ) = ( ( p0 + 1 ) + ( len g ) ))) & ( t . a ) = ( 0 )) & ( t . ( intpos i ) ) < ( 0 )) & (for i being (Element of ( NAT )) holds (i > p0 implies ( t . ( intpos i ) ) = ( s . ( intpos i ) )))) implies (((((( ( IExec (I,Q,t) ) . a ) = ( 0 ) & I is_closed_on t,Q) & I is_halting_on t,Q) & ( ( IExec (I,Q,t) ) . ( intpos i ) ) = ( ( t . ( intpos i ) ) + 1 )) & (ex g being (FinSequence of ( INT )) st (((g is_FinSequence_on s,p0 & ( len g ) = ( ( ( t . ( intpos i ) ) + n ) + 1 )) & ( ( IExec (I,Q,t) ) . c ) = ( ( p0 + 1 ) + ( len g ) )) & ( ( IExec (I,Q,t) ) . b ) = ( Sum g )))) & (for i being (Element of ( NAT )) holds (i > p0 implies ( ( IExec (I,Q,t) ) . ( intpos i ) ) = ( s . ( intpos i ) )))))));
A10: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (P[ t ] implies (((F(t) = ( 0 ) & ( t . da ) < ( 0 )) implies contradiction) & (( t . da ) >= ( 0 ) implies F(t) = ( 0 )))))
proof
let t being ( 0 ) -started (State of ( SCMPDS ));
assume P[ t ];
hereby
assume A11: F(t) = ( 0 );
assume A12: ( t . da ) < ( 0 );
then ( t . da ) < ( 0 );
then F(t) = ( - ( t . da ) ) by A8;
hence contradiction by A11,A12;
end;
assume ( t . da ) >= ( 0 );
then ( t . da ) >= ( 0 );
hence F(t) = ( 0 ) by A8;
end;
A13:now
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
assume that
A14: P[ t ]
and
A15: ( t . a ) = ( s . a )
and
A16: ( t . ( DataLoc (( s . a ),i) ) ) < ( 0 );
consider h being (FinSequence of ( INT )) such that A17: h is_FinSequence_on s,p0 and A18: (( len h ) = ( ( t . ( intpos i ) ) + n ) & ( t . b ) = ( Sum h )) and A19: ( t . c ) = ( ( p0 + 1 ) + ( len h ) ) by A14;
A20: ( t . c ) = ( ( p0 + 1 ) + ( len h ) ) by A19;
set It = ( IExec (I,Q,t) );
set Dit = ( Initialize It );
A21: (for i being (Element of ( NAT )) holds (i > p0 implies ( t . ( intpos i ) ) = ( s . ( intpos i ) ))) by A14;
A23: ( intpos ( ( 0 ) + i ) ) = da by A5,SCMP_GCD:1;
A24: (( len h ) = ( ( t . ( intpos i ) ) + n ) & ( t . b ) = ( Sum h )) by A18;
hence ( ( IExec (I,Q,t) ) . a ) = ( t . a ) by A5,A9,A15,A16,A21,A17,A20,A23;
consider g being (FinSequence of ( INT )) such that A25: g is_FinSequence_on s,p0 and A26: ( len g ) = ( ( ( t . ( intpos i ) ) + n ) + 1 ) and A27: ( ( IExec (I,Q,t) ) . c ) = ( ( p0 + 1 ) + ( len g ) ) and A28: ( ( IExec (I,Q,t) ) . b ) = ( Sum g ) by A5,A9,A15,A16,A21,A17,A24,A20,A23;
thus (I is_closed_on t,Q & I is_halting_on t,Q) by A5,A9,A15,A16,A21,A17,A24,A20,A23;
A29: ( It . ( intpos i ) ) = ( ( t . ( intpos i ) ) + 1 ) by A5,A9,A15,A16,A21,A17,A24,A20,A23;
hereby
per cases ;
suppose ( It . ( intpos i ) ) >= ( 0 );

then ( Dit . da ) >= ( 0 ) by A23,SCMPDS_5:15;
then A30: F(Dit) = ( 0 ) by A8;
F(t) <> ( 0 ) by A10,A14,A16;
hence F(Dit) < F(t) by A30,NAT_1:3;
end;
suppose A31: ( It . ( intpos i ) ) < ( 0 );

( t . da ) < ( 0 ) by A16;
then A32: F(t) = ( - ( t . da ) ) by A8
.= ( - ( t . ( intpos i ) ) ) by A23;
( Dit . da ) < ( 0 ) by A23,A31,SCMPDS_5:15;
then F(Dit) = ( - ( Dit . da ) ) by A8
.= ( - ( ( t . ( intpos i ) ) + 1 ) ) by A23,A29,SCMPDS_5:15
.= ( ( - ( t . ( intpos i ) ) ) - 1 );
hence F(Dit) < F(t) by A32,XREAL_1:146;
end;
end;
thus P[ ( Initialize ( IExec (I,Q,t) ) ) ]
proof
hereby
let i being (Element of ( NAT ));
assume A33: i > p0;
thus ( Dit . ( intpos i ) ) = ( It . ( intpos i ) ) by SCMPDS_5:15
.= ( s . ( intpos i ) ) by A5,A9,A15,A16,A21,A17,A24,A20,A23,A33;
end;
take g;
thus g is_FinSequence_on s,p0 by A25;
thus ( len g ) = ( ( ( IExec (I,Q,t) ) . ( intpos i ) ) + n ) by A29,A26
.= ( ( Dit . ( intpos i ) ) + n ) by SCMPDS_5:15;
thus ( Dit . b ) = ( Sum g ) by A28,SCMPDS_5:15;
( Dit . ( intpos i ) ) = ( ( t . ( intpos i ) ) + 1 ) by A29,SCMPDS_5:15;
hence ( Dit . ( intpos i ) ) <= ( 0 ) by A16,A23,INT_1:7;
thus thesis by A27,SCMPDS_5:15;
end;

end;
A34: P[ s ]
proof
thus (for i being (Element of ( NAT )) holds (i > p0 implies ( s . ( intpos i ) ) = ( s . ( intpos i ) )));
consider h being (FinSequence of ( INT )) such that A35: ( len h ) = ( 0 ) and A36: h is_FinSequence_on s,p0 by SCPISORT:2;
take h;
thus h is_FinSequence_on s,p0 by A36;
thus ( len h ) = ( ( s . ( intpos i ) ) + n ) by A6,A35
.= ( ( s . ( intpos i ) ) + n );
h = ( <*> ( REAL ) ) by A35;
hence ( s . b ) = ( Sum h ) by A4,RVSUM_1:72;
thus ( s . ( intpos i ) ) <= ( 0 ) by A6;
thus thesis by A7,A35;
end;
A37: (F(Dw) = ( 0 ) & P[ Dw ]) from CKB4:sch 1(A10,A34,A13);
then consider g being (FinSequence of ( INT )) such that A38: g is_FinSequence_on s,p0 and A39: ( len g ) = ( ( Dw . ( intpos i ) ) + n ) and A40: ( Dw . b ) = ( Sum g ) and A41: ( Dw . ( intpos i ) ) <= ( 0 );
XX: ( Dw . ( intpos i ) ) = ( Iw . ( intpos ( ( 0 ) + i ) ) ) by SCMPDS_5:15
.= ( Iw . da ) by A5,SCMP_GCD:1;
( Iw . da ) = ( Dw . da ) by SCMPDS_5:15;
then ( Dw . ( intpos i ) ) >= ( 0 ) by A10,A37,XX;
then A42: ( Dw . ( intpos i ) ) = ( 0 ) by A41,XXREAL_0:1;
now
let i being Nat;
reconsider a = i as (Element of ( NAT )) by ORDINAL1:def 12;
assume i in ( dom f );
then A43: (1 <= i & i <= n) by A3,FINSEQ_3:25;
hence ( f . i ) = ( s . ( intpos ( p0 + a ) ) ) by A2,A3,SCPISORT:def 1
.= ( g . i ) by A38,A39,A42,A43,SCPISORT:def 1;
end;
then f = g by A3,A39,A42,FINSEQ_2:9;
hence ( Iw . b ) = ( Sum f ) by A40,SCMPDS_5:15;
A44: (for t being ( 0 ) -started (State of ( SCMPDS )) holds ((P[ t ] & F(t) = ( 0 )) implies ( t . da ) >= ( 0 ))) by A10;
(( while<0 (a,i,I) ) is_closed_on s,P & ( while<0 (a,i,I) ) is_halting_on s,P) from SCMPDS_8:sch 1(A44,A34,A13);
hence thesis;
end;
