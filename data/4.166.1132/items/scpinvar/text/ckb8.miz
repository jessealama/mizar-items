environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMPDS_2,TURING_1,FUNCT_1,CARD_1,SCMFSA_7,RELAT_1,ARYTM_3,CARD_3,FSM_1,XXREAL_0,COMPLEX1,ARYTM_1,AMI_2,SCMPDS_5,SCMPDS_4,INT_1,SCMPDS_8,SCMFSA6B,SCMFSA_9,UNIALG_2,SCMFSA7B,SCMP_GCD,SEMI_AF1,GRAPHSP,AMI_3,FINSEQ_1,SCPISORT,NAT_1,ORDINAL4,SFMASTR2,PRE_FF,FUNCT_4,CIRCUIT2,TARSKI,PBOOLE,MSUALG_1,STRUCT_0,VALUED_1,SCMFSA8B,INT_2,SCPINVAR,ORDINAL1,PARTFUN1,SCMNORM,SCMFSA6C,COMPOS_1;
notations XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,PARTFUN1,VALUED_1,XCMPLX_0,FUNCT_4,PBOOLE,INT_1,INT_2,NAT_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,SCMPDS_2,SCMPDS_4,SCMPDS_6,SCMP_GCD,SCMPDS_5,SCMPDS_8,FUNCT_2,CARD_3,DOMAIN_1,FINSEQ_1,GR_CY_1,PRE_FF,SCPISORT,XXREAL_0,CKB5,CKB6;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,AMI_3,SCMPDS_2,SCMP_GCD,SCPISORT,MEMSTR_0,CKB5;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,INT_1,SCMPDS_2,ABSVALUE,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,ENUMSET1,INT_2,SCMPDS_8,SCMP_GCD,SCMPDS_7,FUNCT_1,FINSEQ_1,RVSUM_1,FINSEQ_2,MEMSTR_0,PRE_FF,SCPISORT,XBOOLE_1,XREAL_1,COMPLEX1,XXREAL_0,PREPOWER,ORDINAL1,FUNCOP_1,ZFMISC_1,NAT_D,FINSEQ_3,PBOOLE,PARTFUN1,AFINSQ_1,COMPOS_1,EXTPRO_1,CARD_3,CKB1,CKB2,CKB3,CKB5,CKB7;
schemes NAT_1,SCMPDS_8,FUNCT_2,CKB4;
registrations SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,CARD_3,STRUCT_0,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,XBOOLE_0,FINSEQ_1,CARD_1,VALUED_1,VALUED_0,MEMSTR_0,RELAT_1,FUNCT_2,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,FUNCT_4;
constructors DOMAIN_1,REAL_1,NAT_D,RECDEF_1,PRE_FF,MESFUNC1,GR_CY_1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,BINOP_2,AMI_2,MEMSTR_0,RELSET_1,CKB5,CKB6;
requirements NUMERALS,REAL,SUBSET,ARITHM,BOOLE;
begin
reserve m for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
reserve i for (Instruction of ( SCMPDS ));
reserve Q for (Instruction-Sequence of ( SCMPDS ));
reserve P for (Instruction-Sequence of ( SCMPDS ));
set a1 = ( intpos 1 );
set a2 = ( intpos 2 );
set a3 = ( intpos 3 );
set j1 = ( AddTo (( GBP ),1,a3,( 0 )) );
set j2 = ( AddTo (( GBP ),2,1) );
set j3 = ( AddTo (( GBP ),3,1) );
set WB = ( ( j1 ';' j2 ) ';' j3 );
set WH = ( while<0 (( GBP ),2,WB) );
Lm1: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (for m being (Element of ( NAT )) holds ((( s . ( GBP ) ) = ( 0 ) & ( s . a3 ) = m) implies ((((( ( IExec (WB,P,( Initialize s )) ) . ( GBP ) ) = ( 0 ) & ( ( IExec (WB,P,( Initialize s )) ) . a1 ) = ( ( s . a1 ) + ( s . ( intpos m ) ) )) & ( ( IExec (WB,P,( Initialize s )) ) . a2 ) = ( ( s . a2 ) + 1 )) & ( ( IExec (WB,P,( Initialize s )) ) . a3 ) = ( m + 1 )) & (for i being (Element of ( NAT )) holds (i > 3 implies ( ( IExec (WB,P,( Initialize s )) ) . ( intpos i ) ) = ( s . ( intpos i ) )))))))
proof
set a = ( GBP );
let s being ( 0 ) -started (State of ( SCMPDS ));
let m being (Element of ( NAT ));
assume that
A1: ( s . a ) = ( 0 )
and
A2: ( s . a3 ) = m;
set t0 = ( Initialize s );
set t1 = ( IExec (WB,P,( Initialize s )) );
set t2 = ( IExec (( j1 ';' j2 ),P,( Initialize s )) );
set t3 = ( Exec (j1,t0) );
A3: ( t0 . a3 ) = m by A2,SCMPDS_5:15;
A4: ( t0 . a ) = ( 0 ) by A1,SCMPDS_5:15;
then ( 0 ) <> ( abs ( ( t0 . ( GBP ) ) + 1 ) ) by ABSVALUE:def 1;
then a <> ( DataLoc (( t0 . ( GBP ) ),1) ) by ZFMISC_1:27;
then A5: ( t3 . a ) = ( 0 ) by A4,SCMPDS_2:49;
then ( 0 ) <> ( abs ( ( t3 . ( GBP ) ) + 2 ) ) by ABSVALUE:def 1;
then A6: a <> ( DataLoc (( t3 . ( GBP ) ),2) ) by ZFMISC_1:27;
3 <> ( abs ( ( t0 . ( GBP ) ) + 1 ) ) by A4,ABSVALUE:def 1;
then a3 <> ( DataLoc (( t0 . ( GBP ) ),1) ) by ZFMISC_1:27;
then A7: ( t3 . a3 ) = m by A3,SCMPDS_2:49;
3 <> ( abs ( ( t3 . ( GBP ) ) + 2 ) ) by A5,ABSVALUE:def 1;
then A8: a3 <> ( DataLoc (( t3 . ( GBP ) ),2) ) by ZFMISC_1:27;
A9: ( t2 . a3 ) = ( ( Exec (j2,t3) ) . a3 ) by SCMPDS_5:42
.= m by A7,A8,SCMPDS_2:48;
A10: ( t0 . a1 ) = ( s . a1 ) by SCMPDS_5:15;
A11: ( DataLoc (( t0 . a ),1) ) = ( intpos ( ( 0 ) + 1 ) ) by A4,SCMP_GCD:1;
then A12: ( t3 . a1 ) = ( ( t0 . a1 ) + ( t0 . ( DataLoc (( t0 . a3 ),( 0 )) ) ) ) by SCMPDS_2:49
.= ( ( t0 . a1 ) + ( t0 . ( intpos ( m + ( 0 ) ) ) ) ) by A3,SCMP_GCD:1
.= ( ( s . a1 ) + ( s . ( intpos m ) ) ) by A10,SCMPDS_5:15;
1 <> ( abs ( ( t3 . ( GBP ) ) + 2 ) ) by A5,ABSVALUE:def 1;
then A13: a1 <> ( DataLoc (( t3 . ( GBP ) ),2) ) by ZFMISC_1:27;
A14: ( DataLoc (( t3 . a ),2) ) = ( intpos ( ( 0 ) + 2 ) ) by A5,SCMP_GCD:1;
then A15: ( abs ( ( t3 . a ) + 2 ) ) = ( ( 0 ) + 2 ) by ZFMISC_1:27;
2 <> ( abs ( ( t0 . ( GBP ) ) + 1 ) ) by A4,ABSVALUE:def 1;
then a2 <> ( DataLoc (( t0 . ( GBP ) ),1) ) by ZFMISC_1:27;
then A16: ( t3 . a2 ) = ( t0 . a2 ) by SCMPDS_2:49
.= ( s . a2 ) by SCMPDS_5:15;
A17: ( t2 . a ) = ( ( Exec (j2,t3) ) . a ) by SCMPDS_5:42
.= ( 0 ) by A5,A6,SCMPDS_2:48;
then A18: ( DataLoc (( t2 . a ),3) ) = ( intpos ( ( 0 ) + 3 ) ) by SCMP_GCD:1;
A19: ( t2 . a2 ) = ( ( Exec (j2,t3) ) . a2 ) by SCMPDS_5:42
.= ( ( s . a2 ) + 1 ) by A16,A14,SCMPDS_2:48;
A20: ( t2 . a1 ) = ( ( Exec (j2,t3) ) . a1 ) by SCMPDS_5:42
.= ( ( s . a1 ) + ( s . ( intpos m ) ) ) by A12,A13,SCMPDS_2:48;
( 0 ) <> ( abs ( ( t2 . ( GBP ) ) + 3 ) ) by A17,ABSVALUE:def 1;
then A21: a <> ( DataLoc (( t2 . ( GBP ) ),3) ) by ZFMISC_1:27;
thus ( t1 . a ) = ( ( Exec (j3,t2) ) . a ) by SCMPDS_5:41
.= ( 0 ) by A17,A21,SCMPDS_2:48;
1 <> ( abs ( ( t2 . ( GBP ) ) + 3 ) ) by A17,ABSVALUE:def 1;
then A22: a1 <> ( DataLoc (( t2 . ( GBP ) ),3) ) by ZFMISC_1:27;
thus ( t1 . a1 ) = ( ( Exec (j3,t2) ) . a1 ) by SCMPDS_5:41
.= ( ( s . a1 ) + ( s . ( intpos m ) ) ) by A20,A22,SCMPDS_2:48;
2 <> ( abs ( ( t2 . ( GBP ) ) + 3 ) ) by A17,ABSVALUE:def 1;
then A23: a2 <> ( DataLoc (( t2 . ( GBP ) ),3) ) by ZFMISC_1:27;
thus ( t1 . a2 ) = ( ( Exec (j3,t2) ) . a2 ) by SCMPDS_5:41
.= ( ( s . a2 ) + 1 ) by A19,A23,SCMPDS_2:48;
thus ( t1 . a3 ) = ( ( Exec (j3,t2) ) . a3 ) by SCMPDS_5:41
.= ( m + 1 ) by A9,A18,SCMPDS_2:48;
A24: ( abs ( ( t0 . a ) + 1 ) ) = ( ( 0 ) + 1 ) by A11,ZFMISC_1:27;
hereby
let i being (Element of ( NAT ));
assume A25: i > 3;
then A26: ( intpos i ) <> ( DataLoc (( t2 . a ),3) ) by A18,ZFMISC_1:27;
i <> ( abs ( ( t0 . a ) + 1 ) ) by A24,A25;
then A27: ( intpos i ) <> ( DataLoc (( t0 . a ),1) ) by ZFMISC_1:27;
i <> ( abs ( ( t3 . a ) + 2 ) ) by A15,A25;
then A28: ( intpos i ) <> ( DataLoc (( t3 . a ),2) ) by ZFMISC_1:27;
thus ( t1 . ( intpos i ) ) = ( ( Exec (j3,t2) ) . ( intpos i ) ) by SCMPDS_5:41
.= ( t2 . ( intpos i ) ) by A26,SCMPDS_2:48
.= ( ( Exec (j2,t3) ) . ( intpos i ) ) by SCMPDS_5:42
.= ( t3 . ( intpos i ) ) by A28,SCMPDS_2:48
.= ( t0 . ( intpos i ) ) by A27,SCMPDS_2:49
.= ( s . ( intpos i ) ) by SCMPDS_5:15;
end;
end;
Lm3: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (for n,p0 being (Element of ( NAT )) holds (for f being (FinSequence of ( INT )) holds (((((((p0 >= 3 & f is_FinSequence_on s,p0) & ( len f ) = n) & ( s . a1 ) = ( 0 )) & ( s . ( GBP ) ) = ( 0 )) & ( s . a2 ) = ( - n )) & ( s . a3 ) = ( p0 + 1 )) implies ((( ( IExec (WH,P,( Initialize s )) ) . a1 ) = ( Sum f ) & WH is_closed_on s,P) & WH is_halting_on s,P)))))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
let n being (Element of ( NAT ));
let p0 being (Element of ( NAT ));
let f being (FinSequence of ( INT ));
set a = ( GBP );
I: ( Initialize s ) = s by MEMSTR_0:44;
assume that
A1: p0 >= 3
and
A2: (((((f is_FinSequence_on s,p0 & ( len f ) = n) & ( s . a1 ) = ( 0 )) & ( s . a ) = ( 0 )) & ( s . a2 ) = ( - n )) & ( s . a3 ) = ( p0 + 1 ));
now
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
T: ( Initialize t ) = t by MEMSTR_0:44;
given g being (FinSequence of ( INT )) such that
A3: g is_FinSequence_on s,p0
and
A4: ( len g ) = ( ( t . a2 ) + n )
and
A5: ( t . a1 ) = ( Sum g )
and
A6: ( t . a3 ) = ( ( p0 + 1 ) + ( len g ) );

assume that
A7: ( t . a ) = ( 0 )
and
( t . a2 ) < ( 0 );
assume A13: (for i being (Element of ( NAT )) holds (i > p0 implies ( t . ( intpos i ) ) = ( s . ( intpos i ) )));
thus ( ( IExec (WB,Q,t) ) . a ) = ( 0 ) by A6,A7,Lm1,T;
thus (WB is_closed_on t,Q & WB is_halting_on t,Q) by SCMPDS_6:20,SCMPDS_6:21;
thus ( ( IExec (WB,Q,t) ) . a2 ) = ( ( t . a2 ) + 1 ) by A6,A7,Lm1,T;
thus (ex g being (FinSequence of ( INT )) st (((g is_FinSequence_on s,p0 & ( len g ) = ( ( ( t . a2 ) + n ) + 1 )) & ( ( IExec (WB,Q,t) ) . a3 ) = ( ( p0 + 1 ) + ( len g ) )) & ( ( IExec (WB,Q,t) ) . a1 ) = ( Sum g )))
proof
consider h being (FinSequence of ( INT )) such that A14: ( len h ) = ( ( len g ) + 1 ) and A15: h is_FinSequence_on s,p0 by SCPISORT:2;
take h;
thus h is_FinSequence_on s,p0 by A15;
thus ( len h ) = ( ( ( t . a2 ) + n ) + 1 ) by A4,A14;
thus ( ( IExec (WB,Q,t) ) . a3 ) = ( ( ( p0 + 1 ) + ( len g ) ) + 1 ) by A6,A7,Lm1,T
.= ( ( p0 + 1 ) + ( len h ) ) by A14;
A16: ( p0 + 1 ) > p0 by XREAL_1:29;
set m = ( len h );
A17: m >= 1 by A14,NAT_1:11;
then ( p0 + m ) >= ( p0 + 1 ) by XREAL_1:6;
then A18: ( p0 + m ) > p0 by A16,XXREAL_0:2;
reconsider q = ( h . m ) as (Element of ( INT )) by INT_1:def 2;
A19:now
let i being Nat;
A20: i in ( NAT ) by ORDINAL1:def 12;
assume that
A21: 1 <= i
and
A22: i <= ( len h );
per cases ;
suppose i = ( len h );

hence ( h . i ) = ( ( g ^ <* q *> ) . i ) by A14,FINSEQ_1:42;
end;
suppose i <> ( len h );

then i < ( len h ) by A22,XXREAL_0:1;
then A23: i <= ( len g ) by A14,INT_1:7;
then i in ( Seg ( len g ) ) by A21,FINSEQ_1:1;
then A24: i in ( dom g ) by FINSEQ_1:def 3;
thus ( h . i ) = ( s . ( intpos ( p0 + i ) ) ) by A15,A20,A21,A22,SCPISORT:def 1
.= ( g . i ) by A3,A20,A21,A23,SCPISORT:def 1
.= ( ( g ^ <* q *> ) . i ) by A24,FINSEQ_1:def 7;
end;
end;
( len ( g ^ <* q *> ) ) = ( len h ) by A14,FINSEQ_2:16;
then A25: ( g ^ <* q *> ) = h by A19,FINSEQ_1:14;
( h . m ) = ( s . ( intpos ( p0 + m ) ) ) by A15,A17,SCPISORT:def 1
.= ( t . ( intpos ( ( p0 + 1 ) + ( len g ) ) ) ) by A13,A14,A18;
hence ( ( IExec (WB,Q,t) ) . a1 ) = ( ( t . a1 ) + ( h . m ) ) by A6,A7,Lm1,T
.= ( Sum h ) by A5,A25,RVSUM_1:74;
end;

hereby
let i being (Element of ( NAT ));
assume A28: i > p0;
then i > 3 by A1,XXREAL_0:2;
hence ( ( IExec (WB,Q,t) ) . ( intpos i ) ) = ( t . ( intpos i ) ) by A6,A7,Lm1,T
.= ( s . ( intpos i ) ) by A13,A28;
end;
end;
hence thesis by A2,CKB7:1,I;
end;
Lm4: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (for n,p0 being (Element of ( NAT )) holds (for f being (FinSequence of ( INT )) holds (((p0 >= 3 & f is_FinSequence_on s,p0) & ( len f ) = n) implies (( ( IExec (( sum (n,p0) ),P,s) ) . a1 ) = ( Sum f ) & ( sum (n,p0) ) is_halting_on s,P)))))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
let n being (Element of ( NAT ));
let p0 being (Element of ( NAT ));
let f being (FinSequence of ( INT ));
I: ( Initialize s ) = s by MEMSTR_0:44;
assume that
A1: p0 >= 3
and
A2: f is_FinSequence_on s,p0
and
A3: ( len f ) = n;
set a = ( GBP );
set i1 = ( a := ( 0 ) );
set i2 = ( a1 := ( 0 ) );
set i3 = ( a2 := ( - n ) );
set i4 = ( a3 := ( p0 + 1 ) );
set t0 = ( Initialize s );
set I4 = ( ( ( i1 ';' i2 ) ';' i3 ) ';' i4 );
set t1 = ( IExec (I4,P,( Initialize s )) );
set Q1 = P;
set t2 = ( IExec (( ( i1 ';' i2 ) ';' i3 ),P,( Initialize s )) );
set t3 = ( IExec (( i1 ';' i2 ),P,( Initialize s )) );
set t4 = ( Exec (i1,t0) );
now
let i being (Element of ( NAT ));
assume that
A4: 1 <= i
and
A5: i <= ( len f );
A6: ( p0 + 1 ) >= ( 3 + 1 ) by A1,XREAL_1:6;
A7: ( p0 + i ) >= ( p0 + 1 ) by A4,XREAL_1:6;
then ( p0 + i ) <> 3 by A6,XXREAL_0:2;
then A8: ( intpos ( p0 + i ) ) <> a3 by ZFMISC_1:27;
( p0 + i ) <> ( 0 ) by A6,A7,XXREAL_0:2;
then A9: ( intpos ( p0 + i ) ) <> a by ZFMISC_1:27;
( p0 + i ) <> 1 by A6,A7,XXREAL_0:2;
then A10: ( intpos ( p0 + i ) ) <> a1 by ZFMISC_1:27;
( p0 + i ) <> 2 by A6,A7,XXREAL_0:2;
then A11: ( intpos ( p0 + i ) ) <> a2 by ZFMISC_1:27;
thus ( t1 . ( intpos ( p0 + i ) ) ) = ( ( Exec (i4,t2) ) . ( intpos ( p0 + i ) ) ) by SCMPDS_5:41
.= ( t2 . ( intpos ( p0 + i ) ) ) by A8,SCMPDS_2:45
.= ( ( Exec (i3,t3) ) . ( intpos ( p0 + i ) ) ) by SCMPDS_5:41
.= ( t3 . ( intpos ( p0 + i ) ) ) by A11,SCMPDS_2:45
.= ( ( Exec (i2,t4) ) . ( intpos ( p0 + i ) ) ) by SCMPDS_5:42
.= ( t4 . ( intpos ( p0 + i ) ) ) by A10,SCMPDS_2:45
.= ( t0 . ( intpos ( p0 + i ) ) ) by A9,SCMPDS_2:45
.= ( s . ( intpos ( p0 + i ) ) ) by SCMPDS_5:15
.= ( f . i ) by A2,A4,A5,SCPISORT:def 1;
end;
then A12: f is_FinSequence_on t1,p0 by SCPISORT:def 1;
A13: f is_FinSequence_on ( Initialize t1 ),p0
proof
let i being (Element of ( NAT ));
assume (1 <= i & i <= ( len f ));
then ( f . i ) = ( t1 . ( intpos ( p0 + i ) ) ) by A12,SCPISORT:def 1;
hence thesis by SCMPDS_5:15;
end;
A14: ( t4 . a ) = ( 0 ) by SCMPDS_2:45;
A15: ( t3 . a ) = ( ( Exec (i2,t4) ) . a ) by SCMPDS_5:42
.= ( 0 ) by A14,AMI_3:10,SCMPDS_2:45;
A16: ( t2 . a ) = ( ( Exec (i3,t3) ) . a ) by SCMPDS_5:41
.= ( 0 ) by A15,AMI_3:10,SCMPDS_2:45;
A17: ( t1 . a3 ) = ( ( Exec (i4,t2) ) . a3 ) by SCMPDS_5:41
.= ( p0 + 1 ) by SCMPDS_2:45;
A18: ( ( Initialize t1 ) . a3 ) = ( t1 . a3 ) by SCMPDS_5:15;
A19: ( t3 . a1 ) = ( ( Exec (i2,t4) ) . a1 ) by SCMPDS_5:42
.= ( 0 ) by SCMPDS_2:45;
A20: ( t2 . a1 ) = ( ( Exec (i3,t3) ) . a1 ) by SCMPDS_5:41
.= ( 0 ) by A19,AMI_3:10,SCMPDS_2:45;
A21: ( ( Initialize t1 ) . a1 ) = ( t1 . a1 ) by SCMPDS_5:15;
A22: ( t1 . a1 ) = ( ( Exec (i4,t2) ) . a1 ) by SCMPDS_5:41
.= ( 0 ) by A20,AMI_3:10,SCMPDS_2:45;
A23: ( t2 . a2 ) = ( ( Exec (i3,t3) ) . a2 ) by SCMPDS_5:41
.= ( - n ) by SCMPDS_2:45;
A24: ( ( Initialize t1 ) . a2 ) = ( t1 . a2 ) by SCMPDS_5:15;
A25: ( ( Initialize t1 ) . a ) = ( t1 . a ) by SCMPDS_5:15;
A26: ( t1 . a2 ) = ( ( Exec (i4,t2) ) . a2 ) by SCMPDS_5:41
.= ( - n ) by A23,AMI_3:10,SCMPDS_2:45;
A27: ( t1 . a ) = ( ( Exec (i4,t2) ) . a ) by SCMPDS_5:41
.= ( 0 ) by A16,AMI_3:10,SCMPDS_2:45;
then (WH is_closed_on ( Initialize t1 ),Q1 & WH is_halting_on ( Initialize t1 ),Q1) by A1,A3,A22,A26,A17,Lm3,A13,A18,A21,A24,A25;
then A28: (WH is_closed_on t1,Q1 & WH is_halting_on t1,Q1) by SCMPDS_6:125,SCMPDS_6:126;
( IExec (WH,Q1,( Initialize t1 )) ) = ( IExec (WH,Q1,( Initialize ( Initialize t1 ) )) );
then ( ( IExec (WH,Q1,( Initialize t1 )) ) . a1 ) = ( Sum f ) by A1,A3,A27,A22,A26,A17,Lm3,A13,A18,A21,A24,A25;
hence ( ( IExec (( sum (n,p0) ),P,s) ) . a1 ) = ( Sum f ) by A28,I,SCPISORT:7;
thus thesis by A28,SCPISORT:9;
end;
theorem
(for s being ( 0 ) -started (State of ( SCMPDS )) holds (for n,p0 being (Element of ( NAT )) holds (for f being (FinSequence of ( INT )) holds (((p0 >= 3 & f is_FinSequence_on s,p0) & ( len f ) = n) implies (( ( IExec (( sum (n,p0) ),P,s) ) . ( intpos 1 ) ) = ( Sum f ) & ( sum (n,p0) ) is  parahalting)))))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
let n being (Element of ( NAT ));
let p0 being (Element of ( NAT ));
let f being (FinSequence of ( INT ));
assume that
A1: p0 >= 3
and
A2: (f is_FinSequence_on s,p0 & ( len f ) = n);
thus ( ( IExec (( sum (n,p0) ),P,s) ) . a1 ) = ( Sum f ) by A1,A2,Lm4;
now
let t being (State of ( SCMPDS ));
let Q;
consider g being (FinSequence of ( INT )) such that A3: (( len g ) = n & g is_FinSequence_on t,p0) by SCPISORT:2;
g is_FinSequence_on ( Initialize t ),p0
proof
let i being (Element of ( NAT ));
assume (1 <= i & i <= ( len g ));
then ( g . i ) = ( t . ( intpos ( p0 + i ) ) ) by A3,SCPISORT:def 1;
hence thesis by SCMPDS_5:15;
end;
then ( sum (n,p0) ) is_halting_on ( Initialize t ),Q by A1,Lm4,A3;
hence ( sum (n,p0) ) is_halting_on t,Q by SCMPDS_6:126;
end;
hence thesis by SCMPDS_6:21;
end;
