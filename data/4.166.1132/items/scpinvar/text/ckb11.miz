environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMPDS_2,TURING_1,FUNCT_1,CARD_1,SCMFSA_7,RELAT_1,ARYTM_3,CARD_3,FSM_1,XXREAL_0,COMPLEX1,ARYTM_1,AMI_2,SCMPDS_5,SCMPDS_4,INT_1,SCMPDS_8,SCMFSA6B,SCMFSA_9,UNIALG_2,SCMFSA7B,SCMP_GCD,SEMI_AF1,GRAPHSP,AMI_3,FINSEQ_1,SCPISORT,NAT_1,ORDINAL4,SFMASTR2,PRE_FF,FUNCT_4,CIRCUIT2,TARSKI,PBOOLE,MSUALG_1,STRUCT_0,VALUED_1,SCMFSA8B,INT_2,SCPINVAR,ORDINAL1,PARTFUN1,SCMNORM,SCMFSA6C,COMPOS_1;
notations XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,PARTFUN1,VALUED_1,XCMPLX_0,FUNCT_4,PBOOLE,INT_1,INT_2,NAT_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,SCMPDS_2,SCMPDS_4,SCMPDS_6,SCMP_GCD,SCMPDS_5,SCMPDS_8,FUNCT_2,CARD_3,DOMAIN_1,FINSEQ_1,GR_CY_1,PRE_FF,SCPISORT,XXREAL_0,CKB5,CKB6,CKB10;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,AMI_3,SCMPDS_2,SCMP_GCD,SCPISORT,MEMSTR_0,CKB5,CKB10;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,INT_1,SCMPDS_2,ABSVALUE,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,ENUMSET1,INT_2,SCMPDS_8,SCMP_GCD,SCMPDS_7,FUNCT_1,FINSEQ_1,RVSUM_1,FINSEQ_2,MEMSTR_0,PRE_FF,SCPISORT,XBOOLE_1,XREAL_1,COMPLEX1,XXREAL_0,PREPOWER,ORDINAL1,FUNCOP_1,ZFMISC_1,NAT_D,FINSEQ_3,PBOOLE,PARTFUN1,AFINSQ_1,COMPOS_1,EXTPRO_1,CARD_3,CKB1,CKB2,CKB3,CKB5,CKB7,CKB8,CKB10;
schemes NAT_1,SCMPDS_8,FUNCT_2,CKB4,CKB9;
registrations SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,CARD_3,STRUCT_0,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,XBOOLE_0,FINSEQ_1,CARD_1,VALUED_1,VALUED_0,MEMSTR_0,RELAT_1,FUNCT_2,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,FUNCT_4;
constructors DOMAIN_1,REAL_1,NAT_D,RECDEF_1,PRE_FF,MESFUNC1,GR_CY_1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,BINOP_2,AMI_2,MEMSTR_0,RELSET_1,CKB5,CKB6,CKB10;
requirements NUMERALS,REAL,SUBSET,ARITHM,BOOLE;
begin
reserve m for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
reserve i for (Instruction of ( SCMPDS ));
reserve I for (Program of ( SCMPDS ));
reserve a for Int_position;
reserve Q for (Instruction-Sequence of ( SCMPDS ));
reserve P for (Instruction-Sequence of ( SCMPDS ));
theorem
Th10: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (for I being  halt-free  shiftable (Program of ( SCMPDS )) holds (for a,f0,f1 being Int_position holds (for n,i being (Element of ( NAT )) holds (((((( s . a ) = ( 0 ) & ( s . f0 ) = ( 0 )) & ( s . f1 ) = 1) & ( s . ( intpos i ) ) = n) & (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (for k being (Element of ( NAT )) holds (((((n = ( ( t . ( intpos i ) ) + k ) & ( t . f0 ) = ( Fib k )) & ( t . f1 ) = ( Fib ( k + 1 ) )) & ( t . a ) = ( 0 )) & ( t . ( intpos i ) ) > ( 0 )) implies (((((( ( IExec (I,Q,t) ) . a ) = ( 0 ) & I is_closed_on t,Q) & I is_halting_on t,Q) & ( ( IExec (I,Q,t) ) . ( intpos i ) ) = ( ( t . ( intpos i ) ) - 1 )) & ( ( IExec (I,Q,t) ) . f0 ) = ( Fib ( k + 1 ) )) & ( ( IExec (I,Q,t) ) . f1 ) = ( Fib ( ( k + 1 ) + 1 ) ))))))) implies (((( ( IExec (( while>0 (a,i,I) ),P,s) ) . f0 ) = ( Fib n ) & ( ( IExec (( while>0 (a,i,I) ),P,s) ) . f1 ) = ( Fib ( n + 1 ) )) & ( while>0 (a,i,I) ) is_closed_on s,P) & ( while>0 (a,i,I) ) is_halting_on s,P))))))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
let I being  halt-free  shiftable (Program of ( SCMPDS ));
let a being Int_position;
let f0 being Int_position;
let f1 being Int_position;
let n being (Element of ( NAT ));
let i being (Element of ( NAT ));
set Iw = ( IExec (( while>0 (a,i,I) ),P,s) );
set Dw = ( Initialize Iw );
set da = ( DataLoc (( s . a ),i) );
defpred P[ (State of ( SCMPDS )) ]
 means
(( $1 . ( intpos i ) ) >= ( 0 ) & (ex k being (Element of ( NAT )) st ((n = ( ( $1 . ( intpos i ) ) + k ) & ( $1 . f0 ) = ( Fib k )) & ( $1 . f1 ) = ( Fib ( k + 1 ) ))));
assume that
A2: ( s . a ) = ( 0 )
and
A3: ( s . f0 ) = ( 0 )
and
A4: ( s . f1 ) = 1
and
A5: ( s . ( intpos i ) ) = n;
consider ff being (Function of ( product (the Object-Kind of ( SCMPDS )) ),( NAT )) such that B6: (for t being (State of ( SCMPDS )) holds ((( t . da ) <= ( 0 ) implies ( ff . t ) = ( 0 )) & (( t . da ) > ( 0 ) implies ( ff . t ) = ( t . da )))) by SCMPDS_8:5;
A6: (for t being ( 0 ) -started (State of ( SCMPDS )) holds ((( t . da ) <= ( 0 ) implies ( ff . t ) = ( 0 )) & (( t . da ) > ( 0 ) implies ( ff . t ) = ( t . da )))) by B6;
deffunc F((State of ( SCMPDS ))) = ( ff . $1 );
A7: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (P[ t ] implies ((not (F(t) = ( 0 ) & ( t . da ) > ( 0 ))) & (( t . da ) <= ( 0 ) implies F(t) = ( 0 ))))) by A6;
assume A9: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (for k being (Element of ( NAT )) holds (((((n = ( ( t . ( intpos i ) ) + k ) & ( t . f0 ) = ( Fib k )) & ( t . f1 ) = ( Fib ( k + 1 ) )) & ( t . a ) = ( 0 )) & ( t . ( intpos i ) ) > ( 0 )) implies (((((( ( IExec (I,Q,t) ) . a ) = ( 0 ) & I is_closed_on t,Q) & I is_halting_on t,Q) & ( ( IExec (I,Q,t) ) . ( intpos i ) ) = ( ( t . ( intpos i ) ) - 1 )) & ( ( IExec (I,Q,t) ) . f0 ) = ( Fib ( k + 1 ) )) & ( ( IExec (I,Q,t) ) . f1 ) = ( Fib ( ( k + 1 ) + 1 ) ))))));
A10:now
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
assume that
A11: P[ t ]
and
A12: ( t . a ) = ( s . a )
and
A13: ( t . ( DataLoc (( s . a ),i) ) ) > ( 0 );
set It = ( IExec (I,Q,t) );
set Dit = ( Initialize It );
consider k being (Element of ( NAT )) such that A14: n = ( ( t . ( intpos i ) ) + k ) and A15: ( t . f0 ) = ( Fib k ) and A16: ( t . f1 ) = ( Fib ( k + 1 ) ) by A11;
A17: ( t . f1 ) = ( Fib ( k + 1 ) ) by A16;
A18: ( intpos ( ( 0 ) + i ) ) = da by A2,SCMP_GCD:1;
A19: (n = ( ( t . ( intpos i ) ) + k ) & ( t . f0 ) = ( Fib k )) by A14,A15;
hence ( ( IExec (I,Q,t) ) . a ) = ( t . a ) by A2,A9,A12,A13,A17,A18;
thus (I is_closed_on t,Q & I is_halting_on t,Q) by A2,A9,A12,A13,A19,A17,A18;
A20: ( It . ( intpos i ) ) = ( ( t . ( intpos i ) ) - 1 ) by A2,A9,A12,A13,A19,A17,A18;
hereby
per cases ;
suppose ( It . ( intpos i ) ) <= ( 0 );

then ( Dit . da ) <= ( 0 ) by A18,SCMPDS_5:15;
then A21: F(Dit) = ( 0 ) by A6;
F(t) <> ( 0 ) by A7,A11,A13;
hence F(Dit) < F(t) by A21,NAT_1:3;
end;
suppose A22: ( It . ( intpos i ) ) > ( 0 );

( t . da ) > ( 0 ) by A13;
then A23: F(t) = ( t . da ) by A6
.= ( t . ( intpos i ) ) by A18;
( Dit . da ) > ( 0 ) by A18,A22,SCMPDS_5:15;
then F(Dit) = ( Dit . da ) by A6
.= ( ( t . ( intpos i ) ) - 1 ) by A18,A20,SCMPDS_5:15;
hence F(Dit) < F(t) by A23,XREAL_1:146;
end;
end;
thus P[ Dit ]
proof
( t . ( intpos i ) ) >= ( 1 + ( 0 ) ) by A13,A18,INT_1:7;
then ( ( t . ( intpos i ) ) - 1 ) >= ( 0 ) by XREAL_1:48;
hence ( Dit . ( intpos i ) ) >= ( 0 ) by A20,SCMPDS_5:15;
take m = ( k + 1 );
thus n = ( ( ( ( t . ( intpos i ) ) - 1 ) + 1 ) + k ) by A14
.= ( ( ( Dit . ( intpos i ) ) + 1 ) + k ) by A20,SCMPDS_5:15
.= ( ( Dit . ( intpos i ) ) + m );
(( It . f0 ) = ( Fib m ) & ( It . f1 ) = ( Fib ( ( k + 1 ) + 1 ) )) by A2,A9,A12,A13,A19,A17,A18;
hence thesis by SCMPDS_5:15;
end;

end;
A24: P[ s ]
proof
( s . ( intpos i ) ) = n by A5;
hence ( s . ( intpos i ) ) >= ( 0 ) by NAT_1:2;
take k = ( 0 );
thus n = ( ( s . ( intpos i ) ) + k ) by A5;
thus ( s . f0 ) = ( Fib k ) by A3,PRE_FF:1;
thus thesis by A4,PRE_FF:1;
end;
A25: (F(Dw) = ( 0 ) & P[ Dw ]) from CKB9:sch 1(A7,A24,A10);
X1: ( Dw . da ) = ( Iw . da ) by SCMPDS_5:15;
( Dw . ( intpos i ) ) = ( Iw . ( intpos ( ( 0 ) + i ) ) ) by SCMPDS_5:15
.= ( Iw . da ) by A2,SCMP_GCD:1;
then ( Dw . ( intpos i ) ) <= ( 0 ) by A7,A25,X1;
then ( Dw . ( intpos i ) ) = ( 0 ) by A25,XXREAL_0:1;
hence (( Iw . f0 ) = ( Fib n ) & ( Iw . f1 ) = ( Fib ( n + 1 ) )) by A25,SCMPDS_5:15;
A26: (for t being ( 0 ) -started (State of ( SCMPDS )) holds ((P[ t ] & F(t) = ( 0 )) implies ( t . da ) <= ( 0 ))) by A7;
(( while>0 (a,i,I) ) is_closed_on s,P & ( while>0 (a,i,I) ) is_halting_on s,P) from SCMPDS_8:sch 3(A26,A24,A10);
hence thesis;
end;
