environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMPDS_2,TURING_1,FUNCT_1,CARD_1,SCMFSA_7,RELAT_1,ARYTM_3,CARD_3,FSM_1,XXREAL_0,COMPLEX1,ARYTM_1,AMI_2,SCMPDS_5,SCMPDS_4,INT_1,SCMPDS_8,SCMFSA6B,SCMFSA_9,UNIALG_2,SCMFSA7B,SCMP_GCD,SEMI_AF1,GRAPHSP,AMI_3,FINSEQ_1,SCPISORT,NAT_1,ORDINAL4,SFMASTR2,PRE_FF,FUNCT_4,CIRCUIT2,TARSKI,PBOOLE,MSUALG_1,STRUCT_0,VALUED_1,SCMFSA8B,INT_2,SCPINVAR,ORDINAL1,PARTFUN1,SCMNORM,SCMFSA6C,COMPOS_1;
notations XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,PARTFUN1,VALUED_1,XCMPLX_0,FUNCT_4,PBOOLE,INT_1,INT_2,NAT_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,SCMPDS_2,SCMPDS_4,SCMPDS_6,SCMP_GCD,SCMPDS_5,SCMPDS_8,FUNCT_2,CARD_3,DOMAIN_1,FINSEQ_1,GR_CY_1,PRE_FF,SCPISORT,XXREAL_0,CKB5,CKB6,CKB10;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,AMI_3,SCMPDS_2,SCMP_GCD,SCPISORT,MEMSTR_0,CKB5,CKB10;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,INT_1,SCMPDS_2,ABSVALUE,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,ENUMSET1,INT_2,SCMPDS_8,SCMP_GCD,SCMPDS_7,FUNCT_1,FINSEQ_1,RVSUM_1,FINSEQ_2,MEMSTR_0,PRE_FF,SCPISORT,XBOOLE_1,XREAL_1,COMPLEX1,XXREAL_0,PREPOWER,ORDINAL1,FUNCOP_1,ZFMISC_1,NAT_D,FINSEQ_3,PBOOLE,PARTFUN1,AFINSQ_1,COMPOS_1,EXTPRO_1,CARD_3,CKB1,CKB2,CKB3,CKB5,CKB7,CKB8,CKB10,CKB11;
schemes NAT_1,SCMPDS_8,FUNCT_2,CKB4,CKB9;
registrations SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,CARD_3,STRUCT_0,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,XBOOLE_0,FINSEQ_1,CARD_1,VALUED_1,VALUED_0,MEMSTR_0,RELAT_1,FUNCT_2,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,FUNCT_4;
constructors DOMAIN_1,REAL_1,NAT_D,RECDEF_1,PRE_FF,MESFUNC1,GR_CY_1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,BINOP_2,AMI_2,MEMSTR_0,RELSET_1,CKB5,CKB6,CKB10;
requirements NUMERALS,REAL,SUBSET,ARITHM,BOOLE;
begin
reserve n for (Element of ( NAT ));
reserve Q for (Instruction-Sequence of ( SCMPDS ));
reserve P for (Instruction-Sequence of ( SCMPDS ));
set a1 = ( intpos 1 );
set a2 = ( intpos 2 );
set a3 = ( intpos 3 );
set j1 = ( (( GBP ),4) := (( GBP ),2) );
set j2 = ( AddTo (( GBP ),2,( GBP ),1) );
set j3 = ( (( GBP ),1) := (( GBP ),4) );
set j4 = ( AddTo (( GBP ),3,( - 1 )) );
set WB = ( ( ( j1 ';' j2 ) ';' j3 ) ';' j4 );
set WH = ( while>0 (( GBP ),3,WB) );
Lm5: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (( s . ( GBP ) ) = ( 0 ) implies (((( ( IExec (WB,P,s) ) . ( GBP ) ) = ( 0 ) & ( ( IExec (WB,P,s) ) . a1 ) = ( s . a2 )) & ( ( IExec (WB,P,s) ) . a2 ) = ( ( s . a1 ) + ( s . a2 ) )) & ( ( IExec (WB,P,s) ) . a3 ) = ( ( s . a3 ) - 1 ))))
proof
set a = ( GBP );
let s being ( 0 ) -started (State of ( SCMPDS ));
set t0 = s;
set t1 = ( IExec (WB,P,s) );
set t2 = ( IExec (( ( j1 ';' j2 ) ';' j3 ),P,s) );
set Q0 = P;
set t3 = ( IExec (( j1 ';' j2 ),P,s) );
set t4 = ( Exec (j1,t0) );
set a4 = ( intpos 4 );
assume ( s . a ) = ( 0 );
then A5: ( t0 . a ) = ( 0 );
then ( DataLoc (( t0 . a ),4) ) = ( intpos ( ( 0 ) + 4 ) ) by SCMP_GCD:1;
then A6: ( t4 . a4 ) = ( t0 . ( DataLoc (( t0 . a ),2) ) ) by SCMPDS_2:47
.= ( t0 . ( intpos ( ( 0 ) + 2 ) ) ) by A5,SCMP_GCD:1
.= ( s . a2 );
( 0 ) <> ( abs ( ( t0 . ( GBP ) ) + 4 ) ) by A5,ABSVALUE:def 1;
then a <> ( DataLoc (( t0 . ( GBP ) ),4) ) by ZFMISC_1:27;
then A7: ( t4 . a ) = ( 0 ) by A5,SCMPDS_2:47;
then A8: ( DataLoc (( t4 . a ),2) ) = ( intpos ( ( 0 ) + 2 ) ) by SCMP_GCD:1;
( 0 ) <> ( abs ( ( t4 . ( GBP ) ) + 2 ) ) by A7,ABSVALUE:def 1;
then A9: a <> ( DataLoc (( t4 . ( GBP ) ),2) ) by ZFMISC_1:27;
A10: ( t3 . a ) = ( ( Exec (j2,t4) ) . a ) by SCMPDS_5:42
.= ( 0 ) by A7,A9,SCMPDS_2:49;
then A11: ( DataLoc (( t3 . a ),1) ) = ( intpos ( ( 0 ) + 1 ) ) by SCMP_GCD:1;
4 <> ( abs ( ( t4 . ( GBP ) ) + 2 ) ) by A7,ABSVALUE:def 1;
then A12: a4 <> ( DataLoc (( t4 . ( GBP ) ),2) ) by ZFMISC_1:27;
A13: ( t3 . a4 ) = ( ( Exec (j2,t4) ) . a4 ) by SCMPDS_5:42
.= ( s . a2 ) by A6,A12,SCMPDS_2:49;
A14: ( t2 . a1 ) = ( ( Exec (j3,t3) ) . a1 ) by SCMPDS_5:41
.= ( t3 . ( DataLoc (( t3 . a ),4) ) ) by A11,SCMPDS_2:47
.= ( s . a2 ) by A10,A13,SCMP_GCD:1;
3 <> ( abs ( ( t4 . ( GBP ) ) + 2 ) ) by A7,ABSVALUE:def 1;
then A15: a3 <> ( DataLoc (( t4 . ( GBP ) ),2) ) by ZFMISC_1:27;
2 <> ( abs ( ( t0 . ( GBP ) ) + 4 ) ) by A5,ABSVALUE:def 1;
then a2 <> ( DataLoc (( t0 . ( GBP ) ),4) ) by ZFMISC_1:27;
then A16: ( t4 . a2 ) = ( t0 . a2 ) by SCMPDS_2:47
.= ( s . a2 );
1 <> ( abs ( ( t0 . ( GBP ) ) + 4 ) ) by A5,ABSVALUE:def 1;
then a1 <> ( DataLoc (( t0 . ( GBP ) ),4) ) by ZFMISC_1:27;
then A17: ( t4 . a1 ) = ( t0 . a1 ) by SCMPDS_2:47
.= ( s . a1 );
3 <> ( abs ( ( t0 . ( GBP ) ) + 4 ) ) by A5,ABSVALUE:def 1;
then a3 <> ( DataLoc (( t0 . ( GBP ) ),4) ) by ZFMISC_1:27;
then A18: ( t4 . a3 ) = ( t0 . a3 ) by SCMPDS_2:47
.= ( s . a3 );
( 0 ) <> ( abs ( ( t3 . ( GBP ) ) + 1 ) ) by A10,ABSVALUE:def 1;
then A19: a <> ( DataLoc (( t3 . ( GBP ) ),1) ) by ZFMISC_1:27;
A20: ( t2 . a ) = ( ( Exec (j3,t3) ) . a ) by SCMPDS_5:41
.= ( 0 ) by A10,A19,SCMPDS_2:47;
then A21: ( DataLoc (( t2 . a ),3) ) = ( intpos ( ( 0 ) + 3 ) ) by SCMP_GCD:1;
2 <> ( abs ( ( t3 . ( GBP ) ) + 1 ) ) by A10,ABSVALUE:def 1;
then A22: a2 <> ( DataLoc (( t3 . ( GBP ) ),1) ) by ZFMISC_1:27;
A23: ( t3 . a2 ) = ( ( Exec (j2,t4) ) . a2 ) by SCMPDS_5:42
.= ( ( t4 . a2 ) + ( t4 . ( DataLoc (( t4 . a ),1) ) ) ) by A8,SCMPDS_2:49
.= ( ( s . a2 ) + ( s . a1 ) ) by A7,A17,A16,SCMP_GCD:1;
A24: ( t2 . a2 ) = ( ( Exec (j3,t3) ) . a2 ) by SCMPDS_5:41
.= ( ( s . a2 ) + ( s . a1 ) ) by A23,A22,SCMPDS_2:47;
3 <> ( abs ( ( t3 . ( GBP ) ) + 1 ) ) by A10,ABSVALUE:def 1;
then A25: a3 <> ( DataLoc (( t3 . ( GBP ) ),1) ) by ZFMISC_1:27;
( 0 ) <> ( abs ( ( t2 . ( GBP ) ) + 3 ) ) by A20,ABSVALUE:def 1;
then A26: a <> ( DataLoc (( t2 . ( GBP ) ),3) ) by ZFMISC_1:27;
thus ( t1 . a ) = ( ( Exec (j4,t2) ) . a ) by SCMPDS_5:41
.= ( 0 ) by A20,A26,SCMPDS_2:48;
1 <> ( abs ( ( t2 . ( GBP ) ) + 3 ) ) by A20,ABSVALUE:def 1;
then A27: a1 <> ( DataLoc (( t2 . ( GBP ) ),3) ) by ZFMISC_1:27;
thus ( t1 . a1 ) = ( ( Exec (j4,t2) ) . a1 ) by SCMPDS_5:41
.= ( s . a2 ) by A14,A27,SCMPDS_2:48;
2 <> ( abs ( ( t2 . ( GBP ) ) + 3 ) ) by A20,ABSVALUE:def 1;
then A28: a2 <> ( DataLoc (( t2 . ( GBP ) ),3) ) by ZFMISC_1:27;
A29: ( t3 . a3 ) = ( ( Exec (j2,t4) ) . a3 ) by SCMPDS_5:42
.= ( s . a3 ) by A18,A15,SCMPDS_2:49;
A30: ( t2 . a3 ) = ( ( Exec (j3,t3) ) . a3 ) by SCMPDS_5:41
.= ( s . a3 ) by A29,A25,SCMPDS_2:47;
thus ( t1 . a2 ) = ( ( Exec (j4,t2) ) . a2 ) by SCMPDS_5:41
.= ( ( s . a1 ) + ( s . a2 ) ) by A24,A28,SCMPDS_2:48;
thus ( t1 . a3 ) = ( ( Exec (j4,t2) ) . a3 ) by SCMPDS_5:41
.= ( ( t2 . a3 ) + ( - 1 ) ) by A21,SCMPDS_2:48
.= ( ( s . a3 ) - 1 ) by A30;
end;
Lm7: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (for n being (Element of ( NAT )) holds ((((( s . ( GBP ) ) = ( 0 ) & ( s . a1 ) = ( 0 )) & ( s . a2 ) = 1) & ( s . a3 ) = n) implies (((( ( IExec (WH,P,s) ) . a1 ) = ( Fib n ) & ( ( IExec (WH,P,s) ) . a2 ) = ( Fib ( n + 1 ) )) & WH is_closed_on s,P) & WH is_halting_on s,P))))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
let n being (Element of ( NAT ));
set a = ( GBP );
A1:now
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
let k being (Element of ( NAT ));
assume that
n = ( ( t . a3 ) + k )
and
A2: ( t . a1 ) = ( Fib k )
and
A3: ( t . a2 ) = ( Fib ( k + 1 ) )
and
A4: ( t . a ) = ( 0 )
and
( t . a3 ) > ( 0 );
thus ( ( IExec (WB,Q,t) ) . a ) = ( 0 ) by A4,Lm5;
thus (WB is_closed_on t,Q & WB is_halting_on t,Q) by SCMPDS_6:20,SCMPDS_6:21;
thus ( ( IExec (WB,Q,t) ) . a3 ) = ( ( t . a3 ) - 1 ) by A4,Lm5;
thus ( ( IExec (WB,Q,t) ) . a1 ) = ( Fib ( k + 1 ) ) by A3,A4,Lm5;
thus ( ( IExec (WB,Q,t) ) . a2 ) = ( ( t . a1 ) + ( t . a2 ) ) by A4,Lm5
.= ( Fib ( ( k + 1 ) + 1 ) ) by A2,A3,PRE_FF:1;
end;
assume (((( s . ( GBP ) ) = ( 0 ) & ( s . a1 ) = ( 0 )) & ( s . a2 ) = 1) & ( s . a3 ) = n);
hence thesis by A1,CKB11:1;
end;
Lm8: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (for n being (Element of ( NAT )) holds ((( ( IExec (( Fib-macro n ),P,s) ) . a1 ) = ( Fib n ) & ( ( IExec (( Fib-macro n ),P,s) ) . a2 ) = ( Fib ( n + 1 ) )) & ( Fib-macro n ) is_halting_on s,P)))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
let n being (Element of ( NAT ));
set a = ( GBP );
set i1 = ( a := ( 0 ) );
set i2 = ( a1 := ( 0 ) );
set i3 = ( a2 := 1 );
set i4 = ( a3 := n );
set I4 = ( ( ( i1 ';' i2 ) ';' i3 ) ';' i4 );
set t1 = ( IExec (I4,P,s) );
set t2 = ( IExec (( ( i1 ';' i2 ) ';' i3 ),P,s) );
set t3 = ( IExec (( i1 ';' i2 ),P,s) );
set t4 = ( Exec (i1,s) );
I: ( Initialize s ) = s by MEMSTR_0:44;
A1: ( t4 . a ) = ( 0 ) by SCMPDS_2:45;
A2: ( t3 . a ) = ( ( Exec (i2,t4) ) . a ) by SCMPDS_5:42
.= ( 0 ) by A1,AMI_3:10,SCMPDS_2:45;
A3: ( t2 . a ) = ( ( Exec (i3,t3) ) . a ) by SCMPDS_5:41
.= ( 0 ) by A2,AMI_3:10,SCMPDS_2:45;
A4: ( t3 . a1 ) = ( ( Exec (i2,t4) ) . a1 ) by SCMPDS_5:42
.= ( 0 ) by SCMPDS_2:45;
A5: ( t2 . a1 ) = ( ( Exec (i3,t3) ) . a1 ) by SCMPDS_5:41
.= ( 0 ) by A4,AMI_3:10,SCMPDS_2:45;
A6: ( t1 . a1 ) = ( ( Exec (i4,t2) ) . a1 ) by SCMPDS_5:41
.= ( 0 ) by A5,AMI_3:10,SCMPDS_2:45;
A7: ( t2 . a2 ) = ( ( Exec (i3,t3) ) . a2 ) by SCMPDS_5:41
.= 1 by SCMPDS_2:45;
A8: ( t1 . a2 ) = ( ( Exec (i4,t2) ) . a2 ) by SCMPDS_5:41
.= 1 by A7,AMI_3:10,SCMPDS_2:45;
A9: ( t1 . a3 ) = ( ( Exec (i4,t2) ) . a3 ) by SCMPDS_5:41
.= n by SCMPDS_2:45;
A10: ( t1 . a ) = ( ( Exec (i4,t2) ) . a ) by SCMPDS_5:41
.= ( 0 ) by A3,AMI_3:10,SCMPDS_2:45;
X1: ( ( Initialize t1 ) . ( GBP ) ) = ( t1 . ( GBP ) ) by SCMPDS_5:15;
X2: ( ( Initialize t1 ) . a1 ) = ( t1 . a1 ) by SCMPDS_5:15;
X3: ( ( Initialize t1 ) . a2 ) = ( t1 . a2 ) by SCMPDS_5:15;
X4: ( ( Initialize t1 ) . a3 ) = ( t1 . a3 ) by SCMPDS_5:15;
B11: (WH is_closed_on ( Initialize t1 ),P & WH is_halting_on ( Initialize t1 ),P) by A6,A8,A9,Lm7,A10,X1,X2,X3,X4;
A11: WH is_closed_on t1,P
proof
(for k being (Element of ( NAT )) holds ( IC ( Comput (( P +* ( stop WH ) ),( Initialize ( Initialize t1 ) ),k) ) ) in ( dom ( stop WH ) )) by B11,SCMPDS_6:def 2;
hence thesis by SCMPDS_6:def 2;
end;
A12: WH is_halting_on t1,P
proof
( P +* ( stop WH ) ) halts_on ( Initialize ( Initialize t1 ) ) by B11,SCMPDS_6:def 3;
hence thesis by SCMPDS_6:def 3;
end;
( ( IExec (WH,P,( Initialize t1 )) ) . a1 ) = ( Fib n ) by A10,A6,A8,A9,Lm7,X1,X2,X3,X4;
hence ( ( IExec (( Fib-macro n ),P,s) ) . a1 ) = ( Fib n ) by A11,A12,SCPISORT:7;
( ( IExec (WH,P,( Initialize t1 )) ) . a2 ) = ( Fib ( n + 1 ) ) by A10,A6,A8,A9,Lm7,X1,X2,X3,X4;
hence ( ( IExec (( Fib-macro n ),P,s) ) . a2 ) = ( Fib ( n + 1 ) ) by A11,A12,SCPISORT:7;
thus thesis by A11,A12,I,SCPISORT:9;
end;
theorem
(for s being ( 0 ) -started (State of ( SCMPDS )) holds (for n being (Element of ( NAT )) holds ((( ( IExec (( Fib-macro n ),P,s) ) . ( intpos 1 ) ) = ( Fib n ) & ( ( IExec (( Fib-macro n ),P,s) ) . ( intpos 2 ) ) = ( Fib ( n + 1 ) )) & ( Fib-macro n ) is  parahalting)))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
let n being (Element of ( NAT ));
thus (( ( IExec (( Fib-macro n ),P,s) ) . a1 ) = ( Fib n ) & ( ( IExec (( Fib-macro n ),P,s) ) . a2 ) = ( Fib ( n + 1 ) )) by Lm8;
(for t being (State of ( SCMPDS )) holds (for Q holds ( Fib-macro n ) is_halting_on t,Q))
proof
let t being (State of ( SCMPDS ));
let Q;
( Fib-macro n ) is_halting_on ( Initialize t ),Q by Lm8;
hence thesis by SCMPDS_6:126;
end;
hence thesis by SCMPDS_6:21;
end;
