environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMPDS_2,TURING_1,FUNCT_1,CARD_1,SCMFSA_7,RELAT_1,ARYTM_3,CARD_3,FSM_1,XXREAL_0,COMPLEX1,ARYTM_1,AMI_2,SCMPDS_5,SCMPDS_4,INT_1,SCMPDS_8,SCMFSA6B,SCMFSA_9,UNIALG_2,SCMFSA7B,SCMP_GCD,SEMI_AF1,GRAPHSP,AMI_3,FINSEQ_1,SCPISORT,NAT_1,ORDINAL4,SFMASTR2,PRE_FF,FUNCT_4,CIRCUIT2,TARSKI,PBOOLE,MSUALG_1,STRUCT_0,VALUED_1,SCMFSA8B,INT_2,SCPINVAR,ORDINAL1,PARTFUN1,SCMNORM,SCMFSA6C,COMPOS_1;
notations XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,PARTFUN1,VALUED_1,XCMPLX_0,FUNCT_4,PBOOLE,INT_1,INT_2,NAT_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,SCMPDS_2,SCMPDS_4,SCMPDS_6,SCMP_GCD,SCMPDS_5,SCMPDS_8,FUNCT_2,CARD_3,DOMAIN_1,FINSEQ_1,GR_CY_1,PRE_FF,SCPISORT,XXREAL_0,CKB5,CKB6,CKB10,CKB13;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,AMI_3,SCMPDS_2,SCMP_GCD,SCPISORT,MEMSTR_0,CKB5,CKB10,CKB13;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,INT_1,SCMPDS_2,ABSVALUE,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,ENUMSET1,INT_2,SCMPDS_8,SCMP_GCD,SCMPDS_7,FUNCT_1,FINSEQ_1,RVSUM_1,FINSEQ_2,MEMSTR_0,PRE_FF,SCPISORT,XBOOLE_1,XREAL_1,COMPLEX1,XXREAL_0,PREPOWER,ORDINAL1,FUNCOP_1,ZFMISC_1,NAT_D,FINSEQ_3,PBOOLE,PARTFUN1,AFINSQ_1,COMPOS_1,EXTPRO_1,CARD_3,CKB1,CKB2,CKB3,CKB5,CKB7,CKB8,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
schemes NAT_1,SCMPDS_8,FUNCT_2,CKB4,CKB9;
registrations SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,CARD_3,STRUCT_0,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,XBOOLE_0,FINSEQ_1,CARD_1,VALUED_1,VALUED_0,MEMSTR_0,RELAT_1,FUNCT_2,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,FUNCT_4;
constructors DOMAIN_1,REAL_1,NAT_D,RECDEF_1,PRE_FF,MESFUNC1,GR_CY_1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,BINOP_2,AMI_2,MEMSTR_0,RELSET_1,CKB5,CKB6,CKB10,CKB13;
requirements NUMERALS,REAL,SUBSET,ARITHM,BOOLE;
begin
reserve i for (Instruction of ( SCMPDS ));
reserve I for (Program of ( SCMPDS ));
reserve a for Int_position;
reserve P for (Instruction-Sequence of ( SCMPDS ));
theorem
Th17: (for s being (State of ( SCMPDS )) holds (for I being (Program of ( SCMPDS )) holds (for a,c being Int_position holds (for i being Integer holds (( s . ( DataLoc (( s . a ),i) ) ) = ( 0 ) implies ( IExec (( while<>0 (a,i,I) ),P,( Initialize s )) ) = ( s +* ( Start-At (( ( card I ) + 3 ),( SCMPDS )) ) ))))))
proof
let s being (State of ( SCMPDS ));
let I being (Program of ( SCMPDS ));
let a being Int_position;
let c being Int_position;
let i being Integer;
set b = ( DataLoc (( s . a ),i) );
assume A1: ( s . b ) = ( 0 );
set i1 = ( (a,i) <>0_goto 2 );
set i2 = ( goto ( ( card I ) + 2 ) );
set i3 = ( goto ( - ( ( card I ) + 2 ) ) );
set WHL = ( while<>0 (a,i,I) );
set pWH = ( stop WHL );
set iWH = pWH;
set s3 = ( Initialize s );
set P3 = ( P +* pWH );
set s4 = ( Comput (P3,s3,1) );
set s5 = ( Comput (P3,s3,2) );
set P4 = P3;
set P5 = P3;
A3: ( IC s3 ) = ( 0 ) by MEMSTR_0:47;
A4: iWH c= P3 by FUNCT_4:25;
then A5: pWH c= P4;
A6: pWH c= P5 by A4;
A7: (not b in ( dom ( Start-At (( 0 ),( SCMPDS )) ) )) by SCMPDS_4:18;
A8: WHL = ( i1 ';' ( ( i2 ';' I ) ';' i3 ) ) by CKB19:1;
A9: ( Comput (P3,s3,( ( 0 ) + 1 )) ) = ( Following (P3,( Comput (P3,s3,( 0 )) )) ) by EXTPRO_1:3
.= ( Following (P3,s3) ) by EXTPRO_1:2
.= ( Exec (i1,s3) ) by A8,SCMPDS_6:11;
A10: 1 in ( dom WHL ) by CKB17:1;
then 1 in ( dom pWH ) by COMPOS_1:62;
then A11: ( P4 . 1 ) = ( pWH . 1 ) by A5,GRFUNC_1:2
.= ( WHL . 1 ) by A10,COMPOS_1:63
.= i2 by CKB18:1;
set SAl = ( Start-At (( ( card I ) + 3 ),( SCMPDS )) );
(not a in ( dom ( Start-At (( 0 ),( SCMPDS )) ) )) by SCMPDS_4:18;
then ( s3 . ( DataLoc (( s3 . a ),i) ) ) = ( s3 . b ) by FUNCT_4:11
.= ( 0 ) by A1,A7,FUNCT_4:11;
then A13: ( IC s4 ) = ( succ ( IC s3 ) ) by A9,SCMPDS_2:55
.= ( ( 0 ) + 1 ) by A3;
A16: ( P3 /. ( IC s4 ) ) = ( P4 . ( IC s4 ) ) by PBOOLE:143;
A17: ( Comput (P3,s3,( 1 + 1 )) ) = ( Following (P3,s4) ) by EXTPRO_1:3
.= ( Exec (i2,s4) ) by A13,A11,A16;
then A18: ( IC s5 ) = ( ICplusConst (s4,( ( card I ) + 2 )) ) by SCMPDS_2:54
.= ( ( ( card I ) + 2 ) + 1 ) by A13,SCMPDS_6:12
.= ( ( card I ) + ( 2 + 1 ) );
A19: ( P3 /. ( IC s5 ) ) = ( P5 . ( IC s5 ) ) by PBOOLE:143;
A20: ( card WHL ) = ( ( card I ) + 3 ) by CKB14:1;
then ( ( card I ) + 3 ) in ( dom pWH ) by COMPOS_1:64;
then ( P5 . ( ( card I ) + 3 ) ) = ( pWH . ( ( card I ) + 3 ) ) by A6,GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by A20,COMPOS_1:64;
then A21: ( CurInstr (P3,s5) ) = ( halt ( SCMPDS ) ) by A18,A19;
then P3 halts_on s3 by EXTPRO_1:29;
then A22: s5 = ( Result (P3,s3) ) by A21,EXTPRO_1:def 9;
A23: ( IExec (WHL,P,( Initialize s )) ) = ( Result (P3,s3) ) by SCMPDS_4:def 5;
A24:now
let x being set;
A25: ( dom SAl ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume A26: x in ( dom ( IExec (WHL,P,( Initialize s )) ) );
per cases  by A26,SCMPDS_4:6;
suppose A27: x is Int_position;

then x <> ( IC ( SCMPDS ) ) by SCMPDS_2:43;
then A28: (not x in ( dom SAl )) by A25,TARSKI:def 1;
TT: (not x in ( dom ( Start-At (( 0 ),( SCMPDS )) ) )) by A27,SCMPDS_4:18;
thus ( ( IExec (WHL,P,( Initialize s )) ) . x ) = ( s5 . x ) by A22,A23
.= ( s4 . x ) by A17,A27,SCMPDS_2:54
.= ( s3 . x ) by A9,A27,SCMPDS_2:55
.= ( s . x ) by TT,FUNCT_4:11
.= ( ( s +* SAl ) . x ) by A28,FUNCT_4:11;
end;
suppose A29: x = ( IC ( SCMPDS ) );

hence ( ( IExec (WHL,P,( Initialize s )) ) . x ) = ( ( card I ) + 3 ) by A18,A22,A23
.= ( ( s +* SAl ) . x ) by A29,FUNCT_4:113;
end;
end;
( dom ( IExec (WHL,P,( Initialize s )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( s +* SAl ) ) by PARTFUN1:def 2;
hence thesis by A24,FUNCT_1:2;
end;
