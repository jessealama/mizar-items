environ
vocabularies NUMBERS,XBOOLE_0,FINSEQ_1,FINSEQ_6,SUBSET_1,RELAT_1,FINSEQ_4,XXREAL_0,FINSEQ_5,ARYTM_1,ARYTM_3,ORDINAL4,RFINSEQ,PARTFUN1,FUNCT_1,GOBOARD5,PRE_TOPC,EUCLID,CARD_1,PSCOMP_1,TOPREAL1,SPRECT_2;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,XXREAL_0,FUNCT_1,PARTFUN1,FINSEQ_1,FINSEQ_4,FINSEQ_5,RFINSEQ,FINSEQ_6,NAT_1,NAT_D,PRE_TOPC,EUCLID,TOPREAL1,GOBOARD5,PSCOMP_1,SPRECT_2;
definitions FUNCT_1;
theorems FINSEQ_6,FINSEQ_4,FINSEQ_5,FINSEQ_3,NAT_1,FINSEQ_1,TARSKI,GOBOARD7,RFINSEQ,REVROT_1,SPRECT_2,XBOOLE_0,XREAL_1,XXREAL_0,PARTFUN1,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7;
registrations XBOOLE_0,RELSET_1,XREAL_0,FINSEQ_6,STRUCT_0,SPRECT_2,REVROT_1,ORDINAL1,FUNCT_1,FINSEQ_1,CKB8;
constructors XXREAL_0,FINSEQ_4,RFINSEQ,FINSEQ_5,GOBOARD5,PSCOMP_1,SPRECT_2,NAT_D,RELSET_1;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve f for non constant  standard special_circular_sequence;
reserve q for (Point of ( TOP-REAL 2 ));
theorem
Th9: ((1 < ( q .. f ) & q in ( rng f )) implies ( ( f /. 1 ) .. ( Rotate (f,q) ) ) = ( ( ( len f ) + 1 ) - ( q .. f ) ))
proof
assume that
A1: 1 < ( q .. f )
and
A2: q in ( rng f );
set i = ( ( 1 + ( len f ) ) -' ( q .. f ) );
A3: ( ( q .. f ) - 1 ) > ( 0 ) by A1,XREAL_1:50;
A4: ( q .. f ) <= ( len f ) by A2,FINSEQ_4:21;
then A5: ( q .. f ) <= ( ( len f ) + 1 ) by NAT_1:13;
then A6: i = ( ( 1 + ( len f ) ) - ( q .. f ) ) by XREAL_1:233;
then ( i + ( ( q .. f ) - 1 ) ) = ( len f );
then i < ( len f ) by A3,XREAL_1:29;
then A7: i < ( len ( Rotate (f,q) ) ) by REVROT_1:14;
now
assume ( ( q .. f ) + ( 0 ) ) >= ( len f );
then A8: ( q .. f ) = ( len f ) by A4,XXREAL_0:1;
q = ( f /. ( q .. f ) ) by A2,FINSEQ_5:38
.= ( f /. 1 ) by A8,FINSEQ_6:def 1;
hence contradiction by A1,FINSEQ_6:43;
end;
then A9: ( ( len f ) - ( q .. f ) ) > ( 0 ) by XREAL_1:20;
i = ( 1 + ( ( len f ) - ( q .. f ) ) ) by A6;
then A10: ( 1 + ( 0 ) ) < i by A9,XREAL_1:6;
then A11: i in ( dom ( Rotate (f,q) ) ) by A7,FINSEQ_3:25;
A12: ( f /. 1 ) = ( ( Rotate (f,q) ) /. ( ( 1 + ( len f ) ) -' ( q .. f ) ) ) by A1,A2,REVROT_1:18;
then A13: ( f /. 1 ) = ( ( Rotate (f,q) ) . i ) by A11,PARTFUN1:def 6;
(for j being set holds ((j in ( dom ( Rotate (f,q) ) ) & j <> i) implies ( ( Rotate (f,q) ) . j ) <> ( f /. 1 )))
proof
let z being set;
assume that
A14: z in ( dom ( Rotate (f,q) ) )
and
A15: z <> i;
reconsider j = z as (Element of ( NAT )) by A14;
per cases  by A15,XXREAL_0:1;
suppose A16: j < i;

1 <= j by A14,FINSEQ_3:25;
then ( ( Rotate (f,q) ) /. j ) <> ( f /. 1 ) by A12,A7,A16,GOBOARD7:36;
hence thesis by A14,PARTFUN1:def 6;
end;
suppose A17: i < j;

j <= ( len ( Rotate (f,q) ) ) by A14,FINSEQ_3:25;
then ( ( Rotate (f,q) ) /. j ) <> ( f /. 1 ) by A12,A10,A17,GOBOARD7:37;
hence thesis by A14,PARTFUN1:def 6;
end;
end;
then A18: ( Rotate (f,q) ) just_once_values ( f /. 1 ) by A11,A13,FINSEQ_4:7;
then ( ( 1 + ( len f ) ) -' ( q .. f ) ) = ( ( Rotate (f,q) ) <- ( f /. 1 ) ) by A11,A13,FINSEQ_4:def 3;
hence ( ( f /. 1 ) .. ( Rotate (f,q) ) ) = ( ( 1 + ( len f ) ) -' ( q .. f ) ) by A18,FINSEQ_4:25
.= ( ( ( len f ) + 1 ) - ( q .. f ) ) by A5,XREAL_1:233;
end;
