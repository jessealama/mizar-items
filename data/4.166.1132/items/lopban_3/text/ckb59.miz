environ
vocabularies NUMBERS,RLVECT_1,ALGSTR_0,XBOOLE_0,NORMSP_1,NAT_1,SUBSET_1,FUNCT_1,SUPINF_2,SERIES_1,ARYTM_3,CARD_1,SEQ_2,FUNCOP_1,REAL_1,XXREAL_0,ARYTM_1,CARD_3,ORDINAL2,RSSPACE3,VALUED_0,RELAT_1,XREAL_0,ORDINAL1,COMPLEX1,XXREAL_2,LOPBAN_1,SEQ_1,POWER,LOPBAN_2,MESFUNC1,REWRITE1,VECTSP_1,BINOP_1,PREPOWER,STRUCT_0,COMSEQ_3,PRE_TOPC,VALUED_1,LOPBAN_3;
notations TARSKI,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,PRE_TOPC,DOMAIN_1,FUNCOP_1,XREAL_0,XXREAL_0,COMPLEX1,REAL_1,NAT_1,STRUCT_0,ALGSTR_0,ORDINAL1,NUMBERS,RLVECT_1,GROUP_1,VECTSP_1,NORMSP_0,NORMSP_1,RSSPACE3,VALUED_1,SEQ_1,SEQ_2,VALUED_0,SERIES_1,PREPOWER,POWER,BHSP_4,LOPBAN_1,LOPBAN_2,RECDEF_1,CKB2,CKB4,CKB5,CKB53,CKB54,CKB55,CKB56,CKB57,CKB58;
definitions SEQ_2,SERIES_1,NORMSP_1,BHSP_3,RLVECT_1,BINOP_1,ALGSTR_0,VECTSP_1,NORMSP_0,CKB2,CKB4,CKB5,CKB53,CKB54,CKB55,CKB56,CKB58;
theorems ABSVALUE,RLVECT_1,VECTSP_1,FUNCSDOM,SEQ_1,SEQ_2,SEQM_3,SERIES_1,NAT_1,INT_1,FUNCT_2,NORMSP_1,SEQ_4,RSSPACE3,LOPBAN_1,PREPOWER,LOPBAN_2,GROUP_1,FUNCOP_1,XREAL_1,COMPLEX1,XXREAL_0,ORDINAL1,BHSP_4,VALUED_0,ALGSTR_0,NORMSP_0,CKB1,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB19,CKB20,CKB21,CKB24,CKB25,CKB28,CKB29,CKB31,CKB32,CKB34,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB51,CKB53,CKB54,CKB55,CKB56,CKB58;
schemes NAT_1,FUNCT_2;
registrations XBOOLE_0,SUBSET_1,ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,MEMBERED,STRUCT_0,NORMSP_1,LOPBAN_2,ALGSTR_0,GCD_1,VALUED_1,FUNCT_2,VALUED_0,FUNCOP_1,NORMSP_0,CKB3,CKB18,CKB22,CKB23,CKB26,CKB27,CKB30,CKB33,CKB35,CKB50,CKB52;
constructors PARTFUN1,DOMAIN_1,XXREAL_0,REAL_1,NAT_1,COMPLEX1,SEQ_2,BINOP_2,PREPOWER,SERIES_1,BHSP_3,BHSP_4,RSSPACE3,LOPBAN_2,SEQ_1,GCD_1,VALUED_1,RECDEF_1,NORMSP_1,RELSET_1,CKB2,CKB4,CKB5,CKB54,CKB55,CKB56;
requirements SUBSET,REAL,BOOLE,NUMERALS,ARITHM;
begin
definition
let X being Banach_Algebra;
let z being (Element of X);
func z GeoSeq -> (sequence of X) means 
:Def13: (( it . ( 0 ) ) = ( 1. X ) & (for n being (Element of ( NAT )) holds ( it . ( n + 1 ) ) = ( ( it . n ) * z )));
existence
proof
deffunc G(set,set) = ( (the multF of X) . [ $2,z ] );
consider g being Function such that A1: ((( dom g ) = ( NAT ) & ( g . ( 0 ) ) = ( 1. X )) & (for n being Nat holds ( g . ( n + 1 ) ) = G(n,( g . n )))) from NAT_1:sch 11;
defpred P[ (Element of ( NAT )) ]
 means
( g . $1 ) in (the carrier of X);
A2: (for k being (Element of ( NAT )) holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume P[ k ];
then reconsider gk = ( g . k ) as (Element of X);
( g . ( k + 1 ) ) = ( (the multF of X) . [ gk,z ] ) by A1;
hence thesis;
end;
A3: P[ ( 0 ) ] by A1;
(for n being (Element of ( NAT )) holds P[ n ]) from NAT_1:sch 1(A3,A2);
then (for n being set holds (n in ( NAT ) implies ( g . n ) in (the carrier of X)));
then reconsider g0 = g as (sequence of X) by A1,FUNCT_2:3;
take g0;
thus thesis by A1;
end;
uniqueness
proof
let seq1 being (sequence of X);
let seq2 being (sequence of X);
assume that
A4: ( seq1 . ( 0 ) ) = ( 1. X )
and
A5: (for n being (Element of ( NAT )) holds ( seq1 . ( n + 1 ) ) = ( ( seq1 . n ) * z ))
and
A6: ( seq2 . ( 0 ) ) = ( 1. X )
and
A7: (for n being (Element of ( NAT )) holds ( seq2 . ( n + 1 ) ) = ( ( seq2 . n ) * z ));
defpred P[ (Element of ( NAT )) ]
 means
( seq1 . $1 ) = ( seq2 . $1 );
A8: (for k being (Element of ( NAT )) holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume P[ k ];
hence ( seq1 . ( k + 1 ) ) = ( ( seq2 . k ) * z ) by A5
.= ( seq2 . ( k + 1 ) ) by A7;
end;
A9: P[ ( 0 ) ] by A4,A6;
(for n being (Element of ( NAT )) holds P[ n ]) from NAT_1:sch 1(A9,A8);
hence seq1 = seq2 by FUNCT_2:63;
end;
end;
