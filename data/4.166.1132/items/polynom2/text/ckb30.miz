environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,FINSEQ_1,RELAT_1,PARTFUN1,CARD_1,FUNCT_1,TARSKI,XXREAL_0,ARYTM_1,ARYTM_3,NAT_1,ORDERS_1,RELAT_2,GROUP_1,BINOP_1,ALGSTR_0,RLVECT_1,VECTSP_1,LATTICES,ZFMISC_1,FINSET_1,ALGSTR_1,STRUCT_0,SUPINF_2,CARD_3,FINSOP_1,ORDINAL4,PRE_POLY,FINSEQ_5,FUNCT_4,FUNCOP_1,ORDINAL1,WELLORD2,MESFUNC1,RFINSEQ,POLYNOM1,ALGSEQ_1,QC_LANG1,MSSUBFAM,QUOFIELD,POLYNOM2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FINSOP_1,RELAT_2,RELSET_1,FUNCT_1,FINSET_1,ORDINAL1,PARTFUN1,FUNCT_2,BINOP_1,FUNCT_4,FUNCT_7,REAL_1,NAT_1,ALGSTR_1,ORDERS_1,FINSEQ_1,STRUCT_0,ALGSTR_0,RLVECT_1,FUNCOP_1,VFUNCT_1,VECTSP_1,GROUP_1,GROUP_4,QUOFIELD,FINSEQ_5,GRCAT_1,RFINSEQ,YELLOW_1,GROUP_6,XXREAL_0,RECDEF_1,PRE_POLY,POLYNOM1,CKB20,CKB22,CKB24,CKB25;
definitions QUOFIELD,GROUP_1,BINOP_1,FUNCOP_1,ALGSTR_0,CKB20,CKB25;
theorems TARSKI,FINSEQ_1,FUNCT_1,FUNCT_2,ORDINAL1,RELAT_1,ZFMISC_1,VECTSP_1,POLYNOM1,RELAT_2,WELLORD2,FUNCT_7,FUNCT_4,FUNCOP_1,ORDERS_1,NAT_1,FINSEQ_4,GRCAT_1,INT_1,FINSEQ_3,RLVECT_1,GROUP_4,PARTFUN2,CARD_1,RFINSEQ,FINSOP_1,FINSEQ_5,CARD_2,FINSEQ_2,ALGSTR_1,GROUP_1,XBOOLE_0,XBOOLE_1,PARTFUN1,XREAL_1,GROUP_6,XXREAL_0,VALUED_0,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB23,CKB25,CKB26,CKB27,CKB28,CKB29;
schemes FUNCT_2,NAT_1,RECDEF_1,INT_1;
registrations XBOOLE_0,ORDINAL1,RELSET_1,FUNCOP_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,STRUCT_0,VECTSP_1,ALGSTR_1,MONOID_0,POLYNOM1,VALUED_0,CARD_1,SUBSET_1,PRE_POLY,RELAT_1,VFUNCT_1,FUNCT_2,FUNCT_1,CKB5,CKB21;
constructors XXREAL_0,REAL_1,FINSOP_1,RFINSEQ,BINARITH,FINSEQ_5,GROUP_4,GRCAT_1,GROUP_6,MONOID_0,TRIANG_1,YELLOW_1,QUOFIELD,POLYNOM1,RECDEF_1,ALGSTR_1,RELSET_1,FUNCT_7,FVSUM_1,VFUNCT_1,CKB20,CKB22,CKB24,CKB25;
requirements NUMERALS,BOOLE,SUBSET,REAL,ARITHM;
begin
theorem
Lm9: (for n being Ordinal holds (for L being  right_zeroed  add-associative  right_complementable  Abelian  well-unital  distributive non  trivial  commutative  associative non  empty doubleLoopStr holds (for b1 being (bag of n) holds ((ex u being set st ( support b1 ) = { u }) implies (for b2 being (bag of n) holds (for x being (Function of n,L) holds ( eval (( b1 + b2 ),x) ) = ( ( eval (b1,x) ) * ( eval (b2,x) ) )))))))
proof
let n being Ordinal;
let L being  right_zeroed  add-associative  right_complementable  well-unital  distributive  Abelian  commutative  associative non  trivial doubleLoopStr;
let b1 being (bag of n);
assume (ex u being set st ( support b1 ) = { u });
then consider u being set such that A1: ( support b1 ) = { u };
let b2 being (bag of n);
let x being (Function of n,L);
A2: ( support ( b1 + b2 ) ) = ( ( support b2 ) \/ { u } ) by A1,PRE_POLY:38;
A3: (for u9 being set holds (u9 <> u implies ( ( b1 + b2 ) . u9 ) = ( b2 . u9 )))
proof
let u9 being set;
assume u9 <> u;
then A4: (not u9 in ( support b1 )) by A1,TARSKI:def 1;
thus ( ( b1 + b2 ) . u9 ) = ( ( b1 . u9 ) + ( b2 . u9 ) ) by PRE_POLY:def 5
.= ( ( 0 ) + ( b2 . u9 ) ) by A4,PRE_POLY:def 7
.= ( b2 . u9 );
end;
set sb2 = ( SgmX (( RelIncl n ),( support b2 )) );
set sb1b2 = ( SgmX (( RelIncl n ),( support ( b1 + b2 ) )) );
A5: n c= ( dom x ) by FUNCT_2:def 1;
A6: ( RelIncl n ) linearly_orders ( support b2 ) by CKB23:1;
consider yb1b2 being (FinSequence of (the carrier of L)) such that A7: ( len yb1b2 ) = ( len sb1b2 ) and A8: ( eval (( b1 + b2 ),x) ) = ( Product yb1b2 ) and A9: (for i being (Element of ( NAT )) holds ((1 <= i & i <= ( len yb1b2 )) implies ( yb1b2 /. i ) = ( ( power L ) . (( ( x * sb1b2 ) /. i ),( ( ( b1 + b2 ) * sb1b2 ) /. i )) ))) by CKB25:def 1;
consider yb2 being (FinSequence of (the carrier of L)) such that A10: ( len yb2 ) = ( len sb2 ) and A11: ( eval (b2,x) ) = ( Product yb2 ) and A12: (for i being (Element of ( NAT )) holds ((1 <= i & i <= ( len yb2 )) implies ( yb2 /. i ) = ( ( power L ) . (( ( x * sb2 ) /. i ),( ( b2 * sb2 ) /. i )) ))) by CKB25:def 1;
per cases ;
suppose A13: u in ( support b2 );

consider sb2k being Nat such that A14: ( dom sb2 ) = ( Seg sb2k ) by FINSEQ_1:def 2;
A15: (for v being set holds (v in ( support b2 ) implies v in ( support ( b1 + b2 ) )))
proof
let v being set;
assume A16: v in ( support b2 );
now
per cases ;
case u = v;
then v in { u } by TARSKI:def 1;
hence thesis by A2,XBOOLE_0:def 3;
end;
case u <> v;
then ( ( b1 + b2 ) . v ) = ( b2 . v ) by A3;
then ( ( b1 + b2 ) . v ) <> ( 0 ) by A16,PRE_POLY:def 7;
hence thesis by PRE_POLY:def 7;
end;
end;
hence thesis;
end;
A17: (for v being set holds (v in ( support ( b1 + b2 ) ) implies v in ( support b2 )))
proof
let v being set;
assume A18: v in ( support ( b1 + b2 ) );
now
per cases  by A2,A18,XBOOLE_0:def 3;
case v in { u };
hence thesis by A13,TARSKI:def 1;
end;
case v in ( support b2 );
hence thesis;
end;
end;
hence thesis;
end;
then A19: ( len yb1b2 ) = ( len yb2 ) by A7,A10,A15,TARSKI:1;
A20: ( support ( b1 + b2 ) ) = ( support b2 ) by A17,A15,TARSKI:1;
u in ( rng sb2 ) by A6,A13,PRE_POLY:def 2;
then consider k being Nat such that A21: k in ( dom sb2 ) and A22: ( sb2 . k ) = u by FINSEQ_2:10;
reconsider k as (Element of ( NAT )) by ORDINAL1:def 12;
A23: 1 <= k by A21,A14,FINSEQ_1:1;
A24: ( support b2 ) c= ( dom b2 ) by PRE_POLY:37;
then A25: k in ( dom ( b2 * sb2 ) ) by A13,A21,A22,FUNCT_1:11;
then A26: ( ( b2 * sb2 ) /. k ) = ( ( b2 * sb2 ) . k ) by PARTFUN1:def 6
.= ( b2 . u ) by A22,A25,FUNCT_1:12;
A27: ( rng x ) c= (the carrier of L) by RELAT_1:def 19;
consider sb1b2k being Nat such that A28: ( dom sb1b2 ) = ( Seg sb1b2k ) by FINSEQ_1:def 2;
( support ( b1 + b2 ) ) c= ( dom ( b1 + b2 ) ) by PRE_POLY:37;
then A29: k in ( dom ( ( b1 + b2 ) * sb2 ) ) by A13,A20,A21,A22,FUNCT_1:11;
then A30: ( ( ( b1 + b2 ) * sb2 ) /. k ) = ( ( ( b1 + b2 ) * sb2 ) . k ) by PARTFUN1:def 6
.= ( ( b1 + b2 ) . u ) by A22,A29,FUNCT_1:12;
consider i being Nat such that A31: ( dom yb2 ) = ( Seg i ) by FINSEQ_1:def 2;
reconsider sb2k,sb1b2k as (Element of ( NAT )) by ORDINAL1:def 12;
A32: k <= sb2k by A21,A14,FINSEQ_1:1;
i in ( NAT ) by ORDINAL1:def 12;
then A33: ( len yb2 ) = i by A31,FINSEQ_1:def 3;
A34: sb2k = ( len yb2 ) by A10,A14,FINSEQ_1:def 3;
then A35: k in ( dom yb2 ) by A21,A14,FINSEQ_1:def 3;
A36: sb2k = ( len sb2 ) by A14,FINSEQ_1:def 3
.= ( len sb1b2 ) by A17,A15,TARSKI:1
.= sb1b2k by A28,FINSEQ_1:def 3;
then ( len yb1b2 ) = sb2k by A7,A28,FINSEQ_1:def 3;
then A37: ( yb1b2 /. k ) = ( ( power L ) . (( ( x * sb2 ) /. k ),( ( ( b1 + b2 ) * sb2 ) /. k )) ) by A9,A20,A23,A32
.= ( ( power L ) . (( ( x * sb2 ) /. k ),( ( b1 . u ) + ( b2 . u ) )) ) by A30,PRE_POLY:def 5
.= ( ( ( power L ) . (( ( x * sb2 ) /. k ),( b1 . u )) ) * ( ( power L ) . (( ( x * sb2 ) /. k ),( ( b2 * sb2 ) /. k )) ) ) by A26,CKB4:1
.= ( ( ( power L ) . (( ( x * sb2 ) /. k ),( b1 . u )) ) * ( yb2 /. k ) ) by A12,A23,A32,A34;
A38: ( dom ( b1 + b2 ) ) = n by PARTFUN1:def 2;
A39: (for i9 being (Element of ( NAT )) holds ((i9 in ( dom yb2 ) & i9 <> k) implies ( yb1b2 /. i9 ) = ( yb2 /. i9 )))
proof
( rng sb1b2 ) c= ( dom b2 ) by A6,A20,A24,PRE_POLY:def 2;
then A40: ( rng sb1b2 ) c= n by PARTFUN1:def 2;
A41: ( rng sb2 ) c= ( dom b2 ) by A6,A24,PRE_POLY:def 2;
let i9 being (Element of ( NAT ));
assume that
A42: i9 in ( dom yb2 )
and
A43: i9 <> k;
A44: 1 <= i9 by A31,A42,FINSEQ_1:1;
A45: i9 in ( dom sb2 ) by A10,A31,A33,A42,FINSEQ_1:def 3;
then ( sb2 . i9 ) in ( rng sb2 ) by FUNCT_1:def 3;
then A46: i9 in ( dom ( b2 * sb2 ) ) by A45,A41,FUNCT_1:11;
then A47: ( ( b2 * sb2 ) /. i9 ) = ( ( b2 * sb2 ) . i9 ) by PARTFUN1:def 6
.= ( b2 . ( sb2 . i9 ) ) by A46,FUNCT_1:12
.= ( b2 . ( sb2 /. i9 ) ) by A45,PARTFUN1:def 6;
A48: i9 <= ( len yb2 ) by A31,A33,A42,FINSEQ_1:1;
A49: i9 in ( Seg sb1b2k ) by A36,A34,A42,FINSEQ_1:def 3;
A50: ( sb1b2 /. i9 ) <> u
proof
assume ( sb1b2 /. i9 ) = u;
then A51: ( sb1b2 . i9 ) = u by A28,A49,PARTFUN1:def 6;
A52: sb1b2 is  one-to-one by CKB23:1,PRE_POLY:10;
( sb1b2 . k ) = u by A17,A15,A22,TARSKI:1;
hence thesis by A21,A14,A28,A36,A43,A49,A51,A52,FUNCT_1:def 4;
end;
( sb1b2 . i9 ) in ( rng sb1b2 ) by A28,A49,FUNCT_1:def 3;
then A53: i9 in ( dom ( ( b1 + b2 ) * sb1b2 ) ) by A28,A38,A49,A40,FUNCT_1:11;
then ( ( ( b1 + b2 ) * sb1b2 ) /. i9 ) = ( ( ( b1 + b2 ) * sb1b2 ) . i9 ) by PARTFUN1:def 6
.= ( ( b1 + b2 ) . ( sb1b2 . i9 ) ) by A53,FUNCT_1:12
.= ( ( b1 + b2 ) . ( sb1b2 /. i9 ) ) by A28,A49,PARTFUN1:def 6;
hence ( yb1b2 /. i9 ) = ( ( power L ) . (( ( x * sb1b2 ) /. i9 ),( ( b1 + b2 ) . ( sb1b2 /. i9 ) )) ) by A9,A19,A44,A48
.= ( ( power L ) . (( ( x * sb2 ) /. i9 ),( b2 . ( sb2 /. i9 ) )) ) by A3,A20,A50
.= ( yb2 /. i9 ) by A12,A44,A48,A47;
end;
A54: ( support b1 ) c= ( dom b1 ) by PRE_POLY:37;
u in ( support b1 ) by A1,TARSKI:def 1;
then A55: u in ( dom b1 ) by A54;
A56: ( dom b1 ) = n by PARTFUN1:def 2;
then ( x . u ) in ( rng x ) by A5,A55,FUNCT_1:def 3;
then reconsider xu = ( x . u ) as (Element of L) by A27;
consider a being (Element of L) such that A57: a = ( ( power L ) . (xu,( b1 . u )) );
A58: k in ( dom ( x * sb2 ) ) by A5,A21,A22,A55,A56,FUNCT_1:11;
then ( ( x * sb2 ) . k ) = ( x . ( sb2 . k ) ) by FUNCT_1:12;
then ( yb1b2 /. k ) = ( a * ( yb2 /. k ) ) by A22,A37,A57,A58,PARTFUN1:def 6;
hence ( eval (( b1 + b2 ),x) ) = ( a * ( Product yb2 ) ) by A8,A19,A35,A39,CKB11:1
.= ( ( eval (b1,x) ) * ( eval (b2,x) ) ) by A1,A11,A57,CKB28:1;
end;
suppose A59: (not u in ( support b2 ));

A60: ( support b1 ) c= ( dom b1 ) by PRE_POLY:37;
u in ( support b1 ) by A1,TARSKI:def 1;
then A61: u in ( dom b1 ) by A60;
A62: ( rng x ) c= (the carrier of L) by RELAT_1:def 19;
( dom b1 ) = n by PARTFUN1:def 2;
then ( x . u ) in ( rng x ) by A5,A61,FUNCT_1:def 3;
then reconsider xu = ( x . u ) as (Element of L) by A62;
consider a being (Element of L) such that A63: a = ( ( power L ) . (xu,( ( b1 + b2 ) . u )) );
A64: ( ( b1 + b2 ) . u ) = ( ( b1 . u ) + ( b2 . u ) ) by PRE_POLY:def 5
.= ( ( b1 . u ) + ( 0 ) ) by A59,PRE_POLY:def 7;
thus ( eval (( b1 + b2 ),x) ) = ( a * ( eval (b2,x) ) ) by A3,A2,A59,A63,CKB29:1
.= ( ( eval (b1,x) ) * ( eval (b2,x) ) ) by A1,A64,A63,CKB28:1;
end;
end;
