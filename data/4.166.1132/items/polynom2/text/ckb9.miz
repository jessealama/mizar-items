environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,FINSEQ_1,RELAT_1,PARTFUN1,CARD_1,FUNCT_1,TARSKI,XXREAL_0,ARYTM_1,ARYTM_3,NAT_1,ORDERS_1,RELAT_2,GROUP_1,BINOP_1,ALGSTR_0,RLVECT_1,VECTSP_1,LATTICES,ZFMISC_1,FINSET_1,ALGSTR_1,STRUCT_0,SUPINF_2,CARD_3,FINSOP_1,ORDINAL4,PRE_POLY,FINSEQ_5,FUNCT_4,FUNCOP_1,ORDINAL1,WELLORD2,MESFUNC1,RFINSEQ,POLYNOM1,ALGSEQ_1,QC_LANG1,MSSUBFAM,QUOFIELD,POLYNOM2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FINSOP_1,RELAT_2,RELSET_1,FUNCT_1,FINSET_1,ORDINAL1,PARTFUN1,FUNCT_2,BINOP_1,FUNCT_4,FUNCT_7,REAL_1,NAT_1,ALGSTR_1,ORDERS_1,FINSEQ_1,STRUCT_0,ALGSTR_0,RLVECT_1,FUNCOP_1,VFUNCT_1,VECTSP_1,GROUP_1,GROUP_4,QUOFIELD,FINSEQ_5,GRCAT_1,RFINSEQ,YELLOW_1,GROUP_6,XXREAL_0,RECDEF_1,PRE_POLY,POLYNOM1;
definitions QUOFIELD,GROUP_1,BINOP_1,FUNCOP_1,ALGSTR_0;
theorems TARSKI,FINSEQ_1,FUNCT_1,FUNCT_2,ORDINAL1,RELAT_1,ZFMISC_1,VECTSP_1,POLYNOM1,RELAT_2,WELLORD2,FUNCT_7,FUNCT_4,FUNCOP_1,ORDERS_1,NAT_1,FINSEQ_4,GRCAT_1,INT_1,FINSEQ_3,RLVECT_1,GROUP_4,PARTFUN2,CARD_1,RFINSEQ,FINSOP_1,FINSEQ_5,CARD_2,FINSEQ_2,ALGSTR_1,GROUP_1,XBOOLE_0,XBOOLE_1,PARTFUN1,XREAL_1,GROUP_6,XXREAL_0,VALUED_0,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB6,CKB7,CKB8;
schemes FUNCT_2,NAT_1,RECDEF_1,INT_1;
registrations XBOOLE_0,ORDINAL1,RELSET_1,FUNCOP_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,STRUCT_0,VECTSP_1,ALGSTR_1,MONOID_0,POLYNOM1,VALUED_0,CARD_1,SUBSET_1,PRE_POLY,RELAT_1,VFUNCT_1,FUNCT_2,FUNCT_1,CKB5;
constructors XXREAL_0,REAL_1,FINSOP_1,RFINSEQ,BINARITH,FINSEQ_5,GROUP_4,GRCAT_1,GROUP_6,MONOID_0,TRIANG_1,YELLOW_1,QUOFIELD,POLYNOM1,RECDEF_1,ALGSTR_1,RELSET_1,FUNCT_7,FVSUM_1,VFUNCT_1;
requirements NUMERALS,BOOLE,SUBSET,REAL,ARITHM;
begin
theorem
(for L being  add-associative  right_zeroed  right_complementable  distributive  well-unital non  empty doubleLoopStr holds (for p being (FinSequence of (the carrier of L)) holds ((ex i being (Element of ( NAT )) st (i in ( dom p ) & ( p /. i ) = ( 0. L ))) implies ( Product p ) = ( 0. L ))))
proof
let L being  add-associative  right_zeroed  right_complementable  distributive  well-unital non  empty doubleLoopStr;
let p being (FinSequence of (the carrier of L));
given i being (Element of ( NAT )) such that
A1: i in ( dom p )
and
A2: ( p /. i ) = ( 0. L );

defpred P[ (Element of ( NAT )) ]
 means
(for p being (FinSequence of (the carrier of L)) holds ((( len p ) = $1 & (ex i being (Element of ( NAT )) st (i in ( dom p ) & ( p /. i ) = ( 0. L )))) implies ( Product p ) = ( 0. L )));
A3: (for j being (Element of ( NAT )) holds (P[ j ] implies P[ ( j + 1 ) ]))
proof
let j being (Element of ( NAT ));
assume A4: P[ j ];
(for p being (FinSequence of (the carrier of L)) holds ((( len p ) = ( j + 1 ) & (ex i being (Element of ( NAT )) st (i in ( dom p ) & ( p /. i ) = ( 0. L )))) implies ( Product p ) = ( 0. L )))
proof
let p being (FinSequence of (the carrier of L));
assume that
A5: ( len p ) = ( j + 1 )
and
A6: (ex i being (Element of ( NAT )) st (i in ( dom p ) & ( p /. i ) = ( 0. L )));
A7: (ex fp being (Function of ( NAT ),(the carrier of L)) st ((( fp . 1 ) = ( p . 1 ) & (for i being (Element of ( NAT )) holds ((( 0 ) <> i & i < ( len p )) implies ( fp . ( i + 1 ) ) = ( (the multF of L) . (( fp . i ),( p . ( i + 1 ) )) )))) & ( (the multF of L) "**" p ) = ( fp . ( len p ) ))) by A5,FINSOP_1:1,NAT_1:14;
A8: ( len p ) >= 1 by A5,NAT_1:14;
then A9: 1 in ( dom p ) by FINSEQ_3:25;
A10: ( dom p ) = ( Seg ( len p ) ) by FINSEQ_1:def 3;
then A11: ( j + 1 ) in ( dom p ) by A5,A8,FINSEQ_1:1;
per cases ;
suppose A12: j = ( 0 );

then A13: ( dom p ) = { 1 } by A5,FINSEQ_1:2,FINSEQ_1:def 3;
( Product p ) = ( p . 1 ) by A5,A7,A12,GROUP_4:def 2
.= ( p /. 1 ) by A9,PARTFUN1:def 6;
hence thesis by A6,A13,TARSKI:def 1;
end;
suppose j <> ( 0 );

then A14: 1 <= j by NAT_1:14;
reconsider p9 = ( p | ( Seg j ) ) as (FinSequence of (the carrier of L)) by FINSEQ_1:18;
A15: j <= ( j + 1 ) by XREAL_1:29;
then A16: ( dom p9 ) = ( Seg j ) by A5,FINSEQ_1:17;
p = ( p9 ^ <* ( p . ( len p ) ) *> ) by A5,FINSEQ_3:55;
then A17: p = ( p9 ^ <* ( p /. ( len p ) ) *> ) by A5,A11,PARTFUN1:def 6;
A18: ( len p9 ) = j by A5,A15,FINSEQ_1:17;
now
per cases ;
case ( p /. ( len p ) ) = ( 0. L );
hence ( Product p ) = ( ( Product p9 ) * ( 0. L ) ) by A17,GROUP_4:6
.= ( 0. L ) by VECTSP_1:6;
end;
case A19: ( p /. ( len p ) ) <> ( 0. L );
consider i being (Element of ( NAT )) such that A20: i in ( dom p ) and A21: ( p /. i ) = ( 0. L ) by A6;
i <= ( len p ) by A10,A20,FINSEQ_1:1;
then i < ( len p ) by A19,A21,XXREAL_0:1;
then A22: i <= j by A5,NAT_1:13;
A23: 1 <= i by A10,A20,FINSEQ_1:1;
then A24: i in ( dom p9 ) by A16,A22,FINSEQ_1:1;
A25: j in ( dom p ) by A5,A10,A14,A15,FINSEQ_1:1;
i in ( Seg j ) by A23,A22,FINSEQ_1:1;
then ( ( p | j ) . i ) = ( p . i ) by A25,RFINSEQ:6;
then ( p9 . i ) = ( p . i ) by FINSEQ_1:def 15;
then ( p9 /. i ) = ( p . i ) by A24,PARTFUN1:def 6;
then A26: ( p9 /. i ) = ( 0. L ) by A20,A21,PARTFUN1:def 6;
thus ( Product p ) = ( ( Product p9 ) * ( p /. ( len p ) ) ) by A17,GROUP_4:6
.= ( ( 0. L ) * ( p /. ( len p ) ) ) by A4,A18,A24,A26
.= ( 0. L ) by VECTSP_1:7;
end;
end;
hence thesis;
end;
end;
hence thesis;
end;
A27: (ex l being (Element of ( NAT )) st l = ( len p ));
A28: P[ ( 0 ) ]
proof
let p being (FinSequence of L);
assume ( len p ) = ( 0 );
then p = ( {} );
hence thesis;
end;
(for j being (Element of ( NAT )) holds P[ j ]) from NAT_1:sch 1(A28,A3);
hence thesis by A1,A2,A27;
end;
