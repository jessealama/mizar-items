environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,FINSEQ_1,RELAT_1,PARTFUN1,CARD_1,FUNCT_1,TARSKI,XXREAL_0,ARYTM_1,ARYTM_3,NAT_1,ORDERS_1,RELAT_2,GROUP_1,BINOP_1,ALGSTR_0,RLVECT_1,VECTSP_1,LATTICES,ZFMISC_1,FINSET_1,ALGSTR_1,STRUCT_0,SUPINF_2,CARD_3,FINSOP_1,ORDINAL4,PRE_POLY,FINSEQ_5,FUNCT_4,FUNCOP_1,ORDINAL1,WELLORD2,MESFUNC1,RFINSEQ,POLYNOM1,ALGSEQ_1,QC_LANG1,MSSUBFAM,QUOFIELD,POLYNOM2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FINSOP_1,RELAT_2,RELSET_1,FUNCT_1,FINSET_1,ORDINAL1,PARTFUN1,FUNCT_2,BINOP_1,FUNCT_4,FUNCT_7,REAL_1,NAT_1,ALGSTR_1,ORDERS_1,FINSEQ_1,STRUCT_0,ALGSTR_0,RLVECT_1,FUNCOP_1,VFUNCT_1,VECTSP_1,GROUP_1,GROUP_4,QUOFIELD,FINSEQ_5,GRCAT_1,RFINSEQ,YELLOW_1,GROUP_6,XXREAL_0,RECDEF_1,PRE_POLY,POLYNOM1,CKB20,CKB22,CKB24,CKB25,CKB36,CKB37;
definitions QUOFIELD,GROUP_1,BINOP_1,FUNCOP_1,ALGSTR_0,CKB20,CKB25,CKB36,CKB37;
theorems TARSKI,FINSEQ_1,FUNCT_1,FUNCT_2,ORDINAL1,RELAT_1,ZFMISC_1,VECTSP_1,POLYNOM1,RELAT_2,WELLORD2,FUNCT_7,FUNCT_4,FUNCOP_1,ORDERS_1,NAT_1,FINSEQ_4,GRCAT_1,INT_1,FINSEQ_3,RLVECT_1,GROUP_4,PARTFUN2,CARD_1,RFINSEQ,FINSOP_1,FINSEQ_5,CARD_2,FINSEQ_2,ALGSTR_1,GROUP_1,XBOOLE_0,XBOOLE_1,PARTFUN1,XREAL_1,GROUP_6,XXREAL_0,VALUED_0,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB23,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB33,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43;
schemes FUNCT_2,NAT_1,RECDEF_1,INT_1;
registrations XBOOLE_0,ORDINAL1,RELSET_1,FUNCOP_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,STRUCT_0,VECTSP_1,ALGSTR_1,MONOID_0,POLYNOM1,VALUED_0,CARD_1,SUBSET_1,PRE_POLY,RELAT_1,VFUNCT_1,FUNCT_2,FUNCT_1,CKB5,CKB21,CKB32,CKB34;
constructors XXREAL_0,REAL_1,FINSOP_1,RFINSEQ,BINARITH,FINSEQ_5,GROUP_4,GRCAT_1,GROUP_6,MONOID_0,TRIANG_1,YELLOW_1,QUOFIELD,POLYNOM1,RECDEF_1,ALGSTR_1,RELSET_1,FUNCT_7,FVSUM_1,VFUNCT_1,CKB20,CKB22,CKB24,CKB25,CKB36,CKB37;
requirements NUMERALS,BOOLE,SUBSET,REAL,ARITHM;
begin
theorem
Th25: (for n being Ordinal holds (for L being  right_zeroed  add-associative  right_complementable  Abelian  well-unital  distributive non  trivial doubleLoopStr holds (for p,q being (Polynomial of n,L) holds (for x being (Function of n,L) holds ( eval (( p + q ),x) ) = ( ( eval (p,x) ) + ( eval (q,x) ) )))))
proof
let n being Ordinal;
let L being  right_zeroed  add-associative  right_complementable  Abelian  well-unital  distributive non  trivial doubleLoopStr;
let p being (Polynomial of n,L);
let q being (Polynomial of n,L);
let x being (Function of n,L);
defpred P[ (Element of ( NAT )) ]
 means
(for p being (Polynomial of n,L) holds (( card ( Support p ) ) = $1 implies ( eval (( p + q ),x) ) = ( ( eval (p,x) ) + ( eval (q,x) ) )));
A1: (ex k being (Element of ( NAT )) st ( card ( Support p ) ) = k);
A2: (for k being (Element of ( NAT )) holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume A3: P[ k ];
let p being (Polynomial of n,L);
assume A4: ( card ( Support p ) ) = ( k + 1 );
set sgp = ( SgmX (( BagOrder n ),( Support p )) );
set bg = ( sgp /. ( len sgp ) );
A5: ( BagOrder n ) linearly_orders ( Support p ) by CKB35:1;
then sgp <> ( {} ) by A4,CARD_1:27,PRE_POLY:def 2,RELAT_1:38;
then 1 <= ( len sgp ) by NAT_1:14;
then ( len sgp ) in ( Seg ( len sgp ) ) by FINSEQ_1:1;
then A6: ( len sgp ) in ( dom sgp ) by FINSEQ_1:def 3;
then ( sgp /. ( len sgp ) ) = ( sgp . ( len sgp ) ) by PARTFUN1:def 6;
then bg in ( rng sgp ) by A6,FUNCT_1:def 3;
then A7: bg in ( Support p ) by A5,PRE_POLY:def 2;
then A8: ( p . bg ) <> ( 0. L ) by POLYNOM1:def 3;
set m = ( ( 0_ (n,L) ) +* (bg,( p . bg )) );
set p9 = ( p +* (bg,( 0. L )) );
reconsider bg as (bag of n);
( dom p ) = ( Bags n ) by FUNCT_2:def 1;
then A9: p9 = ( p +* ( bg .--> ( 0. L ) ) ) by FUNCT_7:def 3;
reconsider p9 as (Function of ( Bags n ),(the carrier of L));
reconsider p9 as (Function of ( Bags n ),L);
(for u being set holds (u in ( Support p9 ) implies u in ( Support p )))
proof
let u being set;
assume A10: u in ( Support p9 );
then reconsider u as (Element of ( Bags n ));
reconsider u as (bag of n);
now
assume A11: u = bg;
then u in { bg } by TARSKI:def 1;
then u in ( dom ( bg .--> ( 0. L ) ) ) by FUNCOP_1:13;
then ( p9 . u ) = ( ( bg .--> ( 0. L ) ) . bg ) by A9,A11,FUNCT_4:13;
then ( p9 . u ) = ( 0. L ) by FUNCOP_1:72;
hence contradiction by A10,POLYNOM1:def 3;
end;
then (not u in { bg }) by TARSKI:def 1;
then (not u in ( dom ( bg .--> ( 0. L ) ) )) by FUNCOP_1:13;
then ( p . u ) = ( p9 . u ) by A9,FUNCT_4:11;
then ( p . u ) <> ( 0. L ) by A10,POLYNOM1:def 3;
hence thesis by POLYNOM1:def 3;
end;
then ( Support p9 ) c= ( Support p ) by TARSKI:def 3;
then reconsider p9 as (Polynomial of n,L) by POLYNOM1:def 4;
A12: ( dom p ) = ( Bags n ) by FUNCT_2:def 1;
A13: (for u being set holds (u in ( Support p ) implies u in ( ( Support p9 ) \/ { bg } )))
proof
let u being set;
assume A14: u in ( Support p );
then reconsider u as (Element of ( Bags n ));
A15: ( p . u ) <> ( 0. L ) by A14,POLYNOM1:def 3;
per cases ;
suppose u = bg;

then u in { bg } by TARSKI:def 1;
hence thesis by XBOOLE_0:def 3;
end;
suppose u <> bg;

then (not u in { bg }) by TARSKI:def 1;
then (not u in ( dom ( bg .--> ( 0. L ) ) )) by FUNCOP_1:13;
then ( p9 . u ) = ( p . u ) by A9,FUNCT_4:11;
then u in ( Support p9 ) by A15,POLYNOM1:def 3;
hence thesis by XBOOLE_0:def 3;
end;
end;
bg in { bg } by TARSKI:def 1;
then bg in ( dom ( bg .--> ( 0. L ) ) ) by FUNCOP_1:13;
then ( p9 . bg ) = ( ( bg .--> ( 0. L ) ) . bg ) by A9,FUNCT_4:13;
then A16: ( p9 . bg ) = ( 0. L ) by FUNCOP_1:72;
then A17: (not bg in ( Support p9 )) by POLYNOM1:def 3;
(for u being set holds (u in ( ( Support p9 ) \/ { bg } ) implies u in ( Support p )))
proof
let u being set;
assume A18: u in ( ( Support p9 ) \/ { bg } );
per cases  by A18,XBOOLE_0:def 3;
suppose A19: u in ( Support p9 );

then reconsider u as (Element of ( Bags n ));
u <> bg by A16,A19,POLYNOM1:def 3;
then (not u in { bg }) by TARSKI:def 1;
then (not u in ( dom ( bg .--> ( 0. L ) ) )) by FUNCOP_1:13;
then A20: ( p9 . u ) = ( p . u ) by A9,FUNCT_4:11;
( p9 . u ) <> ( 0. L ) by A19,POLYNOM1:def 3;
hence thesis by A20,POLYNOM1:def 3;
end;
suppose u in { bg };

hence thesis by A7,TARSKI:def 1;
end;
end;
then ( Support p ) = ( ( Support p9 ) \/ { bg } ) by A13,TARSKI:1;
then A21: ( k + 1 ) = ( ( card ( Support p9 ) ) + 1 ) by A4,A17,CARD_2:41;
( dom ( 0_ (n,L) ) ) = ( Bags n ) by FUNCT_2:def 1;
then A22: m = ( ( 0_ (n,L) ) +* ( bg .--> ( p . bg ) ) ) by FUNCT_7:def 3;
reconsider m as (Function of ( Bags n ),(the carrier of L));
reconsider m as (Function of ( Bags n ),L);
A23: (for u being set holds (u in ( Support m ) implies u in { bg }))
proof
let u being set;
assume A24: u in ( Support m );
then reconsider u as (Element of ( Bags n ));
A25: ( m . u ) <> ( 0. L ) by A24,POLYNOM1:def 3;
now
assume u <> bg;
then (not u in { bg }) by TARSKI:def 1;
then (not u in ( dom ( bg .--> ( p . bg ) ) )) by FUNCOP_1:13;
then ( m . u ) = ( ( 0_ (n,L) ) . u ) by A22,FUNCT_4:11;
hence contradiction by A25,POLYNOM1:22;
end;
hence thesis by TARSKI:def 1;
end;
(for u being set holds (u in { bg } implies u in ( Support m )))
proof
let u being set;
bg in { bg } by TARSKI:def 1;
then bg in ( dom ( bg .--> ( p . bg ) ) ) by FUNCOP_1:13;
then ( m . bg ) = ( ( bg .--> ( p . bg ) ) . bg ) by A22,FUNCT_4:13;
then A26: ( m . bg ) = ( p . bg ) by FUNCOP_1:72;
assume u in { bg };
then u = bg by TARSKI:def 1;
hence thesis by A8,A26,POLYNOM1:def 3;
end;
then A27: ( Support m ) = { bg } by A23,TARSKI:1;
then reconsider m as (Polynomial of n,L) by POLYNOM1:def 4;
reconsider m as (Polynomial of n,L);
A28: (for u being set holds (u in ( Bags n ) implies ( ( p9 + m ) . u ) = ( p . u )))
proof
let u being set;
assume u in ( Bags n );
then reconsider u as (bag of n);
per cases ;
suppose A29: u = bg;

bg in { bg } by TARSKI:def 1;
then bg in ( dom ( bg .--> ( p . bg ) ) ) by FUNCOP_1:13;
then ( m . bg ) = ( ( bg .--> ( p . bg ) ) . bg ) by A22,FUNCT_4:13;
then A30: ( m . bg ) = ( p . bg ) by FUNCOP_1:72;
u in { bg } by A29,TARSKI:def 1;
then u in ( dom ( bg .--> ( 0. L ) ) ) by FUNCOP_1:13;
then A31: ( p9 . u ) = ( ( bg .--> ( 0. L ) ) . bg ) by A9,A29,FUNCT_4:13;
( ( p9 + m ) . u ) = ( ( p9 . u ) + ( m . u ) ) by POLYNOM1:15
.= ( ( 0. L ) + ( p . bg ) ) by A29,A31,A30,FUNCOP_1:72
.= ( p . bg ) by RLVECT_1:def 4;
hence thesis by A29;
end;
suppose u <> bg;

then A32: (not u in { bg }) by TARSKI:def 1;
then A33: (not u in ( dom ( bg .--> ( 0. L ) ) )) by FUNCOP_1:13;
(not u in ( dom ( bg .--> ( p . bg ) ) )) by A32,FUNCOP_1:13;
then ( m . u ) = ( ( 0_ (n,L) ) . u ) by A22,FUNCT_4:11;
then A34: ( m . u ) = ( 0. L ) by POLYNOM1:22;
( ( p9 + m ) . u ) = ( ( p9 . u ) + ( m . u ) ) by POLYNOM1:15
.= ( ( p . u ) + ( 0. L ) ) by A9,A33,A34,FUNCT_4:11
.= ( p . u ) by RLVECT_1:def 4;
hence thesis;
end;
end;
A35: ( dom ( p9 + m ) ) = ( Bags n ) by FUNCT_2:def 1;
then ( eval (p,x) ) = ( eval (( m + p9 ),x) ) by A12,A28,FUNCT_1:2
.= ( ( eval (p9,x) ) + ( eval (m,x) ) ) by A27,CKB43:1;
hence ( ( eval (p,x) ) + ( eval (q,x) ) ) = ( ( ( eval (p9,x) ) + ( eval (q,x) ) ) + ( eval (m,x) ) ) by RLVECT_1:def 3
.= ( ( eval (( p9 + q ),x) ) + ( eval (m,x) ) ) by A3,A21
.= ( eval (( m + ( p9 + q ) ),x) ) by A27,CKB43:1
.= ( eval (( ( p9 + m ) + q ),x) ) by POLYNOM1:21
.= ( eval (( p + q ),x) ) by A35,A12,A28,FUNCT_1:2;
end;
A36: P[ ( 0 ) ]
proof
let p being (Polynomial of n,L);
assume ( card ( Support p ) ) = ( 0 );
then ( Support p ) = ( {} );
then A37: p = ( 0_ (n,L) ) by CKB33:1;
hence ( eval (( p + q ),x) ) = ( eval (q,x) ) by POLYNOM1:23
.= ( ( 0. L ) + ( eval (q,x) ) ) by RLVECT_1:4
.= ( ( eval (p,x) ) + ( eval (q,x) ) ) by A37,CKB39:1;
end;
(for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A36,A2);
hence thesis by A1;
end;
