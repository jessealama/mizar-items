environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,FINSEQ_1,RELAT_1,PARTFUN1,CARD_1,FUNCT_1,TARSKI,XXREAL_0,ARYTM_1,ARYTM_3,NAT_1,ORDERS_1,RELAT_2,GROUP_1,BINOP_1,ALGSTR_0,RLVECT_1,VECTSP_1,LATTICES,ZFMISC_1,FINSET_1,ALGSTR_1,STRUCT_0,SUPINF_2,CARD_3,FINSOP_1,ORDINAL4,PRE_POLY,FINSEQ_5,FUNCT_4,FUNCOP_1,ORDINAL1,WELLORD2,MESFUNC1,RFINSEQ,POLYNOM1,ALGSEQ_1,QC_LANG1,MSSUBFAM,QUOFIELD,POLYNOM2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FINSOP_1,RELAT_2,RELSET_1,FUNCT_1,FINSET_1,ORDINAL1,PARTFUN1,FUNCT_2,BINOP_1,FUNCT_4,FUNCT_7,REAL_1,NAT_1,ALGSTR_1,ORDERS_1,FINSEQ_1,STRUCT_0,ALGSTR_0,RLVECT_1,FUNCOP_1,VFUNCT_1,VECTSP_1,GROUP_1,GROUP_4,QUOFIELD,FINSEQ_5,GRCAT_1,RFINSEQ,YELLOW_1,GROUP_6,XXREAL_0,RECDEF_1,PRE_POLY,POLYNOM1,CKB20,CKB22,CKB24,CKB25,CKB36,CKB37;
definitions QUOFIELD,GROUP_1,BINOP_1,FUNCOP_1,ALGSTR_0,CKB20,CKB25,CKB36,CKB37;
theorems TARSKI,FINSEQ_1,FUNCT_1,FUNCT_2,ORDINAL1,RELAT_1,ZFMISC_1,VECTSP_1,POLYNOM1,RELAT_2,WELLORD2,FUNCT_7,FUNCT_4,FUNCOP_1,ORDERS_1,NAT_1,FINSEQ_4,GRCAT_1,INT_1,FINSEQ_3,RLVECT_1,GROUP_4,PARTFUN2,CARD_1,RFINSEQ,FINSOP_1,FINSEQ_5,CARD_2,FINSEQ_2,ALGSTR_1,GROUP_1,XBOOLE_0,XBOOLE_1,PARTFUN1,XREAL_1,GROUP_6,XXREAL_0,VALUED_0,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB23,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB33,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45;
schemes FUNCT_2,NAT_1,RECDEF_1,INT_1;
registrations XBOOLE_0,ORDINAL1,RELSET_1,FUNCOP_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,STRUCT_0,VECTSP_1,ALGSTR_1,MONOID_0,POLYNOM1,VALUED_0,CARD_1,SUBSET_1,PRE_POLY,RELAT_1,VFUNCT_1,FUNCT_2,FUNCT_1,CKB5,CKB21,CKB32,CKB34;
constructors XXREAL_0,REAL_1,FINSOP_1,RFINSEQ,BINARITH,FINSEQ_5,GROUP_4,GRCAT_1,GROUP_6,MONOID_0,TRIANG_1,YELLOW_1,QUOFIELD,POLYNOM1,RECDEF_1,ALGSTR_1,RELSET_1,FUNCT_7,FVSUM_1,VFUNCT_1,CKB20,CKB22,CKB24,CKB25,CKB36,CKB37;
requirements NUMERALS,BOOLE,SUBSET,REAL,ARITHM;
begin
theorem
Lm12: (for n being Ordinal holds (for L being  right_zeroed  add-associative  right_complementable  Abelian  well-unital  distributive non trivial  commutative  associative non empty doubleLoopStr holds (for p,q being (Polynomial of n,L) holds (for b1,b2 being (bag of n) holds ((( Support p ) = { b1 } & ( Support q ) = { b2 }) implies (for x being (Function of n,L) holds ( eval (( p *' q ),x) ) = ( ( eval (p,x) ) * ( eval (q,x) ) )))))))
proof
let n being Ordinal;
let L being  right_zeroed  add-associative  right_complementable  Abelian  well-unital  distributive  commutative  associative non trivial doubleLoopStr;
let p being (Polynomial of n,L),q being (Polynomial of n,L);
let b1 being (bag of n),b2 being (bag of n);
assume that
A1: ( Support p ) = { b1 }
and
A2: ( Support q ) = { b2 };
consider s being (FinSequence of (the carrier of L)) such that A3: ( ( p *' q ) . ( b1 + b2 ) ) = ( Sum s ) and A4: ( len s ) = ( len ( decomp ( b1 + b2 ) ) ) and A5: (for k being (Element of ( NAT )) holds (k in ( dom s ) implies (ex u1,u2 being (bag of n) st (( ( decomp ( b1 + b2 ) ) /. k ) = <* u1,u2 *> & ( s /. k ) = ( ( p . u1 ) * ( q . u2 ) ))))) by POLYNOM1:def 9;
A6: ( b1 + b2 ) is (Element of ( Bags n )) by PRE_POLY:def 12;
let x being (Function of n,L);
A7: ( ( ( p . b1 ) * ( q . b2 ) ) * ( ( eval (b1,x) ) * ( eval (b2,x) ) ) ) = ( ( ( ( p . b1 ) * ( q . b2 ) ) * ( eval (b1,x) ) ) * ( eval (b2,x) ) ) by GROUP_1:def 3
.= ( ( ( ( p . b1 ) * ( eval (b1,x) ) ) * ( q . b2 ) ) * ( eval (b2,x) ) ) by GROUP_1:def 3
.= ( ( ( p . b1 ) * ( eval (b1,x) ) ) * ( ( q . b2 ) * ( eval (b2,x) ) ) ) by GROUP_1:def 3
.= ( ( eval (p,x) ) * ( ( q . b2 ) * ( eval (b2,x) ) ) ) by A1,CKB38:1
.= ( ( eval (p,x) ) * ( eval (q,x) ) ) by A2,CKB38:1;
A8: (for b being (bag of n) holds (b <> b2 implies ( q . b ) = ( 0. L )))
proof
let b being (bag of n);
assume b <> b2;
then A9: (not b in ( Support q )) by A2,TARSKI:def 1;
b is (Element of ( Bags n )) by PRE_POLY:def 12;
hence thesis by A9,POLYNOM1:def 3;
end;
A10: (for b being (bag of n) holds (b <> b1 implies ( p . b ) = ( 0. L )))
proof
let b being (bag of n);
assume b <> b1;
then A11: (not b in ( Support p )) by A1,TARSKI:def 1;
b is (Element of ( Bags n )) by PRE_POLY:def 12;
hence thesis by A11,POLYNOM1:def 3;
end;
A12: (for u being set holds (u in ( Support ( p *' q ) ) implies u in { ( b1 + b2 ) }))
proof
let u being set;
assume A13: u in ( Support ( p *' q ) );
assume A14: (not u in { ( b1 + b2 ) });
reconsider u as (bag of n) by A13;
consider t being (FinSequence of (the carrier of L)) such that A15: ( ( p *' q ) . u ) = ( Sum t ) and A16: ( len t ) = ( len ( decomp u ) ) and A17: (for k being (Element of ( NAT )) holds (k in ( dom t ) implies (ex b19,b29 being (bag of n) st (( ( decomp u ) /. k ) = <* b19,b29 *> & ( t /. k ) = ( ( p . b19 ) * ( q . b29 ) ))))) by POLYNOM1:def 9;
1 <= ( len t ) by A16,NAT_1:14;
then A18: 1 in ( dom t ) by FINSEQ_3:25;
A19: ( dom t ) = ( Seg ( len t ) ) by FINSEQ_1:def 3
.= ( dom ( decomp u ) ) by A16,FINSEQ_1:def 3;
A20: (for i being (Element of ( NAT )) holds (i in ( dom t ) implies ( t /. i ) = ( 0. L )))
proof
let i being (Element of ( NAT ));
consider S being non empty  finite (Subset of ( Bags n )) such that A21: ( divisors u ) = ( SgmX (( BagOrder n ),S) ) and A22: (for b being (bag of n) holds (b in S iff b divides u)) by PRE_POLY:def 16;
( BagOrder n ) linearly_orders S by CKB3:1;
then A23: S = ( rng ( divisors u ) ) by A21,PRE_POLY:def 2;
assume A24: i in ( dom t );
then consider b19 being (bag of n),b29 being (bag of n) such that A25: ( ( decomp u ) /. i ) = <* b19,b29 *> and A26: ( t /. i ) = ( ( p . b19 ) * ( q . b29 ) ) by A17;
A27: b19 = ( ( divisors u ) /. i ) by A19,A24,A25,PRE_POLY:70;
A28: i in ( dom ( divisors u ) ) by A19,A24,PRE_POLY:def 17;
then b19 = ( ( divisors u ) . i ) by A27,PARTFUN1:def 6;
then b19 in ( rng ( divisors u ) ) by A28,FUNCT_1:def 3;
then A29: b19 divides u by A22,A23;
per cases ;
suppose A30: (b19 = b1 & b29 = b2);

b2 = ( <* b1,b2 *> . 2 ) by FINSEQ_1:44
.= ( <* b1,( u -' b1 ) *> . 2 ) by A19,A24,A25,A27,A30,PRE_POLY:def 17
.= ( u -' b1 ) by FINSEQ_1:44;
then ( b1 + b2 ) = u by A29,A30,PRE_POLY:47;
hence thesis by A14,TARSKI:def 1;
end;
suppose b19 <> b1;

then ( p . b19 ) = ( 0. L ) by A10;
hence thesis by A26,VECTSP_1:7;
end;
suppose b29 <> b2;

then ( q . b29 ) = ( 0. L ) by A8;
hence thesis by A26,VECTSP_1:7;
end;
end;
then (for i being (Element of ( NAT )) holds ((i in ( dom t ) & i <> 1) implies ( t /. i ) = ( 0. L )));
then ( Sum t ) = ( t /. 1 ) by A18,CKB8:1
.= ( 0. L ) by A18,A20;
hence thesis by A13,A15,POLYNOM1:def 3;
end;
consider k being (Element of ( NAT )) such that A31: k in ( dom ( decomp ( b1 + b2 ) ) ) and A32: ( ( decomp ( b1 + b2 ) ) /. k ) = <* b1,b2 *> by PRE_POLY:69;
A33: ( dom s ) = ( Seg ( len s ) ) by FINSEQ_1:def 3
.= ( dom ( decomp ( b1 + b2 ) ) ) by A4,FINSEQ_1:def 3;
then consider b19 being (bag of n),b29 being (bag of n) such that A34: ( ( decomp ( b1 + b2 ) ) /. k ) = <* b19,b29 *> and A35: ( s /. k ) = ( ( p . b19 ) * ( q . b29 ) ) by A5,A31;
A36: b2 = ( <* b1,b2 *> . 2 ) by FINSEQ_1:44
.= b29 by A32,A34,FINSEQ_1:44;
A37: (for k9 being (Element of ( NAT )) holds ((k9 in ( dom s ) & k9 <> k) implies ( s /. k9 ) = ( 0. L )))
proof
let k9 being (Element of ( NAT ));
assume that
A38: k9 in ( dom s )
and
A39: k9 <> k;
consider b19 being (bag of n),b29 being (bag of n) such that A40: ( ( decomp ( b1 + b2 ) ) /. k9 ) = <* b19,b29 *> and A41: ( s /. k9 ) = ( ( p . b19 ) * ( q . b29 ) ) by A5,A38;
per cases ;
suppose A42: (b19 = b1 & b29 = b2);

( ( decomp ( b1 + b2 ) ) . k9 ) = ( ( decomp ( b1 + b2 ) ) /. k9 ) by A33,A38,PARTFUN1:def 6
.= ( ( decomp ( b1 + b2 ) ) . k ) by A31,A32,A40,A42,PARTFUN1:def 6;
hence thesis by A33,A31,A38,A39,FUNCT_1:def 4;
end;
suppose b19 <> b1;

then ( p . b19 ) = ( 0. L ) by A10;
hence thesis by A41,VECTSP_1:7;
end;
suppose b29 <> b2;

then ( q . b29 ) = ( 0. L ) by A8;
hence thesis by A41,VECTSP_1:7;
end;
end;
b1 = ( <* b19,b29 *> . 1 ) by A32,A34,FINSEQ_1:44
.= b19 by FINSEQ_1:44;
then A43: ( ( p *' q ) . ( b1 + b2 ) ) = ( ( p . b1 ) * ( q . b2 ) ) by A3,A33,A31,A35,A36,A37,CKB8:1;
per cases ;
suppose A44: ( ( p . b1 ) * ( q . b2 ) ) = ( 0. L );

then A45: (not ( b1 + b2 ) in ( Support ( p *' q ) )) by A43,POLYNOM1:def 3;
( Support ( p *' q ) ) = ( {} )
proof
set u = the (Element of ( Support ( p *' q ) ));
assume A46: ( Support ( p *' q ) ) <> ( {} );
then A47: u in ( Support ( p *' q ) );
u in { ( b1 + b2 ) } by A12,A46;
hence thesis by A45,A47,TARSKI:def 1;
end;
then ( p *' q ) = ( 0_ (n,L) ) by CKB33:1;
hence ( eval (( p *' q ),x) ) = ( 0. L ) by CKB39:1
.= ( ( eval (p,x) ) * ( eval (q,x) ) ) by A7,A44,VECTSP_1:7;
end;
suppose ( ( p . b1 ) * ( q . b2 ) ) <> ( 0. L );

then ( b1 + b2 ) in ( Support ( p *' q ) ) by A43,A6,POLYNOM1:def 3;
then (for u being set holds (u in { ( b1 + b2 ) } implies u in ( Support ( p *' q ) ))) by TARSKI:def 1;
then ( Support ( p *' q ) ) = { ( b1 + b2 ) } by A12,TARSKI:1;
hence ( eval (( p *' q ),x) ) = ( ( ( p *' q ) . ( b1 + b2 ) ) * ( eval (( b1 + b2 ),x) ) ) by CKB38:1
.= ( ( eval (p,x) ) * ( eval (q,x) ) ) by A43,A7,CKB31:1;
end;
end;
