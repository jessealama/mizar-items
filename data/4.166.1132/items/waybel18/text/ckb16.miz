environ
vocabularies SETFAM_1,XBOOLE_0,CANTOR_1,TARSKI,PRE_TOPC,RLVECT_3,RELAT_1,PRALG_1,FUNCT_1,PBOOLE,FUNCOP_1,WAYBEL_3,STRUCT_0,SUBSET_1,CARD_3,RLVECT_2,RCOMP_1,FUNCT_4,MONOID_0,ORDINAL2,FUNCTOR0,PARTFUN1,FUNCT_6,BORSUK_1,FUNCT_3,GROUP_6,WAYBEL_1,FUNCT_2,T_0TOPSP,TOPS_2,CARD_1,ZFMISC_1,RELAT_2,ORDERS_2,WAYBEL11,YELLOW_9,YELLOW_1,LATTICE3,FILTER_1,XXREAL_0,WAYBEL_0,CARD_FIL,FINSET_1,REWRITE1,WAYBEL_8,LATTICES,CAT_1,WAYBEL_9,WAYBEL18;
notations TARSKI,XBOOLE_0,ENUMSET1,ZFMISC_1,SUBSET_1,SETFAM_1,RELAT_1,PBOOLE,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,DOMAIN_1,NUMBERS,PRALG_3,STRUCT_0,PRE_TOPC,T_0TOPSP,FUNCT_3,FUNCT_6,FUNCT_7,CARD_3,FUNCOP_1,MONOID_0,PRALG_1,ORDERS_2,LATTICE3,YELLOW_1,CANTOR_1,FINSET_1,TOPS_2,BORSUK_1,TMAP_1,YELLOW_0,YELLOW_9,WAYBEL_0,WAYBEL_3,WAYBEL_8,WAYBEL_9,WAYBEL11,CKB3,CKB7,CKB8,CKB10,CKB12,CKB14,CKB15;
definitions STRUCT_0,TARSKI,PRE_TOPC,FUNCOP_1,WAYBEL_1,WAYBEL_3,XBOOLE_0,PRALG_1,CKB3,CKB8,CKB10,CKB15;
theorems TARSKI,PRE_TOPC,ENUMSET1,ZFMISC_1,T_0TOPSP,TOPS_1,TOPS_2,FINSET_1,FUNCT_2,FUNCT_3,RELAT_1,FUNCT_1,BORSUK_1,FUNCOP_1,CANTOR_1,LATTICE3,ORDERS_2,MSSUBFAM,PRALG_1,CARD_3,WAYBEL_3,FUNCT_6,FUNCT_7,TMAP_1,YELLOW_9,YELLOW_0,YELLOW_1,WAYBEL_0,WAYBEL_1,WAYBEL_7,WAYBEL_8,WAYBEL11,WAYBEL13,WAYBEL14,RELSET_1,SETFAM_1,XBOOLE_0,XBOOLE_1,ORDERS_1,MONOID_0,CARD_1,PARTFUN1,CKB1,CKB2,CKB3,CKB8,CKB9,CKB10,CKB15;
schemes SUBSET_1,CLASSES1,FUNCT_1,FRAENKEL;
registrations XBOOLE_0,SUBSET_1,RELSET_1,FUNCT_2,FUNCOP_1,CARD_3,STRUCT_0,PRE_TOPC,BORSUK_1,LATTICE3,YELLOW_0,MONOID_0,WAYBEL_0,YELLOW_1,WAYBEL_3,WAYBEL_8,WAYBEL11,YELLOW_9,WAYBEL17,CKB4,CKB5,CKB6,CKB11,CKB13;
constructors SETFAM_1,FUNCT_3,FUNCT_7,TOPS_2,BORSUK_1,LATTICE3,TMAP_1,T_0TOPSP,CANTOR_1,MONOID_0,PRALG_1,PRALG_3,WAYBEL_3,WAYBEL_5,WAYBEL_8,WAYBEL11,YELLOW_9,BINOP_1,CKB3,CKB7,CKB8,CKB10,CKB12,CKB14,CKB15;
requirements SUBSET,BOOLE;
begin
theorem
Th5: (for I being non  empty set holds (for J being  TopSpace-yielding  non-Empty (ManySortedSet of I) holds (for i being (Element of I) holds (for P being (Subset of ( J . i )) holds ( ( proj (J,i) ) " P ) = ( product ( ( Carrier J ) +* (i,P) ) )))))
proof
let I being non  empty set;
let J being  TopSpace-yielding  non-Empty (ManySortedSet of I);
let i being (Element of I);
let P being (Subset of ( J . i ));
set f = ( ( Carrier J ) +* (i,P) );
A1: ( dom ( Carrier J ) ) = I by PARTFUN1:def 2;
A2: ( dom f ) = ( dom ( Carrier J ) ) by FUNCT_7:30
.= I by PARTFUN1:def 2;
A3: ( product f ) c= ( ( proj (J,i) ) " P )
proof
let x being set;
assume x in ( product f );
then consider g being Function such that A4: x = g and A5: ( dom g ) = ( dom f ) and A6: (for y being set holds (y in ( dom f ) implies ( g . y ) in ( f . y ))) by CARD_3:def 5;
A7: (for j being set holds (j in ( dom ( Carrier J ) ) implies ( g . j ) in ( ( Carrier J ) . j )))
proof
let j being set;
assume j in ( dom ( Carrier J ) );
then A8: j in I by PARTFUN1:def 2;
then A9: (ex R being 1-sorted st (R = ( J . j ) & ( ( Carrier J ) . j ) = (the carrier of R))) by PRALG_1:def 13;
per cases ;
suppose A10: j = i;

( f . i ) = P by A1,FUNCT_7:31;
then ( g . j ) in P by A2,A6,A10;
hence thesis by A9,A10;
end;
suppose j <> i;

then ( f . j ) = ( ( Carrier J ) . j ) by FUNCT_7:32;
hence thesis by A2,A6,A8;
end;
end;
( dom g ) = ( dom ( Carrier J ) ) by A5,FUNCT_7:30;
then A11: g in ( product ( Carrier J ) ) by A7,CARD_3:9;
then A12: g in ( dom ( proj (( Carrier J ),i) ) ) by CARD_3:def 16;
( f . i ) = P by A1,FUNCT_7:31;
then ( g . i ) in P by A2,A6;
then A13: ( ( proj (( Carrier J ),i) ) . g ) in P by A12,CARD_3:def 16;
g in ( dom ( proj (J,i) ) ) by A11,CARD_3:def 16;
hence thesis by A4,A13,FUNCT_1:def 7;
end;
( ( proj (J,i) ) " P ) c= ( product f )
proof
let x being set;
assume A14: x in ( ( proj (J,i) ) " P );
then A15: x in ( dom ( proj (( Carrier J ),i) ) ) by FUNCT_1:def 7;
then x in ( product ( Carrier J ) ) by CARD_3:def 16;
then consider g being Function such that A16: x = g and A17: ( dom g ) = ( dom ( Carrier J ) ) and A18: (for y being set holds (y in ( dom ( Carrier J ) ) implies ( g . y ) in ( ( Carrier J ) . y ))) by CARD_3:def 5;
A19: ( dom g ) = ( dom f ) by A17,FUNCT_7:30;
(for j being set holds (j in ( dom f ) implies ( g . j ) in ( f . j )))
proof
let j being set;
assume j in ( dom f );
then A20: ( g . j ) in ( ( Carrier J ) . j ) by A17,A18,A19;
per cases ;
suppose A21: i = j;

( ( proj (( Carrier J ),i) ) . x ) = ( g . i ) by A15,A16,CARD_3:def 16;
then ( g . i ) in P by A14,FUNCT_1:def 7;
hence thesis by A1,A21,FUNCT_7:31;
end;
suppose i <> j;

hence thesis by A20,FUNCT_7:32;
end;
end;
hence thesis by A16,A19,CARD_3:def 5;
end;
hence thesis by A3,XBOOLE_0:def 10;
end;
