environ
vocabularies SETFAM_1,XBOOLE_0,CANTOR_1,TARSKI,PRE_TOPC,RLVECT_3,RELAT_1,PRALG_1,FUNCT_1,PBOOLE,FUNCOP_1,WAYBEL_3,STRUCT_0,SUBSET_1,CARD_3,RLVECT_2,RCOMP_1,FUNCT_4,MONOID_0,ORDINAL2,FUNCTOR0,PARTFUN1,FUNCT_6,BORSUK_1,FUNCT_3,GROUP_6,WAYBEL_1,FUNCT_2,T_0TOPSP,TOPS_2,CARD_1,ZFMISC_1,RELAT_2,ORDERS_2,WAYBEL11,YELLOW_9,YELLOW_1,LATTICE3,FILTER_1,XXREAL_0,WAYBEL_0,CARD_FIL,FINSET_1,REWRITE1,WAYBEL_8,LATTICES,CAT_1,WAYBEL_9,WAYBEL18;
notations TARSKI,XBOOLE_0,ENUMSET1,ZFMISC_1,SUBSET_1,SETFAM_1,RELAT_1,PBOOLE,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,DOMAIN_1,NUMBERS,PRALG_3,STRUCT_0,PRE_TOPC,T_0TOPSP,FUNCT_3,FUNCT_6,FUNCT_7,CARD_3,FUNCOP_1,MONOID_0,PRALG_1,ORDERS_2,LATTICE3,YELLOW_1,CANTOR_1,FINSET_1,TOPS_2,BORSUK_1,TMAP_1,YELLOW_0,YELLOW_9,WAYBEL_0,WAYBEL_3,WAYBEL_8,WAYBEL_9,WAYBEL11,CKB3,CKB7,CKB8;
definitions STRUCT_0,TARSKI,PRE_TOPC,FUNCOP_1,WAYBEL_1,WAYBEL_3,XBOOLE_0,PRALG_1,CKB3,CKB8;
theorems TARSKI,PRE_TOPC,ENUMSET1,ZFMISC_1,T_0TOPSP,TOPS_1,TOPS_2,FINSET_1,FUNCT_2,FUNCT_3,RELAT_1,FUNCT_1,BORSUK_1,FUNCOP_1,CANTOR_1,LATTICE3,ORDERS_2,MSSUBFAM,PRALG_1,CARD_3,WAYBEL_3,FUNCT_6,FUNCT_7,TMAP_1,YELLOW_9,YELLOW_0,YELLOW_1,WAYBEL_0,WAYBEL_1,WAYBEL_7,WAYBEL_8,WAYBEL11,WAYBEL13,WAYBEL14,RELSET_1,SETFAM_1,XBOOLE_0,XBOOLE_1,ORDERS_1,MONOID_0,CARD_1,PARTFUN1,CKB1,CKB2,CKB3,CKB8,CKB9;
schemes SUBSET_1,CLASSES1,FUNCT_1,FRAENKEL;
registrations XBOOLE_0,SUBSET_1,RELSET_1,FUNCT_2,FUNCOP_1,CARD_3,STRUCT_0,PRE_TOPC,BORSUK_1,LATTICE3,YELLOW_0,MONOID_0,WAYBEL_0,YELLOW_1,WAYBEL_3,WAYBEL_8,WAYBEL11,YELLOW_9,WAYBEL17,CKB4,CKB5,CKB6;
constructors SETFAM_1,FUNCT_3,FUNCT_7,TOPS_2,BORSUK_1,LATTICE3,TMAP_1,T_0TOPSP,CANTOR_1,MONOID_0,PRALG_1,PRALG_3,WAYBEL_3,WAYBEL_5,WAYBEL_8,WAYBEL11,YELLOW_9,BINOP_1,CKB3,CKB7,CKB8;
requirements SUBSET,BOOLE;
begin
definition
let I being set;
let J being  TopSpace-yielding  non-Empty (ManySortedSet of I);
func product J ->  strict TopSpace means 
:Def3: ((the carrier of it) = ( product ( Carrier J ) ) & ( product_prebasis J ) is (prebasis of it));
existence
proof
set X = ( product ( Carrier J ) );
reconsider A = ( product_prebasis J ) as (Subset-Family of X);
consider T being  strict TopStruct such that A1: T = TopStruct (# X,( UniCl ( FinMeetCl A ) ) #);
reconsider T as  strict TopSpace by A1,CKB9:1;
take T;
thus (the carrier of T) = ( product ( Carrier J ) ) by A1;
now
assume ( {} ) in ( rng ( Carrier J ) );
then consider i being set such that A2: i in ( dom ( Carrier J ) ) and A3: ( {} ) = ( ( Carrier J ) . i ) by FUNCT_1:def 3;
A4: ( dom ( Carrier J ) ) = I by PARTFUN1:def 2;
then consider R being 1-sorted such that A5: R = ( J . i ) and A6: ( {} ) = (the carrier of R) by A2,A3,PRALG_1:def 13;
( dom J ) = I by PARTFUN1:def 2;
then R in ( rng J ) by A2,A4,A5,FUNCT_1:def 3;
then reconsider R as non  empty 1-sorted by WAYBEL_3:def 7;
(the carrier of R) = ( {} ) by A6;
hence contradiction;
end;
then X is non  empty by CARD_3:26;
hence thesis by A1,CANTOR_1:18;
end;
uniqueness
proof
let T1 being  strict TopSpace;
let T2 being  strict TopSpace;
assume that
A7: (the carrier of T1) = ( product ( Carrier J ) )
and
A8: ( product_prebasis J ) is (prebasis of T1)
and
A9: (the carrier of T2) = ( product ( Carrier J ) )
and
A10: ( product_prebasis J ) is (prebasis of T2);
now
assume ( {} ) in ( rng ( Carrier J ) );
then consider i being set such that A11: i in ( dom ( Carrier J ) ) and A12: ( {} ) = ( ( Carrier J ) . i ) by FUNCT_1:def 3;
A13: ( dom ( Carrier J ) ) = I by PARTFUN1:def 2;
then consider R being 1-sorted such that A14: R = ( J . i ) and A15: ( {} ) = (the carrier of R) by A11,A12,PRALG_1:def 13;
( dom J ) = I by PARTFUN1:def 2;
then R in ( rng J ) by A11,A13,A14,FUNCT_1:def 3;
then reconsider R as non  empty 1-sorted by WAYBEL_3:def 7;
(the carrier of R) = ( {} ) by A15;
hence contradiction;
end;
then ( product ( Carrier J ) ) <> ( {} ) by CARD_3:26;
then reconsider t1 = T1,t2 = T2 as non  empty TopSpace by A7,A9;
t1 = t2 by A7,A8,A9,A10,CANTOR_1:17;
hence thesis;
end;
end;
