environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,FUNCT_1,FINSEQ_1,TARSKI,RELAT_1,NAT_1,ORDINAL4,ARYTM_3,FINSET_1,CARD_1,ARYTM_1,XXREAL_0,ORDINAL1,TREES_1,AMISTD_3,FINSEQ_2;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,CARD_1,XCMPLX_0,NAT_1,NUMBERS,ORDINAL1,RELAT_1,FUNCT_1,FINSEQ_1,FINSEQ_2,FUNCT_2,FINSET_1,XXREAL_0,CKB1,CKB2,CKB6,CKB15,CKB24,CKB27,CKB29,CKB41,CKB46,CKB47,CKB50,CKB51,CKB52,CKB59,CKB61,CKB64,CKB69,CKB70;
definitions TARSKI,FINSET_1,FUNCT_1,WELLORD2,XBOOLE_0,FUNCOP_1,FINSEQ_2,CKB2,CKB15,CKB24,CKB41,CKB46,CKB47,CKB50,CKB51,CKB52,CKB59,CKB64,CKB69,CKB70;
theorems TARSKI,NAT_1,FINSEQ_1,FINSET_1,FUNCT_1,CARD_1,RELAT_1,GRFUNC_1,CARD_2,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,ORDINAL1,ENUMSET1,FINSEQ_2,FINSEQ_3,FUNCOP_1,FUNCT_2,CKB2,CKB3,CKB4,CKB5,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB28,CKB30,CKB31,CKB32,CKB33,CKB36,CKB37,CKB39,CKB40,CKB41,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB50,CKB51,CKB52,CKB53,CKB54,CKB56,CKB58,CKB59,CKB62,CKB63,CKB64,CKB65,CKB66,CKB67,CKB69,CKB70,CKB71,CKB72,CKB73,CKB74,CKB75;
schemes NAT_1,CLASSES1,XBOOLE_0,FUNCT_2;
registrations XBOOLE_0,RELAT_1,FUNCT_1,ORDINAL1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,FINSEQ_1,CARD_1,RELSET_1,FINSEQ_2,FUNCOP_1,CKB25,CKB26,CKB34,CKB35,CKB38,CKB42,CKB49,CKB55,CKB57,CKB60,CKB68;
constructors ENUMSET1,WELLORD2,XXREAL_0,XREAL_0,NAT_1,FINSEQ_1,FINSEQ_2,FUNCOP_1,FUNCT_2,RELSET_1,CKB15,CKB24,CKB29,CKB41,CKB46,CKB47,CKB50,CKB51,CKB52,CKB59,CKB64,CKB69,CKB70;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve x for set;
reserve y for set;
reserve z for set;
reserve k for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
reserve m for (Element of ( NAT ));
reserve f for Function;
reserve p1 for FinSequence;
reserve p2 for FinSequence;
set D = { ( {} ) };
theorem
( width ( elementary_tree ( n + 1 ) ) ) = ( n + 1 )
proof
set T = ( elementary_tree ( n + 1 ) );
now
{ <* k *>: k < ( n + 1 ) } is  AntiChain_of_Prefixes-like
proof
thus (x in { <* k *>: k < ( n + 1 ) } implies x is FinSequence)
proof
assume x in { <* k *>: k < ( n + 1 ) };
then (ex k st (x = <* k *> & k < ( n + 1 )));
hence thesis;
end;

let p1;
let p2;
assume (p1 in { <* k *>: k < ( n + 1 ) } & p2 in { <* m *>: m < ( n + 1 ) });
then ((ex k st (p1 = <* k *> & k < ( n + 1 ))) & (ex m st (p2 = <* m *> & m < ( n + 1 ))));
hence thesis by CKB9:1;
end;
then reconsider X = { <* k *>: k < ( n + 1 ) } as AntiChain_of_Prefixes;
X c= T by XBOOLE_1:7;
then reconsider X as (AntiChain_of_Prefixes of T) by CKB64:def 1;
take X;
X,( Seg ( n + 1 ) ) are_equipotent 
proof
defpred P[ set,set ]
 means
(ex n st ($1 = <* n *> & $2 = ( n + 1 )));
A1: (((x in X & P[ x,y ]) & P[ x,z ]) implies y = z)
proof
assume x in X;
given n1 being (Element of ( NAT )) such that
A2: (x = <* n1 *> & y = ( n1 + 1 ));

given n2 being (Element of ( NAT )) such that
A3: (x = <* n2 *> & z = ( n2 + 1 ));

( <* n1 *> . 1 ) = n1 by FINSEQ_1:def 8;
hence thesis by A2,A3,FINSEQ_1:def 8;
end;
A4: (x in X implies (ex y st P[ x,y ]))
proof
assume x in X;
then consider k such that A5: x = <* k *> and k < ( n + 1 );
reconsider y = ( k + 1 ) as set;
take y;
thus thesis by A5;
end;
consider f such that A6: (( dom f ) = X & (for x holds (x in X implies P[ x,( f . x ) ]))) from CLASSES1:sch 1(A4);
take f;
thus f is  one-to-one
proof
let x;
let y;
assume that
A7: (x in ( dom f ) & y in ( dom f ))
and
A8: ( f . x ) = ( f . y );
((ex k1 being (Element of ( NAT )) st (x = <* k1 *> & ( f . x ) = ( k1 + 1 ))) & (ex k2 being (Element of ( NAT )) st (y = <* k2 *> & ( f . y ) = ( k2 + 1 )))) by A6,A7;
hence thesis by A8;
end;

thus ( dom f ) = X by A6;
thus ( rng f ) c= ( Seg ( n + 1 ) )
proof
let x;
assume x in ( rng f );
then consider y such that A9: y in ( dom f ) and A10: x = ( f . y ) by FUNCT_1:def 3;
consider k such that A11: y = <* k *> and A12: x = ( k + 1 ) by A6,A9,A10;
consider m such that A13: (y = <* m *> & m < ( n + 1 )) by A6,A9;
(( <* k *> . 1 ) = k & ( <* m *> . 1 ) = m) by FINSEQ_1:def 8;
then (( ( 0 ) + 1 ) <= ( k + 1 ) & ( k + 1 ) <= ( n + 1 )) by A11,A13,NAT_1:13;
hence thesis by A12,FINSEQ_1:1;
end;

let x;
assume A14: x in ( Seg ( n + 1 ) );
then reconsider k = x as (Element of ( NAT ));
A15: 1 <= k by A14,FINSEQ_1:1;
A16: k <= ( n + 1 ) by A14,FINSEQ_1:1;
consider m being Nat such that A17: k = ( 1 + m ) by A15,NAT_1:10;
reconsider m as (Element of ( NAT )) by ORDINAL1:def 12;
m < ( n + 1 ) by A16,A17,NAT_1:13;
then A18: <* m *> in X;
then P[ <* m *>,( f . <* m *> ) ] by A6;
then x = ( f . <* m *> ) by A1,A17,A18;
hence thesis by A6,A18,FUNCT_1:def 3;
end;
then A19: ( card ( Seg ( n + 1 ) ) ) = ( card X ) by CARD_1:5;
hence ( n + 1 ) = ( card X ) by FINSEQ_1:57;
let Y being (AntiChain_of_Prefixes of T);
A20: Y c= T by CKB64:def 1;
A21: (( {} ) in Y implies Y = D)
proof
assume that
A22: ( {} ) in Y
and
A23: Y <> D;
consider x such that A24: (not (x in Y iff x in D)) by A23,TARSKI:1;
A25: ( {} ) <> x by A22,A24,TARSKI:def 1;
reconsider x as (FinSequence of ( NAT )) by A20,A24,CKB28:1;
( {} ) is_a_prefix_of x by XBOOLE_1:2;
then ( {} ),x are_c=-comparable  by XBOOLE_0:def 9;
hence contradiction by A22,A24,A25,CKB59:def 1,TARSKI:def 1;
end;
A26: (( card D ) = 1 & 1 <= ( 1 + n )) by CARD_1:30,NAT_1:11;
now
assume A27: (not ( {} ) in Y);
Y c= X
proof
let x;
assume A28: x in Y;
then (x in { <* k *>: k < ( n + 1 ) } or x in D) by A20,XBOOLE_0:def 3;
hence thesis by A27,A28,TARSKI:def 1;
end;
hence ( card Y ) <= ( card X ) by NAT_1:43;
end;
hence ( card Y ) <= ( card X ) by A19,A21,A26,FINSEQ_1:57;
end;
hence thesis by CKB70:def 1;
end;
