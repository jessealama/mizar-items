environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,FUNCT_1,FINSEQ_1,TARSKI,RELAT_1,NAT_1,ORDINAL4,ARYTM_3,FINSET_1,CARD_1,ARYTM_1,XXREAL_0,ORDINAL1,TREES_1,AMISTD_3,FINSEQ_2;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,CARD_1,XCMPLX_0,NAT_1,NUMBERS,ORDINAL1,RELAT_1,FUNCT_1,FINSEQ_1,FINSEQ_2,FUNCT_2,FINSET_1,XXREAL_0,CKB1,CKB2,CKB6,CKB15,CKB24,CKB27,CKB29,CKB41,CKB46;
definitions TARSKI,FINSET_1,FUNCT_1,WELLORD2,XBOOLE_0,FUNCOP_1,FINSEQ_2,CKB2,CKB15,CKB24,CKB41,CKB46;
theorems TARSKI,NAT_1,FINSEQ_1,FINSET_1,FUNCT_1,CARD_1,RELAT_1,GRFUNC_1,CARD_2,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,ORDINAL1,ENUMSET1,FINSEQ_2,FINSEQ_3,FUNCOP_1,FUNCT_2,CKB2,CKB3,CKB4,CKB5,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB28,CKB30,CKB31,CKB32,CKB33,CKB36,CKB37,CKB39,CKB40,CKB41,CKB43,CKB44,CKB45,CKB46;
schemes NAT_1,CLASSES1,XBOOLE_0,FUNCT_2;
registrations XBOOLE_0,RELAT_1,FUNCT_1,ORDINAL1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,FINSEQ_1,CARD_1,RELSET_1,FINSEQ_2,FUNCOP_1,CKB25,CKB26,CKB34,CKB35,CKB38,CKB42;
constructors ENUMSET1,WELLORD2,XXREAL_0,XREAL_0,NAT_1,FINSEQ_1,FINSEQ_2,FUNCOP_1,FUNCT_2,RELSET_1,CKB15,CKB24,CKB29,CKB41,CKB46;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve X for set;
reserve x for set;
reserve k for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
reserve p for (FinSequence of ( NAT ));
reserve q for (FinSequence of ( NAT ));
reserve r for (FinSequence of ( NAT ));
reserve T for Tree;
reserve T1 for Tree;
definition
let T;
let p;
assume that
A11: p in T;
func T | p -> Tree means 
:Def9: (q in it iff ( p ^ q ) in T);
existence
proof
defpred X[ set ]
 means
(for q holds ($1 = q implies ( p ^ q ) in T));
consider X such that A12: (x in X iff (x in ( ( NAT ) * ) & X[ x ])) from XBOOLE_0:sch 1;
(( <*> ( NAT ) ) in ( ( NAT ) * ) & (for q holds (( <*> ( NAT ) ) = q implies ( p ^ q ) in T))) by A11,FINSEQ_1:34,FINSEQ_1:def 11;
then reconsider X as non  empty set by A12;
A13: X c= ( ( NAT ) * )
proof
let x;
thus thesis by A12;
end;
A14:now
let q;
assume that
A15: q in X;
thus ( ProperPrefixes q ) c= X
proof
let x;
assume x in ( ProperPrefixes q );
then consider r being FinSequence such that A16: x = r and A17: r is_a_proper_prefix_of q by CKB15:def 1;
r is_a_prefix_of q by A17,XBOOLE_0:def 8;
then A18: (ex n st r = ( q | ( Seg n ) )) by CKB2:def 1;
then reconsider r as (FinSequence of ( NAT )) by FINSEQ_1:18;
consider s being FinSequence such that A19: q = ( r ^ s ) by A18,FINSEQ_1:80;
A20: ( p ^ q ) in T by A12,A15;
( p ^ q ) = ( ( p ^ r ) ^ s ) by A19,FINSEQ_1:32;
then (r in ( ( NAT ) * ) & (for q holds (r = q implies ( p ^ q ) in T))) by A20,CKB31:1,FINSEQ_1:def 11;
hence thesis by A12,A16;
end;

end;
now
let q;
let k;
let n;
assume that
A21: ( q ^ <* k *> ) in X
and
A22: n <= k;
( p ^ ( q ^ <* k *> ) ) in T by A12,A21;
then ( ( p ^ q ) ^ <* k *> ) in T by FINSEQ_1:32;
then ( ( p ^ q ) ^ <* n *> ) in T by A22,CKB24:def 1;
then (( q ^ <* n *> ) in ( ( NAT ) * ) & (for r holds (r = ( q ^ <* n *> ) implies ( p ^ r ) in T))) by FINSEQ_1:32,FINSEQ_1:def 11;
hence ( q ^ <* n *> ) in X by A12;
end;
then reconsider X as Tree by A13,A14,CKB24:def 1;
take X;
let q;
thus (q in X implies ( p ^ q ) in T) by A12;
assume ( p ^ q ) in T;
then (q in ( ( NAT ) * ) & (for r being (FinSequence of ( NAT )) holds (q = r implies ( p ^ r ) in T))) by FINSEQ_1:def 11;
hence thesis by A12;
end;
uniqueness
proof
let T1 being Tree;
let T2 being Tree;
assume that
A23: (q in T1 iff ( p ^ q ) in T)
and
A24: (q in T2 iff ( p ^ q ) in T);
now
let x;
thus (x in T1 implies x in T2)
proof
assume A25: x in T1;
then reconsider q = x as (FinSequence of ( NAT )) by CKB28:1;
( p ^ q ) in T by A23,A25;
hence thesis by A24;
end;

assume A26: x in T2;
then reconsider q = x as (FinSequence of ( NAT )) by CKB28:1;
( p ^ q ) in T by A24,A26;
hence x in T1 by A23;
end;
hence thesis by TARSKI:1;
end;
end;
