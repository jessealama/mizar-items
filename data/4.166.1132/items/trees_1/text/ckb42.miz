environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,FUNCT_1,FINSEQ_1,TARSKI,RELAT_1,NAT_1,ORDINAL4,ARYTM_3,FINSET_1,CARD_1,ARYTM_1,XXREAL_0,ORDINAL1,TREES_1,AMISTD_3,FINSEQ_2;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,CARD_1,XCMPLX_0,NAT_1,NUMBERS,ORDINAL1,RELAT_1,FUNCT_1,FINSEQ_1,FINSEQ_2,FUNCT_2,FINSET_1,XXREAL_0,CKB1,CKB2,CKB6,CKB15,CKB24,CKB27,CKB29,CKB41;
definitions TARSKI,FINSET_1,FUNCT_1,WELLORD2,XBOOLE_0,FUNCOP_1,FINSEQ_2,CKB2,CKB15,CKB24,CKB41;
theorems TARSKI,NAT_1,FINSEQ_1,FINSET_1,FUNCT_1,CARD_1,RELAT_1,GRFUNC_1,CARD_2,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,ORDINAL1,ENUMSET1,FINSEQ_2,FINSEQ_3,FUNCOP_1,FUNCT_2,CKB2,CKB3,CKB4,CKB5,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB28,CKB30,CKB31,CKB32,CKB33,CKB36,CKB37,CKB39,CKB40,CKB41;
schemes NAT_1,CLASSES1,XBOOLE_0,FUNCT_2;
registrations XBOOLE_0,RELAT_1,FUNCT_1,ORDINAL1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,FINSEQ_1,CARD_1,RELSET_1,FINSEQ_2,FUNCOP_1,CKB25,CKB26,CKB34,CKB35,CKB38;
constructors ENUMSET1,WELLORD2,XXREAL_0,XREAL_0,NAT_1,FINSEQ_1,FINSEQ_2,FUNCOP_1,FUNCT_2,RELSET_1,CKB15,CKB24,CKB29,CKB41;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve x for set;
reserve y for set;
reserve z for set;
reserve k for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
reserve m for (Element of ( NAT ));
reserve f for Function;
set D = { ( {} ) };
registration
let n;
cluster ( elementary_tree n ) ->  finite;
coherence
proof
set IT = ( elementary_tree n );
IT,( Seg ( n + 1 ) ) are_equipotent 
proof
defpred F[ set,set ]
 means
(($1 = ( {} ) & $2 = 1) or (ex n st ($1 = <* n *> & $2 = ( n + 2 ))));
A12: (((x in IT & F[ x,y ]) & F[ x,z ]) implies y = z)
proof
assume that
x in IT
and
A13: (((x = ( {} ) & y = 1) or (ex n st (x = <* n *> & y = ( n + 2 )))) & ((x = ( {} ) & z = 1) or (ex n st (x = <* n *> & z = ( n + 2 )))));
now
given n1 being (Element of ( NAT )) such that
A14: (x = <* n1 *> & y = ( n1 + 2 ));

given n2 being (Element of ( NAT )) such that
A15: (x = <* n2 *> & z = ( n2 + 2 ));

( <* n1 *> . 1 ) = n1 by FINSEQ_1:def 8;
hence thesis by A14,A15,FINSEQ_1:def 8;
end;
hence thesis by A13;
end;
A16: (x in IT implies (ex y st F[ x,y ]))
proof
assume A17: x in IT;
A18:now
assume x in { <* k *>: k < n };
then consider k such that A19: x = <* k *> and k < n;
reconsider y = ( k + 2 ) as set;
take y;
thus F[ x,y ] by A19;
end;
now
assume A20: x in D;
reconsider y = 1 as set;
take y;
thus F[ x,y ] by A20,TARSKI:def 1;
end;
hence thesis by A17,A18,XBOOLE_0:def 3;
end;
consider f such that A21: (( dom f ) = IT & (for x holds (x in IT implies F[ x,( f . x ) ]))) from CLASSES1:sch 1(A16);
take f;
thus f is  one-to-one
proof
let x;
let y;
assume that
A22: x in ( dom f )
and
A23: y in ( dom f )
and
A24: ( f . x ) = ( f . y );
A25: ((x = ( {} ) & ( f . x ) = 1) or (ex n st (x = <* n *> & ( f . x ) = ( n + 2 )))) by A21,A22;
A26: ((y = ( {} ) & ( f . y ) = 1) or (ex n st (y = <* n *> & ( f . y ) = ( n + 2 )))) by A21,A23;
A27:now
assume that
x = ( {} )
and
A28: ( f . x ) = 1;
given n such that
y = <* n *>
and
A29: ( f . y ) = ( n + 2 );

( ( 0 ) + 1 ) = ( ( n + 1 ) + 1 ) by A24,A28,A29;
hence contradiction;
end;
now
assume that
y = ( {} )
and
A30: ( f . y ) = 1;
given n such that
x = <* n *>
and
A31: ( f . x ) = ( n + 2 );

( ( 0 ) + 1 ) = ( ( n + 1 ) + 1 ) by A24,A30,A31;
hence contradiction;
end;
hence thesis by A24,A25,A26,A27;
end;

thus ( dom f ) = IT by A21;
thus ( rng f ) c= ( Seg ( n + 1 ) )
proof
let x;
assume x in ( rng f );
then consider y such that A32: y in ( dom f ) and A33: x = ( f . y ) by FUNCT_1:def 3;
1 <= ( 1 + n ) by NAT_1:11;
then A34: 1 in ( Seg ( n + 1 ) ) by FINSEQ_1:1;
now
given k such that
A35: y = <* k *>
and
A36: x = ( k + 2 );

(y in { <* j *> where j is (Element of ( NAT )): j < n } or y in D) by A21,A32,XBOOLE_0:def 3;
then consider l being (Element of ( NAT )) such that A37: (y = <* l *> & l < n) by A35,TARSKI:def 1;
(( <* k *> . 1 ) = k & ( <* l *> . 1 ) = l) by FINSEQ_1:def 8;
then ( k + 1 ) <= n by A35,A37,NAT_1:13;
then (( 1 + ( 0 ) ) <= ( ( k + 1 ) + 1 ) & ( ( k + 1 ) + 1 ) <= ( n + 1 )) by XREAL_1:7;
hence thesis by A36,FINSEQ_1:1;
end;
hence thesis by A21,A32,A33,A34;
end;

let x;
assume A38: x in ( Seg ( n + 1 ) );
then reconsider k = x as (Element of ( NAT ));
A39: 1 <= k by A38,FINSEQ_1:1;
A40: k <= ( n + 1 ) by A38,FINSEQ_1:1;
( {} ) in D by TARSKI:def 1;
then A41: ( {} ) in IT by XBOOLE_0:def 3;
then F[ ( {} ),( f . ( {} ) ) ] by A21;
then A42: 1 in ( rng f ) by A21,A41,FUNCT_1:def 3;
now
assume 1 < k;
then ( 1 + 1 ) <= k by NAT_1:13;
then consider m being Nat such that A43: k = ( 2 + m ) by NAT_1:10;
reconsider m as (Element of ( NAT )) by ORDINAL1:def 12;
( ( 1 + 1 ) + m ) = ( 1 + ( 1 + m ) );
then ( 1 + m ) <= n by A40,A43,XREAL_1:6;
then m < n by NAT_1:13;
then <* m *> in { <* j *> where j is (Element of ( NAT )): j < n };
then A44: <* m *> in IT by XBOOLE_0:def 3;
then F[ <* m *>,( f . <* m *> ) ] by A21;
then k = ( f . <* m *> ) by A12,A43,A44;
hence k in ( rng f ) by A21,A44,FUNCT_1:def 3;
end;
hence thesis by A39,A42,XXREAL_0:1;
end;
hence thesis by CARD_1:38;
end;
end;
