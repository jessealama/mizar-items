environ
vocabularies NUMBERS,FUNCT_1,RELAT_1,FUNCT_4,FUNCOP_1,XBOOLE_0,PRE_POLY,TARSKI,CARD_1,UPROOTS,CARD_3,ARYTM_3,FINSEQ_1,NAT_1,XXREAL_0,FINSET_1,SUBSET_1,FINSEQ_2,XREAL_0,ORDINAL1,ARYTM_1,GLIB_003,TREES_1,GLIB_000,GLIB_001,REAL_1,PBOOLE,ZFMISC_1,FUNCT_2,ABIAN,PARTFUN1,MCART_1,GLIB_002,WAYBEL_0,RELAT_2,RCOMP_1,GRAPH_1,GLIB_004;
notations TARSKI,XBOOLE_0,ZFMISC_1,ENUMSET1,CARD_1,NUMBERS,SUBSET_1,DOMAIN_1,MCART_1,XCMPLX_0,XXREAL_0,XREAL_0,REAL_1,RELAT_1,RELSET_1,PARTFUN1,FUNCT_1,FINSEQ_1,FINSEQ_2,SEQ_1,PBOOLE,FUNCT_2,RVSUM_1,ABIAN,ORDINAL1,UPROOTS,FINSET_1,NAT_1,FUNCOP_1,FUNCT_4,GLIB_000,GLIB_001,GLIB_002,GLIB_003,RFUNCT_3,PRE_POLY,CKB12,CKB13,CKB14,CKB15,CKB20,CKB22,CKB23,CKB29,CKB30,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39;
definitions TARSKI,GLIB_000,GLIB_003,RVSUM_1,FUNCOP_1,CKB12,CKB13,CKB14,CKB15,CKB20,CKB23,CKB33,CKB34,CKB35,CKB36,CKB38,CKB39;
theorems CARD_1,CARD_2,FUNCOP_1,ENUMSET1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSET_1,FUNCT_1,FUNCT_2,FUNCT_4,GLIB_000,GLIB_001,GLIB_002,GLIB_003,ABIAN,INT_1,JORDAN12,NAT_1,PARTFUN1,PBOOLE,RELAT_1,RVSUM_1,TARSKI,TREES_1,UPROOTS,XBOOLE_0,XBOOLE_1,XREAL_0,ZFMISC_1,XREAL_1,XXREAL_0,ORDINAL1,FINSOP_1,FUNCT_7,MCART_1,RELSET_1,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB18,CKB19,CKB20,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB33,CKB34,CKB35,CKB36,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47;
schemes NAT_1,SUBSET_1,RECDEF_1,GRAPH_5,CQC_SIM1,PBOOLE;
registrations XBOOLE_0,SUBSET_1,RELAT_1,PARTFUN1,FRAENKEL,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,CARD_1,UPROOTS,MEMBERED,GLIB_000,ABIAN,GLIB_001,GLIB_002,GLIB_003,VALUED_0,FUNCT_2,RELSET_1,PRE_POLY,INT_1,CKB17,CKB21,CKB31,CKB32;
constructors DOMAIN_1,BINOP_2,FINSOP_1,RVSUM_1,GRAPH_2,RFUNCT_3,UPROOTS,GLIB_002,GLIB_003,SEQ_1,XXREAL_2,RELSET_1,PBOOLE,CKB12,CKB13,CKB14,CKB15,CKB20,CKB22,CKB23,CKB30,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39;
requirements ARITHM,BOOLE,NUMERALS,REAL,SUBSET;
begin
theorem
Th23: (for G being  finite  nonnegative-weighted WGraph holds (for s being (Vertex of G) holds (for n being Nat holds (for G2 being (inducedWSubgraph of G,( dom ( ( ( DIJK:CompSeq s ) . n ) `1 ) ),( ( ( DIJK:CompSeq s ) . n ) `2 )) holds (G2 is_mincost_DTree_rooted_at s & (for v being (Vertex of G) holds (v in ( dom ( ( ( DIJK:CompSeq s ) . n ) `1 ) ) implies ( G .min_DPath_cost (s,v) ) = ( ( ( ( DIJK:CompSeq s ) . n ) `1 ) . v ))))))))
proof
let G being  finite  nonnegative-weighted WGraph;
let src being (Vertex of G);
set DCS = ( DIJK:CompSeq src );
set D0 = ( DCS . ( 0 ) );
defpred P[ Nat ]
 means
(for G2 being (inducedWSubgraph of G,( dom ( ( DCS . $1 ) `1 ) ),( ( DCS . $1 ) `2 )) holds (G2 is_mincost_DTree_rooted_at src & (for v being (Vertex of G) holds (v in ( dom ( ( DCS . $1 ) `1 ) ) implies ( G .min_DPath_cost (src,v) ) = ( ( ( DCS . $1 ) `1 ) . v )))));
A1: D0 = ( DIJK:Init src ) by CKB38:def 1;
then A2: ( D0 `1 ) = ( src .--> ( 0 ) ) by MCART_1:7;
then A3: ( dom ( D0 `1 ) ) = { src } by FUNCOP_1:13;
now
let n being Nat;
set Dn = ( DCS . n );
set Dn1 = ( DCS . ( n + 1 ) );
set BE = ( DIJK:NextBestEdges Dn );
set e = ( choose BE );
set source = ( ( the_Source_of G ) . e );
set target = ( ( the_Target_of G ) . e );
set DnE = ( ( Dn `2 ) \/ { e } );
set pc = ( ( Dn `1 ) . source );
set ec = ( ( the_Weight_of G ) . e );
set DnW = the (inducedWSubgraph of G,( dom ( Dn `1 ) ),( Dn `2 ));
A4: Dn1 = ( DIJK:Step Dn ) by CKB38:def 1;
assume A5: P[ n ];
then A6: DnW is_mincost_DTree_rooted_at src;
then A7: DnW is  Tree-like by CKB12:def 1;
let Dn1W being (inducedWSubgraph of G,( dom ( Dn1 `1 ) ),( Dn1 `2 ));
A8: (src in ( dom ( D0 `1 ) ) & ( dom ( D0 `1 ) ) c= ( dom ( Dn `1 ) )) by A3,CKB43:1,TARSKI:def 1;
A9: ( Dn `2 ) c= ( G .edgesBetween ( dom ( Dn `1 ) ) ) by CKB47:1;
then A10: ( card ( Dn `2 ) ) = ( DnW .size() ) by A8,GLIB_000:def 37;
A11: ( Dn `2 ) c= ( G .edgesBetween ( dom ( Dn `1 ) ) ) by CKB47:1;
then A12: ( the_Vertices_of DnW ) = ( dom ( Dn `1 ) ) by A8,GLIB_000:def 37;
A13: ( the_Edges_of DnW ) = ( Dn `2 ) by A8,A11,GLIB_000:def 37;
A14: ( card ( dom ( Dn `1 ) ) ) = ( DnW .order() ) by A8,A9,GLIB_000:def 37;
now
per cases ;
suppose BE = ( {} );

then Dn1 = Dn by A4,CKB34:def 1;
hence (Dn1W is_mincost_DTree_rooted_at src & (for v being (Vertex of G) holds (v in ( dom ( Dn1 `1 ) ) implies ( G .min_DPath_cost (src,v) ) = ( ( Dn1 `1 ) . v )))) by A5;
end;
suppose A15: BE <> ( {} );

set mc = ( G .min_DPath_cost (src,target) );
A16: ( the_Weight_of Dn1W ) = ( ( the_Weight_of G ) | ( the_Edges_of Dn1W ) ) by GLIB_003:def 10;
A17: e DSJoins ( dom ( Dn `1 ) ),( ( the_Vertices_of G ) \ ( dom ( Dn `1 ) ) ),G by A15,CKB33:def 1;
then A18: target in ( ( the_Vertices_of G ) \ ( dom ( Dn `1 ) ) ) by GLIB_000:def 16;
then A19: src <> target by A8,XBOOLE_0:def 5;
A20: (not target in ( dom ( Dn `1 ) )) by A18,XBOOLE_0:def 5;
then A21: ( card ( ( dom ( Dn `1 ) ) \/ { target } ) ) = ( ( card ( dom ( Dn `1 ) ) ) + 1 ) by CARD_2:41;
A22: source in ( dom ( Dn `1 ) ) by A17,GLIB_000:def 16;
A23: Dn1 = [ ( ( Dn `1 ) +* ( target .--> ( pc + ec ) ) ),DnE ] by A4,A15,CKB34:def 1;
then ( Dn1 `1 ) = ( ( Dn `1 ) +* ( target .--> ( pc + ec ) ) ) by MCART_1:7;
then A24: ( dom ( Dn1 `1 ) ) = ( ( dom ( Dn `1 ) ) \/ { target } ) by CKB1:1;
A25: ( Dn1 `2 ) c= ( G .edgesBetween ( dom ( Dn1 `1 ) ) ) by CKB47:1;
then A26: ( the_Vertices_of Dn1W ) = ( ( dom ( Dn `1 ) ) \/ { target } ) by A24,GLIB_000:def 37;
( Dn1 `2 ) = DnE by A23,MCART_1:7;
then A27: ( the_Edges_of Dn1W ) = ( ( Dn `2 ) \/ { e } ) by A24,A25,GLIB_000:def 37;
A28:now
thus (( the_Vertices_of DnW ) c= ( the_Vertices_of Dn1W ) & ( the_Edges_of DnW ) c= ( the_Edges_of Dn1W )) by A12,A13,A26,A27,XBOOLE_1:7;
let e being set;
assume A29: e in ( the_Edges_of DnW );
then A30: ( ( the_Target_of DnW ) . e ) = ( ( the_Target_of G ) . e ) by GLIB_000:def 32;
(e in ( the_Edges_of Dn1W ) & ( ( the_Source_of DnW ) . e ) = ( ( the_Source_of G ) . e )) by A13,A27,A29,GLIB_000:def 32,XBOOLE_0:def 3;
hence (( ( the_Source_of DnW ) . e ) = ( ( the_Source_of Dn1W ) . e ) & ( ( the_Target_of DnW ) . e ) = ( ( the_Target_of Dn1W ) . e )) by A30,GLIB_000:def 32;
end;
then reconsider DnW9 = DnW as  [Weighted] (Subgraph of Dn1W) by GLIB_000:def 32;
e in { e } by TARSKI:def 1;
then A31: e in ( the_Edges_of Dn1W ) by A27,XBOOLE_0:def 3;
e in BE by A15;
then e DJoins source,target,G by GLIB_000:def 14;
then A32: e DJoins source,target,Dn1W by A31,GLIB_000:73;
then A33: e Joins source,target,Dn1W by GLIB_000:16;
A34: ( the_Weight_of DnW9 ) = ( ( the_Weight_of G ) | ( the_Edges_of DnW ) ) by GLIB_003:def 10;
A35:now
let y being set;
assume y in ( dom ( the_Weight_of DnW9 ) );
then A36: y in ( the_Edges_of DnW ) by PARTFUN1:def 2;
hence ( ( the_Weight_of DnW9 ) . y ) = ( ( the_Weight_of G ) . y ) by A34,FUNCT_1:49
.= ( ( the_Weight_of Dn1W ) . y ) by A28,A16,A36,FUNCT_1:49;
end;
( dom ( the_Weight_of Dn1W ) ) = ( the_Edges_of Dn1W ) by PARTFUN1:def 2;
then ( ( dom ( the_Weight_of Dn1W ) ) /\ ( the_Edges_of DnW ) ) = ( the_Edges_of DnW ) by A28,XBOOLE_1:28;
then ( dom ( the_Weight_of DnW9 ) ) = ( ( dom ( the_Weight_of Dn1W ) ) /\ ( the_Edges_of DnW ) ) by PARTFUN1:def 2;
then ( the_Weight_of DnW9 ) = ( ( the_Weight_of Dn1W ) | ( the_Edges_of DnW ) ) by A35,FUNCT_1:46;
then A37: DnW is (WSubgraph of Dn1W) by GLIB_003:def 10;
A38: DnW is (Subgraph of Dn1W) by A28,GLIB_000:def 32;
now
let u being (Vertex of Dn1W),v being (Vertex of Dn1W);
A39:now
let u being set,v being set;
assume (u in ( dom ( Dn `1 ) ) & v in ( dom ( Dn `1 ) ));
then reconsider u9 = u,v9 = v as (Vertex of DnW) by A11,GLIB_000:def 37;
consider W1 being (Walk of DnW) such that A40: W1 is_Walk_from u9,v9 by A7,GLIB_002:def 1;
reconsider W2 = W1 as (Walk of Dn1W) by A38,GLIB_001:167;
W2 is_Walk_from u,v by A40,GLIB_001:19;
hence (ex W being (Walk of Dn1W) st W is_Walk_from u,v);
end;
now
per cases  by A26,XBOOLE_0:def 3;
suppose (u in ( dom ( Dn `1 ) ) & v in ( dom ( Dn `1 ) ));

hence (ex W being (Walk of Dn1W) st W is_Walk_from u,v) by A39;
end;
suppose A41: (u in ( dom ( Dn `1 ) ) & v in { target });

then A42: v = target by TARSKI:def 1;
consider W being (Walk of Dn1W) such that A43: W is_Walk_from u,source by A22,A39,A41;
( W .addEdge e ) is_Walk_from u,target by A33,A43,GLIB_001:66;
hence (ex W being (Walk of Dn1W) st W is_Walk_from u,v) by A42;
end;
suppose A44: (u in { target } & v in ( dom ( Dn `1 ) ));

then consider W being (Walk of Dn1W) such that A45: W is_Walk_from v,source by A22,A39;
( W .addEdge e ) is_Walk_from v,target by A33,A45,GLIB_001:66;
then ( W .addEdge e ) is_Walk_from v,u by A44,TARSKI:def 1;
then ( ( W .addEdge e ) .reverse() ) is_Walk_from u,v by GLIB_001:23;
hence (ex W being (Walk of Dn1W) st W is_Walk_from u,v);
end;
suppose A46: (u in { target } & v in { target });

take W = ( Dn1W .walkOf u );
(u = target & v = target) by A46,TARSKI:def 1;
hence W is_Walk_from u,v by GLIB_001:13;
end;
end;
hence (ex W being (Walk of Dn1W) st W is_Walk_from u,v);
end;
then A47: Dn1W is  connected by GLIB_002:def 1;
A48: (not e in ( Dn `2 )) by A9,A20,GLIB_000:31;
then ( Dn1W .size() ) = ( ( DnW .size() ) + 1 ) by A10,A27,CARD_2:41;
then ( Dn1W .order() ) = ( ( Dn1W .size() ) + 1 ) by A14,A7,A26,A21,GLIB_002:47;
then A49: Dn1W is  Tree-like by A47,GLIB_002:47;
now
consider WT being (DPath of DnW) such that A50: WT is_Walk_from src,source and A51: (for W1 being (DPath of G) holds (W1 is_Walk_from src,source implies ( WT .cost() ) <= ( W1 .cost() ))) by A12,A6,A22,CKB12:def 1;
reconsider WT9 = WT as (DPath of Dn1W) by A38,GLIB_001:175;
set W2 = ( WT9 .addEdge e );
A52: WT9 is_Walk_from src,source by A50,GLIB_001:19;
then reconsider W2 as (DWalk of Dn1W) by A32,GLIB_001:123;
now
target in { target } by TARSKI:def 1;
hence target is (Vertex of Dn1W) by A26,XBOOLE_0:def 3;
thus e Joins ( WT9 .last() ),target,Dn1W by A33,A52,GLIB_001:def 23;
((not e in ( the_Edges_of DnW )) & ( WT .edges() ) = ( WT9 .edges() )) by A8,A9,A48,GLIB_000:def 37,GLIB_001:110;
hence (not e in ( WT9 .edges() ));
now
assume A53: WT9 is non trivial;
now
assume WT9 is  closed;
then WT9 is  Cycle-like by A53,GLIB_001:def 31;
hence contradiction by A49,GLIB_002:def 2;
end;
hence WT9 is  open;
end;
hence (WT9 is  trivial or WT9 is  open);
let n being  odd (Element of ( NAT ));
assume that
1 < n
and
A54: n <= ( len WT9 );
( WT9 .vertices() ) = ( WT .vertices() ) by GLIB_001:98;
then (not target in ( WT9 .vertices() )) by A12,A18,XBOOLE_0:def 5;
hence ( WT9 . n ) <> target by A54,GLIB_001:87;
end;
then reconsider W2 as (DPath of Dn1W) by GLIB_001:150;
take W2;
thus W2 is_Walk_from src,target by A33,A52,GLIB_001:66;
now
(( WT9 .last() ) = source & ( ( the_Source_of Dn1W ) . e ) = source) by A32,A52,GLIB_000:def 14,GLIB_001:def 23;
hence e in ( ( WT9 .last() ) .edgesInOut() ) by A31,GLIB_000:61;
reconsider WTG = WT as (DPath of G) by GLIB_001:175;
A55: WTG is_Walk_from src,source by A50,GLIB_001:19;
( ( the_Weight_of Dn1W ) . e ) = ( ( ( the_Weight_of G ) | ( the_Edges_of Dn1W ) ) . e ) by GLIB_003:def 10;
hence ec = ( ( the_Weight_of Dn1W ) . e ) by A31,FUNCT_1:49;
pc = ( G .min_DPath_cost (src,source) ) by A5,A22;
then consider WX being (DPath of G) such that A56: WX is_mincost_DPath_from src,source and A57: pc = ( WX .cost() ) by A55,CKB14:def 1;
WX is_Walk_from src,source by A56,CKB13:def 1;
then ( WT .cost() ) <= pc by A51,A57;
then A58: ( WT9 .cost() ) <= pc by A37,GLIB_003:27;
pc <= ( WTG .cost() ) by A55,A56,A57,CKB13:def 1;
then pc <= ( WT9 .cost() ) by GLIB_003:27;
hence ( WT9 .cost() ) = pc by A58,XXREAL_0:1;
end;
hence ( W2 .cost() ) = ( pc + ec ) by GLIB_003:25;
end;
then consider W2 being (DPath of Dn1W) such that A59: W2 is_Walk_from src,target and A60: ( W2 .cost() ) = ( pc + ec );
reconsider W2G = W2 as (DPath of G) by GLIB_001:175;
A61: W2G is_Walk_from src,target by A59,GLIB_001:19;
A62: ( W2G .cost() ) = ( pc + ec ) by A60,GLIB_003:27;
now
consider WB being (DPath of G) such that A63: WB is_mincost_DPath_from src,target and A64: mc = ( WB .cost() ) by A61,CKB14:def 1;
thus mc <= ( pc + ec ) by A61,A62,A63,A64,CKB13:def 1;
A65: WB is_Walk_from src,target by A63,CKB13:def 1;
then reconsider target9 = target as (Vertex of G) by GLIB_001:18;
(( WB .first() ) = src & ( WB .last() ) = target) by A65,GLIB_001:def 23;
then consider lenWB2h being  odd (Element of ( NAT )) such that A66: lenWB2h = ( ( len WB ) - 2 ) and A67: ( ( WB .cut (1,lenWB2h) ) .addEdge ( WB . ( lenWB2h + 1 ) ) ) = WB by A19,GLIB_001:127,GLIB_001:133;
A68: lenWB2h < ( ( len WB ) - ( 0 ) ) by A66,XREAL_1:15;
set sa = ( WB . lenWB2h );
set ea = ( WB . ( lenWB2h + 1 ) );
set WA = ( WB .cut (1,lenWB2h) );
A69: 1 <= lenWB2h by ABIAN:12;
A70: ( WB . 1 ) = ( WB .first() ) by GLIB_001:def 6
.= src by A65,GLIB_001:def 23;
then WA is_Walk_from src,sa by A69,A68,GLIB_001:37,JORDAN12:2;
then reconsider sa as (Vertex of G) by GLIB_001:18;
A71: ea DJoins sa,( WB . ( lenWB2h + 2 ) ),G by A68,GLIB_001:122;
then A72: ea DJoins sa,( WB .last() ),G by A66,GLIB_001:def 7;
then ea DJoins sa,target,G by A65,GLIB_001:def 23;
then ea Joins sa,target9,G by GLIB_000:16;
then ea in ( sa .edgesInOut() ) by GLIB_000:62;
then A73: ea in ( ( WA .last() ) .edgesInOut() ) by A69,A68,GLIB_001:37,JORDAN12:2;
then A74: mc = ( ( WA .cost() ) + ( ( the_Weight_of G ) . ea ) ) by A64,A67,GLIB_003:25;
reconsider WA as (DPath of G);
A75: ( WA .first() ) = src by A69,A68,A70,GLIB_001:37,JORDAN12:2;
A76: ( WA .last() ) = sa by A69,A68,GLIB_001:37,JORDAN12:2;
then A77: WA is_mincost_DPath_from src,sa by A63,A75,CKB26:1;
A78: ea DJoins sa,target,G by A65,A72,GLIB_001:def 23;
A79: ( WA .cost() ) = ( G .min_DPath_cost (src,sa) ) by A63,A75,A76,CKB26:1,CKB28:1;
now
defpred P[ Nat ]
 means
(($1 is  odd & $1 <= ( len WA )) & (not ( WA . $1 ) in ( dom ( Dn `1 ) )));
A80: ( ( the_Source_of G ) . ea ) = sa by A71,GLIB_000:def 14;
assume A81: mc < ( pc + ec );
A82:now
assume A83: (not sa in ( dom ( Dn `1 ) ));
sa = ( WA .last() ) by A69,A68,GLIB_001:37,JORDAN12:2
.= ( WA . ( len WA ) ) by GLIB_001:def 7;
then A84: (ex k being Nat st P[ k ]) by A83;
consider k being Nat such that A85: (P[ k ] & (for m being Nat holds (P[ m ] implies k <= m))) from NAT_1:sch 5(A84);
reconsider k as  odd (Element of ( NAT )) by A85,ORDINAL1:def 12;
A86: 1 <= k by ABIAN:12;
( WA . 1 ) = ( WA .first() ) by GLIB_001:def 6
.= src by A69,A68,A70,GLIB_001:37,JORDAN12:2;
then k <> 1 by A8,A85;
then 1 < k by A86,XXREAL_0:1;
then ( 1 + 1 ) < ( k + 1 ) by XREAL_1:8;
then 2 <= k by NAT_1:13;
then reconsider k2a = ( k - ( 2 * 1 ) ) as  odd (Element of ( NAT )) by INT_1:5;
set sk = ( WA . k2a );
set ek = ( WA . ( k2a + 1 ) );
set tk = ( WA . k );
A87: k2a < ( ( len WA ) - ( 0 ) ) by A85,XREAL_1:15;
set WKA = ( WA .cut (1,k) );
set WKB = ( WA .cut (k,( len WA )) );
set WK1 = ( WA .cut (1,k2a) );
reconsider WK1,WKA,WKB as (DPath of G);
A88: 1 <= k by ABIAN:12;
then A89: ( WKA .append WKB ) = ( WA .cut (1,( len WA )) ) by A85,GLIB_001:38,JORDAN12:2
.= WA by GLIB_001:39;
A90: k2a < ( k - ( 0 ) ) by XREAL_1:15;
then A91: sk in ( dom ( Dn `1 ) ) by A85,A87;
then reconsider sk as (Vertex of G);
A92: 1 <= k2a by ABIAN:12;
then A93: ( WK1 .last() ) = sk by A87,GLIB_001:37,JORDAN12:2;
( WK1 .first() ) = ( WA . 1 ) by A92,A87,GLIB_001:37,JORDAN12:2;
then WK1 is_mincost_DPath_from ( WA . 1 ),sk by A77,A93,CKB26:1;
then WK1 is_mincost_DPath_from ( WA .first() ),sk by GLIB_001:def 6;
then ( G .min_DPath_cost (src,sk) ) = ( WK1 .cost() ) by A75,CKB28:1;
then A94: ( ( Dn `1 ) . sk ) = ( WK1 .cost() ) by A5,A85,A87,A90;
reconsider tk as (Vertex of G) by A85,GLIB_001:7;
A95: tk in ( ( the_Vertices_of G ) \ ( dom ( Dn `1 ) ) ) by A85,XBOOLE_0:def 5;
tk = ( WA . ( k2a + 2 ) );
then A96: ek DJoins sk,tk,G by A87,GLIB_001:122;
then A97: ( ( the_Source_of G ) . ek ) = sk by GLIB_000:def 14;
( WKB .first() ) = ( WA . k ) by A85,GLIB_001:37
.= ( WKA .last() ) by A85,A88,GLIB_001:37,JORDAN12:2;
then A98: ( WA .cost() ) = ( ( WKA .cost() ) + ( WKB .cost() ) ) by A89,GLIB_003:24;
( 0 ) <= ( WKB .cost() ) by GLIB_003:29;
then A99: ( (( 0 ) qua Nat) + ( WKA .cost() ) ) <= ( WA .cost() ) by A98,XREAL_1:7;
ea in ( the_Edges_of G ) by A71,GLIB_000:def 14;
then A100: ( 0 ) <= ( ( the_Weight_of G ) . ea ) by GLIB_003:31;
(ek in ( the_Edges_of G ) & ( ( the_Target_of G ) . ek ) = tk) by A96,GLIB_000:def 14;
then ek DSJoins ( dom ( Dn `1 ) ),( ( the_Vertices_of G ) \ ( dom ( Dn `1 ) ) ),G by A91,A97,A95,GLIB_000:def 16;
then A101: ( pc + ec ) <= ( ( WK1 .cost() ) + ( ( the_Weight_of G ) . ek ) ) by A15,A97,A94,CKB33:def 1;
(ek in ( the_Edges_of G ) & ( ( the_Source_of G ) . ek ) = sk) by A96,GLIB_000:def 14;
then A102: ek in ( sk .edgesInOut() ) by GLIB_000:61;
( k2a + 2 ) = k;
then ( WK1 .addEdge ek ) = WKA by A87,ABIAN:12,GLIB_001:41,JORDAN12:2;
then ( pc + ec ) <= ( WKA .cost() ) by A93,A101,A102,GLIB_003:25;
then ( pc + ec ) <= ( WA .cost() ) by A99,XXREAL_0:2;
then ( ( pc + ec ) + (( 0 ) qua Nat) ) <= ( ( WA .cost() ) + ( ( the_Weight_of G ) . ea ) ) by A100,XREAL_1:7;
hence contradiction by A64,A67,A73,A81,GLIB_003:25;
end;
then A103: ( WA .cost() ) = ( ( Dn `1 ) . sa ) by A5,A79;
(ea in ( the_Edges_of G ) & ( ( the_Target_of G ) . ea ) = target) by A78,GLIB_000:def 14;
then ea DSJoins ( dom ( Dn `1 ) ),( ( the_Vertices_of G ) \ ( dom ( Dn `1 ) ) ),G by A18,A82,A80,GLIB_000:def 16;
hence contradiction by A15,A74,A81,A103,A80,CKB33:def 1;
end;
hence mc >= ( pc + ec );
end;
then A104: ( G .min_DPath_cost (src,target) ) = ( pc + ec ) by XXREAL_0:1;
now
let x being (Vertex of Dn1W);
now
per cases  by A26,XBOOLE_0:def 3;
suppose x in ( dom ( Dn `1 ) );

then reconsider x9 = x as (Vertex of DnW) by A11,GLIB_000:def 37;
DnW is_mincost_DTree_rooted_at src by A5;
then consider W2 being (DPath of DnW) such that A105: W2 is_Walk_from src,x9 and A106: (for W1 being (DPath of G) holds (W1 is_Walk_from src,x9 implies ( W2 .cost() ) <= ( W1 .cost() ))) by CKB12:def 1;
reconsider W29 = W2 as (DPath of Dn1W) by A38,GLIB_001:175;
take W29;
thus W29 is_Walk_from src,x by A105,GLIB_001:19;
let W1 being (DPath of G);
assume W1 is_Walk_from src,x;
then ( W2 .cost() ) <= ( W1 .cost() ) by A106;
hence ( W29 .cost() ) <= ( W1 .cost() ) by A37,GLIB_003:27;
end;
suppose A107: x in { target };

take W2;
thus W2 is_Walk_from src,x by A59,A107,TARSKI:def 1;
let W1 being (DPath of G);
assume A108: W1 is_Walk_from src,x;
A109: x = target by A107,TARSKI:def 1;
(ex WX being (DPath of G) st (WX is_mincost_DPath_from src,target & ( WX .cost() ) = ( W2 .cost() ))) by A60,A61,A104,CKB14:def 1;
hence ( W2 .cost() ) <= ( W1 .cost() ) by A109,A108,CKB13:def 1;
end;
end;
hence (ex W2 being (DPath of Dn1W) st (W2 is_Walk_from src,x & (for W1 being (DPath of G) holds (W1 is_Walk_from src,x implies ( W2 .cost() ) <= ( W1 .cost() )))));
end;
hence Dn1W is_mincost_DTree_rooted_at src by A49,CKB12:def 1;
let v being (Vertex of G);
assume A110: v in ( dom ( Dn1 `1 ) );
now
per cases  by A24,A110,XBOOLE_0:def 3;
suppose A111: v in ( dom ( Dn `1 ) );

then A112: ( G .min_DPath_cost (src,v) ) = ( ( Dn `1 ) . v ) by A5;
A113: ( Dn1 `1 ) = ( ( Dn `1 ) +* ( target .--> ( pc + ec ) ) ) by A23,MCART_1:7;
A114: ( dom ( target .--> ( pc + ec ) ) ) = { target } by FUNCOP_1:13;
then (not v in ( dom ( target .--> ( pc + ec ) ) )) by A20,A111,TARSKI:def 1;
hence ( G .min_DPath_cost (src,v) ) = ( ( Dn1 `1 ) . v ) by A24,A110,A112,A113,A114,FUNCT_4:def 1;
end;
suppose A115: v in { target };

(( Dn1 `1 ) = ( ( Dn `1 ) +* ( target .--> ( pc + ec ) ) ) & ( dom ( target .--> ( pc + ec ) ) ) = { target }) by A23,FUNCOP_1:13,MCART_1:7;
then A116: ( ( Dn1 `1 ) . v ) = ( ( target .--> ( pc + ec ) ) . v ) by A115,FUNCT_4:13;
v = target by A115,TARSKI:def 1;
hence ( G .min_DPath_cost (src,v) ) = ( ( Dn1 `1 ) . v ) by A104,A116,FUNCOP_1:72;
end;
end;
hence ( G .min_DPath_cost (src,v) ) = ( ( Dn1 `1 ) . v );
end;
end;
hence (Dn1W is_mincost_DTree_rooted_at src & (for v being (Vertex of G) holds (v in ( dom ( Dn1 `1 ) ) implies ( G .min_DPath_cost (src,v) ) = ( ( Dn1 `1 ) . v ))));
end;
then A117: (for k being Nat holds (P[ k ] implies P[ ( k + 1 ) ]));
A118: ( D0 `2 ) = ( {} ) by A1,MCART_1:7;
now
let D0W being (inducedWSubgraph of G,( dom ( D0 `1 ) ),( D0 `2 ));
A119: ( {} ) c= ( G .edgesBetween ( dom ( D0 `1 ) ) ) by XBOOLE_1:2;
then A120: ( the_Vertices_of D0W ) = { src } by A3,A118,GLIB_000:def 37;
then ( card ( the_Vertices_of D0W ) ) = 1 by CARD_1:30;
then A121: D0W is  trivial by GLIB_000:def 19;
A122:now
let x being (Vertex of D0W);
set W2 = ( D0W .walkOf x );
take W2;
x = src by A120,TARSKI:def 1;
hence W2 is_Walk_from src,x by GLIB_001:13;
let W1 being (DPath of G);
assume W1 is_Walk_from src,x;
( 0 ) <= ( W1 .cost() ) by GLIB_003:29;
hence ( W2 .cost() ) <= ( W1 .cost() ) by GLIB_003:21;
end;
( the_Edges_of D0W ) = ( {} ) by A2,A118,A119,GLIB_000:def 37;
then ( D0W .order() ) = ( ( D0W .size() ) + 1 ) by A120,CARD_1:27,CARD_1:30;
then D0W is  Tree-like by A121,GLIB_002:47;
hence D0W is_mincost_DTree_rooted_at src by A122,CKB12:def 1;
let v being (Vertex of G);
assume A123: v in ( dom ( D0 `1 ) );
then A124: v = src by A3,TARSKI:def 1;
A125:now
set W1 = ( G .walkOf v );
A126: W1 is_Walk_from src,v by A124,GLIB_001:13;
then consider W being (DPath of G) such that A127: W is_mincost_DPath_from src,v and A128: ( G .min_DPath_cost (src,v) ) = ( W .cost() ) by CKB14:def 1;
( W1 .cost() ) = ( 0 ) by GLIB_003:21;
then ( W .cost() ) <= ( 0 ) by A126,A127,CKB13:def 1;
hence ( G .min_DPath_cost (src,v) ) = ( 0 ) by A128,GLIB_003:29;
end;
( ( D0 `1 ) . src ) = ( 0 ) by A2,FUNCOP_1:72;
hence ( G .min_DPath_cost (src,v) ) = ( ( D0 `1 ) . v ) by A3,A123,A125,TARSKI:def 1;
end;
then A129: P[ ( 0 ) ];
(for n being Nat holds P[ n ]) from NAT_1:sch 2(A129,A117);
hence thesis;
end;
