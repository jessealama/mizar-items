environ
vocabularies NUMBERS,FUNCT_1,RELAT_1,FUNCT_4,FUNCOP_1,XBOOLE_0,PRE_POLY,TARSKI,CARD_1,UPROOTS,CARD_3,ARYTM_3,FINSEQ_1,NAT_1,XXREAL_0,FINSET_1,SUBSET_1,FINSEQ_2,XREAL_0,ORDINAL1,ARYTM_1,GLIB_003,TREES_1,GLIB_000,GLIB_001,REAL_1,PBOOLE,ZFMISC_1,FUNCT_2,ABIAN,PARTFUN1,MCART_1,GLIB_002,WAYBEL_0,RELAT_2,RCOMP_1,GRAPH_1,GLIB_004;
notations TARSKI,XBOOLE_0,ZFMISC_1,ENUMSET1,CARD_1,NUMBERS,SUBSET_1,DOMAIN_1,MCART_1,XCMPLX_0,XXREAL_0,XREAL_0,REAL_1,RELAT_1,RELSET_1,PARTFUN1,FUNCT_1,FINSEQ_1,FINSEQ_2,SEQ_1,PBOOLE,FUNCT_2,RVSUM_1,ABIAN,ORDINAL1,UPROOTS,FINSET_1,NAT_1,FUNCOP_1,FUNCT_4,GLIB_000,GLIB_001,GLIB_002,GLIB_003,RFUNCT_3,PRE_POLY,CKB12,CKB13,CKB14,CKB15,CKB20,CKB22,CKB23;
definitions TARSKI,GLIB_000,GLIB_003,RVSUM_1,FUNCOP_1,CKB12,CKB13,CKB14,CKB15,CKB20,CKB23;
theorems CARD_1,CARD_2,FUNCOP_1,ENUMSET1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSET_1,FUNCT_1,FUNCT_2,FUNCT_4,GLIB_000,GLIB_001,GLIB_002,GLIB_003,ABIAN,INT_1,JORDAN12,NAT_1,PARTFUN1,PBOOLE,RELAT_1,RVSUM_1,TARSKI,TREES_1,UPROOTS,XBOOLE_0,XBOOLE_1,XREAL_0,ZFMISC_1,XREAL_1,XXREAL_0,ORDINAL1,FINSOP_1,FUNCT_7,MCART_1,RELSET_1,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB18,CKB19,CKB20,CKB23,CKB24,CKB25;
schemes NAT_1,SUBSET_1,RECDEF_1,GRAPH_5,CQC_SIM1,PBOOLE;
registrations XBOOLE_0,SUBSET_1,RELAT_1,PARTFUN1,FRAENKEL,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,CARD_1,UPROOTS,MEMBERED,GLIB_000,ABIAN,GLIB_001,GLIB_002,GLIB_003,VALUED_0,FUNCT_2,RELSET_1,PRE_POLY,INT_1,CKB17,CKB21;
constructors DOMAIN_1,BINOP_2,FINSOP_1,RVSUM_1,GRAPH_2,RFUNCT_3,UPROOTS,GLIB_002,GLIB_003,SEQ_1,XXREAL_2,RELSET_1,PBOOLE,CKB12,CKB13,CKB14,CKB15,CKB20,CKB22,CKB23;
requirements ARITHM,BOOLE,NUMERALS,REAL,SUBSET;
begin
theorem
Th12: (for G being  finite  nonnegative-weighted WGraph holds (for W being (DPath of G) holds (for x,y being set holds (for m,n being (Element of ( NAT )) holds (W is_mincost_DPath_from x,y implies ( W .cut (m,n) ) is_mincost_DPath_from ( ( W .cut (m,n) ) .first() ),( ( W .cut (m,n) ) .last() ))))))
proof
let G being  finite  nonnegative-weighted WGraph;
let W being (DPath of G);
let x being set,y being set;
let m being (Element of ( NAT )),n being (Element of ( NAT ));
set WC = ( W .cut (m,n) );
A1: WC is_Walk_from ( WC .first() ),( WC .last() ) by GLIB_001:def 23;
assume A2: W is_mincost_DPath_from x,y;
then A3: W is_Walk_from x,y by CKB13:def 1;
then A4: (( W . 1 ) = x & ( W . ( len W ) ) = y) by GLIB_001:17;
now
per cases ;
suppose A5: (((m is  odd & n is  odd) & m <= n) & n <= ( len W ));

set W1 = ( W .cut (1,m) );
set W3 = ( W .cut (n,( len W )) );
A6: 1 <= n by A5,ABIAN:12;
then A7: ( ( W .cut (1,n) ) .append W3 ) = ( W .cut (1,( len W )) ) by A5,GLIB_001:38,JORDAN12:2
.= W by GLIB_001:39;
( ( W .cut (1,n) ) .last() ) = ( W . n ) by A5,A6,GLIB_001:37,JORDAN12:2
.= ( W3 .first() ) by A5,GLIB_001:37;
then A8: ( W .cost() ) = ( ( ( W .cut (1,n) ) .cost() ) + ( W3 .cost() ) ) by A7,GLIB_003:24;
A9: 1 <= m by A5,ABIAN:12;
then A10: ( W1 .append WC ) = ( W .cut (1,n) ) by A5,GLIB_001:38,JORDAN12:2;
A11: m <= ( len W ) by A5,XXREAL_0:2;
then ( W1 .last() ) = ( W . m ) by A5,A9,GLIB_001:37,JORDAN12:2
.= ( WC .first() ) by A5,GLIB_001:37;
then ( ( W .cut (1,n) ) .cost() ) = ( ( W1 .cost() ) + ( WC .cost() ) ) by A10,GLIB_003:24;
then A12: ( W .cost() ) = ( ( WC .cost() ) + ( ( W1 .cost() ) + ( W3 .cost() ) ) ) by A8;
A13: W3 is_Walk_from ( W . n ),( W . ( len W ) ) by A5,GLIB_001:37;
A14: W1 is_Walk_from ( W . 1 ),( W . m ) by A5,A9,A11,GLIB_001:37,JORDAN12:2;
now
assume (not WC is_mincost_DPath_from ( WC .first() ),( WC .last() ));
then consider W2 being (DPath of G) such that A15: W2 is_Walk_from ( WC .first() ),( WC .last() ) and A16: ( W2 .cost() ) < ( WC .cost() ) by A1,CKB13:def 1;
set WA = ( W1 .append W2 );
set WB = ( WA .append W3 );
set WB2 = the (DPath of WB);
A17: ( WC .last() ) = ( W . n ) by A5,GLIB_001:37;
A18: ( WC .first() ) = ( W . m ) by A5,GLIB_001:37;
then WA is_Walk_from ( W . 1 ),( W . n ) by A14,A15,A17,GLIB_001:31;
then WB is_Walk_from x,y by A4,A13,GLIB_001:31;
then A19: WB2 is_Walk_from x,y by GLIB_001:160;
( W2 .first() ) = ( W . m ) by A15,A18,GLIB_001:def 23;
then A20: ( W1 .last() ) = ( W2 .first() ) by A5,A9,A11,GLIB_001:37,JORDAN12:2;
then A21: ( WA .cost() ) = ( ( W1 .cost() ) + ( W2 .cost() ) ) by GLIB_003:24;
( W2 .last() ) = ( W . n ) by A15,A17,GLIB_001:def 23;
then ( W3 .first() ) = ( W2 .last() ) by A5,GLIB_001:37
.= ( WA .last() ) by A20,GLIB_001:30;
then ( WB .cost() ) = ( ( ( W1 .cost() ) + ( W2 .cost() ) ) + ( W3 .cost() ) ) by A21,GLIB_003:24
.= ( ( W2 .cost() ) + ( ( W1 .cost() ) + ( W3 .cost() ) ) );
then A22: ( WB .cost() ) < ( W .cost() ) by A12,A16,XREAL_1:8;
( WB2 .cost() ) <= ( WB .cost() ) by GLIB_003:30;
then ( WB2 .cost() ) < ( W .cost() ) by A22,XXREAL_0:2;
hence contradiction by A2,A19,CKB13:def 1;
end;
hence thesis;
end;
suppose (not (((m is  odd & n is  odd) & m <= n) & n <= ( len W )));

then A23: WC = W by GLIB_001:def 11;
then ( WC .first() ) = x by A3,GLIB_001:def 23;
hence thesis by A2,A3,A23,GLIB_001:def 23;
end;
end;
hence thesis;
end;
