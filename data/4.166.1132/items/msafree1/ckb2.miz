environ
vocabularies FUNCT_1,CARD_3,RELAT_1,TARSKI,XBOOLE_0,LANG1,SUBSET_1,DTCONSTR,TREES_4,FINSEQ_1,TDGROUP,TREES_3,TREES_2,STRUCT_0,MSUALG_1,PBOOLE,MSAFREE,ZFMISC_1,MARGREL1,PROB_2,NAT_1,PARTFUN1,MCART_1,MSUALG_3,MSAFREE1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NAT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FINSEQ_2,STRUCT_0,MCART_1,FINSEQ_1,MULTOP_1,PROB_2,CARD_3,TREES_2,TREES_3,TREES_4,LANG1,DTCONSTR,PBOOLE,MSUALG_1,MSAFREE,MSUALG_3;
definitions TARSKI,MSUALG_1,PBOOLE,PROB_2;
theorems MSAFREE,MSUALG_3,LANG1,FINSEQ_1,CARD_3,PBOOLE,FUNCT_1,FUNCT_2,DTCONSTR,TARSKI,ZFMISC_1,PROB_2,CARD_5,RELAT_1,DOMAIN_1,MCART_1,XBOOLE_0,XBOOLE_1,PARTFUN1,FINSEQ_2,CKB1;
schemes DTCONSTR,FUNCT_2,MULTOP_1,PBOOLE;
registrations XBOOLE_0,FUNCT_1,RELSET_1,FINSEQ_1,RELAT_1,TREES_3,STRUCT_0,DTCONSTR,MSUALG_1,MSUALG_3,MSAFREE,ORDINAL1,PBOOLE,PRE_POLY;
constructors MULTOP_1,PROB_2,MSUALG_3,MSAFREE,RELSET_1,CAT_3,FINSEQ_2;
requirements BOOLE,SUBSET;
begin
scheme DTConstrUniq { DT() -> non empty DTConstrStr,D() -> non empty set,G(set) -> (Element of D()),H(set,set,set) -> (Element of D()),f1,f2() -> (Function of ( TS DT() ),D()) } : f1() = f2()
provided
A1: (for t being (Symbol of DT()) holds (t in ( Terminals DT() ) implies ( f1() . ( root-tree t ) ) = G(t)))
and
A2: (for nt being (Symbol of DT()) holds (for ts being (Element of ( ( TS DT() ) * )) holds (nt ==> ( roots ts ) implies (for x being (Element of ( D() * )) holds (x = ( f1() * ts ) implies ( f1() . ( nt -tree ts ) ) = H(nt,ts,x))))))
and
A3: (for t being (Symbol of DT()) holds (t in ( Terminals DT() ) implies ( f2() . ( root-tree t ) ) = G(t)))
and
A4: (for nt being (Symbol of DT()) holds (for ts being (Element of ( ( TS DT() ) * )) holds (nt ==> ( roots ts ) implies (for x being (Element of ( D() * )) holds (x = ( f2() * ts ) implies ( f2() . ( nt -tree ts ) ) = H(nt,ts,x))))))
proof
defpred P[ set ]
 means
( f1() . $1 ) = ( f2() . $1 );
A5: (for nt being (Symbol of DT()) holds (for ts being (FinSequence of ( TS DT() )) holds ((nt ==> ( roots ts ) & (for t being (DecoratedTree of (the carrier of DT())) holds (t in ( rng ts ) implies P[ t ]))) implies P[ ( nt -tree ts ) ])))
proof
let nt being (Symbol of DT());
let ts being (FinSequence of ( TS DT() ));
assume that
A6: nt ==> ( roots ts )
and
A7: (for t being (DecoratedTree of (the carrier of DT())) holds (t in ( rng ts ) implies ( f1() . t ) = ( f2() . t )));
A8: ( rng ts ) c= ( TS DT() ) by FINSEQ_1:def 4;
then A9: ( rng ts ) c= ( dom f1() ) by FUNCT_2:def 1;
then A10: ( dom ( f1() * ts ) ) = ( dom ts ) by RELAT_1:27;
( rng ts ) c= ( dom f2() ) by A8,FUNCT_2:def 1;
then A11: ( dom ( f2() * ts ) ) = ( dom ts ) by RELAT_1:27;
A12:now
let x being set;
assume A13: x in ( dom ts );
then reconsider t = ( ts . x ) as (Element of ( FinTrees (the carrier of DT()) )) by DTCONSTR:2;
t in ( rng ts ) by A13,FUNCT_1:def 3;
then A14: ( f1() . t ) = ( f2() . t ) by A7;
thus ( ( f1() * ts ) . x ) = ( f1() . t ) by A10,A13,FUNCT_1:12
.= ( ( f2() * ts ) . x ) by A11,A13,A14,FUNCT_1:12;
end;
( dom ( f1() * ts ) ) = ( dom ts ) by A9,RELAT_1:27
.= ( Seg ( len ts ) ) by FINSEQ_1:def 3;
then reconsider ntv1 = ( f1() * ts ) as FinSequence by FINSEQ_1:def 2;
( rng ntv1 ) c= D() by RELAT_1:def 19;
then ntv1 is (FinSequence of D()) by FINSEQ_1:def 4;
then reconsider ntv1 as (Element of ( D() * )) by FINSEQ_1:def 11;
reconsider tss = ts as (Element of ( ( TS DT() ) * )) by FINSEQ_1:def 11;
thus ( f1() . ( nt -tree ts ) ) = H(nt,tss,ntv1) by A2,A6
.= ( f2() . ( nt -tree ts ) ) by A4,A6,A10,A11,A12,FUNCT_1:2;
end;
A15: (for s being (Symbol of DT()) holds (s in ( Terminals DT() ) implies P[ ( root-tree s ) ]))
proof
let s being (Symbol of DT());
assume A16: s in ( Terminals DT() );
hence ( f1() . ( root-tree s ) ) = G(s) by A1
.= ( f2() . ( root-tree s ) ) by A3,A16;
end;
(for t being (DecoratedTree of (the carrier of DT())) holds (t in ( TS DT() ) implies P[ t ])) from DTCONSTR:sch 7(A15,A5);
then (for x being set holds (x in ( TS DT() ) implies ( f1() . x ) = ( f2() . x )));
hence thesis by FUNCT_2:12;
end;
