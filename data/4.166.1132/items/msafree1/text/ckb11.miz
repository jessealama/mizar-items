environ
vocabularies FUNCT_1,CARD_3,RELAT_1,TARSKI,XBOOLE_0,LANG1,SUBSET_1,DTCONSTR,TREES_4,FINSEQ_1,TDGROUP,TREES_3,TREES_2,STRUCT_0,MSUALG_1,PBOOLE,MSAFREE,ZFMISC_1,MARGREL1,PROB_2,NAT_1,PARTFUN1,MCART_1,MSUALG_3,MSAFREE1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NAT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FINSEQ_2,STRUCT_0,MCART_1,FINSEQ_1,MULTOP_1,PROB_2,CARD_3,TREES_2,TREES_3,TREES_4,LANG1,DTCONSTR,PBOOLE,MSUALG_1,MSAFREE,MSUALG_3,CKB8,CKB10;
definitions TARSKI,MSUALG_1,PBOOLE,PROB_2,CKB8,CKB10;
theorems MSAFREE,MSUALG_3,LANG1,FINSEQ_1,CARD_3,PBOOLE,FUNCT_1,FUNCT_2,DTCONSTR,TARSKI,ZFMISC_1,PROB_2,CARD_5,RELAT_1,DOMAIN_1,MCART_1,XBOOLE_0,XBOOLE_1,PARTFUN1,FINSEQ_2,CKB1,CKB3,CKB4,CKB8,CKB9,CKB10;
schemes DTCONSTR,FUNCT_2,MULTOP_1,PBOOLE,CKB2;
registrations XBOOLE_0,FUNCT_1,RELSET_1,FINSEQ_1,RELAT_1,TREES_3,STRUCT_0,DTCONSTR,MSUALG_1,MSUALG_3,MSAFREE,ORDINAL1,PBOOLE,PRE_POLY,CKB5,CKB6,CKB7;
constructors MULTOP_1,PROB_2,MSUALG_3,MSAFREE,RELSET_1,CAT_3,FINSEQ_2,CKB8,CKB10;
requirements BOOLE,SUBSET;
begin
definition
let S being non  empty ManySortedSign;
func SingleAlg S ->  strict MSAlgebra over S means 
:Def3: (for i being set holds (i in (the carrier of S) implies ( (the Sorts of it) . i ) = { i }));
existence
proof
deffunc F(set) = { $1 };
consider f being (ManySortedSet of (the carrier of S)) such that A1: (for i being set holds (i in (the carrier of S) implies ( f . i ) = F(i))) from PBOOLE:sch 4;
set Ch = the (ManySortedFunction of ( ( f # ) * (the Arity of S) ),( f * (the ResultSort of S) ));
take MSAlgebra (# f,Ch #);
thus thesis by A1;
end;
uniqueness
proof
let A1 being  strict MSAlgebra over S;
let A2 being  strict MSAlgebra over S;
assume that
A2: (for i being set holds (i in (the carrier of S) implies ( (the Sorts of A1) . i ) = { i }))
and
A3: (for i being set holds (i in (the carrier of S) implies ( (the Sorts of A2) . i ) = { i }));
set B = (the Sorts of A1);
now
let i being set;
assume A4: i in (the carrier of S);
hence ( (the Sorts of A1) . i ) = { i } by A2
.= ( (the Sorts of A2) . i ) by A3,A4;
end;
then A5: (the Sorts of A1) = (the Sorts of A2) by PBOOLE:3;
A6: ( dom (the ResultSort of S) ) = (the carrier' of S) by FUNCT_2:def 1;
now
let i being set;
set A = ( ( B * (the ResultSort of S) ) . i );
assume A7: i in (the carrier' of S);
then A8: A = ( B . ( (the ResultSort of S) . i ) ) by A6,FUNCT_1:13
.= { ( (the ResultSort of S) . i ) } by A2,A7,FUNCT_2:5;
then reconsider A as non  empty set;
reconsider f1 = ( (the Charact of A1) . i ),f2 = ( (the Charact of A2) . i ) as (Function of ( ( ( B # ) * (the Arity of S) ) . i ),A) by A5,A7,PBOOLE:def 15;
now
let x being set;
assume A9: x in ( ( ( B # ) * (the Arity of S) ) . i );
then ( f1 . x ) in A by FUNCT_2:5;
then A10: ( f1 . x ) = ( (the ResultSort of S) . i ) by A8,TARSKI:def 1;
( f2 . x ) in A by A9,FUNCT_2:5;
hence ( f1 . x ) = ( f2 . x ) by A8,A10,TARSKI:def 1;
end;
hence ( (the Charact of A1) . i ) = ( (the Charact of A2) . i ) by FUNCT_2:12;
end;
hence thesis by A5,PBOOLE:3;
end;
end;
