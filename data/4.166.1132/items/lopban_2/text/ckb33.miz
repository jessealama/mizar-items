environ
vocabularies NUMBERS,RLVECT_1,LOPBAN_1,RELAT_1,REAL_1,FUNCT_1,ARYTM_3,NORMSP_1,XXREAL_2,XXREAL_0,PRE_TOPC,CARD_1,XREAL_0,ORDINAL1,ORDINAL2,SUBSET_1,RSSPACE,BINOP_1,STRUCT_0,ALGSTR_0,XBOOLE_0,GROUP_1,SUPINF_2,MESFUNC1,FUNCSDOM,VECTSP_1,LATTICES,RSSPACE3,REWRITE1,NAT_1,SEQ_2,ZFMISC_1,PREPOWER,SEQ_1,COMPLEX1,SERIES_1,ARYTM_1,LOPBAN_2,NORMSP_0,METRIC_1,RELAT_2,SEQ_4;
notations XBOOLE_0,ZFMISC_1,SUBSET_1,FUNCT_1,PARTFUN1,FUNCT_2,BINOP_1,XXREAL_0,XXREAL_2,XCMPLX_0,XREAL_0,ORDINAL1,REAL_1,NAT_1,NUMBERS,COMPLEX1,SEQ_1,SEQ_4,SERIES_1,PREPOWER,STRUCT_0,ALGSTR_0,PRE_TOPC,PSCOMP_1,RLVECT_1,GROUP_1,VECTSP_1,NORMSP_0,NORMSP_1,FUNCSDOM,RSSPACE,RSSPACE3,LOPBAN_1,CKB3,CKB4,CKB5,CKB6,CKB7,CKB9,CKB19,CKB25,CKB29;
definitions STRUCT_0,GROUP_1,VECTSP_1,LOPBAN_1,RLVECT_1,ALGSTR_0,FUNCSDOM,NORMSP_0,CKB4,CKB5,CKB6,CKB7,CKB9,CKB19,CKB25;
theorems ABSVALUE,RLVECT_1,VECTSP_1,BINOP_1,FUNCSDOM,XCMPLX_0,SERIES_1,FUNCT_1,FUNCT_2,NORMSP_1,SEQ_4,RSSPACE,RSSPACE3,LOPBAN_1,PREPOWER,STRUCT_0,GROUP_1,XREAL_1,XXREAL_0,ALGSTR_0,XREAL_0,GRCAT_1,NORMSP_0,CKB1,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB22,CKB23,CKB25,CKB28,CKB31;
schemes BINOP_1,NAT_1;
registrations XBOOLE_0,RELAT_1,FUNCT_1,FUNCT_2,NUMBERS,XXREAL_0,XREAL_0,MEMBERED,STRUCT_0,RLVECT_1,VECTSP_1,FUNCSDOM,RSSPACE3,LOPBAN_1,ALGSTR_0,VALUED_0,NORMSP_0,CKB20,CKB21,CKB24,CKB26,CKB27,CKB30,CKB32;
constructors PARTFUN1,XXREAL_0,REAL_1,NAT_1,INT_2,BINOP_2,PREPOWER,SERIES_1,FUNCSDOM,PSCOMP_1,RSSPACE3,LOPBAN_1,VECTSP_1,SEQ_1,XXREAL_2,SEQ_4,RELSET_1,CKB3,CKB4,CKB5,CKB6,CKB7,CKB9,CKB19,CKB25;
requirements SUBSET,REAL,BOOLE,NUMERALS,ARITHM;
begin
registration
cluster ( l1_Space ) -> non  trivial;
coherence
proof
set a = ( 1 / 2 );
reconsider x = ( a GeoSeq ) as Real_Sequence;
A1: ( abs a ) = ( 1 / 2 ) by ABSVALUE:def 1;
defpred P[ (Element of ( NAT )) ]
 means
( 0 ) <= ( x . $1 );
A2: (for n being (Element of ( NAT )) holds (P[ n ] implies P[ ( n + 1 ) ]))
proof
let n being (Element of ( NAT ));
A3: ( x . ( n + 1 ) ) = ( ( x . n ) * a ) by PREPOWER:3;
assume P[ n ];
hence thesis by A3;
end;
A4: P[ ( 0 ) ] by PREPOWER:3;
(for n being (Element of ( NAT )) holds P[ n ]) from NAT_1:sch 1(A4,A2);
then x is  absolutely_summable by A1,SERIES_1:24,SERIES_1:36;
then ( seq_id x ) is  absolutely_summable by RSSPACE:1;
then reconsider v = x as (VECTOR of ( l1_Space )) by RSSPACE3:6;
( ( seq_id v ) . ( 0 ) ) = ( x . ( 0 ) ) by RSSPACE:1
.= 1 by PREPOWER:3;
then v <> ( Zeroseq ) by RSSPACE:def 6;
hence thesis by RSSPACE3:6,STRUCT_0:def 18;
end;
end;
