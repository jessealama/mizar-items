environ
vocabularies NUMBERS,RLVECT_1,LOPBAN_1,RELAT_1,REAL_1,FUNCT_1,ARYTM_3,NORMSP_1,XXREAL_2,XXREAL_0,PRE_TOPC,CARD_1,XREAL_0,ORDINAL1,ORDINAL2,SUBSET_1,RSSPACE,BINOP_1,STRUCT_0,ALGSTR_0,XBOOLE_0,GROUP_1,SUPINF_2,MESFUNC1,FUNCSDOM,VECTSP_1,LATTICES,RSSPACE3,REWRITE1,NAT_1,SEQ_2,ZFMISC_1,PREPOWER,SEQ_1,COMPLEX1,SERIES_1,ARYTM_1,LOPBAN_2,NORMSP_0,METRIC_1,RELAT_2,SEQ_4;
notations XBOOLE_0,ZFMISC_1,SUBSET_1,FUNCT_1,PARTFUN1,FUNCT_2,BINOP_1,XXREAL_0,XXREAL_2,XCMPLX_0,XREAL_0,ORDINAL1,REAL_1,NAT_1,NUMBERS,COMPLEX1,SEQ_1,SEQ_4,SERIES_1,PREPOWER,STRUCT_0,ALGSTR_0,PRE_TOPC,PSCOMP_1,RLVECT_1,GROUP_1,VECTSP_1,NORMSP_0,NORMSP_1,FUNCSDOM,RSSPACE,RSSPACE3,LOPBAN_1,CKB3,CKB4,CKB5,CKB6,CKB7,CKB9,CKB19,CKB25,CKB29;
definitions STRUCT_0,GROUP_1,VECTSP_1,LOPBAN_1,RLVECT_1,ALGSTR_0,FUNCSDOM,NORMSP_0,CKB4,CKB5,CKB6,CKB7,CKB9,CKB19,CKB25;
theorems ABSVALUE,RLVECT_1,VECTSP_1,BINOP_1,FUNCSDOM,XCMPLX_0,SERIES_1,FUNCT_1,FUNCT_2,NORMSP_1,SEQ_4,RSSPACE,RSSPACE3,LOPBAN_1,PREPOWER,STRUCT_0,GROUP_1,XREAL_1,XXREAL_0,ALGSTR_0,XREAL_0,GRCAT_1,NORMSP_0,CKB1,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB22,CKB23,CKB25,CKB28;
schemes BINOP_1,NAT_1;
registrations XBOOLE_0,RELAT_1,FUNCT_1,FUNCT_2,NUMBERS,XXREAL_0,XREAL_0,MEMBERED,STRUCT_0,RLVECT_1,VECTSP_1,FUNCSDOM,RSSPACE3,LOPBAN_1,ALGSTR_0,VALUED_0,NORMSP_0,CKB20,CKB21,CKB24,CKB26,CKB27;
constructors PARTFUN1,XXREAL_0,REAL_1,NAT_1,INT_2,BINOP_2,PREPOWER,SERIES_1,FUNCSDOM,PSCOMP_1,RSSPACE3,LOPBAN_1,VECTSP_1,SEQ_1,XXREAL_2,SEQ_4,RELSET_1,CKB3,CKB4,CKB5,CKB6,CKB7,CKB9,CKB19,CKB25;
requirements SUBSET,REAL,BOOLE,NUMERALS,ARITHM;
begin
registration
let X being RealNormSpace;
cluster ( R_Algebra_of_BoundedLinearOperators X ) ->  Abelian  add-associative  right_zeroed  right_complementable  associative  right_unital  right-distributive  vector-distributive  scalar-distributive  scalar-associative  vector-associative  strict;
coherence
proof
set A = ( R_Algebra_of_BoundedLinearOperators X );
set BLOP = ( BoundedLinearOperators (X,X) );
set RRL = RLSStruct (# ( BoundedLinearOperators (X,X) ),( Zero_ (( BoundedLinearOperators (X,X) ),( R_VectorSpace_of_LinearOperators (X,X) )) ),( Add_ (( BoundedLinearOperators (X,X) ),( R_VectorSpace_of_LinearOperators (X,X) )) ),( Mult_ (( BoundedLinearOperators (X,X) ),( R_VectorSpace_of_LinearOperators (X,X) )) ) #);
set MULT = ( FuncMult X );
set UNIT = ( FuncUnit X );
set ADD = ( Add_ (( BoundedLinearOperators (X,X) ),( R_VectorSpace_of_LinearOperators (X,X) )) );
thus A is  Abelian
proof
let x being (Element of A);
let y being (Element of A);
reconsider f = x,g = y as (Element of RRL);
thus ( x + y ) = ( f + g )
.= ( y + x ) by RLVECT_1:2;
end;

thus A is  add-associative
proof
let x being (Element of A);
let y being (Element of A);
let z being (Element of A);
reconsider f = x,g = y,h = z as (Element of RRL);
thus ( ( x + y ) + z ) = ( ( f + g ) + h )
.= ( f + ( g + h ) ) by RLVECT_1:def 3
.= ( x + ( y + z ) );
end;

thus A is  right_zeroed
proof
let x being (Element of A);
reconsider f = x as (Element of RRL);
thus ( x + ( 0. A ) ) = ( f + ( 0. RRL ) )
.= x by RLVECT_1:def 4;
end;

thus A is  right_complementable
proof
let x being (Element of A);
reconsider f = x as (Element of RRL);
consider s being (Element of RRL) such that A1: ( f + s ) = ( 0. RRL ) by ALGSTR_0:def 11;
reconsider t = s as (Element of A);
take t;
thus thesis by A1;
end;

thus A is  associative
proof
let x being (Element of A);
let y being (Element of A);
let z being (Element of A);
reconsider xx = x,yy = y,zz = z as (Element of BLOP);
thus ( ( x * y ) * z ) = ( MULT . (( xx * yy ),zz) ) by CKB7:def 1
.= ( ( xx * yy ) * zz ) by CKB7:def 1
.= ( xx * ( yy * zz ) ) by CKB13:1
.= ( MULT . (xx,( yy * zz )) ) by CKB7:def 1
.= ( x * ( y * z ) ) by CKB7:def 1;
end;

thus A is  right_unital
proof
let x being (Element of A);
reconsider xx = x as (Element of BLOP);
thus ( x * ( 1. A ) ) = ( xx * UNIT ) by CKB7:def 1
.= x by CKB14:1;
end;

thus A is  right-distributive
proof
let x being (Element of A);
let y being (Element of A);
let z being (Element of A);
reconsider xx = x,yy = y,zz = z as (Element of BLOP);
thus ( x * ( y + z ) ) = ( xx * ( yy + zz ) ) by CKB7:def 1
.= ( ( xx * yy ) + ( xx * zz ) ) by CKB15:1
.= ( ADD . (( xx * yy ),( MULT . (xx,zz) )) ) by CKB7:def 1
.= ( ( x * y ) + ( x * z ) ) by CKB7:def 1;
end;

thus A is  vector-distributive
proof
let a being  real number;
let x being (Element of A);
let y being (Element of A);
reconsider f = x,g = y as (Element of RRL);
thus ( a * ( x + y ) ) = ( a * ( f + g ) )
.= ( ( a * f ) + ( a * g ) ) by RLVECT_1:def 5
.= ( ( a * x ) + ( a * y ) );
end;

thus A is  scalar-distributive
proof
let a being  real number;
let b being  real number;
let x being (Element of A);
reconsider f = x as (Element of RRL);
thus ( ( a + b ) * x ) = ( ( a + b ) * f )
.= ( ( a * f ) + ( b * f ) ) by RLVECT_1:def 6
.= ( ( a * x ) + ( b * x ) );
end;

thus A is  scalar-associative
proof
let a being  real number;
let b being  real number;
let x being (Element of A);
reconsider f = x as (Element of RRL);
thus ( ( a * b ) * x ) = ( ( a * b ) * f )
.= ( a * ( b * f ) ) by RLVECT_1:def 7
.= ( a * ( b * x ) );
end;

thus A is  vector-associative
proof
let x being (Element of A);
let y being (Element of A);
let a being Real;
reconsider xx = x,yy = y as (Element of BLOP);
thus ( a * ( x * y ) ) = ( a * ( xx * yy ) ) by CKB7:def 1
.= ( ( a * xx ) * yy ) by CKB18:1
.= ( ( a * x ) * y ) by CKB7:def 1;
end;

thus thesis;
end;
end;
