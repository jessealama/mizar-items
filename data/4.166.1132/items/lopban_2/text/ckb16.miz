environ
vocabularies NUMBERS,RLVECT_1,LOPBAN_1,RELAT_1,REAL_1,FUNCT_1,ARYTM_3,NORMSP_1,XXREAL_2,XXREAL_0,PRE_TOPC,CARD_1,XREAL_0,ORDINAL1,ORDINAL2,SUBSET_1,RSSPACE,BINOP_1,STRUCT_0,ALGSTR_0,XBOOLE_0,GROUP_1,SUPINF_2,MESFUNC1,FUNCSDOM,VECTSP_1,LATTICES,RSSPACE3,REWRITE1,NAT_1,SEQ_2,ZFMISC_1,PREPOWER,SEQ_1,COMPLEX1,SERIES_1,ARYTM_1,LOPBAN_2,NORMSP_0,METRIC_1,RELAT_2,SEQ_4;
notations XBOOLE_0,ZFMISC_1,SUBSET_1,FUNCT_1,PARTFUN1,FUNCT_2,BINOP_1,XXREAL_0,XXREAL_2,XCMPLX_0,XREAL_0,ORDINAL1,REAL_1,NAT_1,NUMBERS,COMPLEX1,SEQ_1,SEQ_4,SERIES_1,PREPOWER,STRUCT_0,ALGSTR_0,PRE_TOPC,PSCOMP_1,RLVECT_1,GROUP_1,VECTSP_1,NORMSP_0,NORMSP_1,FUNCSDOM,RSSPACE,RSSPACE3,LOPBAN_1,CKB3,CKB4,CKB5,CKB6,CKB7,CKB9;
definitions STRUCT_0,GROUP_1,VECTSP_1,LOPBAN_1,RLVECT_1,ALGSTR_0,FUNCSDOM,NORMSP_0,CKB4,CKB5,CKB6,CKB7,CKB9;
theorems ABSVALUE,RLVECT_1,VECTSP_1,BINOP_1,FUNCSDOM,XCMPLX_0,SERIES_1,FUNCT_1,FUNCT_2,NORMSP_1,SEQ_4,RSSPACE,RSSPACE3,LOPBAN_1,PREPOWER,STRUCT_0,GROUP_1,XREAL_1,XXREAL_0,ALGSTR_0,XREAL_0,GRCAT_1,NORMSP_0,CKB1,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15;
schemes BINOP_1,NAT_1;
registrations XBOOLE_0,RELAT_1,FUNCT_1,FUNCT_2,NUMBERS,XXREAL_0,XREAL_0,MEMBERED,STRUCT_0,RLVECT_1,VECTSP_1,FUNCSDOM,RSSPACE3,LOPBAN_1,ALGSTR_0,VALUED_0,NORMSP_0;
constructors PARTFUN1,XXREAL_0,REAL_1,NAT_1,INT_2,BINOP_2,PREPOWER,SERIES_1,FUNCSDOM,PSCOMP_1,RSSPACE3,LOPBAN_1,VECTSP_1,SEQ_1,XXREAL_2,SEQ_4,RELSET_1,CKB3,CKB4,CKB5,CKB6,CKB7,CKB9;
requirements SUBSET,REAL,BOOLE,NUMERALS,ARITHM;
begin
theorem
Th10: (for X being RealNormSpace holds (for f,g,h being (Element of ( BoundedLinearOperators (X,X) )) holds ( ( g + h ) * f ) = ( ( g * f ) + ( h * f ) )))
proof
let X being RealNormSpace;
let f being (Element of ( BoundedLinearOperators (X,X) ));
let g being (Element of ( BoundedLinearOperators (X,X) ));
let h being (Element of ( BoundedLinearOperators (X,X) ));
set BLOP = ( R_NormSpace_of_BoundedLinearOperators (X,X) );
set ADD = ( Add_ (( BoundedLinearOperators (X,X) ),( R_VectorSpace_of_LinearOperators (X,X) )) );
set mf = ( modetrans (f,X,X) );
set mg = ( modetrans (g,X,X) );
set mh = ( modetrans (h,X,X) );
set mgh = ( modetrans (( g + h ),X,X) );
( ADD . (( mg * mf ),( mh * mf )) ) = ( mgh * mf )
proof
reconsider hf = ( mh * mf ) as (VECTOR of BLOP) by LOPBAN_1:def 9;
reconsider gf = ( mg * mf ) as (VECTOR of BLOP) by LOPBAN_1:def 9;
reconsider k = ( mgh * mf ) as (VECTOR of BLOP) by LOPBAN_1:def 9;
reconsider hh = h as (VECTOR of BLOP);
reconsider gg = g as (VECTOR of BLOP);
A1: (gg = mg & hh = mh) by LOPBAN_1:def 11;
(for x being (VECTOR of X) holds ( ( mgh * mf ) . x ) = ( ( ( mg * mf ) . x ) + ( ( mh * mf ) . x ) ))
proof
let x being (VECTOR of X);
(( g + h ) = ( gg + hh ) & ( modetrans (( g + h ),X,X) ) = ( g + h )) by LOPBAN_1:def 11;
then A2: ( mgh . ( mf . x ) ) = ( ( mg . ( mf . x ) ) + ( mh . ( mf . x ) ) ) by A1,LOPBAN_1:35;
thus ( ( mgh * mf ) . x ) = ( mgh . ( mf . x ) ) by CKB10:1
.= ( ( ( mg * mf ) . x ) + ( mh . ( mf . x ) ) ) by A2,CKB10:1
.= ( ( ( mg * mf ) . x ) + ( ( mh * mf ) . x ) ) by CKB10:1;
end;
then k = ( gf + hf ) by LOPBAN_1:35;
hence thesis;
end;
hence thesis;
end;
