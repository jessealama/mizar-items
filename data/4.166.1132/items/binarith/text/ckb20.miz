environ
vocabularies NUMBERS,NAT_1,XBOOLE_0,SUBSET_1,FINSEQ_2,FINSEQ_1,ORDINAL4,PARTFUN1,RELAT_1,ARYTM_3,CARD_1,MARGREL1,XBOOLEAN,XCMPLX_0,FUNCT_1,XXREAL_0,ARYTM_1,FUNCOP_1,POWER,BINOP_2,SETWISEO,REAL_1,BINARITH;
notations XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,REAL_1,XBOOLEAN,MARGREL1,FUNCT_1,PARTFUN1,FUNCT_2,BINOP_1,BINOP_2,SETWISEO,FUNCOP_1,SETWOP_2,SERIES_1,FINSEQ_1,FINSEQ_2,XXREAL_0,NAT_1,NAT_D,CKB3,CKB4,CKB16,CKB17,CKB18,CKB19;
definitions FINSEQ_1,TARSKI,XBOOLEAN,CKB16,CKB17,CKB18,CKB19;
theorems NAT_1,INT_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,FUNCT_1,TARSKI,POWER,FINSOP_1,XBOOLE_0,BINOP_2,XREAL_1,XXREAL_0,XBOOLEAN,FUNCOP_1,PARTFUN1,FINSEQ_3,XREAL_0,NAT_D,CARD_1,CKB1,CKB2,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19;
schemes FINSEQ_1,FINSEQ_2,NAT_1;
registrations ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,BINOP_2,XBOOLEAN,MARGREL1,FINSEQ_2,XBOOLE_0,REAL_1,CARD_1,FINSEQ_1;
constructors BINOP_1,SETWISEO,XXREAL_0,NAT_1,INT_1,BINOP_2,MARGREL1,PARTFUN1,FINSOP_1,SERIES_1,RFINSEQ,SEQ_1,REAL_1,NAT_D,RELSET_1,FINSEQ_2,CKB3,CKB4,CKB16,CKB17,CKB18,CKB19;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve z for  boolean set;
reserve i for Nat;
reserve j for Nat;
reserve n for non  zero Nat;
reserve x for (Tuple of n,( BOOLEAN ));
reserve y for (Tuple of n,( BOOLEAN ));
reserve z1 for (Tuple of n,( BOOLEAN ));
reserve z2 for (Tuple of n,( BOOLEAN ));
definition
let n;
let x;
let y;
func x + y -> (Tuple of n,( BOOLEAN )) means 
:Def8: (for i holds (i in ( Seg n ) implies ( it /. i ) = ( ( ( x /. i ) 'xor' ( y /. i ) ) 'xor' ( ( carry (x,y) ) /. i ) )));
existence
proof
deffunc F(Nat) = ( ( ( x /. $1 ) 'xor' ( y /. $1 ) ) 'xor' ( ( carry (x,y) ) /. $1 ) );
consider z being (FinSequence of ( BOOLEAN )) such that A1: ( len z ) = n and A2: (for j being Nat holds (j in ( dom z ) implies ( z . j ) = F(j))) from FINSEQ_2:sch 1;
A3: ( dom z ) = ( Seg n ) by A1,FINSEQ_1:def 3;
reconsider z as (Tuple of n,( BOOLEAN )) by A1,CARD_1:def 7;
take z;
let i;
assume A4: i in ( Seg n );
then i in ( dom z ) by A1,FINSEQ_1:def 3;
hence ( z /. i ) = ( z . i ) by PARTFUN1:def 6
.= ( ( ( x /. i ) 'xor' ( y /. i ) ) 'xor' ( ( carry (x,y) ) /. i ) ) by A2,A3,A4;
end;
uniqueness
proof
let z1;
let z2;
assume that
A5: (for i holds (i in ( Seg n ) implies ( z1 /. i ) = ( ( ( x /. i ) 'xor' ( y /. i ) ) 'xor' ( ( carry (x,y) ) /. i ) )))
and
A6: (for i holds (i in ( Seg n ) implies ( z2 /. i ) = ( ( ( x /. i ) 'xor' ( y /. i ) ) 'xor' ( ( carry (x,y) ) /. i ) )));
A7: ( len z1 ) = n by CARD_1:def 7;
then A8: ( dom z1 ) = ( Seg n ) by FINSEQ_1:def 3;
A9: ( len z2 ) = n by CARD_1:def 7;
then A10: ( dom z2 ) = ( Seg n ) by FINSEQ_1:def 3;
now
let j being Nat;
assume A11: j in ( dom z1 );
hence ( z1 . j ) = ( z1 /. j ) by PARTFUN1:def 6
.= ( ( ( x /. j ) 'xor' ( y /. j ) ) 'xor' ( ( carry (x,y) ) /. j ) ) by A5,A8,A11
.= ( z2 /. j ) by A6,A8,A11
.= ( z2 . j ) by A8,A10,A11,PARTFUN1:def 6;
end;
hence thesis by A7,A9,FINSEQ_2:9;
end;
end;
