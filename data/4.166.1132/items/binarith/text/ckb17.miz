environ
vocabularies NUMBERS,NAT_1,XBOOLE_0,SUBSET_1,FINSEQ_2,FINSEQ_1,ORDINAL4,PARTFUN1,RELAT_1,ARYTM_3,CARD_1,MARGREL1,XBOOLEAN,XCMPLX_0,FUNCT_1,XXREAL_0,ARYTM_1,FUNCOP_1,POWER,BINOP_2,SETWISEO,REAL_1,BINARITH;
notations XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,REAL_1,XBOOLEAN,MARGREL1,FUNCT_1,PARTFUN1,FUNCT_2,BINOP_1,BINOP_2,SETWISEO,FUNCOP_1,SETWOP_2,SERIES_1,FINSEQ_1,FINSEQ_2,XXREAL_0,NAT_1,NAT_D,CKB3,CKB4,CKB16;
definitions FINSEQ_1,TARSKI,XBOOLEAN,CKB16;
theorems NAT_1,INT_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,FUNCT_1,TARSKI,POWER,FINSOP_1,XBOOLE_0,BINOP_2,XREAL_1,XXREAL_0,XBOOLEAN,FUNCOP_1,PARTFUN1,FINSEQ_3,XREAL_0,NAT_D,CARD_1,CKB1,CKB2,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16;
schemes FINSEQ_1,FINSEQ_2,NAT_1;
registrations ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,BINOP_2,XBOOLEAN,MARGREL1,FINSEQ_2,XBOOLE_0,REAL_1,CARD_1,FINSEQ_1;
constructors BINOP_1,SETWISEO,XXREAL_0,NAT_1,INT_1,BINOP_2,MARGREL1,PARTFUN1,FINSOP_1,SERIES_1,RFINSEQ,SEQ_1,REAL_1,NAT_D,RELSET_1,FINSEQ_2,CKB3,CKB4,CKB16;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve k for Nat;
definition
let n being non empty Nat;
let x being (Tuple of n,( BOOLEAN ));
let y being (Tuple of n,( BOOLEAN ));
func carry (x,y) -> (Tuple of n,( BOOLEAN ))
means
:Def5: (( it /. 1 ) = ( FALSE ) & (for i being Nat holds ((1 <= i & i < n) implies ( it /. ( i + 1 ) ) = ( ( ( ( x /. i ) '&' ( y /. i ) ) 'or' ( ( x /. i ) '&' ( it /. i ) ) ) 'or' ( ( y /. i ) '&' ( it /. i ) ) ))));
existence
proof
deffunc G(Nat,(Element of ( BOOLEAN ))) = ( ( ( ( x /. ( $1 + 1 ) ) '&' ( y /. ( $1 + 1 ) ) ) 'or' ( ( x /. ( $1 + 1 ) ) '&' $2 ) ) 'or' ( ( y /. ( $1 + 1 ) ) '&' $2 ) );
consider f being (Function of ( NAT ),( BOOLEAN )) such that A1: ( f . ( 0 ) ) = ( FALSE ) and A2: (for i being Nat holds ( f . ( i + 1 ) ) = G(i,( f . i ))) from NAT_1:sch 12;
deffunc F(Nat) = ( f . ( $1 - 1 ) );
consider z being FinSequence such that A3: ( len z ) = n and A4: (for j being Nat holds (j in ( dom z ) implies ( z . j ) = F(j))) from FINSEQ_1:sch 2;
z is (FinSequence of ( BOOLEAN ))
proof
let a being set;
assume a in ( rng z );
then consider b being set such that A5: b in ( dom z ) and A6: a = ( z . b ) by FUNCT_1:def 3;
A7: b in ( Seg n ) by A3,A5,FINSEQ_1:def 3;
reconsider b as (Element of ( NAT )) by A5;
b >= 1 by A7,FINSEQ_1:1;
then reconsider c = ( b - 1 ) as (Element of ( NAT )) by INT_1:5;
( z . b ) = ( f . c ) by A4,A5;
hence thesis by A6;
end;
then reconsider z as (Tuple of n,( BOOLEAN )) by A3,CARD_1:def 7;
take z;
( ( 0 ) + 1 ) <= n by NAT_1:13;
then 1 in ( Seg n );
then A8: 1 in ( dom z ) by A3,FINSEQ_1:def 3;
hence ( z /. 1 ) = ( z . 1 ) by PARTFUN1:def 6
.= ( f . ( 1 - 1 ) ) by A4,A8
.= ( FALSE ) by A1;
let i being Nat;
assume that
A9: 1 <= i
and
A10: i < n;
consider j being Nat such that A11: ( j + 1 ) = i by A9,NAT_1:6;
( j + 1 ) in ( Seg n ) by A9,A10,A11;
then A12: ( j + 1 ) in ( dom z ) by A3,FINSEQ_1:def 3;
then A13: ( z /. ( j + 1 ) ) = ( z . ( j + 1 ) ) by PARTFUN1:def 6
.= ( f . ( ( j + 1 ) - 1 ) ) by A4,A12
.= ( f . j );
A14: ( ( i + 1 ) - 1 ) = i;
(1 <= ( i + 1 ) & ( i + 1 ) <= n) by A9,A10,NAT_1:13;
then A15: ( i + 1 ) in ( dom z ) by A3,FINSEQ_3:25;
hence ( z /. ( i + 1 ) ) = ( z . ( i + 1 ) ) by PARTFUN1:def 6
.= ( f . ( j + 1 ) ) by A4,A11,A14,A15
.= ( ( ( ( x /. i ) '&' ( y /. i ) ) 'or' ( ( x /. i ) '&' ( z /. i ) ) ) 'or' ( ( y /. i ) '&' ( z /. i ) ) ) by A2,A11,A13;
end;
uniqueness
proof
let z1 being (Tuple of n,( BOOLEAN )),z2 being (Tuple of n,( BOOLEAN ));
assume that
A16: ( z1 /. 1 ) = ( FALSE )
and
A17: (for i being Nat holds ((1 <= i & i < n) implies ( z1 /. ( i + 1 ) ) = ( ( ( ( x /. i ) '&' ( y /. i ) ) 'or' ( ( x /. i ) '&' ( z1 /. i ) ) ) 'or' ( ( y /. i ) '&' ( z1 /. i ) ) )))
and
A18: ( z2 /. 1 ) = ( FALSE )
and
A19: (for i being Nat holds ((1 <= i & i < n) implies ( z2 /. ( i + 1 ) ) = ( ( ( ( x /. i ) '&' ( y /. i ) ) 'or' ( ( x /. i ) '&' ( z2 /. i ) ) ) 'or' ( ( y /. i ) '&' ( z2 /. i ) ) )));
A20: ( len z2 ) = n by CARD_1:def 7;
A21: ( len z1 ) = n by CARD_1:def 7;
then A22: ( dom z1 ) = ( Seg n ) by FINSEQ_1:def 3;
now
defpred P[ Nat ]
 means
($1 in ( Seg n ) implies ( z1 /. $1 ) = ( z2 /. $1 ));
A23: (( dom z1 ) = ( Seg n ) & ( dom z2 ) = ( Seg n )) by A21,A20,FINSEQ_1:def 3;
A24:now
let k;
assume that
A25: P[ k ];
thus P[ ( k + 1 ) ]
proof
assume A26: ( k + 1 ) in ( Seg n );
per cases ;
suppose k = ( 0 );

hence thesis by A16,A18;
end;
suppose A27: k <> ( 0 );

(( k + 1 ) <= n & k < ( k + 1 )) by A26,FINSEQ_1:1,XREAL_1:29;
then A28: k < n by XXREAL_0:2;
A29: k >= ( ( 0 ) + 1 ) by A27,NAT_1:13;
hence ( z1 /. ( k + 1 ) ) = ( ( ( ( x /. k ) '&' ( y /. k ) ) 'or' ( ( x /. k ) '&' ( z1 /. k ) ) ) 'or' ( ( y /. k ) '&' ( z1 /. k ) ) ) by A17,A28
.= ( z2 /. ( k + 1 ) ) by A19,A25,A29,A28,FINSEQ_1:1;
end;
end;

end;
A30: P[ ( 0 ) ] by FINSEQ_1:1;
A31: (for k holds P[ k ]) from NAT_1:sch 2(A30,A24);
let j being Nat;
assume that
A32: j in ( dom z1 );
thus ( z1 . j ) = ( z1 /. j ) by A32,PARTFUN1:def 6
.= ( z2 /. j ) by A22,A32,A31
.= ( z2 . j ) by A32,A23,PARTFUN1:def 6;
end;
hence thesis by A21,A20,FINSEQ_2:9;
end;
end;
