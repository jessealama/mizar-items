environ
vocabularies MSAFREE2,STRUCT_0,XBOOLE_0,MSUALG_1,RELAT_1,PBOOLE,MSAFREE,FUNCOP_1,FUNCT_1,TREES_3,FINSEQ_1,SUBSET_1,TREES_4,MSUALG_3,MARGREL1,FINSEQ_4,TARSKI,DTCONSTR,NAT_1,NUMBERS,TREES_2,CARD_3,PARTFUN1,ZFMISC_1,TDGROUP,CIRCUIT1,FSM_1,FUNCT_4,GLIB_000,UNIALG_2,MSATERM,PRELAMB,REALSET1,CARD_1,XXREAL_0,ARYTM_3,FUNCT_6,TREES_A,FINSET_1,CIRCUIT2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,XXREAL_0,NAT_1,FINSEQ_1,FINSEQ_2,FINSET_1,TREES_2,TREES_3,TREES_4,CARD_3,FUNCT_6,LANG1,DTCONSTR,PBOOLE,FUNCOP_1,XXREAL_2,STRUCT_0,PRALG_1,MSUALG_1,MSUALG_2,MSUALG_3,MSAFREE,MSAFREE2,CIRCUIT1,MSATERM,CKB3;
definitions PBOOLE,MSAFREE2;
theorems TARSKI,NAT_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,RELAT_1,GRFUNC_1,FUNCT_1,FUNCT_2,FUNCT_4,TREES_3,TREES_4,DTCONSTR,FUNCT_6,ZFMISC_1,CARD_3,MSATERM,PARTFUN2,FUNCOP_1,PBOOLE,PRALG_1,MSUALG_1,MSUALG_2,MSUALG_3,MSAFREE,PRE_CIRC,MSAFREE2,CIRCUIT1,TREES_1,EXTENS_1,RELSET_1,XBOOLE_0,XBOOLE_1,ORDINAL1,XXREAL_0,PARTFUN1,XXREAL_2,CARD_1,CKB1,CKB2;
schemes NAT_1,FINSEQ_1,PRE_CIRC,PBOOLE;
registrations XBOOLE_0,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,XREAL_0,MEMBERED,FINSEQ_1,CARD_3,TREES_3,PRE_CIRC,STRUCT_0,DTCONSTR,MSUALG_1,MSUALG_3,MSAFREE,MSAFREE2,CIRCUIT1,XXREAL_2,CARD_1,RELSET_1,PBOOLE;
constructors XXREAL_0,NAT_1,PRALG_1,MSUALG_3,MSATERM,CIRCUIT1,SEQ_1,SEQ_4,XXREAL_2,RELSET_1,FUNCT_4,FINSEQ_2,CKB3;
requirements NUMERALS,BOOLE,SUBSET;
begin
reserve IIG for  monotonic  Circuit-like non  void non  empty ManySortedSign;
definition
let IIG;
let A being  non-empty (Circuit of IIG);
let iv being (InputValues of A);
func Fix_inp iv -> (ManySortedFunction of ( FreeGen (the Sorts of A) ),(the Sorts of ( FreeEnv A ))) means 
:Def1: (for v being (Vertex of IIG) holds (((v in ( InputVertices IIG ) implies ( it . v ) = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( iv . v ),v ] ) )) & (v in ( SortsWithConstants IIG ) implies ( it . v ) = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( action_at v ),(the carrier of IIG) ] ) ))) & (v in ( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) ) implies ( it . v ) = ( id ( FreeGen (v,(the Sorts of A)) ) ))));
existence
proof
defpred P[ set,set ]
 means
(ex v being (Vertex of IIG) st (((v = $1 & ($1 in ( InputVertices IIG ) implies $2 = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( iv . v ),v ] ) ))) & ($1 in ( SortsWithConstants IIG ) implies $2 = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( action_at v ),(the carrier of IIG) ] ) ))) & ($1 in ( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) ) implies $2 = ( id ( FreeGen (v,(the Sorts of A)) ) ))));
A1:now
let i being set;
assume A2: i in (the carrier of IIG);
then reconsider v = i as (Vertex of IIG);
v in ( ( InputVertices IIG ) \/ ( InnerVertices IIG ) ) by A2,XBOOLE_1:45;
then A3: (v in ( InputVertices IIG ) or v in ( InnerVertices IIG )) by XBOOLE_0:def 3;
A4: ( ( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) ) \/ ( SortsWithConstants IIG ) ) = ( InnerVertices IIG ) by MSAFREE2:3,XBOOLE_1:45;
thus (ex j being set st P[ i,j ])
proof
per cases  by A4,A3,XBOOLE_0:def 3;
suppose A5: v in ( InputVertices IIG );

reconsider j = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( iv . v ),v ] ) ) as set;
take j;
take v;
thus v = i;
thus (i in ( InputVertices IIG ) implies j = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( iv . v ),v ] ) ));
hereby
A6: ( InputVertices IIG ) misses ( SortsWithConstants IIG ) by MSAFREE2:4;
assume i in ( SortsWithConstants IIG );
hence j = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( action_at v ),(the carrier of IIG) ] ) ) by A5,A6,XBOOLE_0:3;
end;
A7: (( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) ) c= ( InnerVertices IIG ) & ( InputVertices IIG ) misses ( InnerVertices IIG )) by XBOOLE_1:36,XBOOLE_1:79;
assume i in ( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) );
hence thesis by A5,A7,XBOOLE_0:3;
end;
suppose A8: v in ( SortsWithConstants IIG );

reconsider j = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( action_at v ),(the carrier of IIG) ] ) ) as set;
take j;
take v;
thus v = i;
hereby
A9: ( InputVertices IIG ) misses ( SortsWithConstants IIG ) by MSAFREE2:4;
assume i in ( InputVertices IIG );
hence j = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( iv . v ),v ] ) ) by A8,A9,XBOOLE_0:3;
end;
thus (i in ( SortsWithConstants IIG ) implies j = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( action_at v ),(the carrier of IIG) ] ) ));
A10: ( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) ) misses ( SortsWithConstants IIG ) by XBOOLE_1:79;
assume i in ( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) );
hence thesis by A8,A10,XBOOLE_0:3;
end;
suppose A11: v in ( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) );

reconsider j = ( id ( FreeGen (v,(the Sorts of A)) ) ) as set;
take j;
take v;
thus v = i;
hereby
A12: (( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) ) c= ( InnerVertices IIG ) & ( InputVertices IIG ) misses ( InnerVertices IIG )) by XBOOLE_1:36,XBOOLE_1:79;
assume i in ( InputVertices IIG );
hence j = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( iv . v ),v ] ) ) by A11,A12,XBOOLE_0:3;
end;
hereby
A13: ( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) ) misses ( SortsWithConstants IIG ) by XBOOLE_1:79;
assume i in ( SortsWithConstants IIG );
hence j = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( action_at v ),(the carrier of IIG) ] ) ) by A11,A13,XBOOLE_0:3;
end;
assume i in ( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) );
thus thesis;
end;
end;

end;
consider M being (ManySortedSet of (the carrier of IIG)) such that A14: (for i being set holds (i in (the carrier of IIG) implies P[ i,( M . i ) ])) from PBOOLE:sch 3(A1);
A15:now
let i being set;
A16: ( ( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) ) \/ ( SortsWithConstants IIG ) ) = ( InnerVertices IIG ) by MSAFREE2:3,XBOOLE_1:45;
assume A17: i in (the carrier of IIG);
then reconsider v = i as (Vertex of IIG);
v in ( ( InputVertices IIG ) \/ ( InnerVertices IIG ) ) by A17,XBOOLE_1:45;
then A18: (v in ( InputVertices IIG ) or v in ( InnerVertices IIG )) by XBOOLE_0:def 3;
A19: ( FreeGen (v,(the Sorts of A)) ) = ( ( FreeGen (the Sorts of A) ) . v ) by MSAFREE:def 16;
A20: ( FreeEnv A ) = MSAlgebra (# ( FreeSort (the Sorts of A) ),( FreeOper (the Sorts of A) ) #) by MSAFREE:def 14;
per cases  by A16,A18,XBOOLE_0:def 3;
suppose A21: v in ( InputVertices IIG );

then ( iv . v ) in ( (the Sorts of A) . v ) by MSAFREE2:def 5;
then A22: ( root-tree [ ( iv . v ),v ] ) in ( FreeGen (v,(the Sorts of A)) ) by MSAFREE:def 15;
P[ v,( M . v ) ] by A14;
hence ( M . i ) is (Function of ( ( FreeGen (the Sorts of A) ) . i ),( (the Sorts of ( FreeEnv A )) . i )) by A19,A20,A21,A22,FUNCOP_1:45;
end;
suppose A23: v in ( SortsWithConstants IIG );

reconsider sy = ( Sym (( action_at v ),(the Sorts of A)) ) as (NonTerminal of ( DTConMSA (the Sorts of A) ));
set p = ( <*> ( TS ( DTConMSA (the Sorts of A) ) ) );
set e = ( root-tree [ ( action_at v ),(the carrier of IIG) ] );
A24: ( SortsWithConstants IIG ) c= ( InnerVertices IIG ) by MSAFREE2:3;
v in { s where s is (SortSymbol of IIG): s is  with_const_op } by A23,MSAFREE2:def 1;
then (ex s being (SortSymbol of IIG) st (v = s & s is  with_const_op));
then consider o being (OperSymbol of IIG) such that A25: ( (the Arity of IIG) . o ) = ( {} ) and A26: ( (the ResultSort of IIG) . o ) = v by MSUALG_2:def 1;
A27: (for n being Nat holds (n in ( dom p ) implies ( p . n ) in ( FreeSort ((the Sorts of A),(( ( the_arity_of o ) /. n ) qua (SortSymbol of IIG))) )));
p = ( the_arity_of o ) by A25,MSUALG_1:def 1;
then A28: p in ( ( ( ( FreeSort (the Sorts of A) ) # ) * (the Arity of IIG) ) . o ) by A27,MSAFREE:9;
( the_result_sort_of o ) = v by A26,MSUALG_1:def 2;
then o = ( action_at v ) by A23,A24,MSAFREE2:def 7;
then sy ==> ( roots p ) by A28,MSAFREE:10;
then (( {} ) = ( <*> ( IIG -Terms (the Sorts of A) ) ) & p is (SubtreeSeq of ( Sym (( action_at v ),(the Sorts of A)) ))) by DTCONSTR:def 6;
then (e = ( [ ( action_at v ),(the carrier of IIG) ] -tree ( {} ) ) & ( {} ) is (ArgumentSeq of sy)) by MSATERM:def 2,TREES_4:20;
then e in ( IIG -Terms (the Sorts of A) ) by MSATERM:1;
then reconsider e as (Element of ( TS ( DTConMSA (the Sorts of A) ) )) by MSATERM:def 1;
(( e . ( {} ) ) = [ ( action_at v ),(the carrier of IIG) ] & ( the_result_sort_of ( action_at v ) ) = v) by A23,A24,MSAFREE2:def 7,TREES_4:3;
then e in { a where a is (Element of ( TS ( DTConMSA (the Sorts of A) ) )): ((ex x being set st (x in ( (the Sorts of A) . v ) & a = ( root-tree [ x,v ] ))) or (ex o being (OperSymbol of IIG) st ([ o,(the carrier of IIG) ] = ( a . ( {} ) ) & ( the_result_sort_of o ) = v))) };
then e in ( FreeSort ((the Sorts of A),v) ) by MSAFREE:def 10;
then A29: e in ( (the Sorts of ( FreeEnv A )) . v ) by A20,MSAFREE:def 11;
P[ v,( M . v ) ] by A14;
hence ( M . i ) is (Function of ( ( FreeGen (the Sorts of A) ) . i ),( (the Sorts of ( FreeEnv A )) . i )) by A19,A23,A29,FUNCOP_1:45;
end;
suppose A30: v in ( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) );

A31: (( dom ( id ( FreeGen (v,(the Sorts of A)) ) ) ) = ( FreeGen (v,(the Sorts of A)) ) & ( rng ( id ( FreeGen (v,(the Sorts of A)) ) ) ) = ( FreeGen (v,(the Sorts of A)) )) by RELAT_1:45;
P[ v,( M . v ) ] by A14;
hence ( M . i ) is (Function of ( ( FreeGen (the Sorts of A) ) . i ),( (the Sorts of ( FreeEnv A )) . i )) by A19,A20,A30,A31,FUNCT_2:def 1,RELSET_1:4;
end;
end;
now
let i being set;
assume i in ( dom M );
then i in (the carrier of IIG) by PARTFUN1:def 2;
hence ( M . i ) is Function by A15;
end;
then reconsider M as (ManySortedFunction of (the carrier of IIG)) by FUNCOP_1:def 6;
reconsider M as (ManySortedFunction of ( FreeGen (the Sorts of A) ),(the Sorts of ( FreeEnv A ))) by A15,PBOOLE:def 15;
take M;
let v being (Vertex of IIG);
hereby
assume A32: v in ( InputVertices IIG );
P[ v,( M . v ) ] by A14;
hence ( M . v ) = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( iv . v ),v ] ) ) by A32;
end;
hereby
assume A33: v in ( SortsWithConstants IIG );
P[ v,( M . v ) ] by A14;
hence ( M . v ) = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( action_at v ),(the carrier of IIG) ] ) ) by A33;
end;
assume A34: v in ( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) );
P[ v,( M . v ) ] by A14;
hence thesis by A34;
end;
uniqueness
proof
let M1 being (ManySortedFunction of ( FreeGen (the Sorts of A) ),(the Sorts of ( FreeEnv A )));
let M2 being (ManySortedFunction of ( FreeGen (the Sorts of A) ),(the Sorts of ( FreeEnv A )));
assume that
A35: (for v being (Vertex of IIG) holds (((v in ( InputVertices IIG ) implies ( M1 . v ) = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( iv . v ),v ] ) )) & (v in ( SortsWithConstants IIG ) implies ( M1 . v ) = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( action_at v ),(the carrier of IIG) ] ) ))) & (v in ( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) ) implies ( M1 . v ) = ( id ( FreeGen (v,(the Sorts of A)) ) ))))
and
A36: (for v being (Vertex of IIG) holds (((v in ( InputVertices IIG ) implies ( M2 . v ) = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( iv . v ),v ] ) )) & (v in ( SortsWithConstants IIG ) implies ( M2 . v ) = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( action_at v ),(the carrier of IIG) ] ) ))) & (v in ( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) ) implies ( M2 . v ) = ( id ( FreeGen (v,(the Sorts of A)) ) ))));
now
let i being set;
A37: ( ( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) ) \/ ( SortsWithConstants IIG ) ) = ( InnerVertices IIG ) by MSAFREE2:3,XBOOLE_1:45;
assume A38: i in (the carrier of IIG);
then reconsider v = i as (Vertex of IIG);
v in ( ( InputVertices IIG ) \/ ( InnerVertices IIG ) ) by A38,XBOOLE_1:45;
then A39: (v in ( InputVertices IIG ) or v in ( InnerVertices IIG )) by XBOOLE_0:def 3;
per cases  by A37,A39,XBOOLE_0:def 3;
suppose A40: v in ( InputVertices IIG );

then ( M1 . v ) = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( iv . v ),v ] ) ) by A35;
hence ( M1 . i ) = ( M2 . i ) by A36,A40;
end;
suppose A41: v in ( SortsWithConstants IIG );

then ( M1 . v ) = ( ( FreeGen (v,(the Sorts of A)) ) --> ( root-tree [ ( action_at v ),(the carrier of IIG) ] ) ) by A35;
hence ( M1 . i ) = ( M2 . i ) by A36,A41;
end;
suppose A42: v in ( ( InnerVertices IIG ) \ ( SortsWithConstants IIG ) );

then ( M1 . v ) = ( id ( FreeGen (v,(the Sorts of A)) ) ) by A35;
hence ( M1 . i ) = ( M2 . i ) by A36,A42;
end;
end;
hence M1 = M2 by PBOOLE:3;
end;
end;
