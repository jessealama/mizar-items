environ
vocabularies MSAFREE2,STRUCT_0,XBOOLE_0,MSUALG_1,RELAT_1,PBOOLE,MSAFREE,FUNCOP_1,FUNCT_1,TREES_3,FINSEQ_1,SUBSET_1,TREES_4,MSUALG_3,MARGREL1,FINSEQ_4,TARSKI,DTCONSTR,NAT_1,NUMBERS,TREES_2,CARD_3,PARTFUN1,ZFMISC_1,TDGROUP,CIRCUIT1,FSM_1,FUNCT_4,GLIB_000,UNIALG_2,MSATERM,PRELAMB,REALSET1,CARD_1,XXREAL_0,ARYTM_3,FUNCT_6,TREES_A,FINSET_1,CIRCUIT2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,XXREAL_0,NAT_1,FINSEQ_1,FINSEQ_2,FINSET_1,TREES_2,TREES_3,TREES_4,CARD_3,FUNCT_6,LANG1,DTCONSTR,PBOOLE,FUNCOP_1,XXREAL_2,STRUCT_0,PRALG_1,MSUALG_1,MSUALG_2,MSUALG_3,MSAFREE,MSAFREE2,CIRCUIT1,MSATERM,CKB3,CKB4,CKB5,CKB12;
definitions PBOOLE,MSAFREE2,CKB4,CKB5,CKB12;
theorems TARSKI,NAT_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,RELAT_1,GRFUNC_1,FUNCT_1,FUNCT_2,FUNCT_4,TREES_3,TREES_4,DTCONSTR,FUNCT_6,ZFMISC_1,CARD_3,MSATERM,PARTFUN2,FUNCOP_1,PBOOLE,PRALG_1,MSUALG_1,MSUALG_2,MSUALG_3,MSAFREE,PRE_CIRC,MSAFREE2,CIRCUIT1,TREES_1,EXTENS_1,RELSET_1,XBOOLE_0,XBOOLE_1,ORDINAL1,XXREAL_0,PARTFUN1,XXREAL_2,CARD_1,CKB1,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13;
schemes NAT_1,FINSEQ_1,PRE_CIRC,PBOOLE;
registrations XBOOLE_0,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,XREAL_0,MEMBERED,FINSEQ_1,CARD_3,TREES_3,PRE_CIRC,STRUCT_0,DTCONSTR,MSUALG_1,MSUALG_3,MSAFREE,MSAFREE2,CIRCUIT1,XXREAL_2,CARD_1,RELSET_1,PBOOLE;
constructors XXREAL_0,NAT_1,PRALG_1,MSUALG_3,MSATERM,CIRCUIT1,SEQ_1,SEQ_4,XXREAL_2,RELSET_1,FUNCT_4,FINSEQ_2,CKB3,CKB4,CKB5,CKB12;
requirements NUMERALS,BOOLE,SUBSET;
begin
reserve IIG for  monotonic  Circuit-like non void non empty ManySortedSign;
theorem
Th9: (for SCS being  non-empty (Circuit of IIG) holds (for v being (Vertex of IIG) holds (for iv being (InputValues of SCS) holds (for p being  DTree-yielding FinSequence holds (((v in ( InnerVertices IIG ) & ( dom p ) = ( dom ( the_arity_of ( action_at v ) ) )) & (for k being (Element of ( NAT )) holds (k in ( dom p ) implies ( p . k ) = ( IGTree (( ( the_arity_of ( action_at v ) ) /. k ),iv) )))) implies ( IGTree (v,iv) ) = ( [ ( action_at v ),(the carrier of IIG) ] -tree p ))))))
proof
let SCS being  non-empty (Circuit of IIG);
let v being (Vertex of IIG);
let iv being (InputValues of SCS);
let p being  DTree-yielding FinSequence;
assume that
A1: v in ( InnerVertices IIG )
and
A2: ( dom p ) = ( dom ( the_arity_of ( action_at v ) ) )
and
A3: (for k being (Element of ( NAT )) holds (k in ( dom p ) implies ( p . k ) = ( IGTree (( ( the_arity_of ( action_at v ) ) /. k ),iv) )));
set U1 = ( FreeEnv SCS );
set o = ( action_at v );
A4:now
let k being Nat;
assume k in ( dom p );
then ( p . k ) = ( IGTree (( ( the_arity_of o ) /. k ),iv) ) by A3;
hence ( p . k ) in ( (the Sorts of U1) . ( ( the_arity_of o ) /. k ) );
end;
( len p ) = ( len ( the_arity_of o ) ) by A2,FINSEQ_3:29;
then reconsider p99 = p as (Element of ( Args (o,U1) )) by A4,MSAFREE2:5;
set X = (the Sorts of SCS);
A5: ( dom (the ResultSort of IIG) ) = (the carrier' of IIG) by FUNCT_2:def 1;
A6: ( Result (o,U1) ) = ( ( (the Sorts of U1) * (the ResultSort of IIG) ) . o ) by MSUALG_1:def 5
.= ( (the Sorts of U1) . ( (the ResultSort of IIG) . o ) ) by A5,FUNCT_1:13;
A7: (U1 = MSAlgebra (# ( FreeSort X ),( FreeOper X ) #) & ( Args (o,U1) ) = ( ( ( (the Sorts of U1) # ) * (the Arity of IIG) ) . o )) by MSAFREE:def 14,MSUALG_1:def 4;
then reconsider p9 = p99 as (FinSequence of ( TS ( DTConMSA X ) )) by MSAFREE:8;
U1 = MSAlgebra (# ( FreeSort X ),( FreeOper X ) #) by MSAFREE:def 14;
then A8: ( Den (o,U1) ) = ( ( FreeOper X ) . o ) by MSUALG_1:def 6
.= ( DenOp (o,X) ) by MSAFREE:def 13;
( Sym (o,X) ) ==> ( roots p9 ) by A7,MSAFREE:10;
then A9: ( ( Den (o,U1) ) . p ) = ( ( Sym (o,X) ) -tree p9 ) by A8,MSAFREE:def 12
.= ( [ o,(the carrier of IIG) ] -tree p9 ) by MSAFREE:def 9;
( (the ResultSort of IIG) . o ) = ( the_result_sort_of o ) by MSUALG_1:def 2
.= v by A1,MSAFREE2:def 7;
then reconsider t = ( [ ( action_at v ),(the carrier of IIG) ] -tree p ) as (Element of ( (the Sorts of ( FreeMSA X )) . v )) by A9,A6,FUNCT_2:5;
now
let k being (Element of ( NAT ));
set v1 = ( ( the_arity_of ( action_at v ) ) /. k );
assume k in ( dom p );
then A10: ( p . k ) = ( IGTree (v1,iv) ) by A3;
then reconsider ek = ( p . k ) as (Element of ( (the Sorts of ( FreeEnv SCS )) . v1 ));
take ek;
thus ek = ( p . k );
(ex e1 being (Element of ( (the Sorts of ( FreeMSA X )) . v1 )) st (( card e1 ) = ( size (v1,SCS) ) & ek = ( ( ( Fix_inp_ext iv ) . v1 ) . e1 ))) by A10,CKB12:def 1;
hence ( card ek ) = ( size (v1,SCS) ) by CKB11:1;
end;
then A11: ( card t ) = ( size (v,SCS) ) by A1,CIRCUIT1:16;
now
let k being (Element of ( NAT ));
assume k in ( dom p );
then ( p . k ) = ( IGTree (( ( the_arity_of ( action_at v ) ) /. k ),iv) ) by A3;
hence ( p . k ) = ( ( ( Fix_inp_ext iv ) . ( ( the_arity_of ( action_at v ) ) /. k ) ) . ( p . k ) ) by CKB13:1;
end;
then ( [ ( action_at v ),(the carrier of IIG) ] -tree p ) = ( ( ( Fix_inp_ext iv ) . v ) . t ) by A1,CKB8:1;
hence thesis by A11,CKB12:def 1;
end;
