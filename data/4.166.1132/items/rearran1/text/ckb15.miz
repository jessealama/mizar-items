environ
vocabularies NUMBERS,SUBSET_1,REAL_1,XBOOLE_0,MEMBERED,PARTFUN1,VALUED_1,FUNCT_1,RELAT_1,FINSEQ_1,NAT_1,XXREAL_0,FINSET_1,CARD_1,ARYTM_1,TARSKI,ARYTM_3,ZFMISC_1,ORDINAL4,RFINSEQ,RFUNCT_3,CLASSES1,CARD_3,PBOOLE,FINSEQ_2,FUNCT_3,VALUED_0,REARRAN1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,MEMBERED,FUNCT_1,RELSET_1,CARD_1,FINSET_1,NUMBERS,XXREAL_0,XCMPLX_0,REAL_1,NAT_1,PARTFUN1,FINSEQ_1,VALUED_1,SEQ_1,RFUNCT_1,FINSEQOP,RVSUM_1,CLASSES1,RFINSEQ,RFUNCT_3,CKB1,CKB3,CKB4,CKB8,CKB10;
definitions TARSKI,XBOOLE_0,FINSEQ_2,RELAT_1,CKB3,CKB4,CKB8;
theorems FINSEQ_1,NAT_1,FUNCT_1,FINSEQ_2,TARSKI,CARD_2,CARD_1,PARTFUN1,FINSET_1,FINSEQ_3,RFUNCT_1,RVSUM_1,ZFMISC_1,RFINSEQ,RFUNCT_3,RELAT_1,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,FUNCOP_1,ORDINAL1,VALUED_1,CLASSES1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB11,CKB12,CKB13,CKB14;
schemes NAT_1,FINSEQ_1;
registrations SUBSET_1,RELSET_1,PARTFUN1,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,MEMBERED,FINSEQ_1,VALUED_0,CARD_1,FINSEQ_2,FUNCT_1,CKB9;
constructors REAL_1,NAT_1,FINSEQOP,RVSUM_1,RFINSEQ,RFUNCT_3,SEQ_1,CLASSES1,RELSET_1,BINOP_2,CKB1,CKB3,CKB4,CKB8;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve n for (Element of ( NAT ));
reserve m for (Element of ( NAT ));
reserve D for non empty  finite set;
theorem
Th5: (for a being  ascending  terms've_same_card_as_number (FinSequence of ( bool D )) holds (for n holds (for m holds (((n in ( dom a ) & m in ( dom a )) & n <> m) implies ( a . n ) <> ( a . m )))))
proof
let A being  ascending  terms've_same_card_as_number (FinSequence of ( bool D ));
let n;
let m;
assume that
A1: n in ( dom A )
and
A2: m in ( dom A )
and
A3: (n <> m & ( A . n ) = ( A . m ));
A4: (1 <= m & m <= ( len A )) by A2,FINSEQ_3:25;
A5: (1 <= n & n <= ( len A )) by A1,FINSEQ_3:25;
reconsider Am = ( A . m ) as  finite set by A4,CKB5:1;
( card Am ) = m by A4,CKB3:def 1;
hence contradiction by A3,A5,CKB3:def 1;
end;
