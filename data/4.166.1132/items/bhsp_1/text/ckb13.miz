environ
vocabularies NUMBERS,RLVECT_1,STRUCT_0,SUBSET_1,ALGSTR_0,BINOP_1,FUNCT_1,ZFMISC_1,XBOOLE_0,REAL_1,PRE_TOPC,SUPINF_2,PROB_2,RLSUB_1,FUNCOP_1,CARD_1,ARYTM_3,RELAT_1,XXREAL_0,XREAL_0,ORDINAL1,ARYTM_1,COMPLEX1,SQUARE_1,FUNCT_3,RVSUM_1,NORMSP_1,METRIC_1,NAT_1,BHSP_1,PARTFUN1,CKB6;
notations XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,NUMBERS,XCMPLX_0,XREAL_0,COMPLEX1,REAL_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCOP_1,BINOP_1,NAT_1,STRUCT_0,ALGSTR_0,DOMAIN_1,PRE_TOPC,RLVECT_1,RLSUB_1,SQUARE_1,VFUNCT_1,NORMSP_1,QUIN_1,XXREAL_0,CKB1,CKB4,CKB6,CKB12;
definitions NORMSP_1,STRUCT_0,SQUARE_1,ALGSTR_0,RLVECT_1,VALUED_0,FUNCT_2,CKB4,CKB6,CKB12;
theorems TARSKI,SQUARE_1,ABSVALUE,RLVECT_1,RLSUB_1,QUIN_1,FUNCT_2,NORMSP_1,XREAL_0,COMPLEX1,FUNCOP_1,XREAL_1,XXREAL_0,ALGSTR_0,VALUED_0,ORDINAL1,VFUNCT_1,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12;
schemes FUNCT_2;
registrations SUBSET_1,ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,SQUARE_1,MEMBERED,STRUCT_0,XBOOLE_0,ALGSTR_0,FUNCT_2,VFUNCT_1,CKB1,CKB2,CKB3;
constructors BINOP_1,DOMAIN_1,FUNCOP_1,REAL_1,SQUARE_1,NAT_1,MEMBERED,COMPLEX1,SEQ_1,QUIN_1,RLSUB_1,NORMSP_1,RELSET_1,VFUNCT_1,CKB1,CKB4,CKB6,CKB12;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve X for non empty UNITSTR;
reserve a for Real;
reserve x for (Point of X);
reserve y for (Point of X);
Lm6:now
let x being (Point of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #)),y being (Point of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #)),z being (Point of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #));
let a;
( 0. UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #) ) = ( 0. the RealLinearSpace ) by RLSUB_1:11;
hence (( x .|. x ) = ( 0 ) iff x = ( 0. UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #) )) by CKB5:1,FUNCOP_1:7,TARSKI:def 1;
thus ( 0 ) <= ( x .|. x ) by FUNCOP_1:7;
thus ( x .|. y ) = ( y .|. x ) by CKB9:1;
thus ( ( x + y ) .|. z ) = ( ( x .|. z ) + ( y .|. z ) )
proof
reconsider u = x,v = y,w = z as (VECTOR of ( (0). the RealLinearSpace ));
( ( x + y ) .|. z ) = ( nilfunc . [ ( u + v ),w ] );
hence thesis by CKB10:1;
end;

thus ( ( a * x ) .|. y ) = ( a * ( x .|. y ) )
proof
reconsider u = x,v = y as (VECTOR of ( (0). the RealLinearSpace ));
( ( a * x ) .|. y ) = ( nilfunc . [ ( a * u ),v ] );
hence thesis by CKB11:1;
end;

end;
registration
cluster  RealUnitarySpace-like  vector-distributive  scalar-distributive  scalar-associative  scalar-unital  Abelian  add-associative  right_zeroed  right_complementable  strict for non empty non empty UNITSTR;
existence
proof
take UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #);
thus UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #) is  RealUnitarySpace-like by CKB12:def 1,Lm6;
thus UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #) is  vector-distributive  scalar-distributive  scalar-associative  scalar-unital
proof
thus (for a being  real number holds (for v,w being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #)) holds ( a * ( v + w ) ) = ( ( a * v ) + ( a * w ) )))
proof
let a being  real number;
let v being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #)),w being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #));
reconsider v9 = v,w9 = w as (VECTOR of ( (0). the RealLinearSpace ));
thus ( a * ( v + w ) ) = ( a * ( v9 + w9 ) )
.= ( ( a * v9 ) + ( a * w9 ) ) by RLVECT_1:def 5
.= ( ( a * v ) + ( a * w ) );
end;

thus (for a,b being  real number holds (for v being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #)) holds ( ( a + b ) * v ) = ( ( a * v ) + ( b * v ) )))
proof
let a being  real number,b being  real number;
let v being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #));
reconsider v9 = v as (VECTOR of ( (0). the RealLinearSpace ));
thus ( ( a + b ) * v ) = ( ( a + b ) * v9 )
.= ( ( a * v9 ) + ( b * v9 ) ) by RLVECT_1:def 6
.= ( ( a * v ) + ( b * v ) );
end;

thus (for a,b being  real number holds (for v being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #)) holds ( ( a * b ) * v ) = ( a * ( b * v ) )))
proof
let a being  real number,b being  real number;
let v being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #));
reconsider v9 = v as (VECTOR of ( (0). the RealLinearSpace ));
thus ( ( a * b ) * v ) = ( ( a * b ) * v9 )
.= ( a * ( b * v9 ) ) by RLVECT_1:def 7
.= ( a * ( b * v ) );
end;

let v being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #));
reconsider v9 = v as (VECTOR of ( (0). the RealLinearSpace ));
thus ( 1 * v ) = ( 1 * v9 )
.= v by RLVECT_1:def 8;
end;

A1: (for x,y being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #)) holds (for x9,y9 being (VECTOR of ( (0). the RealLinearSpace )) holds ((x = x9 & y = y9) implies (( x + y ) = ( x9 + y9 ) & (for a holds ( a * x ) = ( a * x9 ))))));
thus (for v,w being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #)) holds ( v + w ) = ( w + v ))
proof
let v being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #)),w being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #));
reconsider v9 = v,w9 = w as (VECTOR of ( (0). the RealLinearSpace ));
thus ( v + w ) = ( w9 + v9 ) by A1
.= ( w + v );
end;

thus (for u,v,w being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #)) holds ( ( u + v ) + w ) = ( u + ( v + w ) ))
proof
let u being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #)),v being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #)),w being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #));
reconsider u9 = u,v9 = v,w9 = w as (VECTOR of ( (0). the RealLinearSpace ));
thus ( ( u + v ) + w ) = ( ( u9 + v9 ) + w9 )
.= ( u9 + ( v9 + w9 ) ) by RLVECT_1:def 3
.= ( u + ( v + w ) );
end;

thus (for v being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #)) holds ( v + ( 0. UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #) ) ) = v)
proof
let v being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #));
reconsider v9 = v as (VECTOR of ( (0). the RealLinearSpace ));
thus ( v + ( 0. UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #) ) ) = ( v9 + ( 0. ( (0). the RealLinearSpace ) ) )
.= v by RLVECT_1:4;
end;

thus UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #) is  right_complementable
proof
let v being (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #));
reconsider v9 = v as (VECTOR of ( (0). the RealLinearSpace ));
consider w9 being (VECTOR of ( (0). the RealLinearSpace )) such that A2: ( v9 + w9 ) = ( 0. ( (0). the RealLinearSpace ) ) by ALGSTR_0:def 11;
reconsider w = w9 as (VECTOR of UNITSTR (# (the carrier of ( (0). the RealLinearSpace )),( 0. ( (0). the RealLinearSpace ) ),(the addF of ( (0). the RealLinearSpace )),(the Mult of ( (0). the RealLinearSpace )),nilfunc #));
take w;
thus thesis by A2;
end;

thus thesis;
end;
end;
