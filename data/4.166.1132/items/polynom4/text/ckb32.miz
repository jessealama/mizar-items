environ
vocabularies NUMBERS,XBOOLE_0,FINSEQ_1,SUBSET_1,XXREAL_0,RELAT_1,ARYTM_1,ORDINAL4,FUNCT_1,RFINSEQ,ALGSTR_1,ALGSTR_0,VECTSP_1,SUPINF_2,ARYTM_3,VECTSP_2,BINOP_1,MESFUNC1,STRUCT_0,RLVECT_1,LATTICES,GROUP_1,ZFMISC_1,NAT_1,POLYNOM3,CARD_3,CARD_1,ALGSEQ_1,POLYNOM1,TARSKI,PARTFUN1,FUNCT_4,POLYNOM2,FINSEQ_2,MSSUBFAM,QUOFIELD,POLYNOM4;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,BINOP_1,FINSEQ_1,NAT_1,STRUCT_0,ALGSTR_0,FINSEQ_2,FUNCT_7,RFINSEQ,NAT_D,RLVECT_1,VFUNCT_1,GROUP_1,VECTSP_1,VECTSP_2,NORMSP_1,FVSUM_1,ALGSTR_1,GRCAT_1,QUOFIELD,BHSP_1,ALGSEQ_1,POLYNOM3,GROUP_6,XXREAL_0,CKB14,CKB22;
definitions ALGSEQ_1,QUOFIELD,GROUP_1,GRCAT_1,GROUP_6,POLYNOM3,FINSEQ_2,CKB14,CKB22;
theorems NAT_1,FUNCT_2,FUNCT_7,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSEQ_4,FINSEQ_5,RFINSEQ,RLVECT_1,VECTSP_1,VECTSP_2,FVSUM_1,NORMSP_1,ALGSEQ_1,GROUP_1,POLYNOM2,POLYNOM3,INT_1,NAT_2,MATRIX_3,ALGSTR_1,XREAL_1,XXREAL_0,BHSP_1,PARTFUN1,ORDINAL1,ALGSTR_0,XREAL_0,CARD_1,CKB1,CKB2,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31;
schemes NAT_1,FINSEQ_2,POLYNOM3,FUNCT_2;
registrations ORDINAL1,RELSET_1,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,FINSEQ_2,STRUCT_0,VECTSP_1,ALGSTR_1,POLYNOM3,XBOOLE_0,ALGSTR_0,CARD_1,VFUNCT_1,FUNCT_2,CKB3,CKB4,CKB16;
constructors SQUARE_1,FINSEQOP,FINSOP_1,RFINSEQ,NAT_D,ALGSEQ_1,BHSP_1,GRCAT_1,GROUP_6,QUOFIELD,POLYNOM1,POLYNOM3,SEQ_1,REAL_1,ALGSTR_1,RELSET_1,FUNCT_7,FVSUM_1,VFUNCT_1,CKB14,CKB22;
requirements NUMERALS,SUBSET,REAL,BOOLE,ARITHM;
begin
theorem
Th26: (for L being  add-associative  right_zeroed  right_complementable  Abelian  left_unital  distributive  commutative  associative non  trivial doubleLoopStr holds (for p,q being (Polynomial of L) holds (for x being (Element of L) holds ( eval (( ( Leading-Monomial p ) *' q ),x) ) = ( ( eval (( Leading-Monomial p ),x) ) * ( eval (q,x) ) ))))
proof
let L being  add-associative  right_zeroed  right_complementable  Abelian  left_unital  distributive  commutative  associative non  trivial doubleLoopStr;
let p1 being (Polynomial of L);
let q being (Polynomial of L);
let x being (Element of L);
set p = ( Leading-Monomial p1 );
defpred P[ Nat ]
 means
(for q being (Polynomial of L) holds (( len q ) = $1 implies ( eval (( p *' q ),x) ) = ( ( eval (p,x) ) * ( eval (q,x) ) )));
A1: (for k being Nat holds ((for n being Nat holds (n < k implies P[ n ])) implies P[ k ]))
proof
let k being Nat;
assume A2: (for n being Nat holds (n < k implies (for q being (Polynomial of L) holds (( len q ) = n implies ( eval (( p *' q ),x) ) = ( ( eval (p,x) ) * ( eval (q,x) ) )))));
let q being (Polynomial of L);
assume A3: ( len q ) = k;
per cases ;
suppose A4: ( len q ) <> ( 0 );

set LMq = ( Leading-Monomial q );
consider r being (Polynomial of L) such that A5: ( len r ) < ( len q ) and A6: q = ( r + ( Leading-Monomial q ) ) and (for n being (Element of ( NAT )) holds (n < ( ( len q ) - 1 ) implies ( r . n ) = ( q . n ))) by A4,CKB21:1;
thus ( eval (( p *' q ),x) ) = ( eval (( ( p *' r ) + ( p *' LMq ) ),x) ) by A6,POLYNOM3:31
.= ( ( eval (( p *' r ),x) ) + ( eval (( p *' LMq ),x) ) ) by CKB26:1
.= ( ( ( eval (p,x) ) * ( eval (r,x) ) ) + ( eval (( p *' LMq ),x) ) ) by A2,A3,A5
.= ( ( ( eval (p,x) ) * ( eval (r,x) ) ) + ( ( eval (p,x) ) * ( eval (LMq,x) ) ) ) by CKB31:1
.= ( ( eval (p,x) ) * ( ( eval (r,x) ) + ( eval (LMq,x) ) ) ) by VECTSP_1:def 7
.= ( ( eval (p,x) ) * ( eval (q,x) ) ) by A6,CKB26:1;
end;
suppose ( len q ) = ( 0 );

then A7: q = ( 0_. L ) by CKB8:1;
hence ( eval (( p *' q ),x) ) = ( eval (( 0_. L ),x) ) by POLYNOM3:34
.= ( 0. L ) by CKB23:1
.= ( ( eval (p,x) ) * ( 0. L ) ) by VECTSP_1:7
.= ( ( eval (p,x) ) * ( eval (q,x) ) ) by A7,CKB23:1;
end;
end;
A8: (for n being Nat holds P[ n ]) from NAT_1:sch 4(A1);
( len q ) = ( len q );
hence thesis by A8;
end;
