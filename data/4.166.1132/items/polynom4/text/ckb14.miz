environ
vocabularies NUMBERS,XBOOLE_0,FINSEQ_1,SUBSET_1,XXREAL_0,RELAT_1,ARYTM_1,ORDINAL4,FUNCT_1,RFINSEQ,ALGSTR_1,ALGSTR_0,VECTSP_1,SUPINF_2,ARYTM_3,VECTSP_2,BINOP_1,MESFUNC1,STRUCT_0,RLVECT_1,LATTICES,GROUP_1,ZFMISC_1,NAT_1,POLYNOM3,CARD_3,CARD_1,ALGSEQ_1,POLYNOM1,TARSKI,PARTFUN1,FUNCT_4,POLYNOM2,FINSEQ_2,MSSUBFAM,QUOFIELD,POLYNOM4;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,BINOP_1,FINSEQ_1,NAT_1,STRUCT_0,ALGSTR_0,FINSEQ_2,FUNCT_7,RFINSEQ,NAT_D,RLVECT_1,VFUNCT_1,GROUP_1,VECTSP_1,VECTSP_2,NORMSP_1,FVSUM_1,ALGSTR_1,GRCAT_1,QUOFIELD,BHSP_1,ALGSEQ_1,POLYNOM3,GROUP_6,XXREAL_0;
definitions ALGSEQ_1,QUOFIELD,GROUP_1,GRCAT_1,GROUP_6,POLYNOM3,FINSEQ_2;
theorems NAT_1,FUNCT_2,FUNCT_7,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSEQ_4,FINSEQ_5,RFINSEQ,RLVECT_1,VECTSP_1,VECTSP_2,FVSUM_1,NORMSP_1,ALGSEQ_1,GROUP_1,POLYNOM2,POLYNOM3,INT_1,NAT_2,MATRIX_3,ALGSTR_1,XREAL_1,XXREAL_0,BHSP_1,PARTFUN1,ORDINAL1,ALGSTR_0,XREAL_0,CARD_1,CKB1,CKB2,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13;
schemes NAT_1,FINSEQ_2,POLYNOM3,FUNCT_2;
registrations ORDINAL1,RELSET_1,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,FINSEQ_2,STRUCT_0,VECTSP_1,ALGSTR_1,POLYNOM3,XBOOLE_0,ALGSTR_0,CARD_1,VFUNCT_1,FUNCT_2,CKB3,CKB4;
constructors SQUARE_1,FINSEQOP,FINSOP_1,RFINSEQ,NAT_D,ALGSEQ_1,BHSP_1,GRCAT_1,GROUP_6,QUOFIELD,POLYNOM1,POLYNOM3,SEQ_1,REAL_1,ALGSTR_1,RELSET_1,FUNCT_7,FVSUM_1,VFUNCT_1;
requirements NUMERALS,SUBSET,REAL,BOOLE,ARITHM;
begin
definition
let L being non  empty ZeroStr;
let p being (Polynomial of L);
func Leading-Monomial p -> (sequence of L) means 
:Def1: (( it . ( ( len p ) -' 1 ) ) = ( p . ( ( len p ) -' 1 ) ) & (for n being (Element of ( NAT )) holds (n <> ( ( len p ) -' 1 ) implies ( it . n ) = ( 0. L ))));
existence
proof
reconsider P = ( ( 0_. L ) +* (( ( len p ) -' 1 ),( p . ( ( len p ) -' 1 ) )) ) as (sequence of L);
take P;
( ( len p ) -' 1 ) in ( NAT );
then ( ( len p ) -' 1 ) in ( dom ( 0_. L ) ) by NORMSP_1:12;
hence ( P . ( ( len p ) -' 1 ) ) = ( p . ( ( len p ) -' 1 ) ) by FUNCT_7:31;
let n being (Element of ( NAT ));
assume n <> ( ( len p ) -' 1 );
hence ( P . n ) = ( ( 0_. L ) . n ) by FUNCT_7:32
.= ( 0. L ) by FUNCOP_1:7;
end;
uniqueness
proof
let P1 being (sequence of L);
let P2 being (sequence of L);
assume that
A1: ( P1 . ( ( len p ) -' 1 ) ) = ( p . ( ( len p ) -' 1 ) )
and
A2: (for n being (Element of ( NAT )) holds (n <> ( ( len p ) -' 1 ) implies ( P1 . n ) = ( 0. L )))
and
A3: ( P2 . ( ( len p ) -' 1 ) ) = ( p . ( ( len p ) -' 1 ) )
and
A4: (for n being (Element of ( NAT )) holds (n <> ( ( len p ) -' 1 ) implies ( P2 . n ) = ( 0. L )));
now
let i being (Element of ( NAT ));
per cases ;
suppose i = ( ( len p ) -' 1 );

hence ( P1 . i ) = ( P2 . i ) by A1,A3;
end;
suppose A5: i <> ( ( len p ) -' 1 );

hence ( P1 . i ) = ( 0. L ) by A2
.= ( P2 . i ) by A4,A5;
end;
end;
hence P1 = P2 by FUNCT_2:63;
end;
end;
