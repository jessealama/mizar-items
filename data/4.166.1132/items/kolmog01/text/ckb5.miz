environ
vocabularies NUMBERS,XBOOLE_0,PROB_1,SETFAM_1,SUBSET_1,RPR_1,FUNCT_1,TARSKI,RELAT_1,REAL_1,CARD_1,ARYTM_1,CARD_3,PROB_3,NAT_1,ARYTM_3,ZFMISC_1,PROB_2,XREAL_0,ORDINAL1,DYNKIN,VALUED_1,XXREAL_0,SERIES_1,ORDINAL2,FUNCOP_1,FINSEQ_1,FINSET_1,FINSUB_1,SETWISEO,ORDINAL4,EQREL_1,KOLMOG01;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,REAL_1,ORDINAL1,XCMPLX_0,XXREAL_0,NAT_1,XREAL_0,NUMBERS,FINSET_1,DYNKIN,FINSUB_1,RELAT_1,CARD_3,SEQ_2,SETFAM_1,FUNCT_1,RELSET_1,VALUED_1,FINSEQ_1,RVSUM_1,PARTFUN1,FUNCT_2,PROB_3,SERIES_1,FUNCOP_1,SETWISEO,FINSEQOP,KURATO_0,PROB_1,PROB_2,CKB4;
definitions PROB_1,SUBSET_1,TARSKI,XBOOLE_0,PROB_3,CARD_3,CKB4;
theorems XCMPLX_1,PROB_1,TARSKI,SUBSET_1,XBOOLE_0,DYNKIN,ZFMISC_1,PROB_2,XBOOLE_1,SERIES_1,PROB_3,PROB_4,FUNCT_1,FUNCT_2,SEQ_1,SEQ_2,RELAT_1,SETFAM_1,CARD_5,FINSUB_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,RVSUM_1,ORDINAL1,WELLORD2,FINSEQOP,NAT_1,VALUED_0,FUNCOP_1,RELSET_1,CKB1,CKB2,CKB3,CKB4;
schemes NAT_1,XBOOLE_0,SETWISEO,PARTFUN1,FUNCT_2;
registrations XBOOLE_0,SUBSET_1,ORDINAL1,VALUED_1,RELSET_1,NUMBERS,XREAL_0,MEMBERED,PROB_1,RELAT_1,FINSET_1,FINSEQ_1,FINSUB_1,FUNCT_1,FUNCT_2,VALUED_0,PROB_3;
constructors SEQ_2,DYNKIN,REAL_1,SEQ_1,PROB_3,SERIES_1,KURATO_0,RINFSUP1,SETFAM_1,BINOP_2,RVSUM_1,WELLORD2,FINSEQOP,SETWISEO,RELSET_1,MEASURE1,CKB4;
requirements SUBSET,NUMERALS,BOOLE,ARITHM;
begin
reserve Omega for non  empty set;
reserve Sigma for (SigmaField of Omega);
reserve P for (Probability of Sigma);
reserve B for non  empty (Subset of Sigma);
reserve b for (Element of B);
reserve n for (Element of ( NAT ));
reserve m for (Element of ( NAT ));
reserve x for set;
theorem
Th4: (for f being (SetSequence of Sigma) holds (((for n holds (for b holds ( P . ( ( f . n ) /\ b ) ) = ( ( P . ( f . n ) ) * ( P . b ) ))) & f is  disjoint_valued) implies ( P . ( b /\ ( Union f ) ) ) = ( ( P . b ) * ( P . ( Union f ) ) )))
proof
let f being (SetSequence of Sigma);
reconsider b as (Element of Sigma);
reconsider r = ( P . b ) as  real number;
(for n holds ( ( seqIntersection (b,f) ) . n ) is (Event of Sigma))
proof
let n;
( b /\ ( f . n ) ) is (Event of Sigma);
hence thesis by DYNKIN:def 1;
end;
then reconsider seqIntf = ( seqIntersection (b,f) ) as (SetSequence of Sigma) by PROB_1:25;
(for n holds ( ( seqIntersection (b,( Partial_Union f )) ) . n ) is (Event of Sigma))
proof
let n;
( b /\ ( ( Partial_Union f ) . n ) ) is (Event of Sigma);
hence thesis by DYNKIN:def 1;
end;
then reconsider seqIntPf = ( seqIntersection (b,( Partial_Union f )) ) as (SetSequence of Sigma) by PROB_1:25;
A1: ( b /\ ( Union f ) ) = ( b /\ ( Union ( Partial_Union f ) ) ) by PROB_3:15
.= ( Union seqIntPf ) by DYNKIN:10;
assume A2: (for n holds (for b holds ( P . ( ( f . n ) /\ b ) ) = ( ( P . ( f . n ) ) * ( P . b ) )));
now
let n being (Element of ( NAT ));
thus ( ( P * seqIntf ) . n ) = ( P . ( seqIntf . n ) ) by FUNCT_2:15
.= ( P . ( ( f . n ) /\ b ) ) by DYNKIN:def 1
.= ( ( P . ( f . n ) ) * ( P . b ) ) by A2
.= ( ( ( P * f ) . n ) * r ) by FUNCT_2:15
.= ( ( r (#) ( P * f ) ) . n ) by SEQ_1:9;
end;
then A3: ( P * seqIntf ) = ( r (#) ( P * f ) ) by FUNCT_2:def 7;
A4: (for n holds (for m holds (n <= m implies (x in ( ( Partial_Union f ) . n ) implies x in ( ( Partial_Union f ) . m )))))
proof
reconsider Pf = ( Partial_Union f ) as (SetSequence of Sigma);
let n;
let m;
assume A5: n <= m;
assume A6: x in ( ( Partial_Union f ) . n );
Pf is  non-descending by PROB_3:11;
then ( Pf . n ) c= ( Pf . m ) by A5,PROB_1:def 5;
hence thesis by A6;
end;
(for n holds (for m holds (n <= m implies ( ( seqIntersection (b,( Partial_Union f )) ) . n ) c= ( ( seqIntersection (b,( Partial_Union f )) ) . m ))))
proof
let n;
let m;
assume A7: n <= m;
let x;
assume x in ( ( seqIntersection (b,( Partial_Union f )) ) . n );
then A8: x in ( b /\ ( ( Partial_Union f ) . n ) ) by DYNKIN:def 1;
then x in ( ( Partial_Union f ) . n ) by XBOOLE_0:def 4;
then A9: x in ( ( Partial_Union f ) . m ) by A4,A7;
x in b by A8,XBOOLE_0:def 4;
then x in ( b /\ ( ( Partial_Union f ) . m ) ) by A9,XBOOLE_0:def 4;
hence thesis by DYNKIN:def 1;
end;
then A10: ( seqIntersection (b,( Partial_Union f )) ) is  non-descending by PROB_1:def 5;
assume A11: f is  disjoint_valued;
then A12: ( seqIntersection (b,f) ) is  disjoint_valued by DYNKIN:9;
(for n holds ( ( Partial_Union seqIntf ) . n ) = ( ( seqIntersection (b,( Partial_Union f )) ) . n ))
proof
defpred P[ Nat ]
 means
( ( Partial_Union seqIntf ) . $1 ) = ( ( seqIntersection (b,( Partial_Union f )) ) . $1 );
let n;
A13: (for k being Nat holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k being Nat;
assume that
A14: ( ( Partial_Union seqIntf ) . k ) = ( ( seqIntersection (b,( Partial_Union f )) ) . k );
reconsider k as (Element of ( NAT )) by ORDINAL1:def 12;
( ( Partial_Union seqIntf ) . ( k + 1 ) ) = ( ( ( Partial_Union seqIntf ) . k ) \/ ( seqIntf . ( k + 1 ) ) ) by PROB_3:def 2
.= ( ( b /\ ( ( Partial_Union f ) . k ) ) \/ ( seqIntf . ( k + 1 ) ) ) by A14,DYNKIN:def 1
.= ( ( b /\ ( ( Partial_Union f ) . k ) ) \/ ( b /\ ( f . ( k + 1 ) ) ) ) by DYNKIN:def 1
.= ( b /\ ( ( ( Partial_Union f ) . k ) \/ ( f . ( k + 1 ) ) ) ) by XBOOLE_1:23
.= ( b /\ ( ( Partial_Union f ) . ( k + 1 ) ) ) by PROB_3:def 2
.= ( ( seqIntersection (b,( Partial_Union f )) ) . ( k + 1 ) ) by DYNKIN:def 1;
hence thesis;
end;
( ( Partial_Union seqIntf ) . ( 0 ) ) = ( seqIntf . ( 0 ) ) by PROB_3:def 2
.= ( b /\ ( f . ( 0 ) ) ) by DYNKIN:def 1
.= ( b /\ ( ( Partial_Union f ) . ( 0 ) ) ) by PROB_3:def 2
.= ( ( seqIntersection (b,( Partial_Union f )) ) . ( 0 ) ) by DYNKIN:def 1;
then A15: P[ ( 0 ) ];
(for k being Nat holds P[ k ]) from NAT_1:sch 2(A15,A13);
hence thesis;
end;
then ( P * ( seqIntersection (b,( Partial_Union f )) ) ) = ( P * ( Partial_Union seqIntf ) ) by FUNCT_2:63
.= ( Partial_Sums ( P * seqIntf ) ) by A12,PROB_3:44
.= ( r (#) ( Partial_Sums ( P * f ) ) ) by A3,SERIES_1:9
.= ( r (#) ( P * ( Partial_Union f ) ) ) by A11,PROB_3:44;
then ( r * ( lim ( P * ( Partial_Union f ) ) ) ) = ( lim ( P * seqIntPf ) ) by PROB_3:41,SEQ_2:8
.= ( P . ( b /\ ( Union f ) ) ) by A10,A1,PROB_2:10;
hence thesis by PROB_3:41;
end;
