environ
vocabularies NUMBERS,XBOOLE_0,PROB_1,SETFAM_1,SUBSET_1,RPR_1,FUNCT_1,TARSKI,RELAT_1,REAL_1,CARD_1,ARYTM_1,CARD_3,PROB_3,NAT_1,ARYTM_3,ZFMISC_1,PROB_2,XREAL_0,ORDINAL1,DYNKIN,VALUED_1,XXREAL_0,SERIES_1,ORDINAL2,FUNCOP_1,FINSEQ_1,FINSET_1,FINSUB_1,SETWISEO,ORDINAL4,EQREL_1,KOLMOG01;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,REAL_1,ORDINAL1,XCMPLX_0,XXREAL_0,NAT_1,XREAL_0,NUMBERS,FINSET_1,DYNKIN,FINSUB_1,RELAT_1,CARD_3,SEQ_2,SETFAM_1,FUNCT_1,RELSET_1,VALUED_1,FINSEQ_1,RVSUM_1,PARTFUN1,FUNCT_2,PROB_3,SERIES_1,FUNCOP_1,SETWISEO,FINSEQOP,KURATO_0,PROB_1,PROB_2;
definitions PROB_1,SUBSET_1,TARSKI,XBOOLE_0,PROB_3,CARD_3;
theorems XCMPLX_1,PROB_1,TARSKI,SUBSET_1,XBOOLE_0,DYNKIN,ZFMISC_1,PROB_2,XBOOLE_1,SERIES_1,PROB_3,PROB_4,FUNCT_1,FUNCT_2,SEQ_1,SEQ_2,RELAT_1,SETFAM_1,CARD_5,FINSUB_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,RVSUM_1,ORDINAL1,WELLORD2,FINSEQOP,NAT_1,VALUED_0,FUNCOP_1,RELSET_1,CKB1,CKB2;
schemes NAT_1,XBOOLE_0,SETWISEO,PARTFUN1,FUNCT_2;
registrations XBOOLE_0,SUBSET_1,ORDINAL1,VALUED_1,RELSET_1,NUMBERS,XREAL_0,MEMBERED,PROB_1,RELAT_1,FINSET_1,FINSEQ_1,FINSUB_1,FUNCT_1,FUNCT_2,VALUED_0,PROB_3;
constructors SEQ_2,DYNKIN,REAL_1,SEQ_1,PROB_3,SERIES_1,KURATO_0,RINFSUP1,SETFAM_1,BINOP_2,RVSUM_1,WELLORD2,FINSEQOP,SETWISEO,RELSET_1,MEASURE1;
requirements SUBSET,NUMERALS,BOOLE,ARITHM;
begin
reserve Omega for non empty set;
reserve n for (Element of ( NAT ));
reserve x for set;
theorem
Th3: (for X being (Subset-Family of Omega) holds (X = ( {} ) implies ( sigma X ) = { ( {} ),Omega }))
proof
let X being (Subset-Family of Omega);
A1: (for A1 being (SetSequence of Omega) holds (( rng A1 ) c= { ( {} ),Omega } implies ( Union A1 ) in { ( {} ),Omega }))
proof
let A1 being (SetSequence of Omega);
assume A2: ( rng A1 ) c= { ( {} ),Omega };
A3: (for n holds (( ( Partial_Union A1 ) . n ) = ( {} ) or ( ( Partial_Union A1 ) . n ) = Omega))
proof
defpred P[ Nat ]
 means
(( ( Partial_Union A1 ) . $1 ) = ( {} ) or ( ( Partial_Union A1 ) . $1 ) = Omega);
let n;
A4: (for k being Nat holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k being Nat;
assume A5: (( ( Partial_Union A1 ) . k ) = ( {} ) or ( ( Partial_Union A1 ) . k ) = Omega);
reconsider k as (Element of ( NAT )) by ORDINAL1:def 12;
A6: ( A1 . ( k + 1 ) ) in ( rng A1 ) by NAT_1:51;
per cases  by A5,PROB_3:def 2;
suppose ( ( Partial_Union A1 ) . ( k + 1 ) ) = ( ( {} ) \/ ( A1 . ( k + 1 ) ) );

hence thesis by A2,A6,TARSKI:def 2;
end;
suppose A7: ( ( Partial_Union A1 ) . ( k + 1 ) ) = ( Omega \/ ( A1 . ( k + 1 ) ) );

(( A1 . ( k + 1 ) ) = ( {} ) or ( A1 . ( k + 1 ) ) = Omega) by A2,A6,TARSKI:def 2;
hence thesis by A7;
end;
end;
(( ( Partial_Union A1 ) . ( 0 ) ) = ( A1 . ( 0 ) ) & ( A1 . ( 0 ) ) in ( rng A1 )) by NAT_1:51,PROB_3:def 2;
then A8: P[ ( 0 ) ] by A2,TARSKI:def 2;
(for k being Nat holds P[ k ]) from NAT_1:sch 2(A8,A4);
hence thesis;
end;
(( Union ( Partial_Union A1 ) ) = ( {} ) or ( Union ( Partial_Union A1 ) ) = Omega)
proof
per cases ;
suppose A9: (for n holds ( ( Partial_Union A1 ) . n ) = ( {} ));

(not x in ( Union ( Partial_Union A1 ) ))
proof
assume (not thesis);
then (ex n st x in ( ( Partial_Union A1 ) . n )) by PROB_1:12;
hence contradiction by A9;
end;
hence thesis by XBOOLE_0:def 1;
end;
suppose (not (for n holds ( ( Partial_Union A1 ) . n ) = ( {} )));

then consider n such that A10: ( ( Partial_Union A1 ) . n ) <> ( {} );
( ( Partial_Union A1 ) . n ) = Omega by A3,A10;
then (x in Omega implies x in ( Union ( Partial_Union A1 ) )) by PROB_1:12;
then Omega c= ( Union ( Partial_Union A1 ) ) by TARSKI:def 3;
hence thesis by XBOOLE_0:def 10;
end;
end;
then (( Union A1 ) = ( {} ) or ( Union A1 ) = Omega) by PROB_3:15;
hence thesis by TARSKI:def 2;
end;
A11: (for A being (Subset of Omega) holds (A in { ( {} ),Omega } implies ( A ` ) in { ( {} ),Omega }))
proof
let A being (Subset of Omega);
assume A in { ( {} ),Omega };
then (A = ( {} ) or A = Omega) by TARSKI:def 2;
then (( A ` ) = Omega or ( A ` ) = ( {} )) by XBOOLE_1:37;
hence thesis by TARSKI:def 2;
end;
(( {} ) in ( sigma X ) & Omega in ( sigma X )) by PROB_1:4,PROB_1:5;
then (x in { ( {} ),Omega } implies x in ( sigma X )) by TARSKI:def 2;
then A12: { ( {} ),Omega } c= ( sigma X ) by TARSKI:def 3;
assume X = ( {} );
then A13: X c= { ( {} ),Omega } by XBOOLE_1:2;
(x in { ( {} ),Omega } implies x in ( bool Omega ))
proof
assume x in { ( {} ),Omega };
then (x = ( {} ) or x = Omega) by TARSKI:def 2;
then x c= Omega by XBOOLE_1:2;
hence thesis;
end;
then { ( {} ),Omega } is (SigmaField of Omega) by A1,A11,PROB_4:4,TARSKI:def 3;
then ( sigma X ) c= { ( {} ),Omega } by A13,PROB_1:def 9;
hence thesis by A12,XBOOLE_0:def 10;
end;
