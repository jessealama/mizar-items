environ
vocabularies NUMBERS,SCMFSA7B,FUNCSDOM,SUBSET_1,AMI_3,AMI_1,FSM_1,ORDINAL1,INT_3,FINSET_1,STRUCT_0,AMI_2,TARSKI,ZFMISC_1,RELAT_1,FUNCOP_1,XBOOLE_0,CAT_1,FUNCT_1,CARD_1,GRAPHSP,FINSEQ_1,AMISTD_2,CARD_3,AMISTD_1,CIRCUIT2,FUNCT_4,SETFAM_1,SUPINF_2,ARYTM_3,XXREAL_0,GOBOARD5,ARYTM_1,GROUP_1,PBOOLE,FRECHET,UNIALG_1,CARD_5,PARTFUN1,RECDEF_2,SCMNORM,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,FINSET_1,ENUMSET1,ZFMISC_1,MCART_1,SETFAM_1,RELAT_1,FUNCT_1,XXREAL_0,RECDEF_2,VALUED_1,PBOOLE,STRUCT_0,ALGSTR_0,FUNCSDOM,ORDINAL1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,FUNCOP_1,FINSEQ_1,PARTFUN1,FUNCT_4,CARD_3,FUNCT_7,GROUP_1,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,AMI_3,SCMRING1,SCMRING2,INT_3,NAT_D,AMISTD_1,AMISTD_2,FUNCT_2,CKB4,CKB57;
definitions TARSKI,FUNCT_1,FUNCT_7,SCMRING1,SCMRING2,AMISTD_1,AMISTD_2,XBOOLE_0,FUNCOP_1,STRUCT_0,COMPOS_1,EXTPRO_1,AMI_2,CARD_3,NAT_1,MEMSTR_0,MCART_1,ZFMISC_1,CKB57;
theorems TARSKI,NAT_1,SCMRING2,AMI_3,FUNCT_4,FUNCT_1,ZFMISC_1,FUNCOP_1,SCMRING1,SETFAM_1,AMI_2,AMISTD_1,MCART_1,INT_1,INT_3,STRUCT_0,RLVECT_1,VECTSP_1,LMOD_6,FINSEQ_1,AMISTD_2,CARD_3,ORDINAL1,XBOOLE_0,XBOOLE_1,RELAT_1,ENUMSET1,NUMBERS,PARTFUN1,PBOOLE,RECDEF_2,VALUED_1,COMPOS_1,EXTPRO_1,FUNCT_7,MEMSTR_0,CKB3,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB47,CKB48,CKB50,CKB51,CKB52,CKB54,CKB55,CKB57;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,XREAL_0,INT_1,FINSEQ_1,CARD_3,STRUCT_0,VECTSP_1,INT_3,FINSET_1,AMI_3,SCMRING1,SCMRING2,AMISTD_2,NUMBERS,RELSET_1,ZFMISC_1,CARD_2,FUNCT_2,FUNCT_4,ALGSTR_0,ALGSTR_1,GCD_1,VALUED_1,VALUED_0,COMPOS_1,EXTPRO_1,XCMPLX_0,REAL_1,NAT_1,PBOOLE,FUNCT_7,PRE_POLY,MEMSTR_0,CARD_1,CKB1,CKB2,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB49,CKB53,CKB56,CKB58,CKB59,CKB60,CKB61,CKB62,CKB63,CKB64,CKB65,CKB66,CKB67,CKB68,CKB69,CKB70,CKB71,CKB72,CKB73,CKB74,CKB75,CKB76,CKB77;
constructors XXREAL_0,NAT_1,FINSEQ_4,VECTSP_2,REALSET2,INT_3,AMI_3,SCMRING2,AMISTD_2,BINOP_2,RELSET_1,RECDEF_2,VALUED_1,GCD_1,NAT_D,XCMPLX_0,REAL_1,AMISTD_1,PBOOLE,FUNCT_7,PRE_POLY,MEMSTR_0,CKB4,CKB57;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve R for  good Ring;
reserve r for (Element of R);
reserve a for (Data-Location of R);
reserve b for (Data-Location of R);
reserve d1 for (Data-Location of R);
reserve d2 for (Data-Location of R);
reserve i1 for (Element of ( NAT ));
reserve i2 for (Element of ( NAT ));
registration
let R;
cluster ( SCM R ) ->  homogeneous  with_explicit_jumps;
coherence
proof
thus ( SCM R ) is  homogeneous
proof
let I being (Instruction of ( SCM R )),J being (Instruction of ( SCM R ));
assume that
A1: ( InsCode I ) = ( InsCode J );
A2: (((((((J = [ ( 0 ),( {} ),( {} ) ] or (ex a st (ex b st J = ( a := b )))) or (ex a st (ex b st J = ( AddTo (a,b) )))) or (ex a st (ex b st J = ( SubFrom (a,b) )))) or (ex a st (ex b st J = ( MultBy (a,b) )))) or (ex i1 st J = ( goto (i1,R) ))) or (ex a st (ex i1 st J = ( a =0_goto i1 )))) or (ex a st (ex r st J = ( a := r )))) by SCMRING2:7;
per cases  by SCMRING2:7;
suppose A3: I = [ ( 0 ),( {} ),( {} ) ];

then I = ( halt ( SCM R ) ) by SCMRING2:21;
then ( InsCode I ) = ( 0 ) by CKB7:1;
hence thesis by A1,A2,A3,RECDEF_2:def 1;
end;
suppose (ex a st (ex b st I = ( a := b )));

then consider a,b such that A4: I = ( a := b );
A5: ( InsCode I ) = 1 by A4,RECDEF_2:def 1;
now
per cases  by SCMRING2:7;
suppose J = [ ( 0 ),( {} ),( {} ) ];

then J = ( halt ( SCM R ) ) by SCMRING2:21;
hence thesis by A1,A5,CKB7:1;
end;
suppose (ex a st (ex b st J = ( a := b )));

then consider d1,d2 such that A6: J = ( d1 := d2 );
thus ( dom ( JumpPart I ) ) = ( dom ( {} ) ) by A4,RECDEF_2:def 2
.= ( dom ( JumpPart J ) ) by A6,RECDEF_2:def 2;
end;
suppose ((((((ex a st (ex b st J = ( AddTo (a,b) ))) or (ex a st (ex b st J = ( SubFrom (a,b) )))) or (ex a st (ex b st J = ( MultBy (a,b) )))) or (ex i1 st J = ( goto (i1,R) ))) or (ex a st (ex i1 st J = ( a =0_goto i1 )))) or (ex a st (ex r st J = ( a := r ))));

hence thesis by A1,A5,RECDEF_2:def 1;
end;
end;
hence thesis;
end;
suppose (ex a st (ex b st I = ( AddTo (a,b) )));

then consider a,b such that A7: I = ( AddTo (a,b) );
A8: ( InsCode I ) = 2 by A7,RECDEF_2:def 1;
now
per cases  by SCMRING2:7;
suppose J = [ ( 0 ),( {} ),( {} ) ];

then J = ( halt ( SCM R ) ) by SCMRING2:21;
hence thesis by A1,A8,CKB7:1;
end;
suppose (ex a st (ex b st J = ( AddTo (a,b) )));

then consider d1,d2 such that A9: J = ( AddTo (d1,d2) );
thus ( dom ( JumpPart I ) ) = ( dom ( {} ) ) by A7,RECDEF_2:def 2
.= ( dom ( JumpPart J ) ) by A9,RECDEF_2:def 2;
end;
suppose ((((((ex a st (ex b st J = ( a := b ))) or (ex a st (ex b st J = ( SubFrom (a,b) )))) or (ex a st (ex b st J = ( MultBy (a,b) )))) or (ex i1 st J = ( goto (i1,R) ))) or (ex a st (ex i1 st J = ( a =0_goto i1 )))) or (ex a st (ex r st J = ( a := r ))));

hence thesis by A1,A8,RECDEF_2:def 1;
end;
end;
hence thesis;
end;
suppose (ex a st (ex b st I = ( SubFrom (a,b) )));

then consider a,b such that A10: I = ( SubFrom (a,b) );
A11: ( InsCode I ) = 3 by A10,RECDEF_2:def 1;
now
per cases  by SCMRING2:7;
suppose J = [ ( 0 ),( {} ),( {} ) ];

then J = ( halt ( SCM R ) ) by SCMRING2:21;
hence thesis by A1,A11,CKB7:1;
end;
suppose (ex a st (ex b st J = ( SubFrom (a,b) )));

then consider d1,d2 such that A12: J = ( SubFrom (d1,d2) );
thus ( dom ( JumpPart I ) ) = ( dom ( {} ) ) by A10,RECDEF_2:def 2
.= ( dom ( JumpPart J ) ) by A12,RECDEF_2:def 2;
end;
suppose ((((((ex a st (ex b st J = ( a := b ))) or (ex a st (ex b st J = ( AddTo (a,b) )))) or (ex a st (ex b st J = ( MultBy (a,b) )))) or (ex i1 st J = ( goto (i1,R) ))) or (ex a st (ex i1 st J = ( a =0_goto i1 )))) or (ex a st (ex r st J = ( a := r ))));

hence thesis by A1,A11,RECDEF_2:def 1;
end;
end;
hence thesis;
end;
suppose (ex a st (ex b st I = ( MultBy (a,b) )));

then consider a,b such that A13: I = ( MultBy (a,b) );
A14: ( InsCode I ) = 4 by A13,RECDEF_2:def 1;
now
per cases  by SCMRING2:7;
suppose J = [ ( 0 ),( {} ),( {} ) ];

then J = ( halt ( SCM R ) ) by SCMRING2:21;
hence thesis by A1,A14,CKB7:1;
end;
suppose (ex a st (ex b st J = ( MultBy (a,b) )));

then consider d1,d2 such that A15: J = ( MultBy (d1,d2) );
thus ( dom ( JumpPart I ) ) = ( dom ( {} ) ) by A13,RECDEF_2:def 2
.= ( dom ( JumpPart J ) ) by A15,RECDEF_2:def 2;
end;
suppose ((((((ex a st (ex b st J = ( a := b ))) or (ex a st (ex b st J = ( AddTo (a,b) )))) or (ex a st (ex b st J = ( SubFrom (a,b) )))) or (ex i1 st J = ( goto (i1,R) ))) or (ex a st (ex i1 st J = ( a =0_goto i1 )))) or (ex a st (ex r st J = ( a := r ))));

hence thesis by A1,A14,RECDEF_2:def 1;
end;
end;
hence thesis;
end;
suppose (ex i1 st I = ( goto (i1,R) ));

then consider i1 such that A16: I = ( goto (i1,R) );
A17: ( InsCode I ) = 6 by A16,RECDEF_2:def 1;
now
per cases  by SCMRING2:7;
suppose J = [ ( 0 ),( {} ),( {} ) ];

then J = ( halt ( SCM R ) ) by SCMRING2:21;
hence thesis by A1,A17,CKB7:1;
end;
suppose (ex i2 st J = ( goto (i2,R) ));

then consider i2 such that A18: J = ( goto (i2,R) );
thus ( dom ( JumpPart I ) ) = ( dom <* i1 *> ) by A16,RECDEF_2:def 2
.= ( Seg 1 ) by FINSEQ_1:def 8
.= ( dom <* i2 *> ) by FINSEQ_1:def 8
.= ( dom ( JumpPart J ) ) by A18,RECDEF_2:def 2;
end;
suppose ((((((ex a st (ex b st J = ( a := b ))) or (ex a st (ex b st J = ( AddTo (a,b) )))) or (ex a st (ex b st J = ( SubFrom (a,b) )))) or (ex a st (ex b st J = ( MultBy (a,b) )))) or (ex a st (ex i1 st J = ( a =0_goto i1 )))) or (ex a st (ex r st J = ( a := r ))));

hence thesis by A1,A17,RECDEF_2:def 1;
end;
end;
hence thesis;
end;
suppose (ex a st (ex i1 st I = ( a =0_goto i1 )));

then consider a,i1 such that A19: I = ( a =0_goto i1 );
A20: ( InsCode I ) = 7 by A19,RECDEF_2:def 1;
now
per cases  by SCMRING2:7;
suppose J = [ ( 0 ),( {} ),( {} ) ];

then J = ( halt ( SCM R ) ) by SCMRING2:21;
hence thesis by A1,A20,CKB7:1;
end;
suppose (ex d1 st (ex i2 st J = ( d1 =0_goto i2 )));

then consider d1,i2 such that A21: J = ( d1 =0_goto i2 );
thus ( dom ( JumpPart I ) ) = ( dom <* i1 *> ) by A19,RECDEF_2:def 2
.= ( Seg 1 ) by FINSEQ_1:38
.= ( dom <* i2 *> ) by FINSEQ_1:38
.= ( dom ( JumpPart J ) ) by A21,RECDEF_2:def 2;
end;
suppose ((((((ex a st (ex b st J = ( a := b ))) or (ex a st (ex b st J = ( AddTo (a,b) )))) or (ex a st (ex b st J = ( SubFrom (a,b) )))) or (ex a st (ex b st J = ( MultBy (a,b) )))) or (ex i1 st J = ( goto (i1,R) ))) or (ex a st (ex r st J = ( a := r ))));

hence thesis by A1,A20,RECDEF_2:def 1;
end;
end;
hence thesis;
end;
suppose (ex a st (ex r st I = ( a := r )));

then consider a,r such that A22: I = ( a := r );
A23: ( InsCode I ) = 5 by A22,RECDEF_2:def 1;
now
per cases  by SCMRING2:7;
suppose J = [ ( 0 ),( {} ),( {} ) ];

then J = ( halt ( SCM R ) ) by SCMRING2:21;
hence thesis by A1,A23,CKB7:1;
end;
suppose (ex a st (ex r st J = ( a := r )));

then consider b being (Data-Location of R),r1 being (Element of R) such that A24: J = ( b := r1 );
thus ( dom ( JumpPart I ) ) = ( dom ( {} ) ) by A22,RECDEF_2:def 2
.= ( dom ( JumpPart J ) ) by A24,RECDEF_2:def 2;
end;
suppose ((((((ex a st (ex b st J = ( a := b ))) or (ex a st (ex b st J = ( AddTo (a,b) )))) or (ex a st (ex b st J = ( SubFrom (a,b) )))) or (ex a st (ex b st J = ( MultBy (a,b) )))) or (ex i1 st J = ( goto (i1,R) ))) or (ex a st (ex i1 st J = ( a =0_goto i1 ))));

hence thesis by A1,A23,RECDEF_2:def 1;
end;
end;
hence thesis;
end;
end;

thus ( SCM R ) is  with_explicit_jumps
proof
let I being (Instruction of ( SCM R ));
thus ( JUMP I ) c= ( rng ( JumpPart I ) )
proof
let f being set;
assume that
A25: f in ( JUMP I );
per cases  by SCMRING2:7;
suppose A26: I = [ ( 0 ),( {} ),( {} ) ];

( JUMP ( halt ( SCM R ) ) ) is  empty;
hence thesis by A25,A26,SCMRING2:21;
end;
suppose (ex a st (ex b st I = ( a := b )));

hence thesis by A25;
end;
suppose (ex a st (ex b st I = ( AddTo (a,b) )));

hence thesis by A25;
end;
suppose (ex a st (ex b st I = ( SubFrom (a,b) )));

hence thesis by A25;
end;
suppose (ex a st (ex b st I = ( MultBy (a,b) )));

hence thesis by A25;
end;
suppose A27: (ex i1 st I = ( goto (i1,R) ));

consider i1 such that A28: I = ( goto (i1,R) ) by A27;
A29: ( JumpPart ( goto (i1,R) ) ) = <* i1 *> by RECDEF_2:def 2;
( rng <* i1 *> ) = { i1 } by FINSEQ_1:39;
hence f in ( rng ( JumpPart I ) ) by A25,A28,A29,CKB48:1;
end;
suppose A31: (ex a st (ex i1 st I = ( a =0_goto i1 )));

consider a,i1 such that A32: I = ( a =0_goto i1 ) by A31;
A33: ( JumpPart ( a =0_goto i1 ) ) = <* i1 *> by RECDEF_2:def 2;
( rng <* i1 *> ) = { i1 } by FINSEQ_1:39;
hence thesis by A25,A32,A33,CKB52:1;
end;
suppose (ex a st (ex r st I = ( a := r )));

hence thesis by A25;
end;
end;

let f being set;
assume f in ( rng ( JumpPart I ) );
then consider k being set such that A35: k in ( dom ( JumpPart I ) ) and A36: f = ( ( JumpPart I ) . k ) by FUNCT_1:def 3;
per cases  by SCMRING2:7;
suppose I = [ ( 0 ),( {} ),( {} ) ];

then I = ( halt ( SCM R ) ) by SCMRING2:21;
hence thesis by A35;
end;
suppose (ex a st (ex b st I = ( a := b )));

then consider a,b such that A37: I = ( a := b );
k in ( dom ( {} ) ) by A35,A37,RECDEF_2:def 2;
hence thesis;
end;
suppose (ex a st (ex b st I = ( AddTo (a,b) )));

then consider a,b such that A38: I = ( AddTo (a,b) );
k in ( dom ( {} ) ) by A35,A38,RECDEF_2:def 2;
hence thesis;
end;
suppose (ex a st (ex b st I = ( SubFrom (a,b) )));

then consider a,b such that A39: I = ( SubFrom (a,b) );
k in ( dom ( {} ) ) by A35,A39,RECDEF_2:def 2;
hence thesis;
end;
suppose (ex a st (ex b st I = ( MultBy (a,b) )));

then consider a,b such that A40: I = ( MultBy (a,b) );
k in ( dom ( {} ) ) by A35,A40,RECDEF_2:def 2;
hence thesis;
end;
suppose (ex i1 st I = ( goto (i1,R) ));

then consider i1 such that A41: I = ( goto (i1,R) );
A42: ( JumpPart I ) = <* i1 *> by A41,RECDEF_2:def 2;
then k = 1 by A35,CKB23:1;
then A43: f = i1 by A42,A36,FINSEQ_1:def 8;
( JUMP I ) = { i1 } by A41,CKB48:1;
hence thesis by A43,TARSKI:def 1;
end;
suppose (ex a st (ex i1 st I = ( a =0_goto i1 )));

then consider a,i1 such that A44: I = ( a =0_goto i1 );
A45: ( JumpPart I ) = <* i1 *> by A44,RECDEF_2:def 2;
then k = 1 by A35,CKB23:1;
then A46: f = i1 by A45,A36,FINSEQ_1:40;
( JUMP I ) = { i1 } by A44,CKB52:1;
hence thesis by A46,TARSKI:def 1;
end;
suppose (ex a st (ex r st I = ( a := r )));

then consider a,r such that A47: I = ( a := r );
k in ( dom ( {} ) ) by A35,A47,RECDEF_2:def 2;
hence thesis;
end;
end;

end;
end;
