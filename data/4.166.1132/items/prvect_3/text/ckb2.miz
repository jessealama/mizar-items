environ
vocabularies NUMBERS,SUBSET_1,CARD_3,FUNCT_1,RELAT_1,FUNCT_2,FINSEQ_1,PRE_TOPC,XBOOLE_0,NORMSP_0,STRUCT_0,RLVECT_1,NORMSP_1,COMPLEX1,ARYTM_3,REAL_1,PRVECT_3,RFINSEQ,ARYTM_1,SQUARE_1,RVSUM_1,XXREAL_0,CARD_1,SUPINF_2,SEQ_2,ORDINAL2,XREAL_0,ORDINAL1,TARSKI,NAT_1,PRVECT_1,PRVECT_2,ZFMISC_1,ORDINAL4,GROUP_2,ALGSTR_0,BINOP_1,EUCLID,REWRITE1,RSSPACE3,RELAT_2,METRIC_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,RELSET_1,PARTFUN1,FUNCT_2,BINOP_1,DOMAIN_1,FUNCOP_1,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,REAL_1,SQUARE_1,NAT_1,VALUED_0,COMPLEX1,CARD_3,FINSEQ_1,FINSEQ_2,FINSEQ_4,RVSUM_1,RFINSEQ,STRUCT_0,ALGSTR_0,PRE_TOPC,RLVECT_1,NORMSP_0,NORMSP_1,EUCLID,RSSPACE3,LOPBAN_1,PRVECT_1,PRVECT_2;
definitions EUCLID,PRVECT_2,BINOP_1,RLVECT_1,VALUED_1,ALGSTR_0,NORMSP_0,STRUCT_0;
theorems TARSKI,XBOOLE_0,XREAL_0,RLVECT_1,FINSEQ_1,FINSEQ_2,RVSUM_1,NORMSP_0,RFINSEQ,NAT_1,TOPREAL6,SQUARE_1,RELSET_1,RELAT_1,FUNCT_1,FUNCT_2,NORMSP_1,LOPBAN_1,BINOP_1,CARD_3,ALGSTR_0,EUCLID,RSSPACE3,XXREAL_0,PRVECT_1,PRVECT_2,ZFMISC_1,FINSEQ_3,SUBSET_1,TOPREAL7,CKB1;
schemes FUNCT_2,BINOP_1;
registrations RELSET_1,STRUCT_0,ORDINAL1,XREAL_0,MEMBERED,FUNCT_1,FUNCT_2,NUMBERS,XBOOLE_0,VALUED_0,EUCLID,PRVECT_2,ALGSTR_0,FINSEQ_2,FINSEQ_1,CARD_3,NORMSP_0,LOPBAN_1,RLVECT_1,NORMSP_1,RELAT_1,SUBSET_1;
constructors REAL_1,SQUARE_1,RSSPACE3,COMPLEX1,LOPBAN_1,SEQ_1,RVSUM_1,BINOP_2,PRVECT_2,FINSEQ_4,RFINSEQ,FINSEQOP,TOPMETR;
requirements SUBSET,REAL,BOOLE,NUMERALS,ARITHM;
begin
theorem
Th2: (for X being non empty set holds (for D being Function holds ((( dom D ) = { 1 } & ( D . 1 ) = X) implies (ex I being (Function of X,( product D )) st ((I is  one-to-one & I is  onto) & (for x being set holds (x in X implies ( I . x ) = <* x *>)))))))
proof
let X being non empty set;
let D being Function;
assume A1: (( dom D ) = { 1 } & ( D . 1 ) = X);
defpred P[ set,set ]
 means
$2 = <* $1 *>;
A2: (for x being set holds (x in X implies (ex z being set st (z in ( product D ) & P[ x,z ]))))
proof
let x being set;
assume A3: x in X;
A4: ( dom <* x *> ) = ( Seg ( len <* x *> ) ) by FINSEQ_1:def 3
.= { 1 } by FINSEQ_1:2,FINSEQ_1:40;
now
let i being set;
assume i in ( dom <* x *> );
then i = 1 by A4,TARSKI:def 1;
hence ( <* x *> . i ) in ( D . i ) by A1,A3,FINSEQ_1:40;
end;
then <* x *> in ( product D ) by A4,A1,CARD_3:9;
hence (ex z being set st (z in ( product D ) & P[ x,z ]));
end;
consider I being (Function of X,( product D )) such that A5: (for x being set holds (x in X implies P[ x,( I . x ) ])) from FUNCT_2:sch 1(A2);
now
assume ( {} ) in ( rng D );
then (ex x being set st (x in ( dom D ) & ( D . x ) = ( {} ))) by FUNCT_1:def 3;
hence contradiction by A1,TARSKI:def 1;
end;
then A6: ( product D ) <> ( {} ) by CARD_3:26;
now
let z1 being set,z2 being set;
assume A7: ((z1 in X & z2 in X) & ( I . z1 ) = ( I . z2 ));
<* z1 *> = ( I . z1 ) by A5,A7
.= <* z2 *> by A5,A7;
hence z1 = z2 by FINSEQ_1:76;
end;
then A8: I is  one-to-one by A6,FUNCT_2:19;
now
let w being set;
assume w in ( product D );
then consider g being Function such that A9: ((w = g & ( dom g ) = ( dom D )) & (for i being set holds (i in ( dom D ) implies ( g . i ) in ( D . i )))) by CARD_3:def 5;
reconsider g as FinSequence by A1,A9,FINSEQ_1:2,FINSEQ_1:def 2;
set x = ( g . 1 );
A10: ( len g ) = 1 by A1,A9,FINSEQ_1:2,FINSEQ_1:def 3;
1 in ( dom D ) by A1,TARSKI:def 1;
then A11: (x in X & w = <* x *>) by A9,A10,A1,FINSEQ_1:40;
then w = ( I . x ) by A5;
hence w in ( rng I ) by A11,A6,FUNCT_2:112;
end;
then ( product D ) c= ( rng I ) by TARSKI:def 3;
then ( product D ) = ( rng I ) by XBOOLE_0:def 10;
then I is  onto by FUNCT_2:def 3;
hence thesis by A5,A8;
end;
