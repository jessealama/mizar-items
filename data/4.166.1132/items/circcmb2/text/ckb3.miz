environ
vocabularies NAT_1,FUNCT_1,FINSEQ_2,MARGREL1,CIRCCOMB,LATTICES,FINSET_1,XBOOLE_0,MSUALG_1,FSM_1,CIRCUIT1,RELAT_1,CIRCUIT2,STRUCT_0,MSAFREE2,GLIB_000,ARYTM_3,CARD_1,XXREAL_0,PBOOLE,NUMBERS,MCART_1,FUNCT_4,PARTFUN1,FACIRC_1,TARSKI;
notations TARSKI,XBOOLE_0,NUMBERS,XCMPLX_0,XXREAL_0,NAT_1,MCART_1,FINSET_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FINSEQ_2,FUNCT_4,PBOOLE,MARGREL1,STRUCT_0,MSUALG_1,MSAFREE2,CIRCUIT1,CIRCUIT2,CIRCCOMB,FACIRC_1;
definitions CIRCUIT2,MSAFREE2;
theorems TARSKI,FUNCT_1,RELAT_1,ZFMISC_1,NAT_1,MCART_1,PBOOLE,CIRCCOMB,FACIRC_1,FUNCT_4,FRECHET,CIRCUIT1,CIRCUIT2,XBOOLE_0,XBOOLE_1,XXREAL_0,ORDINAL1,CKB2;
schemes NAT_1,PBOOLE;
registrations RELAT_1,FUNCT_1,ORDINAL1,XREAL_0,CARD_3,STRUCT_0,CIRCCOMB,FACIRC_1,NAT_1,MARGREL1,CKB1;
constructors LIMFUNC1,CIRCUIT1,CIRCUIT2,FACIRC_1,NAT_1,RELSET_1,MARGREL1,DOMAIN_1,ENUMSET1,BINOP_1;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
theorem
(for X being  finite non  empty set holds (for n being Nat holds (for p being (FinSeqLen of n) holds (for f being (Function of ( n -tuples_on X ),X) holds (for s being (State of ( 1GateCircuit (p,f) )) holds ( Following s ) is  stable)))))
proof
let X being  finite non  empty set;
let n being Nat;
let p being (FinSeqLen of n);
let f being (Function of ( n -tuples_on X ),X);
set S = ( 1GateCircStr (p,f) );
let s being (State of ( 1GateCircuit (p,f) ));
set s1 = ( Following s );
set s2 = ( Following s1 );
A1: ( dom s1 ) = (the carrier of S) by CIRCUIT1:3;
A2: (the carrier of S) = ( ( rng p ) \/ { [ p,f ] } ) by CIRCCOMB:def 6;
A3: ( InputVertices S ) = ( rng p ) by CIRCCOMB:42;
A4: ( InnerVertices S ) = { [ p,f ] } by CIRCCOMB:42;
A5:now
let a being set;
assume a in (the carrier of S);
then reconsider v = a as (Vertex of S);
( dom s ) = (the carrier of S) by CIRCUIT1:3;
then A6: ( dom ( s * p ) ) = ( dom p ) by A2,RELAT_1:27,XBOOLE_1:7;
A7: ( dom ( s1 * p ) ) = ( dom p ) by A1,A2,RELAT_1:27,XBOOLE_1:7;
A8:now
let i being set;
assume A9: i in ( dom p );
then A10: ( p . i ) in ( rng p ) by FUNCT_1:3;
(( ( s1 * p ) . i ) = ( s1 . ( p . i ) ) & ( ( s * p ) . i ) = ( s . ( p . i ) )) by A7,A6,A9,FUNCT_1:12;
hence ( ( s1 * p ) . i ) = ( ( s * p ) . i ) by A3,A10,CIRCUIT2:def 5;
end;
(v in ( rng p ) or v in { [ p,f ] }) by A2,XBOOLE_0:def 3;
then (( s2 . v ) = ( s1 . v ) or ((((v = [ p,f ] & (v = [ p,f ] implies ( action_at v ) = v)) & ( s2 . v ) = ( ( Den (( action_at v ),( 1GateCircuit (p,f) )) ) . ( ( action_at v ) depends_on_in s1 ) )) & ( s1 . v ) = ( ( Den (( action_at v ),( 1GateCircuit (p,f) )) ) . ( ( action_at v ) depends_on_in s ) )) & (( action_at v ) = [ p,f ] implies (( ( action_at v ) depends_on_in s ) = ( s * p ) & ( ( action_at v ) depends_on_in s1 ) = ( s1 * p ))))) by A3,A4,CKB2:1,CIRCCOMB:41,CIRCUIT2:def 5,TARSKI:def 1;
hence ( s2 . a ) = ( s1 . a ) by A7,A6,A8,FUNCT_1:2;
end;
( dom s2 ) = (the carrier of S) by CIRCUIT1:3;
hence ( Following s ) = ( Following ( Following s ) ) by A1,A5,FUNCT_1:2;
end;
