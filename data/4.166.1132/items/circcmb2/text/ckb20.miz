environ
vocabularies NAT_1,FUNCT_1,FINSEQ_2,MARGREL1,CIRCCOMB,LATTICES,FINSET_1,XBOOLE_0,MSUALG_1,FSM_1,CIRCUIT1,RELAT_1,CIRCUIT2,STRUCT_0,MSAFREE2,GLIB_000,ARYTM_3,CARD_1,XXREAL_0,PBOOLE,NUMBERS,MCART_1,FUNCT_4,PARTFUN1,FACIRC_1,TARSKI;
notations TARSKI,XBOOLE_0,NUMBERS,XCMPLX_0,XXREAL_0,NAT_1,MCART_1,FINSET_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FINSEQ_2,FUNCT_4,PBOOLE,MARGREL1,STRUCT_0,MSUALG_1,MSAFREE2,CIRCUIT1,CIRCUIT2,CIRCCOMB,FACIRC_1;
definitions CIRCUIT2,MSAFREE2;
theorems TARSKI,FUNCT_1,RELAT_1,ZFMISC_1,NAT_1,MCART_1,PBOOLE,CIRCCOMB,FACIRC_1,FUNCT_4,FRECHET,CIRCUIT1,CIRCUIT2,XBOOLE_0,XBOOLE_1,XXREAL_0,ORDINAL1,CKB2,CKB3,CKB4,CKB5,CKB15,CKB16,CKB17,CKB18;
schemes NAT_1,PBOOLE,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB19;
registrations RELAT_1,FUNCT_1,ORDINAL1,XREAL_0,CARD_3,STRUCT_0,CIRCCOMB,FACIRC_1,NAT_1,MARGREL1,CKB1;
constructors LIMFUNC1,CIRCUIT1,CIRCUIT2,FACIRC_1,NAT_1,RELSET_1,MARGREL1,DOMAIN_1,ENUMSET1,BINOP_1;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
scheme CIRCCMB29sch11 { Sn(set) ->  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign,h() -> (ManySortedSet of ( NAT )),S(set,set) ->  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign,o(set,set) -> set } : (for n being Nat holds ((( InputVertices Sn(( n + 1 )) ) = ( ( InputVertices Sn(n) ) \/ ( ( InputVertices S(( h() . n ),n) ) \ { ( h() . n ) } ) ) & ( InnerVertices Sn(n) ) is Relation) & ( InputVertices Sn(n) ) is  without_pairs))
provided
A1: ( InnerVertices Sn(( 0 )) ) is Relation
and
A2: ( InputVertices Sn(( 0 )) ) is  without_pairs
and
A3: ( h() . ( 0 ) ) in ( InnerVertices Sn(( 0 )) )
and
A4: (for n being Nat holds (for x being set holds ( InnerVertices S(x,n) ) is Relation))
and
A5: (for n being Nat holds (for x being set holds (x = ( h() . n ) implies ( ( InputVertices S(x,n) ) \ { x } ) is  without_pairs)))
and
A6: (for n being Nat holds (for S being non  empty ManySortedSign holds (for x being set holds ((S = Sn(n) & x = ( h() . n )) implies (((Sn(( n + 1 )) = ( S +* S(x,n) ) & ( h() . ( n + 1 ) ) = o(x,n)) & x in ( InputVertices S(x,n) )) & o(x,n) in ( InnerVertices S(x,n) ))))))
proof
deffunc SN(set) = Sn($1);
A7: (for n being Nat holds (for S being non  empty ManySortedSign holds (for x being set holds ((S = SN(n) & x = ( h() . n )) implies (((SN(( n + 1 )) = ( S +* S(x,n) ) & ( h() . ( n + 1 ) ) = o(x,n)) & x in ( InputVertices S(x,n) )) & o(x,n) in ( InnerVertices S(x,n) )))))) by A6;
let n being Nat;
A8: (for n being Nat holds (for x being set holds (x = ( h() . n ) implies ( ( InputVertices S(x,n) ) \ { x } ) is  without_pairs))) by A5;
A9: (SN(( 0 )) = SN(( 0 )) & ( h() . ( 0 ) ) in ( InnerVertices SN(( 0 )) )) by A3;
A10: (for n being Nat holds (for x being set holds ( InnerVertices S(x,n) ) is Relation)) by A4;
(for n being Nat holds (ex S1,S2 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign st ((((S1 = SN(n) & S2 = SN(( n + 1 ))) & ( InputVertices S2 ) = ( ( InputVertices S1 ) \/ ( ( InputVertices S(( h() . n ),n) ) \ { ( h() . n ) } ) )) & ( InnerVertices S1 ) is Relation) & ( InputVertices S1 ) is  without_pairs))) from CKB19:sch 1(A1,A2,A9,A10,A8,A7);
then (ex S1,S2 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign st ((((S1 = Sn(n) & S2 = Sn(( n + 1 ))) & ( InputVertices S2 ) = ( ( InputVertices S1 ) \/ ( ( InputVertices S(( h() . n ),n) ) \ { ( h() . n ) } ) )) & ( InnerVertices S1 ) is Relation) & ( InputVertices S1 ) is  without_pairs));
hence thesis;
end;
