environ
vocabularies NAT_1,FUNCT_1,FINSEQ_2,MARGREL1,CIRCCOMB,LATTICES,FINSET_1,XBOOLE_0,MSUALG_1,FSM_1,CIRCUIT1,RELAT_1,CIRCUIT2,STRUCT_0,MSAFREE2,GLIB_000,ARYTM_3,CARD_1,XXREAL_0,PBOOLE,NUMBERS,MCART_1,FUNCT_4,PARTFUN1,FACIRC_1,TARSKI;
notations TARSKI,XBOOLE_0,NUMBERS,XCMPLX_0,XXREAL_0,NAT_1,MCART_1,FINSET_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FINSEQ_2,FUNCT_4,PBOOLE,MARGREL1,STRUCT_0,MSUALG_1,MSAFREE2,CIRCUIT1,CIRCUIT2,CIRCCOMB,FACIRC_1,CKB29;
definitions CIRCUIT2,MSAFREE2,CKB29;
theorems TARSKI,FUNCT_1,RELAT_1,ZFMISC_1,NAT_1,MCART_1,PBOOLE,CIRCCOMB,FACIRC_1,FUNCT_4,FRECHET,CIRCUIT1,CIRCUIT2,XBOOLE_0,XBOOLE_1,XXREAL_0,ORDINAL1,CKB2,CKB3,CKB4,CKB5,CKB15,CKB16,CKB17,CKB18,CKB29,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47;
schemes NAT_1,PBOOLE,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB30,CKB31;
registrations RELAT_1,FUNCT_1,ORDINAL1,XREAL_0,CARD_3,STRUCT_0,CIRCCOMB,FACIRC_1,NAT_1,MARGREL1,CKB1;
constructors LIMFUNC1,CIRCUIT1,CIRCUIT2,FACIRC_1,NAT_1,RELSET_1,MARGREL1,DOMAIN_1,ENUMSET1,BINOP_1,CKB29;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
scheme CIRCCMB29sch22 { S0,Sn() ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign,A0() ->  Boolean  gate`2=den  strict (Circuit of S0()),An() ->  Boolean  gate`2=den  strict (Circuit of Sn()),S(set,set) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign,A(set,set) -> set,h() -> (ManySortedSet of ( NAT )),o0() -> set,o(set,set) -> set,n(Nat) -> Nat } : (for s being (State of An()) holds ( Following (s,( n(( 0 )) + ( n(2) * n(1) ) )) ) is  stable)
provided
A1: (for x being set holds (for n being Nat holds A(x,n) is  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict (Circuit of S(x,n))))
and
A2: (for s being (State of A0()) holds ( Following (s,n(( 0 ))) ) is  stable)
and
A3: (for n being Nat holds (for x being set holds (for A being  non-empty (Circuit of S(x,n)) holds ((x = ( h() . n ) & A = A(x,n)) implies (for s being (State of A) holds ( Following (s,n(1)) ) is  stable)))))
and
A4: (ex f,g being (ManySortedSet of ( NAT )) st (((((Sn() = ( f . n(2) ) & An() = ( g . n(2) )) & ( f . ( 0 ) ) = S0()) & ( g . ( 0 ) ) = A0()) & ( h() . ( 0 ) ) = o0()) & (for n being Nat holds (for S being non  empty ManySortedSign holds (for A1 being  non-empty MSAlgebra over S holds (for x being set holds (for A2 being  non-empty MSAlgebra over S(x,n) holds ((((S = ( f . n ) & A1 = ( g . n )) & x = ( h() . n )) & A2 = A(x,n)) implies ((( f . ( n + 1 ) ) = ( S +* S(x,n) ) & ( g . ( n + 1 ) ) = ( A1 +* A2 )) & ( h() . ( n + 1 ) ) = o(x,n))))))))))
and
A5: (( InnerVertices S0() ) is Relation & ( InputVertices S0() ) is  without_pairs)
and
A6: (( h() . ( 0 ) ) = o0() & o0() in ( InnerVertices S0() ))
and
A7: (for n being Nat holds (for x being set holds ( InnerVertices S(x,n) ) is Relation))
and
A8: (for n being Nat holds (for x being set holds (x = ( h() . n ) implies ( ( InputVertices S(x,n) ) \ { x } ) is  without_pairs)))
and
A9: (for n being Nat holds (for x being set holds (x = ( h() . n ) implies ((( h() . ( n + 1 ) ) = o(x,n) & x in ( InputVertices S(x,n) )) & o(x,n) in ( InnerVertices S(x,n) )))))
proof
deffunc Al(non  empty ManySortedSign, non-empty MSAlgebra over $1,set,set) = ( $2 +* ( MSAlg (A($3,$4),S($3,$4)) ) );
deffunc Sl(non  empty ManySortedSign,set,set) = ( $1 +* S($2,$3) );
defpred Q[ set,set,set,Nat ]
 means
(ex S being  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign st (ex A being  Boolean  gate`2=den  strict (Circuit of S) st ((($1 = S & $2 = A) & $3 = ( h() . $4 )) & (for s being (State of A) holds ( Following (s,( n(( 0 )) + ( $4 * n(1) ) )) ) is  stable))));
deffunc h(set) = ( h() . $1 );
consider f,g being (ManySortedSet of ( NAT )) such that A10: (Sn() = ( f . n(2) ) & An() = ( g . n(2) )) and A11: ( f . ( 0 ) ) = S0() and A12: ( g . ( 0 ) ) = A0() and ( h() . ( 0 ) ) = o0() and A13: (for n being Nat holds (for S being non  empty ManySortedSign holds (for A1 being  non-empty MSAlgebra over S holds (for x being set holds (for A2 being  non-empty MSAlgebra over S(x,n) holds ((((S = ( f . n ) & A1 = ( g . n )) & x = ( h() . n )) & A2 = A(x,n)) implies ((( f . ( n + 1 ) ) = ( S +* S(x,n) ) & ( g . ( n + 1 ) ) = ( A1 +* A2 )) & ( h() . ( n + 1 ) ) = o(x,n)))))))) by A4;
deffunc f(set) = ( f . $1 );
A14: (for n being Nat holds (for S being non  empty ManySortedSign holds (for A being  non-empty MSAlgebra over S holds (for x being set holds (((S = ( f . n ) & A = ( g . n )) & x = ( h() . n )) implies ((( f . ( n + 1 ) ) = Sl(S,x,n) & ( g . ( n + 1 ) ) = Al(S,A,x,n)) & ( h() . ( n + 1 ) ) = o(x,n)))))))
proof
let n being Nat;
let S being non  empty ManySortedSign;
let A being  non-empty MSAlgebra over S;
let x being set;
reconsider A2 = A(x,n) as  Boolean  gate`2=den  strict (Circuit of S(x,n)) by A1;
A2 = ( MSAlg (A(x,n),S(x,n)) ) by CKB29:def 1;
hence thesis by A13;
end;
A15: (for n being Nat holds (for S being non  empty ManySortedSign holds (for A being  non-empty MSAlgebra over S holds (for x being set holds ((((S = ( f . n ) & A = ( g . n )) & x = ( h() . n )) & Q[ S,A,x,n ]) implies Q[ Sl(S,x,n),Al(S,A,x,n),o(x,n),( n + 1 ) ])))))
proof
let n being Nat;
let S being non  empty ManySortedSign;
let A being  non-empty MSAlgebra over S;
let x being set;
assume that
A16: S = ( f . n )
and
A = ( g . n )
and
x = ( h() . n );
given S9 being  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign,A9 being  Boolean  gate`2=den  strict (Circuit of S9) such that
A17: S = S9
and
A18: A = A9
and
A19: x = ( h() . n )
and
A20: (for s being (State of A9) holds ( Following (s,( n(( 0 )) + ( n * n(1) ) )) ) is  stable);

thus Q[ ( S +* S(x,n) ),( A +* ( MSAlg (A(x,n),S(x,n)) ) ),o(x,n),( n + 1 ) ]
proof
reconsider A2 = A(x,n) as  Boolean  gate`2=den  strict (Circuit of S(x,n)) by A1;
take ( S9 +* S(x,n) );
A21: (for S being non  empty ManySortedSign holds (for A being  non-empty MSAlgebra over S holds (for x being set holds (for n being Nat holds Al(S,A,x,n) is  non-empty  non-empty MSAlgebra over Sl(S,x,n)))));
A22: (( f . ( 0 ) ) = S0() & ( g . ( 0 ) ) = A0()) by A11,A12;
(for n being Nat holds (for S being non  empty ManySortedSign holds (for x being set holds ((S = ( f . n ) & x = ( h() . n )) implies (( f . ( n + 1 ) ) = Sl(S,x,n) & ( h() . ( n + 1 ) ) = o(x,n)))))) from CKB24:sch 1(A22,A14,A21);
then A23: (for n being Nat holds (for S being non  empty ManySortedSign holds (for x being set holds ((S = f(n) & x = ( h() . n )) implies (((f(( n + 1 )) = ( S +* S(x,n) ) & ( h() . ( n + 1 ) ) = o(x,n)) & x in ( InputVertices S(x,n) )) & o(x,n) in ( InnerVertices S(x,n) )))))) by A9;
( A9 +* A2 ) = ( A +* ( MSAlg (A(x,n),S(x,n)) ) ) by A17,A18,CKB29:def 1;
then reconsider AA = ( A +* ( MSAlg (A(x,n),S(x,n)) ) ) as  Boolean  gate`2=den  strict (Circuit of ( S9 +* S(x,n) ));
take AA;
A24: ( n(( 0 )) + ( ( n + 1 ) * n(1) ) ) = ( ( n(( 0 )) + ( n * n(1) ) ) + n(1) );
thus (( S9 +* S(x,n) ) = ( S +* S(x,n) ) & ( A +* ( MSAlg (A(x,n),S(x,n)) ) ) = AA) by A17;
thus o(x,n) = h(( n + 1 )) by A9,A19;
let s being (State of AA);
A25: ( InnerVertices S0() ) is Relation by A5;
A26: (for n being Nat holds (for x being set holds (x = ( h() . n ) implies ( ( InputVertices S(x,n) ) \ { x } ) is  without_pairs))) by A8;
A27: (for n being Nat holds (for x being set holds ( InnerVertices S(x,n) ) is Relation)) by A7;
A28: ( InputVertices S0() ) is  without_pairs by A5;
A29: (f(( 0 )) = S0() & ( h() . ( 0 ) ) in ( InnerVertices S0() )) by A6,A11;
(for n being Nat holds (ex S1,S2 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign st ((((S1 = f(n) & S2 = f(( n + 1 ))) & ( InputVertices S2 ) = ( ( InputVertices S1 ) \/ ( ( InputVertices S(( h() . n ),n) ) \ { ( h() . n ) } ) )) & ( InnerVertices S1 ) is Relation) & ( InputVertices S1 ) is  without_pairs))) from CKB19:sch 1(A25,A28,A29,A27,A26,A23);
then (ex S1,S2 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign st ((((S1 = ( f . n ) & S2 = ( f . ( n + 1 ) )) & ( InputVertices S2 ) = ( ( InputVertices S1 ) \/ ( ( InputVertices S(h(n),n) ) \ { h(n) } ) )) & ( InnerVertices S1 ) is Relation) & ( InputVertices S1 ) is  without_pairs));
then A30: ( InputVertices S9 ) misses ( InnerVertices S(x,n) ) by A7,A16,A17,FACIRC_1:5;
(A2 = ( MSAlg (A(x,n),S(x,n)) ) & (for s being (State of A2) holds ( Following (s,n(1)) ) is  stable)) by A3,A19,CKB29:def 1;
hence ( Following (s,( n(( 0 )) + ( ( n + 1 ) * n(1) ) )) ) is  stable by A17,A18,A20,A30,A24,CKB43:1,CIRCCOMB:60;
end;

end;
A31: (for S being non  empty ManySortedSign holds (for A being  non-empty MSAlgebra over S holds (for x being set holds (for n being Nat holds Al(S,A,x,n) is  non-empty  non-empty MSAlgebra over Sl(S,x,n)))));
A32: (ex S being non  empty ManySortedSign st (ex A being  non-empty MSAlgebra over S st (ex x being set st (((S = ( f . ( 0 ) ) & A = ( g . ( 0 ) )) & x = ( h() . ( 0 ) )) & Q[ S,A,x,( 0 ) ])))) by A2,A11,A12;
(for n being Nat holds (ex S being non  empty ManySortedSign st (ex A being  non-empty MSAlgebra over S st ((S = ( f . n ) & A = ( g . n )) & Q[ S,A,( h() . n ),n ])))) from CKB22:sch 1(A32,A14,A15,A31);
then (ex S being non  empty ManySortedSign st (ex A being  non-empty MSAlgebra over S st ((S = ( f . n(2) ) & A = ( g . n(2) )) & Q[ S,A,( h() . n(2) ),n(2) ])));
hence thesis by A10;
end;
