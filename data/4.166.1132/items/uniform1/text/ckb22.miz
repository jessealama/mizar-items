environ
vocabularies NUMBERS,REAL_1,SUBSET_1,XXREAL_0,CARD_1,ARYTM_3,RELAT_1,XBOOLE_0,METRIC_1,FUNCT_1,FCONT_2,PARTFUN1,PRE_TOPC,PCOMPS_1,ORDINAL2,RCOMP_1,XREAL_0,ORDINAL1,STRUCT_0,TARSKI,SETFAM_1,FINSET_1,ZFMISC_1,TOPMETR,BORSUK_1,EUCLID,FINSEQ_1,ORDINAL4,COMPLEX1,ARYTM_1,XXREAL_1,VALUED_0,MEASURE5,NAT_1,INT_1,XXREAL_2;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,SETFAM_1,COMPLEX1,REAL_1,NAT_1,NAT_D,ORDINAL1,INT_1,RCOMP_1,FUNCT_1,PARTFUN1,FINSEQ_1,RELSET_1,FUNCT_2,SEQM_3,STRUCT_0,TOPMETR,PRE_TOPC,TOPS_2,COMPTS_1,EUCLID,FINSET_1,TBSP_1,METRIC_1,PCOMPS_1,CKB2,CKB20;
definitions TARSKI,ORDINAL1,EUCLID,PRE_TOPC,XCMPLX_0,CKB2,CKB20;
theorems TARSKI,RCOMP_1,TOPMETR,TOPS_1,METRIC_1,FUNCT_1,FUNCT_2,TBSP_1,NAT_1,FINSEQ_3,FINSEQ_1,ABSVALUE,PRE_TOPC,TOPS_2,FINSEQ_4,GOBOARD6,PCOMPS_1,SETFAM_1,SUBSET_1,COMPTS_1,SEQ_4,HEINE,INT_1,JORDAN2B,XBOOLE_0,XBOOLE_1,XREAL_0,FINSEQ_2,XCMPLX_1,FINSET_1,XREAL_1,XXREAL_0,PARTFUN1,XXREAL_1,EUCLID,SEQM_3,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21;
schemes FUNCT_2,DOMAIN_1,SUBSET_1,FINSEQ_1,NAT_1;
registrations XBOOLE_0,SUBSET_1,ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,FINSEQ_1,STRUCT_0,METRIC_1,PCOMPS_1,EUCLID,TOPMETR,BORSUK_2,VALUED_0,FUNCT_2,BORSUK_1;
constructors SETFAM_1,REAL_1,NAT_1,COMPLEX1,RCOMP_1,BINARITH,TOPS_2,COMPTS_1,TBSP_1,TOPMETR,GOBOARD1,SEQ_1,SEQM_3,NAT_D,FUNCSDOM,PCOMPS_1,CKB2,CKB20;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve i for (Element of ( NAT ));
reserve j for (Element of ( NAT ));
theorem
Lm8: (for f being (FinSequence of ( REAL )) holds ((for k being (Element of ( NAT )) holds ((1 <= k & k < ( len f )) implies ( f /. k ) > ( f /. ( k + 1 ) ))) implies f is  decreasing))
proof
let f being (FinSequence of ( REAL ));
assume A1: (for k being (Element of ( NAT )) holds ((1 <= k & k < ( len f )) implies ( f /. k ) > ( f /. ( k + 1 ) )));
now
let i;
let j;
now
defpred P[ (Element of ( NAT )) ]
 means
(( i + ( 1 + $1 ) ) <= ( len f ) implies ( f /. i ) > ( f /. ( i + ( 1 + $1 ) ) ));
assume that
A2: i in ( dom f )
and
A3: j in ( dom f )
and
A4: i < j;
A5: 1 <= i by A2,FINSEQ_3:25;
A6: (for k being (Element of ( NAT )) holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume A7: (( i + ( 1 + k ) ) <= ( len f ) implies ( f /. i ) > ( f /. ( i + ( 1 + k ) ) ));
now
(1 <= ( i + 1 ) & ( i + 1 ) <= ( ( i + 1 ) + k )) by NAT_1:11;
then A8: 1 <= ( ( i + 1 ) + k ) by XXREAL_0:2;
A9: ( i + ( 1 + ( k + 1 ) ) ) = ( ( i + ( 1 + k ) ) + 1 );
( 1 + k ) < ( 1 + ( k + 1 ) ) by NAT_1:13;
then A10: ( i + ( 1 + k ) ) < ( i + ( 1 + ( k + 1 ) ) ) by XREAL_1:6;
assume A11: ( i + ( 1 + ( k + 1 ) ) ) <= ( len f );
then ( i + ( 1 + k ) ) < ( len f ) by A10,XXREAL_0:2;
then ( f /. ( i + ( 1 + k ) ) ) > ( f /. ( i + ( 1 + ( k + 1 ) ) ) ) by A1,A8,A9;
hence ( f /. i ) > ( f /. ( i + ( 1 + ( k + 1 ) ) ) ) by A7,A11,A10,XXREAL_0:2;
end;
hence thesis;
end;
( i + 1 ) <= j by A4,NAT_1:13;
then ( j -' ( i + 1 ) ) = ( j - ( i + 1 ) ) by XREAL_1:233;
then A12: ( i + ( 1 + ( j -' ( i + 1 ) ) ) ) = j;
A13: ( f /. i ) = ( f . i ) by A2,PARTFUN1:def 6;
A14: j <= ( len f ) by A3,FINSEQ_3:25;
then i < ( len f ) by A4,XXREAL_0:2;
then A15: P[ ( 0 ) ] by A1,A5;
(for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A15,A6);
then ( f /. i ) > ( f /. j ) by A14,A12;
hence ( f . i ) > ( f . j ) by A3,A13,PARTFUN1:def 6;
end;
hence (((i in ( dom f ) & j in ( dom f )) & i < j) implies ( f . i ) > ( f . j ));
end;
hence thesis by CKB20:def 1;
end;
