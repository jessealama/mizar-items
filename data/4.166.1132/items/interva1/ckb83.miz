environ
vocabularies SUBSET_1,SETFAM_1,TARSKI,ZFMISC_1,XBOOLE_0,LEXBFS,XXREAL_0,ORDINAL4,STRUCT_0,LATTICES,FUNCT_1,BINOP_1,EQREL_1,ROUGHS_1,MCART_1,QC_LANG1,MSUALG_6,XXREAL_2,PBOOLE,REWRITE1,LATTICE3,INTERVA1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,SETFAM_1,MCART_1,BINOP_1,STRUCT_0,LATTICES,LATTICE3,ROUGHS_1,CKB1,CKB10,CKB13,CKB18,CKB19,CKB22,CKB23,CKB29,CKB37,CKB41,CKB42,CKB43,CKB44,CKB62,CKB71,CKB82;
definitions XBOOLE_0,TARSKI,LATTICES,SUBSET_1,LATTICE3,VECTSP_8,STRUCT_0,CKB1,CKB10,CKB18,CKB19,CKB22,CKB23,CKB29,CKB37,CKB62,CKB71,CKB82;
theorems ROUGHS_1,ZFMISC_1,MCART_1,XBOOLE_1,BINOP_1,LATTICES,TARSKI,LATTICE3,SETFAM_1,XBOOLE_0,TOPGEN_4,SUBSET_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB15,CKB16,CKB17,CKB18,CKB19,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB39,CKB40,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56,CKB57,CKB58,CKB59,CKB60,CKB61,CKB62,CKB64,CKB65,CKB66,CKB67,CKB68,CKB71,CKB72,CKB73,CKB74,CKB75,CKB76,CKB77,CKB78,CKB79,CKB80,CKB81,CKB82;
schemes BINOP_1,XBOOLE_0;
registrations RELSET_1,STRUCT_0,SUBSET_1,XBOOLE_0,LATTICES,CKB14,CKB20,CKB21,CKB38,CKB63,CKB69,CKB70;
constructors LATTICE3,SETFAM_1,ROUGHS_1,BINOP_1,CKB1,CKB10,CKB13,CKB18,CKB19,CKB22,CKB23,CKB29,CKB37,CKB43,CKB44,CKB62,CKB71,CKB82;
requirements BOOLE,SUBSET;
begin
definition
let U being non empty set;
func InterLatt U ->  strict non empty LattStr
means
:Def12: ((the carrier of it) = ( IntervalSets U ) & (for a,b being (Element of (the carrier of it)) holds (for a9,b9 being non empty (IntervalSet of U) holds ((a9 = a & b9 = b) implies (( (the L_join of it) . (a,b) ) = ( a9 _\/_ b9 ) & ( (the L_meet of it) . (a,b) ) = ( a9 _/\_ b9 ))))));
existence
proof
set B = ( IntervalSets U );
defpred P[ (Element of B),(Element of B),(Element of B) ]
 means
(ex a9,b9 being non empty (IntervalSet of U) st ((a9 = $1 & b9 = $2) & $3 = ( a9 _\/_ b9 )));
A1: (for x,y being (Element of B) holds (ex z being (Element of B) st P[ x,y,z ]))
proof
let x being (Element of B),y being (Element of B);
reconsider x9 = x,y9 = y as non empty (IntervalSet of U) by CKB82:def 1;
reconsider z = ( x9 _\/_ y9 ) as (Element of B) by CKB82:def 1;
take z;
thus thesis;
end;
consider B1 being (BinOp of B) such that A2: (for x,y being (Element of B) holds P[ x,y,( B1 . (x,y) ) ]) from BINOP_1:sch 3(A1);
defpred R[ (Element of B),(Element of B),(Element of B) ]
 means
(ex a9,b9 being non empty (IntervalSet of U) st ((a9 = $1 & b9 = $2) & $3 = ( a9 _/\_ b9 )));
A3: (for x,y being (Element of B) holds (ex z being (Element of B) st R[ x,y,z ]))
proof
let x being (Element of B),y being (Element of B);
reconsider x9 = x,y9 = y as non empty (IntervalSet of U) by CKB82:def 1;
reconsider z = ( x9 _/\_ y9 ) as (Element of B) by CKB82:def 1;
take z;
thus thesis;
end;
consider B2 being (BinOp of B) such that A4: (for x,y being (Element of B) holds R[ x,y,( B2 . (x,y) ) ]) from BINOP_1:sch 3(A3);
take IT = LattStr (# B,B1,B2 #);
thus (the carrier of IT) = ( IntervalSets U );
let a being (Element of (the carrier of IT)),b being (Element of (the carrier of IT));
let a9 being non empty (IntervalSet of U),b9 being non empty (IntervalSet of U);
assume A5: (a9 = a & b9 = b);
reconsider x = a,y = b as (Element of B);
consider a9 being non empty (IntervalSet of U),b9 being non empty (IntervalSet of U) such that A6: ((a9 = x & b9 = y) & ( B1 . (x,y) ) = ( a9 _\/_ b9 )) by A2;
consider a1 being non empty (IntervalSet of U),b1 being non empty (IntervalSet of U) such that A7: ((a1 = x & b1 = y) & ( B2 . (x,y) ) = ( a1 _/\_ b1 )) by A4;
thus thesis by A6,A7,A5;
end;
uniqueness
proof
let L1 being  strict non empty LattStr,L2 being  strict non empty LattStr;
assume that
A8: ((the carrier of L1) = ( IntervalSets U ) & (for a,b being (Element of (the carrier of L1)) holds (for a9,b9 being non empty (IntervalSet of U) holds ((a9 = a & b9 = b) implies (( (the L_join of L1) . (a,b) ) = ( a9 _\/_ b9 ) & ( (the L_meet of L1) . (a,b) ) = ( a9 _/\_ b9 ))))))
and
A9: ((the carrier of L2) = ( IntervalSets U ) & (for a,b being (Element of (the carrier of L2)) holds (for a9,b9 being non empty (IntervalSet of U) holds ((a9 = a & b9 = b) implies (( (the L_join of L2) . (a,b) ) = ( a9 _\/_ b9 ) & ( (the L_meet of L2) . (a,b) ) = ( a9 _/\_ b9 ))))));
(for a,b being (Element of L1) holds ( (the L_join of L1) . (a,b) ) = ( (the L_join of L2) . (a,b) ))
proof
let a being (Element of L1),b being (Element of L1);
reconsider a9 = a,b9 = b as non empty (IntervalSet of U) by A8,CKB82:def 1;
( (the L_join of L1) . (a,b) ) = ( a9 _\/_ b9 ) by A8
.= ( (the L_join of L2) . (a,b) ) by A9,A8;
hence thesis;
end;
then A10: (the L_join of L1) = (the L_join of L2) by A8,A9,BINOP_1:2;
(for a,b being (Element of L1) holds ( (the L_meet of L1) . (a,b) ) = ( (the L_meet of L2) . (a,b) ))
proof
let a being (Element of L1),b being (Element of L1);
reconsider a9 = a,b9 = b as non empty (IntervalSet of U) by A8,CKB82:def 1;
( (the L_meet of L1) . (a,b) ) = ( a9 _/\_ b9 ) by A8
.= ( (the L_meet of L2) . (a,b) ) by A8,A9;
hence thesis;
end;
hence thesis by A8,A9,A10,BINOP_1:2;
end;
end;
