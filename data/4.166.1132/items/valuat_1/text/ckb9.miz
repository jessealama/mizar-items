environ
vocabularies SUBSET_1,NUMBERS,XBOOLE_0,FUNCT_2,QC_LANG1,FUNCT_1,RELAT_1,TARSKI,MARGREL1,XBOOLEAN,CQC_LANG,ARYTM_3,FINSEQ_1,NAT_1,XXREAL_0,ZF_LANG,FUNCOP_1,REALSET1,BVFUNC_2,ZF_MODEL,ZF_LANG1,QC_LANG3,CARD_1,CLASSES2,VALUAT_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,RELAT_1,FUNCT_1,FUNCT_2,NAT_1,FINSEQ_1,QC_LANG1,QC_LANG3,CQC_LANG,MARGREL1,XXREAL_0,CKB1,CKB4,CKB5,CKB8;
definitions XBOOLEAN,CKB1,CKB5;
theorems TARSKI,FINSEQ_1,FUNCT_1,FUNCT_2,FUNCOP_1,QC_LANG1,QC_LANG2,QC_LANG3,CQC_LANG,MARGREL1,RELSET_1,RELAT_1,FINSEQ_3,XBOOLE_0,XBOOLE_1,XBOOLEAN,ORDINAL1,CARD_1,CKB1,CKB3,CKB5,CKB6,CKB7;
schemes QC_LANG1,CQC_LANG,FUNCT_2;
registrations XBOOLE_0,FUNCT_1,RELSET_1,MEMBERED,MARGREL1,QC_LANG1,CQC_LANG,XXREAL_0,FUNCT_2,CARD_1,CKB2;
constructors XXREAL_0,MEMBERED,MARGREL1,QC_LANG3,CQC_LANG,RELSET_1,CKB1,CKB4,CKB5;
requirements NUMERALS,SUBSET,BOOLE;
begin
reserve i for (Element of ( NAT ));
reserve k for (Element of ( NAT ));
reserve A for non  empty set;
reserve x for bound_QC-variable;
reserve v for (Element of ( Valuations_in A ));
reserve ll for (CQC-variable_list of k);
definition
let A;
let k;
let ll;
let v;
redefine func v *' ll -> (FinSequence of A) means 
:Def8: (( len it ) = k & (for i being Nat holds ((1 <= i & i <= k) implies ( it . i ) = ( v . ( ll . i ) ))));
coherence
proof
(( rng v ) c= A & ( rng ( v * ll ) ) c= ( rng v )) by RELAT_1:26,RELAT_1:def 19;
then A1: ( rng ( v * ll ) ) c= A by XBOOLE_1:1;
A2: ( len ll ) = k by CARD_1:def 7;
( dom v ) = ( bound_QC-variables ) by FUNCT_2:def 1;
then ( rng ll ) c= ( dom v ) by RELAT_1:def 19;
then ( dom ( v * ll ) ) = ( dom ll ) by RELAT_1:27
.= ( Seg k ) by A2,FINSEQ_1:def 3;
then ( v * ll ) is  FinSequence-like by FINSEQ_1:def 2;
hence thesis by A1,FINSEQ_1:def 4;
end;
compatibility
proof
let IT being (FinSequence of A);
A3: ( len ll ) = k by CARD_1:def 7;
( dom v ) = ( bound_QC-variables ) by FUNCT_2:def 1;
then A4: ( rng ll ) c= ( dom v ) by RELAT_1:def 19;
thus (IT = ( v * ll ) implies (( len IT ) = k & (for i being Nat holds ((1 <= i & i <= k) implies ( IT . i ) = ( v . ( ll . i ) )))))
proof
assume A5: IT = ( v * ll );
then A6: ( dom ll ) = ( dom IT ) by A4,RELAT_1:27;
hence ( len IT ) = k by A3,FINSEQ_3:29;
let i being Nat;
assume (1 <= i & i <= k);
then i in ( dom IT ) by A3,A6,FINSEQ_3:25;
hence thesis by A5,FUNCT_1:12;
end;

assume that
A7: ( len IT ) = k
and
A8: (for i being Nat holds ((1 <= i & i <= k) implies ( IT . i ) = ( v . ( ll . i ) )));
A9: (for x being set holds (x in ( dom IT ) iff (x in ( dom ll ) & ( ll . x ) in ( dom v ))))
proof
let x being set;
thus (x in ( dom IT ) implies (x in ( dom ll ) & ( ll . x ) in ( dom v )))
proof
assume x in ( dom IT );
hence x in ( dom ll ) by A3,A7,FINSEQ_3:29;
then ( ll . x ) in ( rng ll ) by FUNCT_1:def 3;
hence thesis by A4;
end;

assume that
A10: x in ( dom ll )
and
( ll . x ) in ( dom v );
thus thesis by A3,A7,A10,FINSEQ_3:29;
end;
(for x being set holds (x in ( dom IT ) implies ( IT . x ) = ( v . ( ll . x ) )))
proof
let x being set;
assume A11: x in ( dom IT );
then reconsider i = x as (Element of ( NAT ));
(1 <= i & i <= k) by A7,A11,FINSEQ_3:25;
hence thesis by A8;
end;
hence thesis by A9,FUNCT_1:10;
end;
end;
