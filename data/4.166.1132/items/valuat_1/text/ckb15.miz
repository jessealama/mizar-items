environ
vocabularies SUBSET_1,NUMBERS,XBOOLE_0,FUNCT_2,QC_LANG1,FUNCT_1,RELAT_1,TARSKI,MARGREL1,XBOOLEAN,CQC_LANG,ARYTM_3,FINSEQ_1,NAT_1,XXREAL_0,ZF_LANG,FUNCOP_1,REALSET1,BVFUNC_2,ZF_MODEL,ZF_LANG1,QC_LANG3,CARD_1,CLASSES2,VALUAT_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,RELAT_1,FUNCT_1,FUNCT_2,NAT_1,FINSEQ_1,QC_LANG1,QC_LANG3,CQC_LANG,MARGREL1,XXREAL_0,CKB1,CKB4,CKB5,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14;
definitions XBOOLEAN,CKB1,CKB5,CKB9,CKB10,CKB12,CKB14;
theorems TARSKI,FINSEQ_1,FUNCT_1,FUNCT_2,FUNCOP_1,QC_LANG1,QC_LANG2,QC_LANG3,CQC_LANG,MARGREL1,RELSET_1,RELAT_1,FINSEQ_3,XBOOLE_0,XBOOLE_1,XBOOLEAN,ORDINAL1,CARD_1,CKB1,CKB3,CKB5,CKB6,CKB7,CKB9,CKB10,CKB12,CKB14;
schemes QC_LANG1,CQC_LANG,FUNCT_2;
registrations XBOOLE_0,FUNCT_1,RELSET_1,MEMBERED,MARGREL1,QC_LANG1,CQC_LANG,XXREAL_0,FUNCT_2,CARD_1,CKB2;
constructors XXREAL_0,MEMBERED,MARGREL1,QC_LANG3,CQC_LANG,RELSET_1,CKB1,CKB4,CKB5,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14;
requirements NUMERALS,SUBSET,BOOLE;
begin
reserve k for (Element of ( NAT ));
reserve A for non empty set;
reserve x for bound_QC-variable;
reserve ll for (CQC-variable_list of k);
reserve p for (Element of ( CQC-WFF ));
reserve q for (Element of ( CQC-WFF ));
reserve J for (interpretation of A);
reserve P for (QC-pred_symbol of k);
theorem
Lm1: (for A holds (for J holds ((((( Valid (( VERUM ),J) ) = ( ( Valuations_in A ) --> ( TRUE ) ) & (for k holds (for ll holds (for P holds ( Valid (( P ! ll ),J) ) = ( ll 'in' ( J . P ) ))))) & (for p holds ( Valid (( 'not' p ),J) ) = ( 'not' ( Valid (p,J) ) ))) & (for q holds ( Valid (( p '&' q ),J) ) = ( ( Valid (p,J) ) '&' ( Valid (q,J) ) ))) & (for x holds ( Valid (( All (x,p) ),J) ) = ( FOR_ALL (x,( Valid (p,J) )) )))))
proof
let A;
let J;
set D = ( Funcs (( Valuations_in A ),( BOOLEAN )) );
set V = ( ( Valuations_in A ) --> ( TRUE ) );
deffunc A((Element of ( NAT )),(QC-pred_symbol of $1),(CQC-variable_list of $1)) = ( $3 'in' ( J . $2 ) );
deffunc N((Element of D)) = ( 'not' $1 );
deffunc C((Element of D),(Element of D)) = ( $1 '&' $2 );
deffunc Q(bound_QC-variable,(Element of D)) = ( FOR_ALL ($1,$2) );
deffunc X((Element of ( CQC-WFF ))) = ( Valid ($1,J) );
A1: (for p holds (for d being (Element of D) holds (d = X(p) iff (ex F being (Function of ( CQC-WFF ),D) st ((d = ( F . p ) & ( F . ( VERUM ) ) = V) & (for p,q being (Element of ( CQC-WFF )) holds (for x being bound_QC-variable holds (for k being (Element of ( NAT )) holds (for ll being (CQC-variable_list of k) holds (for P being (QC-pred_symbol of k) holds (((( F . ( P ! ll ) ) = A(k,P,ll) & ( F . ( 'not' p ) ) = N(( F . p ))) & ( F . ( p '&' q ) ) = C(( F . p ),( F . q ))) & ( F . ( All (x,p) ) ) = Q(x,( F . p ))))))))))))) by CKB14:def 1;
thus X(( VERUM )) = V from CQC_LANG:sch 5(A1);
hereby
let k;
let ll;
let P;
thus X(( P ! ll )) = A(k,P,ll) from CQC_LANG:sch 6(A1);
end;
hereby
let p;
thus X(( 'not' p )) = N(X(p)) from CQC_LANG:sch 7(A1);
end;
hereby
let q;
thus X(( p '&' q )) = C(X(p),X(q)) from CQC_LANG:sch 8(A1);
end;
let x;
thus X(( All (x,p) )) = Q(x,X(p)) from CQC_LANG:sch 9(A1);
end;
