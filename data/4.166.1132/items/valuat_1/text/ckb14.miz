environ
vocabularies SUBSET_1,NUMBERS,XBOOLE_0,FUNCT_2,QC_LANG1,FUNCT_1,RELAT_1,TARSKI,MARGREL1,XBOOLEAN,CQC_LANG,ARYTM_3,FINSEQ_1,NAT_1,XXREAL_0,ZF_LANG,FUNCOP_1,REALSET1,BVFUNC_2,ZF_MODEL,ZF_LANG1,QC_LANG3,CARD_1,CLASSES2,VALUAT_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,RELAT_1,FUNCT_1,FUNCT_2,NAT_1,FINSEQ_1,QC_LANG1,QC_LANG3,CQC_LANG,MARGREL1,XXREAL_0,CKB1,CKB4,CKB5,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13;
definitions XBOOLEAN,CKB1,CKB5,CKB9,CKB10,CKB12;
theorems TARSKI,FINSEQ_1,FUNCT_1,FUNCT_2,FUNCOP_1,QC_LANG1,QC_LANG2,QC_LANG3,CQC_LANG,MARGREL1,RELSET_1,RELAT_1,FINSEQ_3,XBOOLE_0,XBOOLE_1,XBOOLEAN,ORDINAL1,CARD_1,CKB1,CKB3,CKB5,CKB6,CKB7,CKB9,CKB10,CKB12;
schemes QC_LANG1,CQC_LANG,FUNCT_2;
registrations XBOOLE_0,FUNCT_1,RELSET_1,MEMBERED,MARGREL1,QC_LANG1,CQC_LANG,XXREAL_0,FUNCT_2,CARD_1,CKB2;
constructors XXREAL_0,MEMBERED,MARGREL1,QC_LANG3,CQC_LANG,RELSET_1,CKB1,CKB4,CKB5,CKB9,CKB10,CKB11,CKB12,CKB13;
requirements NUMERALS,SUBSET,BOOLE;
begin
reserve A for non  empty set;
reserve p for (Element of ( CQC-WFF ));
reserve J for (interpretation of A);
definition
let A;
let J;
let p;
func Valid (p,J) -> (Element of ( Funcs (( Valuations_in A ),( BOOLEAN )) )) means 
:Def11: (ex F being (Function of ( CQC-WFF ),( Funcs (( Valuations_in A ),( BOOLEAN )) )) st ((it = ( F . p ) & ( F . ( VERUM ) ) = ( ( Valuations_in A ) --> ( TRUE ) )) & (for p,q being (Element of ( CQC-WFF )) holds (for x being bound_QC-variable holds (for k being (Element of ( NAT )) holds (for ll being (CQC-variable_list of k) holds (for P being (QC-pred_symbol of k) holds (((( F . ( P ! ll ) ) = ( ll 'in' ( J . P ) ) & ( F . ( 'not' p ) ) = ( 'not' ( F . p ) )) & ( F . ( p '&' q ) ) = ( ( F . p ) '&' ( F . q ) )) & ( F . ( All (x,p) ) ) = ( FOR_ALL (x,( F . p )) )))))))));
correctness
proof
deffunc A((Element of ( NAT )),(QC-pred_symbol of $1),(CQC-variable_list of $1)) = ( $3 'in' ( J . $2 ) );
set V = ( ( Valuations_in A ) --> ( TRUE ) );
set D = ( Funcs (( Valuations_in A ),( BOOLEAN )) );
deffunc N((Element of D)) = ( 'not' $1 );
deffunc C((Element of D),(Element of D)) = ( $1 '&' $2 );
deffunc Q(bound_QC-variable,(Element of D)) = ( FOR_ALL ($1,$2) );
thus ((ex d being (Element of D) st (ex F being (Function of ( CQC-WFF ),D) st ((d = ( F . p ) & ( F . ( VERUM ) ) = V) & (for r,s being (Element of ( CQC-WFF )) holds (for x being bound_QC-variable holds (for k being (Element of ( NAT )) holds (for l being (CQC-variable_list of k) holds (for P being (QC-pred_symbol of k) holds (((( F . ( P ! l ) ) = A(k,P,l) & ( F . ( 'not' r ) ) = N(( F . r ))) & ( F . ( r '&' s ) ) = C(( F . r ),( F . s ))) & ( F . ( All (x,r) ) ) = Q(x,( F . r ))))))))))) & (for d1,d2 being (Element of D) holds (((ex F being (Function of ( CQC-WFF ),D) st ((d1 = ( F . p ) & ( F . ( VERUM ) ) = V) & (for r,s being (Element of ( CQC-WFF )) holds (for x being bound_QC-variable holds (for k being (Element of ( NAT )) holds (for l being (CQC-variable_list of k) holds (for P being (QC-pred_symbol of k) holds (((( F . ( P ! l ) ) = A(k,P,l) & ( F . ( 'not' r ) ) = N(( F . r ))) & ( F . ( r '&' s ) ) = C(( F . r ),( F . s ))) & ( F . ( All (x,r) ) ) = Q(x,( F . r )))))))))) & (ex F being (Function of ( CQC-WFF ),D) st ((d2 = ( F . p ) & ( F . ( VERUM ) ) = V) & (for r,s being (Element of ( CQC-WFF )) holds (for x being bound_QC-variable holds (for k being (Element of ( NAT )) holds (for l being (CQC-variable_list of k) holds (for P being (QC-pred_symbol of k) holds (((( F . ( P ! l ) ) = A(k,P,l) & ( F . ( 'not' r ) ) = N(( F . r ))) & ( F . ( r '&' s ) ) = C(( F . r ),( F . s ))) & ( F . ( All (x,r) ) ) = Q(x,( F . r ))))))))))) implies d1 = d2))) from CQC_LANG:sch 4;
end;
end;
