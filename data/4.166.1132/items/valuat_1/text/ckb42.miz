environ
vocabularies SUBSET_1,NUMBERS,XBOOLE_0,FUNCT_2,QC_LANG1,FUNCT_1,RELAT_1,TARSKI,MARGREL1,XBOOLEAN,CQC_LANG,ARYTM_3,FINSEQ_1,NAT_1,XXREAL_0,ZF_LANG,FUNCOP_1,REALSET1,BVFUNC_2,ZF_MODEL,ZF_LANG1,QC_LANG3,CARD_1,CLASSES2,VALUAT_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,RELAT_1,FUNCT_1,FUNCT_2,NAT_1,FINSEQ_1,QC_LANG1,QC_LANG3,CQC_LANG,MARGREL1,XXREAL_0,CKB1,CKB4,CKB5,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB28,CKB39;
definitions XBOOLEAN,CKB1,CKB5,CKB9,CKB10,CKB12,CKB14,CKB28,CKB39;
theorems TARSKI,FINSEQ_1,FUNCT_1,FUNCT_2,FUNCOP_1,QC_LANG1,QC_LANG2,QC_LANG3,CQC_LANG,MARGREL1,RELSET_1,RELAT_1,FINSEQ_3,XBOOLE_0,XBOOLE_1,XBOOLEAN,ORDINAL1,CARD_1,CKB1,CKB3,CKB5,CKB6,CKB7,CKB9,CKB10,CKB12,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41;
schemes QC_LANG1,CQC_LANG,FUNCT_2;
registrations XBOOLE_0,FUNCT_1,RELSET_1,MEMBERED,MARGREL1,QC_LANG1,CQC_LANG,XXREAL_0,FUNCT_2,CARD_1,CKB2;
constructors XXREAL_0,MEMBERED,MARGREL1,QC_LANG3,CQC_LANG,RELSET_1,CKB1,CKB4,CKB5,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB28,CKB39;
requirements NUMERALS,SUBSET,BOOLE;
begin
reserve k for (Element of ( NAT ));
reserve A for non empty set;
reserve x for bound_QC-variable;
reserve x1 for bound_QC-variable;
reserve y for bound_QC-variable;
reserve v for (Element of ( Valuations_in A ));
reserve v1 for (Element of ( Valuations_in A ));
reserve ll for (CQC-variable_list of k);
reserve p for (Element of ( CQC-WFF ));
reserve s for (Element of ( CQC-WFF ));
reserve t for (Element of ( CQC-WFF ));
reserve J for (interpretation of A);
reserve P for (QC-pred_symbol of k);
reserve w for (Element of ( Valuations_in A ));
reserve v2 for (Element of ( Valuations_in A ));
reserve z for bound_QC-variable;
Lm3:now
let A being non empty set;
let Y being bound_QC-variable,Z being bound_QC-variable;
let V1 being (Element of ( Valuations_in A )),V2 being (Element of ( Valuations_in A ));
thus (ex v being (Element of ( Valuations_in A )) st ((for x being bound_QC-variable holds (x <> Y implies ( v . x ) = ( V1 . x ))) & ( v . Y ) = ( V2 . Z )))
proof
deffunc G(set) = ( V2 . Z );
deffunc F(set) = ( V1 . $1 );
defpred C[ set ]
 means
(for x1 holds (x1 = $1 implies x1 <> Y));
A1: (for x being set holds (x in ( bound_QC-variables ) implies ((C[ x ] implies F(x) in A) & ((not C[ x ]) implies G(x) in A)))) by FUNCT_2:5;
consider f being (Function of ( bound_QC-variables ),A) such that A2: (for x being set holds (x in ( bound_QC-variables ) implies ((C[ x ] implies ( f . x ) = F(x)) & ((not C[ x ]) implies ( f . x ) = G(x))))) from FUNCT_2:sch 5(A1);
(( dom f ) = ( bound_QC-variables ) & ( rng f ) c= A) by FUNCT_2:def 1,RELAT_1:def 19;
then reconsider f as (Element of ( Valuations_in A )) by FUNCT_2:def 2;
take f;
now
let x being bound_QC-variable;
now
assume A3: x <> Y;
((for x1 holds (x1 = x implies x1 <> Y)) implies ( f . x ) = ( V1 . x )) by A2;
hence ( f . x ) = ( V1 . x ) by A3;
end;
hence (x <> Y implies ( f . x ) = ( V1 . x ));
thus (x = Y implies ( f . Y ) = ( V2 . Z )) by A2;
end;
hence thesis;
end;

end;
theorem
Th39: ((not x in ( still_not-bound_in p )) implies (for v holds (for w holds ((for y holds (x <> y implies ( w . y ) = ( v . y ))) implies ( ( Valid (p,J) ) . v ) = ( ( Valid (p,J) ) . w )))))
proof
defpred PP[ (Element of ( CQC-WFF )) ]
 means
((not x in ( still_not-bound_in $1 )) implies (for v holds (for w holds ((for y holds (x <> y implies ( w . y ) = ( v . y ))) implies ( ( Valid ($1,J) ) . v ) = ( ( Valid ($1,J) ) . w )))));
A1:now
let s;
let t;
let y;
let k;
let ll;
let P;
thus PP[ ( VERUM ) ]
proof
assume (not x in ( still_not-bound_in ( VERUM ) ));
thus (for v holds (for w holds ((for y holds (x <> y implies ( w . y ) = ( v . y ))) implies ( ( Valid (( VERUM ),J) ) . v ) = ( ( Valid (( VERUM ),J) ) . w ))))
proof
let v;
let w;
assume that
(for y holds (x <> y implies ( w . y ) = ( v . y )));
( ( Valid (( VERUM ),J) ) . v ) = ( TRUE ) by CKB17:1;
hence thesis by CKB17:1;
end;

end;

A2: ( rng ll ) c= ( bound_QC-variables ) by RELAT_1:def 19;
thus PP[ ( P ! ll ) ]
proof
assume A3: (not x in ( still_not-bound_in ( P ! ll ) ));
thus (for v holds (for w holds ((for y holds (x <> y implies ( w . y ) = ( v . y ))) implies ( ( Valid (( P ! ll ),J) ) . v ) = ( ( Valid (( P ! ll ),J) ) . w ))))
proof
let v;
let w;
assume that
A4: (for y holds (x <> y implies ( w . y ) = ( v . y )));
A5:now
A6: ( len ( v *' ll ) ) = k by CKB9:def 1;
A7:now
let i being Nat;
assume A8: (1 <= i & i <= ( len ( v *' ll ) ));
A9: ( len ( v *' ll ) ) = ( len ll ) by A6,CARD_1:def 7;
then i in ( dom ll ) by A8,FINSEQ_3:25;
then ( ll . i ) in ( rng ll ) by FUNCT_1:def 3;
then reconsider z = ( ll . i ) as bound_QC-variable by A2;
A10: i in ( NAT ) by ORDINAL1:def 12;
( ll . i ) <> x
proof
reconsider M = ( still_not-bound_in ll ) as set;
(not x in M) by A3,QC_LANG3:5;
then (not x in ( variables_in (ll,( bound_QC-variables )) )) by QC_LANG3:2;
then (not x in { ( ll . i2 ) where i2 is (Element of ( NAT )): ((1 <= i2 & i2 <= ( len ll )) & ( ll . i2 ) in ( bound_QC-variables )) }) by QC_LANG3:def 1;
hence thesis by A8,A10,A9;
end;
then A11: ( w . z ) = ( v . z ) by A4;
( ( v *' ll ) . i ) = ( v . ( ll . i ) ) by A6,A8,CKB9:def 1;
hence ( ( v *' ll ) . i ) = ( ( w *' ll ) . i ) by A6,A8,A11,CKB9:def 1;
end;
assume A12: ( ( Valid (( P ! ll ),J) ) . v ) = ( TRUE );
then ( ( ll 'in' ( J . P ) ) . v ) = ( TRUE ) by CKB15:1;
then A13: ( v *' ll ) in ( J . P ) by CKB10:def 1;
( len ( w *' ll ) ) = k by CKB9:def 1;
then ( w *' ll ) in ( J . P ) by A13,A6,A7,FINSEQ_1:14;
then ( ( ll 'in' ( J . P ) ) . w ) = ( TRUE ) by CKB10:def 1;
hence thesis by A12,CKB15:1;
end;
now
A14: ( len ( v *' ll ) ) = k by CKB9:def 1;
A15:now
let i being Nat;
assume A16: (1 <= i & i <= ( len ( v *' ll ) ));
A17: ( len ( v *' ll ) ) = ( len ll ) by A14,CARD_1:def 7;
then i in ( dom ll ) by A16,FINSEQ_3:25;
then ( ll . i ) in ( rng ll ) by FUNCT_1:def 3;
then reconsider z = ( ll . i ) as bound_QC-variable by A2;
( ll . i ) <> x
proof
reconsider M = ( still_not-bound_in ll ) as set;
(not x in M) by A3,QC_LANG3:5;
then (not x in ( variables_in (ll,( bound_QC-variables )) )) by QC_LANG3:2;
then (i in ( NAT ) & (not x in { ( ll . i2 ) where i2 is (Element of ( NAT )): ((1 <= i2 & i2 <= ( len ll )) & ( ll . i2 ) in ( bound_QC-variables )) })) by ORDINAL1:def 12,QC_LANG3:def 1;
hence thesis by A16,A17;
end;
then A18: ( w . z ) = ( v . z ) by A4;
( ( v *' ll ) . i ) = ( v . ( ll . i ) ) by A14,A16,CKB9:def 1;
hence ( ( v *' ll ) . i ) = ( ( w *' ll ) . i ) by A14,A16,A18,CKB9:def 1;
end;
assume A19: ( ( Valid (( P ! ll ),J) ) . v ) = ( FALSE );
then ( ( ll 'in' ( J . P ) ) . v ) = ( FALSE ) by CKB15:1;
then A20: (not ( v *' ll ) in ( J . P )) by CKB10:def 1;
( len ( w *' ll ) ) = k by CKB9:def 1;
then (not ( w *' ll ) in ( J . P )) by A20,A14,A15,FINSEQ_1:14;
then ( ( ll 'in' ( J . P ) ) . w ) = ( FALSE ) by CKB10:def 1;
hence thesis by A19,CKB15:1;
end;
hence thesis by A5,XBOOLEAN:def 3;
end;

end;

thus (PP[ s ] implies PP[ ( 'not' s ) ])
proof
assume A21: (((not x in ( still_not-bound_in s )) implies (for v holds (for w holds ((for y holds (x <> y implies ( w . y ) = ( v . y ))) implies ( ( Valid (s,J) ) . v ) = ( ( Valid (s,J) ) . w ))))) & (not x in ( still_not-bound_in ( 'not' s ) )));
thus (for v holds (for w holds ((for y holds (x <> y implies ( w . y ) = ( v . y ))) implies ( ( Valid (( 'not' s ),J) ) . v ) = ( ( Valid (( 'not' s ),J) ) . w ))))
proof
let v;
let w;
assume that
A22: (for y holds (x <> y implies ( w . y ) = ( v . y )));
A23:now
assume A24: ( ( Valid (( 'not' s ),J) ) . v ) = ( FALSE );
then ( 'not' ( ( Valid (s,J) ) . v ) ) = ( FALSE ) by CKB22:1;
then ( ( Valid (s,J) ) . v ) = ( TRUE ) by MARGREL1:11;
then ( ( Valid (s,J) ) . w ) = ( TRUE ) by A21,A22,QC_LANG3:7;
then ( 'not' ( ( Valid (s,J) ) . w ) ) = ( FALSE ) by MARGREL1:11;
hence thesis by A24,CKB22:1;
end;
now
assume A25: ( ( Valid (( 'not' s ),J) ) . v ) = ( TRUE );
then ( 'not' ( ( Valid (s,J) ) . v ) ) = ( TRUE ) by CKB22:1;
then ( ( Valid (s,J) ) . v ) = ( FALSE ) by MARGREL1:11;
then ( ( Valid (s,J) ) . w ) = ( FALSE ) by A21,A22,QC_LANG3:7;
then ( 'not' ( ( Valid (s,J) ) . w ) ) = ( TRUE ) by MARGREL1:11;
hence thesis by A25,CKB22:1;
end;
hence thesis by A23,XBOOLEAN:def 3;
end;

end;

thus ((PP[ s ] & PP[ t ]) implies PP[ ( s '&' t ) ])
proof
assume that
A26: ((not x in ( still_not-bound_in s )) implies (for v holds (for w holds ((for y holds (x <> y implies ( w . y ) = ( v . y ))) implies ( ( Valid (s,J) ) . v ) = ( ( Valid (s,J) ) . w )))))
and
A27: ((not x in ( still_not-bound_in t )) implies (for v holds (for w holds ((for y holds (x <> y implies ( w . y ) = ( v . y ))) implies ( ( Valid (t,J) ) . v ) = ( ( Valid (t,J) ) . w )))))
and
A28: (not x in ( still_not-bound_in ( s '&' t ) ));
A29: (not x in ( ( still_not-bound_in s ) \/ ( still_not-bound_in t ) )) by A28,QC_LANG3:10;
thus (for v holds (for w holds ((for y holds (x <> y implies ( w . y ) = ( v . y ))) implies ( ( Valid (( s '&' t ),J) ) . v ) = ( ( Valid (( s '&' t ),J) ) . w ))))
proof
let v;
let w;
assume that
A30: (for y holds (x <> y implies ( w . y ) = ( v . y )));
A31:now
assume A32: ( ( Valid (( s '&' t ),J) ) . v ) = ( FALSE );
A33:now
assume ( ( Valid (s,J) ) . v ) = ( FALSE );
then ( ( Valid (s,J) ) . w ) = ( FALSE ) by A26,A29,A30,XBOOLE_0:def 3;
then ( ( ( Valid (s,J) ) . w ) '&' ( ( Valid (t,J) ) . w ) ) = ( FALSE ) by MARGREL1:12;
hence thesis by A32,CKB24:1;
end;
A34:now
assume ( ( Valid (t,J) ) . v ) = ( FALSE );
then ( ( Valid (t,J) ) . w ) = ( FALSE ) by A27,A29,A30,XBOOLE_0:def 3;
then ( ( ( Valid (s,J) ) . w ) '&' ( ( Valid (t,J) ) . w ) ) = ( FALSE ) by MARGREL1:12;
hence thesis by A32,CKB24:1;
end;
( ( ( Valid (s,J) ) . v ) '&' ( ( Valid (t,J) ) . v ) ) = ( FALSE ) by A32,CKB24:1;
hence thesis by A33,A34,MARGREL1:12;
end;
now
assume A35: ( ( Valid (( s '&' t ),J) ) . v ) = ( TRUE );
then A36: ( ( ( Valid (s,J) ) . v ) '&' ( ( Valid (t,J) ) . v ) ) = ( TRUE ) by CKB24:1;
then ( ( Valid (t,J) ) . v ) = ( TRUE ) by MARGREL1:12;
then A37: ( ( Valid (t,J) ) . w ) = ( TRUE ) by A27,A29,A30,XBOOLE_0:def 3;
( ( Valid (s,J) ) . v ) = ( TRUE ) by A36,MARGREL1:12;
then ( ( Valid (s,J) ) . w ) = ( TRUE ) by A26,A29,A30,XBOOLE_0:def 3;
then ( ( ( Valid (s,J) ) . w ) '&' ( ( Valid (t,J) ) . w ) ) = ( TRUE ) by A37;
hence thesis by A35,CKB24:1;
end;
hence thesis by A31,XBOOLEAN:def 3;
end;

end;

thus (PP[ s ] implies PP[ ( All (y,s) ) ])
proof
assume that
A38: ((not x in ( still_not-bound_in s )) implies (for v holds (for w holds ((for y holds (x <> y implies ( w . y ) = ( v . y ))) implies ( ( Valid (s,J) ) . v ) = ( ( Valid (s,J) ) . w )))))
and
A39: (not x in ( still_not-bound_in ( All (y,s) ) ));
A40: (not x in ( ( still_not-bound_in s ) \ { y } )) by A39,QC_LANG3:12;
thus (for v holds (for w holds ((for z holds (x <> z implies ( w . z ) = ( v . z ))) implies ( ( Valid (( All (y,s) ),J) ) . v ) = ( ( Valid (( All (y,s) ),J) ) . w ))))
proof
let v;
let w;
assume that
A41: (for z holds (x <> z implies ( w . z ) = ( v . z )));
A42:now
assume A43: ( ( Valid (( All (y,s) ),J) ) . v ) = ( FALSE );
then ( ( FOR_ALL (y,( Valid (s,J) )) ) . v ) = ( FALSE ) by CKB15:1;
then consider v1 such that A44: ( ( Valid (s,J) ) . v1 ) = ( FALSE ) and A45: (for z holds (y <> z implies ( v1 . z ) = ( v . z ))) by CKB6:1;
A46:now
assume A47: (not x in ( still_not-bound_in s ));
consider v2 such that A48: ((for z holds (z <> y implies ( v2 . z ) = ( w . z ))) & ( v2 . y ) = ( v1 . y )) by Lm3;
take v2;
(for z holds (x <> z implies ( v2 . z ) = ( v1 . z )))
proof
let z;
assume that
A49: x <> z;
now
assume A50: z <> y;
hence ( v2 . z ) = ( w . z ) by A48
.= ( v . z ) by A41,A49
.= ( v1 . z ) by A45,A50;
end;
hence thesis by A48;
end;
hence ( ( Valid (s,J) ) . v2 ) = ( FALSE ) by A38,A44,A47;
thus (for z holds (y <> z implies ( v2 . z ) = ( w . z ))) by A48;
end;
now
assume A51: x in { y };
take v2 = v1;
thus ( ( Valid (s,J) ) . v2 ) = ( FALSE ) by A44;
(for z holds (y <> z implies ( v1 . z ) = ( w . z )))
proof
let z;
assume A52: y <> z;
then A53: x <> z by A51,TARSKI:def 1;
thus ( v1 . z ) = ( v . z ) by A45,A52
.= ( w . z ) by A41,A53;
end;
hence (for z holds (y <> z implies ( v2 . z ) = ( w . z )));
end;
then ( ( FOR_ALL (y,( Valid (s,J) )) ) . w ) = ( FALSE ) by A40,A46,CKB6:1,XBOOLE_0:def 5;
hence thesis by A43,CKB15:1;
end;
now
assume A54: ( ( Valid (( All (y,s) ),J) ) . v ) = ( TRUE );
then A55: ( ( FOR_ALL (y,( Valid (s,J) )) ) . v ) = ( TRUE ) by CKB15:1;
(for v1 holds ((for z holds (y <> z implies ( v1 . z ) = ( w . z ))) implies ( ( Valid (s,J) ) . v1 ) = ( TRUE )))
proof
let v1;
assume that
A56: (for z holds (y <> z implies ( v1 . z ) = ( w . z )));
A57:now
assume A58: (not x in ( still_not-bound_in s ));
consider v2 such that A59: ((for z holds (z <> y implies ( v2 . z ) = ( v . z ))) & ( v2 . y ) = ( v1 . y )) by Lm3;
A60: (for z holds (x <> z implies ( v2 . z ) = ( v1 . z )))
proof
let z;
assume that
A61: x <> z;
now
assume A62: z <> y;
hence ( v2 . z ) = ( v . z ) by A59
.= ( w . z ) by A41,A61
.= ( v1 . z ) by A56,A62;
end;
hence thesis by A59;
end;
( ( Valid (s,J) ) . v2 ) = ( TRUE ) by A55,A59,CKB7:1;
hence thesis by A38,A58,A60;
end;
now
assume x in { y };
then A63: x = y by TARSKI:def 1;
(for z holds (y <> z implies ( v1 . z ) = ( v . z )))
proof
let z;
assume A64: y <> z;
hence ( v . z ) = ( w . z ) by A41,A63
.= ( v1 . z ) by A56,A64;
end;
hence thesis by A55,CKB7:1;
end;
hence thesis by A40,A57,XBOOLE_0:def 5;
end;
then ( ( FOR_ALL (y,( Valid (s,J) )) ) . w ) = ( TRUE ) by CKB7:1;
hence thesis by A54,CKB15:1;
end;
hence thesis by A42,XBOOLEAN:def 3;
end;

end;

end;
(for s holds PP[ s ]) from CQC_LANG:sch 1(A1);
hence thesis;
end;
