environ
vocabularies SUBSET_1,NUMBERS,XBOOLE_0,FUNCT_2,QC_LANG1,FUNCT_1,RELAT_1,TARSKI,MARGREL1,XBOOLEAN,CQC_LANG,ARYTM_3,FINSEQ_1,NAT_1,XXREAL_0,ZF_LANG,FUNCOP_1,REALSET1,BVFUNC_2,ZF_MODEL,ZF_LANG1,QC_LANG3,CARD_1,CLASSES2,VALUAT_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,RELAT_1,FUNCT_1,FUNCT_2,NAT_1,FINSEQ_1,QC_LANG1,QC_LANG3,CQC_LANG,MARGREL1,XXREAL_0,CKB1,CKB4,CKB5,CKB8,CKB9;
definitions XBOOLEAN,CKB1,CKB5,CKB9;
theorems TARSKI,FINSEQ_1,FUNCT_1,FUNCT_2,FUNCOP_1,QC_LANG1,QC_LANG2,QC_LANG3,CQC_LANG,MARGREL1,RELSET_1,RELAT_1,FINSEQ_3,XBOOLE_0,XBOOLE_1,XBOOLEAN,ORDINAL1,CARD_1,CKB1,CKB3,CKB5,CKB6,CKB7,CKB9;
schemes QC_LANG1,CQC_LANG,FUNCT_2;
registrations XBOOLE_0,FUNCT_1,RELSET_1,MEMBERED,MARGREL1,QC_LANG1,CQC_LANG,XXREAL_0,FUNCT_2,CARD_1,CKB2;
constructors XXREAL_0,MEMBERED,MARGREL1,QC_LANG3,CQC_LANG,RELSET_1,CKB1,CKB4,CKB5,CKB9;
requirements NUMERALS,SUBSET,BOOLE;
begin
reserve k for (Element of ( NAT ));
reserve A for non empty set;
reserve ll for (CQC-variable_list of k);
definition
let A;
let k;
let ll;
let r being (Element of ( relations_on A ));
func ll 'in' r -> (Element of ( Funcs (( Valuations_in A ),( BOOLEAN )) ))
means
:Def9: (for v being (Element of ( Valuations_in A )) holds ((( v *' ll ) in r implies ( it . v ) = ( TRUE )) & ((not ( v *' ll ) in r) implies ( it . v ) = ( FALSE ))));
existence
proof
defpred C[ set ]
 means
(ex v being (Element of ( Valuations_in A )) st ($1 = v & ( v *' ll ) in r));
deffunc T(set) = ( TRUE );
deffunc F(set) = ( FALSE );
A1: (for x being set holds (x in ( Valuations_in A ) implies ((C[ x ] implies T(x) in ( BOOLEAN )) & ((not C[ x ]) implies F(x) in ( BOOLEAN )))));
consider f being (Function of ( Valuations_in A ),( BOOLEAN )) such that A2: (for x being set holds (x in ( Valuations_in A ) implies ((C[ x ] implies ( f . x ) = T(x)) & ((not C[ x ]) implies ( f . x ) = F(x))))) from FUNCT_2:sch 5(A1);
(( dom f ) = ( Valuations_in A ) & ( rng f ) c= ( BOOLEAN )) by FUNCT_2:def 1,RELAT_1:def 19;
then reconsider f as (Element of ( Funcs (( Valuations_in A ),( BOOLEAN )) )) by FUNCT_2:def 2;
take f;
let v being (Element of ( Valuations_in A ));
((not (ex v9 being (Element of ( Valuations_in A )) st (v = v9 & ( v9 *' ll ) in r))) implies ( f . v ) = ( FALSE )) by A2;
hence thesis by A2;
end;
uniqueness
proof
let f1 being (Element of ( Funcs (( Valuations_in A ),( BOOLEAN )) )),f2 being (Element of ( Funcs (( Valuations_in A ),( BOOLEAN )) ));
assume that
A3: (for v being (Element of ( Valuations_in A )) holds ((( v *' ll ) in r implies ( f1 . v ) = ( TRUE )) & ((not ( v *' ll ) in r) implies ( f1 . v ) = ( FALSE ))))
and
A4: (for v being (Element of ( Valuations_in A )) holds ((( v *' ll ) in r implies ( f2 . v ) = ( TRUE )) & ((not ( v *' ll ) in r) implies ( f2 . v ) = ( FALSE ))));
(for v being (Element of ( Valuations_in A )) holds ( f1 . v ) = ( f2 . v ))
proof
let v being (Element of ( Valuations_in A ));
per cases ;
suppose A5: ( v *' ll ) in r;

then ( f1 . v ) = ( TRUE ) by A3;
hence thesis by A4,A5;
end;
suppose A6: (not ( v *' ll ) in r);

then ( f1 . v ) = ( FALSE ) by A3;
hence thesis by A4,A6;
end;
end;
hence thesis by FUNCT_2:63;
end;
end;
