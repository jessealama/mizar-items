environ
vocabularies FINSEQ_1,RELAT_1,SUBSET_1,NUMBERS,ARYTM_3,XXREAL_0,NAT_1,CARD_1,FUNCT_1,TARSKI,STRUCT_0,XBOOLE_0,MSUALG_1,PBOOLE,TREES_3,MSAFREE,DTCONSTR,LANG1,ZFMISC_1,TREES_4,TDGROUP,CARD_3,TREES_2,FINSET_1,MARGREL1,PARTFUN1,TREES_9,ORDINAL4,ORDINAL1,TREES_1,MCART_1,FUNCT_6,TREES_A,QC_LANG1,MSATERM;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,NAT_1,MCART_1,RELAT_1,STRUCT_0,FUNCT_1,PARTFUN1,FINSEQ_1,FINSEQ_2,FUNCT_2,FINSET_1,TREES_1,TREES_2,CARD_3,FUNCT_6,LANG1,TREES_3,TREES_4,TREES_9,PBOOLE,MSUALG_1,DTCONSTR,MSUALG_3,MSAFREE,XXREAL_0,CKB2,CKB4,CKB5,CKB6,CKB9,CKB10,CKB12;
definitions TARSKI,PBOOLE,XBOOLE_0,CKB2,CKB6;
theorems TARSKI,NAT_1,ZFMISC_1,MCART_1,CARD_3,FUNCT_1,FINSEQ_1,FUNCT_2,FINSEQ_3,FINSEQ_4,CARD_5,FUNCT_6,TREES_1,TREES_2,MODAL_1,TREES_3,TREES_4,LANG1,DTCONSTR,TREES_9,PBOOLE,MSUALG_1,MSAFREE,DOMAIN_1,RELAT_1,XBOOLE_0,FINSET_1,XREAL_1,ORDINAL1,PARTFUN1,FINSEQ_2,CKB1,CKB2,CKB6,CKB7,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
schemes TREES_2,CLASSES1,DTCONSTR,PBOOLE,CKB8,CKB11;
registrations XBOOLE_0,RELAT_1,FUNCT_1,ORDINAL1,XREAL_0,FINSEQ_1,PBOOLE,TREES_2,TREES_3,TREES_9,STRUCT_0,DTCONSTR,MSUALG_1,MSUALG_2,MSAFREE,FINSET_1,TREES_1,RELSET_1,CKB3,CKB13;
constructors XXREAL_0,NAT_1,NAT_D,TREES_9,MSUALG_3,MSAFREE,RELSET_1,FINSEQ_2,CKB2,CKB5,CKB6,CKB12;
requirements NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve S for non  void non  empty ManySortedSign;
reserve V for  non-empty (ManySortedSet of (the carrier of S));
reserve A for MSAlgebra over S;
reserve t for (Term of S,V);
Lm4:now
let S;
let A;
let V;
let x being set;
set X = ( (the Sorts of A) \/ V );
set G = ( DTConMSA X );
A1: ( dom ( coprod X ) ) = (the carrier of S) by PARTFUN1:def 2;
A2: ( Terminals G ) = ( Union ( coprod X ) ) by MSAFREE:6;
hereby
assume x in ( Terminals G );
then consider s being set such that A3: s in ( dom ( coprod X ) ) and A4: x in ( ( coprod X ) . s ) by A2,CARD_5:2;
reconsider s as (SortSymbol of S) by A3,PARTFUN1:def 2;
( ( coprod X ) . s ) = ( coprod (s,X) ) by MSAFREE:def 3;
then consider a being set such that A5: a in ( X . s ) and A6: x = [ a,s ] by A4,MSAFREE:def 2;
( X . s ) = ( ( (the Sorts of A) . s ) \/ ( V . s ) ) by PBOOLE:def 4;
then (a in ( (the Sorts of A) . s ) or a in ( V . s )) by A5,XBOOLE_0:def 3;
hence ((ex s being (SortSymbol of S) st (ex a being set st (a in ( (the Sorts of A) . s ) & x = [ a,s ]))) or (ex s being (SortSymbol of S) st (ex v being (Element of ( V . s )) st x = [ v,s ]))) by A6;
end;
let s being (SortSymbol of S);
A7: ( X . s ) = ( ( (the Sorts of A) . s ) \/ ( V . s ) ) by PBOOLE:def 4;
hereby
let a being set;
assume a in ( (the Sorts of A) . s );
then A8: a in ( X . s ) by A7,XBOOLE_0:def 3;
assume x = [ a,s ];
then x in ( coprod (s,X) ) by A8,MSAFREE:def 2;
then x in ( ( coprod X ) . s ) by MSAFREE:def 3;
hence x in ( Terminals G ) by A2,A1,CARD_5:2;
end;
let a being (Element of ( V . s ));
assume A9: x = [ a,s ];
a in ( X . s ) by A7,XBOOLE_0:def 3;
then x in ( coprod (s,X) ) by A9,MSAFREE:def 2;
then x in ( ( coprod X ) . s ) by MSAFREE:def 3;
hence x in ( Terminals G ) by A2,A1,CARD_5:2;
end;
theorem
(for t being (c-Term of A,V) holds (for s being (SortSymbol of S) holds (for v being (Element of ( V . s )) holds (( t . ( {} ) ) = [ v,s ] implies t = ( root-tree [ v,s ] )))))
proof
let t being (c-Term of A,V);
let s being (SortSymbol of S);
let x being (Element of ( V . s ));
set G = ( DTConMSA ( (the Sorts of A) \/ V ) );
reconsider a = [ x,s ] as (Terminal of G) by Lm4;
reconsider t as (Element of ( TS G ));
(( t . ( {} ) ) = a implies t = ( root-tree a )) by DTCONSTR:9;
hence thesis;
end;
