environ
vocabularies XBOOLE_0,ORDERS_2,PARTFUN1,STRUCT_0,FINSEQ_1,RELAT_1,TARSKI,RELAT_2,SUBSET_1,XXREAL_0,LATTICE3,WAYBEL_0,EQREL_1,LATTICES;
notations XBOOLE_0,TARSKI,SUBSET_1,RELSET_1,RELAT_2,STRUCT_0,ORDERS_2,YELLOW_0,WAYBEL_0,LATTICE3,CKB2;
definitions RELAT_2,CKB2;
theorems ZFMISC_1,RELAT_1,RELSET_1,ORDERS_2,RELAT_2,XBOOLE_0,XBOOLE_1,WAYBEL_0,YELLOW_0,YELLOW_5,CKB1,CKB2;
registrations XBOOLE_0,RELSET_1,STRUCT_0,WAYBEL_0;
constructors LATTICE3,WAYBEL_0,RELSET_1,CKB2;
requirements SUBSET,BOOLE;
begin
definition
let R being RelStr;
let S being RelStr;
func R [*] S ->  strict RelStr
means
:Def2: ((the carrier of it) = ( (the carrier of R) \/ (the carrier of S) ) & (the InternalRel of it) = ( ( (the InternalRel of R) \/ (the InternalRel of S) ) \/ ( (the InternalRel of R) * (the InternalRel of S) ) ));
existence
proof
set X = ( (the carrier of R) \/ (the carrier of S) );
((the carrier of R) c= X & (the carrier of S) c= X) by XBOOLE_1:7;
then reconsider G = ( (the InternalRel of R) * (the InternalRel of S) ) as (Relation of X) by RELSET_1:7;
((the carrier of R) c= X & (the carrier of S) c= X) by XBOOLE_1:7;
then reconsider IR = (the InternalRel of R),IS = (the InternalRel of S) as (Relation of X) by RELSET_1:7;
set F = ( ( IR \/ IS ) \/ G );
reconsider F as (Relation of X);
take RelStr (# X,F #);
thus thesis;
end;
uniqueness;
end;
