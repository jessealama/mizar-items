environ
vocabularies AMI_1,SCMFSA_2,SCMFSA7B,SCMFSA6A,SF_MASTR,GRAPHSP,AMI_3,SCMFSA6B,TURING_1,AOFA_I00,SCMFSA8C,SCMFSA8B,SCMFSA8A,CARD_1,AMISTD_2,RELAT_1,TARSKI,XXREAL_0,ARYTM_3,FSM_1,XBOOLE_0,FUNCT_4,NUMBERS,SCMFSA6C,UNIALG_2,CIRCUIT2,FUNCT_1,MSUALG_1,SUBSET_1,NAT_1,STRUCT_0,FINSET_1,SCMFSA_1,ZFMISC_1,SCMNORM,PRE_FF,ARYTM_1,SFMASTR1,PARTFUN1,RELOC,PBOOLE,FUNCOP_1,COMPOS_1;
notations TARSKI,XBOOLE_0,ENUMSET1,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,FINSET_1,NAT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,FUNCOP_1,PBOOLE,FUNCT_7,PRE_FF,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_1,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,XXREAL_0,SEQ_4,CKB1,CKB38,CKB39,CKB40,CKB41,CKB42;
definitions EXTPRO_1,COMPOS_1,SCMFSA_2,SCMFSA7B,FUNCOP_1,SCMFSA6A,MEMSTR_0,CKB1,CKB42;
theorems TARSKI,ZFMISC_1,ENUMSET1,NAT_1,RELAT_1,FUNCT_1,FUNCT_2,LATTICE2,GRFUNC_1,SUBSET_1,FUNCT_4,PRE_FF,SCMFSA_2,MEMSTR_0,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,FUNCOP_1,XXREAL_0,AMI_3,XXREAL_2,PBOOLE,PARTFUN1,COMPOS_1,EXTPRO_1,AMISTD_2,CKB1,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB42;
schemes NAT_1,DOMAIN_1,FRAENKEL,RECDEF_1;
registrations XBOOLE_0,SUBSET_1,SETFAM_1,FUNCT_1,ORDINAL1,FINSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,MEMBERED,AMI_5,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8C,SCMFSA_9,XXREAL_2,RELAT_1,SCMFSA10,AMISTD_2,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,FUNCOP_1,SCMFSA6A,STRUCT_0,MEMSTR_0,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB43;
constructors DOMAIN_1,SETWISEO,SEQ_4,PRE_FF,SCM_1,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA8C,RELSET_1,PRE_POLY,AMISTD_2,SCMFSA7B,SCMFSA_1,PBOOLE,AMISTD_1,COMPLEX1,INT_2,NAT_D,XXREAL_1,MEMSTR_0,CKB1,CKB38,CKB39,CKB40,CKB41,CKB42;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve L for  finite (Subset of ( Int-Locations ));
reserve m for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
theorem
Th18: ((not ( 0 ) in ( ( RWNotIn-seq L ) . n )) & (for m holds (m in ( ( RWNotIn-seq L ) . n ) implies (not ( intloc m ) in L))))
proof
set RL = ( RWNotIn-seq L );
defpred X[ (Element of ( NAT )) ]
 means
((not ( 0 ) in ( RL . $1 )) & (for m holds (m in ( RL . $1 ) implies (not ( intloc m ) in L))));
A1: X[ ( 0 ) ]
proof
A2: ( RL . ( 0 ) ) = { k where k is (Element of ( NAT )): ((not ( intloc k ) in L) & k <> ( 0 )) } by CKB42:def 1;
hereby
assume ( 0 ) in ( RL . ( 0 ) );
then (ex k being (Element of ( NAT )) st ((k = ( 0 ) & (not ( intloc k ) in L)) & k <> ( 0 ))) by A2;
hence contradiction;
end;
let m;
assume m in ( RL . ( 0 ) );
then (ex k being (Element of ( NAT )) st ((k = m & (not ( intloc k ) in L)) & k <> ( 0 ))) by A2;
hence thesis;
end;
A3: (for n holds (X[ n ] implies X[ ( n + 1 ) ]))
proof
let n;
assume that
A4: (not ( 0 ) in ( RL . n ))
and
A5: (for m holds (m in ( RL . n ) implies (not ( intloc m ) in L)));
reconsider sn = ( RL . n ) as non  empty (Subset of ( NAT ));
A6: ( RL . ( n + 1 ) ) = ( sn \ { ( min sn ) } ) by CKB42:def 1;
hence (not ( 0 ) in ( RL . ( n + 1 ) )) by A4,XBOOLE_0:def 5;
let m;
assume m in ( RL . ( n + 1 ) );
then m in ( RL . n ) by A6,XBOOLE_0:def 5;
hence thesis by A5;
end;
(for n being (Element of ( NAT )) holds X[ n ]) from NAT_1:sch 1(A1,A3);
hence thesis;
end;
