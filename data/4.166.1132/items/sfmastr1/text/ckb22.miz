environ
vocabularies AMI_1,SCMFSA_2,SCMFSA7B,SCMFSA6A,SF_MASTR,GRAPHSP,AMI_3,SCMFSA6B,TURING_1,AOFA_I00,SCMFSA8C,SCMFSA8B,SCMFSA8A,CARD_1,AMISTD_2,RELAT_1,TARSKI,XXREAL_0,ARYTM_3,FSM_1,XBOOLE_0,FUNCT_4,NUMBERS,SCMFSA6C,UNIALG_2,CIRCUIT2,FUNCT_1,MSUALG_1,SUBSET_1,NAT_1,STRUCT_0,FINSET_1,SCMFSA_1,ZFMISC_1,SCMNORM,PRE_FF,ARYTM_1,SFMASTR1,PARTFUN1,RELOC,PBOOLE,FUNCOP_1,COMPOS_1;
notations TARSKI,XBOOLE_0,ENUMSET1,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,FINSET_1,NAT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,FUNCOP_1,PBOOLE,FUNCT_7,PRE_FF,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_1,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,XXREAL_0,SEQ_4,CKB1;
definitions EXTPRO_1,COMPOS_1,SCMFSA_2,SCMFSA7B,FUNCOP_1,SCMFSA6A,MEMSTR_0,CKB1;
theorems TARSKI,ZFMISC_1,ENUMSET1,NAT_1,RELAT_1,FUNCT_1,FUNCT_2,LATTICE2,GRFUNC_1,SUBSET_1,FUNCT_4,PRE_FF,SCMFSA_2,MEMSTR_0,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,FUNCOP_1,XXREAL_0,AMI_3,XXREAL_2,PBOOLE,PARTFUN1,COMPOS_1,EXTPRO_1,AMISTD_2,CKB1,CKB21;
schemes NAT_1,DOMAIN_1,FRAENKEL,RECDEF_1;
registrations XBOOLE_0,SUBSET_1,SETFAM_1,FUNCT_1,ORDINAL1,FINSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,MEMBERED,AMI_5,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8C,SCMFSA_9,XXREAL_2,RELAT_1,SCMFSA10,AMISTD_2,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,FUNCOP_1,SCMFSA6A,STRUCT_0,MEMSTR_0,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
constructors DOMAIN_1,SETWISEO,SEQ_4,PRE_FF,SCM_1,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA8C,RELSET_1,PRE_POLY,AMISTD_2,SCMFSA7B,SCMFSA_1,PBOOLE,AMISTD_1,COMPLEX1,INT_2,NAT_D,XXREAL_1,MEMSTR_0,CKB1;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve P for (Instruction-Sequence of ( SCM+FSA ));
reserve S for (State of ( SCM+FSA ));
reserve I for (Program of ( SCM+FSA ));
reserve J for (Program of ( SCM+FSA ));
reserve i for  good  parahalting (Instruction of ( SCM+FSA ));
theorem
Th3: (((I is_halting_on ( Initialized S ),P & I is_closed_on ( Initialized S ),P) & J is_closed_on ( IExec (I,P,S) ),P) implies ( I ';' J ) is_closed_on ( Initialized S ),P)
proof
assume that
A1: I is_halting_on ( Initialized S ),P
and
A2: I is_closed_on ( Initialized S ),P
and
A3: J is_closed_on ( IExec (I,P,S) ),P;
set IS = ( Initialized S );
set PS = P;
set s = ( Initialize IS );
set p = ( P +* ( I ';' J ) );
A6: ( I ';' J ) c= p by FUNCT_4:25;
A7: ( Directed I ) c= ( I ';' J ) by SCMFSA6A:16;
( I ';' J ) c= p by FUNCT_4:25;
then ( Directed I ) c= p by A7,XBOOLE_1:1;
then A8: ( p +* ( Directed I ) ) = p by FUNCT_4:98;
A9: ( DataPart IS ) = ( DataPart s ) by MEMSTR_0:79;
then A10: I is_closed_on s,p by A2,SCMFSA8B:3;
A11: I is_halting_on s,p by A1,A2,A9,SCMFSA8B:5;
then A12: ( p +* I ) halts_on ( Initialize s ) by SCMFSA7B:def 7;
set s1 = ( Initialize s );
set p1 = ( p +* I );
set JAt = ( Start-At (( 0 ),( SCM+FSA )) );
set s3 = ( Initialize ( Comput (p1,s1,( LifeSpan (p1,s1) )) ) );
set p3 = ( p1 +* J );
A13: J c= p3 by FUNCT_4:25;
set m1 = ( LifeSpan (p1,s1) );
set IJ = ( I ';' J );
A15: ( IS . ( intloc ( 0 ) ) ) = 1 by SCMFSA6A:38;
then ( s . ( intloc ( 0 ) ) ) = 1 by A9,SCMFSA6A:7;
then A16: ( Initialized s1 ) = s by SCMFSA8C:4;
( DataPart ( IExec (I,P,S) ) ) = ( DataPart ( IExec (I,P,IS) ) ) by SCMFSA8C:3
.= ( DataPart ( IExec (I,p,s) ) ) by A1,A2,A9,A15,SCMFSA8C:20
.= ( DataPart ( Result (( p +* I ),( Initialized s )) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Comput (p1,s1,( LifeSpan (p1,s1) )) ) ) by A16,A12,EXTPRO_1:23;
then ( DataPart ( IExec (I,P,S) ) ) = ( DataPart s3 ) by MEMSTR_0:79;
then A17: J is_closed_on s3,p3 by A3,SCMFSA8B:3;
set PPR = ( Reloc (J,( card I )) );
set s4 = ( Comput (p,s,( m1 + 1 )) );
reconsider kk = ( DataPart JAt ) as Function;
A18: ( DataPart s3 ) = ( ( DataPart ( Comput (p1,s1,m1) ) ) +* kk ) by FUNCT_4:71;
let k being (Element of ( NAT ));
( IC ( Comput (( p +* ( Directed I ) ),s,( ( LifeSpan (( p +* I ),( Initialize s )) ) + 1 )) ) ) = ( card I ) by A10,A11,SCMFSA8A:22;
then A22: ( IC s4 ) = ( card I ) by A8;
( DataPart JAt ) = ( {} ) by MEMSTR_0:20;
then ( DataPart ( Comput (p1,s1,m1) ) ) = ( DataPart s3 ) by A18,FUNCT_4:98,XBOOLE_1:2;
then A23: ( DataPart s4 ) = ( DataPart s3 ) by A10,A11,A8,SCMFSA8A:22;
A24: PPR c= ( I ';' J ) by FUNCT_4:25;
A25: PPR c= p by A6,A24,XBOOLE_1:1;
per cases  by NAT_1:13;
suppose A26: k <= m1;

A27: ( dom I ) c= ( dom IJ ) by SCMFSA6A:17;
A28: ( IC ( Comput (p1,s1,k) ) ) in ( dom I ) by A10,SCMFSA7B:def 6;
( Comput (p1,s1,k) ) = ( Comput (p,s,k) ) by A10,A11,A26,A8,SCMFSA8A:21;
then ( IC ( Comput (p1,s1,k) ) ) = ( IC ( Comput (p,s,k) ) );
hence thesis by A28,A27;
end;
suppose ( m1 + 1 ) <= k;

then consider i being Nat such that A29: k = ( ( m1 + 1 ) + i ) by NAT_1:10;
reconsider i as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider jloc = ( IC ( Comput (p3,s3,i) ) ) as (Element of ( NAT ));
A30: s3 = ( Initialize s3 );
( p3 +* J ) = p3 by FUNCT_4:93;
then A31: ( IC ( Comput (p3,s3,i) ) ) in ( dom J ) by A17,A30,SCMFSA7B:def 6;
( dom PPR ) = { ( j + ( card I ) ) where j is (Element of ( NAT )): j in ( dom J ) } by COMPOS_1:33;
then A32: ( jloc + ( card I ) ) in ( dom PPR ) by A31;
A33: ( dom PPR ) c= ( dom IJ ) by A24,RELAT_1:11;
( ( IC ( Comput (p3,s3,i) ) ) + ( card I ) ) = ( IC ( Comput (p,( Comput (p,s,( m1 + 1 )) ),i) ) ) by A22,A23,A17,A13,A25,SCMFSA8C:16
.= ( IC ( Comput (p,s,( ( m1 + 1 ) + i )) ) ) by EXTPRO_1:4;
hence thesis by A29,A32,A33;
end;
end;
