environ
vocabularies AMI_1,SCMFSA_2,SCMFSA7B,SCMFSA6A,SF_MASTR,GRAPHSP,AMI_3,SCMFSA6B,TURING_1,AOFA_I00,SCMFSA8C,SCMFSA8B,SCMFSA8A,CARD_1,AMISTD_2,RELAT_1,TARSKI,XXREAL_0,ARYTM_3,FSM_1,XBOOLE_0,FUNCT_4,NUMBERS,SCMFSA6C,UNIALG_2,CIRCUIT2,FUNCT_1,MSUALG_1,SUBSET_1,NAT_1,STRUCT_0,FINSET_1,SCMFSA_1,ZFMISC_1,SCMNORM,PRE_FF,ARYTM_1,SFMASTR1,PARTFUN1,RELOC,PBOOLE,FUNCOP_1,COMPOS_1;
notations TARSKI,XBOOLE_0,ENUMSET1,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,FINSET_1,NAT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,FUNCOP_1,PBOOLE,FUNCT_7,PRE_FF,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_1,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,XXREAL_0,SEQ_4,CKB1,CKB38,CKB39,CKB40,CKB41;
definitions EXTPRO_1,COMPOS_1,SCMFSA_2,SCMFSA7B,FUNCOP_1,SCMFSA6A,MEMSTR_0,CKB1;
theorems TARSKI,ZFMISC_1,ENUMSET1,NAT_1,RELAT_1,FUNCT_1,FUNCT_2,LATTICE2,GRFUNC_1,SUBSET_1,FUNCT_4,PRE_FF,SCMFSA_2,MEMSTR_0,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,FUNCOP_1,XXREAL_0,AMI_3,XXREAL_2,PBOOLE,PARTFUN1,COMPOS_1,EXTPRO_1,AMISTD_2,CKB1,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37;
schemes NAT_1,DOMAIN_1,FRAENKEL,RECDEF_1;
registrations XBOOLE_0,SUBSET_1,SETFAM_1,FUNCT_1,ORDINAL1,FINSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,MEMBERED,AMI_5,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8C,SCMFSA_9,XXREAL_2,RELAT_1,SCMFSA10,AMISTD_2,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,FUNCOP_1,SCMFSA6A,STRUCT_0,MEMSTR_0,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
constructors DOMAIN_1,SETWISEO,SEQ_4,PRE_FF,SCM_1,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA8C,RELSET_1,PRE_POLY,AMISTD_2,SCMFSA7B,SCMFSA_1,PBOOLE,AMISTD_1,COMPLEX1,INT_2,NAT_D,XXREAL_1,MEMSTR_0,CKB1,CKB38,CKB39,CKB40,CKB41;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve i for  good  parahalting (Instruction of ( SCM+FSA ));
reserve f for FinSeq-Location;
reserve L for  finite (Subset of ( Int-Locations ));
reserve n for (Element of ( NAT ));
definition
let L being  finite (Subset of ( Int-Locations ));
func RWNotIn-seq L -> (Function of ( NAT ),( bool ( NAT ) )) means 
:Def2: ((( it . ( 0 ) ) = { k where k is (Element of ( NAT )): ((not ( intloc k ) in L) & k <> ( 0 )) } & (for i being (Element of ( NAT )) holds (for sn being non  empty (Subset of ( NAT )) holds (( it . i ) = sn implies ( it . ( i + 1 ) ) = ( sn \ { ( min sn ) } ))))) & (for i being (Element of ( NAT )) holds ( it . i ) is  infinite));
existence
proof
set M = ( L \/ { ( intloc ( 0 ) ) } );
defpred X[ (Element of ( NAT )) ]
 means
((not ( intloc $1 ) in L) & $1 <> ( 0 ));
set sn = { k where k is (Element of ( NAT )): X[ k ] };
A1: sn is (Subset of ( NAT )) from DOMAIN_1:sch 7;
(not ( Int-Locations ) c= M) by AMI_3:27;
then consider x being set such that A2: x in ( Int-Locations ) and A3: (not x in M) by TARSKI:def 3;
reconsider x as Int-Location by A2,SCMFSA_2:4;
consider k being (Element of ( NAT )) such that A4: x = ( intloc k ) by SCMFSA_2:8;
(not ( intloc k ) in { ( intloc ( 0 ) ) }) by A3,A4,XBOOLE_0:def 3;
then A5: k <> ( 0 ) by TARSKI:def 1;
(not ( intloc k ) in L) by A3,A4,XBOOLE_0:def 3;
then k in sn by A5;
then reconsider sn as non  empty (Subset of ( NAT )) by A1;
defpred P[ (Element of ( NAT )),(Subset of ( NAT )),(Subset of ( NAT )) ]
 means
(for N being non  empty (Subset of ( NAT )) holds (N = $2 implies $3 = ( $2 \ { ( min N ) } )));
A6:now
let n being (Element of ( NAT ));
let x being (Subset of ( NAT ));
per cases ;
suppose x is  empty;

then P[ n,x,( {} ( NAT ) ) ];
hence (ex y being (Subset of ( NAT )) st P[ n,x,y ]);
end;
suppose x is non  empty;

then reconsider x9 = x as non  empty (Subset of ( NAT ));
now
reconsider mx9 = { ( min x9 ) } as (Subset of ( NAT )) by ZFMISC_1:31;
reconsider t = ( x9 \ mx9 ) as (Subset of ( NAT ));
take t;
let N being non  empty (Subset of ( NAT ));
assume N = x;
hence t = ( x \ { ( min N ) } );
end;
hence (ex y being (Subset of ( NAT )) st P[ n,x,y ]);
end;
end;
consider f being (Function of ( NAT ),( bool ( NAT ) )) such that A7: ( f . ( 0 ) ) = sn and A8: (for n being (Element of ( NAT )) holds P[ n,( f . n ),( f . ( n + 1 ) ) ]) from RECDEF_1:sch 2(A6);
take f;
thus ( f . ( 0 ) ) = { v where v is (Element of ( NAT )): ((not ( intloc v ) in L) & v <> ( 0 )) } by A7;
thus (for i being (Element of ( NAT )) holds (for sn being non  empty (Subset of ( NAT )) holds (( f . i ) = sn implies ( f . ( i + 1 ) ) = ( sn \ { ( min sn ) } )))) by A8;
defpred X[ (Element of ( NAT )) ]
 means
( f . $1 ) is  infinite;
A9: X[ ( 0 ) ]
proof
deffunc U((Element of ( NAT ))) = ( intloc $1 );
set Isn = { U(v) where v is (Element of ( NAT )): v in sn };
assume ( f . ( 0 ) ) is  finite;
then A10: sn is  finite by A7;
Isn is  finite from FRAENKEL:sch 21(A10);
then reconsider Isn as  finite set;
now
let x being set;
hereby
assume A11: x in ( M \/ Isn );
per cases  by A11,XBOOLE_0:def 3;
suppose x in M;

hence x in ( Int-Locations );
end;
suppose x in Isn;

then (ex k being (Element of ( NAT )) st (( intloc k ) = x & k in sn));
hence x in ( Int-Locations ) by SCMFSA_2:def 4;
end;
end;
assume x in ( Int-Locations );
then reconsider x9 = x as Int-Location by SCMFSA_2:4;
consider i being (Element of ( NAT )) such that A12: x9 = ( intloc i ) by SCMFSA_2:8;
now
assume A13: (not x in M);
then (not x9 in { ( intloc ( 0 ) ) }) by XBOOLE_0:def 3;
then A14: i <> ( 0 ) by A12,TARSKI:def 1;
(not ( intloc i ) in L) by A12,A13,XBOOLE_0:def 3;
then i in sn by A14;
hence x in Isn by A12;
end;
hence x in ( M \/ Isn ) by XBOOLE_0:def 3;
end;
hence contradiction by AMI_3:27,TARSKI:1;
end;
A15: (for n holds (X[ n ] implies X[ ( n + 1 ) ]))
proof
let n;
assume A16: ( f . n ) is  infinite;
then reconsider sn = ( f . n ) as non  empty (Subset of ( NAT ));
( min sn ) in sn by XXREAL_2:def 7;
then A17: { ( min sn ) } c= sn by ZFMISC_1:31;
assume ( f . ( n + 1 ) ) is  finite;
then reconsider sn1 = ( f . ( n + 1 ) ) as  finite set;
A18: ( sn1 \/ { ( min sn ) } ) is  finite;
( f . ( n + 1 ) ) = ( sn \ { ( min sn ) } ) by A8;
hence contradiction by A16,A17,A18,XBOOLE_1:45;
end;
thus (for n being (Element of ( NAT )) holds X[ n ]) from NAT_1:sch 1(A9,A15);
end;
uniqueness
proof
let IT1 being (Function of ( NAT ),( bool ( NAT ) ));
let IT2 being (Function of ( NAT ),( bool ( NAT ) ));
assume that
A19: ( IT1 . ( 0 ) ) = { k where k is (Element of ( NAT )): ((not ( intloc k ) in L) & k <> ( 0 )) }
and
A20: (for i being (Element of ( NAT )) holds (for sn being non  empty (Subset of ( NAT )) holds (( IT1 . i ) = sn implies ( IT1 . ( i + 1 ) ) = ( sn \ { ( min sn ) } ))))
and
(for i being (Element of ( NAT )) holds ( IT1 . i ) is  infinite)
and
A21: ( IT2 . ( 0 ) ) = { k where k is (Element of ( NAT )): ((not ( intloc k ) in L) & k <> ( 0 )) }
and
A22: (for i being (Element of ( NAT )) holds (for sn being non  empty (Subset of ( NAT )) holds (( IT2 . i ) = sn implies ( IT2 . ( i + 1 ) ) = ( sn \ { ( min sn ) } ))))
and
A23: (for i being (Element of ( NAT )) holds ( IT2 . i ) is  infinite);
now
defpred X[ (Element of ( NAT )) ]
 means
( IT1 . $1 ) = ( IT2 . $1 );
thus ( NAT ) = ( dom IT1 ) by FUNCT_2:def 1;
thus ( NAT ) = ( dom IT2 ) by FUNCT_2:def 1;
A24: (for n holds (X[ n ] implies X[ ( n + 1 ) ]))
proof
let n being (Element of ( NAT ));
assume A25: ( IT1 . n ) = ( IT2 . n );
then reconsider IT1n = ( IT1 . n ) as non  empty (Subset of ( NAT )) by A23;
thus ( IT1 . ( n + 1 ) ) = ( IT1n \ { ( min IT1n ) } ) by A20
.= ( IT2 . ( n + 1 ) ) by A22,A25;
end;
A26: X[ ( 0 ) ] by A19,A21;
(for n being (Element of ( NAT )) holds X[ n ]) from NAT_1:sch 1(A26,A24);
hence (for x being set holds (x in ( NAT ) implies ( IT1 . x ) = ( IT2 . x )));
end;
hence IT1 = IT2 by FUNCT_1:2;
end;
end;
