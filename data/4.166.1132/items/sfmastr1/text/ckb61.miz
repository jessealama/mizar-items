environ
vocabularies AMI_1,SCMFSA_2,SCMFSA7B,SCMFSA6A,SF_MASTR,GRAPHSP,AMI_3,SCMFSA6B,TURING_1,AOFA_I00,SCMFSA8C,SCMFSA8B,SCMFSA8A,CARD_1,AMISTD_2,RELAT_1,TARSKI,XXREAL_0,ARYTM_3,FSM_1,XBOOLE_0,FUNCT_4,NUMBERS,SCMFSA6C,UNIALG_2,CIRCUIT2,FUNCT_1,MSUALG_1,SUBSET_1,NAT_1,STRUCT_0,FINSET_1,SCMFSA_1,ZFMISC_1,SCMNORM,PRE_FF,ARYTM_1,SFMASTR1,PARTFUN1,RELOC,PBOOLE,FUNCOP_1,COMPOS_1;
notations TARSKI,XBOOLE_0,ENUMSET1,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,FINSET_1,NAT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,FUNCOP_1,PBOOLE,FUNCT_7,PRE_FF,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_1,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,XXREAL_0,SEQ_4,CKB1,CKB38,CKB39,CKB40,CKB41,CKB42,CKB47,CKB48,CKB49,CKB50,CKB54,CKB55,CKB56,CKB57,CKB60;
definitions EXTPRO_1,COMPOS_1,SCMFSA_2,SCMFSA7B,FUNCOP_1,SCMFSA6A,MEMSTR_0,CKB1,CKB42,CKB47,CKB54,CKB60;
theorems TARSKI,ZFMISC_1,ENUMSET1,NAT_1,RELAT_1,FUNCT_1,FUNCT_2,LATTICE2,GRFUNC_1,SUBSET_1,FUNCT_4,PRE_FF,SCMFSA_2,MEMSTR_0,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,FUNCOP_1,XXREAL_0,AMI_3,XXREAL_2,PBOOLE,PARTFUN1,COMPOS_1,EXTPRO_1,AMISTD_2,CKB1,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB42,CKB44,CKB45,CKB46,CKB47,CKB52,CKB53,CKB54,CKB59,CKB60;
schemes NAT_1,DOMAIN_1,FRAENKEL,RECDEF_1;
registrations XBOOLE_0,SUBSET_1,SETFAM_1,FUNCT_1,ORDINAL1,FINSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,MEMBERED,AMI_5,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8C,SCMFSA_9,XXREAL_2,RELAT_1,SCMFSA10,AMISTD_2,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,FUNCOP_1,SCMFSA6A,STRUCT_0,MEMSTR_0,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB43,CKB51,CKB58;
constructors DOMAIN_1,SETWISEO,SEQ_4,PRE_FF,SCM_1,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA8C,RELSET_1,PRE_POLY,AMISTD_2,SCMFSA7B,SCMFSA_1,PBOOLE,AMISTD_1,COMPLEX1,INT_2,NAT_D,XXREAL_1,MEMSTR_0,CKB1,CKB38,CKB39,CKB40,CKB41,CKB42,CKB47,CKB54,CKB60;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve p for (Instruction-Sequence of ( SCM+FSA ));
reserve s for (State of ( SCM+FSA ));
reserve m for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
theorem
(for N,result being  read-write Int-Location holds (N <> result implies (for n being (Element of ( NAT )) holds (n = ( s . N ) implies (( ( IExec (( Fib_macro (N,result) ),p,s) ) . result ) = ( Fib n ) & ( ( IExec (( Fib_macro (N,result) ),p,s) ) . N ) = ( s . N ))))))
proof
let N being  read-write Int-Location;
let result being  read-write Int-Location;
assume that
A1: N <> result;
set i0 = ( SubFrom (result,result) );
set next = ( 1 -stRWNotIn { N,result } );
set aux = ( 1 -stRWNotIn ( UsedIntLoc ( swap (result,next) ) ) );
set Nsave = ( 2 -ndRWNotIn ( UsedIntLoc ( swap (result,next) ) ) );
set i00 = ( Nsave := N );
set i1 = ( next := ( intloc ( 0 ) ) );
set i2 = ( aux := Nsave );
set i30 = ( AddTo (result,next) );
set I31 = ( swap (result,next) );
set i02 = ( ( ( i00 ';' i0 ) ';' i1 ) ';' i2 );
set s1 = ( IExec (i02,p,s) );
set p1 = p;
reconsider I301 = ( i30 ';' I31 ) as  good  parahalting (Program of ( SCM+FSA ));
set I3 = ( Times (aux,I301) );
set i4 = ( N := Nsave );
defpred P[ (Element of ( NAT )) ]
 means
(for s1 being (State of ( SCM+FSA )) holds (($1 = ( s1 . aux ) & ( s1 . ( intloc ( 0 ) ) ) = 1) implies (( ( IExec (I3,p1,s1) ) . Nsave ) = ( s1 . Nsave ) & (for m being (Element of ( NAT )) holds ((( s1 . result ) = ( Fib m ) & ( s1 . next ) = ( Fib ( m + 1 ) )) implies (( ( IExec (I3,p1,s1) ) . result ) = ( Fib ( m + $1 ) ) & ( ( IExec (I3,p1,s1) ) . next ) = ( Fib ( ( m + 1 ) + $1 ) )))))));
let n being (Element of ( NAT ));
assume that
A2: n = ( s . N );
(not next in { N,result }) by CKB52:1;
then A3: result <> next by TARSKI:def 2;
A4: Nsave <> aux by CKB53:1;
A5: Nsave <> next by CKB52:1,CKB59:1;
A6: Nsave <> result by CKB52:1,CKB59:1;
A7: ( s1 . aux ) = ( ( Exec (i2,( IExec (( ( i00 ';' i0 ) ';' i1 ),p,s) )) ) . aux ) by SCMFSA6C:6
.= ( ( IExec (( ( i00 ';' i0 ) ';' i1 ),p,s) ) . Nsave ) by SCMFSA_2:63
.= ( ( Exec (i1,( IExec (( i00 ';' i0 ),p,s) )) ) . Nsave ) by SCMFSA6C:6
.= ( ( IExec (( i00 ';' i0 ),p,s) ) . Nsave ) by A5,SCMFSA_2:63
.= ( ( Exec (i0,( Exec (i00,( Initialized s )) )) ) . Nsave ) by SCMFSA6C:8
.= ( ( Exec (i00,( Initialized s )) ) . Nsave ) by A6,SCMFSA_2:65
.= ( ( Initialized s ) . N ) by SCMFSA_2:63
.= ( s . N ) by SCMFSA6C:3;
A8: (not I31 destroy aux) by CKB21:1,CKB52:1;
A9: i02 is_closed_on ( Initialized s ),p by SCMFSA7B:18;
A10: ( s1 . Nsave ) = ( ( Exec (i2,( IExec (( ( i00 ';' i0 ) ';' i1 ),p,s) )) ) . Nsave ) by SCMFSA6C:6
.= ( ( IExec (( ( i00 ';' i0 ) ';' i1 ),p,s) ) . Nsave ) by A4,SCMFSA_2:63
.= ( ( Exec (i1,( IExec (( i00 ';' i0 ),p,s) )) ) . Nsave ) by SCMFSA6C:6
.= ( ( IExec (( i00 ';' i0 ),p,s) ) . Nsave ) by A5,SCMFSA_2:63
.= ( ( Exec (i0,( Exec (i00,( Initialized s )) )) ) . Nsave ) by SCMFSA6C:8
.= ( ( Exec (i00,( Initialized s )) ) . Nsave ) by A6,SCMFSA_2:65
.= ( ( Initialized s ) . N ) by SCMFSA_2:63
.= ( s . N ) by SCMFSA6C:3;
A11: i02 is_halting_on ( Initialized s ),p by SCMFSA7B:19;
reconsider i02 as  good (Program of ( SCM+FSA ));
A12: (not aux in ( UsedIntLoc I31 )) by CKB52:1;
A13: result in ( UsedIntLoc I31 ) by CKB59:1;
then (not ( Macro i30 ) destroy aux) by A12,SCMFSA7B:7,SCMFSA8C:48;
then A14: (not I301 destroy aux) by A8,SCMFSA8C:52;
A15: next in ( UsedIntLoc I31 ) by CKB59:1;
A16:now
let n being (Element of ( NAT ));
assume that
A17: P[ n ];
thus P[ ( n + 1 ) ]
proof
let s1 being (State of ( SCM+FSA ));
assume that
A18: ( n + 1 ) = ( s1 . aux )
and
( s1 . ( intloc ( 0 ) ) ) = 1;
set s2 = ( IExec (( I301 ';' ( SubFrom (aux,( intloc ( 0 ) )) ) ),p1,s1) );
set p2 = p1;
A19: ( s1 . aux ) > ( 0 ) by A18,NAT_1:3;
then A20: ( s2 . aux ) = ( ( n + 1 ) - 1 ) by A14,A18,SCMFSA8C:91
.= n;
A21: ( s2 . ( intloc ( 0 ) ) ) = ( ( Exec (( SubFrom (aux,( intloc ( 0 ) )) ),( IExec (I301,p1,s1) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:6
.= ( ( IExec (I301,p1,s1) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:65
.= 1 by SCMFSA6B:11;
A22: ( DataPart ( IExec (I3,p1,s1) ) ) = ( DataPart ( IExec (I3,p2,s2) ) ) by A14,A19,SCMFSA8C:91;
hence ( ( IExec (I3,p1,s1) ) . Nsave ) = ( ( IExec (I3,p2,s2) ) . Nsave ) by SCMFSA6A:7
.= ( s2 . Nsave ) by A17,A20,A21
.= ( ( Exec (( SubFrom (aux,( intloc ( 0 ) )) ),( IExec (I301,p1,s1) )) ) . Nsave ) by SCMFSA6C:6
.= ( ( IExec (I301,p1,s1) ) . Nsave ) by A4,SCMFSA_2:65
.= ( ( IExec (I31,p1,( Exec (i30,( Initialized s1 )) )) ) . Nsave ) by SCMFSA8B:9
.= ( ( Exec (i30,( Initialized s1 )) ) . Nsave ) by CKB52:1,SCMFSA6B:3
.= ( ( Initialized s1 ) . Nsave ) by A6,SCMFSA_2:64
.= ( s1 . Nsave ) by SCMFSA6C:3;
let m being (Element of ( NAT ));
assume that
A23: ( s1 . result ) = ( Fib m )
and
A24: ( s1 . next ) = ( Fib ( m + 1 ) );
A25: ( s2 . next ) = ( ( Exec (( SubFrom (aux,( intloc ( 0 ) )) ),( IExec (I301,p1,s1) )) ) . next ) by SCMFSA6C:6
.= ( ( IExec (I301,p1,s1) ) . next ) by A12,A15,SCMFSA_2:65
.= ( ( IExec (I31,p1,( Exec (i30,( Initialized s1 )) )) ) . next ) by SCMFSA8B:9
.= ( ( Exec (i30,( Initialized s1 )) ) . result ) by SCMFSA6C:10
.= ( ( ( Initialized s1 ) . result ) + ( ( Initialized s1 ) . next ) ) by SCMFSA_2:64
.= ( ( s1 . result ) + ( ( Initialized s1 ) . next ) ) by SCMFSA6C:3
.= ( ( s1 . result ) + ( s1 . next ) ) by SCMFSA6C:3
.= ( Fib ( ( m + 1 ) + 1 ) ) by A23,A24,PRE_FF:1;
A26: ( s2 . result ) = ( ( Exec (( SubFrom (aux,( intloc ( 0 ) )) ),( IExec (I301,p1,s1) )) ) . result ) by SCMFSA6C:6
.= ( ( IExec (I301,p1,s1) ) . result ) by A12,A13,SCMFSA_2:65
.= ( ( IExec (I31,p1,( Exec (i30,( Initialized s1 )) )) ) . result ) by SCMFSA8B:9
.= ( ( Exec (i30,( Initialized s1 )) ) . next ) by SCMFSA6C:10
.= ( ( Initialized s1 ) . next ) by A3,SCMFSA_2:64
.= ( Fib ( m + 1 ) ) by A24,SCMFSA6C:3;
thus ( ( IExec (I3,p1,s1) ) . result ) = ( ( IExec (I3,p2,s2) ) . result ) by A22,SCMFSA6A:7
.= ( Fib ( ( m + 1 ) + n ) ) by A17,A20,A21,A26,A25
.= ( Fib ( m + ( n + 1 ) ) );
thus ( ( IExec (I3,p1,s1) ) . next ) = ( ( IExec (I3,p2,s2) ) . next ) by A22,SCMFSA6A:7
.= ( Fib ( ( ( m + 1 ) + 1 ) + n ) ) by A17,A20,A21,A26,A25
.= ( Fib ( ( m + 1 ) + ( n + 1 ) ) );
end;

end;
A27: ( s1 . result ) = ( ( Exec (i2,( IExec (( ( i00 ';' i0 ) ';' i1 ),p,s) )) ) . result ) by SCMFSA6C:6
.= ( ( IExec (( ( i00 ';' i0 ) ';' i1 ),p,s) ) . result ) by A12,A13,SCMFSA_2:63
.= ( ( Exec (i1,( IExec (( i00 ';' i0 ),p,s) )) ) . result ) by SCMFSA6C:6
.= ( ( IExec (( i00 ';' i0 ),p,s) ) . result ) by A3,SCMFSA_2:63
.= ( ( Exec (i0,( Exec (i00,( Initialized s )) )) ) . result ) by SCMFSA6C:8
.= ( ( ( Exec (i00,( Initialized s )) ) . result ) - ( ( Exec (i00,( Initialized s )) ) . result ) ) by SCMFSA_2:65
.= ( Fib ( 0 ) ) by PRE_FF:1;
A28: ( s1 . next ) = ( ( Exec (i2,( IExec (( ( i00 ';' i0 ) ';' i1 ),p,s) )) ) . next ) by SCMFSA6C:6
.= ( ( IExec (( ( i00 ';' i0 ) ';' i1 ),p,s) ) . next ) by A12,A15,SCMFSA_2:63
.= ( ( Exec (i1,( IExec (( i00 ';' i0 ),p,s) )) ) . next ) by SCMFSA6C:6
.= ( ( IExec (( i00 ';' i0 ),p,s) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= ( ( Exec (i0,( Exec (i00,( Initialized s )) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:8
.= ( ( Exec (i00,( Initialized s )) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:65
.= ( ( Initialized s ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= ( Fib ( ( 0 ) + 1 ) ) by PRE_FF:1,SCMFSA6A:38;
A29: ( s1 . ( intloc ( 0 ) ) ) = ( ( Exec (i2,( IExec (( ( i00 ';' i0 ) ';' i1 ),p,s) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:6
.= ( ( IExec (( ( i00 ';' i0 ) ';' i1 ),p,s) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= ( ( Exec (i1,( IExec (( i00 ';' i0 ),p,s) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:6
.= ( ( IExec (( i00 ';' i0 ),p,s) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= ( ( Exec (i0,( Exec (i00,( Initialized s )) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:8
.= ( ( Exec (i00,( Initialized s )) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:65
.= ( ( Initialized s ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= 1 by SCMFSA6A:38;
then A30: I3 is_closed_on s1,p1 by A14,SCMFSA8C:86;
A31: P[ ( 0 ) ]
proof
let s1 being (State of ( SCM+FSA ));
assume that
A32: ( 0 ) = ( s1 . aux )
and
A33: ( s1 . ( intloc ( 0 ) ) ) = 1;
A34: ( DataPart ( IExec (I3,p1,s1) ) ) = ( DataPart s1 ) by A32,A33,SCMFSA8C:90;
hence ( ( IExec (I3,p1,s1) ) . Nsave ) = ( s1 . Nsave ) by SCMFSA6A:7;
let m being (Element of ( NAT ));
assume that
A35: ( s1 . result ) = ( Fib m )
and
A36: ( s1 . next ) = ( Fib ( m + 1 ) );
thus ( ( IExec (I3,p1,s1) ) . result ) = ( Fib ( m + ( 0 ) ) ) by A34,A35,SCMFSA6A:7;
thus thesis by A34,A36,SCMFSA6A:7;
end;
A37: (for n being (Element of ( NAT )) holds P[ n ]) from NAT_1:sch 1(A31,A16);
A38: I3 is_halting_on s1,p1 by A14,A29,SCMFSA8C:86;
A39: ( i02 ';' I3 ) is_closed_on ( Initialized s ),p by A11,A30,A9,CKB22:1;
hence ( ( IExec (( Fib_macro (N,result) ),p,s) ) . result ) = ( ( Exec (i4,( IExec (( i02 ';' I3 ),p,s) )) ) . result ) by A11,A30,A38,A9,CKB23:1,CKB32:1
.= ( ( IExec (( i02 ';' I3 ),p,s) ) . result ) by A1,SCMFSA_2:63
.= ( ( IExec (I3,p1,s1) ) . result ) by A30,A38,CKB28:1
.= ( Fib ( ( 0 ) + n ) ) by A37,A29,A27,A28,A7,A2
.= ( Fib n );
thus ( ( IExec (( Fib_macro (N,result) ),p,s) ) . N ) = ( ( Exec (i4,( IExec (( i02 ';' I3 ),p,s) )) ) . N ) by A11,A30,A38,A9,A39,CKB23:1,CKB32:1
.= ( ( IExec (( i02 ';' I3 ),p,s) ) . Nsave ) by SCMFSA_2:63
.= ( ( IExec (I3,p1,s1) ) . Nsave ) by A30,A38,CKB28:1
.= ( s . N ) by A37,A29,A10,A7,A2;
end;
