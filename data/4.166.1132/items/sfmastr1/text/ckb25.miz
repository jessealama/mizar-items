environ
vocabularies AMI_1,SCMFSA_2,SCMFSA7B,SCMFSA6A,SF_MASTR,GRAPHSP,AMI_3,SCMFSA6B,TURING_1,AOFA_I00,SCMFSA8C,SCMFSA8B,SCMFSA8A,CARD_1,AMISTD_2,RELAT_1,TARSKI,XXREAL_0,ARYTM_3,FSM_1,XBOOLE_0,FUNCT_4,NUMBERS,SCMFSA6C,UNIALG_2,CIRCUIT2,FUNCT_1,MSUALG_1,SUBSET_1,NAT_1,STRUCT_0,FINSET_1,SCMFSA_1,ZFMISC_1,SCMNORM,PRE_FF,ARYTM_1,SFMASTR1,PARTFUN1,RELOC,PBOOLE,FUNCOP_1,COMPOS_1;
notations TARSKI,XBOOLE_0,ENUMSET1,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,FINSET_1,NAT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,FUNCOP_1,PBOOLE,FUNCT_7,PRE_FF,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_1,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,XXREAL_0,SEQ_4,CKB1;
definitions EXTPRO_1,COMPOS_1,SCMFSA_2,SCMFSA7B,FUNCOP_1,SCMFSA6A,MEMSTR_0,CKB1;
theorems TARSKI,ZFMISC_1,ENUMSET1,NAT_1,RELAT_1,FUNCT_1,FUNCT_2,LATTICE2,GRFUNC_1,SUBSET_1,FUNCT_4,PRE_FF,SCMFSA_2,MEMSTR_0,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,FUNCOP_1,XXREAL_0,AMI_3,XXREAL_2,PBOOLE,PARTFUN1,COMPOS_1,EXTPRO_1,AMISTD_2,CKB1,CKB21,CKB22,CKB23,CKB24;
schemes NAT_1,DOMAIN_1,FRAENKEL,RECDEF_1;
registrations XBOOLE_0,SUBSET_1,SETFAM_1,FUNCT_1,ORDINAL1,FINSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,MEMBERED,AMI_5,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8C,SCMFSA_9,XXREAL_2,RELAT_1,SCMFSA10,AMISTD_2,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,FUNCOP_1,SCMFSA6A,STRUCT_0,MEMSTR_0,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
constructors DOMAIN_1,SETWISEO,SEQ_4,PRE_FF,SCM_1,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA8C,RELSET_1,PRE_POLY,AMISTD_2,SCMFSA7B,SCMFSA_1,PBOOLE,AMISTD_1,COMPLEX1,INT_2,NAT_D,XXREAL_1,MEMSTR_0,CKB1;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve p for (Instruction-Sequence of ( SCM+FSA ));
reserve s for (State of ( SCM+FSA ));
reserve I for (Program of ( SCM+FSA ));
reserve J for (Program of ( SCM+FSA ));
set D = ( Data-Locations ( SCM+FSA ) );
set SAt = ( Start-At (( 0 ),( SCM+FSA )) );
theorem
Lm1: (for I being  good (Program of ( SCM+FSA )) holds (for J being (Program of ( SCM+FSA )) holds (for s being (State of ( SCM+FSA )) holds (((((((( s . ( intloc ( 0 ) ) ) = 1 & I is_halting_on s,p) & J is_halting_on ( IExec (I,p,s) ),p) & I is_closed_on s,p) & J is_closed_on ( IExec (I,p,s) ),p) & ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= s) & ( I ';' J ) c= p) implies ((((((( IC ( Comput (p,s,( ( LifeSpan (( p +* I ),s) ) + 1 )) ) ) = ( card I ) & ( DataPart ( Comput (p,s,( ( LifeSpan (( p +* I ),s) ) + 1 )) ) ) = ( DataPart ( Initialized ( Comput (( p +* I ),s,( LifeSpan (( p +* I ),s) )) ) ) )) & ( Reloc (J,( card I )) ) c= p) & ( ( Comput (p,s,( ( LifeSpan (( p +* I ),s) ) + 1 )) ) . ( intloc ( 0 ) ) ) = 1) & p halts_on s) & ( LifeSpan (p,s) ) = ( ( ( LifeSpan (( p +* I ),s) ) + 1 ) + ( LifeSpan (( ( p +* I ) +* J ),( Initialized ( Result (( p +* I ),s) ) )) ) )) & (J is  good implies ( ( Result (p,s) ) . ( intloc ( 0 ) ) ) = 1))))))
proof
let I being  good (Program of ( SCM+FSA ));
let J being (Program of ( SCM+FSA ));
let s being (State of ( SCM+FSA ));
assume that
A1: ( s . ( intloc ( 0 ) ) ) = 1
and
A2: I is_halting_on s,p
and
A3: J is_halting_on ( IExec (I,p,s) ),p
and
A4: I is_closed_on s,p
and
A5: J is_closed_on ( IExec (I,p,s) ),p;
set s1 = s;
set p1 = ( p +* I );
set m1 = ( LifeSpan (p1,s1) );
set s4 = ( Comput (p,s,( m1 + 1 )) );
set p4 = p;
assume A10: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= s;
then ( Start-At (( 0 ),( SCM+FSA )) ) c= s by MEMSTR_0:50;
then A11: SAt c= s;
A12: s = ( s +* SAt ) by A11,FUNCT_4:98
.= ( Initialize s );
then A13: ( p +* I ) halts_on s by A2,SCMFSA7B:def 7;
assume A14: ( I ';' J ) c= p;
( Directed I ) c= ( I ';' J ) by SCMFSA6A:16;
then ( Directed I ) c= p by A14,XBOOLE_1:1;
then A15: ( p +* ( Directed I ) ) = p by FUNCT_4:98;
( Start-At (( 0 ),( SCM+FSA )) ) c= s by A10,MEMSTR_0:50;
then ( Start-At (( 0 ),( SCM+FSA )) ) c= s;
then s = ( Initialize s ) by FUNCT_4:98;
hence A17: ( IC s4 ) = ( card I ) by A2,A4,A15,SCMFSA8A:22;
set JAt = ( Start-At (( 0 ),( SCM+FSA )) );
set InJ = ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) );
set s3 = ( Initialized ( Comput (p1,s1,m1) ) );
set p3 = ( p1 +* J );
A18: J c= p3 by FUNCT_4:25;
reconsider kk = ( DataPart JAt ) as Function;
A19: ( DataPart JAt ) = ( {} ) by MEMSTR_0:20;
( ( Comput (p1,s1,m1) ) . ( intloc ( 0 ) ) ) = ( s . ( intloc ( 0 ) ) ) by A4,A12,SCMFSA8C:68;
then A20: s3 = ( Initialize ( Comput (p1,s1,m1) ) ) by A1,SCMFSA8C:4;
then ( DataPart s3 ) = ( ( DataPart ( Comput (p1,s1,m1) ) ) +* kk ) by FUNCT_4:71;
then ( DataPart ( Comput (p1,s1,m1) ) ) = ( DataPart s3 ) by A19,FUNCT_4:98,XBOOLE_1:2;
hence A21: ( DataPart s4 ) = ( DataPart s3 ) by A2,A4,A12,A15,SCMFSA8A:22;
A22: ( Reloc (J,( card I )) ) c= ( I ';' J ) by FUNCT_4:25;
A23: ( intloc ( 0 ) ) in ( dom InJ ) by SCMFSA6A:41;
A24: s1 = ( s +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by A10,FUNCT_4:98;
A25: ( DataPart ( IExec (I,p,s) ) ) = ( DataPart ( Result (( p +* I ),( Initialized s )) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Comput (p1,s1,( LifeSpan (p1,s1) )) ) ) by A13,A24,EXTPRO_1:23;
then J is_halting_on ( Comput (p1,s1,( LifeSpan (p1,s1) )) ),p1 by A3,A5,SCMFSA8B:5;
then A26: p3 halts_on s3 by A20,SCMFSA7B:def 7;
( I ';' J ) c= p by A14;
then ( Reloc (J,( card I )) ) c= p by A22,XBOOLE_1:1;
then ( Reloc (J,( card I )) ) c= p;
hence ( Reloc (J,( card I )) ) c= p;
A27: ( Reloc (J,( card I )) ) c= p by A14,A22,XBOOLE_1:1;
( intloc ( 0 ) ) in ( Int-Locations ) by SCMFSA_2:def 4;
then A28: ( intloc ( 0 ) ) in D by SCMFSA_2:100,XBOOLE_0:def 3;
hence ( s4 . ( intloc ( 0 ) ) ) = ( ( DataPart s3 ) . ( intloc ( 0 ) ) ) by A21,FUNCT_1:49
.= ( s3 . ( intloc ( 0 ) ) ) by A28,FUNCT_1:49
.= 1 by SCMFSA6A:43,A23,FUNCT_4:13;
set m3 = ( LifeSpan (p3,s3) );
reconsider m = ( ( m1 + 1 ) + m3 ) as (Element of ( NAT ));
A33: ( DataPart ( IExec (I,p,s) ) ) = ( DataPart s3 ) by A20,A25,MEMSTR_0:79;
then A34: J is_closed_on s3,p3 by A5,SCMFSA8B:3;
A35: ( Comput (p,s,( ( m1 + 1 ) + m3 )) ) = ( Comput (p,( Comput (p,s,( m1 + 1 )) ),m3) ) by EXTPRO_1:4;
( IncAddr (( CurInstr (p3,( Comput (p3,s3,m3) )) ),( card I )) ) = ( CurInstr (p,( Comput (p,s4,m3) )) ) by A34,A17,A21,A27,A18,SCMFSA8C:16;
then ( IncAddr (( CurInstr (p3,( Comput (p3,s3,m3) )) ),( card I )) ) = ( CurInstr (p,( Comput (p,s,( ( m1 + 1 ) + m3 )) )) ) by A35;
then A37: ( CurInstr (p,( Comput (p,s,m) )) ) = ( IncAddr (( halt ( SCM+FSA ) ),( card I )) ) by A26,EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_1:11;
hence A38: p halts_on s by EXTPRO_1:29;
A39:now
let k being (Element of ( NAT ));
assume ( ( m1 + 1 ) + k ) < m;
then A40: k < m3 by XREAL_1:6;
A41: ( Comput (p,s,( ( m1 + 1 ) + k )) ) = ( Comput (p,( Comput (p,s,( m1 + 1 )) ),k) ) by EXTPRO_1:4;
assume A42: ( CurInstr (p,( Comput (p,s,( ( m1 + 1 ) + k )) )) ) = ( halt ( SCM+FSA ) );
( IncAddr (( CurInstr (p3,( Comput (p3,s3,k) )) ),( card I )) ) = ( halt ( SCM+FSA ) ) by A42,A41,A34,A17,A21,A27,A18,SCMFSA8C:16;
then ( InsCode ( CurInstr (p3,( Comput (p3,s3,k) )) ) ) = ( 0 ) by COMPOS_1:def 17,SCMFSA_2:97;
then ( CurInstr (p3,( Comput (p3,s3,k) )) ) = ( halt ( SCM+FSA ) ) by SCMFSA_2:95;
hence contradiction by A26,A40,EXTPRO_1:def 15;
end;
now
let k being (Element of ( NAT ));
assume A43: k < m;
per cases ;
suppose k <= m1;

hence ( CurInstr (p,( Comput (p,s,k) )) ) <> ( halt ( SCM+FSA ) ) by A2,A4,A12,A15,SCMFSA8A:21;
end;
suppose m1 < k;

then ( m1 + 1 ) <= k by NAT_1:13;
then consider kk being Nat such that A44: ( ( m1 + 1 ) + kk ) = k by NAT_1:10;
reconsider kk as (Element of ( NAT )) by ORDINAL1:def 12;
( ( m1 + 1 ) + kk ) = k by A44;
hence ( CurInstr (p,( Comput (p,s,k) )) ) <> ( halt ( SCM+FSA ) ) by A39,A43;
end;
end;
then (for k being (Element of ( NAT )) holds (( CurInstr (p,( Comput (p,s,k) )) ) = ( halt ( SCM+FSA ) ) implies m <= k));
then A45: ( LifeSpan (p,s) ) = m by A37,A38,EXTPRO_1:def 15;
( Comput (( p +* I ),s,m1) ) = ( Result (( p +* I ),s) ) by A13,EXTPRO_1:23;
hence ( LifeSpan (p,s) ) = ( ( ( LifeSpan (( p +* I ),s) ) + 1 ) + ( LifeSpan (( ( p +* I ) +* J ),( Initialized ( Result (( p +* I ),s) ) )) ) ) by A45;
( Start-At (( 0 ),( SCM+FSA )) ) c= s3 by FUNCT_4:25,MEMSTR_0:50;
then A46: ( Initialize s3 ) = s3 by FUNCT_4:98;
A47: InJ c= s3 by FUNCT_4:25;
hereby
A48: ( DataPart ( Comput (p3,s3,m3) ) ) = ( DataPart ( Comput (p,s4,m3) ) ) by A34,A17,A21,A27,A18,SCMFSA8C:16;
assume A49: J is  good;
thus ( ( Result (p,s) ) . ( intloc ( 0 ) ) ) = ( ( Comput (p,s,m) ) . ( intloc ( 0 ) ) ) by A38,A45,EXTPRO_1:23
.= ( ( Comput (p,s4,m3) ) . ( intloc ( 0 ) ) ) by EXTPRO_1:4
.= ( ( Comput (p3,s3,m3) ) . ( intloc ( 0 ) ) ) by A48,SCMFSA6A:7
.= ( s3 . ( intloc ( 0 ) ) ) by A5,A33,A46,A49,SCMFSA8B:3,SCMFSA8C:68
.= 1 by SCMFSA6A:43,A23,A47,GRFUNC_1:2;
end;
end;
