environ
vocabularies AMI_1,SCMFSA_2,SCMFSA7B,SCMFSA6A,SF_MASTR,GRAPHSP,AMI_3,SCMFSA6B,TURING_1,AOFA_I00,SCMFSA8C,SCMFSA8B,SCMFSA8A,CARD_1,AMISTD_2,RELAT_1,TARSKI,XXREAL_0,ARYTM_3,FSM_1,XBOOLE_0,FUNCT_4,NUMBERS,SCMFSA6C,UNIALG_2,CIRCUIT2,FUNCT_1,MSUALG_1,SUBSET_1,NAT_1,STRUCT_0,FINSET_1,SCMFSA_1,ZFMISC_1,SCMNORM,PRE_FF,ARYTM_1,SFMASTR1,PARTFUN1,RELOC,PBOOLE,FUNCOP_1,COMPOS_1;
notations TARSKI,XBOOLE_0,ENUMSET1,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,FINSET_1,NAT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,FUNCOP_1,PBOOLE,FUNCT_7,PRE_FF,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_1,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,XXREAL_0,SEQ_4,CKB1;
definitions EXTPRO_1,COMPOS_1,SCMFSA_2,SCMFSA7B,FUNCOP_1,SCMFSA6A,MEMSTR_0,CKB1;
theorems TARSKI,ZFMISC_1,ENUMSET1,NAT_1,RELAT_1,FUNCT_1,FUNCT_2,LATTICE2,GRFUNC_1,SUBSET_1,FUNCT_4,PRE_FF,SCMFSA_2,MEMSTR_0,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,FUNCOP_1,XXREAL_0,AMI_3,XXREAL_2,PBOOLE,PARTFUN1,COMPOS_1,EXTPRO_1,AMISTD_2,CKB1,CKB21,CKB22,CKB23;
schemes NAT_1,DOMAIN_1,FRAENKEL,RECDEF_1;
registrations XBOOLE_0,SUBSET_1,SETFAM_1,FUNCT_1,ORDINAL1,FINSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,MEMBERED,AMI_5,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8C,SCMFSA_9,XXREAL_2,RELAT_1,SCMFSA10,AMISTD_2,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,FUNCOP_1,SCMFSA6A,STRUCT_0,MEMSTR_0,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
constructors DOMAIN_1,SETWISEO,SEQ_4,PRE_FF,SCM_1,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA8C,RELSET_1,PRE_POLY,AMISTD_2,SCMFSA7B,SCMFSA_1,PBOOLE,AMISTD_1,COMPLEX1,INT_2,NAT_D,XXREAL_1,MEMSTR_0,CKB1;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve p for (Instruction-Sequence of ( SCM+FSA ));
reserve s for (State of ( SCM+FSA ));
reserve I for (Program of ( SCM+FSA ));
reserve J for (Program of ( SCM+FSA ));
theorem
Th5: (for s being ( 0 ) -started (State of ( SCM+FSA )) holds (((I is_closed_on s,p & I c= p) & p halts_on s) implies (for m being (Element of ( NAT )) holds (m <= ( LifeSpan (p,s) ) implies ( Comput (p,s,m) ) = ( Comput (( p +* ( I ';' J ) ),s,m) )))))
proof
let s being ( 0 ) -started (State of ( SCM+FSA ));
assume that
A1: I is_closed_on s,p
and
A3: I c= p
and
A4: p halts_on s;
A2: ( Start-At (( 0 ),( SCM+FSA )) ) c= s by MEMSTR_0:29;
A5: ( p +* I ) = p by A3,FUNCT_4:98;
defpred X[ (Element of ( NAT )) ]
 means
($1 <= ( LifeSpan (p,s) ) implies ( Comput (p,s,$1) ) = ( Comput (( p +* ( I ';' J ) ),s,$1) ));
A7: (for m being (Element of ( NAT )) holds (X[ m ] implies X[ ( m + 1 ) ]))
proof
( dom ( I ';' J ) ) = ( ( dom ( Directed I ) ) \/ ( dom ( Reloc (J,( card I )) ) ) ) by FUNCT_4:def 1
.= ( ( dom I ) \/ ( dom ( Reloc (J,( card I )) ) ) ) by FUNCT_4:99;
then A8: ( dom I ) c= ( dom ( I ';' J ) ) by XBOOLE_1:7;
set sIJ = s;
set pIJ = ( p +* ( I ';' J ) );
A9: ( I ';' J ) c= pIJ by FUNCT_4:25;
let m being (Element of ( NAT ));
assume A10: (m <= ( LifeSpan (p,s) ) implies ( Comput (p,s,m) ) = ( Comput (( p +* ( I ';' J ) ),s,m) ));
A11: ( Comput (pIJ,sIJ,( m + 1 )) ) = ( Following (pIJ,( Comput (pIJ,sIJ,m) )) ) by EXTPRO_1:3;
A12: ( Comput (p,s,( m + 1 )) ) = ( Following (p,( Comput (p,s,m) )) ) by EXTPRO_1:3;
A13: ( p /. ( IC ( Comput (p,s,m) ) ) ) = ( p . ( IC ( Comput (p,s,m) ) ) ) by PBOOLE:143;
assume A14: ( m + 1 ) <= ( LifeSpan (p,s) );
then A15: ( IC ( Comput (p,s,m) ) ) = ( IC ( Comput (pIJ,sIJ,m) ) ) by A10,NAT_1:13;
s = ( Initialize s ) by A2,FUNCT_4:98;
then A16: ( IC ( Comput (p,s,m) ) ) in ( dom I ) by A1,A5,SCMFSA7B:def 6;
A17: ( CurInstr (p,( Comput (p,s,m) )) ) = ( I . ( IC ( Comput (p,s,m) ) ) ) by A16,A13,A3,GRFUNC_1:2;
A18: ( pIJ /. ( IC ( Comput (pIJ,sIJ,m) ) ) ) = ( pIJ . ( IC ( Comput (pIJ,sIJ,m) ) ) ) by PBOOLE:143;
m < ( LifeSpan (p,s) ) by A14,NAT_1:13;
then ( I . ( IC ( Comput (p,s,m) ) ) ) <> ( halt ( SCM+FSA ) ) by A4,A17,EXTPRO_1:def 15;
then ( CurInstr (p,( Comput (p,s,m) )) ) = ( ( I ';' J ) . ( IC ( Comput (p,s,m) ) ) ) by A16,A17,SCMFSA6A:15
.= ( CurInstr (pIJ,( Comput (pIJ,sIJ,m) )) ) by A15,A16,A8,A18,A9,GRFUNC_1:2;
hence thesis by A10,A14,A12,A11,NAT_1:13;
end;
A19: ( Comput (( p +* ( I ';' J ) ),s,( 0 )) ) = s by EXTPRO_1:2;
( Comput (p,s,( 0 )) ) = s by EXTPRO_1:2;
then A20: X[ ( 0 ) ] by A19;
thus (for n being (Element of ( NAT )) holds X[ n ]) from NAT_1:sch 1(A20,A7);
end;
