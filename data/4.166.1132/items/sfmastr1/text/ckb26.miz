environ
vocabularies AMI_1,SCMFSA_2,SCMFSA7B,SCMFSA6A,SF_MASTR,GRAPHSP,AMI_3,SCMFSA6B,TURING_1,AOFA_I00,SCMFSA8C,SCMFSA8B,SCMFSA8A,CARD_1,AMISTD_2,RELAT_1,TARSKI,XXREAL_0,ARYTM_3,FSM_1,XBOOLE_0,FUNCT_4,NUMBERS,SCMFSA6C,UNIALG_2,CIRCUIT2,FUNCT_1,MSUALG_1,SUBSET_1,NAT_1,STRUCT_0,FINSET_1,SCMFSA_1,ZFMISC_1,SCMNORM,PRE_FF,ARYTM_1,SFMASTR1,PARTFUN1,RELOC,PBOOLE,FUNCOP_1,COMPOS_1;
notations TARSKI,XBOOLE_0,ENUMSET1,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,FINSET_1,NAT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,FUNCOP_1,PBOOLE,FUNCT_7,PRE_FF,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_1,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,XXREAL_0,SEQ_4,CKB1;
definitions EXTPRO_1,COMPOS_1,SCMFSA_2,SCMFSA7B,FUNCOP_1,SCMFSA6A,MEMSTR_0,CKB1;
theorems TARSKI,ZFMISC_1,ENUMSET1,NAT_1,RELAT_1,FUNCT_1,FUNCT_2,LATTICE2,GRFUNC_1,SUBSET_1,FUNCT_4,PRE_FF,SCMFSA_2,MEMSTR_0,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,FUNCOP_1,XXREAL_0,AMI_3,XXREAL_2,PBOOLE,PARTFUN1,COMPOS_1,EXTPRO_1,AMISTD_2,CKB1,CKB21,CKB22,CKB23,CKB24,CKB25;
schemes NAT_1,DOMAIN_1,FRAENKEL,RECDEF_1;
registrations XBOOLE_0,SUBSET_1,SETFAM_1,FUNCT_1,ORDINAL1,FINSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,MEMBERED,AMI_5,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8C,SCMFSA_9,XXREAL_2,RELAT_1,SCMFSA10,AMISTD_2,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,FUNCOP_1,SCMFSA6A,STRUCT_0,MEMSTR_0,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
constructors DOMAIN_1,SETWISEO,SEQ_4,PRE_FF,SCM_1,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA8C,RELSET_1,PRE_POLY,AMISTD_2,SCMFSA7B,SCMFSA_1,PBOOLE,AMISTD_1,COMPLEX1,INT_2,NAT_D,XXREAL_1,MEMSTR_0,CKB1;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve p for (Instruction-Sequence of ( SCM+FSA ));
reserve s for (State of ( SCM+FSA ));
reserve J for (Program of ( SCM+FSA ));
reserve Ig for  good (Program of ( SCM+FSA ));
theorem
Th6: ((((Ig is_halting_on ( Initialized s ),p & J is_halting_on ( IExec (Ig,p,s) ),p) & Ig is_closed_on ( Initialized s ),p) & J is_closed_on ( IExec (Ig,p,s) ),p) implies ( LifeSpan (( p +* ( Ig ';' J ) ),( Initialized s )) ) = ( ( ( LifeSpan (( p +* Ig ),( Initialized s )) ) + 1 ) + ( LifeSpan (( ( p +* Ig ) +* J ),( Initialized ( Result (( p +* Ig ),( Initialized s )) ) )) ) ))
proof
set I = Ig;
assume that
A1: I is_halting_on ( Initialized s ),p
and
A2: J is_halting_on ( IExec (I,p,s) ),p
and
A3: I is_closed_on ( Initialized s ),p
and
A4: J is_closed_on ( IExec (I,p,s) ),p;
set Is = ( Initialized s );
A5: ( ( Initialized s ) . ( intloc ( 0 ) ) ) = 1 by SCMFSA6A:38;
set s1 = ( Initialized s );
set p1 = ( p +* I );
set m1 = ( LifeSpan (p1,s1) );
set s3 = ( Initialized ( Comput (p1,s1,m1) ) );
set p3 = ( p1 +* J );
A6: ( p3 +* J ) = p3 by FUNCT_4:93;
s1 = ( Initialized Is );
then A8: s1 = ( Initialize Is ) by A5,SCMFSA8C:4;
then A9: p1 halts_on s1 by A1,SCMFSA7B:def 7;
then A10: s3 = ( Initialized ( Result (p1,s1) ) ) by EXTPRO_1:23;
set s2 = ( Initialized s );
set p2 = ( p +* ( I ';' J ) );
A11: ( I ';' J ) c= p2 by FUNCT_4:25;
A12: ( DataPart Is ) = ( DataPart s2 );
A13: ( s2 . ( intloc ( 0 ) ) ) = 1 by A5;
set JAt = ( Start-At (( 0 ),( SCM+FSA )) );
( ( Comput (p1,s1,m1) ) . ( intloc ( 0 ) ) ) = 1 by A3,A5,A8,SCMFSA8C:68;
then A14: ( Initialized ( Comput (p1,s1,m1) ) ) = ( Initialize ( Comput (p1,s1,m1) ) ) by SCMFSA8C:4;
then JAt c= s3 by FUNCT_4:25;
then A15: s3 = ( Initialize s3 ) by FUNCT_4:98;
( DataPart ( IExec (I,p,s) ) ) = ( DataPart ( Result (( p +* I ),( Initialized s )) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Result (( p +* I ),( Initialized s )) ) )
.= ( DataPart ( Comput (p1,s1,( LifeSpan (p1,s1) )) ) ) by A9,EXTPRO_1:23;
then A16: ( DataPart ( IExec (I,p,s) ) ) = ( DataPart s3 ) by A14,MEMSTR_0:79;
then A17: J is_halting_on s3,p3 by A2,A4,SCMFSA8B:5;
( Initialize s2 ) = s2 by MEMSTR_0:44;
then ( Result (( p2 +* I ),s2) ) = ( Result (p1,s1) ) by A1,A3,A12,SCMFSA8C:72;
then ( Initialized ( Result (( p2 +* I ),s2) ) ) = s3 by A10;
then A20: ( DataPart ( Initialized ( Result (( p2 +* I ),s2) ) ) ) = ( DataPart s3 );
A21: ( DataPart ( IExec (I,p,s) ) ) = ( DataPart ( IExec (I,p,Is) ) ) by SCMFSA8C:3
.= ( DataPart ( IExec (I,p2,s2) ) ) by A1,A3,A5,A12,SCMFSA8C:20;
then A22: J is_closed_on ( IExec (I,p2,s2) ),p2 by A2,A4,SCMFSA8B:5;
A23: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= ( Initialized s ) by FUNCT_4:25;
A24: I is_closed_on s2,p2 by A3,A12,SCMFSA8B:3;
A25: J is_halting_on ( IExec (I,p2,s2) ),p2 by A2,A4,A21,SCMFSA8B:5;
I is_halting_on s2,p2 by A1,A3,A12,SCMFSA8B:5;
then A26: ( LifeSpan (p2,s2) ) = ( ( ( LifeSpan (( p2 +* I ),s2) ) + 1 ) + ( LifeSpan (( ( p2 +* I ) +* J ),( Initialized ( Result (( p2 +* I ),s2) ) )) ) ) by A24,A13,A22,A25,A23,CKB25:1,A11;
( Start-At (( 0 ),( SCM+FSA )) ) c= ( Initialized ( Result (( p2 +* I ),s2) ) ) by FUNCT_4:25,MEMSTR_0:50;
then A27: ( Initialized ( Result (( p2 +* I ),s2) ) ) = ( Initialize ( Initialized ( Result (( p2 +* I ),s2) ) ) ) by FUNCT_4:98;
A28: J is_closed_on s3,p3 by A4,A16,SCMFSA8B:3;
A29: ( LifeSpan (( p2 +* I ),s2) ) = m1 by A1,A3,A8,A12,SCMFSA8C:72;
( LifeSpan (( ( p2 +* I ) +* J ),( Initialized ( Result (( p2 +* I ),s2) ) )) ) = ( LifeSpan (p3,s3) ) by A28,A17,A15,A27,A20,A6,SCMFSA8C:72;
hence thesis by A10,A26,A29;
end;
