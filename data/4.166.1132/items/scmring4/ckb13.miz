environ
vocabularies ORDINAL1,SUBSET_1,NUMBERS,XBOOLE_0,SETFAM_1,SCMFSA7B,FUNCSDOM,AMI_3,AMI_1,FSM_1,STRUCT_0,AMI_2,FUNCT_1,TARSKI,RELAT_1,AMISTD_2,ARYTM_3,FUNCT_4,CIRCUIT2,CARD_1,GRAPHSP,ARYTM_1,SUPINF_2,FUNCOP_1,ZFMISC_1,PARTFUN1,SCMNORM,RELOC,NAT_1,AMISTD_5,COMPOS_1,PBOOLE,FINSET_1;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,DOMAIN_1,ORDINAL1,RELAT_1,FINSET_1,NUMBERS,FUNCT_1,PARTFUN1,STRUCT_0,ALGSTR_0,FUNCSDOM,FUNCOP_1,XCMPLX_0,NAT_1,FUNCT_4,FUNCT_7,NAT_D,VALUED_1,PBOOLE,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,AMI_3,SCMRING1,SCMRING2,SCMRING3,AMISTD_2,AMISTD_5,CKB8;
definitions FUNCT_1,EXTPRO_1,FUNCOP_1,AMI_3,AMI_2,AMISTD_1,AMISTD_2,NAT_1,COMPOS_1,AMISTD_5,STRUCT_0,MEMSTR_0;
theorems TARSKI,NAT_1,SCMRING2,AMI_3,FUNCT_4,FUNCT_1,ZFMISC_1,FUNCOP_1,SCMRING1,AMI_2,STRUCT_0,XBOOLE_0,XBOOLE_1,RELAT_1,GRFUNC_1,SCMRING3,AMISTD_2,PBOOLE,SUBSET_1,PARTFUN1,ORDINAL1,COMPOS_1,EXTPRO_1,AMISTD_5,MEMSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB11,CKB12;
schemes NAT_1;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,FUNCOP_1,XREAL_0,NAT_1,CARD_3,STRUCT_0,AMI_3,SCMRING2,AMISTD_2,SCMRING3,FINSET_1,ORDINAL1,RELSET_1,GRFUNC_1,FUNCT_2,VALUED_1,FUNCT_4,COMPOS_1,EXTPRO_1,AMISTD_5,AMI_5,PBOOLE,PRE_POLY,FUNCT_7,ZFMISC_1,SUBSET_1,MEMSTR_0,NUMBERS,INT_1,CARD_1,AMI_2,CKB7,CKB9,CKB10;
constructors XXREAL_0,REALSET2,AMI_3,AMISTD_2,SCMRING3,PRE_POLY,NAT_D,AMISTD_1,AMISTD_5,PBOOLE,INT_3,FUNCT_7,RELSET_1,MEMSTR_0,CKB8;
requirements NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve n for (Element of ( NAT ));
reserve R for non trivial  good Ring;
reserve a for (Data-Location of R);
reserve b for (Data-Location of R);
reserve s1 for (State of ( SCM R ));
reserve s2 for (State of ( SCM R ));
reserve P1 for (Instruction-Sequence of ( SCM R ));
reserve P2 for (Instruction-Sequence of ( SCM R ));
theorem
Th11: (for q being non halt-free  finite (the Instructions of ( SCM R )) -valued ( NAT ) -defined Function holds (for p being q -autonomic non empty (FinPartState of ( SCM R )) holds ((((((p c= s1 & p c= s2) & q c= P1) & q c= P2) & ( CurInstr (P1,( Comput (P1,s1,n) )) ) = ( SubFrom (a,b) )) & a in ( dom p )) implies ( ( ( Comput (P1,s1,n) ) . a ) - ( ( Comput (P1,s1,n) ) . b ) ) = ( ( ( Comput (P2,s2,n) ) . a ) - ( ( Comput (P2,s2,n) ) . b ) ))))
proof
set Cs2i1 = ( Comput (P2,s2,( n + 1 )) );
set Cs1i1 = ( Comput (P1,s1,( n + 1 )) );
set Cs2i = ( Comput (P2,s2,n) );
set Cs1i = ( Comput (P1,s1,n) );
set I = ( CurInstr (P1,( Comput (P1,s1,n) )) );
let q being non halt-free  finite (the Instructions of ( SCM R )) -valued ( NAT ) -defined Function;
let p being q -autonomic non empty (FinPartState of ( SCM R ));
assume that
A1: (p c= s1 & p c= s2)
and
A2: (q c= P1 & q c= P2);
A3: (a in ( dom p ) implies (( ( Cs1i1 | ( dom p ) ) . a ) = ( Cs1i1 . a ) & ( ( Cs2i1 | ( dom p ) ) . a ) = ( Cs2i1 . a ))) by FUNCT_1:49;
A4: Cs2i1 = ( Following (P2,Cs2i) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (P2,Cs2i) ),Cs2i) );
assume that
A5: I = ( SubFrom (a,b) )
and
A6: (a in ( dom p ) & ( ( ( Comput (P1,s1,n) ) . a ) - ( ( Comput (P1,s1,n) ) . b ) ) <> ( ( ( Comput (P2,s2,n) ) . a ) - ( ( Comput (P2,s2,n) ) . b ) ));
Cs1i1 = ( Following (P1,Cs1i) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (P1,Cs1i) ),Cs1i) );
then A7: ( Cs1i1 . a ) = ( ( Cs1i . a ) - ( Cs1i . b ) ) by A5,SCMRING2:13;
I = ( CurInstr (P2,( Comput (P2,s2,n) )) ) by A1,A2,AMISTD_5:7;
then ( Cs2i1 . a ) = ( ( Cs2i . a ) - ( Cs2i . b ) ) by A4,A5,SCMRING2:13;
hence contradiction by A1,A3,A6,A7,A2,EXTPRO_1:def 10;
end;
