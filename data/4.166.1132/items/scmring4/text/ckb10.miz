environ
vocabularies ORDINAL1,SUBSET_1,NUMBERS,XBOOLE_0,SETFAM_1,SCMFSA7B,FUNCSDOM,AMI_3,AMI_1,FSM_1,STRUCT_0,AMI_2,FUNCT_1,TARSKI,RELAT_1,AMISTD_2,ARYTM_3,FUNCT_4,CIRCUIT2,CARD_1,GRAPHSP,ARYTM_1,SUPINF_2,FUNCOP_1,ZFMISC_1,PARTFUN1,SCMNORM,RELOC,NAT_1,AMISTD_5,COMPOS_1,PBOOLE,FINSET_1;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,DOMAIN_1,ORDINAL1,RELAT_1,FINSET_1,NUMBERS,FUNCT_1,PARTFUN1,STRUCT_0,ALGSTR_0,FUNCSDOM,FUNCOP_1,XCMPLX_0,NAT_1,FUNCT_4,FUNCT_7,NAT_D,VALUED_1,PBOOLE,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,AMI_3,SCMRING1,SCMRING2,SCMRING3,AMISTD_2,AMISTD_5,CKB8;
definitions FUNCT_1,EXTPRO_1,FUNCOP_1,AMI_3,AMI_2,AMISTD_1,AMISTD_2,NAT_1,COMPOS_1,AMISTD_5,STRUCT_0,MEMSTR_0;
theorems TARSKI,NAT_1,SCMRING2,AMI_3,FUNCT_4,FUNCT_1,ZFMISC_1,FUNCOP_1,SCMRING1,AMI_2,STRUCT_0,XBOOLE_0,XBOOLE_1,RELAT_1,GRFUNC_1,SCMRING3,AMISTD_2,PBOOLE,SUBSET_1,PARTFUN1,ORDINAL1,COMPOS_1,EXTPRO_1,AMISTD_5,MEMSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6;
schemes NAT_1;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,FUNCOP_1,XREAL_0,NAT_1,CARD_3,STRUCT_0,AMI_3,SCMRING2,AMISTD_2,SCMRING3,FINSET_1,ORDINAL1,RELSET_1,GRFUNC_1,FUNCT_2,VALUED_1,FUNCT_4,COMPOS_1,EXTPRO_1,AMISTD_5,AMI_5,PBOOLE,PRE_POLY,FUNCT_7,ZFMISC_1,SUBSET_1,MEMSTR_0,NUMBERS,INT_1,CARD_1,AMI_2,CKB7,CKB9;
constructors XXREAL_0,REALSET2,AMI_3,AMISTD_2,SCMRING3,PRE_POLY,NAT_D,AMISTD_1,AMISTD_5,PBOOLE,INT_3,FUNCT_7,RELSET_1,MEMSTR_0,CKB8;
requirements NUMERALS,BOOLE,SUBSET,ARITHM;
begin
registration
let R being non trivial  good Ring;
cluster ( SCM R ) ->  CurIns-recognized;
coherence
proof
let q being non halt-free  finite (the Instructions of ( SCM R )) -valued ( NAT ) -defined Function;
let p being q -autonomic non empty (FinPartState of ( SCM R ));
let s being (State of ( SCM R ));
assume that
A1: p c= s;
let P being (Instruction-Sequence of ( SCM R ));
assume that
A2: q c= P;
let i being (Element of ( NAT ));
set Csi = ( Comput (P,s,i) );
set loc = ( IC Csi );
set loc1 = ( loc + 1 );
assume B4: (not ( IC ( Comput (P,s,i) ) ) in ( dom q ));
set I = ( ( dl. (R,( 0 )) ) := ( dl. (R,( 0 )) ) );
set q1 = ( q +* ( loc .--> I ) );
set q2 = ( q +* ( loc .--> ( halt ( SCM R ) ) ) );
reconsider P1 = ( P +* ( loc .--> I ) ) as (Instruction-Sequence of ( SCM R ));
reconsider P2 = ( P +* ( loc .--> ( halt ( SCM R ) ) ) ) as (Instruction-Sequence of ( SCM R ));
A6: ( dom ( loc .--> ( halt ( SCM R ) ) ) ) = { loc } by FUNCOP_1:13;
then A7: loc in ( dom ( loc .--> ( halt ( SCM R ) ) ) ) by TARSKI:def 1;
A12: ( dom ( loc .--> I ) ) = { loc } by FUNCOP_1:13;
then A13: loc in ( dom ( loc .--> I ) ) by TARSKI:def 1;
Y6: ( dom q ) misses ( dom ( loc .--> ( halt ( SCM R ) ) ) ) by B4,A6,ZFMISC_1:50;
Y5: ( dom q ) misses ( dom ( loc .--> I ) ) by B4,A12,ZFMISC_1:50;
P3: q1 c= P1 by A2,FUNCT_4:123;
P4: q2 c= P2 by A2,FUNCT_4:123;
set Cs2i = ( Comput (P2,s,i) );
set Cs1i = ( Comput (P1,s,i) );
(not p is q -autonomic)
proof
( ( loc .--> ( halt ( SCM R ) ) ) . loc ) = ( halt ( SCM R ) ) by FUNCOP_1:72;
then A18: ( P2 . loc ) = ( halt ( SCM R ) ) by A7,FUNCT_4:13;
B19: ( ( loc .--> I ) . loc ) = I by FUNCOP_1:72;
take P1;
take P2;
q c= q1 by Y5,FUNCT_4:32;
hence A25: q c= P1 by P3,XBOOLE_1:1;
q c= q2 by Y6,FUNCT_4:32;
hence A27: q c= P2 by P4,XBOOLE_1:1;
take s;
take s;
thus p c= s by A1;
A28: ( Cs1i | ( dom p ) ) = ( Csi | ( dom p ) ) by A25,A2,A1,EXTPRO_1:def 10;
thus p c= s by A1;
A29: ( Cs1i | ( dom p ) ) = ( Cs2i | ( dom p ) ) by A25,A27,A1,EXTPRO_1:def 10;
take k = ( i + 1 );
set Cs1k = ( Comput (P1,s,k) );
A33: ( IC ( SCM R ) ) in ( dom p ) by AMISTD_5:6;
( IC Csi ) = ( IC ( Csi | ( dom p ) ) ) by A33,FUNCT_1:49;
then ( IC Cs1i ) = loc by A28,A33,FUNCT_1:49;
then XX: ( CurInstr (P1,Cs1i) ) = ( P1 . loc ) by PBOOLE:143
.= I by B19,A13,FUNCT_4:13;
A31: Cs1k = ( Following (P1,Cs1i) ) by EXTPRO_1:3
.= ( Exec (I,Cs1i) ) by XX;
A32: ( IC ( Exec (I,Cs1i) ) ) = ( succ ( IC Cs1i ) ) by SCMRING2:11;
A33: ( IC ( SCM R ) ) in ( dom p ) by AMISTD_5:6;
A34: ( IC Csi ) = ( IC ( Csi | ( dom p ) ) ) by A33,FUNCT_1:49;
then A35: ( IC Cs1k ) = loc1 by A31,A32,A28,A33,FUNCT_1:49;
set Cs2k = ( Comput (P2,s,k) );
A36: Cs2k = ( Following (P2,Cs2i) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (P2,Cs2i) ),Cs2i) );
A37: ( P2 /. ( IC Cs2i ) ) = ( P2 . ( IC Cs2i ) ) by PBOOLE:143;
( IC Cs2i ) = loc by A28,A34,A29,A33,FUNCT_1:49;
then A38: ( IC Cs2k ) = loc by A36,A18,A37,EXTPRO_1:def 3;
(( IC ( Cs1k | ( dom p ) ) ) = ( IC Cs1k ) & ( IC ( Cs2k | ( dom p ) ) ) = ( IC Cs2k )) by A33,FUNCT_1:49;
hence thesis by A35,A38;
end;
hence contradiction;
end;
end;
