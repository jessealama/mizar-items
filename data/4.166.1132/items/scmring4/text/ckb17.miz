environ
vocabularies ORDINAL1,SUBSET_1,NUMBERS,XBOOLE_0,SETFAM_1,SCMFSA7B,FUNCSDOM,AMI_3,AMI_1,FSM_1,STRUCT_0,AMI_2,FUNCT_1,TARSKI,RELAT_1,AMISTD_2,ARYTM_3,FUNCT_4,CIRCUIT2,CARD_1,GRAPHSP,ARYTM_1,SUPINF_2,FUNCOP_1,ZFMISC_1,PARTFUN1,SCMNORM,RELOC,NAT_1,AMISTD_5,COMPOS_1,PBOOLE,FINSET_1;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,DOMAIN_1,ORDINAL1,RELAT_1,FINSET_1,NUMBERS,FUNCT_1,PARTFUN1,STRUCT_0,ALGSTR_0,FUNCSDOM,FUNCOP_1,XCMPLX_0,NAT_1,FUNCT_4,FUNCT_7,NAT_D,VALUED_1,PBOOLE,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,AMI_3,SCMRING1,SCMRING2,SCMRING3,AMISTD_2,AMISTD_5,CKB8;
definitions FUNCT_1,EXTPRO_1,FUNCOP_1,AMI_3,AMI_2,AMISTD_1,AMISTD_2,NAT_1,COMPOS_1,AMISTD_5,STRUCT_0,MEMSTR_0;
theorems TARSKI,NAT_1,SCMRING2,AMI_3,FUNCT_4,FUNCT_1,ZFMISC_1,FUNCOP_1,SCMRING1,AMI_2,STRUCT_0,XBOOLE_0,XBOOLE_1,RELAT_1,GRFUNC_1,SCMRING3,AMISTD_2,PBOOLE,SUBSET_1,PARTFUN1,ORDINAL1,COMPOS_1,EXTPRO_1,AMISTD_5,MEMSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16;
schemes NAT_1;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,FUNCOP_1,XREAL_0,NAT_1,CARD_3,STRUCT_0,AMI_3,SCMRING2,AMISTD_2,SCMRING3,FINSET_1,ORDINAL1,RELSET_1,GRFUNC_1,FUNCT_2,VALUED_1,FUNCT_4,COMPOS_1,EXTPRO_1,AMISTD_5,AMI_5,PBOOLE,PRE_POLY,FUNCT_7,ZFMISC_1,SUBSET_1,MEMSTR_0,NUMBERS,INT_1,CARD_1,AMI_2,CKB7,CKB9,CKB10;
constructors XXREAL_0,REALSET2,AMI_3,AMISTD_2,SCMRING3,PRE_POLY,NAT_D,AMISTD_1,AMISTD_5,PBOOLE,INT_3,FUNCT_7,RELSET_1,MEMSTR_0,CKB8;
requirements NUMERALS,BOOLE,SUBSET,ARITHM;
begin
registration
let R being non trivial  good Ring;
cluster ( SCM R ) ->  relocable1  relocable2;
coherence
proof
thus ( SCM R ) is  relocable1
proof
thus (for k being (Element of ( NAT )) holds (for q being non halt-free  finite (the Instructions of ( SCM R )) -valued ( NAT ) -defined Function holds (for p being q -autonomic non empty (FinPartState of ( SCM R )) holds (for s1,s2 being (State of ( SCM R )) holds (((( IC ( SCM R ) ) in ( dom p ) & p c= s1) & ( IncIC (p,k) ) c= s2) implies (for P1,P2 being (Instruction-Sequence of ( SCM R )) holds ((q c= P1 & ( Reloc (q,k) ) c= P2) implies (for i being (Element of ( NAT )) holds ( IncAddr (( CurInstr (P1,( Comput (P1,s1,i) )) ),k) ) = ( CurInstr (P2,( Comput (P2,s2,i) )) ))))))))) by CKB16:1;
end;

let k being (Element of ( NAT ));
let q being non halt-free  finite (the Instructions of ( SCM R )) -valued ( NAT ) -defined Function;
let p being q -autonomic non empty (FinPartState of ( SCM R ));
let s1 being (State of ( SCM R )),s2 being (State of ( SCM R ));
assume A1: ((( IC ( SCM R ) ) in ( dom p ) & p c= s1) & ( IncIC (p,k) ) c= s2);
let P1 being (Instruction-Sequence of ( SCM R )),P2 being (Instruction-Sequence of ( SCM R ));
assume (q c= P1 & ( Reloc (q,k) ) c= P2);
hence (for i being (Element of ( NAT )) holds ( ( Comput (P1,s1,i) ) | ( dom ( DataPart p ) ) ) = ( ( Comput (P2,s2,i) ) | ( dom ( DataPart p ) ) )) by A1,CKB16:1;
end;
end;
