environ
vocabularies NUMBERS,NAT_1,INT_1,XXREAL_0,ARYTM_3,RADIX_1,POWER,RELAT_1,RADIX_3,ARYTM_1,SUBSET_1,FINSEQ_1,NEWTON,CARD_1,FINSEQ_2,TARSKI,FUNCT_1,ORDINAL4,PARTFUN1,CARD_3,RADIX_4;
notations TARSKI,SUBSET_1,NUMBERS,XCMPLX_0,INT_1,NAT_1,NAT_D,FUNCT_1,PARTFUN1,NEWTON,POWER,XXREAL_0,FINSEQ_1,FINSEQ_2,GR_CY_1,RADIX_1,RADIX_3;
definitions RADIX_1;
theorems RADIX_1,POWER,NAT_1,INT_1,FINSEQ_1,FINSEQ_2,NEWTON,RVSUM_1,PREPOWER,JORDAN12,EULER_2,RADIX_3,XREAL_1,XXREAL_0,NAT_D,ORDINAL1,PARTFUN1,XREAL_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10;
schemes FINSEQ_2,NAT_1;
registrations RELSET_1,NUMBERS,XREAL_0,NAT_1,INT_1,MEMBERED,NEWTON,XBOOLE_0,VALUED_0,FINSEQ_2,CARD_1;
constructors REAL_1,NAT_D,NEWTON,POWER,BINARITH,GR_CY_1,RADIX_3;
requirements REAL,SUBSET,BOOLE,NUMERALS,ARITHM;
begin
definition
let i being Nat;
let n being Nat;
let k being Nat;
let x being (Tuple of n,( k -SD_Sub ));
let y being (Tuple of n,( k -SD_Sub ));
assume that
A1: i in ( Seg n )
and
A2: k >= 2;
func SDSubAddDigit (x,y,i,k) -> (Element of ( k -SD_Sub ))
equals
:Def1: ( ( SDSub_Add_Data (( ( DigA_SDSub (x,i) ) + ( DigA_SDSub (y,i) ) ),k) ) + ( SDSub_Add_Carry (( ( DigA_SDSub (x,( i -' 1 )) ) + ( DigA_SDSub (y,( i -' 1 )) ) ),k) ) );
coherence
proof
( DigA_SDSub (x,i) ) is (Element of ( k -SD_Sub )) by A1,RADIX_3:18;
then A3: ( DigA_SDSub (x,i) ) in ( k -SD_Sub );
set SDAC = ( SDSub_Add_Carry (( ( DigA_SDSub (x,( i -' 1 )) ) + ( DigA_SDSub (y,( i -' 1 )) ) ),k) );
set SDAD = ( SDSub_Add_Data (( ( DigA_SDSub (x,i) ) + ( DigA_SDSub (y,i) ) ),k) );
A4: ( - 1 ) <= SDAC by RADIX_3:12;
A5: SDAC <= 1 by RADIX_3:12;
(( k -SD_Sub ) c= ( k -SD ) & ( DigA_SDSub (y,i) ) is (Element of ( k -SD_Sub ))) by A1,A2,RADIX_3:4,RADIX_3:18;
then A6: SDAD in ( k -SD_Sub_S ) by A2,A3,RADIX_3:19;
then SDAD >= ( - ( Radix ( k -' 1 ) ) ) by CKB2:1;
then A7: ( ( - ( Radix ( k -' 1 ) ) ) + ( - 1 ) ) <= ( SDAD + SDAC ) by A4,XREAL_1:7;
SDAD <= ( ( Radix ( k -' 1 ) ) - 1 ) by A6,CKB2:1;
then A8: ( SDAD + SDAC ) <= ( ( ( Radix ( k -' 1 ) ) - 1 ) + 1 ) by A5,XREAL_1:7;
(( SDAD + SDAC ) is (Element of ( INT )) & ( k -SD_Sub ) = { w where w is (Element of ( INT )): (w >= ( ( - ( Radix ( k -' 1 ) ) ) - 1 ) & w <= ( Radix ( k -' 1 ) )) }) by INT_1:def 2,RADIX_3:def 2;
then ( SDAD + SDAC ) in ( k -SD_Sub ) by A7,A8;
hence thesis;
end;
end;
