environ
vocabularies STACKS_1,XBOOLE_0,STRUCT_0,ZFMISC_1,SUBSET_1,FUNCT_1,NUMBERS,NAT_1,TARSKI,ARYTM_3,RELAT_1,FINSEQ_1,FINSEQ_3,ORDINAL4,FUNCOP_1,PARTFUN1,CARD_1,XXREAL_0,COMPLEX1,GLIB_000,RELAT_2,EQREL_1,FILTER_1,BINOP_1,MCART_1,ORDERS_1,WELLORD1,ARYTM_1,SETFAM_1,FUNCT_2,AOFA_000,PBOOLE,FUNCT_4,MATRIX_7,REWRITE1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,SETFAM_1,RELAT_1,FUNCT_1,RELAT_2,RELSET_1,PARTFUN1,FUNCT_2,BINOP_1,DOMAIN_1,FUNCT_3,FUNCOP_1,ORDERS_1,FUNCT_4,NUMBERS,XXREAL_0,NAT_1,NAT_D,FINSEQ_1,FINSEQ_2,EQREL_1,FINSEQ_3,PBOOLE,FUNCT_7,STRUCT_0,FILTER_1,REWRITE1,ABCMIZ_1,AOFA_000,CKB1,CKB2,CKB5,CKB7,CKB8,CKB9,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB21,CKB22,CKB23,CKB24,CKB25,CKB32,CKB40,CKB49,CKB56,CKB58,CKB61,CKB66,CKB71,CKB80;
definitions TARSKI,XBOOLE_0,RELAT_1,FUNCT_1,RELAT_2,PARTFUN1,FUNCT_2,FINSEQ_1,BINOP_1,FILTER_1,REWRITE1,CKB5,CKB7,CKB14,CKB15,CKB16,CKB17,CKB18,CKB21,CKB22,CKB23,CKB24,CKB25,CKB40,CKB49,CKB56,CKB58,CKB61,CKB66,CKB71,CKB80;
theorems TARSKI,XBOOLE_1,FINSEQ_1,FINSEQ_3,FINSEQ_5,NAT_1,NAT_D,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_3,FUNCOP_1,WSIERP_1,BINOP_1,POLYALG1,EQREL_1,WELLORD2,RELSET_1,ORDINAL1,XREAL_1,NAT_2,ZFMISC_1,SETFAM_1,RELAT_1,XBOOLE_0,ORDERS_1,MATRIX_7,FUNCT_7,FILTER_1,FUNCT_4,REWRITE1,XXREAL_0,MSUALG_8,HILBERT2,RLVECT_3,FINSEQOP,FINSEQ_2,CKB3,CKB5,CKB7,CKB14,CKB15,CKB16,CKB17,CKB18,CKB21,CKB22,CKB23,CKB24,CKB25,CKB33,CKB35,CKB36,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56,CKB58,CKB60,CKB61,CKB62,CKB63,CKB64,CKB66,CKB67,CKB69,CKB70,CKB71,CKB72,CKB73,CKB74,CKB75,CKB76,CKB77,CKB78,CKB79,CKB80,CKB82,CKB83,CKB84,CKB85,CKB86,CKB87,CKB88;
schemes XBOOLE_0,RELSET_1,NAT_1,FUNCT_2,BINOP_1,RECDEF_1,ALTCAT_1,FUNCT_1,FINSEQ_1,FINSEQ_2,CKB4,CKB6,CKB37,CKB38,CKB39,CKB68;
registrations XBOOLE_0,RELSET_1,STRUCT_0,RELAT_1,FUNCT_1,FINSEQ_1,PARTFUN1,FUNCT_2,NAT_1,ORDINAL1,XXREAL_0,XREAL_0,CARD_1,EQREL_1,SUBSET_1,REWRITE1,CKB9,CKB10,CKB11,CKB12,CKB19,CKB20,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB34,CKB57,CKB59,CKB65,CKB81;
constructors BINOP_1,DOMAIN_1,XXREAL_0,RELSET_1,FILTER_1,FUNCT_7,REWRITE1,ABCMIZ_1,POLYNOM3,NAT_D,CKB1,CKB2,CKB5,CKB7,CKB8,CKB9,CKB14,CKB15,CKB16,CKB17,CKB18,CKB21,CKB22,CKB23,CKB24,CKB25,CKB40,CKB49,CKB56,CKB58,CKB61,CKB66,CKB71,CKB80;
requirements BOOLE,SUBSET,NUMERALS,ARITHM,REAL;
begin
reserve i for Nat;
reserve x for set;
reserve y for set;
reserve X for StackAlgebra;
reserve s for (stack of X);
reserve s2 for (stack of X);
registration
let X;
cluster ( X /== ) ->  pop-finite;
coherence
proof
let f being (Function of ( NAT ),(the carrier' of ( X /== )));
set s1 = the (stack of X);
defpred P[ set,set ]
 means
$2 in ( ( coset s1 ) /\ $1 );
A1: (for x holds (x in ( Class ( ==_ X ) ) implies (ex y st (y in (the carrier' of X) & P[ x,y ]))))
proof
let x;
assume x in ( Class ( ==_ X ) );
then consider s2 such that B2: x = ( Class (( ==_ X ),s2) ) by EQREL_1:36;
consider s such that B3: ( ( coset s1 ) /\ ( Class (( ==_ X ),s2) ) ) = { s } by CKB79:1;
take s;
thus s in (the carrier' of X);
thus s in ( ( coset s1 ) /\ x ) by B2,B3,TARSKI:def 1;
end;
consider g being Function such that A2: ((( dom g ) = ( Class ( ==_ X ) ) & ( rng g ) c= (the carrier' of X)) & (for x holds (x in ( Class ( ==_ X ) ) implies P[ x,( g . x ) ]))) from FUNCT_1:sch 5(A1);
A4: (the carrier' of ( X /== )) = ( Class ( ==_ X ) ) by CKB80:def 1;
then reconsider g as (Function of (the carrier' of ( X /== )),(the carrier' of X)) by A2,FUNCT_2:2;
consider i,s such that A3: (( ( g * f ) . i ) = s & ((not  emp s) implies ( ( g * f ) . ( i + 1 ) ) <> ( pop s ))) by CKB21:def 1;
reconsider S = ( Class (( ==_ X ),s) ) as (stack of ( X /== )) by A4,EQREL_1:def 3;
take i;
take S;
consider s2 such that A5: ( f . i ) = ( Class (( ==_ X ),s2) ) by A4,EQREL_1:36;
i in ( NAT ) by ORDINAL1:def 12;
then s = ( g . ( f . i ) ) by A3,FUNCT_2:15;
then s in ( ( coset s1 ) /\ ( f . i ) ) by A2,A4;
then A6: (s in ( coset s1 ) & s in ( f . i )) by XBOOLE_0:def 4;
hence ( f . i ) = S by A5,EQREL_1:23;
assume B2: (not  emp S);
then A8: (not  emp s) by CKB84:1;
assume B1: ( f . ( i + 1 ) ) = ( pop S );
then A9: ( f . ( i + 1 ) ) = ( Class (( ==_ X ),( pop s )) ) by A8,CKB87:1;
set s3 = ( g . ( f . ( i + 1 ) ) );
consider s4 being (stack of X) such that A10: ( ( coset s1 ) /\ ( f . ( i + 1 ) ) ) = { s4 } by A9,CKB79:1;
((( pop s ) in ( coset s1 ) & ( pop s ) in ( pop S )) & ( pop S ) = ( f . ( i + 1 ) )) by A6,B1,A8,CKB61:def 1,CKB87:1;
then A11: ( pop s ) in { s4 } by A10,XBOOLE_0:def 4;
s3 in ( ( coset s1 ) /\ ( f . ( i + 1 ) ) ) by A2,A4;
then (s3 = s4 & ( pop s ) = s4) by A10,A11,TARSKI:def 1;
hence thesis by A3,B2,CKB84:1,FUNCT_2:15;
end;
end;
