environ
vocabularies SUBSET_1,RELAT_1,XBOOLE_0,FUNCT_1,ZFMISC_1,EQREL_1,RELAT_2,ORDERS_2,STRUCT_0,TARSKI,YELLOW_0,LATTICES,LATTICE3,ORDINAL2,WAYBEL_0,WELLORD1,CAT_1,XXREAL_0,REWRITE1,WAYBEL_1,GROUP_6,SEQM_3,YELLOW_1,WAYBEL_3,PBOOLE,CARD_3,FINSET_1,FUNCT_4,WAYBEL16,WAYBEL_5,BINOP_1,SETFAM_1,WAYBEL20;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,SETFAM_1,RELAT_2,FUNCT_1,PBOOLE,RELSET_1,PARTFUN1,BINOP_1,FUNCT_2,FINSET_1,DOMAIN_1,EQREL_1,FUNCT_3,FUNCT_7,STRUCT_0,ORDERS_2,LATTICE3,QUANTAL1,YELLOW_0,YELLOW_1,YELLOW_2,YELLOW_3,WAYBEL_0,WAYBEL_1,WAYBEL_3,WAYBEL_5,WAYBEL16,CKB3;
definitions TARSKI,RELAT_2,LATTICE3,LATTICE5,YELLOW_0,WAYBEL_0,WAYBEL_1,WAYBEL_3,YELLOW_2,BINOP_1,STRUCT_0;
theorems TARSKI,ZFMISC_1,RELAT_1,RELAT_2,FUNCT_1,FUNCT_2,FUNCT_3,FUNCT_5,FUNCT_7,CARD_3,ORDERS_2,LATTICE3,LATTICE5,QUANTAL1,EQREL_1,YELLOW_0,YELLOW_2,YELLOW_3,YELLOW10,WAYBEL_0,WAYBEL_1,WAYBEL_3,WAYBEL_5,WAYBEL13,WAYBEL15,WAYBEL16,WAYBEL17,XBOOLE_0,XBOOLE_1,PARTFUN1,ORDERS_1,CKB1,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33;
schemes YELLOW_0,FUNCT_2,PBOOLE;
registrations XBOOLE_0,SUBSET_1,RELAT_1,PARTFUN1,FUNCT_2,FINSET_1,STRUCT_0,LATTICE3,YELLOW_0,MONOID_0,WAYBEL_0,YELLOW_2,WAYBEL_1,YELLOW_3,WAYBEL_3,WAYBEL10,YELLOW_9,RELSET_1;
constructors DOMAIN_1,FUNCT_7,MONOID_0,QUANTAL1,ORDERS_3,WAYBEL_1,YELLOW_3,WAYBEL16,RELSET_1,CKB3;
requirements SUBSET,BOOLE;
begin
theorem
(for I being non  empty set holds (for J being  RelStr-yielding  non-Empty  reflexive-yielding (ManySortedSet of I) holds ((for i being (Element of I) holds ( J . i ) is  continuous  complete  continuous  complete LATTICE) implies ( product J ) is  continuous)))
proof
let I being non  empty set;
let J being  RelStr-yielding  non-Empty  reflexive-yielding (ManySortedSet of I);
assume that
A1: (for i being (Element of I) holds ( J . i ) is  continuous  complete  continuous  complete LATTICE);
A2: (for i being (Element of I) holds ( J . i ) is  complete  complete LATTICE) by A1;
set pJ = ( product J );
reconsider pJ9 = pJ as  complete LATTICE by A2,WAYBEL_3:31;
hereby
let x being (Element of pJ);
reconsider x9 = x as (Element of pJ9);
( waybelow x9 ) is non  empty;
hence ( waybelow x ) is non  empty;
( waybelow x9 ) is  directed;
hence ( waybelow x ) is  directed;
end;
pJ9 is  up-complete;
hence pJ is  up-complete;
let x being (Element of pJ);
set swx = ( sup ( waybelow x ) );
now
thus ( dom x ) = I by WAYBEL_3:27;
thus ( dom swx ) = I by WAYBEL_3:27;
let i being set;
assume i in I;
then reconsider i9 = i as (Element of I);
now
reconsider K = { i9 } as  finite (Subset of I);
deffunc F((Element of I)) = ( Bottom ( J . $1 ) );
let a being set;
consider g being (ManySortedSet of I) such that A3: (for i being (Element of I) holds ( g . i ) = F(i)) from PBOOLE:sch 5;
set f = ( g +* (i,a) );
hereby
assume a in ( pi (( waybelow x ),i9) );
then consider f being Function such that A4: f in ( waybelow x ) and A5: a = ( f . i ) by CARD_3:def 6;
reconsider f as (Element of pJ) by A4;
f << x by A4,WAYBEL_3:7;
then ( f . i9 ) << ( x . i9 ) by A2,WAYBEL_3:33;
hence a in ( waybelow ( x . i9 ) ) by A5;
end;
A6: ( dom g ) = I by PARTFUN1:def 2;
then A7: ( dom f ) = I by FUNCT_7:30;
assume A8: a in ( waybelow ( x . i9 ) );
now
let j being (Element of I);
per cases ;
suppose i9 = j;

hence ( f . j ) is (Element of ( J . j )) by A8,A6,FUNCT_7:31;
end;
suppose i9 <> j;

then ( f . j ) = ( g . j ) by FUNCT_7:32
.= ( Bottom ( J . j ) ) by A3;
hence ( f . j ) is (Element of ( J . j ));
end;
end;
then reconsider f as (Element of pJ) by A7,WAYBEL_3:27;
A9:now
let j being (Element of I);
per cases ;
suppose A10: i9 = j;

( f . i9 ) = a by A6,FUNCT_7:31;
hence ( f . j ) << ( x . j ) by A8,A10,WAYBEL_3:7;
end;
suppose A11: i9 <> j;

A12: ( J . j ) is  complete  complete LATTICE by A1;
( f . j ) = ( g . j ) by A11,FUNCT_7:32
.= ( Bottom ( J . j ) ) by A3;
hence ( f . j ) << ( x . j ) by A12,WAYBEL_3:4;
end;
end;
now
let j being (Element of I);
assume (not j in K);
then j <> i9 by TARSKI:def 1;
hence ( f . j ) = ( g . j ) by FUNCT_7:32
.= ( Bottom ( J . j ) ) by A3;
end;
then f << x by A2,A9,WAYBEL_3:33;
then A13: f in ( waybelow x );
a = ( f . i9 ) by A6,FUNCT_7:31;
hence a in ( pi (( waybelow x ),i9) ) by A13,CARD_3:def 6;
end;
then A14: ( pi (( waybelow x ),i9) ) = ( waybelow ( x . i9 ) ) by TARSKI:1;
(( swx . i9 ) = ( sup ( pi (( waybelow x ),i9) ) ) & ( J . i9 ) is  satisfying_axiom_of_approximation) by A1,A2,WAYBEL_3:32;
hence ( x . i ) = ( swx . i ) by A14,WAYBEL_3:def 5;
end;
hence thesis by FUNCT_1:2;
end;
