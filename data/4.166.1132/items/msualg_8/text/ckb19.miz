environ
vocabularies XBOOLE_0,PBOOLE,SUBSET_1,NUMBERS,FINSEQ_1,STRUCT_0,MSUALG_1,RELAT_1,XXREAL_0,ARYTM_3,FUNCT_1,MSUALG_5,EQREL_1,TARSKI,LATTICES,XXREAL_2,REWRITE1,LATTICE3,SETFAM_1,ZFMISC_1,CARD_1,MSUALG_4,CLOSURE2,NAT_1,MARGREL1,PARTFUN1,FUNCT_4,FINSET_1,CARD_3,MSUALG_6,MSUALG_7,MSUALG_8;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,SETFAM_1,RELAT_1,RELSET_1,DOMAIN_1,NUMBERS,STRUCT_0,NAT_1,BINOP_1,FUNCT_1,PARTFUN1,FUNCT_2,FINSET_1,FINSEQ_1,CARD_3,REWRITE1,EQREL_1,LATTICES,LATTICE3,PBOOLE,MSSUBFAM,MSUALG_1,MSUALG_4,MSUALG_5,CLOSURE2,MSUALG_6,MSUALG_7,XXREAL_0,CKB15,CKB16;
definitions TARSKI,XBOOLE_0,EQREL_1,CKB15,CKB16;
theorems XBOOLE_0,TARSKI,PBOOLE,NAT_LAT,MSUALG_4,MSUALG_5,MSUALG_7,CLOSURE2,SETFAM_1,LATTICES,LATTICE3,MSSUBFAM,ZFMISC_1,FINSEQ_1,SUBSET_1,REWRITE1,RELAT_1,MSUALG_6,FUNCT_2,NAT_1,EQREL_1,VECTSP_8,CARD_3,XBOOLE_1,PARTFUN1,CKB1,CKB3,CKB5,CKB6,CKB7,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18;
schemes FINSEQ_1,PARTFUN1,CLASSES1,CKB2;
registrations SUBSET_1,RELSET_1,PARTFUN1,FINSET_1,MEMBERED,EQREL_1,PBOOLE,STRUCT_0,LATTICES,MSUALG_1,MSUALG_3,MSUALG_5,CLOSURE2,MSUALG_6,MSUALG_7,FUNCT_1,CKB4,CKB8;
constructors SETFAM_1,BINOP_1,XXREAL_0,NAT_1,MEMBERED,REALSET1,REWRITE1,MSSUBFAM,LATTICE3,MSUALG_5,CLOSURE2,MSUALG_6,MSUALG_7,RELSET_1,CKB15,CKB16;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve x for set;
reserve i for set;
reserve S for non  void non  empty ManySortedSign;
reserve A for  non-empty MSAlgebra over S;
theorem
(for B1,B2 being (Subset of ( CongrLatt A )) holds (for C1,C2 being (MSCongruence of A) holds ((C1 = ( "\/" (B1,( EqRelLatt (the Sorts of A) )) ) & C2 = ( "\/" (B2,( EqRelLatt (the Sorts of A) )) )) implies ( C1 "\/" C2 ) = ( "\/" (( B1 \/ B2 ),( EqRelLatt (the Sorts of A) )) ))))
proof
let B1 being (Subset of ( CongrLatt A ));
let B2 being (Subset of ( CongrLatt A ));
let C1 being (MSCongruence of A);
let C2 being (MSCongruence of A);
set C = ( EqRelLatt (the Sorts of A) );
assume A1: (C1 = ( "\/" (B1,( EqRelLatt (the Sorts of A) )) ) & C2 = ( "\/" (B2,( EqRelLatt (the Sorts of A) )) ));
(the carrier of ( CongrLatt A )) c= (the carrier of ( EqRelLatt (the Sorts of A) )) by NAT_LAT:def 12;
then reconsider D1 = B1,D2 = B2 as (Subset of ( EqRelLatt (the Sorts of A) )) by XBOOLE_1:1;
A2: { ( "\/" D1 ),( "\/" D2 ) } c= { ( "\/" Y ) where Y is (Subset of C): Y in { B1,B2 } }
proof
let x;
assume x in { ( "\/" D1 ),( "\/" D2 ) };
then A3: (x = ( "\/" D1 ) or x = ( "\/" D2 )) by TARSKI:def 2;
(D1 in { B1,B2 } & D2 in { B1,B2 }) by TARSKI:def 2;
hence thesis by A3;
end;
{ ( "\/" Y ) where Y is (Subset of C): Y in { B1,B2 } } c= { ( "\/" D1 ),( "\/" D2 ) }
proof
let x;
assume x in { ( "\/" Y ) where Y is (Subset of C): Y in { B1,B2 } };
then consider X1 being (Subset of C) such that A4: x = ( "\/" X1 ) and A5: X1 in { B1,B2 };
(X1 = B1 or X1 = B2) by A5,TARSKI:def 2;
hence thesis by A4,TARSKI:def 2;
end;
then A6: { ( "\/" Y ) where Y is (Subset of C): Y in { B1,B2 } } = { ( "\/" D1 ),( "\/" D2 ) } by A2,XBOOLE_0:def 10;
now
let i;
assume i in { B1,B2 };
then (i = D1 or i = D2) by TARSKI:def 2;
hence i in ( bool (the carrier of C) );
end;
then A7: { B1,B2 } c= ( bool (the carrier of C) ) by TARSKI:def 3;
thus ( "\/" (( B1 \/ B2 ),( EqRelLatt (the Sorts of A) )) ) = ( "\/" (( union { B1,B2 } ),C) ) by ZFMISC_1:75
.= ( "\/" ({ ( "\/" Y ) where Y is (Subset of C): Y in { B1,B2 } },C) ) by A7,LATTICE3:48
.= ( ( "\/" D1 ) "\/" ( "\/" D2 ) ) by A6,LATTICE3:43
.= ( (the L_join of C) . (C1,C2) ) by A1,LATTICES:def 1
.= ( C1 "\/" C2 ) by MSUALG_5:def 5;
end;
