environ
vocabularies XBOOLE_0,SUBSET_1,CARD_FIL,YELLOW_1,LATTICES,PRE_TOPC,CONNSP_2,STRUCT_0,TARSKI,ZFMISC_1,WAYBEL_0,XXREAL_0,TOPS_1,WAYBEL_7,RCOMP_1,RELAT_1,RELAT_2,FUNCT_1,FINSET_1,SETFAM_1,LATTICE3,ORDERS_2,WELLORD2,ORDINAL1,MCART_1,YELLOW_6,SEQ_2,METRIC_1,CANTOR_1,ARYTM_0,ARYTM_3,CLASSES1,INT_2,YELLOW_0,CAT_1,BHSP_3,YELLOW19;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,MCART_1,SETFAM_1,FINSET_1,FUNCT_1,RELAT_2,RELSET_1,PARTFUN1,FUNCT_2,CLASSES1,STRUCT_0,PRE_TOPC,TOPS_1,TOPS_2,COMPTS_1,CONNSP_2,CANTOR_1,ORDERS_2,LATTICE3,YELLOW_0,WAYBEL_0,YELLOW_1,WAYBEL_7,YELLOW_6,WAYBEL_9,YELLOW_7,WAYBEL32,CKB2,CKB8,CKB14;
definitions TARSKI,SUBSET_1,TOPS_2,WAYBEL_0,WAYBEL_7,WAYBEL_9,XBOOLE_0,FINSET_1,STRUCT_0,CKB2,CKB8,CKB14;
theorems TARSKI,SETFAM_1,FUNCT_2,FINSET_1,FUNCT_1,CLASSES1,RELAT_1,ZFMISC_1,MCART_1,RELAT_2,SUBSET_1,PRE_TOPC,TOPS_1,TOPS_2,COMPTS_1,CONNSP_2,CANTOR_1,ORDERS_2,LATTICE3,YELLOW_0,WAYBEL_0,YELLOW_1,WAYBEL_7,WAYBEL_8,WAYBEL_9,YELLOW_5,YELLOW_6,YELLOW_7,WAYBEL12,WAYBEL21,WAYBEL32,XBOOLE_0,XBOOLE_1,CKB1,CKB2,CKB3,CKB5,CKB6,CKB7,CKB8,CKB9,CKB11,CKB12,CKB13,CKB14,CKB15,CKB18,CKB19;
schemes RELSET_1,FUNCT_2,FUNCT_1;
registrations SUBSET_1,RELAT_1,FINSET_1,STRUCT_0,PRE_TOPC,TOPS_1,LATTICE3,YELLOW_0,WAYBEL_0,YELLOW_1,YELLOW_6,WAYBEL_7,WAYBEL_9,WAYBEL32,RELSET_1,CKB4,CKB10,CKB16,CKB17;
constructors SETFAM_1,CLASSES1,TOLER_1,TOPS_1,TOPS_2,CONNSP_2,CANTOR_1,WAYBEL_1,WAYBEL_7,WAYBEL32,COMPTS_1,RELSET_1,CKB2,CKB8,CKB14;
requirements BOOLE,SUBSET;
begin
definition
let L being non empty 1-sorted;
let O being non empty (Subset of L);
let F being (Filter of ( BoolePoset O ));
func a_net F ->  strict non empty NetStr over L
means
:Def4: (((the carrier of it) = { [ a,f ] where a is (Element of L),f is (Element of F): a in f } & (for i,j being (Element of it) holds (i <= j iff ( j `2 ) c= ( i `2 )))) & (for i being (Element of it) holds ( it . i ) = ( i `1 )));
existence
proof
deffunc F(set) = ( $1 `1 );
set S = { [ a,f ] where a is (Element of L),f is (Element of F): a in f };
( Top ( BoolePoset O ) ) = O by YELLOW_1:19;
then reconsider f = O as (Element of F) by WAYBEL12:8;
reconsider f as (Subset of L);
consider a being (Element of L) such that A1: a in f by SUBSET_1:4;
reconsider a as (Element of L);
[ a,f ] in S by A1;
then reconsider S as non empty set;
defpred P[ set,set ]
 means
( $2 `2 ) c= ( $1 `2 );
consider R being (Relation of S,S) such that A2: (for x,y being (Element of S) holds ([ x,y ] in R iff P[ x,y ])) from RELSET_1:sch 2;
A3: (for x being set holds (x in S implies F(x) in (the carrier of L)))
proof
let x being set;
assume x in S;
then consider a being (Element of L),f being (Element of F) such that A4: x = [ a,f ] and a in f;
( x `1 ) = a by A4,MCART_1:def 1;
hence thesis;
end;
consider h being (Function of S,(the carrier of L)) such that A5: (for x being set holds (x in S implies ( h . x ) = F(x))) from FUNCT_2:sch 2(A3);
take N = NetStr (# S,R,h #);
(for i,j being (Element of N) holds (i <= j iff ( j `2 ) c= ( i `2 )))
proof
let i being (Element of N),j being (Element of N);
reconsider x = i,y = j as (Element of S);
([ x,y ] in (the InternalRel of N) iff ( y `2 ) c= ( x `2 )) by A2;
hence thesis by ORDERS_2:def 5;
end;
hence thesis by A5;
end;
uniqueness
proof
set S = { [ a,f ] where a is (Element of L),f is (Element of F): a in f };
let it1 being  strict non empty NetStr over L,it2 being  strict non empty NetStr over L;
assume that
A6: (the carrier of it1) = { [ a,f ] where a is (Element of L),f is (Element of F): a in f }
and
A7: (for i,j being (Element of it1) holds (i <= j iff ( j `2 ) c= ( i `2 )))
and
A8: (for i being (Element of it1) holds ( it1 . i ) = ( i `1 ))
and
A9: (the carrier of it2) = { [ a,f ] where a is (Element of L),f is (Element of F): a in f }
and
A10: (for i,j being (Element of it2) holds (i <= j iff ( j `2 ) c= ( i `2 )))
and
A11: (for i being (Element of it2) holds ( it2 . i ) = ( i `1 ));
A12: (for x,y being set holds ([ x,y ] in (the InternalRel of it1) iff [ x,y ] in (the InternalRel of it2)))
proof
let x being set,y being set;
hereby
assume A13: [ x,y ] in (the InternalRel of it1);
then reconsider i = x,j = y as (Element of it1) by ZFMISC_1:87;
reconsider i9 = x,j9 = y as (Element of it2) by A6,A9,A13,ZFMISC_1:87;
i <= j by A13,ORDERS_2:def 5;
then ( j9 `2 ) c= ( i9 `2 ) by A7;
then i9 <= j9 by A10;
hence [ x,y ] in (the InternalRel of it2) by ORDERS_2:def 5;
end;
assume A14: [ x,y ] in (the InternalRel of it2);
then reconsider i = x,j = y as (Element of it2) by ZFMISC_1:87;
reconsider i9 = x,j9 = y as (Element of it1) by A6,A9,A14,ZFMISC_1:87;
i <= j by A14,ORDERS_2:def 5;
then ( j9 `2 ) c= ( i9 `2 ) by A10;
then i9 <= j9 by A7;
hence thesis by ORDERS_2:def 5;
end;
(the mapping of it1) = (the mapping of it2)
proof
reconsider f2 = (the mapping of it2) as (Function of S,(the carrier of L)) by A9;
reconsider f1 = (the mapping of it1) as (Function of S,(the carrier of L)) by A6;
(for x being set holds (x in S implies ( f1 . x ) = ( f2 . x )))
proof
let x being set;
assume A15: x in S;
then reconsider x1 = x as (Element of it1) by A6;
reconsider x2 = x as (Element of it2) by A9,A15;
reconsider x as (Element of S) by A15;
( f1 . x ) = ( it1 . x1 )
.= ( x1 `1 ) by A8
.= ( it2 . x2 ) by A11;
hence thesis;
end;
hence thesis by FUNCT_2:12;
end;
hence thesis by A6,A9,A12,RELAT_1:def 2;
end;
end;
