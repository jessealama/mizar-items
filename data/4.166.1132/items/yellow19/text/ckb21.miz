environ
vocabularies XBOOLE_0,SUBSET_1,CARD_FIL,YELLOW_1,LATTICES,PRE_TOPC,CONNSP_2,STRUCT_0,TARSKI,ZFMISC_1,WAYBEL_0,XXREAL_0,TOPS_1,WAYBEL_7,RCOMP_1,RELAT_1,RELAT_2,FUNCT_1,FINSET_1,SETFAM_1,LATTICE3,ORDERS_2,WELLORD2,ORDINAL1,MCART_1,YELLOW_6,SEQ_2,METRIC_1,CANTOR_1,ARYTM_0,ARYTM_3,CLASSES1,INT_2,YELLOW_0,CAT_1,BHSP_3,YELLOW19;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,MCART_1,SETFAM_1,FINSET_1,FUNCT_1,RELAT_2,RELSET_1,PARTFUN1,FUNCT_2,CLASSES1,STRUCT_0,PRE_TOPC,TOPS_1,TOPS_2,COMPTS_1,CONNSP_2,CANTOR_1,ORDERS_2,LATTICE3,YELLOW_0,WAYBEL_0,YELLOW_1,WAYBEL_7,YELLOW_6,WAYBEL_9,YELLOW_7,WAYBEL32,CKB2,CKB8,CKB14,CKB20;
definitions TARSKI,SUBSET_1,TOPS_2,WAYBEL_0,WAYBEL_7,WAYBEL_9,XBOOLE_0,FINSET_1,STRUCT_0,CKB2,CKB8,CKB14,CKB20;
theorems TARSKI,SETFAM_1,FUNCT_2,FINSET_1,FUNCT_1,CLASSES1,RELAT_1,ZFMISC_1,MCART_1,RELAT_2,SUBSET_1,PRE_TOPC,TOPS_1,TOPS_2,COMPTS_1,CONNSP_2,CANTOR_1,ORDERS_2,LATTICE3,YELLOW_0,WAYBEL_0,YELLOW_1,WAYBEL_7,WAYBEL_8,WAYBEL_9,YELLOW_5,YELLOW_6,YELLOW_7,WAYBEL12,WAYBEL21,WAYBEL32,XBOOLE_0,XBOOLE_1,CKB1,CKB2,CKB3,CKB5,CKB6,CKB7,CKB8,CKB9,CKB11,CKB12,CKB13,CKB14,CKB15,CKB18,CKB19,CKB20;
schemes RELSET_1,FUNCT_2,FUNCT_1;
registrations SUBSET_1,RELAT_1,FINSET_1,STRUCT_0,PRE_TOPC,TOPS_1,LATTICE3,YELLOW_0,WAYBEL_0,YELLOW_1,YELLOW_6,WAYBEL_7,WAYBEL_9,WAYBEL32,RELSET_1,CKB4,CKB10,CKB16,CKB17;
constructors SETFAM_1,CLASSES1,TOLER_1,TOPS_1,TOPS_2,CONNSP_2,CANTOR_1,WAYBEL_1,WAYBEL_7,WAYBEL32,COMPTS_1,RELSET_1,CKB2,CKB8,CKB14,CKB20;
requirements BOOLE,SUBSET;
begin
reserve x for set;
reserve y for set;
registration
let L being non  empty 1-sorted;
let O being non  empty (Subset of L);
let F being (Filter of ( BoolePoset O ));
cluster ( a_net F ) ->  reflexive  transitive;
coherence
proof
(for x,y,z being set holds (((((x in (the carrier of ( a_net F )) & y in (the carrier of ( a_net F ))) & z in (the carrier of ( a_net F ))) & [ x,y ] in (the InternalRel of ( a_net F ))) & [ y,z ] in (the InternalRel of ( a_net F ))) implies [ x,z ] in (the InternalRel of ( a_net F ))))
proof
let x being set;
let y being set;
let z being set;
assume that
A1: x in (the carrier of ( a_net F ))
and
A2: y in (the carrier of ( a_net F ))
and
A3: z in (the carrier of ( a_net F ))
and
A4: [ x,y ] in (the InternalRel of ( a_net F ))
and
A5: [ y,z ] in (the InternalRel of ( a_net F ));
reconsider k = z as (Element of ( a_net F )) by A3;
reconsider j = y as (Element of ( a_net F )) by A2;
j <= k by A5,ORDERS_2:def 5;
then A6: ( k `2 ) c= ( j `2 ) by CKB20:def 1;
reconsider i = x as (Element of ( a_net F )) by A1;
i <= j by A4,ORDERS_2:def 5;
then ( j `2 ) c= ( i `2 ) by CKB20:def 1;
then ( k `2 ) c= ( i `2 ) by A6,XBOOLE_1:1;
then i <= k by CKB20:def 1;
hence thesis by ORDERS_2:def 5;
end;
then A7: (the InternalRel of ( a_net F )) is_transitive_in (the carrier of ( a_net F )) by RELAT_2:def 8;
(for x being set holds (x in (the carrier of ( a_net F )) implies [ x,x ] in (the InternalRel of ( a_net F ))))
proof
let x being set;
assume x in (the carrier of ( a_net F ));
then reconsider i = x as (Element of ( a_net F ));
( i `2 ) c= ( i `2 );
then i <= i by CKB20:def 1;
hence thesis by ORDERS_2:def 5;
end;
then (the InternalRel of ( a_net F )) is_reflexive_in (the carrier of ( a_net F )) by RELAT_2:def 1;
hence thesis by A7,ORDERS_2:def 2,ORDERS_2:def 3;
end;
end;
