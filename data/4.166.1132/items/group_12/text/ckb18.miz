environ
vocabularies FINSEQ_1,FUNCT_1,RELAT_1,RLVECT_2,CARD_3,TARSKI,BINOP_1,GROUP_1,XXREAL_0,GROUP_2,CARD_1,NUMBERS,FUNCT_4,GROUP_6,GROUP_7,FUNCOP_1,ALGSTR_0,GROUP_12,PARTFUN1,FUNCT_2,SUBSET_1,XBOOLE_0,STRUCT_0,NAT_1,ORDINAL4,PRE_TOPC,ARYTM_1,ARYTM_3;
notations TARSKI,XBOOLE_0,SUBSET_1,XCMPLX_0,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,FUNCT_4,FUNCOP_1,CARD_3,NAT_1,NUMBERS,FINSEQ_1,XXREAL_0,STRUCT_0,ALGSTR_0,GROUP_1,GROUP_2,GROUP_3,GROUP_4,GROUP_6,PRALG_1,GROUP_7,FUNCT_7,CKB5,CKB12,CKB14;
definitions GROUP_2,FINSEQ_1,CKB5,CKB12,CKB14;
theorems PRALG_1,FUNCT_1,CARD_3,FUNCT_2,TARSKI,GROUP_1,GROUP_2,GROUP_3,GROUP_4,GROUP_6,FINSEQ_2,XREAL_1,ORDINAL1,FINSEQ_1,FINSEQ_3,NAT_1,XBOOLE_0,RELAT_1,XXREAL_0,GROUP_7,FUNCT_7,YELLOW17,STRUCT_0,PARTFUN1,CKB4,CKB5,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB17;
schemes NAT_1,SUBSET_1,FUNCT_2,XBOOLE_0,FINSEQ_1;
registrations XBOOLE_0,XREAL_0,STRUCT_0,GROUP_2,MONOID_0,ORDINAL1,NAT_1,FUNCT_2,FUNCOP_1,CARD_1,CARD_3,GROUP_7,XXREAL_0,RELSET_1,FINSEQ_1,CKB1,CKB2,CKB3,CKB6,CKB15,CKB16;
constructors BINOP_1,XXREAL_0,REALSET1,FUNCT_4,GROUP_6,MONOID_0,PRALG_1,GROUP_4,GROUP_7,FUNCT_7,RELSET_1,CKB5,CKB12,CKB14;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve I for non  empty set;
reserve F for  associative  Group-like (multMagma-Family of I);
reserve n for non  empty Nat;
theorem
Th8: (for F being  associative  Group-like (multMagma-Family of ( Seg n )) holds (for J being Nat holds (for GJ being Group holds (((1 <= J & J <= n) & GJ = ( F . J )) implies (for x being (Element of ( product F )) holds (for s being (FinSequence of ( product F )) holds (((( len s ) < J & (for k being (Element of ( Seg n )) holds (k in ( dom s ) implies ( s . k ) in ( ProjGroup (F,k) )))) & x = ( Product s )) implies ( x . J ) = ( 1_ GJ ))))))))
proof
let F being  associative  Group-like (multMagma-Family of ( Seg n ));
let J being Nat;
let GJ being Group;
assume A1: ((1 <= J & J <= n) & GJ = ( F . J ));
defpred P[ Nat ]
 means
(for x being (Element of ( product F )) holds (for s being (FinSequence of ( product F )) holds ((((( len s ) < J & ( len s ) = $1) & (for k being (Element of ( Seg n )) holds (k in ( dom s ) implies ( s . k ) in ( ProjGroup (F,k) )))) & x = ( Product s )) implies ( x . J ) = ( 1_ GJ ))));
A2: P[ ( 0 ) ]
proof
let x being (Element of ( product F ));
let s being (FinSequence of ( product F ));
assume A3: (((( len s ) < J & ( len s ) = ( 0 )) & (for k being (Element of ( Seg n )) holds (k in ( dom s ) implies ( s . k ) in ( ProjGroup (F,k) )))) & x = ( Product s ));
s = ( <*> (the carrier of ( product F )) ) by A3;
then A4: x = ( 1_ ( product F ) ) by A3,GROUP_4:8;
J in ( Seg n ) by A1,FINSEQ_1:1;
hence ( x . J ) = ( 1_ GJ ) by A1,A4,GROUP_7:6;
end;
A5: (for m being (Element of ( NAT )) holds (P[ m ] implies P[ ( m + 1 ) ]))
proof
let m being (Element of ( NAT ));
assume A6: P[ m ];
let x being (Element of ( product F ));
let s being (FinSequence of ( product F ));
assume A7: (((( len s ) < J & ( len s ) = ( m + 1 )) & (for k being (Element of ( Seg n )) holds (k in ( dom s ) implies ( s . k ) in ( ProjGroup (F,k) )))) & x = ( Product s ));
A8: m < ( m + 1 ) by NAT_1:13;
A9: 1 <= ( len s ) by A7,NAT_1:11;
(1 <= ( len s ) & ( len s ) <= n) by A7,A1,NAT_1:11,XXREAL_0:2;
then ( len s ) in ( Seg n );
then reconsider ls = ( len s ) as (Element of ( Seg n ));
set t = ( s | m );
A10:now
let k being (Element of ( Seg n ));
assume A11: k in ( dom t );
A12: ( t . k ) = ( s . k ) by A11,FUNCT_1:47;
k in ( dom s ) by A11,RELAT_1:57;
hence ( t . k ) in ( ProjGroup (F,k) ) by A12,A7;
end;
set y = ( Product t );
( dom s ) = ( Seg ( m + 1 ) ) by A7,FINSEQ_1:def 3;
then ( Seg m ) c= ( dom s ) by A8,FINSEQ_1:5;
then A13: ( dom t ) = ( Seg m ) by RELAT_1:62;
then A14: ( len t ) = m by FINSEQ_1:def 3;
A15: ( len t ) = ( ( len s ) - 1 ) by A13,A7,FINSEQ_1:def 3;
A16: ( y . J ) = ( 1_ GJ ) by A6,A10,A15,A7,XREAL_1:51;
( len s ) in ( Seg ( len s ) ) by A9;
then A17: ( len s ) in ( dom s ) by FINSEQ_1:def 3;
then reconsider sn = ( s . ( len s ) ) as (Element of ( product F )) by FINSEQ_2:11;
A18: ( ( len t ) + 1 ) = ( len s ) by A13,A7,FINSEQ_1:def 3;
( len ( t ^ <* sn *> ) ) = ( len s ) by A18,FINSEQ_2:16;
then A19: ( dom ( t ^ <* sn *> ) ) = ( Seg ( len s ) ) by FINSEQ_1:def 3
.= ( dom s ) by FINSEQ_1:def 3;
A20: s = ( t ^ <* sn *> )
proof
(for k being Nat holds (k in ( dom s ) implies ( s . k ) = ( ( t ^ <* sn *> ) . k )))
proof
let k being Nat;
assume k in ( dom s );
then A21: k in ( Seg ( ( len t ) + 1 ) ) by A18,FINSEQ_1:def 3;
now
per cases  by A21,FINSEQ_2:7;
case A22: k in ( Seg ( len t ) );
then k in ( dom t ) by FINSEQ_1:def 3;
then ( ( t ^ <* sn *> ) . k ) = ( t . k ) by FINSEQ_1:def 7
.= ( s . k ) by A22,A14,FUNCT_1:49;
hence thesis;
end;
case k = ( ( len t ) + 1 );
hence thesis by A18,FINSEQ_1:42;
end;
end;
hence thesis;
end;
hence thesis by A19,FINSEQ_1:13;
end;
A23: x = ( y * sn ) by A20,A7,GROUP_4:6;
( s . ( len s ) ) in ( ProjGroup (F,ls) ) by A7,A17;
then ( s . ( len s ) ) in (the carrier of ( ProjGroup (F,ls) )) by STRUCT_0:def 5;
then A24: ( s . ( len s ) ) in ( ProjSet (F,ls) ) by CKB12:def 1;
consider snn being Function,gn being (Element of ( F . ls )) such that A25: (((snn = sn & ( dom snn ) = ( Seg n )) & ( snn . ls ) = gn) & (for k being (Element of ( Seg n )) holds (k <> ls implies ( snn . k ) = ( 1_ ( F . k ) )))) by A24,CKB7:1;
thus ( x . J ) = ( 1_ GJ )
proof
reconsider J0 = J as (Element of ( Seg n )) by A1,FINSEQ_1:1;
A26: ( snn . J0 ) = ( 1_ ( F . J0 ) ) by A25,A7;
thus ( x . J ) = ( ( 1_ ( F . J0 ) ) * ( 1_ ( F . J0 ) ) ) by A16,A25,A26,A23,A1,GROUP_7:1
.= ( 1_ GJ ) by A1,GROUP_1:def 4;
end;

end;
(for m being (Element of ( NAT )) holds P[ m ]) from NAT_1:sch 1(A2,A5);
hence thesis;
end;
