environ
vocabularies NUMBERS,SUBSET_1,STRUCT_0,AMI_1,AMI_2,FUNCT_7,XBOOLE_0,RELAT_1,TARSKI,ZFMISC_1,CAT_1,FSM_1,FUNCT_1,INT_1,NAT_1,GRAPHSP,FINSEQ_1,CARD_1,ORDINAL1,ARYTM_3,ARYTM_1,FUNCOP_1,XXREAL_0,GLIB_000,FUNCT_4,AMI_3,RECDEF_2,COMPOS_1,AMISTD_2,SCMNORM;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,ORDINAL1,XCMPLX_0,FUNCT_1,XXREAL_0,INT_1,NAT_1,ZFMISC_1,MCART_1,FUNCOP_1,CARD_1,CARD_3,RELAT_1,FUNCT_4,FUNCT_7,FINSEQ_1,RECDEF_2,NUMBERS,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,CKB1,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16;
definitions RELAT_1,COMPOS_1,EXTPRO_1,FUNCOP_1,AMI_2,CARD_1,NAT_1,STRUCT_0,MEMSTR_0,CKB1,CKB7,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16;
theorems TARSKI,ZFMISC_1,ENUMSET1,AMI_2,FUNCOP_1,FUNCT_4,CARD_3,FUNCT_2,MCART_1,INT_1,STRUCT_0,ORDINAL1,XBOOLE_0,XBOOLE_1,FUNCT_7,ARYTM_3,XXREAL_0,NAT_1,RELAT_1,FINSEQ_1,FUNCT_1,PARTFUN1,PBOOLE,RECDEF_2,COMPOS_1,EXTPRO_1,MEMSTR_0,CKB1,CKB3,CKB4,CKB5,CKB7,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33;
registrations XBOOLE_0,SETFAM_1,ORDINAL1,FUNCOP_1,NUMBERS,XREAL_0,INT_1,CARD_3,AMI_2,XXREAL_0,FUNCT_1,FINSEQ_1,FUNCT_2,RELSET_1,COMPOS_1,EXTPRO_1,FUNCT_4,MEMSTR_0,CKB2,CKB6;
constructors DOMAIN_1,XXREAL_0,FINSEQ_4,CAT_2,AMI_2,RELSET_1,PRE_POLY,RECDEF_2,EXTPRO_1,FUNCT_7,MEMSTR_0,CKB1,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve a for Data-Location;
reserve loc for Nat;
theorem
Lm11: ( a =0_goto loc ) is non  halting
proof
set f = (the Object-Kind of ( SCM ));
set s = the SCM-State;
reconsider V = ( a =0_goto loc ) as (Element of ( SCM-Instr ));
reconsider a3 = loc as (Element of ( NAT )) by ORDINAL1:def 12;
set t = ( s +* ( ( NAT ) .--> ( succ a3 ) ) );
A1: { ( NAT ) } c= ( SCM-Memory ) by AMI_2:22,ZFMISC_1:31;
A2: ( dom s ) = (the carrier of ( SCM )) by PARTFUN1:def 2;
A3: ( dom t ) = ( ( dom s ) \/ ( dom ( ( NAT ) .--> ( succ a3 ) ) ) ) by FUNCT_4:def 1
.= ( ( SCM-Memory ) \/ ( dom ( ( NAT ) .--> ( succ a3 ) ) ) ) by A2
.= ( ( SCM-Memory ) \/ { ( NAT ) } ) by FUNCOP_1:13
.= ( SCM-Memory ) by A1,XBOOLE_1:12;
A4: 7 is (Element of ( Segm 9 )) by NAT_1:44;
A5: ( dom ( ( NAT ) .--> ( succ a3 ) ) ) = { ( NAT ) } by FUNCOP_1:13;
then ( NAT ) in ( dom ( ( NAT ) .--> ( succ a3 ) ) ) by TARSKI:def 1;
then A6: ( t . ( NAT ) ) = ( ( ( NAT ) .--> ( succ a3 ) ) . ( NAT ) ) by FUNCT_4:13
.= ( succ a3 ) by FUNCOP_1:72;
A7: (for x being set holds (x in ( dom f ) implies ( t . x ) in ( f . x )))
proof
let x being set;
assume that
A8: x in ( dom f );
per cases ;
suppose A9: x = ( NAT );

then ( f . x ) = ( NAT ) by AMI_2:6,AMI_2:22;
hence thesis by A6,A9;
end;
suppose x <> ( NAT );

then (not x in ( dom ( ( NAT ) .--> ( succ a3 ) ) )) by A5,TARSKI:def 1;
then ( t . x ) = ( s . x ) by FUNCT_4:11;
hence thesis by A8,CARD_3:9;
end;
end;
( dom f ) = ( SCM-Memory ) by FUNCT_2:def 1;
then reconsider t as (State of ( SCM )) by A3,A7,FUNCT_1:def 14,PARTFUN1:def 2,RELAT_1:def 18;
reconsider w = t as SCM-State by CARD_3:107;
( dom ( ( NAT ) .--> loc ) ) = { ( NAT ) } by FUNCOP_1:13;
then ( NAT ) in ( dom ( ( NAT ) .--> loc ) ) by TARSKI:def 1;
then A10: ( ( w +* ( ( NAT ) .--> loc ) ) . ( NAT ) ) = ( ( ( NAT ) .--> loc ) . ( NAT ) ) by FUNCT_4:13
.= loc by FUNCOP_1:72;
assume A11: ( a =0_goto loc ) is  halting;
A12: a is (Element of ( SCM-Data-Loc )) by CKB7:def 1;
per cases ;
suppose A13: ( w . ( V cond_address ) ) <> ( 0 );

( IC w ) = ( w . ( NAT ) );
then reconsider e = ( w . ( NAT ) ) as (Element of ( NAT ));
(( IC t ) = ( IC w ) & ( t . a ) <> ( 0 )) by A4,A12,A13,AMI_2:19,AMI_2:22,FUNCT_7:def 1;
then A14: ( ( Exec (( a =0_goto loc ),t) ) . ( IC ( SCM ) ) ) = ( succ e ) by CKB24:1;
( ( Exec (( a =0_goto loc ),t) ) . ( IC ( SCM ) ) ) = ( w . ( NAT ) ) by A11,CKB17:1,EXTPRO_1:def 3;
hence contradiction by A14;
end;
suppose ( w . ( V cond_address ) ) = ( 0 );

then ( IFEQ (( w . ( V cond_address ) ),( 0 ),( V cjump_address ),( succ ( IC w ) )) ) = ( V cjump_address ) by FUNCOP_1:def 8;
then ( w +* ( ( NAT ) .--> loc ) ) = ( SCM-Chg (w,( IFEQ (( w . ( V cond_address ) ),( 0 ),( V cjump_address ),( succ ( IC w ) )) )) ) by A4,A12,AMI_2:19
.= ( SCM-Exec-Res (V,w) ) by A12,AMI_2:def 13
.= ( Exec (( a =0_goto loc ),t) ) by AMI_2:def 14
.= t by A11,EXTPRO_1:def 3;
hence contradiction by A6,A10;
end;
end;
