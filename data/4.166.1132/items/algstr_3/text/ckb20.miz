environ
vocabularies STRUCT_0,SUBSET_1,MULTOP_1,XBOOLE_0,VECTSP_1,FUNCT_1,NUMBERS,REAL_1,RELAT_1,ARYTM_3,CARD_1,ARYTM_1,MESFUNC1,SUPINF_2,ALGSTR_3;
notations XBOOLE_0,SUBSET_1,NUMBERS,STRUCT_0,REAL_1,MULTOP_1,CKB1,CKB3,CKB4,CKB5,CKB6,CKB8;
definitions STRUCT_0,CKB4,CKB5,CKB6,CKB8;
theorems MULTOP_1,XCMPLX_1,CKB4,CKB5,CKB6,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19;
schemes MULTOP_1;
registrations NUMBERS,MEMBERED,STRUCT_0,CKB1,CKB2,CKB7;
constructors REAL_1,MEMBERED,MULTOP_1,RLVECT_1,CKB1,CKB4,CKB5,CKB6,CKB8;
requirements NUMERALS,SUBSET,ARITHM,BOOLE;
begin
reserve F for non  empty TernaryFieldStr;
reserve a for (Scalar of F);
theorem
Lm9: (for a,a9,u,u9,v,v9 being (Scalar of ( TernaryFieldEx )) holds ((( Tern (u,a,v) ) = ( Tern (u9,a,v9) ) & ( Tern (u,a9,v) ) = ( Tern (u9,a9,v9) )) implies (a = a9 or u = u9)))
proof
let a being (Scalar of ( TernaryFieldEx ));
let a9 being (Scalar of ( TernaryFieldEx ));
let u being (Scalar of ( TernaryFieldEx ));
let u9 being (Scalar of ( TernaryFieldEx ));
let v being (Scalar of ( TernaryFieldEx ));
let v9 being (Scalar of ( TernaryFieldEx ));
assume A1: (( Tern (u,a,v) ) = ( Tern (u9,a,v9) ) & ( Tern (u,a9,v) ) = ( Tern (u9,a9,v9) ));
reconsider aa = a,aa9 = a9,uu = u,uu9 = u9,vv = v,vv9 = v9 as Real;
A2: (( Tern (u,a9,v) ) = ( ( uu * aa9 ) + vv ) & ( Tern (u9,a9,v9) ) = ( ( uu9 * aa9 ) + vv9 )) by CKB5:def 1;
(( Tern (u,a,v) ) = ( ( uu * aa ) + vv ) & ( Tern (u9,a,v9) ) = ( ( uu9 * aa ) + vv9 )) by CKB5:def 1;
then ( uu * ( aa - aa9 ) ) = ( uu9 * ( aa - aa9 ) ) by A1,A2;
then (uu = uu9 or ( aa - aa9 ) = ( 0 )) by XCMPLX_1:5;
hence thesis;
end;
