environ
vocabularies NUMBERS,CLVECT_1,LOPBAN_1,RELAT_1,RLVECT_1,CFUNCT_1,FUNCT_1,ARYTM_3,XXREAL_2,NORMSP_1,XXREAL_0,PRE_TOPC,CLOPBAN1,CARD_1,REAL_1,XREAL_0,ORDINAL1,ORDINAL2,SUBSET_1,RSSPACE,LOPBAN_2,BINOP_1,STRUCT_0,COMPLEX1,ALGSTR_0,XBOOLE_0,GROUP_1,SUPINF_2,MESFUNC1,FUNCSDOM,VECTSP_1,LATTICES,CFUNCDOM,CSSPACE3,REWRITE1,NAT_1,RSSPACE3,SEQ_2,ZFMISC_1,XCMPLX_0,PREPOWER,COMSEQ_1,SERIES_1,CSSPACE,ARYTM_1,CLOPBAN2,NORMSP_0,METRIC_1,RELAT_2,SEQ_4;
notations XBOOLE_0,ZFMISC_1,SUBSET_1,FUNCT_1,PARTFUN1,FUNCT_2,PRE_TOPC,BINOP_1,STRUCT_0,ALGSTR_0,XCMPLX_0,XXREAL_0,XREAL_0,ORDINAL1,NUMBERS,XXREAL_2,REAL_1,PSCOMP_1,RLVECT_1,VALUED_1,SEQ_4,FUNCSDOM,COMPLEX1,GROUP_1,VECTSP_1,SERIES_1,CFUNCT_1,COMSEQ_1,COMSEQ_3,NORMSP_0,CLVECT_1,CSSPACE,CSSPACE3,CLOPBAN1,CFUNCDOM,PREPOWER,CKB3,CKB4,CKB5,CKB6,CKB7,CKB9,CKB19;
definitions STRUCT_0,GROUP_1,VECTSP_1,CLOPBAN1,BINOP_1,RLVECT_1,ALGSTR_0,CLVECT_1,CFUNCDOM,NORMSP_0,CKB4,CKB5,CKB6,CKB7,CKB9,CKB19;
theorems ABSVALUE,RLVECT_1,VECTSP_1,BINOP_1,XCMPLX_0,SERIES_1,FUNCT_1,FUNCT_2,SEQ_4,PREPOWER,STRUCT_0,CLOPBAN1,CLVECT_1,COMPLEX1,CFUNCDOM,CSSPACE3,COMSEQ_3,CSSPACE,GROUP_1,XREAL_1,XXREAL_0,ALGSTR_0,VALUED_1,GRCAT_1,NORMSP_0,CKB1,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19;
schemes BINOP_1;
registrations XBOOLE_0,FUNCT_1,ORDINAL1,RELSET_1,FUNCT_2,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,MEMBERED,STRUCT_0,CLVECT_1,CSSPACE3,CLOPBAN1,CFUNCDOM,ALGSTR_0,VALUED_1,VALUED_0,NORMSP_0,CKB20,CKB21;
constructors PARTFUN1,DOMAIN_1,XXREAL_0,REAL_1,NAT_1,PREPOWER,COMSEQ_3,PSCOMP_1,CSSPACE3,CLOPBAN1,CFUNCDOM,VECTSP_1,SEQ_1,XXREAL_2,SERIES_1,SEQ_4,RELSET_1,BINOP_2,RVSUM_1,CKB3,CKB4,CKB5,CKB6,CKB7,CKB9,CKB19;
requirements SUBSET,REAL,BOOLE,NUMERALS,ARITHM;
begin
theorem
Th13: (for X being ComplexNormSpace holds (for x,y,z being (Element of ( Ring_of_BoundedLinearOperators X )) holds ((((((((( x + y ) = ( y + x ) & ( ( x + y ) + z ) = ( x + ( y + z ) )) & ( x + ( 0. ( Ring_of_BoundedLinearOperators X ) ) ) = x) & x is  right_complementable) & ( ( x * y ) * z ) = ( x * ( y * z ) )) & ( x * ( 1. ( Ring_of_BoundedLinearOperators X ) ) ) = x) & ( ( 1. ( Ring_of_BoundedLinearOperators X ) ) * x ) = x) & ( x * ( y + z ) ) = ( ( x * y ) + ( x * z ) )) & ( ( y + z ) * x ) = ( ( y * x ) + ( z * x ) ))))
proof
let X being ComplexNormSpace;
let x being (Element of ( Ring_of_BoundedLinearOperators X ));
let y being (Element of ( Ring_of_BoundedLinearOperators X ));
let z being (Element of ( Ring_of_BoundedLinearOperators X ));
set RBLOP = ( Ring_of_BoundedLinearOperators X );
set BLOP = ( BoundedLinearOperators (X,X) );
set ADD = ( Add_ (( BoundedLinearOperators (X,X) ),( C_VectorSpace_of_LinearOperators (X,X) )) );
set MULT = ( FuncMult X );
set UNIT = ( FuncUnit X );
set RRL = CLSStruct (# ( BoundedLinearOperators (X,X) ),( Zero_ (( BoundedLinearOperators (X,X) ),( C_VectorSpace_of_LinearOperators (X,X) )) ),( Add_ (( BoundedLinearOperators (X,X) ),( C_VectorSpace_of_LinearOperators (X,X) )) ),( Mult_ (( BoundedLinearOperators (X,X) ),( C_VectorSpace_of_LinearOperators (X,X) )) ) #);
reconsider f = x,g = y,h = z as (Element of RRL);
thus ( x + y ) = ( f + g )
.= ( y + x ) by RLVECT_1:2;
thus ( ( x + y ) + z ) = ( ( f + g ) + h )
.= ( f + ( g + h ) ) by RLVECT_1:def 3
.= ( x + ( y + z ) );
thus ( x + ( 0. RBLOP ) ) = ( f + ( 0. RRL ) )
.= x by RLVECT_1:def 4;
thus (ex t being (Element of RBLOP) st ( x + t ) = ( 0. RBLOP ))
proof
consider s being (Element of RRL) such that A1: ( f + s ) = ( 0. RRL ) by ALGSTR_0:def 11;
reconsider t = s as (Element of RBLOP);
take t;
thus thesis by A1;
end;

reconsider xx = x,yy = y,zz = z as (Element of BLOP);
thus ( ( x * y ) * z ) = ( MULT . (( xx * yy ),zz) ) by CKB7:def 1
.= ( ( xx * yy ) * zz ) by CKB7:def 1
.= ( xx * ( yy * zz ) ) by CKB13:1
.= ( MULT . (xx,( yy * zz )) ) by CKB7:def 1
.= ( x * ( y * z ) ) by CKB7:def 1;
thus ( x * ( 1. RBLOP ) ) = ( xx * UNIT ) by CKB7:def 1
.= x by CKB14:1;
thus ( ( 1. RBLOP ) * x ) = ( UNIT * xx ) by CKB7:def 1
.= x by CKB14:1;
thus ( x * ( y + z ) ) = ( xx * ( yy + zz ) ) by CKB7:def 1
.= ( ( xx * yy ) + ( xx * zz ) ) by CKB15:1
.= ( ADD . (( xx * yy ),( MULT . (xx,zz) )) ) by CKB7:def 1
.= ( ( x * y ) + ( x * z ) ) by CKB7:def 1;
thus ( ( y + z ) * x ) = ( ( yy + zz ) * xx ) by CKB7:def 1
.= ( ( yy * xx ) + ( zz * xx ) ) by CKB16:1
.= ( ADD . (( yy * xx ),( MULT . (zz,xx) )) ) by CKB7:def 1
.= ( ( y * x ) + ( z * x ) ) by CKB7:def 1;
end;
