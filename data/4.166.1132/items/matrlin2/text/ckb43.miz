environ
vocabularies NUMBERS,NAT_1,VECTSP_1,SUBSET_1,RLSUB_1,XBOOLE_0,ARYTM_3,STRUCT_0,TARSKI,RLVECT_3,RLVECT_2,CARD_3,SUPINF_2,FINSET_1,FUNCT_1,RLSUB_2,FUNCT_2,RLVECT_5,MATRLIN,RELAT_1,CARD_1,XXREAL_0,FINSEQ_1,ZFMISC_1,ALGSTR_0,PARTFUN1,ORDINAL4,FINSEQ_2,INCSP_1,MESFUNC1,TREES_1,MATRIX_1,GROUP_1,ARYTM_1,FINSEQ_4,RFINSEQ,RANKNULL,MATRIXJ1,MATRIX_3,MATRIX_6,FVSUM_1,RVSUM_1,MATRIXR1,VECTSP10,MATRIX15,QC_LANG1,CLASSES1,PRVECT_1,MATRIX13,LMOD_7,VALUED_1,RLVECT_1,BINOP_1,LATTICES,MATRLIN2,UNIALG_1,MSSUBFAM;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,CARD_1,XCMPLX_0,ALGSTR_0,XXREAL_0,NAT_1,FINSET_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FINSEQ_1,BINOP_1,STRUCT_0,RLVECT_1,GROUP_1,VECTSP_1,FINSEQ_2,MATRIX_1,FVSUM_1,MATRIX_3,MATRIX_6,DOMAIN_1,VECTSP_4,VECTSP_6,VECTSP_7,VECTSP_9,FINSEQOP,PRVECT_1,MATRIX13,MATRLIN,MATRIX15,RFINSEQ,WSIERP_1,GRCAT_1,MOD_2,VECTSP_5,RANKNULL,MATRIXJ1,CKB31,CKB32,CKB34,CKB39;
definitions STRUCT_0,TARSKI,RLVECT_1,FINSEQ_1,VECTSP_4,FVSUM_1,VECTSP_1,MATRIX_1,MATRIX13,MATRLIN,MATRIX15,FUNCT_1,VECTSP_7,RANKNULL,VECTSP_6,CKB32,CKB34,CKB39;
theorems ZFMISC_1,RLVECT_1,MATRIX_1,MATRIX_2,MATRIX_4,MATRIX_3,VECTSP_1,NAT_1,FINSEQ_2,CARD_1,CARD_FIN,FINSEQ_1,FINSEQ_3,FINSEQOP,FUNCT_1,FUNCT_2,FUNCOP_1,FVSUM_1,LAPLACE,MATRIX_6,MATRIX_7,MATRIX11,MATRIX13,MATRIXR1,MATRIXR2,MATRLIN,ORDINAL1,PARTFUN1,RELAT_1,STRUCT_0,TARSKI,VECTSP_4,VECTSP_6,VECTSP_7,VECTSP_9,XBOOLE_0,XBOOLE_1,XXREAL_0,MATRIX15,MOD_2,RLVECT_2,POLYFORM,VECTSP10,MATRIX_8,RANKNULL,VECTSP_5,FINSEQ_5,RFINSEQ,MATRIXJ1,GRCAT_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42;
schemes NAT_1,MATRIX_1,FUNCT_2,FINSEQ_2;
registrations XBOOLE_0,FUNCT_1,FINSET_1,STRUCT_0,VECTSP_1,FUNCT_2,ORDINAL1,XXREAL_0,NAT_1,FINSEQ_1,RELAT_1,FINSEQ_2,MATRLIN,MATRIX13,XREAL_0,VECTSP_9,CARD_1,MOD_2,GRCAT_1,PRVECT_1;
constructors FVSUM_1,VECTSP_9,MATRIX_6,LAPLACE,MATRIX15,RANKNULL,VECTSP10,MATRIXJ1,XXREAL_0,REALSET1,BINARITH,RELSET_1,FINSOP_1,MATRIX13,CKB31,CKB32,CKB34,CKB39;
requirements ARITHM,NUMERALS,REAL,BOOLE,SUBSET;
begin
reserve i for Nat;
reserve K for Field;
reserve a for (Element of K);
reserve V1 for  finite-dimensional (VectSp of K);
reserve V2 for  finite-dimensional (VectSp of K);
reserve b1 for (OrdBasis of V1);
reserve B2 for (FinSequence of V2);
reserve v1 for (Element of V1);
reserve w1 for (Element of V1);
registration
let K;
let V1;
let V2;
let b1;
let B2;
let M being (Matrix of ( len b1 ),( len B2 ),K);
cluster ( Mx2Tran (M,b1,B2) ) ->  homogeneous  additive;
coherence
proof
set Mx = ( Mx2Tran (M,b1,B2) );
per cases ;
suppose A1: ( len b1 ) = ( 0 );

A2:now
let a being (Scalar of K);
let v1 being (Vector of V1);
thus ( Mx . ( a * v1 ) ) = ( 0. V2 ) by A1,CKB41:1
.= ( a * ( 0. V2 ) ) by VECTSP_1:14
.= ( a * ( Mx . v1 ) ) by A1,CKB41:1;
end;
now
let v1 being (Vector of V1);
let w1 being (Vector of V1);
thus ( Mx . ( v1 + w1 ) ) = ( 0. V2 ) by A1,CKB41:1
.= ( ( 0. V2 ) + ( 0. V2 ) ) by RLVECT_1:def 4
.= ( ( Mx . v1 ) + ( 0. V2 ) ) by A1,CKB41:1
.= ( ( Mx . v1 ) + ( Mx . w1 ) ) by A1,CKB41:1;
end;
then Mx is  additive  homogeneous by A2,GRCAT_1:def 8,MOD_2:def 2;
hence thesis;
end;
suppose A3: ( len b1 ) > ( 0 );

A4:now
let v1 being (Vector of V1);
let w1 being (Vector of V1);
set vb = ( v1 |-- b1 );
set wb = ( w1 |-- b1 );
set vwb = ( ( v1 + w1 ) |-- b1 );
set Lvw = ( LineVec2Mx vwb );
set Lv = ( LineVec2Mx vb );
set Lw = ( LineVec2Mx wb );
set LLvw = ( Line (( Lvw * M ),1) );
set LLv = ( Line (( Lv * M ),1) );
set LLw = ( Line (( Lw * M ),1) );
A5: ( len Lw ) = 1 by MATRIX_1:23;
A6: ( len b1 ) = ( len vb ) by MATRLIN:def 7;
A7: ( len M ) = ( len b1 ) by A3,MATRIX_1:23;
A8: ( width Lv ) = ( len vb ) by MATRIX_1:23;
then A9: ( width ( Lv * M ) ) = ( width M ) by A7,A6,MATRIX_3:def 4;
then A10: ( len LLv ) = ( width M ) by CARD_1:def 7;
A11: ( len Lv ) = 1 by MATRIX_1:23;
then A12: ( len ( Lv * M ) ) = 1 by A8,A7,A6,MATRIX_3:def 4;
A13: ( len b1 ) = ( len wb ) by MATRLIN:def 7;
(( width Lvw ) = ( len vwb ) & ( len b1 ) = ( len vwb )) by MATRIX_1:23,MATRLIN:def 7;
then ( width ( Lvw * M ) ) = ( width M ) by A7,MATRIX_3:def 4;
then A14: ( len LLvw ) = ( width M ) by CARD_1:def 7;
A15: ( dom ( lmlt (LLvw,B2) ) ) = ( ( dom LLvw ) /\ ( dom B2 ) ) by CKB7:1
.= ( ( dom LLv ) /\ ( dom B2 ) ) by A14,A10,FINSEQ_3:29
.= ( dom ( lmlt (LLv,B2) ) ) by CKB7:1;
A16: ( width Lw ) = ( len wb ) by MATRIX_1:23;
then A17: ( width ( Lw * M ) ) = ( width M ) by A7,A13,MATRIX_3:def 4;
then A18: ( len LLw ) = ( width M ) by CARD_1:def 7;
A19: ( dom ( lmlt (LLvw,B2) ) ) = ( ( dom LLvw ) /\ ( dom B2 ) ) by CKB7:1
.= ( ( dom LLw ) /\ ( dom B2 ) ) by A14,A18,FINSEQ_3:29
.= ( dom ( lmlt (LLw,B2) ) ) by CKB7:1;
then A20: ( len ( lmlt (LLvw,B2) ) ) = ( len ( lmlt (LLw,B2) ) ) by FINSEQ_3:29;
Lvw = ( LineVec2Mx ( vb + wb ) ) by CKB20:1
.= ( Lv + Lw ) by A6,A13,MATRIX15:27;
then ( Lvw * M ) = ( ( Lv * M ) + ( Lw * M ) ) by A3,A11,A8,A5,A16,A7,A6,A13,MATRIX_4:63;
then LLvw = ( LLv + LLw ) by A12,A9,A17,CKB42:1;
then A21: ( lmlt (LLvw,B2) ) = ( ( lmlt (LLv,B2) ) + ( lmlt (LLw,B2) ) ) by CKB10:1;
A22:now
let i being (Element of ( NAT ));
assume that
A23: i in ( dom ( lmlt (LLv,B2) ) );
(( ( lmlt (LLv,B2) ) /. i ) = ( ( lmlt (LLv,B2) ) . i ) & ( ( lmlt (LLw,B2) ) /. i ) = ( ( lmlt (LLw,B2) ) . i )) by A15,A19,A23,PARTFUN1:def 6;
hence ( ( lmlt (LLvw,B2) ) . i ) = ( ( ( lmlt (LLv,B2) ) /. i ) + ( ( lmlt (LLw,B2) ) /. i ) ) by A21,A15,A23,FVSUM_1:17;
end;
( len ( lmlt (LLvw,B2) ) ) = ( len ( lmlt (LLv,B2) ) ) by A15,FINSEQ_3:29;
then ( Sum ( lmlt (LLvw,B2) ) ) = ( ( Sum ( lmlt (LLv,B2) ) ) + ( Sum ( lmlt (LLw,B2) ) ) ) by A20,A22,RLVECT_2:2;
hence ( Mx . ( v1 + w1 ) ) = ( ( Sum ( lmlt (LLv,B2) ) ) + ( Sum ( lmlt (LLw,B2) ) ) ) by CKB39:def 1
.= ( ( Mx . v1 ) + ( Sum ( lmlt (LLw,B2) ) ) ) by CKB39:def 1
.= ( ( Mx . v1 ) + ( Mx . w1 ) ) by CKB39:def 1;
end;
now
let a being (Scalar of K);
let v1 being (Vector of V1);
set vb = ( v1 |-- b1 );
set avb = ( ( a * v1 ) |-- b1 );
set Lav = ( LineVec2Mx avb );
set Lv = ( LineVec2Mx vb );
set LLav = ( Line (( Lav * M ),1) );
set LLv = ( Line (( Lv * M ),1) );
A24: ( len M ) = ( len b1 ) by A3,MATRIX_1:23;
(( width Lav ) = ( len avb ) & ( len b1 ) = ( len avb )) by MATRIX_1:23,MATRLIN:def 7;
then ( width ( Lav * M ) ) = ( width M ) by A24,MATRIX_3:def 4;
then A25: ( len LLav ) = ( width M ) by CARD_1:def 7;
A26: (( width Lv ) = ( len vb ) & ( len b1 ) = ( len vb )) by MATRIX_1:23,MATRLIN:def 7;
then ( width ( Lv * M ) ) = ( width M ) by A24,MATRIX_3:def 4;
then ( len LLv ) = ( width M ) by CARD_1:def 7;
then A27: ( dom LLav ) = ( dom LLv ) by A25,FINSEQ_3:29;
Lav = ( LineVec2Mx ( a * vb ) ) by CKB21:1
.= ( a * Lv ) by MATRIX15:29;
then A28: ( Lav * M ) = ( a * ( Lv * M ) ) by A24,A26,MATRIX15:1;
A29: ( dom ( lmlt (LLav,B2) ) ) = ( ( dom LLav ) /\ ( dom B2 ) ) by CKB7:1;
A30: ( ( dom LLv ) /\ ( dom B2 ) ) = ( dom ( lmlt (LLv,B2) ) ) by CKB7:1;
( len Lv ) = 1 by MATRIX_1:23;
then ( len ( Lv * M ) ) = 1 by A24,A26,MATRIX_3:def 4;
then A31: LLav = ( a * LLv ) by A28,MATRIXR1:20;
A32:now
let i being (Element of ( NAT ));
assume that
A33: i in ( dom ( lmlt (LLv,B2) ) );
A34: ( ( lmlt (LLv,B2) ) . i ) = ( ( lmlt (LLv,B2) ) /. i ) by A33,PARTFUN1:def 6;
i in ( dom LLv ) by A30,A33,XBOOLE_0:def 4;
then A35: ( LLv . i ) = ( LLv /. i ) by PARTFUN1:def 6;
i in ( dom B2 ) by A30,A33,XBOOLE_0:def 4;
then A36: ( B2 . i ) = ( B2 /. i ) by PARTFUN1:def 6;
A37: i in ( dom LLav ) by A27,A30,A33,XBOOLE_0:def 4;
then A38: ( LLav . i ) = ( LLav /. i ) by PARTFUN1:def 6;
hence ( ( lmlt (LLav,B2) ) . i ) = ( (the lmult of V2) . (( LLav /. i ),( B2 /. i )) ) by A29,A27,A30,A33,A36,FUNCOP_1:22
.= ( ( a * ( LLv /. i ) ) * ( B2 /. i ) ) by A31,A37,A35,A38,FVSUM_1:50
.= ( a * ( ( LLv /. i ) * ( B2 /. i ) ) ) by VECTSP_1:def 16
.= ( a * ( ( lmlt (LLv,B2) ) /. i ) ) by A33,A35,A36,A34,FUNCOP_1:22;
end;
( len ( lmlt (LLav,B2) ) ) = ( len ( lmlt (LLv,B2) ) ) by A29,A27,A30,FINSEQ_3:29;
then ( Sum ( lmlt (LLav,B2) ) ) = ( a * ( Sum ( lmlt (LLv,B2) ) ) ) by A32,RLVECT_2:67;
hence ( Mx . ( a * v1 ) ) = ( a * ( Sum ( lmlt (LLv,B2) ) ) ) by CKB39:def 1
.= ( a * ( Mx . v1 ) ) by CKB39:def 1;
end;
then Mx is  additive  homogeneous by A4,GRCAT_1:def 8,MOD_2:def 2;
hence thesis;
end;
end;
end;
