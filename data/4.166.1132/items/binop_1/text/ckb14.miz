environ
vocabularies FUNCT_1,XBOOLE_0,ZFMISC_1,SUBSET_1,TARSKI,RELAT_1,PARTFUN1,BINOP_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,CKB1,CKB2,CKB5,CKB6,CKB11,CKB12,CKB13;
definitions FUNCT_1,CKB1,CKB11,CKB12,CKB13;
theorems RELAT_1,FUNCT_1,FUNCT_2,ZFMISC_1,SUBSET_1,CKB1,CKB3,CKB4,CKB11,CKB12,CKB13;
schemes FUNCT_2,PARTFUN1,CKB7,CKB8,CKB9,CKB10;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,RELSET_1;
constructors FUNCT_2,RELSET_1,CKB1,CKB2,CKB11,CKB12,CKB13;
requirements SUBSET,BOOLE;
begin
registration
cluster  ->  empty  associative  commutative for (BinOp of ( {} ));
coherence
proof
let f being (BinOp of ( {} ));
thus f is  empty;
A1: f c= [: ( dom f ),( rng f ) :];
hereby
let a being (Element of ( {} )),b being (Element of ( {} )),c being (Element of ( {} ));
thus ( f . (a,( f . (b,c) )) ) = ( {} ) by A1,FUNCT_1:def 2
.= ( f . (( f . (a,b) ),c) ) by A1,FUNCT_1:def 2;
end;
let a being (Element of ( {} )),b being (Element of ( {} ));
thus ( f . (a,b) ) = ( {} ) by A1,FUNCT_1:def 2
.= ( f . (b,a) ) by A1,FUNCT_1:def 2;
end;
end;
