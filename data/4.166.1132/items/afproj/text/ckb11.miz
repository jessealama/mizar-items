environ
vocabularies DIRAF,SUBSET_1,STRUCT_0,AFF_4,INCSP_1,AFF_1,ANALOAF,RELAT_1,TARSKI,PARSP_1,XBOOLE_0,ARYTM_3,SETFAM_1,ZFMISC_1,EQREL_1,RELAT_2,ANPROJ_1,INCPROJ,MCART_1,FDIFF_1,ANPROJ_2,AFF_2,VECTSP_1,AFPROJ;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,DOMAIN_1,EQREL_1,RELSET_1,RELAT_1,RELAT_2,MCART_1,STRUCT_0,ANALOAF,DIRAF,AFF_1,AFF_4,AFF_2,PAPDESAF,INCSP_1,INCPROJ,CKB7,CKB8;
definitions TARSKI,CKB7,CKB8;
theorems RELAT_1,RELAT_2,TARSKI,ZFMISC_1,MCART_1,EQREL_1,AFF_1,AFF_4,INCPROJ,PAPDESAF,AFF_2,DIRAF,INCSP_1,XBOOLE_0,PARTFUN1,ORDERS_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10;
schemes RELSET_1;
registrations XBOOLE_0,SUBSET_1,RELSET_1,STRUCT_0,INCPROJ;
constructors DOMAIN_1,EQREL_1,AFF_1,AFF_2,TRANSLAC,INCPROJ,AFF_4,RELSET_1,CKB7,CKB8;
requirements SUBSET,BOOLE;
begin
reserve AS for AffinSpace;
reserve K for (Subset of AS);
reserve M for (Subset of AS);
reserve X for (Subset of AS);
reserve Y for (Subset of AS);
reserve Z for (Subset of AS);
reserve X9 for (Subset of AS);
reserve Y9 for (Subset of AS);
reserve x for set;
reserve y for set;
definition
let AS;
func LinesParallelity AS -> (Equivalence_Relation of ( AfLines AS )) equals 
{ [ K,M ]: ((K is  being_line & M is  being_line) & K '||' M) };
coherence
proof
set AFL = ( AfLines AS );
set AFL2 = [: ( AfLines AS ),( AfLines AS ) :];
set R1 = { [ X,Y ]: ((X is  being_line & Y is  being_line) & X '||' Y) };
now
let x;
assume x in R1;
then consider X,Y such that A1: x = [ X,Y ] and A2: X is  being_line and A3: Y is  being_line and X '||' Y;
A4: Y in AFL by A3;
X in AFL by A2;
hence x in AFL2 by A1,A4,ZFMISC_1:def 2;
end;
then reconsider R2 = R1 as (Relation of AFL,AFL) by TARSKI:def 3;
now
let x;
assume x in AFL;
then consider X such that A5: x = X and A6: X is  being_line;
X // X by A6,AFF_1:41;
then X '||' X by A6,AFF_4:40;
hence [ x,x ] in R2 by A5,A6;
end;
then A7: R2 is_reflexive_in AFL by RELAT_2:def 1;
then A8: ( field R2 ) = AFL by ORDERS_1:13;
A9: ((X is  being_line & Y is  being_line) implies ([ X,Y ] in R1 iff X '||' Y))
proof
assume that
A10: X is  being_line
and
A11: Y is  being_line;
now
assume [ X,Y ] in R1;
then consider X9,Y9 such that A12: [ X,Y ] = [ X9,Y9 ] and X9 is  being_line and Y9 is  being_line and A13: X9 '||' Y9;
X = X9 by A12,ZFMISC_1:27;
hence X '||' Y by A12,A13,ZFMISC_1:27;
end;
hence thesis by A10,A11;
end;
now
let x being set;
let y being set;
let z being set;
assume that
A14: x in AFL
and
A15: y in AFL
and
A16: z in AFL
and
A17: [ x,y ] in R2
and
A18: [ y,z ] in R2;
consider Y such that A19: y = Y and A20: Y is  being_line by A15;
consider Z such that A21: z = Z and A22: Z is  being_line by A16;
Y '||' Z by A9,A18,A19,A20,A21,A22;
then A23: Y // Z by A20,A22,AFF_4:40;
consider X such that A24: x = X and A25: X is  being_line by A14;
X '||' Y by A9,A17,A24,A25,A19,A20;
then X // Y by A25,A20,AFF_4:40;
then X // Z by A23,AFF_1:44;
then X '||' Z by A25,A22,AFF_4:40;
hence [ x,z ] in R2 by A24,A25,A21,A22;
end;
then A26: R2 is_transitive_in AFL by RELAT_2:def 8;
now
let x;
let y;
assume that
A27: x in AFL
and
A28: y in AFL
and
A29: [ x,y ] in R2;
consider X such that A30: x = X and A31: X is  being_line by A27;
consider Y such that A32: y = Y and A33: Y is  being_line by A28;
X '||' Y by A9,A29,A30,A31,A32,A33;
then X // Y by A31,A33,AFF_4:40;
then Y '||' X by A31,A33,AFF_4:40;
hence [ y,x ] in R2 by A30,A31,A32,A33;
end;
then A34: R2 is_symmetric_in AFL by RELAT_2:def 3;
( dom R2 ) = AFL by A7,ORDERS_1:13;
hence thesis by A8,A34,A26,PARTFUN1:def 2,RELAT_2:def 11,RELAT_2:def 16;
end;
end;
