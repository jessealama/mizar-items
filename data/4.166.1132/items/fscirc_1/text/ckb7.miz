environ
vocabularies SUBSET_1,MSAFREE2,FACIRC_1,XBOOLEAN,STRUCT_0,LATTICES,CIRCCOMB,CIRCUIT1,XBOOLE_0,MSUALG_1,FINSEQ_1,TWOSCOMP,FUNCT_4,RELAT_1,PARTFUN1,FSM_1,MARGREL1,FUNCT_1,CIRCUIT2,GLIB_000,ARYTM_3,FSCIRC_1;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,RELAT_1,FUNCT_1,FINSEQ_1,STRUCT_0,MARGREL1,NAT_1,MSUALG_1,MSAFREE2,CIRCUIT1,CIRCUIT2,CIRCCOMB,TWOSCOMP,FACIRC_1,BINARITH,CKB1,CKB2,CKB3,CKB4,CKB5;
definitions CIRCUIT2,FACIRC_1,MSAFREE2,CKB1,CKB2,CKB3,CKB4,CKB5;
theorems TARSKI,ENUMSET1,RELAT_1,FUNCT_1,FINSEQ_2,CIRCUIT1,CIRCUIT2,CIRCCOMB,FACIRC_1,TWOSCOMP,XBOOLE_0,XBOOLE_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6;
registrations RELSET_1,CARD_3,STRUCT_0,CIRCCOMB,FACIRC_1,ORDINAL1,FINSEQ_1,FUNCT_1,MSAFREE2;
constructors ENUMSET1,BINARITH,CIRCUIT1,CIRCUIT2,FACIRC_1,TWOSCOMP,NAT_1,RELSET_1,CKB1,CKB2,CKB3,CKB4,CKB5;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve x for set;
reserve y for set;
reserve c for set;
theorem
Th2: (for x,y,c being non  pair set holds ( InputVertices ( BorrowStr (x,y,c) ) ) is  without_pairs)
proof
let x being non  pair set;
let y being non  pair set;
let c being non  pair set;
set M = ( BorrowStr (x,y,c) );
set MI = ( BorrowIStr (x,y,c) );
set S = ( 1GateCircStr (<* [ <* x,y *>,( and2a ) ],[ <* y,c *>,( and2 ) ],[ <* x,c *>,( and2a ) ] *>,( or3 )) );
given xx being  pair set such that
A1: xx in ( InputVertices M );

A2: ( 1GateCircStr (<* x,y *>,( and2a )) ) tolerates ( 1GateCircStr (<* y,c *>,( and2 )) ) by CIRCCOMB:47;
A3: (( InnerVertices ( 1GateCircStr (<* x,c *>,( and2a )) ) ) = { [ <* x,c *>,( and2a ) ] } & ( ( 1GateCircStr (<* x,y *>,( and2a )) ) +* ( 1GateCircStr (<* y,c *>,( and2 )) ) ) tolerates ( 1GateCircStr (<* x,c *>,( and2a )) )) by CIRCCOMB:42,CIRCCOMB:47;
(( InnerVertices ( 1GateCircStr (<* x,y *>,( and2a )) ) ) = { [ <* x,y *>,( and2a ) ] } & ( InnerVertices ( 1GateCircStr (<* y,c *>,( and2 )) ) ) = { [ <* y,c *>,( and2 ) ] }) by CIRCCOMB:42;
then ( InnerVertices ( ( 1GateCircStr (<* x,y *>,( and2a )) ) +* ( 1GateCircStr (<* y,c *>,( and2 )) ) ) ) = ( { [ <* x,y *>,( and2a ) ] } \/ { [ <* y,c *>,( and2 ) ] } ) by A2,CIRCCOMB:11;
then A4: ( InnerVertices MI ) = ( ( { [ <* x,y *>,( and2a ) ] } \/ { [ <* y,c *>,( and2 ) ] } ) \/ { [ <* x,c *>,( and2a ) ] } ) by A3,CIRCCOMB:11
.= ( { [ <* x,y *>,( and2a ) ],[ <* y,c *>,( and2 ) ] } \/ { [ <* x,c *>,( and2a ) ] } ) by ENUMSET1:1
.= { [ <* x,y *>,( and2a ) ],[ <* y,c *>,( and2 ) ],[ <* x,c *>,( and2a ) ] } by ENUMSET1:3;
( InputVertices S ) = { [ <* x,y *>,( and2a ) ],[ <* y,c *>,( and2 ) ],[ <* x,c *>,( and2a ) ] } by FACIRC_1:42;
then A5: ( ( InputVertices S ) \ ( InnerVertices MI ) ) = ( {} ) by A4,XBOOLE_1:37;
(( InputVertices ( 1GateCircStr (<* x,y *>,( and2a )) ) ) is  without_pairs & ( InputVertices ( 1GateCircStr (<* y,c *>,( and2 )) ) ) is  without_pairs) by FACIRC_1:41;
then (( InputVertices ( 1GateCircStr (<* x,c *>,( and2a )) ) ) is  without_pairs & ( InputVertices ( ( 1GateCircStr (<* x,y *>,( and2a )) ) +* ( 1GateCircStr (<* y,c *>,( and2 )) ) ) ) is  without_pairs) by FACIRC_1:9,FACIRC_1:41;
then A6: ( InputVertices MI ) is  without_pairs by FACIRC_1:9;
( InnerVertices S ) is Relation by FACIRC_1:38;
then ( InputVertices M ) = ( ( InputVertices MI ) \/ ( ( InputVertices S ) \ ( InnerVertices MI ) ) ) by A6,FACIRC_1:6;
hence thesis by A6,A1,A5,FACIRC_1:def 2;
end;
