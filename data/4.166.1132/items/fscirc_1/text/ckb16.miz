environ
vocabularies SUBSET_1,MSAFREE2,FACIRC_1,XBOOLEAN,STRUCT_0,LATTICES,CIRCCOMB,CIRCUIT1,XBOOLE_0,MSUALG_1,FINSEQ_1,TWOSCOMP,FUNCT_4,RELAT_1,PARTFUN1,FSM_1,MARGREL1,FUNCT_1,CIRCUIT2,GLIB_000,ARYTM_3,FSCIRC_1;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,RELAT_1,FUNCT_1,FINSEQ_1,STRUCT_0,MARGREL1,NAT_1,MSUALG_1,MSAFREE2,CIRCUIT1,CIRCUIT2,CIRCCOMB,TWOSCOMP,FACIRC_1,BINARITH,CKB1,CKB2,CKB3,CKB4,CKB5,CKB11,CKB12;
definitions CIRCUIT2,FACIRC_1,MSAFREE2,CKB1,CKB2,CKB3,CKB4,CKB5,CKB11,CKB12;
theorems TARSKI,ENUMSET1,RELAT_1,FUNCT_1,FINSEQ_2,CIRCUIT1,CIRCUIT2,CIRCCOMB,FACIRC_1,TWOSCOMP,XBOOLE_0,XBOOLE_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15;
registrations RELSET_1,CARD_3,STRUCT_0,CIRCCOMB,FACIRC_1,ORDINAL1,FINSEQ_1,FUNCT_1,MSAFREE2;
constructors ENUMSET1,BINARITH,CIRCUIT1,CIRCUIT2,FACIRC_1,TWOSCOMP,NAT_1,RELSET_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB11,CKB12;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
theorem
Th9: (for x,y,c being non pair set holds (( InputVertices ( BorrowStr (x,y,c) ) ) = { x,y,c } & ( InnerVertices ( BorrowStr (x,y,c) ) ) = ( { [ <* x,y *>,( and2a ) ],[ <* y,c *>,( and2 ) ],[ <* x,c *>,( and2a ) ] } \/ { ( BorrowOutput (x,y,c) ) } )))
proof
let x being non pair set,y being non pair set,c being non pair set;
set xy = <* x,y *>;
set yc = <* y,c *>;
set xc = <* x,c *>;
set xy1 = [ xy,( and2a ) ];
set yc1 = [ yc,( and2 ) ];
set xc1 = [ xc,( and2a ) ];
set MI = ( BorrowIStr (x,y,c) );
set S = ( 1GateCircStr (<* xy1,yc1,xc1 *>,( or3 )) );
set M = ( BorrowStr (x,y,c) );
A1: (( InputVertices ( 1GateCircStr (<* x,y *>,( and2a )) ) ) = { x,y } & ( InputVertices ( 1GateCircStr (<* x,c *>,( and2a )) ) ) = { x,c }) by FACIRC_1:40;
A2: ( InputVertices ( 1GateCircStr (<* y,c *>,( and2 )) ) ) = { y,c } by FACIRC_1:40;
A3: (( InnerVertices ( 1GateCircStr (<* x,y *>,( and2a )) ) ) = { [ <* x,y *>,( and2a ) ] } & ( InnerVertices ( 1GateCircStr (<* y,c *>,( and2 )) ) ) = { [ <* y,c *>,( and2 ) ] }) by CIRCCOMB:42;
A4: ( InnerVertices S ) is Relation by FACIRC_1:38;
A5: (( InputVertices ( 1GateCircStr (<* x,y *>,( and2a )) ) ) is  without_pairs & ( InputVertices ( 1GateCircStr (<* y,c *>,( and2 )) ) ) is  without_pairs) by FACIRC_1:41;
then A6: (( InputVertices ( 1GateCircStr (<* x,c *>,( and2a )) ) ) is  without_pairs & ( InputVertices ( ( 1GateCircStr (<* x,y *>,( and2a )) ) +* ( 1GateCircStr (<* y,c *>,( and2 )) ) ) ) is  without_pairs) by FACIRC_1:9,FACIRC_1:41;
then ( InputVertices MI ) is  without_pairs by FACIRC_1:9;
then A7: ( InputVertices M ) = ( ( InputVertices MI ) \/ ( ( InputVertices S ) \ ( InnerVertices MI ) ) ) by A4,FACIRC_1:6;
A8: ( InnerVertices ( 1GateCircStr (<* x,c *>,( and2a )) ) ) = { [ <* x,c *>,( and2a ) ] } by CIRCCOMB:42;
( 1GateCircStr (<* x,y *>,( and2a )) ) tolerates ( 1GateCircStr (<* y,c *>,( and2 )) ) by CIRCCOMB:47;
then A9: ( InnerVertices ( ( 1GateCircStr (<* x,y *>,( and2a )) ) +* ( 1GateCircStr (<* y,c *>,( and2 )) ) ) ) = ( { [ <* x,y *>,( and2a ) ] } \/ { [ <* y,c *>,( and2 ) ] } ) by A3,CIRCCOMB:11;
( ( 1GateCircStr (<* x,y *>,( and2a )) ) +* ( 1GateCircStr (<* y,c *>,( and2 )) ) ) tolerates ( 1GateCircStr (<* x,c *>,( and2a )) ) by CIRCCOMB:47;
then A10: ( InnerVertices MI ) = ( ( { [ <* x,y *>,( and2a ) ] } \/ { [ <* y,c *>,( and2 ) ] } ) \/ { [ <* x,c *>,( and2a ) ] } ) by A8,A9,CIRCCOMB:11
.= ( { [ <* x,y *>,( and2a ) ],[ <* y,c *>,( and2 ) ] } \/ { [ <* x,c *>,( and2a ) ] } ) by ENUMSET1:1
.= { [ <* x,y *>,( and2a ) ],[ <* y,c *>,( and2 ) ],[ <* x,c *>,( and2a ) ] } by ENUMSET1:3;
( InputVertices S ) = { [ <* x,y *>,( and2a ) ],[ <* y,c *>,( and2 ) ],[ <* x,c *>,( and2a ) ] } by FACIRC_1:42;
then A11: ( ( InputVertices S ) \ ( InnerVertices MI ) ) = ( {} ) by A10,XBOOLE_1:37;
( InnerVertices ( ( 1GateCircStr (<* x,y *>,( and2a )) ) +* ( 1GateCircStr (<* y,c *>,( and2 )) ) ) ) = { [ <* x,y *>,( and2a ) ],[ <* y,c *>,( and2 ) ] } by A9,ENUMSET1:1;
hence ( InputVertices M ) = ( ( InputVertices ( ( 1GateCircStr (<* x,y *>,( and2a )) ) +* ( 1GateCircStr (<* y,c *>,( and2 )) ) ) ) \/ ( InputVertices ( 1GateCircStr (<* x,c *>,( and2a )) ) ) ) by A6,A7,A8,A11,FACIRC_1:7
.= ( ( ( InputVertices ( 1GateCircStr (<* x,y *>,( and2a )) ) ) \/ ( InputVertices ( 1GateCircStr (<* y,c *>,( and2 )) ) ) ) \/ ( InputVertices ( 1GateCircStr (<* x,c *>,( and2a )) ) ) ) by A5,A3,FACIRC_1:7
.= ( { x,y,y,c } \/ { c,x } ) by A1,A2,ENUMSET1:5
.= ( { y,y,x,c } \/ { c,x } ) by ENUMSET1:67
.= ( { y,x,c } \/ { c,x } ) by ENUMSET1:31
.= ( { x,y,c } \/ { c,x } ) by ENUMSET1:58
.= ( { x,y,c } \/ ( { c } \/ { x } ) ) by ENUMSET1:1
.= ( ( { x,y,c } \/ { c } ) \/ { x } ) by XBOOLE_1:4
.= ( ( { c,x,y } \/ { c } ) \/ { x } ) by ENUMSET1:59
.= ( { c,c,x,y } \/ { x } ) by ENUMSET1:4
.= ( { c,x,y } \/ { x } ) by ENUMSET1:31
.= ( { x,y,c } \/ { x } ) by ENUMSET1:59
.= { x,x,y,c } by ENUMSET1:4
.= { x,y,c } by ENUMSET1:31;
MI tolerates S by CIRCCOMB:47;
hence ( InnerVertices M ) = ( ( InnerVertices MI ) \/ ( InnerVertices S ) ) by CIRCCOMB:11
.= ( { [ <* x,y *>,( and2a ) ],[ <* y,c *>,( and2 ) ],[ <* x,c *>,( and2a ) ] } \/ { ( BorrowOutput (x,y,c) ) } ) by A10,CIRCCOMB:42;
end;
