environ
vocabularies XBOOLE_0,RELAT_1,PBOOLE,SUBSET_1,CAT_5,CAT_1,MCART_1,GRCAT_1,GRAPH_1,STRUCT_0,FUNCT_1,FUNCOP_1,PARTFUN1,ZFMISC_1,ARYTM_0,TARSKI,GROUP_6,CAT_2,FUNCT_3,INDEX_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,MCART_1,RELAT_1,FUNCT_1,FUNCT_2,BINOP_1,PARTFUN1,PBOOLE,FUNCOP_1,STRUCT_0,GRAPH_1,CAT_1,CAT_2,OPPCAT_1,CAT_5,CKB2,CKB5,CKB8,CKB9,CKB13,CKB15,CKB16,CKB22,CKB23,CKB30,CKB31,CKB36,CKB37,CKB39,CKB40,CKB43,CKB44;
definitions TARSKI,FUNCT_1,PBOOLE,CAT_5,FUNCOP_1,CAT_1,BINOP_1,GRAPH_1,CKB5,CKB15,CKB16,CKB22,CKB30,CKB31,CKB37,CKB40,CKB44;
theorems MCART_1,RELAT_1,FUNCT_1,FUNCT_2,FUNCOP_1,PARTFUN1,FUNCT_4,CAT_1,CAT_2,OPPCAT_1,CAT_5,RELSET_1,CKB3,CKB4,CKB5,CKB15,CKB16,CKB21,CKB22,CKB30,CKB31,CKB37,CKB40,CKB41,CKB42,CKB44;
schemes CLASSES1,PBOOLE,CAT_5,CKB38;
registrations XBOOLE_0,RELAT_1,FUNCT_1,FUNCOP_1,PBOOLE,CAT_2,CAT_5,STRUCT_0,RELSET_1,PRE_CIRC,CKB1,CKB6,CKB7,CKB10,CKB11,CKB12,CKB14,CKB17,CKB18,CKB19,CKB20,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB32,CKB33,CKB34,CKB35,CKB45;
constructors PARTFUN1,DOMAIN_1,OPPCAT_1,CAT_5,RELSET_1,PBOOLE,CKB2,CKB5,CKB13,CKB15,CKB16,CKB22,CKB23,CKB30,CKB31,CKB36,CKB37,CKB39,CKB40,CKB43,CKB44;
requirements SUBSET,BOOLE;
begin
definition
let A being non  empty set;
let B being non  empty set;
let F being (Function of B,A);
let G being (Function of B,A);
let c being (PartFunc of [: B,B :],B);
let i being (Function of A,B);
given C being Category such that
A1: C = CatStr (# A,B,F,G,c,i #);

mode Indexing of F,G,c,i
 -> (Indexing of F,G)
means :Def10: ((for a being (Element of A) holds ( ( it `2 ) . ( i . a ) ) = ( id ( ( it `1 ) . a ) )) & (for m1,m2 being (Element of B) holds (( F . m2 ) = ( G . m1 ) implies ( ( it `2 ) . ( c . [ m2,m1 ] ) ) = ( ( ( it `2 ) . m2 ) * ( ( it `2 ) . m1 ) ))));
existence
proof
set I2 = ( B --> ( id C ) );
set I1 = ( A --> C );
A2: ( [ I1,I2 ] `1 ) = I1 by MCART_1:7;
A3: ( [ I1,I2 ] `2 ) = I2 by MCART_1:7;
I2 is (ManySortedFunctor of ( I1 * F ),( I1 * G ))
proof
let a being (Element of B);
(( I1 . ( F . a ) ) = C & ( dom ( I1 * F ) ) = B) by FUNCOP_1:7,PARTFUN1:def 2;
then A4: (( I2 . a ) = ( id C ) & ( ( I1 * F ) . a ) = C) by FUNCOP_1:7,FUNCT_1:12;
(( I1 . ( G . a ) ) = C & ( dom ( I1 * G ) ) = B) by FUNCOP_1:7,PARTFUN1:def 2;
hence thesis by A4,FUNCT_1:12;
end;
then reconsider I = [ I1,I2 ] as (Indexing of F,G) by A2,A3,CKB40:def 1;
take I;
hereby
let a being (Element of A);
thus ( ( I `2 ) . ( i . a ) ) = ( id C ) by A3,FUNCOP_1:7
.= ( id ( ( I `1 ) . a ) ) by A2,FUNCOP_1:7;
end;
let m1 being (Element of B);
let m2 being (Element of B);
assume ( F . m2 ) = ( G . m1 );
then [ m2,m1 ] in ( dom c ) by A1,CAT_1:def 5;
then A5: ( ( I `2 ) . ( c . [ m2,m1 ] ) ) = ( id C ) by A3,FUNCOP_1:7,PARTFUN1:4;
(( ( I `2 ) . m1 ) = ( id C ) & ( ( I `2 ) . m2 ) = ( id C )) by A3,FUNCOP_1:7;
hence thesis by A5,FUNCT_2:17;
end;
end;
