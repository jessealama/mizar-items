environ
vocabularies NUMBERS,INT_1,FINSEQ_1,SUBSET_1,FSM_1,AMI_3,PARTFUN1,AMI_1,SCMNORM,RELAT_1,FUNCT_1,CIRCUIT2,MSUALG_1,ARYTM_3,XXREAL_0,CARD_1,TARSKI,AFINSQ_1,AMI_2,ORDINAL4,GRAPHSP,ARYTM_1,SCM_1,STRUCT_0,ORDINAL1,RECDEF_2,FUNCT_4,CAT_1;
notations TARSKI,SUBSET_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,VALUED_1,MCART_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FINSEQ_1,XXREAL_0,AFINSQ_1,FUNCT_4,RECDEF_2,AMI_2,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_3,CKB1,CKB2;
definitions TARSKI,AFINSQ_1,COMPOS_1,EXTPRO_1,NAT_1,AMI_3,FUNCOP_1,RELAT_1,FUNCT_1,MEMSTR_0,CKB2;
theorems NAT_1,INT_1,FUNCT_1,FUNCT_2,FINSEQ_1,AMI_2,AMI_3,FINSEQ_3,RELSET_1,RELAT_1,AFINSQ_1,PARTFUN1,RECDEF_2,COMPOS_1,FUNCT_4,FUNCOP_1,TARSKI,EXTPRO_1,GRFUNC_1,CARD_1,XCMPLX_1,MEMSTR_0,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22;
schemes PARTFUN1;
registrations XBOOLE_0,SETFAM_1,ORDINAL1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,AMI_3,AMI_2,AFINSQ_1,RELAT_1,COMPOS_1,PBOOLE,FINSEQ_1,STRUCT_0,VALUED_0,FUNCT_4,MEMSTR_0,CKB3;
constructors XXREAL_0,AMI_3,RELSET_1,AMI_2,AFINSQ_1,ORDINAL4,PRE_POLY,RECDEF_2,AMISTD_2,MEMSTR_0,CKB1,CKB2;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
theorem
(for F being  total ( NAT ) -defined (the Instructions of ( SCM )) -valued Function holds (( <% ( Divide (( dl. ( 0 ) ),( dl. 1 )) ) %> ^ <% ( halt ( SCM ) ) %> ) c= F implies (for i1,i2 being Integer holds (for s being ( 0 ) -started (State-consisting of ( 0 ),( <* i1 *> ^ <* i2 *> )) holds ((((F halts_on s & ( LifeSpan (F,s) ) = 1) & ( ( Result (F,s) ) . ( dl. ( 0 ) ) ) = ( i1 div i2 )) & ( ( Result (F,s) ) . ( dl. 1 ) ) = ( i1 mod i2 )) & (for d being Data-Location holds ((d <> ( dl. ( 0 ) ) & d <> ( dl. 1 )) implies ( ( Result (F,s) ) . d ) = ( s . d ))))))))
proof
let F being  total ( NAT ) -defined (the Instructions of ( SCM )) -valued Function;
assume that
A1: ( <% ( Divide (( dl. ( 0 ) ),( dl. 1 )) ) %> ^ <% ( halt ( SCM ) ) %> ) c= F;
let i1 being Integer,i2 being Integer;
let s being ( 0 ) -started (State-consisting of ( 0 ),( <* i1 *> ^ <* i2 *> ));
set s1 = ( Comput (F,s,( ( 0 ) + 1 )) );
A2: ( dl. ( 0 ) ) <> ( dl. 1 ) by AMI_3:10;
A3: (( IC s ) = ( 0 ) & ( F . ( 0 ) ) = ( Divide (( dl. ( 0 ) ),( dl. 1 )) )) by A1,CKB6:1,MEMSTR_0:def 8;
A4: (( s . ( dl. ( 0 ) ) ) = i1 & ( s . ( dl. 1 ) ) = i2) by CKB5:1;
A5: s = ( Comput (F,s,( 0 )) ) by EXTPRO_1:2;
( F . 1 ) = ( halt ( SCM ) ) by A1,CKB6:1;
then A6: ( F . ( IC s1 ) ) = ( halt ( SCM ) ) by A3,A2,A5,CKB12:1;
hence F halts_on s by EXTPRO_1:30;
( Divide (( dl. ( 0 ) ),( dl. 1 )) ) <> ( halt ( SCM ) ) by CKB16:1;
hence ( LifeSpan (F,s) ) = 1 by A3,A5,A6,EXTPRO_1:32;
thus ( ( Result (F,s) ) . ( dl. ( 0 ) ) ) = ( s1 . ( dl. ( 0 ) ) ) by A6,EXTPRO_1:31
.= ( i1 div i2 ) by A3,A4,A2,A5,CKB12:1;
thus ( ( Result (F,s) ) . ( dl. 1 ) ) = ( s1 . ( dl. 1 ) ) by A6,EXTPRO_1:31
.= ( i1 mod i2 ) by A3,A4,A2,A5,CKB12:1;
let d being Data-Location;
assume A7: (d <> ( dl. ( 0 ) ) & d <> ( dl. 1 ));
thus ( ( Result (F,s) ) . d ) = ( s1 . d ) by A6,EXTPRO_1:31
.= ( s . d ) by A3,A2,A5,A7,CKB12:1;
end;
