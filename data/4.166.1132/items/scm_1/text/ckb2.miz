environ
vocabularies NUMBERS,INT_1,FINSEQ_1,SUBSET_1,FSM_1,AMI_3,PARTFUN1,AMI_1,SCMNORM,RELAT_1,FUNCT_1,CIRCUIT2,MSUALG_1,ARYTM_3,XXREAL_0,CARD_1,TARSKI,AFINSQ_1,AMI_2,ORDINAL4,GRAPHSP,ARYTM_1,SCM_1,STRUCT_0,ORDINAL1,RECDEF_2,FUNCT_4,CAT_1;
notations TARSKI,SUBSET_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,VALUED_1,MCART_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FINSEQ_1,XXREAL_0,AFINSQ_1,FUNCT_4,RECDEF_2,AMI_2,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_3,CKB1;
definitions TARSKI,AFINSQ_1,COMPOS_1,EXTPRO_1,NAT_1,AMI_3,FUNCOP_1,RELAT_1,FUNCT_1,MEMSTR_0;
theorems NAT_1,INT_1,FUNCT_1,FUNCT_2,FINSEQ_1,AMI_2,AMI_3,FINSEQ_3,RELSET_1,RELAT_1,AFINSQ_1,PARTFUN1,RECDEF_2,COMPOS_1,FUNCT_4,FUNCOP_1,TARSKI,EXTPRO_1,GRFUNC_1,CARD_1,XCMPLX_1,MEMSTR_0;
schemes PARTFUN1;
registrations XBOOLE_0,SETFAM_1,ORDINAL1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,AMI_3,AMI_2,AFINSQ_1,RELAT_1,COMPOS_1,PBOOLE,FINSEQ_1,STRUCT_0,VALUED_0,FUNCT_4,MEMSTR_0;
constructors XXREAL_0,AMI_3,RELSET_1,AMI_2,AFINSQ_1,ORDINAL4,PRE_POLY,RECDEF_2,AMISTD_2,MEMSTR_0,CKB1;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
definition
let D being (FinSequence of ( INT ));
let ds being (Element of ( NAT ));
mode State-consisting of ds,D
 -> (State of ( SCM ))
means :Def1: (for k being (Element of ( NAT )) holds (k < ( len D ) implies ( it . ( dl. ( ds + k ) ) ) = ( D . ( k + 1 ) )));
existence
proof
defpred P[ set,set ]
 means
(ex k being (Element of ( NAT )) st ($1 = ( dl. ( ds + k ) ) & $2 = ( D . ( k + 1 ) )));
X: (for x,y being set holds ((x in (the carrier of ( SCM )) & P[ x,y ]) implies y in ( INT ))) by INT_1:def 2;
Y: (for x,y1,y2 being set holds (((x in (the carrier of ( SCM )) & P[ x,y1 ]) & P[ x,y2 ]) implies y1 = y2))
proof
let x being set;
let y1 being set;
let y2 being set;
assume that
x in (the carrier of ( SCM ))
and
W2: P[ x,y1 ]
and
W3: P[ x,y2 ];
consider k1 being (Element of ( NAT )) such that W4: x = ( dl. ( ds + k1 ) ) and W5: y1 = ( D . ( k1 + 1 ) ) by W2;
consider k2 being (Element of ( NAT )) such that W6: x = ( dl. ( ds + k2 ) ) and W7: y2 = ( D . ( k2 + 1 ) ) by W3;
( ds + k1 ) = ( ds + k2 ) by W4,W6,AMI_3:10;
hence y1 = y2 by W7,W5;
end;
consider p being (PartFunc of ( SCM ),( INT )) such that W0: (for x being set holds (x in ( dom p ) iff (x in (the carrier of ( SCM )) & (ex y being set st P[ x,y ])))) and W1: (for x being set holds (x in ( dom p ) implies P[ x,( p . x ) ])) from PARTFUN1:sch 2(X,Y);
C: p is (the carrier of ( SCM )) -defined
proof
let e being set;
thus thesis by W0;
end;
p is (the Object-Kind of ( SCM )) -compatible
proof
let e being set;
assume Z: e in ( dom p );
then AA: (ex y being set st P[ e,y ]) by W0;
reconsider o = e as (Object of ( SCM )) by Z,W0;
B: ( ObjectKind o ) = ( INT ) by AA,AMI_3:11;
consider k being (Element of ( NAT )) such that W3: (o = ( dl. ( ds + k ) ) & ( p . o ) = ( D . ( k + 1 ) )) by W1,Z;
thus ( p . e ) in ( (the Object-Kind of ( SCM )) . e ) by B,W3,INT_1:def 2;
end;
then reconsider p as (PartState of ( SCM )) by C;
take s = ( the (State of ( SCM )) +* p );
let k being (Element of ( NAT ));
assume k < ( len D );
(ex i being (Element of ( NAT )) st (( dl. ( ds + k ) ) = ( dl. ( ds + i ) ) & ( D . ( k + 1 ) ) = ( D . ( i + 1 ) )));
then X: ( dl. ( ds + k ) ) in ( dom p ) by W0;
then consider i being (Element of ( NAT )) such that W2: (( dl. ( ds + k ) ) = ( dl. ( ds + i ) ) & ( p . ( dl. ( ds + k ) ) ) = ( D . ( i + 1 ) )) by W1;
A: ( ds + k ) = ( ds + i ) by W2,AMI_3:10;
p c= s by FUNCT_4:25;
hence ( s . ( dl. ( ds + k ) ) ) = ( D . ( k + 1 ) ) by A,W2,X,GRFUNC_1:2;
end;
end;
