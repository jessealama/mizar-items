environ
vocabularies NUMBERS,INT_1,FINSEQ_1,SUBSET_1,FSM_1,AMI_3,PARTFUN1,AMI_1,SCMNORM,RELAT_1,FUNCT_1,CIRCUIT2,MSUALG_1,ARYTM_3,XXREAL_0,CARD_1,TARSKI,AFINSQ_1,AMI_2,ORDINAL4,GRAPHSP,ARYTM_1,SCM_1,STRUCT_0,ORDINAL1,RECDEF_2,FUNCT_4,CAT_1;
notations TARSKI,SUBSET_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,VALUED_1,MCART_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FINSEQ_1,XXREAL_0,AFINSQ_1,FUNCT_4,RECDEF_2,AMI_2,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_3,CKB1,CKB2;
definitions TARSKI,AFINSQ_1,COMPOS_1,EXTPRO_1,NAT_1,AMI_3,FUNCOP_1,RELAT_1,FUNCT_1,MEMSTR_0,CKB2;
theorems NAT_1,INT_1,FUNCT_1,FUNCT_2,FINSEQ_1,AMI_2,AMI_3,FINSEQ_3,RELSET_1,RELAT_1,AFINSQ_1,PARTFUN1,RECDEF_2,COMPOS_1,FUNCT_4,FUNCOP_1,TARSKI,EXTPRO_1,GRFUNC_1,CARD_1,XCMPLX_1,MEMSTR_0,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16;
schemes PARTFUN1;
registrations XBOOLE_0,SETFAM_1,ORDINAL1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,AMI_3,AMI_2,AFINSQ_1,RELAT_1,COMPOS_1,PBOOLE,FINSEQ_1,STRUCT_0,VALUED_0,FUNCT_4,MEMSTR_0,CKB3;
constructors XXREAL_0,AMI_3,RELSET_1,AMI_2,AFINSQ_1,ORDINAL4,PRE_POLY,RECDEF_2,AMISTD_2,MEMSTR_0,CKB1,CKB2;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
theorem
(for i1,i2,i3,i4 being Integer holds (for s being (State of ( SCM )) holds ((((( s . ( dl. ( 0 ) ) ) = i1 & ( s . ( dl. 1 ) ) = i2) & ( s . ( dl. 2 ) ) = i3) & ( s . ( dl. 3 ) ) = i4) implies s is (State-consisting of ( 0 ),( ( ( <* i1 *> ^ <* i2 *> ) ^ <* i3 *> ) ^ <* i4 *> )))))
proof
let i1 being Integer;
let i2 being Integer;
let i3 being Integer;
let i4 being Integer;
let s being (State of ( SCM ));
assume that
A1: (((( s . ( dl. ( 0 ) ) ) = i1 & ( s . ( dl. 1 ) ) = i2) & ( s . ( dl. 2 ) ) = i3) & ( s . ( dl. 3 ) ) = i4);
set D = ( ( ( <* i1 *> ^ <* i2 *> ) ^ <* i3 *> ) ^ <* i4 *> );
now
let k being (Element of ( NAT ));
A2: (( len D ) = 4 & 4 = ( 3 + 1 )) by FINSEQ_1:66;
A3: 3 = ( 2 + 1 );
assume k < ( len D );
then k <= 3 by A2,NAT_1:13;
then A4: (k <= 2 or k = 3) by A3,NAT_1:8;
A5: 1 = ( ( 0 ) + 1 );
2 = ( 1 + 1 );
then ((k <= 1 or k = 2) or k = 3) by A4,NAT_1:8;
then (((k = ( 0 ) or k = 1) or k = 2) or k = 3) by A5,NAT_1:8;
hence ( s . ( dl. ( ( 0 ) + k ) ) ) = ( D . ( k + 1 ) ) by A1,FINSEQ_1:66;
end;
hence thesis by CKB2:def 1;
end;
