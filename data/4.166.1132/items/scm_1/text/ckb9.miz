environ
vocabularies NUMBERS,INT_1,FINSEQ_1,SUBSET_1,FSM_1,AMI_3,PARTFUN1,AMI_1,SCMNORM,RELAT_1,FUNCT_1,CIRCUIT2,MSUALG_1,ARYTM_3,XXREAL_0,CARD_1,TARSKI,AFINSQ_1,AMI_2,ORDINAL4,GRAPHSP,ARYTM_1,SCM_1,STRUCT_0,ORDINAL1,RECDEF_2,FUNCT_4,CAT_1;
notations TARSKI,SUBSET_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,VALUED_1,MCART_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FINSEQ_1,XXREAL_0,AFINSQ_1,FUNCT_4,RECDEF_2,AMI_2,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_3,CKB1,CKB2;
definitions TARSKI,AFINSQ_1,COMPOS_1,EXTPRO_1,NAT_1,AMI_3,FUNCOP_1,RELAT_1,FUNCT_1,MEMSTR_0,CKB2;
theorems NAT_1,INT_1,FUNCT_1,FUNCT_2,FINSEQ_1,AMI_2,AMI_3,FINSEQ_3,RELSET_1,RELAT_1,AFINSQ_1,PARTFUN1,RECDEF_2,COMPOS_1,FUNCT_4,FUNCOP_1,TARSKI,EXTPRO_1,GRFUNC_1,CARD_1,XCMPLX_1,MEMSTR_0,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8;
schemes PARTFUN1;
registrations XBOOLE_0,SETFAM_1,ORDINAL1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,AMI_3,AMI_2,AFINSQ_1,RELAT_1,COMPOS_1,PBOOLE,FINSEQ_1,STRUCT_0,VALUED_0,FUNCT_4,MEMSTR_0,CKB3;
constructors XXREAL_0,AMI_3,RELSET_1,AMI_2,AFINSQ_1,ORDINAL4,PRE_POLY,RECDEF_2,AMISTD_2,MEMSTR_0,CKB1,CKB2;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve F for  total ( NAT ) -defined (the Instructions of ( SCM )) -valued Function;
Lm4:now
let F being  total ( NAT ) -defined (the Instructions of ( SCM )) -valued Function;
let k being (Element of ( NAT ));
let n being (Element of ( NAT ));
let s being (State of ( SCM ));
let a being Data-Location;
let b being Data-Location;
assume A1: ( IC ( Comput (F,s,k) ) ) = n;
set csk1 = ( Comput (F,s,( k + 1 )) );
set csk = ( Comput (F,s,k) );
assume A2: ((((( F . n ) = ( a := b ) or ( F . n ) = ( AddTo (a,b) )) or ( F . n ) = ( SubFrom (a,b) )) or ( F . n ) = ( MultBy (a,b) )) or (a <> b & ( F . n ) = ( Divide (a,b) )));
A3: ( dom F ) = ( NAT ) by PARTFUN1:def 2;
thus csk1 = ( Exec (( CurInstr (F,csk) ),csk) ) by CKB7:1
.= ( Exec (( F . n ),csk) ) by A1,A3,PARTFUN1:def 6;
hence ( IC csk1 ) = ( succ ( IC csk ) ) by A2,AMI_3:2,AMI_3:3,AMI_3:4,AMI_3:5,AMI_3:6
.= ( n + 1 ) by A1;
end;
theorem
Th19: (for k,n being (Element of ( NAT )) holds (for s being (State of ( SCM )) holds (for a,b being Data-Location holds ((( IC ( Comput (F,s,k) ) ) = n & ( F . n ) = ( AddTo (a,b) )) implies ((( IC ( Comput (F,s,( k + 1 )) ) ) = ( n + 1 ) & ( ( Comput (F,s,( k + 1 )) ) . a ) = ( ( ( Comput (F,s,k) ) . a ) + ( ( Comput (F,s,k) ) . b ) )) & (for d being Data-Location holds (d <> a implies ( ( Comput (F,s,( k + 1 )) ) . d ) = ( ( Comput (F,s,k) ) . d ))))))))
proof
let k being (Element of ( NAT ));
let n being (Element of ( NAT ));
let s being (State of ( SCM ));
let a being Data-Location;
let b being Data-Location;
assume A1: ( IC ( Comput (F,s,k) ) ) = n;
assume A2: ( F . n ) = ( AddTo (a,b) );
then ( Comput (F,s,( k + 1 )) ) = ( Exec (( AddTo (a,b) ),( Comput (F,s,k) )) ) by A1,Lm4;
hence thesis by A1,A2,Lm4,AMI_3:3;
end;
