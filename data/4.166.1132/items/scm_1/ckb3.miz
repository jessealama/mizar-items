environ
vocabularies NUMBERS,INT_1,FINSEQ_1,SUBSET_1,FSM_1,AMI_3,PARTFUN1,AMI_1,SCMNORM,RELAT_1,FUNCT_1,CIRCUIT2,MSUALG_1,ARYTM_3,XXREAL_0,CARD_1,TARSKI,AFINSQ_1,AMI_2,ORDINAL4,GRAPHSP,ARYTM_1,SCM_1,STRUCT_0,ORDINAL1,RECDEF_2,FUNCT_4,CAT_1;
notations TARSKI,SUBSET_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,VALUED_1,MCART_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FINSEQ_1,XXREAL_0,AFINSQ_1,FUNCT_4,RECDEF_2,AMI_2,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_3,CKB1,CKB2;
definitions TARSKI,AFINSQ_1,COMPOS_1,EXTPRO_1,NAT_1,AMI_3,FUNCOP_1,RELAT_1,FUNCT_1,MEMSTR_0,CKB2;
theorems NAT_1,INT_1,FUNCT_1,FUNCT_2,FINSEQ_1,AMI_2,AMI_3,FINSEQ_3,RELSET_1,RELAT_1,AFINSQ_1,PARTFUN1,RECDEF_2,COMPOS_1,FUNCT_4,FUNCOP_1,TARSKI,EXTPRO_1,GRFUNC_1,CARD_1,XCMPLX_1,MEMSTR_0,CKB2;
schemes PARTFUN1;
registrations XBOOLE_0,SETFAM_1,ORDINAL1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,AMI_3,AMI_2,AFINSQ_1,RELAT_1,COMPOS_1,PBOOLE,FINSEQ_1,STRUCT_0,VALUED_0,FUNCT_4,MEMSTR_0;
constructors XXREAL_0,AMI_3,RELSET_1,AMI_2,AFINSQ_1,ORDINAL4,PRE_POLY,RECDEF_2,AMISTD_2,MEMSTR_0,CKB1,CKB2;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
registration
let D being (FinSequence of ( INT ));
let il being (Element of ( NAT ));
let ds being (Element of ( NAT ));
cluster il -started for (State-consisting of ds,D);
existence
proof
set s = the (State-consisting of ds,D);
set s1 = ( s +* ( Start-At (il,( SCM )) ) );
(for k being (Element of ( NAT )) holds (k < ( len D ) implies ( s1 . ( dl. ( ds + k ) ) ) = ( D . ( k + 1 ) )))
proof
let k being (Element of ( NAT ));
assume A1: k < ( len D );
A2: ( dom ( Start-At (il,( SCM )) ) ) = { ( IC ( SCM ) ) } by FUNCOP_1:13;
( dl. ( ds + k ) ) <> ( IC ( SCM ) ) by AMI_3:13;
then (not ( dl. ( ds + k ) ) in ( dom ( Start-At (il,( SCM )) ) )) by A2,TARSKI:def 1;
hence ( s1 . ( dl. ( ds + k ) ) ) = ( s . ( dl. ( ds + k ) ) ) by FUNCT_4:11
.= ( D . ( k + 1 ) ) by A1,CKB2:def 1;
end;
then reconsider s1 as (State-consisting of ds,D) by CKB2:def 1;
take s1;
thus ( IC s1 ) = il by MEMSTR_0:16;
end;
end;
