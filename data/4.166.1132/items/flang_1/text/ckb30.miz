environ
vocabularies NUMBERS,SUBSET_1,AFINSQ_1,NAT_1,ORDINAL4,XBOOLE_0,TARSKI,RELAT_1,FUNCT_1,ZFMISC_1,XXREAL_0,ARYTM_3,CARD_1,FINSEQ_1,PRE_POLY,NEWTON,SETFAM_1,FLANG_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,XCMPLX_0,NAT_1,FUNCT_1,RELSET_1,FUNCT_2,SETFAM_1,XXREAL_0,AFINSQ_1,CATALAN2,CKB1,CKB2,CKB3,CKB4,CKB5,CKB18;
definitions TARSKI,CKB18;
theorems AFINSQ_1,NAT_1,ORDINAL1,SUBSET_1,TARSKI,XBOOLE_0,XBOOLE_1,XREAL_1,ZFMISC_1,XXREAL_0,FUNCT_2,RELAT_1,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29;
schemes CARD_FIL,DOMAIN_1,NAT_1,RECDEF_1,SUBSET_1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,ORDINAL1,XXREAL_0,XREAL_0,NAT_1,AFINSQ_1,CATALAN2,FUNCT_1,RELSET_1;
constructors XXREAL_0,XREAL_0,NAT_1,CATALAN2,RELSET_1,ORDINAL4,CKB1,CKB2,CKB3,CKB4,CKB5,CKB18;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve E for set;
reserve x for set;
reserve A for (Subset of ( E ^omega ));
reserve B for (Subset of ( E ^omega ));
reserve C for (Subset of ( E ^omega ));
reserve i for Nat;
reserve k for Nat;
reserve n for Nat;
definition
let E;
let A;
let n;
func A |^ n -> (Subset of ( E ^omega )) means 
:Def2: (ex concat being (Function of ( NAT ),( bool ( E ^omega ) )) st ((it = ( concat . n ) & ( concat . ( 0 ) ) = { ( <%> E ) }) & (for i holds ( concat . ( i + 1 ) ) = ( ( concat . i ) ^^ A ))));
existence
proof
defpred P[ set,set,set ]
 means
(ex B st (ex C st ((C = $3 & B = $2) & C = ( B ^^ A ))));
A1: (for i being (Element of ( NAT )) holds (for x being (Element of ( bool ( E ^omega ) )) holds (ex y being (Element of ( bool ( E ^omega ) )) st P[ i,x,y ])))
proof
let i being (Element of ( NAT ));
let x being (Element of ( bool ( E ^omega ) ));
take ( x ^^ A );
thus thesis;
end;
consider f being (Function of ( NAT ),( bool ( E ^omega ) )) such that A2: (( f . ( 0 ) ) = { ( <%> E ) } & (for i being (Element of ( NAT )) holds P[ i,( f . i ),( f . ( i + 1 ) ) ])) from RECDEF_1:sch 2(A1);
consider C being (Subset of ( E ^omega )) such that A3: C = ( f . n );
take C;
now
let i;
reconsider j = i as (Element of ( NAT )) by ORDINAL1:def 12;
(ex B st (ex C st ((C = ( f . ( j + 1 ) ) & B = ( f . j )) & C = ( B ^^ A )))) by A2;
hence ( f . ( i + 1 ) ) = ( ( f . i ) ^^ A );
end;
hence thesis by A2,A3;
end;
uniqueness
proof
let C1 being (Subset of ( E ^omega ));
let C2 being (Subset of ( E ^omega ));
given f1 being (Function of ( NAT ),( bool ( E ^omega ) )) such that
A4: C1 = ( f1 . n )
and
A5: ( f1 . ( 0 ) ) = { ( <%> E ) }
and
A6: (for i holds ( f1 . ( i + 1 ) ) = ( ( f1 . i ) ^^ A ));

given f2 being (Function of ( NAT ),( bool ( E ^omega ) )) such that
A7: C2 = ( f2 . n )
and
A8: ( f2 . ( 0 ) ) = { ( <%> E ) }
and
A9: (for i holds ( f2 . ( i + 1 ) ) = ( ( f2 . i ) ^^ A ));

defpred P[ Nat ]
 means
( f1 . $1 ) = ( f2 . $1 );
A10:now
let k;
assume A11: P[ k ];
( f2 . ( k + 1 ) ) = ( ( f2 . k ) ^^ A ) by A9;
hence P[ ( k + 1 ) ] by A6,A11;
end;
A12: P[ ( 0 ) ] by A5,A8;
(for k holds P[ k ]) from NAT_1:sch 2(A12,A10);
hence thesis by A4,A7;
end;
end;
