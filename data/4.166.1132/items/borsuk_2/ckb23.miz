environ
vocabularies NUMBERS,XBOOLE_0,PRE_TOPC,XREAL_0,ORDINAL1,CARD_1,XXREAL_0,STRUCT_0,BORSUK_1,XXREAL_1,REAL_1,SUBSET_1,TARSKI,FUNCT_1,RELAT_1,RCOMP_1,ORDINAL2,FUNCT_4,TOPS_2,FUNCOP_1,GRAPH_1,RELAT_2,ARYTM_3,ARYTM_1,TOPMETR,TREAL_1,VALUED_1,SETFAM_1,ZFMISC_1,PCOMPS_1,MCART_1,CONNSP_2,TOPS_1,BORSUK_2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,SETFAM_1,ORDINAL1,CARD_1,NUMBERS,XXREAL_0,XREAL_0,REAL_1,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,DOMAIN_1,STRUCT_0,PRE_TOPC,TOPS_2,MCART_1,RCOMP_1,PCOMPS_1,TOPS_1,COMPTS_1,CONNSP_1,CONNSP_2,TREAL_1,FUNCT_4,BORSUK_1,T_0TOPSP,TOPMETR,BINOP_1,FUNCT_3,CKB8,CKB9,CKB10,CKB12,CKB14,CKB20;
definitions TARSKI,PRE_TOPC,COMPTS_1,URYSOHN1,T_0TOPSP,XBOOLE_0,BINOP_1,STRUCT_0,BORSUK_1,CKB8,CKB10,CKB12,CKB14,CKB20;
theorems BORSUK_1,FUNCOP_1,TOPS_2,TREAL_1,FUNCT_2,FUNCT_1,PRE_TOPC,RCOMP_1,TARSKI,RELAT_1,TOPS_1,URYSOHN1,TOPMETR,FUNCT_4,HEINE,PCOMPS_1,MCART_1,ZFMISC_1,CONNSP_2,FUNCT_3,COMPTS_1,T_0TOPSP,CARD_1,RELSET_1,XBOOLE_0,XBOOLE_1,XREAL_0,XREAL_1,CONNSP_1,XXREAL_1,XXREAL_2,CKB1,CKB3,CKB6,CKB7,CKB8,CKB10,CKB12,CKB14,CKB16,CKB17,CKB19,CKB20,CKB22;
schemes FUNCT_2,FUNCT_1,CKB2;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,FUNCT_2,XREAL_0,MEMBERED,STRUCT_0,PRE_TOPC,COMPTS_1,METRIC_1,BORSUK_1,RELAT_1,XXREAL_2,TOPS_1,CONNSP_1,TOPMETR,RELSET_1,CKB4,CKB5,CKB11,CKB13,CKB15,CKB18,CKB21;
constructors SETFAM_1,FUNCT_3,FUNCT_4,REAL_1,MEMBERED,RCOMP_1,TOPS_1,CONNSP_1,TOPS_2,COMPTS_1,URYSOHN1,T_0TOPSP,TREAL_1,FUNCOP_1,PCOMPS_1,XXREAL_2,COMPLEX1,CKB8,CKB9,CKB10,CKB12,CKB20;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve r for Real;
theorem
Th7: (for T being non empty TopSpace holds (for a being (Point of T) holds (for P being  constant (Path of a,a) holds ( P + P ) = P)))
proof
let T being non empty TopSpace;
let a being (Point of T);
let P being  constant (Path of a,a);
A1: (the carrier of ( I[01] )) = ( dom P ) by FUNCT_2:def 1;
A2: (for x being set holds (x in (the carrier of ( I[01] )) implies ( P . x ) = ( ( P + P ) . x )))
proof
let x being set;
assume A3: x in (the carrier of ( I[01] ));
then reconsider p = x as (Point of ( I[01] ));
x in { r: (( 0 ) <= r & r <= 1) } by A3,BORSUK_1:40,RCOMP_1:def 1;
then consider r being Real such that A4: r = x and A5: ( 0 ) <= r and A6: r <= 1;
per cases ;
suppose A7: r < ( 1 / 2 );

then A8: ( r * 2 ) < ( ( 1 / 2 ) * 2 ) by XREAL_1:68;
( 2 * r ) >= ( 0 ) by A5,XREAL_1:127;
then ( 2 * r ) in { e where e is Real: (( 0 ) <= e & e <= 1) } by A8;
then ( 2 * r ) in (the carrier of ( I[01] )) by BORSUK_1:40,RCOMP_1:def 1;
then ( P . ( 2 * r ) ) = ( P . p ) by A1,FUNCT_1:def 10;
hence thesis by A4,A7,CKB20:def 1;
end;
suppose A9: r >= ( 1 / 2 );

then ( r * 2 ) >= ( ( 1 / 2 ) * 2 ) by XREAL_1:64;
then ( 2 * r ) >= ( 1 + ( 0 ) );
then A10: ( ( 2 * r ) - 1 ) >= ( 0 ) by XREAL_1:19;
( r * 2 ) <= ( 1 * 2 ) by A6,XREAL_1:64;
then ( ( 2 * r ) - 1 ) <= ( 2 - 1 ) by XREAL_1:13;
then ( ( 2 * r ) - 1 ) in { e where e is Real: (( 0 ) <= e & e <= 1) } by A10;
then ( ( 2 * r ) - 1 ) in (the carrier of ( I[01] )) by BORSUK_1:40,RCOMP_1:def 1;
then ( P . ( ( 2 * r ) - 1 ) ) = ( P . p ) by A1,FUNCT_1:def 10;
hence thesis by A4,A9,CKB20:def 1;
end;
end;
( dom ( P + P ) ) = (the carrier of ( I[01] )) by FUNCT_2:def 1;
hence thesis by A1,A2,FUNCT_1:2;
end;
