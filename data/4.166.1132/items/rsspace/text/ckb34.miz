environ
vocabularies NUMBERS,XBOOLE_0,SEQ_1,FUNCT_2,TARSKI,REAL_1,BINOP_1,SUBSET_1,FUNCT_1,ARYTM_3,ZFMISC_1,VALUED_1,CARD_1,FUNCOP_1,NAT_1,RLVECT_1,RELAT_1,SUPINF_2,ARYTM_1,STRUCT_0,ALGSTR_0,XREAL_0,ORDINAL1,RLSUB_1,REALSET1,SERIES_1,XXREAL_0,SQUARE_1,CARD_3,BHSP_1,COMPLEX1,SEQ_2,ORDINAL2,XXREAL_2,VALUED_0,RSSPACE;
notations TARSKI,SUBSET_1,XBOOLE_0,ZFMISC_1,ORDINAL1,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,COMPLEX1,STRUCT_0,ALGSTR_0,REAL_1,NAT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,REALSET1,FUNCOP_1,RLVECT_1,RLSUB_1,BHSP_1,SQUARE_1,VALUED_1,SEQ_1,SEQ_2,SERIES_1,BINOP_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB18,CKB21,CKB22,CKB23,CKB25,CKB30,CKB32;
definitions SQUARE_1,BINOP_1,TARSKI,RLVECT_1,XBOOLE_0,REALSET1,STRUCT_0,ALGSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB18,CKB21,CKB22,CKB23,CKB25,CKB30,CKB32;
theorems XBOOLE_0,RELAT_1,TARSKI,ABSVALUE,ZFMISC_1,SEQ_1,SEQ_2,SEQM_3,SERIES_1,COMSEQ_3,INT_1,FUNCT_1,NAT_1,FUNCT_2,RLVECT_1,RLSUB_1,SEQ_4,BINOP_1,FUNCOP_1,XREAL_1,ORDINAL1,ALGSTR_0,XREAL_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB21,CKB22,CKB23,CKB24,CKB25,CKB27,CKB28,CKB29,CKB30,CKB32,CKB33;
schemes NAT_1,BINOP_1,XBOOLE_0,BINOP_2;
registrations ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,MEMBERED,REALSET1,STRUCT_0,RLVECT_1,BHSP_1,ALGSTR_0,VALUED_1,FUNCT_2,VALUED_0,CKB10,CKB19,CKB20,CKB26,CKB31;
constructors PARTFUN1,BINOP_1,FUNCOP_1,REAL_1,SQUARE_1,NAT_1,NAT_D,SEQ_2,SEQM_3,SERIES_1,REALSET1,RLSUB_1,BHSP_1,SEQ_1,VALUED_1,RELSET_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB18,CKB21,CKB22,CKB23,CKB25,CKB30,CKB32;
requirements SUBSET,REAL,BOOLE,NUMERALS,ARITHM;
begin
theorem
(for rseq being Real_Sequence holds ((for n being (Element of ( NAT )) holds ( rseq . n ) = ( 0 )) implies (rseq is  summable & ( Sum rseq ) = ( 0 ))))
proof
let rseq being Real_Sequence;
assume that
A1: (for n being (Element of ( NAT )) holds ( rseq . n ) = ( 0 ));
A2: (for m being (Element of ( NAT )) holds ( ( Partial_Sums rseq ) . m ) = ( 0 ))
proof
defpred P[ Nat ]
 means
( rseq . $1 ) = ( ( Partial_Sums rseq ) . $1 );
let m being (Element of ( NAT ));
A3: (for k being (Element of ( NAT )) holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume that
A4: ( rseq . k ) = ( ( Partial_Sums rseq ) . k );
thus ( rseq . ( k + 1 ) ) = ( ( 0 ) + ( rseq . ( k + 1 ) ) )
.= ( ( rseq . k ) + ( rseq . ( k + 1 ) ) ) by A1
.= ( ( Partial_Sums rseq ) . ( k + 1 ) ) by A4,SERIES_1:def 1;
end;
A5: P[ ( 0 ) ] by SERIES_1:def 1;
(for n being (Element of ( NAT )) holds P[ n ]) from NAT_1:sch 1(A5,A3);
hence ( ( Partial_Sums rseq ) . m ) = ( rseq . m )
.= ( 0 ) by A1;
end;
A6: (for p being  real number holds (( 0 ) < p implies (ex n being (Element of ( NAT )) st (for m being (Element of ( NAT )) holds (n <= m implies ( abs ( ( ( Partial_Sums rseq ) . m ) - ( 0 ) ) ) < p)))))
proof
let p being  real number;
assume that
A7: ( 0 ) < p;
take ( 0 );
let m being (Element of ( NAT ));
assume that
( 0 ) <= m;
( abs ( ( ( Partial_Sums rseq ) . m ) - ( 0 ) ) ) = ( abs ( ( 0 ) - ( 0 ) ) ) by A2
.= ( 0 ) by ABSVALUE:def 1;
hence thesis by A7;
end;
then A8: ( Partial_Sums rseq ) is  convergent by SEQ_2:def 6;
then ( lim ( Partial_Sums rseq ) ) = ( 0 ) by A6,SEQ_2:def 7;
hence thesis by A8,SERIES_1:def 2,SERIES_1:def 3;
end;
