environ
vocabularies NUMBERS,ZFMISC_1,ALGSTR_0,VECTSP_1,RLVECT_1,PRE_POLY,XCMPLX_0,ARYTM_3,FUNCT_1,XXREAL_0,ARYTM_1,CARD_1,XBOOLE_0,SUBSET_1,MCART_1,RELAT_1,PBOOLE,TARSKI,ORDINAL1,LATTICES,POLYNOM1,FINSEQ_1,CARD_3,PARTFUN1,NAT_1,SUPINF_2,POLYNOM7,STRUCT_0,VECTSP_2,CAT_3,BAGORDER,RELAT_2,WELLORD1,FINSET_1,BROUWER,VALUED_0,ORDERS_1,ALGSTR_1,TERMORD;
notations NUMBERS,XCMPLX_0,TARSKI,XBOOLE_0,SUBSET_1,ORDERS_1,RELAT_1,CARD_1,BAGORDER,RELSET_1,FUNCT_1,PARTFUN1,FINSET_1,XXREAL_0,ORDINAL1,NAT_1,ALGSTR_1,PBOOLE,FINSEQ_1,PRE_POLY,STRUCT_0,ALGSTR_0,RLVECT_1,VFUNCT_1,MCART_1,VECTSP_1,VECTSP_2,RELAT_2,POLYNOM1,NAT_D,WELLORD1,POLYNOM7,CKB3;
definitions CKB3;
theorems TARSKI,FINSEQ_1,FUNCT_1,FUNCT_2,RELAT_1,POLYNOM1,NAT_1,BINOM,RLVECT_1,VECTSP_2,POLYNOM7,POLYNOM2,NAT_2,RELAT_2,CARD_1,CARD_2,MATRLIN,XBOOLE_0,XBOOLE_1,ORDERS_1,MCART_1,BAGORDER,WELLORD1,VECTSP_1,XREAL_1,PARTFUN1,VALUED_0,STRUCT_0,XREAL_0,PRE_POLY,CKB3,CKB4,CKB5;
schemes NAT_1;
registrations XBOOLE_0,ORDINAL1,RELSET_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,CARD_1,FINSEQ_1,STRUCT_0,VECTSP_1,ALGSTR_1,POLYNOM1,POLYNOM2,POLYNOM7,BAGORDER,VALUED_0,PRE_POLY,VFUNCT_1,FUNCT_2,FUNCT_1,CKB1,CKB2;
constructors XXREAL_0,VECTSP_2,ALGSTR_1,TRIANG_1,POLYNOM7,BAGORDER,WELLORD2,RELSET_1,POLYNOM1,BINOP_2,VFUNCT_1,CKB3;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
registration
let n being Ordinal;
let L being  add-associative  right_complementable  right_zeroed  well-unital  distributive non  empty doubleLoopStr;
let m1 being (Monomial of n,L);
let m2 being (Monomial of n,L);
cluster ( m1 *' m2 ) ->  monomial-like;
coherence
proof
per cases ;
suppose ( Support ( m1 *' m2 ) ) = ( {} );

hence thesis by POLYNOM7:6;
end;
suppose A1: ( Support ( m1 *' m2 ) ) <> ( {} );

now
per cases ;
case A2: (( Support m1 ) <> ( {} ) & ( Support m2 ) <> ( {} ));
then consider mb2 being (bag of n) such that A3: ( Support m2 ) = { mb2 } by POLYNOM7:6;
mb2 in ( Support m2 ) by A3,TARSKI:def 1;
then A4: ( m2 . mb2 ) <> ( 0. L ) by POLYNOM1:def 3;
A5:now
let b being (bag of n);
assume A6: b <> mb2;
consider b9 being (bag of n) such that A7: (for b being (bag of n) holds (b <> b9 implies ( m2 . b ) = ( 0. L ))) by POLYNOM7:def 3;
b9 = mb2 by A4,A7;
hence ( m2 . b ) = ( 0. L ) by A6,A7;
end;
consider mb1 being (bag of n) such that A8: ( Support m1 ) = { mb1 } by A2,POLYNOM7:6;
mb1 in ( Support m1 ) by A8,TARSKI:def 1;
then A9: ( m1 . mb1 ) <> ( 0. L ) by POLYNOM1:def 3;
A10:now
let b being (bag of n);
assume A11: b <> mb1;
consider b9 being (bag of n) such that A12: (for b being (bag of n) holds (b <> b9 implies ( m1 . b ) = ( 0. L ))) by POLYNOM7:def 3;
b9 = mb1 by A9,A12;
hence ( m1 . b ) = ( 0. L ) by A11,A12;
end;
set b = the (Element of ( Support ( m1 *' m2 ) ));
A13: b in ( Support ( m1 *' m2 ) ) by A1;
then b is (Element of ( Bags n ));
then reconsider b as (bag of n);
consider s being (FinSequence of L) such that A14: ( ( m1 *' m2 ) . b ) = ( Sum s ) and A15: ( len s ) = ( len ( decomp b ) ) and A16: (for k being (Element of ( NAT )) holds (k in ( dom s ) implies (ex b1,b2 being (bag of n) st (( ( decomp b ) /. k ) = <* b1,b2 *> & ( s /. k ) = ( ( m1 . b1 ) * ( m2 . b2 ) ))))) by POLYNOM1:def 9;
A17: ( dom s ) = ( Seg ( len ( decomp b ) ) ) by A15,FINSEQ_1:def 3
.= ( dom ( decomp b ) ) by FINSEQ_1:def 3;
A18:now
assume A19: b <> ( mb1 + mb2 );
A20:now
let k being (Element of ( NAT ));
assume A21: k in ( dom s );
then consider b1,b2 being (bag of n) such that A22: ( ( decomp b ) /. k ) = <* b1,b2 *> and A23: ( s /. k ) = ( ( m1 . b1 ) * ( m2 . b2 ) ) by A16;
consider b19,b29 being (bag of n) such that A24: ( ( decomp b ) /. k ) = <* b19,b29 *> and A25: b = ( b19 + b29 ) by A17,A21,PRE_POLY:68;
A26: b2 = ( <* b19,b29 *> . 2 ) by A22,A24,FINSEQ_1:44
.= b29 by FINSEQ_1:44;
A27: b1 = ( <* b19,b29 *> . 1 ) by A22,A24,FINSEQ_1:44
.= b19 by FINSEQ_1:44;
now
per cases  by A19,A25,A27,A26;
case b1 <> mb1;
then ( m1 . b1 ) = ( 0. L ) by A10;
hence ( ( m1 . b1 ) * ( m2 . b2 ) ) = ( 0. L ) by BINOM:1;
end;
case b2 <> mb2;
then ( m2 . b2 ) = ( 0. L ) by A5;
hence ( ( m1 . b1 ) * ( m2 . b2 ) ) = ( 0. L ) by BINOM:2;
end;
end;
hence ( s /. k ) = ( 0. L ) by A23;
end;
now
per cases ;
case ( dom s ) = ( {} );
then s = ( <*> (the carrier of L) ) by RELAT_1:41;
hence ( ( m1 *' m2 ) . b ) = ( 0. L ) by A15;
end;
case A28: ( dom s ) <> ( {} );
set k = the (Element of ( dom s ));
A29: k in ( dom s ) by A28;
(for k9 being (Element of ( NAT )) holds ((k9 in ( dom s ) & k9 <> k) implies ( s /. k9 ) = ( 0. L ))) by A20;
then ( s /. k ) = ( ( m1 *' m2 ) . b ) by A14,A29,POLYNOM2:3;
hence ( ( m1 *' m2 ) . b ) = ( 0. L ) by A20,A29;
end;
end;
hence contradiction by A13,POLYNOM1:def 3;
end;
now
let b9 being (bag of n);
assume A30: b9 <> b;
consider s being (FinSequence of L) such that A31: ( ( m1 *' m2 ) . b9 ) = ( Sum s ) and A32: ( len s ) = ( len ( decomp b9 ) ) and A33: (for k being (Element of ( NAT )) holds (k in ( dom s ) implies (ex b1,b2 being (bag of n) st (( ( decomp b9 ) /. k ) = <* b1,b2 *> & ( s /. k ) = ( ( m1 . b1 ) * ( m2 . b2 ) ))))) by POLYNOM1:def 9;
A34: ( dom s ) = ( Seg ( len ( decomp b9 ) ) ) by A32,FINSEQ_1:def 3
.= ( dom ( decomp b9 ) ) by FINSEQ_1:def 3;
A35:now
let k being (Element of ( NAT ));
assume A36: k in ( dom s );
then consider b1,b2 being (bag of n) such that A37: ( ( decomp b9 ) /. k ) = <* b1,b2 *> and A38: ( s /. k ) = ( ( m1 . b1 ) * ( m2 . b2 ) ) by A33;
consider b19,b29 being (bag of n) such that A39: ( ( decomp b9 ) /. k ) = <* b19,b29 *> and A40: b9 = ( b19 + b29 ) by A34,A36,PRE_POLY:68;
A41: b2 = ( <* b19,b29 *> . 2 ) by A37,A39,FINSEQ_1:44
.= b29 by FINSEQ_1:44;
A42: b1 = ( <* b19,b29 *> . 1 ) by A37,A39,FINSEQ_1:44
.= b19 by FINSEQ_1:44;
now
per cases  by A18,A30,A40,A42,A41;
case b1 <> mb1;
then ( m1 . b1 ) = ( 0. L ) by A10;
hence ( ( m1 . b1 ) * ( m2 . b2 ) ) = ( 0. L ) by BINOM:1;
end;
case b2 <> mb2;
then ( m2 . b2 ) = ( 0. L ) by A5;
hence ( ( m1 . b1 ) * ( m2 . b2 ) ) = ( 0. L ) by BINOM:2;
end;
end;
hence ( s /. k ) = ( 0. L ) by A38;
end;
now
per cases ;
case ( dom s ) = ( {} );
then s = ( <*> (the carrier of L) ) by RELAT_1:41;
hence ( ( m1 *' m2 ) . b9 ) = ( 0. L ) by A32;
end;
case A43: ( dom s ) <> ( {} );
set k = the (Element of ( dom s ));
A44: k in ( dom s ) by A43;
(for k9 being (Element of ( NAT )) holds ((k9 in ( dom s ) & k9 <> k) implies ( s /. k9 ) = ( 0. L ))) by A35;
then ( s /. k ) = ( ( m1 *' m2 ) . b9 ) by A31,A44,POLYNOM2:3;
hence ( ( m1 *' m2 ) . b9 ) = ( 0. L ) by A35,A44;
end;
end;
hence ( ( m1 *' m2 ) . b9 ) = ( 0. L );
end;
hence thesis by POLYNOM7:def 3;
end;
case A45: (( Support m1 ) = ( {} ) or ( Support m2 ) = ( {} ));
now
per cases  by A45;
case ( Support m1 ) = ( {} );
then m1 = ( 0_ (n,L) ) by POLYNOM7:1;
hence thesis by CKB5:1;
end;
case ( Support m2 ) = ( {} );
then m2 = ( 0_ (n,L) ) by POLYNOM7:1;
hence thesis by POLYNOM1:28;
end;
end;
hence thesis;
end;
end;
hence thesis;
end;
end;
end;
