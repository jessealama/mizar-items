environ
vocabularies NUMBERS,ZFMISC_1,ALGSTR_0,VECTSP_1,RLVECT_1,PRE_POLY,XCMPLX_0,ARYTM_3,FUNCT_1,XXREAL_0,ARYTM_1,CARD_1,XBOOLE_0,SUBSET_1,MCART_1,RELAT_1,PBOOLE,TARSKI,ORDINAL1,LATTICES,POLYNOM1,FINSEQ_1,CARD_3,PARTFUN1,NAT_1,SUPINF_2,POLYNOM7,STRUCT_0,VECTSP_2,CAT_3,BAGORDER,RELAT_2,WELLORD1,FINSET_1,BROUWER,VALUED_0,ORDERS_1,ALGSTR_1,TERMORD;
notations NUMBERS,XCMPLX_0,TARSKI,XBOOLE_0,SUBSET_1,ORDERS_1,RELAT_1,CARD_1,BAGORDER,RELSET_1,FUNCT_1,PARTFUN1,FINSET_1,XXREAL_0,ORDINAL1,NAT_1,ALGSTR_1,PBOOLE,FINSEQ_1,PRE_POLY,STRUCT_0,ALGSTR_0,RLVECT_1,VFUNCT_1,MCART_1,VECTSP_1,VECTSP_2,RELAT_2,POLYNOM1,NAT_D,WELLORD1,POLYNOM7,CKB3;
definitions CKB3;
theorems TARSKI,FINSEQ_1,FUNCT_1,FUNCT_2,RELAT_1,POLYNOM1,NAT_1,BINOM,RLVECT_1,VECTSP_2,POLYNOM7,POLYNOM2,NAT_2,RELAT_2,CARD_1,CARD_2,MATRLIN,XBOOLE_0,XBOOLE_1,ORDERS_1,MCART_1,BAGORDER,WELLORD1,VECTSP_1,XREAL_1,PARTFUN1,VALUED_0,STRUCT_0,XREAL_0,PRE_POLY,CKB3;
schemes NAT_1;
registrations XBOOLE_0,ORDINAL1,RELSET_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,CARD_1,FINSEQ_1,STRUCT_0,VECTSP_1,ALGSTR_1,POLYNOM1,POLYNOM2,POLYNOM7,BAGORDER,VALUED_0,PRE_POLY,VFUNCT_1,FUNCT_2,FUNCT_1,CKB1,CKB2;
constructors XXREAL_0,VECTSP_2,ALGSTR_1,TRIANG_1,POLYNOM7,BAGORDER,WELLORD2,RELSET_1,POLYNOM1,BINOP_2,VFUNCT_1,CKB3;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
theorem
Th1: (for X being set holds (for b1,b2 being (bag of X) holds (b1 divides b2 iff (ex b being (bag of X) st b2 = ( b1 + b )))))
proof
let n being set;
let b1 being (bag of n);
let b2 being (bag of n);
now
assume A1: b1 divides b2;
A2:now
let k being set;
( b1 . k ) <= ( b2 . k ) by A1,PRE_POLY:def 11;
then ( ( b1 . k ) - ( b1 . k ) ) <= ( ( b2 . k ) - ( b1 . k ) ) by XREAL_1:9;
hence ( 0 ) <= ( ( b2 . k ) - ( b1 . k ) );
end;
now
per cases ;
case A3: n = ( {} );
then ( b1 + ( EmptyBag n ) ) = ( EmptyBag n ) by POLYNOM7:3
.= b2 by A3,POLYNOM7:3;
hence (ex b being (bag of n) st b2 = ( b1 + b ));
end;
case n <> ( {} );
then reconsider n9 = n as non  empty set;
set b = { [ k,( ( b2 . k ) -' ( b1 . k ) ) ] where k is (Element of n9): (not contradiction) };
A4:now
let x being set;
assume x in b;
then (ex k being (Element of n9) st x = [ k,( ( b2 . k ) -' ( b1 . k ) ) ]);
hence (ex y,z being set st x = [ y,z ]);
end;
now
let x being set;
let y1 being set;
let y2 being set;
assume that
A5: [ x,y1 ] in b
and
A6: [ x,y2 ] in b;
consider k being (Element of n9) such that A7: [ x,y1 ] = [ k,( ( b2 . k ) -' ( b1 . k ) ) ] by A5;
consider k9 being (Element of n9) such that A8: [ x,y2 ] = [ k9,( ( b2 . k9 ) -' ( b1 . k9 ) ) ] by A6;
k = ( [ x,y1 ] `1 ) by A7,MCART_1:def 1
.= x by MCART_1:def 1
.= ( [ x,y2 ] `1 ) by MCART_1:def 1
.= k9 by A8,MCART_1:def 1;
hence y1 = ( [ x,y2 ] `2 ) by A7,A8,MCART_1:def 2
.= y2 by MCART_1:def 2;
end;
then reconsider b as Function by A4,FUNCT_1:def 1,RELAT_1:def 1;
A9:now
let x being set;
assume x in ( dom b );
then consider y being set such that A10: [ x,y ] in b by RELAT_1:def 4;
consider k being (Element of n9) such that A11: [ x,y ] = [ k,( ( b2 . k ) -' ( b1 . k ) ) ] by A10;
x = ( [ k,( ( b2 . k ) -' ( b1 . k ) ) ] `1 ) by A11,MCART_1:def 1
.= k by MCART_1:def 1;
hence x in n9;
end;
now
let x being set;
assume x in n9;
then reconsider k = x as (Element of n9);
[ k,( ( b2 . k ) -' ( b1 . k ) ) ] in b;
hence x in ( dom b ) by RELAT_1:def 4;
end;
then A12: ( dom b ) = n9 by A9,TARSKI:1;
then reconsider b as (ManySortedSet of n9) by PARTFUN1:def 2,RELAT_1:def 18;
A13:now
let k being set;
assume k in n;
then consider u being set such that A14: [ k,u ] in b by A12,RELAT_1:def 4;
consider k9 being (Element of n9) such that A15: [ k,u ] = [ k9,( ( b2 . k9 ) -' ( b1 . k9 ) ) ] by A14;
A16: u = ( [ k9,( ( b2 . k9 ) -' ( b1 . k9 ) ) ] `2 ) by A15,MCART_1:def 2
.= ( ( b2 . k9 ) -' ( b1 . k9 ) ) by MCART_1:def 2;
k = ( [ k9,( ( b2 . k9 ) -' ( b1 . k9 ) ) ] `1 ) by A15,MCART_1:def 1
.= k9 by MCART_1:def 1;
hence ( b . k ) = ( ( b2 . k ) -' ( b1 . k ) ) by A14,A16,FUNCT_1:1;
end;
now
let x being set;
A17: ( support b ) c= ( dom b ) by PRE_POLY:37;
assume A18: x in ( support b );
then A19: ( b . x ) <> ( 0 ) by PRE_POLY:def 7;
now
assume (not x in ( support b2 ));
then ( b2 . x ) = ( 0 ) by PRE_POLY:def 7;
then ( 0 ) = ( ( b2 . x ) -' ( b1 . x ) ) by NAT_2:8;
hence contradiction by A12,A13,A18,A19,A17;
end;
hence x in ( support b2 );
end;
then A20: ( support b ) c= ( support b2 ) by TARSKI:def 3;
now
let x being set;
assume x in ( rng b );
then consider y being set such that A21: [ y,x ] in b by RELAT_1:def 5;
consider k being (Element of n9) such that A22: [ y,x ] = [ k,( ( b2 . k ) -' ( b1 . k ) ) ] by A21;
x = ( [ k,( ( b2 . k ) -' ( b1 . k ) ) ] `2 ) by A22,MCART_1:def 2
.= ( ( b2 . k ) -' ( b1 . k ) ) by MCART_1:def 2;
hence x in ( NAT );
end;
then ( rng b ) c= ( NAT ) by TARSKI:def 3;
then reconsider b as (bag of n) by A20,PRE_POLY:def 8,VALUED_0:def 6;
take b;
now
let k being set;
A23: ( 0 ) <= ( ( b2 . k ) - ( b1 . k ) ) by A2;
assume k in n;
hence ( ( b1 . k ) + ( b . k ) ) = ( ( b1 . k ) + ( ( b2 . k ) -' ( b1 . k ) ) ) by A13
.= ( ( b1 . k ) + ( ( b2 . k ) + ( - ( b1 . k ) ) ) ) by A23,XREAL_0:def 2
.= ( b2 . k );
end;
then b2 = ( b1 + b ) by PRE_POLY:33;
hence (ex b being (bag of n) st b2 = ( b1 + b ));
end;
end;
hence (ex b being (bag of n) st b2 = ( b1 + b ));
end;
hence thesis by PRE_POLY:50;
end;
