environ
vocabularies NUMBERS,ZFMISC_1,ALGSTR_0,VECTSP_1,RLVECT_1,PRE_POLY,XCMPLX_0,ARYTM_3,FUNCT_1,XXREAL_0,ARYTM_1,CARD_1,XBOOLE_0,SUBSET_1,MCART_1,RELAT_1,PBOOLE,TARSKI,ORDINAL1,LATTICES,POLYNOM1,FINSEQ_1,CARD_3,PARTFUN1,NAT_1,SUPINF_2,POLYNOM7,STRUCT_0,VECTSP_2,CAT_3,BAGORDER,RELAT_2,WELLORD1,FINSET_1,BROUWER,VALUED_0,ORDERS_1,ALGSTR_1,TERMORD;
notations NUMBERS,XCMPLX_0,TARSKI,XBOOLE_0,SUBSET_1,ORDERS_1,RELAT_1,CARD_1,BAGORDER,RELSET_1,FUNCT_1,PARTFUN1,FINSET_1,XXREAL_0,ORDINAL1,NAT_1,ALGSTR_1,PBOOLE,FINSEQ_1,PRE_POLY,STRUCT_0,ALGSTR_0,RLVECT_1,VFUNCT_1,MCART_1,VECTSP_1,VECTSP_2,RELAT_2,POLYNOM1,NAT_D,WELLORD1,POLYNOM7,CKB3;
definitions CKB3;
theorems TARSKI,FINSEQ_1,FUNCT_1,FUNCT_2,RELAT_1,POLYNOM1,NAT_1,BINOM,RLVECT_1,VECTSP_2,POLYNOM7,POLYNOM2,NAT_2,RELAT_2,CARD_1,CARD_2,MATRLIN,XBOOLE_0,XBOOLE_1,ORDERS_1,MCART_1,BAGORDER,WELLORD1,VECTSP_1,XREAL_1,PARTFUN1,VALUED_0,STRUCT_0,XREAL_0,PRE_POLY,CKB3,CKB4,CKB5;
schemes NAT_1;
registrations XBOOLE_0,ORDINAL1,RELSET_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,CARD_1,FINSEQ_1,STRUCT_0,VECTSP_1,ALGSTR_1,POLYNOM1,POLYNOM2,POLYNOM7,BAGORDER,VALUED_0,PRE_POLY,VFUNCT_1,FUNCT_2,FUNCT_1,CKB1,CKB2,CKB6;
constructors XXREAL_0,VECTSP_2,ALGSTR_1,TRIANG_1,POLYNOM7,BAGORDER,WELLORD2,RELSET_1,POLYNOM1,BINOP_2,VFUNCT_1,CKB3;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
registration
let n being Ordinal;
let L being  add-associative  right_complementable  right_zeroed  distributive non  empty doubleLoopStr;
let c1 being (ConstPoly of n,L);
let c2 being (ConstPoly of n,L);
cluster ( c1 *' c2 ) ->  Constant;
coherence
proof
set p = ( c1 *' c2 );
now
let b being (bag of n);
assume A1: b <> ( EmptyBag n );
consider s being (FinSequence of L) such that A2: ( p . b ) = ( Sum s ) and A3: ( len s ) = ( len ( decomp b ) ) and A4: (for k being (Element of ( NAT )) holds (k in ( dom s ) implies (ex b1,b2 being (bag of n) st (( ( decomp b ) /. k ) = <* b1,b2 *> & ( s /. k ) = ( ( c1 . b1 ) * ( c2 . b2 ) ))))) by POLYNOM1:def 9;
A5: ( dom s ) = ( Seg ( len ( decomp b ) ) ) by A3,FINSEQ_1:def 3
.= ( dom ( decomp b ) ) by FINSEQ_1:def 3;
A6:now
let k being (Element of ( NAT ));
assume A7: k in ( dom s );
then consider b1,b2 being (bag of n) such that A8: ( ( decomp b ) /. k ) = <* b1,b2 *> and A9: ( s /. k ) = ( ( c1 . b1 ) * ( c2 . b2 ) ) by A4;
consider b19,b29 being (bag of n) such that A10: ( ( decomp b ) /. k ) = <* b19,b29 *> and A11: b = ( b19 + b29 ) by A5,A7,PRE_POLY:68;
A12: b2 = ( <* b19,b29 *> . 2 ) by A8,A10,FINSEQ_1:44
.= b29 by FINSEQ_1:44;
b1 = ( <* b19,b29 *> . 1 ) by A8,A10,FINSEQ_1:44
.= b19 by FINSEQ_1:44;
then A13: (b1 <> ( EmptyBag n ) or b2 <> ( EmptyBag n )) by A1,A11,A12,PRE_POLY:53;
now
per cases  by A13,POLYNOM7:def 7;
case ( c1 . b1 ) = ( 0. L );
hence ( s /. k ) = ( 0. L ) by A9,BINOM:1;
end;
case ( c2 . b2 ) = ( 0. L );
hence ( s /. k ) = ( 0. L ) by A9,BINOM:2;
end;
end;
hence ( s /. k ) = ( 0. L );
end;
now
per cases ;
case ( dom s ) = ( {} );
then s = ( <*> (the carrier of L) ) by RELAT_1:41;
hence ( p . b ) = ( 0. L ) by A3;
end;
case A14: ( dom s ) <> ( {} );
set k = the (Element of ( dom s ));
A15: k in ( dom s ) by A14;
(for k9 being (Element of ( NAT )) holds ((k9 in ( dom s ) & k9 <> k) implies ( s /. k9 ) = ( 0. L ))) by A6;
then ( Sum s ) = ( s /. k ) by A15,POLYNOM2:3;
hence ( p . b ) = ( 0. L ) by A2,A6,A15;
end;
end;
hence ( p . b ) = ( 0. L );
end;
hence thesis by POLYNOM7:def 7;
end;
end;
