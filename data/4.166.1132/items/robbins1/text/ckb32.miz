environ
vocabularies STRUCT_0,BINOP_1,LATTICES,FUNCT_5,XBOOLE_0,ZFMISC_1,SUBSET_1,FUNCT_1,ARYTM_3,EQREL_1,XXREAL_2,ARYTM_1,ROBBINS1,CARD_1;
notations TARSKI,CARD_1,STRUCT_0,LATTICES,BINOP_1,FUNCT_2,FUNCT_5,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB24;
definitions LATTICES,STRUCT_0,CKB5,CKB6,CKB13,CKB15,CKB16,CKB17,CKB18;
theorems STRUCT_0,LATTICES,BINOP_1,CARD_1,CKB5,CKB6,CKB13,CKB15,CKB16,CKB17,CKB18,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30;
schemes BINOP_1;
registrations RELSET_1,STRUCT_0,LATTICES,LATTICE2,XBOOLE_0,ZFMISC_1,CARD_1,ORDINAL1,CKB1,CKB2,CKB3,CKB4,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB19,CKB20,CKB21,CKB22,CKB23,CKB31;
constructors BINOP_1,LATTICES,FUNCT_5,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB13,CKB15,CKB16,CKB17,CKB18,CKB24;
requirements SUBSET,NUMERALS;
begin
definition
let L being  join-commutative  join-associative  join-idempotent  Huntington non empty ComplLLattStr;
redefine func Top L
means
:Def8: (ex a being (Element of L) st it = ( a + ( a ` ) ));
compatibility
proof
let IT being (Element of L);
hereby
set a = the (Element of L);
assume A1: IT = ( Top L );
take a;
(for b being (Element of L) holds (( ( a + ( a ` ) ) + b ) = ( a + ( a ` ) ) & ( b + ( a + ( a ` ) ) ) = ( a + ( a ` ) )))
proof
let b being (Element of L);
( ( a + ( a ` ) ) + b ) = ( ( b + ( b ` ) ) + b ) by CKB28:1
.= ( ( b ` ) + ( b + b ) ) by LATTICES:def 5
.= ( ( b ` ) + b ) by CKB18:def 1
.= ( ( a ` ) + a ) by CKB28:1;
hence thesis;
end;
hence IT = ( a + ( a ` ) ) by A1,LATTICES:def 17;
end;
given a being (Element of L) such that
A2: IT = ( a + ( a ` ) );

A3: (for b being (Element of L) holds ( ( a + ( a ` ) ) + b ) = ( a + ( a ` ) ))
proof
let b being (Element of L);
( ( a + ( a ` ) ) + b ) = ( ( b + ( b ` ) ) + b ) by CKB28:1
.= ( ( b ` ) + ( b + b ) ) by LATTICES:def 5
.= ( ( b ` ) + b ) by CKB18:def 1
.= ( ( a ` ) + a ) by CKB28:1;
hence thesis;
end;
then (for b being (Element of L) holds ( b + ( a + ( a ` ) ) ) = ( a + ( a ` ) ));
hence thesis by A2,A3,LATTICES:def 17;
end;
end;
