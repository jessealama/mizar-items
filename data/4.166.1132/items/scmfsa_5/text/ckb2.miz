environ
vocabularies SUBSET_1,NUMBERS,AMI_1,SCMFSA_2,AMISTD_2,ARYTM_3,FUNCT_4,VALUED_1,XBOOLE_0,FUNCT_1,RELAT_1,TARSKI,FSM_1,CIRCUIT2,CARD_1,XXREAL_0,SCMNORM,GRAPHSP,AMI_3,ARYTM_1,INT_1,COMPLEX1,PARTFUN1,FINSEQ_1,FINSEQ_2,GLIB_000,STRUCT_0,MSUALG_1,TURING_1,NAT_1,ORDINAL1,RELOC,AMISTD_5,PBOOLE,COMPOS_1,FINSET_1;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,FINSET_1,NUMBERS,XCMPLX_0,INT_2,ORDINAL1,INT_1,NAT_1,NAT_D,PARTFUN1,RELAT_1,FUNCT_1,PBOOLE,FINSEQ_1,FINSEQ_2,FUNCT_4,FUNCT_7,VALUED_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_2,SCMFSA_2,XXREAL_0,AMISTD_5;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,TARSKI,AMISTD_2,AMISTD_5,MEMSTR_0;
theorems GRFUNC_1,NAT_1,FUNCOP_1,TARSKI,FUNCT_4,FUNCT_1,ZFMISC_1,RELAT_1,SCMFSA_2,SCMFSA_3,SCMFSA_4,XBOOLE_0,XBOOLE_1,VALUED_1,NAT_D,PBOOLE,PARTFUN1,COMPOS_1,EXTPRO_1,AMISTD_2,AMISTD_5,MEMSTR_0,CKB1;
schemes NAT_1;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,RELSET_1,NUMBERS,XREAL_0,INT_1,CARD_3,SCMFSA_2,ORDINAL1,FINSET_1,RELAT_1,VALUED_1,GRFUNC_1,FUNCT_2,AMISTD_2,SCMFSA10,COMPOS_1,EXTPRO_1,SCMFSA_4,SCMFSA_3,AMISTD_5,PBOOLE,FUNCT_7,FUNCT_4,MEMSTR_0;
constructors DOMAIN_1,XXREAL_0,NAT_D,RELSET_1,FUNCT_7,AMISTD_1,PRE_POLY,AMISTD_2,SCMFSA_2,SCMFSA_3,AMISTD_5,PBOOLE,FUNCT_4,MEMSTR_0;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
registration
cluster ( SCM+FSA ) ->  relocable1  relocable2;
coherence
proof
(for k being (Element of ( NAT )) holds (for q being non halt-free  finite (the Instructions of ( SCM+FSA )) -valued ( NAT ) -defined Function holds (for p being q -autonomic non empty (FinPartState of ( SCM+FSA )) holds (for s1,s2 being (State of ( SCM+FSA )) holds (((( IC ( SCM+FSA ) ) in ( dom p ) & p c= s1) & ( IncIC (p,k) ) c= s2) implies (for P1,P2 being (Instruction-Sequence of ( SCM+FSA )) holds ((q c= P1 & ( Reloc (q,k) ) c= P2) implies (for i being (Element of ( NAT )) holds ( IncAddr (( CurInstr (P1,( Comput (P1,s1,i) )) ),k) ) = ( CurInstr (P2,( Comput (P2,s2,i) )) ))))))))) by CKB1:1;
hence ( SCM+FSA ) is  relocable1 by AMISTD_5:def 5;
let k being (Element of ( NAT ));
let q being non halt-free  finite (the Instructions of ( SCM+FSA )) -valued ( NAT ) -defined Function;
let p being q -autonomic non empty (FinPartState of ( SCM+FSA ));
let s1 being (State of ( SCM+FSA )),s2 being (State of ( SCM+FSA ));
assume A1: ((( IC ( SCM+FSA ) ) in ( dom p ) & p c= s1) & ( IncIC (p,k) ) c= s2);
let P1 being (Instruction-Sequence of ( SCM+FSA )),P2 being (Instruction-Sequence of ( SCM+FSA ));
assume (q c= P1 & ( Reloc (q,k) ) c= P2);
hence (for i being (Element of ( NAT )) holds ( ( Comput (P1,s1,i) ) | ( dom ( DataPart p ) ) ) = ( ( Comput (P2,s2,i) ) | ( dom ( DataPart p ) ) )) by A1,CKB1:1;
end;
end;
