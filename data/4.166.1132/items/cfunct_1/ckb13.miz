environ
vocabularies XBOOLE_0,SUBSET_1,PARTFUN1,NUMBERS,XREAL_0,ORDINAL1,RELAT_1,ARYTM_3,CARD_1,COMPLEX1,ORDINAL4,FUNCT_1,ARYTM_1,VALUED_1,TARSKI,XXREAL_2,XXREAL_0,CFUNCT_1;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,FUNCT_1,RELSET_1,PARTFUN1,RFUNCT_1,COMPLEX1,VALUED_1,SEQ_2,CKB1,CKB2,CKB3;
definitions TARSKI,PARTFUN1,RFUNCT_1,XBOOLE_0,VALUED_1,SEQ_2,CKB2,CKB3;
theorems TARSKI,SUBSET_1,FUNCT_1,PARTFUN1,PARTFUN2,RFUNCT_1,COMPLEX1,RELAT_1,XBOOLE_0,XBOOLE_1,XCMPLX_0,XCMPLX_1,XREAL_1,XXREAL_0,VALUED_1,SEQ_2,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12;
schemes PARTFUN2;
registrations RELSET_1,NUMBERS,XREAL_0,MEMBERED,VALUED_0,RFUNCT_1;
constructors PARTFUN1,XXREAL_0,REAL_1,COMPLEX1,PARTFUN2,VALUED_1,RFUNCT_1,SEQ_1,SEQ_2,NAT_1,RELSET_1,CKB2,CKB3;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve C for non empty set;
reserve f for (PartFunc of C,( COMPLEX ));
theorem
Th18: ( ( f ^ ) " { ( 0 ) } ) = ( {} )
proof
set x = the (Element of ( ( f ^ ) " { ( 0c ) } ));
assume A1: ( ( f ^ ) " { ( 0 ) } ) <> ( {} );
then A2: x in ( dom ( f ^ ) ) by CKB9:1;
A3: ( ( f ^ ) /. x ) in { ( 0c ) } by A1,CKB9:1;
reconsider x as (Element of C) by A2;
x in ( ( dom f ) \ ( f " { ( 0c ) } ) ) by A2,CKB3:def 1;
then (x in ( dom f ) & (not x in ( f " { ( 0c ) } ))) by XBOOLE_0:def 5;
then A4: (not ( f /. x ) in { ( 0c ) }) by PARTFUN2:26;
( ( f ^ ) /. x ) = ( 0c ) by A3,TARSKI:def 1;
then ( ( f /. x ) " ) = ( 0c ) by A2,CKB3:def 1;
hence contradiction by A4,TARSKI:def 1,XCMPLX_1:202;
end;
