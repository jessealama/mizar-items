environ
vocabularies NUMBERS,PRE_TOPC,EUCLID,FINSEQ_1,REAL_1,SUBSET_1,GOBOARD1,NAT_1,XBOOLE_0,CARD_1,ARYTM_3,XXREAL_0,TARSKI,ARYTM_1,RELAT_1,ORDINAL4,PARTFUN1,FUNCT_1,RLTOPSP1,TOPREAL1,MCART_1,MATRIX_1,INCSP_1,ZFMISC_1,TREES_1,ORDINAL2,COMPLEX1,STRUCT_0,GOBOARD2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,CARD_1,NUMBERS,XCMPLX_0,XREAL_0,COMPLEX1,REAL_1,NAT_1,RELAT_1,FUNCT_1,PARTFUN1,FINSEQ_1,SEQ_1,VALUED_0,STRUCT_0,PRE_TOPC,SEQ_4,MATRIX_1,RLTOPSP1,EUCLID,TOPREAL1,GOBOARD1,XXREAL_0;
definitions TARSKI,TOPREAL1,GOBOARD1,XBOOLE_0;
theorems TARSKI,NAT_1,ZFMISC_1,FUNCT_1,FINSEQ_1,ABSVALUE,SEQ_4,FINSEQ_2,MATRIX_1,EUCLID,TOPREAL1,TOPREAL3,GOBOARD1,FINSEQ_4,FINSEQ_3,PARTFUN2,INT_1,XBOOLE_0,XBOOLE_1,XREAL_1,COMPLEX1,XXREAL_0,ORDINAL1,PARTFUN1,SEQM_3,RLTOPSP1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6;
schemes NAT_1,MATRIX_1,FINSEQ_4;
registrations RELSET_1,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,MEMBERED,FINSEQ_1,STRUCT_0,EUCLID,GOBOARD1,VALUED_0,CARD_1,XXREAL_2,RELAT_1,FUNCT_1,SEQM_3,SEQ_4;
constructors PARTFUN1,SQUARE_1,NAT_1,COMPLEX1,SEQ_4,TOPREAL1,GOBOARD1,SEQ_1,XXREAL_2,SEQM_3,RELSET_1,DOMAIN_1,BINOP_2,RVSUM_1;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve f for (FinSequence of ( TOP-REAL 2 ));
reserve i for (Element of ( NAT ));
theorem
(f is  s.n.c. implies ( f | i ) is  s.n.c.)
proof
assume A1: f is  s.n.c.;
set f1 = ( f | i );
let n being Nat,m being Nat;
assume m > ( n + 1 );
then ( LSeg (f,n) ) misses ( LSeg (f,m) ) by A1,TOPREAL1:def 7;
then A2: ( ( LSeg (f,n) ) /\ ( LSeg (f,m) ) ) = ( {} ) by XBOOLE_0:def 7;
now
A3: m <= ( m + 1 ) by NAT_1:11;
A4: n <= ( n + 1 ) by NAT_1:11;
now
per cases ;
suppose A5: n in ( dom f1 );

now
per cases ;
suppose ( n + 1 ) in ( dom f1 );

then A6: ( LSeg (f,n) ) = ( LSeg (f1,n) ) by A5,TOPREAL3:17;
now
per cases ;
suppose A7: m in ( dom f1 );

now
per cases ;
suppose ( m + 1 ) in ( dom f1 );

hence ( ( LSeg (f1,n) ) /\ ( LSeg (f1,m) ) ) = ( {} ) by A2,A6,A7,TOPREAL3:17;
end;
suppose (not ( m + 1 ) in ( dom f1 ));

then (not (1 <= ( m + 1 ) & ( m + 1 ) <= ( len f1 ))) by FINSEQ_3:25;
then ( LSeg (f1,m) ) = ( {} ) by NAT_1:11,TOPREAL1:def 3;
hence ( ( LSeg (f1,n) ) /\ ( LSeg (f1,m) ) ) = ( {} );
end;
end;
hence thesis by XBOOLE_0:def 7;
end;
suppose (not m in ( dom f1 ));

then (not (1 <= m & m <= ( len f1 ))) by FINSEQ_3:25;
then (not (1 <= m & ( m + 1 ) <= ( len f1 ))) by A3,XXREAL_0:2;
then ( LSeg (f1,m) ) = ( {} ) by TOPREAL1:def 3;
hence thesis by XBOOLE_1:65;
end;
end;
hence thesis;
end;
suppose (not ( n + 1 ) in ( dom f1 ));

then (not (1 <= ( n + 1 ) & ( n + 1 ) <= ( len f1 ))) by FINSEQ_3:25;
then ( LSeg (f1,n) ) = ( {} ) by NAT_1:11,TOPREAL1:def 3;
hence thesis by XBOOLE_1:65;
end;
end;
hence thesis;
end;
suppose (not n in ( dom f1 ));

then (not (1 <= n & n <= ( len f1 ))) by FINSEQ_3:25;
then (not (1 <= n & ( n + 1 ) <= ( len f1 ))) by A4,XXREAL_0:2;
then ( LSeg (f1,n) ) = ( {} ) by TOPREAL1:def 3;
hence thesis by XBOOLE_1:65;
end;
end;
hence thesis;
end;
hence thesis;
end;
