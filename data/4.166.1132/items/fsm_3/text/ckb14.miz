environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,AFINSQ_1,NAT_1,REWRITE3,XXREAL_0,ARYTM_3,CARD_1,FINSEQ_1,ORDINAL4,RELAT_1,FUNCT_1,FLANG_1,FSM_1,STRUCT_0,ZFMISC_1,TARSKI,FINSET_1,REWRITE2,PRELAMB,FSM_2,LANG1,REWRITE1,MCART_1,FSM_3;
notations CARD_1,TARSKI,XBOOLE_0,ZFMISC_1,XCMPLX_0,NAT_1,DOMAIN_1,FUNCT_1,RELSET_1,XXREAL_0,FINSET_1,AFINSQ_1,SUBSET_1,REWRITE1,CATALAN2,FLANG_1,STRUCT_0,NUMBERS,MCART_1,FINSEQ_1,REWRITE3,CKB13;
definitions STRUCT_0,CKB13;
theorems AFINSQ_1,CARD_1,FLANG_1,FUNCT_1,NAT_1,ORDINAL1,RELAT_1,RELSET_1,REWRITE1,STRUCT_0,SUBSET_1,TARSKI,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,ZFMISC_1,FINSEQ_1,FINSEQ_3,FINSEQ_5,MCART_1,REWRITE3,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB9,CKB10,CKB11,CKB12,CKB13;
schemes FINSEQ_1,FRAENKEL,NAT_1,RELSET_1;
registrations CARD_1,NAT_1,XREAL_0,XBOOLE_0,MEMBERED,XXREAL_0,STRUCT_0,SUBSET_1,REWRITE1,AFINSQ_1,RELAT_1,FINSET_1,FINSEQ_1,REWRITE3,CATALAN2,FUNCT_1,RELSET_1,CKB8;
constructors XXREAL_0,NAT_1,MEMBERED,REWRITE1,FLANG_1,XREAL_0,REWRITE3,RELSET_1,CKB13;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve E for non empty set;
reserve F for (Subset of ( E ^omega ));
reserve TS for non empty transition-system over F;
registration
let E;
let F;
let TS;
cluster ( _bool TS ) -> non empty  deterministic;
coherence
proof
set bTS = ( _bool TS );
set wTS = (the carrier of bTS);
set tTS = (the Tran of bTS);
(for x,y1,y2 being set holds (([ x,y1 ] in tTS & [ x,y2 ] in tTS) implies y1 = y2))
proof
let x being set,y1 being set,y2 being set;
assume that
A1: [ x,y1 ] in tTS
and
A2: [ x,y2 ] in tTS;
reconsider x as (Element of [: wTS,( Lex E ) :]) by A1,ZFMISC_1:87;
reconsider y1,y2 as (Element of wTS) by A1,A2,ZFMISC_1:87;
(the carrier of bTS) = ( bool (the carrier of TS) ) by CKB13:def 1;
then consider xc being set,xi being set such that A3: xc in wTS and A4: xi in ( Lex E ) and A5: x = [ xc,xi ] by ZFMISC_1:def 2;
reconsider xc as (Element of wTS) by A3;
reconsider xi as (Element of ( Lex E )) by A4;
reconsider xi as (Element of ( E ^omega ));
reconsider xc,y1,y2 as (Subset of TS) by CKB13:def 1;
(y1 = ( xi -succ_of (xc,TS) ) & y2 = ( xi -succ_of (xc,TS) )) by A1,A2,A5,CKB13:def 1;
hence thesis;
end;
then A6: (the Tran of bTS) is Function by FUNCT_1:def 1;
(the carrier of bTS) = ( bool (the carrier of TS) ) by CKB13:def 1;
hence thesis by A6,CKB12:1;
end;
end;
