environ
vocabularies NUMBERS,SUBSET_1,INT_1,AMI_1,SCMFSA_2,SF_MASTR,FUNCOP_1,FUNCT_1,FINSUB_1,CARD_3,RELAT_1,TARSKI,AMISTD_2,XBOOLE_0,CARD_1,SCMFSA8A,AMI_3,FSM_1,SCMFSA7B,SCMFSA8B,ARYTM_3,TURING_1,SCMFSA6A,ARYTM_1,VALUED_1,FUNCT_4,SCMFSA_9,UNIALG_2,SCMFSA6B,XXREAL_0,CIRCUIT2,GRAPHSP,NAT_1,SCMFSA6C,MSUALG_1,SFMASTR1,PRE_FF,COMPLEX1,ABIAN,SCMFSA9A,ORDINAL1,PARTFUN1,SCMNORM,RELOC,PBOOLE,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,FINSUB_1,FUNCOP_1,INT_1,ABIAN,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,PRE_FF,CARD_3,FUNCT_4,PBOOLE,VALUED_1,INT_2,XXREAL_0,NAT_1,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA_7,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,CKB16,CKB17,CKB27,CKB35,CKB36,CKB46,CKB54;
definitions FUNCOP_1,SCMFSA6A,AFINSQ_1,COMPOS_1,EXTPRO_1,AMISTD_2,MEMSTR_0,CKB16,CKB17,CKB27,CKB35,CKB36,CKB46,CKB54;
theorems TARSKI,ZFMISC_1,ABSVALUE,NAT_1,INT_1,NAT_2,FUNCT_1,FUNCT_2,GRFUNC_1,FUNCOP_1,FUNCT_4,PRE_FF,ABIAN,SCMFSA_2,MEMSTR_0,SCMFSA_4,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,SCMFSA_9,SFMASTR1,RELAT_1,XBOOLE_0,XBOOLE_1,CARD_3,XREAL_1,XXREAL_0,ORDINAL1,NAT_D,VALUED_1,PBOOLE,PARTFUN1,FINSEQ_4,COMPOS_1,EXTPRO_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54;
schemes FUNCT_2,NAT_1;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,FINSET_1,FINSUB_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,CARD_3,ABIAN,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,VALUED_1,FUNCT_2,RELAT_1,AFINSQ_1,FUNCT_4,FUNCOP_1,SCMFSA10,AMISTD_2,SCMFSA6A,COMPOS_1,EXTPRO_1,PBOOLE,STRUCT_0,MEMSTR_0;
constructors NAT_D,PRE_FF,ABIAN,SCMFSA_7,SCMFSA6A,SCMFSA6B,MEMSTR_0,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,AMISTD_2,RELSET_1,PRE_POLY,XXREAL_2,PBOOLE,SCMFSA7B,SCMFSA8C,FUNCT_4,AMISTD_1,CKB16,CKB17,CKB27,CKB35,CKB36,CKB46,CKB54;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve p for (Instruction-Sequence of ( SCM+FSA ));
reserve s for (State of ( SCM+FSA ));
reserve s1 for (State of ( SCM+FSA ));
reserve s2 for (State of ( SCM+FSA ));
reserve a for  read-write Int-Location;
reserve Ig for  good (Program of ( SCM+FSA ));
reserve k for (Element of ( NAT ));
theorem
Th46: (((( s . ( intloc ( 0 ) ) ) = 1 &  ProperBodyWhile>0 a,Ig,s,p) &  WithVariantWhile>0 a,Ig,s,p) implies (ex f being (Function of ( product (the Object-Kind of ( SCM+FSA )) ),( NAT )) st (f is  on_data_only & (for k being (Element of ( NAT )) holds (( f . ( ( StepWhile>0 (a,Ig,p,s) ) . ( k + 1 ) ) ) < ( f . ( ( StepWhile>0 (a,Ig,p,s) ) . k ) ) or ( ( ( StepWhile>0 (a,Ig,p,s) ) . k ) . a ) <= ( 0 ))))))
proof
set I = Ig;
assume that
A1: ( s . ( intloc ( 0 ) ) ) = 1
and
A2:  ProperBodyWhile>0 a,I,s,p
and
A3:  WithVariantWhile>0 a,I,s,p;
set SW = ( StepWhile>0 (a,I,p,s) );
set PW = ( p +* ( while>0 (a,I) ) );
consider K being (Element of ( NAT )) such that A4: ( ExitsAtWhile>0 (a,I,p,s) ) = K and A5: ( ( SW . K ) . a ) <= ( 0 ) and (for i being (Element of ( NAT )) holds (( ( SW . i ) . a ) <= ( 0 ) implies K <= i)) and ( DataPart ( Comput (( p +* ( while>0 (a,I) ) ),( Initialize s ),( LifeSpan (( p +* ( while>0 (a,I) ) ),( Initialize s )) )) ) ) = ( DataPart ( ( StepWhile>0 (a,I,p,s) ) . K ) ) by A2,A3,CKB46:def 1;
consider g being (Function of ( product (the Object-Kind of ( SCM+FSA )) ),( NAT )) such that A6: (for k being (Element of ( NAT )) holds (( g . ( SW . ( k + 1 ) ) ) < ( g . ( SW . k ) ) or ( ( SW . k ) . a ) <= ( 0 ))) by A3,CKB36:def 1;
defpred P[ (State of ( SCM+FSA )),set ]
 means
((ex k being (Element of ( NAT )) st ((k <= K & ( DataPart $1 ) = ( DataPart ( SW . k ) )) & $2 = ( g . ( SW . k ) ))) or ((not (ex k being (Element of ( NAT )) st (k <= K & ( DataPart $1 ) = ( DataPart ( SW . k ) )))) & $2 = ( 0 )));
A7: (for x being (Element of ( product (the Object-Kind of ( SCM+FSA )) )) holds (ex y being (Element of ( NAT )) st P[ x,y ]))
proof
let x being (Element of ( product (the Object-Kind of ( SCM+FSA )) ));
per cases ;
suppose (ex k being (Element of ( NAT )) st (k <= K & ( DataPart x ) = ( DataPart ( SW . k ) )));

then consider k being (Element of ( NAT )) such that A8: (k <= K & ( DataPart x ) = ( DataPart ( SW . k ) ));
take ( g . ( SW . k ) );
thus thesis by A8;
end;
suppose A9: (not (ex k being (Element of ( NAT )) st (k <= K & ( DataPart x ) = ( DataPart ( SW . k ) ))));

take ( 0 );
thus thesis by A9;
end;
end;
consider f being (Function of ( product (the Object-Kind of ( SCM+FSA )) ),( NAT )) such that A10: (for x being (Element of ( product (the Object-Kind of ( SCM+FSA )) )) holds P[ x,( f . x ) ]) from FUNCT_2:sch 3(A7);
take f;
hereby
let s1;
let s2;
assume that
A11: ( DataPart s1 ) = ( DataPart s2 );
reconsider ss1 = s1,ss2 = s2 as (Element of ( product (the Object-Kind of ( SCM+FSA )) )) by CARD_3:107;
(P[ ss1,( f . ss1 ) ] & P[ ss2,( f . ss2 ) ]) by A10;
hence ( f . s1 ) = ( f . s2 ) by A1,A2,A3,A4,A11,CKB53:1;
end;
let k being (Element of ( NAT ));
per cases ;
suppose A12: k < K;

then A13: ( k + 1 ) <= K by NAT_1:13;
then consider kk1 being (Element of ( NAT )) such that A14: (kk1 <= K & ( DataPart ( SW . ( k + 1 ) ) ) = ( DataPart ( SW . kk1 ) )) and A15: ( f . ( SW . ( k + 1 ) ) ) = ( g . ( SW . kk1 ) ) by A10;
A16: ( k + 1 ) = kk1 by A1,A2,A3,A4,A13,A14,CKB53:1;
consider kk being (Element of ( NAT )) such that A17: (kk <= K & ( DataPart ( SW . k ) ) = ( DataPart ( SW . kk ) )) and A18: ( f . ( SW . k ) ) = ( g . ( SW . kk ) ) by A10,A12;
k = kk by A1,A2,A3,A4,A12,A17,CKB53:1;
hence thesis by A6,A18,A15,A16;
end;
suppose K <= k;

then ( DataPart ( SW . K ) ) = ( DataPart ( SW . k ) ) by A5,CKB49:1;
hence thesis by A5,SCMFSA6A:7;
end;
end;
