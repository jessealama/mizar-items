environ
vocabularies NUMBERS,SUBSET_1,INT_1,AMI_1,SCMFSA_2,SF_MASTR,FUNCOP_1,FUNCT_1,FINSUB_1,CARD_3,RELAT_1,TARSKI,AMISTD_2,XBOOLE_0,CARD_1,SCMFSA8A,AMI_3,FSM_1,SCMFSA7B,SCMFSA8B,ARYTM_3,TURING_1,SCMFSA6A,ARYTM_1,VALUED_1,FUNCT_4,SCMFSA_9,UNIALG_2,SCMFSA6B,XXREAL_0,CIRCUIT2,GRAPHSP,NAT_1,SCMFSA6C,MSUALG_1,SFMASTR1,PRE_FF,COMPLEX1,ABIAN,SCMFSA9A,ORDINAL1,PARTFUN1,SCMNORM,RELOC,PBOOLE,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,FINSUB_1,FUNCOP_1,INT_1,ABIAN,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,PRE_FF,CARD_3,FUNCT_4,PBOOLE,VALUED_1,INT_2,XXREAL_0,NAT_1,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA_7,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,CKB16,CKB17,CKB27,CKB35,CKB36;
definitions FUNCOP_1,SCMFSA6A,AFINSQ_1,COMPOS_1,EXTPRO_1,AMISTD_2,MEMSTR_0,CKB16,CKB17,CKB27,CKB35,CKB36;
theorems TARSKI,ZFMISC_1,ABSVALUE,NAT_1,INT_1,NAT_2,FUNCT_1,FUNCT_2,GRFUNC_1,FUNCOP_1,FUNCT_4,PRE_FF,ABIAN,SCMFSA_2,MEMSTR_0,SCMFSA_4,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,SCMFSA_9,SFMASTR1,RELAT_1,XBOOLE_0,XBOOLE_1,CARD_3,XREAL_1,XXREAL_0,ORDINAL1,NAT_D,VALUED_1,PBOOLE,PARTFUN1,FINSEQ_4,COMPOS_1,EXTPRO_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44;
schemes FUNCT_2,NAT_1;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,FINSET_1,FINSUB_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,CARD_3,ABIAN,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,VALUED_1,FUNCT_2,RELAT_1,AFINSQ_1,FUNCT_4,FUNCOP_1,SCMFSA10,AMISTD_2,SCMFSA6A,COMPOS_1,EXTPRO_1,PBOOLE,STRUCT_0,MEMSTR_0;
constructors NAT_D,PRE_FF,ABIAN,SCMFSA_7,SCMFSA6A,SCMFSA6B,MEMSTR_0,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,AMISTD_2,RELSET_1,PRE_POLY,XXREAL_2,PBOOLE,SCMFSA7B,SCMFSA8C,FUNCT_4,AMISTD_1,CKB16,CKB17,CKB27,CKB35,CKB36;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve p1 for (Instruction-Sequence of ( SCM+FSA ));
reserve p2 for (Instruction-Sequence of ( SCM+FSA ));
reserve s1 for (State of ( SCM+FSA ));
reserve s2 for (State of ( SCM+FSA ));
reserve a for  read-write Int-Location;
reserve I for (Program of ( SCM+FSA ));
reserve k for (Element of ( NAT ));
theorem
Th40: (( ProperBodyWhile>0 a,I,s1,p1 & ( DataPart s1 ) = ( DataPart s2 )) implies (for k holds ( DataPart ( ( StepWhile>0 (a,I,p1,s1) ) . k ) ) = ( DataPart ( ( StepWhile>0 (a,I,p2,s2) ) . k ) )))
proof
assume that
A1:  ProperBodyWhile>0 a,I,s1,p1
and
A2: ( DataPart s1 ) = ( DataPart s2 );
set WH = ( while>0 (a,I) );
set ST2 = ( StepWhile>0 (a,I,p2,s2) );
set PT2 = ( p2 +* ( while>0 (a,I) ) );
set ST1 = ( StepWhile>0 (a,I,p1,s1) );
set PT1 = ( p1 +* ( while>0 (a,I) ) );
A3: ( PT2 +* ( while>0 (a,I) ) ) = PT2 by FUNCT_4:93;
A4: ( PT1 +* ( while>0 (a,I) ) ) = PT1 by FUNCT_4:93;
defpred X[ Nat ]
 means
( DataPart ( ST1 . $1 ) ) = ( DataPart ( ST2 . $1 ) );
A5: (for k holds (X[ k ] implies X[ ( k + 1 ) ]))
proof
let k;
set ST1kI = ( Initialize ( ST1 . k ) );
set PT1I = ( PT1 +* I );
set ST2kI = ( Initialize ( ST2 . k ) );
set PT2I = ( PT2 +* I );
A6: I c= PT1I by FUNCT_4:25;
A7: I c= PT2I by FUNCT_4:25;
assume A8: ( DataPart ( ST1 . k ) ) = ( DataPart ( ST2 . k ) );
then A9: ( ( ST1 . k ) . a ) = ( ( ST2 . k ) . a ) by SCMFSA6A:7;
per cases ;
suppose A10: ( ( ST1 . k ) . a ) <= ( 0 );

hence ( DataPart ( ST1 . ( k + 1 ) ) ) = ( DataPart ( ST1 . k ) ) by CKB42:1
.= ( DataPart ( ST2 . ( k + 1 ) ) ) by A8,A9,A10,CKB42:1;
end;
suppose A11: ( ( ST1 . k ) . a ) > ( 0 );

then A12: I is_closed_on ( ST1 . k ),PT1 by A1,CKB35:def 1;
A13: I is_halting_on ( ST1 . k ),PT1 by A1,A11,CKB35:def 1;
then A14: (I is_closed_on ( ST2 . k ),PT2 & I is_halting_on ( ST2 . k ),PT2) by A8,A12,SCMFSA8B:5;
A15: ( DataPart ( ST1 . ( k + 1 ) ) ) = ( DataPart ( Comput (( PT1 +* ( while>0 (a,I) ) ),( Initialize ( ST1 . k ) ),( ( LifeSpan (PT1I,ST1kI) ) + 3 )) ) ) by A4,SCMFSA_9:def 5
.= ( DataPart ( Comput (PT1I,ST1kI,( LifeSpan (PT1I,ST1kI) )) ) ) by A11,A12,A13,CKB41:1;
A16: ( DataPart ( ST2 . ( k + 1 ) ) ) = ( DataPart ( Comput (( PT2 +* ( while>0 (a,I) ) ),( Initialize ( ST2 . k ) ),( ( LifeSpan (PT2I,ST2kI) ) + 3 )) ) ) by A3,SCMFSA_9:def 5
.= ( DataPart ( Comput (PT2I,ST2kI,( LifeSpan (PT2I,ST2kI) )) ) ) by A9,A11,A14,CKB41:1;
A18: ( DataPart ( ST1 . k ) ) = ( DataPart ST1kI ) by MEMSTR_0:79;
then A19: I is_closed_on ST1kI,PT1I by A12,SCMFSA8B:3;
A20: ( DataPart ST1kI ) = ( DataPart ( ST1 . k ) ) by MEMSTR_0:79
.= ( DataPart ST2kI ) by A8,MEMSTR_0:79;
I is_halting_on ST1kI,PT1I by A12,A13,A18,SCMFSA8B:5;
then ( LifeSpan (PT1I,ST1kI) ) = ( LifeSpan (PT2I,ST2kI) ) by A12,A20,A18,A6,A7,SCMFSA8B:3,SCMFSA8C:18;
hence thesis by A15,A16,A20,A19,A6,A7,SCMFSA8C:17;
end;
end;
( DataPart ( ST1 . ( 0 ) ) ) = ( DataPart s1 ) by SCMFSA_9:def 5
.= ( DataPart ( ST2 . ( 0 ) ) ) by A2,SCMFSA_9:def 5;
then A21: X[ ( 0 ) ];
thus (for k holds X[ k ]) from NAT_1:sch 1(A21,A5);
end;
