environ
vocabularies NUMBERS,SUBSET_1,INT_1,AMI_1,SCMFSA_2,SF_MASTR,FUNCOP_1,FUNCT_1,FINSUB_1,CARD_3,RELAT_1,TARSKI,AMISTD_2,XBOOLE_0,CARD_1,SCMFSA8A,AMI_3,FSM_1,SCMFSA7B,SCMFSA8B,ARYTM_3,TURING_1,SCMFSA6A,ARYTM_1,VALUED_1,FUNCT_4,SCMFSA_9,UNIALG_2,SCMFSA6B,XXREAL_0,CIRCUIT2,GRAPHSP,NAT_1,SCMFSA6C,MSUALG_1,SFMASTR1,PRE_FF,COMPLEX1,ABIAN,SCMFSA9A,ORDINAL1,PARTFUN1,SCMNORM,RELOC,PBOOLE,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,FINSUB_1,FUNCOP_1,INT_1,ABIAN,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,PRE_FF,CARD_3,FUNCT_4,PBOOLE,VALUED_1,INT_2,XXREAL_0,NAT_1,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA_7,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,CKB16,CKB17,CKB27,CKB35,CKB36;
definitions FUNCOP_1,SCMFSA6A,AFINSQ_1,COMPOS_1,EXTPRO_1,AMISTD_2,MEMSTR_0,CKB16,CKB17,CKB27,CKB35,CKB36;
theorems TARSKI,ZFMISC_1,ABSVALUE,NAT_1,INT_1,NAT_2,FUNCT_1,FUNCT_2,GRFUNC_1,FUNCOP_1,FUNCT_4,PRE_FF,ABIAN,SCMFSA_2,MEMSTR_0,SCMFSA_4,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,SCMFSA_9,SFMASTR1,RELAT_1,XBOOLE_0,XBOOLE_1,CARD_3,XREAL_1,XXREAL_0,ORDINAL1,NAT_D,VALUED_1,PBOOLE,PARTFUN1,FINSEQ_4,COMPOS_1,EXTPRO_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37;
schemes FUNCT_2,NAT_1;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,FINSET_1,FINSUB_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,CARD_3,ABIAN,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,VALUED_1,FUNCT_2,RELAT_1,AFINSQ_1,FUNCT_4,FUNCOP_1,SCMFSA10,AMISTD_2,SCMFSA6A,COMPOS_1,EXTPRO_1,PBOOLE,STRUCT_0,MEMSTR_0;
constructors NAT_D,PRE_FF,ABIAN,SCMFSA_7,SCMFSA6A,SCMFSA6B,MEMSTR_0,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,AMISTD_2,RELSET_1,PRE_POLY,XXREAL_2,PBOOLE,SCMFSA7B,SCMFSA8C,FUNCT_4,AMISTD_1,CKB16,CKB17,CKB27,CKB35,CKB36;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve p for (Instruction-Sequence of ( SCM+FSA ));
reserve s for (State of ( SCM+FSA ));
reserve a for  read-write Int-Location;
reserve I for (Program of ( SCM+FSA ));
reserve i for (Element of ( NAT ));
reserve j for (Element of ( NAT ));
reserve k for (Element of ( NAT ));
reserve m for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
theorem
Th33: (( ProperBodyWhile>0 a,I,s,p &  WithVariantWhile>0 a,I,s,p) implies (( while>0 (a,I) ) is_halting_on s,p & ( while>0 (a,I) ) is_closed_on s,p))
proof
assume A2: (for k being (Element of ( NAT )) holds (( ( ( StepWhile>0 (a,I,p,s) ) . k ) . a ) > ( 0 ) implies (I is_closed_on ( ( StepWhile>0 (a,I,p,s) ) . k ),( p +* ( while>0 (a,I) ) ) & I is_halting_on ( ( StepWhile>0 (a,I,p,s) ) . k ),( p +* ( while>0 (a,I) ) ))));
set s1 = ( Initialize s );
set p1 = ( p +* ( while>0 (a,I) ) );
A3: ( p1 +* ( while>0 (a,I) ) ) = p1 by FUNCT_4:93;
defpred S[ Nat ]
 means
( ( ( StepWhile>0 (a,I,p,s) ) . $1 ) . a ) <= ( 0 );
given f being (Function of ( product (the Object-Kind of ( SCM+FSA )) ),( NAT )) such that
A4: (for k being (Element of ( NAT )) holds (( f . ( ( StepWhile>0 (a,I,p,s) ) . ( k + 1 ) ) ) < ( f . ( ( StepWhile>0 (a,I,p,s) ) . k ) ) or ( ( ( StepWhile>0 (a,I,p,s) ) . k ) . a ) <= ( 0 )));

deffunc F(Nat) = ( f . ( ( StepWhile>0 (a,I,p,s) ) . $1 ) );
A5: (for k holds (F(( k + 1 )) < F(k) or S[ k ])) by A4;
consider m being (Element of ( NAT )) such that A6: S[ m ] and A7: (for n holds (S[ n ] implies m <= n)) from NAT_1:sch 18(A5);
defpred P[ Nat ]
 means
(( $1 + 1 ) <= m implies (ex k st ( ( StepWhile>0 (a,I,p,s) ) . ( $1 + 1 ) ) = ( Comput (p1,s1,k) )));
A8:now
let k being (Element of ( NAT ));
assume A9: P[ k ];
now
set sk1 = ( ( StepWhile>0 (a,I,p,s) ) . ( k + 1 ) );
set sk = ( ( StepWhile>0 (a,I,p,s) ) . k );
set pk = ( p +* ( while>0 (a,I) ) );
assume A10: ( ( k + 1 ) + 1 ) <= m;
( k + ( 0 ) ) < ( k + ( 1 + 1 ) ) by XREAL_1:6;
then k < m by A10,XXREAL_0:2;
then A11: ( sk . a ) > ( 0 ) by A7;
( ( k + 1 ) + ( 0 ) ) < ( ( k + 1 ) + 1 ) by XREAL_1:6;
then consider n being (Element of ( NAT )) such that A12: sk1 = ( Comput (p1,s1,n) ) by A9,A10,XXREAL_0:2;
A13: sk1 = ( Comput (( pk +* ( while>0 (a,I) ) ),( Initialize sk ),( ( LifeSpan (( pk +* I ),( Initialize sk )) ) + 3 )) ) by A3,SCMFSA_9:def 5;
take m = ( n + ( ( LifeSpan (( pk +* I ),( Initialize sk1 )) ) + 3 ) );
(I is_closed_on sk,pk & I is_halting_on sk,pk) by A2,A11;
then ( IC sk1 ) = ( 0 ) by A13,A11,SCMFSA_9:42;
hence ( ( StepWhile>0 (a,I,p,s) ) . ( ( k + 1 ) + 1 ) ) = ( Comput (p1,s1,m) ) by A12,SCMFSA_9:45;
end;
hence P[ ( k + 1 ) ];
end;
A15: P[ ( 0 ) ]
proof
assume ( ( 0 ) + 1 ) <= m;
take n = ( ( LifeSpan (( ( p +* ( while>0 (a,I) ) ) +* I ),( Initialize s )) ) + 3 );
thus thesis by SCMFSA_9:44;
end;
A16: (for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A15,A8);
per cases ;
suppose m = ( 0 );

then ( s . a ) <= ( 0 ) by A6,SCMFSA_9:def 5;
hence thesis by SCMFSA_9:38;
end;
suppose A17: m <> ( 0 );

set ii = ( ( LifeSpan (( ( p +* ( while>0 (a,I) ) ) +* I ),( Initialize s )) ) + 3 );
set sm = ( ( StepWhile>0 (a,I,p,s) ) . m );
set pm = ( p +* ( while>0 (a,I) ) );
set sm1 = ( Initialize sm );
set pm1 = ( pm +* ( while>0 (a,I) ) );
consider i being Nat such that A18: m = ( i + 1 ) by A17,NAT_1:6;
reconsider i as (Element of ( NAT )) by ORDINAL1:def 12;
set si = ( ( StepWhile>0 (a,I,p,s) ) . i );
set psi = ( p +* ( while>0 (a,I) ) );
A19: sm = ( Comput (( psi +* ( while>0 (a,I) ) ),( Initialize si ),( ( LifeSpan (( psi +* I ),( Initialize si )) ) + 3 )) ) by A18,A3,SCMFSA_9:def 5;
m = ( i + 1 ) by A18;
then consider n being (Element of ( NAT )) such that A20: sm = ( Comput (p1,s1,n) ) by A16;
i < m by A18,NAT_1:13;
then A21: ( si . a ) > ( 0 ) by A7;
then (I is_closed_on si,psi & I is_halting_on si,psi) by A2;
then ( IC sm ) = ( 0 ) by A19,A21,SCMFSA_9:42;
then ( Start-At (( 0 ),( SCM+FSA )) ) c= sm by MEMSTR_0:30;
then A24: sm1 = sm by FUNCT_4:98;
( while>0 (a,I) ) is_halting_on sm,pm by A6,SCMFSA_9:38;
then pm1 halts_on sm1 by SCMFSA7B:def 7;
then consider j being (Element of ( NAT )) such that A25: ( CurInstr (pm,( Comput (pm,sm,j) )) ) = ( halt ( SCM+FSA ) ) by A24,A3,EXTPRO_1:29;
A26: ( Comput (p1,s1,( n + j )) ) = ( Comput (p1,( Comput (p1,s1,n) ),j) ) by EXTPRO_1:4;
( CurInstr (p1,( Comput (p1,s1,( n + j )) )) ) = ( halt ( SCM+FSA ) ) by A20,A25,A26;
then p1 halts_on s1 by EXTPRO_1:29;
hence ( while>0 (a,I) ) is_halting_on s,p by SCMFSA7B:def 7;
now
let q being (Element of ( NAT ));
per cases ;
suppose A27: q <= ii;

A28: ( ( StepWhile>0 (a,I,p,s) ) . ( 0 ) ) = s by SCMFSA_9:def 5;
then A29: ( s . a ) > ( 0 ) by A7,A17;
then (I is_closed_on s,p1 & I is_halting_on s,p1) by A2,A28;
hence ( IC ( Comput (p1,s1,q) ) ) in ( dom ( while>0 (a,I) ) ) by A27,A29,A3,SCMFSA_9:42;
end;
suppose A30: q > ii;

A31:now
take k = ii;
thus (( ( StepWhile>0 (a,I,p,s) ) . 1 ) = ( Comput (p1,s1,k) ) & k <= q) by A30,SCMFSA_9:44;
end;
defpred P2[ Nat ]
 means
(($1 <= m & $1 <> ( 0 )) & (ex k st (( ( StepWhile>0 (a,I,p,s) ) . $1 ) = ( Comput (p1,s1,k) ) & k <= q)));
A32: (for i being Nat holds (P2[ i ] implies i <= m));
( ( 0 ) + 1 ) < ( m + 1 ) by A17,XREAL_1:6;
then 1 <= m by NAT_1:13;
then A33: (ex k being Nat st P2[ k ]) by A31;
consider t being Nat such that A34: (P2[ t ] & (for i being Nat holds (P2[ i ] implies i <= t))) from NAT_1:sch 6(A32,A33);
reconsider t as (Element of ( NAT )) by ORDINAL1:def 12;
per cases ;
suppose t = m;

then consider r being (Element of ( NAT )) such that A35: sm = ( Comput (p1,s1,r) ) and A36: r <= q by A34;
consider x being Nat such that A37: q = ( r + x ) by A36,NAT_1:10;
A38: ( while>0 (a,I) ) is_closed_on sm,pm by A6,SCMFSA_9:38;
reconsider x as (Element of ( NAT )) by ORDINAL1:def 12;
( Comput (p1,s1,q) ) = ( Comput (p1,sm1,x) ) by A24,A35,A37,EXTPRO_1:4;
hence ( IC ( Comput (p1,s1,q) ) ) in ( dom ( while>0 (a,I) ) ) by A38,A3,SCMFSA7B:def 6;
end;
suppose A39: t <> m;

set Dt = ( ( StepWhile>0 (a,I,p,s) ) . t );
set pt = ( p +* ( while>0 (a,I) ) );
consider y being Nat such that A40: t = ( y + 1 ) by A34,NAT_1:6;
reconsider y as (Element of ( NAT )) by ORDINAL1:def 12;
set Dy = ( ( StepWhile>0 (a,I,p,s) ) . y );
set py = ( p +* ( while>0 (a,I) ) );
A41: Dt = ( Comput (( py +* ( while>0 (a,I) ) ),( Initialize Dy ),( ( LifeSpan (( py +* I ),( Initialize Dy )) ) + 3 )) ) by A40,A3,SCMFSA_9:def 5;
( y + ( 0 ) ) < t by A40,XREAL_1:6;
then y < m by A34,XXREAL_0:2;
then A42: ( Dy . a ) > ( 0 ) by A7;
then (I is_closed_on Dy,py & I is_halting_on Dy,py) by A2;
then A43: ( IC Dt ) = ( 0 ) by A41,A42,SCMFSA_9:42;
consider z being (Element of ( NAT )) such that A44: ( ( StepWhile>0 (a,I,p,s) ) . t ) = ( Comput (p1,s1,z) ) and A45: z <= q by A34;
consider w being Nat such that A46: q = ( z + w ) by A45,NAT_1:10;
reconsider w as (Element of ( NAT )) by ORDINAL1:def 12;
A47: Dt = ( Initialize Dt ) by A44,A43,SCMFSA_9:45;
A48: ( Comput (p1,s1,q) ) = ( Comput (( pt +* ( while>0 (a,I) ) ),( Initialize Dt ),w) ) by A47,A3,A44,A46,EXTPRO_1:4;
set z2 = ( z + ( ( LifeSpan (( pt +* I ),( Initialize Dt )) ) + 3 ) );
A49: t < m by A34,A39,XXREAL_0:1;
now
assume A50: z2 <= q;
A51:now
take k = z2;
thus (( ( StepWhile>0 (a,I,p,s) ) . ( t + 1 ) ) = ( Comput (p1,s1,k) ) & k <= q) by A44,A43,A50,SCMFSA_9:45;
end;
( t + 1 ) <= m by A49,NAT_1:13;
hence contradiction by A34,A51,XREAL_1:29;
end;
then A52: w < ( ( LifeSpan (( pt +* I ),( Initialize Dt )) ) + 3 ) by A46,XREAL_1:6;
A53: ( Dt . a ) > ( 0 ) by A7,A49;
then (I is_closed_on Dt,pt & I is_halting_on Dt,pt) by A2;
hence ( IC ( Comput (p1,s1,q) ) ) in ( dom ( while>0 (a,I) ) ) by A52,A48,A53,SCMFSA_9:42;
end;
end;
end;
hence ( while>0 (a,I) ) is_closed_on s,p by SCMFSA7B:def 6;
end;
end;
