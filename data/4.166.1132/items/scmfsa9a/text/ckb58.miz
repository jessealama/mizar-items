environ
vocabularies NUMBERS,SUBSET_1,INT_1,AMI_1,SCMFSA_2,SF_MASTR,FUNCOP_1,FUNCT_1,FINSUB_1,CARD_3,RELAT_1,TARSKI,AMISTD_2,XBOOLE_0,CARD_1,SCMFSA8A,AMI_3,FSM_1,SCMFSA7B,SCMFSA8B,ARYTM_3,TURING_1,SCMFSA6A,ARYTM_1,VALUED_1,FUNCT_4,SCMFSA_9,UNIALG_2,SCMFSA6B,XXREAL_0,CIRCUIT2,GRAPHSP,NAT_1,SCMFSA6C,MSUALG_1,SFMASTR1,PRE_FF,COMPLEX1,ABIAN,SCMFSA9A,ORDINAL1,PARTFUN1,SCMNORM,RELOC,PBOOLE,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,FINSUB_1,FUNCOP_1,INT_1,ABIAN,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,PRE_FF,CARD_3,FUNCT_4,PBOOLE,VALUED_1,INT_2,XXREAL_0,NAT_1,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA_7,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,CKB16,CKB17,CKB27,CKB35,CKB36,CKB46,CKB54,CKB57;
definitions FUNCOP_1,SCMFSA6A,AFINSQ_1,COMPOS_1,EXTPRO_1,AMISTD_2,MEMSTR_0,CKB16,CKB17,CKB27,CKB35,CKB36,CKB46,CKB54,CKB57;
theorems TARSKI,ZFMISC_1,ABSVALUE,NAT_1,INT_1,NAT_2,FUNCT_1,FUNCT_2,GRFUNC_1,FUNCOP_1,FUNCT_4,PRE_FF,ABIAN,SCMFSA_2,MEMSTR_0,SCMFSA_4,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,SCMFSA_9,SFMASTR1,RELAT_1,XBOOLE_0,XBOOLE_1,CARD_3,XREAL_1,XXREAL_0,ORDINAL1,NAT_D,VALUED_1,PBOOLE,PARTFUN1,FINSEQ_4,COMPOS_1,EXTPRO_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56,CKB57;
schemes FUNCT_2,NAT_1;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,FINSET_1,FINSUB_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,CARD_3,ABIAN,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,VALUED_1,FUNCT_2,RELAT_1,AFINSQ_1,FUNCT_4,FUNCOP_1,SCMFSA10,AMISTD_2,SCMFSA6A,COMPOS_1,EXTPRO_1,PBOOLE,STRUCT_0,MEMSTR_0;
constructors NAT_D,PRE_FF,ABIAN,SCMFSA_7,SCMFSA6A,SCMFSA6B,MEMSTR_0,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,AMISTD_2,RELSET_1,PRE_POLY,XXREAL_2,PBOOLE,SCMFSA7B,SCMFSA8C,FUNCT_4,AMISTD_1,CKB16,CKB17,CKB27,CKB35,CKB36,CKB46,CKB54,CKB57;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve p for (Instruction-Sequence of ( SCM+FSA ));
reserve h for (Instruction-Sequence of ( SCM+FSA ));
reserve s for (State of ( SCM+FSA ));
reserve k for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
theorem
(for N,result being  read-write Int-Location holds (N <> result implies (for n being (Element of ( NAT )) holds (n = ( s . N ) implies (( ( IExec (( Fusc_macro (N,result) ),p,s) ) . result ) = ( Fusc n ) & ( ( IExec (( Fusc_macro (N,result) ),p,s) ) . N ) = n)))))
proof
let N being  read-write Int-Location;
let result being  read-write Int-Location;
assume that
A1: N <> result;
set i0 = ( SubFrom (result,result) );
set rem2 = ( 3 -rdRWNotIn { N,result } );
set aux = ( 2 -ndRWNotIn { N,result } );
set next = ( 1 -stRWNotIn { N,result } );
set I3i0 = ( rem2 := 2 );
set I3i1 = ( Divide (aux,rem2) );
set I3I2I0 = ( Macro ( AddTo (next,result) ) );
set I3I2I1 = ( Macro ( AddTo (result,next) ) );
set I3I2 = ( if=0 (rem2,I3I2I0,I3I2I1) );
set I = ( ( I3i0 ';' I3i1 ) ';' I3I2 );
let n being (Element of ( NAT ));
assume that
A2: n = ( s . N );
A3: next <> rem2 by SFMASTR1:21;
A4: aux <> next by SFMASTR1:21;
set I3 = ( while>0 (aux,I) );
deffunc U((Element of ( product (the Object-Kind of ( SCM+FSA )) ))) = ( abs ( $1 . aux ) );
set i2 = ( aux := N );
set i1 = ( next := ( intloc ( 0 ) ) );
set t = ( IExec (( ( i0 ';' i1 ) ';' i2 ),p,s) );
set q = p;
set It = ( Initialized t );
set SWt = ( StepWhile>0 (aux,I,q,It) );
set PWt = ( q +* ( while>0 (aux,I) ) );
defpred X[ Nat ]
 means
(ex au,ne,re being (Element of ( NAT )) st ((((( ( SWt . $1 ) . aux ) = au & ( ( SWt . $1 ) . next ) = ne) & ( ( SWt . $1 ) . result ) = re) & ( ( SWt . $1 ) . N ) = n) & ( Fusc n ) = ( ( ne * ( Fusc au ) ) + ( re * ( Fusc ( au + 1 ) ) ) )));
consider f being (Function of ( product (the Object-Kind of ( SCM+FSA )) ),( NAT )) such that A5: (for x being (Element of ( product (the Object-Kind of ( SCM+FSA )) )) holds ( f . x ) = U(x)) from FUNCT_2:sch 4;
A6: N in { N,result } by TARSKI:def 2;
then A7: N <> next by SFMASTR1:20;
A8: result in { N,result } by TARSKI:def 2;
then A9: aux <> result by SFMASTR1:20;
A10: result <> rem2 by A8,SFMASTR1:20;
A11: next <> result by A8,SFMASTR1:20;
A12: N <> rem2 by A6,SFMASTR1:20;
A13: N <> aux by A6,SFMASTR1:20;
A14: aux <> rem2 by SFMASTR1:21;
A15: (for u being (State of ( SCM+FSA )) holds (for h holds ((ex au,ne,re being (Element of ( NAT )) st ((((( u . aux ) = au & ( u . next ) = ne) & ( u . result ) = re) & ( u . N ) = n) & ( Fusc n ) = ( ( ne * ( Fusc au ) ) + ( re * ( Fusc ( au + 1 ) ) ) ))) implies (ex au1,ne1,re1 being (Element of ( NAT )) st (((((( ( IExec (I,h,u) ) . aux ) = au1 & ( ( IExec (I,h,u) ) . next ) = ne1) & ( ( IExec (I,h,u) ) . result ) = re1) & ( ( IExec (I,h,u) ) . N ) = n) & ( Fusc n ) = ( ( ne1 * ( Fusc au1 ) ) + ( re1 * ( Fusc ( au1 + 1 ) ) ) )) & au1 = ( ( u . aux ) div 2 ))))))
proof
let u being (State of ( SCM+FSA ));
let h;
given au being (Element of ( NAT )),ne being (Element of ( NAT )),re being (Element of ( NAT )) such that
A16: ( u . aux ) = au
and
A17: ( u . next ) = ne
and
A18: ( u . result ) = re
and
A19: ( u . N ) = n
and
A20: ( Fusc n ) = ( ( ne * ( Fusc au ) ) + ( re * ( Fusc ( au + 1 ) ) ) );

A21: ( ( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) ) . next ) = ( ( IExec (( I3i0 ';' I3i1 ),h,u) ) . next ) by SCMFSA6C:3
.= ( ( Exec (I3i1,( IExec (I3i0,h,u) )) ) . next ) by SCMFSA6C:6
.= ( ( IExec (I3i0,h,u) ) . next ) by A4,A3,SCMFSA_2:67
.= ne by A17,SCMFSA7B:3,SFMASTR1:21;
A22: ( ( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) ) . aux ) = ( ( IExec (( I3i0 ';' I3i1 ),h,u) ) . aux ) by SCMFSA6C:3
.= ( ( Exec (I3i1,( IExec (I3i0,h,u) )) ) . aux ) by SCMFSA6C:6
.= ( ( ( IExec (I3i0,h,u) ) . aux ) div ( ( IExec (I3i0,h,u) ) . rem2 ) ) by A14,SCMFSA_2:67
.= ( ( u . aux ) div ( ( IExec (I3i0,h,u) ) . rem2 ) ) by SCMFSA7B:3,SFMASTR1:21
.= ( ( u . aux ) div 2 ) by SCMFSA7B:3;
A23: ( ( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) ) . result ) = ( ( IExec (( I3i0 ';' I3i1 ),h,u) ) . result ) by SCMFSA6C:3
.= ( ( Exec (I3i1,( IExec (I3i0,h,u) )) ) . result ) by SCMFSA6C:6
.= ( ( IExec (I3i0,h,u) ) . result ) by A9,A10,SCMFSA_2:67
.= re by A10,A18,SCMFSA7B:3;
A24: ( ( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) ) . N ) = ( ( IExec (( I3i0 ';' I3i1 ),h,u) ) . N ) by SCMFSA6C:3
.= ( ( Exec (I3i1,( IExec (I3i0,h,u) )) ) . N ) by SCMFSA6C:6
.= ( ( IExec (I3i0,h,u) ) . N ) by A12,A13,SCMFSA_2:67
.= n by A12,A19,SCMFSA7B:3;
A25: ( ( IExec (( I3i0 ';' I3i1 ),h,u) ) . rem2 ) = ( ( Exec (I3i1,( IExec (I3i0,h,u) )) ) . rem2 ) by SCMFSA6C:6
.= ( ( ( IExec (I3i0,h,u) ) . aux ) mod ( ( IExec (I3i0,h,u) ) . rem2 ) ) by SCMFSA_2:67
.= ( ( u . aux ) mod ( ( IExec (I3i0,h,u) ) . rem2 ) ) by SCMFSA7B:3,SFMASTR1:21
.= ( ( u . aux ) mod 2 ) by SCMFSA7B:3;
per cases ;
suppose A26: au is  even;

reconsider ne1 = ( ne + re ) as (Element of ( NAT ));
reconsider au1 = ( ( u . aux ) div 2 ) as (Element of ( NAT )) by A16,INT_1:3,INT_1:55;
take au1;
take ne1;
take re;
consider k being (Element of ( NAT )) such that A27: au = ( 2 * k ) by A26,ABIAN:def 2;
A28: ( ( u . aux ) mod 2 ) = ( ( ( 2 * k ) + ( 0 ) ) mod 2 ) by A16,A27
.= ( ( 0 ) mod 2 ) by NAT_D:21
.= ( 0 ) by NAT_D:26;
( ( IExec (I,h,u) ) . aux ) = ( ( IExec (I3I2,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . aux ) by SCMFSA6C:1
.= ( ( IExec (I3I2I0,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . aux ) by A25,A28,SCMFSA8B:18
.= ( ( IExec (I3I2I0,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . aux )
.= ( ( Exec (( AddTo (next,result) ),( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) )) ) . aux ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (next,result) ),( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) )) ) . aux )
.= ( ( u . aux ) div 2 ) by A4,A22,SCMFSA_2:64;
hence ( ( IExec (I,h,u) ) . aux ) = au1;
thus ( ( IExec (I,h,u) ) . next ) = ( ( IExec (I3I2,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . next ) by SCMFSA6C:1
.= ( ( IExec (I3I2I0,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . next ) by A25,A28,SCMFSA8B:18
.= ( ( IExec (I3I2I0,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . next )
.= ( ( Exec (( AddTo (next,result) ),( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) )) ) . next ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (next,result) ),( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) )) ) . next )
.= ne1 by A21,A23,SCMFSA_2:64;
thus ( ( IExec (I,h,u) ) . result ) = ( ( IExec (I3I2,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . result ) by SCMFSA6C:1
.= ( ( IExec (I3I2I0,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . result ) by A25,A28,SCMFSA8B:18
.= ( ( IExec (I3I2I0,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . result )
.= ( ( Exec (( AddTo (next,result) ),( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) )) ) . result ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (next,result) ),( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) )) ) . result )
.= re by A11,A23,SCMFSA_2:64;
thus ( ( IExec (I,h,u) ) . N ) = ( ( IExec (I3I2,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . N ) by SCMFSA6C:1
.= ( ( IExec (I3I2I0,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . N ) by A25,A28,SCMFSA8B:18
.= ( ( IExec (I3I2I0,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . N )
.= ( ( Exec (( AddTo (next,result) ),( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) )) ) . N ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (next,result) ),( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) )) ) . N )
.= n by A7,A24,SCMFSA_2:64;
au1 = k by A16,A27,NAT_D:20;
hence ( Fusc n ) = ( ( ne1 * ( Fusc au1 ) ) + ( re * ( Fusc ( au1 + 1 ) ) ) ) by A20,A27,PRE_FF:20;
thus thesis;
end;
suppose A29: au is  odd;

reconsider re1 = ( ne + re ) as (Element of ( NAT ));
reconsider au1 = ( ( u . aux ) div 2 ) as (Element of ( NAT )) by A16,INT_1:3,INT_1:55;
take au1;
take ne;
take re1;
consider k being (Element of ( NAT )) such that A30: au = ( ( 2 * k ) + 1 ) by A29,ABIAN:9;
A31: ( ( u . aux ) mod 2 ) = ( 1 mod 2 ) by A16,A30,NAT_D:21
.= 1 by NAT_D:24;
( ( IExec (I,h,u) ) . aux ) = ( ( IExec (I3I2,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . aux ) by SCMFSA6C:1
.= ( ( IExec (I3I2I1,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . aux ) by A25,A31,SCMFSA8B:18
.= ( ( IExec (I3I2I1,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . aux )
.= ( ( Exec (( AddTo (result,next) ),( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) )) ) . aux ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (result,next) ),( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) )) ) . aux )
.= ( ( u . aux ) div 2 ) by A9,A22,SCMFSA_2:64;
hence ( ( IExec (I,h,u) ) . aux ) = au1;
thus ( ( IExec (I,h,u) ) . next ) = ( ( IExec (I3I2,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . next ) by SCMFSA6C:1
.= ( ( IExec (I3I2I1,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . next ) by A25,A31,SCMFSA8B:18
.= ( ( IExec (I3I2I1,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . next )
.= ( ( Exec (( AddTo (result,next) ),( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) )) ) . next ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (result,next) ),( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) )) ) . next )
.= ne by A11,A21,SCMFSA_2:64;
thus ( ( IExec (I,h,u) ) . result ) = ( ( IExec (I3I2,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . result ) by SCMFSA6C:1
.= ( ( IExec (I3I2I1,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . result ) by A25,A31,SCMFSA8B:18
.= ( ( IExec (I3I2I1,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . result )
.= ( ( Exec (( AddTo (result,next) ),( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) )) ) . result ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (result,next) ),( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) )) ) . result )
.= re1 by A21,A23,SCMFSA_2:64;
thus ( ( IExec (I,h,u) ) . N ) = ( ( IExec (I3I2,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . N ) by SCMFSA6C:1
.= ( ( IExec (I3I2I1,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . N ) by A25,A31,SCMFSA8B:18
.= ( ( IExec (I3I2I1,h,( IExec (( I3i0 ';' I3i1 ),h,u) )) ) . N )
.= ( ( Exec (( AddTo (result,next) ),( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) )) ) . N ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (result,next) ),( Initialized ( IExec (( I3i0 ';' I3i1 ),h,u) ) )) ) . N )
.= n by A1,A24,SCMFSA_2:64;
au1 = ( ( 2 * k ) div 2 ) by A16,A30,NAT_2:26
.= k by NAT_D:20;
hence ( Fusc n ) = ( ( ne * ( Fusc au1 ) ) + ( re1 * ( Fusc ( au1 + 1 ) ) ) ) by A20,A30,PRE_FF:19;
thus thesis;
end;
end;
A32: ( It . ( intloc ( 0 ) ) ) = 1 by SCMFSA6A:38;
A33: (for k being (Element of ( NAT )) holds (X[ k ] implies X[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
given au being (Element of ( NAT )),ne being (Element of ( NAT )),re being (Element of ( NAT )) such that
A34: ( ( SWt . k ) . aux ) = au
and
A35: ( ( SWt . k ) . next ) = ne
and
A36: ( ( SWt . k ) . result ) = re
and
A37: ( ( SWt . k ) . N ) = n
and
A38: ( Fusc n ) = ( ( ne * ( Fusc au ) ) + ( re * ( Fusc ( au + 1 ) ) ) );

A39: ( ( SWt . k ) . ( intloc ( 0 ) ) ) = 1 by A32,CKB44:1;
per cases ;
suppose A40: ( ( SWt . k ) . aux ) > ( 0 );

consider au1,ne1,re1 being (Element of ( NAT )) such that A41: ( ( IExec (I,PWt,( SWt . k )) ) . aux ) = au1 and A42: ( ( IExec (I,PWt,( SWt . k )) ) . next ) = ne1 and A43: ( ( IExec (I,PWt,( SWt . k )) ) . result ) = re1 and A44: ( ( IExec (I,PWt,( SWt . k )) ) . N ) = n and A45: ( Fusc n ) = ( ( ne1 * ( Fusc au1 ) ) + ( re1 * ( Fusc ( au1 + 1 ) ) ) ) and au1 = ( ( ( SWt . k ) . aux ) div 2 ) by A15,A34,A35,A36,A37,A38;
take au1;
take ne1;
take re1;
A46: ( DataPart ( SWt . ( k + 1 ) ) ) = ( DataPart ( IExec (I,PWt,( SWt . k )) ) ) by A39,A40,CKB43:1;
hence ( ( SWt . ( k + 1 ) ) . aux ) = au1 by A41,SCMFSA6A:7;
thus ( ( SWt . ( k + 1 ) ) . next ) = ne1 by A46,A42,SCMFSA6A:7;
thus ( ( SWt . ( k + 1 ) ) . result ) = re1 by A46,A43,SCMFSA6A:7;
thus ( ( SWt . ( k + 1 ) ) . N ) = n by A46,A44,SCMFSA6A:7;
thus thesis by A45;
end;
suppose A47: ( ( SWt . k ) . aux ) <= ( 0 );

take au;
take ne;
take re;
A48: ( DataPart ( SWt . ( k + 1 ) ) ) = ( DataPart ( SWt . k ) ) by A47,CKB42:1;
hence ( ( SWt . ( k + 1 ) ) . aux ) = au by A34,SCMFSA6A:7;
thus ( ( SWt . ( k + 1 ) ) . next ) = ne by A35,A48,SCMFSA6A:7;
thus ( ( SWt . ( k + 1 ) ) . result ) = re by A36,A48,SCMFSA6A:7;
thus ( ( SWt . ( k + 1 ) ) . N ) = n by A37,A48,SCMFSA6A:7;
thus thesis by A38;
end;
end;
( t . ( intloc ( 0 ) ) ) = 1 by SCMFSA6B:11;
then A49: ( DataPart t ) = ( DataPart It ) by SCMFSA8C:7;
A50: X[ ( 0 ) ]
proof
take au = n;
take ne = 1;
take re = ( 0 );
A51: ( SWt . ( 0 ) ) = It by SCMFSA_9:def 5;
hence ( ( SWt . ( 0 ) ) . aux ) = ( t . aux ) by A49,SCMFSA6A:7
.= ( ( Exec (i2,( IExec (( i0 ';' i1 ),p,s) )) ) . aux ) by SCMFSA6C:6
.= ( ( IExec (( i0 ';' i1 ),p,s) ) . N ) by SCMFSA_2:63
.= ( ( Exec (i1,( Exec (i0,( Initialized s )) )) ) . N ) by SCMFSA6C:8
.= ( ( Exec (i0,( Initialized s )) ) . N ) by A7,SCMFSA_2:63
.= ( ( Initialized s ) . N ) by A1,SCMFSA_2:65
.= au by A2,SCMFSA6C:3;
thus ( ( SWt . ( 0 ) ) . next ) = ( t . next ) by A49,A51,SCMFSA6A:7
.= ( ( Exec (i2,( IExec (( i0 ';' i1 ),p,s) )) ) . next ) by SCMFSA6C:6
.= ( ( IExec (( i0 ';' i1 ),p,s) ) . next ) by A4,SCMFSA_2:63
.= ( ( Exec (i1,( Exec (i0,( Initialized s )) )) ) . next ) by SCMFSA6C:8
.= ( ( Exec (i0,( Initialized s )) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= ( ( Initialized s ) . ( intloc ( 0 ) ) ) by SCMFSA_2:65
.= ne by SCMFSA6A:38;
thus ( ( SWt . ( 0 ) ) . result ) = ( t . result ) by A49,A51,SCMFSA6A:7
.= ( ( Exec (i2,( IExec (( i0 ';' i1 ),p,s) )) ) . result ) by SCMFSA6C:6
.= ( ( IExec (( i0 ';' i1 ),p,s) ) . result ) by A9,SCMFSA_2:63
.= ( ( Exec (i1,( Exec (i0,( Initialized s )) )) ) . result ) by SCMFSA6C:8
.= ( ( Exec (i0,( Initialized s )) ) . result ) by A11,SCMFSA_2:63
.= ( ( ( Initialized s ) . result ) - ( ( Initialized s ) . result ) ) by SCMFSA_2:65
.= re;
thus ( ( SWt . ( 0 ) ) . N ) = ( t . N ) by A49,A51,SCMFSA6A:7
.= ( ( Exec (i2,( IExec (( i0 ';' i1 ),p,s) )) ) . N ) by SCMFSA6C:6
.= ( ( IExec (( i0 ';' i1 ),p,s) ) . N ) by A13,SCMFSA_2:63
.= ( ( Exec (i1,( Exec (i0,( Initialized s )) )) ) . N ) by SCMFSA6C:8
.= ( ( Exec (i0,( Initialized s )) ) . N ) by A7,SCMFSA_2:63
.= ( ( Initialized s ) . N ) by A1,SCMFSA_2:65
.= n by A2,SCMFSA6C:3;
thus thesis;
end;
A52: (for k being (Element of ( NAT )) holds X[ k ]) from NAT_1:sch 1(A50,A33);
(for k being (Element of ( NAT )) holds (( f . ( SWt . ( k + 1 ) ) ) < ( f . ( SWt . k ) ) or ( ( SWt . k ) . aux ) <= ( 0 )))
proof
let k being (Element of ( NAT ));
consider au,ne,re being (Element of ( NAT )) such that A53: ( ( SWt . k ) . aux ) = au and A54: (((( ( SWt . k ) . next ) = ne & ( ( SWt . k ) . result ) = re) & ( ( SWt . k ) . N ) = n) & ( Fusc n ) = ( ( ne * ( Fusc au ) ) + ( re * ( Fusc ( au + 1 ) ) ) )) by A52;
A55: ( f . ( SWt . k ) ) = ( abs ( ( SWt . k ) . aux ) ) by A5
.= au by A53,ABSVALUE:def 1;
now
consider au1,ne1,re1 being (Element of ( NAT )) such that A56: ( ( IExec (I,PWt,( SWt . k )) ) . aux ) = au1 and ( ( IExec (I,PWt,( SWt . k )) ) . next ) = ne1 and ( ( IExec (I,PWt,( SWt . k )) ) . result ) = re1 and ( ( IExec (I,PWt,( SWt . k )) ) . N ) = n and ( Fusc n ) = ( ( ne1 * ( Fusc au1 ) ) + ( re1 * ( Fusc ( au1 + 1 ) ) ) ) and A57: au1 = ( ( ( SWt . k ) . aux ) div 2 ) by A15,A53,A54;
assume A58: au > ( 0 );
( ( SWt . k ) . ( intloc ( 0 ) ) ) = 1 by A32,CKB44:1;
then ( DataPart ( SWt . ( k + 1 ) ) ) = ( DataPart ( IExec (I,PWt,( SWt . k )) ) ) by A53,A58,CKB43:1;
then A59: ( ( SWt . ( k + 1 ) ) . aux ) = au1 by A56,SCMFSA6A:7;
( f . ( SWt . ( k + 1 ) ) ) = ( abs ( ( SWt . ( k + 1 ) ) . aux ) ) by A5
.= au1 by A59,ABSVALUE:def 1;
hence ( f . ( SWt . ( k + 1 ) ) ) < ( f . ( SWt . k ) ) by A53,A55,A58,A57,INT_1:56;
end;
hence thesis by A53;
end;
then A60:  WithVariantWhile>0 aux,I,It,q by CKB36:def 1;
then consider k being (Element of ( NAT )) such that A61: ( ExitsAtWhile>0 (aux,I,q,It) ) = k and A62: ( ( ( StepWhile>0 (aux,I,q,It) ) . k ) . aux ) <= ( 0 ) and (for i being (Element of ( NAT )) holds (( ( SWt . i ) . aux ) <= ( 0 ) implies k <= i)) and ( DataPart ( Comput (( q +* ( while>0 (aux,I) ) ),( Initialize It ),( LifeSpan (( q +* ( while>0 (aux,I) ) ),( Initialize It )) )) ) ) = ( DataPart ( ( StepWhile>0 (aux,I,q,It) ) . k ) ) by CKB46:def 1;
A63: ( DataPart ( IExec (I3,q,t) ) ) = ( DataPart ( SWt . k ) ) by A60,A61,CKB48:1;
consider au,ne,re being (Element of ( NAT )) such that A64: ( ( SWt . k ) . aux ) = au and ( ( SWt . k ) . next ) = ne and A65: ( ( SWt . k ) . result ) = re and A66: ( ( SWt . k ) . N ) = n and A67: ( Fusc n ) = ( ( ne * ( Fusc au ) ) + ( re * ( Fusc ( au + 1 ) ) ) ) by A52;
A68: au = ( 0 ) by A62,A64;
(I3 is_closed_on It,q & I3 is_halting_on It,q) by A60,CKB39:1;
then A69: (I3 is_closed_on t,q & I3 is_halting_on t,q) by A49,SCMFSA8B:5;
hence ( ( IExec (( Fusc_macro (N,result) ),p,s) ) . result ) = ( ( IExec (I3,q,t) ) . result ) by SFMASTR1:7
.= ( Fusc n ) by A65,A67,A68,A63,PRE_FF:15,SCMFSA6A:7;
thus ( ( IExec (( Fusc_macro (N,result) ),p,s) ) . N ) = ( ( IExec (I3,q,t) ) . N ) by A69,SFMASTR1:7
.= n by A66,A63,SCMFSA6A:7;
end;
