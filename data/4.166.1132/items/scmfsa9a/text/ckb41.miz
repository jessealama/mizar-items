environ
vocabularies NUMBERS,SUBSET_1,INT_1,AMI_1,SCMFSA_2,SF_MASTR,FUNCOP_1,FUNCT_1,FINSUB_1,CARD_3,RELAT_1,TARSKI,AMISTD_2,XBOOLE_0,CARD_1,SCMFSA8A,AMI_3,FSM_1,SCMFSA7B,SCMFSA8B,ARYTM_3,TURING_1,SCMFSA6A,ARYTM_1,VALUED_1,FUNCT_4,SCMFSA_9,UNIALG_2,SCMFSA6B,XXREAL_0,CIRCUIT2,GRAPHSP,NAT_1,SCMFSA6C,MSUALG_1,SFMASTR1,PRE_FF,COMPLEX1,ABIAN,SCMFSA9A,ORDINAL1,PARTFUN1,SCMNORM,RELOC,PBOOLE,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,FINSUB_1,FUNCOP_1,INT_1,ABIAN,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,PRE_FF,CARD_3,FUNCT_4,PBOOLE,VALUED_1,INT_2,XXREAL_0,NAT_1,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA_7,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,CKB16,CKB17,CKB27,CKB35,CKB36;
definitions FUNCOP_1,SCMFSA6A,AFINSQ_1,COMPOS_1,EXTPRO_1,AMISTD_2,MEMSTR_0,CKB16,CKB17,CKB27,CKB35,CKB36;
theorems TARSKI,ZFMISC_1,ABSVALUE,NAT_1,INT_1,NAT_2,FUNCT_1,FUNCT_2,GRFUNC_1,FUNCOP_1,FUNCT_4,PRE_FF,ABIAN,SCMFSA_2,MEMSTR_0,SCMFSA_4,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,SCMFSA_9,SFMASTR1,RELAT_1,XBOOLE_0,XBOOLE_1,CARD_3,XREAL_1,XXREAL_0,ORDINAL1,NAT_D,VALUED_1,PBOOLE,PARTFUN1,FINSEQ_4,COMPOS_1,EXTPRO_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40;
schemes FUNCT_2,NAT_1;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,FINSET_1,FINSUB_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,CARD_3,ABIAN,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,VALUED_1,FUNCT_2,RELAT_1,AFINSQ_1,FUNCT_4,FUNCOP_1,SCMFSA10,AMISTD_2,SCMFSA6A,COMPOS_1,EXTPRO_1,PBOOLE,STRUCT_0,MEMSTR_0;
constructors NAT_D,PRE_FF,ABIAN,SCMFSA_7,SCMFSA6A,SCMFSA6B,MEMSTR_0,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,AMISTD_2,RELSET_1,PRE_POLY,XXREAL_2,PBOOLE,SCMFSA7B,SCMFSA8C,FUNCT_4,AMISTD_1,CKB16,CKB17,CKB27,CKB35,CKB36;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve p for (Instruction-Sequence of ( SCM+FSA ));
reserve s for (State of ( SCM+FSA ));
reserve a for  read-write Int-Location;
reserve I for (Program of ( SCM+FSA ));
reserve k for (Element of ( NAT ));
theorem
Th36: (((I is_closed_on s,p & I is_halting_on s,p) & ( s . a ) > ( 0 )) implies ( DataPart ( Comput (( p +* ( while>0 (a,I) ) ),( Initialize s ),( ( LifeSpan (( p +* I ),( Initialize s )) ) + 3 )) ) ) = ( DataPart ( Comput (( p +* I ),( Initialize s ),( LifeSpan (( p +* I ),( Initialize s )) )) ) ))
proof
assume that
A1: (I is_closed_on s,p & I is_halting_on s,p)
and
A2: ( s . a ) > ( 0 );
set sI = ( Initialize s );
set pI = ( p +* I );
set s1 = ( Initialize s );
set p1 = ( p +* ( while>0 (a,I) ) );
A3: ( while>0 (a,I) ) c= p1 by FUNCT_4:25;
defpred P[ Nat ]
 means
($1 <= ( LifeSpan (pI,sI) ) implies (( IC ( Comput (p1,s1,( 1 + $1 )) ) ) = ( ( IC ( Comput (pI,sI,$1) ) ) + 4 ) & ( DataPart ( Comput (p1,s1,( 1 + $1 )) ) ) = ( DataPart ( Comput (pI,sI,$1) ) )));
A4:now
let k being (Element of ( NAT ));
assume A5: P[ k ];
now
A6: ( k + ( 0 ) ) < ( k + 1 ) by XREAL_1:6;
assume ( k + 1 ) <= ( LifeSpan (pI,sI) );
then k < ( LifeSpan (pI,sI) ) by A6,XXREAL_0:2;
hence (( IC ( Comput (p1,s1,( ( 1 + k ) + 1 )) ) ) = ( ( IC ( Comput (pI,sI,( k + 1 )) ) ) + 4 ) & ( DataPart ( Comput (p1,s1,( ( 1 + k ) + 1 )) ) ) = ( DataPart ( Comput (pI,sI,( k + 1 )) ) )) by A1,A5,SCMFSA_9:39;
end;
hence P[ ( k + 1 ) ];
end;
set i = ( a >0_goto 4 );
set s2 = ( Comput (p1,s1,1) );
set p2 = p1;
B7: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) by MEMSTR_0:15;
A8: ( IC s1 ) = ( IC ( Start-At (( 0 ),( SCM+FSA )) ) ) by B7,FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
(not a in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) )) by SCMFSA_2:102;
then A9: ( s1 . a ) = ( s . a ) by FUNCT_4:11;
set loc4 = ( ( card I ) + 4 );
A10: ( p1 /. ( IC s1 ) ) = ( p1 . ( IC s1 ) ) by PBOOLE:143;
( 0 ) in ( dom ( while>0 (a,I) ) ) by SCMFSA_9:10;
then ( p1 . ( 0 ) ) = ( ( while>0 (a,I) ) . ( 0 ) ) by FUNCT_4:13
.= i by SCMFSA_9:11;
then A11: ( CurInstr (p1,s1) ) = i by A8,A10;
A12: ( Comput (p1,s1,( ( 0 ) + 1 )) ) = ( Following (p1,( Comput (p1,s1,( 0 )) )) ) by EXTPRO_1:3
.= ( Following (p1,s1) ) by EXTPRO_1:2
.= ( Exec (i,s1) ) by A11;
then ((for c being Int-Location holds ( s2 . c ) = ( s1 . c )) & (for f being FinSeq-Location holds ( s2 . f ) = ( s1 . f ))) by SCMFSA_2:71;
then A13: ( DataPart s2 ) = ( DataPart s1 ) by SCMFSA6A:7
.= ( DataPart sI );
A14: ( IC s2 ) = 4 by A2,A12,A9,SCMFSA_2:71;
A15: P[ ( 0 ) ]
proof
assume ( 0 ) <= ( LifeSpan (pI,sI) );
B16: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) by MEMSTR_0:15;
( IC ( Comput (pI,sI,( 0 )) ) ) = ( IC sI ) by EXTPRO_1:2
.= ( IC ( Start-At (( 0 ),( SCM+FSA )) ) ) by B16,FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
hence thesis by A14,A13,EXTPRO_1:2;
end;
(for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A15,A4);
then A17: P[ (( LifeSpan (pI,sI) ) qua (Element of ( NAT ))) ];
set s4 = ( Comput (p1,s1,( ( ( 1 + ( LifeSpan (pI,sI) ) ) + 1 ) + 1 )) );
set p4 = p1;
set s3 = ( Comput (p1,s1,( ( 1 + ( LifeSpan (pI,sI) ) ) + 1 )) );
set p3 = p1;
A18: loc4 in ( dom ( while>0 (a,I) ) ) by SCMFSA_9:33;
set s2 = ( Comput (p1,s1,( 1 + ( LifeSpan (pI,sI) ) )) );
A19: ( CurInstr (p2,s2) ) = ( goto loc4 ) by A1,A17,SCMFSA_9:40;
A20: s3 = ( Following (p1,s2) ) by EXTPRO_1:3
.= ( Exec (( goto loc4 ),s2) ) by A19;
then A21: ((for c being Int-Location holds ( s3 . c ) = ( s2 . c )) & (for f being FinSeq-Location holds ( s3 . f ) = ( s2 . f ))) by SCMFSA_2:69;
A22: ( p3 . loc4 ) = ( ( while>0 (a,I) ) . loc4 ) by A18,A3,GRFUNC_1:2
.= ( goto ( 0 ) ) by SCMFSA_9:41;
A23: ( p3 /. ( IC s3 ) ) = ( p3 . ( IC s3 ) ) by PBOOLE:143;
( IC s3 ) = loc4 by A20,SCMFSA_2:69;
then A24: ( CurInstr (p3,s3) ) = ( goto ( 0 ) ) by A22,A23;
s4 = ( Following (p1,s3) ) by EXTPRO_1:3
.= ( Exec (( goto ( 0 ) ),s3) ) by A24;
then ((for c being Int-Location holds ( s4 . c ) = ( s3 . c )) & (for f being FinSeq-Location holds ( s4 . f ) = ( s3 . f ))) by SCMFSA_2:69;
hence ( DataPart ( Comput (p1,s1,( ( LifeSpan (pI,sI) ) + 3 )) ) ) = ( DataPart s3 ) by SCMFSA6A:7
.= ( DataPart ( Comput (pI,sI,( LifeSpan (pI,sI) )) ) ) by A17,A21,SCMFSA6A:7;
end;
