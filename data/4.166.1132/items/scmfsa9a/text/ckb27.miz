environ
vocabularies NUMBERS,SUBSET_1,INT_1,AMI_1,SCMFSA_2,SF_MASTR,FUNCOP_1,FUNCT_1,FINSUB_1,CARD_3,RELAT_1,TARSKI,AMISTD_2,XBOOLE_0,CARD_1,SCMFSA8A,AMI_3,FSM_1,SCMFSA7B,SCMFSA8B,ARYTM_3,TURING_1,SCMFSA6A,ARYTM_1,VALUED_1,FUNCT_4,SCMFSA_9,UNIALG_2,SCMFSA6B,XXREAL_0,CIRCUIT2,GRAPHSP,NAT_1,SCMFSA6C,MSUALG_1,SFMASTR1,PRE_FF,COMPLEX1,ABIAN,SCMFSA9A,ORDINAL1,PARTFUN1,SCMNORM,RELOC,PBOOLE,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,FINSUB_1,FUNCOP_1,INT_1,ABIAN,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,PRE_FF,CARD_3,FUNCT_4,PBOOLE,VALUED_1,INT_2,XXREAL_0,NAT_1,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA_7,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,CKB16,CKB17;
definitions FUNCOP_1,SCMFSA6A,AFINSQ_1,COMPOS_1,EXTPRO_1,AMISTD_2,MEMSTR_0,CKB16,CKB17;
theorems TARSKI,ZFMISC_1,ABSVALUE,NAT_1,INT_1,NAT_2,FUNCT_1,FUNCT_2,GRFUNC_1,FUNCOP_1,FUNCT_4,PRE_FF,ABIAN,SCMFSA_2,MEMSTR_0,SCMFSA_4,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,SCMFSA_9,SFMASTR1,RELAT_1,XBOOLE_0,XBOOLE_1,CARD_3,XREAL_1,XXREAL_0,ORDINAL1,NAT_D,VALUED_1,PBOOLE,PARTFUN1,FINSEQ_4,COMPOS_1,EXTPRO_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26;
schemes FUNCT_2,NAT_1;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,FINSET_1,FINSUB_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,CARD_3,ABIAN,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,VALUED_1,FUNCT_2,RELAT_1,AFINSQ_1,FUNCT_4,FUNCOP_1,SCMFSA10,AMISTD_2,SCMFSA6A,COMPOS_1,EXTPRO_1,PBOOLE,STRUCT_0,MEMSTR_0;
constructors NAT_D,PRE_FF,ABIAN,SCMFSA_7,SCMFSA6A,SCMFSA6B,MEMSTR_0,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,AMISTD_2,RELSET_1,PRE_POLY,XXREAL_2,PBOOLE,SCMFSA7B,SCMFSA8C,FUNCT_4,AMISTD_1,CKB16,CKB17;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve p for (Instruction-Sequence of ( SCM+FSA ));
reserve s for (State of ( SCM+FSA ));
reserve a for  read-write Int-Location;
reserve I for (Program of ( SCM+FSA ));
reserve i for (Element of ( NAT ));
reserve j for (Element of ( NAT ));
reserve k for (Element of ( NAT ));
reserve m for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
definition
let p;
let s being (State of ( SCM+FSA ));
let a being  read-write Int-Location;
let I being (Program of ( SCM+FSA ));
assume that
A1: ( ProperBodyWhile=0 a,I,s,p or I is  parahalting)
and
A2:  WithVariantWhile=0 a,I,s,p;
func ExitsAtWhile=0 (a,I,p,s) -> (Element of ( NAT )) means 
:Def3: (ex k being (Element of ( NAT )) st (((it = k & ( ( ( StepWhile=0 (a,I,p,s) ) . k ) . a ) <> ( 0 )) & (for i being (Element of ( NAT )) holds (( ( ( StepWhile=0 (a,I,p,s) ) . i ) . a ) <> ( 0 ) implies k <= i))) & ( DataPart ( Comput (( p +* ( while=0 (a,I) ) ),( Initialize s ),( LifeSpan (( p +* ( while=0 (a,I) ) ),( Initialize s )) )) ) ) = ( DataPart ( ( StepWhile=0 (a,I,p,s) ) . k ) )));
existence
proof
set S = ( Initialize s );
set P = ( p +* ( while=0 (a,I) ) );
set SW = ( StepWhile=0 (a,I,p,s) );
set PW = ( p +* ( while=0 (a,I) ) );
A3: ( while=0 (a,I) ) c= PW by FUNCT_4:25;
A4: ( PW +* ( while=0 (a,I) ) ) = PW by FUNCT_4:93;
defpred X[ Nat ]
 means
( ( SW . $1 ) . a ) <> ( 0 );
consider f being (Function of ( product (the Object-Kind of ( SCM+FSA )) ),( NAT )) such that A7: (for k being (Element of ( NAT )) holds (( f . ( SW . ( k + 1 ) ) ) < ( f . ( SW . k ) ) or X[ k ])) by A2,CKB17:def 1;
deffunc U(Nat) = ( f . ( SW . $1 ) );
A8: (for k being (Element of ( NAT )) holds (U(( k + 1 )) < U(k) or X[ k ])) by A7;
consider m such that A9: X[ m ] and A10: (for n holds (X[ n ] implies m <= n)) from NAT_1:sch 18(A8);
take m;
take m;
thus m = m;
thus ( ( SW . m ) . a ) <> ( 0 ) by A9;
thus (for n holds (( ( SW . n ) . a ) <> ( 0 ) implies m <= n)) by A10;
defpred P[ Nat ]
 means
(( $1 + 1 ) <= m implies (ex k st ( ( StepWhile=0 (a,I,p,s) ) . ( $1 + 1 ) ) = ( Comput (P,S,k) )));
A11:  ProperBodyWhile=0 a,I,s,p by A1,CKB18:1;
A12:now
let k being (Element of ( NAT ));
assume A13: P[ k ];
now
set sk1 = ( ( StepWhile=0 (a,I,p,s) ) . ( k + 1 ) );
set sk = ( ( StepWhile=0 (a,I,p,s) ) . k );
set pk = ( p +* ( while=0 (a,I) ) );
assume A14: ( ( k + 1 ) + 1 ) <= m;
( k + ( 0 ) ) < ( k + ( 1 + 1 ) ) by XREAL_1:6;
then k < m by A14,XXREAL_0:2;
then A15: ( sk . a ) = ( 0 ) by A10;
( ( k + 1 ) + ( 0 ) ) < ( ( k + 1 ) + 1 ) by XREAL_1:6;
then consider n being (Element of ( NAT )) such that A16: sk1 = ( Comput (P,S,n) ) by A13,A14,XXREAL_0:2;
A17: sk1 = ( Comput (( pk +* ( while=0 (a,I) ) ),( Initialize sk ),( ( LifeSpan (( pk +* I ),( Initialize sk )) ) + 3 )) ) by A4,SCMFSA_9:def 4;
take m = ( n + ( ( LifeSpan (( pk +* I ),( Initialize sk1 )) ) + 3 ) );
(I is_closed_on sk,pk & I is_halting_on sk,pk) by A11,A15,CKB16:def 1;
then ( IC sk1 ) = ( 0 ) by A17,A15,SCMFSA_9:22;
hence ( ( StepWhile=0 (a,I,p,s) ) . ( ( k + 1 ) + 1 ) ) = ( Comput (P,S,m) ) by A16,SCMFSA_9:26;
end;
hence P[ ( k + 1 ) ];
end;
B18: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) by MEMSTR_0:15;
A19: P[ ( 0 ) ]
proof
assume ( ( 0 ) + 1 ) <= m;
take n = ( ( LifeSpan (( ( p +* ( while=0 (a,I) ) ) +* I ),( Initialize s )) ) + 3 );
thus thesis by SCMFSA_9:25;
end;
A20: (for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A19,A12);
per cases ;
suppose A21: m = ( 0 );

A22: ( DataPart S ) = ( DataPart s ) by MEMSTR_0:79
.= ( DataPart ( SW . m ) ) by A21,SCMFSA_9:def 4;
then ( S . a ) = ( ( SW . m ) . a ) by SCMFSA6A:7;
hence thesis by A9,A22,CKB21:1,A3;
end;
suppose A23: m <> ( 0 );

set sm = ( ( StepWhile=0 (a,I,p,s) ) . m );
set pm = ( p +* ( while=0 (a,I) ) );
set sm1 = ( Initialize sm );
set pm1 = ( pm +* ( while=0 (a,I) ) );
consider i being Nat such that A24: m = ( i + 1 ) by A23,NAT_1:6;
reconsider i as (Element of ( NAT )) by ORDINAL1:def 12;
set si = ( ( StepWhile=0 (a,I,p,s) ) . i );
set psi = ( p +* ( while=0 (a,I) ) );
A25: sm = ( Comput (( psi +* ( while=0 (a,I) ) ),( Initialize si ),( ( LifeSpan (( psi +* I ),( Initialize si )) ) + 3 )) ) by A24,A4,SCMFSA_9:def 4;
m = ( i + 1 ) by A24;
then consider n being (Element of ( NAT )) such that A26: sm = ( Comput (P,S,n) ) by A20;
i < m by A24,NAT_1:13;
then A27: ( si . a ) = ( 0 ) by A10;
then (I is_closed_on si,psi & I is_halting_on si,psi) by A11,CKB16:def 1;
then A28: ( IC sm ) = ( 0 ) by A25,A27,SCMFSA_9:22;
A29: ( IC sm1 ) = ( IC ( Start-At (( 0 ),( SCM+FSA )) ) ) by B18,FUNCT_4:13
.= ( IC sm ) by A28,FUNCOP_1:72;
( DataPart sm1 ) = ( DataPart sm ) by MEMSTR_0:79;
then A31: sm1 = sm by A29,MEMSTR_0:78;
A32: pm1 = pm by FUNCT_4:93;
( while=0 (a,I) ) is_halting_on sm,pm by A9,SCMFSA_9:18;
then pm1 halts_on sm1 by SCMFSA7B:def 7;
then consider j being (Element of ( NAT )) such that A33: ( CurInstr (pm,( Comput (pm,sm,j) )) ) = ( halt ( SCM+FSA ) ) by A31,A32,EXTPRO_1:29;
A34: ( Comput (P,S,( n + j )) ) = ( Comput (P,( Comput (P,S,n) ),j) ) by EXTPRO_1:4;
( CurInstr (P,( Comput (P,S,( n + j )) )) ) = ( halt ( SCM+FSA ) ) by A26,A33,A34;
then A35: ( Comput (P,S,( LifeSpan (P,S) )) ) = ( Comput (P,S,( n + j )) ) by EXTPRO_1:24
.= ( Comput (P,sm,j) ) by A26,EXTPRO_1:4
.= ( Comput (pm,sm,( LifeSpan (pm,sm) )) ) by A33,EXTPRO_1:24;
( Start-At (( 0 ),( SCM+FSA )) ) c= sm by A31,FUNCT_4:25;
then sm is ( 0 ) -started by MEMSTR_0:29;
hence thesis by A9,A35,CKB21:1,A3;
end;
end;
uniqueness
proof
let it1 being (Element of ( NAT ));
let it2 being (Element of ( NAT ));
given k1 being (Element of ( NAT )) such that
A36: it1 = k1
and
A37: (( ( ( StepWhile=0 (a,I,p,s) ) . k1 ) . a ) <> ( 0 ) & (for i being (Element of ( NAT )) holds (( ( ( StepWhile=0 (a,I,p,s) ) . i ) . a ) <> ( 0 ) implies k1 <= i)))
and
( DataPart ( Comput (( p +* ( while=0 (a,I) ) ),( Initialize s ),( LifeSpan (( p +* ( while=0 (a,I) ) ),( Initialize s )) )) ) ) = ( DataPart ( ( StepWhile=0 (a,I,p,s) ) . k1 ) );

given k2 being (Element of ( NAT )) such that
A38: it2 = k2
and
A39: (( ( ( StepWhile=0 (a,I,p,s) ) . k2 ) . a ) <> ( 0 ) & (for i being (Element of ( NAT )) holds (( ( ( StepWhile=0 (a,I,p,s) ) . i ) . a ) <> ( 0 ) implies k2 <= i)))
and
( DataPart ( Comput (( p +* ( while=0 (a,I) ) ),( Initialize s ),( LifeSpan (( p +* ( while=0 (a,I) ) ),( Initialize s )) )) ) ) = ( DataPart ( ( StepWhile=0 (a,I,p,s) ) . k2 ) );

(k1 <= k2 & k2 <= k1) by A37,A39;
hence thesis by A36,A38,XXREAL_0:1;
end;
end;
