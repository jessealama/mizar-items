environ
vocabularies NUMBERS,SUBSET_1,INT_1,AMI_1,SCMFSA_2,SF_MASTR,FUNCOP_1,FUNCT_1,FINSUB_1,CARD_3,RELAT_1,TARSKI,AMISTD_2,XBOOLE_0,CARD_1,SCMFSA8A,AMI_3,FSM_1,SCMFSA7B,SCMFSA8B,ARYTM_3,TURING_1,SCMFSA6A,ARYTM_1,VALUED_1,FUNCT_4,SCMFSA_9,UNIALG_2,SCMFSA6B,XXREAL_0,CIRCUIT2,GRAPHSP,NAT_1,SCMFSA6C,MSUALG_1,SFMASTR1,PRE_FF,COMPLEX1,ABIAN,SCMFSA9A,ORDINAL1,PARTFUN1,SCMNORM,RELOC,PBOOLE,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,FINSUB_1,FUNCOP_1,INT_1,ABIAN,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,PRE_FF,CARD_3,FUNCT_4,PBOOLE,VALUED_1,INT_2,XXREAL_0,NAT_1,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA_7,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,CKB16,CKB17,CKB27;
definitions FUNCOP_1,SCMFSA6A,AFINSQ_1,COMPOS_1,EXTPRO_1,AMISTD_2,MEMSTR_0,CKB16,CKB17,CKB27;
theorems TARSKI,ZFMISC_1,ABSVALUE,NAT_1,INT_1,NAT_2,FUNCT_1,FUNCT_2,GRFUNC_1,FUNCOP_1,FUNCT_4,PRE_FF,ABIAN,SCMFSA_2,MEMSTR_0,SCMFSA_4,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,SCMFSA_9,SFMASTR1,RELAT_1,XBOOLE_0,XBOOLE_1,CARD_3,XREAL_1,XXREAL_0,ORDINAL1,NAT_D,VALUED_1,PBOOLE,PARTFUN1,FINSEQ_4,COMPOS_1,EXTPRO_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31;
schemes FUNCT_2,NAT_1;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,FINSET_1,FINSUB_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,CARD_3,ABIAN,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,VALUED_1,FUNCT_2,RELAT_1,AFINSQ_1,FUNCT_4,FUNCOP_1,SCMFSA10,AMISTD_2,SCMFSA6A,COMPOS_1,EXTPRO_1,PBOOLE,STRUCT_0,MEMSTR_0;
constructors NAT_D,PRE_FF,ABIAN,SCMFSA_7,SCMFSA6A,SCMFSA6B,MEMSTR_0,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,AMISTD_2,RELSET_1,PRE_POLY,XXREAL_2,PBOOLE,SCMFSA7B,SCMFSA8C,FUNCT_4,AMISTD_1,CKB16,CKB17,CKB27;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve a for  read-write Int-Location;
reserve I for (Program of ( SCM+FSA ));
theorem
Lm6: (for a being Int-Location holds (for I being (Program of ( SCM+FSA )) holds ( UsedInt*Loc ( if>0 (a,( I ';' ( Goto ( 0 ) ) ),( Stop ( SCM+FSA ) )) ) ) = ( UsedInt*Loc ( ( if>0 (a,( I ';' ( Goto ( 0 ) ) ),( Stop ( SCM+FSA ) )) ) +* ( ( ( card I ) + 4 ) .--> ( goto ( 0 ) ) ) ) )))
proof
let a being Int-Location;
let I being (Program of ( SCM+FSA ));
set Lc4 = ( ( card I ) + 4 );
set if0 = ( if>0 (a,( I ';' ( Goto ( 0 ) ) ),( Stop ( SCM+FSA ) )) );
set ic4 = ( ( ( card I ) + 4 ) .--> ( goto ( 0 ) ) );
consider UIL1 being (Function of (the Instructions of ( SCM+FSA )),( Fin ( FinSeq-Locations ) )) such that A1: (for i being (Instruction of ( SCM+FSA )) holds ( UIL1 . i ) = ( UsedInt*Loc i )) and A2: ( UsedInt*Loc if0 ) = ( Union ( UIL1 * if0 ) ) by SF_MASTR:def 4;
A3: ( dom UIL1 ) = (the Instructions of ( SCM+FSA )) by FUNCT_2:def 1;
A4:now
thus ( dom ( UIL1 * if0 ) ) = ( dom ( UIL1 * if0 ) );
A5: ( rng ( if0 +* ic4 ) ) c= ( dom UIL1 ) by A3,RELAT_1:def 19;
A6: ( dom ic4 ) = { ( ( card I ) + 4 ) } by FUNCOP_1:13;
then A7: Lc4 in ( dom ic4 ) by TARSKI:def 1;
( ( card I ) + 4 ) in ( dom if0 ) by CKB30:1;
then (( dom ( if0 +* ic4 ) ) = ( ( dom if0 ) \/ ( dom ic4 ) ) & ( dom ic4 ) c= ( dom if0 )) by A6,FUNCT_4:def 1,ZFMISC_1:31;
then A8: ( dom if0 ) = ( dom ( if0 +* ic4 ) ) by XBOOLE_1:12;
( rng if0 ) c= ( dom UIL1 ) by A3,RELAT_1:def 19;
hence A9: ( dom ( UIL1 * if0 ) ) = ( dom if0 ) by RELAT_1:27
.= ( dom ( UIL1 * ( if0 +* ic4 ) ) ) by A5,A8,RELAT_1:27;
let x being set;
assume A10: x in ( dom ( UIL1 * if0 ) );
per cases ;
suppose x <> Lc4;

then A11: (not x in ( dom ic4 )) by A6,TARSKI:def 1;
thus ( ( UIL1 * if0 ) . x ) = ( UIL1 . ( if0 . x ) ) by A10,FUNCT_1:12
.= ( UIL1 . ( ( if0 +* ic4 ) . x ) ) by A11,FUNCT_4:11
.= ( ( UIL1 * ( if0 +* ic4 ) ) . x ) by A9,A10,FUNCT_1:12;
end;
suppose A12: x = Lc4;

thus ( ( UIL1 * if0 ) . x ) = ( UIL1 . ( if0 . x ) ) by A10,FUNCT_1:12
.= ( UIL1 . ( goto ( ( 0 ) + ( ( card I ) + 4 ) ) ) ) by A12,CKB30:1
.= ( UsedInt*Loc ( goto ( ( 0 ) + ( ( card I ) + 4 ) ) ) ) by A1
.= ( {} ) by SF_MASTR:32
.= ( UsedInt*Loc ( goto ( 0 ) ) ) by SF_MASTR:32
.= ( UIL1 . ( goto ( 0 ) ) ) by A1
.= ( UIL1 . ( ic4 . x ) ) by A12,FUNCOP_1:72
.= ( UIL1 . ( ( if0 +* ic4 ) . x ) ) by A7,A12,FUNCT_4:13
.= ( ( UIL1 * ( if0 +* ic4 ) ) . x ) by A9,A10,FUNCT_1:12;
end;
end;
consider UIL2 being (Function of (the Instructions of ( SCM+FSA )),( Fin ( FinSeq-Locations ) )) such that A13: (for i being (Instruction of ( SCM+FSA )) holds ( UIL2 . i ) = ( UsedInt*Loc i )) and A14: ( UsedInt*Loc ( if0 +* ic4 ) ) = ( Union ( UIL2 * ( if0 +* ic4 ) ) ) by SF_MASTR:def 4;
(for c being (Element of (the Instructions of ( SCM+FSA ))) holds ( UIL1 . c ) = ( UIL2 . c ))
proof
let c being (Element of (the Instructions of ( SCM+FSA )));
reconsider d = c as (Instruction of ( SCM+FSA ));
thus ( UIL1 . c ) = ( UsedInt*Loc d ) by A1
.= ( UIL2 . c ) by A13;
end;
then UIL1 = UIL2 by FUNCT_2:63;
hence thesis by A2,A14,A4,FUNCT_1:2;
end;
