environ
vocabularies NUMBERS,SUBSET_1,INT_1,AMI_1,SCMFSA_2,SF_MASTR,FUNCOP_1,FUNCT_1,FINSUB_1,CARD_3,RELAT_1,TARSKI,AMISTD_2,XBOOLE_0,CARD_1,SCMFSA8A,AMI_3,FSM_1,SCMFSA7B,SCMFSA8B,ARYTM_3,TURING_1,SCMFSA6A,ARYTM_1,VALUED_1,FUNCT_4,SCMFSA_9,UNIALG_2,SCMFSA6B,XXREAL_0,CIRCUIT2,GRAPHSP,NAT_1,SCMFSA6C,MSUALG_1,SFMASTR1,PRE_FF,COMPLEX1,ABIAN,SCMFSA9A,ORDINAL1,PARTFUN1,SCMNORM,RELOC,PBOOLE,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,FINSUB_1,FUNCOP_1,INT_1,ABIAN,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,PRE_FF,CARD_3,FUNCT_4,PBOOLE,VALUED_1,INT_2,XXREAL_0,NAT_1,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA_7,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,CKB16,CKB17,CKB27,CKB35,CKB36;
definitions FUNCOP_1,SCMFSA6A,AFINSQ_1,COMPOS_1,EXTPRO_1,AMISTD_2,MEMSTR_0,CKB16,CKB17,CKB27,CKB35,CKB36;
theorems TARSKI,ZFMISC_1,ABSVALUE,NAT_1,INT_1,NAT_2,FUNCT_1,FUNCT_2,GRFUNC_1,FUNCOP_1,FUNCT_4,PRE_FF,ABIAN,SCMFSA_2,MEMSTR_0,SCMFSA_4,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,SCMFSA_9,SFMASTR1,RELAT_1,XBOOLE_0,XBOOLE_1,CARD_3,XREAL_1,XXREAL_0,ORDINAL1,NAT_D,VALUED_1,PBOOLE,PARTFUN1,FINSEQ_4,COMPOS_1,EXTPRO_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39;
schemes FUNCT_2,NAT_1;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,FINSET_1,FINSUB_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,CARD_3,ABIAN,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,VALUED_1,FUNCT_2,RELAT_1,AFINSQ_1,FUNCT_4,FUNCOP_1,SCMFSA10,AMISTD_2,SCMFSA6A,COMPOS_1,EXTPRO_1,PBOOLE,STRUCT_0,MEMSTR_0;
constructors NAT_D,PRE_FF,ABIAN,SCMFSA_7,SCMFSA6A,SCMFSA6B,MEMSTR_0,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,AMISTD_2,RELSET_1,PRE_POLY,XXREAL_2,PBOOLE,SCMFSA7B,SCMFSA8C,FUNCT_4,AMISTD_1,CKB16,CKB17,CKB27,CKB35,CKB36;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve p for (Instruction-Sequence of ( SCM+FSA ));
reserve s for (State of ( SCM+FSA ));
reserve a for  read-write Int-Location;
reserve I for (Program of ( SCM+FSA ));
reserve k for (Element of ( NAT ));
theorem
Th35: (for s being ( 0 ) -started (State of ( SCM+FSA )) holds ((( while>0 (a,I) ) c= p & ( s . a ) <= ( 0 )) implies (( LifeSpan (p,s) ) = 4 & (for k being (Element of ( NAT )) holds ( DataPart ( Comput (p,s,k) ) ) = ( DataPart s )))))
proof
let s being ( 0 ) -started (State of ( SCM+FSA ));
assume that
A2: ( while>0 (a,I) ) c= p
and
A3: ( s . a ) <= ( 0 );
A4: ( p +* ( while>0 (a,I) ) ) = p by A2,FUNCT_4:98;
set i = ( a >0_goto 4 );
set p1 = ( p +* ( while>0 (a,I) ) );
A5: ( while>0 (a,I) ) c= p1 by FUNCT_4:25;
B6: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) by MEMSTR_0:15;
A8: 1 in ( dom ( while>0 (a,I) ) ) by SCMFSA_9:10;
A9: ( p1 . 1 ) = ( ( while>0 (a,I) ) . 1 ) by A8,FUNCT_4:13
.= ( goto 2 ) by SCMFSA_9:11;
s = ( Initialize s ) by MEMSTR_0:44;
then A10: ( IC s ) = ( IC ( Start-At (( 0 ),( SCM+FSA )) ) ) by B6,FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
A11: ( p1 /. ( IC s ) ) = ( p1 . ( IC s ) ) by PBOOLE:143;
( 0 ) in ( dom ( while>0 (a,I) ) ) by SCMFSA_9:10;
then ( p1 . ( 0 ) ) = ( ( while>0 (a,I) ) . ( 0 ) ) by FUNCT_4:13
.= i by SCMFSA_9:11;
then A12: ( CurInstr (p1,s) ) = i by A10,A11;
A13: ( Comput (p1,s,( ( 0 ) + 1 )) ) = ( Following (p1,( Comput (p1,s,( 0 )) )) ) by EXTPRO_1:3
.= ( Following (p1,s) ) by EXTPRO_1:2
.= ( Exec (i,s) ) by A12;
set loc5 = ( ( card I ) + 5 );
set s5 = ( Comput (p1,s,4) );
set s4 = ( Comput (p1,s,3) );
set s3 = ( Comput (p1,s,2) );
set s2 = ( Comput (p1,s,1) );
A14: 2 in ( dom ( while>0 (a,I) ) ) by SCMFSA_9:32;
A15: ( p1 . 2 ) = ( ( while>0 (a,I) ) . 2 ) by A14,FUNCT_4:13
.= ( goto 3 ) by SCMFSA_9:36;
A16: 3 in ( dom ( while>0 (a,I) ) ) by SCMFSA_9:32;
A17: ( p1 . 3 ) = ( ( while>0 (a,I) ) . 3 ) by A16,FUNCT_4:13
.= ( goto loc5 ) by SCMFSA_9:35;
A18: loc5 in ( dom ( while>0 (a,I) ) ) by SCMFSA_9:33;
A19: ( p1 . loc5 ) = ( ( while>0 (a,I) ) . loc5 ) by A18,A5,GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by SCMFSA_9:34;
A20: ((for c being Int-Location holds ( ( Exec (( goto loc5 ),s4) ) . c ) = ( s4 . c )) & (for f being FinSeq-Location holds ( ( Exec (( goto loc5 ),s4) ) . f ) = ( s4 . f ))) by SCMFSA_2:69;
A21: ((for c being Int-Location holds ( ( Exec (( goto 2 ),s2) ) . c ) = ( s2 . c )) & (for f being FinSeq-Location holds ( ( Exec (( goto 2 ),s2) ) . f ) = ( s2 . f ))) by SCMFSA_2:69;
A22: ( p1 /. ( IC ( Comput (p1,s,1) ) ) ) = ( p1 . ( IC ( Comput (p1,s,1) ) ) ) by PBOOLE:143;
( IC ( Comput (p1,s,1) ) ) = ( succ ( 0 ) ) by A3,A10,A13,SCMFSA_2:71
.= ( ( 0 ) + 1 );
then A23: ( CurInstr (p1,( Comput (p1,s,1) )) ) = ( goto 2 ) by A9,A22;
A24: ( Comput (p1,s,( 1 + 1 )) ) = ( Following (p1,s2) ) by EXTPRO_1:3
.= ( Exec (( goto 2 ),s2) ) by A23;
A25: ( p1 /. ( IC s3 ) ) = ( p1 . ( IC s3 ) ) by PBOOLE:143;
( IC s3 ) = 2 by A24,SCMFSA_2:69;
then A26: ( CurInstr (p1,s3) ) = ( goto 3 ) by A15,A25;
A27: ( Comput (p1,s,( 2 + 1 )) ) = ( Following (p1,s3) ) by EXTPRO_1:3
.= ( Exec (( goto 3 ),s3) ) by A26;
A28: ( p1 /. ( IC s4 ) ) = ( p1 . ( IC s4 ) ) by PBOOLE:143;
( IC s4 ) = 3 by A27,SCMFSA_2:69;
then A29: ( CurInstr (p1,s4) ) = ( goto loc5 ) by A17,A28;
A30: ( Comput (p1,s,( 3 + 1 )) ) = ( Following (p1,s4) ) by EXTPRO_1:3
.= ( Exec (( goto loc5 ),s4) ) by A29;
A31: ( p1 /. ( IC s5 ) ) = ( p1 . ( IC s5 ) ) by PBOOLE:143;
( IC s5 ) = loc5 by A30,SCMFSA_2:69;
then A32: ( CurInstr (p1,s5) ) = ( halt ( SCM+FSA ) ) by A19,A31;
then A33: p1 halts_on s by EXTPRO_1:29;
now
let k;
assume A35: ( CurInstr (p,( Comput (p,s,k) )) ) = ( halt ( SCM+FSA ) );
assume 4 > k;
then ( 3 + 1 ) > k;
then A36: k <= 3 by NAT_1:13;
per cases  by A36,NAT_1:27;
suppose k = ( 0 );

then ( Comput (p,s,k) ) = s by EXTPRO_1:2;
hence contradiction by A12,A35,A4;
end;
suppose k = 1;

hence contradiction by A23,A35,A4;
end;
suppose k = 2;

hence contradiction by A26,A35,A4;
end;
suppose k = 3;

hence contradiction by A29,A35,A4;
end;
end;
hence A37: ( LifeSpan (p,s) ) = 4 by A32,A33,A4,EXTPRO_1:def 15;
A38: ((for c being Int-Location holds ( ( Exec (i,s) ) . c ) = ( s . c )) & (for f being FinSeq-Location holds ( ( Exec (i,s) ) . f ) = ( s . f ))) by SCMFSA_2:71;
then A39: ( DataPart ( Comput (p,s,1) ) ) = ( DataPart s ) by A13,A4,SCMFSA6A:7;
then A40: ( DataPart ( Comput (p,s,2) ) ) = ( DataPart s ) by A24,A21,A4,SCMFSA6A:7;
A41: ((for c being Int-Location holds ( ( Exec (( goto 3 ),s3) ) . c ) = ( s3 . c )) & (for f being FinSeq-Location holds ( ( Exec (( goto 3 ),s3) ) . f ) = ( s3 . f ))) by SCMFSA_2:69;
then ( DataPart ( Comput (p,s,3) ) ) = ( DataPart s ) by A27,A40,A4,SCMFSA6A:7;
then A42: ( DataPart ( Comput (p,s,4) ) ) = ( DataPart s ) by A30,A20,A4,SCMFSA6A:7;
let k being (Element of ( NAT ));
(k <= 3 or 3 < k);
then A43: ((((k = ( 0 ) or k = 1) or k = 2) or k = 3) or ( 3 + 1 ) <= k) by NAT_1:13,NAT_1:27;
per cases  by A43;
suppose k = ( 0 );

hence thesis by EXTPRO_1:2;
end;
suppose k = 1;

hence thesis by A13,A38,A4,SCMFSA6A:7;
end;
suppose k = 2;

hence thesis by A24,A21,A39,A4,SCMFSA6A:7;
end;
suppose k = 3;

hence thesis by A27,A41,A40,A4,SCMFSA6A:7;
end;
suppose 4 <= k;

then ( CurInstr (p,( Comput (p,s,k) )) ) = ( halt ( SCM+FSA ) ) by A33,A37,A4,EXTPRO_1:36;
hence thesis by A37,A42,EXTPRO_1:24;
end;
end;
