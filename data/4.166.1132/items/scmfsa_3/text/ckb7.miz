environ
vocabularies NUMBERS,SUBSET_1,SCMFSA_2,AMI_1,RELAT_1,AMI_3,FSM_1,STRUCT_0,FUNCT_4,FUNCOP_1,XBOOLE_0,TARSKI,FUNCT_1,XXREAL_0,ARYTM_3,GRAPHSP,SCMNORM,COMPLEX1,PARTFUN1,FINSEQ_1,FINSEQ_2,CARD_1,INT_1,CIRCUIT2,ARYTM_1,ORDINAL1,AMISTD_5,PBOOLE,FINSET_1,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,FINSET_1,NUMBERS,XCMPLX_0,INT_2,RELAT_1,PBOOLE,FUNCT_1,PARTFUN1,FUNCT_4,INT_1,NAT_1,DOMAIN_1,STRUCT_0,FUNCOP_1,FINSEQ_1,FINSEQ_2,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_3,FUNCT_7,SCMFSA_2,XXREAL_0,AMISTD_5,CKB5;
definitions COMPOS_1,EXTPRO_1,AMI_3,FUNCOP_1,SCMFSA_2,AMISTD_5,AMI_2,MEMSTR_0;
theorems GRFUNC_1,FUNCOP_1,TARSKI,FUNCT_4,FUNCT_1,ZFMISC_1,INT_1,RELAT_1,SCMFSA_2,SCMFSA_1,ABSVALUE,FINSEQ_2,XBOOLE_0,XBOOLE_1,NUMBERS,PBOOLE,PARTFUN1,COMPOS_1,EXTPRO_1,AMISTD_5,NAT_1,MEMSTR_0,CKB1,CKB2,CKB3,CKB4;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,NUMBERS,XREAL_0,INT_1,FINSEQ_1,CARD_3,STRUCT_0,AMI_3,SCMFSA_2,FINSET_1,ZFMISC_1,ORDINAL1,RELSET_1,FUNCT_2,COMPOS_1,EXTPRO_1,AMISTD_5,CARD_1,PBOOLE,FUNCT_7,PRE_POLY,MEMSTR_0,AMI_2,FUNCT_4,FUNCOP_1,CKB6;
constructors DOMAIN_1,XXREAL_0,INT_2,AMI_3,SCMFSA_2,RELSET_1,PRE_POLY,SCMFSA_1,AMISTD_5,AMISTD_2,PBOOLE,FUNCT_7,AMISTD_1,MEMSTR_0,CKB5;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
registration
cluster ( SCM+FSA ) ->  CurIns-recognized;
coherence
proof
let q being non halt-free  finite (the Instructions of ( SCM+FSA )) -valued ( NAT ) -defined Function;
let p being q -autonomic non empty (FinPartState of ( SCM+FSA ));
let s being (State of ( SCM+FSA ));
assume that
A1: p c= s;
let P being (Instruction-Sequence of ( SCM+FSA ));
assume that
A2: q c= P;
let i being (Element of ( NAT ));
set Csi = ( Comput (P,s,i) );
set loc = ( IC Csi );
set loc1 = ( loc + 1 );
assume Z: (not ( IC ( Comput (P,s,i) ) ) in ( dom q ));
set I = ( ( intloc ( 0 ) ) := ( intloc ( 0 ) ) );
set q1 = ( q +* ( loc .--> I ) );
set q2 = ( q +* ( loc .--> ( halt ( SCM+FSA ) ) ) );
reconsider P1 = ( P +* ( loc .--> I ) ) as (Instruction-Sequence of ( SCM+FSA ));
reconsider P2 = ( P +* ( loc .--> ( halt ( SCM+FSA ) ) ) ) as (Instruction-Sequence of ( SCM+FSA ));
A6: ( dom ( loc .--> ( halt ( SCM+FSA ) ) ) ) = { loc } by FUNCOP_1:13;
then A7: loc in ( dom ( loc .--> ( halt ( SCM+FSA ) ) ) ) by TARSKI:def 1;
A12: ( dom ( loc .--> I ) ) = { loc } by FUNCOP_1:13;
then A13: loc in ( dom ( loc .--> I ) ) by TARSKI:def 1;
Y6: ( dom q ) misses ( dom ( loc .--> ( halt ( SCM+FSA ) ) ) ) by Z,A6,ZFMISC_1:50;
Y5: ( dom q ) misses ( dom ( loc .--> I ) ) by Z,A12,ZFMISC_1:50;
P3: q1 c= P1 by A2,FUNCT_4:123;
P4: q2 c= P2 by A2,FUNCT_4:123;
set Cs2i = ( Comput (P2,s,i) );
set Cs1i = ( Comput (P1,s,i) );
(not p is q -autonomic)
proof
( ( loc .--> ( halt ( SCM+FSA ) ) ) . loc ) = ( halt ( SCM+FSA ) ) by FUNCOP_1:72;
then A18: ( P2 . loc ) = ( halt ( SCM+FSA ) ) by A7,FUNCT_4:13;
B19: ( ( loc .--> I ) . loc ) = I by FUNCOP_1:72;
take P1;
take P2;
q c= q1 by Y5,FUNCT_4:32;
hence A25: q c= P1 by P3,XBOOLE_1:1;
q c= q2 by Y6,FUNCT_4:32;
hence A27: q c= P2 by P4,XBOOLE_1:1;
take s;
take s;
thus p c= s by A1;
A28: ( Cs1i | ( dom p ) ) = ( Csi | ( dom p ) ) by A25,A2,A1,EXTPRO_1:def 10;
thus p c= s by A1;
A29: ( Cs1i | ( dom p ) ) = ( Cs2i | ( dom p ) ) by A25,A27,A1,EXTPRO_1:def 10;
take k = ( i + 1 );
set Cs1k = ( Comput (P1,s,k) );
A33: ( IC ( SCM+FSA ) ) in ( dom p ) by AMISTD_5:6;
( IC Csi ) = ( IC ( Csi | ( dom p ) ) ) by A33,FUNCT_1:49;
then ( IC Cs1i ) = loc by A28,A33,FUNCT_1:49;
then XX: ( CurInstr (P1,Cs1i) ) = ( P1 . loc ) by PBOOLE:143
.= I by B19,A13,FUNCT_4:13;
A31: Cs1k = ( Following (P1,Cs1i) ) by EXTPRO_1:3
.= ( Exec (I,Cs1i) ) by XX;
A32: ( IC ( Exec (I,Cs1i) ) ) = ( succ ( IC Cs1i ) ) by SCMFSA_2:63;
A33: ( IC ( SCM+FSA ) ) in ( dom p ) by AMISTD_5:6;
A34: ( IC Csi ) = ( IC ( Csi | ( dom p ) ) ) by A33,FUNCT_1:49;
then A35: ( IC Cs1k ) = ( succ loc ) by A31,A32,A28,A33,FUNCT_1:49
.= loc1 by NAT_1:38;
set Cs2k = ( Comput (P2,s,k) );
A36: Cs2k = ( Following (P2,Cs2i) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (P2,Cs2i) ),Cs2i) );
A37: ( P2 /. ( IC Cs2i ) ) = ( P2 . ( IC Cs2i ) ) by PBOOLE:143;
( IC Cs2i ) = loc by A28,A34,A29,A33,FUNCT_1:49;
then A38: ( IC Cs2k ) = loc by A36,A18,A37,EXTPRO_1:def 3;
(( IC ( Cs1k | ( dom p ) ) ) = ( IC Cs1k ) & ( IC ( Cs2k | ( dom p ) ) ) = ( IC Cs2k )) by A33,FUNCT_1:49;
hence thesis by A35,A38;
end;
hence contradiction;
end;
end;
