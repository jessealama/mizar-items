environ
vocabularies NUMBERS,PRE_TOPC,EUCLID,FINSEQ_1,REAL_1,SUBSET_1,COMPLEX1,ARYTM_1,XXREAL_0,ARYTM_3,CARD_1,NAT_1,RELAT_1,FINSEQ_3,FUNCT_1,XBOOLE_0,TARSKI,ORDINAL2,PARTFUN1,MCART_1,TOPREAL1,RLTOPSP1,MATRIX_1,TREES_1,INCSP_1,ZFMISC_1,MATRIX_2,STRUCT_0,ORDINAL4,GOBOARD1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,PARTFUN1,REAL_1,NUMBERS,XCMPLX_0,XXREAL_0,COMPLEX1,NAT_1,VALUED_0,FINSEQ_1,FINSEQ_3,SEQ_1,STRUCT_0,PRE_TOPC,EUCLID,TOPREAL1,MATRIX_1,MATRIX_2,CKB1,CKB2,CKB5,CKB6,CKB7,CKB8,CKB9;
definitions TARSKI,XBOOLE_0,FUNCT_1,SEQM_3,CKB1,CKB2,CKB5,CKB6,CKB7,CKB8,CKB9;
theorems TARSKI,NAT_1,ZFMISC_1,FUNCT_1,FINSEQ_1,ABSVALUE,FINSEQ_2,FINSEQ_3,MATRIX_1,TOPREAL1,MATRIX_2,TOPREAL3,FINSEQ_4,RELAT_1,INT_1,CARD_1,PARTFUN2,XBOOLE_0,XREAL_1,COMPLEX1,XXREAL_0,ORDINAL1,PARTFUN1,SEQM_3,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10;
schemes NAT_1,MATRIX_1,FINSEQ_1,FINSEQ_4;
registrations RELAT_1,ORDINAL1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,FINSEQ_1,STRUCT_0,EUCLID,MEMBERED,VALUED_0,CARD_1;
constructors PARTFUN1,XXREAL_0,NAT_1,COMPLEX1,MATRIX_2,SEQ_1,TOPREAL1,SEQM_3,RELSET_1,REAL_1,CKB1,CKB2,CKB5,CKB6,CKB7,CKB8,CKB9;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve n for (Element of ( NAT ));
reserve m for (Element of ( NAT ));
reserve k for (Element of ( NAT ));
registration
cluster non empty-yielding  X_equal-in-line  Y_equal-in-column  Y_increasing-in-line  X_increasing-in-column for (Matrix of ( TOP-REAL 2 ));
existence
proof
set p = the (Point of ( TOP-REAL 2 ));
take M = <* <* p *> *>;
A1: ( len M ) = 1 by MATRIX_1:24;
A2: ( width M ) = 1 by MATRIX_1:24;
hence M is non empty-yielding by A1,CKB5:def 1;
thus M is  X_equal-in-line
proof
let n;
assume that
n in ( dom M );
set L = ( X_axis ( Line (M,n) ) );
let k;
let m;
assume that
A3: k in ( dom L )
and
A4: m in ( dom L );
A5: ( len L ) = ( len ( Line (M,n) ) ) by CKB1:def 1;
k in ( Seg ( len L ) ) by A3,FINSEQ_1:def 3;
then k in { 1 } by A2,A5,FINSEQ_1:2,MATRIX_1:def 7;
then A6: k = 1 by TARSKI:def 1;
m in ( Seg ( len L ) ) by A4,FINSEQ_1:def 3;
then m in { 1 } by A2,A5,FINSEQ_1:2,MATRIX_1:def 7;
hence ( L . k ) = ( L . m ) by A6,TARSKI:def 1;
end;

thus M is  Y_equal-in-column
proof
let n;
assume that
n in ( Seg ( width M ) );
set L = ( Y_axis ( Col (M,n) ) );
let k;
let m;
assume that
A7: k in ( dom L )
and
A8: m in ( dom L );
A9: ( len L ) = ( len ( Col (M,n) ) ) by CKB2:def 1;
k in ( Seg ( len L ) ) by A7,FINSEQ_1:def 3;
then k in { 1 } by A1,A9,FINSEQ_1:2,MATRIX_1:def 8;
then A10: k = 1 by TARSKI:def 1;
m in ( Seg ( len L ) ) by A8,FINSEQ_1:def 3;
then m in { 1 } by A1,A9,FINSEQ_1:2,MATRIX_1:def 8;
hence ( L . k ) = ( L . m ) by A10,TARSKI:def 1;
end;

thus M is  Y_increasing-in-line
proof
let n;
assume that
n in ( dom M );
set L = ( Y_axis ( Line (M,n) ) );
let k;
let m;
assume that
A11: k in ( dom L )
and
A12: m in ( dom L )
and
A13: k < m;
A14: ( len L ) = ( len ( Line (M,n) ) ) by CKB2:def 1;
k in ( Seg ( len L ) ) by A11,FINSEQ_1:def 3;
then k in { 1 } by A2,A14,FINSEQ_1:2,MATRIX_1:def 7;
then A15: k = 1 by TARSKI:def 1;
m in ( Seg ( len L ) ) by A12,FINSEQ_1:def 3;
then m in { 1 } by A2,A14,FINSEQ_1:2,MATRIX_1:def 7;
hence thesis by A13,A15,TARSKI:def 1;
end;

let n;
assume that
n in ( Seg ( width M ) );
set L = ( X_axis ( Col (M,n) ) );
let k;
let m;
assume that
A16: k in ( dom L )
and
A17: m in ( dom L )
and
A18: k < m;
A19: ( len L ) = ( len ( Col (M,n) ) ) by CKB1:def 1;
k in ( Seg ( len L ) ) by A16,FINSEQ_1:def 3;
then k in { 1 } by A1,A19,FINSEQ_1:2,MATRIX_1:def 8;
then A20: k = 1 by TARSKI:def 1;
m in ( Seg ( len L ) ) by A17,FINSEQ_1:def 3;
then m in { 1 } by A1,A19,FINSEQ_1:2,MATRIX_1:def 8;
hence thesis by A18,A20,TARSKI:def 1;
end;
end;
