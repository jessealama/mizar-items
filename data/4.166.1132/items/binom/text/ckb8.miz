environ
vocabularies NUMBERS,RLVECT_1,ALGSTR_0,XBOOLE_0,SUBSET_1,ARYTM_3,ALGSTR_1,BINOP_1,LATTICES,GROUP_1,VECTSP_2,VECTSP_1,SUPINF_2,RELAT_1,FUNCT_1,ZFMISC_1,CARD_1,FUNCT_2,MCART_1,CARD_3,FINSEQ_1,STRUCT_0,XXREAL_0,PARTFUN1,NAT_1,NEWTON,ARYTM_1,ORDINAL4,FINSEQ_2,BINOM;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,XCMPLX_0,STRUCT_0,ALGSTR_0,PARTFUN1,FUNCT_1,FUNCT_2,NAT_1,FINSEQ_1,RELSET_1,BINOP_1,ALGSTR_1,FINSEQ_2,VECTSP_1,VECTSP_2,GROUP_1,NEWTON,RLVECT_1,MCART_1,POLYNOM1,XXREAL_0;
definitions BINOP_1,ALGSTR_0;
theorems TARSKI,FUNCT_2,VECTSP_1,RLVECT_1,ALGSTR_1,NAT_1,MCART_1,FINSEQ_1,GROUP_1,NEWTON,FINSEQ_2,FUNCT_1,ZFMISC_1,INT_1,RELAT_1,POLYNOM1,XBOOLE_0,XREAL_1,PARTFUN1,ORDINAL1,ALGSTR_0,CARD_1,FINSEQ_5,CKB5,CKB6,CKB7;
schemes NAT_1,RECDEF_1,INT_1;
registrations XBOOLE_0,ORDINAL1,RELSET_1,XXREAL_0,XREAL_0,NAT_1,FINSEQ_2,STRUCT_0,VECTSP_1,ALGSTR_1,MONOID_0,INT_1,ALGSTR_0,CARD_1,FINSEQ_1,CKB1,CKB2,CKB3,CKB4;
constructors BINOP_1,XXREAL_0,REAL_1,NEWTON,ALGSTR_1,MONOID_0,POLYNOM1,RELSET_1,FVSUM_1;
requirements NUMERALS,SUBSET,REAL,BOOLE,ARITHM;
begin
theorem
(for R being  left_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr holds (for a being (Element of R) holds (for p being (FinSequence of (the carrier of R)) holds ( Sum ( a * p ) ) = ( a * ( Sum p ) ))))
proof
let R being  left_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr;
let a being (Element of R);
let p being (FinSequence of (the carrier of R));
consider f being (Function of ( NAT ),(the carrier of R)) such that A1: ( Sum p ) = ( f . ( len p ) ) and A2: ( f . ( 0 ) ) = ( 0. R ) and A3: (for j being (Element of ( NAT )) holds (for v being (Element of R) holds ((j < ( len p ) & v = ( p . ( j + 1 ) )) implies ( f . ( j + 1 ) ) = ( ( f . j ) + v )))) by RLVECT_1:def 12;
consider fa being (Function of ( NAT ),(the carrier of R)) such that A4: ( Sum ( a * p ) ) = ( fa . ( len ( a * p ) ) ) and A5: ( fa . ( 0 ) ) = ( 0. R ) and A6: (for j being (Element of ( NAT )) holds (for v being (Element of R) holds ((j < ( len ( a * p ) ) & v = ( ( a * p ) . ( j + 1 ) )) implies ( fa . ( j + 1 ) ) = ( ( fa . j ) + v )))) by RLVECT_1:def 12;
defpred P[ (Element of ( NAT )) ]
 means
( a * ( f . $1 ) ) = ( fa . $1 );
A7: ( Seg ( len ( a * p ) ) ) = ( dom ( a * p ) ) by FINSEQ_1:def 3
.= ( dom p ) by POLYNOM1:def 1
.= ( Seg ( len p ) ) by FINSEQ_1:def 3;
A8:now
let j being (Element of ( NAT ));
assume that
( 0 ) <= j
and
A9: j < ( len p );
thus (P[ j ] implies P[ ( j + 1 ) ])
proof
A10: ( ( 0 ) + 1 ) <= ( j + 1 ) by XREAL_1:6;
A11: j < ( len ( a * p ) ) by A7,A9,FINSEQ_1:6;
then ( j + 1 ) <= ( len ( a * p ) ) by NAT_1:13;
then ( j + 1 ) in ( Seg ( len ( a * p ) ) ) by A10,FINSEQ_1:1;
then ( j + 1 ) in ( dom ( a * p ) ) by FINSEQ_1:def 3;
then A12: ( ( a * p ) /. ( j + 1 ) ) = ( ( a * p ) . ( j + 1 ) ) by PARTFUN1:def 6;
( j + 1 ) <= ( len p ) by A9,NAT_1:13;
then ( j + 1 ) in ( Seg ( len p ) ) by A10,FINSEQ_1:1;
then A13: ( j + 1 ) in ( dom p ) by FINSEQ_1:def 3;
then A14: ( p /. ( j + 1 ) ) = ( p . ( j + 1 ) ) by PARTFUN1:def 6;
assume P[ j ];
hence ( fa . ( j + 1 ) ) = ( ( a * ( f . j ) ) + ( ( a * p ) /. ( j + 1 ) ) ) by A6,A11,A12
.= ( ( a * ( f . j ) ) + ( a * ( p /. ( j + 1 ) ) ) ) by A13,POLYNOM1:def 1
.= ( a * ( ( f . j ) + ( p /. ( j + 1 ) ) ) ) by VECTSP_1:def 2
.= ( a * ( f . ( j + 1 ) ) ) by A3,A9,A14;
end;

end;
A15: P[ ( 0 ) ] by A2,A5,CKB6:1;
A16: (for i being (Element of ( NAT )) holds ((( 0 ) <= i & i <= ( len p )) implies P[ i ])) from INT_1:sch 7(A15,A8);
thus ( Sum ( a * p ) ) = ( fa . ( len p ) ) by A4,A7,FINSEQ_1:6
.= ( a * ( Sum p ) ) by A1,A16;
end;
