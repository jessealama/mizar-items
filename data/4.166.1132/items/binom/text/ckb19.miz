environ
vocabularies NUMBERS,RLVECT_1,ALGSTR_0,XBOOLE_0,SUBSET_1,ARYTM_3,ALGSTR_1,BINOP_1,LATTICES,GROUP_1,VECTSP_2,VECTSP_1,SUPINF_2,RELAT_1,FUNCT_1,ZFMISC_1,CARD_1,FUNCT_2,MCART_1,CARD_3,FINSEQ_1,STRUCT_0,XXREAL_0,PARTFUN1,NAT_1,NEWTON,ARYTM_1,ORDINAL4,FINSEQ_2,BINOM;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,XCMPLX_0,STRUCT_0,ALGSTR_0,PARTFUN1,FUNCT_1,FUNCT_2,NAT_1,FINSEQ_1,RELSET_1,BINOP_1,ALGSTR_1,FINSEQ_2,VECTSP_1,VECTSP_2,GROUP_1,NEWTON,RLVECT_1,MCART_1,POLYNOM1,XXREAL_0,CKB11,CKB13,CKB18;
definitions BINOP_1,ALGSTR_0,CKB11,CKB13,CKB18;
theorems TARSKI,FUNCT_2,VECTSP_1,RLVECT_1,ALGSTR_1,NAT_1,MCART_1,FINSEQ_1,GROUP_1,NEWTON,FINSEQ_2,FUNCT_1,ZFMISC_1,INT_1,RELAT_1,POLYNOM1,XBOOLE_0,XREAL_1,PARTFUN1,ORDINAL1,ALGSTR_0,CARD_1,FINSEQ_5,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18;
schemes NAT_1,RECDEF_1,INT_1;
registrations XBOOLE_0,ORDINAL1,RELSET_1,XXREAL_0,XREAL_0,NAT_1,FINSEQ_2,STRUCT_0,VECTSP_1,ALGSTR_1,MONOID_0,INT_1,ALGSTR_0,CARD_1,FINSEQ_1,CKB1,CKB2,CKB3,CKB4;
constructors BINOP_1,XXREAL_0,REAL_1,NEWTON,ALGSTR_1,MONOID_0,POLYNOM1,RELSET_1,FVSUM_1,CKB11,CKB13,CKB18;
requirements NUMERALS,SUBSET,REAL,BOOLE,ARITHM;
begin
Lm2:now
let C being non  empty set;
let D being non  empty set;
let b being (Element of D);
let F being (Function of [: D,C :],D);
thus (ex g being (Function of [: C,( NAT ) :],D) st (for a being (Element of C) holds (( g . (a,( 0 )) ) = b & (for n being (Element of ( NAT )) holds ( g . (a,( n + 1 )) ) = ( F . (( g . (a,n) ),a) )))))
proof
A1: (for a being (Element of C) holds (ex f being (Function of ( NAT ),D) st (( f . ( 0 ) ) = b & (for n being (Element of ( NAT )) holds ( f . ( n + 1 ) ) = ( F . (( f . n ),a) )))))
proof
let a being (Element of C);
defpred P[ (Element of ( NAT )),(Element of D),(Element of D) ]
 means
$3 = ( F . ($2,a) );
A2: (for n being (Element of ( NAT )) holds (for x being (Element of D) holds (ex y being (Element of D) st P[ n,x,y ])));
(ex f being (Function of ( NAT ),D) st (( f . ( 0 ) ) = b & (for n being (Element of ( NAT )) holds P[ n,( f . n ),( f . ( n + 1 ) ) ]))) from RECDEF_1:sch 2(A2);
hence thesis;
end;
(ex g being (Function of C,( Funcs (( NAT ),D) )) st (for a being (Element of C) holds (ex f being (Function of ( NAT ),D) st ((( g . a ) = f & ( f . ( 0 ) ) = b) & (for n being (Element of ( NAT )) holds ( f . ( n + 1 ) ) = ( F . (( f . n ),a) ))))))
proof
set h = { [ a,l ] where a is (Element of C),l is (Element of ( Funcs (( NAT ),D) )): (ex f being (Function of ( NAT ),D) st ((f = l & ( f . ( 0 ) ) = b) & (for n being (Element of ( NAT )) holds ( f . ( n + 1 ) ) = ( F . (( f . n ),a) )))) };
A3:now
let x being set;
let y1 being set;
let y2 being set;
assume that
A4: [ x,y1 ] in h
and
A5: [ x,y2 ] in h;
consider a1 being (Element of C),l1 being (Element of ( Funcs (( NAT ),D) )) such that A6: [ x,y1 ] = [ a1,l1 ] and A7: (ex f being (Function of ( NAT ),D) st ((f = l1 & ( f . ( 0 ) ) = b) & (for n being (Element of ( NAT )) holds ( f . ( n + 1 ) ) = ( F . (( f . n ),a1) )))) by A4;
consider a2 being (Element of C),l2 being (Element of ( Funcs (( NAT ),D) )) such that A8: [ x,y2 ] = [ a2,l2 ] and A9: (ex f being (Function of ( NAT ),D) st ((f = l2 & ( f . ( 0 ) ) = b) & (for n being (Element of ( NAT )) holds ( f . ( n + 1 ) ) = ( F . (( f . n ),a2) )))) by A5;
consider f1 being (Function of ( NAT ),D) such that A10: f1 = l1 and A11: ( f1 . ( 0 ) ) = b and A12: (for n being (Element of ( NAT )) holds ( f1 . ( n + 1 ) ) = ( F . (( f1 . n ),a1) )) by A7;
consider f2 being (Function of ( NAT ),D) such that A13: f2 = l2 and A14: ( f2 . ( 0 ) ) = b and A15: (for n being (Element of ( NAT )) holds ( f2 . ( n + 1 ) ) = ( F . (( f2 . n ),a2) )) by A9;
A16: a1 = ( [ x,y1 ] `1 ) by A6,MCART_1:def 1
.= x by MCART_1:def 1
.= ( [ a2,l2 ] `1 ) by A8,MCART_1:def 1
.= a2 by MCART_1:def 1;
A17:now
defpred P[ (Element of ( NAT )) ]
 means
( f1 . $1 ) = ( f2 . $1 );
let x being set;
assume x in ( NAT );
then reconsider x9 = x as (Element of ( NAT ));
A18:now
let n being (Element of ( NAT ));
assume A19: P[ n ];
( f1 . ( n + 1 ) ) = ( F . (( f1 . n ),a2) ) by A12,A16
.= ( f2 . ( n + 1 ) ) by A15,A19;
hence P[ ( n + 1 ) ];
end;
A20: P[ ( 0 ) ] by A11,A14;
(for n being (Element of ( NAT )) holds P[ n ]) from NAT_1:sch 1(A20,A18);
hence ( f1 . x ) = ( f2 . x9 )
.= ( f2 . x );
end;
A21: (( NAT ) = ( dom f1 ) & ( NAT ) = ( dom f2 )) by FUNCT_2:def 1;
thus y1 = ( [ a1,l1 ] `2 ) by A6,MCART_1:def 2
.= l1 by MCART_1:def 2
.= l2 by A10,A13,A21,A17,FUNCT_1:2
.= ( [ x,y2 ] `2 ) by A8,MCART_1:def 2
.= y2 by MCART_1:def 2;
end;
now
let x being set;
assume x in h;
then (ex a being (Element of C) st (ex l being (Element of ( Funcs (( NAT ),D) )) st (x = [ a,l ] & (ex f being (Function of ( NAT ),D) st ((f = l & ( f . ( 0 ) ) = b) & (for n being (Element of ( NAT )) holds ( f . ( n + 1 ) ) = ( F . (( f . n ),a) )))))));
hence x in [: C,( Funcs (( NAT ),D) ) :] by ZFMISC_1:def 2;
end;
then reconsider h as (Relation of C,( Funcs (( NAT ),D) )) by TARSKI:def 3;
A22: (for x being set holds (x in C implies x in ( dom h )))
proof
let x being set;
assume A23: x in C;
then consider f being (Function of ( NAT ),D) such that A24: (( f . ( 0 ) ) = b & (for n being (Element of ( NAT )) holds ( f . ( n + 1 ) ) = ( F . (( f . n ),x) ))) by A1;
reconsider f9 = f as (Element of ( Funcs (( NAT ),D) )) by FUNCT_2:8;
[ x,f9 ] in h by A23,A24;
hence thesis by RELAT_1:def 4;
end;
(for x being set holds (x in ( dom h ) implies x in C));
then ( dom h ) = C by A22,TARSKI:1;
then reconsider h as (Function of C,( Funcs (( NAT ),D) )) by A3,FUNCT_1:def 1,FUNCT_2:def 1;
take h;
(for a being (Element of C) holds (ex f being (Function of ( NAT ),D) st ((( h . a ) = f & ( f . ( 0 ) ) = b) & (for n being (Element of ( NAT )) holds ( f . ( n + 1 ) ) = ( F . (( f . n ),a) )))))
proof
let a being (Element of C);
( dom h ) = C by FUNCT_2:def 1;
then [ a,( h . a ) ] in h by FUNCT_1:1;
then consider a9 being (Element of C),l being (Element of ( Funcs (( NAT ),D) )) such that A25: [ a,( h . a ) ] = [ a9,l ] and A26: (ex f9 being (Function of ( NAT ),D) st ((f9 = l & ( f9 . ( 0 ) ) = b) & (for n being (Element of ( NAT )) holds ( f9 . ( n + 1 ) ) = ( F . (( f9 . n ),a9) ))));
A27: ( h . a ) = ( [ a9,l ] `2 ) by A25,MCART_1:def 2
.= l by MCART_1:def 2;
a = ( [ a9,l ] `1 ) by A25,MCART_1:def 1
.= a9 by MCART_1:def 1;
hence thesis by A26,A27;
end;
hence thesis;
end;
then consider g being (Function of C,( Funcs (( NAT ),D) )) such that A28: (for a being (Element of C) holds (ex f being (Function of ( NAT ),D) st ((( g . a ) = f & ( f . ( 0 ) ) = b) & (for n being (Element of ( NAT )) holds ( f . ( n + 1 ) ) = ( F . (( f . n ),a) )))));
set h = { [ [ a,n ],z ] where n is (Element of ( NAT )),a is (Element of C),z is (Element of D): (ex f being (Function of ( NAT ),D) st (f = ( g . a ) & z = ( f . n ))) };
A29:now
let x being set;
let y1 being set;
let y2 being set;
assume that
A30: [ x,y1 ] in h
and
A31: [ x,y2 ] in h;
consider n1 being (Element of ( NAT )),a1 being (Element of C),z1 being (Element of D) such that A32: [ x,y1 ] = [ [ a1,n1 ],z1 ] and A33: (ex f1 being (Function of ( NAT ),D) st (f1 = ( g . a1 ) & z1 = ( f1 . n1 ))) by A30;
consider n2 being (Element of ( NAT )),a2 being (Element of C),z2 being (Element of D) such that A34: [ x,y2 ] = [ [ a2,n2 ],z2 ] and A35: (ex f2 being (Function of ( NAT ),D) st (f2 = ( g . a2 ) & z2 = ( f2 . n2 ))) by A31;
A36: [ a1,n1 ] = ( [ x,y1 ] `1 ) by A32,MCART_1:def 1
.= x by MCART_1:def 1
.= ( [ [ a2,n2 ],z2 ] `1 ) by A34,MCART_1:def 1
.= [ a2,n2 ] by MCART_1:def 1;
then A37: n1 = ( [ a2,n2 ] `2 ) by MCART_1:def 2
.= n2 by MCART_1:def 2;
a1 = ( [ a2,n2 ] `1 ) by A36,MCART_1:def 1
.= a2 by MCART_1:def 1;
hence y1 = ( [ x,y2 ] `2 ) by A32,A33,A34,A35,A37,MCART_1:def 2
.= y2 by MCART_1:def 2;
end;
now
let x being set;
assume x in h;
then consider n1 being (Element of ( NAT )),a1 being (Element of C),z1 being (Element of D) such that A38: x = [ [ a1,n1 ],z1 ] and (ex f1 being (Function of ( NAT ),D) st (f1 = ( g . a1 ) & z1 = ( f1 . n1 )));
[ a1,n1 ] in [: C,( NAT ) :] by ZFMISC_1:def 2;
hence x in [: [: C,( NAT ) :],D :] by A38,ZFMISC_1:def 2;
end;
then reconsider h as (Relation of [: C,( NAT ) :],D) by TARSKI:def 3;
A39: (for x being set holds (x in [: C,( NAT ) :] implies x in ( dom h )))
proof
let x being set;
assume x in [: C,( NAT ) :];
then consider d,n being set such that A40: d in C and A41: n in ( NAT ) and A42: x = [ d,n ] by ZFMISC_1:def 2;
reconsider d as (Element of C) by A40;
reconsider n as (Element of ( NAT )) by A41;
consider f9 being (Function of ( NAT ),D) such that A43: ( g . d ) = f9 and ( f9 . ( 0 ) ) = b and (for n being (Element of ( NAT )) holds ( f9 . ( n + 1 ) ) = ( F . (( f9 . n ),d) )) by A28;
(ex z being (Element of D) st (ex f being (Function of ( NAT ),D) st (f = ( g . d ) & z = ( f . n ))))
proof
take ( f9 . n );
take f9;
thus thesis by A43;
end;
then consider z being (Element of D) such that A44: (ex f being (Function of ( NAT ),D) st (f = ( g . d ) & z = ( f . n )));
[ x,z ] in h by A42,A44;
hence thesis by RELAT_1:def 4;
end;
(for x being set holds (x in ( dom h ) implies x in [: C,( NAT ) :]));
then ( dom h ) = [: C,( NAT ) :] by A39,TARSKI:1;
then reconsider h as (Function of [: C,( NAT ) :],D) by A29,FUNCT_1:def 1,FUNCT_2:def 1;
take h;
(for a being (Element of C) holds (( h . (a,( 0 )) ) = b & (for n being (Element of ( NAT )) holds ( h . (a,( n + 1 )) ) = ( F . (( h . (a,n) ),a) ))))
proof
let a being (Element of C);
consider f9 being (Function of ( NAT ),D) such that A45: ( g . a ) = f9 and A46: ( f9 . ( 0 ) ) = b and A47: (for n being (Element of ( NAT )) holds ( f9 . ( n + 1 ) ) = ( F . (( f9 . n ),a) )) by A28;
A48:now
let k being (Element of ( NAT ));
[ a,( k + 1 ) ] in [: C,( NAT ) :] by ZFMISC_1:def 2;
then [ a,( k + 1 ) ] in ( dom h ) by FUNCT_2:def 1;
then consider u being set such that A49: [ [ a,( k + 1 ) ],u ] in h by RELAT_1:def 4;
[ a,k ] in [: C,( NAT ) :] by ZFMISC_1:def 2;
then [ a,k ] in ( dom h ) by FUNCT_2:def 1;
then consider v being set such that A50: [ [ a,k ],v ] in h by RELAT_1:def 4;
consider n1 being (Element of ( NAT )),d1 being (Element of C),z1 being (Element of D) such that A51: [ [ a,k ],v ] = [ [ d1,n1 ],z1 ] and A52: (ex f2 being (Function of ( NAT ),D) st (f2 = ( g . d1 ) & z1 = ( f2 . n1 ))) by A50;
A53: v = ( [ [ d1,n1 ],z1 ] `2 ) by A51,MCART_1:def 2
.= z1 by MCART_1:def 2;
A54: [ a,k ] = ( [ [ d1,n1 ],z1 ] `1 ) by A51,MCART_1:def 1
.= [ d1,n1 ] by MCART_1:def 1;
then A55: n1 = ( [ a,k ] `2 ) by MCART_1:def 2
.= k by MCART_1:def 2;
consider f2 being (Function of ( NAT ),D) such that A56: f2 = ( g . d1 ) and A57: z1 = ( f2 . n1 ) by A52;
consider n being (Element of ( NAT )),d being (Element of C),z being (Element of D) such that A58: [ [ a,( k + 1 ) ],u ] = [ [ d,n ],z ] and A59: (ex f1 being (Function of ( NAT ),D) st (f1 = ( g . d ) & z = ( f1 . n ))) by A49;
A60: [ a,( k + 1 ) ] = ( [ [ d,n ],z ] `1 ) by A58,MCART_1:def 1
.= [ d,n ] by MCART_1:def 1;
then A61: n = ( [ a,( k + 1 ) ] `2 ) by MCART_1:def 2
.= ( k + 1 ) by MCART_1:def 2;
A62: d1 = ( [ a,k ] `1 ) by A54,MCART_1:def 1
.= a by MCART_1:def 1;
A63: d = ( [ a,( k + 1 ) ] `1 ) by A60,MCART_1:def 1
.= a by MCART_1:def 1;
u = ( [ [ d,n ],z ] `2 ) by A58,MCART_1:def 2
.= z by MCART_1:def 2;
hence ( h . (a,( k + 1 )) ) = ( f9 . n ) by A45,A49,A59,A63,FUNCT_1:1
.= ( F . (( f2 . n1 ),a) ) by A45,A47,A61,A56,A55,A62
.= ( F . (( h . (a,k) ),a) ) by A50,A57,A53,FUNCT_1:1;
end;
[ a,( 0 ) ] in [: C,( NAT ) :] by ZFMISC_1:def 2;
then [ a,( 0 ) ] in ( dom h ) by FUNCT_2:def 1;
then consider u being set such that A64: [ [ a,( 0 ) ],u ] in h by RELAT_1:def 4;
consider n being (Element of ( NAT )),d being (Element of C),z being (Element of D) such that A65: [ [ a,( 0 ) ],u ] = [ [ d,n ],z ] and A66: (ex f1 being (Function of ( NAT ),D) st (f1 = ( g . d ) & z = ( f1 . n ))) by A64;
A67: u = ( [ [ d,n ],z ] `2 ) by A65,MCART_1:def 2
.= z by MCART_1:def 2;
A68: [ a,( 0 ) ] = ( [ [ d,n ],z ] `1 ) by A65,MCART_1:def 1
.= [ d,n ] by MCART_1:def 1;
then A69: d = ( [ a,( 0 ) ] `1 ) by MCART_1:def 1
.= a by MCART_1:def 1;
n = ( [ a,( 0 ) ] `2 ) by A68,MCART_1:def 2
.= ( 0 ) by MCART_1:def 2;
hence thesis by A45,A46,A64,A66,A67,A69,A48,FUNCT_1:1;
end;
hence thesis;
end;

end;
definition
let R being non  empty addLoopStr;
func Nat-mult-right R -> (Function of [: (the carrier of R),( NAT ) :],(the carrier of R)) means 
:Def7: (for a being (Element of R) holds (( it . (a,( 0 )) ) = ( 0. R ) & (for n being (Element of ( NAT )) holds ( it . (a,( n + 1 )) ) = ( ( it . (a,n) ) + a ))));
existence
proof
consider g being (Function of [: (the carrier of R),( NAT ) :],(the carrier of R)) such that A12: (for a being (Element of R) holds (( g . (a,( 0 )) ) = ( 0. R ) & (for n being (Element of ( NAT )) holds ( g . (a,( n + 1 )) ) = ( (the addF of R) . (( g . (a,n) ),a) )))) by Lm2;
take g;
thus thesis by A12;
end;
uniqueness
proof
let f being (Function of [: (the carrier of R),( NAT ) :],(the carrier of R));
let g being (Function of [: (the carrier of R),( NAT ) :],(the carrier of R));
assume A13: (for a being (Element of R) holds (( f . (a,( 0 )) ) = ( 0. R ) & (for n being (Element of ( NAT )) holds ( f . (a,( n + 1 )) ) = ( ( f . (a,n) ) + a ))));
defpred P[ (Element of ( NAT )) ]
 means
(for a being (Element of R) holds ( f . (a,$1) ) = ( g . (a,$1) ));
assume A14: (for a being (Element of R) holds (( g . (a,( 0 )) ) = ( 0. R ) & (for n being (Element of ( NAT )) holds ( g . (a,( n + 1 )) ) = ( ( g . (a,n) ) + a ))));
A15:now
let n being (Element of ( NAT ));
assume A16: P[ n ];
now
let a being (Element of R);
thus ( f . (a,( n + 1 )) ) = ( ( f . (a,n) ) + a ) by A13
.= ( ( g . (a,n) ) + a ) by A16
.= ( g . (a,( n + 1 )) ) by A14;
end;
hence P[ ( n + 1 ) ];
end;
A17: P[ ( 0 ) ]
proof
let a being (Element of R);
thus ( f . (a,( 0 )) ) = ( 0. R ) by A13
.= ( g . (a,( 0 )) ) by A14;
end;
A18: (for n being (Element of ( NAT )) holds P[ n ]) from NAT_1:sch 1(A17,A15);
A19:now
let x being set;
assume x in [: (the carrier of R),( NAT ) :];
then consider v,u being set such that A20: v in (the carrier of R) and A21: u in ( NAT ) and A22: x = [ v,u ] by ZFMISC_1:def 2;
reconsider v as (Element of R) by A20;
reconsider u as (Element of ( NAT )) by A21;
thus ( f . x ) = ( f . (v,u) ) by A22
.= ( g . (v,u) ) by A18
.= ( g . x ) by A22;
end;
(( dom f ) = [: (the carrier of R),( NAT ) :] & ( dom g ) = [: (the carrier of R),( NAT ) :]) by FUNCT_2:def 1;
hence thesis by A19,FUNCT_1:2;
end;
end;
