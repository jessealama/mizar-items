environ
vocabularies XBOOLE_0,MSUALG_1,CARD_3,FUNCT_1,SUBSET_1,PBOOLE,RELAT_1,FUNCT_6,TARSKI,FUNCOP_1,FINSEQ_4,FUNCT_5,ZFMISC_1,PRALG_1,MCART_1,COMPLEX1,STRUCT_0,MARGREL1,RLVECT_2,FUNCT_2,PRALG_2,PARTFUN1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,BINOP_1,MCART_1,STRUCT_0,FUNCOP_1,FINSEQ_2,FUNCT_5,FUNCT_6,CARD_3,PBOOLE,PRALG_1,MSUALG_1,CKB3,CKB5,CKB8,CKB9,CKB10,CKB11,CKB12,CKB14,CKB18,CKB20,CKB22;
definitions TARSKI,PBOOLE,FUNCOP_1,XBOOLE_0,BINOP_1,FUNCT_6,FUNCT_2,CKB3,CKB5,CKB8,CKB9,CKB10,CKB12,CKB14,CKB18,CKB20,CKB22;
theorems TARSKI,FUNCT_1,FINSEQ_1,PBOOLE,MSUALG_1,ZFMISC_1,CARD_3,FUNCT_2,MCART_1,FUNCOP_1,FUNCT_6,FUNCT_5,RELAT_1,PRALG_1,XBOOLE_0,XBOOLE_1,PARTFUN1,FINSEQ_2,CKB3,CKB4,CKB5,CKB7,CKB8,CKB9,CKB10,CKB12,CKB14,CKB16,CKB17,CKB18,CKB20,CKB22;
schemes FUNCT_1,FUNCT_2,CLASSES1,TARSKI,PBOOLE;
registrations XBOOLE_0,RELAT_1,FUNCT_1,FUNCOP_1,CARD_3,PBOOLE,STRUCT_0,MSUALG_1,RELSET_1,FINSEQ_2,CKB1,CKB2,CKB6,CKB13,CKB15,CKB19,CKB21,CKB23;
constructors BINOP_1,FUNCT_6,PRALG_1,MSUALG_1,RELSET_1,FUNCT_5,CKB3,CKB5,CKB8,CKB9,CKB10,CKB11,CKB12,CKB14,CKB18,CKB20,CKB22;
requirements BOOLE,SUBSET;
begin
reserve I for set;
reserve i for set;
reserve x for set;
reserve S for non  empty ManySortedSign;
definition
let I;
let S being non  empty ManySortedSign;
let A being (MSAlgebra-Family of I,S);
func OPER A -> (ManySortedFunction of I) means 
:Def18: (for i being set holds (i in I implies (ex U0 being MSAlgebra over S st (U0 = ( A . i ) & ( it . i ) = (the Charact of U0))))) if I <> ( {} ) otherwise it = ( {} );
existence
proof
reconsider f = ( [[0]] I ) as (ManySortedFunction of I);
hereby
assume I <> ( {} );
then reconsider I9 = I as non  empty set;
reconsider A9 = A as (MSAlgebra-Family of I9,S);
deffunc F((Element of I9)) = (the Charact of ( A9 . $1 ));
consider X being (ManySortedSet of I9) such that A1: (for i being (Element of I9) holds ( X . i ) = F(i)) from PBOOLE:sch 5;
(for x holds (x in ( dom X ) implies ( X . x ) is Function))
proof
let x;
assume x in ( dom X );
then reconsider i = x as (Element of I9) by PARTFUN1:def 2;
( X . i ) = (the Charact of ( A9 . i )) by A1;
hence thesis;
end;
then reconsider X as (ManySortedFunction of I) by FUNCOP_1:def 6;
take X;
let i being set;
assume i in I;
then reconsider i9 = i as (Element of I9);
reconsider U0 = ( A9 . i9 ) as MSAlgebra over S;
take U0;
thus (U0 = ( A . i ) & ( X . i ) = (the Charact of U0)) by A1;
end;
assume A2: I = ( {} );
take f;
thus thesis by A2;
end;
uniqueness
proof
let f being (ManySortedFunction of I);
let g being (ManySortedFunction of I);
hereby
assume I <> ( {} );
assume A3: ((for i being set holds (i in I implies (ex U0 being MSAlgebra over S st (U0 = ( A . i ) & ( f . i ) = (the Charact of U0))))) & (for i being set holds (i in I implies (ex U0 being MSAlgebra over S st (U0 = ( A . i ) & ( g . i ) = (the Charact of U0))))));
(for x holds (x in I implies ( f . x ) = ( g . x )))
proof
let x;
assume A4: x in I;
then reconsider i = x as (Element of I);
((ex U0 being MSAlgebra over S st (U0 = ( A . i ) & ( f . i ) = (the Charact of U0))) & (ex U0 being MSAlgebra over S st (U0 = ( A . i ) & ( g . i ) = (the Charact of U0)))) by A3,A4;
hence thesis;
end;
hence f = g by PBOOLE:3;
end;
thus thesis;
end;
correctness;
end;
