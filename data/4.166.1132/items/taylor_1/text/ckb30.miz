environ
vocabularies NUMBERS,ORDINAL1,INT_1,XREAL_0,RAT_1,PARTFUN1,PREPOWER,FUNCT_1,REAL_1,SUBSET_1,ARYTM_3,RELAT_1,CARD_1,NEWTON,COMPLEX1,XXREAL_0,FDIFF_1,ARYTM_1,RCOMP_1,TARSKI,XBOOLE_0,VALUED_1,SIN_COS,SEQ_2,ORDINAL2,FCONT_1,FUNCT_2,POWER,SERIES_1,REALSET1,NAT_1,CARD_3,LIMFUNC1,SEQFUNC,SEQ_1,XXREAL_1,TAYLOR_1,IRRAT_1;
notations TARSKI,XBOOLE_0,SUBSET_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,IRRAT_1,LIMFUNC1,RCOMP_1,FCONT_1,XCMPLX_0,XXREAL_0,XREAL_0,COMPLEX1,RAT_1,ORDINAL1,NUMBERS,REAL_1,NAT_1,INT_1,NEWTON,VALUED_1,PARTFUN2,SEQ_1,SEQ_2,SERIES_1,FDIFF_1,SEQFUNC,PREPOWER,POWER,SIN_COS,CKB1,CKB25,CKB26;
definitions SUBSET_1,LIMFUNC1,CKB1,CKB25,CKB26;
theorems XBOOLE_1,ABSVALUE,TARSKI,XBOOLE_0,PARTFUN1,PARTFUN2,XCMPLX_1,RELAT_1,CARD_4,RCOMP_1,SEQ_1,SEQ_2,SIN_COS,SERIES_1,FUNCT_1,NAT_1,INT_1,NEWTON,RAT_1,IRRAT_1,POWER,FCONT_1,FDIFF_1,FDIFF_2,ROLLE,SEQ_4,PREPOWER,FUNCT_2,XREAL_0,XREAL_1,XXREAL_0,ORDINAL1,VALUED_1,XXREAL_1,XXREAL_2,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB23,CKB25,CKB26,CKB27,CKB28,CKB29;
schemes SEQ_1,RECDEF_1,NAT_1,INT_1,PARTFUN2,FUNCT_2;
registrations XBOOLE_0,RELSET_1,PARTFUN1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,RAT_1,MEMBERED,RCOMP_1,NEWTON,PREPOWER,SIN_COS,VALUED_0,VALUED_1,FUNCT_2,XXREAL_2,ORDINAL1,SEQ_4,FCONT_3,ABIAN,CKB22,CKB24;
constructors PARTFUN1,ARYTM_0,REAL_1,NAT_1,SEQ_2,RCOMP_1,PARTFUN2,RFUNCT_2,FCONT_1,LIMFUNC1,FDIFF_1,SEQFUNC,PREPOWER,COMSEQ_3,SIN_COS,SEQ_1,XXREAL_2,SERIES_1,VALUED_1,POWER,RELSET_1,ABIAN,CKB1,CKB25,CKB26;
requirements SUBSET,REAL,BOOLE,NUMERALS,ARITHM;
begin
reserve p for  real number;
reserve f for (PartFunc of ( REAL ),( REAL ));
definition
let p being  real number;
func #R p -> (PartFunc of ( REAL ),( REAL )) means 
:Def4: (( dom it ) = ( right_open_halfline ( 0 ) ) & (for d being (Element of ( right_open_halfline ( 0 ) )) holds ( it . d ) = ( d #R p )));
existence
proof
defpred X[ set ]
 means
$1 in ( right_open_halfline ( 0 ) );
reconsider p as Real by XREAL_0:def 1;
deffunc U(Real) = ( $1 #R p );
consider f being (PartFunc of ( REAL ),( REAL )) such that A1: (for d being (Element of ( REAL )) holds (d in ( dom f ) iff X[ d ])) and A2: (for d being (Element of ( REAL )) holds (d in ( dom f ) implies ( f /. d ) = U(d))) from PARTFUN2:sch 2;
take f;
(for x being set holds (x in ( right_open_halfline ( 0 ) ) implies x in ( dom f ))) by A1;
then A3: ( right_open_halfline ( 0 ) ) c= ( dom f ) by TARSKI:def 3;
(for x being set holds (x in ( dom f ) implies x in ( right_open_halfline ( 0 ) ))) by A1;
then ( dom f ) c= ( right_open_halfline ( 0 ) ) by TARSKI:def 3;
hence A4: ( dom f ) = ( right_open_halfline ( 0 ) ) by A3,XBOOLE_0:def 10;
let d being (Element of ( right_open_halfline ( 0 ) ));
( f /. d ) = ( d #R p ) by A2,A4;
hence thesis by A4,PARTFUN1:def 6;
end;
uniqueness
proof
let f1 being (PartFunc of ( REAL ),( REAL ));
let f2 being (PartFunc of ( REAL ),( REAL ));
assume that
A5: ( dom f1 ) = ( right_open_halfline ( 0 ) )
and
A6: (for d being (Element of ( right_open_halfline ( 0 ) )) holds ( f1 . d ) = ( d #R p ))
and
A7: ( dom f2 ) = ( right_open_halfline ( 0 ) )
and
A8: (for d being (Element of ( right_open_halfline ( 0 ) )) holds ( f2 . d ) = ( d #R p ));
(for d being (Element of ( REAL )) holds (d in ( right_open_halfline ( 0 ) ) implies ( f1 . d ) = ( f2 . d )))
proof
let d being (Element of ( REAL ));
assume that
A9: d in ( right_open_halfline ( 0 ) );
thus ( f1 . d ) = ( d #R p ) by A6,A9
.= ( f2 . d ) by A8,A9;
end;
hence f1 = f2 by A5,A7,PARTFUN1:5;
end;
end;
