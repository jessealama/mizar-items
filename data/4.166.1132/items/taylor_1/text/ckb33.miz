environ
vocabularies NUMBERS,ORDINAL1,INT_1,XREAL_0,RAT_1,PARTFUN1,PREPOWER,FUNCT_1,REAL_1,SUBSET_1,ARYTM_3,RELAT_1,CARD_1,NEWTON,COMPLEX1,XXREAL_0,FDIFF_1,ARYTM_1,RCOMP_1,TARSKI,XBOOLE_0,VALUED_1,SIN_COS,SEQ_2,ORDINAL2,FCONT_1,FUNCT_2,POWER,SERIES_1,REALSET1,NAT_1,CARD_3,LIMFUNC1,SEQFUNC,SEQ_1,XXREAL_1,TAYLOR_1,IRRAT_1;
notations TARSKI,XBOOLE_0,SUBSET_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,IRRAT_1,LIMFUNC1,RCOMP_1,FCONT_1,XCMPLX_0,XXREAL_0,XREAL_0,COMPLEX1,RAT_1,ORDINAL1,NUMBERS,REAL_1,NAT_1,INT_1,NEWTON,VALUED_1,PARTFUN2,SEQ_1,SEQ_2,SERIES_1,FDIFF_1,SEQFUNC,PREPOWER,POWER,SIN_COS,CKB1,CKB25,CKB26,CKB30;
definitions SUBSET_1,LIMFUNC1,CKB1,CKB25,CKB26,CKB30;
theorems XBOOLE_1,ABSVALUE,TARSKI,XBOOLE_0,PARTFUN1,PARTFUN2,XCMPLX_1,RELAT_1,CARD_4,RCOMP_1,SEQ_1,SEQ_2,SIN_COS,SERIES_1,FUNCT_1,NAT_1,INT_1,NEWTON,RAT_1,IRRAT_1,POWER,FCONT_1,FDIFF_1,FDIFF_2,ROLLE,SEQ_4,PREPOWER,FUNCT_2,XREAL_0,XREAL_1,XXREAL_0,ORDINAL1,VALUED_1,XXREAL_1,XXREAL_2,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB23,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32;
schemes SEQ_1,RECDEF_1,NAT_1,INT_1,PARTFUN2,FUNCT_2;
registrations XBOOLE_0,RELSET_1,PARTFUN1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,RAT_1,MEMBERED,RCOMP_1,NEWTON,PREPOWER,SIN_COS,VALUED_0,VALUED_1,FUNCT_2,XXREAL_2,ORDINAL1,SEQ_4,FCONT_3,ABIAN,CKB22,CKB24;
constructors PARTFUN1,ARYTM_0,REAL_1,NAT_1,SEQ_2,RCOMP_1,PARTFUN2,RFUNCT_2,FCONT_1,LIMFUNC1,FDIFF_1,SEQFUNC,PREPOWER,COMSEQ_3,SIN_COS,SEQ_1,XXREAL_2,SERIES_1,VALUED_1,POWER,RELSET_1,ABIAN,CKB1,CKB25,CKB26,CKB30;
requirements SUBSET,REAL,BOOLE,NUMERALS,ARITHM;
begin
reserve i for Integer;
reserve x for  real number;
reserve f for (PartFunc of ( REAL ),( REAL ));
definition
let f being (PartFunc of ( REAL ),( REAL ));
let Z being (Subset of ( REAL ));
func diff (f,Z) -> (Functional_Sequence of ( REAL ),( REAL )) means 
:Def5: (( it . ( 0 ) ) = ( f | Z ) & (for i being  natural number holds ( it . ( i + 1 ) ) = ( ( it . i ) `| Z )));
existence
proof
reconsider fZ = ( f | Z ) as (Element of ( PFuncs (( REAL ),( REAL )) )) by PARTFUN1:45;
defpred R[ set,set,set ]
 means
(ex h being (PartFunc of ( REAL ),( REAL )) st ($2 = h & $3 = ( h `| Z )));
A1: (for n being (Element of ( NAT )) holds (for x being (Element of ( PFuncs (( REAL ),( REAL )) )) holds (ex y being (Element of ( PFuncs (( REAL ),( REAL )) )) st R[ n,x,y ])))
proof
let n being (Element of ( NAT ));
let x being (Element of ( PFuncs (( REAL ),( REAL )) ));
reconsider x9 = x as (PartFunc of ( REAL ),( REAL )) by PARTFUN1:46;
reconsider y = ( x9 `| Z ) as (Element of ( PFuncs (( REAL ),( REAL )) )) by PARTFUN1:45;
(ex h being (PartFunc of ( REAL ),( REAL )) st (x = h & y = ( h `| Z )));
hence thesis;
end;
consider g being (Function of ( NAT ),( PFuncs (( REAL ),( REAL )) )) such that A2: (( g . ( 0 ) ) = fZ & (for n being (Element of ( NAT )) holds R[ n,( g . n ),( g . ( n + 1 ) ) ])) from RECDEF_1:sch 2(A1);
reconsider g as (Functional_Sequence of ( REAL ),( REAL ));
take g;
thus ( g . ( 0 ) ) = ( f | Z ) by A2;
let i being  natural number;
i is (Element of ( NAT )) by ORDINAL1:def 12;
then R[ i,( g . i ),( g . ( i + 1 ) ) ] by A2;
hence thesis;
end;
uniqueness
proof
let seq1 being (Functional_Sequence of ( REAL ),( REAL ));
let seq2 being (Functional_Sequence of ( REAL ),( REAL ));
assume that
A3: ( seq1 . ( 0 ) ) = ( f | Z )
and
A4: (for n being  natural number holds ( seq1 . ( n + 1 ) ) = ( ( seq1 . n ) `| Z ))
and
A5: ( seq2 . ( 0 ) ) = ( f | Z )
and
A6: (for n being  natural number holds ( seq2 . ( n + 1 ) ) = ( ( seq2 . n ) `| Z ));
defpred P[ (Element of ( NAT )) ]
 means
( seq1 . $1 ) = ( seq2 . $1 );
A7: (for k being (Element of ( NAT )) holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume A8: P[ k ];
thus ( seq1 . ( k + 1 ) ) = ( ( seq1 . k ) `| Z ) by A4
.= ( seq2 . ( k + 1 ) ) by A6,A8;
end;
A9: P[ ( 0 ) ] by A3,A5;
(for n being (Element of ( NAT )) holds P[ n ]) from NAT_1:sch 1(A9,A7);
hence seq1 = seq2 by FUNCT_2:63;
end;
end;
