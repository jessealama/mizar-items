environ
vocabularies TARSKI,XBOOLE_0,CLASSES1,ZFMISC_1,EQREL_1,TOLER_1,SETFAM_1,SUBSET_1,FUNCT_2,FUNCT_1,RELAT_1,MCART_1,GRAPH_1,ENS_1,PARTFUN1,CAT_1,COH_SP;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,SETFAM_1,RELAT_1,RELSET_1,MCART_1,FUNCT_1,PARTFUN1,CLASSES1,FUNCT_2,BINOP_1,EQREL_1,TOLER_1,CAT_1,CKB1,CKB3,CKB8,CKB16,CKB21,CKB25,CKB28,CKB33,CKB34,CKB37,CKB40,CKB45,CKB46;
definitions TARSKI,CLASSES1,XBOOLE_0,BINOP_1,RELAT_1,CKB1,CKB8,CKB16,CKB21,CKB25,CKB28,CKB33,CKB34,CKB37,CKB40,CKB45,CKB46;
theorems TARSKI,ZFMISC_1,TOLER_1,ENUMSET1,RELAT_1,FUNCT_2,CLASSES1,PARTFUN1,MCART_1,FUNCT_1,DOMAIN_1,CAT_1,XBOOLE_0,XBOOLE_1,EQREL_1,CKB1,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB24,CKB25,CKB27,CKB28,CKB30,CKB31,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46;
schemes TOLER_1,TARSKI,FUNCT_2,BINOP_1,XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,EQREL_1,CAT_2,CKB2,CKB22,CKB23,CKB26,CKB29,CKB32;
constructors BINOP_1,EQREL_1,CLASSES1,TOLER_1,CAT_1,RELSET_1,CKB1,CKB8,CKB16,CKB21,CKB25,CKB28,CKB33,CKB34,CKB37,CKB40,CKB45,CKB46;
requirements SUBSET,BOOLE;
begin
reserve x for set;
reserve y for set;
reserve z for set;
reserve X for set;
reserve l for (Element of ( MapsC X ));
reserve l1 for (Element of ( MapsC X ));
reserve l2 for (Element of ( MapsC X ));
definition
let X;
func CComp X -> (PartFunc of [: ( MapsC X ),( MapsC X ) :],( MapsC X )) means 
:Def16: ((for l2 holds (for l1 holds ([ l2,l1 ] in ( dom it ) iff ( dom l2 ) = ( cod l1 )))) & (for l2 holds (for l1 holds (( dom l2 ) = ( cod l1 ) implies ( it . [ l2,l1 ] ) = ( l2 * l1 )))));
existence
proof
defpred P[ set,set,set ]
 means
(for l2 holds (for l1 holds ((l2 = $1 & l1 = $2) implies (( dom l2 ) = ( cod l1 ) & $3 = ( l2 * l1 )))));
A5: (for x,y,z1,z2 being set holds ((((x in ( MapsC X ) & y in ( MapsC X )) & P[ x,y,z1 ]) & P[ x,y,z2 ]) implies z1 = z2))
proof
let x being set;
let y being set;
let z1 being set;
let z2 being set;
assume (x in ( MapsC X ) & y in ( MapsC X ));
then reconsider l2 = x,l1 = y as (Element of ( MapsC X ));
assume that
A6: P[ x,y,z1 ]
and
A7: P[ x,y,z2 ];
z1 = ( l2 * l1 ) by A6;
hence thesis by A7;
end;
A8: (for x,y,z being set holds (((x in ( MapsC X ) & y in ( MapsC X )) & P[ x,y,z ]) implies z in ( MapsC X )))
proof
let x being set;
let y being set;
let z being set;
assume (x in ( MapsC X ) & y in ( MapsC X ));
then reconsider l2 = x,l1 = y as (Element of ( MapsC X ));
assume P[ x,y,z ];
then z = ( l2 * l1 );
hence thesis;
end;
consider h being (PartFunc of [: ( MapsC X ),( MapsC X ) :],( MapsC X )) such that A9: (for x holds (for y holds ([ x,y ] in ( dom h ) iff ((x in ( MapsC X ) & y in ( MapsC X )) & (ex z st P[ x,y,z ]))))) and A10: (for x holds (for y holds ([ x,y ] in ( dom h ) implies P[ x,y,( h . (x,y) ) ]))) from BINOP_1:sch 5(A8,A5);
take h;
thus A11: (for l2 holds (for l1 holds ([ l2,l1 ] in ( dom h ) iff ( dom l2 ) = ( cod l1 ))))
proof
let l2;
let l1;
thus ([ l2,l1 ] in ( dom h ) implies ( dom l2 ) = ( cod l1 ))
proof
assume [ l2,l1 ] in ( dom h );
then (ex z being set st P[ l2,l1,z ]) by A9;
hence thesis;
end;

assume ( dom l2 ) = ( cod l1 );
then P[ l2,l1,( l2 * l1 ) ];
hence thesis by A9;
end;

let l2;
let l1;
assume ( dom l2 ) = ( cod l1 );
then [ l2,l1 ] in ( dom h ) by A11;
then P[ l2,l1,( h . (l2,l1) ) ] by A10;
hence thesis;
end;
uniqueness
proof
let h1 being (PartFunc of [: ( MapsC X ),( MapsC X ) :],( MapsC X ));
let h2 being (PartFunc of [: ( MapsC X ),( MapsC X ) :],( MapsC X ));
assume that
A12: (for l2 holds (for l1 holds ([ l2,l1 ] in ( dom h1 ) iff ( dom l2 ) = ( cod l1 ))))
and
A13: (for l2 holds (for l1 holds (( dom l2 ) = ( cod l1 ) implies ( h1 . [ l2,l1 ] ) = ( l2 * l1 ))))
and
A14: (for l2 holds (for l1 holds ([ l2,l1 ] in ( dom h2 ) iff ( dom l2 ) = ( cod l1 ))))
and
A15: (for l2 holds (for l1 holds (( dom l2 ) = ( cod l1 ) implies ( h2 . [ l2,l1 ] ) = ( l2 * l1 ))));
A16: ( dom h1 ) = ( dom h2 )
proof
let x being set;
let y being set;
thus ([ x,y ] in ( dom h1 ) implies [ x,y ] in ( dom h2 ))
proof
assume A17: [ x,y ] in ( dom h1 );
then reconsider l2 = x,l1 = y as (Element of ( MapsC X )) by ZFMISC_1:87;
( dom l2 ) = ( cod l1 ) by A12,A17;
hence thesis by A14;
end;

assume A18: [ x,y ] in ( dom h2 );
then reconsider l2 = x,l1 = y as (Element of ( MapsC X )) by ZFMISC_1:87;
( dom l2 ) = ( cod l1 ) by A14,A18;
hence thesis by A12;
end;
now
let l being (Element of [: ( MapsC X ),( MapsC X ) :]);
assume that
A19: l in ( dom h1 );
consider l2,l1 being (Element of ( MapsC X )) such that A20: l = [ l2,l1 ] by DOMAIN_1:1;
A21: ( dom l2 ) = ( cod l1 ) by A12,A19,A20;
then ( h1 . [ l2,l1 ] ) = ( l2 * l1 ) by A13;
hence ( h1 . l ) = ( h2 . l ) by A15,A20,A21;
end;
hence thesis by A16,PARTFUN1:5;
end;
end;
