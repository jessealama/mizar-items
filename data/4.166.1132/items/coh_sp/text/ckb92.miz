environ
vocabularies TARSKI,XBOOLE_0,CLASSES1,ZFMISC_1,EQREL_1,TOLER_1,SETFAM_1,SUBSET_1,FUNCT_2,FUNCT_1,RELAT_1,MCART_1,GRAPH_1,ENS_1,PARTFUN1,CAT_1,COH_SP;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,SETFAM_1,RELAT_1,RELSET_1,MCART_1,FUNCT_1,PARTFUN1,CLASSES1,FUNCT_2,BINOP_1,EQREL_1,TOLER_1,CAT_1,CKB1,CKB3,CKB8,CKB16,CKB21,CKB25,CKB28,CKB33,CKB34,CKB37,CKB40,CKB45,CKB46,CKB47,CKB48,CKB50,CKB51,CKB53,CKB62,CKB69,CKB70,CKB71,CKB74,CKB79,CKB80,CKB83,CKB85,CKB90,CKB91;
definitions TARSKI,CLASSES1,XBOOLE_0,BINOP_1,RELAT_1,CKB1,CKB8,CKB16,CKB21,CKB25,CKB28,CKB33,CKB34,CKB37,CKB40,CKB45,CKB46,CKB47,CKB48,CKB50,CKB51,CKB53,CKB62,CKB71,CKB74,CKB79,CKB80,CKB83,CKB85,CKB90,CKB91;
theorems TARSKI,ZFMISC_1,TOLER_1,ENUMSET1,RELAT_1,FUNCT_2,CLASSES1,PARTFUN1,MCART_1,FUNCT_1,DOMAIN_1,CAT_1,XBOOLE_0,XBOOLE_1,EQREL_1,CKB1,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB24,CKB25,CKB27,CKB28,CKB30,CKB31,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB53,CKB55,CKB56,CKB57,CKB58,CKB59,CKB60,CKB61,CKB62,CKB64,CKB65,CKB66,CKB67,CKB68,CKB71,CKB73,CKB74,CKB76,CKB77,CKB79,CKB80,CKB81,CKB82,CKB83,CKB84,CKB85,CKB86,CKB87,CKB88,CKB89,CKB90,CKB91;
schemes TOLER_1,TARSKI,FUNCT_2,BINOP_1,XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,EQREL_1,CAT_2,CKB2,CKB22,CKB23,CKB26,CKB29,CKB32,CKB52,CKB54,CKB63,CKB72,CKB75,CKB78;
constructors BINOP_1,EQREL_1,CLASSES1,TOLER_1,CAT_1,RELSET_1,CKB1,CKB8,CKB16,CKB21,CKB25,CKB28,CKB33,CKB34,CKB37,CKB40,CKB45,CKB46,CKB47,CKB48,CKB50,CKB51,CKB53,CKB62,CKB69,CKB70,CKB71,CKB74,CKB79,CKB80,CKB83,CKB85,CKB90,CKB91;
requirements SUBSET,BOOLE;
begin
reserve x for set;
reserve y for set;
reserve z for set;
reserve X for set;
reserve m1 for (Element of ( MapsT X ));
reserve m2 for (Element of ( MapsT X ));
definition
let X;
func fComp X -> (PartFunc of [: ( MapsT X ),( MapsT X ) :],( MapsT X ))
means
:Def31: ((for m2 holds (for m1 holds ([ m2,m1 ] in ( dom it ) iff ( dom m2 ) = ( cod m1 )))) & (for m2 holds (for m1 holds (( dom m2 ) = ( cod m1 ) implies ( it . [ m2,m1 ] ) = ( m2 * m1 )))));
existence
proof
defpred P[ set,set,set ]
 means
(for m2 holds (for m1 holds ((m2 = $1 & m1 = $2) implies (( dom m2 ) = ( cod m1 ) & $3 = ( m2 * m1 )))));
A5: (for x,y,z1,z2 being set holds ((((x in ( MapsT X ) & y in ( MapsT X )) & P[ x,y,z1 ]) & P[ x,y,z2 ]) implies z1 = z2))
proof
let x being set,y being set,z1 being set,z2 being set;
assume (x in ( MapsT X ) & y in ( MapsT X ));
then reconsider m2 = x,m1 = y as (Element of ( MapsT X ));
assume that
A6: P[ x,y,z1 ]
and
A7: P[ x,y,z2 ];
z1 = ( m2 * m1 ) by A6;
hence thesis by A7;
end;
A8: (for x,y,z being set holds (((x in ( MapsT X ) & y in ( MapsT X )) & P[ x,y,z ]) implies z in ( MapsT X )))
proof
let x being set,y being set,z being set;
assume (x in ( MapsT X ) & y in ( MapsT X ));
then reconsider m2 = x,m1 = y as (Element of ( MapsT X ));
assume P[ x,y,z ];
then z = ( m2 * m1 );
hence thesis;
end;
consider h being (PartFunc of [: ( MapsT X ),( MapsT X ) :],( MapsT X )) such that A9: (for x holds (for y holds ([ x,y ] in ( dom h ) iff ((x in ( MapsT X ) & y in ( MapsT X )) & (ex z st P[ x,y,z ]))))) and A10: (for x holds (for y holds ([ x,y ] in ( dom h ) implies P[ x,y,( h . (x,y) ) ]))) from BINOP_1:sch 5(A8,A5);
take h;
thus A11: (for m2 holds (for m1 holds ([ m2,m1 ] in ( dom h ) iff ( dom m2 ) = ( cod m1 ))))
proof
let m2;
let m1;
thus ([ m2,m1 ] in ( dom h ) implies ( dom m2 ) = ( cod m1 ))
proof
assume [ m2,m1 ] in ( dom h );
then (ex z being set st P[ m2,m1,z ]) by A9;
hence thesis;
end;

assume ( dom m2 ) = ( cod m1 );
then P[ m2,m1,( m2 * m1 ) ];
hence thesis by A9;
end;

let m2;
let m1;
assume ( dom m2 ) = ( cod m1 );
then [ m2,m1 ] in ( dom h ) by A11;
then P[ m2,m1,( h . (m2,m1) ) ] by A10;
hence thesis;
end;
uniqueness
proof
let h1 being (PartFunc of [: ( MapsT X ),( MapsT X ) :],( MapsT X )),h2 being (PartFunc of [: ( MapsT X ),( MapsT X ) :],( MapsT X ));
assume that
A12: (for m2 holds (for m1 holds ([ m2,m1 ] in ( dom h1 ) iff ( dom m2 ) = ( cod m1 ))))
and
A13: (for m2 holds (for m1 holds (( dom m2 ) = ( cod m1 ) implies ( h1 . [ m2,m1 ] ) = ( m2 * m1 ))))
and
A14: (for m2 holds (for m1 holds ([ m2,m1 ] in ( dom h2 ) iff ( dom m2 ) = ( cod m1 ))))
and
A15: (for m2 holds (for m1 holds (( dom m2 ) = ( cod m1 ) implies ( h2 . [ m2,m1 ] ) = ( m2 * m1 ))));
A16: ( dom h1 ) = ( dom h2 )
proof
let x being set,y being set;
thus ([ x,y ] in ( dom h1 ) implies [ x,y ] in ( dom h2 ))
proof
assume A17: [ x,y ] in ( dom h1 );
then reconsider m2 = x,m1 = y as (Element of ( MapsT X )) by ZFMISC_1:87;
( dom m2 ) = ( cod m1 ) by A12,A17;
hence thesis by A14;
end;

assume A18: [ x,y ] in ( dom h2 );
then reconsider m2 = x,m1 = y as (Element of ( MapsT X )) by ZFMISC_1:87;
( dom m2 ) = ( cod m1 ) by A14,A18;
hence thesis by A12;
end;
now
let m being (Element of [: ( MapsT X ),( MapsT X ) :]);
assume that
A19: m in ( dom h1 );
consider m2 being (Element of ( MapsT X )),m1 being (Element of ( MapsT X )) such that A20: m = [ m2,m1 ] by DOMAIN_1:1;
A21: ( dom m2 ) = ( cod m1 ) by A12,A19,A20;
then ( h1 . [ m2,m1 ] ) = ( m2 * m1 ) by A13;
hence ( h1 . m ) = ( h2 . m ) by A15,A20,A21;
end;
hence thesis by A16,PARTFUN1:5;
end;
end;
