environ
vocabularies TARSKI,XBOOLE_0,CLASSES1,ZFMISC_1,EQREL_1,TOLER_1,SETFAM_1,SUBSET_1,FUNCT_2,FUNCT_1,RELAT_1,MCART_1,GRAPH_1,ENS_1,PARTFUN1,CAT_1,COH_SP;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,SETFAM_1,RELAT_1,RELSET_1,MCART_1,FUNCT_1,PARTFUN1,CLASSES1,FUNCT_2,BINOP_1,EQREL_1,TOLER_1,CAT_1,CKB1,CKB3,CKB8;
definitions TARSKI,CLASSES1,XBOOLE_0,BINOP_1,RELAT_1,CKB1,CKB8;
theorems TARSKI,ZFMISC_1,TOLER_1,ENUMSET1,RELAT_1,FUNCT_2,CLASSES1,PARTFUN1,MCART_1,FUNCT_1,DOMAIN_1,CAT_1,XBOOLE_0,XBOOLE_1,EQREL_1,CKB1,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15;
schemes TOLER_1,TARSKI,FUNCT_2,BINOP_1,XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,EQREL_1,CAT_2,CKB2;
constructors BINOP_1,EQREL_1,CLASSES1,TOLER_1,CAT_1,RELSET_1,CKB1,CKB8;
requirements SUBSET,BOOLE;
begin
reserve x for set;
reserve y for set;
reserve z for set;
reserve a for set;
reserve b for set;
reserve A for set;
reserve C for Coherence_Space;
reserve D for Coherence_Space;
definition
let X being set;
let E being (Tolerance of X);
func CohSp E -> Coherence_Space
means
:Def4: (for a holds (a in it iff (for x holds (for y holds ((x in a & y in a) implies [ x,y ] in E)))));
existence
proof
defpred P[ set ]
 means
(for x holds (for y holds ((x in $1 & y in $1) implies [ x,y ] in E)));
consider Z being set such that A1: (for x holds (x in Z iff (x in ( bool X ) & P[ x ]))) from XBOOLE_0:sch 1;
A2: (for A holds ((A c= Z & (for a holds (for b holds ((a in A & b in A) implies ( a \/ b ) in Z)))) implies ( union A ) in Z))
proof
let A;
assume that
A3: A c= Z
and
A4: (for a holds (for b holds ((a in A & b in A) implies ( a \/ b ) in Z)));
A5:now
let x;
let y;
assume that
A6: x in ( union A )
and
A7: y in ( union A );
consider Y1 being set such that A8: y in Y1 and A9: Y1 in A by A7,TARSKI:def 4;
consider X1 being set such that A10: x in X1 and A11: X1 in A by A6,TARSKI:def 4;
A12: x in ( X1 \/ Y1 ) by A10,XBOOLE_0:def 3;
A13: y in ( X1 \/ Y1 ) by A8,XBOOLE_0:def 3;
( X1 \/ Y1 ) in Z by A4,A11,A9;
hence [ x,y ] in E by A1,A12,A13;
end;
now
let a;
assume a in A;
then a in ( bool X ) by A1,A3;
hence a c= X;
end;
then ( union A ) c= X by ZFMISC_1:76;
hence thesis by A1,A5;
end;
A14: (for a holds (for b holds ((a in Z & b c= a) implies b in Z)))
proof
let a;
let b;
assume that
A15: a in Z
and
A16: b c= a;
a in ( bool X ) by A1,A15;
then A17: b c= X by A16,XBOOLE_1:1;
(for x holds (for y holds ((x in b & y in b) implies [ x,y ] in E))) by A1,A15,A16;
hence thesis by A1,A17;
end;
(P[ ( {} ) ] & ( {} ) c= X) by XBOOLE_1:2;
then reconsider Z as Coherence_Space by A1,A14,A2,CKB1:def 1,CLASSES1:def 1;
take Z;
let a;
thus (a in Z implies (for x holds (for y holds ((x in a & y in a) implies [ x,y ] in E)))) by A1;
assume A18: (for x holds (for y holds ((x in a & y in a) implies [ x,y ] in E)));
then a is (TolSet of E) by TOLER_1:def 1;
then a c= X by TOLER_1:18;
hence thesis by A1,A18;
end;
uniqueness
proof
let C;
let D;
assume that
A19: (for a holds (a in C iff (for x holds (for y holds ((x in a & y in a) implies [ x,y ] in E)))))
and
A20: (for a holds (a in D iff (for x holds (for y holds ((x in a & y in a) implies [ x,y ] in E)))));
thus C c= D
proof
let x;
assume x in C;
then (for z holds (for y holds ((z in x & y in x) implies [ z,y ] in E))) by A19;
hence thesis by A20;
end;

let x;
assume x in D;
then (for z holds (for y holds ((z in x & y in x) implies [ z,y ] in E))) by A20;
hence thesis by A19;
end;
end;
