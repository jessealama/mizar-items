environ
vocabularies STRUCT_0,BINOP_1,XBOOLE_0,SUBSET_1,QC_LANG1,FUNCT_1,FUNCT_5,ZFMISC_1,MCART_1,RELAT_1,VECTSP_1,ARYTM_3,ARYTM_1,ALGSTR_0,SUPINF_2,RLVECT_1,MIDSP_1;
notations XBOOLE_0,ZFMISC_1,SUBSET_1,BINOP_1,DOMAIN_1,FUNCT_5,STRUCT_0,ALGSTR_0,RLVECT_1,MCART_1,FUNCT_2,CKB1,CKB3,CKB4,CKB10,CKB12,CKB13,CKB19,CKB29,CKB30,CKB31,CKB39,CKB46,CKB47,CKB49;
definitions STRUCT_0,RLVECT_1,ALGSTR_0,CKB3,CKB4,CKB10,CKB19,CKB31,CKB39,CKB46,CKB49;
theorems FUNCT_2,TARSKI,MCART_1,BINOP_1,CARD_1,CKB3,CKB4,CKB6,CKB7,CKB8,CKB9,CKB10,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB48,CKB49,CKB50,CKB51;
schemes FUNCT_2,BINOP_1;
registrations XBOOLE_0,SUBSET_1,RELSET_1,STRUCT_0,RELAT_1,CKB1,CKB2,CKB5,CKB11,CKB40;
constructors BINOP_1,DOMAIN_1,RLVECT_1,FUNCT_5,RELSET_1,CKB1,CKB3,CKB4,CKB10,CKB13,CKB19,CKB29,CKB30,CKB31,CKB39,CKB46,CKB47,CKB49;
requirements SUBSET,BOOLE;
begin
reserve M for MidSp;
reserve d for (Element of M);
reserve p for (Element of [: (the carrier of M),(the carrier of M) :]);
reserve q for (Element of [: (the carrier of M),(the carrier of M) :]);
reserve u for (Vector of M);
reserve v for (Vector of M);
definition
let M;
let u;
let v;
func u + v -> (Vector of M)
means
:Def10: (ex p st (ex q st (((u = ( p ~ ) & v = ( q ~ )) & ( p `2 ) = ( q `1 )) & it = ( [ ( p `1 ),( q `2 ) ] ~ ))));
existence
proof
consider p such that A1: u = ( p ~ ) by CKB46:def 1;
consider q such that A2: v = ( q ~ ) by CKB46:def 1;
consider d such that A3: ( q `1 ),( q `2 ) @@ ( p `2 ),d by CKB25:1;
take ( [ ( p `1 ),d ] ~ );
take p9 = p;
take q9 = [ ( p `2 ),d ];
thus u = ( p9 ~ ) by A1;
(( q9 `1 ) = ( p `2 ) & ( q9 `2 ) = d) by MCART_1:7;
then q ## q9 by A3,CKB31:def 1;
hence v = ( q9 ~ ) by A2,CKB42:1;
thus ( p9 `2 ) = ( q9 `1 ) by MCART_1:7;
thus thesis by MCART_1:7;
end;
uniqueness by CKB51:1;
end;
