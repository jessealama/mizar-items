environ
vocabularies RELAT_2,ALTCAT_1,XBOOLE_0,MSUALG_6,FUNCTOR0,FUNCT_2,FUNCT_1,RELAT_1,CAT_1,ENS_1,PARTFUN1,ZFMISC_1,STRUCT_0,YELLOW18,SETFAM_1,PBOOLE,ALTCAT_2,TARSKI,SUBSET_1,REALSET1,FUNCOP_1,FUNCT_3,MCART_1,MSUALG_3,WELLORD1,ARYTM_0,YELLOW20;
notations TARSKI,XBOOLE_0,ZFMISC_1,RELAT_1,RELSET_1,FUNCT_1,FUNCT_2,MCART_1,BINOP_1,REALSET1,MULTOP_1,PBOOLE,STRUCT_0,FUNCT_4,PARTFUN1,FUNCOP_1,MSUALG_3,FUNCT_3,ALTCAT_1,ALTCAT_2,FUNCTOR0,FUNCTOR3,YELLOW18,CKB10,CKB14,CKB21,CKB37,CKB38,CKB39,CKB49,CKB50;
definitions TARSKI,RELAT_1,PARTFUN1,PBOOLE,MSUALG_3,ALTCAT_1,ALTCAT_2,FUNCTOR0,FUNCT_2,XBOOLE_0,BINOP_1,REALSET1,CKB10,CKB14,CKB21,CKB49,CKB50;
theorems ZFMISC_1,RELAT_1,FUNCT_1,PBOOLE,MCART_1,FUNCT_2,FUNCT_3,FUNCT_4,ALTCAT_1,ALTCAT_2,FUNCTOR3,ALTCAT_4,FUNCTOR0,FUNCTOR1,FUNCTOR2,PARTFUN1,MULTOP_1,MSUALG_3,YELLOW18,XBOOLE_0,XBOOLE_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB30,CKB34,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56,CKB57,CKB58,CKB59,CKB60,CKB61,CKB62,CKB63,CKB64,CKB65,CKB66,CKB67,CKB68;
schemes FUNCT_1,YELLOW18,CKB29,CKB31,CKB32;
registrations SUBSET_1,RELAT_1,FUNCT_1,FUNCOP_1,PBOOLE,STRUCT_0,ALTCAT_2,FUNCTOR0,FUNCTOR2,ALTCAT_4,YELLOW18,RELSET_1,CKB33,CKB35,CKB36;
constructors REALSET1,MSUALG_3,FUNCTOR3,YELLOW18,RELSET_1,CKB10,CKB14,CKB21,CKB37,CKB38,CKB39,CKB49,CKB50;
requirements SUBSET,BOOLE;
begin
theorem
(for A1,A2,A3 being category holds (for F being  contravariant (Functor of A1,A2) holds (for G being  contravariant (Functor of A2,A3) holds (for B1 being non  empty (subcategory of A1) holds (for B2 being non  empty (subcategory of A2) holds (for B3 being non  empty (subcategory of A3) holds ((B1,B2 are_anti-isomorphic_under F & B2,B3 are_anti-isomorphic_under G) implies B1,B3 are_isomorphic_under ( G * F ))))))))
proof
let A1 being category;
let A2 being category;
let A3 being category;
let F being  contravariant (Functor of A1,A2);
let G being  contravariant (Functor of A2,A3);
let B1 being non  empty (subcategory of A1);
let B2 being non  empty (subcategory of A2);
let B3 being non  empty (subcategory of A3);
assume that
B1 is (subcategory of A1)
and
B2 is (subcategory of A2);
given F1 being  contravariant (Functor of B1,B2) such that
A1: F1 is  bijective
and
A2: (for a being (object of B1) holds (for a1 being (object of A1) holds (a = a1 implies ( F1 . a ) = ( F . a1 ))))
and
A3: (for b,c being (object of B1) holds (for b1,c1 being (object of A1) holds (((<^ b,c ^> <> ( {} ) & b = b1) & c = c1) implies (for f being (Morphism of b,c) holds (for f1 being (Morphism of b1,c1) holds (f = f1 implies ( F1 . f ) = ( ( Morph-Map (F,b1,c1) ) . f1 )))))));

assume that
B2 is (subcategory of A2)
and
B3 is (subcategory of A3);
given G1 being  contravariant (Functor of B2,B3) such that
A4: G1 is  bijective
and
A5: (for a being (object of B2) holds (for a1 being (object of A2) holds (a = a1 implies ( G1 . a ) = ( G . a1 ))))
and
A6: (for b,c being (object of B2) holds (for b1,c1 being (object of A2) holds (((<^ b,c ^> <> ( {} ) & b = b1) & c = c1) implies (for f being (Morphism of b,c) holds (for f1 being (Morphism of b1,c1) holds (f = f1 implies ( G1 . f ) = ( ( Morph-Map (G,b1,c1) ) . f1 )))))));

thus (B1 is (subcategory of A1) & B3 is (subcategory of A3));
take ( G1 * F1 );
thus ( G1 * F1 ) is  bijective by A1,A4,FUNCTOR1:12;
hereby
let a being (object of B1);
let b being (object of A1);
assume a = b;
then ( G1 . ( F1 . a ) ) = ( G . ( F . b ) ) by A2,A5;
hence ( ( G1 * F1 ) . a ) = ( G . ( F . b ) ) by FUNCTOR0:33
.= ( ( G * F ) . b ) by FUNCTOR0:33;
end;
let b being (object of B1);
let c being (object of B1);
let b1 being (object of A1);
let c1 being (object of A1);
assume that
A7: <^ b,c ^> <> ( {} )
and
A8: (b = b1 & c = c1);
A9: (( ( G * F ) . b1 ) = ( G . ( F . b1 ) ) & ( ( G * F ) . c1 ) = ( G . ( F . c1 ) )) by FUNCTOR0:33;
let f being (Morphism of b,c);
let f1 being (Morphism of b1,c1);
A10: (f in <^ b,c ^> & <^ b,c ^> c= <^ b1,c1 ^>) by A7,A8,ALTCAT_2:31;
then A11: <^ ( ( G * F ) . b1 ),( ( G * F ) . c1 ) ^> <> ( {} ) by FUNCTOR0:def 18;
A12: <^ ( F1 . c ),( F1 . b ) ^> <> ( {} ) by A7,FUNCTOR0:def 19;
then A13: ( F1 . f ) in <^ ( F1 . c ),( F1 . b ) ^>;
A14: (( F1 . b ) = ( F . b1 ) & ( F1 . c ) = ( F . c1 )) by A2,A8;
then A15: <^ ( F1 . c ),( F1 . b ) ^> c= <^ ( F . c1 ),( F . b1 ) ^> by ALTCAT_2:31;
assume f = f1;
then ( F1 . f ) = ( ( Morph-Map (F,b1,c1) ) . f1 ) by A3,A7,A8
.= ( F . f1 ) by A10,A13,A15,FUNCTOR0:def 16;
then ( G1 . ( F1 . f ) ) = ( ( Morph-Map (G,( F . c1 ),( F . b1 )) ) . ( F . f1 ) ) by A6,A12,A14;
hence ( ( G1 * F1 ) . f ) = ( ( Morph-Map (G,( F . c1 ),( F . b1 )) ) . ( F . f1 ) ) by A7,FUNCTOR3:7
.= ( G . ( F . f1 ) ) by A13,A15,A11,A9,FUNCTOR0:def 16
.= ( ( G * F ) . f1 ) by A10,FUNCTOR3:7
.= ( ( Morph-Map (( G * F ),b1,c1) ) . f1 ) by A10,A11,FUNCTOR0:def 15;
end;
