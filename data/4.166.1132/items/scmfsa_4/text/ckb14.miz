environ
vocabularies NUMBERS,SUBSET_1,AMI_1,AMI_3,SCMFSA_2,AMISTD_2,CARD_1,GRAPHSP,ARYTM_3,SCMNORM,RELAT_1,FUNCT_1,FUNCT_4,XBOOLE_0,FSM_1,ARYTM_1,INT_1,COMPLEX1,PARTFUN1,FINSEQ_1,FINSEQ_2,NAT_1,COMPOS_1;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,NUMBERS,CARD_3,XXREAL_0,XCMPLX_0,MCART_1,NAT_1,NAT_D,VALUED_1,INT_1,INT_2,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,FUNCOP_1,FUNCT_7,FINSEQ_1,FINSEQ_2,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_3,SCMFSA_2,AMISTD_2,AMISTD_5;
definitions TARSKI,COMPOS_1,EXTPRO_1,AMI_3,SCMFSA_2,FUNCOP_1,RELAT_1,AMISTD_2,FUNCT_1,AMISTD_5,MEMSTR_0;
theorems SCMFSA_2,ENUMSET1,NAT_1,TARSKI,SCMFSA_3,VALUED_1,AMISTD_2,RECDEF_2,SCMFSA10,FINSEQ_1,ORDINAL1,COMPOS_1,EXTPRO_1,MEMSTR_0,CKB6,CKB7,CKB8;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,FUNCOP_1,NUMBERS,XREAL_0,INT_1,CARD_3,SCMFSA_2,FINSET_1,VALUED_1,FUNCT_4,RELAT_1,AMI_3,AMI_6,RELOC,XXREAL_0,SCMFSA10,AMISTD_2,VALUED_0,COMPOS_1,EXTPRO_1,AMISTD_5,MEMSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB9,CKB10,CKB11,CKB12,CKB13;
constructors DOMAIN_1,XXREAL_0,AMI_3,SCMFSA_2,NAT_D,RELSET_1,VALUED_1,AMISTD_2,AMISTD_5,PBOOLE,FUNCT_7,MEMSTR_0;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve k for (Element of ( NAT ));
reserve i for (Instruction of ( SCM+FSA ));
theorem
((not ( InsCode i ) in { 6,7,8 }) implies ( IncAddr (i,k) ) = i)
proof
assume (not ( InsCode i ) in { 6,7,8 });
then A1: ((( InsCode i ) <> 6 & ( InsCode i ) <> 7) & ( InsCode i ) <> 8) by ENUMSET1:def 1;
per cases  by A1,NAT_1:36,SCMFSA_2:16;
suppose ( InsCode i ) = ( 0 );

then i = ( halt ( SCM+FSA ) ) by SCMFSA_2:95;
hence thesis by COMPOS_1:11;
end;
suppose ( InsCode i ) = 1;

then consider da,db being Int-Location such that A2: i = ( da := db ) by SCMFSA_2:30;
thus thesis by A2,COMPOS_1:11;
end;
suppose ( InsCode i ) = 2;

then consider da,db being Int-Location such that A3: i = ( AddTo (da,db) ) by SCMFSA_2:31;
thus thesis by A3,COMPOS_1:11;
end;
suppose ( InsCode i ) = 3;

then consider da,db being Int-Location such that A4: i = ( SubFrom (da,db) ) by SCMFSA_2:32;
thus thesis by A4,COMPOS_1:11;
end;
suppose ( InsCode i ) = 4;

then consider da,db being Int-Location such that A5: i = ( MultBy (da,db) ) by SCMFSA_2:33;
thus thesis by A5,COMPOS_1:11;
end;
suppose ( InsCode i ) = 5;

then consider da,db being Int-Location such that A6: i = ( Divide (da,db) ) by SCMFSA_2:34;
thus thesis by A6,COMPOS_1:11;
end;
suppose ( InsCode i ) = 9;

then consider db,da being Int-Location,f being FinSeq-Location such that A7: i = ( da := (f,db) ) by SCMFSA_2:38;
thus thesis by A7,COMPOS_1:11;
end;
suppose ( InsCode i ) = 10;

then consider db,da being Int-Location,f being FinSeq-Location such that A8: i = ( (f,db) := da ) by SCMFSA_2:39;
thus thesis by A8,COMPOS_1:11;
end;
suppose ( InsCode i ) = 11;

then consider da being Int-Location,f being FinSeq-Location such that A9: i = ( da :=len f ) by SCMFSA_2:40;
thus thesis by A9,COMPOS_1:11;
end;
suppose ( InsCode i ) = 12;

then consider da being Int-Location,f being FinSeq-Location such that A10: i = ( f :=<0,...,0> da ) by SCMFSA_2:41;
thus thesis by A10,COMPOS_1:11;
end;
end;
