environ
vocabularies NUMBERS,XBOOLE_0,CARD_1,NAT_1,SUBSET_1,ARYTM_3,RELAT_1,FUNCT_1,FINSEQ_1,CIRCCOMB,FINSEQ_2,MSUALG_1,PARTFUN1,MSAFREE2,FUNCT_4,TARSKI,STRUCT_0,MARGREL1,XBOOLEAN,CIRCUIT1,FSM_1,CIRCUIT2,CARD_3,GLIB_000,LATTICES,MCART_1,FINSET_1,CLASSES1,FACIRC_1;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,NUMBERS,XCMPLX_0,MCART_1,RELAT_1,STRUCT_0,FUNCT_1,FUNCT_2,FINSEQ_1,FINSET_1,FINSEQ_2,FUNCT_4,MARGREL1,BINARITH,CARD_3,CLASSES1,PARTFUN1,MSUALG_1,MSAFREE2,CIRCUIT1,CIRCUIT2,CIRCCOMB,XXREAL_0,NAT_1,CKB1,CKB7,CKB8,CKB22;
definitions TARSKI,RELAT_1,MSAFREE2,CIRCUIT2,CIRCCOMB,XBOOLE_0,MARGREL1,CKB1,CKB7,CKB22;
theorems TARSKI,AXIOMS,ENUMSET1,MCART_1,RELAT_1,FUNCT_1,FUNCT_2,FUNCT_4,ORDINAL1,FINSEQ_1,FINSEQ_2,MSUALG_1,MSAFREE2,CIRCUIT1,CIRCUIT2,CIRCCOMB,XBOOLE_0,XBOOLE_1,CLASSES1,CARD_1,CKB1,CKB7,CKB22,CKB26,CKB30,CKB31;
schemes NAT_1,RECDEF_1,FUNCT_2;
registrations XBOOLE_0,RELAT_1,FUNCT_1,ORDINAL1,XXREAL_0,FINSEQ_1,FINSEQ_2,CARD_3,STRUCT_0,MSUALG_1,CIRCCOMB,NAT_1,XCMPLX_0,MSAFREE2,MARGREL1,FINSET_1,CARD_1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB23,CKB24,CKB25,CKB27,CKB28,CKB29;
constructors ENUMSET1,XXREAL_0,NAT_1,CLASSES1,BINARITH,CIRCUIT1,CIRCUIT2,CIRCCOMB,SEQ_1,RELSET_1,BINOP_1,WELLORD2,DOMAIN_1,CKB1,CKB7,CKB22;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
theorem
Th4: (for S1,S2 being non  empty ManySortedSign holds ((S1 tolerates S2 & ( InnerVertices S2 ) misses ( InputVertices S1 )) implies (( InputVertices S1 ) c= ( InputVertices ( S1 +* S2 ) ) & ( InputVertices ( S1 +* S2 ) ) = ( ( InputVertices S1 ) \/ ( ( InputVertices S2 ) \ ( InnerVertices S1 ) ) ))))
proof
let S1 being non  empty ManySortedSign;
let S2 being non  empty ManySortedSign;
set S = ( S1 +* S2 );
set R = (the ResultSort of S);
set R1 = (the ResultSort of S1);
set R2 = (the ResultSort of S2);
assume that
A1: S1 tolerates S2
and
A2: ( InnerVertices S2 ) misses ( InputVertices S1 );
A3: ( InnerVertices S ) = ( rng R );
(( InnerVertices S1 ) = ( rng R1 ) & ( InnerVertices S2 ) = ( rng R2 ));
then A4: ( rng R ) = ( ( rng R1 ) \/ ( rng R2 ) ) by A1,A3,CIRCCOMB:11;
A5: (the carrier of S) = ( (the carrier of S1) \/ (the carrier of S2) ) by CIRCCOMB:def 2;
hereby
let x being set;
assume A6: x in ( InputVertices S1 );
then ((not x in ( rng R1 )) & (not x in ( rng R2 ))) by A2,XBOOLE_0:3,XBOOLE_0:def 5;
then A7: (not x in ( rng R )) by A4,XBOOLE_0:def 3;
x in (the carrier of S) by A5,A6,XBOOLE_0:def 3;
hence x in ( InputVertices S ) by A7,XBOOLE_0:def 5;
end;
A8: ( InputVertices S ) c= ( ( InputVertices S1 ) \/ ( InputVertices S2 ) ) by A1,CIRCCOMB:11;
hereby
let x being set;
assume A9: x in ( InputVertices ( S1 +* S2 ) );
then (not x in ( rng R )) by XBOOLE_0:def 5;
then (x in ( InputVertices S1 ) or (x in ( InputVertices S2 ) & (not x in ( InnerVertices S1 )))) by A4,A8,A9,XBOOLE_0:def 3;
then (x in ( InputVertices S1 ) or x in ( ( InputVertices S2 ) \ ( InnerVertices S1 ) )) by XBOOLE_0:def 5;
hence x in ( ( InputVertices S1 ) \/ ( ( InputVertices S2 ) \ ( InnerVertices S1 ) ) ) by XBOOLE_0:def 3;
end;
let x being set;
assume x in ( ( InputVertices S1 ) \/ ( ( InputVertices S2 ) \ ( InnerVertices S1 ) ) );
then A10: (x in ( InputVertices S1 ) or x in ( ( InputVertices S2 ) \ ( rng R1 ) )) by XBOOLE_0:def 3;
then A11: x in (the carrier of S) by A5,XBOOLE_0:def 3;
((x in ( InputVertices S1 ) & (not x in ( rng R2 ))) or (x in ( InputVertices S2 ) & (not x in ( rng R1 )))) by A2,A10,XBOOLE_0:3,XBOOLE_0:def 5;
then A12: (not x in ( rng R2 )) by XBOOLE_0:def 5;
(not x in ( rng R1 )) by A10,XBOOLE_0:def 5;
then (not x in ( rng R )) by A4,A12,XBOOLE_0:def 3;
hence thesis by A11,XBOOLE_0:def 5;
end;
