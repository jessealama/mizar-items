environ
vocabularies FINSET_1,LATTICES,LATTICE3,XBOOLE_0,STRUCT_0,ZFMISC_1,SUBSET_1,XXREAL_0,NUMBERS,FINSEQ_1,RELAT_1,ARYTM_3,CARD_1,FUNCT_1,TARSKI,ORDERS_2,FILTER_1,EQREL_1,PBOOLE,REWRITE1,WELLORD1,WAYBEL_6,RELAT_2,ZF_LANG,BINOP_1,LATTICE6;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,XXREAL_0,RELAT_1,FUNCT_1,NAT_1,BINOP_1,FINSET_1,WELLORD1,WAYBEL_6,STRUCT_0,LATTICES,LATTICE3,ORDERS_2,FINSEQ_1,WELLFND1,YELLOW_0,LATTICE2,CKB8,CKB9,CKB12,CKB13,CKB20,CKB21,CKB29,CKB30,CKB31,CKB32,CKB46,CKB47,CKB50;
definitions WELLFND1,WELLORD1,CKB8,CKB9,CKB12,CKB13,CKB20,CKB29,CKB30,CKB31,CKB32,CKB46,CKB47,CKB50;
theorems TARSKI,FUNCT_1,LATTICES,LATTICE3,ORDERS_2,VECTSP_8,FINSEQ_1,WAYBEL_6,NAT_1,INT_1,RELAT_1,YELLOW_0,WELLORD1,WELLFND1,REALSET1,XBOOLE_0,XXREAL_0,STRUCT_0,CARD_1,ZFMISC_1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB8,CKB9,CKB11,CKB12,CKB13,CKB16,CKB17,CKB20,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50;
schemes NAT_1,WELLFND1;
registrations XBOOLE_0,RELAT_1,FUNCT_1,FINSET_1,XREAL_0,INT_1,FINSEQ_1,FINSEQ_6,STRUCT_0,LATTICES,ORDERS_2,LATTICE2,LATTICE3,WAYBEL_0,KNASTER,YELLOW_1,ORDINAL1,ZFMISC_1,CARD_1,CKB1,CKB7,CKB10,CKB14,CKB15,CKB18,CKB19;
constructors WELLORD1,BINOP_1,REAL_1,REALSET2,LATTICE2,WAYBEL_0,WAYBEL_6,WELLFND1,RELSET_1,CKB8,CKB9,CKB12,CKB13,CKB20,CKB29,CKB30,CKB31,CKB32,CKB46,CKB47,CKB50;
requirements NUMERALS,BOOLE,SUBSET,ARITHM;
begin
registration
cluster  strict 1 -element for Lattice;
existence
proof
set X = { ( {} ) };
set XJ = the (BinOp of X);
reconsider L = LattStr (# X,XJ,XJ #) as non  empty LattStr;
A1: L is  trivial;
then A2: ((for a,b being (Element of L) holds ( ( a "/\" b ) "\/" b ) = b) & (for a,b being (Element of L) holds ( a "/\" b ) = ( b "/\" a ))) by STRUCT_0:def 10;
A3: ((for a,b,c being (Element of L) holds ( a "/\" ( b "/\" c ) ) = ( ( a "/\" b ) "/\" c )) & (for a,b being (Element of L) holds ( a "/\" ( a "\/" b ) ) = a)) by A1,STRUCT_0:def 10;
((for a,b being (Element of L) holds ( a "\/" b ) = ( b "\/" a )) & (for a,b,c being (Element of L) holds ( a "\/" ( b "\/" c ) ) = ( ( a "\/" b ) "\/" c ))) by A1,STRUCT_0:def 10;
then L is  join-commutative  join-associative  meet-absorbing  meet-commutative  meet-associative  join-absorbing by A2,A3,LATTICES:def 4,LATTICES:def 5,LATTICES:def 6,LATTICES:def 7,LATTICES:def 8,LATTICES:def 9;
then reconsider L as Lattice;
take L;
thus thesis by STRUCT_0:def 19;
end;
end;
