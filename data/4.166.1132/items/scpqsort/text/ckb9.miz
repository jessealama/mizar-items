environ
vocabularies NUMBERS,SCMPDS_2,SUBSET_1,FSM_1,SCMPDS_4,AMI_1,TURING_1,SCMFSA8A,SCMFSA_7,AMI_3,INT_1,SCMFSA8B,CARD_1,ARYTM_3,FUNCT_1,XXREAL_0,UNIALG_2,SCMFSA7B,SCMFSA6B,RELAT_1,FUNCT_4,AMI_2,SCMFSA_9,ARYTM_1,VALUED_1,TARSKI,GRAPHSP,CIRCUIT2,MSUALG_1,NAT_1,FUNCOP_1,CARD_3,FINSEQ_1,GRAPH_2,SCPISORT,SCMP_GCD,CLASSES1,SCPQSORT,ORDINAL1,SCMNORM,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,FUNCT_2,SUBSET_1,CARD_1,NUMBERS,XXREAL_0,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_4,PBOOLE,VALUED_1,XCMPLX_0,RECDEF_1,INT_1,NAT_1,STRUCT_0,MEMSTR_0,EXTPRO_1,AMI_2,FUNCT_7,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,CARD_3,FINSEQ_1,SCMPDS_8,GRAPH_2,CLASSES1,COMPOS_1,SCPISORT;
definitions SCMPDS_2,SCMP_GCD,COMPOS_1,EXTPRO_1,SCPISORT,MEMSTR_0,TARSKI,FUNCT_7,XBOOLE_0,FUNCOP_1,NAT_1,AFINSQ_1,FUNCT_4;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,SCMPDS_2,FUNCT_7,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_7,SCMPDS_8,FINSEQ_1,FINSEQ_2,RFINSEQ,SCPISORT,XBOOLE_1,XREAL_1,XXREAL_0,GRAPH_2,MEMSTR_0,ORDINAL1,CLASSES1,SCMPDS_6,SCMP_GCD,INT_1,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8;
schemes NAT_1,SCMPDS_8;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,ORDINAL1,VALUED_0,VALUED_1,RELAT_1,COMPOS_1,AFINSQ_1,MEMSTR_0,EXTPRO_1,FUNCT_4,FUNCT_7,FUNCOP_1,PRE_POLY,PBOOLE,SCMPDS_3,CKB1;
constructors REAL_1,RECDEF_1,NEWTON,MESFUNC1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,CLASSES1,GRAPH_2,VALUED_1,AMI_2,SCMPDS_1,PRE_POLY,AMISTD_1,AMISTD_2,SCMPDS_7,PBOOLE,AMISTD_5,MEMSTR_0;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve x for Int_position;
reserve P for (Instruction-Sequence of ( SCMPDS ));
reserve Q for (Instruction-Sequence of ( SCMPDS ));
theorem
Th6: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (for I being  halt-free  shiftable (Program of ( SCMPDS )) holds (for a,x,y being Int_position holds (for i,c being Integer holds ((( s . x ) >= c & (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds ((((( t . x ) >= c & ( t . y ) = ( s . y )) & ( t . a ) = ( s . a )) & ( t . ( DataLoc (( s . a ),i) ) ) > ( 0 )) implies (((((( ( IExec (I,Q,t) ) . a ) = ( t . a ) & I is_closed_on t,Q) & I is_halting_on t,Q) & ( ( IExec (I,Q,t) ) . ( DataLoc (( s . a ),i) ) ) < ( t . ( DataLoc (( s . a ),i) ) )) & ( ( IExec (I,Q,t) ) . x ) >= c) & ( ( IExec (I,Q,t) ) . y ) = ( t . y )))))) implies ((( while>0 (a,i,I) ) is_closed_on s,P & ( while>0 (a,i,I) ) is_halting_on s,P) & (( s . ( DataLoc (( s . a ),i) ) ) > ( 0 ) implies ( IExec (( while>0 (a,i,I) ),P,s) ) = ( IExec (( while>0 (a,i,I) ),P,( Initialize ( IExec (I,P,s) ) )) ))))))))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
let I being  halt-free  shiftable (Program of ( SCMPDS ));
let a being Int_position;
let x being Int_position;
let y being Int_position;
let i being Integer;
let c being Integer;
set b = ( DataLoc (( s . a ),i) );
defpred P[ set ]
 means
(ex t being (State of ( SCMPDS )) st ((t = $1 & ( t . x ) >= c) & ( t . y ) = ( s . y )));
consider f being (Function of ( product (the Object-Kind of ( SCMPDS )) ),( NAT )) such that A2: (for s being (State of ( SCMPDS )) holds ((( s . b ) <= ( 0 ) implies ( f . s ) = ( 0 )) & (( s . b ) > ( 0 ) implies ( f . s ) = ( s . b )))) by SCMPDS_8:5;
deffunc F((State of ( SCMPDS ))) = ( f . $1 );
A5: (for t being ( 0 ) -started (State of ( SCMPDS )) holds ((P[ t ] & F(t) = ( 0 )) implies ( t . b ) <= ( 0 ))) by A2;
assume A6: ( s . x ) >= c;
A7: P[ s ] by A6;
assume A8: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds ((((( t . x ) >= c & ( t . y ) = ( s . y )) & ( t . a ) = ( s . a )) & ( t . b ) > ( 0 )) implies (((((( ( IExec (I,Q,t) ) . a ) = ( t . a ) & I is_closed_on t,Q) & I is_halting_on t,Q) & ( ( IExec (I,Q,t) ) . b ) < ( t . b )) & ( ( IExec (I,Q,t) ) . x ) >= c) & ( ( IExec (I,Q,t) ) . y ) = ( t . y )))));
A9:now
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
assume that
A10: P[ t ]
and
A11: ( t . a ) = ( s . a )
and
A12: ( t . b ) > ( 0 );
set It = ( IExec (I,Q,t) );
set t2 = ( Initialize It );
thus ((( ( IExec (I,Q,t) ) . a ) = ( t . a ) & I is_closed_on t,Q) & I is_halting_on t,Q) by A8,A11,A12,A10;
thus F(t2) < F(t)
proof
A15: F(t) = ( t . b ) by A2,A12
.= ( t . b );
assume A16: F(t2) >= F(t);
then ( t2 . b ) > ( 0 ) by A2,A12,A15;
then F(t2) = ( t2 . b ) by A2
.= ( It . b ) by SCMPDS_5:15;
hence contradiction by A8,A11,A12,A10,A16,A15;
end;

thus P[ ( Initialize It ) ]
proof
take v = ( Initialize It );
thus v = ( Initialize It );
( It . x ) >= c by A8,A11,A12,A10;
hence ( v . x ) >= c by SCMPDS_5:15;
( It . y ) = ( t . y ) by A8,A11,A12,A10;
hence thesis by A10,SCMPDS_5:15;
end;

end;
(( while>0 (a,i,I) ) is_closed_on s,P & ( while>0 (a,i,I) ) is_halting_on s,P) from SCMPDS_8:sch 3(A5,A7,A9);
hence (( while>0 (a,i,I) ) is_closed_on s,P & ( while>0 (a,i,I) ) is_halting_on s,P);
assume A17: ( s . b ) > ( 0 );
( IExec (( while>0 (a,i,I) ),P,s) ) = ( IExec (( while>0 (a,i,I) ),P,( Initialize ( IExec (I,P,s) ) )) ) from SCMPDS_8:sch 4(A17,A5,A7,A9);
hence thesis;
end;
