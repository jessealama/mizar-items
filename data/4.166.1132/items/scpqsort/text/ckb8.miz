environ
vocabularies NUMBERS,SCMPDS_2,SUBSET_1,FSM_1,SCMPDS_4,AMI_1,TURING_1,SCMFSA8A,SCMFSA_7,AMI_3,INT_1,SCMFSA8B,CARD_1,ARYTM_3,FUNCT_1,XXREAL_0,UNIALG_2,SCMFSA7B,SCMFSA6B,RELAT_1,FUNCT_4,AMI_2,SCMFSA_9,ARYTM_1,VALUED_1,TARSKI,GRAPHSP,CIRCUIT2,MSUALG_1,NAT_1,FUNCOP_1,CARD_3,FINSEQ_1,GRAPH_2,SCPISORT,SCMP_GCD,CLASSES1,SCPQSORT,ORDINAL1,SCMNORM,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,FUNCT_2,SUBSET_1,CARD_1,NUMBERS,XXREAL_0,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_4,PBOOLE,VALUED_1,XCMPLX_0,RECDEF_1,INT_1,NAT_1,STRUCT_0,MEMSTR_0,EXTPRO_1,AMI_2,FUNCT_7,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,CARD_3,FINSEQ_1,SCMPDS_8,GRAPH_2,CLASSES1,COMPOS_1,SCPISORT;
definitions SCMPDS_2,SCMP_GCD,COMPOS_1,EXTPRO_1,SCPISORT,MEMSTR_0,TARSKI,FUNCT_7,XBOOLE_0,FUNCOP_1,NAT_1,AFINSQ_1,FUNCT_4;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,SCMPDS_2,FUNCT_7,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_7,SCMPDS_8,FINSEQ_1,FINSEQ_2,RFINSEQ,SCPISORT,XBOOLE_1,XREAL_1,XXREAL_0,GRAPH_2,MEMSTR_0,ORDINAL1,CLASSES1,SCMPDS_6,SCMP_GCD,INT_1,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7;
schemes NAT_1,SCMPDS_8;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,ORDINAL1,VALUED_0,VALUED_1,RELAT_1,COMPOS_1,AFINSQ_1,MEMSTR_0,EXTPRO_1,FUNCT_4,FUNCT_7,FUNCOP_1,PRE_POLY,PBOOLE,SCMPDS_3,CKB1;
constructors REAL_1,RECDEF_1,NEWTON,MESFUNC1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,CLASSES1,GRAPH_2,VALUED_1,AMI_2,SCMPDS_1,PRE_POLY,AMISTD_1,AMISTD_2,SCMPDS_7,PBOOLE,AMISTD_5,MEMSTR_0;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve x for Int_position;
reserve P for (Instruction-Sequence of ( SCMPDS ));
reserve Q for (Instruction-Sequence of ( SCMPDS ));
theorem
Th5: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (for I being  halt-free  shiftable (Program of ( SCMPDS )) holds (for a,x,y being Int_position holds (for i,c being Integer holds ((( s . x ) >= ( c + ( s . ( DataLoc (( s . a ),i) ) ) ) & (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds ((((( t . x ) >= ( c + ( t . ( DataLoc (( s . a ),i) ) ) ) & ( t . y ) = ( s . y )) & ( t . a ) = ( s . a )) & ( t . ( DataLoc (( s . a ),i) ) ) > ( 0 )) implies (((((( ( IExec (I,Q,t) ) . a ) = ( t . a ) & I is_closed_on t,Q) & I is_halting_on t,Q) & ( ( IExec (I,Q,t) ) . ( DataLoc (( s . a ),i) ) ) < ( t . ( DataLoc (( s . a ),i) ) )) & ( ( IExec (I,Q,t) ) . x ) >= ( c + ( ( IExec (I,Q,t) ) . ( DataLoc (( s . a ),i) ) ) )) & ( ( IExec (I,Q,t) ) . y ) = ( t . y )))))) implies ((( while>0 (a,i,I) ) is_closed_on s,P & ( while>0 (a,i,I) ) is_halting_on s,P) & (( s . ( DataLoc (( s . a ),i) ) ) > ( 0 ) implies ( IExec (( while>0 (a,i,I) ),P,s) ) = ( IExec (( while>0 (a,i,I) ),P,( Initialize ( IExec (I,P,s) ) )) ))))))))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
let I being  halt-free  shiftable (Program of ( SCMPDS ));
let a being Int_position;
let x1 being Int_position;
let y1 being Int_position;
let i being Integer;
let c being Integer;
set b = ( DataLoc (( s . a ),i) );
assume ( s . x1 ) >= ( c + ( s . b ) );
then A2: (for x holds (x in { x1 } implies ( s . x ) >= ( c + ( s . b ) ))) by TARSKI:def 1;
assume A3: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds ((((( t . x1 ) >= ( c + ( t . b ) ) & ( t . y1 ) = ( s . y1 )) & ( t . a ) = ( s . a )) & ( t . b ) > ( 0 )) implies (((((( ( IExec (I,Q,t) ) . a ) = ( t . a ) & I is_closed_on t,Q) & I is_halting_on t,Q) & ( ( IExec (I,Q,t) ) . b ) < ( t . b )) & ( ( IExec (I,Q,t) ) . x1 ) >= ( c + ( ( IExec (I,Q,t) ) . b ) )) & ( ( IExec (I,Q,t) ) . y1 ) = ( t . y1 )))));
now
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
assume that
A4: (for x holds (x in { x1 } implies ( t . x ) >= ( c + ( t . b ) )))
and
A5: (for x holds (x in { y1 } implies ( t . x ) = ( s . x )))
and
A6: ( t . a ) = ( s . a )
and
A7: ( t . b ) > ( 0 );
y1 in { y1 } by TARSKI:def 1;
then A8: ( t . y1 ) = ( s . y1 ) by A5;
x1 in { x1 } by TARSKI:def 1;
then A9: ( t . x1 ) >= ( c + ( t . b ) ) by A4;
hence (((( ( IExec (I,Q,t) ) . a ) = ( t . a ) & I is_closed_on t,Q) & I is_halting_on t,Q) & ( ( IExec (I,Q,t) ) . b ) < ( t . b )) by A3,A6,A7,A8;
hereby
let x;
assume A10: x in { x1 };
( ( IExec (I,Q,t) ) . x1 ) >= ( c + ( ( IExec (I,Q,t) ) . b ) ) by A3,A6,A7,A9,A8;
hence ( ( IExec (I,Q,t) ) . x ) >= ( c + ( ( IExec (I,Q,t) ) . b ) ) by A10,TARSKI:def 1;
end;
let x;
assume A11: x in { y1 };
hence ( ( IExec (I,Q,t) ) . x ) = ( ( IExec (I,Q,t) ) . y1 ) by TARSKI:def 1
.= ( t . y1 ) by A3,A6,A7,A9,A8
.= ( t . x ) by A11,TARSKI:def 1;
end;
hence thesis by A2,SCMPDS_8:27;
end;
