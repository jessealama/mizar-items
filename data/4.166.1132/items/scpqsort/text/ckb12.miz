environ
vocabularies NUMBERS,SCMPDS_2,SUBSET_1,FSM_1,SCMPDS_4,AMI_1,TURING_1,SCMFSA8A,SCMFSA_7,AMI_3,INT_1,SCMFSA8B,CARD_1,ARYTM_3,FUNCT_1,XXREAL_0,UNIALG_2,SCMFSA7B,SCMFSA6B,RELAT_1,FUNCT_4,AMI_2,SCMFSA_9,ARYTM_1,VALUED_1,TARSKI,GRAPHSP,CIRCUIT2,MSUALG_1,NAT_1,FUNCOP_1,CARD_3,FINSEQ_1,GRAPH_2,SCPISORT,SCMP_GCD,CLASSES1,SCPQSORT,ORDINAL1,SCMNORM,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,FUNCT_2,SUBSET_1,CARD_1,NUMBERS,XXREAL_0,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_4,PBOOLE,VALUED_1,XCMPLX_0,RECDEF_1,INT_1,NAT_1,STRUCT_0,MEMSTR_0,EXTPRO_1,AMI_2,FUNCT_7,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,CARD_3,FINSEQ_1,SCMPDS_8,GRAPH_2,CLASSES1,COMPOS_1,SCPISORT;
definitions SCMPDS_2,SCMP_GCD,COMPOS_1,EXTPRO_1,SCPISORT,MEMSTR_0,TARSKI,FUNCT_7,XBOOLE_0,FUNCOP_1,NAT_1,AFINSQ_1,FUNCT_4;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,SCMPDS_2,FUNCT_7,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_7,SCMPDS_8,FINSEQ_1,FINSEQ_2,RFINSEQ,SCPISORT,XBOOLE_1,XREAL_1,XXREAL_0,GRAPH_2,MEMSTR_0,ORDINAL1,CLASSES1,SCMPDS_6,SCMP_GCD,INT_1,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11;
schemes NAT_1,SCMPDS_8;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,ORDINAL1,VALUED_0,VALUED_1,RELAT_1,COMPOS_1,AFINSQ_1,MEMSTR_0,EXTPRO_1,FUNCT_4,FUNCT_7,FUNCOP_1,PRE_POLY,PBOOLE,SCMPDS_3,CKB1;
constructors REAL_1,RECDEF_1,NEWTON,MESFUNC1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,CLASSES1,GRAPH_2,VALUED_1,AMI_2,SCMPDS_1,PRE_POLY,AMISTD_1,AMISTD_2,SCMPDS_7,PBOOLE,AMISTD_5,MEMSTR_0;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve n for (Element of ( NAT ));
reserve P for (Instruction-Sequence of ( SCMPDS ));
reserve Q for (Instruction-Sequence of ( SCMPDS ));
theorem
Lm4: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (for I being  halt-free  shiftable (Program of ( SCMPDS )) holds (for a being Int_position holds (for i,c being Integer holds (for f,g being (FinSequence of ( INT )) holds (for m,n,m1 being (Element of ( NAT )) holds ((((((((((( s . a ) = c & ( len f ) = n) & ( len g ) = n) & f is_FinSequence_on s,m) & g is_FinSequence_on ( IExec (( while>0 (a,i,I) ),P,s) ),m) & 1 = ( s . ( DataLoc (c,i) ) )) & m1 = ( ( m + n ) + 1 )) & ( m + 1 ) = ( s . ( intpos m1 ) )) & ( m + n ) = ( s . ( intpos ( m1 + 1 ) ) )) & (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (for f1,f2 being (FinSequence of ( INT )) holds (for k1,k2,y1,yn being (Element of ( NAT )) holds ((((((( t . a ) = c & ( ( 2 * k1 ) + 1 ) = ( t . ( DataLoc (c,i) ) )) & k2 = ( ( ( m + n ) + ( 2 * k1 ) ) + 1 )) & ( m + y1 ) = ( t . ( intpos k2 ) )) & ( m + yn ) = ( t . ( intpos ( k2 + 1 ) ) )) & ((1 <= y1 & yn <= n) or y1 >= yn)) implies ((((((I is_closed_on t,Q & I is_halting_on t,Q) & ( ( IExec (I,Q,t) ) . a ) = ( t . a )) & (for j being (Element of ( NAT )) holds ((1 <= j & j < ( ( 2 * k1 ) + 1 )) implies ( ( IExec (I,Q,t) ) . ( intpos ( ( m + n ) + j ) ) ) = ( t . ( intpos ( ( m + n ) + j ) ) )))) & (y1 >= yn implies (( ( IExec (I,Q,t) ) . ( DataLoc (c,i) ) ) = ( ( 2 * k1 ) - 1 ) & (for j being (Element of ( NAT )) holds ((1 <= j & j <= n) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) = ( t . ( intpos ( m + j ) ) )))))) & (y1 < yn implies ((( ( IExec (I,Q,t) ) . ( DataLoc (c,i) ) ) = ( ( 2 * k1 ) + 3 ) & (for j being (Element of ( NAT )) holds (((1 <= j & j < y1) or (yn < j & j <= n)) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) = ( t . ( intpos ( m + j ) ) )))) & (ex ym being (Element of ( NAT )) st (((((((y1 <= ym & ym <= yn) & ( m + y1 ) = ( ( IExec (I,Q,t) ) . ( intpos k2 ) )) & ( ( m + ym ) - 1 ) = ( ( IExec (I,Q,t) ) . ( intpos ( k2 + 1 ) ) )) & ( ( m + ym ) + 1 ) = ( ( IExec (I,Q,t) ) . ( intpos ( k2 + 2 ) ) )) & ( m + yn ) = ( ( IExec (I,Q,t) ) . ( intpos ( k2 + 3 ) ) )) & (for j being (Element of ( NAT )) holds ((y1 <= j & j < ym) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) <= ( ( IExec (I,Q,t) ) . ( intpos ( m + ym ) ) )))) & (for j being (Element of ( NAT )) holds ((ym < j & j <= yn) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) >= ( ( IExec (I,Q,t) ) . ( intpos ( m + ym ) ) )))))))) & ((((f1 is_FinSequence_on t,m & f2 is_FinSequence_on ( IExec (I,Q,t) ),m) & ( len f1 ) = n) & ( len f2 ) = n) implies f1,f2 are_fiberwise_equipotent )))))))) implies ((( while>0 (a,i,I) ) is_halting_on s,P & f,g are_fiberwise_equipotent ) & g is_non_decreasing_on 1,n))))))))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
let I being  halt-free  shiftable (Program of ( SCMPDS ));
let a being Int_position;
let i being Integer;
let c being Integer;
let f being (FinSequence of ( INT ));
let g being (FinSequence of ( INT ));
let m being (Element of ( NAT ));
let n being (Element of ( NAT ));
let m1 being (Element of ( NAT ));
I: ( Initialize s ) = s by MEMSTR_0:44;
set b = ( DataLoc (c,i) );
assume that
A2: ( s . a ) = c
and
A3: ( len f ) = n
and
A4: ( len g ) = n;
set WH = ( while>0 (a,i,I) );
set sWH = ( stop WH );
assume A5: f is_FinSequence_on s,m;
defpred P[ (Element of ( NAT )) ]
 means
(for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (for f1 being (FinSequence of ( INT )) holds (for k1,k2,y1,yn being (Element of ( NAT )) holds (((((((((( t . a ) = c & ( ( 2 * k1 ) + 1 ) = ( t . b )) & k2 = ( ( ( m + n ) + ( 2 * k1 ) ) + 1 )) & ((1 <= y1 & yn <= n) or y1 >= yn)) & ( m + y1 ) = ( t . ( intpos k2 ) )) & ( m + yn ) = ( t . ( intpos ( k2 + 1 ) ) )) & ( yn - y1 ) <= $1) & f1 is_FinSequence_on t,m) & ( len f1 ) = n) implies (ex k being (Element of ( NAT )) st (ex f2 being (FinSequence of ( INT )) st (((((((((( Initialize ( Comput (( Q +* sWH ),t,k) ) ) = ( Comput (( Q +* sWH ),t,k) ) & f2 is_FinSequence_on ( Comput (( Q +* sWH ),t,k) ),m) & ( len f2 ) = n) & f1,f2 are_fiberwise_equipotent ) & f2 is_non_decreasing_on y1,yn) & (for j being (Element of ( NAT )) holds ((y1 < yn & ((1 <= j & j < y1) or (yn < j & j <= n))) implies ( f2 . j ) = ( t . ( intpos ( m + j ) ) )))) & (for j being (Element of ( NAT )) holds (((y1 >= yn & 1 <= j) & j <= n) implies ( f2 . j ) = ( t . ( intpos ( m + j ) ) )))) & (for j being (Element of ( NAT )) holds ((1 <= j & j < ( ( 2 * k1 ) + 1 )) implies ( ( Comput (( Q +* sWH ),t,k) ) . ( intpos ( ( m + n ) + j ) ) ) = ( t . ( intpos ( ( m + n ) + j ) ) )))) & ( ( Comput (( Q +* sWH ),t,k) ) . b ) = ( ( t . b ) - 2 )) & ( ( Comput (( Q +* sWH ),t,k) ) . a ) = c))))))));
assume A6: g is_FinSequence_on ( IExec (( while>0 (a,i,I) ),P,s) ),m;
assume A7: 1 = ( s . b );
assume that
A8: m1 = ( ( m + n ) + 1 )
and
A9: ( m + 1 ) = ( s . ( intpos m1 ) )
and
A10: ( m + n ) = ( s . ( intpos ( m1 + 1 ) ) );
A11: m1 = ( ( ( m + n ) + ( 2 * ( 0 ) ) ) + 1 ) by A8;
assume A12: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (for f1,f2 being (FinSequence of ( INT )) holds (for k1,k2,y1,yn being (Element of ( NAT )) holds ((((((( t . a ) = c & ( ( 2 * k1 ) + 1 ) = ( t . b )) & k2 = ( ( ( m + n ) + ( 2 * k1 ) ) + 1 )) & ( m + y1 ) = ( t . ( intpos k2 ) )) & ( m + yn ) = ( t . ( intpos ( k2 + 1 ) ) )) & ((1 <= y1 & yn <= n) or y1 >= yn)) implies ((((((I is_closed_on t,Q & I is_halting_on t,Q) & ( ( IExec (I,Q,t) ) . a ) = ( t . a )) & (for j being (Element of ( NAT )) holds ((1 <= j & j < ( ( 2 * k1 ) + 1 )) implies ( ( IExec (I,Q,t) ) . ( intpos ( ( m + n ) + j ) ) ) = ( t . ( intpos ( ( m + n ) + j ) ) )))) & (y1 >= yn implies (( ( IExec (I,Q,t) ) . b ) = ( ( 2 * k1 ) - 1 ) & (for j being (Element of ( NAT )) holds ((1 <= j & j <= n) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) = ( t . ( intpos ( m + j ) ) )))))) & (y1 < yn implies ((( ( IExec (I,Q,t) ) . b ) = ( ( 2 * k1 ) + 3 ) & (for j being (Element of ( NAT )) holds (((1 <= j & j < y1) or (yn < j & j <= n)) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) = ( t . ( intpos ( m + j ) ) )))) & (ex ym being (Element of ( NAT )) st (((((((y1 <= ym & ym <= yn) & ( m + y1 ) = ( ( IExec (I,Q,t) ) . ( intpos k2 ) )) & ( ( m + ym ) - 1 ) = ( ( IExec (I,Q,t) ) . ( intpos ( k2 + 1 ) ) )) & ( ( m + ym ) + 1 ) = ( ( IExec (I,Q,t) ) . ( intpos ( k2 + 2 ) ) )) & ( m + yn ) = ( ( IExec (I,Q,t) ) . ( intpos ( k2 + 3 ) ) )) & (for j being (Element of ( NAT )) holds ((y1 <= j & j < ym) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) <= ( ( IExec (I,Q,t) ) . ( intpos ( m + ym ) ) )))) & (for j being (Element of ( NAT )) holds ((ym < j & j <= yn) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) >= ( ( IExec (I,Q,t) ) . ( intpos ( m + ym ) ) )))))))) & ((((f1 is_FinSequence_on t,m & f2 is_FinSequence_on ( IExec (I,Q,t) ),m) & ( len f1 ) = n) & ( len f2 ) = n) implies f1,f2 are_fiberwise_equipotent )))))));
A13: P[ ( 0 ) ]
proof
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
let f1 being (FinSequence of ( INT ));
let k1 being (Element of ( NAT ));
let k2 being (Element of ( NAT ));
let y1 being (Element of ( NAT ));
let yn being (Element of ( NAT ));
T: ( Initialize t ) = t by MEMSTR_0:44;
assume that
A14: ( t . a ) = c
and
A15: ( ( 2 * k1 ) + 1 ) = ( t . b )
and
A16: k2 = ( ( ( m + n ) + ( 2 * k1 ) ) + 1 )
and
A17: ((1 <= y1 & yn <= n) or y1 >= yn)
and
A18: ( m + y1 ) = ( t . ( intpos k2 ) )
and
A19: ( m + yn ) = ( t . ( intpos ( k2 + 1 ) ) )
and
A20: ( yn - y1 ) <= ( 0 )
and
A21: f1 is_FinSequence_on t,m
and
A22: ( len f1 ) = n;
A23: I is_halting_on t,Q by A12,A14,A15,A16,A17,A18,A19;
take k = ( ( LifeSpan (( Q +* ( stop I ) ),t) ) + 2 );
set tk = ( Comput (( Q +* sWH ),t,k) );
A24: I is_closed_on t,Q by A12,A14,A15,A16,A17,A18,A19;
then A25: ( DataPart tk ) = ( DataPart ( IExec (I,Q,t) ) ) by A14,A15,A23,CKB5:1,T;
consider f2 being (FinSequence of ( INT )) such that A26: ( len f2 ) = n and A27: (for i being (Element of ( NAT )) holds ((1 <= i & i <= ( len f2 )) implies ( f2 . i ) = ( ( IExec (I,Q,t) ) . ( intpos ( m + i ) ) ))) by SCPISORT:1;
take f2;
thus ( Initialize tk ) = tk by A14,A15,A24,A23,CKB5:1,T;
now
let i being (Element of ( NAT ));
assume that
A28: 1 <= i
and
A29: i <= ( len f2 );
thus ( f2 . i ) = ( ( IExec (I,Q,t) ) . ( intpos ( m + i ) ) ) by A27,A28,A29
.= ( tk . ( intpos ( m + i ) ) ) by A25,SCMPDS_4:8;
end;
hence f2 is_FinSequence_on tk,m by SCPISORT:def 1;
thus ( len f2 ) = n by A26;
f2 is_FinSequence_on ( IExec (I,Q,t) ),m by A27,SCPISORT:def 1;
hence f1,f2 are_fiberwise_equipotent  by A12,A14,A15,A16,A17,A18,A19,A21,A22,A26;
thus f2 is_non_decreasing_on y1,yn by A20,GRAPH_2:63,XREAL_1:50;
thus (for j being (Element of ( NAT )) holds ((y1 < yn & ((1 <= j & j < y1) or (yn < j & j <= n))) implies ( f2 . j ) = ( t . ( intpos ( m + j ) ) ))) by A20,XREAL_1:50;
hereby
let j being (Element of ( NAT ));
assume that
A30: y1 >= yn
and
A31: 1 <= j
and
A32: j <= n;
thus ( f2 . j ) = ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) by A26,A27,A31,A32
.= ( t . ( intpos ( m + j ) ) ) by A12,A14,A15,A16,A18,A19,A30,A31,A32;
end;
hereby
let j being (Element of ( NAT ));
assume that
A33: 1 <= j
and
A34: j < ( ( 2 * k1 ) + 1 );
thus ( tk . ( intpos ( ( m + n ) + j ) ) ) = ( ( IExec (I,Q,t) ) . ( intpos ( ( m + n ) + j ) ) ) by A25,SCMPDS_4:8
.= ( t . ( intpos ( ( m + n ) + j ) ) ) by A12,A14,A15,A16,A17,A18,A19,A33,A34;
end;
(y1 >= yn implies (( ( IExec (I,Q,t) ) . b ) = ( ( 2 * k1 ) - 1 ) & (for j being (Element of ( NAT )) holds ((1 <= j & j <= n) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) = ( t . ( intpos ( m + j ) ) ))))) by A12,A14,A15,A16,A18,A19;
hence ( tk . b ) = ( ( t . b ) - 2 ) by A15,A20,A25,SCMPDS_4:8,XREAL_1:50;
( ( IExec (I,Q,t) ) . a ) = ( t . a ) by A12,A14,A15,A16,A17,A18,A19;
hence thesis by A14,A25,SCMPDS_4:8;
end;
A35:now
let k being (Element of ( NAT ));
assume A36: P[ k ];
P[ ( k + 1 ) ]
proof
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
let f1 being (FinSequence of ( INT ));
let k1 being (Element of ( NAT ));
let k2 being (Element of ( NAT ));
let y1 being (Element of ( NAT ));
let yn being (Element of ( NAT ));
T: ( Initialize t ) = t by MEMSTR_0:44;
assume that
A37: ( t . a ) = c
and
A38: ( ( 2 * k1 ) + 1 ) = ( t . b )
and
A39: k2 = ( ( ( m + n ) + ( 2 * k1 ) ) + 1 )
and
A40: ((1 <= y1 & yn <= n) or y1 >= yn)
and
A41: ( m + y1 ) = ( t . ( intpos k2 ) )
and
A42: ( m + yn ) = ( t . ( intpos ( k2 + 1 ) ) )
and
A43: ( yn - y1 ) <= ( k + 1 )
and
A44: f1 is_FinSequence_on t,m
and
A45: ( len f1 ) = n;
per cases ;
suppose ( yn - y1 ) <= ( 0 );

hence (ex kk being (Element of ( NAT )) st (ex f2 being (FinSequence of ( INT )) st (((((((((( Initialize ( Comput (( Q +* sWH ),t,kk) ) ) = ( Comput (( Q +* sWH ),t,kk) ) & f2 is_FinSequence_on ( Comput (( Q +* sWH ),t,kk) ),m) & ( len f2 ) = n) & f1,f2 are_fiberwise_equipotent ) & f2 is_non_decreasing_on y1,yn) & (for j being (Element of ( NAT )) holds ((y1 < yn & ((1 <= j & j < y1) or (yn < j & j <= n))) implies ( f2 . j ) = ( t . ( intpos ( m + j ) ) )))) & (for j being (Element of ( NAT )) holds (((y1 >= yn & 1 <= j) & j <= n) implies ( f2 . j ) = ( t . ( intpos ( m + j ) ) )))) & (for j being (Element of ( NAT )) holds ((1 <= j & j < ( ( 2 * k1 ) + 1 )) implies ( ( Comput (( Q +* sWH ),t,kk) ) . ( intpos ( ( m + n ) + j ) ) ) = ( t . ( intpos ( ( m + n ) + j ) ) )))) & ( ( Comput (( Q +* sWH ),t,kk) ) . b ) = ( ( t . b ) - 2 )) & ( ( Comput (( Q +* sWH ),t,kk) ) . a ) = c))) by A13,A37,A38,A39,A40,A41,A42,A44,A45;
end;
suppose A46: ( yn - y1 ) > ( 0 );

set m1 = ( ( LifeSpan (( Q +* ( stop I ) ),t) ) + 2 );
set t1 = ( Comput (( Q +* sWH ),t,m1) );
set Q1 = ( Q +* sWH );
A47: I is_halting_on t,Q by A12,A37,A38,A39,A40,A41,A42;
( y1 - 1 ) >= ( 0 ) by A40,A46,XREAL_1:47,XREAL_1:48;
then reconsider y0 = ( y1 - 1 ) as (Element of ( NAT )) by INT_1:3;
set jj = ( ( 2 * k1 ) + 1 );
A48: ( ( yn - y1 ) - 1 ) <= ( ( k + 1 ) - 1 ) by A43,XREAL_1:9;
A49: yn <= ( y1 + ( k + 1 ) ) by A43,XREAL_1:20;
consider f2 being (FinSequence of ( INT )) such that A50: ( len f2 ) = n and A51: (for i being (Element of ( NAT )) holds ((1 <= i & i <= ( len f2 )) implies ( f2 . i ) = ( t1 . ( intpos ( m + i ) ) ))) by SCPISORT:1;
set It = ( IExec (I,Q,t) );
A53: (y1 < yn implies ((( It . b ) = ( ( 2 * k1 ) + 3 ) & (for j being (Element of ( NAT )) holds (((1 <= j & j < y1) or (yn < j & j <= n)) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) = ( t . ( intpos ( m + j ) ) )))) & (ex ym being (Element of ( NAT )) st (((((((y1 <= ym & ym <= yn) & ( m + y1 ) = ( It . ( intpos k2 ) )) & ( ( m + ym ) - 1 ) = ( It . ( intpos ( k2 + 1 ) ) )) & ( ( m + ym ) + 1 ) = ( It . ( intpos ( k2 + 2 ) ) )) & ( m + yn ) = ( It . ( intpos ( k2 + 3 ) ) )) & (for j being (Element of ( NAT )) holds ((y1 <= j & j < ym) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) <= ( ( IExec (I,Q,t) ) . ( intpos ( m + ym ) ) )))) & (for j being (Element of ( NAT )) holds ((ym < j & j <= yn) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) >= ( ( IExec (I,Q,t) ) . ( intpos ( m + ym ) ) ))))))) by A12,A37,A38,A39,A40,A41,A42;
then consider ym being (Element of ( NAT )) such that A54: y1 <= ym and A55: ym <= yn and A56: ( m + y1 ) = ( It . ( intpos k2 ) ) and A57: ( ( m + ym ) - 1 ) = ( It . ( intpos ( k2 + 1 ) ) ) and A58: ( ( m + ym ) + 1 ) = ( It . ( intpos ( k2 + 2 ) ) ) and A59: ( m + yn ) = ( It . ( intpos ( k2 + 3 ) ) ) and A60: (for j being (Element of ( NAT )) holds ((y1 <= j & j < ym) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) <= ( ( IExec (I,Q,t) ) . ( intpos ( m + ym ) ) ))) and A61: (for j being (Element of ( NAT )) holds ((ym < j & j <= yn) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) >= ( ( IExec (I,Q,t) ) . ( intpos ( m + ym ) ) ))) by A46,XREAL_1:47;
A62: I is_closed_on t,Q by A12,A37,A38,A39,A40,A41,A42;
then A63: ( DataPart t1 ) = ( DataPart ( IExec (I,Q,t) ) ) by A37,A38,A47,CKB5:1,T;
then A64: ( t1 . b ) = ( ( 2 * k1 ) + 3 ) by A46,A53,SCMPDS_4:8,XREAL_1:47;
A65: ym >= 1 by A40,A46,A54,XREAL_1:47,XXREAL_0:2;
then reconsider yc = ( ym - 1 ) as (Element of ( NAT )) by INT_1:3,XREAL_1:48;
A66: yc <= yn by A55,XREAL_1:146,XXREAL_0:2;
then A67: yc <= n by A40,A46,XREAL_1:47,XXREAL_0:2;
A68: ( t1 . b ) = ( ( 2 * ( k1 + 1 ) ) + 1 ) by A46,A53,A63,SCMPDS_4:8,XREAL_1:47;
( ( IExec (I,Q,t) ) . a ) = ( t . a ) by A12,A37,A38,A39,A40,A41,A42;
then A69: ( t1 . a ) = c by A37,A63,SCMPDS_4:8;
set k3 = ( ( ( m + n ) + ( 2 * ( k1 + 1 ) ) ) + 1 );
set yd = ( ym + 1 );
A70: yd > ym by XREAL_1:29;
then A71: yd >= y1 by A54,XXREAL_0:2;
then A72: yd >= 1 by A40,A46,XREAL_1:47,XXREAL_0:2;
A73: ( t1 . ( intpos ( k3 + 1 ) ) ) = ( m + yn ) by A39,A63,A59,SCMPDS_4:8;
( ym + ( 1 + k ) ) >= ( y1 + ( 1 + k ) ) by A54,XREAL_1:6;
then yn <= ( yd + k ) by A49,XXREAL_0:2;
then A74: ( yn - yd ) <= k by XREAL_1:20;
AA: ( t1 . ( intpos k3 ) ) = ( m + yd ) by A39,A63,A58,SCMPDS_4:8;
X1: ( ( Initialize t1 ) . a ) = ( t1 . a ) by SCMPDS_5:15;
X2: ( ( Initialize t1 ) . b ) = ( t1 . b ) by SCMPDS_5:15;
X3: ( ( Initialize t1 ) . ( intpos k3 ) ) = ( t1 . ( intpos k3 ) ) by SCMPDS_5:15;
X4: ( ( Initialize t1 ) . ( intpos ( k3 + 1 ) ) ) = ( t1 . ( intpos ( k3 + 1 ) ) ) by SCMPDS_5:15;
f2 is_FinSequence_on ( Initialize t1 ),m
proof
let i being (Element of ( NAT ));
assume (1 <= i & i <= ( len f2 ));
then ( f2 . i ) = ( t1 . ( intpos ( m + i ) ) ) by A51;
hence thesis by SCMPDS_5:15;
end;
then consider kl being (Element of ( NAT )),f3 being (FinSequence of ( INT )) such that W1: ( Initialize ( Comput (( Q1 +* sWH ),( Initialize t1 ),kl) ) ) = ( Comput (( Q1 +* sWH ),( Initialize t1 ),kl) ) and W2: f3 is_FinSequence_on ( Comput (( Q1 +* sWH ),( Initialize t1 ),kl) ),m and W3: ( len f3 ) = n and W4: f2,f3 are_fiberwise_equipotent  and W5: f3 is_non_decreasing_on yd,yn and W6: (for j being (Element of ( NAT )) holds ((yd < yn & ((1 <= j & j < yd) or (yn < j & j <= n))) implies ( f3 . j ) = ( ( Initialize t1 ) . ( intpos ( m + j ) ) ))) and W7: (for j being (Element of ( NAT )) holds (((yd >= yn & 1 <= j) & j <= n) implies ( f3 . j ) = ( ( Initialize t1 ) . ( intpos ( m + j ) ) ))) and W8: (for j being (Element of ( NAT )) holds ((1 <= j & j < ( ( 2 * ( k1 + 1 ) ) + 1 )) implies ( ( Comput (( Q1 +* sWH ),( Initialize t1 ),kl) ) . ( intpos ( ( m + n ) + j ) ) ) = ( ( Initialize t1 ) . ( intpos ( ( m + n ) + j ) ) ))) and W9: ( ( Comput (( Q1 +* sWH ),( Initialize t1 ),kl) ) . b ) = ( ( ( Initialize t1 ) . b ) - 2 ) and W10: ( ( Comput (( Q1 +* sWH ),( Initialize t1 ),kl) ) . a ) = c by A36,A72,A74,A50,A40,A46,A69,X1,A68,X2,AA,X3,A73,X4,XREAL_1:47;
A75: ( Initialize ( Comput (( Q1 +* sWH ),( Initialize t1 ),kl) ) ) = ( Comput (( Q1 +* sWH ),( Initialize t1 ),kl) ) by W1;
A76: f3 is_FinSequence_on ( Comput (( Q1 +* sWH ),( Initialize t1 ),kl) ),m by W2;
A77: ( len f3 ) = n by W3;
A78: f2,f3 are_fiberwise_equipotent  by W4;
A79: f3 is_non_decreasing_on yd,yn by W5;
A80: (for j being (Element of ( NAT )) holds ((yd < yn & ((1 <= j & j < yd) or (yn < j & j <= n))) implies ( f3 . j ) = ( t1 . ( intpos ( m + j ) ) )))
proof
let j being (Element of ( NAT ));
assume (yd < yn & ((1 <= j & j < yd) or (yn < j & j <= n)));
then ( f3 . j ) = ( ( Initialize t1 ) . ( intpos ( m + j ) ) ) by W6;
hence thesis by SCMPDS_5:15;
end;
A81: (for j being (Element of ( NAT )) holds (((yd >= yn & 1 <= j) & j <= n) implies ( f3 . j ) = ( t1 . ( intpos ( m + j ) ) )))
proof
let j being (Element of ( NAT ));
assume ((yd >= yn & 1 <= j) & j <= n);
then ( f3 . j ) = ( ( Initialize t1 ) . ( intpos ( m + j ) ) ) by W7;
hence thesis by SCMPDS_5:15;
end;
A82: (for j being (Element of ( NAT )) holds ((1 <= j & j < ( ( 2 * ( k1 + 1 ) ) + 1 )) implies ( ( Comput (( Q1 +* sWH ),( Initialize t1 ),kl) ) . ( intpos ( ( m + n ) + j ) ) ) = ( t1 . ( intpos ( ( m + n ) + j ) ) )))
proof
let j being (Element of ( NAT ));
assume (1 <= j & j < ( ( 2 * ( k1 + 1 ) ) + 1 ));
then ( ( Comput (( Q1 +* sWH ),( Initialize t1 ),kl) ) . ( intpos ( ( m + n ) + j ) ) ) = ( ( Initialize t1 ) . ( intpos ( ( m + n ) + j ) ) ) by W8;
hence thesis by SCMPDS_5:15;
end;
set t2 = ( Comput (( Q1 +* sWH ),( Initialize t1 ),kl) );
set Q2 = ( Q1 +* sWH );
A83: ( t2 . b ) = ( ( t1 . b ) - 2 ) by W9,X2;
A84: ( t2 . a ) = c by W10;
A85: ( ( Q1 +* sWH ) +* sWH ) = ( Q1 +* sWH ) by FUNCT_4:93;
A86: ( ( 2 * k1 ) + 3 ) = ( ( 2 * ( k1 + 1 ) ) + 1 );
then jj < ( ( 2 * ( k1 + 1 ) ) + 1 ) by XREAL_1:6;
then A87: ( t2 . ( intpos k2 ) ) = ( t1 . ( intpos ( ( m + n ) + jj ) ) ) by A39,A82,NAT_1:11
.= ( m + y1 ) by A39,A63,A56,SCMPDS_4:8;
A88: ym <= n by A40,A46,A55,XREAL_1:47,XXREAL_0:2;
A89:now
per cases ;
suppose yd < yn;

hence ( f3 . ym ) = ( t1 . ( intpos ( m + ym ) ) ) by A70,A80,A65;
end;
suppose yd >= yn;

hence ( f3 . ym ) = ( t1 . ( intpos ( m + ym ) ) ) by A81,A65,A88;
end;
end;
A90:now
let i being (Element of ( NAT ));
assume that
A91: 1 <= i
and
A92: i <= ym;
A93: i <= n by A88,A92,XXREAL_0:2;
A94: i < yd by A70,A92,XXREAL_0:2;
now
per cases ;
suppose yd < yn;

hence ( f3 . i ) = ( t1 . ( intpos ( m + i ) ) ) by A80,A91,A94;
end;
suppose yd >= yn;

hence ( f3 . i ) = ( t1 . ( intpos ( m + i ) ) ) by A81,A91,A93;
end;
end;
hence ( f3 . i ) = ( f2 . i ) by A50,A51,A91,A93;
end;
yc <= ( yn - 1 ) by A55,XREAL_1:9;
then ( yc - y1 ) <= ( ( yn - 1 ) - y1 ) by XREAL_1:9;
then A95: ( yc - y1 ) <= k by A48,XXREAL_0:2;
A96: yc < yd by A70,XREAL_1:146,XXREAL_0:2;
set jj = ( ( 2 * k1 ) + 2 );
jj >= 2 by NAT_1:11;
then A97: jj >= 1 by XXREAL_0:2;
jj < ( ( 2 * ( k1 + 1 ) ) + 1 ) by A86,XREAL_1:6;
then AA: ( t2 . ( intpos ( k2 + 1 ) ) ) = ( t1 . ( intpos ( ( m + n ) + jj ) ) ) by A39,A82,A97
.= ( m + yc ) by A39,A63,A57,SCMPDS_4:8;
YY: ((1 <= y1 & yc <= n) or y1 >= yc) by A46,A67,A40,XREAL_1:47;
X1: ( ( Initialize t2 ) . a ) = ( t2 . a ) by SCMPDS_5:15;
X2: ( ( Initialize t2 ) . b ) = ( t2 . b ) by SCMPDS_5:15;
X3: ( ( Initialize t2 ) . ( intpos k2 ) ) = ( t2 . ( intpos k2 ) ) by SCMPDS_5:15;
X4: ( ( Initialize t2 ) . ( intpos ( k2 + 1 ) ) ) = ( t2 . ( intpos ( k2 + 1 ) ) ) by SCMPDS_5:15;
f3 is_FinSequence_on ( Initialize t2 ),m
proof
let i being (Element of ( NAT ));
assume (1 <= i & i <= ( len f3 ));
then ( f3 . i ) = ( t2 . ( intpos ( m + i ) ) ) by A76,SCPISORT:def 1;
hence thesis by SCMPDS_5:15;
end;
then consider km being (Element of ( NAT )),f4 being (FinSequence of ( INT )) such that W1: ( Initialize ( Comput (( Q2 +* sWH ),( Initialize t2 ),km) ) ) = ( Comput (( Q2 +* sWH ),( Initialize t2 ),km) ) and W2: f4 is_FinSequence_on ( Comput (( Q2 +* sWH ),( Initialize t2 ),km) ),m and W3: ( len f4 ) = n and W4: f3,f4 are_fiberwise_equipotent  and W5: f4 is_non_decreasing_on y1,yc and W6: (for j being (Element of ( NAT )) holds ((y1 < yc & ((1 <= j & j < y1) or (yc < j & j <= n))) implies ( f4 . j ) = ( ( Initialize t2 ) . ( intpos ( m + j ) ) ))) and W7: (for j being (Element of ( NAT )) holds (((y1 >= yc & 1 <= j) & j <= n) implies ( f4 . j ) = ( ( Initialize t2 ) . ( intpos ( m + j ) ) ))) and W8: (for j being (Element of ( NAT )) holds ((1 <= j & j < ( ( 2 * k1 ) + 1 )) implies ( ( Comput (( Q2 +* sWH ),( Initialize t2 ),km) ) . ( intpos ( ( m + n ) + j ) ) ) = ( ( Initialize t2 ) . ( intpos ( ( m + n ) + j ) ) ))) and W9: ( ( Comput (( Q2 +* sWH ),( Initialize t2 ),km) ) . b ) = ( ( ( Initialize t2 ) . b ) - 2 ) and W10: ( ( Comput (( Q2 +* sWH ),( Initialize t2 ),km) ) . a ) = c by A36,A95,A77,YY,A39,X1,A84,X2,A64,A83,X3,A87,X4,AA;
A98: ( Initialize ( Comput (( Q2 +* sWH ),( Initialize t2 ),km) ) ) = ( Comput (( Q2 +* sWH ),( Initialize t2 ),km) ) by W1;
A99: f4 is_FinSequence_on ( Comput (( Q2 +* sWH ),( Initialize t2 ),km) ),m by W2;
A100: ( len f4 ) = n by W3;
A101: f3,f4 are_fiberwise_equipotent  by W4;
A102: f4 is_non_decreasing_on y1,yc by W5;
A103: (for j being (Element of ( NAT )) holds ((y1 < yc & ((1 <= j & j < y1) or (yc < j & j <= n))) implies ( f4 . j ) = ( t2 . ( intpos ( m + j ) ) )))
proof
let j being (Element of ( NAT ));
assume (y1 < yc & ((1 <= j & j < y1) or (yc < j & j <= n)));
then ( f4 . j ) = ( ( Initialize t2 ) . ( intpos ( m + j ) ) ) by W6;
hence thesis by SCMPDS_5:15;
end;
A104: (for j being (Element of ( NAT )) holds (((y1 >= yc & 1 <= j) & j <= n) implies ( f4 . j ) = ( t2 . ( intpos ( m + j ) ) )))
proof
let j being (Element of ( NAT ));
assume ((y1 >= yc & 1 <= j) & j <= n);
then ( f4 . j ) = ( ( Initialize t2 ) . ( intpos ( m + j ) ) ) by W7;
hence thesis by SCMPDS_5:15;
end;
A105: (for j being (Element of ( NAT )) holds ((1 <= j & j < ( ( 2 * k1 ) + 1 )) implies ( ( Comput (( Q2 +* sWH ),( Initialize t2 ),km) ) . ( intpos ( ( m + n ) + j ) ) ) = ( t2 . ( intpos ( ( m + n ) + j ) ) )))
proof
let j being (Element of ( NAT ));
assume (1 <= j & j < ( ( 2 * k1 ) + 1 ));
then ( ( Comput (( Q2 +* sWH ),( Initialize t2 ),km) ) . ( intpos ( ( m + n ) + j ) ) ) = ( ( Initialize t2 ) . ( intpos ( ( m + n ) + j ) ) ) by W8;
hence thesis by SCMPDS_5:15;
end;
A106: ( ( Comput (( Q2 +* sWH ),( Initialize t2 ),km) ) . b ) = ( ( t2 . b ) - 2 ) by W9,X2;
A107: ( ( Comput (( Q2 +* sWH ),( Initialize t2 ),km) ) . a ) = c by W10;
A108:now
let i being (Element of ( NAT ));
assume that
A109: yc < i
and
A110: i <= ( len f4 );
A111: ( 1 + ( 0 ) ) <= i by A109,INT_1:7;
now
per cases ;
suppose y1 < yc;

hence ( f4 . i ) = ( t2 . ( intpos ( m + i ) ) ) by A100,A103,A109,A110;
end;
suppose y1 >= yc;

hence ( f4 . i ) = ( t2 . ( intpos ( m + i ) ) ) by A100,A104,A110,A111;
end;
end;
hence ( f4 . i ) = ( f3 . i ) by A76,A77,A100,A110,A111,SCPISORT:def 1;
end;
then ( f4 . ym ) = ( f3 . ym ) by A100,A88,XREAL_1:146;
then A112: ( f4 . ym ) = ( ( IExec (I,Q,t) ) . ( intpos ( m + ym ) ) ) by A63,A89,SCMPDS_4:8;
A113:now
let i being (Element of ( NAT ));
assume that
A114: yn < i
and
A115: i <= ( len f3 );
A116: ( 1 + ( 0 ) ) <= i by A114,INT_1:7;
now
per cases ;
suppose yd < yn;

hence ( f3 . i ) = ( t1 . ( intpos ( m + i ) ) ) by A77,A80,A114,A115;
end;
suppose yd >= yn;

hence ( f3 . i ) = ( t1 . ( intpos ( m + i ) ) ) by A77,A81,A115,A116;
end;
end;
hence ( f3 . i ) = ( f2 . i ) by A50,A51,A77,A115,A116;
end;
A117:now
let i being (Element of ( NAT ));
assume that
A118: ym < i
and
A119: i <= yn;
consider j being (Element of ( NAT )) such that A120: ym < j and A121: j <= yn and A122: ( f3 . i ) = ( f2 . j ) by A40,A46,A55,A77,A78,A90,A113,A118,A119,RFINSEQ:32,XREAL_1:47;
A123: yc < i by A118,XREAL_1:146,XXREAL_0:2;
A124: 1 <= j by A65,A120,XXREAL_0:2;
A125: j <= ( len f2 ) by A40,A46,A50,A121,XREAL_1:47,XXREAL_0:2;
i <= ( len f4 ) by A40,A46,A100,A119,XREAL_1:47,XXREAL_0:2;
then ( f4 . i ) = ( f2 . j ) by A108,A123,A122
.= ( t1 . ( intpos ( m + j ) ) ) by A51,A124,A125
.= ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) by A63,SCMPDS_4:8;
hence ( f4 . ym ) <= ( f4 . i ) by A61,A112,A120,A121;
end;
A126: yn > y1 by A46,XREAL_1:47;
A127:now
let i being (Element of ( NAT ));
assume that
A128: 1 <= i
and
A129: i <= y0;
( i - 1 ) < ( y1 - 1 ) by A129,XREAL_1:146,XXREAL_0:2;
then A130: i < y1 by XREAL_1:9;
y1 <= n by A40,A126,XXREAL_0:2;
then A131: i <= n by A130,XXREAL_0:2;
now
per cases ;
suppose y1 < yc;

hence ( f4 . i ) = ( t2 . ( intpos ( m + i ) ) ) by A103,A128,A130;
end;
suppose y1 >= yc;

hence ( f4 . i ) = ( t2 . ( intpos ( m + i ) ) ) by A104,A128,A131;
end;
end;
hence ( f4 . i ) = ( f3 . i ) by A76,A77,A128,A131,SCPISORT:def 1;
end;
A132: y0 <= yc by A54,XREAL_1:9;
A133:now
let i being (Element of ( NAT ));
assume that
A134: y1 <= i
and
A135: i < ym;
( i + 1 ) <= ym by A135,INT_1:7;
then A136: i <= yc by XREAL_1:19;
y0 < i by A134,XREAL_1:146,XXREAL_0:2;
then consider j being (Element of ( NAT )) such that A137: y0 < j and A138: j <= yc and A139: ( f4 . i ) = ( f3 . j ) by A67,A100,A101,A132,A127,A108,A136,RFINSEQ:32;
A140: ( 1 + ( 0 ) ) <= j by A137,INT_1:7;
A141: j <= n by A67,A138,XXREAL_0:2;
A142: j < yd by A96,A138,XXREAL_0:2;
now
per cases ;
suppose yd < yn;

hence ( f3 . j ) = ( t1 . ( intpos ( m + j ) ) ) by A80,A140,A142;
end;
suppose yd >= yn;

hence ( f3 . j ) = ( t1 . ( intpos ( m + j ) ) ) by A81,A140,A141;
end;
end;
then A143: ( f4 . i ) = ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) by A63,A139,SCMPDS_4:8;
A144: j < ym by A138,XREAL_1:146,XXREAL_0:2;
( ( y1 - 1 ) + 1 ) <= j by A137,INT_1:7;
hence ( f4 . i ) <= ( f4 . ym ) by A60,A112,A144,A143;
end;
take mm = ( m1 + ( kl + km ) );
set tm = ( Comput (( Q +* sWH ),t,mm) );
take f4;
A145: ( Q1 +* sWH ) = ( Q +* sWH ) by FUNCT_4:93;
( Initialize t1 ) = t1 by A37,A38,A62,A47,CKB5:1,T;
then A146: tm = ( Comput (( Q +* sWH ),( Initialize t1 ),( kl + km )) ) by EXTPRO_1:4
.= ( Comput (( Q1 +* sWH ),( Initialize t1 ),( kl + km )) ) by A145
.= ( Comput (( Q2 +* sWH ),( Initialize t2 ),km) ) by A75,A85,EXTPRO_1:4;
hence ( Initialize tm ) = tm by A98;
thus f4 is_FinSequence_on tm,m by A99,A146;
thus ( len f4 ) = n by A100;
now
let i being (Element of ( NAT ));
assume that
A147: 1 <= i
and
A148: i <= ( len f2 );
thus ( f2 . i ) = ( t1 . ( intpos ( m + i ) ) ) by A51,A147,A148
.= ( ( IExec (I,Q,t) ) . ( intpos ( m + i ) ) ) by A63,SCMPDS_4:8;
end;
then f2 is_FinSequence_on ( IExec (I,Q,t) ),m by SCPISORT:def 1;
then f1,f2 are_fiberwise_equipotent  by A12,A37,A38,A39,A40,A41,A42,A44,A45,A50;
then f1,f3 are_fiberwise_equipotent  by A78,CLASSES1:76;
hence f1,f4 are_fiberwise_equipotent  by A101,CLASSES1:76;
A149:now
let j being (Element of ( NAT ));
assume that
A150: yd <= j
and
A151: j <= yn;
A152: 1 <= j by A72,A150,XXREAL_0:2;
A153: j <= n by A40,A46,A151,XREAL_1:47,XXREAL_0:2;
A154: yc < j by A96,A150,XXREAL_0:2;
now
per cases ;
suppose y1 < yc;

hence ( f4 . j ) = ( t2 . ( intpos ( m + j ) ) ) by A103,A153,A154;
end;
suppose y1 >= yc;

hence ( f4 . j ) = ( t2 . ( intpos ( m + j ) ) ) by A104,A153,A152;
end;
end;
hence ( f4 . j ) = ( f3 . j ) by A76,A77,A153,A152,SCPISORT:def 1;
end;
now
let i being (Element of ( NAT ));
let j being (Element of ( NAT ));
assume that
A155: yd <= i
and
A156: i <= j
and
A157: j <= yn;
yd <= j by A155,A156,XXREAL_0:2;
then A158: ( f4 . j ) = ( f3 . j ) by A149,A157;
i <= yn by A156,A157,XXREAL_0:2;
then ( f4 . i ) = ( f3 . i ) by A149,A155;
hence ( f4 . i ) <= ( f4 . j ) by A79,A155,A156,A157,A158,GRAPH_2:def 12;
end;
then f4 is_non_decreasing_on yd,yn by GRAPH_2:def 12;
hence f4 is_non_decreasing_on y1,yn by A102,A133,A117,CKB11:1;
thus (for j being (Element of ( NAT )) holds ((y1 < yn & ((1 <= j & j < y1) or (yn < j & j <= n))) implies ( f4 . j ) = ( t . ( intpos ( m + j ) ) )))
proof
let j being (Element of ( NAT ));
assume that
A159: y1 < yn
and
A160: ((1 <= j & j < y1) or (yn < j & j <= n));
A161: (1 <= j & j <= n)
proof
per cases  by A160;
suppose A162: (1 <= j & j < y1);

then j < yn by A159,XXREAL_0:2;
hence thesis by A40,A46,A162,XREAL_1:47,XXREAL_0:2;
end;
suppose A163: (yn < j & j <= n);

then y1 < j by A159,XXREAL_0:2;
hence thesis by A40,A46,A163,XREAL_1:47,XXREAL_0:2;
end;
end;
A164: ((1 <= j & j < yd) or (yn < j & j <= n))
proof
per cases  by A160;
suppose (1 <= j & j < y1);

hence thesis by A71,XXREAL_0:2;
end;
suppose (yn < j & j <= n);

hence thesis;
end;
end;
A165:now
per cases ;
suppose yd < yn;

hence ( f3 . j ) = ( t1 . ( intpos ( m + j ) ) ) by A80,A164;
end;
suppose yd >= yn;

hence ( f3 . j ) = ( t1 . ( intpos ( m + j ) ) ) by A81,A161;
end;
end;
A166: ((1 <= j & j < y1) or (yc < j & j <= n))
proof
per cases  by A160;
suppose (1 <= j & j < y1);

hence thesis;
end;
suppose (yn < j & j <= n);

hence thesis by A66,XXREAL_0:2;
end;
end;
now
per cases ;
suppose y1 < yc;

hence ( f4 . j ) = ( t2 . ( intpos ( m + j ) ) ) by A103,A166;
end;
suppose y1 >= yc;

hence ( f4 . j ) = ( t2 . ( intpos ( m + j ) ) ) by A104,A161;
end;
end;
hence ( f4 . j ) = ( f3 . j ) by A76,A77,A161,SCPISORT:def 1
.= ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) by A63,A165,SCMPDS_4:8
.= ( t . ( intpos ( m + j ) ) ) by A12,A37,A38,A39,A40,A41,A42,A159,A160;
end;

thus (for j being (Element of ( NAT )) holds (((y1 >= yn & 1 <= j) & j <= n) implies ( f4 . j ) = ( t . ( intpos ( m + j ) ) ))) by A46,XREAL_1:47;
hereby
let j being (Element of ( NAT ));
assume that
A167: 1 <= j
and
A168: j < ( ( 2 * k1 ) + 1 );
( ( 2 * k1 ) + 1 ) < ( ( 2 * ( k1 + 1 ) ) + 1 ) by A86,XREAL_1:6;
then A169: j < ( ( 2 * ( k1 + 1 ) ) + 1 ) by A168,XXREAL_0:2;
thus ( tm . ( intpos ( ( m + n ) + j ) ) ) = ( t2 . ( intpos ( ( m + n ) + j ) ) ) by A105,A146,A167,A168
.= ( t1 . ( intpos ( ( m + n ) + j ) ) ) by A82,A167,A169
.= ( ( IExec (I,Q,t) ) . ( intpos ( ( m + n ) + j ) ) ) by A63,SCMPDS_4:8
.= ( t . ( intpos ( ( m + n ) + j ) ) ) by A12,A37,A38,A39,A40,A41,A42,A167,A168;
end;
thus ( tm . b ) = ( ( t . b ) - 2 ) by A38,A64,A83,A106,A146;
thus ( tm . a ) = c by A107,A146;
end;
end;
hence P[ ( k + 1 ) ];
end;
A170: (for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A13,A35);
(ex k being (Element of ( NAT )) st (ex f2 being (FinSequence of ( INT )) st (((((((((( Initialize ( Comput (( P +* sWH ),s,k) ) ) = ( Comput (( P +* sWH ),s,k) ) & f2 is_FinSequence_on ( Comput (( P +* sWH ),s,k) ),m) & ( len f2 ) = n) & f,f2 are_fiberwise_equipotent ) & f2 is_non_decreasing_on 1,n) & (for j being (Element of ( NAT )) holds ((1 < n & ((1 <= j & j < 1) or (n < j & j <= n))) implies ( f2 . j ) = ( s . ( intpos ( m + j ) ) )))) & (for j being (Element of ( NAT )) holds (((1 >= n & 1 <= j) & j <= n) implies ( f2 . j ) = ( s . ( intpos ( m + j ) ) )))) & (for j being (Element of ( NAT )) holds ((1 <= j & j < ( ( 2 * ( 0 ) ) + 1 )) implies ( ( Comput (( P +* sWH ),s,k) ) . ( intpos ( ( m + n ) + j ) ) ) = ( s . ( intpos ( ( m + n ) + j ) ) )))) & ( ( Comput (( P +* sWH ),s,k) ) . b ) = ( ( s . b ) - 2 )) & ( ( Comput (( P +* sWH ),s,k) ) . a ) = c)))
proof
per cases ;
suppose ( n - 1 ) <= ( 0 );

hence thesis by A2,A3,A5,A7,A9,A10,A13,A11;
end;
suppose ( n - 1 ) > ( 0 );

then reconsider nn = ( n - 1 ) as (Element of ( NAT )) by INT_1:3;
P[ nn ] by A170;
hence thesis by A2,A3,A5,A7,A9,A10,A11;
end;
end;
then consider k being (Element of ( NAT )),f2 being (FinSequence of ( INT )) such that A171: ( Initialize ( Comput (( P +* sWH ),s,k) ) ) = ( Comput (( P +* sWH ),s,k) ) and A172: f2 is_FinSequence_on ( Comput (( P +* sWH ),s,k) ),m and A173: ( len f2 ) = n and A174: f,f2 are_fiberwise_equipotent  and A175: f2 is_non_decreasing_on 1,n and A176: ( ( Comput (( P +* sWH ),s,k) ) . b ) = ( ( s . b ) - 2 ) and A177: ( ( Comput (( P +* sWH ),s,k) ) . a ) = c;
set sk = ( Comput (( P +* sWH ),s,k) );
set s1 = ( Initialize sk );
set P1 = ( ( P +* sWH ) +* sWH );
set s2 = ( Comput (P1,s1,1) );
set P2 = P1;
A179: ( IC s1 ) = ( 0 ) by MEMSTR_0:def 8;
set i1 = ( (a,i) <=0_goto ( ( card I ) + 2 ) );
set i2 = ( goto ( - ( ( card I ) + 1 ) ) );
A180: ( card WH ) = ( ( card I ) + 2 ) by SCMPDS_8:17;
then A181: ( ( card I ) + 2 ) in ( dom sWH ) by COMPOS_1:64;
A182: ( dom g ) = ( Seg n ) by A4,FINSEQ_1:def 3;
sWH c= P2 by FUNCT_4:25;
then A183: ( P2 . ( ( card I ) + 2 ) ) = ( sWH . ( ( card I ) + 2 ) ) by A181,GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by A180,COMPOS_1:64;
A184: WH = ( i1 ';' ( I ';' i2 ) ) by CKB3:1;
A185: ( Comput (P1,s1,( ( 0 ) + 1 )) ) = ( Following (P1,( Comput (P1,s1,( 0 )) )) ) by EXTPRO_1:3
.= ( Following (P1,s1) ) by EXTPRO_1:2
.= ( Exec (i1,s1) ) by A184,SCMPDS_6:11;
( IC s2 ) = ( s2 . ( IC ( SCMPDS ) ) )
.= ( ICplusConst (s1,( ( card I ) + 2 )) ) by A7,A171,A176,A177,A185,SCMPDS_2:56
.= ( ( 0 ) + ( ( card I ) + 2 ) ) by A179,SCMPDS_6:12;
then A187: ( CurInstr (P2,s2) ) = ( halt ( SCMPDS ) ) by A183,PBOOLE:143;
( ( P +* sWH ) +* sWH ) = ( P +* sWH ) by FUNCT_4:93;
then A188: s2 = ( Comput (( P +* sWH ),s,( k + 1 )) ) by A171,EXTPRO_1:4;
A189: ( P +* sWH ) = P2 by FUNCT_4:93;
then A190: ( P +* sWH ) halts_on s by A187,A188,EXTPRO_1:29;
hence WH is_halting_on s,P by I,SCMPDS_6:def 3;
A191: ( Result (( P +* sWH ),s) ) = s2 by A187,A188,A190,A189,EXTPRO_1:def 9;
now
let i being Nat;
reconsider a = i as (Element of ( NAT )) by ORDINAL1:def 12;
set xi = ( intpos ( m + a ) );
assume A194: i in ( dom g );
then A195: 1 <= i by A182,FINSEQ_1:1;
A196: i <= n by A182,A194,FINSEQ_1:1;
( IExec (WH,P,s) ) = s2 by A191,SCMPDS_4:def 5;
hence ( g . i ) = ( s2 . xi ) by A4,A6,A195,A196,SCPISORT:def 1
.= ( s2 . xi )
.= ( s1 . xi ) by A185,SCMPDS_2:56
.= ( f2 . i ) by A171,A172,A173,A195,A196,SCPISORT:def 1;
end;
hence thesis by A4,A173,A174,A175,FINSEQ_2:9;
end;
