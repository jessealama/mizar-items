environ
vocabularies NUMBERS,SCMPDS_2,SUBSET_1,FSM_1,SCMPDS_4,AMI_1,TURING_1,SCMFSA8A,SCMFSA_7,AMI_3,INT_1,SCMFSA8B,CARD_1,ARYTM_3,FUNCT_1,XXREAL_0,UNIALG_2,SCMFSA7B,SCMFSA6B,RELAT_1,FUNCT_4,AMI_2,SCMFSA_9,ARYTM_1,VALUED_1,TARSKI,GRAPHSP,CIRCUIT2,MSUALG_1,NAT_1,FUNCOP_1,CARD_3,FINSEQ_1,GRAPH_2,SCPISORT,SCMP_GCD,CLASSES1,SCPQSORT,ORDINAL1,SCMNORM,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,FUNCT_2,SUBSET_1,CARD_1,NUMBERS,XXREAL_0,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_4,PBOOLE,VALUED_1,XCMPLX_0,RECDEF_1,INT_1,NAT_1,STRUCT_0,MEMSTR_0,EXTPRO_1,AMI_2,FUNCT_7,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,CARD_3,FINSEQ_1,SCMPDS_8,GRAPH_2,CLASSES1,COMPOS_1,SCPISORT;
definitions SCMPDS_2,SCMP_GCD,COMPOS_1,EXTPRO_1,SCPISORT,MEMSTR_0,TARSKI,FUNCT_7,XBOOLE_0,FUNCOP_1,NAT_1,AFINSQ_1,FUNCT_4;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,SCMPDS_2,FUNCT_7,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_7,SCMPDS_8,FINSEQ_1,FINSEQ_2,RFINSEQ,SCPISORT,XBOOLE_1,XREAL_1,XXREAL_0,GRAPH_2,MEMSTR_0,ORDINAL1,CLASSES1,SCMPDS_6,SCMP_GCD,INT_1,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9;
schemes NAT_1,SCMPDS_8;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,ORDINAL1,VALUED_0,VALUED_1,RELAT_1,COMPOS_1,AFINSQ_1,MEMSTR_0,EXTPRO_1,FUNCT_4,FUNCT_7,FUNCOP_1,PRE_POLY,PBOOLE,SCMPDS_3,CKB1;
constructors REAL_1,RECDEF_1,NEWTON,MESFUNC1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,CLASSES1,GRAPH_2,VALUED_1,AMI_2,SCMPDS_1,PRE_POLY,AMISTD_1,AMISTD_2,SCMPDS_7,PBOOLE,AMISTD_5,MEMSTR_0;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve P for (Instruction-Sequence of ( SCMPDS ));
reserve Q for (Instruction-Sequence of ( SCMPDS ));
theorem
Th7: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (for I being  halt-free  shiftable (Program of ( SCMPDS )) holds (for a,x1,x2,x3,x4 being Int_position holds (for i,c,md being Integer holds (((( s . x4 ) = ( ( ( s . x3 ) - c ) + ( s . x1 ) ) & md <= ( ( s . x3 ) - c )) & (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((((( t . x4 ) = ( ( ( t . x3 ) - c ) + ( t . x1 ) ) & md <= ( ( t . x3 ) - c )) & ( t . x2 ) = ( s . x2 )) & ( t . a ) = ( s . a )) & ( t . ( DataLoc (( s . a ),i) ) ) > ( 0 )) implies ((((((( ( IExec (I,Q,t) ) . a ) = ( t . a ) & I is_closed_on t,Q) & I is_halting_on t,Q) & ( ( IExec (I,Q,t) ) . ( DataLoc (( s . a ),i) ) ) < ( t . ( DataLoc (( s . a ),i) ) )) & ( ( IExec (I,Q,t) ) . x4 ) = ( ( ( ( IExec (I,Q,t) ) . x3 ) - c ) + ( ( IExec (I,Q,t) ) . x1 ) )) & md <= ( ( ( IExec (I,Q,t) ) . x3 ) - c )) & ( ( IExec (I,Q,t) ) . x2 ) = ( t . x2 )))))) implies ((( while>0 (a,i,I) ) is_closed_on s,P & ( while>0 (a,i,I) ) is_halting_on s,P) & (( s . ( DataLoc (( s . a ),i) ) ) > ( 0 ) implies ( IExec (( while>0 (a,i,I) ),P,s) ) = ( IExec (( while>0 (a,i,I) ),P,( Initialize ( IExec (I,P,s) ) )) ))))))))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
let I being  halt-free  shiftable (Program of ( SCMPDS ));
let a being Int_position;
let x1 being Int_position;
let x2 being Int_position;
let x3 being Int_position;
let x4 being Int_position;
let i being Integer;
let c being Integer;
let md being Integer;
set b = ( DataLoc (( s . a ),i) );
defpred P[ set ]
 means
(ex t being (State of ( SCMPDS )) st (((t = $1 & ( t . x4 ) = ( ( ( t . x3 ) - c ) + ( t . x1 ) )) & md <= ( ( t . x3 ) - c )) & ( t . x2 ) = ( s . x2 )));
assume that
A2: ( s . x4 ) = ( ( ( s . x3 ) - c ) + ( s . x1 ) )
and
A3: md <= ( ( s . x3 ) - c );
consider f being (Function of ( product (the Object-Kind of ( SCMPDS )) ),( NAT )) such that A4: (for s being (State of ( SCMPDS )) holds ((( s . b ) <= ( 0 ) implies ( f . s ) = ( 0 )) & (( s . b ) > ( 0 ) implies ( f . s ) = ( s . b )))) by SCMPDS_8:5;
deffunc F((State of ( SCMPDS ))) = ( f . $1 );
A7: (for t being ( 0 ) -started (State of ( SCMPDS )) holds ((P[ t ] & F(t) = ( 0 )) implies ( t . b ) <= ( 0 ))) by A4;
assume A8: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((((( t . x4 ) = ( ( ( t . x3 ) - c ) + ( t . x1 ) ) & md <= ( ( t . x3 ) - c )) & ( t . x2 ) = ( s . x2 )) & ( t . a ) = ( s . a )) & ( t . ( DataLoc (( s . a ),i) ) ) > ( 0 )) implies ((((((( ( IExec (I,Q,t) ) . a ) = ( t . a ) & I is_closed_on t,Q) & I is_halting_on t,Q) & ( ( IExec (I,Q,t) ) . ( DataLoc (( s . a ),i) ) ) < ( t . ( DataLoc (( s . a ),i) ) )) & ( ( IExec (I,Q,t) ) . x4 ) = ( ( ( ( IExec (I,Q,t) ) . x3 ) - c ) + ( ( IExec (I,Q,t) ) . x1 ) )) & md <= ( ( ( IExec (I,Q,t) ) . x3 ) - c )) & ( ( IExec (I,Q,t) ) . x2 ) = ( t . x2 )))));
A9:now
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
assume that
A10: P[ t ]
and
A11: ( t . a ) = ( s . a )
and
A12: ( t . b ) > ( 0 );
set It = ( IExec (I,Q,t) );
set t2 = ( Initialize It );
consider v being (State of ( SCMPDS )) such that A13: v = t and A14: ( v . x4 ) = ( ( ( v . x3 ) - c ) + ( v . x1 ) ) and A15: md <= ( ( v . x3 ) - c ) and A16: ( v . x2 ) = ( s . x2 ) by A10;
A17: ( t . x2 ) = ( s . x2 ) by A13,A16;
A18: ( t . x4 ) = ( ( ( t . x3 ) - c ) + ( t . x1 ) ) by A13,A14;
A19: md <= ( ( t . x3 ) - c ) by A13,A15;
thus ((( ( IExec (I,Q,t) ) . a ) = ( t . a ) & I is_closed_on t,Q) & I is_halting_on t,Q) by A8,A11,A12,A18,A16,A13,A15;
thus F(t2) < F(t)
proof
A20: F(t) = ( t . b ) by A4,A12
.= ( t . b );
assume A21: F(t2) >= F(t);
then ( t2 . b ) > ( 0 ) by A4,A12,A20;
then F(t2) = ( t2 . b ) by A4
.= ( It . b ) by SCMPDS_5:15;
hence contradiction by A8,A11,A12,A18,A19,A13,A16,A21,A20;
end;

thus P[ ( Initialize It ) ]
proof
take v = ( Initialize It );
thus v = ( Initialize It );
( It . x4 ) = ( ( ( It . x3 ) - c ) + ( It . x1 ) ) by A8,A11,A12,A18,A19,A17;
then ( v . x4 ) = ( ( ( It . x3 ) - c ) + ( It . x1 ) ) by SCMPDS_5:15;
then ( v . x4 ) = ( ( ( v . x3 ) - c ) + ( It . x1 ) ) by SCMPDS_5:15;
hence ( v . x4 ) = ( ( ( v . x3 ) - c ) + ( v . x1 ) ) by SCMPDS_5:15;
md <= ( ( It . x3 ) - c ) by A8,A11,A12,A18,A19,A17;
hence md <= ( ( v . x3 ) - c ) by SCMPDS_5:15;
( It . x2 ) = ( t . x2 ) by A8,A11,A12,A18,A19,A13,A16;
hence thesis by A13,A16,SCMPDS_5:15;
end;

end;
A22: P[ s ] by A2,A3;
(( while>0 (a,i,I) ) is_closed_on s,P & ( while>0 (a,i,I) ) is_halting_on s,P) from SCMPDS_8:sch 3(A7,A22,A9);
hence (( while>0 (a,i,I) ) is_closed_on s,P & ( while>0 (a,i,I) ) is_halting_on s,P);
assume A23: ( s . b ) > ( 0 );
( IExec (( while>0 (a,i,I) ),P,s) ) = ( IExec (( while>0 (a,i,I) ),P,( Initialize ( IExec (I,P,s) ) )) ) from SCMPDS_8:sch 4(A23,A7,A22,A9);
hence thesis;
end;
