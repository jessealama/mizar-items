environ
vocabularies NUMBERS,SCMPDS_2,SUBSET_1,FSM_1,SCMPDS_4,AMI_1,TURING_1,SCMFSA8A,SCMFSA_7,AMI_3,INT_1,SCMFSA8B,CARD_1,ARYTM_3,FUNCT_1,XXREAL_0,UNIALG_2,SCMFSA7B,SCMFSA6B,RELAT_1,FUNCT_4,AMI_2,SCMFSA_9,ARYTM_1,VALUED_1,TARSKI,GRAPHSP,CIRCUIT2,MSUALG_1,NAT_1,FUNCOP_1,CARD_3,FINSEQ_1,GRAPH_2,SCPISORT,SCMP_GCD,CLASSES1,SCPQSORT,ORDINAL1,SCMNORM,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,FUNCT_2,SUBSET_1,CARD_1,NUMBERS,XXREAL_0,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_4,PBOOLE,VALUED_1,XCMPLX_0,RECDEF_1,INT_1,NAT_1,STRUCT_0,MEMSTR_0,EXTPRO_1,AMI_2,FUNCT_7,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,CARD_3,FINSEQ_1,SCMPDS_8,GRAPH_2,CLASSES1,COMPOS_1,SCPISORT,CKB15,CKB16;
definitions SCMPDS_2,SCMP_GCD,COMPOS_1,EXTPRO_1,SCPISORT,MEMSTR_0,TARSKI,FUNCT_7,XBOOLE_0,FUNCOP_1,NAT_1,AFINSQ_1,FUNCT_4,CKB15,CKB16;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,SCMPDS_2,FUNCT_7,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_7,SCMPDS_8,FINSEQ_1,FINSEQ_2,RFINSEQ,SCPISORT,XBOOLE_1,XREAL_1,XXREAL_0,GRAPH_2,MEMSTR_0,ORDINAL1,CLASSES1,SCMPDS_6,SCMP_GCD,INT_1,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19;
schemes NAT_1,SCMPDS_8;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,ORDINAL1,VALUED_0,VALUED_1,RELAT_1,COMPOS_1,AFINSQ_1,MEMSTR_0,EXTPRO_1,FUNCT_4,FUNCT_7,FUNCOP_1,PRE_POLY,PBOOLE,SCMPDS_3,CKB1;
constructors REAL_1,RECDEF_1,NEWTON,MESFUNC1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,CLASSES1,GRAPH_2,VALUED_1,AMI_2,SCMPDS_1,PRE_POLY,AMISTD_1,AMISTD_2,SCMPDS_7,PBOOLE,AMISTD_5,MEMSTR_0,CKB15,CKB16;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
theorem
Lm25: (for s,s1 being (State of ( SCMPDS )) holds (for n0,n1,n2 being (Element of ( NAT )) holds (for c1,c2 being Integer holds ((((for i being (Element of ( NAT )) holds (((i >= n0 & i <> n1) & i <> n2) implies ( s1 . ( intpos i ) ) = ( s . ( intpos i ) ))) & n1 <= n2) & ((( s1 . ( intpos n1 ) ) = ( s . ( intpos n1 ) ) & ( s1 . ( intpos n2 ) ) = ( s . ( intpos n2 ) )) or (((c1 <= n1 & n2 <= c2) & ( s1 . ( intpos n1 ) ) = ( s . ( intpos n2 ) )) & ( s1 . ( intpos n2 ) ) = ( s . ( intpos n1 ) )))) implies (for i being (Element of ( NAT )) holds ((i >= n0 & (i < c1 or i > c2)) implies ( s1 . ( intpos i ) ) = ( s . ( intpos i ) )))))))
proof
let s being (State of ( SCMPDS ));
let s1 being (State of ( SCMPDS ));
let n0 being (Element of ( NAT ));
let n1 being (Element of ( NAT ));
let n2 being (Element of ( NAT ));
let c1 being Integer;
let c2 being Integer;
assume A1: (for i being (Element of ( NAT )) holds (((i >= n0 & i <> n1) & i <> n2) implies ( s1 . ( intpos i ) ) = ( s . ( intpos i ) )));
assume A2: n1 <= n2;
assume that
A3: ((( s1 . ( intpos n1 ) ) = ( s . ( intpos n1 ) ) & ( s1 . ( intpos n2 ) ) = ( s . ( intpos n2 ) )) or (((c1 <= n1 & n2 <= c2) & ( s1 . ( intpos n1 ) ) = ( s . ( intpos n2 ) )) & ( s1 . ( intpos n2 ) ) = ( s . ( intpos n1 ) )));
per cases  by A3;
suppose A4: (( s1 . ( intpos n1 ) ) = ( s . ( intpos n1 ) ) & ( s1 . ( intpos n2 ) ) = ( s . ( intpos n2 ) ));

hereby
let i being (Element of ( NAT ));
assume that
A5: i >= n0
and
(i < c1 or i > c2);
per cases ;
suppose (i <> n1 & i <> n2);

hence ( s1 . ( intpos i ) ) = ( s . ( intpos i ) ) by A1,A5;
end;
suppose A6: (not (i <> n1 & i <> n2));

hereby
per cases  by A6;
suppose i = n1;

hence ( s1 . ( intpos i ) ) = ( s . ( intpos i ) ) by A4;
end;
suppose i = n2;

hence ( s1 . ( intpos i ) ) = ( s . ( intpos i ) ) by A4;
end;
end;
end;
end;
end;
suppose A7: (((c1 <= n1 & n2 <= c2) & ( s1 . ( intpos n1 ) ) = ( s . ( intpos n2 ) )) & ( s1 . ( intpos n2 ) ) = ( s . ( intpos n1 ) ));

hereby
let i being (Element of ( NAT ));
assume that
A8: i >= n0
and
A9: (i < c1 or i > c2);
per cases  by A9;
suppose i < c1;

then i < n1 by A7,XXREAL_0:2;
hence ( s1 . ( intpos i ) ) = ( s . ( intpos i ) ) by A1,A2,A8;
end;
suppose i > c2;

then i > n2 by A7,XXREAL_0:2;
hence ( s1 . ( intpos i ) ) = ( s . ( intpos i ) ) by A1,A2,A8;
end;
end;
end;
end;
