environ
vocabularies NUMBERS,SCMPDS_2,SUBSET_1,FSM_1,SCMPDS_4,AMI_1,TURING_1,SCMFSA8A,SCMFSA_7,AMI_3,INT_1,SCMFSA8B,CARD_1,ARYTM_3,FUNCT_1,XXREAL_0,UNIALG_2,SCMFSA7B,SCMFSA6B,RELAT_1,FUNCT_4,AMI_2,SCMFSA_9,ARYTM_1,VALUED_1,TARSKI,GRAPHSP,CIRCUIT2,MSUALG_1,NAT_1,FUNCOP_1,CARD_3,FINSEQ_1,GRAPH_2,SCPISORT,SCMP_GCD,CLASSES1,SCPQSORT,ORDINAL1,SCMNORM,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,FUNCT_2,SUBSET_1,CARD_1,NUMBERS,XXREAL_0,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_4,PBOOLE,VALUED_1,XCMPLX_0,RECDEF_1,INT_1,NAT_1,STRUCT_0,MEMSTR_0,EXTPRO_1,AMI_2,FUNCT_7,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,CARD_3,FINSEQ_1,SCMPDS_8,GRAPH_2,CLASSES1,COMPOS_1,SCPISORT;
definitions SCMPDS_2,SCMP_GCD,COMPOS_1,EXTPRO_1,SCPISORT,MEMSTR_0,TARSKI,FUNCT_7,XBOOLE_0,FUNCOP_1,NAT_1,AFINSQ_1,FUNCT_4;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,SCMPDS_2,FUNCT_7,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_7,SCMPDS_8,FINSEQ_1,FINSEQ_2,RFINSEQ,SCPISORT,XBOOLE_1,XREAL_1,XXREAL_0,GRAPH_2,MEMSTR_0,ORDINAL1,CLASSES1,SCMPDS_6,SCMP_GCD,INT_1,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,CKB2,CKB3,CKB4;
schemes NAT_1,SCMPDS_8;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,ORDINAL1,VALUED_0,VALUED_1,RELAT_1,COMPOS_1,AFINSQ_1,MEMSTR_0,EXTPRO_1,FUNCT_4,FUNCT_7,FUNCOP_1,PRE_POLY,PBOOLE,SCMPDS_3,CKB1;
constructors REAL_1,RECDEF_1,NEWTON,MESFUNC1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,CLASSES1,GRAPH_2,VALUED_1,AMI_2,SCMPDS_1,PRE_POLY,AMISTD_1,AMISTD_2,SCMPDS_7,PBOOLE,AMISTD_5,MEMSTR_0;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve x for Int_position;
reserve P for (Instruction-Sequence of ( SCMPDS ));
theorem
Th2: (for s,sm being (State of ( SCMPDS )) holds (for I being  halt-free  shiftable (Program of ( SCMPDS )) holds (for a being Int_position holds (for i being Integer holds (for m being (Element of ( NAT )) holds (((((I is_closed_on s,P & I is_halting_on s,P) & ( s . ( DataLoc (( s . a ),i) ) ) > ( 0 )) & m = ( ( LifeSpan (( P +* ( stop I ) ),( Initialize s )) ) + 2 )) & sm = ( Comput (( P +* ( stop ( while>0 (a,i,I) ) ) ),( Initialize s ),m) )) implies (( DataPart sm ) = ( DataPart ( IExec (I,P,( Initialize s )) ) ) & ( Initialize sm ) = sm)))))))
proof
let s being (State of ( SCMPDS ));
let sm being (State of ( SCMPDS ));
let I being  halt-free  shiftable (Program of ( SCMPDS ));
let a being Int_position;
let i being Integer;
let m being (Element of ( NAT ));
set b = ( DataLoc (( s . a ),i) );
set WH = ( while>0 (a,i,I) );
set iWH = ( stop WH );
set IsI = ( stop I );
set i1 = ( (a,i) <=0_goto ( ( card I ) + 2 ) );
set i2 = ( goto ( - ( ( card I ) + 1 ) ) );
set s2 = ( Initialize s );
set P2 = ( P +* ( stop I ) );
set s3 = ( Initialize s );
set P3 = ( P +* ( stop WH ) );
set s4 = ( Comput (P3,s3,1) );
set P4 = P3;
assume that
A4: I is_closed_on s,P
and
A5: I is_halting_on s,P
and
A6: ( s . b ) > ( 0 )
and
A7: m = ( ( LifeSpan (P2,s2) ) + 2 )
and
A8: sm = ( Comput (P3,s3,m) );
A9: IsI c= P2 by FUNCT_4:25;
A10: iWH c= P3 by FUNCT_4:25;
WH c= iWH by AFINSQ_1:74;
then A11: WH c= P3 by A10,XBOOLE_1:1;
( Shift (I,1) ) c= WH by CKB4:1;
then A12: ( Shift (I,1) ) c= P4 by A11,XBOOLE_1:1;
A13: WH = ( i1 ';' ( I ';' i2 ) ) by CKB3:1;
A14: ( Comput (P3,s3,( ( 0 ) + 1 )) ) = ( Following (P3,( Comput (P3,s3,( 0 )) )) ) by EXTPRO_1:3
.= ( Following (P3,s3) ) by EXTPRO_1:2
.= ( Exec (i1,s3) ) by A13,SCMPDS_6:11;
set m2 = ( LifeSpan (P2,s2) );
set s5 = ( Comput (P4,s4,m2) );
set P5 = P4;
set l1 = ( ( card I ) + 1 );
A15: ( IC s3 ) = ( 0 ) by MEMSTR_0:def 8;
TT: (not b in ( dom ( Start-At (( 0 ),( SCMPDS )) ) )) by SCMPDS_4:18;
(not a in ( dom ( Start-At (( 0 ),( SCMPDS )) ) )) by SCMPDS_4:18;
then A16: ( s3 . ( DataLoc (( s3 . a ),i) ) ) = ( s3 . b ) by FUNCT_4:11
.= ( s . b ) by TT,FUNCT_4:11;
set m3 = ( m2 + 1 );
set s6 = ( Comput (P3,s3,m3) );
set P6 = P3;
A17: s6 = s5 by EXTPRO_1:4;
set s7 = ( Comput (P3,s3,( m3 + 1 )) );
( ( card I ) + 1 ) < ( ( card I ) + 2 ) by XREAL_1:6;
then A18: l1 in ( dom WH ) by SCMPDS_8:18;
A20: I is_closed_on s2,P2 by A4,SCMPDS_6:24;
(for x holds ( s2 . x ) = ( s4 . x )) by A14,SCMPDS_2:56;
then A22: ( DataPart s2 ) = ( DataPart s4 ) by SCMPDS_4:8;
A23: P2 halts_on s2 by A5,SCMPDS_6:def 3;
P2 = ( P2 +* ( stop I ) ) by FUNCT_4:25,FUNCT_4:98;
then ( P2 +* ( stop I ) ) halts_on ( Initialize s2 ) by A5,SCMPDS_6:def 3;
then A25: I is_halting_on s2,P2 by SCMPDS_6:def 3;
A26: ( IC s4 ) = ( s4 . ( IC ( SCMPDS ) ) )
.= ( succ ( 0 ) ) by A6,A15,A14,A16,SCMPDS_2:56
.= ( ( 0 ) + 1 );
then ( DataPart ( Comput (P2,s2,m2) ) ) = ( DataPart s5 ) by A9,A25,A20,A22,A12,SCMPDS_7:18;
then A27: ( DataPart s5 ) = ( DataPart ( Result (P2,s2) ) ) by A23,EXTPRO_1:23
.= ( DataPart ( Result (P2,s2) ) )
.= ( DataPart ( IExec (I,P,( Initialize s )) ) ) by SCMPDS_4:def 5;
A28: ( IC s5 ) = l1 by A9,A25,A20,A26,A22,A12,SCMPDS_7:18;
then A29: ( CurInstr (P6,s6) ) = ( P5 . l1 ) by A17,PBOOLE:143
.= ( P4 . l1 )
.= ( P3 . l1 )
.= ( WH . l1 ) by A18,A11,GRFUNC_1:2
.= i2 by SCMPDS_8:19;
A30: s7 = ( Following (P3,s6) ) by EXTPRO_1:3
.= ( Exec (i2,s6) ) by A29;
now
let x;
thus ( sm . x ) = ( s6 . x ) by A7,A8,A30,SCMPDS_2:54
.= ( s5 . x ) by EXTPRO_1:4;
end;
hence ( DataPart sm ) = ( DataPart ( IExec (I,P,( Initialize s )) ) ) by A27,SCMPDS_4:8;
( IC s7 ) = ( s7 . ( IC ( SCMPDS ) ) )
.= ( ICplusConst (s6,( ( 0 ) - ( ( card I ) + 1 ) )) ) by A30,SCMPDS_2:54
.= ( 0 ) by A28,A17,SCMPDS_7:1;
hence thesis by A7,A8,MEMSTR_0:46;
end;
