environ
vocabularies NUMBERS,SCMPDS_2,SUBSET_1,FSM_1,SCMPDS_4,AMI_1,TURING_1,SCMFSA8A,SCMFSA_7,AMI_3,INT_1,SCMFSA8B,CARD_1,ARYTM_3,FUNCT_1,XXREAL_0,UNIALG_2,SCMFSA7B,SCMFSA6B,RELAT_1,FUNCT_4,AMI_2,SCMFSA_9,ARYTM_1,VALUED_1,TARSKI,GRAPHSP,CIRCUIT2,MSUALG_1,NAT_1,FUNCOP_1,CARD_3,FINSEQ_1,GRAPH_2,SCPISORT,SCMP_GCD,CLASSES1,SCPQSORT,ORDINAL1,SCMNORM,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,FUNCT_2,SUBSET_1,CARD_1,NUMBERS,XXREAL_0,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_4,PBOOLE,VALUED_1,XCMPLX_0,RECDEF_1,INT_1,NAT_1,STRUCT_0,MEMSTR_0,EXTPRO_1,AMI_2,FUNCT_7,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,CARD_3,FINSEQ_1,SCMPDS_8,GRAPH_2,CLASSES1,COMPOS_1,SCPISORT,CKB15,CKB16;
definitions SCMPDS_2,SCMP_GCD,COMPOS_1,EXTPRO_1,SCPISORT,MEMSTR_0,TARSKI,FUNCT_7,XBOOLE_0,FUNCOP_1,NAT_1,AFINSQ_1,FUNCT_4,CKB15,CKB16;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,SCMPDS_2,FUNCT_7,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_7,SCMPDS_8,FINSEQ_1,FINSEQ_2,RFINSEQ,SCPISORT,XBOOLE_1,XREAL_1,XXREAL_0,GRAPH_2,MEMSTR_0,ORDINAL1,CLASSES1,SCMPDS_6,SCMP_GCD,INT_1,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18;
schemes NAT_1,SCMPDS_8;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,ORDINAL1,VALUED_0,VALUED_1,RELAT_1,COMPOS_1,AFINSQ_1,MEMSTR_0,EXTPRO_1,FUNCT_4,FUNCT_7,FUNCOP_1,PRE_POLY,PBOOLE,SCMPDS_3,CKB1;
constructors REAL_1,RECDEF_1,NEWTON,MESFUNC1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,CLASSES1,GRAPH_2,VALUED_1,AMI_2,SCMPDS_1,PRE_POLY,AMISTD_1,AMISTD_2,SCMPDS_7,PBOOLE,AMISTD_5,MEMSTR_0,CKB15,CKB16;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve n for (Element of ( NAT ));
theorem
Lm24: (for s,s1 being (State of ( SCMPDS )) holds (for n0,n1,n2,n being (Element of ( NAT )) holds (for f,f1 being (FinSequence of ( INT )) holds ((((((f is_FinSequence_on s,n0 & f1 is_FinSequence_on s1,n0) & ( len f ) = n) & ( len f1 ) = n) & (for i being (Element of ( NAT )) holds (((i >= ( n0 + 1 ) & i <> n1) & i <> n2) implies ( s1 . ( intpos i ) ) = ( s . ( intpos i ) )))) & ((( s1 . ( intpos n1 ) ) = ( s . ( intpos n1 ) ) & ( s1 . ( intpos n2 ) ) = ( s . ( intpos n2 ) )) or (((((n1 >= ( n0 + 1 ) & n2 >= ( n0 + 1 )) & n1 <= ( n0 + n )) & n2 <= ( n0 + n )) & ( s1 . ( intpos n1 ) ) = ( s . ( intpos n2 ) )) & ( s1 . ( intpos n2 ) ) = ( s . ( intpos n1 ) )))) implies f,f1 are_fiberwise_equipotent ))))
proof
let s being (State of ( SCMPDS ));
let s1 being (State of ( SCMPDS ));
let n0 being (Element of ( NAT ));
let n1 being (Element of ( NAT ));
let n2 being (Element of ( NAT ));
let n being (Element of ( NAT ));
let f being (FinSequence of ( INT ));
let f1 being (FinSequence of ( INT ));
assume that
A1: f is_FinSequence_on s,n0
and
A2: f1 is_FinSequence_on s1,n0;
assume that
A3: ( len f ) = n
and
A4: ( len f1 ) = n;
assume A5: (for i being (Element of ( NAT )) holds (((i >= ( n0 + 1 ) & i <> n1) & i <> n2) implies ( s1 . ( intpos i ) ) = ( s . ( intpos i ) )));
assume that
A6: ((( s1 . ( intpos n1 ) ) = ( s . ( intpos n1 ) ) & ( s1 . ( intpos n2 ) ) = ( s . ( intpos n2 ) )) or (((((n1 >= ( n0 + 1 ) & n2 >= ( n0 + 1 )) & n1 <= ( n0 + n )) & n2 <= ( n0 + n )) & ( s1 . ( intpos n1 ) ) = ( s . ( intpos n2 ) )) & ( s1 . ( intpos n2 ) ) = ( s . ( intpos n1 ) )));
per cases  by A6;
suppose A7: (( s1 . ( intpos n1 ) ) = ( s . ( intpos n1 ) ) & ( s1 . ( intpos n2 ) ) = ( s . ( intpos n2 ) ));

A8: ( dom f1 ) = ( Seg n ) by A4,FINSEQ_1:def 3;
now
let i being Nat;
reconsider a = i as (Element of ( NAT )) by ORDINAL1:def 12;
assume A9: i in ( dom f1 );
then A10: 1 <= i by A8,FINSEQ_1:1;
then A11: ( n0 + 1 ) <= ( n0 + i ) by XREAL_1:6;
A12: i <= n by A8,A9,FINSEQ_1:1;
per cases ;
suppose A13: (( n0 + i ) <> n1 & ( n0 + i ) <> n2);

thus ( f1 . i ) = ( s1 . ( intpos ( n0 + a ) ) ) by A2,A4,A10,A12,SCPISORT:def 1
.= ( s . ( intpos ( n0 + a ) ) ) by A5,A11,A13
.= ( f . i ) by A1,A3,A10,A12,SCPISORT:def 1;
end;
suppose A14: (not (( n0 + i ) <> n1 & ( n0 + i ) <> n2));

hereby
per cases  by A14;
suppose ( n0 + i ) = n1;

hence ( f1 . i ) = ( s . ( intpos ( n0 + a ) ) ) by A2,A4,A7,A10,A12,SCPISORT:def 1
.= ( f . i ) by A1,A3,A10,A12,SCPISORT:def 1;
end;
suppose ( n0 + i ) = n2;

hence ( f1 . i ) = ( s . ( intpos ( n0 + a ) ) ) by A2,A4,A7,A10,A12,SCPISORT:def 1
.= ( f . i ) by A1,A3,A10,A12,SCPISORT:def 1;
end;
end;
end;
end;
hence thesis by A3,A4,FINSEQ_2:9;
end;
suppose A15: (((((n1 >= ( n0 + 1 ) & n2 >= ( n0 + 1 )) & n1 <= ( n0 + n )) & n2 <= ( n0 + n )) & ( s1 . ( intpos n1 ) ) = ( s . ( intpos n2 ) )) & ( s1 . ( intpos n2 ) ) = ( s . ( intpos n1 ) ));

then A16: ( n1 - n0 ) >= 1 by XREAL_1:19;
then reconsider m1 = ( n1 - n0 ) as (Element of ( NAT )) by INT_1:3;
A17: m1 <= ( len f ) by A3,A15,XREAL_1:20;
A18: ( n2 - n0 ) >= 1 by A15,XREAL_1:19;
then reconsider m2 = ( n2 - n0 ) as (Element of ( NAT )) by INT_1:3;
A19: m2 <= ( len f1 ) by A4,A15,XREAL_1:20;
A20: n2 = ( m2 + n0 );
A21: n1 = ( m1 + n0 );
then A22: ( f . m1 ) = ( s1 . ( intpos n2 ) ) by A1,A15,A16,A17,SCPISORT:def 1
.= ( f1 . m2 ) by A2,A18,A19,A20,SCPISORT:def 1;
A23:now
let k being (Element of ( NAT ));
assume that
A24: k <> m1
and
A25: k <> m2
and
A26: 1 <= k
and
A27: k <= ( len f );
A28: ( k + n0 ) <> ( m1 + n0 ) by A24;
A29: ( n0 + 1 ) <= ( n0 + k ) by A26,XREAL_1:6;
A30: ( k + n0 ) <> ( m2 + n0 ) by A25;
thus ( f . k ) = ( s . ( intpos ( k + n0 ) ) ) by A1,A26,A27,SCPISORT:def 1
.= ( s1 . ( intpos ( k + n0 ) ) ) by A5,A28,A30,A29
.= ( f1 . k ) by A2,A3,A4,A26,A27,SCPISORT:def 1;
end;
A31: m2 <= ( len f ) by A3,A15,XREAL_1:20;
then ( f . m2 ) = ( s1 . ( intpos n1 ) ) by A1,A15,A18,A20,SCPISORT:def 1
.= ( f1 . m1 ) by A2,A3,A4,A16,A17,A21,SCPISORT:def 1;
hence thesis by A3,A4,A16,A18,A17,A31,A22,A23,SCPISORT:3;
end;
end;
