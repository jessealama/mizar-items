environ
vocabularies NUMBERS,SCMPDS_2,SUBSET_1,FSM_1,SCMPDS_4,AMI_1,TURING_1,SCMFSA8A,SCMFSA_7,AMI_3,INT_1,SCMFSA8B,CARD_1,ARYTM_3,FUNCT_1,XXREAL_0,UNIALG_2,SCMFSA7B,SCMFSA6B,RELAT_1,FUNCT_4,AMI_2,SCMFSA_9,ARYTM_1,VALUED_1,TARSKI,GRAPHSP,CIRCUIT2,MSUALG_1,NAT_1,FUNCOP_1,CARD_3,FINSEQ_1,GRAPH_2,SCPISORT,SCMP_GCD,CLASSES1,SCPQSORT,ORDINAL1,SCMNORM,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,FUNCT_2,SUBSET_1,CARD_1,NUMBERS,XXREAL_0,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_4,PBOOLE,VALUED_1,XCMPLX_0,RECDEF_1,INT_1,NAT_1,STRUCT_0,MEMSTR_0,EXTPRO_1,AMI_2,FUNCT_7,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,CARD_3,FINSEQ_1,SCMPDS_8,GRAPH_2,CLASSES1,COMPOS_1,SCPISORT;
definitions SCMPDS_2,SCMP_GCD,COMPOS_1,EXTPRO_1,SCPISORT,MEMSTR_0,TARSKI,FUNCT_7,XBOOLE_0,FUNCOP_1,NAT_1,AFINSQ_1,FUNCT_4;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,SCMPDS_2,FUNCT_7,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_7,SCMPDS_8,FINSEQ_1,FINSEQ_2,RFINSEQ,SCPISORT,XBOOLE_1,XREAL_1,XXREAL_0,GRAPH_2,MEMSTR_0,ORDINAL1,CLASSES1,SCMPDS_6,SCMP_GCD,INT_1,COMPOS_1,AFINSQ_1,EXTPRO_1,PBOOLE,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12;
schemes NAT_1,SCMPDS_8;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_8,ORDINAL1,VALUED_0,VALUED_1,RELAT_1,COMPOS_1,AFINSQ_1,MEMSTR_0,EXTPRO_1,FUNCT_4,FUNCT_7,FUNCOP_1,PRE_POLY,PBOOLE,SCMPDS_3,CKB1;
constructors REAL_1,RECDEF_1,NEWTON,MESFUNC1,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_8,SCPISORT,CLASSES1,GRAPH_2,VALUED_1,AMI_2,SCMPDS_1,PRE_POLY,AMISTD_1,AMISTD_2,SCMPDS_7,PBOOLE,AMISTD_5,MEMSTR_0;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve n for (Element of ( NAT ));
reserve P for (Instruction-Sequence of ( SCMPDS ));
reserve Q for (Instruction-Sequence of ( SCMPDS ));
theorem
Lm5: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (for I being  halt-free  shiftable (Program of ( SCMPDS )) holds (for a being Int_position holds (for i,c being Integer holds (for m,n,m1 being (Element of ( NAT )) holds ((((((( s . a ) = c & 1 = ( s . ( DataLoc (c,i) ) )) & m1 = ( ( m + n ) + 1 )) & ( m + 1 ) = ( s . ( intpos m1 ) )) & ( m + n ) = ( s . ( intpos ( m1 + 1 ) ) )) & (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (for f1,f2 being (FinSequence of ( INT )) holds (for k1,k2,y1,yn being (Element of ( NAT )) holds ((((((( t . a ) = c & ( ( 2 * k1 ) + 1 ) = ( t . ( DataLoc (c,i) ) )) & k2 = ( ( ( m + n ) + ( 2 * k1 ) ) + 1 )) & ( m + y1 ) = ( t . ( intpos k2 ) )) & ( m + yn ) = ( t . ( intpos ( k2 + 1 ) ) )) & ((1 <= y1 & yn <= n) or y1 >= yn)) implies ((((((I is_closed_on t,Q & I is_halting_on t,Q) & ( ( IExec (I,Q,t) ) . a ) = ( t . a )) & (for j being (Element of ( NAT )) holds ((1 <= j & j < ( ( 2 * k1 ) + 1 )) implies ( ( IExec (I,Q,t) ) . ( intpos ( ( m + n ) + j ) ) ) = ( t . ( intpos ( ( m + n ) + j ) ) )))) & (y1 >= yn implies (( ( IExec (I,Q,t) ) . ( DataLoc (c,i) ) ) = ( ( 2 * k1 ) - 1 ) & (for j being (Element of ( NAT )) holds ((1 <= j & j <= n) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) = ( t . ( intpos ( m + j ) ) )))))) & (y1 < yn implies ((( ( IExec (I,Q,t) ) . ( DataLoc (c,i) ) ) = ( ( 2 * k1 ) + 3 ) & (for j being (Element of ( NAT )) holds (((1 <= j & j < y1) or (yn < j & j <= n)) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) = ( t . ( intpos ( m + j ) ) )))) & (ex ym being (Element of ( NAT )) st (((((((y1 <= ym & ym <= yn) & ( m + y1 ) = ( ( IExec (I,Q,t) ) . ( intpos k2 ) )) & ( ( m + ym ) - 1 ) = ( ( IExec (I,Q,t) ) . ( intpos ( k2 + 1 ) ) )) & ( ( m + ym ) + 1 ) = ( ( IExec (I,Q,t) ) . ( intpos ( k2 + 2 ) ) )) & ( m + yn ) = ( ( IExec (I,Q,t) ) . ( intpos ( k2 + 3 ) ) )) & (for j being (Element of ( NAT )) holds ((y1 <= j & j < ym) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) <= ( ( IExec (I,Q,t) ) . ( intpos ( m + ym ) ) )))) & (for j being (Element of ( NAT )) holds ((ym < j & j <= yn) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) >= ( ( IExec (I,Q,t) ) . ( intpos ( m + ym ) ) )))))))) & ((((f1 is_FinSequence_on t,m & f2 is_FinSequence_on ( IExec (I,Q,t) ),m) & ( len f1 ) = n) & ( len f2 ) = n) implies f1,f2 are_fiberwise_equipotent )))))))) implies ( while>0 (a,i,I) ) is_halting_on s,P))))))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
let I being  halt-free  shiftable (Program of ( SCMPDS ));
let a being Int_position;
let i being Integer;
let c being Integer;
let m being (Element of ( NAT ));
let n being (Element of ( NAT ));
let m1 being (Element of ( NAT ));
set b = ( DataLoc (c,i) );
assume A2: ( s . a ) = c;
consider f being (FinSequence of ( INT )) such that A3: ( len f ) = n and A4: (for i being (Element of ( NAT )) holds ((1 <= i & i <= ( len f )) implies ( f . i ) = ( s . ( intpos ( m + i ) ) ))) by SCPISORT:1;
A5: f is_FinSequence_on s,m by A4,SCPISORT:def 1;
set ss = ( IExec (( while>0 (a,i,I) ),P,s) );
assume A6: 1 = ( s . b );
consider g being (FinSequence of ( INT )) such that A7: ( len g ) = n and A8: (for i being (Element of ( NAT )) holds ((1 <= i & i <= ( len g )) implies ( g . i ) = ( ss . ( intpos ( m + i ) ) ))) by SCPISORT:1;
A9: g is_FinSequence_on ss,m by A8,SCPISORT:def 1;
assume that
A10: m1 = ( ( m + n ) + 1 )
and
A11: ( m + 1 ) = ( s . ( intpos m1 ) )
and
A12: ( m + n ) = ( s . ( intpos ( m1 + 1 ) ) );
assume (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (for f1,f2 being (FinSequence of ( INT )) holds (for k1,k2,y1,yn being (Element of ( NAT )) holds ((((((( t . a ) = c & ( ( 2 * k1 ) + 1 ) = ( t . b )) & k2 = ( ( ( m + n ) + ( 2 * k1 ) ) + 1 )) & ( m + y1 ) = ( t . ( intpos k2 ) )) & ( m + yn ) = ( t . ( intpos ( k2 + 1 ) ) )) & ((1 <= y1 & yn <= n) or y1 >= yn)) implies ((((((I is_closed_on t,Q & I is_halting_on t,Q) & ( ( IExec (I,Q,t) ) . a ) = ( t . a )) & (for j being (Element of ( NAT )) holds ((1 <= j & j < ( ( 2 * k1 ) + 1 )) implies ( ( IExec (I,Q,t) ) . ( intpos ( ( m + n ) + j ) ) ) = ( t . ( intpos ( ( m + n ) + j ) ) )))) & (y1 >= yn implies (( ( IExec (I,Q,t) ) . b ) = ( ( 2 * k1 ) - 1 ) & (for j being (Element of ( NAT )) holds ((1 <= j & j <= n) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) = ( t . ( intpos ( m + j ) ) )))))) & (y1 < yn implies ((( ( IExec (I,Q,t) ) . b ) = ( ( 2 * k1 ) + 3 ) & (for j being (Element of ( NAT )) holds (((1 <= j & j < y1) or (yn < j & j <= n)) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) = ( t . ( intpos ( m + j ) ) )))) & (ex ym being (Element of ( NAT )) st (((((((y1 <= ym & ym <= yn) & ( m + y1 ) = ( ( IExec (I,Q,t) ) . ( intpos k2 ) )) & ( ( m + ym ) - 1 ) = ( ( IExec (I,Q,t) ) . ( intpos ( k2 + 1 ) ) )) & ( ( m + ym ) + 1 ) = ( ( IExec (I,Q,t) ) . ( intpos ( k2 + 2 ) ) )) & ( m + yn ) = ( ( IExec (I,Q,t) ) . ( intpos ( k2 + 3 ) ) )) & (for j being (Element of ( NAT )) holds ((y1 <= j & j < ym) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) <= ( ( IExec (I,Q,t) ) . ( intpos ( m + ym ) ) )))) & (for j being (Element of ( NAT )) holds ((ym < j & j <= yn) implies ( ( IExec (I,Q,t) ) . ( intpos ( m + j ) ) ) >= ( ( IExec (I,Q,t) ) . ( intpos ( m + ym ) ) )))))))) & ((((f1 is_FinSequence_on t,m & f2 is_FinSequence_on ( IExec (I,Q,t) ),m) & ( len f1 ) = n) & ( len f2 ) = n) implies f1,f2 are_fiberwise_equipotent )))))));
hence thesis by A2,A6,A10,A11,A12,A3,A5,A7,A9,CKB12:1;
end;
