environ
vocabularies XBOOLE_0,PRE_TOPC,RCOMP_1,TARSKI,NAT_1,NUMBERS,FUNCOP_1,FRECHET,SUBSET_1,CARD_1,STRUCT_0,ORDINAL2,RELAT_1,SEQ_1,VALUED_0,XXREAL_0,FUNCT_1,RLVECT_3,CARD_3,SETFAM_1,ORDINAL1,ZFMISC_1,FINSET_1,ARYTM_3,SEQ_2,METRIC_1,PCOMPS_1,METRIC_6,XREAL_0,REAL_1,WAYBEL_7,ARYTM_1,FUNCT_2,FRECHET2;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,ORDINAL1,SETFAM_1,FINSET_1,CARD_3,TOPS_2,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,SEQ_1,FUNCT_2,REAL_1,NAT_1,XXREAL_2,LIMFUNC1,VALUED_0,METRIC_1,PCOMPS_1,TBSP_1,DOMAIN_1,STRUCT_0,PRE_TOPC,FUNCOP_1,METRIC_6,YELLOW_8,FRECHET,SEQ_4,CKB18,CKB30,CKB38;
definitions TARSKI,SEQM_3,PRE_TOPC,TOPS_2,METRIC_6,FUNCT_1,FUNCT_2,FRECHET,XBOOLE_0,CKB18,CKB30,CKB38;
theorems FRECHET,URYSOHN1,YELLOW_8,PRE_TOPC,TARSKI,FUNCOP_1,NORMSP_1,ZFMISC_1,PCOMPS_1,FUNCT_1,AXIOMS,CARD_1,RELAT_1,SETFAM_1,ORDINAL1,FUNCT_2,TOPS_2,FINSET_1,SUBSET_1,SEQM_3,NAT_1,INT_1,SEQ_1,TOPMETR,METRIC_6,RELSET_1,XBOOLE_0,XBOOLE_1,XREAL_0,XREAL_1,XXREAL_0,VALUED_0,XXREAL_2,CARD_3,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44;
schemes CLASSES1,DOMAIN_1,NAT_1,RECDEF_1,SEQ_1,FUNCT_1,VALUED_1;
registrations SUBSET_1,FUNCT_1,RELSET_1,FUNCT_2,NUMBERS,XREAL_0,MEMBERED,REALSET1,STRUCT_0,METRIC_1,PCOMPS_1,FRECHET,VALUED_0,CARD_1,XXREAL_2,ORDINAL1,FINSET_1;
constructors SETFAM_1,PARTFUN1,NAT_1,NAT_D,SEQ_1,LIMFUNC1,REALSET1,CARD_3,TOPS_2,COMPTS_1,PCOMPS_1,BHSP_3,TBSP_1,URYSOHN1,METRIC_6,YELLOW_8,FRECHET,RECDEF_1,SEQ_4,XXREAL_2,SEQM_3,RELSET_1,FUNCOP_1,CKB18,CKB30,CKB38;
requirements NUMERALS,BOOLE,SUBSET,ARITHM;
begin
scheme PermSeq { T() -> non empty 1-sorted,S() -> (sequence of T()),p() -> (Permutation of ( NAT )),P[set] } : (ex n being (Element of ( NAT )) st (for m being (Element of ( NAT )) holds (n <= m implies P[ ( ( S() * p() ) . m ) ])))
provided
A1: (ex n being (Element of ( NAT )) st (for m being (Element of ( NAT )) holds (for x being (Point of T()) holds ((n <= m & x = ( S() . m )) implies P[ x ]))))
proof
consider n being (Element of ( NAT )) such that A2: (for m being (Element of ( NAT )) holds (for x being (Point of T()) holds ((n <= m & x = ( S() . m )) implies P[ x ]))) by A1;
(n in ( succ n ) & ( dom ( p() " ) ) = ( NAT )) by FUNCT_2:def 1,ORDINAL1:6;
then ( ( p() " ) . n ) in ( ( p() " ) .: ( succ n ) ) by FUNCT_1:def 6;
then reconsider X = ( ( p() " ) .: ( succ n ) ) as  finite non empty (Subset of ( NAT ));
reconsider mX = ( ( max X ) + 1 ) as (Element of ( NAT ));
take mX;
let m being (Element of ( NAT ));
m in ( NAT );
then A3: m in ( dom p() ) by FUNCT_2:52;
assume A4: mX <= m;
n <= ( p() . m )
proof
assume ( p() . m ) < n;
then ( p() . m ) in { p1 where p1 is (Element of ( NAT )): p1 < n };
then ( p() . m ) in n by AXIOMS:4;
then ( p() . m ) in ( succ n ) by ORDINAL1:8;
then m in ( p() " ( succ n ) ) by A3,FUNCT_1:def 7;
then m in ( ( p() " ) .: ( succ n ) ) by FUNCT_1:85;
then m <= ( max X ) by XXREAL_2:def 8;
hence contradiction by A4,NAT_1:13;
end;
then A5: P[ ( S() . ( p() . m ) ) ] by A2;
m in ( NAT );
then m in ( dom p() ) by FUNCT_2:def 1;
hence thesis by A5,FUNCT_1:13;
end;
