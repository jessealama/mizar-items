environ
vocabularies NUMBERS,XBOOLE_0,FINSEQ_1,FUNCT_1,GRAPH_2,ARYTM_3,NAT_1,XXREAL_0,SUBSET_1,TREES_1,TARSKI,CARD_1,ORDINAL1,FINSET_1,MEMBERED,RELAT_1,ORDINAL4,GLIB_000,GLIB_001,ABIAN,ZFMISC_1,ARYTM_1,GRAPH_1,RCOMP_1,SETFAM_1,HELLY;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,FINSET_1,CARD_1,NUMBERS,XCMPLX_0,XXREAL_0,SETFAM_1,FUNCT_1,FINSEQ_1,MEMBERED,NAT_1,TREES_1,XXREAL_2,ABIAN,GRAPH_2,GLIB_000,GLIB_001,GLIB_002,CKB2;
definitions TARSKI,XBOOLE_0,GLIB_001,CKB2;
theorems TARSKI,NAT_1,GRAPH_5,SETFAM_1,XBOOLE_0,XBOOLE_1,GRFUNC_1,FUNCT_1,ZFMISC_1,ORDINAL1,FINSEQ_1,FINSEQ_2,FINSEQ_3,INT_1,EULER_1,CARD_1,XREAL_1,XXREAL_0,CHORD,ABIAN,GLIB_000,GLIB_001,GLIB_002,MSSCYC_1,MEMBERED,GRAPH_2,XXREAL_2,FINSEQ_4,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB15,CKB16,CKB17,CKB18,CKB19;
schemes NAT_1,FINSEQ_1;
registrations FINSET_1,XREAL_0,XXREAL_0,NAT_1,INT_1,RELAT_1,FINSEQ_1,ABIAN,MEMBERED,GLIB_000,GLIB_001,GLIB_002,XXREAL_2,CARD_1,FUNCT_1,XBOOLE_0,CKB14;
constructors DOMAIN_1,SETFAM_1,NAT_1,GRAPH_2,GLIB_001,GLIB_002,XXREAL_2,RELSET_1,RAT_1,CKB2;
requirements BOOLE,SUBSET,NUMERALS,ARITHM,REAL;
begin
theorem
Th18: (for G being _Graph holds (for P1,P2 being (Path of G) holds ((((((( P1 .last() ) = ( P2 .first() ) & P1 is  open) & P2 is  open) & ( P1 .edges() ) misses ( P2 .edges() )) & (( P1 .first() ) in ( P2 .vertices() ) implies ( P1 .first() ) = ( P2 .last() ))) & ( ( P1 .vertices() ) /\ ( P2 .vertices() ) ) c= { ( P1 .first() ),( P1 .last() ) }) implies ( P1 .append P2 ) is  Path-like)))
proof
let G being _Graph;
let P1 being (Path of G),P2 being (Path of G);
assume that
A1: ( P1 .last() ) = ( P2 .first() )
and
A2: P1 is  open
and
A3: P2 is  open
and
A4: ( P1 .edges() ) misses ( P2 .edges() )
and
A5: (( P1 .first() ) in ( P2 .vertices() ) implies ( P1 .first() ) = ( P2 .last() ))
and
A6: ( ( P1 .vertices() ) /\ ( P2 .vertices() ) ) c= { ( P1 .first() ),( P1 .last() ) };
thus ( P1 .append P2 ) is  Trail-like by A1,A4,CKB19:1;
set P = ( P1 .append P2 );
let m being  odd (Element of ( NAT )),n being  odd (Element of ( NAT ));
assume that
A7: m < n
and
A8: n <= ( len P )
and
A9: ( P . m ) = ( P . n )
and
A10: (m <> 1 or n <> ( len P ));
A11: 1 <= m by ABIAN:12;
1 <= n by ABIAN:12;
then A12: n in ( dom P ) by A8,FINSEQ_3:25;
m <= ( len P ) by A7,A8,XXREAL_0:2;
then A13: m in ( dom P ) by A11,FINSEQ_3:25;
per cases  by A12,GLIB_001:34;
suppose (ex k being (Element of ( NAT )) st (k < ( len P2 ) & n = ( ( len P1 ) + k )));

then consider k being (Element of ( NAT )) such that A14: k < ( len P2 ) and A15: n = ( ( len P1 ) + k );
A16: ( P . n ) = ( P2 . ( k + 1 ) ) by A1,A14,A15,GLIB_001:33;
reconsider k as  even (Element of ( NAT )) by A15;
A17: ( k + 1 ) <= ( len P2 ) by A14,NAT_1:13;
then A18: ( P2 . ( k + 1 ) ) in ( P2 .vertices() ) by GLIB_001:87;
per cases  by A13,GLIB_001:34;
suppose (ex k being (Element of ( NAT )) st (k < ( len P2 ) & m = ( ( len P1 ) + k )));

then consider l being (Element of ( NAT )) such that A19: l < ( len P2 ) and A20: m = ( ( len P1 ) + l );
A21: ( P . m ) = ( P2 . ( l + 1 ) ) by A1,A19,A20,GLIB_001:33;
l < k by A7,A15,A20,XREAL_1:6;
then A22: ( l + 1 ) < ( k + 1 ) by XREAL_1:6;
reconsider l as  even (Element of ( NAT )) by A20;
( l + 1 ) is  odd;
then A23: ( P2 .last() ) = ( P2 . ( k + 1 ) ) by A9,A16,A17,A21,A22,GLIB_001:def 28;
( P2 .first() ) = ( P2 . ( l + 1 ) ) by A9,A16,A17,A21,A22,GLIB_001:def 28;
hence contradiction by A3,A9,A16,A21,A23,GLIB_001:def 24;
end;
suppose A24: m in ( dom P1 );

set x = ( P1 . m );
A25: ( P1 . m ) = ( P . m ) by A24,GLIB_001:32;
A26: m <= ( len P1 ) by A24,FINSEQ_3:25;
then ( P1 . m ) in ( P1 .vertices() ) by GLIB_001:87;
then A27: x in ( ( P1 .vertices() ) /\ ( P2 .vertices() ) ) by A9,A16,A18,A25,XBOOLE_0:def 4;
per cases  by A6,A27,TARSKI:def 2;
suppose A28: x = ( P1 .last() );

A29:now
assume m < ( len P1 );
then ( P1 .first() ) = ( P1 . m ) by A28,GLIB_001:def 28;
hence contradiction by A2,A28,GLIB_001:def 24;
end;
A30:now
assume ( ( 2 * ( 0 ) ) + 1 ) < ( k + 1 );
then ( P2 .first() ) = ( P2 .last() ) by A1,A9,A16,A17,A25,A28,GLIB_001:def 28;
hence contradiction by A3,GLIB_001:def 24;
end;
1 <= ( k + 1 ) by NAT_1:11;
then 1 = ( k + 1 ) by A30,XXREAL_0:1;
hence contradiction by A7,A15,A29;
end;
suppose A31: x = ( P1 .first() );

then A32: x = ( P1 . ( ( 2 * ( 0 ) ) + 1 ) );
A33:now
assume m <> 1;
then 1 < m by A11,XXREAL_0:1;
then x = ( P1 .last() ) by A26,A32,GLIB_001:def 28;
hence contradiction by A2,A31,GLIB_001:def 24;
end;
now
assume ( k + 1 ) = ( len P2 );
then ( ( len P ) + 1 ) = ( ( len P1 ) + ( k + 1 ) ) by A1,GLIB_001:28;
hence contradiction by A10,A15,A33;
end;
then A34: ( k + 1 ) < ( len P2 ) by A17,XXREAL_0:1;
( P2 . ( k + 1 ) ) = ( P2 .last() ) by A5,A9,A16,A18,A24,A31,GLIB_001:32;
then ( P2 .first() ) = ( P2 .last() ) by A34,GLIB_001:def 28;
hence contradiction by A3,GLIB_001:def 24;
end;
end;
end;
suppose A35: n in ( dom P1 );

then A36: n <= ( len P1 ) by FINSEQ_3:25;
then (1 <= m & m <= ( len P1 )) by A7,ABIAN:12,XXREAL_0:2;
then m in ( dom P1 ) by FINSEQ_3:25;
then A37: ( P1 . m ) = ( P . m ) by GLIB_001:32
.= ( P1 . n ) by A9,A35,GLIB_001:32;
then m = 1 by A7,A36,GLIB_001:def 28;
then ( P1 .first() ) = ( P1 .last() ) by A7,A36,A37,GLIB_001:def 28;
hence contradiction by A2,GLIB_001:def 24;
end;
end;
