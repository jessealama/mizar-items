environ
vocabularies NUMBERS,XBOOLE_0,FINSEQ_1,FUNCT_1,GRAPH_2,ARYTM_3,NAT_1,XXREAL_0,SUBSET_1,TREES_1,TARSKI,CARD_1,ORDINAL1,FINSET_1,MEMBERED,RELAT_1,ORDINAL4,GLIB_000,GLIB_001,ABIAN,ZFMISC_1,ARYTM_1,GRAPH_1,RCOMP_1,SETFAM_1,HELLY;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,FINSET_1,CARD_1,NUMBERS,XCMPLX_0,XXREAL_0,SETFAM_1,FUNCT_1,FINSEQ_1,MEMBERED,NAT_1,TREES_1,XXREAL_2,ABIAN,GRAPH_2,GLIB_000,GLIB_001,GLIB_002,CKB2,CKB27,CKB28,CKB34,CKB52;
definitions TARSKI,XBOOLE_0,GLIB_001,CKB2,CKB34,CKB52;
theorems TARSKI,NAT_1,GRAPH_5,SETFAM_1,XBOOLE_0,XBOOLE_1,GRFUNC_1,FUNCT_1,ZFMISC_1,ORDINAL1,FINSEQ_1,FINSEQ_2,FINSEQ_3,INT_1,EULER_1,CARD_1,XREAL_1,XXREAL_0,CHORD,ABIAN,GLIB_000,GLIB_001,GLIB_002,MSSCYC_1,MEMBERED,GRAPH_2,XXREAL_2,FINSEQ_4,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56,CKB57,CKB58,CKB59,CKB60,CKB61,CKB62,CKB63,CKB64;
schemes NAT_1,FINSEQ_1;
registrations FINSET_1,XREAL_0,XXREAL_0,NAT_1,INT_1,RELAT_1,FINSEQ_1,ABIAN,MEMBERED,GLIB_000,GLIB_001,GLIB_002,XXREAL_2,CARD_1,FUNCT_1,XBOOLE_0,CKB14,CKB29,CKB31,CKB37,CKB38;
constructors DOMAIN_1,SETFAM_1,NAT_1,GRAPH_2,GLIB_001,GLIB_002,XXREAL_2,RELSET_1,RAT_1,CKB2,CKB34,CKB52;
requirements BOOLE,SUBSET,NUMERALS,ARITHM,REAL;
begin
theorem
Th53: (for T being _Tree holds (for a,b,c being (Vertex of T) holds (for S being non  empty set holds ((for s being set holds (s in S implies ((ex t being (_Subtree of T) st s = ( the_Vertices_of t )) & (((a in s & b in s) or (a in s & c in s)) or (b in s & c in s))))) implies ( meet S ) <> ( {} )))))
proof
let T being _Tree;
let a being (Vertex of T);
let b being (Vertex of T);
let c being (Vertex of T);
let S being non  empty set;
assume A1: (for s being set holds (s in S implies ((ex t being (_Subtree of T) st s = ( the_Vertices_of t )) & (((a in s & b in s) or (a in s & c in s)) or (b in s & c in s)))));
set m = ( MiddleVertex (a,b,c) );
set Pca = ( T .pathBetween (c,a) );
set Pbc = ( T .pathBetween (b,c) );
set Pac = ( T .pathBetween (a,c) );
set Pab = ( T .pathBetween (a,b) );
set VPab = ( Pab .vertices() );
set VPac = ( Pac .vertices() );
set VPbc = ( Pbc .vertices() );
set VPca = ( Pca .vertices() );
( ( VPab /\ VPbc ) /\ VPca ) = { m } by CKB52:def 1;
then A2: m in ( ( VPab /\ VPbc ) /\ VPca ) by TARSKI:def 1;
then A3: m in ( VPab /\ VPbc ) by XBOOLE_0:def 4;
then A4: m in VPbc by XBOOLE_0:def 4;
VPca = VPac by CKB41:1;
then A5: m in VPac by A2,XBOOLE_0:def 4;
A6: m in VPab by A3,XBOOLE_0:def 4;
now
let s being set;
assume A7: s in S;
then A8: (ex t being (_Subtree of T) st s = ( the_Vertices_of t )) by A1;
per cases  by A1,A7;
suppose (a in s & b in s);

then VPab c= s by A8,CKB43:1;
hence m in s by A6;
end;
suppose (a in s & c in s);

then VPac c= s by A8,CKB43:1;
hence m in s by A5;
end;
suppose (b in s & c in s);

then VPbc c= s by A8,CKB43:1;
hence m in s by A4;
end;
end;
hence thesis by SETFAM_1:def 1;
end;
