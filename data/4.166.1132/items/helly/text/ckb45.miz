environ
vocabularies NUMBERS,XBOOLE_0,FINSEQ_1,FUNCT_1,GRAPH_2,ARYTM_3,NAT_1,XXREAL_0,SUBSET_1,TREES_1,TARSKI,CARD_1,ORDINAL1,FINSET_1,MEMBERED,RELAT_1,ORDINAL4,GLIB_000,GLIB_001,ABIAN,ZFMISC_1,ARYTM_1,GRAPH_1,RCOMP_1,SETFAM_1,HELLY;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,FINSET_1,CARD_1,NUMBERS,XCMPLX_0,XXREAL_0,SETFAM_1,FUNCT_1,FINSEQ_1,MEMBERED,NAT_1,TREES_1,XXREAL_2,ABIAN,GRAPH_2,GLIB_000,GLIB_001,GLIB_002,CKB2,CKB27,CKB28,CKB34;
definitions TARSKI,XBOOLE_0,GLIB_001,CKB2,CKB34;
theorems TARSKI,NAT_1,GRAPH_5,SETFAM_1,XBOOLE_0,XBOOLE_1,GRFUNC_1,FUNCT_1,ZFMISC_1,ORDINAL1,FINSEQ_1,FINSEQ_2,FINSEQ_3,INT_1,EULER_1,CARD_1,XREAL_1,XXREAL_0,CHORD,ABIAN,GLIB_000,GLIB_001,GLIB_002,MSSCYC_1,MEMBERED,GRAPH_2,XXREAL_2,FINSEQ_4,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44;
schemes NAT_1,FINSEQ_1;
registrations FINSET_1,XREAL_0,XXREAL_0,NAT_1,INT_1,RELAT_1,FINSEQ_1,ABIAN,MEMBERED,GLIB_000,GLIB_001,GLIB_002,XXREAL_2,CARD_1,FUNCT_1,XBOOLE_0,CKB14,CKB29,CKB31,CKB37,CKB38;
constructors DOMAIN_1,SETFAM_1,NAT_1,GRAPH_2,GLIB_001,GLIB_002,XXREAL_2,RELSET_1,RAT_1,CKB2,CKB34;
requirements BOOLE,SUBSET,NUMERALS,ARITHM,REAL;
begin
theorem
Th36: (for T being _Tree holds (for a,b,c being (Vertex of T) holds (c in ( ( T .pathBetween (a,b) ) .vertices() ) iff ( T .pathBetween (a,b) ) = ( ( T .pathBetween (a,c) ) .append ( T .pathBetween (c,b) ) ))))
proof
let T being _Tree;
let a being (Vertex of T);
let b being (Vertex of T);
let c being (Vertex of T);
set P = ( T .pathBetween (a,b) );
set ci = ( P .find c );
set pac = ( T .pathBetween (a,c) );
set pcb = ( T .pathBetween (c,b) );
hereby
A1: P = ( P .cut (1,( len P )) ) by GLIB_001:39;
A2: (1 <= ci & 1 = ( ( 2 * ( 0 ) ) + 1 )) by ABIAN:12;
assume A3: c in ( P .vertices() );
then A4: ci <= ( len P ) by GLIB_001:def 19;
A5: ( P . ci ) = c by A3,GLIB_001:def 19;
( P . ( len P ) ) = ( P .last() )
.= b by CKB35:1;
then A6: pcb = ( P .cut (ci,( len P )) ) by A4,A5,CKB44:1;
( P . 1 ) = ( P .first() )
.= a by CKB35:1;
then pac = ( P .cut (1,ci) ) by A4,A2,A5,CKB44:1;
hence P = ( ( T .pathBetween (a,c) ) .append ( T .pathBetween (c,b) ) ) by A4,A2,A6,A1,GLIB_001:38;
end;
assume P = ( pac .append pcb );
then A7: ( pac .vertices() ) c= ( P .vertices() ) by CKB15:1,CKB17:1;
c in ( pac .vertices() ) by CKB36:1;
hence thesis by A7;
end;
