environ
vocabularies NUMBERS,XBOOLE_0,FINSEQ_1,FUNCT_1,GRAPH_2,ARYTM_3,NAT_1,XXREAL_0,SUBSET_1,TREES_1,TARSKI,CARD_1,ORDINAL1,FINSET_1,MEMBERED,RELAT_1,ORDINAL4,GLIB_000,GLIB_001,ABIAN,ZFMISC_1,ARYTM_1,GRAPH_1,RCOMP_1,SETFAM_1,HELLY;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,FINSET_1,CARD_1,NUMBERS,XCMPLX_0,XXREAL_0,SETFAM_1,FUNCT_1,FINSEQ_1,MEMBERED,NAT_1,TREES_1,XXREAL_2,ABIAN,GRAPH_2,GLIB_000,GLIB_001,GLIB_002,CKB2;
definitions TARSKI,XBOOLE_0,GLIB_001,CKB2;
theorems TARSKI,NAT_1,GRAPH_5,SETFAM_1,XBOOLE_0,XBOOLE_1,GRFUNC_1,FUNCT_1,ZFMISC_1,ORDINAL1,FINSEQ_1,FINSEQ_2,FINSEQ_3,INT_1,EULER_1,CARD_1,XREAL_1,XXREAL_0,CHORD,ABIAN,GLIB_000,GLIB_001,GLIB_002,MSSCYC_1,MEMBERED,GRAPH_2,XXREAL_2,FINSEQ_4,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
schemes NAT_1,FINSEQ_1;
registrations FINSET_1,XREAL_0,XXREAL_0,NAT_1,INT_1,RELAT_1,FINSEQ_1,ABIAN,MEMBERED,GLIB_000,GLIB_001,GLIB_002,XXREAL_2,CARD_1,FUNCT_1,XBOOLE_0,CKB14;
constructors DOMAIN_1,SETFAM_1,NAT_1,GRAPH_2,GLIB_001,GLIB_002,XXREAL_2,RELSET_1,RAT_1,CKB2;
requirements BOOLE,SUBSET,NUMERALS,ARITHM,REAL;
begin
theorem
Th19: (for G being _Graph holds (for P1,P2 being (Path of G) holds ((((( P1 .last() ) = ( P2 .first() ) & P1 is  open) & P2 is  open) & ( ( P1 .vertices() ) /\ ( P2 .vertices() ) ) = { ( P1 .last() ) }) implies ( P1 .append P2 ) is  open  Path-like)))
proof
let G being _Graph;
let P1 being (Path of G),P2 being (Path of G);
assume that
A1: ( P1 .last() ) = ( P2 .first() )
and
A2: P1 is  open
and
A3: P2 is  open
and
A4: ( ( P1 .vertices() ) /\ ( P2 .vertices() ) ) = { ( P1 .last() ) };
set P = ( P1 .append P2 );
thus P is  open
proof
assume A5: ( P .first() ) = ( P .last() );
(( P .first() ) = ( P1 .first() ) & ( P .last() ) = ( P2 .last() )) by A1,GLIB_001:30;
then (( P1 .first() ) in ( P1 .vertices() ) & ( P1 .first() ) in ( P2 .vertices() )) by A5,GLIB_001:88;
then ( P1 .first() ) in { ( P1 .last() ) } by A4,XBOOLE_0:def 4;
then ( P1 .first() ) = ( P1 .last() ) by TARSKI:def 1;
hence contradiction by A2,GLIB_001:def 24;
end;

A6:now
A7: ( P1 .first() ) in ( P1 .vertices() ) by GLIB_001:88;
assume ( P1 .first() ) in ( P2 .vertices() );
then ( P1 .first() ) in { ( P1 .last() ) } by A4,A7,XBOOLE_0:def 4;
then ( P1 .first() ) = ( P1 .last() ) by TARSKI:def 1;
hence contradiction by A2,GLIB_001:def 24;
end;
A8: ( P1 .edges() ) misses ( P2 .edges() )
proof
assume ( ( P1 .edges() ) /\ ( P2 .edges() ) ) <> ( {} );
then consider x being set such that A9: x in ( ( P1 .edges() ) /\ ( P2 .edges() ) ) by XBOOLE_0:def 1;
x in ( P2 .edges() ) by A9,XBOOLE_0:def 4;
then consider u1 being (Vertex of G),u2 being (Vertex of G),m being  odd (Element of ( NAT )) such that A10: ( m + 2 ) <= ( len P2 ) and A11: u1 = ( P2 . m ) and x = ( P2 . ( m + 1 ) ) and A12: u2 = ( P2 . ( m + 2 ) ) and A13: x Joins u1,u2,G by GLIB_001:103;
x in ( P1 .edges() ) by A9,XBOOLE_0:def 4;
then consider v1 being (Vertex of G),v2 being (Vertex of G),n being  odd (Element of ( NAT )) such that A14: ( n + 2 ) <= ( len P1 ) and A15: v1 = ( P1 . n ) and x = ( P1 . ( n + 1 ) ) and A16: v2 = ( P1 . ( n + 2 ) ) and A17: x Joins v1,v2,G by GLIB_001:103;
A18: ( n + ( 0 ) ) < ( n + 2 ) by XREAL_1:8;
per cases ;
suppose A19: v1 <> v2;

n <= ( len P1 ) by A14,A18,XXREAL_0:2;
then A20: v1 in ( P1 .vertices() ) by A15,GLIB_001:87;
v2 in ( P1 .vertices() ) by A14,A16,GLIB_001:87;
then A21: { v1,v2 } c= ( P1 .vertices() ) by A20,ZFMISC_1:32;
( m + ( 0 ) ) < ( m + 2 ) by XREAL_1:8;
then m <= ( len P2 ) by A10,XXREAL_0:2;
then A22: u1 in ( P2 .vertices() ) by A11,GLIB_001:87;
u2 in ( P2 .vertices() ) by A10,A12,GLIB_001:87;
then A23: { u1,u2 } c= ( P2 .vertices() ) by A22,ZFMISC_1:32;
A24: ((v1 = u1 & v2 = u2) or (v1 = u2 & v2 = u1)) by A17,A13,GLIB_000:15;
then v1 = ( P1 .last() ) by A4,A21,A23,XBOOLE_1:19,ZFMISC_1:20;
hence contradiction by A4,A19,A24,A21,A23,XBOOLE_1:19,ZFMISC_1:20;
end;
suppose A25: v1 = v2;

then ( P1 .first() ) = v1 by A14,A15,A16,A18,GLIB_001:def 28
.= ( P1 .last() ) by A14,A15,A16,A18,A25,GLIB_001:def 28;
hence contradiction by A2,GLIB_001:def 24;
end;
end;
( ( P1 .vertices() ) /\ ( P2 .vertices() ) ) c= { ( P1 .first() ),( P1 .last() ) } by A4,ZFMISC_1:7;
hence thesis by A1,A2,A3,A8,A6,CKB20:1;
end;
