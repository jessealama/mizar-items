environ
vocabularies NUMBERS,XBOOLE_0,FINSEQ_1,FUNCT_1,GRAPH_2,ARYTM_3,NAT_1,XXREAL_0,SUBSET_1,TREES_1,TARSKI,CARD_1,ORDINAL1,FINSET_1,MEMBERED,RELAT_1,ORDINAL4,GLIB_000,GLIB_001,ABIAN,ZFMISC_1,ARYTM_1,GRAPH_1,RCOMP_1,SETFAM_1,HELLY;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,FINSET_1,CARD_1,NUMBERS,XCMPLX_0,XXREAL_0,SETFAM_1,FUNCT_1,FINSEQ_1,MEMBERED,NAT_1,TREES_1,XXREAL_2,ABIAN,GRAPH_2,GLIB_000,GLIB_001,GLIB_002,CKB2,CKB27,CKB28,CKB34;
definitions TARSKI,XBOOLE_0,GLIB_001,CKB2,CKB34;
theorems TARSKI,NAT_1,GRAPH_5,SETFAM_1,XBOOLE_0,XBOOLE_1,GRFUNC_1,FUNCT_1,ZFMISC_1,ORDINAL1,FINSEQ_1,FINSEQ_2,FINSEQ_3,INT_1,EULER_1,CARD_1,XREAL_1,XXREAL_0,CHORD,ABIAN,GLIB_000,GLIB_001,GLIB_002,MSSCYC_1,MEMBERED,GRAPH_2,XXREAL_2,FINSEQ_4,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51;
schemes NAT_1,FINSEQ_1;
registrations FINSET_1,XREAL_0,XXREAL_0,NAT_1,INT_1,RELAT_1,FINSEQ_1,ABIAN,MEMBERED,GLIB_000,GLIB_001,GLIB_002,XXREAL_2,CARD_1,FUNCT_1,XBOOLE_0,CKB14,CKB29,CKB31,CKB37,CKB38;
constructors DOMAIN_1,SETFAM_1,NAT_1,GRAPH_2,GLIB_001,GLIB_002,XXREAL_2,RELSET_1,RAT_1,CKB2,CKB34;
requirements BOOLE,SUBSET,NUMERALS,ARITHM,REAL;
begin
definition
let T being _Tree;
let a being (Vertex of T);
let b being (Vertex of T);
let c being (Vertex of T);
func MiddleVertex (a,b,c) -> (Vertex of T)
means
:Def3: ( ( ( ( T .pathBetween (a,b) ) .vertices() ) /\ ( ( T .pathBetween (b,c) ) .vertices() ) ) /\ ( ( T .pathBetween (c,a) ) .vertices() ) ) = { it };
existence
proof
defpred P[ (Vertex of T),(Vertex of T),(Vertex of T),(Vertex of T) ]
 means
( ( ( ( T .pathBetween ($1,$2) ) .vertices() ) /\ ( ( T .pathBetween ($2,$3) ) .vertices() ) ) /\ ( ( T .pathBetween ($3,$1) ) .vertices() ) ) = { $4 };
set P3 = ( T .pathBetween (c,a) );
set P2 = ( T .pathBetween (b,c) );
set P1 = ( T .pathBetween (a,b) );
per cases ;
suppose A1: ((c in ( P1 .vertices() ) or a in ( P2 .vertices() )) or b in ( P3 .vertices() ));

per cases  by A1;
suppose c in ( P1 .vertices() );

then P[ a,b,c,c ] by CKB50:1;
hence thesis;
end;
suppose a in ( P2 .vertices() );

then P[ b,c,a,a ] by CKB50:1;
hence thesis by XBOOLE_1:16;
end;
suppose b in ( P3 .vertices() );

then P[ c,a,b,b ] by CKB50:1;
hence thesis by XBOOLE_1:16;
end;
end;
suppose A2: (((not c in ( P1 .vertices() )) & (not a in ( P2 .vertices() ))) & (not b in ( P3 .vertices() )));

set P4 = ( T .pathBetween (a,c) );
set i = ( len ( maxPrefix (P1,P4) ) );
( P1 .last() ) = b by CKB35:1;
then A3: b in ( P1 .vertices() ) by GLIB_001:88;
( P4 .last() ) = c by CKB35:1;
then c in ( P4 .vertices() ) by GLIB_001:88;
then (not ( P4 .vertices() ) c= ( P1 .vertices() )) by A2;
then A4: (not P4 c= P1) by CKB15:1;
( P1 .first() ) = a by CKB35:1;
then A5: ( P1 .first() ) = ( P4 .first() ) by CKB35:1;
then reconsider i9 = i as  odd (Element of ( NAT )) by CKB24:1;
set x = ( P1 . i9 );
( P3 .vertices() ) = ( P4 .vertices() ) by CKB41:1;
then A6: (not ( P1 .vertices() ) c= ( P4 .vertices() )) by A2,A3;
then (i <= ( i + 2 ) & ( i + 2 ) <= ( len P1 )) by A5,CKB15:1,CKB25:1,NAT_1:11;
then reconsider x as (Vertex of T) by GLIB_001:7,XXREAL_0:2;
take x;
(not P1 c= P4) by A6,CKB15:1;
hence thesis by A4,CKB51:1;
end;
end;
uniqueness by ZFMISC_1:3;
end;
