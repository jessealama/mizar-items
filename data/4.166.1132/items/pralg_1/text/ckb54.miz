environ
vocabularies UNIALG_1,NAT_1,XBOOLE_0,FINSEQ_1,ZFMISC_1,MCART_1,RELAT_1,FUNCT_1,FUNCT_2,PARTFUN1,FINSEQ_2,SUBSET_1,TARSKI,NUMBERS,STRUCT_0,CQC_SIM1,UNIALG_2,ORDINAL1,PBOOLE,FUNCOP_1,RLVECT_2,CARD_3,CARD_1,FINSEQ_4,FUNCT_5,PRALG_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,NUMBERS,NAT_1,STRUCT_0,RELAT_1,FUNCT_1,FINSEQ_1,FUNCT_2,BINOP_1,FUNCOP_1,MCART_1,DOMAIN_1,PARTFUN1,FINSEQ_2,FUNCT_4,FUNCT_5,CARD_3,MARGREL1,DTCONSTR,UNIALG_1,UNIALG_2,PBOOLE,CKB1,CKB2,CKB3,CKB4,CKB6,CKB7,CKB14,CKB17,CKB21,CKB22,CKB23,CKB27,CKB29,CKB30,CKB31,CKB33,CKB35,CKB36,CKB37,CKB40,CKB43,CKB50,CKB51,CKB52,CKB53;
definitions TARSKI,UNIALG_1,UNIALG_2,FUNCT_1,PBOOLE,XBOOLE_0,BINOP_1,FINSEQ_2,FUNCOP_1,PARTFUN1,MARGREL1,CKB1,CKB2,CKB3,CKB4,CKB6,CKB7,CKB14,CKB17,CKB21,CKB22,CKB23,CKB27,CKB31,CKB33,CKB35,CKB37,CKB40,CKB43,CKB50,CKB51,CKB52,CKB53;
theorems TARSKI,FUNCT_1,PARTFUN1,FINSEQ_1,FINSEQ_2,FUNCOP_1,UNIALG_1,DOMAIN_1,ZFMISC_1,MCART_1,UNIALG_2,FUNCT_2,PBOOLE,FUNCT_5,CARD_3,FUNCT_4,FINSEQ_3,RELAT_1,RELSET_1,ORDINAL1,XBOOLE_0,XBOOLE_1,MARGREL1,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB16,CKB17,CKB18,CKB19,CKB21,CKB22,CKB23,CKB27,CKB31,CKB33,CKB35,CKB37,CKB39,CKB40,CKB43,CKB50,CKB51,CKB52,CKB53;
schemes FINSEQ_1,PARTFUN1,FUNCT_2,FUNCT_1,CLASSES1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,PARTFUN1,FUNCOP_1,FINSEQ_1,FINSEQ_2,CARD_3,PBOOLE,STRUCT_0,UNIALG_1,CARD_1,RELSET_1,MARGREL1,CKB15,CKB20,CKB24,CKB25,CKB26,CKB28,CKB32,CKB34,CKB38,CKB41,CKB42,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49;
constructors BINOP_1,DOMAIN_1,FUNCT_4,FUNCT_5,CARD_3,PBOOLE,UNIALG_2,DTCONSTR,STRUCT_0,RELSET_1,CKB1,CKB2,CKB3,CKB4,CKB6,CKB7,CKB14,CKB17,CKB21,CKB22,CKB23,CKB27,CKB29,CKB30,CKB31,CKB33,CKB35,CKB36,CKB37,CKB40,CKB43,CKB50,CKB51,CKB52,CKB53;
requirements BOOLE,SUBSET;
begin
reserve n for Nat;
reserve x for set;
reserve y for set;
reserve A for non  empty set;
definition
let J being non  empty set;
let A being  equal-signature  Univ_Alg-yielding (ManySortedSet of J);
func ProdOpSeq A -> (PFuncFinSequence of ( product ( Carrier A ) )) means 
:Def23: (( len it ) = ( len ( ComSign A ) ) & (for n holds (n in ( dom it ) implies ( it . n ) = [[: ( ProdOp (A,n) ) :]])));
existence
proof
set f = ( ComSign A );
defpred P[ Nat,set ]
 means
$2 = [[: ( ProdOp (A,$1) ) :]];
A1: (for k being Nat holds (k in ( Seg ( len f ) ) implies (ex x being (Element of ( PFuncs (( ( product ( Carrier A ) ) * ),( product ( Carrier A ) )) )) st P[ k,x ])))
proof
let k being Nat;
assume k in ( Seg ( len f ) );
reconsider a = [[: ( ProdOp (A,k) ) :]] as (Element of ( PFuncs (( ( product ( Carrier A ) ) * ),( product ( Carrier A ) )) )) by PARTFUN1:45;
take a;
thus thesis;
end;
consider p being (FinSequence of ( PFuncs (( ( product ( Carrier A ) ) * ),( product ( Carrier A ) )) )) such that A2: (( dom p ) = ( Seg ( len f ) ) & (for k being Nat holds (k in ( Seg ( len f ) ) implies P[ k,( p . k ) ]))) from FINSEQ_1:sch 5(A1);
reconsider p as (PFuncFinSequence of ( product ( Carrier A ) ));
take p;
thus ( len p ) = ( len f ) by A2,FINSEQ_1:def 3;
let n;
assume n in ( dom p );
hence thesis by A2;
end;
uniqueness
proof
let x being (PFuncFinSequence of ( product ( Carrier A ) ));
let y being (PFuncFinSequence of ( product ( Carrier A ) ));
assume that
A3: ( len x ) = ( len ( ComSign A ) )
and
A4: (for n holds (n in ( dom x ) implies ( x . n ) = [[: ( ProdOp (A,n) ) :]]))
and
A5: ( len y ) = ( len ( ComSign A ) )
and
A6: (for n holds (n in ( dom y ) implies ( y . n ) = [[: ( ProdOp (A,n) ) :]]));
A7: ( dom x ) = ( Seg ( len ( ComSign A ) ) ) by A3,FINSEQ_1:def 3;
now
let n being Nat;
assume n in ( dom x );
then (n in ( dom y ) & ( x . n ) = [[: ( ProdOp (A,n) ) :]]) by A4,A5,A7,FINSEQ_1:def 3;
hence ( x . n ) = ( y . n ) by A6;
end;
hence thesis by A3,A5,FINSEQ_2:9;
end;
end;
