environ
vocabularies UNIALG_1,NAT_1,XBOOLE_0,FINSEQ_1,ZFMISC_1,MCART_1,RELAT_1,FUNCT_1,FUNCT_2,PARTFUN1,FINSEQ_2,SUBSET_1,TARSKI,NUMBERS,STRUCT_0,CQC_SIM1,UNIALG_2,ORDINAL1,PBOOLE,FUNCOP_1,RLVECT_2,CARD_3,CARD_1,FINSEQ_4,FUNCT_5,PRALG_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,NUMBERS,NAT_1,STRUCT_0,RELAT_1,FUNCT_1,FINSEQ_1,FUNCT_2,BINOP_1,FUNCOP_1,MCART_1,DOMAIN_1,PARTFUN1,FINSEQ_2,FUNCT_4,FUNCT_5,CARD_3,MARGREL1,DTCONSTR,UNIALG_1,UNIALG_2,PBOOLE,CKB1,CKB2,CKB3,CKB4,CKB6,CKB7,CKB14,CKB17,CKB21,CKB22,CKB23,CKB27,CKB29,CKB30,CKB31,CKB33,CKB35,CKB36,CKB37,CKB40,CKB43,CKB50,CKB51,CKB52,CKB53,CKB54;
definitions TARSKI,UNIALG_1,UNIALG_2,FUNCT_1,PBOOLE,XBOOLE_0,BINOP_1,FINSEQ_2,FUNCOP_1,PARTFUN1,MARGREL1,CKB1,CKB2,CKB3,CKB4,CKB6,CKB7,CKB14,CKB17,CKB21,CKB22,CKB23,CKB27,CKB31,CKB33,CKB35,CKB37,CKB40,CKB43,CKB50,CKB51,CKB52,CKB53,CKB54;
theorems TARSKI,FUNCT_1,PARTFUN1,FINSEQ_1,FINSEQ_2,FUNCOP_1,UNIALG_1,DOMAIN_1,ZFMISC_1,MCART_1,UNIALG_2,FUNCT_2,PBOOLE,FUNCT_5,CARD_3,FUNCT_4,FINSEQ_3,RELAT_1,RELSET_1,ORDINAL1,XBOOLE_0,XBOOLE_1,MARGREL1,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB16,CKB17,CKB18,CKB19,CKB21,CKB22,CKB23,CKB27,CKB31,CKB33,CKB35,CKB37,CKB39,CKB40,CKB43,CKB50,CKB51,CKB52,CKB53,CKB54;
schemes FINSEQ_1,PARTFUN1,FUNCT_2,FUNCT_1,CLASSES1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,PARTFUN1,FUNCOP_1,FINSEQ_1,FINSEQ_2,CARD_3,PBOOLE,STRUCT_0,UNIALG_1,CARD_1,RELSET_1,MARGREL1,CKB15,CKB20,CKB24,CKB25,CKB26,CKB28,CKB32,CKB34,CKB38,CKB41,CKB42,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49;
constructors BINOP_1,DOMAIN_1,FUNCT_4,FUNCT_5,CARD_3,PBOOLE,UNIALG_2,DTCONSTR,STRUCT_0,RELSET_1,CKB1,CKB2,CKB3,CKB4,CKB6,CKB7,CKB14,CKB17,CKB21,CKB22,CKB23,CKB27,CKB29,CKB30,CKB31,CKB33,CKB35,CKB36,CKB37,CKB40,CKB43,CKB50,CKB51,CKB52,CKB53,CKB54;
requirements BOOLE,SUBSET;
begin
definition
let J being non empty set;
let A being  equal-signature  Univ_Alg-yielding (ManySortedSet of J);
func ProdUnivAlg A ->  strict Universal_Algebra
equals
UAStr (# ( product ( Carrier A ) ),( ProdOpSeq A ) #);
coherence
proof
set j = the (Element of J);
set ua = UAStr (# ( product ( Carrier A ) ),( ProdOpSeq A ) #);
set pr = ( product ( Carrier A ) );
(for n being Nat holds (for h being (PartFunc of ( pr * ),pr) holds ((n in ( dom (the charact of ua) ) & h = ( (the charact of ua) . n )) implies h is  quasi_total)))
proof
let n being Nat;
let h being (PartFunc of ( pr * ),pr);
assume that
A1: n in ( dom (the charact of ua) )
and
A2: ( (the charact of ua) . n ) = h;
( (the charact of ua) . n ) = [[: ( ProdOp (A,n) ) :]] by A1,CKB54:def 1;
hence thesis by A2;
end;
then A3: (the charact of ua) is  quasi_total by MARGREL1:def 24;
(for n being Nat holds (for h being (PartFunc of ( pr * ),pr) holds ((n in ( dom (the charact of ua) ) & h = ( (the charact of ua) . n )) implies h is  homogeneous)))
proof
let n being Nat;
let h being (PartFunc of ( pr * ),pr);
assume that
A4: n in ( dom (the charact of ua) )
and
A5: ( (the charact of ua) . n ) = h;
( (the charact of ua) . n ) = [[: ( ProdOp (A,n) ) :]] by A4,CKB54:def 1;
hence thesis by A5;
end;
then A6: (the charact of ua) is  homogeneous by MARGREL1:def 23;
(for n being set holds (n in ( dom (the charact of ua) ) implies ( (the charact of ua) . n ) is non empty))
proof
let n being set;
assume A7: n in ( dom (the charact of ua) );
then reconsider n9 = n as (Element of ( NAT ));
( (the charact of ua) . n ) = [[: ( ProdOp (A,n9) ) :]] by A7,CKB54:def 1;
hence thesis;
end;
then A8: (the charact of ua) is  non-empty by FUNCT_1:def 9;
( len (the charact of ua) ) = ( len ( ComSign A ) ) by CKB54:def 1
.= ( len ( signature ( A . j ) ) ) by CKB33:def 1
.= ( len (the charact of ( A . j )) ) by UNIALG_1:def 4;
then (the charact of ua) <> ( {} );
hence thesis by A3,A6,A8,UNIALG_1:def 1,UNIALG_1:def 2,UNIALG_1:def 3;
end;
end;
