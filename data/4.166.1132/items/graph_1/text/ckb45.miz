environ
vocabularies NUMBERS,SUBSET_1,STRUCT_0,FUNCT_1,GLIB_000,XBOOLE_0,FUNCT_5,RELAT_1,PARTFUN1,RELAT_2,FINSET_1,TREES_2,FINSEQ_1,XXREAL_0,ARYTM_3,TARSKI,CARD_1,FUNCT_2,ZFMISC_1,MCART_1,GRAPH_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,RELSET_1,FUNCT_2,FUNCT_5,FINSEQ_1,FINSET_1,PARTFUN1,CARD_1,NUMBERS,NAT_1,MCART_1,XXREAL_0,STRUCT_0,CKB1,CKB2,CKB3,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB19,CKB20,CKB21,CKB23,CKB24,CKB27,CKB28,CKB29,CKB30,CKB32,CKB33,CKB34,CKB36,CKB37,CKB38,CKB39,CKB40,CKB43;
definitions FUNCT_1,TARSKI,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB19,CKB20,CKB21,CKB24,CKB27,CKB30,CKB34,CKB36,CKB37,CKB38,CKB39,CKB40,CKB43;
theorems FUNCT_2,FUNCT_1,PARTFUN1,FINSEQ_1,NAT_1,ZFMISC_1,MCART_1,TARSKI,RELAT_1,FINSEQ_3,RELSET_1,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,CARD_1,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB19,CKB20,CKB21,CKB22,CKB24,CKB27,CKB30,CKB34,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44;
schemes FUNCT_2,TARSKI,XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,PARTFUN1,FINSET_1,XREAL_0,FINSEQ_1,ORDINAL1,STRUCT_0,CARD_1,FUNCT_2,RELSET_1,CKB1,CKB4,CKB15,CKB16,CKB17,CKB18,CKB25,CKB26,CKB31,CKB35;
constructors PARTFUN1,FUNCT_2,XXREAL_0,XREAL_0,NAT_1,FINSEQ_1,STRUCT_0,FUNCT_5,RELSET_1,CKB1,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB19,CKB20,CKB21,CKB23,CKB24,CKB27,CKB30,CKB34,CKB36,CKB37,CKB38,CKB39,CKB40,CKB43;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve G for Graph;
reserve x for (Element of (the carrier of G));
reserve y for (Element of (the carrier of G));
definition
let G being Graph;
func bool G -> set means 
:Def25: (for x being set holds (x in it iff x is  strict  strict (Subgraph of G)));
existence
proof
reconsider V = (the carrier of G) as non  empty set;
set E = (the carrier' of G);
set Prod = [: ( bool V ),( bool E ),( PFuncs (E,V) ),( PFuncs (E,V) ) :];
defpred P[ set ]
 means
(ex y being (Element of Prod) st (ex M being Graph st (ex v being non  empty set st (ex e being set st (ex s being (Function of e,v) st (ex t being (Function of e,v) st ((((((y = $1 & v = ( y `1 )) & e = ( y `2 )) & s = ( y `3 )) & t = ( y `4 )) & M = MultiGraphStruct (# v,e,s,t #)) & M is (Subgraph of G))))))));
consider X being set such that A1: (for x being set holds (x in X iff (x in Prod & P[ x ]))) from XBOOLE_0:sch 1;
defpred P[ set,set ]
 means
(ex y being (Element of Prod) st (ex M being  strict Graph st (ex v being non  empty set st (ex e being set st (ex s being (Function of e,v) st (ex t being (Function of e,v) st (((((((y = $1 & v = ( y `1 )) & e = ( y `2 )) & s = ( y `3 )) & t = ( y `4 )) & M = MultiGraphStruct (# v,e,s,t #)) & M is (Subgraph of G)) & $2 = M)))))));
A2: (for a,b,c being set holds ((P[ a,b ] & P[ a,c ]) implies b = c));
consider Y being set such that A3: (for z being set holds (z in Y iff (ex x being set st (x in X & P[ x,z ])))) from TARSKI:sch 1(A2);
take Y;
let x being set;
thus (x in Y implies x is  strict  strict (Subgraph of G))
proof
assume x in Y;
then (ex z being set st (z in X & P[ z,x ])) by A3;
hence thesis;
end;

assume x is  strict  strict (Subgraph of G);
then reconsider H = x as  strict (Subgraph of G);
(ex y being set st (y in X & P[ y,x ]))
proof
take y = [ (the carrier of H),(the carrier' of H),(the Source of H),(the Target of H) ];
A4: ((the carrier of H) c= V & (the carrier' of H) c= E) by CKB34:def 1;
((the Source of H) in ( PFuncs (E,V) ) & (the Target of H) in ( PFuncs (E,V) )) by CKB44:1;
then reconsider y9 = y as (Element of Prod) by A4,MCART_1:80;
reconsider v = (the carrier of H) as non  empty set;
set e = (the carrier' of H);
reconsider s = (the Source of H) as (Function of e,v);
reconsider t = (the Target of H) as (Function of e,v);
A5: (v = ( y9 `1 ) & e = ( y9 `2 )) by MCART_1:55;
A6: (s = ( y9 `3 ) & t = ( y9 `4 )) by MCART_1:55;
hence y in X by A1,A5;
thus thesis by A5,A6;
end;
hence thesis by A3;
end;
uniqueness
proof
defpred P[ set ]
 means
$1 is  strict  strict (Subgraph of G);
let X1 being set;
let X2 being set;
assume that
A7: (for x being set holds (x in X1 iff P[ x ]))
and
A8: (for x being set holds (x in X2 iff P[ x ]));
thus X1 = X2 from XBOOLE_0:sch 2(A7,A8);
end;
end;
