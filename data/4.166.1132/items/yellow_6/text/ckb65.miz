environ
vocabularies CLASSES2,CLASSES1,ORDINAL1,XBOOLE_0,FUNCT_1,RELAT_1,TARSKI,CARD_3,CARD_1,FUNCT_2,PRALG_1,PBOOLE,SUBSET_1,RLVECT_2,STRUCT_0,FUNCOP_1,WAYBEL_3,YELLOW_1,ORDERS_2,WAYBEL_0,XXREAL_0,EQREL_1,RELAT_2,ZFMISC_1,CAT_1,YELLOW_0,WELLORD1,PRE_TOPC,RCOMP_1,CONNSP_2,COMPTS_1,MCART_1,TOPS_1,SEQ_2,ORDINAL2,SETFAM_1,YELLOW_6;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,SETFAM_1,MCART_1,RELAT_1,FUNCT_1,PBOOLE,RELSET_1,PARTFUN1,FUNCT_2,BINOP_1,CARD_1,CARD_3,FUNCOP_1,ORDINAL1,CLASSES1,CLASSES2,TOLER_1,STRUCT_0,TOPS_1,COMPTS_1,CONNSP_2,PRALG_1,ORDERS_2,LATTICE3,PRE_TOPC,YELLOW_0,WAYBEL_0,YELLOW_1,YELLOW_3,WAYBEL_3,CKB1,CKB7,CKB8,CKB15,CKB20,CKB26,CKB27,CKB37,CKB41,CKB50,CKB52,CKB60;
definitions TARSKI,STRUCT_0,WAYBEL_0,PRALG_1,YELLOW_1,COMPTS_1,YELLOW_0,RELAT_1,PRE_TOPC,WAYBEL_3,BINOP_1,SUBSET_1,WELLORD1,CKB1,CKB8,CKB15,CKB26,CKB27,CKB37,CKB41,CKB50,CKB52,CKB60;
theorems CONNSP_2,TOPS_1,FUNCOP_1,WAYBEL_0,PRE_TOPC,ORDERS_2,RELAT_1,FUNCT_2,ZFMISC_1,FUNCT_1,TARSKI,PBOOLE,YELLOW_1,CARD_3,PRALG_1,YELLOW_3,RELSET_1,DOMAIN_1,YELLOW_0,CLASSES2,CLASSES1,CARD_2,FUNCT_6,LATTICE3,MCART_1,SUBSET_1,WAYBEL_3,XBOOLE_0,XBOOLE_1,ORDINAL1,REALSET1,PARTFUN1,CKB1,CKB4,CKB5,CKB8,CKB15,CKB18,CKB19,CKB24,CKB25,CKB26,CKB27,CKB32,CKB33,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB45,CKB46,CKB47,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56,CKB57,CKB58,CKB59,CKB60,CKB62,CKB63,CKB64;
schemes PBOOLE,FUNCT_7,SUBSET_1,RELSET_1,DOMAIN_1,MSSUBFAM,FUNCT_2,XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,ORDINAL1,FUNCT_2,FUNCOP_1,CARD_1,CLASSES1,CARD_3,CLASSES2,PBOOLE,STRUCT_0,ORDERS_2,PCOMPS_1,LATTICE3,YELLOW_0,WAYBEL_0,PARTFUN1,YELLOW_1,YELLOW_3,WAYBEL_3,RELSET_1,TOPS_1,CKB2,CKB3,CKB6,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB16,CKB17,CKB21,CKB22,CKB23,CKB28,CKB29,CKB30,CKB31,CKB34,CKB43,CKB44,CKB48,CKB49,CKB61;
constructors BINOP_1,CLASSES1,TOLER_1,CLASSES2,REALSET1,TOPS_1,COMPTS_1,CONNSP_2,LATTICE3,PRALG_1,YELLOW_3,WAYBEL_3,RELSET_1,PBOOLE,CKB1,CKB20,CKB26,CKB27,CKB37,CKB41,CKB50,CKB52,CKB60;
requirements BOOLE,SUBSET;
begin
reserve x for set;
reserve y for set;
reserve z for set;
definition
let X being non empty 1-sorted;
func NetUniv X
means
:Def14: (for x holds (x in it iff (ex N being  strict (net of X) st (N = x & (the carrier of N) in ( the_universe_of (the carrier of X) )))));
existence
proof
deffunc f(set) = { NetStr (# $1,r,f #) where r is (Relation of $1,$1),f is (Element of ( Funcs ($1,(the carrier of X)) )): NetStr (# $1,r,f #) is (net of X) };
set I = ( the_universe_of (the carrier of X) );
consider M being (ManySortedSet of I) such that A1: (for i being set holds (i in I implies ( M . i ) = f(i))) from PBOOLE:sch 4;
take IT = ( Union M );
let x;
A2: ( Union M ) = ( union ( rng M ) ) by CARD_3:def 4;
hereby
assume x in IT;
then consider y such that A3: x in y and A4: y in ( rng M ) by A2,TARSKI:def 4;
consider z such that A5: z in ( dom M ) and A6: ( M . z ) = y by A4,FUNCT_1:def 3;
z in I by A5,PARTFUN1:def 2;
then y = { NetStr (# z,r,f #) where r is (Relation of z,z),f is (Element of ( Funcs (z,(the carrier of X)) )): NetStr (# z,r,f #) is (net of X) } by A1,A6;
then consider r being (Relation of z,z),f being (Element of ( Funcs (z,(the carrier of X)) )) such that A7: x = NetStr (# z,r,f #) and A8: NetStr (# z,r,f #) is (net of X) by A3;
reconsider N = NetStr (# z,r,f #) as  strict (net of X) by A8;
take N;
thus N = x by A7;
thus (the carrier of N) in ( the_universe_of (the carrier of X) ) by A5,PARTFUN1:def 2;
end;
given N being  strict (net of X) such that
A9: N = x
and
A10: (the carrier of N) in ( the_universe_of (the carrier of X) );

set i = (the carrier of N);
i in ( dom M ) by A10,PARTFUN1:def 2;
then A11: ( M . i ) in ( rng M ) by FUNCT_1:def 3;
A12: (the mapping of N) in ( Funcs (i,(the carrier of X)) ) by FUNCT_2:8;
( M . i ) = { NetStr (# i,r,f #) where r is (Relation of i,i),f is (Element of ( Funcs (i,(the carrier of X)) )): NetStr (# i,r,f #) is (net of X) } by A1,A10;
then N in ( M . i ) by A12;
hence thesis by A2,A9,A11,TARSKI:def 4;
end;
uniqueness
proof
defpred P[ set ]
 means
(ex N being  strict (net of X) st (N = $1 & (the carrier of N) in ( the_universe_of (the carrier of X) )));
thus (for X1,X2 being set holds (((for x being set holds (x in X1 iff P[ x ])) & (for x being set holds (x in X2 iff P[ x ]))) implies X1 = X2)) from XBOOLE_0:sch 3;
end;
end;
