environ
vocabularies CAT_1,STRUCT_0,FUNCT_1,XBOOLE_0,SUBSET_1,ZFMISC_1,TARSKI,MCART_1,RELAT_1,GRAPH_1,PARTFUN1,CAT_2,FUNCOP_1,FUNCT_3,COMMACAT;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,BINOP_1,FUNCOP_1,STRUCT_0,GRAPH_1,CAT_1,CAT_2,MCART_1,DOMAIN_1,CKB1;
definitions TARSKI,XBOOLE_0,CAT_1,BINOP_1,FUNCOP_1,GRAPH_1,CKB1;
theorems TARSKI,ZFMISC_1,MCART_1,FUNCT_1,FUNCT_2,CAT_1,CAT_2,GRFUNC_1,RELSET_1,FUNCOP_1,CKB1,CKB2;
schemes FUNCT_2,CLASSES1;
registrations XBOOLE_0,SUBSET_1,RELSET_1,CAT_1,CAT_2,STRUCT_0;
constructors DOMAIN_1,CAT_2,FUNCOP_1,RELSET_1,CKB1;
requirements SUBSET,BOOLE;
begin
reserve C for Category;
reserve D for Category;
reserve E for Category;
reserve c for (Object of C);
reserve c1 for (Object of C);
reserve d for (Object of D);
reserve d1 for (Object of D);
reserve x for set;
reserve f for (Morphism of E);
reserve f1 for (Morphism of E);
reserve g for (Morphism of C);
reserve h for (Morphism of D);
reserve F for (Functor of C,E);
reserve G for (Functor of D,E);
reserve o1 for (Element of ( commaObjs (F,G) ));
reserve o2 for (Element of ( commaObjs (F,G) ));
definition
let C;
let D;
let E;
let F;
let G;
given c1,d1,f1 such that
A1: f1 in ( Hom (( F . c1 ),( G . d1 )) );

func commaMorphs (F,G) -> non empty (Subset of [: [: ( commaObjs (F,G) ),( commaObjs (F,G) ) :],[: (the carrier' of C),(the carrier' of D) :] :])
equals
:Def6: { [ [ o1,o2 ],[ g,h ] ]: ((((( dom g ) = ( o1 `11 ) & ( cod g ) = ( o2 `11 )) & ( dom h ) = ( o1 `12 )) & ( cod h ) = ( o2 `12 )) & ( ( o2 `2 ) * ( F . g ) ) = ( ( G . h ) * ( o1 `2 ) )) };
coherence
proof
( commaObjs (F,G) ) = { [ [ c,d ],f ]: f in ( Hom (( F . c ),( G . d )) ) } by A1,CKB1:def 1;
then [ [ c1,d1 ],f1 ] in ( commaObjs (F,G) ) by A1;
then reconsider o = [ [ c1,d1 ],f1 ] as (Element of ( commaObjs (F,G) ));
set X = { [ [ o1,o2 ],[ g,h ] ]: ((((( dom g ) = ( o1 `11 ) & ( cod g ) = ( o2 `11 )) & ( dom h ) = ( o1 `12 )) & ( cod h ) = ( o2 `12 )) & ( ( o2 `2 ) * ( F . g ) ) = ( ( G . h ) * ( o1 `2 ) )) };
A2: (( dom ( id d1 ) ) = d1 & ( cod ( id d1 ) ) = d1) by CAT_1:19;
A3: (( ( o `1 ) `1 ) = ( o `11 ) & ( ( o `1 ) `2 ) = ( o `12 )) by MCART_1:def 14,MCART_1:def 15;
A4: X c= [: [: ( commaObjs (F,G) ),( commaObjs (F,G) ) :],[: (the carrier' of C),(the carrier' of D) :] :]
proof
let x;
assume x in X;
then (ex g st (ex h st (ex o1 st (ex o2 st (((((x = [ [ o1,o2 ],[ g,h ] ] & ( dom g ) = ( o1 `11 )) & ( cod g ) = ( o2 `11 )) & ( dom h ) = ( o1 `12 )) & ( cod h ) = ( o2 `12 )) & ( ( o2 `2 ) * ( F . g ) ) = ( ( G . h ) * ( o1 `2 ) ))))));
hence thesis;
end;
A5: (( [ c1,d1 ] `2 ) = d1 & ( o `2 ) = f1) by MCART_1:7;
A6: (( o `1 ) = [ c1,d1 ] & ( [ c1,d1 ] `1 ) = c1) by MCART_1:7;
( cod f1 ) = ( G . d1 ) by A1,CAT_1:1;
then A7: ( ( id ( G . d1 ) ) * f1 ) = f1 by CAT_1:21;
( dom f1 ) = ( F . c1 ) by A1,CAT_1:1;
then A8: ( f1 * ( id ( F . c1 ) ) ) = f1 by CAT_1:22;
A9: (( F . ( id c1 ) ) = ( id ( F . c1 ) ) & ( G . ( id d1 ) ) = ( id ( G . d1 ) )) by CAT_1:71;
(( dom ( id c1 ) ) = c1 & ( cod ( id c1 ) ) = c1) by CAT_1:19;
then [ [ o,o ],[ ( id c1 ),( id d1 ) ] ] in X by A2,A3,A6,A5,A8,A7,A9;
hence thesis by A4;
end;
end;
