environ
vocabularies CAT_1,STRUCT_0,FUNCT_1,XBOOLE_0,SUBSET_1,ZFMISC_1,TARSKI,MCART_1,RELAT_1,GRAPH_1,PARTFUN1,CAT_2,FUNCOP_1,FUNCT_3,COMMACAT;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,BINOP_1,FUNCOP_1,STRUCT_0,GRAPH_1,CAT_1,CAT_2,MCART_1,DOMAIN_1;
definitions TARSKI,XBOOLE_0,CAT_1,BINOP_1,FUNCOP_1,GRAPH_1;
theorems TARSKI,ZFMISC_1,MCART_1,FUNCT_1,FUNCT_2,CAT_1,CAT_2,GRFUNC_1,RELSET_1,FUNCOP_1;
schemes FUNCT_2,CLASSES1;
registrations XBOOLE_0,SUBSET_1,RELSET_1,CAT_1,CAT_2,STRUCT_0;
constructors DOMAIN_1,CAT_2,FUNCOP_1,RELSET_1;
requirements SUBSET,BOOLE;
begin
reserve C for Category;
reserve D for Category;
reserve E for Category;
reserve c for (Object of C);
reserve c1 for (Object of C);
reserve d for (Object of D);
reserve d1 for (Object of D);
reserve x for set;
reserve f for (Morphism of E);
reserve f1 for (Morphism of E);
definition
let C;
let D;
let E;
let F being (Functor of C,E);
let G being (Functor of D,E);
given c1,d1,f1 such that
A1: f1 in ( Hom (( F . c1 ),( G . d1 )) );

func commaObjs (F,G) -> non empty (Subset of [: [: (the carrier of C),(the carrier of D) :],(the carrier' of E) :])
equals
:Def5: { [ [ c,d ],f ]: f in ( Hom (( F . c ),( G . d )) ) };
coherence
proof
A2: { [ [ c,d ],f ]: f in ( Hom (( F . c ),( G . d )) ) } c= [: [: (the carrier of C),(the carrier of D) :],(the carrier' of E) :]
proof
let x;
assume x in { [ [ c,d ],f ]: f in ( Hom (( F . c ),( G . d )) ) };
then (ex c st (ex d st (ex f st (x = [ [ c,d ],f ] & f in ( Hom (( F . c ),( G . d )) )))));
hence thesis;
end;
[ [ c1,d1 ],f1 ] in { [ [ c,d ],f ]: f in ( Hom (( F . c ),( G . d )) ) } by A1;
hence thesis by A2;
end;
end;
