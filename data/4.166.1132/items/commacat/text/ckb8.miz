environ
vocabularies CAT_1,STRUCT_0,FUNCT_1,XBOOLE_0,SUBSET_1,ZFMISC_1,TARSKI,MCART_1,RELAT_1,GRAPH_1,PARTFUN1,CAT_2,FUNCOP_1,FUNCT_3,COMMACAT;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,BINOP_1,FUNCOP_1,STRUCT_0,GRAPH_1,CAT_1,CAT_2,MCART_1,DOMAIN_1,CKB1,CKB3,CKB4,CKB5,CKB7;
definitions TARSKI,XBOOLE_0,CAT_1,BINOP_1,FUNCOP_1,GRAPH_1,CKB1,CKB3,CKB7;
theorems TARSKI,ZFMISC_1,MCART_1,FUNCT_1,FUNCT_2,CAT_1,CAT_2,GRFUNC_1,RELSET_1,FUNCOP_1,CKB1,CKB2,CKB3,CKB6,CKB7;
schemes FUNCT_2,CLASSES1;
registrations XBOOLE_0,SUBSET_1,RELSET_1,CAT_1,CAT_2,STRUCT_0;
constructors DOMAIN_1,CAT_2,FUNCOP_1,RELSET_1,CKB1,CKB3,CKB4,CKB5,CKB7;
requirements SUBSET,BOOLE;
begin
reserve y for set;
reserve C for Category;
reserve D for Category;
reserve E for Category;
reserve x for set;
reserve F for (Functor of C,E);
reserve G for (Functor of D,E);
reserve k for (Element of ( commaMorphs (F,G) ));
reserve k1 for (Element of ( commaMorphs (F,G) ));
reserve k2 for (Element of ( commaMorphs (F,G) ));
reserve k9 for (Element of ( commaMorphs (F,G) ));
definition
let C;
let D;
let E;
let F;
let G;
func commaComp (F,G) -> (PartFunc of [: ( commaMorphs (F,G) ),( commaMorphs (F,G) ) :],( commaMorphs (F,G) ))
means
:Def8: (( dom it ) = { [ k1,k2 ]: ( k1 `11 ) = ( k2 `12 ) } & (for k holds (for k9 holds ([ k,k9 ] in ( dom it ) implies ( it . [ k,k9 ] ) = ( k * k9 )))));
existence
proof
defpred P[ set,set ]
 means
(ex k1 st (ex k2 st ($1 = [ k1,k2 ] & $2 = ( k1 * k2 ))));
set X = { [ k1,k2 ]: ( k1 `11 ) = ( k2 `12 ) };
A1: (for x holds (x in X implies (ex y st P[ x,y ])))
proof
let x;
assume x in X;
then consider k1,k2 such that A2: x = [ k1,k2 ] and ( k1 `11 ) = ( k2 `12 );
reconsider y = ( k1 * k2 ) as set;
take y;
take k1;
take k2;
thus thesis by A2;
end;
consider f being Function such that A3: (( dom f ) = X & (for x holds (x in X implies P[ x,( f . x ) ]))) from CLASSES1:sch 1(A1);
A4: ( rng f ) c= ( commaMorphs (F,G) )
proof
let x;
assume x in ( rng f );
then consider y such that A5: y in ( dom f ) and A6: x = ( f . y ) by FUNCT_1:def 3;
(ex k1 st (ex k2 st (y = [ k1,k2 ] & ( f . y ) = ( k1 * k2 )))) by A3,A5;
hence thesis by A6;
end;
( dom f ) c= [: ( commaMorphs (F,G) ),( commaMorphs (F,G) ) :]
proof
let x;
assume x in ( dom f );
then (ex k1 st (ex k2 st (x = [ k1,k2 ] & ( k1 `11 ) = ( k2 `12 )))) by A3;
hence thesis;
end;
then reconsider f as (PartFunc of [: ( commaMorphs (F,G) ),( commaMorphs (F,G) ) :],( commaMorphs (F,G) )) by A4,RELSET_1:4;
take f;
thus ( dom f ) = X by A3;
let k1;
let k2;
assume [ k1,k2 ] in ( dom f );
then consider k,k9 such that A7: [ k1,k2 ] = [ k,k9 ] and A8: ( f . [ k1,k2 ] ) = ( k * k9 ) by A3;
k1 = k by A7,ZFMISC_1:27;
hence thesis by A7,A8,ZFMISC_1:27;
end;
uniqueness
proof
let f1 being (PartFunc of [: ( commaMorphs (F,G) ),( commaMorphs (F,G) ) :],( commaMorphs (F,G) )),f2 being (PartFunc of [: ( commaMorphs (F,G) ),( commaMorphs (F,G) ) :],( commaMorphs (F,G) ));
assume that
A9: (( dom f1 ) = { [ k1,k2 ]: ( k1 `11 ) = ( k2 `12 ) } & (for k holds (for k9 holds ([ k,k9 ] in ( dom f1 ) implies ( f1 . [ k,k9 ] ) = ( k * k9 )))))
and
A10: (( dom f2 ) = { [ k1,k2 ]: ( k1 `11 ) = ( k2 `12 ) } & (for k holds (for k9 holds ([ k,k9 ] in ( dom f2 ) implies ( f2 . [ k,k9 ] ) = ( k * k9 )))));
now
let x;
assume A11: x in { [ k1,k2 ]: ( k1 `11 ) = ( k2 `12 ) };
then consider k1,k2 such that A12: x = [ k1,k2 ] and ( k1 `11 ) = ( k2 `12 );
thus ( f1 . x ) = ( k1 * k2 ) by A9,A11,A12
.= ( f2 . x ) by A10,A11,A12;
end;
hence thesis by A9,A10,FUNCT_1:2;
end;
end;
