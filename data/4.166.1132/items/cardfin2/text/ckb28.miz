environ
vocabularies FUNCT_1,INT_1,ARYTM_1,ARYTM_3,CARD_1,FUNCT_2,NAT_1,CARD_3,FINSET_1,ORDINAL2,RPR_1,CARDFIN2,ABIAN,POWER,COMPLEX1,AFINSQ_1,RELAT_1,XCMPLX_0,SIN_COS,SERIES_1,TAYLOR_1,SUBSET_1,FDIFF_1,FINSEQ_1,TARSKI,REAL_1,FINSOP_1,NEWTON,ORDINAL1,REALSET1,XXREAL_0,XBOOLE_0,XXREAL_1,VALUED_1,NUMBERS,BINOP_2,XREAL_0,CKB18,CKB19;
notations TARSKI,XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,RELSET_1,PARTFUN1,FUNCT_2,BINOP_1,FINSET_1,CARD_1,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,REAL_1,NAT_1,NAT_D,INT_1,COMPLEX1,BINOP_2,VALUED_1,NEWTON,RCOMP_1,FCONT_1,POWER,SERIES_1,SEQFUNC,SIN_COS,AFINSQ_1,ABIAN,TAYLOR_1,STIRL2_1,CARD_FIN,RPR_1,AFINSQ_2,CKB5,CKB10,CKB18,CKB19,CKB20,CKB26;
definitions XBOOLE_0,TARSKI,XCMPLX_0,SUBSET_1,SIN_COS,RELAT_1,CKB5,CKB10,CKB18,CKB19,CKB20,CKB26;
theorems CARD_2,CARD_FIN,FUNCT_2,XBOOLE_0,NEWTON,XREAL_0,XCMPLX_1,RPR_1,XREAL_1,XCMPLX_0,INT_1,ORDINAL1,CARD_1,TAYLOR_1,SIN_COS,TAYLOR_2,XXREAL_1,ABIAN,STIRL2_1,SERIES_1,SEQ_1,SIN_COS2,NAT_1,TARSKI,BINOP_2,IRRAT_1,SEQ_2,FIB_NUM2,SIN_COS7,XXREAL_0,ALTCAT_1,RELAT_1,VALUED_1,VALUED_0,FUNCT_1,AFINSQ_2,XBOOLE_1,POWER,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB23,CKB24,CKB25,CKB26;
schemes RECDEF_2,FIB_NUM,NAT_1;
registrations RELSET_1,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,CARD_1,FINSET_1,NUMBERS,SIN_COS,RCOMP_1,VALUED_0,VALUED_1,FUNCT_2,FCONT_3,FCONT_1,AFINSQ_1,POWER,FUNCT_1,BINOP_2,WSIERP_1,XCMPLX_0,XBOOLE_0,RELAT_1,FRAENKEL,AFINSQ_2,ORDINAL1,NEWTON,CKB1,CKB2,CKB11,CKB21,CKB22,CKB27;
constructors REAL_1,SERIES_1,ABIAN,VALUED_1,CARD_FIN,RCOMP_1,SIN_COS,TAYLOR_1,SEQ_1,FCONT_1,SEQFUNC,RELSET_1,STIRL2_1,SETWISEO,YELLOW20,WELLORD2,NAT_D,BINARITH,RPR_1,AFINSQ_2,AFINSQ_1,NEWTON,CKB5,CKB10,CKB18,CKB19,CKB20,CKB26;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve x for set;
scheme FraenkelDiff { s,t() -> set,P[set] } : { f where f is (Function of s(),t()): (not P[ f ]) } = ( ( Funcs (s(),t()) ) \ { f where f is (Function of s(),t()): P[ f ] } )
provided
A1: (t() = ( {} ) implies s() = ( {} ))
proof
set z1 = { f where f is (Function of s(),t()): (not P[ f ]) };
set z2 = { f where f is (Function of s(),t()): P[ f ] };
set zc = ( Funcs (s(),t()) );
thus z1 c= ( zc \ z2 )
proof
let x;
assume x in z1;
then consider f being (Function of s(),t()) such that A2: (x = f & (not P[ f ]));
A3: f in zc by A1,FUNCT_2:8;
(not f in z2)
proof
assume f in z2;
then (ex g being (Function of s(),t()) st (f = g & P[ g ]));
hence thesis by A2;
end;
hence thesis by A3,A2,XBOOLE_0:def 5;
end;

let x;
assume A4: x in ( zc \ z2 );
then A5: x is (Function of s(),t()) by FUNCT_2:66;
(not x in z2) by A4,XBOOLE_0:def 5;
then (not P[ x ]) by A5;
hence thesis by A5;
end;
