environ
vocabularies NUMBERS,SUBSET_1,REAL_1,COMSEQ_1,COMPLEX1,RELAT_1,ARYTM_1,ARYTM_3,CARD_1,XXREAL_0,FUNCT_1,XREAL_0,ORDINAL1,XBOOLE_0,PARTFUN1,VALUED_0,VALUED_1,XXREAL_2,FUNCOP_1,SEQ_2,ORDINAL2,SEQ_1,XCMPLX_0;
notations XBOOLE_0,SUBSET_1,ORDINAL1,NUMBERS,XCMPLX_0,XREAL_0,COMPLEX1,REAL_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,FUNCOP_1,VALUED_1,SEQ_1,SEQ_2,NAT_1,COMSEQ_1,XXREAL_0,CKB3;
definitions VALUED_1,SEQ_2,PARTFUN1,CKB3;
theorems COMSEQ_1,SEQ_2,FINSEQ_2,COMPLEX1,NAT_1,SUBSET_1,FUNCT_2,XREAL_0,XCMPLX_0,XCMPLX_1,FUNCOP_1,XREAL_1,XXREAL_0,VALUED_1,CKB1,CKB2,CKB3;
schemes NAT_1,SEQ_1;
registrations XBOOLE_0,ORDINAL1,RELSET_1,FUNCT_2,NUMBERS,XXREAL_0,XREAL_0,MEMBERED,VALUED_1,VALUED_0;
constructors PARTFUN1,FUNCOP_1,REAL_1,SQUARE_1,NAT_1,COMPLEX1,SEQ_2,VALUED_1,SEQ_1,RELSET_1,CKB3;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
definition
let C being non  empty set;
let f being (Function of C,( COMPLEX ));
redefine func f *' means 
:Def2: (( dom it ) = C & (for n being (Element of C) holds ( it . n ) = ( ( f . n ) *' )));
compatibility
proof
let IT being (PartFunc of C,( COMPLEX ));
thus (IT = ( f *' ) implies (( dom IT ) = C & (for c being (Element of C) holds ( IT . c ) = ( ( f . c ) *' ))))
proof
assume A1: IT = ( f *' );
hence A2: ( dom IT ) = ( dom f ) by CKB3:def 1
.= C by FUNCT_2:def 1;
let c being (Element of C);
( f . c ) = ( f /. c );
hence thesis by A1,A2,CKB3:def 1;
end;

assume (( dom IT ) = C & (for c being (Element of C) holds ( IT . c ) = ( ( f . c ) *' )));
then (( dom IT ) = ( dom f ) & (for c being (Element of C) holds (c in ( dom IT ) implies ( IT . c ) = ( ( f /. c ) *' )))) by FUNCT_2:def 1;
hence IT = ( f *' ) by CKB3:def 1;
end;
end;
