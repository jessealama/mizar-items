environ
vocabularies NUMBERS,SUBSET_1,REAL_1,COMSEQ_1,COMPLEX1,RELAT_1,ARYTM_1,ARYTM_3,CARD_1,XXREAL_0,FUNCT_1,XREAL_0,ORDINAL1,XBOOLE_0,PARTFUN1,VALUED_0,VALUED_1,XXREAL_2,FUNCOP_1,SEQ_2,ORDINAL2,SEQ_1,XCMPLX_0;
notations XBOOLE_0,SUBSET_1,ORDINAL1,NUMBERS,XCMPLX_0,XREAL_0,COMPLEX1,REAL_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,FUNCOP_1,VALUED_1,SEQ_1,SEQ_2,NAT_1,COMSEQ_1,XXREAL_0;
definitions VALUED_1,SEQ_2,PARTFUN1;
theorems COMSEQ_1,SEQ_2,FINSEQ_2,COMPLEX1,NAT_1,SUBSET_1,FUNCT_2,XREAL_0,XCMPLX_0,XCMPLX_1,FUNCOP_1,XREAL_1,XXREAL_0,VALUED_1,CKB1,CKB2;
schemes NAT_1,SEQ_1;
registrations XBOOLE_0,ORDINAL1,RELSET_1,FUNCT_2,NUMBERS,XXREAL_0,XREAL_0,MEMBERED,VALUED_1,VALUED_0;
constructors PARTFUN1,FUNCOP_1,REAL_1,SQUARE_1,NAT_1,COMPLEX1,SEQ_2,VALUED_1,SEQ_1,RELSET_1;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
definition
let C being non  empty set;
let f being (PartFunc of C,( COMPLEX ));
func f *' -> (PartFunc of C,( COMPLEX )) means 
:Def1: (( dom it ) = ( dom f ) & (for c being (Element of C) holds (c in ( dom it ) implies ( it . c ) = ( ( f /. c ) *' ))));
existence
proof
deffunc F(set) = ( ( f /. $1 ) *' );
defpred P[ set ]
 means
$1 in ( dom f );
consider F being (PartFunc of C,( COMPLEX )) such that A1: (for c being (Element of C) holds (c in ( dom F ) iff P[ c ])) and A2: (for c being (Element of C) holds (c in ( dom F ) implies ( F . c ) = F(c))) from SEQ_1:sch 3;
take F;
thus ( dom f ) = ( dom F ) by A1,SUBSET_1:3;
thus thesis by A2;
end;
uniqueness
proof
deffunc F(set) = ( ( f /. $1 ) *' );
thus (for h,g being (PartFunc of C,( COMPLEX )) holds (((( dom h ) = ( dom f ) & (for c being (Element of C) holds (c in ( dom h ) implies ( h . c ) = F(c)))) & (( dom g ) = ( dom f ) & (for c being (Element of C) holds (c in ( dom g ) implies ( g . c ) = F(c))))) implies h = g)) from SEQ_1:sch 4;
end;
end;
