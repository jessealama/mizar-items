environ
vocabularies BINOP_1,VECTSP_1,XBOOLE_0,ALGSTR_0,SUBSET_1,MESFUNC1,RELAT_1,LATTICES,ARYTM_3,FUNCSDOM,VECTSP_2,REAL_1,SUPINF_2,CARD_1,STRUCT_0,RLVECT_1,ARYTM_1,GROUP_1,EQREL_1,TARSKI,SETFAM_1,MSSUBFAM,INT_2,GCD_1;
notations TARSKI,XBOOLE_0,SUBSET_1,REAL_1,NUMBERS,STRUCT_0,ALGSTR_0,RLVECT_1,GROUP_1,VECTSP_2,VECTSP_1,FUNCSDOM,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB33,CKB36;
definitions VECTSP_1,VECTSP_2,XBOOLE_0,CKB8,CKB10,CKB11,CKB14,CKB33,CKB36;
theorems TARSKI,WELLORD2,SUBSET_1,VECTSP_1,VECTSP_2,RLVECT_1,XBOOLE_0,XCMPLX_1,GROUP_1,STRUCT_0,CKB7,CKB8,CKB10,CKB11,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB35,CKB36,CKB38;
schemes SUBSET_1;
registrations XBOOLE_0,SUBSET_1,MEMBERED,STRUCT_0,VECTSP_1,MONOID_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB34,CKB37;
constructors BINOP_2,VECTSP_2,MONOID_0,CKB8,CKB9,CKB10,CKB11,CKB13,CKB14,CKB33,CKB36;
requirements SUBSET,BOOLE;
begin
reserve X for set;
reserve Y for set;
reserve R for  domRing-like  commutative Ring;
definition
let R being  associative  well-unital non  empty multLoopStr;
mode Am of R
 -> non  empty (Subset of R)
means :Def7: ((for a being (Element of R) holds (ex z being (Element of it) st z is_associated_to a)) & (for x,y being (Element of it) holds (x <> y implies x is_not_associated_to y)));
existence
proof
now
let R being  associative  well-unital non  empty multLoopStr;
reconsider M = ( Classes R ) as non  empty set;
A1: (for X holds (X in M implies X <> ( {} )))
proof
let X being set;
assume X in M;
then (ex A being (Element of R) st X = ( Class A )) by CKB36:def 1;
hence thesis;
end;
(for X holds (for Y holds (((X in M & Y in M) & X <> Y) implies X misses Y)))
proof
let X being set;
let Y being set;
assume that
A2: (X in M & Y in M)
and
A3: X <> Y;
assume A4: X meets Y;
((ex A being (Element of R) st X = ( Class A )) & (ex B being (Element of R) st Y = ( Class B ))) by A2,CKB36:def 1;
hence contradiction by A3,A4,CKB35:1;
end;
then consider AmpS9 being set such that A5: (for X holds (X in M implies (ex x being set st ( AmpS9 /\ X ) = { x }))) by A1,WELLORD2:18;
AmpS9 is non  empty
proof
( Class ( 1. R ) ) in M by CKB36:def 1;
then (ex x being set st ( AmpS9 /\ ( Class ( 1. R ) ) ) = { x }) by A5;
hence thesis;
end;
then reconsider AmpS9 as non  empty set;
set AmpS = { x where x is (Element of AmpS9): (ex X being non  empty (Subset of R) st (X in M & ( AmpS9 /\ X ) = { x })) };
A6: AmpS is non  empty non  empty (Subset of R)
proof
AmpS is non  empty
proof
A7: ( Class ( 1. R ) ) in M by CKB36:def 1;
then consider x being set such that A8: ( AmpS9 /\ ( Class ( 1. R ) ) ) = { x } by A5;
x in { x } by TARSKI:def 1;
then x in AmpS9 by A8,XBOOLE_0:def 4;
then x in AmpS by A7,A8;
hence thesis;
end;
then reconsider AmpS as non  empty set;
now
let A being set;
now
assume A in AmpS;
then consider x being (Element of AmpS9) such that A9: (A = x & (ex X being non  empty (Subset of R) st (X in M & ( AmpS9 /\ X ) = { x })));
x in { x } by TARSKI:def 1;
hence (A in AmpS implies A in (the carrier of R)) by A9;
end;
hence (A in AmpS implies A in (the carrier of R));
end;
hence thesis by TARSKI:def 3;
end;
A10: (for X being (Element of M) holds (ex z being (Element of AmpS) st ( AmpS /\ X ) = { z }))
proof
let X being (Element of M);
consider x being set such that A11: ( AmpS9 /\ X ) = { x } by A5;
X in ( Classes R );
then A12: X is non  empty non  empty (Subset of R) by CKB38:1;
A13: x in { x } by TARSKI:def 1;
then x in AmpS9 by A11,XBOOLE_0:def 4;
then A14: x in AmpS by A11,A12;
A15: x in X by A11,A13,XBOOLE_0:def 4;
now
let y being set;
A16:now
assume A17: y in ( AmpS /\ X );
then y in AmpS by XBOOLE_0:def 4;
then A18: (ex zz being (Element of AmpS9) st (y = zz & (ex X being non  empty (Subset of R) st (X in M & ( AmpS9 /\ X ) = { zz }))));
y in X by A17,XBOOLE_0:def 4;
hence (y in ( AmpS /\ X ) implies y in { x }) by A11,A18,XBOOLE_0:def 4;
end;
now
assume y in { x };
then y = x by TARSKI:def 1;
hence (y in { x } implies y in ( AmpS /\ X )) by A15,A14,XBOOLE_0:def 4;
end;
hence (y in { x } iff y in ( AmpS /\ X )) by A16;
end;
then ( AmpS /\ X ) = { x } by TARSKI:1;
hence thesis by A14;
end;
reconsider AmpS as non  empty (Subset of R) by A6;
A19: (for x,y being (Element of AmpS) holds (x <> y implies x is_not_associated_to y))
proof
let x being (Element of AmpS);
let y being (Element of AmpS);
assume A20: x <> y;
x is_associated_to x;
then x in ( Class x ) by CKB33:def 1;
then A21: x in ( AmpS /\ ( Class x ) ) by XBOOLE_0:def 4;
( Class x ) in M by CKB36:def 1;
then consider z being (Element of AmpS) such that A22: ( AmpS /\ ( Class x ) ) = { z } by A10;
assume x is_associated_to y;
then y in ( Class x ) by CKB33:def 1;
then y in ( AmpS /\ ( Class x ) ) by XBOOLE_0:def 4;
then y = z by A22,TARSKI:def 1;
hence thesis by A20,A21,A22,TARSKI:def 1;
end;
(for a being (Element of R) holds (ex z being (Element of AmpS) st z is_associated_to a))
proof
let a being (Element of R);
reconsider N = ( Class a ) as (Element of M) by CKB36:def 1;
consider z being (Element of AmpS) such that A23: ( AmpS /\ N ) = { z } by A10;
z in { z } by TARSKI:def 1;
then z in ( Class a ) by A23,XBOOLE_0:def 4;
then z is_associated_to a by CKB33:def 1;
hence thesis;
end;
hence (ex s being non  empty (Subset of R) st ((for a being (Element of R) holds (ex z being (Element of s) st z is_associated_to a)) & (for x,y being (Element of s) holds (x <> y implies x is_not_associated_to y)))) by A19;
end;
hence thesis;
end;
end;
