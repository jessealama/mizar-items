environ
vocabularies BINOP_1,VECTSP_1,XBOOLE_0,ALGSTR_0,SUBSET_1,MESFUNC1,RELAT_1,LATTICES,ARYTM_3,FUNCSDOM,VECTSP_2,REAL_1,SUPINF_2,CARD_1,STRUCT_0,RLVECT_1,ARYTM_1,GROUP_1,EQREL_1,TARSKI,SETFAM_1,MSSUBFAM,INT_2,GCD_1;
notations TARSKI,XBOOLE_0,SUBSET_1,REAL_1,NUMBERS,STRUCT_0,ALGSTR_0,RLVECT_1,GROUP_1,VECTSP_2,VECTSP_1,FUNCSDOM,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14;
definitions VECTSP_1,VECTSP_2,XBOOLE_0,CKB8,CKB10,CKB11,CKB14;
theorems TARSKI,WELLORD2,SUBSET_1,VECTSP_1,VECTSP_2,RLVECT_1,XBOOLE_0,XCMPLX_1,GROUP_1,STRUCT_0,CKB7,CKB8,CKB10,CKB11,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32;
schemes SUBSET_1;
registrations XBOOLE_0,SUBSET_1,MEMBERED,STRUCT_0,VECTSP_1,MONOID_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6;
constructors BINOP_2,VECTSP_2,MONOID_0,CKB8,CKB9,CKB10,CKB11,CKB13,CKB14;
requirements SUBSET,BOOLE;
begin
reserve R for  domRing-like  commutative Ring;
definition
let R being non  empty multLoopStr;
let a being (Element of R);
func Class a -> (Subset of R) means 
:Def5: (for b being (Element of R) holds (b in it iff b is_associated_to a));
existence
proof
set M = { b where b is (Element of R): b is_associated_to a };
now
let B being set;
now
assume B in M;
then (ex B9 being (Element of R) st (B = B9 & B9 is_associated_to a));
hence (B in M implies B in (the carrier of R));
end;
hence (B in M implies B in (the carrier of R));
end;
then A1: M c= (the carrier of R) by TARSKI:def 3;
now
let A being (Element of R);
(A in M implies A is_associated_to a)
proof
assume A in M;
then (ex A9 being (Element of R) st (A = A9 & A9 is_associated_to a));
hence thesis;
end;
hence (A in M iff A is_associated_to a);
end;
hence thesis by A1;
end;
uniqueness
proof
defpred P[ (Element of R) ]
 means
$1 is_associated_to a;
let X1 being (Subset of R);
let X2 being (Subset of R);
assume that
A2: (for y being (Element of R) holds (y in X1 iff P[ y ]))
and
A3: (for y being (Element of R) holds (y in X2 iff P[ y ]));
thus X1 = X2 from SUBSET_1:sch 2(A2,A3);
end;
end;
