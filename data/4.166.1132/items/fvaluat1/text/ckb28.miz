environ
vocabularies INT_1,VECTSP_1,FUNCT_1,ARYTM_3,ZFMISC_1,RELAT_1,RLVECT_1,FUNCOP_1,ARYTM_1,BINOP_1,FUNCSDOM,REALSET1,LATTICES,GROUP_1,ORDINAL2,IDEAL_1,FINSEQ_1,SUBSET_1,VECTSP_2,FUNCT_3,NUMBERS,GROUP_4,STRUCT_0,RLSUB_1,XXREAL_2,ALGSTR_0,XCMPLX_0,ORDINAL1,REALSET2,NAT_1,REAL_1,INT_2,XXREAL_0,TARSKI,XREAL_0,XBOOLE_0,NEWTON,CARD_FIL,RMOD_2,CARD_1,SUPINF_2,MESFUNC1,PARTFUN1,COMPLEX1,MEMBERED,MSSUBFAM,FVALUAT1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,ORDINAL1,DOMAIN_1,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,FUNCOP_1,XXREAL_0,XREAL_0,XXREAL_2,XXREAL_3,XCMPLX_0,REAL_1,INT_1,MEMBERED,SUPINF_2,EXTREAL1,INT_2,NAT_1,MESFUNC1,FINSEQ_1,FINSEQ_4,REALSET1,BINOP_1,STRUCT_0,ALGSTR_0,RLVECT_1,GRCAT_1,GROUP_1,YELLOW_9,VECTSP_1,VECTSP_2,FUNCSDOM,REALSET2,RMOD_2,IDEAL_1,RING_1,CKB10,CKB19,CKB22,CKB23;
definitions TARSKI,XBOOLE_0,SUBSET_1,FUNCT_2,BINOP_1,XXREAL_0,XREAL_0,XCMPLX_0,XXREAL_2,XXREAL_3,REALSET1,RING_1,MESFUNC1,STRUCT_0,ALGSTR_0,RLVECT_1,GROUP_1,GRCAT_1,VECTSP_1,VECTSP_2,IDEAL_1,RMOD_2,CKB10,CKB22,CKB23;
theorems VECTSP_1,FUNCOP_1,TARSKI,FUNCT_1,INT_1,RLVECT_1,XREAL_0,VECTSP_2,XBOOLE_0,FUNCT_2,ABSVALUE,NAT_1,ZFMISC_1,REALSET1,FINSEQ_1,FINSEQ_3,XBOOLE_1,TOPREALA,FINSEQ_5,GROUP_1,IDEAL_1,RMOD_2,YELLOW_9,RELAT_1,RING_1,XXREAL_0,ORDINAL1,XXREAL_3,PARTFUN1,ALGSTR_0,XXREAL_2,SUBSET_1,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB20,CKB21,CKB22,CKB23,CKB27;
schemes NAT_1,INT_1,RECDEF_1,FUNCT_2;
registrations RELSET_1,VECTSP_1,INT_1,XREAL_0,ALGSTR_1,VECTSP_2,STRUCT_0,NAT_1,SUBSET_1,WAYBEL_2,XBOOLE_0,RMOD_2,XCMPLX_0,IDEAL_1,RING_1,XXREAL_0,NUMBERS,MEMBERED,ORDINAL1,ALGSTR_0,XXREAL_3,REALSET2,FINSEQ_1,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB24,CKB25,CKB26;
constructors REAL_1,FINSEQ_4,SUPINF_2,EXTREAL1,MESFUNC1,RMOD_2,YELLOW_9,RING_1,BINOM,FUNCOP_1,REALSET2,RELSET_1,GRCAT_1,CKB10,CKB22,CKB23;
requirements NUMERALS,ARITHM,REAL,BOOLE,SUBSET;
begin
reserve i for Integer;
reserve n for Nat;
reserve x for ExtInt;
definition
let K being non  empty doubleLoopStr;
let S being (Subset of K);
let n being Nat;
func S |^ n -> (Subset of K) means 
:Def6: it = (the carrier of K) if n = ( 0 ) otherwise (ex f being (FinSequence of ( bool (the carrier of K) )) st (((it = ( f . ( len f ) ) & ( len f ) = n) & ( f . 1 ) = S) & (for i being Nat holds ((i in ( dom f ) & ( i + 1 ) in ( dom f )) implies ( f . ( i + 1 ) ) = ( S *' ( f /. i ) )))));
consistency;
existence
proof
hereby
assume n = ( 0 );
take A = ( [#] K );
thus A = (the carrier of K);
end;
assume A1: n <> ( 0 );
set D = ( bool (the carrier of K) );
reconsider n1 = n as (Element of ( NAT )) by ORDINAL1:def 12;
defpred P[ set,set,set ]
 means
(ex A being (Subset of K) st (A = $2 & $3 = ( S *' A )));
A2: (for i being (Element of ( NAT )) holds ((1 <= i & i < n1) implies (for x being (Element of D) holds (ex y being (Element of D) st P[ i,x,y ]))))
proof
let i being (Element of ( NAT ));
assume that
(1 <= i & i < n1);
let x being (Element of D);
take ( S *' x );
thus thesis;
end;
consider f being (FinSequence of D) such that A3: ( len f ) = n1 and A4: (( f . 1 ) = S or n1 = ( 0 )) and A5: (for i being (Element of ( NAT )) holds ((1 <= i & i < n1) implies P[ i,( f . i ),( f . ( i + 1 ) ) ])) from RECDEF_1:sch 4(A2);
take ( f /. ( len f ) );
take f;
( len f ) in ( dom f ) by A1,A3,CARD_1:27,FINSEQ_5:6;
hence ( f /. ( len f ) ) = ( f . ( len f ) ) by PARTFUN1:def 6;
thus ( len f ) = n by A3;
thus ( f . 1 ) = S by A1,A4;
let i being Nat;
assume that
A6: i in ( dom f );
assume ( i + 1 ) in ( dom f );
then ( i + 1 ) <= n1 by A3,FINSEQ_3:25;
then A7: i < n1 by NAT_1:13;
A8: i is (Element of ( NAT )) by ORDINAL1:def 12;
1 <= i by A6,FINSEQ_3:25;
then P[ i,( f . i ),( f . ( i + 1 ) ) ] by A5,A8,A7;
hence thesis by A6,PARTFUN1:def 6;
end;
uniqueness
proof
let S1 being (Subset of K);
let S2 being (Subset of K);
thus (((n = ( 0 ) & S1 = (the carrier of K)) & S2 = (the carrier of K)) implies S1 = S2);
assume n <> ( 0 );
given f being (FinSequence of ( bool (the carrier of K) )) such that
A9: S1 = ( f . ( len f ) )
and
A10: ( len f ) = n
and
A11: ( f . 1 ) = S
and
A12: (for i being Nat holds ((i in ( dom f ) & ( i + 1 ) in ( dom f )) implies ( f . ( i + 1 ) ) = ( S *' ( f /. i ) )));

given g being (FinSequence of ( bool (the carrier of K) )) such that
A13: S2 = ( g . ( len g ) )
and
A14: ( len g ) = n
and
A15: ( g . 1 ) = S
and
A16: (for i being Nat holds ((i in ( dom g ) & ( i + 1 ) in ( dom g )) implies ( g . ( i + 1 ) ) = ( S *' ( g /. i ) )));

A17: ( dom f ) = ( dom g ) by A10,A14,FINSEQ_3:29;
(for k being Nat holds (k in ( dom f ) implies ( f . k ) = ( g . k )))
proof
let k being Nat;
defpred P[ Nat ]
 means
($1 in ( dom f ) implies ( f . $1 ) = ( g . $1 ));
A18: P[ ( 0 ) ] by FINSEQ_3:24;
A19: (for a being Nat holds (P[ a ] implies P[ ( a + 1 ) ]))
proof
let a being Nat;
assume that
A20: P[ a ]
and
A21: ( a + 1 ) in ( dom f );
per cases ;
suppose A22: a in ( dom f );

then A23: ( f /. a ) = ( f . a ) by PARTFUN1:def 6
.= ( g /. a ) by A17,A20,A22,PARTFUN1:def 6;
thus ( f . ( a + 1 ) ) = ( S *' ( f /. a ) ) by A12,A21,A22
.= ( g . ( a + 1 ) ) by A16,A17,A21,A22,A23;
end;
suppose (not a in ( dom f ));

then a = ( 0 ) by A21,TOPREALA:2;
hence thesis by A11,A15;
end;
end;
(for a being Nat holds P[ a ]) from NAT_1:sch 2(A18,A19);
hence thesis;
end;
hence S1 = S2 by A9,A13,A10,A14,A17,FINSEQ_1:13;
end;
end;
