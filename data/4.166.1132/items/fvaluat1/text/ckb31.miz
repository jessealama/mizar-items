environ
vocabularies INT_1,VECTSP_1,FUNCT_1,ARYTM_3,ZFMISC_1,RELAT_1,RLVECT_1,FUNCOP_1,ARYTM_1,BINOP_1,FUNCSDOM,REALSET1,LATTICES,GROUP_1,ORDINAL2,IDEAL_1,FINSEQ_1,SUBSET_1,VECTSP_2,FUNCT_3,NUMBERS,GROUP_4,STRUCT_0,RLSUB_1,XXREAL_2,ALGSTR_0,XCMPLX_0,ORDINAL1,REALSET2,NAT_1,REAL_1,INT_2,XXREAL_0,TARSKI,XREAL_0,XBOOLE_0,NEWTON,CARD_FIL,RMOD_2,CARD_1,SUPINF_2,MESFUNC1,PARTFUN1,COMPLEX1,MEMBERED,MSSUBFAM,FVALUAT1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,ORDINAL1,DOMAIN_1,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,FUNCOP_1,XXREAL_0,XREAL_0,XXREAL_2,XXREAL_3,XCMPLX_0,REAL_1,INT_1,MEMBERED,SUPINF_2,EXTREAL1,INT_2,NAT_1,MESFUNC1,FINSEQ_1,FINSEQ_4,REALSET1,BINOP_1,STRUCT_0,ALGSTR_0,RLVECT_1,GRCAT_1,GROUP_1,YELLOW_9,VECTSP_1,VECTSP_2,FUNCSDOM,REALSET2,RMOD_2,IDEAL_1,RING_1,CKB10,CKB19,CKB22,CKB23,CKB28;
definitions TARSKI,XBOOLE_0,SUBSET_1,FUNCT_2,BINOP_1,XXREAL_0,XREAL_0,XCMPLX_0,XXREAL_2,XXREAL_3,REALSET1,RING_1,MESFUNC1,STRUCT_0,ALGSTR_0,RLVECT_1,GROUP_1,GRCAT_1,VECTSP_1,VECTSP_2,IDEAL_1,RMOD_2,CKB10,CKB22,CKB23,CKB28;
theorems VECTSP_1,FUNCOP_1,TARSKI,FUNCT_1,INT_1,RLVECT_1,XREAL_0,VECTSP_2,XBOOLE_0,FUNCT_2,ABSVALUE,NAT_1,ZFMISC_1,REALSET1,FINSEQ_1,FINSEQ_3,XBOOLE_1,TOPREALA,FINSEQ_5,GROUP_1,IDEAL_1,RMOD_2,YELLOW_9,RELAT_1,RING_1,XXREAL_0,ORDINAL1,XXREAL_3,PARTFUN1,ALGSTR_0,XXREAL_2,SUBSET_1,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB20,CKB21,CKB22,CKB23,CKB27,CKB28,CKB29,CKB30;
schemes NAT_1,INT_1,RECDEF_1,FUNCT_2;
registrations RELSET_1,VECTSP_1,INT_1,XREAL_0,ALGSTR_1,VECTSP_2,STRUCT_0,NAT_1,SUBSET_1,WAYBEL_2,XBOOLE_0,RMOD_2,XCMPLX_0,IDEAL_1,RING_1,XXREAL_0,NUMBERS,MEMBERED,ORDINAL1,ALGSTR_0,XXREAL_3,REALSET2,FINSEQ_1,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB24,CKB25,CKB26;
constructors REAL_1,FINSEQ_4,SUPINF_2,EXTREAL1,MESFUNC1,RMOD_2,YELLOW_9,RING_1,BINOM,FUNCOP_1,REALSET2,RELSET_1,GRCAT_1,CKB10,CKB22,CKB23,CKB28;
requirements NUMERALS,ARITHM,REAL,BOOLE,SUBSET;
begin
reserve n for Nat;
reserve m for Nat;
registration
let R being Ring;
let S being (Ideal of R);
let n being Nat;
cluster ( S |^ n ) -> non  empty  add-closed  left-ideal  right-ideal;
coherence
proof
per cases  by NAT_1:6;
suppose A1: n = ( 0 );

A2: ( S |^ ( 0 ) ) = (the carrier of R) by CKB28:def 1;
thus ( S |^ n ) is non  empty by A1,CKB28:def 1;
thus ( S |^ n ) is  add-closed
proof
let x being (Element of R);
let y being (Element of R);
thus thesis by A2,A1;
end;

thus ( S |^ n ) is  left-ideal
proof
let p being (Element of R);
let x being (Element of R);
thus thesis by A2,A1;
end;

let p being (Element of R);
let x being (Element of R);
thus thesis by A2,A1;
end;
suppose A3: (ex k being Nat st n = ( k + 1 ));

then consider f being (FinSequence of ( bool (the carrier of R) )) such that A4: ((( S |^ n ) = ( f . ( len f ) ) & ( len f ) = n) & ( f . 1 ) = S) and A5: (for i being Nat holds ((i in ( dom f ) & ( i + 1 ) in ( dom f )) implies ( f . ( i + 1 ) ) = ( S *' ( f /. i ) ))) by CKB28:def 1;
defpred P[ Nat ]
 means
($1 in ( dom f ) implies ( f . $1 ) is (Ideal of R));
A6: P[ ( 0 ) ] by FINSEQ_3:24;
A7: (for m holds (P[ m ] implies P[ ( m + 1 ) ]))
proof
let m;
assume that
A8: P[ m ]
and
A9: ( m + 1 ) in ( dom f );
per cases  by A9,TOPREALA:2;
suppose m = ( 0 );

hence thesis by A4;
end;
suppose A10: m in ( dom f );

then A11: ( f /. m ) = ( f . m ) by PARTFUN1:def 6;
( f . ( m + 1 ) ) = ( S *' ( f /. m ) ) by A5,A9,A10;
hence thesis by A10,A8,A11;
end;
end;
A12: (for m holds P[ m ]) from NAT_1:sch 2(A6,A7);
( ( 0 ) + 1 ) <= ( len f ) by A3,A4,NAT_1:13;
then ( len f ) in ( dom f ) by FINSEQ_3:25;
hence thesis by A4,A12;
end;
end;
end;
