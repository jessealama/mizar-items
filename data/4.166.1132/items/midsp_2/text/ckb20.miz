environ
vocabularies XBOOLE_0,ALGSTR_0,SUBSET_1,MIDSP_1,PRE_TOPC,FUNCT_1,ZFMISC_1,STRUCT_0,ROBBINS1,ARYTM_3,QC_LANG1,RLVECT_1,SUPINF_2,ARYTM_1,VECTSP_1,RLVECT_2,BINOP_1,MIDSP_2;
notations XBOOLE_0,ZFMISC_1,SUBSET_1,FUNCT_2,BINOP_1,DOMAIN_1,STRUCT_0,ALGSTR_0,PRE_TOPC,RLVECT_1,VECTSP_1,MIDSP_1,CKB1,CKB2,CKB4,CKB5;
definitions STRUCT_0,VECTSP_1,CKB1,CKB2,CKB4,CKB5;
theorems BINOP_1,MIDSP_1,RLVECT_1,VECTSP_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18;
schemes BINOP_1;
registrations XBOOLE_0,RELSET_1,STRUCT_0,VECTSP_1,MIDSP_1,CKB19;
constructors BINOP_1,DOMAIN_1,VECTSP_1,MIDSP_1,RLVECT_1,CKB1,CKB2,CKB4,CKB5;
requirements SUBSET,BOOLE;
begin
reserve M for MidSp;
theorem
Th18: (((for a being set holds (a is (Element of ( vectgroup M )) iff a is (Vector of M))) & ( 0. ( vectgroup M ) ) = ( ID M )) & (for a,b being (Element of ( vectgroup M )) holds (for x,y being (Vector of M) holds ((a = x & b = y) implies ( a + b ) = ( x + y )))))
proof
set G = ( vectgroup M );
thus (for a being set holds (a is (Element of G) iff a is (Vector of M)))
proof
let a being set;
(a is (Element of G) iff a is (Element of ( setvect M ))) by MIDSP_1:53;
hence thesis by MIDSP_1:48;
end;

thus ( 0. G ) = ( zerovect M ) by MIDSP_1:55
.= ( ID M ) by MIDSP_1:def 16;
thus (for a,b being (Element of G) holds (for x,y being (Vector of M) holds ((a = x & b = y) implies ( a + b ) = ( x + y ))))
proof
let a being (Element of G),b being (Element of G);
let x being (Vector of M),y being (Vector of M);
assume that
A1: (a = x & b = y);
reconsider xx = x,yy = y as (Element of ( setvect M )) by MIDSP_1:48;
thus ( a + b ) = ( (the addF of G) . (a,b) ) by RLVECT_1:2
.= ( ( addvect M ) . (xx,yy) ) by A1,MIDSP_1:54
.= ( xx + yy ) by MIDSP_1:def 14
.= ( x + y ) by MIDSP_1:def 13;
end;

end;
