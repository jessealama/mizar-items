environ
vocabularies NUMBERS,XBOOLEAN,XXREAL_0,CARD_1,XBOOLE_0,SUBSET_1,FUNCT_2,MARGREL1,FUNCT_1,RELAT_1,TARSKI,FUNCOP_1,PARTIT1,EQREL_1,ZFMISC_1,SETFAM_1,BVFUNC_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,XBOOLEAN,MARGREL1,RELAT_1,FUNCT_1,FUNCT_2,SETFAM_1,EQREL_1,NUMBERS,PARTIT1,XXREAL_0,CKB1,CKB3,CKB4,CKB5,CKB6,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13;
definitions TARSKI,XBOOLE_0,MARGREL1,XBOOLEAN,CKB1,CKB5,CKB6,CKB8,CKB9,CKB12,CKB13;
theorems TARSKI,FUNCT_1,FUNCT_2,MARGREL1,EQREL_1,SETFAM_1,PARTIT1,XBOOLE_0,FUNCOP_1,XBOOLEAN,CKB1,CKB5,CKB6,CKB8,CKB9,CKB12,CKB13;
schemes DOMAIN_1,FUNCT_2,FUNCT_1,CKB2;
registrations SUBSET_1,XREAL_0,XBOOLEAN,EQREL_1,MARGREL1,FUNCT_1,FUNCT_2,CKB7,CKB14,CKB15;
constructors SETFAM_1,XXREAL_0,XREAL_0,PARTIT1,BINARITH,RELSET_1,CKB3,CKB4,CKB5,CKB6,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13;
requirements REAL,SUBSET,BOOLE,ARITHM;
begin
definition
let A being non empty set;
let p being (Element of ( Funcs (A,( BOOLEAN )) ));
let q being (Element of ( Funcs (A,( BOOLEAN )) ));
redefine func p 'imp' q -> (Element of ( Funcs (A,( BOOLEAN )) ))
means
:Def11: (for x being (Element of A) holds ( it . x ) = ( ( 'not' ( p . x ) ) 'or' ( q . x ) ));
coherence
proof
((ex f being Function st ((p = f & ( dom f ) = A) & ( rng f ) c= ( BOOLEAN ))) & (ex f being Function st ((q = f & ( dom f ) = A) & ( rng f ) c= ( BOOLEAN )))) by FUNCT_2:def 2;
then A1: ( dom ( p 'imp' q ) ) = ( A /\ A ) by CKB12:def 1
.= A;
( rng ( p 'imp' q ) ) c= ( BOOLEAN ) by MARGREL1:def 16;
hence thesis by A1,FUNCT_2:def 2;
end;
compatibility
proof
let IT being (Element of ( Funcs (A,( BOOLEAN )) ));
A2: ( dom q ) = A by FUNCT_2:def 1;
hereby
assume A3: IT = ( p 'imp' q );
let x being (Element of A);
(( dom p ) = A & ( dom q ) = A) by FUNCT_2:def 1;
then ( dom ( p 'imp' q ) ) = ( A /\ A ) by CKB12:def 1
.= A;
hence ( IT . x ) = ( ( p . x ) => ( q . x ) ) by A3,CKB12:def 1
.= ( ( 'not' ( p . x ) ) 'or' ( q . x ) );
end;
assume A4: (for x being (Element of A) holds ( IT . x ) = ( ( 'not' ( p . x ) ) 'or' ( q . x ) ));
A5: (for x being set holds (x in ( dom IT ) implies ( IT . x ) = ( ( p . x ) => ( q . x ) )))
proof
let x being set;
assume x in ( dom IT );
then reconsider x as (Element of A) by FUNCT_2:def 1;
( IT . x ) = ( ( 'not' ( p . x ) ) 'or' ( q . x ) ) by A4;
hence thesis;
end;
( dom IT ) = ( A /\ A ) by FUNCT_2:def 1
.= ( ( dom p ) /\ ( dom q ) ) by A2,FUNCT_2:def 1;
hence thesis by A5,CKB12:def 1;
end;
end;
