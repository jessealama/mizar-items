environ
vocabularies NUMBERS,XBOOLEAN,XXREAL_0,CARD_1,XBOOLE_0,SUBSET_1,FUNCT_2,MARGREL1,FUNCT_1,RELAT_1,TARSKI,FUNCOP_1,PARTIT1,EQREL_1,ZFMISC_1,SETFAM_1,BVFUNC_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,XBOOLEAN,MARGREL1,RELAT_1,FUNCT_1,FUNCT_2,SETFAM_1,EQREL_1,NUMBERS,PARTIT1,XXREAL_0,CKB1,CKB3,CKB4,CKB5,CKB6,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB16;
definitions TARSKI,XBOOLE_0,MARGREL1,XBOOLEAN,CKB1,CKB5,CKB6,CKB8,CKB9,CKB12,CKB13,CKB16;
theorems TARSKI,FUNCT_1,FUNCT_2,MARGREL1,EQREL_1,SETFAM_1,PARTIT1,XBOOLE_0,FUNCOP_1,XBOOLEAN,CKB1,CKB5,CKB6,CKB8,CKB9,CKB12,CKB13,CKB16;
schemes DOMAIN_1,FUNCT_2,FUNCT_1,CKB2;
registrations SUBSET_1,XREAL_0,XBOOLEAN,EQREL_1,MARGREL1,FUNCT_1,FUNCT_2,CKB7,CKB14,CKB15;
constructors SETFAM_1,XXREAL_0,XREAL_0,PARTIT1,BINARITH,RELSET_1,CKB3,CKB4,CKB5,CKB6,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB16;
requirements REAL,SUBSET,BOOLE,ARITHM;
begin
definition
let A being non  empty set;
let p being (Element of ( Funcs (A,( BOOLEAN )) ));
let q being (Element of ( Funcs (A,( BOOLEAN )) ));
redefine func p 'eqv' q -> (Element of ( Funcs (A,( BOOLEAN )) )) means 
:Def12: (for x being (Element of A) holds ( it . x ) = ( 'not' ( ( p . x ) 'xor' ( q . x ) ) ));
coherence
proof
((ex f being Function st ((p = f & ( dom f ) = A) & ( rng f ) c= ( BOOLEAN ))) & (ex f being Function st ((q = f & ( dom f ) = A) & ( rng f ) c= ( BOOLEAN )))) by FUNCT_2:def 2;
then A6: ( dom ( p 'eqv' q ) ) = ( A /\ A ) by CKB13:def 1
.= A;
( rng ( p 'eqv' q ) ) c= ( BOOLEAN ) by MARGREL1:def 16;
hence thesis by A6,FUNCT_2:def 2;
end;
compatibility
proof
let IT being (Element of ( Funcs (A,( BOOLEAN )) ));
A7: ( dom q ) = A by FUNCT_2:def 1;
hereby
assume A8: IT = ( p 'eqv' q );
let x being (Element of A);
(( dom p ) = A & ( dom q ) = A) by FUNCT_2:def 1;
then ( dom ( p 'eqv' q ) ) = ( A /\ A ) by CKB13:def 1
.= A;
hence ( IT . x ) = ( 'not' ( ( p . x ) 'xor' ( q . x ) ) ) by A8,CKB13:def 1;
end;
assume A9: (for x being (Element of A) holds ( IT . x ) = ( 'not' ( ( p . x ) 'xor' ( q . x ) ) ));
A10: (for x being set holds (x in ( dom IT ) implies ( IT . x ) = ( ( p . x ) <=> ( q . x ) )))
proof
let x being set;
assume x in ( dom IT );
then reconsider x as (Element of A) by FUNCT_2:def 1;
( IT . x ) = ( 'not' ( ( p . x ) 'xor' ( q . x ) ) ) by A9;
hence thesis;
end;
( dom IT ) = ( A /\ A ) by FUNCT_2:def 1
.= ( ( dom p ) /\ ( dom q ) ) by A7,FUNCT_2:def 1;
hence thesis by A10,CKB13:def 1;
end;
end;
