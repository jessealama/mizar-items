environ
vocabularies MSUALG_1,SUBSET_1,STRUCT_0,NUMBERS,XBOOLE_0,CARD_3,FINSEQ_1,FUNCOP_1,FINSEQ_2,PBOOLE,FUNCT_4,RELAT_1,PARTFUN1,FUNCT_1,TARSKI,MSAFREE2,FINSET_1,GLIB_000,MARGREL1,CIRCUIT1,FSM_1,CIRCUIT2,MCART_1,NAT_1,CARD_1,LATTICES,XBOOLEAN,CIRCCOMB;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,NAT_1,MCART_1,RELAT_1,FUNCT_1,FINSEQ_1,FINSEQ_2,FINSET_1,FUNCT_2,FUNCOP_1,PARTFUN1,FUNCT_4,CARD_3,MARGREL1,PBOOLE,STRUCT_0,MSUALG_1,MSAFREE2,CIRCUIT1,CIRCUIT2,CKB1;
definitions TARSKI,PARTFUN1,MSUALG_1,FINSET_1,MSAFREE2,STRUCT_0,RELAT_1,XBOOLE_0,FUNCOP_1,PBOOLE,MARGREL1;
theorems TARSKI,ZFMISC_1,FINSEQ_1,FINSEQ_2,MSUALG_1,FUNCT_1,FUNCT_2,FUNCT_4,PBOOLE,GRFUNC_1,FUNCOP_1,PARTFUN1,RELAT_1,MSAFREE2,CIRCUIT1,CIRCUIT2,MCART_1,CARD_3,ORDINAL1,MONOID_1,RELSET_1,XBOOLE_0,XBOOLE_1,FINSET_1,CARD_1,FINSEQ_3,CKB7;
schemes FUNCT_1;
registrations XBOOLE_0,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,FINSEQ_1,MARGREL1,CARD_3,PBOOLE,STRUCT_0,MSUALG_1,MSUALG_2,MSAFREE2,FUNCT_4,RELSET_1,PRE_CIRC,CARD_1,FINSEQ_2,CKB2,CKB3,CKB4,CKB5,CKB6;
constructors MARGREL1,CIRCUIT1,CIRCUIT2,RELSET_1,XCMPLX_0;
requirements NUMERALS,BOOLE,SUBSET;
begin
Lm1:now
let i being (Element of ( NAT ));
let X being non  empty set;
thus ( product ( ( Seg i ) --> X ) ) = ( product ( i |-> X ) ) by FINSEQ_2:def 2
.= ( i -tuples_on X ) by FINSEQ_3:131;
end;
theorem
Th6: (for X being set holds (for Y being non  empty set holds (for p being (FinSequence of X) holds ( ( ( X --> Y ) # ) . p ) = ( ( len p ) -tuples_on Y ))))
proof
let X being set;
let Y being non  empty set;
let p being (FinSequence of X);
( rng p ) c= X by FINSEQ_1:def 4;
then ( ( rng p ) /\ X ) = ( rng p ) by XBOOLE_1:28;
then A1: ( p " X ) = ( p " ( rng p ) ) by RELAT_1:133
.= ( dom p ) by RELAT_1:134;
p in ( X * ) by FINSEQ_1:def 11;
hence ( ( ( X --> Y ) # ) . p ) = ( product ( ( X --> Y ) * p ) ) by FINSEQ_2:def 5
.= ( product ( ( p " X ) --> Y ) ) by FUNCOP_1:19
.= ( product ( ( Seg ( len p ) ) --> Y ) ) by A1,FINSEQ_1:def 3
.= ( ( len p ) -tuples_on Y ) by Lm1;
end;
