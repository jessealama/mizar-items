environ
vocabularies MSUALG_1,SUBSET_1,STRUCT_0,NUMBERS,XBOOLE_0,CARD_3,FINSEQ_1,FUNCOP_1,FINSEQ_2,PBOOLE,FUNCT_4,RELAT_1,PARTFUN1,FUNCT_1,TARSKI,MSAFREE2,FINSET_1,GLIB_000,MARGREL1,CIRCUIT1,FSM_1,CIRCUIT2,MCART_1,NAT_1,CARD_1,LATTICES,XBOOLEAN,CIRCCOMB;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,NAT_1,MCART_1,RELAT_1,FUNCT_1,FINSEQ_1,FINSEQ_2,FINSET_1,FUNCT_2,FUNCOP_1,PARTFUN1,FUNCT_4,CARD_3,MARGREL1,PBOOLE,STRUCT_0,MSUALG_1,MSAFREE2,CIRCUIT1,CIRCUIT2,CKB1,CKB9,CKB10,CKB11,CKB29;
definitions TARSKI,PARTFUN1,MSUALG_1,FINSET_1,MSAFREE2,STRUCT_0,RELAT_1,XBOOLE_0,FUNCOP_1,PBOOLE,MARGREL1,CKB10,CKB11,CKB29;
theorems TARSKI,ZFMISC_1,FINSEQ_1,FINSEQ_2,MSUALG_1,FUNCT_1,FUNCT_2,FUNCT_4,PBOOLE,GRFUNC_1,FUNCOP_1,PARTFUN1,RELAT_1,MSAFREE2,CIRCUIT1,CIRCUIT2,MCART_1,CARD_3,ORDINAL1,MONOID_1,RELSET_1,XBOOLE_0,XBOOLE_1,FINSET_1,CARD_1,FINSEQ_3,CKB7,CKB8,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29;
schemes FUNCT_1;
registrations XBOOLE_0,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,FINSEQ_1,MARGREL1,CARD_3,PBOOLE,STRUCT_0,MSUALG_1,MSUALG_2,MSAFREE2,FUNCT_4,RELSET_1,PRE_CIRC,CARD_1,FINSEQ_2,CKB2,CKB3,CKB4,CKB5,CKB6,CKB20,CKB21;
constructors MARGREL1,CIRCUIT1,CIRCUIT2,RELSET_1,XCMPLX_0,CKB9,CKB10,CKB11,CKB29;
requirements NUMERALS,BOOLE,SUBSET;
begin
definition
let S1 being non  empty ManySortedSign;
let S2 being non  empty ManySortedSign;
let A1 being  non-empty MSAlgebra over S1;
let A2 being  non-empty MSAlgebra over S2;
assume A1: (the Sorts of A1) tolerates (the Sorts of A2);
func A1 +* A2 ->  strict  non-empty MSAlgebra over ( S1 +* S2 ) means 
:Def4: ((the Sorts of it) = ( (the Sorts of A1) +* (the Sorts of A2) ) & (the Charact of it) = ( (the Charact of A1) +* (the Charact of A2) ));
uniqueness;
existence
proof
set CHARACT = ( (the Charact of A1) +* (the Charact of A2) );
set SA1 = (the Sorts of A1);
set SA2 = (the Sorts of A2);
set S = ( S1 +* S2 );
set I = (the carrier of S);
set I1 = (the carrier of S1);
set I2 = (the carrier of S2);
set SA12 = ( ( SA1 # ) +* ( SA2 # ) );
A2: ( dom ( SA2 # ) ) = ( I2 * ) by PARTFUN1:def 2;
A3: (the ResultSort of S) = ( (the ResultSort of S1) +* (the ResultSort of S2) ) by CKB11:def 1;
A4: ( rng (the ResultSort of S2) ) c= I2 by RELAT_1:def 19;
A5: ( dom SA2 ) = I2 by PARTFUN1:def 2;
(the carrier of S) = ( (the carrier of S1) \/ (the carrier of S2) ) by CKB11:def 1;
then reconsider SORTS = ( (the Sorts of A1) +* (the Sorts of A2) ) as  non-empty (ManySortedSet of (the carrier of ( S1 +* S2 )));
A6: ( dom ( SORTS # ) ) = ( I * ) by PARTFUN1:def 2;
A7: SORTS = ( SA1 \/ SA2 ) by A1,FUNCT_4:30;
then A8: ( SA2 # ) c= ( SORTS # ) by CKB7:1,XBOOLE_1:7;
A9: ( dom SA12 ) = ( ( I1 * ) \/ ( I2 * ) ) by PARTFUN1:def 2;
A10: ( dom SA1 ) = I1 by PARTFUN1:def 2;
( rng (the ResultSort of S1) ) c= I1 by RELAT_1:def 19;
then A11: ( ( SA1 +* SA2 ) * ( (the ResultSort of S1) +* (the ResultSort of S2) ) ) = ( ( SA1 * (the ResultSort of S1) ) +* ( SA2 * (the ResultSort of S2) ) ) by A1,A10,A5,A4,FUNCT_4:69;
A12: ( rng (the Arity of S2) ) c= ( I2 * ) by RELAT_1:def 19;
A13: ( dom ( SA1 # ) ) = ( I1 * ) by PARTFUN1:def 2;
A14: ( SA1 # ) tolerates ( SA2 # )
proof
let x being set;
assume A15: x in ( ( dom ( SA1 # ) ) /\ ( dom ( SA2 # ) ) );
then reconsider i1 = x as (Element of ( I1 * )) by A13,XBOOLE_0:def 4;
reconsider i2 = x as (Element of ( I2 * )) by A2,A15,XBOOLE_0:def 4;
A16: ( rng i1 ) c= I1 by FINSEQ_1:def 4;
A17: ( rng i2 ) c= I2 by FINSEQ_1:def 4;
thus ( ( SA1 # ) . x ) = ( product ( SA1 * i1 ) ) by FINSEQ_2:def 5
.= ( product ( SA2 * i2 ) ) by A1,A10,A5,A16,A17,PARTFUN1:79
.= ( ( SA2 # ) . x ) by FINSEQ_2:def 5;
end;
then A18: SA12 = ( ( SA1 # ) \/ ( SA2 # ) ) by FUNCT_4:30;
( SA1 # ) c= ( SORTS # ) by A7,CKB7:1,XBOOLE_1:7;
then A19: SA12 c= ( SORTS # ) by A18,A8,XBOOLE_1:8;
A20: (the carrier' of S) = ( (the carrier' of S1) \/ (the carrier' of S2) ) by CKB11:def 1;
A21: ( rng (the Arity of S) ) c= ( I * ) by RELAT_1:def 19;
A22: ( rng (the Arity of S1) ) c= ( I1 * ) by RELAT_1:def 19;
then A23: ( ( rng (the Arity of S1) ) \/ ( rng (the Arity of S2) ) ) c= ( ( I1 * ) \/ ( I2 * ) ) by A12,XBOOLE_1:13;
A24: (the Arity of S) = ( (the Arity of S1) +* (the Arity of S2) ) by CKB11:def 1;
then ( rng (the Arity of S) ) c= ( ( rng (the Arity of S1) ) \/ ( rng (the Arity of S2) ) ) by FUNCT_4:17;
then A25: ( rng (the Arity of S) ) c= ( dom SA12 ) by A23,A9,XBOOLE_1:1;
UU: SA12 tolerates ( SORTS # ) by A19,PARTFUN1:54;
XX: ( ( ( SA1 # ) +* ( SA2 # ) ) * ( (the Arity of S1) +* (the Arity of S2) ) ) = ( ( ( SA1 # ) * (the Arity of S1) ) +* ( ( SA2 # ) * (the Arity of S2) ) ) by A13,A2,A22,A12,A14,FUNCT_4:69;
reconsider CHARACT as (ManySortedFunction of ( ( SORTS # ) * (the Arity of S) ),( SORTS * (the ResultSort of S) )) by A20,A24,A3,A6,A21,A25,A11,UU,XX,PARTFUN1:79;
reconsider A = MSAlgebra (# SORTS,CHARACT #) as  strict  non-empty MSAlgebra over S by MSUALG_1:def 3;
take A;
thus thesis;
end;
end;
