environ
vocabularies MSUALG_1,SUBSET_1,STRUCT_0,NUMBERS,XBOOLE_0,CARD_3,FINSEQ_1,FUNCOP_1,FINSEQ_2,PBOOLE,FUNCT_4,RELAT_1,PARTFUN1,FUNCT_1,TARSKI,MSAFREE2,FINSET_1,GLIB_000,MARGREL1,CIRCUIT1,FSM_1,CIRCUIT2,MCART_1,NAT_1,CARD_1,LATTICES,XBOOLEAN,CIRCCOMB;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,NAT_1,MCART_1,RELAT_1,FUNCT_1,FINSEQ_1,FINSEQ_2,FINSET_1,FUNCT_2,FUNCOP_1,PARTFUN1,FUNCT_4,CARD_3,MARGREL1,PBOOLE,STRUCT_0,MSUALG_1,MSAFREE2,CIRCUIT1,CIRCUIT2,CKB1;
definitions TARSKI,PARTFUN1,MSUALG_1,FINSET_1,MSAFREE2,STRUCT_0,RELAT_1,XBOOLE_0,FUNCOP_1,PBOOLE,MARGREL1;
theorems TARSKI,ZFMISC_1,FINSEQ_1,FINSEQ_2,MSUALG_1,FUNCT_1,FUNCT_2,FUNCT_4,PBOOLE,GRFUNC_1,FUNCOP_1,PARTFUN1,RELAT_1,MSAFREE2,CIRCUIT1,CIRCUIT2,MCART_1,CARD_3,ORDINAL1,MONOID_1,RELSET_1,XBOOLE_0,XBOOLE_1,FINSET_1,CARD_1,FINSEQ_3,CKB7,CKB8;
schemes FUNCT_1;
registrations XBOOLE_0,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,FINSEQ_1,MARGREL1,CARD_3,PBOOLE,STRUCT_0,MSUALG_1,MSUALG_2,MSAFREE2,FUNCT_4,RELSET_1,PRE_CIRC,CARD_1,FINSEQ_2,CKB2,CKB3,CKB4,CKB5,CKB6;
constructors MARGREL1,CIRCUIT1,CIRCUIT2,RELSET_1,XCMPLX_0;
requirements NUMERALS,BOOLE,SUBSET;
begin
definition
let A being set;
let f1 being  non-empty (ManySortedSet of A);
let g1 being  non-empty (ManySortedSet of A);
let B being set;
let f2 being  non-empty (ManySortedSet of B);
let g2 being  non-empty (ManySortedSet of B);
let h1 being (ManySortedFunction of f1,g1);
let h2 being (ManySortedFunction of f2,g2);
redefine func h1 +* h2 -> (ManySortedFunction of ( f1 +* f2 ),( g1 +* g2 ));

coherence
proof
set f = ( f1 +* f2 );
set g = ( g1 +* g2 );
set h = ( h1 +* h2 );
A1: ( dom g1 ) = A by PARTFUN1:def 2;
A2: ( dom f2 ) = B by PARTFUN1:def 2;
A3: ( dom g2 ) = B by PARTFUN1:def 2;
A4: ( dom h2 ) = B by PARTFUN1:def 2;
A5: ( dom h1 ) = A by PARTFUN1:def 2;
reconsider h as (ManySortedFunction of ( A \/ B ));
A6: ( dom f1 ) = A by PARTFUN1:def 2;
h is (ManySortedFunction of f,g)
proof
let x being set;
A7: ((not x in B) or x in B);
assume A8: x in ( A \/ B );
then (x in A or x in B) by XBOOLE_0:def 3;
then ((((( h . x ) = ( h1 . x ) & ( h1 . x ) is (Function of ( f1 . x ),( g1 . x ))) & ( f . x ) = ( f1 . x )) & ( g . x ) = ( g1 . x )) or (((( h . x ) = ( h2 . x ) & ( h2 . x ) is (Function of ( f2 . x ),( g2 . x ))) & ( f . x ) = ( f2 . x )) & ( g . x ) = ( g2 . x ))) by A6,A1,A5,A2,A3,A4,A8,A7,FUNCT_4:def 1,PBOOLE:def 15;
hence thesis;
end;
hence thesis;
end;
end;
