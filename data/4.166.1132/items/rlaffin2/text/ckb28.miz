environ
vocabularies ARYTM_1,ARYTM_3,XBOOLE_0,CARD_1,CONVEX1,CONVEX2,CONVEX3,FINSEQ_1,FINSEQ_2,FINSEQ_4,FINSET_1,FUNCOP_1,FUNCT_1,FUNCT_2,FUNCT_4,MEMBERED,ORDERS_1,RELAT_1,RLVECT_1,RLVECT_2,RUSUB_4,SEMI_AF1,SETFAM_1,TARSKI,TOPS_1,RLAFFIN1,RLAFFIN2,ZFMISC_1,REAL_1,CARD_3,XXREAL_0,NAT_1,SUBSET_1,NUMBERS,ORDINAL1,STRUCT_0,SUPINF_2,ORDINAL4,VALUED_1,XREAL_0,PARTFUN1;
notations TARSKI,XBOOLE_0,SUBSET_1,ZFMISC_1,ORDINAL1,NUMBERS,NAT_1,XCMPLX_0,XXREAL_0,ORDERS_1,CARD_1,XREAL_0,REAL_1,FINSET_1,SETFAM_1,DOMAIN_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,RELSET_1,FINSEQ_1,STRUCT_0,FINSEQ_2,SEQ_1,FINSEQOP,RVSUM_1,RLVECT_1,RLVECT_2,RUSUB_4,CONVEX1,CONVEX2,CONVEX3,RLAFFIN1,FUNCT_4,FUNCOP_1,MEMBERED,XXREAL_2,CKB6,CKB19;
definitions ORDERS_1,RLVECT_2,TARSKI,XBOOLE_0,CKB6,CKB19;
theorems BORSUK_4,CARD_1,CARD_2,CARD_FIN,CONVEX1,CONVEX3,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSEQ_4,FUNCOP_1,FUNCT_1,FUNCT_2,FUNCT_4,NAT_1,MEMBERED,PARTFUN1,RELAT_1,RLAFFIN1,RLTOPSP1,RUSUB_4,RLVECT_2,RLVECT_3,RLVECT_4,RVSUM_1,STIRL2_1,SIMPLEX0,TARSKI,WELLORD2,XBOOLE_0,XBOOLE_1,XCMPLX_1,XREAL_0,XREAL_1,XXREAL_0,XXREAL_2,ZFMISC_1,RLVECT_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27;
schemes FRAENKEL,FUNCT_2,NAT_1,RLVECT_4;
registrations CARD_1,FINSET_1,FINSEQ_2,FUNCT_2,MEMBERED,NAT_1,NUMBERS,RELAT_1,RLVECT_1,RLVECT_3,STRUCT_0,SUBSET_1,VALUED_0,XCMPLX_0,XREAL_0,XXREAL_0,XBOOLE_0,RLAFFIN1,SIMPLEX0,FUNCOP_1,XXREAL_3,REALSET1,SETFAM_1,XXREAL_2,ABIAN,PARTFUN1,RVSUM_1,FINSEQ_1,RELSET_1,DILWORTH,RLVECT_2,CKB8;
constructors BINOP_2,CONVEX1,CONVEX3,DOMAIN_1,FINSEQOP,REAL_1,RLVECT_3,RVSUM_1,RUSUB_5,SEQ_1,SETFAM_1,RLAFFIN1,SIMPLEX0,XXREAL_2,FUNCT_4,RELSET_1,PARTFUN1,CKB6,CKB19;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve x for set;
reserve y for set;
reserve n for Nat;
reserve V for RealLinearSpace;
reserve A for (Subset of V);
reserve If for  finite  affinely-independent (Subset of V);
theorem
(((( conv A ) c= ( conv If ) & If is non empty) & ( conv A ) misses ( Int If )) implies (ex B being (Subset of V) st (B c< If & ( conv A ) c= ( conv B ))))
proof
assume that
A1: ( conv A ) c= ( conv If )
and
A2: If is non empty
and
A3: ( conv A ) misses ( Int If );
reconsider If as non empty  finite  affinely-independent (Subset of V) by A2;
set YY = { B where B is (Subset of V): (B c= If & (ex x st (x in ( conv A ) & x in ( Int B )))) };
YY c= ( bool (the carrier of V) )
proof
let x;
assume x in YY;
then (ex B being (Subset of V) st ((B = x & B c= If) & (ex y st (y in ( conv A ) & y in ( Int B )))));
hence thesis;
end;
then reconsider YY as (Subset-Family of V);
take U = ( union YY );
A4: ( conv A ) c= ( conv U )
proof
let v being set;
assume A5: v in ( conv A );
then v in ( conv If ) by A1;
then v in ( union { ( Int B ) where B is (Subset of V): B c= If } ) by CKB12:1;
then consider IB being set such that A6: v in IB and A7: IB in { ( Int B ) where B is (Subset of V): B c= If } by TARSKI:def 4;
consider B being (Subset of V) such that A8: IB = ( Int B ) and A9: B c= If by A7;
( Int B ) c= ( conv B ) by CKB7:1;
then A10: v in ( conv B ) by A6,A8;
B in YY by A5,A6,A8,A9;
then ( conv B ) c= ( conv U ) by RLAFFIN1:3,ZFMISC_1:74;
hence thesis by A10;
end;
A11: U c= If
proof
let x;
assume x in U;
then consider b being set such that A12: x in b and A13: b in YY by TARSKI:def 4;
(ex B being (Subset of V) st ((b = B & B c= If) & (ex y st (y in ( conv A ) & y in ( Int B ))))) by A13;
hence thesis by A12;
end;
U <> If
proof
defpred P[ set,set ]
 means
(for B being (Subset of V) holds (B = $2 implies ($1 in B & (ex x st (x in ( conv A ) & x in ( Int B ))))));
assume A14: U = If;
A15: (for x holds (x in If implies (ex y st (y in ( bool If ) & P[ x,y ]))))
proof
let x;
assume x in If;
then consider b being set such that A16: x in b and A17: b in YY by A14,TARSKI:def 4;
consider B being (Subset of V) such that A18: ((b = B & B c= If) & (ex y st (y in ( conv A ) & y in ( Int B )))) by A17;
take B;
thus thesis by A16,A18;
end;
consider p being (Function of If,( bool If )) such that A19: (for x holds (x in If implies P[ x,( p . x ) ])) from FUNCT_2:sch 1(A15);
defpred Q[ set,set ]
 means
(for B being (Subset of V) holds (B = ( p . $1 ) implies ($2 in ( conv A ) & $2 in ( Int B ))));
A20: ( dom p ) = If by FUNCT_2:def 1;
A21: (for x holds (x in If implies (ex y st (y in (the carrier of V) & Q[ x,y ]))))
proof
let x;
assume A22: x in If;
then ( p . x ) in ( rng p ) by A20,FUNCT_1:def 3;
then reconsider px = ( p . x ) as (Subset of V) by XBOOLE_1:1;
consider y such that A23: (y in ( conv A ) & y in ( Int px )) by A19,A22;
take y;
thus thesis by A23;
end;
consider q being (Function of If,V) such that A24: (for x holds (x in If implies Q[ x,( q . x ) ])) from FUNCT_2:sch 1(A21);
reconsider R = ( rng q ) as non empty  finite (Subset of V);
A25: R c= ( conv A )
proof
let y;
assume y in R;
then consider x such that A26: x in ( dom q ) and A27: y = ( q . x ) by FUNCT_1:def 3;
( p . x ) in ( rng p ) by A20,A26,FUNCT_1:def 3;
then reconsider px = ( p . x ) as (Subset of V) by XBOOLE_1:1;
px = ( p . x );
hence thesis by A24,A26,A27;
end;
then A28: R c= ( conv U ) by A4,XBOOLE_1:1;
A29: ( conv R ) c= ( conv A ) by A25,CONVEX1:30;
A30: ( dom q ) = If by FUNCT_2:def 1;
A31: ( ( 1 / ( card R ) ) * ( card R ) ) = ( ( card R ) / ( card R ) ) by XCMPLX_1:99
.= 1 by XCMPLX_1:60;
consider L being (Linear_Combination of R) such that A32: ( Sum L ) = ( ( 1 / ( card R ) ) * ( Sum R ) ) and A33: ( sum L ) = ( ( 1 / ( card R ) ) * ( card R ) ) and A34: L = ( ( ZeroLC V ) +* ( R --> ( 1 / ( card R ) ) ) ) by CKB20:1;
set SL = ( Sum L );
set SLIf = ( SL |-- If );
( Sum L ) = ( ( center_of_mass V ) . R ) by A32,CKB19:def 1;
then A35: ( Sum L ) in ( conv R ) by CKB21:1;
A36: ( dom ( R --> ( 1 / ( card R ) ) ) ) = R by FUNCOP_1:13;
A37:now
let x;
assume A38: x in R;
hence ( L . x ) = ( ( R --> ( 1 / ( card R ) ) ) . x ) by A34,A36,FUNCT_4:13
.= ( 1 / ( card R ) ) by A38,FUNCOP_1:7;
end;
A39: R c= ( Carrier L )
proof
let x;
assume A40: x in R;
then ( L . x ) <> ( 0 ) by A37;
hence thesis by A40;
end;
A41: ( conv U ) c= ( conv If ) by A11,RLAFFIN1:3;
then A42: R c= ( conv If ) by A28,XBOOLE_1:1;
then A43: ( conv R ) c= ( conv If ) by CONVEX1:30;
then A44: SL in ( conv If ) by A35;
A45: R c= ( conv If ) by A28,A41,XBOOLE_1:1;
( Carrier L ) c= R by RLVECT_2:def 6;
then A46: R = ( Carrier L ) by A39,XBOOLE_0:def 10;
A47: If c= ( Carrier SLIf )
proof
let x;
assume A48: x in If;
then consider F being (FinSequence of ( REAL )),G being (FinSequence of V) such that A49: ( SLIf . x ) = ( Sum F ) and A50: ( len G ) = ( len F ) and G is  one-to-one and A51: ( rng G ) = ( Carrier L ) and A52: (for n holds (n in ( dom F ) implies ( F . n ) = ( ( L . ( G . n ) ) * ( ( ( G . n ) |-- If ) . x ) ))) by A31,A33,A42,CKB4:1;
A53: ( p . x ) in ( rng p ) by A20,A48,FUNCT_1:def 3;
then reconsider px = ( p . x ) as (Subset of V) by XBOOLE_1:1;
A54: ( Int px ) c= ( conv px ) by CKB7:1;
A55: ( q . x ) in ( Int px ) by A24,A48;
then A56: ( q . x ) in ( conv px ) by A54;
A57: x in px by A19,A48;
A58: ( conv px ) c= ( Affin px ) by RLAFFIN1:65;
A59: px is  affinely-independent by A53,RLAFFIN1:43;
then ( Sum ( ( q . x ) |-- px ) ) = ( q . x ) by A56,A58,RLAFFIN1:def 7;
then A60: ( Carrier ( ( q . x ) |-- px ) ) = px by A54,A55,A59,CKB15:1,RLAFFIN1:71;
( ( q . x ) |-- px ) = ( ( q . x ) |-- If ) by A53,A56,A58,RLAFFIN1:77;
then A61: ( ( ( q . x ) |-- If ) . x ) <> ( 0 ) by A57,A60,RLVECT_2:19;
( conv px ) c= ( conv If ) by A53,RLAFFIN1:3;
then A62: ( ( ( q . x ) |-- If ) . x ) >= ( 0 ) by A48,A56,RLAFFIN1:71;
A63: ( q . x ) in R by A30,A48,FUNCT_1:def 3;
then A64: ( L . ( q . x ) ) = ( 1 / ( card R ) ) by A37;
A65: ( dom G ) = ( dom F ) by A50,FINSEQ_3:29;
A66:now
let m being Nat;
assume A67: m in ( dom F );
then ( G . m ) in R by A46,A51,A65,FUNCT_1:def 3;
then A68: (( L . ( G . m ) ) > ( 0 ) & ( ( ( G . m ) |-- If ) . x ) >= ( 0 )) by A37,A45,A48,RLAFFIN1:71;
( F . m ) = ( ( L . ( G . m ) ) * ( ( ( G . m ) |-- If ) . x ) ) by A52,A67;
hence ( 0 ) <= ( F . m ) by A68;
end;
consider n being set such that A69: n in ( dom G ) and A70: ( G . n ) = ( q . x ) by A39,A51,A63,FUNCT_1:def 3;
( F . n ) = ( ( L . ( q . x ) ) * ( ( ( q . x ) |-- If ) . x ) ) by A52,A65,A69,A70;
then ( SLIf . x ) > ( 0 ) by A49,A61,A62,A64,A65,A66,A69,RVSUM_1:85;
hence thesis by A48;
end;
( Carrier SLIf ) c= If by RLVECT_2:def 6;
then (( Carrier SLIf ) = If & SLIf is  convex) by A47,A35,A43,RLAFFIN1:71,XBOOLE_0:def 10;
then (( conv If ) c= ( Affin If ) & ( Sum SLIf ) in ( Int If )) by CKB16:1,RLAFFIN1:65;
then SL in ( Int If ) by A44,RLAFFIN1:def 7;
hence contradiction by A3,A29,A35,XBOOLE_0:3;
end;
hence thesis by A4,A11,XBOOLE_0:def 8;
end;
