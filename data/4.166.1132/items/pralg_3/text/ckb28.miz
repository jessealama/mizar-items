environ
vocabularies XBOOLE_0,PBOOLE,STRUCT_0,MSUALG_1,SUBSET_1,PRALG_2,EQREL_1,FUNCT_1,CARD_3,RELAT_1,SETFAM_1,RLVECT_2,FUNCT_6,TARSKI,FUNCT_2,MARGREL1,UNIALG_2,FUNCT_5,FUNCOP_1,FINSEQ_4,FINSEQ_1,CARD_1,PARTFUN1,MSUALG_3,MEMBER_1,ARYTM_3,WELLORD1,PRALG_3;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,STRUCT_0,FUNCT_2,FUNCOP_1,EQREL_1,FINSEQ_1,FUNCT_5,FUNCT_6,CARD_3,NUMBERS,PBOOLE,MSUALG_1,MSUALG_3,PRALG_2,PRALG_1,MSUALG_2,CKB8;
definitions XBOOLE_0,FUNCT_1,MSUALG_3,PRALG_2,PBOOLE,TARSKI,CKB8;
theorems PBOOLE,FUNCT_1,EQREL_1,PRALG_2,MSUALG_1,MSUALG_3,FUNCT_2,CARD_3,TARSKI,FUNCOP_1,MSUALG_2,PRALG_1,FINSEQ_1,FUNCT_6,RELAT_1,RELSET_1,XBOOLE_0,XBOOLE_1,PARTFUN1,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27;
schemes PBOOLE,MSSUBFAM;
registrations XBOOLE_0,SUBSET_1,SETFAM_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCOP_1,EQREL_1,PBOOLE,STRUCT_0,MSUALG_1,PRALG_2,MSUALG_3,ORDINAL1,CARD_3,RELSET_1,FINSEQ_1,CKB1,CKB2,CKB13;
constructors SETFAM_1,EQREL_1,PRALG_1,PRALG_2,MSUALG_3,RELSET_1,FUNCT_5,CKB8;
requirements BOOLE,SUBSET;
begin
reserve I for non empty set;
reserve S for non void non empty ManySortedSign;
definition
let I;
let S;
let A being (MSAlgebra-Family of I,S);
let i being (Element of I);
func proj (A,i) -> (ManySortedFunction of ( product A ),( A . i ))
means
:Def3: (for s being (Element of S) holds ( it . s ) = ( proj (( Carrier (A,s) ),i) ));
existence
proof
deffunc G((Element of S)) = ( proj (( Carrier (A,$1) ),i) );
consider F being (ManySortedSet of (the carrier of S)) such that A1: (for s being (Element of S) holds ( F . s ) = G(s)) from PBOOLE:sch 5;
F is (ManySortedFunction of ( product A ),( A . i ))
proof
let s being set;
assume that
A2: s in (the carrier of S);
( F . s ) is (Function of ( (the Sorts of ( product A )) . s ),( (the Sorts of ( A . i )) . s ))
proof
reconsider s9 = s as (Element of S) by A2;
( F . s ) = ( proj (( Carrier (A,s9) ),i) ) by A1;
then reconsider F9 = ( F . s ) as Function;
A3: ( rng F9 ) c= ( (the Sorts of ( A . i )) . s )
proof
let y being set;
A4: (( dom ( Carrier (A,s9) ) ) = I & (ex U0 being MSAlgebra over S st (U0 = ( A . i ) & ( ( Carrier (A,s9) ) . i ) = ( (the Sorts of U0) . s9 )))) by PARTFUN1:def 2,PRALG_2:def 9;
assume y in ( rng F9 );
then y in ( rng ( proj (( Carrier (A,s9) ),i) ) ) by A1;
then consider x1 being set such that A5: x1 in ( dom ( proj (( Carrier (A,s9) ),i) ) ) and A6: y = ( ( proj (( Carrier (A,s9) ),i) ) . x1 ) by FUNCT_1:def 3;
A7: x1 in ( product ( Carrier (A,s9) ) ) by A5,CARD_3:def 16;
then reconsider x1 as Function;
y = ( x1 . i ) by A5,A6,CARD_3:def 16;
hence thesis by A7,A4,CARD_3:9;
end;
( dom F9 ) = ( dom ( proj (( Carrier (A,s9) ),i) ) ) by A1
.= ( product ( Carrier (A,s9) ) ) by CARD_3:def 16
.= ( (the Sorts of ( product A )) . s ) by PRALG_2:def 10;
hence thesis by A2,A3,FUNCT_2:def 1,RELSET_1:4;
end;
hence thesis;
end;
then reconsider F9 = F as (ManySortedFunction of ( product A ),( A . i ));
take F9;
thus thesis by A1;
end;
uniqueness
proof
let F being (ManySortedFunction of ( product A ),( A . i )),G being (ManySortedFunction of ( product A ),( A . i ));
assume that
A8: (for s being (Element of S) holds ( F . s ) = ( proj (( Carrier (A,s) ),i) ))
and
A9: (for s being (Element of S) holds ( G . s ) = ( proj (( Carrier (A,s) ),i) ));
now
let s9 being set;
assume s9 in (the carrier of S);
then reconsider s99 = s9 as (Element of S);
thus ( F . s9 ) = ( proj (( Carrier (A,s99) ),i) ) by A8
.= ( G . s9 ) by A9;
end;
hence F = G by PBOOLE:3;
end;
end;
