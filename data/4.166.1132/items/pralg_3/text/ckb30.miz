environ
vocabularies XBOOLE_0,PBOOLE,STRUCT_0,MSUALG_1,SUBSET_1,PRALG_2,EQREL_1,FUNCT_1,CARD_3,RELAT_1,SETFAM_1,RLVECT_2,FUNCT_6,TARSKI,FUNCT_2,MARGREL1,UNIALG_2,FUNCT_5,FUNCOP_1,FINSEQ_4,FINSEQ_1,CARD_1,PARTFUN1,MSUALG_3,MEMBER_1,ARYTM_3,WELLORD1,PRALG_3;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,STRUCT_0,FUNCT_2,FUNCOP_1,EQREL_1,FINSEQ_1,FUNCT_5,FUNCT_6,CARD_3,NUMBERS,PBOOLE,MSUALG_1,MSUALG_3,PRALG_2,PRALG_1,MSUALG_2,CKB8,CKB28;
definitions XBOOLE_0,FUNCT_1,MSUALG_3,PRALG_2,PBOOLE,TARSKI,CKB8,CKB28;
theorems PBOOLE,FUNCT_1,EQREL_1,PRALG_2,MSUALG_1,MSUALG_3,FUNCT_2,CARD_3,TARSKI,FUNCOP_1,MSUALG_2,PRALG_1,FINSEQ_1,FUNCT_6,RELAT_1,RELSET_1,XBOOLE_0,XBOOLE_1,PARTFUN1,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29;
schemes PBOOLE,MSSUBFAM;
registrations XBOOLE_0,SUBSET_1,SETFAM_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCOP_1,EQREL_1,PBOOLE,STRUCT_0,MSUALG_1,PRALG_2,MSUALG_3,ORDINAL1,CARD_3,RELSET_1,FINSEQ_1,CKB1,CKB2,CKB13;
constructors SETFAM_1,EQREL_1,PRALG_1,PRALG_2,MSUALG_3,RELSET_1,FUNCT_5,CKB8,CKB28;
requirements BOOLE,SUBSET;
begin
reserve I for non  empty set;
reserve S for non  void non  empty ManySortedSign;
reserve i for (Element of I);
reserve A for (MSAlgebra-Family of I,S);
reserve o for (OperSymbol of S);
theorem
(for i being (Element of I) holds (for A being (MSAlgebra-Family of I,S) holds ( proj (A,i) ) is_homomorphism ( product A ),( A . i )))
proof
let i being (Element of I);
let A being (MSAlgebra-Family of I,S);
thus ( proj (A,i) ) is_homomorphism ( product A ),( A . i )
proof
let o being (OperSymbol of S);
assume that
( Args (o,( product A )) ) <> ( {} );
let x being (Element of ( Args (o,( product A )) ));
set F = ( proj (A,i) );
set s = ( the_result_sort_of o );
o in (the carrier' of S);
then A1: o in ( dom (the ResultSort of S) ) by FUNCT_2:def 1;
A2: ( Result (o,( product A )) ) = ( ( (the Sorts of ( product A )) * (the ResultSort of S) ) . o ) by MSUALG_1:def 5
.= ( (the Sorts of ( product A )) . ( (the ResultSort of S) . o ) ) by A1,FUNCT_1:13
.= ( ( SORTS A ) . s ) by MSUALG_1:def 2
.= ( product ( Carrier (A,s) ) ) by PRALG_2:def 10;
thus ( ( F . s ) . ( ( Den (o,( product A )) ) . x ) ) = ( ( Den (o,( A . i )) ) . ( F # x ) )
proof
per cases ;
suppose A3: ( the_arity_of o ) = ( {} );

then ( const (o,( product A )) ) in ( product ( Carrier (A,s) ) ) by A2,CKB9:1;
then A4: ( const (o,( product A )) ) in ( dom ( proj (( Carrier (A,s) ),i) ) ) by CARD_3:def 16;
A5: ( Args (o,( product A )) ) = { ( {} ) } by A3,PRALG_2:4;
then A6: x = ( {} ) by TARSKI:def 1;
( ( F . s ) . ( ( Den (o,( product A )) ) . x ) ) = ( ( F . s ) . ( const (o,( product A )) ) ) by A5,TARSKI:def 1
.= ( ( proj (( Carrier (A,s) ),i) ) . ( const (o,( product A )) ) ) by CKB28:def 1
.= ( ( const (o,( product A )) ) . i ) by A4,CARD_3:def 16
.= ( const (o,( A . i )) ) by A3,CKB14:1
.= ( ( Den (o,( A . i )) ) . ( F # x ) ) by A3,A6,CKB16:1;
hence thesis;
end;
suppose A7: ( the_arity_of o ) <> ( {} );

reconsider D = ( ( Den (o,( product A )) ) . x ) as Function by A2;
( ( Den (o,( product A )) ) . x ) in ( product ( Carrier (A,s) ) ) by A2;
then A8: ( ( Den (o,( product A )) ) . x ) in ( dom ( proj (( Carrier (A,s) ),i) ) ) by CARD_3:def 16;
( ( F . s ) . ( ( Den (o,( product A )) ) . x ) ) = ( ( proj (( Carrier (A,s) ),i) ) . ( ( Den (o,( product A )) ) . x ) ) by CKB28:def 1
.= ( D . i ) by A8,CARD_3:def 16
.= ( ( Den (o,( A . i )) ) . ( ( commute x ) . i ) ) by A7,CKB27:1
.= ( ( Den (o,( A . i )) ) . ( ( proj (A,i) ) # x ) ) by A7,CKB29:1;
hence thesis;
end;
end;

end;

end;
