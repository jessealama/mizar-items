environ
vocabularies NUMBERS,NAT_1,XBOOLE_0,FINSEQ_1,MODELC_2,SUBSET_1,ZF_LANG,XREAL_0,ORDINAL1,FUNCT_1,RELAT_1,XXREAL_0,INT_1,ARYTM_3,ARYTM_1,CARD_1,STRUCT_0,TARSKI,XBOOLEAN,LATTICES,CAT_3,ORDINAL4,ZF_MODEL,MODELC_1,FINSET_1,SEQ_1,REAL_1,CARD_3,SERIES_1,ZFMISC_1,MSUALG_3,ORDERS_1,SUBSTUT1,FSM_1,FSM_2,VALUED_1,MODELC_3;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,FINSET_1,CARD_1,NUMBERS,XCMPLX_0,XREAL_0,REAL_1,XXREAL_0,NAT_1,RELAT_1,FUNCT_1,RELSET_1,FINSEQ_1,ORDERS_1,FUNCT_2,INT_1,SEQ_1,SERIES_1,PARTFUN1,STRUCT_0,MODELC_1,MODELC_2,RFINSEQ2,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB38,CKB39,CKB40,CKB54,CKB55,CKB56,CKB64,CKB76,CKB77,CKB82,CKB106,CKB108,CKB114,CKB115,CKB132,CKB134,CKB138,CKB140,CKB142,CKB148,CKB149,CKB150,CKB151,CKB152,CKB153,CKB154,CKB155,CKB156,CKB157,CKB159,CKB160,CKB162;
definitions TARSKI,MODELC_2,SERIES_1,CKB16,CKB17,CKB18,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB38,CKB39,CKB40,CKB54,CKB55,CKB56,CKB64,CKB76,CKB77,CKB82,CKB106,CKB108,CKB114,CKB115,CKB132,CKB134,CKB138,CKB140,CKB142,CKB149,CKB150,CKB151,CKB152,CKB153,CKB154,CKB155,CKB156,CKB157,CKB159,CKB160,CKB162;
theorems XBOOLE_0,ZFMISC_1,XBOOLE_1,TARSKI,FUNCT_1,FUNCT_2,FUNCT_7,WELLORD2,NAT_1,INT_1,ENUMSET1,XREAL_1,FINSEQ_1,ORDERS_1,XXREAL_0,MODELC_1,MODELC_2,ORDINAL1,SUBSET_1,FINSEQ_4,SERIES_1,CARD_1,CARD_2,SERIES_2,FINSET_1,RFINSEQ2,FINSEQ_3,SUBSET,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB16,CKB17,CKB18,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB54,CKB55,CKB56,CKB57,CKB58,CKB59,CKB60,CKB61,CKB62,CKB63,CKB64,CKB65,CKB66,CKB67,CKB68,CKB69,CKB70,CKB71,CKB72,CKB73,CKB74,CKB75,CKB76,CKB77,CKB78,CKB79,CKB80,CKB81,CKB82,CKB83,CKB84,CKB85,CKB86,CKB87,CKB88,CKB89,CKB90,CKB91,CKB92,CKB93,CKB94,CKB95,CKB96,CKB97,CKB98,CKB99,CKB100,CKB101,CKB102,CKB103,CKB104,CKB105,CKB106,CKB108,CKB110,CKB111,CKB112,CKB113,CKB114,CKB115,CKB116,CKB117,CKB118,CKB119,CKB120,CKB121,CKB122,CKB123,CKB124,CKB125,CKB126,CKB127,CKB128,CKB131,CKB132,CKB133,CKB134,CKB135,CKB136,CKB137,CKB138,CKB139,CKB140,CKB142,CKB143,CKB144,CKB145,CKB146,CKB147,CKB149,CKB150,CKB151,CKB152,CKB153,CKB154,CKB155,CKB156,CKB157,CKB158,CKB159,CKB160,CKB161,CKB162,CKB163,CKB164,CKB165,CKB166,CKB167,CKB168;
schemes NAT_1,FUNCT_2,MODELC_2,TARSKI,FUNCT_1,FINSEQ_1,RECDEF_1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,XXREAL_0,XREAL_0,NAT_1,INT_1,ORDERS_1,FINSET_1,MODELC_2,FINSEQ_1,NUMBERS,VALUED_0,MEMBERED,STRUCT_0,MODELC_1,CARD_1,RELSET_1,FUNCT_2,CKB19,CKB31,CKB53,CKB107,CKB109,CKB129,CKB130,CKB141,CKB148;
constructors KNASTER,MODELC_2,SERIES_1,REAL_1,NEWTON,RFINSEQ2,SEQ_1,RELSET_1,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB38,CKB39,CKB40,CKB54,CKB55,CKB56,CKB64,CKB76,CKB77,CKB82,CKB106,CKB108,CKB114,CKB115,CKB132,CKB134,CKB138,CKB140,CKB142,CKB148,CKB149,CKB150,CKB151,CKB152,CKB153,CKB154,CKB155,CKB156,CKB157,CKB159,CKB160,CKB162;
requirements REAL,NUMERALS,ARITHM,SUBSET,BOOLE;
begin
reserve k for Nat;
reserve n for Nat;
reserve m for Nat;
reserve h for Nat;
reserve a for set;
reserve x for set;
reserve L for FinSequence;
reserve F for LTL-formula;
reserve H for LTL-formula;
reserve w for (Element of ( Inf_seq ( AtomicFamily ) ));
reserve v for  neg-inner-most LTL-formula;
reserve N for  strict LTLnode over v;
theorem
Th75: (w |= v implies w is-accepted-by ( BAutomaton v ))
proof
set LS = ( LTLStates v );
set LT = ( Tran_LTL v );
set IS = ( InitS_LTL v );
set FS = ( FinalS_LTL v );
assume A1: w |= v;
(ex run being (sequence of LS) st (( run . ( 0 ) ) in IS & (for n holds ([ [ ( run . n ),( ( CastSeq (w,( AtomicFamily )) ) . n ) ],( run . ( n + 1 ) ) ] in LT & (for FSet being set holds (FSet in FS implies { k where k is (Element of ( NAT )): ( run . k ) in FSet } is  infinite  infinite set))))))
proof
set chf = the (Choice_Function of ( BOOL ( Subformulae v ) ));
deffunc R(set) = ( ( chosen_run (w,v,chf) ) . ( k_nat $1 ) );
A2: (for x holds (x in ( NAT ) implies R(x) in LS));
(ex run being (Function of ( NAT ),LS) st (for x holds (x in ( NAT ) implies ( run . x ) = R(x)))) from FUNCT_2:sch 2(A2);
then consider run being (sequence of LS) such that A3: (for x holds (x in ( NAT ) implies ( run . x ) = R(x)));
deffunc Run(Nat) = ( CastNode (( run . $1 ),v) );
A4: (for n holds (( run . n ) is  elementary  strict  elementary  strict LTLnode over v & Run(n) is  elementary  strict  elementary  strict LTLnode over v))
proof
let n;
reconsider n as (Element of ( NAT )) by ORDINAL1:def 12;
set Rn = Run(n);
( run . n ) in LS;
then consider N being (Element of ( LTLNodes v )) such that A5: N = ( run . n ) and A6: N is  elementary  strict  elementary  strict LTLnode over v;
reconsider N as  elementary  strict LTLnode over v by A6;
(the LTLnew of Rn) = (the LTLnew of N) by A5,CKB33:def 1
.= ( {} ) by CKB27:def 1;
hence thesis by A5,A6,CKB27:def 1;
end;
A7: (for n holds ( run . n ) = ( ( chosen_run (w,v,chf) ) . n ))
proof
let n;
reconsider n as (Element of ( NAT )) by ORDINAL1:def 12;
( run . n ) = R(n) by A3;
hence thesis by MODELC_1:def 2;
end;
A8: (for n holds (Run(( n + 1 )) is_next_of Run(n) & ( Shift (w,n) ) |= ( * Run(( n + 1 )) )))
proof
let n;
set Rn = Run(n);
reconsider Rn as  elementary  strict LTLnode over v by A4;
set n1 = ( n + 1 );
set w1 = ( Shift (w,n) );
A9: ( run . n ) = ( ( chosen_run (w,v,chf) ) . n ) by A7;
Run(n) = ( CastNode (( ( chosen_run (w,v,chf) ) . n ),v) ) by A7;
then A10: w1 |= ( * ( 'X' Rn ) ) by A1,CKB167:1;
( run . n1 ) = ( ( chosen_run (w,v,chf) ) . n1 ) by A7
.= ( chosen_next (w1,v,chf,Rn) ) by A9,CKB162:def 1;
then Run(n1) = ( chosen_next (w1,v,chf,Rn) ) by CKB33:def 1;
hence thesis by A10,CKB161:1;
end;
A11: (for n holds ( ( CastSeq (w,( AtomicFamily )) ) . n ) in ( Label_ Run(( n + 1 )) ))
proof
let n;
reconsider n as (Element of ( NAT )) by ORDINAL1:def 12;
set Rn1 = Run(( n + 1 ));
set w1 = ( Shift (w,n) );
set X = ( ( CastSeq (w,( AtomicFamily )) ) . n );
reconsider X as (Subset of ( atomic_LTL ));
( CastSeq (w1,( AtomicFamily )) ) = ( ( CastSeq (w,( AtomicFamily )) ) ^\ n ) by MODELC_2:81;
then A12: ( ( CastSeq (w1,( AtomicFamily )) ) . ( 0 ) ) = ( ( CastSeq (w,( AtomicFamily )) ) . ( ( 0 ) + n ) ) by NAT_1:def 3;
A13: w1 |= ( * Rn1 ) by A8;
A14:now
assume (not ( Neg_atomic_LTL Rn1 ) misses X);
then ( ( Neg_atomic_LTL Rn1 ) /\ X ) <> ( {} ) by XBOOLE_0:def 7;
then consider a such that A15: a in ( ( Neg_atomic_LTL Rn1 ) /\ X ) by XBOOLE_0:def 1;
a in ( Neg_atomic_LTL Rn1 ) by A15,XBOOLE_0:def 4;
then consider x being LTL-formula such that A16: (x = a & x is  atomic) and A17: ( 'not' x ) in (the LTLold of Rn1);
( 'not' x ) in ( * Rn1 ) by A17,CKB1:1;
then w1 |= ( 'not' x ) by A13,MODELC_2:def 64;
then A18: w1 |/= x by MODELC_2:64;
a in X by A15,XBOOLE_0:def 4;
hence contradiction by A12,A16,A18,MODELC_2:63;
end;
( atomic_LTL Rn1 ) c= X
proof
let a;
assume a in ( atomic_LTL Rn1 );
then consider x being LTL-formula such that A19: (x = a & x is  atomic) and A20: x in (the LTLold of Rn1);
x in ( * Rn1 ) by A20,CKB1:1;
then w1 |= x by A13,MODELC_2:def 64;
hence thesis by A12,A19,MODELC_2:63;
end;
hence thesis by A14;
end;
A21: (for n holds [ [ ( run . n ),( ( CastSeq (w,( AtomicFamily )) ) . n ) ],( run . ( n + 1 ) ) ] in LT)
proof
let n;
reconsider n as (Element of ( NAT )) by ORDINAL1:def 12;
set R = Run(n);
reconsider R as  elementary  strict LTLnode over v by A4;
set n1 = ( n + 1 );
set r = ( run . n );
set r1 = ( run . n1 );
set R1 = Run(n1);
set gA = ( ( CastSeq (w,( AtomicFamily )) ) . n );
set y = [ [ r,gA ],r1 ];
reconsider R1 as  elementary  strict LTLnode over v by A4;
[ r,gA ] in [: LS,( AtomicFamily ) :] by ZFMISC_1:87;
then [ [ r,gA ],r1 ] in [: [: LS,( AtomicFamily ) :],LS :] by ZFMISC_1:87;
then A22: y is (Element of [: LS,( AtomicFamily ),LS :]) by ZFMISC_1:def 3;
reconsider r1 as  elementary  strict LTLnode over v by A4;
reconsider r as  elementary  strict LTLnode over v by A4;
A23: (R1 is_next_of R & gA in ( Label_ R1 )) by A8,A11;
(R = r & R1 = r1) by CKB33:def 1;
hence thesis by A22,A23;
end;
A24: (for n holds (for H holds (((H in (the LTLold of Run(( n + 1 ))) & H is  Until) & ( Shift (w,n) ) |= ( the_right_argument_of H )) implies ( the_right_argument_of H ) in (the LTLold of Run(( n + 1 ))))))
proof
let n;
let H;
set n1 = ( n + 1 );
Run(n1) = ( CastNode (( ( chosen_run (w,v,chf) ) . n1 ),v) ) by A7;
hence thesis by A1,CKB168:1;
end;
A25: (for FSet being set holds (FSet in FS implies { k where k is (Element of ( NAT )): ( run . k ) in FSet } is  infinite  infinite set))
proof
let FSet being set;
set FK = { k where k is (Element of ( NAT )): ( run . k ) in FSet };
assume FSet in FS;
then consider x being (Element of ( bool LS )) such that A26: FSet = x and A27: (ex F st ((F is_subformula_of v & F is  Until) & x = ( FinalS_LTL (F,v) )));
consider F such that F is_subformula_of v and A28: F is  Until and A29: x = ( FinalS_LTL (F,v) ) by A27;
set F2 = ( the_right_argument_of F );
set F1 = ( the_left_argument_of F );
A30: F = ( F1 'U' F2 ) by A28,MODELC_2:8;
now
assume (not FK is  infinite  infinite set);
then consider L such that A31: FK = ( rng L ) by FINSEQ_1:52;
(ex m st (for k holds (m <= k implies (not k in FK))))
proof
A32: (( len L ) = ( 0 ) or ( 0 ) < ( ( 0 ) + ( len L ) ));
now
per cases  by A32,NAT_1:19;
suppose A33: 1 <= ( len L );

set LEN = ( len L );
FK c= ( REAL )
proof
let a;
assume a in FK;
then (ex k being (Element of ( NAT )) st (a = k & ( run . k ) in FSet));
hence thesis;
end;
then reconsider L as (FinSequence of ( REAL )) by A31,FINSEQ_1:def 4;
set realMAX = ( max L );
set iMAX = [/ realMAX \];
set natMAX = ( iMAX + 1 );
( 0 ) <= realMAX
proof
set b = ( L . LEN );
LEN in ( Seg ( len L ) ) by A33,FINSEQ_1:1;
then LEN in ( dom L ) by FINSEQ_1:def 3;
then b in ( rng L ) by FUNCT_1:3;
then (ex k being (Element of ( NAT )) st (k = b & ( run . k ) in FSet)) by A31;
hence thesis by A33,RFINSEQ2:1;
end;
then reconsider iMAX as Nat by INT_1:53;
( iMAX + 1 ) is Nat;
then reconsider natMAX as Nat;
(for k holds (natMAX <= k implies (not k in FK)))
proof
let k;
assume A34: natMAX <= k;
now
assume k in FK;
then consider i1 being set such that A35: i1 in ( dom L ) and A36: k = ( L . i1 ) by A31,FUNCT_1:def 3;
reconsider i1 as (Element of ( NAT )) by A35;
i1 in ( Seg LEN ) by A35,FINSEQ_1:def 3;
then (1 <= i1 & i1 <= LEN) by FINSEQ_1:1;
then k <= realMAX by A36,RFINSEQ2:1;
hence contradiction by A34,INT_1:32,XXREAL_0:2;
end;
hence thesis;
end;
hence thesis;
end;
suppose ( len L ) = ( 0 );

then L = ( {} );
then (for k holds (( 0 ) <= k implies (not k in FK))) by A31;
hence thesis;
end;
end;
hence thesis;
end;
then consider m such that A37: (for k holds (m <= k implies (not k in FK)));
A38: (for k holds (m <= k implies (F in (the LTLold of Run(k)) & (not F2 in (the LTLold of Run(k))))))
proof
let k;
assume m <= k;
then A39: (not k in FK) by A37;
reconsider k as (Element of ( NAT )) by ORDINAL1:def 12;
set r = ( run . k );
reconsider r as  elementary  strict LTLnode over v by A4;
now
assume (not (F in (the LTLold of ( CastNode (r,v) )) & (not F2 in (the LTLold of ( CastNode (r,v) )))));
then r in FSet by A26,A29;
hence contradiction by A39;
end;
hence thesis;
end;
set w1 = ( Shift (w,m) );
set m1 = ( m + 1 );
A40: w1 |= ( * Run(m1) ) by A8;
m <= m1 by NAT_1:11;
then F in (the LTLold of Run(m1)) by A38;
then F in ( * Run(m1) ) by CKB1:1;
then w1 |= F by A40,MODELC_2:def 64;
then consider h such that (for j being Nat holds (j < h implies ( Shift (w1,j) ) |= F1)) and A41: ( Shift (w1,h) ) |= F2 by A30,MODELC_2:68;
set m2 = ( m + h );
set m3 = ( m2 + 1 );
m3 = ( m + ( h + 1 ) );
then m <= m3 by NAT_1:11;
then A42: (F in (the LTLold of Run(m3)) & (not F2 in (the LTLold of Run(m3)))) by A38;
( Shift (w,m2) ) |= F2 by A41,MODELC_2:80;
hence contradiction by A24,A28,A42;
end;
hence thesis;
end;
( run . ( 0 ) ) = ( ( chosen_run (w,v,chf) ) . ( 0 ) ) by A7
.= ( init v ) by CKB162:def 1;
then ( run . ( 0 ) ) in IS by TARSKI:def 1;
hence thesis by A21,A25;
end;
hence thesis by CKB149:def 1;
end;
