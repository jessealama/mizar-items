environ
vocabularies NUMBERS,NAT_1,XBOOLE_0,FINSEQ_1,MODELC_2,SUBSET_1,ZF_LANG,XREAL_0,ORDINAL1,FUNCT_1,RELAT_1,XXREAL_0,INT_1,ARYTM_3,ARYTM_1,CARD_1,STRUCT_0,TARSKI,XBOOLEAN,LATTICES,CAT_3,ORDINAL4,ZF_MODEL,MODELC_1,FINSET_1,SEQ_1,REAL_1,CARD_3,SERIES_1,ZFMISC_1,MSUALG_3,ORDERS_1,SUBSTUT1,FSM_1,FSM_2,VALUED_1,MODELC_3;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,FINSET_1,CARD_1,NUMBERS,XCMPLX_0,XREAL_0,REAL_1,XXREAL_0,NAT_1,RELAT_1,FUNCT_1,RELSET_1,FINSEQ_1,ORDERS_1,FUNCT_2,INT_1,SEQ_1,SERIES_1,PARTFUN1,STRUCT_0,MODELC_1,MODELC_2,RFINSEQ2,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB38,CKB39,CKB40,CKB54,CKB55,CKB56,CKB64,CKB76,CKB77,CKB82,CKB106,CKB108,CKB114,CKB115,CKB132,CKB134,CKB138,CKB140,CKB142,CKB148,CKB149,CKB150,CKB151,CKB152,CKB153,CKB154,CKB155,CKB156,CKB157;
definitions TARSKI,MODELC_2,SERIES_1,CKB16,CKB17,CKB18,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB38,CKB39,CKB40,CKB54,CKB55,CKB56,CKB64,CKB76,CKB77,CKB82,CKB106,CKB108,CKB114,CKB115,CKB132,CKB134,CKB138,CKB140,CKB142,CKB149,CKB150,CKB151,CKB152,CKB153,CKB154,CKB155,CKB156,CKB157;
theorems XBOOLE_0,ZFMISC_1,XBOOLE_1,TARSKI,FUNCT_1,FUNCT_2,FUNCT_7,WELLORD2,NAT_1,INT_1,ENUMSET1,XREAL_1,FINSEQ_1,ORDERS_1,XXREAL_0,MODELC_1,MODELC_2,ORDINAL1,SUBSET_1,FINSEQ_4,SERIES_1,CARD_1,CARD_2,SERIES_2,FINSET_1,RFINSEQ2,FINSEQ_3,SUBSET,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB16,CKB17,CKB18,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB54,CKB55,CKB56,CKB57,CKB58,CKB59,CKB60,CKB61,CKB62,CKB63,CKB64,CKB65,CKB66,CKB67,CKB68,CKB69,CKB70,CKB71,CKB72,CKB73,CKB74,CKB75,CKB76,CKB77,CKB78,CKB79,CKB80,CKB81,CKB82,CKB83,CKB84,CKB85,CKB86,CKB87,CKB88,CKB89,CKB90,CKB91,CKB92,CKB93,CKB94,CKB95,CKB96,CKB97,CKB98,CKB99,CKB100,CKB101,CKB102,CKB103,CKB104,CKB105,CKB106,CKB108,CKB110,CKB111,CKB112,CKB113,CKB114,CKB115,CKB116,CKB117,CKB118,CKB119,CKB120,CKB121,CKB122,CKB123,CKB124,CKB125,CKB126,CKB127,CKB128,CKB131,CKB132,CKB133,CKB134,CKB135,CKB136,CKB137,CKB138,CKB139,CKB140,CKB142,CKB143,CKB144,CKB145,CKB146,CKB147,CKB149,CKB150,CKB151,CKB152,CKB153,CKB154,CKB155,CKB156,CKB157;
schemes NAT_1,FUNCT_2,MODELC_2,TARSKI,FUNCT_1,FINSEQ_1,RECDEF_1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,XXREAL_0,XREAL_0,NAT_1,INT_1,ORDERS_1,FINSET_1,MODELC_2,FINSEQ_1,NUMBERS,VALUED_0,MEMBERED,STRUCT_0,MODELC_1,CARD_1,RELSET_1,FUNCT_2,CKB19,CKB31,CKB53,CKB107,CKB109,CKB129,CKB130,CKB141,CKB148;
constructors KNASTER,MODELC_2,SERIES_1,REAL_1,NEWTON,RFINSEQ2,SEQ_1,RELSET_1,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB38,CKB39,CKB40,CKB54,CKB55,CKB56,CKB64,CKB76,CKB77,CKB82,CKB106,CKB108,CKB114,CKB115,CKB132,CKB134,CKB138,CKB140,CKB142,CKB148,CKB149,CKB150,CKB151,CKB152,CKB153,CKB154,CKB155,CKB156,CKB157;
requirements REAL,NUMERALS,ARITHM,SUBSET,BOOLE;
begin
reserve k for Nat;
reserve n for Nat;
reserve m for Nat;
reserve i for Nat;
reserve j for Nat;
reserve x for set;
reserve y for set;
reserve F for LTL-formula;
reserve w for (Element of ( Inf_seq ( AtomicFamily ) ));
reserve v for  neg-inner-most LTL-formula;
reserve s for  elementary  strict LTLnode over v;
reserve s1 for  elementary  strict LTLnode over v;
theorem
Th68: (w is-accepted-by ( BAutomaton v ) implies w |= v)
proof
deffunc Gzai(Nat) = ( ( CastSeq (w,( AtomicFamily )) ) . $1 );
assume w is-accepted-by ( BAutomaton v );
then consider run being (sequence of ( LTLStates v )) such that A1: ( run . ( 0 ) ) in ( InitS_LTL v ) and A2: (for i holds [ [ ( run . i ),Gzai(i) ],( run . ( i + 1 ) ) ] in ( Tran_LTL v )) and A3: (for FSet being set holds (FSet in ( FinalS_LTL v ) implies { k where k is (Element of ( NAT )): ( run . k ) in FSet } is  infinite  infinite set)) by CKB149:def 1;
deffunc Run(Nat) = ( CastNode (( run . $1 ),v) );
set Run01 = Run(( ( 0 ) + 1 ));
set Run00 = Run(( 0 ));
A4: (for i holds (Run(( i + 1 )) is_next_of Run(i) & Gzai(i) in ( Label_ Run(( i + 1 )) )))
proof
let i;
set z = [ [ ( run . i ),Gzai(i) ],( run . ( i + 1 ) ) ];
z in ( Tran_LTL v ) by A2;
then consider y being (Element of [: ( LTLStates v ),( AtomicFamily ),( LTLStates v ) :]) such that A5: z = y and A6: (ex s st (ex s1 st (ex x st ((y = [ [ s,x ],s1 ] & s1 is_next_of s) & x in ( Label_ s1 )))));
consider s,s1,x such that A7: y = [ [ s,x ],s1 ] and A8: (s1 is_next_of s & x in ( Label_ s1 )) by A6;
A9: Run(( i + 1 )) = ( CastNode (s1,v) ) by A5,A7,ZFMISC_1:27
.= s1 by CKB33:def 1;
A10: [ s,x ] = [ ( run . i ),Gzai(i) ] by A5,A7,ZFMISC_1:27;
then Run(i) = ( CastNode (s,v) ) by ZFMISC_1:27
.= s by CKB33:def 1;
hence thesis by A8,A10,A9,ZFMISC_1:27;
end;
then A11: Run01 is_next_of Run00;
defpred P[ Nat ]
 means
(for i holds (for F holds (((F is_subformula_of v & ( len F ) <= $1) & F in (the LTLold of Run(( i + 1 )))) implies ( Shift (w,i) ) |= F)));
A12: (for i holds Run(i) = ( run . i ))
proof
let i;
reconsider i as (Element of ( NAT )) by ORDINAL1:def 12;
( run . i ) in ( LTLStates v );
then (ex x being (Element of ( LTLNodes v )) st (( run . i ) = x & x is  elementary  strict  elementary  strict LTLnode over v));
hence thesis by CKB33:def 1;
end;
A13: (for FSet being set holds (FSet in ( FinalS_LTL v ) implies { k where k is (Element of ( NAT )): Run(k) in FSet } is  infinite))
proof
let FSet being set;
set X = { k where k is (Element of ( NAT )): ( run . k ) in FSet };
set Y = { k where k is (Element of ( NAT )): Run(k) in FSet };
A14: X c= Y
proof
let x;
assume x in X;
then consider k being (Element of ( NAT )) such that A15: x = k and A16: ( run . k ) in FSet;
Run(k) in FSet by A12,A16;
hence thesis by A15;
end;
assume FSet in ( FinalS_LTL v );
hence thesis by A3,A14;
end;
A17: (for n holds (P[ n ] implies P[ ( n + 1 ) ]))
proof
let n;
assume A18: P[ n ];
A19: (for i holds (for F holds (((F is_subformula_of v & ( len F ) = ( n + 1 )) & F in (the LTLold of Run(( i + 1 )))) implies ( Shift (w,i) ) |= F)))
proof
let i;
let F;
assume that
A20: F is_subformula_of v
and
A21: ( len F ) = ( n + 1 )
and
A22: F in (the LTLold of Run(( i + 1 )));
set zeta = ( Shift (w,i) );
now
per cases  by A20,CKB143:1,CKB145:1;
suppose A23: F is  Sub_atomic;

set Gi9 = ( ( CastSeq (w,( AtomicFamily )) ) ^\ i );
set Gi = Gzai(i);
( CastSeq (zeta,( AtomicFamily )) ) = Gi9 by MODELC_2:81;
then A24: ( ( CastSeq (zeta,( AtomicFamily )) ) . ( 0 ) ) = ( ( CastSeq (w,( AtomicFamily )) ) . ( ( 0 ) + i ) ) by NAT_1:def 3
.= Gi;
Gi in ( Label_ Run(( i + 1 )) ) by A4;
then consider X being (Subset of ( atomic_LTL )) such that A25: Gi = X and A26: ( atomic_LTL Run(( i + 1 )) ) c= X and A27: ( Neg_atomic_LTL Run(( i + 1 )) ) misses X;
A28: ( ( Neg_atomic_LTL Run(( i + 1 )) ) /\ X ) = ( {} ) by A27,XBOOLE_0:def 7;
now
per cases  by A23,CKB144:1;
suppose A29: F is  atomic;

then F in ( atomic_LTL Run(( i + 1 )) ) by A22;
hence thesis by A25,A26,A24,A29,MODELC_2:63;
end;
suppose A30: (F is  negative & ( the_argument_of F ) is  atomic);

set Fa = ( the_argument_of F );
A31: F = ( 'not' Fa ) by A30,MODELC_2:4;
then (zeta |= F iff zeta |/= Fa) by MODELC_2:64;
then A32: (zeta |= F iff (not Fa in Gi)) by A24,A30,MODELC_2:63;
Fa in ( Neg_atomic_LTL Run(( i + 1 )) ) by A22,A30,A31;
hence thesis by A25,A28,A32,XBOOLE_0:def 4;
end;
end;
hence thesis;
end;
suppose A33: (F is  conjunctive or F is  disjunctive);

set h1 = ( the_left_argument_of F );
( len h1 ) < ( n + 1 ) by A21,A33,MODELC_2:11;
then A34: ( len h1 ) <= n by NAT_1:13;
set Runi1 = Run(( i + 1 ));
set Runi = Run(i);
A35: Runi1 is_next_of Runi by A4;
set h2 = ( the_right_argument_of F );
( len h2 ) < ( n + 1 ) by A21,A33,MODELC_2:11;
then A36: ( len h2 ) <= n by NAT_1:13;
reconsider Runi1 as  elementary  strict LTLnode over v by A35,CKB38:def 1;
reconsider Runi as  elementary  strict LTLnode over v by A35,CKB38:def 1;
A37: ((Runi1 is_next_of Runi & F in (the LTLold of Runi1)) implies ((F is  conjunctive implies (h1 in (the LTLold of Runi1) & h2 in (the LTLold of Runi1))) & (F is  disjunctive implies (h1 in (the LTLold of Runi1) or h2 in (the LTLold of Runi1))))) by CKB103:1;
A38: (h1 is_subformula_of F & h2 is_subformula_of F) by A33,MODELC_2:31;
zeta |= F
proof
now
per cases  by A33;
suppose A39: F is  conjunctive;

then (zeta |= h1 & zeta |= h2) by A4,A18,A20,A22,A38,A34,A36,A37,MODELC_2:35;
then zeta |= ( h1 '&' h2 ) by MODELC_2:65;
hence thesis by A39,MODELC_2:6;
end;
suppose A40: F is  disjunctive;

then (zeta |= h1 or zeta |= h2) by A4,A18,A20,A22,A38,A34,A36,A37,MODELC_2:35;
then zeta |= ( h1 'or' h2 ) by MODELC_2:66;
hence thesis by A40,MODELC_2:7;
end;
end;
hence thesis;
end;
hence thesis;
end;
suppose A41: F is  next;

set i1 = ( i + 1 );
set Runi1 = Run(i1);
set Runi2 = Run(( i1 + 1 ));
Runi2 is_next_of Runi1 by A4;
then reconsider Runi2 as  elementary  strict LTLnode over v by CKB38:def 1;
set Runi = Run(i);
A42: Runi1 is_next_of Runi by A4;
set h = ( the_argument_of F );
A43: h is_subformula_of F by A41,MODELC_2:30;
( len h ) < ( n + 1 ) by A21,A41,MODELC_2:10;
then A44: ( len h ) <= n by NAT_1:13;
reconsider Runi1 as  elementary  strict LTLnode over v by A42,CKB38:def 1;
reconsider Runi as  elementary  strict LTLnode over v by A42,CKB38:def 1;
A45: ((Runi1 is_next_of Runi & F in (the LTLold of Runi1)) implies (F is  next implies h in (the LTLnext of Runi1))) by CKB103:1;
(the LTLnext of Runi1) c= (the LTLold of Runi2) by A4,CKB99:1;
then ( Shift (w,i1) ) |= h by A4,A18,A20,A22,A41,A43,A44,A45,MODELC_2:35;
then ( Shift (zeta,1) ) |= h by MODELC_2:80;
then zeta |= ( 'X' h ) by MODELC_2:67;
hence thesis by A41,MODELC_2:5;
end;
suppose A46: F is  Until;

set Fin = ( FinalS_LTL (F,v) );
deffunc Fun(set) = ( run . ( ( CastNat $1 ) + i ) );
set FRun = { k where k is (Element of ( NAT )): Run(k) in Fin };
A47: (for x holds (x in ( NAT ) implies Fun(x) in ( LTLStates v )))
proof
let x;
assume x in ( NAT );
set y = ( ( CastNat x ) + i );
reconsider y as (Element of ( NAT )) by ORDINAL1:def 12;
Fun(x) = ( run . y );
hence thesis;
end;
consider runQ being (Function of ( NAT ),( LTLStates v )) such that A48: (for x holds (x in ( NAT ) implies ( runQ . x ) = Fun(x))) from FUNCT_2:sch 2(A47);
reconsider runQ as (sequence of ( LTLStates v ));
deffunc RunQ(Nat) = ( CastNode (( runQ . $1 ),v) );
A49: (for m holds RunQ(m) = Run(( m + i )))
proof
let m;
reconsider m as (Element of ( NAT )) by ORDINAL1:def 12;
RunQ(m) = ( CastNode (Fun(m),v) ) by A48
.= Run(( m + i )) by MODELC_2:def 1;
hence thesis;
end;
A50: (for m holds RunQ(( m + 1 )) is_next_of RunQ(m))
proof
let m;
set m1 = ( m + i );
A51: RunQ(( m + 1 )) = Run(( ( m + 1 ) + i )) by A49
.= Run(( m1 + 1 ));
RunQ(m) = Run(m1) by A49;
hence thesis by A4,A51;
end;
set FRunQ = { k where k is (Element of ( NAT )): RunQ(k) in Fin };
A52: Fin in ( FinalS_LTL v ) by A20,A46;
A53: FRunQ is  infinite
proof
set FRun2 = { k where k is (Element of ( NAT )): (i < k & k in FRun) };
set FRun1 = { k where k is (Element of ( NAT )): (k <= i & k in FRun) };
A54: FRun1 c= ( ( Seg i ) \/ { ( 0 ) } )
proof
let x;
assume x in FRun1;
then consider k being (Element of ( NAT )) such that A55: x = k and A56: k <= i and k in FRun;
now
per cases ;
suppose k = ( 0 );

then k in { ( 0 ) } by TARSKI:def 1;
hence thesis by A55,XBOOLE_0:def 3;
end;
suppose k <> ( 0 );

then ( 0 ) < ( ( 0 ) + k );
then 1 <= k by NAT_1:19;
then k in ( Seg i ) by A56,FINSEQ_1:1;
hence thesis by A55,XBOOLE_0:def 3;
end;
end;
hence thesis;
end;
A57: (FRunQ is  finite implies FRun2 is  finite)
proof
deffunc Fun(set) = ( ( CastNat $1 ) + i );
consider fun being Function such that A58: (( dom fun ) = FRunQ & (for x holds (x in FRunQ implies ( fun . x ) = Fun(x)))) from FUNCT_1:sch 3;
A59: (x in FRun2 implies ( ( CastNat x ) - i ) in FRunQ)
proof
assume x in FRun2;
then consider k being (Element of ( NAT )) such that A60: x = k and A61: i < k and A62: k in FRun;
set k2 = ( k - i );
reconsider k2 as (Element of ( NAT )) by A61,NAT_1:21;
A63: RunQ(k2) = Run(( k2 + i )) by A49
.= Run(k);
((ex k1 being (Element of ( NAT )) st (k = k1 & Run(k1) in Fin)) & ( ( CastNat x ) - i ) = k2) by A60,A62,MODELC_2:def 1;
hence thesis by A63;
end;
A64: (for y holds (y in FRun2 implies (ex x st (x in ( dom fun ) & y = ( fun . x )))))
proof
let y;
assume that
A65: y in FRun2;
consider k being (Element of ( NAT )) such that A66: y = k and A67: i < k and k in FRun by A65;
set x = ( ( CastNat y ) - i );
A68: x in ( dom fun ) by A59,A58,A65;
set k1 = ( k - i );
reconsider k1 as Nat by A67,NAT_1:21;
A69: x = k1 by A66,MODELC_2:def 1;
( fun . x ) = Fun(x) by A59,A58,A65
.= ( k1 + i ) by A69,MODELC_2:def 1
.= y by A66;
hence thesis by A68;
end;
assume FRunQ is  finite;
then ( rng fun ) is  finite by A58,FINSET_1:8;
hence thesis by A64,FINSET_1:1,FUNCT_1:9;
end;
FRun c= ( FRun1 \/ FRun2 )
proof
let x;
assume A70: x in FRun;
then (ex k being (Element of ( NAT )) st (x = k & Run(k) in Fin));
then reconsider x as (Element of ( NAT ));
now
per cases ;
suppose x <= i;

then x in FRun1 by A70;
hence x in ( FRun1 \/ FRun2 ) by XBOOLE_0:def 3;
end;
suppose i < x;

then x in FRun2 by A70;
hence x in ( FRun1 \/ FRun2 ) by XBOOLE_0:def 3;
end;
end;
hence thesis;
end;
hence thesis by A13,A52,A57,A54;
end;
set h2 = ( the_right_argument_of F );
set h1 = ( the_left_argument_of F );
( len h1 ) < ( n + 1 ) by A21,A46,MODELC_2:11;
then A71: ( len h1 ) <= n by NAT_1:13;
A72: ((for m holds (m >= 1 implies ((F in (the LTLold of RunQ(m)) & h1 in (the LTLold of RunQ(m))) & (not h2 in (the LTLold of RunQ(m)))))) implies FRunQ is  finite)
proof
assume A73: (for m holds (m >= 1 implies ((F in (the LTLold of RunQ(m)) & h1 in (the LTLold of RunQ(m))) & (not h2 in (the LTLold of RunQ(m))))));
now
assume (not FRunQ c= { ( 0 ) });
then consider x such that A74: x in FRunQ and A75: (not x in { ( 0 ) }) by TARSKI:def 3;
consider k being (Element of ( NAT )) such that A76: x = k and A77: RunQ(k) in Fin by A74;
k <> ( 0 ) by A75,A76,TARSKI:def 1;
then ( 0 ) < ( ( 0 ) + k );
then A78: 1 <= k by NAT_1:19;
set RQk = RunQ(k);
consider y being (Element of ( LTLStates v )) such that A79: RQk = y and A80: ((not F in (the LTLold of ( CastNode (y,v) ))) or h2 in (the LTLold of ( CastNode (y,v) ))) by A77;
reconsider y as  strict LTLnode over v by A79;
( CastNode (y,v) ) = RunQ(k) by A79,CKB33:def 1;
hence contradiction by A73,A78,A80;
end;
hence thesis;
end;
F in (the LTLold of RunQ(1)) by A22,A49;
then consider j such that A81: j >= 1 and A82: h2 in (the LTLold of RunQ(j)) and A83: (for m holds ((1 <= m & m < j) implies (F in (the LTLold of RunQ(m)) & h1 in (the LTLold of RunQ(m))))) by A46,A50,A53,A72,CKB126:1;
set j0 = ( j - 1 );
reconsider j0 as Nat by A81,NAT_1:21;
set j1 = ( j0 + i );
( j1 + 1 ) = ( j + i );
then A84: h2 in (the LTLold of Run(( j1 + 1 ))) by A49,A82;
A85: h1 is_subformula_of F by A46,MODELC_2:31;
A86: (for k holds (k < j0 implies ( Shift (zeta,k) ) |= h1))
proof
let k;
assume that
A87: k < j0;
set k1 = ( k + 1 );
set ki = ( k + i );
(1 <= k1 & ( k + 1 ) < ( j0 + 1 )) by A87,NAT_1:11,XREAL_1:8;
then h1 in (the LTLold of RunQ(k1)) by A83;
then h1 in (the LTLold of Run(( k1 + i ))) by A49;
then h1 in (the LTLold of Run(( ki + 1 )));
then ( Shift (w,ki) ) |= h1 by A18,A20,A85,A71,MODELC_2:35;
hence thesis by MODELC_2:80;
end;
( len h2 ) < ( n + 1 ) by A21,A46,MODELC_2:11;
then A88: ( len h2 ) <= n by NAT_1:13;
h2 is_subformula_of F by A46,MODELC_2:31;
then ( Shift (w,j1) ) |= h2 by A18,A20,A88,A84,MODELC_2:35;
then A89: ( Shift (zeta,j0) ) |= h2 by MODELC_2:80;
F = ( h1 'U' h2 ) by A46,MODELC_2:8;
hence thesis by A89,A86,MODELC_2:68;
end;
suppose A90: F is  Release;

set h2 = ( the_right_argument_of F );
A91: h2 is_subformula_of F by A90,MODELC_2:31;
set h1 = ( the_left_argument_of F );
defpred M[ Nat ]
 means
((for k holds (k < $1 implies ( Shift (zeta,k) ) |= ( 'not' h1 ))) implies (( Shift (zeta,$1) ) |= h2 & F in (the LTLold of Run(( ( i + 1 ) + $1 )))));
( len h1 ) < ( n + 1 ) by A21,A90,MODELC_2:11;
then A92: ( len h1 ) <= n by NAT_1:13;
( len h2 ) < ( n + 1 ) by A21,A90,MODELC_2:11;
then A93: ( len h2 ) <= n by NAT_1:13;
A94: h1 is_subformula_of F by A90,MODELC_2:31;
A95: (for j holds (M[ j ] implies M[ ( j + 1 ) ]))
proof
let j;
assume that
A96: M[ j ];
M[ ( j + 1 ) ]
proof
set i1 = ( i + j );
set Run1 = Run(( i1 + 1 ));
set Run0 = Run(i1);
assume A97: (for k holds (k < ( j + 1 ) implies ( Shift (zeta,k) ) |= ( 'not' h1 )));
A98: (for k holds (k < j implies ( Shift (zeta,k) ) |= ( 'not' h1 )))
proof
A99: j <= ( j + 1 ) by NAT_1:11;
let k;
assume k < j;
then k < ( j + 1 ) by A99,XXREAL_0:2;
hence thesis by A97;
end;
A100: Run1 is_next_of Run0 by A4;
then reconsider Run0 as  elementary  strict LTLnode over v by CKB38:def 1;
set i2 = ( i1 + 1 );
set Run2 = Run(( i2 + 1 ));
A101: Run2 is_next_of Run1 by A4;
then reconsider Run2 as  elementary  strict LTLnode over v by CKB38:def 1;
reconsider Run1 as  elementary  strict LTLnode over v by A100,CKB38:def 1;
j < ( j + 1 ) by NAT_1:13;
then A102: ( Shift (zeta,j) ) |= ( 'not' h1 ) by A97;
A103:now
assume h1 in (the LTLold of Run1);
then ( Shift (w,i1) ) |= h1 by A18,A20,A94,A92,MODELC_2:35;
then ( Shift (( Shift (w,i) ),j) ) |= h1 by MODELC_2:80;
hence contradiction by A102,MODELC_2:64;
end;
A104: ((((Run1 is_next_of Run0 & F is  Release) & F in (the LTLold of Run1)) & (not h1 in (the LTLold of Run1))) implies (h2 in (the LTLold of Run1) & F in (the LTLnext of Run1))) by CKB101:1;
then h2 in (the LTLold of Run2) by A4,A90,A96,A101,A98,A103,CKB102:1;
then A105: ( Shift (w,( i + ( j + 1 ) )) ) |= h2 by A18,A20,A91,A93,MODELC_2:35;
F in (the LTLold of Run2) by A4,A90,A96,A101,A98,A103,A104,CKB102:1;
hence thesis by A105,MODELC_2:80;
end;
hence thesis;
end;
A106: F = ( h1 'R' h2 ) by A90,MODELC_2:9;
A107: ((for j holds M[ j ]) implies zeta |= F)
proof
assume (for j holds M[ j ]);
then (for j holds ((for k holds (k < j implies ( Shift (zeta,k) ) |= ( 'not' h1 ))) implies ( Shift (zeta,j) ) |= h2));
hence thesis by A106,MODELC_2:69;
end;
A108: M[ ( 0 ) ]
proof
set Run0 = Run(i);
set Run1 = Run(( i + 1 ));
A109: Run1 is_next_of Run0 by A4;
then reconsider Run1 as  elementary  strict LTLnode over v by CKB38:def 1;
reconsider Run0 as  elementary  strict LTLnode over v by A109,CKB38:def 1;
assume (for k holds (k < ( 0 ) implies ( Shift (zeta,k) ) |= ( 'not' h1 )));
A110: ( Shift (zeta,( 0 )) ) = ( Shift (w,i) ) by MODELC_2:79;
((Run1 is_next_of Run0 & F in (the LTLold of Run1)) implies (F is  Release implies h2 in (the LTLold of Run1))) by CKB103:1;
hence thesis by A4,A18,A20,A22,A90,A91,A93,A110,MODELC_2:35;
end;
(for j holds M[ j ]) from NAT_1:sch 2(A108,A95);
hence thesis by A107;
end;
end;
hence thesis;
end;
P[ ( n + 1 ) ]
proof
let i;
let F;
assume that
A111: F is_subformula_of v
and
A112: ( len F ) <= ( n + 1 )
and
A113: F in (the LTLold of Run(( i + 1 )));
set L = ( len F );
reconsider L as Nat;
now
per cases  by A112,NAT_1:8;
suppose L <= n;

hence thesis by A18,A111,A113;
end;
suppose L = ( n + 1 );

hence thesis by A19,A111,A113;
end;
end;
hence thesis;
end;
hence thesis;
end;
A114: P[ ( 0 ) ] by MODELC_2:3;
A115: (for n holds P[ n ]) from NAT_1:sch 2(A114,A17);
set n = ( len v );
A116: (v in { v } & ( len v ) <= n) by TARSKI:def 1;
reconsider Run01 as  elementary  strict LTLnode over v by A11,CKB38:def 1;
reconsider Run00 as  elementary  strict LTLnode over v by A11,CKB38:def 1;
A117: (the LTLnext of Run00) c= (the LTLold of Run01) by A4,CKB99:1;
Run(( 0 )) = ( CastNode (( init v ),v) ) by A1,TARSKI:def 1
.= ( init v ) by CKB33:def 1;
then ( Shift (w,( 0 )) ) |= v by A117,A115,A116;
hence thesis by MODELC_2:79;
end;
