environ
vocabularies NUMBERS,NAT_1,XBOOLE_0,FINSEQ_1,MODELC_2,SUBSET_1,ZF_LANG,XREAL_0,ORDINAL1,FUNCT_1,RELAT_1,XXREAL_0,INT_1,ARYTM_3,ARYTM_1,CARD_1,STRUCT_0,TARSKI,XBOOLEAN,LATTICES,CAT_3,ORDINAL4,ZF_MODEL,MODELC_1,FINSET_1,SEQ_1,REAL_1,CARD_3,SERIES_1,ZFMISC_1,MSUALG_3,ORDERS_1,SUBSTUT1,FSM_1,FSM_2,VALUED_1,MODELC_3;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,FINSET_1,CARD_1,NUMBERS,XCMPLX_0,XREAL_0,REAL_1,XXREAL_0,NAT_1,RELAT_1,FUNCT_1,RELSET_1,FINSEQ_1,ORDERS_1,FUNCT_2,INT_1,SEQ_1,SERIES_1,PARTFUN1,STRUCT_0,MODELC_1,MODELC_2,RFINSEQ2,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB38,CKB39,CKB40,CKB54,CKB55,CKB56,CKB64,CKB76,CKB77,CKB82,CKB106,CKB108,CKB114,CKB115;
definitions TARSKI,MODELC_2,SERIES_1,CKB16,CKB17,CKB18,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB38,CKB39,CKB40,CKB54,CKB55,CKB56,CKB64,CKB76,CKB77,CKB82,CKB106,CKB108,CKB114,CKB115;
theorems XBOOLE_0,ZFMISC_1,XBOOLE_1,TARSKI,FUNCT_1,FUNCT_2,FUNCT_7,WELLORD2,NAT_1,INT_1,ENUMSET1,XREAL_1,FINSEQ_1,ORDERS_1,XXREAL_0,MODELC_1,MODELC_2,ORDINAL1,SUBSET_1,FINSEQ_4,SERIES_1,CARD_1,CARD_2,SERIES_2,FINSET_1,RFINSEQ2,FINSEQ_3,SUBSET,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB16,CKB17,CKB18,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB54,CKB55,CKB56,CKB57,CKB58,CKB59,CKB60,CKB61,CKB62,CKB63,CKB64,CKB65,CKB66,CKB67,CKB68,CKB69,CKB70,CKB71,CKB72,CKB73,CKB74,CKB75,CKB76,CKB77,CKB78,CKB79,CKB80,CKB81,CKB82,CKB83,CKB84,CKB85,CKB86,CKB87,CKB88,CKB89,CKB90,CKB91,CKB92,CKB93,CKB94,CKB95,CKB96,CKB97,CKB98,CKB99,CKB100,CKB101,CKB102,CKB103,CKB104,CKB105,CKB106,CKB108,CKB110,CKB111,CKB112,CKB113,CKB114,CKB115,CKB116,CKB117,CKB118,CKB119,CKB120,CKB121,CKB122;
schemes NAT_1,FUNCT_2,MODELC_2,TARSKI,FUNCT_1,FINSEQ_1,RECDEF_1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,XXREAL_0,XREAL_0,NAT_1,INT_1,ORDERS_1,FINSET_1,MODELC_2,FINSEQ_1,NUMBERS,VALUED_0,MEMBERED,STRUCT_0,MODELC_1,CARD_1,RELSET_1,FUNCT_2,CKB19,CKB31,CKB53,CKB107,CKB109;
constructors KNASTER,MODELC_2,SERIES_1,REAL_1,NEWTON,RFINSEQ2,SEQ_1,RELSET_1,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB38,CKB39,CKB40,CKB54,CKB55,CKB56,CKB64,CKB76,CKB77,CKB82,CKB106,CKB108,CKB114,CKB115;
requirements REAL,NUMERALS,ARITHM,SUBSET,BOOLE;
begin
reserve k for Nat;
reserve n for Nat;
reserve i for Nat;
reserve F for LTL-formula;
reserve G for LTL-formula;
reserve v for LTL-formula;
reserve s0 for  elementary  strict LTLnode over v;
reserve s1 for  elementary  strict LTLnode over v;
reserve s2 for  elementary  strict LTLnode over v;
reserve q for (sequence of ( LTLStates v ));
theorem
Lm32: ((( F 'U' G ) in (the LTLold of ( CastNode (( q . 1 ),v) )) & (for i holds ( CastNode (( q . ( i + 1 ) ),v) ) is_next_of ( CastNode (( q . i ),v) ))) implies ((for i holds ((1 <= i & i < n) implies (not G in (the LTLold of ( CastNode (( q . i ),v) ))))) implies (for i holds ((1 <= i & i < n) implies (F in (the LTLold of ( CastNode (( q . i ),v) )) & ( F 'U' G ) in (the LTLold of ( CastNode (( q . i ),v) )))))))
proof
deffunc Node(Nat) = ( CastNode (( q . $1 ),v) );
assume that
A1: ( F 'U' G ) in (the LTLold of Node(1))
and
A2: (for i holds Node(( i + 1 )) is_next_of Node(i));
defpred P[ Nat ]
 means
((for i holds ((1 <= i & i < $1) implies (not G in (the LTLold of Node(i))))) implies (for i holds ((1 <= i & i < $1) implies (F in (the LTLold of Node(i)) & ( F 'U' G ) in (the LTLold of Node(i))))));
A3: (for k holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k;
assume that
A4: P[ k ];
set k1 = ( k + 1 );
((for i holds ((1 <= i & i < k1) implies (not G in (the LTLold of Node(i))))) implies (for i holds ((1 <= i & i < k1) implies (F in (the LTLold of Node(i)) & ( F 'U' G ) in (the LTLold of Node(i))))))
proof
assume A5: (for i holds ((1 <= i & i < k1) implies (not G in (the LTLold of Node(i)))));
A6: k <= k1 by NAT_1:11;
A7: (for i holds ((1 <= i & i < k) implies (not G in (the LTLold of Node(i)))))
proof
let i;
assume that
A8: 1 <= i
and
A9: i < k;
i < k1 by A6,A9,XXREAL_0:2;
hence thesis by A5,A8;
end;
(for i holds ((1 <= i & i < k1) implies (F in (the LTLold of Node(i)) & ( F 'U' G ) in (the LTLold of Node(i)))))
proof
let i;
assume that
A10: 1 <= i
and
A11: i < k1;
A12: i <= k by A11,NAT_1:13;
now
per cases  by A12,XXREAL_0:1;
suppose i < k;

hence thesis by A4,A7,A10;
end;
suppose A13: i = k;

now
per cases  by A10,A13,XXREAL_0:1;
suppose A14: k = 1;

A15: (Node(( ( 0 ) + 1 )) is_next_of Node(( 0 )) & Node(( 1 + 1 )) is_next_of Node(1)) by A2;
A16: ((ex s0 st s0 = Node(( 0 ))) & (ex s2 st s2 = Node(2))) by CKB122:1;
consider s1 such that A17: s1 = Node(1) by CKB122:1;
(not G in (the LTLold of s1)) by A5,A14,A17;
hence thesis by A1,A13,A14,A17,A16,A15,CKB104:1;
end;
suppose A18: 1 < k;

set m = ( k - 1 );
reconsider m as Nat by A18,NAT_1:20;
set m1 = ( m - 1 );
1 < ( m + 1 ) by A18;
then A19: 1 <= m by NAT_1:13;
then reconsider m1 as Nat by NAT_1:21;
consider sm being  elementary  strict LTLnode over v such that A20: sm = Node(m) by CKB122:1;
A21: m < ( m + 1 ) by NAT_1:19;
then m < k1 by A6,XXREAL_0:2;
then A22: (not G in (the LTLold of sm)) by A5,A19,A20;
A23: ((ex sk1 being  elementary  strict LTLnode over v st sk1 = Node(k1)) & Node(( m + 1 )) is_next_of Node(m)) by A2,CKB122:1;
A24: ((ex sm1 being  elementary  strict LTLnode over v st sm1 = Node(m1)) & Node(( m1 + 1 )) is_next_of Node(m1)) by A2,CKB122:1;
A25: Node(( m + 1 )) is_next_of Node(m) by A2;
A26: Node(( k + 1 )) is_next_of Node(k) by A2;
consider sk being  elementary  strict LTLnode over v such that A27: sk = Node(k) by CKB122:1;
A28: (not G in (the LTLold of sk)) by A5,A10,A11,A13,A27;
( F 'U' G ) in (the LTLold of sm) by A4,A7,A19,A20,A21;
then ( F 'U' G ) in (the LTLold of sk) by A20,A27,A22,A24,A25,CKB104:1;
hence thesis by A13,A20,A27,A28,A23,A26,CKB104:1;
end;
end;
hence thesis;
end;
end;
hence thesis;
end;
hence thesis;
end;
hence thesis;
end;
A29: P[ ( 0 ) ];
(for n holds P[ n ]) from NAT_1:sch 2(A29,A3);
hence thesis;
end;
