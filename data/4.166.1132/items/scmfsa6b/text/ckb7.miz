environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMFSA_2,FSM_1,CARD_1,TARSKI,SCMFSA6A,FUNCT_4,RELAT_1,XBOOLE_0,FUNCT_1,INT_1,MSUALG_1,CIRCUIT2,AMI_3,ARYTM_3,XXREAL_0,NAT_1,SF_MASTR,GRAPHSP,AMISTD_2,TURING_1,STRUCT_0,VALUED_1,FUNCOP_1,SCMFSA6B,PARTFUN1,SCMNORM,RELOC,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,CARD_1,NUMBERS,XCMPLX_0,XXREAL_0,NAT_1,FUNCT_7,INT_1,RELAT_1,FUNCT_1,PARTFUN1,PBOOLE,FINSEQ_1,FUNCOP_1,FUNCT_4,VALUED_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,SCMFSA_2,AMISTD_1,AMISTD_2,SCMFSA6A,SF_MASTR,CKB1,CKB2,CKB3;
definitions AMISTD_2,FUNCOP_1,SCMFSA6A,COMPOS_1,EXTPRO_1,MEMSTR_0,AMISTD_1,CKB2,CKB3;
theorems RELAT_1,FUNCT_7,FUNCT_4,FUNCT_1,SCMFSA_3,INT_1,FUNCOP_1,TARSKI,NAT_1,SCMFSA_2,MEMSTR_0,GRFUNC_1,SCMFSA6A,SF_MASTR,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,XXREAL_0,VALUED_1,PBOOLE,PARTFUN1,AFINSQ_1,FINSEQ_4,COMPOS_1,EXTPRO_1,AMISTD_2,AMISTD_5,AMISTD_1,STRUCT_0,CKB2,CKB3,CKB5,CKB6;
schemes NAT_1;
registrations SETFAM_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SCMFSA6A,SF_MASTR,XBOOLE_0,FINSET_1,AMISTD_2,SCMFSA10,COMPOS_1,EXTPRO_1,SCMFSA_4,PBOOLE,PRE_POLY,FUNCT_7,FUNCT_4,STRUCT_0,MEMSTR_0,CKB4;
constructors XXREAL_0,SCMFSA6A,SF_MASTR,AMISTD_1,AMISTD_2,MEMSTR_0,RELSET_1,PRE_POLY,AMISTD_5,DOMAIN_1,PBOOLE,AMI_3,FUNCT_7,CKB1,CKB2,CKB3;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve n for (Element of ( NAT ));
reserve s for (State of ( SCM+FSA ));
reserve P for (Instruction-Sequence of ( SCM+FSA ));
theorem
Lm45: (for P being (Instruction-Sequence of ( SCM+FSA )) holds (not ( P +* (( IC s ),( goto ( IC s ) )) ) halts_on s))
proof
let P being (Instruction-Sequence of ( SCM+FSA ));
set Q = ( P +* (( IC s ),( goto ( IC s ) )) );
defpred X[ Nat ]
 means
( IC ( Comput (Q,s,$1) ) ) = ( IC s );
A1: ( dom P ) = ( NAT ) by PARTFUN1:def 2;
A2: ( dom P ) = ( dom Q ) by FUNCT_7:30;
A3:now
let n;
assume X[ n ];
then A4: ( CurInstr (Q,( Comput (Q,s,n) )) ) = ( Q . ( IC s ) ) by A2,A1,PARTFUN1:def 6
.= ( goto ( IC s ) ) by A1,FUNCT_7:31;
( IC ( Comput (Q,s,( n + 1 )) ) ) = ( IC ( Following (Q,( Comput (Q,s,n) )) ) ) by EXTPRO_1:3
.= ( IC s ) by A4,SCMFSA_2:69;
hence X[ ( n + 1 ) ];
end;
let n being Nat;
A5: X[ ( 0 ) ] by EXTPRO_1:2;
assume A6: ( IC ( Comput (Q,s,n) ) ) in ( dom Q );
reconsider n as (Element of ( NAT )) by ORDINAL1:def 12;
A7: (for n holds X[ n ]) from NAT_1:sch 1(A5,A3);
( CurInstr (Q,( Comput (Q,s,n) )) ) = ( Q . ( IC ( Comput (Q,s,n) ) ) ) by A6,PARTFUN1:def 6
.= ( Q . ( IC s ) ) by A7
.= ( goto ( IC s ) ) by A1,FUNCT_7:31;
hence thesis;
end;
