environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMFSA_2,FSM_1,CARD_1,TARSKI,SCMFSA6A,FUNCT_4,RELAT_1,XBOOLE_0,FUNCT_1,INT_1,MSUALG_1,CIRCUIT2,AMI_3,ARYTM_3,XXREAL_0,NAT_1,SF_MASTR,GRAPHSP,AMISTD_2,TURING_1,STRUCT_0,VALUED_1,FUNCOP_1,SCMFSA6B,PARTFUN1,SCMNORM,RELOC,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,CARD_1,NUMBERS,XCMPLX_0,XXREAL_0,NAT_1,FUNCT_7,INT_1,RELAT_1,FUNCT_1,PARTFUN1,PBOOLE,FINSEQ_1,FUNCOP_1,FUNCT_4,VALUED_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,SCMFSA_2,AMISTD_1,AMISTD_2,SCMFSA6A,SF_MASTR,CKB1,CKB2,CKB3;
definitions AMISTD_2,FUNCOP_1,SCMFSA6A,COMPOS_1,EXTPRO_1,MEMSTR_0,AMISTD_1,CKB2,CKB3;
theorems RELAT_1,FUNCT_7,FUNCT_4,FUNCT_1,SCMFSA_3,INT_1,FUNCOP_1,TARSKI,NAT_1,SCMFSA_2,MEMSTR_0,GRFUNC_1,SCMFSA6A,SF_MASTR,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,XXREAL_0,VALUED_1,PBOOLE,PARTFUN1,AFINSQ_1,FINSEQ_4,COMPOS_1,EXTPRO_1,AMISTD_2,AMISTD_5,AMISTD_1,STRUCT_0,CKB2,CKB3,CKB5,CKB6,CKB7,CKB10,CKB11,CKB12;
schemes NAT_1;
registrations SETFAM_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SCMFSA6A,SF_MASTR,XBOOLE_0,FINSET_1,AMISTD_2,SCMFSA10,COMPOS_1,EXTPRO_1,SCMFSA_4,PBOOLE,PRE_POLY,FUNCT_7,FUNCT_4,STRUCT_0,MEMSTR_0,CKB4,CKB8,CKB9,CKB13;
constructors XXREAL_0,SCMFSA6A,SF_MASTR,AMISTD_1,AMISTD_2,MEMSTR_0,RELSET_1,PRE_POLY,AMISTD_5,DOMAIN_1,PBOOLE,AMI_3,FUNCT_7,CKB1,CKB2,CKB3;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve n for (Element of ( NAT ));
reserve s1 for (State of ( SCM+FSA ));
reserve s2 for (State of ( SCM+FSA ));
reserve P for (Instruction-Sequence of ( SCM+FSA ));
theorem
Th27: (for s1 being ( 0 ) -started (State of ( SCM+FSA )) holds (for P,Q being (Instruction-Sequence of ( SCM+FSA )) holds (for J being  parahalting (Program of ( SCM+FSA )) holds (J c= P implies (for n being (Element of ( NAT )) holds (((( Reloc (J,n) ) c= Q & ( IC s2 ) = n) & ( DataPart s1 ) = ( DataPart s2 )) implies (for i being (Element of ( NAT )) holds ((( ( IC ( Comput (P,s1,i) ) ) + n ) = ( IC ( Comput (Q,s2,i) ) ) & ( IncAddr (( CurInstr (P,( Comput (P,s1,i) )) ),n) ) = ( CurInstr (Q,( Comput (Q,s2,i) )) )) & ( DataPart ( Comput (P,s1,i) ) ) = ( DataPart ( Comput (Q,s2,i) ) )))))))))
proof
let s1 being ( 0 ) -started (State of ( SCM+FSA ));
let P being (Instruction-Sequence of ( SCM+FSA ));
let Q being (Instruction-Sequence of ( SCM+FSA ));
let J being  parahalting (Program of ( SCM+FSA ));
A1: ( Start-At (( 0 ),( SCM+FSA )) ) c= s1 by MEMSTR_0:29;
assume that
A2: J c= P;
set JAt = ( Start-At (( 0 ),( SCM+FSA )) );
A3: ( 0 ) in ( dom J ) by AFINSQ_1:65;
A4: ( IC ( SCM+FSA ) ) in ( dom JAt ) by MEMSTR_0:15;
then A5: ( P . ( IC s1 ) ) = ( P . ( IC JAt ) ) by A1,GRFUNC_1:2
.= ( P . ( 0 ) ) by FUNCOP_1:72
.= ( J . ( 0 ) ) by A3,A2,GRFUNC_1:2;
A6: ( IC ( Comput (P,s1,( 0 )) ) ) = ( IC s1 ) by EXTPRO_1:2
.= ( IC JAt ) by A1,A4,GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
A7: ( 0 ) in ( dom J ) by AFINSQ_1:65;
let n being (Element of ( NAT ));
assume that
A8: ( Reloc (J,n) ) c= Q
and
A9: ( IC s2 ) = n
and
A10: ( DataPart s1 ) = ( DataPart s2 );
A11: ( DataPart ( Comput (P,s1,( 0 )) ) ) = ( DataPart s2 ) by A10,EXTPRO_1:2
.= ( DataPart ( Comput (Q,s2,( 0 )) ) ) by EXTPRO_1:2;
defpred P[ Nat ]
 means
((( ( IC ( Comput (P,s1,$1) ) ) + n ) = ( IC ( Comput (Q,s2,$1) ) ) & ( IncAddr (( CurInstr (P,( Comput (P,s1,$1) )) ),n) ) = ( CurInstr (Q,( Comput (Q,s2,$1) )) )) & ( DataPart ( Comput (P,s1,$1) ) ) = ( DataPart ( Comput (Q,s2,$1) ) ));
A12: (for k being (Element of ( NAT )) holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
A13: ( Comput (P,s1,( k + 1 )) ) = ( Following (P,( Comput (P,s1,k) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (P,( Comput (P,s1,k) )) ),( Comput (P,s1,k) )) );
reconsider l = ( IC ( Comput (P,s1,( k + 1 )) ) ) as (Element of ( NAT ));
reconsider j = ( CurInstr (P,( Comput (P,s1,( k + 1 )) )) ) as (Instruction of ( SCM+FSA ));
A14: ( Comput (Q,s2,( k + 1 )) ) = ( Following (Q,( Comput (Q,s2,k) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (Q,( Comput (Q,s2,k) )) ),( Comput (Q,s2,k) )) );
A15: ( IC ( Comput (P,s1,( k + 1 )) ) ) in ( dom J ) by A2,AMISTD_1:def 10;
assume A16: P[ k ];
hence ( ( IC ( Comput (P,s1,( k + 1 )) ) ) + n ) = ( IC ( Comput (Q,s2,( k + 1 )) ) ) by A13,A14,SCMFSA6A:8;
then A17: ( IC ( Comput (Q,s2,( k + 1 )) ) ) in ( dom ( Reloc (J,n) ) ) by A15,COMPOS_1:46;
A18: l in ( dom J ) by A2,AMISTD_1:def 10;
A19: ( dom P ) = ( NAT ) by PARTFUN1:def 2;
A20: ( dom Q ) = ( NAT ) by PARTFUN1:def 2;
j = ( P . ( IC ( Comput (P,s1,( k + 1 )) ) ) ) by A19,PARTFUN1:def 6
.= ( J . l ) by A15,A2,GRFUNC_1:2;
hence ( IncAddr (( CurInstr (P,( Comput (P,s1,( k + 1 )) )) ),n) ) = ( ( Reloc (J,n) ) . ( l + n ) ) by A18,COMPOS_1:35
.= ( ( Reloc (J,n) ) . ( IC ( Comput (Q,s2,( k + 1 )) ) ) ) by A16,A13,A14,SCMFSA6A:8
.= ( Q . ( IC ( Comput (Q,s2,( k + 1 )) ) ) ) by A17,A8,GRFUNC_1:2
.= ( CurInstr (Q,( Comput (Q,s2,( k + 1 )) )) ) by A20,PARTFUN1:def 6;
thus thesis by A16,A13,A14,SCMFSA6A:8;
end;
let i being (Element of ( NAT ));
( 0 ) in ( dom J ) by AFINSQ_1:65;
then A21: ( ( 0 ) + n ) in ( dom ( Reloc (J,n) ) ) by COMPOS_1:46;
A22: ( Comput (P,s1,( 0 )) ) = s1 by EXTPRO_1:2;
A23: ( Comput (Q,s2,( 0 )) ) = s2 by EXTPRO_1:2;
A24: ( dom Q ) = ( NAT ) by PARTFUN1:def 2;
( dom P ) = ( NAT ) by PARTFUN1:def 2;
then ( IncAddr (( CurInstr (P,( Comput (P,s1,( 0 )) )) ),n) ) = ( ( Reloc (J,n) ) . ( ( 0 ) + n ) ) by A5,A7,A22,COMPOS_1:35,PARTFUN1:def 6
.= ( Q . ( IC ( Comput (Q,s2,( 0 )) ) ) ) by A23,A9,A21,A8,GRFUNC_1:2
.= ( CurInstr (Q,( Comput (Q,s2,( 0 )) )) ) by A24,PARTFUN1:def 6;
then A25: P[ ( 0 ) ] by A9,A6,A11,EXTPRO_1:2;
(for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A25,A12);
hence thesis;
end;
