environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMFSA_2,FSM_1,CARD_1,TARSKI,SCMFSA6A,FUNCT_4,RELAT_1,XBOOLE_0,FUNCT_1,INT_1,MSUALG_1,CIRCUIT2,AMI_3,ARYTM_3,XXREAL_0,NAT_1,SF_MASTR,GRAPHSP,AMISTD_2,TURING_1,STRUCT_0,VALUED_1,FUNCOP_1,SCMFSA6B,PARTFUN1,SCMNORM,RELOC,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,CARD_1,NUMBERS,XCMPLX_0,XXREAL_0,NAT_1,FUNCT_7,INT_1,RELAT_1,FUNCT_1,PARTFUN1,PBOOLE,FINSEQ_1,FUNCOP_1,FUNCT_4,VALUED_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,SCMFSA_2,AMISTD_1,AMISTD_2,SCMFSA6A,SF_MASTR,CKB1,CKB2,CKB3;
definitions AMISTD_2,FUNCOP_1,SCMFSA6A,COMPOS_1,EXTPRO_1,MEMSTR_0,AMISTD_1,CKB2,CKB3;
theorems RELAT_1,FUNCT_7,FUNCT_4,FUNCT_1,SCMFSA_3,INT_1,FUNCOP_1,TARSKI,NAT_1,SCMFSA_2,MEMSTR_0,GRFUNC_1,SCMFSA6A,SF_MASTR,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,XXREAL_0,VALUED_1,PBOOLE,PARTFUN1,AFINSQ_1,FINSEQ_4,COMPOS_1,EXTPRO_1,AMISTD_2,AMISTD_5,AMISTD_1,STRUCT_0,CKB2,CKB3,CKB5,CKB6,CKB7;
schemes NAT_1;
registrations SETFAM_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SCMFSA6A,SF_MASTR,XBOOLE_0,FINSET_1,AMISTD_2,SCMFSA10,COMPOS_1,EXTPRO_1,SCMFSA_4,PBOOLE,PRE_POLY,FUNCT_7,FUNCT_4,STRUCT_0,MEMSTR_0,CKB4;
constructors XXREAL_0,SCMFSA6A,SF_MASTR,AMISTD_1,AMISTD_2,MEMSTR_0,RELSET_1,PRE_POLY,AMISTD_5,DOMAIN_1,PBOOLE,AMI_3,FUNCT_7,CKB1,CKB2,CKB3;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve m for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
reserve I for (Program of ( SCM+FSA ));
reserve s for (State of ( SCM+FSA ));
reserve P for (Instruction-Sequence of ( SCM+FSA ));
registration
cluster  parahalting ->  paraclosed for (Program of ( SCM+FSA ));
coherence
proof
let I being (Program of ( SCM+FSA ));
assume Z: I is  parahalting;
let s being ( 0 ) -started (State of ( SCM+FSA ));
let P being (Instruction-Sequence of ( SCM+FSA ));
assume that
A2: I c= P;
let n being (Element of ( NAT ));
defpred X[ Nat ]
 means
(not ( IC ( Comput (P,s,$1) ) ) in ( dom I ));
assume (not ( IC ( Comput (P,s,n) ) ) in ( dom I ));
then A4: (ex n being Nat st X[ n ]);
consider n being Nat such that A5: X[ n ] and A6: (for m being Nat holds (X[ m ] implies n <= m)) from NAT_1:sch 5(A4);
reconsider n as (Element of ( NAT )) by ORDINAL1:def 12;
A7: (for m holds (m < n implies ( IC ( Comput (P,s,m) ) ) in ( dom I ))) by A6;
set s2 = ( Comput (P,s,n) );
set s0 = s;
set s1 = s2;
set P0 = ( P +* (( IC s2 ),( goto ( IC s2 ) )) );
A13: I c= P0 by A5,A2,FUNCT_7:89;
then B14: ( Comput (P0,s0,n) ) = s2 by A7,A2,AMISTD_2:10;
B15: (not P0 halts_on ( Comput (P0,s0,n) )) by B14,CKB7:1;
P0 halts_on s by A13,Z,AMISTD_1:def 11;
hence contradiction by B15,EXTPRO_1:22;
end;
end;
