environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMFSA_2,FSM_1,CARD_1,TARSKI,SCMFSA6A,FUNCT_4,RELAT_1,XBOOLE_0,FUNCT_1,INT_1,MSUALG_1,CIRCUIT2,AMI_3,ARYTM_3,XXREAL_0,NAT_1,SF_MASTR,GRAPHSP,AMISTD_2,TURING_1,STRUCT_0,VALUED_1,FUNCOP_1,SCMFSA6B,PARTFUN1,SCMNORM,RELOC,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,CARD_1,NUMBERS,XCMPLX_0,XXREAL_0,NAT_1,FUNCT_7,INT_1,RELAT_1,FUNCT_1,PARTFUN1,PBOOLE,FINSEQ_1,FUNCOP_1,FUNCT_4,VALUED_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,SCMFSA_2,AMISTD_1,AMISTD_2,SCMFSA6A,SF_MASTR,CKB1,CKB2,CKB3;
definitions AMISTD_2,FUNCOP_1,SCMFSA6A,COMPOS_1,EXTPRO_1,MEMSTR_0,AMISTD_1,CKB2,CKB3;
theorems RELAT_1,FUNCT_7,FUNCT_4,FUNCT_1,SCMFSA_3,INT_1,FUNCOP_1,TARSKI,NAT_1,SCMFSA_2,MEMSTR_0,GRFUNC_1,SCMFSA6A,SF_MASTR,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,XXREAL_0,VALUED_1,PBOOLE,PARTFUN1,AFINSQ_1,FINSEQ_4,COMPOS_1,EXTPRO_1,AMISTD_2,AMISTD_5,AMISTD_1,STRUCT_0,CKB2,CKB3,CKB5,CKB6,CKB7;
schemes NAT_1;
registrations SETFAM_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SCMFSA6A,SF_MASTR,XBOOLE_0,FINSET_1,AMISTD_2,SCMFSA10,COMPOS_1,EXTPRO_1,SCMFSA_4,PBOOLE,PRE_POLY,FUNCT_7,FUNCT_4,STRUCT_0,MEMSTR_0,CKB4,CKB8;
constructors XXREAL_0,SCMFSA6A,SF_MASTR,AMISTD_1,AMISTD_2,MEMSTR_0,RELSET_1,PRE_POLY,AMISTD_5,DOMAIN_1,PBOOLE,AMI_3,FUNCT_7,CKB1,CKB2,CKB3;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve m for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
reserve I for (Program of ( SCM+FSA ));
reserve s for (State of ( SCM+FSA ));
reserve P for (Instruction-Sequence of ( SCM+FSA ));
registration
cluster  keeping_0 ->  paraclosed for (Program of ( SCM+FSA ));
coherence
proof
let I being (Program of ( SCM+FSA ));
assume A16: I is  keeping_0;
set FI = ( FirstNotUsed I );
let s being ( 0 ) -started (State of ( SCM+FSA ));
let P being (Instruction-Sequence of ( SCM+FSA ));
assume that
A17: I c= P;
let n being (Element of ( NAT ));
A18: ( Start-At (( 0 ),( SCM+FSA )) ) c= s by MEMSTR_0:29;
defpred X[ Nat ]
 means
(not ( IC ( Comput (P,s,$1) ) ) in ( dom I ));
assume (not ( IC ( Comput (P,s,n) ) ) in ( dom I ));
then A19: (ex n being Nat st X[ n ]);
consider n being Nat such that A20: X[ n ] and A21: (for m being Nat holds (X[ m ] implies n <= m)) from NAT_1:sch 5(A19);
reconsider n as (Element of ( NAT )) by ORDINAL1:def 12;
set s2 = ( Comput (P,s,n) );
set s00 = s;
reconsider s0 = ( s +* (FI,( ( s . ( intloc ( 0 ) ) ) + 1 )) ) as (State of ( SCM+FSA ));
set Q = ( P +* (( IC s2 ),( ( intloc ( 0 ) ) := FI )) );
A23: ( dom Q ) = ( NAT ) by PARTFUN1:def 2;
(not I is  keeping_0)
proof
(not FI in ( UsedInt*Loc I ))
proof
assume (not thesis);
then FI is FinSeq-Location by SCMFSA_2:5;
hence contradiction by SCMFSA_2:58;
end;
then A25: ( s0 | ( UsedInt*Loc I ) ) = ( s | ( UsedInt*Loc I ) ) by FUNCT_7:92;
A27: ( s . ( intloc ( 0 ) ) ) < ( ( s . ( intloc ( 0 ) ) ) + 1 ) by XREAL_1:29;
A28: ( dom P ) = ( NAT ) by PARTFUN1:def 2;
A29: ( Q . ( IC s2 ) ) = ( ( intloc ( 0 ) ) := FI ) by A28,FUNCT_7:31;
A30: ( s0 . ( intloc ( 0 ) ) ) = ( s . ( intloc ( 0 ) ) ) by FUNCT_7:32;
FI in ( dom s00 ) by SCMFSA_2:42;
then A31: ( s0 . FI ) = ( ( s . ( intloc ( 0 ) ) ) + 1 ) by FUNCT_7:31;
set s02 = ( Comput (Q,s0,n) );
FI <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
then (not FI in { ( IC ( SCM+FSA ) ) }) by TARSKI:def 1;
then (not FI in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) )) by FUNCOP_1:13;
then B35: ( Start-At (( 0 ),( SCM+FSA )) ) c= s0 by A18,FUNCT_7:89;
then reconsider s0 as ( 0 ) -started (State of ( SCM+FSA )) by MEMSTR_0:29;
take s0;
A36: I c= Q by A17,A20,FUNCT_7:138;
take Q;
thus I c= Q by A17,A20,FUNCT_7:138;
take k = ( n + 1 );
A38: ( s0 | ( UsedIntLoc I ) ) = ( s | ( UsedIntLoc I ) ) by FUNCT_7:92,SF_MASTR:50;
A39: (for m holds (m < n implies ( IC ( Comput (P,s,m) ) ) in ( dom I ))) by A21;
A40: ((not FI in ( UsedIntLoc I )) & (for m holds (m < n implies ( IC ( Comput (Q,s0,m) ) ) in ( dom I )))) by A39,A38,A25,A17,A36,A18,B35,SF_MASTR:50,SF_MASTR:65;
A41: ( s02 . FI ) = ( ( s . ( intloc ( 0 ) ) ) + 1 ) by A31,A40,A36,SF_MASTR:61;
( Comput (Q,s0,k) ) = ( Following (Q,s02) ) by EXTPRO_1:3
.= ( Exec (( Q . ( IC s02 ) ),s02) ) by A23,PARTFUN1:def 6
.= ( Exec (( ( intloc ( 0 ) ) := FI ),s02) ) by A38,A25,A17,A36,A39,A29,A18,B35,SF_MASTR:65;
hence thesis by A41,A30,A27,SCMFSA_2:63;
end;
hence contradiction by A16;
end;
end;
