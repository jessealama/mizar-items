environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMFSA_2,FSM_1,CARD_1,TARSKI,SCMFSA6A,FUNCT_4,RELAT_1,XBOOLE_0,FUNCT_1,INT_1,MSUALG_1,CIRCUIT2,AMI_3,ARYTM_3,XXREAL_0,NAT_1,SF_MASTR,GRAPHSP,AMISTD_2,TURING_1,STRUCT_0,VALUED_1,FUNCOP_1,SCMFSA6B,PARTFUN1,SCMNORM,RELOC,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,CARD_1,NUMBERS,XCMPLX_0,XXREAL_0,NAT_1,FUNCT_7,INT_1,RELAT_1,FUNCT_1,PARTFUN1,PBOOLE,FINSEQ_1,FUNCOP_1,FUNCT_4,VALUED_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,SCMFSA_2,AMISTD_1,AMISTD_2,SCMFSA6A,SF_MASTR,CKB1,CKB2,CKB3;
definitions AMISTD_2,FUNCOP_1,SCMFSA6A,COMPOS_1,EXTPRO_1,MEMSTR_0,AMISTD_1,CKB2,CKB3;
theorems RELAT_1,FUNCT_7,FUNCT_4,FUNCT_1,SCMFSA_3,INT_1,FUNCOP_1,TARSKI,NAT_1,SCMFSA_2,MEMSTR_0,GRFUNC_1,SCMFSA6A,SF_MASTR,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,XXREAL_0,VALUED_1,PBOOLE,PARTFUN1,AFINSQ_1,FINSEQ_4,COMPOS_1,EXTPRO_1,AMISTD_2,AMISTD_5,AMISTD_1,STRUCT_0,CKB2,CKB3,CKB5,CKB6,CKB7,CKB10,CKB11,CKB12,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB21,CKB22,CKB23,CKB24,CKB25;
schemes NAT_1;
registrations SETFAM_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SCMFSA6A,SF_MASTR,XBOOLE_0,FINSET_1,AMISTD_2,SCMFSA10,COMPOS_1,EXTPRO_1,SCMFSA_4,PBOOLE,PRE_POLY,FUNCT_7,FUNCT_4,STRUCT_0,MEMSTR_0,CKB4,CKB8,CKB9,CKB13,CKB20;
constructors XXREAL_0,SCMFSA6A,SF_MASTR,AMISTD_1,AMISTD_2,MEMSTR_0,RELSET_1,PRE_POLY,AMISTD_5,DOMAIN_1,PBOOLE,AMI_3,FUNCT_7,CKB1,CKB2,CKB3;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve x for set;
reserve I for (Program of ( SCM+FSA ));
reserve s for (State of ( SCM+FSA ));
reserve P for (Instruction-Sequence of ( SCM+FSA ));
set SA0 = ( Start-At (( 0 ),( SCM+FSA )) );
theorem
Lm5: (for I being  keeping_0  parahalting (Program of ( SCM+FSA )) holds (for J being  parahalting (Program of ( SCM+FSA )) holds (for s being (State of ( SCM+FSA )) holds ((( I ';' J ) c= P & ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= s) implies ((((((( IC ( Comput (P,s,( ( LifeSpan (( P +* I ),s) ) + 1 )) ) ) = ( card I ) & ( DataPart ( Comput (P,s,( ( LifeSpan (( P +* I ),s) ) + 1 )) ) ) = ( DataPart ( ( Comput (( P +* I ),s,( LifeSpan (( P +* I ),s) )) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) )) & ( Reloc (J,( card I )) ) c= P) & ( ( Comput (P,s,( ( LifeSpan (( P +* I ),s) ) + 1 )) ) . ( intloc ( 0 ) ) ) = 1) & P halts_on s) & ( LifeSpan (P,s) ) = ( ( ( LifeSpan (( P +* I ),s) ) + 1 ) + ( LifeSpan (( ( P +* I ) +* J ),( ( Result (( P +* I ),s) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) )) & (J is  keeping_0 implies ( ( Result (P,s) ) . ( intloc ( 0 ) ) ) = 1))))))
proof
set D = ( Data-Locations ( SCM+FSA ) );
let I being  keeping_0  parahalting (Program of ( SCM+FSA ));
let J being  parahalting (Program of ( SCM+FSA ));
let s being (State of ( SCM+FSA ));
set s3 = ( ( Comput (( P +* I ),s,( LifeSpan (( P +* I ),s) )) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) );
set m1 = ( LifeSpan (( P +* I ),s) );
set m3 = ( LifeSpan (( ( P +* I ) +* J ),s3) );
A1: ( dom ( Directed I ) ) = ( dom I ) by FUNCT_4:99;
assume that
A3: ( I ';' J ) c= P
and
A4: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= s;
B5: ( Start-At (( 0 ),( SCM+FSA )) ) c= ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCT_4:25;
then A5: SA0 c= s by A4,XBOOLE_1:1;
A7: ( Directed I ) c= ( I ';' J ) by SCMFSA6A:16;
A9: ( P +* ( Directed I ) ) = P by A7,A3,FUNCT_4:98,XBOOLE_1:1;
A11: P = ( P +* ( I ';' J ) ) by A3,FUNCT_4:98;
C13: s is ( 0 ) -started ( 0 ) -started (State of ( SCM+FSA )) by A5,MEMSTR_0:29;
then A14: ( P +* I ) halts_on s by CKB5:1,FUNCT_4:25;
hence A15: ( IC ( Comput (P,s,( ( LifeSpan (( P +* I ),s) ) + 1 )) ) ) = ( card I ) by CKB22:1,A7,A3,C13,XBOOLE_1:1;
A17:now
let x being set;
DD: ( dom ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) c= ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by RELAT_1:60;
assume Z: x in ( dom ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) );
A20: x in D by Z,RELAT_1:57;
II: I c= ( P +* I ) by FUNCT_4:25;
per cases  by Z,DD,SCMFSA6A:42,TARSKI:def 2;
suppose A22: x = ( intloc ( 0 ) );

then B22: x in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by SCMFSA6A:42,TARSKI:def 2;
thus ( ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) . x ) = 1 by A22,A20,FUNCT_1:49,SCMFSA6A:43
.= ( s . x ) by A4,B22,A22,GRFUNC_1:2,SCMFSA6A:43
.= ( ( Comput (( P +* I ),s,m1) ) . x ) by A22,CKB3:def 1,II,C13
.= ( ( DataPart ( Comput (( P +* I ),s,m1) ) ) . x ) by A20,FUNCT_1:49;
end;
suppose x = ( IC ( SCM+FSA ) );

then (not x in ( Data-Locations ( SCM+FSA ) )) by STRUCT_0:3;
hence ( ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) . x ) = ( ( DataPart ( Comput (( P +* I ),s,m1) ) ) . x ) by Z,RELAT_1:57;
end;
end;
set s4 = ( Comput (P,s,( m1 + 1 )) );
reconsider m = ( ( m1 + 1 ) + m3 ) as (Element of ( NAT ));
A23: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= s3 by FUNCT_4:25;
J c= ( ( P +* I ) +* J ) by FUNCT_4:25;
then A25: ( ( P +* I ) +* J ) halts_on s3 by A23,CKB6:1;
B24: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) c= (the carrier of ( SCM+FSA )) by RELAT_1:def 18;
( dom ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) = ( ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) /\ D ) by RELAT_1:61;
then ( dom ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) c= ( (the carrier of ( SCM+FSA )) /\ D ) by B24,XBOOLE_1:26;
then ( dom ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) c= ( ( dom ( Comput (( P +* I ),s,m1) ) ) /\ D ) by PARTFUN1:def 2;
then ( dom ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) c= ( dom ( DataPart ( Comput (( P +* I ),s,m1) ) ) ) by RELAT_1:61;
then (( DataPart s3 ) = ( ( DataPart ( Comput (( P +* I ),s,m1) ) ) +* ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) & ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) c= ( DataPart ( Comput (( P +* I ),s,m1) ) )) by A17,FUNCT_4:71,GRFUNC_1:2;
then A26: ( DataPart ( Comput (( P +* I ),s,m1) ) ) = ( DataPart s3 ) by FUNCT_4:98;
s = ( s +* SA0 ) by B5,A4,FUNCT_4:98,XBOOLE_1:1;
then ( DataPart ( Comput (P,s,m1) ) ) = ( DataPart s3 ) by A26,A11,CKB25:1,A14;
hence A28: ( DataPart ( Comput (P,s,( m1 + 1 )) ) ) = ( DataPart s3 ) by A14,CKB23:1,A7,A3,C13,XBOOLE_1:1;
( Reloc (J,( card I )) ) c= ( I ';' J ) by FUNCT_4:25;
hence A31: ( Reloc (J,( card I )) ) c= P by A3,XBOOLE_1:1;
( intloc ( 0 ) ) in ( Int-Locations ) by SCMFSA_2:2;
then A33: ( intloc ( 0 ) ) in D by SCMFSA_2:100,XBOOLE_0:def 3;
hence ( s4 . ( intloc ( 0 ) ) ) = ( ( DataPart s3 ) . ( intloc ( 0 ) ) ) by A28,FUNCT_1:49
.= ( s3 . ( intloc ( 0 ) ) ) by A33,FUNCT_1:49
.= 1 by FUNCT_4:13,SCMFSA6A:41,SCMFSA6A:43;
A34: ( Comput (P,s,( ( m1 + 1 ) + m3 )) ) = ( Comput (P,( Comput (P,s,( m1 + 1 )) ),m3) ) by EXTPRO_1:4;
A36: J c= ( ( P +* I ) +* J ) by FUNCT_4:25;
then ( IncAddr (( CurInstr (( ( P +* I ) +* J ),( Comput (( ( P +* I ) +* J ),s3,m3) )) ),( card I )) ) = ( CurInstr (P,( Comput (P,s4,m3) )) ) by A15,A28,CKB14:1,A31;
then A37: ( CurInstr (P,( Comput (P,s,m) )) ) = ( IncAddr (( halt ( SCM+FSA ) ),( card I )) ) by A25,A34,EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_1:11;
hence A38: P halts_on s by EXTPRO_1:29;
A39:now
let k being (Element of ( NAT ));
assume ( ( m1 + 1 ) + k ) < m;
then A40: k < m3 by XREAL_1:6;
assume A41: ( CurInstr (P,( Comput (P,s,( ( m1 + 1 ) + k )) )) ) = ( halt ( SCM+FSA ) );
( IncAddr (( CurInstr (( ( P +* I ) +* J ),( Comput (( ( P +* I ) +* J ),s3,k) )) ),( card I )) ) = ( CurInstr (P,( Comput (P,s4,k) )) ) by A15,A28,CKB14:1,A36,A31
.= ( halt ( SCM+FSA ) ) by A41,EXTPRO_1:4;
then ( InsCode ( CurInstr (( ( P +* I ) +* J ),( Comput (( ( P +* I ) +* J ),s3,k) )) ) ) = ( 0 ) by COMPOS_1:def 17,SCMFSA_2:97;
then ( CurInstr (( ( P +* I ) +* J ),( Comput (( ( P +* I ) +* J ),s3,k) )) ) = ( halt ( SCM+FSA ) ) by SCMFSA_2:95;
hence contradiction by A25,A40,EXTPRO_1:def 15;
end;
now
let k being (Element of ( NAT ));
assume A42: k < m;
per cases ;
suppose A43: k <= m1;

( ( P +* I ) +* ( Directed I ) ) = ( P +* ( Directed I ) ) by A1,FUNCT_4:74;
hence ( CurInstr (P,( Comput (P,s,k) )) ) <> ( halt ( SCM+FSA ) ) by A4,CKB24:1,A43,A9,FUNCT_4:25;
end;
suppose m1 < k;

then ( m1 + 1 ) <= k by NAT_1:13;
then consider kk being Nat such that A44: ( ( m1 + 1 ) + kk ) = k by NAT_1:10;
kk in ( NAT ) by ORDINAL1:def 12;
hence ( CurInstr (P,( Comput (P,s,k) )) ) <> ( halt ( SCM+FSA ) ) by A39,A42,A44;
end;
end;
then A45: (for k being (Element of ( NAT )) holds (( CurInstr (P,( Comput (P,s,k) )) ) = ( halt ( SCM+FSA ) ) implies m <= k));
then A46: ( LifeSpan (P,s) ) = m by A37,A38,EXTPRO_1:def 15;
( P +* I ) halts_on s by CKB6:1,A4,FUNCT_4:25;
then ( Comput (( P +* I ),s,( LifeSpan (( P +* I ),s) )) ) = ( Result (( P +* I ),s) ) by EXTPRO_1:23;
hence ( LifeSpan (P,s) ) = ( ( ( LifeSpan (( P +* I ),s) ) + 1 ) + ( LifeSpan (( ( P +* I ) +* J ),( ( Result (( P +* I ),s) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) ) by A45,A37,A38,EXTPRO_1:def 15;
hereby
A50: ( DataPart ( Comput (( ( P +* I ) +* J ),s3,m3) ) ) = ( DataPart ( Comput (P,s4,m3) ) ) by A15,A28,CKB14:1,A36,A31;
IJ: J c= ( ( P +* I ) +* J ) by FUNCT_4:25;
assume A51: J is  keeping_0;
thus ( ( Result (P,s) ) . ( intloc ( 0 ) ) ) = ( ( Comput (P,s,m) ) . ( intloc ( 0 ) ) ) by A38,A46,EXTPRO_1:23
.= ( ( Comput (P,s4,m3) ) . ( intloc ( 0 ) ) ) by EXTPRO_1:4
.= ( ( Comput (( ( P +* I ) +* J ),s3,m3) ) . ( intloc ( 0 ) ) ) by A50,SCMFSA6A:7
.= ( s3 . ( intloc ( 0 ) ) ) by A51,CKB3:def 1,IJ
.= 1 by A23,GRFUNC_1:2,SCMFSA6A:41,SCMFSA6A:43;
end;
end;
