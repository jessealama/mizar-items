environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMFSA_2,FSM_1,CARD_1,TARSKI,SCMFSA6A,FUNCT_4,RELAT_1,XBOOLE_0,FUNCT_1,INT_1,MSUALG_1,CIRCUIT2,AMI_3,ARYTM_3,XXREAL_0,NAT_1,SF_MASTR,GRAPHSP,AMISTD_2,TURING_1,STRUCT_0,VALUED_1,FUNCOP_1,SCMFSA6B,PARTFUN1,SCMNORM,RELOC,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,CARD_1,NUMBERS,XCMPLX_0,XXREAL_0,NAT_1,FUNCT_7,INT_1,RELAT_1,FUNCT_1,PARTFUN1,PBOOLE,FINSEQ_1,FUNCOP_1,FUNCT_4,VALUED_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,SCMFSA_2,AMISTD_1,AMISTD_2,SCMFSA6A,SF_MASTR,CKB1,CKB2,CKB3;
definitions AMISTD_2,FUNCOP_1,SCMFSA6A,COMPOS_1,EXTPRO_1,MEMSTR_0,AMISTD_1,CKB2,CKB3;
theorems RELAT_1,FUNCT_7,FUNCT_4,FUNCT_1,SCMFSA_3,INT_1,FUNCOP_1,TARSKI,NAT_1,SCMFSA_2,MEMSTR_0,GRFUNC_1,SCMFSA6A,SF_MASTR,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,XXREAL_0,VALUED_1,PBOOLE,PARTFUN1,AFINSQ_1,FINSEQ_4,COMPOS_1,EXTPRO_1,AMISTD_2,AMISTD_5,AMISTD_1,STRUCT_0,CKB2,CKB3,CKB5,CKB6,CKB7,CKB10,CKB11,CKB12,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB28;
schemes NAT_1;
registrations SETFAM_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SCMFSA6A,SF_MASTR,XBOOLE_0,FINSET_1,AMISTD_2,SCMFSA10,COMPOS_1,EXTPRO_1,SCMFSA_4,PBOOLE,PRE_POLY,FUNCT_7,FUNCT_4,STRUCT_0,MEMSTR_0,CKB4,CKB8,CKB9,CKB13,CKB20,CKB27;
constructors XXREAL_0,SCMFSA6A,SF_MASTR,AMISTD_1,AMISTD_2,MEMSTR_0,RELSET_1,PRE_POLY,AMISTD_5,DOMAIN_1,PBOOLE,AMI_3,FUNCT_7,CKB1,CKB2,CKB3;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve I for (Program of ( SCM+FSA ));
reserve a for Int-Location;
reserve f for FinSeq-Location;
reserve s for (State of ( SCM+FSA ));
reserve P for (Instruction-Sequence of ( SCM+FSA ));
theorem
Th42: (for s being ( 0 ) -started (State of ( SCM+FSA )) holds (for I being  keeping_0 (Program of ( SCM+FSA )) holds (( P +* I ) halts_on s implies (for J being  paraclosed (Program of ( SCM+FSA )) holds (( I ';' J ) c= P implies (for k being (Element of ( NAT )) holds ( IncIC (( Comput (( ( P +* I ) +* J ),( Initialize ( Result (( P +* I ),s) ) ),k) ),( card I )) ) = ( Comput (( P +* ( I ';' J ) ),s,( ( ( LifeSpan (( P +* I ),s) ) + 1 ) + k )) )))))))
proof
let s being ( 0 ) -started (State of ( SCM+FSA ));
let I being  keeping_0 (Program of ( SCM+FSA ));
assume A1: ( P +* I ) halts_on s;
let J being  paraclosed (Program of ( SCM+FSA ));
set RI = ( Result (( P +* I ),s) );
set JSA0 = ( Start-At (( 0 ),( SCM+FSA )) );
set RIJ = ( RI +* JSA0 );
defpred X[ Nat ]
 means
( IncIC (( Comput (( ( P +* I ) +* J ),RIJ,$1) ),( card I )) ) = ( Comput (( P +* ( I ';' J ) ),s,( ( ( LifeSpan (( P +* I ),s) ) + 1 ) + $1 )) );
assume A2: ( I ';' J ) c= P;
then A3: ( P +* ( I ';' J ) ) = P by FUNCT_4:98;
A7: (for n being (Element of ( NAT )) holds (X[ n ] implies X[ ( n + 1 ) ]))
proof
let k being (Element of ( NAT ));
set k1 = ( k + 1 );
set CRk = ( Comput (( ( P +* I ) +* J ),RIJ,k) );
set CRSk = ( IncIC (CRk,( card I )) );
set CIJk = ( Comput (( P +* ( I ';' J ) ),s,( ( ( LifeSpan (( P +* I ),s) ) + 1 ) + k )) );
set CRk1 = ( Comput (( ( P +* I ) +* J ),RIJ,k1) );
set CRSk1 = ( IncIC (CRk1,( card I )) );
set CIJk1 = ( Comput (( P +* ( I ';' J ) ),s,( ( ( LifeSpan (( P +* I ),s) ) + 1 ) + k1 )) );
assume A8: ( IncIC (( Comput (( ( P +* I ) +* J ),RIJ,k) ),( card I )) ) = ( Comput (( P +* ( I ';' J ) ),s,( ( ( LifeSpan (( P +* I ),s) ) + 1 ) + k )) );
A9: ( IncAddr (( CurInstr (( ( P +* I ) +* J ),CRk) ),( card I )) ) = ( CurInstr (( P +* ( I ';' J ) ),CIJk) )
proof
A10: ( I ';' J ) c= ( P +* ( I ';' J ) ) by FUNCT_4:25;
( Reloc (J,( card I )) ) c= ( I ';' J ) by FUNCT_4:25;
then A11: ( Reloc (J,( card I )) ) c= ( P +* ( I ';' J ) ) by A10,XBOOLE_1:1;
B12: ( dom ( P +* ( I ';' J ) ) ) = ( NAT ) by PARTFUN1:def 2;
A13: ( CurInstr (( P +* ( I ';' J ) ),CIJk) ) = ( ( P +* ( I ';' J ) ) . ( IC CRSk ) ) by A8,B12,PARTFUN1:def 6
.= ( ( P +* ( I ';' J ) ) . ( ( IC CRk ) + ( card I ) ) ) by FUNCT_4:113;
reconsider ii = ( IC CRk ) as (Element of ( NAT ));
A14: ( Reloc (J,( card I )) ) = ( Shift (( IncAddr (J,( card I )) ),( card I )) ) by COMPOS_1:34;
J c= ( ( P +* I ) +* J ) by FUNCT_4:25;
then A16: ( IC CRk ) in ( dom J ) by AMISTD_1:def 10;
then A17: ( IC CRk ) in ( dom ( IncAddr (J,( card I )) ) ) by COMPOS_1:def 19;
then A18: ( ( Shift (( IncAddr (J,( card I )) ),( card I )) ) . ( ( IC CRk ) + ( card I ) ) ) = ( ( IncAddr (J,( card I )) ) . ii ) by VALUED_1:def 12
.= ( IncAddr (( J /. ii ),( card I )) ) by A16,COMPOS_1:def 19;
( dom ( Shift (( IncAddr (J,( card I )) ),( card I )) ) ) = { ( il + ( card I ) ) where il is (Element of ( NAT )): il in ( dom ( IncAddr (J,( card I )) ) ) } by VALUED_1:def 12;
then A19: ( ii + ( card I ) ) in ( dom ( Shift (( IncAddr (J,( card I )) ),( card I )) ) ) by A17;
A20: J c= ( ( P +* I ) +* J ) by FUNCT_4:25;
A21: ( J /. ii ) = ( J . ii ) by A16,PARTFUN1:def 6;
thus ( IncAddr (( CurInstr (( ( P +* I ) +* J ),CRk) ),( card I )) ) = ( IncAddr (( ( ( P +* I ) +* J ) . ( IC CRk ) ),( card I )) ) by PBOOLE:143
.= ( ( Reloc (J,( card I )) ) . ( ( IC CRk ) + ( card I ) ) ) by A18,A14,A20,A21,A16,GRFUNC_1:2
.= ( CurInstr (( P +* ( I ';' J ) ),CIJk) ) by A13,A11,A14,A19,GRFUNC_1:2;
end;
A23: ( Exec (( CurInstr (( P +* ( I ';' J ) ),CIJk) ),CIJk) ) = ( IncIC (( Following (( ( P +* I ) +* J ),CRk) ),( card I )) ) by A9,A8,AMISTD_5:4;
CIJk1 = ( Comput (( P +* ( I ';' J ) ),s,( ( ( ( LifeSpan (( P +* I ),s) ) + 1 ) + k ) + 1 )) );
then A24: CIJk1 = ( Following (( P +* ( I ';' J ) ),CIJk) ) by EXTPRO_1:3;
A25: (for a being Int-Location holds ( CRSk1 . a ) = ( CIJk1 . a )) by A24,A23,EXTPRO_1:3;
A26: (for f being FinSeq-Location holds ( CRSk1 . f ) = ( CIJk1 . f )) by A24,A23,EXTPRO_1:3;
( IC CRSk1 ) = ( ( IC CRk1 ) + ( card I ) ) by FUNCT_4:113
.= ( ( IC ( Following (( ( P +* I ) +* J ),CRk) ) ) + ( card I ) ) by EXTPRO_1:3;
then ( IC CRSk1 ) = ( IC CIJk1 ) by A24,A23,FUNCT_4:113;
hence thesis by A25,A26,SCMFSA_2:61;
end;
B29: ( Directed I ) c= ( I ';' J ) by SCMFSA6A:16;
A31:now
set s2 = ( Comput (( P +* ( I ';' J ) ),s,( ( ( LifeSpan (( P +* I ),s) ) + 1 ) + ( 0 ) )) );
set s1 = ( IncIC (RIJ,( card I )) );
thus ( IC s1 ) = ( ( IC RIJ ) + ( card I ) ) by FUNCT_4:113
.= ( ( 0 ) + ( card I ) ) by FUNCT_4:113
.= ( IC s2 ) by A1,B29,CKB22:1,A3,A2,XBOOLE_1:1;
A32: ( DataPart ( Comput (P,s,( LifeSpan (( P +* I ),s) )) ) ) = ( DataPart ( Comput (P,s,( ( LifeSpan (( P +* I ),s) ) + 1 )) ) ) by A1,B29,CKB23:1,A2,XBOOLE_1:1;
set o = ( LifeSpan (( P +* I ),s) );
hereby
let a being Int-Location;
A34: (not a in ( dom JSA0 )) by SCMFSA_2:102;
(not a in ( dom ( Start-At (( ( IC RIJ ) + ( card I ) ),( SCM+FSA )) ) )) by SCMFSA_2:102;
hence ( s1 . a ) = ( RIJ . a ) by FUNCT_4:11
.= ( RI . a ) by A34,FUNCT_4:11
.= ( ( Comput (( P +* I ),s,( LifeSpan (( P +* I ),s) )) ) . a ) by A1,EXTPRO_1:23
.= ( ( Comput (( P +* ( I ';' J ) ),s,( LifeSpan (( P +* I ),s) )) ) . a ) by CKB25:1,A1
.= ( s2 . a ) by A32,A3,SCMFSA6A:7;
end;
let f being FinSeq-Location;
A35: (not f in ( dom JSA0 )) by SCMFSA_2:103;
(not f in ( dom ( Start-At (( ( IC RIJ ) + ( card I ) ),( SCM+FSA )) ) )) by SCMFSA_2:103;
hence ( s1 . f ) = ( RIJ . f ) by FUNCT_4:11
.= ( RI . f ) by A35,FUNCT_4:11
.= ( ( Comput (( P +* I ),s,( LifeSpan (( P +* I ),s) )) ) . f ) by A1,EXTPRO_1:23
.= ( ( Comput (( P +* ( I ';' J ) ),s,( LifeSpan (( P +* I ),s) )) ) . f ) by CKB25:1,A1
.= ( s2 . f ) by A32,A3,SCMFSA6A:7;
end;
( Comput (( ( P +* I ) +* J ),RIJ,( 0 )) ) = RIJ by EXTPRO_1:2;
then A37: X[ ( 0 ) ] by A31,SCMFSA_2:61;
(for k being (Element of ( NAT )) holds X[ k ]) from NAT_1:sch 1(A37,A7);
hence thesis;
end;
