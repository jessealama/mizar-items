environ
vocabularies NUMBERS,AMI_3,AMI_1,FSM_1,ORDINAL1,CAT_1,XBOOLE_0,FUNCT_1,RELAT_1,FINSEQ_1,CARD_1,AMISTD_2,GRAPHSP,CARD_3,AMISTD_1,SUBSET_1,CIRCUIT2,FUNCT_4,FUNCOP_1,SETFAM_1,ZFMISC_1,XXREAL_0,TARSKI,ARYTM_3,GOBOARD5,FRECHET,ARYTM_1,INT_1,UNIALG_1,CARD_5,PARTFUN1,NAT_1,COMPOS_1,PBOOLE;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,RELAT_1,FUNCT_1,FUNCT_2,ZFMISC_1,CARD_1,ORDINAL1,NAT_1,NUMBERS,XCMPLX_0,INT_1,FUNCOP_1,PARTFUN1,PBOOLE,FINSEQ_1,FUNCT_4,XXREAL_0,MCART_1,VALUED_1,STRUCT_0,CARD_3,FUNCT_7,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,AMI_3,AMISTD_1,AMISTD_2;
definitions TARSKI,FUNCT_1,FUNCT_7,AMISTD_1,AMISTD_2,XBOOLE_0,AMI_3,FUNCOP_1,AMI_2,COMPOS_1,EXTPRO_1,CARD_3,NAT_1,MCART_1,MEMSTR_0;
theorems TARSKI,NAT_1,AMI_3,FUNCT_4,AMI_5,FUNCT_1,FUNCOP_1,SETFAM_1,AMISTD_1,MCART_1,FINSEQ_1,MEMSTR_0,FUNCT_7,CARD_3,XBOOLE_0,XBOOLE_1,NAT_D,RELAT_1,ORDINAL1,PARTFUN1,PBOOLE,RECDEF_2,VALUED_1,COMPOS_1,EXTPRO_1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB28,CKB29,CKB31,CKB32,CKB34,CKB35,CKB37,CKB38,CKB48;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,NUMBERS,XREAL_0,NAT_1,INT_1,FINSEQ_1,CARD_3,AMI_3,AMISTD_2,RELSET_1,ZFMISC_1,FUNCT_2,FUNCT_4,VALUED_0,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_7,PRE_POLY,MEMSTR_0,CARD_1,CKB1,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB30,CKB33,CKB36,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56,CKB57,CKB58,CKB59;
constructors XXREAL_0,NAT_1,NAT_D,ZFMISC_1,AMI_3,AMISTD_2,RELSET_1,RECDEF_2,MCART_1,VALUED_1,AMI_2,EXTPRO_1,AMISTD_1,PRE_POLY,DOMAIN_1,FUNCT_7,MEMSTR_0;
requirements NUMERALS,BOOLE,SUBSET,REAL,ARITHM;
begin
reserve a for Data-Location;
reserve b for Data-Location;
reserve i1 for (Element of ( NAT ));
reserve i2 for (Element of ( NAT ));
reserve I for (Instruction of ( SCM ));
reserve T for (InsType of ( SCM ));
reserve k for  natural number;
registration
cluster ( SCM ) ->  regular  J/A-independent;
coherence
proof
thus ( SCM ) is  regular
proof
let I being (Instruction of ( SCM ));
set T = ( InsCode I );
A1: ( JumpPart I ) in ( JumpParts T );
per cases  by CKB2:1;
suppose T = ( 0 );

then I = ( halt ( SCM ) ) by AMI_5:7;
hence thesis;
end;
suppose T = 1;

then ( JumpParts T ) = { ( {} ) } by CKB5:1;
then ( JumpPart I ) = ( {} ) by A1,TARSKI:def 1;
hence thesis;
end;
suppose T = 2;

then ( JumpParts T ) = { ( {} ) } by CKB6:1;
then ( JumpPart I ) = ( {} ) by A1,TARSKI:def 1;
hence thesis;
end;
suppose T = 3;

then ( JumpParts T ) = { ( {} ) } by CKB7:1;
then ( JumpPart I ) = ( {} ) by A1,TARSKI:def 1;
hence thesis;
end;
suppose T = 4;

then ( JumpParts T ) = { ( {} ) } by CKB8:1;
then ( JumpPart I ) = ( {} ) by A1,TARSKI:def 1;
hence thesis;
end;
suppose T = 5;

then ( JumpParts T ) = { ( {} ) } by CKB9:1;
then ( JumpPart I ) = ( {} ) by A1,TARSKI:def 1;
hence thesis;
end;
suppose A2: T = 6;

then consider i2 such that A3: I = ( SCM-goto i2 ) by AMI_5:13;
let k being set;
assume A4: k in ( dom ( JumpPart I ) );
(for f being Function holds (f in ( JumpParts T ) implies k in ( dom f )))
proof
let f being Function;
assume f in ( JumpParts T );
then consider J being (Instruction of ( SCM )) such that A5: f = ( JumpPart J ) and A6: ( InsCode J ) = T;
thus k in ( dom f ) by A4,A5,A6,COMPOS_1:def 12;
end;
then k in ( dom ( product" ( JumpParts T ) ) ) by CARD_3:def 12;
then k in { 1 } by A2,CKB10:1;
then k = 1 by TARSKI:def 1;
hence ( ( product" ( JumpParts ( InsCode I ) ) ) . k ) = ( NAT ) by A3,CKB13:1;
end;
suppose A7: T = 7;

then consider i1,a such that A8: I = ( a =0_goto i1 ) by AMI_5:14;
let k being set;
assume A9: k in ( dom ( JumpPart I ) );
(for f being Function holds (f in ( JumpParts T ) implies k in ( dom f )))
proof
let f being Function;
assume f in ( JumpParts T );
then consider J being (Instruction of ( SCM )) such that A10: f = ( JumpPart J ) and A11: ( InsCode J ) = T;
thus k in ( dom f ) by A9,A10,A11,COMPOS_1:def 12;
end;
then k in ( dom ( product" ( JumpParts T ) ) ) by CARD_3:def 12;
then k in { 1 } by A7,CKB11:1;
then k = 1 by TARSKI:def 1;
hence ( ( product" ( JumpParts ( InsCode I ) ) ) . k ) = ( NAT ) by A8,CKB14:1;
end;
suppose A12: T = 8;

then consider i1,a such that A13: I = ( a >0_goto i1 ) by AMI_5:15;
let k being set;
assume A14: k in ( dom ( JumpPart I ) );
(for f being Function holds (f in ( JumpParts T ) implies k in ( dom f )))
proof
let f being Function;
assume f in ( JumpParts T );
then consider J being (Instruction of ( SCM )) such that A15: f = ( JumpPart J ) and A16: ( InsCode J ) = T;
thus k in ( dom f ) by A14,A15,A16,COMPOS_1:def 12;
end;
then k in ( dom ( product" ( JumpParts T ) ) ) by CARD_3:def 12;
then k in { 1 } by A12,CKB12:1;
then k = 1 by TARSKI:def 1;
hence ( ( product" ( JumpParts ( InsCode I ) ) ) . k ) = ( NAT ) by A13,CKB15:1;
end;
end;

let T being (InsType of ( SCM ));
let f1 being Function;
let f2 being Function;
let p being set;
assume that
A17: f1 in ( JumpParts T )
and
A18: f2 in ( product ( product" ( JumpParts T ) ) )
and
A19: [ T,f1,p ] in (the Instructions of ( SCM ));
per cases  by CKB2:1;
suppose (((((T = ( 0 ) or T = 1) or T = 2) or T = 3) or T = 4) or T = 5);

then A20: ( JumpParts T ) = { ( 0 ) } by CKB4:1,CKB5:1,CKB6:1,CKB7:1,CKB8:1,CKB9:1;
f1 = ( 0 ) by A20,A17,TARSKI:def 1
.= f2 by A18,A20,CARD_3:10,CARD_3:106,TARSKI:def 1;
hence [ T,f2,p ] in (the Instructions of ( SCM )) by A19;
end;
suppose A21: T = 6;

reconsider J = [ T,f1,p ] as (Instruction of ( SCM )) by A19;
A22: ( InsCode J ) = 6 by A21,RECDEF_2:def 1;
then consider i1 being (Element of ( NAT )) such that A23: J = ( SCM-goto i1 ) by AMI_5:13;
A24: p = ( {} ) by A23,MCART_1:25;
A25: ( dom f2 ) = ( dom ( product" ( JumpParts T ) ) ) by A18,CARD_3:9;
A26: ( dom f2 ) = { 1 } by A21,A25,CKB10:1;
then 1 in ( dom f2 ) by TARSKI:def 1;
then ( f2 . 1 ) in ( ( product" ( JumpParts T ) ) . 1 ) by A25,A18,CARD_3:9;
then reconsider l = ( f2 . 1 ) as (Element of ( NAT )) by A23,A21,A22,CKB13:1;
set I = [ T,f2,( {} ) ];
I = ( SCM-goto l ) by A21,A26,FINSEQ_1:2,FINSEQ_1:def 8;
then reconsider I as (Instruction of ( SCM ));
f2 = ( JumpPart I ) by RECDEF_2:def 2;
hence [ T,f2,p ] in (the Instructions of ( SCM )) by A24;
end;
suppose A27: T = 7;

reconsider J = [ T,f1,p ] as (Instruction of ( SCM )) by A19;
A28: ( InsCode J ) = T by RECDEF_2:def 1;
then consider i1,a such that A29: J = ( a =0_goto i1 ) by A27,AMI_5:14;
A30: p = <* a *> by A29,MCART_1:25;
A31: ( dom f2 ) = ( dom ( product" ( JumpParts T ) ) ) by A18,CARD_3:9;
A32: ( dom f2 ) = { 1 } by A27,A31,CKB11:1;
then 1 in ( dom f2 ) by TARSKI:def 1;
then ( f2 . 1 ) in ( ( product" ( JumpParts T ) ) . 1 ) by A31,A18,CARD_3:9;
then reconsider l = ( f2 . 1 ) as (Element of ( NAT )) by A29,A28,CKB14:1;
set I = [ T,f2,p ];
I = ( a =0_goto l ) by A30,A27,A32,FINSEQ_1:2,FINSEQ_1:def 8;
then reconsider I as (Instruction of ( SCM ));
A33: ( InsCode I ) = T by RECDEF_2:def 1;
consider i2,b such that A34: I = ( b =0_goto i2 ) by A27,A33,AMI_5:14;
thus [ T,f2,p ] in (the Instructions of ( SCM )) by A34;
end;
suppose A35: T = 8;

reconsider J = [ T,f1,p ] as (Instruction of ( SCM )) by A19;
A36: ( InsCode J ) = T by RECDEF_2:def 1;
then consider i1,a such that A37: J = ( a >0_goto i1 ) by A35,AMI_5:15;
A38: p = <* a *> by A37,MCART_1:25;
A39: ( dom f2 ) = ( dom ( product" ( JumpParts T ) ) ) by A18,CARD_3:9;
A40: ( dom f2 ) = { 1 } by A35,A39,CKB12:1;
then 1 in ( dom f2 ) by TARSKI:def 1;
then ( f2 . 1 ) in ( ( product" ( JumpParts T ) ) . 1 ) by A39,A18,CARD_3:9;
then reconsider l = ( f2 . 1 ) as (Element of ( NAT )) by A37,A36,CKB15:1;
set I = [ T,f2,p ];
I = ( a >0_goto l ) by A38,A35,A40,FINSEQ_1:2,FINSEQ_1:def 8;
then reconsider I as (Instruction of ( SCM ));
A41: ( InsCode I ) = T by RECDEF_2:def 1;
consider i2,b such that A42: I = ( b >0_goto i2 ) by A35,A41,AMI_5:15;
thus [ T,f2,p ] in (the Instructions of ( SCM )) by A42;
end;
end;
end;
