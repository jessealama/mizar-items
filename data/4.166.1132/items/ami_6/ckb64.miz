environ
vocabularies NUMBERS,AMI_3,AMI_1,FSM_1,ORDINAL1,CAT_1,XBOOLE_0,FUNCT_1,RELAT_1,FINSEQ_1,CARD_1,AMISTD_2,GRAPHSP,CARD_3,AMISTD_1,SUBSET_1,CIRCUIT2,FUNCT_4,FUNCOP_1,SETFAM_1,ZFMISC_1,XXREAL_0,TARSKI,ARYTM_3,GOBOARD5,FRECHET,ARYTM_1,INT_1,UNIALG_1,CARD_5,PARTFUN1,NAT_1,COMPOS_1,PBOOLE;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,RELAT_1,FUNCT_1,FUNCT_2,ZFMISC_1,CARD_1,ORDINAL1,NAT_1,NUMBERS,XCMPLX_0,INT_1,FUNCOP_1,PARTFUN1,PBOOLE,FINSEQ_1,FUNCT_4,XXREAL_0,MCART_1,VALUED_1,STRUCT_0,CARD_3,FUNCT_7,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,AMI_3,AMISTD_1,AMISTD_2;
definitions TARSKI,FUNCT_1,FUNCT_7,AMISTD_1,AMISTD_2,XBOOLE_0,AMI_3,FUNCOP_1,AMI_2,COMPOS_1,EXTPRO_1,CARD_3,NAT_1,MCART_1,MEMSTR_0;
theorems TARSKI,NAT_1,AMI_3,FUNCT_4,AMI_5,FUNCT_1,FUNCOP_1,SETFAM_1,AMISTD_1,MCART_1,FINSEQ_1,MEMSTR_0,FUNCT_7,CARD_3,XBOOLE_0,XBOOLE_1,NAT_D,RELAT_1,ORDINAL1,PARTFUN1,PBOOLE,RECDEF_2,VALUED_1,COMPOS_1,EXTPRO_1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB28,CKB29,CKB31,CKB32,CKB34,CKB35,CKB37,CKB38,CKB48,CKB61,CKB62,CKB63;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,NUMBERS,XREAL_0,NAT_1,INT_1,FINSEQ_1,CARD_3,AMI_3,AMISTD_2,RELSET_1,ZFMISC_1,FUNCT_2,FUNCT_4,VALUED_0,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_7,PRE_POLY,MEMSTR_0,CARD_1,CKB1,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB30,CKB33,CKB36,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56,CKB57,CKB58,CKB59,CKB60;
constructors XXREAL_0,NAT_1,NAT_D,ZFMISC_1,AMI_3,AMISTD_2,RELSET_1,RECDEF_2,MCART_1,VALUED_1,AMI_2,EXTPRO_1,AMISTD_1,PRE_POLY,DOMAIN_1,FUNCT_7,MEMSTR_0;
requirements NUMERALS,BOOLE,SUBSET,REAL,ARITHM;
begin
reserve a for Data-Location;
reserve b for Data-Location;
reserve k for  natural number;
reserve k1 for  natural number;
registration
cluster ( SCM ) ->  IC-relocable;
coherence
proof
thus ( SCM ) is  IC-relocable
proof
let I being (Instruction of ( SCM ));
per cases  by AMI_3:24;
suppose I = [ ( 0 ),( {} ),( {} ) ];

hence thesis by AMI_3:26;
end;
suppose (ex a st (ex b st I = ( a := b )));

hence thesis;
end;
suppose (ex a st (ex b st I = ( AddTo (a,b) )));

hence thesis;
end;
suppose (ex a st (ex b st I = ( SubFrom (a,b) )));

hence thesis;
end;
suppose (ex a st (ex b st I = ( MultBy (a,b) )));

hence thesis;
end;
suppose (ex a st (ex b st I = ( Divide (a,b) )));

hence thesis;
end;
suppose A1: (ex k st I = ( SCM-goto k ));

let j being Nat,k being Nat;
let s1 being (State of ( SCM ));
set s2 = ( IncIC (s1,k) );
consider k1 such that A2: I = ( SCM-goto k1 ) by A1;
reconsider i1 = k1 as (Element of ( NAT )) by ORDINAL1:def 12;
( IC ( Exec (I,s1) ) ) = k1 by A2,AMI_3:7;
hence ( ( IC ( Exec (( IncAddr (I,j) ),s1) ) ) + k ) = ( ( IC ( Exec (( SCM-goto ( j + k1 ) ),s1) ) ) + k ) by A2,CKB61:1
.= ( ( j + k1 ) + k ) by AMI_3:7
.= ( IC ( Exec (( SCM-goto ( ( j + i1 ) + k ) ),s2) ) ) by AMI_3:7
.= ( IC ( Exec (( SCM-goto ( ( j + k ) + i1 ) ),s2) ) )
.= ( IC ( Exec (( IncAddr (I,( j + k )) ),s2) ) ) by A2,CKB61:1;
end;
suppose (ex a st (ex k st I = ( a =0_goto k )));

then consider a,k1 such that A3: I = ( a =0_goto k1 );
reconsider i1 = k1 as (Element of ( NAT )) by ORDINAL1:def 12;
let j being  natural number,k being  natural number;
let s1 being (State of ( SCM ));
set s2 = ( IncIC (s1,k) );
(a <> ( IC ( SCM ) ) & ( dom ( ( IC ( SCM ) ) .--> ( ( IC s1 ) + k ) ) ) = { ( IC ( SCM ) ) }) by AMI_5:2,FUNCOP_1:13;
then (not a in ( dom ( ( IC ( SCM ) ) .--> ( ( IC s1 ) + k ) ) )) by TARSKI:def 1;
then A4: ( s1 . a ) = ( s2 . a ) by FUNCT_4:11;
now
per cases ;
suppose A5: ( s1 . a ) = ( 0 );

then ( IC ( Exec (I,s1) ) ) = k1 by A3,AMI_3:8;
hence ( ( IC ( Exec (( IncAddr (I,j) ),s1) ) ) + k ) = ( ( IC ( Exec (( a =0_goto ( j + k1 ) ),s1) ) ) + k ) by A3,CKB62:1
.= ( ( j + k1 ) + k ) by A5,AMI_3:8
.= ( IC ( Exec (( a =0_goto ( ( j + i1 ) + k ) ),s2) ) ) by A4,A5,AMI_3:8
.= ( IC ( Exec (( a =0_goto ( ( j + k ) + i1 ) ),s2) ) )
.= ( IC ( Exec (( IncAddr (I,( j + k )) ),s2) ) ) by A3,CKB62:1;
end;
suppose A6: ( s1 . a ) <> ( 0 );

A7: ( IncAddr (I,j) ) = ( a =0_goto ( i1 + j ) ) by A3,CKB62:1;
A8: ( IncAddr (I,( j + k )) ) = ( a =0_goto ( i1 + ( j + k ) ) ) by A3,CKB62:1;
( dom ( ( IC ( SCM ) ) .--> ( ( IC s1 ) + k ) ) ) = { ( IC ( SCM ) ) } by FUNCOP_1:13;
then ( IC ( SCM ) ) in ( dom ( ( IC ( SCM ) ) .--> ( ( IC s1 ) + k ) ) ) by TARSKI:def 1;
then A9: ( IC s2 ) = ( ( ( IC ( SCM ) ) .--> ( ( IC s1 ) + k ) ) . ( IC ( SCM ) ) ) by FUNCT_4:13
.= ( ( IC s1 ) + k ) by FUNCOP_1:72;
thus ( ( IC ( Exec (( IncAddr (I,j) ),s1) ) ) + k ) = ( ( succ ( IC s1 ) ) + k ) by A7,A6,AMI_3:8
.= ( ( ( IC s1 ) + 1 ) + k )
.= ( succ ( IC s2 ) ) by A9
.= ( IC ( Exec (( IncAddr (I,( j + k )) ),s2) ) ) by A8,A6,A4,AMI_3:8;
end;
end;
hence thesis;
end;
suppose (ex a st (ex k st I = ( a >0_goto k )));

then consider a,k1 such that A10: I = ( a >0_goto k1 );
reconsider i1 = k1 as (Element of ( NAT )) by ORDINAL1:def 12;
let j being  natural number,k being  natural number;
let s1 being (State of ( SCM ));
set s2 = ( IncIC (s1,k) );
(a <> ( IC ( SCM ) ) & ( dom ( ( IC ( SCM ) ) .--> ( ( IC s1 ) + k ) ) ) = { ( IC ( SCM ) ) }) by AMI_5:2,FUNCOP_1:13;
then (not a in ( dom ( ( IC ( SCM ) ) .--> ( ( IC s1 ) + k ) ) )) by TARSKI:def 1;
then A11: ( s1 . a ) = ( s2 . a ) by FUNCT_4:11;
per cases ;
suppose A12: ( s1 . a ) > ( 0 );

then ( IC ( Exec (I,s1) ) ) = k1 by A10,AMI_3:9;
hence ( ( IC ( Exec (( IncAddr (I,j) ),s1) ) ) + k ) = ( ( IC ( Exec (( a >0_goto ( j + k1 ) ),s1) ) ) + k ) by A10,CKB63:1
.= ( ( j + k1 ) + k ) by A12,AMI_3:9
.= ( IC ( Exec (( a >0_goto ( ( j + i1 ) + k ) ),s2) ) ) by A11,A12,AMI_3:9
.= ( IC ( Exec (( a >0_goto ( ( j + k ) + i1 ) ),s2) ) )
.= ( IC ( Exec (( IncAddr (I,( j + k )) ),s2) ) ) by A10,CKB63:1;
end;
suppose A13: ( s1 . a ) <= ( 0 );

A14: ( IncAddr (I,j) ) = ( a >0_goto ( i1 + j ) ) by A10,CKB63:1;
A15: ( IncAddr (I,( j + k )) ) = ( a >0_goto ( i1 + ( j + k ) ) ) by A10,CKB63:1;
( dom ( ( IC ( SCM ) ) .--> ( ( IC s1 ) + k ) ) ) = { ( IC ( SCM ) ) } by FUNCOP_1:13;
then ( IC ( SCM ) ) in ( dom ( ( IC ( SCM ) ) .--> ( ( IC s1 ) + k ) ) ) by TARSKI:def 1;
then A16: ( IC s2 ) = ( ( ( IC ( SCM ) ) .--> ( ( IC s1 ) + k ) ) . ( IC ( SCM ) ) ) by FUNCT_4:13
.= ( ( IC s1 ) + k ) by FUNCOP_1:72;
thus ( ( IC ( Exec (( IncAddr (I,j) ),s1) ) ) + k ) = ( ( succ ( IC s1 ) ) + k ) by A14,A13,AMI_3:9
.= ( ( ( IC s1 ) + 1 ) + k )
.= ( succ ( IC s2 ) ) by A16
.= ( IC ( Exec (( IncAddr (I,( j + k )) ),s2) ) ) by A15,A13,A11,AMI_3:9;
end;
end;
end;

end;
end;
