environ
vocabularies XBOOLE_0,ORDERS_2,SUBSET_1,STRUCT_0,MSUALG_1,PRALG_2,FUNCT_1,RELAT_1,CARD_3,RLVECT_2,PBOOLE,XXREAL_0,MEMBER_1,MSUALG_3,FUNCOP_1,RELAT_2,MCART_1,MSUALG_2,TARSKI,UNIALG_2,MARGREL1,FUNCT_6,FINSEQ_1,FUNCT_2,COMPLEX1,PARTFUN1,FINSEQ_4,NAT_1,FUNCT_5,NATTRA_1,PUA2MSS1,ZFMISC_1,MSALIMIT;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NAT_1,MCART_1,RELAT_1,FUNCT_1,STRUCT_0,RELAT_2,FUNCT_2,FINSEQ_1,FINSEQ_2,ORDERS_2,FUNCOP_1,RELSET_1,PARTFUN1,CARD_3,BINOP_1,FUNCT_5,FUNCT_6,PBOOLE,PRALG_1,MSUALG_1,MSUALG_2,MSUALG_3,PRALG_2,PUA2MSS1,ORDERS_3,CKB3,CKB4,CKB5,CKB7,CKB9,CKB14,CKB16;
definitions TARSKI,XBOOLE_0,BINOP_1,CKB3,CKB4,CKB5,CKB7,CKB9,CKB14,CKB16;
theorems ALTCAT_1,CARD_3,FUNCOP_1,FINSEQ_1,FUNCT_1,FUNCT_2,FUNCT_5,FUNCT_7,MCART_1,MSUALG_1,MSUALG_2,MSUALG_3,MSUHOM_1,ORDERS_2,ORDERS_3,PARTFUN1,PBOOLE,PRALG_1,PRALG_2,PUA2MSS1,RELAT_1,RELAT_2,TARSKI,ZFMISC_1,RELSET_1,XBOOLE_0,XBOOLE_1,ORDERS_1,FUNCT_6,FINSEQ_2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB13,CKB14,CKB15,CKB16;
schemes FRAENKEL,PBOOLE,TARSKI,XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,FUNCOP_1,PBOOLE,STRUCT_0,ORDERS_2,MSUALG_1,MSUALG_2,PRALG_2,MSUALG_3,ORDERS_3,PRALG_3,ORDINAL1,CARD_3,RELSET_1,CKB1,CKB2,CKB11,CKB12,CKB17;
constructors PRALG_1,PRALG_2,MSUALG_3,PUA2MSS1,ORDERS_3,RELSET_1,FINSEQ_2,CKB3,CKB4,CKB5,CKB7,CKB9,CKB14,CKB16;
requirements SUBSET,BOOLE;
begin
definition
func TrivialMSSign ->  strict ManySortedSign means 
:Def8: it is  empty  void;
existence
proof
(( dom ( ( {} ) --> ( {} ) ) ) = ( {} ) & ( rng ( ( {} ) --> ( {} ) ) ) = ( {} ));
then reconsider g = ( ( {} ) --> ( {} ) ) as (Function of ( {} ),( {} )) by RELSET_1:4;
( {} ) in ( ( {} ) * ) by FINSEQ_1:49;
then reconsider f = ( ( {} ) --> ( {} ) ) as (Function of ( {} ),( ( {} ) * )) by FUNCOP_1:46;
take ManySortedSign (# ( {} ),( {} ),f,g #);
thus thesis;
end;
uniqueness
proof
let C1 being  strict ManySortedSign;
let C2 being  strict ManySortedSign;
assume that
A1: C1 is  empty  void
and
A2: C2 is  empty  void;
C1 = C2
proof
A3: ((the carrier of C1) = ( {} ) & (the carrier' of C1) = ( {} )) by A1;
then reconsider RS = (the ResultSort of C1),RT = (the ResultSort of C2) as (Function of ( {} ),( {} )) by A2;
A4: ((the carrier of C2) = ( {} ) & (the carrier' of C2) = ( {} )) by A2;
A5: RT in { ( id ( {} ) ) } by ALTCAT_1:2,FUNCT_2:9;
RS in { ( id ( {} ) ) } by ALTCAT_1:2,FUNCT_2:9;
then (the ResultSort of C1) = ( id ( {} ) )
.= (the ResultSort of C2) by A5;
hence thesis by A3,A4;
end;
hence thesis;
end;
end;
