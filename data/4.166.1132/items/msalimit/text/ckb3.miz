environ
vocabularies XBOOLE_0,ORDERS_2,SUBSET_1,STRUCT_0,MSUALG_1,PRALG_2,FUNCT_1,RELAT_1,CARD_3,RLVECT_2,PBOOLE,XXREAL_0,MEMBER_1,MSUALG_3,FUNCOP_1,RELAT_2,MCART_1,MSUALG_2,TARSKI,UNIALG_2,MARGREL1,FUNCT_6,FINSEQ_1,FUNCT_2,COMPLEX1,PARTFUN1,FINSEQ_4,NAT_1,FUNCT_5,NATTRA_1,PUA2MSS1,ZFMISC_1,MSALIMIT;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NAT_1,MCART_1,RELAT_1,FUNCT_1,STRUCT_0,RELAT_2,FUNCT_2,FINSEQ_1,FINSEQ_2,ORDERS_2,FUNCOP_1,RELSET_1,PARTFUN1,CARD_3,BINOP_1,FUNCT_5,FUNCT_6,PBOOLE,PRALG_1,MSUALG_1,MSUALG_2,MSUALG_3,PRALG_2,PUA2MSS1,ORDERS_3;
definitions TARSKI,XBOOLE_0,BINOP_1;
theorems ALTCAT_1,CARD_3,FUNCOP_1,FINSEQ_1,FUNCT_1,FUNCT_2,FUNCT_5,FUNCT_7,MCART_1,MSUALG_1,MSUALG_2,MSUALG_3,MSUHOM_1,ORDERS_2,ORDERS_3,PARTFUN1,PBOOLE,PRALG_1,PRALG_2,PUA2MSS1,RELAT_1,RELAT_2,TARSKI,ZFMISC_1,RELSET_1,XBOOLE_0,XBOOLE_1,ORDERS_1,FUNCT_6,FINSEQ_2;
schemes FRAENKEL,PBOOLE,TARSKI,XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,FUNCOP_1,PBOOLE,STRUCT_0,ORDERS_2,MSUALG_1,MSUALG_2,PRALG_2,MSUALG_3,ORDERS_3,PRALG_3,ORDINAL1,CARD_3,RELSET_1,CKB1,CKB2;
constructors PRALG_1,PRALG_2,MSUALG_3,PUA2MSS1,ORDERS_3,RELSET_1,FINSEQ_2;
requirements SUBSET,BOOLE;
begin
reserve P for non  empty Poset;
reserve i for (Element of P);
reserve j for (Element of P);
reserve k for (Element of P);
reserve S for non  void non  empty ManySortedSign;
definition
let P;
let S;
mode OrderedAlgFam of P,S
 -> (MSAlgebra-Family of (the carrier of P),S)
means :Def1: (ex F being (ManySortedFunction of (the InternalRel of P)) st (for i holds (for j holds (for k holds ((i >= j & j >= k) implies (ex f1 being (ManySortedFunction of ( it . i ),( it . j )) st (ex f2 being (ManySortedFunction of ( it . j ),( it . k )) st (((f1 = ( F . (j,i) ) & f2 = ( F . (k,j) )) & ( F . (k,i) ) = ( f2 ** f1 )) & f1 is_homomorphism ( it . i ),( it . j )))))))));
existence
proof
reconsider T1 = (the InternalRel of P) as (Relation of (the carrier of P));
set A = the  non-empty MSAlgebra over S;
reconsider Z = ( (the carrier of P) --> A ) as (ManySortedSet of (the carrier of P));
(for i being set holds (i in (the carrier of P) implies ( Z . i ) is  non-empty  non-empty MSAlgebra over S)) by FUNCOP_1:7;
then reconsider Z as (MSAlgebra-Family of (the carrier of P),S) by PRALG_2:def 5;
take Z;
set G = ( (the InternalRel of P) --> ( id (the Sorts of A) ) );
reconsider G as (ManySortedFunction of (the InternalRel of P));
take G;
let i;
let j;
let k;
A1: ( Z . j ) = A by FUNCOP_1:7;
( Z . k ) = A by FUNCOP_1:7;
then consider F2 being (ManySortedFunction of ( Z . j ),( Z . k )) such that A2: F2 = ( id (the Sorts of A) ) by A1;
assume (i >= j & j >= k);
then A3: ([ j,i ] in (the InternalRel of P) & [ k,j ] in (the InternalRel of P)) by ORDERS_2:def 5;
( field T1 ) = (the carrier of P) by ORDERS_1:12;
then T1 is_transitive_in (the carrier of P) by RELAT_2:def 16;
then A4: [ k,i ] in T1 by A3,RELAT_2:def 8;
A5: ( Z . i ) = A by FUNCOP_1:7;
then consider F1 being (ManySortedFunction of ( Z . i ),( Z . j )) such that A6: F1 = ( id (the Sorts of A) ) by A1;
take F1;
take F2;
( F2 ** F1 ) = ( id (the Sorts of A) ) by A6,A2,MSUALG_3:3;
hence thesis by A3,A5,A1,A6,A2,A4,FUNCOP_1:7,MSUALG_3:9;
end;
end;
