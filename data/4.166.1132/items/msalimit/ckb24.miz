environ
vocabularies XBOOLE_0,ORDERS_2,SUBSET_1,STRUCT_0,MSUALG_1,PRALG_2,FUNCT_1,RELAT_1,CARD_3,RLVECT_2,PBOOLE,XXREAL_0,MEMBER_1,MSUALG_3,FUNCOP_1,RELAT_2,MCART_1,MSUALG_2,TARSKI,UNIALG_2,MARGREL1,FUNCT_6,FINSEQ_1,FUNCT_2,COMPLEX1,PARTFUN1,FINSEQ_4,NAT_1,FUNCT_5,NATTRA_1,PUA2MSS1,ZFMISC_1,MSALIMIT;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NAT_1,MCART_1,RELAT_1,FUNCT_1,STRUCT_0,RELAT_2,FUNCT_2,FINSEQ_1,FINSEQ_2,ORDERS_2,FUNCOP_1,RELSET_1,PARTFUN1,CARD_3,BINOP_1,FUNCT_5,FUNCT_6,PBOOLE,PRALG_1,MSUALG_1,MSUALG_2,MSUALG_3,PRALG_2,PUA2MSS1,ORDERS_3,CKB3,CKB4,CKB5,CKB7,CKB9,CKB14,CKB16,CKB18;
definitions TARSKI,XBOOLE_0,BINOP_1,CKB3,CKB4,CKB5,CKB7,CKB9,CKB14,CKB16,CKB18;
theorems ALTCAT_1,CARD_3,FUNCOP_1,FINSEQ_1,FUNCT_1,FUNCT_2,FUNCT_5,FUNCT_7,MCART_1,MSUALG_1,MSUALG_2,MSUALG_3,MSUHOM_1,ORDERS_2,ORDERS_3,PARTFUN1,PBOOLE,PRALG_1,PRALG_2,PUA2MSS1,RELAT_1,RELAT_2,TARSKI,ZFMISC_1,RELSET_1,XBOOLE_0,XBOOLE_1,ORDERS_1,FUNCT_6,FINSEQ_2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB13,CKB14,CKB15,CKB16,CKB18,CKB21,CKB22,CKB23;
schemes FRAENKEL,PBOOLE,TARSKI,XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,FUNCOP_1,PBOOLE,STRUCT_0,ORDERS_2,MSUALG_1,MSUALG_2,PRALG_2,MSUALG_3,ORDERS_3,PRALG_3,ORDINAL1,CARD_3,RELSET_1,CKB1,CKB2,CKB11,CKB12,CKB17,CKB19,CKB20;
constructors PRALG_1,PRALG_2,MSUALG_3,PUA2MSS1,ORDERS_3,RELSET_1,FINSEQ_2,CKB3,CKB4,CKB5,CKB7,CKB9,CKB14,CKB16,CKB18;
requirements SUBSET,BOOLE;
begin
reserve S for non void non empty ManySortedSign;
reserve x for set;
reserve A for non empty set;
definition
let A;
func MSS_set A
means
:Def9: (x in it iff (ex S being  strict non empty non void ManySortedSign st ((x = S & (the carrier of S) c= A) & (the carrier' of S) c= A)));
existence
proof
defpred P[ set,set ]
 means
(ex S being  strict non empty non void ManySortedSign st (S = $2 & $1 = [ (the carrier of S),(the carrier' of S),(the Arity of S),(the ResultSort of S) ]));
A1: (for x,y,z being set holds ((P[ x,y ] & P[ x,z ]) implies y = z))
proof
let x being set,y being set,z being set;
assume (P[ x,y ] & P[ x,z ]);
then consider S1 being  strict non empty non void ManySortedSign,S2 being  strict non empty non void ManySortedSign such that A2: S1 = y and A3: x = [ (the carrier of S1),(the carrier' of S1),(the Arity of S1),(the ResultSort of S1) ] and A4: S2 = z and A5: x = [ (the carrier of S2),(the carrier' of S2),(the Arity of S2),(the ResultSort of S2) ] and (S2 is  empty implies S2 is  void);
A6: (the Arity of S1) = (the Arity of S2) by A3,A5,MCART_1:29;
((the carrier of S1) = (the carrier of S2) & (the carrier' of S1) = (the carrier' of S2)) by A3,A5,MCART_1:29;
hence thesis by A2,A3,A4,A5,A6,MCART_1:29;
end;
consider X being set such that A7: (for x holds (x in X iff (ex y being set st (y in [: ( bool A ),( bool A ),( PFuncs (A,( A * )) ),( PFuncs (A,A) ) :] & P[ y,x ])))) from TARSKI:sch 1(A1);
take X;
let x being set;
thus (x in X iff (ex S being  strict non empty non void ManySortedSign st ((x = S & (the carrier of S) c= A) & (the carrier' of S) c= A)))
proof
thus (x in X implies (ex S being  strict non empty non void ManySortedSign st ((x = S & (the carrier of S) c= A) & (the carrier' of S) c= A)))
proof
assume x in X;
then consider y being set such that A8: y in [: ( bool A ),( bool A ),( PFuncs (A,( A * )) ),( PFuncs (A,A) ) :] and A9: P[ y,x ] by A7;
consider S being  strict non empty non void ManySortedSign such that A10: S = x and y = [ (the carrier of S),(the carrier' of S),(the Arity of S),(the ResultSort of S) ] by A9;
take S;
((the carrier of S) in ( bool A ) & (the carrier' of S) in ( bool A )) by A8,A9,A10,MCART_1:80;
hence thesis by A10;
end;

given S being  strict non empty non void ManySortedSign such that
A11: x = S
and
A12: (the carrier of S) c= A
and
A13: (the carrier' of S) c= A;

(( dom (the ResultSort of S) ) = (the carrier' of S) & ( rng (the ResultSort of S) ) c= A) by A12,FUNCT_2:def 1,XBOOLE_1:1;
then A14: (the ResultSort of S) in ( PFuncs (A,A) ) by A13,PARTFUN1:def 3;
reconsider C = (the carrier of S) as (Subset of A) by A12;
consider y being set such that A15: y = [ (the carrier of S),(the carrier' of S),(the Arity of S),(the ResultSort of S) ];
( C * ) c= ( A * ) by MSUHOM_1:2;
then A16: ( rng (the Arity of S) ) c= ( A * ) by XBOOLE_1:1;
( dom (the Arity of S) ) c= A by A13,FUNCT_2:def 1;
then (the Arity of S) in ( PFuncs (A,( A * )) ) by A16,PARTFUN1:def 3;
then y in [: ( bool A ),( bool A ),( PFuncs (A,( A * )) ),( PFuncs (A,A) ) :] by A12,A13,A15,A14,MCART_1:80;
hence thesis by A7,A11,A15;
end;

end;
uniqueness
proof
let A1 being set,A2 being set;
assume that
A17: (x in A1 iff (ex S being  strict non empty non void ManySortedSign st ((x = S & (the carrier of S) c= A) & (the carrier' of S) c= A)))
and
A18: (x in A2 iff (ex S being  strict non empty non void ManySortedSign st ((x = S & (the carrier of S) c= A) & (the carrier' of S) c= A)));
thus A1 c= A2
proof
let x being set;
assume x in A1;
then (ex S being  strict non empty non void ManySortedSign st ((x = S & (the carrier of S) c= A) & (the carrier' of S) c= A)) by A17;
hence thesis by A18;
end;

thus A2 c= A1
proof
let x being set;
assume x in A2;
then (ex S being  strict non empty non void ManySortedSign st ((x = S & (the carrier of S) c= A) & (the carrier' of S) c= A)) by A18;
hence thesis by A17;
end;

end;
end;
