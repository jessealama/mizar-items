environ
vocabularies RLVECT_1,ALGSTR_1,ALGSTR_0,VECTSP_1,BINOP_1,LATTICES,VECTSP_2,ZFMISC_1,XBOOLE_0,STRUCT_0,POLYNOM1,VALUED_0,SUBSET_1,SUPINF_2,FUNCT_4,PRE_POLY,FUNCT_1,FUNCOP_1,RELAT_1,ORDINAL1,CARD_1,PARTFUN1,POLYNOM2,FINSEQ_1,CARD_3,NUMBERS,XXREAL_0,QC_LANG1,FINSET_1,ORDERS_1,ARYTM_3,NAT_1,MESFUNC1,QUOFIELD,GROUP_1,TARSKI,MSSUBFAM,ALGSEQ_1,CAT_3,XCMPLX_0,ORDINAL4,POLYNOM7;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,RELSET_1,FUNCT_1,FINSET_1,ORDINAL1,PARTFUN1,FUNCT_2,FUNCT_7,POLYNOM1,NUMBERS,XXREAL_0,DOMAIN_1,STRUCT_0,ALGSTR_0,FUNCT_4,NAT_1,ALGSTR_1,RLVECT_1,ORDERS_1,FINSEQ_1,FUNCOP_1,GROUP_1,QUOFIELD,GRCAT_1,VECTSP_2,POLYNOM2,VECTSP_1,GROUP_6,PRE_POLY,CKB2,CKB7;
definitions FUNCOP_1,STRUCT_0,CKB2,CKB7;
theorems TARSKI,FINSEQ_1,FUNCT_1,FUNCT_2,RELAT_1,ZFMISC_1,VECTSP_1,POLYNOM1,STRUCT_0,QUOFIELD,FUNCT_7,FUNCT_4,FUNCOP_1,GRCAT_1,BINOM,FINSEQ_3,RLVECT_1,VECTSP_2,GROUP_1,NAT_1,FINSEQ_2,FINSEQ_5,MATRLIN,POLYNOM2,XBOOLE_0,REALSET1,XREAL_1,GROUP_6,XXREAL_0,ORDINAL1,PARTFUN1,PRE_POLY,CKB2,CKB5,CKB6,CKB7,CKB10;
schemes FUNCT_2;
registrations XBOOLE_0,ORDINAL1,RELSET_1,FUNCOP_1,FINSET_1,XREAL_0,STRUCT_0,VECTSP_1,ALGSTR_1,POLYNOM1,POLYNOM2,ALGSTR_0,CARD_1,SUBSET_1,PRE_POLY,ZFMISC_1,FUNCT_1,CKB1,CKB3,CKB4,CKB8,CKB9;
constructors RFUNCT_3,REALSET2,GRCAT_1,GROUP_6,TRIANG_1,QUOFIELD,POLYNOM2,ALGSTR_1,RELSET_1,FUNCT_7,FVSUM_1,VFUNCT_1,CKB2,CKB7;
requirements NUMERALS,BOOLE,SUBSET,ARITHM;
begin
theorem
Lm1: (for L being non empty doubleLoopStr holds (for p being (Polynomial of ( {} ),L) holds (ex a being (Element of L) st p = ( { ( EmptyBag ( {} ) ) } --> a ))))
proof
set n = ( {} );
let L being non empty doubleLoopStr;
let p being (Polynomial of ( {} ),L);
A1: (for b being (bag of ( {} )) holds b = ( {} ))
proof
let b being (bag of ( {} ));
b in ( Bags ( {} ) ) by PRE_POLY:def 12;
hence thesis by PRE_POLY:51,TARSKI:def 1;
end;
reconsider p as (Function of ( Bags ( {} ) ),L);
reconsider p as (Function of { ( {} ) },(the carrier of L)) by PRE_POLY:51;
set a = ( p /. ( {} ) );
A2: ( dom p ) = { ( {} ) } by FUNCT_2:def 1
.= { ( EmptyBag n ) } by A1;
A3: (for u being set holds (u in p implies u in [: { ( EmptyBag n ) },{ a } :]))
proof
let u being set;
assume A4: u in p;
then consider p1 being set,p2 being set such that A5: u = [ p1,p2 ] by RELAT_1:def 1;
A6: p1 in ( dom p ) by A4,A5,RELAT_1:def 4;
then reconsider p1 as (bag of n) by A2;
A7: p1 = ( {} ) by A1;
then p2 = ( p . ( {} ) ) by A4,A5,A6,FUNCT_1:def 2
.= ( p /. ( {} ) ) by A6,A7,PARTFUN1:def 6;
then p2 in { a } by TARSKI:def 1;
hence thesis by A2,A5,A6,ZFMISC_1:def 2;
end;
take a;
A8: ( EmptyBag n ) = ( {} ) by A1;
(for u being set holds (u in [: { ( EmptyBag n ) },{ a } :] implies u in p))
proof
let u being set;
assume u in [: { ( EmptyBag n ) },{ a } :];
then consider u1 being set,u2 being set such that A9: u1 in { ( EmptyBag n ) } and A10: u2 in { a } and A11: u = [ u1,u2 ] by ZFMISC_1:def 2;
A12: u1 = ( {} ) by A8,A9,TARSKI:def 1;
u2 = a by A10,TARSKI:def 1
.= ( p . ( {} ) ) by A2,A9,A12,PARTFUN1:def 6;
hence thesis by A2,A9,A11,A12,FUNCT_1:1;
end;
hence thesis by A3,TARSKI:1;
end;
