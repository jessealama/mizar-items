environ
vocabularies RLVECT_1,ALGSTR_1,ALGSTR_0,VECTSP_1,BINOP_1,LATTICES,VECTSP_2,ZFMISC_1,XBOOLE_0,STRUCT_0,POLYNOM1,VALUED_0,SUBSET_1,SUPINF_2,FUNCT_4,PRE_POLY,FUNCT_1,FUNCOP_1,RELAT_1,ORDINAL1,CARD_1,PARTFUN1,POLYNOM2,FINSEQ_1,CARD_3,NUMBERS,XXREAL_0,QC_LANG1,FINSET_1,ORDERS_1,ARYTM_3,NAT_1,MESFUNC1,QUOFIELD,GROUP_1,TARSKI,MSSUBFAM,ALGSEQ_1,CAT_3,XCMPLX_0,ORDINAL4,POLYNOM7;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,RELSET_1,FUNCT_1,FINSET_1,ORDINAL1,PARTFUN1,FUNCT_2,FUNCT_7,POLYNOM1,NUMBERS,XXREAL_0,DOMAIN_1,STRUCT_0,ALGSTR_0,FUNCT_4,NAT_1,ALGSTR_1,RLVECT_1,ORDERS_1,FINSEQ_1,FUNCOP_1,GROUP_1,QUOFIELD,GRCAT_1,VECTSP_2,POLYNOM2,VECTSP_1,GROUP_6,PRE_POLY,CKB2,CKB7,CKB14,CKB16,CKB19,CKB20,CKB21,CKB29,CKB31;
definitions FUNCOP_1,STRUCT_0,CKB2,CKB7,CKB14,CKB19,CKB20,CKB21,CKB29;
theorems TARSKI,FINSEQ_1,FUNCT_1,FUNCT_2,RELAT_1,ZFMISC_1,VECTSP_1,POLYNOM1,STRUCT_0,QUOFIELD,FUNCT_7,FUNCT_4,FUNCOP_1,GRCAT_1,BINOM,FINSEQ_3,RLVECT_1,VECTSP_2,GROUP_1,NAT_1,FINSEQ_2,FINSEQ_5,MATRLIN,POLYNOM2,XBOOLE_0,REALSET1,XREAL_1,GROUP_6,XXREAL_0,ORDINAL1,PARTFUN1,PRE_POLY,CKB2,CKB5,CKB6,CKB7,CKB10,CKB11,CKB12,CKB13,CKB14,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29;
schemes FUNCT_2;
registrations XBOOLE_0,ORDINAL1,RELSET_1,FUNCOP_1,FINSET_1,XREAL_0,STRUCT_0,VECTSP_1,ALGSTR_1,POLYNOM1,POLYNOM2,ALGSTR_0,CARD_1,SUBSET_1,PRE_POLY,ZFMISC_1,FUNCT_1,CKB1,CKB3,CKB4,CKB8,CKB9,CKB15,CKB17,CKB30,CKB32;
constructors RFUNCT_3,REALSET2,GRCAT_1,GROUP_6,TRIANG_1,QUOFIELD,POLYNOM2,ALGSTR_1,RELSET_1,FUNCT_7,FVSUM_1,VFUNCT_1,CKB2,CKB7,CKB14,CKB19,CKB20,CKB21,CKB29;
requirements NUMERALS,BOOLE,SUBSET,ARITHM;
begin
theorem
Th14: (for X being set holds (for L being non  empty ZeroStr holds (for p being (Series of X,L) holds (p is (ConstPoly of X,L) iff (p = ( 0_ (X,L) ) or ( Support p ) = { ( EmptyBag X ) })))))
proof
let n being set;
let L being non  empty ZeroStr;
let p being (Series of n,L);
A1:now
assume A2: p is (ConstPoly of n,L);
A3: (for u being set holds (u in ( Support p ) implies u in { ( EmptyBag n ) }))
proof
let u being set;
assume A4: u in ( Support p );
then reconsider u as (Element of ( Bags n ));
reconsider u9 = u as (bag of n);
( p . u9 ) <> ( 0. L ) by A4,POLYNOM1:def 3;
then u9 = ( EmptyBag n ) by A2,CKB29:def 1;
hence thesis by TARSKI:def 1;
end;
thus (( Support p ) = { ( EmptyBag n ) } or p = ( 0_ (n,L) ))
proof
assume A5: (not ( Support p ) = { ( EmptyBag n ) });
A6: (not ( EmptyBag n ) in ( Support p ))
proof
assume ( EmptyBag n ) in ( Support p );
then (for u being set holds (u in { ( EmptyBag n ) } implies u in ( Support p ))) by TARSKI:def 1;
hence thesis by A3,A5,TARSKI:1;
end;
A7: ( Support p ) = ( {} )
proof
set v = the (Element of ( Support p ));
assume ( Support p ) <> ( {} );
then (v in ( Support p ) & v in { ( EmptyBag n ) }) by A3;
hence thesis by A6,TARSKI:def 1;
end;
A8: (for b being (bag of n) holds ( p . b ) = ( 0. L ))
proof
let b being (bag of n);
A9: b is (Element of ( Bags n )) by PRE_POLY:def 12;
assume ( p . b ) <> ( 0. L );
hence thesis by A7,A9,POLYNOM1:def 3;
end;
A10: (for u being set holds (u in ( rng p ) implies u in { ( 0. L ) }))
proof
let u being set;
assume u in ( rng p );
then consider x being set such that A11: x in ( dom p ) and A12: ( p . x ) = u by FUNCT_1:def 3;
x is (bag of n) by A11;
then u = ( 0. L ) by A8,A12;
hence thesis by TARSKI:def 1;
end;
A13: ( dom p ) = ( Bags n ) by FUNCT_2:def 1;
(for u being set holds (u in { ( 0. L ) } implies u in ( rng p )))
proof
set b = the (bag of n);
let u being set;
assume u in { ( 0. L ) };
then u = ( 0. L ) by TARSKI:def 1;
then A14: ( p . b ) = u by A8;
b in ( dom p ) by A13,PRE_POLY:def 12;
hence thesis by A14,FUNCT_1:def 3;
end;
then ( rng p ) = { ( 0. L ) } by A10,TARSKI:1;
then p = ( ( Bags n ) --> ( 0. L ) ) by A13,FUNCOP_1:9;
hence thesis by POLYNOM1:def 7;
end;

end;
now
assume A15: (p = ( 0_ (n,L) ) or ( Support p ) = { ( EmptyBag n ) });
per cases  by A15;
suppose p = ( 0_ (n,L) );

then (for b being (bag of n) holds (b <> ( EmptyBag n ) implies ( p . b ) = ( 0. L ))) by POLYNOM1:22;
hence p is (ConstPoly of n,L) by CKB29:def 1;
end;
suppose A16: ( Support p ) = { ( EmptyBag n ) };

(for b being (bag of n) holds (b <> ( EmptyBag n ) implies ( p . b ) = ( 0. L )))
proof
let b being (bag of n);
assume A17: b <> ( EmptyBag n );
reconsider b as (Element of ( Bags n )) by PRE_POLY:def 12;
(not b in ( Support p )) by A16,A17,TARSKI:def 1;
hence thesis by POLYNOM1:def 3;
end;
hence p is (ConstPoly of n,L) by CKB29:def 1;
end;
end;
hence thesis by A1;
end;
