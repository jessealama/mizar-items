environ
vocabularies RLVECT_1,ALGSTR_1,ALGSTR_0,VECTSP_1,BINOP_1,LATTICES,VECTSP_2,ZFMISC_1,XBOOLE_0,STRUCT_0,POLYNOM1,VALUED_0,SUBSET_1,SUPINF_2,FUNCT_4,PRE_POLY,FUNCT_1,FUNCOP_1,RELAT_1,ORDINAL1,CARD_1,PARTFUN1,POLYNOM2,FINSEQ_1,CARD_3,NUMBERS,XXREAL_0,QC_LANG1,FINSET_1,ORDERS_1,ARYTM_3,NAT_1,MESFUNC1,QUOFIELD,GROUP_1,TARSKI,MSSUBFAM,ALGSEQ_1,CAT_3,XCMPLX_0,ORDINAL4,POLYNOM7;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,RELSET_1,FUNCT_1,FINSET_1,ORDINAL1,PARTFUN1,FUNCT_2,FUNCT_7,POLYNOM1,NUMBERS,XXREAL_0,DOMAIN_1,STRUCT_0,ALGSTR_0,FUNCT_4,NAT_1,ALGSTR_1,RLVECT_1,ORDERS_1,FINSEQ_1,FUNCOP_1,GROUP_1,QUOFIELD,GRCAT_1,VECTSP_2,POLYNOM2,VECTSP_1,GROUP_6,PRE_POLY,CKB2,CKB7,CKB14,CKB16,CKB19,CKB20,CKB21,CKB29,CKB31,CKB39;
definitions FUNCOP_1,STRUCT_0,CKB2,CKB7,CKB14,CKB19,CKB20,CKB21,CKB29,CKB39;
theorems TARSKI,FINSEQ_1,FUNCT_1,FUNCT_2,RELAT_1,ZFMISC_1,VECTSP_1,POLYNOM1,STRUCT_0,QUOFIELD,FUNCT_7,FUNCT_4,FUNCOP_1,GRCAT_1,BINOM,FINSEQ_3,RLVECT_1,VECTSP_2,GROUP_1,NAT_1,FINSEQ_2,FINSEQ_5,MATRLIN,POLYNOM2,XBOOLE_0,REALSET1,XREAL_1,GROUP_6,XXREAL_0,ORDINAL1,PARTFUN1,PRE_POLY,CKB2,CKB5,CKB6,CKB7,CKB10,CKB11,CKB12,CKB13,CKB14,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB33,CKB36,CKB37,CKB38,CKB39,CKB41,CKB42,CKB43,CKB44;
schemes FUNCT_2;
registrations XBOOLE_0,ORDINAL1,RELSET_1,FUNCOP_1,FINSET_1,XREAL_0,STRUCT_0,VECTSP_1,ALGSTR_1,POLYNOM1,POLYNOM2,ALGSTR_0,CARD_1,SUBSET_1,PRE_POLY,ZFMISC_1,FUNCT_1,CKB1,CKB3,CKB4,CKB8,CKB9,CKB15,CKB17,CKB30,CKB32,CKB34,CKB35,CKB40;
constructors RFUNCT_3,REALSET2,GRCAT_1,GROUP_6,TRIANG_1,QUOFIELD,POLYNOM2,ALGSTR_1,RELSET_1,FUNCT_7,FVSUM_1,VFUNCT_1,CKB2,CKB7,CKB14,CKB19,CKB20,CKB21,CKB29,CKB39;
requirements NUMERALS,BOOLE,SUBSET,ARITHM;
begin
theorem
(for X being set holds (for L being  well-unital non empty multLoopStr_0 holds ( ( 1. L ) | (X,L) ) = ( 1_ (X,L) )))
proof
let X being set;
let L being  well-unital non empty multLoopStr_0;
set o1 = ( ( 1. L ) | (X,L) );
set o2 = ( 1_ (X,L) );
A1:now
set m = ( ( 0_ (X,L) ) +* (( EmptyBag X ),( 1. L )) );
let x being set;
reconsider m as (Function of ( Bags X ),(the carrier of L));
reconsider m as (Function of ( Bags X ),L);
reconsider m as (Series of X,L);
assume x in ( Bags X );
then reconsider x9 = x as (bag of X);
A2: ( dom ( 0_ (X,L) ) ) = ( dom ( ( Bags X ) --> ( 0. L ) ) ) by POLYNOM1:def 7
.= ( Bags X ) by FUNCOP_1:13;
then A3: m = ( ( 0_ (X,L) ) +* ( ( EmptyBag X ) .--> ( 1. L ) ) ) by FUNCT_7:def 3;
A4: ( dom ( ( EmptyBag X ) .--> ( 1. L ) ) ) = { ( EmptyBag X ) } by FUNCOP_1:13;
then A5: ( EmptyBag X ) in ( dom ( ( EmptyBag X ) .--> ( 1. L ) ) ) by TARSKI:def 1;
A6: ( m . ( EmptyBag X ) ) = ( ( ( 0_ (X,L) ) +* ( ( EmptyBag X ) .--> ( 1. L ) ) ) . ( EmptyBag X ) ) by A2,FUNCT_7:def 3
.= ( ( ( EmptyBag X ) .--> ( 1. L ) ) . ( EmptyBag X ) ) by A5,FUNCT_4:13
.= ( 1. L ) by FUNCOP_1:72;
per cases ;
suppose x9 = ( EmptyBag X );

hence ( o1 . x ) = ( o2 . x ) by A6,POLYNOM1:25;
end;
suppose A7: x9 <> ( EmptyBag X );

then (not x9 in ( dom ( ( EmptyBag X ) .--> ( 1. L ) ) )) by A4,TARSKI:def 1;
then ( m . x9 ) = ( ( 0_ (X,L) ) . x9 ) by A3,FUNCT_4:11
.= ( 0. L ) by POLYNOM1:22
.= ( o2 . x9 ) by A7,POLYNOM1:25;
hence ( o1 . x ) = ( o2 . x );
end;
end;
(( Bags X ) = ( dom o1 ) & ( Bags X ) = ( dom o2 )) by FUNCT_2:def 1;
hence thesis by A1,FUNCT_1:2;
end;
