environ
vocabularies NUMBERS,SUBSET_1,INT_1,NAT_1,ARYTM_3,INT_2,CARD_1,XXREAL_0,ORDINAL1,SQUARE_1,ABIAN,RELAT_1,ARYTM_1,FINSET_1,FUNCT_1,XBOOLE_0,COMPLEX1,TARSKI,PYTHTRIP;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,FINSET_1,NUMBERS,XCMPLX_0,XXREAL_0,INT_1,INT_2,NAT_1,NAT_D,SQUARE_1,ABIAN,PEPIN,DOMAIN_1,RELAT_1,FUNCT_1,LIMFUNC1,ORDINAL1,CKB1,CKB2,CKB3;
definitions INT_1,INT_2,SQUARE_1,RELAT_1,ABIAN,CKB1,CKB2,CKB3;
theorems SQUARE_1,NAT_1,INT_2,WSIERP_1,EULER_2,ABIAN,EULER_1,PEPIN,INT_1,ENUMSET1,FINSET_1,TARSKI,RELAT_1,FUNCT_1,ORDINAL1,ZFMISC_1,XBOOLE_0,XCMPLX_1,NEWTON,XREAL_1,COMPLEX1,XXREAL_0,PREPOWER,NAT_D,CKB1,CKB2,CKB3,CKB11,CKB15,CKB16,CKB17,CKB19,CKB20,CKB21,CKB22;
schemes NAT_1;
registrations ORDINAL1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,INT_1,NEWTON,ABIAN,XBOOLE_0,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13,CKB14,CKB18;
constructors DOMAIN_1,REAL_1,NAT_1,NAT_D,LIMFUNC1,ABIAN,PEPIN,VALUED_1,CKB3;
requirements SUBSET,BOOLE,NUMERALS,REAL,ARITHM;
begin
reserve k for (Element of ( NAT ));
reserve m for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
theorem
Th9: (for X being set holds ((for m holds (ex n st (n >= m & n in X))) implies X is  infinite))
proof
let X being set;
A1:now
let f being Function;
defpred P[ (Element of ( NAT )) ]
 means
(ex m st (for n holds (n >= m implies (not n in ( f .: $1 )))));
A2: (for k holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k;
assume (ex m st (for n holds (n >= m implies (not n in ( f .: k )))));
then consider m such that A3: (for n holds (n >= m implies (not n in ( f .: k ))));
( k + 1 ) = ( succ k ) by NAT_1:38
.= ( k \/ { k } ) by ORDINAL1:def 1;
then A4: ( f .: ( k + 1 ) ) = ( ( f .: k ) \/ ( Im (f,k) ) ) by RELAT_1:120;
per cases ;
suppose A5: (k in ( dom f ) & ( f . k ) in ( NAT ));

then reconsider m9 = ( f . k ) as (Element of ( NAT ));
take ( max (m,( m9 + 1 )) );
let n;
assume A6: n >= ( max (m,( m9 + 1 )) );
then A7: (not n in ( f .: k )) by A3,XXREAL_0:30;
n >= ( m9 + 1 ) by A6,XXREAL_0:30;
then n <> m9 by NAT_1:13;
then A8: (not n in { m9 }) by TARSKI:def 1;
( f .: ( k + 1 ) ) = ( ( f .: k ) \/ { m9 } ) by A4,A5,FUNCT_1:59;
hence thesis by A7,A8,XBOOLE_0:def 3;
end;
suppose A9: (k in ( dom f ) & (not ( f . k ) in ( NAT )));

take m;
set m9 = ( f . k );
let n;
n <> m9 by A9;
then A10: (not n in { m9 }) by TARSKI:def 1;
assume n >= m;
then A11: (not n in ( f .: k )) by A3;
( f .: ( k + 1 ) ) = ( ( f .: k ) \/ { m9 } ) by A4,A9,FUNCT_1:59;
hence thesis by A11,A10,XBOOLE_0:def 3;
end;
suppose (not k in ( dom f ));

then A12: ( dom f ) misses { k } by ZFMISC_1:50;
take m;
let n;
assume A13: n >= m;
( Im (f,k) ) = ( f .: ( ( dom f ) /\ { k } ) ) by RELAT_1:112
.= ( f .: ( {} ) ) by A12,XBOOLE_0:def 7
.= ( {} ) by RELAT_1:116;
hence thesis by A3,A4,A13;
end;
end;
A14: P[ ( 0 ) ]
proof
take ( 0 );
let n;
assume that
n >= ( 0 );
thus thesis by RELAT_1:116;
end;
thus (for k holds P[ k ]) from NAT_1:sch 1(A14,A2);
end;
now
assume X is  finite;
then consider f being Function such that A15: ( rng f ) = X and A16: ( dom f ) in ( omega ) by FINSET_1:def 1;
reconsider k = ( dom f ) as (Element of ( NAT )) by A16;
( f .: k ) = X by A15,RELAT_1:113;
hence (ex m st (for n holds (n >= m implies (not n in X)))) by A1;
end;
hence thesis;
end;
