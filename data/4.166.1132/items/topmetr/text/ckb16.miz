environ
vocabularies NUMBERS,REAL_1,NAT_1,XREAL_0,ORDINAL1,XBOOLE_0,PRE_TOPC,SETFAM_1,STRUCT_0,TARSKI,SUBSET_1,RCOMP_1,RELAT_1,CONNSP_2,TOPS_1,FUNCT_1,ORDINAL2,METRIC_1,CARD_1,XXREAL_0,ARYTM_3,REALSET1,ZFMISC_1,XXREAL_1,COMPLEX1,ARYTM_1,PCOMPS_1,FINSET_1,PARTFUN1,BORSUK_1,TOPMETR,MEMBERED;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,NUMBERS,MEMBERED,XCMPLX_0,XREAL_0,REAL_1,NAT_1,DOMAIN_1,RELAT_1,REALSET1,FUNCT_1,PARTFUN1,RELSET_1,XXREAL_0,FUNCT_2,FINSET_1,BINOP_1,STRUCT_0,METRIC_1,PRE_TOPC,TOPS_1,TOPS_2,COMPTS_1,PCOMPS_1,CONNSP_2,RCOMP_1,BORSUK_1,COMPLEX1,CKB9,CKB14;
definitions STRUCT_0,PRE_TOPC,TARSKI,TOPS_2,XREAL_0,BINOP_1,REALSET1,MEMBERED,PCOMPS_1,METRIC_1,CKB9,CKB14;
theorems ABSVALUE,BINOP_1,BORSUK_1,COMPTS_1,CONNSP_2,FINSET_1,FUNCT_1,FUNCT_2,METRIC_1,PCOMPS_1,PRE_TOPC,TARSKI,TOPS_1,TOPS_2,ZFMISC_1,TBSP_1,RELAT_1,RELSET_1,XREAL_0,XBOOLE_0,XBOOLE_1,PARTFUN1,XCMPLX_1,XREAL_1,COMPLEX1,XXREAL_0,SETFAM_1,XXREAL_1,XXREAL_2,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB12,CKB13,CKB14;
schemes FUNCT_2;
registrations XBOOLE_0,SUBSET_1,RELSET_1,XREAL_0,MEMBERED,REALSET1,STRUCT_0,PRE_TOPC,TOPS_1,METRIC_1,METRIC_3,PCOMPS_1,XXREAL_2,BORSUK_1,CKB10,CKB11,CKB15;
constructors SETFAM_1,REAL_1,COMPLEX1,RCOMP_1,REALSET1,TOPS_1,TOPS_2,COMPTS_1,BORSUK_1,FINSET_1,MEMBERED,XXREAL_2,PCOMPS_1,CKB9,CKB14;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
definition
let a being  real number;
let b being  real number;
assume A1: a <= b;
func Closed-Interval-MSpace (a,b) ->  strict non empty (SubSpace of ( RealSpace ))
means
:Def3: (for P being non empty (Subset of ( RealSpace )) holds (P = [. a,b .] implies it = ( ( RealSpace ) | P )));
existence
proof
reconsider P = [. a,b .] as (Subset of ( RealSpace ));
reconsider P as non empty (Subset of ( RealSpace )) by A1,XXREAL_1:1;
take ( ( RealSpace ) | P );
thus thesis;
end;
uniqueness
proof
reconsider P = [. a,b .] as (Subset of ( RealSpace ));
reconsider P as non empty (Subset of ( RealSpace )) by A1,XXREAL_1:1;
let S1 being  strict non empty (SubSpace of ( RealSpace )),S2 being  strict non empty (SubSpace of ( RealSpace ));
assume that
A2: (for P being non empty (Subset of ( RealSpace )) holds (P = [. a,b .] implies S1 = ( ( RealSpace ) | P )))
and
A3: (for P being non empty (Subset of ( RealSpace )) holds (P = [. a,b .] implies S2 = ( ( RealSpace ) | P )));
thus S1 = ( ( RealSpace ) | P ) by A2
.= S2 by A3;
end;
end;
