environ
vocabularies NUMBERS,RLVECT_1,ALGSTR_0,XBOOLE_0,FINSEQ_1,SUBSET_1,RELAT_1,XXREAL_0,FUNCT_1,SUPINF_2,CARD_3,ARYTM_3,TARSKI,ORDINAL4,PARTFUN1,CARD_1,FUNCT_7,ARYTM_1,RFINSEQ,PRE_POLY,PBOOLE,RELAT_2,BAGORDER,ORDERS_2,WAYBEL_4,ZFMISC_1,XCMPLX_0,ALGSTR_1,LATTICES,POLYNOM7,POLYNOM1,ORDINAL1,VECTSP_2,VALUED_0,VECTSP_1,BINOP_1,POLYRED,REWRITE1,STRUCT_0,MCART_1,TERMORD,GROEB_1,BROUWER,MESFUNC1,CAT_3,GROUP_1,IDEAL_1,FINSET_1,NAT_1,GROEB_2;
notations TARSKI,RELAT_1,XBOOLE_0,SUBSET_1,RELAT_2,RELSET_1,FUNCT_1,ORDINAL1,XCMPLX_0,PARTFUN1,FINSET_1,MCART_1,XXREAL_0,FINSEQ_1,PRE_POLY,STRUCT_0,ALGSTR_1,VECTSP_2,POLYNOM7,PBOOLE,ORDERS_2,REWRITE1,BAGORDER,ALGSTR_0,RLVECT_1,VFUNCT_1,VECTSP_1,POLYNOM1,TERMORD,IDEAL_1,POLYRED,GROUP_1,NAT_D,NUMBERS,NAT_1,GROEB_1,RFINSEQ,FINSEQ_7,WAYBEL_4,RECDEF_1;
definitions STRUCT_0;
theorems TARSKI,RELSET_1,FINSEQ_1,ZFMISC_1,VECTSP_1,POLYNOM1,FINSEQ_4,RLVECT_1,NAT_1,MCART_1,POLYNOM7,REWRITE1,XBOOLE_0,IDEAL_1,TERMORD,INT_1,FUNCT_1,FINSET_1,XBOOLE_1,VECTSP_2,POLYRED,FUNCT_2,BINOM,FINSEQ_3,RELAT_1,RELAT_2,WAYBEL_4,BAGORDER,RFINSEQ,FINSEQ_5,ALGSTR_1,FINSEQ_7,GROEB_1,GROUP_1,XREAL_1,XXREAL_0,PARTFUN1,VALUED_0,STRUCT_0,NAT_D,PRE_POLY;
schemes NAT_1,CLASSES1;
registrations XBOOLE_0,RELAT_1,ORDINAL1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,REWRITE1,STRUCT_0,VECTSP_1,ORDERS_2,ALGSTR_1,GCD_1,POLYNOM1,POLYNOM2,POLYNOM4,IDEAL_1,POLYNOM7,TERMORD,POLYRED,VALUED_0,ALGSTR_0,PRE_POLY,CARD_1,VFUNCT_1,FUNCT_1,FUNCT_2,RELSET_1;
constructors RFINSEQ,REWRITE1,FINSEQ_7,VECTSP_2,WAYBEL_4,WELLFND1,IDEAL_1,BAGORDER,TERMORD,POLYRED,GROEB_1,RECDEF_1,REAL_1,RELSET_1,PBOOLE,BINOP_2,VFUNCT_1;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
theorem
(for L being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for p being (FinSequence of L) holds (for n being (Element of ( NAT )) holds ((for k being (Element of ( NAT )) holds ((k in ( dom p ) & k > n) implies ( p . k ) = ( 0. L ))) implies ( Sum p ) = ( Sum ( p | n ) )))))
proof
let L being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let p being (FinSequence of L);
let n being (Element of ( NAT ));
defpred P[ (Element of ( NAT )) ]
 means
(for p being (FinSequence of L) holds (for n being (Element of ( NAT )) holds ((( len p ) = $1 & (for k being (Element of ( NAT )) holds ((k in ( dom p ) & k > n) implies ( p . k ) = ( 0. L )))) implies ( Sum p ) = ( Sum ( p | n ) ))));
A1:now
let k being (Element of ( NAT ));
assume A2: P[ k ];
now
let p being (FinSequence of L);
let n being (Element of ( NAT ));
assume that
A3: ( len p ) = ( k + 1 )
and
A4: (for l being (Element of ( NAT )) holds ((l in ( dom p ) & l > n) implies ( p . l ) = ( 0. L )));
A5: ( dom p ) = ( Seg ( k + 1 ) ) by A3,FINSEQ_1:def 3;
set q = ( p | ( Seg k ) );
reconsider q as (FinSequence of L) by FINSEQ_1:18;
A6: k <= ( len p ) by A3,NAT_1:11;
then A7: ( len q ) = k by FINSEQ_1:17;
(k <= ( k + 1 ) & ( dom q ) = ( Seg k )) by A6,FINSEQ_1:17,NAT_1:11;
then A8: ( dom q ) c= ( dom p ) by A5,FINSEQ_1:5;
A9: q = ( p | k ) by FINSEQ_1:def 15;
A10: ( q ^ <* ( p /. ( k + 1 ) ) *> ) = ( q ^ <* ( p . ( k + 1 ) ) *> ) by A5,FINSEQ_1:4,PARTFUN1:def 6
.= p by A3,FINSEQ_3:55;
now
per cases ;
case A11: k < n;
A12: ( dom ( p | n ) ) = ( dom ( p | ( Seg n ) ) ) by FINSEQ_1:def 15;
A13: ( k + 1 ) <= n by A11,NAT_1:13;
A14:now
let u being set;
assume A15: u in ( dom p );
then reconsider u9 = u as (Element of ( NAT ));
A16: u in ( Seg ( k + 1 ) ) by A3,A15,FINSEQ_1:def 3;
then u9 <= ( k + 1 ) by FINSEQ_1:1;
then A17: u9 <= n by A13,XXREAL_0:2;
1 <= u9 by A16,FINSEQ_1:1;
then u9 in ( Seg n ) by A17,FINSEQ_1:1;
then u9 in ( ( dom p ) /\ ( Seg n ) ) by A15,XBOOLE_0:def 4;
hence u in ( dom ( p | n ) ) by A12,RELAT_1:61;
end;
A18: (for x being set holds (x in ( dom ( p | ( Seg n ) ) ) implies ( ( p | ( Seg n ) ) . x ) = ( p . x ))) by FUNCT_1:47;
now
let u being set;
assume u in ( dom ( p | n ) );
then A19: u in ( dom ( p | ( Seg n ) ) ) by FINSEQ_1:def 15;
( dom ( p | ( Seg n ) ) ) c= ( dom p ) by RELAT_1:60;
hence u in ( dom p ) by A19;
end;
then ( dom ( p | n ) ) = ( dom p ) by A14,TARSKI:1;
then ( p | ( Seg n ) ) = p by A12,A18,FUNCT_1:2;
hence ( Sum ( p | n ) ) = ( Sum p ) by FINSEQ_1:def 15;
end;
case A20: n <= k;
A21:now
let l being (Element of ( NAT ));
assume that
A22: l in ( dom q )
and
A23: l > n;
A24: ( p . l ) = ( 0. L ) by A4,A8,A22,A23;
thus ( q . l ) = ( q /. l ) by A22,PARTFUN1:def 6
.= ( p /. l ) by A9,A22,FINSEQ_4:70
.= ( 0. L ) by A8,A22,A24,PARTFUN1:def 6;
end;
( k + 1 ) > n by A20,NAT_1:13;
then A25: ( 0. L ) = ( p . ( k + 1 ) ) by A4,A5,FINSEQ_1:4
.= ( p /. ( k + 1 ) ) by A5,FINSEQ_1:4,PARTFUN1:def 6;
thus ( Sum p ) = ( ( Sum q ) + ( Sum <* ( p /. ( k + 1 ) ) *> ) ) by A10,RLVECT_1:41
.= ( ( Sum q ) + ( p /. ( k + 1 ) ) ) by RLVECT_1:44
.= ( Sum q ) by A25,RLVECT_1:def 4
.= ( Sum ( q | n ) ) by A2,A7,A21
.= ( Sum ( p | n ) ) by A9,A20,FINSEQ_1:82;
end;
end;
hence ( Sum p ) = ( Sum ( p | n ) );
end;
hence P[ ( k + 1 ) ];
end;
A26: P[ ( 0 ) ] by FINSEQ_1:58;
A27: (for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A26,A1);
A28: (ex k being (Element of ( NAT )) st ( len p ) = k);
assume (for k being (Element of ( NAT )) holds ((k in ( dom p ) & k > n) implies ( p . k ) = ( 0. L )));
hence thesis by A27,A28;
end;
