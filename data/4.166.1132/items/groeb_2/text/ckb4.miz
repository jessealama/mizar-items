environ
vocabularies NUMBERS,RLVECT_1,ALGSTR_0,XBOOLE_0,FINSEQ_1,SUBSET_1,RELAT_1,XXREAL_0,FUNCT_1,SUPINF_2,CARD_3,ARYTM_3,TARSKI,ORDINAL4,PARTFUN1,CARD_1,FUNCT_7,ARYTM_1,RFINSEQ,PRE_POLY,PBOOLE,RELAT_2,BAGORDER,ORDERS_2,WAYBEL_4,ZFMISC_1,XCMPLX_0,ALGSTR_1,LATTICES,POLYNOM7,POLYNOM1,ORDINAL1,VECTSP_2,VALUED_0,VECTSP_1,BINOP_1,POLYRED,REWRITE1,STRUCT_0,MCART_1,TERMORD,GROEB_1,BROUWER,MESFUNC1,CAT_3,GROUP_1,IDEAL_1,FINSET_1,NAT_1,GROEB_2;
notations TARSKI,RELAT_1,XBOOLE_0,SUBSET_1,RELAT_2,RELSET_1,FUNCT_1,ORDINAL1,XCMPLX_0,PARTFUN1,FINSET_1,MCART_1,XXREAL_0,FINSEQ_1,PRE_POLY,STRUCT_0,ALGSTR_1,VECTSP_2,POLYNOM7,PBOOLE,ORDERS_2,REWRITE1,BAGORDER,ALGSTR_0,RLVECT_1,VFUNCT_1,VECTSP_1,POLYNOM1,TERMORD,IDEAL_1,POLYRED,GROUP_1,NAT_D,NUMBERS,NAT_1,GROEB_1,RFINSEQ,FINSEQ_7,WAYBEL_4,RECDEF_1,CKB3;
definitions STRUCT_0,CKB3;
theorems TARSKI,RELSET_1,FINSEQ_1,ZFMISC_1,VECTSP_1,POLYNOM1,FINSEQ_4,RLVECT_1,NAT_1,MCART_1,POLYNOM7,REWRITE1,XBOOLE_0,IDEAL_1,TERMORD,INT_1,FUNCT_1,FINSET_1,XBOOLE_1,VECTSP_2,POLYRED,FUNCT_2,BINOM,FINSEQ_3,RELAT_1,RELAT_2,WAYBEL_4,BAGORDER,RFINSEQ,FINSEQ_5,ALGSTR_1,FINSEQ_7,GROEB_1,GROUP_1,XREAL_1,XXREAL_0,PARTFUN1,VALUED_0,STRUCT_0,NAT_D,PRE_POLY,CKB1,CKB2,CKB3;
schemes NAT_1,CLASSES1;
registrations XBOOLE_0,RELAT_1,ORDINAL1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,REWRITE1,STRUCT_0,VECTSP_1,ORDERS_2,ALGSTR_1,GCD_1,POLYNOM1,POLYNOM2,POLYNOM4,IDEAL_1,POLYNOM7,TERMORD,POLYRED,VALUED_0,ALGSTR_0,PRE_POLY,CARD_1,VFUNCT_1,FUNCT_1,FUNCT_2,RELSET_1;
constructors RFINSEQ,REWRITE1,FINSEQ_7,VECTSP_2,WAYBEL_4,WELLFND1,IDEAL_1,BAGORDER,TERMORD,POLYRED,GROEB_1,RECDEF_1,REAL_1,RELSET_1,PBOOLE,BINOP_2,VFUNCT_1,CKB3;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
definition
let X being set;
let b1 being (bag of X);
let b2 being (bag of X);
func lcm (b1,b2) -> (bag of X) means 
:Def2: (for k being set holds ( it . k ) = ( max (( b1 . k ),( b2 . k )) ));
existence
proof
defpred Q[ set,set ]
 means
$2 = ( max (( b1 . $1 ),( b2 . $1 )) );
A1: (for x being set holds (x in X implies (ex y being set st Q[ x,y ])));
consider b being Function such that A2: (( dom b ) = X & (for x being set holds (x in X implies Q[ x,( b . x ) ]))) from CLASSES1:sch 1(A1);
reconsider b as (ManySortedSet of X) by A2,PARTFUN1:def 2,RELAT_1:def 18;
now
let u being set;
assume u in ( rng b );
then consider x being set such that A3: (x in ( dom b ) & u = ( b . x )) by FUNCT_1:def 3;
A4: (( b1 . x ) in ( NAT ) & ( b2 . x ) in ( NAT ));
u = ( max (( b1 . x ),( b2 . x )) ) by A2,A3;
hence u in ( NAT ) by A4,XXREAL_0:16;
end;
then A5: ( rng b ) c= ( NAT ) by TARSKI:def 3;
now
let u being set;
A6: ( support b ) c= ( dom b ) by PRE_POLY:37;
assume A7: u in ( support b );
then A8: ( b . u ) <> ( 0 ) by PRE_POLY:def 7;
now
assume A9: (not u in ( ( support b1 ) \/ ( support b2 ) ));
then (not u in ( support b2 )) by XBOOLE_0:def 3;
then A10: ( b2 . u ) = ( 0 ) by PRE_POLY:def 7;
(not u in ( support b1 )) by A9,XBOOLE_0:def 3;
then ( b1 . u ) = ( 0 ) by PRE_POLY:def 7;
then ( max (( b1 . u ),( b2 . u )) ) = ( 0 ) by A10;
hence contradiction by A2,A7,A8,A6;
end;
hence u in ( ( support b1 ) \/ ( support b2 ) );
end;
then ( support b ) c= ( ( support b1 ) \/ ( support b2 ) ) by TARSKI:def 3;
then reconsider b as (bag of X) by A5,PRE_POLY:def 8,VALUED_0:def 6;
A11: ( dom b ) = X by PARTFUN1:def 2
.= ( dom b2 ) by PARTFUN1:def 2;
take b;
A12: ( dom b ) = X by PARTFUN1:def 2
.= ( dom b1 ) by PARTFUN1:def 2;
now
let k being set;
now
per cases ;
case k in ( dom b );
hence ( b . k ) = ( max (( b1 . k ),( b2 . k )) ) by A2;
end;
case A13: (not k in ( dom b ));
then (( b1 . k ) = ( 0 ) & ( b2 . k ) = ( 0 )) by A12,A11,FUNCT_1:def 2;
hence ( b . k ) = ( max (( b1 . k ),( b2 . k )) ) by A13,FUNCT_1:def 2;
end;
end;
hence ( b . k ) = ( max (( b1 . k ),( b2 . k )) );
end;
hence thesis;
end;
uniqueness
proof
let b3 being (bag of X);
let b4 being (bag of X);
assume A14: (for k being set holds ( b3 . k ) = ( max (( b1 . k ),( b2 . k )) ));
assume A15: (for k being set holds ( b4 . k ) = ( max (( b1 . k ),( b2 . k )) ));
A16:now
let u being set;
assume u in ( dom b3 );
thus ( b3 . u ) = ( max (( b1 . u ),( b2 . u )) ) by A14
.= ( b4 . u ) by A15;
end;
( dom b3 ) = X by PARTFUN1:def 2
.= ( dom b4 ) by PARTFUN1:def 2;
hence thesis by A16,FUNCT_1:2;
end;
commutativity;
idempotence;
end;
