environ
vocabularies FUNCT_1,RELAT_1,FUNCOP_1,FUNCT_5,FUNCT_6,XBOOLE_0,TARSKI,FUNCT_2,PBOOLE,ZFMISC_1,SUBSET_1,CARD_3,MCART_1,MONOID_0,STRUCT_0,REWRITE1,WAYBEL_0,NEWTON,ORDERS_2,YELLOW_0,BINOP_1,GROUP_6,SEQM_3,XXREAL_0,CAT_1,FUNCT_3,CARD_1,YELLOW_1,RLVECT_2,PRE_TOPC,WAYBEL26,WAYBEL24,WAYBEL25,ORDINAL2,RCOMP_1,WELLORD2,WELLORD1,RELAT_2,WAYBEL11,WAYBEL_9,WAYBEL17,YELLOW_9,EQREL_1,WAYBEL18,PROB_1,WAYBEL_1,WAYBEL_8,RLVECT_3,LATTICES,BORSUK_1,WAYBEL27;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,TOLER_1,MCART_1,RELAT_1,FUNCT_1,PBOOLE,RELSET_1,PARTFUN1,BINOP_1,FUNCT_3,FUNCT_4,FUNCT_5,NUMBERS,CARD_3,FUNCOP_1,FUNCT_6,MONOID_0,PRALG_1,QUANTAL1,FUNCT_2,DOMAIN_1,STRUCT_0,PRE_TOPC,TOPS_2,ORDERS_2,CANTOR_1,LATTICE3,YELLOW_0,WAYBEL_0,YELLOW_1,YELLOW_2,WAYBEL_1,YELLOW_3,WAYBEL_3,WAYBEL_8,WAYBEL_9,WAYBEL11,YELLOW_9,WAYBEL17,WAYBEL18,WAYBEL24,WAYBEL25,YELLOW16,WAYBEL26,CKB1,CKB2,CKB3;
definitions TARSKI,FUNCT_1,MONOID_0,WAYBEL_0,FUNCOP_1,WAYBEL_1,XBOOLE_0,BINOP_1,YELLOW_2,STRUCT_0,CKB1,CKB2,CKB3;
theorems YELLOW_1,CARD_3,FUNCT_2,FUNCT_1,PRE_TOPC,TARSKI,PRALG_1,FUNCOP_1,YELLOW_0,WELLORD1,WAYBEL17,WAYBEL10,TOPS_2,TOPS_3,YELLOW_9,WAYBEL24,WAYBEL26,WAYBEL_0,RELSET_1,ORDERS_2,RELAT_1,FUNCT_6,YELLOW14,WAYBEL18,WAYBEL20,WAYBEL25,WAYBEL_1,WAYBEL15,QUANTAL1,WAYBEL14,WAYBEL13,YELLOW16,ZFMISC_1,FUNCT_5,FUNCT_3,YELLOW_2,WAYBEL_3,WAYBEL_8,YELLOW_3,MCART_1,FUNCT_4,WAYBEL21,XBOOLE_0,XBOOLE_1,PARTFUN1,CKB1,CKB2,CKB3;
schemes FUNCT_2,PBOOLE,XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,FUNCOP_1,STRUCT_0,TOPS_1,LATTICE3,YELLOW_0,MONOID_0,WAYBEL_0,YELLOW_1,YELLOW_2,WAYBEL_1,YELLOW_3,WAYBEL_2,WAYBEL_3,WAYBEL_8,WAYBEL10,WAYBEL14,WAYBEL17,YELLOW_9,WAYBEL18,WAYBEL19,WAYBEL24,WAYBEL25,YELLOW16,PARTFUN1,RELSET_1,CKB4,CKB5,CKB6,CKB7;
constructors DOMAIN_1,TOLER_1,FUNCT_6,TOPS_2,CANTOR_1,MONOID_0,QUANTAL1,ORDERS_3,WAYBEL_6,WAYBEL_8,WAYBEL17,YELLOW_9,WAYBEL18,WAYBEL24,YELLOW16,WAYBEL26,RELSET_1,WAYBEL20,CKB1,CKB2,CKB3;
requirements BOOLE,SUBSET;
begin
theorem
Th1: (for X,Y,Z,D being set holds (D c= ( Funcs (X,( Funcs (Y,Z) )) ) implies (ex F being (ManySortedSet of D) st (F is  uncurrying & ( rng F ) c= ( Funcs ([: X,Y :],Z) )))))
proof
let X being set;
let Y being set;
let Z being set;
let D being set;
assume that
A1: D c= ( Funcs (X,( Funcs (Y,Z) )) );
per cases ;
suppose D is  empty;

then reconsider F = ( {} ) as (ManySortedSet of D) by PARTFUN1:def 2,RELAT_1:38,RELAT_1:def 18;
take F;
thus F is  uncurrying;
thus thesis by RELAT_1:38,XBOOLE_1:2;
end;
suppose D is non  empty;

then reconsider E = D as non  empty  functional set by A1;
deffunc F(Function) = ( uncurry $1 );
consider F being (ManySortedSet of E) such that A2: (for d being (Element of E) holds ( F . d ) = F(d)) from PBOOLE:sch 5;
reconsider F1 = F as (ManySortedSet of D);
take F1;
thus F1 is  uncurrying
proof
hereby
let x being set;
assume x in ( dom F1 );
then x in D by PARTFUN1:def 2;
then consider x1 being Function such that A3: x1 = x and ( dom x1 ) = X and A4: ( rng x1 ) c= ( Funcs (Y,Z) ) by A1,FUNCT_2:def 2;
x1 is  Function-yielding
proof
let a being set;
assume a in ( dom x1 );
then ( x1 . a ) in ( rng x1 ) by FUNCT_1:def 3;
hence thesis by A4;
end;
hence x is  Function-yielding  Function-yielding Function by A3;
end;
let f being Function;
assume f in ( dom F1 );
then reconsider d = f as (Element of E) by PARTFUN1:def 2;
thus ( F1 . f ) = ( F . d )
.= ( uncurry f ) by A2;
end;

thus ( rng F1 ) c= ( Funcs ([: X,Y :],Z) )
proof
let y being set;
assume y in ( rng F1 );
then consider x being set such that A5: x in ( dom F1 ) and A6: y = ( F1 . x ) by FUNCT_1:def 3;
reconsider d = x as (Element of E) by A5,PARTFUN1:def 2;
A7: d in ( Funcs (X,( Funcs (Y,Z) )) ) by A1,TARSKI:def 3;
y = ( uncurry d ) by A2,A6;
hence thesis by A7,FUNCT_6:11;
end;

end;
end;
