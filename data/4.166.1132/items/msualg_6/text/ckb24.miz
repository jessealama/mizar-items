environ
vocabularies NUMBERS,XBOOLE_0,MSUALG_1,SUBSET_1,FUNCT_1,PBOOLE,MEMBER_1,RELAT_1,STRUCT_0,CARD_3,MARGREL1,PARTFUN1,MOD_4,MSUALG_3,NAT_1,FUNCT_4,RLTOPSP1,TARSKI,REWRITE1,FUNCOP_1,FINSEQ_1,ARYTM_3,FUNCT_7,CARD_1,XXREAL_0,ORDINAL4,MSUALG_4,CIRCUIT2,MCART_1,ZFMISC_1,EQREL_1,RELAT_2,MSUALG_5,MSUALG_6;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,NAT_1,MCART_1,STRUCT_0,RELAT_1,RELAT_2,RELSET_1,EQREL_1,REWRITE1,FUNCT_1,PBOOLE,PARTFUN1,FUNCT_2,FINSEQ_1,CARD_3,FUNCOP_1,MSUALG_1,MSUALG_3,MSUALG_4,MSUALG_5,FUNCT_7,XXREAL_0,CKB1,CKB2,CKB5,CKB9,CKB13,CKB14,CKB18,CKB20;
definitions TARSKI,RELAT_1,REWRITE1,FUNCT_1,PBOOLE,MSUALG_3,MSUALG_4,FUNCT_7,FUNCOP_1,CKB5,CKB9,CKB14,CKB18,CKB20;
theorems TARSKI,NAT_1,MCART_1,ZFMISC_1,RELAT_1,RELSET_1,EQREL_1,FUNCT_1,FINSEQ_1,FINSEQ_3,FUNCT_2,CARD_3,FUNCT_7,REWRITE1,PBOOLE,PRALG_2,MSUALG_3,MSUALG_4,MSUALG_5,FINSEQ_5,XBOOLE_0,PARTFUN1,RELAT_2,ORDERS_1,XREAL_1,XXREAL_0,ORDINAL1,CKB3,CKB4,CKB5,CKB6,CKB9,CKB10,CKB11,CKB12,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23;
schemes NAT_1,RECDEF_1,RELSET_1,FUNCT_1,FINSEQ_1,CARD_3,CLASSES1,PBOOLE,PUA2MSS1;
registrations XBOOLE_0,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCOP_1,XXREAL_0,XREAL_0,NAT_1,FINSEQ_1,PBOOLE,REWRITE1,FUNCT_7,STRUCT_0,MSUALG_1,MSUALG_3,MSUALG_4,MSUALG_5,ORDINAL1,CARD_1,RELSET_1,CKB7,CKB8;
constructors XXREAL_0,NAT_1,NAT_D,REWRITE1,FUNCT_7,MSUALG_3,MSUALG_5,RELSET_1,CKB2,CKB5,CKB9,CKB13,CKB14,CKB18,CKB20;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve S for non  empty non  void ManySortedSign;
reserve A for MSAlgebra over S;
theorem
Th14: (for S being non  empty non  void ManySortedSign holds (for A being  feasible MSAlgebra over S holds (for s1,s2 being (SortSymbol of S) holds (for q being (RedSequence of ( TranslationRel S )) holds (for p being  Function-yielding FinSequence holds ((((( len q ) = ( ( len p ) + 1 ) & s1 = ( q . 1 )) & s2 = ( q . ( len q ) )) & (for i being (Element of ( NAT )) holds (for f being Function holds (for s1,s2 being (SortSymbol of S) holds ((((i in ( dom p ) & f = ( p . i )) & s1 = ( q . i )) & s2 = ( q . ( i + 1 ) )) implies f is_e.translation_of A,s1,s2))))) implies (( compose (p,( (the Sorts of A) . s1 )) ) is (Function of ( (the Sorts of A) . s1 ),( (the Sorts of A) . s2 )) & (p <> ( {} ) implies (( (the Sorts of A) . s1 ) <> ( {} ) & ( (the Sorts of A) . s2 ) <> ( {} ))))))))))
proof
let S being non  empty non  void ManySortedSign;
let A being  feasible MSAlgebra over S;
let s1 being (SortSymbol of S);
let s2 being (SortSymbol of S);
let q being (RedSequence of ( TranslationRel S ));
let p being  Function-yielding FinSequence;
assume that
A1: ( len q ) = ( ( len p ) + 1 )
and
A2: s1 = ( q . 1 )
and
A3: s2 = ( q . ( len q ) )
and
A4: (for i being (Element of ( NAT )) holds (for f being Function holds (for s1,s2 being (SortSymbol of S) holds ((((i in ( dom p ) & f = ( p . i )) & s1 = ( q . i )) & s2 = ( q . ( i + 1 ) )) implies f is_e.translation_of A,s1,s2))));
per cases ;
suppose A5: p = ( {} );

then A6: ( len p ) = ( 0 );
( compose (p,( (the Sorts of A) . s1 )) ) = ( id ( (the Sorts of A) . s1 ) ) by A5,FUNCT_7:39;
hence thesis by A1,A2,A3,A6;
end;
suppose p <> ( {} );

then A7: ( rng p ) <> ( {} );
then A8: 1 in ( dom p ) by FINSEQ_3:32;
then A9: ( 1 + 1 ) in ( dom q ) by A1,FUNCT_7:22;
1 in ( dom q ) by A1,A8,FUNCT_7:22;
then [ ( q . 1 ),( q . ( 1 + 1 ) ) ] in ( TranslationRel S ) by A9,REWRITE1:def 2;
then reconsider q1 = ( q . 1 ),q2 = ( q . ( 1 + 1 ) ) as (SortSymbol of S) by ZFMISC_1:87;
deffunc F(set) = ( (the Sorts of A) . ( q . $1 ) );
reconsider f = ( p . 1 ) as Function;
A10: ( dom q ) = ( Seg ( len q ) ) by FINSEQ_1:def 3;
consider pp being FinSequence such that A11: ( len pp ) = ( len q ) and A12: (for i being Nat holds (i in ( dom pp ) implies ( pp . i ) = F(i))) from FINSEQ_1:sch 2;
defpred P[ (Element of ( NAT )) ]
 means
($1 in ( dom pp ) implies (not ( pp . $1 ) is  empty));
A13: ( dom pp ) = ( Seg ( len q ) ) by A11,FINSEQ_1:def 3;
f is_e.translation_of A,q1,q2 by A4,A7,FINSEQ_3:32;
then A14: ( (the Sorts of A) . q1 ) <> ( {} ) by CKB21:1;
A15: (for i being (Element of ( NAT )) holds (P[ i ] implies P[ ( i + 1 ) ]))
proof
let i being (Element of ( NAT ));
assume that
(i in ( dom pp ) implies (not ( pp . i ) is  empty))
and
A16: ( i + 1 ) in ( dom pp );
A17: i <= ( i + 1 ) by NAT_1:11;
( i + 1 ) <= ( len pp ) by A16,FINSEQ_3:25;
then A18: i <= ( len pp ) by A17,XXREAL_0:2;
per cases ;
suppose i = ( 0 );

hence thesis by A14,A12,A16;
end;
suppose i > ( 0 );

then i >= ( ( 0 ) + 1 ) by NAT_1:13;
then A19: i in ( dom pp ) by A18,FINSEQ_3:25;
then [ ( q . i ),( q . ( i + 1 ) ) ] in ( TranslationRel S ) by A10,A13,A16,REWRITE1:def 2;
then reconsider s1 = ( q . i ),s2 = ( q . ( i + 1 ) ) as (SortSymbol of S) by ZFMISC_1:87;
reconsider f = ( p . i ) as Function;
i in ( dom p ) by A1,A11,A16,A19,FUNCT_7:22;
then A20: f is_e.translation_of A,s1,s2 by A4;
( pp . ( i + 1 ) ) = ( (the Sorts of A) . s2 ) by A12,A16;
hence thesis by A20,CKB21:1;
end;
end;
A21: P[ ( 0 ) ] by FINSEQ_3:25;
A22: (for i being (Element of ( NAT )) holds P[ i ]) from NAT_1:sch 1(A21,A15);
A23: pp is  non-empty
proof
let x being set;
assume x in ( dom pp );
hence thesis by A22;
end;
A24: ( dom pp ) = ( Seg ( len q ) ) by A11,FINSEQ_1:def 3;
reconsider pp as non  empty  non-empty FinSequence by A11,A23;
A25: ( dom p ) = ( Seg ( len p ) ) by FINSEQ_1:def 3;
p is (FuncSequence of pp)
proof
thus ( ( len p ) + 1 ) = ( len pp ) by A1,A11;
let j being (Element of ( NAT ));
reconsider f = ( p . j ) as Function;
assume A26: j in ( dom p );
then A27: j >= 1 by A25,FINSEQ_1:1;
then A28: ( j + 1 ) >= 1 by NAT_1:13;
A29: j <= ( len p ) by A25,A26,FINSEQ_1:1;
then j <= ( len q ) by A1,NAT_1:13;
then A30: j in ( Seg ( len q ) ) by A27,FINSEQ_1:1;
( j + 1 ) <= ( len q ) by A1,A29,XREAL_1:6;
then A31: ( j + 1 ) in ( Seg ( len q ) ) by A28,FINSEQ_1:1;
then [ ( q . j ),( q . ( j + 1 ) ) ] in ( TranslationRel S ) by A10,A30,REWRITE1:def 2;
then reconsider s1 = ( q . j ),s2 = ( q . ( j + 1 ) ) as (SortSymbol of S) by ZFMISC_1:87;
A32: ( pp . ( j + 1 ) ) = ( (the Sorts of A) . s2 ) by A12,A24,A31;
A33: f is_e.translation_of A,s1,s2 by A4,A26;
then A34: ( p . j ) is (Function of ( (the Sorts of A) . s1 ),( (the Sorts of A) . s2 )) by CKB21:1;
A35: ( (the Sorts of A) . s2 ) <> ( {} ) by A33,CKB21:1;
( pp . j ) = ( (the Sorts of A) . s1 ) by A12,A24,A30;
hence thesis by A34,A35,A32,FUNCT_2:8;
end;
then reconsider p9 = p as (FuncSequence of pp);
A36: 1 in ( dom q ) by FINSEQ_5:6;
then A37: ( pp . 1 ) = ( (the Sorts of A) . s1 ) by A2,A10,A12,A13;
then A38: ( dom ( compose (p9,( (the Sorts of A) . s1 )) ) ) = ( (the Sorts of A) . s1 ) by FUNCT_7:67;
A39: ( len q ) in ( dom q ) by FINSEQ_5:6;
then A40: ( pp . ( len pp ) ) = ( (the Sorts of A) . s2 ) by A3,A10,A11,A12,A13;
then ( rng ( compose (p9,( (the Sorts of A) . s1 )) ) ) c= ( (the Sorts of A) . s2 ) by A37,FUNCT_7:67;
hence ( compose (p,( (the Sorts of A) . s1 )) ) is (Function of ( (the Sorts of A) . s1 ),( (the Sorts of A) . s2 )) by A10,A11,A13,A39,A40,A38,FUNCT_2:def 1,RELSET_1:4;
thus thesis by A10,A11,A13,A36,A39,A37,A40;
end;
end;
