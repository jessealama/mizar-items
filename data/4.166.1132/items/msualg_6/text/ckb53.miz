environ
vocabularies NUMBERS,XBOOLE_0,MSUALG_1,SUBSET_1,FUNCT_1,PBOOLE,MEMBER_1,RELAT_1,STRUCT_0,CARD_3,MARGREL1,PARTFUN1,MOD_4,MSUALG_3,NAT_1,FUNCT_4,RLTOPSP1,TARSKI,REWRITE1,FUNCOP_1,FINSEQ_1,ARYTM_3,FUNCT_7,CARD_1,XXREAL_0,ORDINAL4,MSUALG_4,CIRCUIT2,MCART_1,ZFMISC_1,EQREL_1,RELAT_2,MSUALG_5,MSUALG_6;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,NAT_1,MCART_1,STRUCT_0,RELAT_1,RELAT_2,RELSET_1,EQREL_1,REWRITE1,FUNCT_1,PBOOLE,PARTFUN1,FUNCT_2,FINSEQ_1,CARD_3,FUNCOP_1,MSUALG_1,MSUALG_3,MSUALG_4,MSUALG_5,FUNCT_7,XXREAL_0,CKB1,CKB2,CKB5,CKB9,CKB13,CKB14,CKB18,CKB20,CKB25,CKB39,CKB40,CKB41,CKB49;
definitions TARSKI,RELAT_1,REWRITE1,FUNCT_1,PBOOLE,MSUALG_3,MSUALG_4,FUNCT_7,FUNCOP_1,CKB5,CKB9,CKB14,CKB18,CKB20,CKB25,CKB39,CKB40,CKB41,CKB49;
theorems TARSKI,NAT_1,MCART_1,ZFMISC_1,RELAT_1,RELSET_1,EQREL_1,FUNCT_1,FINSEQ_1,FINSEQ_3,FUNCT_2,CARD_3,FUNCT_7,REWRITE1,PBOOLE,PRALG_2,MSUALG_3,MSUALG_4,MSUALG_5,FINSEQ_5,XBOOLE_0,PARTFUN1,RELAT_2,ORDERS_1,XREAL_1,XXREAL_0,ORDINAL1,CKB3,CKB4,CKB5,CKB6,CKB9,CKB10,CKB11,CKB12,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB49;
schemes NAT_1,RECDEF_1,RELSET_1,FUNCT_1,FINSEQ_1,CARD_3,CLASSES1,PBOOLE,PUA2MSS1,CKB32,CKB47,CKB48,CKB52;
registrations XBOOLE_0,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCOP_1,XXREAL_0,XREAL_0,NAT_1,FINSEQ_1,PBOOLE,REWRITE1,FUNCT_7,STRUCT_0,MSUALG_1,MSUALG_3,MSUALG_4,MSUALG_5,ORDINAL1,CARD_1,RELSET_1,CKB7,CKB8,CKB44,CKB45,CKB46,CKB50,CKB51;
constructors XXREAL_0,NAT_1,NAT_D,REWRITE1,FUNCT_7,MSUALG_3,MSUALG_5,RELSET_1,CKB2,CKB5,CKB9,CKB13,CKB14,CKB18,CKB20,CKB25,CKB39,CKB40,CKB41,CKB49;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve S for non  empty non  void ManySortedSign;
reserve A for  non-empty MSAlgebra over S;
reserve R for (ManySortedRelation of (the Sorts of A));
Lm1:now
let S being non  empty non  void ManySortedSign;
let A being  non-empty MSAlgebra over S;
let R being (ManySortedRelation of A);
let Q being (ManySortedRelation of A);
defpred R[ (ManySortedRelation of A) ]
 means
$1 is  invariant;
defpred P[ Function,(SortSymbol of S),(SortSymbol of S) ]
 means
(( TranslationRel S ) reduces $2,$3 & $1 is (Translation of A,$2,$3));
assume that
A1: (for s being (SortSymbol of S) holds (for a,b being (Element of A,s) holds ([ a,b ] in ( Q . s ) iff (ex s9 being (SortSymbol of S) st (ex f being (Function of ( (the Sorts of A) . s9 ),( (the Sorts of A) . s )) st (ex x,y being (Element of A,s9) st (((P[ f,s9,s ] & [ x,y ] in ( R . s9 )) & a = ( f . x )) & b = ( f . y ))))))));
A2: (for s being (SortSymbol of S) holds P[ ( id ( (the Sorts of A) . s ) ),s,s ]) by CKB27:1,REWRITE1:12;
A3:now
let R being (ManySortedRelation of A);
thus (R[ R ] implies (for s1,s2 being (SortSymbol of S) holds (for f being (Function of ( (the Sorts of A) . s1 ),( (the Sorts of A) . s2 )) holds (P[ f,s1,s2 ] implies (for a,b being set holds ([ a,b ] in ( R . s1 ) implies [ ( f . a ),( f . b ) ] in ( R . s2 ))))))) by CKB43:1;
assume (for s1,s2 being (SortSymbol of S) holds (for f being (Function of ( (the Sorts of A) . s1 ),( (the Sorts of A) . s2 )) holds (P[ f,s1,s2 ] implies (for a,b being set holds ([ a,b ] in ( R . s1 ) implies [ ( f . a ),( f . b ) ] in ( R . s2 ))))));
then (for s1,s2 being (SortSymbol of S) holds (( TranslationRel S ) reduces s1,s2 implies (for f being (Translation of A,s1,s2) holds (for a,b being set holds ([ a,b ] in ( R . s1 ) implies [ ( f . a ),( f . b ) ] in ( R . s2 ))))));
hence R[ R ] by CKB43:1;
end;
A4: (for s1,s2,s3 being (SortSymbol of S) holds (for f1 being (Function of ( (the Sorts of A) . s1 ),( (the Sorts of A) . s2 )) holds (for f2 being (Function of ( (the Sorts of A) . s2 ),( (the Sorts of A) . s3 )) holds ((P[ f1,s1,s2 ] & P[ f2,s2,s3 ]) implies P[ ( f2 * f1 ),s1,s3 ])))) by CKB29:1,REWRITE1:16;
thus ((R[ Q ] & R c= Q) & (for P being (ManySortedRelation of A) holds ((R[ P ] & R c= P) implies Q c= P))) from CKB52:sch 1(A3,A4,A2,A1);
end;
definition
let S being non  empty non  void ManySortedSign;
let A being  non-empty MSAlgebra over S;
let R being (ManySortedRelation of (the Sorts of A));
func InvCl R ->  invariant (ManySortedRelation of A) means 
:Def11: (R c= it & (for Q being  invariant (ManySortedRelation of A) holds (R c= Q implies it c= Q)));
uniqueness
proof
let Q1 being  invariant (ManySortedRelation of A);
let Q2 being  invariant (ManySortedRelation of A);
assume that
A1: R c= Q1
and
A2: (for Q being  invariant (ManySortedRelation of A) holds (R c= Q implies Q1 c= Q))
and
A3: R c= Q2
and
A4: (for Q being  invariant (ManySortedRelation of A) holds (R c= Q implies Q2 c= Q));
thus (Q1 c= Q2 & Q2 c= Q1) by A1,A2,A3,A4;
end;
existence
proof
defpred P[ Function,(SortSymbol of S),(SortSymbol of S) ]
 means
(( TranslationRel S ) reduces $2,$3 & $1 is (Translation of A,$2,$3));
defpred Z[ (SortSymbol of S),set,set ]
 means
(ex s9 being (SortSymbol of S) st (ex f being (Function of ( (the Sorts of A) . s9 ),( (the Sorts of A) . $1 )) st (ex x,y being (Element of A,s9) st (((P[ f,s9,$1 ] & [ x,y ] in ( R . s9 )) & $2 = ( f . x )) & $3 = ( f . y )))));
consider Q being (ManySortedRelation of (the Sorts of A)) such that A5: (for s being (SortSymbol of S) holds (for a,b being (Element of A,s) holds ([ a,b ] in ( Q . s ) iff Z[ s,a,b ]))) from CKB47:sch 1;
reconsider Q as (ManySortedRelation of A);
reconsider Q as  invariant (ManySortedRelation of A) by A5,Lm1;
take Q;
thus thesis by A5,Lm1;
end;
end;
