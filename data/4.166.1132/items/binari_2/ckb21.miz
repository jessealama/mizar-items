environ
vocabularies NUMBERS,NAT_1,XBOOLE_0,FINSEQ_2,MARGREL1,SUBSET_1,FINSEQ_1,PARTFUN1,RELAT_1,FUNCT_1,FUNCOP_1,XBOOLEAN,ARYTM_3,INT_1,BINARITH,ARYTM_1,POWER,ORDINAL4,CARD_1,TARSKI,BINOP_2,SETWISEO,BINARI_2;
notations TARSKI,XBOOLE_0,SUBSET_1,XCMPLX_0,NUMBERS,FUNCT_1,NAT_1,NAT_D,INT_1,PARTFUN1,BINOP_1,SETWOP_2,SERIES_1,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,BINOP_2,XBOOLEAN,MARGREL1,BINARITH,CKB2,CKB3,CKB4,CKB5,CKB6;
definitions XBOOLEAN,CKB2,CKB3,CKB4,CKB5,CKB6;
theorems BINARITH,FINSEQ_1,FINSEQ_2,FINSEQ_4,FUNCOP_1,POWER,NAT_1,FINSOP_1,BINOP_2,XBOOLEAN,PARTFUN1,XREAL_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
schemes FINSEQ_2,NAT_1;
registrations ORDINAL1,RELSET_1,XREAL_0,NAT_1,INT_1,BINOP_2,XBOOLEAN,MARGREL1,XBOOLE_0,FINSEQ_2,CARD_1,FINSEQ_1;
constructors PARTFUN1,BINOP_1,SETWISEO,XXREAL_0,NAT_1,INT_1,FINSEQ_4,FINSOP_1,SERIES_1,BINARITH,BINOP_2,NAT_D,RELSET_1,CKB2,CKB3,CKB4,CKB5,CKB6;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve m for non empty Nat;
reserve d for (Element of ( BOOLEAN ));
theorem
Th17: (for z being (Tuple of m,( BOOLEAN )) holds (for d being (Element of ( BOOLEAN )) holds ( ( Intval ( Neg2 ( z ^ <* d *> ) ) ) + ( IFEQ (( Int_add_ovfl (( 'not' ( z ^ <* d *> ) ),( Bin1 ( m + 1 ) )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) = ( - ( Intval ( z ^ <* d *> ) ) )))
proof
let z being (Tuple of m,( BOOLEAN ));
let d;
set OV = ( IFEQ (( Int_add_ovfl (( ( 'not' z ) ^ <* ( 'not' d ) *> ),( ( Bin1 m ) ^ <* ( FALSE ) *> )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) );
set UD = ( IFEQ (( Int_add_udfl (( ( 'not' z ) ^ <* ( 'not' d ) *> ),( ( Bin1 m ) ^ <* ( FALSE ) *> )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) );
A1: ( Int_add_udfl (( ( 'not' z ) ^ <* ( 'not' d ) *> ),( ( Bin1 m ) ^ <* ( FALSE ) *> )) ) = ( ( ( ( ( 'not' z ) ^ <* ( 'not' d ) *> ) /. ( m + 1 ) ) '&' ( FALSE ) ) '&' ( 'not' ( ( carry (( ( 'not' z ) ^ <* ( 'not' d ) *> ),( ( Bin1 m ) ^ <* ( FALSE ) *> )) ) /. ( m + 1 ) ) ) ) by BINARITH:2
.= ( FALSE );
A2: ( ( Intval ( Neg2 ( z ^ <* d *> ) ) ) + ( IFEQ (( Int_add_ovfl (( 'not' ( z ^ <* d *> ) ),( Bin1 ( m + 1 ) )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) = ( ( Intval ( ( ( 'not' z ) ^ <* ( 'not' d ) *> ) + ( Bin1 ( m + 1 ) ) ) ) + ( IFEQ (( Int_add_ovfl (( 'not' ( z ^ <* d *> ) ),( Bin1 ( m + 1 ) )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) by CKB15:1
.= ( ( Intval ( ( ( 'not' z ) ^ <* ( 'not' d ) *> ) + ( Bin1 ( m + 1 ) ) ) ) + ( IFEQ (( Int_add_ovfl (( ( 'not' z ) ^ <* ( 'not' d ) *> ),( Bin1 ( m + 1 ) )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) by CKB15:1
.= ( ( Intval ( ( ( 'not' z ) ^ <* ( 'not' d ) *> ) + ( ( Bin1 m ) ^ <* ( FALSE ) *> ) ) ) + ( IFEQ (( Int_add_ovfl (( ( 'not' z ) ^ <* ( 'not' d ) *> ),( Bin1 ( m + 1 ) )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) by CKB13:1
.= ( ( Intval ( ( ( 'not' z ) ^ <* ( 'not' d ) *> ) + ( ( Bin1 m ) ^ <* ( FALSE ) *> ) ) ) + OV ) by CKB13:1
.= ( ( ( ( ( Intval ( ( 'not' z ) ^ <* ( 'not' d ) *> ) ) + ( Intval ( ( Bin1 m ) ^ <* ( FALSE ) *> ) ) ) - OV ) + UD ) + OV ) by CKB18:1
.= ( ( ( ( ( Intval ( ( 'not' z ) ^ <* ( 'not' d ) *> ) ) + 1 ) - OV ) + UD ) + OV ) by CKB14:1
.= ( ( ( ( Intval ( ( 'not' z ) ^ <* ( 'not' d ) *> ) ) + 1 ) + UD ) - ( OV - OV ) )
.= ( ( ( Intval ( ( 'not' z ) ^ <* ( 'not' d ) *> ) ) + 1 ) + ( 0 ) ) by A1,FUNCOP_1:def 8
.= ( ( ( Absval ( 'not' z ) ) - ( IFEQ (( 'not' d ),( FALSE ),( 0 ),( 2 to_power m )) ) ) + 1 ) by CKB16:1
.= ( ( ( ( ( - ( Absval z ) ) + ( 2 to_power m ) ) - 1 ) - ( IFEQ (( 'not' d ),( FALSE ),( 0 ),( 2 to_power m )) ) ) + 1 ) by CKB19:1
.= ( ( ( - ( Absval z ) ) + ( 2 to_power m ) ) - ( IFEQ (( 'not' d ),( FALSE ),( 0 ),( 2 to_power m )) ) );
A3: ( - ( Intval ( z ^ <* d *> ) ) ) = ( - ( ( Absval z ) - ( IFEQ (d,( FALSE ),( 0 ),( 2 to_power m )) ) ) ) by CKB16:1
.= ( ( - ( Absval z ) ) + ( IFEQ (d,( FALSE ),( 0 ),( 2 to_power m )) ) );
per cases  by XBOOLEAN:def 3;
suppose A4: d = ( FALSE );

then ( ( Intval ( Neg2 ( z ^ <* d *> ) ) ) + ( IFEQ (( Int_add_ovfl (( 'not' ( z ^ <* d *> ) ),( Bin1 ( m + 1 ) )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) = ( ( ( - ( Absval z ) ) + ( 2 to_power m ) ) - ( 2 to_power m ) ) by A2,FUNCOP_1:def 8
.= ( ( - ( Absval z ) ) + ( 0 ) );
hence thesis by A3,A4,FUNCOP_1:def 8;
end;
suppose A5: d = ( TRUE );

then ( ( Intval ( Neg2 ( z ^ <* d *> ) ) ) + ( IFEQ (( Int_add_ovfl (( 'not' ( z ^ <* d *> ) ),( Bin1 ( m + 1 ) )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) = ( ( ( - ( Absval z ) ) + ( 2 to_power m ) ) - ( 0 ) ) by A2,FUNCOP_1:def 8
.= ( ( - ( Absval z ) ) + ( 2 to_power m ) );
hence thesis by A3,A5,FUNCOP_1:def 8;
end;
end;
