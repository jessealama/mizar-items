environ
vocabularies NUMBERS,NAT_1,XBOOLE_0,FINSEQ_2,MARGREL1,SUBSET_1,FINSEQ_1,PARTFUN1,RELAT_1,FUNCT_1,FUNCOP_1,XBOOLEAN,ARYTM_3,INT_1,BINARITH,ARYTM_1,POWER,ORDINAL4,CARD_1,TARSKI,BINOP_2,SETWISEO,BINARI_2;
notations TARSKI,XBOOLE_0,SUBSET_1,XCMPLX_0,NUMBERS,FUNCT_1,NAT_1,NAT_D,INT_1,PARTFUN1,BINOP_1,SETWOP_2,SERIES_1,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,BINOP_2,XBOOLEAN,MARGREL1,BINARITH,CKB2,CKB3,CKB4,CKB5,CKB6,CKB23;
definitions XBOOLEAN,CKB2,CKB3,CKB4,CKB5,CKB6,CKB23;
theorems BINARITH,FINSEQ_1,FINSEQ_2,FINSEQ_4,FUNCOP_1,POWER,NAT_1,FINSOP_1,BINOP_2,XBOOLEAN,PARTFUN1,XREAL_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25;
schemes FINSEQ_2,NAT_1;
registrations ORDINAL1,RELSET_1,XREAL_0,NAT_1,INT_1,BINOP_2,XBOOLEAN,MARGREL1,XBOOLE_0,FINSEQ_2,CARD_1,FINSEQ_1;
constructors PARTFUN1,BINOP_1,SETWISEO,XXREAL_0,NAT_1,INT_1,FINSEQ_4,FINSOP_1,SERIES_1,BINARITH,BINOP_2,NAT_D,RELSET_1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB23;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve m for non empty Nat;
reserve d1 for (Element of ( BOOLEAN ));
reserve d2 for (Element of ( BOOLEAN ));
theorem
(for z1,z2 being (Tuple of m,( BOOLEAN )) holds (for d1,d2 being (Element of ( BOOLEAN )) holds ( ( ( ( Intval ( ( z1 ^ <* d1 *> ) - ( z2 ^ <* d2 *> ) ) ) + ( IFEQ (( Int_add_ovfl (( z1 ^ <* d1 *> ),( Neg2 ( z2 ^ <* d2 *> ) )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) - ( IFEQ (( Int_add_udfl (( z1 ^ <* d1 *> ),( Neg2 ( z2 ^ <* d2 *> ) )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) + ( IFEQ (( Int_add_ovfl (( 'not' ( z2 ^ <* d2 *> ) ),( Bin1 ( m + 1 ) )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) = ( ( Intval ( z1 ^ <* d1 *> ) ) - ( Intval ( z2 ^ <* d2 *> ) ) )))
proof
let z1 being (Tuple of m,( BOOLEAN )),z2 being (Tuple of m,( BOOLEAN ));
let d1;
let d2;
set OV1 = ( IFEQ (( Int_add_ovfl (( z1 ^ <* d1 *> ),( Neg2 ( z2 ^ <* d2 *> ) )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) );
set UD1 = ( IFEQ (( Int_add_udfl (( z1 ^ <* d1 *> ),( Neg2 ( z2 ^ <* d2 *> ) )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) );
set OV2 = ( IFEQ (( Int_add_ovfl (( 'not' ( z2 ^ <* d2 *> ) ),( Bin1 ( m + 1 ) )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) );
set NEG = ( ( Neg2 z2 ) ^ <* ( ( 'not' d2 ) 'xor' ( add_ovfl (( 'not' z2 ),( Bin1 m )) ) ) *> );
thus ( ( ( ( Intval ( ( z1 ^ <* d1 *> ) - ( z2 ^ <* d2 *> ) ) ) + OV1 ) - UD1 ) + OV2 ) = ( ( ( ( Intval ( ( z1 ^ <* d1 *> ) + ( Neg2 ( z2 ^ <* d2 *> ) ) ) ) + OV1 ) - UD1 ) + OV2 ) by CKB24:1
.= ( ( ( ( Intval ( ( z1 ^ <* d1 *> ) + NEG ) ) + OV1 ) - UD1 ) + OV2 ) by CKB20:1
.= ( ( ( ( Intval ( ( z1 ^ <* d1 *> ) + NEG ) ) + ( IFEQ (( Int_add_ovfl (( z1 ^ <* d1 *> ),NEG) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) - UD1 ) + OV2 ) by CKB20:1
.= ( ( ( ( Intval ( ( z1 ^ <* d1 *> ) + NEG ) ) + ( IFEQ (( Int_add_ovfl (( z1 ^ <* d1 *> ),NEG) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) - ( IFEQ (( Int_add_udfl (( z1 ^ <* d1 *> ),NEG) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) + OV2 ) by CKB20:1
.= ( ( ( Intval ( z1 ^ <* d1 *> ) ) + ( Intval NEG ) ) + OV2 ) by CKB17:1
.= ( ( Intval ( z1 ^ <* d1 *> ) ) + ( ( Intval NEG ) + OV2 ) )
.= ( ( Intval ( z1 ^ <* d1 *> ) ) + ( ( Intval ( Neg2 ( z2 ^ <* d2 *> ) ) ) + OV2 ) ) by CKB20:1
.= ( ( Intval ( z1 ^ <* d1 *> ) ) + ( - ( Intval ( z2 ^ <* d2 *> ) ) ) ) by CKB21:1
.= ( ( Intval ( z1 ^ <* d1 *> ) ) - ( Intval ( z2 ^ <* d2 *> ) ) );
end;
