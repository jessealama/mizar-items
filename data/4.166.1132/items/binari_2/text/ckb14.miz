environ
vocabularies NUMBERS,NAT_1,XBOOLE_0,FINSEQ_2,MARGREL1,SUBSET_1,FINSEQ_1,PARTFUN1,RELAT_1,FUNCT_1,FUNCOP_1,XBOOLEAN,ARYTM_3,INT_1,BINARITH,ARYTM_1,POWER,ORDINAL4,CARD_1,TARSKI,BINOP_2,SETWISEO,BINARI_2;
notations TARSKI,XBOOLE_0,SUBSET_1,XCMPLX_0,NUMBERS,FUNCT_1,NAT_1,NAT_D,INT_1,PARTFUN1,BINOP_1,SETWOP_2,SERIES_1,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,BINOP_2,XBOOLEAN,MARGREL1,BINARITH,CKB2,CKB3,CKB4,CKB5,CKB6;
definitions XBOOLEAN,CKB2,CKB3,CKB4,CKB5,CKB6;
theorems BINARITH,FINSEQ_1,FINSEQ_2,FINSEQ_4,FUNCOP_1,POWER,NAT_1,FINSOP_1,BINOP_2,XBOOLEAN,PARTFUN1,XREAL_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13;
schemes FINSEQ_2,NAT_1;
registrations ORDINAL1,RELSET_1,XREAL_0,NAT_1,INT_1,BINOP_2,XBOOLEAN,MARGREL1,XBOOLE_0,FINSEQ_2,CARD_1,FINSEQ_1;
constructors PARTFUN1,BINOP_1,SETWISEO,XXREAL_0,NAT_1,INT_1,FINSEQ_4,FINSOP_1,SERIES_1,BINARITH,BINOP_2,NAT_D,RELSET_1,CKB2,CKB3,CKB4,CKB5,CKB6;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve m for non  empty Nat;
theorem
Th10: (for m holds ( Intval ( ( Bin1 m ) ^ <* ( FALSE ) *> ) ) = 1)
proof
defpred P[ non  empty Nat ]
 means
( Intval ( ( Bin1 $1 ) ^ <* ( FALSE ) *> ) ) = 1;
A1: P[ 1 ]
proof
consider k being (Element of ( BOOLEAN )) such that A2: ( Bin1 1 ) = <* k *> by FINSEQ_2:97;
A3: ( ( Bin1 1 ) /. 1 ) = k by A2,FINSEQ_4:16;
1 in ( Seg 1 ) by FINSEQ_1:3;
then ( Bin1 1 ) = <* ( TRUE ) *> by A2,A3,CKB11:1;
hence thesis by CKB8:1;
end;
A4:now
let m being non  empty Nat;
assume that
A5: P[ m ];
( ( ( Bin1 m ) ^ <* ( FALSE ) *> ) /. ( m + 1 ) ) = ( FALSE ) by BINARITH:2;
then A6: ( Absval ( ( Bin1 m ) ^ <* ( FALSE ) *> ) ) = 1 by A5,CKB4:def 1;
( ( ( Bin1 ( m + 1 ) ) ^ <* ( FALSE ) *> ) /. ( ( m + 1 ) + 1 ) ) = ( FALSE ) by BINARITH:2;
then ( Intval ( ( Bin1 ( m + 1 ) ) ^ <* ( FALSE ) *> ) ) = ( Absval ( ( Bin1 ( m + 1 ) ) ^ <* ( FALSE ) *> ) ) by CKB4:def 1
.= ( Absval ( ( ( Bin1 m ) ^ <* ( FALSE ) *> ) ^ <* ( FALSE ) *> ) ) by CKB13:1
.= ( ( Absval ( ( Bin1 m ) ^ <* ( FALSE ) *> ) ) + ( IFEQ (( FALSE ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) by BINARITH:20
.= ( 1 + ( 0 ) ) by A6,FUNCOP_1:def 8
.= 1;
hence P[ ( m + 1 ) ];
end;
thus (for m holds P[ m ]) from NAT_1:sch 10(A1,A4);
end;
