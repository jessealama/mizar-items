environ
vocabularies NUMBERS,NAT_1,XBOOLE_0,FINSEQ_2,MARGREL1,SUBSET_1,FINSEQ_1,PARTFUN1,RELAT_1,FUNCT_1,FUNCOP_1,XBOOLEAN,ARYTM_3,INT_1,BINARITH,ARYTM_1,POWER,ORDINAL4,CARD_1,TARSKI,BINOP_2,SETWISEO,BINARI_2;
notations TARSKI,XBOOLE_0,SUBSET_1,XCMPLX_0,NUMBERS,FUNCT_1,NAT_1,NAT_D,INT_1,PARTFUN1,BINOP_1,SETWOP_2,SERIES_1,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,BINOP_2,XBOOLEAN,MARGREL1,BINARITH,CKB2,CKB3,CKB4,CKB5,CKB6;
definitions XBOOLEAN,CKB2,CKB3,CKB4,CKB5,CKB6;
theorems BINARITH,FINSEQ_1,FINSEQ_2,FINSEQ_4,FUNCOP_1,POWER,NAT_1,FINSOP_1,BINOP_2,XBOOLEAN,PARTFUN1,XREAL_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16;
schemes FINSEQ_2,NAT_1;
registrations ORDINAL1,RELSET_1,XREAL_0,NAT_1,INT_1,BINOP_2,XBOOLEAN,MARGREL1,XBOOLE_0,FINSEQ_2,CARD_1,FINSEQ_1;
constructors PARTFUN1,BINOP_1,SETWISEO,XXREAL_0,NAT_1,INT_1,FINSEQ_4,FINSOP_1,SERIES_1,BINARITH,BINOP_2,NAT_D,RELSET_1,CKB2,CKB3,CKB4,CKB5,CKB6;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve m for non empty Nat;
theorem
Th13: (for z1,z2 being (Tuple of m,( BOOLEAN )) holds (for d1,d2 being (Element of ( BOOLEAN )) holds ( ( ( Intval ( ( z1 ^ <* d1 *> ) + ( z2 ^ <* d2 *> ) ) ) + ( IFEQ (( Int_add_ovfl (( z1 ^ <* d1 *> ),( z2 ^ <* d2 *> )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) - ( IFEQ (( Int_add_udfl (( z1 ^ <* d1 *> ),( z2 ^ <* d2 *> )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) = ( ( Intval ( z1 ^ <* d1 *> ) ) + ( Intval ( z2 ^ <* d2 *> ) ) )))
proof
let z1 being (Tuple of m,( BOOLEAN )),z2 being (Tuple of m,( BOOLEAN ));
let d1 being (Element of ( BOOLEAN )),d2 being (Element of ( BOOLEAN ));
set f = ( FALSE );
set t = ( TRUE );
A1: ( Absval ( z1 + z2 ) ) = ( ( ( Absval z1 ) + ( Absval z2 ) ) - ( IFEQ (( add_ovfl (z1,z2) ),( FALSE ),( 0 ),( 2 to_power m )) ) )
proof
set siki1 = ( Absval ( z1 + z2 ) );
set siki2 = ( IFEQ (( add_ovfl (z1,z2) ),( FALSE ),( 0 ),( 2 to_power m )) );
( ( siki1 + siki2 ) - siki2 ) = siki1;
hence thesis by BINARITH:21;
end;
A2: ( Intval ( ( z1 ^ <* d1 *> ) + ( z2 ^ <* d2 *> ) ) ) = ( Intval ( ( z1 + z2 ) ^ <* ( ( d1 'xor' d2 ) 'xor' ( add_ovfl (z1,z2) ) ) *> ) ) by BINARITH:19
.= ( ( ( ( Absval z1 ) + ( Absval z2 ) ) - ( IFEQ (( add_ovfl (z1,z2) ),( FALSE ),( 0 ),( 2 to_power m )) ) ) - ( IFEQ (( ( d1 'xor' d2 ) 'xor' ( add_ovfl (z1,z2) ) ),( FALSE ),( 0 ),( 2 to_power m )) ) ) by A1,CKB16:1;
A3: ( Int_add_ovfl (( z1 ^ <* d1 *> ),( z2 ^ <* d2 *> )) ) = ( ( ( 'not' d1 ) '&' ( 'not' ( ( z2 ^ <* d2 *> ) /. ( m + 1 ) ) ) ) '&' ( ( carry (( z1 ^ <* d1 *> ),( z2 ^ <* d2 *> )) ) /. ( m + 1 ) ) ) by BINARITH:2
.= ( ( ( 'not' d1 ) '&' ( 'not' d2 ) ) '&' ( ( carry (( z1 ^ <* d1 *> ),( z2 ^ <* d2 *> )) ) /. ( m + 1 ) ) ) by BINARITH:2
.= ( ( ( 'not' d1 ) '&' ( 'not' d2 ) ) '&' ( add_ovfl (z1,z2) ) ) by BINARITH:18;
A4: ( Int_add_udfl (( z1 ^ <* d1 *> ),( z2 ^ <* d2 *> )) ) = ( ( d1 '&' ( ( z2 ^ <* d2 *> ) /. ( m + 1 ) ) ) '&' ( 'not' ( ( carry (( z1 ^ <* d1 *> ),( z2 ^ <* d2 *> )) ) /. ( m + 1 ) ) ) ) by BINARITH:2
.= ( ( d1 '&' d2 ) '&' ( 'not' ( ( carry (( z1 ^ <* d1 *> ),( z2 ^ <* d2 *> )) ) /. ( m + 1 ) ) ) ) by BINARITH:2
.= ( ( d1 '&' d2 ) '&' ( 'not' ( add_ovfl (z1,z2) ) ) ) by BINARITH:18;
A5: ( Intval ( z1 ^ <* d1 *> ) ) = ( ( Absval z1 ) - ( IFEQ (d1,( FALSE ),( 0 ),( 2 to_power m )) ) ) by CKB16:1;
A6: ( Intval ( z2 ^ <* d2 *> ) ) = ( ( Absval z2 ) - ( IFEQ (d2,( FALSE ),( 0 ),( 2 to_power m )) ) ) by CKB16:1;
per cases  by XBOOLEAN:def 3;
suppose A7: (d1 = f & d2 = f);

then A8: ( ( Absval z1 ) - ( IFEQ (d1,( FALSE ),( 0 ),( 2 to_power m )) ) ) = ( ( Absval z1 ) - ( 0 ) ) by FUNCOP_1:def 8
.= ( Absval z1 );
A9: ( ( Absval z2 ) - ( IFEQ (d2,( FALSE ),( 0 ),( 2 to_power m )) ) ) = ( ( Absval z2 ) - ( 0 ) ) by A7,FUNCOP_1:def 8
.= ( Absval z2 );
A10: ( IFEQ (( ( d1 '&' d2 ) '&' ( 'not' ( add_ovfl (z1,z2) ) ) ),f,( 0 ),( 2 to_power ( m + 1 ) )) ) = ( 0 ) by A7,FUNCOP_1:def 8;
thus thesis
proof
per cases  by XBOOLEAN:def 3;
suppose ( add_ovfl (z1,z2) ) = f;

hence thesis by A2,A3,A4,A6,A7,A8,CKB16:1;
end;
suppose A11: ( add_ovfl (z1,z2) ) = t;

then ( IFEQ (( add_ovfl (z1,z2) ),( FALSE ),( 0 ),( 2 to_power m )) ) = ( 2 to_power m ) by FUNCOP_1:def 8;
then ( ( ( Intval ( ( z1 ^ <* d1 *> ) + ( z2 ^ <* d2 *> ) ) ) + ( IFEQ (( Int_add_ovfl (( z1 ^ <* d1 *> ),( z2 ^ <* d2 *> )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) - ( IFEQ (( Int_add_udfl (( z1 ^ <* d1 *> ),( z2 ^ <* d2 *> )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) = ( ( ( ( Absval z1 ) + ( Absval z2 ) ) - ( 2 * ( 2 to_power m ) ) ) + ( 2 to_power ( m + 1 ) ) ) by A2,A3,A4,A7,A10,A11,FUNCOP_1:def 8
.= ( ( ( ( Absval z1 ) + ( Absval z2 ) ) - ( ( 2 to_power 1 ) * ( 2 to_power m ) ) ) + ( 2 to_power ( m + 1 ) ) ) by POWER:25
.= ( ( ( ( Absval z1 ) + ( Absval z2 ) ) - ( 2 to_power ( m + 1 ) ) ) + ( 2 to_power ( m + 1 ) ) ) by POWER:27
.= ( ( Absval z1 ) + ( Absval z2 ) );
hence thesis by A6,A8,A9,CKB16:1;
end;
end;

end;
suppose A12: (d1 = t & d2 = f);

then A13: ( ( Absval z2 ) - ( IFEQ (d2,( FALSE ),( 0 ),( 2 to_power m )) ) ) = ( ( Absval z2 ) - ( 0 ) ) by FUNCOP_1:def 8
.= ( Absval z2 );
thus thesis
proof
per cases  by XBOOLEAN:def 3;
suppose A14: ( add_ovfl (z1,z2) ) = f;

then ( IFEQ (( add_ovfl (z1,z2) ),( FALSE ),( 0 ),( 2 to_power m )) ) = ( 0 ) by FUNCOP_1:def 8;
hence thesis by A2,A3,A4,A5,A6,A12,A13,A14;
end;
suppose ( add_ovfl (z1,z2) ) = t;

hence thesis by A2,A3,A4,A5,A6,A12;
end;
end;

end;
suppose A15: (d1 = f & d2 = t);

then A16: ( ( Absval z1 ) - ( IFEQ (d1,( FALSE ),( 0 ),( 2 to_power m )) ) ) = ( ( Absval z1 ) - ( 0 ) ) by FUNCOP_1:def 8
.= ( Absval z1 );
thus thesis
proof
per cases  by XBOOLEAN:def 3;
suppose A17: ( add_ovfl (z1,z2) ) = f;

then ( IFEQ (( add_ovfl (z1,z2) ),( FALSE ),( 0 ),( 2 to_power m )) ) = ( 0 ) by FUNCOP_1:def 8;
hence thesis by A2,A3,A4,A5,A6,A15,A16,A17;
end;
suppose ( add_ovfl (z1,z2) ) = t;

hence thesis by A2,A3,A4,A5,A6,A15;
end;
end;

end;
suppose A18: (d1 = t & d2 = t);

then A19: ( ( Absval z2 ) - ( IFEQ (d2,( FALSE ),( 0 ),( 2 to_power m )) ) ) = ( ( Absval z2 ) - ( 2 to_power m ) ) by FUNCOP_1:def 8;
A20: ( ( Intval ( z1 ^ <* d1 *> ) ) + ( Intval ( z2 ^ <* d2 *> ) ) ) = ( ( ( Absval z1 ) - ( IFEQ (d1,( FALSE ),( 0 ),( 2 to_power m )) ) ) + ( Intval ( z2 ^ <* d2 *> ) ) ) by A5
.= ( ( ( Absval z1 ) + ( Absval z2 ) ) - ( 2 * ( 2 to_power m ) ) ) by A6,A18,A19
.= ( ( ( Absval z1 ) + ( Absval z2 ) ) - ( ( 2 to_power 1 ) * ( 2 to_power m ) ) ) by POWER:25
.= ( ( ( Absval z1 ) + ( Absval z2 ) ) - ( 2 to_power ( m + 1 ) ) ) by POWER:27;
A21: ( IFEQ (( ( ( 'not' d1 ) '&' ( 'not' d2 ) ) '&' ( add_ovfl (z1,z2) ) ),f,( 0 ),( 2 to_power ( m + 1 ) )) ) = ( 0 ) by A18,FUNCOP_1:def 8;
thus thesis
proof
per cases  by XBOOLEAN:def 3;
suppose A22: ( add_ovfl (z1,z2) ) = f;

then ( IFEQ (( add_ovfl (z1,z2) ),( FALSE ),( 0 ),( 2 to_power m )) ) = ( 0 ) by FUNCOP_1:def 8;
hence thesis by A2,A3,A4,A18,A20,A21,A22,FUNCOP_1:def 8;
end;
suppose A23: ( add_ovfl (z1,z2) ) = t;

then ( IFEQ (( add_ovfl (z1,z2) ),( FALSE ),( 0 ),( 2 to_power m )) ) = ( 2 to_power m ) by FUNCOP_1:def 8;
then ( ( ( Intval ( ( z1 ^ <* d1 *> ) + ( z2 ^ <* d2 *> ) ) ) + ( IFEQ (( Int_add_ovfl (( z1 ^ <* d1 *> ),( z2 ^ <* d2 *> )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) - ( IFEQ (( Int_add_udfl (( z1 ^ <* d1 *> ),( z2 ^ <* d2 *> )) ),( FALSE ),( 0 ),( 2 to_power ( m + 1 ) )) ) ) = ( ( ( Absval z1 ) + ( Absval z2 ) ) - ( 2 * ( 2 to_power m ) ) ) by A2,A3,A4,A18,A23
.= ( ( ( Absval z1 ) + ( Absval z2 ) ) - ( ( 2 to_power 1 ) * ( 2 to_power m ) ) ) by POWER:25
.= ( ( ( Absval z1 ) + ( Absval z2 ) ) - ( 2 to_power ( m + 1 ) ) ) by POWER:27;
hence thesis by A20;
end;
end;

end;
end;
