environ
vocabularies NUMBERS,NAT_1,XBOOLE_0,FINSEQ_2,MARGREL1,SUBSET_1,FINSEQ_1,PARTFUN1,RELAT_1,FUNCT_1,FUNCOP_1,XBOOLEAN,ARYTM_3,INT_1,BINARITH,ARYTM_1,POWER,ORDINAL4,CARD_1,TARSKI,BINOP_2,SETWISEO,BINARI_2;
notations TARSKI,XBOOLE_0,SUBSET_1,XCMPLX_0,NUMBERS,FUNCT_1,NAT_1,NAT_D,INT_1,PARTFUN1,BINOP_1,SETWOP_2,SERIES_1,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,BINOP_2,XBOOLEAN,MARGREL1,BINARITH,CKB2,CKB3,CKB4,CKB5,CKB6;
definitions XBOOLEAN,CKB2,CKB3,CKB4,CKB5,CKB6;
theorems BINARITH,FINSEQ_1,FINSEQ_2,FINSEQ_4,FUNCOP_1,POWER,NAT_1,FINSOP_1,BINOP_2,XBOOLEAN,PARTFUN1,XREAL_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18;
schemes FINSEQ_2,NAT_1;
registrations ORDINAL1,RELSET_1,XREAL_0,NAT_1,INT_1,BINOP_2,XBOOLEAN,MARGREL1,XBOOLE_0,FINSEQ_2,CARD_1,FINSEQ_1;
constructors PARTFUN1,BINOP_1,SETWISEO,XXREAL_0,NAT_1,INT_1,FINSEQ_4,FINSOP_1,SERIES_1,BINARITH,BINOP_2,NAT_D,RELSET_1,CKB2,CKB3,CKB4,CKB5,CKB6;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve m for non empty Nat;
theorem
Th15: (for m holds (for x being (Tuple of m,( BOOLEAN )) holds ( Absval ( 'not' x ) ) = ( ( ( - ( Absval x ) ) + ( 2 to_power m ) ) - 1 )))
proof
defpred P[ Nat ]
 means
(for x being (Tuple of $1,( BOOLEAN )) holds ( Absval ( 'not' x ) ) = ( ( ( - ( Absval x ) ) + ( 2 to_power $1 ) ) - 1 ));
A1: P[ 1 ]
proof
let x being (Tuple of 1,( BOOLEAN ));
per cases  by BINARITH:14;
suppose A2: x = <* ( FALSE ) *>;

then A3: ( x /. 1 ) = ( FALSE ) by FINSEQ_4:16;
consider k being (Element of ( BOOLEAN )) such that A4: ( 'not' x ) = <* k *> by FINSEQ_2:97;
A5: ( ( 'not' x ) /. 1 ) = k by A4,FINSEQ_4:16;
1 in ( Seg 1 ) by FINSEQ_1:3;
then A6: ( ( 'not' x ) /. 1 ) = ( 'not' ( FALSE ) ) by A3,BINARITH:def 1
.= ( TRUE );
( ( ( - ( Absval x ) ) + ( 2 to_power 1 ) ) - 1 ) = ( ( ( - ( 0 ) ) + ( 2 to_power 1 ) ) - 1 ) by A2,BINARITH:15
.= ( ( ( 0 ) + 2 ) - 1 ) by POWER:25
.= 1;
hence thesis by A4,A5,A6,BINARITH:16;
end;
suppose A7: x = <* ( TRUE ) *>;

then A8: ( x /. 1 ) = ( TRUE ) by FINSEQ_4:16;
consider k being (Element of ( BOOLEAN )) such that A9: ( 'not' x ) = <* k *> by FINSEQ_2:97;
A10: ( ( 'not' x ) /. 1 ) = k by A9,FINSEQ_4:16;
1 in ( Seg 1 ) by FINSEQ_1:3;
then A11: ( ( 'not' x ) /. 1 ) = ( 'not' ( TRUE ) ) by A8,BINARITH:def 1
.= ( FALSE );
( ( ( - ( Absval x ) ) + ( 2 to_power 1 ) ) - 1 ) = ( ( ( - 1 ) + ( 2 to_power 1 ) ) - 1 ) by A7,BINARITH:16
.= ( ( ( - 1 ) + 2 ) - 1 ) by POWER:25
.= ( 0 );
hence thesis by A9,A10,A11,BINARITH:15;
end;
end;
A12:now
let m;
assume A13: P[ m ];
now
let x being (Tuple of ( m + 1 ),( BOOLEAN ));
consider t being (Element of ( m -tuples_on ( BOOLEAN ) )),d being (Element of ( BOOLEAN )) such that A14: x = ( t ^ <* d *> ) by FINSEQ_2:117;
A15: ( Absval ( 'not' x ) ) = ( Absval ( ( 'not' t ) ^ <* ( 'not' d ) *> ) ) by A14,CKB15:1
.= ( ( Absval ( 'not' t ) ) + ( IFEQ (( 'not' d ),( FALSE ),( 0 ),( 2 to_power m )) ) ) by BINARITH:20
.= ( ( ( ( - ( Absval t ) ) + ( 2 to_power m ) ) - 1 ) + ( IFEQ (( 'not' d ),( FALSE ),( 0 ),( 2 to_power m )) ) ) by A13;
A16: ( ( ( - ( Absval x ) ) + ( 2 to_power ( m + 1 ) ) ) - 1 ) = ( ( ( - ( ( Absval t ) + ( IFEQ (d,( FALSE ),( 0 ),( 2 to_power m )) ) ) ) + ( 2 to_power ( m + 1 ) ) ) - 1 ) by A14,BINARITH:20;
thus ( Absval ( 'not' x ) ) = ( ( ( - ( Absval x ) ) + ( 2 to_power ( m + 1 ) ) ) - 1 )
proof
per cases  by XBOOLEAN:def 3;
suppose A17: d = ( FALSE );

then A18: ( Absval ( 'not' x ) ) = ( ( ( ( - ( Absval t ) ) + ( 2 to_power m ) ) - 1 ) + ( 2 to_power m ) ) by A15,FUNCOP_1:def 8
.= ( ( ( - ( Absval t ) ) + ( 2 * ( 2 to_power m ) ) ) - 1 )
.= ( ( ( - ( Absval t ) ) + ( ( 2 to_power 1 ) * ( 2 to_power m ) ) ) - 1 ) by POWER:25
.= ( ( ( - ( Absval t ) ) + ( 2 to_power ( m + 1 ) ) ) - 1 ) by POWER:27;
( ( ( - ( Absval x ) ) + ( 2 to_power ( m + 1 ) ) ) - 1 ) = ( ( ( - ( ( Absval t ) + ( 0 ) ) ) + ( 2 to_power ( m + 1 ) ) ) - 1 ) by A16,A17,FUNCOP_1:def 8
.= ( ( ( - ( Absval t ) ) + ( 2 to_power ( m + 1 ) ) ) - 1 );
hence thesis by A18;
end;
suppose A19: d = ( TRUE );

then A20: ( Absval ( 'not' x ) ) = ( ( ( ( - ( Absval t ) ) + ( 2 to_power m ) ) - 1 ) + ( 0 ) ) by A15,FUNCOP_1:def 8
.= ( ( ( - ( Absval t ) ) + ( 2 to_power m ) ) - 1 );
( ( ( - ( Absval x ) ) + ( 2 to_power ( m + 1 ) ) ) - 1 ) = ( ( ( - ( ( Absval t ) + ( 2 to_power m ) ) ) + ( 2 to_power ( m + 1 ) ) ) - 1 ) by A16,A19,FUNCOP_1:def 8
.= ( ( ( ( - ( Absval t ) ) - ( 2 to_power m ) ) + ( ( 2 to_power 1 ) * ( 2 to_power m ) ) ) - 1 ) by POWER:27
.= ( ( ( ( - ( Absval t ) ) - ( 2 to_power m ) ) + ( 2 * ( 2 to_power m ) ) ) - 1 ) by POWER:25
.= ( ( ( - ( Absval t ) ) + ( 2 to_power m ) ) - 1 );
hence thesis by A20;
end;
end;

end;
hence P[ ( m + 1 ) ];
end;
thus (for m holds P[ m ]) from NAT_1:sch 10(A1,A12);
end;
