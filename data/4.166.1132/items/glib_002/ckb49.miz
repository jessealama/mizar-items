environ
vocabularies NUMBERS,FINSET_1,ARYTM_3,CARD_1,SUBSET_1,XBOOLE_0,GLIB_000,RELAT_2,GLIB_001,TREES_1,ZFMISC_1,FUNCT_1,FINSEQ_1,GRAPH_1,ABIAN,XXREAL_0,RELAT_1,RCOMP_1,FUNCOP_1,ARYTM_1,WAYBEL_0,TARSKI,PBOOLE,SETFAM_1,ORDINAL1,NAT_1,GLIB_002;
notations TARSKI,XBOOLE_0,ZFMISC_1,CARD_1,NUMBERS,SUBSET_1,SETFAM_1,DOMAIN_1,XCMPLX_0,ABIAN,XXREAL_0,RELAT_1,FUNCT_1,PBOOLE,FUNCT_2,FINSEQ_1,FINSET_1,NAT_1,FUNCOP_1,GLIB_000,GLIB_001,CKB2,CKB3,CKB4,CKB11,CKB16,CKB17,CKB22,CKB26,CKB27,CKB29,CKB30,CKB31,CKB32;
definitions TARSKI,FUNCOP_1,CKB2,CKB3,CKB4,CKB11,CKB16,CKB17,CKB22,CKB27,CKB29,CKB31,CKB32;
theorems CARD_1,CARD_2,FUNCOP_1,FINSEQ_1,FINSEQ_3,FUNCT_1,FUNCT_2,GLIB_000,GLIB_001,ABIAN,INT_1,JORDAN12,NAT_1,ORDINAL1,PENCIL_1,TARSKI,XBOOLE_0,XBOOLE_1,XCMPLX_1,ZFMISC_1,XREAL_1,XXREAL_0,RELSET_1,CKB1,CKB2,CKB3,CKB4,CKB11,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB27,CKB29,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48;
schemes NAT_1,SUBSET_1,GLIB_000;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,XREAL_0,INT_1,CARD_1,GLIB_000,ABIAN,GLIB_001,FUNCT_2,PARTFUN1,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13,CKB14,CKB15,CKB23,CKB24,CKB25,CKB28;
constructors DOMAIN_1,CARD_FIL,GLIB_001,VALUED_1,XXREAL_2,WELLORD2,RELSET_1,CKB2,CKB3,CKB4,CKB11,CKB16,CKB17,CKB22,CKB27,CKB29,CKB30,CKB31;
requirements ARITHM,BOOLE,NUMERALS,REAL,SUBSET;
begin
theorem
Lm21: (for G being non trivial  finite  connected _Graph holds (ex v1,v2 being (Vertex of G) st ((v1 <> v2 & (not v1 is  cut-vertex)) & (not v2 is  cut-vertex))))
proof
let G being non trivial  finite  connected _Graph;
defpred P[ Nat ]
 means
(for G being non trivial  finite  connected _Graph holds (( G .order() ) = $1 implies (ex v1,v2 being (Vertex of G) st ((v1 <> v2 & (not v1 is  cut-vertex)) & (not v2 is  cut-vertex)))));
now
let k being Nat;
assume A1: (for n being Nat holds (n < k implies P[ n ]));
now
let G being non trivial  finite  connected _Graph;
assume that
A2: ( G .order() ) = k;
A3: ( G .numComponents() ) = 1 by CKB46:1;
now
per cases ;
suppose A4: (not (ex v being (Vertex of G) st v is  cut-vertex));

consider v1 being (Vertex of G),v2 being (Vertex of G) such that A5: v1 <> v2 by GLIB_000:21;
take v1;
take v2;
thus v1 <> v2 by A5;
thus ((not v1 is  cut-vertex) & (not v2 is  cut-vertex)) by A4;
end;
suppose (ex cv being (Vertex of G) st cv is  cut-vertex);

then consider cv being (Vertex of G) such that A6: cv is  cut-vertex;
set G2 = the (removeVertex of G,cv);
1 < ( G2 .numComponents() ) by A3,A6,CKB32:def 1;
then ( 1 + 1 ) <= ( G2 .numComponents() ) by NAT_1:13;
then ( card 2 ) <= ( card ( G2 .componentSet() ) ) by CARD_1:def 2;
then ( card 2 ) c= ( card ( G2 .componentSet() ) ) by NAT_1:39;
then 2 c= ( card ( G2 .componentSet() ) ) by CARD_1:def 2;
then consider C1 being set,C2 being set such that A7: (C1 in ( G2 .componentSet() ) & C2 in ( G2 .componentSet() )) and A8: C1 <> C2 by PENCIL_1:2;
reconsider C1,C2 as (Element of ( G2 .componentSet() )) by A7;
set CC1 = the (inducedSubgraph of G2,C1);
set CC2 = the (inducedSubgraph of G2,C2);
A9: ( the_Vertices_of G2 ) = ( ( the_Vertices_of G ) \ { cv } ) by GLIB_000:47;
( G .edgesBetween ( ( the_Vertices_of G ) \ { cv } ) ) = ( ( the_Edges_of G ) \ ( G .edgesInOut { cv } ) ) by GLIB_000:35;
then ( G .edgesBetween ( ( the_Vertices_of G ) \ { cv } ) ) = ( ( the_Edges_of G ) \ ( cv .edgesInOut() ) ) by GLIB_000:def 40;
then A10: ( the_Edges_of G2 ) = ( ( the_Edges_of G ) \ ( cv .edgesInOut() ) ) by GLIB_000:47;
A11: ( ( G2 .order() ) + 1 ) = k by A2,GLIB_000:48;
A12:now
let C being (Component of G2);
now
set x = the (Vertex of C);
assume A13: (for a being (Vertex of C) holds (not (ex e being set st e Joins cv,a,G)));
( the_Vertices_of C ) c= ( the_Vertices_of G2 );
then reconsider x9 = x as (Vertex of G2) by TARSKI:def 3;
( the_Vertices_of G2 ) c= ( the_Vertices_of G );
then reconsider x99 = x9 as (Vertex of G) by TARSKI:def 3;
consider W being (Walk of G) such that A14: W is_Walk_from cv,x99 by CKB2:def 1;
set P = the (Path of W);
A15: P is_Walk_from cv,x99 by A14,GLIB_001:160;
then A16: ( P .first() ) = cv by GLIB_001:def 23;
set P2 = ( P .cut (( ( 2 * 1 ) + 1 ),( len P )) );
A17: 1 <= ( len P ) by ABIAN:12;
A18: ( P .last() ) = x by A15,GLIB_001:def 23;
then A19: ( P . ( len P ) ) = x by GLIB_001:def 7;
(not x9 in { cv }) by A9,XBOOLE_0:def 5;
then A20: x <> cv by TARSKI:def 1;
then A21: P is non trivial by A16,A18,GLIB_001:127;
then A22: ( ( 2 * 1 ) + 1 ) <= ( len P ) by GLIB_001:125;
then P2 is_Walk_from ( P . 3 ),( P . ( len P ) ) by GLIB_001:37;
then A23: P2 is_Walk_from ( P . 3 ),x by A18,GLIB_001:def 7;
A24: ( P . ( ( 2 * ( 0 ) ) + 1 ) ) = cv by A16,GLIB_001:def 6;
now
assume cv in ( P2 .vertices() );
then consider n being  odd (Element of ( NAT )) such that A25: n <= ( len P2 ) and A26: ( P2 . n ) = cv by GLIB_001:87;
A27: 1 <= n by ABIAN:12;
then A28: ( 1 + ( 0 ) ) < ( n + 2 ) by XREAL_1:8;
A29: n in ( dom P2 ) by A25,A27,FINSEQ_3:25;
then ( ( 3 + n ) - 1 ) in ( dom P ) by A22,GLIB_001:47;
then A30: ( 2 + n ) <= ( len P ) by FINSEQ_3:25;
( P . ( ( 3 + n ) - 1 ) ) = cv by A22,A26,A29,GLIB_001:47;
hence contradiction by A20,A24,A19,A30,A28,GLIB_001:def 28;
end;
then reconsider P2 as (Walk of G2) by GLIB_001:171;
P2 is_Walk_from ( P . 3 ),x by A23,GLIB_001:19;
then ( P2 .reverse() ) is_Walk_from x,( P . 3 ) by GLIB_001:23;
then A31: ( P . 3 ) in ( G2 .reachableFrom x9 ) by CKB16:def 1;
( len P ) <> 1 by A21,GLIB_001:125;
then ( ( 2 * ( 0 ) ) + 1 ) < ( len P ) by A17,XXREAL_0:1;
then ( P . ( 1 + 1 ) ) Joins ( P . 1 ),( P . ( 1 + 2 ) ),G by GLIB_001:def 3;
then A32: ( P . 2 ) Joins cv,( P . 3 ),G by A16,GLIB_001:def 6;
( the_Vertices_of C ) = ( G2 .reachableFrom x9 ) by CKB44:1;
hence contradiction by A13,A32,A31;
end;
then consider a being (Vertex of C),e being set such that A33: e Joins cv,a,G;
A34: e in ( the_Edges_of G ) by A33,GLIB_000:def 13;
now
per cases ;
suppose C is  trivial;

then consider v99 being (Vertex of C) such that A35: ( the_Vertices_of C ) = { v99 } by GLIB_000:22;
( the_Vertices_of C ) c= ( the_Vertices_of G2 );
then reconsider v9 = v99 as (Vertex of G2) by TARSKI:def 3;
reconsider v = v9 as (Vertex of G) by GLIB_000:42;
take v;
thus v in ( the_Vertices_of C );
(not v9 in { cv }) by A9,XBOOLE_0:def 5;
then A36: v9 <> cv by TARSKI:def 1;
A37: { v9 } = ( G2 .reachableFrom v9 ) by A35,CKB44:1;
now
set G3 = the (removeVertex of G,v);
A38:now
let e being set,z being set;
assume A39: e Joins v,z,G;
then A40: e in ( the_Edges_of G ) by GLIB_000:def 13;
now
assume that
A41: z <> v
and
A42: z <> cv;
(not e in ( cv .edgesInOut() )) by A36,A39,A42,GLIB_000:65;
then e in ( the_Edges_of G2 ) by A10,A40,XBOOLE_0:def 5;
then e Joins v,z,G2 by A39,GLIB_000:73;
then z in ( G2 .reachableFrom v9 ) by CKB18:1,CKB19:1;
hence contradiction by A37,A41,TARSKI:def 1;
end;
hence (z = v or z = cv);
end;
now
let x being (Vertex of G3),y being (Vertex of G3);
now
per cases ;
suppose A43: x = y;

set W = ( G3 .walkOf x );
take W;
thus W is_Walk_from x,y by A43,GLIB_001:13;
end;
suppose A44: x <> y;

reconsider x9 = x,y9 = y as (Vertex of G) by GLIB_000:42;
consider W being (Walk of G) such that A45: W is_Walk_from x9,y9 by CKB2:def 1;
set P = the (Path of W);
A46: P is_Walk_from x9,y9 by A45,GLIB_001:160;
A47: ( the_Vertices_of G3 ) = ( ( the_Vertices_of G ) \ { v } ) by GLIB_000:47;
then (not x in { v }) by XBOOLE_0:def 5;
then x <> v by TARSKI:def 1;
then A48: v <> ( P . 1 ) by A46,GLIB_001:17;
(not y in { v }) by A47,XBOOLE_0:def 5;
then y <> v by TARSKI:def 1;
then A49: v <> ( P . ( len P ) ) by A46,GLIB_001:17;
now
assume v in ( P .vertices() );
then consider n being  odd (Element of ( NAT )) such that A50: n <= ( len P ) and A51: ( P . n ) = v by GLIB_001:87;
1 <= n by ABIAN:12;
then 1 < n by A48,A51,XXREAL_0:1;
then ( 1 + 1 ) <= n by NAT_1:13;
then reconsider n2 = ( n - ( 2 * 1 ) ) as  odd (Element of ( NAT )) by INT_1:5;
A52:now
A53: n2 < ( n - ( 0 ) ) by XREAL_1:15;
assume ( P . n2 ) = v;
hence contradiction by A48,A50,A51,A53,GLIB_001:def 28;
end;
set e1 = ( P . ( n2 + 1 ) );
set e2 = ( P . ( n + 1 ) );
( n - 2 ) < ( ( len P ) - ( 0 ) ) by A50,XREAL_1:15;
then e1 Joins ( P . n2 ),( P . ( n2 + 2 ) ),G by GLIB_001:def 3;
then A54: ( P . n2 ) = cv by A38,A51,A52,GLIB_000:14;
A55: n < ( len P ) by A49,A50,A51,XXREAL_0:1;
then A56: ( n + 2 ) <= ( len P ) by GLIB_001:1;
A57:now
A58: ( n + ( 0 ) ) < ( n + 2 ) by XREAL_1:8;
assume ( P . ( n + 2 ) ) = v;
hence contradiction by A48,A51,A56,A58,GLIB_001:def 28;
end;
n2 < ( n - ( 0 ) ) by XREAL_1:15;
then A59: ( n2 + ( 0 ) ) < ( n + 2 ) by XREAL_1:8;
e2 Joins v,( P . ( n + 2 ) ),G by A51,A55,GLIB_001:def 3;
then A60: ( P . ( n + 2 ) ) = cv by A38,A57;
then cv = ( P . 1 ) by A54,A56,A59,GLIB_001:def 28;
then A61: cv = x by A46,GLIB_001:17;
cv = ( P . ( len P ) ) by A54,A56,A60,A59,GLIB_001:def 28;
hence contradiction by A44,A46,A61,GLIB_001:17;
end;
then reconsider P as (Walk of G3) by GLIB_001:171;
take P;
thus P is_Walk_from x,y by A46,GLIB_001:19;
end;
end;
hence (ex P being (Walk of G3) st P is_Walk_from x,y);
end;
then A62: G3 is  connected by CKB2:def 1;
assume v is  cut-vertex;
then 1 < ( G3 .numComponents() ) by A3,CKB32:def 1;
hence contradiction by A62,CKB46:1;
end;
hence (not v is  cut-vertex);
end;
suppose C is non trivial;

then reconsider C9 = C as non trivial _Graph;
( ( C .order() ) + ( 0 ) ) < ( ( G2 .order() ) + 1 ) by GLIB_000:75,XREAL_1:8;
then consider v1 being (Vertex of C9),v2 being (Vertex of C9) such that A63: v1 <> v2 and A64: (not v1 is  cut-vertex) and A65: (not v2 is  cut-vertex) by A1,A11;
set C9R1 = the (removeVertex of C9,v1);
A66: C9R1 is  connected by A64,CKB48:1;
set C9R2 = the (removeVertex of C9,v2);
A67: ( the_Vertices_of C9R1 ) = ( ( the_Vertices_of C9 ) \ { v1 } ) by GLIB_000:47;
v2 in ( the_Vertices_of G2 ) by GLIB_000:42;
then (not v2 in { cv }) by A9,XBOOLE_0:def 5;
then A68: v2 <> cv by TARSKI:def 1;
A69: ( the_Vertices_of C9R2 ) = ( ( the_Vertices_of C9 ) \ { v2 } ) by GLIB_000:47;
v1 in ( the_Vertices_of G2 ) by GLIB_000:42;
then (not v1 in { cv }) by A9,XBOOLE_0:def 5;
then A70: v1 <> cv by TARSKI:def 1;
A71: C9R2 is  connected by A65,CKB48:1;
now
per cases ;
suppose A72: (not v1 in ( cv .allNeighbors() ));

reconsider v9 = v1 as (Vertex of G2) by GLIB_000:42;
reconsider v = v9 as (Vertex of G) by GLIB_000:42;
take v;
thus v in ( the_Vertices_of C );
set G3 = the (removeVertex of G,v);
A73: ( the_Vertices_of G3 ) = ( ( the_Vertices_of G ) \ { v } ) by GLIB_000:47;
(not cv in { v }) by A70,TARSKI:def 1;
then reconsider cv9 = cv as (Vertex of G3) by A73,XBOOLE_0:def 5;
A74: v1 <> a by A33,A72,GLIB_000:71;
A75: ( the_Vertices_of C ) = ( G2 .reachableFrom v9 ) by CKB44:1;
now
let y being (Vertex of G3);
now
per cases ;
suppose y = cv;

then ( G3 .walkOf y ) is_Walk_from cv9,y by GLIB_001:13;
hence (ex W being (Walk of G3) st W is_Walk_from cv9,y);
end;
suppose A76: y <> cv;

now
per cases ;
suppose A77: y in ( the_Vertices_of C );

(not a in { v1 }) by A74,TARSKI:def 1;
then A78: a in ( the_Vertices_of C9R1 ) by A67,XBOOLE_0:def 5;
(not y in { v1 }) by A73,XBOOLE_0:def 5;
then y in ( the_Vertices_of C9R1 ) by A67,A77,XBOOLE_0:def 5;
then consider W being (Walk of C9R1) such that A79: W is_Walk_from y,a by A66,A78,CKB2:def 1;
A80: (( W . 1 ) = y & ( W . ( len W ) ) = a) by A79,GLIB_001:17;
A81:now
assume v in ( W .vertices() );
then (not v in { v1 }) by A67,XBOOLE_0:def 5;
hence contradiction by TARSKI:def 1;
end;
(not e in ( v .edgesInOut() )) by A33,A70,A74,GLIB_000:65;
then e in ( ( the_Edges_of G ) \ ( v .edgesInOut() ) ) by A34,XBOOLE_0:def 5;
then e in ( ( the_Edges_of G ) \ ( G .edgesInOut { v } ) ) by GLIB_000:def 40;
then e in ( G .edgesBetween ( ( the_Vertices_of G ) \ { v } ) ) by GLIB_000:35;
then e in ( the_Edges_of G3 ) by GLIB_000:47;
then e Joins cv,a,G3 by A33,GLIB_000:73;
then A82: e Joins a,cv,G3 by GLIB_000:14;
reconsider W as (Walk of C) by GLIB_001:167;
reconsider W as (Walk of G2) by GLIB_001:167;
reconsider W as (Walk of G) by GLIB_001:167;
(not v in ( W .vertices() )) by A81,GLIB_001:98;
then reconsider W as (Walk of G3) by GLIB_001:171;
W is_Walk_from y,a by A80,GLIB_001:17;
then ( W .addEdge e ) is_Walk_from y,cv by A82,GLIB_001:66;
then ( ( W .addEdge e ) .reverse() ) is_Walk_from cv,y by GLIB_001:23;
hence (ex W being (Walk of G3) st W is_Walk_from cv9,y);
end;
suppose A83: (not y in ( the_Vertices_of C ));

reconsider y9 = y as (Vertex of G) by GLIB_000:42;
consider W being (Walk of G) such that A84: W is_Walk_from cv,y9 by CKB2:def 1;
set P = the (Path of W);
A85: P is_Walk_from cv,y9 by A84,GLIB_001:160;
then A86: ( P . ( len P ) ) = y9 by GLIB_001:17;
A87: ( P . 1 ) = cv by A85,GLIB_001:17;
now
assume v in ( P .vertices() );
then consider n being  odd (Element of ( NAT )) such that A88: n <= ( len P ) and A89: ( P . n ) = v by GLIB_001:87;
set P2 = ( P .cut (n,( len P )) );
A90: P2 is_Walk_from v,y9 by A86,A88,A89,GLIB_001:37;
1 <= n by ABIAN:12;
then A91: 1 < n by A70,A87,A89,XXREAL_0:1;
now
assume cv in ( P2 .vertices() );
then consider m being  odd (Element of ( NAT )) such that A92: m <= ( len P2 ) and A93: ( P2 . m ) = cv by GLIB_001:87;
1 <= m by ABIAN:12;
then A94: m in ( dom P2 ) by A92,FINSEQ_3:25;
then A95: ( P . ( ( n + m ) - 1 ) ) = cv by A88,A93,GLIB_001:47;
( 1 + 1 ) < ( n + m ) by A91,ABIAN:12,XREAL_1:8;
then ( ( 1 + 1 ) - 1 ) < ( ( n + m ) - 1 ) by XREAL_1:14;
then A96: ( ( 2 * ( 0 ) ) + 1 ) < ( ( n + m ) - 1 );
A97: ( ( n + m ) - 1 ) in ( dom P ) by A88,A94,GLIB_001:47;
then ( ( n + m ) - 1 ) <= ( len P ) by FINSEQ_3:25;
hence contradiction by A76,A87,A86,A95,A97,A96,GLIB_001:def 28;
end;
then reconsider P2 as (Walk of G2) by GLIB_001:171;
P2 is_Walk_from v,y9 by A90,GLIB_001:19;
hence contradiction by A75,A83,CKB16:def 1;
end;
then reconsider P as (Walk of G3) by GLIB_001:171;
take P;
thus P is_Walk_from cv9,y by A85,GLIB_001:19;
end;
end;
hence (ex W being (Walk of G3) st W is_Walk_from cv9,y);
end;
end;
hence (ex W being (Walk of G3) st W is_Walk_from cv9,y);
end;
then G3 is  connected by CKB34:1;
then ( G3 .numComponents() ) = 1 by CKB46:1;
hence (not v is  cut-vertex) by A3,CKB32:def 1;
end;
suppose A98: (v1 in ( cv .allNeighbors() ) & (not v2 in ( cv .allNeighbors() )));

reconsider v9 = v2 as (Vertex of G2) by GLIB_000:42;
reconsider v = v9 as (Vertex of G) by GLIB_000:42;
take v;
thus v in ( the_Vertices_of C );
set G3 = the (removeVertex of G,v);
A99: ( the_Vertices_of G3 ) = ( ( the_Vertices_of G ) \ { v } ) by GLIB_000:47;
(not cv in { v }) by A68,TARSKI:def 1;
then reconsider cv9 = cv as (Vertex of G3) by A99,XBOOLE_0:def 5;
A100: v2 <> a by A33,A98,GLIB_000:71;
A101: ( the_Vertices_of C ) = ( G2 .reachableFrom v9 ) by CKB44:1;
now
let y being (Vertex of G3);
now
per cases ;
suppose y = cv;

then ( G3 .walkOf y ) is_Walk_from cv9,y by GLIB_001:13;
hence (ex W being (Walk of G3) st W is_Walk_from cv9,y);
end;
suppose A102: y <> cv;

now
per cases ;
suppose A103: y in ( the_Vertices_of C );

(not a in { v2 }) by A100,TARSKI:def 1;
then A104: a in ( the_Vertices_of C9R2 ) by A69,XBOOLE_0:def 5;
(not y in { v2 }) by A99,XBOOLE_0:def 5;
then y in ( the_Vertices_of C9R2 ) by A69,A103,XBOOLE_0:def 5;
then consider W being (Walk of C9R2) such that A105: W is_Walk_from y,a by A71,A104,CKB2:def 1;
A106: (( W . 1 ) = y & ( W . ( len W ) ) = a) by A105,GLIB_001:17;
A107:now
assume v in ( W .vertices() );
then (not v in { v2 }) by A69,XBOOLE_0:def 5;
hence contradiction by TARSKI:def 1;
end;
(not e in ( v .edgesInOut() )) by A33,A68,A100,GLIB_000:65;
then e in ( ( the_Edges_of G ) \ ( v .edgesInOut() ) ) by A34,XBOOLE_0:def 5;
then e in ( ( the_Edges_of G ) \ ( G .edgesInOut { v } ) ) by GLIB_000:def 40;
then e in ( G .edgesBetween ( ( the_Vertices_of G ) \ { v } ) ) by GLIB_000:35;
then e in ( the_Edges_of G3 ) by GLIB_000:47;
then e Joins cv,a,G3 by A33,GLIB_000:73;
then A108: e Joins a,cv,G3 by GLIB_000:14;
reconsider W as (Walk of C) by GLIB_001:167;
reconsider W as (Walk of G2) by GLIB_001:167;
reconsider W as (Walk of G) by GLIB_001:167;
(not v in ( W .vertices() )) by A107,GLIB_001:98;
then reconsider W as (Walk of G3) by GLIB_001:171;
W is_Walk_from y,a by A106,GLIB_001:17;
then ( W .addEdge e ) is_Walk_from y,cv by A108,GLIB_001:66;
then ( ( W .addEdge e ) .reverse() ) is_Walk_from cv,y by GLIB_001:23;
hence (ex W being (Walk of G3) st W is_Walk_from cv9,y);
end;
suppose A109: (not y in ( the_Vertices_of C ));

reconsider y9 = y as (Vertex of G) by GLIB_000:42;
consider W being (Walk of G) such that A110: W is_Walk_from cv,y9 by CKB2:def 1;
set P = the (Path of W);
A111: P is_Walk_from cv,y9 by A110,GLIB_001:160;
then A112: ( P . ( len P ) ) = y9 by GLIB_001:17;
A113: ( P . 1 ) = cv by A111,GLIB_001:17;
now
assume v in ( P .vertices() );
then consider n being  odd (Element of ( NAT )) such that A114: n <= ( len P ) and A115: ( P . n ) = v by GLIB_001:87;
set P2 = ( P .cut (n,( len P )) );
A116: P2 is_Walk_from v,y9 by A112,A114,A115,GLIB_001:37;
1 <= n by ABIAN:12;
then A117: 1 < n by A68,A113,A115,XXREAL_0:1;
now
assume cv in ( P2 .vertices() );
then consider m being  odd (Element of ( NAT )) such that A118: m <= ( len P2 ) and A119: ( P2 . m ) = cv by GLIB_001:87;
1 <= m by ABIAN:12;
then A120: m in ( dom P2 ) by A118,FINSEQ_3:25;
then A121: ( P . ( ( n + m ) - 1 ) ) = cv by A114,A119,GLIB_001:47;
( 1 + 1 ) < ( n + m ) by A117,ABIAN:12,XREAL_1:8;
then ( ( 1 + 1 ) - 1 ) < ( ( n + m ) - 1 ) by XREAL_1:14;
then A122: ( ( 2 * ( 0 ) ) + 1 ) < ( ( n + m ) - 1 );
A123: ( ( n + m ) - 1 ) in ( dom P ) by A114,A120,GLIB_001:47;
then ( ( n + m ) - 1 ) <= ( len P ) by FINSEQ_3:25;
hence contradiction by A102,A113,A112,A121,A123,A122,GLIB_001:def 28;
end;
then reconsider P2 as (Walk of G2) by GLIB_001:171;
P2 is_Walk_from v,y9 by A116,GLIB_001:19;
hence contradiction by A101,A109,CKB16:def 1;
end;
then reconsider P as (Walk of G3) by GLIB_001:171;
take P;
thus P is_Walk_from cv9,y by A111,GLIB_001:19;
end;
end;
hence (ex W being (Walk of G3) st W is_Walk_from cv9,y);
end;
end;
hence (ex W being (Walk of G3) st W is_Walk_from cv9,y);
end;
then G3 is  connected by CKB34:1;
then ( G3 .numComponents() ) = 1 by CKB46:1;
hence (not v is  cut-vertex) by A3,CKB32:def 1;
end;
suppose (v1 in ( cv .allNeighbors() ) & v2 in ( cv .allNeighbors() ));

then consider e being set such that A124: e Joins cv,v2,G by GLIB_000:71;
reconsider v9 = v1 as (Vertex of G2) by GLIB_000:42;
set a = v2;
reconsider v = v9 as (Vertex of G) by GLIB_000:42;
take v;
thus v in ( the_Vertices_of C );
set G3 = the (removeVertex of G,v);
A125: ( the_Vertices_of G3 ) = ( ( the_Vertices_of G ) \ { v } ) by GLIB_000:47;
(not cv in { v }) by A70,TARSKI:def 1;
then reconsider cv9 = cv as (Vertex of G3) by A125,XBOOLE_0:def 5;
A126: ( the_Vertices_of C ) = ( G2 .reachableFrom v9 ) by CKB44:1;
A127: e in ( the_Edges_of G ) by A124,GLIB_000:def 13;
now
let y being (Vertex of G3);
now
per cases ;
suppose y = cv;

then ( G3 .walkOf y ) is_Walk_from cv9,y by GLIB_001:13;
hence (ex W being (Walk of G3) st W is_Walk_from cv9,y);
end;
suppose A128: y <> cv;

now
per cases ;
suppose A129: y in ( the_Vertices_of C );

(not a in { v1 }) by A63,TARSKI:def 1;
then A130: a in ( the_Vertices_of C9R1 ) by A67,XBOOLE_0:def 5;
(not y in { v1 }) by A125,XBOOLE_0:def 5;
then y in ( the_Vertices_of C9R1 ) by A67,A129,XBOOLE_0:def 5;
then consider W being (Walk of C9R1) such that A131: W is_Walk_from y,a by A66,A130,CKB2:def 1;
A132: (( W . 1 ) = y & ( W . ( len W ) ) = a) by A131,GLIB_001:17;
A133:now
assume v in ( W .vertices() );
then (not v in { v1 }) by A67,XBOOLE_0:def 5;
hence contradiction by TARSKI:def 1;
end;
(not e in ( v .edgesInOut() )) by A63,A70,A124,GLIB_000:65;
then e in ( ( the_Edges_of G ) \ ( v .edgesInOut() ) ) by A127,XBOOLE_0:def 5;
then e in ( ( the_Edges_of G ) \ ( G .edgesInOut { v } ) ) by GLIB_000:def 40;
then e in ( G .edgesBetween ( ( the_Vertices_of G ) \ { v } ) ) by GLIB_000:35;
then e in ( the_Edges_of G3 ) by GLIB_000:47;
then e Joins cv,a,G3 by A124,GLIB_000:73;
then A134: e Joins a,cv,G3 by GLIB_000:14;
reconsider W as (Walk of C) by GLIB_001:167;
reconsider W as (Walk of G2) by GLIB_001:167;
reconsider W as (Walk of G) by GLIB_001:167;
(not v in ( W .vertices() )) by A133,GLIB_001:98;
then reconsider W as (Walk of G3) by GLIB_001:171;
W is_Walk_from y,a by A132,GLIB_001:17;
then ( W .addEdge e ) is_Walk_from y,cv by A134,GLIB_001:66;
then ( ( W .addEdge e ) .reverse() ) is_Walk_from cv,y by GLIB_001:23;
hence (ex W being (Walk of G3) st W is_Walk_from cv9,y);
end;
suppose A135: (not y in ( the_Vertices_of C ));

reconsider y9 = y as (Vertex of G) by GLIB_000:42;
consider W being (Walk of G) such that A136: W is_Walk_from cv,y9 by CKB2:def 1;
set P = the (Path of W);
A137: P is_Walk_from cv,y9 by A136,GLIB_001:160;
then A138: ( P . ( len P ) ) = y9 by GLIB_001:17;
A139: ( P . 1 ) = cv by A137,GLIB_001:17;
now
assume v in ( P .vertices() );
then consider n being  odd (Element of ( NAT )) such that A140: n <= ( len P ) and A141: ( P . n ) = v by GLIB_001:87;
set P2 = ( P .cut (n,( len P )) );
A142: P2 is_Walk_from v,y9 by A138,A140,A141,GLIB_001:37;
1 <= n by ABIAN:12;
then A143: 1 < n by A70,A139,A141,XXREAL_0:1;
now
assume cv in ( P2 .vertices() );
then consider m being  odd (Element of ( NAT )) such that A144: m <= ( len P2 ) and A145: ( P2 . m ) = cv by GLIB_001:87;
1 <= m by ABIAN:12;
then A146: m in ( dom P2 ) by A144,FINSEQ_3:25;
then A147: ( P . ( ( n + m ) - 1 ) ) = cv by A140,A145,GLIB_001:47;
( 1 + 1 ) < ( n + m ) by A143,ABIAN:12,XREAL_1:8;
then ( ( 1 + 1 ) - 1 ) < ( ( n + m ) - 1 ) by XREAL_1:14;
then A148: ( ( 2 * ( 0 ) ) + 1 ) < ( ( n + m ) - 1 );
A149: ( ( n + m ) - 1 ) in ( dom P ) by A140,A146,GLIB_001:47;
then ( ( n + m ) - 1 ) <= ( len P ) by FINSEQ_3:25;
hence contradiction by A128,A139,A138,A147,A149,A148,GLIB_001:def 28;
end;
then reconsider P2 as (Walk of G2) by GLIB_001:171;
P2 is_Walk_from v,y9 by A142,GLIB_001:19;
hence contradiction by A126,A135,CKB16:def 1;
end;
then reconsider P as (Walk of G3) by GLIB_001:171;
take P;
thus P is_Walk_from cv9,y by A137,GLIB_001:19;
end;
end;
hence (ex W being (Walk of G3) st W is_Walk_from cv9,y);
end;
end;
hence (ex W being (Walk of G3) st W is_Walk_from cv9,y);
end;
then G3 is  connected by CKB34:1;
then ( G3 .numComponents() ) = 1 by CKB46:1;
hence (not v is  cut-vertex) by A3,CKB32:def 1;
end;
end;
hence (ex v being (Vertex of G) st (v in ( the_Vertices_of C ) & (not v is  cut-vertex)));
end;
end;
hence (ex v being (Vertex of G) st (v in ( the_Vertices_of C ) & (not v is  cut-vertex)));
end;
then consider v1 being (Vertex of G) such that A150: v1 in ( the_Vertices_of CC1 ) and A151: (not v1 is  cut-vertex);
consider v2 being (Vertex of G) such that A152: v2 in ( the_Vertices_of CC2 ) and A153: (not v2 is  cut-vertex) by A12;
take v1;
take v2;
now
C2 is non empty non empty (Subset of ( the_Vertices_of G2 )) by CKB41:1;
then A154: ( the_Vertices_of CC2 ) = C2 by GLIB_000:def 37;
C1 is non empty non empty (Subset of ( the_Vertices_of G2 )) by CKB41:1;
then A155: ( the_Vertices_of CC1 ) = C1 by GLIB_000:def 37;
assume v1 = v2;
then CC1 == CC2 by A150,A152,CKB45:1;
hence contradiction by A8,A155,A154,GLIB_000:def 34;
end;
hence v1 <> v2;
thus ((not v1 is  cut-vertex) & (not v2 is  cut-vertex)) by A151,A153;
end;
end;
hence (ex v1,v2 being (Vertex of G) st ((v1 <> v2 & (not v1 is  cut-vertex)) & (not v2 is  cut-vertex)));
end;
hence P[ k ];
end;
then A156: (for k being Nat holds ((for n being Nat holds (n < k implies P[ n ])) implies P[ k ]));
A157: (for k being Nat holds P[ k ]) from NAT_1:sch 4(A156);
( G .order() ) = ( G .order() );
hence thesis by A157;
end;
