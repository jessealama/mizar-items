environ
vocabularies NUMBERS,FINSET_1,ARYTM_3,CARD_1,SUBSET_1,XBOOLE_0,GLIB_000,RELAT_2,GLIB_001,TREES_1,ZFMISC_1,FUNCT_1,FINSEQ_1,GRAPH_1,ABIAN,XXREAL_0,RELAT_1,RCOMP_1,FUNCOP_1,ARYTM_1,WAYBEL_0,TARSKI,PBOOLE,SETFAM_1,ORDINAL1,NAT_1,GLIB_002;
notations TARSKI,XBOOLE_0,ZFMISC_1,CARD_1,NUMBERS,SUBSET_1,SETFAM_1,DOMAIN_1,XCMPLX_0,ABIAN,XXREAL_0,RELAT_1,FUNCT_1,PBOOLE,FUNCT_2,FINSEQ_1,FINSET_1,NAT_1,FUNCOP_1,GLIB_000,GLIB_001,CKB2,CKB3,CKB4,CKB11,CKB16,CKB17,CKB22,CKB26,CKB27,CKB29,CKB30,CKB31,CKB32;
definitions TARSKI,FUNCOP_1,CKB2,CKB3,CKB4,CKB11,CKB16,CKB17,CKB22,CKB27,CKB29,CKB31,CKB32;
theorems CARD_1,CARD_2,FUNCOP_1,FINSEQ_1,FINSEQ_3,FUNCT_1,FUNCT_2,GLIB_000,GLIB_001,ABIAN,INT_1,JORDAN12,NAT_1,ORDINAL1,PENCIL_1,TARSKI,XBOOLE_0,XBOOLE_1,XCMPLX_1,ZFMISC_1,XREAL_1,XXREAL_0,RELSET_1,CKB1,CKB2,CKB3,CKB4,CKB11,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB27,CKB29,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB51;
schemes NAT_1,SUBSET_1,GLIB_000;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,XREAL_0,INT_1,CARD_1,GLIB_000,ABIAN,GLIB_001,FUNCT_2,PARTFUN1,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13,CKB14,CKB15,CKB23,CKB24,CKB25,CKB28,CKB50;
constructors DOMAIN_1,CARD_FIL,GLIB_001,VALUED_1,XXREAL_2,WELLORD2,RELSET_1,CKB2,CKB3,CKB4,CKB11,CKB16,CKB17,CKB22,CKB27,CKB29,CKB30,CKB31;
requirements ARITHM,BOOLE,NUMERALS,REAL,SUBSET;
begin
theorem
Lm23: (for G being non trivial  finite  acyclic _Graph holds (( the_Edges_of G ) <> ( {} ) implies (ex v1,v2 being (Vertex of G) st (((v1 <> v2 & v1 is  endvertex) & v2 is  endvertex) & v2 in ( G .reachableFrom v1 )))))
proof
let G being non trivial  finite  acyclic _Graph;
assume that
A1: ( the_Edges_of G ) <> ( {} );
defpred P[ Nat ]
 means
(ex W being (Path of G) st ( len W ) = $1);
set e = ( choose ( the_Edges_of G ) );
A2:now
let k being Nat;
assume P[ k ];
then consider P being (Path of G) such that A3: ( len P ) = k;
( 2 * ( len ( P .vertexSeq() ) ) ) <= ( 2 * ( ( G .order() ) + 1 ) ) by GLIB_001:154,XREAL_1:64;
then ( k + 1 ) <= ( 2 * ( ( G .order() ) + 1 ) ) by A3,GLIB_001:def 14;
then ( ( k + 1 ) - 1 ) <= ( ( 2 * ( ( G .order() ) + 1 ) ) - ( 0 ) ) by XREAL_1:13;
hence k <= ( 2 * ( ( G .order() ) + 1 ) );
end;
set src = ( ( the_Source_of G ) . e );
set tar = ( ( the_Target_of G ) . e );
e Joins src,tar,G by A1,GLIB_000:def 13;
then A4: ( len ( G .walkOf (src,e,tar) ) ) = 3 by GLIB_001:14;
then A5: (ex k being Nat st P[ k ]);
consider k being Nat such that A6: (P[ k ] & (for n being Nat holds (P[ n ] implies n <= k))) from NAT_1:sch 6(A2,A5);
consider W being (Path of G) such that A7: ( len W ) = k and A8: (for n being Nat holds (P[ n ] implies n <= k)) by A6;
A9: ( len ( W .reverse() ) ) = k by A7,GLIB_001:21;
A10: 3 <= ( len W ) by A4,A7,A8;
then A11: W is non trivial by GLIB_001:125;
A12:now
assume ( W .first() ) = ( W .last() );
then W is  closed by GLIB_001:def 24;
then W is  Cycle-like by A11,GLIB_001:def 31;
hence contradiction by CKB3:def 1;
end;
then A13: W is  open by GLIB_001:def 24;
A14:now
let W being (Path of G);
assume that
A15: ( len W ) = k
and
A16: W is  open;
( 2 + 1 ) <= ( len W ) by A4,A8,A15;
then 2 < ( len W ) by NAT_1:13;
then reconsider lenW2 = ( ( len W ) - ( 2 * 1 ) ) as  odd (Element of ( NAT )) by INT_1:5;
A17: ( lenW2 + 2 ) = ( len W );
A18: W is non trivial by A7,A10,A15,GLIB_001:125;
now
( W .last() ) in ( W .vertices() ) by GLIB_001:88;
then (not ( W .last() ) is  isolated) by A18,GLIB_001:135;
then ( ( W .last() ) .degree() ) <> ( 0 ) by GLIB_000:def 50;
then ( card ( ( W .last() ) .edgesInOut() ) ) <> ( 0 ) by GLIB_000:19;
then ( 0 ) < ( card ( ( W .last() ) .edgesInOut() ) ) by NAT_1:3;
then A19: ( ( 0 ) + 1 ) <= ( card ( ( W .last() ) .edgesInOut() ) ) by NAT_1:13;
assume (not ( W .last() ) is  endvertex);
then ( ( W .last() ) .degree() ) <> 1 by GLIB_000:def 52;
then ( card ( ( W .last() ) .edgesInOut() ) ) <> 1 by GLIB_000:19;
then 1 < ( card ( ( W .last() ) .edgesInOut() ) ) by A19,XXREAL_0:1;
then consider e1 being set,e2 being set such that A20: e1 in ( ( W .last() ) .edgesInOut() ) and A21: (e2 in ( ( W .last() ) .edgesInOut() ) & e1 <> e2) by CKB1:1;
now
per cases ;
suppose A22: e1 = ( W . ( lenW2 + 1 ) );

take e2;
thus (e2 in ( ( W .last() ) .edgesInOut() ) & e2 <> ( W . ( lenW2 + 1 ) )) by A21,A22;
end;
suppose A23: e1 <> ( W . ( lenW2 + 1 ) );

take e1;
thus (e1 in ( ( W .last() ) .edgesInOut() ) & e1 <> ( W . ( lenW2 + 1 ) )) by A20,A23;
end;
end;
then consider e being set such that A24: e in ( ( W .last() ) .edgesInOut() ) and A25: e <> ( W . ( lenW2 + 1 ) );
consider v being (Vertex of G) such that A26: e Joins ( W .last() ),v,G by A24,GLIB_000:64;
now
per cases ;
suppose v in ( W .vertices() );

then consider n being  odd (Element of ( NAT )) such that A27: n <= ( len W ) and A28: ( W . n ) = v by GLIB_001:87;
set m = ( W .rfind n );
set W2 = ( W .cut (m,( len W )) );
A29: m <= ( len W ) by A27,GLIB_001:def 22;
then ( W2 .last() ) = ( W . ( len W ) ) by GLIB_001:37;
then A30: e Joins ( W2 .last() ),v,G by A26,GLIB_001:def 7;
( W . m ) = v by A27,A28,GLIB_001:def 22;
then A31: ( W2 .first() ) = v by A29,GLIB_001:37;
A32: e in ( ( W2 .last() ) .edgesInOut() ) by A30,GLIB_000:62;
now
per cases ;
suppose A33: (not e in ( W2 .edges() ));

A34: ( W2 .addEdge e ) is non trivial by A30,GLIB_001:132;
(( ( W2 .addEdge e ) .first() ) = v & ( ( W2 .addEdge e ) .last() ) = v) by A31,A30,GLIB_001:63;
then A35: ( W2 .addEdge e ) is  closed by GLIB_001:def 24;
( W2 .addEdge e ) is  Path-like by A32,A33,CKB51:1;
then ( W2 .addEdge e ) is  Cycle-like by A35,A34,GLIB_001:def 31;
hence contradiction by CKB3:def 1;
end;
suppose A36: e in ( W2 .edges() );

( W2 .edges() ) c= ( W .edges() ) by GLIB_001:106;
then consider a being  even (Element of ( NAT )) such that A37: 1 <= a and A38: a <= ( len W ) and A39: ( W . a ) = e by A36,GLIB_001:99;
reconsider a1 = ( a - 1 ) as  odd (Element of ( NAT )) by A37,INT_1:5;
A40: a1 < ( ( len W ) - ( 0 ) ) by A38,XREAL_1:15;
a < ( lenW2 + 2 ) by A38,XXREAL_0:1;
then ( a + 1 ) <= ( ( lenW2 + 1 ) + 1 ) by NAT_1:13;
then a <= ( lenW2 + 1 ) by XREAL_1:6;
then A41: a < ( lenW2 + 1 ) by A25,A39,XXREAL_0:1;
( a1 + 1 ) = a;
then A42: e Joins ( W . a1 ),( W . ( a1 + 2 ) ),G by A39,A40,GLIB_001:def 3;
now
per cases  by A26,A42,GLIB_000:15;
suppose (( W .last() ) = ( W . a1 ) & v = ( W . ( a1 + 2 ) ));

then ( W . ( len W ) ) = ( W . a1 ) by GLIB_001:def 7;
hence contradiction by A16,A40,GLIB_001:147;
end;
suppose A43: (( W .last() ) = ( W . ( a1 + 2 ) ) & v = ( W . a1 ));

a1 < ( ( lenW2 + 1 ) - 1 ) by A41,XREAL_1:14;
then A44: ( a1 + 2 ) < ( len W ) by A17,XREAL_1:8;
( W . ( len W ) ) = ( W . ( a1 + 2 ) ) by A43,GLIB_001:def 7;
hence contradiction by A16,A44,GLIB_001:147;
end;
end;
hence contradiction;
end;
end;
hence contradiction;
end;
suppose A45: (not v in ( W .vertices() ));

A46: ( len ( W .addEdge e ) ) = ( k + 2 ) by A15,A26,GLIB_001:64;
( W .addEdge e ) is  Path-like by A16,A26,A45,GLIB_001:151;
then ( k + 2 ) <= ( k + ( 0 ) ) by A8,A46;
hence contradiction by XREAL_1:6;
end;
end;
hence contradiction;
end;
hence ( W .last() ) is  endvertex;
end;
W is_Walk_from ( W .first() ),( W .last() ) by GLIB_001:def 23;
then A47: ( W .last() ) in ( G .reachableFrom ( W .first() ) ) by CKB16:def 1;
( W .reverse() ) is  open by A13,GLIB_001:120;
then ( ( W .reverse() ) .last() ) is  endvertex by A14,A9;
then A48: ( W .first() ) is  endvertex by GLIB_001:22;
( W .last() ) is  endvertex by A7,A13,A14;
hence thesis by A12,A48,A47;
end;
