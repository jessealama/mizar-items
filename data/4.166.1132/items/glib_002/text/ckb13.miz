environ
vocabularies NUMBERS,FINSET_1,ARYTM_3,CARD_1,SUBSET_1,XBOOLE_0,GLIB_000,RELAT_2,GLIB_001,TREES_1,ZFMISC_1,FUNCT_1,FINSEQ_1,GRAPH_1,ABIAN,XXREAL_0,RELAT_1,RCOMP_1,FUNCOP_1,ARYTM_1,WAYBEL_0,TARSKI,PBOOLE,SETFAM_1,ORDINAL1,NAT_1,GLIB_002;
notations TARSKI,XBOOLE_0,ZFMISC_1,CARD_1,NUMBERS,SUBSET_1,SETFAM_1,DOMAIN_1,XCMPLX_0,ABIAN,XXREAL_0,RELAT_1,FUNCT_1,PBOOLE,FUNCT_2,FINSEQ_1,FINSET_1,NAT_1,FUNCOP_1,GLIB_000,GLIB_001,CKB2,CKB3,CKB4,CKB11;
definitions TARSKI,FUNCOP_1,CKB2,CKB3,CKB4,CKB11;
theorems CARD_1,CARD_2,FUNCOP_1,FINSEQ_1,FINSEQ_3,FUNCT_1,FUNCT_2,GLIB_000,GLIB_001,ABIAN,INT_1,JORDAN12,NAT_1,ORDINAL1,PENCIL_1,TARSKI,XBOOLE_0,XBOOLE_1,XCMPLX_1,ZFMISC_1,XREAL_1,XXREAL_0,RELSET_1,CKB1,CKB2,CKB3,CKB4,CKB11;
schemes NAT_1,SUBSET_1,GLIB_000;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,XREAL_0,INT_1,CARD_1,GLIB_000,ABIAN,GLIB_001,FUNCT_2,PARTFUN1,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB12;
constructors DOMAIN_1,CARD_FIL,GLIB_001,VALUED_1,XXREAL_2,WELLORD2,RELSET_1,CKB2,CKB3,CKB4,CKB11;
requirements ARITHM,BOOLE,NUMERALS,REAL,SUBSET;
begin
registration
cluster non  trivial  finite  Tree-like for _Graph;
existence
proof
set V = { ( 0 ),1 };
set E = { ( 0 ) };
set S = ( ( 0 ) .--> ( 0 ) );
set T = ( ( 0 ) .--> 1 );
A1: ( dom T ) = E by FUNCOP_1:13;
A2:now
let x being set;
assume x in E;
then x = ( 0 ) by TARSKI:def 1;
then ( T . x ) = 1 by FUNCOP_1:72;
hence ( T . x ) in V by TARSKI:def 2;
end;
A3:now
let x being set;
assume x in E;
then x = ( 0 ) by TARSKI:def 1;
then ( S . x ) = ( 0 ) by FUNCOP_1:72;
hence ( S . x ) in V by TARSKI:def 2;
end;
reconsider T as (Function of E,V) by A1,A2,FUNCT_2:3;
( dom S ) = E by FUNCOP_1:13;
then reconsider S as (Function of E,V) by A3,FUNCT_2:3;
set G = ( createGraph (V,E,S,T) );
A4: ( the_Edges_of G ) = E by GLIB_000:6;
( the_Target_of G ) = T by GLIB_000:6;
then A5: ( ( the_Target_of G ) . ( 0 ) ) = 1 by FUNCOP_1:72;
( the_Source_of G ) = S by GLIB_000:6;
then A6: ( ( the_Source_of G ) . ( 0 ) ) = ( 0 ) by FUNCOP_1:72;
now
given W being (Walk of G) such that
A7: W is  Cycle-like;

now
per cases ;
suppose A8: ( len W ) = 3;

set e = ( W . ( 1 + 1 ) );
set v1 = ( W . 1 );
set v2 = ( W . ( 1 + 2 ) );
A9: ( W . ( 1 + 1 ) ) Joins ( W . 1 ),( W . ( 1 + 2 ) ),G by A8,GLIB_001:def 3,JORDAN12:2;
v1 = v2 by A7,A8,GLIB_001:118;
then A10: ((( ( the_Source_of G ) . e ) = v1 & ( ( the_Target_of G ) . e ) = v1) or (( ( the_Source_of G ) . e ) = v1 & ( ( the_Target_of G ) . e ) = v1)) by A9,GLIB_000:def 13;
e in ( the_Edges_of G ) by A9,GLIB_000:def 13;
then ((v1 = ( 0 ) & v1 = 1) or (v1 = 1 & v1 = ( 0 ))) by A4,A6,A5,A10,TARSKI:def 1;
hence contradiction;
end;
suppose A11: ( len W ) <> 3;

A12: 3 <= ( len W ) by A7,GLIB_001:125;
then ( 3 - 1 ) <= ( ( len W ) - ( 0 ) ) by XREAL_1:13;
then ( 2 * 1 ) in ( dom W ) by FINSEQ_3:25;
then ( W . ( 2 * 1 ) ) in { ( 0 ) } by A4,GLIB_001:8;
then A13: ( W . ( 2 * 1 ) ) = ( 0 ) by TARSKI:def 1;
3 < ( len W ) by A11,A12,XXREAL_0:1;
then A14: ( 3 + 1 ) <= ( len W ) by NAT_1:13;
then ( 2 * 2 ) in ( dom W ) by FINSEQ_3:25;
then ( W . ( 2 * 2 ) ) in { ( 0 ) } by A4,GLIB_001:8;
then ( W . ( 2 * 2 ) ) = ( 0 ) by TARSKI:def 1;
hence contradiction by A7,A14,A13,GLIB_001:138;
end;
end;
hence contradiction;
end;
then A15: G is  acyclic by CKB3:def 1;
set W1 = ( G .walkOf (( 0 ),( 0 ),1) );
set W2 = ( W1 .reverse() );
take G;
A16: ( the_Vertices_of G ) = V by GLIB_000:6;
then reconsider a0 = ( 0 ),a1 = 1 as (Vertex of G) by TARSKI:def 2;
now
assume ( card ( the_Vertices_of G ) ) = 1;
then (ex x being set st ( the_Vertices_of G ) = { x }) by CARD_2:42;
hence contradiction by A16,ZFMISC_1:5;
end;
hence (G is non  trivial & G is  finite) by GLIB_000:def 19;
( 0 ) in ( the_Edges_of G ) by A4,TARSKI:def 1;
then ( 0 ) Joins ( 0 ),1,G by A6,A5,GLIB_000:def 13;
then A17: W1 is_Walk_from ( 0 ),1 by GLIB_001:15;
then A18: W2 is_Walk_from 1,( 0 ) by GLIB_001:23;
now
let u being (Vertex of G);
let v being (Vertex of G);
now
per cases  by A16,TARSKI:def 2;
suppose (u = ( 0 ) & v = ( 0 ));

then ( G .walkOf a0 ) is_Walk_from u,v by GLIB_001:13;
hence (ex W being (Walk of G) st W is_Walk_from u,v);
end;
suppose (u = ( 0 ) & v = 1);

hence (ex W being (Walk of G) st W is_Walk_from u,v) by A17;
end;
suppose (u = 1 & v = ( 0 ));

hence (ex W being (Walk of G) st W is_Walk_from u,v) by A18;
end;
suppose (u = 1 & v = 1);

then ( G .walkOf a1 ) is_Walk_from u,v by GLIB_001:13;
hence (ex W being (Walk of G) st W is_Walk_from u,v);
end;
end;
hence (ex W being (Walk of G) st W is_Walk_from u,v);
end;
then G is  connected by CKB2:def 1;
hence thesis by A15;
end;
end;
