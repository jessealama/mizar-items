environ
vocabularies NUMBERS,FINSET_1,ARYTM_3,CARD_1,SUBSET_1,XBOOLE_0,GLIB_000,RELAT_2,GLIB_001,TREES_1,ZFMISC_1,FUNCT_1,FINSEQ_1,GRAPH_1,ABIAN,XXREAL_0,RELAT_1,RCOMP_1,FUNCOP_1,ARYTM_1,WAYBEL_0,TARSKI,PBOOLE,SETFAM_1,ORDINAL1,NAT_1,GLIB_002;
notations TARSKI,XBOOLE_0,ZFMISC_1,CARD_1,NUMBERS,SUBSET_1,SETFAM_1,DOMAIN_1,XCMPLX_0,ABIAN,XXREAL_0,RELAT_1,FUNCT_1,PBOOLE,FUNCT_2,FINSEQ_1,FINSET_1,NAT_1,FUNCOP_1,GLIB_000,GLIB_001,CKB2,CKB3,CKB4,CKB11,CKB16,CKB17,CKB22,CKB26,CKB27,CKB29,CKB30,CKB31,CKB32,CKB56,CKB57,CKB58;
definitions TARSKI,FUNCOP_1,CKB2,CKB3,CKB4,CKB11,CKB16,CKB17,CKB22,CKB27,CKB29,CKB31,CKB32,CKB56,CKB57,CKB58;
theorems CARD_1,CARD_2,FUNCOP_1,FINSEQ_1,FINSEQ_3,FUNCT_1,FUNCT_2,GLIB_000,GLIB_001,ABIAN,INT_1,JORDAN12,NAT_1,ORDINAL1,PENCIL_1,TARSKI,XBOOLE_0,XBOOLE_1,XCMPLX_1,ZFMISC_1,XREAL_1,XXREAL_0,RELSET_1,CKB1,CKB2,CKB3,CKB4,CKB11,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB27,CKB29,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB51,CKB52,CKB53,CKB56,CKB57,CKB58,CKB68,CKB69,CKB70;
schemes NAT_1,SUBSET_1,GLIB_000;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,XREAL_0,INT_1,CARD_1,GLIB_000,ABIAN,GLIB_001,FUNCT_2,PARTFUN1,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13,CKB14,CKB15,CKB23,CKB24,CKB25,CKB28,CKB50,CKB54,CKB55,CKB59,CKB60,CKB61,CKB62,CKB63,CKB64,CKB65,CKB66,CKB67;
constructors DOMAIN_1,CARD_FIL,GLIB_001,VALUED_1,XXREAL_2,WELLORD2,RELSET_1,CKB2,CKB3,CKB4,CKB11,CKB16,CKB17,CKB22,CKB27,CKB29,CKB30,CKB31,CKB56,CKB57,CKB58;
requirements ARITHM,BOOLE,NUMERALS,REAL,SUBSET;
begin
theorem
Th5: (for G1 being  connected _Graph holds (for W being (Walk of G1) holds (for e being set holds (for G2 being (removeEdge of G1,e) holds ((W is  Cycle-like & e in ( W .edges() )) implies G2 is  connected)))))
proof
let G1 being  connected _Graph;
let W being (Walk of G1);
let e being set;
let G2 being (removeEdge of G1,e);
assume that
A1: W is  Cycle-like
and
A2: e in ( W .edges() );
reconsider v1 = ( ( the_Source_of G1 ) . e ),v2 = ( ( the_Target_of G1 ) . e ) as (Vertex of G1) by A2,FUNCT_2:5;
e Joins v1,v2,G1 by A2,GLIB_000:def 13;
then consider X being (Walk of G1) such that A3: X is_Walk_from v1,v2 and A4: (not e in ( X .edges() )) by A1,A2,GLIB_001:157;
reconsider X2 = X as (Walk of G2) by A4,GLIB_001:172;
A5: X2 is_Walk_from v1,v2 by A3,GLIB_001:19;
then A6: ( X2 .reverse() ) is_Walk_from v2,v1 by GLIB_001:23;
now
let u being (Vertex of G2),v being (Vertex of G2);
( the_Vertices_of G2 ) c= ( the_Vertices_of G1 );
then reconsider u9 = u,v9 = v as (Vertex of G1) by TARSKI:def 3;
consider C being (Walk of G1) such that A7: C is_Walk_from u9,v9 by CKB2:def 1;
set P = the (Path of C);
A8: P is_Walk_from u9,v9 by A7,GLIB_001:160;
then A9: ( P . ( len P ) ) = v by GLIB_001:17;
A10: ( P . 1 ) = u by A8,GLIB_001:17;
now
per cases ;
suppose e in ( P .edges() );

then consider a being (Vertex of G1),b being (Vertex of G1),m being  odd (Element of ( NAT )) such that A11: ( m + 2 ) <= ( len P ) and A12: a = ( P . m ) and A13: e = ( P . ( m + 1 ) ) and A14: b = ( P . ( m + 2 ) ) and A15: e Joins a,b,G1 by GLIB_001:103;
set P1 = ( P .cut (1,m) );
set P2 = ( P .cut (( m + 2 ),( len P )) );
A16: ( ( m + 2 ) - 2 ) < ( ( len P ) - ( 0 ) ) by A11,XREAL_1:15;
then A17: ( m + 1 ) <= ( len P ) by NAT_1:13;
now
assume e in ( P1 .edges() );
then consider x being  even (Element of ( NAT )) such that A18: 1 <= x and A19: x <= ( len P1 ) and A20: ( P1 . x ) = e by GLIB_001:99;
x <= m by A16,A19,GLIB_001:45;
then A21: x < ( m + 1 ) by NAT_1:13;
x in ( dom P1 ) by A18,A19,FINSEQ_3:25;
then ( P . x ) = e by A16,A20,GLIB_001:46;
hence contradiction by A13,A17,A18,A21,GLIB_001:138;
end;
then reconsider P19 = P1 as (Walk of G2) by GLIB_001:172;
now
assume e in ( P2 .edges() );
then consider x being  even (Element of ( NAT )) such that A22: 1 <= x and A23: x <= ( len P2 ) and A24: ( P2 . x ) = e by GLIB_001:99;
reconsider x1 = ( x - 1 ) as  odd (Element of ( NAT )) by A22,INT_1:5;
A25: x1 < ( ( len P2 ) - ( 0 ) ) by A23,XREAL_1:15;
then ( ( m + 2 ) + x1 ) in ( dom P ) by A11,GLIB_001:36;
then A26: ( ( m + 2 ) + x1 ) <= ( len P ) by FINSEQ_3:25;
( x1 + 1 ) = x;
then A27: e = ( P . ( ( m + 2 ) + x1 ) ) by A11,A24,A25,GLIB_001:36;
( m + 1 ) < ( ( m + 1 ) + 1 ) by NAT_1:13;
then A28: ( ( m + 1 ) + ( 0 ) ) < ( ( m + 2 ) + x1 ) by NAT_1:2,XREAL_1:8;
1 <= ( m + 1 ) by NAT_1:12;
hence contradiction by A13,A27,A26,A28,GLIB_001:138;
end;
then reconsider P29 = P2 as (Walk of G2) by GLIB_001:172;
reconsider a,b as (Vertex of G2) by GLIB_000:51;
1 <= m by ABIAN:12;
then P1 is_Walk_from u,a by A10,A12,A16,GLIB_001:37,JORDAN12:2;
then A29: P19 is_Walk_from u,a by GLIB_001:19;
P2 is_Walk_from b,v by A9,A11,A14,GLIB_001:37;
then A30: P29 is_Walk_from b,v by GLIB_001:19;
now
per cases  by A15,GLIB_000:def 13;
suppose (a = v1 & b = v2);

then ( P19 .append X2 ) is_Walk_from u,b by A5,A29,GLIB_001:31;
then ( ( P19 .append X2 ) .append P29 ) is_Walk_from u,v by A30,GLIB_001:31;
hence (ex W being (Walk of G2) st W is_Walk_from u,v);
end;
suppose (b = v1 & a = v2);

then ( P19 .append ( X2 .reverse() ) ) is_Walk_from u,b by A6,A29,GLIB_001:31;
then ( ( P19 .append ( X2 .reverse() ) ) .append P29 ) is_Walk_from u,v by A30,GLIB_001:31;
hence (ex W being (Walk of G2) st W is_Walk_from u,v);
end;
end;
hence (ex W being (Walk of G2) st W is_Walk_from u,v);
end;
suppose (not e in ( P .edges() ));

then reconsider P as (Walk of G2) by GLIB_001:172;
take P;
thus P is_Walk_from u,v by A8,GLIB_001:19;
end;
end;
hence (ex W being (Walk of G2) st W is_Walk_from u,v);
end;
hence thesis by CKB2:def 1;
end;
