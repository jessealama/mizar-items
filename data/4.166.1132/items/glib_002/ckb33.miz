environ
vocabularies NUMBERS,FINSET_1,ARYTM_3,CARD_1,SUBSET_1,XBOOLE_0,GLIB_000,RELAT_2,GLIB_001,TREES_1,ZFMISC_1,FUNCT_1,FINSEQ_1,GRAPH_1,ABIAN,XXREAL_0,RELAT_1,RCOMP_1,FUNCOP_1,ARYTM_1,WAYBEL_0,TARSKI,PBOOLE,SETFAM_1,ORDINAL1,NAT_1,GLIB_002;
notations TARSKI,XBOOLE_0,ZFMISC_1,CARD_1,NUMBERS,SUBSET_1,SETFAM_1,DOMAIN_1,XCMPLX_0,ABIAN,XXREAL_0,RELAT_1,FUNCT_1,PBOOLE,FUNCT_2,FINSEQ_1,FINSET_1,NAT_1,FUNCOP_1,GLIB_000,GLIB_001,CKB2,CKB3,CKB4,CKB11,CKB16,CKB17,CKB22,CKB26,CKB27,CKB29,CKB30,CKB31,CKB32;
definitions TARSKI,FUNCOP_1,CKB2,CKB3,CKB4,CKB11,CKB16,CKB17,CKB22,CKB27,CKB29,CKB31,CKB32;
theorems CARD_1,CARD_2,FUNCOP_1,FINSEQ_1,FINSEQ_3,FUNCT_1,FUNCT_2,GLIB_000,GLIB_001,ABIAN,INT_1,JORDAN12,NAT_1,ORDINAL1,PENCIL_1,TARSKI,XBOOLE_0,XBOOLE_1,XCMPLX_1,ZFMISC_1,XREAL_1,XXREAL_0,RELSET_1,CKB1,CKB2,CKB3,CKB4,CKB11,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB27,CKB29,CKB31,CKB32;
schemes NAT_1,SUBSET_1,GLIB_000;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,XREAL_0,INT_1,CARD_1,GLIB_000,ABIAN,GLIB_001,FUNCT_2,PARTFUN1,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13,CKB14,CKB15,CKB23,CKB24,CKB25,CKB28;
constructors DOMAIN_1,CARD_FIL,GLIB_001,VALUED_1,XXREAL_2,WELLORD2,RELSET_1,CKB2,CKB3,CKB4,CKB11,CKB16,CKB17,CKB22,CKB27,CKB29,CKB30,CKB31;
requirements ARITHM,BOOLE,NUMERALS,REAL,SUBSET;
begin
theorem
Lm5: (for G1 being non trivial  connected _Graph holds (for v being (Vertex of G1) holds (for G2 being (removeVertex of G1,v) holds (v is  endvertex implies G2 is  connected))))
proof
let G1 being non trivial  connected _Graph;
let v being (Vertex of G1);
let G2 being (removeVertex of G1,v);
set VG = ( the_Vertices_of G1 );
set VG2 = ( the_Vertices_of G2 );
assume A1: v is  endvertex;
then consider ev being set such that A2: ( v .edgesInOut() ) = { ev } and (not ev Joins v,v,G1) by GLIB_000:def 51;
now
let v19 being (Vertex of G2),v29 being (Vertex of G2);
reconsider v1 = v19,v2 = v29 as (Vertex of G1) by GLIB_000:42;
consider W being (Walk of G1) such that A3: W is_Walk_from v1,v2 by CKB2:def 1;
set T = the (Trail of W);
A4: T is_Walk_from v1,v2 by A3,GLIB_001:160;
then A5: ( T . ( len T ) ) = v2 by GLIB_001:17;
v19 in VG2;
then v19 in ( VG \ { v } ) by GLIB_000:47;
then A6: (not v1 in { v }) by XBOOLE_0:def 5;
v29 in VG2;
then v29 in ( VG \ { v } ) by GLIB_000:47;
then (not v2 in { v }) by XBOOLE_0:def 5;
then A7: v2 <> v by TARSKI:def 1;
A8: ( T . 1 ) = v1 by A4,GLIB_001:17;
now
let e being set;
assume A9: e in ( T .edges() );
then consider n being  even (Element of ( NAT )) such that A10: 1 <= n and A11: n <= ( len T ) and A12: ( T . n ) = e by GLIB_001:99;
n in ( dom T ) by A10,A11,FINSEQ_3:25;
then consider n1 being  odd (Element of ( NAT )) such that A13: n1 = ( n - 1 ) and A14: ( n - 1 ) in ( dom T ) and A15: ( n + 1 ) in ( dom T ) and A16: ( T . n ) Joins ( T . n1 ),( T . ( n + 1 ) ),G1 by GLIB_001:9;
A17: ( n + 1 ) <= ( len T ) by A15,FINSEQ_3:25;
A18: n1 <= ( len T ) by A13,A14,FINSEQ_3:25;
now
assume A19: e in ( v .edgesInOut() );
then A20: e = ev by A2,TARSKI:def 1;
now
per cases  by A12,A16,A19,GLIB_000:65;
suppose A21: ( T . n1 ) = v;

reconsider n2 = ( n1 - 1 ) as  even (Element of ( NAT )) by ABIAN:12,INT_1:5;
A22: 1 <= n1 by ABIAN:12;
n1 <> 1 by A6,A8,A21,TARSKI:def 1;
then A23: 1 < n1 by A22,XXREAL_0:1;
then ( 1 + 1 ) <= n1 by NAT_1:13;
then A24: ( ( 1 + 1 ) - 1 ) <= n2 by XREAL_1:13;
( T .vertexAt n1 ) = v by A18,A21,GLIB_001:def 8;
then ( T . n2 ) in ( v .edgesInOut() ) by A18,A23,GLIB_001:11;
then A25: ( T . n ) = ( T . n2 ) by A2,A12,A20,TARSKI:def 1;
( n - 1 ) < ( n - ( 0 ) ) by XREAL_1:15;
then ( n1 - 1 ) < ( n - ( 0 ) ) by A13,XREAL_1:14;
hence contradiction by A11,A25,A24,GLIB_001:138;
end;
suppose A26: ( T . ( n + 1 ) ) = v;

then A27: ( n + 1 ) < ( len T ) by A7,A5,A17,XXREAL_0:1;
( T .vertexAt ( n + 1 ) ) = v by A17,A26,GLIB_001:def 8;
then ( T . ( ( n + 1 ) + 1 ) ) in ( v .edgesInOut() ) by A27,GLIB_001:10;
then A28: ( T . n ) = ( T . ( ( n + 1 ) + 1 ) ) by A2,A12,A20,TARSKI:def 1;
(( n + ( 0 ) ) < ( n + ( 1 + 1 ) ) & ( ( n + 1 ) + 1 ) <= ( len T )) by A27,NAT_1:13,XREAL_1:8;
hence contradiction by A10,A28,GLIB_001:138;
end;
end;
hence contradiction;
end;
then e in ( ( the_Edges_of G1 ) \ ( v .edgesInOut() ) ) by A9,XBOOLE_0:def 5;
then e in ( ( the_Edges_of G1 ) \ ( G1 .edgesInOut { v } ) ) by GLIB_000:def 40;
then e in ( G1 .edgesBetween ( ( the_Vertices_of G1 ) \ { v } ) ) by GLIB_000:35;
hence e in ( the_Edges_of G2 ) by GLIB_000:47;
end;
then A29: ( T .edges() ) c= ( the_Edges_of G2 ) by TARSKI:def 3;
A30: v1 <> v by A6,TARSKI:def 1;
now
let x being set;
assume A31: x in ( T .vertices() );
now
assume x = v;
then (v = ( T .first() ) or v = ( T .last() )) by A1,A31,GLIB_001:143;
hence contradiction by A30,A7,A4,GLIB_001:def 23;
end;
then (not x in { v }) by TARSKI:def 1;
then x in ( VG \ { v } ) by A31,XBOOLE_0:def 5;
hence x in VG2 by GLIB_000:47;
end;
then ( T .vertices() ) c= VG2 by TARSKI:def 3;
then reconsider W9 = T as (Walk of G2) by A29,GLIB_001:170;
W9 is_Walk_from v19,v29 by A4,GLIB_001:19;
hence (ex W being (Walk of G2) st W is_Walk_from v19,v29);
end;
hence thesis by CKB2:def 1;
end;
