environ
vocabularies NUMBERS,SUBSET_1,XBOOLE_0,ARYTM_1,CARD_1,RELAT_1,FINSEQ_1,QUANTAL1,UNIALG_1,UNIALG_2,FUNCT_1,MSAFREE,TARSKI,STRUCT_0,FINSEQ_2,PRELAMB,CQC_SIM1,MSUALG_3,FUNCOP_1,PARTFUN1,FUNCT_2,NAT_1,LANG1,TDGROUP,DTCONSTR,TREES_3,TREES_4,CARD_3,TREES_2,QC_LANG1,FREEALG;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,NAT_1,RELAT_1,RELSET_1,FUNCT_1,PARTFUN1,FINSEQ_1,FUNCT_2,FUNCOP_1,FINSEQ_2,CARD_3,TREES_2,TREES_3,TREES_4,MARGREL1,STRUCT_0,UNIALG_1,UNIALG_2,LANG1,DTCONSTR,PRE_POLY,ALG_1,CKB1,CKB4,CKB5,CKB6,CKB9,CKB10,CKB13,CKB14,CKB18,CKB19,CKB26,CKB27,CKB28,CKB29,CKB31,CKB33,CKB34,CKB35,CKB38,CKB39;
definitions TARSKI,UNIALG_2,DTCONSTR,XBOOLE_0,FINSEQ_2,FUNCOP_1,MARGREL1,CKB1,CKB6,CKB9,CKB10,CKB13,CKB14,CKB18,CKB19,CKB26,CKB27,CKB28,CKB29,CKB31,CKB34,CKB35,CKB39;
theorems FINSEQ_1,FINSEQ_2,PARTFUN1,FUNCT_1,FUNCT_2,NAT_1,ZFMISC_1,UNIALG_1,ALG_1,TARSKI,FUNCOP_1,UNIALG_2,LANG1,DTCONSTR,RELAT_1,XBOOLE_0,XBOOLE_1,TREES_3,MARGREL1,FINSEQ_3,CARD_1,CKB1,CKB3,CKB6,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB17,CKB18,CKB19,CKB21,CKB22,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB34,CKB35,CKB36,CKB39;
schemes PARTFUN1,FINSEQ_1,RELSET_1,DTCONSTR;
registrations XBOOLE_0,SUBSET_1,RELAT_1,ORDINAL1,PARTFUN1,XREAL_0,FINSEQ_1,FINSEQ_2,TREES_3,STRUCT_0,UNIALG_1,UNIALG_2,DTCONSTR,CARD_1,RELSET_1,MARGREL1,FUNCT_1,CKB2,CKB7,CKB8,CKB15,CKB16,CKB20,CKB23,CKB24,CKB25,CKB37;
constructors DOMAIN_1,XCMPLX_0,XXREAL_0,XREAL_0,FINSEQOP,DTCONSTR,ALG_1,RELSET_1,PRE_POLY,CKB1,CKB9,CKB10,CKB13,CKB14,CKB18,CKB19,CKB26,CKB27,CKB28,CKB29,CKB31,CKB33,CKB34,CKB35,CKB38,CKB39;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve n for (Element of ( NAT ));
definition
let f being  with_zero non empty (FinSequence of ( NAT ));
let D being  disjoint_with_NAT set;
func FreeOpSeqZAO (f,D) -> (PFuncFinSequence of ( TS ( DTConUA (f,D) ) ))
means
:Def18: (( len it ) = ( len f ) & (for n holds (n in ( dom it ) implies ( it . n ) = ( FreeOpZAO (n,f,D) ))));
existence
proof
defpred P[ Nat,set ]
 means
$2 = ( FreeOpZAO ($1,f,D) );
set A = ( TS ( DTConUA (f,D) ) );
A1: (for n being Nat holds (n in ( Seg ( len f ) ) implies (ex x being (Element of ( PFuncs (( A * ),A) )) st P[ n,x ])))
proof
let n being Nat;
assume n in ( Seg ( len f ) );
reconsider O = ( FreeOpZAO (n,f,D) ) as (Element of ( PFuncs (( A * ),A) )) by PARTFUN1:45;
take O;
thus thesis;
end;
consider p being (FinSequence of ( PFuncs (( A * ),A) )) such that A2: (( dom p ) = ( Seg ( len f ) ) & (for n being Nat holds (n in ( Seg ( len f ) ) implies P[ n,( p . n ) ]))) from FINSEQ_1:sch 5(A1);
reconsider p as (PFuncFinSequence of A);
take p;
thus ( len p ) = ( len f ) by A2,FINSEQ_1:def 3;
let n;
assume n in ( dom p );
hence thesis by A2;
end;
uniqueness
proof
let f1 being (PFuncFinSequence of ( TS ( DTConUA (f,D) ) )),f2 being (PFuncFinSequence of ( TS ( DTConUA (f,D) ) ));
assume that
A3: ( len f1 ) = ( len f )
and
A4: (for n holds (n in ( dom f1 ) implies ( f1 . n ) = ( FreeOpZAO (n,f,D) )))
and
A5: ( len f2 ) = ( len f )
and
A6: (for n holds (n in ( dom f2 ) implies ( f2 . n ) = ( FreeOpZAO (n,f,D) )));
A7: ( dom f1 ) = ( Seg ( len f1 ) ) by FINSEQ_1:def 3;
A8: ( dom f ) = ( Seg ( len f ) ) by FINSEQ_1:def 3;
A9: ( dom f2 ) = ( Seg ( len f2 ) ) by FINSEQ_1:def 3;
(for n being Nat holds (n in ( dom f ) implies ( f1 . n ) = ( f2 . n )))
proof
let n being Nat;
assume A10: n in ( dom f );
then ( f1 . n ) = ( FreeOpZAO (n,f,D) ) by A3,A4,A8,A7;
hence thesis by A5,A6,A8,A9,A10;
end;
hence thesis by A3,A5,A8,A7,FINSEQ_2:9;
end;
end;
