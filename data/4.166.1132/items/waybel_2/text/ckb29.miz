environ
vocabularies XBOOLE_0,FUNCT_1,SUBSET_1,RELAT_1,RELAT_2,LATTICE3,ORDERS_2,XXREAL_0,TREES_2,WAYBEL_0,YELLOW_0,LATTICES,EQREL_1,ORDINAL2,ZFMISC_1,TARSKI,STRUCT_0,MCART_1,SEQM_3,REWRITE1,FINSET_1,WELLORD1,CAT_1,YELLOW_2,FINSUB_1,WELLORD2,YELLOW_1,CARD_FIL,LATTICE2,WAYBEL_1,WAYBEL_2,CARD_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,FINSUB_1,RELAT_1,FUNCT_1,RELSET_1,TOLER_1,FINSET_1,PARTFUN1,BINOP_1,FUNCT_2,DOMAIN_1,STRUCT_0,ORDERS_2,ORDERS_3,LATTICE3,YELLOW_0,WAYBEL_0,YELLOW_1,YELLOW_2,WAYBEL_1,YELLOW_3,YELLOW_4,CKB28;
definitions WAYBEL_1,YELLOW_0,LATTICE3,ORDERS_3,TARSKI,WAYBEL_0,XBOOLE_0,WELLORD1,BINOP_1,RELAT_1,STRUCT_0,CKB28;
theorems FINSUB_1,FUNCT_1,FUNCT_2,LATTICE3,MCART_1,ORDERS_2,ORDERS_3,RELAT_1,STRUCT_0,TARSKI,WAYBEL_0,YELLOW_0,ZFMISC_1,YELLOW_1,YELLOW_2,WAYBEL_1,YELLOW_3,YELLOW_4,FUNCT_5,TEX_1,XBOOLE_1,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB15,CKB16,CKB17,CKB18,CKB21,CKB22,CKB23,CKB25,CKB26,CKB27,CKB28;
schemes FINSET_1,YELLOW_3,FUNCT_2,CKB24;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,FINSET_1,FINSUB_1,STRUCT_0,LATTICE3,YELLOW_0,WAYBEL_0,YELLOW_1,YELLOW_2,WAYBEL_1,YELLOW_3,YELLOW_4,CARD_1,ORDINAL1,ORDERS_2,RELSET_1,CKB1,CKB2,CKB3,CKB14,CKB19,CKB20;
constructors DOMAIN_1,FINSUB_1,TOLER_1,ORDERS_3,WAYBEL_1,YELLOW_3,YELLOW_4,RELSET_1,CKB28;
requirements SUBSET,BOOLE,NUMERALS;
begin
definition
let L being non empty RelStr;
let J being set;
let f being (Function of J,(the carrier of L));
func FinSups f -> (prenet of L)
means
:Def2: (ex g being (Function of ( Fin J ),(the carrier of L)) st (for x being (Element of ( Fin J )) holds (( g . x ) = ( sup ( f .: x ) ) & it = NetStr (# ( Fin J ),( RelIncl ( Fin J ) ),g #))));
existence
proof
deffunc F((Element of ( Fin J ))) = ( sup ( f .: $1 ) );
A1: (for x being (Element of ( Fin J )) holds F(x) in (the carrier of L));
consider g being (Function of ( Fin J ),(the carrier of L)) such that A2: (for x being (Element of ( Fin J )) holds ( g . x ) = F(x)) from FUNCT_2:sch 8(A1);
set M = NetStr (# ( Fin J ),( RelIncl ( Fin J ) ),g #);
M is  directed
proof
let x being (Element of M),y being (Element of M);
assume that
x in ( [#] M )
and
y in ( [#] M );
reconsider x1 = x,y1 = y as (Element of ( Fin J ));
reconsider z = ( x1 \/ y1 ) as (Element of M);
take z;
thus z in ( [#] M );
A3: ( InclPoset ( Fin J ) ) = RelStr (# ( Fin J ),( RelIncl ( Fin J ) ) #) by YELLOW_1:def 1;
then reconsider x2 = x,y2 = y,z1 = z as (Element of ( InclPoset ( Fin J ) ));
y c= z by XBOOLE_1:7;
then A4: y2 <= z1 by YELLOW_1:3;
x c= z by XBOOLE_1:7;
then x2 <= z1 by YELLOW_1:3;
hence thesis by A3,A4,YELLOW_0:1;
end;
then reconsider M as (prenet of L);
take M;
thus thesis by A2;
end;
uniqueness
proof
let A being (prenet of L),B being (prenet of L);
assume that
A5: (ex g being (Function of ( Fin J ),(the carrier of L)) st (for x being (Element of ( Fin J )) holds (( g . x ) = ( sup ( f .: x ) ) & A = NetStr (# ( Fin J ),( RelIncl ( Fin J ) ),g #))))
and
A6: (ex g being (Function of ( Fin J ),(the carrier of L)) st (for x being (Element of ( Fin J )) holds (( g . x ) = ( sup ( f .: x ) ) & B = NetStr (# ( Fin J ),( RelIncl ( Fin J ) ),g #))));
consider g1 being (Function of ( Fin J ),(the carrier of L)) such that A7: (for x being (Element of ( Fin J )) holds (( g1 . x ) = ( sup ( f .: x ) ) & A = NetStr (# ( Fin J ),( RelIncl ( Fin J ) ),g1 #))) by A5;
consider g2 being (Function of ( Fin J ),(the carrier of L)) such that A8: (for x being (Element of ( Fin J )) holds (( g2 . x ) = ( sup ( f .: x ) ) & B = NetStr (# ( Fin J ),( RelIncl ( Fin J ) ),g2 #))) by A6;
(for x being set holds (x in ( Fin J ) implies ( g1 . x ) = ( g2 . x )))
proof
let x being set;
assume A9: x in ( Fin J );
hence ( g1 . x ) = ( sup ( f .: x ) ) by A7
.= ( g2 . x ) by A8,A9;
end;
hence thesis by A7,A8,FUNCT_2:12;
end;
end;
