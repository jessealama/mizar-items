environ
vocabularies NUMBERS,BCIALG_1,SUBSET_1,INT_1,FUNCT_1,NAT_1,XBOOLE_0,ZFMISC_1,STRUCT_0,CARD_1,SUPINF_2,ARYTM_3,RELAT_1,NEWTON,COMPLEX1,XXREAL_0,WAYBEL15,ARYTM_1,GROUP_1,INT_2,UNIALG_2,CARD_FIL,RCOMP_1,BCIALG_2,REALSET1,MSSUBFAM,FUNCOP_1,MOD_4,GROUP_6,TARSKI,FUNCT_2,CHORD,WELLORD1,EQREL_1,ALG_1,CARD_3,BINOP_1,BCIALG_6;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,REALSET1,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,BINOP_1,STRUCT_0,BCIALG_1,FUNCOP_1,NAT_1,NUMBERS,INT_2,XXREAL_0,BINOP_2,NAT_D,INT_1,BCIALG_2,EQREL_1,CKB1,CKB2,CKB3,CKB4;
definitions TARSKI,REALSET1,BINOP_1,STRUCT_0,BCIALG_1,FUNCT_1,BCIALG_2,XBOOLE_0,CKB2,CKB3,CKB4;
theorems TARSKI,FUNCT_1,FUNCT_2,FUNCOP_1,BINOP_1,ZFMISC_1,RELAT_1,XBOOLE_0,XBOOLE_1,BCIALG_1,GROUP_6,BCIALG_2,EQREL_1,RELSET_1,ABSVALUE,ORDINAL1,NAT_D,XREAL_1,INT_1,XCMPLX_1,INT_2,NAT_1,NEWTON,XXREAL_0,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16;
schemes BINOP_1,FUNCT_2,NAT_1,INT_1,CLASSES1;
registrations XBOOLE_0,RELSET_1,REALSET1,STRUCT_0,BCIALG_1,BCIALG_2,FUNCT_2,PARTFUN1,NAT_1,XREAL_0,ORDINAL1,XXREAL_0,INT_1;
constructors BINOP_1,REALSET1,BCIALG_2,REAL_1,BINOP_2,FINSEQOP,SUPINF_1,SEQ_1,NAT_D,RELSET_1,CKB1,CKB2,CKB3;
requirements BOOLE,SUBSET,NUMERALS,ARITHM,REAL;
begin
reserve X for BCI-algebra;
reserve a for (Element of ( AtomSet X ));
reserve i for Integer;
theorem
Th13: ( a |^ i ) in ( AtomSet X )
proof
defpred P[ Integer ]
 means
( a |^ $1 ) in ( AtomSet X );
( 0. X ) in ( AtomSet X );
then A1: P[ ( 0 ) ] by CKB2:def 1;
per cases ;
suppose A2: i >= ( 0 );

A3: (for i2 being Integer holds (i2 >= ( 0 ) implies (P[ i2 ] implies P[ ( i2 + 1 ) ])))
proof
let i2 being Integer;
assume i2 >= ( 0 );
then reconsider j = i2 as (Element of ( NAT )) by INT_1:3;
( ( ( a |^ ( j + 1 ) ) ` ) ` ) = ( ( ( a \ ( ( a |^ j ) ` ) ) ` ) ` ) by CKB2:def 1;
then ( ( ( a |^ ( j + 1 ) ) ` ) ` ) = ( ( ( a ` ) \ ( ( ( a |^ j ) ` ) ` ) ) ` ) by BCIALG_1:9;
then ( ( ( a |^ ( j + 1 ) ) ` ) ` ) = ( ( ( a ` ) ` ) \ ( ( ( ( a |^ j ) ` ) ` ) ` ) ) by BCIALG_1:9;
then A4: ( ( ( a |^ ( j + 1 ) ) ` ) ` ) = ( a \ ( ( ( ( a |^ j ) ` ) ` ) ` ) ) by BCIALG_1:29;
assume P[ i2 ];
then ( ( ( a |^ ( j + 1 ) ) ` ) ` ) = ( a \ ( ( a |^ j ) ` ) ) by A4,BCIALG_1:29;
then ( ( ( a |^ ( j + 1 ) ) ` ) ` ) = ( a |^ ( j + 1 ) ) by CKB2:def 1;
hence thesis by BCIALG_1:29;
end;
(for i holds (i >= ( 0 ) implies P[ i ])) from INT_1:sch 2(A1,A3);
hence thesis by A2;
end;
suppose A5: i <= ( 0 );

A6: (for i2 being Integer holds (i2 <= ( 0 ) implies (P[ i2 ] implies P[ ( i2 - 1 ) ])))
proof
let i2 being Integer;
assume A7: i2 <= ( 0 );
assume A8: P[ i2 ];
per cases  by A7;
suppose A9: i2 = ( 0 );

( ( ( a ` ) ` ) ` ) = ( a ` ) by BCIALG_1:8;
then ( a ` ) in ( AtomSet X ) by BCIALG_1:29;
hence thesis by A9,CKB9:1;
end;
suppose A10: i2 < ( 0 );

set j = i2;
reconsider m = ( - j ) as (Element of ( NAT )) by A10,INT_1:3;
( a |^ ( j - 1 ) ) = ( ( BCI-power X ) . (( a ` ),( abs ( j - 1 ) )) ) by A10,CKB3:def 1;
then ( a |^ ( j - 1 ) ) = ( ( BCI-power X ) . (( a ` ),( - ( j - 1 ) )) ) by A10,ABSVALUE:def 1;
then ( a |^ ( j - 1 ) ) = ( ( a ` ) |^ ( m + 1 ) );
then ( a |^ ( j - 1 ) ) = ( ( a ` ) \ ( ( ( a ` ) |^ m ) ` ) ) by CKB2:def 1;
then ( a |^ ( j - 1 ) ) = ( ( a ` ) \ ( ( a |^ ( - ( - j ) ) ) ` ) ) by CKB14:1;
then ( ( ( a |^ ( j - 1 ) ) ` ) ` ) = ( ( ( ( a ` ) ` ) \ ( ( ( a |^ j ) ` ) ` ) ) ` ) by BCIALG_1:9;
then ( ( ( a |^ ( j - 1 ) ) ` ) ` ) = ( ( a \ ( ( ( a |^ j ) ` ) ` ) ) ` ) by BCIALG_1:29;
then ( ( ( a |^ ( j - 1 ) ) ` ) ` ) = ( ( a \ ( a |^ j ) ) ` ) by A8,BCIALG_1:29;
then ( ( ( a |^ ( j - 1 ) ) ` ) ` ) = ( ( a ` ) \ ( ( a |^ ( - m ) ) ` ) ) by BCIALG_1:9;
then ( ( ( a |^ ( j - 1 ) ) ` ) ` ) = ( ( a ` ) \ ( ( ( a ` ) |^ m ) ` ) ) by CKB14:1;
then ( ( ( a |^ ( j - 1 ) ) ` ) ` ) = ( ( a ` ) |^ ( m + 1 ) ) by CKB2:def 1;
then ( ( ( a |^ ( j - 1 ) ) ` ) ` ) = ( ( BCI-power X ) . (( a ` ),( - ( j - 1 ) )) );
then ( ( ( a |^ ( j - 1 ) ) ` ) ` ) = ( ( BCI-power X ) . (( a ` ),( abs ( j - 1 ) )) ) by A10,ABSVALUE:def 1;
then ( ( ( a |^ ( j - 1 ) ) ` ) ` ) = ( a |^ ( j - 1 ) ) by A10,CKB3:def 1;
hence thesis by BCIALG_1:29;
end;
end;
(for i holds (i <= ( 0 ) implies P[ i ])) from INT_1:sch 3(A1,A6);
hence thesis by A5;
end;
end;
