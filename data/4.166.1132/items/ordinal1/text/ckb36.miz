environ
vocabularies TARSKI,XBOOLE_0,SUBSET_1,FUNCT_1,RELAT_1,ZFMISC_1,ORDINAL1;
notations TARSKI,XBOOLE_0,ZFMISC_1,ENUMSET1,SUBSET_1,RELAT_1,FUNCT_1,CKB6,CKB12,CKB13,CKB15,CKB18,CKB20,CKB26;
definitions TARSKI,XBOOLE_0,RELAT_1,FUNCT_1,CKB6,CKB12,CKB13,CKB15,CKB26;
theorems TARSKI,XBOOLE_0,FUNCT_1,ZFMISC_1,ENUMSET1,RELAT_1,XBOOLE_1,SUBSET_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB30,CKB31,CKB35;
schemes XBOOLE_0,FUNCT_1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,CKB7,CKB16,CKB17,CKB19,CKB29,CKB32,CKB33,CKB34;
constructors TARSKI,ENUMSET1,SUBSET_1,FUNCT_1,CKB6,CKB12,CKB13,CKB15,CKB26;
requirements SUBSET,BOOLE;
begin
reserve a for set;
reserve X for set;
reserve Y for set;
reserve A for Ordinal;
reserve B for Ordinal;
reserve C for Ordinal;
theorem
Th32: ((X c= A & X <> ( {} )) implies (ex C st (C in X & (for B holds (B in X implies C c= B)))))
proof
set a = the (Element of X);
assume that
A1: X c= A
and
A2: X <> ( {} );
a in X by A2;
then consider Y such that A3: Y in X and A4: (not (ex a st (a in X & a in Y))) by TARSKI:2;
Y is Ordinal by A1,A3,CKB24:1;
then consider C such that A5: C = Y;
take C;
thus C in X by A3,A5;
let B;
assume B in X;
then (not B in C) by A4,A5;
then (B = C or C in B) by CKB25:1;
hence thesis by CKB12:def 1;
end;
