environ
vocabularies XBOOLE_0,SUBSET_1,PARTFUN1,RELAT_1,FUNCT_1,TARSKI,FUNCOP_1;
notations TARSKI,XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,FUNCOP_1,CKB6,CKB12,CKB21;
definitions TARSKI,XBOOLE_0,FUNCT_1;
theorems TARSKI,FUNCT_1,FUNCT_2,GRFUNC_1,FUNCOP_1,PARTFUN1,RELAT_1,RELSET_1,XBOOLE_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB7,CKB8,CKB9,CKB10,CKB11,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27;
schemes FUNCT_2,XBOOLE_0;
registrations FUNCT_1,RELSET_1;
constructors PARTFUN1,FUNCOP_1,RELSET_1,CKB6,CKB12,CKB21;
requirements SUBSET,BOOLE;
begin
reserve C for non empty set;
reserve D for non empty set;
reserve c1 for (Element of C);
reserve c2 for (Element of C);
reserve f for (PartFunc of C,D);
theorem
((c1 in ( dom f ) & c2 in ( dom f )) implies ( f .: { c1,c2 } ) = { ( f /. c1 ),( f /. c2 ) })
proof
assume that
A1: c1 in ( dom f )
and
A2: c2 in ( dom f );
thus ( f .: { c1,c2 } ) = { ( (f qua Function) . c1 ),( (f qua Function) . c2 ) } by A1,A2,FUNCT_1:60
.= { ( f /. c1 ),( (f qua Function) . c2 ) } by A1,PARTFUN1:def 6
.= { ( f /. c1 ),( f /. c2 ) } by A2,PARTFUN1:def 6;
end;
