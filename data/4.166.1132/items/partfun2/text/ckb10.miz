environ
vocabularies XBOOLE_0,SUBSET_1,PARTFUN1,RELAT_1,FUNCT_1,TARSKI,FUNCOP_1;
notations TARSKI,XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,FUNCOP_1,CKB6;
definitions TARSKI,XBOOLE_0,FUNCT_1;
theorems TARSKI,FUNCT_1,FUNCT_2,GRFUNC_1,FUNCOP_1,PARTFUN1,RELAT_1,RELSET_1,XBOOLE_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB7,CKB8,CKB9;
schemes FUNCT_2,XBOOLE_0;
registrations FUNCT_1,RELSET_1;
constructors PARTFUN1,FUNCOP_1,RELSET_1,CKB6;
requirements SUBSET,BOOLE;
begin
reserve x for set;
reserve y for set;
reserve C for non  empty set;
reserve D for non  empty set;
reserve c1 for (Element of C);
reserve c2 for (Element of C);
reserve f for (PartFunc of C,D);
theorem
((for c1 holds (for c2 holds (((c1 in ( dom f ) & c2 in ( dom f )) & ( f /. c1 ) = ( f /. c2 )) implies c1 = c2))) implies f is  one-to-one)
proof
assume A1: (for c1 holds (for c2 holds (((c1 in ( dom f ) & c2 in ( dom f )) & ( f /. c1 ) = ( f /. c2 )) implies c1 = c2)));
now
let x;
let y;
assume that
A2: x in ( dom f )
and
A3: y in ( dom f )
and
A4: ( (f qua Function) . x ) = ( (f qua Function) . y );
reconsider y1 = y as (Element of C) by A3;
reconsider x1 = x as (Element of C) by A2;
( f /. x1 ) = ( (f qua Function) . y1 ) by A2,A4,PARTFUN1:def 6;
then ( f /. x1 ) = ( f /. y1 ) by A3,PARTFUN1:def 6;
hence x = y by A1,A2,A3;
end;
hence thesis by FUNCT_1:def 4;
end;
