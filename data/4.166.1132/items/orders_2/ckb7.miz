environ
vocabularies STRUCT_0,RELAT_1,XBOOLE_0,PARTFUN1,RELAT_2,ORDERS_1,SUBSET_1,XXREAL_0,ARYTM_3,TREES_2,TARSKI,WELLORD1,FUNCT_1,ZFMISC_1,ORDERS_2,CARD_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,RELAT_2,FUNCT_1,RELSET_1,PARTFUN1,CARD_1,WELLORD1,DOMAIN_1,STRUCT_0,ORDERS_1,CKB1,CKB3,CKB4,CKB5,CKB6;
definitions RELAT_1,RELAT_2,TARSKI,WELLORD1,STRUCT_0,XBOOLE_0,ORDERS_1,CKB3,CKB4,CKB5,CKB6;
theorems RELAT_1,RELAT_2,TARSKI,WELLORD1,ZFMISC_1,XBOOLE_0,XBOOLE_1,PARTFUN1,ORDERS_1,CKB3,CKB4,CKB5,CKB6;
schemes XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,RELSET_1,ORDERS_1,STRUCT_0,PARTFUN1,CARD_1,ORDINAL1,CKB1,CKB2;
constructors RELAT_2,WELLORD1,PARTFUN1,DOMAIN_1,ORDERS_1,PRE_TOPC,RELSET_1,SETFAM_1,CKB1,CKB3,CKB4,CKB5,CKB6;
requirements BOOLE,SUBSET,NUMERALS;
begin
registration
cluster  reflexive  transitive  antisymmetric  strict  total 1 -element for RelStr;
existence
proof
set R = the (Order of { ( {} ) });
take L = RelStr (# { ( {} ) },R #);
A1: ( field R ) = (the carrier of L) by ORDERS_1:12;
hence (the InternalRel of L) is_reflexive_in (the carrier of L) by RELAT_2:def 9;
thus (the InternalRel of L) is_transitive_in (the carrier of L) by A1,RELAT_2:def 16;
thus (the InternalRel of L) is_antisymmetric_in (the carrier of L) by A1,RELAT_2:def 12;
thus L is  strict;
thus (the InternalRel of L) is  total;
thus (the carrier of L) is 1 -element;
end;
end;
