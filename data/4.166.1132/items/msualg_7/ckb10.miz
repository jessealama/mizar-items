environ
vocabularies NUMBERS,XBOOLE_0,PBOOLE,REAL_1,STRUCT_0,MSUALG_5,EQREL_1,RELAT_1,FUNCT_1,MSUALG_4,TARSKI,ZFMISC_1,XXREAL_2,SUBSET_1,LATTICES,CLOSURE2,SETFAM_1,FUNCT_4,REWRITE1,LATTICE3,MSSUBFAM,NAT_LAT,REALSET1,XXREAL_0,XXREAL_1,REAL_LAT,BINOP_1,SUPINF_1,ORDINAL2,ARYTM_1,ORDINAL1,CARD_1,ARYTM_3,MSUALG_7;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,SUPINF_1,ORDINAL1,XXREAL_0,REAL_1,XXREAL_2,STRUCT_0,RELSET_1,DOMAIN_1,FUNCT_1,PARTFUN1,FUNCT_2,NUMBERS,RCOMP_1,EQREL_1,BINOP_1,REALSET1,PBOOLE,LATTICES,LATTICE3,NAT_LAT,REAL_LAT,MSUALG_3,MSUALG_4,MSUALG_5,SETFAM_1,MSSUBFAM,CLOSURE2;
definitions TARSKI,LATTICE3,XBOOLE_0,BINOP_1,REALSET1,XXREAL_2;
theorems TARSKI,PBOOLE,MSSUBFAM,LATTICE3,VECTSP_8,MSUALG_4,MSUALG_5,ZFMISC_1,SETFAM_1,EQREL_1,LATTICES,NAT_LAT,FUNCT_1,REAL_LAT,FUNCT_2,RCOMP_1,MSUALG_3,CLOSURE2,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,NUMBERS,RELAT_1,XXREAL_2,CKB1,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9;
schemes DOMAIN_1;
registrations XBOOLE_0,SUBSET_1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,MEMBERED,REALSET1,MSSUBFAM,STRUCT_0,LATTICES,LATTICE3,CLOSURE2,CKB3;
constructors BINOP_1,REAL_1,SQUARE_1,SUPINF_1,RCOMP_1,REALSET1,MSSUBFAM,REAL_LAT,LATTICE3,MSUALG_3,MSUALG_5,CLOSURE2,XXREAL_2,RELSET_1;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
definition
let L being non empty LattStr;
redefine attr L is  complete
means
:Def1: (for X being (Subset of L) holds (ex a being (Element of L) st (X is_less_than a & (for b being (Element of L) holds (X is_less_than b implies a [= b)))));
compatibility
proof
thus (L is  complete implies (for X being (Subset of L) holds (ex a being (Element of L) st (X is_less_than a & (for b being (Element of L) holds (X is_less_than b implies a [= b)))))) by LATTICE3:def 18;
assume A1: (for X being (Subset of L) holds (ex a being (Element of L) st (X is_less_than a & (for b being (Element of L) holds (X is_less_than b implies a [= b)))));
let X being set;
defpred P[ set ]
 means
$1 in X;
set Y = { c where c is (Element of L): P[ c ] };
Y is (Subset of L) from DOMAIN_1:sch 7;
then consider p being (Element of L) such that A2: Y is_less_than p and A3: (for r being (Element of L) holds (Y is_less_than r implies p [= r)) by A1;
take p;
thus X is_less_than p
proof
let q being (Element of L);
assume q in X;
then q in Y;
hence thesis by A2,LATTICE3:def 17;
end;

let r being (Element of L);
assume A4: X is_less_than r;
now
let q being (Element of L);
assume q in Y;
then (ex v being (Element of L) st (q = v & v in X));
hence q [= r by A4,LATTICE3:def 17;
end;
then Y is_less_than r by LATTICE3:def 17;
hence thesis by A3;
end;
end;
