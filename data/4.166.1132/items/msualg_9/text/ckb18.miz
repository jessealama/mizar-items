environ
vocabularies XBOOLE_0,STRUCT_0,MSUALG_1,PBOOLE,FINSET_1,SUBSET_1,CLOSURE2,TARSKI,RELAT_1,FUNCT_1,FINSEQ_1,MARGREL1,NAT_1,PRALG_2,CARD_3,RLVECT_2,MSAFREE,PRELAMB,ZFMISC_1,PRALG_1,MCART_1,EQREL_1,FUNCOP_1,MSUALG_3,TREES_4,LANG1,NUMBERS,MSUALG_2,MEMBER_1,GROUP_6,WELLORD1,PARTFUN1,FUNCT_6,FINSEQ_4,PZFMISC1,CARD_1,MSUALG_4,MSUALG_5,SETFAM_1,FUNCT_4,RELAT_2,MSUALG_9;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,NAT_1,RELAT_1,RELAT_2,STRUCT_0,SETFAM_1,FUNCT_1,PBOOLE,EQREL_1,RELSET_1,PARTFUN1,FUNCT_2,FINSEQ_1,LANG1,MCART_1,FINSET_1,CARD_3,TREES_4,FUNCT_6,DTCONSTR,MSUALG_1,MSUALG_2,PRALG_1,PRALG_3,MSUALG_3,MSAFREE,PRALG_2,FUNCOP_1,MSAFREE2,MSUALG_4,PZFMISC1,MSSUBFAM,CLOSURE2,MSUALG_5;
definitions FINSEQ_1,FUNCT_1,MSAFREE2,FINSET_1,MSUALG_1,MSUALG_3,PZFMISC1,MSUALG_4,PBOOLE,TARSKI,XBOOLE_0;
theorems CARD_3,CLOSURE1,CLOSURE2,EXTENS_1,EQREL_1,FINSEQ_1,FUNCOP_1,FUNCT_1,FUNCT_2,MCART_1,MSAFREE,MSAFREE2,MSSUBFAM,MSUALG_1,MSUALG_2,MSUALG_3,MSUALG_4,MSUALG_5,MSUALG_6,MSUALG_7,PARTFUN1,PBOOLE,PRALG_1,PRALG_2,PZFMISC1,RELAT_2,SETFAM_1,TARSKI,RELSET_1,XBOOLE_0,XBOOLE_1,ORDERS_1,RELAT_1,FINSET_1,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17;
schemes MSSUBFAM,PBOOLE,MSUALG_8;
registrations XBOOLE_0,RELAT_1,ORDINAL1,FUNCT_2,FUNCOP_1,FINSET_1,EQREL_1,PRE_CIRC,PZFMISC1,MSSUBFAM,STRUCT_0,FUNCT_1,MSUALG_1,MSUALG_2,PRALG_2,MSUALG_3,MSAFREE,MSUALG_4,MSUALG_5,CLOSURE2,CARD_3,RELSET_1,PRALG_1,PBOOLE,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7;
constructors SETFAM_1,BINOP_1,PZFMISC1,MSUALG_3,MSAFREE2,MSUALG_5,CLOSURE1,CLOSURE2,PRALG_3,RELSET_1,CIRCUIT1,NAT_1,FUNCT_6,FUNCT_5;
requirements SUBSET,BOOLE;
begin
reserve S for non  empty non  void ManySortedSign;
theorem
(for X being  non-empty (ManySortedSet of (the carrier of S)) holds ( Reverse X ) is  "1-1")
proof
let X being  non-empty (ManySortedSet of (the carrier of S));
(for i being set holds (i in (the carrier of S) implies ( ( Reverse X ) . i ) is  one-to-one))
proof
set D = ( DTConMSA X );
let i being set;
assume i in (the carrier of S);
then reconsider s = i as (SortSymbol of S);
set f = ( ( Reverse X ) . s );
let x1 being set;
let x2 being set;
assume that
A1: x1 in ( dom ( ( Reverse X ) . i ) )
and
A2: x2 in ( dom ( ( Reverse X ) . i ) )
and
A3: ( ( ( Reverse X ) . i ) . x1 ) = ( ( ( Reverse X ) . i ) . x2 );
A4: f = ( Reverse (s,X) ) by MSAFREE:def 18;
then A5: ( dom f ) = ( FreeGen (s,X) ) by FUNCT_2:def 1;
then consider a2 being set such that A6: a2 in ( X . s ) and A7: x2 = ( root-tree [ a2,s ] ) by A2,MSAFREE:def 15;
A8: [ a2,s ] in ( Terminals D ) by A6,MSAFREE:7;
then reconsider t2 = [ a2,s ] as (Symbol of D);
( t2 `2 ) = s by MCART_1:7;
then ( root-tree t2 ) in { ( root-tree tt ) where tt is (Symbol of D): (tt in ( Terminals D ) & ( tt `2 ) = s) } by A8;
then ( root-tree t2 ) in ( FreeGen (s,X) ) by MSAFREE:13;
then A9: ( f . x2 ) = ( [ a2,s ] `1 ) by A4,A7,MSAFREE:def 17
.= a2 by MCART_1:7;
consider a1 being set such that A10: a1 in ( X . s ) and A11: x1 = ( root-tree [ a1,s ] ) by A1,A5,MSAFREE:def 15;
A12: [ a1,s ] in ( Terminals D ) by A10,MSAFREE:7;
then reconsider t1 = [ a1,s ] as (Symbol of D);
( t1 `2 ) = s by MCART_1:7;
then ( root-tree t1 ) in { ( root-tree tt ) where tt is (Symbol of D): (tt in ( Terminals D ) & ( tt `2 ) = s) } by A12;
then ( root-tree t1 ) in ( FreeGen (s,X) ) by MSAFREE:13;
then ( f . x1 ) = ( [ a1,s ] `1 ) by A4,A11,MSAFREE:def 17
.= a1 by MCART_1:7;
hence thesis by A3,A11,A7,A9;
end;
hence thesis by MSUALG_3:1;
end;
