environ
vocabularies NUMBERS,SUBSET_1,FINSEQ_1,AMI_1,SCMFSA_2,RELAT_1,SCMFSA_7,ARYTM_3,ARYTM_1,TARSKI,FUNCT_1,XXREAL_0,PARTFUN1,CAT_1,NAT_1,CARD_1,FUNCOP_1,SCMFSA6A,ORDINAL4,AMI_3,FUNCT_4,INT_1,GRAPHSP,FSM_1,CIRCUIT2,SCMNORM,SCMFSA6B,GLIB_000,SF_MASTR,MSUALG_1,XBOOLE_0,PRE_POLY,UNIALG_2,AMISTD_2,SCMFSA7B,ORDINAL1,AFINSQ_1,PBOOLE,SCMFSA6C,STRUCT_0,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,COMPLEX1,NAT_1,INT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FINSEQ_1,FINSEQ_2,FUNCT_4,DOMAIN_1,VALUED_1,AFINSQ_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,FUNCT_7,SCMFSA_2,AMISTD_1,AMISTD_2,FUNCOP_1,XXREAL_0,ENUMSET1,NAT_D,PBOOLE,AFINSQ_2,SCMFSA_7,SCMFSA6A,SF_MASTR,SCMFSA6B,INT_2,PRE_POLY;
definitions TARSKI,AFINSQ_1,RELAT_1,FINSEQ_1,FINSEQ_2,SCMFSA_2,FUNCOP_1,SCMFSA6A,SCMFSA6B,COMPOS_1,AMISTD_1,SCMFSA_7,EXTPRO_1,MEMSTR_0,AFINSQ_2;
theorems SCMFSA_7,NAT_1,GRFUNC_1,FUNCT_1,FUNCT_4,FUNCT_7,ENUMSET1,SCMFSA_2,FUNCOP_1,INT_1,RELAT_1,TARSKI,SCMFSA6A,SF_MASTR,SCMFSA6B,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,AFINSQ_1,COMPOS_1,AFINSQ_2,CARD_1,EXTPRO_1,PARTFUN1,AMISTD_1,MEMSTR_0,CKB1,CKB2,CKB4,CKB6,CKB7;
schemes NAT_1,AFINSQ_1;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,FUNCOP_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,FUNCT_7,SCMFSA_2,SF_MASTR,SCMFSA6B,ORDINAL1,FINSET_1,FINSEQ_2,CARD_1,AFINSQ_1,COMPOS_1,AFINSQ_2,ORDINAL5,EXTPRO_1,PBOOLE,FUNCT_4,STRUCT_0,SCMFSA6A,SCMFSA_4,MEMSTR_0,VALUED_1,SCMFSA10,AMISTD_2,CKB3,CKB5;
constructors ENUMSET1,XXREAL_0,REAL_1,SCMFSA_7,SCMFSA6A,SF_MASTR,SCMFSA6B,NAT_D,RELSET_1,PRE_POLY,DOMAIN_1,AFINSQ_2,PARTFUN3,PBOOLE,AMISTD_1,AMISTD_2,AMI_3,MEMSTR_0;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve P for (Instruction-Sequence of ( SCM+FSA ));
theorem
Lm3: (for c0 being (Element of ( NAT )) holds (for s being c0 -started (State of ( SCM+FSA )) holds (for P being (Instruction-Sequence of ( SCM+FSA )) holds (for a being Int-Location holds (for k being Integer holds ((for c being (Element of ( NAT )) holds (c < ( len ( aSeq (a,k) ) ) implies ( ( aSeq (a,k) ) . c ) = ( P . ( c0 + c ) ))) implies (for i being (Element of ( NAT )) holds (i <= ( len ( aSeq (a,k) ) ) implies ( IC ( Comput (P,s,i) ) ) = ( c0 + i )))))))))
proof
let c0 being (Element of ( NAT ));
let s being c0 -started (State of ( SCM+FSA ));
let P being (Instruction-Sequence of ( SCM+FSA ));
A1: ( dom P ) = ( NAT ) by PARTFUN1:def 2;
A2: ( IC s ) = c0 by MEMSTR_0:def 9;
let a being Int-Location;
let k being Integer;
assume A3: (for c being (Element of ( NAT )) holds (c < ( len ( aSeq (a,k) ) ) implies ( ( aSeq (a,k) ) . c ) = ( P . ( c0 + c ) )));
A4: (for c being (Element of ( NAT )) holds (c in ( dom ( aSeq (a,k) ) ) implies ( ( aSeq (a,k) ) . c ) = ( P . ( c0 + c ) )))
proof
let c being (Element of ( NAT ));
assume c in ( dom ( aSeq (a,k) ) );
then c < ( len ( aSeq (a,k) ) ) by AFINSQ_1:66;
hence ( ( aSeq (a,k) ) . c ) = ( P . ( c0 + c ) ) by A3;
end;
per cases ;
suppose A5: k > ( 0 );

then reconsider k9 = k as (Element of ( NAT )) by INT_1:3;
consider k1 being (Element of ( NAT )) such that A6: ( k1 + 1 ) = k9 and A7: ( aSeq (a,k9) ) = ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( AddTo (a,( intloc ( 0 ) )) ) ) ) by A5,SCMFSA_7:def 2;
defpred Q[ Nat ]
 means
($1 <= k9 implies ( IC ( Comput (P,s,$1) ) ) = ( c0 + $1 ));
A8: ( len ( aSeq (a,k9) ) ) = ( ( len <% ( a := ( intloc ( 0 ) ) ) %> ) + ( len ( k1 --> ( AddTo (a,( intloc ( 0 ) )) ) ) ) ) by A7,AFINSQ_1:17
.= ( 1 + ( len ( k1 --> ( AddTo (a,( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:34
.= k9 by A6,CARD_1:64;
(for i being (Element of ( NAT )) holds (i <= ( len ( aSeq (a,k9) ) ) implies ( IC ( Comput (P,s,i) ) ) = ( c0 + i )))
proof
A9:now
let i being (Element of ( NAT ));
assume that
A10: 1 <= i
and
A11: i < k9;
reconsider i1 = ( i - 1 ) as (Element of ( NAT )) by A10,INT_1:5;
i = ( i1 + 1 );
then i1 < k1 by A11,A6,XREAL_1:6;
then A12: i1 in k1 by NAT_1:44;
A13: ( len ( k1 --> ( AddTo (a,( intloc ( 0 ) )) ) ) ) = k1 by CARD_1:64;
( len <% ( a := ( intloc ( 0 ) ) ) %> ) = 1 by AFINSQ_1:33;
hence ( ( aSeq (a,k9) ) . i ) = ( ( k1 --> ( AddTo (a,( intloc ( 0 ) )) ) ) . ( i - 1 ) ) by A10,A7,A13,A6,A11,AFINSQ_1:18
.= ( AddTo (a,( intloc ( 0 ) )) ) by A12,FUNCOP_1:7;
end;
A14: (for i being (Element of ( NAT )) holds (i < k9 implies i in ( dom ( aSeq (a,k9) ) ))) by A8,NAT_1:44;
A15:now
let i being (Element of ( NAT ));
assume that
A16: ( 0 ) < i
and
A17: i < k9;
A18: ( ( 0 ) + 1 ) <= i by A16,NAT_1:13;
thus ( P . ( c0 + i ) ) = ( ( aSeq (a,k9) ) . i ) by A4,A14,A17
.= ( AddTo (a,( intloc ( 0 ) )) ) by A9,A18,A17;
end;
A19: ( P . ( c0 + ( 0 ) ) ) = ( ( aSeq (a,k9) ) . ( 0 ) ) by A3,A5,A8
.= ( a := ( intloc ( 0 ) ) ) by A7,AFINSQ_1:35;
A20:now
let n being (Element of ( NAT ));
assume n = ( 0 );
hence A21: ( Comput (P,s,n) ) = s by EXTPRO_1:2;
thus ( CurInstr (P,( Comput (P,s,n) )) ) = ( P . ( IC ( Comput (P,s,n) ) ) ) by A1,PARTFUN1:def 6
.= ( a := ( intloc ( 0 ) ) ) by A19,A21,MEMSTR_0:def 9;
thus ( Comput (P,s,( n + 1 )) ) = ( Following (P,( Comput (P,s,n) )) ) by EXTPRO_1:3
.= ( Exec (( a := ( intloc ( 0 ) ) ),s) ) by A21,A2,A19,A1,PARTFUN1:def 6;
end;
A22: (for n being (Element of ( NAT )) holds (Q[ n ] implies Q[ ( n + 1 ) ]))
proof
let n being (Element of ( NAT ));
assume A23: Q[ n ];
assume A24: ( n + 1 ) <= k9;
per cases ;
suppose A25: n = ( 0 );

hence ( IC ( Comput (P,s,( n + 1 )) ) ) = ( ( Exec (( a := ( intloc ( 0 ) ) ),s) ) . ( IC ( SCM+FSA ) ) ) by A20
.= ( ( succ c0 ) + n ) by A2,A25,SCMFSA_2:63
.= ( ( c0 + 1 ) + n ) by NAT_1:38
.= ( c0 + ( n + 1 ) );
end;
suppose A26: n > ( 0 );

A27: n < k9 by A24,NAT_1:13;
A28: ( n + ( 0 ) ) <= ( n + 1 ) by XREAL_1:7;
A29: ( CurInstr (P,( Comput (P,s,n) )) ) = ( P . ( c0 + n ) ) by A23,A24,A28,A1,PARTFUN1:def 6,XXREAL_0:2
.= ( AddTo (a,( intloc ( 0 ) )) ) by A15,A26,A27;
A30: ( Comput (P,s,( n + 1 )) ) = ( Following (P,( Comput (P,s,n) )) ) by EXTPRO_1:3
.= ( Exec (( AddTo (a,( intloc ( 0 ) )) ),( Comput (P,s,n) )) ) by A29;
thus ( IC ( Comput (P,s,( n + 1 )) ) ) = ( succ ( IC ( Comput (P,s,n) ) ) ) by A30,SCMFSA_2:64
.= ( ( c0 + n ) + 1 ) by A23,A24,A28,NAT_1:38,XXREAL_0:2
.= ( c0 + ( n + 1 ) );
end;
end;
let i being (Element of ( NAT ));
assume A31: i <= ( len ( aSeq (a,k9) ) );
A32: Q[ ( 0 ) ] by A2,EXTPRO_1:2;
(for i being (Element of ( NAT )) holds Q[ i ]) from NAT_1:sch 1(A32,A22);
hence thesis by A8,A31;
end;
hence thesis;
end;
suppose A33: k <= ( 0 );

then reconsider mk = ( - k ) as (Element of ( NAT )) by INT_1:3;
defpred Q[ Nat ]
 means
($1 <= ( ( mk + 1 ) + 1 ) implies ( IC ( Comput (P,s,$1) ) ) = ( c0 + $1 ));
consider k1 being (Element of ( NAT )) such that A34: ( k1 + k ) = 1 and A35: ( aSeq (a,k) ) = ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ) by A33,SCMFSA_7:def 2;
A36: ( len ( aSeq (a,k) ) ) = ( ( len <% ( a := ( intloc ( 0 ) ) ) %> ) + ( len ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ) ) by A35,AFINSQ_1:17
.= ( 1 + ( len ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:34
.= ( ( mk + 1 ) + 1 ) by A34,CARD_1:64;
(for i being (Element of ( NAT )) holds (i <= ( len ( aSeq (a,k) ) ) implies ( IC ( Comput (P,s,i) ) ) = ( c0 + i )))
proof
A37:now
let i being (Element of ( NAT ));
assume that
A38: 1 <= i
and
A39: i < ( ( mk + 1 ) + 1 );
A40: ( i - 1 ) < ( ( ( mk + 1 ) + 1 ) - 1 ) by A39,XREAL_1:9;
reconsider i1 = ( i - 1 ) as (Element of ( NAT )) by A38,INT_1:5;
A41: i1 in k1 by A34,A40,NAT_1:44;
A42: ( len ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ) = k1 by CARD_1:64;
( len <% ( a := ( intloc ( 0 ) ) ) %> ) = 1 by AFINSQ_1:33;
hence ( ( aSeq (a,k) ) . i ) = ( ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) . ( i - 1 ) ) by A35,A38,A42,A34,A39,AFINSQ_1:18
.= ( SubFrom (a,( intloc ( 0 ) )) ) by A41,FUNCOP_1:7;
end;
A43: (for i being (Element of ( NAT )) holds (i < ( ( mk + 1 ) + 1 ) implies i in ( dom ( aSeq (a,k) ) ))) by A36,NAT_1:44;
A44:now
let i being (Element of ( NAT ));
assume that
A45: ( 0 ) < i
and
A46: i < ( ( mk + 1 ) + 1 );
A47: ( ( 0 ) + 1 ) <= i by A45,NAT_1:13;
thus ( P . ( c0 + i ) ) = ( ( aSeq (a,k) ) . i ) by A4,A43,A46
.= ( SubFrom (a,( intloc ( 0 ) )) ) by A37,A47,A46;
end;
A48: ( P . ( c0 + ( 0 ) ) ) = ( ( aSeq (a,k) ) . ( 0 ) ) by A3,A36
.= ( a := ( intloc ( 0 ) ) ) by A35,AFINSQ_1:35;
A49: (for n being (Element of ( NAT )) holds (n = ( 0 ) implies ((( Comput (P,s,n) ) = s & ( CurInstr (P,( Comput (P,s,n) )) ) = ( a := ( intloc ( 0 ) ) )) & ( Comput (P,s,( n + 1 )) ) = ( Exec (( a := ( intloc ( 0 ) ) ),s) ))))
proof
let n being (Element of ( NAT ));
assume n = ( 0 );
hence A50: ( Comput (P,s,n) ) = s by EXTPRO_1:2;
thus ( CurInstr (P,( Comput (P,s,n) )) ) = ( P . ( IC ( Comput (P,s,n) ) ) ) by A1,PARTFUN1:def 6
.= ( a := ( intloc ( 0 ) ) ) by A48,A50,MEMSTR_0:def 9;
thus ( Comput (P,s,( n + 1 )) ) = ( Following (P,( Comput (P,s,n) )) ) by EXTPRO_1:3
.= ( Exec (( a := ( intloc ( 0 ) ) ),s) ) by A50,A2,A48,A1,PARTFUN1:def 6;
end;
A51: (for n being (Element of ( NAT )) holds (Q[ n ] implies Q[ ( n + 1 ) ]))
proof
let n being (Element of ( NAT ));
assume A52: Q[ n ];
assume A53: ( n + 1 ) <= ( ( mk + 1 ) + 1 );
per cases ;
suppose A54: n = ( 0 );

hence ( IC ( Comput (P,s,( n + 1 )) ) ) = ( ( Exec (( a := ( intloc ( 0 ) ) ),s) ) . ( IC ( SCM+FSA ) ) ) by A49
.= ( succ ( c0 + n ) ) by A2,A54,SCMFSA_2:63
.= ( ( c0 + n ) + 1 ) by NAT_1:38
.= ( c0 + ( n + 1 ) );
end;
suppose A55: n > ( 0 );

A56: n < ( ( mk + 1 ) + 1 ) by A53,NAT_1:13;
A57: ( n + ( 0 ) ) <= ( n + 1 ) by XREAL_1:7;
A58: ( CurInstr (P,( Comput (P,s,n) )) ) = ( P . ( c0 + n ) ) by A52,A53,A57,A1,PARTFUN1:def 6,XXREAL_0:2
.= ( SubFrom (a,( intloc ( 0 ) )) ) by A44,A55,A56;
A59: ( Comput (P,s,( n + 1 )) ) = ( Following (P,( Comput (P,s,n) )) ) by EXTPRO_1:3
.= ( Exec (( SubFrom (a,( intloc ( 0 ) )) ),( Comput (P,s,n) )) ) by A58;
thus ( IC ( Comput (P,s,( n + 1 )) ) ) = ( succ ( IC ( Comput (P,s,n) ) ) ) by A59,SCMFSA_2:65
.= ( ( c0 + n ) + 1 ) by A52,A53,A57,NAT_1:38,XXREAL_0:2
.= ( c0 + ( n + 1 ) );
end;
end;
let i being (Element of ( NAT ));
assume A60: i <= ( len ( aSeq (a,k) ) );
A61: Q[ ( 0 ) ] by A2,EXTPRO_1:2;
(for i being (Element of ( NAT )) holds Q[ i ]) from NAT_1:sch 1(A61,A51);
hence thesis by A36,A60;
end;
hence thesis;
end;
end;
