environ
vocabularies NUMBERS,SUBSET_1,FINSEQ_1,AMI_1,SCMFSA_2,RELAT_1,SCMFSA_7,ARYTM_3,ARYTM_1,TARSKI,FUNCT_1,XXREAL_0,PARTFUN1,CAT_1,NAT_1,CARD_1,FUNCOP_1,SCMFSA6A,ORDINAL4,AMI_3,FUNCT_4,INT_1,GRAPHSP,FSM_1,CIRCUIT2,SCMNORM,SCMFSA6B,GLIB_000,SF_MASTR,MSUALG_1,XBOOLE_0,PRE_POLY,UNIALG_2,AMISTD_2,SCMFSA7B,ORDINAL1,AFINSQ_1,PBOOLE,SCMFSA6C,STRUCT_0,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,COMPLEX1,NAT_1,INT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FINSEQ_1,FINSEQ_2,FUNCT_4,DOMAIN_1,VALUED_1,AFINSQ_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,FUNCT_7,SCMFSA_2,AMISTD_1,AMISTD_2,FUNCOP_1,XXREAL_0,ENUMSET1,NAT_D,PBOOLE,AFINSQ_2,SCMFSA_7,SCMFSA6A,SF_MASTR,SCMFSA6B,INT_2,PRE_POLY;
definitions TARSKI,AFINSQ_1,RELAT_1,FINSEQ_1,FINSEQ_2,SCMFSA_2,FUNCOP_1,SCMFSA6A,SCMFSA6B,COMPOS_1,AMISTD_1,SCMFSA_7,EXTPRO_1,MEMSTR_0,AFINSQ_2;
theorems SCMFSA_7,NAT_1,GRFUNC_1,FUNCT_1,FUNCT_4,FUNCT_7,ENUMSET1,SCMFSA_2,FUNCOP_1,INT_1,RELAT_1,TARSKI,SCMFSA6A,SF_MASTR,SCMFSA6B,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,AFINSQ_1,COMPOS_1,AFINSQ_2,CARD_1,EXTPRO_1,PARTFUN1,AMISTD_1,MEMSTR_0,CKB1,CKB2;
schemes NAT_1,AFINSQ_1;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,FUNCOP_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,FUNCT_7,SCMFSA_2,SF_MASTR,SCMFSA6B,ORDINAL1,FINSET_1,FINSEQ_2,CARD_1,AFINSQ_1,COMPOS_1,AFINSQ_2,ORDINAL5,EXTPRO_1,PBOOLE,FUNCT_4,STRUCT_0,SCMFSA6A,SCMFSA_4,MEMSTR_0,VALUED_1,SCMFSA10,AMISTD_2,CKB3;
constructors ENUMSET1,XXREAL_0,REAL_1,SCMFSA_7,SCMFSA6A,SF_MASTR,SCMFSA6B,NAT_D,RELSET_1,PRE_POLY,DOMAIN_1,AFINSQ_2,PARTFUN3,PBOOLE,AMISTD_1,AMISTD_2,AMI_3,MEMSTR_0;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve P for (Instruction-Sequence of ( SCM+FSA ));
theorem
Lm1: (for s being (State of ( SCM+FSA )) holds (( IC s ) = ( 0 ) implies (for P being (Instruction-Sequence of ( SCM+FSA )) holds (for a being Int-Location holds (for k being Integer holds (( a := k ) c= P implies P halts_on s))))))
proof
let s being (State of ( SCM+FSA ));
assume A1: ( IC s ) = ( 0 );
let P being (Instruction-Sequence of ( SCM+FSA ));
A2: ( dom P ) = ( NAT ) by PARTFUN1:def 2;
let a being Int-Location;
let k being Integer;
assume A3: ( a := k ) c= P;
per cases ;
suppose A4: k > ( 0 );

then consider k1 being (Element of ( NAT )) such that A5: ( k1 + 1 ) = k and A6: ( a := k ) = ( ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( AddTo (a,( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> ) by SCMFSA_7:def 1;
A7: ( len ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( AddTo (a,( intloc ( 0 ) )) ) ) ) ) = ( ( len <% ( a := ( intloc ( 0 ) ) ) %> ) + ( len ( k1 --> ( AddTo (a,( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:17
.= ( 1 + ( len ( k1 --> ( AddTo (a,( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:34
.= k by A5,CARD_1:64;
set f = ( ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( AddTo (a,( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> );
A8: ( f . ( 0 ) ) = ( ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( ( k1 --> ( AddTo (a,( intloc ( 0 ) )) ) ) ^ <% ( halt ( SCM+FSA ) ) %> ) ) . ( 0 ) ) by AFINSQ_1:27
.= ( a := ( intloc ( 0 ) ) ) by AFINSQ_1:35;
reconsider k as (Element of ( NAT )) by A4,INT_1:3;
A9: ( len f ) = ( ( len ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( AddTo (a,( intloc ( 0 ) )) ) ) ) ) + ( len <% ( halt ( SCM+FSA ) ) %> ) ) by AFINSQ_1:17
.= ( k + 1 ) by A7,AFINSQ_1:34;
A10:now
let i being (Element of ( NAT ));
assume that
A11: i <= k;
i < ( k + 1 ) by A11,NAT_1:13;
hence i in ( dom f ) by A9,NAT_1:44;
end;
A12:now
let i being (Element of ( NAT ));
assume that
A13: i <= k;
i in ( dom f ) by A10,A13;
hence ( P . i ) = ( f . i ) by A3,A6,GRFUNC_1:2;
end;
then A14: ( P . ( 0 ) ) = ( a := ( intloc ( 0 ) ) ) by A8;
A15:now
let n being (Element of ( NAT ));
assume n = ( 0 );
hence A16: ( Comput (P,s,n) ) = s by EXTPRO_1:2;
hence ( CurInstr (P,( Comput (P,s,n) )) ) = ( a := ( intloc ( 0 ) ) ) by A1,A14,A2,PARTFUN1:def 6;
thus ( Comput (P,s,( n + 1 )) ) = ( Following (P,( Comput (P,s,n) )) ) by EXTPRO_1:3
.= ( Exec (( a := ( intloc ( 0 ) ) ),s) ) by A16,A1,A14,A2,PARTFUN1:def 6;
end;
A17:now
let i being (Element of ( NAT ));
assume that
A18: 1 <= i
and
A19: i < k;
reconsider i1 = ( i - 1 ) as (Element of ( NAT )) by A18,INT_1:5;
( i - 1 ) < ( k - 1 ) by A19,XREAL_1:9;
then A20: i1 in k1 by A5,NAT_1:44;
A21: ( len <% ( a := ( intloc ( 0 ) ) ) %> ) = 1 by AFINSQ_1:33;
A22: ( len ( k1 --> ( AddTo (a,( intloc ( 0 ) )) ) ) ) = k1 by CARD_1:64;
i in ( dom ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( AddTo (a,( intloc ( 0 ) )) ) ) ) ) by A19,A7,NAT_1:44;
hence ( f . i ) = ( ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( AddTo (a,( intloc ( 0 ) )) ) ) ) . i ) by AFINSQ_1:def 3
.= ( ( k1 --> ( AddTo (a,( intloc ( 0 ) )) ) ) . ( i - 1 ) ) by A18,A19,A21,A22,A5,AFINSQ_1:18
.= ( AddTo (a,( intloc ( 0 ) )) ) by A20,FUNCOP_1:7;
end;
A23:now
let i being (Element of ( NAT ));
assume that
A24: ( 0 ) < i
and
A25: i < k;
A26: ( ( 0 ) + 1 ) <= i by A24,NAT_1:13;
thus ( P . i ) = ( f . i ) by A12,A25
.= ( AddTo (a,( intloc ( 0 ) )) ) by A17,A26,A25;
end;
A27: (for i being (Element of ( NAT )) holds (i <= k implies ( IC ( Comput (P,s,i) ) ) = i))
proof
defpred P[ Nat ]
 means
($1 <= k implies ( IC ( Comput (P,s,$1) ) ) = $1);
let i being (Element of ( NAT ));
assume A28: i <= k;
A29: (for n being (Element of ( NAT )) holds (P[ n ] implies P[ ( n + 1 ) ]))
proof
let n being (Element of ( NAT ));
assume A30: P[ n ];
assume A31: ( n + 1 ) <= k;
then A32: n < k by NAT_1:13;
per cases ;
suppose A33: n = ( 0 );

hence ( IC ( Comput (P,s,( n + 1 )) ) ) = ( ( Exec (( a := ( intloc ( 0 ) ) ),s) ) . ( IC ( SCM+FSA ) ) ) by A15
.= ( succ n ) by A1,A33,SCMFSA_2:63
.= ( n + 1 ) by NAT_1:38;
end;
suppose A34: n > ( 0 );

( n + ( 0 ) ) <= ( n + 1 ) by XREAL_1:7;
then A35: ( CurInstr (P,( Comput (P,s,n) )) ) = ( P . n ) by A30,A31,A2,PARTFUN1:def 6,XXREAL_0:2
.= ( AddTo (a,( intloc ( 0 ) )) ) by A23,A32,A34;
A36: ( Comput (P,s,( n + 1 )) ) = ( Following (P,( Comput (P,s,n) )) ) by EXTPRO_1:3
.= ( Exec (( AddTo (a,( intloc ( 0 ) )) ),( Comput (P,s,n) )) ) by A35;
thus ( IC ( Comput (P,s,( n + 1 )) ) ) = ( succ ( IC ( Comput (P,s,n) ) ) ) by A36,SCMFSA_2:64
.= ( n + 1 ) by A30,A31,NAT_1:13,NAT_1:38;
end;
end;
A37: P[ ( 0 ) ] by A1,EXTPRO_1:2;
(for i being (Element of ( NAT )) holds P[ i ]) from NAT_1:sch 1(A37,A29);
hence thesis by A28;
end;
k < ( k + ( len <% ( halt ( SCM+FSA ) ) %> ) ) by XREAL_1:29;
then A38: ( f . k ) = ( <% ( halt ( SCM+FSA ) ) %> . ( k - k ) ) by A7,AFINSQ_1:18
.= ( halt ( SCM+FSA ) ) by AFINSQ_1:34;
( CurInstr (P,( Comput (P,s,k) )) ) = ( P . ( IC ( Comput (P,s,k) ) ) ) by A2,PARTFUN1:def 6
.= ( P . k ) by A27
.= ( halt ( SCM+FSA ) ) by A38,A12;
hence thesis by EXTPRO_1:29;
end;
suppose A39: k <= ( 0 );

then reconsider mk = ( - k ) as (Element of ( NAT )) by INT_1:3;
consider k1 being (Element of ( NAT )) such that A40: ( k1 + k ) = 1 and A41: ( a := k ) = ( ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> ) by A39,SCMFSA_7:def 1;
A42: ( len ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ) ) = ( ( len <% ( a := ( intloc ( 0 ) ) ) %> ) + ( len ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:17
.= ( 1 + ( len ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:34
.= ( ( mk + 1 ) + 1 ) by A40,CARD_1:64;
set f = ( ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> );
A43: ( f . ( 0 ) ) = ( ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ^ <% ( halt ( SCM+FSA ) ) %> ) ) . ( 0 ) ) by AFINSQ_1:27
.= ( a := ( intloc ( 0 ) ) ) by AFINSQ_1:35;
A44: ( len f ) = ( ( len ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ) ) + ( len <% ( halt ( SCM+FSA ) ) %> ) ) by AFINSQ_1:17
.= ( ( ( mk + 1 ) + 1 ) + 1 ) by A42,AFINSQ_1:34;
A45:now
let i being (Element of ( NAT ));
assume that
( 0 ) <= i
and
A46: i <= ( ( mk + 1 ) + 1 );
i < ( ( ( mk + 1 ) + 1 ) + 1 ) by A46,NAT_1:13;
hence i in ( dom f ) by A44,NAT_1:44;
end;
A47:now
let i being (Element of ( NAT ));
assume that
( 0 ) <= i
and
A48: i <= ( ( mk + 1 ) + 1 );
i in ( dom f ) by A45,A48;
hence ( P . i ) = ( f . i ) by A3,A41,GRFUNC_1:2;
end;
then A49: ( P . ( 0 ) ) = ( a := ( intloc ( 0 ) ) ) by A43;
A50:now
let n being (Element of ( NAT ));
assume n = ( 0 );
hence A51: ( Comput (P,s,n) ) = s by EXTPRO_1:2;
hence ( CurInstr (P,( Comput (P,s,n) )) ) = ( a := ( intloc ( 0 ) ) ) by A1,A49,A2,PARTFUN1:def 6;
thus ( Comput (P,s,( n + 1 )) ) = ( Following (P,( Comput (P,s,n) )) ) by EXTPRO_1:3
.= ( Exec (( a := ( intloc ( 0 ) ) ),s) ) by A51,A1,A49,A2,PARTFUN1:def 6;
end;
A52:now
A53: ( len <% ( a := ( intloc ( 0 ) ) ) %> ) = 1 by AFINSQ_1:33;
let i being (Element of ( NAT ));
assume that
A54: 1 <= i
and
A55: i < ( ( mk + 1 ) + 1 );
reconsider i1 = ( i - 1 ) as (Element of ( NAT )) by A54,INT_1:5;
( i - 1 ) < ( ( k1 + 1 ) - 1 ) by A55,A40,XREAL_1:9;
then A56: i1 in k1 by NAT_1:44;
A57: ( len ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ) = k1 by CARD_1:64;
i in ( dom ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ) ) by A55,A42,NAT_1:44;
hence ( f . i ) = ( ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ) . i ) by AFINSQ_1:def 3
.= ( ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) . ( i - 1 ) ) by A40,A54,A55,A53,A57,AFINSQ_1:18
.= ( SubFrom (a,( intloc ( 0 ) )) ) by A56,FUNCOP_1:7;
end;
A58:now
let i being (Element of ( NAT ));
assume that
A59: ( 0 ) < i
and
A60: i < ( ( mk + 1 ) + 1 );
A61: ( ( 0 ) + 1 ) <= i by A59,NAT_1:13;
thus ( P . i ) = ( f . i ) by A47,A60
.= ( SubFrom (a,( intloc ( 0 ) )) ) by A52,A61,A60;
end;
A62: (for i being (Element of ( NAT )) holds (i <= ( ( mk + 1 ) + 1 ) implies ( IC ( Comput (P,s,i) ) ) = i))
proof
defpred P[ Nat ]
 means
($1 <= ( ( mk + 1 ) + 1 ) implies ( IC ( Comput (P,s,$1) ) ) = $1);
let i being (Element of ( NAT ));
assume A63: i <= ( ( mk + 1 ) + 1 );
A64: (for n being (Element of ( NAT )) holds (P[ n ] implies P[ ( n + 1 ) ]))
proof
let n being (Element of ( NAT ));
assume A65: P[ n ];
assume A66: ( n + 1 ) <= ( ( mk + 1 ) + 1 );
then A67: n < ( ( mk + 1 ) + 1 ) by NAT_1:13;
per cases ;
suppose A68: n = ( 0 );

hence ( IC ( Comput (P,s,( n + 1 )) ) ) = ( ( Exec (( a := ( intloc ( 0 ) ) ),s) ) . ( IC ( SCM+FSA ) ) ) by A50
.= ( succ n ) by A1,A68,SCMFSA_2:63
.= ( n + 1 ) by NAT_1:38;
end;
suppose A69: n > ( 0 );

( n + ( 0 ) ) <= ( n + 1 ) by XREAL_1:7;
then A70: ( CurInstr (P,( Comput (P,s,n) )) ) = ( P . n ) by A65,A66,A2,PARTFUN1:def 6,XXREAL_0:2
.= ( SubFrom (a,( intloc ( 0 ) )) ) by A58,A67,A69;
A71: ( Comput (P,s,( n + 1 )) ) = ( Following (P,( Comput (P,s,n) )) ) by EXTPRO_1:3
.= ( Exec (( SubFrom (a,( intloc ( 0 ) )) ),( Comput (P,s,n) )) ) by A70;
thus ( IC ( Comput (P,s,( n + 1 )) ) ) = ( succ ( IC ( Comput (P,s,n) ) ) ) by A71,SCMFSA_2:65
.= ( n + 1 ) by A65,A66,NAT_1:13,NAT_1:38;
end;
end;
A72: P[ ( 0 ) ] by A1,EXTPRO_1:2;
(for i being (Element of ( NAT )) holds P[ i ]) from NAT_1:sch 1(A72,A64);
hence thesis by A63;
end;
((( len ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ) ) <= ( ( mk + 1 ) + 1 ) & ( ( mk + 1 ) + 1 ) < ( ( len ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ) ) + ( len <% ( halt ( SCM+FSA ) ) %> ) )) implies ( f . ( ( mk + 1 ) + 1 ) ) = ( <% ( halt ( SCM+FSA ) ) %> . ( ( ( mk + 1 ) + 1 ) - ( len ( <% ( a := ( intloc ( 0 ) ) ) %> ^ ( k1 --> ( SubFrom (a,( intloc ( 0 ) )) ) ) ) ) ) )) by AFINSQ_1:18;
then A73: ( f . ( ( mk + 1 ) + 1 ) ) = ( halt ( SCM+FSA ) ) by A42,AFINSQ_1:34,XREAL_1:29;
( CurInstr (P,( Comput (P,s,( ( mk + 1 ) + 1 )) )) ) = ( P . ( IC ( Comput (P,s,( ( mk + 1 ) + 1 )) ) ) ) by A2,PARTFUN1:def 6
.= ( P . ( ( mk + 1 ) + 1 ) ) by A62
.= ( halt ( SCM+FSA ) ) by A73,A47;
hence thesis by EXTPRO_1:29;
end;
end;
