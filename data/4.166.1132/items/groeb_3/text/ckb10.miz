environ
vocabularies NUMBERS,PRE_POLY,ARYTM_3,ARYTM_1,ORDINAL1,BAGORDER,XXREAL_0,RLVECT_1,ALGSTR_0,VECTSP_1,LATTICES,VECTSP_2,ZFMISC_1,VALUED_0,POLYNOM7,CAT_3,RELAT_2,POLYNOM1,BROUWER,SUPINF_2,XCMPLX_0,SUBSET_1,RELAT_1,FUNCT_1,XBOOLE_0,TARSKI,ALGSTR_1,CARD_1,FUNCT_7,QC_LANG1,TERMORD,BINOP_1,POLYRED,REWRITE1,FINSEQ_1,STRUCT_0,MCART_1,FINSET_1,FUNCT_4,FUNCOP_1,ALGSEQ_1,ORDERS_2,WAYBEL_4,RUSUB_4,GROEB_2,MESFUNC1,GROEB_1,GROEB_3;
notations TARSKI,SUBSET_1,RELAT_1,XBOOLE_0,RELAT_2,CARD_1,ORDINAL1,NUMBERS,XCMPLX_0,XXREAL_0,NAT_1,FUNCT_1,RELSET_1,FUNCT_2,FUNCT_4,FUNCOP_1,PRE_POLY,STRUCT_0,ALGSTR_0,GROUP_1,ALGSTR_1,RLVECT_1,VFUNCT_1,FINSET_1,MCART_1,FINSEQ_1,VECTSP_2,VECTSP_1,POLYNOM2,POLYNOM7,ORDERS_2,FUNCT_7,REWRITE1,BAGORDER,TERMORD,GROEB_1,POLYRED,GROEB_2,WAYBEL_4,POLYNOM1;
definitions TARSKI,STRUCT_0;
theorems TARSKI,VECTSP_1,POLYNOM1,RLVECT_1,NAT_1,INT_1,POLYNOM7,REWRITE1,XBOOLE_0,TERMORD,CARD_1,FUNCT_1,XBOOLE_1,POLYRED,FUNCT_2,RELAT_1,BAGORDER,ALGSTR_1,CARD_2,GROEB_1,FUNCT_4,FUNCOP_1,FINSET_1,VECTSP_2,RELSET_1,WAYBEL_4,MCART_1,GROEB_2,GROUP_1,FUNCT_7,POLYNOM2,FINSEQ_3,XREAL_1,XXREAL_0,STRUCT_0,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9;
schemes FUNCT_2,NAT_1,INT_1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,INT_1,CARD_1,REWRITE1,STRUCT_0,VECTSP_1,ORDERS_2,ALGSTR_1,POLYNOM1,POLYNOM2,POLYNOM4,POLYNOM7,TERMORD,POLYRED,ORDINAL1,VALUED_0,ALGSTR_0,PRE_POLY,VFUNCT_1,FUNCT_2,RELSET_1;
constructors XXREAL_0,REWRITE1,VECTSP_2,WAYBEL_4,POLYNOM2,BAGORDER,TERMORD,POLYRED,GROEB_1,GROEB_2,RELSET_1,PBOOLE,FUNCT_7,VFUNCT_1;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
theorem
Th10: (for n being Ordinal holds (for L being  add-associative  right_complementable  left_zeroed  right_zeroed  well-unital  distributive  domRing-like non trivial doubleLoopStr holds (for p being (Polynomial of n,L) holds (for m being  non-zero (Monomial of n,L) holds ( card ( Support p ) ) = ( card ( Support ( m *' p ) ) )))))
proof
let n being Ordinal;
let L being  add-associative  right_complementable  left_zeroed  right_zeroed  well-unital  distributive  domRing-like non trivial doubleLoopStr;
let p being (Polynomial of n,L);
let m being  non-zero (Monomial of n,L);
defpred P[ set,set ]
 means
$2 = ( ( term m ) + ( ( In ($1,( Bags n )) ) @ ) );
set T = the  admissible  connected (TermOrder of n);
m <> ( 0_ (n,L) ) by POLYNOM7:def 1;
then ( Support m ) <> ( {} ) by POLYNOM7:1;
then A1: ( Support m ) = { ( term m ) } by POLYNOM7:7;
A2: (for x being set holds (x in ( Support p ) implies (ex y being set st (y in ( Support ( m *' p ) ) & P[ x,y ]))))
proof
let x being set;
assume A3: x in ( Support p );
then reconsider x9 = x as (Element of ( Bags n ));
A4: x9 = ( In (x9,( Bags n )) ) by FUNCT_7:def 1
.= ( ( In (x9,( Bags n )) ) @ ) by POLYNOM2:def 3;
( ( term m ) + x9 ) in ( Support ( m *' p ) ) by A3,CKB8:1;
hence thesis by A4;
end;
consider f being (Function of ( Support p ),( Support ( m *' p ) )) such that A5: (for x being set holds (x in ( Support p ) implies P[ x,( f . x ) ])) from FUNCT_2:sch 1(A2);
A6:now
assume A7: ( Support ( m *' p ) ) = ( {} );
now
assume ( Support p ) <> ( {} );
then p <> ( 0_ (n,L) ) by POLYNOM7:1;
then reconsider p9 = p as  non-zero (Polynomial of n,L) by POLYNOM7:def 1;
( ( HT (m,T) ) + ( HT (p9,T) ) ) in ( Support ( m *' p9 ) ) by TERMORD:29;
hence contradiction by A7;
end;
hence ( Support p ) = ( {} );
end;
then A8: ( Support p ) c= ( dom f ) by FUNCT_2:def 1;
A9: ( Support ( m *' p ) ) c= { ( s + t ) where s is (Element of ( Bags n )),t is (Element of ( Bags n )): (s in ( Support m ) & t in ( Support p )) } by TERMORD:30;
A10:now
let u being set;
assume A11: u in ( Support ( m *' p ) );
then reconsider u9 = u as (Element of ( Bags n ));
u9 in { ( s + t ) where s is (Element of ( Bags n )),t is (Element of ( Bags n )): (s in ( Support m ) & t in ( Support p )) } by A9,A11;
then consider s being (Element of ( Bags n )),t being (Element of ( Bags n )) such that A12: (u9 = ( s + t ) & s in ( Support m )) and A13: t in ( Support p );
A14: t in ( dom f ) by A6,A13,FUNCT_2:def 1;
A15: t = ( In (t,( Bags n )) ) by FUNCT_7:def 1
.= ( ( In (t,( Bags n )) ) @ ) by POLYNOM2:def 3;
u9 = ( ( term m ) + t ) by A1,A12,TARSKI:def 1;
then u9 = ( f . t ) by A5,A13,A15;
hence u in ( f .: ( Support p ) ) by A14,FUNCT_1:def 6;
end;
now
let x1 being set,x2 being set;
assume that
A16: x1 in ( Support p )
and
A17: x2 in ( Support p )
and
A18: ( f . x1 ) = ( f . x2 );
reconsider x19 = x1,x29 = x2 as (Element of ( Bags n )) by A16,A17;
A19: x29 = ( In (x29,( Bags n )) ) by FUNCT_7:def 1
.= ( ( In (x29,( Bags n )) ) @ ) by POLYNOM2:def 3;
x19 = ( In (x19,( Bags n )) ) by FUNCT_7:def 1
.= ( ( In (x19,( Bags n )) ) @ ) by POLYNOM2:def 3;
then ( ( term m ) + x19 ) = ( f . x29 ) by A5,A16,A18
.= ( ( term m ) + x29 ) by A5,A17,A19;
hence x1 = ( ( x29 + ( term m ) ) -' ( term m ) ) by PRE_POLY:48
.= x2 by PRE_POLY:48;
end;
then f is  one-to-one by A6,FUNCT_2:19;
then A20: ( Support p ),( f .: ( Support p ) ) are_equipotent  by A8,CARD_1:33;
(for u being set holds (u in ( f .: ( Support p ) ) implies u in ( Support ( m *' p ) )));
then ( f .: ( Support p ) ) = ( Support ( m *' p ) ) by A10,TARSKI:1;
hence thesis by A20,CARD_1:5;
end;
