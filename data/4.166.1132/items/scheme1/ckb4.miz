environ
vocabularies NUMBERS,SUBSET_1,REAL_1,RELAT_1,ARYTM_3,INT_1,CARD_1,XXREAL_0,SEQ_1,VALUED_0,FUNCT_1,NAT_1,TARSKI,ORDINAL2,ARYTM_1,XBOOLE_0,PARTFUN1,ZFMISC_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,XCMPLX_0,REAL_1,NAT_1,NAT_D,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,VALUED_0,SEQ_1,XXREAL_0,RECDEF_1;
definitions TARSKI,XBOOLE_0;
theorems ZFMISC_1,NAT_1,FUNCT_1,FUNCT_2,SEQM_3,PARTFUN1,RELSET_1,XBOOLE_1,NAT_D,ORDINAL1,XXREAL_0,CKB1,CKB2,CKB3;
schemes NAT_1,FUNCT_2,RECDEF_1,SUBSET_1,CLASSES1,XBOOLE_0;
registrations ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,SEQM_3,VALUED_0;
constructors PARTFUN1,XXREAL_0,NAT_1,NAT_D,SEQ_1,SEQM_3,RECDEF_1,MEMBERED,RELSET_1;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve n for (Element of ( NAT ));
reserve m for (Element of ( NAT ));
theorem
Th4: (for n holds (ex m st ((((n = ( 5 * m ) or n = ( ( 5 * m ) + 1 )) or n = ( ( 5 * m ) + 2 )) or n = ( ( 5 * m ) + 3 )) or n = ( ( 5 * m ) + 4 ))))
proof
let n;
take ( n div 5 );
set l = ( n mod 5 );
A1: ((((l = ( 0 ) or l = 1) or l = 2) or l = 3) or l = 4)
proof
l < ( 4 + 1 ) by NAT_D:1;
then A2: l <= ( 3 + 1 ) by NAT_1:13;
now
per cases  by A2,NAT_1:8;
suppose A3: l <= 3;

now
per cases  by A3,NAT_1:8;
suppose A4: l <= 2;

now
per cases  by A4,NAT_1:8;
suppose A5: l <= 1;

now
per cases  by A5,NAT_1:8;
suppose l <= ( 0 );

hence thesis by NAT_1:2;
end;
suppose l = ( ( 0 ) + 1 );

hence thesis;
end;
end;
hence thesis;
end;
suppose l = ( 1 + 1 );

hence thesis;
end;
end;
hence thesis;
end;
suppose l = ( 2 + 1 );

hence thesis;
end;
end;
hence thesis;
end;
suppose l = ( 3 + 1 );

hence thesis;
end;
end;
hence thesis;
end;
n = ( ( 5 * ( n div 5 ) ) + ( n mod 5 ) ) by NAT_D:2;
hence thesis by A1;
end;
