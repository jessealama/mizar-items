environ
vocabularies NUMBERS,SUBSET_1,REAL_1,RELAT_1,ARYTM_3,INT_1,CARD_1,XXREAL_0,SEQ_1,VALUED_0,FUNCT_1,NAT_1,TARSKI,ORDINAL2,ARYTM_1,XBOOLE_0,PARTFUN1,ZFMISC_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,XCMPLX_0,REAL_1,NAT_1,NAT_D,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,VALUED_0,SEQ_1,XXREAL_0,RECDEF_1;
definitions TARSKI,XBOOLE_0;
theorems ZFMISC_1,NAT_1,FUNCT_1,FUNCT_2,SEQM_3,PARTFUN1,RELSET_1,XBOOLE_1,NAT_D,ORDINAL1,XXREAL_0;
schemes NAT_1,FUNCT_2,RECDEF_1,SUBSET_1,CLASSES1,XBOOLE_0;
registrations ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,SEQM_3,VALUED_0;
constructors PARTFUN1,XXREAL_0,NAT_1,NAT_D,SEQ_1,SEQM_3,RECDEF_1,MEMBERED,RELSET_1;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve n for (Element of ( NAT ));
reserve m for (Element of ( NAT ));
theorem
(for n holds (ex m st (n = ( 2 * m ) or n = ( ( 2 * m ) + 1 ))))
proof
let n;
take ( n div 2 );
set k = ( n mod 2 );
A1: (k = ( 0 ) or k = 1)
proof
k < ( 1 + 1 ) by NAT_D:1;
then A2: k <= ( ( 0 ) + 1 ) by NAT_1:13;
now
per cases  by A2,NAT_1:8;
suppose k <= ( 0 );

hence thesis by NAT_1:2;
end;
suppose k = ( ( 0 ) + 1 );

hence thesis;
end;
end;
hence thesis;
end;
n = ( ( 2 * ( n div 2 ) ) + ( n mod 2 ) ) by NAT_D:2;
hence thesis by A1;
end;
