environ
vocabularies NUMBERS,SUBSET_1,REAL_1,RELAT_1,ARYTM_3,INT_1,CARD_1,XXREAL_0,SEQ_1,VALUED_0,FUNCT_1,NAT_1,TARSKI,ORDINAL2,ARYTM_1,XBOOLE_0,PARTFUN1,ZFMISC_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,XCMPLX_0,REAL_1,NAT_1,NAT_D,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,VALUED_0,SEQ_1,XXREAL_0,RECDEF_1;
definitions TARSKI,XBOOLE_0;
theorems ZFMISC_1,NAT_1,FUNCT_1,FUNCT_2,SEQM_3,PARTFUN1,RELSET_1,XBOOLE_1,NAT_D,ORDINAL1,XXREAL_0,CKB1;
schemes NAT_1,FUNCT_2,RECDEF_1,SUBSET_1,CLASSES1,XBOOLE_0;
registrations ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,SEQM_3,VALUED_0;
constructors PARTFUN1,XXREAL_0,NAT_1,NAT_D,SEQ_1,SEQM_3,RECDEF_1,MEMBERED,RELSET_1;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve n for (Element of ( NAT ));
reserve m for (Element of ( NAT ));
theorem
Th2: (for n holds (ex m st ((n = ( 3 * m ) or n = ( ( 3 * m ) + 1 )) or n = ( ( 3 * m ) + 2 ))))
proof
let n;
take ( n div 3 );
set w = ( n mod 3 );
A1: ((w = ( 0 ) or w = 1) or w = 2)
proof
w < ( 2 + 1 ) by NAT_D:1;
then A2: w <= ( 1 + 1 ) by NAT_1:13;
now
per cases  by A2,NAT_1:8;
suppose A3: w <= 1;

now
per cases  by A3,NAT_1:8;
suppose w <= ( 0 );

hence thesis by NAT_1:2;
end;
suppose w = ( ( 0 ) + 1 );

hence thesis;
end;
end;
hence thesis;
end;
suppose w = ( 1 + 1 );

hence thesis;
end;
end;
hence thesis;
end;
A4: n = ( ( 3 * ( n div 3 ) ) + ( n mod 3 ) ) by NAT_D:2;
now
per cases  by A1;
suppose w = ( 0 );

hence thesis by A4;
end;
suppose w = 1;

hence thesis by NAT_D:2;
end;
suppose w = 2;

hence thesis by NAT_D:2;
end;
end;
hence thesis;
end;
