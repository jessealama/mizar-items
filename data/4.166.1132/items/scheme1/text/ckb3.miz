environ
vocabularies NUMBERS,SUBSET_1,REAL_1,RELAT_1,ARYTM_3,INT_1,CARD_1,XXREAL_0,SEQ_1,VALUED_0,FUNCT_1,NAT_1,TARSKI,ORDINAL2,ARYTM_1,XBOOLE_0,PARTFUN1,ZFMISC_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,XCMPLX_0,REAL_1,NAT_1,NAT_D,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,VALUED_0,SEQ_1,XXREAL_0,RECDEF_1;
definitions TARSKI,XBOOLE_0;
theorems ZFMISC_1,NAT_1,FUNCT_1,FUNCT_2,SEQM_3,PARTFUN1,RELSET_1,XBOOLE_1,NAT_D,ORDINAL1,XXREAL_0,CKB1,CKB2;
schemes NAT_1,FUNCT_2,RECDEF_1,SUBSET_1,CLASSES1,XBOOLE_0;
registrations ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,SEQM_3,VALUED_0;
constructors PARTFUN1,XXREAL_0,NAT_1,NAT_D,SEQ_1,SEQM_3,RECDEF_1,MEMBERED,RELSET_1;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve n for (Element of ( NAT ));
reserve m for (Element of ( NAT ));
theorem
Th3: (for n holds (ex m st (((n = ( 4 * m ) or n = ( ( 4 * m ) + 1 )) or n = ( ( 4 * m ) + 2 )) or n = ( ( 4 * m ) + 3 ))))
proof
let n;
take ( n div 4 );
set o = ( n mod 4 );
A1: (((o = ( 0 ) or o = 1) or o = 2) or o = 3)
proof
o < ( 3 + 1 ) by NAT_D:1;
then A2: o <= ( 2 + 1 ) by NAT_1:13;
now
per cases  by A2,NAT_1:8;
suppose A3: o <= 2;

now
per cases  by A3,NAT_1:8;
suppose A4: o <= 1;

now
per cases  by A4,NAT_1:8;
suppose o <= ( 0 );

hence thesis by NAT_1:2;
end;
suppose o = ( ( 0 ) + 1 );

hence thesis;
end;
end;
hence thesis;
end;
suppose o = ( 1 + 1 );

hence thesis;
end;
end;
hence thesis;
end;
suppose o = ( 2 + 1 );

hence thesis;
end;
end;
hence thesis;
end;
n = ( ( 4 * ( n div 4 ) ) + ( n mod 4 ) ) by NAT_D:2;
hence thesis by A1;
end;
