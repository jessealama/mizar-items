environ
vocabularies CAT_1,FUNCT_1,ZFMISC_1,RELAT_1,MCART_1,STRUCT_0,ALGSTR_0,GRAPH_1,PZFMISC1,NATTRA_1,XBOOLE_0,WELLORD1,TARSKI,PARTFUN1,VALUED_1,REWRITE1,ISOCAT_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,BINOP_1,FUNCT_3,STRUCT_0,GRAPH_1,CAT_1,CAT_2,NATTRA_1;
definitions TARSKI,CAT_1,FUNCT_1,NATTRA_1,XBOOLE_0,CAT_2,BINOP_1;
theorems FUNCT_2,CAT_1,ZFMISC_1,FUNCT_1,FUNCT_3,NATTRA_1,RELAT_1,TARSKI,CKB1,CKB2,CKB3,CKB4;
registrations RELSET_1,FUNCT_2,STRUCT_0;
constructors PARTFUN1,NATTRA_1,FUNCOP_1,RELSET_1;
requirements SUBSET,BOOLE;
begin
reserve A for Category;
reserve B for Category;
reserve C for Category;
theorem
Th8: (for F1,F2 being (Functor of A,B) holds (for G1,G2 being (Functor of B,C) holds ((F1 is_transformable_to F2 & G1 is_transformable_to G2) implies ( G1 * F1 ) is_transformable_to ( G2 * F2 ))))
proof
let F1 being (Functor of A,B);
let F2 being (Functor of A,B);
let G1 being (Functor of B,C);
let G2 being (Functor of B,C);
assume that
A1: F1 is_transformable_to F2
and
A2: G1 is_transformable_to G2;
let a being (Object of A);
( Hom (( F1 . a ),( F2 . a )) ) <> ( {} ) by A1,NATTRA_1:def 2;
then A3: ( Hom (( G1 . ( F1 . a ) ),( G1 . ( F2 . a ) )) ) <> ( {} ) by CAT_1:84;
A4: (( G1 . ( F1 . a ) ) = ( ( G1 * F1 ) . a ) & ( G2 . ( F2 . a ) ) = ( ( G2 * F2 ) . a )) by CAT_1:76;
( Hom (( G1 . ( F2 . a ) ),( G2 . ( F2 . a ) )) ) <> ( {} ) by A2,NATTRA_1:def 2;
hence thesis by A4,A3,CAT_1:24;
end;
