environ
vocabularies NUMBERS,XBOOLE_0,NAT_1,FINSEQ_2,MARGREL1,BINARITH,ARYTM_3,POWER,SUBSET_1,ORDINAL4,FINSEQ_1,FUNCOP_1,XBOOLEAN,CARD_1,RELAT_1,REAL_1,FINSEQ_5,EUCLID,XXREAL_0,FUNCT_1,PARTFUN1,ARYTM_1,BINARI_2,ZFMISC_1,INT_1,ABIAN,BINARI_3;
notations XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,REAL_1,XXREAL_0,NAT_1,NAT_D,POWER,ABIAN,SERIES_1,MARGREL1,FUNCT_1,PARTFUN1,FUNCOP_1,FINSEQ_1,FINSEQ_5,FINSEQOP,ZFMISC_1,FINSEQ_2,BINARITH,BINARI_2,EUCLID;
definitions FINSEQ_2,EUCLID,XBOOLEAN;
theorems TARSKI,NAT_1,NAT_2,MARGREL1,POWER,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,FINSEQ_5,FINSEQ_6,BINARITH,BINARI_2,XREAL_1,XCMPLX_1,XBOOLEAN,NAT_D,PARTFUN1,XXREAL_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
schemes NAT_1,NAT_2,FINSEQ_2;
registrations RELSET_1,XREAL_0,NAT_1,XBOOLEAN,MARGREL1,ZFMISC_1,NAT_2,ORDINAL1,XBOOLE_0,FINSEQ_2,INT_1,CARD_1,FINSEQ_1;
constructors XXREAL_0,NAT_1,NAT_D,FINSEQOP,SERIES_1,ZFMISC_1,BINARITH,FINSEQ_5,BINARI_2,ABIAN,EUCLID,BINOP_2,RELSET_1;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
theorem
Th22: (for n being non  empty Nat holds (for x,y being (Tuple of n,( BOOLEAN )) holds (((y = ( 0* n ) & ( x /. n ) = ( TRUE )) & ( ( carry (x,( Bin1 n )) ) /. n ) = ( TRUE )) implies x = ( 'not' y ))))
proof
let n being non  empty Nat;
let x being (Tuple of n,( BOOLEAN ));
let y being (Tuple of n,( BOOLEAN ));
assume that
A1: y = ( 0* n )
and
A2: ( x /. n ) = ( TRUE )
and
A3: ( ( carry (x,( Bin1 n )) ) /. n ) = ( TRUE );
A4: ( len x ) = n by CARD_1:def 7;
A5: ( len ( 'not' y ) ) = n by CARD_1:def 7;
A6: ( len y ) = n by CARD_1:def 7;
A7: ( len ( carry (x,( Bin1 n )) ) ) = n by CARD_1:def 7;
now
let i being Nat;
reconsider z = i as Nat;
assume A8: i in ( Seg n );
then A9: 1 <= i by FINSEQ_1:1;
A10: i <= n by A8,FINSEQ_1:1;
A11: ( y . i ) = ( FALSE ) by A1,A8,FUNCOP_1:7;
now
per cases ;
suppose A12: i = 1;

A13: n >= 1 by NAT_1:14;
now
per cases  by A13,XXREAL_0:1;
suppose n = 1;

hence ( x . i ) = ( ( 'not' y ) . i ) by A3,BINARITH:def 2;
end;
suppose A14: n > 1;

A15: ( len ( 'not' ( Bin1 n ) ) ) = n by CARD_1:def 7;
A16: ( ( carry (x,( Bin1 n )) ) /. i ) = ( FALSE ) by A12,BINARITH:def 2;
then A17: ( ( ( Bin1 n ) /. i ) '&' ( ( carry (x,( Bin1 n )) ) /. i ) ) = ( FALSE );
A18: ( 1 + 1 ) <= n by A14,NAT_1:13;
then A19: 2 in ( Seg n ) by FINSEQ_1:1;
( ( carry (x,( Bin1 n )) ) . ( i + 1 ) ) = ( ( 'not' ( Bin1 n ) ) . 2 ) by A2,A3,A12,CKB20:1
.= ( ( 'not' ( Bin1 n ) ) /. 2 ) by A18,A15,FINSEQ_4:15
.= ( 'not' ( ( Bin1 n ) /. 2 ) ) by A19,BINARITH:def 1
.= ( 'not' ( FALSE ) ) by A19,BINARI_2:6
.= ( TRUE );
then A20: ( TRUE ) = ( ( carry (x,( Bin1 n )) ) /. ( i + 1 ) ) by A7,A12,A18,FINSEQ_4:15
.= ( ( ( x /. i ) '&' ( ( Bin1 n ) /. i ) ) 'or' ( ( x /. i ) '&' ( ( carry (x,( Bin1 n )) ) /. i ) ) ) by A12,A14,A16,A17,BINARITH:def 2
.= ( ( x /. i ) '&' ( ( Bin1 n ) /. i ) ) by A16;
thus ( x . i ) = ( x /. z ) by A4,A9,A10,FINSEQ_4:15
.= ( 'not' ( FALSE ) ) by A20,MARGREL1:12
.= ( 'not' ( y /. z ) ) by A6,A9,A10,A11,FINSEQ_4:15
.= ( ( 'not' y ) /. z ) by A8,BINARITH:def 1
.= ( ( 'not' y ) . i ) by A5,A9,A10,FINSEQ_4:15;
end;
end;
hence ( x . i ) = ( ( 'not' y ) . i );
end;
suppose A21: i <> 1;

A22: i is non  empty by A8,FINSEQ_1:1;
thus ( x . i ) = ( x /. z ) by A4,A9,A10,FINSEQ_4:15
.= ( 'not' ( FALSE ) ) by A2,A3,A10,A21,A22,CKB19:1
.= ( 'not' ( y /. z ) ) by A6,A9,A10,A11,FINSEQ_4:15
.= ( ( 'not' y ) /. z ) by A8,BINARITH:def 1
.= ( ( 'not' y ) . i ) by A5,A9,A10,FINSEQ_4:15;
end;
end;
hence ( x . i ) = ( ( 'not' y ) . i );
end;
hence thesis by FINSEQ_2:119;
end;
