environ
vocabularies NUMBERS,XBOOLE_0,NAT_1,FINSEQ_2,MARGREL1,BINARITH,ARYTM_3,POWER,SUBSET_1,ORDINAL4,FINSEQ_1,FUNCOP_1,XBOOLEAN,CARD_1,RELAT_1,REAL_1,FINSEQ_5,EUCLID,XXREAL_0,FUNCT_1,PARTFUN1,ARYTM_1,BINARI_2,ZFMISC_1,INT_1,ABIAN,BINARI_3;
notations XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,REAL_1,XXREAL_0,NAT_1,NAT_D,POWER,ABIAN,SERIES_1,MARGREL1,FUNCT_1,PARTFUN1,FUNCOP_1,FINSEQ_1,FINSEQ_5,FINSEQOP,ZFMISC_1,FINSEQ_2,BINARITH,BINARI_2,EUCLID,CKB25;
definitions FINSEQ_2,EUCLID,XBOOLEAN,CKB25;
theorems TARSKI,NAT_1,NAT_2,MARGREL1,POWER,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,FINSEQ_5,FINSEQ_6,BINARITH,BINARI_2,XREAL_1,XCMPLX_1,XBOOLEAN,NAT_D,PARTFUN1,XXREAL_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32;
schemes NAT_1,NAT_2,FINSEQ_2;
registrations RELSET_1,XREAL_0,NAT_1,XBOOLEAN,MARGREL1,ZFMISC_1,NAT_2,ORDINAL1,XBOOLE_0,FINSEQ_2,INT_1,CARD_1,FINSEQ_1;
constructors XXREAL_0,NAT_1,NAT_D,FINSEQOP,SERIES_1,ZFMISC_1,BINARITH,FINSEQ_5,BINARI_2,ABIAN,EUCLID,BINOP_2,RELSET_1,CKB25;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
theorem
Th29: (for i being Nat holds ( ( i + 1 ) -BinarySequence ( 2 to_power i ) ) = ( ( 0* i ) ^ <* 1 *> ))
proof
deffunc Bi(Nat) = ( ( $1 + 1 ) -BinarySequence ( 2 to_power $1 ) );
let i being Nat;
set Bi = Bi(i);
per cases  by NAT_1:3;
suppose A1: i = ( 0 );

then A2: ( 0* i ) = ( 0 ) by FINSEQ_2:58;
reconsider i1 = ( i + 1 ) as non  empty Nat;
A3: ( 0* i1 ) = <* ( FALSE ) *> by A1,FINSEQ_2:59;
then reconsider x = ( 0* i1 ) as (Tuple of i1,( BOOLEAN ));
( 2 to_power i1 ) = 2 by A1,POWER:25;
then 1 = ( ( 2 to_power i1 ) - 1 );
then ( i1 -BinarySequence 1 ) = ( 'not' x ) by CKB32:1;
hence Bi = <* ( TRUE ) *> by A1,A3,CKB14:1,POWER:24
.= ( ( 0* i ) ^ <* 1 *> ) by A2,FINSEQ_1:34;
end;
suppose i > ( 0 );

then reconsider i9 = i as non  empty Nat;
Bi = ( ( 0* i9 ) ^ <* 1 *> ) by CKB29:1;
hence thesis;
end;
end;
