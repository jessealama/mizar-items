environ
vocabularies NUMBERS,XBOOLE_0,NAT_1,FINSEQ_2,MARGREL1,BINARITH,ARYTM_3,POWER,SUBSET_1,ORDINAL4,FINSEQ_1,FUNCOP_1,XBOOLEAN,CARD_1,RELAT_1,REAL_1,FINSEQ_5,EUCLID,XXREAL_0,FUNCT_1,PARTFUN1,ARYTM_1,BINARI_2,ZFMISC_1,INT_1,ABIAN,BINARI_3;
notations XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,REAL_1,XXREAL_0,NAT_1,NAT_D,POWER,ABIAN,SERIES_1,MARGREL1,FUNCT_1,PARTFUN1,FUNCOP_1,FINSEQ_1,FINSEQ_5,FINSEQOP,ZFMISC_1,FINSEQ_2,BINARITH,BINARI_2,EUCLID,CKB25;
definitions FINSEQ_2,EUCLID,XBOOLEAN,CKB25;
theorems TARSKI,NAT_1,NAT_2,MARGREL1,POWER,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,FINSEQ_5,FINSEQ_6,BINARITH,BINARI_2,XREAL_1,XCMPLX_1,XBOOLEAN,NAT_D,PARTFUN1,XXREAL_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37;
schemes NAT_1,NAT_2,FINSEQ_2;
registrations RELSET_1,XREAL_0,NAT_1,XBOOLEAN,MARGREL1,ZFMISC_1,NAT_2,ORDINAL1,XBOOLE_0,FINSEQ_2,INT_1,CARD_1,FINSEQ_1;
constructors XXREAL_0,NAT_1,NAT_D,FINSEQOP,SERIES_1,ZFMISC_1,BINARITH,FINSEQ_5,BINARI_2,ABIAN,EUCLID,BINOP_2,RELSET_1,CKB25;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
theorem
Th34: (for n being non empty Nat holds (for k being Nat holds (( k + 1 ) < ( 2 to_power n ) implies ( n -BinarySequence ( k + 1 ) ) = ( ( n -BinarySequence k ) + ( Bin1 n ) ))))
proof
defpred P[ non empty Nat ]
 means
(for k being Nat holds (( k + 1 ) < ( 2 to_power $1 ) implies ( $1 -BinarySequence ( k + 1 ) ) = ( ( $1 -BinarySequence k ) + ( Bin1 $1 ) )));
A1: (for n being non empty Nat holds (P[ n ] implies P[ ( n + 1 ) ]))
proof
let n being non empty Nat;
assume A2: P[ n ];
let k being Nat;
assume A3: ( k + 1 ) < ( 2 to_power ( n + 1 ) );
then A4: k < ( 2 to_power ( n + 1 ) ) by NAT_1:13;
now
per cases  by XXREAL_0:1;
suppose A5: ( k + 1 ) < ( 2 to_power n );

then A6: k < ( 2 to_power n ) by NAT_1:13;
A7: ( add_ovfl (( n -BinarySequence k ),( Bin1 n )) ) = ( FALSE ) by A5,CKB37:1;
thus ( ( n + 1 ) -BinarySequence ( k + 1 ) ) = ( ( n -BinarySequence ( k + 1 ) ) ^ <* ( FALSE ) *> ) by A5,CKB28:1
.= ( ( ( n -BinarySequence k ) + ( Bin1 n ) ) ^ <* ( ( ( FALSE ) 'xor' ( FALSE ) ) 'xor' ( add_ovfl (( n -BinarySequence k ),( Bin1 n )) ) ) *> ) by A2,A5,A7
.= ( ( ( n -BinarySequence k ) ^ <* ( FALSE ) *> ) + ( ( Bin1 n ) ^ <* ( FALSE ) *> ) ) by BINARITH:19
.= ( ( ( n -BinarySequence k ) ^ <* ( FALSE ) *> ) + ( Bin1 ( n + 1 ) ) ) by BINARI_2:7
.= ( ( ( n + 1 ) -BinarySequence k ) + ( Bin1 ( n + 1 ) ) ) by A6,CKB28:1;
end;
suppose A8: ( k + 1 ) > ( 2 to_power n );

then A9: k >= ( 2 to_power n ) by NAT_1:13;
( k + 1 ) < ( ( 2 to_power n ) * ( 2 to_power 1 ) ) by A3,POWER:27;
then ( k + 1 ) < ( ( 2 to_power n ) * 2 ) by POWER:25;
then ( k + 1 ) < ( ( 2 to_power n ) + ( 2 to_power n ) );
then ( ( k + 1 ) - ( 2 to_power n ) ) < ( 2 to_power n ) by XREAL_1:19;
then ( ( k - ( 2 to_power n ) ) + 1 ) < ( 2 to_power n );
then A10: ( ( k -' ( 2 to_power n ) ) + 1 ) < ( 2 to_power n ) by A9,XREAL_1:233;
then A11: ( add_ovfl (( n -BinarySequence ( k -' ( 2 to_power n ) ) ),( Bin1 n )) ) = ( FALSE ) by CKB37:1;
thus ( ( n + 1 ) -BinarySequence ( k + 1 ) ) = ( ( n -BinarySequence ( ( k + 1 ) -' ( 2 to_power n ) ) ) ^ <* ( TRUE ) *> ) by A3,A8,CKB31:1
.= ( ( n -BinarySequence ( ( k -' ( 2 to_power n ) ) + 1 ) ) ^ <* ( TRUE ) *> ) by A9,NAT_D:38
.= ( ( ( n -BinarySequence ( k -' ( 2 to_power n ) ) ) + ( Bin1 n ) ) ^ <* ( ( ( TRUE ) 'xor' ( FALSE ) ) 'xor' ( add_ovfl (( n -BinarySequence ( k -' ( 2 to_power n ) ) ),( Bin1 n )) ) ) *> ) by A2,A10,A11
.= ( ( ( n -BinarySequence ( k -' ( 2 to_power n ) ) ) ^ <* ( TRUE ) *> ) + ( ( Bin1 n ) ^ <* ( FALSE ) *> ) ) by BINARITH:19
.= ( ( ( n -BinarySequence ( k -' ( 2 to_power n ) ) ) ^ <* ( TRUE ) *> ) + ( Bin1 ( n + 1 ) ) ) by BINARI_2:7
.= ( ( ( n + 1 ) -BinarySequence k ) + ( Bin1 ( n + 1 ) ) ) by A4,A9,CKB31:1;
end;
suppose A12: ( k + 1 ) = ( 2 to_power n );

( 0* n ) in ( ( BOOLEAN ) * ) by CKB4:1;
then ( 0* n ) is (FinSequence of ( BOOLEAN )) by FINSEQ_1:def 11;
then reconsider z = ( 0* n ) as (Tuple of n,( BOOLEAN ));
A13: k < ( 2 to_power n ) by A12,NAT_1:13;
k = ( ( 2 to_power n ) - 1 ) by A12;
then A14: ( n -BinarySequence k ) = ( 'not' z ) by A13,CKB32:1;
thus ( ( n + 1 ) -BinarySequence ( k + 1 ) ) = ( ( 0* n ) ^ <* 1 *> ) by A12,CKB33:1
.= ( ( ( 'not' z ) + ( Bin1 n ) ) ^ <* ( TRUE ) *> ) by CKB24:1
.= ( ( ( n -BinarySequence k ) + ( Bin1 n ) ) ^ <* ( ( ( FALSE ) 'xor' ( FALSE ) ) 'xor' ( add_ovfl (( n -BinarySequence k ),( Bin1 n )) ) ) *> ) by A14,CKB23:1
.= ( ( ( n -BinarySequence k ) ^ <* ( FALSE ) *> ) + ( ( Bin1 n ) ^ <* ( FALSE ) *> ) ) by BINARITH:19
.= ( ( ( n -BinarySequence k ) ^ <* ( FALSE ) *> ) + ( Bin1 ( n + 1 ) ) ) by BINARI_2:7
.= ( ( ( n + 1 ) -BinarySequence k ) + ( Bin1 ( n + 1 ) ) ) by A13,CKB28:1;
end;
end;
hence thesis;
end;
A15: P[ 1 ]
proof
( 0* 1 ) in ( ( BOOLEAN ) * ) by CKB4:1;
then ( 0* 1 ) is (FinSequence of ( BOOLEAN )) by FINSEQ_1:def 11;
then reconsider x = ( 0* 1 ) as (Tuple of 1,( BOOLEAN ));
let k being Nat;
A16: ( 0* 1 ) = <* ( FALSE ) *> by FINSEQ_2:59;
assume A17: ( k + 1 ) < ( 2 to_power 1 );
then ( k + 1 ) < ( 1 + 1 ) by POWER:25;
then k < 1 by XREAL_1:6;
then A18: k = ( 0 ) by NAT_1:14;
then ( k + 1 ) = ( 2 - 1 )
.= ( ( 2 to_power 1 ) - 1 ) by POWER:25;
hence ( 1 -BinarySequence ( k + 1 ) ) = ( 'not' x ) by A17,CKB32:1
.= ( ( 1 -BinarySequence k ) + ( Bin1 1 ) ) by A18,A16,CKB10:1,CKB14:1,CKB17:1,CKB26:1;
end;
thus (for n being non empty Nat holds P[ n ]) from NAT_1:sch 10(A15,A1);
end;
