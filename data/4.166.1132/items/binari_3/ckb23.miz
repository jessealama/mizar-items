environ
vocabularies NUMBERS,XBOOLE_0,NAT_1,FINSEQ_2,MARGREL1,BINARITH,ARYTM_3,POWER,SUBSET_1,ORDINAL4,FINSEQ_1,FUNCOP_1,XBOOLEAN,CARD_1,RELAT_1,REAL_1,FINSEQ_5,EUCLID,XXREAL_0,FUNCT_1,PARTFUN1,ARYTM_1,BINARI_2,ZFMISC_1,INT_1,ABIAN,BINARI_3;
notations XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,REAL_1,XXREAL_0,NAT_1,NAT_D,POWER,ABIAN,SERIES_1,MARGREL1,FUNCT_1,PARTFUN1,FUNCOP_1,FINSEQ_1,FINSEQ_5,FINSEQOP,ZFMISC_1,FINSEQ_2,BINARITH,BINARI_2,EUCLID;
definitions FINSEQ_2,EUCLID,XBOOLEAN;
theorems TARSKI,NAT_1,NAT_2,MARGREL1,POWER,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,FINSEQ_5,FINSEQ_6,BINARITH,BINARI_2,XREAL_1,XCMPLX_1,XBOOLEAN,NAT_D,PARTFUN1,XXREAL_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22;
schemes NAT_1,NAT_2,FINSEQ_2;
registrations RELSET_1,XREAL_0,NAT_1,XBOOLEAN,MARGREL1,ZFMISC_1,NAT_2,ORDINAL1,XBOOLE_0,FINSEQ_2,INT_1,CARD_1,FINSEQ_1;
constructors XXREAL_0,NAT_1,NAT_D,FINSEQOP,SERIES_1,ZFMISC_1,BINARITH,FINSEQ_5,BINARI_2,ABIAN,EUCLID,BINOP_2,RELSET_1;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
theorem
Th24: (for n being non empty Nat holds (for x,y being (Tuple of n,( BOOLEAN )) holds (y = ( 0* n ) implies (( add_ovfl (x,( Bin1 n )) ) = ( TRUE ) iff x = ( 'not' y )))))
proof
let n being non empty Nat;
let x being (Tuple of n,( BOOLEAN )),y being (Tuple of n,( BOOLEAN ));
assume A1: y = ( 0* n );
A2: n in ( Seg n ) by FINSEQ_1:3;
A3: 1 in ( Seg 1 ) by FINSEQ_1:3;
thus (( add_ovfl (x,( Bin1 n )) ) = ( TRUE ) implies x = ( 'not' y ))
proof
assume A4: ( add_ovfl (x,( Bin1 n )) ) = ( TRUE );
then A5: ( ( ( ( x /. n ) '&' ( ( Bin1 n ) /. n ) ) 'or' ( ( x /. n ) '&' ( ( carry (x,( Bin1 n )) ) /. n ) ) ) 'or' ( ( ( Bin1 n ) /. n ) '&' ( ( carry (x,( Bin1 n )) ) /. n ) ) ) = ( TRUE ) by BINARITH:def 6;
per cases ;
suppose A6: n <> 1;

now
per cases  by A5,CKB12:1;
suppose A7: ( ( ( x /. n ) '&' ( ( Bin1 n ) /. n ) ) 'or' ( ( x /. n ) '&' ( ( carry (x,( Bin1 n )) ) /. n ) ) ) = ( TRUE );

now
per cases  by A7,CKB12:1;
suppose A8: ( ( x /. n ) '&' ( ( Bin1 n ) /. n ) ) = ( TRUE );

assume x <> ( 'not' y );
( ( Bin1 n ) /. n ) = ( TRUE ) by A8,MARGREL1:12;
hence contradiction by A2,A6,BINARI_2:6;
end;
suppose A9: ( ( x /. n ) '&' ( ( carry (x,( Bin1 n )) ) /. n ) ) = ( TRUE );

then ( x /. n ) = ( TRUE ) by MARGREL1:12;
hence thesis by A1,A9,CKB21:1;
end;
end;
hence thesis;
end;
suppose A10: ( ( ( Bin1 n ) /. n ) '&' ( ( carry (x,( Bin1 n )) ) /. n ) ) = ( TRUE );

assume x <> ( 'not' y );
( ( Bin1 n ) /. n ) = ( TRUE ) by A10,MARGREL1:12;
hence contradiction by A2,A6,BINARI_2:6;
end;
end;
hence thesis;
end;
suppose A11: n = 1;

then ( len y ) = 1 by CARD_1:def 7;
then 1 in ( dom y ) by A3,FINSEQ_1:def 3;
then A12: ( y /. 1 ) = ( y . 1 ) by PARTFUN1:def 6
.= ( 0 ) by A1,A11,FINSEQ_1:3,FUNCOP_1:7;
consider d being (Element of ( BOOLEAN )) such that A13: x = <* d *> by A11,FINSEQ_2:97;
A14: d = ( TRUE ) by A4,A11,A13,CKB10:1,CKB13:1;
now
let i being Nat;
assume i in ( Seg n );
then i = 1 by A11,FINSEQ_1:2,TARSKI:def 1;
hence ( x /. i ) = ( 'not' ( y /. i ) ) by A13,A14,A12,FINSEQ_4:16;
end;
hence thesis by BINARITH:def 1;
end;
end;

assume A15: x = ( 'not' y );
per cases ;
suppose A16: n <> 1;

A17: ( ( carry (x,( Bin1 n )) ) /. n ) = ( ( 'not' ( Bin1 n ) ) /. n ) by A1,A15,CKB22:1
.= ( 'not' ( ( Bin1 n ) /. n ) ) by A2,BINARITH:def 1
.= ( 'not' ( FALSE ) ) by A2,A16,BINARI_2:6
.= ( TRUE );
( len y ) = n by CARD_1:def 7;
then n in ( dom y ) by A2,FINSEQ_1:def 3;
then A18: ( y /. n ) = ( y . n ) by PARTFUN1:def 6
.= ( 0 ) by A1,FINSEQ_1:3,FUNCOP_1:7;
A19: ( x /. n ) = ( 'not' ( y /. n ) ) by A2,A15,BINARITH:def 1
.= ( TRUE ) by A18;
thus ( add_ovfl (x,( Bin1 n )) ) = ( ( ( ( x /. n ) '&' ( ( Bin1 n ) /. n ) ) 'or' ( ( x /. n ) '&' ( ( carry (x,( Bin1 n )) ) /. n ) ) ) 'or' ( ( ( Bin1 n ) /. n ) '&' ( ( carry (x,( Bin1 n )) ) /. n ) ) ) by BINARITH:def 6
.= ( TRUE ) by A19,A17;
end;
suppose A20: n = 1;

then ( len y ) = 1 by CARD_1:def 7;
then 1 in ( dom y ) by A3,FINSEQ_1:def 3;
then A21: ( y /. 1 ) = ( y . 1 ) by PARTFUN1:def 6
.= ( 0 ) by A1,A20,FINSEQ_1:3,FUNCOP_1:7;
consider d being (Element of ( BOOLEAN )) such that A22: x = <* d *> by A20,FINSEQ_2:97;
d = ( ( 'not' y ) /. 1 ) by A15,A22,FINSEQ_4:16
.= ( 'not' ( y /. 1 ) ) by A3,A20,BINARITH:def 1
.= ( TRUE ) by A21;
hence thesis by A20,A22,CKB10:1,CKB13:1;
end;
end;
