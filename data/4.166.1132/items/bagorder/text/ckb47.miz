environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,FINSEQ_1,ARYTM_1,ARYTM_3,XXREAL_0,CARD_1,NAT_1,PRE_POLY,FUNCT_1,RELAT_1,TARSKI,CLASSES1,FUNCT_2,CARD_3,FINSEQ_2,PBOOLE,GRAPH_2,VALUED_0,FINSUB_1,FINSET_1,RELAT_2,ORDERS_2,WAYBEL_4,STRUCT_0,WELLFND1,WELLORD1,ORDERS_1,ORDINAL1,WELLORD2,ORDINAL4,REAL_1,FUNCOP_1,FUNCT_4,PARTFUN1,DICKSON,RLVECT_2,ZFMISC_1,MCART_1,BAGORDER;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,XCMPLX_0,RELAT_1,PBOOLE,RELAT_2,RELSET_1,PARTFUN1,FINSET_1,FINSUB_1,ORDINAL1,FUNCT_7,MCART_1,WELLORD1,ORDERS_1,WELLFND1,CARD_1,NUMBERS,VALUED_0,XXREAL_0,REAL_1,FUNCT_1,SEQ_1,PRE_POLY,CARD_3,NAT_D,FINSEQ_1,RVSUM_1,WSIERP_1,FUNCOP_1,FUNCT_2,SEQ_4,DOMAIN_1,FINSEQOP,CLASSES1,RECDEF_1,NAT_1,STRUCT_0,WAYBEL_0,YELLOW_1,WAYBEL_4,PRALG_1,ORDERS_2,DICKSON,POLYNOM2,CKB6,CKB10,CKB15,CKB19,CKB30,CKB31,CKB32,CKB37,CKB41,CKB43,CKB44;
definitions TARSKI,RELAT_2,WELLFND1,FINSEQ_2,CKB6,CKB10,CKB15,CKB19,CKB32,CKB37,CKB41,CKB43,CKB44;
theorems WELLORD1,TARSKI,RELAT_2,RELSET_1,ZFMISC_1,ORDERS_2,NAT_1,FUNCT_1,AXIOMS,CARD_3,PBOOLE,YELLOW_1,PRALG_1,FUNCOP_1,PARTIT_2,WELLFND1,RELAT_1,DICKSON,FINSEQ_1,INTEGRA5,RVSUM_1,FINSEQ_2,CARD_1,WAYBEL_0,WAYBEL_4,ORDINAL1,FUNCT_2,CARD_2,MCART_1,FINSUB_1,ORDERS_1,FUNCT_7,WELLORD2,FINSEQ_3,FINSEQ_5,FINSEQOP,RFINSEQ,XBOOLE_0,XBOOLE_1,PARTFUN1,XREAL_1,XXREAL_0,VALUED_0,VALUED_1,XXREAL_2,XREAL_0,NAT_D,CLASSES1,PRE_POLY,CKB1,CKB2,CKB4,CKB5,CKB6,CKB9,CKB10,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB32,CKB33,CKB36,CKB37,CKB38,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45;
schemes NAT_1,RELSET_1,FINSET_1,RECDEF_1,FUNCT_2,ORDINAL1,CLASSES1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCT_2,FINSET_1,FINSUB_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,CARD_1,MEMBERED,FINSEQ_1,CARD_5,STRUCT_0,ORDERS_2,WAYBEL_0,YELLOW_1,DICKSON,VALUED_0,XXREAL_2,RELSET_1,PRE_POLY,CKB3,CKB7,CKB8,CKB11,CKB34,CKB35,CKB39,CKB46;
constructors DOMAIN_1,FINSEQOP,NAT_D,WSIERP_1,PRALG_1,TRIANG_1,WAYBEL_4,WELLFND1,POLYNOM2,DICKSON,SEQ_1,RECDEF_1,BINOP_2,SEQ_4,CLASSES1,RELSET_1,FUNCT_7,REAL_1,CKB6,CKB10,CKB15,CKB19,CKB32,CKB37,CKB41,CKB43,CKB44;
requirements SUBSET,NUMERALS,REAL,BOOLE,ARITHM;
begin
theorem
(for o being  infinite Ordinal holds ( GrLexOrder o ) is non well-ordering)
proof
let o being  infinite Ordinal;
set R = ( GrLexOrder o );
set r = RelStr (# ( Bags o ),R #);
set ir = (the InternalRel of r);
set cr = (the carrier of r);
assume R is  well-ordering;
then A1: R is  well_founded by WELLORD1:def 4;
cr = ( field ir ) by ORDERS_1:15;
then ir is_well_founded_in cr by A1,WELLORD1:3;
then A2: r is  well_founded by WELLFND1:def 2;
defpred P[ Nat,set ]
 means
$2 = ( ( o --> ( 0 ) ) +* ($1,1) );
A3:now
let n being (Element of ( NAT ));
set y = ( ( o --> ( 0 ) ) +* (n,1) );
A4: ( dom ( o --> ( 0 ) ) ) = o by FUNCOP_1:13;
reconsider y as (ManySortedSet of o);
A5: n in ( omega );
A6: ( omega ) c= o by CARD_3:85;
now
let x being set;
hereby
assume x in { n };
then x = n by TARSKI:def 1;
hence ( y . x ) <> ( 0 ) by A4,A5,A6,FUNCT_7:31;
end;
assume that
A7: ( y . x ) <> ( 0 )
and
A8: (not x in { n });
x <> n by A8,TARSKI:def 1;
then A9: ( y . x ) = ( ( o --> ( 0 ) ) . x ) by FUNCT_7:32;
per cases ;
suppose x in ( dom ( o --> ( 0 ) ) );

hence contradiction by A7,A9,FUNCOP_1:7;
end;
suppose (not x in ( dom ( o --> ( 0 ) ) ));

hence contradiction by A7,A9,FUNCT_1:def 2;
end;
end;
then ( support y ) = { n } by PRE_POLY:def 7;
then y is  finite-support by PRE_POLY:def 8;
then reconsider y as (Element of cr) by PRE_POLY:def 12;
take y;
thus P[ n,y ];
end;
consider f being (Function of ( NAT ),cr) such that A10: (for n being (Element of ( NAT )) holds P[ n,( f . n ) ]) from FUNCT_2:sch 3(A3);
reconsider f as (sequence of r);
f is  descending
proof
let n being Nat;
reconsider n0 = n as (Element of ( NAT )) by ORDINAL1:def 12;
set fn1 = ( f . ( n0 + 1 ) );
set fn = ( f . n0 );
A11: fn1 = ( ( o --> ( 0 ) ) +* (( n + 1 ),1) ) by A10;
A12: fn = ( ( o --> ( 0 ) ) +* (n,1) ) by A10;
reconsider fn1 as (bag of o);
reconsider fn as (bag of o);
A13: n0 in ( omega );
A14: ( omega ) c= o by CARD_3:85;
n <> ( n + 1 );
then A15: ( fn1 . n ) = ( ( o --> ( 0 ) ) . n ) by A11,FUNCT_7:32
.= ( 0 ) by A13,A14,FUNCOP_1:7;
A16: ( dom ( o --> ( 0 ) ) ) = o by FUNCOP_1:13;
then A17: ( fn . n ) = 1 by A12,A13,A14,FUNCT_7:31;
now
let l being Ordinal;
assume A18: l in n;
then A19: l <> n;
n < ( n + 1 ) by NAT_1:13;
then n in { i where i is (Element of ( NAT )): i < ( n0 + 1 ) };
then n in ( n + 1 ) by AXIOMS:4;
then n c= ( n + 1 ) by ORDINAL1:def 2;
then l in ( n + 1 ) by A18;
then l <> ( n + 1 );
hence ( fn1 . l ) = ( ( o --> ( 0 ) ) . l ) by A11,FUNCT_7:32
.= ( fn . l ) by A12,A19,FUNCT_7:32;
end;
then A20: fn1 < fn by A15,A17,PRE_POLY:def 9;
thus ( f . ( n + 1 ) ) <> ( f . n ) by A12,A13,A14,A15,A16,FUNCT_7:31;
fn1 <=' fn by A20,PRE_POLY:def 10;
then A21: [ ( f . ( n + 1 ) ),( f . n ) ] in ( LexOrder o ) by PRE_POLY:def 14;
consider tn being (FinSequence of ( NAT )) such that A22: ( TotDegree fn ) = ( Sum tn ) and A23: tn = ( fn * ( SgmX (( RelIncl o ),( support fn )) ) ) by CKB19:def 1;
consider tn1 being (FinSequence of ( NAT )) such that A24: ( TotDegree fn1 ) = ( Sum tn1 ) and A25: tn1 = ( fn1 * ( SgmX (( RelIncl o ),( support fn1 )) ) ) by CKB19:def 1;
A26: ( n + 1 ) in ( omega );
( omega ) c= o by CARD_3:85;
then reconsider nn = n,n1n = ( n + 1 ) as (Element of o) by A13,A26;
A27: ( field ( RelIncl o ) ) = o by WELLORD2:def 1;
( RelIncl o ) is  well-ordering by WELLORD2:6;
then A28: ( RelIncl o ) linearly_orders o by A27,ORDERS_1:19,ORDERS_1:37;
now
let x being set;
hereby
assume A29: x in ( support fn1 );
now
assume x <> n1n;
then ( fn1 . x ) = ( ( o --> ( 0 ) ) . x ) by A11,FUNCT_7:32;
then ( fn1 . x ) = ( 0 ) by A29,FUNCOP_1:7;
hence contradiction by A29,PRE_POLY:def 7;
end;
hence x in { n1n } by TARSKI:def 1;
end;
assume x in { n1n };
then x = n1n by TARSKI:def 1;
then ( fn1 . x ) = 1 by A11,A16,FUNCT_7:31;
hence x in ( support fn1 ) by PRE_POLY:def 7;
end;
then ( support fn1 ) = { n1n } by TARSKI:1;
then A30: ( SgmX (( RelIncl o ),( support fn1 )) ) = <* n1n *> by A28,CKB18:1,ORDERS_1:38;
A31: ( dom fn ) = o by A12,A16,FUNCT_7:30;
A32: ( dom fn1 ) = o by A11,A16,FUNCT_7:30;
now
let x being set;
hereby
assume A33: x in ( support fn );
now
assume x <> nn;
then ( fn . x ) = ( ( o --> ( 0 ) ) . x ) by A12,FUNCT_7:32;
then ( fn . x ) = ( 0 ) by A33,FUNCOP_1:7;
hence contradiction by A33,PRE_POLY:def 7;
end;
hence x in { nn } by TARSKI:def 1;
end;
assume x in { nn };
then x = nn by TARSKI:def 1;
then ( fn . x ) = 1 by A12,A16,FUNCT_7:31;
hence x in ( support fn ) by PRE_POLY:def 7;
end;
then ( support fn ) = { nn } by TARSKI:1;
then ( SgmX (( RelIncl o ),( support fn )) ) = <* nn *> by A28,CKB18:1,ORDERS_1:38;
then A34: tn = <* ( fn . n ) *> by A23,A31,FINSEQ_2:34
.= <* 1 *> by A12,A13,A14,A16,FUNCT_7:31
.= <* ( fn1 . n1n ) *> by A11,A16,FUNCT_7:31
.= tn1 by A25,A30,A32,FINSEQ_2:34;
(for a,b,c being (bag of o) holds ([ a,b ] in ( LexOrder o ) implies [ ( a + c ),( b + c ) ] in ( LexOrder o ))) by CKB32:def 1;
hence [ ( f . ( n + 1 ) ),( f . n ) ] in ir by A21,A22,A24,A34,CKB41:def 1;
end;
hence contradiction by A2,WELLFND1:14;
end;
