environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,FINSEQ_1,ARYTM_1,ARYTM_3,XXREAL_0,CARD_1,NAT_1,PRE_POLY,FUNCT_1,RELAT_1,TARSKI,CLASSES1,FUNCT_2,CARD_3,FINSEQ_2,PBOOLE,GRAPH_2,VALUED_0,FINSUB_1,FINSET_1,RELAT_2,ORDERS_2,WAYBEL_4,STRUCT_0,WELLFND1,WELLORD1,ORDERS_1,ORDINAL1,WELLORD2,ORDINAL4,REAL_1,FUNCOP_1,FUNCT_4,PARTFUN1,DICKSON,RLVECT_2,ZFMISC_1,MCART_1,BAGORDER;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,XCMPLX_0,RELAT_1,PBOOLE,RELAT_2,RELSET_1,PARTFUN1,FINSET_1,FINSUB_1,ORDINAL1,FUNCT_7,MCART_1,WELLORD1,ORDERS_1,WELLFND1,CARD_1,NUMBERS,VALUED_0,XXREAL_0,REAL_1,FUNCT_1,SEQ_1,PRE_POLY,CARD_3,NAT_D,FINSEQ_1,RVSUM_1,WSIERP_1,FUNCOP_1,FUNCT_2,SEQ_4,DOMAIN_1,FINSEQOP,CLASSES1,RECDEF_1,NAT_1,STRUCT_0,WAYBEL_0,YELLOW_1,WAYBEL_4,PRALG_1,ORDERS_2,DICKSON,POLYNOM2,CKB6,CKB10,CKB15,CKB19,CKB30,CKB31,CKB32,CKB37,CKB41,CKB43,CKB44,CKB51;
definitions TARSKI,RELAT_2,WELLFND1,FINSEQ_2,CKB6,CKB10,CKB15,CKB19,CKB32,CKB37,CKB41,CKB43,CKB44,CKB51;
theorems WELLORD1,TARSKI,RELAT_2,RELSET_1,ZFMISC_1,ORDERS_2,NAT_1,FUNCT_1,AXIOMS,CARD_3,PBOOLE,YELLOW_1,PRALG_1,FUNCOP_1,PARTIT_2,WELLFND1,RELAT_1,DICKSON,FINSEQ_1,INTEGRA5,RVSUM_1,FINSEQ_2,CARD_1,WAYBEL_0,WAYBEL_4,ORDINAL1,FUNCT_2,CARD_2,MCART_1,FINSUB_1,ORDERS_1,FUNCT_7,WELLORD2,FINSEQ_3,FINSEQ_5,FINSEQOP,RFINSEQ,XBOOLE_0,XBOOLE_1,PARTFUN1,XREAL_1,XXREAL_0,VALUED_0,VALUED_1,XXREAL_2,XREAL_0,NAT_D,CLASSES1,PRE_POLY,CKB1,CKB2,CKB4,CKB5,CKB6,CKB9,CKB10,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB32,CKB33,CKB36,CKB37,CKB38,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB47,CKB48,CKB50,CKB51;
schemes NAT_1,RELSET_1,FINSET_1,RECDEF_1,FUNCT_2,ORDINAL1,CLASSES1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCT_2,FINSET_1,FINSUB_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,CARD_1,MEMBERED,FINSEQ_1,CARD_5,STRUCT_0,ORDERS_2,WAYBEL_0,YELLOW_1,DICKSON,VALUED_0,XXREAL_2,RELSET_1,PRE_POLY,CKB3,CKB7,CKB8,CKB11,CKB34,CKB35,CKB39,CKB46,CKB49;
constructors DOMAIN_1,FINSEQOP,NAT_D,WSIERP_1,PRALG_1,TRIANG_1,WAYBEL_4,WELLFND1,POLYNOM2,DICKSON,SEQ_1,RECDEF_1,BINOP_2,SEQ_4,CLASSES1,RELSET_1,FUNCT_7,REAL_1,CKB6,CKB10,CKB15,CKB19,CKB32,CKB37,CKB41,CKB43,CKB44,CKB51;
requirements SUBSET,NUMERALS,REAL,BOOLE,ARITHM;
begin
theorem
(for i,n being Nat holds (for o1 being (TermOrder of ( i + 1 )) holds (for o2 being (TermOrder of ( n -' ( i + 1 ) )) holds ((o1 is  admissible & o2 is  admissible) implies ( BlockOrder (i,n,o1,o2) ) is  admissible))))
proof
let i being Nat,n being Nat;
let o1 being (TermOrder of ( i + 1 ));
let o2 being (TermOrder of ( n -' ( i + 1 ) ));
assume that
A1: o1 is  admissible
and
A2: o2 is  admissible;
A3: ( i + 1 ) = ( ( i + 1 ) -' ( 0 ) ) by NAT_D:40;
then A4: o1 is_strongly_connected_in ( Bags ( ( i + 1 ) -' ( 0 ) ) ) by A1,CKB32:def 1;
A5: o2 is_strongly_connected_in ( Bags ( n -' ( i + 1 ) ) ) by A2,CKB32:def 1;
set BO = ( BlockOrder (i,n,o1,o2) );
now
now
let x being set,y being set;
assume that
A6: x in ( Bags n )
and
A7: y in ( Bags n );
reconsider p = x,q = y as (bag of n) by A6,A7;
set CUTP1 = ( (( 0 ),( i + 1 )) -cut p );
set CUTP2 = ( (( i + 1 ),n) -cut p );
set CUTQ1 = ( (( 0 ),( i + 1 )) -cut q );
set CUTQ2 = ( (( i + 1 ),n) -cut q );
A8: CUTP1 in ( Bags ( ( i + 1 ) -' ( 0 ) ) ) by PRE_POLY:def 12;
A9: CUTQ1 in ( Bags ( ( i + 1 ) -' ( 0 ) ) ) by PRE_POLY:def 12;
A10: CUTP2 in ( Bags ( n -' ( i + 1 ) ) ) by PRE_POLY:def 12;
A11: CUTQ2 in ( Bags ( n -' ( i + 1 ) ) ) by PRE_POLY:def 12;
assume A12: (not [ x,y ] in BO);
per cases  by A12,CKB51:def 1;
suppose A13: CUTP1 = CUTQ1;

now
per cases  by A12,CKB51:def 1;
suppose CUTP1 <> CUTQ1;

hence [ y,x ] in BO by A13;
end;
suppose (not [ CUTP2,CUTQ2 ] in o2);

then [ CUTQ2,CUTP2 ] in o2 by A5,A10,A11,RELAT_2:def 7;
hence [ y,x ] in BO by A13,CKB51:def 1;
end;
end;
hence [ y,x ] in BO;
end;
suppose (not [ CUTP1,CUTQ1 ] in o1);

then A14: [ CUTQ1,CUTP1 ] in o1 by A4,A8,A9,RELAT_2:def 7;
now
per cases  by A12,CKB51:def 1;
suppose CUTP1 <> CUTQ1;

hence [ y,x ] in BO by A14,CKB51:def 1;
end;
suppose (not [ CUTP2,CUTQ2 ] in o2);

then A15: [ CUTQ2,CUTP2 ] in o2 by A5,A10,A11,RELAT_2:def 7;
now
per cases ;
suppose CUTP1 = CUTQ1;

hence [ y,x ] in BO by A15,CKB51:def 1;
end;
suppose CUTP1 <> CUTQ1;

hence [ y,x ] in BO by A14,CKB51:def 1;
end;
end;
hence [ y,x ] in BO;
end;
end;
hence [ y,x ] in BO;
end;
end;
hence BO is_strongly_connected_in ( Bags n ) by RELAT_2:def 7;
let a being (bag of n);
set CUTE1 = ( (( 0 ),( i + 1 )) -cut ( EmptyBag n ) );
set CUTA1 = ( (( 0 ),( i + 1 )) -cut a );
set CUTE2 = ( (( i + 1 ),n) -cut ( EmptyBag n ) );
set CUTA2 = ( (( i + 1 ),n) -cut a );
now
per cases ;
suppose A16: CUTE1 <> CUTA1;

CUTE1 = ( EmptyBag ( ( i + 1 ) -' ( 0 ) ) ) by CKB24:1;
then [ CUTE1,CUTA1 ] in o1 by A1,A3,CKB32:def 1;
hence [ ( EmptyBag n ),a ] in BO by A16,CKB51:def 1;
end;
suppose A17: CUTE1 = CUTA1;

CUTE2 = ( EmptyBag ( n -' ( i + 1 ) ) ) by CKB24:1;
then [ CUTE2,CUTA2 ] in o2 by A2,CKB32:def 1;
hence [ ( EmptyBag n ),a ] in BO by A17,CKB51:def 1;
end;
end;
hence [ ( EmptyBag n ),a ] in BO;
let a being (bag of n),b being (bag of n),c being (bag of n);
assume that
A18: [ a,b ] in BO;
set CUTA1 = ( (( 0 ),( i + 1 )) -cut a );
set CUTA2 = ( (( i + 1 ),n) -cut a );
set CUTB1 = ( (( 0 ),( i + 1 )) -cut b );
set CUTB2 = ( (( i + 1 ),n) -cut b );
set CUTC1 = ( (( 0 ),( i + 1 )) -cut c );
set CUTC2 = ( (( i + 1 ),n) -cut c );
set CUTAC1 = ( (( 0 ),( i + 1 )) -cut ( a + c ) );
set CUTBC1 = ( (( 0 ),( i + 1 )) -cut ( b + c ) );
set CUTAC2 = ( (( i + 1 ),n) -cut ( a + c ) );
set CUTBC2 = ( (( i + 1 ),n) -cut ( b + c ) );
per cases  by A18,CKB51:def 1;
suppose A19: (CUTA1 <> CUTB1 & [ CUTA1,CUTB1 ] in o1);

then [ ( CUTA1 + CUTC1 ),( CUTB1 + CUTC1 ) ] in o1 by A1,A3,CKB32:def 1;
then [ CUTAC1,( CUTB1 + CUTC1 ) ] in o1 by CKB25:1;
then A20: [ CUTAC1,CUTBC1 ] in o1 by CKB25:1;
now
assume A21: ( CUTA1 + CUTC1 ) = ( CUTB1 + CUTC1 );
( ( CUTA1 + CUTC1 ) -' CUTC1 ) = CUTA1 by PRE_POLY:48;
hence contradiction by A19,A21,PRE_POLY:48;
end;
then CUTAC1 <> ( CUTB1 + CUTC1 ) by CKB25:1;
then CUTAC1 <> CUTBC1 by CKB25:1;
hence [ ( a + c ),( b + c ) ] in BO by A20,CKB51:def 1;
end;
suppose A22: (CUTA1 = CUTB1 & [ CUTA2,CUTB2 ] in o2);

then [ ( CUTA2 + CUTC2 ),( CUTB2 + CUTC2 ) ] in o2 by A2,CKB32:def 1;
then [ CUTAC2,( CUTB2 + CUTC2 ) ] in o2 by CKB25:1;
then A23: [ CUTAC2,CUTBC2 ] in o2 by CKB25:1;
CUTAC1 = ( CUTB1 + CUTC1 ) by A22,CKB25:1;
then CUTAC1 = CUTBC1 by CKB25:1;
hence [ ( a + c ),( b + c ) ] in BO by A23,CKB51:def 1;
end;
end;
hence thesis by CKB32:def 1;
end;
