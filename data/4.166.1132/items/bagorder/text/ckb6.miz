environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,FINSEQ_1,ARYTM_1,ARYTM_3,XXREAL_0,CARD_1,NAT_1,PRE_POLY,FUNCT_1,RELAT_1,TARSKI,CLASSES1,FUNCT_2,CARD_3,FINSEQ_2,PBOOLE,GRAPH_2,VALUED_0,FINSUB_1,FINSET_1,RELAT_2,ORDERS_2,WAYBEL_4,STRUCT_0,WELLFND1,WELLORD1,ORDERS_1,ORDINAL1,WELLORD2,ORDINAL4,REAL_1,FUNCOP_1,FUNCT_4,PARTFUN1,DICKSON,RLVECT_2,ZFMISC_1,MCART_1,BAGORDER;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,XCMPLX_0,RELAT_1,PBOOLE,RELAT_2,RELSET_1,PARTFUN1,FINSET_1,FINSUB_1,ORDINAL1,FUNCT_7,MCART_1,WELLORD1,ORDERS_1,WELLFND1,CARD_1,NUMBERS,VALUED_0,XXREAL_0,REAL_1,FUNCT_1,SEQ_1,PRE_POLY,CARD_3,NAT_D,FINSEQ_1,RVSUM_1,WSIERP_1,FUNCOP_1,FUNCT_2,SEQ_4,DOMAIN_1,FINSEQOP,CLASSES1,RECDEF_1,NAT_1,STRUCT_0,WAYBEL_0,YELLOW_1,WAYBEL_4,PRALG_1,ORDERS_2,DICKSON,POLYNOM2;
definitions TARSKI,RELAT_2,WELLFND1,FINSEQ_2;
theorems WELLORD1,TARSKI,RELAT_2,RELSET_1,ZFMISC_1,ORDERS_2,NAT_1,FUNCT_1,AXIOMS,CARD_3,PBOOLE,YELLOW_1,PRALG_1,FUNCOP_1,PARTIT_2,WELLFND1,RELAT_1,DICKSON,FINSEQ_1,INTEGRA5,RVSUM_1,FINSEQ_2,CARD_1,WAYBEL_0,WAYBEL_4,ORDINAL1,FUNCT_2,CARD_2,MCART_1,FINSUB_1,ORDERS_1,FUNCT_7,WELLORD2,FINSEQ_3,FINSEQ_5,FINSEQOP,RFINSEQ,XBOOLE_0,XBOOLE_1,PARTFUN1,XREAL_1,XXREAL_0,VALUED_0,VALUED_1,XXREAL_2,XREAL_0,NAT_D,CLASSES1,PRE_POLY,CKB1,CKB2,CKB4,CKB5;
schemes NAT_1,RELSET_1,FINSET_1,RECDEF_1,FUNCT_2,ORDINAL1,CLASSES1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCT_2,FINSET_1,FINSUB_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,CARD_1,MEMBERED,FINSEQ_1,CARD_5,STRUCT_0,ORDERS_2,WAYBEL_0,YELLOW_1,DICKSON,VALUED_0,XXREAL_2,RELSET_1,PRE_POLY,CKB3;
constructors DOMAIN_1,FINSEQOP,NAT_D,WSIERP_1,PRALG_1,TRIANG_1,WAYBEL_4,WELLFND1,POLYNOM2,DICKSON,SEQ_1,RECDEF_1,BINOP_2,SEQ_4,CLASSES1,RELSET_1,FUNCT_7,REAL_1;
requirements SUBSET,NUMERALS,REAL,BOOLE,ARITHM;
begin
definition
let n being Nat;
let i being Nat;
let j being Nat;
let b being (ManySortedSet of n);
func (i,j) -cut b -> (ManySortedSet of ( j -' i )) means 
:Def1: (for k being (Element of ( NAT )) holds (k in ( j -' i ) implies ( it . k ) = ( b . ( i + k ) )));
existence
proof
defpred P[ set,set ]
 means
(ex k1 being (Element of ( NAT )) st (k1 = $1 & $2 = ( b . ( i + k1 ) )));
now
let x being set;
assume that
A1: x in ( j -' i );
( j -' i ) = { k where k is (Element of ( NAT )): k < ( j -' i ) } by AXIOMS:4;
then (ex k being (Element of ( NAT )) st (x = k & k < ( j -' i ))) by A1;
then reconsider x9 = x as (Element of ( NAT ));
consider y being set such that A2: y = ( b . ( i + x9 ) );
take y;
thus P[ x,y ] by A2;
end;
then A3: (for x being set holds (x in ( j -' i ) implies (ex y being set st P[ x,y ])));
consider f being Function such that A4: ( dom f ) = ( j -' i ) and A5: (for k being set holds (k in ( j -' i ) implies P[ k,( f . k ) ])) from CLASSES1:sch 1(A3);
reconsider f as (ManySortedSet of ( j -' i )) by A4,PARTFUN1:def 2,RELAT_1:def 18;
take f;
let k being (Element of ( NAT ));
assume k in ( j -' i );
then (ex k9 being (Element of ( NAT )) st (k9 = k & ( f . k ) = ( b . ( i + k9 ) ))) by A5;
hence thesis;
end;
uniqueness
proof
let IT1 being (ManySortedSet of ( j -' i ));
let IT2 being (ManySortedSet of ( j -' i ));
assume that
A6: (for k being (Element of ( NAT )) holds (k in ( j -' i ) implies ( IT1 . k ) = ( b . ( i + k ) )))
and
A7: (for k being (Element of ( NAT )) holds (k in ( j -' i ) implies ( IT2 . k ) = ( b . ( i + k ) )));
A8: ( j -' i ) = ( dom IT1 ) by PARTFUN1:def 2;
A9: ( j -' i ) = ( dom IT2 ) by PARTFUN1:def 2;
now
let x being set;
assume that
A10: x in ( j -' i );
( j -' i ) = { k where k is (Element of ( NAT )): k < ( j -' i ) } by AXIOMS:4;
then (ex k being (Element of ( NAT )) st (x = k & k < ( j -' i ))) by A10;
then reconsider x9 = x as (Element of ( NAT ));
( IT1 . x ) = ( b . ( i + x9 ) ) by A6,A10;
hence ( IT1 . x ) = ( IT2 . x ) by A7,A10;
end;
hence IT1 = IT2 by A8,A9,FUNCT_1:2;
end;
end;
