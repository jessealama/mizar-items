environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,FINSEQ_1,ARYTM_1,ARYTM_3,XXREAL_0,CARD_1,NAT_1,PRE_POLY,FUNCT_1,RELAT_1,TARSKI,CLASSES1,FUNCT_2,CARD_3,FINSEQ_2,PBOOLE,GRAPH_2,VALUED_0,FINSUB_1,FINSET_1,RELAT_2,ORDERS_2,WAYBEL_4,STRUCT_0,WELLFND1,WELLORD1,ORDERS_1,ORDINAL1,WELLORD2,ORDINAL4,REAL_1,FUNCOP_1,FUNCT_4,PARTFUN1,DICKSON,RLVECT_2,ZFMISC_1,MCART_1,BAGORDER;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,XCMPLX_0,RELAT_1,PBOOLE,RELAT_2,RELSET_1,PARTFUN1,FINSET_1,FINSUB_1,ORDINAL1,FUNCT_7,MCART_1,WELLORD1,ORDERS_1,WELLFND1,CARD_1,NUMBERS,VALUED_0,XXREAL_0,REAL_1,FUNCT_1,SEQ_1,PRE_POLY,CARD_3,NAT_D,FINSEQ_1,RVSUM_1,WSIERP_1,FUNCOP_1,FUNCT_2,SEQ_4,DOMAIN_1,FINSEQOP,CLASSES1,RECDEF_1,NAT_1,STRUCT_0,WAYBEL_0,YELLOW_1,WAYBEL_4,PRALG_1,ORDERS_2,DICKSON,POLYNOM2,CKB6,CKB10,CKB15;
definitions TARSKI,RELAT_2,WELLFND1,FINSEQ_2,CKB6,CKB10,CKB15;
theorems WELLORD1,TARSKI,RELAT_2,RELSET_1,ZFMISC_1,ORDERS_2,NAT_1,FUNCT_1,AXIOMS,CARD_3,PBOOLE,YELLOW_1,PRALG_1,FUNCOP_1,PARTIT_2,WELLFND1,RELAT_1,DICKSON,FINSEQ_1,INTEGRA5,RVSUM_1,FINSEQ_2,CARD_1,WAYBEL_0,WAYBEL_4,ORDINAL1,FUNCT_2,CARD_2,MCART_1,FINSUB_1,ORDERS_1,FUNCT_7,WELLORD2,FINSEQ_3,FINSEQ_5,FINSEQOP,RFINSEQ,XBOOLE_0,XBOOLE_1,PARTFUN1,XREAL_1,XXREAL_0,VALUED_0,VALUED_1,XXREAL_2,XREAL_0,NAT_D,CLASSES1,PRE_POLY,CKB1,CKB2,CKB4,CKB5,CKB6,CKB9,CKB10,CKB12,CKB13,CKB14,CKB15;
schemes NAT_1,RELSET_1,FINSET_1,RECDEF_1,FUNCT_2,ORDINAL1,CLASSES1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCT_2,FINSET_1,FINSUB_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,CARD_1,MEMBERED,FINSEQ_1,CARD_5,STRUCT_0,ORDERS_2,WAYBEL_0,YELLOW_1,DICKSON,VALUED_0,XXREAL_2,RELSET_1,PRE_POLY,CKB3,CKB7,CKB8,CKB11;
constructors DOMAIN_1,FINSEQOP,NAT_D,WSIERP_1,PRALG_1,TRIANG_1,WAYBEL_4,WELLFND1,POLYNOM2,DICKSON,SEQ_1,RECDEF_1,BINOP_2,SEQ_4,CLASSES1,RELSET_1,FUNCT_7,REAL_1,CKB6,CKB10,CKB15;
requirements SUBSET,NUMERALS,REAL,BOOLE,ARITHM;
begin
theorem
Th10: (for R being non  empty  transitive RelStr holds (for f being (sequence of R) holds (f is  non-increasing implies (for j,i being Nat holds (i < j implies [ ( f . j ),( f . i ) ] in (the InternalRel of R))))))
proof
let R being non  empty  transitive RelStr;
let f being (sequence of R);
assume that
A1: f is  non-increasing;
set IR = (the InternalRel of R);
set CR = (the carrier of R);
A2: IR is_transitive_in CR by ORDERS_2:def 3;
defpred P[ Nat ]
 means
(for i being Nat holds (i < $1 implies [ ( f . $1 ),( f . i ) ] in IR));
A3: P[ ( 0 ) ];
now
let j being Nat;
assume that
A4: (for i being Nat holds (i < j implies [ ( f . j ),( f . i ) ] in IR));
let i being Nat;
assume that
A5: i < ( j + 1 );
now
per cases  by XXREAL_0:1;
suppose i > j;

hence [ ( f . ( j + 1 ) ),( f . i ) ] in IR by A5,NAT_1:13;
end;
suppose i = j;

hence [ ( f . ( j + 1 ) ),( f . i ) ] in IR by A1,CKB15:def 1;
end;
suppose i < j;

then A6: [ ( f . j ),( f . i ) ] in IR by A4;
[ ( f . ( j + 1 ) ),( f . j ) ] in IR by A1,CKB15:def 1;
hence [ ( f . ( j + 1 ) ),( f . i ) ] in IR by A2,A6,RELAT_2:def 8;
end;
end;
hence [ ( f . ( j + 1 ) ),( f . i ) ] in IR;
end;
then A7: (for j being Nat holds (P[ j ] implies P[ ( j + 1 ) ]));
thus (for j being Nat holds P[ j ]) from NAT_1:sch 2(A3,A7);
end;
