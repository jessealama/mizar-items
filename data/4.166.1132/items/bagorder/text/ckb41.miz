environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,FINSEQ_1,ARYTM_1,ARYTM_3,XXREAL_0,CARD_1,NAT_1,PRE_POLY,FUNCT_1,RELAT_1,TARSKI,CLASSES1,FUNCT_2,CARD_3,FINSEQ_2,PBOOLE,GRAPH_2,VALUED_0,FINSUB_1,FINSET_1,RELAT_2,ORDERS_2,WAYBEL_4,STRUCT_0,WELLFND1,WELLORD1,ORDERS_1,ORDINAL1,WELLORD2,ORDINAL4,REAL_1,FUNCOP_1,FUNCT_4,PARTFUN1,DICKSON,RLVECT_2,ZFMISC_1,MCART_1,BAGORDER;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,XCMPLX_0,RELAT_1,PBOOLE,RELAT_2,RELSET_1,PARTFUN1,FINSET_1,FINSUB_1,ORDINAL1,FUNCT_7,MCART_1,WELLORD1,ORDERS_1,WELLFND1,CARD_1,NUMBERS,VALUED_0,XXREAL_0,REAL_1,FUNCT_1,SEQ_1,PRE_POLY,CARD_3,NAT_D,FINSEQ_1,RVSUM_1,WSIERP_1,FUNCOP_1,FUNCT_2,SEQ_4,DOMAIN_1,FINSEQOP,CLASSES1,RECDEF_1,NAT_1,STRUCT_0,WAYBEL_0,YELLOW_1,WAYBEL_4,PRALG_1,ORDERS_2,DICKSON,POLYNOM2,CKB6,CKB10,CKB15,CKB19,CKB30,CKB31,CKB32,CKB37;
definitions TARSKI,RELAT_2,WELLFND1,FINSEQ_2,CKB6,CKB10,CKB15,CKB19,CKB32,CKB37;
theorems WELLORD1,TARSKI,RELAT_2,RELSET_1,ZFMISC_1,ORDERS_2,NAT_1,FUNCT_1,AXIOMS,CARD_3,PBOOLE,YELLOW_1,PRALG_1,FUNCOP_1,PARTIT_2,WELLFND1,RELAT_1,DICKSON,FINSEQ_1,INTEGRA5,RVSUM_1,FINSEQ_2,CARD_1,WAYBEL_0,WAYBEL_4,ORDINAL1,FUNCT_2,CARD_2,MCART_1,FINSUB_1,ORDERS_1,FUNCT_7,WELLORD2,FINSEQ_3,FINSEQ_5,FINSEQOP,RFINSEQ,XBOOLE_0,XBOOLE_1,PARTFUN1,XREAL_1,XXREAL_0,VALUED_0,VALUED_1,XXREAL_2,XREAL_0,NAT_D,CLASSES1,PRE_POLY,CKB1,CKB2,CKB4,CKB5,CKB6,CKB9,CKB10,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB32,CKB33,CKB36,CKB37,CKB38,CKB40;
schemes NAT_1,RELSET_1,FINSET_1,RECDEF_1,FUNCT_2,ORDINAL1,CLASSES1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCT_2,FINSET_1,FINSUB_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,CARD_1,MEMBERED,FINSEQ_1,CARD_5,STRUCT_0,ORDERS_2,WAYBEL_0,YELLOW_1,DICKSON,VALUED_0,XXREAL_2,RELSET_1,PRE_POLY,CKB3,CKB7,CKB8,CKB11,CKB34,CKB35,CKB39;
constructors DOMAIN_1,FINSEQOP,NAT_D,WSIERP_1,PRALG_1,TRIANG_1,WAYBEL_4,WELLFND1,POLYNOM2,DICKSON,SEQ_1,RECDEF_1,BINOP_2,SEQ_4,CLASSES1,RELSET_1,FUNCT_7,REAL_1,CKB6,CKB10,CKB15,CKB19,CKB32,CKB37;
requirements SUBSET,NUMERALS,REAL,BOOLE,ARITHM;
begin
definition
let n being Ordinal;
let o being (TermOrder of n);
assume that
A1: (for a,b,c being (bag of n) holds ([ a,b ] in o implies [ ( a + c ),( b + c ) ] in o));
func Graded o -> (TermOrder of n) means 
:Def9: (for a,b being (bag of n) holds ([ a,b ] in it iff (( TotDegree a ) < ( TotDegree b ) or (( TotDegree a ) = ( TotDegree b ) & [ a,b ] in o))));
existence
proof
defpred P[ set,set ]
 means
(ex x9,y9 being (bag of n) st ((x9 = $1 & y9 = $2) & (( TotDegree x9 ) < ( TotDegree y9 ) or (( TotDegree x9 ) = ( TotDegree y9 ) & [ x9,y9 ] in o))));
consider R being (Relation of ( Bags n )) such that A2: (for x,y being set holds ([ x,y ] in R iff ((x in ( Bags n ) & y in ( Bags n )) & P[ x,y ]))) from RELSET_1:sch 1;
A3:now
let x being set;
assume that
A4: x in ( Bags n );
reconsider x9 = x as (bag of n) by A4;
now
take x9;
thus x9 = x;
thus ( TotDegree x9 ) = ( TotDegree x9 );
[ ( EmptyBag n ),( EmptyBag n ) ] in o by ORDERS_1:3;
then [ ( ( EmptyBag n ) + x9 ),( ( EmptyBag n ) + x9 ) ] in o by A1;
then [ x9,( ( EmptyBag n ) + x9 ) ] in o by PRE_POLY:53;
hence [ x9,x9 ] in o by PRE_POLY:53;
end;
hence [ x,x ] in R by A2,A4;
end;
A5:now
let x being set;
let y being set;
assume that
A6: x in ( Bags n )
and
A7: y in ( Bags n )
and
A8: [ x,y ] in R
and
A9: [ y,x ] in R;
consider x9,y9 being (bag of n) such that A10: x9 = x and A11: y9 = y and A12: (( TotDegree x9 ) < ( TotDegree y9 ) or (( TotDegree x9 ) = ( TotDegree y9 ) & [ x9,y9 ] in o)) by A2,A8;
A13: (ex y99,x99 being (bag of n) st ((y99 = y & x99 = x) & (( TotDegree y99 ) < ( TotDegree x99 ) or (( TotDegree y99 ) = ( TotDegree x99 ) & [ y99,x99 ] in o)))) by A2,A9;
now
per cases  by A12;
suppose A14: ( TotDegree x9 ) < ( TotDegree y9 );

now
per cases  by A10,A11,A13;
suppose ( TotDegree y9 ) < ( TotDegree x9 );

hence contradiction by A14;
end;
suppose (( TotDegree y9 ) = ( TotDegree x9 ) & [ y9,x9 ] in o);

hence contradiction by A14;
end;
end;
hence (((( TotDegree x9 ) = ( TotDegree y9 ) & [ x9,y9 ] in o) & ( TotDegree y9 ) = ( TotDegree x9 )) & [ y9,x9 ] in o);
end;
suppose A15: (( TotDegree x9 ) = ( TotDegree y9 ) & [ x9,y9 ] in o);

now
per cases  by A10,A11,A13;
suppose ( TotDegree y9 ) < ( TotDegree x9 );

hence (((( TotDegree x9 ) = ( TotDegree y9 ) & [ x9,y9 ] in o) & ( TotDegree y9 ) = ( TotDegree x9 )) & [ y9,x9 ] in o) by A15;
end;
suppose (( TotDegree y9 ) = ( TotDegree x9 ) & [ y9,x9 ] in o);

hence (((( TotDegree x9 ) = ( TotDegree y9 ) & [ x9,y9 ] in o) & ( TotDegree y9 ) = ( TotDegree x9 )) & [ y9,x9 ] in o) by A15;
end;
end;
hence (((( TotDegree x9 ) = ( TotDegree y9 ) & [ x9,y9 ] in o) & ( TotDegree y9 ) = ( TotDegree x9 )) & [ y9,x9 ] in o);
end;
end;
hence x = y by A6,A7,A10,A11,ORDERS_1:4;
end;
A16:now
let x being set;
let y being set;
let z being set;
assume that
A17: x in ( Bags n )
and
A18: y in ( Bags n )
and
A19: z in ( Bags n )
and
A20: [ x,y ] in R
and
A21: [ y,z ] in R;
consider x9,y9 being (bag of n) such that A22: x9 = x and A23: y9 = y and A24: (( TotDegree x9 ) < ( TotDegree y9 ) or (( TotDegree x9 ) = ( TotDegree y9 ) & [ x9,y9 ] in o)) by A2,A20;
consider y99,z9 being (bag of n) such that A25: y99 = y and A26: z9 = z and A27: (( TotDegree y99 ) < ( TotDegree z9 ) or (( TotDegree y99 ) = ( TotDegree z9 ) & [ y99,z9 ] in o)) by A2,A21;
per cases  by A24;
suppose A28: ( TotDegree x9 ) < ( TotDegree y9 );

now
per cases  by A23,A25,A27;
suppose ( TotDegree y9 ) < ( TotDegree z9 );

then ( TotDegree x9 ) < ( TotDegree z9 ) by A28,XXREAL_0:2;
hence [ x,z ] in R by A2,A17,A19,A22,A26;
end;
suppose (( TotDegree y9 ) = ( TotDegree z9 ) & [ y9,z9 ] in o);

hence [ x,z ] in R by A2,A17,A19,A22,A26,A28;
end;
end;
hence [ x,z ] in R;
end;
suppose A29: (( TotDegree x9 ) = ( TotDegree y9 ) & [ x9,y9 ] in o);

now
per cases  by A23,A25,A27;
suppose ( TotDegree y9 ) < ( TotDegree z9 );

hence [ x,z ] in R by A2,A17,A19,A22,A26,A29;
end;
suppose (( TotDegree y9 ) = ( TotDegree z9 ) & [ y9,z9 ] in o);

then [ x9,z9 ] in o by A17,A18,A19,A22,A23,A26,A29,ORDERS_1:5;
hence [ x,z ] in R by A2,A17,A19,A22,A23,A25,A26,A27,A29;
end;
end;
hence [ x,z ] in R;
end;
end;
A30: R is_reflexive_in ( Bags n ) by A3,RELAT_2:def 1;
A31: R is_antisymmetric_in ( Bags n ) by A5,RELAT_2:def 4;
A32: R is_transitive_in ( Bags n ) by A16,RELAT_2:def 8;
A33: ( dom R ) = ( Bags n ) by A30,ORDERS_1:13;
( field R ) = ( Bags n ) by A30,ORDERS_1:13;
then reconsider R as (TermOrder of n) by A30,A31,A32,A33,PARTFUN1:def 2,RELAT_2:def 9,RELAT_2:def 12,RELAT_2:def 16;
take R;
let a being (bag of n);
let b being (bag of n);
hereby
assume [ a,b ] in R;
then (ex x9,y9 being (bag of n) st ((x9 = a & y9 = b) & (( TotDegree x9 ) < ( TotDegree y9 ) or (( TotDegree x9 ) = ( TotDegree y9 ) & [ x9,y9 ] in o)))) by A2;
hence (( TotDegree a ) < ( TotDegree b ) or (( TotDegree a ) = ( TotDegree b ) & [ a,b ] in o));
end;
assume A34: (( TotDegree a ) < ( TotDegree b ) or (( TotDegree a ) = ( TotDegree b ) & [ a,b ] in o));
A35: a in ( Bags n ) by PRE_POLY:def 12;
b in ( Bags n ) by PRE_POLY:def 12;
hence thesis by A2,A34,A35;
end;
uniqueness
proof
let IT1 being (TermOrder of n);
let IT2 being (TermOrder of n);
assume that
A36: (for a,b being (bag of n) holds ([ a,b ] in IT1 iff (( TotDegree a ) < ( TotDegree b ) or (( TotDegree a ) = ( TotDegree b ) & [ a,b ] in o))))
and
A37: (for a,b being (bag of n) holds ([ a,b ] in IT2 iff (( TotDegree a ) < ( TotDegree b ) or (( TotDegree a ) = ( TotDegree b ) & [ a,b ] in o))));
now
let a being set;
let b being set;
hereby
assume A38: [ a,b ] in IT1;
then A39: a in ( dom IT1 ) by RELAT_1:def 4;
b in ( rng IT1 ) by A38,RELAT_1:def 5;
then reconsider a9 = a,b9 = b as (bag of n) by A39;
(( TotDegree a9 ) < ( TotDegree b9 ) or (( TotDegree a9 ) = ( TotDegree b9 ) & [ a9,b9 ] in o)) by A36,A38;
hence [ a,b ] in IT2 by A37;
end;
assume A40: [ a,b ] in IT2;
then A41: a in ( dom IT2 ) by RELAT_1:def 4;
b in ( rng IT2 ) by A40,RELAT_1:def 5;
then reconsider a9 = a,b9 = b as (bag of n) by A41;
(( TotDegree a9 ) < ( TotDegree b9 ) or (( TotDegree a9 ) = ( TotDegree b9 ) & [ a9,b9 ] in o)) by A37,A40;
hence [ a,b ] in IT1 by A36;
end;
hence IT1 = IT2 by RELAT_1:def 2;
end;
end;
