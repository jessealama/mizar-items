environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,FINSEQ_1,ARYTM_1,ARYTM_3,XXREAL_0,CARD_1,NAT_1,PRE_POLY,FUNCT_1,RELAT_1,TARSKI,CLASSES1,FUNCT_2,CARD_3,FINSEQ_2,PBOOLE,GRAPH_2,VALUED_0,FINSUB_1,FINSET_1,RELAT_2,ORDERS_2,WAYBEL_4,STRUCT_0,WELLFND1,WELLORD1,ORDERS_1,ORDINAL1,WELLORD2,ORDINAL4,REAL_1,FUNCOP_1,FUNCT_4,PARTFUN1,DICKSON,RLVECT_2,ZFMISC_1,MCART_1,BAGORDER;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,XCMPLX_0,RELAT_1,PBOOLE,RELAT_2,RELSET_1,PARTFUN1,FINSET_1,FINSUB_1,ORDINAL1,FUNCT_7,MCART_1,WELLORD1,ORDERS_1,WELLFND1,CARD_1,NUMBERS,VALUED_0,XXREAL_0,REAL_1,FUNCT_1,SEQ_1,PRE_POLY,CARD_3,NAT_D,FINSEQ_1,RVSUM_1,WSIERP_1,FUNCOP_1,FUNCT_2,SEQ_4,DOMAIN_1,FINSEQOP,CLASSES1,RECDEF_1,NAT_1,STRUCT_0,WAYBEL_0,YELLOW_1,WAYBEL_4,PRALG_1,ORDERS_2,DICKSON,POLYNOM2,CKB6;
definitions TARSKI,RELAT_2,WELLFND1,FINSEQ_2,CKB6;
theorems WELLORD1,TARSKI,RELAT_2,RELSET_1,ZFMISC_1,ORDERS_2,NAT_1,FUNCT_1,AXIOMS,CARD_3,PBOOLE,YELLOW_1,PRALG_1,FUNCOP_1,PARTIT_2,WELLFND1,RELAT_1,DICKSON,FINSEQ_1,INTEGRA5,RVSUM_1,FINSEQ_2,CARD_1,WAYBEL_0,WAYBEL_4,ORDINAL1,FUNCT_2,CARD_2,MCART_1,FINSUB_1,ORDERS_1,FUNCT_7,WELLORD2,FINSEQ_3,FINSEQ_5,FINSEQOP,RFINSEQ,XBOOLE_0,XBOOLE_1,PARTFUN1,XREAL_1,XXREAL_0,VALUED_0,VALUED_1,XXREAL_2,XREAL_0,NAT_D,CLASSES1,PRE_POLY,CKB1,CKB2,CKB4,CKB5,CKB6;
schemes NAT_1,RELSET_1,FINSET_1,RECDEF_1,FUNCT_2,ORDINAL1,CLASSES1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCT_2,FINSET_1,FINSUB_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,CARD_1,MEMBERED,FINSEQ_1,CARD_5,STRUCT_0,ORDERS_2,WAYBEL_0,YELLOW_1,DICKSON,VALUED_0,XXREAL_2,RELSET_1,PRE_POLY,CKB3,CKB7,CKB8;
constructors DOMAIN_1,FINSEQOP,NAT_D,WSIERP_1,PRALG_1,TRIANG_1,WAYBEL_4,WELLFND1,POLYNOM2,DICKSON,SEQ_1,RECDEF_1,BINOP_2,SEQ_4,CLASSES1,RELSET_1,FUNCT_7,REAL_1,CKB6;
requirements SUBSET,NUMERALS,REAL,BOOLE,ARITHM;
begin
theorem
Th6: (for n,i being Nat holds (for a,b being (ManySortedSet of n) holds (a = b iff (( (( 0 ),( i + 1 )) -cut a ) = ( (( 0 ),( i + 1 )) -cut b ) & ( (( i + 1 ),n) -cut a ) = ( (( i + 1 ),n) -cut b )))))
proof
let n being Nat,i being Nat;
let a being (ManySortedSet of n),b being (ManySortedSet of n);
set CUTA1 = ( (( 0 ),( i + 1 )) -cut a );
set CUTA2 = ( (( i + 1 ),n) -cut a );
set CUTB1 = ( (( 0 ),( i + 1 )) -cut b );
set CUTB2 = ( (( i + 1 ),n) -cut b );
thus (a = b implies (CUTA1 = CUTB1 & CUTA2 = CUTB2));
assume that
A1: CUTA1 = CUTB1
and
A2: CUTA2 = CUTB2;
A3:now
let k being (Element of ( NAT ));
assume that
A4: k in ( i + 1 );
( ( i + 1 ) -' ( 0 ) ) = ( ( ( i + 1 ) + (( 0 ) qua Nat) ) -' ( 0 ) );
then A5: k in ( ( i + 1 ) -' ( 0 ) ) by A4,NAT_D:34;
then ( CUTB1 . k ) = ( b . ( (( 0 ) qua Nat) + k ) ) by CKB6:def 1;
hence ( a . k ) = ( b . k ) by A1,A5,CKB6:def 1;
end;
A6:now
let x being (Element of ( NAT ));
assume that
A7: x >= ( i + 1 )
and
A8: x < n;
set k = ( x -' ( i + 1 ) );
( x - ( i + 1 ) ) >= ( ( i + 1 ) - ( i + 1 ) ) by A7,XREAL_1:9;
then A9: k = ( x - ( i + 1 ) ) by XREAL_0:def 2;
n >= ( i + 1 ) by A7,A8,XXREAL_0:2;
then ( n - ( i + 1 ) ) >= ( ( i + 1 ) - ( i + 1 ) ) by XREAL_1:9;
then A10: ( n -' ( i + 1 ) ) = ( n - ( i + 1 ) ) by XREAL_0:def 2;
( x - ( i + 1 ) ) < ( n - ( i + 1 ) ) by A8,XREAL_1:14;
then A11: k in ( n -' ( i + 1 ) ) by A9,A10,NAT_1:44;
then ( CUTB2 . k ) = ( b . ( ( i + 1 ) + k ) ) by CKB6:def 1;
hence ( a . x ) = ( b . x ) by A2,A9,A11,CKB6:def 1;
end;
now
let x9 being set;
assume that
A12: x9 in n;
n = { k where k is (Element of ( NAT )): k < n } by AXIOMS:4;
then A13: (ex k being (Element of ( NAT )) st (k = x9 & k < n)) by A12;
then reconsider x = x9 as (Element of ( NAT ));
per cases ;
suppose x in ( i + 1 );

hence ( a . x9 ) = ( b . x9 ) by A3;
end;
suppose (not x in ( i + 1 ));

then x >= ( i + 1 ) by NAT_1:44;
hence ( a . x9 ) = ( b . x9 ) by A6,A13;
end;
end;
hence thesis by PBOOLE:3;
end;
