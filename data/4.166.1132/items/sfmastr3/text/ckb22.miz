environ
vocabularies NUMBERS,FSM_1,SCMFSA_2,SF_MASTR,AMI_1,SCMFSA7B,SUBSET_1,UNIALG_2,SCMFSA6C,SCMFSA6B,FUNCT_1,XBOOLE_0,FUNCT_4,CARD_1,AMISTD_2,RELAT_1,GRAPHSP,AMI_3,PARTFUN1,COMPLEX1,SCMFSA8B,TURING_1,SCMFSA_9,ARYTM_3,FUNCOP_1,SCMFSA8A,CARD_3,SFMASTR1,ARYTM_1,XXREAL_0,SCMFSA6A,TARSKI,SCMFSA9A,FINSEQ_1,GRAPH_2,AOFA_I00,FUNCT_2,FINSEQ_2,SFMASTR3,NAT_1,SCMNORM,PBOOLE,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,CARD_3,INT_2,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,FUNCT_7,PBOOLE,FUNCOP_1,GRAPH_2,FINSEQ_1,FINSEQ_2,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,SCMFSA9A,XXREAL_0,NAT_1,CKB11,CKB19;
definitions TARSKI,SCMFSA7B,SCMFSA9A,GRAPH_2,SCMFSA6A,COMPOS_1,EXTPRO_1,MEMSTR_0,CKB11,CKB19;
theorems TARSKI,ZFMISC_1,ENUMSET1,ABSVALUE,NAT_1,INT_1,RELAT_1,FUNCT_7,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSEQ_4,GRAPH_2,SCMFSA_2,MEMSTR_0,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,SCMFSA_9,SFMASTR1,SCMFSA9A,SFMASTR2,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,PARTFUN1,AFINSQ_1,PBOOLE,EXTPRO_1,CARD_3,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21;
schemes FUNCT_2,NAT_1;
registrations SUBSET_1,SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,FUNCT_2,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,CARD_3,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,XBOOLE_0,VALUED_0,AFINSQ_1,FUNCOP_1,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,MEMSTR_0,SCMFSA6A,CKB7;
constructors SETWISEO,REAL_1,INT_2,MESFUNC1,SCMFSA6A,SCMFSA6B,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,SCMFSA9A,RELSET_1,FUNCT_4,PBOOLE,GRAPH_2,SCMFSA7B,MEMSTR_0,AMISTD_1,CKB11,CKB19;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve s for (State of ( SCM+FSA ));
reserve a for  read-write Int-Location;
reserve bb for Int-Location;
reserve cc for Int-Location;
reserve Ig for  good (Program of ( SCM+FSA ));
reserve k for (Element of ( NAT ));
reserve p for (Instruction-Sequence of ( SCM+FSA ));
theorem
Th25: ((( s . ( intloc ( 0 ) ) ) = 1 &  ProperForUpBody a,bb,cc,Ig,s,p) implies (for k holds (k <= ( ( ( s . cc ) - ( s . bb ) ) + 1 ) implies ((( ( ( StepForUp (a,bb,cc,Ig,p,s) ) . k ) . ( intloc ( 0 ) ) ) = 1 & ((not Ig destroy a) implies (( ( ( StepForUp (a,bb,cc,Ig,p,s) ) . k ) . a ) = ( k + ( s . bb ) ) & ( ( ( StepForUp (a,bb,cc,Ig,p,s) ) . k ) . a ) <= ( ( s . cc ) + 1 )))) & ( ( ( ( StepForUp (a,bb,cc,Ig,p,s) ) . k ) . ( 1 -stRWNotIn ( { a,bb,cc } \/ ( UsedIntLoc Ig ) ) ) ) + k ) = ( ( ( s . cc ) - ( s . bb ) ) + 1 )))))
proof
set I = Ig;
assume that
A1: ( s . ( intloc ( 0 ) ) ) = 1
and
A2:  ProperForUpBody a,bb,cc,I,s,p;
set scb1 = ( ( ( s . cc ) - ( s . bb ) ) + 1 );
set aux = ( 1 -stRWNotIn ( { a,bb,cc } \/ ( UsedIntLoc I ) ) );
set SF = ( StepForUp (a,bb,cc,I,p,s) );
set IB = ( ( I ';' ( AddTo (a,( intloc ( 0 ) )) ) ) ';' ( SubFrom (aux,( intloc ( 0 ) )) ) );
set s2 = ( ( s +* (aux,( ( ( s . cc ) - ( s . bb ) ) + 1 )) ) +* (a,( s . bb )) );
set p2 = p;
set SW2 = ( StepWhile>0 (aux,IB,p2,s2) );
A3: IB = ( I ';' ( ( AddTo (a,( intloc ( 0 ) )) ) ';' ( SubFrom (aux,( intloc ( 0 ) )) ) ) ) by SCMFSA6A:28;
defpred P[ Nat ]
 means
($1 <= scb1 implies ((( ( SF . $1 ) . ( intloc ( 0 ) ) ) = 1 & ((not I destroy a) implies (( ( SF . $1 ) . a ) = ( $1 + ( s . bb ) ) & ( ( SF . $1 ) . a ) <= ( ( s . cc ) + 1 )))) & ( ( ( SF . $1 ) . aux ) + $1 ) = scb1));
a in { a,bb,cc } by ENUMSET1:def 1;
then a in ( { a,bb,cc } \/ ( UsedIntLoc I ) ) by XBOOLE_0:def 3;
then A4: aux <> a by SFMASTR1:20;
A5: (for k holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k;
assume that
A6: P[ k ];
thus P[ ( k + 1 ) ]
proof
A7: (not aux in ( UsedIntLoc I ))
proof
assume (not thesis);
then aux in ( { a,bb,cc } \/ ( UsedIntLoc I ) ) by XBOOLE_0:def 3;
hence contradiction by SFMASTR1:20;
end;
set k1 = ( k + 1 );
assume A8: ( k + 1 ) <= scb1;
A9: k < ( k + 1 ) by XREAL_1:29;
then A10: ( ( SW2 . k ) . aux ) > ( 0 ) by A6,A8,XREAL_1:8,XXREAL_0:2;
A11: k < scb1 by A8,A9,XXREAL_0:2;
then A12: I is_closed_on ( SF . k ),( p +* ( while>0 (( 1 -stRWNotIn ( { a,bb,cc } \/ ( UsedIntLoc I ) ) ),( ( I ';' ( AddTo (a,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { a,bb,cc } \/ ( UsedIntLoc I ) ) ),( intloc ( 0 ) )) ) )) ) ) by A2,CKB19:def 1;
then A13: I is_closed_on ( Initialized ( SW2 . k ) ),( p +* ( while>0 (aux,IB) ) ) by A6,A8,A9,SFMASTR2:4,XXREAL_0:2;
A14: I is_halting_on ( SF . k ),( p +* ( while>0 (( 1 -stRWNotIn ( { a,bb,cc } \/ ( UsedIntLoc I ) ) ),( ( I ';' ( AddTo (a,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { a,bb,cc } \/ ( UsedIntLoc I ) ) ),( intloc ( 0 ) )) ) )) ) ) by A2,A11,CKB19:def 1;
then A15: I is_halting_on ( Initialized ( SW2 . k ) ),( p +* ( while>0 (aux,IB) ) ) by A6,A8,A9,A12,SFMASTR2:5,XXREAL_0:2;
thus ( ( SF . k1 ) . ( intloc ( 0 ) ) ) = 1 by A6,A8,A9,A12,A14,CKB21:1,XXREAL_0:2;
A16: ( ( AddTo (a,( intloc ( 0 ) )) ) ';' ( SubFrom (aux,( intloc ( 0 ) )) ) ) is_closed_on ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ),( p +* ( while>0 (aux,IB) ) ) by SCMFSA7B:18;
then A17: IB is_closed_on ( Initialized ( SW2 . k ) ),( p +* ( while>0 (aux,IB) ) ) by A3,A13,A15,SFMASTR1:2;
( ( AddTo (a,( intloc ( 0 ) )) ) ';' ( SubFrom (aux,( intloc ( 0 ) )) ) ) is_halting_on ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ),( p +* ( while>0 (aux,IB) ) ) by SCMFSA7B:19;
then IB is_halting_on ( Initialized ( SW2 . k ) ),( p +* ( while>0 (aux,IB) ) ) by A3,A13,A15,A16,SFMASTR1:3;
then A18: ( DataPart ( SW2 . ( k + 1 ) ) ) = ( DataPart ( IExec (IB,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) ) by A6,A8,A9,A10,A17,SCMFSA9A:32,XXREAL_0:2;
hereby
assume A19: (not I destroy a);
A20: ( ( IExec (IB,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) . a ) = ( ( IExec (( ( AddTo (a,( intloc ( 0 ) )) ) ';' ( SubFrom (aux,( intloc ( 0 ) )) ) ),( p +* ( while>0 (aux,IB) ) ),( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) )) ) . a ) by A3,A13,A15,SFMASTR1:7
.= ( ( Exec (( SubFrom (aux,( intloc ( 0 ) )) ),( Exec (( AddTo (a,( intloc ( 0 ) )) ),( Initialized ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) )) )) ) . a ) by SCMFSA6C:8
.= ( ( Exec (( AddTo (a,( intloc ( 0 ) )) ),( Initialized ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) )) ) . a ) by A4,SCMFSA_2:65
.= ( ( ( Initialized ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) ) . a ) + ( ( Initialized ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) ) . ( intloc ( 0 ) ) ) ) by SCMFSA_2:64
.= ( ( ( Initialized ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) ) . a ) + 1 ) by SCMFSA6A:38
.= ( ( ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) . a ) + 1 ) by SCMFSA6C:3
.= ( ( ( Initialized ( SW2 . k ) ) . a ) + 1 ) by A13,A15,A19,CKB1:1
.= ( ( ( SW2 . k ) . a ) + 1 ) by SCMFSA6C:3;
hence ( ( SF . k1 ) . a ) = ( k1 + ( s . bb ) ) by A6,A8,A9,A18,A19,SCMFSA6A:7,XXREAL_0:2;
( k1 + ( s . bb ) ) <= ( ( ( ( s . cc ) + 1 ) - ( s . bb ) ) + ( s . bb ) ) by A8,XREAL_1:6;
hence ( ( SF . k1 ) . a ) <= ( ( s . cc ) + 1 ) by A6,A8,A9,A18,A19,A20,SCMFSA6A:7,XXREAL_0:2;
end;
( ( IExec (IB,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) . aux ) = ( ( IExec (( ( AddTo (a,( intloc ( 0 ) )) ) ';' ( SubFrom (aux,( intloc ( 0 ) )) ) ),( p +* ( while>0 (aux,IB) ) ),( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) )) ) . aux ) by A3,A13,A15,SFMASTR1:7
.= ( ( Exec (( SubFrom (aux,( intloc ( 0 ) )) ),( Exec (( AddTo (a,( intloc ( 0 ) )) ),( Initialized ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) )) )) ) . aux ) by SCMFSA6C:8
.= ( ( ( Exec (( AddTo (a,( intloc ( 0 ) )) ),( Initialized ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) )) ) . aux ) - ( ( Exec (( AddTo (a,( intloc ( 0 ) )) ),( Initialized ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) )) ) . ( intloc ( 0 ) ) ) ) by SCMFSA_2:65
.= ( ( ( Exec (( AddTo (a,( intloc ( 0 ) )) ),( Initialized ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) )) ) . aux ) - ( ( Initialized ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) ) . ( intloc ( 0 ) ) ) ) by SCMFSA_2:64
.= ( ( ( Exec (( AddTo (a,( intloc ( 0 ) )) ),( Initialized ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) )) ) . aux ) - 1 ) by SCMFSA6A:38
.= ( ( ( Initialized ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) ) . aux ) - 1 ) by A4,SCMFSA_2:64
.= ( ( ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) . aux ) - 1 ) by SCMFSA6C:3
.= ( ( ( Initialized ( SW2 . k ) ) . aux ) - 1 ) by A13,A15,A7,CKB1:1,SFMASTR1:1
.= ( ( ( SW2 . k ) . aux ) - 1 ) by SCMFSA6C:3;
hence ( ( ( SF . k1 ) . aux ) + k1 ) = ( ( ( ( SW2 . k ) . aux ) - 1 ) + k1 ) by A18,SCMFSA6A:7
.= scb1 by A6,A8,A9,XXREAL_0:2;
end;

end;
A21: a in ( dom ( s +* (aux,( ( ( s . cc ) - ( s . bb ) ) + 1 )) ) ) by SCMFSA_2:42;
A22: aux in ( dom s ) by SCMFSA_2:42;
A23: P[ ( 0 ) ]
proof
assume A24: ( 0 ) <= scb1;
A25: ( SW2 . ( 0 ) ) = s2 by SCMFSA_9:def 5;
hence ( ( SF . ( 0 ) ) . ( intloc ( 0 ) ) ) = ( ( s +* (aux,( ( ( s . cc ) - ( s . bb ) ) + 1 )) ) . ( intloc ( 0 ) ) ) by FUNCT_7:32
.= 1 by A1,FUNCT_7:32;
hereby
assume (not I destroy a);
thus ( ( SF . ( 0 ) ) . a ) = ( ( 0 ) + ( s . bb ) ) by A21,A25,FUNCT_7:31;
( ( 0 ) + ( s . bb ) ) <= ( ( ( ( s . cc ) + 1 ) - ( s . bb ) ) + ( s . bb ) ) by A24,XREAL_1:6;
hence ( ( SF . ( 0 ) ) . a ) <= ( ( s . cc ) + 1 ) by A21,A25,FUNCT_7:31;
end;
thus ( ( ( SF . ( 0 ) ) . aux ) + ( 0 ) ) = ( ( s +* (aux,( ( ( s . cc ) - ( s . bb ) ) + 1 )) ) . aux ) by A4,A25,FUNCT_7:32
.= scb1 by A22,FUNCT_7:31;
end;
thus (for k holds P[ k ]) from NAT_1:sch 1(A23,A5);
end;
