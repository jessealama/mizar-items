environ
vocabularies NUMBERS,FSM_1,SCMFSA_2,SF_MASTR,AMI_1,SCMFSA7B,SUBSET_1,UNIALG_2,SCMFSA6C,SCMFSA6B,FUNCT_1,XBOOLE_0,FUNCT_4,CARD_1,AMISTD_2,RELAT_1,GRAPHSP,AMI_3,PARTFUN1,COMPLEX1,SCMFSA8B,TURING_1,SCMFSA_9,ARYTM_3,FUNCOP_1,SCMFSA8A,CARD_3,SFMASTR1,ARYTM_1,XXREAL_0,SCMFSA6A,TARSKI,SCMFSA9A,FINSEQ_1,GRAPH_2,AOFA_I00,FUNCT_2,FINSEQ_2,SFMASTR3,NAT_1,SCMNORM,PBOOLE,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,CARD_3,INT_2,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,FUNCT_7,PBOOLE,FUNCOP_1,GRAPH_2,FINSEQ_1,FINSEQ_2,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,SCMFSA9A,XXREAL_0,NAT_1,CKB11,CKB19;
definitions TARSKI,SCMFSA7B,SCMFSA9A,GRAPH_2,SCMFSA6A,COMPOS_1,EXTPRO_1,MEMSTR_0,CKB11,CKB19;
theorems TARSKI,ZFMISC_1,ENUMSET1,ABSVALUE,NAT_1,INT_1,RELAT_1,FUNCT_7,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSEQ_4,GRAPH_2,SCMFSA_2,MEMSTR_0,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,SCMFSA_9,SFMASTR1,SCMFSA9A,SFMASTR2,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,PARTFUN1,AFINSQ_1,PBOOLE,EXTPRO_1,CARD_3,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23;
schemes FUNCT_2,NAT_1;
registrations SUBSET_1,SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,FUNCT_2,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,CARD_3,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,XBOOLE_0,VALUED_0,AFINSQ_1,FUNCOP_1,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,MEMSTR_0,SCMFSA6A,CKB7;
constructors SETWISEO,REAL_1,INT_2,MESFUNC1,SCMFSA6A,SCMFSA6B,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,SCMFSA9A,RELSET_1,FUNCT_4,PBOOLE,GRAPH_2,SCMFSA7B,MEMSTR_0,AMISTD_1,CKB11,CKB19;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve s for (State of ( SCM+FSA ));
reserve a for  read-write Int-Location;
reserve bb for Int-Location;
reserve cc for Int-Location;
reserve x for Int-Location;
reserve Ig for  good (Program of ( SCM+FSA ));
reserve k for (Element of ( NAT ));
reserve p for (Instruction-Sequence of ( SCM+FSA ));
theorem
Th27: (((( s . ( intloc ( 0 ) ) ) = 1 &  ProperForUpBody a,bb,cc,Ig,s,p) & k < ( ( ( s . cc ) - ( s . bb ) ) + 1 )) implies ( ( ( StepForUp (a,bb,cc,Ig,p,s) ) . ( k + 1 ) ) | ( ( { a,bb,cc } \/ ( UsedIntLoc Ig ) ) \/ ( FinSeq-Locations ) ) ) = ( ( IExec (( Ig ';' ( AddTo (a,( intloc ( 0 ) )) ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { a,bb,cc } \/ ( UsedIntLoc Ig ) ) ),( ( Ig ';' ( AddTo (a,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { a,bb,cc } \/ ( UsedIntLoc Ig ) ) ),( intloc ( 0 ) )) ) )) ) ),( ( StepForUp (a,bb,cc,Ig,p,s) ) . k )) ) | ( ( { a,bb,cc } \/ ( UsedIntLoc Ig ) ) \/ ( FinSeq-Locations ) ) ))
proof
assume that
A1: ( s . ( intloc ( 0 ) ) ) = 1
and
A2:  ProperForUpBody a,bb,cc,Ig,s,p
and
A3: k < ( ( ( s . cc ) - ( s . bb ) ) + 1 );
set FL = ( FinSeq-Locations );
set I = Ig;
set aux = ( 1 -stRWNotIn ( { a,bb,cc } \/ ( UsedIntLoc I ) ) );
set SF = ( StepForUp (a,bb,cc,I,p,s) );
set IB = ( ( I ';' ( AddTo (a,( intloc ( 0 ) )) ) ) ';' ( SubFrom (aux,( intloc ( 0 ) )) ) );
set s2 = ( ( s +* (aux,( ( ( s . cc ) - ( s . bb ) ) + 1 )) ) +* (a,( s . bb )) );
set p2 = p;
set SW2 = ( StepWhile>0 (aux,IB,p2,s2) );
SF = SW2;
then A4: ( ( SW2 . k ) . ( intloc ( 0 ) ) ) = 1 by A1,A2,A3,CKB22:1;
set scb1 = ( ( ( s . cc ) - ( s . bb ) ) + 1 );
A5: ( ( ( SF . k ) . aux ) + k ) = scb1 by A1,A2,A3,CKB22:1;
A6: ( ( SW2 . k ) . aux ) > ( 0 )
proof
assume ( ( SW2 . k ) . aux ) <= ( 0 );
then ( ( ( SW2 . k ) . aux ) + k ) < ( ( 0 ) + scb1 ) by A3,XREAL_1:8;
hence contradiction by A5;
end;
set S2 = ( IExec (IB,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) );
set IB1 = ( I ';' ( AddTo (a,( intloc ( 0 ) )) ) );
set Iloc = ( { a,bb,cc } \/ ( UsedIntLoc I ) );
set S1 = ( IExec (IB1,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) );
A7: ( Macro ( AddTo (a,( intloc ( 0 ) )) ) ) is_closed_on ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ),( p +* ( while>0 (aux,IB) ) ) by SCMFSA7B:18;
A8: I is_closed_on ( SF . k ),( p +* ( while>0 (( 1 -stRWNotIn ( { a,bb,cc } \/ ( UsedIntLoc I ) ) ),( ( I ';' ( AddTo (a,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { a,bb,cc } \/ ( UsedIntLoc I ) ) ),( intloc ( 0 ) )) ) )) ) ) by A2,A3,CKB19:def 1;
then A9: I is_closed_on ( Initialized ( SW2 . k ) ),( p +* ( while>0 (aux,IB) ) ) by A4,SFMASTR2:4;
I is_halting_on ( SF . k ),( p +* ( while>0 (( 1 -stRWNotIn ( { a,bb,cc } \/ ( UsedIntLoc I ) ) ),( ( I ';' ( AddTo (a,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { a,bb,cc } \/ ( UsedIntLoc I ) ) ),( intloc ( 0 ) )) ) )) ) ) by A2,A3,CKB19:def 1;
then A10: I is_halting_on ( Initialized ( SW2 . k ) ),( p +* ( while>0 (aux,IB) ) ) by A8,A4,SFMASTR2:5;
( Macro ( AddTo (a,( intloc ( 0 ) )) ) ) is_halting_on ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ),( p +* ( while>0 (aux,IB) ) ) by SCMFSA7B:19;
then A11: IB1 is_halting_on ( Initialized ( SW2 . k ) ),( p +* ( while>0 (aux,IB) ) ) by A9,A10,A7,SFMASTR1:3;
now
hereby
let x being Int-Location;
assume x in Iloc;
then A12: x <> aux by SFMASTR1:20;
( S2 . x ) = ( ( Exec (( SubFrom (aux,( intloc ( 0 ) )) ),S1) ) . x ) by A9,A10,A7,A11,SFMASTR1:2,SFMASTR1:11
.= ( S1 . x ) by A12,SCMFSA_2:65;
hence ( S1 . x ) = ( S2 . x );
end;
let x being FinSeq-Location;
( S2 . x ) = ( ( Exec (( SubFrom (aux,( intloc ( 0 ) )) ),S1) ) . x ) by A9,A10,A7,A11,SFMASTR1:2,SFMASTR1:12
.= ( S1 . x ) by SCMFSA_2:65;
hence ( S1 . x ) = ( S2 . x );
end;
then A13: ( S1 | ( Iloc \/ FL ) ) = ( ( IExec (IB,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) | ( Iloc \/ FL ) ) by SFMASTR2:7;
A14: (IB = ( I ';' ( ( AddTo (a,( intloc ( 0 ) )) ) ';' ( SubFrom (aux,( intloc ( 0 ) )) ) ) ) & ( ( AddTo (a,( intloc ( 0 ) )) ) ';' ( SubFrom (aux,( intloc ( 0 ) )) ) ) is_closed_on ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ),( p +* ( while>0 (aux,IB) ) )) by SCMFSA6A:28,SCMFSA7B:18;
then (( ( AddTo (a,( intloc ( 0 ) )) ) ';' ( SubFrom (aux,( intloc ( 0 ) )) ) ) is_halting_on ( IExec (I,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ),( p +* ( while>0 (aux,IB) ) ) & IB is_closed_on ( Initialized ( SW2 . k ) ),( p +* ( while>0 (aux,IB) ) )) by A9,A10,SCMFSA7B:19,SFMASTR1:2;
then ( DataPart ( SW2 . ( k + 1 ) ) ) = ( DataPart ( IExec (IB,( p +* ( while>0 (aux,IB) ) ),( SW2 . k )) ) ) by A4,A6,A9,A10,A14,SCMFSA9A:32,SFMASTR1:3;
hence thesis by A13,RELAT_1:153,SCMFSA_2:100,XBOOLE_1:9;
end;
