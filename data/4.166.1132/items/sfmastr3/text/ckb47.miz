environ
vocabularies NUMBERS,FSM_1,SCMFSA_2,SF_MASTR,AMI_1,SCMFSA7B,SUBSET_1,UNIALG_2,SCMFSA6C,SCMFSA6B,FUNCT_1,XBOOLE_0,FUNCT_4,CARD_1,AMISTD_2,RELAT_1,GRAPHSP,AMI_3,PARTFUN1,COMPLEX1,SCMFSA8B,TURING_1,SCMFSA_9,ARYTM_3,FUNCOP_1,SCMFSA8A,CARD_3,SFMASTR1,ARYTM_1,XXREAL_0,SCMFSA6A,TARSKI,SCMFSA9A,FINSEQ_1,GRAPH_2,AOFA_I00,FUNCT_2,FINSEQ_2,SFMASTR3,NAT_1,SCMNORM,PBOOLE,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,CARD_3,INT_2,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,FUNCT_7,PBOOLE,FUNCOP_1,GRAPH_2,FINSEQ_1,FINSEQ_2,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,SCMFSA_2,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,SCMFSA9A,XXREAL_0,NAT_1,CKB11,CKB19,CKB25,CKB32,CKB39,CKB46;
definitions TARSKI,SCMFSA7B,SCMFSA9A,GRAPH_2,SCMFSA6A,COMPOS_1,EXTPRO_1,MEMSTR_0,CKB11,CKB19,CKB25,CKB32,CKB39,CKB46;
theorems TARSKI,ZFMISC_1,ENUMSET1,ABSVALUE,NAT_1,INT_1,RELAT_1,FUNCT_7,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSEQ_4,GRAPH_2,SCMFSA_2,MEMSTR_0,SCMFSA6A,SCMFSA6B,SF_MASTR,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA8C,SCMFSA_9,SFMASTR1,SCMFSA9A,SFMASTR2,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,PARTFUN1,AFINSQ_1,PBOOLE,EXTPRO_1,CARD_3,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB28,CKB29,CKB30,CKB31,CKB32,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46;
schemes FUNCT_2,NAT_1;
registrations SUBSET_1,SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,FUNCT_2,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,CARD_3,SCMFSA_2,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,XBOOLE_0,VALUED_0,AFINSQ_1,FUNCOP_1,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,MEMSTR_0,SCMFSA6A,CKB7,CKB27,CKB33,CKB40;
constructors SETWISEO,REAL_1,INT_2,MESFUNC1,SCMFSA6A,SCMFSA6B,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA_9,SFMASTR1,SCMFSA9A,RELSET_1,FUNCT_4,PBOOLE,GRAPH_2,SCMFSA7B,MEMSTR_0,AMISTD_1,CKB11,CKB19,CKB25,CKB32,CKB39,CKB46;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve s for (State of ( SCM+FSA ));
reserve f for FinSeq-Location;
reserve p for (Instruction-Sequence of ( SCM+FSA ));
theorem
(for S being (State of ( SCM+FSA )) holds (S = ( IExec (( Selection-sort f ),p,s) ) implies (( S . f ) is_non_decreasing_on 1,( len ( S . f ) ) & (ex p being (Permutation of ( dom ( s . f ) )) st ( S . f ) = ( ( s . f ) * p )))))
proof
set minpos = ( 2 -ndRWNotIn ( {} ( Int-Locations ) ) );
set cv = ( 1 -stRWNotIn ( {} ( Int-Locations ) ) );
let S being (State of ( SCM+FSA ));
assume that
A1: S = ( IExec (( Selection-sort f ),p,s) );
set I22 = ( swap (f,cv,minpos) );
set finish = ( 1 -stNotUsed ( swap (f,cv,minpos) ) );
set i1 = ( finish :=len f );
set I21 = ( FinSeqMin (f,cv,finish,minpos) );
set I2B = ( I21 ';' I22 );
set I2 = ( for-up (cv,( intloc ( 0 ) ),finish,I2B) );
set s1 = ( Exec (i1,( Initialized s )) );
set p1 = p;
A2: ( s1 . ( intloc ( 0 ) ) ) = ( ( Initialized s ) . ( intloc ( 0 ) ) ) by SCMFSA_2:74
.= 1 by SCMFSA6A:38;
cv in { cv,minpos } by TARSKI:def 2;
then (cv <> ( 1 -stRWNotIn { cv,minpos } ) & cv <> ( 2 -ndRWNotIn { cv,minpos } )) by SFMASTR1:20;
then A3: (not ( swap (f,cv,minpos) ) destroy cv) by CKB41:1;
set SF = ( StepForUp (cv,( intloc ( 0 ) ),finish,I2B,p1,s1) );
A4: ( s1 . finish ) = ( len ( ( Initialized s ) . f ) ) by SCMFSA_2:74
.= ( len ( s . f ) ) by SCMFSA6C:3;
then reconsider n = ( ( ( s1 . finish ) - ( s1 . ( intloc ( 0 ) ) ) ) + 1 ) as (Element of ( NAT )) by A2;
defpred P[ (Element of ( NAT )) ]
 means
($1 <= n implies ((((( ( SF . $1 ) . cv ) = ( $1 + ( s1 . ( intloc ( 0 ) ) ) ) & ( ( SF . $1 ) . finish ) = ( s1 . finish )) & ( ( SF . $1 ) . f ) is_split_at $1) & ( ( SF . $1 ) . f ) is_non_decreasing_on 1,$1) & (ex p being (Permutation of ( dom ( s . f ) )) st ( ( SF . $1 ) . f ) = ( ( s . f ) * p ))));
defpred Q[ Nat ]
 means
($1 < n implies ((( ( SF . $1 ) . ( intloc ( 0 ) ) ) = 1 & I2B is_closed_on ( SF . $1 ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) )) & I2B is_halting_on ( SF . $1 ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) )));
A5: (for k being (Element of ( NAT )) holds (Q[ k ] implies Q[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume that
A6: Q[ k ];
assume ( k + 1 ) < n;
hence A7: ( ( SF . ( k + 1 ) ) . ( intloc ( 0 ) ) ) = 1 by A6,CKB21:1,NAT_1:13;
( ( Initialized ( SF . ( k + 1 ) ) ) . ( intloc ( 0 ) ) ) = 1 by SCMFSA6A:38;
then A8: (I21 is_closed_on ( Initialized ( SF . ( k + 1 ) ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) & I21 is_halting_on ( Initialized ( SF . ( k + 1 ) ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) )) by CKB36:1;
A9: I22 is_closed_on ( IExec (I21,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . ( k + 1 ) )) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) by SCMFSA7B:18;
then A10: I2B is_closed_on ( Initialized ( SF . ( k + 1 ) ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) by A8,SFMASTR1:2;
hence I2B is_closed_on ( SF . ( k + 1 ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) by A7,SFMASTR2:4;
I22 is_halting_on ( IExec (I21,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . ( k + 1 ) )) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) by SCMFSA7B:19;
then I2B is_halting_on ( Initialized ( SF . ( k + 1 ) ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) by A8,A9,SFMASTR1:3;
hence thesis by A7,A10,SFMASTR2:5;
end;
A11: Q[ ( 0 ) ]
proof
( ( Initialized ( SF . ( 0 ) ) ) . ( intloc ( 0 ) ) ) = 1 by SCMFSA6A:38;
then A12: (I21 is_closed_on ( Initialized ( SF . ( 0 ) ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) & I21 is_halting_on ( Initialized ( SF . ( 0 ) ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) )) by CKB36:1;
assume ( 0 ) < n;
thus A13: ( ( SF . ( 0 ) ) . ( intloc ( 0 ) ) ) = 1 by A2,CKB12:1;
A14: I22 is_closed_on ( IExec (I21,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . ( 0 ) )) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) by SCMFSA7B:18;
then A15: I2B is_closed_on ( Initialized ( SF . ( 0 ) ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) by A12,SFMASTR1:2;
hence I2B is_closed_on ( SF . ( 0 ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) by A13,SFMASTR2:4;
I22 is_halting_on ( IExec (I21,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . ( 0 ) )) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) by SCMFSA7B:19;
then I2B is_halting_on ( Initialized ( SF . ( 0 ) ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) by A12,A14,SFMASTR1:3;
hence thesis by A13,A15,SFMASTR2:5;
end;
A16: (for k being (Element of ( NAT )) holds Q[ k ]) from NAT_1:sch 1(A11,A5);
A17:  ProperForUpBody cv,( intloc ( 0 ) ),finish,I2B,s1,p1
proof
let i being (Element of ( NAT ));
thus thesis by A16;
end;
then A18: ( DataPart ( IExec (I2,p1,s1) ) ) = ( DataPart ( SF . n ) ) by A2,CKB30:1;
(I2 is_halting_on s1,p1 & I2 is_closed_on s1,p1) by A2,A17,CKB31:1;
then A19: ( S . f ) = ( ( IExec (I2,p1,s1) ) . f ) by A1,SFMASTR1:15
.= ( ( SF . n ) . f ) by A18,SCMFSA6A:7;
(not ( FinSeqMin (f,cv,finish,minpos) ) destroy cv) by CKB34:1,SFMASTR1:21;
then A20: (not I2B destroy cv) by A3,SCMFSA8C:52;
A21: (for k being (Element of ( NAT )) holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume that
A22: P[ k ];
A23:now
assume A24: k < n;
hence A25: ( ( SF . k ) . ( intloc ( 0 ) ) ) = 1 by A16;
A26: I2B is_closed_on ( SF . k ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) by A16,A24;
hence I2B is_closed_on ( Initialized ( SF . k ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) by A25,SFMASTR2:4;
I2B is_halting_on ( SF . k ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) by A16,A24;
hence I2B is_halting_on ( Initialized ( SF . k ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) by A25,A26,SFMASTR2:5;
thus ( ( SF . k ) . cv ) = ( k + ( s1 . ( intloc ( 0 ) ) ) ) by A22,A24;
thus ( ( SF . k ) . finish ) = ( s1 . finish ) by A22,A24;
thus ( ( SF . k ) . cv ) <= ( s1 . finish ) by A2,A22,A24,NAT_1:13;
thus ( ( SF . ( k + 1 ) ) | ( ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) \/ ( FinSeq-Locations ) ) ) = ( ( IExec (( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . k )) ) | ( ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) \/ ( FinSeq-Locations ) ) ) by A2,A17,A24,CKB24:1;
end;
set F = ( ( SF . k ) . f );
set F1 = ( ( SF . ( k + 1 ) ) . f );
assume A27: ( k + 1 ) <= n;
then consider pp being (Permutation of ( dom ( s . f ) )) such that A28: F = ( ( s . f ) * pp ) by A22,NAT_1:13;
thus ( ( SF . ( k + 1 ) ) . cv ) = ( ( k + 1 ) + ( s1 . ( intloc ( 0 ) ) ) ) by A20,A2,A17,A27,CKB22:1;
A29: (I22 is_closed_on ( Initialized ( IExec (I21,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . k )) ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) & I22 is_halting_on ( Initialized ( IExec (I21,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . k )) ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) )) by SCMFSA7B:18,SCMFSA7B:19;
A30: finish = ( 1 -stRWNotIn ( UsedIntLoc I22 ) ) by SFMASTR1:def 4;
set ma = ( min_at (F,( k + 1 ),( len F )) );
A31: ( dom ( s . f ) ) = ( Seg ( len ( s . f ) ) ) by FINSEQ_1:def 3;
then A32: ( len F ) = ( len ( s . f ) ) by A28,FINSEQ_2:43;
A33: 1 <= ( k + 1 ) by NAT_1:12;
then A34: ( k + 1 ) <= ma by A2,A4,A27,A32,GRAPH_2:59;
then A35: 1 <= ma by A33,XXREAL_0:2;
ma <= ( len F ) by A2,A4,A27,A32,A33,GRAPH_2:59;
then A36: ma in ( dom F ) by A35,FINSEQ_3:25;
A37: { cv,minpos } c= ( UsedIntLoc I22 ) by CKB44:1;
minpos in { cv,minpos } by TARSKI:def 2;
then A38: finish <> minpos by A30,A37,SFMASTR1:20;
cv in { cv,minpos } by TARSKI:def 2;
then A39: cv <> finish by A30,A37,SFMASTR1:20;
A40: cv <> minpos by SFMASTR1:21;
( ( Initialized ( SF . k ) ) . ( intloc ( 0 ) ) ) = 1 by SCMFSA6A:38;
then A41: (I21 is_closed_on ( Initialized ( SF . k ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ) & I21 is_halting_on ( Initialized ( SF . k ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) )) by CKB36:1;
A42: F1 = ( ( F +* (( k + 1 ),( F . ma )) ) +* (ma,( F . ( k + 1 ) )) )
proof
set S2 = ( IExec (I21,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . k )) );
A43: ( len F ) = ( abs ( len F ) ) by ABSVALUE:def 1;
(( ( SF . k ) . finish ) = ( len F ) & ( k + 1 ) = ( abs ( k + 1 ) )) by A4,A23,A27,A28,A31,ABSVALUE:def 1,FINSEQ_2:43,NAT_1:13;
then A44: ( S2 . minpos ) = ma by A2,A23,A27,A38,A40,A33,A43,CKB38:1,NAT_1:13;
then A45: 1 <= ( S2 . minpos ) by A33,A34,XXREAL_0:2;
A46: ( S2 . f ) = F by A23,A27,A38,A40,CKB37:1,NAT_1:13;
then A47: ( S2 . minpos ) <= ( len ( S2 . f ) ) by A2,A4,A27,A32,A33,A44,GRAPH_2:59;
A48: (( S2 . cv ) = ( k + 1 ) & ( S2 . ( intloc ( 0 ) ) ) = 1) by A2,A23,A27,A41,A38,A40,CKB37:1,NAT_1:13,SCMFSA8C:67;
thus F1 = ( ( IExec (( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . k )) ) . f ) by A23,A27,NAT_1:13,SFMASTR2:7
.= ( ( Exec (( AddTo (cv,( intloc ( 0 ) )) ),( IExec (I2B,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . k )) )) ) . f ) by A23,A27,NAT_1:13,SFMASTR1:12
.= ( ( IExec (I2B,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . k )) ) . f ) by SCMFSA_2:64
.= ( ( IExec (I22,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( IExec (I21,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . k )) )) ) . f ) by A41,SFMASTR1:8
.= ( ( F +* (( k + 1 ),( F . ma )) ) +* (ma,( F . ( k + 1 ) )) ) by A2,A4,A27,A32,A33,A46,A44,A45,A47,A48,CKB42:1;
end;
( k + 1 ) in ( dom F ) by A2,A4,A27,A32,A33,FINSEQ_3:25;
then consider p1 being (Permutation of ( dom F )) such that A49: F1 = ( F * p1 ) by A36,A42,FUNCT_7:111;
({ cv,finish,minpos } c= ( UsedIntLoc I21 ) & finish in { cv,finish,minpos }) by CKB35:1,ENUMSET1:def 1;
then finish in ( ( UsedIntLoc I21 ) \/ ( UsedIntLoc I22 ) ) by XBOOLE_0:def 3;
then finish in ( UsedIntLoc I2B ) by SF_MASTR:27;
then finish in ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) by XBOOLE_0:def 3;
hence ( ( SF . ( k + 1 ) ) . finish ) = ( ( IExec (( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ),( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . k )) ) . finish ) by A23,A27,NAT_1:13,SFMASTR2:7
.= ( ( Exec (( AddTo (cv,( intloc ( 0 ) )) ),( IExec (I2B,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . k )) )) ) . finish ) by A23,A27,NAT_1:13,SFMASTR1:11
.= ( ( IExec (I2B,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . k )) ) . finish ) by A39,SCMFSA_2:64
.= ( ( IExec (I22,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( IExec (I21,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . k )) )) ) . finish ) by A41,SFMASTR1:7
.= ( ( Initialized ( IExec (I21,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . k )) ) ) . finish ) by A30,A29,SFMASTR1:20,SFMASTR2:1
.= ( ( IExec (I21,( p +* ( while>0 (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( ( I2B ';' ( AddTo (cv,( intloc ( 0 ) )) ) ) ';' ( SubFrom (( 1 -stRWNotIn ( { cv,( intloc ( 0 ) ),finish } \/ ( UsedIntLoc I2B ) ) ),( intloc ( 0 ) )) ) )) ) ),( SF . k )) ) . finish ) by SCMFSA6C:3
.= ( s1 . finish ) by A23,A27,A38,A40,CKB37:1,NAT_1:13;
thus ( ( SF . ( k + 1 ) ) . f ) is_split_at ( k + 1 ) by A2,A4,A22,A27,A32,A42,GRAPH_2:62,NAT_1:13;
thus ( ( SF . ( k + 1 ) ) . f ) is_non_decreasing_on 1,( k + 1 ) by A2,A4,A22,A27,A32,A42,GRAPH_2:61,NAT_1:13;
( dom F ) = ( dom ( s . f ) ) by A32,FINSEQ_3:29;
then reconsider p1 as (Permutation of ( dom ( s . f ) ));
reconsider ppp = ( pp * p1 ) as (Permutation of ( dom ( s . f ) ));
take ppp;
thus thesis by A28,A49,RELAT_1:36;
end;
A50: ( dom ( s . f ) ) = ( Seg ( len ( s . f ) ) ) by FINSEQ_1:def 3;
A51: cv in { cv,minpos } by TARSKI:def 2;
(finish = ( 1 -stRWNotIn ( UsedIntLoc I22 ) ) & { cv,minpos } c= ( UsedIntLoc I22 )) by CKB44:1,SFMASTR1:def 4;
then A52: cv <> finish by A51,SFMASTR1:20;
A53: P[ ( 0 ) ]
proof
assume ( 0 ) <= n;
thus ( ( SF . ( 0 ) ) . cv ) = ( ( 0 ) + ( s1 . ( intloc ( 0 ) ) ) ) by CKB13:1;
thus ( ( SF . ( 0 ) ) . finish ) = ( s1 . finish ) by A52,CKB15:1;
thus ( ( SF . ( 0 ) ) . f ) is_split_at ( 0 )
proof
let i being (Element of ( NAT )),j being (Element of ( NAT ));
assume that
A54: (1 <= i & i <= ( 0 ))
and
( 0 ) < j
and
j <= ( len ( ( SF . ( 0 ) ) . f ) );
thus thesis by A54;
end;

thus ( ( SF . ( 0 ) ) . f ) is_non_decreasing_on 1,( 0 )
proof
let i being (Element of ( NAT )),j being (Element of ( NAT ));
assume that
1 <= i
and
A55: (i <= j & j <= ( 0 ));
thus thesis by A55;
end;

( dom ( s . f ) ) = ( Seg ( len ( s . f ) ) ) by FINSEQ_1:def 3;
then reconsider p = ( idseq ( len ( s . f ) ) ) as (Permutation of ( dom ( s . f ) )) by FINSEQ_2:55;
take p;
( ( SF . ( 0 ) ) . f ) = ( s1 . f ) by CKB17:1
.= ( ( Initialized s ) . f ) by SCMFSA_2:74
.= ( s . f ) by SCMFSA6C:3;
hence thesis by FINSEQ_2:54;
end;
A56: (for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A53,A21);
then (ex p being (Permutation of ( dom ( s . f ) )) st ( ( SF . n ) . f ) = ( ( s . f ) * p ));
then ( len ( S . f ) ) = n by A2,A4,A19,A50,FINSEQ_2:43;
hence ( S . f ) is_non_decreasing_on 1,( len ( S . f ) ) by A56,A19;
thus thesis by A56,A19;
end;
