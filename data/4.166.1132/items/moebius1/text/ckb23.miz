environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,FUNCT_1,CARD_1,XCMPLX_0,INT_2,ORDINAL1,XXREAL_0,ARYTM_3,FINSEQ_1,RELAT_1,ABIAN,NEWTON,NAT_3,PRE_POLY,NAT_1,UPROOTS,CARD_3,TARSKI,INT_1,FINSET_1,ARYTM_1,PYTHTRIP,ZFMISC_1,SQUARE_1,XREAL_0,REAL_1,SETFAM_1,PBOOLE,VALUED_0,FUNCOP_1,MOEBIUS1;
notations TARSKI,XBOOLE_0,SUBSET_1,FINSET_1,ZFMISC_1,ORDINAL1,CARD_1,NUMBERS,XCMPLX_0,XREAL_0,XXREAL_0,NEWTON,SETFAM_1,RELAT_1,FUNCT_1,FUNCT_2,FINSEQ_1,VALUED_0,SEQ_1,PBOOLE,SQUARE_1,RVSUM_1,BINOP_2,FUNCOP_1,XXREAL_2,NAT_3,DOMAIN_1,ABIAN,PYTHTRIP,UPROOTS,RECDEF_1,PRE_POLY,POLYNOM2,REAL_1,NAT_1,NAT_D,INT_2;
definitions TARSKI,XBOOLE_0,RVSUM_1,SQUARE_1;
theorems XBOOLE_0,NAT_3,BAGORDER,NEWTON,INT_2,NAT_2,WSIERP_1,CARD_1,PEPIN,NAT_1,XCMPLX_1,XREAL_1,PYTHTRIP,ABIAN,ORDINAL1,EULER_1,XREAL_0,FINSEQ_1,XBOOLE_1,TARSKI,ZFMISC_1,RVSUM_1,FINSEQ_2,NUMBERS,INT_1,FUNCT_1,PBOOLE,UPROOTS,CARD_4,FUNCOP_1,RADIX_1,RELAT_1,FINSOP_1,XXREAL_0,NAT_D,VALUED_0,XXREAL_2,FUNCT_2,PARTFUN1,PRE_POLY,MEASURE6,CKB1,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB18,CKB19,CKB20,CKB21,CKB22;
schemes FUNCT_2,CLASSES1,PRE_CIRC,SUBSET_1,NAT_1,CKB2;
registrations XBOOLE_0,FUNCT_1,ORDINAL1,FINSET_1,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,FINSEQ_1,NEWTON,NAT_3,VALUED_0,XXREAL_2,CARD_1,FUNCT_2,UPROOTS,RELSET_1,PRE_POLY,REAL_1,CKB3,CKB17;
constructors SETFAM_1,NAT_D,FINSOP_1,ZFMISC_1,BINARITH,WSIERP_1,ABIAN,PEPIN,PYTHTRIP,POLYNOM2,UPROOTS,NAT_3,SEQ_1,RECDEF_1,BINOP_2,XXREAL_2,PRE_POLY,REAL_1,DOMAIN_1,RELSET_1;
requirements NUMERALS,SUBSET,ARITHM,REAL,BOOLE;
begin
reserve m for  natural number;
reserve n for  natural number;
theorem
Th18: (for k being (Element of ( NAT )) holds (for n being non  zero (Element of ( NAT )) holds (( support ( ppf n ) ) c= ( Seg ( k + 1 ) ) implies (ex m being non  zero (Element of ( NAT )) st (ex e being (Element of ( NAT )) st ((( support ( ppf m ) ) c= ( Seg k ) & n = ( m * ( ( k + 1 ) |^ e ) )) & (for p being Prime holds ((p in ( support ( ppf m ) ) implies ( p |-count m ) = ( p |-count n )) & ((not p in ( support ( ppf m ) )) implies ( p |-count m ) <= ( p |-count n ))))))))))
proof
let k being (Element of ( NAT ));
let n being non  zero (Element of ( NAT ));
assume A1: ( support ( ppf n ) ) c= ( Seg ( k + 1 ) );
per cases ;
suppose A2: ( support ( ppf n ) ) c= ( Seg k );

take n;
take e = ( 0 );
( ( k + 1 ) |^ e ) = 1 by NEWTON:4;
hence thesis by A2;
end;
suppose A3: (not ( support ( ppf n ) ) c= ( Seg k ));

reconsider r = ( k + 1 ) as non  zero (Element of ( NAT ));
set e = ( r |-count n );
set s = ( r |^ e );
now
assume A4: (not ( k + 1 ) in ( support ( ppf n ) ));
( support ( ppf n ) ) c= ( Seg k )
proof
let x being set;
assume A5: x in ( support ( ppf n ) );
then reconsider m = x as  natural number;
x in ( support ( pfexp n ) ) by A5,NAT_3:def 9;
then x is Prime by NAT_3:34;
then A6: 1 <= m by INT_2:def 4;
m <= ( k + 1 ) by A1,A5,FINSEQ_1:1;
then m < ( k + 1 ) by A4,A5,XXREAL_0:1;
then m <= k by NAT_1:13;
hence thesis by A6,FINSEQ_1:1;
end;
hence contradiction by A3;
end;
then ( k + 1 ) in ( support ( pfexp n ) ) by NAT_3:def 9;
then A7: r is Prime by NAT_3:34;
then A8: r > 1 by INT_2:def 4;
then s divides n by NAT_3:def 7;
then consider t being Nat such that A9: n = ( s * t ) by NAT_D:def 3;
reconsider s,t as non  zero (Element of ( NAT )) by A9,ORDINAL1:def 12;
A10: ( support ( ppf t ) ) = ( support ( pfexp t ) ) by NAT_3:def 9;
A11: ( support ( ppf t ) ) c= ( Seg k )
proof
set f = ( r |-count t );
let x being set;
assume A12: x in ( support ( ppf t ) );
then reconsider m = x as  natural number;
A13: x in ( support ( pfexp t ) ) by A12,NAT_3:def 9;
A14:now
assume A15: m = r;
( ( pfexp t ) . r ) = f by A7,NAT_3:def 8;
then f <> ( 0 ) by A13,A15,PRE_POLY:def 7;
then f >= ( ( 0 ) + 1 ) by NAT_1:13;
then consider g being Nat such that A16: f = ( 1 + g ) by NAT_1:10;
( r |^ f ) divides t by A8,NAT_3:def 7;
then consider u being Nat such that A17: t = ( ( r |^ f ) * u ) by NAT_D:def 3;
reconsider g as (Element of ( NAT )) by ORDINAL1:def 12;
n = ( s * ( ( ( r |^ g ) * r ) * u ) ) by A9,A16,A17,NEWTON:6
.= ( ( s * r ) * ( ( r |^ g ) * u ) )
.= ( ( r |^ ( e + 1 ) ) * ( ( r |^ g ) * u ) ) by NEWTON:6;
then ( r |^ ( e + 1 ) ) divides n by NAT_D:def 3;
hence contradiction by A8,NAT_3:def 7;
end;
( support ( pfexp t ) ) c= ( support ( pfexp n ) ) by A9,NAT_3:45;
then ( support ( ppf t ) ) c= ( support ( ppf n ) ) by A10,NAT_3:def 9;
then m in ( support ( ppf n ) ) by A12;
then m <= ( k + 1 ) by A1,FINSEQ_1:1;
then m < r by A14,XXREAL_0:1;
then A18: m <= k by NAT_1:13;
x is Prime by A13,NAT_3:34;
then 1 <= m by INT_2:def 4;
hence thesis by A18,FINSEQ_1:1;
end;
A19: e <> ( 0 )
proof
assume e = ( 0 );
then n = ( 1 * t ) by A9,NEWTON:4;
hence thesis by A3,A11;
end;
take m = t;
take e = ( ( k + 1 ) |-count n );
( support ( ppf s ) ) = ( support ( pfexp s ) ) by NAT_3:def 9;
then A20: ( support ( ppf s ) ) = { r } by A7,A19,NAT_3:42;
A21:now
assume ( support ( ppf s ) ) meets ( support ( ppf t ) );
then consider x being set such that A22: x in ( support ( ppf s ) ) and A23: x in ( support ( ppf t ) ) by XBOOLE_0:3;
x = r by A20,A22,TARSKI:def 1;
then r <= k by A11,A23,FINSEQ_1:1;
hence contradiction by NAT_1:13;
end;
(for p being Prime holds ((p in ( support ( ppf m ) ) implies ( p |-count m ) = ( p |-count n )) & ((not p in ( support ( ppf m ) )) implies ( p |-count m ) <= ( p |-count n ))))
proof
let p being Prime;
hereby
assume p in ( support ( ppf m ) );
then (not p in ( support ( ppf s ) )) by A21,XBOOLE_0:3;
then A24: ( p |-count s ) = ( 0 ) by CKB20:1;
( p |-count n ) = ( ( p |-count ( r |^ e ) ) + ( p |-count t ) ) by A9,NAT_3:28;
hence ( p |-count m ) = ( p |-count n ) by A24;
end;
assume (not p in ( support ( ppf m ) ));
hence thesis by CKB20:1;
end;
hence thesis by A9,A11;
end;
end;
