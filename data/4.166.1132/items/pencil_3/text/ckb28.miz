environ
vocabularies NUMBERS,XBOOLE_0,STRUCT_0,PRE_TOPC,PENCIL_2,PENCIL_1,FUNCT_1,RELAT_1,TARSKI,SUBSET_1,PRALG_1,PBOOLE,ZFMISC_1,RELAT_2,FINSEQ_1,NAT_1,XXREAL_0,ARYTM_3,CARD_1,ARYTM_1,WAYBEL_3,RLVECT_2,CARD_3,INTEGRA1,FUNCT_4,FINSET_1,FDIFF_1,PARSP_1,GRAPH_2,FUNCT_2,CAT_1,RCOMP_1,FUNCOP_1,PENCIL_3;
notations TARSKI,XBOOLE_0,ZFMISC_1,XCMPLX_0,XXREAL_0,NUMBERS,NAT_1,RELAT_1,SUBSET_1,FUNCT_1,FUNCT_2,FUNCOP_1,RELSET_1,CARD_1,FINSET_1,FINSEQ_1,CARD_3,DOMAIN_1,STRUCT_0,PRE_TOPC,PBOOLE,PZFMISC1,T_0TOPSP,PRALG_1,WAYBEL_3,PENCIL_1,FUNCT_7,PENCIL_2,TOPS_2,GRAPH_2,CKB19,CKB21;
definitions TARSKI,XBOOLE_0,PBOOLE,FUNCT_1,T_0TOPSP,STRUCT_0,RELAT_1,CKB19,CKB21;
theorems XBOOLE_0,ZFMISC_1,FUNCT_1,FINSEQ_1,FINSEQ_3,NAT_1,CARD_3,PBOOLE,PRE_TOPC,FUNCT_7,PRALG_1,PZFMISC1,TARSKI,FUNCT_2,REALSET1,TOPS_2,PENCIL_1,PENCIL_2,CARD_1,XBOOLE_1,PUA2MSS1,FINSET_1,CARD_2,GRAPH_2,FUNCOP_1,RELAT_1,RELSET_1,XREAL_1,XXREAL_0,ORDINAL1,PARTFUN1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27;
schemes TRANSGEO,NAT_1,FINSEQ_2,PENCIL_2,FINSEQ_1,PBOOLE,CLASSES1;
registrations XBOOLE_0,SUBSET_1,RELSET_1,FUNCT_2,XXREAL_0,XREAL_0,NAT_1,CARD_1,PBOOLE,REALSET1,STRUCT_0,PENCIL_1,ORDINAL1,FUNCT_1,RELAT_1,FINSEQ_1,ZFMISC_1,PRE_POLY;
constructors XXREAL_0,PZFMISC1,TOPS_2,REALSET2,T_0TOPSP,GRAPH_2,PENCIL_2,RELSET_1,PBOOLE,FUNCT_7,PRE_POLY,CKB19,CKB21;
requirements REAL,BOOLE,SUBSET,NUMERALS,ARITHM;
begin
definition
let I being  finite non  empty set;
let A being  PLS-yielding (ManySortedSet of I);
let f being (Collineation of ( Segre_Product A ));
assume that
A1: (for i being (Element of I) holds ( A . i ) is  strongly_connected);
func permutation_of_indices f -> (Permutation of I) means 
:Def3: (for i,j being (Element of I) holds (( it . i ) = j iff (for B1 being (Segre-Coset of A) holds (for b1,b2 being  Segre-like non  trivial-yielding (ManySortedSubset of ( Carrier A )) holds ((B1 = ( product b1 ) & ( f .: B1 ) = ( product b2 )) implies (( indx b1 ) = i implies ( indx b2 ) = j))))));
existence by A1,CKB27:1;
uniqueness
proof
let s being (Permutation of I);
let t being (Permutation of I);
assume that
A2: (for i,j being (Element of I) holds (( s . i ) = j iff (for B1 being (Segre-Coset of A) holds (for b1,b2 being  Segre-like non  trivial-yielding (ManySortedSubset of ( Carrier A )) holds ((B1 = ( product b1 ) & ( f .: B1 ) = ( product b2 )) implies (( indx b1 ) = i implies ( indx b2 ) = j))))))
and
A3: (for i,j being (Element of I) holds (( t . i ) = j iff (for B1 being (Segre-Coset of A) holds (for b1,b2 being  Segre-like non  trivial-yielding (ManySortedSubset of ( Carrier A )) holds ((B1 = ( product b1 ) & ( f .: B1 ) = ( product b2 )) implies (( indx b1 ) = i implies ( indx b2 ) = j))))));
A4:now
let a being set;
assume a in I;
then reconsider i = a as (Element of I);
reconsider j2 = ( t . i ) as (Element of I);
reconsider j1 = ( s . i ) as (Element of I);
consider b1 being  Segre-like non  trivial-yielding (ManySortedSubset of ( Carrier A )) such that A5: ( indx b1 ) = i and A6: ( product b1 ) is (Segre-Coset of A) by CKB8:1;
reconsider B1 = ( product b1 ) as (Segre-Coset of A) by A6;
reconsider fB = ( f .: B1 ) as (Segre-Coset of A) by A1,PENCIL_2:24;
consider b2 being  Segre-like non  trivial-yielding (ManySortedSubset of ( Carrier A )) such that A7: fB = ( product b2 ) and ( b2 . ( indx b2 ) ) = ( [#] ( A . ( indx b2 ) ) ) by PENCIL_2:def 2;
j1 = ( indx b2 ) by A2,A5,A7
.= j2 by A3,A5,A7;
hence ( s . a ) = ( t . a );
end;
(( dom s ) = I & ( dom t ) = I) by FUNCT_2:def 1;
hence s = t by A4,FUNCT_1:2;
end;
end;
