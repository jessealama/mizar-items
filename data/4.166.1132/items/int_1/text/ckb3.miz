environ
vocabularies NUMBERS,SUBSET_1,XREAL_0,ORDINAL1,ZFMISC_1,CARD_1,XBOOLE_0,ARYTM_1,TARSKI,ARYTM_2,ARYTM_3,ARYTM_0,REAL_1,XXREAL_0,NAT_1,RELAT_1,INT_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,ARYTM_2,ARYTM_1,NUMBERS,ARYTM_0,XCMPLX_0,XREAL_0,REAL_1,NAT_1,XXREAL_0;
definitions TARSKI,XBOOLE_0,CARD_1;
theorems NAT_1,AXIOMS,TARSKI,XREAL_0,XCMPLX_0,XCMPLX_1,ZFMISC_1,XBOOLE_0,NUMBERS,ARYTM_0,ARYTM_2,ARYTM_1,XREAL_1,XXREAL_0,ORDINAL1,CKB1,CKB2;
schemes NAT_1,XBOOLE_0,SUBSET_1;
registrations ORDINAL1,NUMBERS,XXREAL_0,XREAL_0,REAL_1,NAT_1;
constructors FUNCT_4,ARYTM_1,ARYTM_0,XXREAL_0,REAL_1,NAT_1,FINSET_1,CARD_1;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve x for set;
reserve k for (Element of ( NAT ));
definition
redefine func INT
means
:Def1: (x in it iff (ex k st (x = k or x = ( - k ))));
compatibility
proof
let I being set;
thus (I = ( INT ) implies (for x holds (x in I iff (ex k st (x = k or x = ( - k ))))))
proof
assume A1: I = ( INT );
let x;
thus (x in I implies (ex k st (x = k or x = ( - k ))))
proof
assume A2: x in I;
then A3: (not x in { [ ( 0 ),( 0 ) ] }) by A1,NUMBERS:def 4,XBOOLE_0:def 5;
per cases  by A1,A2,NUMBERS:def 4,XBOOLE_0:def 3;
suppose x in ( NAT );

hence thesis;
end;
suppose x in [: { ( 0 ) },( NAT ) :];

then x in ( [: { ( 0 ) },( NAT ) :] \ { [ ( 0 ),( 0 ) ] } ) by A3,XBOOLE_0:def 5;
hence thesis by CKB1:1;
end;
end;

given k such that
A4: (x = k or x = ( - k ));

per cases  by A4;
suppose A5: x = k;

then A6: (not x in { [ ( 0 ),( 0 ) ] }) by NUMBERS:def 1,XBOOLE_0:def 5;
x in ( ( NAT ) \/ [: { ( 0 ) },( NAT ) :] ) by A5,XBOOLE_0:def 3;
hence thesis by A1,A6,NUMBERS:def 4,XBOOLE_0:def 5;
end;
suppose (x = ( - k ) & k <> x);

then A7: x in ( [: { ( 0 ) },( NAT ) :] \ { [ ( 0 ),( 0 ) ] } ) by CKB2:1;
then A8: (not x in { [ ( 0 ),( 0 ) ] }) by XBOOLE_0:def 5;
x in ( ( NAT ) \/ [: { ( 0 ) },( NAT ) :] ) by A7,XBOOLE_0:def 3;
hence thesis by A1,A8,NUMBERS:def 4,XBOOLE_0:def 5;
end;
end;

assume A9: (for x holds (x in I iff (ex k st (x = k or x = ( - k )))));
thus I c= ( INT )
proof
let x;
assume x in I;
then consider k such that A10: (x = k or x = ( - k )) by A9;
per cases  by A10;
suppose A11: x = k;

then A12: (not x in { [ ( 0 ),( 0 ) ] }) by NUMBERS:def 1,XBOOLE_0:def 5;
x in ( ( NAT ) \/ [: { ( 0 ) },( NAT ) :] ) by A11,XBOOLE_0:def 3;
hence thesis by A12,NUMBERS:def 4,XBOOLE_0:def 5;
end;
suppose (x = ( - k ) & k <> x);

then A13: x in ( [: { ( 0 ) },( NAT ) :] \ { [ ( 0 ),( 0 ) ] } ) by CKB2:1;
then A14: (not x in { [ ( 0 ),( 0 ) ] }) by XBOOLE_0:def 5;
x in ( ( NAT ) \/ [: { ( 0 ) },( NAT ) :] ) by A13,XBOOLE_0:def 3;
hence thesis by A14,NUMBERS:def 4,XBOOLE_0:def 5;
end;
end;

let x;
assume A15: x in ( INT );
then A16: (not x in { [ ( 0 ),( 0 ) ] }) by NUMBERS:def 4,XBOOLE_0:def 5;
per cases  by A15,NUMBERS:def 4,XBOOLE_0:def 3;
suppose x in ( NAT );

hence thesis by A9;
end;
suppose x in [: { ( 0 ) },( NAT ) :];

then x in ( [: { ( 0 ) },( NAT ) :] \ { [ ( 0 ),( 0 ) ] } ) by A16,XBOOLE_0:def 5;
then (ex k st (x = k or x = ( - k ))) by CKB1:1;
hence thesis by A9;
end;
end;
end;
