environ
vocabularies NUMBERS,PRE_TOPC,SUBSET_1,RELAT_1,SETFAM_1,RCOMP_1,NAT_1,INT_1,XBOOLE_0,TOPS_1,TARSKI,PROB_1,ZFMISC_1,STRUCT_0,FUNCT_1,CARD_1,ARYTM_3,PARTFUN1,FINSET_1,XXREAL_0,COMPTS_1,ARYTM_1,ORDINAL1,T_0TOPSP,TOPS_2,CARD_5,METRIZTS,RLVECT_3,CARD_3,MCART_1,PCOMPS_1,WAYBEL23,TOPDIM_1,FUNCT_2;
notations TARSKI,XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,ORDINAL1,MCART_1,FUNCT_2,CARD_1,CARD_3,CANTOR_1,FINSET_1,NUMBERS,ZFMISC_1,XXREAL_0,REAL_1,SETFAM_1,DOMAIN_1,PRE_TOPC,TOPS_1,TOPS_2,NAT_1,STRUCT_0,COMPTS_1,PCOMPS_1,PROB_1,WAYBEL23,BORSUK_1,BORSUK_3,INT_1,METRIZTS;
definitions COMPTS_1,STRUCT_0,SUBSET_1,TOPS_1,TOPS_2,TARSKI,XBOOLE_0;
theorems CARD_2,CARD_3,FUNCT_1,FUNCT_2,INT_1,KURATO_2,ORDINAL1,MCART_1,NAT_1,PRE_TOPC,PROB_1,RELAT_1,SETFAM_1,SETLIM_1,SUBSET_1,TARSKI,TOPGEN_1,TOPGRP_1,TOPS_1,TOPS_2,TOPS_3,TSEP_1,TSP_1,T_0TOPSP,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,YELLOW12,YELLOW_9,ZFMISC_1,METRIZTS,KURATO_0,CKB1,CKB2;
schemes CLASSES1,FRAENKEL,FUNCT_2,NAT_1,SUBSET_1;
registrations BORSUK_3,CARD_1,COMPTS_1,FINSET_1,FUNCT_2,INT_1,NAT_1,ORDINAL1,PRE_TOPC,RELAT_1,STRUCT_0,SUBSET_1,TOPREAL6,TOPS_1,XBOOLE_0,XCMPLX_0,XREAL_0,XXREAL_0,YELLOW13,METRIZTS,RELSET_1,KURATO_0;
constructors SETFAM_1,TOPS_1,TOPS_2,BORSUK_1,REAL_1,KURATO_2,CANTOR_1,WELLFND1,WAYBEL23,COMPTS_1,BORSUK_3,TSP_1,METRIZTS,RELSET_1,ORDINAL2,PCOMPS_1,KURATO_0,EUCLID;
requirements ARITHM,BOOLE,NUMERALS,REAL,SUBSET;
begin
reserve T for TopSpace;
reserve A for (Subset of T);
reserve U for  open (Subset of ( T | A ));
reserve W for  open (Subset of ( T | A ));
reserve p for (Point of ( T | A ));
reserve n for Nat;
definition
let T;
func Seq_of_ind T -> (SetSequence of (( bool (the carrier of T) ) qua set)) means 
:Def1: (( it . ( 0 ) ) = { ( {} T ) } & (A in ( it . ( n + 1 ) ) iff (A in ( it . n ) or (for p holds (for U holds (p in U implies (ex W st ((p in W & W c= U) & ( Fr W ) in ( it . n )))))))));
existence
proof
defpred P[ set,set ]
 means
(A in $2 iff (A in $1 or (for p holds (for U holds (p in U implies (ex W st ((p in W & W c= U) & ( Fr W ) in $1)))))));
set C = (the carrier of T);
reconsider E = { ( {} T ) } as (Element of ( bool ( bool C ) ));
A1: (for x being set holds (x in ( bool ( bool C ) ) implies (ex y being set st (y in ( bool ( bool C ) ) & P[ x,y ]))))
proof
let x being set;
assume that
x in ( bool ( bool C ) );
defpred Q[ set ]
 means
(for A holds (A = $1 implies (A in x or (for p holds (for U holds (p in U implies (ex W st ((p in W & W c= U) & ( Fr W ) in x))))))));
consider y being (Subset of ( bool C )) such that A2: (for z being set holds (z in y iff (z in ( bool C ) & Q[ z ]))) from SUBSET_1:sch 1;
take y;
thus y in ( bool ( bool C ) );
let A;
(A in y iff Q[ A ]) by A2;
hence thesis;
end;
consider p being (Function of ( bool ( bool C ) ),( bool ( bool C ) )) such that A3: (for x being set holds (x in ( bool ( bool C ) ) implies P[ x,( p . x ) ])) from FUNCT_2:sch 1(A1);
deffunc F(set,set) = ( p /. $2 );
consider f being (Function of ( NAT ),( bool ( bool C ) )) such that A4: ( f . ( 0 ) ) = E and A5: (for n holds ( f . ( n + 1 ) ) = F(n,( f . n ))) from NAT_1:sch 12;
reconsider f as (SetSequence of (( bool (the carrier of T) ) qua set));
take f;
now
let n;
( f . ( n + 1 ) ) = ( p /. ( f . n ) ) by A5
.= ( p . ( f . n ) );
hence (A in ( f . ( n + 1 ) ) iff (A in ( f . n ) or (for p holds (for U holds (p in U implies (ex W st ((p in W & W c= U) & ( Fr W ) in ( f . n )))))))) by A3;
end;
hence thesis by A4;
end;
uniqueness
proof
let Ind1 being (SetSequence of (( bool (the carrier of T) ) qua set));
let Ind2 being (SetSequence of (( bool (the carrier of T) ) qua set));
assume that
A6: (( Ind1 . ( 0 ) ) = { ( {} T ) } & (A in ( Ind1 . ( n + 1 ) ) iff (A in ( Ind1 . n ) or (for p holds (for U holds (p in U implies (ex W st ((p in W & W c= U) & ( Fr W ) in ( Ind1 . n )))))))))
and
A7: (( Ind2 . ( 0 ) ) = { ( {} T ) } & (A in ( Ind2 . ( n + 1 ) ) iff (A in ( Ind2 . n ) or (for p holds (for U holds (p in U implies (ex W st ((p in W & W c= U) & ( Fr W ) in ( Ind2 . n )))))))));
defpred P[ Nat ]
 means
( Ind1 . $1 ) = ( Ind2 . $1 );
A8: (for n being (Element of ( NAT )) holds (P[ n ] implies P[ ( n + 1 ) ]))
proof
let n being (Element of ( NAT ));
assume that
A9: P[ n ];
thus ( Ind1 . ( n + 1 ) ) c= ( Ind2 . ( n + 1 ) )
proof
let x being set;
assume that
A10: x in ( Ind1 . ( n + 1 ) );
reconsider A = x as (Subset of T) by A10;
(A in ( Ind1 . n ) or (for p being (Point of ( T | A )) holds (for U being  open (Subset of ( T | A )) holds (p in U implies (ex W being  open (Subset of ( T | A )) st ((p in W & W c= U) & ( Fr W ) in ( Ind1 . n ))))))) by A6,A10;
hence thesis by A7,A9;
end;

let x being set;
assume that
A11: x in ( Ind2 . ( n + 1 ) );
reconsider A = x as (Subset of T) by A11;
(A in ( Ind2 . n ) or (for p being (Point of ( T | A )) holds (for U being  open (Subset of ( T | A )) holds (p in U implies (ex W being  open (Subset of ( T | A )) st ((p in W & W c= U) & ( Fr W ) in ( Ind2 . n ))))))) by A7,A11;
hence thesis by A6,A9;
end;
A12: P[ ( 0 ) ] by A6,A7;
(for n being (Element of ( NAT )) holds P[ n ]) from NAT_1:sch 1(A12,A8);
hence thesis by FUNCT_2:63;
end;
end;
