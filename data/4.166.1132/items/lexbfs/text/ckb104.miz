environ
vocabularies NUMBERS,FUNCT_1,CARD_1,RELAT_1,TARSKI,FUNCT_4,FUNCOP_1,XBOOLE_0,SUBSET_1,XXREAL_0,ARYTM_3,FINSET_1,XREAL_0,ORDINAL1,ARYTM_1,NAT_1,ZFMISC_1,FINSEQ_1,UPROOTS,VALUED_0,RELAT_2,BAGORDER,PRE_POLY,WELLORD1,GLIB_000,GLIB_001,ORDINAL4,PBOOLE,PARTFUN1,MCART_1,FUNCT_2,FINSUB_1,CHORD,TOPGEN_1,RCOMP_1,FINSEQ_4,GRAPH_1,MEMBERED,ABIAN,LEXBFS;
notations TARSKI,XBOOLE_0,ZFMISC_1,MCART_1,CARD_1,NUMBERS,SUBSET_1,XXREAL_0,VALUED_0,XREAL_0,RELAT_1,RELAT_2,WELLORD1,MEMBERED,XXREAL_2,PARTFUN1,FUNCT_1,FUNCT_2,PBOOLE,ORDINAL1,FINSET_1,XCMPLX_0,NAT_1,NAT_D,FUNCOP_1,FUNCT_4,GLIB_000,GLIB_001,BAGORDER,TERMORD,UPROOTS,CHORD,FINSEQ_1,DOMAIN_1,ABIAN,RELSET_1,RECDEF_1,FINSUB_1,RFUNCT_3,PRE_POLY,CKB7,CKB11,CKB15,CKB18,CKB20,CKB21,CKB26,CKB27,CKB35,CKB36,CKB37,CKB40,CKB41,CKB56,CKB57,CKB58,CKB61,CKB62,CKB63,CKB67,CKB68,CKB69,CKB70,CKB71,CKB72,CKB76,CKB103;
definitions GLIB_000,GLIB_001,FUNCOP_1,TARSKI,CKB7,CKB11,CKB15,CKB20,CKB21,CKB26,CKB27,CKB35,CKB37,CKB41,CKB61,CKB62,CKB63,CKB67,CKB68,CKB71,CKB72,CKB103;
theorems AXIOMS,CARD_1,CARD_2,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSET_1,FUNCT_1,FUNCT_2,FUNCT_4,GLIB_000,GLIB_001,INT_1,NAT_1,BAGORDER,TERMORD,ORDINAL1,PARTFUN1,PBOOLE,NAT_D,XREAL_0,RELAT_1,RELSET_1,TARSKI,XBOOLE_0,XBOOLE_1,XREAL_1,ZFMISC_1,ENUMSET1,CHORD,NECKLACE,FINSEQ_4,WELLORD1,UPROOTS,CARD_FIN,TREES_1,NAT_2,XXREAL_0,XXREAL_2,VALUED_0,MCART_1,FINSUB_1,SYSREL,GRFUNC_1,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB19,CKB20,CKB21,CKB23,CKB24,CKB25,CKB26,CKB27,CKB29,CKB31,CKB33,CKB34,CKB35,CKB37,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB61,CKB62,CKB63,CKB64,CKB65,CKB66,CKB67,CKB68,CKB71,CKB72,CKB73,CKB75,CKB77,CKB78,CKB79,CKB80,CKB81,CKB82,CKB83,CKB85,CKB86,CKB87,CKB88,CKB90,CKB91,CKB92,CKB93,CKB94,CKB95,CKB96,CKB97,CKB98,CKB99,CKB100,CKB101,CKB102,CKB103;
schemes NAT_1,FUNCT_1,RECDEF_1,FRAENKEL,PBOOLE,FUNCT_2,CLASSES1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,XXREAL_0,XREAL_0,XXREAL_2,NAT_1,INT_1,MEMBERED,FINSEQ_1,CARD_1,UPROOTS,FUNCT_2,GLIB_000,ABIAN,BAGORDER,TERMORD,CARD_FIN,GLIB_001,CHORD,VALUED_0,FINSUB_1,PARTFUN1,RELSET_1,PRE_POLY,CKB8,CKB9,CKB10,CKB17,CKB22,CKB28,CKB30,CKB32,CKB38,CKB39,CKB59,CKB60,CKB74,CKB84,CKB89;
constructors DOMAIN_1,FUNCT_4,XXREAL_2,BAGORDER,TERMORD,UPROOTS,CHORD,RECDEF_1,RFUNCT_3,WELLORD2,RELSET_1,PBOOLE,CKB7,CKB11,CKB15,CKB18,CKB20,CKB21,CKB26,CKB27,CKB35,CKB36,CKB37,CKB41,CKB56,CKB57,CKB61,CKB62,CKB63,CKB67,CKB68,CKB69,CKB70,CKB71,CKB72,CKB76,CKB103;
requirements NUMERALS,SUBSET,BOOLE,REAL,ARITHM;
begin
theorem
Th53: (for G being  finite _Graph holds (for n being Nat holds ( ( ( LexBFS:CSeq G ) . n ) `1 ) is  with_property_L3))
proof
let G being  finite _Graph;
let i being Nat;
set CSi = ( ( LexBFS:CSeq G ) . i );
set VLi = ( ( ( LexBFS:CSeq G ) ``1 ) . i );
A1: ( CSi `1 ) = VLi by CKB71:def 1;
now
A2: ( ( LexBFS:CSeq G ) .Lifespan() ) = ( ( ( LexBFS:CSeq G ) ``1 ) .Lifespan() ) by CKB88:1;
A3: ( ( LexBFS:CSeq G ) .Lifespan() ) = ( G .order() ) by CKB86:1;
let a being (Vertex of G);
let b being (Vertex of G);
let c being (Vertex of G);
assume that
A4: a in ( dom VLi )
and
A5: b in ( dom VLi )
and
A6: c in ( dom VLi )
and
A7: ( VLi . a ) < ( VLi . b )
and
A8: ( VLi . b ) < ( VLi . c )
and
A9: a,c are_adjacent 
and
A10: (not b,c are_adjacent );
defpred P[ Nat ]
 means
(ex v being (Vertex of G) st ((((v in ( dom VLi ) & b,v are_adjacent ) & (not a,v are_adjacent )) & ( VLi . c ) < ( VLi . v )) & ( VLi . v ) = $1));
A11: ( VLi . a ) < ( VLi . c ) by A7,A8,XXREAL_0:2;
now
set kc = ( ( G .order() ) -' ( VLi . c ) );
set k = ( ( G .order() ) -' ( VLi . b ) );
assume A12: (for d being (Vertex of G) holds (((d in ( dom VLi ) & ( VLi . c ) < ( VLi . d )) & d,b are_adjacent ) implies d,a are_adjacent ));
set VLc = ( ( ( LexBFS:CSeq G ) ``1 ) . kc );
set CSc = ( ( LexBFS:CSeq G ) . kc );
set VLb = ( ( ( LexBFS:CSeq G ) ``1 ) . k );
set CSb = ( ( LexBFS:CSeq G ) . k );
reconsider sb = ( ( CSb `2 ) . b ),sa = ( ( CSb `2 ) . a ) as  finite (Subset of ( NAT ));
A13: ( ( Seg ( G .order() ) ) \ ( Seg ( ( G .order() ) -' k ) ) ) c= ( Seg ( G .order() ) ) by XBOOLE_1:36;
sb c= ( ( Seg ( G .order() ) ) \ ( Seg ( ( G .order() ) -' k ) ) ) by CKB93:1;
then A14: sb c= ( Seg ( G .order() ) ) by A13,XBOOLE_1:1;
A15: ( CSc `1 ) = VLc by CKB71:def 1;
sa c= ( ( Seg ( G .order() ) ) \ ( Seg ( ( G .order() ) -' k ) ) ) by CKB93:1;
then A16: sa c= ( Seg ( G .order() ) ) by A13,XBOOLE_1:1;
A17: c in ( dom VLb ) by A5,A6,A8,A3,A2,CKB54:1;
A18: ( VLi . c ) <= ( G .order() ) by A3,A2,CKB46:1;
then A19: ( ( G .order() ) -' ( VLi . c ) ) = ( ( G .order() ) - ( VLi . c ) ) by XREAL_1:233;
then A20: kc < ( G .order() ) by A8,XREAL_1:44;
then A21: ( ( G .order() ) -' kc ) = ( ( G .order() ) - ( ( G .order() ) - ( VLi . c ) ) ) by A19,XREAL_1:233;
A22:now
A23: ( rng VLc ) = ( ( Seg ( G .order() ) ) \ ( Seg ( ( G .order() ) -' kc ) ) ) by A3,A2,CKB45:1;
A24: ( VLi . a ) < ( VLi . c ) by A7,A8,XXREAL_0:2;
assume A25: a in ( dom VLc );
then ( VLc . a ) in ( rng VLc ) by FUNCT_1:def 3;
then ( VLi . c ) < ( VLc . a ) by A21,A23,CKB12:1;
hence contradiction by A4,A25,A24,CKB50:1;
end;
( ( ( LexBFS:CSeq G ) ``1 ) .PickedAt kc ) = c by A6,A3,A2,CKB51:1;
then A26: c = ( LexBFS:PickUnnumbered CSc ) by A8,A19,CKB91:1,XREAL_1:44;
A27: kc < k by A8,A18,CKB6:1;
set j = ( VLb . c );
A28: ( CSb `1 ) = VLb by CKB71:def 1;
a in ( G .AdjacentSet { c } ) by A7,A8,A9,CHORD:52;
then ( VLi . c ) in sa by A15,A20,A27,A26,A21,A22,CKB95:1;
then A29: ( VLb . c ) in sa by A6,A17,CKB50:1;
A30: (not b in ( G .AdjacentSet { c } )) by A10,CHORD:52;
A31:now
assume ( VLb . c ) in sb;
then A32: (ex z being (Vertex of G) st ((z in ( dom VLb ) & ( VLb . z ) = ( VLb . c )) & b in ( G .AdjacentSet { z } ))) by A28,CKB102:1;
VLb is  one-to-one by CKB49:1;
hence contradiction by A30,A17,A32,FUNCT_1:def 4;
end;
then ( ( (sb,1) -bag ) . j ) = ( 0 ) by UPROOTS:6;
then A33: ( ( (sb,1) -bag ) . j ) < ( ( (sa,1) -bag ) . j ) by A29,UPROOTS:7;
[ ( (sb,1) -bag ),( (sa,1) -bag ) ] in ( InvLexOrder ( NAT ) )
proof
per cases ;
suppose (for k being Ordinal holds ((j in k & k in ( NAT )) implies ( ( (sb,1) -bag ) . k ) = ( ( (sa,1) -bag ) . k )));

hence thesis by A33,BAGORDER:def 6;
end;
suppose A34: (not (for k being Ordinal holds ((j in k & k in ( NAT )) implies ( ( (sb,1) -bag ) . k ) = ( ( (sa,1) -bag ) . k ))));

defpred M[ Nat ]
 means
(j in $1 & ( ( (sb,1) -bag ) . $1 ) <> ( ( (sa,1) -bag ) . $1 ));
A35: (for k being Nat holds (M[ k ] implies k <= ( G .order() )))
proof
let k being Nat;
assume that
A36: M[ k ];
A37: (( ( (sa,1) -bag ) . k ) = 1 or ( ( (sa,1) -bag ) . k ) = ( 0 )) by UPROOTS:6,UPROOTS:7;
k in ( NAT ) by ORDINAL1:def 12;
then consider ok being Ordinal such that A38: ok = k and j in ok and ok in ( NAT ) and A39: ( ( (sb,1) -bag ) . ok ) <> ( ( (sa,1) -bag ) . ok ) by A36;
per cases ;
suppose (not ok in sb);

then ok in sa by A38,A39,A37,UPROOTS:6;
hence thesis by A16,A38,FINSEQ_1:1;
end;
suppose ok in sb;

hence thesis by A14,A38,FINSEQ_1:1;
end;
end;
A40: (ex k being Nat st M[ k ]) by A34;
consider mm being Nat such that A41: M[ mm ] and A42: (for i being Nat holds (M[ i ] implies i <= mm)) from NAT_1:sch 6(A35,A40);
reconsider mm as (Element of ( NAT )) by ORDINAL1:def 12;
A43:now
let k being Ordinal;
assume that
A44: mm in k
and
A45: k in ( NAT );
reconsider kk = k as (Element of ( NAT )) by A45;
mm in { y where y is (Element of ( NAT )): y < kk } by A44,AXIOMS:4;
then A46: (ex mmy being (Element of ( NAT )) st (mmy = mm & mmy < kk));
assume ( ( (sb,1) -bag ) . k ) <> ( ( (sa,1) -bag ) . k );
hence contradiction by A41,A42,A44,A46,ORDINAL1:10;
end;
j in { y where y is (Element of ( NAT )): y < mm } by A41,AXIOMS:4;
then A47: (ex jy being (Element of ( NAT )) st (jy = j & jy < mm));
A48:now
assume A49: ( ( (sb,1) -bag ) . mm ) = 1;
then mm in sb by UPROOTS:6;
then consider z being (Vertex of G) such that A50: z in ( dom ( CSb `1 ) ) and A51: ( ( CSb `1 ) . z ) = mm and A52: b in ( G .AdjacentSet { z } ) by CKB102:1;
set kc = ( ( G .order() ) -' ( VLi . z ) );
A53: ( VLi . z ) <= ( G .order() ) by A3,A2,CKB46:1;
then A54: ( ( G .order() ) -' ( VLi . z ) ) = ( ( G .order() ) - ( VLi . z ) ) by XREAL_1:233;
k < i by A5,A3,A2,CKB53:1;
then A55: ( CSb `1 ) c= ( CSi `1 ) by A1,A28,CKB48:1;
then A56: ( dom ( CSb `1 ) ) c= ( dom ( CSi `1 ) ) by RELAT_1:11;
then A57: ( 0 ) < ( VLi . z ) by A1,A50,CKB46:1;
then A58: kc < ( G .order() ) by A54,XREAL_1:44;
then A59: ( ( G .order() ) -' kc ) = ( ( G .order() ) - ( ( G .order() ) - ( VLi . z ) ) ) by A54,XREAL_1:233;
set VLc = ( ( ( LexBFS:CSeq G ) ``1 ) . kc );
set CSc = ( ( LexBFS:CSeq G ) . kc );
z = ( ( ( LexBFS:CSeq G ) ``1 ) .PickedAt kc ) by A1,A3,A2,A50,A56,CKB51:1;
then A60: z = ( LexBFS:PickUnnumbered CSc ) by A57,A54,CKB91:1,XREAL_1:44;
A61: [ z,mm ] in ( CSb `1 ) by A50,A51,FUNCT_1:def 2;
then A62: ( VLi . z ) = mm by A1,A50,A55,A56,FUNCT_1:def 2;
A63: [ c,j ] in ( CSb `1 ) by A28,A17,FUNCT_1:def 2;
then A64: ( VLi . c ) = j by A1,A6,A55,FUNCT_1:def 2;
then ( VLi . b ) < ( VLi . z ) by A8,A47,A62,XXREAL_0:2;
then A65: kc < k by A53,CKB6:1;
A66: ( VLi . c ) < ( VLi . z ) by A1,A47,A50,A55,A56,A61,A64,FUNCT_1:def 2;
A67:now
( VLi . a ) < ( VLi . c ) by A7,A8,XXREAL_0:2;
then A68: ( VLi . a ) < ( VLi . z ) by A66,XXREAL_0:2;
A69: ( rng VLc ) = ( ( Seg ( G .order() ) ) \ ( Seg ( ( G .order() ) -' kc ) ) ) by A3,A2,CKB45:1;
assume A70: a in ( dom VLc );
then ( VLc . a ) in ( rng VLc ) by FUNCT_1:def 3;
then ( VLi . z ) < ( VLc . a ) by A59,A69,CKB12:1;
hence contradiction by A4,A70,A68,CKB50:1;
end;
A71: ( VLi . c ) < ( VLi . z ) by A1,A6,A47,A55,A62,A63,FUNCT_1:def 2;
b,z are_adjacent  by A52,CHORD:52;
then z,a are_adjacent  by A1,A12,A47,A50,A56,A62,A64;
then A72: a in ( G .AdjacentSet { z } ) by A11,A71,CHORD:52;
( CSc `1 ) = VLc by CKB71:def 1;
then ( ( G .order() ) -' kc ) in ( ( CSb `2 ) . a ) by A72,A58,A65,A60,A67,CKB95:1;
hence contradiction by A41,A49,A62,A59,UPROOTS:7;
end;
(( ( (sb,1) -bag ) . mm ) = ( 0 ) or ( ( (sb,1) -bag ) . mm ) = 1) by UPROOTS:6,UPROOTS:7;
hence thesis by A41,A48,A43,BAGORDER:def 6;
end;
end;
then A73: ( (sb,1) -bag ) <= ( (sa,1) -bag ),( InvLexOrder ( NAT ) ) by TERMORD:def 2;
( (sb,1) -bag ) <> ( (sa,1) -bag ) by A29,A31,CKB19:1;
then A74: ( (sb,1) -bag ) < ( (sa,1) -bag ),( InvLexOrder ( NAT ) ) by A73,TERMORD:def 3;
( (sa,1) -bag ) <= ( (sb,1) -bag ),( InvLexOrder ( NAT ) ) by A1,A4,A5,A7,CKB101:1;
hence contradiction by A74,TERMORD:5;
end;
then A75: (ex k being Nat st P[ k ]);
A76: (for k being Nat holds (P[ k ] implies k <= ( G .order() )))
proof
let k being Nat;
assume P[ k ];
then k in ( rng VLi ) by FUNCT_1:def 3;
then A77: k in ( ( Seg ( G .order() ) ) \ ( Seg ( ( G .order() ) -' i ) ) ) by A3,A2,CKB45:1;
( ( Seg ( G .order() ) ) \ ( Seg ( ( G .order() ) -' i ) ) ) c= ( Seg ( G .order() ) ) by XBOOLE_1:36;
hence thesis by A77,FINSEQ_1:1;
end;
(ex k being Nat st (P[ k ] & (for n being Nat holds (P[ n ] implies n <= k)))) from NAT_1:sch 6(A76,A75);
then consider k being Nat such that A78: P[ k ] and A79: (for n being Nat holds (P[ n ] implies n <= k));
consider v being (Vertex of G) such that A80: v in ( dom VLi ) and A81: b,v are_adjacent  and A82: (not a,v are_adjacent ) and A83: ( VLi . c ) < ( VLi . v ) and A84: ( VLi . v ) = k by A78;
(for d being (Vertex of G) holds (((d <> v & d,b are_adjacent ) & (not d,a are_adjacent )) implies ( VLi . d ) < ( VLi . v )))
proof
let d being (Vertex of G);
assume that
A85: d <> v
and
A86: d,b are_adjacent 
and
A87: (not d,a are_adjacent );
per cases ;
suppose ( VLi . d ) <= ( VLi . c );

hence thesis by A83,XXREAL_0:2;
end;
suppose A88: ( VLi . c ) < ( VLi . d );

then A89: d in ( dom VLi ) by FUNCT_1:def 2;
VLi is  one-to-one by CKB49:1;
then A90: ( VLi . d ) <> ( VLi . v ) by A80,A85,A89,FUNCT_1:def 4;
( VLi . d ) <= k by A79,A86,A87,A88,A89;
hence thesis by A84,A90,XXREAL_0:1;
end;
end;
hence (ex d being (Vertex of G) st ((((d in ( dom VLi ) & ( VLi . c ) < ( VLi . d )) & b,d are_adjacent ) & (not a,d are_adjacent )) & (for e being (Vertex of G) holds (((e <> d & e,b are_adjacent ) & (not e,a are_adjacent )) implies ( VLi . e ) < ( VLi . d ))))) by A80,A81,A82,A83;
end;
hence thesis by A1,CKB103:def 1;
end;
