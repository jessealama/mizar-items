environ
vocabularies NUMBERS,FUNCT_1,CARD_1,RELAT_1,TARSKI,FUNCT_4,FUNCOP_1,XBOOLE_0,SUBSET_1,XXREAL_0,ARYTM_3,FINSET_1,XREAL_0,ORDINAL1,ARYTM_1,NAT_1,ZFMISC_1,FINSEQ_1,UPROOTS,VALUED_0,RELAT_2,BAGORDER,PRE_POLY,WELLORD1,GLIB_000,GLIB_001,ORDINAL4,PBOOLE,PARTFUN1,MCART_1,FUNCT_2,FINSUB_1,CHORD,TOPGEN_1,RCOMP_1,FINSEQ_4,GRAPH_1,MEMBERED,ABIAN,LEXBFS;
notations TARSKI,XBOOLE_0,ZFMISC_1,MCART_1,CARD_1,NUMBERS,SUBSET_1,XXREAL_0,VALUED_0,XREAL_0,RELAT_1,RELAT_2,WELLORD1,MEMBERED,XXREAL_2,PARTFUN1,FUNCT_1,FUNCT_2,PBOOLE,ORDINAL1,FINSET_1,XCMPLX_0,NAT_1,NAT_D,FUNCOP_1,FUNCT_4,GLIB_000,GLIB_001,BAGORDER,TERMORD,UPROOTS,CHORD,FINSEQ_1,DOMAIN_1,ABIAN,RELSET_1,RECDEF_1,FINSUB_1,RFUNCT_3,PRE_POLY,CKB7,CKB11,CKB15,CKB18,CKB20,CKB21,CKB26,CKB27,CKB35,CKB36,CKB37,CKB40,CKB41,CKB56,CKB57,CKB58,CKB61;
definitions GLIB_000,GLIB_001,FUNCOP_1,TARSKI,CKB7,CKB11,CKB15,CKB20,CKB21,CKB26,CKB27,CKB35,CKB37,CKB41,CKB61;
theorems AXIOMS,CARD_1,CARD_2,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSET_1,FUNCT_1,FUNCT_2,FUNCT_4,GLIB_000,GLIB_001,INT_1,NAT_1,BAGORDER,TERMORD,ORDINAL1,PARTFUN1,PBOOLE,NAT_D,XREAL_0,RELAT_1,RELSET_1,TARSKI,XBOOLE_0,XBOOLE_1,XREAL_1,ZFMISC_1,ENUMSET1,CHORD,NECKLACE,FINSEQ_4,WELLORD1,UPROOTS,CARD_FIN,TREES_1,NAT_2,XXREAL_0,XXREAL_2,VALUED_0,MCART_1,FINSUB_1,SYSREL,GRFUNC_1,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB19,CKB20,CKB21,CKB23,CKB24,CKB25,CKB26,CKB27,CKB29,CKB31,CKB33,CKB34,CKB35,CKB37,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB61;
schemes NAT_1,FUNCT_1,RECDEF_1,FRAENKEL,PBOOLE,FUNCT_2,CLASSES1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,XXREAL_0,XREAL_0,XXREAL_2,NAT_1,INT_1,MEMBERED,FINSEQ_1,CARD_1,UPROOTS,FUNCT_2,GLIB_000,ABIAN,BAGORDER,TERMORD,CARD_FIN,GLIB_001,CHORD,VALUED_0,FINSUB_1,PARTFUN1,RELSET_1,PRE_POLY,CKB8,CKB9,CKB10,CKB17,CKB22,CKB28,CKB30,CKB32,CKB38,CKB39,CKB59,CKB60;
constructors DOMAIN_1,FUNCT_4,XXREAL_2,BAGORDER,TERMORD,UPROOTS,CHORD,RECDEF_1,RFUNCT_3,WELLORD2,RELSET_1,PBOOLE,CKB7,CKB11,CKB15,CKB18,CKB20,CKB21,CKB26,CKB27,CKB35,CKB36,CKB37,CKB41,CKB56,CKB57,CKB61;
requirements NUMERALS,SUBSET,BOOLE,REAL,ARITHM;
begin
definition
let G being  finite _Graph;
let L being (LexBFS:Labeling of G);
func LexBFS:PickUnnumbered L -> (Vertex of G) means 
:Def12: it = ( choose ( the_Vertices_of G ) ) if ( dom ( L `1 ) ) = ( the_Vertices_of G ) otherwise (ex S being non  empty  finite (Subset of ( bool ( NAT ) )) st (ex B being non  empty  finite (Subset of ( Bags ( NAT ) )) st (ex F being Function st ((((S = ( rng F ) & F = ( ( L `2 ) | ( ( the_Vertices_of G ) \ ( dom ( L `1 ) ) ) )) & (for x being  finite (Subset of ( NAT )) holds (x in S implies ( (x,1) -bag ) in B))) & (for x being set holds (x in B implies (ex y being  finite (Subset of ( NAT )) st (y in S & x = ( (y,1) -bag )))))) & it = ( choose ( F " { ( support ( max (B,( InvLexOrder ( NAT ) )) ) ) } ) )))));
existence
proof
set VG = ( the_Vertices_of G );
set V2G = ( L `2 );
set VLG = ( L `1 );
set F = ( V2G | ( VG \ ( dom VLG ) ) );
set S = ( rng F );
A1: (ex f being Function st ((( L `2 ) = f & ( dom f ) = VG) & ( rng f ) c= ( Fin ( NAT ) ))) by FUNCT_2:def 2;
per cases ;
suppose ( dom VLG ) = VG;

hence thesis;
end;
suppose A2: ( dom VLG ) <> VG;

( dom F ) = ( ( dom V2G ) /\ ( VG \ ( dom VLG ) ) ) by RELAT_1:61;
then A3: ( dom F ) = ( ( VG /\ VG ) \ ( dom VLG ) ) by A1,XBOOLE_1:49;
A4:now
assume ( dom F ) = ( {} );
then VG c= ( dom VLG ) by A3,XBOOLE_1:37;
hence contradiction by A2,XBOOLE_0:def 10;
end;
then S is non  empty by RELAT_1:42;
then A5: (for x being (Element of S) holds x is  finite);
A6: ( rng F ) c= ( rng V2G ) by RELAT_1:70;
now
A7: ( rng V2G ) c= ( bool ( NAT ) )
proof
let x being set;
assume x in ( rng V2G );
then x c= ( NAT ) by FINSUB_1:def 5;
hence thesis;
end;
let x being set;
assume that
A8: x in S;
x in ( rng V2G ) by A6,A8;
hence x in ( bool ( NAT ) ) by A7;
thus x is  finite by A8;
end;
then (for x being set holds (x in S implies x in ( bool ( NAT ) )));
then reconsider S as non  empty  finite  with_finite-elements (Subset of ( bool ( NAT ) )) by A4,A5,CKB7:def 1,RELAT_1:42,TARSKI:def 3;
deffunc F( finite (Subset of ( NAT ))) = ( ($1,1) -bag );
set B = { F(x) where x is (Element of S): x in S };
consider z being set such that A9: z in S by XBOOLE_0:def 1;
reconsider z as  finite (Subset of ( NAT )) by A9;
A10: ( (z,1) -bag ) in B by A9;
A11: S is  finite;
A12: B is  finite from FRAENKEL:sch 21(A11);
now
let x being set;
assume x in B;
then (ex y being (Element of S) st (x = ( (y,1) -bag ) & y in S));
hence x in ( Bags ( NAT ) );
end;
then reconsider B as non  empty  finite (Subset of ( Bags ( NAT ) )) by A12,A10,TARSKI:def 3;
A13: (for x being set holds (x in B implies (ex y being  finite (Subset of ( NAT )) st (y in S & x = ( (y,1) -bag )))))
proof
let x being set;
assume x in B;
then (ex y being (Element of S) st (x = ( (y,1) -bag ) & y in S));
hence thesis;
end;
set mw = ( max (B,( InvLexOrder ( NAT ) )) );
mw in B by CKB21:def 1;
then consider y being  finite (Subset of ( NAT )) such that A14: y in S and A15: mw = ( (y,1) -bag ) by A13;
set IT = ( choose ( F " { ( support mw ) } ) );
y = ( support mw ) by A15,UPROOTS:8;
then ( F " { ( support mw ) } ) is non  empty by A14,FUNCT_1:72;
then IT in ( dom F ) by FUNCT_1:def 7;
then IT in ( dom V2G ) by RELAT_1:57;
then reconsider IT as (Vertex of G);
(for x being  finite (Subset of ( NAT )) holds (x in S implies ( (x,1) -bag ) in B));
then (ex S being non  empty  finite (Subset of ( bool ( NAT ) )) st (ex B being non  empty  finite (Subset of ( Bags ( NAT ) )) st (ex F being Function st (((((S = ( rng F ) & F = ( V2G | ( VG \ ( dom VLG ) ) )) & (for x being  finite (Subset of ( NAT )) holds (x in S implies ( (x,1) -bag ) in B))) & (for x being set holds (x in B implies (ex y being  finite (Subset of ( NAT )) st (y in S & x = ( (y,1) -bag )))))) & IT = ( choose ( F " { ( support ( max (B,( InvLexOrder ( NAT ) )) ) ) } ) )) & IT is (Vertex of G))))) by A13;
hence thesis;
end;
end;
uniqueness
proof
let IT1 being (Vertex of G);
let IT2 being (Vertex of G);
set VG = ( the_Vertices_of G );
set V2G = ( L `2 );
set VLG = ( L `1 );
thus (((( dom VLG ) = VG & IT1 = ( choose VG )) & IT2 = ( choose VG )) implies IT1 = IT2);
assume ( dom VLG ) <> VG;
assume (ex S1 being non  empty  finite (Subset of ( bool ( NAT ) )) st (ex B1 being non  empty  finite (Subset of ( Bags ( NAT ) )) st (ex F1 being Function st ((((S1 = ( rng F1 ) & F1 = ( V2G | ( VG \ ( dom VLG ) ) )) & (for x being  finite (Subset of ( NAT )) holds (x in S1 implies ( (x,1) -bag ) in B1))) & (for x being set holds (x in B1 implies (ex y being  finite (Subset of ( NAT )) st (y in S1 & x = ( (y,1) -bag )))))) & IT1 = ( choose ( F1 " { ( support ( max (B1,( InvLexOrder ( NAT ) )) ) ) } ) )))));
then consider S1 being non  empty  finite (Subset of ( bool ( NAT ) )),B1 being non  empty  finite (Subset of ( Bags ( NAT ) )),F1 being Function such that A16: S1 = ( rng F1 ) and A17: F1 = ( V2G | ( VG \ ( dom VLG ) ) ) and A18: (for x being  finite (Subset of ( NAT )) holds (x in S1 implies ( (x,1) -bag ) in B1)) and A19: (for x being set holds (x in B1 implies (ex y being  finite (Subset of ( NAT )) st (y in S1 & x = ( (y,1) -bag ))))) and A20: IT1 = ( choose ( F1 " { ( support ( max (B1,( InvLexOrder ( NAT ) )) ) ) } ) );
assume (ex S2 being non  empty  finite (Subset of ( bool ( NAT ) )) st (ex B2 being non  empty  finite (Subset of ( Bags ( NAT ) )) st (ex F2 being Function st ((((S2 = ( rng F2 ) & F2 = ( V2G | ( VG \ ( dom VLG ) ) )) & (for x being  finite (Subset of ( NAT )) holds (x in S2 implies ( (x,1) -bag ) in B2))) & (for x being set holds (x in B2 implies (ex y being  finite (Subset of ( NAT )) st (y in S2 & x = ( (y,1) -bag )))))) & IT2 = ( choose ( F2 " { ( support ( max (B2,( InvLexOrder ( NAT ) )) ) ) } ) )))));
then consider S2 being non  empty  finite (Subset of ( bool ( NAT ) )),B2 being non  empty  finite (Subset of ( Bags ( NAT ) )),F2 being Function such that A21: S2 = ( rng F2 ) and A22: F2 = ( V2G | ( VG \ ( dom VLG ) ) ) and A23: (for x being  finite (Subset of ( NAT )) holds (x in S2 implies ( (x,1) -bag ) in B2)) and A24: (for x being set holds (x in B2 implies (ex y being  finite (Subset of ( NAT )) st (y in S2 & x = ( (y,1) -bag ))))) and A25: IT2 = ( choose ( F2 " { ( support ( max (B2,( InvLexOrder ( NAT ) )) ) ) } ) );
now
let x being set;
assume x in B2;
then (ex y being  finite (Subset of ( NAT )) st (y in S2 & x = ( (y,1) -bag ))) by A24;
hence x in B1 by A16,A17,A18,A21,A22;
end;
then A26: B2 c= B1 by TARSKI:def 3;
now
let x being set;
assume x in B1;
then (ex y being  finite (Subset of ( NAT )) st (y in S1 & x = ( (y,1) -bag ))) by A19;
hence x in B2 by A16,A17,A21,A22,A23;
end;
then B1 c= B2 by TARSKI:def 3;
hence thesis by A17,A20,A22,A25,A26,XBOOLE_0:def 10;
end;
consistency;
end;
