environ
vocabularies NUMBERS,SUBSET_1,AMI_1,SCMPDS_2,SCMFSA_7,CARD_1,FUNCOP_1,RELAT_1,FUNCT_1,NAT_1,ARYTM_3,XBOOLE_0,TARSKI,VALUED_1,SCMNORM,FSM_1,INT_1,FUNCT_4,GRAPHSP,AMI_3,AMI_2,STRUCT_0,SCMPDS_1,COMPLEX1,XXREAL_0,ARYTM_1,TURING_1,AMISTD_2,SCMFSA6B,MSUALG_1,CIRCUIT2,SCMPDS_4,ORDINAL1,PARTFUN1,SCMFSA6C,ORDINAL4,PBOOLE,FINSET_1,COMPOS_1;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,CARD_1,FINSET_1,NUMBERS,XCMPLX_0,RELAT_1,FUNCT_1,PARTFUN1,AFINSQ_1,VALUED_1,FUNCT_4,FUNCT_7,INT_1,NAT_1,INT_2,XXREAL_0,PBOOLE,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,AMISTD_2,SCMPDS_1,SCMPDS_2;
definitions TARSKI,COMPOS_1,EXTPRO_1,FUNCT_7,XBOOLE_0,SCMPDS_2,FUNCOP_1,NAT_1,AFINSQ_1,FUNCT_4,AMISTD_2,MEMSTR_0;
theorems NAT_1,TARSKI,FUNCT_4,FUNCT_1,ZFMISC_1,INT_1,RELAT_1,SCMPDS_2,AMI_2,FUNCT_2,FUNCT_7,SCMPDS_3,ENUMSET1,ABSVALUE,GRFUNC_1,XBOOLE_0,XBOOLE_1,XREAL_1,ORDINAL1,FUNCOP_1,VALUED_1,AFINSQ_1,PARTFUN1,COMPOS_1,EXTPRO_1,AMISTD_2,PBOOLE,STRUCT_0,MEMSTR_0,CKB1,CKB2,CKB3,CKB4;
schemes NAT_1,CLASSES1;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,ORDINAL1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMPDS_2,AMI_2,FINSET_1,CARD_1,VALUED_1,FUNCT_4,RELAT_1,PRE_POLY,AFINSQ_1,COMPOS_1,ORDINAL5,EXTPRO_1,FUNCOP_1,FUNCT_7,SCMPDS_3,AMISTD_2,PBOOLE,MEMSTR_0;
constructors WELLORD2,XXREAL_0,INT_2,SCMPDS_1,SCMPDS_3,DOMAIN_1,RELSET_1,PRE_POLY,ORDINAL5,AMI_3,AMISTD_2,AMISTD_1,FUNCT_7,MEMSTR_0;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve m for (Element of ( NAT ));
reserve i for (Instruction of ( SCMPDS ));
reserve I for (Program of ( SCMPDS ));
scheme SCMPDSEx { G(set) -> Integer,I() -> (Element of ( NAT )) } : (ex S being (State of ( SCMPDS )) st (( IC S ) = I() & (for i being (Element of ( NAT )) holds ( S . ( DataLoc (i,( 0 )) ) ) = G(i))))
proof
set S1 = { ( IC ( SCMPDS ) ) };
set S2 = ( SCM-Data-Loc );
set S3 = ( NAT );
defpred P[ set,set ]
 means
(ex m st (($1 = ( IC ( SCMPDS ) ) & $2 = I()) or ($1 = ( DataLoc (m,( 0 )) ) & $2 = G(m))));
A1: (for e being set holds (e in (the carrier of ( SCMPDS )) implies (ex u being set st P[ e,u ])))
proof
let e being set;
assume e in (the carrier of ( SCMPDS ));
then e in ( S1 \/ S2 ) by SCMPDS_2:84,STRUCT_0:4;
then A2: e in ( S1 \/ S2 );
now
per cases  by A2,XBOOLE_0:def 3;
case e in S1;
hence e = ( IC ( SCMPDS ) ) by TARSKI:def 1;
end;
case e in S2;
then e is Int_position by SCMPDS_2:3;
hence (ex m st e = ( DataLoc (m,( 0 )) )) by CKB4:1;
end;
end;
then consider m such that A3: (e = ( IC ( SCMPDS ) ) or e = ( DataLoc (m,( 0 )) ));
per cases  by A3;
suppose A4: e = ( IC ( SCMPDS ) );

take u = I();
thus thesis by A4;
end;
suppose A6: e = ( DataLoc (m,( 0 )) );

take u = G(m);
thus thesis by A6;
end;
end;
consider f being Function such that A7: ( dom f ) = (the carrier of ( SCMPDS )) and A8: (for e being set holds (e in (the carrier of ( SCMPDS )) implies P[ e,( f . e ) ])) from CLASSES1:sch 1(A1);
A9: ( dom (the Object-Kind of ( SCMPDS )) ) = (the carrier of ( SCMPDS )) by FUNCT_2:def 1;
now
let x being set;
assume A10: x in ( dom (the Object-Kind of ( SCMPDS )) );
then x in ( S1 \/ S2 ) by A9,SCMPDS_2:84,STRUCT_0:4;
then A11: x in ( S1 \/ S2 );
consider m such that A12: ((x = ( IC ( SCMPDS ) ) & ( f . x ) = I()) or (x = ( DataLoc (m,( 0 )) ) & ( f . x ) = G(m))) by A8,A9,A10;
per cases  by A11,XBOOLE_0:def 3;
suppose x in S2;

then x is Int_position by SCMPDS_2:3;
then ( (the Object-Kind of ( SCMPDS )) . x ) = ( ObjectKind ( DataLoc (m,( 0 )) ) ) by A12,SCMPDS_2:43
.= ( INT ) by SCMPDS_2:5;
hence ( f . x ) in ( (the Object-Kind of ( SCMPDS )) . x ) by A12,INT_1:def 2;
end;
suppose A14: x in S1;

then ( (the Object-Kind of ( SCMPDS )) . x ) = ( ObjectKind ( IC ( SCMPDS ) ) ) by TARSKI:def 1
.= ( NAT ) by MEMSTR_0:def 3;
hence ( f . x ) in ( (the Object-Kind of ( SCMPDS )) . x ) by A12,A14,SCMPDS_2:2,TARSKI:def 1;
end;
end;
then reconsider f as (State of ( SCMPDS )) by A7,A9,FUNCT_1:def 14,PARTFUN1:def 2,RELAT_1:def 18;
consider m such that A15: ((( IC ( SCMPDS ) ) = ( IC ( SCMPDS ) ) & ( f . ( IC ( SCMPDS ) ) ) = I()) or (( IC ( SCMPDS ) ) = ( DataLoc (m,( 0 )) ) & ( f . ( IC ( SCMPDS ) ) ) = G(m))) by A8;
take f;
thus ( IC f ) = I() by A15,SCMPDS_2:43;
let i being (Element of ( NAT ));
(ex m st ((( DataLoc (i,( 0 )) ) = ( IC ( SCMPDS ) ) & ( f . ( DataLoc (i,( 0 )) ) ) = I()) or (( DataLoc (i,( 0 )) ) = ( DataLoc (m,( 0 )) ) & ( f . ( DataLoc (i,( 0 )) ) ) = G(m)))) by A8;
hence thesis by CKB3:1,SCMPDS_2:43;
end;
