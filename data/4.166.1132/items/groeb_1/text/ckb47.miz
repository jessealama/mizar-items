environ
vocabularies NUMBERS,ORDINAL1,RLVECT_1,ALGSTR_0,VECTSP_1,LATTICES,ZFMISC_1,POLYNOM1,SUBSET_1,STRUCT_0,RELAT_2,BAGORDER,BINOP_1,POLYRED,POLYNOM7,ARYTM_1,ARYTM_3,PRE_POLY,TERMORD,FUNCT_1,BROUWER,RELAT_1,XBOOLE_0,XXREAL_0,SUPINF_2,VALUED_0,XCMPLX_0,CAT_3,ALGSTR_1,IDEAL_1,FINSEQ_1,PARTFUN1,MESFUNC1,CARD_3,TARSKI,CARD_1,ORDERS_2,REWRITE1,MCART_1,INT_1,FUNCT_4,GROUP_1,ORDERS_1,DICKSON,RLVECT_2,FUNCOP_1,PBOOLE,FINSET_1,ORDINAL4,GROEB_1;
notations TARSKI,RELAT_1,XBOOLE_0,RELAT_2,XCMPLX_0,XXREAL_0,RELSET_1,FUNCT_1,PARTFUN1,ORDINAL1,ALGSTR_0,ALGSTR_1,RLVECT_1,FINSET_1,FUNCT_7,DICKSON,CARD_3,CARD_1,SUBSET_1,MCART_1,FINSEQ_1,YELLOW_1,ORDERS_1,PRALG_1,STRUCT_0,POLYNOM7,PBOOLE,FUNCOP_1,ORDERS_2,VFUNCT_1,POLYNOM1,IDEAL_1,REWRITE1,BAGORDER,VECTSP_1,TERMORD,GROUP_1,NUMBERS,NAT_1,PRE_POLY,POLYRED,RECDEF_1,CKB1,CKB16,CKB17,CKB29,CKB30;
definitions RELAT_2,RELAT_1,STRUCT_0,CKB16,CKB17,CKB29,CKB30;
theorems TARSKI,RELSET_1,FINSEQ_1,RELAT_1,ZFMISC_1,VECTSP_1,POLYNOM1,RLVECT_1,NAT_1,ALGSTR_1,MCART_1,POLYNOM7,REWRITE1,XBOOLE_0,IDEAL_1,TERMORD,INT_1,FUNCT_1,ORDERS_2,FINSET_1,WELLORD2,XBOOLE_1,CARD_3,DICKSON,FUNCOP_1,PRALG_1,YELLOW_1,FUNCT_7,FUNCT_2,CARD_2,BAGORDER,ORDINAL1,VECTSP_2,POLYRED,RELAT_2,PARTFUN1,ORDERS_1,GROUP_1,XREAL_1,XXREAL_0,VALUED_0,STRUCT_0,PRE_POLY,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46;
schemes RELSET_1,NAT_1,CLASSES1;
registrations XBOOLE_0,RELAT_1,ORDINAL1,FINSET_1,XREAL_0,NAT_1,INT_1,CARD_1,REWRITE1,STRUCT_0,VECTSP_1,ORDERS_2,ALGSTR_1,YELLOW_1,GCD_1,POLYNOM1,POLYNOM2,POLYNOM4,IDEAL_1,POLYNOM7,DICKSON,TERMORD,POLYRED,VALUED_0,ALGSTR_0,FINSEQ_1,SUBSET_1,PRE_POLY,FUNCOP_1,VFUNCT_1,FUNCT_1,FUNCT_2;
constructors XXREAL_0,REWRITE1,VECTSP_2,PRALG_1,YELLOW_1,IDEAL_1,DICKSON,BAGORDER,TERMORD,POLYRED,RECDEF_1,DOMAIN_1,RELSET_1,PBOOLE,FUNCT_7,VFUNCT_1,CKB1,CKB16,CKB17,CKB29,CKB30;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
definition
let n being Ordinal;
func DivOrder n -> (Order of ( Bags n )) means 
:Def5: (for b1,b2 being (bag of n) holds ([ b1,b2 ] in it iff b1 divides b2));
existence
proof
defpred P[ set,set ]
 means
(ex b1,b2 being (Element of ( Bags n )) st (($1 = b1 & $2 = b2) & b1 divides b2));
consider BO being (Relation of ( Bags n ),( Bags n )) such that A1: (for x,y being set holds ([ x,y ] in BO iff ((x in ( Bags n ) & y in ( Bags n )) & P[ x,y ]))) from RELSET_1:sch 1;
A2: BO is_transitive_in ( Bags n )
proof
let x being set;
let y being set;
let z being set;
assume that
x in ( Bags n )
and
y in ( Bags n )
and
z in ( Bags n )
and
A3: [ x,y ] in BO
and
A4: [ y,z ] in BO;
consider b1,b2 being (Element of ( Bags n )) such that A5: x = b1 and A6: (y = b2 & b1 divides b2) by A1,A3;
consider b11,b22 being (Element of ( Bags n )) such that A7: y = b11 and A8: z = b22 and A9: b11 divides b22 by A1,A4;
reconsider B1 = b1,B29 = b22 as (bag of n);
B1 divides B29 by A6,A7,A9,CKB46:1;
hence thesis by A1,A5,A8;
end;
A10: BO is_reflexive_in ( Bags n )
proof
let x being set;
assume x in ( Bags n );
hence thesis by A1;
end;
then A11: (( dom BO ) = ( Bags n ) & ( field BO ) = ( Bags n )) by ORDERS_1:13;
BO is_antisymmetric_in ( Bags n )
proof
let x being set;
let y being set;
assume that
x in ( Bags n )
and
y in ( Bags n )
and
A12: [ x,y ] in BO
and
A13: [ y,x ] in BO;
consider b19,b29 being (Element of ( Bags n )) such that A14: (y = b19 & x = b29) and A15: b19 divides b29 by A1,A13;
consider b11,b22 being (Element of ( Bags n )) such that A16: (x = b11 & y = b22) and A17: b11 divides b22 by A1,A12;
reconsider b11,b22 as (bag of n);
A18:now
let k being set;
assume k in ( dom b11 );
(( b11 . k ) <= ( b22 . k ) & ( b19 . k ) <= ( b29 . k )) by A17,A15,PRE_POLY:def 11;
hence ( b11 . k ) = ( b22 . k ) by A16,A14,XXREAL_0:1;
end;
( dom b11 ) = n by PARTFUN1:def 2
.= ( dom b22 ) by PARTFUN1:def 2;
hence thesis by A16,A18,FUNCT_1:2;
end;
then reconsider BO as (Order of ( Bags n )) by A10,A2,A11,PARTFUN1:def 2,RELAT_2:def 9,RELAT_2:def 12,RELAT_2:def 16;
take BO;
let p being (bag of n);
let q being (bag of n);
hereby
assume [ p,q ] in BO;
then (ex b19,b29 being (Element of ( Bags n )) st ((p = b19 & q = b29) & b19 divides b29)) by A1;
hence p divides q;
end;
(p in ( Bags n ) & q in ( Bags n )) by PRE_POLY:def 12;
hence thesis by A1;
end;
uniqueness
proof
let B1 being (Order of ( Bags n ));
let B2 being (Order of ( Bags n ));
assume that
A19: (for p,q being (bag of n) holds ([ p,q ] in B1 iff p divides q))
and
A20: (for p,q being (bag of n) holds ([ p,q ] in B2 iff p divides q));
let a being set;
let b being set;
hereby
assume A21: [ a,b ] in B1;
then consider b1,b2 being set such that A22: [ a,b ] = [ b1,b2 ] and A23: (b1 in ( Bags n ) & b2 in ( Bags n )) by RELSET_1:2;
reconsider b1,b2 as (bag of n) by A23;
b1 divides b2 by A19,A21,A22;
hence [ a,b ] in B2 by A20,A22;
end;
assume A24: [ a,b ] in B2;
then consider b1,b2 being set such that A25: [ a,b ] = [ b1,b2 ] and A26: (b1 in ( Bags n ) & b2 in ( Bags n )) by RELSET_1:2;
reconsider b1,b2 as (bag of n) by A26;
b1 divides b2 by A20,A24,A25;
hence thesis by A19,A25;
end;
end;
