environ
vocabularies NUMBERS,SUBSET_1,XBOOLE_0,RELAT_1,FUNCT_1,FINSEQ_1,FUNCT_4,FINSEQ_3,XXREAL_0,NAT_1,ARYTM_3,CARD_1,FINSEQ_2,PARTFUN1,SETFAM_1,FUNCT_6,TARSKI,MSUALG_6,RFUNCT_3,VALUED_0,UNIALG_1,CARD_3,FUNCOP_1,FUNCT_2,PRALG_3,ORDINAL1,ORDINAL4,ZFMISC_1,FINSET_1,VALUED_2,REALSET1,NEWTON,ARYTM_1,COMPUT_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,XCMPLX_0,XXREAL_0,RELAT_1,RELSET_1,FUNCT_1,FINSEQ_1,FINSEQ_2,SETFAM_1,FUNCT_2,MARGREL1,FUNCOP_1,XXREAL_2,VALUED_0,FUNCT_4,CARD_3,PROB_1,FINSEQ_3,FINSEQ_4,PARTFUN1,RFUNCT_3,FUNCT_6,FUNCT_7,MIDSP_3,FINSET_1,NEWTON,NAT_D,NAT_1,RECDEF_1,CKB11,CKB21,CKB23,CKB45,CKB49,CKB51,CKB59,CKB64,CKB68;
definitions PARTFUN1,RFUNCT_3,FUNCT_1,RELAT_1,TARSKI,FINSEQ_2,FUNCOP_1,CARD_3,MARGREL1,CKB11,CKB23,CKB45,CKB49,CKB51,CKB59,CKB64,CKB68;
theorems TARSKI,NAT_1,ZFMISC_1,RELAT_1,RELSET_1,FINSEQ_1,FUNCOP_1,PARTFUN1,FINSEQ_2,FINSEQ_4,FUNCT_6,FUNCT_1,RFUNCT_3,FUNCT_2,GRFUNC_1,FUNCT_7,FUNCT_4,FINSEQ_3,SUBSET_1,SETFAM_1,CARD_5,FUNCT_5,CARD_1,CARD_3,NEWTON,WSIERP_1,XBOOLE_0,XBOOLE_1,ORDINAL1,XXREAL_0,VALUED_0,XXREAL_2,XREAL_0,NAT_D,XREAL_1,MARGREL1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB14,CKB16,CKB17,CKB18,CKB20,CKB23,CKB24,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB49,CKB50,CKB51,CKB52,CKB56,CKB57,CKB58,CKB59,CKB60,CKB62,CKB64,CKB65,CKB67,CKB68,CKB69,CKB70,CKB72,CKB73,CKB75;
schemes NAT_1,FUNCT_2,RECDEF_1,MONOID_1,PARTFUN2;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,PARTFUN1,FUNCOP_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,MEMBERED,FINSEQ_1,FINSEQ_2,FUNCT_7,FUNCT_2,VALUED_0,XXREAL_2,CARD_1,RELSET_1,CARD_3,FINSEQ_3,MARGREL1,CKB12,CKB13,CKB15,CKB19,CKB22,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB46,CKB47,CKB48,CKB53,CKB54,CKB55,CKB61,CKB63,CKB66,CKB71,CKB74;
constructors SETFAM_1,DOMAIN_1,FUNCT_4,REAL_1,PROB_1,FINSEQ_3,FINSEQ_4,NEWTON,RFUNCT_3,NAT_D,RECDEF_1,XXREAL_2,MIDSP_3,RELSET_1,FUNCT_6,MARGREL1,XXREAL_1,CKB11,CKB23,CKB45,CKB49,CKB51,CKB59,CKB64,CKB68;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve i for (Element of ( NAT ));
reserve j for (Element of ( NAT ));
reserve m for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
reserve x for set;
reserve y for set;
reserve D for non  empty set;
reserve f for Function;
reserve g for Function;
theorem
(for F being (Function of ( NAT ),( HFuncs D )) holds ((for i holds ( F . i ) c= ( F . ( i + 1 ) )) implies ( Union F ) in ( HFuncs D )))
proof
set X = D;
let F being (Function of ( NAT ),( HFuncs X ));
assume that
A1: (for i being (Element of ( NAT )) holds ( F . i ) c= ( F . ( i + 1 ) ));
A2:now
let n being (Element of ( NAT ));
defpred p[ (Element of ( NAT )) ]
 means
( F . n ) c= ( F . ( n + $1 ) );
let m being (Element of ( NAT ));
A3:now
let i being (Element of ( NAT ));
assume that
A4: p[ i ];
( F . ( n + i ) ) c= ( F . ( ( n + i ) + 1 ) ) by A1;
hence p[ ( i + 1 ) ] by A4,XBOOLE_1:1;
end;
A5: p[ ( 0 ) ];
A6: (for i being (Element of ( NAT )) holds p[ i ]) from NAT_1:sch 1(A5,A3);
assume n <= m;
then consider i being Nat such that A7: m = ( n + i ) by NAT_1:10;
i in ( NAT ) by ORDINAL1:def 12;
hence ( F . n ) c= ( F . m ) by A6,A7;
end;
reconsider Y = ( rng F ) as non  empty (Subset of ( HFuncs X )) by RELAT_1:def 19;
A8: Y is  compatible
proof
let f being Function;
let g being Function;
assume f in Y;
then consider i being set such that A9: i in ( dom F ) and A10: f = ( F . i ) by FUNCT_1:def 3;
assume g in Y;
then consider j being set such that A11: j in ( dom F ) and A12: g = ( F . j ) by FUNCT_1:def 3;
reconsider i,j as (Element of ( NAT )) by A9,A11;
(i <= j or j <= i);
hence thesis by A2,A10,A12,PARTFUN1:54;
end;
Y is (PartFunc-set of ( X * ),X)
proof
let f being (Element of Y);
f is (Element of ( HFuncs X ));
hence thesis;
end;
then ( Union F ) is (PartFunc of ( X * ),X) by A8,CKB20:1;
then reconsider f = ( Union F ) as (Element of ( PFuncs (( X * ),X) )) by PARTFUN1:45;
A13: ( dom f ) = ( union { ( dom g ) where g is (Element of Y): (not contradiction) } ) by A8,CKB16:1;
f is  homogeneous
proof
thus ( dom f ) is  with_common_domain
proof
let x being FinSequence;
let y being FinSequence;
assume x in ( dom f );
then consider A1 being set such that A14: x in A1 and A15: A1 in { ( dom g ) where g is (Element of Y): (not contradiction) } by A13,TARSKI:def 4;
consider g1 being (Element of Y) such that A16: A1 = ( dom g1 ) by A15;
assume y in ( dom f );
then consider A2 being set such that A17: y in A2 and A18: A2 in { ( dom g ) where g is (Element of Y): (not contradiction) } by A13,TARSKI:def 4;
consider g2 being (Element of Y) such that A19: A2 = ( dom g2 ) by A18;
consider i1 being set such that A20: i1 in ( dom F ) and A21: g1 = ( F . i1 ) by FUNCT_1:def 3;
consider i2 being set such that A22: i2 in ( dom F ) and A23: g2 = ( F . i2 ) by FUNCT_1:def 3;
reconsider i1,i2 as (Element of ( NAT )) by A20,A22;
(i1 <= i2 or i2 <= i1);
then (g1 c= g2 or g2 c= g1) by A2,A21,A23;
then (( dom g1 ) c= ( dom g2 ) or ( dom g2 ) c= ( dom g1 )) by GRFUNC_1:2;
then ( dom x ) = ( dom y ) by A14,A16,A17,A19,CARD_3:def 10;
hence ( len x ) = ( len y ) by FINSEQ_3:29;
end;

end;
hence thesis;
end;
