environ
vocabularies NUMBERS,SUBSET_1,XBOOLE_0,RELAT_1,FUNCT_1,FINSEQ_1,FUNCT_4,FINSEQ_3,XXREAL_0,NAT_1,ARYTM_3,CARD_1,FINSEQ_2,PARTFUN1,SETFAM_1,FUNCT_6,TARSKI,MSUALG_6,RFUNCT_3,VALUED_0,UNIALG_1,CARD_3,FUNCOP_1,FUNCT_2,PRALG_3,ORDINAL1,ORDINAL4,ZFMISC_1,FINSET_1,VALUED_2,REALSET1,NEWTON,ARYTM_1,COMPUT_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,XCMPLX_0,XXREAL_0,RELAT_1,RELSET_1,FUNCT_1,FINSEQ_1,FINSEQ_2,SETFAM_1,FUNCT_2,MARGREL1,FUNCOP_1,XXREAL_2,VALUED_0,FUNCT_4,CARD_3,PROB_1,FINSEQ_3,FINSEQ_4,PARTFUN1,RFUNCT_3,FUNCT_6,FUNCT_7,MIDSP_3,FINSET_1,NEWTON,NAT_D,NAT_1,RECDEF_1,CKB11,CKB21,CKB23,CKB45,CKB49,CKB51,CKB59,CKB64,CKB68,CKB80,CKB88,CKB89,CKB96,CKB100,CKB110,CKB111,CKB112;
definitions PARTFUN1,RFUNCT_3,FUNCT_1,RELAT_1,TARSKI,FINSEQ_2,FUNCOP_1,CARD_3,MARGREL1,CKB11,CKB23,CKB45,CKB49,CKB51,CKB59,CKB64,CKB68,CKB88,CKB89,CKB96,CKB110,CKB111,CKB112;
theorems TARSKI,NAT_1,ZFMISC_1,RELAT_1,RELSET_1,FINSEQ_1,FUNCOP_1,PARTFUN1,FINSEQ_2,FINSEQ_4,FUNCT_6,FUNCT_1,RFUNCT_3,FUNCT_2,GRFUNC_1,FUNCT_7,FUNCT_4,FINSEQ_3,SUBSET_1,SETFAM_1,CARD_5,FUNCT_5,CARD_1,CARD_3,NEWTON,WSIERP_1,XBOOLE_0,XBOOLE_1,ORDINAL1,XXREAL_0,VALUED_0,XXREAL_2,XREAL_0,NAT_D,XREAL_1,MARGREL1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB14,CKB16,CKB17,CKB18,CKB20,CKB23,CKB24,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB49,CKB50,CKB51,CKB52,CKB56,CKB57,CKB58,CKB59,CKB60,CKB62,CKB64,CKB65,CKB67,CKB68,CKB69,CKB70,CKB72,CKB73,CKB75,CKB76,CKB77,CKB79,CKB82,CKB83,CKB84,CKB85,CKB86,CKB87,CKB88,CKB89,CKB90,CKB91,CKB92,CKB93,CKB94,CKB95,CKB96,CKB97,CKB98,CKB99,CKB101,CKB102,CKB103,CKB104,CKB105,CKB106,CKB107,CKB108,CKB109,CKB110,CKB111,CKB112,CKB113,CKB115,CKB116,CKB117;
schemes NAT_1,FUNCT_2,RECDEF_1,MONOID_1,PARTFUN2;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,PARTFUN1,FUNCOP_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,MEMBERED,FINSEQ_1,FINSEQ_2,FUNCT_7,FUNCT_2,VALUED_0,XXREAL_2,CARD_1,RELSET_1,CARD_3,FINSEQ_3,MARGREL1,CKB12,CKB13,CKB15,CKB19,CKB22,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB46,CKB47,CKB48,CKB53,CKB54,CKB55,CKB61,CKB63,CKB66,CKB71,CKB74,CKB78,CKB81,CKB114;
constructors SETFAM_1,DOMAIN_1,FUNCT_4,REAL_1,PROB_1,FINSEQ_3,FINSEQ_4,NEWTON,RFUNCT_3,NAT_D,RECDEF_1,XXREAL_2,MIDSP_3,RELSET_1,FUNCT_6,MARGREL1,XXREAL_1,CKB11,CKB23,CKB45,CKB49,CKB51,CKB59,CKB64,CKB68,CKB80,CKB88,CKB89,CKB96,CKB100,CKB110,CKB111,CKB112;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve i for (Element of ( NAT ));
reserve c for (Element of ( NAT ));
reserve m for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
reserve P for  primitive-recursively_closed non  empty (Subset of ( HFuncs ( NAT ) ));
theorem
Th73: ( n const c ) in P
proof
defpred p[ (Element of ( NAT )) ]
 means
( ( 0 ) const $1 ) in P;
defpred r[ (Element of ( NAT )) ]
 means
(for c being (Element of ( NAT )) holds ( $1 const c ) in P);
A1: P is  composition_closed by CKB112:def 1;
A2: (for i being (Element of ( NAT )) holds (p[ i ] implies p[ ( i + 1 ) ]))
proof
reconsider 1succ1 = ( 1 succ 1 ) as  quasi_total (Element of ( HFuncs ( NAT ) )) by CKB57:1;
let i being (Element of ( NAT ));
A3: ( 1 succ 1 ) in P by CKB112:def 1;
A4: ( <*> ( NAT ) ) is (Element of ( ( 0 ) -tuples_on ( NAT ) )) by FINSEQ_2:131;
then A5: ( ( ( 0 ) const i ) . ( {} ) ) = i by FUNCOP_1:7;
reconsider 0consti = ( ( 0 ) const i ) as (Element of ( HFuncs ( NAT ) )) by CKB56:1;
set F = <* ( ( 0 ) const i ) *>;
<* 0consti *> is (FinSequence of ( HFuncs ( NAT ) ));
then reconsider F as  with_the_same_arity (FinSequence of ( HFuncs ( NAT ) ));
assume ( ( 0 ) const i ) in P;
then A6: { ( ( 0 ) const i ) } c= P by ZFMISC_1:31;
A7: ( arity ( 1 succ 1 ) ) = 1 by CKB67:1
.= ( len F ) by FINSEQ_1:39;
A8: ( rng F ) = { ( ( 0 ) const i ) } by FINSEQ_1:39;
now
let h being (Element of ( HFuncs ( NAT ) ));
assume h in ( rng F );
then h = ( ( 0 ) const i ) by A8,TARSKI:def 1;
hence h is  quasi_total by CKB57:1;
end;
then reconsider g = ( 1succ1 * <: F :> ) as  quasi_total (Element of ( HFuncs ( NAT ) )) by A7,CKB85:1;
A9: ( arity ( ( 0 ) const ( i + 1 ) ) ) = ( 0 ) by CKB62:1;
A10: ( ( ( 0 ) const ( i + 1 ) ) . ( {} ) ) = ( i + 1 ) by A4,FUNCOP_1:7;
A11: ( dom ( 1 succ 1 ) ) = ( 1 -tuples_on ( NAT ) ) by CKB64:def 1;
A12: ( arity ( ( 0 ) const i ) ) = ( 0 ) by CKB62:1;
then A13: ( dom ( ( 0 ) const i ) ) = ( ( 0 ) -tuples_on ( NAT ) ) by CKB42:1;
then A14: ( <: F :> . ( {} ) ) = <* i *> by A4,A5,FINSEQ_3:141;
reconsider ii = <* i *> as (Element of ( 1 -tuples_on ( NAT ) )) by FINSEQ_2:131;
A15: ( dom <: <* ( ( 0 ) const i ) *> :> ) = ( dom ( ( 0 ) const i ) ) by FINSEQ_3:141;
then ( g . ( {} ) ) = ( ( 1 succ 1 ) . ( <: F :> . ( {} ) ) ) by A4,A13,FUNCT_1:13;
then A16: ( g . ( {} ) ) = ( ( ii /. 1 ) + 1 ) by A14,CKB64:def 1
.= ( i + 1 ) by FINSEQ_4:16;
A17: ( dom ( ( 0 ) const i ) ) = ( ( 0 ) -tuples_on ( NAT ) ) by A12,CKB42:1;
then ( <: <* ( ( 0 ) const i ) *> :> . ( {} ) ) = ii by A4,A5,FINSEQ_3:141;
then A18: ( {} ) in ( dom g ) by A4,A15,A17,A11,FUNCT_1:11;
( ( 0 ) const i ) in ( rng F ) by A8,TARSKI:def 1;
then ( arity F ) = ( 0 ) by A12,CKB49:def 1;
then ( arity g ) = ( 0 ) by A18,CKB83:1,RELAT_1:38;
then ( ( 0 ) const ( i + 1 ) ) = ( ( 1 succ 1 ) * <: <* ( ( 0 ) const i ) *> :> ) by A9,A10,A18,A16,CKB87:1,RELAT_1:38;
hence thesis by A1,A6,A8,A3,A7,CKB110:def 1;
end;
A19: P is  primitive-recursion_closed by CKB112:def 1;
A20:now
let n being (Element of ( NAT ));
assume that
A21: r[ n ];
thus r[ ( n + 1 ) ]
proof
let i being (Element of ( NAT ));
set g = ( ( n + 1 ) const i );
set f1 = ( n const i );
set j = ( n + 1 );
set f2 = ( ( n + 2 ) proj ( n + 2 ) );
A22: ( dom g ) = ( ( n + 1 ) -tuples_on ( NAT ) ) by FUNCOP_1:13;
A23: ( n + ( 1 + 1 ) ) = ( j + 1 );
then 1 <= ( n + 2 ) by NAT_1:11;
then A24: f2 in P by CKB112:def 1;
A25: ( arity f2 ) = ( n + 2 ) by CKB72:1;
A26: ( dom f2 ) = ( ( n + 2 ) -tuples_on ( NAT ) ) by CKB70:1;
A27: ( arity f1 ) = n by CKB62:1;
A28: ( dom f1 ) = ( n -tuples_on ( NAT ) ) by FUNCOP_1:13;
A29: ( arity g ) = j by CKB62:1;
A30: g is_primitive-recursively_expressed_by f1,f2,( n + 1 )
proof
take m = ( arity g );
thus ( dom g ) c= ( m -tuples_on ( NAT ) ) by CKB39:1;
thus (j >= 1 & j <= m) by CKB62:1,NAT_1:11;
thus (( ( arity f1 ) + 1 ) = m & ( m + 1 ) = ( arity f2 )) by A27,A25,A23,CKB62:1;
let p being (FinSequence of ( NAT ));
assume ( len p ) = m;
then A31: p is (Element of ( j -tuples_on ( NAT ) )) by A29,FINSEQ_2:92;
A32: j >= 1 by NAT_1:11;
hence (( p +* (j,( 0 )) ) in ( dom g ) implies ( Del (p,j) ) in ( dom f1 )) by A28,A31,CKB9:1;
thus (( Del (p,j) ) in ( dom f1 ) implies ( p +* (j,( 0 )) ) in ( dom g )) by A22,A31,A32,CKB115:1;
( f1 . ( Del (p,j) ) ) = i by A31,A32,CKB9:1,FUNCOP_1:7;
hence (( p +* (j,( 0 )) ) in ( dom g ) implies ( g . ( p +* (j,( 0 )) ) ) = ( f1 . ( Del (p,j) ) )) by A31,A32,CKB115:1,FUNCOP_1:7;
let m being (Element of ( NAT ));
A33: ( p +* (j,m) ) in ( j -tuples_on ( NAT ) ) by A31,A32,CKB115:1;
then A34: ( ( p +* (j,m) ) ^ <* i *> ) is (Tuple of ( n + 2 ),( NAT )) by A23,FINSEQ_2:107;
then A35: ( ( p +* (j,m) ) ^ <* i *> ) is (Element of ( ( n + 2 ) -tuples_on ( NAT ) )) by FINSEQ_2:131;
hereby
hereby
assume ( p +* (j,( m + 1 )) ) in ( dom g );
thus ( p +* (j,m) ) in ( dom g ) by A22,A31,A32,CKB115:1;
( g . ( p +* (j,m) ) ) = i by A31,A32,CKB115:1,FUNCOP_1:7;
hence ( ( p +* (j,m) ) ^ <* ( g . ( p +* (j,m) ) ) *> ) in ( dom f2 ) by A26,A34,FINSEQ_2:131;
end;
thus ((( p +* (j,m) ) in ( dom g ) & ( ( p +* (j,m) ) ^ <* ( g . ( p +* (j,m) ) ) *> ) in ( dom f2 )) implies ( p +* (j,( m + 1 )) ) in ( dom g )) by A22,A31,A32,CKB115:1;
end;
assume ( p +* (j,( m + 1 )) ) in ( dom g );
( len ( p +* (j,m) ) ) = j by A33,CARD_1:def 7;
then A36: ( ( ( p +* (j,m) ) ^ <* i *> ) . ( j + 1 ) ) = i by FINSEQ_1:42;
thus ( g . ( p +* (j,( m + 1 )) ) ) = i by A31,A32,CKB115:1,FUNCOP_1:7
.= ( f2 . ( ( p +* (j,m) ) ^ <* i *> ) ) by A36,A35,CKB73:1
.= ( f2 . ( ( p +* (j,m) ) ^ <* ( g . ( p +* (j,m) ) ) *> ) ) by A31,A32,CKB115:1,FUNCOP_1:7;
end;
A37: f1 in P by A21;
( ( n + 1 ) const i ) is (Element of ( HFuncs ( NAT ) )) by CKB56:1;
hence thesis by A19,A30,A37,A24,CKB111:def 1;
end;

end;
A38: p[ ( 0 ) ] by CKB112:def 1;
(for i being (Element of ( NAT )) holds p[ i ]) from NAT_1:sch 1(A38,A2);
then A39: r[ ( 0 ) ];
(for n holds r[ n ]) from NAT_1:sch 1(A39,A20);
hence thesis;
end;
