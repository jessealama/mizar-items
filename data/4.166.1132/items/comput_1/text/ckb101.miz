environ
vocabularies NUMBERS,SUBSET_1,XBOOLE_0,RELAT_1,FUNCT_1,FINSEQ_1,FUNCT_4,FINSEQ_3,XXREAL_0,NAT_1,ARYTM_3,CARD_1,FINSEQ_2,PARTFUN1,SETFAM_1,FUNCT_6,TARSKI,MSUALG_6,RFUNCT_3,VALUED_0,UNIALG_1,CARD_3,FUNCOP_1,FUNCT_2,PRALG_3,ORDINAL1,ORDINAL4,ZFMISC_1,FINSET_1,VALUED_2,REALSET1,NEWTON,ARYTM_1,COMPUT_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,XCMPLX_0,XXREAL_0,RELAT_1,RELSET_1,FUNCT_1,FINSEQ_1,FINSEQ_2,SETFAM_1,FUNCT_2,MARGREL1,FUNCOP_1,XXREAL_2,VALUED_0,FUNCT_4,CARD_3,PROB_1,FINSEQ_3,FINSEQ_4,PARTFUN1,RFUNCT_3,FUNCT_6,FUNCT_7,MIDSP_3,FINSET_1,NEWTON,NAT_D,NAT_1,RECDEF_1,CKB11,CKB21,CKB23,CKB45,CKB49,CKB51,CKB59,CKB64,CKB68,CKB80,CKB88,CKB89,CKB96,CKB100;
definitions PARTFUN1,RFUNCT_3,FUNCT_1,RELAT_1,TARSKI,FINSEQ_2,FUNCOP_1,CARD_3,MARGREL1,CKB11,CKB23,CKB45,CKB49,CKB51,CKB59,CKB64,CKB68,CKB88,CKB89,CKB96;
theorems TARSKI,NAT_1,ZFMISC_1,RELAT_1,RELSET_1,FINSEQ_1,FUNCOP_1,PARTFUN1,FINSEQ_2,FINSEQ_4,FUNCT_6,FUNCT_1,RFUNCT_3,FUNCT_2,GRFUNC_1,FUNCT_7,FUNCT_4,FINSEQ_3,SUBSET_1,SETFAM_1,CARD_5,FUNCT_5,CARD_1,CARD_3,NEWTON,WSIERP_1,XBOOLE_0,XBOOLE_1,ORDINAL1,XXREAL_0,VALUED_0,XXREAL_2,XREAL_0,NAT_D,XREAL_1,MARGREL1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB14,CKB16,CKB17,CKB18,CKB20,CKB23,CKB24,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB49,CKB50,CKB51,CKB52,CKB56,CKB57,CKB58,CKB59,CKB60,CKB62,CKB64,CKB65,CKB67,CKB68,CKB69,CKB70,CKB72,CKB73,CKB75,CKB76,CKB77,CKB79,CKB82,CKB83,CKB84,CKB85,CKB86,CKB87,CKB88,CKB89,CKB90,CKB91,CKB92,CKB93,CKB94,CKB95,CKB96,CKB97,CKB98,CKB99;
schemes NAT_1,FUNCT_2,RECDEF_1,MONOID_1,PARTFUN2;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,PARTFUN1,FUNCOP_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,MEMBERED,FINSEQ_1,FINSEQ_2,FUNCT_7,FUNCT_2,VALUED_0,XXREAL_2,CARD_1,RELSET_1,CARD_3,FINSEQ_3,MARGREL1,CKB12,CKB13,CKB15,CKB19,CKB22,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB46,CKB47,CKB48,CKB53,CKB54,CKB55,CKB61,CKB63,CKB66,CKB71,CKB74,CKB78,CKB81;
constructors SETFAM_1,DOMAIN_1,FUNCT_4,REAL_1,PROB_1,FINSEQ_3,FINSEQ_4,NEWTON,RFUNCT_3,NAT_D,RECDEF_1,XXREAL_2,MIDSP_3,RELSET_1,FUNCT_6,MARGREL1,XXREAL_1,CKB11,CKB23,CKB45,CKB49,CKB51,CKB59,CKB64,CKB68,CKB80,CKB88,CKB89,CKB96,CKB100;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve i for (Element of ( NAT ));
reserve k for (Element of ( NAT ));
reserve m for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
reserve x for set;
reserve X for set;
reserve f for Function;
reserve f1 for non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
reserve f2 for non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
reserve p for (Element of ( ( ( arity f1 ) + 1 ) -tuples_on ( NAT ) ));
defpred Q[ (Element of ( NAT )),(Element of ( HFuncs ( NAT ) )),(Element of ( HFuncs ( NAT ) )),(FinSequence of ( NAT )),(Element of ( NAT )), homogeneous Function ]
 means
(((($5 in ( dom $4 ) & ( $4 +* ($5,$1) ) in ( dom $2 )) & ( ( $4 +* ($5,$1) ) ^ <* ( $2 . ( $4 +* ($5,$1) ) ) *> ) in ( dom $6 )) implies $3 = ( $2 +* ( ( $4 +* ($5,( $1 + 1 )) ) .--> ( $6 . ( ( $4 +* ($5,$1) ) ^ <* ( $2 . ( $4 +* ($5,$1) ) ) *> ) ) ) )) & ((((not $5 in ( dom $4 )) or (not ( $4 +* ($5,$1) ) in ( dom $2 ))) or (not ( ( $4 +* ($5,$1) ) ^ <* ( $2 . ( $4 +* ($5,$1) ) ) *> ) in ( dom $6 ))) implies $3 = $2));
Lm2:now
let f1 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let f2 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let p being (Element of ( ( ( arity f1 ) + 1 ) -tuples_on ( NAT ) ));
let i being (Element of ( NAT ));
let m being (Element of ( NAT ));
set pm1 = ( p +* (i,( m + 1 )) );
set pm = ( p +* (i,m) );
let F1 being (Function of ( NAT ),( HFuncs ( NAT ) ));
let F being (Function of ( NAT ),( HFuncs ( NAT ) ));
assume that
A1: ((i in ( dom pm1 ) & ( Del (pm1,i) ) in ( dom f1 )) implies ( F1 . ( 0 ) ) = ( { ( pm1 +* (i,( 0 )) ) } --> ( f1 . ( Del (pm1,i) ) ) ))
and
A2: (((not i in ( dom pm1 )) or (not ( Del (pm1,i) ) in ( dom f1 ))) implies ( F1 . ( 0 ) ) = ( {} ))
and
A3: (for M being (Element of ( NAT )) holds Q[ M,(( F1 . M ) qua (Element of ( HFuncs ( NAT ) ))),(( F1 . ( M + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))),pm1,i,f2 ])
and
A4: ((i in ( dom pm ) & ( Del (pm,i) ) in ( dom f1 )) implies ( F . ( 0 ) ) = ( { ( pm +* (i,( 0 )) ) } --> ( f1 . ( Del (pm,i) ) ) ))
and
A5: (((not i in ( dom pm )) or (not ( Del (pm,i) ) in ( dom f1 ))) implies ( F . ( 0 ) ) = ( {} ))
and
A6: (for M being (Element of ( NAT )) holds Q[ M,(( F . M ) qua (Element of ( HFuncs ( NAT ) ))),(( F . ( M + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))),pm,i,f2 ]);
A7: ( dom p ) = ( dom pm ) by FUNCT_7:30;
A8: ( pm +* (i,( 0 )) ) = ( p +* (i,( 0 )) ) by FUNCT_7:34
.= ( pm1 +* (i,( 0 )) ) by FUNCT_7:34;
A9: ( dom p ) = ( dom pm1 ) by FUNCT_7:30;
A10: ( Del (pm,i) ) = ( Del (p,i) ) by CKB3:1
.= ( Del (pm1,i) ) by CKB3:1;
(for x being set holds (x in ( NAT ) implies ( F . x ) = ( F1 . x )))
proof
let x being set;
defpred p[ (Element of ( NAT )) ]
 means
( F . $1 ) = ( F1 . $1 );
A11: (for k being (Element of ( NAT )) holds (p[ k ] implies p[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume that
A12: p[ k ];
A13: ( pm +* (i,( k + 1 )) ) = ( p +* (i,( k + 1 )) ) by FUNCT_7:34
.= ( pm1 +* (i,( k + 1 )) ) by FUNCT_7:34;
A14: ( pm +* (i,k) ) = ( p +* (i,k) ) by FUNCT_7:34
.= ( pm1 +* (i,k) ) by FUNCT_7:34;
per cases ;
suppose A15: ((i in ( dom pm ) & ( pm +* (i,k) ) in ( dom ( F . k ) )) & ( ( pm +* (i,k) ) ^ <* ( ( F . k ) . ( pm +* (i,k) ) ) *> ) in ( dom f2 ));

hence ( F . ( k + 1 ) ) = ( ( F . k ) +* ( ( pm +* (i,( k + 1 )) ) .--> ( f2 . ( ( pm +* (i,k) ) ^ <* ( ( F . k ) . ( pm +* (i,k) ) ) *> ) ) ) ) by A6
.= ( F1 . ( k + 1 ) ) by A3,A7,A9,A12,A14,A13,A15;
end;
suppose A16: (((not i in ( dom pm )) or (not ( pm +* (i,k) ) in ( dom ( F . k ) ))) or (not ( ( pm +* (i,k) ) ^ <* ( ( F . k ) . ( pm +* (i,k) ) ) *> ) in ( dom f2 )));

hence ( F . ( k + 1 ) ) = ( F . k ) by A6
.= ( F1 . ( k + 1 ) ) by A3,A7,A9,A12,A14,A16;
end;
end;
A17: p[ ( 0 ) ] by A1,A2,A4,A5,A7,A8,A10,FUNCT_7:30;
A18: (for k being (Element of ( NAT )) holds p[ k ]) from NAT_1:sch 1(A17,A11);
assume x in ( NAT );
hence thesis by A18;
end;
hence F1 = F by FUNCT_2:12;
end;
Lm3:now
let f1 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let f2 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let p being (Element of ( ( ( arity f1 ) + 1 ) -tuples_on ( NAT ) ));
let i being (Element of ( NAT ));
let m being (Element of ( NAT ));
assume that
A1: i in ( dom p );
set pm = ( p +* (i,m) );
set pm1 = ( p +* (i,( m + 1 )) );
let F being (Function of ( NAT ),( HFuncs ( NAT ) ));
assume that
A2: ((i in ( dom pm1 ) & ( Del (pm1,i) ) in ( dom f1 )) implies ( F . ( 0 ) ) = ( { ( pm1 +* (i,( 0 )) ) } --> ( f1 . ( Del (pm1,i) ) ) ))
and
A3: (((not i in ( dom pm1 )) or (not ( Del (pm1,i) ) in ( dom f1 ))) implies ( F . ( 0 ) ) = ( {} ))
and
A4: (for M being (Element of ( NAT )) holds Q[ M,(( F . M ) qua (Element of ( HFuncs ( NAT ) ))),(( F . ( M + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))),pm1,i,f2 ]);
thus ( ( F . ( m + 1 ) ) . pm ) = ( ( F . m ) . pm )
proof
per cases ;
suppose A5: ((i in ( dom pm1 ) & ( pm1 +* (i,m) ) in ( dom ( F . m ) )) & ( ( pm1 +* (i,m) ) ^ <* ( ( F . m ) . ( pm1 +* (i,m) ) ) *> ) in ( dom f2 ));

A6: pm1 = ( pm1 +* (i,( m + 1 )) ) by FUNCT_7:34;
A7: ( pm1 . i ) = ( m + 1 ) by A1,FUNCT_7:31;
( pm . i ) = m by A1,FUNCT_7:31;
then pm <> pm1 by A7;
then A8: (not pm in ( dom ( { ( pm1 +* (i,( m + 1 )) ) } --> ( f2 . ( ( pm1 +* (i,m) ) ^ <* ( ( F . m ) . ( pm1 +* (i,m) ) ) *> ) ) ) )) by A6,TARSKI:def 1;
( F . ( m + 1 ) ) = ( ( F . m ) +* ( ( pm1 +* (i,( m + 1 )) ) .--> ( f2 . ( ( pm1 +* (i,m) ) ^ <* ( ( F . m ) . ( pm1 +* (i,m) ) ) *> ) ) ) ) by A4,A5;
hence thesis by A8,FUNCT_4:11;
end;
suppose (((not i in ( dom pm1 )) or (not ( pm1 +* (i,m) ) in ( dom ( F . m ) ))) or (not ( ( pm1 +* (i,m) ) ^ <* ( ( F . m ) . ( pm1 +* (i,m) ) ) *> ) in ( dom f2 )));

hence thesis by A4;
end;
end;

A9: (for m,k being (Element of ( NAT )) holds (( p +* (i,k) ) in ( dom ( F . m ) ) implies k <= m))
proof
defpred p[ (Element of ( NAT )) ]
 means
(for k being (Element of ( NAT )) holds (( p +* (i,k) ) in ( dom ( F . $1 ) ) implies k <= $1));
A10: (for m being (Element of ( NAT )) holds (p[ m ] implies p[ ( m + 1 ) ]))
proof
let m being (Element of ( NAT ));
assume that
A11: p[ m ];
let k being (Element of ( NAT ));
assume that
A12: ( p +* (i,k) ) in ( dom ( F . ( m + 1 ) ) );
per cases ;
suppose ((i in ( dom pm1 ) & ( pm1 +* (i,m) ) in ( dom ( F . m ) )) & ( ( pm1 +* (i,m) ) ^ <* ( ( F . m ) . ( pm1 +* (i,m) ) ) *> ) in ( dom f2 ));

then ( F . ( m + 1 ) ) = ( ( F . m ) +* ( ( pm1 +* (i,( m + 1 )) ) .--> ( f2 . ( ( pm1 +* (i,m) ) ^ <* ( ( F . m ) . ( pm1 +* (i,m) ) ) *> ) ) ) ) by A4;
then ( dom ( F . ( m + 1 ) ) ) = ( ( dom ( F . m ) ) \/ ( dom ( { ( pm1 +* (i,( m + 1 )) ) } --> ( f2 . ( ( pm1 +* (i,m) ) ^ <* ( ( F . m ) . ( pm1 +* (i,m) ) ) *> ) ) ) ) ) by FUNCT_4:def 1;
then A13: ( dom ( F . ( m + 1 ) ) ) = ( ( dom ( F . m ) ) \/ { ( pm1 +* (i,( m + 1 )) ) } ) by FUNCOP_1:13;
thus k <= ( m + 1 )
proof
per cases  by A12,A13,XBOOLE_0:def 3;
suppose A14: ( p +* (i,k) ) in ( dom ( F . m ) );

A15: m <= ( m + 1 ) by NAT_1:11;
k <= m by A11,A14;
hence thesis by A15,XXREAL_0:2;
end;
suppose ( p +* (i,k) ) in { ( pm1 +* (i,( m + 1 )) ) };

then A16: ( p +* (i,k) ) = ( pm1 +* (i,( m + 1 )) ) by TARSKI:def 1
.= ( p +* (i,( m + 1 )) ) by FUNCT_7:34;
k = ( ( p +* (i,k) ) . i ) by A1,FUNCT_7:31
.= ( m + 1 ) by A1,A16,FUNCT_7:31;
hence thesis;
end;
end;

end;
suppose (((not i in ( dom pm1 )) or (not ( pm1 +* (i,m) ) in ( dom ( F . m ) ))) or (not ( ( pm1 +* (i,m) ) ^ <* ( ( F . m ) . ( pm1 +* (i,m) ) ) *> ) in ( dom f2 )));

then ( F . ( m + 1 ) ) = ( F . m ) by A4;
then A17: k <= m by A11,A12;
m <= ( m + 1 ) by NAT_1:11;
hence thesis by A17,XXREAL_0:2;
end;
end;
A18: p[ ( 0 ) ]
proof
let k being (Element of ( NAT ));
assume that
A19: ( p +* (i,k) ) in ( dom ( F . ( 0 ) ) );
per cases ;
suppose (i in ( dom pm1 ) & ( Del (pm1,i) ) in ( dom f1 ));

then ( dom ( F . ( 0 ) ) ) = { ( pm1 +* (i,( 0 )) ) } by A2,FUNCOP_1:13;
then A20: ( p +* (i,k) ) = ( pm1 +* (i,( 0 )) ) by A19,TARSKI:def 1
.= ( p +* (i,( 0 )) ) by FUNCT_7:34;
k = ( ( p +* (i,k) ) . i ) by A1,FUNCT_7:31
.= ( 0 ) by A1,A20,FUNCT_7:31;
hence thesis;
end;
suppose ((not i in ( dom pm1 )) or (not ( Del (pm1,i) ) in ( dom f1 )));

hence thesis by A3,A19;
end;
end;
thus (for n being (Element of ( NAT )) holds p[ n ]) from NAT_1:sch 1(A18,A10);
end;
thus (not pm1 in ( dom ( F . m ) ))
proof
assume (not thesis);
then ( m + 1 ) <= m by A9;
hence contradiction by NAT_1:13;
end;

end;
Lm4:now
let f1 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let f2 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let p being (Element of ( ( ( arity f1 ) + 1 ) -tuples_on ( NAT ) ));
let i being (Element of ( NAT ));
let m being (Element of ( NAT ));
assume that
A1: i in ( dom p );
let G being (Function of ( ( ( arity f1 ) + 1 ) -tuples_on ( NAT ) ),( HFuncs ( NAT ) ));
assume that
A2: (for p being (Element of ( ( ( arity f1 ) + 1 ) -tuples_on ( NAT ) )) holds ( G . p ) = ( primrec (f1,f2,i,p) ));
thus (for k,n being (Element of ( NAT )) holds ( dom ( G . ( p +* (i,k) ) ) ) c= ( dom ( G . ( p +* (i,( k + n )) ) ) ))
proof
let k being (Element of ( NAT ));
set pk = ( p +* (i,k) );
defpred p[ (Element of ( NAT )) ]
 means
( dom ( G . pk ) ) c= ( dom ( G . ( p +* (i,( k + $1 )) ) ) );
A3:now
let n being (Element of ( NAT ));
assume that
A4: p[ n ];
set m = ( k + n );
set pkn1 = ( p +* (i,( ( k + n ) + 1 )) );
set pkn = ( p +* (i,( k + n )) );
consider F being (Function of ( NAT ),( HFuncs ( NAT ) )) such that A5: ( primrec (f1,f2,i,pkn) ) = ( F . ( pkn /. i ) ) and A6: ((i in ( dom pkn ) & ( Del (pkn,i) ) in ( dom f1 )) implies ( F . ( 0 ) ) = ( ( pkn +* (i,( 0 )) ) .--> ( f1 . ( Del (pkn,i) ) ) )) and A7: (((not i in ( dom pkn )) or (not ( Del (pkn,i) ) in ( dom f1 ))) implies ( F . ( 0 ) ) = ( {} )) and A8: (for M being (Element of ( NAT )) holds Q[ M,(( F . M ) qua (Element of ( HFuncs ( NAT ) ))),(( F . ( M + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))),pkn,i,f2 ]) by CKB89:def 1;
( dom p ) = ( dom pkn1 ) by FUNCT_7:30;
then A9: ( pkn1 /. i ) = ( pkn1 . i ) by A1,PARTFUN1:def 6
.= ( m + 1 ) by A1,FUNCT_7:31;
consider F1 being (Function of ( NAT ),( HFuncs ( NAT ) )) such that A10: ( primrec (f1,f2,i,pkn1) ) = ( F1 . ( pkn1 /. i ) ) and A11: ((i in ( dom pkn1 ) & ( Del (pkn1,i) ) in ( dom f1 )) implies ( F1 . ( 0 ) ) = ( ( pkn1 +* (i,( 0 )) ) .--> ( f1 . ( Del (pkn1,i) ) ) )) and A12: (((not i in ( dom pkn1 )) or (not ( Del (pkn1,i) ) in ( dom f1 ))) implies ( F1 . ( 0 ) ) = ( {} )) and A13: (for M being (Element of ( NAT )) holds Q[ M,(( F1 . M ) qua (Element of ( HFuncs ( NAT ) ))),(( F1 . ( M + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))),pkn1,i,f2 ]) by CKB89:def 1;
F1 = F by A6,A7,A8,A11,A12,A13,Lm2;
then A14: ( G . ( p +* (i,( k + ( n + 1 ) )) ) ) = ( F . ( m + 1 ) ) by A2,A10,A9;
( dom p ) = ( dom pkn ) by FUNCT_7:30;
then ( pkn /. i ) = ( pkn . i ) by A1,PARTFUN1:def 6
.= m by A1,FUNCT_7:31;
then A15: ( G . ( p +* (i,( k + n )) ) ) = ( F . m ) by A2,A5;
per cases ;
suppose ((i in ( dom pkn ) & ( pkn +* (i,m) ) in ( dom ( F . m ) )) & ( ( pkn +* (i,m) ) ^ <* ( ( F . m ) . ( pkn +* (i,m) ) ) *> ) in ( dom f2 ));

then ( F . ( m + 1 ) ) = ( ( F . m ) +* ( ( pkn +* (i,( m + 1 )) ) .--> ( f2 . ( ( pkn +* (i,m) ) ^ <* ( ( F . m ) . ( pkn +* (i,m) ) ) *> ) ) ) ) by A8;
then ( dom ( F . ( m + 1 ) ) ) = ( ( dom ( F . m ) ) \/ ( dom ( { ( pkn +* (i,( m + 1 )) ) } --> ( f2 . ( ( pkn +* (i,m) ) ^ <* ( ( F . m ) . ( pkn +* (i,m) ) ) *> ) ) ) ) ) by FUNCT_4:def 1;
then ( dom ( F . m ) ) c= ( dom ( F . ( m + 1 ) ) ) by XBOOLE_1:7;
hence p[ ( n + 1 ) ] by A4,A14,A15,XBOOLE_1:1;
end;
suppose (((not i in ( dom pkn )) or (not ( pkn +* (i,m) ) in ( dom ( F . m ) ))) or (not ( ( pkn +* (i,m) ) ^ <* ( ( F . m ) . ( pkn +* (i,m) ) ) *> ) in ( dom f2 )));

hence p[ ( n + 1 ) ] by A4,A8,A14,A15;
end;
end;
A16: p[ ( 0 ) ];
thus (for n being (Element of ( NAT )) holds p[ n ]) from NAT_1:sch 1(A16,A3);
end;

end;
Lm5:now
let f1 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let f2 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let p being (Element of ( ( ( arity f1 ) + 1 ) -tuples_on ( NAT ) ));
let i being (Element of ( NAT ));
let m being (Element of ( NAT ));
assume that
A1: i in ( dom p );
let G being (Function of ( ( ( arity f1 ) + 1 ) -tuples_on ( NAT ) ),( HFuncs ( NAT ) ));
assume that
A2: (for p being (Element of ( ( ( arity f1 ) + 1 ) -tuples_on ( NAT ) )) holds ( G . p ) = ( primrec (f1,f2,i,p) ));
thus (for k,n being (Element of ( NAT )) holds ((not ( p +* (i,k) ) in ( dom ( G . ( p +* (i,k) ) ) )) implies (not ( p +* (i,k) ) in ( dom ( G . ( p +* (i,( k + n )) ) ) ))))
proof
let k being (Element of ( NAT ));
set pk = ( p +* (i,k) );
defpred p[ (Element of ( NAT )) ]
 means
((not pk in ( dom ( G . pk ) )) implies (not pk in ( dom ( G . ( p +* (i,( k + $1 )) ) ) )));
A3: (for n being (Element of ( NAT )) holds (p[ n ] implies p[ ( n + 1 ) ]))
proof
let n being (Element of ( NAT ));
assume that
A4: p[ n ]
and
A5: (not pk in ( dom ( G . pk ) ));
set m = ( k + n );
set pkn = ( p +* (i,( k + n )) );
consider F being (Function of ( NAT ),( HFuncs ( NAT ) )) such that A6: ( primrec (f1,f2,i,pkn) ) = ( F . ( pkn /. i ) ) and A7: ((i in ( dom pkn ) & ( Del (pkn,i) ) in ( dom f1 )) implies ( F . ( 0 ) ) = ( ( pkn +* (i,( 0 )) ) .--> ( f1 . ( Del (pkn,i) ) ) )) and A8: (((not i in ( dom pkn )) or (not ( Del (pkn,i) ) in ( dom f1 ))) implies ( F . ( 0 ) ) = ( {} )) and A9: (for M being (Element of ( NAT )) holds Q[ M,(( F . M ) qua (Element of ( HFuncs ( NAT ) ))),(( F . ( M + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))),pkn,i,f2 ]) by CKB89:def 1;
A10: ( dom p ) = ( dom pkn ) by FUNCT_7:30;
then ( pkn /. i ) = ( pkn . i ) by A1,PARTFUN1:def 6
.= m by A1,FUNCT_7:31;
then A11: (not pk in ( dom ( F . m ) )) by A2,A4,A5,A6;
set pkn1 = ( p +* (i,( ( k + n ) + 1 )) );
consider F1 being (Function of ( NAT ),( HFuncs ( NAT ) )) such that A12: ( primrec (f1,f2,i,pkn1) ) = ( F1 . ( pkn1 /. i ) ) and A13: ((i in ( dom pkn1 ) & ( Del (pkn1,i) ) in ( dom f1 )) implies ( F1 . ( 0 ) ) = ( ( pkn1 +* (i,( 0 )) ) .--> ( f1 . ( Del (pkn1,i) ) ) )) and A14: (((not i in ( dom pkn1 )) or (not ( Del (pkn1,i) ) in ( dom f1 ))) implies ( F1 . ( 0 ) ) = ( {} )) and A15: (for M being (Element of ( NAT )) holds Q[ M,(( F1 . M ) qua (Element of ( HFuncs ( NAT ) ))),(( F1 . ( M + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))),pkn1,i,f2 ]) by CKB89:def 1;
( dom p ) = ( dom pkn1 ) by FUNCT_7:30;
then A16: ( pkn1 /. i ) = ( pkn1 . i ) by A1,PARTFUN1:def 6
.= ( m + 1 ) by A1,FUNCT_7:31;
F1 = F by A7,A8,A9,A13,A14,A15,Lm2;
then A17: ( G . ( p +* (i,( k + ( n + 1 ) )) ) ) = ( F . ( m + 1 ) ) by A2,A12,A16;
per cases ;
suppose ((i in ( dom pkn ) & ( pkn +* (i,m) ) in ( dom ( F . m ) )) & ( ( pkn +* (i,m) ) ^ <* ( ( F . m ) . ( pkn +* (i,m) ) ) *> ) in ( dom f2 ));

then ( F . ( m + 1 ) ) = ( ( F . m ) +* ( ( pkn +* (i,( m + 1 )) ) .--> ( f2 . ( ( pkn +* (i,m) ) ^ <* ( ( F . m ) . ( pkn +* (i,m) ) ) *> ) ) ) ) by A9;
then ( dom ( F . ( m + 1 ) ) ) = ( ( dom ( F . m ) ) \/ ( dom ( { ( pkn +* (i,( m + 1 )) ) } --> ( f2 . ( ( pkn +* (i,m) ) ^ <* ( ( F . m ) . ( pkn +* (i,m) ) ) *> ) ) ) ) ) by FUNCT_4:def 1;
then A18: ( dom ( F . ( m + 1 ) ) ) = ( ( dom ( F . m ) ) \/ { ( pkn +* (i,( m + 1 )) ) } ) by FUNCOP_1:13;
k <= ( k + n ) by NAT_1:11;
then A19: k <> ( m + 1 ) by NAT_1:13;
A20: ( pk . i ) = k by A1,FUNCT_7:31;
( ( pkn +* (i,( m + 1 )) ) . i ) = ( m + 1 ) by A1,A10,FUNCT_7:31;
then (not pk in { ( pkn +* (i,( m + 1 )) ) }) by A19,A20,TARSKI:def 1;
hence thesis by A11,A17,A18,XBOOLE_0:def 3;
end;
suppose (((not i in ( dom pkn )) or (not ( pkn +* (i,m) ) in ( dom ( F . m ) ))) or (not ( ( pkn +* (i,m) ) ^ <* ( ( F . m ) . ( pkn +* (i,m) ) ) *> ) in ( dom f2 )));

hence thesis by A9,A11,A17;
end;
end;
A21: p[ ( 0 ) ];
thus (for n being (Element of ( NAT )) holds p[ n ]) from NAT_1:sch 1(A21,A3);
end;

end;
theorem
Lm6: (i in ( dom p ) implies ((((( p +* (i,( 0 )) ) in ( dom ( primrec (f1,f2,i) ) ) iff ( Del (p,i) ) in ( dom f1 )) & (( p +* (i,( 0 )) ) in ( dom ( primrec (f1,f2,i) ) ) implies ( ( primrec (f1,f2,i) ) . ( p +* (i,( 0 )) ) ) = ( f1 . ( Del (p,i) ) ))) & (( p +* (i,( m + 1 )) ) in ( dom ( primrec (f1,f2,i) ) ) iff (( p +* (i,m) ) in ( dom ( primrec (f1,f2,i) ) ) & ( ( p +* (i,m) ) ^ <* ( ( primrec (f1,f2,i) ) . ( p +* (i,m) ) ) *> ) in ( dom f2 )))) & (( p +* (i,( m + 1 )) ) in ( dom ( primrec (f1,f2,i) ) ) implies ( ( primrec (f1,f2,i) ) . ( p +* (i,( m + 1 )) ) ) = ( f2 . ( ( p +* (i,m) ) ^ <* ( ( primrec (f1,f2,i) ) . ( p +* (i,m) ) ) *> ) ))))
proof
set p0 = ( p +* (i,( 0 )) );
consider G being (Function of ( ( ( arity f1 ) + 1 ) -tuples_on ( NAT ) ),( HFuncs ( NAT ) )) such that A1: ( primrec (f1,f2,i) ) = ( Union G ) and A2: (for p being (Element of ( ( ( arity f1 ) + 1 ) -tuples_on ( NAT ) )) holds ( G . p ) = ( primrec (f1,f2,i,p) )) by CKB96:def 1;
reconsider rngG = ( rng G ) as  functional  compatible set by A1,CKB14:1;
assume A3: i in ( dom p );
A4:now
let k being (Element of ( NAT ));
assume that
A5: ( p +* (i,k) ) in ( dom ( primrec (f1,f2,i) ) )
and
A6: (not ( p +* (i,k) ) in ( dom ( G . ( p +* (i,k) ) ) ));
( union rngG ) <> ( {} ) by A1,A5;
then reconsider rngG = ( rng G ) as non  empty  functional  compatible set;
set pk = ( p +* (i,k) );
( dom ( union rngG ) ) = ( union { ( dom f ) where f is (Element of rngG): (not contradiction) } ) by CKB16:1;
then consider X being set such that A7: pk in X and A8: X in { ( dom f ) where f is (Element of rngG): (not contradiction) } by A1,A5,TARSKI:def 4;
consider f being (Element of rngG) such that A9: X = ( dom f ) and (not contradiction) by A8;
consider pp being set such that A10: pp in ( dom G ) and A11: f = ( G . pp ) by FUNCT_1:def 3;
reconsider pp as (Element of ( ( ( arity f1 ) + 1 ) -tuples_on ( NAT ) )) by A10;
( G . pp ) = ( primrec (f1,f2,i,pp) ) by A2;
then A12: (ex m being (Element of ( NAT )) st pk = ( pp +* (i,m) )) by A7,A9,A11,CKB90:1;
set ppi = ( pp . i );
A13: ( p +* (i,ppi) ) = ( pk +* (i,ppi) ) by FUNCT_7:34
.= ( pp +* (i,ppi) ) by A12,FUNCT_7:34
.= pp by FUNCT_7:35;
per cases  by XXREAL_0:1;
suppose k = ppi;

hence contradiction by A6,A7,A9,A11,A13;
end;
suppose ppi < k;

then consider m being Nat such that A14: k = ( ppi + m ) by NAT_1:10;
reconsider m as (Element of ( NAT )) by ORDINAL1:def 12;
k = ( ppi + m ) by A14;
then ( dom ( G . pp ) ) c= ( dom ( G . pk ) ) by A3,A2,A13,Lm4;
hence contradiction by A6,A7,A9,A11;
end;
suppose ppi > k;

then consider m being Nat such that A15: ppi = ( k + m ) by NAT_1:10;
reconsider m as (Element of ( NAT )) by ORDINAL1:def 12;
ppi = ( k + m ) by A15;
hence contradiction by A3,A2,A6,A7,A9,A11,A13,Lm5;
end;
end;
A16: ( dom p ) = ( dom p0 ) by FUNCT_7:30;
A17:now
A18: p0 in { p0 } by TARSKI:def 1;
A19: ( p0 /. i ) = ( p0 . i ) by A3,A16,PARTFUN1:def 6
.= ( 0 ) by A3,FUNCT_7:31;
consider F being (Function of ( NAT ),( HFuncs ( NAT ) )) such that A20: ( primrec (f1,f2,i,p0) ) = ( F . ( p0 /. i ) ) and A21: ((i in ( dom p0 ) & ( Del (p0,i) ) in ( dom f1 )) implies ( F . ( 0 ) ) = ( ( p0 +* (i,( 0 )) ) .--> ( f1 . ( Del (p0,i) ) ) )) and A22: (((not i in ( dom p0 )) or (not ( Del (p0,i) ) in ( dom f1 ))) implies ( F . ( 0 ) ) = ( {} )) and (for m being (Element of ( NAT )) holds Q[ m,(( F . m ) qua (Element of ( HFuncs ( NAT ) ))),(( F . ( m + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))),p0,i,f2 ]) by CKB89:def 1;
A23: ( G . p0 ) = ( primrec (f1,f2,i,p0) ) by A2;
thus (p0 in ( dom ( G . p0 ) ) iff ( Del (p,i) ) in ( dom f1 ))
proof
thus (p0 in ( dom ( G . p0 ) ) implies ( Del (p,i) ) in ( dom f1 )) by A2,A20,A22,A19,CKB3:1,RELAT_1:38;
assume ( Del (p,i) ) in ( dom f1 );
then ( dom ( F . ( 0 ) ) ) = { ( p0 +* (i,( 0 )) ) } by A3,A21,CKB3:1,FUNCOP_1:13,FUNCT_7:30
.= { p0 } by FUNCT_7:34;
hence thesis by A23,A20,A19,TARSKI:def 1;
end;

assume p0 in ( dom ( G . p0 ) );
then ( F . ( 0 ) ) = ( { p0 } --> ( f1 . ( Del (p0,i) ) ) ) by A2,A20,A21,A22,A19,FUNCT_7:34,RELAT_1:38;
then ( F . ( 0 ) ) = ( { p0 } --> ( f1 . ( Del (p,i) ) ) ) by CKB3:1;
hence ( ( G . p0 ) . p0 ) = ( f1 . ( Del (p,i) ) ) by A23,A20,A19,A18,FUNCOP_1:7;
end;
set pm1 = ( p +* (i,( m + 1 )) );
set pm = ( p +* (i,m) );
set pc = <* ( ( G . pm1 ) . ( pm1 +* (i,m) ) ) *>;
A24: ( dom G ) = ( ( ( arity f1 ) + 1 ) -tuples_on ( NAT ) ) by FUNCT_2:def 1;
then A25: ( G . pm1 ) in ( rng G ) by FUNCT_1:def 3;
reconsider rngG as non  empty  functional  compatible set;
A26: ( G . p0 ) in ( rng G ) by A24,FUNCT_1:def 3;
thus (( p +* (i,( 0 )) ) in ( dom ( primrec (f1,f2,i) ) ) iff ( Del (p,i) ) in ( dom f1 ))
proof
thus (( p +* (i,( 0 )) ) in ( dom ( primrec (f1,f2,i) ) ) implies ( Del (p,i) ) in ( dom f1 )) by A4,A17;
assume A27: ( Del (p,i) ) in ( dom f1 );
( dom ( G . p0 ) ) in { ( dom f ) where f is (Element of rngG): (not contradiction) } by A26;
then p0 in ( union { ( dom f ) where f is (Element of rngG): (not contradiction) } ) by A17,A27,TARSKI:def 4;
hence thesis by A1,CKB16:1;
end;

hereby
assume A28: ( p +* (i,( 0 )) ) in ( dom ( primrec (f1,f2,i) ) );
then p0 in ( dom ( G . p0 ) ) by A4;
then ( ( union rngG ) . p0 ) = ( ( G . p0 ) . p0 ) by A26,CKB17:1;
hence ( ( primrec (f1,f2,i) ) . ( p +* (i,( 0 )) ) ) = ( f1 . ( Del (p,i) ) ) by A1,A4,A17,A28;
end;
A29: ( dom p ) = ( dom pm1 ) by FUNCT_7:30;
A30: ( pm1 +* (i,( m + 1 )) ) = pm1 by FUNCT_7:34;
A31: ( pm1 +* (i,m) ) = pm by FUNCT_7:34;
A32: ( dom p ) = ( dom pm ) by FUNCT_7:30;
A33:now
A34: ( pm /. i ) = ( pm . i ) by A3,A32,PARTFUN1:def 6
.= m by A3,FUNCT_7:31;
consider F being (Function of ( NAT ),( HFuncs ( NAT ) )) such that A35: ( primrec (f1,f2,i,pm) ) = ( F . ( pm /. i ) ) and A36: ((i in ( dom pm ) & ( Del (pm,i) ) in ( dom f1 )) implies ( F . ( 0 ) ) = ( ( pm +* (i,( 0 )) ) .--> ( f1 . ( Del (pm,i) ) ) )) and A37: (((not i in ( dom pm )) or (not ( Del (pm,i) ) in ( dom f1 ))) implies ( F . ( 0 ) ) = ( {} )) and A38: (for M being (Element of ( NAT )) holds Q[ M,(( F . M ) qua (Element of ( HFuncs ( NAT ) ))),(( F . ( M + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))),pm,i,f2 ]) by CKB89:def 1;
A39: ( G . pm1 ) = ( primrec (f1,f2,i,pm1) ) by A2;
consider F1 being (Function of ( NAT ),( HFuncs ( NAT ) )) such that A40: ( primrec (f1,f2,i,pm1) ) = ( F1 . ( pm1 /. i ) ) and A41: ((i in ( dom pm1 ) & ( Del (pm1,i) ) in ( dom f1 )) implies ( F1 . ( 0 ) ) = ( ( pm1 +* (i,( 0 )) ) .--> ( f1 . ( Del (pm1,i) ) ) )) and A42: (((not i in ( dom pm1 )) or (not ( Del (pm1,i) ) in ( dom f1 ))) implies ( F1 . ( 0 ) ) = ( {} )) and A43: (for M being (Element of ( NAT )) holds Q[ M,(( F1 . M ) qua (Element of ( HFuncs ( NAT ) ))),(( F1 . ( M + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))),pm1,i,f2 ]) by CKB89:def 1;
A44: ( ( F1 . ( m + 1 ) ) . pm ) = ( ( F1 . m ) . pm ) by A3,A41,A42,A43,Lm3;
A45: pm1 in { pm1 } by TARSKI:def 1;
then A46: pm1 in ( dom ( { pm1 } --> ( f2 . ( pm ^ <* ( ( F1 . m ) . pm ) *> ) ) ) ) by FUNCOP_1:13;
A47: ( G . pm ) = ( primrec (f1,f2,i,pm) ) by A2;
A48: ( pm1 /. i ) = ( pm1 . i ) by A3,A29,PARTFUN1:def 6
.= ( m + 1 ) by A3,FUNCT_7:31;
A49: ( F1 . m ) = ( F . m ) by A41,A42,A43,A36,A37,A38,Lm2;
A50: (not pm1 in ( dom ( F1 . m ) )) by A3,A41,A42,A43,Lm3;
thus A51: (pm1 in ( dom ( G . pm1 ) ) iff (pm in ( dom ( G . pm ) ) & ( pm ^ pc ) in ( dom f2 )))
proof
hereby
assume A52: pm1 in ( dom ( G . pm1 ) );
then A53: pm1 in ( dom ( F1 . ( m + 1 ) ) ) by A2,A40,A48;
assume A54: (not (pm in ( dom ( G . pm ) ) & ( pm ^ pc ) in ( dom f2 )));
per cases  by A54;
suppose (not pm in ( dom ( G . pm ) ));

then (not pm in ( dom ( F1 . m ) )) by A2,A35,A34,A49;
hence contradiction by A31,A43,A50,A53;
end;
suppose (not ( pm ^ pc ) in ( dom f2 ));

hence contradiction by A31,A39,A40,A43,A48,A44,A50,A52;
end;
end;
assume that
A55: pm in ( dom ( G . pm ) )
and
A56: ( pm ^ pc ) in ( dom f2 );
pm1 in { pm1 } by TARSKI:def 1;
then pm1 in ( dom ( { pm1 } --> ( f2 . ( pm ^ <* ( ( F1 . m ) . pm ) *> ) ) ) ) by FUNCOP_1:13;
then A57: pm1 in ( ( dom ( F1 . m ) ) \/ ( dom ( { pm1 } --> ( f2 . ( pm ^ <* ( ( F1 . m ) . pm ) *> ) ) ) ) ) by XBOOLE_0:def 3;
( F1 . ( m + 1 ) ) = ( ( F1 . m ) +* ( pm1 .--> ( f2 . ( pm ^ <* ( ( F1 . m ) . pm ) *> ) ) ) ) by A3,A29,A31,A30,A39,A47,A40,A43,A35,A48,A34,A49,A44,A55,A56;
hence thesis by A39,A40,A48,A57,FUNCT_4:def 1;
end;

assume A58: pm1 in ( dom ( G . pm1 ) );
then ( pm ^ <* ( ( F1 . m ) . pm ) *> ) in ( dom f2 ) by A31,A39,A40,A43,A48,A51;
then ( F1 . ( m + 1 ) ) = ( ( F1 . m ) +* ( pm1 .--> ( f2 . ( pm ^ <* ( ( F1 . m ) . pm ) *> ) ) ) ) by A3,A29,A31,A30,A47,A43,A35,A34,A49,A51,A58;
hence ( ( G . pm1 ) . pm1 ) = ( ( { pm1 } --> ( f2 . ( pm ^ <* ( ( F1 . m ) . pm ) *> ) ) ) . pm1 ) by A39,A40,A48,A46,FUNCT_4:13
.= ( f2 . ( pm ^ pc ) ) by A31,A39,A40,A48,A44,A45,FUNCOP_1:7;
end;
thus (( p +* (i,( m + 1 )) ) in ( dom ( primrec (f1,f2,i) ) ) iff (( p +* (i,m) ) in ( dom ( primrec (f1,f2,i) ) ) & ( ( p +* (i,m) ) ^ <* ( ( primrec (f1,f2,i) ) . ( p +* (i,m) ) ) *> ) in ( dom f2 )))
proof
hereby
assume A59: ( p +* (i,( m + 1 )) ) in ( dom ( primrec (f1,f2,i) ) );
( G . pm ) in ( rng G ) by A24,FUNCT_1:def 3;
then ( dom ( G . pm ) ) in { ( dom f ) where f is (Element of rngG): (not contradiction) };
then pm in ( union { ( dom f ) where f is (Element of rngG): (not contradiction) } ) by A4,A33,A59,TARSKI:def 4;
hence ( p +* (i,m) ) in ( dom ( primrec (f1,f2,i) ) ) by A1,CKB16:1;
A60: ( G . pm1 ) in ( rng G ) by A24,FUNCT_1:def 3;
( dom ( G . pm ) ) c= ( dom ( G . pm1 ) ) by A3,A2,Lm4;
then ( ( union rngG ) . pm ) = ( ( G . pm1 ) . pm ) by A4,A33,A59,A60,CKB17:1;
hence ( ( p +* (i,m) ) ^ <* ( ( primrec (f1,f2,i) ) . ( p +* (i,m) ) ) *> ) in ( dom f2 ) by A1,A4,A33,A59,FUNCT_7:34;
end;
assume that
A61: ( p +* (i,m) ) in ( dom ( primrec (f1,f2,i) ) )
and
A62: ( ( p +* (i,m) ) ^ <* ( ( primrec (f1,f2,i) ) . ( p +* (i,m) ) ) *> ) in ( dom f2 );
A63: ( G . pm1 ) in ( rng G ) by A24,FUNCT_1:def 3;
( G . pm1 ) in ( rng G ) by A24,FUNCT_1:def 3;
then A64: ( dom ( G . pm1 ) ) in { ( dom f ) where f is (Element of rngG): (not contradiction) };
A65: ( dom ( G . pm ) ) c= ( dom ( G . pm1 ) ) by A3,A2,Lm4;
pm in ( dom ( G . pm ) ) by A4,A61;
then pm1 in ( union { ( dom f ) where f is (Element of rngG): (not contradiction) } ) by A1,A31,A33,A62,A64,A63,A65,CKB17:1,TARSKI:def 4;
hence thesis by A1,CKB16:1;
end;

assume A66: ( p +* (i,( m + 1 )) ) in ( dom ( primrec (f1,f2,i) ) );
A67: ( dom ( G . pm ) ) c= ( dom ( G . pm1 ) ) by A3,A2,Lm4;
then A68: ( ( union rngG ) . pm1 ) = ( ( G . pm1 ) . pm1 ) by A4,A66,A25,CKB17:1;
( ( union rngG ) . pm ) = ( ( G . pm1 ) . pm ) by A4,A33,A66,A25,A67,CKB17:1;
hence thesis by A1,A4,A33,A66,A68,FUNCT_7:34;
end;
