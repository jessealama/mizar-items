environ
vocabularies NUMBERS,SUBSET_1,QC_LANG1,CQC_LANG,FINSEQ_1,PARTFUN1,XBOOLE_0,FUNCT_1,RELAT_1,XXREAL_0,NAT_1,TARSKI,FINSET_1,ZFMISC_1,ZF_LANG,CLASSES2,CARD_1,BVFUNC_2,ORDINAL4,REALSET1,XBOOLEAN,MARGREL1,MCART_1,ARYTM_3,SUBSTUT1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,CARD_1,NUMBERS,FINSEQ_1,NAT_1,QC_LANG1,QC_LANG3,PARTFUN1,SEQ_4,CQC_LANG,FINSET_1,RELSET_1,FUNCT_2,DOMAIN_1,MCART_1,XXREAL_0,CKB1,CKB3,CKB5,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13,CKB14;
definitions TARSKI,FUNCT_1,QC_LANG1,QC_LANG3,CKB1,CKB5,CKB7,CKB8,CKB9,CKB12,CKB13,CKB14;
theorems TARSKI,FINSEQ_1,FUNCT_1,MCART_1,CQC_SIM1,XBOOLE_0,CQC_LANG,QC_LANG1,ZFMISC_1,RELAT_1,XBOOLE_1,CARD_2,CARD_3,FUNCT_2,PARTFUN1,RELSET_1,NAT_1,QC_LANG2,FINSEQ_3,CARD_1,XXREAL_0,ORDINAL1,CKB1,CKB5,CKB6,CKB7,CKB8,CKB9,CKB12,CKB13,CKB14;
schemes FUNCT_1,FUNCT_2,QC_LANG1,QC_LANG3,NAT_1,XBOOLE_0,FRAENKEL,FINSEQ_1,CLASSES1;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,ORDINAL1,RELSET_1,PARTFUN1,FINSET_1,MEMBERED,FINSEQ_1,RFINSEQ,QC_LANG1,CQC_LANG,XXREAL_0,CARD_1,CKB2,CKB4,CKB11;
constructors PARTFUN1,DOMAIN_1,XXREAL_0,NAT_1,SEQ_4,QC_LANG3,CQC_SIM1,RELSET_1,CKB1,CKB5,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13,CKB14;
requirements REAL,NUMERALS,SUBSET,BOOLE;
begin
reserve p for QC-formula;
theorem
Lm1: ((((( Bound_Vars ( VERUM ) ) = ( {} ( bound_QC-variables ) ) & (p is  atomic implies ( Bound_Vars p ) = ( Bound_Vars ( the_arguments_of p ) ))) & (p is  negative implies ( Bound_Vars p ) = ( Bound_Vars ( the_argument_of p ) ))) & (p is  conjunctive implies ( Bound_Vars p ) = ( ( Bound_Vars ( the_left_argument_of p ) ) \/ ( Bound_Vars ( the_right_argument_of p ) ) ))) & (p is  universal implies ( Bound_Vars p ) = ( ( Bound_Vars ( the_scope_of p ) ) \/ { ( bound_in p ) } )))
proof
deffunc A((Element of ( QC-WFF ))) = ( Bound_Vars ( the_arguments_of $1 ) );
deffunc F1((Element of ( QC-WFF ))) = ( Bound_Vars $1 );
set V = ( bound_QC-variables );
deffunc N((Subset of V)) = $1;
deffunc C((Subset of V),(Subset of V)) = ( $1 \/ $2 );
deffunc Q((Element of ( QC-WFF )),(Subset of V)) = ( $2 \/ { ( bound_in $1 ) } );
A1: (for p being QC-formula holds (for X being (Subset of V) holds (X = F1(p) iff (ex F being (Function of ( QC-WFF ),( bool V )) st (X = ( F . p ) & (for p being (Element of ( QC-WFF )) holds (for d1,d2 being (Subset of ( bound_QC-variables )) holds (((((p = ( VERUM ) implies ( F . p ) = ( {} V )) & (p is  atomic implies ( F . p ) = A(p))) & ((p is  negative & d1 = ( F . ( the_argument_of p ) )) implies ( F . p ) = N(d1))) & (((p is  conjunctive & d1 = ( F . ( the_left_argument_of p ) )) & d2 = ( F . ( the_right_argument_of p ) )) implies ( F . p ) = C(d1,d2))) & ((p is  universal & d1 = ( F . ( the_scope_of p ) )) implies ( F . p ) = Q(p,d1)))))))))) by CKB14:def 1;
F1(( VERUM )) = ( {} V ) from QC_LANG3:sch 3(A1)
.= ( {} );
hence ( Bound_Vars ( VERUM ) ) = ( {} ( bound_QC-variables ) );
thus (p is  atomic implies ( Bound_Vars p ) = ( Bound_Vars ( the_arguments_of p ) ))
proof
assume A2: p is  atomic;
thus F1(p) = A(p) from QC_LANG3:sch 4(A1,A2);
end;

thus (p is  negative implies ( Bound_Vars p ) = ( Bound_Vars ( the_argument_of p ) ))
proof
assume A3: p is  negative;
thus F1(p) = N(F1(( the_argument_of p ))) from QC_LANG3:sch 5(A1,A3);
end;

thus (p is  conjunctive implies ( Bound_Vars p ) = ( ( Bound_Vars ( the_left_argument_of p ) ) \/ ( Bound_Vars ( the_right_argument_of p ) ) ))
proof
assume A4: p is  conjunctive;
(for d1,d2 being (Subset of V) holds ((d1 = F1(( the_left_argument_of p )) & d2 = F1(( the_right_argument_of p ))) implies F1(p) = C(d1,d2))) from QC_LANG3:sch 6(A1,A4);
hence thesis;
end;

thus (p is  universal implies ( Bound_Vars p ) = ( ( Bound_Vars ( the_scope_of p ) ) \/ { ( bound_in p ) } ))
proof
assume A5: p is  universal;
thus F1(p) = Q(p,F1(( the_scope_of p ))) from QC_LANG3:sch 7(A1,A5);
end;

end;
