environ
vocabularies NUMBERS,SUBSET_1,QC_LANG1,CQC_LANG,FINSEQ_1,PARTFUN1,XBOOLE_0,FUNCT_1,RELAT_1,XXREAL_0,NAT_1,TARSKI,FINSET_1,ZFMISC_1,ZF_LANG,CLASSES2,CARD_1,BVFUNC_2,ORDINAL4,REALSET1,XBOOLEAN,MARGREL1,MCART_1,ARYTM_3,SUBSTUT1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,CARD_1,NUMBERS,FINSEQ_1,NAT_1,QC_LANG1,QC_LANG3,PARTFUN1,SEQ_4,CQC_LANG,FINSET_1,RELSET_1,FUNCT_2,DOMAIN_1,MCART_1,XXREAL_0,CKB1,CKB3,CKB5,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13;
definitions TARSKI,FUNCT_1,QC_LANG1,QC_LANG3,CKB1,CKB5,CKB7,CKB8,CKB9,CKB12,CKB13;
theorems TARSKI,FINSEQ_1,FUNCT_1,MCART_1,CQC_SIM1,XBOOLE_0,CQC_LANG,QC_LANG1,ZFMISC_1,RELAT_1,XBOOLE_1,CARD_2,CARD_3,FUNCT_2,PARTFUN1,RELSET_1,NAT_1,QC_LANG2,FINSEQ_3,CARD_1,XXREAL_0,ORDINAL1,CKB1,CKB5,CKB6,CKB7,CKB8,CKB9,CKB12,CKB13;
schemes FUNCT_1,FUNCT_2,QC_LANG1,QC_LANG3,NAT_1,XBOOLE_0,FRAENKEL,FINSEQ_1,CLASSES1;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,ORDINAL1,RELSET_1,PARTFUN1,FINSET_1,MEMBERED,FINSEQ_1,RFINSEQ,QC_LANG1,CQC_LANG,XXREAL_0,CARD_1,CKB2,CKB4,CKB11;
constructors PARTFUN1,DOMAIN_1,XXREAL_0,NAT_1,SEQ_4,QC_LANG3,CQC_SIM1,RELSET_1,CKB1,CKB5,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13;
requirements REAL,NUMERALS,SUBSET,BOOLE;
begin
reserve p for QC-formula;
definition
let p;
func Bound_Vars p -> (Subset of ( bound_QC-variables ))
means
:Def8: (ex F being (Function of ( QC-WFF ),( bool ( bound_QC-variables ) )) st (it = ( F . p ) & (for p being (Element of ( QC-WFF )) holds (for d1,d2 being (Subset of ( bound_QC-variables )) holds (((((p = ( VERUM ) implies ( F . p ) = ( {} ( bound_QC-variables ) )) & (p is  atomic implies ( F . p ) = ( Bound_Vars ( the_arguments_of p ) ))) & ((p is  negative & d1 = ( F . ( the_argument_of p ) )) implies ( F . p ) = d1)) & (((p is  conjunctive & d1 = ( F . ( the_left_argument_of p ) )) & d2 = ( F . ( the_right_argument_of p ) )) implies ( F . p ) = ( d1 \/ d2 ))) & ((p is  universal & d1 = ( F . ( the_scope_of p ) )) implies ( F . p ) = ( d1 \/ { ( bound_in p ) } )))))));
correctness
proof
deffunc A((Element of ( QC-WFF ))) = ( Bound_Vars ( the_arguments_of $1 ) );
set V = ( bound_QC-variables );
deffunc N((Subset of V)) = $1;
deffunc C((Subset of V),(Subset of V)) = ( $1 \/ $2 );
deffunc Q((Element of ( QC-WFF )),(Subset of V)) = ( $2 \/ { ( bound_in $1 ) } );
thus ((ex d being (Subset of V) st (ex F being (Function of ( QC-WFF ),( bool V )) st (d = ( F . p ) & (for p being (Element of ( QC-WFF )) holds (for d1,d2 being (Subset of V) holds (((((p = ( VERUM ) implies ( F . p ) = ( {} V )) & (p is  atomic implies ( F . p ) = A(p))) & ((p is  negative & d1 = ( F . ( the_argument_of p ) )) implies ( F . p ) = N(d1))) & (((p is  conjunctive & d1 = ( F . ( the_left_argument_of p ) )) & d2 = ( F . ( the_right_argument_of p ) )) implies ( F . p ) = C(d1,d2))) & ((p is  universal & d1 = ( F . ( the_scope_of p ) )) implies ( F . p ) = Q(p,d1)))))))) & (for x1,x2 being (Subset of V) holds (((ex F being (Function of ( QC-WFF ),( bool V )) st (x1 = ( F . p ) & (for p being (Element of ( QC-WFF )) holds (for d1,d2 being (Subset of V) holds (((((p = ( VERUM ) implies ( F . p ) = ( {} V )) & (p is  atomic implies ( F . p ) = A(p))) & ((p is  negative & d1 = ( F . ( the_argument_of p ) )) implies ( F . p ) = N(d1))) & (((p is  conjunctive & d1 = ( F . ( the_left_argument_of p ) )) & d2 = ( F . ( the_right_argument_of p ) )) implies ( F . p ) = C(d1,d2))) & ((p is  universal & d1 = ( F . ( the_scope_of p ) )) implies ( F . p ) = Q(p,d1))))))) & (ex F being (Function of ( QC-WFF ),( bool V )) st (x2 = ( F . p ) & (for p being (Element of ( QC-WFF )) holds (for d1,d2 being (Subset of V) holds (((((p = ( VERUM ) implies ( F . p ) = ( {} V )) & (p is  atomic implies ( F . p ) = A(p))) & ((p is  negative & d1 = ( F . ( the_argument_of p ) )) implies ( F . p ) = N(d1))) & (((p is  conjunctive & d1 = ( F . ( the_left_argument_of p ) )) & d2 = ( F . ( the_right_argument_of p ) )) implies ( F . p ) = C(d1,d2))) & ((p is  universal & d1 = ( F . ( the_scope_of p ) )) implies ( F . p ) = Q(p,d1)))))))) implies x1 = x2))) from QC_LANG3:sch 2;
end;
end;
