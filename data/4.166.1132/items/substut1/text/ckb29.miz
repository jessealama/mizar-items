environ
vocabularies NUMBERS,SUBSET_1,QC_LANG1,CQC_LANG,FINSEQ_1,PARTFUN1,XBOOLE_0,FUNCT_1,RELAT_1,XXREAL_0,NAT_1,TARSKI,FINSET_1,ZFMISC_1,ZF_LANG,CLASSES2,CARD_1,BVFUNC_2,ORDINAL4,REALSET1,XBOOLEAN,MARGREL1,MCART_1,ARYTM_3,SUBSTUT1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,CARD_1,NUMBERS,FINSEQ_1,NAT_1,QC_LANG1,QC_LANG3,PARTFUN1,SEQ_4,CQC_LANG,FINSET_1,RELSET_1,FUNCT_2,DOMAIN_1,MCART_1,XXREAL_0,CKB1,CKB3,CKB5,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13,CKB14,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28;
definitions TARSKI,FUNCT_1,QC_LANG1,QC_LANG3,CKB1,CKB5,CKB7,CKB8,CKB9,CKB12,CKB13,CKB14,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28;
theorems TARSKI,FINSEQ_1,FUNCT_1,MCART_1,CQC_SIM1,XBOOLE_0,CQC_LANG,QC_LANG1,ZFMISC_1,RELAT_1,XBOOLE_1,CARD_2,CARD_3,FUNCT_2,PARTFUN1,RELSET_1,NAT_1,QC_LANG2,FINSEQ_3,CARD_1,XXREAL_0,ORDINAL1,CKB1,CKB5,CKB6,CKB7,CKB8,CKB9,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28;
schemes FUNCT_1,FUNCT_2,QC_LANG1,QC_LANG3,NAT_1,XBOOLE_0,FRAENKEL,FINSEQ_1,CLASSES1;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,ORDINAL1,RELSET_1,PARTFUN1,FINSET_1,MEMBERED,FINSEQ_1,RFINSEQ,QC_LANG1,CQC_LANG,XXREAL_0,CARD_1,CKB2,CKB4,CKB11,CKB21;
constructors PARTFUN1,DOMAIN_1,XXREAL_0,NAT_1,SEQ_4,QC_LANG3,CQC_SIM1,RELSET_1,CKB1,CKB5,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13,CKB14,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28;
requirements REAL,NUMERALS,SUBSET,BOOLE;
begin
reserve a for set;
reserve b for set;
reserve c for set;
reserve d for set;
reserve k for (Element of ( NAT ));
reserve x for bound_QC-variable;
reserve ll for (CQC-variable_list of k);
reserve p for QC-formula;
reserve e for (Element of ( vSUB ));
theorem
Th7: ((((([: ( QC-WFF ),( vSUB ) :] is (Subset of [: ( [: ( NAT ),( NAT ) :] * ),( vSUB ) :]) & (for k being (Element of ( NAT )) holds (for p being (QC-pred_symbol of k) holds (for ll being (QC-variable_list of k) holds (for e being (Element of ( vSUB )) holds [ ( <* p *> ^ ll ),e ] in [: ( QC-WFF ),( vSUB ) :]))))) & (for e being (Element of ( vSUB )) holds [ <* [ ( 0 ),( 0 ) ] *>,e ] in [: ( QC-WFF ),( vSUB ) :])) & (for p being (FinSequence of [: ( NAT ),( NAT ) :]) holds (for e being (Element of ( vSUB )) holds ([ p,e ] in [: ( QC-WFF ),( vSUB ) :] implies [ ( <* [ 1,( 0 ) ] *> ^ p ),e ] in [: ( QC-WFF ),( vSUB ) :])))) & (for p,q being (FinSequence of [: ( NAT ),( NAT ) :]) holds (for e being (Element of ( vSUB )) holds (([ p,e ] in [: ( QC-WFF ),( vSUB ) :] & [ q,e ] in [: ( QC-WFF ),( vSUB ) :]) implies [ ( ( <* [ 2,( 0 ) ] *> ^ p ) ^ q ),e ] in [: ( QC-WFF ),( vSUB ) :])))) & (for x being bound_QC-variable holds (for p being (FinSequence of [: ( NAT ),( NAT ) :]) holds (for e being (Element of ( vSUB )) holds ([ p,( ( QSub ) . [ ( ( <* [ 3,( 0 ) ] *> ^ <* x *> ) ^ p ),e ] ) ] in [: ( QC-WFF ),( vSUB ) :] implies [ ( ( <* [ 3,( 0 ) ] *> ^ <* x *> ) ^ p ),e ] in [: ( QC-WFF ),( vSUB ) :])))))
proof
( QC-WFF ) is (Subset of ( [: ( NAT ),( NAT ) :] * )) by QC_LANG1:5,QC_LANG1:def 8;
hence [: ( QC-WFF ),( vSUB ) :] is (Subset of [: ( [: ( NAT ),( NAT ) :] * ),( vSUB ) :]) by ZFMISC_1:95;
thus (for k being (Element of ( NAT )) holds (for p being (QC-pred_symbol of k) holds (for ll being (QC-variable_list of k) holds (for e being (Element of ( vSUB )) holds [ ( <* p *> ^ ll ),e ] in [: ( QC-WFF ),( vSUB ) :]))))
proof
let k being (Element of ( NAT ));
let p being (QC-pred_symbol of k);
let ll being (QC-variable_list of k);
let e being (Element of ( vSUB ));
( p ! ll ) = ( <* p *> ^ ll ) by QC_LANG1:6;
hence thesis by ZFMISC_1:def 2;
end;

thus (for e being (Element of ( vSUB )) holds [ <* [ ( 0 ),( 0 ) ] *>,e ] in [: ( QC-WFF ),( vSUB ) :]) by QC_LANG1:def 12,ZFMISC_1:def 2;
thus (for p being (FinSequence of [: ( NAT ),( NAT ) :]) holds (for e being (Element of ( vSUB )) holds ([ p,e ] in [: ( QC-WFF ),( vSUB ) :] implies [ ( <* [ 1,( 0 ) ] *> ^ p ),e ] in [: ( QC-WFF ),( vSUB ) :])))
proof
let p being (FinSequence of [: ( NAT ),( NAT ) :]);
let e being (Element of ( vSUB ));
assume [ p,e ] in [: ( QC-WFF ),( vSUB ) :];
then (ex a st (ex b st ((a in ( QC-WFF ) & b in ( vSUB )) & [ p,e ] = [ a,b ]))) by ZFMISC_1:def 2;
then reconsider p9 = p as (Element of ( QC-WFF )) by ZFMISC_1:27;
( 'not' p9 ) = ( <* [ 1,( 0 ) ] *> ^ ( @ p9 ) );
hence thesis by ZFMISC_1:def 2;
end;

thus (for p,q being (FinSequence of [: ( NAT ),( NAT ) :]) holds (for e being (Element of ( vSUB )) holds (([ p,e ] in [: ( QC-WFF ),( vSUB ) :] & [ q,e ] in [: ( QC-WFF ),( vSUB ) :]) implies [ ( ( <* [ 2,( 0 ) ] *> ^ p ) ^ q ),e ] in [: ( QC-WFF ),( vSUB ) :])))
proof
let p being (FinSequence of [: ( NAT ),( NAT ) :]);
let q being (FinSequence of [: ( NAT ),( NAT ) :]);
let e being (Element of ( vSUB ));
assume that
A1: [ p,e ] in [: ( QC-WFF ),( vSUB ) :]
and
A2: [ q,e ] in [: ( QC-WFF ),( vSUB ) :];
(ex c st (ex d st ((c in ( QC-WFF ) & d in ( vSUB )) & [ q,e ] = [ c,d ]))) by A2,ZFMISC_1:def 2;
then reconsider q9 = q as (Element of ( QC-WFF )) by ZFMISC_1:27;
(ex a st (ex b st ((a in ( QC-WFF ) & b in ( vSUB )) & [ p,e ] = [ a,b ]))) by A1,ZFMISC_1:def 2;
then reconsider p9 = p as (Element of ( QC-WFF )) by ZFMISC_1:27;
( p9 '&' q9 ) = ( ( <* [ 2,( 0 ) ] *> ^ ( @ p9 ) ) ^ ( @ q9 ) );
hence thesis by ZFMISC_1:def 2;
end;

thus (for x being bound_QC-variable holds (for p being (FinSequence of [: ( NAT ),( NAT ) :]) holds (for e being (Element of ( vSUB )) holds ([ p,( ( QSub ) . [ ( ( <* [ 3,( 0 ) ] *> ^ <* x *> ) ^ p ),e ] ) ] in [: ( QC-WFF ),( vSUB ) :] implies [ ( ( <* [ 3,( 0 ) ] *> ^ <* x *> ) ^ p ),e ] in [: ( QC-WFF ),( vSUB ) :]))))
proof
let x being bound_QC-variable;
let p being (FinSequence of [: ( NAT ),( NAT ) :]);
let e being (Element of ( vSUB ));
assume [ p,( ( QSub ) . [ ( ( <* [ 3,( 0 ) ] *> ^ <* x *> ) ^ p ),e ] ) ] in [: ( QC-WFF ),( vSUB ) :];
then (ex a st (ex b st ((a in ( QC-WFF ) & b in ( vSUB )) & [ p,( ( QSub ) . [ ( ( <* [ 3,( 0 ) ] *> ^ <* x *> ) ^ p ),e ] ) ] = [ a,b ]))) by ZFMISC_1:def 2;
then reconsider p9 = p as (Element of ( QC-WFF )) by ZFMISC_1:27;
( All (x,p9) ) = ( ( <* [ 3,( 0 ) ] *> ^ <* x *> ) ^ ( @ p9 ) );
hence thesis by ZFMISC_1:def 2;
end;

end;
