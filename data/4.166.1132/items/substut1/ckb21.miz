environ
vocabularies NUMBERS,SUBSET_1,QC_LANG1,CQC_LANG,FINSEQ_1,PARTFUN1,XBOOLE_0,FUNCT_1,RELAT_1,XXREAL_0,NAT_1,TARSKI,FINSET_1,ZFMISC_1,ZF_LANG,CLASSES2,CARD_1,BVFUNC_2,ORDINAL4,REALSET1,XBOOLEAN,MARGREL1,MCART_1,ARYTM_3,SUBSTUT1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,CARD_1,NUMBERS,FINSEQ_1,NAT_1,QC_LANG1,QC_LANG3,PARTFUN1,SEQ_4,CQC_LANG,FINSET_1,RELSET_1,FUNCT_2,DOMAIN_1,MCART_1,XXREAL_0,CKB1,CKB3,CKB5,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13,CKB14;
definitions TARSKI,FUNCT_1,QC_LANG1,QC_LANG3,CKB1,CKB5,CKB7,CKB8,CKB9,CKB12,CKB13,CKB14;
theorems TARSKI,FINSEQ_1,FUNCT_1,MCART_1,CQC_SIM1,XBOOLE_0,CQC_LANG,QC_LANG1,ZFMISC_1,RELAT_1,XBOOLE_1,CARD_2,CARD_3,FUNCT_2,PARTFUN1,RELSET_1,NAT_1,QC_LANG2,FINSEQ_3,CARD_1,XXREAL_0,ORDINAL1,CKB1,CKB5,CKB6,CKB7,CKB8,CKB9,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
schemes FUNCT_1,FUNCT_2,QC_LANG1,QC_LANG3,NAT_1,XBOOLE_0,FRAENKEL,FINSEQ_1,CLASSES1;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,ORDINAL1,RELSET_1,PARTFUN1,FINSET_1,MEMBERED,FINSEQ_1,RFINSEQ,QC_LANG1,CQC_LANG,XXREAL_0,CARD_1,CKB2,CKB4,CKB11;
constructors PARTFUN1,DOMAIN_1,XXREAL_0,NAT_1,SEQ_4,QC_LANG3,CQC_SIM1,RELSET_1,CKB1,CKB5,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13,CKB14;
requirements REAL,NUMERALS,SUBSET,BOOLE;
begin
reserve k for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
reserve p for QC-formula;
registration
let p;
cluster ( Bound_Vars p ) ->  finite;
coherence
proof
defpred P[ (Element of ( QC-WFF )) ]
 means
( Bound_Vars $1 ) is  finite;
A1: (for p being (Element of ( QC-WFF )) holds (((((p is  atomic implies P[ p ]) & P[ ( VERUM ) ]) & ((p is  negative & P[ ( the_argument_of p ) ]) implies P[ p ])) & (((p is  conjunctive & P[ ( the_left_argument_of p ) ]) & P[ ( the_right_argument_of p ) ]) implies P[ p ])) & ((p is  universal & P[ ( the_scope_of p ) ]) implies P[ p ])))
proof
let p being (Element of ( QC-WFF ));
thus (p is  atomic implies ( Bound_Vars p ) is  finite)
proof
deffunc F(set) = ( ( the_arguments_of p ) . $1 );
defpred B[ (Element of ( NAT )) ]
 means
(1 <= $1 & $1 <= ( len ( the_arguments_of p ) ));
defpred A[ (Element of ( NAT )) ]
 means
((1 <= $1 & $1 <= ( len ( the_arguments_of p ) )) & ( ( the_arguments_of p ) . $1 ) in ( bound_QC-variables ));
A2: (for k holds (A[ k ] implies B[ k ]));
A3: { F(k): A[ k ] } c= { F(n): B[ n ] } from FRAENKEL:sch 1(A2);
assume p is  atomic;
then ( Bound_Vars p ) = ( Bound_Vars ( the_arguments_of p ) ) by CKB15:1
.= { ( ( the_arguments_of p ) . k ): ((1 <= k & k <= ( len ( the_arguments_of p ) )) & ( ( the_arguments_of p ) . k ) in ( bound_QC-variables )) };
then ( Bound_Vars p ) c= ( rng ( the_arguments_of p ) ) by A3,CQC_SIM1:9;
hence thesis;
end;

thus ( Bound_Vars ( VERUM ) ) is  finite by CKB15:1;
thus ((p is  negative & ( Bound_Vars ( the_argument_of p ) ) is  finite) implies ( Bound_Vars p ) is  finite) by CKB15:1;
thus (((p is  conjunctive & ( Bound_Vars ( the_left_argument_of p ) ) is  finite) & ( Bound_Vars ( the_right_argument_of p ) ) is  finite) implies ( Bound_Vars p ) is  finite)
proof
assume that
A4: p is  conjunctive
and
A5: (( Bound_Vars ( the_left_argument_of p ) ) is  finite & ( Bound_Vars ( the_right_argument_of p ) ) is  finite);
( Bound_Vars p ) = ( ( Bound_Vars ( the_left_argument_of p ) ) \/ ( Bound_Vars ( the_right_argument_of p ) ) ) by A4,CKB15:1;
hence thesis by A5;
end;

assume that
A6: p is  universal
and
A7: ( Bound_Vars ( the_scope_of p ) ) is  finite;
( Bound_Vars p ) = ( ( Bound_Vars ( the_scope_of p ) ) \/ { ( bound_in p ) } ) by A6,CKB15:1;
hence thesis by A7;
end;
(for p being (Element of ( QC-WFF )) holds P[ p ]) from QC_LANG1:sch 2(A1);
hence thesis;
end;
end;
