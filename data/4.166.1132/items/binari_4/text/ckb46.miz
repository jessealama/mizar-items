environ
vocabularies NUMBERS,XBOOLE_0,NAT_1,INT_1,XXREAL_0,CARD_1,RELAT_1,ARYTM_3,POWER,EUCLID,FINSEQ_1,BINOP_2,ZFMISC_1,TARSKI,FUNCT_1,FINSEQ_2,MARGREL1,BINARITH,ARYTM_1,SUBSET_1,PARTFUN1,XBOOLEAN,BINARI_2,BINARI_3,FUNCOP_1,ORDINAL4,COMPLEX1,NEWTON,BINARI_4;
notations INT_1,SUBSET_1,XBOOLEAN,MARGREL1,FUNCOP_1,POWER,BINARITH,BINARI_2,BINARI_3,SERIES_1,NUMBERS,XXREAL_0,XBOOLE_0,NAT_1,NAT_D,BINOP_2,EUCLID,TARSKI,PARTFUN1,FUNCT_1,RELAT_1,ZFMISC_1,INT_2,FINSEQOP,NEWTON,FINSEQ_1,FINSEQ_2,CKB21,CKB27;
definitions FINSEQ_2,XBOOLEAN,EUCLID,CKB21,CKB27;
theorems POWER,NAT_1,PRE_FF,ABSVALUE,BINARI_3,INT_1,BINARITH,NAT_2,BINARI_2,FINSEQ_1,FINSEQ_2,FINSEQ_4,FUNCOP_1,RVSUM_1,FUNCT_2,ZFMISC_1,INT_3,EULER_2,PEPIN,PREPOWER,XREAL_1,XXREAL_0,XBOOLEAN,NAT_D,VALUED_1,XREAL_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45;
schemes NAT_1;
registrations XBOOLE_0,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,XBOOLEAN,MARGREL1,VALUED_0,FINSEQ_1,FINSEQ_2,RELAT_1,FUNCT_1,CARD_1;
constructors XXREAL_0,REAL_1,NAT_D,FINSEQOP,NEWTON,SERIES_1,BINARITH,BINARI_2,EUCLID,BINARI_3,RVSUM_1,RELSET_1,CKB21,CKB27;
requirements REAL,BOOLE,SUBSET,NUMERALS,ARITHM;
begin
reserve h for Integer;
reserve i for Integer;
theorem
(for n being non empty Nat holds (((((((( - ( 2 to_power ( n -' 1 ) ) ) <= h & h <= ( ( 2 to_power ( n -' 1 ) ) - 1 )) & ( - ( 2 to_power ( n -' 1 ) ) ) <= i) & i <= ( ( 2 to_power ( n -' 1 ) ) - 1 )) & ( - ( 2 to_power ( n -' 1 ) ) ) <= ( h + i )) & ( h + i ) <= ( ( 2 to_power ( n -' 1 ) ) - 1 )) & ((h >= ( 0 ) & i < ( 0 )) or (h < ( 0 ) & i >= ( 0 )))) implies ( Intval ( ( 2sComplement (n,h) ) + ( 2sComplement (n,i) ) ) ) = ( h + i )))
proof
defpred P[ non empty Nat ]
 means
(((((((( - ( 2 to_power ( $1 -' 1 ) ) ) <= h & h <= ( ( 2 to_power ( $1 -' 1 ) ) - 1 )) & ( - ( 2 to_power ( $1 -' 1 ) ) ) <= i) & i <= ( ( 2 to_power ( $1 -' 1 ) ) - 1 )) & ( - ( 2 to_power ( $1 -' 1 ) ) ) <= ( h + i )) & ( h + i ) <= ( ( 2 to_power ( $1 -' 1 ) ) - 1 )) & ((h >= ( 0 ) & i < ( 0 )) or (h < ( 0 ) & i >= ( 0 )))) implies ( Intval ( ( 2sComplement ($1,h) ) + ( 2sComplement ($1,i) ) ) ) = ( h + i ));
A1: (for n being non empty Nat holds (P[ n ] implies P[ ( n + 1 ) ]))
proof
let n being non empty Nat;
assume that
(((((((( - ( 2 to_power ( n -' 1 ) ) ) <= h & h <= ( ( 2 to_power ( n -' 1 ) ) - 1 )) & ( - ( 2 to_power ( n -' 1 ) ) ) <= i) & i <= ( ( 2 to_power ( n -' 1 ) ) - 1 )) & ( - ( 2 to_power ( n -' 1 ) ) ) <= ( h + i )) & ( h + i ) <= ( ( 2 to_power ( n -' 1 ) ) - 1 )) & ((h >= ( 0 ) & i < ( 0 )) or (h < ( 0 ) & i >= ( 0 )))) implies ( Intval ( ( 2sComplement (n,h) ) + ( 2sComplement (n,i) ) ) ) = ( h + i ));
assume that
A2: ( - ( 2 to_power ( ( n + 1 ) -' 1 ) ) ) <= h
and
A3: h <= ( ( 2 to_power ( ( n + 1 ) -' 1 ) ) - 1 )
and
A4: ( - ( 2 to_power ( ( n + 1 ) -' 1 ) ) ) <= i
and
A5: i <= ( ( 2 to_power ( ( n + 1 ) -' 1 ) ) - 1 )
and
( - ( 2 to_power ( ( n + 1 ) -' 1 ) ) ) <= ( h + i )
and
( h + i ) <= ( ( 2 to_power ( ( n + 1 ) -' 1 ) ) - 1 )
and
A6: ((h >= ( 0 ) & i < ( 0 )) or (h < ( 0 ) & i >= ( 0 )));
set H = ( 2sComplement (n,h) );
set I = ( 2sComplement (n,i) );
set H1 = ( 2sComplement (( n + 1 ),h) );
set I1 = ( 2sComplement (( n + 1 ),i) );
set n2 = ( 2 to_power n );
set F = ( FALSE );
set T = ( TRUE );
A7: ( ( n + 1 ) - 1 ) = n;
then A8: ( - n2 ) <= h by A2,XREAL_0:def 2;
A9: i <= ( n2 - 1 ) by A5,A7,XREAL_0:def 2;
A10: ((ex a being (Element of ( BOOLEAN )) st H1 = ( H ^ <* a *> )) & (ex b being (Element of ( BOOLEAN )) st I1 = ( I ^ <* b *> ))) by CKB41:1;
A11: ( - n2 ) <= i by A4,A7,XREAL_0:def 2;
A12: h <= ( n2 - 1 ) by A3,A7,XREAL_0:def 2;
now
per cases  by A6;
suppose A13: (h >= ( 0 ) & i < ( 0 ));

( ( 2 to_power ( n + 1 ) ) + ( - ( 2 to_power n ) ) ) = ( ( - ( 2 to_power n ) ) + ( ( 2 to_power 1 ) * ( 2 to_power n ) ) ) by POWER:27
.= ( ( - ( 2 to_power n ) ) + ( 2 * ( 2 to_power n ) ) ) by POWER:25
.= ( 2 to_power n );
then A14: ( 2 to_power n ) <= ( ( 2 to_power ( n + 1 ) ) + i ) by A11,XREAL_1:6;
then reconsider NI = ( ( 2 to_power ( n + 1 ) ) + i ) as (Element of ( NAT )) by INT_1:3;
n < ( n + 1 ) by XREAL_1:29;
then A15: ( 2 to_power n ) < ( 2 to_power ( n + 1 ) ) by POWER:39;
( abs i ) = ( - i ) by A13,ABSVALUE:def 1;
then ( abs i ) <= ( - ( - ( 2 to_power n ) ) ) by A11,XREAL_1:24;
then A16: ( MajP (( n + 1 ),( abs i )) ) = ( n + 1 ) by A15,CKB25:1,XXREAL_0:2;
then A17: I1 = ( ( n + 1 ) -BinarySequence ( abs ( ( 2 to_power ( n + 1 ) ) + i ) ) ) by A13,CKB27:def 1
.= ( ( n + 1 ) -BinarySequence NI ) by ABSVALUE:def 1;
A18: ( ( 2 to_power ( n + 1 ) ) + i ) < ( ( 2 to_power ( n + 1 ) ) + ( 0 ) ) by A13,XREAL_1:8;
reconsider h as (Element of ( NAT )) by A13,INT_1:3;
A19: h < ( 2 to_power n ) by A12,XREAL_1:146,XXREAL_0:2;
A20: H1 = ( ( n + 1 ) -BinarySequence ( abs h ) ) by CKB27:def 1
.= ( ( n + 1 ) -BinarySequence h ) by ABSVALUE:def 1;
then A21: ( H1 . ( n + 1 ) ) = F by A19,BINARI_3:26;
( n + ( 0 ) ) < ( n + 1 ) by XREAL_1:8;
then ( 2 to_power n ) < ( 2 to_power ( n + 1 ) ) by POWER:39;
then A22: h < ( 2 to_power ( n + 1 ) ) by A19,XXREAL_0:2;
A23: 1 <= ( n + 1 ) by NAT_1:11;
( len I1 ) = ( n + 1 ) by CARD_1:def 7;
then A24: ( I1 /. ( n + 1 ) ) = ( I1 . ( n + 1 ) ) by A23,FINSEQ_4:15;
A25: ( I1 . ( n + 1 ) ) = ( ( ( n + 1 ) -BinarySequence ( abs ( ( 2 to_power ( n + 1 ) ) + i ) ) ) . ( n + 1 ) ) by A13,A16,CKB27:def 1
.= ( ( ( n + 1 ) -BinarySequence NI ) . ( n + 1 ) ) by ABSVALUE:def 1
.= T by A18,A14,BINARI_3:29;
then A26: ( Intval I1 ) = ( ( Absval I1 ) - ( 2 to_power ( n + 1 ) ) ) by A24,BINARI_2:def 3
.= ( NI - ( 2 to_power ( n + 1 ) ) ) by A18,A17,BINARI_3:35
.= i;
( len H1 ) = ( n + 1 ) by CARD_1:def 7;
then A27: ( H1 /. ( n + 1 ) ) = ( H1 . ( n + 1 ) ) by A23,FINSEQ_4:15;
then A28: ( Int_add_ovfl (H1,I1) ) = ( ( ( 'not' F ) '&' ( 'not' T ) ) '&' ( ( carry (H1,I1) ) /. ( n + 1 ) ) ) by A21,A25,A24,BINARI_2:def 4
.= F;
A29: ( Int_add_udfl (H1,I1) ) = ( ( F '&' T ) '&' ( 'not' ( ( carry (H1,I1) ) /. ( n + 1 ) ) ) ) by A21,A25,A27,A24,BINARI_2:def 5
.= F;
( Intval H1 ) = ( Absval H1 ) by A21,A27,BINARI_2:def 3
.= h by A20,A22,BINARI_3:35;
then ( Intval ( H1 + I1 ) ) = ( ( ( h + i ) - ( IFEQ (F,F,( 0 ),( 2 to_power ( n + 1 ) )) ) ) + ( IFEQ (F,F,( 0 ),( 2 to_power ( n + 1 ) )) ) ) by A10,A26,A28,A29,BINARI_2:12
.= ( ( ( h + i ) - ( 0 ) ) + ( 0 ) );
hence thesis;
end;
suppose A30: (h < ( 0 ) & i >= ( 0 ));

( ( 2 to_power ( n + 1 ) ) + ( - ( 2 to_power n ) ) ) = ( ( - ( 2 to_power n ) ) + ( ( 2 to_power 1 ) * ( 2 to_power n ) ) ) by POWER:27
.= ( ( - ( 2 to_power n ) ) + ( 2 * ( 2 to_power n ) ) ) by POWER:25
.= ( 2 to_power n );
then A31: ( 2 to_power n ) <= ( ( 2 to_power ( n + 1 ) ) + h ) by A8,XREAL_1:6;
then reconsider NH = ( ( 2 to_power ( n + 1 ) ) + h ) as (Element of ( NAT )) by INT_1:3;
n < ( n + 1 ) by XREAL_1:29;
then A32: ( 2 to_power n ) < ( 2 to_power ( n + 1 ) ) by POWER:39;
( abs h ) = ( - h ) by A30,ABSVALUE:def 1;
then ( abs h ) <= ( - ( - ( 2 to_power n ) ) ) by A8,XREAL_1:24;
then A33: ( MajP (( n + 1 ),( abs h )) ) = ( n + 1 ) by A32,CKB25:1,XXREAL_0:2;
then A34: H1 = ( ( n + 1 ) -BinarySequence ( abs ( ( 2 to_power ( n + 1 ) ) + h ) ) ) by A30,CKB27:def 1
.= ( ( n + 1 ) -BinarySequence NH ) by ABSVALUE:def 1;
A35: ( ( 2 to_power ( n + 1 ) ) + h ) < ( ( 2 to_power ( n + 1 ) ) + ( 0 ) ) by A30,XREAL_1:8;
reconsider i as (Element of ( NAT )) by A30,INT_1:3;
A36: i < ( 2 to_power n ) by A9,XREAL_1:146,XXREAL_0:2;
A37: I1 = ( ( n + 1 ) -BinarySequence ( abs i ) ) by CKB27:def 1
.= ( ( n + 1 ) -BinarySequence i ) by ABSVALUE:def 1;
then A38: ( I1 . ( n + 1 ) ) = F by A36,BINARI_3:26;
( n + ( 0 ) ) < ( n + 1 ) by XREAL_1:8;
then ( 2 to_power n ) < ( 2 to_power ( n + 1 ) ) by POWER:39;
then A39: i < ( 2 to_power ( n + 1 ) ) by A36,XXREAL_0:2;
A40: 1 <= ( n + 1 ) by NAT_1:11;
( len H1 ) = ( n + 1 ) by CARD_1:def 7;
then A41: ( H1 /. ( n + 1 ) ) = ( H1 . ( n + 1 ) ) by A40,FINSEQ_4:15;
A42: ( H1 . ( n + 1 ) ) = ( ( ( n + 1 ) -BinarySequence ( abs ( ( 2 to_power ( n + 1 ) ) + h ) ) ) . ( n + 1 ) ) by A30,A33,CKB27:def 1
.= ( ( ( n + 1 ) -BinarySequence NH ) . ( n + 1 ) ) by ABSVALUE:def 1
.= T by A35,A31,BINARI_3:29;
then A43: ( Intval H1 ) = ( ( Absval H1 ) - ( 2 to_power ( n + 1 ) ) ) by A41,BINARI_2:def 3
.= ( NH - ( 2 to_power ( n + 1 ) ) ) by A35,A34,BINARI_3:35
.= h;
( len I1 ) = ( n + 1 ) by CARD_1:def 7;
then A44: ( I1 /. ( n + 1 ) ) = ( I1 . ( n + 1 ) ) by A40,FINSEQ_4:15;
then A45: ( Int_add_ovfl (H1,I1) ) = ( ( ( 'not' T ) '&' ( 'not' F ) ) '&' ( ( carry (H1,I1) ) /. ( n + 1 ) ) ) by A38,A42,A41,BINARI_2:def 4
.= F;
A46: ( Int_add_udfl (H1,I1) ) = ( ( T '&' F ) '&' ( 'not' ( ( carry (H1,I1) ) /. ( n + 1 ) ) ) ) by A38,A42,A44,A41,BINARI_2:def 5
.= F;
( Intval I1 ) = ( Absval I1 ) by A38,A44,BINARI_2:def 3
.= i by A37,A39,BINARI_3:35;
then ( Intval ( H1 + I1 ) ) = ( ( ( h + i ) - ( IFEQ (F,F,( 0 ),( 2 to_power ( n + 1 ) )) ) ) + ( IFEQ (F,F,( 0 ),( 2 to_power ( n + 1 ) )) ) ) by A10,A43,A45,A46,BINARI_2:12
.= ( ( ( h + i ) - ( 0 ) ) + ( 0 ) );
hence thesis;
end;
end;
hence thesis;
end;
A47: P[ 1 ]
proof
A48: ( abs ( - 1 ) ) = ( - ( - 1 ) ) by ABSVALUE:def 1
.= 1;
(( 2 to_power 1 ) = 2 & (for k being Nat holds ((( 2 to_power k ) >= 1 & k >= 1) implies k >= 1))) by POWER:25;
then ( MajP (1,( abs ( - 1 ) )) ) = 1 by A48,CKB21:def 1;
then A49: ( 2sComplement (1,( - 1 )) ) = ( 1 -BinarySequence ( abs ( ( 2 to_power 1 ) + ( - 1 ) ) ) ) by CKB27:def 1
.= ( 1 -BinarySequence ( abs ( 2 + ( - 1 ) ) ) ) by POWER:25
.= ( 1 -BinarySequence 1 ) by ABSVALUE:def 1
.= ( ( ( 0 ) + 1 ) -BinarySequence ( 2 to_power ( 0 ) ) ) by POWER:24
.= ( ( 0* ( 0 ) ) ^ <* 1 *> ) by BINARI_3:28
.= <* ( TRUE ) *> by FINSEQ_1:34;
assume that
A50: ( - ( 2 to_power ( 1 -' 1 ) ) ) <= h
and
A51: h <= ( ( 2 to_power ( 1 -' 1 ) ) - 1 )
and
A52: ( - ( 2 to_power ( 1 -' 1 ) ) ) <= i
and
A53: i <= ( ( 2 to_power ( 1 -' 1 ) ) - 1 )
and
( - ( 2 to_power ( 1 -' 1 ) ) ) <= ( h + i )
and
( h + i ) <= ( ( 2 to_power ( 1 -' 1 ) ) - 1 )
and
A54: ((h >= ( 0 ) & i < ( 0 )) or (h < ( 0 ) & i >= ( 0 )));
A55: ( 1 -' 1 ) = ( 1 - 1 ) by XREAL_0:def 2
.= ( 0 );
then A56: h <= ( 1 - 1 ) by A51,POWER:24;
A57: i <= ( 1 - 1 ) by A53,A55,POWER:24;
A58: ( - 1 ) <= i by A52,A55,POWER:24;
A59: ( 2sComplement (1,( 0 )) ) = ( 1 -BinarySequence ( abs ( 0 ) ) ) by CKB27:def 1
.= ( 1 -BinarySequence ( 0 ) ) by ABSVALUE:def 1
.= ( 0* 1 ) by BINARI_3:25
.= <* ( FALSE ) *> by FINSEQ_2:59;
A60: ( - 1 ) <= h by A50,A55,POWER:24;
now
per cases  by A54;
suppose A61: (h >= ( 0 ) & i < ( 0 ));

then i <= ( - 1 ) by INT_1:8;
then A62: i = ( - 1 ) by A58,XXREAL_0:1;
h = ( 0 ) by A56,A61;
hence thesis by A59,A49,A62,CKB15:1,BINARI_3:17;
end;
suppose A63: (h < ( 0 ) & i >= ( 0 ));

then h <= ( - 1 ) by INT_1:8;
then A64: h = ( - 1 ) by A60,XXREAL_0:1;
i = ( 0 ) by A57,A63;
hence thesis by A59,A49,A64,CKB15:1,BINARI_3:17;
end;
end;
hence thesis;
end;
thus (for n being non empty Nat holds P[ n ]) from NAT_1:sch 10(A47,A1);
end;
