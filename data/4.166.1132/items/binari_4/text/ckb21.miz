environ
vocabularies NUMBERS,XBOOLE_0,NAT_1,INT_1,XXREAL_0,CARD_1,RELAT_1,ARYTM_3,POWER,EUCLID,FINSEQ_1,BINOP_2,ZFMISC_1,TARSKI,FUNCT_1,FINSEQ_2,MARGREL1,BINARITH,ARYTM_1,SUBSET_1,PARTFUN1,XBOOLEAN,BINARI_2,BINARI_3,FUNCOP_1,ORDINAL4,COMPLEX1,NEWTON,BINARI_4;
notations INT_1,SUBSET_1,XBOOLEAN,MARGREL1,FUNCOP_1,POWER,BINARITH,BINARI_2,BINARI_3,SERIES_1,NUMBERS,XXREAL_0,XBOOLE_0,NAT_1,NAT_D,BINOP_2,EUCLID,TARSKI,PARTFUN1,FUNCT_1,RELAT_1,ZFMISC_1,INT_2,FINSEQOP,NEWTON,FINSEQ_1,FINSEQ_2;
definitions FINSEQ_2,XBOOLEAN,EUCLID;
theorems POWER,NAT_1,PRE_FF,ABSVALUE,BINARI_3,INT_1,BINARITH,NAT_2,BINARI_2,FINSEQ_1,FINSEQ_2,FINSEQ_4,FUNCOP_1,RVSUM_1,FUNCT_2,ZFMISC_1,INT_3,EULER_2,PEPIN,PREPOWER,XREAL_1,XXREAL_0,XBOOLEAN,NAT_D,VALUED_1,XREAL_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
schemes NAT_1;
registrations XBOOLE_0,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,XBOOLEAN,MARGREL1,VALUED_0,FINSEQ_1,FINSEQ_2,RELAT_1,FUNCT_1,CARD_1;
constructors XXREAL_0,REAL_1,NAT_D,FINSEQOP,NEWTON,SERIES_1,BINARITH,BINARI_2,EUCLID,BINARI_3,RVSUM_1,RELSET_1;
requirements REAL,BOOLE,SUBSET,NUMERALS,ARITHM;
begin
reserve j for Nat;
reserve m for Nat;
definition
let m being Nat;
let j being Nat;
func MajP (m,j) -> Nat means 
:Def1: ((( 2 to_power it ) >= j & it >= m) & (for k being Nat holds ((( 2 to_power k ) >= j & k >= m) implies k >= it)));
existence
proof
per cases ;
suppose A1: ( 2 to_power m ) >= j;

(for k being Nat holds ((( 2 to_power k ) >= j & k >= m) implies k >= m));
hence thesis by A1;
end;
suppose A2: ( 2 to_power m ) < j;

defpred P[ Nat ]
 means
(( 2 to_power $1 ) >= j & $1 >= m);
( 2 to_power m ) >= m by CKB2:1;
then A3: j >= m by A2,XXREAL_0:2;
( 2 to_power j ) >= j by CKB2:1;
then A4: (ex k being Nat st P[ k ]) by A3;
(ex k being Nat st (P[ k ] & (for l being Nat holds (P[ l ] implies l >= k)))) from NAT_1:sch 5(A4);
hence thesis;
end;
end;
uniqueness
proof
let p being Nat;
let q being Nat;
assume ((((( 2 to_power p ) >= j & p >= m) & (for k being Nat holds ((( 2 to_power k ) >= j & k >= m) implies k >= p))) & ( 2 to_power q ) >= j) & (q >= m & (for k being Nat holds ((( 2 to_power k ) >= j & k >= m) implies k >= q))));
then (p >= q & q >= p);
hence thesis by XXREAL_0:1;
end;
end;
