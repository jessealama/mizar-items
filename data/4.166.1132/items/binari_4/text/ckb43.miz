environ
vocabularies NUMBERS,XBOOLE_0,NAT_1,INT_1,XXREAL_0,CARD_1,RELAT_1,ARYTM_3,POWER,EUCLID,FINSEQ_1,BINOP_2,ZFMISC_1,TARSKI,FUNCT_1,FINSEQ_2,MARGREL1,BINARITH,ARYTM_1,SUBSET_1,PARTFUN1,XBOOLEAN,BINARI_2,BINARI_3,FUNCOP_1,ORDINAL4,COMPLEX1,NEWTON,BINARI_4;
notations INT_1,SUBSET_1,XBOOLEAN,MARGREL1,FUNCOP_1,POWER,BINARITH,BINARI_2,BINARI_3,SERIES_1,NUMBERS,XXREAL_0,XBOOLE_0,NAT_1,NAT_D,BINOP_2,EUCLID,TARSKI,PARTFUN1,FUNCT_1,RELAT_1,ZFMISC_1,INT_2,FINSEQOP,NEWTON,FINSEQ_1,FINSEQ_2,CKB21,CKB27;
definitions FINSEQ_2,XBOOLEAN,EUCLID,CKB21,CKB27;
theorems POWER,NAT_1,PRE_FF,ABSVALUE,BINARI_3,INT_1,BINARITH,NAT_2,BINARI_2,FINSEQ_1,FINSEQ_2,FINSEQ_4,FUNCOP_1,RVSUM_1,FUNCT_2,ZFMISC_1,INT_3,EULER_2,PEPIN,PREPOWER,XREAL_1,XXREAL_0,XBOOLEAN,NAT_D,VALUED_1,XREAL_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42;
schemes NAT_1;
registrations XBOOLE_0,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,XBOOLEAN,MARGREL1,VALUED_0,FINSEQ_1,FINSEQ_2,RELAT_1,FUNCT_1,CARD_1;
constructors XXREAL_0,REAL_1,NAT_D,FINSEQOP,NEWTON,SERIES_1,BINARITH,BINARI_2,EUCLID,BINARI_3,RVSUM_1,RELSET_1,CKB21,CKB27;
requirements REAL,BOOLE,SUBSET,NUMERALS,ARITHM;
begin
reserve n for non  empty Nat;
reserve h for Integer;
reserve i for Integer;
theorem
Th35: (for n being non  empty Nat holds (((((( - ( 2 to_power n ) ) <= ( h + i ) & h < ( 0 )) & i < ( 0 )) & ( - ( 2 to_power ( n -' 1 ) ) ) <= h) & ( - ( 2 to_power ( n -' 1 ) ) ) <= i) implies ( ( carry (( 2sComplement (( n + 1 ),h) ),( 2sComplement (( n + 1 ),i) )) ) /. ( n + 1 ) ) = ( TRUE )))
proof
defpred P[ Nat ]
 means
(((((( - ( 2 to_power $1 ) ) <= ( h + i ) & h < ( 0 )) & i < ( 0 )) & ( - ( 2 to_power ( $1 -' 1 ) ) ) <= h) & ( - ( 2 to_power ( $1 -' 1 ) ) ) <= i) implies ( ( carry (( 2sComplement (( $1 + 1 ),h) ),( 2sComplement (( $1 + 1 ),i) )) ) /. ( $1 + 1 ) ) = ( TRUE ));
A1: (for n being non  empty Nat holds (P[ n ] implies P[ ( n + 1 ) ]))
proof
let n being non  empty Nat;
assume that
P[ n ];
assume that
( - ( 2 to_power ( n + 1 ) ) ) <= ( h + i )
and
A2: h < ( 0 )
and
A3: i < ( 0 )
and
A4: ( - ( 2 to_power ( ( n + 1 ) -' 1 ) ) ) <= h
and
A5: ( - ( 2 to_power ( ( n + 1 ) -' 1 ) ) ) <= i;
set H1 = ( 2sComplement (( ( n + 1 ) + 1 ),h) );
set I1 = ( 2sComplement (( ( n + 1 ) + 1 ),i) );
set H = ( 2sComplement (( n + 1 ),h) );
set I = ( 2sComplement (( n + 1 ),i) );
set T = ( TRUE );
set N = ( n + 1 );
A6: ( N -' 1 ) = ( N - 1 ) by XREAL_0:def 2;
then A7: ( 2 to_power ( N -' 1 ) ) < ( 2 to_power N ) by POWER:39,XREAL_1:146;
( ( 2 to_power ( N -' 1 ) ) + ( 2 to_power ( N -' 1 ) ) ) = ( 2 * ( 2 to_power ( N -' 1 ) ) )
.= ( ( 2 to_power 1 ) * ( 2 to_power ( N -' 1 ) ) ) by POWER:25
.= ( 2 to_power ( ( 0 ) + N ) ) by A6,POWER:27;
then A8: ( ( - ( 2 to_power ( N -' 1 ) ) ) + ( 2 to_power N ) ) = ( 2 to_power ( N -' 1 ) );
then A9: ( 2 to_power ( N -' 1 ) ) <= ( ( 2 to_power N ) + h ) by A4,XREAL_1:6;
A10: ( 2 to_power ( N -' 1 ) ) <= ( ( 2 to_power N ) + i ) by A5,A8,XREAL_1:6;
A11: ( ( 2 to_power N ) + i ) < ( ( 0 ) + ( 2 to_power N ) ) by A3,XREAL_1:8;
( N - 1 ) = n;
then A12: ( N -' 1 ) = n by XREAL_0:def 2;
(( 0 ) <= ( ( 2 to_power N ) + h ) & ( 0 ) <= ( ( 2 to_power N ) + i )) by A4,A5,A8,XREAL_1:6;
then reconsider NH = ( ( 2 to_power N ) + h ),NI = ( ( 2 to_power N ) + i ) as (Element of ( NAT )) by INT_1:3;
A13: ( len ( N -BinarySequence NI ) ) = N by CARD_1:def 7;
A14: 1 <= N by NAT_1:11;
then A15: (( H1 /. N ) = ( H /. N ) & ( I1 /. N ) = ( I /. N )) by CKB40:1;
A16: ( ( 2 to_power N ) + h ) < ( ( 0 ) + ( 2 to_power N ) ) by A2,XREAL_1:8;
A17: N < ( N + 1 ) by NAT_1:13;
( abs i ) = ( - i ) by A3,ABSVALUE:def 1;
then ( - ( - ( 2 to_power ( N -' 1 ) ) ) ) >= ( abs i ) by A5,XREAL_1:24;
then ( MajP (N,( abs i )) ) = N by A7,CKB25:1,XXREAL_0:2;
then A18: ( I /. N ) = ( ( N -BinarySequence ( abs NI ) ) /. N ) by A3,CKB27:def 1
.= ( ( N -BinarySequence NI ) /. N ) by ABSVALUE:def 1
.= ( ( N -BinarySequence NI ) . N ) by A14,A13,FINSEQ_4:15
.= T by A12,A10,A11,BINARI_3:29;
A19: ( len ( N -BinarySequence NH ) ) = N by CARD_1:def 7;
( abs h ) = ( - h ) by A2,ABSVALUE:def 1;
then ( - ( - ( 2 to_power ( N -' 1 ) ) ) ) >= ( abs h ) by A4,XREAL_1:24;
then ( MajP (N,( abs h )) ) = N by A7,CKB25:1,XXREAL_0:2;
then ( H /. N ) = ( ( N -BinarySequence ( abs NH ) ) /. N ) by A2,CKB27:def 1
.= ( ( N -BinarySequence NH ) /. N ) by ABSVALUE:def 1
.= ( ( N -BinarySequence NH ) . N ) by A14,A19,FINSEQ_4:15
.= T by A12,A9,A16,BINARI_3:29;
then ( ( carry (H1,I1) ) /. ( N + 1 ) ) = ( ( ( T '&' T ) 'or' ( T '&' ( ( carry (H1,I1) ) /. N ) ) ) 'or' ( T '&' ( ( carry (H1,I1) ) /. N ) ) ) by A14,A18,A15,A17,BINARITH:def 2
.= ( T 'or' ( ( carry (H1,I1) ) /. N ) );
hence thesis;
end;
A20: P[ 1 ]
proof
( 1 -' 1 ) = ( 1 - 1 ) by XREAL_0:def 2;
then ( 3 div ( 2 to_power ( 1 -' 1 ) ) ) = ( ( 1 + 2 ) div 1 ) by POWER:24
.= 3 by NAT_2:4;
then A21: ( ( 3 div ( 2 to_power ( 1 -' 1 ) ) ) mod 2 ) = ( ( 2 + 1 ) mod 2 )
.= ( ( ( 2 mod 2 ) + 1 ) mod 2 ) by NAT_D:22
.= ( ( ( 0 ) + 1 ) mod 2 ) by NAT_D:25
.= 1 by PEPIN:5;
A22: ( ( - 2 ) + 1 ) = ( - 1 );
set H = ( 2sComplement (2,h) );
set I = ( 2sComplement (2,i) );
set T = ( TRUE );
assume that
A23: ( - ( 2 to_power 1 ) ) <= ( h + i )
and
A24: h < ( 0 )
and
A25: i < ( 0 )
and
( - ( 2 to_power ( 1 -' 1 ) ) ) <= h
and
( - ( 2 to_power ( 1 -' 1 ) ) ) <= i;
A26: i <= ( - 1 ) by A25,INT_1:8;
( - ( 2 to_power 1 ) ) < h by A23,A24,A25,CKB9:1;
then ( - 2 ) < h by POWER:25;
then A27: ( - 1 ) <= h by A22,INT_1:7;
( - ( 2 to_power 1 ) ) < i by A23,A24,A25,CKB9:1;
then ( - 2 ) < i by POWER:25;
then ( - 1 ) <= i by A22,INT_1:7;
then A28: i = ( - 1 ) by A26,XXREAL_0:1;
A29: 1 in ( Seg 2 ) by FINSEQ_1:1;
A30: ( 2 to_power 2 ) = ( 2 |^ ( 1 + 1 ) ) by POWER:41
.= ( ( 2 |^ 1 ) + ( 2 |^ 1 ) ) by PEPIN:29
.= ( ( 2 to_power 1 ) + ( 2 |^ 1 ) ) by POWER:41
.= ( ( 2 to_power 1 ) + ( 2 to_power 1 ) ) by POWER:41
.= ( 2 + ( 2 to_power 1 ) ) by POWER:25
.= ( 2 + 2 ) by POWER:25;
A31: ( 2 to_power 2 ) > ( 2 to_power ( 0 ) ) by POWER:39;
A32: h <= ( - 1 ) by A24,INT_1:8;
then A33: h = ( - 1 ) by A27,XXREAL_0:1;
then ( abs h ) = ( - ( - 1 ) ) by ABSVALUE:def 1;
then ( 2 to_power ( 0 ) ) = ( abs h ) by POWER:24;
then ( MajP (2,( abs h )) ) = 2 by A31,CKB25:1;
then ( abs ( ( 2 to_power ( MajP (2,( abs h )) ) ) + h ) ) = ( abs ( 4 + ( - 1 ) ) ) by A27,A32,A30,XXREAL_0:1
.= 3 by ABSVALUE:def 1;
then ( ( 2sComplement (2,h) ) /. 1 ) = ( ( 2 -BinarySequence 3 ) /. 1 ) by A24,CKB27:def 1
.= ( IFEQ (1,( 0 ),( FALSE ),( TRUE )) ) by A21,A29,BINARI_3:def 1
.= ( TRUE ) by FUNCOP_1:def 8;
then ( ( carry (H,I) ) /. ( 1 + 1 ) ) = ( ( ( T '&' T ) 'or' ( T '&' ( ( carry (H,I) ) /. 1 ) ) ) 'or' ( T '&' ( ( carry (H,I) ) /. 1 ) ) ) by A33,A28,BINARITH:def 2
.= ( T 'or' ( ( carry (H,I) ) /. 1 ) );
hence thesis;
end;
thus (for n being non  empty Nat holds P[ n ]) from NAT_1:sch 10(A20,A1);
end;
