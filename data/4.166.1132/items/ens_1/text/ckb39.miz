environ
vocabularies XBOOLE_0,SUBSET_1,FUNCT_2,TARSKI,FUNCT_1,RELAT_1,ZFMISC_1,MCART_1,GRAPH_1,PARTFUN1,CAT_1,STRUCT_0,QC_LANG1,CLASSES2,FUNCOP_1,FUNCT_4,CAT_2,OPPCAT_1,FUNCT_5,ARYTM_0,ENS_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,MCART_1,DOMAIN_1,RELAT_1,FUNCT_1,FUNCT_2,BINOP_1,PARTFUN1,FUNCT_4,FUNCT_5,CLASSES2,FUNCOP_1,STRUCT_0,GRAPH_1,CAT_1,CAT_2,OPPCAT_1,CKB1,CKB6,CKB14,CKB15,CKB21,CKB23,CKB27,CKB36,CKB37,CKB38;
definitions TARSKI,FUNCT_1,CAT_1,CAT_2,BINOP_1,RELAT_1,GRAPH_1,CKB1,CKB6,CKB14,CKB15,CKB21,CKB23,CKB27,CKB36,CKB37,CKB38;
theorems TARSKI,ENUMSET1,ZFMISC_1,MCART_1,DOMAIN_1,FUNCT_1,FUNCT_2,PARTFUN1,FUNCOP_1,FUNCT_4,CLASSES2,CAT_1,CAT_2,OPPCAT_1,GRFUNC_1,RELAT_1,RELSET_1,XBOOLE_0,XBOOLE_1,BINOP_1,CKB1,CKB3,CKB4,CKB5,CKB6,CKB8,CKB9,CKB10,CKB11,CKB12,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38;
schemes FUNCT_2,BINOP_1,FUNCT_1;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,FUNCT_2,RELSET_1,STRUCT_0,PARTFUN1,CKB2,CKB7,CKB13;
constructors PARTFUN1,DOMAIN_1,CLASSES2,CAT_2,OPPCAT_1,FUNCOP_1,RELSET_1,CKB1,CKB6,CKB14,CKB15,CKB21,CKB23,CKB27,CKB36,CKB37,CKB38;
requirements SUBSET,BOOLE;
begin
reserve V for non  empty set;
reserve m for (Element of ( Maps V ));
reserve m1 for (Element of ( Maps V ));
reserve m2 for (Element of ( Maps V ));
definition
let V;
func fComp V -> (PartFunc of [: ( Maps V ),( Maps V ) :],( Maps V )) means 
:Def12: ((for m2 holds (for m1 holds ([ m2,m1 ] in ( dom it ) iff ( dom m2 ) = ( cod m1 )))) & (for m2 holds (for m1 holds (( dom m2 ) = ( cod m1 ) implies ( it . [ m2,m1 ] ) = ( m2 * m1 )))));
existence
proof
defpred P[ set,set,set ]
 means
(for m2 holds (for m1 holds ((m2 = $1 & m1 = $2) implies (( dom m2 ) = ( cod m1 ) & $3 = ( m2 * m1 )))));
A5: (for x,y,z1,z2 being set holds ((((x in ( Maps V ) & y in ( Maps V )) & P[ x,y,z1 ]) & P[ x,y,z2 ]) implies z1 = z2))
proof
let x being set;
let y being set;
let z1 being set;
let z2 being set;
assume (x in ( Maps V ) & y in ( Maps V ));
then reconsider m2 = x,m1 = y as (Element of ( Maps V ));
assume that
A6: P[ x,y,z1 ]
and
A7: P[ x,y,z2 ];
z1 = ( m2 * m1 ) by A6;
hence thesis by A7;
end;
A8: (for x,y,z being set holds (((x in ( Maps V ) & y in ( Maps V )) & P[ x,y,z ]) implies z in ( Maps V )))
proof
let x being set;
let y being set;
let z being set;
assume (x in ( Maps V ) & y in ( Maps V ));
then reconsider m2 = x,m1 = y as (Element of ( Maps V ));
assume P[ x,y,z ];
then z = ( m2 * m1 );
hence thesis;
end;
consider h being (PartFunc of [: ( Maps V ),( Maps V ) :],( Maps V )) such that A9: (for x,y being set holds ([ x,y ] in ( dom h ) iff ((x in ( Maps V ) & y in ( Maps V )) & (ex z being set st P[ x,y,z ])))) and A10: (for x,y being set holds ([ x,y ] in ( dom h ) implies P[ x,y,( h . (x,y) ) ])) from BINOP_1:sch 5(A8,A5);
take h;
thus A11: (for m2 holds (for m1 holds ([ m2,m1 ] in ( dom h ) iff ( dom m2 ) = ( cod m1 ))))
proof
let m2;
let m1;
thus ([ m2,m1 ] in ( dom h ) implies ( dom m2 ) = ( cod m1 ))
proof
assume [ m2,m1 ] in ( dom h );
then (ex z being set st P[ m2,m1,z ]) by A9;
hence thesis;
end;

assume ( dom m2 ) = ( cod m1 );
then P[ m2,m1,( m2 * m1 ) ];
hence thesis by A9;
end;

let m2;
let m1;
assume ( dom m2 ) = ( cod m1 );
then [ m2,m1 ] in ( dom h ) by A11;
then P[ m2,m1,( h . (m2,m1) ) ] by A10;
hence thesis;
end;
uniqueness
proof
let h1 being (PartFunc of [: ( Maps V ),( Maps V ) :],( Maps V ));
let h2 being (PartFunc of [: ( Maps V ),( Maps V ) :],( Maps V ));
assume that
A12: (for m2 holds (for m1 holds ([ m2,m1 ] in ( dom h1 ) iff ( dom m2 ) = ( cod m1 ))))
and
A13: (for m2 holds (for m1 holds (( dom m2 ) = ( cod m1 ) implies ( h1 . [ m2,m1 ] ) = ( m2 * m1 ))))
and
A14: (for m2 holds (for m1 holds ([ m2,m1 ] in ( dom h2 ) iff ( dom m2 ) = ( cod m1 ))))
and
A15: (for m2 holds (for m1 holds (( dom m2 ) = ( cod m1 ) implies ( h2 . [ m2,m1 ] ) = ( m2 * m1 ))));
A16: ( dom h2 ) c= [: ( Maps V ),( Maps V ) :] by RELAT_1:def 18;
A17: ( dom h1 ) c= [: ( Maps V ),( Maps V ) :] by RELAT_1:def 18;
A18: ( dom h1 ) = ( dom h2 )
proof
let x being set;
let y being set;
thus ([ x,y ] in ( dom h1 ) implies [ x,y ] in ( dom h2 ))
proof
assume A19: [ x,y ] in ( dom h1 );
then reconsider m2 = x,m1 = y as (Element of ( Maps V )) by A17,ZFMISC_1:87;
( dom m2 ) = ( cod m1 ) by A12,A19;
hence thesis by A14;
end;

assume A20: [ x,y ] in ( dom h2 );
then reconsider m2 = x,m1 = y as (Element of ( Maps V )) by A16,ZFMISC_1:87;
( dom m2 ) = ( cod m1 ) by A14,A20;
hence thesis by A12;
end;
now
let m being (Element of [: ( Maps V ),( Maps V ) :]);
consider m2,m1 such that A21: m = [ m2,m1 ] by DOMAIN_1:1;
assume m in ( dom h1 );
then A22: ( dom m2 ) = ( cod m1 ) by A12,A21;
then ( h1 . [ m2,m1 ] ) = ( m2 * m1 ) by A13;
hence ( h1 . m ) = ( h2 . m ) by A15,A21,A22;
end;
hence thesis by A18,PARTFUN1:5;
end;
end;
