environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,XREAL_0,ORDINAL1,XXREAL_0,SEQ_4,XXREAL_2,ARYTM_1,CARD_1,ARYTM_3,METRIC_1,NAT_1,PCOMPS_1,SEQ_2,FUNCT_1,RCOMP_1,ORDINAL2,TARSKI,REAL_1,STRUCT_0,PRE_TOPC,RELAT_1,SEQ_1,COMPLEX1,XXREAL_1,TOPMETR,VALUED_0,BORSUK_1,EUCLID,TOPREAL1,TOPREAL2,PSCOMP_1,JORDAN6,TOPS_2;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,NUMBERS,XCMPLX_0,XXREAL_0,XXREAL_2,XREAL_0,COMPLEX1,REAL_1,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,BINOP_1,NAT_1,STRUCT_0,METRIC_1,PRE_TOPC,TOPS_2,COMPTS_1,PCOMPS_1,RCOMP_1,EUCLID,PSCOMP_1,TOPMETR,SEQ_1,SEQ_2,SEQM_3,SEQ_4,TBSP_1,JORDAN6,TOPREAL1,TOPREAL2;
definitions TARSKI,STRUCT_0,XXREAL_2;
theorems PRE_TOPC,TOPMETR,XREAL_0,TBSP_1,XBOOLE_0,METRIC_1,FUNCT_1,XBOOLE_1,FUNCT_2,JGRAPH_2,GOBOARD6,SEQ_2,TREAL_1,SEQ_4,NAT_1,SEQM_3,UNIFORM1,BORSUK_1,JORDAN6,TOPREAL1,TOPS_2,TARSKI,RELAT_1,TOPREAL3,JORDAN5B,PREPOWER,XCMPLX_1,XREAL_1,XXREAL_0,XXREAL_1,EUCLID,XXREAL_2,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11;
schemes FUNCT_2,RECDEF_1,NAT_1;
registrations XBOOLE_0,ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,MEMBERED,STRUCT_0,PRE_TOPC,METRIC_1,PCOMPS_1,EUCLID,TOPMETR,COMPTS_1,VALUED_0,SEQ_4;
constructors REAL_1,NAT_1,COMPLEX1,SEQM_3,RCOMP_1,TOPS_2,COMPTS_1,TBSP_1,TOPMETR,TOPREAL1,PSCOMP_1,JORDAN5C,JORDAN6,SEQ_1,XXREAL_2,SEQ_4,BINOP_2,RVSUM_1,SEQ_2,PCOMPS_1;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
theorem
Th16: (for R being non  empty (Subset of ( REAL )) holds (R is  bounded_below implies (ex s being Real_Sequence st ((s is  non-increasing  convergent & ( rng s ) c= R) & ( lim s ) = ( lower_bound R )))))
proof
let R being non  empty (Subset of ( REAL ));
reconsider rs = ( lower_bound R ) as  real number;
defpred X[ (Element of ( NAT )), real number ]
 means
($2 in R & (for r00 being  real number holds (r00 = $2 implies ( rs + (( 1 / ( $1 + 1 ) ) qua  real number) ) > r00)));
assume A1: R is  bounded_below;
A2: (for n being (Element of ( NAT )) holds (ex r being Real st X[ n,r ]))
proof
let n being (Element of ( NAT ));
( ( n + 1 ) " ) > ( 0 );
then ( 1 / ( n + 1 ) ) > ( 0 ) by XCMPLX_1:215;
then consider r0 being  real number such that A3: r0 in R and A4: ( rs + (( 1 / ( n + 1 ) ) qua  real number) ) > r0 by A1,SEQ_4:def 2;
(for r00 being  real number holds (r00 = r0 implies ( rs + (( 1 / ( n + 1 ) ) qua  real number) ) > r00)) by A4;
hence thesis by A3;
end;
(ex s1 being (Function of ( NAT ),( REAL )) st (for n being (Element of ( NAT )) holds X[ n,( s1 . n ) ])) from FUNCT_2:sch 3(A2);
then consider s1 being (Function of ( NAT ),( REAL )) such that A5: (for n being (Element of ( NAT )) holds (( s1 . n ) in R & (for r0 being  real number holds (r0 = ( s1 . n ) implies ( rs + (( 1 / ( n + 1 ) ) qua  real number) ) > r0))));
defpred P[ set,set,set ]
 means
(($2 is  real  real number implies (for r1,r2 being  real number holds (for n1 being Nat holds (((r1 = $2 & r2 = ( s1 . ( n1 + 1 ) )) & n1 = $1) implies ((r1 <= r2 implies $3 = $2) & (r1 > r2 implies $3 = ( s1 . ( n1 + 1 ) ))))))) & ((not $2 is  real  real number) implies $3 = 1));
A6: (for n being (Element of ( NAT )) holds (for x being set holds (ex y being set st P[ n,x,y ])))
proof
let n being (Element of ( NAT ));
thus (for x being set holds (ex y being set st P[ n,x,y ]))
proof
let x being set;
now
per cases ;
case (not x is  real  real number);
hence (ex y being set st ((x is  real  real number implies (for r1,r2 being  real number holds (for n1 being Nat holds (((r1 = x & r2 = ( s1 . ( n1 + 1 ) )) & n1 = n) implies ((r1 >= r2 implies y = x) & (r1 < r2 implies y = ( s1 . ( n1 + 1 ) ))))))) & ((not x is  real  real number) implies y = 1)));
end;
case A7: x is  real  real number;
then reconsider r10 = x as  real number;
reconsider r20 = ( s1 . ( n + 1 ) ) as  real number;
now
per cases ;
case r10 <= r20;
then (for r1,r2 being  real number holds (for n1 being Nat holds (((r1 = x & r2 = ( s1 . ( n1 + 1 ) )) & n1 = n) implies ((r1 <= r2 implies x = x) & (r1 > r2 implies x = ( s1 . ( n1 + 1 ) ))))));
hence thesis by A7;
end;
case r10 > r20;
then (for r1,r2 being  real number holds (for n1 being Nat holds (((r1 = x & r2 = ( s1 . ( n1 + 1 ) )) & n1 = n) implies ((r1 <= r2 implies ( s1 . ( n + 1 ) ) = x) & (r1 > r2 implies ( s1 . ( n + 1 ) ) = ( s1 . ( n1 + 1 ) ))))));
hence thesis by A7;
end;
end;
hence thesis;
end;
end;
hence thesis;
end;

end;
(ex f being Function st ((( dom f ) = ( NAT ) & ( f . ( 0 ) ) = ( s1 . ( 0 ) )) & (for n being (Element of ( NAT )) holds P[ n,( f . n ),( f . ( n + 1 ) ) ]))) from RECDEF_1:sch 1(A6);
then consider s2 being Function such that A8: ( dom s2 ) = ( NAT ) and A9: ( s2 . ( 0 ) ) = ( s1 . ( 0 ) ) and A10: (for n being (Element of ( NAT )) holds P[ n,( s2 . n ),( s2 . ( n + 1 ) ) ]);
A11: ( rng s2 ) c= ( REAL )
proof
defpred X[ Nat ]
 means
( s2 . $1 ) in ( REAL );
let y being set;
assume y in ( rng s2 );
then consider x being set such that A12: x in ( dom s2 ) and A13: y = ( s2 . x ) by FUNCT_1:def 3;
reconsider n = x as (Element of ( NAT )) by A8,A12;
A14: (for k being (Element of ( NAT )) holds (X[ k ] implies X[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
reconsider r2 = ( s1 . ( k + 1 ) ) as Real;
assume A15: ( s2 . k ) in ( REAL );
then reconsider r1 = ( s2 . k ) as Real;
now
per cases ;
case r1 <= r2;
hence thesis by A10,A15;
end;
case r1 > r2;
then ( s2 . ( k + 1 ) ) = ( s1 . ( k + 1 ) ) by A10;
hence thesis;
end;
end;
hence thesis;
end;
A16: X[ ( 0 ) ] by A9;
(for m being (Element of ( NAT )) holds X[ m ]) from NAT_1:sch 1(A16,A14);
then ( s2 . n ) in ( REAL );
hence thesis by A13;
end;
then reconsider s3 = s2 as Real_Sequence by A8,FUNCT_2:2;
defpred X[ Nat ]
 means
( s1 . $1 ) >= ( s3 . $1 );
A17: (for k being (Element of ( NAT )) holds (X[ k ] implies X[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume ( s1 . k ) >= ( s3 . k );
reconsider r2 = ( s1 . ( k + 1 ) ) as  real number;
( s2 . k ) in ( rng s2 ) by A8,FUNCT_1:def 3;
then reconsider r1 = ( s2 . k ) as  real number by A11;
now
per cases ;
case r1 <= r2;
hence thesis by A10;
end;
case r1 > r2;
hence thesis by A10;
end;
end;
hence thesis;
end;
A18: X[ ( 0 ) ] by A9;
A19: (for n4 being (Element of ( NAT )) holds X[ n4 ]) from NAT_1:sch 1(A18,A17);
defpred X[ Nat ]
 means
(( 0 ) <= $1 implies ( s3 . ( 0 ) ) >= ( s3 . $1 ));
A20: (for n4 being (Element of ( NAT )) holds ( s3 . n4 ) >= ( s3 . ( n4 + 1 ) ))
proof
let n4 being (Element of ( NAT ));
reconsider r2 = ( s1 . ( n4 + 1 ) ) as  real number;
( dom s3 ) = ( NAT ) by FUNCT_2:def 1;
then reconsider r1 = ( s2 . n4 ) as  real number;
now
per cases ;
case r1 <= r2;
hence thesis by A10;
end;
case r1 > r2;
hence thesis by A10;
end;
end;
hence thesis;
end;
A21: (for k being (Element of ( NAT )) holds (X[ k ] implies X[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume A22: (( 0 ) <= k implies ( s3 . ( 0 ) ) >= ( s3 . k ));
now
assume ( 0 ) <= ( k + 1 );
A23: ( s3 . k ) >= ( s3 . ( k + 1 ) ) by A20;
now
per cases ;
case ( 0 ) < ( k + 1 );
thus ( s3 . ( 0 ) ) >= ( s3 . ( k + 1 ) ) by A22,A23,XXREAL_0:2;
end;
case ( 0 ) = ( k + 1 );
hence ( s3 . ( 0 ) ) >= ( s3 . ( k + 1 ) );
end;
end;
hence ( s3 . ( 0 ) ) >= ( s3 . ( k + 1 ) );
end;
hence thesis;
end;
defpred Y[ Nat ]
 means
(for n4 being (Element of ( NAT )) holds ($1 <= n4 implies ( s3 . $1 ) >= ( s3 . n4 )));
A24: (for k being (Element of ( NAT )) holds (Y[ k ] implies Y[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume (for n5 being (Element of ( NAT )) holds (k <= n5 implies ( s3 . k ) >= ( s3 . n5 )));
defpred X[ Nat ]
 means
(( k + 1 ) <= $1 implies ( s3 . ( k + 1 ) ) >= ( s3 . $1 ));
A25: (for i being (Element of ( NAT )) holds (X[ i ] implies X[ ( i + 1 ) ]))
proof
let i being (Element of ( NAT ));
reconsider r2 = ( s1 . ( i + 1 ) ) as  real number;
( s2 . i ) in ( rng s2 ) by A8,FUNCT_1:def 3;
then reconsider r1 = ( s2 . i ) as  real number by A11;
A26:now
per cases ;
case r1 <= r2;
hence ( s3 . i ) >= ( s3 . ( i + 1 ) ) by A10;
end;
case r1 > r2;
hence ( s3 . i ) >= ( s3 . ( i + 1 ) ) by A10;
end;
end;
assume A27: (( k + 1 ) <= i implies ( s3 . ( k + 1 ) ) >= ( s3 . i ));
now
assume A28: ( k + 1 ) <= ( i + 1 );
now
per cases  by A28,XXREAL_0:1;
case ( k + 1 ) < ( i + 1 );
hence ( s3 . ( k + 1 ) ) >= ( s3 . ( i + 1 ) ) by A27,A26,NAT_1:13,XXREAL_0:2;
end;
case ( k + 1 ) = ( i + 1 );
hence ( s3 . ( k + 1 ) ) >= ( s3 . ( i + 1 ) );
end;
end;
hence ( s3 . ( k + 1 ) ) >= ( s3 . ( i + 1 ) );
end;
hence thesis;
end;
A29: X[ ( 0 ) ];
thus (for n4 being (Element of ( NAT )) holds X[ n4 ]) from NAT_1:sch 1(A29,A25);
end;
A30: X[ ( 0 ) ];
(for n4 being (Element of ( NAT )) holds X[ n4 ]) from NAT_1:sch 1(A30,A21);
then A31: Y[ ( 0 ) ];
(for m4 being (Element of ( NAT )) holds Y[ m4 ]) from NAT_1:sch 1(A31,A24);
then (for m4,n4 being (Element of ( NAT )) holds (((m4 in ( dom s3 ) & n4 in ( dom s3 )) & m4 <= n4) implies ( s3 . m4 ) >= ( s3 . n4 )));
then A32: s3 is  non-increasing by SEQM_3:def 4;
A33: ( rng s3 ) c= R
proof
defpred Z[ Nat ]
 means
( s3 . $1 ) in R;
let y being set;
assume y in ( rng s3 );
then A34: (ex x being set st (x in ( dom s3 ) & y = ( s3 . x ))) by FUNCT_1:def 3;
A35: (for k being (Element of ( NAT )) holds (Z[ k ] implies Z[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
reconsider r2 = ( s1 . ( k + 1 ) ) as  real number;
( s2 . k ) in ( rng s2 ) by A8,FUNCT_1:def 3;
then reconsider r1 = ( s2 . k ) as  real number by A11;
assume A36: ( s3 . k ) in R;
now
per cases ;
case r1 <= r2;
hence thesis by A10,A36;
end;
case r1 > r2;
then ( s2 . ( k + 1 ) ) = ( s1 . ( k + 1 ) ) by A10;
hence thesis by A5;
end;
end;
hence thesis;
end;
A37: Z[ ( 0 ) ] by A5,A9;
(for nn being (Element of ( NAT )) holds Z[ nn ]) from NAT_1:sch 1(A37,A35);
hence thesis by A34;
end;
(for n being (Element of ( NAT )) holds ( s3 . n ) > ( ( lower_bound R ) - 1 ))
proof
let n being (Element of ( NAT ));
( lower_bound R ) < ( ( lower_bound R ) + 1 ) by XREAL_1:29;
then A38: ( lower_bound R ) > ( ( lower_bound R ) - 1 ) by XREAL_1:19;
( s3 . n ) in ( rng s3 ) by A8,FUNCT_1:def 3;
then ( s3 . n ) >= ( lower_bound R ) by A1,A33,SEQ_4:def 2;
hence thesis by A38,XXREAL_0:2;
end;
then A39: s3 is  bounded_below by SEQ_2:def 4;
A40: (for r being Real holds (r > ( 0 ) implies ( ( lower_bound R ) + r ) > ( lim s3 )))
proof
let r being Real;
assume A41: r > ( 0 );
consider n2 being (Element of ( NAT )) such that A42: ( 1 / r ) < n2 by SEQ_4:3;
n2 < ( n2 + 1 ) by XREAL_1:29;
then ( 1 / r ) < ( n2 + 1 ) by A42,XXREAL_0:2;
then ( ( 1 / r ) * r ) < ( ( n2 + 1 ) * r ) by A41,XREAL_1:68;
then 1 < ( ( n2 + 1 ) * r ) by A41,XCMPLX_1:106;
then ( 1 / ( n2 + 1 ) ) < ( ( ( n2 + 1 ) * r ) / ( n2 + 1 ) ) by XREAL_1:74;
then ( 1 / ( n2 + 1 ) ) < r by XCMPLX_1:89;
then ( rs + ( 1 / ( n2 + 1 ) ) ) < ( rs + r ) by XREAL_1:8;
then A43: ( rs + r ) > ( s1 . n2 ) by A5,XXREAL_0:2;
A44: ( s3 . n2 ) >= ( lim s3 ) by A32,A39,SEQ_4:38;
( s1 . n2 ) >= ( s3 . n2 ) by A19;
then ( rs + r ) > ( s3 . n2 ) by A43,XXREAL_0:2;
hence thesis by A44,XXREAL_0:2;
end;
A45:now
reconsider r = ( ( lim s3 ) - ( lower_bound R ) ) as Real;
assume ( lower_bound R ) < ( lim s3 );
then r > ( 0 ) by XREAL_1:50;
then ( ( lower_bound R ) + ( ( lim s3 ) + ( - ( lower_bound R ) ) ) ) > ( lim s3 ) by A40;
hence contradiction;
end;
A46: (for n being (Element of ( NAT )) holds ( s3 . n ) >= ( lower_bound R ))
proof
let n being (Element of ( NAT ));
( dom s3 ) = ( NAT ) by FUNCT_2:def 1;
then ( s3 . n ) in ( rng s3 ) by FUNCT_1:def 3;
hence thesis by A1,A33,SEQ_4:def 2;
end;
(for n being (Element of ( NAT )) holds ( s3 . n ) > ( ( lower_bound R ) - 1 ))
proof
let n being (Element of ( NAT ));
( lower_bound R ) < ( ( lower_bound R ) + 1 ) by XREAL_1:29;
then A47: ( lower_bound R ) > ( ( lower_bound R ) - 1 ) by XREAL_1:19;
( s3 . n ) >= ( lower_bound R ) by A46;
hence thesis by A47,XXREAL_0:2;
end;
then A48: s3 is  bounded_below by SEQ_2:def 4;
then ( lim s3 ) >= ( lower_bound R ) by A32,A46,PREPOWER:1;
hence thesis by A32,A33,A48,A45,XXREAL_0:1;
end;
