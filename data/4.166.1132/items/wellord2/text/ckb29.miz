environ
vocabularies RELAT_1,ORDINAL1,TARSKI,RELAT_2,WELLORD1,XBOOLE_0,SUBSET_1,ZFMISC_1,FUNCT_1,MCART_1,WELLORD2;
notations TARSKI,XBOOLE_0,ZFMISC_1,MCART_1,SUBSET_1,RELAT_1,RELAT_2,FUNCT_1,WELLORD1,ORDINAL1,CKB1,CKB15,CKB16,CKB18;
definitions TARSKI,XBOOLE_0,FUNCT_1,RELAT_1,RELAT_2,WELLORD1,CKB1,CKB15,CKB16,CKB18;
theorems TARSKI,FUNCT_1,RELAT_1,RELAT_2,ZFMISC_1,WELLORD1,ORDINAL1,XBOOLE_0,XBOOLE_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26;
schemes FUNCT_1,RELAT_1,ORDINAL1,XBOOLE_0;
registrations RELAT_1,FUNCT_1,ORDINAL1,CKB27,CKB28;
constructors RELAT_2,ORDINAL1,WELLORD1,MCART_1,CKB1,CKB15,CKB16,CKB18;
requirements SUBSET,BOOLE;
begin
reserve Y for set;
reserve Z for set;
reserve x for set;
theorem
( RelIncl { x } ) = { [ x,x ] }
proof
A1: (for Y,Z being set holds ((Y in { x } & Z in { x }) implies ([ Y,Z ] in { [ x,x ] } iff Y c= Z)))
proof
let Y being set;
let Z being set;
assume that
A2: Y in { x }
and
A3: Z in { x };
A4: Y = x by A2,TARSKI:def 1;
hence ([ Y,Z ] in { [ x,x ] } implies Y c= Z) by A3,TARSKI:def 1;
Z = x by A3,TARSKI:def 1;
hence thesis by A4,TARSKI:def 1;
end;
( field { [ x,x ] } ) = { x } by RELAT_1:173;
hence thesis by A1,CKB1:def 1;
end;
