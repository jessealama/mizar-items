environ
vocabularies UNIALG_1,NAT_1,XBOOLE_0,FUNCT_1,RELAT_1,TARSKI,SUBSET_1,FINSEQ_1,FUNCOP_1,PBOOLE,CARD_3,MSUALG_1,XXREAL_0,STRUCT_0,FINSEQ_2,PARTFUN1,CQC_SIM1,CARD_1,UNIALG_2,MARGREL1,NUMBERS,MSUALG_3,MEMBER_1,MSUHOM_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,NAT_1,RELAT_1,FUNCT_1,PBOOLE,RELSET_1,PARTFUN1,FUNCT_2,CARD_3,FUNCOP_1,FINSEQ_1,STRUCT_0,UNIALG_1,UNIALG_2,FINSEQ_2,ALG_1,MSUALG_3,MSUALG_1,XXREAL_0,CKB5;
definitions ALG_1,MSUALG_3,TARSKI,FUNCOP_1,FINSEQ_2,UNIALG_2,CKB5;
theorems TARSKI,FINSEQ_2,MSUALG_1,UNIALG_2,MSUALG_3,FUNCOP_1,FINSEQ_1,FUNCT_1,FUNCT_2,ALG_1,UNIALG_1,PBOOLE,MONOID_1,CARD_3,RELAT_1,XBOOLE_0,XBOOLE_1,PARTFUN1,FINSEQ_3,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9;
registrations XBOOLE_0,FUNCT_1,ORDINAL1,RELSET_1,FUNCT_2,FUNCOP_1,XREAL_0,PRE_CIRC,STRUCT_0,MSUALG_1,MSUALG_3,RELAT_1,PBOOLE,FINSEQ_1;
constructors XXREAL_0,CARD_3,FINSEQOP,ALG_1,MSUALG_3,XREAL_0,RELSET_1,PBOOLE,NAT_1,CKB5;
requirements NUMERALS,SUBSET,BOOLE;
begin
reserve A for non  empty set;
definition
let S being  strict non  void non  empty ManySortedSign;
let S9 being  strict non  void non  empty ManySortedSign;
let A being  non-empty  strict MSAlgebra over S9;
assume A1: S <= S9;
func A Over S ->  non-empty  strict MSAlgebra over S means 
:Def2: ((the Sorts of it) = ( (the Sorts of A) | (the carrier of S) ) & (the Charact of it) = ( (the Charact of A) | (the carrier' of S) ));
existence
proof
set D = ( (the Charact of A) | (the carrier' of S) );
set C = ( (the Sorts of A) | (the carrier of S) );
A2: ( rng (the Arity of S) ) c= ( (the carrier of S) * );
A3: (the carrier' of S) c= (the carrier' of S9) by A1,CKB5:def 1;
then reconsider D as (ManySortedSet of (the carrier' of S));
A4: (the carrier of S) c= (the carrier of S9) by A1,CKB5:def 1;
then reconsider C as (ManySortedSet of (the carrier of S));
( rng (the ResultSort of S) ) c= (the carrier of S);
then A5: ( C * (the ResultSort of S) ) = ( (the Sorts of A) * (the ResultSort of S) ) by CKB1:1
.= ( (the Sorts of A) * ( (the ResultSort of S9) | (the carrier' of S) ) ) by A1,CKB5:def 1
.= ( ( (the Sorts of A) * (the ResultSort of S9) ) | (the carrier' of S) ) by RELAT_1:83;
( ( C # ) * (the Arity of S) ) = ( ( ( (the Sorts of A) # ) | ( (the carrier of S) * ) ) * (the Arity of S) ) by A4,CKB4:1
.= ( ( (the Sorts of A) # ) * (the Arity of S) ) by A2,CKB1:1
.= ( ( (the Sorts of A) # ) * ( (the Arity of S9) | (the carrier' of S) ) ) by A1,CKB5:def 1
.= ( ( ( (the Sorts of A) # ) * (the Arity of S9) ) | (the carrier' of S) ) by RELAT_1:83;
then reconsider D as (ManySortedFunction of ( ( C # ) * (the Arity of S) ),( C * (the ResultSort of S) )) by A3,A5,CKB9:1;
reconsider B = MSAlgebra (# C,D #) as  non-empty  strict MSAlgebra over S by MSUALG_1:def 3;
take B;
thus thesis;
end;
uniqueness;
end;
