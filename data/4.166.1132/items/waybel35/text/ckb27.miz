environ
vocabularies XBOOLE_0,ZFMISC_1,SUBSET_1,STRUCT_0,ORDERS_2,WAYBEL_4,RELAT_1,RELAT_2,LATTICE3,LATTICES,FUNCT_1,YELLOW_1,LATTICE7,WAYBEL_0,SEQM_3,XXREAL_0,TARSKI,ARYTM_3,GROUP_4,ORDERS_1,WELLORD2,WELLORD1,YELLOW_0,EQREL_1,REWRITE1,WAYBEL_1,ORDINAL2,NUMBERS,CARD_1,NAT_1,WAYBEL35;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,NAT_1,RELAT_1,RELAT_2,FUNCT_1,RELSET_1,FUNCT_2,DOMAIN_1,STRUCT_0,WELLORD1,ORDERS_2,ORDERS_1,LATTICE3,YELLOW_0,YELLOW_1,ALG_1,WAYBEL_0,WAYBEL_1,WAYBEL_4,LATTICE7,CKB6,CKB12,CKB14,CKB21,CKB22,CKB24;
definitions TARSKI,XBOOLE_0,ORDERS_1,LATTICE3,WAYBEL_1,CKB6,CKB12,CKB14,CKB21,CKB22;
theorems WAYBEL_4,YELLOW_8,FUNCT_2,YELLOW_1,TARSKI,ORDERS_2,YELLOW_0,LATTICE3,YELLOW_4,WAYBEL_0,XBOOLE_0,LATTICE7,WAYBEL_1,XBOOLE_1,RELAT_1,WELLORD2,ORDERS_1,RELAT_2,ZFMISC_1,FUNCT_1,ORDINAL1,SUBSET_1,CKB1,CKB6,CKB12,CKB14,CKB15,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB25,CKB26;
schemes XBOOLE_0,FUNCT_2,RECDEF_1,NAT_1;
registrations SUBSET_1,ORDINAL1,RELSET_1,REALSET1,STRUCT_0,LATTICE3,YELLOW_0,WAYBEL_0,YELLOW_1,YELLOW_2,WAYBEL_4,FUNCT_1,ZFMISC_1,CARD_1,CKB2,CKB3,CKB4,CKB5,CKB7,CKB8,CKB9,CKB10,CKB11,CKB13,CKB16,CKB23;
constructors WELLORD1,NAT_1,REALSET1,ORDERS_3,WAYBEL_1,WAYBEL_4,LATTICE7,RELSET_1,CKB6,CKB12,CKB14,CKB21,CKB22;
requirements SUBSET,BOOLE,NUMERALS;
begin
theorem
Lm2: (for L being non  empty Poset holds (for R being  auxiliary(i)  auxiliary(ii) (Relation of L) holds (for C being non  empty (strict_chain of R) holds (for X being (Subset of C) holds ((( ex_sup_of X,L & C is  maximal) & (not ( "\/" (X,L) ) in C)) implies (ex cs being (Element of L) st (((cs in C & ( "\/" (X,L) ) < cs) & (not [ ( "\/" (X,L) ),cs ] in R)) & (ex cs1 being (Element of ( subrelstr C )) st ((cs = cs1 & X is_<=_than cs1) & (for a being (Element of ( subrelstr C )) holds (X is_<=_than a implies cs1 <= a)))))))))))
proof
let L being non  empty Poset;
let R being  auxiliary(i)  auxiliary(ii) (Relation of L);
let C being non  empty (strict_chain of R);
let X being (Subset of C);
assume that
A1:  ex_sup_of X,L
and
A2: C is  maximal;
set s = ( "\/" (X,L) );
A3: C c= ( C \/ { s } ) by XBOOLE_1:7;
assume A4: (not s in C);
then (not ( C \/ { s } ) c= C) by ZFMISC_1:39;
then A5: (not ( C \/ { s } ) is (strict_chain of R)) by A3,A2,CKB21:def 1;
(ex cs being (Element of L) st ((cs in C & s < cs) & (not [ s,cs ] in R)))
proof
A6: (for a being (Element of L) holds (((a in C & (not [ a,s ] in R)) & (not [ s,a ] in R)) implies (ex cs being (Element of L) st ((cs in C & s < cs) & (not [ s,cs ] in R)))))
proof
let a being (Element of L);
assume that
A7: a in C
and
A8: (not [ a,s ] in R)
and
A9: (not [ s,a ] in R);
take a;
thus a in C by A7;
a is_>=_than X
proof
let x being (Element of L);
assume A10: x in X;
per cases  by A7,A10,CKB14:def 1;
suppose A11: [ a,x ] in R;

A12: a <= a;
x <= s by A1,A10,YELLOW_4:1;
hence x <= a by A12,A8,A11,WAYBEL_4:def 4;
end;
suppose ([ x,a ] in R or a = x);

hence x <= a by WAYBEL_4:def 3;
end;
end;
then s <= a by A1,YELLOW_0:def 9;
hence s < a by A4,A7,ORDERS_2:def 6;
thus thesis by A9;
end;
consider a,b being set such that A13: a in ( C \/ { s } ) and A14: b in ( C \/ { s } ) and A15: (not [ a,b ] in R) and A16: a <> b and A17: (not [ b,a ] in R) by A5,CKB14:def 1;
reconsider a,b as (Element of L) by A13,A14;
per cases  by A13,A14,CKB1:1;
suppose (a in C & b in C);

hence thesis by A15,A16,A17,CKB14:def 1;
end;
suppose (a in C & b = s);

hence thesis by A15,A17,A6;
end;
suppose (a = s & b in C);

hence thesis by A15,A17,A6;
end;
suppose (a = s & b = s);

hence thesis by A16;
end;
end;
then consider cs being (Element of L) such that A18: cs in C and A19: s < cs and A20: (not [ s,cs ] in R);
take cs;
thus ((cs in C & s < cs) & (not [ s,cs ] in R)) by A18,A19,A20;
reconsider cs1 = cs as (Element of ( subrelstr C )) by A18,YELLOW_0:def 15;
take cs1;
thus cs = cs1;
A21: s <= cs by A19,ORDERS_2:def 6;
thus X is_<=_than cs1
proof
let b being (Element of ( subrelstr C ));
reconsider b0 = b as (Element of L) by YELLOW_0:58;
assume b in X;
then b0 <= s by A1,YELLOW_4:1;
then b0 <= cs by A21,ORDERS_2:3;
hence b <= cs1 by YELLOW_0:60;
end;

let a being (Element of ( subrelstr C ));
reconsider a0 = a as (Element of L) by YELLOW_0:58;
A22: (the carrier of ( subrelstr C )) = C by YELLOW_0:def 15;
assume X is_<=_than a;
then X is_<=_than a0 by A22,YELLOW_0:62;
then A23: s <= a0 by A1,YELLOW_0:def 9;
A24: cs <= cs;
(([ cs1,a ] in R or a = cs1) or [ a,cs1 ] in R) by A22,CKB14:def 1;
then cs <= a0 by A20,A23,A24,WAYBEL_4:def 3,WAYBEL_4:def 4;
hence thesis by YELLOW_0:60;
end;
