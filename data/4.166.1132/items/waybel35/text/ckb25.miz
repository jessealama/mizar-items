environ
vocabularies XBOOLE_0,ZFMISC_1,SUBSET_1,STRUCT_0,ORDERS_2,WAYBEL_4,RELAT_1,RELAT_2,LATTICE3,LATTICES,FUNCT_1,YELLOW_1,LATTICE7,WAYBEL_0,SEQM_3,XXREAL_0,TARSKI,ARYTM_3,GROUP_4,ORDERS_1,WELLORD2,WELLORD1,YELLOW_0,EQREL_1,REWRITE1,WAYBEL_1,ORDINAL2,NUMBERS,CARD_1,NAT_1,WAYBEL35;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,NAT_1,RELAT_1,RELAT_2,FUNCT_1,RELSET_1,FUNCT_2,DOMAIN_1,STRUCT_0,WELLORD1,ORDERS_2,ORDERS_1,LATTICE3,YELLOW_0,YELLOW_1,ALG_1,WAYBEL_0,WAYBEL_1,WAYBEL_4,LATTICE7,CKB6,CKB12,CKB14,CKB21,CKB22,CKB24;
definitions TARSKI,XBOOLE_0,ORDERS_1,LATTICE3,WAYBEL_1,CKB6,CKB12,CKB14,CKB21,CKB22;
theorems WAYBEL_4,YELLOW_8,FUNCT_2,YELLOW_1,TARSKI,ORDERS_2,YELLOW_0,LATTICE3,YELLOW_4,WAYBEL_0,XBOOLE_0,LATTICE7,WAYBEL_1,XBOOLE_1,RELAT_1,WELLORD2,ORDERS_1,RELAT_2,ZFMISC_1,FUNCT_1,ORDINAL1,SUBSET_1,CKB1,CKB6,CKB12,CKB14,CKB15,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22;
schemes XBOOLE_0,FUNCT_2,RECDEF_1,NAT_1;
registrations SUBSET_1,ORDINAL1,RELSET_1,REALSET1,STRUCT_0,LATTICE3,YELLOW_0,WAYBEL_0,YELLOW_1,YELLOW_2,WAYBEL_4,FUNCT_1,ZFMISC_1,CARD_1,CKB2,CKB3,CKB4,CKB5,CKB7,CKB8,CKB9,CKB10,CKB11,CKB13,CKB16,CKB23;
constructors WELLORD1,NAT_1,REALSET1,ORDERS_3,WAYBEL_1,WAYBEL_4,LATTICE7,RELSET_1,CKB6,CKB12,CKB14,CKB21,CKB22;
requirements SUBSET,BOOLE,NUMERALS;
begin
theorem
(for L being 1-sorted holds (for R being (Relation of (the carrier of L)) holds (for C being (strict_chain of R) holds (( Strict_Chains (R,C) ) is_inductive_wrt ( RelIncl ( Strict_Chains (R,C) ) ) & (ex D being set st (D is_maximal_in ( RelIncl ( Strict_Chains (R,C) ) ) & C c= D))))))
proof
let L being 1-sorted;
let R being (Relation of (the carrier of L));
let C being (strict_chain of R);
set X = ( Strict_Chains (R,C) );
A1: ( field ( RelIncl X ) ) = X by WELLORD2:def 1;
thus A2: X is_inductive_wrt ( RelIncl X )
proof
let Y being set;
assume that
A3: Y c= X
and
A4: ( ( RelIncl X ) |_2 Y ) is  being_linear-order;
per cases ;
suppose A5: Y is  empty;

take C;
thus thesis by A5,CKB22:def 1;
end;
suppose A6: Y is non  empty;

take Z = ( union Y );
Z c= (the carrier of L)
proof
let z being set;
assume z in Z;
then consider A being set such that A7: z in A and A8: A in Y by TARSKI:def 4;
A is (strict_chain of R) by A3,A8,CKB22:def 1;
hence thesis by A7;
end;
then reconsider S = Z as (Subset of L);
A9: S is (strict_chain of R)
proof
( ( RelIncl X ) |_2 Y ) is  connected by A4,ORDERS_1:def 5;
then A10: ( ( RelIncl X ) |_2 Y ) is_connected_in ( field ( ( RelIncl X ) |_2 Y ) ) by RELAT_2:def 14;
A11: ( ( RelIncl X ) |_2 Y ) = ( RelIncl Y ) by A3,WELLORD2:7;
let x being set;
let y being set;
A12: ( field ( RelIncl Y ) ) = Y by WELLORD2:def 1;
assume x in S;
then consider A being set such that A13: x in A and A14: A in Y by TARSKI:def 4;
A15: A is (strict_chain of R) by A3,A14,CKB22:def 1;
assume y in S;
then consider B being set such that A16: y in B and A17: B in Y by TARSKI:def 4;
A18: B is (strict_chain of R) by A3,A17,CKB22:def 1;
per cases ;
suppose A <> B;

then ([ A,B ] in ( RelIncl Y ) or [ B,A ] in ( RelIncl Y )) by A14,A17,A10,A11,A12,RELAT_2:def 6;
then (A c= B or B c= A) by A14,A17,WELLORD2:def 1;
hence thesis by A13,A16,A15,A18,CKB14:def 1;
end;
suppose A = B;

hence thesis by A13,A16,A15,CKB14:def 1;
end;
end;
C c= Z
proof
let c being set;
assume A19: c in C;
consider y being set such that A20: y in Y by A6,XBOOLE_0:def 1;
C c= y by A3,A20,CKB22:def 1;
hence thesis by A19,A20,TARSKI:def 4;
end;
hence A21: Z in X by A9,CKB22:def 1;
let y being set;
assume A22: y in Y;
then y c= Z by ZFMISC_1:74;
hence thesis by A3,A21,A22,WELLORD2:def 1;
end;
end;

A23: ( RelIncl X ) is_transitive_in X by WELLORD2:20;
A24: ( RelIncl X ) is_antisymmetric_in X by WELLORD2:21;
( RelIncl X ) is_reflexive_in X by WELLORD2:19;
then ( RelIncl X ) partially_orders X by A23,A24,ORDERS_1:def 7;
then consider D being set such that A25: D is_maximal_in ( RelIncl X ) by A1,A2,ORDERS_1:63;
take D;
thus D is_maximal_in ( RelIncl X ) by A25;
D in ( field ( RelIncl X ) ) by A25,ORDERS_1:def 11;
hence thesis by A1,CKB22:def 1;
end;
