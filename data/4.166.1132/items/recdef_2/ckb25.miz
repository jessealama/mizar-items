environ
vocabularies NUMBERS,ZFMISC_1,XBOOLE_0,SUBSET_1,FUNCT_1,RELAT_1,FUNCT_4,TARSKI,CARD_1,ARYTM_3,MCART_1,NAT_1,ARYTM_1,XXREAL_0,FUNCT_7,RECDEF_2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,MCART_1,MCART_2,DOMAIN_1,NUMBERS,XCMPLX_0,NAT_1,NAT_D,RELAT_1,FUNCT_1,FUNCT_2,FUNCT_4,FUNCT_7,XXREAL_0,CKB1,CKB2,CKB3,CKB7,CKB8,CKB9,CKB10,CKB14,CKB15,CKB16,CKB17,CKB18;
definitions TARSKI,XBOOLE_0,CKB1,CKB2,CKB3,CKB7,CKB8,CKB9,CKB10,CKB14,CKB15,CKB16,CKB17,CKB18;
theorems MCART_1,NAT_1,FUNCT_1,FUNCT_2,RELSET_1,INT_1,FUNCT_4,XBOOLE_0,XBOOLE_1,DOMAIN_1,MCART_2,FUNCT_7,XREAL_1,XXREAL_0,XREAL_0,NAT_D,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21;
schemes NAT_1,RECDEF_1,FUNCT_1,XBOOLE_0,PARTFUN1,CKB22,CKB23,CKB24;
registrations SUBSET_1,ORDINAL1,RELSET_1,XREAL_0,NAT_1,INT_1;
constructors DOMAIN_1,FUNCT_4,XXREAL_0,NAT_1,INT_1,MCART_2,BINARITH,FUNCT_7,NAT_D,RELSET_1,CKB1,CKB2,CKB3,CKB7,CKB8,CKB9,CKB10,CKB14,CKB15,CKB16,CKB17,CKB18;
requirements BOOLE,SUBSET,NUMERALS,ARITHM,REAL;
begin
scheme LambdaRec2Ex { A,B() -> set,F(set,set,set) -> set } : (ex f being Function st (((( dom f ) = ( NAT ) & ( f . ( 0 ) ) = A()) & ( f . 1 ) = B()) & (for n being (Element of ( NAT )) holds ( f . ( n + 2 ) ) = F(n,( f . n ),( f . ( n + 1 ) )))))
proof
defpred C[ set ]
 means
$1 = ( 0 );
deffunc G(Nat,set) = [ ( $2 `2_3 ),( $2 `3_3 ),F(( $1 + 1 ),( $2 `2_3 ),( $2 `3_3 )) ];
set r03 = F(( 0 ),A(),B());
set r13 = F(1,B(),r03);
deffunc H(Nat,set) = G(( $1 + 1 ),$2);
consider h being Function such that ( dom h ) = ( NAT ) and A1: ( h . ( 0 ) ) = [ B(),r03,r13 ] and A2: (for n being Nat holds ( h . ( n + 1 ) ) = H(n,( h . n ))) from NAT_1:sch 11;
deffunc Y((Element of ( NAT ))) = ( h . ( $1 -' 1 ) );
deffunc X(set) = [ A(),B(),r03 ];
consider g being Function such that ( dom g ) = ( NAT ) and A3: (for x being (Element of ( NAT )) holds ((C[ x ] implies ( g . x ) = X(x)) & ((not C[ x ]) implies ( g . x ) = Y(x)))) from PARTFUN1:sch 4;
deffunc M(set) = ( ( g . $1 ) `1_3 );
consider f being Function such that A4: ( dom f ) = ( NAT ) and A5: (for x being set holds (x in ( NAT ) implies ( f . x ) = M(x))) from FUNCT_1:sch 3;
defpred P[ (Element of ( NAT )) ]
 means
(((((( f . ( $1 + 2 ) ) = ( ( g . ( $1 + 1 ) ) `2_3 ) & ( ( g . ( $1 + 1 ) ) `1_3 ) = ( ( g . $1 ) `2_3 )) & ( ( g . ( $1 + 2 ) ) `1_3 ) = ( ( g . $1 ) `3_3 )) & ( ( g . ( $1 + 2 ) ) `1_3 ) = ( ( g . ( $1 + 1 ) ) `2_3 )) & ( ( g . ( $1 + 2 ) ) `2_3 ) = ( ( g . ( $1 + 1 ) ) `3_3 )) & ( f . ( $1 + 2 ) ) = F($1,( f . $1 ),( f . ( $1 + 1 ) )));
A6: ( g . ( 0 ) ) = [ A(),B(),r03 ] by A3;
A7: (for n being (Element of ( NAT )) holds ( g . ( n + 2 ) ) = G(( n + 1 ),( g . ( n + 1 ) )))
proof
let n being (Element of ( NAT ));
A8: (( ( n + 2 ) - 1 ) = ( n + ( 2 - 1 ) ) & ( 0 ) <= ( n + 1 )) by NAT_1:2;
A9: ( g . ( n + 1 ) ) = Y(( n + 1 )) by A3
.= ( h . n ) by NAT_D:34;
thus ( g . ( n + 2 ) ) = Y(( n + 2 )) by A3
.= ( h . ( n + 1 ) ) by A8,XREAL_0:def 2
.= G(( n + 1 ),( g . ( n + 1 ) )) by A2,A9;
end;
then A10: ( ( g . ( ( 0 ) + 2 ) ) `2_3 ) = ( G(( ( 0 ) + 1 ),( g . ( ( 0 ) + 1 ) )) `2_3 )
.= ( ( g . ( ( 0 ) + 1 ) ) `3_3 ) by CKB2:def 1;
take f;
thus ( dom f ) = ( NAT ) by A4;
thus A11: ( f . ( 0 ) ) = ( ( g . ( 0 ) ) `1_3 ) by A5
.= A() by A6,CKB1:def 1;
A12: ( g . 1 ) = Y(1) by A3
.= [ B(),r03,r13 ] by A1,XREAL_1:232;
then A13: ( ( g . ( ( 0 ) + 1 ) ) `1_3 ) = B() by CKB1:def 1
.= ( ( g . ( 0 ) ) `2_3 ) by A6,CKB2:def 1;
A14: (for x being (Element of ( NAT )) holds (P[ x ] implies P[ ( x + 1 ) ]))
proof
let x being (Element of ( NAT ));
assume A15: P[ x ];
then A16: ( f . ( x + 1 ) ) = ( ( g . x ) `2_3 ) by A5;
thus A17: ( f . ( ( x + 1 ) + 2 ) ) = ( ( g . ( ( x + 1 ) + 2 ) ) `1_3 ) by A5
.= ( G(( ( x + 1 ) + 1 ),( g . ( ( x + 1 ) + 1 ) )) `1_3 ) by A7
.= ( ( g . ( ( x + 1 ) + 1 ) ) `2_3 ) by CKB1:def 1;
thus ( ( g . ( ( x + 1 ) + 1 ) ) `1_3 ) = ( ( g . ( x + 1 ) ) `2_3 ) by A15;
thus ( ( g . ( ( x + 1 ) + 2 ) ) `1_3 ) = ( G(( ( x + 1 ) + 1 ),( g . ( ( x + 1 ) + 1 ) )) `1_3 ) by A7
.= ( ( g . ( x + 1 ) ) `3_3 ) by A15,CKB1:def 1;
hence ( ( g . ( ( x + 1 ) + 2 ) ) `1_3 ) = ( ( g . ( ( x + 1 ) + 1 ) ) `2_3 ) by A15;
thus ( ( g . ( ( x + 1 ) + 2 ) ) `2_3 ) = ( G(( ( x + 1 ) + 1 ),( g . ( ( x + 1 ) + 1 ) )) `2_3 ) by A7
.= ( ( g . ( ( x + 1 ) + 1 ) ) `3_3 ) by CKB2:def 1;
per cases ;
suppose A18: x = ( 0 );

hence ( f . ( ( x + 1 ) + 2 ) ) = ( ( g . ( 1 + 2 ) ) `1_3 ) by A5
.= ( G(( 1 + 1 ),( g . ( 1 + 1 ) )) `1_3 ) by A7
.= ( ( g . ( ( 0 ) + 1 ) ) `3_3 ) by A15,A18,CKB1:def 1
.= r13 by A12,CKB3:def 1
.= F(( ( 0 ) + 1 ),B(),( ( g . ( 0 ) ) `3_3 )) by A6,CKB3:def 1
.= F(( x + 1 ),( f . ( x + 1 ) ),( f . ( ( x + 1 ) + 1 ) )) by A6,A15,A16,A18,CKB2:def 1;
end;
suppose x <> ( 0 );

then ( 0 ) < x by NAT_1:3;
then A19: ( ( 0 ) + 1 ) <= x by NAT_1:13;
then A20: ( ( x -' 1 ) + 1 ) = x by XREAL_1:235;
( 1 - 1 ) <= ( x - 1 ) by A19,XREAL_1:13;
then A21: ( x - 1 ) = ( x -' 1 ) by XREAL_0:def 2;
( x + 1 ) = ( ( x - 1 ) + 2 );
hence ( f . ( ( x + 1 ) + 2 ) ) = ( G(( ( x -' 1 ) + 1 ),( g . ( ( x -' 1 ) + 1 ) )) `3_3 ) by A7,A15,A17,A21
.= F(( x + 1 ),( f . ( x + 1 ) ),( f . ( ( x + 1 ) + 1 ) )) by A15,A16,A20,CKB3:def 1;
end;
end;
A22: ( f . ( ( 0 ) + 2 ) ) = ( ( g . ( ( 0 ) + 2 ) ) `1_3 ) by A5
.= ( G(( ( 0 ) + 1 ),( g . ( ( 0 ) + 1 ) )) `1_3 ) by A7
.= ( ( g . ( ( 0 ) + 1 ) ) `2_3 ) by CKB1:def 1;
thus A23: ( f . 1 ) = ( ( g . 1 ) `1_3 ) by A5
.= B() by A12,CKB1:def 1;
A24: ( ( g . ( ( 0 ) + 2 ) ) `1_3 ) = ( G(( ( 0 ) + 1 ),( g . ( ( 0 ) + 1 ) )) `1_3 ) by A7
.= ( ( g . 1 ) `2_3 ) by CKB1:def 1
.= r03 by A12,CKB2:def 1
.= ( ( g . ( 0 ) ) `3_3 ) by A6,CKB3:def 1;
then ( ( g . ( ( 0 ) + 2 ) ) `1_3 ) = r03 by A6,CKB3:def 1
.= ( ( g . ( ( 0 ) + 1 ) ) `2_3 ) by A12,CKB2:def 1;
then A25: P[ ( 0 ) ] by A12,A11,A23,A22,A13,A24,A10,CKB2:def 1;
(for x being (Element of ( NAT )) holds P[ x ]) from NAT_1:sch 1(A25,A14);
hence thesis;
end;
