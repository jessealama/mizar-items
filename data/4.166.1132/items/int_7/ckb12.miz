environ
vocabularies NUMBERS,FUNCOP_1,CARD_1,FUNCT_4,FUNCT_1,RELAT_1,PBOOLE,PRE_POLY,VALUED_0,XBOOLE_0,ARYTM_3,NEWTON,TARSKI,FINSET_1,ORDINAL1,NAT_3,CARD_3,UPROOTS,FINSEQ_1,SUBSET_1,ORDINAL4,ARYTM_1,XXREAL_0,FUNCT_2,CLASSES1,PARTFUN1,INT_2,NAT_1,POWER,RVSUM_1,BINOP_1,BINOP_2,REALSET1,ZFMISC_1,INT_3,SUPINF_2,FUNCT_7,ALGSTR_0,GROUP_1,MESFUNC1,INT_1,COMPLEX1,VECTSP_1,POLYNOM1,HURWITZ,POLYNOM5,POLYNOM3,POLYNOM2,AFINSQ_1,STRUCT_0,GROUP_4,GROUP_2,GRAPH_1,INT_7;
notations TARSKI,XBOOLE_0,SUBSET_1,ZFMISC_1,ORDINAL1,FINSET_1,RVSUM_1,CARD_1,CLASSES1,DOMAIN_1,NUMBERS,XCMPLX_0,XXREAL_0,NAT_1,POWER,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,FUNCOP_1,FINSEQ_1,FUNCT_4,STRUCT_0,ALGSTR_0,VFUNCT_1,GROUP_1,VECTSP_1,BINOP_1,PBOOLE,GROUP_2,BHSP_1,ALGSEQ_1,WSIERP_1,POLYNOM3,POLYNOM4,UPROOTS,NAT_3,POLYNOM5,GROUP_4,GR_CY_1,INT_1,FUNCT_7,NEWTON,INT_2,INT_3,HURWITZ,VALUED_0,REALSET1,RECDEF_1,PRE_POLY,POLYNOM2,CKB8;
definitions STRUCT_0,GROUP_1,INT_3,CARD_1,ALGSTR_0,BINOP_1,FINSEQ_1,POLYNOM3,HURWITZ,REALSET1,TARSKI,CKB8;
theorems TARSKI,XBOOLE_0,ZFMISC_1,ORDINAL1,FUNCT_1,FUNCT_2,VECTSP_1,INT_1,RELAT_1,RLVECT_1,ABSVALUE,GR_CY_1,FUNCT_7,NAT_1,INT_2,INT_3,PEPIN,NAT_D,XCMPLX_1,NUMBERS,PYTHTRIP,WSIERP_1,CARD_1,GROUP_1,GROUP_2,STRUCT_0,WELLORD2,XREAL_1,NEWTON,XXREAL_0,GR_CY_2,POWER,VALUED_0,ALGSEQ_1,NAT_3,UPROOTS,RVSUM_1,FINSEQ_4,FINSEQ_5,POLYNOM3,POLYNOM4,POLYNOM5,CARD_2,EULER_1,EULER_2,XBOOLE_1,FINSEQ_1,HURWITZ,GROUP_8,REALSET1,RELSET_1,FUNCT_4,FUNCOP_1,CLASSES1,PARTFUN1,PRE_POLY,FINSEQ_2,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB10,CKB11;
schemes NAT_1,PRE_CIRC,FUNCT_2,RECDEF_1;
registrations XBOOLE_0,STRUCT_0,FUNCT_1,XREAL_0,ORDINAL1,NAT_1,INT_1,GROUP_1,GROUP_2,FINSET_1,FINSEQ_1,FUNCT_2,GR_CY_1,ALGSTR_0,MEMBERED,VECTSP_1,INT_3,XXREAL_0,NEWTON,SUBSET_1,RELAT_1,CARD_1,ALGSTR_1,NAT_3,VALUED_0,POLYNOM3,POLYNOM4,POLYNOM5,UPROOTS,RELSET_1,PRE_POLY,VFUNCT_1,CKB9;
constructors REAL_1,NAT_D,NAT_3,SEQ_1,PEPIN,EUCLID,REALSET1,GROUP_4,GR_CY_1,INT_3,WSIERP_1,BHSP_1,POLYNOM2,POLYNOM4,POLYNOM5,WELLORD2,POWER,ALGSTR_1,HURWITZ,UPROOTS,FUNCT_4,RECDEF_1,BINOP_2,CLASSES1,RELSET_1,PBOOLE,FUNCT_7,VFUNCT_1,CKB8;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
theorem
Lm5: (for p being (FinSequence of ( NAT )) holds (for x being (Element of ( NAT )) holds (for b being (bag of ( SetPrimes )) holds ((b is  prime-factorization-like & ( p ^ <* x *> ) = ( b * ( canFS ( support b ) ) )) implies (ex p1 being (FinSequence of ( NAT )) st (ex q being Prime st (ex n being (Element of ( NAT )) st (ex b1 being (bag of ( SetPrimes )) st (((((((( 0 ) < n & b1 is  prime-factorization-like) & q in ( support b )) & ( support b1 ) = ( ( support b ) \ { q } )) & x = ( q |^ n )) & ( len p1 ) = ( len p )) & ( Product p ) = ( Product p1 )) & p1 = ( b1 * ( canFS ( support b1 ) ) ))))))))))
proof
deffunc G(set) = ( 0 );
let p being (FinSequence of ( NAT ));
let x being (Element of ( NAT ));
let b being (bag of ( SetPrimes ));
assume that
A1: b is  prime-factorization-like
and
A2: ( p ^ <* x *> ) = ( b * ( canFS ( support b ) ) );
A3: ( rng ( canFS ( support b ) ) ) = ( support b ) by FUNCT_2:def 3;
( dom b ) = ( SetPrimes ) by PARTFUN1:def 2;
then A4: ( dom ( b * ( canFS ( support b ) ) ) ) = ( dom ( canFS ( support b ) ) ) by A3,RELAT_1:27;
p = ( ( b * ( canFS ( support b ) ) ) | ( dom p ) ) by A2,FINSEQ_1:21;
then ( dom p ) = ( ( dom ( b * ( canFS ( support b ) ) ) ) /\ ( dom p ) ) by RELAT_1:61;
then A5: ( dom ( ( canFS ( support b ) ) | ( dom p ) ) ) = ( dom p ) by A4,RELAT_1:62,XBOOLE_1:17;
deffunc F(set) = ( b . $1 );
A6: ( card ( support b ) ) = ( len ( canFS ( support b ) ) ) by UPROOTS:3;
( dom b ) = ( SetPrimes ) by PARTFUN1:def 2;
then A7: ( dom ( b * ( canFS ( support b ) ) ) ) = ( dom ( canFS ( support b ) ) ) by A3,RELAT_1:27;
A8: ( ( len p ) + 1 ) in ( Seg ( ( len p ) + 1 ) ) by FINSEQ_1:4;
A9: ( len <* x *> ) = 1 by FINSEQ_1:40;
then ( len ( p ^ <* x *> ) ) = ( ( len p ) + 1 ) by FINSEQ_1:22;
then A10: ( ( len p ) + 1 ) in ( dom ( b * ( canFS ( support b ) ) ) ) by A2,A8,FINSEQ_1:def 3;
A11: x = ( ( p ^ <* x *> ) . ( ( len p ) + 1 ) ) by FINSEQ_1:42
.= ( b . ( ( canFS ( support b ) ) . ( ( len p ) + 1 ) ) ) by A2,A7,A10,FUNCT_1:13;
A12: ( rng ( canFS ( support b ) ) ) = ( support b ) by FUNCT_2:def 3;
then A13: ( ( canFS ( support b ) ) . ( ( len p ) + 1 ) ) in ( support b ) by A7,A10,FUNCT_1:3;
then reconsider q = ( ( canFS ( support b ) ) . ( ( len p ) + 1 ) ) as Prime by NEWTON:def 6;
defpred P[ set ]
 means
$1 in ( ( support b ) \ { q } );
consider b1 being (ManySortedSet of ( SetPrimes )) such that A14: (for i being (Element of ( SetPrimes )) holds (i in ( SetPrimes ) implies ((P[ i ] implies ( b1 . i ) = F(i)) & ((not P[ i ]) implies ( b1 . i ) = G(i))))) from PRE_CIRC:sch 2;
A15: ( rng b1 ) c= ( NAT )
proof
let y being set;
assume y in ( rng b1 );
then consider x being set such that A16: x in ( dom b1 ) and A17: y = ( b1 . x ) by FUNCT_1:def 3;
reconsider x as (Element of ( SetPrimes )) by A16,PARTFUN1:def 2;
( b1 . x ) in ( NAT )
proof
per cases ;
suppose x in ( ( support b ) \ { q } );

then ( b1 . x ) = ( b . x ) by A14;
hence thesis;
end;
suppose (not x in ( ( support b ) \ { q } ));

then ( b1 . x ) = ( 0 ) by A14;
hence thesis;
end;
end;
hence thesis by A17;
end;
now
let z being set;
assume A18: z in ( support b1 );
z in ( dom b1 )
proof
assume (not z in ( dom b1 ));
then ( b1 . z ) = ( {} ) by FUNCT_1:def 2;
hence contradiction by A18,PRE_POLY:def 7;
end;
then reconsider y = z as (Element of ( SetPrimes )) by PARTFUN1:def 2;
assume A19: (not z in ( ( support b ) \ { q } ));
( b1 . y ) <> ( 0 ) by A18,PRE_POLY:def 7;
hence contradiction by A14,A19;
end;
then A20: ( support b1 ) c= ( ( support b ) \ { q } ) by TARSKI:def 3;
now
let z being set;
assume A21: z in ( ( support b ) \ { q } );
then A22: z in ( support b ) by XBOOLE_0:def 5;
reconsider y = z as (Element of ( SetPrimes )) by A21;
( b1 . y ) = ( b . y ) by A14,A21;
then ( b1 . y ) <> ( 0 ) by A22,PRE_POLY:def 7;
hence z in ( support b1 ) by PRE_POLY:def 7;
end;
then A23: ( ( support b ) \ { q } ) c= ( support b1 ) by TARSKI:def 3;
then A24: ( support b1 ) = ( ( support b ) \ { q } ) by A20,XBOOLE_0:def 10;
reconsider b1 as (bag of ( SetPrimes )) by A20,A15,PRE_POLY:def 8,VALUED_0:def 6;
consider n being  natural number such that A25: ( 0 ) < n and A26: ( b . q ) = ( q |^ n ) by A1,A13,CKB8:def 1;
reconsider n as (Element of ( NAT )) by ORDINAL1:def 12;
A27: ( rng ( canFS ( support b ) ) ) = ( support b ) by FUNCT_2:def 3;
( SetPrimes ) = ( dom b ) by PARTFUN1:def 2;
then ( card ( dom ( b * ( canFS ( support b ) ) ) ) ) = ( card ( dom ( canFS ( support b ) ) ) ) by A27,RELAT_1:27
.= ( card ( Seg ( len ( canFS ( support b ) ) ) ) ) by FINSEQ_1:def 3
.= ( card ( len ( canFS ( support b ) ) ) ) by FINSEQ_1:55
.= ( len ( canFS ( support b ) ) );
then A28: ( len ( canFS ( support b ) ) ) = ( card ( Seg ( len ( p ^ <* x *> ) ) ) ) by A2,FINSEQ_1:def 3
.= ( card ( len ( p ^ <* x *> ) ) ) by FINSEQ_1:55
.= ( ( len p ) + 1 ) by A9,FINSEQ_1:22;
( card ( ( support b ) \ { q } ) ) = ( ( card ( support b ) ) - ( card { q } ) ) by A7,A12,A10,EULER_1:4,FUNCT_1:3
.= ( ( card ( support b ) ) - 1 ) by CARD_1:30;
then A29: ( len ( canFS ( support b1 ) ) ) = ( len p ) by A24,A28,A6,UPROOTS:3;
then A30: ( dom ( canFS ( support b1 ) ) ) = ( Seg ( len p ) ) by FINSEQ_1:def 3;
then A31: ( dom ( canFS ( support b1 ) ) ) = ( dom p ) by FINSEQ_1:def 3;
A32:now
let x being Prime;
assume A33: x in ( support b1 );
( ( support b ) \ { q } ) c= ( support b ) by XBOOLE_1:36;
then consider m being  natural number such that A34: ( 0 ) < m and A35: ( b . x ) = ( x |^ m ) by A1,A24,A33,CKB8:def 1;
take m;
thus ( 0 ) < m by A34;
thus ( b1 . x ) = ( x |^ m ) by A14,A20,A33,A35;
end;
per cases ;
suppose A36: ( dom p ) = ( {} );

set p1 = ( b1 * ( canFS ( support b1 ) ) );
A37: p = ( {} ) by A36;
( Seg ( len ( canFS ( support b1 ) ) ) ) = ( dom ( canFS ( support b1 ) ) ) by FINSEQ_1:def 3
.= ( Seg ( len p ) ) by A29,FINSEQ_1:def 3
.= ( Seg ( 0 ) ) by A37;
then ( canFS ( support b1 ) ) = ( {} );
then A38: p1 = ( <*> ( NAT ) );
then reconsider p1 as (FinSequence of ( NAT ));
take p1;
take q;
take n;
take b1;
thus thesis by A7,A12,A10,A11,A25,A26,A20,A23,A32,A36,A38,CKB8:def 1,FUNCT_1:3,RELAT_1:41,XBOOLE_0:def 10;
end;
suppose A39: ( dom p ) <> ( {} );

A40: ( rng ( canFS ( support b ) ) ) = ( support b ) by FUNCT_2:def 3;
now
let y being set;
assume A41: y in ( ( support b ) \ { q } );
then y in ( rng ( canFS ( support b ) ) ) by A40,XBOOLE_0:def 5;
then consider x being set such that A42: x in ( dom ( canFS ( support b ) ) ) and A43: y = ( ( canFS ( support b ) ) . x ) by FUNCT_1:def 3;
A44: x in ( dom p )
proof
assume (not x in ( dom p ));
then A45: (not x in ( Seg ( len p ) )) by FINSEQ_1:def 3;
A46: x in ( Seg ( ( len p ) + 1 ) ) by A28,A42,FINSEQ_1:def 3;
reconsider x as (Element of ( NAT )) by A42;
1 <= x by A46,FINSEQ_1:1;
then ( len p ) < x by A45;
then A47: ( ( len p ) + 1 ) <= x by NAT_1:13;
x <= ( ( len p ) + 1 ) by A46,FINSEQ_1:1;
then x = ( ( len p ) + 1 ) by A47,XXREAL_0:1;
then y in { q } by A43,TARSKI:def 1;
hence contradiction by A41,XBOOLE_0:def 5;
end;
then x in ( ( dom ( canFS ( support b ) ) ) /\ ( dom p ) ) by A42,XBOOLE_0:def 4;
then A48: x in ( dom ( ( canFS ( support b ) ) | ( dom p ) ) ) by RELAT_1:61;
y = ( ( ( canFS ( support b ) ) | ( dom p ) ) . x ) by A43,A44,FUNCT_1:49;
hence y in ( rng ( ( canFS ( support b ) ) | ( dom p ) ) ) by A48,FUNCT_1:3;
end;
then A49: ( ( support b ) \ { q } ) c= ( rng ( ( canFS ( support b ) ) | ( dom p ) ) ) by TARSKI:def 3;
now
let y being set;
assume y in ( rng ( ( canFS ( support b ) ) | ( dom p ) ) );
then consider x being set such that A50: x in ( dom ( ( canFS ( support b ) ) | ( dom p ) ) ) and A51: y = ( ( ( canFS ( support b ) ) | ( dom p ) ) . x ) by FUNCT_1:def 3;
A52: y = ( ( canFS ( support b ) ) . x ) by A50,A51,FUNCT_1:47;
A53: x in ( ( dom ( canFS ( support b ) ) ) /\ ( dom p ) ) by A50,RELAT_1:61;
then A54: x in ( dom ( canFS ( support b ) ) ) by XBOOLE_0:def 4;
A55: x in ( dom p ) by A53,XBOOLE_0:def 4;
y <> q
proof
( ( len p ) + 1 ) in ( Seg ( ( len p ) + 1 ) ) by FINSEQ_1:4;
then A56: ( ( len p ) + 1 ) in ( dom ( canFS ( support b ) ) ) by A28,FINSEQ_1:def 3;
assume y = q;
then ( ( len p ) + 1 ) = x by A52,A54,A56,FUNCT_1:def 4;
then A57: ( ( len p ) + 1 ) in ( Seg ( len p ) ) by A55,FINSEQ_1:def 3;
( ( len p ) + ( 0 ) ) < ( 1 + ( len p ) ) by XREAL_1:8;
hence contradiction by A57,FINSEQ_1:1;
end;
then A58: (not y in { q }) by TARSKI:def 1;
y in ( rng ( canFS ( support b ) ) ) by A52,A54,FUNCT_1:3;
hence y in ( ( support b ) \ { q } ) by A58,XBOOLE_0:def 5;
end;
then ( rng ( ( canFS ( support b ) ) | ( dom p ) ) ) c= ( ( support b ) \ { q } ) by TARSKI:def 3;
then A59: ( rng ( ( canFS ( support b ) ) | ( dom p ) ) ) = ( ( support b ) \ { q } ) by A49,XBOOLE_0:def 10;
then reconsider L0 = ( ( canFS ( support b ) ) | ( dom p ) ) as (Function of ( dom p ),( ( support b ) \ { q } )) by A5,FUNCT_2:1;
A60: L0 is  one-to-one by FUNCT_1:52;
then A61: ( dom ( L0 " ) ) = ( ( support b ) \ { q } ) by A59,FUNCT_1:33;
A62: ( ( support b ) \ { q } ) <> ( {} ) by A20,A30,A39,FINSEQ_1:def 3;
then ( dom L0 ) = ( dom p ) by FUNCT_2:def 1;
then A63: ( rng ( L0 " ) ) = ( dom p ) by A60,FUNCT_1:33;
then reconsider LL1 = ( L0 " ) as (Function of ( ( support b ) \ { q } ),( dom p )) by A61,FUNCT_2:1;
A64: ( rng ( canFS ( support b1 ) ) ) = ( support b1 ) by FUNCT_2:def 3;
then ( canFS ( support b1 ) ) is (Function of ( dom p ),( ( support b ) \ { q } )) by A24,A31,FUNCT_2:1;
then reconsider L0L = ( LL1 * ( canFS ( support b1 ) ) ) as (Function of ( dom p ),( dom p )) by A62,FUNCT_2:13;
A65: L0 is  one-to-one by FUNCT_1:52;
( rng L0L ) = ( dom p ) by A23,A61,A63,A64,RELAT_1:28;
then L0L is  onto by FUNCT_2:def 3;
then reconsider LL = L0L as (Permutation of ( dom p )) by A65;
( ( ( canFS ( support b ) ) | ( dom p ) ) * LL ) = ( ( ( ( canFS ( support b ) ) | ( dom p ) ) * LL1 ) * ( canFS ( support b1 ) ) ) by RELAT_1:36
.= ( ( id ( support b1 ) ) * ( canFS ( support b1 ) ) ) by A24,A62,A59,A65,FUNCT_2:29
.= ( canFS ( support b1 ) ) by FUNCT_2:17;
then A66: ( ( canFS ( support b1 ) ) * ( LL " ) ) = ( ( ( canFS ( support b ) ) | ( dom p ) ) * ( LL * ( LL " ) ) ) by RELAT_1:36;
reconsider FS = ( canFS ( support b1 ) ) as FinSequence;
reconsider L = ( LL " ) as (Permutation of ( dom p ));
A67: ( rng L ) = ( dom FS ) by A31,FUNCT_2:def 3;
then A68: ( dom ( FS * L ) ) = ( dom L ) by RELAT_1:27
.= ( dom p ) by A39,FUNCT_2:def 1;
set p1 = ( b1 * FS );
A69: ( rng ( canFS ( support b1 ) ) ) = ( support b1 ) by FUNCT_2:def 3;
( SetPrimes ) = ( dom b1 ) by PARTFUN1:def 2;
then A70: ( dom ( b1 * FS ) ) = ( dom p ) by A31,A69,RELAT_1:27;
then ( dom p1 ) = ( Seg ( len p ) ) by FINSEQ_1:def 3;
then A71: p1 is FinSequence by FINSEQ_1:def 2;
A72: ( rng ( FS * L ) ) = ( rng FS ) by A67,RELAT_1:28
.= ( ( support b ) \ { q } ) by A24,FUNCT_2:def 3;
( SetPrimes ) = ( dom b1 ) by PARTFUN1:def 2;
then A73: ( dom p ) = ( dom ( b1 * ( FS * L ) ) ) by A68,A72,RELAT_1:27;
( rng LL ) = ( dom p ) by FUNCT_2:def 3;
then A74: ( ( canFS ( support b1 ) ) * ( LL " ) ) = ( ( ( canFS ( support b ) ) | ( dom p ) ) * ( id ( dom p ) ) ) by A39,A66,FUNCT_2:29;
now
let k being set;
A75: ( dom p ) c= ( dom ( p ^ <* x *> ) ) by FINSEQ_1:26;
assume A76: k in ( dom p );
then A77: ( ( FS * L ) . k ) in ( ( support b ) \ { q } ) by A68,A72,FUNCT_1:3;
thus ( p . k ) = ( ( p ^ <* x *> ) . k ) by A76,FINSEQ_1:def 7
.= ( b . ( ( canFS ( support b ) ) . k ) ) by A2,A76,A75,FUNCT_1:12
.= ( b . ( ( ( canFS ( support b ) ) | ( dom p ) ) . k ) ) by A76,FUNCT_1:49
.= ( b . ( ( FS * L ) . k ) ) by A74,FUNCT_2:17
.= ( b1 . ( ( FS * L ) . k ) ) by A14,A77
.= ( ( b1 * ( FS * L ) ) . k ) by A73,A76,FUNCT_1:12;
end;
then p = ( b1 * ( FS * L ) ) by A73,FUNCT_1:2
.= ( p1 * L ) by RELAT_1:36;
then A78: p,p1 are_fiberwise_equipotent  by A70,CLASSES1:80;
( rng p1 ) c= ( NAT ) by VALUED_0:def 6;
then reconsider p1 as (FinSequence of ( NAT )) by A71,FINSEQ_1:def 4;
take p1;
take q;
take n;
take b1;
( Seg ( len p1 ) ) = ( dom p ) by A70,FINSEQ_1:def 3;
hence thesis by A7,A12,A10,A11,A25,A26,A20,A23,A32,A78,CKB8:def 1,EULER_2:10,FINSEQ_1:def 3,FUNCT_1:3,XBOOLE_0:def 10;
end;
end;
