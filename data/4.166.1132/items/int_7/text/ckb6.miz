environ
vocabularies NUMBERS,FUNCOP_1,CARD_1,FUNCT_4,FUNCT_1,RELAT_1,PBOOLE,PRE_POLY,VALUED_0,XBOOLE_0,ARYTM_3,NEWTON,TARSKI,FINSET_1,ORDINAL1,NAT_3,CARD_3,UPROOTS,FINSEQ_1,SUBSET_1,ORDINAL4,ARYTM_1,XXREAL_0,FUNCT_2,CLASSES1,PARTFUN1,INT_2,NAT_1,POWER,RVSUM_1,BINOP_1,BINOP_2,REALSET1,ZFMISC_1,INT_3,SUPINF_2,FUNCT_7,ALGSTR_0,GROUP_1,MESFUNC1,INT_1,COMPLEX1,VECTSP_1,POLYNOM1,HURWITZ,POLYNOM5,POLYNOM3,POLYNOM2,AFINSQ_1,STRUCT_0,GROUP_4,GROUP_2,GRAPH_1,INT_7;
notations TARSKI,XBOOLE_0,SUBSET_1,ZFMISC_1,ORDINAL1,FINSET_1,RVSUM_1,CARD_1,CLASSES1,DOMAIN_1,NUMBERS,XCMPLX_0,XXREAL_0,NAT_1,POWER,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,FUNCOP_1,FINSEQ_1,FUNCT_4,STRUCT_0,ALGSTR_0,VFUNCT_1,GROUP_1,VECTSP_1,BINOP_1,PBOOLE,GROUP_2,BHSP_1,ALGSEQ_1,WSIERP_1,POLYNOM3,POLYNOM4,UPROOTS,NAT_3,POLYNOM5,GROUP_4,GR_CY_1,INT_1,FUNCT_7,NEWTON,INT_2,INT_3,HURWITZ,VALUED_0,REALSET1,RECDEF_1,PRE_POLY,POLYNOM2;
definitions STRUCT_0,GROUP_1,INT_3,CARD_1,ALGSTR_0,BINOP_1,FINSEQ_1,POLYNOM3,HURWITZ,REALSET1,TARSKI;
theorems TARSKI,XBOOLE_0,ZFMISC_1,ORDINAL1,FUNCT_1,FUNCT_2,VECTSP_1,INT_1,RELAT_1,RLVECT_1,ABSVALUE,GR_CY_1,FUNCT_7,NAT_1,INT_2,INT_3,PEPIN,NAT_D,XCMPLX_1,NUMBERS,PYTHTRIP,WSIERP_1,CARD_1,GROUP_1,GROUP_2,STRUCT_0,WELLORD2,XREAL_1,NEWTON,XXREAL_0,GR_CY_2,POWER,VALUED_0,ALGSEQ_1,NAT_3,UPROOTS,RVSUM_1,FINSEQ_4,FINSEQ_5,POLYNOM3,POLYNOM4,POLYNOM5,CARD_2,EULER_1,EULER_2,XBOOLE_1,FINSEQ_1,HURWITZ,GROUP_8,REALSET1,RELSET_1,FUNCT_4,FUNCOP_1,CLASSES1,PARTFUN1,PRE_POLY,FINSEQ_2,CKB1,CKB2,CKB3,CKB4,CKB5;
schemes NAT_1,PRE_CIRC,FUNCT_2,RECDEF_1;
registrations XBOOLE_0,STRUCT_0,FUNCT_1,XREAL_0,ORDINAL1,NAT_1,INT_1,GROUP_1,GROUP_2,FINSET_1,FINSEQ_1,FUNCT_2,GR_CY_1,ALGSTR_0,MEMBERED,VECTSP_1,INT_3,XXREAL_0,NEWTON,SUBSET_1,RELAT_1,CARD_1,ALGSTR_1,NAT_3,VALUED_0,POLYNOM3,POLYNOM4,POLYNOM5,UPROOTS,RELSET_1,PRE_POLY,VFUNCT_1;
constructors REAL_1,NAT_D,NAT_3,SEQ_1,PEPIN,EUCLID,REALSET1,GROUP_4,GR_CY_1,INT_3,WSIERP_1,BHSP_1,POLYNOM2,POLYNOM4,POLYNOM5,WELLORD2,POWER,ALGSTR_1,HURWITZ,UPROOTS,FUNCT_4,RECDEF_1,BINOP_2,CLASSES1,RELSET_1,PBOOLE,FUNCT_7,VFUNCT_1;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
theorem
Lm2: (for p,q being (bag of ( SetPrimes )) holds ((( support p ) c= ( support q ) & ( p | ( support p ) ) = ( q | ( support p ) )) implies (ex r being (bag of ( SetPrimes )) st (((( support r ) = ( ( support q ) \ ( support p ) ) & ( support p ) misses ( support r )) & ( r | ( support r ) ) = ( q | ( support r ) )) & ( p + r ) = q))))
proof
deffunc G(set) = ( 0 );
let p being (bag of ( SetPrimes )),q being (bag of ( SetPrimes ));
assume that
A1: ( support p ) c= ( support q )
and
A2: ( p | ( support p ) ) = ( q | ( support p ) );
deffunc F(set) = ( q . $1 );
defpred C[ set ]
 means
$1 in ( ( support q ) \ ( support p ) );
A3: (for x being set holds (x in ( SetPrimes ) implies ((C[ x ] implies F(x) in ( NAT )) & ((not C[ x ]) implies G(x) in ( NAT )))));
consider f being (Function of ( SetPrimes ),( NAT )) such that A4: (for x being set holds (x in ( SetPrimes ) implies ((C[ x ] implies ( f . x ) = F(x)) & ((not C[ x ]) implies ( f . x ) = G(x))))) from FUNCT_2:sch 5(A3);
A5: (for x being set holds (x in ( SetPrimes ) implies (x in ( ( support q ) \ ( support p ) ) implies ( f . x ) <> ( 0 ))))
proof
let x being set;
assume that
x in ( SetPrimes )
and
A6: x in ( ( support q ) \ ( support p ) );
x in ( support q ) by A6,XBOOLE_0:def 5;
then ( q . x ) <> ( 0 ) by PRE_POLY:def 7;
hence thesis by A4,A6;
end;
A7: (for x being set holds ((not x in ( SetPrimes )) implies ( f . x ) = ( 0 )))
proof
let x being set;
assume (not x in ( SetPrimes ));
then (not x in ( dom f ));
hence thesis by FUNCT_1:def 2;
end;
A8: (for x being set holds (x in ( ( support q ) \ ( support p ) ) iff ( f . x ) <> ( 0 )))
proof
let x being set;
per cases ;
suppose x in ( SetPrimes );

hence thesis by A4,A5;
end;
suppose (not x in ( SetPrimes ));

hence thesis by A7;
end;
end;
then ( support f ) is  finite by PRE_POLY:def 7;
then reconsider r = f as (bag of ( SetPrimes )) by PRE_POLY:def 8;
A9: ( ( support p ) \/ ( support r ) ) = ( ( support p ) \/ ( ( support q ) \ ( support p ) ) ) by A8,PRE_POLY:def 7
.= ( ( support p ) \/ ( support q ) ) by XBOOLE_1:39
.= ( support q ) by A1,XBOOLE_1:12;
A10: ( dom ( f | ( support f ) ) ) = ( ( dom f ) /\ ( support f ) ) by RELAT_1:61
.= ( support f ) by PRE_POLY:37,XBOOLE_1:28;
A11: ( support f ) = ( ( support q ) \ ( support p ) ) by A8,PRE_POLY:def 7;
A12: (for x being set holds (x in ( dom ( f | ( support f ) ) ) implies ( ( f | ( support f ) ) . x ) = ( ( q | ( support f ) ) . x )))
proof
let x being set;
assume A13: x in ( dom ( f | ( support f ) ) );
then A14: ( ( q | ( support f ) ) . x ) = ( q . x ) by A10,FUNCT_1:49;
( ( f | ( support f ) ) . x ) = ( f . x ) by A10,A13,FUNCT_1:49;
hence thesis by A4,A11,A10,A13,A14;
end;
( dom ( q | ( support f ) ) ) = ( ( dom q ) /\ ( support f ) ) by RELAT_1:61
.= ( ( dom q ) /\ ( ( support q ) \ ( support p ) ) ) by A8,PRE_POLY:def 7
.= ( ( ( dom q ) /\ ( support q ) ) \ ( support p ) ) by XBOOLE_1:49
.= ( ( support q ) \ ( support p ) ) by PRE_POLY:37,XBOOLE_1:28
.= ( support f ) by A8,PRE_POLY:def 7;
then A15: ( f | ( support f ) ) = ( q | ( support f ) ) by A10,A12,FUNCT_1:def 11;
A16: ( support p ) misses ( support f )
proof
assume ( support p ) meets ( support f );
then (ex x being set st (x in ( support p ) & x in ( support f ))) by XBOOLE_0:3;
hence contradiction by A11,XBOOLE_0:def 5;
end;
then ( ( support p ) /\ ( support f ) ) = ( {} ) by XBOOLE_0:def 7;
then ( p + r ) = q by A2,A15,A9,CKB3:1;
hence thesis by A11,A16,A15;
end;
