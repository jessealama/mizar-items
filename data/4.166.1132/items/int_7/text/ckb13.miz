environ
vocabularies NUMBERS,FUNCOP_1,CARD_1,FUNCT_4,FUNCT_1,RELAT_1,PBOOLE,PRE_POLY,VALUED_0,XBOOLE_0,ARYTM_3,NEWTON,TARSKI,FINSET_1,ORDINAL1,NAT_3,CARD_3,UPROOTS,FINSEQ_1,SUBSET_1,ORDINAL4,ARYTM_1,XXREAL_0,FUNCT_2,CLASSES1,PARTFUN1,INT_2,NAT_1,POWER,RVSUM_1,BINOP_1,BINOP_2,REALSET1,ZFMISC_1,INT_3,SUPINF_2,FUNCT_7,ALGSTR_0,GROUP_1,MESFUNC1,INT_1,COMPLEX1,VECTSP_1,POLYNOM1,HURWITZ,POLYNOM5,POLYNOM3,POLYNOM2,AFINSQ_1,STRUCT_0,GROUP_4,GROUP_2,GRAPH_1,INT_7;
notations TARSKI,XBOOLE_0,SUBSET_1,ZFMISC_1,ORDINAL1,FINSET_1,RVSUM_1,CARD_1,CLASSES1,DOMAIN_1,NUMBERS,XCMPLX_0,XXREAL_0,NAT_1,POWER,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,FUNCOP_1,FINSEQ_1,FUNCT_4,STRUCT_0,ALGSTR_0,VFUNCT_1,GROUP_1,VECTSP_1,BINOP_1,PBOOLE,GROUP_2,BHSP_1,ALGSEQ_1,WSIERP_1,POLYNOM3,POLYNOM4,UPROOTS,NAT_3,POLYNOM5,GROUP_4,GR_CY_1,INT_1,FUNCT_7,NEWTON,INT_2,INT_3,HURWITZ,VALUED_0,REALSET1,RECDEF_1,PRE_POLY,POLYNOM2,CKB8;
definitions STRUCT_0,GROUP_1,INT_3,CARD_1,ALGSTR_0,BINOP_1,FINSEQ_1,POLYNOM3,HURWITZ,REALSET1,TARSKI,CKB8;
theorems TARSKI,XBOOLE_0,ZFMISC_1,ORDINAL1,FUNCT_1,FUNCT_2,VECTSP_1,INT_1,RELAT_1,RLVECT_1,ABSVALUE,GR_CY_1,FUNCT_7,NAT_1,INT_2,INT_3,PEPIN,NAT_D,XCMPLX_1,NUMBERS,PYTHTRIP,WSIERP_1,CARD_1,GROUP_1,GROUP_2,STRUCT_0,WELLORD2,XREAL_1,NEWTON,XXREAL_0,GR_CY_2,POWER,VALUED_0,ALGSEQ_1,NAT_3,UPROOTS,RVSUM_1,FINSEQ_4,FINSEQ_5,POLYNOM3,POLYNOM4,POLYNOM5,CARD_2,EULER_1,EULER_2,XBOOLE_1,FINSEQ_1,HURWITZ,GROUP_8,REALSET1,RELSET_1,FUNCT_4,FUNCOP_1,CLASSES1,PARTFUN1,PRE_POLY,FINSEQ_2,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB10,CKB11,CKB12;
schemes NAT_1,PRE_CIRC,FUNCT_2,RECDEF_1;
registrations XBOOLE_0,STRUCT_0,FUNCT_1,XREAL_0,ORDINAL1,NAT_1,INT_1,GROUP_1,GROUP_2,FINSET_1,FINSEQ_1,FUNCT_2,GR_CY_1,ALGSTR_0,MEMBERED,VECTSP_1,INT_3,XXREAL_0,NEWTON,SUBSET_1,RELAT_1,CARD_1,ALGSTR_1,NAT_3,VALUED_0,POLYNOM3,POLYNOM4,POLYNOM5,UPROOTS,RELSET_1,PRE_POLY,VFUNCT_1,CKB9;
constructors REAL_1,NAT_D,NAT_3,SEQ_1,PEPIN,EUCLID,REALSET1,GROUP_4,GR_CY_1,INT_3,WSIERP_1,BHSP_1,POLYNOM2,POLYNOM4,POLYNOM5,WELLORD2,POWER,ALGSTR_1,HURWITZ,UPROOTS,FUNCT_4,RECDEF_1,BINOP_2,CLASSES1,RELSET_1,PBOOLE,FUNCT_7,VFUNCT_1,CKB8;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
theorem
Lm6: (for i being (Element of ( NAT )) holds (for f being (FinSequence of ( NAT )) holds (for b being (bag of ( SetPrimes )) holds (for a being Prime holds ((((((( len f ) = i & b is  prime-factorization-like) & ( Product b ) <> 1) & a divides ( Product b )) & ( Product b ) = ( Product f )) & f = ( b * ( canFS ( support b ) ) )) implies a in ( support b ))))))
proof
defpred P[ (Element of ( NAT )) ]
 means
(for f being (FinSequence of ( NAT )) holds (for b being (bag of ( SetPrimes )) holds (for a being Prime holds ((((((( len f ) = $1 & b is  prime-factorization-like) & ( Product b ) <> 1) & a divides ( Product b )) & ( Product b ) = ( Product f )) & f = ( b * ( canFS ( support b ) ) )) implies a in ( support b )))));
A1: (for k being (Element of ( NAT )) holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume A2: P[ k ];
thus P[ ( k + 1 ) ]
proof
A3: 1 <= ( k + 1 ) by NAT_1:11;
let f being (FinSequence of ( NAT ));
let b being (bag of ( SetPrimes ));
let a being Prime;
assume that
A4: ( len f ) = ( k + 1 )
and
A5: b is  prime-factorization-like
and
( Product b ) <> 1
and
A6: a divides ( Product b )
and
A7: ( Product b ) = ( Product f )
and
A8: f = ( b * ( canFS ( support b ) ) );
reconsider p = ( f | k ) as (FinSequence of ( NAT ));
reconsider x = ( f . ( k + 1 ) ) as (Element of ( NAT ));
A9: ( len p ) = k by A4,FINSEQ_1:59,NAT_1:11;
A10: f = ( ( f | k ) ^ <* ( f /. ( len f ) ) *> ) by A4,FINSEQ_5:21
.= ( p ^ <* x *> ) by A4,A3,FINSEQ_4:15;
then consider p1 being (FinSequence of ( NAT )),q being Prime,n being (Element of ( NAT )),b1 being (bag of ( SetPrimes )) such that ( 0 ) < n and A11: b1 is  prime-factorization-like and A12: q in ( support b ) and A13: ( support b1 ) = ( ( support b ) \ { q } ) and A14: x = ( q |^ n ) and A15: ( len p1 ) = ( len p ) and A16: ( Product p ) = ( Product p1 ) and A17: p1 = ( b1 * ( canFS ( support b1 ) ) ) by A5,A8,CKB12:1;
A18: ( Product f ) = ( ( Product p1 ) * x ) by A10,A16,RVSUM_1:96;
( rng p1 ) c= ( COMPLEX ) by NUMBERS:20,XBOOLE_1:1;
then p1 is (FinSequence of ( COMPLEX )) by FINSEQ_1:def 4;
then A19: ( Product b1 ) = ( Product p1 ) by A17,NAT_3:def 5;
now
per cases ;
suppose A20: ( Product p1 ) = 1;

a <> 1 by INT_2:def 4;
then (ex k being (Element of ( NAT )) st a = ( q * k )) by A6,A7,A14,A18,A20,PEPIN:32;
then A21: q divides a by INT_1:def 3;
q <> 1 by INT_2:def 4;
hence thesis by A12,A21,INT_2:def 4;
end;
suppose A22: ( Product p1 ) <> 1;

per cases ;
suppose a = q;

hence thesis by A12;
end;
suppose A23: a <> q;

A24: ( support b1 ) c= ( support b ) by A13,XBOOLE_1:36;
a in ( support b1 ) by A2,A6,A7,A9,A11,A14,A15,A17,A18,A19,A22,A23,CKB10:1;
hence thesis by A24;
end;
end;
end;
hence thesis;
end;

end;
A25: P[ ( 0 ) ]
proof
let f being (FinSequence of ( NAT ));
let b being (bag of ( SetPrimes ));
let a being Prime;
assume ( len f ) = ( 0 );
then f = ( <*> ( NAT ) );
hence thesis by RVSUM_1:94;
end;
(for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A25,A1);
hence thesis;
end;
