environ
vocabularies BOR_CANT,REALSET1,ABIAN,SIN_COS,ARYTM_3,CARD_3,XREAL_0,EQREL_1,COMPLEX1,NUMBERS,ORDINAL1,ZFMISC_1,CARD_1,XXREAL_0,NEWTON,REAL_1,RELAT_1,PROB_1,SEQ_1,SEQ_2,ARYTM_1,ORDINAL2,RPR_1,XBOOLE_0,SUBSET_1,PROB_2,SERIES_1,NAT_1,FUNCT_1,PROB_3,SERIES_3,LIMFUNC1,SETLIM_1,XXREAL_2,FUNCOP_1;
notations XXREAL_0,XCMPLX_0,XREAL_0,ORDINAL1,REAL_1,XBOOLE_0,SUBSET_1,NUMBERS,NAT_1,COMPLEX1,SEQ_1,SEQ_2,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,FUNCOP_1,PROB_1,PROB_2,SETLIM_1,SERIES_1,PROB_3,VALUED_0,VALUED_1,ZFMISC_1,LIMFUNC1,SERIES_3,NEWTON,ABIAN,SIN_COS,CKB1,CKB4,CKB7,CKB8,CKB9,CKB10,CKB16;
definitions FUNCT_1,FUNCT_2,SIN_COS,PROB_1,SETLIM_1,NEWTON,CKB4,CKB7,CKB8,CKB9,CKB10,CKB16;
theorems XCMPLX_0,SIN_COS,SERIES_1,PROB_1,SEQ_2,PROB_3,SUBSET_1,XBOOLE_0,XBOOLE_1,ABIAN,NAT_1,FUNCT_1,FUNCT_2,XXREAL_0,ORDINAL1,TARSKI,XREAL_1,PROB_2,ABSVALUE,VALUED_1,SEQ_4,LIMFUNC1,SETLIM_1,SERIES_3,NEWTON,POWER,FUNCOP_1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB15,CKB16,CKB17,CKB18,CKB19;
schemes NAT_1,RECDEF_1,FUNCT_2;
registrations FUNCT_2,FINSEQ_2,XCMPLX_0,XBOOLE_0,SUBSET_1,ORDINAL1,NUMBERS,XREAL_0,NAT_1,MEMBERED,VALUED_0,VALUED_1,ABIAN,XXREAL_0,RELAT_1,SEQ_4,FINSEQ_1,NEWTON,FUNCOP_1,PROB_2,PROB_3,SETLIM_1,RELSET_1,CKB11,CKB12,CKB13,CKB14;
constructors RELSET_1,BINARITH,SQUARE_1,COMSEQ_3,RVSUM_1,SIN_COS,REAL_1,LIMFUNC1,SETLIM_1,SEQ_2,SERIES_1,KURATO_0,RINFSUP1,SEQ_1,PROB_3,SERIES_3,ABIAN,NEWTON,NUMBERS,NAT_D,SEQ_4,RFUNCT_1,RCOMP_1,SEQM_3,FUNCT_4,CKB1,CKB4,CKB7,CKB8,CKB9,CKB10,CKB16;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
definition
let X being set;
let A being (SetSequence of X);
func Union_Shift_Seq A -> (SetSequence of X)
means
:Def9: (for n being (Element of ( NAT )) holds ( it . n ) = ( Union ( A ^\ n ) ));
existence
proof
(for X being set holds (for A being (SetSequence of X) holds (ex S being (SetSequence of X) st (for n being (Element of ( NAT )) holds ( S . n ) = ( Union ( A ^\ n ) )))))
proof
let X being set;
let A being (SetSequence of X);
(ex J being (SetSequence of X) st (( J . ( 0 ) ) = ( Union ( A ^\ ( 0 ) ) ) & (for n being (Element of ( NAT )) holds ( J . ( n + 1 ) ) = ( Union ( A ^\ ( n + 1 ) ) ))))
proof
defpred P[ set,set,set ]
 means
(for x,y being (Subset of X) holds (for k being (Element of ( NAT )) holds (((k = $1 & x = $2) & y = $3) implies y = ( Union ( A ^\ ( k + 1 ) ) ))));
A1: (for n being (Element of ( NAT )) holds (for x being (Subset of X) holds (ex y being (Subset of X) st P[ n,x,y ])))
proof
let n being (Element of ( NAT ));
let x being (Subset of X);
take y = ( Union ( A ^\ ( n + 1 ) ) );
thus thesis;
end;
consider J being (SetSequence of X) such that A2: ( J . ( 0 ) ) = ( Union ( A ^\ ( 0 ) ) ) and A3: (for n being (Element of ( NAT )) holds P[ n,( J . n ),( J . ( n + 1 ) ) ]) from RECDEF_1:sch 2(A1);
take J;
thus ( J . ( 0 ) ) = ( Union ( A ^\ ( 0 ) ) ) by A2;
let n being (Element of ( NAT ));
P[ n,( J . n ),( J . ( n + 1 ) ) ] by A3;
hence thesis;
end;
then consider J being (SetSequence of X) such that A4: (( J . ( 0 ) ) = ( Union ( A ^\ ( 0 ) ) ) & (for n being (Element of ( NAT )) holds ( J . ( n + 1 ) ) = ( Union ( A ^\ ( n + 1 ) ) )));
A5: ((( J . ( 0 ) ) = ( Union ( A ^\ ( 0 ) ) ) & (for n being (Element of ( NAT )) holds ( J . ( n + 1 ) ) = ( Union ( A ^\ ( n + 1 ) ) ))) implies (for n being (Element of ( NAT )) holds ( J . n ) = ( Union ( A ^\ n ) )))
proof
assume A6: (( J . ( 0 ) ) = ( Union ( A ^\ ( 0 ) ) ) & (for n being (Element of ( NAT )) holds ( J . ( n + 1 ) ) = ( Union ( A ^\ ( n + 1 ) ) )));
let n being Nat;
per cases  by NAT_1:6;
suppose n = ( 0 );

hence thesis by A6;
end;
suppose (ex q being Nat st n = ( q + 1 ));

then consider q being Nat such that A7: n = ( q + 1 );
reconsider q as (Element of ( NAT )) by ORDINAL1:def 12;
( J . ( q + 1 ) ) = ( Union ( A ^\ ( q + 1 ) ) ) by A6;
hence thesis by A7;
end;
end;
take J;
thus thesis by A4,A5;
end;
hence thesis;
end;
uniqueness
proof
let J1 being (SetSequence of X),J2 being (SetSequence of X);
assume that
A8: (for n being (Element of ( NAT )) holds ( J1 . n ) = ( Union ( A ^\ n ) ))
and
A9: (for n being (Element of ( NAT )) holds ( J2 . n ) = ( Union ( A ^\ n ) ));
(for n being (Element of ( NAT )) holds ( J1 . n ) = ( J2 . n ))
proof
let n being (Element of ( NAT ));
( J1 . n ) = ( Union ( A ^\ n ) ) by A8;
hence thesis by A9;
end;
then (for n being set holds (n in ( NAT ) implies ( J1 . n ) = ( J2 . n )));
hence thesis by FUNCT_2:12;
end;
end;
