environ
vocabularies BOR_CANT,REALSET1,ABIAN,SIN_COS,ARYTM_3,CARD_3,XREAL_0,EQREL_1,COMPLEX1,NUMBERS,ORDINAL1,ZFMISC_1,CARD_1,XXREAL_0,NEWTON,REAL_1,RELAT_1,PROB_1,SEQ_1,SEQ_2,ARYTM_1,ORDINAL2,RPR_1,XBOOLE_0,SUBSET_1,PROB_2,SERIES_1,NAT_1,FUNCT_1,PROB_3,SERIES_3,LIMFUNC1,SETLIM_1,XXREAL_2,FUNCOP_1;
notations XXREAL_0,XCMPLX_0,XREAL_0,ORDINAL1,REAL_1,XBOOLE_0,SUBSET_1,NUMBERS,NAT_1,COMPLEX1,SEQ_1,SEQ_2,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,FUNCOP_1,PROB_1,PROB_2,SETLIM_1,SERIES_1,PROB_3,VALUED_0,VALUED_1,ZFMISC_1,LIMFUNC1,SERIES_3,NEWTON,ABIAN,SIN_COS,CKB1,CKB4,CKB7,CKB8,CKB9,CKB10,CKB16,CKB20,CKB22,CKB23,CKB25;
definitions FUNCT_1,FUNCT_2,SIN_COS,PROB_1,SETLIM_1,NEWTON,CKB4,CKB7,CKB8,CKB9,CKB10,CKB16,CKB20,CKB22,CKB23,CKB25;
theorems XCMPLX_0,SIN_COS,SERIES_1,PROB_1,SEQ_2,PROB_3,SUBSET_1,XBOOLE_0,XBOOLE_1,ABIAN,NAT_1,FUNCT_1,FUNCT_2,XXREAL_0,ORDINAL1,TARSKI,XREAL_1,PROB_2,ABSVALUE,VALUED_1,SEQ_4,LIMFUNC1,SETLIM_1,SERIES_3,NEWTON,POWER,FUNCOP_1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB22,CKB23,CKB25;
schemes NAT_1,RECDEF_1,FUNCT_2;
registrations FUNCT_2,FINSEQ_2,XCMPLX_0,XBOOLE_0,SUBSET_1,ORDINAL1,NUMBERS,XREAL_0,NAT_1,MEMBERED,VALUED_0,VALUED_1,ABIAN,XXREAL_0,RELAT_1,SEQ_4,FINSEQ_1,NEWTON,FUNCOP_1,PROB_2,PROB_3,SETLIM_1,RELSET_1,CKB11,CKB12,CKB13,CKB14,CKB21,CKB24;
constructors RELSET_1,BINARITH,SQUARE_1,COMSEQ_3,RVSUM_1,SIN_COS,REAL_1,LIMFUNC1,SETLIM_1,SEQ_2,SERIES_1,KURATO_0,RINFSUP1,SEQ_1,PROB_3,SERIES_3,ABIAN,NEWTON,NUMBERS,NAT_D,SEQ_4,RFUNCT_1,RCOMP_1,SEQM_3,FUNCT_4,CKB1,CKB4,CKB7,CKB8,CKB9,CKB10,CKB16,CKB20,CKB22,CKB23,CKB25;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve Omega for non empty set;
reserve Sigma for (SigmaField of Omega);
reserve A for (SetSequence of Sigma);
reserve n for (Element of ( NAT ));
theorem
Th9: ( ( Intersect_Shift_Seq ( Complement A ) ) . n ) = ( ( ( Union_Shift_Seq A ) . n ) ` )
proof
(for x being set holds (x in ( ( Intersect_Shift_Seq ( Complement A ) ) . n ) iff x in ( ( ( Union_Shift_Seq A ) . n ) ` )))
proof
let x being set;
hereby
assume A1: x in ( ( Intersect_Shift_Seq ( Complement A ) ) . n );
then A2: x in ( Intersection ( ( Complement A ) ^\ n ) ) by CKB23:def 1;
A3: (for k being (Element of ( NAT )) holds (not x in ( ( A ^\ n ) . k )))
proof
let k being (Element of ( NAT ));
x in ( ( ( Complement A ) ^\ n ) . k ) by A2,PROB_1:13;
then x in ( ( Complement A ) . ( n + k ) ) by NAT_1:def 3;
then A4: x in ( ( A . ( n + k ) ) ` ) by PROB_1:def 2;
x in ( Omega \ ( A . ( n + k ) ) ) by A4,SUBSET_1:def 4;
then (x in Omega & (not x in ( A . ( n + k ) ))) by XBOOLE_0:def 5;
hence thesis by NAT_1:def 3;
end;
A5: (not x in ( Union ( A ^\ n ) )) by A3,PROB_1:12;
A6: (not x in ( ( Union_Shift_Seq A ) . n )) by CKB20:def 1,A5;
A7: x in ( Omega \ ( ( Union_Shift_Seq A ) . n ) ) by A1,A6,XBOOLE_0:def 5;
thus x in ( ( ( Union_Shift_Seq A ) . n ) ` ) by A7,SUBSET_1:def 4;
end;
assume A8: x in ( ( ( Union_Shift_Seq A ) . n ) ` );
A9: (x in ( ( ( Union_Shift_Seq A ) . n ) ` ) iff x in ( Omega \ ( ( Union_Shift_Seq A ) . n ) )) by SUBSET_1:def 4;
A10: (x in ( ( Union_Shift_Seq A ) . n ) iff x in ( Union ( A ^\ n ) )) by CKB20:def 1;
A11: (for k being (Element of ( NAT )) holds x in ( ( ( Complement A ) ^\ n ) . k ))
proof
let k being (Element of ( NAT ));
A12: (not x in ( ( A ^\ n ) . k )) by A10,A8,A9,PROB_1:12,XBOOLE_0:def 5;
A13: (not x in ( A . ( n + k ) )) by A12,NAT_1:def 3;
A14: x in ( Omega \ ( A . ( n + k ) ) ) by A8,A13,XBOOLE_0:def 5;
(x in ( ( A . ( n + k ) ) ` ) iff x in ( ( Complement A ) . ( n + k ) )) by PROB_1:def 2;
hence thesis by A14,NAT_1:def 3,SUBSET_1:def 4;
end;
x in ( Intersection ( ( Complement A ) ^\ n ) ) by A11,PROB_1:13;
hence x in ( ( Intersect_Shift_Seq ( Complement A ) ) . n ) by CKB23:def 1;
end;
hence thesis by TARSKI:1;
end;
