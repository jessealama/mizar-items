environ
vocabularies BOR_CANT,REALSET1,ABIAN,SIN_COS,ARYTM_3,CARD_3,XREAL_0,EQREL_1,COMPLEX1,NUMBERS,ORDINAL1,ZFMISC_1,CARD_1,XXREAL_0,NEWTON,REAL_1,RELAT_1,PROB_1,SEQ_1,SEQ_2,ARYTM_1,ORDINAL2,RPR_1,XBOOLE_0,SUBSET_1,PROB_2,SERIES_1,NAT_1,FUNCT_1,PROB_3,SERIES_3,LIMFUNC1,SETLIM_1,XXREAL_2,FUNCOP_1;
notations XXREAL_0,XCMPLX_0,XREAL_0,ORDINAL1,REAL_1,XBOOLE_0,SUBSET_1,NUMBERS,NAT_1,COMPLEX1,SEQ_1,SEQ_2,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,FUNCOP_1,PROB_1,PROB_2,SETLIM_1,SERIES_1,PROB_3,VALUED_0,VALUED_1,ZFMISC_1,LIMFUNC1,SERIES_3,NEWTON,ABIAN,SIN_COS,CKB1,CKB4,CKB7,CKB8,CKB9,CKB10;
definitions FUNCT_1,FUNCT_2,SIN_COS,PROB_1,SETLIM_1,NEWTON,CKB4,CKB7,CKB8,CKB9,CKB10;
theorems XCMPLX_0,SIN_COS,SERIES_1,PROB_1,SEQ_2,PROB_3,SUBSET_1,XBOOLE_0,XBOOLE_1,ABIAN,NAT_1,FUNCT_1,FUNCT_2,XXREAL_0,ORDINAL1,TARSKI,XREAL_1,PROB_2,ABSVALUE,VALUED_1,SEQ_4,LIMFUNC1,SETLIM_1,SERIES_3,NEWTON,POWER,FUNCOP_1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10;
schemes NAT_1,RECDEF_1,FUNCT_2;
registrations FUNCT_2,FINSEQ_2,XCMPLX_0,XBOOLE_0,SUBSET_1,ORDINAL1,NUMBERS,XREAL_0,NAT_1,MEMBERED,VALUED_0,VALUED_1,ABIAN,XXREAL_0,RELAT_1,SEQ_4,FINSEQ_1,NEWTON,FUNCOP_1,PROB_2,PROB_3,SETLIM_1,RELSET_1;
constructors RELSET_1,BINARITH,SQUARE_1,COMSEQ_3,RVSUM_1,SIN_COS,REAL_1,LIMFUNC1,SETLIM_1,SEQ_2,SERIES_1,KURATO_0,RINFSUP1,SEQ_1,PROB_3,SERIES_3,ABIAN,NEWTON,NUMBERS,NAT_D,SEQ_4,RFUNCT_1,RCOMP_1,SEQM_3,FUNCT_4,CKB1,CKB4,CKB7,CKB8,CKB9,CKB10;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve n1 for (Element of ( NAT ));
reserve n2 for (Element of ( NAT ));
registration
let n1 being (Element of ( NAT ));
let n2 being (Element of ( NAT ));
cluster ( Special_Function (n1,n2) ) ->  one-to-one;
coherence
proof
let x1 being set;
let x2 being set;
assume that
A1: x1 in ( dom ( Special_Function (n1,n2) ) )
and
A2: x2 in ( dom ( Special_Function (n1,n2) ) );
assume A3: ( ( Special_Function (n1,n2) ) . x1 ) = ( ( Special_Function (n1,n2) ) . x2 );
reconsider x1 as (Element of ( NAT )) by A1;
reconsider x2 as (Element of ( NAT )) by A2;
A4: (( ( Special_Function (n1,n2) ) . x2 ) = ( IFGT (x2,n1,( x2 + n2 ),x2) ) & ( ( Special_Function (n1,n2) ) . x1 ) = ( IFGT (x1,n1,( x1 + n2 ),x1) )) by CKB7:def 1;
per cases ;
suppose A5: (x1 <= n1 & x2 <= n1);

(( IFGT (x2,n1,( x2 + n2 ),x2) ) = x2 & ( IFGT (x1,n1,( x1 + n2 ),x1) ) = x1) by A5,XXREAL_0:def 11;
hence thesis by A4,A3;
end;
suppose A6: (x1 <= n1 & x2 > n1);

then ( IFGT (x2,n1,( x2 + n2 ),x2) ) = ( x2 + n2 ) by XXREAL_0:def 11;
then A7: ( ( Special_Function (n1,n2) ) . x2 ) = ( x2 + n2 ) by CKB7:def 1;
A8: ( IFGT (x1,n1,( x1 + n2 ),x1) ) = x1 by A6,XXREAL_0:def 11;
A9: ( ( Special_Function (n1,n2) ) . x1 ) = x1 by CKB7:def 1,A8;
(x1 <> x2 implies ( ( Special_Function (n1,n2) ) . x1 ) <> ( ( Special_Function (n1,n2) ) . x2 ))
proof
assume x1 <> x2;
(x1 < x2 & ( 0 ) <= n2) by A6,XXREAL_0:2;
hence thesis by A9,A7,XREAL_1:31;
end;
hence thesis by A3;
end;
suppose A10: (x2 <= n1 & x1 > n1);

A11: ( ( Special_Function (n1,n2) ) . x1 ) = ( IFGT (x1,n1,( x1 + n2 ),x1) ) by CKB7:def 1;
A12: ( ( Special_Function (n1,n2) ) . x1 ) = ( x1 + n2 ) by A11,A10,XXREAL_0:def 11;
A13: ( ( Special_Function (n1,n2) ) . x2 ) = ( IFGT (x2,n1,( x2 + n2 ),x2) ) by CKB7:def 1;
A14: ( ( Special_Function (n1,n2) ) . x2 ) = x2 by A13,A10,XXREAL_0:def 11;
(x2 <> x1 implies ( ( Special_Function (n1,n2) ) . x2 ) <> ( ( Special_Function (n1,n2) ) . x1 ))
proof
assume x2 <> x1;
(x2 < x1 & ( 0 ) <= n2) by A10,XXREAL_0:2;
hence thesis by A14,A12,XREAL_1:31;
end;
hence thesis by A3;
end;
suppose A15: (x1 > n1 & x2 > n1);

(( IFGT (x2,n1,( x2 + n2 ),x2) ) = ( x2 + n2 ) & ( IFGT (x1,n1,( x1 + n2 ),x1) ) = ( x1 + n2 )) by A15,XXREAL_0:def 11;
then ( x2 + n2 ) = ( x1 + n2 ) by A4,A3;
hence thesis;
end;
end;
end;
