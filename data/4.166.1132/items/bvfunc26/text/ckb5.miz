environ
vocabularies XBOOLE_0,SUBSET_1,FUNCT_2,MARGREL1,FUNCT_1,XBOOLEAN,RELAT_1,TARSKI,BVFUNC_1;
notations TARSKI,XBOOLE_0,SUBSET_1,XBOOLEAN,MARGREL1,RELAT_1,FUNCT_1,FUNCT_2,BVFUNC_1,CKB1,CKB2;
definitions TARSKI,MARGREL1,CKB1,CKB2;
theorems FUNCT_1,FUNCT_2,MARGREL1,BVFUNC_1,BVFUNC_4,BVFUNC_8,BVFUNC25,XBOOLEAN,CKB1,CKB2;
schemes FUNCT_1;
registrations FUNCT_1,FUNCT_2,XBOOLEAN,MARGREL1,XBOOLE_0,CKB3,CKB4;
constructors BVFUNC_1,RELSET_1,CKB1,CKB2;
requirements SUBSET,BOOLE;
begin
definition
let A being non  empty set;
let p being (Element of ( Funcs (A,( BOOLEAN )) ));
let q being (Element of ( Funcs (A,( BOOLEAN )) ));
redefine func p 'nand' q -> (Element of ( Funcs (A,( BOOLEAN )) )) means 
:Def3: (for x being (Element of A) holds ( it . x ) = ( ( p . x ) 'nand' ( q . x ) ));
coherence
proof
((ex f being Function st ((p = f & ( dom f ) = A) & ( rng f ) c= ( BOOLEAN ))) & (ex f being Function st ((q = f & ( dom f ) = A) & ( rng f ) c= ( BOOLEAN )))) by FUNCT_2:def 2;
then A1: ( dom ( p 'nand' q ) ) = ( A /\ A ) by CKB1:def 1
.= A;
( rng ( p 'nand' q ) ) c= ( BOOLEAN ) by MARGREL1:def 16;
hence thesis by A1,FUNCT_2:def 2;
end;
compatibility
proof
let IT being (Element of ( Funcs (A,( BOOLEAN )) ));
A2: ( dom IT ) = A by FUNCT_2:def 1;
hereby
assume A3: IT = ( p 'nand' q );
let x being (Element of A);
(( dom p ) = A & ( dom q ) = A) by FUNCT_2:def 1;
then ( dom ( p 'nand' q ) ) = ( A /\ A ) by CKB1:def 1
.= A;
hence ( IT . x ) = ( ( p . x ) 'nand' ( q . x ) ) by A3,CKB1:def 1;
end;
A4: ( dom q ) = A by FUNCT_2:def 1;
A5: ( dom IT ) = ( A /\ A ) by FUNCT_2:def 1
.= ( ( dom p ) /\ ( dom q ) ) by A4,FUNCT_2:def 1;
assume (for x being (Element of A) holds ( IT . x ) = ( ( p . x ) 'nand' ( q . x ) ));
then (for x being set holds (x in ( dom IT ) implies ( IT . x ) = ( ( p . x ) 'nand' ( q . x ) ))) by A2;
hence thesis by A5,CKB1:def 1;
end;
end;
