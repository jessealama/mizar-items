environ
vocabularies AMI_1,SCMFSA_2,FSM_1,CARD_1,SCMFSA6B,TURING_1,FUNCT_1,RELAT_1,ARYTM_3,FUNCT_4,SCMFSA6A,TARSKI,XBOOLE_0,CIRCUIT2,NUMBERS,SUBSET_1,GRAPHSP,AMI_3,XXREAL_0,SF_MASTR,FUNCOP_1,FUNCT_7,STRUCT_0,ARYTM_1,INT_1,COMPLEX1,PARTFUN1,FINSEQ_1,FINSEQ_2,MSUALG_1,AOFA_I00,ORDINAL1,SCMNORM,PBOOLE,SCMFSA6C,AMISTD_1,AMISTD_2,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,ENUMSET1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,COMPLEX1,RELAT_1,FUNCT_1,PARTFUN1,FINSEQ_1,FINSEQ_2,FUNCOP_1,FUNCT_4,PBOOLE,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,FUNCT_7,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,XXREAL_0,CKB3,CKB4,CKB40;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,SCMFSA6B,SCMFSA6A,PARTFUN1,MEMSTR_0,AMISTD_1,CKB3,CKB4,CKB40;
theorems RELAT_1,FUNCT_7,FUNCT_4,FUNCT_1,SCMFSA_3,ZFMISC_1,FUNCOP_1,TARSKI,NAT_1,SCMFSA_2,ENUMSET1,GRFUNC_1,SCMFSA6A,SF_MASTR,SCMFSA6B,XBOOLE_0,XBOOLE_1,PARTFUN1,COMPOS_1,EXTPRO_1,AMISTD_2,PBOOLE,STRUCT_0,MEMSTR_0,AMISTD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,FUNCOP_1,FINSET_1,NUMBERS,XREAL_0,INT_1,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,ORDINAL1,RELSET_1,COMPOS_1,STRUCT_0,EXTPRO_1,SCMFSA10,PBOOLE,FUNCT_4,AMISTD_2,MEMSTR_0,AMISTD_1,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB41,CKB42;
constructors DOMAIN_1,SETWISEO,XXREAL_0,INT_2,SCMFSA6A,SF_MASTR,SCMFSA6B,RELSET_1,PRE_POLY,AMISTD_1,AMISTD_2,PBOOLE,FUNCT_4,MEMSTR_0,CKB3,CKB4,CKB40;
requirements NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve a for Int-Location;
reserve b for Int-Location;
reserve s for (State of ( SCM+FSA ));
reserve P for (Instruction-Sequence of ( SCM+FSA ));
theorem
(for a,b being  read-write Int-Location holds (( ( IExec (( swap (a,b) ),P,s) ) . a ) = ( s . b ) & ( ( IExec (( swap (a,b) ),P,s) ) . b ) = ( s . a )))
proof
let a being  read-write Int-Location;
let b being  read-write Int-Location;
set i0 = ( ( FirstNotUsed ( Macro ( a := b ) ) ) := a );
set i1 = ( a := b );
set i2 = ( b := ( FirstNotUsed ( Macro ( a := b ) ) ) );
set i01 = ( i0 ';' i1 );
( UsedIntLoc ( Macro ( a := b ) ) ) = ( UsedIntLoc ( a := b ) ) by SF_MASTR:28;
then ( UsedIntLoc ( Macro ( a := b ) ) ) = { a,b } by SF_MASTR:14;
then A1: (not ( FirstNotUsed ( Macro ( a := b ) ) ) in { a,b }) by SF_MASTR:50;
then A2: ( FirstNotUsed ( Macro ( a := b ) ) ) <> a by TARSKI:def 2;
A3: ( FirstNotUsed ( Macro ( a := b ) ) ) <> b by A1,TARSKI:def 2;
hereby
per cases ;
suppose A4: a <> b;

thus ( ( IExec (( swap (a,b) ),P,s) ) . a ) = ( ( Exec (i2,( IExec (i01,P,s) )) ) . a ) by CKB36:1
.= ( ( IExec (i01,P,s) ) . a ) by A4,SCMFSA_2:63
.= ( ( Exec (i1,( Exec (i0,( Initialized s )) )) ) . a ) by CKB38:1
.= ( ( Exec (i0,( Initialized s )) ) . b ) by SCMFSA_2:63
.= ( ( Initialized s ) . b ) by A3,SCMFSA_2:63
.= ( s . b ) by CKB33:1;
end;
suppose A5: a = b;

thus ( ( IExec (( swap (a,b) ),P,s) ) . a ) = ( ( Exec (i2,( IExec (i01,P,s) )) ) . a ) by CKB36:1
.= ( ( IExec (i01,P,s) ) . ( FirstNotUsed ( Macro ( a := b ) ) ) ) by A5,SCMFSA_2:63
.= ( ( Exec (i1,( Exec (i0,( Initialized s )) )) ) . ( FirstNotUsed ( Macro ( a := b ) ) ) ) by CKB38:1
.= ( ( Exec (i0,( Initialized s )) ) . ( FirstNotUsed ( Macro ( a := b ) ) ) ) by A2,SCMFSA_2:63
.= ( ( Initialized s ) . a ) by SCMFSA_2:63
.= ( s . b ) by A5,CKB33:1;
end;
end;
thus ( ( IExec (( swap (a,b) ),P,s) ) . b ) = ( ( Exec (i2,( IExec (i01,P,s) )) ) . b ) by CKB36:1
.= ( ( IExec (i01,P,s) ) . ( FirstNotUsed ( Macro ( a := b ) ) ) ) by SCMFSA_2:63
.= ( ( Exec (i1,( Exec (i0,( Initialized s )) )) ) . ( FirstNotUsed ( Macro ( a := b ) ) ) ) by CKB38:1
.= ( ( Exec (i0,( Initialized s )) ) . ( FirstNotUsed ( Macro ( a := b ) ) ) ) by A2,SCMFSA_2:63
.= ( ( Initialized s ) . a ) by SCMFSA_2:63
.= ( s . a ) by CKB33:1;
end;
