environ
vocabularies AMI_1,SCMFSA_2,FSM_1,CARD_1,SCMFSA6B,TURING_1,FUNCT_1,RELAT_1,ARYTM_3,FUNCT_4,SCMFSA6A,TARSKI,XBOOLE_0,CIRCUIT2,NUMBERS,SUBSET_1,GRAPHSP,AMI_3,XXREAL_0,SF_MASTR,FUNCOP_1,FUNCT_7,STRUCT_0,ARYTM_1,INT_1,COMPLEX1,PARTFUN1,FINSEQ_1,FINSEQ_2,MSUALG_1,AOFA_I00,ORDINAL1,SCMNORM,PBOOLE,SCMFSA6C,AMISTD_1,AMISTD_2,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,ENUMSET1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,COMPLEX1,RELAT_1,FUNCT_1,PARTFUN1,FINSEQ_1,FINSEQ_2,FUNCOP_1,FUNCT_4,PBOOLE,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,FUNCT_7,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,XXREAL_0,CKB3,CKB4;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,SCMFSA6B,SCMFSA6A,PARTFUN1,MEMSTR_0,AMISTD_1,CKB3,CKB4;
theorems RELAT_1,FUNCT_7,FUNCT_4,FUNCT_1,SCMFSA_3,ZFMISC_1,FUNCOP_1,TARSKI,NAT_1,SCMFSA_2,ENUMSET1,GRFUNC_1,SCMFSA6A,SF_MASTR,SCMFSA6B,XBOOLE_0,XBOOLE_1,PARTFUN1,COMPOS_1,EXTPRO_1,AMISTD_2,PBOOLE,STRUCT_0,MEMSTR_0,AMISTD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,FUNCOP_1,FINSET_1,NUMBERS,XREAL_0,INT_1,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,ORDINAL1,RELSET_1,COMPOS_1,STRUCT_0,EXTPRO_1,SCMFSA10,PBOOLE,FUNCT_4,AMISTD_2,MEMSTR_0,AMISTD_1,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18;
constructors DOMAIN_1,SETWISEO,XXREAL_0,INT_2,SCMFSA6A,SF_MASTR,SCMFSA6B,RELSET_1,PRE_POLY,AMISTD_1,AMISTD_2,PBOOLE,FUNCT_4,MEMSTR_0,CKB3,CKB4;
requirements NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve a for Int-Location;
reserve f for FinSeq-Location;
reserve s for (State of ( SCM+FSA ));
reserve P for (Instruction-Sequence of ( SCM+FSA ));
set SA0 = ( Start-At (( 0 ),( SCM+FSA )) );
registration
let a being Int-Location;
let f being FinSeq-Location;
cluster ( f :=<0,...,0> a ) ->  parahalting  keeping_0;
coherence
proof
thus ( f :=<0,...,0> a ) is  parahalting
proof
set Ma = ( Macro ( f :=<0,...,0> a ) );
let s being ( 0 ) -started (State of ( SCM+FSA ));
A12: ( Start-At (( 0 ),( SCM+FSA )) ) c= s by MEMSTR_0:29;
let P being (Instruction-Sequence of ( SCM+FSA ));
assume that
A13: ( Macro ( f :=<0,...,0> a ) ) c= P;
take 1;
A15: ( dom P ) = ( NAT ) by PARTFUN1:def 2;
thus ( IC ( Comput (P,s,1) ) ) in ( dom P ) by A15;
( dom SA0 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
then A16: ( IC ( SCM+FSA ) ) in ( dom SA0 ) by TARSKI:def 1;
A17: ( IC s ) = ( SA0 . ( IC ( SCM+FSA ) ) ) by A16,A12,GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
then A18: ( IC ( Exec (( f :=<0,...,0> a ),s) ) ) = ( succ ( 0 ) ) by SCMFSA_2:75
.= ( ( 0 ) + 1 );
A19: 1 in ( dom Ma ) by COMPOS_1:60;
A20: ( 0 ) in ( dom Ma ) by COMPOS_1:60;
A21: ( P . ( 0 ) ) = ( Ma . ( 0 ) ) by A13,A20,GRFUNC_1:2
.= ( f :=<0,...,0> a ) by COMPOS_1:58;
A22: ( P . 1 ) = ( Ma . 1 ) by A13,A19,GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by COMPOS_1:59;
( Comput (P,s,( ( 0 ) + 1 )) ) = ( Following (P,( Comput (P,s,( 0 )) )) ) by EXTPRO_1:3
.= ( Following (P,s) ) by EXTPRO_1:2
.= ( Exec (( f :=<0,...,0> a ),s) ) by A17,A15,A21,PARTFUN1:def 6;
hence thesis by A18,A15,A22,PARTFUN1:def 6;
end;

thus ( f :=<0,...,0> a ) is  keeping_0
proof
set Ma = ( Macro ( f :=<0,...,0> a ) );
let s being ( 0 ) -started (State of ( SCM+FSA ));
A23: ( Start-At (( 0 ),( SCM+FSA )) ) c= s by MEMSTR_0:29;
let P being (Instruction-Sequence of ( SCM+FSA ));
assume A24: Ma c= P;
let k being (Element of ( NAT ));
( dom SA0 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
then A25: ( IC ( SCM+FSA ) ) in ( dom SA0 ) by TARSKI:def 1;
A26: ( IC s ) = ( SA0 . ( IC ( SCM+FSA ) ) ) by A25,A23,GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
( 0 ) in ( dom Ma ) by COMPOS_1:60;
then A27: ( Ma . ( 0 ) ) = ( P . ( 0 ) ) by A24,GRFUNC_1:2;
A28: ( P /. ( IC s ) ) = ( P . ( IC s ) ) by PBOOLE:143;
A29: ( Comput (P,s,( ( 0 ) + 1 )) ) = ( Following (P,( Comput (P,s,( 0 )) )) ) by EXTPRO_1:3
.= ( Following (P,s) ) by EXTPRO_1:2
.= ( Exec (( f :=<0,...,0> a ),s) ) by A26,A27,A28,COMPOS_1:58;
1 in ( dom Ma ) by COMPOS_1:60;
then ( Ma . 1 ) = ( P . 1 ) by A24,GRFUNC_1:2;
then A30: ( P . 1 ) = ( halt ( SCM+FSA ) ) by COMPOS_1:59;
( IC ( Exec (( f :=<0,...,0> a ),s) ) ) = ( succ ( 0 ) ) by A26,SCMFSA_2:75
.= ( ( 0 ) + 1 );
then A31: ( CurInstr (P,( Comput (P,s,1) )) ) = ( halt ( SCM+FSA ) ) by A30,A29,PBOOLE:143;
per cases  by NAT_1:14;
suppose k = ( 0 );

hence thesis by EXTPRO_1:2;
end;
suppose A32: 1 <= k;

( ( Comput (P,s,1) ) . ( intloc ( 0 ) ) ) = ( s . ( intloc ( 0 ) ) ) by A29,SCMFSA_2:75;
hence thesis by A31,A32,EXTPRO_1:5;
end;
end;

end;
end;
