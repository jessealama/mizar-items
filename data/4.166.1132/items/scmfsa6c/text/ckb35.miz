environ
vocabularies AMI_1,SCMFSA_2,FSM_1,CARD_1,SCMFSA6B,TURING_1,FUNCT_1,RELAT_1,ARYTM_3,FUNCT_4,SCMFSA6A,TARSKI,XBOOLE_0,CIRCUIT2,NUMBERS,SUBSET_1,GRAPHSP,AMI_3,XXREAL_0,SF_MASTR,FUNCOP_1,FUNCT_7,STRUCT_0,ARYTM_1,INT_1,COMPLEX1,PARTFUN1,FINSEQ_1,FINSEQ_2,MSUALG_1,AOFA_I00,ORDINAL1,SCMNORM,PBOOLE,SCMFSA6C,AMISTD_1,AMISTD_2,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,ENUMSET1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,COMPLEX1,RELAT_1,FUNCT_1,PARTFUN1,FINSEQ_1,FINSEQ_2,FUNCOP_1,FUNCT_4,PBOOLE,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,FUNCT_7,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,XXREAL_0,CKB3,CKB4;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,SCMFSA6B,SCMFSA6A,PARTFUN1,MEMSTR_0,AMISTD_1,CKB3,CKB4;
theorems RELAT_1,FUNCT_7,FUNCT_4,FUNCT_1,SCMFSA_3,ZFMISC_1,FUNCOP_1,TARSKI,NAT_1,SCMFSA_2,ENUMSET1,GRFUNC_1,SCMFSA6A,SF_MASTR,SCMFSA6B,XBOOLE_0,XBOOLE_1,PARTFUN1,COMPOS_1,EXTPRO_1,AMISTD_2,PBOOLE,STRUCT_0,MEMSTR_0,AMISTD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB33,CKB34;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,FUNCOP_1,FINSET_1,NUMBERS,XREAL_0,INT_1,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,ORDINAL1,RELSET_1,COMPOS_1,STRUCT_0,EXTPRO_1,SCMFSA10,PBOOLE,FUNCT_4,AMISTD_2,MEMSTR_0,AMISTD_1,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32;
constructors DOMAIN_1,SETWISEO,XXREAL_0,INT_2,SCMFSA6A,SF_MASTR,SCMFSA6B,RELSET_1,PRE_POLY,AMISTD_1,AMISTD_2,PBOOLE,FUNCT_4,MEMSTR_0,CKB3,CKB4;
requirements NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve i for (Instruction of ( SCM+FSA ));
reserve a for Int-Location;
reserve b for Int-Location;
reserve f for FinSeq-Location;
reserve l for (Element of ( NAT ));
reserve s for (State of ( SCM+FSA ));
reserve P for (Instruction-Sequence of ( SCM+FSA ));
theorem
Th6: (for i being  parahalting (Instruction of ( SCM+FSA )) holds ( Exec (i,( Initialized s )) ) = ( IExec (( Macro i ),P,s) ))
proof
let i being  parahalting (Instruction of ( SCM+FSA ));
set Mi = ( Macro i );
set sI = ( s +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) );
set pI = ( P +* Mi );
A1: Mi c= pI by FUNCT_4:25;
set Is = ( Initialized s );
set IC1 = ( IC ( Comput (( P +* Mi ),sI,1) ) );
reconsider Mi as  parahalting (Program of ( SCM+FSA ));
A3: IC1 in ( dom Mi ) by A1,AMISTD_1:def 10;
A24: 1 in ( dom Mi ) by COMPOS_1:60;
A25: ( 0 ) in ( dom Mi ) by COMPOS_1:60;
A26: ( Mi . ( 0 ) ) = i by COMPOS_1:58;
XX: ( IC sI ) = ( 0 ) by MEMSTR_0:def 8;
A28: ( Comput (( P +* Mi ),sI,( ( 0 ) + 1 )) ) = ( Following (( P +* Mi ),( Comput (( P +* Mi ),sI,( 0 )) )) ) by EXTPRO_1:3
.= ( Following (( P +* Mi ),sI) ) by EXTPRO_1:2
.= ( Exec (( pI . ( 0 ) ),sI) ) by XX,PBOOLE:143
.= ( Exec (i,sI) ) by A26,A1,A25,GRFUNC_1:2;
per cases  by A3,COMPOS_1:60;
suppose A29: IC1 = ( 0 );

then A30: ( CurInstr (( P +* Mi ),( Comput (( P +* Mi ),sI,1) )) ) = ( ( P +* Mi ) . ( 0 ) ) by PBOOLE:143
.= i by A26,A25,FUNCT_4:13;
( succ ( IC sI ) ) = 1 by XX;
then A31: ( InsCode i ) in { ( 0 ),6,7,8 } by A28,A29,SCMFSA6A:3;
hereby
per cases  by A31,ENUMSET1:def 2;
suppose ( InsCode i ) = ( 0 );

then A32: i = ( halt ( SCM+FSA ) ) by SCMFSA_2:95;
then ( P +* Mi ) halts_on sI by A30,EXTPRO_1:29;
hence thesis by A28,A30,A32,EXTPRO_1:def 9;
end;
suppose A33: ((( InsCode i ) = 6 or ( InsCode i ) = 7) or ( InsCode i ) = 8);

A34:now
let a;
per cases  by A33;
suppose ( InsCode i ) = 6;

then (ex l st i = ( goto l )) by SCMFSA_2:35;
hence ( sI . a ) = ( ( Exec (i,sI) ) . a ) by SCMFSA_2:69;
end;
suppose ( InsCode i ) = 7;

then (ex l st (ex b st i = ( b =0_goto l ))) by SCMFSA_2:36;
hence ( sI . a ) = ( ( Exec (i,sI) ) . a ) by SCMFSA_2:70;
end;
suppose ( InsCode i ) = 8;

then (ex l st (ex b st i = ( b >0_goto l ))) by SCMFSA_2:37;
hence ( sI . a ) = ( ( Exec (i,sI) ) . a ) by SCMFSA_2:71;
end;
end;
A36:now
let f;
per cases  by A33;
suppose ( InsCode i ) = 6;

then (ex l st i = ( goto l )) by SCMFSA_2:35;
hence ( sI . f ) = ( ( Exec (i,sI) ) . f ) by SCMFSA_2:69;
end;
suppose ( InsCode i ) = 7;

then (ex l st (ex a st i = ( a =0_goto l ))) by SCMFSA_2:36;
hence ( sI . f ) = ( ( Exec (i,sI) ) . f ) by SCMFSA_2:70;
end;
suppose ( InsCode i ) = 8;

then (ex l st (ex a st i = ( a >0_goto l ))) by SCMFSA_2:37;
hence ( sI . f ) = ( ( Exec (i,sI) ) . f ) by SCMFSA_2:71;
end;
end;
A38: ( Following (( P +* Mi ),sI) ) = ( Following (( P +* Mi ),( Comput (( P +* Mi ),sI,( 0 )) )) ) by EXTPRO_1:2
.= ( Exec (i,sI) ) by A28,EXTPRO_1:3;
(for n being (Element of ( NAT )) holds ( CurInstr (( P +* Mi ),( Comput (( P +* Mi ),sI,n) )) ) <> ( halt ( SCM+FSA ) )) by A30,A33,SCMFSA_2:97,A34,A36,A28,A29,XX,A38,AMISTD_2:11,SCMFSA_2:104;
then A39: (not ( P +* Mi ) halts_on sI) by EXTPRO_1:29;
Mi c= ( P +* Mi ) by FUNCT_4:25;
hence ( Exec (i,( Initialized s )) ) = ( IExec (( Macro i ),P,s) ) by A39,AMISTD_1:def 11;
end;
end;
end;
suppose A41: IC1 = 1;

A43: ( Mi . 1 ) = ( halt ( SCM+FSA ) ) by COMPOS_1:59;
A44: ( CurInstr (( P +* Mi ),( Comput (( P +* Mi ),sI,1) )) ) = ( ( P +* Mi ) . 1 ) by A41,PBOOLE:143
.= ( halt ( SCM+FSA ) ) by A43,A1,A24,GRFUNC_1:2;
then ( P +* Mi ) halts_on sI by EXTPRO_1:29;
hence thesis by A28,A44,EXTPRO_1:def 9;
end;
end;
