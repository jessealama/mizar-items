environ
vocabularies NUMBERS,SUBSET_1,SCMPDS_2,INT_1,FSM_1,AMI_1,COMPLEX1,ARYTM_3,FUNCT_1,AMI_2,STRUCT_0,XBOOLE_0,RELAT_1,TARSKI,CARD_1,AMI_3,SCMPDS_1,GRAPHSP,SCMNORM,XXREAL_0,ARYTM_1,FUNCT_4,FUNCOP_1,FUNCT_7,CIRCUIT2,ORDINAL1,PARTFUN1,AMISTD_5,PBOOLE,AMISTD_2,FINSET_1,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,RELAT_1,FUNCT_1,PARTFUN1,PBOOLE,FUNCT_4,FINSET_1,INT_1,NAT_1,STRUCT_0,FUNCOP_1,INT_2,XXREAL_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,AMISTD_5,SCMPDS_1,SCMPDS_2,CKB8;
definitions EXTPRO_1,AMI_2,AMI_3,FUNCOP_1,SCMPDS_2,NAT_1,COMPOS_1,AMISTD_5,STRUCT_0,MEMSTR_0;
theorems AMI_3,GRFUNC_1,NAT_1,FUNCOP_1,TARSKI,FUNCT_4,FUNCT_1,ZFMISC_1,INT_1,RELAT_1,ABSVALUE,SCMPDS_2,XBOOLE_0,XBOOLE_1,NUMBERS,PBOOLE,PARTFUN1,COMPOS_1,EXTPRO_1,AMISTD_5,MEMSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB10,CKB11,CKB12,CKB14,CKB15,CKB16,CKB17;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,ORDINAL1,NUMBERS,XREAL_0,INT_1,CARD_3,AMI_3,SCMPDS_2,FINSET_1,RELSET_1,FUNCT_2,COMPOS_1,EXTPRO_1,AMISTD_5,PBOOLE,AMISTD_2,FUNCT_4,FUNCOP_1,MEMSTR_0,CKB9,CKB13;
constructors DOMAIN_1,XXREAL_0,INT_2,SCMPDS_1,SCMPDS_2,REAL_1,PRE_POLY,AMI_3,AMISTD_5,PBOOLE,AMISTD_1,FUNCT_7,MEMSTR_0,RELSET_1,CKB8;
requirements NUMERALS,SUBSET,BOOLE,ARITHM,REAL;
begin
reserve m for (Element of ( NAT ));
reserve a for Int_position;
reserve k1 for Integer;
reserve k2 for Integer;
reserve P1 for (Instruction-Sequence of ( SCMPDS ));
reserve P2 for (Instruction-Sequence of ( SCMPDS ));
theorem
(for q being non  halt-free  finite (the Instructions of ( SCMPDS )) -valued ( NAT ) -defined Function holds (for p being q -autonomic non  empty (FinPartState of ( SCMPDS )) holds (for s1,s2 being (State of ( SCMPDS )) holds ((((p c= s1 & p c= s2) & q c= P1) & q c= P2) implies (for i,m being (Element of ( NAT )) holds (for a being Int_position holds (for k1,k2 being Integer holds ((((( CurInstr (P1,( Comput (P1,s1,i) )) ) = ( (a,k1) <>0_goto k2 ) & m = ( IC ( Comput (P1,s1,i) ) )) & ( m + k2 ) >= ( 0 )) & k2 <> 1) implies (( ( Comput (P1,s1,i) ) . ( DataLoc (( ( Comput (P1,s1,i) ) . a ),k1) ) ) = ( 0 ) iff ( ( Comput (P2,s2,i) ) . ( DataLoc (( ( Comput (P2,s2,i) ) . a ),k1) ) ) = ( 0 ))))))))))
proof
let q being non  halt-free  finite (the Instructions of ( SCMPDS )) -valued ( NAT ) -defined Function;
let p being q -autonomic non  empty (FinPartState of ( SCMPDS ));
let s1 being (State of ( SCMPDS ));
let s2 being (State of ( SCMPDS ));
assume that
A1: (p c= s1 & p c= s2)
and
A2: (q c= P1 & q c= P2);
let i being (Element of ( NAT ));
let m being (Element of ( NAT ));
let a being Int_position;
let k1 being Integer;
let k2 being Integer;
set Cs1i = ( Comput (P1,s1,i) );
set Cs2i = ( Comput (P2,s2,i) );
set Cs1i1 = ( Comput (P1,s1,( i + 1 )) );
set Cs2i1 = ( Comput (P2,s2,( i + 1 )) );
A3: (( IC Cs1i ) = ( IC Cs2i ) & ( Cs1i1 | ( dom p ) ) = ( Cs2i1 | ( dom p ) )) by A1,A2,AMISTD_5:7,EXTPRO_1:def 10;
set I = ( CurInstr (P1,( Comput (P1,s1,i) )) );
A4: Cs1i1 = ( Following (P1,Cs1i) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (P1,Cs1i) ),Cs1i) );
A5: ( m + 1 ) >= ( 0 ) by NAT_1:2;
( IC ( SCMPDS ) ) in ( dom p ) by AMISTD_5:6;
then ( IC ( SCMPDS ) ) in ( dom p );
then A6: (( ( Cs1i1 | ( dom p ) ) . ( IC ( SCMPDS ) ) ) = ( Cs1i1 . ( IC ( SCMPDS ) ) ) & ( ( Cs2i1 | ( dom p ) ) . ( IC ( SCMPDS ) ) ) = ( Cs2i1 . ( IC ( SCMPDS ) ) )) by FUNCT_1:49;
A7: Cs2i1 = ( Following (P2,Cs2i) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (P2,Cs2i) ),Cs2i) );
assume that
A8: I = ( (a,k1) <>0_goto k2 )
and
A9: ((m = ( IC Cs1i ) & ( m + k2 ) >= ( 0 )) & k2 <> 1);
A10: I = ( CurInstr (P2,( Comput (P2,s2,i) )) ) by A1,A2,AMISTD_5:7;
A11:now
assume that
A12: ( ( Comput (P2,s2,i) ) . ( DataLoc (( Cs2i . a ),k1) ) ) = ( 0 )
and
A13: ( ( Comput (P1,s1,i) ) . ( DataLoc (( Cs1i . a ),k1) ) ) <> ( 0 );
A14: ( Cs1i1 . ( IC ( SCMPDS ) ) ) = ( ICplusConst (Cs1i,k2) ) by A4,A8,A13,SCMPDS_2:55;
( Cs2i1 . ( IC ( SCMPDS ) ) ) = ( succ ( IC Cs2i ) ) by A10,A7,A8,A12,SCMPDS_2:55
.= ( ICplusConst (Cs2i,1) ) by CKB12:1;
hence contradiction by A6,A3,A9,A5,A14,CKB10:1;
end;
now
assume that
A15: ( ( Comput (P1,s1,i) ) . ( DataLoc (( Cs1i . a ),k1) ) ) = ( 0 )
and
A16: ( ( Comput (P2,s2,i) ) . ( DataLoc (( Cs2i . a ),k1) ) ) <> ( 0 );
A17: ( Cs2i1 . ( IC ( SCMPDS ) ) ) = ( ICplusConst (Cs2i,k2) ) by A10,A7,A8,A16,SCMPDS_2:55;
( Cs1i1 . ( IC ( SCMPDS ) ) ) = ( succ ( IC Cs1i ) ) by A4,A8,A15,SCMPDS_2:55
.= ( ICplusConst (Cs1i,1) ) by CKB12:1;
hence contradiction by A6,A3,A9,A5,A17,CKB10:1;
end;
hence thesis by A11;
end;
