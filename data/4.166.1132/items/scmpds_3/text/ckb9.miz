environ
vocabularies NUMBERS,SUBSET_1,SCMPDS_2,INT_1,FSM_1,AMI_1,COMPLEX1,ARYTM_3,FUNCT_1,AMI_2,STRUCT_0,XBOOLE_0,RELAT_1,TARSKI,CARD_1,AMI_3,SCMPDS_1,GRAPHSP,SCMNORM,XXREAL_0,ARYTM_1,FUNCT_4,FUNCOP_1,FUNCT_7,CIRCUIT2,ORDINAL1,PARTFUN1,AMISTD_5,PBOOLE,AMISTD_2,FINSET_1,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,RELAT_1,FUNCT_1,PARTFUN1,PBOOLE,FUNCT_4,FINSET_1,INT_1,NAT_1,STRUCT_0,FUNCOP_1,INT_2,XXREAL_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,AMISTD_5,SCMPDS_1,SCMPDS_2,CKB8;
definitions EXTPRO_1,AMI_2,AMI_3,FUNCOP_1,SCMPDS_2,NAT_1,COMPOS_1,AMISTD_5,STRUCT_0,MEMSTR_0;
theorems AMI_3,GRFUNC_1,NAT_1,FUNCOP_1,TARSKI,FUNCT_4,FUNCT_1,ZFMISC_1,INT_1,RELAT_1,ABSVALUE,SCMPDS_2,XBOOLE_0,XBOOLE_1,NUMBERS,PBOOLE,PARTFUN1,COMPOS_1,EXTPRO_1,AMISTD_5,MEMSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,ORDINAL1,NUMBERS,XREAL_0,INT_1,CARD_3,AMI_3,SCMPDS_2,FINSET_1,RELSET_1,FUNCT_2,COMPOS_1,EXTPRO_1,AMISTD_5,PBOOLE,AMISTD_2,FUNCT_4,FUNCOP_1,MEMSTR_0;
constructors DOMAIN_1,XXREAL_0,INT_2,SCMPDS_1,SCMPDS_2,REAL_1,PRE_POLY,AMI_3,AMISTD_5,PBOOLE,AMISTD_1,FUNCT_7,MEMSTR_0,RELSET_1,CKB8;
requirements NUMERALS,SUBSET,BOOLE,ARITHM,REAL;
begin
registration
cluster ( SCMPDS ) ->  IC-recognized;
coherence
proof
let q being non halt-free  finite (the Instructions of ( SCMPDS )) -valued ( NAT ) -defined Function;
let p being q -autonomic (FinPartState of ( SCMPDS ));
assume that
A1: p is non empty;
assume A2: (not ( IC ( SCMPDS ) ) in ( dom p ));
(not ( IC ( SCMPDS ) ) in ( dom p )) by A2;
then A3: ( dom p ) misses { ( IC ( SCMPDS ) ) } by ZFMISC_1:50;
( dom p ) c= ( { ( IC ( SCMPDS ) ) } \/ ( dom ( DataPart p ) ) ) by MEMSTR_0:32;
then A4: ( dom p ) c= ( dom ( DataPart p ) ) by A3,XBOOLE_1:73;
A5: ( dom ( DataPart p ) ) <> ( {} ) by A1,A4,XBOOLE_1:3;
( DataPart p ) c= p by MEMSTR_0:12;
then A6: ( dom ( DataPart p ) ) c= ( dom p ) by RELAT_1:11;
(not p is q -autonomic)
proof
set il = the (Element of ( ( NAT ) \ ( dom q ) ));
set d1 = the (Element of ( dom ( DataPart p ) ));
A7: d1 in ( dom ( DataPart p ) ) by A5;
( dom ( DataPart p ) ) c= (the carrier of ( SCMPDS )) by RELAT_1:def 18;
then reconsider d1 as (Element of ( SCMPDS )) by A7;
(not ( NAT ) c= ( dom q ));
then A8: ( ( NAT ) \ ( dom q ) ) <> ( {} ) by XBOOLE_1:37;
then reconsider il as (Element of ( NAT )) by XBOOLE_0:def 5;
B8: (not il in ( dom q )) by A8,XBOOLE_0:def 5;
( dom ( DataPart p ) ) c= ( SCM-Data-Loc ) by RELAT_1:58,SCMPDS_2:84;
then reconsider d1 as Int_position by A7,SCMPDS_2:3;
( dom ( Start-At (il,( SCMPDS )) ) ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
then A11: ( IC ( SCMPDS ) ) in ( dom ( Start-At (il,( SCMPDS )) ) ) by TARSKI:def 1;
A13: ( dom p ) misses { ( IC ( SCMPDS ) ) } by A2,ZFMISC_1:50;
set p2 = ( p +* ( Start-At (il,( SCMPDS )) ) );
set p1 = ( p +* ( Start-At (il,( SCMPDS )) ) );
set q2 = ( q +* ( il .--> ( d1 := 1 ) ) );
set q1 = ( q +* ( il .--> ( d1 := ( 0 ) ) ) );
UU: ( dom ( il .--> ( d1 := 1 ) ) ) = { il } by FUNCOP_1:13;
then Y6: ( dom q ) misses ( dom ( il .--> ( d1 := 1 ) ) ) by B8,ZFMISC_1:50;
( dom ( il .--> ( d1 := ( 0 ) ) ) ) = { il } by FUNCOP_1:13;
then Y5: ( dom q ) misses ( dom ( il .--> ( d1 := ( 0 ) ) ) ) by B8,ZFMISC_1:50;
consider s1 being (State of ( SCMPDS )) such that A14: p1 c= s1 by PBOOLE:141;
consider S1 being (Instruction-Sequence of ( SCMPDS )) such that B14: q1 c= S1 by PBOOLE:145;
consider s2 being (State of ( SCMPDS )) such that A15: p2 c= s2 by PBOOLE:141;
consider S2 being (Instruction-Sequence of ( SCMPDS )) such that B15: q2 c= S2 by PBOOLE:145;
take P1 = S1;
take P2 = S2;
( dom ( Start-At (il,( SCMPDS )) ) ) = ( dom ( Start-At (il,( SCMPDS )) ) )
.= { ( IC ( SCMPDS ) ) } by FUNCOP_1:13
.= { ( IC ( SCMPDS ) ) };
then ( ( dom p ) /\ ( dom ( Start-At (il,( SCMPDS )) ) ) ) = ( ( dom p ) /\ { ( IC ( SCMPDS ) ) } )
.= ( {} ) by A13,XBOOLE_0:def 7
.= ( {} );
then ( dom p ) misses ( dom ( Start-At (il,( SCMPDS )) ) ) by XBOOLE_0:def 7;
then p c= p1 by FUNCT_4:32;
then A16: p c= s1 by A14,XBOOLE_1:1;
q c= q1 by Y5,FUNCT_4:32;
hence q c= P1 by B14,XBOOLE_1:1;
( dom ( Start-At (il,( SCMPDS )) ) ) = ( dom ( Start-At (il,( SCMPDS )) ) )
.= { ( IC ( SCMPDS ) ) } by FUNCOP_1:13
.= { ( IC ( SCMPDS ) ) };
then ( ( dom p ) /\ ( dom ( Start-At (il,( SCMPDS )) ) ) ) = ( ( dom p ) /\ { ( IC ( SCMPDS ) ) } )
.= ( {} ) by A13,XBOOLE_0:def 7
.= ( {} );
then ( dom p ) misses ( dom ( Start-At (il,( SCMPDS )) ) ) by XBOOLE_0:def 7;
then p c= p2 by FUNCT_4:32;
then A17: p c= s2 by A15,XBOOLE_1:1;
q c= q2 by Y6,FUNCT_4:32;
hence q c= P2 by B15,XBOOLE_1:1;
take s1;
take s2;
p c= s1 by A16;
hence p c= s1;
thus p c= s2 by A17;
take 1;
A18: ( dom p2 ) = ( ( dom p ) \/ ( dom ( Start-At (il,( SCMPDS )) ) ) ) by FUNCT_4:def 1;
B18: ( dom q2 ) = ( ( dom q ) \/ ( dom ( il .--> ( d1 := 1 ) ) ) ) by FUNCT_4:def 1;
A20: ( IC ( SCMPDS ) ) in ( dom ( Start-At (il,( SCMPDS )) ) ) by A11;
then ( IC ( SCMPDS ) ) in ( dom p2 ) by A18,XBOOLE_0:def 3;
then A21: ( IC s2 ) = ( p2 . ( IC ( SCMPDS ) ) ) by A15,GRFUNC_1:2
.= ( ( Start-At (il,( SCMPDS )) ) . ( IC ( SCMPDS ) ) ) by A20,FUNCT_4:13
.= ( ( Start-At (il,( SCMPDS )) ) . ( IC ( SCMPDS ) ) )
.= il by FUNCOP_1:72;
il in ( dom ( il .--> ( d1 := 1 ) ) ) by UU,TARSKI:def 1;
then A22: il in ( dom ( il .--> ( d1 := 1 ) ) );
then il in ( dom q2 ) by B18,XBOOLE_0:def 3;
then A23: ( S2 . il ) = ( q2 . il ) by B15,GRFUNC_1:2
.= ( ( il .--> ( d1 := 1 ) ) . il ) by A22,FUNCT_4:13
.= ( ( il .--> ( d1 := 1 ) ) . il )
.= ( d1 := 1 ) by FUNCOP_1:72;
A24: ( S2 /. ( IC s2 ) ) = ( S2 . ( IC s2 ) ) by PBOOLE:143;
A25: ( ( Comput (S2,s2,( ( 0 ) + 1 )) ) . d1 ) = ( ( Following (S2,( Comput (S2,s2,( 0 )) )) ) . d1 ) by EXTPRO_1:3
.= ( ( Following (S2,s2) ) . d1 ) by EXTPRO_1:2
.= 1 by A21,A23,A24,SCMPDS_2:45;
A26: ( dom p ) c= (the carrier of ( SCMPDS )) by RELAT_1:def 18;
( dom ( Comput (S1,s1,1) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2;
then A27: ( dom ( ( Comput (S1,s1,1) ) | ( dom p ) ) ) = ( dom p ) by A26,RELAT_1:62;
A29: ( dom p1 ) = ( ( dom p ) \/ ( dom ( Start-At (il,( SCMPDS )) ) ) ) by FUNCT_4:def 1;
B29: ( dom q1 ) = ( ( dom q ) \/ ( dom ( il .--> ( d1 := ( 0 ) ) ) ) ) by FUNCT_4:def 1;
A31: ( IC ( SCMPDS ) ) in ( dom ( Start-At (il,( SCMPDS )) ) ) by A11;
then ( IC ( SCMPDS ) ) in ( dom p1 ) by A29,XBOOLE_0:def 3;
then A32: ( IC s1 ) = ( p1 . ( IC ( SCMPDS ) ) ) by A14,GRFUNC_1:2
.= ( ( Start-At (il,( SCMPDS )) ) . ( IC ( SCMPDS ) ) ) by A31,FUNCT_4:13
.= ( ( Start-At (il,( SCMPDS )) ) . ( IC ( SCMPDS ) ) )
.= il by FUNCOP_1:72;
VV: ( dom ( il .--> ( d1 := ( 0 ) ) ) ) = { il } by FUNCOP_1:13;
il in ( dom ( il .--> ( d1 := ( 0 ) ) ) ) by VV,TARSKI:def 1;
then A33: il in ( dom ( il .--> ( d1 := ( 0 ) ) ) );
then il in ( dom q1 ) by B29,XBOOLE_0:def 3;
then A34: ( S1 . il ) = ( q1 . il ) by B14,GRFUNC_1:2
.= ( ( il .--> ( d1 := ( 0 ) ) ) . il ) by A33,FUNCT_4:13
.= ( ( il .--> ( d1 := ( 0 ) ) ) . il )
.= ( d1 := ( 0 ) ) by FUNCOP_1:72;
A35: ( S1 /. ( IC s1 ) ) = ( S1 . ( IC s1 ) ) by PBOOLE:143;
A36: ( dom ( Comput (S2,s2,1) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2;
A37: ( dom ( ( Comput (S2,s2,1) ) | ( dom p ) ) ) = ( dom p ) by A26,A36,RELAT_1:62;
( ( Comput (S1,s1,( ( 0 ) + 1 )) ) . d1 ) = ( ( Following (S1,( Comput (S1,s1,( 0 )) )) ) . d1 ) by EXTPRO_1:3
.= ( ( Following (S1,s1) ) . d1 ) by EXTPRO_1:2
.= ( 0 ) by A32,A34,A35,SCMPDS_2:45;
then ( ( ( Comput (S1,s1,1) ) | ( dom p ) ) . d1 ) = ( 0 ) by A7,A27,A6,FUNCT_1:47;
hence thesis by A25,A7,A37,A6,FUNCT_1:47;
end;
hence contradiction;
end;
end;
