environ
vocabularies NUMBERS,SUBSET_1,SCMPDS_2,INT_1,FSM_1,AMI_1,COMPLEX1,ARYTM_3,FUNCT_1,AMI_2,STRUCT_0,XBOOLE_0,RELAT_1,TARSKI,CARD_1,AMI_3,SCMPDS_1,GRAPHSP,SCMNORM,XXREAL_0,ARYTM_1,FUNCT_4,FUNCOP_1,FUNCT_7,CIRCUIT2,ORDINAL1,PARTFUN1,AMISTD_5,PBOOLE,AMISTD_2,FINSET_1,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,RELAT_1,FUNCT_1,PARTFUN1,PBOOLE,FUNCT_4,FINSET_1,INT_1,NAT_1,STRUCT_0,FUNCOP_1,INT_2,XXREAL_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,AMISTD_5,SCMPDS_1,SCMPDS_2,CKB8;
definitions EXTPRO_1,AMI_2,AMI_3,FUNCOP_1,SCMPDS_2,NAT_1,COMPOS_1,AMISTD_5,STRUCT_0,MEMSTR_0;
theorems AMI_3,GRFUNC_1,NAT_1,FUNCOP_1,TARSKI,FUNCT_4,FUNCT_1,ZFMISC_1,INT_1,RELAT_1,ABSVALUE,SCMPDS_2,XBOOLE_0,XBOOLE_1,NUMBERS,PBOOLE,PARTFUN1,COMPOS_1,EXTPRO_1,AMISTD_5,MEMSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB10,CKB11,CKB12;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,ORDINAL1,NUMBERS,XREAL_0,INT_1,CARD_3,AMI_3,SCMPDS_2,FINSET_1,RELSET_1,FUNCT_2,COMPOS_1,EXTPRO_1,AMISTD_5,PBOOLE,AMISTD_2,FUNCT_4,FUNCOP_1,MEMSTR_0,CKB9;
constructors DOMAIN_1,XXREAL_0,INT_2,SCMPDS_1,SCMPDS_2,REAL_1,PRE_POLY,AMI_3,AMISTD_5,PBOOLE,AMISTD_1,FUNCT_7,MEMSTR_0,RELSET_1,CKB8;
requirements NUMERALS,SUBSET,BOOLE,ARITHM,REAL;
begin
reserve k for (Element of ( NAT ));
reserve P for (Instruction-Sequence of ( SCMPDS ));
registration
cluster ( SCMPDS ) ->  CurIns-recognized;
coherence
proof
let q being non  halt-free  finite (the Instructions of ( SCMPDS )) -valued ( NAT ) -defined Function;
let p being q -autonomic non  empty (FinPartState of ( SCMPDS ));
let s being (State of ( SCMPDS ));
assume that
A1: p c= s;
let P being (Instruction-Sequence of ( SCMPDS ));
assume that
A2: q c= P;
let i being (Element of ( NAT ));
set Csi = ( Comput (P,s,i) );
set loc = ( IC Csi );
set loc1 = ( loc + 1 );
assume (not ( IC ( Comput (P,s,i) ) ) in ( dom q ));
then A4: (not loc in ( dom q ));
set I = ( the Int_position := ( 0 ) );
set q1 = ( q +* ( loc .--> I ) );
set q2 = ( q +* ( loc .--> ( halt ( SCMPDS ) ) ) );
reconsider P1 = ( P +* ( loc .--> I ) ) as (Instruction-Sequence of ( SCMPDS ));
reconsider P2 = ( P +* ( loc .--> ( halt ( SCMPDS ) ) ) ) as (Instruction-Sequence of ( SCMPDS ));
A6: ( dom ( loc .--> ( halt ( SCMPDS ) ) ) ) = { loc } by FUNCOP_1:13;
then A7: loc in ( dom ( loc .--> ( halt ( SCMPDS ) ) ) ) by TARSKI:def 1;
A12: ( dom ( loc .--> I ) ) = { loc } by FUNCOP_1:13;
then A13: loc in ( dom ( loc .--> I ) ) by TARSKI:def 1;
Y6: ( dom q ) misses ( dom ( loc .--> ( halt ( SCMPDS ) ) ) ) by A4,A6,ZFMISC_1:50;
Y5: ( dom q ) misses ( dom ( loc .--> I ) ) by A4,A12,ZFMISC_1:50;
P3: q1 c= P1 by A2,FUNCT_4:123;
P4: q2 c= P2 by A2,FUNCT_4:123;
set Cs2i = ( Comput (P2,s,i) );
set Cs1i = ( Comput (P1,s,i) );
(not p is q -autonomic)
proof
( ( loc .--> ( halt ( SCMPDS ) ) ) . loc ) = ( halt ( SCMPDS ) ) by FUNCOP_1:72;
then A18: ( P2 . loc ) = ( halt ( SCMPDS ) ) by A7,FUNCT_4:13;
( ( loc .--> I ) . loc ) = I by FUNCOP_1:72;
then A19: ( P1 . loc ) = I by A13,FUNCT_4:13;
take P1;
take P2;
q c= q1 by Y5,FUNCT_4:32;
hence A25: q c= P1 by P3,XBOOLE_1:1;
q c= q2 by Y6,FUNCT_4:32;
hence A27: q c= P2 by P4,XBOOLE_1:1;
take s;
take s;
thus p c= s by A1;
A28: ( Cs1i | ( dom p ) ) = ( Csi | ( dom p ) ) by A25,A2,A1,EXTPRO_1:def 10;
thus p c= s by A1;
A29: ( Cs1i | ( dom p ) ) = ( Cs2i | ( dom p ) ) by A25,A27,A1,EXTPRO_1:def 10;
take k = ( i + 1 );
set Cs1k = ( Comput (P1,s,k) );
A33: ( IC ( SCMPDS ) ) in ( dom p ) by AMISTD_5:6;
( IC Csi ) = ( IC ( Csi | ( dom p ) ) ) by A33,FUNCT_1:49;
then ( IC Cs1i ) = loc by A28,A33,FUNCT_1:49;
then XX: ( CurInstr (P1,Cs1i) ) = ( P1 . loc ) by PBOOLE:143
.= I by A19;
A31: Cs1k = ( Following (P1,Cs1i) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (P1,Cs1i) ),Cs1i) )
.= ( Exec (I,Cs1i) ) by XX;
A32: ( IC ( Exec (I,Cs1i) ) ) = ( succ ( IC Cs1i ) ) by SCMPDS_2:45;
A33: ( IC ( SCMPDS ) ) in ( dom p ) by AMISTD_5:6;
A34: ( IC Csi ) = ( IC ( Csi | ( dom p ) ) ) by A33,FUNCT_1:49;
then ( IC Cs1i ) = loc by A28,A33,FUNCT_1:49;
then A35: ( IC Cs1k ) = ( succ loc ) by A31,A32
.= loc1;
set Cs2k = ( Comput (P2,s,k) );
A36: Cs2k = ( Following (P2,Cs2i) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (P2,Cs2i) ),Cs2i) );
A37: ( P2 /. ( IC Cs2i ) ) = ( P2 . ( IC Cs2i ) ) by PBOOLE:143;
( IC Cs2i ) = loc by A28,A34,A29,A33,FUNCT_1:49;
then A38: ( IC Cs2k ) = loc by A36,A18,A37,EXTPRO_1:def 3;
(( IC ( Cs1k | ( dom p ) ) ) = ( IC Cs1k ) & ( IC ( Cs2k | ( dom p ) ) ) = ( IC Cs2k )) by A33,FUNCT_1:49;
hence thesis by A35,A38;
end;
hence contradiction;
end;
end;
