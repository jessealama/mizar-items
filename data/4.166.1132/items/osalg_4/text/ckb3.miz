environ
vocabularies NUMBERS,XBOOLE_0,ORDERS_2,MSUALG_4,OSALG_1,RELAT_1,STRUCT_0,FUNCOP_1,PBOOLE,SUBSET_1,XXREAL_0,FUNCT_1,MSUALG_1,TARSKI,EQREL_1,NAT_1,MARGREL1,PARTFUN1,FINSEQ_1,ARYTM_3,ARYTM_1,ZFMISC_1,FINSEQ_5,CARD_1,RELAT_2,ORDINAL4,NATTRA_1,YELLOW15,SETFAM_1,COH_SP,YELLOW18,WAYBEL_0,CARD_3,MSUALG_3,WELLORD1,SEQM_3,OSALG_4;
notations ZFMISC_1,TARSKI,XBOOLE_0,SUBSET_1,RELAT_1,RELAT_2,FUNCT_1,RELSET_1,PARTFUN1,EQREL_1,SETFAM_1,XCMPLX_0,ORDERS_2,ORDERS_3,NUMBERS,NAT_1,FUNCT_2,FINSEQ_1,CARD_3,FINSEQ_2,FINSEQ_4,FINSEQ_5,FUNCOP_1,PBOOLE,STRUCT_0,WAYBEL_0,MSUALG_1,MSUALG_3,OSALG_1,OSALG_3,MSUALG_4,XXREAL_0,CKB2;
definitions TARSKI,MSUALG_3,XBOOLE_0,OSALG_1,OSALG_3,CKB2;
theorems XBOOLE_0,XBOOLE_1,FUNCT_1,FUNCT_2,PBOOLE,CARD_3,MSUALG_1,MSUALG_5,OSALG_1,OSALG_3,RELAT_2,ZFMISC_1,RELAT_1,RELSET_1,EQREL_1,MSUALG_3,MSUALG_6,MSAFREE,TARSKI,SYSREL,ORDERS_2,FINSEQ_1,FINSEQ_3,ENUMSET1,FINSEQ_5,INT_1,ORDERS_3,PARTFUN1,WAYBEL_0,GRFUNC_1,MSUALG_9,MSUALG_4,FINSEQ_2,ORDERS_1,FUNCOP_1,XREAL_1,XXREAL_0,CKB2;
schemes FUNCT_1,CLASSES1,NAT_1,FUNCT_2;
registrations SUBSET_1,RELAT_1,PARTFUN1,FUNCOP_1,XREAL_0,INT_1,FINSEQ_1,EQREL_1,FUNCT_1,PBOOLE,STRUCT_0,MSUALG_1,MSUALG_3,MSUALG_4,ORDERS_3,OSALG_1,ORDINAL1,CARD_3,TOLER_1,RELSET_1,FINSEQ_2,CKB1;
constructors XXREAL_0,REAL_1,NAT_1,NAT_D,EQREL_1,FINSEQ_4,FINSEQ_5,MSUALG_3,MSUALG_4,ORDERS_3,WAYBEL_0,OSALG_3,RELSET_1,CKB2;
requirements BOOLE,SUBSET,NUMERALS,REAL,ARITHM;
begin
registration
let R being non  empty Poset;
let A being (ManySortedSet of (the carrier of R));
let B being (ManySortedSet of (the carrier of R));
cluster  os-compatible for (ManySortedRelation of A,B);
existence
proof
set I = (the carrier of R);
consider R1 being Relation such that A1: R1 = ( {} );
set f = ( I --> R1 );
reconsider f as (ManySortedSet of R);
set f1 = f;
(for i being set holds (i in I implies ( f . i ) is (Relation of ( A . i ),( B . i ))))
proof
let i being set;
assume i in I;
then ( f . i ) = ( {} ) by A1,FUNCOP_1:7;
hence thesis by RELSET_1:12;
end;
then reconsider f2 = f1 as (ManySortedRelation of A,B) by MSUALG_4:def 1;
take f;
(for s1,s2 being (Element of R) holds (s1 <= s2 implies (for x,y being set holds ((x in ( A . s1 ) & y in ( B . s1 )) implies ([ x,y ] in ( f1 . s1 ) iff [ x,y ] in ( f1 . s2 ))))))
proof
let s1 being (Element of R);
let s2 being (Element of R);
assume that
s1 <= s2;
let x being set;
let y being set;
assume that
x in ( A . s1 )
and
y in ( B . s1 );
( f1 . s1 ) = R1 by FUNCOP_1:7
.= ( f1 . s2 ) by FUNCOP_1:7;
hence thesis;
end;
then f2 is  os-compatible by CKB2:def 1;
hence thesis;
end;
end;
