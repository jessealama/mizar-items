environ
vocabularies SUBSET_1,STRUCT_0,NORMSP_1,FUNCT_1,NUMBERS,REAL_1,XBOOLE_0,FUNCT_5,FUNCOP_1,CARD_1,METRIC_1,RELAT_2,SUPINF_2,XCMPLX_0,NAT_1,SEQ_1,RELAT_1,TARSKI,PARTFUN1,NORMSP_0;
notations TARSKI,XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCOP_1,FUNCT_5,NUMBERS,XCMPLX_0,REAL_1,NAT_1,SEQ_1,STRUCT_0,CKB1,CKB4,CKB5,CKB7;
definitions TARSKI,FUNCT_5,FUNCOP_1,RELAT_1,FUNCT_1,FUNCT_2,STRUCT_0,CKB4,CKB5,CKB7;
theorems CARD_1,FUNCOP_1,TARSKI,FUNCT_1,RELAT_1,RELSET_1,PARTFUN1,FUNCT_2,CKB2,CKB4,CKB5,CKB7;
schemes FUNCT_1;
registrations STRUCT_0,RELSET_1,XBOOLE_0,REAL_1,NUMBERS,FUNCOP_1,XREAL_0,NAT_1,ORDINAL1,XCMPLX_0,FUNCT_1,FUNCT_2,CKB1,CKB3,CKB6;
constructors FUNCT_2,NUMBERS,STRUCT_0,FUNCT_5,FUNCOP_1,XCMPLX_0,RELSET_1,CKB1,CKB4,CKB5,CKB7;
requirements BOOLE,SUBSET;
begin
reserve X for non  empty N-Str;
definition
let X;
let s being (sequence of X);
redefine func ||.s .|| -> Real_Sequence means 
(for n being (Element of ( NAT )) holds ( it . n ) = ||. ( s . n ) .||);
coherence
proof
A1: ( dom ||. s .|| ) = ( dom s ) by CKB5:def 1
.= ( NAT ) by PARTFUN1:def 2;
( rng ||. s .|| ) c= ( REAL ) by RELAT_1:def 19;
hence ||. s .|| is Real_Sequence by A1,FUNCT_2:2;
end;
compatibility
proof
let S being Real_Sequence;
A2: ( dom S ) = ( NAT ) by PARTFUN1:def 2;
A3: ( dom s ) = ( NAT ) by PARTFUN1:def 2;
thus (S = ||. s .|| implies (for n being (Element of ( NAT )) holds ( S . n ) = ||. ( s . n ) .||))
proof
assume A4: S = ||. s .||;
let n being (Element of ( NAT ));
( ||. s .|| . n ) = ||. ( s /. n ) .|| by CKB5:def 1,A2,A4;
hence ( S . n ) = ||. ( s . n ) .|| by A4;
end;

assume A5: (for n being (Element of ( NAT )) holds ( S . n ) = ||. ( s . n ) .||);
(for e being set holds (e in ( dom s ) implies ( S . e ) = ||. ( s /. e ) .||))
proof
let e being set;
assume A6: e in ( dom s );
then reconsider n = e as (Element of ( NAT )) by PARTFUN1:def 2;
thus ( S . e ) = ||. ( s . n ) .|| by A5
.= ||. ( s /. e ) .|| by A6,PARTFUN1:def 6;
end;
hence S = ||. s .|| by A2,A3,CKB5:def 1;
end;
end;
