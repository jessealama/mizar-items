environ
vocabularies NUMBERS,ORDINAL1,REAL_1,SUBSET_1,CARD_1,ARYTM_3,XREAL_0,TARSKI,RELAT_1,XXREAL_0,XCMPLX_0,ARYTM_1,XBOOLE_0,FINSET_1,FUNCT_1,NAT_1,FUNCOP_1,PBOOLE,PARTFUN1;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,FINSET_1,CARD_1,PBOOLE,NUMBERS,XCMPLX_0,XREAL_0,REAL_1,XXREAL_0,RELAT_1,FUNCT_1,PARTFUN1,FUNCOP_1,FUNCT_2,CKB1,CKB4,CKB5,CKB9,CKB10;
definitions TARSKI,XBOOLE_0,CARD_1,RELAT_1,FUNCT_1;
theorems AXIOMS,ORDINAL1,XCMPLX_1,XREAL_1,XXREAL_0,TARSKI,ORDINAL2,XBOOLE_1,XBOOLE_0,CARD_1,FUNCT_2,FUNCT_1,FUNCOP_1,PBOOLE,RELSET_1,RELAT_1,PARTFUN1,CKB2,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB21,CKB22,CKB23,CKB24,CKB28,CKB29,CKB30,CKB31,CKB32;
schemes SUBSET_1,ORDINAL2,FUNCT_2,FRAENKEL,PBOOLE,CKB6,CKB7,CKB20,CKB25,CKB26,CKB27,CKB33;
registrations SUBSET_1,ORDINAL1,NUMBERS,XXREAL_0,XREAL_0,REAL_1,CARD_1,RELSET_1,FUNCT_2,PBOOLE,CKB3,CKB8,CKB17,CKB18,CKB19;
constructors NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,CARD_1,WELLORD2,FUNCT_2,PARTFUN1,FUNCOP_1,FUNCT_4,ENUMSET1,RELSET_1,PBOOLE,CKB4,CKB5,CKB9,CKB10;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve k for Nat;
reserve m for Nat;
reserve n for Nat;
reserve k1 for Nat;
reserve t for Nat;
reserve t1 for Nat;
theorem
(( 0 ) < m implies (for n holds (ex k st (ex t st (n = ( ( m * k ) + t ) & t < m)))))
proof
defpred P[ Nat ]
 means
(ex k st (ex t st ($1 = ( ( m * k ) + t ) & t < m)));
assume A1: ( 0 ) < m;
A2: (for n holds (P[ n ] implies P[ ( n + 1 ) ]))
proof
let n;
given k1,t1 such that
A3: n = ( ( m * k1 ) + t1 )
and
A4: t1 < m;

A5: (( t1 + 1 ) < m implies (ex k st (ex t st (( n + 1 ) = ( ( m * k ) + t ) & t < m))))
proof
assume A6: ( t1 + 1 ) < m;
take k = k1;
take t = ( t1 + 1 );
thus ( n + 1 ) = ( ( m * k ) + t ) by A3;
thus thesis by A6;
end;
A7: (( t1 + 1 ) = m implies (ex k st (ex t st (( n + 1 ) = ( ( m * k ) + t ) & t < m))))
proof
assume A8: ( t1 + 1 ) = m;
take k = ( k1 + 1 );
take t = ( 0 );
thus ( n + 1 ) = ( ( m * k ) + t ) by A3,A8;
thus thesis by A1;
end;
( t1 + 1 ) <= m by A4,CKB29:1;
hence thesis by A5,A7,XXREAL_0:1;
end;
( 0 ) = ( ( m * ( 0 ) ) + ( 0 ) );
then A9: P[ ( 0 ) ] by A1;
thus (for n holds P[ n ]) from CKB7:sch 1(A9,A2);
end;
