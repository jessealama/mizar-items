environ
vocabularies NUMBERS,REAL_3,FINSEQ_1,RELAT_1,TARSKI,VALUED_0,ORDINAL1,RFINSEQ,XXREAL_0,ARYTM_1,SUBSET_1,FUNCT_1,ARYTM_3,INT_1,ORDINAL4,XBOOLE_0,NAT_1,VALUED_1,CARD_3,BINOP_2,SETWISEO,BINOP_1,SETWOP_2,CARD_1,FINSOP_1,PARTFUN1,COMPLEX1,INT_2,PARTFUN3,XREAL_0,INT_6;
notations TARSKI,XBOOLE_0,SUBSET_1,INT_1,INT_2,ORDINAL1,NUMBERS,PARTFUN1,PARTFUN3,REAL_3,XXREAL_0,XREAL_0,FUNCT_1,VALUED_0,VALUED_1,BINOP_2,SETWISEO,RFINSEQ,BINOP_1,FINSEQ_1,SETWOP_2,RVSUM_1,XCMPLX_0,NAT_1,FINSOP_1;
definitions INT_2,XCMPLX_0,FINSEQ_1,FUNCT_1;
theorems INT_1,FUNCT_1,FINSEQ_1,RVSUM_1,NAT_1,SETWOP_2,FINSEQ_3,BINOP_2,SETWISEO,TARSKI,NAT_D,INT_2,XCMPLX_0,XCMPLX_1,XREAL_1,RFINSEQ,FINSEQ_5,FINSEQ_2,ABSVALUE,PARTFUN3,XBOOLE_0,XXREAL_0,ORDINAL1,XBOOLE_1,PARTFUN1,XREAL_0,WSIERP_1,VALUED_0,VALUED_1,COMPLEX1,CKB1,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB16,CKB17;
schemes FINSEQ_1,NAT_1,INT_1;
registrations NUMBERS,XREAL_0,NAT_1,INT_1,RELAT_1,FINSEQ_1,RVSUM_1,XBOOLE_0,MEMBERED,BINOP_2,ORDINAL1,XXREAL_0,VALUED_0,VALUED_1,FUNCT_1,CARD_1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB14,CKB15;
constructors FINSOP_1,RFINSEQ,INT_2,BINOP_2,REAL_1,SETWISEO,SETWOP_2,PARTFUN3,XXREAL_0,RVSUM_1,BINOP_1,RELSET_1;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
theorem
Th6: (for f being  complex-valued FinSequence holds ((ex i being  natural number st (i in ( dom f ) & ( f . i ) = ( 0 ))) implies ( Product f ) = ( 0 )))
proof
defpred P[ Nat ]
 means
(for f being  complex-valued FinSequence holds (( len f ) = $1 implies ((ex i being  natural number st (i in ( dom f ) & ( f . i ) = ( 0 ))) implies ( Product f ) = ( 0 ))));
let m being  complex-valued FinSequence;
A1: (for k being (Element of ( NAT )) holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume A2: P[ k ];
now
let f being  complex-valued FinSequence;
set f1 = ( f | k );
assume A3: ( len f ) = ( k + 1 );
then A4: ( len f1 ) = k by FINSEQ_1:59,NAT_1:11;
reconsider f1 as  complex-valued FinSequence;
f = ( f1 ^ <* ( f . ( k + 1 ) ) *> ) by A3,FINSEQ_3:55;
then A5: ( Product f ) = ( ( Product f1 ) * ( f . ( k + 1 ) ) ) by RVSUM_1:96;
assume A6: (ex i being  natural number st (i in ( dom f ) & ( f . i ) = ( 0 )));
per cases ;
suppose ( f . ( k + 1 ) ) = ( 0 );

hence ( Product f ) = ( 0 ) by A5;
end;
suppose A7: ( f . ( k + 1 ) ) <> ( 0 );

consider j being  natural number such that A8: j in ( dom f ) and A9: ( f . j ) = ( 0 ) by A6;
reconsider j as (Element of ( NAT )) by ORDINAL1:def 12;
A10: j in ( Seg ( len f ) ) by A8,FINSEQ_1:def 3;
then j <= ( k + 1 ) by A3,FINSEQ_1:1;
then j < ( k + 1 ) by A7,A9,XXREAL_0:1;
then A11: j <= k by NAT_1:13;
1 <= j by A10,FINSEQ_1:1;
then j in ( Seg k ) by A11;
then A12: j in ( dom f1 ) by A4,FINSEQ_1:def 3;
then ( f1 . j ) = ( f . j ) by FUNCT_1:47;
then ( Product f1 ) = ( 0 ) by A2,A4,A9,A12;
hence ( Product f ) = ( 0 ) by A5;
end;
end;
hence thesis;
end;
A13: P[ ( 0 ) ]
proof
let f being  complex-valued FinSequence;
assume ( len f ) = ( 0 );
then ( Seg ( len f ) ) = ( {} );
hence thesis by FINSEQ_1:def 3;
end;
A14: (for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A13,A1);
A15: (ex j being Nat st ( len m ) = j);
assume (ex i being  natural number st (i in ( dom m ) & ( m . i ) = ( 0 )));
hence thesis by A14,A15;
end;
