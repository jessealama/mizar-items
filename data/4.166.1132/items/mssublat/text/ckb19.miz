environ
vocabularies NAT_1,PBOOLE,FUNCT_1,CARD_1,XBOOLE_0,FINSEQ_2,FINSEQ_1,RELAT_1,TARSKI,NUMBERS,SUBSET_1,UNIALG_1,UNIALG_2,MSUALG_1,FUNCOP_1,CQC_SIM1,STRUCT_0,MSUALG_2,MARGREL1,PARTFUN1,CARD_3,FUNCT_2,ZFMISC_1,EQREL_1,INCPROJ,WELLORD1,GROUP_6,LATTICES;
notations TARSKI,XBOOLE_0,SUBSET_1,BINOP_1,CARD_3,NAT_1,LATTICES,LATTICE4,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCOP_1,STRUCT_0,PBOOLE,UNIALG_1,UNIALG_2,NUMBERS,FINSEQ_1,FINSEQ_2,MARGREL1,MSUALG_1,MSUALG_2;
definitions TARSKI,XBOOLE_0,MSUALG_2,PBOOLE,LATTICE4,UNIALG_1,UNIALG_2,FUNCOP_1,FINSEQ_2,FUNCT_2,MARGREL1;
theorems MSUALG_1,MSUALG_2,PBOOLE,TARSKI,UNIALG_1,UNIALG_2,FUNCT_1,RELAT_1,FUNCOP_1,PARTFUN1,FUNCT_2,FINSEQ_1,FINSEQ_2,FINSEQ_3,ZFMISC_1,CARD_3,LATTICES,MSUHOM_1,XBOOLE_0,XBOOLE_1,ORDINAL1,STRUCT_0,MARGREL1,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18;
schemes FUNCT_2;
registrations XBOOLE_0,FUNCT_1,ORDINAL1,RELSET_1,FUNCOP_1,FINSEQ_2,RELAT_1,PBOOLE,STRUCT_0,UNIALG_1,UNIALG_2,MSUALG_1,MSUALG_2,FINSEQ_1,MARGREL1,CARD_1;
constructors BINOP_1,CARD_3,FINSEQOP,FILTER_1,UNIALG_2,LATTICE4,MSUALG_2,RELSET_1,MARGREL1,NAT_1;
requirements NUMERALS,SUBSET,BOOLE;
begin
reserve MS for  segmental non  void 1 -element ManySortedSign;
reserve A for  non-empty MSAlgebra over MS;
theorem
Th19: (for B being  non-empty (MSSubAlgebra of A) holds (for S being non  empty (Subset of ( 1-Alg A )) holds (S = (the carrier of ( 1-Alg B )) implies (the charact of ( 1-Alg B )) = ( Opers (( 1-Alg A ),S) ))))
proof
let B being  non-empty (MSSubAlgebra of A);
reconsider C = (the Sorts of B) as (MSSubset of A) by MSUALG_2:def 9;
A1: (the Charact of B) = ( Opers (A,C) ) by MSUALG_2:def 9;
set 1B = ( 1-Alg B );
set 1A = ( 1-Alg A );
A2: ( 1-Alg A ) = UAStr (# ( the_sort_of A ),( the_charact_of A ) #) by MSUALG_1:def 14;
set f1 = (the charact of 1B);
let S being non  empty (Subset of ( 1-Alg A ));
assume that
A3: S = (the carrier of ( 1-Alg B ));
reconsider f1 as (PFuncFinSequence of S) by A3;
A4: ( 1-Alg B ) = UAStr (# ( the_sort_of B ),( the_charact_of B ) #) by MSUALG_1:def 14;
then A5: f1 = (the Charact of B) by MSUALG_1:def 13;
A6: C is  opers_closed by MSUALG_2:def 9;
A7: (for n being set holds (for o being (operation of 1A) holds ((n in ( dom f1 ) & o = ( (the charact of 1A) . n )) implies ( f1 . n ) = ( o /. S ))))
proof
let n being set;
let o being (operation of 1A);
assume that
A8: n in ( dom f1 )
and
A9: o = ( (the charact of 1A) . n );
reconsider y = n as (OperSymbol of MS) by A5,A8,PARTFUN1:def 2;
o = ( (the Charact of A) . y ) by A2,A9,MSUALG_1:def 13
.= ( Den (y,A) ) by MSUALG_1:def 6;
then A10: ( dom o ) = ( Args (y,A) ) by FUNCT_2:def 1
.= ( ( len ( the_arity_of y ) ) -tuples_on ( the_sort_of A ) ) by MSUALG_1:6;
now
set a = the (Element of ( ( len ( the_arity_of y ) ) -tuples_on ( the_sort_of A ) ));
a in ( dom o ) by A10;
hence (ex x being FinSequence st x in ( dom o ));
let x being FinSequence;
assume x in ( dom o );
then (ex s being (Element of ( ( the_sort_of A ) * )) st (x = s & ( len s ) = ( len ( the_arity_of y ) ))) by A10;
hence ( len ( the_arity_of y ) ) = ( len x );
end;
then A11: ( arity o ) = ( len ( the_arity_of y ) ) by MARGREL1:def 25;
S is  opers_closed by A3,CKB18:1;
then A12: S is_closed_on o by UNIALG_2:def 4;
A13: C is_closed_on y by A6,MSUALG_2:def 6;
A14: ( ( ( C # ) * (the Arity of MS) ) . y ) = ( Args (y,B) ) by MSUALG_1:def 4
.= ( ( arity o ) -tuples_on S ) by A4,A3,A11,MSUALG_1:6;
( f1 . n ) = ( (the Charact of B) . y ) by A4,MSUALG_1:def 13
.= ( y /. C ) by A1,MSUALG_2:def 8
.= ( ( Den (y,A) ) | ( ( ( C # ) * (the Arity of MS) ) . y ) ) by A13,MSUALG_2:def 7
.= ( ( (the Charact of A) . y ) | ( ( ( C # ) * (the Arity of MS) ) . y ) ) by MSUALG_1:def 6
.= ( o | ( ( arity o ) -tuples_on S ) ) by A2,A9,A14,MSUALG_1:def 13;
hence thesis by A12,UNIALG_2:def 5;
end;
( dom f1 ) = (the carrier' of MS) by A5,PARTFUN1:def 2
.= ( dom (the Charact of A) ) by PARTFUN1:def 2
.= ( dom (the charact of 1A) ) by A2,MSUALG_1:def 13;
hence thesis by A7,UNIALG_2:def 6;
end;
