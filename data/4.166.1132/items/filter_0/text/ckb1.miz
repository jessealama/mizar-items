environ
vocabularies LATTICES,SUBSET_1,XBOOLE_0,PBOOLE,EQREL_1,CARD_FIL,STRUCT_0,TARSKI,ORDINAL1,ZFMISC_1,SETFAM_1,INT_2,XBOOLEAN,BINOP_1,REALSET1,FUNCT_1,RELAT_1,MCART_1,XXREAL_2,RELAT_2,FILTER_0;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,SETFAM_1,FUNCT_1,MCART_1,ORDINAL1,RELAT_2,FUNCT_2,BINOP_1,REALSET1,STRUCT_0,LATTICES,DOMAIN_1,RELAT_1,RELSET_1,EQREL_1;
definitions TARSKI,XBOOLE_0,LATTICES,RELAT_1,RELAT_2,BINOP_1,REALSET1,STRUCT_0;
theorems TARSKI,ZFMISC_1,SETFAM_1,FUNCT_1,MCART_1,FUNCT_2,LATTICES,RELAT_1,ORDERS_1,RLSUB_2,WELLSET1,RELSET_1,ORDINAL1,XBOOLE_0,XBOOLE_1,PARTFUN1,RELAT_2,SUBSET_1;
schemes RELAT_1,XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,RELSET_1,STRUCT_0,LATTICES;
constructors SETFAM_1,RELAT_2,ORDINAL1,PARTFUN1,BINOP_1,REALSET1,LATTICES,RELSET_1;
requirements SUBSET,BOOLE;
begin
reserve L for Lattice;
reserve p for (Element of L);
reserve q for (Element of L);
reserve r for (Element of L);
theorem
Th1: (for L being  join-associative  join-commutative  meet-commutative  join-absorbing  meet-absorbing non  empty LattStr holds (for p,q,r being (Element of L) holds (p [= q implies ( r "\/" p ) [= ( r "\/" q ))))
proof
let L being  join-associative  join-commutative  meet-commutative  join-absorbing  meet-absorbing non  empty LattStr;
let p being (Element of L);
let q being (Element of L);
let r being (Element of L);
assume A1: ( p "\/" q ) = q;
thus ( ( r "\/" p ) "\/" ( r "\/" q ) ) = ( ( r "\/" ( r "\/" p ) ) "\/" q ) by LATTICES:def 5
.= ( ( ( r "\/" r ) "\/" p ) "\/" q ) by LATTICES:def 5
.= ( ( r "\/" p ) "\/" q ) by LATTICES:1
.= ( r "\/" q ) by A1,LATTICES:def 5;
end;
