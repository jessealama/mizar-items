environ
vocabularies NUMBERS,ZF_LANG,XBOOLE_0,SUBSET_1,FUNCT_1,ZF_MODEL,ARYTM_3,TARSKI,XBOOLEAN,BVFUNC_2,ZF_LANG1,FINSET_1,RELAT_1,CARD_1,XXREAL_0,ZFMODEL1;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,NUMBERS,NAT_1,RELAT_1,FUNCT_1,FINSET_1,PARTFUN1,FUNCT_2,ZF_LANG,ZF_MODEL,ZFMODEL1,ZF_LANG1,XXREAL_0;
definitions TARSKI,ZF_MODEL,ZFMODEL1,XBOOLE_0,FUNCT_2;
theorems TARSKI,ZFMISC_1,ENUMSET1,NAT_1,FUNCT_1,FUNCT_2,ZF_MODEL,ZFMODEL1,ZF_LANG1,RELSET_1,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,FUNCT_7,CKB1,CKB2;
schemes NAT_1,PARTFUN1,ZF_LANG1;
registrations FUNCT_1,RELSET_1,FUNCT_2,FINSET_1,XXREAL_0,XREAL_0,FINSEQ_1,ZF_LANG,ORDINAL1,CKB3;
constructors ENUMSET1,PARTFUN1,XXREAL_0,XREAL_0,NAT_1,ZF_MODEL,ZFMODEL1,ZF_LANG1,RELSET_1;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve x for Variable;
reserve y for Variable;
reserve i for (Element of ( NAT ));
reserve j for (Element of ( NAT ));
reserve k for (Element of ( NAT ));
reserve H for ZF-formula;
reserve H1 for ZF-formula;
reserve H2 for ZF-formula;
theorem
Th4: ((ex i st (for j holds (( x. j ) in ( variables_in H ) implies j < i))) & (ex x st (not x in ( variables_in H ))))
proof
defpred P[ ZF-formula ]
 means
(ex i st (for j holds (( x. j ) in ( variables_in $1 ) implies j < i)));
A1: (for x holds (for y holds (P[ ( x '=' y ) ] & P[ ( x 'in' y ) ])))
proof
let x;
let y;
consider i such that A2: x = ( x. i ) by ZF_LANG1:77;
consider j such that A3: y = ( x. j ) by ZF_LANG1:77;
j <= ( j + i ) by NAT_1:11;
then A4: j < ( ( i + j ) + 1 ) by NAT_1:13;
i <= ( i + j ) by NAT_1:11;
then A5: i < ( ( i + j ) + 1 ) by NAT_1:13;
A6: ( variables_in ( x '=' y ) ) = { x,y } by ZF_LANG1:138;
thus P[ ( x '=' y ) ]
proof
take ( ( i + j ) + 1 );
let k being (Element of ( NAT ));
assume ( x. k ) in ( variables_in ( x '=' y ) );
then (( x. k ) = ( x. i ) or ( x. k ) = ( x. j )) by A2,A3,A6,TARSKI:def 2;
hence thesis by A5,A4,ZF_LANG1:76;
end;

take ( ( i + j ) + 1 );
let k being (Element of ( NAT ));
A7: ( variables_in ( x 'in' y ) ) = { x,y } by ZF_LANG1:139;
assume ( x. k ) in ( variables_in ( x 'in' y ) );
then (( x. k ) = ( x. i ) or ( x. k ) = ( x. j )) by A2,A3,A7,TARSKI:def 2;
hence thesis by A5,A4,ZF_LANG1:76;
end;
A8: (for H1 holds (for H2 holds ((P[ H1 ] & P[ H2 ]) implies P[ ( H1 '&' H2 ) ])))
proof
let H1;
let H2;
given i1 being (Element of ( NAT )) such that
A9: (for j holds (( x. j ) in ( variables_in H1 ) implies j < i1));

given i2 being (Element of ( NAT )) such that
A10: (for j holds (( x. j ) in ( variables_in H2 ) implies j < i2));

(i1 <= i2 or i1 > i2);
then consider i such that A11: ((i1 <= i2 & i = i2) or (i1 > i2 & i = i1));
take i;
let j;
assume ( x. j ) in ( variables_in ( H1 '&' H2 ) );
then ( x. j ) in ( ( variables_in H1 ) \/ ( variables_in H2 ) ) by ZF_LANG1:141;
then (( x. j ) in ( variables_in H1 ) or ( x. j ) in ( variables_in H2 )) by XBOOLE_0:def 3;
then (j < i1 or j < i2) by A9,A10;
hence thesis by A11,XXREAL_0:2;
end;
A12: (for H holds (for x holds (P[ H ] implies P[ ( All (x,H) ) ])))
proof
let H;
let x;
given i1 being (Element of ( NAT )) such that
A13: (for j holds (( x. j ) in ( variables_in H ) implies j < i1));

consider i2 being (Element of ( NAT )) such that A14: x = ( x. i2 ) by ZF_LANG1:77;
(i1 <= ( i2 + 1 ) or i1 > ( i2 + 1 ));
then consider i such that A15: ((i1 <= ( i2 + 1 ) & i = ( i2 + 1 )) or (i1 > ( i2 + 1 ) & i = i1));
take i;
let j;
assume ( x. j ) in ( variables_in ( All (x,H) ) );
then ( x. j ) in ( ( variables_in H ) \/ { x } ) by ZF_LANG1:142;
then (( x. j ) in ( variables_in H ) or ((( x. j ) in { x } & ( i2 + ( 0 ) ) = i2) & ( 0 ) < 1)) by XBOOLE_0:def 3;
then (j < i1 or (( x. j ) = ( x. i2 ) & i2 < ( i2 + 1 ))) by A13,A14,TARSKI:def 1,XREAL_1:6;
then (j < i1 or j < ( i2 + 1 )) by ZF_LANG1:76;
hence thesis by A15,XXREAL_0:2;
end;
A16: (for H holds (P[ H ] implies P[ ( 'not' H ) ]))
proof
let H;
( variables_in ( 'not' H ) ) = ( variables_in H ) by ZF_LANG1:140;
hence thesis;
end;
(for H holds P[ H ]) from ZF_LANG1:sch 1(A1,A16,A8,A12);
then consider i such that A17: (for j holds (( x. j ) in ( variables_in H ) implies j < i));
thus (ex i st (for j holds (( x. j ) in ( variables_in H ) implies j < i))) by A17;
take ( x. i );
thus thesis by A17;
end;
