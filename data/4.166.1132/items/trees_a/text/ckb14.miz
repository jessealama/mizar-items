environ
vocabularies TREES_1,FINSEQ_1,NUMBERS,SUBSET_1,ORDINAL4,XBOOLE_0,TARSKI,RELAT_1,XXREAL_0,ARYTM_3,TREES_2,FUNCT_1,TREES_A;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XXREAL_0,NAT_1,RELAT_1,FUNCT_1,FINSEQ_1,TREES_1,TREES_2,CKB2,CKB11,CKB13;
definitions TARSKI,XBOOLE_0,TREES_1,TREES_2,RELAT_1,CKB2,CKB13;
theorems TARSKI,FUNCT_1,FINSEQ_1,TREES_1,TREES_2,XBOOLE_0,XBOOLE_1,RELAT_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB12,CKB13;
schemes TREES_2;
registrations XBOOLE_0,RELSET_1,MEMBERED,FINSEQ_1,TREES_2,CKB10;
constructors XXREAL_0,NAT_1,MEMBERED,TREES_2,RELSET_1,FINSEQ_2,CKB2,CKB11,CKB13;
requirements NUMERALS,BOOLE,SUBSET;
begin
reserve p for (FinSequence of ( NAT ));
reserve q for (FinSequence of ( NAT ));
reserve r for (FinSequence of ( NAT ));
reserve T for DecoratedTree;
reserve T1 for DecoratedTree;
reserve P for (AntiChain_of_Prefixes of ( dom T ));
theorem
Th13: (P <> ( {} ) implies (for q holds (q in ( dom ( tree (T,P,T1) ) ) implies ((for p holds (p in P implies ((not p is_a_prefix_of q) & ( ( tree (T,P,T1) ) . q ) = ( T . q )))) or (ex p st (ex r st (((p in P & r in ( dom T1 )) & q = ( p ^ r )) & ( ( tree (T,P,T1) ) . q ) = ( T1 . r ))))))))
proof
assume A1: P <> ( {} );
let q;
assume q in ( dom ( tree (T,P,T1) ) );
then q in ( tree (( dom T ),P,( dom T1 )) ) by A1,CKB13:def 1;
hence thesis by CKB13:def 1;
end;
