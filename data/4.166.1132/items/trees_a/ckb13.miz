environ
vocabularies TREES_1,FINSEQ_1,NUMBERS,SUBSET_1,ORDINAL4,XBOOLE_0,TARSKI,RELAT_1,XXREAL_0,ARYTM_3,TREES_2,FUNCT_1,TREES_A;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XXREAL_0,NAT_1,RELAT_1,FUNCT_1,FINSEQ_1,TREES_1,TREES_2,CKB2,CKB11;
definitions TARSKI,XBOOLE_0,TREES_1,TREES_2,RELAT_1,CKB2;
theorems TARSKI,FUNCT_1,FINSEQ_1,TREES_1,TREES_2,XBOOLE_0,XBOOLE_1,RELAT_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB12;
schemes TREES_2;
registrations XBOOLE_0,RELSET_1,MEMBERED,FINSEQ_1,TREES_2,CKB10;
constructors XXREAL_0,NAT_1,MEMBERED,TREES_2,RELSET_1,FINSEQ_2,CKB2,CKB11;
requirements NUMERALS,BOOLE,SUBSET;
begin
reserve p for (FinSequence of ( NAT ));
reserve q for (FinSequence of ( NAT ));
reserve r for (FinSequence of ( NAT ));
reserve p9 for (FinSequence of ( NAT ));
reserve x for set;
reserve T for DecoratedTree;
reserve T1 for DecoratedTree;
reserve P for (AntiChain_of_Prefixes of ( dom T ));
reserve t for (Element of ( dom T ));
reserve p1 for (FinSequence of ( NAT ));
reserve p2 for (FinSequence of ( NAT ));
reserve r1 for (FinSequence of ( NAT ));
reserve r2 for (FinSequence of ( NAT ));
definition
let T;
let P;
let T1;
assume A1: P <> ( {} );
func tree (T,P,T1) -> DecoratedTree
means
:Def2: (( dom it ) = ( tree (( dom T ),P,( dom T1 )) ) & (for q holds (q in ( tree (( dom T ),P,( dom T1 )) ) implies ((for p holds (p in P implies ((not p is_a_prefix_of q) & ( it . q ) = ( T . q )))) or (ex p st (ex r st (((p in P & r in ( dom T1 )) & q = ( p ^ r )) & ( it . q ) = ( T1 . r ))))))));
existence
proof
defpred X[ FinSequence,set ]
 means
((for p holds (p in P implies ((not p is_a_prefix_of $1) & $2 = ( T . $1 )))) or (ex p st (ex r st (((p in P & r in ( dom T1 )) & $1 = ( p ^ r )) & $2 = ( T1 . r )))));
A2: (for q holds (q in ( tree (( dom T ),P,( dom T1 )) ) implies (ex x st X[ q,x ])))
proof
let q;
assume q in ( tree (( dom T ),P,( dom T1 )) );
then A3: q in ( { t where t is (Element of ( dom T )): (for p holds (p in P implies (not p is_a_prefix_of t))) } \/ { ( p ^ s ) where p is (Element of ( dom T )),s is (Element of ( dom T1 )): p in P } ) by A1,CKB8:1;
A4:now
assume q in { t where t is (Element of ( dom T )): (for p holds (p in P implies (not p is_a_prefix_of t))) };
then consider t such that A5: (q = t & (for p holds (p in P implies (not p is_a_prefix_of t))));
take x = ( T . t );
(for p holds (p in P implies ((not p is_a_prefix_of q) & x = ( T . q )))) by A5;
hence thesis;
end;
now
assume q in { ( p ^ s ) where p is (Element of ( dom T )),s is (Element of ( dom T1 )): p in P };
then consider p being (Element of ( dom T )),s being (Element of ( dom T1 )) such that A6: (q = ( p ^ s ) & p in P);
take x = ( T1 . s );
((for p holds (p in P implies ((not p is_a_prefix_of q) & x = ( T . q )))) or (ex p st (ex r st (((p in P & r in ( dom T1 )) & q = ( p ^ r )) & x = ( T1 . r ))))) by A6;
hence thesis;
end;
hence thesis by A3,A4,XBOOLE_0:def 3;
end;
thus (ex T0 being DecoratedTree st (( dom T0 ) = ( tree (( dom T ),P,( dom T1 )) ) & (for p holds (p in ( tree (( dom T ),P,( dom T1 )) ) implies X[ p,( T0 . p ) ])))) from TREES_2:sch 6(A2);
end;
uniqueness
proof
let D1 being DecoratedTree,D2 being DecoratedTree;
assume that
A7: ( dom D1 ) = ( tree (( dom T ),P,( dom T1 )) )
and
A8: (for q holds (q in ( tree (( dom T ),P,( dom T1 )) ) implies ((for p holds (p in P implies ((not p is_a_prefix_of q) & ( D1 . q ) = ( T . q )))) or (ex p st (ex r st (((p in P & r in ( dom T1 )) & q = ( p ^ r )) & ( D1 . q ) = ( T1 . r )))))))
and
A9: ( dom D2 ) = ( tree (( dom T ),P,( dom T1 )) )
and
A10: (for q holds (q in ( tree (( dom T ),P,( dom T1 )) ) implies ((for p holds (p in P implies ((not p is_a_prefix_of q) & ( D2 . q ) = ( T . q )))) or (ex p st (ex r st (((p in P & r in ( dom T1 )) & q = ( p ^ r )) & ( D2 . q ) = ( T1 . r )))))));
now
let q;
assume that
A11: q in ( dom D1 )
and
A12: ( D1 . q ) <> ( D2 . q );
thus contradiction
proof
per cases  by A7,A8,A11;
suppose A13: (for p holds (p in P implies ((not p is_a_prefix_of q) & ( D1 . q ) = ( T . q ))));

now
per cases  by A7,A10,A11;
suppose A14: (for p holds (p in P implies ((not p is_a_prefix_of q) & ( D2 . q ) = ( T . q ))));

consider x being set such that A15: x in P by A1,XBOOLE_0:def 1;
P c= ( dom T ) by TREES_1:def 11;
then reconsider x as (Element of ( dom T )) by A15;
A16: (ex p9 st p9 = x);
then ( D1 . q ) = ( T . q ) by A13,A15;
hence contradiction by A12,A14,A15,A16;
end;
suppose (ex p st (ex r st (((p in P & r in ( dom T1 )) & q = ( p ^ r )) & ( D2 . q ) = ( T1 . r ))));

then consider p2,r2 such that A17: p2 in P and r2 in ( dom T1 ) and A18: q = ( p2 ^ r2 ) and ( D2 . q ) = ( T1 . r2 );
(not p2 is_a_prefix_of q) by A13,A17;
hence contradiction by A18,TREES_1:1;
end;
end;
hence contradiction;
end;
suppose (ex p st (ex r st (((p in P & r in ( dom T1 )) & q = ( p ^ r )) & ( D1 . q ) = ( T1 . r ))));

then consider p1,r1 such that A19: p1 in P and r1 in ( dom T1 ) and A20: q = ( p1 ^ r1 ) and A21: ( D1 . q ) = ( T1 . r1 );
now
per cases  by A7,A10,A11;
suppose (for p holds (p in P implies ((not p is_a_prefix_of q) & ( D2 . q ) = ( T . q ))));

then (not p1 is_a_prefix_of q) by A19;
hence contradiction by A20,TREES_1:1;
end;
suppose (ex p st (ex r st (((p in P & r in ( dom T1 )) & q = ( p ^ r )) & ( D2 . q ) = ( T1 . r ))));

then consider p2,r2 such that A22: p2 in P and r2 in ( dom T1 ) and A23: q = ( p2 ^ r2 ) and A24: ( D2 . q ) = ( T1 . r2 );
now
assume A25: p1 <> p2;
p1,p2 are_c=-comparable  by A20,A23,CKB1:1;
hence contradiction by A19,A22,A25,TREES_1:def 10;
end;
hence contradiction by A12,A20,A21,A23,A24,FINSEQ_1:33;
end;
end;
hence contradiction;
end;
end;

end;
hence thesis by A7,A9,TREES_2:31;
end;
end;
