environ
vocabularies NUMBERS,SUBSET_1,XBOOLE_0,XXREAL_0,CARD_1,ARYTM_3,NAT_1,FINSEQ_1,RELAT_1,FUNCT_1,TARSKI,COMPLFLD,COMPLEX1,PARTFUN1,CARD_3,STRUCT_0,REAL_1,ORDINAL4,FINSET_1,UPROOTS,ARYTM_1,POLYNOM2,AFINSQ_1,GROUP_1,INT_1,HAHNBAN1,SQUARE_1,POWER,SIN_COS,BINOP_1,ALGSTR_0,FINSEQ_2,MOD_2,VECTSP_1,VECTSP_2,REALSET1,ZFMISC_1,SUPINF_2,COMPTRIG,RAT_1,PREPOWER,XREAL_0,ORDINAL1,NEWTON,XCMPLX_0,INT_2,BINOP_2,GROUP_2,POLYNOM1,POLYNOM3,FUNCT_4,ALGSEQ_1,VALUED_0,POLYNOM5,SGRAPH1,PRE_POLY,GRAPH_2,MESFUNC1,UNIROOTS;
notations TARSKI,XBOOLE_0,SUBSET_1,REALSET1,CARD_1,NUMBERS,XREAL_0,ZFMISC_1,XXREAL_0,COMPLEX1,REAL_1,SQUARE_1,INT_1,INT_2,NAT_1,NAT_D,PREPOWER,POWER,BINOP_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FINSEQ_1,RAT_1,DOMAIN_1,FINSET_1,BINOP_2,STRUCT_0,ALGSTR_0,VECTSP_2,VECTSP_1,GROUP_4,RVSUM_1,ALGSEQ_1,COMPLFLD,HAHNBAN1,POLYNOM3,POLYNOM4,POLYNOM5,COMPTRIG,GROUP_2,NEWTON,GROUP_1,MOD_2,GRAPH_2,ORDINAL1,PRE_POLY,FVSUM_1,UPROOTS,SIN_COS,FUNCT_7,FINSEQ_2,CKB21,CKB29,CKB48,CKB50,CKB63;
definitions TARSKI,GROUP_1,XBOOLE_0,BINOP_1,REALSET1,SQUARE_1,HAHNBAN1,POLYNOM3,FINSEQ_2,COMPLEX1,GROUP_4,ALGSTR_0,STRUCT_0,CKB21,CKB29,CKB48,CKB50,CKB63;
theorems GROUP_1,CARD_1,FINSEQ_1,ZFMISC_1,NAT_1,FUNCT_1,FUNCT_2,RELAT_1,TARSKI,XBOOLE_0,XBOOLE_1,VECTSP_1,PREPOWER,COMPTRIG,COMPLFLD,BINOP_1,XCMPLX_1,COMPLEX1,HAHNBAN1,SIN_COS,POWER,SIN_COS2,POLYNOM5,INT_1,COMPLEX2,XCMPLX_0,XREAL_0,SQUARE_1,RVSUM_1,FVSUM_1,FINSEQ_3,FINSEQ_2,FINSEQ_4,POLYNOM4,INT_2,WSIERP_1,NAT_2,PEPIN,POLYNOM3,COMPUT_1,NORMSP_1,FUNCT_7,ALGSEQ_1,RLVECT_1,NEWTON,POLYNOM2,MATRIX_3,VECTSP_2,MOD_2,CARD_2,GRAPH_2,FINSEQ_5,UPROOTS,GROUP_2,BINOP_2,XREAL_1,XXREAL_0,GROUP_4,FUNCOP_1,ORDINAL1,FINSOP_1,NAT_D,PARTFUN1,PRE_POLY,CKB1,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB21,CKB22,CKB23,CKB24,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB56,CKB57,CKB58,CKB59,CKB60,CKB61,CKB62,CKB63,CKB64,CKB65,CKB66;
schemes NAT_1,FUNCT_2,FINSEQ_1,INT_1,RECDEF_1,CKB2;
registrations RELAT_1,FUNCT_1,FINSET_1,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,NAT_1,INT_1,BINOP_2,CARD_1,MEMBERED,FINSEQ_1,FINSEQ_2,REALSET1,WSIERP_1,STRUCT_0,GROUP_1,VECTSP_1,COMPLFLD,QUOFIELD,POLYNOM3,POLYNOM5,VALUED_0,ALGSTR_0,POWER,UPROOTS,FUNCT_2,RELSET_1,PRE_POLY,XBOOLE_0,ZFMISC_1,CKB19,CKB20,CKB25,CKB37,CKB38,CKB55;
constructors WELLORD2,BINOP_1,REAL_1,SQUARE_1,NAT_D,FINSEQOP,FINSOP_1,RVSUM_1,PREPOWER,POWER,REALSET1,SIN_COS,GROUP_4,MOD_2,MATRIX_2,HAHNBAN1,GRAPH_2,POLYNOM4,POLYNOM5,UPROOTS,SEQ_1,RECDEF_1,BINOP_2,RELSET_1,PBOOLE,FUNCT_7,POLYNOM1,NEWTON,FVSUM_1,CKB21,CKB29,CKB48,CKB50,CKB63;
requirements NUMERALS,BOOLE,SUBSET,ARITHM,REAL;
begin
theorem
Th55: (for d being non empty (Element of ( NAT )) holds (for i being (Element of ( NAT )) holds ((( ( cyclotomic_poly d ) . ( 0 ) ) = 1 or ( ( cyclotomic_poly d ) . ( 0 ) ) = ( - 1 )) & ( ( cyclotomic_poly d ) . i ) is  integer)))
proof
deffunc cp(non empty (Element of ( NAT ))) = ( cyclotomic_poly $1 );
set cPRFC = (the carrier of ( Polynom-Ring ( F_Complex ) ));
set cFC = (the carrier of ( F_Complex ));
defpred P[ non empty (Element of ( NAT )) ]
 means
((( cp($1) . ( 0 ) ) = 1 or ( cp($1) . ( 0 ) ) = ( - 1 )) & (for i being (Element of ( NAT )) holds ( cp($1) . i ) is  integer));
A1: ( - ( 1_ ( F_Complex ) ) ) = ( - 1 ) by COMPLFLD:2,COMPLFLD:8;
A2:now
let k being non empty (Element of ( NAT ));
assume that
A3: (for n being non empty (Element of ( NAT )) holds (n < k implies P[ n ]));
A4: 1 <= k by CKB1:1;
per cases  by A4,XXREAL_0:1;
suppose A5: k = 1;

now
let i being (Element of ( NAT ));
per cases  by NAT_1:23;
suppose i = ( 0 );

hence ( cp(k) . i ) is  integer by A1,A5,CKB64:1,POLYNOM5:38;
end;
suppose i = 1;

hence ( cp(k) . i ) is  integer by A5,CKB64:1,COMPLFLD:8,POLYNOM5:38;
end;
suppose i >= 2;

hence ( cp(k) . i ) is  integer by A5,CKB64:1,COMPLFLD:7,POLYNOM5:38;
end;
end;
hence P[ k ] by A1,A5,CKB64:1,POLYNOM5:38;
end;
suppose A6: k > 1;

consider f being (FinSequence of cPRFC),p being (Polynomial of ( F_Complex )) such that A7: p = ( Product f ) and A8: ( dom f ) = ( Seg k ) and A9: (for i being non empty (Element of ( NAT )) holds (i in ( Seg k ) implies ((((not i divides k) or i = k) implies ( f . i ) = <% ( 1_ ( F_Complex ) ) %>) & ((i divides k & i <> k) implies ( f . i ) = cp(i))))) and A10: ( unital_poly (( F_Complex ),k) ) = ( ( cyclotomic_poly k ) *' p ) by CKB66:1;
defpred G[ Nat,set ]
 means
(ex g being (FinSequence of cPRFC) st (ex p being (Polynomial of ( F_Complex )) st ((((g = ( f | ( Seg $1 ) ) & p = ( Product g )) & $2 = p) & (( p . ( 0 ) ) = 1 or ( p . ( 0 ) ) = ( - 1 ))) & (for j being (Element of ( NAT )) holds ( p . j ) is  integer))));
defpred H[ (Element of ( NAT )) ]
 means
($1 in ( Seg ( len f ) ) implies (ex x being set st G[ $1,x ]));
A11: k = ( len f ) by A8,FINSEQ_1:def 3;
A12: (for l being (Element of ( NAT )) holds (H[ l ] implies H[ ( l + 1 ) ]))
proof
let l being (Element of ( NAT ));
assume A13: H[ l ];
assume A14: ( l + 1 ) in ( Seg ( len f ) );
per cases ;
suppose A15: l = ( 0 );

reconsider fl1 = ( f . ( l + 1 ) ) as (Element of cPRFC) by A8,A11,A14,FINSEQ_2:11;
reconsider g = ( f | ( Seg ( l + 1 ) ) ) as (FinSequence of cPRFC) by FINSEQ_1:18;
reconsider p = ( Product g ) as (Polynomial of ( F_Complex )) by POLYNOM3:def 10;
( <*> cPRFC ) = ( f | (( Seg ( 0 ) ) qua set) );
then g = ( ( <*> cPRFC ) ^ <* ( f . ( l + 1 ) ) *> ) by A8,A11,A14,A15,FINSEQ_5:10
.= <* ( f . ( l + 1 ) ) *> by FINSEQ_1:34;
then A16: p = fl1 by FINSOP_1:11;
take p;
take g;
take p;
thus ((g = ( f | ( Seg ( l + 1 ) ) ) & p = ( Product g )) & p = p);
1 divides k by NAT_D:6;
then A17: ( f . 1 ) = cp(1) by A6,A9,A11,A14,A15;
hence (( p . ( 0 ) ) = 1 or ( p . ( 0 ) ) = ( - 1 )) by A1,A15,A16,CKB64:1,POLYNOM5:38;
let j being (Element of ( NAT ));
thus ( p . j ) is  integer
proof
per cases  by NAT_1:23;
suppose j = ( 0 );

hence thesis by A1,A15,A16,A17,CKB64:1,POLYNOM5:38;
end;
suppose j = 1;

hence thesis by A15,A16,A17,CKB64:1,COMPLFLD:8,POLYNOM5:38;
end;
suppose j >= 2;

hence thesis by A15,A16,A17,CKB64:1,COMPLFLD:7,POLYNOM5:38;
end;
end;

end;
suppose A18: ( 0 ) < l;

(( l + 1 ) <= ( len f ) & l <= ( l + 1 )) by A14,FINSEQ_1:1,NAT_1:12;
then A19: l <= ( len f ) by XXREAL_0:2;
( ( 0 ) + 1 ) <= l by A18,NAT_1:13;
then consider x being set such that A20: G[ l,x ] by A13,A19,FINSEQ_1:1;
reconsider fl1 = ( f . ( l + 1 ) ) as (Element of cPRFC) by A8,A11,A14,FINSEQ_2:11;
reconsider g1 = ( f | ( Seg ( l + 1 ) ) ) as (FinSequence of cPRFC) by FINSEQ_1:18;
reconsider p1 = ( Product g1 ) as (Polynomial of ( F_Complex )) by POLYNOM3:def 10;
take p1;
take g1;
take p1;
thus ((g1 = ( f | ( Seg ( l + 1 ) ) ) & p1 = ( Product g1 )) & p1 = p1);
reconsider fl1p = fl1 as (Polynomial of ( F_Complex )) by POLYNOM3:def 10;
reconsider m1 = ( - 1 ) as (Element of ( COMPLEX )) by XCMPLX_0:def 2;
consider g being (FinSequence of cPRFC),p being (Polynomial of ( F_Complex )) such that A21: g = ( f | ( Seg l ) ) and A22: p = ( Product g ) and x = p and A23: (( p . ( 0 ) ) = 1 or ( p . ( 0 ) ) = ( - 1 )) and A24: (for j being (Element of ( NAT )) holds ( p . j ) is  integer) by A20;
g1 = ( g ^ <* fl1 *> ) by A8,A11,A14,A21,FINSEQ_5:10;
then ( Product g1 ) = ( ( Product g ) * fl1 ) by GROUP_4:6;
then A25: p1 = ( p *' fl1p ) by A22,POLYNOM3:def 10;
thus thesis
proof
per cases ;
suppose ((not ( l + 1 ) divides k) or ( l + 1 ) = k);

then A26: fl1p = <% ( 1_ ( F_Complex ) ) %> by A9,A11,A14;
consider r being (FinSequence of ( F_Complex )) such that A27: ( len r ) = ( ( 0 ) + 1 ) and A28: ( p1 . ( 0 ) ) = ( Sum r ) and A29: (for m being (Element of ( NAT )) holds (m in ( dom r ) implies ( r . m ) = ( ( p . ( m -' 1 ) ) * ( fl1p . ( ( ( 0 ) + 1 ) -' m ) ) ))) by A25,POLYNOM3:def 9;
1 in ( dom r ) by A27,FINSEQ_3:25;
then reconsider r1 = ( r . 1 ) as (Element of ( F_Complex )) by FINSEQ_2:11;
r = <* r1 *> by A27,FINSEQ_1:40;
then A30: ( p1 . ( 0 ) ) = r1 by A28,RLVECT_1:44;
1 in ( dom r ) by A27,FINSEQ_3:25;
then A31: ( p1 . ( 0 ) ) = ( ( p . ( 1 -' 1 ) ) * ( fl1p . ( ( ( 0 ) + 1 ) -' 1 ) ) ) by A29,A30
.= ( ( p . ( ( ( 0 ) + 1 ) -' 1 ) ) * ( fl1p . ( 0 ) ) ) by NAT_D:34
.= ( ( p . ( 0 ) ) * ( fl1p . ( 0 ) ) ) by NAT_D:34
.= ( ( p . ( 0 ) ) * ( 1_ ( F_Complex ) ) ) by A26,POLYNOM5:32;
thus (( p1 . ( 0 ) ) = 1 or ( p1 . ( 0 ) ) = ( - 1 ))
proof
per cases  by A23;
suppose ( p . ( 0 ) ) = 1;

hence thesis by A31,COMPLFLD:8;
end;
suppose ( p . ( 0 ) ) = ( - 1 );

hence thesis by A31,COMPLFLD:8;
end;
end;

let j being (Element of ( NAT ));
consider r being (FinSequence of ( F_Complex )) such that ( len r ) = ( j + 1 ) and A32: ( p1 . j ) = ( Sum r ) and A33: (for m being (Element of ( NAT )) holds (m in ( dom r ) implies ( r . m ) = ( ( p . ( m -' 1 ) ) * ( fl1p . ( ( j + 1 ) -' m ) ) ))) by A25,POLYNOM3:def 9;
(for i being (Element of ( NAT )) holds (i in ( dom r ) implies ( r . i ) is  integer))
proof
let i being (Element of ( NAT ));
reconsider pi1 = ( p . ( i -' 1 ) ) as Integer by A24;
set j1i = ( ( j + 1 ) -' i );
now
A34: (j1i = ( 0 ) or j1i >= ( ( 0 ) + 1 )) by NAT_1:13;
per cases  by A34;
case j1i = ( 0 );
hence ( fl1p . j1i ) = 1 by A26,COMPLFLD:8,POLYNOM5:32;
end;
case j1i >= 1;
hence ( fl1p . j1i ) = ( 0 ) by A26,COMPLFLD:7,POLYNOM5:32;
end;
end;
then reconsider fl1pj1i = ( fl1p . ( ( j + 1 ) -' i ) ) as Integer;
assume i in ( dom r );
then ( r . i ) = ( ( p . ( i -' 1 ) ) * ( fl1p . ( ( j + 1 ) -' i ) ) ) by A33
.= ( pi1 * fl1pj1i );
hence thesis;
end;
hence thesis by A32,CKB7:1;
end;
suppose A35: (( l + 1 ) divides k & ( l + 1 ) <> k);

consider r being (FinSequence of ( F_Complex )) such that A36: ( len r ) = ( ( 0 ) + 1 ) and A37: ( p1 . ( 0 ) ) = ( Sum r ) and A38: (for m being (Element of ( NAT )) holds (m in ( dom r ) implies ( r . m ) = ( ( p . ( m -' 1 ) ) * ( fl1p . ( ( ( 0 ) + 1 ) -' m ) ) ))) by A25,POLYNOM3:def 9;
1 in ( dom r ) by A36,FINSEQ_3:25;
then reconsider r1 = ( r . 1 ) as (Element of ( F_Complex )) by FINSEQ_2:11;
r = <* r1 *> by A36,FINSEQ_1:40;
then A39: ( p1 . ( 0 ) ) = r1 by A37,RLVECT_1:44;
1 in ( dom r ) by A36,FINSEQ_3:25;
then A40: ( p1 . ( 0 ) ) = ( ( p . ( 1 -' 1 ) ) * ( fl1p . ( ( ( 0 ) + 1 ) -' 1 ) ) ) by A38,A39
.= ( ( p . ( ( ( 0 ) + 1 ) -' 1 ) ) * ( fl1p . ( 0 ) ) ) by NAT_D:34
.= ( ( p . ( 0 ) ) * ( fl1p . ( 0 ) ) ) by NAT_D:34;
( l + 1 ) <= k by A35,NAT_D:7;
then A41: ( l + 1 ) < k by A35,XXREAL_0:1;
A42: fl1p = cp(( l + 1 )) by A9,A11,A14,A35;
then reconsider fl1p0 = ( fl1p . ( 0 ) ) as Integer by A3,A41;
A43: (fl1p0 = 1 or fl1p0 = m1) by A3,A42,A41;
thus (( p1 . ( 0 ) ) = 1 or ( p1 . ( 0 ) ) = ( - 1 ))
proof
per cases  by A23;
suppose ( p . ( 0 ) ) = 1;

hence thesis by A3,A42,A41,A40;
end;
suppose ( p . ( 0 ) ) = ( - 1 );

hence thesis by A40,A43;
end;
end;

let j being (Element of ( NAT ));
consider r being (FinSequence of ( F_Complex )) such that ( len r ) = ( j + 1 ) and A44: ( p1 . j ) = ( Sum r ) and A45: (for m being (Element of ( NAT )) holds (m in ( dom r ) implies ( r . m ) = ( ( p . ( m -' 1 ) ) * ( fl1p . ( ( j + 1 ) -' m ) ) ))) by A25,POLYNOM3:def 9;
(for i being (Element of ( NAT )) holds (i in ( dom r ) implies ( r . i ) is  integer))
proof
let i being (Element of ( NAT ));
reconsider fl1pj1i = ( fl1p . ( ( j + 1 ) -' i ) ) as Integer by A3,A42,A41;
reconsider pi1 = ( p . ( i -' 1 ) ) as Integer by A24;
assume i in ( dom r );
then ( r . i ) = ( ( p . ( i -' 1 ) ) * ( fl1p . ( ( j + 1 ) -' i ) ) ) by A45
.= ( pi1 * fl1pj1i );
hence thesis;
end;
hence thesis by A44,CKB7:1;
end;
end;

end;
end;
defpred C[ Nat ]
 means
( cp(k) . $1 ) is  integer;
A46: ( ( ( 0 ) + 1 ) -' 1 ) = ( 0 ) by NAT_D:34;
A47: H[ ( 0 ) ] by FINSEQ_1:1;
(for l being (Element of ( NAT )) holds H[ l ]) from NAT_1:sch 1(A47,A12);
then A48: (for l being Nat holds (l in ( Seg ( len f ) ) implies (ex x being set st G[ l,x ])));
consider F being FinSequence such that ( dom F ) = ( Seg ( len f ) ) and A49: (for i being Nat holds (i in ( Seg ( len f ) ) implies G[ i,( F . i ) ])) from FINSEQ_1:sch 1(A48);
consider g being (FinSequence of cPRFC),p1 being (Polynomial of ( F_Complex )) such that A50: (g = ( f | ( Seg k ) ) & p1 = ( Product g )) and ( F . k ) = p1 and A51: (( p1 . ( 0 ) ) = 1 or ( p1 . ( 0 ) ) = ( - 1 )) and A52: (for j being (Element of ( NAT )) holds ( p1 . j ) is  integer) by A11,A49,FINSEQ_1:3;
A53: p = p1 by A7,A11,A50,FINSEQ_3:49;
A54:now
let m being Nat;
reconsider m1 = m as (Element of ( NAT )) by ORDINAL1:def 12;
consider r being (FinSequence of cFC) such that A55: ( len r ) = ( m + 1 ) and A56: ( ( unital_poly (( F_Complex ),k) ) . m ) = ( Sum r ) and A57: (for l being (Element of ( NAT )) holds (l in ( dom r ) implies ( r . l ) = ( ( p . ( l -' 1 ) ) * ( cp(k) . ( ( m1 + 1 ) -' l ) ) ))) by A10,POLYNOM3:def 9;
reconsider Src = ( Sum r ) as (Element of ( COMPLEX )) by COMPLFLD:def 1;
now
per cases ;
suppose m1 = ( 0 );

hence Src is  integer by A1,A56,CKB52:1;
end;
suppose m1 = k;

hence Src is  integer by A56,CKB52:1,COMPLFLD:8;
end;
suppose (m1 <> ( 0 ) & m1 <> k);

hence Src is  integer by A56,CKB53:1,COMPLFLD:7;
end;
end;
then reconsider Sr = Src as Integer;
A58: ( ( (1,1) -cut r ) ^ ( (( 1 + 1 ),( len r )) -cut r ) ) = r by A55,GRAPH_2:9,NAT_1:11;
set s = ( (( 1 + 1 ),( len r )) -cut r );
reconsider Ssc = ( Sum s ) as (Element of ( COMPLEX )) by COMPLFLD:def 1;
assume A59: (for n being Nat holds (n < m implies C[ n ]));
now
let i being (Element of ( NAT ));
assume A60: i in ( dom s );
per cases ;
suppose ( len r ) < 2;

then s = ( {} ) by GRAPH_2:def 1;
hence ( s . i ) is  integer;
end;
suppose A61: ( 1 + 1 ) <= ( len r );

then A62: ( ( len s ) + ( 1 + 1 ) ) = ( ( len r ) + 1 ) by GRAPH_2:def 1;
per cases ;
suppose m = ( 0 );

hence ( s . i ) is  integer by A55,A61;
end;
suppose A63: m > ( 0 );

i <> ( 0 ) by A60,FINSEQ_3:25;
then reconsider cpkmi = ( cp(k) . ( m -' i ) ) as Integer by A59,A63,NAT_2:9;
reconsider ppi = ( p . i ) as Integer by A52,A53;
i <> ( 0 ) by A60,FINSEQ_3:25;
then consider i1 being Nat such that A64: i = ( i1 + 1 ) by NAT_1:6;
A65: i <= ( len s ) by A60,FINSEQ_3:25;
then (1 <= ( i + 1 ) & ( i + 1 ) <= ( ( len s ) + 1 )) by NAT_1:11,XREAL_1:6;
then ( 1 + i ) in ( dom r ) by A62,FINSEQ_3:25;
then A66: ( r . ( 1 + i ) ) = ( ( p . ( ( 1 + i ) -' 1 ) ) * ( cp(k) . ( ( m + 1 ) -' ( 1 + i ) ) ) ) by A57
.= ( ( p . ( ( i + 1 ) -' 1 ) ) * ( cp(k) . ( ( ( m + 1 ) -' 1 ) -' i ) ) ) by NAT_2:30
.= ( ( p . i ) * ( cp(k) . ( ( ( m + 1 ) -' 1 ) -' i ) ) ) by NAT_D:34
.= ( ppi * cpkmi ) by NAT_D:34;
i1 < ( len s ) by A65,A64,NAT_1:13;
then ( s . i ) = ( r . ( ( 1 + 1 ) + i1 ) ) by A61,A64,GRAPH_2:def 1
.= ( r . ( 1 + i ) ) by A64;
hence ( s . i ) is  integer by A66;
end;
end;
end;
then reconsider Ss = Ssc as Integer by CKB7:1;
A67: 1 <= ( len r ) by A55,NAT_1:11;
then A68: 1 in ( dom r ) by FINSEQ_3:25;
then reconsider r1 = ( r . 1 ) as (Element of cFC) by FINSEQ_2:11;
reconsider r1c = r1 as (Element of ( COMPLEX )) by COMPLFLD:def 1;
( (1,1) -cut r ) = <* r1 *> by A67,GRAPH_2:6;
then ( Sum r ) = ( r1 + ( Sum s ) ) by A58,FVSUM_1:72;
then r1c = ( Sr - Ss );
then reconsider r1i = r1 as Integer;
A69: r1i = ( ( p . ( 1 -' 1 ) ) * ( cp(k) . ( ( m + 1 ) -' 1 ) ) ) by A57,A68
.= ( ( p . ( 0 ) ) * ( cp(k) . m1 ) ) by A46,NAT_D:34;
per cases  by A7,A11,A50,A51,FINSEQ_3:49;
suppose ( p . ( 0 ) ) = 1;

hence C[ m ] by A69;
end;
suppose ( p . ( 0 ) ) = ( - 1 );

then r1 = ( ( - ( 1_ ( F_Complex ) ) ) * ( cp(k) . m1 ) ) by A69,COMPLFLD:2,COMPLFLD:8
.= ( - ( ( 1_ ( F_Complex ) ) * ( cp(k) . m1 ) ) ) by VECTSP_1:9
.= ( - ( cp(k) . m1 ) ) by VECTSP_1:def 8;
then ( 0. ( F_Complex ) ) = ( ( - ( cp(k) . m1 ) ) + ( - r1 ) ) by RLVECT_1:def 10
.= ( ( - r1 ) - ( cp(k) . m1 ) );
then ( - r1 ) = ( cp(k) . m ) by VECTSP_1:19;
then ( - r1i ) = ( cp(k) . m ) by COMPLFLD:2;
hence C[ m ];
end;
end;
A70: (for i being Nat holds C[ i ]) from NAT_1:sch 4(A54);
consider r being (FinSequence of cFC) such that A71: ( len r ) = ( ( 0 ) + 1 ) and A72: ( ( unital_poly (( F_Complex ),k) ) . ( 0 ) ) = ( Sum r ) and A73: (for l being (Element of ( NAT )) holds (l in ( dom r ) implies ( r . l ) = ( ( p . ( l -' 1 ) ) * ( cp(k) . ( ( ( 0 ) + 1 ) -' l ) ) ))) by A10,POLYNOM3:def 9;
A74: 1 in ( dom r ) by A71,FINSEQ_3:25;
then reconsider r1 = ( r . 1 ) as (Element of cFC) by FINSEQ_2:11;
r = <* r1 *> by A71,FINSEQ_1:40;
then A75: ( Sum r ) = ( r . 1 ) by RLVECT_1:44
.= ( ( p . ( 0 ) ) * ( cp(k) . ( 0 ) ) ) by A73,A46,A74;
(( cp(k) . ( 0 ) ) = 1 or ( cp(k) . ( 0 ) ) = ( - 1 ))
proof
per cases  by A7,A11,A50,A51,FINSEQ_3:49;
suppose ( p . ( 0 ) ) = 1;

hence thesis by A1,A72,A75,CKB52:1;
end;
suppose ( p . ( 0 ) ) = ( - 1 );

then ( - ( 1_ ( F_Complex ) ) ) = ( ( - ( 1_ ( F_Complex ) ) ) * ( cp(k) . ( 0 ) ) ) by A1,A72,A75,CKB52:1
.= ( - ( ( 1_ ( F_Complex ) ) * ( cp(k) . ( 0 ) ) ) ) by VECTSP_1:9
.= ( - ( cp(k) . ( 0 ) ) ) by VECTSP_1:def 8;
hence thesis by COMPLFLD:8,RLVECT_1:18;
end;
end;
hence P[ k ] by A70;
end;
end;
(for d being non empty (Element of ( NAT )) holds P[ d ]) from CKB2:sch 1(A2);
hence thesis;
end;
