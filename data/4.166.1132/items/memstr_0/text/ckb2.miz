environ
vocabularies STRUCT_0,SUBSET_1,XBOOLE_0,FUNCT_1,NUMBERS,CARD_3,CARD_1,FUNCOP_1,FUNCT_4,RELAT_1,TARSKI,CAT_1,FSM_1,SETFAM_1,FINSET_1,NAT_1,ARYTM_1,PARTFUN1,ZFMISC_1,AMI_1,ARYTM_3,COMPOS_1,SCMFSA6C,XXREAL_0,SUPINF_2,MEMSTR_0;
notations TARSKI,XBOOLE_0,ZFMISC_1,MCART_1,SUBSET_1,SETFAM_1,ORDINAL1,PBOOLE,FUNCT_7,CARD_1,CARD_3,XCMPLX_0,RELAT_1,FUNCT_1,PARTFUN1,FINSET_1,NUMBERS,INT_1,NAT_1,NAT_D,FUNCOP_1,FUNCT_4,AFINSQ_1,FINSEQ_1,FUNCT_2,DOMAIN_1,VALUED_0,VALUED_1,STRUCT_0,XXREAL_0,CKB1;
definitions RELAT_1,FUNCOP_1,ORDINAL1,PBOOLE,PARTFUN1,MCART_1,ZFMISC_1,TARSKI,STRUCT_0,FUNCT_1,XBOOLE_0,NAT_1,FUNCT_4,NAT_D,AFINSQ_1,VALUED_1,CARD_3;
theorems ZFMISC_1,FUNCT_2,TARSKI,CARD_3,FUNCT_4,FUNCOP_1,FUNCT_1,GRFUNC_1,RELAT_1,RELSET_1,XBOOLE_0,XBOOLE_1,ORDINAL1,SUBSET_1,FUNCT_7,PARTFUN1,PBOOLE,XREAL_1,NAT_D,NAT_2,STRUCT_0;
schemes FRAENKEL;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCT_2,FUNCOP_1,FUNCT_4,FINSET_1,XREAL_0,FINSEQ_1,CARD_3,STRUCT_0,INT_1,RELSET_1,GRFUNC_1,PRE_POLY,PBOOLE,AFINSQ_1,VALUED_1,XCMPLX_0,PARTFUN1,NUMBERS,NAT_1,MEMBERED,FUNCT_7,CARD_1,XXREAL_2,ZFMISC_1,SUBSET_1,VALUED_0,XXREAL_0,ORDINAL4,ORDINAL5,CKB1;
constructors SETFAM_1,DOMAIN_1,FUNCT_4,XXREAL_0,RELSET_1,FUNCT_7,PRE_POLY,PBOOLE,RECDEF_2,AFINSQ_1,NAT_D,WELLORD2,STRUCT_0,CKB1;
requirements NUMERALS,BOOLE,SUBSET,ARITHM,REAL;
begin
reserve N for set;
definition
let N;
func Trivial-Mem N ->  strict Mem-Struct over N
means
:Def1: (((the carrier of it) = { ( 0 ) } & (the ZeroF of it) = ( 0 )) & (the Object-Kind of it) = ( ( 0 ) .--> ( NAT ) ));
existence
proof
set f = ( ( 0 ) .--> ( NAT ) );
A1: ( dom f ) = { ( 0 ) } by FUNCOP_1:13;
B2: ( rng ( ( 0 ) .--> ( NAT ) ) ) c= { ( NAT ) } by FUNCOP_1:13;
{ ( NAT ) } c= ( N \/ { ( NAT ) } ) by XBOOLE_1:7;
then ( rng f ) c= ( N \/ { ( NAT ) } ) by B2,XBOOLE_1:1;
then reconsider f as (Function of { ( 0 ) },( N \/ { ( NAT ) } )) by A1,RELSET_1:4;
reconsider y = ( 0 ) as (Element of { ( 0 ) }) by TARSKI:def 1;
take Mem-Struct (# { ( 0 ) },y,f #);
thus thesis;
end;
uniqueness;
end;
