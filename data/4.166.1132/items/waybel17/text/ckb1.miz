environ
vocabularies XBOOLE_0,SUBSET_1,FUNCT_1,NUMBERS,RELAT_1,TARSKI,WAYBEL_9,STRUCT_0,WAYBEL_0,RELAT_2,ORDERS_2,SEQM_3,XXREAL_0,WAYBEL11,YELLOW_0,LATTICE3,ORDINAL2,PRE_TOPC,RCOMP_1,FUNCOP_1,WAYBEL_3,REWRITE1,NEWTON,CARD_3,CAT_1,YELLOW_1,FUNCT_2,ARYTM_3,LATTICES,WELLORD1,YELLOW_2,EQREL_1,CARD_FIL,RLVECT_3,ZFMISC_1,SETFAM_1,YELLOW_8,TOPS_1,WAYBEL_8,WAYBEL17;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,NAT_1,RELAT_1,SETFAM_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,DOMAIN_1,STRUCT_0,PRE_TOPC,TOPS_1,TOPS_2,TOLER_1,ORDERS_2,LATTICE3,YELLOW_0,ORDERS_3,WAYBEL_0,YELLOW_1,YELLOW_2,NATTRA_1,WAYBEL_3,FUNCOP_1,WAYBEL_8,WAYBEL_9,WAYBEL11,WAYBEL_2,CANTOR_1,YELLOW_8,XXREAL_0;
definitions TARSKI,XBOOLE_0,WAYBEL_0,PRE_TOPC,RELAT_1,LATTICE3,YELLOW_0,WAYBEL_1,WAYBEL_3,WAYBEL11,YELLOW_8,WELLORD1,SUBSET_1,STRUCT_0,TOPS_2;
theorems WAYBEL11,WAYBEL_0,PRE_TOPC,TOPS_1,TARSKI,FUNCT_1,FUNCT_2,TOPS_2,YELLOW_0,YELLOW_2,WAYBEL_3,WAYBEL_1,RELAT_1,WAYBEL_4,ZFMISC_1,WAYBEL_2,WAYBEL_8,LATTICE3,NAT_1,ORDERS_2,SCHEME1,WAYBEL_9,FUNCT_3,WAYBEL13,YELLOW_8,YELLOW_1,FUNCOP_1,WAYBEL10,RELSET_1,SETFAM_1,XBOOLE_0,XBOOLE_1,XXREAL_0,EQREL_1;
schemes PARTFUN1,RELSET_1,FRAENKEL,XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCT_2,FUNCOP_1,MEMBERED,ABIAN,STRUCT_0,TOPS_1,LATTICE3,WAYBEL_0,YELLOW_1,WAYBEL_2,WAYBEL_3,WAYBEL_9,WAYBEL10,WAYBEL11,PRE_TOPC,RELSET_1;
constructors SETFAM_1,DOMAIN_1,XXREAL_0,NAT_1,NAT_D,TOLER_1,ABIAN,TOPS_1,NATTRA_1,LATTICE3,CANTOR_1,ORDERS_3,WAYBEL_1,WAYBEL_3,WAYBEL_5,WAYBEL_8,YELLOW_8,WAYBEL11,MEMBERED,RELSET_1,TOPS_2,WAYBEL_2;
requirements NUMERALS,BOOLE,SUBSET,ARITHM;
begin
definition
let S being non  empty set;
let a being (Element of S);
let b being (Element of S);
func (a,b) ,... -> (Function of ( NAT ),S) means 
:Def1: (for i being (Element of ( NAT )) holds (((ex k being (Element of ( NAT )) st i = ( 2 * k )) implies ( it . i ) = a) & ((not (ex k being (Element of ( NAT )) st i = ( 2 * k ))) implies ( it . i ) = b)));
existence
proof
defpred C[ set ]
 means
(ex k being (Element of ( NAT )) st $1 = ( 2 * k ));
deffunc G(set) = b;
deffunc F(set) = a;
consider f being Function such that A1: (( dom f ) = ( NAT ) & (for x being set holds (x in ( NAT ) implies ((C[ x ] implies ( f . x ) = F(x)) & ((not C[ x ]) implies ( f . x ) = G(x)))))) from PARTFUN1:sch 1;
A2: ( rng f ) c= { a,b }
proof
let x being set;
assume x in ( rng f );
then consider y being set such that A3: y in ( dom f ) and A4: x = ( f . y ) by FUNCT_1:def 3;
per cases ;
suppose C[ y ];

then ( f . y ) = a by A1;
hence thesis by A4,TARSKI:def 2;
end;
suppose (not C[ y ]);

then ( f . y ) = b by A1,A3;
hence thesis by A4,TARSKI:def 2;
end;
end;
(for y being set holds (y in { a,b } implies (ex x being set st (x in ( dom f ) & y = ( f . x )))))
proof
let y being set;
assume A5: y in { a,b };
per cases  by A5,TARSKI:def 2;
suppose A6: y = a;

take 2;
C[ 2 ]
proof
take 1;
thus thesis;
end;
hence thesis by A1,A6;
end;
suppose A7: y = b;

take 1;
(for k being (Element of ( NAT )) holds 1 <> ( 2 * k )) by NAT_1:15;
hence thesis by A1,A7;
end;
end;
then { a,b } c= ( rng f ) by FUNCT_1:9;
then ( rng f ) = { a,b } by A2,XBOOLE_0:def 10;
then reconsider f as (Function of ( NAT ),S) by A1,FUNCT_2:def 1,RELSET_1:4;
take f;
let i being (Element of ( NAT ));
thus thesis by A1;
end;
uniqueness
proof
let f1 being (Function of ( NAT ),S);
let f2 being (Function of ( NAT ),S);
A8: ( dom f1 ) = ( NAT ) by FUNCT_2:def 1;
A9: ( dom f2 ) = ( NAT ) by FUNCT_2:def 1;
assume that
A10: (for i being (Element of ( NAT )) holds (((ex k being (Element of ( NAT )) st i = ( 2 * k )) implies ( f1 . i ) = a) & ((not (ex k being (Element of ( NAT )) st i = ( 2 * k ))) implies ( f1 . i ) = b)))
and
A11: (for i being (Element of ( NAT )) holds (((ex k being (Element of ( NAT )) st i = ( 2 * k )) implies ( f2 . i ) = a) & ((not (ex k being (Element of ( NAT )) st i = ( 2 * k ))) implies ( f2 . i ) = b)));
(for k being set holds (k in ( NAT ) implies ( f1 . k ) = ( f2 . k )))
proof
let k being set;
assume k in ( NAT );
then reconsider k9 = k as (Element of ( NAT ));
per cases ;
suppose A12: (ex l being (Element of ( NAT )) st k = ( 2 * l ));

then ( f1 . k ) = a by A10
.= ( f2 . k ) by A11,A12;
hence thesis;
end;
suppose A13: (not (ex l being (Element of ( NAT )) st k = ( 2 * l )));

then ( f1 . k9 ) = b by A10
.= ( f2 . k9 ) by A11,A13;
hence thesis;
end;
end;
hence thesis by A8,A9,FUNCT_1:2;
end;
end;
