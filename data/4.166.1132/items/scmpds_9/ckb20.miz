environ
vocabularies NUMBERS,SCMPDS_2,AMI_1,INT_1,FUNCOP_1,SUBSET_1,FSM_1,FUNCT_1,AMISTD_1,FUNCT_4,XBOOLE_0,SETFAM_1,AMI_3,COMPLEX1,ARYTM_3,ORDINAL1,XXREAL_0,ARYTM_1,CARD_1,AMI_2,RELAT_1,GRAPHSP,TARSKI,FINSET_1,XREAL_0,CARD_3,AMI_WSTD;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,ORDINAL1,CARD_3,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,FUNCT_1,INT_1,NAT_1,FINSET_1,COMPLEX1,INT_2,PARTFUN1,FUNCOP_1,RELAT_1,FUNCT_4,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,SCMPDS_2,SCMPDS_3,AMISTD_1,AMI_WSTD,CKB1;
definitions TARSKI,XBOOLE_0,NAT_1,AMI_WSTD,AMISTD_1,COMPOS_1,MEMSTR_0;
theorems AMI_WSTD,SETFAM_1,XBOOLE_0,SCMPDS_1,SCMPDS_2,ABSVALUE,INT_1,TARSKI,AMI_2,NAT_1,XBOOLE_1,FUNCT_4,PRE_CIRC,WSIERP_1,PEPIN,COMPLEX1,XREAL_1,FUNCT_7,NAT_D,ZFMISC_1,PBOOLE,AMISTD_1,COMPOS_1,MEMSTR_0,CARD_3,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19;
registrations SETFAM_1,ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,CARD_3,SCMPDS_2,FUNCT_1,FUNCT_2,XBOOLE_0,FUNCOP_1,FUNCT_4,AMISTD_1,COMPOS_1,FUNCT_7,RELAT_1,MEMSTR_0,CKB3;
constructors XXREAL_0,REAL_1,NAT_D,REALSET1,SCMPDS_1,SCMPDS_3,AMI_WSTD,PRE_POLY,AMISTD_1,FUNCT_4,FUNCT_7,FUNCOP_1,MEMSTR_0,CKB1;
requirements BOOLE,SUBSET,NUMERALS,ARITHM,REAL;
begin
reserve a for Int_position;
reserve l for (Element of ( NAT ));
reserve k1 for Integer;
reserve k2 for Integer;
theorem
( NIC (( (a,k1) >=0_goto k2 ),l) ) = { ( succ l ),( abs ( k2 + l ) ) }
proof
set s = the (State of ( SCMPDS ));
set i = ( (a,k1) >=0_goto k2 );
set t = ( abs ( k2 + l ) );
set I = i;
reconsider n = l as (Element of ( NAT ));
reconsider il1 = l as (Element of ( ObjectKind ( IC ( SCMPDS ) ) )) by MEMSTR_0:def 3;
reconsider u = the n -started (State of ( SCMPDS )) as (Element of ( product (the Object-Kind of ( SCMPDS )) )) by CARD_3:107;
hereby
let x being set;
assume x in ( NIC (i,l) );
then consider s being (Element of ( product (the Object-Kind of ( SCMPDS )) )) such that A1: x = ( IC ( Exec (i,s) ) ) and A2: ( IC s ) = l;
A3: (ex m1 being (Element of ( NAT )) st (m1 = ( IC s ) & ( ICplusConst (s,k2) ) = ( abs ( m1 + k2 ) ))) by SCMPDS_2:def 18;
per cases ;
suppose A4: ( s . ( DataLoc (( s . a ),k1) ) ) >= ( 0 );

x = t by A1,A2,A3,A4,SCMPDS_2:57;
hence x in { ( succ l ),t } by TARSKI:def 2;
end;
suppose A5: ( s . ( DataLoc (( s . a ),k1) ) ) < ( 0 );

x = ( succ l ) by A1,A2,A5,SCMPDS_2:57;
hence x in { ( succ l ),t } by TARSKI:def 2;
end;
end;
let x being set;
assume A6: x in { ( succ l ),t };
per cases  by A6,TARSKI:def 2;
suppose A7: x = ( succ l );

A8: ( - 1 ) < ( 0 );
reconsider u1 = ( u +* ( a .--> ( - 1 ) ) ) as (State of ( SCMPDS ));
reconsider u1 = ( u +* ( a .--> ( - 1 ) ) ) as (Element of ( product (the Object-Kind of ( SCMPDS )) )) by CARD_3:107;
reconsider u2 = ( u1 +* ( ( DataLoc (( u1 . a ),k1) ) .--> ( - 1 ) ) ) as (Element of ( product (the Object-Kind of ( SCMPDS )) )) by CARD_3:107;
A9: ( IC u2 ) = ( u1 . ( IC ( SCMPDS ) ) ) by FUNCT_4:83,SCMPDS_2:43
.= ( IC u ) by FUNCT_4:83,SCMPDS_2:43
.= n by MEMSTR_0:def 8;
A10: ( u2 . ( DataLoc (( u1 . a ),k1) ) ) = ( - 1 ) by FUNCT_7:94;
( u2 . ( DataLoc (( u2 . a ),k1) ) ) < ( 0 )
proof
per cases ;
suppose a = ( DataLoc (( u1 . a ),k1) );

hence thesis by A10,A8,FUNCT_7:94;
end;
suppose a <> ( DataLoc (( u1 . a ),k1) );

then ( u2 . a ) = ( u1 . a ) by FUNCT_4:83;
hence thesis by A8,FUNCT_7:94;
end;
end;
then x = ( IC ( Exec (i,u2) ) ) by A7,A9,SCMPDS_2:57;
hence thesis by A9;
end;
suppose A11: x = t;

reconsider u1 = ( u +* ( a .--> ( - 1 ) ) ) as (State of ( SCMPDS ));
reconsider u1 = ( u +* ( a .--> ( 0 ) ) ) as (Element of ( product (the Object-Kind of ( SCMPDS )) )) by CARD_3:107;
reconsider u2 = ( u1 +* ( ( DataLoc (( u1 . a ),k1) ) .--> ( 0 ) ) ) as (Element of ( product (the Object-Kind of ( SCMPDS )) )) by CARD_3:107;
A12: ( u2 . ( DataLoc (( u1 . a ),k1) ) ) = ( 0 ) by FUNCT_7:94;
A13: ( u2 . ( DataLoc (( u2 . a ),k1) ) ) >= ( 0 )
proof
per cases ;
suppose a = ( DataLoc (( u1 . a ),k1) );

hence thesis by A12,FUNCT_7:94;
end;
suppose a <> ( DataLoc (( u1 . a ),k1) );

then ( u2 . a ) = ( u1 . a ) by FUNCT_4:83;
hence thesis by FUNCT_7:94;
end;
end;
A14: ( IC u2 ) = ( u1 . ( IC ( SCMPDS ) ) ) by FUNCT_4:83,SCMPDS_2:43
.= ( IC u ) by FUNCT_4:83,SCMPDS_2:43
.= n by MEMSTR_0:def 8;
(ex m1 being (Element of ( NAT )) st (m1 = ( IC u2 ) & ( ICplusConst (u2,k2) ) = ( abs ( m1 + k2 ) ))) by SCMPDS_2:def 18;
then x = ( IC ( Exec (i,u2) ) ) by A11,A14,A13,SCMPDS_2:57;
hence thesis by A14;
end;
end;
