environ
vocabularies NUMBERS,SCMPDS_2,AMI_1,INT_1,FUNCOP_1,SUBSET_1,FSM_1,FUNCT_1,AMISTD_1,FUNCT_4,XBOOLE_0,SETFAM_1,AMI_3,COMPLEX1,ARYTM_3,ORDINAL1,XXREAL_0,ARYTM_1,CARD_1,AMI_2,RELAT_1,GRAPHSP,TARSKI,FINSET_1,XREAL_0,CARD_3,AMI_WSTD;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,ORDINAL1,CARD_3,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,FUNCT_1,INT_1,NAT_1,FINSET_1,COMPLEX1,INT_2,PARTFUN1,FUNCOP_1,RELAT_1,FUNCT_4,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,SCMPDS_2,SCMPDS_3,AMISTD_1,AMI_WSTD,CKB1;
definitions TARSKI,XBOOLE_0,NAT_1,AMI_WSTD,AMISTD_1,COMPOS_1,MEMSTR_0;
theorems AMI_WSTD,SETFAM_1,XBOOLE_0,SCMPDS_1,SCMPDS_2,ABSVALUE,INT_1,TARSKI,AMI_2,NAT_1,XBOOLE_1,FUNCT_4,PRE_CIRC,WSIERP_1,PEPIN,COMPLEX1,XREAL_1,FUNCT_7,NAT_D,ZFMISC_1,PBOOLE,AMISTD_1,COMPOS_1,MEMSTR_0,CARD_3,CKB2,CKB4,CKB5,CKB6,CKB7;
registrations SETFAM_1,ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,CARD_3,SCMPDS_2,FUNCT_1,FUNCT_2,XBOOLE_0,FUNCOP_1,FUNCT_4,AMISTD_1,COMPOS_1,FUNCT_7,RELAT_1,MEMSTR_0,CKB3;
constructors XXREAL_0,REAL_1,NAT_D,REALSET1,SCMPDS_1,SCMPDS_3,AMI_WSTD,PRE_POLY,AMISTD_1,FUNCT_4,FUNCT_7,FUNCOP_1,MEMSTR_0,CKB1;
requirements BOOLE,SUBSET,NUMERALS,ARITHM,REAL;
begin
reserve a for Int_position;
reserve l for (Element of ( NAT ));
theorem
Th10: ( NIC (( return a ),l) ) = { k where k is (Element of ( NAT )): k > 1 }
proof
set s = the (State of ( SCMPDS ));
set X = { k where k is (Element of ( NAT )): k > 1 };
set i = ( return a );
hereby
let x being set;
assume x in ( NIC (i,l) );
then consider s being (Element of ( product (the Object-Kind of ( SCMPDS )) )) such that A1: x = ( IC ( Exec (i,s) ) ) and ( IC s ) = l;
reconsider k = x as (Element of ( NAT )) by A1;
A2: ( ( abs ( s . ( DataLoc (( s . a ),1) ) ) ) + 2 ) >= ( ( 0 ) + 2 ) by XREAL_1:6;
k >= ( 1 + 1 ) by A2,A1,SCMPDS_1:def 21,SCMPDS_2:58;
then k > 1 by NAT_1:13;
hence x in X;
end;
let x being set;
set I = i;
reconsider n = l as (Element of ( NAT ));
assume x in X;
then consider k being (Element of ( NAT )) such that A3: x = k and A4: k > 1;
reconsider il1 = l as (Element of ( ObjectKind ( IC ( SCMPDS ) ) )) by MEMSTR_0:def 3;
reconsider k2 = ( k - 2 ) as (Element of ( NAT )) by A4,CKB7:1;
reconsider u = the n -started (State of ( SCMPDS )) as (Element of ( product (the Object-Kind of ( SCMPDS )) )) by CARD_3:107;
A5: ( IC u ) = n by MEMSTR_0:def 8;
a in ( SCM-Data-Loc ) by SCMPDS_2:def 2;
then consider j being (Element of ( NAT )) such that A6: a = [ 1,j ] by AMI_2:23;
set t = [ 1,( j + 1 ) ];
reconsider t1 = t as Int_position by AMI_2:24,SCMPDS_2:3;
A7: ( DataLoc (j,1) ) = [ 1,( abs ( j + 1 ) ) ] by SCMPDS_2:def 3
.= t by ABSVALUE:def 1;
set g = ( (a,t1) --> (j,k2) );
reconsider v = ( u +* g ) as (Element of ( product (the Object-Kind of ( SCMPDS )) )) by CARD_3:107;
A8: ( dom g ) = { a,t } by FUNCT_4:62;
j <> ( j + 1 );
then A9: a <> t by A6,ZFMISC_1:27;
then A10: ( v . a ) = j by FUNCT_4:84;
(a <> ( IC ( SCMPDS ) ) & t1 <> ( IC ( SCMPDS ) )) by SCMPDS_2:43;
then A11: (not ( IC ( SCMPDS ) ) in ( dom g )) by A8,TARSKI:def 2;
A12: ( IC v ) = l by A5,A11,FUNCT_4:11;
A13: ( v . t ) = k2 by A9,FUNCT_4:84;
x = ( k2 + 2 ) by A3
.= ( ( abs ( v . ( DataLoc (j,1) ) ) ) + 2 ) by A13,A7,ABSVALUE:def 1
.= ( IC ( Exec (i,v) ) ) by A10,SCMPDS_1:def 21,SCMPDS_2:58;
hence thesis by A12;
end;
