environ
vocabularies NUMBERS,SCMPDS_2,AMI_1,INT_1,FUNCOP_1,SUBSET_1,FSM_1,FUNCT_1,AMISTD_1,FUNCT_4,XBOOLE_0,SETFAM_1,AMI_3,COMPLEX1,ARYTM_3,ORDINAL1,XXREAL_0,ARYTM_1,CARD_1,AMI_2,RELAT_1,GRAPHSP,TARSKI,FINSET_1,XREAL_0,CARD_3,AMI_WSTD;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,ORDINAL1,CARD_3,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,FUNCT_1,INT_1,NAT_1,FINSET_1,COMPLEX1,INT_2,PARTFUN1,FUNCOP_1,RELAT_1,FUNCT_4,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,SCMPDS_2,SCMPDS_3,AMISTD_1,AMI_WSTD,CKB1;
definitions TARSKI,XBOOLE_0,NAT_1,AMI_WSTD,AMISTD_1,COMPOS_1,MEMSTR_0;
theorems AMI_WSTD,SETFAM_1,XBOOLE_0,SCMPDS_1,SCMPDS_2,ABSVALUE,INT_1,TARSKI,AMI_2,NAT_1,XBOOLE_1,FUNCT_4,PRE_CIRC,WSIERP_1,PEPIN,COMPLEX1,XREAL_1,FUNCT_7,NAT_D,ZFMISC_1,PBOOLE,AMISTD_1,COMPOS_1,MEMSTR_0,CARD_3,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
registrations SETFAM_1,ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,CARD_3,SCMPDS_2,FUNCT_1,FUNCT_2,XBOOLE_0,FUNCOP_1,FUNCT_4,AMISTD_1,COMPOS_1,FUNCT_7,RELAT_1,MEMSTR_0,CKB3;
constructors XXREAL_0,REAL_1,NAT_D,REALSET1,SCMPDS_1,SCMPDS_3,AMI_WSTD,PRE_POLY,AMISTD_1,FUNCT_4,FUNCT_7,FUNCOP_1,MEMSTR_0,CKB1;
requirements BOOLE,SUBSET,NUMERALS,ARITHM,REAL;
begin
reserve a for Int_position;
theorem
Th23: ( JUMP ( return a ) ) = { k where k is (Element of ( NAT )): k > 1 }
proof
set A = { k where k is (Element of ( NAT )): k > 1 };
set i = ( return a );
set X = { ( NIC (i,l) ) where l is (Element of ( NAT )): (not contradiction) };
( JUMP i ) c= ( NIC (i,( 0 )) ) by AMISTD_1:19;
hence ( JUMP i ) c= A by CKB8:1;
let x being set;
assume A1: x in A;
now
consider k being (Element of ( NAT )) such that A2: x = k and A3: k > 1 by A1;
reconsider k2 = ( k - 2 ) as (Element of ( NAT )) by A3,CKB7:1;
( NIC (i,( 0 )) ) in X;
hence X <> ( {} );
a in ( SCM-Data-Loc ) by SCMPDS_2:def 2;
then consider j being (Element of ( NAT )) such that A4: a = [ 1,j ] by AMI_2:23;
set t = [ 1,( j + 1 ) ];
set s = the (State of ( SCMPDS ));
let y being set;
A5: ( DataLoc (j,1) ) = [ 1,( abs ( j + 1 ) ) ] by SCMPDS_2:def 3
.= t by ABSVALUE:def 1;
reconsider t1 = t as Int_position by AMI_2:24,SCMPDS_2:3;
assume y in X;
then consider l being (Element of ( NAT )) such that A6: y = ( NIC (i,l) );
reconsider n = l as (Element of ( NAT ));
reconsider il1 = l as (Element of ( ObjectKind ( IC ( SCMPDS ) ) )) by MEMSTR_0:def 3;
set I = i;
reconsider u = the n -started (State of ( SCMPDS )) as (Element of ( product (the Object-Kind of ( SCMPDS )) )) by CARD_3:107;
A7: ( IC u ) = n by MEMSTR_0:def 8;
set g = ( (a,t1) --> (j,k2) );
reconsider v = ( u +* g ) as (Element of ( product (the Object-Kind of ( SCMPDS )) )) by CARD_3:107;
j <> ( j + 1 );
then A8: a <> t1 by A4,ZFMISC_1:27;
then A9: ( v . a ) = j by FUNCT_4:84;
A10: ( v . t1 ) = k2 by A8,FUNCT_4:84;
A11: ( dom g ) = { a,t1 } by FUNCT_4:62;
(a <> ( IC ( SCMPDS ) ) & t1 <> ( IC ( SCMPDS ) )) by SCMPDS_2:43;
then A12: (not ( IC ( SCMPDS ) ) in ( dom g )) by A11,TARSKI:def 2;
A13: ( IC v ) = l by A7,A12,FUNCT_4:11;
x = ( k2 + 2 ) by A2
.= ( ( abs ( v . ( DataLoc (j,1) ) ) ) + 2 ) by A10,A5,ABSVALUE:def 1
.= ( IC ( Exec (i,v) ) ) by A9,SCMPDS_1:def 21,SCMPDS_2:58;
hence x in y by A6,A13;
end;
hence thesis by SETFAM_1:def 1;
end;
