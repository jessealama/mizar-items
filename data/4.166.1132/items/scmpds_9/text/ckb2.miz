environ
vocabularies NUMBERS,SCMPDS_2,AMI_1,INT_1,FUNCOP_1,SUBSET_1,FSM_1,FUNCT_1,AMISTD_1,FUNCT_4,XBOOLE_0,SETFAM_1,AMI_3,COMPLEX1,ARYTM_3,ORDINAL1,XXREAL_0,ARYTM_1,CARD_1,AMI_2,RELAT_1,GRAPHSP,TARSKI,FINSET_1,XREAL_0,CARD_3,AMI_WSTD;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,ORDINAL1,CARD_3,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,FUNCT_1,INT_1,NAT_1,FINSET_1,COMPLEX1,INT_2,PARTFUN1,FUNCOP_1,RELAT_1,FUNCT_4,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,SCMPDS_2,SCMPDS_3,AMISTD_1,AMI_WSTD,CKB1;
definitions TARSKI,XBOOLE_0,NAT_1,AMI_WSTD,AMISTD_1,COMPOS_1,MEMSTR_0;
theorems AMI_WSTD,SETFAM_1,XBOOLE_0,SCMPDS_1,SCMPDS_2,ABSVALUE,INT_1,TARSKI,AMI_2,NAT_1,XBOOLE_1,FUNCT_4,PRE_CIRC,WSIERP_1,PEPIN,COMPLEX1,XREAL_1,FUNCT_7,NAT_D,ZFMISC_1,PBOOLE,AMISTD_1,COMPOS_1,MEMSTR_0,CARD_3;
registrations SETFAM_1,ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,CARD_3,SCMPDS_2,FUNCT_1,FUNCT_2,XBOOLE_0,FUNCOP_1,FUNCT_4,AMISTD_1,COMPOS_1,FUNCT_7,RELAT_1,MEMSTR_0;
constructors XXREAL_0,REAL_1,NAT_D,REALSET1,SCMPDS_1,SCMPDS_3,AMI_WSTD,PRE_POLY,AMISTD_1,FUNCT_4,FUNCT_7,FUNCOP_1,MEMSTR_0,CKB1;
requirements BOOLE,SUBSET,NUMERALS,ARITHM,REAL;
begin
reserve k for Integer;
theorem
Lm1: ( JUMP ( goto k ) ) = ( {} )
proof
set i = ( goto k );
set X = { ( NIC (i,l) ) where l is (Element of ( NAT )): (not contradiction) };
hereby
set l2 = 1;
set l1 = ( 0 );
let x being set;
assume A1: x in ( JUMP i );
( NIC (i,l2) ) in X;
then x in ( NIC (i,l2) ) by A1,SETFAM_1:def 1;
then consider s2 being (Element of ( product (the Object-Kind of ( SCMPDS )) )) such that A2: x = ( IC ( Exec (i,s2) ) ) and A3: ( IC s2 ) = l2;
consider m2 being (Element of ( NAT )) such that A4: m2 = ( IC s2 ) and A5: ( ICplusConst (s2,k) ) = ( abs ( m2 + k ) ) by SCMPDS_2:def 18;
( NIC (i,l1) ) in X;
then x in ( NIC (i,l1) ) by A1,SETFAM_1:def 1;
then consider s1 being (Element of ( product (the Object-Kind of ( SCMPDS )) )) such that A6: x = ( IC ( Exec (i,s1) ) ) and A7: ( IC s1 ) = l1;
consider m1 being (Element of ( NAT )) such that A8: m1 = ( IC s1 ) and A9: ( ICplusConst (s1,k) ) = ( abs ( m1 + k ) ) by SCMPDS_2:def 18;
A10: x = ( abs ( m1 + k ) ) by A6,A9,SCMPDS_2:54;
per cases  by A7,A8,A10,A3,A4,A2,A5,ABSVALUE:28,SCMPDS_2:54;
suppose ( ( 0 ) + k ) = ( 1 + k );

hence x in ( {} );
end;
suppose k = ( - ( 1 + k ) );

then ( - ( - ( 1 / 2 ) ) ) is  integer;
hence x in ( {} ) by NAT_D:33;
end;
end;
thus thesis by XBOOLE_1:2;
end;
