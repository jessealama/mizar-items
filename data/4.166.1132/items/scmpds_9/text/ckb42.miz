environ
vocabularies NUMBERS,SCMPDS_2,AMI_1,INT_1,FUNCOP_1,SUBSET_1,FSM_1,FUNCT_1,AMISTD_1,FUNCT_4,XBOOLE_0,SETFAM_1,AMI_3,COMPLEX1,ARYTM_3,ORDINAL1,XXREAL_0,ARYTM_1,CARD_1,AMI_2,RELAT_1,GRAPHSP,TARSKI,FINSET_1,XREAL_0,CARD_3,AMI_WSTD;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,ORDINAL1,CARD_3,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,FUNCT_1,INT_1,NAT_1,FINSET_1,COMPLEX1,INT_2,PARTFUN1,FUNCOP_1,RELAT_1,FUNCT_4,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,SCMPDS_2,SCMPDS_3,AMISTD_1,AMI_WSTD,CKB1;
definitions TARSKI,XBOOLE_0,NAT_1,AMI_WSTD,AMISTD_1,COMPOS_1,MEMSTR_0;
theorems AMI_WSTD,SETFAM_1,XBOOLE_0,SCMPDS_1,SCMPDS_2,ABSVALUE,INT_1,TARSKI,AMI_2,NAT_1,XBOOLE_1,FUNCT_4,PRE_CIRC,WSIERP_1,PEPIN,COMPLEX1,XREAL_1,FUNCT_7,NAT_D,ZFMISC_1,PBOOLE,AMISTD_1,COMPOS_1,MEMSTR_0,CARD_3,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41;
registrations SETFAM_1,ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,CARD_3,SCMPDS_2,FUNCT_1,FUNCT_2,XBOOLE_0,FUNCOP_1,FUNCT_4,AMISTD_1,COMPOS_1,FUNCT_7,RELAT_1,MEMSTR_0,CKB3,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31;
constructors XXREAL_0,REAL_1,NAT_D,REALSET1,SCMPDS_1,SCMPDS_3,AMI_WSTD,PRE_POLY,AMISTD_1,FUNCT_4,FUNCT_7,FUNCOP_1,MEMSTR_0,CKB1;
requirements BOOLE,SUBSET,NUMERALS,ARITHM,REAL;
begin
reserve a for Int_position;
reserve k1 for Integer;
theorem
Lm13: ( JUMP ( (a,k1) >=0_goto 5 ) ) = ( {} )
proof
set k2 = 5;
set i = ( (a,k1) >=0_goto k2 );
set X = { ( NIC (i,l) ) where l is (Element of ( NAT )): (not contradiction) };
hereby
set nl2 = 8;
set nl1 = 5;
let x being set;
assume A1: x in ( JUMP i );
set l2 = nl2;
( NIC (i,l2) ) in X;
then x in ( NIC (i,l2) ) by A1,SETFAM_1:def 1;
then consider s2 being (Element of ( product (the Object-Kind of ( SCMPDS )) )) such that A2: x = ( IC ( Exec (i,s2) ) ) and A3: ( IC s2 ) = l2;
set l1 = nl1;
( NIC (i,l1) ) in X;
then x in ( NIC (i,l1) ) by A1,SETFAM_1:def 1;
then consider s1 being (Element of ( product (the Object-Kind of ( SCMPDS )) )) such that A4: x = ( IC ( Exec (i,s1) ) ) and A5: ( IC s1 ) = l1;
consider m2 being (Element of ( NAT )) such that A6: m2 = ( IC s2 ) and A7: ( ICplusConst (s2,k2) ) = ( abs ( m2 + k2 ) ) by SCMPDS_2:def 18;
consider m1 being (Element of ( NAT )) such that A8: m1 = ( IC s1 ) and A9: ( ICplusConst (s1,k2) ) = ( abs ( m1 + k2 ) ) by SCMPDS_2:def 18;
per cases ;
suppose that A10: ( s1 . ( DataLoc (( s1 . a ),k1) ) ) >= ( 0 )
and
A11: ( s2 . ( DataLoc (( s2 . a ),k1) ) ) >= ( 0 );
A12: x = ( abs ( m2 + k2 ) ) by A2,A7,A11,SCMPDS_2:57;
x = ( abs ( m1 + k2 ) ) by A4,A9,A10,SCMPDS_2:57;
then (( ( ( nl1 + 2 ) - 2 ) + k2 ) = ( ( ( nl2 + 2 ) - 2 ) + k2 ) or ( ( ( nl1 + 2 ) - 2 ) + k2 ) = ( - ( ( ( nl2 + 2 ) - 2 ) + k2 ) )) by A5,A8,A3,A6,A12,ABSVALUE:28;
hence x in ( {} );
end;
suppose that A13: ( s1 . ( DataLoc (( s1 . a ),k1) ) ) < ( 0 )
and
A14: ( s2 . ( DataLoc (( s2 . a ),k1) ) ) < ( 0 );
A15: x = ( succ l2 ) by A2,A3,A14,SCMPDS_2:57;
x = ( succ l1 ) by A4,A5,A13,SCMPDS_2:57;
hence x in ( {} ) by A15;
end;
suppose that A16: ( s1 . ( DataLoc (( s1 . a ),k1) ) ) < ( 0 )
and
A17: ( s2 . ( DataLoc (( s2 . a ),k1) ) ) >= ( 0 );
reconsider n1 = l1 as (Element of ( NAT ));
set w1 = n1;
A18: x = ( abs ( m2 + k2 ) ) by A2,A7,A17,SCMPDS_2:57;
x = ( succ n1 ) by A4,A5,A16,SCMPDS_2:57
.= ( n1 + 1 );
then (( w1 + 1 ) = ( m2 + k2 ) or ( w1 + 1 ) = ( - ( m2 + k2 ) )) by A18,ABSVALUE:1;
hence x in ( {} ) by A3,A6;
end;
suppose that A19: ( s1 . ( DataLoc (( s1 . a ),k1) ) ) >= ( 0 )
and
A20: ( s2 . ( DataLoc (( s2 . a ),k1) ) ) < ( 0 );
reconsider n2 = l2 as (Element of ( NAT ));
A21: x = ( succ n2 ) by A2,A3,A20,SCMPDS_2:57
.= ( n2 + 1 );
set w2 = n2;
x = ( abs ( m1 + k2 ) ) by A4,A9,A19,SCMPDS_2:57;
then (( w2 + 1 ) = ( m1 + k2 ) or ( w2 + 1 ) = ( - ( m1 + k2 ) )) by A21,ABSVALUE:1;
hence x in ( {} ) by A5,A8;
end;
end;
thus thesis by XBOOLE_1:2;
end;
