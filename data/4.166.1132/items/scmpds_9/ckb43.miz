environ
vocabularies NUMBERS,SCMPDS_2,AMI_1,INT_1,FUNCOP_1,SUBSET_1,FSM_1,FUNCT_1,AMISTD_1,FUNCT_4,XBOOLE_0,SETFAM_1,AMI_3,COMPLEX1,ARYTM_3,ORDINAL1,XXREAL_0,ARYTM_1,CARD_1,AMI_2,RELAT_1,GRAPHSP,TARSKI,FINSET_1,XREAL_0,CARD_3,AMI_WSTD;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,ORDINAL1,CARD_3,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,FUNCT_1,INT_1,NAT_1,FINSET_1,COMPLEX1,INT_2,PARTFUN1,FUNCOP_1,RELAT_1,FUNCT_4,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_2,SCMPDS_2,SCMPDS_3,AMISTD_1,AMI_WSTD,CKB1;
definitions TARSKI,XBOOLE_0,NAT_1,AMI_WSTD,AMISTD_1,COMPOS_1,MEMSTR_0;
theorems AMI_WSTD,SETFAM_1,XBOOLE_0,SCMPDS_1,SCMPDS_2,ABSVALUE,INT_1,TARSKI,AMI_2,NAT_1,XBOOLE_1,FUNCT_4,PRE_CIRC,WSIERP_1,PEPIN,COMPLEX1,XREAL_1,FUNCT_7,NAT_D,ZFMISC_1,PBOOLE,AMISTD_1,COMPOS_1,MEMSTR_0,CARD_3,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42;
registrations SETFAM_1,ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,CARD_3,SCMPDS_2,FUNCT_1,FUNCT_2,XBOOLE_0,FUNCOP_1,FUNCT_4,AMISTD_1,COMPOS_1,FUNCT_7,RELAT_1,MEMSTR_0,CKB3,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31;
constructors XXREAL_0,REAL_1,NAT_D,REALSET1,SCMPDS_1,SCMPDS_3,AMI_WSTD,PRE_POLY,AMISTD_1,FUNCT_4,FUNCT_7,FUNCOP_1,MEMSTR_0,CKB1;
requirements BOOLE,SUBSET,NUMERALS,ARITHM,REAL;
begin
reserve a for Int_position;
reserve k1 for Integer;
reserve k2 for Integer;
theorem
Lm14: (k2 <> 5 implies ( JUMP ( (a,k1) >=0_goto k2 ) ) = ( {} ))
proof
set i = ( (a,k1) >=0_goto k2 );
set X = { ( NIC (i,l) ) where l is (Element of ( NAT )): (not contradiction) };
assume A1: k2 <> 5;
hereby
set x1 = ( ( ( - k2 ) + ( abs k2 ) ) + 4 );
let x being set;
assume A2: x in ( JUMP i );
A3: x1 > ( ( ( - k2 ) + ( abs k2 ) ) + ( 0 ) ) by XREAL_1:6;
then A4: x1 > ( 0 ) by ABSVALUE:27;
then reconsider x1 as (Element of ( NAT )) by INT_1:3;
set nl1 = ( ( abs k2 ) + x1 );
set nl2 = ( nl1 + x1 );
set l1 = nl1;
set l2 = nl2;
( NIC (i,l1) ) in X;
then x in ( NIC (i,l1) ) by A2,SETFAM_1:def 1;
then consider s1 being (Element of ( product (the Object-Kind of ( SCMPDS )) )) such that A5: x = ( IC ( Exec (i,s1) ) ) and A6: ( IC s1 ) = l1;
consider m1 being (Element of ( NAT )) such that A7: m1 = ( IC s1 ) and A8: ( ICplusConst (s1,k2) ) = ( abs ( m1 + k2 ) ) by SCMPDS_2:def 18;
( NIC (i,l2) ) in X;
then x in ( NIC (i,l2) ) by A2,SETFAM_1:def 1;
then consider s2 being (Element of ( product (the Object-Kind of ( SCMPDS )) )) such that A9: x = ( IC ( Exec (i,s2) ) ) and A10: ( IC s2 ) = l2;
consider m2 being (Element of ( NAT )) such that A11: m2 = ( IC s2 ) and A12: ( ICplusConst (s2,k2) ) = ( abs ( m2 + k2 ) ) by SCMPDS_2:def 18;
per cases ;
suppose that A13: ( s1 . ( DataLoc (( s1 . a ),k1) ) ) >= ( 0 )
and
A14: ( s2 . ( DataLoc (( s2 . a ),k1) ) ) >= ( 0 );
A15: x = ( abs ( m2 + k2 ) ) by A9,A12,A14,SCMPDS_2:57;
A16: x = ( abs ( m1 + k2 ) ) by A5,A8,A13,SCMPDS_2:57;
thus x in ( {} )
proof
per cases  by A6,A7,A10,A11,A16,A15,ABSVALUE:28;
suppose ( ( ( nl1 + 2 ) - 2 ) + k2 ) = ( ( ( nl2 + 2 ) - 2 ) + k2 );

hence thesis by A3,ABSVALUE:27;
end;
suppose ( ( ( nl1 + 2 ) - 2 ) + k2 ) = ( - ( ( ( nl2 + 2 ) - 2 ) + k2 ) );

hence thesis by CKB33:1;
end;
end;

end;
suppose that A17: ( s1 . ( DataLoc (( s1 . a ),k1) ) ) < ( 0 )
and
A18: ( s2 . ( DataLoc (( s2 . a ),k1) ) ) < ( 0 );
A19: x = ( succ l2 ) by A9,A10,A18,SCMPDS_2:57;
x = ( succ l1 ) by A5,A6,A17,SCMPDS_2:57;
hence x in ( {} ) by A3,A19,ABSVALUE:27;
end;
suppose that A20: ( s1 . ( DataLoc (( s1 . a ),k1) ) ) < ( 0 )
and
A21: ( s2 . ( DataLoc (( s2 . a ),k1) ) ) >= ( 0 );
reconsider n1 = l1 as (Element of ( NAT ));
set w1 = n1;
A22: x = ( abs ( m2 + k2 ) ) by A9,A12,A21,SCMPDS_2:57;
A23: x = ( succ n1 ) by A5,A6,A20,SCMPDS_2:57
.= ( n1 + 1 );
thus x in ( {} )
proof
per cases  by A23,A22,ABSVALUE:1;
suppose ( w1 + 1 ) = ( m2 + k2 );

then ( nl1 + 1 ) = ( nl1 + ( x1 + k2 ) ) by A10,A11;
hence thesis by CKB34:1;
end;
suppose ( w1 + 1 ) = ( - ( m2 + k2 ) );

hence thesis by A4,A10,A11,CKB35:1;
end;
end;

end;
suppose that A24: ( s1 . ( DataLoc (( s1 . a ),k1) ) ) >= ( 0 )
and
A25: ( s2 . ( DataLoc (( s2 . a ),k1) ) ) < ( 0 );
reconsider n2 = l2 as (Element of ( NAT ));
A26: x = ( succ n2 ) by A9,A10,A25,SCMPDS_2:57
.= ( n2 + 1 );
set w2 = n2;
A27: x = ( abs ( m1 + k2 ) ) by A5,A8,A24,SCMPDS_2:57;
thus x in ( {} )
proof
per cases  by A27,A26,ABSVALUE:1;
suppose ( w2 + 1 ) = ( m1 + k2 );

hence thesis by A1,A6,A7,CKB36:1;
end;
suppose ( w2 + 1 ) = ( - ( m1 + k2 ) );

hence thesis by A4,A6,A7,CKB37:1;
end;
end;

end;
end;
thus thesis by XBOOLE_1:2;
end;
