environ
vocabularies NUMBERS,FINSEQ_1,ORDINAL4,XBOOLE_0,SUBSET_1,RELAT_1,BINTREE1,TREES_1,MARGREL1,TARSKI,ORDINAL1,CARD_1,ARYTM_3,PARTFUN1,FUNCT_1,XBOOLEAN,TREES_2,FINSEQ_2,TREES_4,ZFMISC_1,FUNCOP_1,MCART_1,FINSEQ_5,NAT_1,BINARITH,CAT_1,XXREAL_0,EUCLID,FINSET_1,POWER,ARYTM_1,BINARI_3,INT_1,ABIAN,BINTREE2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,MCART_1,NAT_1,NAT_D,ABIAN,SERIES_1,RELAT_1,MARGREL1,DOMAIN_1,FUNCT_1,PARTFUN1,FUNCT_2,BINOP_1,FINSET_1,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_5,BINARITH,BINARI_3,TREES_1,TREES_2,TREES_4,BINTREE1,EUCLID,XXREAL_0,CKB5;
definitions TARSKI,XBOOLE_0,EUCLID,FINSEQ_2,MARGREL1,XBOOLEAN,BINOP_1;
theorems TARSKI,MCART_1,NAT_1,NAT_2,WELLORD2,ZFMISC_1,FUNCT_1,FUNCT_2,CARD_1,CARD_2,POWER,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,FINSEQ_5,FINSEQ_6,BINARI_3,TREES_1,TREES_2,BINTREE1,XBOOLE_0,XBOOLE_1,XREAL_1,NAT_D,PARTFUN1,RELAT_1,ORDINAL1,XXREAL_0,XREAL_0,TREES_9,CKB1,CKB2,CKB3,CKB4,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11;
schemes FUNCT_2,NAT_1,FINSEQ_2,TREES_2,FUNCT_1,CKB12;
registrations XBOOLE_0,SUBSET_1,ORDINAL1,RELSET_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,FINSEQ_1,MARGREL1,TREES_2,TREES_9,BINTREE1,FINSEQ_2,INT_1,CARD_1;
constructors WELLORD2,DOMAIN_1,XXREAL_0,NAT_1,NAT_D,FINSEQOP,SERIES_1,BINARITH,FINSEQ_5,TREES_9,ABIAN,EUCLID,BINTREE1,BINARI_3,ORDINAL1,RELSET_1,CKB5;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
scheme DecoratedBinTreeEx1 { A() -> non  empty set,a() -> (Element of A()),P[set,set],Q[set,set] } : (ex D being  binary (DecoratedTree of A()) st ((( dom D ) = ( { ( 0 ),1 } * ) & ( D . ( {} ) ) = a()) & (for x being (Node of D) holds (P[ ( D . x ),( D . ( x ^ <* ( 0 ) *> ) ) ] & Q[ ( D . x ),( D . ( x ^ <* 1 *> ) ) ]))))
provided
A1: (for a being (Element of A()) holds (ex b being (Element of A()) st P[ a,b ]))
and
A2: (for a being (Element of A()) holds (ex b being (Element of A()) st Q[ a,b ]))
proof
deffunc F(set) = 2;
defpred P1[ set,set ]
 means
((( $1 `2 ) = ( 0 ) implies P[ ( $1 `1 ),$2 ]) & (( $1 `2 ) = 1 implies Q[ ( $1 `1 ),$2 ]));
A3: (for e being set holds (e in [: A(),( NAT ) :] implies (ex u being set st (u in A() & P1[ e,u ]))))
proof
let e being set;
assume e in [: A(),( NAT ) :];
then reconsider e1 = ( e `1 ) as (Element of A()) by MCART_1:10;
consider u1 being (Element of A()) such that A4: P[ e1,u1 ] by A1;
consider u2 being (Element of A()) such that A5: Q[ e1,u2 ] by A2;
take u = ( IFEQ (( e `2 ),( 0 ),u1,u2) );
thus u in A();
thus (( e `2 ) = ( 0 ) implies P[ ( e `1 ),u ]) by A4,FUNCOP_1:def 8;
thus thesis by A5,FUNCOP_1:def 8;
end;
consider F being Function such that A6: (( dom F ) = [: A(),( NAT ) :] & ( rng F ) c= A()) and A7: (for e being set holds (e in [: A(),( NAT ) :] implies P1[ e,( F . e ) ])) from FUNCT_1:sch 5(A3);
reconsider F as (Function of [: A(),( NAT ) :],A()) by A6,FUNCT_2:2;
consider D being (DecoratedTree of A()) such that A8: ( D . ( {} ) ) = a() and A9: (for d being (Element of ( dom D )) holds (( succ d ) = { ( d ^ <* k *> ) where k is (Element of ( NAT )): k < F(( D . d )) } & (for n being (Element of ( NAT )) holds (n < F(( D . d )) implies ( D . ( d ^ <* n *> ) ) = ( F . (( D . d ),n) ))))) from TREES_2:sch 9;
now
let t being (Element of ( dom D ));
assume (not t in ( Leaves ( dom D ) ));
{ ( t ^ <* k *> ) where k is (Element of ( NAT )): k < 2 } = { ( t ^ <* ( 0 ) *> ),( t ^ <* 1 *> ) }
proof
thus { ( t ^ <* k *> ) where k is (Element of ( NAT )): k < 2 } c= { ( t ^ <* ( 0 ) *> ),( t ^ <* 1 *> ) }
proof
let v being set;
assume v in { ( t ^ <* k *> ) where k is (Element of ( NAT )): k < 2 };
then consider k being (Element of ( NAT )) such that A10: v = ( t ^ <* k *> ) and A11: k < 2;
(k = ( 0 ) or k = 1) by A11,NAT_1:23;
hence thesis by A10,TARSKI:def 2;
end;

let v being set;
assume v in { ( t ^ <* ( 0 ) *> ),( t ^ <* 1 *> ) };
then (v = ( t ^ <* ( 0 ) *> ) or v = ( t ^ <* 1 *> )) by TARSKI:def 2;
hence thesis;
end;
hence ( succ t ) = { ( t ^ <* ( 0 ) *> ),( t ^ <* 1 *> ) } by A9;
end;
then ( dom D ) is  binary by BINTREE1:def 2;
then reconsider D as  binary (DecoratedTree of A()) by BINTREE1:def 3;
take D;
now
let t being (Element of ( dom D ));
{ ( t ^ <* k *> ) where k is (Element of ( NAT )): k < 2 } = { ( t ^ <* ( 0 ) *> ),( t ^ <* 1 *> ) }
proof
thus { ( t ^ <* k *> ) where k is (Element of ( NAT )): k < 2 } c= { ( t ^ <* ( 0 ) *> ),( t ^ <* 1 *> ) }
proof
let v being set;
assume v in { ( t ^ <* k *> ) where k is (Element of ( NAT )): k < 2 };
then consider k being (Element of ( NAT )) such that A12: v = ( t ^ <* k *> ) and A13: k < 2;
(k = ( 0 ) or k = 1) by A13,NAT_1:23;
hence thesis by A12,TARSKI:def 2;
end;

let v being set;
assume v in { ( t ^ <* ( 0 ) *> ),( t ^ <* 1 *> ) };
then (v = ( t ^ <* ( 0 ) *> ) or v = ( t ^ <* 1 *> )) by TARSKI:def 2;
hence thesis;
end;
hence ( succ t ) = { ( t ^ <* ( 0 ) *> ),( t ^ <* 1 *> ) } by A9;
end;
hence ( dom D ) = ( { ( 0 ),1 } * ) by CKB11:1;
thus ( D . ( {} ) ) = a() by A8;
let x being (Node of D);
( [ ( D . x ),( 0 ) ] `2 ) = ( 0 ) by MCART_1:7;
then P[ ( [ ( D . x ),( 0 ) ] `1 ),( F . [ ( D . x ),( 0 ) ] ) ] by A7;
then P[ ( D . x ),( F . (( D . x ),( 0 )) ) ] by MCART_1:7;
hence P[ ( D . x ),( D . ( x ^ <* ( 0 ) *> ) ) ] by A9;
( [ ( D . x ),1 ] `2 ) = 1 by MCART_1:7;
then Q[ ( [ ( D . x ),1 ] `1 ),( F . [ ( D . x ),1 ] ) ] by A7;
then Q[ ( D . x ),( F . (( D . x ),1) ) ] by MCART_1:7;
hence thesis by A9;
end;
