environ
vocabularies NUMBERS,FINSEQ_1,ORDINAL4,XBOOLE_0,SUBSET_1,RELAT_1,BINTREE1,TREES_1,MARGREL1,TARSKI,ORDINAL1,CARD_1,ARYTM_3,PARTFUN1,FUNCT_1,XBOOLEAN,TREES_2,FINSEQ_2,TREES_4,ZFMISC_1,FUNCOP_1,MCART_1,FINSEQ_5,NAT_1,BINARITH,CAT_1,XXREAL_0,EUCLID,FINSET_1,POWER,ARYTM_1,BINARI_3,INT_1,ABIAN,BINTREE2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,MCART_1,NAT_1,NAT_D,ABIAN,SERIES_1,RELAT_1,MARGREL1,DOMAIN_1,FUNCT_1,PARTFUN1,FUNCT_2,BINOP_1,FINSET_1,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_5,BINARITH,BINARI_3,TREES_1,TREES_2,TREES_4,BINTREE1,EUCLID,XXREAL_0;
definitions TARSKI,XBOOLE_0,EUCLID,FINSEQ_2,MARGREL1,XBOOLEAN,BINOP_1;
theorems TARSKI,MCART_1,NAT_1,NAT_2,WELLORD2,ZFMISC_1,FUNCT_1,FUNCT_2,CARD_1,CARD_2,POWER,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,FINSEQ_5,FINSEQ_6,BINARI_3,TREES_1,TREES_2,BINTREE1,XBOOLE_0,XBOOLE_1,XREAL_1,NAT_D,PARTFUN1,RELAT_1,ORDINAL1,XXREAL_0,XREAL_0,TREES_9,CKB1,CKB2,CKB3;
schemes FUNCT_2,NAT_1,FINSEQ_2,TREES_2,FUNCT_1;
registrations XBOOLE_0,SUBSET_1,ORDINAL1,RELSET_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,FINSEQ_1,MARGREL1,TREES_2,TREES_9,BINTREE1,FINSEQ_2,INT_1,CARD_1;
constructors WELLORD2,DOMAIN_1,XXREAL_0,NAT_1,NAT_D,FINSEQOP,SERIES_1,BINARITH,FINSEQ_5,TREES_9,ABIAN,EUCLID,BINTREE1,BINARI_3,ORDINAL1,RELSET_1;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
theorem
Th2: (for T being  binary Tree holds (for t being (Element of T) holds t is (FinSequence of ( BOOLEAN ))))
proof
let T being  binary Tree;
let t being (Element of T);
defpred P[ FinSequence ]
 means
($1 is (Element of T) implies ( rng $1 ) c= ( BOOLEAN ));
A1: (for p being (FinSequence of ( NAT )) holds (for x being (Element of ( NAT )) holds (P[ p ] implies P[ ( p ^ <* x *> ) ])))
proof
let p being (FinSequence of ( NAT ));
let x being (Element of ( NAT ));
assume A2: P[ p ];
assume A3: ( p ^ <* x *> ) is (Element of T);
then reconsider p1 = p as (Element of T) by TREES_1:21;
( p ^ <* x *> ) in { ( p ^ <* n *> ) where n is (Element of ( NAT )): ( p ^ <* n *> ) in T } by A3;
then A4: ( p ^ <* x *> ) in ( succ p1 ) by TREES_2:def 5;
then (not p in ( Leaves T )) by BINTREE1:3;
then ( succ p1 ) = { ( p ^ <* ( 0 ) *> ),( p ^ <* 1 *> ) } by BINTREE1:def 2;
then (( p ^ <* x *> ) = ( p ^ <* ( 0 ) *> ) or ( p ^ <* x *> ) = ( p ^ <* 1 *> )) by A4,TARSKI:def 2;
then (x = ( 0 ) or x = 1) by FINSEQ_2:17;
then A5: x in { ( 0 ),1 } by TARSKI:def 2;
A6: { x } c= ( BOOLEAN )
proof
let z being set;
assume z in { x };
hence thesis by A5,TARSKI:def 1;
end;
( rng <* x *> ) = { x } by FINSEQ_1:38;
then ( ( rng p ) \/ ( rng <* x *> ) ) c= ( BOOLEAN ) by A2,A3,A6,TREES_1:21,XBOOLE_1:8;
hence thesis by FINSEQ_1:31;
end;
A7: P[ ( <*> ( NAT ) ) ] by RELAT_1:38,XBOOLE_1:2;
(for p being (FinSequence of ( NAT )) holds P[ p ]) from FINSEQ_2:sch 2(A7,A1);
then ( rng t ) c= ( BOOLEAN );
hence thesis by FINSEQ_1:def 4;
end;
