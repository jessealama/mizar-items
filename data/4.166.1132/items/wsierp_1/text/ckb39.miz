environ
vocabularies NUMBERS,XREAL_0,ORDINAL1,NAT_1,INT_1,RAT_1,NEWTON,RELAT_1,ARYTM_1,ARYTM_3,XXREAL_0,CARD_1,PREPOWER,INT_2,COMPLEX1,SUBSET_1,FINSEQ_1,FUNCT_1,XBOOLE_0,ORDINAL4,TARSKI,VALUED_0,CARD_3,FINSEQ_3,REAL_1,SQUARE_1;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,NUMBERS,XCMPLX_0,XREAL_0,INT_1,REAL_1,NAT_1,NAT_D,RAT_1,INT_2,XXREAL_0,VALUED_0,PREPOWER,SQUARE_1,FUNCT_1,FINSEQ_1,FINSEQ_3,SEQ_1,RVSUM_1,FINSEQ_4,NEWTON,TREES_4,CKB30,CKB31,CKB36,CKB37;
definitions FINSEQ_1,TARSKI,SQUARE_1,RVSUM_1;
theorems TARSKI,ABSVALUE,INT_1,NAT_1,INT_2,RAT_1,NEWTON,PREPOWER,SQUARE_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,FUNCT_1,RVSUM_1,PRE_FF,CARD_4,FINSEQ_3,FINSEQ_5,XBOOLE_1,XCMPLX_0,XCMPLX_1,XREAL_1,CARD_1,XXREAL_0,ORDINAL1,FINSOP_1,NAT_D,XREAL_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB38;
schemes NAT_1,FINSEQ_1,FINSEQ_2;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,NUMBERS,SEQM_3,XXREAL_0,XREAL_0,SQUARE_1,NAT_1,INT_1,RAT_1,MEMBERED,FINSEQ_1,NEWTON,VALUED_0,CARD_1,CKB7,CKB29,CKB32,CKB33,CKB34,CKB35;
constructors REAL_1,SQUARE_1,NAT_1,NAT_D,BINOP_2,FINSEQ_3,FINSEQ_4,FINSOP_1,RVSUM_1,NEWTON,PREPOWER,TREES_4,SEQ_1,RELSET_1,CKB30,CKB31,CKB36,CKB37;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve a for Nat;
reserve b for Nat;
reserve k for Integer;
reserve fs for FinSequence;
definition
let a being Nat;
let fs;
redefine func Del (fs,a) means 
:Def1: it = fs if (not a in ( dom fs )) otherwise (( ( len it ) + 1 ) = ( len fs ) & (for b holds ((b < a implies ( it . b ) = ( fs . b )) & (b >= a implies ( it . b ) = ( fs . ( b + 1 ) )))));
compatibility
proof
let IT being FinSequence;
thus ((not a in ( dom fs )) implies (IT = ( Del (fs,a) ) iff IT = fs)) by FINSEQ_3:104;
assume A1: a in ( dom fs );
hereby
assume A2: IT = ( Del (fs,a) );
then A3: (ex m being Nat st (( len fs ) = ( m + 1 ) & ( len IT ) = m)) by A1,FINSEQ_3:104;
hence ( ( len IT ) + 1 ) = ( len fs );
let b;
thus (b < a implies ( IT . b ) = ( fs . b )) by A2,FINSEQ_3:110;
assume A4: b >= a;
per cases ;
suppose b <= ( len IT );

hence ( IT . b ) = ( fs . ( b + 1 ) ) by A1,A2,A3,A4,FINSEQ_3:111;
end;
suppose A5: b > ( len IT );

then (not b in ( dom IT )) by FINSEQ_3:25;
then A6: ( IT . b ) = ( {} ) by FUNCT_1:def 2;
( b + 1 ) > ( ( len IT ) + 1 ) by A5,XREAL_1:6;
then (not ( b + 1 ) in ( dom fs )) by A3,FINSEQ_3:25;
hence ( IT . b ) = ( fs . ( b + 1 ) ) by A6,FUNCT_1:def 2;
end;
end;
assume that
A7: ( ( len IT ) + 1 ) = ( len fs )
and
A8: (for b holds ((b < a implies ( IT . b ) = ( fs . b )) & (b >= a implies ( IT . b ) = ( fs . ( b + 1 ) ))));
A9: (for k being Nat holds ((1 <= k & k <= ( len IT )) implies ( IT . k ) = ( ( Del (fs,a) ) . k )))
proof
let k being Nat;
assume that
1 <= k
and
A10: k <= ( len IT );
reconsider k as (Element of ( NAT )) by ORDINAL1:def 12;
per cases ;
suppose A11: k < a;

then ( IT . k ) = ( fs . k ) by A8;
hence thesis by A11,FINSEQ_3:110;
end;
suppose A12: k >= a;

then ( IT . k ) = ( fs . ( k + 1 ) ) by A8;
hence thesis by A1,A7,A10,A12,FINSEQ_3:111;
end;
end;
(ex m being Nat st (( len fs ) = ( m + 1 ) & ( len ( Del (fs,a) ) ) = m)) by A1,FINSEQ_3:104;
hence thesis by A7,A9,FINSEQ_1:14;
end;
correctness;
end;
