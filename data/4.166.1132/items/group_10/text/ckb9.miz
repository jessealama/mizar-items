environ
vocabularies NUMBERS,XBOOLE_0,STRUCT_0,GROUP_9,SUBSET_1,ORDINAL4,FUNCT_1,RELAT_1,TARSKI,GROUP_1,ALGSTR_0,ZFMISC_1,FUNCT_2,BINOP_1,SETFAM_1,CARD_1,FINSET_1,ORDINAL1,CARD_FIN,GROUP_2,EQREL_1,INT_2,NEWTON,INT_1,XXREAL_0,ARYTM_3,FINSEQ_1,NAT_1,PARTFUN1,CQC_SIM1,CARD_3,FUNCOP_1,FINSEQ_2,NAT_3,GR_CY_1,BINOP_2,XREAL_0,XCMPLX_0,ARYTM_1,RLSUB_1,GROUP_4,GRAPH_1,GROUP_3,REALSET1,GROUP_10;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,CARD_1,NUMBERS,XCMPLX_0,ZFMISC_1,XXREAL_0,XREAL_0,INT_2,NAT_1,NAT_D,FINSET_1,RELAT_1,REALSET1,FUNCT_1,RELSET_1,FUNCT_2,FINSEQ_1,RVSUM_1,STRUCT_0,ALGSTR_0,GROUP_1,GROUP_2,GROUP_3,EQREL_1,FUNCOP_1,WSIERP_1,NEWTON,DOMAIN_1,GR_CY_1,ORDINAL1,GROUP_4,CARD_FIN,PARTFUN1,NAT_3,TOPGRP_1,CKB1,CKB2,CKB3,CKB5,CKB8;
definitions CARD_1,GROUP_2,TARSKI,REALSET1,RELAT_1,WELLORD2,STRUCT_0,FUNCT_2,CKB3;
theorems FINSEQ_1,GROUP_2,GROUP_3,TARSKI,GROUP_6,FINSEQ_2,FUNCT_1,FUNCT_2,RELAT_1,XBOOLE_0,XBOOLE_1,NAT_1,GROUP_1,XREAL_1,RELSET_1,PARTFUN1,FINSEQ_3,INT_1,ZFMISC_1,CARD_1,CARD_2,FINSET_1,XCMPLX_1,ORDINAL1,FINSEQ_4,XXREAL_0,STRUCT_0,NAT_D,GR_CY_1,NEWTON,CARD_FIN,WEDDWITT,WELLORD2,EQREL_1,FUNCOP_1,RVSUM_1,PEPIN,NAT_4,GROUP_8,NAT_3,GROUP_9,GR_CY_2,TOPGRP_1,VALUED_1,XREAL_0,CKB3;
schemes FUNCT_1,FINSEQ_1,NAT_1,FUNCT_2,SUBSET_1,CLASSES1,CKB6;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,ORDINAL1,RELSET_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,INT_1,CARD_1,FINSEQ_1,NEWTON,STRUCT_0,GROUP_2,GROUP_1,GROUP_3,GR_CY_1,FUNCT_2,NAT_3,REALSET1,VALUED_0,DYNKIN,CKB4,CKB7;
constructors SETFAM_1,WELLORD2,NAT_D,EQREL_1,BINARITH,WSIERP_1,REALSET2,GR_CY_1,GROUP_4,CARD_FIN,NAT_3,TOPGRP_1,SEQ_1,DYNKIN,RELSET_1,CKB2,CKB3;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
definition
let S being  Group-like  associative non  empty multMagma;
func the_left_operation_of S -> (LeftOperation of S,(the carrier of S)) means 
:Def2: (for s being (Element of S) holds ( it . s ) = ( the_left_translation_of s ));
existence
proof
deffunc f((Element of S)) = ( the_left_translation_of $1 );
set E = (the carrier of S);
A1: (for s1,s2 being (Element of S) holds f(( s1 * s2 )) = ( f(s1) * f(s2) ))
proof
let s1 being (Element of S);
let s2 being (Element of S);
set f12 = ( the_left_translation_of ( s1 * s2 ) );
set f1 = ( the_left_translation_of s1 );
set f2 = ( the_left_translation_of s2 );
f1 in ( Funcs (E,E) ) by FUNCT_2:9;
then A2: (ex f being Function st ((f1 = f & ( dom f ) = E) & ( rng f ) c= E)) by FUNCT_2:def 2;
f2 in ( Funcs (E,E) ) by FUNCT_2:9;
then A3: (ex f being Function st ((f2 = f & ( dom f ) = E) & ( rng f ) c= E)) by FUNCT_2:def 2;
f12 in ( Funcs (E,E) ) by FUNCT_2:9;
then A4: (ex f being Function st ((f12 = f & ( dom f ) = E) & ( rng f ) c= E)) by FUNCT_2:def 2;
A5:now
let x being set;
hereby
assume A6: x in ( dom f12 );
hence x in ( dom f2 ) by A3;
( f2 . x ) in ( rng f2 ) by A3,A6,FUNCT_1:3;
hence ( f2 . x ) in ( dom f1 ) by A2;
end;
assume that
A7: x in ( dom f2 )
and
( f2 . x ) in ( dom f1 );
thus x in ( dom f12 ) by A4,A7;
end;
now
let x being set;
assume A8: x in ( dom f12 );
then reconsider s19 = x as (Element of S);
( f2 . x ) in ( rng f2 ) by A3,A8,FUNCT_1:3;
then reconsider s199 = ( f2 . x ) as (Element of S);
thus ( f12 . x ) = ( ( s1 * s2 ) * s19 ) by TOPGRP_1:def 1
.= ( s1 * ( s2 * s19 ) ) by GROUP_1:def 3
.= ( s1 * s199 ) by TOPGRP_1:def 1
.= ( f1 . ( f2 . x ) ) by TOPGRP_1:def 1;
end;
hence thesis by A5,FUNCT_1:10;
end;
A9: f(( 1_ S )) = ( id E )
proof
set f = ( the_left_translation_of ( 1_ S ) );
A10:now
let x being set;
assume x in E;
then reconsider s1 = x as (Element of S);
( f . s1 ) = ( ( 1_ S ) * s1 ) by TOPGRP_1:def 1;
hence ( f . x ) = x by GROUP_1:def 4;
end;
f in ( Funcs (E,E) ) by FUNCT_2:9;
then (ex f9 being Function st ((f = f9 & ( dom f9 ) = E) & ( rng f9 ) c= E)) by FUNCT_2:def 2;
hence thesis by A10,FUNCT_1:17;
end;
(ex T being (LeftOperation of S,E) st (for s being (Element of S) holds ( T . s ) = f(s))) from CKB6:sch 1(A9,A1);
hence thesis;
end;
uniqueness
proof
let T1 being (LeftOperation of S,(the carrier of S));
let T2 being (LeftOperation of S,(the carrier of S));
assume that
A11: (for s being (Element of S) holds ( T1 . s ) = ( the_left_translation_of s ))
and
A12: (for s being (Element of S) holds ( T2 . s ) = ( the_left_translation_of s ));
let x being (Element of S);
thus ( T1 . x ) = ( the_left_translation_of x ) by A11
.= ( T2 . x ) by A12;
end;
end;
