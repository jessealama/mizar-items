environ
vocabularies NUMBERS,FUNCT_1,RELAT_1,FUNCT_4,FUNCOP_1,XBOOLE_0,TARSKI,GLIB_003,VALUED_0,SUBSET_1,REAL_1,GRAPH_5,FINSET_1,ZFMISC_1,TREES_1,GLIB_000,PBOOLE,CARD_1,XXREAL_0,CARD_3,XREAL_0,ORDINAL1,ARYTM_1,PARTFUN1,ARYTM_3,GLIB_001,ABIAN,NAT_1,FINSEQ_1,GRAPH_1,RCOMP_1,INT_1,PRE_POLY,UPROOTS,SGRAPH1,GLIB_005;
notations TARSKI,XBOOLE_0,CARD_1,NUMBERS,SUBSET_1,XCMPLX_0,XXREAL_0,XREAL_0,DOMAIN_1,REAL_1,RELAT_1,VALUED_0,PARTFUN1,FUNCT_1,PBOOLE,FINSEQ_1,FUNCT_2,GRAPH_5,ORDINAL1,UPROOTS,RELSET_1,FINSET_1,INT_1,NAT_1,FUNCOP_1,FUNCT_4,GLIB_000,GLIB_001,ABIAN,GLIB_002,GLIB_003,PRE_POLY,CKB5,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB20,CKB21,CKB22,CKB23,CKB24,CKB27,CKB30;
definitions TARSKI,GLIB_000,GLIB_003,FUNCOP_1,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB20,CKB21,CKB22,CKB24,CKB27,CKB30;
theorems CARD_1,CARD_2,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FUNCT_1,FUNCT_2,FUNCT_4,GLIB_000,GLIB_001,GLIB_003,GLIB_004,GRAPH_5,ABIAN,INT_1,NAT_1,PBOOLE,PEPIN,TARSKI,UPROOTS,XBOOLE_0,XBOOLE_1,ZFMISC_1,XREAL_1,XXREAL_0,ORDINAL1,NAT_D,VALUED_0,RELSET_1,PARTFUN1,RELAT_1,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30;
schemes NAT_1,SUBSET_1,FINSEQ_1,CLASSES1,RECDEF_1,GRAPH_5;
registrations XBOOLE_0,RELAT_1,PARTFUN1,INT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,MEMBERED,FINSEQ_1,GLIB_000,ABIAN,GLIB_001,GLIB_002,GLIB_003,VALUED_0,FUNCT_2,CARD_1,PRE_CIRC,PRE_POLY,RELSET_1,CKB6,CKB7,CKB8;
constructors DOMAIN_1,FUNCT_4,NAT_D,GRAPH_2,GRAPH_5,UPROOTS,GLIB_004,SEQ_1,XXREAL_2,RELSET_1,PBOOLE,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB20,CKB21,CKB22,CKB23,CKB24,CKB27,CKB30;
requirements ARITHM,BOOLE,NUMERALS,REAL,SUBSET;
begin
theorem
Th8: (for G being  real-weighted WGraph holds (for EL being (FF:ELabeling of G) holds (for source being (Vertex of G) holds (for n being Nat holds (for v being set holds (v in ( dom ( ( AP:CompSeq (EL,source) ) . n ) ) implies (ex P being (Path of G) st ((P is_augmenting_wrt EL & P is_Walk_from source,v) & ( P .vertices() ) c= ( dom ( ( AP:CompSeq (EL,source) ) . n ) )))))))))
proof
let G being  real-weighted WGraph;
let EL being (FF:ELabeling of G);
let source being (Vertex of G);
set CS = ( AP:CompSeq (EL,source) );
set G0 = ( CS . ( 0 ) );
defpred P[ Nat ]
 means
(for v being set holds (v in ( dom ( CS . $1 ) ) implies (ex P being (Path of G) st ((P is_augmenting_wrt EL & P is_Walk_from source,v) & ( P .vertices() ) c= ( dom ( CS . $1 ) )))));
A1:now
let n being Nat;
set Gn = ( CS . n );
set Gn1 = ( CS . ( n + 1 ) );
set Next = ( AP:NextBestEdges Gn );
set e = ( choose Next );
assume A2: P[ n ];
A3: Gn1 = ( AP:Step Gn ) by CKB24:def 1;
now
per cases ;
suppose Next = ( {} );

then Gn1 = Gn by A3,CKB21:def 1;
hence P[ ( n + 1 ) ] by A2;
end;
suppose A4: Next <> ( {} );

set se = ( ( the_Source_of G ) . e );
set te = ( ( the_Target_of G ) . e );
now
per cases  by A4,CKB20:def 1;
suppose A5: e is_forward_edge_wrt Gn;

then A6: ( EL . e ) < ( ( the_Weight_of G ) . e ) by CKB14:def 1;
let v being set;
assume A7: v in ( dom Gn1 );
A8: e in ( the_Edges_of G ) by A5,CKB14:def 1;
then A9: e DJoins se,te,G by GLIB_000:def 14;
A10: se in ( dom Gn ) by A5,CKB14:def 1;
then Gn1 = ( Gn +* ( te .--> e ) ) by A3,A4,CKB21:def 1;
then A11: ( dom Gn1 ) = ( ( dom Gn ) \/ { te } ) by CKB1:1;
te in { te } by TARSKI:def 1;
then A12: te in ( dom Gn1 ) by A11,XBOOLE_0:def 3;
A13: ( dom Gn ) c= ( dom Gn1 ) by A11,XBOOLE_1:7;
then A14: se in ( dom Gn1 ) by A10;
now
per cases  by A11,A7,XBOOLE_0:def 3;
suppose v in ( dom Gn );

then consider P being (Path of G) such that A15: P is_augmenting_wrt EL and A16: P is_Walk_from source,v and A17: ( P .vertices() ) c= ( dom Gn ) by A2;
take P;
thus ((P is_augmenting_wrt EL & P is_Walk_from source,v) & ( P .vertices() ) c= ( dom Gn1 )) by A13,A15,A16,A17,XBOOLE_1:1;
end;
suppose v in { te };

then A18: v = te by TARSKI:def 1;
now
per cases ;
suppose A19: se = source;

set P = ( G .walkOf (se,e,te) );
take P;
A20: e Joins se,te,G by A8,GLIB_000:def 13;
now
let n being  odd Nat;
assume n < ( len P );
then n < ( 2 + 1 ) by A20,GLIB_001:14;
then n <= ( 2 * 1 ) by NAT_1:13;
then n < ( 1 + 1 ) by XXREAL_0:1;
then A21: n <= 1 by NAT_1:13;
1 <= n by ABIAN:12;
then A22: n = 1 by A21,XXREAL_0:1;
A23: P = <* se,e,te *> by A20,GLIB_001:def 5;
then A24: ( P . n ) = se by A22,FINSEQ_1:45;
A25: ( P . ( n + 2 ) ) = te by A22,A23,FINSEQ_1:45;
A26: ( P . ( n + 1 ) ) = e by A22,A23,FINSEQ_1:45;
hence (( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G implies ( EL . ( P . ( n + 1 ) ) ) < ( ( the_Weight_of G ) . ( P . ( n + 1 ) ) )) by A5,CKB14:def 1;
assume (not ( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G);
hence ( 0 ) < ( EL . ( P . ( n + 1 ) ) ) by A8,A24,A26,A25,GLIB_000:def 14;
end;
hence P is_augmenting_wrt EL by CKB16:def 1;
thus P is_Walk_from source,v by A18,A19,A20,GLIB_001:15;
now
let x being set;
assume x in ( P .vertices() );
then x in { se,te } by A20,GLIB_001:91;
hence x in ( dom Gn1 ) by A12,A14,TARSKI:def 2;
end;
hence ( P .vertices() ) c= ( dom Gn1 ) by TARSKI:def 3;
end;
suppose A27: se <> source;

A28: e Joins se,v,G by A8,A18,GLIB_000:def 13;
consider P being (Path of G) such that A29: P is_augmenting_wrt EL and A30: P is_Walk_from source,se and A31: ( P .vertices() ) c= ( dom Gn ) by A2,A10;
set P2 = ( P .addEdge e );
A32: (not v in ( P .vertices() )) by A5,A18,A31,CKB14:def 1;
A33: se = ( P .last() ) by A30,GLIB_001:def 23;
then ( P .first() ) <> ( P .last() ) by A27,A30,GLIB_001:def 23;
then P is  open by GLIB_001:def 24;
then reconsider P2 as (Path of G) by A28,A33,A32,GLIB_001:151;
take P2;
thus P2 is_augmenting_wrt EL by A6,A9,A18,A29,A33,A32,CKB19:1;
thus P2 is_Walk_from source,v by A30,A28,GLIB_001:66;
now
let x being set;
assume x in ( P2 .vertices() );
then A34: x in ( ( P .vertices() ) \/ { te } ) by A18,A28,A33,GLIB_001:95;
now
per cases  by A34,XBOOLE_0:def 3;
suppose x in ( P .vertices() );

then x in ( dom Gn ) by A31;
hence x in ( dom Gn1 ) by A13;
end;
suppose x in { te };

hence x in ( dom Gn1 ) by A11,XBOOLE_0:def 3;
end;
end;
hence x in ( dom Gn1 );
end;
hence ( P2 .vertices() ) c= ( dom Gn1 ) by TARSKI:def 3;
end;
end;
hence (ex P being (Path of G) st ((P is_augmenting_wrt EL & P is_Walk_from source,v) & ( P .vertices() ) c= ( dom Gn1 )));
end;
end;
hence (ex P being (Path of G) st ((P is_augmenting_wrt EL & P is_Walk_from source,v) & ( P .vertices() ) c= ( dom Gn1 )));
end;
suppose A35: e is_backward_edge_wrt Gn;

then A36: ( 0 ) < ( EL . e ) by CKB15:def 1;
let v being set;
assume A37: v in ( dom Gn1 );
A38: e in ( the_Edges_of G ) by A35,CKB15:def 1;
then A39: e DJoins se,te,G by GLIB_000:def 14;
A40: (not se in ( dom Gn )) by A35,CKB15:def 1;
then Gn1 = ( Gn +* ( se .--> e ) ) by A3,A4,CKB21:def 1;
then A41: ( dom Gn1 ) = ( ( dom Gn ) \/ { se } ) by CKB1:1;
se in { se } by TARSKI:def 1;
then A42: se in ( dom Gn1 ) by A41,XBOOLE_0:def 3;
A43: te in ( dom Gn ) by A35,CKB15:def 1;
A44: ( dom Gn ) c= ( dom Gn1 ) by A41,XBOOLE_1:7;
then A45: te in ( dom Gn1 ) by A43;
now
per cases  by A41,A37,XBOOLE_0:def 3;
suppose v in ( dom Gn );

then consider P being (Path of G) such that A46: P is_augmenting_wrt EL and A47: P is_Walk_from source,v and A48: ( P .vertices() ) c= ( dom Gn ) by A2;
take P;
thus ((P is_augmenting_wrt EL & P is_Walk_from source,v) & ( P .vertices() ) c= ( dom Gn1 )) by A44,A46,A47,A48,XBOOLE_1:1;
end;
suppose v in { se };

then A49: v = se by TARSKI:def 1;
now
per cases ;
suppose A50: te = source;

set P = ( G .walkOf (te,e,se) );
take P;
A51: e Joins te,se,G by A38,GLIB_000:def 13;
now
let n being  odd Nat;
assume n < ( len P );
then n < ( 2 + 1 ) by A51,GLIB_001:14;
then n <= ( 2 * 1 ) by NAT_1:13;
then n < ( 1 + 1 ) by XXREAL_0:1;
then A52: n <= 1 by NAT_1:13;
1 <= n by ABIAN:12;
then A53: n = 1 by A52,XXREAL_0:1;
A54: P = <* te,e,se *> by A51,GLIB_001:def 5;
then A55: ( P . ( n + 1 ) ) = e by A53,FINSEQ_1:45;
( P . n ) = te by A53,A54,FINSEQ_1:45;
hence (( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G implies ( EL . ( P . ( n + 1 ) ) ) < ( ( the_Weight_of G ) . ( P . ( n + 1 ) ) )) by A43,A40,A55,GLIB_000:def 14;
assume (not ( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G);
thus ( 0 ) < ( EL . ( P . ( n + 1 ) ) ) by A35,A55,CKB15:def 1;
end;
hence P is_augmenting_wrt EL by CKB16:def 1;
thus P is_Walk_from source,v by A49,A50,A51,GLIB_001:15;
now
let x being set;
assume x in ( P .vertices() );
then x in { se,te } by A51,GLIB_001:91;
hence x in ( dom Gn1 ) by A42,A45,TARSKI:def 2;
end;
hence ( P .vertices() ) c= ( dom Gn1 ) by TARSKI:def 3;
end;
suppose A56: te <> source;

A57: e Joins te,v,G by A38,A49,GLIB_000:def 13;
consider P being (Path of G) such that A58: P is_augmenting_wrt EL and A59: P is_Walk_from source,te and A60: ( P .vertices() ) c= ( dom Gn ) by A2,A43;
set P2 = ( P .addEdge e );
A61: (not v in ( P .vertices() )) by A35,A49,A60,CKB15:def 1;
A62: te = ( P .last() ) by A59,GLIB_001:def 23;
then ( P .first() ) <> ( P .last() ) by A56,A59,GLIB_001:def 23;
then P is  open by GLIB_001:def 24;
then reconsider P2 as (Path of G) by A57,A62,A61,GLIB_001:151;
take P2;
thus P2 is_augmenting_wrt EL by A36,A39,A49,A58,A62,A61,CKB19:1;
thus P2 is_Walk_from source,v by A59,A57,GLIB_001:66;
now
let x being set;
assume x in ( P2 .vertices() );
then A63: x in ( ( P .vertices() ) \/ { se } ) by A49,A57,A62,GLIB_001:95;
now
per cases  by A63,XBOOLE_0:def 3;
suppose x in ( P .vertices() );

then x in ( dom Gn ) by A60;
hence x in ( dom Gn1 ) by A44;
end;
suppose x in { se };

hence x in ( dom Gn1 ) by A41,XBOOLE_0:def 3;
end;
end;
hence x in ( dom Gn1 );
end;
hence ( P2 .vertices() ) c= ( dom Gn1 ) by TARSKI:def 3;
end;
end;
hence (ex P being (Path of G) st ((P is_augmenting_wrt EL & P is_Walk_from source,v) & ( P .vertices() ) c= ( dom Gn1 )));
end;
end;
hence (ex P being (Path of G) st ((P is_augmenting_wrt EL & P is_Walk_from source,v) & ( P .vertices() ) c= ( dom Gn1 )));
end;
end;
hence P[ ( n + 1 ) ];
end;
end;
hence P[ ( n + 1 ) ];
end;
now
let v being set;
assume A64: v in ( dom G0 );
then reconsider v9 = v as (Vertex of G);
set P = ( G .walkOf v9 );
take P;
thus P is_augmenting_wrt EL by CKB17:1;
v in { source } by A64,CKB25:1;
then v = source by TARSKI:def 1;
hence P is_Walk_from source,v by GLIB_001:13;
( P .vertices() ) = { v9 } by GLIB_001:90;
hence ( P .vertices() ) c= ( dom G0 ) by A64,ZFMISC_1:31;
end;
then A65: P[ ( 0 ) ];
(for n being Nat holds P[ n ]) from NAT_1:sch 2(A65,A1);
hence thesis;
end;
