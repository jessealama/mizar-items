environ
vocabularies NUMBERS,FUNCT_1,RELAT_1,FUNCT_4,FUNCOP_1,XBOOLE_0,TARSKI,GLIB_003,VALUED_0,SUBSET_1,REAL_1,GRAPH_5,FINSET_1,ZFMISC_1,TREES_1,GLIB_000,PBOOLE,CARD_1,XXREAL_0,CARD_3,XREAL_0,ORDINAL1,ARYTM_1,PARTFUN1,ARYTM_3,GLIB_001,ABIAN,NAT_1,FINSEQ_1,GRAPH_1,RCOMP_1,INT_1,PRE_POLY,UPROOTS,SGRAPH1,GLIB_005;
notations TARSKI,XBOOLE_0,CARD_1,NUMBERS,SUBSET_1,XCMPLX_0,XXREAL_0,XREAL_0,DOMAIN_1,REAL_1,RELAT_1,VALUED_0,PARTFUN1,FUNCT_1,PBOOLE,FINSEQ_1,FUNCT_2,GRAPH_5,ORDINAL1,UPROOTS,RELSET_1,FINSET_1,INT_1,NAT_1,FUNCOP_1,FUNCT_4,GLIB_000,GLIB_001,ABIAN,GLIB_002,GLIB_003,PRE_POLY,CKB5,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB20,CKB21,CKB22,CKB23,CKB24,CKB27,CKB30,CKB34,CKB35,CKB36,CKB37,CKB38,CKB42,CKB43;
definitions TARSKI,GLIB_000,GLIB_003,FUNCOP_1,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB20,CKB21,CKB22,CKB24,CKB27,CKB30,CKB34,CKB35,CKB36,CKB37,CKB38,CKB42,CKB43;
theorems CARD_1,CARD_2,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FUNCT_1,FUNCT_2,FUNCT_4,GLIB_000,GLIB_001,GLIB_003,GLIB_004,GRAPH_5,ABIAN,INT_1,NAT_1,PBOOLE,PEPIN,TARSKI,UPROOTS,XBOOLE_0,XBOOLE_1,ZFMISC_1,XREAL_1,XXREAL_0,ORDINAL1,NAT_D,VALUED_0,RELSET_1,PARTFUN1,RELAT_1,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47;
schemes NAT_1,SUBSET_1,FINSEQ_1,CLASSES1,RECDEF_1,GRAPH_5;
registrations XBOOLE_0,RELAT_1,PARTFUN1,INT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,MEMBERED,FINSEQ_1,GLIB_000,ABIAN,GLIB_001,GLIB_002,GLIB_003,VALUED_0,FUNCT_2,CARD_1,PRE_CIRC,PRE_POLY,RELSET_1,CKB6,CKB7,CKB8,CKB39,CKB40,CKB41;
constructors DOMAIN_1,FUNCT_4,NAT_D,GRAPH_2,GRAPH_5,UPROOTS,GLIB_004,SEQ_1,XXREAL_2,RELSET_1,PBOOLE,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB20,CKB21,CKB22,CKB23,CKB24,CKB27,CKB30,CKB34,CKB35,CKB36,CKB37,CKB38,CKB42,CKB43;
requirements ARITHM,BOOLE,NUMERALS,REAL,SUBSET;
begin
theorem
Th15: (for G being  finite  natural-weighted WGraph holds (for EL being (FF:ELabeling of G) holds (for source,sink being set holds (for P being (Path of G) holds (((source <> sink & P is_Walk_from source,sink) & P is_augmenting_wrt EL) implies ( ( EL .flow (source,sink) ) + ( P .tolerance EL ) ) = ( ( FF:PushFlow (EL,P) ) .flow (source,sink) ))))))
proof
let G being  finite  natural-weighted WGraph;
let EL being (FF:ELabeling of G);
let source being set,sink being set;
let P being (Path of G);
assume that
A1: source <> sink
and
A2: P is_Walk_from source,sink
and
A3: P is_augmenting_wrt EL;
A4: ( P .last() ) = sink by A2,GLIB_001:def 23;
( P .first() ) = source by A2,GLIB_001:def 23;
then P is non trivial by A1,A4,GLIB_001:127;
then 3 <= ( len P ) by GLIB_001:125;
then reconsider lenP2g = ( ( len P ) - ( 2 * 1 ) ) as  odd (Element of ( NAT )) by INT_1:5,XXREAL_0:2;
set e1 = ( P . ( lenP2g + 1 ) );
set EI1 = ( EL | ( G .edgesInto { sink } ) );
set EO1 = ( EL | ( G .edgesOutOf { sink } ) );
set EL2 = ( FF:PushFlow (EL,P) );
set T = ( P .tolerance EL );
A5: ( P . ( len P ) ) = sink by A2,GLIB_001:17;
A6: lenP2g < ( ( len P ) - ( 0 ) ) by XREAL_1:15;
then A7: e1 Joins ( P . lenP2g ),( P . ( lenP2g + 2 ) ),G by GLIB_001:def 3;
then A8: e1 in ( the_Edges_of G ) by GLIB_000:def 13;
now
per cases ;
suppose A9: e1 DJoins ( P . lenP2g ),( P . ( lenP2g + 2 ) ),G;

then ( ( the_Target_of G ) . e1 ) = ( P . ( lenP2g + 2 ) ) by GLIB_000:def 14
.= sink by A2,GLIB_001:17;
then ( ( the_Target_of G ) . e1 ) in { sink } by TARSKI:def 1;
then A10: e1 in ( G .edgesInto { sink } ) by A8,GLIB_000:def 26;
set EI2 = ( EI1 +* ( e1 .--> ( ( EI1 . e1 ) + T ) ) );
A11: ( dom ( EL2 | ( G .edgesInto { sink } ) ) ) = ( G .edgesInto { sink } ) by PARTFUN1:def 2;
A12: ( dom EI2 ) = ( ( dom EI1 ) \/ ( dom ( e1 .--> ( ( EI1 . e1 ) + T ) ) ) ) by FUNCT_4:def 1
.= ( ( dom EI1 ) \/ { e1 } ) by FUNCOP_1:13
.= ( ( G .edgesInto { sink } ) \/ { e1 } ) by PARTFUN1:def 2
.= ( G .edgesInto { sink } ) by A10,ZFMISC_1:40;
then reconsider EI2 as (Rbag of ( G .edgesInto { sink } )) by PARTFUN1:def 2,RELAT_1:def 18;
A13: ( EL2 . e1 ) = ( ( EL . e1 ) + T ) by A3,A6,A9,CKB36:def 1;
now
let e being set;
assume A14: e in ( dom ( EL2 | ( G .edgesInto { sink } ) ) );
then A15: e in ( G .edgesInto { sink } ) by PARTFUN1:def 2;
A16: ( ( EL2 | ( G .edgesInto { sink } ) ) . e ) = ( EL2 . e ) by A11,A14,FUNCT_1:49;
( ( the_Target_of G ) . e ) in { sink } by A15,GLIB_000:def 26;
then A17: ( ( the_Target_of G ) . e ) = sink by TARSKI:def 1;
now
per cases ;
suppose A18: e = e1;

then e in { e1 } by TARSKI:def 1;
then e in ( dom ( e1 .--> ( ( EI1 . e1 ) + T ) ) ) by FUNCOP_1:13;
then ( EI2 . e ) = ( ( e1 .--> ( ( EI1 . e1 ) + T ) ) . e1 ) by A18,FUNCT_4:13
.= ( ( EI1 . e1 ) + T ) by FUNCOP_1:72
.= ( EL2 . e1 ) by A13,A15,A18,FUNCT_1:49;
hence ( ( EL2 | ( G .edgesInto { sink } ) ) . e ) = ( EI2 . e ) by A11,A14,A18,FUNCT_1:49;
end;
suppose A19: e <> e1;

A20:now
assume e in ( P .edges() );
then consider v1 being (Vertex of G),v2 being (Vertex of G),m being  odd (Element of ( NAT )) such that A21: ( m + 2 ) <= ( len P ) and A22: v1 = ( P . m ) and A23: e = ( P . ( m + 1 ) ) and A24: v2 = ( P . ( m + 2 ) ) and A25: e Joins v1,v2,G by GLIB_001:103;
now
per cases  by A17,A25,GLIB_000:def 13;
suppose A26: v1 = sink;

A27: ( ( m + 2 ) - 2 ) < ( ( len P ) - ( 0 ) ) by A21,XREAL_1:15;
( P . m ) = ( P . ( len P ) ) by A2,A22,A26,GLIB_001:17;
then m = 1 by A27,GLIB_001:def 28;
hence contradiction by A1,A2,A22,A26,GLIB_001:17;
end;
suppose v2 = sink;

then A28: ( P . ( m + 2 ) ) = ( P . ( len P ) ) by A2,A24,GLIB_001:17;
now
assume ( m + 2 ) < ( len P );
then ( m + 2 ) = 1 by A28,GLIB_001:def 28;
then m = ( 1 - 2 );
hence contradiction by ABIAN:12;
end;
then ( m + 2 ) = ( len P ) by A21,XXREAL_0:1;
hence contradiction by A19,A23;
end;
end;
hence contradiction;
end;
(not e in { e1 }) by A19,TARSKI:def 1;
then (not e in ( dom ( e1 .--> ( ( EI1 . e1 ) + T ) ) )) by FUNCOP_1:13;
then ( EI2 . e ) = ( EI1 . e ) by FUNCT_4:11
.= ( EL . e ) by A15,FUNCT_1:49;
hence ( ( EL2 | ( G .edgesInto { sink } ) ) . e ) = ( EI2 . e ) by A3,A15,A16,A20,CKB36:def 1;
end;
end;
hence ( ( EL2 | ( G .edgesInto { sink } ) ) . e ) = ( EI2 . e );
end;
then A29: ( Sum ( EL2 | ( G .edgesInto { sink } ) ) ) = ( ( ( Sum EI1 ) + ( T + ( EI1 . e1 ) ) ) - ( EI1 . e1 ) ) by A12,A11,FUNCT_1:2,GLIB_004:9
.= ( ( Sum EI1 ) + T );
A30: ( dom ( EL2 | ( G .edgesOutOf { sink } ) ) ) = ( G .edgesOutOf { sink } ) by PARTFUN1:def 2;
A31:now
let e being set;
assume A32: e in ( dom ( EL2 | ( G .edgesOutOf { sink } ) ) );
then A33: e in ( G .edgesOutOf { sink } ) by PARTFUN1:def 2;
then ( ( the_Source_of G ) . e ) in { sink } by GLIB_000:def 27;
then A34: ( ( the_Source_of G ) . e ) = sink by TARSKI:def 1;
now
assume e in ( P .edges() );
then consider v1 being (Vertex of G),v2 being (Vertex of G),m being  odd (Element of ( NAT )) such that A35: ( m + 2 ) <= ( len P ) and A36: v1 = ( P . m ) and A37: e = ( P . ( m + 1 ) ) and A38: v2 = ( P . ( m + 2 ) ) and A39: e Joins v1,v2,G by GLIB_001:103;
now
per cases  by A34,A39,GLIB_000:def 13;
suppose A40: v1 = sink;

A41: ( ( m + 2 ) - 2 ) < ( ( len P ) - ( 0 ) ) by A35,XREAL_1:15;
( P . m ) = ( P . ( len P ) ) by A2,A36,A40,GLIB_001:17;
then m = 1 by A41,GLIB_001:def 28;
hence contradiction by A1,A2,A36,A40,GLIB_001:17;
end;
suppose v2 = sink;

then A42: ( P . ( m + 2 ) ) = ( P . ( len P ) ) by A2,A38,GLIB_001:17;
now
assume ( m + 2 ) < ( len P );
then ( m + 2 ) = 1 by A42,GLIB_001:def 28;
then 1 <= ( 1 - 2 ) by ABIAN:12;
hence contradiction;
end;
then ( m + 2 ) = ( len P ) by A35,XXREAL_0:1;
then A43: ( P . lenP2g ) = sink by A9,A34,A37,GLIB_000:def 14;
then lenP2g = 1 by A6,A5,GLIB_001:def 28;
hence contradiction by A1,A2,A43,GLIB_001:17;
end;
end;
hence contradiction;
end;
then ( EL2 . e ) = ( EL . e ) by A3,A33,CKB36:def 1
.= ( EO1 . e ) by A33,FUNCT_1:49;
hence ( ( EL2 | ( G .edgesOutOf { sink } ) ) . e ) = ( EO1 . e ) by A30,A32,FUNCT_1:49;
end;
( dom EO1 ) = ( G .edgesOutOf { sink } ) by PARTFUN1:def 2;
hence ( EL2 .flow (source,sink) ) = ( ( ( Sum EI1 ) + T ) - ( Sum EO1 ) ) by A29,A30,A31,FUNCT_1:2
.= ( ( ( Sum EI1 ) - ( Sum EO1 ) ) + T )
.= ( ( EL .flow (source,sink) ) + T );
end;
suppose A44: (not e1 DJoins ( P . lenP2g ),( P . ( lenP2g + 2 ) ),G);

then A45: e1 DJoins ( P . ( lenP2g + 2 ) ),( P . lenP2g ),G by A7,GLIB_000:16;
then ( ( the_Source_of G ) . e1 ) = ( P . ( lenP2g + 2 ) ) by GLIB_000:def 14
.= sink by A2,GLIB_001:17;
then ( ( the_Source_of G ) . e1 ) in { sink } by TARSKI:def 1;
then A46: e1 in ( G .edgesOutOf { sink } ) by A8,GLIB_000:def 27;
set EO2 = ( EO1 +* ( e1 .--> ( ( EO1 . e1 ) - T ) ) );
A47: ( dom ( EL2 | ( G .edgesOutOf { sink } ) ) ) = ( G .edgesOutOf { sink } ) by PARTFUN1:def 2;
A48: ( dom EO2 ) = ( ( dom EO1 ) \/ ( dom ( e1 .--> ( ( EO1 . e1 ) - T ) ) ) ) by FUNCT_4:def 1
.= ( ( dom EO1 ) \/ { e1 } ) by FUNCOP_1:13
.= ( ( G .edgesOutOf { sink } ) \/ { e1 } ) by PARTFUN1:def 2
.= ( G .edgesOutOf { sink } ) by A46,ZFMISC_1:40;
then reconsider EO2 as (Rbag of ( G .edgesOutOf { sink } )) by PARTFUN1:def 2,RELAT_1:def 18;
A49: ( EL2 . e1 ) = ( ( EL . e1 ) - T ) by A3,A6,A44,CKB36:def 1;
now
let e being set;
assume A50: e in ( dom ( EL2 | ( G .edgesOutOf { sink } ) ) );
then A51: e in ( G .edgesOutOf { sink } ) by PARTFUN1:def 2;
A52: ( ( EL2 | ( G .edgesOutOf { sink } ) ) . e ) = ( EL2 . e ) by A47,A50,FUNCT_1:49;
( ( the_Source_of G ) . e ) in { sink } by A51,GLIB_000:def 27;
then A53: ( ( the_Source_of G ) . e ) = sink by TARSKI:def 1;
now
per cases ;
suppose A54: e = e1;

then e in { e1 } by TARSKI:def 1;
then e in ( dom ( e1 .--> ( ( EO1 . e1 ) - T ) ) ) by FUNCOP_1:13;
then ( EO2 . e ) = ( ( e1 .--> ( ( EO1 . e1 ) - T ) ) . e1 ) by A54,FUNCT_4:13
.= ( ( EO1 . e1 ) - T ) by FUNCOP_1:72
.= ( EL2 . e ) by A49,A51,A54,FUNCT_1:49;
hence ( ( EL2 | ( G .edgesOutOf { sink } ) ) . e ) = ( EO2 . e ) by A47,A50,FUNCT_1:49;
end;
suppose A55: e <> e1;

A56:now
assume e in ( P .edges() );
then consider v1 being (Vertex of G),v2 being (Vertex of G),m being  odd (Element of ( NAT )) such that A57: ( m + 2 ) <= ( len P ) and A58: v1 = ( P . m ) and A59: e = ( P . ( m + 1 ) ) and A60: v2 = ( P . ( m + 2 ) ) and A61: e Joins v1,v2,G by GLIB_001:103;
now
per cases  by A53,A61,GLIB_000:def 13;
suppose A62: v1 = sink;

A63: ( ( m + 2 ) - 2 ) < ( ( len P ) - ( 0 ) ) by A57,XREAL_1:15;
( P . m ) = ( P . ( len P ) ) by A2,A58,A62,GLIB_001:17;
then m = 1 by A63,GLIB_001:def 28;
hence contradiction by A1,A2,A58,A62,GLIB_001:17;
end;
suppose v2 = sink;

then A64: ( P . ( m + 2 ) ) = ( P . ( len P ) ) by A2,A60,GLIB_001:17;
now
assume ( m + 2 ) < ( len P );
then ( m + 2 ) = 1 by A64,GLIB_001:def 28;
then 1 <= ( 1 - 2 ) by ABIAN:12;
hence contradiction;
end;
then ( m + 2 ) = ( len P ) by A57,XXREAL_0:1;
hence contradiction by A55,A59;
end;
end;
hence contradiction;
end;
(not e in { e1 }) by A55,TARSKI:def 1;
then (not e in ( dom ( e1 .--> ( ( EO1 . e1 ) - T ) ) )) by FUNCOP_1:13;
then ( EO2 . e ) = ( EO1 . e ) by FUNCT_4:11
.= ( EL . e ) by A51,FUNCT_1:49;
hence ( ( EL2 | ( G .edgesOutOf { sink } ) ) . e ) = ( EO2 . e ) by A3,A51,A52,A56,CKB36:def 1;
end;
end;
hence ( ( EL2 | ( G .edgesOutOf { sink } ) ) . e ) = ( EO2 . e );
end;
then A65: ( Sum ( EL2 | ( G .edgesOutOf { sink } ) ) ) = ( ( ( Sum EO1 ) + ( ( EO1 . e1 ) - T ) ) - ( EO1 . e1 ) ) by A48,A47,FUNCT_1:2,GLIB_004:9
.= ( ( Sum EO1 ) - T );
A66: ( dom ( EL2 | ( G .edgesInto { sink } ) ) ) = ( G .edgesInto { sink } ) by PARTFUN1:def 2;
A67:now
let e being set;
assume A68: e in ( dom ( EL2 | ( G .edgesInto { sink } ) ) );
then A69: e in ( G .edgesInto { sink } ) by PARTFUN1:def 2;
then ( ( the_Target_of G ) . e ) in { sink } by GLIB_000:def 26;
then A70: ( ( the_Target_of G ) . e ) = sink by TARSKI:def 1;
now
assume e in ( P .edges() );
then consider v1 being (Vertex of G),v2 being (Vertex of G),m being  odd (Element of ( NAT )) such that A71: ( m + 2 ) <= ( len P ) and A72: v1 = ( P . m ) and A73: e = ( P . ( m + 1 ) ) and A74: v2 = ( P . ( m + 2 ) ) and A75: e Joins v1,v2,G by GLIB_001:103;
now
per cases  by A70,A75,GLIB_000:def 13;
suppose A76: v1 = sink;

A77: ( ( m + 2 ) - 2 ) < ( ( len P ) - ( 0 ) ) by A71,XREAL_1:15;
( P . m ) = ( P . ( len P ) ) by A2,A72,A76,GLIB_001:17;
then m = 1 by A77,GLIB_001:def 28;
hence contradiction by A1,A2,A72,A76,GLIB_001:17;
end;
suppose v2 = sink;

then A78: ( P . ( m + 2 ) ) = ( P . ( len P ) ) by A2,A74,GLIB_001:17;
now
assume ( m + 2 ) < ( len P );
then ( m + 2 ) = 1 by A78,GLIB_001:def 28;
then 1 <= ( 1 - 2 ) by ABIAN:12;
hence contradiction;
end;
then ( m + 2 ) = ( len P ) by A71,XXREAL_0:1;
then A79: ( P . lenP2g ) = sink by A45,A70,A73,GLIB_000:def 14;
then lenP2g = 1 by A6,A5,GLIB_001:def 28;
hence contradiction by A1,A2,A79,GLIB_001:17;
end;
end;
hence contradiction;
end;
then ( EL2 . e ) = ( EL . e ) by A3,A69,CKB36:def 1
.= ( EI1 . e ) by A69,FUNCT_1:49;
hence ( ( EL2 | ( G .edgesInto { sink } ) ) . e ) = ( EI1 . e ) by A66,A68,FUNCT_1:49;
end;
( dom EI1 ) = ( G .edgesInto { sink } ) by PARTFUN1:def 2;
hence ( EL2 .flow (source,sink) ) = ( ( Sum EI1 ) - ( ( Sum EO1 ) - T ) ) by A65,A66,A67,FUNCT_1:2
.= ( ( ( Sum EI1 ) - ( Sum EO1 ) ) + T )
.= ( ( EL .flow (source,sink) ) + T );
end;
end;
hence thesis;
end;
