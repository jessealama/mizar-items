environ
vocabularies NUMBERS,FUNCT_1,RELAT_1,FUNCT_4,FUNCOP_1,XBOOLE_0,TARSKI,GLIB_003,VALUED_0,SUBSET_1,REAL_1,GRAPH_5,FINSET_1,ZFMISC_1,TREES_1,GLIB_000,PBOOLE,CARD_1,XXREAL_0,CARD_3,XREAL_0,ORDINAL1,ARYTM_1,PARTFUN1,ARYTM_3,GLIB_001,ABIAN,NAT_1,FINSEQ_1,GRAPH_1,RCOMP_1,INT_1,PRE_POLY,UPROOTS,SGRAPH1,GLIB_005;
notations TARSKI,XBOOLE_0,CARD_1,NUMBERS,SUBSET_1,XCMPLX_0,XXREAL_0,XREAL_0,DOMAIN_1,REAL_1,RELAT_1,VALUED_0,PARTFUN1,FUNCT_1,PBOOLE,FINSEQ_1,FUNCT_2,GRAPH_5,ORDINAL1,UPROOTS,RELSET_1,FINSET_1,INT_1,NAT_1,FUNCOP_1,FUNCT_4,GLIB_000,GLIB_001,ABIAN,GLIB_002,GLIB_003,PRE_POLY,CKB5,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB20,CKB21,CKB22,CKB23,CKB24,CKB27,CKB30,CKB34,CKB35;
definitions TARSKI,GLIB_000,GLIB_003,FUNCOP_1,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB20,CKB21,CKB22,CKB24,CKB27,CKB30,CKB34,CKB35;
theorems CARD_1,CARD_2,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FUNCT_1,FUNCT_2,FUNCT_4,GLIB_000,GLIB_001,GLIB_003,GLIB_004,GRAPH_5,ABIAN,INT_1,NAT_1,PBOOLE,PEPIN,TARSKI,UPROOTS,XBOOLE_0,XBOOLE_1,ZFMISC_1,XREAL_1,XXREAL_0,ORDINAL1,NAT_D,VALUED_0,RELSET_1,PARTFUN1,RELAT_1,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35;
schemes NAT_1,SUBSET_1,FINSEQ_1,CLASSES1,RECDEF_1,GRAPH_5;
registrations XBOOLE_0,RELAT_1,PARTFUN1,INT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,MEMBERED,FINSEQ_1,GLIB_000,ABIAN,GLIB_001,GLIB_002,GLIB_003,VALUED_0,FUNCT_2,CARD_1,PRE_CIRC,PRE_POLY,RELSET_1,CKB6,CKB7,CKB8;
constructors DOMAIN_1,FUNCT_4,NAT_D,GRAPH_2,GRAPH_5,UPROOTS,GLIB_004,SEQ_1,XXREAL_2,RELSET_1,PBOOLE,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB20,CKB21,CKB22,CKB23,CKB24,CKB27,CKB30,CKB34,CKB35;
requirements ARITHM,BOOLE,NUMERALS,REAL,SUBSET;
begin
definition
let G being  natural-weighted WGraph;
let EL being (FF:ELabeling of G);
let P being (Path of G);
assume A1: P is_augmenting_wrt EL;
func FF:PushFlow (EL,P) -> (FF:ELabeling of G) means 
:Def17: ((for e being set holds ((e in ( the_Edges_of G ) & (not e in ( P .edges() ))) implies ( it . e ) = ( EL . e ))) & (for n being  odd Nat holds (n < ( len P ) implies ((( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G implies ( it . ( P . ( n + 1 ) ) ) = ( ( EL . ( P . ( n + 1 ) ) ) + ( P .tolerance EL ) )) & ((not ( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G) implies ( it . ( P . ( n + 1 ) ) ) = ( ( EL . ( P . ( n + 1 ) ) ) - ( P .tolerance EL ) ))))));
existence
proof
defpred P[ set,set ]
 means
((($1 in ( the_Edges_of G ) & (not $1 in ( P .edges() ))) implies $2 = ( EL . $1 )) & (for n being  odd (Element of ( NAT )) holds ((n < ( len P ) & $1 = ( P . ( n + 1 ) )) implies ((( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G implies $2 = ( ( EL . ( P . ( n + 1 ) ) ) + ( P .tolerance EL ) )) & ((not ( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G) implies $2 = ( ( EL . ( P . ( n + 1 ) ) ) - ( P .tolerance EL ) ))))));
now
let x being set;
assume x in ( the_Edges_of G );
now
per cases ;
suppose A2: (not x in ( P .edges() ));

set y = ( EL . x );
(for n being  odd (Element of ( NAT )) holds ((n < ( len P ) & x = ( P . ( n + 1 ) )) implies ((( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G implies y = ( ( EL . ( P . ( n + 1 ) ) ) + ( P .tolerance EL ) )) & ((not ( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G) implies y = ( ( EL . ( P . ( n + 1 ) ) ) - ( P .tolerance EL ) ))))) by A2,GLIB_001:100;
hence (ex y being set st P[ x,y ]);
end;
suppose A3: x in ( P .edges() );

then consider n being  odd (Element of ( NAT )) such that A4: n < ( len P ) and A5: ( P . ( n + 1 ) ) = x by GLIB_001:100;
A6: 1 <= ( n + 1 ) by NAT_1:11;
A7: ( n + 1 ) <= ( len P ) by A4,NAT_1:13;
now
per cases ;
suppose A8: ( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G;

set y = ( ( EL . ( P . ( n + 1 ) ) ) + ( P .tolerance EL ) );
now
thus ((x in ( the_Edges_of G ) & (not x in ( P .edges() ))) implies y = ( EL . x )) by A3;
let m being  odd (Element of ( NAT ));
assume that
A9: m < ( len P )
and
A10: ( P . ( m + 1 ) ) = x;
1 <= ( m + 1 ) by NAT_1:11;
then A11: ( n + 1 ) <= ( m + 1 ) by A5,A7,A10,GLIB_001:138;
thus (( P . ( m + 1 ) ) DJoins ( P . m ),( P . ( m + 2 ) ),G implies y = y);
assume A12: (not ( P . ( m + 1 ) ) DJoins ( P . m ),( P . ( m + 2 ) ),G);
( m + 1 ) <= ( len P ) by A9,NAT_1:13;
then ( m + 1 ) <= ( n + 1 ) by A5,A6,A10,GLIB_001:138;
then ( m + 1 ) = ( n + 1 ) by A11,XXREAL_0:1;
hence y = ( ( EL . ( P . ( m + 1 ) ) ) - ( P .tolerance EL ) ) by A8,A12;
end;
then P[ x,y ] by A5;
hence (ex y being set st P[ x,y ]);
end;
suppose A13: (not ( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G);

set y = ( ( EL . ( P . ( n + 1 ) ) ) - ( P .tolerance EL ) );
now
thus ((x in ( the_Edges_of G ) & (not x in ( P .edges() ))) implies y = ( EL . x )) by A3;
let m being  odd (Element of ( NAT ));
assume that
A14: m < ( len P )
and
A15: ( P . ( m + 1 ) ) = x;
1 <= ( m + 1 ) by NAT_1:11;
then A16: ( n + 1 ) <= ( m + 1 ) by A5,A7,A15,GLIB_001:138;
( m + 1 ) <= ( len P ) by A14,NAT_1:13;
then ( m + 1 ) <= ( n + 1 ) by A5,A6,A15,GLIB_001:138;
then ( m + 1 ) = ( n + 1 ) by A16,XXREAL_0:1;
hence (( P . ( m + 1 ) ) DJoins ( P . m ),( P . ( m + 2 ) ),G implies y = ( ( EL . ( P . ( n + 1 ) ) ) + ( P .tolerance EL ) )) by A13;
assume (not ( P . ( m + 1 ) ) DJoins ( P . m ),( P . ( m + 2 ) ),G);
thus y = ( ( EL . ( P . ( n + 1 ) ) ) - ( P .tolerance EL ) );
end;
then P[ x,y ] by A5;
hence (ex y being set st P[ x,y ]);
end;
end;
hence (ex y being set st P[ x,y ]);
end;
end;
hence (ex y being set st P[ x,y ]);
end;
then A17: (for x being set holds (x in ( the_Edges_of G ) implies (ex y being set st P[ x,y ])));
consider IT being Function such that A18: ( dom IT ) = ( the_Edges_of G ) and A19: (for e being set holds (e in ( the_Edges_of G ) implies P[ e,( IT . e ) ])) from CLASSES1:sch 1(A17);
( rng IT ) c= ( NAT )
proof
let y being set;
assume y in ( rng IT );
then consider e being set such that A20: e in ( dom IT ) and A21: ( IT . e ) = y by FUNCT_1:def 3;
now
per cases ;
suppose (not e in ( P .edges() ));

then y = ( EL . e ) by A18,A19,A20,A21;
hence thesis by ORDINAL1:def 12;
end;
suppose A22: e in ( P .edges() );

then consider n being  odd (Element of ( NAT )) such that A23: n < ( len P ) and A24: ( P . ( n + 1 ) ) = e by GLIB_001:100;
A25: P is non  trivial by A22,GLIB_001:136;
now
per cases ;
suppose ( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G;

then y = ( ( EL . ( P . ( n + 1 ) ) ) + ( P .tolerance EL ) ) by A18,A19,A20,A21,A23,A24;
hence thesis by ORDINAL1:def 12;
end;
suppose A26: (not ( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G);

set n1div2 = ( ( n + 1 ) div 2 );
A27: 1 <= ( n + 1 ) by NAT_1:11;
( n + 1 ) <= ( len P ) by A23,NAT_1:13;
then n1div2 in ( dom ( P .edgeSeq() ) ) by A27,GLIB_001:77;
then A28: n1div2 in ( dom ( P .flowSeq EL ) ) by A1,CKB34:def 1;
2 divides ( n + 1 ) by PEPIN:22;
then A29: ( 2 * n1div2 ) = ( n + 1 ) by NAT_D:3;
then A30: ( ( 2 * n1div2 ) + 1 ) = ( n + ( 1 + 1 ) );
( ( 2 * n1div2 ) - 1 ) = n by A29;
then ( ( P .flowSeq EL ) . n1div2 ) = ( EL . e ) by A1,A24,A26,A28,A30,CKB34:def 1;
then ( EL . e ) in ( rng ( P .flowSeq EL ) ) by A28,FUNCT_1:def 3;
then A31: ( P .tolerance EL ) <= ( EL . e ) by A1,A25,CKB35:def 1;
y = ( ( EL . e ) - ( P .tolerance EL ) ) by A18,A19,A20,A21,A23,A24,A26;
hence thesis by A31,INT_1:5;
end;
end;
hence thesis;
end;
end;
hence thesis;
end;
then reconsider IT as  natural-valued (ManySortedSet of ( the_Edges_of G )) by A18,PARTFUN1:def 2,RELAT_1:def 18,VALUED_0:def 6;
take IT;
thus (for e being set holds ((e in ( the_Edges_of G ) & (not e in ( P .edges() ))) implies ( IT . e ) = ( EL . e ))) by A19;
let n being  odd Nat;
reconsider n9 = n as  odd (Element of ( NAT )) by ORDINAL1:def 12;
A32: n9 = n;
assume A33: n < ( len P );
then ( P . ( n + 1 ) ) Joins ( P . n ),( P . ( n9 + 2 ) ),G by GLIB_001:def 3;
then A34: ( P . ( n + 1 ) ) in ( the_Edges_of G ) by GLIB_000:def 13;
hence (( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G implies ( IT . ( P . ( n + 1 ) ) ) = ( ( EL . ( P . ( n + 1 ) ) ) + ( P .tolerance EL ) )) by A19,A32,A33;
assume (not ( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G);
hence thesis by A19,A32,A33,A34;
end;
uniqueness
proof
let IT1 being (FF:ELabeling of G);
let IT2 being (FF:ELabeling of G);
assume that
A35: (for e being set holds ((e in ( the_Edges_of G ) & (not e in ( P .edges() ))) implies ( IT1 . e ) = ( EL . e )))
and
A36: (for n being  odd Nat holds (n < ( len P ) implies ((( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G implies ( IT1 . ( P . ( n + 1 ) ) ) = ( ( EL . ( P . ( n + 1 ) ) ) + ( P .tolerance EL ) )) & ((not ( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G) implies ( IT1 . ( P . ( n + 1 ) ) ) = ( ( EL . ( P . ( n + 1 ) ) ) - ( P .tolerance EL ) )))))
and
A37: (for e being set holds ((e in ( the_Edges_of G ) & (not e in ( P .edges() ))) implies ( IT2 . e ) = ( EL . e )))
and
A38: (for n being  odd Nat holds (n < ( len P ) implies ((( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G implies ( IT2 . ( P . ( n + 1 ) ) ) = ( ( EL . ( P . ( n + 1 ) ) ) + ( P .tolerance EL ) )) & ((not ( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G) implies ( IT2 . ( P . ( n + 1 ) ) ) = ( ( EL . ( P . ( n + 1 ) ) ) - ( P .tolerance EL ) )))));
now
let e being set;
assume A39: e in ( the_Edges_of G );
now
per cases ;
suppose A40: (not e in ( P .edges() ));

then ( IT1 . e ) = ( EL . e ) by A35,A39;
hence ( IT1 . e ) = ( IT2 . e ) by A37,A39,A40;
end;
suppose e in ( P .edges() );

then consider n being  odd (Element of ( NAT )) such that A41: n < ( len P ) and A42: ( P . ( n + 1 ) ) = e by GLIB_001:100;
now
per cases ;
suppose A43: ( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G;

then ( IT1 . e ) = ( ( EL . ( P . ( n + 1 ) ) ) + ( P .tolerance EL ) ) by A36,A41,A42;
hence ( IT1 . e ) = ( IT2 . e ) by A38,A41,A42,A43;
end;
suppose A44: (not ( P . ( n + 1 ) ) DJoins ( P . n ),( P . ( n + 2 ) ),G);

then ( IT1 . e ) = ( ( EL . ( P . ( n + 1 ) ) ) - ( P .tolerance EL ) ) by A36,A41,A42;
hence ( IT1 . e ) = ( IT2 . e ) by A38,A41,A42,A44;
end;
end;
hence ( IT1 . e ) = ( IT2 . e );
end;
end;
hence ( IT1 . e ) = ( IT2 . e );
end;
hence thesis by PBOOLE:3;
end;
end;
