environ
vocabularies NUMBERS,FUNCT_1,RELAT_1,FUNCT_4,FUNCOP_1,XBOOLE_0,TARSKI,GLIB_003,VALUED_0,SUBSET_1,REAL_1,GRAPH_5,FINSET_1,ZFMISC_1,TREES_1,GLIB_000,PBOOLE,CARD_1,XXREAL_0,CARD_3,XREAL_0,ORDINAL1,ARYTM_1,PARTFUN1,ARYTM_3,GLIB_001,ABIAN,NAT_1,FINSEQ_1,GRAPH_1,RCOMP_1,INT_1,PRE_POLY,UPROOTS,SGRAPH1,GLIB_005;
notations TARSKI,XBOOLE_0,CARD_1,NUMBERS,SUBSET_1,XCMPLX_0,XXREAL_0,XREAL_0,DOMAIN_1,REAL_1,RELAT_1,VALUED_0,PARTFUN1,FUNCT_1,PBOOLE,FINSEQ_1,FUNCT_2,GRAPH_5,ORDINAL1,UPROOTS,RELSET_1,FINSET_1,INT_1,NAT_1,FUNCOP_1,FUNCT_4,GLIB_000,GLIB_001,ABIAN,GLIB_002,GLIB_003,PRE_POLY,CKB5,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB20,CKB21,CKB22,CKB23,CKB24,CKB27;
definitions TARSKI,GLIB_000,GLIB_003,FUNCOP_1,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB20,CKB21,CKB22,CKB24,CKB27;
theorems CARD_1,CARD_2,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FUNCT_1,FUNCT_2,FUNCT_4,GLIB_000,GLIB_001,GLIB_003,GLIB_004,GRAPH_5,ABIAN,INT_1,NAT_1,PBOOLE,PEPIN,TARSKI,UPROOTS,XBOOLE_0,XBOOLE_1,ZFMISC_1,XREAL_1,XXREAL_0,ORDINAL1,NAT_D,VALUED_0,RELSET_1,PARTFUN1,RELAT_1,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29;
schemes NAT_1,SUBSET_1,FINSEQ_1,CLASSES1,RECDEF_1,GRAPH_5;
registrations XBOOLE_0,RELAT_1,PARTFUN1,INT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,MEMBERED,FINSEQ_1,GLIB_000,ABIAN,GLIB_001,GLIB_002,GLIB_003,VALUED_0,FUNCT_2,CARD_1,PRE_CIRC,PRE_POLY,RELSET_1,CKB6,CKB7,CKB8;
constructors DOMAIN_1,FUNCT_4,NAT_D,GRAPH_2,GRAPH_5,UPROOTS,GLIB_004,SEQ_1,XXREAL_2,RELSET_1,PBOOLE,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB20,CKB21,CKB22,CKB23,CKB24,CKB27;
requirements ARITHM,BOOLE,NUMERALS,REAL,SUBSET;
begin
definition
let G being  finite  real-weighted WGraph;
let EL being (FF:ELabeling of G);
let source being (Vertex of G);
let sink being (Vertex of G);
func AP:GetAugPath (EL,source,sink) ->  vertex-distinct (Path of G) means 
:Def14: ((it is_Walk_from source,sink & it is_augmenting_wrt EL) & (for n being  even Nat holds (n in ( dom it ) implies ( it . n ) = ( ( AP:FindAugPath (EL,source) ) . ( it . ( n + 1 ) ) )))) if sink in ( dom ( AP:FindAugPath (EL,source) ) ) otherwise it = ( G .walkOf source );
existence
proof
set CS = ( AP:CompSeq (EL,source) );
set FAP = ( AP:FindAugPath (EL,source) );
defpred P[ Nat ]
 means
(for v being set holds (v in ( dom ( CS . $1 ) ) implies (ex P being  vertex-distinct (Path of G) st (((P is_Walk_from source,v & P is_augmenting_wrt EL) & ( P .vertices() ) c= ( dom ( CS . $1 ) )) & (for n being  even Nat holds (n in ( dom P ) implies ( P . n ) = ( FAP . ( P . ( n + 1 ) ) )))))));
now
let n being Nat;
assume A1: P[ n ];
set Gn = ( CS . n );
set Gn1 = ( CS . ( n + 1 ) );
set Next = ( AP:NextBestEdges Gn );
set e = ( choose Next );
A2: Gn1 = ( AP:Step Gn ) by CKB24:def 1;
now
per cases ;
suppose Next = ( {} );

then Gn1 = Gn by A2,CKB21:def 1;
hence P[ ( n + 1 ) ] by A1;
end;
suppose A3: (Next <> ( {} ) & (not ( ( the_Source_of G ) . e ) in ( dom Gn )));

then A4: (e is_forward_edge_wrt Gn or e is_backward_edge_wrt Gn) by CKB20:def 1;
then A5: ( 0 ) < ( EL . e ) by A3,CKB14:def 1,CKB15:def 1;
A6: e in Next by A3;
A7: Gn1 = ( Gn +* ( ( ( the_Source_of G ) . e ) .--> e ) ) by A2,A3,CKB21:def 1;
then A8: ( dom Gn1 ) = ( ( dom Gn ) \/ { ( ( the_Source_of G ) . e ) } ) by CKB1:1;
A9: ( ( the_Target_of G ) . e ) in ( dom Gn ) by A3,A4,CKB14:def 1,CKB15:def 1;
now
let v being set;
assume A10: v in ( dom Gn1 );
now
per cases  by A8,A10,XBOOLE_0:def 3;
suppose v in ( dom Gn );

then consider P being  vertex-distinct (Path of G) such that A11: P is_Walk_from source,v and A12: P is_augmenting_wrt EL and A13: ( P .vertices() ) c= ( dom Gn ) and A14: (for n being  even Nat holds (n in ( dom P ) implies ( P . n ) = ( FAP . ( P . ( n + 1 ) ) ))) by A1;
take P;
( dom Gn ) c= ( dom Gn1 ) by CKB26:1,NAT_1:11;
hence (((P is_Walk_from source,v & P is_augmenting_wrt EL) & ( P .vertices() ) c= ( dom Gn1 )) & (for n being  even Nat holds (n in ( dom P ) implies ( P . n ) = ( FAP . ( P . ( n + 1 ) ) )))) by A11,A12,A13,A14,XBOOLE_1:1;
end;
suppose A15: v in { ( ( the_Source_of G ) . e ) };

then A16: v = ( ( the_Source_of G ) . e ) by TARSKI:def 1;
now
consider W being  vertex-distinct (Path of G) such that A17: W is_Walk_from source,( ( the_Target_of G ) . e ) and A18: W is_augmenting_wrt EL and A19: ( W .vertices() ) c= ( dom Gn ) and A20: (for n being  even Nat holds (n in ( dom W ) implies ( W . n ) = ( FAP . ( W . ( n + 1 ) ) ))) by A1,A9;
set W2 = ( W .addEdge e );
A21: ( W .last() ) = ( ( the_Target_of G ) . e ) by A17,GLIB_001:def 23;
then A22: e Joins ( W .last() ),( ( the_Source_of G ) . e ),G by A6,GLIB_000:def 13;
A23: (not ( ( the_Source_of G ) . e ) in ( W .vertices() )) by A3,A19;
then reconsider W2 as  vertex-distinct (Walk of G) by A22,GLIB_001:155;
take W2;
( W .first() ) = source by A17,GLIB_001:def 23;
hence W2 is_Walk_from source,v by A16,A22,GLIB_001:63;
e DJoins ( ( the_Source_of G ) . e ),( W .last() ),G by A6,A21,GLIB_000:def 14;
hence W2 is_augmenting_wrt EL by A5,A18,A23,CKB19:1;
A24: ( W2 .vertices() ) = ( ( W .vertices() ) \/ { v } ) by A16,A22,GLIB_001:95;
now
let x being set;
assume A25: x in ( W2 .vertices() );
now
per cases  by A24,A25,XBOOLE_0:def 3;
suppose A26: x in ( W .vertices() );

A27: ( dom Gn ) c= ( dom Gn1 ) by CKB26:1,NAT_1:11;
x in ( dom Gn ) by A19,A26;
hence x in ( dom Gn1 ) by A27;
end;
suppose x in { v };

hence x in ( dom Gn1 ) by A8,A16,XBOOLE_0:def 3;
end;
end;
hence x in ( dom Gn1 );
end;
hence ( W2 .vertices() ) c= ( dom Gn1 ) by TARSKI:def 3;
let n being  even Nat;
assume A28: n in ( dom W2 );
then A29: n <= ( len W2 ) by FINSEQ_3:25;
A30: 1 <= n by A28,FINSEQ_3:25;
now
per cases ;
suppose A31: n <= ( len W );

then n < ( len W ) by XXREAL_0:1;
then A32: ( n + 1 ) <= ( len W ) by NAT_1:13;
1 <= ( 1 + n ) by NAT_1:11;
then ( n + 1 ) in ( dom W ) by A32,FINSEQ_3:25;
then A33: ( W2 . ( n + 1 ) ) = ( W . ( n + 1 ) ) by A22,GLIB_001:65;
A34: n in ( dom W ) by A30,A31,FINSEQ_3:25;
then ( W2 . n ) = ( W . n ) by A22,GLIB_001:65;
hence ( W2 . n ) = ( FAP . ( W2 . ( n + 1 ) ) ) by A20,A34,A33;
end;
suppose A35: n > ( len W );

n <= ( ( len W ) + ( 2 * 1 ) ) by A22,A29,GLIB_001:64;
then n < ( ( ( len W ) + 1 ) + 1 ) by XXREAL_0:1;
then A36: n <= ( ( len W ) + 1 ) by NAT_1:13;
( ( len W ) + 1 ) <= n by A35,NAT_1:13;
then A37: n = ( ( len W ) + 1 ) by A36,XXREAL_0:1;
then A38: ( W2 . n ) = e by A22,GLIB_001:65;
( n + 1 ) = ( ( len W ) + ( 1 + 1 ) ) by A37;
then A39: ( W2 . ( n + 1 ) ) = v by A16,A22,GLIB_001:65;
A40: v in ( dom Gn1 ) by A8,A15,XBOOLE_0:def 3;
( Gn1 . v ) = e by A7,A16,CKB3:1;
hence ( W2 . n ) = ( FAP . ( W2 . ( n + 1 ) ) ) by A38,A39,A40,CKB29:1;
end;
end;
hence ( W2 . n ) = ( FAP . ( W2 . ( n + 1 ) ) );
end;
hence (ex P being  vertex-distinct (Path of G) st (((P is_Walk_from source,v & P is_augmenting_wrt EL) & ( P .vertices() ) c= ( dom Gn1 )) & (for n being  even Nat holds (n in ( dom P ) implies ( P . n ) = ( FAP . ( P . ( n + 1 ) ) )))));
end;
end;
hence (ex P being  vertex-distinct (Path of G) st (((P is_Walk_from source,v & P is_augmenting_wrt EL) & ( P .vertices() ) c= ( dom Gn1 )) & (for n being  even Nat holds (n in ( dom P ) implies ( P . n ) = ( FAP . ( P . ( n + 1 ) ) )))));
end;
hence P[ ( n + 1 ) ];
end;
suppose A41: (Next <> ( {} ) & ( ( the_Source_of G ) . e ) in ( dom Gn ));

then A42: Gn1 = ( Gn +* ( ( ( the_Target_of G ) . e ) .--> e ) ) by A2,CKB21:def 1;
then A43: ( dom Gn1 ) = ( ( dom Gn ) \/ { ( ( the_Target_of G ) . e ) } ) by CKB1:1;
A44: e in Next by A41;
A45: (e is_forward_edge_wrt Gn or e is_backward_edge_wrt Gn) by A41,CKB20:def 1;
then A46: ( EL . e ) < ( ( the_Weight_of G ) . e ) by A41,CKB14:def 1,CKB15:def 1;
now
let v being set;
assume A47: v in ( dom Gn1 );
now
per cases  by A43,A47,XBOOLE_0:def 3;
suppose v in ( dom Gn );

then consider P being  vertex-distinct (Path of G) such that A48: P is_Walk_from source,v and A49: P is_augmenting_wrt EL and A50: ( P .vertices() ) c= ( dom Gn ) and A51: (for n being  even Nat holds (n in ( dom P ) implies ( P . n ) = ( FAP . ( P . ( n + 1 ) ) ))) by A1;
take P;
( dom Gn ) c= ( dom Gn1 ) by CKB26:1,NAT_1:11;
hence (((P is_Walk_from source,v & P is_augmenting_wrt EL) & ( P .vertices() ) c= ( dom Gn1 )) & (for n being  even Nat holds (n in ( dom P ) implies ( P . n ) = ( FAP . ( P . ( n + 1 ) ) )))) by A48,A49,A50,A51,XBOOLE_1:1;
end;
suppose A52: v in { ( ( the_Target_of G ) . e ) };

then A53: v = ( ( the_Target_of G ) . e ) by TARSKI:def 1;
now
consider W being  vertex-distinct (Path of G) such that A54: W is_Walk_from source,( ( the_Source_of G ) . e ) and A55: W is_augmenting_wrt EL and A56: ( W .vertices() ) c= ( dom Gn ) and A57: (for n being  even Nat holds (n in ( dom W ) implies ( W . n ) = ( FAP . ( W . ( n + 1 ) ) ))) by A1,A41;
set W2 = ( W .addEdge e );
A58: ( W .last() ) = ( ( the_Source_of G ) . e ) by A54,GLIB_001:def 23;
then A59: e Joins ( W .last() ),( ( the_Target_of G ) . e ),G by A44,GLIB_000:def 13;
A60: (not ( ( the_Target_of G ) . e ) in ( W .vertices() )) by A41,A45,A56,CKB14:def 1,CKB15:def 1;
then reconsider W2 as  vertex-distinct (Walk of G) by A59,GLIB_001:155;
take W2;
( W .first() ) = source by A54,GLIB_001:def 23;
hence W2 is_Walk_from source,v by A53,A59,GLIB_001:63;
e DJoins ( W .last() ),( ( the_Target_of G ) . e ),G by A44,A58,GLIB_000:def 14;
hence W2 is_augmenting_wrt EL by A46,A55,A60,CKB19:1;
A61: ( W2 .vertices() ) = ( ( W .vertices() ) \/ { v } ) by A53,A59,GLIB_001:95;
now
let x being set;
assume A62: x in ( W2 .vertices() );
now
per cases  by A61,A62,XBOOLE_0:def 3;
suppose A63: x in ( W .vertices() );

A64: ( dom Gn ) c= ( dom Gn1 ) by CKB26:1,NAT_1:11;
x in ( dom Gn ) by A56,A63;
hence x in ( dom Gn1 ) by A64;
end;
suppose x in { v };

hence x in ( dom Gn1 ) by A43,A53,XBOOLE_0:def 3;
end;
end;
hence x in ( dom Gn1 );
end;
hence ( W2 .vertices() ) c= ( dom Gn1 ) by TARSKI:def 3;
let n being  even Nat;
assume A65: n in ( dom W2 );
then A66: n <= ( len W2 ) by FINSEQ_3:25;
A67: 1 <= n by A65,FINSEQ_3:25;
now
per cases ;
suppose A68: n <= ( len W );

then n < ( len W ) by XXREAL_0:1;
then A69: ( n + 1 ) <= ( len W ) by NAT_1:13;
1 <= ( 1 + n ) by NAT_1:11;
then ( n + 1 ) in ( dom W ) by A69,FINSEQ_3:25;
then A70: ( W2 . ( n + 1 ) ) = ( W . ( n + 1 ) ) by A59,GLIB_001:65;
A71: n in ( dom W ) by A67,A68,FINSEQ_3:25;
then ( W2 . n ) = ( W . n ) by A59,GLIB_001:65;
hence ( W2 . n ) = ( FAP . ( W2 . ( n + 1 ) ) ) by A57,A71,A70;
end;
suppose A72: n > ( len W );

n <= ( ( len W ) + ( 2 * 1 ) ) by A59,A66,GLIB_001:64;
then n < ( ( ( len W ) + 1 ) + 1 ) by XXREAL_0:1;
then A73: n <= ( ( len W ) + 1 ) by NAT_1:13;
( ( len W ) + 1 ) <= n by A72,NAT_1:13;
then A74: n = ( ( len W ) + 1 ) by A73,XXREAL_0:1;
then A75: ( W2 . n ) = e by A59,GLIB_001:65;
( n + 1 ) = ( ( len W ) + ( 1 + 1 ) ) by A74;
then A76: ( W2 . ( n + 1 ) ) = v by A53,A59,GLIB_001:65;
A77: v in ( dom Gn1 ) by A43,A52,XBOOLE_0:def 3;
( Gn1 . v ) = e by A42,A53,CKB3:1;
hence ( W2 . n ) = ( FAP . ( W2 . ( n + 1 ) ) ) by A75,A76,A77,CKB29:1;
end;
end;
hence ( W2 . n ) = ( FAP . ( W2 . ( n + 1 ) ) );
end;
hence (ex P being  vertex-distinct (Path of G) st (((P is_Walk_from source,v & P is_augmenting_wrt EL) & ( P .vertices() ) c= ( dom Gn1 )) & (for n being  even Nat holds (n in ( dom P ) implies ( P . n ) = ( FAP . ( P . ( n + 1 ) ) )))));
end;
end;
hence (ex P being  vertex-distinct (Path of G) st (((P is_Walk_from source,v & P is_augmenting_wrt EL) & ( P .vertices() ) c= ( dom Gn1 )) & (for n being  even Nat holds (n in ( dom P ) implies ( P . n ) = ( FAP . ( P . ( n + 1 ) ) )))));
end;
hence P[ ( n + 1 ) ];
end;
end;
hence P[ ( n + 1 ) ];
end;
then A78: (for n being Nat holds (P[ n ] implies P[ ( n + 1 ) ]));
now
set P = ( G .walkOf source );
let v being set;
assume A79: v in ( dom ( CS . ( 0 ) ) );
take P;
v in { source } by A79,CKB25:1;
then v = source by TARSKI:def 1;
hence P is_Walk_from source,v by GLIB_001:13;
thus P is_augmenting_wrt EL by CKB17:1;
( P .vertices() ) = { source } by GLIB_001:90;
hence ( P .vertices() ) c= ( dom ( CS . ( 0 ) ) ) by CKB25:1;
let n being  even Nat;
assume A80: n in ( dom P );
then n <= ( len P ) by FINSEQ_3:25;
then A81: n < ( len P ) by XXREAL_0:1;
1 <= n by A80,FINSEQ_3:25;
hence ( P . n ) = ( FAP . ( P . ( n + 1 ) ) ) by A81,GLIB_001:13;
end;
then A82: P[ ( 0 ) ];
A83: (for n being Nat holds P[ n ]) from NAT_1:sch 2(A82,A78);
hereby
assume sink in ( dom FAP );
then consider W being  vertex-distinct (Path of G) such that A84: W is_Walk_from source,sink and A85: W is_augmenting_wrt EL and ( W .vertices() ) c= ( dom FAP ) and A86: (for n being  even Nat holds (n in ( dom W ) implies ( W . n ) = ( FAP . ( W . ( n + 1 ) ) ))) by A83;
take W;
thus ((W is_Walk_from source,sink & W is_augmenting_wrt EL) & (for n being  even Nat holds (n in ( dom W ) implies ( W . n ) = ( FAP . ( W . ( n + 1 ) ) )))) by A84,A85,A86;
end;
thus thesis;
end;
uniqueness
proof
set FAP = ( AP:FindAugPath (EL,source) );
set CS = ( AP:CompSeq (EL,source) );
let IT1 being  vertex-distinct (Path of G);
let IT2 being  vertex-distinct (Path of G);
defpred P[ Nat ]
 means
(for v being set holds (for P1,P2 being  vertex-distinct (Path of G) holds (((((((v in ( dom ( CS . $1 ) ) & P1 is_Walk_from source,v) & P1 is_augmenting_wrt EL) & P2 is_Walk_from source,v) & P2 is_augmenting_wrt EL) & (for n being  even Nat holds (n in ( dom P1 ) implies ( P1 . n ) = ( FAP . ( P1 . ( n + 1 ) ) )))) & (for n being  even Nat holds (n in ( dom P2 ) implies ( P2 . n ) = ( FAP . ( P2 . ( n + 1 ) ) )))) implies P1 = P2)));
set G0 = ( CS . ( 0 ) );
now
let n being Nat;
assume A87: P[ n ];
set Gn = ( CS . n );
set Gn1 = ( CS . ( n + 1 ) );
set Next = ( AP:NextBestEdges Gn );
set e = ( choose Next );
A88: Gn1 = ( AP:Step Gn ) by CKB24:def 1;
now
per cases ;
suppose Next = ( {} );

then Gn1 = Gn by A88,CKB21:def 1;
hence P[ ( n + 1 ) ] by A87;
end;
suppose A89: (Next <> ( {} ) & (not ( ( the_Source_of G ) . e ) in ( dom Gn )));

source in { source } by TARSKI:def 1;
then A90: source in ( dom G0 ) by CKB25:1;
( dom G0 ) c= ( dom Gn ) by CKB26:1;
then A91: source in ( dom Gn ) by A90;
(e is_forward_edge_wrt Gn or e is_backward_edge_wrt Gn) by A89,CKB20:def 1;
then A92: ( ( the_Target_of G ) . e ) in ( dom Gn ) by A89,CKB14:def 1,CKB15:def 1;
A93: Gn1 = ( Gn +* ( ( ( the_Source_of G ) . e ) .--> e ) ) by A88,A89,CKB21:def 1;
then A94: ( dom Gn1 ) = ( ( dom Gn ) \/ { ( ( the_Source_of G ) . e ) } ) by CKB1:1;
now
let v being set;
let P1 being  vertex-distinct (Path of G);
let P2 being  vertex-distinct (Path of G);
assume that
A95: v in ( dom Gn1 )
and
A96: P1 is_Walk_from source,v
and
A97: P1 is_augmenting_wrt EL
and
A98: P2 is_Walk_from source,v
and
A99: P2 is_augmenting_wrt EL
and
A100: (for n being  even Nat holds (n in ( dom P1 ) implies ( P1 . n ) = ( FAP . ( P1 . ( n + 1 ) ) )))
and
A101: (for n being  even Nat holds (n in ( dom P2 ) implies ( P2 . n ) = ( FAP . ( P2 . ( n + 1 ) ) )));
A102: ( P1 . ( len P1 ) ) = v by A96,GLIB_001:17;
A103: ( P2 . 1 ) = source by A98,GLIB_001:17;
A104: ( P2 . ( len P2 ) ) = v by A98,GLIB_001:17;
A105: ( P1 . 1 ) = source by A96,GLIB_001:17;
now
per cases  by A94,A95,XBOOLE_0:def 3;
suppose v in ( dom Gn );

hence P1 = P2 by A87,A96,A97,A98,A99,A100,A101;
end;
suppose A106: v in { ( ( the_Source_of G ) . e ) };

then A107: v = ( ( the_Source_of G ) . e ) by TARSKI:def 1;
then ( Gn1 . v ) = e by A93,CKB3:1;
then A108: ( FAP . v ) = e by A95,CKB29:1;
A109: v <> source by A89,A91,A106,TARSKI:def 1;
then ( P1 . 1 ) <> ( P1 .last() ) by A105,A102,GLIB_001:def 7;
then ( P1 .first() ) <> ( P1 .last() ) by GLIB_001:def 6;
then P1 is non  trivial by GLIB_001:127;
then A110: 3 <= ( len P1 ) by GLIB_001:125;
( P2 . 1 ) <> ( P2 .last() ) by A103,A104,A109,GLIB_001:def 7;
then ( P2 .first() ) <> ( P2 .last() ) by GLIB_001:def 6;
then P2 is non  trivial by GLIB_001:127;
then A111: 3 <= ( len P2 ) by GLIB_001:125;
then A112: ( 3 - 2 ) < ( ( len P2 ) - ( 0 ) ) by XREAL_1:15;
( 3 - 2 ) < ( ( len P1 ) - ( 0 ) ) by A110,XREAL_1:15;
then reconsider lenP11 = ( ( len P1 ) - 1 ),lenP21 = ( ( len P2 ) - 1 ) as  even (Element of ( NAT )) by A112,INT_1:5;
A113: lenP11 < ( ( len P1 ) - ( 0 ) ) by XREAL_1:15;
( 3 - 2 ) <= lenP11 by A110,XREAL_1:15;
then A114: lenP11 in ( dom P1 ) by A113,FINSEQ_3:25;
( lenP11 + 1 ) = ( len P1 );
then A115: ( P1 . lenP11 ) = e by A100,A102,A114,A108;
then consider lenP12 being  odd (Element of ( NAT )) such that A116: lenP12 = ( lenP11 - 1 ) and ( lenP11 - 1 ) in ( dom P1 ) and ( lenP11 + 1 ) in ( dom P1 ) and A117: e Joins ( P1 . lenP12 ),v,G by A102,A114,GLIB_001:9;
A118: ( P1 . lenP12 ) = ( ( the_Target_of G ) . e ) by A89,A92,A107,A117,GLIB_000:def 13;
set P1A = ( P1 .cut (( ( 2 * ( 0 ) ) + 1 ),lenP12) );
A119: lenP12 < ( len P1 ) by A113,A116,XREAL_1:15;
A120:now
let n being  even Nat;
assume A121: n in ( dom P1A );
then A122: 1 <= n by FINSEQ_3:25;
A123: n <= ( len P1A ) by A121,FINSEQ_3:25;
then n < ( len P1A ) by XXREAL_0:1;
then A124: ( n + 1 ) <= ( len P1A ) by NAT_1:13;
1 <= ( n + 1 ) by A121,NAT_1:13;
then ( n + 1 ) in ( dom P1A ) by A124,FINSEQ_3:25;
then A125: ( P1A . ( n + 1 ) ) = ( P1 . ( n + 1 ) ) by A119,GLIB_001:46;
( len P1A ) = lenP12 by A119,GLIB_001:45;
then n <= ( len P1 ) by A119,A123,XXREAL_0:2;
then A126: n in ( dom P1 ) by A122,FINSEQ_3:25;
( P1A . n ) = ( P1 . n ) by A119,A121,GLIB_001:46;
hence ( P1A . n ) = ( FAP . ( P1A . ( n + 1 ) ) ) by A100,A125,A126;
end;
A127: ( lenP12 + ( 1 + 1 ) ) = ( len P1 ) by A116;
( lenP12 + 1 ) = lenP11 by A116;
then A128: ( P1 .cut (lenP12,( len P1 )) ) = ( G .walkOf (( ( the_Target_of G ) . e ),e,v) ) by A102,A115,A118,A119,A127,GLIB_001:40;
A129: P1A is_augmenting_wrt EL by A97,CKB18:1;
A130: 1 <= lenP12 by ABIAN:12;
then A131: ( P1A .append ( P1 .cut (lenP12,( len P1 )) ) ) = ( P1 .cut (( ( 2 * ( 0 ) ) + 1 ),( len P1 )) ) by A119,GLIB_001:38
.= P1 by GLIB_001:39;
A132: lenP21 < ( ( len P2 ) - ( 0 ) ) by XREAL_1:15;
( 3 - 2 ) <= lenP21 by A111,XREAL_1:15;
then A133: lenP21 in ( dom P2 ) by A132,FINSEQ_3:25;
( lenP21 + 1 ) = ( len P2 );
then A134: ( P2 . lenP21 ) = e by A101,A104,A133,A108;
then consider lenP22 being  odd (Element of ( NAT )) such that A135: lenP22 = ( lenP21 - 1 ) and ( lenP21 - 1 ) in ( dom P2 ) and ( lenP21 + 1 ) in ( dom P2 ) and A136: e Joins ( P2 . lenP22 ),v,G by A104,A133,GLIB_001:9;
A137: ( lenP22 + ( 1 + 1 ) ) = ( len P2 ) by A135;
set P2A = ( P2 .cut (( ( 2 * ( 0 ) ) + 1 ),lenP22) );
A138: lenP22 < ( len P2 ) by A132,A135,XREAL_1:15;
A139:now
let n being  even Nat;
assume A140: n in ( dom P2A );
then A141: 1 <= n by FINSEQ_3:25;
A142: n <= ( len P2A ) by A140,FINSEQ_3:25;
then n < ( len P2A ) by XXREAL_0:1;
then A143: ( n + 1 ) <= ( len P2A ) by NAT_1:13;
1 <= ( n + 1 ) by A140,NAT_1:13;
then ( n + 1 ) in ( dom P2A ) by A143,FINSEQ_3:25;
then A144: ( P2A . ( n + 1 ) ) = ( P2 . ( n + 1 ) ) by A138,GLIB_001:46;
( len P2A ) = lenP22 by A138,GLIB_001:45;
then n <= ( len P2 ) by A138,A142,XXREAL_0:2;
then A145: n in ( dom P2 ) by A141,FINSEQ_3:25;
( P2A . n ) = ( P2 . n ) by A138,A140,GLIB_001:46;
hence ( P2A . n ) = ( FAP . ( P2A . ( n + 1 ) ) ) by A101,A144,A145;
end;
A146: 1 <= lenP22 by ABIAN:12;
then A147: ( P2A .append ( P2 .cut (lenP22,( len P2 )) ) ) = ( P2 .cut (( ( 2 * ( 0 ) ) + 1 ),( len P2 )) ) by A138,GLIB_001:38
.= P2 by GLIB_001:39;
A148: ( P2 . lenP22 ) = ( ( the_Target_of G ) . e ) by A89,A92,A107,A136,GLIB_000:def 13;
then A149: P2A is_Walk_from source,( ( the_Target_of G ) . e ) by A103,A146,A138,GLIB_001:37;
( lenP22 + 1 ) = lenP21 by A135;
then A150: ( P2 .cut (lenP22,( len P2 )) ) = ( G .walkOf (( ( the_Target_of G ) . e ),e,v) ) by A104,A134,A148,A138,A137,GLIB_001:40;
A151: P2A is_augmenting_wrt EL by A99,CKB18:1;
P1A is_Walk_from source,( ( the_Target_of G ) . e ) by A105,A118,A130,A119,GLIB_001:37;
hence P1 = P2 by A87,A92,A149,A129,A151,A120,A139,A128,A150,A131,A147;
end;
end;
hence P1 = P2;
end;
hence P[ ( n + 1 ) ];
end;
suppose A152: (Next <> ( {} ) & ( ( the_Source_of G ) . e ) in ( dom Gn ));

source in { source } by TARSKI:def 1;
then A153: source in ( dom G0 ) by CKB25:1;
( dom G0 ) c= ( dom Gn ) by CKB26:1;
then A154: source in ( dom Gn ) by A153;
(e is_forward_edge_wrt Gn or e is_backward_edge_wrt Gn) by A152,CKB20:def 1;
then A155: (not ( ( the_Target_of G ) . e ) in ( dom Gn )) by A152,CKB14:def 1,CKB15:def 1;
A156: Gn1 = ( Gn +* ( ( ( the_Target_of G ) . e ) .--> e ) ) by A88,A152,CKB21:def 1;
then A157: ( dom Gn1 ) = ( ( dom Gn ) \/ { ( ( the_Target_of G ) . e ) } ) by CKB1:1;
now
let v being set;
let P1 being  vertex-distinct (Path of G);
let P2 being  vertex-distinct (Path of G);
assume that
A158: v in ( dom Gn1 )
and
A159: P1 is_Walk_from source,v
and
A160: P1 is_augmenting_wrt EL
and
A161: P2 is_Walk_from source,v
and
A162: P2 is_augmenting_wrt EL
and
A163: (for n being  even Nat holds (n in ( dom P1 ) implies ( P1 . n ) = ( FAP . ( P1 . ( n + 1 ) ) )))
and
A164: (for n being  even Nat holds (n in ( dom P2 ) implies ( P2 . n ) = ( FAP . ( P2 . ( n + 1 ) ) )));
A165: ( P1 . ( len P1 ) ) = v by A159,GLIB_001:17;
A166: ( P2 . 1 ) = source by A161,GLIB_001:17;
A167: ( P2 . ( len P2 ) ) = v by A161,GLIB_001:17;
A168: ( P1 . 1 ) = source by A159,GLIB_001:17;
now
per cases  by A157,A158,XBOOLE_0:def 3;
suppose v in ( dom Gn );

hence P1 = P2 by A87,A159,A160,A161,A162,A163,A164;
end;
suppose A169: v in { ( ( the_Target_of G ) . e ) };

then A170: v = ( ( the_Target_of G ) . e ) by TARSKI:def 1;
then ( Gn1 . v ) = e by A156,CKB3:1;
then A171: ( FAP . v ) = e by A158,CKB29:1;
A172: v <> source by A155,A154,A169,TARSKI:def 1;
then ( P1 . 1 ) <> ( P1 .last() ) by A168,A165,GLIB_001:def 7;
then ( P1 .first() ) <> ( P1 .last() ) by GLIB_001:def 6;
then P1 is non  trivial by GLIB_001:127;
then A173: 3 <= ( len P1 ) by GLIB_001:125;
( P2 . 1 ) <> ( P2 .last() ) by A166,A167,A172,GLIB_001:def 7;
then ( P2 .first() ) <> ( P2 .last() ) by GLIB_001:def 6;
then P2 is non  trivial by GLIB_001:127;
then A174: 3 <= ( len P2 ) by GLIB_001:125;
then A175: ( 3 - 2 ) < ( ( len P2 ) - ( 0 ) ) by XREAL_1:15;
( 3 - 2 ) < ( ( len P1 ) - ( 0 ) ) by A173,XREAL_1:15;
then reconsider lenP11 = ( ( len P1 ) - 1 ),lenP21 = ( ( len P2 ) - 1 ) as  even (Element of ( NAT )) by A175,INT_1:5;
A176: lenP11 < ( ( len P1 ) - ( 0 ) ) by XREAL_1:15;
( 3 - 2 ) <= lenP11 by A173,XREAL_1:15;
then A177: lenP11 in ( dom P1 ) by A176,FINSEQ_3:25;
( lenP11 + 1 ) = ( len P1 );
then A178: ( P1 . lenP11 ) = e by A163,A165,A177,A171;
then consider lenP12 being  odd (Element of ( NAT )) such that A179: lenP12 = ( lenP11 - 1 ) and ( lenP11 - 1 ) in ( dom P1 ) and ( lenP11 + 1 ) in ( dom P1 ) and A180: e Joins ( P1 . lenP12 ),v,G by A165,A177,GLIB_001:9;
A181: ( P1 . lenP12 ) = ( ( the_Source_of G ) . e ) by A152,A155,A170,A180,GLIB_000:def 13;
set P1A = ( P1 .cut (( ( 2 * ( 0 ) ) + 1 ),lenP12) );
A182: lenP12 < ( len P1 ) by A176,A179,XREAL_1:15;
A183:now
let n being  even Nat;
assume A184: n in ( dom P1A );
then A185: 1 <= n by FINSEQ_3:25;
A186: n <= ( len P1A ) by A184,FINSEQ_3:25;
then n < ( len P1A ) by XXREAL_0:1;
then A187: ( n + 1 ) <= ( len P1A ) by NAT_1:13;
1 <= ( n + 1 ) by A184,NAT_1:13;
then ( n + 1 ) in ( dom P1A ) by A187,FINSEQ_3:25;
then A188: ( P1A . ( n + 1 ) ) = ( P1 . ( n + 1 ) ) by A182,GLIB_001:46;
( len P1A ) = lenP12 by A182,GLIB_001:45;
then n <= ( len P1 ) by A182,A186,XXREAL_0:2;
then A189: n in ( dom P1 ) by A185,FINSEQ_3:25;
( P1A . n ) = ( P1 . n ) by A182,A184,GLIB_001:46;
hence ( P1A . n ) = ( FAP . ( P1A . ( n + 1 ) ) ) by A163,A188,A189;
end;
A190: ( lenP12 + ( 1 + 1 ) ) = ( len P1 ) by A179;
( lenP12 + 1 ) = lenP11 by A179;
then A191: ( P1 .cut (lenP12,( len P1 )) ) = ( G .walkOf (( ( the_Source_of G ) . e ),e,v) ) by A165,A178,A181,A182,A190,GLIB_001:40;
A192: P1A is_augmenting_wrt EL by A160,CKB18:1;
A193: 1 <= lenP12 by ABIAN:12;
then A194: ( P1A .append ( P1 .cut (lenP12,( len P1 )) ) ) = ( P1 .cut (( ( 2 * ( 0 ) ) + 1 ),( len P1 )) ) by A182,GLIB_001:38
.= P1 by GLIB_001:39;
A195: lenP21 < ( ( len P2 ) - ( 0 ) ) by XREAL_1:15;
( 3 - 2 ) <= lenP21 by A174,XREAL_1:15;
then A196: lenP21 in ( dom P2 ) by A195,FINSEQ_3:25;
( lenP21 + 1 ) = ( len P2 );
then A197: ( P2 . lenP21 ) = e by A164,A167,A196,A171;
then consider lenP22 being  odd (Element of ( NAT )) such that A198: lenP22 = ( lenP21 - 1 ) and ( lenP21 - 1 ) in ( dom P2 ) and ( lenP21 + 1 ) in ( dom P2 ) and A199: e Joins ( P2 . lenP22 ),v,G by A167,A196,GLIB_001:9;
A200: ( lenP22 + ( 1 + 1 ) ) = ( len P2 ) by A198;
set P2A = ( P2 .cut (( ( 2 * ( 0 ) ) + 1 ),lenP22) );
A201: lenP22 < ( len P2 ) by A195,A198,XREAL_1:15;
A202:now
let n being  even Nat;
assume A203: n in ( dom P2A );
then A204: 1 <= n by FINSEQ_3:25;
A205: n <= ( len P2A ) by A203,FINSEQ_3:25;
then n < ( len P2A ) by XXREAL_0:1;
then A206: ( n + 1 ) <= ( len P2A ) by NAT_1:13;
1 <= ( n + 1 ) by A203,NAT_1:13;
then ( n + 1 ) in ( dom P2A ) by A206,FINSEQ_3:25;
then A207: ( P2A . ( n + 1 ) ) = ( P2 . ( n + 1 ) ) by A201,GLIB_001:46;
( len P2A ) = lenP22 by A201,GLIB_001:45;
then n <= ( len P2 ) by A201,A205,XXREAL_0:2;
then A208: n in ( dom P2 ) by A204,FINSEQ_3:25;
( P2A . n ) = ( P2 . n ) by A201,A203,GLIB_001:46;
hence ( P2A . n ) = ( FAP . ( P2A . ( n + 1 ) ) ) by A164,A207,A208;
end;
A209: 1 <= lenP22 by ABIAN:12;
then A210: ( P2A .append ( P2 .cut (lenP22,( len P2 )) ) ) = ( P2 .cut (( ( 2 * ( 0 ) ) + 1 ),( len P2 )) ) by A201,GLIB_001:38
.= P2 by GLIB_001:39;
A211: ( P2 . lenP22 ) = ( ( the_Source_of G ) . e ) by A152,A155,A170,A199,GLIB_000:def 13;
then A212: P2A is_Walk_from source,( ( the_Source_of G ) . e ) by A166,A209,A201,GLIB_001:37;
( lenP22 + 1 ) = lenP21 by A198;
then A213: ( P2 .cut (lenP22,( len P2 )) ) = ( G .walkOf (( ( the_Source_of G ) . e ),e,v) ) by A167,A197,A211,A201,A200,GLIB_001:40;
A214: P2A is_augmenting_wrt EL by A162,CKB18:1;
P1A is_Walk_from source,( ( the_Source_of G ) . e ) by A168,A181,A193,A182,GLIB_001:37;
hence P1 = P2 by A87,A152,A212,A192,A214,A183,A202,A191,A213,A194,A210;
end;
end;
hence P1 = P2;
end;
hence P[ ( n + 1 ) ];
end;
end;
hence P[ ( n + 1 ) ];
end;
then A215: (for n being Nat holds (P[ n ] implies P[ ( n + 1 ) ]));
now
let v being set;
let P1 being  vertex-distinct (Path of G);
let P2 being  vertex-distinct (Path of G);
assume that
A216: v in ( dom G0 )
and
A217: P1 is_Walk_from source,v
and
P1 is_augmenting_wrt EL
and
A218: P2 is_Walk_from source,v
and
P2 is_augmenting_wrt EL
and
(for n being  even Nat holds (n in ( dom P1 ) implies ( P1 . n ) = ( FAP . ( P1 . ( n + 1 ) ) )))
and
(for n being  even Nat holds (n in ( dom P2 ) implies ( P2 . n ) = ( FAP . ( P2 . ( n + 1 ) ) )));
v in { source } by A216,CKB25:1;
then A219: v = source by TARSKI:def 1;
then A220: ( P1 . ( ( 2 * ( 0 ) ) + 1 ) ) = v by A217,GLIB_001:17;
A221: ( P2 . ( ( 2 * ( 0 ) ) + 1 ) ) = v by A218,A219,GLIB_001:17;
A222: 1 <= ( len P1 ) by ABIAN:12;
( P1 . ( len P1 ) ) = v by A217,GLIB_001:17;
then ( len P1 ) = 1 by A220,A222,GLIB_001:def 29;
then A223: P1 = <* v *> by A220,FINSEQ_1:40;
A224: 1 <= ( len P2 ) by ABIAN:12;
( P2 . ( len P2 ) ) = v by A218,GLIB_001:17;
then ( len P2 ) = 1 by A221,A224,GLIB_001:def 29;
hence P1 = P2 by A221,A223,FINSEQ_1:40;
end;
then A225: P[ ( 0 ) ];
(for n being Nat holds P[ n ]) from NAT_1:sch 2(A225,A215);
hence (((sink in ( dom FAP ) & ((IT1 is_Walk_from source,sink & IT1 is_augmenting_wrt EL) & (for n being  even Nat holds (n in ( dom IT1 ) implies ( IT1 . n ) = ( ( AP:FindAugPath (EL,source) ) . ( IT1 . ( n + 1 ) ) ))))) & ((IT2 is_Walk_from source,sink & IT2 is_augmenting_wrt EL) & (for n being  even Nat holds (n in ( dom IT2 ) implies ( IT2 . n ) = ( ( AP:FindAugPath (EL,source) ) . ( IT2 . ( n + 1 ) ) ))))) implies IT1 = IT2);
thus thesis;
end;
consistency;
end;
