environ
vocabularies NUMBERS,FUNCT_1,RELAT_1,FUNCT_4,FUNCOP_1,XBOOLE_0,TARSKI,GLIB_003,VALUED_0,SUBSET_1,REAL_1,GRAPH_5,FINSET_1,ZFMISC_1,TREES_1,GLIB_000,PBOOLE,CARD_1,XXREAL_0,CARD_3,XREAL_0,ORDINAL1,ARYTM_1,PARTFUN1,ARYTM_3,GLIB_001,ABIAN,NAT_1,FINSEQ_1,GRAPH_1,RCOMP_1,INT_1,PRE_POLY,UPROOTS,SGRAPH1,GLIB_005;
notations TARSKI,XBOOLE_0,CARD_1,NUMBERS,SUBSET_1,XCMPLX_0,XXREAL_0,XREAL_0,DOMAIN_1,REAL_1,RELAT_1,VALUED_0,PARTFUN1,FUNCT_1,PBOOLE,FINSEQ_1,FUNCT_2,GRAPH_5,ORDINAL1,UPROOTS,RELSET_1,FINSET_1,INT_1,NAT_1,FUNCOP_1,FUNCT_4,GLIB_000,GLIB_001,ABIAN,GLIB_002,GLIB_003,PRE_POLY,CKB5,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB20,CKB21,CKB22,CKB23,CKB24,CKB27,CKB30;
definitions TARSKI,GLIB_000,GLIB_003,FUNCOP_1,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB20,CKB21,CKB22,CKB24,CKB27,CKB30;
theorems CARD_1,CARD_2,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FUNCT_1,FUNCT_2,FUNCT_4,GLIB_000,GLIB_001,GLIB_003,GLIB_004,GRAPH_5,ABIAN,INT_1,NAT_1,PBOOLE,PEPIN,TARSKI,UPROOTS,XBOOLE_0,XBOOLE_1,ZFMISC_1,XREAL_1,XXREAL_0,ORDINAL1,NAT_D,VALUED_0,RELSET_1,PARTFUN1,RELAT_1,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33;
schemes NAT_1,SUBSET_1,FINSEQ_1,CLASSES1,RECDEF_1,GRAPH_5;
registrations XBOOLE_0,RELAT_1,PARTFUN1,INT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,MEMBERED,FINSEQ_1,GLIB_000,ABIAN,GLIB_001,GLIB_002,GLIB_003,VALUED_0,FUNCT_2,CARD_1,PRE_CIRC,PRE_POLY,RELSET_1,CKB6,CKB7,CKB8;
constructors DOMAIN_1,FUNCT_4,NAT_D,GRAPH_2,GRAPH_5,UPROOTS,GLIB_004,SEQ_1,XXREAL_2,RELSET_1,PBOOLE,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB20,CKB21,CKB22,CKB23,CKB24,CKB27,CKB30;
requirements ARITHM,BOOLE,NUMERALS,REAL,SUBSET;
begin
definition
let G being  natural-weighted WGraph;
let EL being (FF:ELabeling of G);
let W being (Walk of G);
assume A1: W is_augmenting_wrt EL;
func W .flowSeq EL -> (FinSequence of ( NAT ))
means
:Def15: (( dom it ) = ( dom ( W .edgeSeq() ) ) & (for n being Nat holds (n in ( dom it ) implies ((( W . ( 2 * n ) ) DJoins ( W . ( ( 2 * n ) - 1 ) ),( W . ( ( 2 * n ) + 1 ) ),G implies ( it . n ) = ( ( ( the_Weight_of G ) . ( W . ( 2 * n ) ) ) - ( EL . ( W . ( 2 * n ) ) ) )) & ((not ( W . ( 2 * n ) ) DJoins ( W . ( ( 2 * n ) - 1 ) ),( W . ( ( 2 * n ) + 1 ) ),G) implies ( it . n ) = ( EL . ( W . ( 2 * n ) ) ))))));
existence
proof
defpred P[ Nat,set ]
 means
((( W . ( 2 * $1 ) ) DJoins ( W . ( ( 2 * $1 ) - 1 ) ),( W . ( ( 2 * $1 ) + 1 ) ),G implies $2 = ( ( ( the_Weight_of G ) . ( W . ( 2 * $1 ) ) ) - ( EL . ( W . ( 2 * $1 ) ) ) )) & ((not ( W . ( 2 * $1 ) ) DJoins ( W . ( ( 2 * $1 ) - 1 ) ),( W . ( ( 2 * $1 ) + 1 ) ),G) implies $2 = ( EL . ( W . ( 2 * $1 ) ) )));
now
let k being Nat;
assume k in ( Seg ( len ( W .edgeSeq() ) ) );
now
per cases ;
suppose ( W . ( 2 * k ) ) DJoins ( W . ( ( 2 * k ) - 1 ) ),( W . ( ( 2 * k ) + 1 ) ),G;

hence (ex x being set st P[ k,x ]);
end;
suppose (not ( W . ( 2 * k ) ) DJoins ( W . ( ( 2 * k ) - 1 ) ),( W . ( ( 2 * k ) + 1 ) ),G);

hence (ex x being set st P[ k,x ]);
end;
end;
hence (ex x being set st P[ k,x ]);
end;
then A2: (for k being Nat holds (k in ( Seg ( len ( W .edgeSeq() ) ) ) implies (ex x being set st P[ k,x ])));
consider IT being FinSequence such that A3: ( dom IT ) = ( Seg ( len ( W .edgeSeq() ) ) ) and A4: (for k being Nat holds (k in ( Seg ( len ( W .edgeSeq() ) ) ) implies P[ k,( IT . k ) ])) from FINSEQ_1:sch 1(A2);
now
let y being set;
assume y in ( rng IT );
then consider x being set such that A5: x in ( dom IT ) and A6: ( IT . x ) = y by FUNCT_1:def 3;
reconsider n = x as (Element of ( NAT )) by A5;
per cases ;
suppose A7: ( W . ( 2 * n ) ) DJoins ( W . ( ( 2 * n ) - 1 ) ),( W . ( ( 2 * n ) + 1 ) ),G;

n in ( dom ( W .edgeSeq() ) ) by A3,A5,FINSEQ_1:def 3;
then A8: ( 2 * n ) in ( dom W ) by GLIB_001:78;
then 1 <= ( 2 * n ) by FINSEQ_3:25;
then reconsider 2n1 = ( ( 2 * n ) - 1 ) as  odd (Element of ( NAT )) by INT_1:5;
( 2 * n ) <= ( len W ) by A8,FINSEQ_3:25;
then A9: 2n1 < ( ( len W ) - ( 0 ) ) by XREAL_1:15;
A10: ( 2n1 + ( 1 + 1 ) ) = ( ( 2 * n ) + 1 );
A11: ( IT . n ) = ( ( ( the_Weight_of G ) . ( W . ( 2 * n ) ) ) - ( EL . ( W . ( 2 * n ) ) ) ) by A3,A4,A5,A7;
( 2n1 + 1 ) = ( 2 * n );
then ( EL . ( W . ( 2 * n ) ) ) < ( ( the_Weight_of G ) . ( W . ( 2 * n ) ) ) by A1,A7,A9,A10,CKB16:def 1;
hence y in ( NAT ) by A6,A11,INT_1:5;
end;
suppose (not ( W . ( 2 * n ) ) DJoins ( W . ( ( 2 * n ) - 1 ) ),( W . ( ( 2 * n ) + 1 ) ),G);

then ( IT . n ) = ( EL . ( W . ( 2 * n ) ) ) by A3,A4,A5;
hence y in ( NAT ) by A6,ORDINAL1:def 12;
end;
end;
then ( rng IT ) c= ( NAT ) by TARSKI:def 3;
then reconsider IT as (FinSequence of ( NAT )) by FINSEQ_1:def 4;
take IT;
thus ( dom IT ) = ( dom ( W .edgeSeq() ) ) by A3,FINSEQ_1:def 3;
let n being Nat;
assume n in ( dom IT );
hence thesis by A3,A4;
end;
uniqueness
proof
defpred P[ Nat,set ]
 means
((( W . ( 2 * $1 ) ) DJoins ( W . ( ( 2 * $1 ) - 1 ) ),( W . ( ( 2 * $1 ) + 1 ) ),G implies $2 = ( ( ( the_Weight_of G ) . ( W . ( 2 * $1 ) ) ) - ( EL . ( W . ( 2 * $1 ) ) ) )) & ((not ( W . ( 2 * $1 ) ) DJoins ( W . ( ( 2 * $1 ) - 1 ) ),( W . ( ( 2 * $1 ) + 1 ) ),G) implies $2 = ( EL . ( W . ( 2 * $1 ) ) )));
let IT1 being (FinSequence of ( NAT )),IT2 being (FinSequence of ( NAT ));
assume that
A12: ( dom IT1 ) = ( dom ( W .edgeSeq() ) )
and
A13: (for n being Nat holds (n in ( dom IT1 ) implies P[ n,( IT1 . n ) ]))
and
A14: ( dom IT2 ) = ( dom ( W .edgeSeq() ) )
and
A15: (for n being Nat holds (n in ( dom IT2 ) implies P[ n,( IT2 . n ) ]));
now
let n being Nat;
assume A16: n in ( dom IT1 );
now
per cases ;
suppose A17: ( W . ( 2 * n ) ) DJoins ( W . ( ( 2 * n ) - 1 ) ),( W . ( ( 2 * n ) + 1 ) ),G;

then ( IT1 . n ) = ( ( ( the_Weight_of G ) . ( W . ( 2 * n ) ) ) - ( EL . ( W . ( 2 * n ) ) ) ) by A13,A16;
hence ( IT1 . n ) = ( IT2 . n ) by A12,A14,A15,A16,A17;
end;
suppose A18: (not ( W . ( 2 * n ) ) DJoins ( W . ( ( 2 * n ) - 1 ) ),( W . ( ( 2 * n ) + 1 ) ),G);

then ( IT1 . n ) = ( EL . ( W . ( 2 * n ) ) ) by A13,A16;
hence ( IT1 . n ) = ( IT2 . n ) by A12,A14,A15,A16,A18;
end;
end;
hence ( IT1 . n ) = ( IT2 . n );
end;
hence IT1 = IT2 by A12,A14,FINSEQ_1:13;
end;
end;
