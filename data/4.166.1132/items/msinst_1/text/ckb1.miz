environ
vocabularies XBOOLE_0,STRUCT_0,MSUALG_1,ALTCAT_1,MSALIMIT,SUBSET_1,FUNCT_1,CAT_1,RELAT_1,PBOOLE,ZFMISC_1,MCART_1,PUA2MSS1,RELAT_2,BINOP_1,TARSKI,MSUALG_6,FUNCT_2,PARTFUN1,NUMBERS,CARD_3,FUNCOP_1,PZFMISC1,MARGREL1,MEMBER_1,FUNCT_6,FINSEQ_4,MSUALG_3,MSINST_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,MCART_1,RELAT_1,FUNCT_1,STRUCT_0,FUNCT_2,MCART_2,RELSET_1,PARTFUN1,FINSEQ_2,CARD_3,BINOP_1,MULTOP_1,FUNCT_6,FUNCOP_1,PBOOLE,PZFMISC1,PRALG_1,MSUALG_1,MSUALG_3,ALTCAT_1,PRALG_2,PUA2MSS1,MSUALG_6,MSALIMIT;
definitions ALTCAT_1,MSUALG_3,PBOOLE,TARSKI,XBOOLE_0,BINOP_1;
theorems XBOOLE_0,ALTCAT_1,ALTCAT_2,AUTALG_1,CARD_3,CLOSURE1,FUNCOP_1,FUNCT_1,FUNCT_2,FUNCT_6,FUNCTOR0,MCART_1,MCART_2,MSSUBFAM,MSUALG_1,MSUALG_3,MSUALG_6,MSALIMIT,MULTOP_1,PARTFUN1,PBOOLE,PRALG_2,PUA2MSS1,RELAT_1,TARSKI,ZFMISC_1,PRALG_1,XBOOLE_1,PZFMISC1,FINSEQ_2;
schemes ALTCAT_1,MSSUBFAM,TARSKI;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,RELSET_1,FUNCOP_1,RELAT_1,STRUCT_0,MSUALG_1,ALTCAT_1,MSUALG_6,MSALIMIT,MSSUBFAM,PBOOLE;
constructors MCART_2,PZFMISC1,MSUALG_3,ALTCAT_1,PUA2MSS1,CLOSURE1,MSUALG_6,MSALIMIT,RELSET_1;
requirements SUBSET,BOOLE;
begin
reserve A for non  empty set;
reserve x for set;
definition
let A;
func MSSCat A ->  strict non  empty AltCatStr means 
:Def1: (((the carrier of it) = ( MSS_set A ) & (for i,j being (Element of ( MSS_set A )) holds ( (the Arrows of it) . (i,j) ) = ( MSS_morph (i,j) ))) & (for i,j,k being (object of it) holds (((i in ( MSS_set A ) & j in ( MSS_set A )) & k in ( MSS_set A )) implies (for f1,f2,g1,g2 being Function holds (([ f1,f2 ] in ( (the Arrows of it) . (i,j) ) & [ g1,g2 ] in ( (the Arrows of it) . (j,k) )) implies ( ( (the Comp of it) . (i,j,k) ) . ([ g1,g2 ],[ f1,f2 ]) ) = [ ( g1 * f1 ),( g2 * f2 ) ])))));
existence
proof
set c = ( MSS_set A );
deffunc F((Element of c),(Element of c)) = ( MSS_morph ($1,$2) );
consider M being (ManySortedSet of [: c,c :]) such that A1: (for i,j being (Element of c) holds ( M . (i,j) ) = F(i,j)) from ALTCAT_1:sch 2;
defpred P[ set,set,set ]
 means
(ex i,j,k being (Element of ( MSS_set A )) st ($3 = [ i,j,k ] & (for f1,f2,g1,g2 being Function holds ((([ f1,f2 ] in ( M . (i,j) ) & [ g1,g2 ] in ( M . (j,k) )) & $2 = [ [ g1,g2 ],[ f1,f2 ] ]) implies $1 = [ ( g1 * f1 ),( g2 * f2 ) ]))));
A2: (for ijk being set holds (ijk in [: c,c,c :] implies (for x being set holds (x in ( {| M,M |} . ijk ) implies (ex y being set st (y in ( {| M |} . ijk ) & P[ y,x,ijk ]))))))
proof
let ijk being set;
assume ijk in [: c,c,c :];
then consider x1,x2,x3 being set such that A3: ((x1 in c & x2 in c) & x3 in c) and A4: ijk = [ x1,x2,x3 ] by MCART_1:68;
reconsider x1,x2,x3 as (Element of c) by A3;
let x being set;
A5: (( {| M,M |} . (x1,x2,x3) ) = ( {| M,M |} . [ x1,x2,x3 ] ) & ( {| M,M |} . (x1,x2,x3) ) = [: ( M . (x2,x3) ),( M . (x1,x2) ) :]) by ALTCAT_1:def 4,MULTOP_1:def 1;
A6: ( {| M |} . ijk ) = ( {| M |} . (x1,x2,x3) ) by A4,MULTOP_1:def 1;
assume A7: x in ( {| M,M |} . ijk );
then ( x `1 ) in ( M . (x2,x3) ) by A4,A5,MCART_1:10;
then ( x `1 ) in ( MSS_morph (x2,x3) ) by A1;
then consider g1,g2 being Function such that A8: ( x `1 ) = [ g1,g2 ] and A9: g1,g2 form_morphism_between x2,x3 by MSALIMIT:def 10;
( x `2 ) in ( M . (x1,x2) ) by A4,A7,A5,MCART_1:10;
then ( x `2 ) in ( MSS_morph (x1,x2) ) by A1;
then consider f1,f2 being Function such that A10: ( x `2 ) = [ f1,f2 ] and A11: f1,f2 form_morphism_between x1,x2 by MSALIMIT:def 10;
take y = [ ( g1 * f1 ),( g2 * f2 ) ];
( g1 * f1 ),( g2 * f2 ) form_morphism_between x1,x3 by A11,A9,PUA2MSS1:29;
then (( {| M |} . (x1,x2,x3) ) = ( M . (x1,x3) ) & y in ( MSS_morph (x1,x3) )) by ALTCAT_1:def 3,MSALIMIT:def 10;
hence y in ( {| M |} . ijk ) by A1,A6;
take x1;
take x2;
take x3;
thus ijk = [ x1,x2,x3 ] by A4;
let F1 being Function;
let F2 being Function;
let G1 being Function;
let G2 being Function;
assume that
[ F1,F2 ] in ( M . (x1,x2) )
and
[ G1,G2 ] in ( M . (x2,x3) )
and
A12: x = [ [ G1,G2 ],[ F1,F2 ] ];
( x `1 ) = [ G1,G2 ] by A12,MCART_1:7;
then A13: (G1 = g1 & G2 = g2) by A8,ZFMISC_1:27;
A14: ( x `2 ) = [ F1,F2 ] by A12,MCART_1:7;
then F1 = f1 by A10,ZFMISC_1:27;
hence thesis by A10,A14,A13,ZFMISC_1:27;
end;
consider F being (ManySortedFunction of {| M,M |},{| M |}) such that A15: (for ijk being set holds (ijk in [: c,c,c :] implies (ex f being (Function of ( {| M,M |} . ijk ),( {| M |} . ijk )) st (f = ( F . ijk ) & (for x being set holds (x in ( {| M,M |} . ijk ) implies P[ ( f . x ),x,ijk ])))))) from MSSUBFAM:sch 1(A2);
take EX = AltCatStr (# c,M,F #);
reconsider EX as non  empty AltCatStr;
(for i,j,k being (object of EX) holds (((i in ( MSS_set A ) & j in ( MSS_set A )) & k in ( MSS_set A )) implies (for f1,f2,g1,g2 being Function holds (([ f1,f2 ] in ( (the Arrows of EX) . (i,j) ) & [ g1,g2 ] in ( (the Arrows of EX) . (j,k) )) implies ( ( (the Comp of EX) . (i,j,k) ) . ([ g1,g2 ],[ f1,f2 ]) ) = [ ( g1 * f1 ),( g2 * f2 ) ]))))
proof
let i being (object of EX);
let j being (object of EX);
let k being (object of EX);
assume that
i in ( MSS_set A )
and
j in ( MSS_set A )
and
k in ( MSS_set A );
let f1 being Function;
let f2 being Function;
let g1 being Function;
let g2 being Function;
assume A16: ([ f1,f2 ] in ( (the Arrows of EX) . (i,j) ) & [ g1,g2 ] in ( (the Arrows of EX) . (j,k) ));
set x = [ [ g1,g2 ],[ f1,f2 ] ];
set ijk = [ i,j,k ];
ijk in [: c,c,c :] by MCART_1:69;
then consider f being (Function of ( {| M,M |} . ijk ),( {| M |} . ijk )) such that A17: f = ( F . ijk ) and A18: (for x being set holds (x in ( {| M,M |} . ijk ) implies P[ ( f . x ),x,ijk ])) by A15;
A19: f = ( (the Comp of EX) . (i,j,k) ) by A17,MULTOP_1:def 1;
(( {| M,M |} . (i,j,k) ) = ( {| M,M |} . [ i,j,k ] ) & ( {| M,M |} . (i,j,k) ) = [: ( M . (j,k) ),( M . (i,j) ) :]) by ALTCAT_1:def 4,MULTOP_1:def 1;
then x in ( {| M,M |} . ijk ) by A16,ZFMISC_1:87;
then consider I,J,K being (Element of ( MSS_set A )) such that A20: ijk = [ I,J,K ] and A21: (for f1,f2,g1,g2 being Function holds ((([ f1,f2 ] in ( M . (I,J) ) & [ g1,g2 ] in ( M . (J,K) )) & x = [ [ g1,g2 ],[ f1,f2 ] ]) implies ( f . x ) = [ ( g1 * f1 ),( g2 * f2 ) ])) by A18;
A22: K = k by A20,MCART_1:25;
(I = i & J = j) by A20,MCART_1:25;
hence thesis by A16,A21,A22,A19;
end;
hence thesis by A1;
end;
uniqueness
proof
set c = ( MSS_set A );
let A1 being non  empty  strict AltCatStr;
let A2 being non  empty  strict AltCatStr;
assume that
A23: (the carrier of A1) = ( MSS_set A )
and
A24: (for i,j being (Element of ( MSS_set A )) holds ( (the Arrows of A1) . (i,j) ) = ( MSS_morph (i,j) ))
and
A25: (for i,j,k being (object of A1) holds (((i in ( MSS_set A ) & j in ( MSS_set A )) & k in ( MSS_set A )) implies (for f1,f2,g1,g2 being Function holds (([ f1,f2 ] in ( (the Arrows of A1) . (i,j) ) & [ g1,g2 ] in ( (the Arrows of A1) . (j,k) )) implies ( ( (the Comp of A1) . (i,j,k) ) . ([ g1,g2 ],[ f1,f2 ]) ) = [ ( g1 * f1 ),( g2 * f2 ) ]))))
and
A26: (the carrier of A2) = ( MSS_set A )
and
A27: (for i,j being (Element of ( MSS_set A )) holds ( (the Arrows of A2) . (i,j) ) = ( MSS_morph (i,j) ))
and
A28: (for i,j,k being (object of A2) holds (((i in ( MSS_set A ) & j in ( MSS_set A )) & k in ( MSS_set A )) implies (for f1,f2,g1,g2 being Function holds (([ f1,f2 ] in ( (the Arrows of A2) . (i,j) ) & [ g1,g2 ] in ( (the Arrows of A2) . (j,k) )) implies ( ( (the Comp of A2) . (i,j,k) ) . ([ g1,g2 ],[ f1,f2 ]) ) = [ ( g1 * f1 ),( g2 * f2 ) ]))));
reconsider AA2 = (the Arrows of A2) as (ManySortedSet of [: c,c :]) by A26;
reconsider AA1 = (the Arrows of A1) as (ManySortedSet of [: c,c :]) by A23;
reconsider CC1 = (the Comp of A1),CC2 = (the Comp of A2) as (ManySortedSet of [: c,c,c :]) by A23,A26;
A29:now
let i being (Element of ( MSS_set A ));
let j being (Element of ( MSS_set A ));
thus ( AA1 . (i,j) ) = ( MSS_morph (i,j) ) by A24
.= ( AA2 . (i,j) ) by A27;
end;
then A30: AA1 = AA2 by ALTCAT_1:7;
now
let i being set;
let j being set;
let k being set;
set ijk = [ i,j,k ];
A31: ( CC1 . (i,j,k) ) = ( CC1 . [ i,j,k ] ) by MULTOP_1:def 1;
assume A32: ((i in ( MSS_set A ) & j in ( MSS_set A )) & k in ( MSS_set A ));
then reconsider i9 = i,j9 = j,k9 = k as (Element of c);
reconsider I9 = i,J9 = j,K9 = k as (Element of A2) by A26,A32;
reconsider I = i,J = j,K = k as (Element of A1) by A23,A32;
A33: ijk in [: c,c,c :] by A32,MCART_1:69;
A34: ( CC2 . (i,j,k) ) = ( CC2 . [ i,j,k ] ) by MULTOP_1:def 1;
thus ( CC1 . (i,j,k) ) = ( CC2 . (i,j,k) )
proof
reconsider Cj = ( CC2 . ijk ) as (Function of ( {| AA2,AA2 |} . ijk ),( {| AA2 |} . ijk )) by A26,A33,PBOOLE:def 15;
reconsider Ci = ( CC1 . ijk ) as (Function of ( {| AA1,AA1 |} . ijk ),( {| AA1 |} . ijk )) by A23,A33,PBOOLE:def 15;
per cases ;
suppose A35: ( {| AA1 |} . ijk ) <> ( {} );

A36: (for x being set holds (x in ( {| AA1,AA1 |} . ijk ) implies ( Ci . x ) = ( Cj . x )))
proof
let x being set;
assume A37: x in ( {| AA1,AA1 |} . ijk );
then x in ( {| AA1,AA1 |} . (i,j,k) ) by MULTOP_1:def 1;
then A38: x in [: ( AA1 . (j,k) ),( AA1 . (i,j) ) :] by A32,ALTCAT_1:def 4;
then A39: ( x `1 ) in ( AA1 . (j,k) ) by MCART_1:10;
then ( x `1 ) in ( MSS_morph (j9,k9) ) by A24;
then consider g1,g2 being Function such that A40: ( x `1 ) = [ g1,g2 ] and g1,g2 form_morphism_between j9,k9 by MSALIMIT:def 10;
x in ( {| AA2,AA2 |} . (i,j,k) ) by A30,A37,MULTOP_1:def 1;
then x in [: ( AA2 . (j,k) ),( AA2 . (i,j) ) :] by A32,ALTCAT_1:def 4;
then A41: (( x `1 ) in ( AA2 . (j,k) ) & ( x `2 ) in ( AA2 . (i,j) )) by MCART_1:10;
A42: ( x `2 ) in ( AA1 . (i,j) ) by A38,MCART_1:10;
then ( x `2 ) in ( MSS_morph (i9,j9) ) by A24;
then consider f1,f2 being Function such that A43: ( x `2 ) = [ f1,f2 ] and f1,f2 form_morphism_between i9,j9 by MSALIMIT:def 10;
A44: x = [ [ g1,g2 ],[ f1,f2 ] ] by A38,A40,A43,MCART_1:21;
then ( Ci . x ) = ( ( (the Comp of A1) . (I,J,K) ) . ([ g1,g2 ],[ f1,f2 ]) ) by MULTOP_1:def 1
.= [ ( g1 * f1 ),( g2 * f2 ) ] by A23,A25,A39,A42,A40,A43
.= ( ( (the Comp of A2) . (I9,J9,K9) ) . ([ g1,g2 ],[ f1,f2 ]) ) by A26,A28,A41,A40,A43
.= ( Cj . x ) by A44,MULTOP_1:def 1;
hence thesis;
end;
( {| AA2 |} . ijk ) <> ( {} ) by A29,A35,ALTCAT_1:7;
then A45: ( dom Cj ) = ( {| AA2,AA2 |} . ijk ) by FUNCT_2:def 1;
( dom Ci ) = ( {| AA1,AA1 |} . ijk ) by A35,FUNCT_2:def 1;
hence thesis by A30,A31,A34,A45,A36,FUNCT_1:2;
end;
suppose ( {| AA1 |} . ijk ) = ( {} );

then (Ci = ( {} ) & Cj = ( {} )) by A30;
hence thesis by A31,MULTOP_1:def 1;
end;
end;

end;
hence thesis by A23,A26,A30,ALTCAT_1:8;
end;
end;
