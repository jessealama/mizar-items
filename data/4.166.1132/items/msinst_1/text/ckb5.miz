environ
vocabularies XBOOLE_0,STRUCT_0,MSUALG_1,ALTCAT_1,MSALIMIT,SUBSET_1,FUNCT_1,CAT_1,RELAT_1,PBOOLE,ZFMISC_1,MCART_1,PUA2MSS1,RELAT_2,BINOP_1,TARSKI,MSUALG_6,FUNCT_2,PARTFUN1,NUMBERS,CARD_3,FUNCOP_1,PZFMISC1,MARGREL1,MEMBER_1,FUNCT_6,FINSEQ_4,MSUALG_3,MSINST_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,MCART_1,RELAT_1,FUNCT_1,STRUCT_0,FUNCT_2,MCART_2,RELSET_1,PARTFUN1,FINSEQ_2,CARD_3,BINOP_1,MULTOP_1,FUNCT_6,FUNCOP_1,PBOOLE,PZFMISC1,PRALG_1,MSUALG_1,MSUALG_3,ALTCAT_1,PRALG_2,PUA2MSS1,MSUALG_6,MSALIMIT,CKB1;
definitions ALTCAT_1,MSUALG_3,PBOOLE,TARSKI,XBOOLE_0,BINOP_1,CKB1;
theorems XBOOLE_0,ALTCAT_1,ALTCAT_2,AUTALG_1,CARD_3,CLOSURE1,FUNCOP_1,FUNCT_1,FUNCT_2,FUNCT_6,FUNCTOR0,MCART_1,MCART_2,MSSUBFAM,MSUALG_1,MSUALG_3,MSUALG_6,MSALIMIT,MULTOP_1,PARTFUN1,PBOOLE,PRALG_2,PUA2MSS1,RELAT_1,TARSKI,ZFMISC_1,PRALG_1,XBOOLE_1,PZFMISC1,FINSEQ_2,CKB1,CKB3;
schemes ALTCAT_1,MSSUBFAM,TARSKI;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,RELSET_1,FUNCOP_1,RELAT_1,STRUCT_0,MSUALG_1,ALTCAT_1,MSUALG_6,MSALIMIT,MSSUBFAM,PBOOLE,CKB2,CKB4;
constructors MCART_2,PZFMISC1,MSUALG_3,ALTCAT_1,PUA2MSS1,CLOSURE1,MSUALG_6,MSALIMIT,RELSET_1,CKB1;
requirements SUBSET,BOOLE;
begin
reserve A for non  empty set;
reserve S for non  void non  empty ManySortedSign;
reserve x for set;
definition
let S;
let A;
func MSAlg_set (S,A) means 
:Def2: (x in it iff (ex M being  strict  feasible MSAlgebra over S st (x = M & (for C being (Component of (the Sorts of M)) holds C c= A))));
existence
proof
defpred P[ set,set ]
 means
(ex M being  strict  feasible MSAlgebra over S st (M = $2 & $1 = [ (the Sorts of M),(the Charact of M) ]));
A1: (for x,y,z being set holds ((P[ x,y ] & P[ x,z ]) implies y = z))
proof
let x being set;
let y being set;
let z being set;
given M being  strict  feasible MSAlgebra over S such that
A2: M = y
and
A3: x = [ (the Sorts of M),(the Charact of M) ];

given N being  strict  feasible MSAlgebra over S such that
A4: N = z
and
A5: x = [ (the Sorts of N),(the Charact of N) ];

(the Sorts of M) = (the Sorts of N) by A3,A5,ZFMISC_1:27;
hence thesis by A2,A3,A4,A5,ZFMISC_1:27;
end;
consider X being set such that A6: (x in X iff (ex y being set st (y in [: ( Funcs ((the carrier of S),( bool A )) ),( Funcs ((the carrier' of S),( PFuncs (( PFuncs (( NAT ),A) ),A) )) ) :] & P[ y,x ]))) from TARSKI:sch 1(A1);
take X;
thus (x in X iff (ex M being  strict  feasible MSAlgebra over S st (x = M & (for C being (Component of (the Sorts of M)) holds C c= A))))
proof
hereby
assume x in X;
then consider y being set such that A7: y in [: ( Funcs ((the carrier of S),( bool A )) ),( Funcs ((the carrier' of S),( PFuncs (( PFuncs (( NAT ),A) ),A) )) ) :] and A8: P[ y,x ] by A6;
consider M being  strict  feasible MSAlgebra over S such that A9: M = x and y = [ (the Sorts of M),(the Charact of M) ] by A8;
take M;
thus x = M by A9;
thus (for C being (Component of (the Sorts of M)) holds C c= A)
proof
let C being (Component of (the Sorts of M));
consider y1 being set such that y1 in ( dom (the Sorts of M) ) and A10: C = ( (the Sorts of M) . y1 ) by FUNCT_1:def 3;
(the Sorts of M) in ( Funcs ((the carrier of S),( bool A )) ) by A7,A8,A9,ZFMISC_1:87;
then consider f being Function such that A11: (the Sorts of M) = f and ( dom f ) = (the carrier of S) and A12: ( rng f ) c= ( bool A ) by FUNCT_2:def 2;
( f . y1 ) in ( rng f ) by A10,A11;
hence thesis by A10,A11,A12;
end;

end;
given M being  strict  feasible MSAlgebra over S such that
A13: x = M
and
A14: (for C being (Component of (the Sorts of M)) holds C c= A);

A15: ( dom (the Sorts of M) ) = (the carrier of S) by PARTFUN1:def 2;
then reconsider SM = (the Sorts of M) as (Function of (the carrier of S),( rng (the Sorts of M) )) by FUNCT_2:1;
A16: ( rng (the Sorts of M) ) c= ( bool A )
proof
let x being set;
assume x in ( rng (the Sorts of M) );
then reconsider x9 = x as (Component of (the Sorts of M));
x9 c= A by A14;
hence thesis;
end;
then reconsider SM9 = SM as (Function of (the carrier of S),( bool A )) by FUNCT_2:6;
consider y being set such that A17: y = [ (the Sorts of M),(the Charact of M) ];
A18: ( dom (the Charact of M) ) = (the carrier' of S) by PARTFUN1:def 2;
( rng (the Charact of M) ) c= ( PFuncs (( PFuncs (( NAT ),A) ),A) )
proof
reconsider SA = ( ( (the Sorts of M) # ) * (the Arity of S) ),SR = ( (the Sorts of M) * (the ResultSort of S) ) as (ManySortedSet of (the carrier' of S));
let x being set;
reconsider CM = (the Charact of M) as (ManySortedFunction of SA,SR);
assume x in ( rng (the Charact of M) );
then consider x1 being set such that A19: x1 in ( dom (the Charact of M) ) and A20: x = ( (the Charact of M) . x1 ) by FUNCT_1:def 3;
reconsider Cm = ( CM . x1 ) as (Function of ( SA . x1 ),( SR . x1 )) by A18,A19,PBOOLE:def 15;
A21: x1 in (the carrier' of S) by A19,PARTFUN1:def 2;
A22: x1 in ( dom SA ) by A18,A19,PARTFUN1:def 2;
( SA . x1 ) c= ( PFuncs (( NAT ),A) )
proof
reconsider AX = ( (the Arity of S) . x1 ) as (Element of ( (the carrier of S) * )) by A21,FUNCT_2:5;
let a being set;
assume a in ( SA . x1 );
then A23: a in ( ( (the Sorts of M) # ) . ( (the Arity of S) . x1 ) ) by A22,FUNCT_1:12;
( ( (the Sorts of M) # ) . AX ) = ( product ( (the Sorts of M) * AX ) ) by FINSEQ_2:def 5;
then A24: (ex g being Function st ((a = g & ( dom g ) = ( dom ( (the Sorts of M) * AX ) )) & (for x2 being set holds (x2 in ( dom ( (the Sorts of M) * AX ) ) implies ( g . x2 ) in ( ( (the Sorts of M) * AX ) . x2 ))))) by A23,CARD_3:def 5;
then reconsider a9 = a as Function;
( rng AX ) c= ( dom (the Sorts of M) ) by A15;
then A25: ( dom a9 ) = ( dom AX ) by A24,RELAT_1:27;
( rng a9 ) c= A
proof
( rng (the Sorts of M) ) c= ( bool A )
proof
let w being set;
assume w in ( rng (the Sorts of M) );
then reconsider w9 = w as (Component of (the Sorts of M));
w9 c= A by A14;
hence thesis;
end;
then A26: ( union ( rng (the Sorts of M) ) ) c= ( union ( bool A ) ) by ZFMISC_1:77;
let r being set;
assume r in ( rng a9 );
then consider r1 being set such that A27: r1 in ( dom a9 ) and A28: r = ( a9 . r1 ) by FUNCT_1:def 3;
( AX . r1 ) in ( rng AX ) by A25,A27,FUNCT_1:def 3;
then A29: ( (the Sorts of M) . ( AX . r1 ) ) in ( rng (the Sorts of M) ) by A15,FUNCT_1:def 3;
r in ( ( (the Sorts of M) * AX ) . r1 ) by A24,A27,A28;
then r in ( (the Sorts of M) . ( AX . r1 ) ) by A25,A27,FUNCT_1:13;
then r in ( union ( rng (the Sorts of M) ) ) by A29,TARSKI:def 4;
then r in ( union ( bool A ) ) by A26;
hence thesis by ZFMISC_1:81;
end;
hence thesis by A25,PARTFUN1:def 3;
end;
then A30: ( dom Cm ) c= ( PFuncs (( NAT ),A) ) by XBOOLE_1:1;
x1 in ( dom SR ) by A18,A19,PARTFUN1:def 2;
then A31: ( SR . x1 ) = ( (the Sorts of M) . ( (the ResultSort of S) . x1 ) ) by FUNCT_1:12;
( (the ResultSort of S) . x1 ) in (the carrier of S) by A18,A19,FUNCT_2:5;
then ( SR . x1 ) in ( rng (the Sorts of M) ) by A15,A31,FUNCT_1:def 3;
then ( rng Cm ) c= A by A16,XBOOLE_1:1;
hence thesis by A20,A30,PARTFUN1:def 3;
end;
then (SM9 in ( Funcs ((the carrier of S),( bool A )) ) & (the Charact of M) in ( Funcs ((the carrier' of S),( PFuncs (( PFuncs (( NAT ),A) ),A) )) )) by A18,FUNCT_2:8,FUNCT_2:def 2;
then y in [: ( Funcs ((the carrier of S),( bool A )) ),( Funcs ((the carrier' of S),( PFuncs (( PFuncs (( NAT ),A) ),A) )) ) :] by A17,ZFMISC_1:87;
hence thesis by A6,A13,A17;
end;

end;
uniqueness
proof
let A1 being set;
let A2 being set;
assume A32: (x in A1 iff (ex M being  strict  feasible MSAlgebra over S st (x = M & (for C being (Component of (the Sorts of M)) holds C c= A))));
assume A33: (x in A2 iff (ex N being  strict  feasible MSAlgebra over S st (x = N & (for C being (Component of (the Sorts of N)) holds C c= A))));
A34: A2 c= A1
proof
let a being set;
assume a in A2;
then (ex M being  strict  feasible MSAlgebra over S st (a = M & (for C being (Component of (the Sorts of M)) holds C c= A))) by A33;
hence thesis by A32;
end;
A1 c= A2
proof
let a being set;
assume a in A1;
then (ex M being  strict  feasible MSAlgebra over S st (a = M & (for C being (Component of (the Sorts of M)) holds C c= A))) by A32;
hence thesis by A33;
end;
hence A1 = A2 by A34,XBOOLE_0:def 10;
end;
end;
