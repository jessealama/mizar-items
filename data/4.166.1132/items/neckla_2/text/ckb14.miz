environ
vocabularies NUMBERS,CLASSES2,RELAT_1,ZFMISC_1,ORDERS_2,NECKLACE,CARD_1,ARYTM_3,SUBSET_1,XBOOLE_0,TARSKI,XXREAL_0,ORDINAL1,FINSET_1,CLASSES1,STRUCT_0,FUNCT_1,SETFAM_1,NAT_1,CARD_3,NECKLA_2;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,ZFMISC_1,RELSET_1,PARTIT_2,FINSET_1,CARD_1,ORDINAL1,NUMBERS,CLASSES2,SETFAM_1,CLASSES1,CARD_3,XXREAL_0,NAT_1,RELAT_1,FUNCT_1,FUNCT_2,STRUCT_0,ORDERS_2,NECKLACE,CKB6,CKB8,CKB9,CKB10,CKB12;
definitions TARSKI,CKB6,CKB8,CKB9,CKB10,CKB12;
theorems FUNCT_1,FUNCT_2,ENUMSET1,RELSET_1,ZFMISC_1,XBOOLE_1,TARSKI,ORDINAL1,PARTFUN1,NECKLACE,CLASSES2,CLASSES1,XBOOLE_0,SETFAM_1,CARD_5,NAT_1,STRUCT_0,RELAT_1,CARD_2,SUBSET_1,CARD_3,REALSET1,XREAL_1,XXREAL_0,CKB1,CKB2,CKB4,CKB6,CKB8,CKB9,CKB10,CKB12;
schemes TARSKI,XBOOLE_0,NAT_1;
registrations XBOOLE_0,SUBSET_1,ORDINAL1,RELSET_1,FINSET_1,XREAL_0,NAT_1,CLASSES2,STRUCT_0,ORDERS_2,YELLOW_0,CARD_1,CLASSES1,CKB3,CKB5,CKB7,CKB11,CKB13;
constructors SQUARE_1,NAT_1,CARD_3,CLASSES2,REALSET2,COH_SP,NECKLACE,RELSET_1,PARTIT_2,STRUCT_0,CKB6,CKB8,CKB9,CKB10,CKB12;
requirements BOOLE,SUBSET,REAL,NUMERALS,ARITHM;
begin
theorem
Th4: (for X being set holds (X in ( fin_RelStr_sp ) implies X is  finite  strict non  empty  finite  strict non  empty RelStr))
proof
let X being set;
assume A1: X in ( fin_RelStr_sp );
then A2: (ex R being  strict RelStr st (X = R & (the carrier of R) in ( FinSETS ))) by CKB10:def 1;
then reconsider R = X as  strict RelStr;
now
set M = ( ( fin_RelStr_sp ) \ { R } );
set F = ( fin_RelStr_sp );
reconsider M as (Subset of ( fin_RelStr ));
A3: R in { R } by TARSKI:def 1;
assume A4: R is  empty;
A5:now
let H1 being  strict RelStr;
let H2 being  strict RelStr;
assume that
A6: (the carrier of H1) misses (the carrier of H2)
and
A7: H1 in M
and
A8: H2 in M;
A9: H2 in F by A8,XBOOLE_0:def 5;
A10: (not H1 in { R }) by A7,XBOOLE_0:def 5;
(the carrier of H1) <> ( {} )
proof
per cases  by A10,TARSKI:def 1;
suppose (the carrier of H1) <> (the carrier of R);

hence thesis by A4;
end;
suppose A11: (the InternalRel of H1) <> (the InternalRel of R);

set InterH1 = (the InternalRel of H1);
InterH1 <> ( {} ) by A4,A11;
hence thesis;
end;
end;
then reconsider A = (the carrier of H1) as non  empty set;
( A \/ (the carrier of H2) ) <> ( {} );
then ( union_of (H1,H2) ) <> R by A4,CKB8:def 1;
then A12: (not ( union_of (H1,H2) ) in { R }) by TARSKI:def 1;
(the carrier of ( sum_of (H1,H2) )) = ( A \/ (the carrier of H2) ) by CKB9:def 1;
then A13: (not ( sum_of (H1,H2) ) in { R }) by A4,TARSKI:def 1;
A14: H1 in F by A7,XBOOLE_0:def 5;
then ( union_of (H1,H2) ) in F by A6,A9,CKB12:def 1;
hence ( union_of (H1,H2) ) in M by A12,XBOOLE_0:def 5;
( sum_of (H1,H2) ) in F by A6,A14,A9,CKB12:def 1;
hence ( sum_of (H1,H2) ) in M by A13,XBOOLE_0:def 5;
end;
now
let S being  strict RelStr;
assume that
A15: (the carrier of S) is 1 -element
and
A16: (the carrier of S) in ( FinSETS );
A17: (not S in { R }) by A4,A15,TARSKI:def 1;
S in F by A15,A16,CKB12:def 1;
hence S in M by A17,XBOOLE_0:def 5;
end;
then F c= M by A5,CKB12:def 1;
hence contradiction by A1,A3,XBOOLE_0:def 5;
end;
hence thesis by A2;
end;
