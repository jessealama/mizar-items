environ
vocabularies NUMBERS,CLASSES2,RELAT_1,ZFMISC_1,ORDERS_2,NECKLACE,CARD_1,ARYTM_3,SUBSET_1,XBOOLE_0,TARSKI,XXREAL_0,ORDINAL1,FINSET_1,CLASSES1,STRUCT_0,FUNCT_1,SETFAM_1,NAT_1,CARD_3,NECKLA_2;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,ZFMISC_1,RELSET_1,PARTIT_2,FINSET_1,CARD_1,ORDINAL1,NUMBERS,CLASSES2,SETFAM_1,CLASSES1,CARD_3,XXREAL_0,NAT_1,RELAT_1,FUNCT_1,FUNCT_2,STRUCT_0,ORDERS_2,NECKLACE,CKB6,CKB8,CKB9;
definitions TARSKI,CKB6,CKB8,CKB9;
theorems FUNCT_1,FUNCT_2,ENUMSET1,RELSET_1,ZFMISC_1,XBOOLE_1,TARSKI,ORDINAL1,PARTFUN1,NECKLACE,CLASSES2,CLASSES1,XBOOLE_0,SETFAM_1,CARD_5,NAT_1,STRUCT_0,RELAT_1,CARD_2,SUBSET_1,CARD_3,REALSET1,XREAL_1,XXREAL_0,CKB1,CKB2,CKB4,CKB6,CKB8,CKB9;
schemes TARSKI,XBOOLE_0,NAT_1;
registrations XBOOLE_0,SUBSET_1,ORDINAL1,RELSET_1,FINSET_1,XREAL_0,NAT_1,CLASSES2,STRUCT_0,ORDERS_2,YELLOW_0,CARD_1,CLASSES1,CKB3,CKB5,CKB7;
constructors SQUARE_1,NAT_1,CARD_3,CLASSES2,REALSET2,COH_SP,NECKLACE,RELSET_1,PARTIT_2,STRUCT_0,CKB6,CKB8,CKB9;
requirements BOOLE,SUBSET,REAL,NUMERALS,ARITHM;
begin
definition
func fin_RelStr
means
:Def4: (for X being set holds (X in it iff (ex R being  strict RelStr st (X = R & (the carrier of R) in ( FinSETS )))));
existence
proof
defpred P[ set,set ]
 means
(ex R being  strict RelStr st ($1 = [ (the carrier of R),(the InternalRel of R) ] & $2 = R));
A1: (for x,y,z being set holds ((P[ x,y ] & P[ x,z ]) implies y = z))
proof
let x being set,y being set,z being set;
given R1 being  strict RelStr such that
A2: x = [ (the carrier of R1),(the InternalRel of R1) ]
and
A3: y = R1;

given R2 being  strict RelStr such that
A4: x = [ (the carrier of R2),(the InternalRel of R2) ]
and
A5: z = R2;

(the carrier of R1) = (the carrier of R2) by A2,A4,ZFMISC_1:27;
hence thesis by A2,A3,A4,A5,ZFMISC_1:27;
end;
consider X being set such that A6: (for x being set holds (x in X iff (ex y being set st (y in ( FinSETS ) & P[ y,x ])))) from TARSKI:sch 1(A1);
take X;
(for x being set holds (x in X iff (ex R being  strict RelStr st (x = R & (the carrier of R) in ( FinSETS )))))
proof
let x being set;
thus (x in X implies (ex R being  strict RelStr st (x = R & (the carrier of R) in ( FinSETS ))))
proof
assume x in X;
then consider y being set such that A7: y in ( FinSETS ) and A8: (ex R being  strict RelStr st (y = [ (the carrier of R),(the InternalRel of R) ] & x = R)) by A6;
consider R being  strict RelStr such that A9: y = [ (the carrier of R),(the InternalRel of R) ] and A10: x = R by A8;
A11: { (the carrier of R) } in { { (the carrier of R),(the InternalRel of R) },{ (the carrier of R) } } by TARSKI:def 2;
{ { (the carrier of R),(the InternalRel of R) },{ (the carrier of R) } } c= ( FinSETS ) by A7,A9,ORDINAL1:def 2;
then A12: { (the carrier of R) } c= ( FinSETS ) by A11,ORDINAL1:def 2;
(the carrier of R) in { (the carrier of R) } by TARSKI:def 1;
hence thesis by A10,A12;
end;

given R being  strict RelStr such that
A13: x = R
and
A14: (the carrier of R) in ( FinSETS );

consider R being  strict RelStr such that A15: x = R and A16: (the carrier of R) in ( FinSETS ) by A13,A14;
(the InternalRel of R) in ( FinSETS ) by A16,CKB1:1;
then [ (the carrier of R),(the InternalRel of R) ] in ( FinSETS ) by A16,CLASSES2:58;
hence thesis by A6,A15;
end;
hence thesis;
end;
uniqueness
proof
defpred P[ set ]
 means
(ex R being  strict RelStr st ($1 = R & (the carrier of R) in ( FinSETS )));
thus (for X1,X2 being set holds (((for x being set holds (x in X1 iff P[ x ])) & (for x being set holds (x in X2 iff P[ x ]))) implies X1 = X2)) from XBOOLE_0:sch 3;
end;
end;
