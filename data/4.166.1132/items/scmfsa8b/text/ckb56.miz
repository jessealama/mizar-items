environ
vocabularies NUMBERS,SCMFSA_2,AMI_1,AMISTD_2,CARD_1,TARSKI,TURING_1,SCMFSA6A,FUNCT_4,FSM_1,RELAT_1,UNIALG_2,CIRCUIT2,FUNCT_1,SF_MASTR,SUBSET_1,ARYTM_3,SCMFSA7B,SCMFSA6B,SCMFSA6C,AMI_3,SCMFSA8A,NAT_1,GRAPHSP,XXREAL_0,MSUALG_1,STRUCT_0,ARYTM_1,INT_1,COMPLEX1,PARTFUN1,FINSEQ_1,FINSEQ_2,SCMFSA8B,ORDINAL1,SCMNORM,RELOC,PBOOLE,FUNCOP_1,XBOOLE_0,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCOP_1,FUNCT_4,PBOOLE,FUNCT_7,FINSEQ_1,FINSEQ_2,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,INT_2,XXREAL_0,CKB12,CKB13,CKB14,CKB40,CKB41,CKB47;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,STRUCT_0,SCMFSA6A,MEMSTR_0,CKB12,CKB13,CKB14,CKB40,CKB41;
theorems TARSKI,NAT_1,FUNCT_1,FUNCT_4,SCMFSA_2,MEMSTR_0,SCMFSA6A,GRFUNC_1,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,RELAT_1,XBOOLE_1,XREAL_1,ORDINAL1,FUNCOP_1,XXREAL_0,PARTFUN1,AFINSQ_1,SCMFSA10,COMPOS_1,EXTPRO_1,AMISTD_2,PBOOLE,AMISTD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB40,CKB41,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55;
schemes NAT_1;
registrations SETFAM_1,FUNCT_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SF_MASTR,SCMFSA6A,SCMFSA6B,SCMFSA6C,ORDINAL1,MEMSTR_0,XBOOLE_0,FINSET_1,RELSET_1,SCMFSA10,AMISTD_2,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,FUNCOP_1,AMISTD_1,RELAT_1,STRUCT_0,CKB38,CKB39,CKB42,CKB43,CKB44,CKB45,CKB46,CKB48,CKB49;
constructors DOMAIN_1,XXREAL_0,NAT_1,INT_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,AMISTD_2,RELSET_1,SCMFSA7B,PRE_POLY,AMISTD_1,PBOOLE,FUNCOP_1,FUNCT_4,MEMSTR_0,CKB12,CKB13,CKB14,CKB40,CKB41;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve P1 for (Instruction-Sequence of ( SCM+FSA ));
reserve P2 for (Instruction-Sequence of ( SCM+FSA ));
theorem
Th41: (for s1,s2 being (State of ( SCM+FSA )) holds (for I being (Program of ( SCM+FSA )) holds (for a being Int-Location holds ((((((for d being  read-write Int-Location holds (a <> d implies ( s1 . d ) = ( s2 . d ))) & (for f being FinSeq-Location holds ( s1 . f ) = ( s2 . f ))) & (not I refer a)) & I is_closed_on ( Initialized s1 ),P1) & I is_halting_on ( Initialized s1 ),P1) implies (((for d being Int-Location holds (a <> d implies ( ( IExec (I,P1,s1) ) . d ) = ( ( IExec (I,P2,s2) ) . d ))) & (for f being FinSeq-Location holds ( ( IExec (I,P1,s1) ) . f ) = ( ( IExec (I,P2,s2) ) . f ))) & ( IC ( IExec (I,P1,s1) ) ) = ( IC ( IExec (I,P2,s2) ) ))))))
proof
let s1 being (State of ( SCM+FSA ));
let s2 being (State of ( SCM+FSA ));
let I being (Program of ( SCM+FSA ));
let a being Int-Location;
assume that
A2: (for d being  read-write Int-Location holds (a <> d implies ( s1 . d ) = ( s2 . d )))
and
A3: (for f being FinSeq-Location holds ( s1 . f ) = ( s2 . f ));
A4:now
let d being Int-Location;
assume A5: a <> d;
per cases ;
suppose A6: d = ( intloc ( 0 ) );

hence ( ( Initialized s1 ) . d ) = 1 by SCMFSA6A:38
.= ( ( Initialized s2 ) . d ) by A6,SCMFSA6A:38;
end;
suppose d <> ( intloc ( 0 ) );

then A7: d is  read-write by SF_MASTR:def 5;
hence ( ( Initialized s1 ) . d ) = ( s1 . d ) by SCMFSA6C:3
.= ( s2 . d ) by A2,A5,A7
.= ( ( Initialized s2 ) . d ) by A7,SCMFSA6C:3;
end;
end;
set S1 = ( Initialized s1 );
set Q1 = ( P1 +* I );
set S2 = ( Initialized s2 );
set Q2 = ( P2 +* I );
assume A8: (not I refer a);
A9: S2 = ( Initialize ( Initialized s2 ) ) by MEMSTR_0:44;
assume that
A10: I is_closed_on ( Initialized s1 ),P1
and
A11: I is_halting_on ( Initialized s1 ),P1;
A12:now
let f being FinSeq-Location;
thus ( ( Initialized s1 ) . f ) = ( s1 . f ) by SCMFSA6C:3
.= ( s2 . f ) by A3
.= ( ( Initialized s2 ) . f ) by SCMFSA6C:3;
end;
then I is_halting_on ( Initialized s2 ),P2 by A8,A10,A11,A4,CKB55:1;
then A13: Q2 halts_on S2 by A9,SCMFSA7B:def 7;
A14: S1 = ( Initialize ( Initialized s1 ) ) by MEMSTR_0:44;
then A15: Q1 halts_on S1 by A11,SCMFSA7B:def 7;
now
let l being (Element of ( NAT ));
assume l < ( LifeSpan (Q1,S1) );
then ( CurInstr (Q1,( Comput (Q1,S1,l) )) ) <> ( halt ( SCM+FSA ) ) by A15,EXTPRO_1:def 15;
hence ( CurInstr (Q2,( Comput (Q2,S2,l) )) ) <> ( halt ( SCM+FSA ) ) by A8,A10,A4,A12,A14,A9,CKB53:1;
end;
then A16: (for l being (Element of ( NAT )) holds (( CurInstr (Q2,( Comput (Q2,S2,l) )) ) = ( halt ( SCM+FSA ) ) implies ( LifeSpan (Q1,S1) ) <= l));
( CurInstr (Q2,( Comput (Q2,S2,( LifeSpan (Q1,S1) )) )) ) = ( CurInstr (Q1,( Comput (Q1,S1,( LifeSpan (Q1,S1) )) )) ) by A8,A10,A4,A12,A14,A9,CKB53:1
.= ( halt ( SCM+FSA ) ) by A15,EXTPRO_1:def 15;
then A17: ( LifeSpan (Q1,S1) ) = ( LifeSpan (Q2,S2) ) by A13,A16,EXTPRO_1:def 15;
then A18: ( Result (Q2,S2) ) = ( Comput (Q2,S2,( LifeSpan (Q1,S1) )) ) by A13,EXTPRO_1:23;
A19: ( Result (Q1,S1) ) = ( Comput (Q1,S1,( LifeSpan (Q1,S1) )) ) by A15,EXTPRO_1:23;
X1: ( Result (( P1 +* I ),( Initialized s1 )) ) = ( IExec (I,P1,s1) ) by CKB51:1;
X2: ( Result (( P2 +* I ),( Initialized s2 )) ) = ( IExec (I,P2,s2) ) by CKB51:1;
thus (for d being Int-Location holds (a <> d implies ( ( IExec (I,P1,s1) ) . d ) = ( ( IExec (I,P2,s2) ) . d ))) by X2,X1,A8,A10,A4,A12,A14,A9,A18,A19,CKB53:1;
thus (for f being FinSeq-Location holds ( ( IExec (I,P1,s1) ) . f ) = ( ( IExec (I,P2,s2) ) . f )) by X2,X1,A8,A10,A4,A12,A14,A9,A18,A19,CKB53:1;
thus ( IC ( IExec (I,P1,s1) ) ) = ( IC ( Result (Q1,S1) ) ) by SCMFSA6B:def 1
.= ( IC ( Comput (Q1,S1,( LifeSpan (Q1,S1) )) ) ) by A15,EXTPRO_1:23
.= ( IC ( Comput (Q2,S2,( LifeSpan (Q2,S2) )) ) ) by A8,A10,A4,A12,A14,A9,A17,CKB53:1
.= ( IC ( Result (Q2,S2) ) ) by A13,EXTPRO_1:23
.= ( IC ( IExec (I,P2,s2) ) ) by SCMFSA6B:def 1;
end;
