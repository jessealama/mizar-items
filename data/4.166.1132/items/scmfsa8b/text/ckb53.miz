environ
vocabularies NUMBERS,SCMFSA_2,AMI_1,AMISTD_2,CARD_1,TARSKI,TURING_1,SCMFSA6A,FUNCT_4,FSM_1,RELAT_1,UNIALG_2,CIRCUIT2,FUNCT_1,SF_MASTR,SUBSET_1,ARYTM_3,SCMFSA7B,SCMFSA6B,SCMFSA6C,AMI_3,SCMFSA8A,NAT_1,GRAPHSP,XXREAL_0,MSUALG_1,STRUCT_0,ARYTM_1,INT_1,COMPLEX1,PARTFUN1,FINSEQ_1,FINSEQ_2,SCMFSA8B,ORDINAL1,SCMNORM,RELOC,PBOOLE,FUNCOP_1,XBOOLE_0,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCOP_1,FUNCT_4,PBOOLE,FUNCT_7,FINSEQ_1,FINSEQ_2,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,INT_2,XXREAL_0,CKB12,CKB13,CKB14,CKB40,CKB41,CKB47;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,STRUCT_0,SCMFSA6A,MEMSTR_0,CKB12,CKB13,CKB14,CKB40,CKB41;
theorems TARSKI,NAT_1,FUNCT_1,FUNCT_4,SCMFSA_2,MEMSTR_0,SCMFSA6A,GRFUNC_1,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,RELAT_1,XBOOLE_1,XREAL_1,ORDINAL1,FUNCOP_1,XXREAL_0,PARTFUN1,AFINSQ_1,SCMFSA10,COMPOS_1,EXTPRO_1,AMISTD_2,PBOOLE,AMISTD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB40,CKB41,CKB50,CKB51,CKB52;
schemes NAT_1;
registrations SETFAM_1,FUNCT_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SF_MASTR,SCMFSA6A,SCMFSA6B,SCMFSA6C,ORDINAL1,MEMSTR_0,XBOOLE_0,FINSET_1,RELSET_1,SCMFSA10,AMISTD_2,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,FUNCOP_1,AMISTD_1,RELAT_1,STRUCT_0,CKB38,CKB39,CKB42,CKB43,CKB44,CKB45,CKB46,CKB48,CKB49;
constructors DOMAIN_1,XXREAL_0,NAT_1,INT_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,AMISTD_2,RELSET_1,SCMFSA7B,PRE_POLY,AMISTD_1,PBOOLE,FUNCOP_1,FUNCT_4,MEMSTR_0,CKB12,CKB13,CKB14,CKB40,CKB41;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve P1 for (Instruction-Sequence of ( SCM+FSA ));
reserve P2 for (Instruction-Sequence of ( SCM+FSA ));
theorem
Th38: (for s1,s2 being (State of ( SCM+FSA )) holds (for I being (Program of ( SCM+FSA )) holds (for a being Int-Location holds (((((not I refer a) & (for b being Int-Location holds (a <> b implies ( s1 . b ) = ( s2 . b )))) & (for f being FinSeq-Location holds ( s1 . f ) = ( s2 . f ))) & I is_closed_on s1,P1) implies (for k being (Element of ( NAT )) holds ((((for b being Int-Location holds (a <> b implies ( ( Comput (( P1 +* I ),( Initialize s1 ),k) ) . b ) = ( ( Comput (( P2 +* I ),( Initialize s2 ),k) ) . b ))) & (for f being FinSeq-Location holds ( ( Comput (( P1 +* I ),( Initialize s1 ),k) ) . f ) = ( ( Comput (( P2 +* I ),( Initialize s2 ),k) ) . f ))) & ( IC ( Comput (( P1 +* I ),( Initialize s1 ),k) ) ) = ( IC ( Comput (( P2 +* I ),( Initialize s2 ),k) ) )) & ( CurInstr (( P1 +* I ),( Comput (( P1 +* I ),( Initialize s1 ),k) )) ) = ( CurInstr (( P2 +* I ),( Comput (( P2 +* I ),( Initialize s2 ),k) )) )))))))
proof
let s1 being (State of ( SCM+FSA ));
let s2 being (State of ( SCM+FSA ));
let I being (Program of ( SCM+FSA ));
let a being Int-Location;
assume A2: (not I refer a);
set S2 = ( Initialize s2 );
set Q2 = ( P2 +* I );
set S1 = ( Initialize s1 );
set Q1 = ( P1 +* I );
A3: I c= Q1 by FUNCT_4:25;
A4: I c= Q2 by FUNCT_4:25;
defpred S[ (State of ( SCM+FSA )),(State of ( SCM+FSA )) ]
 means
((for b being Int-Location holds (a <> b implies ( $1 . b ) = ( $2 . b ))) & (for f being FinSeq-Location holds ( $1 . f ) = ( $2 . f )));
assume that
A5: (for b being Int-Location holds (a <> b implies ( s1 . b ) = ( s2 . b )))
and
A6: (for f being FinSeq-Location holds ( s1 . f ) = ( s2 . f ));
B7: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) by MEMSTR_0:15;
A8:now
let f being FinSeq-Location;
B9: (not f in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) )) by SCMFSA_2:103;
hence ( S1 . f ) = ( s1 . f ) by FUNCT_4:11
.= ( s2 . f ) by A6
.= ( S2 . f ) by B9,FUNCT_4:11;
end;
A10: ( Comput (Q2,S2,( 0 )) ) = S2 by EXTPRO_1:2;
defpred P[ Nat ]
 means
((S[ ( Comput (Q1,S1,$1) ),( Comput (Q2,S2,$1) ) ] & ( IC ( Comput (Q1,S1,$1) ) ) = ( IC ( Comput (Q2,S2,$1) ) )) & ( CurInstr (Q1,( Comput (Q1,S1,$1) )) ) = ( CurInstr (Q2,( Comput (Q2,S2,$1) )) ));
A11: ( IC ( Comput (Q1,S1,( 0 )) ) ) = ( IC S1 ) by EXTPRO_1:2
.= ( IC ( Start-At (( 0 ),( SCM+FSA )) ) ) by B7,FUNCT_4:13
.= ( IC S2 ) by B7,FUNCT_4:13
.= ( IC ( Comput (Q2,S2,( 0 )) ) ) by EXTPRO_1:2;
A12:now
let b being Int-Location;
assume A13: a <> b;
B14: (not b in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) )) by SCMFSA_2:102;
hence ( S1 . b ) = ( s1 . b ) by FUNCT_4:11
.= ( s2 . b ) by A5,A13
.= ( S2 . b ) by B14,FUNCT_4:11;
end;
A15: ( Comput (Q1,S1,( 0 )) ) = S1 by EXTPRO_1:2;
assume that
A16: I is_closed_on s1,P1;
A17: ( IC ( Comput (Q1,S1,( 0 )) ) ) in ( dom I ) by A16,SCMFSA7B:def 6;
A18: (for k being (Element of ( NAT )) holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
A19: ( Comput (Q1,S1,( k + 1 )) ) = ( Following (Q1,( Comput (Q1,S1,k) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (Q1,( Comput (Q1,S1,k) )) ),( Comput (Q1,S1,k) )) );
A20: ( IC ( Comput (Q1,S1,k) ) ) in ( dom I ) by A16,SCMFSA7B:def 6;
A21: ( Comput (Q2,S2,( k + 1 )) ) = ( Following (Q2,( Comput (Q2,S2,k) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (Q2,( Comput (Q2,S2,k) )) ),( Comput (Q2,S2,k) )) );
A22: ( Q1 /. ( IC ( Comput (Q1,S1,k) ) ) ) = ( Q1 . ( IC ( Comput (Q1,S1,k) ) ) ) by PBOOLE:143;
( CurInstr (Q1,( Comput (Q1,S1,k) )) ) = ( I . ( IC ( Comput (Q1,S1,k) ) ) ) by A20,A22,A3,GRFUNC_1:2;
then ( CurInstr (Q1,( Comput (Q1,S1,k) )) ) in ( rng I ) by A20,FUNCT_1:def 3;
then A23: (not ( CurInstr (Q1,( Comput (Q1,S1,k) )) ) refer a) by A2,SCMFSA7B:def 2;
assume A24: P[ k ];
hence S[ ( Comput (Q1,S1,( k + 1 )) ),( Comput (Q2,S2,( k + 1 )) ) ] by A19,A21,A23,CKB52:1;
thus A25: ( IC ( Comput (Q1,S1,( k + 1 )) ) ) = ( IC ( Comput (Q2,S2,( k + 1 )) ) ) by A24,A19,A21,A23,CKB52:1;
A26: ( IC ( Comput (Q1,S1,( k + 1 )) ) ) in ( dom I ) by A16,SCMFSA7B:def 6;
A27: ( Q1 /. ( IC ( Comput (Q1,S1,( k + 1 )) ) ) ) = ( Q1 . ( IC ( Comput (Q1,S1,( k + 1 )) ) ) ) by PBOOLE:143;
A28: ( Q2 /. ( IC ( Comput (Q2,S2,( k + 1 )) ) ) ) = ( Q2 . ( IC ( Comput (Q2,S2,( k + 1 )) ) ) ) by PBOOLE:143;
thus ( CurInstr (Q1,( Comput (Q1,S1,( k + 1 )) )) ) = ( I . ( IC ( Comput (Q1,S1,( k + 1 )) ) ) ) by A26,A27,A3,GRFUNC_1:2
.= ( CurInstr (Q2,( Comput (Q2,S2,( k + 1 )) )) ) by A25,A26,A28,A4,GRFUNC_1:2;
end;
( CurInstr (Q1,( Comput (Q1,S1,( 0 )) )) ) = ( Q1 . ( IC ( Comput (Q1,S1,( 0 )) ) ) ) by PBOOLE:143
.= ( I . ( IC ( Comput (Q1,S1,( 0 )) ) ) ) by A17,A3,GRFUNC_1:2
.= ( Q2 . ( IC ( Comput (Q2,S2,( 0 )) ) ) ) by A11,A17,A4,GRFUNC_1:2
.= ( CurInstr (Q2,( Comput (Q2,S2,( 0 )) )) ) by PBOOLE:143;
then A29: P[ ( 0 ) ] by A12,A8,A15,A10,A11;
(for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A29,A18);
hence thesis;
end;
