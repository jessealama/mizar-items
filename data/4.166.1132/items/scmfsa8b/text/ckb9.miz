environ
vocabularies NUMBERS,SCMFSA_2,AMI_1,AMISTD_2,CARD_1,TARSKI,TURING_1,SCMFSA6A,FUNCT_4,FSM_1,RELAT_1,UNIALG_2,CIRCUIT2,FUNCT_1,SF_MASTR,SUBSET_1,ARYTM_3,SCMFSA7B,SCMFSA6B,SCMFSA6C,AMI_3,SCMFSA8A,NAT_1,GRAPHSP,XXREAL_0,MSUALG_1,STRUCT_0,ARYTM_1,INT_1,COMPLEX1,PARTFUN1,FINSEQ_1,FINSEQ_2,SCMFSA8B,ORDINAL1,SCMNORM,RELOC,PBOOLE,FUNCOP_1,XBOOLE_0,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCOP_1,FUNCT_4,PBOOLE,FUNCT_7,FINSEQ_1,FINSEQ_2,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,INT_2,XXREAL_0;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,STRUCT_0,SCMFSA6A,MEMSTR_0;
theorems TARSKI,NAT_1,FUNCT_1,FUNCT_4,SCMFSA_2,MEMSTR_0,SCMFSA6A,GRFUNC_1,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,RELAT_1,XBOOLE_1,XREAL_1,ORDINAL1,FUNCOP_1,XXREAL_0,PARTFUN1,AFINSQ_1,SCMFSA10,COMPOS_1,EXTPRO_1,AMISTD_2,PBOOLE,AMISTD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8;
schemes NAT_1;
registrations SETFAM_1,FUNCT_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SF_MASTR,SCMFSA6A,SCMFSA6B,SCMFSA6C,ORDINAL1,MEMSTR_0,XBOOLE_0,FINSET_1,RELSET_1,SCMFSA10,AMISTD_2,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,FUNCOP_1,AMISTD_1,RELAT_1,STRUCT_0;
constructors DOMAIN_1,XXREAL_0,NAT_1,INT_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,AMISTD_2,RELSET_1,SCMFSA7B,PRE_POLY,AMISTD_1,PBOOLE,FUNCOP_1,FUNCT_4,MEMSTR_0;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve P1 for (Instruction-Sequence of ( SCM+FSA ));
reserve P2 for (Instruction-Sequence of ( SCM+FSA ));
theorem
Th11: (for s1 being ( 0 ) -started (State of ( SCM+FSA )) holds (for s2 being (State of ( SCM+FSA )) holds (for I being (Program of ( SCM+FSA )) holds ((I is_closed_on s1,P1 & I c= P1) implies (for n being (Element of ( NAT )) holds (((( IC s2 ) = n & ( DataPart s1 ) = ( DataPart s2 )) & ( Reloc (I,n) ) c= P2) implies (for i being (Element of ( NAT )) holds ((( ( IC ( Comput (P1,s1,i) ) ) + n ) = ( IC ( Comput (P2,s2,i) ) ) & ( IncAddr (( CurInstr (P1,( Comput (P1,s1,i) )) ),n) ) = ( CurInstr (P2,( Comput (P2,s2,i) )) )) & ( DataPart ( Comput (P1,s1,i) ) ) = ( DataPart ( Comput (P2,s2,i) ) )))))))))
proof
let s1 being ( 0 ) -started (State of ( SCM+FSA ));
let s2 being (State of ( SCM+FSA ));
let I being (Program of ( SCM+FSA ));
A1: ( Start-At (( 0 ),( SCM+FSA )) ) c= s1 by MEMSTR_0:29;
assume A2: I is_closed_on s1,P1;
assume A4: I c= P1;
let n being (Element of ( NAT ));
B5: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) by MEMSTR_0:15;
defpred P[ Nat ]
 means
((( ( IC ( Comput (P1,s1,$1) ) ) + n ) = ( IC ( Comput (P2,s2,$1) ) ) & ( IncAddr (( CurInstr (P1,( Comput (P1,s1,$1) )) ),n) ) = ( CurInstr (P2,( Comput (P2,s2,$1) )) )) & ( DataPart ( Comput (P1,s1,$1) ) ) = ( DataPart ( Comput (P2,s2,$1) ) ));
A6: ( IC ( Comput (P1,s1,( 0 )) ) ) = ( IC s1 ) by EXTPRO_1:2
.= ( IC ( Start-At (( 0 ),( SCM+FSA )) ) ) by A1,B5,GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
assume A7: ( IC s2 ) = n;
A8: ( 0 ) in ( dom I ) by A2,CKB2:1;
then A9: ( ( 0 ) + n ) in ( dom ( Reloc (I,n) ) ) by COMPOS_1:46;
( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) by MEMSTR_0:15;
then A10: ( P1 . ( IC s1 ) ) = ( P1 . ( IC ( Start-At (( 0 ),( SCM+FSA )) ) ) ) by A1,GRFUNC_1:2
.= ( P1 . ( 0 ) ) by FUNCOP_1:72
.= ( I . ( 0 ) ) by A8,A4,GRFUNC_1:2;
assume ( DataPart s1 ) = ( DataPart s2 );
then A11: ( DataPart ( Comput (P1,s1,( 0 )) ) ) = ( DataPart s2 ) by EXTPRO_1:2
.= ( DataPart ( Comput (P2,s2,( 0 )) ) ) by EXTPRO_1:2;
assume A12: ( Reloc (I,n) ) c= P2;
let i being (Element of ( NAT ));
A13: ( P2 /. ( IC s2 ) ) = ( P2 . ( IC s2 ) ) by PBOOLE:143;
A14: ( CurInstr (P1,s1) ) = ( I . ( 0 ) ) by A10,PBOOLE:143;
( IncAddr (( CurInstr (P1,( Comput (P1,s1,( 0 )) )) ),n) ) = ( IncAddr (( CurInstr (P1,s1) ),n) ) by EXTPRO_1:2
.= ( ( Reloc (I,n) ) . ( ( 0 ) + n ) ) by A14,A8,COMPOS_1:35
.= ( CurInstr (P2,s2) ) by A7,A9,A13,A12,GRFUNC_1:2
.= ( CurInstr (P2,( Comput (P2,s2,( 0 )) )) ) by EXTPRO_1:2;
then A15: P[ ( 0 ) ] by A7,A6,A11,EXTPRO_1:2;
A16: (for k being (Element of ( NAT )) holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
A17: ( Comput (P1,s1,( k + 1 )) ) = ( Following (P1,( Comput (P1,s1,k) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (P1,( Comput (P1,s1,k) )) ),( Comput (P1,s1,k) )) );
reconsider l = ( IC ( Comput (P1,s1,( k + 1 )) ) ) as (Element of ( NAT ));
reconsider j = ( CurInstr (P1,( Comput (P1,s1,( k + 1 )) )) ) as (Instruction of ( SCM+FSA ));
A18: ( Comput (P2,s2,( k + 1 )) ) = ( Following (P2,( Comput (P2,s2,k) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (P2,( Comput (P2,s2,k) )) ),( Comput (P2,s2,k) )) );
A19: ( Initialize s1 ) = s1 by A1,FUNCT_4:98;
A20: P1 = ( P1 +* I ) by A4,FUNCT_4:98;
then A21: ( IC ( Comput (P1,s1,( k + 1 )) ) ) in ( dom I ) by A2,A19,SCMFSA7B:def 6;
assume A22: P[ k ];
hence A23: ( ( IC ( Comput (P1,s1,( k + 1 )) ) ) + n ) = ( IC ( Comput (P2,s2,( k + 1 )) ) ) by A17,A18,SCMFSA6A:8;
then A24: ( IC ( Comput (P2,s2,( k + 1 )) ) ) in ( dom ( Reloc (I,n) ) ) by A21,COMPOS_1:46;
A25: l in ( dom I ) by A19,A2,A20,SCMFSA7B:def 6;
j = ( P1 . ( IC ( Comput (P1,s1,( k + 1 )) ) ) ) by PBOOLE:143
.= ( I . l ) by A21,A4,GRFUNC_1:2;
hence ( IncAddr (( CurInstr (P1,( Comput (P1,s1,( k + 1 )) )) ),n) ) = ( ( Reloc (I,n) ) . ( l + n ) ) by A25,COMPOS_1:35
.= ( P2 . ( IC ( Comput (P2,s2,( k + 1 )) ) ) ) by A24,A23,A12,GRFUNC_1:2
.= ( CurInstr (P2,( Comput (P2,s2,( k + 1 )) )) ) by PBOOLE:143;
thus thesis by A22,A17,A18,SCMFSA6A:8;
end;
(for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A15,A16);
hence thesis;
end;
