environ
vocabularies NUMBERS,SCMFSA_2,AMI_1,AMISTD_2,CARD_1,TARSKI,TURING_1,SCMFSA6A,FUNCT_4,FSM_1,RELAT_1,UNIALG_2,CIRCUIT2,FUNCT_1,SF_MASTR,SUBSET_1,ARYTM_3,SCMFSA7B,SCMFSA6B,SCMFSA6C,AMI_3,SCMFSA8A,NAT_1,GRAPHSP,XXREAL_0,MSUALG_1,STRUCT_0,ARYTM_1,INT_1,COMPLEX1,PARTFUN1,FINSEQ_1,FINSEQ_2,SCMFSA8B,ORDINAL1,SCMNORM,RELOC,PBOOLE,FUNCOP_1,XBOOLE_0,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCOP_1,FUNCT_4,PBOOLE,FUNCT_7,FINSEQ_1,FINSEQ_2,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,INT_2,XXREAL_0,CKB12,CKB13,CKB14;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,STRUCT_0,SCMFSA6A,MEMSTR_0,CKB12,CKB13,CKB14;
theorems TARSKI,NAT_1,FUNCT_1,FUNCT_4,SCMFSA_2,MEMSTR_0,SCMFSA6A,GRFUNC_1,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,RELAT_1,XBOOLE_1,XREAL_1,ORDINAL1,FUNCOP_1,XXREAL_0,PARTFUN1,AFINSQ_1,SCMFSA10,COMPOS_1,EXTPRO_1,AMISTD_2,PBOOLE,AMISTD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19;
schemes NAT_1;
registrations SETFAM_1,FUNCT_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SF_MASTR,SCMFSA6A,SCMFSA6B,SCMFSA6C,ORDINAL1,MEMSTR_0,XBOOLE_0,FINSET_1,RELSET_1,SCMFSA10,AMISTD_2,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,FUNCOP_1,AMISTD_1,RELAT_1,STRUCT_0;
constructors DOMAIN_1,XXREAL_0,NAT_1,INT_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,AMISTD_2,RELSET_1,SCMFSA7B,PRE_POLY,AMISTD_1,PBOOLE,FUNCOP_1,FUNCT_4,MEMSTR_0,CKB12,CKB13,CKB14;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve P for (Instruction-Sequence of ( SCM+FSA ));
theorem
Th17: (for s being (State of ( SCM+FSA )) holds (for I,J being (Program of ( SCM+FSA )) holds (for a being  read-write Int-Location holds (((( s . a ) = ( 0 ) & I is_closed_on ( Initialized s ),P) & I is_halting_on ( Initialized s ),P) implies ( IExec (( if=0 (a,I,J) ),P,s) ) = ( ( IExec (I,P,s) ) +* ( Start-At (( ( ( card I ) + ( card J ) ) + 3 ),( SCM+FSA )) ) )))))
proof
let s being (State of ( SCM+FSA ));
let I being (Program of ( SCM+FSA ));
let J being (Program of ( SCM+FSA ));
let a being  read-write Int-Location;
set I1 = ( I ';' ( Stop ( SCM+FSA ) ) );
set s1 = ( Initialized s );
set P1 = ( P +* I1 );
set P3 = ( P +* ( if=0 (a,I,J) ) );
A1: I1 c= P1 by FUNCT_4:25;
set s4 = ( Comput (P3,s1,1) );
set i = ( a =0_goto ( ( card J ) + 3 ) );
A3: ( if=0 (a,I,J) ) = ( ( ( i ';' J ) ';' ( Goto ( ( card I ) + 1 ) ) ) ';' I1 ) by SCMFSA6A:25;
A4: ( 0 ) in ( dom ( if=0 (a,I,J) ) ) by CKB15:1;
A5: ( P3 . ( 0 ) ) = ( ( if=0 (a,I,J) ) . ( 0 ) ) by A4,FUNCT_4:13
.= i by CKB16:1;
L1: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = { ( intloc ( 0 ) ),( IC ( SCM+FSA ) ) } by SCMFSA6A:42;
(a <> ( intloc ( 0 ) ) & a <> ( IC ( SCM+FSA ) )) by SCMFSA_2:56;
then C11: (not a in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) by L1,TARSKI:def 2;
( IC ( SCM+FSA ) ) in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by MEMSTR_0:48;
then A6: ( IC s1 ) = ( IC ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by FUNCT_4:13
.= ( 0 ) by MEMSTR_0:def 8;
A7: ( Comput (P3,s1,( ( 0 ) + 1 )) ) = ( Following (P3,( Comput (P3,s1,( 0 )) )) ) by EXTPRO_1:3
.= ( Following (P3,s1) ) by EXTPRO_1:2
.= ( Exec (i,s1) ) by A6,A5,PBOOLE:143;
A10: ( if=0 (a,I,J) ) c= P3 by FUNCT_4:25;
assume ( s . a ) = ( 0 );
then ( s1 . a ) = ( 0 ) by C11,FUNCT_4:11;
then A13: ( IC ( Comput (P3,s1,1) ) ) = ( ( card J ) + 3 ) by A7,SCMFSA_2:70;
A15: (for f being FinSeq-Location holds ( s1 . f ) = ( s4 . f )) by A7,SCMFSA_2:70;
(for a being Int-Location holds ( s1 . a ) = ( s4 . a )) by A7,SCMFSA_2:70;
then A16: ( DataPart s1 ) = ( DataPart s4 ) by A15,SCMFSA6A:7;
( card ( ( i ';' J ) ';' ( Goto ( ( card I ) + 1 ) ) ) ) = ( ( card ( ( Macro i ) ';' J ) ) + ( card ( Goto ( ( card I ) + 1 ) ) ) ) by SCMFSA6A:21
.= ( ( card ( ( Macro i ) ';' J ) ) + 1 ) by SCMFSA8A:15
.= ( ( ( card ( Macro i ) ) + ( card J ) ) + 1 ) by SCMFSA6A:21
.= ( ( ( card J ) + 2 ) + 1 ) by COMPOS_1:56
.= ( ( card J ) + ( 2 + 1 ) );
then A17: ( Reloc (I1,( ( card J ) + 3 )) ) c= ( if=0 (a,I,J) ) by A3,CKB1:1;
A19: ( Reloc (I1,( ( card J ) + 3 )) ) c= P3 by A17,A10,XBOOLE_1:1;
assume A20: I is_closed_on ( Initialized s ),P;
assume A21: I is_halting_on ( Initialized s ),P;
then A22: P1 halts_on s1 by A20,SCMFSA8A:34;
I1 is_closed_on ( Initialized s ),P by A20,A21,SCMFSA8A:30;
then A23: I1 is_closed_on s1,P1 by CKB7:1;
A24: ( CurInstr (P3,( Comput (P3,s1,( ( LifeSpan (P1,s1) ) + 1 )) )) ) = ( CurInstr (P3,( Comput (P3,s4,( LifeSpan (P1,s1) )) )) ) by EXTPRO_1:4
.= ( IncAddr (( CurInstr (P1,( Comput (P1,s1,( LifeSpan (P1,s1) )) )) ),( ( card J ) + 3 )) ) by A23,A13,A16,CKB9:1,A19,A1
.= ( IncAddr (( halt ( SCM+FSA ) ),( ( card J ) + 3 )) ) by A22,EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_1:11;
then A25: P3 halts_on s1 by EXTPRO_1:29;
now
let l being (Element of ( NAT ));
assume A26: l < ( ( LifeSpan (P1,s1) ) + 1 );
A27: ( Comput (P3,s1,( 0 )) ) = s1 by EXTPRO_1:2;
per cases ;
suppose l = ( 0 );

hence ( CurInstr (P3,( Comput (P3,s1,l) )) ) <> ( halt ( SCM+FSA ) ) by A6,A5,A27,PBOOLE:143;
end;
suppose l <> ( 0 );

then consider n being Nat such that A28: l = ( n + 1 ) by NAT_1:6;
assume A29: ( CurInstr (P3,( Comput (P3,s1,l) )) ) = ( halt ( SCM+FSA ) );
reconsider n as (Element of ( NAT )) by ORDINAL1:def 12;
( InsCode ( CurInstr (P1,( Comput (P1,s1,n) )) ) ) = ( InsCode ( IncAddr (( CurInstr (P1,( Comput (P1,s1,n) )) ),( ( card J ) + 3 )) ) ) by COMPOS_1:def 17
.= ( InsCode ( CurInstr (P3,( Comput (P3,s4,n) )) ) ) by A23,A13,A16,CKB9:1,A19,A1
.= ( 0 ) by A28,A29,EXTPRO_1:4,SCMFSA_2:97;
then A30: ( CurInstr (P1,( Comput (P1,s1,n) )) ) = ( halt ( SCM+FSA ) ) by SCMFSA_2:95;
n < ( LifeSpan (P1,s1) ) by A26,A28,XREAL_1:6;
hence contradiction by A22,A30,EXTPRO_1:def 15;
end;
end;
then (for l being (Element of ( NAT )) holds (( CurInstr (P3,( Comput (P3,s1,l) )) ) = ( halt ( SCM+FSA ) ) implies ( ( LifeSpan (P1,s1) ) + 1 ) <= l));
then A31: ( LifeSpan (P3,s1) ) = ( ( LifeSpan (P1,s1) ) + 1 ) by A24,A25,EXTPRO_1:def 15;
A32: ( DataPart ( Result (P1,s1) ) ) = ( DataPart ( Comput (P1,s1,( LifeSpan (P1,s1) )) ) ) by A20,A21,EXTPRO_1:23,SCMFSA8A:34
.= ( DataPart ( Comput (P3,s4,( LifeSpan (P1,s1) )) ) ) by A23,A13,A16,CKB9:1,A1,A19
.= ( DataPart ( Comput (P3,s1,( ( LifeSpan (P1,s1) ) + 1 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (P3,s1) ) ) by A25,A31,EXTPRO_1:23;
A33:now
let x being set;
A34: ( IExec (I1,P,s) ) = ( Result (P1,s1) ) by SCMFSA6B:def 1;
A35: ( dom ( Start-At (( ( ( card I ) + ( card J ) ) + 3 ),( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
A36: ( IExec (( if=0 (a,I,J) ),P,s) ) = ( Result (P3,s1) ) by SCMFSA6B:def 1;
assume A38: x in ( dom ( IExec (( if=0 (a,I,J) ),P,s) ) );
per cases  by A38,SCMFSA6A:5;
suppose A39: x is Int-Location;

then x <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
then A40: (not x in ( dom ( Start-At (( ( ( card I ) + ( card J ) ) + 3 ),( SCM+FSA )) ) )) by A35,TARSKI:def 1;
thus ( ( IExec (( if=0 (a,I,J) ),P,s) ) . x ) = ( ( Result (P3,s1) ) . x ) by A36
.= ( ( Result (P1,s1) ) . x ) by A32,A39,SCMFSA6A:7
.= ( ( IExec (I1,P,s) ) . x ) by A34
.= ( ( ( IExec (I1,P,s) ) +* ( Start-At (( ( ( card I ) + ( card J ) ) + 3 ),( SCM+FSA )) ) ) . x ) by A40,FUNCT_4:11;
end;
suppose A41: x is FinSeq-Location;

then x <> ( IC ( SCM+FSA ) ) by SCMFSA_2:57;
then A42: (not x in ( dom ( Start-At (( ( ( card I ) + ( card J ) ) + 3 ),( SCM+FSA )) ) )) by A35,TARSKI:def 1;
thus ( ( IExec (( if=0 (a,I,J) ),P,s) ) . x ) = ( ( Result (P3,s1) ) . x ) by A36
.= ( ( Result (P1,s1) ) . x ) by A32,A41,SCMFSA6A:7
.= ( ( IExec (I1,P,s) ) . x ) by A34
.= ( ( ( IExec (I1,P,s) ) +* ( Start-At (( ( ( card I ) + ( card J ) ) + 3 ),( SCM+FSA )) ) ) . x ) by A42,FUNCT_4:11;
end;
suppose A43: x = ( IC ( SCM+FSA ) );

then A44: x in ( dom ( Start-At (( ( ( card I ) + ( card J ) ) + 3 ),( SCM+FSA )) ) ) by A35,TARSKI:def 1;
A46: ( IC ( Result (P1,s1) ) ) = ( ( IExec (I1,P,s) ) . ( IC ( SCM+FSA ) ) ) by A34
.= ( IC ( ( IExec (I,P,s) ) +* ( Start-At (( card I ),( SCM+FSA )) ) ) ) by A20,A21,SCMFSA8A:36
.= ( card I ) by FUNCT_4:113;
thus ( ( IExec (( if=0 (a,I,J) ),P,s) ) . x ) = ( ( Result (P3,s1) ) . x ) by A36
.= ( ( Comput (P3,s1,( ( LifeSpan (P1,s1) ) + 1 )) ) . x ) by A25,A31,EXTPRO_1:23
.= ( IC ( Comput (P3,s4,( LifeSpan (P1,s1) )) ) ) by A43,EXTPRO_1:4
.= ( ( IC ( Comput (P1,s1,( LifeSpan (P1,s1) )) ) ) + ( ( card J ) + 3 ) ) by A23,A13,A16,CKB9:1,A19,A1
.= ( ( IC ( Result (P1,s1) ) ) + ( ( card J ) + 3 ) ) by A20,A21,EXTPRO_1:23,SCMFSA8A:34
.= ( ( Start-At (( ( card I ) + ( ( card J ) + 3 ) ),( SCM+FSA )) ) . ( IC ( SCM+FSA ) ) ) by A46,FUNCOP_1:72
.= ( ( ( IExec (I1,P,s) ) +* ( Start-At (( ( ( card I ) + ( card J ) ) + 3 ),( SCM+FSA )) ) ) . x ) by A43,A44,FUNCT_4:13;
end;
end;
( dom ( IExec (( if=0 (a,I,J) ),P,s) ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2
.= ( dom ( ( IExec (I1,P,s) ) +* ( Start-At (( ( ( card I ) + ( card J ) ) + 3 ),( SCM+FSA )) ) ) ) by PARTFUN1:def 2;
hence ( IExec (( if=0 (a,I,J) ),P,s) ) = ( ( IExec (I1,P,s) ) +* ( Start-At (( ( ( card I ) + ( card J ) ) + 3 ),( SCM+FSA )) ) ) by A33,FUNCT_1:2
.= ( ( ( IExec (I,P,s) ) +* ( Start-At (( card I ),( SCM+FSA )) ) ) +* ( Start-At (( ( ( card I ) + ( card J ) ) + 3 ),( SCM+FSA )) ) ) by A20,A21,SCMFSA8A:36
.= ( ( IExec (I,P,s) ) +* ( Start-At (( ( ( card I ) + ( card J ) ) + 3 ),( SCM+FSA )) ) ) by FUNCT_4:114;
end;
