environ
vocabularies NUMBERS,SCMFSA_2,AMI_1,AMISTD_2,CARD_1,TARSKI,TURING_1,SCMFSA6A,FUNCT_4,FSM_1,RELAT_1,UNIALG_2,CIRCUIT2,FUNCT_1,SF_MASTR,SUBSET_1,ARYTM_3,SCMFSA7B,SCMFSA6B,SCMFSA6C,AMI_3,SCMFSA8A,NAT_1,GRAPHSP,XXREAL_0,MSUALG_1,STRUCT_0,ARYTM_1,INT_1,COMPLEX1,PARTFUN1,FINSEQ_1,FINSEQ_2,SCMFSA8B,ORDINAL1,SCMNORM,RELOC,PBOOLE,FUNCOP_1,XBOOLE_0,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCOP_1,FUNCT_4,PBOOLE,FUNCT_7,FINSEQ_1,FINSEQ_2,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,INT_2,XXREAL_0;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,STRUCT_0,SCMFSA6A,MEMSTR_0;
theorems TARSKI,NAT_1,FUNCT_1,FUNCT_4,SCMFSA_2,MEMSTR_0,SCMFSA6A,GRFUNC_1,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,RELAT_1,XBOOLE_1,XREAL_1,ORDINAL1,FUNCOP_1,XXREAL_0,PARTFUN1,AFINSQ_1,SCMFSA10,COMPOS_1,EXTPRO_1,AMISTD_2,PBOOLE,AMISTD_1,CKB1,CKB2,CKB3,CKB4,CKB5;
schemes NAT_1;
registrations SETFAM_1,FUNCT_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SF_MASTR,SCMFSA6A,SCMFSA6B,SCMFSA6C,ORDINAL1,MEMSTR_0,XBOOLE_0,FINSET_1,RELSET_1,SCMFSA10,AMISTD_2,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,FUNCOP_1,AMISTD_1,RELAT_1,STRUCT_0;
constructors DOMAIN_1,XXREAL_0,NAT_1,INT_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,AMISTD_2,RELSET_1,SCMFSA7B,PRE_POLY,AMISTD_1,PBOOLE,FUNCOP_1,FUNCT_4,MEMSTR_0;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve P1 for (Instruction-Sequence of ( SCM+FSA ));
reserve P2 for (Instruction-Sequence of ( SCM+FSA ));
theorem
Th8: (for s1,s2 being (State of ( SCM+FSA )) holds (for I being (Program of ( SCM+FSA )) holds (( DataPart s1 ) = ( DataPart s2 ) implies ((I is_closed_on s1,P1 & I is_halting_on s1,P1) implies (I is_closed_on s2,P2 & I is_halting_on s2,P2)))))
proof
let s1 being (State of ( SCM+FSA ));
let s2 being (State of ( SCM+FSA ));
let I being (Program of ( SCM+FSA ));
set S1 = ( Initialize s1 );
set S2 = ( Initialize s2 );
defpred P[ Nat ]
 means
((( IC ( Comput (( P1 +* I ),S1,$1) ) ) = ( IC ( Comput (( P2 +* I ),S2,$1) ) ) & ( CurInstr (( P1 +* I ),( Comput (( P1 +* I ),S1,$1) )) ) = ( CurInstr (( P2 +* I ),( Comput (( P2 +* I ),S2,$1) )) )) & ( DataPart ( Comput (( P1 +* I ),S1,$1) ) ) = ( DataPart ( Comput (( P2 +* I ),S2,$1) ) ));
A4: ( Comput (( P1 +* I ),S1,( 0 )) ) = ( Initialize s1 ) by EXTPRO_1:2;
C5: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) by MEMSTR_0:15;
A6: ( IC ( Comput (( P1 +* I ),S1,( 0 )) ) ) = ( IC ( Start-At (( 0 ),( SCM+FSA )) ) ) by A4,C5,FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
A7: ( Comput (( P2 +* I ),S2,( 0 )) ) = ( Initialize s2 ) by EXTPRO_1:2;
then A8: ( IC ( Comput (( P2 +* I ),S2,( 0 )) ) ) = ( IC ( Start-At (( 0 ),( SCM+FSA )) ) ) by C5,FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
assume ( DataPart s1 ) = ( DataPart s2 );
then A9: ( Comput (( P1 +* I ),S1,( 0 )) ) = ( Comput (( P2 +* I ),S2,( 0 )) ) by A4,A7,CKB5:1;
assume A10: I is_closed_on s1,P1;
A11:now
let k being (Element of ( NAT ));
A12: ( Comput (( P2 +* I ),S2,( k + 1 )) ) = ( Following (( P2 +* I ),( Comput (( P2 +* I ),S2,k) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( P2 +* I ),( Comput (( P2 +* I ),S2,k) )) ),( Comput (( P2 +* I ),S2,k) )) );
assume A13: P[ k ];
then A14: (for f being FinSeq-Location holds ( ( Comput (( P1 +* I ),S1,k) ) . f ) = ( ( Comput (( P2 +* I ),S2,k) ) . f )) by SCMFSA6A:7;
(for a being Int-Location holds ( ( Comput (( P1 +* I ),S1,k) ) . a ) = ( ( Comput (( P2 +* I ),S2,k) ) . a )) by A13,SCMFSA6A:7;
then A15: ( Comput (( P1 +* I ),S1,k) ) = ( Comput (( P2 +* I ),S2,k) ) by A13,A14,SCMFSA_2:61;
A16: ( IC ( Comput (( P1 +* I ),S1,( k + 1 )) ) ) in ( dom I ) by A10,SCMFSA7B:def 6;
( Comput (( P1 +* I ),S1,( k + 1 )) ) = ( Following (( P1 +* I ),( Comput (( P1 +* I ),S1,k) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( P1 +* I ),( Comput (( P1 +* I ),S1,k) )) ),( Comput (( P1 +* I ),S1,k) )) );
then A17: ( Comput (( P1 +* I ),S1,( k + 1 )) ) = ( Comput (( P2 +* I ),S2,( k + 1 )) ) by A13,A15,A12;
A18: ( IC ( Comput (( P1 +* I ),S1,( k + 1 )) ) ) = ( IC ( Comput (( P2 +* I ),S2,( k + 1 )) ) ) by A17;
A19: ( ( P1 +* I ) /. ( IC ( Comput (( P1 +* I ),S1,( k + 1 )) ) ) ) = ( ( P1 +* I ) . ( IC ( Comput (( P1 +* I ),S1,( k + 1 )) ) ) ) by PBOOLE:143;
A20: ( ( P2 +* I ) /. ( IC ( Comput (( P2 +* I ),S2,( k + 1 )) ) ) ) = ( ( P2 +* I ) . ( IC ( Comput (( P2 +* I ),S2,( k + 1 )) ) ) ) by PBOOLE:143;
A21: I c= ( P1 +* I ) by FUNCT_4:25;
A22: I c= ( P2 +* I ) by FUNCT_4:25;
( CurInstr (( P1 +* I ),( Comput (( P1 +* I ),S1,( k + 1 )) )) ) = ( I . ( IC ( Comput (( P1 +* I ),S1,( k + 1 )) ) ) ) by A16,A19,A21,GRFUNC_1:2
.= ( CurInstr (( P2 +* I ),( Comput (( P2 +* I ),S2,( k + 1 )) )) ) by A18,A16,A20,A22,GRFUNC_1:2;
hence P[ ( k + 1 ) ] by A17;
end;
assume I is_halting_on s1,P1;
then ( P1 +* I ) halts_on ( Initialize s1 ) by SCMFSA7B:def 7;
then consider m being (Element of ( NAT )) such that A23: ( CurInstr (( P1 +* I ),( Comput (( P1 +* I ),S1,m) )) ) = ( halt ( SCM+FSA ) ) by EXTPRO_1:29;
A24: ( ( P1 +* I ) /. ( IC ( Comput (( P1 +* I ),S1,( 0 )) ) ) ) = ( ( P1 +* I ) . ( IC ( Comput (( P1 +* I ),S1,( 0 )) ) ) ) by PBOOLE:143;
A25: ( ( P2 +* I ) /. ( IC ( Comput (( P2 +* I ),S2,( 0 )) ) ) ) = ( ( P2 +* I ) . ( IC ( Comput (( P2 +* I ),S2,( 0 )) ) ) ) by PBOOLE:143;
A26: ( 0 ) in ( dom I ) by A10,CKB2:1;
then ( CurInstr (( P1 +* I ),( Comput (( P1 +* I ),S1,( 0 )) )) ) = ( I . ( 0 ) ) by A6,A24,FUNCT_4:13
.= ( CurInstr (( P2 +* I ),( Comput (( P2 +* I ),S2,( 0 )) )) ) by A8,A26,A25,FUNCT_4:13;
then A27: P[ ( 0 ) ] by A9;
now
let k being (Element of ( NAT ));
A28: ( IC ( Comput (( P1 +* I ),S1,k) ) ) in ( dom I ) by A10,SCMFSA7B:def 6;
(for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A27,A11);
hence ( IC ( Comput (( P2 +* I ),S2,k) ) ) in ( dom I ) by A28;
end;
hence I is_closed_on s2,P2 by SCMFSA7B:def 6;
(for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A27,A11);
then ( CurInstr (( P2 +* I ),( Comput (( P2 +* I ),S2,m) )) ) = ( halt ( SCM+FSA ) ) by A23;
then ( P2 +* I ) halts_on ( Initialize s2 ) by EXTPRO_1:29;
hence thesis by SCMFSA7B:def 7;
end;
