environ
vocabularies NUMBERS,SCMFSA_2,AMI_1,AMISTD_2,CARD_1,TARSKI,TURING_1,SCMFSA6A,FUNCT_4,FSM_1,RELAT_1,UNIALG_2,CIRCUIT2,FUNCT_1,SF_MASTR,SUBSET_1,ARYTM_3,SCMFSA7B,SCMFSA6B,SCMFSA6C,AMI_3,SCMFSA8A,NAT_1,GRAPHSP,XXREAL_0,MSUALG_1,STRUCT_0,ARYTM_1,INT_1,COMPLEX1,PARTFUN1,FINSEQ_1,FINSEQ_2,SCMFSA8B,ORDINAL1,SCMNORM,RELOC,PBOOLE,FUNCOP_1,XBOOLE_0,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCOP_1,FUNCT_4,PBOOLE,FUNCT_7,FINSEQ_1,FINSEQ_2,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,INT_2,XXREAL_0,CKB12,CKB13,CKB14;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,STRUCT_0,SCMFSA6A,MEMSTR_0,CKB12,CKB13,CKB14;
theorems TARSKI,NAT_1,FUNCT_1,FUNCT_4,SCMFSA_2,MEMSTR_0,SCMFSA6A,GRFUNC_1,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,RELAT_1,XBOOLE_1,XREAL_1,ORDINAL1,FUNCOP_1,XXREAL_0,PARTFUN1,AFINSQ_1,SCMFSA10,COMPOS_1,EXTPRO_1,AMISTD_2,PBOOLE,AMISTD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24;
schemes NAT_1;
registrations SETFAM_1,FUNCT_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SF_MASTR,SCMFSA6A,SCMFSA6B,SCMFSA6C,ORDINAL1,MEMSTR_0,XBOOLE_0,FINSET_1,RELSET_1,SCMFSA10,AMISTD_2,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,FUNCOP_1,AMISTD_1,RELAT_1,STRUCT_0;
constructors DOMAIN_1,XXREAL_0,NAT_1,INT_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,AMISTD_2,RELSET_1,SCMFSA7B,PRE_POLY,AMISTD_1,PBOOLE,FUNCOP_1,FUNCT_4,MEMSTR_0,CKB12,CKB13,CKB14;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve P for (Instruction-Sequence of ( SCM+FSA ));
theorem
Th22: (for s being (State of ( SCM+FSA )) holds (for I,J being (Program of ( SCM+FSA )) holds (for a being  read-write Int-Location holds (((( s . a ) > ( 0 ) & I is_closed_on s,P) & I is_halting_on s,P) implies (( if>0 (a,I,J) ) is_closed_on s,P & ( if>0 (a,I,J) ) is_halting_on s,P)))))
proof
let s being (State of ( SCM+FSA ));
let I being (Program of ( SCM+FSA ));
let J being (Program of ( SCM+FSA ));
let a being  read-write Int-Location;
set I1 = ( I ';' ( Stop ( SCM+FSA ) ) );
set s1 = ( Initialize s );
set P1 = ( P +* I1 );
set s3 = ( Initialize s );
set P3 = ( P +* ( if>0 (a,I,J) ) );
set s4 = ( Comput (P3,s3,1) );
set i = ( a >0_goto ( ( card J ) + 3 ) );
A1: I1 c= P1 by FUNCT_4:25;
B4: (not a in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) )) by SCMFSA_2:102;
A5: ( 0 ) in ( dom ( if>0 (a,I,J) ) ) by CKB15:1;
A6: ( P3 . ( 0 ) ) = ( ( if>0 (a,I,J) ) . ( 0 ) ) by A5,FUNCT_4:13
.= i by CKB16:1;
( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) by MEMSTR_0:15;
then A7: ( IC s3 ) = ( IC ( Start-At (( 0 ),( SCM+FSA )) ) ) by FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
A10: ( if>0 (a,I,J) ) c= P3 by FUNCT_4:25;
A11: ( if>0 (a,I,J) ) = ( ( ( i ';' J ) ';' ( Goto ( ( card I ) + 1 ) ) ) ';' I1 ) by SCMFSA6A:25;
( card ( ( i ';' J ) ';' ( Goto ( ( card I ) + 1 ) ) ) ) = ( ( card ( ( Macro i ) ';' J ) ) + ( card ( Goto ( ( card I ) + 1 ) ) ) ) by SCMFSA6A:21
.= ( ( card ( ( Macro i ) ';' J ) ) + 1 ) by SCMFSA8A:15
.= ( ( ( card ( Macro i ) ) + ( card J ) ) + 1 ) by SCMFSA6A:21
.= ( ( ( card J ) + 2 ) + 1 ) by COMPOS_1:56
.= ( ( card J ) + ( 2 + 1 ) );
then A12: ( Reloc (I1,( ( card J ) + 3 )) ) c= ( if>0 (a,I,J) ) by A11,CKB1:1;
A14: ( Reloc (I1,( ( card J ) + 3 )) ) c= P3 by A12,A10,XBOOLE_1:1;
A15: ( Comput (P3,s3,( ( 0 ) + 1 )) ) = ( Following (P3,( Comput (P3,s3,( 0 )) )) ) by EXTPRO_1:3
.= ( Following (P3,s3) ) by EXTPRO_1:2
.= ( Exec (i,s3) ) by A7,A6,PBOOLE:143;
A17: (for f being FinSeq-Location holds ( s1 . f ) = ( s4 . f )) by A15,SCMFSA_2:71;
(for a being Int-Location holds ( s1 . a ) = ( s4 . a )) by A15,SCMFSA_2:71;
then A18: ( DataPart s1 ) = ( DataPart s4 ) by A17,SCMFSA6A:7;
assume ( s . a ) > ( 0 );
then ( s3 . a ) > ( 0 ) by B4,FUNCT_4:11;
then A19: ( IC ( Comput (P3,s3,1) ) ) = ( ( card J ) + 3 ) by A15,SCMFSA_2:71;
assume A20: I is_closed_on s,P;
assume A21: I is_halting_on s,P;
then A22: I1 is_closed_on s,P by A20,SCMFSA8A:30;
I1 is_halting_on s,P by A20,A21,SCMFSA8A:30;
then A23: P1 halts_on s1 by SCMFSA7B:def 7;
( DataPart s ) = ( DataPart s1 ) by MEMSTR_0:79;
then A24: I1 is_closed_on s1,P1 by A22,CKB4:1;
now
let k being (Element of ( NAT ));
per cases ;
suppose ( 0 ) < k;

then consider k1 being Nat such that A26: ( k1 + 1 ) = k by NAT_1:6;
reconsider k1 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider m = ( IC ( Comput (P1,s1,k1) ) ) as (Element of ( NAT ));
m in ( dom I1 ) by A22,SCMFSA7B:def 6;
then A27: m < ( card I1 ) by AFINSQ_1:66;
( card ( Stop ( SCM+FSA ) ) ) = 1 by COMPOS_1:4;
then A28: ( card I1 ) = ( ( card I ) + 1 ) by SCMFSA6A:21;
( card ( if>0 (a,I,J) ) ) = ( ( ( card I ) + ( card J ) ) + 4 ) by CKB18:1
.= ( ( ( card J ) + 3 ) + ( card I1 ) ) by A28;
then A29: ( m + ( ( card J ) + 3 ) ) < ( card ( if>0 (a,I,J) ) ) by A27,XREAL_1:6;
( IC ( Comput (P3,s3,k) ) ) = ( IC ( Comput (P3,s4,k1) ) ) by A26,EXTPRO_1:4
.= ( m + ( ( card J ) + 3 ) ) by A24,A19,A18,CKB9:1,A14,A1;
hence ( IC ( Comput (P3,s3,k) ) ) in ( dom ( if>0 (a,I,J) ) ) by A29,AFINSQ_1:66;
end;
suppose k = ( 0 );

hence ( IC ( Comput (P3,s3,k) ) ) in ( dom ( if>0 (a,I,J) ) ) by A5,A7,EXTPRO_1:2;
end;
end;
hence ( if>0 (a,I,J) ) is_closed_on s,P by SCMFSA7B:def 6;
( CurInstr (P3,( Comput (P3,s3,( ( LifeSpan (P1,s1) ) + 1 )) )) ) = ( CurInstr (P3,( Comput (P3,s4,( LifeSpan (P1,s1) )) )) ) by EXTPRO_1:4
.= ( IncAddr (( CurInstr (P1,( Comput (P1,s1,( LifeSpan (P1,s1) )) )) ),( ( card J ) + 3 )) ) by A24,A19,A18,CKB9:1,A14,A1
.= ( IncAddr (( halt ( SCM+FSA ) ),( ( card J ) + 3 )) ) by A23,EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_1:11;
then P3 halts_on s3 by EXTPRO_1:29;
hence thesis by SCMFSA7B:def 7;
end;
