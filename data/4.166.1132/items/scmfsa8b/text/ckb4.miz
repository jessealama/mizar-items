environ
vocabularies NUMBERS,SCMFSA_2,AMI_1,AMISTD_2,CARD_1,TARSKI,TURING_1,SCMFSA6A,FUNCT_4,FSM_1,RELAT_1,UNIALG_2,CIRCUIT2,FUNCT_1,SF_MASTR,SUBSET_1,ARYTM_3,SCMFSA7B,SCMFSA6B,SCMFSA6C,AMI_3,SCMFSA8A,NAT_1,GRAPHSP,XXREAL_0,MSUALG_1,STRUCT_0,ARYTM_1,INT_1,COMPLEX1,PARTFUN1,FINSEQ_1,FINSEQ_2,SCMFSA8B,ORDINAL1,SCMNORM,RELOC,PBOOLE,FUNCOP_1,XBOOLE_0,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCOP_1,FUNCT_4,PBOOLE,FUNCT_7,FINSEQ_1,FINSEQ_2,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,INT_2,XXREAL_0;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,STRUCT_0,SCMFSA6A,MEMSTR_0;
theorems TARSKI,NAT_1,FUNCT_1,FUNCT_4,SCMFSA_2,MEMSTR_0,SCMFSA6A,GRFUNC_1,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,RELAT_1,XBOOLE_1,XREAL_1,ORDINAL1,FUNCOP_1,XXREAL_0,PARTFUN1,AFINSQ_1,SCMFSA10,COMPOS_1,EXTPRO_1,AMISTD_2,PBOOLE,AMISTD_1,CKB1,CKB2,CKB3;
schemes NAT_1;
registrations SETFAM_1,FUNCT_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SF_MASTR,SCMFSA6A,SCMFSA6B,SCMFSA6C,ORDINAL1,MEMSTR_0,XBOOLE_0,FINSET_1,RELSET_1,SCMFSA10,AMISTD_2,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,FUNCOP_1,AMISTD_1,RELAT_1,STRUCT_0;
constructors DOMAIN_1,XXREAL_0,NAT_1,INT_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,AMISTD_2,RELSET_1,SCMFSA7B,PRE_POLY,AMISTD_1,PBOOLE,FUNCOP_1,FUNCT_4,MEMSTR_0;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve P1 for (Instruction-Sequence of ( SCM+FSA ));
reserve P2 for (Instruction-Sequence of ( SCM+FSA ));
theorem
Th6: (for s1,s2 being (State of ( SCM+FSA )) holds (for I being (Program of ( SCM+FSA )) holds (( DataPart s1 ) = ( DataPart s2 ) implies (I is_closed_on s1,P1 implies I is_closed_on s2,P2))))
proof
let s1 being (State of ( SCM+FSA ));
let s2 being (State of ( SCM+FSA ));
let I being (Program of ( SCM+FSA ));
set S1 = ( Initialize s1 );
set S2 = ( Initialize s2 );
assume A2: ( DataPart s1 ) = ( DataPart s2 );
A3: ( Comput (( P2 +* I ),S2,( 0 )) ) = ( Initialize s2 ) by EXTPRO_1:2;
A4: ( Comput (( P1 +* I ),S1,( 0 )) ) = ( Initialize s1 ) by EXTPRO_1:2;
then A5: ( DataPart ( Comput (( P1 +* I ),S1,( 0 )) ) ) = ( DataPart s1 ) by MEMSTR_0:79
.= ( DataPart ( Comput (( P2 +* I ),S2,( 0 )) ) ) by A2,A3,MEMSTR_0:79;
assume A6: I is_closed_on s1,P1;
then A7: ( 0 ) in ( dom I ) by CKB2:1;
defpred P[ Nat ]
 means
((( IC ( Comput (( P1 +* I ),S1,$1) ) ) = ( IC ( Comput (( P2 +* I ),S2,$1) ) ) & ( CurInstr (( P1 +* I ),( Comput (( P1 +* I ),S1,$1) )) ) = ( CurInstr (( P2 +* I ),( Comput (( P2 +* I ),S2,$1) )) )) & ( DataPart ( Comput (( P1 +* I ),S1,$1) ) ) = ( DataPart ( Comput (( P2 +* I ),S2,$1) ) ));
A8:now
let k being (Element of ( NAT ));
A9: ( Comput (( P2 +* I ),S2,( k + 1 )) ) = ( Following (( P2 +* I ),( Comput (( P2 +* I ),S2,k) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( P2 +* I ),( Comput (( P2 +* I ),S2,k) )) ),( Comput (( P2 +* I ),S2,k) )) );
assume A10: P[ k ];
then A11: (for f being FinSeq-Location holds ( ( Comput (( P1 +* I ),S1,k) ) . f ) = ( ( Comput (( P2 +* I ),S2,k) ) . f )) by SCMFSA6A:7;
(for a being Int-Location holds ( ( Comput (( P1 +* I ),S1,k) ) . a ) = ( ( Comput (( P2 +* I ),S2,k) ) . a )) by A10,SCMFSA6A:7;
then A12: ( Comput (( P1 +* I ),S1,k) ) = ( Comput (( P2 +* I ),S2,k) ) by A10,A11,SCMFSA_2:61;
A13: ( IC ( Comput (( P1 +* I ),S1,( k + 1 )) ) ) in ( dom I ) by A6,SCMFSA7B:def 6;
( Comput (( P1 +* I ),S1,( k + 1 )) ) = ( Following (( P1 +* I ),( Comput (( P1 +* I ),S1,k) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( P1 +* I ),( Comput (( P1 +* I ),S1,k) )) ),( Comput (( P1 +* I ),S1,k) )) );
then A14: ( Comput (( P1 +* I ),S1,( k + 1 )) ) = ( Comput (( P2 +* I ),S2,( k + 1 )) ) by A10,A12,A9;
A15: ( IC ( Comput (( P1 +* I ),S1,( k + 1 )) ) ) = ( IC ( Comput (( P2 +* I ),S2,( k + 1 )) ) ) by A14;
A16: ( ( P1 +* I ) /. ( IC ( Comput (( P1 +* I ),S1,( k + 1 )) ) ) ) = ( ( P1 +* I ) . ( IC ( Comput (( P1 +* I ),S1,( k + 1 )) ) ) ) by PBOOLE:143;
A17: ( ( P2 +* I ) /. ( IC ( Comput (( P2 +* I ),S2,( k + 1 )) ) ) ) = ( ( P2 +* I ) . ( IC ( Comput (( P2 +* I ),S2,( k + 1 )) ) ) ) by PBOOLE:143;
A18: I c= ( P1 +* I ) by FUNCT_4:25;
A19: I c= ( P2 +* I ) by FUNCT_4:25;
( CurInstr (( P1 +* I ),( Comput (( P1 +* I ),S1,( k + 1 )) )) ) = ( I . ( IC ( Comput (( P1 +* I ),S1,( k + 1 )) ) ) ) by A13,A16,A18,GRFUNC_1:2
.= ( CurInstr (( P2 +* I ),( Comput (( P2 +* I ),S2,( k + 1 )) )) ) by A15,A13,A17,A19,GRFUNC_1:2;
hence P[ ( k + 1 ) ] by A14;
end;
A20: ( ( P1 +* I ) /. ( IC ( Comput (( P1 +* I ),S1,( 0 )) ) ) ) = ( ( P1 +* I ) . ( IC ( Comput (( P1 +* I ),S1,( 0 )) ) ) ) by PBOOLE:143;
A21: ( ( P2 +* I ) /. ( IC ( Comput (( P2 +* I ),S2,( 0 )) ) ) ) = ( ( P2 +* I ) . ( IC ( Comput (( P2 +* I ),S2,( 0 )) ) ) ) by PBOOLE:143;
B22: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) by MEMSTR_0:15;
then A23: ( IC ( Comput (( P2 +* I ),S2,( 0 )) ) ) = ( IC ( Start-At (( 0 ),( SCM+FSA )) ) ) by A3,FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
A24: ( IC ( Comput (( P1 +* I ),S1,( 0 )) ) ) = ( IC ( Start-At (( 0 ),( SCM+FSA )) ) ) by A4,B22,FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
then ( CurInstr (( P1 +* I ),( Comput (( P1 +* I ),S1,( 0 )) )) ) = ( I . ( 0 ) ) by A7,A20,FUNCT_4:13
.= ( CurInstr (( P2 +* I ),( Comput (( P2 +* I ),S2,( 0 )) )) ) by A23,A7,A21,FUNCT_4:13;
then A25: P[ ( 0 ) ] by A24,A23,A5;
now
let k being (Element of ( NAT ));
A26: ( IC ( Comput (( P1 +* I ),S1,k) ) ) in ( dom I ) by A6,SCMFSA7B:def 6;
(for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A25,A8);
hence ( IC ( Comput (( P2 +* I ),S2,k) ) ) in ( dom I ) by A26;
end;
hence thesis by SCMFSA7B:def 6;
end;
