environ
vocabularies NUMBERS,SCMFSA_2,AMI_1,AMISTD_2,CARD_1,TARSKI,TURING_1,SCMFSA6A,FUNCT_4,FSM_1,RELAT_1,UNIALG_2,CIRCUIT2,FUNCT_1,SF_MASTR,SUBSET_1,ARYTM_3,SCMFSA7B,SCMFSA6B,SCMFSA6C,AMI_3,SCMFSA8A,NAT_1,GRAPHSP,XXREAL_0,MSUALG_1,STRUCT_0,ARYTM_1,INT_1,COMPLEX1,PARTFUN1,FINSEQ_1,FINSEQ_2,SCMFSA8B,ORDINAL1,SCMNORM,RELOC,PBOOLE,FUNCOP_1,XBOOLE_0,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCOP_1,FUNCT_4,PBOOLE,FUNCT_7,FINSEQ_1,FINSEQ_2,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,SCMFSA_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,INT_2,XXREAL_0,CKB12,CKB13,CKB14;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,STRUCT_0,SCMFSA6A,MEMSTR_0,CKB12,CKB13,CKB14;
theorems TARSKI,NAT_1,FUNCT_1,FUNCT_4,SCMFSA_2,MEMSTR_0,SCMFSA6A,GRFUNC_1,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA7B,SCMFSA8A,RELAT_1,XBOOLE_1,XREAL_1,ORDINAL1,FUNCOP_1,XXREAL_0,PARTFUN1,AFINSQ_1,SCMFSA10,COMPOS_1,EXTPRO_1,AMISTD_2,PBOOLE,AMISTD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26;
schemes NAT_1;
registrations SETFAM_1,FUNCT_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,SCMFSA_2,SF_MASTR,SCMFSA6A,SCMFSA6B,SCMFSA6C,ORDINAL1,MEMSTR_0,XBOOLE_0,FINSET_1,RELSET_1,SCMFSA10,AMISTD_2,COMPOS_1,EXTPRO_1,PBOOLE,FUNCT_4,FUNCOP_1,AMISTD_1,RELAT_1,STRUCT_0;
constructors DOMAIN_1,XXREAL_0,NAT_1,INT_2,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,AMISTD_2,RELSET_1,SCMFSA7B,PRE_POLY,AMISTD_1,PBOOLE,FUNCOP_1,FUNCT_4,MEMSTR_0,CKB12,CKB13,CKB14;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve P for (Instruction-Sequence of ( SCM+FSA ));
theorem
Th24: (for s being (State of ( SCM+FSA )) holds (for I,J being (Program of ( SCM+FSA )) holds (for a being  read-write Int-Location holds (((( s . a ) <= ( 0 ) & J is_closed_on s,P) & J is_halting_on s,P) implies (( if>0 (a,I,J) ) is_closed_on s,P & ( if>0 (a,I,J) ) is_halting_on s,P)))))
proof
let s being (State of ( SCM+FSA ));
let I being (Program of ( SCM+FSA ));
let J being (Program of ( SCM+FSA ));
let a being  read-write Int-Location;
set I1 = ( I ';' ( Stop ( SCM+FSA ) ) );
set JI2 = ( ( ( J ';' ( Goto ( ( card I ) + 1 ) ) ) ';' I ) ';' ( Stop ( SCM+FSA ) ) );
set s2 = ( Initialize s );
set P2 = ( P +* JI2 );
A1: JI2 c= P2 by FUNCT_4:25;
set s3 = ( Initialize s );
set P3 = ( P +* ( if>0 (a,I,J) ) );
set s4 = ( Comput (P3,s3,1) );
set s5 = ( Comput (P3,s3,2) );
set i = ( a >0_goto ( ( card J ) + 3 ) );
( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) by MEMSTR_0:15;
then A5: ( IC s3 ) = ( IC ( Start-At (( 0 ),( SCM+FSA )) ) ) by FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
A8: ( if>0 (a,I,J) ) c= P3 by FUNCT_4:25;
A9: ( if>0 (a,I,J) ) = ( ( ( i ';' J ) ';' ( Goto ( ( card I ) + 1 ) ) ) ';' I1 ) by SCMFSA6A:25
.= ( ( i ';' J ) ';' ( ( Goto ( ( card I ) + 1 ) ) ';' I1 ) ) by SCMFSA6A:25
.= ( i ';' ( J ';' ( ( Goto ( ( card I ) + 1 ) ) ';' I1 ) ) ) by SCMFSA6A:29
.= ( i ';' ( ( J ';' ( Goto ( ( card I ) + 1 ) ) ) ';' I1 ) ) by SCMFSA6A:25
.= ( ( Macro i ) ';' JI2 ) by SCMFSA6A:25;
then A10: ( Reloc (JI2,( card ( Macro i ) )) ) c= ( if>0 (a,I,J) ) by CKB1:1;
( card ( Macro i ) ) = 2 by COMPOS_1:56;
then A12: ( Reloc (JI2,2) ) c= P3 by A8,A10,XBOOLE_1:1;
B13: (not a in ( dom ( Start-At (( 0 ),( SCM+FSA )) ) )) by SCMFSA_2:102;
A14: ( 0 ) in ( dom ( if>0 (a,I,J) ) ) by CKB15:1;
A15: ( P3 . ( 0 ) ) = ( ( if>0 (a,I,J) ) . ( 0 ) ) by A14,FUNCT_4:13
.= i by CKB16:1;
A16: 1 in ( dom ( if>0 (a,I,J) ) ) by CKB15:1;
A17: ( Comput (P3,s3,( ( 0 ) + 1 )) ) = ( Following (P3,( Comput (P3,s3,( 0 )) )) ) by EXTPRO_1:3
.= ( Following (P3,s3) ) by EXTPRO_1:2
.= ( Exec (i,s3) ) by A5,A15,PBOOLE:143;
assume ( s . a ) <= ( 0 );
then ( s3 . a ) <= ( 0 ) by B13,FUNCT_4:11;
then A18: ( IC ( Comput (P3,s3,1) ) ) = ( succ ( 0 ) ) by A5,A17,SCMFSA_2:71
.= ( ( 0 ) + 1 );
A19: ( P3 . 1 ) = ( ( if>0 (a,I,J) ) . 1 ) by A16,FUNCT_4:13
.= ( goto 2 ) by CKB16:1;
assume A20: J is_closed_on s,P;
A21: ( Comput (P3,s3,( 1 + 1 )) ) = ( Following (P3,s4) ) by EXTPRO_1:3
.= ( Exec (( goto 2 ),s4) ) by A18,A19,PBOOLE:143;
A23:now
let f being FinSeq-Location;
thus ( s2 . f ) = ( ( Comput (P3,s3,1) ) . f ) by A17,SCMFSA_2:71
.= ( s5 . f ) by A21,SCMFSA_2:69;
end;
now
let a being Int-Location;
thus ( s2 . a ) = ( ( Comput (P3,s3,1) ) . a ) by A17,SCMFSA_2:71
.= ( s5 . a ) by A21,SCMFSA_2:69;
end;
then A24: ( DataPart s2 ) = ( DataPart s5 ) by A23,SCMFSA6A:7;
assume A25: J is_halting_on s,P;
then A26: JI2 is_closed_on s,P by A20,SCMFSA8A:37;
then A27: JI2 is_closed_on s2,P2 by CKB8:1;
A28: P2 halts_on s2 by A20,A25,SCMFSA8A:38;
A29: ( IC s5 ) = 2 by A21,SCMFSA_2:69;
now
let k being (Element of ( NAT ));
(k = ( 0 ) or ( ( 0 ) + 1 ) < ( k + 1 )) by XREAL_1:6;
then A30: (k = ( 0 ) or 1 <= k) by NAT_1:13;
per cases  by A30,XXREAL_0:1;
suppose A31: 1 < k;

then consider k1 being Nat such that A32: ( k1 + 1 ) = k by NAT_1:6;
( ( 0 ) + 1 ) < ( k1 + 1 ) by A31,A32;
then consider k2 being Nat such that A33: ( k2 + 1 ) = k1 by NAT_1:6;
reconsider k1,k2 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider m = ( IC ( Comput (P2,s2,k2) ) ) as (Element of ( NAT ));
A34: ( card ( if>0 (a,I,J) ) ) = ( ( card ( Macro i ) ) + ( card JI2 ) ) by A9,SCMFSA6A:21
.= ( 2 + ( card JI2 ) ) by COMPOS_1:56;
m in ( dom JI2 ) by A26,SCMFSA7B:def 6;
then m < ( card JI2 ) by AFINSQ_1:66;
then A35: ( m + 2 ) < ( card ( if>0 (a,I,J) ) ) by A34,XREAL_1:6;
( IC ( Comput (P3,s3,k) ) ) = ( IC ( Comput (P3,s4,k1) ) ) by A32,EXTPRO_1:4
.= ( IC ( Comput (P3,( Comput (P3,s4,1) ),k2) ) ) by A33,EXTPRO_1:4
.= ( IC ( Comput (P3,( Comput (P3,s3,( 1 + 1 )) ),k2) ) ) by EXTPRO_1:4
.= ( m + 2 ) by A27,A29,A24,CKB9:1,A12,A1;
hence ( IC ( Comput (P3,s3,k) ) ) in ( dom ( if>0 (a,I,J) ) ) by A35,AFINSQ_1:66;
end;
suppose k = ( 0 );

hence ( IC ( Comput (P3,s3,k) ) ) in ( dom ( if>0 (a,I,J) ) ) by A14,A5,EXTPRO_1:2;
end;
suppose k = 1;

hence ( IC ( Comput (P3,s3,k) ) ) in ( dom ( if>0 (a,I,J) ) ) by A18,CKB15:1;
end;
end;
hence ( if>0 (a,I,J) ) is_closed_on s,P by SCMFSA7B:def 6;
( CurInstr (P3,( Comput (P3,s3,( ( LifeSpan (P2,s2) ) + 2 )) )) ) = ( CurInstr (P3,( Comput (P3,s5,( LifeSpan (P2,s2) )) )) ) by EXTPRO_1:4
.= ( IncAddr (( CurInstr (P2,( Comput (P2,s2,( LifeSpan (P2,s2) )) )) ),2) ) by A27,A12,A29,A24,CKB9:1,A1
.= ( IncAddr (( halt ( SCM+FSA ) ),2) ) by A28,EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_1:11;
then P3 halts_on s3 by EXTPRO_1:29;
hence thesis by SCMFSA7B:def 7;
end;
