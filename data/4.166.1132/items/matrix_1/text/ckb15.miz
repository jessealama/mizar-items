environ
vocabularies NUMBERS,NAT_1,XBOOLE_0,ALGSTR_0,FINSEQ_1,SUBSET_1,RLVECT_1,RELAT_1,CARD_1,FINSEQ_2,TARSKI,STRUCT_0,TREES_1,XXREAL_0,ZFMISC_1,FUNCT_1,QC_LANG1,INCSP_1,SUPINF_2,MESFUNC1,ARYTM_1,ARYTM_3,VECTSP_1,BINOP_1,MATRIX_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,NAT_1,FUNCT_1,FUNCT_2,FINSEQ_1,FINSEQ_2,STRUCT_0,ALGSTR_0,BINOP_1,FINSEQOP,RLVECT_1,VECTSP_1,XXREAL_0,CKB1,CKB12;
definitions TARSKI,RLVECT_1,BINOP_1,FINSEQ_2,STRUCT_0,ALGSTR_0,CKB1;
theorems FINSEQ_1,FINSEQ_2,FINSEQ_3,TARSKI,FUNCOP_1,FUNCT_1,FUNCT_2,ZFMISC_1,NAT_1,BINOP_1,RLVECT_1,RELAT_1,ORDINAL1,CARD_1,CARD_2,XXREAL_0,CKB1,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB14;
schemes FINSEQ_1,BINOP_1,FINSEQ_2;
registrations XBOOLE_0,RELAT_1,FUNCT_1,XREAL_0,FINSEQ_1,FINSEQ_2,STRUCT_0,VECTSP_1,ORDINAL1,CARD_1,CKB2,CKB11,CKB13;
constructors BINOP_1,XXREAL_0,FINSEQOP,VECTSP_1,RLVECT_1,RELSET_1,CKB1;
requirements NUMERALS,SUBSET,BOOLE,REAL;
begin
reserve x for set;
reserve n for Nat;
reserve m for Nat;
reserve D for non empty set;
reserve p for (FinSequence of D);
definition
let D;
let m;
let n;
mode Matrix of m,n,D
 -> (Matrix of D)
means :Def3: (( len it ) = m & (for p holds (p in ( rng it ) implies ( len p ) = n)));
existence
proof
reconsider m1 = m,n1 = n as (Element of ( NAT )) by ORDINAL1:def 12;
set a = the (Element of D);
reconsider d = ( n1 |-> a ) as (Element of ( D * )) by FINSEQ_1:def 11;
reconsider M = ( m1 |-> d ) as (FinSequence of ( D * ));
(ex n being (Element of ( NAT )) st (for x holds (x in ( rng M ) implies (ex p st (x = p & ( len p ) = n)))))
proof
reconsider p = ( n1 |-> a ) as (FinSequence of D);
take n1;
let x;
assume A1: x in ( rng M );
take p;
( rng M ) c= { ( n |-> a ) } by FUNCOP_1:13;
hence thesis by A1,CARD_1:def 7,TARSKI:def 1;
end;
then reconsider M as (Matrix of D) by CKB14:1;
take M;
thus ( len M ) = m by CARD_1:def 7;
let p;
A2: ( rng M ) c= { ( n |-> a ) } by FUNCOP_1:13;
assume p in ( rng M );
then p = ( n |-> a ) by A2,TARSKI:def 1;
hence thesis by CARD_1:def 7;
end;
end;
