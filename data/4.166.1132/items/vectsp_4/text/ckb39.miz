environ
vocabularies RLVECT_1,ALGSTR_0,BINOP_1,VECTSP_1,LATTICES,XBOOLE_0,SUBSET_1,ARYTM_1,RELAT_1,ARYTM_3,RLSUB_1,SUPINF_2,GROUP_1,STRUCT_0,TARSKI,REALSET1,ZFMISC_1,FUNCT_1,MESFUNC1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,REALSET1,FUNCT_1,FUNCT_2,STRUCT_0,ALGSTR_0,DOMAIN_1,BINOP_1,RLVECT_1,GROUP_1,VECTSP_1,CKB2,CKB10;
definitions TARSKI,RLVECT_1,XBOOLE_0,BINOP_1,REALSET1,STRUCT_0,ALGSTR_0,VECTSP_1,CKB2,CKB10;
theorems FUNCT_1,FUNCT_2,TARSKI,VECTSP_1,ZFMISC_1,RLVECT_1,RELAT_1,VECTSP_2,RELSET_1,XBOOLE_0,XBOOLE_1,STRUCT_0,ALGSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB34,CKB35,CKB36,CKB37,CKB38;
schemes XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,REALSET1,STRUCT_0,VECTSP_1,RELAT_1,ALGSTR_0,CKB33;
constructors PARTFUN1,BINOP_1,REALSET1,VECTSP_1,RLVECT_1,RELSET_1,CKB2,CKB10;
requirements SUBSET,BOOLE;
begin
reserve x for set;
reserve y for set;
reserve y1 for set;
reserve y2 for set;
reserve GF for  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
reserve V for  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over GF;
reserve a for (Element of GF);
reserve v for (Element of V);
reserve W for (Subspace of V);
reserve V1 for (Subset of V);
reserve w for (Element of W);
theorem
Th42: ((V1 <> ( {} ) & V1 is  linearly-closed) implies (ex W being  strict (Subspace of V) st V1 = (the carrier of W)))
proof
assume that
A1: V1 <> ( {} )
and
A2: V1 is  linearly-closed;
reconsider D = V1 as non  empty set by A1;
reconsider d = ( 0. V ) as (Element of D) by A2,CKB3:1;
set VV = (the carrier of V);
set C = ( ( comp V ) | D );
( dom ( comp V ) ) = VV by FUNCT_2:def 1;
then A3: ( dom C ) = D by RELAT_1:62;
A4: ( rng C ) c= D
proof
let x;
assume x in ( rng C );
then consider y such that A5: y in ( dom C ) and A6: ( C . y ) = x by FUNCT_1:def 3;
reconsider y as (Element of V) by A3,A5;
x = ( ( comp V ) . y ) by A5,A6,FUNCT_1:47
.= ( - y ) by VECTSP_1:def 13;
hence thesis by A2,A3,A5,CKB4:1;
end;
set M = ( (the lmult of V) | ([: (the carrier of GF),D :] qua set) );
( dom (the lmult of V) ) = [: (the carrier of GF),VV :] by FUNCT_2:def 1;
then A7: ( dom M ) = [: (the carrier of GF),D :] by RELAT_1:62,ZFMISC_1:96;
A8: ( rng M ) c= D
proof
let x;
assume x in ( rng M );
then consider y such that A9: y in ( dom M ) and A10: ( M . y ) = x by FUNCT_1:def 3;
consider y1,y2 such that A11: [ y1,y2 ] = y by A7,A9,RELAT_1:def 1;
reconsider y1 as (Element of GF) by A7,A9,A11,ZFMISC_1:87;
A12: y2 in V1 by A7,A9,A11,ZFMISC_1:87;
then reconsider y2 as (Element of V);
x = ( y1 * y2 ) by A9,A10,A11,FUNCT_1:47;
hence thesis by A2,A12,CKB2:def 1;
end;
set A = ( (the addF of V) || D );
( dom (the addF of V) ) = [: VV,VV :] by FUNCT_2:def 1;
then A13: ( dom A ) = [: D,D :] by RELAT_1:62,ZFMISC_1:96;
A14: ( rng A ) c= D
proof
let x;
assume x in ( rng A );
then consider y such that A15: y in ( dom A ) and A16: ( A . y ) = x by FUNCT_1:def 3;
consider y1,y2 such that A17: [ y1,y2 ] = y by A13,A15,RELAT_1:def 1;
A18: (y1 in D & y2 in D) by A13,A15,A17,ZFMISC_1:87;
then reconsider y1,y2 as (Element of V);
x = ( y1 + y2 ) by A15,A16,A17,FUNCT_1:47;
hence thesis by A2,A18,CKB2:def 1;
end;
reconsider M as (Function of [: (the carrier of GF),D :],D) by A7,A8,FUNCT_2:def 1,RELSET_1:4;
reconsider C as (UnOp of D) by A3,A4,FUNCT_2:def 1,RELSET_1:4;
reconsider A as (BinOp of D) by A13,A14,FUNCT_2:def 1,RELSET_1:4;
set W = VectSpStr (# D,A,d,M #);
A19: (for a,b being (Element of W) holds (for x,y being (Element of V) holds ((x = a & b = y) implies ( a + b ) = ( x + y ))))
proof
let a being (Element of W);
let b being (Element of W);
let x being (Element of V);
let y being (Element of V);
assume that
A20: (x = a & b = y);
thus ( a + b ) = ( A . [ a,b ] )
.= ( x + y ) by A13,A20,FUNCT_1:47;
end;
A21: W is  Abelian  add-associative  right_zeroed  right_complementable
proof
thus W is  Abelian
proof
let a being (Element of W);
let b being (Element of W);
reconsider x = a,y = b as (Element of V) by TARSKI:def 3;
thus ( a + b ) = ( y + x ) by A19
.= ( b + a ) by A19;
end;

hereby
let a being (Element of W);
let b being (Element of W);
let c being (Element of W);
reconsider x = a,y = b,z = c as (Element of V) by TARSKI:def 3;
A22: ( b + c ) = ( y + z ) by A19;
( a + b ) = ( x + y ) by A19;
hence ( ( a + b ) + c ) = ( ( x + y ) + z ) by A19
.= ( x + ( y + z ) ) by RLVECT_1:def 3
.= ( a + ( b + c ) ) by A19,A22;
end;
hereby
let a being (Element of W);
reconsider x = a as (Element of V) by TARSKI:def 3;
thus ( a + ( 0. W ) ) = ( x + ( 0. V ) ) by A19
.= a by RLVECT_1:4;
end;
let a being (Element of W);
reconsider x = a as (Element of V) by TARSKI:def 3;
reconsider a9 = a as (Element of D);
reconsider b = ( C . a9 ) as (Element of D);
reconsider b as (Element of W);
take b;
thus ( a + b ) = ( x + ( ( comp V ) . x ) ) by A3,A19,FUNCT_1:47
.= ( x + ( - x ) ) by VECTSP_1:def 13
.= ( 0. W ) by RLVECT_1:5;
end;
A23: W is  vector-distributive
proof
let a being (Element of GF);
let v being (Element of W);
let w being (Element of W);
reconsider x = v,y = w as (Element of V) by TARSKI:def 3;
A24:now
let a being (Element of GF);
let x being (Element of W);
let y being (Element of V);
assume A25: y = x;
[ a,x ] in ( dom M ) by A7;
hence ( a * x ) = ( a * y ) by A25,FUNCT_1:47;
end;
then A26: ( a * v ) = ( a * x );
A27: ( a * w ) = ( a * y ) by A24;
( v + w ) = ( x + y ) by A19;
hence ( a * ( v + w ) ) = ( a * ( x + y ) ) by A24
.= ( ( a * x ) + ( a * y ) ) by VECTSP_1:def 14
.= ( ( a * v ) + ( a * w ) ) by A19,A26,A27;
end;
A28: W is  scalar-distributive
proof
let a being (Element of GF);
let b being (Element of GF);
let v being (Element of W);
reconsider x = v as (Element of V) by TARSKI:def 3;
A29:now
let a being (Element of GF);
let x being (Element of W);
let y being (Element of V);
assume A30: y = x;
[ a,x ] in ( dom M ) by A7;
hence ( a * x ) = ( a * y ) by A30,FUNCT_1:47;
end;
then A31: ( a * v ) = ( a * x );
A32: ( b * v ) = ( b * x ) by A29;
thus ( ( a + b ) * v ) = ( ( a + b ) * x ) by A29
.= ( ( a * x ) + ( b * x ) ) by VECTSP_1:def 15
.= ( ( a * v ) + ( b * v ) ) by A19,A32,A31;
end;
A33: W is  scalar-associative
proof
let a being (Element of GF);
let b being (Element of GF);
let v being (Element of W);
reconsider x = v as (Element of V) by TARSKI:def 3;
A34:now
let a being (Element of GF);
let x being (Element of W);
let y being (Element of V);
assume A35: y = x;
[ a,x ] in ( dom M ) by A7;
hence ( a * x ) = ( a * y ) by A35,FUNCT_1:47;
end;
then A36: ( b * v ) = ( b * x );
thus ( ( a * b ) * v ) = ( ( a * b ) * x ) by A34
.= ( a * ( b * x ) ) by VECTSP_1:def 16
.= ( a * ( b * v ) ) by A34,A36;
end;
W is  scalar-unital
proof
let v being (Element of W);
reconsider x = v as (Element of V) by TARSKI:def 3;
now
let a being (Element of GF);
let x being (Element of W);
let y being (Element of V);
assume A37: y = x;
[ a,x ] in ( dom M ) by A7;
hence ( a * x ) = ( a * y ) by A37,FUNCT_1:47;
end;
hence ( ( 1. GF ) * v ) = ( ( 1_ GF ) * x )
.= v by VECTSP_1:def 17;
end;
then reconsider W as  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over GF by A21,A23,A28,A33;
( 0. W ) = ( 0. V );
then reconsider W as  strict (Subspace of V) by CKB10:def 1;
take W;
thus thesis;
end;
