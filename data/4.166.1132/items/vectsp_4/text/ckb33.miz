environ
vocabularies RLVECT_1,ALGSTR_0,BINOP_1,VECTSP_1,LATTICES,XBOOLE_0,SUBSET_1,ARYTM_1,RELAT_1,ARYTM_3,RLSUB_1,SUPINF_2,GROUP_1,STRUCT_0,TARSKI,REALSET1,ZFMISC_1,FUNCT_1,MESFUNC1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,REALSET1,FUNCT_1,FUNCT_2,STRUCT_0,ALGSTR_0,DOMAIN_1,BINOP_1,RLVECT_1,GROUP_1,VECTSP_1,CKB2,CKB10;
definitions TARSKI,RLVECT_1,XBOOLE_0,BINOP_1,REALSET1,STRUCT_0,ALGSTR_0,VECTSP_1,CKB2,CKB10;
theorems FUNCT_1,FUNCT_2,TARSKI,VECTSP_1,ZFMISC_1,RLVECT_1,RELAT_1,VECTSP_2,RELSET_1,XBOOLE_0,XBOOLE_1,STRUCT_0,ALGSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32;
schemes XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,REALSET1,STRUCT_0,VECTSP_1,RELAT_1,ALGSTR_0;
constructors PARTFUN1,BINOP_1,REALSET1,VECTSP_1,RLVECT_1,RELSET_1,CKB2,CKB10;
requirements SUBSET,BOOLE;
begin
registration
let GF being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non empty doubleLoopStr;
let V being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non empty VectSpStr over GF;
cluster  strict for (Subspace of V);
existence
proof
set M = (the lmult of V);
set W = VectSpStr (# (the carrier of V),(the addF of V),( 0. V ),M #);
A1: W is  vector-distributive
proof
let a being (Element of GF);
let v being (Element of W),w being (Element of W);
reconsider x = v,y = w as (Element of V);
thus ( a * ( v + w ) ) = ( a * ( x + y ) )
.= ( ( a * x ) + ( a * y ) ) by VECTSP_1:def 14
.= ( ( a * v ) + ( a * w ) );
end;
A2: W is  scalar-distributive
proof
let a being (Element of GF),b being (Element of GF);
let v being (Element of W);
reconsider x = v as (Element of V);
thus ( ( a + b ) * v ) = ( ( a + b ) * x )
.= ( ( a * x ) + ( b * x ) ) by VECTSP_1:def 15
.= ( ( a * v ) + ( b * v ) );
end;
A3: W is  scalar-associative
proof
let a being (Element of GF),b being (Element of GF);
let v being (Element of W);
reconsider x = v as (Element of V);
thus ( ( a * b ) * v ) = ( ( a * b ) * x )
.= ( a * ( b * x ) ) by VECTSP_1:def 16
.= ( a * ( b * v ) );
end;
A4: W is  scalar-unital
proof
let v being (Element of W);
reconsider x = v as (Element of V);
thus ( ( 1. GF ) * v ) = ( ( 1_ GF ) * x )
.= v by VECTSP_1:def 17;
end;
A5: (for a,b being (Element of W) holds (for x,y being (Element of V) holds ((x = a & b = y) implies ( a + b ) = ( x + y ))));
W is  Abelian  add-associative  right_zeroed  right_complementable
proof
thus W is  Abelian
proof
let a being (Element of W),b being (Element of W);
reconsider x = a,y = b as (Element of V);
thus ( a + b ) = ( y + x ) by A5
.= ( b + a );
end;

hereby
let a being (Element of W),b being (Element of W),c being (Element of W);
reconsider x = a,y = b,z = c as (Element of V);
thus ( ( a + b ) + c ) = ( ( x + y ) + z )
.= ( x + ( y + z ) ) by RLVECT_1:def 3
.= ( a + ( b + c ) );
end;
hereby
let a being (Element of W);
reconsider x = a as (Element of V);
thus ( a + ( 0. W ) ) = ( x + ( 0. V ) )
.= a by RLVECT_1:4;
end;
let a being (Element of W);
reconsider x = a as (Element of V);
reconsider b = ( ( comp V ) . x ) as (Element of W);
take b;
thus ( a + b ) = ( x + ( - x ) ) by VECTSP_1:def 13
.= ( 0. W ) by RLVECT_1:5;
end;
then reconsider W as  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non empty VectSpStr over GF by A1,A2,A3,A4;
A6: (( 0. W ) = ( 0. V ) & (the addF of W) = ( (the addF of V) || (the carrier of W) )) by RELSET_1:19;
(the lmult of W) = ( (the lmult of V) | ([: (the carrier of GF),(the carrier of W) :] qua set) ) by RELSET_1:19;
then reconsider W as (Subspace of V) by A6,CKB10:def 1;
take W;
thus thesis;
end;
end;
