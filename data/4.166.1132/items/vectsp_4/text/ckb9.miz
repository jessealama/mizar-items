environ
vocabularies RLVECT_1,ALGSTR_0,BINOP_1,VECTSP_1,LATTICES,XBOOLE_0,SUBSET_1,ARYTM_1,RELAT_1,ARYTM_3,RLSUB_1,SUPINF_2,GROUP_1,STRUCT_0,TARSKI,REALSET1,ZFMISC_1,FUNCT_1,MESFUNC1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,REALSET1,FUNCT_1,FUNCT_2,STRUCT_0,ALGSTR_0,DOMAIN_1,BINOP_1,RLVECT_1,GROUP_1,VECTSP_1,CKB2;
definitions TARSKI,RLVECT_1,XBOOLE_0,BINOP_1,REALSET1,STRUCT_0,ALGSTR_0,VECTSP_1,CKB2;
theorems FUNCT_1,FUNCT_2,TARSKI,VECTSP_1,ZFMISC_1,RLVECT_1,RELAT_1,VECTSP_2,RELSET_1,XBOOLE_0,XBOOLE_1,STRUCT_0,ALGSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8;
schemes XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,REALSET1,STRUCT_0,VECTSP_1,RELAT_1,ALGSTR_0;
constructors PARTFUN1,BINOP_1,REALSET1,VECTSP_1,RLVECT_1,RELSET_1,CKB2;
requirements SUBSET,BOOLE;
begin
theorem
(for GF being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non empty doubleLoopStr holds (for V being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non empty VectSpStr over GF holds (for V1,V2 being (Subset of V) holds ((V1 is  linearly-closed & V2 is  linearly-closed) implies ( V1 /\ V2 ) is  linearly-closed))))
proof
let GF being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non empty doubleLoopStr;
let V being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non empty VectSpStr over GF;
let V1 being (Subset of V),V2 being (Subset of V);
assume that
A1: V1 is  linearly-closed
and
A2: V2 is  linearly-closed;
thus (for v,u being (Element of V) holds ((v in ( V1 /\ V2 ) & u in ( V1 /\ V2 )) implies ( v + u ) in ( V1 /\ V2 )))
proof
let v being (Element of V),u being (Element of V);
assume A3: (v in ( V1 /\ V2 ) & u in ( V1 /\ V2 ));
then (v in V2 & u in V2) by XBOOLE_0:def 4;
then A4: ( v + u ) in V2 by A2,CKB2:def 1;
(v in V1 & u in V1) by A3,XBOOLE_0:def 4;
then ( v + u ) in V1 by A1,CKB2:def 1;
hence thesis by A4,XBOOLE_0:def 4;
end;

let a being (Element of GF);
let v being (Element of V);
assume A5: v in ( V1 /\ V2 );
then v in V2 by XBOOLE_0:def 4;
then A6: ( a * v ) in V2 by A2,CKB2:def 1;
v in V1 by A5,XBOOLE_0:def 4;
then ( a * v ) in V1 by A1,CKB2:def 1;
hence thesis by A6,XBOOLE_0:def 4;
end;
