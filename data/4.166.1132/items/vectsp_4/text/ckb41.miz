environ
vocabularies RLVECT_1,ALGSTR_0,BINOP_1,VECTSP_1,LATTICES,XBOOLE_0,SUBSET_1,ARYTM_1,RELAT_1,ARYTM_3,RLSUB_1,SUPINF_2,GROUP_1,STRUCT_0,TARSKI,REALSET1,ZFMISC_1,FUNCT_1,MESFUNC1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,REALSET1,FUNCT_1,FUNCT_2,STRUCT_0,ALGSTR_0,DOMAIN_1,BINOP_1,RLVECT_1,GROUP_1,VECTSP_1,CKB2,CKB10,CKB40;
definitions TARSKI,RLVECT_1,XBOOLE_0,BINOP_1,REALSET1,STRUCT_0,ALGSTR_0,VECTSP_1,CKB2,CKB10,CKB40;
theorems FUNCT_1,FUNCT_2,TARSKI,VECTSP_1,ZFMISC_1,RLVECT_1,RELAT_1,VECTSP_2,RELSET_1,XBOOLE_0,XBOOLE_1,STRUCT_0,ALGSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40;
schemes XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,REALSET1,STRUCT_0,VECTSP_1,RELAT_1,ALGSTR_0,CKB33;
constructors PARTFUN1,BINOP_1,REALSET1,VECTSP_1,RLVECT_1,RELSET_1,CKB2,CKB10,CKB40;
requirements SUBSET,BOOLE;
begin
reserve GF for  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non empty doubleLoopStr;
reserve V for  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non empty VectSpStr over GF;
reserve a for (Element of GF);
definition
let GF;
let V;
func (Omega). V ->  strict (Subspace of V)
equals
( the VectSpStr of V );
coherence
proof
set W = ( the VectSpStr of V );
A1: W is  vector-distributive
proof
let x being (Element of GF);
let v being (Element of W),w being (Element of W);
reconsider v9 = v,w9 = w as (Element of V);
thus ( x * ( v + w ) ) = ( x * ( v9 + w9 ) )
.= ( ( x * v9 ) + ( x * w9 ) ) by VECTSP_1:def 14
.= ( ( x * v ) + ( x * w ) );
end;
A2: W is  scalar-distributive
proof
let x being (Element of GF),y being (Element of GF);
let v being (Element of W);
reconsider v9 = v as (Element of V);
thus ( ( x + y ) * v ) = ( ( x + y ) * v9 )
.= ( ( x * v9 ) + ( y * v9 ) ) by VECTSP_1:def 15
.= ( ( x * v ) + ( y * v ) );
end;
A3: W is  scalar-associative
proof
let x being (Element of GF),y being (Element of GF);
let v being (Element of W);
reconsider v9 = v as (Element of V);
thus ( ( x * y ) * v ) = ( ( x * y ) * v9 )
.= ( x * ( y * v9 ) ) by VECTSP_1:def 16
.= ( x * ( y * v ) );
end;
A4: W is  scalar-unital
proof
let v being (Element of W);
reconsider v9 = v as (Element of V);
thus ( ( 1. GF ) * v ) = ( ( 1_ GF ) * v9 )
.= v by VECTSP_1:def 17;
end;
A5: (for a holds (for v,w being (Element of W) holds (for v9,w9 being (Element of V) holds ((v = v9 & w = w9) implies (( v + w ) = ( v9 + w9 ) & ( a * v ) = ( a * v9 ))))));
W is  Abelian  add-associative  right_zeroed  right_complementable
proof
thus W is  Abelian
proof
let x being (Element of W),y being (Element of W);
reconsider x9 = x,y9 = y as (Element of V);
thus ( x + y ) = ( y9 + x9 ) by A5
.= ( y + x );
end;

hereby
let x being (Element of W),y being (Element of W),z being (Element of W);
reconsider x9 = x,y9 = y,z9 = z as (Element of V);
thus ( ( x + y ) + z ) = ( ( x9 + y9 ) + z9 )
.= ( x9 + ( y9 + z9 ) ) by RLVECT_1:def 3
.= ( x + ( y + z ) );
end;
hereby
let x being (Element of W);
reconsider x9 = x as (Element of V);
thus ( x + ( 0. W ) ) = ( x9 + ( 0. V ) )
.= x by RLVECT_1:4;
end;
let x being (Element of W);
reconsider x9 = x as (Element of V);
consider b being (Element of V) such that A6: ( x9 + b ) = ( 0. V ) by ALGSTR_0:def 11;
reconsider b9 = b as (Element of W);
take b9;
thus thesis by A6;
end;
then reconsider W as  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non empty VectSpStr over GF by A4,A1,A2,A3;
A7: (the lmult of W) = ( (the lmult of V) | ([: (the carrier of GF),(the carrier of W) :] qua set) ) by RELSET_1:19;
(( 0. W ) = ( 0. V ) & (the addF of W) = ( (the addF of V) || (the carrier of W) )) by RELSET_1:19;
hence thesis by A7,CKB10:def 1;
end;
end;
