environ
vocabularies NUMBERS,SUBSET_1,FUNCT_1,NAT_1,TARSKI,MEMBERED,ORDINAL1,FINSET_1,RELAT_1,AFINSQ_1,ARYTM_1,ARYTM_3,FINSEQ_1,XXREAL_0,CARD_1,XBOOLE_0,ORDINAL4,FINSEQ_5,RFINSEQ,JORDAN3,CARD_3,XCMPLX_0,AFINSQ_2,BINOP_1,SETWISEO,FINSOP_1,FUNCOP_1,BINOP_2,VALUED_0,FUNCT_2,INT_1,PRGCOR_2,XREAL_0,SEQ_1,SERIES_1,VALUED_1,RAT_1,SQUARE_1,COMPLEX1,PARTFUN3,PRE_POLY,AMISTD_1,AMISTD_2;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,XREAL_0,NUMBERS,RELAT_1,FUNCT_1,XCMPLX_0,NAT_1,FINSET_1,ORDINAL1,XXREAL_0,NAT_D,AFINSQ_1,SEQ_1,MEMBERED,VALUED_1,RELSET_1,PARTFUN1,FUNCT_2,FUNCOP_1,INT_1,BINOP_1,BINOP_2,SETWISEO,FINSOP_1,FINSEQ_1,RECDEF_1,VALUED_0,SERIES_1,RAT_1,PARTFUN3;
definitions TARSKI,XBOOLE_0,FUNCT_1,VALUED_1;
theorems TARSKI,FUNCT_1,NAT_1,ZFMISC_1,RELAT_1,CARD_2,XBOOLE_0,XBOOLE_1,FINSET_1,ORDINAL1,CARD_1,XREAL_1,AFINSQ_1,XXREAL_0,NAT_2,FINSEQ_2,WELLORD2,MEMBERED,VALUED_0,VALUED_1,XREAL_0,NAT_D,SERIES_1,PARTFUN3,BINOP_1,BINOP_2,SETWISEO,FUNCOP_1,FINSOP_1,FINSEQ_1,FUNCT_2,XCMPLX_0,GRFUNC_1,CKB1,CKB2,CKB3;
schemes NAT_1,AFINSQ_1,FUNCT_2,BINOP_1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCT_2,FUNCOP_1,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,BINOP_2,CARD_1,FINSEQ_1,AFINSQ_1,RELSET_1,ORDINAL3,VALUED_1,VALUED_0,MEMBERED,CKB4;
constructors SERIES_1,PARTFUN3,WELLORD2,SETWISEO,REAL_1,FINSOP_1,NAT_D,RECDEF_1,BINOP_2,RELSET_1,ORDINAL4,AFINSQ_1,MATRIX_7,SQUARE_1,FINSEQ_4,BINOP_1;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve i for Nat;
reserve k for Nat;
reserve n for Nat;
reserve x for set;
theorem
Th2: (for X0 being  finite  natural-membered set holds (ex n st X0 c= n))
proof
let X0 being  finite  natural-membered set;
consider p being Function such that A1: ( rng p ) = X0 and A2: ( dom p ) in ( NAT ) by FINSET_1:def 1;
reconsider np = ( dom p ) as (Element of ( NAT )) by A2;
np = ( dom p );
then reconsider p as XFinSequence by AFINSQ_1:5;
X0 c= ( NAT ) by MEMBERED:6;
then reconsider p as (XFinSequence of ( NAT )) by A1,RELAT_1:def 19;
defpred P[ Nat ]
 means
(ex n st (for i holds ((i in $1 & ( $1 -' 1 ) in ( dom p )) implies ( p . i ) in n)));
A3: (for k holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k;
assume P[ k ];
then consider n such that A4: (for i holds ((i in k & ( k -' 1 ) in ( dom p )) implies ( p . i ) in n));
per cases ;
suppose A5: ( ( k + 1 ) - 1 ) < ( len p );

set m = ( p . k );
set m2 = ( max (n,( m + 1 )) );
( k -' 1 ) <= k by NAT_D:35;
then ( k -' 1 ) < ( len p ) by A5,XXREAL_0:2;
then A6: ( k -' 1 ) in ( dom p ) by NAT_1:44;
(for i holds ((i in ( k + 1 ) & ( ( k + 1 ) -' 1 ) in ( dom p )) implies ( p . i ) in m2))
proof
let i;
assume that
A7: i in ( k + 1 )
and
( ( k + 1 ) -' 1 ) in ( dom p );
A8: i < ( k + 1 ) by A7,NAT_1:44;
per cases ;
suppose A9: i < k;

set k0 = ( p . i );
i in k by A9,NAT_1:44;
then ( p . i ) in n by A4,A6;
then k0 < n by NAT_1:44;
then k0 < m2 by XXREAL_0:30;
hence thesis by NAT_1:44;
end;
suppose A10: i >= k;

m < ( m + 1 ) by XREAL_1:29;
then A11: m < m2 by XXREAL_0:30;
i <= k by A8,NAT_1:13;
then ( p . i ) = m by A10,XXREAL_0:1;
hence thesis by A11,NAT_1:44;
end;
end;
hence thesis;
end;
suppose A12: ( ( k + 1 ) - 1 ) >= ( len p );

( ( k + 1 ) -' 1 ) = k by NAT_D:34;
then (for i holds ((i in ( k + 1 ) & ( ( k + 1 ) -' 1 ) in ( dom p )) implies ( p . i ) in 2)) by A12,NAT_1:44;
hence thesis;
end;
end;
(for i holds ((i in ( 0 ) & ( ( 0 ) -' 1 ) in ( dom p )) implies ( p . i ) in ( 0 )));
then A13: P[ ( 0 ) ];
(for k holds P[ k ]) from NAT_1:sch 2(A13,A3);
then consider n such that A14: (for i holds ((i in ( len p ) & ( ( len p ) -' 1 ) in ( dom p )) implies ( p . i ) in n));
( rng p ) c= n
proof
let y being set;
assume y in ( rng p );
then consider x such that A15: x in ( dom p ) and A16: y = ( p . x ) by FUNCT_1:def 3;
A17: ( ( len p ) - 1 ) < ( len p ) by XREAL_1:44;
( (( 0 ) qua (Element of ( NAT ))) + 1 ) <= ( len p ) by A15,NAT_1:13;
then ( ( len p ) -' 1 ) = ( ( len p ) - 1 ) by XREAL_1:233;
then ( ( len p ) -' 1 ) in ( dom p ) by A17,NAT_1:44;
hence thesis by A14,A15,A16;
end;
hence thesis by A1;
end;
