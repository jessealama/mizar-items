environ
vocabularies PBOOLE,ZFMISC_1,FUNCT_1,RELAT_1,XBOOLE_0,FUNCT_4,FUNCOP_1,TARSKI,FUNCT_2,FINSET_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,RELAT_1,FUNCT_1,FUNCT_2,FINSET_1,FUNCT_4,FUNCOP_1,PBOOLE;
definitions PBOOLE,FUNCOP_1;
theorems CARD_2,SETFAM_1,FUNCOP_1,FRAENKEL,FUNCT_4,PBOOLE,FINSET_1,TARSKI,ZFMISC_1,XBOOLE_0,XBOOLE_1,PARTFUN1,RELAT_1,FUNCT_1;
schemes PBOOLE;
registrations XBOOLE_0,SUBSET_1,FUNCOP_1,PRE_CIRC;
constructors FUNCT_4,PBOOLE,FINSET_1,RELSET_1;
requirements SUBSET,BOOLE;
begin
reserve I for set;
reserve A for (ManySortedSet of I);
reserve X for (ManySortedSet of I);
reserve Y for (ManySortedSet of I);
definition
let I;
let A;
func bool A -> (ManySortedSet of I) means 
:Def1: (for i being set holds (i in I implies ( it . i ) = ( bool ( A . i ) )));
existence
proof
deffunc V(set) = ( bool ( A . $1 ) );
thus (ex X being (ManySortedSet of I) st (for i being set holds (i in I implies ( X . i ) = V(i)))) from PBOOLE:sch 4;
end;
uniqueness
proof
let X being (ManySortedSet of I);
let Y being (ManySortedSet of I);
assume that
A1: (for i being set holds (i in I implies ( X . i ) = ( bool ( A . i ) )))
and
A2: (for i being set holds (i in I implies ( Y . i ) = ( bool ( A . i ) )));
now
let i being set;
assume A3: i in I;
hence ( X . i ) = ( bool ( A . i ) ) by A1
.= ( Y . i ) by A2,A3;
end;
hence X = Y by PBOOLE:3;
end;
end;
