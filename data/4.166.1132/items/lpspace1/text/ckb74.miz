environ
vocabularies NUMBERS,XBOOLE_0,RLVECT_1,SUBSET_1,REAL_1,RELAT_1,RLSUB_1,IDEAL_1,ARYTM_3,STRUCT_0,RSSPACE,FUNCT_1,ZFMISC_1,TARSKI,BINOP_1,SUPINF_2,ALGSTR_0,REALSET1,XREAL_0,ORDINAL1,FUNCT_7,PARTFUN1,VALUED_1,FUNCOP_1,CARD_1,RFUNCT_3,ARYTM_1,PROB_1,MEASURE1,INTEGRA5,MESFUNC5,MESFUNC2,XXREAL_0,MESFUNC1,SUPINF_1,MEASURE6,VECTSP10,SETFAM_1,COMPLEX1,PRE_TOPC,NORMSP_1,LPSPACE1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,XCMPLX_0,NUMBERS,COMPLEX1,XXREAL_0,XREAL_0,SUPINF_1,SUPINF_2,EXTREAL1,REALSET1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,VALUED_1,RFUNCT_3,BINOP_1,FUNCOP_1,REAL_1,STRUCT_0,ALGSTR_0,RLVECT_1,RLSUB_1,IDEAL_1,SETFAM_1,DOMAIN_1,PRE_TOPC,NORMSP_0,NORMSP_1,PROB_1,MEASURE1,MEASURE2,MEASURE3,MEASURE6,MESFUNC1,MESFUNC2,MESFUNC5,MESFUNC6,FUNCT_7,CKB1,CKB4,CKB9,CKB10,CKB11,CKB12,CKB13,CKB31,CKB34,CKB36,CKB43,CKB47,CKB54,CKB59,CKB63,CKB70,CKB71,CKB72,CKB73;
definitions TARSKI,SUPINF_2,REALSET1,BINOP_1,STRUCT_0,ALGSTR_0,RLVECT_1,IDEAL_1,NORMSP_1,MEASURE6,MESFUNC5,MESFUNC6,SUBSET_1,XXREAL_3,NORMSP_0,CKB1,CKB4,CKB10,CKB11,CKB12,CKB13,CKB31,CKB36,CKB43,CKB47,CKB54,CKB59,CKB63,CKB70,CKB71,CKB72,CKB73;
theorems FUNCT_1,FUNCT_2,PARTFUN1,COMPLEX1,XBOOLE_0,TARSKI,RELAT_1,VALUED_1,IDEAL_1,RLSUB_1,ZFMISC_1,RLVECT_1,FUNCOP_1,XBOOLE_1,BINOP_1,SUPINF_2,RFUNCT_3,MESFUNC5,MESFUNC2,EXTREAL1,MEASURE1,MESFUNC6,PROB_1,RFUNCT_1,XXREAL_0,NUMBERS,ABSVALUE,MESFUNC1,MEASURE2,MESFUNC7,EXTREAL2,RSSPACE3,NORMSP_1,FUNCT_7,VALUED_0,RELSET_1,XXREAL_3,XREAL_0,NORMSP_0,CKB1,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB33,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB43,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56,CKB58,CKB59,CKB61,CKB62,CKB63,CKB64,CKB65,CKB66,CKB67,CKB68,CKB69,CKB70,CKB71,CKB72,CKB73;
schemes BINOP_1,FUNCT_2;
registrations XBOOLE_0,ORDINAL1,RELSET_1,NUMBERS,XREAL_0,MEMBERED,VALUED_0,NAT_1,SUBSET_1,XCMPLX_0,PARTFUN1,XXREAL_0,RLVECT_1,STRUCT_0,NORMSP_1,MEASURE1,MESFUNC7,XXREAL_3,NORMSP_0,CKB3,CKB32,CKB42,CKB44,CKB57,CKB60;
constructors COMPLEX1,EXTREAL1,NAT_1,BINOP_1,REAL_1,RLSUB_1,IDEAL_1,NORMSP_1,MEASURE3,MEASURE6,MESFUNC2,MESFUNC5,MESFUNC6,MESFUNC7,SEQ_1,MESFUNC3,EXTREAL2,SUPINF_1,FUNCT_7,REALSET1,RVSUM_1,MESFUNC1,SEQ_2,RELSET_1,BINOP_2,CKB1,CKB4,CKB9,CKB10,CKB11,CKB12,CKB13,CKB31,CKB34,CKB36,CKB43,CKB47,CKB54,CKB59,CKB63,CKB70,CKB71,CKB72,CKB73;
requirements NUMERALS,BOOLE,SUBSET,REAL,ARITHM;
begin
reserve a for Real;
reserve b for Real;
reserve X for non  empty set;
reserve x for (Element of X);
reserve S for (SigmaField of X);
reserve M for (sigma_Measure of S);
reserve g for (PartFunc of X,( REAL ));
definition
let X being non  empty set;
let S being (SigmaField of X);
let M being (sigma_Measure of S);
func Pre-L-Space M ->  strict  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty RLSStruct means 
:Def18: ((((the carrier of it) = ( CosetSet M ) & (the addF of it) = ( addCoset M )) & ( 0. it ) = ( zeroCoset M )) & (the Mult of it) = ( lmultCoset M ));
existence
proof
set C = ( CosetSet M );
set aC = ( addCoset M );
set zC = ( zeroCoset M );
set lC = ( lmultCoset M );
set A = RLSStruct (# C,zC,aC,lC #);
A1: A is  Abelian
proof
let A1 being (Element of A);
let A2 being (Element of A);
A1 in C;
then consider a being (PartFunc of X,( REAL )) such that A2: (A1 = ( a.e-eq-class (a,M) ) & a in ( L1_Functions M ));
A2 in C;
then consider b being (PartFunc of X,( REAL )) such that A3: (A2 = ( a.e-eq-class (b,M) ) & b in ( L1_Functions M ));
A4: b in A2 by A3,CKB65:1;
A5: a in A1 by A2,CKB65:1;
then ( A1 + A2 ) = ( a.e-eq-class (( a + b ),M) ) by A4,CKB71:def 1;
hence thesis by A5,A4,CKB71:def 1;
end;
A6: A is  right_zeroed
proof
consider z being (PartFunc of X,( REAL )) such that A7: z = ( X --> ( 0 ) ) and A8: z in ( L1_Functions M ) and A9: ( zeroCoset M ) = ( a.e-eq-class (z,M) ) by CKB72:def 1;
A10: z in ( 0. A ) by A8,A9,CKB65:1;
let A1 being (Element of A);
A1 in C;
then consider a being (PartFunc of X,( REAL )) such that A11: A1 = ( a.e-eq-class (a,M) ) and A12: a in ( L1_Functions M );
reconsider a1 = a,z1 = z as (VECTOR of ( RLSp_L1Funct M )) by A12,A8;
A13: ( a + z ) = ( a1 + z1 ) by CKB45:1
.= ( a1 + ( 0. ( RLSp_L1Funct M ) ) ) by A7,CKB58:1
.= a by RLVECT_1:def 4;
a in A1 by A11,A12,CKB65:1;
hence thesis by A11,A10,A13,CKB71:def 1;
end;
A14:now
let x being  real number;
let y being  real number;
let A1 being (Element of A);
let A2 being (Element of A);
reconsider x1 = x,y1 = y as Real by XREAL_0:def 1;
A1 in C;
then consider a being (PartFunc of X,( REAL )) such that A15: A1 = ( a.e-eq-class (a,M) ) and A16: a in ( L1_Functions M );
A17: a in A1 by A15,A16,CKB65:1;
then ( lC . (x1,A1) ) = ( a.e-eq-class (( x (#) a ),M) ) by CKB73:def 1;
then A18: ( x (#) a ) in ( x * A1 ) by A16,CKB40:1,CKB65:1;
A2 in C;
then consider b being (PartFunc of X,( REAL )) such that A19: A2 = ( a.e-eq-class (b,M) ) and A20: b in ( L1_Functions M );
reconsider a1 = a,b1 = b as (VECTOR of ( RLSp_L1Funct M )) by A16,A20;
A21: ( x (#) a ) = ( x1 * a1 ) by CKB46:1;
A22: b in A2 by A19,A20,CKB65:1;
then ( lC . (x1,A2) ) = ( a.e-eq-class (( x (#) b ),M) ) by CKB73:def 1;
then A23: ( x (#) b ) in ( x1 * A2 ) by A20,CKB40:1,CKB65:1;
( a + b ) = ( a1 + b1 ) by CKB45:1;
then ( x (#) ( a + b ) ) = ( x1 * ( a1 + b1 ) ) by CKB46:1;
then A24: ( x (#) ( a + b ) ) = ( ( x * a1 ) + ( x * b1 ) ) by RLVECT_1:def 5;
( x (#) b ) = ( x1 * b1 ) by CKB46:1;
then A25: ( x (#) ( a + b ) ) = ( ( x (#) a ) + ( x (#) b ) ) by A21,A24,CKB45:1;
( aC . (A1,A2) ) = ( a.e-eq-class (( a + b ),M) ) by A17,A22,CKB71:def 1;
then ( a + b ) in ( A1 + A2 ) by A16,A20,CKB39:1,CKB65:1;
then ( x1 * ( A1 + A2 ) ) = ( a.e-eq-class (( ( x (#) a ) + ( x (#) b ) ),M) ) by A25,CKB73:def 1;
hence ( x * ( A1 + A2 ) ) = ( ( x * A1 ) + ( x * A2 ) ) by A18,A23,CKB71:def 1;
A26: ( y (#) a ) = ( y1 * a1 ) by CKB46:1;
( lC . (y1,A1) ) = ( a.e-eq-class (( y (#) a ),M) ) by A17,CKB73:def 1;
then A27: ( y (#) a ) in ( y1 * A1 ) by A16,CKB40:1,CKB65:1;
( ( x + y ) (#) a ) = ( ( x1 + y1 ) * a1 ) by CKB46:1
.= ( ( x * a1 ) + ( y * a1 ) ) by RLVECT_1:def 6
.= ( ( x (#) a ) + ( y (#) a ) ) by A26,A21,CKB45:1;
then ( ( x1 + y1 ) * A1 ) = ( a.e-eq-class (( ( x (#) a ) + ( y (#) a ) ),M) ) by A17,CKB73:def 1;
hence ( ( x + y ) * A1 ) = ( ( x * A1 ) + ( y * A1 ) ) by A18,A27,CKB71:def 1;
( x (#) ( y (#) a ) ) = ( x * ( y * a1 ) ) by A26,A21,CKB46:1
.= ( ( x1 * y1 ) * a1 ) by RLVECT_1:def 7
.= ( ( x * y ) (#) a ) by CKB46:1;
then ( ( x1 * y1 ) * A1 ) = ( a.e-eq-class (( x1 (#) ( y1 (#) a ) ),M) ) by A17,CKB73:def 1
.= ( x * ( y * A1 ) ) by A27,CKB73:def 1;
hence ( ( x * y ) * A1 ) = ( x * ( y * A1 ) );
( 1 (#) a ) = ( 1 * a1 ) by CKB46:1
.= a by RLVECT_1:def 8;
hence ( 1 * A1 ) = A1 by A15,A17,CKB73:def 1;
end;
A28: A is  right_complementable
proof
let A1 being (Element of A);
A1 in C;
then consider a being (PartFunc of X,( REAL )) such that A29: A1 = ( a.e-eq-class (a,M) ) and A30: a in ( L1_Functions M );
set A2 = ( a.e-eq-class (( ( - 1 ) (#) a ),M) );
A31: ( ( - 1 ) (#) a ) in ( L1_Functions M ) by A30,CKB40:1;
then A2 in C;
then reconsider A2 as (Element of A);
A32: (a in A1 & ( ( - 1 ) (#) a ) in A2) by A29,A30,CKB40:1,CKB65:1;
reconsider a1 = a as (VECTOR of ( RLSp_L1Funct M )) by A30;
take A2;
consider v,g being (PartFunc of X,( REAL )) such that v in ( L1_Functions M ) and g in ( L1_Functions M ) and A33: v = ( a1 + ( ( - 1 ) * a1 ) ) and A34: g = ( X --> ( 0 ) ) and A35: v a.e.= g,M by CKB48:1;
A36: (ex z being (PartFunc of X,( REAL )) st ((z = ( X --> ( 0 ) ) & z in ( L1_Functions M )) & ( zeroCoset M ) = ( a.e-eq-class (z,M) ))) by CKB72:def 1;
A37: ( a + ( ( - 1 ) (#) a ) ) in ( L1_Functions M ) by A30,A31,CKB39:1;
( ( - 1 ) (#) a ) = ( ( - 1 ) * a1 ) by CKB46:1;
then ( a + ( ( - 1 ) (#) a ) ) a.e.= g,M by A33,A35,CKB45:1;
then ( 0. A ) = ( a.e-eq-class (( a + ( ( - 1 ) (#) a ) ),M) ) by A34,A37,A36,CKB66:1;
hence thesis by A32,CKB71:def 1;
end;
A is  add-associative
proof
let A1 being (Element of A);
let A2 being (Element of A);
let A3 being (Element of A);
A1 in C;
then consider a being (PartFunc of X,( REAL )) such that A38: A1 = ( a.e-eq-class (a,M) ) and A39: a in ( L1_Functions M );
A2 in C;
then consider b being (PartFunc of X,( REAL )) such that A40: A2 = ( a.e-eq-class (b,M) ) and A41: b in ( L1_Functions M );
A3 in C;
then consider c being (PartFunc of X,( REAL )) such that A42: A3 = ( a.e-eq-class (c,M) ) and A43: c in ( L1_Functions M );
A44: c in A3 by A42,A43,CKB65:1;
A45: b in A2 by A40,A41,CKB65:1;
then ( aC . (A2,A3) ) = ( a.e-eq-class (( b + c ),M) ) by A44,CKB71:def 1;
then A46: ( b + c ) in ( A2 + A3 ) by A41,A43,CKB39:1,CKB65:1;
reconsider a1 = a,b1 = b,c1 = c as (VECTOR of ( RLSp_L1Funct M )) by A39,A41,A43;
( b + c ) = ( b1 + c1 ) by CKB45:1;
then ( a + ( b + c ) ) = ( a1 + ( b1 + c1 ) ) by CKB45:1;
then A47: ( a + ( b + c ) ) = ( ( a1 + b1 ) + c1 ) by RLVECT_1:def 3;
( a + b ) = ( a1 + b1 ) by CKB45:1;
then A48: ( a + ( b + c ) ) = ( ( a + b ) + c ) by A47,CKB45:1;
A49: a in A1 by A38,A39,CKB65:1;
then ( aC . (A1,A2) ) = ( a.e-eq-class (( a + b ),M) ) by A45,CKB71:def 1;
then ( a + b ) in ( A1 + A2 ) by A39,A41,CKB39:1,CKB65:1;
then ( ( A1 + A2 ) + A3 ) = ( a.e-eq-class (( a + ( b + c ) ),M) ) by A44,A48,CKB71:def 1;
hence thesis by A49,A46,CKB71:def 1;
end;
then reconsider A as  strict  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty RLSStruct by A1,A6,A28,A14,RLVECT_1:def 5,RLVECT_1:def 6,RLVECT_1:def 7,RLVECT_1:def 8;
take A;
thus thesis;
end;
uniqueness;
end;
