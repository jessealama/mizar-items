environ
vocabularies NUMBERS,SUBSET_1,TREES_2,ZFMISC_1,FINSEQ_1,XBOOLE_0,TREES_1,FUNCT_1,RELAT_1,ORDINAL4,NAT_1,CARD_1,XXREAL_0,PARTFUN1,TARSKI,ORDINAL1,ARYTM_3,FINSET_1,FUNCOP_1,MARGREL1,MCART_1,QC_LANG1,XBOOLEAN,VALUED_1,ZF_LANG,MODAL_1,TREES_3;
notations TARSKI,XBOOLE_0,ENUMSET1,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,WELLORD2,NAT_1,DOMAIN_1,MCART_1,RELAT_1,FUNCT_1,RELSET_1,FINSEQ_1,FUNCOP_1,FINSEQ_2,FUNCT_2,FINSET_1,PARTFUN1,TREES_1,TREES_2,XXREAL_0,TREES_3,CKB2,CKB3;
definitions TARSKI,XBOOLE_0,FUNCT_1,CKB2,CKB3;
theorems TARSKI,FUNCT_1,NAT_1,ENUMSET1,TREES_1,TREES_2,FUNCOP_1,MCART_1,DOMAIN_1,PARTFUN1,FINSEQ_1,FINSET_1,CARD_1,WELLORD2,CARD_2,ZFMISC_1,FINSEQ_2,RELAT_1,FUNCT_2,RELSET_1,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,TREES_3,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27;
schemes TREES_2,CLASSES1,NAT_1,FUNCT_2,XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FINSET_1,XXREAL_0,XREAL_0,FINSEQ_1,TREES_1,TREES_2,CARD_1,RELSET_1,TREES_3;
constructors PARTFUN1,WELLORD2,DOMAIN_1,XXREAL_0,XREAL_0,NAT_1,FINSEQ_2,TREES_2,RELSET_1,FUNCOP_1,TREES_3,CKB2,CKB3;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve w for (FinSequence of ( NAT ));
reserve s for (FinSequence of ( NAT ));
theorem
Th29: (for Z being Tree holds (for x1,x2 being (Element of Z) holds (((x1 = <* ( 0 ) *> & x2 = <* 1 *>) & ( succ ( Root Z ) ) = { x1,x2 }) implies Z = ( ( ( elementary_tree 2 ) with-replacement (<* ( 0 ) *>,( Z | x1 )) ) with-replacement (<* 1 *>,( Z | x2 )) ))))
proof
set e = ( elementary_tree 2 );
let Z being Tree;
let x1 being (Element of Z),x2 being (Element of Z);
assume that
A1: x1 = <* ( 0 ) *>
and
A2: x2 = <* 1 *>
and
A3: ( succ ( Root Z ) ) = { x1,x2 };
set T1 = ( ( elementary_tree 2 ) with-replacement (<* ( 0 ) *>,( Z | x1 )) );
A4: <* ( 0 ) *> in e by ENUMSET1:def 1,TREES_1:53;
A5:now
let s;
thus (s in Z implies ((s in T1 & (not <* 1 *> is_a_proper_prefix_of s)) or (ex w st (w in ( Z | x2 ) & s = ( <* 1 *> ^ w )))))
proof
assume A6: s in Z;
per cases ;
suppose s = ( {} );

hence thesis by TREES_1:12,TREES_1:15,TREES_1:22;
end;
suppose s <> ( {} );

then consider w being (FinSequence of ( NAT )),n being (Element of ( NAT )) such that A7: s = ( <* n *> ^ w ) by FINSEQ_2:130;
<* n *> is_a_prefix_of s by A7,TREES_1:1;
then A8: <* n *> in Z by A6,TREES_1:20;
<* n *> = ( ( Root Z ) ^ <* n *> ) by FINSEQ_1:34;
then A9: <* n *> in ( succ ( Root Z ) ) by A8,TREES_2:12;
now
per cases  by A1,A2,A3,A9,TARSKI:def 2;
suppose A10: <* n *> = <* ( 0 ) *>;

then w in ( Z | x1 ) by A1,A6,A7,TREES_1:def 6;
hence thesis by A4,A7,A10,CKB6:1,TREES_1:def 9;
end;
suppose A11: <* n *> = <* 1 *>;

then w in ( Z | x2 ) by A2,A6,A7,TREES_1:def 6;
hence thesis by A7,A11;
end;
end;
hence thesis;
end;
end;

assume A12: ((s in T1 & (not <* 1 *> is_a_proper_prefix_of s)) or (ex w st (w in ( Z | x2 ) & s = ( <* 1 *> ^ w ))));
now
per cases  by A12;
suppose A13: (s in T1 & (not <* 1 *> is_a_proper_prefix_of s));

now
per cases  by A4,A13,TREES_1:def 9;
suppose (s in e & (not <* ( 0 ) *> is_a_proper_prefix_of s));

then ((s = ( {} ) or s = <* ( 0 ) *>) or s = <* 1 *>) by ENUMSET1:def 1,TREES_1:53;
hence s in Z by A1,A2,A3;
end;
suppose (ex w st (w in ( Z | x1 ) & s = ( <* ( 0 ) *> ^ w )));

hence s in Z by A1,TREES_1:def 6;
end;
end;
hence s in Z;
end;
suppose (ex w st (w in ( Z | x2 ) & s = ( <* 1 *> ^ w )));

hence s in Z by A2,TREES_1:def 6;
end;
end;
hence s in Z;
end;
A14:now
assume <* ( 0 ) *> is_a_proper_prefix_of <* 1 *>;
then <* ( 0 ) *> is_a_prefix_of <* 1 *> by XBOOLE_0:def 8;
hence contradiction by TREES_1:3;
end;
<* 1 *> in e by ENUMSET1:def 1,TREES_1:53;
then <* 1 *> in T1 by A4,A14,TREES_1:def 9;
hence thesis by A5,TREES_1:def 9;
end;
