environ
vocabularies FUNCT_1,SUBSET_1,RELAT_1,FUNCT_2,XBOOLE_0,TARSKI,PBOOLE,ZFMISC_1,MCART_1,FUNCOP_1,STRUCT_0,CAT_1,RELAT_2,BINOP_1,CARD_1,ALTCAT_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,MCART_1,DOMAIN_1,RELAT_1,CARD_1,NUMBERS,STRUCT_0,FUNCT_1,FUNCT_2,BINOP_1,MULTOP_1,FUNCOP_1,PBOOLE,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB29,CKB30,CKB33,CKB37,CKB38,CKB39,CKB44,CKB45,CKB46,CKB54,CKB55,CKB59,CKB60,CKB66;
definitions TARSKI,STRUCT_0,XBOOLE_0,FUNCOP_1,BINOP_1,CKB17,CKB19,CKB20,CKB21,CKB24,CKB25,CKB26,CKB29,CKB30,CKB33,CKB37,CKB38,CKB39,CKB44,CKB45,CKB46,CKB55,CKB59,CKB60;
theorems FUNCT_1,ZFMISC_1,PBOOLE,DOMAIN_1,MULTOP_1,MCART_1,FUNCT_2,TARSKI,FUNCOP_1,RELAT_1,REALSET1,STRUCT_0,RELSET_1,XBOOLE_0,XBOOLE_1,CARD_1,PARTFUN1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB17,CKB19,CKB20,CKB21,CKB24,CKB25,CKB26,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB49,CKB50,CKB55,CKB56,CKB57,CKB58,CKB59,CKB60,CKB61,CKB63;
schemes FUNCT_1,CKB6,CKB7,CKB8,CKB9;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,FUNCOP_1,STRUCT_0,RELSET_1,ZFMISC_1,CARD_1,ORDINAL1,CKB15,CKB27,CKB28,CKB31,CKB40,CKB41,CKB48,CKB51,CKB52,CKB53,CKB62,CKB64,CKB65;
constructors PARTFUN1,BINOP_1,MULTOP_1,PBOOLE,REALSET2,RELSET_1,CKB15,CKB17,CKB19,CKB20,CKB21,CKB23,CKB24,CKB25,CKB26,CKB27,CKB29,CKB30,CKB33,CKB37,CKB38,CKB39,CKB44,CKB45,CKB46,CKB55,CKB59,CKB60;
requirements BOOLE,SUBSET,NUMERALS;
begin
reserve i for set;
reserve j for set;
reserve k for set;
definition
let A being non empty set;
func DiscrCat A ->  quasi-discrete  strict non empty AltCatStr
means
:Def22: ((the carrier of it) = A & (for i being (object of it) holds <^ i,i ^> = { ( id i ) }));
existence
proof
deffunc F((Element of A),set,set) = ( IFEQ ($1,$2,( IFEQ ($2,$3,( [ ( id $1 ),( id $1 ) ] .--> ( id $1 ) ),( {} )) ),( {} )) );
deffunc F((Element of A),set) = ( IFEQ ($1,$2,{ ( id $1 ) },( {} )) );
consider M being (ManySortedSet of [: A,A :]) such that A1: (for i,j being (Element of A) holds ( M . (i,j) ) = F(i,j)) from CKB7:sch 1;
consider c being (ManySortedSet of [: A,A,A :]) such that A2: (for i,j,k being (Element of A) holds ( c . (i,j,k) ) = F(i,j,k)) from CKB9:sch 1;
A3:now
let i;
assume i in [: A,A,A :];
then consider i1 being set,i2 being set,i3 being set such that A4: ((i1 in A & i2 in A) & i3 in A) and A5: i = [ i1,i2,i3 ] by MCART_1:68;
reconsider i1,i2,i3 as (Element of A) by A4;
per cases ;
suppose that A6: i1 = i2
and
A7: i2 = i3;
A8: ( M . (i1,i1) ) = ( IFEQ (i1,i1,{ ( id i1 ) },( {} )) ) by A1
.= { ( id i1 ) } by FUNCOP_1:def 8;
A9: ( c . i ) = ( c . (i1,i2,i3) ) by A5,MULTOP_1:def 1
.= ( IFEQ (i1,i2,( IFEQ (i2,i3,( [ ( id i1 ),( id i1 ) ] .--> ( id i1 ) ),( {} )) ),( {} )) ) by A2
.= ( IFEQ (i2,i3,( [ ( id i1 ),( id i1 ) ] .--> ( id i1 ) ),( {} )) ) by A6,FUNCOP_1:def 8
.= ( [ ( id i1 ),( id i1 ) ] .--> ( id i1 ) ) by A7,FUNCOP_1:def 8;
A10: ( {| M |} . i ) = ( {| M |} . (i1,i1,i1) ) by A5,A6,A7,MULTOP_1:def 1
.= { ( id i1 ) } by A8,CKB20:def 1;
( {| M,M |} . i ) = ( {| M,M |} . (i1,i1,i1) ) by A5,A6,A7,MULTOP_1:def 1
.= [: { ( id i1 ) },{ ( id i1 ) } :] by A8,CKB21:def 1
.= { [ ( id i1 ),( id i1 ) ] } by ZFMISC_1:29
.= ( dom ( [ ( id i1 ),( id i1 ) ] .--> ( id i1 ) ) ) by FUNCOP_1:13;
hence ( c . i ) is (Function of ( {| M,M |} . i ),( {| M |} . i )) by A9,A10,FUNCT_2:def 1;
end;
suppose A11: (i1 <> i2 or i2 <> i3);

A12:now
per cases  by A11;
suppose A13: i1 <> i2;

thus ( c . i ) = ( c . (i1,i2,i3) ) by A5,MULTOP_1:def 1
.= ( IFEQ (i1,i2,( IFEQ (i2,i3,( [ ( id i1 ),( id i1 ) ] .--> ( id i1 ) ),( {} )) ),( {} )) ) by A2
.= ( {} ) by A13,FUNCOP_1:def 8;
end;
suppose that A14: i1 = i2
and
A15: i2 <> i3;
thus ( c . i ) = ( c . (i1,i2,i3) ) by A5,MULTOP_1:def 1
.= ( IFEQ (i1,i2,( IFEQ (i2,i3,( [ ( id i1 ),( id i1 ) ] .--> ( id i1 ) ),( {} )) ),( {} )) ) by A2
.= ( IFEQ (i2,i3,( [ ( id i1 ),( id i1 ) ] .--> ( id i1 ) ),( {} )) ) by A14,FUNCOP_1:def 8
.= ( {} ) by A15,FUNCOP_1:def 8;
end;
end;
(( M . (i1,i2) ) = ( IFEQ (i1,i2,{ ( id i1 ) },( {} )) ) & ( M . (i2,i3) ) = ( IFEQ (i2,i3,{ ( id i2 ) },( {} )) )) by A1;
then A16: (( M . (i1,i2) ) = ( {} ) or ( M . (i2,i3) ) = ( {} )) by A11,FUNCOP_1:def 8;
( {| M,M |} . i ) = ( {| M,M |} . (i1,i2,i3) ) by A5,MULTOP_1:def 1
.= [: ( M . (i2,i3) ),( M . (i1,i2) ) :] by CKB21:def 1
.= ( {} ) by A16;
hence ( c . i ) is (Function of ( {| M,M |} . i ),( {| M |} . i )) by A12,FUNCT_2:def 1,RELAT_1:38,XBOOLE_1:2;
end;
end;
c is  Function-yielding
proof
let i;
assume i in ( dom c );
then i in [: A,A,A :] by PARTFUN1:def 2;
hence thesis by A3;
end;
then reconsider c as (ManySortedFunction of [: A,A,A :]);
reconsider c as (BinComp of M) by A3,PBOOLE:def 15;
set C = AltCatStr (# A,M,c #);
C is  quasi-discrete
proof
let o1 being (object of C),o2 being (object of C);
assume that
A17: <^ o1,o2 ^> <> ( {} )
and
A18: o1 <> o2;
<^ o1,o2 ^> = ( IFEQ (o1,o2,{ ( id o1 ) },( {} )) ) by A1
.= ( {} ) by A18,FUNCOP_1:def 8;
hence contradiction by A17;
end;
then reconsider C = AltCatStr (# A,M,c #) as  quasi-discrete  strict non empty AltCatStr;
take C;
thus (the carrier of C) = A;
let i being (object of C);
thus <^ i,i ^> = ( IFEQ (i,i,{ ( id i ) },( {} )) ) by A1
.= { ( id i ) } by FUNCOP_1:def 8;
end;
correctness
proof
let C1 being  quasi-discrete  strict non empty AltCatStr,C2 being  quasi-discrete  strict non empty AltCatStr;
assume that
A19: (the carrier of C1) = A
and
A20: (for i being (object of C1) holds <^ i,i ^> = { ( id i ) })
and
A21: (the carrier of C2) = A
and
A22: (for i being (object of C2) holds <^ i,i ^> = { ( id i ) });
A23:now
let i;
let j;
let k;
assume that
A24: i in A
and
A25: (j in A & k in A);
reconsider i2 = i as (object of C2) by A21,A24;
reconsider i1 = i as (object of C1) by A19,A24;
per cases ;
suppose A26: (i = j & j = k);

A27: (<^ i2,i2 ^> = { ( id i2 ) } & ( (the Comp of C2) . (i2,i2,i2) ) is (Function of [: <^ i2,i2 ^>,<^ i2,i2 ^> :],<^ i2,i2 ^>)) by A22;
(<^ i1,i1 ^> = { ( id i1 ) } & ( (the Comp of C1) . (i1,i1,i1) ) is (Function of [: <^ i1,i1 ^>,<^ i1,i1 ^> :],<^ i1,i1 ^>)) by A20;
hence ( (the Comp of C1) . (i,j,k) ) = ( (( id i ),( id i )) :-> ( id i ) ) by A26,FUNCOP_1:def 10
.= ( (the Comp of C2) . (i,j,k) ) by A26,A27,FUNCOP_1:def 10;
end;
suppose A28: (i <> j or j <> k);

reconsider j1 = j,k1 = k as (object of C1) by A19,A25;
A29: (<^ i1,j1 ^> = ( {} ) or <^ j1,k1 ^> = ( {} )) by A28,CKB59:def 1;
reconsider j2 = j,k2 = k as (object of C2) by A21,A25;
A30: (( (the Comp of C2) . (i2,j2,k2) ) is (Function of [: <^ j2,k2 ^>,<^ i2,j2 ^> :],<^ i2,k2 ^>) & ( (the Comp of C1) . (i1,j1,k1) ) is (Function of [: <^ j1,k1 ^>,<^ i1,j1 ^> :],<^ i1,k1 ^>));
(<^ i2,j2 ^> = ( {} ) or <^ j2,k2 ^> = ( {} )) by A28,CKB59:def 1;
hence ( (the Comp of C1) . (i,j,k) ) = ( (the Comp of C2) . (i,j,k) ) by A29,A30;
end;
end;
now
let i being (Element of A),j being (Element of A);
reconsider i2 = i as (object of C2) by A21;
reconsider i1 = i as (object of C1) by A19;
per cases ;
suppose A31: i = j;

hence ( (the Arrows of C1) . (i,j) ) = <^ i1,i1 ^>
.= { ( id i ) } by A20
.= <^ i2,i2 ^> by A22
.= ( (the Arrows of C2) . (i,j) ) by A31;
end;
suppose A32: i <> j;

reconsider j2 = j as (object of C2) by A21;
reconsider j1 = j as (object of C1) by A19;
thus ( (the Arrows of C1) . (i,j) ) = <^ i1,j1 ^>
.= ( {} ) by A32,CKB59:def 1
.= <^ i2,j2 ^> by A32,CKB59:def 1
.= ( (the Arrows of C2) . (i,j) );
end;
end;
then (the Arrows of C1) = (the Arrows of C2) by A19,A21,CKB11:1;
hence thesis by A19,A21,A23,CKB12:1;
end;
end;
