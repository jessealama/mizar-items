environ
vocabularies FUNCT_1,SUBSET_1,RELAT_1,FUNCT_2,XBOOLE_0,TARSKI,PBOOLE,ZFMISC_1,MCART_1,FUNCOP_1,STRUCT_0,CAT_1,RELAT_2,BINOP_1,CARD_1,ALTCAT_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,MCART_1,DOMAIN_1,RELAT_1,CARD_1,NUMBERS,STRUCT_0,FUNCT_1,FUNCT_2,BINOP_1,MULTOP_1,FUNCOP_1,PBOOLE,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB29,CKB30;
definitions TARSKI,STRUCT_0,XBOOLE_0,FUNCOP_1,BINOP_1,CKB17,CKB19,CKB20,CKB21,CKB24,CKB25,CKB26,CKB29,CKB30;
theorems FUNCT_1,ZFMISC_1,PBOOLE,DOMAIN_1,MULTOP_1,MCART_1,FUNCT_2,TARSKI,FUNCOP_1,RELAT_1,REALSET1,STRUCT_0,RELSET_1,XBOOLE_0,XBOOLE_1,CARD_1,PARTFUN1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB17,CKB19,CKB20,CKB21,CKB24,CKB25,CKB26,CKB29,CKB30;
schemes FUNCT_1,CKB6,CKB7,CKB8,CKB9;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,FUNCOP_1,STRUCT_0,RELSET_1,ZFMISC_1,CARD_1,ORDINAL1,CKB15,CKB27,CKB28;
constructors PARTFUN1,BINOP_1,MULTOP_1,PBOOLE,REALSET2,RELSET_1,CKB15,CKB17,CKB19,CKB20,CKB21,CKB23,CKB24,CKB25,CKB26,CKB27,CKB29,CKB30;
requirements BOOLE,SUBSET,NUMERALS;
begin
reserve x for set;
registration
let A being  functional set;
let B being  functional set;
cluster  compositional for (ManySortedFunction of [: A,B :]);
existence
proof
per cases ;
suppose A1: (A = ( {} ) or B = ( {} ));

set M = ( [[0]] [: A,B :] );
M is  Function-yielding
proof
let x;
thus thesis by A1,PARTFUN1:def 2;
end;
then reconsider M as (ManySortedFunction of [: A,B :]);
take M;
let x;
thus thesis by A1,PARTFUN1:def 2;
end;
suppose (A <> ( {} ) & B <> ( {} ));

then reconsider A1 = A,B1 = B as non  empty  functional set;
deffunc F((Element of A1),(Element of B1)) = ( $1 * $2 );
consider M being (ManySortedSet of [: A1,B1 :]) such that A2: (for i being (Element of A1) holds (for j being (Element of B1) holds ( M . (i,j) ) = F(i,j))) from CKB7:sch 1;
M is  Function-yielding
proof
let x;
assume x in ( dom M );
then A3: x in [: A1,B1 :] by PARTFUN1:def 2;
then A4: (( x `1 ) in A1 & ( x `2 ) in B1) by MCART_1:10;
then reconsider f = ( x `1 ),g = ( x `2 ) as Function;
( M . x ) = ( M . (f,g) ) by A3,MCART_1:22
.= ( f * g ) by A2,A4;
hence thesis;
end;
then reconsider M as (ManySortedFunction of [: A,B :]);
take M;
let x;
assume x in ( dom M );
then A5: x in [: A1,B1 :] by PARTFUN1:def 2;
then A6: (( x `1 ) in A1 & ( x `2 ) in B1) by MCART_1:10;
then reconsider f = ( x `1 ),g = ( x `2 ) as Function;
take g;
take f;
thus x = [ f,g ] by A5,MCART_1:22;
thus ( M . x ) = ( M . (f,g) ) by A5,MCART_1:22
.= ( f * g ) by A2,A6;
end;
end;
end;
