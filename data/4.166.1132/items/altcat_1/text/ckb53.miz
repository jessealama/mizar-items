environ
vocabularies FUNCT_1,SUBSET_1,RELAT_1,FUNCT_2,XBOOLE_0,TARSKI,PBOOLE,ZFMISC_1,MCART_1,FUNCOP_1,STRUCT_0,CAT_1,RELAT_2,BINOP_1,CARD_1,ALTCAT_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,MCART_1,DOMAIN_1,RELAT_1,CARD_1,NUMBERS,STRUCT_0,FUNCT_1,FUNCT_2,BINOP_1,MULTOP_1,FUNCOP_1,PBOOLE,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB29,CKB30,CKB33,CKB37,CKB38,CKB39,CKB44,CKB45,CKB46;
definitions TARSKI,STRUCT_0,XBOOLE_0,FUNCOP_1,BINOP_1,CKB17,CKB19,CKB20,CKB21,CKB24,CKB25,CKB26,CKB29,CKB30,CKB33,CKB37,CKB38,CKB39,CKB44,CKB45,CKB46;
theorems FUNCT_1,ZFMISC_1,PBOOLE,DOMAIN_1,MULTOP_1,MCART_1,FUNCT_2,TARSKI,FUNCOP_1,RELAT_1,REALSET1,STRUCT_0,RELSET_1,XBOOLE_0,XBOOLE_1,CARD_1,PARTFUN1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB17,CKB19,CKB20,CKB21,CKB24,CKB25,CKB26,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB49,CKB50;
schemes FUNCT_1,CKB6,CKB7,CKB8,CKB9;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,FUNCOP_1,STRUCT_0,RELSET_1,ZFMISC_1,CARD_1,ORDINAL1,CKB15,CKB27,CKB28,CKB31,CKB40,CKB41,CKB48,CKB51,CKB52;
constructors PARTFUN1,BINOP_1,MULTOP_1,PBOOLE,REALSET2,RELSET_1,CKB15,CKB17,CKB19,CKB20,CKB21,CKB23,CKB24,CKB25,CKB26,CKB27,CKB29,CKB30,CKB33,CKB37,CKB38,CKB39,CKB44,CKB45,CKB46;
requirements BOOLE,SUBSET,NUMERALS;
begin
registration
cluster  with_units  pseudo-functional  transitive ->  quasi-functional  semi-functional for non  empty non  empty AltCatStr;
coherence
proof
let C being non  empty AltCatStr;
assume that
A12: C is  with_units  pseudo-functional  transitive;
thus C is  quasi-functional
proof
let a1 being (object of C);
let a2 being (object of C);
per cases ;
suppose <^ a1,a2 ^> = ( {} );

hence thesis by XBOOLE_1:2;
end;
suppose A13: <^ a1,a2 ^> <> ( {} );

set c = ( (the Comp of C) . (a1,a1,a2) );
set f = ( FuncComp (( Funcs (a1,a1) ),( Funcs (a1,a2) )) );
A14: ( dom c ) = [: <^ a1,a2 ^>,<^ a1,a1 ^> :] by A13,FUNCT_2:def 1;
(( dom f ) = [: ( Funcs (a1,a2) ),( Funcs (a1,a1) ) :] & c = ( f | ([: <^ a1,a2 ^>,<^ a1,a1 ^> :] qua set) )) by A12,CKB39:def 1,PARTFUN1:def 2;
then A15: [: <^ a1,a2 ^>,<^ a1,a1 ^> :] c= [: ( Funcs (a1,a2) ),( Funcs (a1,a1) ) :] by A14,RELAT_1:60;
<^ a1,a1 ^> <> ( {} ) by A12,CKB50:1;
hence thesis by A13,A15,ZFMISC_1:114;
end;
end;

let a1 being (object of C);
let a2 being (object of C);
let a3 being (object of C);
thus thesis by A12,CKB43:1;
end;
end;
