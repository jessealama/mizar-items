environ
vocabularies FUNCT_1,SUBSET_1,RELAT_1,FUNCT_2,XBOOLE_0,TARSKI,PBOOLE,ZFMISC_1,MCART_1,FUNCOP_1,STRUCT_0,CAT_1,RELAT_2,BINOP_1,CARD_1,ALTCAT_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,MCART_1,DOMAIN_1,RELAT_1,CARD_1,NUMBERS,STRUCT_0,FUNCT_1,FUNCT_2,BINOP_1,MULTOP_1,FUNCOP_1,PBOOLE,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB29,CKB30,CKB33,CKB37,CKB38,CKB39;
definitions TARSKI,STRUCT_0,XBOOLE_0,FUNCOP_1,BINOP_1,CKB17,CKB19,CKB20,CKB21,CKB24,CKB25,CKB26,CKB29,CKB30,CKB33,CKB37,CKB38,CKB39;
theorems FUNCT_1,ZFMISC_1,PBOOLE,DOMAIN_1,MULTOP_1,MCART_1,FUNCT_2,TARSKI,FUNCOP_1,RELAT_1,REALSET1,STRUCT_0,RELSET_1,XBOOLE_0,XBOOLE_1,CARD_1,PARTFUN1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB10,CKB11,CKB12,CKB13,CKB14,CKB17,CKB19,CKB20,CKB21,CKB24,CKB25,CKB26,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB42,CKB43;
schemes FUNCT_1,CKB6,CKB7,CKB8,CKB9;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,FUNCOP_1,STRUCT_0,RELSET_1,ZFMISC_1,CARD_1,ORDINAL1,CKB15,CKB27,CKB28,CKB31,CKB40,CKB41;
constructors PARTFUN1,BINOP_1,MULTOP_1,PBOOLE,REALSET2,RELSET_1,CKB15,CKB17,CKB19,CKB20,CKB21,CKB23,CKB24,CKB25,CKB26,CKB27,CKB29,CKB30,CKB33,CKB37,CKB38,CKB39;
requirements BOOLE,SUBSET,NUMERALS;
begin
reserve i for set;
reserve j for set;
reserve k for set;
definition
let A being non empty set;
func EnsCat A ->  strict  pseudo-functional non empty AltCatStr
means
:Def16: ((the carrier of it) = A & (for a1,a2 being (object of it) holds <^ a1,a2 ^> = ( Funcs (a1,a2) )));
existence
proof
deffunc F(set,set,set) = ( FuncComp (( Funcs ($1,$2) ),( Funcs ($2,$3) )) );
consider M being (ManySortedSet of [: A,A :]) such that A1: (for i holds (for j holds ((i in A & j in A) implies ( M . (i,j) ) = ( Funcs (i,j) )))) from CKB6:sch 1;
consider c being (ManySortedSet of [: A,A,A :]) such that A2: (for i holds (for j holds (for k holds (((i in A & j in A) & k in A) implies ( c . (i,j,k) ) = F(i,j,k))))) from CKB8:sch 1;
c is  Function-yielding
proof
let i;
assume i in ( dom c );
then i in [: A,A,A :] by PARTFUN1:def 2;
then consider x1 being set,x2 being set,x3 being set such that A3: ((x1 in A & x2 in A) & x3 in A) and A4: i = [ x1,x2,x3 ] by MCART_1:68;
( c . i ) = ( c . (x1,x2,x3) ) by A4,MULTOP_1:def 1
.= ( FuncComp (( Funcs (x1,x2) ),( Funcs (x2,x3) )) ) by A2,A3;
hence thesis;
end;
then reconsider c as (ManySortedFunction of [: A,A,A :]);
now
let i;
reconsider ci = ( c . i ) as Function;
assume i in [: A,A,A :];
then consider x1 being set,x2 being set,x3 being set such that A5: x1 in A and A6: x2 in A and A7: x3 in A and A8: i = [ x1,x2,x3 ] by MCART_1:68;
A9: ( {| M |} . i ) = ( {| M |} . (x1,x2,x3) ) by A8,MULTOP_1:def 1
.= ( M . (x1,x3) ) by A5,A6,A7,CKB20:def 1;
A10: ( c . i ) = ( c . (x1,x2,x3) ) by A8,MULTOP_1:def 1
.= ( FuncComp (( Funcs (x1,x2) ),( Funcs (x2,x3) )) ) by A2,A5,A6,A7;
(( M . (x1,x2) ) = ( Funcs (x1,x2) ) & ( M . (x2,x3) ) = ( Funcs (x2,x3) )) by A1,A5,A6,A7;
then A11: [: ( Funcs (x2,x3) ),( Funcs (x1,x2) ) :] = ( {| M,M |} . (x1,x2,x3) ) by A5,A6,A7,CKB21:def 1
.= ( {| M,M |} . i ) by A8,MULTOP_1:def 1;
A12:now
assume ( {| M,M |} . i ) <> ( {} );
then consider j such that A13: j in [: ( Funcs (x2,x3) ),( Funcs (x1,x2) ) :] by A11,XBOOLE_0:def 1;
consider j1 being set,j2 being set such that A14: j1 in ( Funcs (x2,x3) ) and A15: j2 in ( Funcs (x1,x2) ) and j = [ j1,j2 ] by A13,ZFMISC_1:84;
reconsider j2 as (Function of x1,x2) by A15,FUNCT_2:66;
reconsider j1 as (Function of x2,x3) by A14,FUNCT_2:66;
( j1 * j2 ) in ( Funcs (x1,x3) ) by A14,A15,CKB3:1;
hence ( {| M |} . i ) <> ( {} ) by A1,A5,A7,A9;
end;
( M . (x1,x3) ) = ( Funcs (x1,x3) ) by A1,A5,A7;
then A16: ( rng ci ) c= ( {| M |} . i ) by A10,A9,CKB34:1;
( dom ci ) = [: ( Funcs (x2,x3) ),( Funcs (x1,x2) ) :] by A10,PARTFUN1:def 2;
hence ( c . i ) is (Function of ( {| M,M |} . i ),( {| M |} . i )) by A11,A16,A12,FUNCT_2:def 1,RELSET_1:4;
end;
then reconsider c as (BinComp of M) by PBOOLE:def 15;
set C = AltCatStr (# A,M,c #);
C is  pseudo-functional
proof
let o1 being (object of C),o2 being (object of C),o3 being (object of C);
(<^ o1,o2 ^> = ( Funcs (o1,o2) ) & <^ o2,o3 ^> = ( Funcs (o2,o3) )) by A1;
then A17: ( dom ( FuncComp (( Funcs (o1,o2) ),( Funcs (o2,o3) )) ) ) = [: <^ o2,o3 ^>,<^ o1,o2 ^> :] by PARTFUN1:def 2;
thus ( (the Comp of C) . (o1,o2,o3) ) = ( FuncComp (( Funcs (o1,o2) ),( Funcs (o2,o3) )) ) by A2
.= ( ( FuncComp (( Funcs (o1,o2) ),( Funcs (o2,o3) )) ) | ([: <^ o2,o3 ^>,<^ o1,o2 ^> :] qua set) ) by A17,RELAT_1:68;
end;
then reconsider C as  strict  pseudo-functional non empty AltCatStr;
take C;
thus (the carrier of C) = A;
let a1 being (object of C),a2 being (object of C);
thus thesis by A1;
end;
uniqueness
proof
let C1 being  strict  pseudo-functional non empty AltCatStr,C2 being  strict  pseudo-functional non empty AltCatStr;
assume that
A18: (the carrier of C1) = A
and
A19: (for a1,a2 being (object of C1) holds <^ a1,a2 ^> = ( Funcs (a1,a2) ))
and
A20: (the carrier of C2) = A
and
A21: (for a1,a2 being (object of C2) holds <^ a1,a2 ^> = ( Funcs (a1,a2) ));
A22:now
let i;
let j;
assume A23: (i in A & j in A);
then reconsider a1 = i,a2 = j as (object of C1) by A18;
reconsider b1 = i,b2 = j as (object of C2) by A20,A23;
thus ( (the Arrows of C1) . (i,j) ) = <^ a1,a2 ^>
.= ( Funcs (a1,a2) ) by A19
.= <^ b1,b2 ^> by A21
.= ( (the Arrows of C2) . (i,j) );
end;
A24:now
let i;
let j;
let k;
assume A25: ((i in A & j in A) & k in A);
then reconsider a1 = i,a2 = j,a3 = k as (object of C1) by A18;
reconsider b1 = i,b2 = j,b3 = k as (object of C2) by A20,A25;
(<^ a2,a3 ^> = <^ b2,b3 ^> & <^ a1,a2 ^> = <^ b1,b2 ^>) by A18,A22;
hence ( (the Comp of C1) . (i,j,k) ) = ( ( FuncComp (( Funcs (b1,b2) ),( Funcs (b2,b3) )) ) | ([: <^ b2,b3 ^>,<^ b1,b2 ^> :] qua set) ) by CKB39:def 1
.= ( (the Comp of C2) . (i,j,k) ) by CKB39:def 1;
end;
(the Arrows of C1) = (the Arrows of C2) by A18,A20,A22,CKB10:1;
hence thesis by A18,A20,A24,CKB12:1;
end;
end;
