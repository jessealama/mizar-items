environ
vocabularies FUNCT_1,SUBSET_1,RELAT_1,FUNCT_2,XBOOLE_0,TARSKI,PBOOLE,ZFMISC_1,MCART_1,FUNCOP_1,STRUCT_0,CAT_1,RELAT_2,BINOP_1,CARD_1,ALTCAT_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,MCART_1,DOMAIN_1,RELAT_1,CARD_1,NUMBERS,STRUCT_0,FUNCT_1,FUNCT_2,BINOP_1,MULTOP_1,FUNCOP_1,PBOOLE;
definitions TARSKI,STRUCT_0,XBOOLE_0,FUNCOP_1,BINOP_1;
theorems FUNCT_1,ZFMISC_1,PBOOLE,DOMAIN_1,MULTOP_1,MCART_1,FUNCT_2,TARSKI,FUNCOP_1,RELAT_1,REALSET1,STRUCT_0,RELSET_1,XBOOLE_0,XBOOLE_1,CARD_1,PARTFUN1,CKB1,CKB2,CKB3,CKB4,CKB5;
schemes FUNCT_1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,FUNCOP_1,STRUCT_0,RELSET_1,ZFMISC_1,CARD_1,ORDINAL1;
constructors PARTFUN1,BINOP_1,MULTOP_1,PBOOLE,REALSET2,RELSET_1;
requirements BOOLE,SUBSET,NUMERALS;
begin
reserve i for set;
reserve j for set;
reserve x for set;
scheme MSSLambda2 { A,B() -> set,F(set,set) -> set } : (ex M being (ManySortedSet of [: A(),B() :]) st (for i holds (for j holds ((i in A() & j in B()) implies ( M . (i,j) ) = F(i,j)))))
proof
deffunc F(set) = F(( $1 `1 ),( $1 `2 ));
consider f being Function such that A1: ( dom f ) = [: A(),B() :] and A2: (for x holds (x in [: A(),B() :] implies ( f . x ) = F(x))) from FUNCT_1:sch 3;
reconsider f as (ManySortedSet of [: A(),B() :]) by A1,PARTFUN1:def 2,RELAT_1:def 18;
take f;
let i;
let j;
assume (i in A() & j in B());
then A3: [ i,j ] in [: A(),B() :] by ZFMISC_1:87;
(( [ i,j ] `1 ) = i & ( [ i,j ] `2 ) = j) by MCART_1:7;
hence thesis by A2,A3;
end;
