environ
vocabularies NUMBERS,SUBSET_1,REAL_1,PARTFUN1,SEQFUNC,XREAL_0,ORDINAL1,VALUED_1,RELAT_1,ARYTM_1,MEMBER_1,FUNCT_1,ARYTM_3,TARSKI,XBOOLE_0,CARD_1,NAT_1,VALUED_0,ZFMISC_1,SEQ_1,FUNCOP_1,XXREAL_0,CARD_3,SERIES_1,DIFF_1,FUNCT_2;
notations ORDINAL1,XCMPLX_0,XREAL_0,REAL_1,NAT_1,SERIES_1,XXREAL_0,TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,FUNCT_1,PARTFUN1,VALUED_0,VALUED_1,SEQ_1,FUNCOP_1,NAT_D,NEWTON,MEASURE6,FUNCT_2,RELSET_1,SEQFUNC,CKB1,CKB2,CKB3,CKB5,CKB7,CKB9,CKB10,CKB22,CKB23;
definitions VALUED_1,CKB1,CKB2,CKB3,CKB5,CKB7,CKB9,CKB22;
theorems FUNCT_2,PARTFUN1,SEQFUNC,ORDINAL1,FUNCT_1,SEQ_1,XBOOLE_0,XCMPLX_1,NEWTON,FUNCOP_1,SERIES_1,TARSKI,MEASURE6,RFUNCT_1,ZFMISC_1,VALUED_1,XREAL_1,RELSET_1,CKB1,CKB2,CKB3,CKB5,CKB7,CKB9,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30;
schemes NAT_1,RECDEF_1,SEQ_1;
registrations XBOOLE_0,RELAT_1,ORDINAL1,PARTFUN1,NUMBERS,XREAL_0,MEMBERED,VALUED_0,VALUED_1,FUNCT_2,RELSET_1,CKB4,CKB6,CKB8;
constructors REAL_1,SEQFUNC,NEWTON,SERIES_1,MEASURE6,NAT_D,PARTFUN3,SEQ_1,FUNCOP_1,RELSET_1,CKB1,CKB2,CKB3,CKB5,CKB7,CKB9,CKB22;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve n for (Element of ( NAT ));
reserve k for (Element of ( NAT ));
definition
let f being (PartFunc of ( REAL ),( REAL ));
let h being  real number;
func central_difference (f,h) -> (Functional_Sequence of ( REAL ),( REAL ))
means
:Def8: (( it . ( 0 ) ) = f & (for n being Nat holds ( it . ( n + 1 ) ) = ( cD (( it . n ),h) )));
existence
proof
reconsider fZ = f as (Element of ( PFuncs (( REAL ),( REAL )) )) by PARTFUN1:45;
defpred R[ set,set,set ]
 means
(ex g being (PartFunc of ( REAL ),( REAL )) st ($2 = g & $3 = ( cD (g,h) )));
A1: (for n holds (for x being (Element of ( PFuncs (( REAL ),( REAL )) )) holds (ex y being (Element of ( PFuncs (( REAL ),( REAL )) )) st R[ n,x,y ])))
proof
let n;
let x being (Element of ( PFuncs (( REAL ),( REAL )) ));
reconsider x9 = x as (PartFunc of ( REAL ),( REAL )) by PARTFUN1:46;
reconsider y = ( cD (x9,h) ) as (Element of ( PFuncs (( REAL ),( REAL )) )) by PARTFUN1:45;
(ex w being (PartFunc of ( REAL ),( REAL )) st (x = w & y = ( cD (w,h) )));
hence thesis;
end;
consider g being (Function of ( NAT ),( PFuncs (( REAL ),( REAL )) )) such that A2: (( g . ( 0 ) ) = fZ & (for n being (Element of ( NAT )) holds R[ n,( g . n ),( g . ( n + 1 ) ) ])) from RECDEF_1:sch 2(A1);
reconsider g as (Functional_Sequence of ( REAL ),( REAL ));
take g;
thus ( g . ( 0 ) ) = f by A2;
let i being  natural number;
i in ( NAT ) by ORDINAL1:def 12;
then R[ i,( g . i ),( g . ( i + 1 ) ) ] by A2;
hence thesis;
end;
uniqueness
proof
let seq1 being (Functional_Sequence of ( REAL ),( REAL )),seq2 being (Functional_Sequence of ( REAL ),( REAL ));
assume that
A3: ( seq1 . ( 0 ) ) = f
and
A4: (for n being Nat holds ( seq1 . ( n + 1 ) ) = ( cD (( seq1 . n ),h) ))
and
A5: ( seq2 . ( 0 ) ) = f
and
A6: (for n being Nat holds ( seq2 . ( n + 1 ) ) = ( cD (( seq2 . n ),h) ));
defpred P[ Nat ]
 means
( seq1 . $1 ) = ( seq2 . $1 );
A7: (for k holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k;
assume A8: P[ k ];
thus ( seq1 . ( k + 1 ) ) = ( cD (( seq1 . k ),h) ) by A4
.= ( seq2 . ( k + 1 ) ) by A6,A8;
end;
A9: P[ ( 0 ) ] by A3,A5;
(for n holds P[ n ]) from NAT_1:sch 1(A9,A7);
hence seq1 = seq2 by FUNCT_2:63;
end;
end;
