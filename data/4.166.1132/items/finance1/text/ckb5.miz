environ
vocabularies FINANCE1,NUMBERS,XBOOLE_0,PROB_1,SUBSET_1,FUNCT_1,TARSKI,RELAT_1,CARD_1,ARYTM_1,CARD_3,PROB_3,NAT_1,ARYTM_3,XREAL_0,ORDINAL1,XXREAL_0,SERIES_1,EQREL_1,MEASURE6,SEQ_1,XXREAL_1,MESFUNC1,RANDOM_1,RANDOM_2,FUNCOP_1,VALUED_1;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,XXREAL_0,NAT_1,XREAL_0,NUMBERS,FUNCT_1,RELSET_1,FUNCT_2,PROB_3,SERIES_1,PROB_1,MEASURE6,SEQ_1,BINOP_2,MESFUNC1,MESFUNC6,RANDOM_1,INT_1,KOLMOG01,XXREAL_1,RCOMP_1,FUNCOP_1,VALUED_1,RANDOM_2,CKB1,CKB2;
definitions XXREAL_0,PROB_1,SUBSET_1,TARSKI,FUNCT_2;
theorems SERIES_1,PROB_1,PROB_3,XBOOLE_0,NAT_1,FUNCT_2,XXREAL_0,ORDINAL1,TARSKI,XREAL_1,XXREAL_1,MESFUNC1,MEASURE6,FINSUB_1,MESFUNC6,XREAL_0,RANDOM_1,RANDOM_2,FUNCOP_1,VALUED_1,FRECHET,XBOOLE_1,CKB3,CKB4;
schemes NAT_1,FUNCT_2,RECDEF_1;
registrations XBOOLE_0,SUBSET_1,ORDINAL1,RELSET_1,NUMBERS,XREAL_0,MEMBERED,PROB_1,VALUED_0,XXREAL_0,NAT_1,XCMPLX_0,VALUED_1,FUNCT_2;
constructors REAL_1,SEQ_1,PROB_3,SERIES_1,BINOP_2,RELSET_1,MEASURE6,RCOMP_1,MESFUNC1,MESFUNC6,KOLMOG01,RANDOM_2,FUNCOP_1,CKB2;
requirements SUBSET,NUMERALS,BOOLE,ARITHM,REAL;
begin
reserve Omega for non  empty set;
reserve F for (SigmaField of Omega);
definition
let a being  real number;
let b being  real number;
func half_open_sets (a,b) -> (SetSequence of ( REAL )) means 
:Def3: (( it . ( 0 ) ) = ( halfline_fin (a,( b + 1 )) ) & (for n being (Element of ( NAT )) holds ( it . ( n + 1 ) ) = ( halfline_fin (a,( b + ( 1 / ( n + 1 ) ) )) )));
existence
proof
defpred P[ set,set,set ]
 means
(for x,y being (Subset of ( REAL )) holds (for s being Nat holds (((s = $1 & x = $2) & y = $3) implies y = ( halfline_fin (a,( b + ( 1 / ( s + 1 ) ) )) ))));
A1: (for n being (Element of ( NAT )) holds (for x being (Subset of ( REAL )) holds (ex y being (Subset of ( REAL )) st P[ n,x,y ])))
proof
let n being (Element of ( NAT ));
let x being (Subset of ( REAL ));
take ( halfline_fin (a,( b + ( 1 / ( n + 1 ) ) )) );
thus thesis;
end;
consider F being (SetSequence of ( REAL )) such that A2: ( F . ( 0 ) ) = ( halfline_fin (a,( b + 1 )) ) and A3: (for n being (Element of ( NAT )) holds P[ n,( F . n ),( F . ( n + 1 ) ) ]) from RECDEF_1:sch 2(A1);
take F;
thus ( F . ( 0 ) ) = ( halfline_fin (a,( b + 1 )) ) by A2;
let n being Nat;
reconsider n as (Element of ( NAT )) by ORDINAL1:def 12;
P[ n,( F . n ),( F . ( n + 1 ) ) ] by A3;
hence thesis;
end;
uniqueness
proof
let S1 being (SetSequence of ( REAL ));
let S2 being (SetSequence of ( REAL ));
assume that
A1: (( S1 . ( 0 ) ) = ( halfline_fin (a,( b + 1 )) ) & (for n being (Element of ( NAT )) holds ( S1 . ( n + 1 ) ) = ( halfline_fin (a,( b + ( 1 / ( n + 1 ) ) )) )))
and
A2: (( S2 . ( 0 ) ) = ( halfline_fin (a,( b + 1 )) ) & (for n being (Element of ( NAT )) holds ( S2 . ( n + 1 ) ) = ( halfline_fin (a,( b + ( 1 / ( n + 1 ) ) )) )));
defpred P[ set ]
 means
( S1 . $1 ) = ( S2 . $1 );
(for n being set holds (n in ( NAT ) implies P[ n ]))
proof
let n being set;
assume n in ( NAT );
then reconsider n as (Element of ( NAT ));
A3: P[ ( 0 ) ] by A1,A2;
A4: (for k being (Element of ( NAT )) holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume ( S1 . k ) = ( S2 . k );
thus ( S1 . ( k + 1 ) ) = ( halfline_fin (a,( b + ( 1 / ( k + 1 ) ) )) ) by A1
.= ( S2 . ( k + 1 ) ) by A2;
end;
(for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A3,A4);
then ( S1 . n ) = ( S2 . n );
hence thesis;
end;
hence thesis by FUNCT_2:12;
end;
end;
