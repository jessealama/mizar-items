environ
vocabularies NUMBERS,FINSEQ_1,QC_LANG1,SUBSET_1,ZF_LANG,XBOOLEAN,XXREAL_0,CARD_1,ORDINAL4,BVFUNC_2,FUNCT_1,CLASSES2,MCART_1,REALSET1,ARYTM_3,NAT_1,RELAT_1,ARYTM_1,TARSKI,XBOOLE_0,QC_LANG2;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,XCMPLX_0,RELAT_1,FUNCT_1,NUMBERS,NAT_1,FINSEQ_1,MCART_1,QC_LANG1,XXREAL_0;
definitions TARSKI,QC_LANG1,XBOOLE_0;
theorems TARSKI,ENUMSET1,NAT_1,FUNCT_1,FINSEQ_1,QC_LANG1,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,ORDINAL1,CKB1;
schemes NAT_1,XBOOLE_0;
registrations RELSET_1,XREAL_0,FINSEQ_1,ORDINAL1;
constructors ENUMSET1,XXREAL_0,XREAL_0,NAT_1,QC_LANG1;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve sq for FinSequence;
reserve p for (Element of ( QC-WFF ));
reserve q for (Element of ( QC-WFF ));
reserve p1 for (Element of ( QC-WFF ));
reserve q1 for (Element of ( QC-WFF ));
theorem
Th3: (( p '&' q ) = ( p1 '&' q1 ) implies (p = p1 & q = q1))
proof
assume A1: ( p '&' q ) = ( p1 '&' q1 );
(( ( <* [ 2,( 0 ) ] *> ^ ( @ p ) ) ^ ( @ q ) ) = ( <* [ 2,( 0 ) ] *> ^ ( ( @ p ) ^ ( @ q ) ) ) & ( ( <* [ 2,( 0 ) ] *> ^ ( @ p1 ) ) ^ ( @ q1 ) ) = ( <* [ 2,( 0 ) ] *> ^ ( ( @ p1 ) ^ ( @ q1 ) ) )) by FINSEQ_1:32;
then A2: ( ( @ p ) ^ ( @ q ) ) = ( ( @ p1 ) ^ ( @ q1 ) ) by A1,FINSEQ_1:33;
then A3: (( len ( @ p1 ) ) <= ( len ( @ p ) ) implies (ex sq st ( @ p ) = ( ( @ p1 ) ^ sq ))) by FINSEQ_1:47;
A4: (( len ( @ p ) ) <= ( len ( @ p1 ) ) implies (ex sq st ( @ p1 ) = ( ( @ p ) ^ sq ))) by A2,FINSEQ_1:47;
hence p = p1 by A3,QC_LANG1:11;
((ex sq st ( @ p1 ) = ( ( @ p ) ^ sq )) implies p1 = p) by QC_LANG1:11;
hence thesis by A1,A3,A4,FINSEQ_1:33,QC_LANG1:11;
end;
