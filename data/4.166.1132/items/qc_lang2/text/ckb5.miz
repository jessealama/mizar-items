environ
vocabularies NUMBERS,FINSEQ_1,QC_LANG1,SUBSET_1,ZF_LANG,XBOOLEAN,XXREAL_0,CARD_1,ORDINAL4,BVFUNC_2,FUNCT_1,CLASSES2,MCART_1,REALSET1,ARYTM_3,NAT_1,RELAT_1,ARYTM_1,TARSKI,XBOOLE_0,QC_LANG2;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,XCMPLX_0,RELAT_1,FUNCT_1,NUMBERS,NAT_1,FINSEQ_1,MCART_1,QC_LANG1,XXREAL_0;
definitions TARSKI,QC_LANG1,XBOOLE_0;
theorems TARSKI,ENUMSET1,NAT_1,FUNCT_1,FINSEQ_1,QC_LANG1,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,ORDINAL1,CKB1,CKB2,CKB3,CKB4;
schemes NAT_1,XBOOLE_0;
registrations RELSET_1,XREAL_0,FINSEQ_1,ORDINAL1;
constructors ENUMSET1,XXREAL_0,XREAL_0,NAT_1,QC_LANG1;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve x for bound_QC-variable;
reserve y for bound_QC-variable;
reserve p for (Element of ( QC-WFF ));
reserve q for (Element of ( QC-WFF ));
theorem
Th6: (( All (x,p) ) = ( All (y,q) ) implies (x = y & p = q))
proof
A1: (( ( <* [ 3,( 0 ) ] *> ^ <* x *> ) ^ ( @ p ) ) = ( <* [ 3,( 0 ) ] *> ^ ( <* x *> ^ ( @ p ) ) ) & ( ( <* [ 3,( 0 ) ] *> ^ <* y *> ) ^ ( @ q ) ) = ( <* [ 3,( 0 ) ] *> ^ ( <* y *> ^ ( @ q ) ) )) by FINSEQ_1:32;
A2: (( ( <* x *> ^ ( @ p ) ) . 1 ) = x & ( ( <* y *> ^ ( @ q ) ) . 1 ) = y) by FINSEQ_1:41;
assume A3: ( All (x,p) ) = ( All (y,q) );
hence x = y by A1,A2,FINSEQ_1:33;
( <* x *> ^ ( @ p ) ) = ( <* y *> ^ ( @ q ) ) by A3,A1,FINSEQ_1:33;
hence thesis by A2,FINSEQ_1:33;
end;
