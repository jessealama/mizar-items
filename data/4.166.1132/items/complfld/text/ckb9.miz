environ
vocabularies STRUCT_0,ALGSTR_0,NUMBERS,BINOP_2,MESFUNC1,COMPLEX1,SUPINF_2,XBOOLE_0,XCMPLX_0,SUBSET_1,ORDINAL1,ARYTM_3,FUNCT_1,RELAT_1,VECTSP_1,GROUP_1,RLVECT_1,BINOP_1,LATTICES,ARYTM_1,CARD_1,XXREAL_0,NAT_1,NEWTON,COMPTRIG,COMPLFLD;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,NUMBERS,XCMPLX_0,COMPLEX1,NAT_1,FUNCT_1,XXREAL_0,COMPTRIG,BINOP_1,BINOP_2,STRUCT_0,ALGSTR_0,RLVECT_1,GROUP_1,NEWTON,VECTSP_1,CKB1;
definitions RLVECT_1,GROUP_1,VECTSP_1,BINOP_1,COMPTRIG,STRUCT_0,COMPLEX1,ALGSTR_0,CKB1;
theorems STRUCT_0,COMPLEX1,RLVECT_1,VECTSP_1,XREAL_0,XCMPLX_0,XCMPLX_1,BINOP_2,GROUP_1,COMPTRIG,NEWTON,ORDINAL1,NAT_1,XREAL_1,CKB1,CKB7,CKB8;
schemes NAT_1;
registrations ORDINAL1,RELSET_1,NUMBERS,XCMPLX_0,NAT_1,COMPLEX1,STRUCT_0,VECTSP_1,XREAL_0,XBOOLE_0,CKB2,CKB3,CKB6,CKB4,CKB5;
constructors BINOP_1,XXREAL_0,REAL_1,NAT_1,BINOP_2,NEWTON,COMPTRIG,VECTSP_1,RLVECT_1,CKB1;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
registration
cluster ( F_Complex ) ->  add-associative  right_zeroed  right_complementable  Abelian  commutative  associative  left_unital  right_unital  distributive  almost_left_invertible non  degenerated;
coherence
proof
thus ( F_Complex ) is  add-associative
proof
let x being (Element of ( F_Complex ));
let y being (Element of ( F_Complex ));
let z being (Element of ( F_Complex ));
reconsider x1 = x,y1 = y,z1 = z as (Element of ( COMPLEX )) by CKB1:def 1;
thus ( ( x + y ) + z ) = ( ( addcomplex ) . [ ( (the addF of ( F_Complex )) . [ x1,y1 ] ),z1 ] ) by CKB1:def 1
.= ( ( addcomplex ) . (( ( addcomplex ) . (x1,y1) ),z1) ) by CKB1:def 1
.= ( ( addcomplex ) . (( x1 + y1 ),z1) ) by BINOP_2:def 3
.= ( ( x1 + y1 ) + z1 ) by BINOP_2:def 3
.= ( x1 + ( y1 + z1 ) )
.= ( ( addcomplex ) . (x1,( y1 + z1 )) ) by BINOP_2:def 3
.= ( ( addcomplex ) . [ x1,( ( addcomplex ) . (y1,z1) ) ] ) by BINOP_2:def 3
.= ( ( addcomplex ) . [ x1,( (the addF of ( F_Complex )) . [ y1,z1 ] ) ] ) by CKB1:def 1
.= ( x + ( y + z ) ) by CKB1:def 1;
end;

thus ( F_Complex ) is  right_zeroed
proof
let x being (Element of ( F_Complex ));
reconsider x1 = x as (Element of ( COMPLEX )) by CKB1:def 1;
thus ( x + ( 0. ( F_Complex ) ) ) = ( (the addF of ( F_Complex )) . (x1,( 0c )) ) by CKB1:def 1
.= ( ( addcomplex ) . (x1,( 0c )) ) by CKB1:def 1
.= ( x1 + ( 0c ) ) by BINOP_2:def 3
.= x;
end;

thus ( F_Complex ) is  right_complementable
proof
let x being (Element of ( F_Complex ));
reconsider x1 = x as (Element of ( COMPLEX )) by CKB1:def 1;
reconsider y = ( - x1 ) as (Element of ( F_Complex )) by CKB1:def 1;
take y;
thus thesis by CKB1:def 1;
end;

thus ( F_Complex ) is  Abelian
proof
let x being (Element of ( F_Complex ));
let y being (Element of ( F_Complex ));
thus thesis;
end;

thus ( F_Complex ) is  commutative
proof
let x being (Element of ( F_Complex ));
let y being (Element of ( F_Complex ));
thus thesis;
end;

thus ( F_Complex ) is  associative
proof
let x being (Element of ( F_Complex ));
let y being (Element of ( F_Complex ));
let z being (Element of ( F_Complex ));
reconsider x1 = x,y1 = y,z1 = z as (Element of ( COMPLEX )) by CKB1:def 1;
thus ( ( x * y ) * z ) = ( ( multcomplex ) . (( (the multF of ( F_Complex )) . (x1,y1) ),z1) ) by CKB1:def 1
.= ( ( multcomplex ) . (( ( multcomplex ) . (x1,y1) ),z1) ) by CKB1:def 1
.= ( ( multcomplex ) . (( x1 * y1 ),z1) ) by BINOP_2:def 5
.= ( ( x1 * y1 ) * z1 ) by BINOP_2:def 5
.= ( x1 * ( y1 * z1 ) )
.= ( ( multcomplex ) . (x1,( y1 * z1 )) ) by BINOP_2:def 5
.= ( ( multcomplex ) . (x1,( ( multcomplex ) . (y1,z1) )) ) by BINOP_2:def 5
.= ( ( multcomplex ) . (x1,( (the multF of ( F_Complex )) . (y1,z1) )) ) by CKB1:def 1
.= ( x * ( y * z ) ) by CKB1:def 1;
end;

thus ( F_Complex ) is  left_unital;
thus ( F_Complex ) is  right_unital;
thus ( F_Complex ) is  distributive
proof
let x being (Element of ( F_Complex ));
let y being (Element of ( F_Complex ));
let z being (Element of ( F_Complex ));
reconsider x1 = x,y1 = y,z1 = z as (Element of ( COMPLEX )) by CKB1:def 1;
thus ( x * ( y + z ) ) = ( ( multcomplex ) . (x1,( (the addF of ( F_Complex )) . (y1,z1) )) ) by CKB1:def 1
.= ( ( multcomplex ) . (x1,( ( addcomplex ) . (y1,z1) )) ) by CKB1:def 1
.= ( ( multcomplex ) . (x1,( y1 + z1 )) ) by BINOP_2:def 3
.= ( x1 * ( y1 + z1 ) ) by BINOP_2:def 5
.= ( ( x1 * y1 ) + ( x1 * z1 ) )
.= ( ( addcomplex ) . (( x1 * y1 ),( x1 * z1 )) ) by BINOP_2:def 3
.= ( ( addcomplex ) . (( ( multcomplex ) . (x1,y1) ),( x1 * z1 )) ) by BINOP_2:def 5
.= ( ( addcomplex ) . (( ( multcomplex ) . (x1,y1) ),( ( multcomplex ) . (x1,z1) )) ) by BINOP_2:def 5
.= ( (the addF of ( F_Complex )) . (( ( multcomplex ) . (x1,y1) ),( ( multcomplex ) . (x1,z1) )) ) by CKB1:def 1
.= ( (the addF of ( F_Complex )) . (( (the multF of ( F_Complex )) . (x1,y1) ),( ( multcomplex ) . (x1,z1) )) ) by CKB1:def 1
.= ( ( x * y ) + ( x * z ) ) by CKB1:def 1;
thus ( ( y + z ) * x ) = ( ( multcomplex ) . (( (the addF of ( F_Complex )) . (y1,z1) ),x1) ) by CKB1:def 1
.= ( ( multcomplex ) . (( ( addcomplex ) . (y1,z1) ),x1) ) by CKB1:def 1
.= ( ( multcomplex ) . (( y1 + z1 ),x1) ) by BINOP_2:def 3
.= ( ( y1 + z1 ) * x1 ) by BINOP_2:def 5
.= ( ( y1 * x1 ) + ( z1 * x1 ) )
.= ( ( addcomplex ) . (( y1 * x1 ),( z1 * x1 )) ) by BINOP_2:def 3
.= ( ( addcomplex ) . (( ( multcomplex ) . (y1,x1) ),( z1 * x1 )) ) by BINOP_2:def 5
.= ( ( addcomplex ) . (( ( multcomplex ) . (y1,x1) ),( ( multcomplex ) . (z1,x1) )) ) by BINOP_2:def 5
.= ( (the addF of ( F_Complex )) . (( ( multcomplex ) . (y1,x1) ),( ( multcomplex ) . (z1,x1) )) ) by CKB1:def 1
.= ( (the addF of ( F_Complex )) . (( (the multF of ( F_Complex )) . (y1,x1) ),( ( multcomplex ) . (z1,x1) )) ) by CKB1:def 1
.= ( ( y * x ) + ( z * x ) ) by CKB1:def 1;
end;

thus ( F_Complex ) is  almost_left_invertible
proof
let x being (Element of ( F_Complex ));
reconsider x1 = x as (Element of ( COMPLEX )) by CKB1:def 1;
assume A1: x <> ( 0. ( F_Complex ) );
reconsider y = ( x1 " ) as (Element of ( F_Complex )) by CKB1:def 1;
take y;
x1 <> ( 0c ) by A1,CKB1:def 1;
hence thesis by CKB8:1,XCMPLX_0:def 7;
end;

( 0. ( F_Complex ) ) <> ( 1. ( F_Complex ) ) by CKB1:def 1,CKB7:1;
hence ( F_Complex ) is non  degenerated by STRUCT_0:def 8;
end;
end;
