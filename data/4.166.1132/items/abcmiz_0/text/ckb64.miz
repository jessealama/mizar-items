environ
vocabularies NUMBERS,ZFMISC_1,RELAT_2,REWRITE1,XBOOLE_0,ORDERS_2,PRELAMB,SUBSET_1,IDEAL_1,TARSKI,RELAT_1,STRUCT_0,ARYTM_3,XXREAL_0,WAYBEL_0,LATTICE3,LATTICES,EQREL_1,CARD_FIL,YELLOW_0,ORDINAL2,BINOP_1,FUNCT_1,OPOSET_1,CARD_1,FUNCOP_1,FINSUB_1,YELLOW_1,ARYTM_0,WELLORD2,FINSEQ_1,FUNCT_7,NAT_1,ORDINAL1,ORDINAL4,FINSET_1,FINSEQ_5,ARYTM_1,ABCMIZ_0;
notations TARSKI,XBOOLE_0,ZFMISC_1,RELAT_1,RELAT_2,SUBSET_1,ORDINAL1,FINSUB_1,CARD_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,BINOP_1,FUNCOP_1,FINSET_1,FINSEQ_1,FUNCT_4,ALG_1,FINSEQ_5,NUMBERS,XCMPLX_0,NAT_1,DOMAIN_1,STRUCT_0,ORDERS_2,LATTICE3,REWRITE1,YELLOW_0,WAYBEL_0,YELLOW_1,YELLOW_7,XXREAL_0,CKB2,CKB3,CKB5,CKB6,CKB12,CKB13,CKB14,CKB16,CKB18,CKB19,CKB25,CKB29,CKB31,CKB33,CKB35,CKB37,CKB38,CKB45,CKB51,CKB52,CKB54,CKB62;
definitions TARSKI,XBOOLE_0,RELAT_2,FUNCT_1,FINSEQ_1,LATTICE3,REWRITE1,YELLOW_0,WAYBEL_0,STRUCT_0,RELSET_1,CKB3,CKB5,CKB6,CKB13,CKB16,CKB18,CKB19,CKB29,CKB31,CKB33,CKB35,CKB37,CKB38,CKB45,CKB51,CKB52,CKB54,CKB62;
theorems TARSKI,XBOOLE_0,XBOOLE_1,SUBSET_1,FINSUB_1,NAT_1,FINSEQ_1,CARD_1,TREES_1,FINSEQ_5,FINSEQ_6,RELAT_1,RELSET_1,FUNCT_1,FUNCT_2,FUNCT_4,FUNCOP_1,STRUCT_0,ORDERS_2,LATTICE3,YELLOW_0,WAYBEL_0,YELLOW_1,YELLOW_4,YELLOW_7,WAYBEL_6,WAYBEL_8,ZFMISC_1,FINSEQ_2,FINSEQ_3,HILBERT2,REWRITE1,ORDINAL1,XREAL_1,XXREAL_0,PRE_POLY,CKB3,CKB5,CKB6,CKB11,CKB13,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB48,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56,CKB57,CKB58,CKB59,CKB60,CKB61,CKB62,CKB63;
schemes XBOOLE_0,NAT_1,FUNCT_1,FUNCT_2,RECDEF_1,RELSET_1,ORDERS_1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_2,FINSET_1,FINSUB_1,XXREAL_0,XREAL_0,NAT_1,FINSEQ_1,FINSEQ_5,REWRITE1,STRUCT_0,LATTICE3,YELLOW_0,WAYBEL_0,YELLOW_1,YELLOW_7,YELLOW_9,ORDINAL1,CARD_1,RELSET_1,CKB1,CKB4,CKB7,CKB8,CKB9,CKB10,CKB12,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB47,CKB49,CKB50;
constructors FINSUB_1,XXREAL_0,NAT_1,FINSEQ_5,REWRITE1,BORSUK_1,LATTICE3,WAYBEL_0,YELLOW_1,FUNCOP_1,XREAL_0,CKB3,CKB6,CKB12,CKB13,CKB16,CKB18,CKB19,CKB25,CKB29,CKB31,CKB33,CKB37,CKB38,CKB45,CKB51,CKB52,CKB54,CKB62;
requirements BOOLE,SUBSET,NUMERALS,REAL,ARITHM;
begin
definition
let T being non  empty non  void  reflexive  transitive TA-structure;
let t being (type of T);
let p being (FinSequence of (the adjectives of T));
func apply (p,t) -> (FinSequence of (the carrier of T)) means 
:Def19: ((( len it ) = ( ( len p ) + 1 ) & ( it . 1 ) = t) & (for i being (Element of ( NAT )) holds (for a being (adjective of T) holds (for t being (type of T) holds (((i in ( dom p ) & a = ( p . i )) & t = ( it . i )) implies ( it . ( i + 1 ) ) = ( a ast t ))))));
existence
proof
defpred P[ set,set,set ]
 means
(ex a being (adjective of T) st (a = ( p . $1 ) & (((not $2 is (type of T)) & $3 = ( 0 )) or (ex t being (type of T) st (t = $2 & $3 = ( a ast t ))))));
A1: (for i being (Element of ( NAT )) holds ((1 <= i & i < ( ( len p ) + 1 )) implies (for x being set holds (ex y being set st P[ i,x,y ]))))
proof
let i being (Element of ( NAT ));
assume A2: 1 <= i;
assume i < ( ( len p ) + 1 );
then i <= ( len p ) by NAT_1:13;
then i in ( dom p ) by A2,FINSEQ_3:25;
then ( p . i ) in ( rng p ) by FUNCT_1:3;
then reconsider a = ( p . i ) as (adjective of T);
let x being set;
per cases ;
suppose A3: (not x is (type of T));

take ( 0 );
take a;
thus thesis by A3;
end;
suppose x is (type of T);

then reconsider t = x as (type of T);
take ( a ast t );
take a;
thus a = ( p . i );
thus thesis;
end;
end;
consider q being FinSequence such that A4: ( len q ) = ( ( len p ) + 1 ) and A5: (( q . 1 ) = t or ( ( len p ) + 1 ) = ( 0 )) and A6: (for i being (Element of ( NAT )) holds ((1 <= i & i < ( ( len p ) + 1 )) implies P[ i,( q . i ),( q . ( i + 1 ) ) ])) from RECDEF_1:sch 3(A1);
defpred P[ (Element of ( NAT )) ]
 means
($1 in ( dom q ) implies ( q . $1 ) is (type of T));
A7:now
let k being (Element of ( NAT ));
assume that
A8: P[ k ];
now
assume ( k + 1 ) in ( dom q );
then ( k + 1 ) <= ( len q ) by FINSEQ_3:25;
then A9: k < ( len q ) by NAT_1:13;
A10: (k <> ( 0 ) implies k >= ( ( 0 ) + 1 )) by NAT_1:13;
then (k <> ( 0 ) implies (ex a being (adjective of T) st (a = ( p . k ) & (((not ( q . k ) is (type of T)) & ( q . ( k + 1 ) ) = ( 0 )) or (ex t being (type of T) st (t = ( q . k ) & ( q . ( k + 1 ) ) = ( a ast t ))))))) by A4,A6,A9;
hence ( q . ( k + 1 ) ) is (type of T) by A5,A8,A10,A9,FINSEQ_3:25;
end;
hence P[ ( k + 1 ) ];
end;
A11: P[ ( 0 ) ] by FINSEQ_3:24;
A12: (for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A11,A7);
( rng q ) c= (the carrier of T)
proof
let a being set;
assume a in ( rng q );
then (ex x being set st (x in ( dom q ) & a = ( q . x ))) by FUNCT_1:def 3;
then a is (type of T) by A12;
hence thesis;
end;
then reconsider q as (FinSequence of (the carrier of T)) by FINSEQ_1:def 4;
take q;
thus (( len q ) = ( ( len p ) + 1 ) & ( q . 1 ) = t) by A4,A5;
let i being (Element of ( NAT ));
let a being (adjective of T);
let t being (type of T);
assume that
A13: i in ( dom p )
and
A14: a = ( p . i )
and
A15: t = ( q . i );
i <= ( len p ) by A13,FINSEQ_3:25;
then A16: i < ( ( len p ) + 1 ) by NAT_1:13;
i >= 1 by A13,FINSEQ_3:25;
then (ex a being (adjective of T) st (a = ( p . i ) & (((not ( q . i ) is (type of T)) & ( q . ( i + 1 ) ) = ( 0 )) or (ex t being (type of T) st (t = ( q . i ) & ( q . ( i + 1 ) ) = ( a ast t )))))) by A6,A16;
hence thesis by A14,A15;
end;
correctness
proof
let q1 being (FinSequence of (the carrier of T));
let q2 being (FinSequence of (the carrier of T));
assume that
A17: ( len q1 ) = ( ( len p ) + 1 )
and
A18: ( q1 . 1 ) = t
and
A19: (for i being (Element of ( NAT )) holds (for a being (adjective of T) holds (for t being (type of T) holds (((i in ( dom p ) & a = ( p . i )) & t = ( q1 . i )) implies ( q1 . ( i + 1 ) ) = ( a ast t )))))
and
A20: ( len q2 ) = ( ( len p ) + 1 )
and
A21: ( q2 . 1 ) = t
and
A22: (for i being (Element of ( NAT )) holds (for a being (adjective of T) holds (for t being (type of T) holds (((i in ( dom p ) & a = ( p . i )) & t = ( q2 . i )) implies ( q2 . ( i + 1 ) ) = ( a ast t )))));
defpred P[ Nat ]
 means
($1 in ( dom q1 ) implies ( q1 . $1 ) = ( q2 . $1 ));
A23:now
let i being Nat;
assume that
A24: P[ i ];
now
assume ( i + 1 ) in ( dom q1 );
then A25: ( i + 1 ) <= ( len q1 ) by FINSEQ_3:25;
then A26: i <= ( len q1 ) by NAT_1:13;
A27: i <= ( len p ) by A17,A25,XREAL_1:6;
per cases ;
suppose i = ( 0 );

hence ( q1 . ( i + 1 ) ) = ( q2 . ( i + 1 ) ) by A18,A21;
end;
suppose i > ( 0 );

then A28: i >= ( ( 0 ) + 1 ) by NAT_1:13;
then A29: i in ( dom p ) by A27,FINSEQ_3:25;
then reconsider a = ( p . i ) as (adjective of T) by FINSEQ_2:11;
i in ( dom q1 ) by A26,A28,FINSEQ_3:25;
then reconsider t = ( q1 . i ) as (type of T) by FINSEQ_2:11;
thus ( q1 . ( i + 1 ) ) = ( a ast t ) by A19,A29
.= ( q2 . ( i + 1 ) ) by A22,A24,A26,A28,A29,FINSEQ_3:25;
end;
end;
hence P[ ( i + 1 ) ];
end;
A30: P[ ( 0 ) ] by FINSEQ_3:25;
A31: (for i being Nat holds P[ i ]) from NAT_1:sch 2(A30,A23);
( dom q1 ) = ( dom q2 ) by A17,A20,FINSEQ_3:29;
hence thesis by A31,FINSEQ_1:13;
end;
end;
