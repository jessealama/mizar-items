environ
vocabularies XBOOLE_0,FUNCSDOM,VECTSP_1,CLASSES2,FUNCT_5,MCART_1,STRUCT_0,VECTSP_2,SUPINF_2,ALGSTR_0,SUBSET_1,ARYTM_3,RLVECT_1,RELAT_1,MESFUNC1,FUNCT_1,MSSUBFAM,GRCAT_1,GRAPH_1,CAT_1,MIDSP_1,ORDINAL1,CARD_1,ARYTM_1,BINOP_1,LATTICES,FUNCT_2,ZFMISC_1,MOD_2,UNIALG_1;
notations XBOOLE_0,ENUMSET1,ZFMISC_1,SUBSET_1,BINOP_1,PARTFUN1,NUMBERS,FUNCT_2,FUNCT_5,STRUCT_0,ALGSTR_0,ORDINAL1,RLVECT_1,GROUP_1,VECTSP_1,FUNCSDOM,VECTSP_2,CLASSES2,GRCAT_1,FUNCT_3;
definitions RLVECT_1,STRUCT_0,GRCAT_1,VECTSP_1,ALGSTR_0;
theorems BINOP_1,CLASSES2,ENUMSET1,GRCAT_1,FUNCT_2,ORDINAL1,VECTSP_1,RLVECT_1,RELAT_1,GROUP_1,FUNCOP_1,FUNCT_1,STRUCT_0,ALGSTR_0;
schemes FUNCT_2,BINOP_1;
registrations XBOOLE_0,SUBSET_1,RELSET_1,FUNCT_2,STRUCT_0,VECTSP_1,ALGSTR_1,ALGSTR_0,CLASSES2,GRCAT_1;
constructors ENUMSET1,PARTFUN1,VECTSP_2,GRCAT_1,FUNCOP_1,ALGSTR_1,RELSET_1,CLASSES1;
requirements SUBSET,BOOLE,NUMERALS;
begin
reserve R for Ring;
theorem
Lm1: VectSpStr (# 1,( op2 ),( op0 ),( pr2 ((the carrier of R),1) ) #) is  strict  strict (LeftMod of R)
proof
set a = ( 0. ( Trivial-addLoopStr ) );
set G = VectSpStr (# 1,( op2 ),( op0 ),( pr2 ((the carrier of R),1) ) #);
A1: (for a,b being (Element of G) holds (for x,y being (Element of ( Trivial-addLoopStr )) holds ((x = a & b = y) implies ( a + b ) = ( x + y ))));
A2: G is  Abelian  add-associative  right_zeroed  right_complementable
proof
thus G is  Abelian
proof
let a being (Element of G);
let b being (Element of G);
reconsider x = a,y = b as (Element of ( Trivial-addLoopStr ));
thus ( a + b ) = ( y + x ) by A1
.= ( b + a );
end;

hereby
let a being (Element of G);
let b being (Element of G);
let c being (Element of G);
reconsider x = a,y = b,z = c as (Element of ( Trivial-addLoopStr ));
thus ( ( a + b ) + c ) = ( ( x + y ) + z )
.= ( x + ( y + z ) ) by RLVECT_1:def 3
.= ( a + ( b + c ) );
end;
hereby
let a being (Element of G);
reconsider x = a as (Element of ( Trivial-addLoopStr ));
thus ( a + ( 0. G ) ) = ( x + ( 0. ( Trivial-addLoopStr ) ) )
.= a by RLVECT_1:4;
end;
let a being (Element of G);
reconsider x = a as (Element of ( Trivial-addLoopStr ));
consider b being (Element of ( Trivial-addLoopStr )) such that A3: ( x + b ) = ( 0. ( Trivial-addLoopStr ) ) by ALGSTR_0:def 11;
reconsider b9 = b as (Element of G);
take b9;
thus thesis by A3;
end;
now
let x being (Scalar of R);
let y being (Scalar of R);
let v being (Vector of G);
let w being (Vector of G);
A4: (( ( x * y ) * v ) = a & ( ( 1. R ) * v ) = a) by GRCAT_1:4;
(( x * ( v + w ) ) = a & ( ( x + y ) * v ) = a) by GRCAT_1:4;
hence (((( x * ( v + w ) ) = ( ( x * v ) + ( x * w ) ) & ( ( x + y ) * v ) = ( ( x * v ) + ( y * v ) )) & ( ( x * y ) * v ) = ( x * ( y * v ) )) & ( ( 1. R ) * v ) = v) by A4,GRCAT_1:4;
end;
hence thesis by A2,VECTSP_1:def 14,VECTSP_1:def 15,VECTSP_1:def 16,VECTSP_1:def 17;
end;
