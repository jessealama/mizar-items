environ
vocabularies XBOOLE_0,FUNCSDOM,VECTSP_1,CLASSES2,FUNCT_5,MCART_1,STRUCT_0,VECTSP_2,SUPINF_2,ALGSTR_0,SUBSET_1,ARYTM_3,RLVECT_1,RELAT_1,MESFUNC1,FUNCT_1,MSSUBFAM,GRCAT_1,GRAPH_1,CAT_1,MIDSP_1,ORDINAL1,CARD_1,ARYTM_1,BINOP_1,LATTICES,FUNCT_2,ZFMISC_1,MOD_2,UNIALG_1;
notations XBOOLE_0,ENUMSET1,ZFMISC_1,SUBSET_1,BINOP_1,PARTFUN1,NUMBERS,FUNCT_2,FUNCT_5,STRUCT_0,ALGSTR_0,ORDINAL1,RLVECT_1,GROUP_1,VECTSP_1,FUNCSDOM,VECTSP_2,CLASSES2,GRCAT_1,FUNCT_3,CKB2,CKB4,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13,CKB15,CKB18,CKB23,CKB24,CKB30;
definitions RLVECT_1,STRUCT_0,GRCAT_1,VECTSP_1,ALGSTR_0,CKB2,CKB4,CKB8,CKB9,CKB10,CKB12,CKB13,CKB18,CKB23,CKB30;
theorems BINOP_1,CLASSES2,ENUMSET1,GRCAT_1,FUNCT_2,ORDINAL1,VECTSP_1,RLVECT_1,RELAT_1,GROUP_1,FUNCOP_1,FUNCT_1,STRUCT_0,ALGSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB16,CKB18,CKB20,CKB21,CKB23,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30;
schemes FUNCT_2,BINOP_1;
registrations XBOOLE_0,SUBSET_1,RELSET_1,FUNCT_2,STRUCT_0,VECTSP_1,ALGSTR_1,ALGSTR_0,CLASSES2,GRCAT_1,CKB6,CKB7,CKB14,CKB17,CKB19,CKB22;
constructors ENUMSET1,PARTFUN1,VECTSP_2,GRCAT_1,FUNCOP_1,ALGSTR_1,RELSET_1,CLASSES1,CKB2,CKB4,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13,CKB18,CKB23,CKB24,CKB30;
requirements SUBSET,BOOLE,NUMERALS;
begin
reserve R for Ring;
reserve G for (LeftMod of R);
reserve G1 for (LeftMod of R);
reserve G2 for (LeftMod of R);
reserve G3 for (LeftMod of R);
reserve f for LModMorphismStr over R;
theorem
Th20: (for G being (Morphism of G2,G3) holds (for F being (Morphism of G1,G2) holds ( G * F ) is  strict  strict (Morphism of G1,G3)))
proof
let G being (Morphism of G2,G3);
let F being (Morphism of G1,G2);
consider g being (Function of G2,G3) such that A1: ( the LModMorphismStr of G ) = LModMorphismStr (# G2,G3,g #) and g is  additive  homogeneous by CKB25:1;
consider f being (Function of G1,G2) such that A2: ( the LModMorphismStr of F ) = LModMorphismStr (# G1,G2,f #) and f is  additive  homogeneous by CKB25:1;
( dom G ) = G2 by CKB18:def 1
.= ( cod F ) by CKB18:def 1;
then ( G * F ) = LModMorphismStr (# G1,G3,( g * f ) #) by A1,A2,CKB30:def 1;
then (( dom ( G * F ) ) = G1 & ( cod ( G * F ) ) = G3);
hence thesis by CKB18:def 1;
end;
