environ
vocabularies NUMBERS,ORDINAL1,SETFAM_1,ARYTM_1,ARYTM_3,CARD_1,SUBSET_1,AMI_1,XBOOLE_0,RELAT_1,TARSKI,FUNCOP_1,GLIB_000,GOBOARD5,AMISTD_1,UNIALG_1,FUNCT_1,CARD_5,STRUCT_0,VALUED_1,FSM_1,FUNCT_4,TURING_1,CIRCUIT2,AMISTD_2,PARTFUN1,SCMNORM,NAT_1,RELOC,PBOOLE,AMISTD_5,COMPOS_1,MSUALG_1,FINSET_1;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,MCART_1,SETFAM_1,MEMBERED,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,PBOOLE,FINSET_1,CARD_1,NUMBERS,XCMPLX_0,XXREAL_0,NAT_1,CARD_3,FINSEQ_1,FUNCOP_1,NAT_D,FUNCT_7,VALUED_0,VALUED_1,AFINSQ_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,CKB3,CKB5,CKB7,CKB19;
definitions RELAT_1,FUNCT_1,WELLORD2,FUNCT_7,COMPOS_1,EXTPRO_1,AMISTD_1,XBOOLE_0,FUNCOP_1,CARD_3,NAT_1,AFINSQ_1,MCART_1,VALUED_1,TARSKI,AMISTD_2,STRUCT_0,MEMSTR_0,CKB3,CKB5,CKB7,CKB19;
theorems AMISTD_1,FUNCOP_1,FUNCT_1,FUNCT_4,GRFUNC_1,RELAT_1,TARSKI,ZFMISC_1,XBOOLE_0,XBOOLE_1,PBOOLE,PARTFUN1,RECDEF_2,VALUED_1,COMPOS_1,EXTPRO_1,ORDINAL1,NAT_D,AMISTD_2,RELSET_1,PRE_CIRC,MEMSTR_0,CKB1,CKB3,CKB5,CKB6,CKB7,CKB8,CKB15,CKB16,CKB18,CKB19;
schemes NAT_1;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,FUNCOP_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,MEMBERED,FINSEQ_1,CARD_3,REALSET1,FUNCT_7,STRUCT_0,AMISTD_1,CARD_1,FUNCT_4,XXREAL_2,RELSET_1,GRFUNC_1,FUNCT_2,ORDINAL1,AFINSQ_1,VALUED_1,VALUED_0,COMPOS_1,EXTPRO_1,XCMPLX_0,REAL_1,PBOOLE,AMISTD_2,MEMSTR_0,CKB2,CKB4,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB17;
constructors WELLORD2,REALSET1,NAT_D,AMISTD_1,XXREAL_2,PRE_POLY,AFINSQ_1,ORDINAL4,RECDEF_2,VALUED_1,AMISTD_2,PBOOLE,RELSET_1,FUNCT_7,FUNCT_4,MEMSTR_0,CKB3,CKB5,CKB7,CKB19;
requirements NUMERALS,BOOLE,SUBSET,REAL,ARITHM;
begin
reserve k for  natural number;
reserve N for  with_non-empty_elements non  empty set;
registration
let N;
cluster ( STC N ) ->  CurIns-recognized;
coherence
proof
let q being non  halt-free  finite (the Instructions of ( STC N )) -valued ( NAT ) -defined Function;
let p being q -autonomic non  empty (FinPartState of ( STC N ));
let s being (State of ( STC N ));
assume that
A1: p c= s;
let P being (Instruction-Sequence of ( STC N ));
assume that
A2: q c= P;
let i being (Element of ( NAT ));
set Csi = ( Comput (P,s,i) );
set loc = ( IC Csi );
set loc1 = ( loc + 1 );
assume B4: (not ( IC ( Comput (P,s,i) ) ) in ( dom q ));
(the Instructions of ( STC N )) = { [ ( 0 ),( 0 ),( 0 ) ],[ 1,( 0 ),( 0 ) ] } by AMISTD_1:def 7;
then reconsider I = [ 1,( 0 ),( 0 ) ] as (Instruction of ( STC N )) by TARSKI:def 2;
set p1 = ( q +* ( loc .--> I ) );
set p2 = ( q +* ( loc .--> ( halt ( STC N ) ) ) );
reconsider P1 = ( P +* ( loc .--> I ) ) as (Instruction-Sequence of ( STC N ));
reconsider P2 = ( P +* ( loc .--> ( halt ( STC N ) ) ) ) as (Instruction-Sequence of ( STC N ));
A6: ( dom ( loc .--> ( halt ( STC N ) ) ) ) = { loc } by FUNCOP_1:13;
then A7: loc in ( dom ( loc .--> ( halt ( STC N ) ) ) ) by TARSKI:def 1;
A12: ( dom ( loc .--> I ) ) = { loc } by FUNCOP_1:13;
then A13: loc in ( dom ( loc .--> I ) ) by TARSKI:def 1;
Y6: ( dom q ) misses ( dom ( loc .--> ( halt ( STC N ) ) ) ) by B4,A6,ZFMISC_1:50;
Y5: ( dom q ) misses ( dom ( loc .--> I ) ) by B4,A12,ZFMISC_1:50;
P3: p1 c= P1 by A2,FUNCT_4:123;
P4: p2 c= P2 by A2,FUNCT_4:123;
set Cs2i = ( Comput (P2,s,i) );
set Cs1i = ( Comput (P1,s,i) );
(not p is q -autonomic)
proof
( ( loc .--> ( halt ( STC N ) ) ) . loc ) = ( halt ( STC N ) ) by FUNCOP_1:72;
then A18: ( P2 . loc ) = ( halt ( STC N ) ) by A7,FUNCT_4:13;
( ( loc .--> I ) . loc ) = I by FUNCOP_1:72;
then A19: ( P1 . loc ) = I by A13,FUNCT_4:13;
take P1;
take P2;
q c= p1 by Y5,FUNCT_4:32;
hence A25: q c= P1 by P3,XBOOLE_1:1;
q c= p2 by Y6,FUNCT_4:32;
hence A27: q c= P2 by P4,XBOOLE_1:1;
take s;
take s;
thus p c= s by A1;
A28: ( Cs1i | ( dom p ) ) = ( Csi | ( dom p ) ) by A25,A2,A1,EXTPRO_1:def 10;
thus p c= s by A1;
A29: ( Cs1i | ( dom p ) ) = ( Cs2i | ( dom p ) ) by A25,A27,A1,EXTPRO_1:def 10;
take k = ( i + 1 );
set Cs1k = ( Comput (P1,s,k) );
A31: Cs1k = ( Following (P1,Cs1i) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (P1,Cs1i) ),Cs1i) );
( InsCode I ) = 1 by RECDEF_2:def 1;
then A32: ( IC ( Exec (I,Cs1i) ) ) = ( succ ( IC Cs1i ) ) by AMISTD_1:9;
A33: ( IC ( STC N ) ) in ( dom p ) by CKB18:1;
A34: ( IC Csi ) = ( IC ( Csi | ( dom p ) ) ) by A33,FUNCT_1:49;
then ( IC Cs1i ) = loc by A28,A33,FUNCT_1:49;
then A35: ( IC Cs1k ) = loc1 by A32,A31,A19,PBOOLE:143;
set Cs2k = ( Comput (P2,s,k) );
A36: Cs2k = ( Following (P2,Cs2i) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (P2,Cs2i) ),Cs2i) );
A37: ( P2 /. ( IC Cs2i ) ) = ( P2 . ( IC Cs2i ) ) by PBOOLE:143;
( IC Cs2i ) = loc by A28,A34,A29,A33,FUNCT_1:49;
then A38: ( IC Cs2k ) = loc by A36,A18,A37,EXTPRO_1:def 3;
(( IC ( Cs1k | ( dom p ) ) ) = ( IC Cs1k ) & ( IC ( Cs2k | ( dom p ) ) ) = ( IC Cs2k )) by A33,FUNCT_1:49;
hence thesis by A35,A38;
end;
hence contradiction;
end;
end;
