environ
vocabularies NUMBERS,ORDINAL1,SETFAM_1,ARYTM_1,ARYTM_3,CARD_1,SUBSET_1,AMI_1,XBOOLE_0,RELAT_1,TARSKI,FUNCOP_1,GLIB_000,GOBOARD5,AMISTD_1,UNIALG_1,FUNCT_1,CARD_5,STRUCT_0,VALUED_1,FSM_1,FUNCT_4,TURING_1,CIRCUIT2,AMISTD_2,PARTFUN1,SCMNORM,NAT_1,RELOC,PBOOLE,AMISTD_5,COMPOS_1,MSUALG_1,FINSET_1;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,MCART_1,SETFAM_1,MEMBERED,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,PBOOLE,FINSET_1,CARD_1,NUMBERS,XCMPLX_0,XXREAL_0,NAT_1,CARD_3,FINSEQ_1,FUNCOP_1,NAT_D,FUNCT_7,VALUED_0,VALUED_1,AFINSQ_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,CKB3,CKB5,CKB7,CKB19,CKB26,CKB27;
definitions RELAT_1,FUNCT_1,WELLORD2,FUNCT_7,COMPOS_1,EXTPRO_1,AMISTD_1,XBOOLE_0,FUNCOP_1,CARD_3,NAT_1,AFINSQ_1,MCART_1,VALUED_1,TARSKI,AMISTD_2,STRUCT_0,MEMSTR_0,CKB3,CKB5,CKB7,CKB19,CKB26,CKB27;
theorems AMISTD_1,FUNCOP_1,FUNCT_1,FUNCT_4,GRFUNC_1,RELAT_1,TARSKI,ZFMISC_1,XBOOLE_0,XBOOLE_1,PBOOLE,PARTFUN1,RECDEF_2,VALUED_1,COMPOS_1,EXTPRO_1,ORDINAL1,NAT_D,AMISTD_2,RELSET_1,PRE_CIRC,MEMSTR_0,CKB1,CKB3,CKB5,CKB6,CKB7,CKB8,CKB15,CKB16,CKB18,CKB19,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB31,CKB32;
schemes NAT_1;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,FUNCOP_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,MEMBERED,FINSEQ_1,CARD_3,REALSET1,FUNCT_7,STRUCT_0,AMISTD_1,CARD_1,FUNCT_4,XXREAL_2,RELSET_1,GRFUNC_1,FUNCT_2,ORDINAL1,AFINSQ_1,VALUED_1,VALUED_0,COMPOS_1,EXTPRO_1,XCMPLX_0,REAL_1,PBOOLE,AMISTD_2,MEMSTR_0,CKB2,CKB4,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB17,CKB20,CKB29,CKB30,CKB33;
constructors WELLORD2,REALSET1,NAT_D,AMISTD_1,XXREAL_2,PRE_POLY,AFINSQ_1,ORDINAL4,RECDEF_2,VALUED_1,AMISTD_2,PBOOLE,RELSET_1,FUNCT_7,FUNCT_4,MEMSTR_0,CKB3,CKB5,CKB7,CKB19,CKB26,CKB27;
requirements NUMERALS,BOOLE,SUBSET,REAL,ARITHM;
begin
reserve N for  with_non-empty_elements non empty set;
reserve S for  relocable1  relocable  IC-recognized  proper-halt  regular  homogeneous  J/A-independent  halting  standard-ins  IC-Ins-separated non empty AMI-Struct over N;
theorem
(S is  CurIns-recognized  relocable1  relocable2  proper-halt implies (for F being  data-only (PartFunc of ( FinPartSt S ),( FinPartSt S )) holds (for l being (Element of ( NAT )) holds (for q being non halt-free  finite (the Instructions of S) -valued ( NAT ) -defined Function holds (for p being q -autonomic q -halted non empty (FinPartState of S) holds (( IC S ) in ( dom p ) implies (for k being (Element of ( NAT )) holds (q,p computes F iff ( Reloc (q,k) ),( IncIC (p,k) ) computes F))))))))
proof
assume A1: S is  CurIns-recognized  relocable1  relocable2  proper-halt;
let F being  data-only (PartFunc of ( FinPartSt S ),( FinPartSt S ));
let l being (Element of ( NAT ));
let q being non halt-free  finite (the Instructions of S) -valued ( NAT ) -defined Function;
let p being q -autonomic q -halted non empty (FinPartState of S);
assume that
A2: ( IC S ) in ( dom p );
let k being (Element of ( NAT ));
hereby
assume A5: q,p computes F;
thus ( Reloc (q,k) ),( IncIC (p,k) ) computes F
proof
let x being set;
assume A6: x in ( dom F );
then consider d1 being (FinPartState of S) such that A7: x = d1 and A8: ( p +* d1 ) is (Autonomy of q) and A9: ( F . d1 ) c= ( Result (q,( p +* d1 )) ) by A5,EXTPRO_1:def 14;
( dom F ) c= ( FinPartSt S ) by RELAT_1:def 18;
then reconsider d = x as (FinPartState of S) by A6,MEMSTR_0:76;
reconsider d as  data-only (FinPartState of S) by A6,MEMSTR_0:def 14;
( dom ( p +* d ) ) = ( ( dom p ) \/ ( dom d ) ) by FUNCT_4:def 1;
then A10: ( IC S ) in ( dom ( p +* d ) ) by A2,XBOOLE_0:def 3;
A17: ( p +* d ) is q -autonomic by A7,A8,EXTPRO_1:def 12;
then A18: ( IncIC (( p +* d ),k) ) is ( Reloc (q,k) ) -autonomic by A10,CKB25:1,A1;
A19: ( p +* d ) is q -halted by A7,A8,EXTPRO_1:def 12;
reconsider pd = ( p +* d ) as q -halted q -autonomic non empty (FinPartState of S) by A7,A8,EXTPRO_1:def 12;
A20: ( DataPart ( Result (q,pd) ) ) = ( DataPart ( Result (( Reloc (q,k) ),( IncIC (( p +* d ),k) )) ) ) by A1,A10,CKB32:1
.= ( DataPart ( Result (( Reloc (q,k) ),( ( IncIC (p,k) ) +* d )) ) ) by MEMSTR_0:54;
reconsider Fs1 = ( F . d1 ) as (FinPartState of S) by A9;
take d;
thus x = d;
( ( IncIC (p,k) ) +* d ) = ( IncIC (( p +* d ),k) ) by MEMSTR_0:54;
hence ( ( IncIC (p,k) ) +* d ) is (Autonomy of ( Reloc (q,k) )) by A17,A19,A18,EXTPRO_1:def 12;
SS: ( p +* d1 ) = pd by A7;
A21: Fs1 is  data-only by A6,A7,MEMSTR_0:def 14;
( F . d1 ) c= ( DataPart ( Result (( Reloc (q,k) ),( ( IncIC (p,k) ) +* d )) ) ) by A9,A21,SS,A20,MEMSTR_0:5;
hence ( F . d ) c= ( Result (( Reloc (q,k) ),( ( IncIC (p,k) ) +* d )) ) by A7,A21,MEMSTR_0:5;
end;

end;
assume A22: ( Reloc (q,k) ),( IncIC (p,k) ) computes F;
let x being set;
assume A23: x in ( dom F );
then consider d1 being (FinPartState of S) such that A24: x = d1 and A25: ( ( IncIC (p,k) ) +* d1 ) is (Autonomy of ( Reloc (q,k) )) and A26: ( F . d1 ) c= ( Result (( Reloc (q,k) ),( ( IncIC (p,k) ) +* d1 )) ) by A22,EXTPRO_1:def 14;
( dom F ) c= ( FinPartSt S ) by RELAT_1:def 18;
then reconsider d = x as (FinPartState of S) by A23,MEMSTR_0:76;
reconsider d as  data-only (FinPartState of S) by A23,MEMSTR_0:def 14;
B27: ( dom ( p +* d ) ) = ( ( dom p ) \/ ( dom d ) ) by FUNCT_4:def 1;
then A27: ( IC S ) in ( dom ( p +* d ) ) by A2,XBOOLE_0:def 3;
A32: ( ( IncIC (p,k) ) +* d ) = ( IncIC (( p +* d ),k) ) by MEMSTR_0:54;
( IncIC (( p +* d ),k) ) is ( Reloc (q,k) ) -autonomic by A24,A25,A32,EXTPRO_1:def 12;
then A33: ( p +* d ) is q -autonomic by A27,CKB25:1,A1;
RR: ( IncIC (( p +* d ),k) ) is ( Reloc (q,k) ) -halted by A24,A25,A32,EXTPRO_1:def 12;
A34: ( p +* d ) is q -halted by A27,CKB31:1,A33,RR;
reconsider pd = ( p +* d ) as q -halted q -autonomic non empty (FinPartState of S) by A27,CKB31:1,A33,RR;
WR: ( IC S ) in ( dom pd ) by B27,A2,XBOOLE_0:def 3;
A35: ( DataPart ( Result (( Reloc (q,k) ),( ( IncIC (p,k) ) +* d1 )) ) ) = ( DataPart ( Result (( Reloc (q,k) ),( IncIC (( p +* d ),k) )) ) ) by A24,MEMSTR_0:54
.= ( DataPart ( Result (q,( p +* d )) ) ) by CKB32:1,A1,WR;
take d;
thus x = d;
thus ( p +* d ) is (Autonomy of q) by A33,A34,EXTPRO_1:def 12;
reconsider Fs1 = ( F . d1 ) as (FinPartState of S) by A26;
A37: Fs1 is  data-only by A23,A24,MEMSTR_0:def 14;
then ( F . d1 ) c= ( DataPart ( Result (q,( p +* d )) ) ) by A35,A26,MEMSTR_0:5;
hence thesis by A24,A37,MEMSTR_0:5;
end;
