environ
vocabularies NUMBERS,ORDINAL1,SETFAM_1,ARYTM_1,ARYTM_3,CARD_1,SUBSET_1,AMI_1,XBOOLE_0,RELAT_1,TARSKI,FUNCOP_1,GLIB_000,GOBOARD5,AMISTD_1,UNIALG_1,FUNCT_1,CARD_5,STRUCT_0,VALUED_1,FSM_1,FUNCT_4,TURING_1,CIRCUIT2,AMISTD_2,PARTFUN1,SCMNORM,NAT_1,RELOC,PBOOLE,AMISTD_5,COMPOS_1,MSUALG_1,FINSET_1;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,MCART_1,SETFAM_1,MEMBERED,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,PBOOLE,FINSET_1,CARD_1,NUMBERS,XCMPLX_0,XXREAL_0,NAT_1,CARD_3,FINSEQ_1,FUNCOP_1,NAT_D,FUNCT_7,VALUED_0,VALUED_1,AFINSQ_1,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_1,AMISTD_2,CKB3,CKB5,CKB7,CKB19,CKB26,CKB27;
definitions RELAT_1,FUNCT_1,WELLORD2,FUNCT_7,COMPOS_1,EXTPRO_1,AMISTD_1,XBOOLE_0,FUNCOP_1,CARD_3,NAT_1,AFINSQ_1,MCART_1,VALUED_1,TARSKI,AMISTD_2,STRUCT_0,MEMSTR_0,CKB3,CKB5,CKB7,CKB19,CKB26,CKB27;
theorems AMISTD_1,FUNCOP_1,FUNCT_1,FUNCT_4,GRFUNC_1,RELAT_1,TARSKI,ZFMISC_1,XBOOLE_0,XBOOLE_1,PBOOLE,PARTFUN1,RECDEF_2,VALUED_1,COMPOS_1,EXTPRO_1,ORDINAL1,NAT_D,AMISTD_2,RELSET_1,PRE_CIRC,MEMSTR_0,CKB1,CKB3,CKB5,CKB6,CKB7,CKB8,CKB15,CKB16,CKB18,CKB19,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27;
schemes NAT_1;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,FUNCOP_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,MEMBERED,FINSEQ_1,CARD_3,REALSET1,FUNCT_7,STRUCT_0,AMISTD_1,CARD_1,FUNCT_4,XXREAL_2,RELSET_1,GRFUNC_1,FUNCT_2,ORDINAL1,AFINSQ_1,VALUED_1,VALUED_0,COMPOS_1,EXTPRO_1,XCMPLX_0,REAL_1,PBOOLE,AMISTD_2,MEMSTR_0,CKB2,CKB4,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB17,CKB20;
constructors WELLORD2,REALSET1,NAT_D,AMISTD_1,XXREAL_2,PRE_POLY,AFINSQ_1,ORDINAL4,RECDEF_2,VALUED_1,AMISTD_2,PBOOLE,RELSET_1,FUNCT_7,FUNCT_4,MEMSTR_0,CKB3,CKB5,CKB7,CKB19,CKB26,CKB27;
requirements NUMERALS,BOOLE,SUBSET,REAL,ARITHM;
begin
reserve N for  with_non-empty_elements non empty set;
theorem
Lm1: (for k being (Element of ( NAT )) holds (for q being non halt-free  finite (the Instructions of ( STC N )) -valued ( NAT ) -defined Function holds (for p being q -autonomic (FinPartState of ( STC N )) holds (for s1,s2 being (State of ( STC N )) holds (((( IC ( STC N ) ) in ( dom p ) & p c= s1) & ( IncIC (p,k) ) c= s2) implies (for P1,P2 being (Instruction-Sequence of ( STC N )) holds ((q c= P1 & ( Reloc (q,k) ) c= P2) implies (for i being (Element of ( NAT )) holds (((( ( IC ( Comput (P1,s1,i) ) ) + k ) = ( IC ( Comput (P2,s2,i) ) ) & ( IncAddr (( CurInstr (P1,( Comput (P1,s1,i) )) ),k) ) = ( CurInstr (P2,( Comput (P2,s2,i) )) )) & ( ( Comput (P1,s1,i) ) | (( dom ( DataPart p ) ) qua set) ) = ( ( Comput (P2,s2,i) ) | (( dom ( DataPart p ) ) qua set) )) & ( DataPart ( Comput (P1,( s1 +* ( DataPart s2 ) ),i) ) ) = ( DataPart ( Comput (P2,s2,i) ) ))))))))))
proof
let k being (Element of ( NAT ));
let q being non halt-free  finite (the Instructions of ( STC N )) -valued ( NAT ) -defined Function;
let p being q -autonomic (FinPartState of ( STC N ));
let s1 being (State of ( STC N )),s2 being (State of ( STC N ));
assume that
A1: ( IC ( STC N ) ) in ( dom p )
and
A2: p c= s1
and
A3: ( IncIC (p,k) ) c= s2;
B1: ( IC ( STC N ) ) in ( dom p ) by A1;
C1: p is non empty by A1;
let P1 being (Instruction-Sequence of ( STC N )),P2 being (Instruction-Sequence of ( STC N ));
assume that
A4: (q c= P1 & ( Reloc (q,k) ) c= P2);
set s3 = ( s1 +* ( DataPart s2 ) );
defpred Z[ (Element of ( NAT )) ]
 means
(((( ( IC ( Comput (P1,s1,$1) ) ) + k ) = ( IC ( Comput (P2,s2,$1) ) ) & ( IncAddr (( CurInstr (P1,( Comput (P1,s1,$1) )) ),k) ) = ( CurInstr (P2,( Comput (P2,s2,$1) )) )) & ( ( Comput (P1,s1,$1) ) | (( dom ( DataPart p ) ) qua set) ) = ( ( Comput (P2,s2,$1) ) | (( dom ( DataPart p ) ) qua set) )) & ( DataPart ( Comput (P1,s3,$1) ) ) = ( DataPart ( Comput (P2,s2,$1) ) ));
A8: (for i being (Element of ( NAT )) holds (Z[ i ] implies Z[ ( i + 1 ) ]))
proof
set DPp = ( DataPart p );
let i being (Element of ( NAT ));
assume that
A9: ( ( IC ( Comput (P1,s1,i) ) ) + k ) = ( IC ( Comput (P2,s2,i) ) )
and
A10: ( IncAddr (( CurInstr (P1,( Comput (P1,s1,i) )) ),k) ) = ( CurInstr (P2,( Comput (P2,s2,i) )) )
and
( ( Comput (P1,s1,i) ) | (( dom ( DataPart p ) ) qua set) ) = ( ( Comput (P2,s2,i) ) | (( dom ( DataPart p ) ) qua set) )
and
( DataPart ( Comput (P1,s3,i) ) ) = ( DataPart ( Comput (P2,s2,i) ) );
set Cs2i1 = ( Comput (P2,s2,( i + 1 )) );
set Cs3i = ( Comput (P1,s3,i) );
set Cs2i = ( Comput (P2,s2,i) );
set Cs3i1 = ( Comput (P1,s3,( i + 1 )) );
set Cs1i1 = ( Comput (P1,s1,( i + 1 )) );
set Cs1i = ( Comput (P1,s1,i) );
A11:now
reconsider loc = ( IC Cs1i1 ) as (Element of ( NAT ));
assume A12: ( ( IC ( Comput (P1,s1,( i + 1 )) ) ) + k ) = ( IC ( Comput (P2,s2,( i + 1 )) ) );
reconsider kk = loc as (Element of ( NAT ));
A13: loc in ( dom q ) by CKB19:def 1,A4,A2,C1;
A14: ( loc + k ) in ( dom ( Reloc (q,k) ) ) by A13,COMPOS_1:46;
A15: ( dom P2 ) = ( NAT ) by PARTFUN1:def 2;
( dom P1 ) = ( NAT ) by PARTFUN1:def 2;
then ( CurInstr (P1,Cs1i1) ) = ( P1 . loc ) by PARTFUN1:def 6
.= ( q . loc ) by A13,A4,GRFUNC_1:2;
hence ( IncAddr (( CurInstr (P1,( Comput (P1,s1,( i + 1 )) )) ),k) ) = ( ( Reloc (q,k) ) . ( loc + k ) ) by A13,COMPOS_1:35
.= ( P2 . ( IC ( Comput (P2,s2,( i + 1 )) ) ) ) by A12,A14,A4,GRFUNC_1:2
.= ( CurInstr (P2,( Comput (P2,s2,( i + 1 )) )) ) by A15,PARTFUN1:def 6;
end;
set I = ( CurInstr (P1,Cs1i) );
A16: Cs2i1 = ( Following (P2,Cs2i) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (P2,Cs2i) ),Cs2i) );
reconsider j = ( IC Cs1i ) as (Element of ( NAT ));
A17: Cs1i1 = ( Following (P1,Cs1i) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (P1,Cs1i) ),Cs1i) );
A18: (the Instructions of ( STC N )) = { [ ( 0 ),( 0 ),( 0 ) ],[ 1,( 0 ),( 0 ) ] } by AMISTD_1:def 7;
per cases  by A18,TARSKI:def 2;
suppose I = [ ( 0 ),( 0 ),( 0 ) ];

then A19: I = ( halt ( STC N ) ) by AMISTD_1:def 7;
thus ( ( IC ( Comput (P1,s1,( i + 1 )) ) ) + k ) = ( ( IC Cs1i ) + k ) by A17,A19,EXTPRO_1:def 3
.= ( IC ( Comput (P2,s2,( i + 1 )) ) ) by A9,A16,A19,A10,EXTPRO_1:def 3;
hence ( IncAddr (( CurInstr (P1,( Comput (P1,s1,( i + 1 )) )) ),k) ) = ( CurInstr (P2,( Comput (P2,s2,( i + 1 )) )) ) by A11;
thus ( ( Comput (P1,s1,( i + 1 )) ) | (( dom ( DataPart p ) ) qua set) ) = ( ( Comput (P2,s2,( i + 1 )) ) | (( dom ( DataPart p ) ) qua set) );
thus ( DataPart Cs3i1 ) = ( DataPart Cs2i1 );
end;
suppose I = [ 1,( 0 ),( 0 ) ];

then A20: ( InsCode I ) = 1 by RECDEF_2:def 1;
then A21: ( Exec (I,Cs2i) ) = ( IncIC (Cs2i,1) ) by AMISTD_1:20;
thus ( ( IC ( Comput (P1,s1,( i + 1 )) ) ) + k ) = ( ( succ ( IC Cs1i ) ) + k ) by A17,A20,AMISTD_1:9
.= ( IC ( Exec (I,Cs2i) ) ) by A21,A9,MEMSTR_0:53
.= ( IC ( Comput (P2,s2,( i + 1 )) ) ) by A16,A10,COMPOS_1:11;
hence ( IncAddr (( CurInstr (P1,( Comput (P1,s1,( i + 1 )) )) ),k) ) = ( CurInstr (P2,( Comput (P2,s2,( i + 1 )) )) ) by A11;
thus ( ( Comput (P1,s1,( i + 1 )) ) | (( dom ( DataPart p ) ) qua set) ) = ( ( Comput (P2,s2,( i + 1 )) ) | (( dom ( DataPart p ) ) qua set) );
thus ( DataPart Cs3i1 ) = ( DataPart Cs2i1 );
end;
end;
B22: ( IC ( STC N ) ) in ( dom ( IncIC (p,k) ) ) by MEMSTR_0:52;
now
thus ( ( IC ( Comput (P1,s1,( 0 )) ) ) + k ) = ( ( IC s1 ) + k ) by EXTPRO_1:2
.= ( ( IC p ) + k ) by A2,B1,GRFUNC_1:2
.= ( ( IC p ) + k )
.= ( IC ( IncIC (p,k) ) ) by MEMSTR_0:53
.= ( IC ( IncIC (p,k) ) )
.= ( IC ( IncIC (p,k) ) )
.= ( IC s2 ) by A3,B22,GRFUNC_1:2
.= ( IC ( Comput (P2,s2,( 0 )) ) ) by EXTPRO_1:2;
reconsider loc = ( IC p ) as (Element of ( NAT ));
A23: ( IC p ) = ( IC s1 ) by A2,B1,GRFUNC_1:2;
then ( IC p ) = ( IC ( Comput (P1,s1,( 0 )) ) ) by EXTPRO_1:2;
then A24: loc in ( dom q ) by CKB19:def 1,A4,A2,C1;
A25: ( ( IC p ) + k ) in ( dom ( Reloc (q,k) ) ) by A24,COMPOS_1:46;
B26: ( IC ( STC N ) ) in ( dom ( IncIC (p,k) ) ) by MEMSTR_0:52;
A27: ( q . ( IC p ) ) = ( P1 . ( IC s1 ) ) by A23,A24,A4,GRFUNC_1:2;
( dom P2 ) = ( NAT ) by PARTFUN1:def 2;
then A28: ( CurInstr (P2,( Comput (P2,s2,( 0 )) )) ) = ( P2 . ( IC ( Comput (P2,s2,( 0 )) ) ) ) by PARTFUN1:def 6
.= ( P2 . ( IC s2 ) ) by EXTPRO_1:2
.= ( P2 . ( IC ( IncIC (p,k) ) ) ) by A3,B26,GRFUNC_1:2
.= ( P2 . ( IC ( IncIC (p,k) ) ) )
.= ( P2 . ( IC ( IncIC (p,k) ) ) )
.= ( P2 . ( ( IC p ) + k ) ) by MEMSTR_0:53
.= ( P2 . ( ( IC p ) + k ) )
.= ( ( Reloc (q,k) ) . ( ( IC p ) + k ) ) by A25,A4,GRFUNC_1:2;
A29: ( dom P1 ) = ( NAT ) by PARTFUN1:def 2;
( CurInstr (P1,( Comput (P1,s1,( 0 )) )) ) = ( CurInstr (P1,s1) ) by EXTPRO_1:2
.= ( P1 . ( IC s1 ) ) by A29,PARTFUN1:def 6;
hence ( IncAddr (( CurInstr (P1,( Comput (P1,s1,( 0 )) )) ),k) ) = ( CurInstr (P2,( Comput (P2,s2,( 0 )) )) ) by A28,A24,A27,COMPOS_1:35;
thus ( ( Comput (P1,s1,( 0 )) ) | (( dom ( DataPart p ) ) qua set) ) = ( ( Comput (P2,s2,( 0 )) ) | (( dom ( DataPart p ) ) qua set) );
thus ( DataPart ( Comput (P1,s3,( 0 )) ) ) = ( DataPart ( Comput (P2,s2,( 0 )) ) );
end;
then A30: Z[ ( 0 ) ];
thus (for i being (Element of ( NAT )) holds Z[ i ]) from NAT_1:sch 1(A30,A8);
end;
