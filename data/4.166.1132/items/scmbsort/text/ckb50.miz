environ
vocabularies NUMBERS,SCMNORM,SCMFSA_2,AMI_1,SUBSET_1,SCMFSA7B,SCMFSA8C,SCMFSA8A,AMI_3,CARD_1,AMISTD_2,SCMFSA8B,TURING_1,FSM_1,GRAPHSP,FUNCT_1,PARTFUN1,COMPLEX1,FUNCT_4,ARYTM_3,SF_MASTR,SCMFSA6C,SCMFSA6B,FUNCOP_1,ORDINAL1,RELAT_1,TARSKI,XBOOLE_0,XXREAL_0,CIRCUIT2,NAT_1,STRUCT_0,ARYTM_1,INT_1,FINSEQ_1,FINSEQ_2,SCMFSA6A,FINSUB_1,CARD_3,CLASSES1,VALUED_0,MSUALG_1,SCM_HALT,SCMBSORT,PBOOLE,COMPOS_1;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,SETFAM_1,ORDINAL1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,RELAT_1,FINSEQ_1,FUNCT_1,COMPLEX1,FUNCT_2,PBOOLE,FUNCT_4,FINSEQ_2,FUNCT_7,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_2,SCMFSA_2,FUNCOP_1,FINSUB_1,CARD_3,PARTFUN1,SCMFSA6B,SCMFSA6C,SCMFSA6A,SF_MASTR,SCMFSA8A,SCMFSA8B,SCMFSA8C,CLASSES1,RFINSEQ,SCMFSA7B,NAT_D,SCM_HALT,XXREAL_0,CKB21,CKB35,CKB36,CKB39;
definitions TARSKI,FUNCOP_1,COMPOS_1,EXTPRO_1,XBOOLE_0,SCMFSA8C,SCM_HALT,MEMSTR_0,CKB35,CKB36,CKB39;
theorems SF_MASTR,FUNCT_1,FUNCT_7,FUNCOP_1,RELAT_1,FUNCT_2,ZFMISC_1,SCMFSA6A,FUNCT_4,FINSEQ_3,ENUMSET1,NAT_1,FINSEQ_1,RELSET_1,TARSKI,INT_1,PARTFUN1,GRFUNC_1,RFINSEQ,SCMFSA_2,SCMFSA7B,SCMFSA8B,SCMFSA8A,SCMFSA8C,SCMFSA6C,SCM_HALT,ABSVALUE,FINSEQ_4,XBOOLE_0,XBOOLE_1,SCMFSA9A,XREAL_1,ORDINAL1,XXREAL_0,NAT_D,CLASSES1,PBOOLE,AFINSQ_1,COMPOS_1,EXTPRO_1,MEMSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48;
schemes RELSET_1,FUNCT_1,NAT_1;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,RELSET_1,FUNCOP_1,FINSUB_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,CARD_3,RFINSEQ,SCMFSA_2,SF_MASTR,SCMFSA6C,SCMFSA7B,FINSET_1,SCMFSA8A,SCMFSA8B,SCMFSA_9,SCM_HALT,STRUCT_0,VALUED_0,ORDINAL1,RELAT_1,FUNCT_2,PBOOLE,SCMFSA10,AMISTD_2,SCMFSA6A,COMPOS_1,SFMASTR1,FUNCT_4,EXTPRO_1,SCMFSA8C,MEMSTR_0,CKB49;
constructors SETWISEO,XXREAL_0,REAL_1,AMI_3,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA8C,SCM_HALT,SEQ_1,SCMFSA7B,AMISTD_2,NAT_D,CLASSES1,RELSET_1,DOMAIN_1,SFMASTR1,AMISTD_1,PBOOLE,PRE_POLY,SCMFSA_3,SCMFSA_7,SCMFSA_9,SCMFSA_2,XXREAL_2,MEMSTR_0,CKB21,CKB35,CKB36,CKB39;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
set a0 = ( intloc ( 0 ) );
set a1 = ( intloc 1 );
set a2 = ( intloc 2 );
set a6 = ( intloc 6 );
Lm9: a1 <> a6 by SCMFSA_2:101;
Lm13: a2 <> a6 by SCMFSA_2:101;
set b1 = ( intloc ( ( 0 ) + 1 ) );
set b2 = ( intloc ( 1 + 1 ) );
set b3 = ( intloc ( 2 + 1 ) );
set b4 = ( intloc ( 3 + 1 ) );
set b5 = ( intloc ( 4 + 1 ) );
set b6 = ( intloc ( 5 + 1 ) );
set f0 = ( fsloc ( 0 ) );
set i1 = ( b4 := b3 );
set i2 = ( SubFrom (b3,a0) );
set i3 = ( b5 := (f0,b3) );
set i4 = ( b6 := (f0,b4) );
set i5 = ( SubFrom (b6,b5) );
set i6 = ( (f0,b3) := b6 );
set i7 = ( (f0,b4) := b5 );
set SS = ( Stop ( SCM+FSA ) );
set ifc = ( if>0 (b6,( ( i4 ';' i6 ) ';' i7 ),SS) );
set body2 = ( ( ( ( ( i1 ';' i2 ) ';' i3 ) ';' i4 ) ';' i5 ) ';' ifc );
set T2 = ( Times (b2,body2) );
set j1 = ( b2 := b1 );
set j2 = ( SubFrom (b2,a0) );
set j3 = ( b3 :=len f0 );
set Sb = ( ( j1 ';' j2 ) ';' j3 );
set body1 = ( Sb ';' T2 );
Lm22: (not body2 destroy b2)
proof
A1: (not i1 destroy b2) by SCMFSA7B:6,SCMFSA_2:101;
A2: (not i2 destroy b2) by SCMFSA7B:8,SCMFSA_2:101;
A3: (not i3 destroy b2) by SCMFSA7B:14,SCMFSA_2:101;
A4: (not i4 destroy b2) by SCMFSA7B:14,SCMFSA_2:101;
A5: (not i6 destroy b2) by SCMFSA7B:15;
A6: (not i7 destroy b2) by SCMFSA7B:15;
A7: (not SS destroy b2) by SCMFSA8C:56;
(not ( ( i4 ';' i6 ) ';' i7 ) destroy b2) by A4,A5,A6,SCMFSA8C:54,SCMFSA8C:55;
then A8: (not ifc destroy b2) by A7,SCMFSA8C:88;
(not ( ( i1 ';' i2 ) ';' i3 ) destroy b2) by A1,A2,A3,SCMFSA8C:54,SCMFSA8C:55;
then (not ( ( ( i1 ';' i2 ) ';' i3 ) ';' i4 ) destroy b2) by Lm13,SCMFSA7B:14,SCMFSA8C:54;
then (not ( ( ( ( i1 ';' i2 ) ';' i3 ) ';' i4 ) ';' i5 ) destroy b2) by Lm13,SCMFSA7B:8,SCMFSA8C:54;
hence thesis by A8,SCMFSA8C:52;
end;
Lm23: ( Times (b2,body2) ) is  good  InitHalting
proof
thus ( Times (b2,body2) ) is  good;
let s being (State of ( SCM+FSA ));
assume that
Z1: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= s;
let P being (Instruction-Sequence of ( SCM+FSA ));
assume that
Z2: ( Times (b2,body2) ) c= P;
ZZ2: ( P +* ( Times (b2,body2) ) ) = P by Z2,FUNCT_4:98;
X2: ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) = { ( intloc ( 0 ) ) } by FUNCOP_1:13;
X1: ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) misses { ( IC ( SCM+FSA ) ) } by X2,SCMFSA_2:56,ZFMISC_1:11;
( Start-At (( 0 ),( SCM+FSA )) ) c= ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCT_4:25;
then x: s = ( Initialize s ) by Z1,FUNCT_4:98,XBOOLE_1:1;
Y2: ( intloc ( 0 ) ) in ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) by X2,TARSKI:def 1;
( dom ( ( intloc ( 0 ) ) .--> 1 ) ) misses ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) by X1,FUNCOP_1:13;
then ( ( intloc ( 0 ) ) .--> 1 ) c= ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCT_4:32;
then ( ( intloc ( 0 ) ) .--> 1 ) c= s by Z1,XBOOLE_1:1;
then A2: ( s . ( intloc ( 0 ) ) ) = ( ( ( intloc ( 0 ) ) .--> 1 ) . ( intloc ( 0 ) ) ) by Y2,GRFUNC_1:2
.= 1 by FUNCOP_1:72;
( Times (b2,body2) ) is_halting_on s,P by Lm22,A2,SCM_HALT:62;
hence P halts_on s by x,ZZ2,SCMFSA7B:def 7;
end;
Lm24: (not body2 destroy b1)
proof
A1: (not i1 destroy b1) by SCMFSA7B:6,SCMFSA_2:101;
A2: (not i2 destroy b1) by SCMFSA7B:8,SCMFSA_2:101;
A3: (not i3 destroy b1) by SCMFSA7B:14,SCMFSA_2:101;
A4: (not i4 destroy b1) by SCMFSA7B:14,SCMFSA_2:101;
A5: (not i6 destroy b1) by SCMFSA7B:15;
A6: (not i7 destroy b1) by SCMFSA7B:15;
A7: (not SS destroy b1) by SCMFSA8C:56;
(not ( ( i4 ';' i6 ) ';' i7 ) destroy b1) by A4,A5,A6,SCMFSA8C:54,SCMFSA8C:55;
then A8: (not ifc destroy b1) by A7,SCMFSA8C:88;
(not ( ( i1 ';' i2 ) ';' i3 ) destroy b1) by A1,A2,A3,SCMFSA8C:54,SCMFSA8C:55;
then (not ( ( ( i1 ';' i2 ) ';' i3 ) ';' i4 ) destroy b1) by Lm9,SCMFSA7B:14,SCMFSA8C:54;
then (not ( ( ( ( i1 ';' i2 ) ';' i3 ) ';' i4 ) ';' i5 ) destroy b1) by Lm9,SCMFSA7B:8,SCMFSA8C:54;
hence thesis by A8,SCMFSA8C:52;
end;
Lm25: (not body1 destroy b1)
proof
A1: (not j1 destroy b1) by SCMFSA7B:6,SCMFSA_2:101;
A2: (not j2 destroy b1) by SCMFSA7B:8,SCMFSA_2:101;
A3: (not j3 destroy b1) by SCMFSA7B:16,SCMFSA_2:101;
A4: (not T2 destroy b1) by Lm24,CKB1:1,SCMFSA_2:101;
(not ( ( j1 ';' j2 ) ';' j3 ) destroy b1) by A1,A2,A3,SCMFSA8C:54,SCMFSA8C:55;
hence thesis by A4,SCMFSA8C:52;
end;
Lm26: ( Times (b1,body1) ) is  good  InitHalting
proof
thus ( Times (b1,body1) ) is  good;
let s being (State of ( SCM+FSA ));
assume that
Z1: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= s;
let P being (Instruction-Sequence of ( SCM+FSA ));
assume that
Z2: ( Times (b1,body1) ) c= P;
ZZ2: ( P +* ( Times (b1,body1) ) ) = P by Z2,FUNCT_4:98;
X2: ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) = { ( intloc ( 0 ) ) } by FUNCOP_1:13;
X1: ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) misses { ( IC ( SCM+FSA ) ) } by X2,SCMFSA_2:56,ZFMISC_1:11;
( Start-At (( 0 ),( SCM+FSA )) ) c= ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCT_4:25;
then x: s = ( Initialize s ) by Z1,FUNCT_4:98,XBOOLE_1:1;
Y2: ( intloc ( 0 ) ) in ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) by X2,TARSKI:def 1;
( dom ( ( intloc ( 0 ) ) .--> 1 ) ) misses ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) by X1,FUNCOP_1:13;
then ( ( intloc ( 0 ) ) .--> 1 ) c= ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCT_4:32;
then ( ( intloc ( 0 ) ) .--> 1 ) c= s by Z1,XBOOLE_1:1;
then A2: ( s . ( intloc ( 0 ) ) ) = ( ( ( intloc ( 0 ) ) .--> 1 ) . ( intloc ( 0 ) ) ) by Y2,GRFUNC_1:2
.= 1 by FUNCOP_1:72;
reconsider TT = T2 as  good  InitHalting (Program of ( SCM+FSA )) by Lm23;
body1 = ( ( ( j1 ';' j2 ) ';' j3 ) ';' TT );
then ( Times (b1,body1) ) is_halting_on s,P by Lm25,A2,SCM_HALT:62;
hence P halts_on s by x,ZZ2,SCMFSA7B:def 7;
end;
theorem
( Bubble-Sort-Algorithm ),( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) computes ( Sorting-Function )
proof
let x being set;
assume x in ( dom ( Sorting-Function ) );
then consider w being (FinSequence of ( INT )) such that A1: x = ( ( fsloc ( 0 ) ) .--> w ) by CKB40:1;
reconsider d = x as (FinPartState of ( SCM+FSA )) by A1;
set q = ( Bubble-Sort-Algorithm );
set p = ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) );
A3: ( dom d ) = { ( fsloc ( 0 ) ) } by A1,FUNCOP_1:13;
take d;
thus x = d;
X5: ( dom d ) misses { ( IC ( SCM+FSA ) ) } by A3,SCMFSA_2:57,ZFMISC_1:11;
X6: ( dom d ) misses { ( intloc ( 0 ) ) } by A3,SCMFSA_2:58,ZFMISC_1:11;
( dom p ) = ( ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) \/ { ( IC ( SCM+FSA ) ) } ) by MEMSTR_0:42
.= ( { ( IC ( SCM+FSA ) ) } \/ { ( intloc ( 0 ) ) } ) by FUNCOP_1:13;
then X1: ( dom d ) misses ( dom p ) by X5,X6,XBOOLE_1:70;
UU: ( d +* p ) = ( p +* d ) by X1,FUNCT_4:35;
( Initialized d ) = ( d +* p ) by SCMFSA6A:def 3
.= ( p +* d ) by X1,FUNCT_4:35
.= ( p +* d )
.= ( p +* d );
then A4: ( p +* d ) is q -autonomic by A1,CKB48:1;
now
let t being (State of ( SCM+FSA ));
assume A6: ( p +* d ) c= t;
let P being (Instruction-Sequence of ( SCM+FSA ));
assume that
A7: q c= P;
set bf = ( bubble-sort ( fsloc ( 0 ) ) );
( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= ( p +* d ) by UU,FUNCT_4:25;
then ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= t by A6,XBOOLE_1:1;
hence P halts_on t by Lm26,A7,SCM_HALT:def 2;
end;
then A10: ( p +* d ) is q -halted by EXTPRO_1:def 11;
thus A15: ( p +* d ) is (Autonomy of q) by A10,A4,EXTPRO_1:def 12;
consider z being (FinSequence of ( REAL )) such that A16: w,z are_fiberwise_equipotent  and A17: z is  non-increasing and z is (FinSequence of ( INT )) and A18: ( ( Sorting-Function ) . d ) = ( ( fsloc ( 0 ) ) .--> z ) by A1,CKB41:1;
consider t being (State of ( SCM+FSA )) such that A19: ( p +* d ) c= t by PBOOLE:141;
consider T being (Instruction-Sequence of ( SCM+FSA )) such that B19: q c= T by PBOOLE:145;
consider u being (FinSequence of ( REAL )) such that A20: w,u are_fiberwise_equipotent  and A21: u is  non-increasing and u is (FinSequence of ( INT )) and A22: ( ( Result (T,t) ) . ( fsloc ( 0 ) ) ) = u by CKB47:1,A1,A19,B19;
A23: u = z by A16,A17,A20,A21,CLASSES1:76,RFINSEQ:23;
( fsloc ( 0 ) ) in (the carrier of ( SCM+FSA ));
then A24: ( fsloc ( 0 ) ) in ( dom ( Result (T,t) ) ) by PARTFUN1:def 2;
d c= ( p +* d ) by FUNCT_4:25;
then A25: ( dom d ) c= ( dom ( p +* d ) ) by RELAT_1:11;
A26: ( dom ( ( fsloc ( 0 ) ) .--> z ) ) = { ( fsloc ( 0 ) ) } by FUNCOP_1:13;
( Result (q,( p +* d )) ) = ( ( Result (T,t) ) | ( dom ( p +* d ) ) ) by A15,A19,B19,EXTPRO_1:def 13;
hence ( ( Sorting-Function ) . d ) c= ( Result (q,( p +* d )) ) by A3,A18,A22,A23,A24,A26,A25,FUNCT_4:85,RELAT_1:151;
end;
