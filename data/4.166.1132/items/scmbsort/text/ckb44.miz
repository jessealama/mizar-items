environ
vocabularies NUMBERS,SCMNORM,SCMFSA_2,AMI_1,SUBSET_1,SCMFSA7B,SCMFSA8C,SCMFSA8A,AMI_3,CARD_1,AMISTD_2,SCMFSA8B,TURING_1,FSM_1,GRAPHSP,FUNCT_1,PARTFUN1,COMPLEX1,FUNCT_4,ARYTM_3,SF_MASTR,SCMFSA6C,SCMFSA6B,FUNCOP_1,ORDINAL1,RELAT_1,TARSKI,XBOOLE_0,XXREAL_0,CIRCUIT2,NAT_1,STRUCT_0,ARYTM_1,INT_1,FINSEQ_1,FINSEQ_2,SCMFSA6A,FINSUB_1,CARD_3,CLASSES1,VALUED_0,MSUALG_1,SCM_HALT,SCMBSORT,PBOOLE,COMPOS_1;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,SETFAM_1,ORDINAL1,CARD_1,NUMBERS,XCMPLX_0,NAT_1,INT_1,RELAT_1,FINSEQ_1,FUNCT_1,COMPLEX1,FUNCT_2,PBOOLE,FUNCT_4,FINSEQ_2,FUNCT_7,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMISTD_2,SCMFSA_2,FUNCOP_1,FINSUB_1,CARD_3,PARTFUN1,SCMFSA6B,SCMFSA6C,SCMFSA6A,SF_MASTR,SCMFSA8A,SCMFSA8B,SCMFSA8C,CLASSES1,RFINSEQ,SCMFSA7B,NAT_D,SCM_HALT,XXREAL_0,CKB21,CKB35,CKB36,CKB39;
definitions TARSKI,FUNCOP_1,COMPOS_1,EXTPRO_1,XBOOLE_0,SCMFSA8C,SCM_HALT,MEMSTR_0,CKB35,CKB36,CKB39;
theorems SF_MASTR,FUNCT_1,FUNCT_7,FUNCOP_1,RELAT_1,FUNCT_2,ZFMISC_1,SCMFSA6A,FUNCT_4,FINSEQ_3,ENUMSET1,NAT_1,FINSEQ_1,RELSET_1,TARSKI,INT_1,PARTFUN1,GRFUNC_1,RFINSEQ,SCMFSA_2,SCMFSA7B,SCMFSA8B,SCMFSA8A,SCMFSA8C,SCMFSA6C,SCM_HALT,ABSVALUE,FINSEQ_4,XBOOLE_0,XBOOLE_1,SCMFSA9A,XREAL_1,ORDINAL1,XXREAL_0,NAT_D,CLASSES1,PBOOLE,AFINSQ_1,COMPOS_1,EXTPRO_1,MEMSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43;
schemes RELSET_1,FUNCT_1,NAT_1;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,RELSET_1,FUNCOP_1,FINSUB_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,CARD_3,RFINSEQ,SCMFSA_2,SF_MASTR,SCMFSA6C,SCMFSA7B,FINSET_1,SCMFSA8A,SCMFSA8B,SCMFSA_9,SCM_HALT,STRUCT_0,VALUED_0,ORDINAL1,RELAT_1,FUNCT_2,PBOOLE,SCMFSA10,AMISTD_2,SCMFSA6A,COMPOS_1,SFMASTR1,FUNCT_4,EXTPRO_1,SCMFSA8C,MEMSTR_0;
constructors SETWISEO,XXREAL_0,REAL_1,AMI_3,SCMFSA6A,SF_MASTR,SCMFSA6B,SCMFSA6C,SCMFSA8A,SCMFSA8B,SCMFSA8C,SCM_HALT,SEQ_1,SCMFSA7B,AMISTD_2,NAT_D,CLASSES1,RELSET_1,DOMAIN_1,SFMASTR1,AMISTD_1,PBOOLE,PRE_POLY,SCMFSA_3,SCMFSA_7,SCMFSA_9,SCMFSA_2,XXREAL_2,MEMSTR_0,CKB21,CKB35,CKB36,CKB39;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
set a0 = ( intloc ( 0 ) );
set a1 = ( intloc 1 );
set a2 = ( intloc 2 );
set a6 = ( intloc 6 );
Lm9: a1 <> a6 by SCMFSA_2:101;
Lm13: a2 <> a6 by SCMFSA_2:101;
set b1 = ( intloc ( ( 0 ) + 1 ) );
set b2 = ( intloc ( 1 + 1 ) );
set b3 = ( intloc ( 2 + 1 ) );
set b4 = ( intloc ( 3 + 1 ) );
set b5 = ( intloc ( 4 + 1 ) );
set b6 = ( intloc ( 5 + 1 ) );
set f0 = ( fsloc ( 0 ) );
set i1 = ( b4 := b3 );
set i2 = ( SubFrom (b3,a0) );
set i3 = ( b5 := (f0,b3) );
set i4 = ( b6 := (f0,b4) );
set i5 = ( SubFrom (b6,b5) );
set i6 = ( (f0,b3) := b6 );
set i7 = ( (f0,b4) := b5 );
set SS = ( Stop ( SCM+FSA ) );
set ifc = ( if>0 (b6,( ( i4 ';' i6 ) ';' i7 ),SS) );
set body2 = ( ( ( ( ( i1 ';' i2 ) ';' i3 ) ';' i4 ) ';' i5 ) ';' ifc );
set T2 = ( Times (b2,body2) );
set j1 = ( b2 := b1 );
set j2 = ( SubFrom (b2,a0) );
set j3 = ( b3 :=len f0 );
set Sb = ( ( j1 ';' j2 ) ';' j3 );
set body1 = ( Sb ';' T2 );
Lm22: (not body2 destroy b2)
proof
A1: (not i1 destroy b2) by SCMFSA7B:6,SCMFSA_2:101;
A2: (not i2 destroy b2) by SCMFSA7B:8,SCMFSA_2:101;
A3: (not i3 destroy b2) by SCMFSA7B:14,SCMFSA_2:101;
A4: (not i4 destroy b2) by SCMFSA7B:14,SCMFSA_2:101;
A5: (not i6 destroy b2) by SCMFSA7B:15;
A6: (not i7 destroy b2) by SCMFSA7B:15;
A7: (not SS destroy b2) by SCMFSA8C:56;
(not ( ( i4 ';' i6 ) ';' i7 ) destroy b2) by A4,A5,A6,SCMFSA8C:54,SCMFSA8C:55;
then A8: (not ifc destroy b2) by A7,SCMFSA8C:88;
(not ( ( i1 ';' i2 ) ';' i3 ) destroy b2) by A1,A2,A3,SCMFSA8C:54,SCMFSA8C:55;
then (not ( ( ( i1 ';' i2 ) ';' i3 ) ';' i4 ) destroy b2) by Lm13,SCMFSA7B:14,SCMFSA8C:54;
then (not ( ( ( ( i1 ';' i2 ) ';' i3 ) ';' i4 ) ';' i5 ) destroy b2) by Lm13,SCMFSA7B:8,SCMFSA8C:54;
hence thesis by A8,SCMFSA8C:52;
end;
Lm23: ( Times (b2,body2) ) is  good  InitHalting
proof
thus ( Times (b2,body2) ) is  good;
let s being (State of ( SCM+FSA ));
assume that
Z1: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= s;
let P being (Instruction-Sequence of ( SCM+FSA ));
assume that
Z2: ( Times (b2,body2) ) c= P;
ZZ2: ( P +* ( Times (b2,body2) ) ) = P by Z2,FUNCT_4:98;
X2: ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) = { ( intloc ( 0 ) ) } by FUNCOP_1:13;
X1: ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) misses { ( IC ( SCM+FSA ) ) } by X2,SCMFSA_2:56,ZFMISC_1:11;
( Start-At (( 0 ),( SCM+FSA )) ) c= ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCT_4:25;
then x: s = ( Initialize s ) by Z1,FUNCT_4:98,XBOOLE_1:1;
Y2: ( intloc ( 0 ) ) in ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) by X2,TARSKI:def 1;
( dom ( ( intloc ( 0 ) ) .--> 1 ) ) misses ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) by X1,FUNCOP_1:13;
then ( ( intloc ( 0 ) ) .--> 1 ) c= ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCT_4:32;
then ( ( intloc ( 0 ) ) .--> 1 ) c= s by Z1,XBOOLE_1:1;
then A2: ( s . ( intloc ( 0 ) ) ) = ( ( ( intloc ( 0 ) ) .--> 1 ) . ( intloc ( 0 ) ) ) by Y2,GRFUNC_1:2
.= 1 by FUNCOP_1:72;
( Times (b2,body2) ) is_halting_on s,P by Lm22,A2,SCM_HALT:62;
hence P halts_on s by x,ZZ2,SCMFSA7B:def 7;
end;
Lm24: (not body2 destroy b1)
proof
A1: (not i1 destroy b1) by SCMFSA7B:6,SCMFSA_2:101;
A2: (not i2 destroy b1) by SCMFSA7B:8,SCMFSA_2:101;
A3: (not i3 destroy b1) by SCMFSA7B:14,SCMFSA_2:101;
A4: (not i4 destroy b1) by SCMFSA7B:14,SCMFSA_2:101;
A5: (not i6 destroy b1) by SCMFSA7B:15;
A6: (not i7 destroy b1) by SCMFSA7B:15;
A7: (not SS destroy b1) by SCMFSA8C:56;
(not ( ( i4 ';' i6 ) ';' i7 ) destroy b1) by A4,A5,A6,SCMFSA8C:54,SCMFSA8C:55;
then A8: (not ifc destroy b1) by A7,SCMFSA8C:88;
(not ( ( i1 ';' i2 ) ';' i3 ) destroy b1) by A1,A2,A3,SCMFSA8C:54,SCMFSA8C:55;
then (not ( ( ( i1 ';' i2 ) ';' i3 ) ';' i4 ) destroy b1) by Lm9,SCMFSA7B:14,SCMFSA8C:54;
then (not ( ( ( ( i1 ';' i2 ) ';' i3 ) ';' i4 ) ';' i5 ) destroy b1) by Lm9,SCMFSA7B:8,SCMFSA8C:54;
hence thesis by A8,SCMFSA8C:52;
end;
Lm25: (not body1 destroy b1)
proof
A1: (not j1 destroy b1) by SCMFSA7B:6,SCMFSA_2:101;
A2: (not j2 destroy b1) by SCMFSA7B:8,SCMFSA_2:101;
A3: (not j3 destroy b1) by SCMFSA7B:16,SCMFSA_2:101;
A4: (not T2 destroy b1) by Lm24,CKB1:1,SCMFSA_2:101;
(not ( ( j1 ';' j2 ) ';' j3 ) destroy b1) by A1,A2,A3,SCMFSA8C:54,SCMFSA8C:55;
hence thesis by A4,SCMFSA8C:52;
end;
Lm26: ( Times (b1,body1) ) is  good  InitHalting
proof
thus ( Times (b1,body1) ) is  good;
let s being (State of ( SCM+FSA ));
assume that
Z1: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= s;
let P being (Instruction-Sequence of ( SCM+FSA ));
assume that
Z2: ( Times (b1,body1) ) c= P;
ZZ2: ( P +* ( Times (b1,body1) ) ) = P by Z2,FUNCT_4:98;
X2: ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) = { ( intloc ( 0 ) ) } by FUNCOP_1:13;
X1: ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) misses { ( IC ( SCM+FSA ) ) } by X2,SCMFSA_2:56,ZFMISC_1:11;
( Start-At (( 0 ),( SCM+FSA )) ) c= ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCT_4:25;
then x: s = ( Initialize s ) by Z1,FUNCT_4:98,XBOOLE_1:1;
Y2: ( intloc ( 0 ) ) in ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) by X2,TARSKI:def 1;
( dom ( ( intloc ( 0 ) ) .--> 1 ) ) misses ( dom ( Start-At (( 0 ),( SCM+FSA )) ) ) by X1,FUNCOP_1:13;
then ( ( intloc ( 0 ) ) .--> 1 ) c= ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCT_4:32;
then ( ( intloc ( 0 ) ) .--> 1 ) c= s by Z1,XBOOLE_1:1;
then A2: ( s . ( intloc ( 0 ) ) ) = ( ( ( intloc ( 0 ) ) .--> 1 ) . ( intloc ( 0 ) ) ) by Y2,GRFUNC_1:2
.= 1 by FUNCOP_1:72;
reconsider TT = T2 as  good  InitHalting (Program of ( SCM+FSA )) by Lm23;
body1 = ( ( ( j1 ';' j2 ) ';' j3 ) ';' TT );
then ( Times (b1,body1) ) is_halting_on s,P by Lm25,A2,SCM_HALT:62;
hence P halts_on s by x,ZZ2,SCMFSA7B:def 7;
end;
theorem
( bubble-sort ( fsloc ( 0 ) ) ) is  keepInt0_1  InitHalting by Lm26;
