environ
vocabularies FINSEQ_1,CARD_1,ORDINAL4,SUBSET_1,NUMBERS,ARYTM_3,TARSKI,RELAT_1,XBOOLE_0,FUNCT_1,QC_LANG1,XBOOLEAN,HILBERT1,MODELC_2,CQC_THE1,NAT_1,XXREAL_0,LTLAXIO1,ORDINAL1,ARYTM_1,ZF_LANG,PARTFUN1,MARGREL1,FUNCT_2,HILBERT2,ZFMISC_1,FUNCOP_1,ZF_MODEL,PBOOLE,GLIB_000;
notations TARSKI,XBOOLE_0,ZFMISC_1,DOMAIN_1,SUBSET_1,RELAT_1,PARTFUN1,NUMBERS,XCMPLX_0,NAT_1,XXREAL_0,NAT_D,FUNCT_1,FUNCT_2,BINOP_1,ORDINAL1,FINSEQ_1,HILBERT1,HILBERT2,PBOOLE,XBOOLEAN,MARGREL1,AOFA_I00,CKB5,CKB6,CKB7,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19;
definitions XBOOLEAN,TARSKI,MARGREL1,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18;
theorems TARSKI,NAT_1,XBOOLE_0,XXREAL_0,FINSEQ_1,NAT_D,XBOOLEAN,FUNCT_2,PARTFUN1,XREAL_1,ZFMISC_1,ORDINAL1,FUNCOP_1,HILBERT2,BINOP_1,XREAL_0,CKB1,CKB2,CKB3,CKB4,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18;
schemes NAT_1,XBOOLE_0,FUNCT_2,FINSEQ_1,BINOP_1,HILBERT2;
registrations SUBSET_1,ORDINAL1,FUNCT_1,XXREAL_0,NAT_1,XBOOLEAN,RELSET_1,MARGREL1,XBOOLE_0,XREAL_0,FUNCT_2,HILBERT1;
constructors XXREAL_0,NAT_D,RELSET_1,AOFA_I00,HILBERT2,DOMAIN_1,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18;
requirements NUMERALS,BOOLE,SUBSET,ARITHM,REAL;
begin
reserve a for  boolean number;
reserve b for  boolean number;
reserve c for  boolean number;
reserve p for (Element of ( LTLB_WFF ));
reserve q for (Element of ( LTLB_WFF ));
reserve A for (Element of ( LTLB_WFF ));
reserve B for (Element of ( LTLB_WFF ));
reserve i for (Element of ( NAT ));
reserve j for (Element of ( NAT ));
reserve k for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
reserve f1 for (FinSequence of ( LTLB_WFF ));
reserve M for LTLModel;
definition
let M being LTLModel;
func SAT M -> (Function of [: ( NAT ),( LTLB_WFF ) :],( BOOLEAN )) means 
:Def12: (for n holds ((( it . [ n,( TFALSUM ) ] ) = ( 0 ) & (for k holds (( it . [ n,( prop k ) ] ) = 1 iff ( prop k ) in ( M . n )))) & (for p holds (for q holds (( it . [ n,( p => q ) ] ) = ( ( it . [ n,p ] ) => ( it . [ n,q ] ) ) & (( it . [ n,( p 'Us' q ) ] ) = 1 iff (ex i st ((( 0 ) < i & ( it . [ ( n + i ),q ] ) = 1) & (for j holds ((1 <= j & j < i) implies ( it . [ ( n + j ),p ] ) = 1))))))))));
existence
proof
set FNB = ( Funcs (( NAT ),( BOOLEAN )) );
defpred I[ (Element of ( LTLB_WFF )),(Element of ( LTLB_WFF )),set,set,set ]
 means
((($3 is (sequence of ( BOOLEAN )) & $4 is (sequence of ( BOOLEAN ))) implies (ex s3,s4,s5 being (sequence of ( BOOLEAN )) st (((s3 = $3 & s4 = $4) & s5 = $5) & (for n holds ( s5 . n ) = ( ( s3 . n ) => ( s4 . n ) ))))) & ((not ($3 is (sequence of ( BOOLEAN )) & $4 is (sequence of ( BOOLEAN )))) implies $5 = ( ( NAT ) --> ( FALSE ) )));
defpred C[ (Element of ( LTLB_WFF )),(Element of ( LTLB_WFF )),set,set,set ]
 means
((($3 is (sequence of ( BOOLEAN )) & $4 is (sequence of ( BOOLEAN ))) implies (ex s3,s4,s5 being (sequence of ( BOOLEAN )) st (((s3 = $3 & s4 = $4) & s5 = $5) & (for n holds (( s5 . n ) = 1 iff (ex i st ((( 0 ) < i & ( s4 . ( n + i ) ) = 1) & (for j holds ((1 <= j & j < i) implies ( s3 . ( n + j ) ) = 1))))))))) & ((not ($3 is (sequence of ( BOOLEAN )) & $4 is (sequence of ( BOOLEAN )))) implies $5 = ( ( NAT ) --> ( FALSE ) )));
defpred P1[ (Element of ( NAT )),Function ]
 means
(for n holds (( $2 . n ) = 1 iff ( prop $1 ) in ( M . n )));
A1: (for p holds (for q holds (for a,b being set holds (ex d being set st C[ p,q,a,b,d ]))))
proof
let p;
let q;
let a being set;
let b being set;
per cases ;
suppose (a is (sequence of ( BOOLEAN )) & b is (sequence of ( BOOLEAN )));

then reconsider a1 = a,b1 = b as (sequence of ( BOOLEAN ));
defpred PP[ (Element of ( NAT )),(Element of ( BOOLEAN )) ]
 means
($2 = 1 iff (ex i st ((( 0 ) < i & ( b1 . ( $1 + i ) ) = 1) & (for j holds ((1 <= j & j < i) implies ( a1 . ( $1 + j ) ) = 1)))));
A2:now
let n;
per cases ;
suppose (ex i st ((( 0 ) < i & ( b1 . ( n + i ) ) = 1) & (for j holds ((1 <= j & j < i) implies ( a1 . ( n + j ) ) = 1))));

hence (ex y being (Element of ( BOOLEAN )) st PP[ n,y ]);
end;
suppose (not (ex i st ((( 0 ) < i & ( b1 . ( n + i ) ) = 1) & (for j holds ((1 <= j & j < i) implies ( a1 . ( n + j ) ) = 1)))));

then PP[ n,( FALSE ) ];
hence (ex y being (Element of ( BOOLEAN )) st PP[ n,y ]);
end;
end;
consider c being (Function of ( NAT ),( BOOLEAN )) such that A3: (for n holds PP[ n,( c . n ) ]) from FUNCT_2:sch 3(A2);
thus thesis by A3;
end;
suppose (not (a is (sequence of ( BOOLEAN )) & b is (sequence of ( BOOLEAN ))));

hence thesis;
end;
end;
A4: (for p holds (for q holds (for a,b,c,d being set holds ((C[ p,q,a,b,c ] & C[ p,q,a,b,d ]) implies c = d))))
proof
let p;
let q;
let a being set;
let b being set;
let c being set;
let d being set;
assume that
A5: C[ p,q,a,b,c ]
and
A6: C[ p,q,a,b,d ];
per cases ;
suppose A7: (a is (sequence of ( BOOLEAN )) & b is (sequence of ( BOOLEAN )));

then consider s31,s41,s51 being (sequence of ( BOOLEAN )) such that A8: (s31 = a & s41 = b) and A9: s51 = d and A10: (for n holds (( s51 . n ) = 1 iff (ex i st ((( 0 ) < i & ( s41 . ( n + i ) ) = 1) & (for j holds ((1 <= j & j < i) implies ( s31 . ( n + j ) ) = 1)))))) by A6;
consider s3,s4,s5 being (sequence of ( BOOLEAN )) such that A11: (s3 = a & s4 = b) and A12: s5 = c and A13: (for n holds (( s5 . n ) = 1 iff (ex i st ((( 0 ) < i & ( s4 . ( n + i ) ) = 1) & (for j holds ((1 <= j & j < i) implies ( s3 . ( n + j ) ) = 1)))))) by A5,A7;
now
let x being set;
assume x in ( NAT );
then reconsider x1 = x as (Element of ( NAT ));
per cases  by XBOOLEAN:def 3;
suppose A14: ( s5 . x1 ) = 1;

then (ex i st ((( 0 ) < i & ( s41 . ( x1 + i ) ) = 1) & (for j holds ((1 <= j & j < i) implies ( s31 . ( x1 + j ) ) = 1)))) by A11,A13,A8;
hence ( s5 . x ) = ( s51 . x ) by A10,A14;
end;
suppose A15: ( s5 . x1 ) = ( 0 );

then (not (ex i st ((( 0 ) < i & ( s41 . ( x1 + i ) ) = 1) & (for j holds ((1 <= j & j < i) implies ( s31 . ( x1 + j ) ) = 1))))) by A11,A13,A8;
then (not ( s51 . x1 ) = 1) by A10;
hence ( s5 . x ) = ( s51 . x ) by A15,XBOOLEAN:def 3;
end;
end;
hence c = d by A12,A9,FUNCT_2:12;
end;
suppose (not (a is (sequence of ( BOOLEAN )) & b is (sequence of ( BOOLEAN ))));

hence c = d by A5,A6;
end;
end;
A16: (for x being (Element of ( NAT )) holds (ex y being (Element of ( Funcs (( NAT ),( BOOLEAN )) )) st P1[ x,y ]))
proof
let x being (Element of ( NAT ));
defpred P2[ (Element of ( NAT )),(Element of ( BOOLEAN )) ]
 means
($2 = 1 iff ( prop x ) in ( M . $1 ));
A17:now
let x1 being (Element of ( NAT ));
per cases ;
suppose ( prop x ) in ( M . x1 );

then P2[ x1,( TRUE ) ];
hence (ex y1 being (Element of ( BOOLEAN )) st P2[ x1,y1 ]);
end;
suppose (not ( prop x ) in ( M . x1 ));

then P2[ x1,( FALSE ) ];
hence (ex y1 being (Element of ( BOOLEAN )) st P2[ x1,y1 ]);
end;
end;
consider y being (Function of ( NAT ),( BOOLEAN )) such that A18: (for n holds P2[ n,( y . n ) ]) from FUNCT_2:sch 3(A17);
reconsider y as (Element of ( Funcs (( NAT ),( BOOLEAN )) )) by FUNCT_2:8;
P1[ x,y ] by A18;
hence (ex y being (Element of ( Funcs (( NAT ),( BOOLEAN )) )) st P1[ x,y ]);
end;
consider f1 being (Function of ( NAT ),( Funcs (( NAT ),( BOOLEAN )) )) such that A19: (for k holds P1[ k,( f1 . k ) ]) from FUNCT_2:sch 3(A16);
A20: (for p holds (for q holds (for a,b,c,d being set holds ((I[ p,q,a,b,c ] & I[ p,q,a,b,d ]) implies c = d))))
proof
let p;
let q;
let a being set;
let b being set;
let c being set;
let d being set;
assume that
A21: I[ p,q,a,b,c ]
and
A22: I[ p,q,a,b,d ];
per cases ;
suppose A23: (a is (sequence of ( BOOLEAN )) & b is (sequence of ( BOOLEAN )));

then consider s31,s41,s51 being (sequence of ( BOOLEAN )) such that A24: s31 = a and A25: s41 = b and A26: s51 = d and A27: (for n holds ( s51 . n ) = ( ( s31 . n ) => ( s41 . n ) )) by A22;
consider s3,s4,s5 being (sequence of ( BOOLEAN )) such that A28: s3 = a and A29: s4 = b and A30: s5 = c and A31: (for n holds ( s5 . n ) = ( ( s3 . n ) => ( s4 . n ) )) by A21,A23;
now
let x being set;
assume x in ( NAT );
then reconsider x1 = x as (Element of ( NAT ));
thus ( s5 . x ) = ( ( s31 . x1 ) => ( s4 . x1 ) ) by A28,A31,A24
.= ( s51 . x ) by A29,A25,A27;
end;
hence c = d by A30,A26,FUNCT_2:12;
end;
suppose (not (a is (sequence of ( BOOLEAN )) & b is (sequence of ( BOOLEAN ))));

hence c = d by A21,A22;
end;
end;
deffunc P((Element of ( NAT ))) = ( f1 . $1 );
A32: (for p holds (for q holds (for a,b being set holds (ex d being set st I[ p,q,a,b,d ]))))
proof
let p;
let q;
let a being set;
let b being set;
per cases ;
suppose (a is (sequence of ( BOOLEAN )) & b is (sequence of ( BOOLEAN )));

then reconsider a1 = a,b1 = b as (sequence of ( BOOLEAN ));
deffunc F3((Element of ( NAT ))) = ( 'not' ( ( a1 . $1 ) '&' ( 'not' ( b1 . $1 ) ) ) );
consider d being (Function of ( NAT ),( BOOLEAN )) such that A33: (for n holds ( d . n ) = F3(n)) from FUNCT_2:sch 4;
(for n holds ( d . n ) = ( ( a1 . n ) => ( b1 . n ) )) by A33;
hence thesis;
end;
suppose (not (a is (sequence of ( BOOLEAN )) & b is (sequence of ( BOOLEAN ))));

hence thesis;
end;
end;
consider sat being (ManySortedSet of ( LTLB_WFF )) such that A34: ((( sat . ( TFALSUM ) ) = ( ( NAT ) --> ( FALSE ) ) & (for n holds ( sat . ( prop n ) ) = P(n))) & (for p holds (for q holds (C[ p,q,( sat . p ),( sat . q ),( sat . ( p 'Us' q ) ) ] & I[ p,q,( sat . p ),( sat . q ),( sat . ( p => q ) ) ])))) from HILBERT2:sch 3(A1,A32,A4,A20);
A35:now
A36:now
let A;
let B;
A37: I[ A,B,( sat . A ),( sat . B ),( sat . ( A => B ) ) ] by A34;
per cases ;
suppose (( sat . A ) is (sequence of ( BOOLEAN )) & ( sat . B ) is (sequence of ( BOOLEAN )));

then consider s3,s4,s5 being (sequence of ( BOOLEAN )) such that s3 = ( sat . A ) and s4 = ( sat . B ) and A38: s5 = ( sat . ( A => B ) ) and (for n holds ( s5 . n ) = ( ( s3 . n ) => ( s4 . n ) )) by A34;
thus ( sat . ( A => B ) ) in FNB by A38,FUNCT_2:8;
end;
suppose (not (( sat . A ) is (sequence of ( BOOLEAN )) & ( sat . B ) is (sequence of ( BOOLEAN ))));

hence ( sat . ( A => B ) ) in FNB by A37;
end;
end;
A39:now
let A;
let B;
A40: C[ A,B,( sat . A ),( sat . B ),( sat . ( A 'Us' B ) ) ] by A34;
per cases ;
suppose (( sat . A ) is (sequence of ( BOOLEAN )) & ( sat . B ) is (sequence of ( BOOLEAN )));

then consider s3,s4,s5 being (sequence of ( BOOLEAN )) such that s3 = ( sat . A ) and s4 = ( sat . B ) and A41: s5 = ( sat . ( A 'Us' B ) ) and (for n holds (( s5 . n ) = 1 iff (ex i st ((( 0 ) < i & ( s4 . ( n + i ) ) = 1) & (for j holds ((1 <= j & j < i) implies ( s3 . ( n + j ) ) = 1)))))) by A34;
thus ( sat . ( A 'Us' B ) ) in FNB by A41,FUNCT_2:8;
end;
suppose (not (( sat . A ) is (sequence of ( BOOLEAN )) & ( sat . B ) is (sequence of ( BOOLEAN ))));

hence ( sat . ( A 'Us' B ) ) in FNB by A40;
end;
end;
let x being set;
assume x in ( LTLB_WFF );
then reconsider x1 = x as (Element of ( LTLB_WFF ));
A42:now
let n;
( sat . ( prop n ) ) = ( f1 . n ) by A34;
hence ( sat . ( prop n ) ) in FNB;
end;
per cases  by CKB8:1;
suppose x1 = ( TFALSUM );

hence ( sat . x ) in FNB by A34;
end;
suppose (ex n being (Element of ( NAT )) st x1 = ( prop n ));

hence ( sat . x ) in FNB by A42;
end;
suppose (ex p,q being (Element of ( LTLB_WFF )) st x1 = ( p 'Us' q ));

hence ( sat . x ) in FNB by A39;
end;
suppose (ex p,q being (Element of ( LTLB_WFF )) st x1 = ( p => q ));

hence ( sat . x ) in FNB by A36;
end;
end;
( dom sat ) = ( LTLB_WFF ) by PARTFUN1:def 2;
then reconsider sat as (Function of ( LTLB_WFF ),( Funcs (( NAT ),( BOOLEAN )) )) by A35,FUNCT_2:3;
deffunc satpom((Element of ( NAT )),(Element of ( LTLB_WFF ))) = ( ( sat . $2 ) . $1 );
consider sat2 being (Function of [: ( NAT ),( LTLB_WFF ) :],( BOOLEAN )) such that A43: (for n holds (for A holds ( sat2 . (n,A) ) = satpom(n,A))) from BINOP_1:sch 4;
A44:now
let A;
let n;
thus ( sat2 . [ n,A ] ) = ( sat2 . (n,A) ) by BINOP_1:def 1
.= ( ( sat . A ) . n ) by A43;
end;
A45:now
let k;
let n;
( sat2 . [ n,( prop k ) ] ) = ( ( sat . ( prop k ) ) . n ) by A44
.= ( ( f1 . k ) . n ) by A34;
hence (( sat2 . [ n,( prop k ) ] ) = 1 iff ( prop k ) in ( M . n )) by A19;
end;
A46:now
let p;
let q;
let n;
reconsider satp = ( sat . p ),satq = ( sat . q ) as (sequence of ( BOOLEAN )) by FUNCT_2:66;
consider s31,s41,s51 being (sequence of ( BOOLEAN )) such that A47: s31 = satp and A48: s41 = satq and A49: s51 = ( sat . ( p 'Us' q ) ) and A50: (for n holds (( s51 . n ) = 1 iff (ex i st ((( 0 ) < i & ( s41 . ( n + i ) ) = 1) & (for j holds ((1 <= j & j < i) implies ( s31 . ( n + j ) ) = 1)))))) by A34;
consider s3,s4,s5 being (sequence of ( BOOLEAN )) such that A51: s3 = satp and A52: s4 = satq and A53: (s5 = ( sat . ( p => q ) ) & (for n holds ( s5 . n ) = ( ( s3 . n ) => ( s4 . n ) ))) by A34;
thus ( sat2 . [ n,( p => q ) ] ) = ( ( sat . ( p => q ) ) . n ) by A44
.= ( ( ( sat . p ) . n ) => ( s4 . n ) ) by A51,A53
.= ( ( sat2 . [ n,p ] ) => ( ( sat . q ) . n ) ) by A44,A52
.= ( ( sat2 . [ n,p ] ) => ( sat2 . [ n,q ] ) ) by A44;
thus (( sat2 . [ n,( p 'Us' q ) ] ) = 1 iff (ex i st ((( 0 ) < i & ( sat2 . [ ( n + i ),q ] ) = 1) & (for j holds ((1 <= j & j < i) implies ( sat2 . [ ( n + j ),p ] ) = 1)))))
proof
hereby
assume ( sat2 . [ n,( p 'Us' q ) ] ) = 1;
then ( s51 . n ) = 1 by A44,A49;
then consider i such that A54: ( 0 ) < i and A55: ( s41 . ( n + i ) ) = 1 and A56: (for j holds ((1 <= j & j < i) implies ( s31 . ( n + j ) ) = 1)) by A50;
A57:now
let j;
assume A58: (1 <= j & j < i);
thus ( sat2 . [ ( n + j ),p ] ) = ( ( sat . p ) . ( n + j ) ) by A44
.= 1 by A47,A56,A58;
end;
( sat2 . [ ( n + i ),q ] ) = 1 by A44,A48,A55;
hence (ex i st ((( 0 ) < i & ( sat2 . [ ( n + i ),q ] ) = 1) & (for j holds ((1 <= j & j < i) implies ( sat2 . [ ( n + j ),p ] ) = 1)))) by A54,A57;
end;
assume (ex i st ((( 0 ) < i & ( sat2 . [ ( n + i ),q ] ) = 1) & (for j holds ((1 <= j & j < i) implies ( sat2 . [ ( n + j ),p ] ) = 1))));
then consider i such that A59: ( 0 ) < i and A60: ( sat2 . [ ( n + i ),q ] ) = 1 and A61: (for j holds ((1 <= j & j < i) implies ( sat2 . [ ( n + j ),p ] ) = 1));
A62: ( s41 . ( n + i ) ) = 1 by A44,A48,A60;
A63: (for j holds ((1 <= j & j < i) implies ( s31 . ( n + j ) ) = 1))
proof
let j;
assume A64: (1 <= j & j < i);
thus ( s31 . ( n + j ) ) = ( sat2 . [ ( n + j ),p ] ) by A44,A47
.= 1 by A61,A64;
end;
thus ( sat2 . [ n,( p 'Us' q ) ] ) = ( s51 . n ) by A44,A49
.= 1 by A50,A59,A62,A63;
end;

end;
take sat2;
now
let n;
thus ( sat2 . [ n,( TFALSUM ) ] ) = ( ( sat . ( TFALSUM ) ) . n ) by A44
.= ( 0 ) by A34,FUNCOP_1:7;
end;
hence thesis by A45,A46;
end;
uniqueness
proof
let v1 being (Function of [: ( NAT ),( LTLB_WFF ) :],( BOOLEAN ));
let v2 being (Function of [: ( NAT ),( LTLB_WFF ) :],( BOOLEAN ));
assume A65: (for n being (Element of ( NAT )) holds ((( v1 . [ n,( TFALSUM ) ] ) = ( 0 ) & (for k holds (( v1 . [ n,( prop k ) ] ) = 1 iff ( prop k ) in ( M . n )))) & (for p holds (for q holds (( v1 . [ n,( p => q ) ] ) = ( ( v1 . [ n,p ] ) => ( v1 . [ n,q ] ) ) & (( v1 . [ n,( p 'Us' q ) ] ) = 1 iff (ex i st ((( 0 ) < i & ( v1 . [ ( n + i ),q ] ) = 1) & (for j holds ((1 <= j & j < i) implies ( v1 . [ ( n + j ),p ] ) = 1))))))))));
assume A66: (for n being (Element of ( NAT )) holds ((( v2 . [ n,( TFALSUM ) ] ) = ( 0 ) & (for k holds (( v2 . [ n,( prop k ) ] ) = 1 iff ( prop k ) in ( M . n )))) & (for p holds (for q holds (( v2 . [ n,( p => q ) ] ) = ( ( v2 . [ n,p ] ) => ( v2 . [ n,q ] ) ) & (( v2 . [ n,( p 'Us' q ) ] ) = 1 iff (ex i st ((( 0 ) < i & ( v2 . [ ( n + i ),q ] ) = 1) & (for j holds ((1 <= j & j < i) implies ( v2 . [ ( n + j ),p ] ) = 1))))))))));
thus v1 = v2
proof
defpred P1[ (Element of ( LTLB_WFF )) ]
 means
(for n being (Element of ( NAT )) holds ( v1 . [ n,$1 ] ) = ( v2 . [ n,$1 ] ));
A67: (for n being (Element of ( NAT )) holds P1[ ( prop n ) ])
proof
let k being (Element of ( NAT ));
now
let n being (Element of ( NAT ));
per cases ;
suppose A68: ( prop k ) in ( M . n );

hence ( v1 . [ n,( prop k ) ] ) = 1 by A65
.= ( v2 . [ n,( prop k ) ] ) by A66,A68;
end;
suppose A69: (not ( prop k ) in ( M . n ));

then (not ( v1 . [ n,( prop k ) ] ) = 1) by A65;
then A70: ( v1 . [ n,( prop k ) ] ) = ( 0 ) by XBOOLEAN:def 3;
(not ( v2 . [ n,( prop k ) ] ) = 1) by A66,A69;
hence ( v1 . [ n,( prop k ) ] ) = ( v2 . [ n,( prop k ) ] ) by A70,XBOOLEAN:def 3;
end;
end;
hence P1[ ( prop k ) ];
end;
A71: (for p holds (for q holds ((P1[ p ] & P1[ q ]) implies (P1[ ( p 'Us' q ) ] & P1[ ( p => q ) ]))))
proof
let p;
let q;
assume that
A72: P1[ p ]
and
A73: P1[ q ];
thus P1[ ( p 'Us' q ) ]
proof
let n;
per cases ;
suppose A74: (ex i st ((( 0 ) < i & ( v1 . [ ( n + i ),q ] ) = 1) & (for j holds ((1 <= j & j < i) implies ( v1 . [ ( n + j ),p ] ) = 1))));

then consider i such that A75: ( 0 ) < i and A76: ( v1 . [ ( n + i ),q ] ) = 1 and A77: (for j holds ((1 <= j & j < i) implies ( v1 . [ ( n + j ),p ] ) = 1));
A78: ( v2 . [ ( n + i ),q ] ) = 1 by A73,A76;
A79:now
let j;
assume (1 <= j & j < i);
then ( v1 . [ ( n + j ),p ] ) = 1 by A77;
hence ( v2 . [ ( n + j ),p ] ) = 1 by A72;
end;
thus ( v1 . [ n,( p 'Us' q ) ] ) = 1 by A65,A74
.= ( v2 . [ n,( p 'Us' q ) ] ) by A66,A75,A78,A79;
end;
suppose A80: (not (ex i st ((( 0 ) < i & ( v1 . [ ( n + i ),q ] ) = 1) & (for j holds ((1 <= j & j < i) implies ( v1 . [ ( n + j ),p ] ) = 1)))));

now
let i;
per cases  by A80;
suppose (not ( 0 ) < i);

hence (not ((( 0 ) < i & ( v2 . [ ( n + i ),q ] ) = 1) & (for j holds ((1 <= j & j < i) implies ( v2 . [ ( n + j ),p ] ) = 1))));
end;
suppose (not ( v1 . [ ( n + i ),q ] ) = 1);

hence (not ((( 0 ) < i & ( v2 . [ ( n + i ),q ] ) = 1) & (for j holds ((1 <= j & j < i) implies ( v2 . [ ( n + j ),p ] ) = 1)))) by A73;
end;
suppose (not (for j holds ((1 <= j & j < i) implies ( v1 . [ ( n + j ),p ] ) = 1)));

then consider j such that A81: (1 <= j & j < i) and A82: (not ( v1 . [ ( n + j ),p ] ) = 1);
(not ( v2 . [ ( n + j ),p ] ) = 1) by A72,A82;
hence (not ((( 0 ) < i & ( v2 . [ ( n + i ),q ] ) = 1) & (for j holds ((1 <= j & j < i) implies ( v2 . [ ( n + j ),p ] ) = 1)))) by A81;
end;
end;
then A83: (not ( v2 . [ n,( p 'Us' q ) ] ) = 1) by A66;
(not ( v1 . [ n,( p 'Us' q ) ] ) = 1) by A65,A80;
then ( v1 . [ n,( p 'Us' q ) ] ) = ( 0 ) by XBOOLEAN:def 3;
hence ( v1 . [ n,( p 'Us' q ) ] ) = ( v2 . [ n,( p 'Us' q ) ] ) by A83,XBOOLEAN:def 3;
end;
end;

thus P1[ ( p => q ) ]
proof
let n being (Element of ( NAT ));
thus ( v1 . [ n,( p => q ) ] ) = ( ( v1 . [ n,p ] ) => ( v1 . [ n,q ] ) ) by A65
.= ( ( v2 . [ n,p ] ) => ( v1 . [ n,q ] ) ) by A72
.= ( ( v2 . [ n,p ] ) => ( v2 . [ n,q ] ) ) by A73
.= ( v2 . [ n,( p => q ) ] ) by A66;
end;

end;
now
let n being (Element of ( NAT ));
thus ( v1 . [ n,( TFALSUM ) ] ) = ( 0 ) by A65
.= ( v2 . [ n,( TFALSUM ) ] ) by A66;
end;
then A84: P1[ ( TFALSUM ) ];
A85: (for A holds P1[ A ]) from HILBERT2:sch 2(A84,A67,A71);
A86: (for x being (Element of [: ( NAT ),( LTLB_WFF ) :]) holds (x in ( dom v1 ) implies ( v1 . x ) = ( v2 . x )))
proof
let x being (Element of [: ( NAT ),( LTLB_WFF ) :]);
consider y,z being set such that A87: y in ( NAT ) and A88: z in ( LTLB_WFF ) and A89: x = [ y,z ] by ZFMISC_1:def 2;
reconsider y1 = y as (Element of ( NAT )) by A87;
assume x in ( dom v1 );
thus ( v1 . x ) = ( v2 . x ) by A85,A87,A88,A89;
reconsider z1 = z as (Element of ( LTLB_WFF )) by A88;
end;
( dom v1 ) = [: ( NAT ),( LTLB_WFF ) :] by FUNCT_2:def 1
.= ( dom v2 ) by FUNCT_2:def 1;
hence thesis by A86,PARTFUN1:5;
end;

end;
end;
