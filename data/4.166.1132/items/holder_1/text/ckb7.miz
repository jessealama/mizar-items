environ
vocabularies NUMBERS,REAL_1,XREAL_0,ORDINAL1,LIMFUNC1,XBOOLE_0,XXREAL_0,CARD_1,ARYTM_3,POWER,RELAT_1,PREPOWER,ARYTM_1,PARTFUN1,FUNCT_1,FDIFF_1,VALUED_1,SUBSET_1,TARSKI,XXREAL_1,ORDINAL2,SEQ_1,SERIES_1,VALUED_0,COMPLEX1,SEQ_2,XXREAL_2,NAT_1,FUNCT_2,FCONT_1,CARD_3;
notations TARSKI,XBOOLE_0,SUBSET_1,RELAT_1,PARTFUN1,FUNCT_2,LIMFUNC1,RCOMP_1,FCONT_1,XXREAL_0,XREAL_0,COMPLEX1,ORDINAL1,NUMBERS,REAL_1,NAT_1,VALUED_0,VALUED_1,SEQ_1,SEQ_2,SERIES_1,FDIFF_1,PREPOWER,POWER,TAYLOR_1,RECDEF_1;
definitions SUBSET_1,LIMFUNC1;
theorems XBOOLE_1,ABSVALUE,TARSKI,XBOOLE_0,XREAL_0,XCMPLX_1,RCOMP_1,SEQ_1,SEQ_2,SEQM_3,SERIES_1,FUNCT_1,NAT_1,POWER,FCONT_1,FDIFF_1,ROLLE,SEQ_4,PREPOWER,RELSET_1,FUNCT_2,TAYLOR_1,XREAL_1,COMPLEX1,XXREAL_0,PARTFUN1,ORDINAL1,VALUED_1,XXREAL_1,VALUED_0,RELAT_1,CKB2,CKB3,CKB4,CKB5,CKB6;
schemes SEQ_1,RECDEF_1,NAT_1,PARTFUN2;
registrations XBOOLE_0,ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,MEMBERED,RCOMP_1,VALUED_0,VALUED_1,FUNCT_2,SEQ_2,SEQ_4,FCONT_3,CKB1;
constructors PARTFUN1,REAL_1,NAT_1,INT_2,SEQ_2,SEQM_3,RCOMP_1,RFUNCT_2,FCONT_1,LIMFUNC1,FDIFF_1,PREPOWER,SERIES_1,TAYLOR_1,SEQ_1,VALUED_1,RECDEF_1,RELSET_1;
requirements SUBSET,REAL,BOOLE,NUMERALS,ARITHM;
begin
reserve a for Real;
theorem
Lm1: (for a being Real_Sequence holds ((for n being (Element of ( NAT )) holds ( 0 ) <= ( a . n )) implies (for n being (Element of ( NAT )) holds ( a . n ) <= ( ( Partial_Sums a ) . n ))))
proof
let a being Real_Sequence;
assume that
A1: (for n being (Element of ( NAT )) holds ( 0 ) <= ( a . n ));
defpred P[ (Element of ( NAT )) ]
 means
( a . $1 ) <= ( ( Partial_Sums a ) . $1 );
A2: (for n being (Element of ( NAT )) holds (P[ n ] implies P[ ( n + 1 ) ]))
proof
let n being (Element of ( NAT ));
assume P[ n ];
then A3: (( ( Partial_Sums a ) . ( n + 1 ) ) = ( ( ( Partial_Sums a ) . n ) + ( a . ( n + 1 ) ) ) & ( ( a . n ) + ( a . ( n + 1 ) ) ) <= ( ( ( Partial_Sums a ) . n ) + ( a . ( n + 1 ) ) )) by SERIES_1:def 1,XREAL_1:6;
( 0 ) <= ( a . n ) by A1;
then ( ( 0 ) + ( a . ( n + 1 ) ) ) <= ( ( a . n ) + ( a . ( n + 1 ) ) ) by XREAL_1:6;
hence thesis by A3,XXREAL_0:2;
end;
A4: P[ ( 0 ) ] by SERIES_1:def 1;
(for n being (Element of ( NAT )) holds P[ n ]) from NAT_1:sch 1(A4,A2);
hence thesis;
end;
