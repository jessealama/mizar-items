environ
vocabularies NUMBERS,REAL_1,XREAL_0,ORDINAL1,LIMFUNC1,XBOOLE_0,XXREAL_0,CARD_1,ARYTM_3,POWER,RELAT_1,PREPOWER,ARYTM_1,PARTFUN1,FUNCT_1,FDIFF_1,VALUED_1,SUBSET_1,TARSKI,XXREAL_1,ORDINAL2,SEQ_1,SERIES_1,VALUED_0,COMPLEX1,SEQ_2,XXREAL_2,NAT_1,FUNCT_2,FCONT_1,CARD_3;
notations TARSKI,XBOOLE_0,SUBSET_1,RELAT_1,PARTFUN1,FUNCT_2,LIMFUNC1,RCOMP_1,FCONT_1,XXREAL_0,XREAL_0,COMPLEX1,ORDINAL1,NUMBERS,REAL_1,NAT_1,VALUED_0,VALUED_1,SEQ_1,SEQ_2,SERIES_1,FDIFF_1,PREPOWER,POWER,TAYLOR_1,RECDEF_1;
definitions SUBSET_1,LIMFUNC1;
theorems XBOOLE_1,ABSVALUE,TARSKI,XBOOLE_0,XREAL_0,XCMPLX_1,RCOMP_1,SEQ_1,SEQ_2,SEQM_3,SERIES_1,FUNCT_1,NAT_1,POWER,FCONT_1,FDIFF_1,ROLLE,SEQ_4,PREPOWER,RELSET_1,FUNCT_2,TAYLOR_1,XREAL_1,COMPLEX1,XXREAL_0,PARTFUN1,ORDINAL1,VALUED_1,XXREAL_1,VALUED_0,RELAT_1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9;
schemes SEQ_1,RECDEF_1,NAT_1,PARTFUN2;
registrations XBOOLE_0,ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,MEMBERED,RCOMP_1,VALUED_0,VALUED_1,FUNCT_2,SEQ_2,SEQ_4,FCONT_3,CKB1;
constructors PARTFUN1,REAL_1,NAT_1,INT_2,SEQ_2,SEQM_3,RCOMP_1,RFUNCT_2,FCONT_1,LIMFUNC1,FDIFF_1,PREPOWER,SERIES_1,TAYLOR_1,SEQ_1,VALUED_1,RECDEF_1,RELSET_1;
requirements SUBSET,REAL,BOOLE,NUMERALS,ARITHM;
begin
reserve a for Real;
theorem
Lm4: (for a being Real_Sequence holds (for n being (Element of ( NAT )) holds ((for k being (Element of ( NAT )) holds (k <= n implies ( a . k ) = ( 0 ))) implies ( ( Partial_Sums a ) . n ) = ( 0 ))))
proof
let a being Real_Sequence;
defpred P[ (Element of ( NAT )) ]
 means
((for k being (Element of ( NAT )) holds (k <= $1 implies ( a . k ) = ( 0 ))) implies ( ( Partial_Sums a ) . $1 ) = ( 0 ));
A1: (for n being (Element of ( NAT )) holds (P[ n ] implies P[ ( n + 1 ) ]))
proof
let n being (Element of ( NAT ));
assume that
A2: P[ n ];
now
assume A3: (for k being (Element of ( NAT )) holds (k <= ( n + 1 ) implies ( a . k ) = ( 0 )));
A4:now
A5: n <= ( n + 1 ) by NAT_1:11;
let k being (Element of ( NAT ));
assume k <= n;
hence ( a . k ) = ( 0 ) by A3,A5,XXREAL_0:2;
end;
thus ( ( Partial_Sums a ) . ( n + 1 ) ) = ( ( ( Partial_Sums a ) . n ) + ( a . ( n + 1 ) ) ) by SERIES_1:def 1
.= ( 0 ) by A2,A3,A4;
end;
hence thesis;
end;
A6: P[ ( 0 ) ]
proof
assume (for k being (Element of ( NAT )) holds (k <= ( 0 ) implies ( a . k ) = ( 0 )));
then ( a . ( 0 ) ) = ( 0 );
hence thesis by SERIES_1:def 1;
end;
thus (for n being (Element of ( NAT )) holds P[ n ]) from NAT_1:sch 1(A6,A1);
end;
