environ
vocabularies MSUALG_1,GLIB_000,SUBSET_1,XBOOLE_0,UNIALG_2,STRUCT_0,RELAT_1,TARSKI,FUNCT_1,FUNCOP_1,PBOOLE,CARD_3,FINSEQ_1,MARGREL1,NAT_1,PARTFUN1,PRELAMB,MSAFREE,MSUALG_3,TREES_4,REALSET1,MSUALG_2,FINSET_1,PRALG_1,CARD_1,TREES_2,DTCONSTR,TREES_3,ZFMISC_1,LANG1,TDGROUP,TREES_1,MSAFREE2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NAT_1,CARD_1,RELAT_1,FUNCT_1,PARTFUN1,FINSET_1,FINSEQ_1,FUNCT_2,CARD_3,TREES_1,TREES_2,TREES_3,TREES_4,PBOOLE,STRUCT_0,MSUALG_1,FINSEQ_2,MSAFREE,MSUALG_2,FUNCOP_1,DTCONSTR,LANG1,PRE_POLY,RELSET_1,MSUALG_3,CKB1,CKB2,CKB3,CKB4,CKB9,CKB13,CKB14,CKB17,CKB19,CKB20,CKB22,CKB23;
definitions TARSKI,MSUALG_1,FINSET_1,MSUALG_2,FUNCT_1,STRUCT_0,PBOOLE,FUNCOP_1,CKB2,CKB3,CKB4,CKB9,CKB13,CKB14,CKB17,CKB19,CKB20,CKB22,CKB23;
theorems TARSKI,ZFMISC_1,FINSEQ_1,FINSEQ_3,FUNCT_1,FUNCT_2,TREES_3,TREES_4,SUBSET_1,CARD_3,FUNCOP_1,PBOOLE,MSUALG_1,MSUALG_2,MSAFREE,CARD_2,CARD_1,DTCONSTR,LANG1,PRE_CIRC,RELAT_1,RELSET_1,XBOOLE_0,XBOOLE_1,FINSET_1,PARTFUN1,FINSEQ_2,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB13,CKB14,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23;
schemes DOMAIN_1,PBOOLE,MSAFREE1,FUNCT_1;
registrations XBOOLE_0,FUNCT_1,RELSET_1,FUNCOP_1,FINSET_1,TREES_1,CARD_3,TREES_2,TREES_3,PRE_CIRC,STRUCT_0,DTCONSTR,RELAT_1,MSUALG_1,MSUALG_2,MSAFREE,ORDINAL1,PBOOLE,FINSEQ_1,CKB10,CKB11,CKB12,CKB15,CKB16,CKB24;
constructors XXREAL_0,NAT_1,MSUALG_3,MSAFREE,SEQ_4,RELSET_1,PRE_POLY,FINSEQ_2,CKB2,CKB3,CKB4,CKB9,CKB13,CKB14,CKB17,CKB19,CKB20,CKB22,CKB23;
requirements BOOLE,SUBSET;
begin
definition
let S being non  empty ManySortedSign;
func Trivial_Algebra S ->  strict MSAlgebra over S means 
:Def12: (the Sorts of it) = ( (the carrier of S) --> { ( 0 ) } );
existence
proof
reconsider f = ( (the carrier of S) --> { ( 0 ) } ) as (ManySortedSet of (the carrier of S));
set Ch = the (ManySortedFunction of ( ( f # ) * (the Arity of S) ),( f * (the ResultSort of S) ));
take MSAlgebra (# f,Ch #);
thus thesis;
end;
uniqueness
proof
let A1 being  strict MSAlgebra over S;
let A2 being  strict MSAlgebra over S;
assume that
A1: (the Sorts of A1) = ( (the carrier of S) --> { ( 0 ) } )
and
A2: (the Sorts of A2) = ( (the carrier of S) --> { ( 0 ) } );
set B = (the Sorts of A1);
A3: ( dom (the ResultSort of S) ) = (the carrier' of S) by FUNCT_2:def 1;
now
let i being set;
set A = ( ( B * (the ResultSort of S) ) . i );
assume A4: i in (the carrier' of S);
then A5: A = ( B . ( (the ResultSort of S) . i ) ) by A3,FUNCT_1:13
.= { ( 0 ) } by A1,A4,FUNCOP_1:7,FUNCT_2:5;
then reconsider A as non  empty set;
reconsider f1 = ( (the Charact of A1) . i ),f2 = ( (the Charact of A2) . i ) as (Function of ( ( ( B # ) * (the Arity of S) ) . i ),A) by A1,A2,A4,PBOOLE:def 15;
now
let x being set;
assume A6: x in ( ( ( B # ) * (the Arity of S) ) . i );
then ( f1 . x ) in A by FUNCT_2:5;
then A7: ( f1 . x ) = ( 0 ) by A5,TARSKI:def 1;
( f2 . x ) in A by A6,FUNCT_2:5;
hence ( f1 . x ) = ( f2 . x ) by A5,A7,TARSKI:def 1;
end;
hence ( (the Charact of A1) . i ) = ( (the Charact of A2) . i ) by FUNCT_2:12;
end;
hence thesis by A1,A2,PBOOLE:3;
end;
end;
