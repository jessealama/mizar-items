environ
vocabularies MSUALG_1,GLIB_000,SUBSET_1,XBOOLE_0,UNIALG_2,STRUCT_0,RELAT_1,TARSKI,FUNCT_1,FUNCOP_1,PBOOLE,CARD_3,FINSEQ_1,MARGREL1,NAT_1,PARTFUN1,PRELAMB,MSAFREE,MSUALG_3,TREES_4,REALSET1,MSUALG_2,FINSET_1,PRALG_1,CARD_1,TREES_2,DTCONSTR,TREES_3,ZFMISC_1,LANG1,TDGROUP,TREES_1,MSAFREE2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NAT_1,CARD_1,RELAT_1,FUNCT_1,PARTFUN1,FINSET_1,FINSEQ_1,FUNCT_2,CARD_3,TREES_1,TREES_2,TREES_3,TREES_4,PBOOLE,STRUCT_0,MSUALG_1,FINSEQ_2,MSAFREE,MSUALG_2,FUNCOP_1,DTCONSTR,LANG1,PRE_POLY,RELSET_1,MSUALG_3,CKB1,CKB2,CKB3,CKB4,CKB9,CKB13,CKB14,CKB17,CKB19,CKB20,CKB22,CKB23,CKB25,CKB27;
definitions TARSKI,MSUALG_1,FINSET_1,MSUALG_2,FUNCT_1,STRUCT_0,PBOOLE,FUNCOP_1,CKB2,CKB3,CKB4,CKB9,CKB13,CKB14,CKB17,CKB19,CKB20,CKB22,CKB23,CKB25,CKB27;
theorems TARSKI,ZFMISC_1,FINSEQ_1,FINSEQ_3,FUNCT_1,FUNCT_2,TREES_3,TREES_4,SUBSET_1,CARD_3,FUNCOP_1,PBOOLE,MSUALG_1,MSUALG_2,MSAFREE,CARD_2,CARD_1,DTCONSTR,LANG1,PRE_CIRC,RELAT_1,RELSET_1,XBOOLE_0,XBOOLE_1,FINSET_1,PARTFUN1,FINSEQ_2,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB13,CKB14,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB25,CKB27,CKB29;
schemes DOMAIN_1,PBOOLE,MSAFREE1,FUNCT_1;
registrations XBOOLE_0,FUNCT_1,RELSET_1,FUNCOP_1,FINSET_1,TREES_1,CARD_3,TREES_2,TREES_3,PRE_CIRC,STRUCT_0,DTCONSTR,RELAT_1,MSUALG_1,MSUALG_2,MSAFREE,ORDINAL1,PBOOLE,FINSEQ_1,CKB10,CKB11,CKB12,CKB15,CKB16,CKB24,CKB26,CKB28;
constructors XXREAL_0,NAT_1,MSUALG_3,MSAFREE,SEQ_4,RELSET_1,PRE_POLY,FINSEQ_2,CKB2,CKB3,CKB4,CKB9,CKB13,CKB14,CKB17,CKB19,CKB20,CKB22,CKB23,CKB25,CKB27;
requirements BOOLE,SUBSET;
begin
theorem
(for S being non  void non  empty ManySortedSign holds (for X being  non-empty  finite-yielding (ManySortedSet of (the carrier of S)) holds ( FreeMSA X ) is  finitely-generated))
proof
let S being non  void non  empty ManySortedSign;
let X being  non-empty  finite-yielding (ManySortedSet of (the carrier of S));
per cases ;
case S is non  void;
reconsider G = ( FreeGen X ) as (GeneratorSet of ( FreeMSA X ));
let S9 being non  void non  empty ManySortedSign;
assume that
A1: S9 = S;
let A being MSAlgebra over S9;
assume A = ( FreeMSA X );
then reconsider G as (GeneratorSet of A) by A1;
take G;
thus G is  finite-yielding
proof
let i being set;
reconsider Gi = ( G . i ) as set;
assume i in (the carrier of S9);
then reconsider iS = i as (SortSymbol of S) by A1;
reconsider Xi = ( X . iS ) as non  empty  finite set by FINSET_1:def 4;
now
defpred P[ set,set ]
 means
$1 = ( root-tree [ $2,i ] );
A2: (for e being set holds (e in Gi implies (ex u being set st (u in Xi & P[ e,u ]))))
proof
A3: Gi = ( FreeGen (iS,X) ) by MSAFREE:def 16;
let e being set;
assume e in Gi;
then consider u being set such that A4: (u in Xi & e = ( root-tree [ u,i ] )) by A3,MSAFREE:def 15;
take u;
thus thesis by A4;
end;
consider f being Function such that A5: ( dom f ) = Gi and A6: ( rng f ) c= Xi and A7: (for e being set holds (e in Gi implies P[ e,( f . e ) ])) from FUNCT_1:sch 5(A2);
take f;
f is  one-to-one
proof
let x1 being set;
let x2 being set;
assume that
A8: x1 in ( dom f )
and
A9: x2 in ( dom f )
and
A10: ( f . x1 ) = ( f . x2 );
thus x1 = ( root-tree [ ( f . x2 ),i ] ) by A5,A7,A8,A10
.= x2 by A5,A7,A9;
end;
hence (ex f being Function st ((f is  one-to-one & ( dom f ) = Gi) & ( rng f ) c= Xi)) by A5,A6;
end;
then (( card Gi ) c= ( card Xi ) or ( card Gi ) in ( card Xi )) by CARD_1:10;
hence thesis by CARD_2:49;
end;

end;
case S is  void;
hence thesis;
end;
end;
