environ
vocabularies MSUALG_1,GLIB_000,SUBSET_1,XBOOLE_0,UNIALG_2,STRUCT_0,RELAT_1,TARSKI,FUNCT_1,FUNCOP_1,PBOOLE,CARD_3,FINSEQ_1,MARGREL1,NAT_1,PARTFUN1,PRELAMB,MSAFREE,MSUALG_3,TREES_4,REALSET1,MSUALG_2,FINSET_1,PRALG_1,CARD_1,TREES_2,DTCONSTR,TREES_3,ZFMISC_1,LANG1,TDGROUP,TREES_1,MSAFREE2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NAT_1,CARD_1,RELAT_1,FUNCT_1,PARTFUN1,FINSET_1,FINSEQ_1,FUNCT_2,CARD_3,TREES_1,TREES_2,TREES_3,TREES_4,PBOOLE,STRUCT_0,MSUALG_1,FINSEQ_2,MSAFREE,MSUALG_2,FUNCOP_1,DTCONSTR,LANG1,PRE_POLY,RELSET_1,MSUALG_3,CKB1,CKB2,CKB3,CKB4,CKB9;
definitions TARSKI,MSUALG_1,FINSET_1,MSUALG_2,FUNCT_1,STRUCT_0,PBOOLE,FUNCOP_1,CKB2,CKB3,CKB4,CKB9;
theorems TARSKI,ZFMISC_1,FINSEQ_1,FINSEQ_3,FUNCT_1,FUNCT_2,TREES_3,TREES_4,SUBSET_1,CARD_3,FUNCOP_1,PBOOLE,MSUALG_1,MSUALG_2,MSAFREE,CARD_2,CARD_1,DTCONSTR,LANG1,PRE_CIRC,RELAT_1,RELSET_1,XBOOLE_0,XBOOLE_1,FINSET_1,PARTFUN1,FINSEQ_2,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9;
schemes DOMAIN_1,PBOOLE,MSAFREE1,FUNCT_1;
registrations XBOOLE_0,FUNCT_1,RELSET_1,FUNCOP_1,FINSET_1,TREES_1,CARD_3,TREES_2,TREES_3,PRE_CIRC,STRUCT_0,DTCONSTR,RELAT_1,MSUALG_1,MSUALG_2,MSAFREE,ORDINAL1,PBOOLE,FINSEQ_1,CKB10,CKB11,CKB12;
constructors XXREAL_0,NAT_1,MSUALG_3,MSAFREE,SEQ_4,RELSET_1,PRE_POLY,FINSEQ_2,CKB2,CKB3,CKB4,CKB9;
requirements BOOLE,SUBSET;
begin
definition
let S being non  empty ManySortedSign;
let MSA being  non-empty MSAlgebra over S;
mode InputValues of MSA
 -> (ManySortedSet of ( InputVertices S ))
means (for v being (Vertex of S) holds (v in ( InputVertices S ) implies ( it . v ) in ( (the Sorts of MSA) . v )));
existence
proof
set e = the (Element of ( product (the Sorts of MSA) ));
set p = ( e | ( InputVertices S ) );
A1: (( dom (the Sorts of MSA) ) = (the carrier of S) & (ex g being Function st ((e = g & ( dom g ) = ( dom (the Sorts of MSA) )) & (for x being set holds (x in ( dom (the Sorts of MSA) ) implies ( g . x ) in ( (the Sorts of MSA) . x )))))) by CARD_3:def 5,PARTFUN1:def 2;
reconsider p as (ManySortedSet of ( InputVertices S ));
take p;
let v being (Vertex of S);
assume v in ( InputVertices S );
then ( p . v ) = ( e . v ) by FUNCT_1:49;
hence thesis by A1;
end;
end;
