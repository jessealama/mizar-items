environ
vocabularies INT_1,ABIAN,ARYTM_1,ZFMISC_1,FUNCT_1,RELAT_1,TARSKI,FUNCOP_1,FUNCT_2,FUNCT_6,XBOOLE_0,PBOOLE,SUBSET_1,NUMBERS,NAT_1,HILBERT1,CARD_1,FUNCT_3,CARD_3,MCART_1,PARTFUN1,FINSEQ_4,XBOOLEAN,QC_LANG1,HILBERT2,FUNCT_5,ARYTM_3,FUNCT_4,XXREAL_0,HILBERT3,XCMPLX_0;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,XCMPLX_0,INT_1,RELAT_1,FUNCT_1,PBOOLE,CARD_3,ABIAN,PARTFUN1,FUNCT_2,BINOP_1,NAT_1,XXREAL_0,FUNCT_3,FUNCOP_1,FUNCT_4,FUNCT_5,FUNCT_6,PRALG_1,PRALG_2,MSUALG_3,HILBERT1,HILBERT2,CKB29,CKB34,CKB35,CKB36,CKB46;
definitions PBOOLE,FUNCT_1,FUNCT_2,TARSKI,HILBERT1,ABIAN,FUNCOP_1,RELAT_1,XBOOLE_0,BINOP_1,SUBSET_1,CKB29,CKB35,CKB36,CKB46;
theorems PBOOLE,ZFMISC_1,MSUALG_3,FUNCT_2,RELAT_1,RELSET_1,FUNCT_1,FUNCT_3,TARSKI,FUNCOP_1,PARTFUN2,PRALG_2,CARD_3,FUNCT_6,MSSUBFAM,FUNCT_5,FUNCTOR0,CAT_2,HILBERT1,FUNCT_4,INT_1,TOPREAL6,PRALG_1,XBOOLE_0,XBOOLE_1,XCMPLX_1,ABIAN,XREAL_1,XXREAL_0,CARD_1,PARTFUN1,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB31,CKB32,CKB33,CKB35,CKB36,CKB38,CKB39,CKB40,CKB41,CKB46;
schemes HILBERT2,FUNCT_2;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,PARTFUN1,FUNCT_2,FUNCOP_1,FUNCT_4,NUMBERS,XREAL_0,INT_1,PBOOLE,ABIAN,HILBERT1,FUNCT_7,RELSET_1,ZFMISC_1,MSSUBFAM,CKB1,CKB2,CKB18,CKB30,CKB37,CKB42,CKB43,CKB44,CKB45;
constructors XXREAL_0,NAT_D,REALSET1,MSSUBFAM,ABIAN,CAT_2,PRALG_1,PRALG_2,MSUALG_3,HILBERT2,RELSET_1,CKB29,CKB35,CKB36,CKB46;
requirements NUMERALS,BOOLE,SUBSET;
begin
reserve n for (Element of ( NAT ));
reserve p for (Element of ( HP-WFF ));
reserve q for (Element of ( HP-WFF ));
reserve r for (Element of ( HP-WFF ));
reserve s for (Element of ( HP-WFF ));
reserve V for SetValuation;
reserve P for (Permutation of V);
definition
let V;
let P;
func Perm P -> (ManySortedFunction of ( SetVal V ),( SetVal V ))
means
:Def5: ((( it . ( VERUM ) ) = ( id 1 ) & (for n holds ( it . ( prop n ) ) = ( P . n ))) & (for p holds (for q holds (ex p9 being (Permutation of ( SetVal (V,p) )) st (ex q9 being (Permutation of ( SetVal (V,q) )) st (((p9 = ( it . p ) & q9 = ( it . q )) & ( it . ( p '&' q ) ) = [: p9,q9 :]) & ( it . ( p => q ) ) = ( p9 => q9 )))))));
existence
proof
deffunc F((Element of ( NAT ))) = ( P . $1 );
defpred I[ (Element of ( HP-WFF )),(Element of ( HP-WFF )),set,set,set ]
 means
((($3 is (Permutation of ( SetVal (V,$1) )) & $4 is (Permutation of ( SetVal (V,$2) ))) implies (ex p9 being (Permutation of ( SetVal (V,$1) )) st (ex q9 being (Permutation of ( SetVal (V,$2) )) st ((p9 = $3 & q9 = $4) & $5 = ( p9 => q9 ))))) & (((not $3 is (Permutation of ( SetVal (V,$1) ))) or (not $4 is (Permutation of ( SetVal (V,$2) )))) implies $5 = ( {} )));
defpred C[ (Element of ( HP-WFF )),(Element of ( HP-WFF )),set,set,set ]
 means
((($3 is (Permutation of ( SetVal (V,$1) )) & $4 is (Permutation of ( SetVal (V,$2) ))) implies (ex p9 being (Permutation of ( SetVal (V,$1) )) st (ex q9 being (Permutation of ( SetVal (V,$2) )) st ((p9 = $3 & q9 = $4) & $5 = [: p9,q9 :])))) & (((not $3 is (Permutation of ( SetVal (V,$1) ))) or (not $4 is (Permutation of ( SetVal (V,$2) )))) implies $5 = ( {} )));
A1: (for p holds (for q holds (for a,b being set holds (ex c being set st C[ p,q,a,b,c ]))))
proof
let p;
let q;
let a being set,b being set;
per cases ;
suppose that A2: a is (Permutation of ( SetVal (V,p) ))
and
A3: b is (Permutation of ( SetVal (V,q) ));
reconsider q9 = b as (Permutation of ( SetVal (V,q) )) by A3;
reconsider p9 = a as (Permutation of ( SetVal (V,p) )) by A2;
take [: p9,q9 :];
thus thesis;
end;
suppose ((not a is (Permutation of ( SetVal (V,p) ))) or (not b is (Permutation of ( SetVal (V,q) ))));

hence thesis;
end;
end;
A4: (for p holds (for q holds (for a,b being set holds (ex d being set st I[ p,q,a,b,d ]))))
proof
let p;
let q;
let a being set,b being set;
per cases ;
suppose that A5: a is (Permutation of ( SetVal (V,p) ))
and
A6: b is (Permutation of ( SetVal (V,q) ));
reconsider q9 = b as (Permutation of ( SetVal (V,q) )) by A6;
reconsider p9 = a as (Permutation of ( SetVal (V,p) )) by A5;
take ( p9 => q9 );
thus thesis;
end;
suppose ((not a is (Permutation of ( SetVal (V,p) ))) or (not b is (Permutation of ( SetVal (V,q) ))));

hence thesis;
end;
end;
A7: (for p holds (for q holds (for a,b,c,d being set holds ((I[ p,q,a,b,c ] & I[ p,q,a,b,d ]) implies c = d))));
A8: (for p holds (for q holds (for a,b,c,d being set holds ((C[ p,q,a,b,c ] & C[ p,q,a,b,d ]) implies c = d))));
consider M being (ManySortedSet of ( HP-WFF )) such that A9: ( M . ( VERUM ) ) = ( id 1 ) and A10: (for n holds ( M . ( prop n ) ) = F(n)) and A11: (for p holds (for q holds (C[ p,q,( M . p ),( M . q ),( M . ( p '&' q ) ) ] & I[ p,q,( M . p ),( M . q ),( M . ( p => q ) ) ]))) from HILBERT2:sch 3(A1,A4,A8,A7);
defpred P[ (Element of ( HP-WFF )) ]
 means
( M . $1 ) is (Permutation of ( ( SetVal V ) . $1 ));
A12: (for r holds (for s holds ((P[ r ] & P[ s ]) implies (P[ ( r '&' s ) ] & P[ ( r => s ) ]))))
proof
let r;
let s;
assume that
A13: (( M . r ) is (Permutation of ( ( SetVal V ) . r )) & ( M . s ) is (Permutation of ( ( SetVal V ) . s )));
A14: ( ( SetVal V ) . ( r '&' s ) ) = [: ( SetVal (V,r) ),( SetVal (V,s) ) :] by CKB35:def 1;
(ex p9 being (Permutation of ( SetVal (V,r) )) st (ex q9 being (Permutation of ( SetVal (V,s) )) st ((p9 = ( M . r ) & q9 = ( M . s )) & ( M . ( r '&' s ) ) = [: p9,q9 :]))) by A11,A13;
hence ( M . ( r '&' s ) ) is (Permutation of ( ( SetVal V ) . ( r '&' s ) )) by A14,CKB28:1;
A15: ( ( SetVal V ) . ( r => s ) ) = ( Funcs (( SetVal (V,r) ),( SetVal (V,s) )) ) by CKB35:def 1;
(ex p9 being (Permutation of ( SetVal (V,r) )) st (ex q9 being (Permutation of ( SetVal (V,s) )) st ((p9 = ( M . r ) & q9 = ( M . s )) & ( M . ( r => s ) ) = ( p9 => q9 )))) by A11,A13;
hence thesis by A15;
end;
take M;
A16: (for n holds P[ ( prop n ) ])
proof
let n;
(( M . ( prop n ) ) = ( P . n ) & ( ( SetVal V ) . ( prop n ) ) = ( V . n )) by A10,CKB35:def 1;
hence thesis by CKB46:def 1;
end;
( ( SetVal V ) . ( VERUM ) ) = 1 by CKB35:def 1;
then A17: P[ ( VERUM ) ] by A9;
A18: (for p holds P[ p ]) from HILBERT2:sch 2(A17,A16,A12);
thus M is (ManySortedFunction of ( SetVal V ),( SetVal V ))
proof
let p being set;
thus thesis by A18;
end;

thus ( M . ( VERUM ) ) = ( id 1 ) by A9;
thus (for n holds ( M . ( prop n ) ) = ( P . n )) by A10;
let p;
let q;
A19: (( M . p ) is (Permutation of ( ( SetVal V ) . p )) & ( M . q ) is (Permutation of ( ( SetVal V ) . q ))) by A18;
then consider p9 being (Permutation of ( SetVal (V,p) )),q9 being (Permutation of ( SetVal (V,q) )) such that A20: (p9 = ( M . p ) & q9 = ( M . q )) and A21: ( M . ( p '&' q ) ) = [: p9,q9 :] by A11;
take p9;
take q9;
thus ((p9 = ( M . p ) & q9 = ( M . q )) & ( M . ( p '&' q ) ) = [: p9,q9 :]) by A20,A21;
(ex p9 being (Permutation of ( SetVal (V,p) )) st (ex q9 being (Permutation of ( SetVal (V,q) )) st ((p9 = ( M . p ) & q9 = ( M . q )) & ( M . ( p => q ) ) = ( p9 => q9 )))) by A11,A19;
hence ( M . ( p => q ) ) = ( p9 => q9 ) by A20;
end;
uniqueness
proof
let M1 being (ManySortedFunction of ( SetVal V ),( SetVal V )),M2 being (ManySortedFunction of ( SetVal V ),( SetVal V ));
assume that
A22: ( M1 . ( VERUM ) ) = ( id 1 )
and
A23: (for n holds ( M1 . ( prop n ) ) = ( P . n ))
and
A24: (for p holds (for q holds (ex p9 being (Permutation of ( SetVal (V,p) )) st (ex q9 being (Permutation of ( SetVal (V,q) )) st (((p9 = ( M1 . p ) & q9 = ( M1 . q )) & ( M1 . ( p '&' q ) ) = [: p9,q9 :]) & ( M1 . ( p => q ) ) = ( p9 => q9 ))))))
and
A25: ( M2 . ( VERUM ) ) = ( id 1 )
and
A26: (for n holds ( M2 . ( prop n ) ) = ( P . n ))
and
A27: (for p holds (for q holds (ex p9 being (Permutation of ( SetVal (V,p) )) st (ex q9 being (Permutation of ( SetVal (V,q) )) st (((p9 = ( M2 . p ) & q9 = ( M2 . q )) & ( M2 . ( p '&' q ) ) = [: p9,q9 :]) & ( M2 . ( p => q ) ) = ( p9 => q9 ))))));
defpred P[ (Element of ( HP-WFF )) ]
 means
( M1 . $1 ) = ( M2 . $1 );
A28: (for n holds P[ ( prop n ) ])
proof
let n;
thus ( M1 . ( prop n ) ) = ( P . n ) by A23
.= ( M2 . ( prop n ) ) by A26;
end;
A29: (for r holds (for s holds ((P[ r ] & P[ s ]) implies (P[ ( r '&' s ) ] & P[ ( r => s ) ]))))
proof
let r;
let s;
assume that
A30: (( M1 . r ) = ( M2 . r ) & ( M1 . s ) = ( M2 . s ));
A31: ((ex p9 being (Permutation of ( SetVal (V,r) )) st (ex q9 being (Permutation of ( SetVal (V,s) )) st (((p9 = ( M1 . r ) & q9 = ( M1 . s )) & ( M1 . ( r '&' s ) ) = [: p9,q9 :]) & ( M1 . ( r => s ) ) = ( p9 => q9 )))) & (ex p9 being (Permutation of ( SetVal (V,r) )) st (ex q9 being (Permutation of ( SetVal (V,s) )) st (((p9 = ( M2 . r ) & q9 = ( M2 . s )) & ( M2 . ( r '&' s ) ) = [: p9,q9 :]) & ( M2 . ( r => s ) ) = ( p9 => q9 ))))) by A24,A27;
hence ( M1 . ( r '&' s ) ) = ( M2 . ( r '&' s ) ) by A30;
thus thesis by A30,A31;
end;
A32: P[ ( VERUM ) ] by A22,A25;
(for r holds P[ r ]) from HILBERT2:sch 2(A32,A28,A29);
then (for r being set holds (r in ( HP-WFF ) implies ( M1 . r ) = ( M2 . r )));
hence M1 = M2 by PBOOLE:3;
end;
end;
