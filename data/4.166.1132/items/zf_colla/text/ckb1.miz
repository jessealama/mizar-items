environ
vocabularies XBOOLE_0,ORDINAL1,FUNCT_1,SUBSET_1,RELAT_1,TARSKI,ZF_LANG,ZF_MODEL,BVFUNC_2,CARD_1,XBOOLEAN,FUNCT_4,ARYTM_3,ZF_COLLA;
notations TARSKI,XBOOLE_0,SUBSET_1,XCMPLX_0,RELAT_1,FUNCT_1,ZF_LANG,NUMBERS,FUNCT_2,FUNCT_7,ORDINAL1,ZF_MODEL;
definitions TARSKI,ORDINAL1,XBOOLE_0;
theorems TARSKI,FUNCT_1,ZF_LANG,ZF_MODEL,ORDINAL1,ZFMISC_1,RELAT_1,XBOOLE_0,FUNCT_7;
schemes TARSKI,CLASSES1,ORDINAL1,XBOOLE_0;
registrations XBOOLE_0,FUNCT_1,ORDINAL1,MEMBERED,ZF_LANG,RELSET_1;
constructors NAT_1,MEMBERED,ZF_MODEL,FUNCT_7;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve x for set;
reserve E for non  empty set;
reserve A for Ordinal;
reserve B for Ordinal;
reserve C for Ordinal;
reserve L for T-Sequence;
reserve L1 for T-Sequence;
reserve d for (Element of E);
reserve d1 for (Element of E);
definition
let E;
let A;
func Collapse (E,A) -> set means 
:Def1: (ex L st ((it = { d: (for d1 holds (d1 in d implies (ex B st (B in ( dom L ) & d1 in ( union { ( L . B ) } ))))) } & ( dom L ) = A) & (for B holds (B in A implies ( L . B ) = { d1: (for d holds (d in d1 implies (ex C st (C in ( dom ( L | B ) ) & d in ( union { ( ( L | B ) . C ) } ))))) }))));
existence
proof
deffunc H(T-Sequence) = { d: (for d1 holds (d1 in d implies (ex C st (C in ( dom $1 ) & d1 in ( union { ( $1 . C ) } ))))) };
consider L such that A1: ( dom L ) = A and A2: (for B holds (for L1 holds ((B in A & L1 = ( L | B )) implies ( L . B ) = H(L1)))) from ORDINAL1:sch 4;
take x = { d: (for d1 holds (d1 in d implies (ex B st (B in ( dom L ) & d1 in ( union { ( L . B ) } ))))) };
take L;
thus x = { d: (for d1 holds (d1 in d implies (ex B st (B in ( dom L ) & d1 in ( union { ( L . B ) } ))))) };
thus ( dom L ) = A by A1;
let B;
assume B in A;
hence thesis by A2;
end;
uniqueness
proof
deffunc H(T-Sequence) = { d: (for d1 holds (d1 in d implies (ex C st (C in ( dom $1 ) & d1 in ( union { ( $1 . C ) } ))))) };
let X1 being set;
let X2 being set;
given L such that
A3: ((X1 = { d: (for d1 holds (d1 in d implies (ex B st (B in ( dom L ) & d1 in ( union { ( L . B ) } ))))) } & ( dom L ) = A) & (for B holds (B in A implies ( L . B ) = { d1: (for d holds (d in d1 implies (ex C st (C in ( dom ( L | B ) ) & d in ( union { ( ( L | B ) . C ) } ))))) })));

A4: (( dom L ) = A & (for B holds (for L1 holds ((B in A & L1 = ( L | B )) implies ( L . B ) = H(L1))))) by A3;
given L1 such that
A5: ((X2 = { d: (for d1 holds (d1 in d implies (ex B st (B in ( dom L1 ) & d1 in ( union { ( L1 . B ) } ))))) } & ( dom L1 ) = A) & (for B holds (B in A implies ( L1 . B ) = { d1: (for d holds (d in d1 implies (ex C st (C in ( dom ( L1 | B ) ) & d in ( union { ( ( L1 | B ) . C ) } ))))) })));

A6: (( dom L1 ) = A & (for B holds (for L holds ((B in A & L = ( L1 | B )) implies ( L1 . B ) = H(L))))) by A5;
L = L1 from ORDINAL1:sch 3(A4,A6);
hence thesis by A3,A5;
end;
end;
