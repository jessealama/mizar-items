environ
vocabularies XBOOLE_0,SUBSET_1,FUNCT_1,PARTFUN1,RELAT_1,ZFMISC_1,FUNCOP_1,TARSKI,NAT_1,FINSEQ_1,FINSEQ_2,ORDINAL4,ARYTM_3,CARD_1,BINOP_1,SETWISEO,FINSEQOP;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,XCMPLX_0,NAT_1,RELAT_1,EQREL_1,FUNCT_1,FINSEQ_1,RELSET_1,PARTFUN1,FUNCT_2,BINOP_1,FUNCT_3,FUNCOP_1,FINSEQ_2,SETWISEO,CKB8,CKB9,CKB10,CKB11,CKB12;
definitions BINOP_1,FUNCOP_1,FINSEQ_2;
theorems ZFMISC_1,FUNCT_1,FUNCT_2,FUNCOP_1,FINSEQ_1,BINOP_1,SETWISEO,FINSEQ_2,FUNCT_3,RELAT_1,XBOOLE_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB13;
schemes NAT_1,FINSEQ_2;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,FUNCOP_1,NAT_1,FINSEQ_2,ORDINAL1,XCMPLX_0,FINSEQ_1,CARD_1,RELSET_1;
constructors PARTFUN1,BINOP_1,FUNCT_3,FUNCOP_1,SETWISEO,NAT_1,FINSEQ_2,RELSET_1,EQREL_1,CKB8,CKB9,CKB10,CKB11,CKB12;
requirements NUMERALS,BOOLE,SUBSET;
begin
reserve D for non  empty set;
reserve E for non  empty set;
reserve d for (Element of D);
reserve p for (FinSequence of D);
reserve q for (FinSequence of D);
reserve h for (Function of D,E);
theorem
( h * ( p ^ q ) ) = ( ( h * p ) ^ ( h * q ) )
proof
defpred P[ (FinSequence of D) ]
 means
( h * ( p ^ $1 ) ) = ( ( h * p ) ^ ( h * $1 ) );
A1: (for q holds (for d holds (P[ q ] implies P[ ( q ^ <* d *> ) ])))
proof
let q;
let d;
assume that
A2: ( h * ( p ^ q ) ) = ( ( h * p ) ^ ( h * q ) );
thus ( h * ( p ^ ( q ^ <* d *> ) ) ) = ( h * ( ( p ^ q ) ^ <* d *> ) ) by FINSEQ_1:32
.= ( ( h * ( p ^ q ) ) ^ <* ( h . d ) *> ) by CKB13:1
.= ( ( h * p ) ^ ( ( h * q ) ^ <* ( h . d ) *> ) ) by A2,FINSEQ_1:32
.= ( ( h * p ) ^ ( h * ( q ^ <* d *> ) ) ) by CKB13:1;
end;
( h * ( p ^ ( <*> D ) ) ) = ( h * p ) by FINSEQ_1:34
.= ( ( h * p ) ^ ( h * ( <*> D ) ) ) by FINSEQ_1:34;
then A3: P[ ( <*> D ) ];
(for q holds P[ q ]) from FINSEQ_2:sch 2(A3,A1);
hence thesis;
end;
