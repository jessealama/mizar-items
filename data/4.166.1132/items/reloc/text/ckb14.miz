environ
vocabularies SUBSET_1,NUMBERS,AMI_1,AMI_3,AMISTD_2,ARYTM_3,GRAPHSP,CARD_1,RELAT_1,FUNCT_1,TARSKI,FUNCT_4,XBOOLE_0,FSM_1,CIRCUIT2,SCMNORM,ARYTM_1,INT_1,XXREAL_0,STRUCT_0,ORDINAL1,RELOC,FINSET_1,FINSEQ_1,NAT_1,AMISTD_5,PBOOLE,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,FINSET_1,NUMBERS,XCMPLX_0,INT_1,NAT_1,VALUED_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_4,PBOOLE,FINSEQ_1,NAT_D,STRUCT_0,MEMSTR_0,COMPOS_1,EXTPRO_1,AMI_3,XXREAL_0,AMISTD_2,AMISTD_5;
definitions FUNCOP_1,COMPOS_1,EXTPRO_1,RELAT_1,TARSKI,AMI_3,AMISTD_2,FUNCT_1,AMISTD_5,MEMSTR_0;
theorems AMI_3,GRFUNC_1,NAT_1,TARSKI,FUNCT_4,FUNCT_1,AMI_5,RELAT_1,XBOOLE_1,PARTFUN1,VALUED_1,RECDEF_2,FINSEQ_1,COMPOS_1,EXTPRO_1,ORDINAL1,AMISTD_2,AMISTD_5,STRUCT_0,MEMSTR_0,CKB6,CKB7,CKB8,CKB9,CKB10,CKB12,CKB13;
schemes NAT_1;
registrations XBOOLE_0,SETFAM_1,FUNCT_1,ORDINAL1,RELSET_1,NUMBERS,XREAL_0,INT_1,CARD_3,AMI_3,RELAT_1,FUNCT_4,GRFUNC_1,FUNCT_2,AMI_6,VALUED_0,AMISTD_2,COMPOS_1,EXTPRO_1,NAT_1,FINSEQ_1,AMISTD_5,AMI_5,PBOOLE,MEMSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB11;
constructors DOMAIN_1,XXREAL_0,AMI_3,NAT_D,PRE_POLY,RECDEF_2,AMISTD_2,VALUED_1,AMI_2,AMISTD_1,AMISTD_5,PBOOLE,MEMSTR_0,RELSET_1;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
registration
cluster ( SCM ) ->  relocable1  relocable2;
coherence
proof
thus ( SCM ) is  relocable1
proof
thus (for k being (Element of ( NAT )) holds (for q being non halt-free  finite (the Instructions of ( SCM )) -valued ( NAT ) -defined Function holds (for p being q -autonomic non empty (FinPartState of ( SCM )) holds (for s1,s2 being (State of ( SCM )) holds (((( IC ( SCM ) ) in ( dom p ) & p c= s1) & ( IncIC (p,k) ) c= s2) implies (for P1,P2 being (Instruction-Sequence of ( SCM )) holds ((q c= P1 & ( Reloc (q,k) ) c= P2) implies (for i being (Element of ( NAT )) holds ( IncAddr (( CurInstr (P1,( Comput (P1,s1,i) )) ),k) ) = ( CurInstr (P2,( Comput (P2,s2,i) )) ))))))))) by CKB12:1;
end;

let k being (Element of ( NAT ));
let q being non halt-free  finite (the Instructions of ( SCM )) -valued ( NAT ) -defined Function;
let p being q -autonomic non empty (FinPartState of ( SCM ));
let s1 being (State of ( SCM )),s2 being (State of ( SCM ));
assume A1: ((( IC ( SCM ) ) in ( dom p ) & p c= s1) & ( IncIC (p,k) ) c= s2);
let P1 being (Instruction-Sequence of ( SCM )),P2 being (Instruction-Sequence of ( SCM ));
assume that
A2: (q c= P1 & ( Reloc (q,k) ) c= P2);
thus (for i being (Element of ( NAT )) holds ( ( Comput (P1,s1,i) ) | ( dom ( DataPart p ) ) ) = ( ( Comput (P2,s2,i) ) | ( dom ( DataPart p ) ) )) by A1,CKB12:1,A2;
end;
end;
