environ
vocabularies NUMBERS,REAL_1,SUBSET_1,FINSEQ_1,INTEGRA1,XREAL_0,ORDINAL1,SEQ_4,XXREAL_0,XXREAL_1,VALUED_0,RELAT_1,ARYTM_3,FUNCT_1,CARD_1,NAT_1,CLASSES1,FINSEQ_5,ARYTM_1,ORDINAL4,XBOOLE_0,JORDAN3,MEMBERED,MEMBER_1,TARSKI,PARTFUN1,XXREAL_2,VALUED_1,MEASURE7,CARD_3,SEQ_1,INTEGRA2,MEASURE5;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,CARD_1,NUMBERS,XXREAL_0,XREAL_0,XXREAL_2,XXREAL_3,MEMBERED,MEMBER_1,REAL_1,NAT_1,RELAT_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,FINSEQ_1,RFUNCT_1,RVSUM_1,INTEGRA1,VALUED_1,SEQ_1,SEQ_2,SEQ_4,FINSEQ_6,RCOMP_1,FINSEQ_5,CLASSES1,RFINSEQ,MEASURE5,MEASURE6,CKB2;
definitions TARSKI,XBOOLE_0,VALUED_1,RELAT_1,MEMBER_1,XXREAL_2,XXREAL_3,CKB2;
theorems SEQ_4,SUBSET_1,PARTFUN1,INTEGRA1,RFUNCT_1,FUNCT_1,FINSEQ_1,RVSUM_1,NEWTON,RCOMP_1,NAT_1,RFINSEQ,CARD_1,FINSEQ_5,FINSEQ_3,RELAT_1,FUNCT_2,XREAL_0,XBOOLE_0,XBOOLE_1,XCMPLX_1,XREAL_1,XXREAL_0,ORDINAL1,MEMBERED,VALUED_1,XXREAL_2,TARSKI,SEQM_3,CLASSES1,FINSEQ_6,MEMBER_1,XXREAL_3,CKB1,CKB2;
schemes SUBSET_1,SEQ_1,NAT_1;
registrations RELAT_1,ORDINAL1,FUNCT_2,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,MEMBERED,FINSEQ_1,RFINSEQ,INTEGRA1,VALUED_0,VALUED_1,XXREAL_2,CARD_1,SEQ_2,RELSET_1,XXREAL_3,MEMBER_1,MEASURE5,CKB3;
constructors PARTFUN1,REAL_1,NAT_1,SEQM_3,RFUNCT_1,RFINSEQ,BINARITH,FINSEQ_5,FINSEQ_6,INTEGRA1,SEQ_1,XXREAL_2,NAT_D,RVSUM_1,SEQ_4,CLASSES1,RELSET_1,SEQ_2,MEMBER_1,MEASURE6,CKB2;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve i for (Element of ( NAT ));
reserve j for (Element of ( NAT ));
reserve k for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
reserve p for (FinSequence of ( REAL ));
theorem
(for p being  non-decreasing (FinSequence of ( REAL )) holds (for i holds (for j holds (((i in ( dom p ) & j in ( dom p )) & i <= j) implies ( p . i ) <= ( p . j )))))
proof
let p being  non-decreasing (FinSequence of ( REAL ));
let i;
let j;
assume A1: i in ( dom p );
defpred P[ (Element of ( NAT )) ]
 means
(for i holds (for j holds (((j = ( i + $1 ) & i in ( dom p )) & j in ( dom p )) implies ( p . i ) <= ( p . j ))));
assume A2: j in ( dom p );
A3: (for k holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k;
assume A4: P[ k ];
P[ ( k + 1 ) ]
proof
let i;
let j;
reconsider l = ( i + k ) as (Element of ( NAT ));
A5: ( 0 ) <= k by NAT_1:2;
assume j = ( i + ( k + 1 ) );
then A6: j = ( l + 1 );
assume A7: i in ( dom p );
then 1 <= i by FINSEQ_3:25;
then A8: ( 1 + ( 0 ) ) <= l by A5,XREAL_1:7;
assume A9: j in ( dom p );
then j <= ( len p ) by FINSEQ_3:25;
then l < ( len p ) by A6,NAT_1:13;
then A10: l in ( dom p ) by A8,FINSEQ_3:25;
then A11: ( p . i ) <= ( p . l ) by A4,A7;
( p . l ) <= ( p . j ) by A9,A6,A10,CKB2:def 1;
hence thesis by A11,XXREAL_0:2;
end;
hence thesis;
end;
A12: P[ ( 0 ) ];
A13: (for k holds P[ k ]) from NAT_1:sch 1(A12,A3);
assume i <= j;
then consider n being Nat such that A14: j = ( i + n ) by NAT_1:10;
reconsider n as (Element of ( NAT )) by ORDINAL1:def 12;
j = ( i + n ) by A14;
hence thesis by A1,A2,A13;
end;
