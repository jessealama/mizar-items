environ
vocabularies NUMBERS,XBOOLE_0,PRE_TOPC,RCOMP_1,SUBSET_1,FUNCT_1,URYSOHN1,CARD_1,ZFMISC_1,STRUCT_0,TARSKI,ARYTM_3,PARTFUN1,SEQFUNC,RELAT_1,NEWTON,XXREAL_0,NAT_1,ARYTM_1,REAL_1,CARD_3,PROB_1,LIMFUNC1,SUPINF_1,TOPMETR,ORDINAL2,XXREAL_1,SUPINF_2,ORDINAL1,XXREAL_2,TMAP_1,METRIC_1,PCOMPS_1,XREAL_0,COMPLEX1,URYSOHN3;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,ORDINAL1,NUMBERS,XXREAL_0,XREAL_0,COMPLEX1,REAL_1,NAT_1,XXREAL_1,XXREAL_2,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,NEWTON,SUPINF_2,SEQ_1,TOPMETR,MEASURE6,PSCOMP_1,STRUCT_0,PRE_TOPC,COMPTS_1,TMAP_1,METRIC_1,PCOMPS_1,SEQFUNC,PROB_1,LIMFUNC1,SUPINF_1,URYSOHN1,CKB3,CKB6,CKB8;
definitions PRE_TOPC,TARSKI,STRUCT_0,LIMFUNC1,PROB_1,CKB3,CKB8;
theorems TARSKI,FUNCT_1,FUNCT_2,NAT_1,PCOMPS_1,PRE_TOPC,TOPS_1,TOPMETR,ABSVALUE,PARTFUN1,URYSOHN1,XREAL_0,RELSET_1,URYSOHN2,TMAP_1,METRIC_1,XBOOLE_0,XBOOLE_1,PREPOWER,XCMPLX_1,XREAL_1,PEPIN,NEWTON,XXREAL_0,SUBSET_1,ORDINAL1,NUMBERS,XXREAL_1,XXREAL_2,RELAT_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB7,CKB8;
schemes NAT_1,FUNCT_2,RECDEF_1,XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,ORDINAL1,RELSET_1,PARTFUN1,NUMBERS,XXREAL_0,NAT_1,MEMBERED,STRUCT_0,PRE_TOPC,METRIC_1,URYSOHN1,TOPMETR,WAYBEL_3,BORSUK_4,BORSUK_6,VALUED_0,XREAL_0,FUNCT_1;
constructors REAL_1,NAT_1,PROB_1,LIMFUNC1,SEQFUNC,NEWTON,SUPINF_2,MEASURE5,MEASURE6,URYSOHN1,TMAP_1,WAYBEL_3,SEQ_1,BORSUK_4,PSCOMP_1,SUPINF_1,PCOMPS_1,BORSUK_6,WAYBEL_0,COMPTS_1,TOPREAL2,LATTICE3,MONOID_0,FUNCOP_1,CKB3,CKB6,CKB8;
requirements NUMERALS,SUBSET,BOOLE,REAL,ARITHM;
begin
definition
let x being Real;
assume A1: x in ( DYADIC );
func inf_number_dyadic x -> (Element of ( NAT )) means 
:Def3: ((x in ( dyadic ( 0 ) ) iff it = ( 0 )) & (for n being (Element of ( NAT )) holds ((x in ( dyadic ( n + 1 ) ) & (not x in ( dyadic n ))) implies it = ( n + 1 ))));
existence
proof
defpred P[ Nat ]
 means
x in ( dyadic $1 );
(ex s being (Element of ( NAT )) st P[ s ]) by A1,URYSOHN1:def 2;
then A2: (ex s being Nat st P[ s ]);
(ex q being Nat st (P[ q ] & (for i being Nat holds (P[ i ] implies q <= i)))) from NAT_1:sch 5(A2);
then consider q being Nat such that A3: x in ( dyadic q ) and A4: (for i being Nat holds (x in ( dyadic i ) implies q <= i));
reconsider q as (Element of ( NAT )) by ORDINAL1:def 12;
take q;
(for n being (Element of ( NAT )) holds ((x in ( dyadic ( n + 1 ) ) & (not x in ( dyadic n ))) implies q = ( n + 1 )))
proof
let n being (Element of ( NAT ));
assume that
A5: x in ( dyadic ( n + 1 ) )
and
A6: (not x in ( dyadic n ));
A7: ( n + 1 ) <= q
proof
assume (not ( n + 1 ) <= q);
then q <= n by NAT_1:13;
then ( dyadic q ) c= ( dyadic n ) by URYSOHN2:29;
hence thesis by A3,A6;
end;
q <= ( n + 1 ) by A4,A5;
hence thesis by A7,XXREAL_0:1;
end;
hence thesis by A3,A4;
end;
uniqueness
proof
let s1 being (Element of ( NAT ));
let s2 being (Element of ( NAT ));
assume that
A8: (x in ( dyadic ( 0 ) ) iff s1 = ( 0 ))
and
A9: (for n being (Element of ( NAT )) holds ((x in ( dyadic ( n + 1 ) ) & (not x in ( dyadic n ))) implies s1 = ( n + 1 )))
and
A10: (x in ( dyadic ( 0 ) ) iff s2 = ( 0 ))
and
A11: (for n being (Element of ( NAT )) holds ((x in ( dyadic ( n + 1 ) ) & (not x in ( dyadic n ))) implies s2 = ( n + 1 )));
per cases ;
suppose s1 = ( 0 );

hence thesis by A8,A10;
end;
suppose A12: ( 0 ) < s1;

defpred P[ Nat ]
 means
x in ( dyadic $1 );
(ex s being (Element of ( NAT )) st P[ s ]) by A1,URYSOHN1:def 2;
then A13: (ex s being Nat st P[ s ]);
(ex q being Nat st (P[ q ] & (for i being Nat holds (P[ i ] implies q <= i)))) from NAT_1:sch 5(A13);
then consider q being Nat such that A14: x in ( dyadic q ) and A15: (for i being Nat holds (x in ( dyadic i ) implies q <= i));
now
per cases ;
case q = ( 0 );
hence thesis by A8,A12,A14;
end;
case ( 0 ) < q;
then consider m being Nat such that A16: q = ( m + 1 ) by NAT_1:6;
reconsider m as (Element of ( NAT )) by ORDINAL1:def 12;
A17: (not x in ( dyadic m ))
proof
assume x in ( dyadic m );
then ( m + 1 ) <= ( m + ( 0 ) ) by A15,A16;
hence thesis by XREAL_1:6;
end;
then s1 = ( m + 1 ) by A9,A14,A16;
hence thesis by A11,A14,A16,A17;
end;
end;
hence thesis;
end;
end;
end;
