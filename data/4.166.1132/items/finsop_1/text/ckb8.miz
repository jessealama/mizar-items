environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,FINSEQ_1,FUNCT_1,BINOP_1,FUNCT_2,RELAT_1,FINSEQ_2,SETWISEO,XXREAL_0,CARD_1,ARYTM_3,FUNCOP_1,TARSKI,FUNCT_4,FINSUB_1,ORDINAL4,NAT_1,ARYTM_1,PARTFUN1,FINSOP_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,BINOP_1,PARTFUN1,FINSEQ_2,FINSEQ_1,FINSEQ_4,RELAT_1,RELSET_1,FUNCT_1,FINSUB_1,SETWISEO,FUNCT_2,NAT_1,FUNCOP_1,FUNCT_4,XXREAL_0,CKB1,CKB2,CKB5,CKB6,CKB7;
definitions FUNCT_1,TARSKI,XBOOLE_0,CKB2;
theorems BINOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSEQ_4,FUNCT_1,FUNCT_2,NAT_1,SETWISEO,TARSKI,RELAT_1,FUNCOP_1,FUNCT_4,FINSUB_1,RELSET_1,XBOOLE_0,XBOOLE_1,XCMPLX_1,XREAL_1,XXREAL_0,ORDINAL1,CARD_1,CKB2,CKB3,CKB4;
schemes FINSEQ_1,FINSEQ_2,NAT_1,FUNCT_2;
registrations XBOOLE_0,FUNCT_1,ORDINAL1,RELSET_1,FUNCT_2,XXREAL_0,XREAL_0,FINSEQ_1,CARD_1,FINSEQ_2;
constructors BINOP_1,PARTFUN1,FUNCOP_1,FUNCT_4,SETWISEO,XXREAL_0,XREAL_0,NAT_1,FINSEQ_2,FINSEQ_4,RELSET_1,CKB1,CKB2,CKB5,CKB7;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve D for non empty set;
reserve d for (Element of D);
reserve F for (FinSequence of D);
reserve f for (Function of ( NAT ),D);
reserve g for (BinOp of D);
reserve n for (Element of ( NAT ));
theorem
Lm1: (((( len F ) >= 1 & g is  associative) & g is  commutative) implies ( g "**" F ) = ( g $$ (( findom F ),( ( ( NAT ) --> ( the_unity_wrt g ) ) +* F )) ))
proof
assume that
A1: ( len F ) >= 1
and
A2: (g is  associative & g is  commutative);
set A = ( findom F );
set h = ( ( ( NAT ) --> ( the_unity_wrt g ) ) +* F );
A3: ( dom F ) = ( Seg ( len F ) ) by FINSEQ_1:def 3;
then consider G being (Function of ( Fin ( NAT ) ),D) such that A4: ( g $$ (A,h) ) = ( G . A ) and (for d holds (d is_a_unity_wrt g implies ( G . ( {} ) ) = d)) and A5: (for n holds ( G . { n } ) = ( h . n )) and A6: (for B being (Element of ( Fin ( NAT ) )) holds ((B c= A & B <> ( {} )) implies (for n holds (n in ( A \ B ) implies ( G . ( B \/ { n } ) ) = ( g . (( G . B ),( h . n )) ))))) by A1,A2,SETWISEO:def 3;
consider f such that A7: ( f . 1 ) = ( F . 1 ) and A8: (for n holds ((( 0 ) <> n & n < ( len F )) implies ( f . ( n + 1 ) ) = ( g . (( f . n ),( F . ( n + 1 ) )) ))) and A9: ( g "**" F ) = ( f . ( len F ) ) by A1,CKB2:def 1;
defpred P[ (Element of ( NAT )) ]
 means
(($1 <> ( 0 ) & $1 <= ( len F )) implies ( f . $1 ) = ( G . ( Seg $1 ) ));
A10: (for n holds (P[ n ] implies P[ ( n + 1 ) ]))
proof
let n;
assume A11: ((n <> ( 0 ) & n <= ( len F )) implies ( f . n ) = ( G . ( Seg n ) ));
assume that
( n + 1 ) <> ( 0 )
and
A12: ( n + 1 ) <= ( len F );
now
per cases ;
suppose A13: n = ( 0 );

1 in ( dom F ) by A1,A3,FINSEQ_1:1;
then ( h . 1 ) = ( F . 1 ) by FUNCT_4:13;
hence thesis by A7,A5,A13,FINSEQ_1:2;
end;
suppose A14: n <> ( 0 );

reconsider B = ( Seg n ) as (Element of ( Fin ( NAT ) )) by FINSUB_1:def 5;
( n + 1 ) >= 1 by NAT_1:12;
then A15: ( n + 1 ) in ( dom F ) by A12,FINSEQ_3:25;
A16: n < ( len F ) by A12,NAT_1:13;
then A17: ( f . ( n + 1 ) ) = ( g . (( f . n ),( F . ( n + 1 ) )) ) by A8,A14;
(not ( n + 1 ) in ( Seg n )) by FINSEQ_3:10;
then A18: ( n + 1 ) in ( A \ ( Seg n ) ) by A15,XBOOLE_0:def 5;
A19: ( Seg n ) c= A by A3,A16,FINSEQ_1:5;
( G . ( Seg ( n + 1 ) ) ) = ( G . ( ( Seg n ) \/ { ( n + 1 ) } ) ) by FINSEQ_1:9
.= ( g . (( G . B ),( h . ( n + 1 ) )) ) by A6,A14,A19,A18;
hence thesis by A11,A12,A14,A17,A15,FUNCT_4:13,NAT_1:13;
end;
end;
hence thesis;
end;
A20: P[ ( 0 ) ];
(for n holds P[ n ]) from NAT_1:sch 1(A20,A10);
hence thesis by A1,A9,A3,A4;
end;
