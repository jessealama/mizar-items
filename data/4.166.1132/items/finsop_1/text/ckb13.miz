environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,FINSEQ_1,FUNCT_1,BINOP_1,FUNCT_2,RELAT_1,FINSEQ_2,SETWISEO,XXREAL_0,CARD_1,ARYTM_3,FUNCOP_1,TARSKI,FUNCT_4,FINSUB_1,ORDINAL4,NAT_1,ARYTM_1,PARTFUN1,FINSOP_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,BINOP_1,PARTFUN1,FINSEQ_2,FINSEQ_1,FINSEQ_4,RELAT_1,RELSET_1,FUNCT_1,FINSUB_1,SETWISEO,FUNCT_2,NAT_1,FUNCOP_1,FUNCT_4,XXREAL_0,CKB1,CKB2,CKB5,CKB6,CKB7;
definitions FUNCT_1,TARSKI,XBOOLE_0,CKB2;
theorems BINOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSEQ_4,FUNCT_1,FUNCT_2,NAT_1,SETWISEO,TARSKI,RELAT_1,FUNCOP_1,FUNCT_4,FINSUB_1,RELSET_1,XBOOLE_0,XBOOLE_1,XCMPLX_1,XREAL_1,XXREAL_0,ORDINAL1,CARD_1,CKB2,CKB3,CKB4,CKB8,CKB9,CKB10,CKB11,CKB12;
schemes FINSEQ_1,FINSEQ_2,NAT_1,FUNCT_2;
registrations XBOOLE_0,FUNCT_1,ORDINAL1,RELSET_1,FUNCT_2,XXREAL_0,XREAL_0,FINSEQ_1,CARD_1,FINSEQ_2;
constructors BINOP_1,PARTFUN1,FUNCOP_1,FUNCT_4,SETWISEO,XXREAL_0,XREAL_0,NAT_1,FINSEQ_2,FINSEQ_4,RELSET_1,CKB1,CKB2,CKB5,CKB7;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve D for non empty set;
reserve d for (Element of D);
reserve F for (FinSequence of D);
reserve f for (Function of ( NAT ),D);
reserve f1 for (Function of ( NAT ),D);
reserve g for (BinOp of D);
reserve n for (Element of ( NAT ));
theorem
Lm5: (( len F ) >= 1 implies ( g "**" ( F ^ <* d *> ) ) = ( g . (( g "**" F ),d) ))
proof
set G = ( F ^ <* d *> );
A1: ( G . ( ( len F ) + 1 ) ) = d by FINSEQ_1:42;
A2: ( len G ) = ( ( len F ) + ( len <* d *> ) ) by FINSEQ_1:22
.= ( ( len F ) + 1 ) by FINSEQ_1:39;
then 1 <= ( len G ) by NAT_1:12;
then consider f1 such that A3: ( f1 . 1 ) = ( G . 1 ) and A4: (for n holds ((( 0 ) <> n & n < ( len G )) implies ( f1 . ( n + 1 ) ) = ( g . (( f1 . n ),( G . ( n + 1 ) )) ))) and A5: ( g "**" G ) = ( f1 . ( len G ) ) by CKB2:def 1;
assume A6: ( len F ) >= 1;
then consider f such that A7: ( f . 1 ) = ( F . 1 ) and A8: (for n holds ((( 0 ) <> n & n < ( len F )) implies ( f . ( n + 1 ) ) = ( g . (( f . n ),( F . ( n + 1 ) )) ))) and A9: ( g "**" F ) = ( f . ( len F ) ) by CKB2:def 1;
defpred P[ (Element of ( NAT )) ]
 means
((( 0 ) <> $1 & $1 < ( len G )) implies ( f . $1 ) = ( f1 . $1 ));
A10: (for n holds (P[ n ] implies P[ ( n + 1 ) ]))
proof
let n;
assume A11: P[ n ];
assume that
A12: ( 0 ) <> ( n + 1 )
and
A13: ( n + 1 ) < ( len G );
A14: ( n + 1 ) >= 1 by A12,NAT_1:14;
now
per cases  by A14,XXREAL_0:1;
suppose A15: ( n + 1 ) = 1;

1 in ( dom F ) by A6,FINSEQ_3:25;
hence thesis by A7,A3,A15,FINSEQ_1:def 7;
end;
suppose A16: ( n + 1 ) > 1;

then n <> ( 0 );
then A17: ( f1 . ( n + 1 ) ) = ( g . (( f1 . n ),( G . ( n + 1 ) )) ) by A4,A13,NAT_1:12;
A18: ( n + 1 ) <= ( len F ) by A2,A13,NAT_1:13;
then A19: n < ( len F ) by NAT_1:13;
1 <= ( n + 1 ) by NAT_1:12;
then A20: ( n + 1 ) in ( dom F ) by A18,FINSEQ_3:25;
( n + 1 ) > ( ( 0 ) + 1 ) by A16;
then ( f . ( n + 1 ) ) = ( g . (( f . n ),( F . ( n + 1 ) )) ) by A8,A19;
hence thesis by A11,A13,A16,A17,A20,FINSEQ_1:def 7,NAT_1:12;
end;
end;
hence thesis;
end;
A21: P[ ( 0 ) ];
A22: (for n holds P[ n ]) from NAT_1:sch 1(A21,A10);
( g "**" G ) = ( g . (( f1 . ( len F ) ),( G . ( ( len F ) + 1 ) )) ) by A6,A2,A4,A5,XREAL_1:29;
hence thesis by A6,A9,A2,A1,A22,XREAL_1:29;
end;
