environ
vocabularies XBOOLE_0,STRUCT_0,FUNCT_1,SUBSET_1,ORDERS_2,SEQM_3,XXREAL_0,RELAT_2,LATTICE3,LATTICES,EQREL_1,WAYBEL_0,YELLOW_1,YELLOW_0,RELAT_1,CAT_1,WELLORD1,ORDINAL2,TARSKI,REWRITE1,CARD_FIL,BINOP_1,FUNCT_2,GROUP_6,YELLOW_2,LATTICE2,XBOOLEAN,ZFMISC_1,XXREAL_2,WAYBEL_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,DOMAIN_1,STRUCT_0,WELLORD1,ORDERS_2,LATTICE3,QUANTAL1,ORDERS_3,YELLOW_0,YELLOW_1,WAYBEL_0,YELLOW_2,CKB1;
definitions TARSKI,LATTICE3,QUANTAL1,ORDERS_3,YELLOW_0,WAYBEL_0,XBOOLE_0,YELLOW_2,STRUCT_0,CKB1;
theorems ZFMISC_1,ORDERS_2,FUNCT_1,FUNCT_2,LATTICE3,RELAT_1,TARSKI,WELLORD1,ORDERS_3,YELLOW_0,YELLOW_1,YELLOW_2,WAYBEL_0,RELSET_1,XBOOLE_0,XBOOLE_1,CKB1;
schemes FUNCT_2,DOMAIN_1;
registrations RELAT_1,FUNCT_1,FUNCT_2,STRUCT_0,LATTICE3,YELLOW_0,WAYBEL_0,YELLOW_1,YELLOW_2,RELSET_1;
constructors DOMAIN_1,TOLER_1,QUANTAL1,ORDERS_3,YELLOW_2,RELSET_1,CKB1;
requirements SUBSET,BOOLE;
begin
definition
let L1 being non  empty RelStr;
let L2 being non  empty RelStr;
let f being (Function of L1,L2);
redefine attr f is  monotone
means
:Def2: (for x,y being (Element of L1) holds (x <= y implies ( f . x ) <= ( f . y )));
compatibility
proof
thus (f is  monotone implies (for x,y being (Element of L1) holds (x <= y implies ( f . x ) <= ( f . y )))) by ORDERS_3:def 5;
assume (for x,y being (Element of L1) holds (x <= y implies ( f . x ) <= ( f . y )));
hence (for x,y being (Element of L1) holds (x <= y implies (for a,b being (Element of L2) holds ((a = ( f . x ) & b = ( f . y )) implies a <= b))));
end;
end;
