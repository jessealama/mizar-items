environ
vocabularies NUMBERS,STRUCT_0,ALGSTR_0,VECTSP_1,FUNCSDOM,BINOP_1,SUBSET_1,FUNCT_1,ZFMISC_1,XBOOLE_0,CARD_1,FUNCOP_1,RELAT_1,GROUP_1,LATTICES,MESFUNC1,NAT_1,ARYTM_3,SUPINF_2,POLYNOM3,RLVECT_1,ARYTM_1,ALGSTR_1,FINSEQ_1,RFINSEQ,FINSEQ_3,XXREAL_0,ORDINAL4,PARTFUN1,CARD_3,REALSET1,TARSKI,UNIALG_2,RLSUB_1,SETFAM_1,POLYNOM1,ALGSEQ_1,POLYALG1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,SETFAM_1,NUMBERS,XCMPLX_0,REALSET1,NAT_1,STRUCT_0,ALGSTR_0,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCOP_1,FINSEQ_1,RFINSEQ,BINOP_1,NAT_D,GROUP_1,RLVECT_1,VFUNCT_1,VECTSP_1,NORMSP_1,BHSP_1,POLYNOM1,ALGSTR_1,ALGSEQ_1,POLYNOM3,POLYNOM5,VECTSP_4,XXREAL_0,CKB1,CKB3;
definitions TARSKI,RLVECT_1,GROUP_1,VECTSP_1,VECTSP_4,BINOP_1,REALSET1,STRUCT_0,ALGSTR_0,CKB3;
theorems TARSKI,NAT_1,RLVECT_1,VECTSP_1,FUNCT_1,FUNCT_2,FUNCOP_1,FINSEQ_1,FINSEQ_3,FINSEQ_5,RFINSEQ,BINOP_1,POLYNOM1,POLYNOM3,ZFMISC_1,POLYNOM5,BINOM,RELAT_1,VECTSP_4,SETFAM_1,ALGSTR_1,XBOOLE_0,XBOOLE_1,GROUP_1,XREAL_1,ORDINAL1,NORMSP_1,PARTFUN1,CARD_1,NAT_D,CKB3;
schemes SUBSET_1,BINOP_1;
registrations XBOOLE_0,SUBSET_1,RELSET_1,XREAL_0,NAT_1,FINSEQ_1,REALSET1,STRUCT_0,VECTSP_1,FVSUM_1,POLYNOM3,POLYNOM5,BINOM,ORDINAL1,VFUNCT_1,FUNCT_2,CKB1,CKB2;
constructors SETFAM_1,BINOP_1,XXREAL_0,REALSET1,RFINSEQ,NAT_D,ALGSTR_1,VECTSP_4,BHSP_1,POLYNOM1,POLYNOM3,POLYNOM5,SEQ_1,REAL_1,RELSET_1,FUNCOP_1,FVSUM_1,VFUNCT_1,CKB1,CKB3;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
registration
let L being non  empty doubleLoopStr;
cluster  unital  distributive  vector-distributive  scalar-distributive  scalar-associative  scalar-unital  mix-associative for non  empty non  empty AlgebraStr over L;
existence
proof
( 0 ) in { ( 0 ) } by TARSKI:def 1;
then reconsider lm = ( [: (the carrier of L),{ ( 0 ) } :] --> ( 0 ) ) as (Function of [: (the carrier of L),{ ( 0 ) } :],{ ( 0 ) }) by FUNCOP_1:45;
reconsider z = ( 0 ) as (Element of { ( 0 ) }) by TARSKI:def 1;
set a = the (BinOp of { ( 0 ) });
reconsider A = AlgebraStr (# { ( 0 ) },a,a,z,z,lm #) as non  empty AlgebraStr over L;
take A;
A1: (for x,y being (Element of A) holds x = y)
proof
let x being (Element of A);
let y being (Element of A);
x = ( 0 ) by TARSKI:def 1;
hence thesis by TARSKI:def 1;
end;
thus A is  unital
proof
take ( 1. A );
thus thesis by A1;
end;

thus A is  distributive
proof
let x being (Element of A);
let y being (Element of A);
let z being (Element of A);
thus thesis by A1;
end;

thus A is  vector-distributive
proof
let x being (Element of L);
let v being (Element of A);
let w being (Element of A);
thus thesis by A1;
end;

thus A is  scalar-distributive
proof
let x being (Element of L);
let y being (Element of L);
let v being (Element of A);
thus thesis by A1;
end;

thus A is  scalar-associative
proof
let x being (Element of L);
let y being (Element of L);
thus thesis by A1;
end;

thus A is  scalar-unital
proof
let v being (Element of A);
thus thesis by A1;
end;

thus A is  mix-associative
proof
let a being (Element of L);
let x being (Element of A);
let y being (Element of A);
thus thesis by A1;
end;

end;
end;
