environ
vocabularies NUMBERS,STRUCT_0,ALGSTR_0,VECTSP_1,FUNCSDOM,BINOP_1,SUBSET_1,FUNCT_1,ZFMISC_1,XBOOLE_0,CARD_1,FUNCOP_1,RELAT_1,GROUP_1,LATTICES,MESFUNC1,NAT_1,ARYTM_3,SUPINF_2,POLYNOM3,RLVECT_1,ARYTM_1,ALGSTR_1,FINSEQ_1,RFINSEQ,FINSEQ_3,XXREAL_0,ORDINAL4,PARTFUN1,CARD_3,REALSET1,TARSKI,UNIALG_2,RLSUB_1,SETFAM_1,POLYNOM1,ALGSEQ_1,POLYALG1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,SETFAM_1,NUMBERS,XCMPLX_0,REALSET1,NAT_1,STRUCT_0,ALGSTR_0,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCOP_1,FINSEQ_1,RFINSEQ,BINOP_1,NAT_D,GROUP_1,RLVECT_1,VFUNCT_1,VECTSP_1,NORMSP_1,BHSP_1,POLYNOM1,ALGSTR_1,ALGSEQ_1,POLYNOM3,POLYNOM5,VECTSP_4,XXREAL_0,CKB1,CKB3,CKB5,CKB8;
definitions TARSKI,RLVECT_1,GROUP_1,VECTSP_1,VECTSP_4,BINOP_1,REALSET1,STRUCT_0,ALGSTR_0,CKB3,CKB8;
theorems TARSKI,NAT_1,RLVECT_1,VECTSP_1,FUNCT_1,FUNCT_2,FUNCOP_1,FINSEQ_1,FINSEQ_3,FINSEQ_5,RFINSEQ,BINOP_1,POLYNOM1,POLYNOM3,ZFMISC_1,POLYNOM5,BINOM,RELAT_1,VECTSP_4,SETFAM_1,ALGSTR_1,XBOOLE_0,XBOOLE_1,GROUP_1,XREAL_1,ORDINAL1,NORMSP_1,PARTFUN1,CARD_1,NAT_D,CKB3,CKB6,CKB7,CKB8,CKB16,CKB17,CKB18,CKB22,CKB23,CKB24,CKB25;
schemes SUBSET_1,BINOP_1;
registrations XBOOLE_0,SUBSET_1,RELSET_1,XREAL_0,NAT_1,FINSEQ_1,REALSET1,STRUCT_0,VECTSP_1,FVSUM_1,POLYNOM3,POLYNOM5,BINOM,ORDINAL1,VFUNCT_1,FUNCT_2,CKB1,CKB2,CKB4,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB19,CKB20,CKB21;
constructors SETFAM_1,BINOP_1,XXREAL_0,REALSET1,RFINSEQ,NAT_D,ALGSTR_1,VECTSP_4,BHSP_1,POLYNOM1,POLYNOM3,POLYNOM5,SEQ_1,REAL_1,RELSET_1,FUNCOP_1,FVSUM_1,VFUNCT_1,CKB1,CKB3,CKB8;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
registration
let L being  Abelian  add-associative  associative  right_zeroed  right_complementable  well-unital  distributive non  empty doubleLoopStr;
cluster ( Formal-Series L ) ->  vector-distributive  scalar-distributive  scalar-associative  scalar-unital;
coherence
proof
set F = ( Formal-Series L );
thus F is  vector-distributive
proof
let x being (Element of L);
let v being (Element of ( Formal-Series L ));
let w being (Element of ( Formal-Series L ));
reconsider p = v,q = w as (sequence of L) by CKB8:def 1;
reconsider x9 = x as (Element of L);
reconsider k = ( v + w ) as (Element of ( Formal-Series L ));
A1: ( x * v ) = ( x * p ) by CKB8:def 1;
reconsider r = k as (sequence of L) by CKB8:def 1;
A2: ( x * w ) = ( x * q ) by CKB8:def 1;
( x * k ) = ( x * r ) by CKB8:def 1;
hence ( x * ( v + w ) ) = ( x * ( p + q ) ) by CKB8:def 1
.= ( ( x9 * p ) + ( x9 * q ) ) by CKB22:1
.= ( ( x * v ) + ( x * w ) ) by A1,A2,CKB8:def 1;
end;

thus F is  scalar-distributive
proof
let x being (Element of L);
let y being (Element of L);
let v being (Element of ( Formal-Series L ));
reconsider p = v as (sequence of L) by CKB8:def 1;
reconsider x9 = x,y9 = y as (Element of L);
A3: ( x * v ) = ( x * p ) by CKB8:def 1;
A4: ( y * v ) = ( y * p ) by CKB8:def 1;
thus ( ( x + y ) * v ) = ( ( x9 + y9 ) * p ) by CKB8:def 1
.= ( ( x9 * p ) + ( y9 * p ) ) by CKB23:1
.= ( ( x * v ) + ( y * v ) ) by A3,A4,CKB8:def 1;
end;

thus F is  scalar-associative
proof
let x being (Element of L);
let y being (Element of L);
let v being (Element of ( Formal-Series L ));
reconsider p = v as (sequence of L) by CKB8:def 1;
reconsider x9 = x,y9 = y as (Element of L);
A5: ( y * v ) = ( y * p ) by CKB8:def 1;
thus ( ( x * y ) * v ) = ( ( x9 * y9 ) * p ) by CKB8:def 1
.= ( x9 * ( y9 * p ) ) by CKB24:1
.= ( x * ( y * v ) ) by A5,CKB8:def 1;
end;

let v being (Element of F);
reconsider p = v as (sequence of L) by CKB8:def 1;
thus ( ( 1. L ) * v ) = ( ( 1. L ) * p ) by CKB8:def 1
.= v by CKB25:1;
end;
end;
