environ
vocabularies NUMBERS,ABIAN,SUBSET_1,ARYTM_3,XXREAL_0,ARYTM_1,CARD_1,TARSKI,FINSEQ_1,RELAT_1,FUNCT_1,NAT_1,XBOOLE_0,GLIB_000,FINSEQ_5,GRAPH_2,INT_1,FINSET_1,RCOMP_1,WAYBEL_0,ZFMISC_1,MSAFREE2,ORDINAL4,GRAPH_1,FUNCT_4,FUNCOP_1,MCART_1,GLIB_001;
notations TARSKI,XBOOLE_0,CARD_1,NUMBERS,SUBSET_1,XCMPLX_0,XXREAL_0,DOMAIN_1,RELAT_1,FUNCT_1,FINSEQ_1,GRAPH_2,FINSEQ_5,RELSET_1,MCART_1,FINSET_1,NAT_1,NAT_D,FUNCOP_1,FUNCT_4,GLIB_000,ABIAN,CKB7,CKB8,CKB9,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB117,CKB118,CKB119,CKB120,CKB121,CKB142,CKB146;
definitions FUNCOP_1,CKB7,CKB8,CKB9,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB36,CKB37,CKB38,CKB39,CKB142;
theorems CARD_1,CARD_2,FUNCOP_1,ENUMSET1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSEQ_4,FINSEQ_5,FINSEQ_6,FINSET_1,FUNCT_1,FUNCT_4,GLIB_000,GRAPH_2,GRAPH_5,INT_1,JORDAN12,MCART_1,NAT_1,NAT_2,PEPIN,RELAT_1,TARSKI,XBOOLE_0,XBOOLE_1,XREAL_1,PRE_CIRC,XXREAL_0,ABIAN,ORDINAL1,NAT_D,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56,CKB57,CKB58,CKB59,CKB60,CKB61,CKB62,CKB63,CKB64,CKB65,CKB66,CKB67,CKB68,CKB69,CKB70,CKB71,CKB72,CKB73,CKB74,CKB75,CKB76,CKB77,CKB78,CKB79,CKB80,CKB81,CKB82,CKB83,CKB84,CKB85,CKB86,CKB87,CKB88,CKB89,CKB90,CKB91,CKB92,CKB93,CKB94,CKB95,CKB96,CKB97,CKB98,CKB99,CKB100,CKB101,CKB102,CKB103,CKB104,CKB105,CKB106,CKB107,CKB108,CKB142,CKB143,CKB144,CKB145;
schemes FINSEQ_1,FUNCT_1,NAT_1,RECDEF_1;
registrations XBOOLE_0,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,GLIB_000,ABIAN,GRAPH_2,GRAPH_3,CARD_1,SUBSET_1,CKB10,CKB109,CKB110,CKB111,CKB112,CKB113,CKB114,CKB115,CKB116,CKB122,CKB123,CKB124,CKB125,CKB126,CKB127,CKB128,CKB129,CKB130,CKB131,CKB132,CKB133,CKB134,CKB135,CKB136,CKB137,CKB138,CKB139,CKB140,CKB141;
constructors DOMAIN_1,FUNCT_4,NAT_D,RECDEF_1,FINSEQ_5,GLIB_000,ABIAN,GRAPH_2,XXREAL_2,RELSET_1,FINSEQ_2,RAT_1,CKB7,CKB8,CKB9,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB36,CKB37,CKB38,CKB39,CKB142,CKB146;
requirements ARITHM,BOOLE,NUMERALS,REAL,SUBSET;
begin
registration
let G being _Graph;
let W being (Walk of G);
cluster  Trail-like  Path-like for (Subwalk of W);
existence
proof
set n = ( ( len W ) + 1 );
defpred P1[ (Element of ( NAT )),set,set ]
 means
(($2 is (Walk of G) & (ex Wn being (Walk of G) st (Wn = $2 & $3 = ( Wn .remove (( Wn .find ( ( 2 * $1 ) + 1 ) ),( Wn .rfind ( ( 2 * $1 ) + 1 ) )) )))) or ((not $2 is (Walk of G)) & $3 = $2));
A1:now
let n being (Element of ( NAT ));
let x being set;
now
per cases ;
suppose x is (Walk of G);

then reconsider W = x as (Walk of G);
set y = ( W .remove (( W .find ( ( 2 * n ) + 1 ) ),( W .rfind ( ( 2 * n ) + 1 ) )) );
P1[ n,x,y ];
hence (ex y being set st P1[ n,x,y ]);
end;
suppose (not x is (Walk of G));

hence (ex y being set st P1[ n,x,y ]);
end;
end;
hence (ex y being set st P1[ n,x,y ]);
end;
consider f being Function such that A2: ((( dom f ) = ( NAT ) & ( f . ( 0 ) ) = W) & (for n being (Element of ( NAT )) holds P1[ n,( f . n ),( f . ( n + 1 ) ) ])) from RECDEF_1:sch 1(A1);
defpred P3[ (Element of ( NAT )) ]
 means
(ex Wn being (Subwalk of W) st ((Wn = ( f . $1 ) & ( len Wn ) <= ( len W )) & (for m being  odd (Element of ( NAT )) holds ((m < ( ( 2 * $1 ) + 1 ) & m <= ( len Wn )) implies ( Wn .rfind m ) = m))));
now
let n being (Element of ( NAT ));
assume P3[ n ];
then consider Wn being (Subwalk of W) such that A3: Wn = ( f . n ) and A4: ( len Wn ) <= ( len W ) and A5: (for m being  odd (Element of ( NAT )) holds ((m < ( ( 2 * n ) + 1 ) & m <= ( len Wn )) implies ( Wn .rfind m ) = m));
set a = ( Wn .find ( ( 2 * n ) + 1 ) );
set b = ( Wn .rfind ( ( 2 * n ) + 1 ) );
set Wn1 = ( Wn .remove (a,b) );
reconsider Wn1 as (Subwalk of W) by CKB144:1;
take Wn1;
P1[ n,( f . n ),( f . ( n + 1 ) ) ] by A2;
hence ( f . ( n + 1 ) ) = Wn1 by A3;
( len Wn1 ) <= ( len Wn ) by CKB65:1;
hence ( len Wn1 ) <= ( len W ) by A4,XXREAL_0:2;
let m being  odd (Element of ( NAT ));
assume that
A6: m < ( ( 2 * ( n + 1 ) ) + 1 )
and
A7: m <= ( len Wn1 );
set W1 = ( Wn .cut (1,a) );
set W2 = ( Wn .cut (b,( len Wn )) );
A8: ( len Wn1 ) <= ( len Wn ) by CKB65:1;
then A9: m <= ( len Wn ) by A7,XXREAL_0:2;
m <= ( 2 * ( n + 1 ) ) by A6,NAT_1:13;
then m < ( ( ( 2 * n ) + 1 ) + 1 ) by XXREAL_0:1;
then A10: m <= ( ( 2 * n ) + 1 ) by NAT_1:13;
now
per cases ;
suppose A11: ( ( 2 * n ) + 1 ) <= ( len Wn );

then A12: a <= ( ( 2 * n ) + 1 ) by CKB88:1;
A13: ( Wn . a ) = ( Wn . ( ( 2 * n ) + 1 ) ) by A11,CKB27:def 1;
A14: a <= ( len Wn ) by A11,CKB27:def 1;
A15:now
assume A16: a < ( ( 2 * n ) + 1 );
then a <= ( len Wn ) by A11,XXREAL_0:2;
then ( Wn .rfind a ) = a by A5,A16;
hence contradiction by A11,A14,A13,A16,CKB29:def 1;
end;
then A17: a = ( ( 2 * n ) + 1 ) by A12,XXREAL_0:1;
A18: ( Wn . b ) = ( Wn . ( ( 2 * n ) + 1 ) ) by A11,CKB29:def 1;
set m9 = ( Wn1 .rfind m );
A19: 1 <= m by ABIAN:12;
A20: ( Wn1 . m9 ) = ( Wn1 . m ) by A7,CKB29:def 1;
A21: m9 >= m by A7,CKB89:1;
A22: b <= ( len Wn ) by A11,CKB29:def 1;
1 <= a by ABIAN:12;
then A23: ( W1 .last() ) = ( Wn . ( ( 2 * n ) + 1 ) ) by A14,A13,CKB55:1,JORDAN12:2
.= ( W2 .first() ) by A22,A18,CKB55:1;
( ( 2 * n ) + 1 ) <= b by A11,CKB89:1;
then A24: a <= b by A12,XXREAL_0:2;
then A25: Wn1 = ( W1 .append W2 ) by A13,A22,A18,CKB19:def 1;
A26: m9 <= ( len Wn1 ) by A7,CKB29:def 1;
then A27: m9 <= ( len Wn ) by A8,XXREAL_0:2;
now
per cases  by A10,XXREAL_0:1;
suppose A28: m < ( ( 2 * n ) + 1 );

then m < ( len ( Wn .cut (1,a) ) ) by A11,A17,CKB61:1;
then A29: ( Wn1 .cut (1,m) ) = ( ( Wn .cut (1,a) ) .cut (1,m) ) by A25,A19,A23,CKB60:1,JORDAN12:2
.= ( Wn .cut (1,m) ) by A10,A17,CKB59:1;
reconsider maa1 = ( m - 1 ) as (Element of ( NAT )) by ABIAN:12,INT_1:5;
A30: ( maa1 + 1 ) = m;
A31: maa1 < ( m - ( 0 ) ) by XREAL_1:15;
then A32: maa1 < ( len ( Wn .cut (1,m) ) ) by A7,A8,CKB61:1,XXREAL_0:2;
maa1 < ( len ( Wn1 .cut (1,m) ) ) by A7,A31,CKB61:1;
then ( Wn1 . m ) = ( ( Wn .cut (1,m) ) . m ) by A7,A19,A29,A30,CKB54:1,JORDAN12:2;
then A33: ( Wn1 . m ) = ( Wn . m ) by A9,A19,A30,A32,CKB54:1,JORDAN12:2;
A34: ( Wn .rfind m ) = m by A5,A9,A28;
now
per cases ;
suppose A35: m9 < a;

reconsider m9aa1 = ( m9 - 1 ) as (Element of ( NAT )) by ABIAN:12,INT_1:5;
A36: 1 <= m9 by ABIAN:12;
A37: m9aa1 < ( m9 - ( 0 ) ) by XREAL_1:15;
then A38: m9aa1 < ( len ( Wn1 .cut (1,m9) ) ) by A26,CKB61:1;
A39: m9aa1 < ( len ( Wn .cut (1,m9) ) ) by A8,A26,A37,CKB61:1,XXREAL_0:2;
m9 < ( len ( Wn .cut (1,a) ) ) by A14,A35,CKB61:1;
then ( Wn1 .cut (1,m9) ) = ( ( Wn .cut (1,a) ) .cut (1,m9) ) by A25,A23,A36,CKB60:1,JORDAN12:2
.= ( Wn .cut (1,m9) ) by A35,CKB59:1;
then ( Wn1 . m9 ) = ( ( Wn .cut (1,m9) ) . ( m9aa1 + 1 ) ) by A26,A36,A38,CKB54:1,JORDAN12:2;
then ( Wn . m9 ) = ( Wn . m ) by A20,A27,A33,A36,A39,CKB54:1,JORDAN12:2;
then m9 <= m by A9,A27,A34,CKB29:def 1;
hence ( Wn1 .rfind m ) = m by A21,XXREAL_0:1;
end;
suppose A40: a <= m9;

set x = ( ( m9 - a ) + b );
A41: ( Wn1 . m9 ) = ( Wn . x ) by A13,A22,A18,A24,A26,A40,CKB69:1;
A42: x <= ( len Wn ) by A13,A22,A18,A24,A26,A40,CKB69:1;
( m9 + a ) <= ( m9 + b ) by A24,XREAL_1:7;
then A43: ( ( m9 + a ) - a ) <= ( ( m9 + b ) - a ) by XREAL_1:13;
reconsider x as (Element of ( NAT )) by A13,A22,A18,A24,A26,A40,CKB69:1;
x <= m by A9,A20,A34,A33,A41,A42,CKB29:def 1;
then m9 <= m by A43,XXREAL_0:2;
hence ( Wn1 .rfind m ) = m by A21,XXREAL_0:1;
end;
end;
hence ( Wn1 .rfind m ) = m;
end;
suppose A44: m = ( ( 2 * n ) + 1 );

then m <= ( len ( Wn .cut (1,a) ) ) by A11,A17,CKB61:1;
then A45: ( Wn1 .cut (1,m) ) = ( ( Wn .cut (1,a) ) .cut (1,m) ) by A25,A19,A23,CKB60:1,JORDAN12:2
.= ( Wn .cut (1,m) ) by A10,A17,CKB59:1;
reconsider maa1 = ( m - 1 ) as (Element of ( NAT )) by ABIAN:12,INT_1:5;
A46: ( maa1 + 1 ) = m;
A47: maa1 < ( m - ( 0 ) ) by XREAL_1:15;
then A48: maa1 < ( len ( Wn .cut (1,m) ) ) by A7,A8,CKB61:1,XXREAL_0:2;
maa1 < ( len ( Wn1 .cut (1,m) ) ) by A7,A47,CKB61:1;
then ( Wn1 . m ) = ( ( Wn .cut (1,m) ) . m ) by A7,A19,A45,A46,CKB54:1,JORDAN12:2;
then A49: ( Wn1 . m ) = ( Wn . m ) by A9,A19,A46,A48,CKB54:1,JORDAN12:2;
now
set x = ( ( m9 - a ) + b );
assume A50: m < m9;
then A51: a < m9 by A12,A15,A44,XXREAL_0:1;
then A52: x is (Element of ( NAT )) by A13,A22,A18,A24,A26,CKB69:1;
A53: x <= ( len Wn ) by A13,A22,A18,A24,A26,A51,CKB69:1;
( Wn1 . m9 ) = ( Wn . x ) by A13,A22,A18,A24,A26,A51,CKB69:1;
then ( ( m9 - a ) + b ) <= b by A11,A20,A44,A49,A52,A53,CKB29:def 1;
then ( ( ( m9 - a ) + b ) - b ) <= ( b - b ) by XREAL_1:13;
then ( ( m9 - a ) + a ) <= ( ( 0 ) + a ) by XREAL_1:7;
hence contradiction by A12,A15,A44,A50,XXREAL_0:1;
end;
hence ( Wn1 .rfind m ) = m by A21,XXREAL_0:1;
end;
end;
hence ( Wn1 .rfind m ) = m;
end;
suppose A54: ( len Wn ) < ( ( 2 * n ) + 1 );

then A55: m < ( ( 2 * n ) + 1 ) by A9,XXREAL_0:2;
A56: b = ( len Wn ) by A54,CKB29:def 1;
a = ( len Wn ) by A54,CKB27:def 1;
then Wn1 = Wn by A56,CKB66:1;
hence ( Wn1 .rfind m ) = m by A5,A7,A55;
end;
end;
hence ( Wn1 .rfind m ) = m;
end;
then A57: (for n being (Element of ( NAT )) holds (P3[ n ] implies P3[ ( n + 1 ) ]));
reconsider W0 = ( f . ( 0 ) ) as (Subwalk of W) by A2,CKB143:1;
(for m being  odd (Element of ( NAT )) holds ((m < ( ( 2 * ( 0 ) ) + 1 ) & m <= ( len W0 )) implies ( W0 .rfind m ) = m)) by ABIAN:12;
then A58: P3[ ( 0 ) ] by A2;
(for n being (Element of ( NAT )) holds P3[ n ]) from NAT_1:sch 1(A58,A57);
then consider P being (Subwalk of W) such that P = ( f . n ) and A59: ( len P ) <= ( len W ) and A60: (for m being  odd (Element of ( NAT )) holds ((m < ( ( 2 * n ) + 1 ) & m <= ( len P )) implies ( P .rfind m ) = m));
take P;
now
let m being  odd (Element of ( NAT ));
assume A61: m <= ( len P );
( ( len P ) + ( 0 ) ) < n by A59,XREAL_1:8;
then ( ( len P ) + ( 0 ) ) < ( n + n ) by XREAL_1:8;
then ( ( len P ) + ( 0 ) ) < ( ( 2 * n ) + 1 ) by XREAL_1:8;
then m < ( ( 2 * n ) + 1 ) by A61,XXREAL_0:2;
hence ( P .rfind m ) = m by A60,A61;
end;
then P is  Path-like by CKB106:1;
hence thesis;
end;
end;
