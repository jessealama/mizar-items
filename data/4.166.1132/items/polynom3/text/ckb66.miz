environ
vocabularies NUMBERS,RLVECT_1,ALGSTR_0,XBOOLE_0,FINSEQ_1,STRUCT_0,SUBSET_1,RELAT_1,FUNCT_1,SUPINF_2,CARD_3,NAT_1,PARTFUN1,FINSEQ_5,ORDINAL4,ARYTM_3,XXREAL_0,FINSEQ_3,FINSEQ_2,PRE_POLY,TARSKI,CARD_1,ORDERS_1,RELAT_2,FINSET_1,ARYTM_1,FUNCT_2,POLYNOM1,ALGSEQ_1,FUNCOP_1,FUNCT_4,MESFUNC1,LATTICES,VECTSP_1,BINOP_1,CLASSES1,GROUP_1,ZFMISC_1,POLYNOM3;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,RELAT_1,RELAT_2,FUNCT_1,ORDERS_1,XXREAL_0,NAT_1,NAT_D,CLASSES1,RELSET_1,PARTFUN1,FINSET_1,FUNCT_2,FUNCOP_1,FINSEQ_1,PRE_POLY,FINSEQ_2,FINSEQ_5,FINSEQOP,BINOP_1,RVSUM_1,FUNCT_7,TREES_4,WSIERP_1,STRUCT_0,ALGSTR_0,MATRLIN,BINARITH,GROUP_1,RLVECT_1,VFUNCT_1,FVSUM_1,VECTSP_1,NORMSP_1,POLYNOM1,ALGSEQ_1,BHSP_1,RECDEF_1,CKB5,CKB6,CKB7,CKB8,CKB10,CKB11,CKB12,CKB13,CKB17,CKB19,CKB28,CKB37,CKB43,CKB47,CKB50,CKB54,CKB57,CKB61,CKB63;
definitions TARSKI,XBOOLE_0,RELAT_1,RELAT_2,PRE_POLY,RLVECT_1,GROUP_1,VECTSP_1,ALGSEQ_1,FINSEQ_2,FUNCT_2,STRUCT_0,CARD_1,ALGSTR_0,CKB10,CKB12,CKB17,CKB19,CKB28,CKB47,CKB50,CKB54,CKB57;
theorems AXIOMS,TARSKI,ENUMSET1,RELSET_1,INT_1,NAT_1,CARD_1,RLVECT_1,VECTSP_1,ALGSEQ_1,RELAT_2,ORDERS_1,FUNCT_1,FUNCT_2,FUNCT_7,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSEQ_4,FINSEQ_5,RFINSEQ,BINOP_1,CARD_3,RVSUM_1,FVSUM_1,MATRLIN,YELLOW15,POLYNOM1,RELAT_1,XBOOLE_0,RLVECT_2,XCMPLX_1,PARTFUN1,GROUP_1,XREAL_1,XXREAL_0,ORDINAL1,BHSP_1,NORMSP_1,XREAL_0,NAT_D,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB10,CKB12,CKB14,CKB15,CKB16,CKB17,CKB19,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB38,CKB41,CKB42,CKB44,CKB46,CKB47,CKB49,CKB50,CKB52,CKB53,CKB54,CKB56,CKB57,CKB59,CKB60,CKB62,CKB64,CKB65;
schemes FUNCT_2,FINSEQ_1,FINSEQ_2,NAT_1,RELSET_1,SUBSET_1,BINOP_1,RECDEF_1,CKB9,CKB39;
registrations RELAT_1,ORDINAL1,FUNCT_2,FUNCOP_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,FINSEQ_1,FINSEQ_2,REALSET1,FINSEQ_5,STRUCT_0,VECTSP_1,VALUED_0,FINSET_1,RELSET_1,PRE_POLY,VFUNCT_1,CARD_1,FUNCT_1,CKB18,CKB20,CKB40,CKB45,CKB48,CKB51,CKB55,CKB58;
constructors BINOP_1,SQUARE_1,FINSEQOP,REALSET1,RFINSEQ,NAT_D,FINSEQ_5,WSIERP_1,ALGSEQ_1,BHSP_1,DTCONSTR,TRIANG_1,POLYNOM1,SEQ_1,RECDEF_1,SEQ_2,SEQM_3,REAL_1,BINARITH,CLASSES1,RELSET_1,RELAT_1,FUNCT_7,MATRLIN,PRE_POLY,FVSUM_1,VFUNCT_1,CKB5,CKB6,CKB7,CKB8,CKB10,CKB12,CKB17,CKB19,CKB28,CKB43,CKB50,CKB54,CKB57,CKB61,CKB63;
requirements NUMERALS,BOOLE,SUBSET,REAL,ARITHM;
begin
definition
let L being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr;
func Polynom-Ring L ->  strict non  empty doubleLoopStr means 
:Def12: (((((for x being set holds (x in (the carrier of it) iff x is (Polynomial of L))) & (for x,y being (Element of it) holds (for p,q being (sequence of L) holds ((x = p & y = q) implies ( x + y ) = ( p + q ))))) & (for x,y being (Element of it) holds (for p,q being (sequence of L) holds ((x = p & y = q) implies ( x * y ) = ( p *' q ))))) & ( 0. it ) = ( 0_. L )) & ( 1. it ) = ( 1_. L ));
existence
proof
A1: ( 0_. L ) in { x where x is (Polynomial of L): (not contradiction) };
then reconsider Ca = { x where x is (Polynomial of L): (not contradiction) } as non  empty set;
reconsider Ze = ( 0_. L ) as (Element of Ca) by A1;
defpred P[ set,set,set ]
 means
(ex p,q being (Polynomial of L) st ((p = $1 & q = $2) & $3 = ( p + q )));
A2: (for x,y being (Element of Ca) holds (ex u being (Element of Ca) st P[ x,y,u ]))
proof
let x being (Element of Ca);
let y being (Element of Ca);
x in Ca;
then consider p being (Polynomial of L) such that A3: x = p;
y in Ca;
then consider q being (Polynomial of L) such that A4: y = q;
( p + q ) in Ca;
then reconsider u = ( p + q ) as (Element of Ca);
take u;
take p;
take q;
thus thesis by A3,A4;
end;
consider Ad being (Function of [: Ca,Ca :],Ca) such that A5: (for x,y being (Element of Ca) holds P[ x,y,( Ad . (x,y) ) ]) from BINOP_1:sch 3(A2);
( 1_. L ) in { x where x is (Polynomial of L): (not contradiction) };
then reconsider Un = ( 1_. L ) as (Element of Ca);
defpred P[ set,set,set ]
 means
(ex p,q being (Polynomial of L) st ((p = $1 & q = $2) & $3 = ( p *' q )));
A6: (for x,y being (Element of Ca) holds (ex u being (Element of Ca) st P[ x,y,u ]))
proof
let x being (Element of Ca);
let y being (Element of Ca);
x in Ca;
then consider p being (Polynomial of L) such that A7: x = p;
y in Ca;
then consider q being (Polynomial of L) such that A8: y = q;
( p *' q ) in Ca;
then reconsider u = ( p *' q ) as (Element of Ca);
take u;
take p;
take q;
thus thesis by A7,A8;
end;
consider Mu being (Function of [: Ca,Ca :],Ca) such that A9: (for x,y being (Element of Ca) holds P[ x,y,( Mu . (x,y) ) ]) from BINOP_1:sch 3(A6);
reconsider P = doubleLoopStr (# Ca,Ad,Mu,Un,Ze #) as  strict non  empty doubleLoopStr;
take P;
thus (for x being set holds (x in (the carrier of P) iff x is (Polynomial of L)))
proof
let x being set;
thus (x in (the carrier of P) implies x is (Polynomial of L))
proof
assume x in (the carrier of P);
then (ex p being (Polynomial of L) st x = p);
hence thesis;
end;

thus thesis;
end;

thus (for x,y being (Element of P) holds (for p,q being (sequence of L) holds ((x = p & y = q) implies ( x + y ) = ( p + q ))))
proof
let x being (Element of P);
let y being (Element of P);
let p being (sequence of L);
let q being (sequence of L);
assume A10: (x = p & y = q);
(ex p1,q1 being (Polynomial of L) st ((p1 = x & q1 = y) & ( Ad . (x,y) ) = ( p1 + q1 ))) by A5;
hence thesis by A10;
end;

thus (for x,y being (Element of P) holds (for p,q being (sequence of L) holds ((x = p & y = q) implies ( x * y ) = ( p *' q ))))
proof
let x being (Element of P);
let y being (Element of P);
let p being (sequence of L);
let q being (sequence of L);
assume A11: (x = p & y = q);
(ex p1,q1 being (Polynomial of L) st ((p1 = x & q1 = y) & ( Mu . (x,y) ) = ( p1 *' q1 ))) by A9;
hence thesis by A11;
end;

thus ( 0. P ) = ( 0_. L );
thus thesis;
end;
uniqueness
proof
let P1 being  strict non  empty doubleLoopStr;
let P2 being  strict non  empty doubleLoopStr;
assume that
A12: (for x being set holds (x in (the carrier of P1) iff x is (Polynomial of L)))
and
A13: (for x,y being (Element of P1) holds (for p,q being (sequence of L) holds ((x = p & y = q) implies ( x + y ) = ( p + q ))))
and
A14: (for x,y being (Element of P1) holds (for p,q being (sequence of L) holds ((x = p & y = q) implies ( x * y ) = ( p *' q ))))
and
A15: (( 0. P1 ) = ( 0_. L ) & ( 1. P1 ) = ( 1_. L ))
and
A16: (for x being set holds (x in (the carrier of P2) iff x is (Polynomial of L)))
and
A17: (for x,y being (Element of P2) holds (for p,q being (sequence of L) holds ((x = p & y = q) implies ( x + y ) = ( p + q ))))
and
A18: (for x,y being (Element of P2) holds (for p,q being (sequence of L) holds ((x = p & y = q) implies ( x * y ) = ( p *' q ))))
and
A19: (( 0. P2 ) = ( 0_. L ) & ( 1. P2 ) = ( 1_. L ));
A20:now
let x being set;
(x in (the carrier of P1) iff x is (Polynomial of L)) by A12;
hence (x in (the carrier of P1) iff x in (the carrier of P2)) by A16;
end;
then A21: (the carrier of P1) = (the carrier of P2) by TARSKI:1;
A22:now
let x being (Element of P1);
let y being (Element of P2);
reconsider y1 = y as (Element of P1) by A20;
reconsider x1 = x as (Element of P2) by A20;
reconsider p = x as (sequence of L) by A12;
reconsider q = y as (sequence of L) by A16;
thus ( (the multF of P1) . (x,y) ) = ( x * y1 )
.= ( p *' q ) by A14
.= ( x1 * y ) by A18
.= ( (the multF of P2) . (x,y) );
end;
now
let x being (Element of P1);
let y being (Element of P2);
reconsider y1 = y as (Element of P1) by A20;
reconsider x1 = x as (Element of P2) by A20;
reconsider p = x as (sequence of L) by A12;
reconsider q = y as (sequence of L) by A16;
thus ( (the addF of P1) . (x,y) ) = ( x + y1 )
.= ( p + q ) by A13
.= ( x1 + y ) by A17
.= ( (the addF of P2) . (x,y) );
end;
then (the addF of P1) = (the addF of P2) by A21,BINOP_1:2;
hence thesis by A15,A19,A21,A22,BINOP_1:2;
end;
end;
