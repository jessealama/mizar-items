environ
vocabularies NUMBERS,RLVECT_1,ALGSTR_0,XBOOLE_0,FINSEQ_1,STRUCT_0,SUBSET_1,RELAT_1,FUNCT_1,SUPINF_2,CARD_3,NAT_1,PARTFUN1,FINSEQ_5,ORDINAL4,ARYTM_3,XXREAL_0,FINSEQ_3,FINSEQ_2,PRE_POLY,TARSKI,CARD_1,ORDERS_1,RELAT_2,FINSET_1,ARYTM_1,FUNCT_2,POLYNOM1,ALGSEQ_1,FUNCOP_1,FUNCT_4,MESFUNC1,LATTICES,VECTSP_1,BINOP_1,CLASSES1,GROUP_1,ZFMISC_1,POLYNOM3;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,CARD_1,NUMBERS,XCMPLX_0,RELAT_1,RELAT_2,FUNCT_1,ORDERS_1,XXREAL_0,NAT_1,NAT_D,CLASSES1,RELSET_1,PARTFUN1,FINSET_1,FUNCT_2,FUNCOP_1,FINSEQ_1,PRE_POLY,FINSEQ_2,FINSEQ_5,FINSEQOP,BINOP_1,RVSUM_1,FUNCT_7,TREES_4,WSIERP_1,STRUCT_0,ALGSTR_0,MATRLIN,BINARITH,GROUP_1,RLVECT_1,VFUNCT_1,FVSUM_1,VECTSP_1,NORMSP_1,POLYNOM1,ALGSEQ_1,BHSP_1,RECDEF_1,CKB5,CKB6,CKB7,CKB8,CKB10,CKB11,CKB12,CKB13;
definitions TARSKI,XBOOLE_0,RELAT_1,RELAT_2,PRE_POLY,RLVECT_1,GROUP_1,VECTSP_1,ALGSEQ_1,FINSEQ_2,FUNCT_2,STRUCT_0,CARD_1,ALGSTR_0,CKB10,CKB12;
theorems AXIOMS,TARSKI,ENUMSET1,RELSET_1,INT_1,NAT_1,CARD_1,RLVECT_1,VECTSP_1,ALGSEQ_1,RELAT_2,ORDERS_1,FUNCT_1,FUNCT_2,FUNCT_7,FUNCOP_1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSEQ_4,FINSEQ_5,RFINSEQ,BINOP_1,CARD_3,RVSUM_1,FVSUM_1,MATRLIN,YELLOW15,POLYNOM1,RELAT_1,XBOOLE_0,RLVECT_2,XCMPLX_1,PARTFUN1,GROUP_1,XREAL_1,XXREAL_0,ORDINAL1,BHSP_1,NORMSP_1,XREAL_0,NAT_D,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB10,CKB12,CKB14,CKB15,CKB16;
schemes FUNCT_2,FINSEQ_1,FINSEQ_2,NAT_1,RELSET_1,SUBSET_1,BINOP_1,RECDEF_1,CKB9;
registrations RELAT_1,ORDINAL1,FUNCT_2,FUNCOP_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,FINSEQ_1,FINSEQ_2,REALSET1,FINSEQ_5,STRUCT_0,VECTSP_1,VALUED_0,FINSET_1,RELSET_1,PRE_POLY,VFUNCT_1,CARD_1,FUNCT_1;
constructors BINOP_1,SQUARE_1,FINSEQOP,REALSET1,RFINSEQ,NAT_D,FINSEQ_5,WSIERP_1,ALGSEQ_1,BHSP_1,DTCONSTR,TRIANG_1,POLYNOM1,SEQ_1,RECDEF_1,SEQ_2,SEQM_3,REAL_1,BINARITH,CLASSES1,RELSET_1,RELAT_1,FUNCT_7,MATRLIN,PRE_POLY,FVSUM_1,VFUNCT_1,CKB5,CKB6,CKB7,CKB8,CKB10,CKB12;
requirements NUMERALS,BOOLE,SUBSET,REAL,ARITHM;
begin
definition
let n being (Element of ( NAT ));
func TuplesOrder n -> (Order of ( n -tuples_on ( NAT ) )) means 
:Def3: (for p,q being (Element of ( n -tuples_on ( NAT ) )) holds ([ p,q ] in it iff p <= q));
existence
proof
defpred P[ (Element of ( n -tuples_on ( NAT ) )),(Element of ( n -tuples_on ( NAT ) )) ]
 means
$1 <= $2;
consider R being (Relation of ( n -tuples_on ( NAT ) ),( n -tuples_on ( NAT ) )) such that A1: (for x,y being (Element of ( n -tuples_on ( NAT ) )) holds ([ x,y ] in R iff P[ x,y ])) from RELSET_1:sch 2;
A2: R is_transitive_in ( n -tuples_on ( NAT ) )
proof
let x being set;
let y being set;
let z being set;
assume that
A3: ((x in ( n -tuples_on ( NAT ) ) & y in ( n -tuples_on ( NAT ) )) & z in ( n -tuples_on ( NAT ) ))
and
A4: ([ x,y ] in R & [ y,z ] in R);
reconsider x1 = x,y1 = y,z1 = z as (Element of ( n -tuples_on ( NAT ) )) by A3;
(x1 <= y1 & y1 <= z1) by A1,A4;
then x1 <= z1 by CKB14:1;
hence thesis by A1;
end;
A5: R is_reflexive_in ( n -tuples_on ( NAT ) )
proof
let x being set;
assume x in ( n -tuples_on ( NAT ) );
then reconsider x1 = x as (Element of ( n -tuples_on ( NAT ) ));
x1 <= x1;
hence thesis by A1;
end;
then A6: (( dom R ) = ( n -tuples_on ( NAT ) ) & ( field R ) = ( n -tuples_on ( NAT ) )) by ORDERS_1:13;
R is_antisymmetric_in ( n -tuples_on ( NAT ) )
proof
let x being set;
let y being set;
assume that
A7: (x in ( n -tuples_on ( NAT ) ) & y in ( n -tuples_on ( NAT ) ))
and
A8: [ x,y ] in R
and
A9: [ y,x ] in R;
reconsider x1 = x,y1 = y as (Element of ( n -tuples_on ( NAT ) )) by A7;
x1 <= y1 by A1,A8;
then A10: (x1 < y1 or x1 = y1) by CKB12:def 1;
y1 <= x1 by A1,A9;
hence thesis by A10,CKB12:def 1;
end;
then reconsider R as (Order of ( n -tuples_on ( NAT ) )) by A5,A2,A6,PARTFUN1:def 2,RELAT_2:def 9,RELAT_2:def 12,RELAT_2:def 16;
take R;
thus thesis by A1;
end;
uniqueness
proof
let T1 being (Order of ( n -tuples_on ( NAT ) ));
let T2 being (Order of ( n -tuples_on ( NAT ) ));
assume that
A11: (for p,q being (Element of ( n -tuples_on ( NAT ) )) holds ([ p,q ] in T1 iff p <= q))
and
A12: (for p,q being (Element of ( n -tuples_on ( NAT ) )) holds ([ p,q ] in T2 iff p <= q));
let x being set;
let y being set;
thus ([ x,y ] in T1 implies [ x,y ] in T2)
proof
assume A13: [ x,y ] in T1;
then consider p,q being set such that A14: [ x,y ] = [ p,q ] and A15: (p in ( n -tuples_on ( NAT ) ) & q in ( n -tuples_on ( NAT ) )) by RELSET_1:2;
reconsider p,q as (Element of ( n -tuples_on ( NAT ) )) by A15;
p <= q by A11,A13,A14;
hence thesis by A12,A14;
end;

assume A16: [ x,y ] in T2;
then consider p,q being set such that A17: [ x,y ] = [ p,q ] and A18: (p in ( n -tuples_on ( NAT ) ) & q in ( n -tuples_on ( NAT ) )) by RELSET_1:2;
reconsider p,q as (Element of ( n -tuples_on ( NAT ) )) by A18;
p <= q by A12,A16,A17;
hence thesis by A11,A17;
end;
end;
