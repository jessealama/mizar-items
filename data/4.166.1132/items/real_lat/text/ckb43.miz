environ
vocabularies REAL_1,BINOP_1,NUMBERS,FUNCT_1,XXREAL_0,SUBSET_1,LATTICES,XREAL_0,XBOOLE_0,EQREL_1,FUNCT_2,RELAT_1,QC_LANG1,REAL_LAT,MEMBERED,STRUCT_0;
notations XBOOLE_0,SUBSET_1,NUMBERS,XXREAL_0,XREAL_0,REAL_1,SQUARE_1,MEMBERED,STRUCT_0,LATTICES,BINOP_1,FUNCSDOM,RELAT_1,FUNCT_2,CKB1,CKB2,CKB3,CKB24,CKB25,CKB42;
definitions LATTICES,STRUCT_0,CKB1,CKB2,CKB3,CKB24,CKB25,CKB42;
theorems LATTICES,BINOP_1,FUNCT_2,FUNCOP_1,XREAL_0,XXREAL_0,CKB1,CKB2,CKB3,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42;
schemes BINOP_1;
registrations XBOOLE_0,RELSET_1,NUMBERS,XREAL_0,LATTICES,MEMBERED,CKB4,CKB5,CKB14,CKB23,CKB6,CKB7;
constructors SQUARE_1,LATTICES,FUNCSDOM,RELSET_1,MEMBERED,CKB1,CKB2,CKB3,CKB24,CKB25,CKB42;
requirements SUBSET,BOOLE;
begin
reserve A for non  empty set;
reserve L for non  empty LattStr;
reserve p for (Element of L);
reserve q for (Element of L);
reserve r for (Element of L);
registration
let A;
cluster ( RealFunc_Lattice A ) ->  join-commutative  join-associative  meet-absorbing  meet-commutative  meet-associative  join-absorbing for non  empty non  empty LattStr;
coherence
proof
let L;
assume that
Z: L = ( RealFunc_Lattice A );
thus ( p "\/" q ) = ( q "\/" p ) by CKB27:1,Z;
thus ( p "\/" ( q "\/" r ) ) = ( ( p "\/" q ) "\/" r ) by CKB29:1,Z;
thus ( ( p "/\" q ) "\/" q ) = q by CKB33:1,Z;
thus ( p "/\" q ) = ( q "/\" p ) by CKB28:1,Z;
thus ( p "/\" ( q "/\" r ) ) = ( ( p "/\" q ) "/\" r ) by CKB30:1,Z;
thus ( p "/\" ( p "\/" q ) ) = p by CKB35:1,Z;
end;
end;
