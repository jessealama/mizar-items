environ
vocabularies NUMBERS,XCMPLX_0,ORDINAL1,ARYTM_1,XXREAL_0,NAT_1,CARD_1,ARYTM_3,ABIAN,SUBSET_1,RELAT_1,INT_1,FINSEQ_1,FUNCT_1,FINSEQ_4,XBOOLE_0,FINSET_1,GRAPH_2,ORDINAL4,GLIB_000,GLIB_001,TARSKI,ZFMISC_1,RCOMP_1,GRAPH_1,RELAT_2,REWRITE1,FUNCOP_1,GLIB_002,PARTFUN1,MEMBERED,TOPGEN_1,CHORD;
notations TARSKI,XBOOLE_0,SUBSET_1,XXREAL_2,ORDINAL1,INT_1,XCMPLX_0,XXREAL_0,DOMAIN_1,RELAT_1,FUNCT_1,FUNCT_2,FINSEQ_1,CARD_1,FINSET_1,NAT_1,ZFMISC_1,GLIB_000,GLIB_001,GLIB_002,FUNCOP_1,ABIAN,ENUMSET1,FINSEQ_4,NUMBERS,GRAPH_2,MEMBERED,CKB18;
definitions TARSKI,XBOOLE_0,GLIB_000,GLIB_001,GLIB_002,FUNCOP_1,CKB18;
theorems FINSEQ_1,FUNCT_1,GLIB_000,GLIB_001,GLIB_002,GRAPH_2,GRAPH_3,TREES_1,INT_1,JORDAN12,NAT_1,ORDINAL1,RELAT_1,TARSKI,XBOOLE_0,XBOOLE_1,FUNCOP_1,FUNCT_2,FINSEQ_3,FINSEQ_4,ZFMISC_1,ABIAN,CARD_2,ENUMSET1,FINSEQ_2,XREAL_1,MEMBERED,FINSEQ_5,XXREAL_0,NAT_D,PARTFUN1,XXREAL_2,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29;
schemes NAT_1,GRAPH_5,FUNCT_2,FRAENKEL;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,FINSEQ_1,GLIB_000,ABIAN,GRAPH_2,GLIB_001,GLIB_002,FUNCT_2,XXREAL_2,CARD_1,RELSET_1;
constructors DOMAIN_1,REAL_1,NAT_D,FINSEQ_4,GRAPH_2,GLIB_001,GLIB_002,VALUED_1,XXREAL_2,RELSET_1,CKB18;
requirements ARITHM,BOOLE,NUMERALS,REAL,SUBSET;
begin
theorem
Th27: (for G being _Graph holds (for P,H being (Path of G) holds (((((((( P .edges() ) misses ( H .edges() ) & P is  open) & H is non trivial) & H is  open) & ( ( P .vertices() ) /\ ( H .vertices() ) ) = { ( P .first() ),( P .last() ) }) & ( H .first() ) = ( P .last() )) & ( H .last() ) = ( P .first() )) implies ( P .append H ) is  Cycle-like)))
proof
let G being _Graph;
let P being (Path of G),H being (Path of G);
assume that
A1: ( P .edges() ) misses ( H .edges() )
and
A2: P is  open
and
A3: H is non trivial
and
A4: H is  open
and
A5: ( ( P .vertices() ) /\ ( H .vertices() ) ) = { ( P .first() ),( P .last() ) }
and
A6: ( H .first() ) = ( P .last() )
and
A7: ( H .last() ) = ( P .first() );
set J = ( P .append H );
A8: ( J .first() ) = ( P .first() ) by A6,GLIB_001:30;
A9:now
let m being  odd Nat;
A10: 1 <= m by ABIAN:12;
assume m <= ( len P );
then m in ( dom P ) by A10,FINSEQ_3:25;
hence ( J . m ) = ( P . m ) by GLIB_001:32;
end;
A11: (for m being  odd Nat holds ((m > ( len P ) & m <= ( len J )) implies (m in ( dom J ) & (not m in ( dom P )))))
proof
let m being  odd Nat;
assume that
A12: m > ( len P )
and
A13: m <= ( len J );
1 <= m by ABIAN:12;
hence thesis by A12,A13,FINSEQ_3:25;
end;
A14: ( ( ( len J ) + 1 ) + ( - 1 ) ) = ( ( ( len P ) + ( len H ) ) + ( - 1 ) ) by A6,GLIB_001:28;
A15:now
let m being  odd (Element of ( NAT )),n being  odd (Element of ( NAT ));
assume that
A16: m < n
and
A17: n <= ( len J );
A18: m <= ( len J ) by A16,A17,XXREAL_0:2;
A19: 1 <= m by ABIAN:12;
per cases ;
suppose A20: (m <= ( len P ) & n <= ( len P ));

then A21: ( P . m ) = ( J . m ) by A9;
( P . m ) <> ( P . n ) by A2,A16,A20,GLIB_001:147;
hence (( J . m ) = ( J . n ) implies (m = 1 & n = ( len J ))) by A9,A20,A21;
end;
suppose A22: (m <= ( len P ) & n > ( len P ));

then A23: ( J . m ) = ( P . m ) by A9;
A24: (not n in ( dom P )) by A11,A17,A22;
n in ( dom J ) by A11,A17,A22;
then consider j being (Element of ( NAT )) such that A25: j < ( len H ) and A26: n = ( ( len P ) + j ) by A24,GLIB_001:34;
reconsider jj = j as  even Nat by A26;
reconsider j1 = ( jj + 1 ) as  odd Nat;
A27: j1 <= ( len H ) by A25,NAT_1:13;
A28: ( J . n ) = ( H . ( j + 1 ) ) by A6,A25,A26,GLIB_001:33;
now
assume A29: ( J . m ) = ( J . n );
A30:now
j <> ( 0 ) by A22,A26;
then ( ( 0 ) + 1 ) < j1 by XREAL_1:8;
then A31: ( H . ( ( 2 * ( 0 ) ) + 1 ) ) <> ( H . j1 ) by A4,A27,GLIB_001:147;
assume ( J . m ) = ( P .last() );
hence contradiction by A6,A25,A26,A29,A31,GLIB_001:33;
end;
A32: ( J . m ) in ( P .vertices() ) by A22,A23,GLIB_001:87;
( J . m ) in ( H .vertices() ) by A28,A27,A29,GLIB_001:87;
then A33: ( J . m ) in ( ( P .vertices() ) /\ ( H .vertices() ) ) by A32,XBOOLE_0:def 4;
then A34: ( J . n ) = ( H .last() ) by A5,A7,A29,A30,TARSKI:def 2;
A35:now
assume n < ( len J );
then j1 <> ( len H ) by A14,A26;
then A36: j1 < ( len H ) by A27,XXREAL_0:1;
( H . j1 ) = ( H . ( len H ) ) by A6,A25,A26,A34,GLIB_001:33;
hence contradiction by A4,A36,GLIB_001:147;
end;
A37: ( J . m ) = ( P .first() ) by A5,A33,A30,TARSKI:def 2;
now
assume 1 < m;
then ( P . m ) <> ( P . ( ( 2 * ( 0 ) ) + 1 ) ) by A2,A22,GLIB_001:147;
hence contradiction by A9,A22,A37;
end;
hence (m = 1 & n = ( len J )) by A17,A19,A35,XXREAL_0:1;
end;
hence (( J . m ) = ( J . n ) implies (m = 1 & n = ( len J )));
end;
suppose (m > ( len P ) & n <= ( len P ));

hence (( J . m ) = ( J . n ) implies (m = 1 & n = ( len J ))) by A16,XXREAL_0:2;
end;
suppose A38: (m > ( len P ) & n > ( len P ));

then A39: (not n in ( dom P )) by A11,A17;
n in ( dom J ) by A11,A17,A38;
then consider j being (Element of ( NAT )) such that A40: j < ( len H ) and A41: n = ( ( len P ) + j ) by A39,GLIB_001:34;
reconsider jj = j as  even Nat by A41;
reconsider j1 = ( jj + 1 ) as  odd (Element of ( NAT ));
A42: j1 <= ( len H ) by A40,NAT_1:13;
A43: (not m in ( dom P )) by A11,A18,A38;
m in ( dom J ) by A11,A18,A38;
then consider k being (Element of ( NAT )) such that A44: k < ( len H ) and A45: m = ( ( len P ) + k ) by A43,GLIB_001:34;
reconsider kk = k as  even Nat by A45;
reconsider k1 = ( kk + 1 ) as  odd Nat;
k < j by A16,A45,A41,XREAL_1:7;
then A46: k1 < j1 by XREAL_1:8;
A47: ( J . ( ( len P ) + j ) ) = ( H . ( j + 1 ) ) by A6,A40,GLIB_001:33;
( J . ( ( len P ) + k ) ) = ( H . ( k + 1 ) ) by A6,A44,GLIB_001:33;
hence (( J . m ) = ( J . n ) implies (m = 1 & n = ( len J ))) by A4,A45,A41,A47,A46,A42,GLIB_001:147;
end;
end;
A48: ( H .edgeSeq() ) is  one-to-one by GLIB_001:def 27;
now
assume ( len J ) = 1;
then A49: ( 1 + 1 ) = ( ( len P ) + ( len H ) ) by A6,GLIB_001:28;
now
assume A50: ( len P ) <> 1;
1 <= ( len P ) by CKB2:1;
then 1 < ( len P ) by A50,XXREAL_0:1;
then ( ( len P ) + ( len H ) ) <= ( len P ) by A49,NAT_1:13;
then ( ( ( len P ) + ( len H ) ) + ( - ( len P ) ) ) <= ( ( len P ) + ( - ( len P ) ) ) by XREAL_1:7;
then ( len H ) <= ( 0 );
hence contradiction;
end;
hence contradiction by A3,A49,GLIB_001:126;
end;
then A51: J is non trivial by GLIB_001:126;
( J .last() ) = ( P .first() ) by A6,A7,GLIB_001:30;
then A52: J is  closed by A8,GLIB_001:def 24;
( P .edgeSeq() ) is  one-to-one by GLIB_001:def 27;
then ( ( P .edgeSeq() ) ^ ( H .edgeSeq() ) ) is  one-to-one by A1,A48,FINSEQ_3:91;
then ( J .edgeSeq() ) is  one-to-one by A6,GLIB_001:85;
then J is  Trail-like by GLIB_001:def 27;
then J is  Path-like by A15,GLIB_001:def 28;
hence thesis by A52,A51,GLIB_001:def 31;
end;
