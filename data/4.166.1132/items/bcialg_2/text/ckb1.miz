environ
vocabularies BCIALG_1,CARD_FIL,SUBSET_1,FUNCT_1,NUMBERS,STRUCT_0,POWER,CARD_1,ARYTM_3,XBOOLE_0,XXREAL_0,FUNCOP_1,NAT_1,SUPINF_2,RELAT_1,CHORD,WAYBEL15,GROUP_4,GROUP_1,ALG_1,EQREL_1,PARTFUN1,RELAT_2,ZFMISC_1,RCOMP_1,TARSKI,BINOP_1,GROUP_6,BCIALG_2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,RELAT_1,FUNCT_1,NAT_1,FUNCT_2,XXREAL_0,FUNCOP_1,BINOP_1,STRUCT_0,BCIALG_1,RELAT_2,PARTFUN1,EQREL_1,ALG_1;
definitions XBOOLE_0,TARSKI,STRUCT_0,BCIALG_1,RELAT_1;
theorems BCIALG_1,FUNCOP_1,NAT_1,XREAL_1,TARSKI,XBOOLE_0,RELAT_2,RELAT_1,XXREAL_0,ORDERS_1,XBOOLE_1,BINOP_1,EQREL_1,RELSET_1,ZFMISC_1;
schemes FUNCT_2,NAT_1,RELSET_1,XBOOLE_0,BINOP_1;
registrations BCIALG_1,SUBSET_1,NAT_1,RELSET_1,STRUCT_0,PARTFUN1,ORDINAL1,XREAL_0;
constructors BCIALG_1,BINOP_1,XXREAL_0,NAT_1,BINARITH,EQREL_1,RELSET_1;
requirements NUMERALS,ARITHM,SUBSET,BOOLE;
begin
reserve X for BCI-algebra;
reserve x for (Element of X);
reserve y for (Element of X);
reserve u for (Element of X);
reserve f for (Function of ( NAT ),(the carrier of X));
reserve f9 for (Function of ( NAT ),(the carrier of X));
reserve j for (Element of ( NAT ));
reserve k for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
definition
let X;
let x;
let y;
let n being (Element of ( NAT ));
func (x,y) to_power n -> (Element of X)
means
:Def1: (ex f st ((it = ( f . n ) & ( f . ( 0 ) ) = x) & (for j being (Element of ( NAT )) holds (j < n implies ( f . ( j + 1 ) ) = ( ( f . j ) \ y )))));
existence
proof
defpred P[ set ]
 means
(for x,y being (Element of X) holds (for n being (Element of ( NAT )) holds (n = $1 implies (ex u being (Element of X) st (ex f being (Function of ( NAT ),(the carrier of X)) st ((u = ( f . n ) & ( f . ( 0 ) ) = x) & (for j being (Element of ( NAT )) holds (j < n implies ( f . ( j + 1 ) ) = ( ( f . j ) \ y )))))))));
now
let n being (Element of ( NAT ));
assume A1: (for x holds (for y holds (for k holds (k = n implies (ex u st (ex f st ((u = ( f . k ) & ( f . ( 0 ) ) = x) & (for j holds (j < k implies ( f . ( j + 1 ) ) = ( ( f . j ) \ y ))))))))));
let x;
let y;
let k;
consider u,f such that u = ( f . n ) and A2: ( f . ( 0 ) ) = x and A3: (for j holds (j < n implies ( f . ( j + 1 ) ) = ( ( f . j ) \ y ))) by A1;
defpred P[ set,set ]
 means
(for j holds ($1 = j implies ((j < ( n + 1 ) implies $2 = ( f . $1 )) & (( n + 1 ) <= j implies $2 = ( ( f . n ) \ y )))));
assume k = ( n + 1 );
A4: (for k being (Element of ( NAT )) holds (ex v being (Element of X) st P[ k,v ]))
proof
let k being (Element of ( NAT ));
reconsider i = k as (Element of ( NAT ));
A5:now
assume A6: ( n + 1 ) <= i;
take v = ( ( f . n ) \ y );
let j;
assume k = j;
hence (j < ( n + 1 ) implies v = ( f . k )) by A6;
assume ( n + 1 ) <= j;
thus v = ( ( f . n ) \ y );
end;
now
assume A7: i < ( n + 1 );
take v = ( f . k );
let j;
assume that
A8: k = j;
thus (j < ( n + 1 ) implies v = ( f . k ));
thus (( n + 1 ) <= j implies v = ( ( f . n ) \ y )) by A7,A8;
end;
hence thesis by A5;
end;
consider f9 being (Function of ( NAT ),(the carrier of X)) such that A9: (for k being (Element of ( NAT )) holds P[ k,( f9 . k ) ]) from FUNCT_2:sch 3(A4);
take z = ( f9 . ( n + 1 ) );
take f99 = f9;
thus z = ( f99 . ( n + 1 ) );
( 0 ) < ( n + 1 ) by NAT_1:5;
hence ( f99 . ( 0 ) ) = x by A2,A9;
let j;
A10:now
assume A11: j < n;
then (( f . ( j + 1 ) ) = ( ( f . j ) \ y ) & j < ( n + 1 )) by A3,NAT_1:13;
then A12: ( f . ( j + 1 ) ) = ( ( f9 . j ) \ y ) by A9;
( j + 1 ) < ( n + 1 ) by A11,XREAL_1:6;
hence ( f99 . ( j + 1 ) ) = ( ( f99 . j ) \ y ) by A9,A12;
end;
A13: n < ( n + 1 ) by NAT_1:13;
A14:now
assume A15: j = n;
then ( f99 . ( j + 1 ) ) = ( ( f . j ) \ y ) by A9;
hence ( f99 . ( j + 1 ) ) = ( ( f99 . j ) \ y ) by A13,A9,A15;
end;
assume j < ( n + 1 );
then j <= n by NAT_1:13;
hence ( f99 . ( j + 1 ) ) = ( ( f99 . j ) \ y ) by A10,A14,XXREAL_0:1;
end;
then A16: (for n being (Element of ( NAT )) holds (P[ n ] implies P[ ( n + 1 ) ]));
now
let x being (Element of X),y being (Element of X);
let n being (Element of ( NAT ));
assume A17: n = ( 0 );
reconsider f = ( ( NAT ) --> x ) as (Function of ( NAT ),(the carrier of X));
take u = ( f . n );
take f9 = f;
thus (u = ( f9 . n ) & ( f9 . ( 0 ) ) = x) by FUNCOP_1:7;
thus (for j being (Element of ( NAT )) holds (j < n implies ( f9 . ( j + 1 ) ) = ( ( f9 . j ) \ y ))) by A17,NAT_1:3;
end;
then A18: P[ ( 0 ) ];
(for n holds P[ n ]) from NAT_1:sch 1(A18,A16);
hence thesis;
end;
uniqueness
proof
let v1 being (Element of X),v2 being (Element of X);
given f such that
A19: v1 = ( f . n )
and
A20: ( f . ( 0 ) ) = x
and
A21: (for j holds (j < n implies ( f . ( j + 1 ) ) = ( ( f . j ) \ y )));

given f9 such that
A22: v2 = ( f9 . n )
and
A23: ( f9 . ( 0 ) ) = x
and
A24: (for j holds (j < n implies ( f9 . ( j + 1 ) ) = ( ( f9 . j ) \ y )));

defpred P[ Nat ]
 means
($1 <= n implies ( f . $1 ) = ( f9 . $1 ));
now
let k;
assume A25: (k <= n implies ( f . k ) = ( f9 . k ));
assume ( k + 1 ) <= n;
then A26: k < n by NAT_1:13;
then ( f . ( k + 1 ) ) = ( ( f . k ) \ y ) by A21;
hence ( f . ( k + 1 ) ) = ( f9 . ( k + 1 ) ) by A24,A25,A26;
end;
then A27: (for k holds (P[ k ] implies P[ ( k + 1 ) ]));
A28: P[ ( 0 ) ] by A20,A23;
(for k holds P[ k ]) from NAT_1:sch 1(A28,A27);
hence thesis by A19,A22;
end;
end;
