environ
vocabularies NUMBERS,SUBSET_1,XBOOLE_0,FINSEQ_1,XXREAL_0,FUNCT_1,RELAT_1,TARSKI,VALUED_0,CARD_1,ARYTM_3,ORDINAL1,CLASSES1,ZFMISC_1,ORDINAL2,FUNCOP_1,MCART_1,NAT_1,ORDINAL4,ARYTM_1,REAL_1,PARTFUN1;
notations TARSKI,XBOOLE_0,ZFMISC_1,MCART_1,SUBSET_1,NUMBERS,XXREAL_0,REAL_1,NAT_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCOP_1,ORDINAL1,ORDINAL2,CLASSES1,FINSEQ_1,FUNCT_2,BINOP_1,DOMAIN_1,VALUED_0,CKB2;
definitions TARSKI,BINOP_1;
theorems TARSKI,NAT_1,FUNCT_1,FINSEQ_1,FUNCT_2,RELAT_1,XBOOLE_1,FUNCOP_1,XREAL_1,XXREAL_0,ORDINAL1,CLASSES1,ORDINAL2,XBOOLE_0,ZFMISC_1,MCART_1,PARTFUN1,CKB1;
schemes NAT_1,FUNCT_1,FINSEQ_1,BINOP_1,CLASSES1,ORDINAL1,FUNCT_2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FINSET_1,XXREAL_0,XREAL_0,NAT_1,CARD_1,NUMBERS,RELSET_1,INT_1,XCMPLX_0,FINSEQ_1,VALUED_0;
constructors BINOP_1,DOMAIN_1,FUNCOP_1,XXREAL_0,REAL_1,NAT_1,FINSEQ_1,VALUED_0,CLASSES1,ORDINAL2,RELSET_1,CKB2;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve n for (Element of ( NAT ));
reserve D for non  empty set;
reserve x for set;
reserve y for set;
reserve z for set;
reserve y1 for set;
reserve y2 for set;
scheme LambdaDefRecD { D() -> non  empty set,A() -> (Element of D()),n() -> Nat,RecFun(set,set) -> (Element of D()) } : ((ex y being (Element of D()) st (ex f being (Function of ( NAT ),D()) st ((y = ( f . n() ) & ( f . ( 0 ) ) = A()) & (for n being Nat holds ( f . ( n + 1 ) ) = RecFun(n,( f . n )))))) & (for y1,y2 being (Element of D()) holds (((ex f being (Function of ( NAT ),D()) st ((y1 = ( f . n() ) & ( f . ( 0 ) ) = A()) & (for n being Nat holds ( f . ( n + 1 ) ) = RecFun(n,( f . n ))))) & (ex f being (Function of ( NAT ),D()) st ((y2 = ( f . n() ) & ( f . ( 0 ) ) = A()) & (for n being Nat holds ( f . ( n + 1 ) ) = RecFun(n,( f . n )))))) implies y1 = y2)))
proof
defpred Q[ set,set,set ]
 means
(for z being (Element of D()) holds (z = $2 implies $3 = RecFun($1,z)));
A1: (for n being (Element of ( NAT )) holds (for x being (Element of D()) holds (ex y being (Element of D()) st Q[ n,x,y ])))
proof
let n being (Element of ( NAT ));
let x being (Element of D());
take RecFun(n,x);
let z being (Element of D());
assume z = x;
hence thesis;
end;
A2: (for n being (Element of ( NAT )) holds (for x,y1,y2 being (Element of D()) holds ((Q[ n,x,y1 ] & Q[ n,x,y2 ]) implies y1 = y2)))
proof
let n being (Element of ( NAT ));
let x being (Element of D());
let y1 being (Element of D());
let y2 being (Element of D());
assume that
A3: (for z being (Element of D()) holds (z = x implies y1 = RecFun(n,z)))
and
A4: (for z being (Element of D()) holds (z = x implies y2 = RecFun(n,z)));
thus y1 = RecFun(n,x) by A3
.= y2 by A4;
end;
A5: ((ex y being (Element of D()) st (ex f being (Function of ( NAT ),D()) st ((y = ( f . n() ) & ( f . ( 0 ) ) = A()) & (for n being (Element of ( NAT )) holds Q[ n,( f . n ),( f . ( n + 1 ) ) ])))) & (for y1,y2 being (Element of D()) holds (((ex f being (Function of ( NAT ),D()) st ((y1 = ( f . n() ) & ( f . ( 0 ) ) = A()) & (for n being (Element of ( NAT )) holds Q[ n,( f . n ),( f . ( n + 1 ) ) ]))) & (ex f being (Function of ( NAT ),D()) st ((y2 = ( f . n() ) & ( f . ( 0 ) ) = A()) & (for n being (Element of ( NAT )) holds Q[ n,( f . n ),( f . ( n + 1 ) ) ])))) implies y1 = y2))) from CKB15:sch 1(A1,A2);
then consider y being (Element of D()),f being (Function of ( NAT ),D()) such that A6: (y = ( f . n() ) & ( f . ( 0 ) ) = A()) and A7: (for n being (Element of ( NAT )) holds Q[ n,( f . n ),( f . ( n + 1 ) ) ]);
thus (ex y being (Element of D()) st (ex f being (Function of ( NAT ),D()) st ((y = ( f . n() ) & ( f . ( 0 ) ) = A()) & (for n being Nat holds ( f . ( n + 1 ) ) = RecFun(n,( f . n ))))))
proof
take y;
take f;
thus (y = ( f . n() ) & ( f . ( 0 ) ) = A()) by A6;
let n being Nat;
reconsider n as (Element of ( NAT )) by ORDINAL1:def 12;
Q[ n,( f . n ),( f . ( n + 1 ) ) ] by A7;
hence thesis;
end;

let y1 being (Element of D());
let y2 being (Element of D());
given f being (Function of ( NAT ),D()) such that
A8: (y1 = ( f . n() ) & ( f . ( 0 ) ) = A())
and
A9: (for n being Nat holds ( f . ( n + 1 ) ) = RecFun(n,( f . n )));

A10: (for n being (Element of ( NAT )) holds Q[ n,( f . n ),( f . ( n + 1 ) ) ]) by A9;
given f2 being (Function of ( NAT ),D()) such that
A11: (y2 = ( f2 . n() ) & ( f2 . ( 0 ) ) = A())
and
A12: (for n being Nat holds ( f2 . ( n + 1 ) ) = RecFun(n,( f2 . n )));

(for n being (Element of ( NAT )) holds Q[ n,( f2 . n ),( f2 . ( n + 1 ) ) ]) by A12;
hence thesis by A5,A8,A11,A10;
end;
