environ
vocabularies NUMBERS,REAL_1,SUBSET_1,SEQ_1,FDIFF_1,FUNCT_1,RCOMP_1,PARTFUN1,ARYTM_1,VALUED_0,SEQ_2,ORDINAL2,CARD_1,RELAT_1,ARYTM_3,XREAL_0,ORDINAL1,XXREAL_0,COMPLEX1,NAT_1,TARSKI,VALUED_1,FUNCT_2,FUNCOP_1,XXREAL_1,FCONT_1,SQUARE_1,XBOOLE_0,ORDINAL4,LIMFUNC1;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,COMPLEX1,REAL_1,NAT_1,FUNCT_1,FUNCT_2,VALUED_0,VALUED_1,SEQ_1,RELSET_1,SEQ_2,PARTFUN1,SQUARE_1,PARTFUN2,RFUNCT_1,RCOMP_1,FCONT_1,FDIFF_1,LIMFUNC1,RECDEF_1,CKB1;
definitions TARSKI,XBOOLE_0,FDIFF_1,SQUARE_1,SUBSET_1,LIMFUNC1,PROB_1,VALUED_0,VALUED_1,SEQM_3;
theorems TARSKI,FUNCT_1,FUNCT_2,NAT_1,SEQ_1,SEQ_2,SEQM_3,SEQ_4,ABSVALUE,PARTFUN1,PARTFUN2,RCOMP_1,RFUNCT_1,RFUNCT_2,FCONT_1,FDIFF_1,SCHEME1,ROLLE,FCONT_3,FUNCT_3,RELAT_1,RELSET_1,XBOOLE_0,XBOOLE_1,XCMPLX_0,XCMPLX_1,COMPLEX1,FUNCOP_1,XREAL_1,XXREAL_0,ORDINAL1,VALUED_1,XXREAL_1,VALUED_0,CKB2;
schemes NAT_1,RECDEF_1,SEQ_1,SCHEME1,FUNCT_2;
registrations ORDINAL1,RELSET_1,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,NAT_1,MEMBERED,SEQM_3,RCOMP_1,RFUNCT_2,FDIFF_1,FCONT_3,VALUED_0,VALUED_1,FUNCT_2,FUNCOP_1,SEQ_4;
constructors PARTFUN1,REAL_1,SQUARE_1,NAT_1,COMPLEX1,SEQ_2,SEQM_3,PROB_1,RCOMP_1,PARTFUN2,RFUNCT_1,RFUNCT_2,FCONT_1,LIMFUNC1,FDIFF_1,SEQ_1,VALUED_1,RECDEF_1,RELSET_1,BINOP_2,RVSUM_1,CKB1;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve x for set;
reserve n for (Element of ( NAT ));
reserve a for Real_Sequence;
theorem
Th2: ((for n holds ( a . n ) = ( 2 * n )) implies a is  increasing  increasing (sequence of ( NAT )))
proof
assume A1: (for n holds ( a . n ) = ( 2 * n ));
A2: a is  increasing
proof
let n;
A3: ( ( 2 * n ) + ( 0 ) ) < ( ( 2 * n ) + 2 ) by XREAL_1:8;
( ( 2 * n ) + 2 ) = ( 2 * ( n + 1 ) )
.= ( a . ( n + 1 ) ) by A1;
hence ( a . n ) < ( a . ( n + 1 ) ) by A1,A3;
end;
A4:now
let x;
assume x in ( NAT );
then reconsider n = x as (Element of ( NAT ));
( a . n ) = ( 2 * n ) by A1;
hence ( a . x ) in ( NAT );
end;
( dom a ) = ( NAT ) by FUNCT_2:def 1;
hence thesis by A2,A4,FUNCT_2:3;
end;
