environ
vocabularies NUMBERS,REAL_1,SUBSET_1,SEQ_1,FDIFF_1,FUNCT_1,RCOMP_1,PARTFUN1,ARYTM_1,VALUED_0,SEQ_2,ORDINAL2,CARD_1,RELAT_1,ARYTM_3,XREAL_0,ORDINAL1,XXREAL_0,COMPLEX1,NAT_1,TARSKI,VALUED_1,FUNCT_2,FUNCOP_1,XXREAL_1,FCONT_1,SQUARE_1,XBOOLE_0,ORDINAL4,LIMFUNC1;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,COMPLEX1,REAL_1,NAT_1,FUNCT_1,FUNCT_2,VALUED_0,VALUED_1,SEQ_1,RELSET_1,SEQ_2,PARTFUN1,SQUARE_1,PARTFUN2,RFUNCT_1,RCOMP_1,FCONT_1,FDIFF_1,LIMFUNC1,RECDEF_1,CKB1;
definitions TARSKI,XBOOLE_0,FDIFF_1,SQUARE_1,SUBSET_1,LIMFUNC1,PROB_1,VALUED_0,VALUED_1,SEQM_3;
theorems TARSKI,FUNCT_1,FUNCT_2,NAT_1,SEQ_1,SEQ_2,SEQM_3,SEQ_4,ABSVALUE,PARTFUN1,PARTFUN2,RCOMP_1,RFUNCT_1,RFUNCT_2,FCONT_1,FDIFF_1,SCHEME1,ROLLE,FCONT_3,FUNCT_3,RELAT_1,RELSET_1,XBOOLE_0,XBOOLE_1,XCMPLX_0,XCMPLX_1,COMPLEX1,FUNCOP_1,XREAL_1,XXREAL_0,ORDINAL1,VALUED_1,XXREAL_1,VALUED_0,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8;
schemes NAT_1,RECDEF_1,SEQ_1,SCHEME1,FUNCT_2;
registrations ORDINAL1,RELSET_1,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,NAT_1,MEMBERED,SEQM_3,RCOMP_1,RFUNCT_2,FDIFF_1,FCONT_3,VALUED_0,VALUED_1,FUNCT_2,FUNCOP_1,SEQ_4;
constructors PARTFUN1,REAL_1,SQUARE_1,NAT_1,COMPLEX1,SEQ_2,SEQM_3,PROB_1,RCOMP_1,PARTFUN2,RFUNCT_1,RFUNCT_2,FCONT_1,LIMFUNC1,FDIFF_1,SEQ_1,VALUED_1,RECDEF_1,RELSET_1,BINOP_2,RVSUM_1,CKB1;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve x for set;
reserve r for Real;
reserve g for Real;
reserve g1 for Real;
reserve n for (Element of ( NAT ));
reserve b for Real_Sequence;
reserve h for  convergent_to_0 Real_Sequence;
reserve c for  constant Real_Sequence;
reserve f for (PartFunc of ( REAL ),( REAL ));
theorem
Th8: ((ex N being (Neighbourhood of r) st N c= ( dom f )) implies (ex h st (ex c st ((( rng c ) = { r } & ( rng ( h + c ) ) c= ( dom f )) & { r } c= ( dom f )))))
proof
given N being (Neighbourhood of r) such that
A1: N c= ( dom f );

reconsider a = ( ( NAT ) --> r ) as Real_Sequence by FUNCOP_1:45;
consider g being  real number such that A2: ( 0 ) < g and A3: N = ]. ( r - g ),( r + g ) .[ by RCOMP_1:def 6;
reconsider a as  constant Real_Sequence;
deffunc G((Element of ( NAT ))) = ( g / ( $1 + 2 ) );
consider b such that A4: (for n holds ( b . n ) = G(n)) from SEQ_1:sch 1;
A5: ( lim b ) = ( 0 ) by A4,SEQ_4:31;
A6: b is  convergent by A4,SEQ_4:31;
now
let n;
( 0 ) < ( g / ( n + 2 ) ) by A2;
hence ( 0 ) <> ( b . n ) by A4;
end;
then b is  non-zero by SEQ_1:5;
then reconsider b as  convergent_to_0 Real_Sequence by A6,A5,FDIFF_1:def 1;
take b;
take a;
thus ( rng a ) = { r }
proof
thus ( rng a ) c= { r }
proof
let x;
assume x in ( rng a );
then (ex n st x = ( a . n )) by FUNCT_2:113;
then x = r by FUNCOP_1:7;
hence thesis by TARSKI:def 1;
end;

let x;
assume x in { r };
then x = r by TARSKI:def 1
.= ( a . ( 0 ) ) by FUNCOP_1:7;
hence thesis by VALUED_0:28;
end;

thus ( rng ( b + a ) ) c= ( dom f )
proof
let x;
assume x in ( rng ( b + a ) );
then consider n such that A7: x = ( ( b + a ) . n ) by FUNCT_2:113;
( ( 0 ) + 1 ) < ( n + 2 ) by XREAL_1:8;
then ( g * 1 ) < ( g * ( n + 2 ) ) by A2,XREAL_1:97;
then ( g * ( ( n + 2 ) " ) ) < ( ( g * ( n + 2 ) ) * ( ( n + 2 ) " ) ) by XREAL_1:68;
then ( g * ( ( n + 2 ) " ) ) < ( g * ( ( n + 2 ) * ( ( n + 2 ) " ) ) );
then ( g * ( ( n + 2 ) " ) ) < ( g * 1 ) by XCMPLX_0:def 7;
then ( g / ( n + 2 ) ) < g by XCMPLX_0:def 9;
then A8: ( r + ( g / ( n + 2 ) ) ) < ( r + g ) by XREAL_1:6;
A9: ( r - g ) < ( r - ( 0 ) ) by A2,XREAL_1:15;
( r + ( 0 ) ) < ( r + ( g / ( n + 2 ) ) ) by A2,XREAL_1:8;
then ( r - g ) < ( r + ( g / ( n + 2 ) ) ) by A9,XXREAL_0:2;
then A10: ( r + ( g / ( n + 2 ) ) ) in { g1: (( r - g ) < g1 & g1 < ( r + g )) } by A8;
x = ( ( b . n ) + ( a . n ) ) by A7,SEQ_1:7
.= ( ( g / ( n + 2 ) ) + ( a . n ) ) by A4
.= ( ( g / ( n + 2 ) ) + r ) by FUNCOP_1:7;
then x in N by A3,A10,RCOMP_1:def 2;
hence thesis by A1;
end;

let x;
assume x in { r };
then x = r by TARSKI:def 1;
then x in N by RCOMP_1:16;
hence thesis by A1;
end;
