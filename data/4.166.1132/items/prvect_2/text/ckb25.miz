environ
vocabularies SEQ_1,XREAL_0,ORDINAL1,SUBSET_1,NUMBERS,FUNCT_1,COMPLEX1,ARYTM_1,SEQ_2,ORDINAL2,CARD_1,ARYTM_3,XXREAL_0,FINSEQ_1,NAT_1,RVSUM_1,SQUARE_1,RELAT_1,CARD_3,FINSEQ_2,ZFMISC_1,MCART_1,PRVECT_1,XBOOLE_0,RLVECT_1,GROUP_2,STRUCT_0,ALGSTR_0,BINOP_1,VECTSP_1,REAL_1,SUPINF_2,FUNCT_6,FINSEQOP,SETWISEO,NORMSP_1,TARSKI,PRE_TOPC,EUCLID,FUNCT_2,REAL_NS1,REWRITE1,RSSPACE3,PRVECT_2,NORMSP_0,METRIC_1,RELAT_2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,CARD_3,XCMPLX_0,XXREAL_0,NUMBERS,XREAL_0,COMPLEX1,NAT_1,RELAT_1,FUNCT_1,RVSUM_1,STRUCT_0,ALGSTR_0,FUNCT_2,FUNCT_3,BINOP_1,REAL_1,SEQ_1,SEQ_2,RLVECT_1,VECTSP_1,SETWISEO,FINSEQ_1,FINSEQ_2,FINSEQOP,SQUARE_1,PRE_TOPC,EUCLID,PRVECT_1,NORMSP_0,NORMSP_1,RSSPACE3,LOPBAN_1,REAL_NS1,CKB4,CKB7,CKB9,CKB10,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
definitions RLVECT_1,NORMSP_1,FINSEQ_2,EUCLID,STRUCT_0,SQUARE_1,ALGSTR_0,NORMSP_0,CKB4,CKB9,CKB10,CKB14,CKB16,CKB17,CKB18,CKB19,CKB20;
theorems BINOP_1,FUNCT_1,FUNCT_2,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSEQOP,FUNCOP_1,SETWISEO,TARSKI,CARD_3,RLVECT_1,RELAT_1,RVSUM_1,ABSVALUE,FVSUM_1,SEQ_2,PRVECT_1,NORMSP_1,SQUARE_1,EUCLID,XREAL_1,LOPBAN_1,RSSPACE3,REAL_NS1,XXREAL_0,VALUED_1,XREAL_0,NORMSP_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB6,CKB8,CKB9,CKB10,CKB14,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24;
schemes FUNCT_1,BINOP_1,FUNCT_2,FINSEQ_1,PRVECT_1,CLASSES1;
registrations STRUCT_0,FINSEQ_2,FINSEQ_1,CARD_3,RLVECT_1,PRVECT_1,XREAL_0,MEMBERED,NORMSP_1,REAL_NS1,ORDINAL1,FUNCT_1,FUNCT_2,RELAT_1,XBOOLE_0,NUMBERS,VALUED_0,NORMSP_0,CARD_1,CKB5,CKB11;
constructors FUNCT_3,FINSEQOP,REAL_1,SEQ_2,COMPLEX1,SQUARE_1,BINOP_2,SETWISEO,PRVECT_1,RSSPACE3,LOPBAN_1,REAL_NS1,SEQ_1,RVSUM_1,NORMSP_1,RELSET_1,CKB4,CKB7,CKB9,CKB10,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
requirements NUMERALS,BOOLE,SUBSET,ARITHM;
begin
theorem
Lm5: (for G being RealLinearSpace-Sequence holds ( product G ) is  vector-distributive  scalar-distributive  scalar-associative  scalar-unital)
proof
deffunc ad(addLoopStr) = (the addF of $1);
let G being RealLinearSpace-Sequence;
reconsider GS = RLSStruct (# ( product ( carr G ) ),( zeros G ),[: ( addop G ) :],[: ( multop G ) :] #) as non  empty RLSStruct;
( dom G ) = ( Seg ( len G ) ) by FINSEQ_1:def 3;
then ( dom G ) = ( Seg ( len ( carr G ) ) ) by CKB14:def 1;
then A1: ( dom G ) = ( dom ( carr G ) ) by FINSEQ_1:def 3;
now
let a1 being  real number;
let b1 being  real number;
reconsider a = a1,b = b1 as Real by XREAL_0:def 1;
let v being (VECTOR of GS);
let w being (VECTOR of GS);
reconsider v1 = v,w1 = w as (Element of ( product ( carr G ) ));
A2:now
let x being set;
assume x in ( dom ( carr G ) );
then reconsider i = x as (Element of ( dom ( carr G ) ));
reconsider vi = ( v1 . i ) as (VECTOR of ( G . i )) by A1,CKB14:def 1;
( ( [: ( multop G ) :] . (1,v1) ) . x ) = ( 1 * vi ) by CKB24:1;
hence ( ( [: ( multop G ) :] . (1,v1) ) . x ) = ( v1 . x ) by RLVECT_1:def 8;
end;
A3:now
let x being set;
assume x in ( dom ( carr G ) );
then reconsider i = x as (Element of ( dom ( carr G ) ));
reconsider vi = ( v1 . i ) as (VECTOR of ( G . i )) by A1,CKB14:def 1;
( ( [: ( multop G ) :] . (( a + b ),v1) ) . i ) = ( ( a + b ) * vi ) by CKB24:1
.= ( ( a * vi ) + ( b * vi ) ) by RLVECT_1:def 6
.= ( ad(( G . i )) . (( ( [: ( multop G ) :] . (a,v1) ) . i ),( b * vi )) ) by CKB24:1
.= ( ad(( G . i )) . (( ( [: ( multop G ) :] . (a,v1) ) . i ),( ( [: ( multop G ) :] . (b,v1) ) . i )) ) by CKB24:1;
hence ( ( [: ( multop G ) :] . (( a + b ),v1) ) . x ) = ( ( [: ( addop G ) :] . (( [: ( multop G ) :] . (a,v1) ),( [: ( multop G ) :] . (b,v1) )) ) . x ) by CKB23:1;
end;
A4:now
let x being set;
assume x in ( dom ( carr G ) );
then reconsider i = x as (Element of ( dom ( carr G ) ));
reconsider vi = ( v1 . i ),wi = ( w1 . i ) as (VECTOR of ( G . i )) by A1,CKB14:def 1;
( ( [: ( multop G ) :] . (a,( [: ( addop G ) :] . (v1,w1) )) ) . i ) = ( (the Mult of ( G . i )) . (a,( ( [: ( addop G ) :] . (v1,w1) ) . i )) ) by CKB24:1
.= ( a * ( vi + wi ) ) by CKB23:1
.= ( ( a * vi ) + ( a * wi ) ) by RLVECT_1:def 5
.= ( ad(( G . i )) . (( ( [: ( multop G ) :] . (a,v1) ) . i ),( a * wi )) ) by CKB24:1
.= ( ad(( G . i )) . (( ( [: ( multop G ) :] . (a,v1) ) . i ),( ( [: ( multop G ) :] . (a,w1) ) . i )) ) by CKB24:1;
hence ( ( [: ( multop G ) :] . (a,( [: ( addop G ) :] . (v1,w1) )) ) . x ) = ( ( [: ( addop G ) :] . (( [: ( multop G ) :] . (a,v1) ),( [: ( multop G ) :] . (a,w1) )) ) . x ) by CKB23:1;
end;
(( dom ( [: ( multop G ) :] . (a,( [: ( addop G ) :] . (v1,w1) )) ) ) = ( dom ( carr G ) ) & ( dom ( [: ( addop G ) :] . (( [: ( multop G ) :] . (a,v1) ),( [: ( multop G ) :] . (a,w1) )) ) ) = ( dom ( carr G ) )) by CARD_3:9;
hence ( a1 * ( v + w ) ) = ( ( a1 * v ) + ( a1 * w ) ) by A4,FUNCT_1:2;
A5:now
let x being set;
assume x in ( dom ( carr G ) );
then reconsider i = x as (Element of ( dom ( carr G ) ));
reconsider vi = ( v1 . i ) as (VECTOR of ( G . i )) by A1,CKB14:def 1;
( ( [: ( multop G ) :] . (( a * b ),v1) ) . i ) = ( ( a * b ) * vi ) by CKB24:1
.= ( a * ( b * vi ) ) by RLVECT_1:def 7
.= ( (the Mult of ( G . i )) . (a,( ( [: ( multop G ) :] . (b,v1) ) . i )) ) by CKB24:1;
hence ( ( [: ( multop G ) :] . (( a * b ),v1) ) . x ) = ( ( [: ( multop G ) :] . (a,( [: ( multop G ) :] . (b,v1) )) ) . x ) by CKB24:1;
end;
(( dom ( [: ( multop G ) :] . (( a + b ),v1) ) ) = ( dom ( carr G ) ) & ( dom ( [: ( addop G ) :] . (( [: ( multop G ) :] . (a,v1) ),( [: ( multop G ) :] . (b,v1) )) ) ) = ( dom ( carr G ) )) by CARD_3:9;
hence ( ( a1 + b1 ) * v ) = ( ( a1 * v ) + ( b1 * v ) ) by A3,FUNCT_1:2;
(( dom ( [: ( multop G ) :] . (( a * b ),v1) ) ) = ( dom ( carr G ) ) & ( dom ( [: ( multop G ) :] . (a,( [: ( multop G ) :] . (b,v1) )) ) ) = ( dom ( carr G ) )) by CARD_3:9;
hence ( ( a1 * b1 ) * v ) = ( a1 * ( b1 * v ) ) by A5,FUNCT_1:2;
(( dom ( [: ( multop G ) :] . (1,v1) ) ) = ( dom ( carr G ) ) & ( dom v1 ) = ( dom ( carr G ) )) by CARD_3:9;
hence ( 1 * v ) = v by A2,FUNCT_1:2;
end;
hence thesis by RLVECT_1:def 5,RLVECT_1:def 6,RLVECT_1:def 7,RLVECT_1:def 8;
end;
