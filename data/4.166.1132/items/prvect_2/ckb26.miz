environ
vocabularies SEQ_1,XREAL_0,ORDINAL1,SUBSET_1,NUMBERS,FUNCT_1,COMPLEX1,ARYTM_1,SEQ_2,ORDINAL2,CARD_1,ARYTM_3,XXREAL_0,FINSEQ_1,NAT_1,RVSUM_1,SQUARE_1,RELAT_1,CARD_3,FINSEQ_2,ZFMISC_1,MCART_1,PRVECT_1,XBOOLE_0,RLVECT_1,GROUP_2,STRUCT_0,ALGSTR_0,BINOP_1,VECTSP_1,REAL_1,SUPINF_2,FUNCT_6,FINSEQOP,SETWISEO,NORMSP_1,TARSKI,PRE_TOPC,EUCLID,FUNCT_2,REAL_NS1,REWRITE1,RSSPACE3,PRVECT_2,NORMSP_0,METRIC_1,RELAT_2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,CARD_3,XCMPLX_0,XXREAL_0,NUMBERS,XREAL_0,COMPLEX1,NAT_1,RELAT_1,FUNCT_1,RVSUM_1,STRUCT_0,ALGSTR_0,FUNCT_2,FUNCT_3,BINOP_1,REAL_1,SEQ_1,SEQ_2,RLVECT_1,VECTSP_1,SETWISEO,FINSEQ_1,FINSEQ_2,FINSEQOP,SQUARE_1,PRE_TOPC,EUCLID,PRVECT_1,NORMSP_0,NORMSP_1,RSSPACE3,LOPBAN_1,REAL_NS1,CKB4,CKB7,CKB9,CKB10,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
definitions RLVECT_1,NORMSP_1,FINSEQ_2,EUCLID,STRUCT_0,SQUARE_1,ALGSTR_0,NORMSP_0,CKB4,CKB9,CKB10,CKB14,CKB16,CKB17,CKB18,CKB19,CKB20;
theorems BINOP_1,FUNCT_1,FUNCT_2,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSEQOP,FUNCOP_1,SETWISEO,TARSKI,CARD_3,RLVECT_1,RELAT_1,RVSUM_1,ABSVALUE,FVSUM_1,SEQ_2,PRVECT_1,NORMSP_1,SQUARE_1,EUCLID,XREAL_1,LOPBAN_1,RSSPACE3,REAL_NS1,XXREAL_0,VALUED_1,XREAL_0,NORMSP_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB6,CKB8,CKB9,CKB10,CKB14,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25;
schemes FUNCT_1,BINOP_1,FUNCT_2,FINSEQ_1,PRVECT_1,CLASSES1;
registrations STRUCT_0,FINSEQ_2,FINSEQ_1,CARD_3,RLVECT_1,PRVECT_1,XREAL_0,MEMBERED,NORMSP_1,REAL_NS1,ORDINAL1,FUNCT_1,FUNCT_2,RELAT_1,XBOOLE_0,NUMBERS,VALUED_0,NORMSP_0,CARD_1,CKB5,CKB11;
constructors FUNCT_3,FINSEQOP,REAL_1,SEQ_2,COMPLEX1,SQUARE_1,BINOP_2,SETWISEO,PRVECT_1,RSSPACE3,LOPBAN_1,REAL_NS1,SEQ_1,RVSUM_1,NORMSP_1,RELSET_1,CKB4,CKB7,CKB9,CKB10,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
requirements NUMERALS,BOOLE,SUBSET,ARITHM;
begin
registration
let G being RealLinearSpace-Sequence;
cluster ( product G ) ->  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital;
coherence
proof
deffunc zr(addLoopStr) = (the ZeroF of $1);
reconsider GS = RLSStruct (# ( product ( carr G ) ),( zeros G ),[: ( addop G ) :],[: ( multop G ) :] #) as non empty RLSStruct;
deffunc car(1-sorted) = (the carrier of $1);
deffunc ad(addLoopStr) = (the addF of $1);
A1:now
let i being (Element of ( dom ( carr G ) ));
( dom G ) = ( Seg ( len G ) ) by FINSEQ_1:def 3
.= ( Seg ( len ( carr G ) ) ) by CKB14:def 1
.= ( dom ( carr G ) ) by FINSEQ_1:def 3;
hence ( ( carr G ) . i ) = car(( G . i )) by CKB14:def 1;
end;
now
let i being (Element of ( dom ( carr G ) ));
(( ( addop G ) . i ) = ad(( G . i )) & ( ( carr G ) . i ) = car(( G . i ))) by A1,CKB16:def 1;
hence ( ( addop G ) . i ) is  associative by FVSUM_1:2;
end;
then A2: [: ( addop G ) :] is  associative by PRVECT_1:18;
now
let i being (Element of ( dom ( carr G ) ));
A3: ( ( zeros G ) . i ) = ( 0. ( G . i ) ) by CKB18:def 1;
(( ( addop G ) . i ) = ad(( G . i )) & ( ( carr G ) . i ) = car(( G . i ))) by A1,CKB16:def 1;
hence ( ( zeros G ) . i ) is_a_unity_wrt ( ( addop G ) . i ) by A3,PRVECT_1:1;
end;
then A4: ( zeros G ) is_a_unity_wrt [: ( addop G ) :] by PRVECT_1:19;
A5: GS is  right_complementable
proof
let x being (Element of GS);
reconsider y = ( ( Frege ( complop G ) ) . x ) as (Element of GS) by FUNCT_2:5;
take y;
now
let i being (Element of ( dom ( carr G ) ));
( 0. ( G . i ) ) = zr(( G . i ));
then A6: zr(( G . i )) is_a_unity_wrt ad(( G . i )) by PRVECT_1:1;
A7: ( ( complop G ) . i ) = ( comp ( G . i ) ) by CKB17:def 1;
(( ( carr G ) . i ) = car(( G . i )) & ( ( addop G ) . i ) = ad(( G . i ))) by A1,CKB16:def 1;
hence (( ( complop G ) . i ) is_an_inverseOp_wrt ( ( addop G ) . i ) & ( ( addop G ) . i ) is  having_a_unity) by A6,A7,PRVECT_1:2,SETWISEO:def 2;
end;
then ( Frege ( complop G ) ) is_an_inverseOp_wrt [: ( addop G ) :] by PRVECT_1:20;
then ( [: ( addop G ) :] . (x,y) ) = ( the_unity_wrt [: ( addop G ) :] ) by FINSEQOP:def 1;
hence thesis by A4,BINOP_1:def 8;
end;
now
let i being (Element of ( dom ( carr G ) ));
(( ( addop G ) . i ) = ad(( G . i )) & ( ( carr G ) . i ) = car(( G . i ))) by A1,CKB16:def 1;
hence ( ( addop G ) . i ) is  commutative by FVSUM_1:1;
end;
then [: ( addop G ) :] is  commutative by PRVECT_1:17;
hence thesis by A2,A4,A5,CKB21:1,CKB22:1,CKB25:1;
end;
end;
