environ
vocabularies NUMBERS,NAT_1,INT_1,ARYTM_1,ARYTM_3,CARD_1,XXREAL_0,SUBSET_1,RELAT_1,NEWTON,POWER,TARSKI,XBOOLE_0,FINSEQ_2,FINSEQ_1,FUNCT_1,PARTFUN1,CARD_3,ORDINAL4,RADIX_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,INT_1,NAT_1,NAT_D,FUNCT_1,PARTFUN1,NEWTON,POWER,FINSEQ_1,FINSEQ_2,TREES_4,GR_CY_1,XXREAL_0,MESFUNC1,CKB8,CKB9,CKB19,CKB21,CKB22,CKB25,CKB26,CKB27;
definitions TARSKI,RVSUM_1,CKB8,CKB9,CKB21,CKB22,CKB25,CKB26,CKB27;
theorems NAT_1,NAT_2,INT_1,FINSEQ_1,EULER_1,PREPOWER,POWER,RVSUM_1,FINSEQ_2,FINSEQ_4,TARSKI,FUNCT_1,PEPIN,FINSEQ_5,NEWTON,XCMPLX_1,XREAL_1,XXREAL_0,FINSOP_1,ORDINAL1,NAT_D,PARTFUN1,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27;
schemes NAT_1,FINSEQ_2;
registrations RELSET_1,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,NEWTON,XBOOLE_0,VALUED_0,POWER,CARD_1,FINSEQ_1,CKB18;
constructors REAL_1,NAT_D,FINSOP_1,NEWTON,POWER,MESFUNC1,WSIERP_1,GR_CY_1,BINOP_2,CKB8,CKB9,CKB19,CKB21,CKB22,CKB25,CKB26,CKB27;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve i for Nat;
reserve k for Nat;
reserve x for Nat;
definition
let i being Nat;
let k being Nat;
let x being Nat;
func DigitDC (x,i,k) -> (Element of ( k -SD )) equals 
( ( x mod ( ( Radix k ) |^ i ) ) div ( ( Radix k ) |^ ( i -' 1 ) ) );
coherence
proof
reconsider i,k as (Element of ( NAT )) by ORDINAL1:def 12;
set T = ( ( Radix k ) |^ i );
set S = ( ( Radix k ) |^ ( i -' 1 ) );
defpred P[ Nat ]
 means
( ( $1 mod T ) div S ) is (Element of ( k -SD ));
A1: ( 0 ) in ( k -SD ) by CKB17:1;
A2: ( Radix k ) <> ( 0 ) by POWER:34;
then A3: S > ( 0 ) by NAT_1:14,PREPOWER:11;
then A4: ( ( 0 ) div S ) = ( 0 ) by NAT_D:27;
A5: ( Radix k ) >= 1 by A2,NAT_1:14;
A6: (for x being Nat holds (P[ x ] implies P[ ( x + 1 ) ]))
proof
reconsider R = ( ( Radix k ) - 1 ) as (Element of ( NAT )) by A5,INT_1:3,XREAL_1:48;
let xx being Nat;
assume ( ( xx mod T ) div S ) is (Element of ( k -SD ));
set X = ( ( ( xx + 1 ) mod T ) div S );
per cases ;
suppose A7: i = ( 0 );

( ( Radix k ) |^ i ) = ( ( Radix k ) to_power i )
.= 1 by A7,POWER:24;
then ( ( xx + 1 ) mod T ) = ( ( ( xx + 1 ) * 1 ) mod 1 )
.= ( 0 ) by NAT_D:13;
then X = ( 0 ) by A3,NAT_D:27;
hence thesis by CKB17:1;
end;
suppose A8: i > ( 0 );

( - 1 ) >= ( - ( Radix k ) ) by A5,XREAL_1:24;
then A9: (X is (Element of ( INT )) & ( 0 ) >= ( ( - ( Radix k ) ) + 1 )) by INT_1:def 2,XREAL_1:59;
X < ( ( ( Radix k ) - 1 ) + 1 ) by A2,A8,CKB5:1;
then X <= R by NAT_1:13;
then X in ( k -SD ) by A9;
hence thesis;
end;
end;
T > ( 0 ) by A2,NAT_1:14,PREPOWER:11;
then A10: P[ ( 0 ) ] by A4,A1,NAT_D:24;
(for x being Nat holds P[ x ]) from NAT_1:sch 2(A10,A6);
hence thesis;
end;
end;
