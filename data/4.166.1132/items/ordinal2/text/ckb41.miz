environ
vocabularies ORDINAL1,FUNCT_1,XBOOLE_0,TARSKI,ZFMISC_1,RELAT_1,SETFAM_1,SUBSET_1,FUNCOP_1,ORDINAL2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,SETFAM_1,FUNCOP_1,CKB7,CKB17,CKB18,CKB31,CKB33;
definitions ORDINAL1,TARSKI,XBOOLE_0,CKB7,CKB17,CKB18,CKB31;
theorems TARSKI,XBOOLE_0,ORDINAL1,SETFAM_1,ZFMISC_1,FUNCT_1,RELAT_1,XBOOLE_1,FUNCOP_1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB31,CKB36;
schemes XBOOLE_0,FUNCT_1,ORDINAL1,CKB1,CKB30,CKB38,CKB39,CKB40;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,ORDINAL1,FUNCOP_1,CKB16,CKB32,CKB34,CKB35,CKB37;
constructors SETFAM_1,ORDINAL1,FUNCOP_1,CKB7,CKB17,CKB18,CKB31;
requirements SUBSET,BOOLE,NUMERALS;
begin
reserve A for Ordinal;
reserve B for Ordinal;
reserve C for Ordinal;
reserve D for Ordinal;
reserve x for set;
reserve L for T-Sequence;
scheme TSResult { L() -> T-Sequence,F(Ordinal) -> set,A() -> Ordinal,B() -> set,C(Ordinal,set) -> set,D(Ordinal,T-Sequence) -> set } : (for A holds (A in ( dom L() ) implies ( L() . A ) = F(A)))
provided
A1: (for A holds (for x holds (x = F(A) iff (ex L st ((((x = ( last L ) & ( dom L ) = ( succ A )) & ( L . ( {} ) ) = B()) & (for C holds (( succ C ) in ( succ A ) implies ( L . ( succ C ) ) = C(C,( L . C ))))) & (for C holds (((C in ( succ A ) & C <> ( {} )) & C is  limit_ordinal) implies ( L . C ) = D(C,( L | C )))))))))
and
A2: ( dom L() ) = A()
and
A3: (( {} ) in A() implies ( L() . ( {} ) ) = B())
and
A4: (for A holds (( succ A ) in A() implies ( L() . ( succ A ) ) = C(A,( L() . A ))))
and
A5: (for A holds (((A in A() & A <> ( {} )) & A is  limit_ordinal) implies ( L() . A ) = D(A,( L() | A ))))
proof
let A;
set L = ( L() | ( succ A ) );
assume A in ( dom L() );
then A6: ( succ A ) c= ( dom L() ) by ORDINAL1:21;
A7: (for C holds (( succ C ) in ( succ A ) implies ( L . ( succ C ) ) = C(C,( L . C ))))
proof
let C;
assume that
A8: ( succ C ) in ( succ A );
C in ( succ C ) by ORDINAL1:6;
then A9: ( L . C ) = ( L() . C ) by A8,FUNCT_1:49,ORDINAL1:10;
( L . ( succ C ) ) = ( L() . ( succ C ) ) by A8,FUNCT_1:49;
hence thesis by A2,A4,A6,A8,A9;
end;
A10: (for C holds (((C in ( succ A ) & C <> ( {} )) & C is  limit_ordinal) implies ( L . C ) = D(C,( L | C ))))
proof
let C;
assume that
A11: C in ( succ A )
and
A12: (C <> ( {} ) & C is  limit_ordinal);
C c= ( succ A ) by A11,ORDINAL1:def 2;
then A13: ( L | C ) = ( L() | C ) by FUNCT_1:51;
( L . C ) = ( L() . C ) by A11,FUNCT_1:49;
hence thesis by A2,A5,A6,A11,A12,A13;
end;
( {} ) c= ( succ A );
then ( {} ) c< ( succ A ) by XBOOLE_0:def 8;
then A14: (( {} ) in ( succ A ) & ( L . ( {} ) ) = ( L() . ( {} ) )) by FUNCT_1:49,ORDINAL1:11;
A15: ( dom L ) = ( succ A ) by A6,RELAT_1:62;
then (A in ( succ A ) & ( last L ) = ( L . A )) by CKB3:1,ORDINAL1:21;
then ( last L ) = ( L() . A ) by FUNCT_1:49;
hence thesis by A1,A2,A3,A6,A15,A14,A7,A10;
end;
