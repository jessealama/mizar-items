environ
vocabularies RLVECT_1,ALGSTR_0,VECTSP_1,XBOOLE_0,SUBSET_1,RELAT_1,ARYTM_1,ARYTM_3,SUPINF_2,XCMPLX_0,ORDINAL1,COMPLEX1,XREAL_0,NUMBERS,CARD_1,SQUARE_1,COMPLFLD,GROUP_1,REAL_1,STRUCT_0,HAHNBAN,FUNCT_1,FUNCOP_1,MSSUBFAM,UNIALG_1,BINOP_1,LATTICES,MESFUNC1,ZFMISC_1,XXREAL_0,RLSUB_1,TARSKI,REALSET1,POWER,HAHNBAN1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,REALSET1,NUMBERS,XCMPLX_0,XREAL_0,COMPLEX1,REAL_1,NAT_1,SQUARE_1,POWER,STRUCT_0,ALGSTR_0,RLVECT_1,GROUP_1,VECTSP_1,RLSUB_1,VECTSP_4,FUNCT_1,FUNCT_2,BINOP_1,RELSET_1,NATTRA_1,FUNCOP_1,HAHNBAN,COMPLFLD,XXREAL_0,GRCAT_1,CKB5,CKB6,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB43,CKB44,CKB50,CKB51,CKB52,CKB53,CKB55,CKB56,CKB59,CKB66,CKB67;
definitions TARSKI,RLSUB_1,HAHNBAN,SQUARE_1,BINOP_1,RLVECT_1,VECTSP_1,COMPLEX1,STRUCT_0,ALGSTR_0,GRCAT_1,CKB5,CKB6,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB44,CKB51,CKB52,CKB53,CKB55,CKB56,CKB59,CKB67;
theorems TARSKI,ZFMISC_1,ABSVALUE,FUNCT_1,FUNCT_2,COMPLEX1,COMPLFLD,VECTSP_1,FUNCOP_1,RLVECT_1,BINOP_1,HAHNBAN,VECTSP_4,XBOOLE_0,RELAT_1,XCMPLX_1,GROUP_1,XXREAL_0,XCMPLX_0,POWER,ALGSTR_0,XREAL_0,GRCAT_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB44,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56,CKB59,CKB67;
schemes FUNCT_2,BINOP_1,NAT_1;
registrations XBOOLE_0,FUNCT_1,RELSET_1,NUMBERS,XCMPLX_0,XREAL_0,MEMBERED,STRUCT_0,RLVECT_1,VECTSP_1,COMPLFLD,HAHNBAN,ALGSTR_0,CKB23,CKB24,CKB25,CKB26,CKB27,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB45,CKB46,CKB47,CKB48,CKB49,CKB57,CKB58,CKB60,CKB61,CKB62,CKB63,CKB64,CKB65,CKB68,CKB69,CKB70,CKB71,CKB72;
constructors ARYTM_0,REAL_1,SQUARE_1,NAT_1,BINOP_2,POWER,REALSET1,RLSUB_1,COMPLFLD,VECTSP_4,NATTRA_1,BORSUK_1,HAHNBAN,SUPINF_1,FUNCOP_1,GRCAT_1,CKB5,CKB6,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB44,CKB51,CKB52,CKB53,CKB55,CKB56,CKB59,CKB67;
requirements NUMERALS,SUBSET,BOOLE,ARITHM;
begin
registration
let V being  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over ( F_Complex );
cluster ( RealVS V ) ->  vector-distributive  scalar-distributive  scalar-associative  scalar-unital;
coherence
proof
thus (for a being  real number holds (for v,w being (Element of ( RealVS V )) holds ( a * ( v + w ) ) = ( ( a * v ) + ( a * w ) )))
proof
let a being  real number;
reconsider a as Real by XREAL_0:def 1;
let v being (Element of ( RealVS V ));
let w being (Element of ( RealVS V ));
set a1 = [** a,( 0 ) **];
A1: ( the addLoopStr of V ) = ( the addLoopStr of ( RealVS V ) ) by CKB67:def 1;
then reconsider v1 = v,w1 = w as (Element of V);
( a * ( v + w ) ) = ( [** a,( 0 ) **] * ( v1 + w1 ) ) by A1,CKB67:def 1
.= ( ( a1 * v1 ) + ( a1 * w1 ) ) by VECTSP_1:def 14
.= ( (the addF of V) . [ ( (the Mult of ( RealVS V )) . (a,v1) ),( [** a,( 0 ) **] * w1 ) ] ) by CKB67:def 1
.= ( ( a * v ) + ( a * w ) ) by A1,CKB67:def 1;
hence thesis;
end;

thus (for a,b being  real number holds (for v being (Element of ( RealVS V )) holds ( ( a + b ) * v ) = ( ( a * v ) + ( b * v ) )))
proof
let a being  real number;
let b being  real number;
reconsider a,b as Real by XREAL_0:def 1;
let v being (Element of ( RealVS V ));
set a1 = [** a,( 0 ) **];
set b1 = [** b,( 0 ) **];
A2: ( the addLoopStr of V ) = ( the addLoopStr of ( RealVS V ) ) by CKB67:def 1;
then reconsider v1 = v as (Element of V);
( [** a,( 0 ) **] + [** b,( 0 ) **] ) = [** ( a + b ),( 0 ) **];
then ( ( a + b ) * v ) = ( ( [** a,( 0 ) **] + [** b,( 0 ) **] ) * v1 ) by CKB67:def 1
.= ( ( a1 * v1 ) + ( b1 * v1 ) ) by VECTSP_1:def 15
.= ( (the addF of ( RealVS V )) . [ ( (the Mult of ( RealVS V )) . (a,v) ),( [** b,( 0 ) **] * v1 ) ] ) by A2,CKB67:def 1
.= ( ( a * v ) + ( b * v ) ) by CKB67:def 1;
hence thesis;
end;

thus (for a,b being  real number holds (for v being (Element of ( RealVS V )) holds ( ( a * b ) * v ) = ( a * ( b * v ) )))
proof
let a being  real number;
let b being  real number;
reconsider a,b as Real by XREAL_0:def 1;
let v being (Element of ( RealVS V ));
( the addLoopStr of V ) = ( the addLoopStr of ( RealVS V ) ) by CKB67:def 1;
then reconsider v1 = v as (Element of V);
[** ( a * b ),( 0 ) **] = ( [** a,( 0 ) **] * [** b,( 0 ) **] );
then ( ( a * b ) * v ) = ( ( [** a,( 0 ) **] * [** b,( 0 ) **] ) * v1 ) by CKB67:def 1
.= ( [** a,( 0 ) **] * ( [** b,( 0 ) **] * v1 ) ) by VECTSP_1:def 16
.= ( (the Mult of ( RealVS V )) . (a,( [** b,( 0 ) **] * v1 )) ) by CKB67:def 1
.= ( a * ( b * v ) ) by CKB67:def 1;
hence thesis;
end;

let v being (Element of ( RealVS V ));
( the addLoopStr of V ) = ( the addLoopStr of ( RealVS V ) ) by CKB67:def 1;
then reconsider v1 = v as (Element of V);
thus ( 1 * v ) = ( [** 1,( 0 ) **] * v1 ) by CKB67:def 1
.= v by COMPLFLD:8,VECTSP_1:def 17;
end;
end;
