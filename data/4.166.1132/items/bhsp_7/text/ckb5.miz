environ
vocabularies NUMBERS,BHSP_1,PRE_TOPC,REAL_1,COMPLEX1,ARYTM_1,ARYTM_3,XXREAL_0,XREAL_0,ORDINAL1,CARD_1,SUBSET_1,RELAT_1,HAHNBAN,BHSP_6,FINSET_1,XBOOLE_0,TARSKI,BHSP_5,STRUCT_0,BINOP_2,FUNCT_1,ZFMISC_1,NAT_1,SEQ_2,ALGSTR_0,BINOP_1,SETWISEO,PROB_2,FINSEQ_1,FINSOP_1,SQUARE_1,NORMSP_1,SEMI_AF1,SUPINF_2,RSSPACE2;
notations TARSKI,XBOOLE_0,SUBSET_1,ZFMISC_1,ORDINAL1,NUMBERS,XREAL_0,BINOP_2,STRUCT_0,ALGSTR_0,COMPLEX1,REAL_1,NAT_1,FUNCT_1,FUNCT_2,RELAT_1,PRE_TOPC,BHSP_1,SQUARE_1,SEQ_2,BINOP_1,FINSET_1,SETWISEO,HAHNBAN,FINSEQ_1,FINSOP_1,BHSP_5,BHSP_6,RSSPACE2,PARTFUN1,XXREAL_0;
definitions TARSKI,SQUARE_1,RLVECT_1;
theorems XBOOLE_1,SQUARE_1,ZFMISC_1,XREAL_0,ABSVALUE,FUNCT_1,NAT_1,FUNCT_2,RLVECT_1,SEQ_2,SEQ_4,BHSP_1,BHSP_5,BHSP_6,UNIFORM1,CHAIN_1,XCMPLX_1,BINOP_2,XREAL_1,COMPLEX1,XXREAL_0,CKB1,CKB2,CKB3,CKB4;
schemes NAT_1,FUNCT_2;
registrations XBOOLE_0,FUNCT_1,ORDINAL1,RELSET_1,FUNCT_2,FINSET_1,NUMBERS,XREAL_0,BINOP_2,MEMBERED,STRUCT_0,BHSP_5;
constructors BINOP_1,DOMAIN_1,SETWISEO,REAL_1,SQUARE_1,BINOP_2,COMPLEX1,SEQ_2,FINSOP_1,BHSP_3,BHSP_5,BHSP_6,SEQ_1,SUPINF_1,RELSET_1;
requirements SUBSET,REAL,BOOLE,NUMERALS,ARITHM;
begin
reserve X for RealUnitarySpace;
reserve y for (Point of X);
reserve y1 for (Point of X);
reserve y2 for (Point of X);
theorem
Th2: (for X holds (((the addF of X) is  commutative  associative & (the addF of X) is  having_a_unity) implies (for S being  finite (OrthogonalFamily of X) holds (S is non  empty implies (for I being (Function of (the carrier of X),(the carrier of X)) holds ((S c= ( dom I ) & (for y holds (y in S implies ( I . y ) = y))) implies (for H being (Function of (the carrier of X),( REAL )) holds ((S c= ( dom H ) & (for y holds (y in S implies ( H . y ) = ( y .|. y )))) implies ( ( setopfunc (S,(the carrier of X),(the carrier of X),I,(the addF of X)) ) .|. ( setopfunc (S,(the carrier of X),(the carrier of X),I,(the addF of X)) ) ) = ( setopfunc (S,(the carrier of X),( REAL ),H,( addreal )) )))))))))
proof
let X;
assume that
A1: ((the addF of X) is  commutative  associative & (the addF of X) is  having_a_unity);
let S being  finite (OrthogonalFamily of X);
assume that
A2: S is non  empty;
let I being (Function of (the carrier of X),(the carrier of X));
assume that
A3: S c= ( dom I )
and
A4: (for y holds (y in S implies ( I . y ) = y));
consider p being (FinSequence of (the carrier of X)) such that A5: (p is  one-to-one & ( rng p ) = S) and A6: ( setopfunc (S,(the carrier of X),(the carrier of X),I,(the addF of X)) ) = ( (the addF of X) "**" ( Func_Seq (I,p) ) ) by A1,A3,BHSP_5:def 5;
let H being (Function of (the carrier of X),( REAL ));
assume that
A7: S c= ( dom H )
and
A8: (for y holds (y in S implies ( H . y ) = ( y .|. y )));
A9: ( setopfunc (S,(the carrier of X),( REAL ),H,( addreal )) ) = ( ( addreal ) "**" ( Func_Seq (H,p) ) ) by A7,A5,BHSP_5:def 5;
A10: (for y1 holds (for y2 holds (((y1 in S & y2 in S) & y1 <> y2) implies ( (the scalar of X) . [ ( I . y1 ),( I . y2 ) ] ) = ( 0 ))))
proof
let y1;
let y2;
assume that
A11: (y1 in S & y2 in S)
and
A12: y1 <> y2;
A13: ( y1 .|. y2 ) = ( 0 ) by A11,A12,BHSP_5:def 8;
(( I . y1 ) = y1 & ( I . y2 ) = y2) by A4,A11;
hence thesis by A13,BHSP_1:def 1;
end;
(for y holds (y in S implies ( H . y ) = ( (the scalar of X) . [ ( I . y ),( I . y ) ] )))
proof
let y;
assume A14: y in S;
then A15: ( I . y ) = y by A4;
( H . y ) = ( y .|. y ) by A8,A14
.= ( (the scalar of X) . [ ( I . y ),( I . y ) ] ) by A15,BHSP_1:def 1;
hence thesis;
end;
then ( (the scalar of X) . [ ( (the addF of X) "**" ( Func_Seq (I,p) ) ),( (the addF of X) "**" ( Func_Seq (I,p) ) ) ] ) = ( ( addreal ) "**" ( Func_Seq (H,p) ) ) by A2,A3,A7,A5,A10,BHSP_5:9;
hence thesis by A6,A9,BHSP_1:def 1;
end;
