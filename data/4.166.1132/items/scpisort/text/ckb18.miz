environ
vocabularies NUMBERS,SCMPDS_2,SUBSET_1,FINSEQ_1,FSM_1,XXREAL_0,FUNCT_1,SCMP_GCD,ARYTM_3,GRAPH_2,NAT_1,RELAT_1,CLASSES1,AMI_2,AMI_1,SCMFSA6B,SCMPDS_4,UNIALG_2,SCMFSA7B,TURING_1,SCMFSA_7,INT_1,CARD_1,SCMPDS_7,AMI_3,ARYTM_1,VALUED_1,TARSKI,FUNCT_4,CIRCUIT2,GRAPHSP,MSUALG_1,XBOOLE_0,SCMISORT,SCMFSA_9,SCMFSA8B,COMPLEX1,SCPISORT,ORDINAL1,SCMNORM,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,PARTFUN1,VALUED_1,XCMPLX_0,FUNCT_4,INT_1,NAT_1,COMPLEX1,MEMSTR_0,EXTPRO_1,COMPOS_1,AMI_2,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,DOMAIN_1,FINSEQ_1,SCMPDS_7,SCMPDS_8,GRAPH_2,CLASSES1,XXREAL_0,CKB1;
definitions SCMPDS_2,SCMP_GCD,AMI_3,COMPOS_1,EXTPRO_1,MEMSTR_0,CKB1;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,INT_1,SCMPDS_2,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,ENUMSET1,SCMP_GCD,SCMPDS_7,SCMPDS_8,ABSVALUE,FINSEQ_1,FINSEQ_2,RFINSEQ,XBOOLE_1,XREAL_1,ORDINAL1,XXREAL_0,GRAPH_2,ZFMISC_1,FINSEQ_3,CLASSES1,AFINSQ_1,COMPOS_1,EXTPRO_1,PBOOLE,MEMSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14;
schemes NAT_1,FINSEQ_1,CKB15,CKB16,CKB17;
registrations SETFAM_1,RELAT_1,FUNCT_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_7,SCMPDS_8,XBOOLE_0,VALUED_0,ORDINAL1,CARD_1,VALUED_1,GRFUNC_1,COMPOS_1,AFINSQ_1,EXTPRO_1,FUNCT_4,MEMSTR_0,RELSET_1;
constructors DOMAIN_1,XXREAL_0,REAL_1,INT_2,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_7,SCMPDS_8,CLASSES1,PRE_POLY,GRAPH_2,AMI_2,MEMSTR_0,RELSET_1,CKB1;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve x for Int_position;
reserve n for (Element of ( NAT ));
reserve P for (Instruction-Sequence of ( SCMPDS ));
reserve Q for (Instruction-Sequence of ( SCMPDS ));
theorem
Th12: (for s being ( 0 ) -started (State of ( SCMPDS )) holds (for I being  halt-free  shiftable (Program of ( SCMPDS )) holds (for a,x,y being Int_position holds (for i,c being Integer holds (for n being (Element of ( NAT )) holds (((n > ( 0 ) & ( s . x ) >= ( ( s . y ) + c )) & (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((( t . x ) >= ( ( t . y ) + c ) & ( t . a ) = ( s . a )) & ( t . ( DataLoc (( s . a ),i) ) ) > ( 0 )) implies ((((( ( IExec (( I ';' ( AddTo (a,i,( - n )) ) ),Q,t) ) . a ) = ( t . a ) & ( ( IExec (( I ';' ( AddTo (a,i,( - n )) ) ),Q,t) ) . ( DataLoc (( s . a ),i) ) ) = ( ( t . ( DataLoc (( s . a ),i) ) ) - n )) & I is_closed_on t,Q) & I is_halting_on t,Q) & ( ( IExec (( I ';' ( AddTo (a,i,( - n )) ) ),Q,t) ) . x ) >= ( ( ( IExec (( I ';' ( AddTo (a,i,( - n )) ) ),Q,t) ) . y ) + c )))))) implies (( for-down (a,i,n,I) ) is_closed_on s,P & ( for-down (a,i,n,I) ) is_halting_on s,P)))))))
proof
let s being ( 0 ) -started (State of ( SCMPDS ));
let I being  halt-free  shiftable (Program of ( SCMPDS ));
let a being Int_position;
let x being Int_position;
let y being Int_position;
let i being Integer;
let c being Integer;
let n being (Element of ( NAT ));
set b = ( DataLoc (( s . a ),i) );
set J = ( I ';' ( AddTo (a,i,( - n )) ) );
assume A1: n > ( 0 );
defpred P[ set ]
 means
(ex t being (State of ( SCMPDS )) st (t = $1 & ( t . x ) >= ( ( t . y ) + c )));
assume A2: ( s . x ) >= ( ( s . y ) + c );
A3: P[ s ] by A2;
assume A4: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((( t . x ) >= ( ( t . y ) + c ) & ( t . a ) = ( s . a )) & ( t . b ) > ( 0 )) implies ((((( ( IExec (J,Q,t) ) . a ) = ( t . a ) & ( ( IExec (J,Q,t) ) . b ) = ( ( t . b ) - n )) & I is_closed_on t,Q) & I is_halting_on t,Q) & ( ( IExec (J,Q,t) ) . x ) >= ( ( ( IExec (J,Q,t) ) . y ) + c )))));
A5:now
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
assume that
A6: P[ t ]
and
A7: (( t . a ) = ( s . a ) & ( t . b ) > ( 0 ));
consider v being (State of ( SCMPDS )) such that A8: v = t and A9: ( v . x ) >= ( ( v . y ) + c ) by A6;
thus (((( ( IExec (J,Q,t) ) . a ) = ( t . a ) & ( ( IExec (J,Q,t) ) . b ) = ( ( t . b ) - n )) & I is_closed_on t,Q) & I is_halting_on t,Q) by A4,A7,A8,A9;
thus P[ ( Initialize ( IExec (J,Q,t) ) ) ]
proof
take v = ( Initialize ( IExec (J,Q,t) ) );
thus v = ( Initialize ( IExec (J,Q,t) ) );
( v . x ) = ( ( IExec (J,Q,t) ) . x ) by SCMPDS_5:15;
then ( v . x ) >= ( ( ( IExec (J,Q,t) ) . y ) + c ) by A4,A7,A8,A9;
hence thesis by SCMPDS_5:15;
end;

end;
(( for-down (a,i,n,I) ) is_closed_on s,P & ( for-down (a,i,n,I) ) is_halting_on s,P) from CKB15:sch 1(A1,A3,A5);
hence thesis;
end;
