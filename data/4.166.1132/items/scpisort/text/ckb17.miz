environ
vocabularies NUMBERS,SCMPDS_2,SUBSET_1,FINSEQ_1,FSM_1,XXREAL_0,FUNCT_1,SCMP_GCD,ARYTM_3,GRAPH_2,NAT_1,RELAT_1,CLASSES1,AMI_2,AMI_1,SCMFSA6B,SCMPDS_4,UNIALG_2,SCMFSA7B,TURING_1,SCMFSA_7,INT_1,CARD_1,SCMPDS_7,AMI_3,ARYTM_1,VALUED_1,TARSKI,FUNCT_4,CIRCUIT2,GRAPHSP,MSUALG_1,XBOOLE_0,SCMISORT,SCMFSA_9,SCMFSA8B,COMPLEX1,SCPISORT,ORDINAL1,SCMNORM,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,PARTFUN1,VALUED_1,XCMPLX_0,FUNCT_4,INT_1,NAT_1,COMPLEX1,MEMSTR_0,EXTPRO_1,COMPOS_1,AMI_2,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,DOMAIN_1,FINSEQ_1,SCMPDS_7,SCMPDS_8,GRAPH_2,CLASSES1,XXREAL_0,CKB1;
definitions SCMPDS_2,SCMP_GCD,AMI_3,COMPOS_1,EXTPRO_1,MEMSTR_0,CKB1;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,INT_1,SCMPDS_2,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,ENUMSET1,SCMP_GCD,SCMPDS_7,SCMPDS_8,ABSVALUE,FINSEQ_1,FINSEQ_2,RFINSEQ,XBOOLE_1,XREAL_1,ORDINAL1,XXREAL_0,GRAPH_2,ZFMISC_1,FINSEQ_3,CLASSES1,AFINSQ_1,COMPOS_1,EXTPRO_1,PBOOLE,MEMSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14;
schemes NAT_1,FINSEQ_1,CKB15,CKB16;
registrations SETFAM_1,RELAT_1,FUNCT_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_7,SCMPDS_8,XBOOLE_0,VALUED_0,ORDINAL1,CARD_1,VALUED_1,GRFUNC_1,COMPOS_1,AFINSQ_1,EXTPRO_1,FUNCT_4,MEMSTR_0,RELSET_1;
constructors DOMAIN_1,XXREAL_0,REAL_1,INT_2,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_7,SCMPDS_8,CLASSES1,PRE_POLY,GRAPH_2,AMI_2,MEMSTR_0,RELSET_1,CKB1;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve n for (Element of ( NAT ));
reserve P for (Instruction-Sequence of ( SCMPDS ));
reserve Q for (Instruction-Sequence of ( SCMPDS ));
reserve U for (Instruction-Sequence of ( SCMPDS ));
scheme ForDownEnd { P[set],s() -> ( 0 ) -started (State of ( SCMPDS )),I() ->  halt-free  shiftable (Program of ( SCMPDS )),P() -> (Instruction-Sequence of ( SCMPDS )),a() -> Int_position,i() -> Integer,n() -> (Element of ( NAT )) } : (( ( IExec (( for-down (a(),i(),n(),I()) ),P(),s()) ) . ( DataLoc (( s() . a() ),i()) ) ) <= ( 0 ) & P[ ( Initialize ( IExec (( for-down (a(),i(),n(),I()) ),P(),s()) ) ) ])
provided
A1: n() > ( 0 )
and
A2: P[ s() ]
and
A3: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (((P[ t ] & ( t . a() ) = ( s() . a() )) & ( t . ( DataLoc (( s() . a() ),i()) ) ) > ( 0 )) implies ((((( ( IExec (( I() ';' ( AddTo (a(),i(),( - n() )) ) ),Q,t) ) . a() ) = ( t . a() ) & ( ( IExec (( I() ';' ( AddTo (a(),i(),( - n() )) ) ),Q,t) ) . ( DataLoc (( s() . a() ),i()) ) ) = ( ( t . ( DataLoc (( s() . a() ),i()) ) ) - n() )) & I() is_closed_on t,Q) & I() is_halting_on t,Q) & P[ ( Initialize ( IExec (( I() ';' ( AddTo (a(),i(),( - n() )) ) ),Q,t) ) ) ])))
proof
set b = ( DataLoc (( s() . a() ),i()) );
set FR = ( for-down (a(),i(),n(),I()) );
defpred Q[ Nat ]
 means
(for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((( t . b ) <= $1 & ( t . a() ) = ( s() . a() )) & P[ t ]) implies (( ( IExec (FR,Q,t) ) . b ) <= ( 0 ) & P[ ( Initialize ( IExec (FR,Q,t) ) ) ]))));
A4: Q[ (( 0 ) qua Nat) ]
proof
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
assume that
A5: (( t . b ) <= ( 0 ) & ( t . a() ) = ( s() . a() ))
and
A6: P[ t ];
T: ( Initialize t ) = t by MEMSTR_0:44;
hence ( ( IExec (FR,Q,t) ) . b ) <= ( 0 ) by A5,SCMPDS_7:47;
(for x being Int_position holds ( ( IExec (FR,Q,t) ) . x ) = ( t . x )) by A5,T,SCMPDS_7:47;
hence thesis by A6,CKB5:1,T;
end;
A7:now
let k being (Element of ( NAT ));
assume A8: Q[ k ];
thus Q[ ( k + 1 ) ]
proof
let u being ( 0 ) -started (State of ( SCMPDS ));
let U;
assume that
A9: ( u . b ) <= ( k + 1 )
and
A10: ( u . a() ) = ( s() . a() )
and
A11: P[ u ];
per cases ;
suppose ( u . b ) <= ( 0 );

hence (( ( IExec (FR,U,u) ) . b ) <= ( 0 ) & P[ ( Initialize ( IExec (FR,U,u) ) ) ]) by A4,A10,A11;
end;
suppose A12: ( u . b ) > ( 0 );

set Ad = ( AddTo (a(),i(),( - n() )) );
set Iu = ( IExec (( I() ';' Ad ),U,u) );
A13: (( Iu . a() ) = ( s() . a() ) & P[ ( Initialize Iu ) ]) by A3,A10,A11,A12;
( Iu . b ) = ( ( u . b ) - n() ) by A3,A10,A11,A12;
then ( ( Iu . b ) + 1 ) <= ( u . b ) by A1,INT_1:7,XREAL_1:44;
then ( ( Iu . b ) + 1 ) <= ( k + 1 ) by A9,XXREAL_0:2;
then A14: ( Iu . b ) <= k by XREAL_1:6;
A15: P[ u ] by A11;
A16: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((P[ t ] & ( t . a() ) = ( u . a() )) & ( t . ( DataLoc (( u . a() ),i()) ) ) > ( 0 )) implies ((((( ( IExec (( I() ';' Ad ),Q,t) ) . a() ) = ( t . a() ) & ( ( IExec (( I() ';' Ad ),Q,t) ) . ( DataLoc (( u . a() ),i()) ) ) = ( ( t . ( DataLoc (( u . a() ),i()) ) ) - n() )) & I() is_closed_on t,Q) & I() is_halting_on t,Q) & P[ ( Initialize ( IExec (( I() ';' Ad ),Q,t) ) ) ])))) by A3,A10;
A17: ( u . ( DataLoc (( u . a() ),i()) ) ) > ( 0 ) by A10,A12;
X1: ( ( Initialize Iu ) . b ) = ( Iu . b ) by SCMPDS_5:15;
X2: ( ( Initialize Iu ) . a() ) = ( Iu . a() ) by SCMPDS_5:15;
( IExec (FR,U,u) ) = ( IExec (FR,U,( Initialize Iu )) ) from CKB16:sch 1(A1,A17,A15,A16);
hence (( ( IExec (FR,U,u) ) . b ) <= ( 0 ) & P[ ( Initialize ( IExec (FR,U,u) ) ) ]) by A8,A14,A13,X1,X2;
end;
end;

end;
A18: (for k being (Element of ( NAT )) holds Q[ k ]) from NAT_1:sch 1(A4,A7);
per cases ;
suppose ( s() . b ) > ( 0 );

then reconsider m = ( s() . b ) as (Element of ( NAT )) by INT_1:3;
Q[ m ] by A18;
hence thesis by A2;
end;
suppose ( s() . b ) <= ( 0 );

hence thesis by A2,A4;
end;
end;
