environ
vocabularies NUMBERS,SCMPDS_2,SUBSET_1,FINSEQ_1,FSM_1,XXREAL_0,FUNCT_1,SCMP_GCD,ARYTM_3,GRAPH_2,NAT_1,RELAT_1,CLASSES1,AMI_2,AMI_1,SCMFSA6B,SCMPDS_4,UNIALG_2,SCMFSA7B,TURING_1,SCMFSA_7,INT_1,CARD_1,SCMPDS_7,AMI_3,ARYTM_1,VALUED_1,TARSKI,FUNCT_4,CIRCUIT2,GRAPHSP,MSUALG_1,XBOOLE_0,SCMISORT,SCMFSA_9,SCMFSA8B,COMPLEX1,SCPISORT,ORDINAL1,SCMNORM,SCMFSA6C,COMPOS_1;
notations TARSKI,XBOOLE_0,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,PARTFUN1,VALUED_1,XCMPLX_0,FUNCT_4,INT_1,NAT_1,COMPLEX1,MEMSTR_0,EXTPRO_1,COMPOS_1,AMI_2,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,DOMAIN_1,FINSEQ_1,SCMPDS_7,SCMPDS_8,GRAPH_2,CLASSES1,XXREAL_0,CKB1;
definitions SCMPDS_2,SCMP_GCD,AMI_3,COMPOS_1,EXTPRO_1,MEMSTR_0,CKB1;
theorems AMI_3,NAT_1,TARSKI,FUNCT_4,INT_1,SCMPDS_2,GRFUNC_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,ENUMSET1,SCMP_GCD,SCMPDS_7,SCMPDS_8,ABSVALUE,FINSEQ_1,FINSEQ_2,RFINSEQ,XBOOLE_1,XREAL_1,ORDINAL1,XXREAL_0,GRAPH_2,ZFMISC_1,FINSEQ_3,CLASSES1,AFINSQ_1,COMPOS_1,EXTPRO_1,PBOOLE,MEMSTR_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14;
schemes NAT_1,FINSEQ_1;
registrations SETFAM_1,RELAT_1,FUNCT_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,SCMPDS_2,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMPDS_7,SCMPDS_8,XBOOLE_0,VALUED_0,ORDINAL1,CARD_1,VALUED_1,GRFUNC_1,COMPOS_1,AFINSQ_1,EXTPRO_1,FUNCT_4,MEMSTR_0,RELSET_1;
constructors DOMAIN_1,XXREAL_0,REAL_1,INT_2,SCM_1,SCMPDS_4,SCMPDS_5,SCMPDS_6,SCMP_GCD,SCMPDS_7,SCMPDS_8,CLASSES1,PRE_POLY,GRAPH_2,AMI_2,MEMSTR_0,RELSET_1,CKB1;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
reserve x for Int_position;
reserve n for (Element of ( NAT ));
reserve P for (Instruction-Sequence of ( SCMPDS ));
reserve Q for (Instruction-Sequence of ( SCMPDS ));
scheme ForDownHalt { P[set],s() -> ( 0 ) -started (State of ( SCMPDS )),P() -> (Instruction-Sequence of ( SCMPDS )),I() ->  halt-free  shiftable (Program of ( SCMPDS )),a() -> Int_position,i() -> Integer,n() -> (Element of ( NAT )) } : (( for-down (a(),i(),n(),I()) ) is_closed_on s(),P() & ( for-down (a(),i(),n(),I()) ) is_halting_on s(),P())
provided
A1: n() > ( 0 )
and
A2: P[ s() ]
and
A3: (for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((P[ t ] & ( t . a() ) = ( s() . a() )) & ( t . ( DataLoc (( s() . a() ),i()) ) ) > ( 0 )) implies ((((( ( IExec (( I() ';' ( AddTo (a(),i(),( - n() )) ) ),Q,t) ) . a() ) = ( t . a() ) & ( ( IExec (( I() ';' ( AddTo (a(),i(),( - n() )) ) ),Q,t) ) . ( DataLoc (( s() . a() ),i()) ) ) = ( ( t . ( DataLoc (( s() . a() ),i()) ) ) - n() )) & I() is_closed_on t,Q) & I() is_halting_on t,Q) & P[ ( Initialize ( IExec (( I() ';' ( AddTo (a(),i(),( - n() )) ) ),Q,t) ) ) ]))))
proof
set i1 = ( (a(),i()) <=0_goto ( ( card I() ) + 3 ) );
set J = ( I() ';' ( AddTo (a(),i(),( - n() )) ) );
set i3 = ( goto ( - ( ( card I() ) + 2 ) ) );
set b = ( DataLoc (( s() . a() ),i()) );
set FOR = ( for-down (a(),i(),n(),I()) );
set pFOR = ( stop FOR );
set pJ = ( stop J );
defpred Q[ Nat ]
 means
(for t being ( 0 ) -started (State of ( SCMPDS )) holds (for Q holds (((( t . b ) <= $1 & P[ t ]) & ( t . a() ) = ( s() . a() )) implies (FOR is_closed_on t,Q & FOR is_halting_on t,Q))));
A4: (for k being (Element of ( NAT )) holds (Q[ k ] implies Q[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume A5: Q[ k ];
now
let t being ( 0 ) -started (State of ( SCMPDS ));
let Q;
T: ( Initialize t ) = t by MEMSTR_0:44;
assume A6: ( t . b ) <= ( k + 1 );
assume A7: P[ t ];
assume A8: ( t . a() ) = ( s() . a() );
per cases ;
suppose ( t . b ) <= ( 0 );

hence (FOR is_closed_on t,Q & FOR is_halting_on t,Q) by A8,SCMPDS_7:44;
end;
suppose A9: ( t . b ) > ( 0 );

A13: ( 0 ) in ( dom pFOR ) by COMPOS_1:36;
( - ( - n() ) ) > ( 0 ) by A1;
then ( - n() ) < ( 0 );
then ( - n() ) <= ( - 1 ) by INT_1:8;
then A14: ( ( - n() ) + ( t . b ) ) <= ( ( - 1 ) + ( t . b ) ) by XREAL_1:6;
( ( t . b ) - 1 ) <= k by A6,XREAL_1:20;
then A15: ( ( - n() ) + ( t . b ) ) <= k by A14,XXREAL_0:2;
set Q2 = ( Q +* pJ );
set Q3 = ( Q +* pFOR );
set t4 = ( Comput (Q3,t,1) );
set Q4 = Q3;
set Jt = ( IExec (J,Q,t) );
A18: pJ c= Q2 by FUNCT_4:25;
A19: FOR = ( i1 ';' ( J ';' i3 ) ) by CKB13:1;
A20: ( Comput (Q3,t,( ( 0 ) + 1 )) ) = ( Following (Q3,( Comput (Q3,t,( 0 )) )) ) by EXTPRO_1:3
.= ( Following (Q3,t) ) by EXTPRO_1:2
.= ( Exec (i1,t) ) by A19,T,SCMPDS_6:11;
(for x holds ( t . x ) = ( t4 . x )) by A20,SCMPDS_2:56;
then A22: ( DataPart t ) = ( DataPart t4 ) by SCMPDS_4:8;
A23: ( Jt . b ) = ( ( t . b ) - n() ) by A3,A7,A8,A9;
A24: ( Jt . a() ) = ( t . a() ) by A3,A7,A8,A9;
set m2 = ( LifeSpan (Q2,t) );
set t5 = ( Comput (Q4,t4,m2) );
set Q5 = Q4;
set l1 = ( ( card J ) + 1 );
A25: ( card J ) = ( ( card I() ) + 1 ) by SCMP_GCD:4;
A28: ( t . ( DataLoc (( t . a() ),i()) ) ) = ( t . b ) by A8;
A29: ( IC t ) = ( 0 ) by T,MEMSTR_0:47;
A30: (I() is_closed_on t,Q & I() is_halting_on t,Q) by A3,A7,A8,A9;
then A31: J is_closed_on t,Q by CKB6:1;
then A32: J is_closed_on t,Q2 by T,SCMPDS_6:24;
( ( card I() ) + 2 ) < ( ( card I() ) + 3 ) by XREAL_1:6;
then A33: l1 in ( dom FOR ) by A25,SCMPDS_7:42;
set m3 = ( m2 + 1 );
set t6 = ( Comput (Q3,t,m3) );
set Q6 = Q3;
A34: t6 = t5 by EXTPRO_1:4;
A36: J is_halting_on t,Q by A30,CKB6:1;
then A37: Q2 halts_on t by T,SCMPDS_6:def 3;
Q2 = ( Q2 +* pJ ) by FUNCT_4:25,FUNCT_4:98;
then ( Q2 +* pJ ) halts_on t by A36,T,SCMPDS_6:def 3;
then A38: J is_halting_on t,Q2 by T,SCMPDS_6:def 3;
set m4 = ( m3 + 1 );
set t7 = ( Comput (Q3,t,m4) );
set Q7 = Q3;
A40: pFOR c= Q3 by FUNCT_4:25;
XX: FOR c= pFOR by AFINSQ_1:74;
then YY: FOR c= Q3 by A40,XBOOLE_1:1;
( Shift (J,1) ) c= FOR by CKB14:1;
then ( Shift (J,1) ) c= pFOR by XX,XBOOLE_1:1;
then A41: ( Shift (J,1) ) c= Q4 by A40,XBOOLE_1:1;
A42: ( IC t4 ) = ( succ ( IC t ) ) by A9,A20,A28,SCMPDS_2:56
.= ( ( 0 ) + 1 ) by A29;
then A43: ( DataPart ( Comput (Q2,t,m2) ) ) = ( DataPart t5 ) by A18,A38,A32,A22,A41,SCMPDS_7:18;
then A44: ( DataPart t5 ) = ( DataPart ( Result (Q2,t) ) ) by A37,EXTPRO_1:23
.= ( DataPart Jt ) by SCMPDS_4:def 5;
A45: ( IC t5 ) = l1 by A18,A38,A32,A42,A22,A41,SCMPDS_7:18;
then A46: ( CurInstr (Q6,t6) ) = ( Q4 . l1 ) by A34,PBOOLE:143
.= ( FOR . l1 ) by A33,YY,GRFUNC_1:2
.= i3 by A25,SCMPDS_7:43;
A47: t7 = ( Following (Q3,t6) ) by EXTPRO_1:3
.= ( Exec (i3,t6) ) by A46;
( IC t7 ) = ( ICplusConst (t6,( ( 0 ) - ( ( card I() ) + 2 ) )) ) by A47,SCMPDS_2:54
.= ( 0 ) by A25,A45,A34,SCMPDS_7:1;
then B49: ( Initialize t7 ) = t7 by MEMSTR_0:46;
( InsCode i3 ) = ( 0 ) by SCMPDS_2:12;
then ( InsCode i3 ) in { ( 0 ),4,5,6 } by ENUMSET1:def 2;
then t7 = ( Initialize t6 ) by A47,B49,SCMPDS_8:3
.= ( Initialize Jt ) by A44,A34,MEMSTR_0:80;
then A48: P[ t7 ] by A3,A7,A8,A9;
A49: ( Q7 +* pFOR ) = Q7 by FUNCT_4:25,FUNCT_4:98;
( t5 . b ) = ( ( Comput (Q2,t,m2) ) . b ) by A43,SCMPDS_4:8
.= ( ( Result (Q2,t) ) . b ) by A37,EXTPRO_1:23
.= ( ( t . b ) - n() ) by A23,SCMPDS_4:def 5;
then A50: ( t7 . b ) = ( ( - n() ) + ( t . b ) ) by A34,A47,SCMPDS_2:54;
( t5 . a() ) = ( ( Comput (Q2,t,m2) ) . a() ) by A43,SCMPDS_4:8
.= ( ( Result (Q2,t) ) . a() ) by A37,EXTPRO_1:23
.= ( s() . a() ) by A8,A24,SCMPDS_4:def 5;
then A51: ( t7 . a() ) = ( s() . a() ) by A34,A47,SCMPDS_2:54;
then A52: FOR is_closed_on t7,Q7 by A5,A48,A50,A15,B49;
now
let k being (Element of ( NAT ));
per cases ;
suppose k < m4;

then A53: k <= m3 by INT_1:7;
hereby
per cases  by A53,NAT_1:8;
suppose A54: k <= m2;

per cases ;
suppose k = ( 0 );

hence ( IC ( Comput (Q3,t,k) ) ) in ( dom pFOR ) by A13,A29,EXTPRO_1:2;
end;
suppose k <> ( 0 );

then consider kn being Nat such that A55: k = ( kn + 1 ) by NAT_1:6;
reconsider kn as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider lm = ( IC ( Comput (Q2,t,kn) ) ) as (Element of ( NAT ));
kn < k by A55,XREAL_1:29;
then kn < m2 by A54,XXREAL_0:2;
then ( ( IC ( Comput (Q2,t,kn) ) ) + 1 ) = ( IC ( Comput (Q4,t4,kn) ) ) by A18,A38,A32,A42,A22,A41,SCMPDS_7:16;
then A57: ( IC ( Comput (Q3,t,k) ) ) = ( lm + 1 ) by A55,EXTPRO_1:4;
( IC ( Comput (Q2,t,kn) ) ) in ( dom pJ ) by A31,T,SCMPDS_6:def 2;
then lm < ( card pJ ) by AFINSQ_1:66;
then lm < ( ( card J ) + 1 ) by COMPOS_1:55;
then A58: ( lm + 1 ) <= ( ( card J ) + 1 ) by INT_1:7;
( ( card I() ) + 2 ) < ( ( card I() ) + 4 ) by XREAL_1:6;
then ( lm + 1 ) < ( ( card I() ) + 4 ) by A25,A58,XXREAL_0:2;
then ( lm + 1 ) < ( card pFOR ) by CKB12:1;
hence ( IC ( Comput (Q3,t,k) ) ) in ( dom pFOR ) by A57,AFINSQ_1:66;
end;
end;
suppose A59: k = m3;

l1 in ( dom pFOR ) by A33,COMPOS_1:62;
hence ( IC ( Comput (Q3,t,k) ) ) in ( dom pFOR ) by A18,A38,A32,A42,A22,A41,A34,A59,SCMPDS_7:18;
end;
end;
end;
suppose k >= m4;

then consider nn being Nat such that A60: k = ( m4 + nn ) by NAT_1:10;
reconsider nn as (Element of ( NAT )) by ORDINAL1:def 12;
( Comput (Q3,t,k) ) = ( Comput (Q3,( Comput (Q3,t,m4) ),nn) ) by A60,EXTPRO_1:4
.= ( Comput (( Q7 +* pFOR ),t7,nn) ) by FUNCT_4:25,FUNCT_4:98;
hence ( IC ( Comput (Q3,t,k) ) ) in ( dom pFOR ) by A52,B49,SCMPDS_6:def 2;
end;
end;
hence FOR is_closed_on t,Q by T,SCMPDS_6:def 2;
FOR is_halting_on t7,Q7 by A5,A51,A48,A50,A15,B49;
then Q7 halts_on t7 by A49,B49,SCMPDS_6:def 3;
then Q3 halts_on t by EXTPRO_1:22;
hence FOR is_halting_on t,Q by T,SCMPDS_6:def 3;
end;
end;
hence thesis;
end;
A61: Q[ ( 0 ) ] by SCMPDS_7:44;
A62: (for k being (Element of ( NAT )) holds Q[ k ]) from NAT_1:sch 1(A61,A4);
per cases ;
suppose ( s() . b ) <= ( 0 );

hence thesis by SCMPDS_7:44;
end;
suppose ( s() . b ) > ( 0 );

then reconsider m = ( s() . b ) as (Element of ( NAT )) by INT_1:3;
Q[ m ] by A62;
hence thesis by A2;
end;
end;
