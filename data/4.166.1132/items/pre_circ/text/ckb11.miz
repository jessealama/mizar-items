environ
vocabularies NUMBERS,FINSET_1,XBOOLE_0,SUBSET_1,TARSKI,FUNCT_1,RELAT_1,FUNCOP_1,FUNCT_4,PBOOLE,FINSEQ_1,CARD_3,PARTFUN1,FUNCT_5,FUNCT_2,ZFMISC_1,FUNCT_6,NAT_1,CARD_1,ARYTM_3,MCART_1,FINSEQ_2,TREES_1,TREES_3,TREES_2,ORDINAL4,TREES_A,XXREAL_0,TREES_4,ARYTM_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,XCMPLX_0,XREAL_0,MCART_1,CARD_1,RELAT_1,FUNCT_1,FINSET_1,PARTFUN1,FUNCT_2,XXREAL_0,XXREAL_2,BINOP_1,FUNCOP_1,FUNCT_4,FUNCT_7,CARD_3,TREES_2,TREES_1,TREES_3,TREES_4,FUNCT_5,FUNCT_6,PBOOLE,FINSEQ_1,FINSEQ_2,NAT_1;
definitions TARSKI,FUNCOP_1,WELLORD2,FUNCT_1,RELAT_1,PBOOLE,XBOOLE_0,SEQ_4,FINSEQ_2,FINSET_1;
theorems TARSKI,ZFMISC_1,FINSEQ_1,FINSEQ_3,GRFUNC_1,FUNCT_1,FUNCT_2,FUNCT_4,FUNCT_5,TREES_1,TREES_2,TREES_3,TREES_4,NAT_1,RELAT_1,CARD_3,FUNCOP_1,MCART_1,PBOOLE,CARD_2,CARD_1,FUNCT_6,FINSET_1,XBOOLE_0,XBOOLE_1,XCMPLX_1,ORDERS_1,XREAL_1,XXREAL_0,XXREAL_2,XREAL_0,PARTFUN1,FUNCT_7,FINSEQ_2,CKB2,CKB3,CKB9,CKB10;
schemes DOMAIN_1,PBOOLE,FUNCT_1,FRAENKEL,FINSEQ_1,NAT_1,CKB1,CKB4;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,XREAL_0,MEMBERED,FINSEQ_1,CARD_3,PBOOLE,TREES_2,TREES_3,XXREAL_2,CARD_1,RELSET_1,TREES_1,CKB5,CKB6,CKB7,CKB8;
constructors WELLORD2,BINOP_1,FUNCT_4,SETWISEO,XXREAL_0,NAT_1,FUNCT_5,CARD_3,SEQ_4,PBOOLE,TREES_4,BINARITH,INT_1,SEQ_1,XXREAL_2,PARTFUN1,RELSET_1,FUNCT_7;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
theorem
(for I being non empty set holds (for A being set holds (for B being  non-empty (ManySortedSet of I) holds (for F being (ManySortedFunction of (( I --> A ) qua  total I -defined Function),B) holds ( dom ( commute F ) ) = A))))
proof
let I being non empty set;
let A being set;
let B being  non-empty (ManySortedSet of I);
let F being (ManySortedFunction of ( I --> A ),B);
A1: ( dom B ) = I by PARTFUN1:def 2;
A2: ( dom F ) = I by PARTFUN1:def 2;
per cases ;
suppose A3: A is  empty;

( rng F ) c= { ( {} ) }
proof
let x being set;
assume x in ( rng F );
then consider i being set such that A4: (i in I & x = ( F . i )) by A2,FUNCT_1:def 3;
(( ( I --> A ) . i ) = A & x is (Function of ( ( I --> A ) . i ),( B . i ))) by A4,FUNCOP_1:7,PBOOLE:def 15;
then x = ( {} ) by A3;
hence thesis by TARSKI:def 1;
end;
then ( rng F ) = { ( {} ) } by ZFMISC_1:33;
then A5: F = ( I --> ( {} ) ) by A2,FUNCOP_1:9;
( commute F ) = ( curry' ( uncurry F ) ) by FUNCT_6:def 10
.= ( {} ) by A5,CKB10:1,FUNCT_5:42;
hence thesis by A3;
end;
suppose A6: A is non empty;

( rng F ) c= ( Funcs (A,( union ( rng B ) )) )
proof
let x being set;
assume x in ( rng F );
then consider i being set such that A7: i in ( dom F ) and A8: x = ( F . i ) by FUNCT_1:def 3;
( ( I --> A ) . i ) = A by A2,A7,FUNCOP_1:7;
then reconsider x9 = x as (Function of A,( B . i )) by A2,A7,A8,PBOOLE:def 15;
( B . i ) in ( rng B ) by A1,A2,A7,FUNCT_1:def 3;
then (( rng x9 ) c= ( B . i ) & ( B . i ) c= ( union ( rng B ) )) by RELAT_1:def 19,ZFMISC_1:74;
then A9: ( rng x9 ) c= ( union ( rng B ) ) by XBOOLE_1:1;
( dom x9 ) = A by A2,A7,FUNCT_2:def 1;
hence thesis by A9,FUNCT_2:def 2;
end;
then F in ( Funcs (I,( Funcs (A,( union ( rng B ) )) )) ) by A2,FUNCT_2:def 2;
then ( commute F ) in ( Funcs (A,( Funcs (I,( union ( rng B ) )) )) ) by A6,FUNCT_6:55;
then A10: ( commute F ) is (Function of A,( Funcs (I,( union ( rng B ) )) )) by FUNCT_2:66;
( union ( rng B ) ) is non empty by CKB9:1;
then ( Funcs (I,( union ( rng B ) )) ) is non empty by FUNCT_2:8;
hence thesis by A10,FUNCT_2:def 1;
end;
end;
