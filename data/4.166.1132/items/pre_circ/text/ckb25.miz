environ
vocabularies NUMBERS,FINSET_1,XBOOLE_0,SUBSET_1,TARSKI,FUNCT_1,RELAT_1,FUNCOP_1,FUNCT_4,PBOOLE,FINSEQ_1,CARD_3,PARTFUN1,FUNCT_5,FUNCT_2,ZFMISC_1,FUNCT_6,NAT_1,CARD_1,ARYTM_3,MCART_1,FINSEQ_2,TREES_1,TREES_3,TREES_2,ORDINAL4,TREES_A,XXREAL_0,TREES_4,ARYTM_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,XCMPLX_0,XREAL_0,MCART_1,CARD_1,RELAT_1,FUNCT_1,FINSET_1,PARTFUN1,FUNCT_2,XXREAL_0,XXREAL_2,BINOP_1,FUNCOP_1,FUNCT_4,FUNCT_7,CARD_3,TREES_2,TREES_1,TREES_3,TREES_4,FUNCT_5,FUNCT_6,PBOOLE,FINSEQ_1,FINSEQ_2,NAT_1;
definitions TARSKI,FUNCOP_1,WELLORD2,FUNCT_1,RELAT_1,PBOOLE,XBOOLE_0,SEQ_4,FINSEQ_2,FINSET_1;
theorems TARSKI,ZFMISC_1,FINSEQ_1,FINSEQ_3,GRFUNC_1,FUNCT_1,FUNCT_2,FUNCT_4,FUNCT_5,TREES_1,TREES_2,TREES_3,TREES_4,NAT_1,RELAT_1,CARD_3,FUNCOP_1,MCART_1,PBOOLE,CARD_2,CARD_1,FUNCT_6,FINSET_1,XBOOLE_0,XBOOLE_1,XCMPLX_1,ORDERS_1,XREAL_1,XXREAL_0,XXREAL_2,XREAL_0,PARTFUN1,FUNCT_7,FINSEQ_2,CKB2,CKB3,CKB9,CKB10,CKB11,CKB14,CKB15,CKB16,CKB19,CKB21,CKB22,CKB23,CKB24;
schemes DOMAIN_1,PBOOLE,FUNCT_1,FRAENKEL,FINSEQ_1,NAT_1,CKB1,CKB4,CKB12,CKB13;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,FINSET_1,XREAL_0,MEMBERED,FINSEQ_1,CARD_3,PBOOLE,TREES_2,TREES_3,XXREAL_2,CARD_1,RELSET_1,TREES_1,CKB5,CKB6,CKB7,CKB8,CKB17,CKB18,CKB20;
constructors WELLORD2,BINOP_1,FUNCT_4,SETWISEO,XXREAL_0,NAT_1,FUNCT_5,CARD_3,SEQ_4,PBOOLE,TREES_4,BINARITH,INT_1,SEQ_1,XXREAL_2,PARTFUN1,RELSET_1,FUNCT_7;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve T for  finite Tree;
reserve t for (Element of T);
reserve p for (Element of T);
theorem
Th18: (for p,q being  Tree-yielding FinSequence holds (for k being (Element of ( NAT )) holds (((( len p ) = ( len q ) & ( k + 1 ) in ( dom p )) & (for i being (Element of ( NAT )) holds ((i in ( dom p ) & i <> ( k + 1 )) implies ( p . i ) = ( q . i )))) implies (for t being Tree holds (( q . ( k + 1 ) ) = t implies ( tree q ) = ( ( tree p ) with-replacement (<* k *>,t) ))))))
proof
let p being  Tree-yielding FinSequence;
let q being  Tree-yielding FinSequence;
let k being (Element of ( NAT ));
assume that
A1: ( len p ) = ( len q )
and
A2: ( k + 1 ) in ( dom p )
and
A3: (for i being (Element of ( NAT )) holds ((i in ( dom p ) & i <> ( k + 1 )) implies ( p . i ) = ( q . i )));
let t being Tree;
set o = <* k *>;
( k + 1 ) <= ( len p ) by A2,FINSEQ_3:25;
then A4: k < ( len p ) by NAT_1:13;
assume A5: ( q . ( k + 1 ) ) = t;
A6:now
let s being (FinSequence of ( NAT ));
hereby
assume A7: s in ( tree q );
per cases  by A7,TREES_3:def 15;
suppose s = ( {} );

hence ((s in ( tree p ) & (not o is_a_proper_prefix_of s)) or (ex r being (FinSequence of ( NAT )) st (r in t & s = ( o ^ r )))) by TREES_1:22,XBOOLE_1:115;
end;
suppose (ex n being (Element of ( NAT )) st (ex r being FinSequence st ((n < ( len q ) & r in ( q . ( n + 1 ) )) & s = ( <* n *> ^ r ))));

then consider n being (Element of ( NAT )),r being FinSequence such that A8: n < ( len q ) and A9: r in ( q . ( n + 1 ) ) and A10: s = ( <* n *> ^ r );
now
per cases ;
case A11: n = k;
reconsider r as (FinSequence of ( NAT )) by A10,FINSEQ_1:36;
take r;
thus (r in t & s = ( o ^ r )) by A5,A9,A10,A11;
end;
case A12: n <> k;
(1 <= ( n + 1 ) & ( n + 1 ) <= ( len p )) by A1,A8,NAT_1:11,NAT_1:13;
then ( n + 1 ) in ( dom p ) by FINSEQ_3:25;
then ( q . ( n + 1 ) ) = ( p . ( n + 1 ) ) by A3,A12,XCMPLX_1:2;
hence s in ( tree p ) by A1,A8,A9,A10,TREES_3:def 15;
assume o is_a_proper_prefix_of s;
then o is_a_prefix_of s by XBOOLE_0:def 8;
then (ex s1 being FinSequence st s = ( o ^ s1 )) by TREES_1:1;
then k = ( s . 1 ) by FINSEQ_1:41
.= n by A10,FINSEQ_1:41;
hence contradiction by A12;
end;
end;
hence ((s in ( tree p ) & (not o is_a_proper_prefix_of s)) or (ex r being (FinSequence of ( NAT )) st (r in t & s = ( o ^ r ))));
end;
end;
assume A13: ((s in ( tree p ) & (not o is_a_proper_prefix_of s)) or (ex r being (FinSequence of ( NAT )) st (r in t & s = ( o ^ r ))));
per cases  by A13;
suppose that A14: s in ( tree p )
and
A15: (not o is_a_proper_prefix_of s);
now
per cases  by A14,TREES_3:def 15;
suppose s = ( {} );

hence s in ( tree q ) by TREES_1:22;
end;
suppose (ex n being (Element of ( NAT )) st (ex r being FinSequence st ((n < ( len p ) & r in ( p . ( n + 1 ) )) & s = ( <* n *> ^ r ))));

then consider n being (Element of ( NAT )),r being FinSequence such that A16: n < ( len p ) and A17: r in ( p . ( n + 1 ) ) and A18: s = ( <* n *> ^ r );
now
per cases ;
suppose A19: r = ( {} );

(1 <= ( n + 1 ) & ( n + 1 ) <= ( len q )) by A1,A16,NAT_1:11,NAT_1:13;
then ( n + 1 ) in ( dom q ) by FINSEQ_3:25;
then ( q . ( n + 1 ) ) is Tree by TREES_3:22;
then r in ( q . ( n + 1 ) ) by A19,TREES_1:22;
hence s in ( tree q ) by A1,A16,A18,TREES_3:def 15;
end;
suppose A20: r <> ( {} );

A21:now
assume n = k;
then (o is_a_prefix_of s & (not s = o)) by A18,A20,FINSEQ_1:87,TREES_1:1;
hence contradiction by A15,XBOOLE_0:def 8;
end;
(1 <= ( n + 1 ) & ( n + 1 ) <= ( len p )) by A16,NAT_1:11,NAT_1:13;
then ( n + 1 ) in ( dom p ) by FINSEQ_3:25;
then ( q . ( n + 1 ) ) = ( p . ( n + 1 ) ) by A3,A21,XCMPLX_1:2;
hence s in ( tree q ) by A1,A16,A17,A18,TREES_3:def 15;
end;
end;
hence s in ( tree q );
end;
end;
hence s in ( tree q );
end;
suppose (ex r being (FinSequence of ( NAT )) st (r in t & s = ( o ^ r )));

hence s in ( tree q ) by A1,A4,A5,TREES_3:def 15;
end;
end;
( p . ( k + 1 ) ) is Tree by A2,TREES_3:22;
then A22: ( {} ) in ( p . ( k + 1 ) ) by TREES_1:22;
o = ( o ^ ( {} ) ) by FINSEQ_1:34;
then o in ( tree p ) by A4,A22,TREES_3:def 15;
hence thesis by A6,TREES_1:def 9;
end;
