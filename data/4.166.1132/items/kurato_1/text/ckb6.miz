environ
vocabularies NUMBERS,XBOOLE_0,PRE_TOPC,SUBSET_1,ARYTM_1,TOPS_1,TARSKI,STRUCT_0,SETFAM_1,FINSET_1,ZFMISC_1,CARD_1,XXREAL_0,ARYTM_3,TOPMETR,XXREAL_1,BORSUK_5,RCOMP_1,PROB_1,KURATO_1;
notations XBOOLE_0,TARSKI,ZFMISC_1,SUBSET_1,SETFAM_1,STRUCT_0,CARD_1,NUMBERS,XXREAL_0,PRE_TOPC,TOPS_1,ENUMSET1,FINSET_1,RCOMP_1,NAT_1,SEQ_4,TOPMETR,TOPS_2,BORSUK_5,PROB_1,CKB1,CKB4;
definitions TARSKI,ZFMISC_1,SETFAM_1,TOPS_2,SUBSET_1,STRUCT_0,CKB4;
theorems ENUMSET1,TOPS_1,PRE_TOPC,CARD_2,XBOOLE_0,TDLAT_1,TARSKI,TOPMETR,ZFMISC_1,XBOOLE_1,SETFAM_1,MEASURE1,BORSUK_5,TOPS_2,PROB_1,XREAL_1,XXREAL_0,XXREAL_1,CKB2,CKB3,CKB4;
registrations XBOOLE_0,SUBSET_1,SETFAM_1,FINSET_1,XXREAL_0,MEMBERED,TOPS_1,TOPMETR,BORSUK_5,STRUCT_0,COMPTS_1,CKB5;
constructors SETFAM_1,PROB_1,RCOMP_1,TOPS_1,TOPS_2,TOPMETR,PSCOMP_1,BORSUK_5,SEQ_4,CKB4;
requirements SUBSET,BOOLE,NUMERALS,REAL,ARITHM;
begin
reserve T for non  empty TopSpace;
reserve A for (Subset of T);
definition
let T;
let A;
func Kurat14Set A -> (Subset-Family of T) equals 
( { A,( A - ),( ( A - ) ` ),( ( ( A - ) ` ) - ),( ( ( ( A - ) ` ) - ) ` ),( ( ( ( ( A - ) ` ) - ) ` ) - ),( ( ( ( ( ( A - ) ` ) - ) ` ) - ) ` ) } \/ { ( A ` ),( ( A ` ) - ),( ( ( A ` ) - ) ` ),( ( ( ( A ` ) - ) ` ) - ),( ( ( ( ( A ` ) - ) ` ) - ) ` ),( ( ( ( ( ( A ` ) - ) ` ) - ) ` ) - ),( ( ( ( ( ( ( A ` ) - ) ` ) - ) ` ) - ) ` ) } );
coherence
proof
set X1 = { A,( Cl A ),( ( Cl A ) ` ),( Cl ( ( Cl A ) ` ) ),( ( Cl ( ( Cl A ) ` ) ) ` ),( Cl ( ( Cl ( ( Cl A ) ` ) ) ` ) ),( ( Cl ( ( Cl ( ( Cl A ) ` ) ) ` ) ) ` ) };
set X2 = { ( A ` ),( Cl ( A ` ) ),( ( Cl ( A ` ) ) ` ),( Cl ( ( Cl ( A ` ) ) ` ) ),( ( Cl ( ( Cl ( A ` ) ) ` ) ) ` ),( Cl ( ( Cl ( ( Cl ( A ` ) ) ` ) ) ` ) ),( ( Cl ( ( Cl ( ( Cl ( A ` ) ) ` ) ) ` ) ) ` ) };
X2 c= ( bool (the carrier of T) )
proof
let x being set;
assume x in X2;
then ((((((x = ( A ` ) or x = ( Cl ( A ` ) )) or x = ( ( Cl ( A ` ) ) ` )) or x = ( Cl ( ( Cl ( A ` ) ) ` ) )) or x = ( ( Cl ( ( Cl ( A ` ) ) ` ) ) ` )) or x = ( Cl ( ( Cl ( ( Cl ( A ` ) ) ` ) ) ` ) )) or x = ( ( Cl ( ( Cl ( ( Cl ( A ` ) ) ` ) ) ` ) ) ` )) by ENUMSET1:def 5;
hence thesis;
end;
then reconsider X2 as (Subset-Family of T);
X1 c= ( bool (the carrier of T) )
proof
let x being set;
assume x in X1;
then ((((((x = A or x = ( Cl A )) or x = ( ( Cl A ) ` )) or x = ( Cl ( ( Cl A ) ` ) )) or x = ( ( Cl ( ( Cl A ) ` ) ) ` )) or x = ( Cl ( ( Cl ( ( Cl A ) ` ) ) ` ) )) or x = ( ( Cl ( ( Cl ( ( Cl A ) ` ) ) ` ) ) ` )) by ENUMSET1:def 5;
hence thesis;
end;
then reconsider X1 as (Subset-Family of T);
( X1 \/ X2 ) is (Subset-Family of T);
hence thesis;
end;
end;
