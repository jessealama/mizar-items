environ
vocabularies XBOOLE_0,RELAT_2,ALTCAT_1,ALTCAT_2,MSUALG_6,FUNCTOR0,RELAT_1,FUNCT_2,FUNCT_1,SUBSET_1,FUNCT_3,ZFMISC_1,STRUCT_0,TARSKI,MEMBER_1,MSUALG_3,ENS_1,CAT_1,PBOOLE,REALSET1,PZFMISC1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,PBOOLE,PARTFUN1,FUNCT_2,BINOP_1,REALSET1,PZFMISC1,STRUCT_0,MSUALG_3,ALTCAT_1,ALTCAT_2,FUNCT_3,FUNCTOR0;
definitions TARSKI,PBOOLE,MSUALG_3,ALTCAT_2,FUNCTOR0,PZFMISC1,BINOP_1,REALSET1;
theorems ALTCAT_1,ALTCAT_2,FUNCTOR0,FUNCT_1,FUNCT_2,ZFMISC_1,PBOOLE,RELAT_1,MSUALG_3,XBOOLE_1,PZFMISC1,PARTFUN1,CKB5,CKB6,CKB7;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,FUNCOP_1,PBOOLE,STRUCT_0,ALTCAT_2,FUNCTOR0,RELSET_1,CKB1,CKB2,CKB3,CKB4;
constructors REALSET1,PZFMISC1,MSUALG_3,FUNCTOR0,RELSET_1;
requirements SUBSET,BOOLE;
begin
theorem
Th5: (for A being non  empty  reflexive AltCatStr holds (for B being non  empty  reflexive (SubCatStr of A) holds (for C being non  empty (SubCatStr of A) holds (for D being non  empty (SubCatStr of B) holds (C = D implies ( incl C ) = ( ( incl B ) * ( incl D ) ))))))
proof
let A being non  empty  reflexive AltCatStr;
let B being non  empty  reflexive (SubCatStr of A);
let C being non  empty (SubCatStr of A);
let D being non  empty (SubCatStr of B);
assume that
A1: C = D;
set X = [: (the carrier of B),(the carrier of B) :];
set Y = [: (the carrier of D),(the carrier of D) :];
A2: (the carrier of D) c= (the carrier of B) by ALTCAT_2:def 11;
then A3: Y c= X by ZFMISC_1:96;
(for i being set holds (i in Y implies ( (the MorphMap of ( incl C )) . i ) = ( ( ( (the MorphMap of ( incl B )) * (the ObjectMap of ( incl D )) ) ** (the MorphMap of ( incl D )) ) . i )))
proof
set dom2 = ( dom (the MorphMap of ( incl D )) );
set dom1 = ( dom ( (the MorphMap of ( incl B )) * (the ObjectMap of ( incl D )) ) );
set XX = (the Arrows of B);
set YY = (the Arrows of D);
let i being set;
A4: ( (the MorphMap of ( incl C )) . i ) = ( ( id (the Arrows of C) ) . i ) by FUNCTOR0:def 28;
A5: (( dom ( ( (the MorphMap of ( incl B )) * (the ObjectMap of ( incl D )) ) ** (the MorphMap of ( incl D )) ) ) = ( dom2 /\ dom1 ) & ( dom (the MorphMap of ( incl D )) ) = Y) by PARTFUN1:def 2,PBOOLE:def 19;
A6: ( dom ( (the MorphMap of ( incl B )) * (the ObjectMap of ( incl D )) ) ) = ( dom ( (the MorphMap of ( incl B )) * ( id Y ) ) ) by FUNCTOR0:def 28
.= ( ( dom (the MorphMap of ( incl B )) ) /\ Y ) by FUNCT_1:19
.= ( X /\ Y ) by PARTFUN1:def 2
.= Y by A2,XBOOLE_1:28,ZFMISC_1:96;
assume A7: i in Y;
then A8: i in ( dom ( id Y ) ) by FUNCT_1:17;
YY cc= XX by ALTCAT_2:def 11;
then A9: ( YY . i ) c= ( XX . i ) by A7,ALTCAT_2:def 2;
A10: ( ( (the MorphMap of ( incl B )) * (the ObjectMap of ( incl D )) ) . i ) = ( ( (the MorphMap of ( incl B )) * ( id Y ) ) . i ) by FUNCTOR0:def 28
.= ( (the MorphMap of ( incl B )) . ( ( id Y ) . i ) ) by A8,FUNCT_1:13
.= ( (the MorphMap of ( incl B )) . i ) by A7,FUNCT_1:18;
(( (the MorphMap of ( incl B )) . i ) = ( ( id (the Arrows of B) ) . i ) & ( (the MorphMap of ( incl D )) . i ) = ( ( id (the Arrows of D) ) . i )) by FUNCTOR0:def 28;
then ( ( (the MorphMap of ( incl B )) . i ) * ( (the MorphMap of ( incl D )) . i ) ) = ( ( ( id XX ) . i ) * ( id ( YY . i ) ) ) by A7,MSUALG_3:def 1
.= ( ( id ( XX . i ) ) * ( id ( YY . i ) ) ) by A3,A7,MSUALG_3:def 1
.= ( id ( ( XX . i ) /\ ( YY . i ) ) ) by FUNCT_1:22
.= ( id ( (the Arrows of D) . i ) ) by A9,XBOOLE_1:28
.= ( (the MorphMap of ( incl C )) . i ) by A1,A7,A4,MSUALG_3:def 1;
hence thesis by A7,A10,A5,A6,PBOOLE:def 19;
end;
then A11: (the MorphMap of ( incl C )) = ( ( (the MorphMap of ( incl B )) * (the ObjectMap of ( incl D )) ) ** (the MorphMap of ( incl D )) ) by A1,PBOOLE:3;
(the ObjectMap of ( incl C )) = ( id Y ) by A1,FUNCTOR0:def 28
.= ( id ( X /\ Y ) ) by A2,XBOOLE_1:28,ZFMISC_1:96
.= ( ( id X ) * ( id Y ) ) by FUNCT_1:22
.= ( ( id X ) * (the ObjectMap of ( incl D )) ) by FUNCTOR0:def 28
.= ( (the ObjectMap of ( incl B )) * (the ObjectMap of ( incl D )) ) by FUNCTOR0:def 28;
hence thesis by A1,A11,FUNCTOR0:def 36;
end;
