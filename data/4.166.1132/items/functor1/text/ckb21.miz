environ
vocabularies XBOOLE_0,RELAT_2,ALTCAT_1,ALTCAT_2,MSUALG_6,FUNCTOR0,RELAT_1,FUNCT_2,FUNCT_1,SUBSET_1,FUNCT_3,ZFMISC_1,STRUCT_0,TARSKI,MEMBER_1,MSUALG_3,ENS_1,CAT_1,PBOOLE,REALSET1,PZFMISC1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,PBOOLE,PARTFUN1,FUNCT_2,BINOP_1,REALSET1,PZFMISC1,STRUCT_0,MSUALG_3,ALTCAT_1,ALTCAT_2,FUNCT_3,FUNCTOR0;
definitions TARSKI,PBOOLE,MSUALG_3,ALTCAT_2,FUNCTOR0,PZFMISC1,BINOP_1,REALSET1;
theorems ALTCAT_1,ALTCAT_2,FUNCTOR0,FUNCT_1,FUNCT_2,ZFMISC_1,PBOOLE,RELAT_1,MSUALG_3,XBOOLE_1,PZFMISC1,PARTFUN1,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,FUNCOP_1,PBOOLE,STRUCT_0,ALTCAT_2,FUNCTOR0,RELSET_1,CKB1,CKB2,CKB3,CKB4;
constructors REALSET1,PZFMISC1,MSUALG_3,FUNCTOR0,RELSET_1;
requirements SUBSET,BOOLE;
begin
theorem
(for A being  transitive  with_units non  empty AltCatStr holds ( ( id A ) " ) = ( id A ))
proof
let A being  transitive  with_units non  empty AltCatStr;
set CCA = [: (the carrier of A),(the carrier of A) :];
consider f being (ManySortedFunction of (the Arrows of A),( (the Arrows of A) * (the ObjectMap of ( id A )) )) such that A1: f = (the MorphMap of ( id A )) and A2: (the MorphMap of ( ( id A ) " )) = ( ( f "" ) * ( (the ObjectMap of ( id A )) " ) ) by FUNCTOR0:def 38;
A3: (for i being set holds (i in CCA implies ( ( id (the Arrows of A) ) . i ) is  one-to-one))
proof
let i being set;
assume that
A4: i in CCA;
( id ( (the Arrows of A) . i ) ) is  one-to-one;
hence thesis by A4,MSUALG_3:def 1;
end;
(the MorphMap of ( id A )) = ( id (the Arrows of A) ) by FUNCTOR0:def 29;
then A5: (the MorphMap of ( id A )) is  "1-1" by A3,MSUALG_3:1;
(for i being set holds (i in CCA implies ( rng ( f . i ) ) = ( ( (the Arrows of A) * (the ObjectMap of ( id A )) ) . i )))
proof
( dom (the Arrows of A) ) = CCA by PARTFUN1:def 2;
then A6: ( ( dom (the Arrows of A) ) /\ CCA ) = CCA;
let i being set;
assume that
A7: i in CCA;
( rng ( f . i ) ) = ( rng ( ( id (the Arrows of A) ) . i ) ) by A1,FUNCTOR0:def 29
.= ( rng ( id ( (the Arrows of A) . i ) ) ) by A7,MSUALG_3:def 1
.= ( (the Arrows of A) . i ) by RELAT_1:45
.= ( ( (the Arrows of A) * ( id CCA ) ) . i ) by A7,A6,FUNCT_1:20
.= ( ( (the Arrows of A) * (the ObjectMap of ( id A )) ) . i ) by FUNCTOR0:def 29;
hence thesis;
end;
then A8: f is  "onto" by MSUALG_3:def 3;
(for i being set holds (i in CCA implies ( ( f "" ) . i ) = ( f . i )))
proof
let i being set;
assume A9: i in CCA;
then ( ( f "" ) . i ) = ( ( (the MorphMap of ( id A )) . i ) " ) by A1,A5,A8,MSUALG_3:def 4
.= ( ( ( id (the Arrows of A) ) . i ) " ) by FUNCTOR0:def 29
.= ( ( id ( (the Arrows of A) . i ) ) " ) by A9,MSUALG_3:def 1
.= ( id ( (the Arrows of A) . i ) ) by FUNCT_1:45
.= ( ( id (the Arrows of A) ) . i ) by A9,MSUALG_3:def 1
.= ( f . i ) by A1,FUNCTOR0:def 29;
hence thesis;
end;
then A10: ( f "" ) = f by PBOOLE:3;
(for i being set holds (i in CCA implies ( ( (the MorphMap of ( id A )) * ( id CCA ) ) . i ) = ( (the MorphMap of ( id A )) . i )))
proof
( dom (the MorphMap of ( id A )) ) = CCA by PARTFUN1:def 2;
then A11: ( ( dom (the MorphMap of ( id A )) ) /\ CCA ) = CCA;
let i being set;
assume i in CCA;
hence thesis by A11,FUNCT_1:20;
end;
then A12: ( (the MorphMap of ( id A )) * ( id CCA ) ) = (the MorphMap of ( id A )) by PBOOLE:3;
A13: (the ObjectMap of ( ( id A ) " )) = ( (the ObjectMap of ( id A )) " ) by FUNCTOR0:def 38;
then (the ObjectMap of ( ( id A ) " )) = ( ( id CCA ) " ) by FUNCTOR0:def 29
.= ( id CCA ) by FUNCT_1:45
.= (the ObjectMap of ( id A )) by FUNCTOR0:def 29;
hence thesis by A13,A1,A2,A10,A12,FUNCTOR0:def 29;
end;
