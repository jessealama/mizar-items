environ
vocabularies XBOOLE_0,RELAT_2,ALTCAT_1,ALTCAT_2,MSUALG_6,FUNCTOR0,RELAT_1,FUNCT_2,FUNCT_1,SUBSET_1,FUNCT_3,ZFMISC_1,STRUCT_0,TARSKI,MEMBER_1,MSUALG_3,ENS_1,CAT_1,PBOOLE,REALSET1,PZFMISC1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,PBOOLE,PARTFUN1,FUNCT_2,BINOP_1,REALSET1,PZFMISC1,STRUCT_0,MSUALG_3,ALTCAT_1,ALTCAT_2,FUNCT_3,FUNCTOR0;
definitions TARSKI,PBOOLE,MSUALG_3,ALTCAT_2,FUNCTOR0,PZFMISC1,BINOP_1,REALSET1;
theorems ALTCAT_1,ALTCAT_2,FUNCTOR0,FUNCT_1,FUNCT_2,ZFMISC_1,PBOOLE,RELAT_1,MSUALG_3,XBOOLE_1,PZFMISC1,PARTFUN1,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,FUNCOP_1,PBOOLE,STRUCT_0,ALTCAT_2,FUNCTOR0,RELSET_1,CKB1,CKB2,CKB3,CKB4;
constructors REALSET1,PZFMISC1,MSUALG_3,FUNCTOR0,RELSET_1;
requirements SUBSET,BOOLE;
begin
theorem
Th10: (for C1 being non  empty AltGraph holds (for C2,C3 being non  empty  reflexive AltGraph holds (for F being  feasible FunctorStr over C1,C2 holds (for G being FunctorStr over C2,C3 holds ((F is  full & G is  full) implies ( G * F ) is  full)))))
proof
let C1 being non  empty AltGraph;
let C2 being non  empty  reflexive AltGraph;
let C3 being non  empty  reflexive AltGraph;
let F being  feasible FunctorStr over C1,C2;
let G being FunctorStr over C2,C3;
assume that
A1: F is  full
and
A2: G is  full;
set CC3 = [: (the carrier of C3),(the carrier of C3) :];
set CC2 = [: (the carrier of C2),(the carrier of C2) :];
set CC1 = [: (the carrier of C1),(the carrier of C1) :];
reconsider OMF = (the ObjectMap of F) as (Function of CC1,CC2);
reconsider OMG = (the ObjectMap of G) as (Function of CC2,CC3);
consider MMF being (ManySortedFunction of (the Arrows of C1),( (the Arrows of C2) * (the ObjectMap of F) )) such that A3: MMF = (the MorphMap of F) and A4: MMF is  "onto" by A1,FUNCTOR0:def 32;
consider MMG being (ManySortedFunction of (the Arrows of C2),( (the Arrows of C3) * (the ObjectMap of G) )) such that A5: MMG = (the MorphMap of G) and A6: MMG is  "onto" by A2,FUNCTOR0:def 32;
(ex f being (ManySortedFunction of (the Arrows of C1),( (the Arrows of C3) * (the ObjectMap of ( G * F )) )) st (f = (the MorphMap of ( G * F )) & f is  "onto"))
proof
reconsider MMGF = (the MorphMap of ( G * F )) as (ManySortedFunction of (the Arrows of C1),( (the Arrows of C3) * (the ObjectMap of ( G * F )) )) by FUNCTOR0:def 4;
take MMGF;
A7: MMGF = ( ( MMG * OMF ) ** MMF ) by A3,A5,FUNCTOR0:def 36;
(for i being set holds (i in CC1 implies ( rng ( MMGF . i ) ) = ( ( (the Arrows of C3) * (the ObjectMap of ( G * F )) ) . i )))
proof
let i being set;
assume A8: i in CC1;
then reconsider MMGI = ( MMG . ( OMF . i ) ) as (Function of ( (the Arrows of C2) . ( OMF . i ) ),( ( (the Arrows of C3) * (the ObjectMap of G) ) . ( OMF . i ) )) by FUNCT_2:5,PBOOLE:def 15;
A9: ( OMF . i ) in CC2 by A8,FUNCT_2:5;
A10: ( rng ( ( MMG . ( OMF . i ) ) * ( MMF . i ) ) ) = ( rng ( MMG . ( OMF . i ) ) )
proof
per cases ;
suppose A11: ( rng MMGI ) = ( {} );

( rng ( ( {} ) * ( MMF . i ) ) ) = ( {} );
hence thesis by A11,RELAT_1:41;
end;
suppose A12: ( rng MMGI ) <> ( {} );

( rng MMGI ) = ( ( (the Arrows of C3) * (the ObjectMap of G) ) . ( OMF . i ) ) by A6,A9,MSUALG_3:def 3;
then ( dom MMGI ) = ( (the Arrows of C2) . ( OMF . i ) ) by A12,FUNCT_2:def 1;
then ( dom MMGI ) = ( ( (the Arrows of C2) * OMF ) . i ) by A8,FUNCT_2:15
.= ( rng ( MMF . i ) ) by A4,A8,MSUALG_3:def 3;
hence thesis by RELAT_1:28;
end;
end;
i in ( dom ( ( MMG * OMF ) ** MMF ) ) by A8,PARTFUN1:def 2;
then ( rng ( MMGF . i ) ) = ( rng ( ( ( MMG * OMF ) . i ) * ( MMF . i ) ) ) by A7,PBOOLE:def 19
.= ( rng ( MMG . ( OMF . i ) ) ) by A8,A10,FUNCT_2:15
.= ( ( (the Arrows of C3) * (the ObjectMap of G) ) . ( OMF . i ) ) by A6,A9,MSUALG_3:def 3
.= ( (the Arrows of C3) . ( OMG . ( OMF . i ) ) ) by A8,FUNCT_2:5,FUNCT_2:15
.= ( (the Arrows of C3) . ( ( OMG * OMF ) . i ) ) by A8,FUNCT_2:15
.= ( (the Arrows of C3) . ( (the ObjectMap of ( G * F )) . i ) ) by FUNCTOR0:def 36
.= ( ( (the Arrows of C3) * (the ObjectMap of ( G * F )) ) . i ) by A8,FUNCT_2:15;
hence thesis;
end;
hence thesis by MSUALG_3:def 3;
end;
hence thesis by FUNCTOR0:def 32;
end;
