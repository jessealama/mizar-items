environ
vocabularies XBOOLE_0,RELAT_2,ALTCAT_1,ALTCAT_2,MSUALG_6,FUNCTOR0,RELAT_1,FUNCT_2,FUNCT_1,SUBSET_1,FUNCT_3,ZFMISC_1,STRUCT_0,TARSKI,MEMBER_1,MSUALG_3,ENS_1,CAT_1,PBOOLE,REALSET1,PZFMISC1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,PBOOLE,PARTFUN1,FUNCT_2,BINOP_1,REALSET1,PZFMISC1,STRUCT_0,MSUALG_3,ALTCAT_1,ALTCAT_2,FUNCT_3,FUNCTOR0;
definitions TARSKI,PBOOLE,MSUALG_3,ALTCAT_2,FUNCTOR0,PZFMISC1,BINOP_1,REALSET1;
theorems ALTCAT_1,ALTCAT_2,FUNCTOR0,FUNCT_1,FUNCT_2,ZFMISC_1,PBOOLE,RELAT_1,MSUALG_3,XBOOLE_1,PZFMISC1,PARTFUN1,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,FUNCOP_1,PBOOLE,STRUCT_0,ALTCAT_2,FUNCTOR0,RELSET_1,CKB1,CKB2,CKB3,CKB4;
constructors REALSET1,PZFMISC1,MSUALG_3,FUNCTOR0,RELSET_1;
requirements SUBSET,BOOLE;
begin
theorem
(for A,B being  transitive  with_units  reflexive non empty AltCatStr holds (for F being  feasible FunctorStr over A,B holds (F is  bijective implies ( ( F " ) * F ) = ( id A ))))
proof
let A being  transitive  with_units  reflexive non empty AltCatStr,B being  transitive  with_units  reflexive non empty AltCatStr;
set I1 = [: (the carrier of A),(the carrier of A) :];
let F being  feasible FunctorStr over A,B;
assume that
A1: F is  bijective;
consider f being (ManySortedFunction of (the Arrows of A),( (the Arrows of B) * (the ObjectMap of F) )) such that A2: f = (the MorphMap of F) and A3: (the MorphMap of ( F " )) = ( ( f "" ) * ( (the ObjectMap of F) " ) ) by A1,FUNCTOR0:def 38;
set OM = (the ObjectMap of F);
A4: ( dom OM ) = I1 by FUNCT_2:def 1;
A5: (the Arrows of A) is_transformable_to ( (the Arrows of B) * (the ObjectMap of F) )
proof
let i being set;
assume A6: i in I1;
then consider o1 being set,o2 being set such that A7: (o1 in (the carrier of A) & o2 in (the carrier of A)) and A8: i = [ o1,o2 ] by ZFMISC_1:84;
reconsider o1,o2 as (object of A) by A7;
A9: ( (the Arrows of A) . i ) = ( (the Arrows of A) . (o1,o2) ) by A8
.= <^ o1,o2 ^> by ALTCAT_1:def 1;
assume ( ( (the Arrows of B) * (the ObjectMap of F) ) . i ) = ( {} );
then ( (the Arrows of B) . ( (the ObjectMap of F) . (o1,o2) ) ) = ( {} ) by A6,A8,FUNCT_2:15;
hence thesis by A9,FUNCTOR0:def 11;
end;
F is  injective by A1,FUNCTOR0:def 35;
then F is  faithful by FUNCTOR0:def 33;
then A10: (the MorphMap of F) is  "1-1" by FUNCTOR0:def 30;
(for i being set holds (i in I1 implies ( ( ( f "" ) * ( id I1 ) ) . i ) = ( ( f "" ) . i )))
proof
let i being set;
assume A11: i in I1;
then ( ( ( f "" ) * ( id I1 ) ) . i ) = ( ( f "" ) . ( ( id I1 ) . i ) ) by FUNCT_2:15
.= ( ( f "" ) . i ) by A11,FUNCT_1:18;
hence thesis;
end;
then A12: ( ( f "" ) * ( id I1 ) ) = ( f "" ) by PBOOLE:3;
F is  injective by A1,FUNCTOR0:def 35;
then F is  one-to-one by FUNCTOR0:def 33;
then A13: (the ObjectMap of F) is  one-to-one by FUNCTOR0:def 6;
(the ObjectMap of ( ( F " ) * F )) = ( (the ObjectMap of ( F " )) * (the ObjectMap of F) ) by FUNCTOR0:def 36;
then (the ObjectMap of ( ( F " ) * F )) = ( ( (the ObjectMap of F) " ) * (the ObjectMap of F) ) by A1,FUNCTOR0:def 38;
then A14: (the ObjectMap of ( ( F " ) * F )) = ( id [: (the carrier of A),(the carrier of A) :] ) by A13,A4,FUNCT_1:39;
F is  surjective by A1,FUNCTOR0:def 35;
then F is  full  onto by FUNCTOR0:def 34;
then A15: (ex k being (ManySortedFunction of (the Arrows of A),( (the Arrows of B) * (the ObjectMap of F) )) st (k = (the MorphMap of F) & k is  "onto")) by FUNCTOR0:def 32;
(the MorphMap of ( ( F " ) * F )) = ( ( ( ( f "" ) * ( (the ObjectMap of F) " ) ) * (the ObjectMap of F) ) ** f ) by A2,A3,FUNCTOR0:def 36
.= ( ( ( f "" ) * ( ( (the ObjectMap of F) " ) * (the ObjectMap of F) ) ) ** f ) by RELAT_1:36;
then (the MorphMap of ( ( F " ) * F )) = ( ( ( f "" ) * ( id I1 ) ) ** f ) by A13,A4,FUNCT_1:39;
then (the MorphMap of ( ( F " ) * F )) = ( id (the Arrows of A) ) by A5,A2,A10,A15,A12,CKB23:1;
hence thesis by A14,FUNCTOR0:def 29;
end;
