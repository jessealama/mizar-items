environ
vocabularies NUMBERS,XBOOLE_0,FUNCT_1,ZFMISC_1,XCMPLX_0,ORDINAL1,FUNCOP_1,SUBSET_1,FUNCT_2,RELAT_1,PARTFUN1,CLVECT_1,STRUCT_0,CFUNCT_1,RLVECT_1,LOPBAN_1,SUPINF_2,ARYTM_3,ARYTM_1,COMPLEX1,ALGSTR_0,MONOID_0,TARSKI,MSSUBFAM,UNIALG_1,RLSUB_1,RSSPACE,NAT_1,PRE_TOPC,SEQ_2,ORDINAL2,NORMSP_1,XREAL_0,XXREAL_0,CARD_1,REAL_1,XXREAL_2,SEQ_4,REWRITE1,RSSPACE3,CSSPACE3,SEQ_1,VALUED_1,CLOPBAN1,METRIC_1,RELAT_2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_3,PRE_TOPC,DOMAIN_1,FUNCOP_1,BINOP_1,XCMPLX_0,XXREAL_0,XXREAL_2,XREAL_0,COMPLEX1,REAL_1,NAT_1,STRUCT_0,ALGSTR_0,MONOID_0,ORDINAL1,NUMBERS,MEASURE6,RLVECT_1,NORMSP_0,NORMSP_1,VALUED_1,SEQ_1,SEQ_2,SEQ_4,FUNCSDOM,CFUNCT_1,CLVECT_1,CSSPACE,CSSPACE3,LOPBAN_1,GRCAT_1,CKB1,CKB2;
definitions SEQ_4,RLVECT_1,FUNCT_1,BINOP_1,STRUCT_0,ALGSTR_0,GRCAT_1,NORMSP_0,XXREAL_2,CKB2;
theorems ALGSTR_0,XBOOLE_0,TARSKI,ABSVALUE,RLVECT_1,BINOP_1,FUNCOP_1,XREAL_0,XCMPLX_0,SEQ_1,SEQ_2,FUNCT_1,NAT_1,FUNCT_2,SEQ_4,FUNCT_3,CLVECT_1,LOPBAN_1,CSSPACE,COMPLEX1,CSSPACE3,MONOID_0,XREAL_1,XXREAL_0,NORMSP_1,GRCAT_1,NORMSP_0,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12;
schemes SEQ_1,FUNCT_2,XBOOLE_0,BINOP_1;
registrations XBOOLE_0,SUBSET_1,ORDINAL1,RELSET_1,FUNCT_2,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,MEMBERED,STRUCT_0,RLVECT_1,MONOID_0,CLVECT_1,CSSPACE3,VALUED_1,VALUED_0,FUNCOP_1,SEQ_4,FUNCT_1;
constructors DOMAIN_1,FUNCT_3,XXREAL_0,REAL_1,NAT_1,COMPLEX1,SEQM_3,FUNCSDOM,MONOID_0,MEASURE6,LOPBAN_1,CSSPACE3,SEQ_1,XXREAL_2,SEQ_4,RELSET_1,BINOP_2,RVSUM_1,SEQ_2,CKB1,CKB2;
requirements SUBSET,REAL,BOOLE,NUMERALS,ARITHM;
begin
reserve X for non  empty set;
reserve Y for ComplexLinearSpace;
reserve a for Complex;
reserve b for Complex;
reserve u for (VECTOR of CLSStruct (# ( Funcs (X,(the carrier of Y)) ),( FuncZero (X,Y) ),( FuncAdd (X,Y) ),( FuncExtMult (X,Y) ) #));
reserve v for (VECTOR of CLSStruct (# ( Funcs (X,(the carrier of Y)) ),( FuncZero (X,Y) ),( FuncAdd (X,Y) ),( FuncExtMult (X,Y) ) #));
reserve w for (VECTOR of CLSStruct (# ( Funcs (X,(the carrier of Y)) ),( FuncZero (X,Y) ),( FuncAdd (X,Y) ),( FuncExtMult (X,Y) ) #));
theorem
Th11: CLSStruct (# ( Funcs (X,(the carrier of Y)) ),( FuncZero (X,Y) ),( FuncAdd (X,Y) ),( FuncExtMult (X,Y) ) #) is ComplexLinearSpace
proof
set IT = CLSStruct (# ( Funcs (X,(the carrier of Y)) ),( FuncZero (X,Y) ),( FuncAdd (X,Y) ),( FuncExtMult (X,Y) ) #);
A1: ( ( u + v ) + w ) = ( u + ( v + w ) ) by CKB6:1;
A2: u is  right_complementable
proof
reconsider u9 = u as (Element of ( Funcs (X,(the carrier of Y)) ));
reconsider w = ( ( FuncExtMult (X,Y) ) . [ ( - ( 1r ) ),u9 ] ) as (VECTOR of IT);
take w;
thus thesis by CKB8:1;
end;
A3: (for a being Complex holds (for u,v being (VECTOR of IT) holds ( a * ( u + v ) ) = ( ( a * u ) + ( a * v ) )))
proof
let a being Complex;
let u being (VECTOR of IT);
let v being (VECTOR of IT);
( a * ( u + v ) ) = ( ( a * u ) + ( a * v ) )
proof
reconsider v9 = v,u9 = u as (Element of ( Funcs (X,(the carrier of Y)) ));
reconsider w = ( ( FuncExtMult (X,Y) ) . [ a,u9 ] ),w9 = ( ( FuncExtMult (X,Y) ) . [ a,v9 ] ) as (VECTOR of IT);
( a * ( u + v ) ) = ( ( FuncExtMult (X,Y) ) . [ a,( ( FuncAdd (X,Y) ) . (u9,v9) ) ] ) by CLVECT_1:def 1
.= ( ( FuncAdd (X,Y) ) . (w,w9) ) by CKB12:1
.= ( w + ( a * v ) ) by CLVECT_1:def 1
.= ( ( a * u ) + ( a * v ) ) by CLVECT_1:def 1;
hence thesis;
end;
hence thesis;
end;
A4: (for a,b being Complex holds (for v being (VECTOR of IT) holds ( ( a * b ) * v ) = ( a * ( b * v ) )))
proof
let a being Complex;
let b being Complex;
let v being (VECTOR of IT);
reconsider v9 = v as (Element of ( Funcs (X,(the carrier of Y)) ));
thus ( ( a * b ) * v ) = ( ( FuncExtMult (X,Y) ) . [ ( a * b ),v9 ] ) by CLVECT_1:def 1
.= ( ( FuncExtMult (X,Y) ) . [ a,( ( FuncExtMult (X,Y) ) . [ b,v9 ] ) ] ) by CKB10:1
.= ( ( FuncExtMult (X,Y) ) . [ a,( b * v ) ] ) by CLVECT_1:def 1
.= ( a * ( b * v ) ) by CLVECT_1:def 1;
end;
A5: (for a,b being Complex holds (for v being (VECTOR of IT) holds ( ( a + b ) * v ) = ( ( a * v ) + ( b * v ) )))
proof
let a being Complex;
let b being Complex;
let v being (VECTOR of IT);
reconsider v9 = v as (Element of ( Funcs (X,(the carrier of Y)) ));
reconsider w = ( ( FuncExtMult (X,Y) ) . [ a,v9 ] ),w9 = ( ( FuncExtMult (X,Y) ) . [ b,v9 ] ) as (VECTOR of IT);
thus ( ( a + b ) * v ) = ( ( FuncExtMult (X,Y) ) . [ ( a + b ),v9 ] ) by CLVECT_1:def 1
.= ( ( FuncAdd (X,Y) ) . (w,w9) ) by CKB11:1
.= ( w + ( b * v ) ) by CLVECT_1:def 1
.= ( ( a * v ) + ( b * v ) ) by CLVECT_1:def 1;
end;
A6: ( u + ( 0. IT ) ) = u
proof
reconsider u9 = u as (Element of ( Funcs (X,(the carrier of Y)) ));
thus ( u + ( 0. IT ) ) = ( ( FuncAdd (X,Y) ) . (( FuncZero (X,Y) ),u9) ) by CKB5:1
.= u by CKB7:1;
end;
A7: (for v being (VECTOR of IT) holds ( ( 1r ) * v ) = v)
proof
let v being (VECTOR of IT);
reconsider v9 = v as (Element of ( Funcs (X,(the carrier of Y)) ));
thus ( ( 1r ) * v ) = ( ( FuncExtMult (X,Y) ) . [ ( 1r ),v9 ] ) by CLVECT_1:def 1
.= v by CKB9:1;
end;
( u + v ) = ( v + u ) by CKB5:1;
hence thesis by A1,A6,A2,A3,A5,A4,A7,ALGSTR_0:def 16,CLVECT_1:def 2,CLVECT_1:def 3,CLVECT_1:def 4,CLVECT_1:def 5,RLVECT_1:def 2,RLVECT_1:def 3,RLVECT_1:def 4;
end;
