environ
vocabularies FUNCT_1,RELAT_1,XBOOLE_0,TARSKI,SUBSET_1,ZFMISC_1,RELAT_2,PARTFUN1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,RELAT_2,RELSET_1,FUNCT_1;
definitions TARSKI,FUNCT_1,XBOOLE_0,RELAT_1,RELAT_2;
theorems TARSKI,FUNCT_1,GRFUNC_1,ZFMISC_1,RELAT_1,RELSET_1,XBOOLE_0,XBOOLE_1,RELAT_2,CKB1,CKB2;
schemes FUNCT_1,XBOOLE_0;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,RELSET_1;
constructors FUNCT_1,RELAT_2,RELSET_1;
requirements SUBSET,BOOLE;
begin
reserve x for set;
reserve y for set;
reserve y1 for set;
reserve y2 for set;
scheme LambdaC { A() -> set,C[set],F(set) -> set,G(set) -> set } : (ex f being Function st (( dom f ) = A() & (for x holds (x in A() implies ((C[ x ] implies ( f . x ) = F(x)) & ((not C[ x ]) implies ( f . x ) = G(x)))))))
proof
defpred P[ set,set ]
 means
((C[ $1 ] implies $2 = F($1)) & ((not C[ $1 ]) implies $2 = G($1)));
A1: (for x holds (x in A() implies (ex y st P[ x,y ])))
proof
let x;
((not C[ x ]) implies ((C[ x ] implies G(x) = F(x)) & ((not C[ x ]) implies G(x) = G(x))));
hence thesis;
end;
A2: (for x holds (for y1 holds (for y2 holds (((x in A() & P[ x,y1 ]) & P[ x,y2 ]) implies y1 = y2))));
thus (ex f being Function st (( dom f ) = A() & (for x holds (x in A() implies P[ x,( f . x ) ])))) from FUNCT_1:sch 2(A2,A1);
end;
