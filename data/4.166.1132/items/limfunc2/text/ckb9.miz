environ
vocabularies NUMBERS,REAL_1,SUBSET_1,SEQ_1,PARTFUN1,XREAL_0,ORDINAL1,CARD_1,ARYTM_3,XXREAL_0,ARYTM_1,RELAT_1,TARSKI,VALUED_1,XBOOLE_0,SEQ_2,ORDINAL2,FUNCT_1,FUNCOP_1,LIMFUNC1,FUNCT_2,XXREAL_1,COMPLEX1,XXREAL_2,NAT_1,VALUED_0,ORDINAL4,LIMFUNC2;
notations TARSKI,XBOOLE_0,SUBSET_1,ORDINAL1,NUMBERS,XCMPLX_0,XREAL_0,COMPLEX1,REAL_1,NAT_1,FUNCT_2,FUNCOP_1,VALUED_0,VALUED_1,SEQ_1,SEQ_2,RELSET_1,RCOMP_1,PARTFUN1,RFUNCT_1,LIMFUNC1,XXREAL_0;
definitions LIMFUNC1,PROB_1,VALUED_1;
theorems TARSKI,NAT_1,ABSVALUE,SEQ_1,SEQ_2,SEQM_3,SEQ_4,RFUNCT_1,RFUNCT_2,LIMFUNC1,RCOMP_1,FUNCT_1,XREAL_0,XBOOLE_0,XBOOLE_1,XCMPLX_0,FUNCOP_1,XREAL_1,COMPLEX1,XXREAL_0,VALUED_1,XXREAL_1,FUNCT_2,VALUED_0,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8;
schemes SEQ_1,FUNCT_2;
registrations ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,MEMBERED,XBOOLE_0,VALUED_0,VALUED_1,FUNCT_2,FUNCOP_1,SEQ_4;
constructors FUNCOP_1,REAL_1,NAT_1,COMPLEX1,SEQ_2,SEQM_3,PROB_1,RCOMP_1,RFUNCT_1,RFUNCT_2,LIMFUNC1,PARTFUN1,VALUED_1,SEQ_1,RELSET_1,BINOP_2,RVSUM_1;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve r for Real;
reserve r1 for Real;
reserve r2 for Real;
reserve g for Real;
reserve g2 for Real;
reserve f for (PartFunc of ( REAL ),( REAL ));
theorem
Th4: ((( 0 ) < r2 & ]. r1,( r1 + r2 ) .[ c= ( dom f )) implies (for r holds (r1 < r implies (ex g st ((g < r & r1 < g) & g in ( dom f ))))))
proof
assume that
A1: ( 0 ) < r2
and
A2: ]. r1,( r1 + r2 ) .[ c= ( dom f );
let r;
assume that
A3: r1 < r;
now
per cases ;
suppose A4: ( r1 + r2 ) <= r;

r1 < ( r1 + r2 ) by A1,CKB1:1;
then consider g being  real number such that A5: r1 < g and A6: g < ( r1 + r2 ) by XREAL_1:5;
reconsider g as Real by XREAL_0:def 1;
take g;
thus (g < r & r1 < g) by A4,A5,A6,XXREAL_0:2;
g in { g2: (r1 < g2 & g2 < ( r1 + r2 )) } by A5,A6;
then g in ]. r1,( r1 + r2 ) .[ by RCOMP_1:def 2;
hence g in ( dom f ) by A2;
end;
suppose A7: r <= ( r1 + r2 );

consider g being  real number such that A8: r1 < g and A9: g < r by A3,XREAL_1:5;
reconsider g as Real by XREAL_0:def 1;
take g;
thus (g < r & r1 < g) by A8,A9;
g < ( r1 + r2 ) by A7,A9,XXREAL_0:2;
then g in { g2: (r1 < g2 & g2 < ( r1 + r2 )) } by A8;
then g in ]. r1,( r1 + r2 ) .[ by RCOMP_1:def 2;
hence g in ( dom f ) by A2;
end;
end;
hence thesis;
end;
