environ
vocabularies NUMBERS,XREAL_0,ORDINAL1,SUBSET_1,REAL_1,PRE_TOPC,METRIC_1,COMPLEX1,ARYTM_1,FUNCT_1,SEQ_1,ORDINAL2,RELAT_1,TARSKI,XXREAL_0,ARYTM_3,CARD_1,POWER,LIMFUNC1,NEWTON,TOPMETR,RCOMP_1,XXREAL_1,STRUCT_0,PCOMPS_1,SETFAM_1,FINSET_1,XBOOLE_0,VALUED_0,SEQ_2,NAT_1,ZFMISC_1,XXREAL_2,VALUED_1;
notations TARSKI,XBOOLE_0,SUBSET_1,SETFAM_1,ORDINAL1,NUMBERS,XCMPLX_0,XREAL_0,COMPLEX1,REAL_1,NAT_1,RELAT_1,FUNCT_2,METRIC_1,FINSET_1,BINOP_1,STRUCT_0,PRE_TOPC,COMPTS_1,PCOMPS_1,VALUED_0,VALUED_1,SEQ_1,SEQ_2,LIMFUNC1,POWER,RCOMP_1,NEWTON,TOPMETR,XXREAL_0,RECDEF_1;
definitions XCMPLX_0,TARSKI,FUNCT_2,SEQ_2,LIMFUNC1;
theorems ABSVALUE,FUNCT_1,FUNCT_2,TOPMETR,LIMFUNC1,METRIC_1,NAT_1,NEWTON,POWER,PCOMPS_1,RCOMP_1,SEQ_1,SEQ_2,SEQ_4,SEQM_3,TARSKI,ZFMISC_1,XREAL_0,XBOOLE_1,XCMPLX_1,XREAL_1,COMPLEX1,COMPTS_1,XXREAL_0,XXREAL_1,VALUED_0,VALUED_1,SETFAM_1,RELSET_1,CKB1;
schemes RECDEF_1,NAT_1,SEQ_1;
registrations XBOOLE_0,SUBSET_1,ORDINAL1,RELSET_1,FINSET_1,NUMBERS,XXREAL_0,XREAL_0,MEMBERED,PRE_TOPC,METRIC_1,VALUED_1,FUNCT_2,VALUED_0;
constructors SETFAM_1,REAL_1,NAT_1,SEQ_2,SEQM_3,SEQ_4,RCOMP_1,LIMFUNC1,NEWTON,POWER,COMPTS_1,TOPMETR,SEQ_1,VALUED_1,RECDEF_1,PCOMPS_1;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve k for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
reserve seq for Real_Sequence;
theorem
Th6: ((seq is  increasing & ( rng seq ) c= ( NAT )) implies n <= ( seq . n ))
proof
defpred P[ (Element of ( NAT )) ]
 means
$1 <= ( seq . $1 );
assume that
A1: seq is  increasing
and
A2: ( rng seq ) c= ( NAT );
A3: (for k holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k;
assume that
A4: k <= ( seq . k );
( k + 1 ) in ( NAT );
then ( k + 1 ) in ( dom seq ) by FUNCT_2:def 1;
then ( seq . ( k + 1 ) ) in ( rng seq ) by FUNCT_1:def 3;
then reconsider k9 = ( seq . ( k + 1 ) ) as (Element of ( NAT )) by A2;
( seq . k ) < ( seq . ( k + 1 ) ) by A1,SEQM_3:def 6;
then k < k9 by A4,XXREAL_0:2;
hence thesis by NAT_1:13;
end;
( 0 ) in ( NAT );
then ( 0 ) in ( dom seq ) by FUNCT_2:def 1;
then ( seq . ( 0 ) ) in ( rng seq ) by FUNCT_1:def 3;
then A5: P[ ( 0 ) ] by A2,NAT_1:2;
(for n holds P[ n ]) from NAT_1:sch 1(A5,A3);
hence thesis;
end;
