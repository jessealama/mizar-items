environ
vocabularies NUMBERS,STRUCT_0,RELAT_1,XBOOLE_0,SUBSET_1,FINSEQ_1,TDGROUP,TARSKI,ORDINAL4,ARYTM_3,CARD_1,FUNCT_1,XXREAL_0,NAT_1,ZFMISC_1,ORDINAL1,FINSET_1,LANG1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,NUMBERS,NAT_1,DOMAIN_1,RELAT_1,STRUCT_0,FUNCT_1,FINSEQ_1,FINSET_1,RELSET_1,PARTFUN1,FUNCT_2,FINSEQ_2,XXREAL_0,PRE_POLY,CKB1,CKB3,CKB5,CKB6,CKB7,CKB8,CKB9,CKB11,CKB16,CKB20,CKB22,CKB23,CKB24,CKB25,CKB26,CKB30;
definitions XBOOLE_0,TARSKI,RELAT_1,STRUCT_0,ORDINAL1,CKB7,CKB8,CKB9,CKB11,CKB16,CKB20,CKB24,CKB25,CKB26,CKB30;
theorems TARSKI,ZFMISC_1,RELAT_1,FINSEQ_1,NAT_1,RELSET_1,TREES_2,FUNCT_2,FINSEQ_3,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,ORDINAL1,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB24,CKB25,CKB26,CKB30,CKB32,CKB33;
schemes NAT_1,FUNCT_2;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,FUNCT_2,FINSET_1,XXREAL_0,XREAL_0,FINSEQ_1,STRUCT_0,ORDINAL1,CARD_1,RELSET_1,CKB1,CKB2,CKB3,CKB4,CKB27,CKB28,CKB29,CKB31;
constructors PARTFUN1,DOMAIN_1,XXREAL_0,XREAL_0,NAT_1,FINSEQ_2,STRUCT_0,RELSET_1,PRE_POLY,CKB1,CKB3,CKB7,CKB8,CKB9,CKB11,CKB16,CKB20,CKB22,CKB23,CKB24,CKB25,CKB26,CKB30;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve a for set;
reserve b for set;
reserve c for set;
theorem
Th12: (a <> b implies ( Terminals ( SingleGrammar (a,b) ) ) = { b })
proof
set E = ( SingleGrammar (a,b) );
A1: (the Rules of E) = { [ a,<* b *> ] } by CKB25:def 1;
A2: (the carrier of E) = { a,b } by CKB25:def 1;
then reconsider x = a,y = b as (Symbol of E) by TARSKI:def 2;
assume A3: a <> b;
A4:now
let n being FinSequence;
assume y ==> n;
then [ y,n ] in { [ a,<* b *> ] } by A1,CKB7:def 1;
then [ y,n ] = [ a,<* b *> ] by TARSKI:def 1;
hence contradiction by A3,ZFMISC_1:27;
end;
[ x,<* y *> ] in (the Rules of E) by A1,TARSKI:def 1;
then A5: x ==> <* y *> by CKB7:def 1;
thus ( Terminals E ) c= { b }
proof
let c;
assume c in ( Terminals E );
then consider s being (Symbol of E) such that A6: c = s and A7: (not (ex n being FinSequence st s ==> n));
s <> x by A5,A7;
then c = b by A2,A6,TARSKI:def 2;
hence thesis by TARSKI:def 1;
end;

let c;
assume c in { b };
then c = b by TARSKI:def 1;
hence thesis by A4;
end;
