environ
vocabularies NUMBERS,XBOOLE_0,STRUCT_0,SUBSET_1,FUNCT_2,FINSET_1,FUNCT_1,CARD_1,FUNCOP_1,COMPLEX1,ALGSTR_0,RLVECT_2,TARSKI,NAT_1,CLVECT_1,FINSEQ_1,VALUED_1,RELAT_1,PARTFUN1,XXREAL_0,RLVECT_1,CFUNCT_1,CARD_3,SUPINF_2,RLSUB_1,ARYTM_3,ARYTM_1,QC_LANG1,BINOP_1,ZFMISC_1,RUSUB_4,REAL_1,REALSET1,XREAL_0,ORDINAL1,XCMPLX_0,CONVEX1,SETFAM_1,CSSPACE,PROB_2,CONVEX4,PRE_POLY;
notations TARSKI,XBOOLE_0,DOMAIN_1,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,PRE_POLY,RELSET_1,FUNCT_2,FINSEQ_1,FINSEQ_4,ALGSTR_0,RLVECT_1,SETFAM_1,STRUCT_0,ORDINAL1,NUMBERS,XXREAL_0,XREAL_0,FINSET_1,PARTFUN1,FUNCOP_1,CARD_1,VALUED_1,XCMPLX_0,COMPLEX1,RVSUM_1,RUSUB_4,RUSUB_5,NAT_1,BINOP_1,REAL_1,RLVECT_2,CFUNCT_1,CLVECT_1,CSSPACE,REALSET1,CKB1,CKB2,CKB3,CKB6,CKB9,CKB13,CKB19,CKB28,CKB29,CKB32,CKB36,CKB44,CKB48,CKB53,CKB55,CKB56,CKB57,CKB58;
definitions FUNCT_1,TARSKI,XBOOLE_0,BINOP_1,RELAT_1,STRUCT_0,REALSET1,FINSEQ_1,CLVECT_1,COMPLEX1,RVSUM_1,XCMPLX_0,ALGSTR_0,RUSUB_4,RUSUB_5,CKB1,CKB3,CKB6,CKB9,CKB13,CKB19,CKB28,CKB29,CKB36,CKB44,CKB48,CKB53,CKB55,CKB56,CKB57,CKB58;
theorems SUBSET_1,STRUCT_0,RVSUM_1,SETFAM_1,ENUMSET1,BINOP_1,CARD_1,CARD_2,FINSEQ_1,FINSEQ_3,FINSEQ_4,FUNCT_1,FUNCT_2,NAT_1,RLVECT_1,RLVECT_2,TARSKI,ZFMISC_1,RELAT_1,RELSET_1,XBOOLE_0,XBOOLE_1,COMPLEX1,XCMPLX_1,FUNCOP_1,XREAL_1,XXREAL_0,FINSOP_1,CLVECT_1,CSSPACE,CONVEX1,PARTFUN1,XREAL_0,VALUED_1,ALGSTR_0,PRE_POLY,CKB1,CKB3,CKB5,CKB6,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB55,CKB56,CKB57,CKB58;
schemes DOMAIN_1,BINOP_1,SUBSET_1,FINSEQ_1,FUNCT_2,NAT_1,XBOOLE_0;
registrations STRUCT_0,MEMBERED,XXREAL_0,CSSPACE,RLVECT_1,RELSET_1,FINSET_1,XREAL_0,SUBSET_1,XCMPLX_0,CLVECT_1,XBOOLE_0,NUMBERS,NAT_1,FUNCT_2,VALUED_1,VALUED_0,CARD_1,FINSEQ_1,CKB4,CKB7,CKB54;
constructors SETFAM_1,BINOP_1,FUNCOP_1,XXREAL_0,REAL_1,FINSEQ_4,COMPLEX1,REALSET1,BINOP_2,FINSOP_1,RVSUM_1,RLVECT_2,RUSUB_5,CSSPACE,RELSET_1,CKB1,CKB3,CKB6,CKB9,CKB13,CKB19,CKB28,CKB29,CKB32,CKB36,CKB44,CKB48,CKB53,CKB55,CKB56,CKB57,CKB58;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve V for non  empty CLSStruct;
reserve u for (VECTOR of V);
reserve v for (VECTOR of V);
reserve a for Complex;
reserve b for Complex;
reserve K for (C_Linear_Combination of V);
reserve L for (C_Linear_Combination of V);
definition
let V;
func LC_CLSpace V -> ComplexLinearSpace equals 
CLSStruct (# ( C_LinComb V ),( @ ( ZeroCLC V ) ),( C_LCAdd V ),( C_LCMult V ) #);
coherence
proof
set S = CLSStruct (# ( C_LinComb V ),( @ ( ZeroCLC V ) ),( C_LCAdd V ),( C_LCMult V ) #);
A1:now
let a being Complex;
let b being Complex;
let v being (VECTOR of S);
let u being (VECTOR of S);
let w being (VECTOR of S);
reconsider x = v,y = u,z = w,yx = ( u + v ),xz = ( v + w ),ax = ( a * v ),az = ( a * w ),bx = ( b * v ) as (Element of ( C_LinComb V ));
A2: (( @ z ) = w & ( @ yx ) = ( u + v ));
A3: (( @ xz ) = ( v + w ) & ( @ ax ) = ( a * v ));
A4: (( @ az ) = ( a * w ) & ( @ bx ) = ( b * v ));
(( @ x ) = v & ( @ y ) = u);
then reconsider K = v,L = u,M = w,LK = ( u + v ),KM = ( v + w ),aK = ( a * v ),aM = ( a * w ),bK = ( b * v ) as (C_Linear_Combination of V) by A2,A3,A4;
A5:now
let v being (VECTOR of S);
let u being (VECTOR of S);
let K;
let L;
A6: (( @ ( @ K ) ) = K & ( @ ( @ L ) ) = L);
assume (v = K & u = L);
hence ( v + u ) = ( K + L ) by A6,CKB57:def 1;
end;
hence ( v + w ) = ( K + M )
.= ( w + v ) by A5;
thus ( ( u + v ) + w ) = ( LK + M ) by A5
.= ( ( L + K ) + M ) by A5
.= ( L + ( K + M ) ) by CKB34:1
.= ( L + KM ) by A5
.= ( u + ( v + w ) ) by A5;
thus ( v + ( 0. S ) ) = ( K + ( ZeroCLC V ) ) by A5
.= v by CKB35:1;
( - K ) in (the carrier of S) by CKB53:def 1;
then ( - K ) in S by STRUCT_0:def 5;
then ( - K ) = ( vector (S,( - K )) ) by RLVECT_2:def 1;
then ( v + ( vector (S,( - K )) ) ) = ( K - K ) by A5
.= ( 0. S ) by CKB52:1;
hence (ex w being (VECTOR of S) st ( v + w ) = ( 0. S ));
A7:now
let v being (VECTOR of S);
let L;
let a;
assume v = L;
then ( ( C_LCMult V ) . [ a,v ] ) = ( a * ( @ ( @ L ) ) ) by CKB58:def 1;
hence ( a * v ) = ( a * L );
end;
hence ( a * ( v + w ) ) = ( a * KM )
.= ( a * ( K + M ) ) by A5
.= ( ( a * K ) + ( a * M ) ) by CKB41:1
.= ( aK + ( a * M ) ) by A7
.= ( aK + aM ) by A7
.= ( ( a * v ) + ( a * w ) ) by A5;
thus ( ( a + b ) * v ) = ( ( a + b ) * K ) by A7
.= ( ( a * K ) + ( b * K ) ) by CKB40:1
.= ( aK + ( b * K ) ) by A7
.= ( aK + bK ) by A7
.= ( ( a * v ) + ( b * v ) ) by A5;
thus ( ( a * b ) * v ) = ( ( a * b ) * K ) by A7
.= ( a * ( b * K ) ) by CKB42:1
.= ( a * bK ) by A7
.= ( a * ( b * v ) ) by A7;
thus ( ( 1r ) * v ) = ( ( 1r ) * K ) by A7
.= v by CKB43:1;
end;
A8:now
let v being (Element of S);
(ex w being (VECTOR of S) st ( v + w ) = ( 0. S )) by A1;
hence v is  right_complementable by ALGSTR_0:def 11;
end;
(for u,v,w being (VECTOR of S) holds ( ( u + v ) + w ) = ( u + ( v + w ) )) by A1;
hence thesis by A1,A8,ALGSTR_0:def 16,CLVECT_1:def 2,CLVECT_1:def 3,CLVECT_1:def 4,CLVECT_1:def 5,RLVECT_1:def 2,RLVECT_1:def 3,RLVECT_1:def 4;
end;
end;
