environ
vocabularies SUBSET_1,CQC_LANG,XBOOLEAN,CQC_THE1;
notations SUBSET_1,CQC_LANG,CQC_THE1;
theorems CQC_THE1,QC_LANG2,LUKASI_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38;
registrations CQC_LANG;
constructors CQC_THE1;
begin
reserve p for (Element of ( CQC-WFF ));
reserve q for (Element of ( CQC-WFF ));
reserve r for (Element of ( CQC-WFF ));
theorem
Th35: ( ( p => r ) => ( ( q => r ) => ( ( p 'or' q ) => r ) ) ) in ( TAUT )
proof
set A = ( ( 'not' r ) => ( 'not' p ) );
set B = ( ( 'not' r ) => ( 'not' q ) );
set C = ( ( 'not' r ) => ( ( 'not' p ) '&' ( 'not' q ) ) );
set D = ( ( p 'or' q ) => r );
set E = ( q => r );
A1: ( A => ( B => C ) ) in ( TAUT ) by CKB37:1;
( C => ( ( 'not' ( ( 'not' p ) '&' ( 'not' q ) ) ) => r ) ) in ( TAUT ) by LUKASI_1:31;
then ( C => D ) in ( TAUT ) by QC_LANG2:def 3;
then A2: ( B => ( C => D ) ) in ( TAUT ) by LUKASI_1:13;
( ( B => ( C => D ) ) => ( ( B => C ) => ( B => D ) ) ) in ( TAUT ) by LUKASI_1:11;
then ( ( B => C ) => ( B => D ) ) in ( TAUT ) by A2,CQC_THE1:46;
then ( A => ( B => D ) ) in ( TAUT ) by A1,LUKASI_1:3;
then A3: ( B => ( A => D ) ) in ( TAUT ) by LUKASI_1:15;
( E => B ) in ( TAUT ) by LUKASI_1:26;
then ( E => ( A => D ) ) in ( TAUT ) by A3,LUKASI_1:3;
then A4: ( A => ( E => D ) ) in ( TAUT ) by LUKASI_1:15;
( ( p => r ) => A ) in ( TAUT ) by LUKASI_1:26;
hence thesis by A4,LUKASI_1:3;
end;
