environ
vocabularies SUBSET_1,NUMBERS,QC_LANG1,FINSEQ_1,PARTFUN1,XXREAL_0,FUNCT_1,RELAT_1,NAT_1,TARSKI,FUNCOP_1,QC_LANG3,XBOOLE_0,ZF_MODEL,FINSEQ_2,ZF_LANG,CARD_1,REALSET1,XBOOLEAN,BVFUNC_2,MARGREL1,CLASSES2,FUNCT_4,CQC_LANG;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,FUNCT_2,BINOP_1,PARTFUN1,FUNCOP_1,FUNCT_4,FINSEQ_1,FINSEQ_2,QC_LANG1,QC_LANG2,QC_LANG3,XXREAL_0,NAT_1,CKB3,CKB4,CKB7,CKB9,CKB13,CKB17,CKB20,CKB21,CKB22,CKB26,CKB27,CKB28,CKB30,CKB32;
definitions TARSKI,FUNCOP_1,FINSEQ_2,RELAT_1,CKB4,CKB9;
theorems TARSKI,ENUMSET1,ZFMISC_1,FUNCT_1,FUNCT_2,FINSEQ_1,PARTFUN1,FUNCOP_1,QC_LANG1,QC_LANG2,QC_LANG3,FINSEQ_2,RELSET_1,FINSEQ_3,FUNCT_4,ORDINAL1,RELAT_1,CARD_1,CKB1,CKB2,CKB4,CKB6,CKB8,CKB9,CKB11,CKB14,CKB15,CKB16,CKB18,CKB19,CKB23,CKB24,CKB25,CKB29,CKB31;
schemes FINSEQ_1,QC_LANG1,QC_LANG3;
registrations XBOOLE_0,RELSET_1,FUNCOP_1,FUNCT_4,MEMBERED,QC_LANG1,XXREAL_0,FINSEQ_2,CARD_1,CKB5,CKB10,CKB12;
constructors ENUMSET1,PARTFUN1,BINOP_1,FUNCOP_1,FUNCT_4,XXREAL_0,MEMBERED,QC_LANG2,QC_LANG3,FINSEQ_2,RELSET_1,CKB4,CKB7,CKB9,CKB17,CKB20,CKB21,CKB22,CKB26,CKB27,CKB28,CKB30,CKB32;
requirements NUMERALS,SUBSET,BOOLE;
begin
reserve i for (Element of ( NAT ));
reserve j for (Element of ( NAT ));
reserve k for (Element of ( NAT ));
reserve x for bound_QC-variable;
reserve p for (Element of ( QC-WFF ));
reserve q for (Element of ( QC-WFF ));
reserve l for (FinSequence of ( QC-variables ));
reserve r for (Element of ( CQC-WFF ));
reserve s for (Element of ( CQC-WFF ));
scheme CQCInd { P[set] } : (for r holds P[ r ])
provided
A1: (for r holds (for s holds (for x holds (for k holds (for l being (CQC-variable_list of k) holds (for P being (QC-pred_symbol of k) holds ((((P[ ( VERUM ) ] & P[ ( P ! l ) ]) & (P[ r ] implies P[ ( 'not' r ) ])) & ((P[ r ] & P[ s ]) implies P[ ( r '&' s ) ])) & (P[ r ] implies P[ ( All (x,r) ) ]))))))))
proof
defpred Prop[ (Element of ( QC-WFF )) ]
 means
($1 is (Element of ( CQC-WFF )) implies P[ $1 ]);
A2: (for p being (Element of ( QC-WFF )) holds (Prop[ p ] implies Prop[ ( 'not' p ) ]))
proof
let p being (Element of ( QC-WFF ));
assume A3: Prop[ p ];
assume ( 'not' p ) is (Element of ( CQC-WFF ));
then p is (Element of ( CQC-WFF )) by CKB18:1;
hence thesis by A1,A3;
end;
A4: (for p,q being (Element of ( QC-WFF )) holds ((Prop[ p ] & Prop[ q ]) implies Prop[ ( p '&' q ) ]))
proof
let p being (Element of ( QC-WFF ));
let q being (Element of ( QC-WFF ));
assume A5: (Prop[ p ] & Prop[ q ]);
assume ( p '&' q ) is (Element of ( CQC-WFF ));
then (p is (Element of ( CQC-WFF )) & q is (Element of ( CQC-WFF ))) by CKB19:1;
hence thesis by A1,A5;
end;
A6: (for k being (Element of ( NAT )) holds (for P being (QC-pred_symbol of k) holds (for l being (QC-variable_list of k) holds Prop[ ( P ! l ) ])))
proof
let k being (Element of ( NAT ));
let P being (QC-pred_symbol of k);
let l being (QC-variable_list of k);
assume A7: ( P ! l ) is (Element of ( CQC-WFF ));
then A8: { ( l . j ): ((1 <= j & j <= ( len l )) & ( l . j ) in ( fixed_QC-variables )) } = ( {} ) by CKB16:1;
{ ( l . i ): ((1 <= i & i <= ( len l )) & ( l . i ) in ( free_QC-variables )) } = ( {} ) by A7,CKB16:1;
then l is (CQC-variable_list of k) by A8,CKB14:1;
hence thesis by A1;
end;
A9: (for x being bound_QC-variable holds (for p being (Element of ( QC-WFF )) holds (Prop[ p ] implies Prop[ ( All (x,p) ) ])))
proof
let x being bound_QC-variable;
let p being (Element of ( QC-WFF ));
assume A10: Prop[ p ];
assume ( All (x,p) ) is (Element of ( CQC-WFF ));
then p is (Element of ( CQC-WFF )) by CKB29:1;
hence thesis by A1,A10;
end;
A11: Prop[ ( VERUM ) ] by A1;
(for p being (Element of ( QC-WFF )) holds Prop[ p ]) from QC_LANG1:sch 1(A6,A11,A2,A4,A9);
hence thesis;
end;
