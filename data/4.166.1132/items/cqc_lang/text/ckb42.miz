environ
vocabularies SUBSET_1,NUMBERS,QC_LANG1,FINSEQ_1,PARTFUN1,XXREAL_0,FUNCT_1,RELAT_1,NAT_1,TARSKI,FUNCOP_1,QC_LANG3,XBOOLE_0,ZF_MODEL,FINSEQ_2,ZF_LANG,CARD_1,REALSET1,XBOOLEAN,BVFUNC_2,MARGREL1,CLASSES2,FUNCT_4,CQC_LANG;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,FUNCT_2,BINOP_1,PARTFUN1,FUNCOP_1,FUNCT_4,FINSEQ_1,FINSEQ_2,QC_LANG1,QC_LANG2,QC_LANG3,XXREAL_0,NAT_1,CKB3,CKB4,CKB7,CKB9,CKB13,CKB17,CKB20,CKB21,CKB22,CKB26,CKB27,CKB28,CKB30,CKB32;
definitions TARSKI,FUNCOP_1,FINSEQ_2,RELAT_1,CKB4,CKB9;
theorems TARSKI,ENUMSET1,ZFMISC_1,FUNCT_1,FUNCT_2,FINSEQ_1,PARTFUN1,FUNCOP_1,QC_LANG1,QC_LANG2,QC_LANG3,FINSEQ_2,RELSET_1,FINSEQ_3,FUNCT_4,ORDINAL1,RELAT_1,CARD_1,CKB1,CKB2,CKB4,CKB6,CKB8,CKB9,CKB11,CKB14,CKB15,CKB16,CKB18,CKB19,CKB23,CKB24,CKB25,CKB29,CKB31;
schemes FINSEQ_1,QC_LANG1,QC_LANG3,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41;
registrations XBOOLE_0,RELSET_1,FUNCOP_1,FUNCT_4,MEMBERED,QC_LANG1,XXREAL_0,FINSEQ_2,CARD_1,CKB5,CKB10,CKB12;
constructors ENUMSET1,PARTFUN1,BINOP_1,FUNCOP_1,FUNCT_4,XXREAL_0,MEMBERED,QC_LANG2,QC_LANG3,FINSEQ_2,RELSET_1,CKB4,CKB7,CKB9,CKB17,CKB20,CKB21,CKB22,CKB26,CKB27,CKB28,CKB30,CKB32;
requirements NUMERALS,SUBSET,BOOLE;
begin
reserve x for bound_QC-variable;
reserve q for (Element of ( QC-WFF ));
theorem
Lm2: (for F1,F2 being (Function of ( QC-WFF ),( QC-WFF )) holds (((for q holds ((((( F1 . ( VERUM ) ) = ( VERUM ) & (q is  atomic implies ( F1 . q ) = ( ( the_pred_symbol_of q ) ! ( Subst (( the_arguments_of q ),( ( a. ( 0 ) ) .--> x )) ) ))) & (q is  negative implies ( F1 . q ) = ( 'not' ( F1 . ( the_argument_of q ) ) ))) & (q is  conjunctive implies ( F1 . q ) = ( ( F1 . ( the_left_argument_of q ) ) '&' ( F1 . ( the_right_argument_of q ) ) ))) & (q is  universal implies ( F1 . q ) = ( IFEQ (( bound_in q ),x,q,( All (( bound_in q ),( F1 . ( the_scope_of q ) )) )) )))) & (for q holds ((((( F2 . ( VERUM ) ) = ( VERUM ) & (q is  atomic implies ( F2 . q ) = ( ( the_pred_symbol_of q ) ! ( Subst (( the_arguments_of q ),( ( a. ( 0 ) ) .--> x )) ) ))) & (q is  negative implies ( F2 . q ) = ( 'not' ( F2 . ( the_argument_of q ) ) ))) & (q is  conjunctive implies ( F2 . q ) = ( ( F2 . ( the_left_argument_of q ) ) '&' ( F2 . ( the_right_argument_of q ) ) ))) & (q is  universal implies ( F2 . q ) = ( IFEQ (( bound_in q ),x,q,( All (( bound_in q ),( F2 . ( the_scope_of q ) )) )) ))))) implies F1 = F2))
proof
deffunc c((Element of ( QC-WFF )),(Element of ( QC-WFF ))) = ( $1 '&' $2 );
deffunc n((Element of ( QC-WFF ))) = ( 'not' $1 );
let F1 being (Function of ( QC-WFF ),( QC-WFF ));
let F2 being (Function of ( QC-WFF ),( QC-WFF ));
deffunc a((Element of ( QC-WFF ))) = ( ( the_pred_symbol_of $1 ) ! ( Subst (( the_arguments_of $1 ),( ( a. ( 0 ) ) .--> x )) ) );
deffunc q((Element of ( QC-WFF )),(Element of ( QC-WFF ))) = ( IFEQ (( bound_in $1 ),x,$1,( All (( bound_in $1 ),$2) )) );
assume (for q holds ((((( F1 . ( VERUM ) ) = ( VERUM ) & (q is  atomic implies ( F1 . q ) = a(q))) & (q is  negative implies ( F1 . q ) = ( 'not' ( F1 . ( the_argument_of q ) ) ))) & (q is  conjunctive implies ( F1 . q ) = ( ( F1 . ( the_left_argument_of q ) ) '&' ( F1 . ( the_right_argument_of q ) ) ))) & (q is  universal implies ( F1 . q ) = ( IFEQ (( bound_in q ),x,q,( All (( bound_in q ),( F1 . ( the_scope_of q ) )) )) ))));
then A1: (for p being (Element of ( QC-WFF )) holds (for d1,d2 being (Element of ( QC-WFF )) holds (((((p = ( VERUM ) implies ( F1 . p ) = ( VERUM )) & (p is  atomic implies ( F1 . p ) = a(p))) & ((p is  negative & d1 = ( F1 . ( the_argument_of p ) )) implies ( F1 . p ) = n(d1))) & (((p is  conjunctive & d1 = ( F1 . ( the_left_argument_of p ) )) & d2 = ( F1 . ( the_right_argument_of p ) )) implies ( F1 . p ) = c(d1,d2))) & ((p is  universal & d1 = ( F1 . ( the_scope_of p ) )) implies ( F1 . p ) = q(p,d1)))));
assume (for q holds ((((( F2 . ( VERUM ) ) = ( VERUM ) & (q is  atomic implies ( F2 . q ) = ( ( the_pred_symbol_of q ) ! ( Subst (( the_arguments_of q ),( ( a. ( 0 ) ) .--> x )) ) ))) & (q is  negative implies ( F2 . q ) = ( 'not' ( F2 . ( the_argument_of q ) ) ))) & (q is  conjunctive implies ( F2 . q ) = ( ( F2 . ( the_left_argument_of q ) ) '&' ( F2 . ( the_right_argument_of q ) ) ))) & (q is  universal implies ( F2 . q ) = ( IFEQ (( bound_in q ),x,q,( All (( bound_in q ),( F2 . ( the_scope_of q ) )) )) ))));
then A2: (for p being (Element of ( QC-WFF )) holds (for d1,d2 being (Element of ( QC-WFF )) holds (((((p = ( VERUM ) implies ( F2 . p ) = ( VERUM )) & (p is  atomic implies ( F2 . p ) = a(p))) & ((p is  negative & d1 = ( F2 . ( the_argument_of p ) )) implies ( F2 . p ) = n(d1))) & (((p is  conjunctive & d1 = ( F2 . ( the_left_argument_of p ) )) & d2 = ( F2 . ( the_right_argument_of p ) )) implies ( F2 . p ) = c(d1,d2))) & ((p is  universal & d1 = ( F2 . ( the_scope_of p ) )) implies ( F2 . p ) = q(p,d1)))));
thus F1 = F2 from QC_LANG3:sch 1(A1,A2);
end;
