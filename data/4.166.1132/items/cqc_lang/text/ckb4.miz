environ
vocabularies SUBSET_1,NUMBERS,QC_LANG1,FINSEQ_1,PARTFUN1,XXREAL_0,FUNCT_1,RELAT_1,NAT_1,TARSKI,FUNCOP_1,QC_LANG3,XBOOLE_0,ZF_MODEL,FINSEQ_2,ZF_LANG,CARD_1,REALSET1,XBOOLEAN,BVFUNC_2,MARGREL1,CLASSES2,FUNCT_4,CQC_LANG;
notations TARSKI,XBOOLE_0,ENUMSET1,SUBSET_1,CARD_1,NUMBERS,RELAT_1,FUNCT_1,FUNCT_2,BINOP_1,PARTFUN1,FUNCOP_1,FUNCT_4,FINSEQ_1,FINSEQ_2,QC_LANG1,QC_LANG2,QC_LANG3,XXREAL_0,NAT_1,CKB3;
definitions TARSKI,FUNCOP_1,FINSEQ_2,RELAT_1;
theorems TARSKI,ENUMSET1,ZFMISC_1,FUNCT_1,FUNCT_2,FINSEQ_1,PARTFUN1,FUNCOP_1,QC_LANG1,QC_LANG2,QC_LANG3,FINSEQ_2,RELSET_1,FINSEQ_3,FUNCT_4,ORDINAL1,RELAT_1,CARD_1,CKB1,CKB2;
schemes FINSEQ_1,QC_LANG1,QC_LANG3;
registrations XBOOLE_0,RELSET_1,FUNCOP_1,FUNCT_4,MEMBERED,QC_LANG1,XXREAL_0,FINSEQ_2,CARD_1;
constructors ENUMSET1,PARTFUN1,BINOP_1,FUNCOP_1,FUNCT_4,XXREAL_0,MEMBERED,QC_LANG2,QC_LANG3,FINSEQ_2,RELSET_1;
requirements NUMERALS,SUBSET,BOOLE;
begin
reserve k for (Element of ( NAT ));
reserve x for bound_QC-variable;
reserve y for bound_QC-variable;
reserve l for (FinSequence of ( QC-variables ));
reserve l1 for (FinSequence of ( QC-variables ));
reserve l2 for (FinSequence of ( QC-variables ));
reserve f for Substitution;
definition
let l;
let f;
func Subst (l,f) -> (FinSequence of ( QC-variables )) means 
:Def3: (( len it ) = ( len l ) & (for k holds ((1 <= k & k <= ( len l )) implies ((( l . k ) in ( dom f ) implies ( it . k ) = ( f . ( l . k ) )) & ((not ( l . k ) in ( dom f )) implies ( it . k ) = ( l . k ))))));
existence
proof
defpred P[ set,set ]
 means
((( l . $1 ) in ( dom f ) implies $2 = ( f . ( l . $1 ) )) & ((not ( l . $1 ) in ( dom f )) implies $2 = ( l . $1 )));
A1: (for k being Nat holds (k in ( Seg ( len l ) ) implies (ex y being set st P[ k,y ])))
proof
let k being Nat;
assume k in ( Seg ( len l ) );
(( l . k ) in ( dom f ) implies thesis);
hence thesis;
end;
consider s being FinSequence such that A2: ( dom s ) = ( Seg ( len l ) ) and A3: (for k being Nat holds (k in ( Seg ( len l ) ) implies P[ k,( s . k ) ])) from FINSEQ_1:sch 1(A1);
( rng s ) c= ( QC-variables )
proof
let y being set;
assume y in ( rng s );
then consider x being set such that A4: x in ( dom s ) and A5: ( s . x ) = y by FUNCT_1:def 3;
reconsider x as (Element of ( NAT )) by A4;
A6:now
per cases ;
case ( l . x ) in ( dom f );
hence (( s . x ) = ( f . ( l . x ) ) & ( f . ( l . x ) ) in ( QC-variables )) by A2,A3,A4,PARTFUN1:4;
end;
case (not ( l . x ) in ( dom f ));
hence ( s . x ) = ( l . x ) by A2,A3,A4;
end;
end;
( dom l ) = ( Seg ( len l ) ) by FINSEQ_1:def 3;
hence thesis by A2,A4,A5,A6,FINSEQ_2:11;
end;
then reconsider s as (FinSequence of ( QC-variables )) by FINSEQ_1:def 4;
take s;
thus ( len s ) = ( len l ) by A2,FINSEQ_1:def 3;
let k;
assume (1 <= k & k <= ( len l ));
then k in ( dom l ) by FINSEQ_3:25;
then k in ( Seg ( len l ) ) by FINSEQ_1:def 3;
hence thesis by A3;
end;
uniqueness
proof
let l1;
let l2;
assume that
A7: ( len l1 ) = ( len l )
and
A8: (for k holds ((1 <= k & k <= ( len l )) implies ((( l . k ) in ( dom f ) implies ( l1 . k ) = ( f . ( l . k ) )) & ((not ( l . k ) in ( dom f )) implies ( l1 . k ) = ( l . k )))))
and
A9: ( len l2 ) = ( len l )
and
A10: (for k holds ((1 <= k & k <= ( len l )) implies ((( l . k ) in ( dom f ) implies ( l2 . k ) = ( f . ( l . k ) )) & ((not ( l . k ) in ( dom f )) implies ( l2 . k ) = ( l . k )))));
now
let k being Nat;
assume A11: (1 <= k & k <= ( len l ));
A12: k in ( NAT ) by ORDINAL1:def 12;
then A13: ((not ( l . k ) in ( dom f )) implies ( l1 . k ) = ( l . k )) by A8,A11;
(( l . k ) in ( dom f ) implies ( l1 . k ) = ( f . ( l . k ) )) by A8,A12,A11;
hence ( l1 . k ) = ( l2 . k ) by A10,A12,A11,A13;
end;
hence thesis by A7,A9,FINSEQ_1:14;
end;
end;
