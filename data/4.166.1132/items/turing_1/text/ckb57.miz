environ
vocabularies NUMBERS,SUBSET_1,XBOOLE_0,FUNCT_1,PARTFUN1,FUNCT_4,RELAT_1,TARSKI,FUNCOP_1,ORDINAL1,XXREAL_0,FINSET_1,CARD_1,FINSEQ_1,NAT_1,CARD_3,ARYTM_3,QMAX_1,FSM_1,ZFMISC_1,ARYTM_1,FUNCT_2,LANG1,INT_1,MCART_1,CIRCUIT2,MSUALG_1,ORDINAL4,VALUED_2,FINSEQ_2,UNIALG_1,PRALG_3,TURING_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,NUMBERS,XCMPLX_0,INT_1,FINSET_1,MCART_1,DOMAIN_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,FUNCOP_1,GR_CY_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,UNIALG_1,COMPUT_1,XXREAL_0,REAL_1,NAT_1,MARGREL1,CKB1,CKB2,CKB3,CKB4,CKB9,CKB10,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB33,CKB34,CKB36,CKB37,CKB39,CKB40,CKB50;
definitions FINSEQ_1,GR_CY_1,COMPUT_1,FUNCOP_1,MARGREL1,CKB4,CKB17,CKB21,CKB22,CKB23,CKB24,CKB25,CKB33,CKB34,CKB36,CKB37,CKB39,CKB40,CKB50;
theorems FUNCOP_1,FUNCT_4,ZFMISC_1,TARSKI,FUNCT_2,INT_1,MCART_1,NAT_1,RELSET_1,PARTFUN1,DOMAIN_1,CQC_THE1,ENUMSET1,FINSEQ_2,FINSEQ_1,FINSEQ_3,FUNCT_1,RELAT_1,FINSEQ_6,FINSEQ_7,COMPUT_1,FINSEQ_4,ORDINAL1,XBOOLE_0,XBOOLE_1,NUMBERS,XREAL_1,FUNCT_7,FINSOP_1,XXREAL_0,RVSUM_1,CKB4,CKB6,CKB7,CKB8,CKB11,CKB12,CKB17,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56;
schemes NAT_1,FUNCT_2,BINOP_2;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,ORDINAL1,RELSET_1,FUNCOP_1,FINSET_1,NUMBERS,XREAL_0,INT_1,COMPUT_1,MARGREL1,FINSEQ_1,CKB5,CKB13;
constructors DOMAIN_1,REAL_1,BINOP_2,FINSEQ_4,FINSOP_1,GR_CY_1,COMPUT_1,RECDEF_1,RELSET_1,UNIALG_1,MARGREL1,CKB1,CKB2,CKB4,CKB10,CKB13,CKB17,CKB21,CKB22,CKB23,CKB24,CKB25,CKB33,CKB34,CKB36,CKB37,CKB39,CKB40,CKB50;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve k for (Element of ( NAT ));
theorem
Lm4: (for tm being TuringStr holds (for s being (All-State of tm) holds (for p being (State of tm) holds (for h being (Element of ( INT )) holds (for t being (Tape of tm) holds (for m,d being (Element of ( NAT )) holds ((((((d = h & 1 is (Symbol of tm)) & s = [ p,h,t ]) & ( (the Tran of tm) . [ p,1 ] ) = [ p,1,1 ]) & p <> (the AcceptS of tm)) & (for i being Integer holds ((d <= i & i < ( d + m )) implies ( t . i ) = 1))) implies ( ( Computation s ) . m ) = [ p,( d + m ),t ])))))))
proof
let tm being TuringStr;
let s being (All-State of tm);
let p being (State of tm);
let h being (Element of ( INT ));
let t being (Tape of tm);
let m being (Element of ( NAT )),d being (Element of ( NAT ));
assume that
A1: d = h
and
A2: 1 is (Symbol of tm)
and
A3: s = [ p,h,t ]
and
A4: ( (the Tran of tm) . [ p,1 ] ) = [ p,1,1 ]
and
A5: p <> (the AcceptS of tm)
and
A6: (for i being Integer holds ((d <= i & i < ( d + m )) implies ( t . i ) = 1));
defpred Q[ (Element of ( NAT )) ]
 means
($1 <= m implies ( ( Computation s ) . $1 ) = [ p,( d + $1 ),t ]);
A7: (for k being (Element of ( NAT )) holds (Q[ k ] implies Q[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume A8: Q[ k ];
now
reconsider T = 1 as (Symbol of tm) by A2;
set dk = ( d + k );
reconsider ik = ( d + k ) as (Element of ( INT )) by INT_1:def 2;
set sk = [ p,ik,t ];
reconsider tt = ( sk `3 ) as (Tape of tm);
assume A9: ( k + 1 ) <= m;
then k < m by NAT_1:13;
then dk < ( d + m ) by XREAL_1:8;
then A10: ( t . ik ) = 1 by A6,NAT_1:11;
A11: ( TRAN sk ) = ( (the Tran of tm) . [ p,( tt . ( Head sk ) ) ] ) by MCART_1:64
.= ( (the Tran of tm) . [ p,( t . ( Head sk ) ) ] ) by MCART_1:64
.= [ p,1,1 ] by A4,A10,MCART_1:64;
then A12: ( offset ( TRAN sk ) ) = 1 by MCART_1:64;
A13: ( Tape-Chg (( sk `3 ),( Head sk ),( ( TRAN sk ) `2 )) ) = ( Tape-Chg (t,( Head sk ),( ( TRAN sk ) `2 )) ) by MCART_1:64
.= ( Tape-Chg (t,dk,( ( TRAN sk ) `2 )) ) by MCART_1:64
.= ( Tape-Chg (t,dk,T) ) by A11,MCART_1:64
.= t by A10,CKB52:1;
thus ( ( Computation s ) . ( k + 1 ) ) = ( Following sk ) by A8,A9,CKB25:def 1,NAT_1:13
.= [ ( ( TRAN sk ) `1 ),( ( Head sk ) + ( offset ( TRAN sk ) ) ),t ] by A5,A13,CKB54:1
.= [ p,( ( Head sk ) + ( offset ( TRAN sk ) ) ),t ] by A11,MCART_1:64
.= [ p,( dk + 1 ),t ] by A12,MCART_1:64
.= [ p,( d + ( k + 1 ) ),t ];
end;
hence thesis;
end;
A14: Q[ ( 0 ) ] by A1,A3,CKB25:def 1;
(for k holds Q[ k ]) from NAT_1:sch 1(A14,A7);
hence thesis;
end;
