environ
vocabularies NUMBERS,SUBSET_1,XBOOLE_0,FUNCT_1,PARTFUN1,FUNCT_4,RELAT_1,TARSKI,FUNCOP_1,ORDINAL1,XXREAL_0,FINSET_1,CARD_1,FINSEQ_1,NAT_1,CARD_3,ARYTM_3,QMAX_1,FSM_1,ZFMISC_1,ARYTM_1,FUNCT_2,LANG1,INT_1,MCART_1,CIRCUIT2,MSUALG_1,ORDINAL4,VALUED_2,FINSEQ_2,UNIALG_1,PRALG_3,TURING_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,NUMBERS,XCMPLX_0,INT_1,FINSET_1,MCART_1,DOMAIN_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,FUNCOP_1,GR_CY_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,UNIALG_1,COMPUT_1,XXREAL_0,REAL_1,NAT_1,MARGREL1,CKB1,CKB2,CKB3,CKB4,CKB9,CKB10,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB33,CKB34,CKB36,CKB37,CKB39,CKB40,CKB50,CKB59,CKB62,CKB64,CKB70,CKB72,CKB78,CKB80,CKB87,CKB92,CKB93,CKB94,CKB95,CKB96,CKB97,CKB98,CKB99,CKB100,CKB101,CKB102;
definitions FINSEQ_1,GR_CY_1,COMPUT_1,FUNCOP_1,MARGREL1,CKB4,CKB17,CKB21,CKB22,CKB23,CKB24,CKB25,CKB33,CKB34,CKB36,CKB37,CKB39,CKB40,CKB50,CKB59,CKB62,CKB64,CKB70,CKB72,CKB78,CKB80,CKB87,CKB92,CKB93,CKB96,CKB97,CKB98,CKB99,CKB100,CKB101,CKB102;
theorems FUNCOP_1,FUNCT_4,ZFMISC_1,TARSKI,FUNCT_2,INT_1,MCART_1,NAT_1,RELSET_1,PARTFUN1,DOMAIN_1,CQC_THE1,ENUMSET1,FINSEQ_2,FINSEQ_1,FINSEQ_3,FUNCT_1,RELAT_1,FINSEQ_6,FINSEQ_7,COMPUT_1,FINSEQ_4,ORDINAL1,XBOOLE_0,XBOOLE_1,NUMBERS,XREAL_1,FUNCT_7,FINSOP_1,XXREAL_0,RVSUM_1,CKB4,CKB6,CKB7,CKB8,CKB11,CKB12,CKB17,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56,CKB57,CKB58,CKB59,CKB60,CKB61,CKB62,CKB63,CKB64,CKB65,CKB66,CKB67,CKB68,CKB69,CKB70,CKB71,CKB72,CKB73,CKB74,CKB75,CKB76,CKB77,CKB78,CKB79,CKB80,CKB81,CKB82,CKB83,CKB84,CKB85,CKB86,CKB87,CKB88,CKB89,CKB90,CKB91,CKB92,CKB93,CKB96,CKB97,CKB98,CKB99,CKB100,CKB101,CKB102,CKB103,CKB104;
schemes NAT_1,FUNCT_2,BINOP_2;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,ORDINAL1,RELSET_1,FUNCOP_1,FINSET_1,NUMBERS,XREAL_0,INT_1,COMPUT_1,MARGREL1,FINSEQ_1,CKB5,CKB13;
constructors DOMAIN_1,REAL_1,BINOP_2,FINSEQ_4,FINSOP_1,GR_CY_1,COMPUT_1,RECDEF_1,RELSET_1,UNIALG_1,MARGREL1,CKB1,CKB2,CKB4,CKB10,CKB13,CKB17,CKB21,CKB22,CKB23,CKB24,CKB25,CKB33,CKB34,CKB36,CKB37,CKB39,CKB40,CKB50,CKB59,CKB62,CKB64,CKB70,CKB72,CKB78,CKB80,CKB87,CKB92,CKB93,CKB94,CKB95,CKB96,CKB97,CKB98,CKB99,CKB100,CKB101,CKB102;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve i for (Element of ( NAT ));
reserve k for (Element of ( NAT ));
theorem
Th50: (for T1,T2 being TuringStr holds (for s1 being (All-State of T1) holds (for h being (Element of ( NAT )) holds (for t being (Tape of T1) holds (for s2 being (All-State of T2) holds (for s3 being (All-State of ( T1 ';' T2 )) holds (((((s1 is  Accept-Halt & s1 = [ (the InitS of T1),h,t ]) & s2 is  Accept-Halt) & s2 = [ (the InitS of T2),( ( Result s1 ) `2 ),( ( Result s1 ) `3 ) ]) & s3 = [ (the InitS of ( T1 ';' T2 )),h,t ]) implies ((s3 is  Accept-Halt & ( ( Result s3 ) `2 ) = ( ( Result s2 ) `2 )) & ( ( Result s3 ) `3 ) = ( ( Result s2 ) `3 )))))))))
proof
let tm1 being TuringStr,tm2 being TuringStr;
let s1 being (All-State of tm1);
let h being (Element of ( NAT ));
let t being (Tape of tm1);
let s2 being (All-State of tm2);
let s3 being (All-State of ( tm1 ';' tm2 ));
set p0 = (the InitS of tm1);
set q0 = (the InitS of tm2);
assume that
A1: s1 is  Accept-Halt
and
A2: s1 = [ p0,h,t ]
and
A3: s2 is  Accept-Halt
and
A4: s2 = [ q0,( ( Result s1 ) `2 ),( ( Result s1 ) `3 ) ]
and
A5: s3 = [ (the InitS of ( tm1 ';' tm2 )),h,t ];
set pF = (the AcceptS of tm1);
set qF = (the AcceptS of tm2);
consider k such that A6: ( ( ( Computation s1 ) . k ) `1 ) = pF and A7: ( Result s1 ) = ( ( Computation s1 ) . k ) and A8: (for i being (Element of ( NAT )) holds (i < k implies ( ( ( Computation s1 ) . i ) `1 ) <> pF)) by A1,CKB35:1;
defpred P[ (Element of ( NAT )) ]
 means
($1 <= k implies (([ ( ( ( Computation s1 ) . $1 ) `1 ),q0 ] = ( ( ( Computation s3 ) . $1 ) `1 ) & ( ( ( Computation s1 ) . $1 ) `2 ) = ( ( ( Computation s3 ) . $1 ) `2 )) & ( ( ( Computation s1 ) . $1 ) `3 ) = ( ( ( Computation s3 ) . $1 ) `3 )));
A9: (for i holds (P[ i ] implies P[ ( i + 1 ) ]))
proof
let i;
assume A10: P[ i ];
now
set s1i1 = ( ( Computation s1 ) . ( i + 1 ) );
set s1i = ( ( Computation s1 ) . i );
set s3i1 = ( ( Computation s3 ) . ( i + 1 ) );
set s3i = ( ( Computation s3 ) . i );
A11: i < ( i + 1 ) by XREAL_1:29;
set f = ( TRAN s3i );
reconsider h = ( Head s1i ) as (Element of ( INT ));
reconsider ss1 = ( s1i `3 ) as (Tape of tm1);
reconsider y = ( ss1 . h ) as (Symbol of tm1);
reconsider ss3 = ( s3i `3 ) as (Tape of ( tm1 ';' tm2 ));
set p = ( s1i `1 );
set g = ( TRAN s1i );
assume A12: ( i + 1 ) <= k;
then A13: i < k by A11,XXREAL_0:2;
then A14: p <> pF by A8;
A15: ( s3i `1 ) <> (the AcceptS of ( tm1 ';' tm2 ))
proof
assume ( s3i `1 ) = (the AcceptS of ( tm1 ';' tm2 ));
then [ p,q0 ] = [ pF,qF ] by A10,A12,A11,CKB102:def 1,XXREAL_0:2;
hence contradiction by A14,ZFMISC_1:27;
end;
A16: f = ( (the Tran of ( tm1 ';' tm2 )) . [ [ p,q0 ],y ] ) by A10,A12,A11,XXREAL_0:2
.= [ [ ( g `1 ),q0 ],( g `2 ),( g `3 ) ] by A8,A13,CKB103:1;
then A17: ( g `2 ) = ( f `2 ) by MCART_1:def 6;
A18: s3i1 = ( Following s3i ) by CKB25:def 1
.= [ ( f `1 ),( ( Head s3i ) + ( offset f ) ),( Tape-Chg (ss3,( Head s3i ),( f `2 )) ) ] by A15,CKB24:def 1;
A19: s1i1 = ( Following s1i ) by CKB25:def 1
.= [ ( g `1 ),( h + ( offset g ) ),( Tape-Chg (ss1,h,( g `2 )) ) ] by A14,CKB24:def 1;
hence [ ( s1i1 `1 ),q0 ] = [ ( g `1 ),q0 ] by MCART_1:def 5
.= ( f `1 ) by A16,MCART_1:def 5
.= ( s3i1 `1 ) by A18,MCART_1:def 5;
( offset g ) = ( offset f ) by A16,MCART_1:def 7;
hence ( s1i1 `2 ) = ( ( Head s3i ) + ( offset f ) ) by A10,A12,A11,A19,MCART_1:def 6,XXREAL_0:2
.= ( s3i1 `2 ) by A18,MCART_1:def 6;
thus ( s1i1 `3 ) = ( ss3 +* ( h .--> ( g `2 ) ) ) by A10,A12,A11,A19,MCART_1:def 7,XXREAL_0:2
.= ( s3i1 `3 ) by A10,A12,A11,A17,A18,MCART_1:def 7,XXREAL_0:2;
end;
hence thesis;
end;
set s1k = ( ( Computation s1 ) . k );
set s3k = ( ( Computation s3 ) . k );
A20: s3 = [ [ p0,q0 ],h,t ] by A5,CKB102:def 1;
A21: P[ ( 0 ) ]
proof
assume ( 0 ) <= k;
A22: ( ( ( Computation s3 ) . ( 0 ) ) `1 ) = ( s3 `1 ) by CKB25:def 1
.= [ p0,q0 ] by A20,MCART_1:64;
( ( ( Computation s1 ) . ( 0 ) ) `1 ) = ( s1 `1 ) by CKB25:def 1
.= p0 by A2,MCART_1:64;
hence [ ( ( ( Computation s1 ) . ( 0 ) ) `1 ),q0 ] = ( ( ( Computation s3 ) . ( 0 ) ) `1 ) by A22;
thus ( ( ( Computation s1 ) . ( 0 ) ) `2 ) = ( s1 `2 ) by CKB25:def 1
.= h by A2,MCART_1:64
.= ( s3 `2 ) by A5,MCART_1:64
.= ( ( ( Computation s3 ) . ( 0 ) ) `2 ) by CKB25:def 1;
thus ( ( ( Computation s1 ) . ( 0 ) ) `3 ) = ( s1 `3 ) by CKB25:def 1
.= t by A2,MCART_1:64
.= ( s3 `3 ) by A5,MCART_1:64
.= ( ( ( Computation s3 ) . ( 0 ) ) `3 ) by CKB25:def 1;
end;
A23: (for i holds P[ i ]) from NAT_1:sch 1(A21,A9);
then A24: ( s1k `2 ) = ( s3k `2 );
consider m being (Element of ( NAT )) such that A25: ( ( ( Computation s2 ) . m ) `1 ) = qF and A26: ( Result s2 ) = ( ( Computation s2 ) . m ) and A27: (for i being (Element of ( NAT )) holds (i < m implies ( ( ( Computation s2 ) . i ) `1 ) <> qF)) by A3,CKB35:1;
defpred Q[ (Element of ( NAT )) ]
 means
($1 <= m implies (([ pF,( ( ( Computation s2 ) . $1 ) `1 ) ] = ( ( ( Computation s3k ) . $1 ) `1 ) & ( ( ( Computation s2 ) . $1 ) `2 ) = ( ( ( Computation s3k ) . $1 ) `2 )) & ( ( ( Computation s2 ) . $1 ) `3 ) = ( ( ( Computation s3k ) . $1 ) `3 )));
A28: (for i holds (Q[ i ] implies Q[ ( i + 1 ) ]))
proof
let i;
assume A29: Q[ i ];
now
set s2i1 = ( ( Computation s2 ) . ( i + 1 ) );
set s2i = ( ( Computation s2 ) . i );
set ski1 = ( ( Computation s3k ) . ( i + 1 ) );
set ski = ( ( Computation s3k ) . i );
A30: i < ( i + 1 ) by XREAL_1:29;
reconsider ssk = ( ski `3 ) as (Tape of ( tm1 ';' tm2 ));
set f = ( TRAN ski );
set q = ( s2i `1 );
set g = ( TRAN s2i );
reconsider h = ( Head s2i ) as (Element of ( INT ));
reconsider ss2 = ( s2i `3 ) as (Tape of tm2);
reconsider y = ( ss2 . h ) as (Symbol of tm2);
assume A31: ( i + 1 ) <= m;
then A32: f = ( (the Tran of ( tm1 ';' tm2 )) . [ [ pF,q ],y ] ) by A29,A30,XXREAL_0:2
.= [ [ pF,( g `1 ) ],( g `2 ),( g `3 ) ] by CKB104:1;
then A33: ( g `2 ) = ( f `2 ) by MCART_1:def 6;
i < m by A31,A30,XXREAL_0:2;
then A34: q <> qF by A27;
A35: ( ski `1 ) <> (the AcceptS of ( tm1 ';' tm2 ))
proof
assume ( ski `1 ) = (the AcceptS of ( tm1 ';' tm2 ));
then [ pF,q ] = [ pF,qF ] by A29,A31,A30,CKB102:def 1,XXREAL_0:2;
hence contradiction by A34,ZFMISC_1:27;
end;
A36: ski1 = ( Following ski ) by CKB25:def 1
.= [ ( f `1 ),( ( Head ski ) + ( offset f ) ),( Tape-Chg (ssk,( Head ski ),( f `2 )) ) ] by A35,CKB24:def 1;
A37: s2i1 = ( Following s2i ) by CKB25:def 1
.= [ ( g `1 ),( h + ( offset g ) ),( Tape-Chg (ss2,h,( g `2 )) ) ] by A34,CKB24:def 1;
hence [ pF,( s2i1 `1 ) ] = [ pF,( g `1 ) ] by MCART_1:def 5
.= ( f `1 ) by A32,MCART_1:def 5
.= ( ski1 `1 ) by A36,MCART_1:def 5;
( offset g ) = ( offset f ) by A32,MCART_1:def 7;
hence ( s2i1 `2 ) = ( ( Head ski ) + ( offset f ) ) by A29,A31,A30,A37,MCART_1:def 6,XXREAL_0:2
.= ( ski1 `2 ) by A36,MCART_1:def 6;
thus ( s2i1 `3 ) = ( ssk +* ( h .--> ( g `2 ) ) ) by A29,A31,A30,A37,MCART_1:def 7,XXREAL_0:2
.= ( ski1 `3 ) by A29,A31,A30,A33,A36,MCART_1:def 7,XXREAL_0:2;
end;
hence thesis;
end;
A38: ( s1k `3 ) = ( s3k `3 ) by A23;
set s2m = ( ( Computation s2 ) . m );
set skm = ( ( Computation s3k ) . m );
A39: ( ( Computation s3 ) . ( k + m ) ) = skm by CKB30:1;
A40: [ ( s1k `1 ),q0 ] = ( s3k `1 ) by A23;
A41: Q[ ( 0 ) ]
proof
assume ( 0 ) <= m;
thus [ pF,( ( ( Computation s2 ) . ( 0 ) ) `1 ) ] = [ pF,( s2 `1 ) ] by CKB25:def 1
.= [ pF,q0 ] by A4,MCART_1:64
.= ( ( ( Computation s3k ) . ( 0 ) ) `1 ) by A6,A40,CKB25:def 1;
thus ( ( ( Computation s2 ) . ( 0 ) ) `2 ) = ( s2 `2 ) by CKB25:def 1
.= ( s3k `2 ) by A4,A7,A24,MCART_1:64
.= ( ( ( Computation s3k ) . ( 0 ) ) `2 ) by CKB25:def 1;
thus ( ( ( Computation s2 ) . ( 0 ) ) `3 ) = ( s2 `3 ) by CKB25:def 1
.= ( s3k `3 ) by A4,A7,A38,MCART_1:64
.= ( ( ( Computation s3k ) . ( 0 ) ) `3 ) by CKB25:def 1;
end;
A42: (for i holds Q[ i ]) from NAT_1:sch 1(A41,A28);
then [ pF,( s2m `1 ) ] = ( skm `1 );
then A43: ( ( ( Computation s3 ) . ( k + m ) ) `1 ) = (the AcceptS of ( tm1 ';' tm2 )) by A25,A39,CKB102:def 1;
hence A44: s3 is  Accept-Halt by CKB33:def 1;
(( s2m `2 ) = ( skm `2 ) & ( s2m `3 ) = ( skm `3 )) by A42;
hence thesis by A26,A39,A43,A44,CKB34:def 1;
end;
