environ
vocabularies NUMBERS,SUBSET_1,XBOOLE_0,FUNCT_1,PARTFUN1,FUNCT_4,RELAT_1,TARSKI,FUNCOP_1,ORDINAL1,XXREAL_0,FINSET_1,CARD_1,FINSEQ_1,NAT_1,CARD_3,ARYTM_3,QMAX_1,FSM_1,ZFMISC_1,ARYTM_1,FUNCT_2,LANG1,INT_1,MCART_1,CIRCUIT2,MSUALG_1,ORDINAL4,VALUED_2,FINSEQ_2,UNIALG_1,PRALG_3,TURING_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,NUMBERS,XCMPLX_0,INT_1,FINSET_1,MCART_1,DOMAIN_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_4,FUNCOP_1,GR_CY_1,FINSEQ_1,FINSEQ_2,FINSEQ_4,UNIALG_1,COMPUT_1,XXREAL_0,REAL_1,NAT_1,MARGREL1,CKB1,CKB2,CKB3,CKB4,CKB9,CKB10,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB33,CKB34,CKB36,CKB37,CKB39,CKB40,CKB50,CKB59,CKB62,CKB64,CKB70,CKB72,CKB78,CKB80;
definitions FINSEQ_1,GR_CY_1,COMPUT_1,FUNCOP_1,MARGREL1,CKB4,CKB17,CKB21,CKB22,CKB23,CKB24,CKB25,CKB33,CKB34,CKB36,CKB37,CKB39,CKB40,CKB50,CKB59,CKB62,CKB64,CKB70,CKB72,CKB78,CKB80;
theorems FUNCOP_1,FUNCT_4,ZFMISC_1,TARSKI,FUNCT_2,INT_1,MCART_1,NAT_1,RELSET_1,PARTFUN1,DOMAIN_1,CQC_THE1,ENUMSET1,FINSEQ_2,FINSEQ_1,FINSEQ_3,FUNCT_1,RELAT_1,FINSEQ_6,FINSEQ_7,COMPUT_1,FINSEQ_4,ORDINAL1,XBOOLE_0,XBOOLE_1,NUMBERS,XREAL_1,FUNCT_7,FINSOP_1,XXREAL_0,RVSUM_1,CKB4,CKB6,CKB7,CKB8,CKB11,CKB12,CKB17,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56,CKB57,CKB58,CKB59,CKB60,CKB61,CKB62,CKB63,CKB64,CKB65,CKB66,CKB67,CKB68,CKB69,CKB70,CKB71,CKB72,CKB73,CKB74,CKB75,CKB76,CKB77,CKB78,CKB79,CKB80,CKB81,CKB82,CKB83;
schemes NAT_1,FUNCT_2,BINOP_2;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,ORDINAL1,RELSET_1,FUNCOP_1,FINSET_1,NUMBERS,XREAL_0,INT_1,COMPUT_1,MARGREL1,FINSEQ_1,CKB5,CKB13;
constructors DOMAIN_1,REAL_1,BINOP_2,FINSEQ_4,FINSOP_1,GR_CY_1,COMPUT_1,RECDEF_1,RELSET_1,UNIALG_1,MARGREL1,CKB1,CKB2,CKB4,CKB10,CKB13,CKB17,CKB21,CKB22,CKB23,CKB24,CKB25,CKB33,CKB34,CKB36,CKB37,CKB39,CKB40,CKB50,CKB59,CKB62,CKB64,CKB70,CKB72,CKB78,CKB80;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve k for (Element of ( NAT ));
theorem
Lm14: (for tm being TuringStr holds (for s being (All-State of tm) holds (for p being (State of tm) holds (for h being (Element of ( INT )) holds (for t being (Tape of tm) holds (for m,d being (Element of ( NAT )) holds ((((((d = h & ( 0 ) is (Symbol of tm)) & s = [ p,h,t ]) & ( (the Tran of tm) . [ p,1 ] ) = [ p,( 0 ),1 ]) & p <> (the AcceptS of tm)) & (for i being Integer holds ((d <= i & i < ( d + m )) implies ( t . i ) = 1))) implies (ex t1 being (Tape of tm) st ((( ( Computation s ) . m ) = [ p,( d + m ),t1 ] & (for i being Integer holds ((d <= i & i < ( d + m )) implies ( t1 . i ) = ( 0 )))) & (for i being Integer holds ((d > i or i >= ( d + m )) implies ( t1 . i ) = ( t . i ))))))))))))
proof
let tm being TuringStr;
let s being (All-State of tm);
let p being (State of tm);
let h being (Element of ( INT ));
let t being (Tape of tm);
let m being (Element of ( NAT )),d being (Element of ( NAT ));
assume that
A1: d = h
and
A2: ( 0 ) is (Symbol of tm)
and
A3: s = [ p,h,t ]
and
A4: ( (the Tran of tm) . [ p,1 ] ) = [ p,( 0 ),1 ]
and
A5: p <> (the AcceptS of tm)
and
A6: (for i being Integer holds ((d <= i & i < ( d + m )) implies ( t . i ) = 1));
defpred Q[ (Element of ( NAT )) ]
 means
($1 <= m implies (ex t1 being (Tape of tm) st ((( ( Computation s ) . $1 ) = [ p,( d + $1 ),t1 ] & (for i being Integer holds ((d <= i & i < ( d + $1 )) implies ( t1 . i ) = ( 0 )))) & (for i being Integer holds ((d > i or i >= ( d + $1 )) implies ( t1 . i ) = ( t . i ))))));
A7: (for k being (Element of ( NAT )) holds (Q[ k ] implies Q[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume A8: Q[ k ];
now
reconsider F = ( 0 ) as (Symbol of tm) by A2;
set dk = ( d + k );
reconsider ik = ( d + k ) as (Element of ( INT )) by INT_1:def 2;
assume A9: ( k + 1 ) <= m;
then consider t1 being (Tape of tm) such that A10: ( ( Computation s ) . k ) = [ p,( d + k ),t1 ] and A11: (for i being Integer holds ((d <= i & i < ( d + k )) implies ( t1 . i ) = ( 0 ))) and A12: (for i being Integer holds ((d > i or i >= ( d + k )) implies ( t1 . i ) = ( t . i ))) by A8,NAT_1:13;
k < m by A9,NAT_1:13;
then A13: dk < ( d + m ) by XREAL_1:8;
A14: ( t1 . ik ) = ( t . ik ) by A12
.= 1 by A6,A13,NAT_1:11;
take t2 = ( Tape-Chg (t1,dk,F) );
set sk = [ p,ik,t1 ];
reconsider tt = ( sk `3 ) as (Tape of tm);
A15: ( TRAN sk ) = ( (the Tran of tm) . [ p,( tt . ( Head sk ) ) ] ) by MCART_1:64
.= ( (the Tran of tm) . [ p,( t1 . ( Head sk ) ) ] ) by MCART_1:64
.= [ p,( 0 ),1 ] by A4,A14,MCART_1:64;
then A16: ( offset ( TRAN sk ) ) = 1 by MCART_1:64;
A17: ( Tape-Chg (( sk `3 ),( Head sk ),( ( TRAN sk ) `2 )) ) = ( Tape-Chg (t1,( Head sk ),( ( TRAN sk ) `2 )) ) by MCART_1:64
.= ( Tape-Chg (t1,dk,( ( TRAN sk ) `2 )) ) by MCART_1:64
.= t2 by A15,MCART_1:64;
thus ( ( Computation s ) . ( k + 1 ) ) = ( Following sk ) by A10,CKB25:def 1
.= [ ( ( TRAN sk ) `1 ),( ( Head sk ) + ( offset ( TRAN sk ) ) ),t2 ] by A5,A17,CKB54:1
.= [ p,( ( Head sk ) + ( offset ( TRAN sk ) ) ),t2 ] by A15,MCART_1:64
.= [ p,( dk + 1 ),t2 ] by A16,MCART_1:64
.= [ p,( d + ( k + 1 ) ),t2 ];
hereby
let i being Integer;
assume that
A18: d <= i
and
A19: i < ( d + ( k + 1 ) );
per cases ;
suppose i = dk;

hence ( t2 . i ) = ( 0 ) by CKB56:1;
end;
suppose A20: i <> dk;

i < ( ( d + k ) + 1 ) by A19;
then i <= ( d + k ) by INT_1:7;
then A21: i < dk by A20,XXREAL_0:1;
thus ( t2 . i ) = ( t1 . i ) by A20,CKB56:1
.= ( 0 ) by A11,A18,A21;
end;
end;
hereby
let i being Integer;
assume A22: (d > i or i >= ( d + ( k + 1 ) ));
per cases  by A22;
suppose A23: d > i;

d <= ( d + k ) by NAT_1:12;
hence ( t2 . i ) = ( t1 . i ) by A23,CKB56:1
.= ( t . i ) by A12,A23;
end;
suppose A24: i >= ( d + ( k + 1 ) );

k < ( k + 1 ) by NAT_1:13;
then A25: ( d + k ) < ( d + ( k + 1 ) ) by XREAL_1:8;
then A26: i > ( d + k ) by A24,XXREAL_0:2;
thus ( t2 . i ) = ( t1 . i ) by A24,A25,CKB56:1
.= ( t . i ) by A12,A26;
end;
end;
end;
hence thesis;
end;
A27: Q[ ( 0 ) ]
proof
assume ( 0 ) <= m;
take t1 = t;
thus ( ( Computation s ) . ( 0 ) ) = [ p,( d + ( 0 ) ),t1 ] by A1,A3,CKB25:def 1;
thus (for i being Integer holds ((d <= i & i < ( d + ( 0 ) )) implies ( t1 . i ) = ( 0 )));
thus thesis;
end;
(for k holds Q[ k ]) from NAT_1:sch 1(A27,A7);
hence thesis;
end;
