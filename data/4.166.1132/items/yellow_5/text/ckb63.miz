environ
vocabularies RELAT_2,LATTICE3,ORDERS_2,SUBSET_1,EQREL_1,XXREAL_0,LATTICES,XBOOLE_0,WAYBEL_0,XBOOLEAN;
notations STRUCT_0,LATTICE3,WAYBEL_0,WAYBEL_1,YELLOW_0,ORDERS_2,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18;
definitions CKB12,CKB13,CKB15;
theorems LATTICE3,YELLOW_0,WAYBEL_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB15,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56,CKB57,CKB58,CKB59,CKB60,CKB61,CKB62;
registrations LATTICE3,YELLOW_0,WAYBEL_1;
constructors LATTICE3,WAYBEL_1,CKB12,CKB13,CKB14,CKB15,CKB18;
begin
reserve L for  Boolean non  empty RelStr;
reserve a for (Element of L);
reserve b for (Element of L);
theorem
(( a "/\" b ) = ( Bottom L ) iff ( a \ b ) = a)
proof
thus (( a "/\" b ) = ( Bottom L ) implies ( a \ b ) = a)
proof
assume ( a "/\" b ) = ( Bottom L );
then a <= ( 'not' b ) by WAYBEL_1:82;
then ( a "/\" a ) <= ( a "/\" ( 'not' b ) ) by CKB6:1;
then A1: a <= ( a "/\" ( 'not' b ) ) by CKB2:1;
( a \ b ) <= a by YELLOW_0:23;
hence thesis by A1,YELLOW_0:def 3;
end;

thus (( a \ b ) = a implies ( a "/\" b ) = ( Bottom L ))
proof
assume ( a \ b ) = a;
then ( ( 'not' a ) "\/" ( 'not' ( 'not' b ) ) ) = ( 'not' a ) by CKB43:1;
then ( a "/\" ( ( 'not' a ) "\/" b ) ) <= ( a "/\" ( 'not' a ) ) by WAYBEL_1:87;
then ( ( a "/\" ( 'not' a ) ) "\/" ( a "/\" b ) ) <= ( a "/\" ( 'not' a ) ) by WAYBEL_1:def 3;
then ( ( Bottom L ) "\/" ( a "/\" b ) ) <= ( a "/\" ( 'not' a ) ) by CKB41:1;
then ( ( Bottom L ) "\/" ( a "/\" b ) ) <= ( Bottom L ) by CKB41:1;
then A2: ( a "/\" b ) <= ( Bottom L ) by WAYBEL_1:3;
( Bottom L ) <= ( a "/\" b ) by YELLOW_0:44;
hence thesis by A2,YELLOW_0:def 3;
end;

end;
