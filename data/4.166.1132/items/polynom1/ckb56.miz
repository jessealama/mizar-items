environ
vocabularies NUMBERS,STRUCT_0,ZFMISC_1,RLVECT_1,ALGSTR_0,VECTSP_1,XBOOLE_0,SUPINF_2,MESFUNC1,SUBSET_1,RELAT_1,FINSEQ_1,ARYTM_3,PARTFUN1,TARSKI,CARD_3,NAT_1,ORDINAL4,FUNCT_1,FVSUM_1,ALGSTR_1,BINOP_1,LATTICES,PRE_POLY,ALGSEQ_1,FINSET_1,ARYTM_1,FUNCOP_1,GROUP_1,FUNCT_4,ORDINAL1,XXREAL_0,FINSEQ_2,MEMBER_1,FUNCT_2,CARD_1,POLYNOM1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,RELAT_1,FUNCT_1,PBOOLE,RELSET_1,FINSET_1,ORDINAL1,PARTFUN1,FUNCT_2,FINSEQ_1,STRUCT_0,ALGSTR_0,FUNCT_3,XXREAL_0,BINOP_1,NAT_1,ALGSTR_1,RLVECT_1,FINSEQ_2,GROUP_1,VECTSP_1,FUNCOP_1,FUNCT_7,MATRLIN,VFUNCT_1,FVSUM_1,PRE_POLY,RECDEF_1,CKB8,CKB9,CKB21,CKB22,CKB23,CKB24,CKB25,CKB32,CKB34,CKB35,CKB38,CKB41,CKB44,CKB49;
definitions TARSKI,XBOOLE_0,FUNCT_1,FUNCT_2,RLVECT_1,VECTSP_1,GROUP_1,FINSEQ_2,STRUCT_0,ALGSTR_0,FUNCOP_1,CKB8,CKB9,CKB21,CKB22,CKB25,CKB34,CKB35,CKB38,CKB41;
theorems FUNCT_1,FINSET_1,FINSEQ_3,FINSEQ_4,ZFMISC_1,FINSEQ_1,FUNCT_2,RLVECT_1,VECTSP_1,FUNCOP_1,TARSKI,FUNCT_7,BINOP_1,RELAT_1,MATRLIN,FINSEQ_2,ORDINAL1,FINSEQ_5,NAT_1,PBOOLE,SUBSET_1,FVSUM_1,FUNCT_3,GROUP_1,XBOOLE_0,XBOOLE_1,RLVECT_2,PARTFUN1,XREAL_1,XXREAL_0,PRE_POLY,VFUNCT_1,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB18,CKB19,CKB20,CKB21,CKB22,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB45,CKB46,CKB47;
schemes FRAENKEL,FUNCT_2,FINSEQ_2,FINSEQ_1,FINSEQ_4,SUBSET_1,BINOP_1;
registrations SUBSET_1,RELAT_1,FUNCT_1,FUNCOP_1,FINSET_1,XREAL_0,CARD_1,MEMBERED,FINSEQ_1,FINSEQ_2,STRUCT_0,VECTSP_1,ALGSTR_1,VALUED_0,PRE_POLY,RELSET_1,VFUNCT_1,FUNCT_2,CKB1,CKB2,CKB16,CKB17,CKB48,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55;
constructors BINOP_1,FINSEQOP,SETWISEO,FINSEQ_4,RFUNCT_3,FUNCT_7,ALGSTR_1,FVSUM_1,MATRLIN,RECDEF_1,RELSET_1,PBOOLE,VFUNCT_1,CKB9,CKB21,CKB22,CKB23,CKB25,CKB32,CKB34,CKB35,CKB38,CKB41,CKB44;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
definition
let n being Ordinal;
let L being  right_zeroed  add-associative  right_complementable  right_unital  distributive non trivial doubleLoopStr;
func Polynom-Ring (n,L) ->  strict non empty doubleLoopStr
means
:Def27: (((((for x being set holds (x in (the carrier of it) iff x is (Polynomial of n,L))) & (for x,y being (Element of it) holds (for p,q being (Polynomial of n,L) holds ((x = p & y = q) implies ( x + y ) = ( p + q ))))) & (for x,y being (Element of it) holds (for p,q being (Polynomial of n,L) holds ((x = p & y = q) implies ( x * y ) = ( p *' q ))))) & ( 0. it ) = ( 0_ (n,L) )) & ( 1. it ) = ( 1_ (n,L) ));
existence
proof
reconsider Z = ( ( Bags n ) --> ( 0. L ) ) as (Function of ( Bags n ),(the carrier of L));
defpred M[ set,set,set ]
 means
(ex p,q,r being (Polynomial of n,L) st (((p = $1 & q = $2) & r = $3) & ( p *' q ) = r));
defpred A[ set,set,set ]
 means
(ex p,q,r being (Polynomial of n,L) st (((p = $1 & q = $2) & r = $3) & ( p + q ) = r));
set x9 = the  finite-Support (Series of n,L);
defpred Q[ set ]
 means
(ex x9 being (Series of n,L) st (x9 = $1 & x9 is  finite-Support));
consider P being (Subset of ( Funcs (( Bags n ),(the carrier of L)) )) such that A1: (for x being (Element of ( Funcs (( Bags n ),(the carrier of L)) )) holds (x in P iff Q[ x ])) from SUBSET_1:sch 3;
x9 in ( Funcs (( Bags n ),(the carrier of L)) ) by FUNCT_2:8;
then reconsider P as non empty (Subset of ( Funcs (( Bags n ),(the carrier of L)) )) by A1;
A2:now
let x being (Element of P);
let y being (Element of P);
reconsider p = x,q = y as (Element of ( Funcs (( Bags n ),(the carrier of L)) ));
consider p9 being (Series of n,L) such that A3: p9 = p and A4: p9 is  finite-Support by A1;
consider q9 being (Series of n,L) such that A5: q9 = q and A6: q9 is  finite-Support by A1;
reconsider p9,q9 as (Polynomial of n,L) by A4,A6;
set r = ( p9 + q9 );
r in ( Funcs (( Bags n ),(the carrier of L)) ) by FUNCT_2:8;
then reconsider u = r as (Element of P) by A1;
take u;
thus A[ x,y,u ] by A3,A5;
end;
consider fadd being (Function of [: P,P :],P) such that A7: (for x being (Element of P) holds (for y being (Element of P) holds A[ x,y,( fadd . (x,y) ) ])) from BINOP_1:sch 3(A2);
A8:now
let x being (Element of P);
let y being (Element of P);
reconsider p = x,q = y as (Element of ( Funcs (( Bags n ),(the carrier of L)) ));
consider p9 being (Series of n,L) such that A9: p9 = p and A10: p9 is  finite-Support by A1;
consider q9 being (Series of n,L) such that A11: q9 = q and A12: q9 is  finite-Support by A1;
reconsider p9,q9 as (Polynomial of n,L) by A10,A12;
set r = ( p9 *' q9 );
r in ( Funcs (( Bags n ),(the carrier of L)) ) by FUNCT_2:8;
then reconsider u = r as (Element of P) by A1;
take u;
thus M[ x,y,u ] by A9,A11;
end;
consider fmult being (Function of [: P,P :],P) such that A13: (for x being (Element of P) holds (for y being (Element of P) holds M[ x,y,( fmult . (x,y) ) ])) from BINOP_1:sch 3(A8);
reconsider ZZ = Z as (Element of ( Funcs (( Bags n ),(the carrier of L)) )) by FUNCT_2:8;
reconsider Z9 = Z as (Function of ( Bags n ),L);
reconsider Z9 as (Series of n,L);
now
given x being set such that
A14: x in ( Support Z9 );

reconsider x as (Element of ( Bags n )) by A14;
( Z9 . x ) = ( 0. L ) by FUNCOP_1:7;
hence contradiction by A14,CKB21:def 1;
end;
then ( Support Z9 ) = ( {} ) by XBOOLE_0:def 1;
then Z9 is  finite-Support by CKB22:def 1;
then ZZ in P by A1;
then reconsider Ze = Z as (Element of P);
reconsider O = ( Z +* (( EmptyBag n ),( 1. L )) ) as (Function of ( Bags n ),(the carrier of L));
reconsider O9 = O as (Function of ( Bags n ),L);
reconsider O9 as (Series of n,L);
reconsider O as (Element of ( Funcs (( Bags n ),(the carrier of L)) )) by FUNCT_2:8;
now
let x being set;
hereby
assume A15: x in ( Support O9 );
then reconsider x9 = x as (Element of ( Bags n ));
assume x <> ( EmptyBag n );
then ( O9 . x ) = ( Z . x9 ) by FUNCT_7:32
.= ( 0. L ) by FUNCOP_1:7;
hence contradiction by A15,CKB21:def 1;
end;
assume A16: x = ( EmptyBag n );
( dom Z ) = ( Bags n ) by FUNCOP_1:13;
then ( O9 . x ) <> ( 0. L ) by A16,FUNCT_7:31;
hence x in ( Support O9 ) by A16,CKB21:def 1;
end;
then ( Support O9 ) = { ( EmptyBag n ) } by TARSKI:def 1;
then O9 is  finite-Support by CKB22:def 1;
then reconsider O as (Element of P) by A1;
reconsider R = doubleLoopStr (# P,fadd,fmult,O,Ze #) as  strict non empty doubleLoopStr;
take R;
thus (for x being set holds (x in (the carrier of R) iff x is (Polynomial of n,L)))
proof
let x being set;
hereby
assume A17: x in (the carrier of R);
then reconsider xx = x as (Element of ( Funcs (( Bags n ),(the carrier of L)) ));
(ex x9 being (Series of n,L) st (x9 = xx & x9 is  finite-Support)) by A1,A17;
hence x is (Polynomial of n,L);
end;
assume A18: x is (Polynomial of n,L);
then x is (Element of ( Funcs (( Bags n ),(the carrier of L)) )) by FUNCT_2:8;
hence thesis by A1,A18;
end;

hereby
let x being (Element of R),y being (Element of R);
let p being (Polynomial of n,L),q being (Polynomial of n,L);
assume that
A19: (x = p & y = q);
(ex p9,q9,r9 being (Polynomial of n,L) st (((p9 = x & q9 = y) & r9 = ( fadd . (x,y) )) & ( p9 + q9 ) = r9)) by A7;
hence ( x + y ) = ( p + q ) by A19;
end;
hereby
let x being (Element of R),y being (Element of R);
let p being (Polynomial of n,L),q being (Polynomial of n,L);
assume that
A20: (x = p & y = q);
(ex p9,q9,r9 being (Polynomial of n,L) st (((p9 = x & q9 = y) & r9 = ( fmult . (x,y) )) & ( p9 *' q9 ) = r9)) by A13;
hence ( x * y ) = ( p *' q ) by A20;
end;
thus ( 0. R ) = ( 0_ (n,L) );
thus thesis;
end;
uniqueness
proof
let it1 being  strict non empty doubleLoopStr,it2 being  strict non empty doubleLoopStr;
assume that
A21: (for x being set holds (x in (the carrier of it1) iff x is (Polynomial of n,L)))
and
A22: (for x,y being (Element of it1) holds (for p,q being (Polynomial of n,L) holds ((x = p & y = q) implies ( x + y ) = ( p + q ))))
and
A23: (for x,y being (Element of it1) holds (for p,q being (Polynomial of n,L) holds ((x = p & y = q) implies ( x * y ) = ( p *' q ))))
and
A24: (( 0. it1 ) = ( 0_ (n,L) ) & ( 1. it1 ) = ( 1_ (n,L) ))
and
A25: (for x being set holds (x in (the carrier of it2) iff x is (Polynomial of n,L)))
and
A26: (for x,y being (Element of it2) holds (for p,q being (Polynomial of n,L) holds ((x = p & y = q) implies ( x + y ) = ( p + q ))))
and
A27: (for x,y being (Element of it2) holds (for p,q being (Polynomial of n,L) holds ((x = p & y = q) implies ( x * y ) = ( p *' q ))))
and
A28: (( 0. it2 ) = ( 0_ (n,L) ) & ( 1. it2 ) = ( 1_ (n,L) ));
A29:now
let x being set;
hereby
assume x in (the carrier of it1);
then x is (Polynomial of n,L) by A21;
hence x in (the carrier of it2) by A25;
end;
assume x in (the carrier of it2);
then x is (Polynomial of n,L) by A25;
hence x in (the carrier of it1) by A21;
end;
then A30: (the carrier of it1) = (the carrier of it2) by TARSKI:1;
A31:now
let a being (Element of it1),b being (Element of it1);
reconsider a9 = a,b9 = b as (Element of it2) by A29;
reconsider a19 = a9,b19 = b9 as (Element of it2);
reconsider p = a,q = b as (Polynomial of n,L) by A21;
reconsider a1 = a,b1 = b as (Element of it1);
thus ( (the multF of it1) . (a,b) ) = ( a1 * b1 )
.= ( p *' q ) by A23
.= ( a19 * b19 ) by A27
.= ( (the multF of it2) . (a,b) );
end;
now
let a being (Element of it1),b being (Element of it1);
reconsider a9 = a,b9 = b as (Element of it2) by A29;
reconsider a19 = a9,b19 = b9 as (Element of it2);
reconsider p = a,q = b as (Polynomial of n,L) by A21;
reconsider a1 = a,b1 = b as (Element of it1);
thus ( (the addF of it1) . (a,b) ) = ( a1 + b1 )
.= ( p + q ) by A22
.= ( a19 + b19 ) by A26
.= ( (the addF of it2) . (a,b) );
end;
then (the addF of it1) = (the addF of it2) by A30,BINOP_1:2;
hence thesis by A24,A28,A30,A31,BINOP_1:2;
end;
end;
