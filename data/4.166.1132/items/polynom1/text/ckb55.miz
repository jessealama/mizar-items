environ
vocabularies NUMBERS,STRUCT_0,ZFMISC_1,RLVECT_1,ALGSTR_0,VECTSP_1,XBOOLE_0,SUPINF_2,MESFUNC1,SUBSET_1,RELAT_1,FINSEQ_1,ARYTM_3,PARTFUN1,TARSKI,CARD_3,NAT_1,ORDINAL4,FUNCT_1,FVSUM_1,ALGSTR_1,BINOP_1,LATTICES,PRE_POLY,ALGSEQ_1,FINSET_1,ARYTM_1,FUNCOP_1,GROUP_1,FUNCT_4,ORDINAL1,XXREAL_0,FINSEQ_2,MEMBER_1,FUNCT_2,CARD_1,POLYNOM1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,RELAT_1,FUNCT_1,PBOOLE,RELSET_1,FINSET_1,ORDINAL1,PARTFUN1,FUNCT_2,FINSEQ_1,STRUCT_0,ALGSTR_0,FUNCT_3,XXREAL_0,BINOP_1,NAT_1,ALGSTR_1,RLVECT_1,FINSEQ_2,GROUP_1,VECTSP_1,FUNCOP_1,FUNCT_7,MATRLIN,VFUNCT_1,FVSUM_1,PRE_POLY,RECDEF_1,CKB8,CKB9,CKB21,CKB22,CKB23,CKB24,CKB25,CKB32,CKB34,CKB35,CKB38,CKB41,CKB44,CKB49;
definitions TARSKI,XBOOLE_0,FUNCT_1,FUNCT_2,RLVECT_1,VECTSP_1,GROUP_1,FINSEQ_2,STRUCT_0,ALGSTR_0,FUNCOP_1,CKB8,CKB9,CKB21,CKB22,CKB25,CKB34,CKB35,CKB38,CKB41;
theorems FUNCT_1,FINSET_1,FINSEQ_3,FINSEQ_4,ZFMISC_1,FINSEQ_1,FUNCT_2,RLVECT_1,VECTSP_1,FUNCOP_1,TARSKI,FUNCT_7,BINOP_1,RELAT_1,MATRLIN,FINSEQ_2,ORDINAL1,FINSEQ_5,NAT_1,PBOOLE,SUBSET_1,FVSUM_1,FUNCT_3,GROUP_1,XBOOLE_0,XBOOLE_1,RLVECT_2,PARTFUN1,XREAL_1,XXREAL_0,PRE_POLY,VFUNCT_1,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB18,CKB19,CKB20,CKB21,CKB22,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB45,CKB46,CKB47;
schemes FRAENKEL,FUNCT_2,FINSEQ_2,FINSEQ_1,FINSEQ_4,SUBSET_1,BINOP_1;
registrations SUBSET_1,RELAT_1,FUNCT_1,FUNCOP_1,FINSET_1,XREAL_0,CARD_1,MEMBERED,FINSEQ_1,FINSEQ_2,STRUCT_0,VECTSP_1,ALGSTR_1,VALUED_0,PRE_POLY,RELSET_1,VFUNCT_1,FUNCT_2,CKB1,CKB2,CKB16,CKB17,CKB48,CKB50,CKB51,CKB52,CKB53,CKB54;
constructors BINOP_1,FINSEQOP,SETWISEO,FINSEQ_4,RFUNCT_3,FUNCT_7,ALGSTR_1,FVSUM_1,MATRLIN,RECDEF_1,RELSET_1,PBOOLE,VFUNCT_1,CKB9,CKB21,CKB22,CKB23,CKB25,CKB32,CKB34,CKB35,CKB38,CKB41,CKB44;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
registration
let n being Ordinal;
let L being  add-associative  right_complementable  right_zeroed  right_unital  distributive non  empty doubleLoopStr;
let p being (Polynomial of n,L);
let q being (Polynomial of n,L);
cluster ( p *' q ) ->  finite-Support;
coherence
proof
deffunc F((Element of ( Bags n )),(Element of ( Bags n ))) = ( $1 + $2 );
set D = { F(b1,b2) where b1 is (Element of ( Bags n )),b2 is (Element of ( Bags n )): (b1 in ( Support p ) & b2 in ( Support q )) };
A1: ( Support q ) is  finite by CKB22:def 1;
A2: ( Support ( p *' q ) ) c= D
proof
let x9 being set;
assume A3: x9 in ( Support ( p *' q ) );
then reconsider b = x9 as (Element of ( Bags n ));
consider s being (FinSequence of (the carrier of L)) such that A4: ( ( p *' q ) . b ) = ( Sum s ) and A5: ( len s ) = ( len ( decomp b ) ) and A6: (for k being (Element of ( NAT )) holds (k in ( dom s ) implies (ex b1,b2 being (bag of n) st (( ( decomp b ) /. k ) = <* b1,b2 *> & ( s /. k ) = ( ( p . b1 ) * ( q . b2 ) ))))) by CKB41:def 1;
( ( p *' q ) . b ) <> ( 0. L ) by A3,CKB21:def 1;
then consider k being Nat such that A7: k in ( dom s ) and A8: ( s /. k ) <> ( 0. L ) by A4,MATRLIN:11;
consider b1,b2 being (bag of n) such that A9: ( ( decomp b ) /. k ) = <* b1,b2 *> and A10: ( s /. k ) = ( ( p . b1 ) * ( q . b2 ) ) by A6,A7;
A11: b1 in ( Bags n ) by PRE_POLY:def 12;
A12: b2 in ( Bags n ) by PRE_POLY:def 12;
( q . b2 ) <> ( 0. L ) by A8,A10,VECTSP_1:6;
then A13: b2 in ( Support q ) by A12,CKB21:def 1;
( p . b1 ) <> ( 0. L ) by A8,A10,VECTSP_1:7;
then A14: b1 in ( Support p ) by A11,CKB21:def 1;
k in ( dom ( decomp b ) ) by A5,A7,FINSEQ_3:29;
then consider b19,b29 being (bag of n) such that A15: ( ( decomp b ) /. k ) = <* b19,b29 *> and A16: b = ( b19 + b29 ) by PRE_POLY:68;
(b19 = b1 & b29 = b2) by A9,A15,FINSEQ_1:77;
hence thesis by A14,A13,A16;
end;
A17: ( Support p ) is  finite by CKB22:def 1;
D is  finite from FRAENKEL:sch 22(A17,A1);
hence thesis by A2,CKB22:def 1;
end;
end;
