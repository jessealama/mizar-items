environ
vocabularies NUMBERS,XREAL_0,ORDINAL1,SUBSET_1,RELAT_1,WELLORD1,RELAT_2,ZFMISC_1,TARSKI,XBOOLE_0,FUNCT_1,FINSEQ_1,PRE_TOPC,METRIC_1,SETFAM_1,CARD_5,RCOMP_1,STRUCT_0,PCOMPS_1,CARD_1,ARYTM_3,XXREAL_0,ORDINAL4,PARTFUN1,NEWTON,NAT_1,REAL_1,FINSET_1,ARYTM_1,PCOMPS_2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,NUMBERS,XREAL_0,REAL_1,TOPS_2,FUNCT_1,PARTFUN1,FUNCT_2,NAT_1,SETFAM_1,STRUCT_0,NEWTON,METRIC_1,PRE_TOPC,PCOMPS_1,WELLORD1,RELAT_1,FINSEQ_1,FINSET_1,RELAT_2,FINSEQ_2,XXREAL_0,CKB3;
definitions TARSKI,WELLORD1,RELAT_2,SETFAM_1,XBOOLE_0,PRE_TOPC,STRUCT_0,CKB3;
theorems PCOMPS_1,COMPTS_1,SETFAM_1,TOPS_1,TOPS_2,PRE_TOPC,SUBSET_1,TARSKI,WELLORD2,ZFMISC_1,NAT_1,PREPOWER,WELLORD1,RELAT_1,RELAT_2,FUNCT_1,METRIC_1,FINSEQ_1,CARD_1,FINSEQ_2,FINSEQ_4,TBSP_1,NEWTON,XBOOLE_0,XBOOLE_1,XCMPLX_1,XREAL_1,XXREAL_0,ORDINAL1,PARTFUN1,CKB1,CKB3;
schemes NAT_1,FUNCT_2,SUBSET_1,RECDEF_1,TREES_2,FRAENKEL,XBOOLE_0,CKB2;
registrations SUBSET_1,ORDINAL1,RELSET_1,FINSET_1,XXREAL_0,NAT_1,MEMBERED,FINSEQ_1,STRUCT_0,PRE_TOPC,METRIC_1,TOPS_1;
constructors SETFAM_1,RELAT_2,WELLORD1,WELLORD2,XXREAL_0,REAL_1,NAT_1,PARTFUN1,MEMBERED,NEWTON,TOPS_2,COMPTS_1,PCOMPS_1,RELSET_1,CKB3;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve A for set;
definition
let FX being set;
let R being Relation;
func DisjointFam (FX,R)
means
(A in it iff (ex B being (Element of FX) st (B in FX & A = ( B \ ( PartUnion (B,R) ) ))));
existence
proof
defpred P[ set ]
 means
(ex B being (Element of FX) st (B in FX & $1 = ( B \ ( PartUnion (B,R) ) )));
consider X being set such that A1: (for x being set holds (x in X iff (x in ( bool ( union FX ) ) & P[ x ]))) from XBOOLE_0:sch 1;
reconsider X as set;
take X;
let A;
thus (A in X implies (ex B being (Element of FX) st (B in FX & A = ( B \ ( PartUnion (B,R) ) )))) by A1;
assume A2: (ex B being (Element of FX) st (B in FX & A = ( B \ ( PartUnion (B,R) ) )));
then A c= ( union FX ) by XBOOLE_1:109,ZFMISC_1:74;
hence thesis by A1,A2;
end;
uniqueness
proof
defpred P[ set ]
 means
(ex B being (Element of FX) st (B in FX & $1 = ( B \ ( PartUnion (B,R) ) )));
thus (for X1,X2 being set holds (((for x being set holds (x in X1 iff P[ x ])) & (for x being set holds (x in X2 iff P[ x ]))) implies X1 = X2)) from XBOOLE_0:sch 3;
end;
end;
