environ
vocabularies NUMBERS,SUBSET_1,XREAL_0,ORDINAL1,SEQ_1,ARYTM_3,CARD_1,FUNCT_1,POWER,SEQ_2,ORDINAL2,ARYTM_1,XXREAL_0,COMPLEX1,RELAT_1,INT_1,NAT_1,REAL_1,CARD_3,VALUED_1,FUNCOP_1,VALUED_0,XXREAL_2,PREPOWER,NEWTON,SERIES_1,ABIAN,MEMBERED,XBOOLE_0,IDEAL_1,XCMPLX_0;
notations XBOOLE_0,SUBSET_1,ORDINAL1,NUMBERS,XCMPLX_0,XREAL_0,COMPLEX1,REAL_1,NAT_1,MEMBERED,RELAT_1,FUNCT_1,VALUED_0,VALUED_1,SEQ_1,SEQ_2,FUNCT_2,INT_1,NEWTON,ABIAN,PREPOWER,POWER,FUNCOP_1,XXREAL_0,CKB5;
definitions VALUED_1,XCMPLX_0;
theorems SEQ_1,SEQ_2,SEQM_3,SEQ_4,NAT_1,RFUNCT_2,ABSVALUE,INT_1,PREPOWER,POWER,FUNCT_2,NEWTON,XCMPLX_1,FUNCOP_1,XREAL_1,COMPLEX1,XXREAL_0,ORDINAL1,VALUED_0,VALUED_1,MEMBERED,CKB1,CKB2,CKB3,CKB4;
schemes NAT_1,SEQ_1,FUNCT_2,RECDEF_1;
registrations ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,MEMBERED,NEWTON,XBOOLE_0,VALUED_0,VALUED_1,FUNCT_2,POWER,FUNCOP_1,SEQ_2,SEQ_4,XCMPLX_0;
constructors FUNCOP_1,XXREAL_0,REAL_1,NAT_1,SEQ_2,SEQM_3,NEWTON,PREPOWER,POWER,PARTFUN1,SEQ_1,VALUED_1,SEQ_4,RELSET_1,ABIAN,BINOP_2,CKB5;
requirements REAL,NUMERALS,SUBSET,ARITHM,BOOLE;
begin
reserve n for (Element of ( NAT ));
reserve k for (Element of ( NAT ));
definition
let X being  complex-membered set;
let s being (sequence of X);
assume that
A1: X is non empty  add-closed;
func Partial_Sums s -> (sequence of X)
means
:Def1: (( it . ( 0 ) ) = ( s . ( 0 ) ) & (for n holds ( it . ( n + 1 ) ) = ( ( it . n ) + ( s . ( n + 1 ) ) )));
existence
proof
reconsider X as non empty  complex-membered set by A1;
reconsider s as (sequence of X);
defpred P[ Nat,(Element of X),set ]
 means
$3 = ( $2 + ( s . ( $1 + 1 ) ) );
A2: (for n being (Element of ( NAT )) holds (for x being (Element of X) holds (ex y being (Element of X) st P[ n,x,y ])))
proof
let n being (Element of ( NAT ));
let x being (Element of X);
reconsider y = ( x + ( s . ( n + 1 ) ) ) as (Element of X) by A1,MEMBERED:def 25;
take y;
thus P[ n,x,y ];
end;
(ex f being (Function of ( NAT ),X) st (( f . ( 0 ) ) = ( s . ( 0 ) ) & (for n being (Element of ( NAT )) holds P[ n,( f . n ),( f . ( n + 1 ) ) ]))) from RECDEF_1:sch 2(A2);
hence thesis;
end;
uniqueness
proof
let s1 being (sequence of X),s2 being (sequence of X);
assume that
A3: ( s1 . ( 0 ) ) = ( s . ( 0 ) )
and
A4: (for n holds ( s1 . ( n + 1 ) ) = ( ( s1 . n ) + ( s . ( n + 1 ) ) ))
and
A5: ( s2 . ( 0 ) ) = ( s . ( 0 ) )
and
A6: (for n holds ( s2 . ( n + 1 ) ) = ( ( s2 . n ) + ( s . ( n + 1 ) ) ));
defpred X[ (Element of ( NAT )) ]
 means
( s1 . $1 ) = ( s2 . $1 );
A7: (for k holds (X[ k ] implies X[ ( k + 1 ) ]))
proof
let k;
assume ( s1 . k ) = ( s2 . k );
hence ( s1 . ( k + 1 ) ) = ( ( s2 . k ) + ( s . ( k + 1 ) ) ) by A4
.= ( s2 . ( k + 1 ) ) by A6;
end;
A8: X[ ( 0 ) ] by A3,A5;
(for n holds X[ n ]) from NAT_1:sch 1(A8,A7);
hence s1 = s2 by FUNCT_2:63;
end;
end;
