environ
vocabularies NUMBERS,STRUCT_0,FUNCT_1,ZFMISC_1,XBOOLE_0,PARTFUN1,SUBSET_1,REAL_1,RELAT_1,CARD_1,FUNCT_5,TARSKI,VALUED_0,ORDINAL1,XXREAL_0,ARYTM_3,RELAT_2,FUNCT_3,COMPLEX1,ARYTM_1,XREAL_0,METRIC_1,FUNCOP_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,ORDINAL1,NUMBERS,XCMPLX_0,XXREAL_0,XREAL_0,COMPLEX1,REAL_1,RELAT_1,FUNCOP_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCT_3,BINOP_1,FUNCT_5,VALUED_0,STRUCT_0,CKB1,CKB3,CKB4,CKB5,CKB6,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB22,CKB27;
definitions STRUCT_0,XBOOLE_0,BINOP_1,FUNCT_5,CKB4,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
theorems TARSKI,BINOP_1,ZFMISC_1,FUNCT_2,RELSET_1,RELAT_1,FUNCT_3,ABSVALUE,SUBSET_1,PARTFUN1,CARD_1,FUNCT_1,XBOOLE_0,XBOOLE_1,XREAL_1,COMPLEX1,XXREAL_0,SQUARE_1,FUNCOP_1,CKB4,CKB7,CKB8,CKB9,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB23,CKB24,CKB25,CKB26,CKB28,CKB29,CKB30;
schemes FRAENKEL,BINOP_1;
registrations XBOOLE_0,RELAT_1,FUNCT_1,NUMBERS,XREAL_0,MEMBERED,STRUCT_0,VALUED_0,FUNCT_2,PARTFUN1,RELSET_1,CKB1,CKB2,CKB10,CKB11,CKB21;
constructors BINOP_1,FUNCT_3,XXREAL_0,REAL_1,COMPLEX1,STRUCT_0,VALUED_1,FUNCT_5,PARTFUN1,RELSET_1,FUNCOP_1,CKB1,CKB3,CKB4,CKB6,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB27;
requirements BOOLE,REAL,NUMERALS,SUBSET,ARITHM;
begin
definition
let A being set;
func discrete_dist A -> (Function of [: A,A :],( REAL )) means 
:Def11: (for x,y being (Element of A) holds (( it . (x,x) ) = ( 0 ) & (x <> y implies ( it . (x,y) ) = 1)));
existence
proof
per cases ;
suppose A1: A is  empty;

then [: A,A :] = ( {} ) by ZFMISC_1:90;
then reconsider f = ( {} ) as (Function of [: A,A :],( REAL )) by RELSET_1:12;
take f;
let x being (Element of A);
let y being (Element of A);
( dom ( {} ) ) = ( {} );
hence ( f . (x,x) ) = ( 0 ) by FUNCT_1:def 2;
x = ( {} ) by A1,SUBSET_1:def 1
.= y by A1,SUBSET_1:def 1;
hence thesis;
end;
suppose A2: A is non  empty;

({ ( 0 ),1 } c= ( REAL ) & ( rng ( chi (( [: A,A :] \ ( id A ) ),[: A,A :]) ) ) c= { ( 0 ),1 }) by FUNCT_3:39,ZFMISC_1:32;
then A3: ( rng ( chi (( [: A,A :] \ ( id A ) ),[: A,A :]) ) ) c= ( REAL ) by XBOOLE_1:1;
( dom ( chi (( [: A,A :] \ ( id A ) ),[: A,A :]) ) ) = [: A,A :] by FUNCT_3:def 3;
then reconsider char = ( chi (( [: A,A :] \ ( id A ) ),[: A,A :]) ) as (Function of [: A,A :],( REAL )) by A3,RELSET_1:4;
take char;
let x being (Element of A);
let y being (Element of A);
( [: A,A :] \ ( [: A,A :] \ ( id A ) ) ) = ( [: A,A :] /\ ( id A ) ) by XBOOLE_1:48
.= ( id A ) by XBOOLE_1:28;
then [ x,x ] in ( [: A,A :] \ ( [: A,A :] \ ( id A ) ) ) by A2,RELAT_1:def 10;
hence ( char . (x,x) ) = ( 0 ) by FUNCT_3:37;
assume x <> y;
then A4: (not [ x,y ] in ( id A )) by RELAT_1:def 10;
[ x,y ] in [: A,A :] by A2,ZFMISC_1:def 2;
then [ x,y ] in ( [: A,A :] \ ( id A ) ) by A4,XBOOLE_0:def 5;
hence thesis by FUNCT_3:def 3;
end;
end;
uniqueness
proof
let f being (Function of [: A,A :],( REAL ));
let f9 being (Function of [: A,A :],( REAL ));
assume that
A5: (for x,y being (Element of A) holds (( f . (x,x) ) = ( 0 ) & (x <> y implies ( f . (x,y) ) = 1)))
and
A6: (for x,y being (Element of A) holds (( f9 . (x,x) ) = ( 0 ) & (x <> y implies ( f9 . (x,y) ) = 1)));
now
let x being (Element of A);
let y being (Element of A);
now
per cases ;
suppose A7: x = y;

hence ( f . (x,y) ) = ( 0 ) by A5
.= ( f9 . (x,y) ) by A6,A7;
end;
suppose A8: x <> y;

hence ( f . (x,y) ) = 1 by A5
.= ( f9 . (x,y) ) by A6,A8;
end;
end;
hence ( f . (x,y) ) = ( f9 . (x,y) );
end;
hence thesis by BINOP_1:2;
end;
end;
