environ
vocabularies ORDERS_2,NATTRA_1,RELAT_1,STRUCT_0,XBOOLE_0,ORDERS_1,SUBSET_1,WELLORD1,RELAT_2,XXREAL_0,TARSKI,ZFMISC_1,FUNCT_1,SEQM_3,FUNCT_2,CAT_5,CAT_1,ALTCAT_1,PBOOLE,FUNCOP_1,BINOP_1,ORDERS_3;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,FUNCT_1,ORDERS_1,CAT_5,MCART_1,WELLORD1,MULTOP_1,PBOOLE,RELSET_1,PARTFUN1,FUNCT_2,BINOP_1,FUNCOP_1,DOMAIN_1,STRUCT_0,ORDERS_2,CAT_1,ENS_1,ALTCAT_1,CKB1,CKB7,CKB8,CKB9,CKB10,CKB18,CKB20,CKB21,CKB22,CKB25,CKB29,CKB37,CKB40;
definitions TARSKI,ALTCAT_1,FUNCOP_1,XBOOLE_0,STRUCT_0,CKB1,CKB7,CKB9,CKB18,CKB22,CKB25,CKB29,CKB37,CKB40;
theorems RELAT_1,RELSET_1,ORDERS_2,TARSKI,ZFMISC_1,WELLORD1,SYSREL,FUNCT_1,FUNCT_2,MCART_1,ENS_1,PBOOLE,MULTOP_1,ALTCAT_1,XBOOLE_0,XBOOLE_1,PARTFUN1,CKB1,CKB5,CKB7,CKB9,CKB11,CKB12,CKB13,CKB14,CKB15,CKB18,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB29,CKB30,CKB32,CKB33,CKB34,CKB35,CKB37,CKB40;
schemes TARSKI,CAT_5,ALTCAT_1,XBOOLE_0,CKB38,CKB39;
registrations XBOOLE_0,SUBSET_1,FUNCT_1,RELSET_1,PARTFUN1,FUNCT_2,STRUCT_0,ORDERS_2,ENS_1,CAT_5,ALTCAT_1,CKB2,CKB3,CKB4,CKB6,CKB16,CKB17,CKB19,CKB28,CKB31,CKB36,CKB41;
constructors RELAT_2,WELLORD1,PARTFUN1,DOMAIN_1,ORDERS_2,ENS_1,CAT_5,ALTCAT_1,MULTOP_1,PBOOLE,RELSET_1,CKB1,CKB7,CKB9,CKB18,CKB21,CKB22,CKB25,CKB29,CKB37,CKB40;
requirements BOOLE,SUBSET;
begin
reserve P for non  empty POSet_set;
registration
let P being non  empty POSet_set;
cluster ( POSAltCat P ) ->  associative  with_units;
coherence
proof
set A = ( POSAltCat P );
set G = (the Arrows of A);
set C = (the Comp of A);
thus C is  associative
proof
let i being (Element of A);
let j being (Element of A);
let k being (Element of A);
let l being (Element of A);
let f being set;
let g being set;
let h being set;
reconsider i9 = i,j9 = j,k9 = k,l9 = l as (Element of P) by CKB40:def 1;
assume that
A1: f in ( G . (i,j) )
and
A2: g in ( G . (j,k) )
and
A3: h in ( G . (k,l) );
A4: g in ( MonFuncs (j9,k9) ) by A2,CKB40:def 1;
A5: h in ( MonFuncs (k9,l9) ) by A3,CKB40:def 1;
A6: f in ( MonFuncs (i9,j9) ) by A1,CKB40:def 1;
then reconsider f9 = f,g9 = g,h9 = h as Function by A4,A5;
A7: ( C . (i,j,l) ) = ( FuncComp (( MonFuncs (i9,j9) ),( MonFuncs (j9,l9) )) ) by CKB40:def 1;
( C . (j,k,l) ) = ( FuncComp (( MonFuncs (j9,k9) ),( MonFuncs (k9,l9) )) ) by CKB40:def 1;
then A8: ( ( C . (j,k,l) ) . (h,g) ) = ( h9 * g9 ) by A4,A5,ALTCAT_1:11;
( C . (i,j,k) ) = ( FuncComp (( MonFuncs (i9,j9) ),( MonFuncs (j9,k9) )) ) by CKB40:def 1;
then A9: ( ( C . (i,j,k) ) . (g,f) ) = ( g9 * f9 ) by A6,A4,ALTCAT_1:11;
( h9 * g9 ) in ( MonFuncs (j9,l9) ) by A4,A5,CKB26:1;
then A10: ( ( C . (i,j,l) ) . (( h9 * g9 ),f9) ) = ( ( h9 * g9 ) * f9 ) by A6,A7,ALTCAT_1:11;
A11: ( C . (i,k,l) ) = ( FuncComp (( MonFuncs (i9,k9) ),( MonFuncs (k9,l9) )) ) by CKB40:def 1;
( g9 * f9 ) in ( MonFuncs (i9,k9) ) by A6,A4,CKB26:1;
then ( ( C . (i,k,l) ) . (h,( g9 * f9 )) ) = ( h9 * ( g9 * f9 ) ) by A5,A11,ALTCAT_1:11;
hence thesis by A9,A8,A10,RELAT_1:36;
end;

thus C is  with_left_units
proof
let j being (Element of A);
reconsider j9 = j as (Element of P) by CKB40:def 1;
take e = ( id (the carrier of j9) );
( G . (j,j) ) = ( MonFuncs (j9,j9) ) by CKB40:def 1;
hence e in ( G . (j,j) ) by CKB27:1;
let i being (Element of A);
let f being set;
reconsider i9 = i as (Element of P) by CKB40:def 1;
A12: ( C . (i,j,j) ) = ( FuncComp (( MonFuncs (i9,j9) ),( MonFuncs (j9,j9) )) ) by CKB40:def 1;
assume f in ( G . (i,j) );
then A13: f in ( MonFuncs (i9,j9) ) by CKB40:def 1;
then consider f9 being (Function of i9,j9) such that A14: f = f9 and f9 in ( Funcs ((the carrier of i9),(the carrier of j9)) ) and f9 is  monotone by CKB25:def 1;
A15: e in ( MonFuncs (j9,j9) ) by CKB27:1;
then consider e9 being (Function of j9,j9) such that A16: e = e9 and e9 in ( Funcs ((the carrier of j9),(the carrier of j9)) ) and e9 is  monotone by CKB25:def 1;
( rng f9 ) c= (the carrier of j9);
then ( e9 * f9 ) = f by A16,A14,RELAT_1:53;
hence thesis by A15,A16,A13,A14,A12,ALTCAT_1:11;
end;

thus C is  with_right_units
proof
let i being (Element of A);
reconsider i9 = i as (Element of P) by CKB40:def 1;
take e = ( id (the carrier of i9) );
( G . (i,i) ) = ( MonFuncs (i9,i9) ) by CKB40:def 1;
hence e in ( G . (i,i) ) by CKB27:1;
let j being (Element of A);
let f being set;
reconsider j9 = j as (Element of P) by CKB40:def 1;
A17: ( C . (i,i,j) ) = ( FuncComp (( MonFuncs (i9,i9) ),( MonFuncs (i9,j9) )) ) by CKB40:def 1;
assume f in ( G . (i,j) );
then A18: f in ( MonFuncs (i9,j9) ) by CKB40:def 1;
then consider f9 being (Function of i9,j9) such that A19: f = f9 and f9 in ( Funcs ((the carrier of i9),(the carrier of j9)) ) and f9 is  monotone by CKB25:def 1;
A20: e in ( MonFuncs (i9,i9) ) by CKB27:1;
then consider e9 being (Function of i9,i9) such that A21: e = e9 and e9 in ( Funcs ((the carrier of i9),(the carrier of i9)) ) and e9 is  monotone by CKB25:def 1;
( dom f9 ) = (the carrier of i9) by FUNCT_2:def 1;
then ( f9 * e9 ) = f by A21,A19,RELAT_1:52;
hence thesis by A20,A21,A18,A19,A17,ALTCAT_1:11;
end;

end;
end;
