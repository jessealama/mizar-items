environ
vocabularies NUMBERS,SUBSET_1,FINSEQ_2,MARGREL1,CARD_1,ARYTM_3,INT_2,NAT_1,RELAT_1,XXREAL_0,INT_1,ARYTM_1,GRCAT_1,XBOOLEAN,FINSEQ_1,PARTFUN1,FUNCT_1,POWER,BINARI_3,FUNCOP_1,XBOOLE_0,BINARITH,MATRIX_1,INCSP_1,ORDINAL4,FUNCT_7,FUNCT_2,TARSKI,TREES_1,IDEA_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,INT_1,INT_2,NAT_1,NAT_D,MARGREL1,RELAT_1,FUNCT_1,FUNCOP_1,MATRIX_1,PARTFUN1,FUNCT_2,FUNCT_7,SERIES_1,FINSEQ_1,FINSEQ_2,RECDEF_1,BINARITH,BINARI_3,XXREAL_0,CKB8,CKB9,CKB12,CKB15,CKB17,CKB18,CKB19,CKB26,CKB29,CKB32,CKB33,CKB39,CKB40,CKB41,CKB52,CKB56,CKB57,CKB58,CKB60,CKB62,CKB63,CKB64,CKB65;
definitions TARSKI,FINSEQ_2,XBOOLEAN,CKB8,CKB9,CKB15,CKB17,CKB18,CKB19,CKB26,CKB29,CKB32,CKB33,CKB39,CKB40,CKB41,CKB52,CKB56,CKB57,CKB58,CKB60,CKB62,CKB63,CKB64,CKB65;
theorems NAT_1,NAT_2,NEWTON,INT_1,INT_2,FINSEQ_1,FINSEQ_2,FUNCT_1,FUNCT_2,FUNCT_7,FUNCOP_1,POWER,EULER_1,EULER_2,BINARITH,BINARI_3,MATRIX_1,RELSET_1,RELAT_1,XBOOLE_1,XREAL_1,XXREAL_0,XBOOLEAN,NAT_D,PARTFUN1,ORDINAL1,XREAL_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB56,CKB57,CKB58,CKB60,CKB62,CKB63,CKB64,CKB65,CKB66,CKB67,CKB68,CKB69,CKB70,CKB71,CKB72,CKB73,CKB74,CKB75,CKB76,CKB77,CKB78;
schemes FINSEQ_1,FINSEQ_2,NAT_1,FUNCT_2;
registrations XBOOLE_0,RELAT_1,FUNCT_1,ORDINAL1,FUNCT_2,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,MARGREL1,FUNCT_7,VALUED_0,CARD_1,FINSEQ_2,RELSET_1,CKB53,CKB54,CKB55,CKB59,CKB61;
constructors PARTFUN1,XXREAL_0,NAT_1,NAT_D,SERIES_1,BINARITH,WSIERP_1,FUNCT_7,MATRIX_1,BINARI_3,RECDEF_1,RELSET_1,CKB8,CKB9,CKB12,CKB15,CKB17,CKB18,CKB19,CKB26,CKB29,CKB32,CKB33,CKB39,CKB40,CKB41,CKB52,CKB56,CKB57,CKB58,CKB60,CKB62,CKB63,CKB64,CKB65;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve m for (FinSequence of ( NAT ));
theorem
Th48: (for n being non empty (Element of ( NAT )) holds (for lk being (Element of ( NAT )) holds (for Key1,Key2 being (Matrix of lk,6,( NAT )) holds (for r being (Element of ( NAT )) holds (for m holds ((((((((lk >= r & ( ( 2 to_power n ) + 1 ) is  prime) & ( len m ) >= 4) & ( m . 1 ) is_expressible_by n) & ( m . 2 ) is_expressible_by n) & ( m . 3 ) is_expressible_by n) & ( m . 4 ) is_expressible_by n) & (for i being (Element of ( NAT )) holds (i <= r implies (((((((((((((((((( Key1 * (i,1) ) is_expressible_by n & ( Key1 * (i,2) ) is_expressible_by n) & ( Key1 * (i,3) ) is_expressible_by n) & ( Key1 * (i,4) ) is_expressible_by n) & ( Key1 * (i,5) ) is_expressible_by n) & ( Key1 * (i,6) ) is_expressible_by n) & ( Key2 * (i,1) ) is_expressible_by n) & ( Key2 * (i,2) ) is_expressible_by n) & ( Key2 * (i,3) ) is_expressible_by n) & ( Key2 * (i,4) ) is_expressible_by n) & ( Key2 * (i,5) ) is_expressible_by n) & ( Key2 * (i,6) ) is_expressible_by n) & ( Key2 * (i,1) ) = ( INV_MOD (( Key1 * (i,1) ),n) )) & ( Key2 * (i,2) ) = ( NEG_MOD (( Key1 * (i,3) ),n) )) & ( Key2 * (i,3) ) = ( NEG_MOD (( Key1 * (i,2) ),n) )) & ( Key2 * (i,4) ) = ( INV_MOD (( Key1 * (i,4) ),n) )) & ( Key1 * (i,5) ) = ( Key2 * (i,5) )) & ( Key1 * (i,6) ) = ( Key2 * (i,6) ))))) implies ( ( compose (( ( IDEA_P_F (Key1,n,r) ) ^ ( IDEA_Q_F (Key2,n,r) ) ),( MESSAGES )) ) . m ) = m))))))
proof
let n being non empty (Element of ( NAT ));
let lk being (Element of ( NAT ));
let Key1 being (Matrix of lk,6,( NAT )),Key2 being (Matrix of lk,6,( NAT ));
(for r being (Element of ( NAT )) holds ((((((((lk >= r & ( ( 2 to_power n ) + 1 ) is  prime) & ( len m ) >= 4) & ( m . 1 ) is_expressible_by n) & ( m . 2 ) is_expressible_by n) & ( m . 3 ) is_expressible_by n) & ( m . 4 ) is_expressible_by n) & (for i being (Element of ( NAT )) holds (i <= r implies (((((((((((((((((( Key1 * (i,1) ) is_expressible_by n & ( Key1 * (i,2) ) is_expressible_by n) & ( Key1 * (i,3) ) is_expressible_by n) & ( Key1 * (i,4) ) is_expressible_by n) & ( Key1 * (i,5) ) is_expressible_by n) & ( Key1 * (i,6) ) is_expressible_by n) & ( Key2 * (i,1) ) is_expressible_by n) & ( Key2 * (i,2) ) is_expressible_by n) & ( Key2 * (i,3) ) is_expressible_by n) & ( Key2 * (i,4) ) is_expressible_by n) & ( Key2 * (i,5) ) is_expressible_by n) & ( Key2 * (i,6) ) is_expressible_by n) & ( Key2 * (i,1) ) = ( INV_MOD (( Key1 * (i,1) ),n) )) & ( Key2 * (i,2) ) = ( NEG_MOD (( Key1 * (i,3) ),n) )) & ( Key2 * (i,3) ) = ( NEG_MOD (( Key1 * (i,2) ),n) )) & ( Key2 * (i,4) ) = ( INV_MOD (( Key1 * (i,4) ),n) )) & ( Key1 * (i,5) ) = ( Key2 * (i,5) )) & ( Key1 * (i,6) ) = ( Key2 * (i,6) ))))) implies ( ( compose (( ( IDEA_P_F (Key1,n,r) ) ^ ( IDEA_Q_F (Key2,n,r) ) ),( MESSAGES )) ) . m ) = m))
proof
defpred P[ (Element of ( NAT )) ]
 means
((((((((lk >= $1 & ( ( 2 to_power n ) + 1 ) is  prime) & ( len m ) >= 4) & ( m . 1 ) is_expressible_by n) & ( m . 2 ) is_expressible_by n) & ( m . 3 ) is_expressible_by n) & ( m . 4 ) is_expressible_by n) & (for i being (Element of ( NAT )) holds (i <= $1 implies (((((((((((((((((( Key1 * (i,1) ) is_expressible_by n & ( Key1 * (i,2) ) is_expressible_by n) & ( Key1 * (i,3) ) is_expressible_by n) & ( Key1 * (i,4) ) is_expressible_by n) & ( Key1 * (i,5) ) is_expressible_by n) & ( Key1 * (i,6) ) is_expressible_by n) & ( Key2 * (i,1) ) is_expressible_by n) & ( Key2 * (i,2) ) is_expressible_by n) & ( Key2 * (i,3) ) is_expressible_by n) & ( Key2 * (i,4) ) is_expressible_by n) & ( Key2 * (i,5) ) is_expressible_by n) & ( Key2 * (i,6) ) is_expressible_by n) & ( Key2 * (i,1) ) = ( INV_MOD (( Key1 * (i,1) ),n) )) & ( Key2 * (i,2) ) = ( NEG_MOD (( Key1 * (i,3) ),n) )) & ( Key2 * (i,3) ) = ( NEG_MOD (( Key1 * (i,2) ),n) )) & ( Key2 * (i,4) ) = ( INV_MOD (( Key1 * (i,4) ),n) )) & ( Key1 * (i,5) ) = ( Key2 * (i,5) )) & ( Key1 * (i,6) ) = ( Key2 * (i,6) ))))) implies ( ( compose (( ( IDEA_P_F (Key1,n,$1) ) ^ ( IDEA_Q_F (Key2,n,$1) ) ),( MESSAGES )) ) . m ) = m);
A1: ( len ( IDEA_P_F (Key1,n,( 0 )) ) ) = ( 0 ) by CKB58:def 1;
A2: (for k being (Element of ( NAT )) holds (P[ k ] implies P[ ( k + 1 ) ]))
proof
let k being (Element of ( NAT ));
assume A3: P[ k ];
consider k1 being (Element of ( NAT )) such that A4: k1 = ( k + 1 );
A5: ( dom ( compose (( IDEA_P_F (Key1,n,k) ),( MESSAGES )) ) ) = ( MESSAGES ) by CKB76:1;
A6: ( rng ( compose (( IDEA_P_F (Key1,n,k) ),( MESSAGES )) ) ) c= ( MESSAGES ) by CKB76:1;
A7: m in ( MESSAGES ) by FINSEQ_1:def 11;
then ( ( compose (( IDEA_P_F (Key1,n,k) ),( MESSAGES )) ) . m ) in ( rng ( compose (( IDEA_P_F (Key1,n,k) ),( MESSAGES )) ) ) by A5,FUNCT_1:def 3;
then reconsider M = ( ( compose (( IDEA_P_F (Key1,n,k) ),( MESSAGES )) ) . m ) as (FinSequence of ( NAT )) by A6,FINSEQ_1:def 11;
assume that
A8: lk >= ( k + 1 )
and
A9: ( ( 2 to_power n ) + 1 ) is  prime
and
A10: ((((( len m ) >= 4 & ( m . 1 ) is_expressible_by n) & ( m . 2 ) is_expressible_by n) & ( m . 3 ) is_expressible_by n) & ( m . 4 ) is_expressible_by n)
and
A11: (for i being (Element of ( NAT )) holds (i <= ( k + 1 ) implies (((((((((((((((((( Key1 * (i,1) ) is_expressible_by n & ( Key1 * (i,2) ) is_expressible_by n) & ( Key1 * (i,3) ) is_expressible_by n) & ( Key1 * (i,4) ) is_expressible_by n) & ( Key1 * (i,5) ) is_expressible_by n) & ( Key1 * (i,6) ) is_expressible_by n) & ( Key2 * (i,1) ) is_expressible_by n) & ( Key2 * (i,2) ) is_expressible_by n) & ( Key2 * (i,3) ) is_expressible_by n) & ( Key2 * (i,4) ) is_expressible_by n) & ( Key2 * (i,5) ) is_expressible_by n) & ( Key2 * (i,6) ) is_expressible_by n) & ( Key2 * (i,1) ) = ( INV_MOD (( Key1 * (i,1) ),n) )) & ( Key2 * (i,2) ) = ( NEG_MOD (( Key1 * (i,3) ),n) )) & ( Key2 * (i,3) ) = ( NEG_MOD (( Key1 * (i,2) ),n) )) & ( Key2 * (i,4) ) = ( INV_MOD (( Key1 * (i,4) ),n) )) & ( Key1 * (i,5) ) = ( Key2 * (i,5) )) & ( Key1 * (i,6) ) = ( Key2 * (i,6) ))));
A12: (( len M ) >= 4 & ( M . 1 ) is_expressible_by n) by A10,CKB78:1;
A13: ( width Key1 ) = 6 by A8,MATRIX_1:23;
then 1 in ( Seg ( width Key1 ) ) by FINSEQ_1:1;
then A14: ( ( Line (Key1,( k + 1 )) ) . 1 ) = ( Key1 * (k1,1) ) by A4,MATRIX_1:def 7;
then A15: ( ( Line (Key1,( k + 1 )) ) . 1 ) is_expressible_by n by A11,A4;
A16: ( width Key2 ) = 6 by A8,MATRIX_1:23;
then 5 in ( Seg ( width Key2 ) ) by FINSEQ_1:1;
then A17: ( ( Line (Key2,( k + 1 )) ) . 5 ) = ( Key2 * (k1,5) ) by A4,MATRIX_1:def 7;
3 in ( Seg ( width Key1 ) ) by A13,FINSEQ_1:1;
then A18: ( ( Line (Key1,( k + 1 )) ) . 3 ) = ( Key1 * (k1,3) ) by A4,MATRIX_1:def 7;
then A19: ( ( Line (Key1,( k + 1 )) ) . 3 ) is_expressible_by n by A11,A4;
2 in ( Seg ( width Key1 ) ) by A13,FINSEQ_1:1;
then A20: ( ( Line (Key1,( k + 1 )) ) . 2 ) = ( Key1 * (k1,2) ) by A4,MATRIX_1:def 7;
then A21: ( ( Line (Key1,( k + 1 )) ) . 2 ) is_expressible_by n by A11,A4;
3 in ( Seg ( width Key2 ) ) by A16,FINSEQ_1:1;
then ( ( Line (Key2,( k + 1 )) ) . 3 ) = ( Key2 * (k1,3) ) by A4,MATRIX_1:def 7;
then A22: ( ( Line (Key2,( k + 1 )) ) . 3 ) = ( NEG_MOD (( ( Line (Key1,( k + 1 )) ) . 2 ),n) ) by A11,A4,A20;
2 in ( Seg ( width Key2 ) ) by A16,FINSEQ_1:1;
then ( ( Line (Key2,( k + 1 )) ) . 2 ) = ( Key2 * (k1,2) ) by A4,MATRIX_1:def 7;
then A23: ( ( Line (Key2,( k + 1 )) ) . 2 ) = ( NEG_MOD (( ( Line (Key1,( k + 1 )) ) . 3 ),n) ) by A11,A4,A18;
5 in ( Seg ( width Key1 ) ) by A13,FINSEQ_1:1;
then ( ( Line (Key1,( k + 1 )) ) . 5 ) = ( Key1 * (k1,5) ) by A4,MATRIX_1:def 7;
then A24: ( ( Line (Key2,( k + 1 )) ) . 5 ) = ( ( Line (Key1,( k + 1 )) ) . 5 ) by A11,A4,A17;
A25: ( M . 4 ) is_expressible_by n by A10,CKB78:1;
A26: (( M . 2 ) is_expressible_by n & ( M . 3 ) is_expressible_by n) by A10,CKB78:1;
4 in ( Seg ( width Key1 ) ) by A13,FINSEQ_1:1;
then A27: ( ( Line (Key1,( k + 1 )) ) . 4 ) = ( Key1 * (k1,4) ) by A4,MATRIX_1:def 7;
then A28: ( ( Line (Key1,( k + 1 )) ) . 4 ) is_expressible_by n by A11,A4;
4 in ( Seg ( width Key2 ) ) by A16,FINSEQ_1:1;
then ( ( Line (Key2,( k + 1 )) ) . 4 ) = ( Key2 * (k1,4) ) by A4,MATRIX_1:def 7;
then A29: ( ( Line (Key2,( k + 1 )) ) . 4 ) = ( INV_MOD (( ( Line (Key1,( k + 1 )) ) . 4 ),n) ) by A11,A4,A27;
6 in ( Seg ( width Key2 ) ) by A16,FINSEQ_1:1;
then A30: ( ( Line (Key2,( k + 1 )) ) . 6 ) = ( Key2 * (k1,6) ) by A4,MATRIX_1:def 7;
6 in ( Seg ( width Key1 ) ) by A13,FINSEQ_1:1;
then ( ( Line (Key1,( k + 1 )) ) . 6 ) = ( Key1 * (k1,6) ) by A4,MATRIX_1:def 7;
then A31: ( ( Line (Key2,( k + 1 )) ) . 6 ) = ( ( Line (Key1,( k + 1 )) ) . 6 ) by A11,A4,A30;
( dom ( ( IDEA_Q (( Line (Key2,( k + 1 )) ),n) ) * ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ) ) ) = ( MESSAGES ) by FUNCT_2:def 1;
then A32: ( dom ( ( ( IDEA_Q (( Line (Key2,( k + 1 )) ),n) ) * ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ) ) * ( compose (( IDEA_P_F (Key1,n,k) ),( MESSAGES )) ) ) ) = ( MESSAGES ) by A6,A5,RELAT_1:27;
( rng ( compose (( ( IDEA_P_F (Key1,n,k) ) ^ ( <* ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ) *> ^ <* ( IDEA_Q (( Line (Key2,( k + 1 )) ),n) ) *> ) ),( MESSAGES )) ) ) = ( rng ( compose (( ( ( IDEA_P_F (Key1,n,k) ) ^ <* ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ) *> ) ^ <* ( IDEA_Q (( Line (Key2,( k + 1 )) ),n) ) *> ),( MESSAGES )) ) ) by FINSEQ_1:32
.= ( rng ( ( IDEA_Q (( Line (Key2,( k + 1 )) ),n) ) * ( compose (( ( IDEA_P_F (Key1,n,k) ) ^ <* ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ) *> ),( MESSAGES )) ) ) ) by FUNCT_7:41;
then A33: ( rng ( compose (( ( IDEA_P_F (Key1,n,k) ) ^ ( <* ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ) *> ^ <* ( IDEA_Q (( Line (Key2,( k + 1 )) ),n) ) *> ) ),( MESSAGES )) ) ) c= ( MESSAGES ) by RELAT_1:def 19;
1 in ( Seg ( width Key2 ) ) by A16,FINSEQ_1:1;
then ( ( Line (Key2,( k + 1 )) ) . 1 ) = ( Key2 * (k1,1) ) by A4,MATRIX_1:def 7;
then A34: ( ( Line (Key2,( k + 1 )) ) . 1 ) = ( INV_MOD (( ( Line (Key1,( k + 1 )) ) . 1 ),n) ) by A11,A4,A14;
A35: ( k + 1 ) >= k by NAT_1:11;
A36: (for i being (Element of ( NAT )) holds (i <= k implies (((((((((((((((((( Key1 * (i,1) ) is_expressible_by n & ( Key1 * (i,2) ) is_expressible_by n) & ( Key1 * (i,3) ) is_expressible_by n) & ( Key1 * (i,4) ) is_expressible_by n) & ( Key1 * (i,5) ) is_expressible_by n) & ( Key1 * (i,6) ) is_expressible_by n) & ( Key2 * (i,1) ) is_expressible_by n) & ( Key2 * (i,2) ) is_expressible_by n) & ( Key2 * (i,3) ) is_expressible_by n) & ( Key2 * (i,4) ) is_expressible_by n) & ( Key2 * (i,5) ) is_expressible_by n) & ( Key2 * (i,6) ) is_expressible_by n) & ( Key2 * (i,1) ) = ( INV_MOD (( Key1 * (i,1) ),n) )) & ( Key2 * (i,2) ) = ( NEG_MOD (( Key1 * (i,3) ),n) )) & ( Key2 * (i,3) ) = ( NEG_MOD (( Key1 * (i,2) ),n) )) & ( Key2 * (i,4) ) = ( INV_MOD (( Key1 * (i,4) ),n) )) & ( Key1 * (i,5) ) = ( Key2 * (i,5) )) & ( Key1 * (i,6) ) = ( Key2 * (i,6) ))))
proof
let i being (Element of ( NAT ));
assume i <= k;
then i <= ( k + 1 ) by A35,XXREAL_0:2;
hence thesis by A11;
end;
( ( compose (( ( IDEA_P_F (Key1,n,( k + 1 )) ) ^ ( IDEA_Q_F (Key2,n,( k + 1 )) ) ),( MESSAGES )) ) . m ) = ( ( compose (( ( ( IDEA_P_F (Key1,n,k) ) ^ <* ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ) *> ) ^ ( IDEA_Q_F (Key2,n,( k + 1 )) ) ),( MESSAGES )) ) . m ) by CKB69:1
.= ( ( compose (( ( ( IDEA_P_F (Key1,n,k) ) ^ <* ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ) *> ) ^ ( <* ( IDEA_Q (( Line (Key2,( k + 1 )) ),n) ) *> ^ ( IDEA_Q_F (Key2,n,k) ) ) ),( MESSAGES )) ) . m ) by CKB70:1
.= ( ( compose (( ( ( ( IDEA_P_F (Key1,n,k) ) ^ <* ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ) *> ) ^ <* ( IDEA_Q (( Line (Key2,( k + 1 )) ),n) ) *> ) ^ ( IDEA_Q_F (Key2,n,k) ) ),( MESSAGES )) ) . m ) by FINSEQ_1:32
.= ( ( compose (( ( ( IDEA_P_F (Key1,n,k) ) ^ ( <* ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ) *> ^ <* ( IDEA_Q (( Line (Key2,( k + 1 )) ),n) ) *> ) ) ^ ( IDEA_Q_F (Key2,n,k) ) ),( MESSAGES )) ) . m ) by FINSEQ_1:32
.= ( ( ( compose (( IDEA_Q_F (Key2,n,k) ),( MESSAGES )) ) * ( compose (( ( IDEA_P_F (Key1,n,k) ) ^ ( <* ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ) *> ^ <* ( IDEA_Q (( Line (Key2,( k + 1 )) ),n) ) *> ) ),( MESSAGES )) ) ) . m ) by A33,FUNCT_7:48
.= ( ( ( compose (( IDEA_Q_F (Key2,n,k) ),( MESSAGES )) ) * ( ( compose (( <* ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ) *> ^ <* ( IDEA_Q (( Line (Key2,( k + 1 )) ),n) ) *> ),( MESSAGES )) ) * ( compose (( IDEA_P_F (Key1,n,k) ),( MESSAGES )) ) ) ) . m ) by A6,FUNCT_7:48
.= ( ( ( compose (( IDEA_Q_F (Key2,n,k) ),( MESSAGES )) ) * ( ( compose (<* ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ),( IDEA_Q (( Line (Key2,( k + 1 )) ),n) ) *>,( MESSAGES )) ) * ( compose (( IDEA_P_F (Key1,n,k) ),( MESSAGES )) ) ) ) . m ) by FINSEQ_1:def 9
.= ( ( ( compose (( IDEA_Q_F (Key2,n,k) ),( MESSAGES )) ) * ( ( ( ( IDEA_Q (( Line (Key2,( k + 1 )) ),n) ) * ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ) ) * ( id ( MESSAGES ) ) ) * ( compose (( IDEA_P_F (Key1,n,k) ),( MESSAGES )) ) ) ) . m ) by FUNCT_7:51
.= ( ( ( compose (( IDEA_Q_F (Key2,n,k) ),( MESSAGES )) ) * ( ( ( IDEA_Q (( Line (Key2,( k + 1 )) ),n) ) * ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ) ) * ( compose (( IDEA_P_F (Key1,n,k) ),( MESSAGES )) ) ) ) . m ) by FUNCT_2:17
.= ( ( compose (( IDEA_Q_F (Key2,n,k) ),( MESSAGES )) ) . ( ( ( ( IDEA_Q (( Line (Key2,( k + 1 )) ),n) ) * ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ) ) * ( compose (( IDEA_P_F (Key1,n,k) ),( MESSAGES )) ) ) . m ) ) by A32,A7,FUNCT_1:13
.= ( ( compose (( IDEA_Q_F (Key2,n,k) ),( MESSAGES )) ) . ( ( ( IDEA_Q (( Line (Key2,( k + 1 )) ),n) ) * ( IDEA_P (( Line (Key1,( k + 1 )) ),n) ) ) . ( ( compose (( IDEA_P_F (Key1,n,k) ),( MESSAGES )) ) . m ) ) ) by A5,A7,FUNCT_1:13
.= ( ( compose (( IDEA_Q_F (Key2,n,k) ),( MESSAGES )) ) . ( ( compose (( IDEA_P_F (Key1,n,k) ),( MESSAGES )) ) . m ) ) by A9,A12,A26,A25,A15,A21,A19,A28,A34,A23,A22,A29,A24,A31,CKB66:1
.= ( ( ( compose (( IDEA_Q_F (Key2,n,k) ),( MESSAGES )) ) * ( compose (( IDEA_P_F (Key1,n,k) ),( MESSAGES )) ) ) . m ) by A5,A7,FUNCT_1:13
.= m by A3,A8,A9,A10,A35,A36,A6,FUNCT_7:48,XXREAL_0:2;
hence thesis;
end;
( len ( IDEA_Q_F (Key2,n,( 0 )) ) ) = ( 0 ) by CKB60:def 1;
then ( IDEA_Q_F (Key2,n,( 0 )) ) = ( {} );
then ( ( IDEA_P_F (Key1,n,( 0 )) ) ^ ( IDEA_Q_F (Key2,n,( 0 )) ) ) = ( IDEA_P_F (Key1,n,( 0 )) ) by FINSEQ_1:34
.= ( {} ) by A1;
then (m in ( MESSAGES ) & ( compose (( ( IDEA_P_F (Key1,n,( 0 )) ) ^ ( IDEA_Q_F (Key2,n,( 0 )) ) ),( MESSAGES )) ) = ( id ( MESSAGES ) )) by FINSEQ_1:def 11,FUNCT_7:39;
then A37: P[ ( 0 ) ] by FUNCT_1:18;
thus (for k being (Element of ( NAT )) holds P[ k ]) from NAT_1:sch 1(A37,A2);
end;
hence thesis;
end;
