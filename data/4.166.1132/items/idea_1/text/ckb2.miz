environ
vocabularies NUMBERS,SUBSET_1,FINSEQ_2,MARGREL1,CARD_1,ARYTM_3,INT_2,NAT_1,RELAT_1,XXREAL_0,INT_1,ARYTM_1,GRCAT_1,XBOOLEAN,FINSEQ_1,PARTFUN1,FUNCT_1,POWER,BINARI_3,FUNCOP_1,XBOOLE_0,BINARITH,MATRIX_1,INCSP_1,ORDINAL4,FUNCT_7,FUNCT_2,TARSKI,TREES_1,IDEA_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,INT_1,INT_2,NAT_1,NAT_D,MARGREL1,RELAT_1,FUNCT_1,FUNCOP_1,MATRIX_1,PARTFUN1,FUNCT_2,FUNCT_7,SERIES_1,FINSEQ_1,FINSEQ_2,RECDEF_1,BINARITH,BINARI_3,XXREAL_0;
definitions TARSKI,FINSEQ_2,XBOOLEAN;
theorems NAT_1,NAT_2,NEWTON,INT_1,INT_2,FINSEQ_1,FINSEQ_2,FUNCT_1,FUNCT_2,FUNCT_7,FUNCOP_1,POWER,EULER_1,EULER_2,BINARITH,BINARI_3,MATRIX_1,RELSET_1,RELAT_1,XBOOLE_1,XREAL_1,XXREAL_0,XBOOLEAN,NAT_D,PARTFUN1,ORDINAL1,XREAL_0,CARD_1,CKB1;
schemes FINSEQ_1,FINSEQ_2,NAT_1,FUNCT_2;
registrations XBOOLE_0,RELAT_1,FUNCT_1,ORDINAL1,FUNCT_2,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,MARGREL1,FUNCT_7,VALUED_0,CARD_1,FINSEQ_2,RELSET_1;
constructors PARTFUN1,XXREAL_0,NAT_1,NAT_D,SERIES_1,BINARITH,WSIERP_1,FUNCT_7,MATRIX_1,BINARI_3,RECDEF_1,RELSET_1;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve i for (Element of ( NAT ));
reserve j for (Element of ( NAT ));
reserve k for (Element of ( NAT ));
theorem
Lm2: ((((j is  prime & i < j) & k < j) & i <> ( 0 )) implies (ex a being (Element of ( NAT )) st ( ( a * i ) mod j ) = k))
proof
assume that
A1: j is  prime
and
A2: i < j
and
A3: k < j
and
A4: i <> ( 0 );
consider a being Integer,b being Integer such that A5: ( ( a * i ) + ( b * j ) ) = k by A1,A2,A4,CKB1:1,EULER_1:10;
A6: j > ( 0 ) by A1,INT_2:def 4;
now
per cases ;
suppose A7: a >= ( 0 );

now
per cases ;
suppose b >= ( 0 );

then reconsider a,b as (Element of ( NAT )) by A7,INT_1:3;
take a;
( ( ( a * i ) + ( b * j ) ) mod j ) = ( ( ( a * i ) + ( ( b * j ) mod j ) ) mod j ) by NAT_D:23
.= ( ( ( a * i ) + ( 0 ) ) mod j ) by NAT_D:13
.= ( ( a * i ) mod j );
hence thesis by A3,A5,NAT_D:24;
end;
suppose A8: b < ( 0 );

reconsider a as (Element of ( NAT )) by A7,INT_1:3;
consider b9 being Integer such that A9: b9 = ( ( 0 ) - b );
take a;
reconsider b9 as (Element of ( NAT )) by A8,A9,INT_1:3;
( ( ( a * i ) + ( b * j ) ) + ( b9 * j ) ) = ( a * i ) by A9;
then ( ( a * i ) mod j ) = ( k mod j ) by A5,NAT_D:21
.= k by A3,NAT_D:24;
hence thesis;
end;
end;
hence thesis;
end;
suppose A10: a < ( 0 );

consider a1 being Integer such that A11: a1 = ( ( 0 ) - a );
reconsider a1 as (Element of ( NAT )) by A10,A11,INT_1:3;
consider a2 being (Element of ( NAT )) such that A12: a2 = ( ( a1 div j ) + 1 );
consider a9 being Integer such that A13: a9 = ( a + ( a2 * j ) );
A14: a9 = ( ( ( - a1 ) + ( ( a1 div j ) * j ) ) + j ) by A11,A12,A13;
consider t being Nat such that A15: a1 = ( ( j * ( a1 div j ) ) + t ) and A16: t < j by A6,NAT_D:def 1;
( ( - t ) + t ) < ( ( - t ) + j ) by A16,XREAL_1:6;
then reconsider a9 as (Element of ( NAT )) by A14,A15,INT_1:3;
now
per cases ;
suppose b >= ( 0 );

then reconsider b as (Element of ( NAT )) by INT_1:3;
take a9;
A17: ( ( k + ( ( a2 * j ) * i ) ) mod j ) = ( ( k + ( ( a2 * i ) * j ) ) mod j )
.= ( k mod j ) by NAT_D:21
.= k by A3,NAT_D:24;
( ( ( a * i ) + ( b * j ) ) + ( ( a2 * j ) * i ) ) = ( ( a9 * i ) + ( b * j ) ) by A13;
hence ( ( a9 * i ) mod j ) = k by A5,A17,NAT_D:21;
end;
suppose A18: b < ( 0 );

take a9;
consider b9 being Integer such that A19: b9 = ( ( 0 ) - b );
reconsider b9 as (Element of ( NAT )) by A18,A19,INT_1:3;
( ( k + ( ( a2 * j ) * i ) ) + ( b9 * j ) ) = ( k + ( ( ( a2 * i ) + b9 ) * j ) );
hence ( ( a9 * i ) mod j ) = ( k mod j ) by A5,A13,A19,NAT_D:21
.= k by A3,NAT_D:24;
end;
end;
hence thesis;
end;
end;
hence thesis;
end;
