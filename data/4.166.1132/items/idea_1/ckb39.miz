environ
vocabularies NUMBERS,SUBSET_1,FINSEQ_2,MARGREL1,CARD_1,ARYTM_3,INT_2,NAT_1,RELAT_1,XXREAL_0,INT_1,ARYTM_1,GRCAT_1,XBOOLEAN,FINSEQ_1,PARTFUN1,FUNCT_1,POWER,BINARI_3,FUNCOP_1,XBOOLE_0,BINARITH,MATRIX_1,INCSP_1,ORDINAL4,FUNCT_7,FUNCT_2,TARSKI,TREES_1,IDEA_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,INT_1,INT_2,NAT_1,NAT_D,MARGREL1,RELAT_1,FUNCT_1,FUNCOP_1,MATRIX_1,PARTFUN1,FUNCT_2,FUNCT_7,SERIES_1,FINSEQ_1,FINSEQ_2,RECDEF_1,BINARITH,BINARI_3,XXREAL_0,CKB8,CKB9,CKB12,CKB15,CKB17,CKB18,CKB19,CKB26,CKB29,CKB32,CKB33;
definitions TARSKI,FINSEQ_2,XBOOLEAN,CKB8,CKB9,CKB15,CKB17,CKB18,CKB19,CKB26,CKB29,CKB32,CKB33;
theorems NAT_1,NAT_2,NEWTON,INT_1,INT_2,FINSEQ_1,FINSEQ_2,FUNCT_1,FUNCT_2,FUNCT_7,FUNCOP_1,POWER,EULER_1,EULER_2,BINARITH,BINARI_3,MATRIX_1,RELSET_1,RELAT_1,XBOOLE_1,XREAL_1,XXREAL_0,XBOOLEAN,NAT_D,PARTFUN1,ORDINAL1,XREAL_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38;
schemes FINSEQ_1,FINSEQ_2,NAT_1,FUNCT_2;
registrations XBOOLE_0,RELAT_1,FUNCT_1,ORDINAL1,FUNCT_2,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,MARGREL1,FUNCT_7,VALUED_0,CARD_1,FINSEQ_2,RELSET_1;
constructors PARTFUN1,XXREAL_0,NAT_1,NAT_D,SERIES_1,BINARITH,WSIERP_1,FUNCT_7,MATRIX_1,BINARI_3,RECDEF_1,RELSET_1,CKB8,CKB9,CKB12,CKB15,CKB17,CKB18,CKB19,CKB26,CKB29,CKB32,CKB33;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve i for (Element of ( NAT ));
reserve n for (Element of ( NAT ));
definition
let n;
let m being (FinSequence of ( NAT ));
let k being (FinSequence of ( NAT ));
func IDEAoperationA (m,k,n) -> (FinSequence of ( NAT ))
means
:Def11: (( len it ) = ( len m ) & (for i being (Element of ( NAT )) holds (i in ( dom m ) implies (((((i = 1 implies ( it . i ) = ( MUL_MOD (( m . 1 ),( k . 1 ),n) )) & (i = 2 implies ( it . i ) = ( ADD_MOD (( m . 2 ),( k . 2 ),n) ))) & (i = 3 implies ( it . i ) = ( ADD_MOD (( m . 3 ),( k . 3 ),n) ))) & (i = 4 implies ( it . i ) = ( MUL_MOD (( m . 4 ),( k . 4 ),n) ))) & ((((i <> 1 & i <> 2) & i <> 3) & i <> 4) implies ( it . i ) = ( m . i ))))));
existence
proof
defpred P[ set,set ]
 means
((((($1 = 1 implies $2 = ( MUL_MOD (( m . 1 ),( k . 1 ),n) )) & ($1 = 2 implies $2 = ( ADD_MOD (( m . 2 ),( k . 2 ),n) ))) & ($1 = 3 implies $2 = ( ADD_MOD (( m . 3 ),( k . 3 ),n) ))) & ($1 = 4 implies $2 = ( MUL_MOD (( m . 4 ),( k . 4 ),n) ))) & (((($1 <> 1 & $1 <> 2) & $1 <> 3) & $1 <> 4) implies $2 = ( m . $1 )));
A1: (for j being Nat holds (j in ( Seg ( len m ) ) implies (ex x being (Element of ( NAT )) st P[ j,x ])))
proof
let j being Nat;
assume j in ( Seg ( len m ) );
then reconsider j as (Element of ( NAT ));
per cases ;
suppose A2: j = 1;

take ( MUL_MOD (( m . 1 ),( k . 1 ),n) );
thus thesis by A2;
end;
suppose A3: j = 2;

take ( ADD_MOD (( m . 2 ),( k . 2 ),n) );
thus thesis by A3;
end;
suppose A4: j = 3;

take ( ADD_MOD (( m . 3 ),( k . 3 ),n) );
thus thesis by A4;
end;
suppose A5: j = 4;

take ( MUL_MOD (( m . 4 ),( k . 4 ),n) );
thus thesis by A5;
end;
suppose A6: (((j <> 1 & j <> 2) & j <> 3) & j <> 4);

take ( m . j );
thus thesis by A6;
end;
end;
consider z being (FinSequence of ( NAT )) such that A7: (( dom z ) = ( Seg ( len m ) ) & (for i being Nat holds (i in ( Seg ( len m ) ) implies P[ i,( z . i ) ]))) from FINSEQ_1:sch 5(A1);
take z;
( dom m ) = ( Seg ( len m ) ) by FINSEQ_1:def 3;
hence thesis by A7,FINSEQ_1:def 3;
end;
uniqueness
proof
let z1 being (FinSequence of ( NAT )),z2 being (FinSequence of ( NAT ));
assume that
A8: ( len z1 ) = ( len m )
and
A9: (for i being (Element of ( NAT )) holds (i in ( dom m ) implies (((((i = 1 implies ( z1 . i ) = ( MUL_MOD (( m . 1 ),( k . 1 ),n) )) & (i = 2 implies ( z1 . i ) = ( ADD_MOD (( m . 2 ),( k . 2 ),n) ))) & (i = 3 implies ( z1 . i ) = ( ADD_MOD (( m . 3 ),( k . 3 ),n) ))) & (i = 4 implies ( z1 . i ) = ( MUL_MOD (( m . 4 ),( k . 4 ),n) ))) & ((((i <> 1 & i <> 2) & i <> 3) & i <> 4) implies ( z1 . i ) = ( m . i )))))
and
A10: ( len z2 ) = ( len m )
and
A11: (for i holds (i in ( dom m ) implies (((((i = 1 implies ( z2 . i ) = ( MUL_MOD (( m . 1 ),( k . 1 ),n) )) & (i = 2 implies ( z2 . i ) = ( ADD_MOD (( m . 2 ),( k . 2 ),n) ))) & (i = 3 implies ( z2 . i ) = ( ADD_MOD (( m . 3 ),( k . 3 ),n) ))) & (i = 4 implies ( z2 . i ) = ( MUL_MOD (( m . 4 ),( k . 4 ),n) ))) & ((((i <> 1 & i <> 2) & i <> 3) & i <> 4) implies ( z2 . i ) = ( m . i )))));
A12: ( dom m ) = ( Seg ( len z2 ) ) by A10,FINSEQ_1:def 3
.= ( dom z2 ) by FINSEQ_1:def 3;
A13:now
let j being Nat;
assume A14: j in ( dom m );
now
per cases ;
suppose A15: j = 1;

hence ( z1 . j ) = ( MUL_MOD (( m . 1 ),( k . 1 ),n) ) by A9,A14
.= ( z2 . j ) by A11,A14,A15;
end;
suppose A16: j = 2;

hence ( z1 . j ) = ( ADD_MOD (( m . 2 ),( k . 2 ),n) ) by A9,A14
.= ( z2 . j ) by A11,A14,A16;
end;
suppose A17: j = 3;

hence ( z1 . j ) = ( ADD_MOD (( m . 3 ),( k . 3 ),n) ) by A9,A14
.= ( z2 . j ) by A11,A14,A17;
end;
suppose A18: j = 4;

hence ( z1 . j ) = ( MUL_MOD (( m . 4 ),( k . 4 ),n) ) by A9,A14
.= ( z2 . j ) by A11,A14,A18;
end;
suppose A19: (((j <> 1 & j <> 2) & j <> 3) & j <> 4);

hence ( z1 . j ) = ( m . j ) by A9,A14
.= ( z2 . j ) by A11,A14,A19;
end;
end;
hence ( z1 . j ) = ( z2 . j );
end;
( dom m ) = ( Seg ( len z1 ) ) by A8,FINSEQ_1:def 3
.= ( dom z1 ) by FINSEQ_1:def 3;
hence thesis by A12,A13,FINSEQ_1:13;
end;
end;
