environ
vocabularies NUMBERS,SUBSET_1,FINSEQ_2,MARGREL1,CARD_1,ARYTM_3,INT_2,NAT_1,RELAT_1,XXREAL_0,INT_1,ARYTM_1,GRCAT_1,XBOOLEAN,FINSEQ_1,PARTFUN1,FUNCT_1,POWER,BINARI_3,FUNCOP_1,XBOOLE_0,BINARITH,MATRIX_1,INCSP_1,ORDINAL4,FUNCT_7,FUNCT_2,TARSKI,TREES_1,IDEA_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,INT_1,INT_2,NAT_1,NAT_D,MARGREL1,RELAT_1,FUNCT_1,FUNCOP_1,MATRIX_1,PARTFUN1,FUNCT_2,FUNCT_7,SERIES_1,FINSEQ_1,FINSEQ_2,RECDEF_1,BINARITH,BINARI_3,XXREAL_0,CKB8,CKB9,CKB12,CKB15,CKB17,CKB18,CKB19,CKB26,CKB29,CKB32;
definitions TARSKI,FINSEQ_2,XBOOLEAN,CKB8,CKB9,CKB15,CKB17,CKB18,CKB19,CKB26,CKB29,CKB32;
theorems NAT_1,NAT_2,NEWTON,INT_1,INT_2,FINSEQ_1,FINSEQ_2,FUNCT_1,FUNCT_2,FUNCT_7,FUNCOP_1,POWER,EULER_1,EULER_2,BINARITH,BINARI_3,MATRIX_1,RELSET_1,RELAT_1,XBOOLE_1,XREAL_1,XXREAL_0,XBOOLEAN,NAT_D,PARTFUN1,ORDINAL1,XREAL_0,CARD_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32;
schemes FINSEQ_1,FINSEQ_2,NAT_1,FUNCT_2;
registrations XBOOLE_0,RELAT_1,FUNCT_1,ORDINAL1,FUNCT_2,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,MARGREL1,FUNCT_7,VALUED_0,CARD_1,FINSEQ_2,RELSET_1;
constructors PARTFUN1,XXREAL_0,NAT_1,NAT_D,SERIES_1,BINARITH,WSIERP_1,FUNCT_7,MATRIX_1,BINARI_3,RECDEF_1,RELSET_1,CKB8,CKB9,CKB12,CKB15,CKB17,CKB18,CKB19,CKB26,CKB29,CKB32;
requirements REAL,NUMERALS,SUBSET,BOOLE,ARITHM;
begin
reserve j for (Element of ( NAT ));
definition
let n being non empty (Element of ( NAT ));
let i being (Element of ( NAT ));
assume that
A1: i is_expressible_by n
and
A2: ( ( 2 to_power n ) + 1 ) is  prime;
func INV_MOD (i,n) -> (Element of ( NAT ))
means
:Def10: (( MUL_MOD (i,it,n) ) = 1 & it is_expressible_by n);
existence
proof
A3: ( 2 to_power n ) > ( 0 ) by POWER:34;
then A4: ( ( 2 to_power n ) + 1 ) > ( ( 0 ) + 1 ) by XREAL_1:6;
then ( ( ( 2 to_power n ) + 1 ) - 1 ) >= ( ( 1 + 1 ) - 1 ) by NAT_1:13;
then ( ( ( ( 2 to_power n ) + 1 ) - 1 ) - 1 ) >= ( ( ( 1 + 1 ) - 1 ) - 1 ) by XREAL_1:9;
then reconsider n3 = ( ( ( ( 2 to_power n ) + 1 ) - 1 ) - 1 ) as (Element of ( NAT )) by INT_1:3;
reconsider nn = ( ( 2 to_power n ) + 1 ) as (Element of ( NAT ));
reconsider n2 = ( ( ( 2 to_power n ) + 1 ) - 1 ) as (Element of ( NAT ));
A5: ( 2 to_power n ) <> 1 by POWER:35;
( n2 * n2 ) = ( ( nn * n3 ) + 1 );
then A6: ( ( n2 * n2 ) mod nn ) = ( 1 mod nn ) by NAT_D:21
.= 1 by A4,NAT_D:24;
now
per cases ;
suppose A7: i = ( 0 );

consider j such that A8: j = ( 0 );
take j;
A9: j is_expressible_by n by A3,A8,CKB15:def 1;
( MUL_MOD (i,j,n) ) = ( ChangeVal_2 (( ( ( 2 to_power n ) * ( ChangeVal_1 (( 0 ),n) ) ) mod nn ),n) ) by A7,A8,CKB26:def 1
.= ( ChangeVal_2 (( ( n2 * n2 ) mod nn ),n) ) by CKB26:def 1
.= 1 by A5,A6,CKB29:def 1;
hence thesis by A9;
end;
suppose A10: i <> ( 0 );

i < ( 2 to_power n ) by A1,CKB15:def 1;
then i < ( ( 2 to_power n ) + 1 ) by NAT_1:13;
then consider a being (Element of ( NAT )) such that A11: ( ( a * i ) mod ( ( 2 to_power n ) + 1 ) ) = 1 and A12: a < ( ( 2 to_power n ) + 1 ) by A2,A4,A10,CKB3:1;
take k = ( ChangeVal_2 (a,n) );
A13: a <> ( 0 ) by A11,NAT_D:24;
now
per cases ;
suppose A14: a <> ( 2 to_power n );

then A15: k = a by CKB29:def 1;
then k <= ( 2 to_power n ) by A12,NAT_1:13;
then k < ( 2 to_power n ) by A14,A15,XXREAL_0:1;
then A16: k is_expressible_by n by CKB15:def 1;
( MUL_MOD (i,k,n) ) = ( ChangeVal_2 (( ( i * ( ChangeVal_1 (k,n) ) ) mod ( ( 2 to_power n ) + 1 ) ),n) ) by A10,CKB26:def 1
.= ( ChangeVal_2 (( ( i * a ) mod ( ( 2 to_power n ) + 1 ) ),n) ) by A13,A15,CKB26:def 1
.= 1 by A5,A11,CKB29:def 1;
hence thesis by A16;
end;
suppose A17: a = ( 2 to_power n );

then A18: k = ( 0 ) by CKB29:def 1;
then A19: k is_expressible_by n by A3,CKB15:def 1;
( MUL_MOD (i,k,n) ) = ( ChangeVal_2 (( ( i * ( ChangeVal_1 (k,n) ) ) mod ( ( 2 to_power n ) + 1 ) ),n) ) by A10,CKB26:def 1
.= ( ChangeVal_2 (( ( i * a ) mod ( ( 2 to_power n ) + 1 ) ),n) ) by A17,A18,CKB26:def 1
.= 1 by A5,A11,CKB29:def 1;
hence thesis by A19;
end;
end;
hence thesis;
end;
end;
hence thesis;
end;
uniqueness
proof
let a1 being (Element of ( NAT )),a2 being (Element of ( NAT ));
assume that
A20: ( MUL_MOD (i,a1,n) ) = 1
and
A21: a1 is_expressible_by n
and
A22: ( MUL_MOD (i,a2,n) ) = 1
and
A23: a2 is_expressible_by n;
consider b2 being (Element of ( NAT )) such that A24: b2 = ( ChangeVal_1 (a2,n) );
b2 <= ( 2 to_power n ) by A23,A24,CKB27:1;
then A25: b2 < ( ( 2 to_power n ) + 1 ) by NAT_1:13;
consider b1 being (Element of ( NAT )) such that A26: b1 = ( ChangeVal_1 (a1,n) );
b1 <= ( 2 to_power n ) by A21,A26,CKB27:1;
then A27: b1 < ( ( 2 to_power n ) + 1 ) by NAT_1:13;
consider k being (Element of ( NAT )) such that A28: k = ( ChangeVal_1 (i,n) );
A29: k <= ( 2 to_power n ) by A1,A28,CKB27:1;
then A30: k < ( ( 2 to_power n ) + 1 ) by NAT_1:13;
A31: k > ( 0 ) by A1,A28,CKB27:1;
b2 > ( 0 ) by A23,A24,CKB27:1;
then A32: ( ( k * b2 ) mod ( ( 2 to_power n ) + 1 ) ) <> ( 0 ) by A2,A31,A30,A25,CKB7:1;
b1 > ( 0 ) by A21,A26,CKB27:1;
then ( ( k * b1 ) mod ( ( 2 to_power n ) + 1 ) ) <> ( 0 ) by A2,A31,A30,A27,CKB7:1;
then A33: ( ( k * b1 ) mod ( ( 2 to_power n ) + 1 ) ) = ( ( k * b2 ) mod ( ( 2 to_power n ) + 1 ) ) by A20,A22,A28,A26,A24,A32,CKB31:1;
now
per cases ;
suppose A34: b1 <= b2;

consider b being Integer such that A35: b = ( b2 - b1 );
( b1 - b1 ) <= ( b2 - b1 ) by A34,XREAL_1:9;
then reconsider b as (Element of ( NAT )) by A35,INT_1:3;
(ex t being (Element of ( NAT )) st ( ( k * b2 ) - ( k * b1 ) ) = ( ( ( 2 to_power n ) + 1 ) * t )) by A33,A34,CKB4:1,NAT_1:4;
then ( ( 2 to_power n ) + 1 ) divides ( k * b ) by A35,NAT_D:def 3;
then A36: (( ( 2 to_power n ) + 1 ) divides k or ( ( 2 to_power n ) + 1 ) divides b) by A2,NEWTON:80;
b <= ( 2 to_power n ) by A23,A24,A35,CKB6:1,CKB27:1;
then A37: (not ( ( 2 to_power n ) + 1 ) <= b) by NAT_1:13;
(not ( ( 2 to_power n ) + 1 ) <= k) by A29,NAT_1:13;
then (not ( 0 ) < b) by A31,A36,A37,NAT_D:7;
then ( ( b2 - b1 ) + b1 ) = ( ( 0 ) + b1 ) by A35;
hence b1 = b2;
end;
suppose A38: b2 <= b1;

consider b being Integer such that A39: b = ( b1 - b2 );
( b2 - b2 ) <= ( b1 - b2 ) by A38,XREAL_1:9;
then reconsider b as (Element of ( NAT )) by A39,INT_1:3;
(ex t being (Element of ( NAT )) st ( ( k * b1 ) - ( k * b2 ) ) = ( ( ( 2 to_power n ) + 1 ) * t )) by A33,A38,CKB4:1,NAT_1:4;
then ( ( 2 to_power n ) + 1 ) divides ( k * b ) by A39,NAT_D:def 3;
then A40: (( ( 2 to_power n ) + 1 ) divides k or ( ( 2 to_power n ) + 1 ) divides b) by A2,NEWTON:80;
b <= ( 2 to_power n ) by A21,A26,A39,CKB6:1,CKB27:1;
then A41: (not ( ( 2 to_power n ) + 1 ) <= b) by NAT_1:13;
(not ( ( 2 to_power n ) + 1 ) <= k) by A29,NAT_1:13;
then (not ( 0 ) < b) by A31,A40,A41,NAT_D:7;
then ( ( b1 - b2 ) + b2 ) = ( ( 0 ) + b2 ) by A39;
hence b2 = b1;
end;
end;
hence thesis by A21,A23,A26,A24,CKB28:1;
end;
end;
