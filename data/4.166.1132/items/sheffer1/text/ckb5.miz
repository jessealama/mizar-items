environ
vocabularies LATTICES,ROBBINS1,XBOOLE_0,SUBSET_1,ARYTM_3,EQREL_1,ZFMISC_1,PBOOLE,STRUCT_0,BINOP_1,FUNCT_5,RELAT_1,FUNCT_1,SHEFFER1,CARD_1;
notations TARSKI,XBOOLE_0,FUNCT_5,CARD_1,STRUCT_0,LATTICES,BINOP_1,ROBBINS1,CKB2,CKB3,CKB4;
definitions LATTICES,ROBBINS1,STRUCT_0,CKB2,CKB3,CKB4;
theorems STRUCT_0,ROBBINS1,LATTICES,CARD_1,CKB1,CKB2,CKB3,CKB4;
registrations LATTICES,LATTICE6,ROBBINS1,XBOOLE_0,ZFMISC_1,CARD_1,ORDINAL1,STRUCT_0;
constructors BINOP_1,ROBBINS1,FUNCT_5,CKB2,CKB3,CKB4;
requirements SUBSET,NUMERALS;
begin
definition
let L being non  empty LattStr;
assume A1: L is  lower-bounded';
func Bot' L -> (Element of L) means 
:Def4: (for a being (Element of L) holds (( it "\/" a ) = a & ( a "\/" it ) = a));
existence by A1,CKB4:def 1;
uniqueness
proof
let c1 being (Element of L);
let c2 being (Element of L);
assume that
A2: (for a being (Element of L) holds (( c1 "\/" a ) = a & ( a "\/" c1 ) = a))
and
A3: (for a being (Element of L) holds (( c2 "\/" a ) = a & ( a "\/" c2 ) = a));
thus c1 = ( c2 "\/" c1 ) by A3
.= c2 by A2;
end;
end;
