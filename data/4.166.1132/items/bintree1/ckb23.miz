environ
vocabularies NUMBERS,XBOOLE_0,TREES_2,SUBSET_1,FUNCT_1,TREES_4,TREES_3,FINSEQ_1,TREES_1,ORDINAL1,ORDINAL4,CARD_1,XXREAL_0,ARYTM_3,FINSET_1,RELAT_1,TARSKI,TREES_A,LANG1,TDGROUP,DTCONSTR,STRUCT_0,ZFMISC_1,FUNCT_2,BINTREE1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,NAT_1,RELAT_1,STRUCT_0,MCART_1,FUNCT_1,RELSET_1,FUNCT_2,FINSEQ_1,FINSET_1,LANG1,TREES_1,TREES_2,TREES_3,TREES_4,DTCONSTR,PRE_POLY,XXREAL_0,CKB1,CKB4,CKB11,CKB20;
definitions DTCONSTR,CKB1,CKB4,CKB11,CKB20;
theorems TARSKI,NAT_1,MCART_1,ZFMISC_1,ENUMSET1,MODAL_1,RELSET_1,FUNCT_1,FUNCT_2,FINSEQ_1,FINSEQ_2,FINSEQ_3,LANG1,TREES_1,TREES_2,TREES_3,TREES_4,DTCONSTR,FINSET_1,RELAT_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB8,CKB9,CKB11,CKB15,CKB16,CKB17,CKB18,CKB20;
schemes FUNCT_2,DTCONSTR,MULTOP_1,CKB22;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,MEMBERED,FINSEQ_1,TREES_2,TREES_3,STRUCT_0,DTCONSTR,FINSET_1,PRE_POLY,TREES_4,TREES_1,RELSET_1,CKB6,CKB7,CKB10,CKB12,CKB13,CKB14,CKB19,CKB21;
constructors DOMAIN_1,XXREAL_0,NAT_1,MEMBERED,FINSEQOP,DTCONSTR,RELSET_1,PRE_POLY,CKB1,CKB4,CKB11,CKB20;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
theorem
Th12: (for G being  binary  with_terminals  with_nonterminals non empty DTConstrStr holds (for ts being (FinSequence of ( TS G )) holds (for nt being (Symbol of G) holds (nt ==> ( roots ts ) implies ((((nt is (NonTerminal of G) & ( dom ts ) = { 1,2 }) & 1 in ( dom ts )) & 2 in ( dom ts )) & (ex tl,tr being (Element of ( TS G )) st (((((( roots ts ) = <* ( root-label tl ),( root-label tr ) *> & tl = ( ts . 1 )) & tr = ( ts . 2 )) & ( nt -tree ts ) = ( nt -tree (tl,tr) )) & tl in ( rng ts )) & tr in ( rng ts ))))))))
proof
let G being  binary  with_terminals  with_nonterminals non empty DTConstrStr;
let ts being (FinSequence of ( TS G ));
let nt being (Symbol of G);
assume A1: nt ==> ( roots ts );
then consider rtl being (Symbol of G),rtr being (Symbol of G) such that A2: ( roots ts ) = <* rtl,rtr *> by CKB20:def 1;
nt in { s where s is (Symbol of G): (ex rts being FinSequence st s ==> rts) } by A1;
hence nt is (NonTerminal of G) by LANG1:def 3;
A3: ( len <* rtl,rtr *> ) = 2 by FINSEQ_1:44;
A4: ( dom <* rtl,rtr *> ) = ( dom ts ) by A2,TREES_3:def 18;
hence ( dom ts ) = { 1,2 } by A3,FINSEQ_1:2,FINSEQ_1:def 3;
hence A5: (1 in ( dom ts ) & 2 in ( dom ts )) by TARSKI:def 2;
then consider tl being DecoratedTree such that A6: tl = ( ts . 1 ) and A7: ( <* rtl,rtr *> . 1 ) = ( tl . ( {} ) ) by A2,TREES_3:def 18;
A8: (( rng ts ) c= ( TS G ) & tl in ( rng ts )) by A5,A6,FINSEQ_1:def 4,FUNCT_1:def 3;
consider tr being DecoratedTree such that A9: tr = ( ts . 2 ) and A10: ( <* rtl,rtr *> . 2 ) = ( tr . ( {} ) ) by A2,A5,TREES_3:def 18;
tr in ( rng ts ) by A5,A9,FUNCT_1:def 3;
then reconsider tl,tr as (Element of ( TS G )) by A8;
take tl;
take tr;
( <* rtl,rtr *> . 1 ) = rtl by FINSEQ_1:44;
hence ( roots ts ) = <* ( root-label tl ),( root-label tr ) *> by A2,A7,A10,FINSEQ_1:44;
( Seg ( len <* rtl,rtr *> ) ) = ( dom <* rtl,rtr *> ) by FINSEQ_1:def 3
.= ( Seg ( len ts ) ) by A4,FINSEQ_1:def 3;
then ( len ts ) = 2 by A3,FINSEQ_1:6;
then ts = <* tl,tr *> by A6,A9,FINSEQ_1:44;
hence ((tl = ( ts . 1 ) & tr = ( ts . 2 )) & ( nt -tree ts ) = ( nt -tree (tl,tr) )) by A6,A9,TREES_4:def 6;
thus thesis by A5,A6,A9,FUNCT_1:def 3;
end;
