environ
vocabularies NUMBERS,XBOOLE_0,TREES_2,SUBSET_1,FUNCT_1,TREES_4,TREES_3,FINSEQ_1,TREES_1,ORDINAL1,ORDINAL4,CARD_1,XXREAL_0,ARYTM_3,FINSET_1,RELAT_1,TARSKI,TREES_A,LANG1,TDGROUP,DTCONSTR,STRUCT_0,ZFMISC_1,FUNCT_2,BINTREE1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,NAT_1,RELAT_1,STRUCT_0,MCART_1,FUNCT_1,RELSET_1,FUNCT_2,FINSEQ_1,FINSET_1,LANG1,TREES_1,TREES_2,TREES_3,TREES_4,DTCONSTR,PRE_POLY,XXREAL_0,CKB1,CKB4,CKB11,CKB20;
definitions DTCONSTR,CKB1,CKB4,CKB11,CKB20;
theorems TARSKI,NAT_1,MCART_1,ZFMISC_1,ENUMSET1,MODAL_1,RELSET_1,FUNCT_1,FUNCT_2,FINSEQ_1,FINSEQ_2,FINSEQ_3,LANG1,TREES_1,TREES_2,TREES_3,TREES_4,DTCONSTR,FINSET_1,RELAT_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB8,CKB9,CKB11,CKB15,CKB16,CKB17,CKB18,CKB20,CKB23;
schemes FUNCT_2,DTCONSTR,MULTOP_1,CKB22,CKB24;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,MEMBERED,FINSEQ_1,TREES_2,TREES_3,STRUCT_0,DTCONSTR,FINSET_1,PRE_POLY,TREES_4,TREES_1,RELSET_1,CKB6,CKB7,CKB10,CKB12,CKB13,CKB14,CKB19,CKB21;
constructors DOMAIN_1,XXREAL_0,NAT_1,MEMBERED,FINSEQOP,DTCONSTR,RELSET_1,PRE_POLY,CKB1,CKB4,CKB11,CKB20;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
scheme BinDTConstrIndDef { G() ->  binary  with_terminals  with_nonterminals  with_useful_nonterminals non  empty DTConstrStr,D() -> non  empty set,TermVal(set) -> (Element of D()),NTermVal(set,set,set,set,set) -> (Element of D()) } : (ex f being (Function of ( TS G() ),D()) st ((for t being (Terminal of G()) holds ( f . ( root-tree t ) ) = TermVal(t)) & (for nt being (NonTerminal of G()) holds (for tl,tr being (Element of ( TS G() )) holds (for rtl,rtr being (Symbol of G()) holds (((rtl = ( root-label tl ) & rtr = ( root-label tr )) & nt ==> <* rtl,rtr *>) implies (for xl,xr being (Element of D()) holds ((xl = ( f . tl ) & xr = ( f . tr )) implies ( f . ( nt -tree (tl,tr) ) ) = NTermVal(nt,rtl,rtr,xl,xr)))))))))
proof
deffunc BNTV((Symbol of G()),FinSequence,(FinSequence of D())) = NTermVal($1,( $2 . 1 ),( $2 . 2 ),( $3 . 1 ),( $3 . 2 ));
consider f being (Function of ( TS G() ),D()) such that A1: (for t being (Symbol of G()) holds (t in ( Terminals G() ) implies ( f . ( root-tree t ) ) = TermVal(t))) and A2: (for nt being (Symbol of G()) holds (for ts being (FinSequence of ( TS G() )) holds (nt ==> ( roots ts ) implies ( f . ( nt -tree ts ) ) = BNTV(nt,( roots ts ),( f * ts ))))) from DTCONSTR:sch 8;
take f;
thus (for t being (Terminal of G()) holds ( f . ( root-tree t ) ) = TermVal(t)) by A1;
let nt being (NonTerminal of G());
let tl being (Element of ( TS G() ));
let tr being (Element of ( TS G() ));
let rtl being (Symbol of G());
let rtr being (Symbol of G());
assume that
A3: rtl = ( root-label tl )
and
A4: rtr = ( root-label tr )
and
A5: nt ==> <* rtl,rtr *>;
reconsider rts = <* rtl,rtr *> as FinSequence;
reconsider ts = <* tl,tr *> as (FinSequence of ( TS G() ));
A6: ( ts . 1 ) = tl by FINSEQ_1:44;
let xl being (Element of D());
let xr being (Element of D());
A7: ( dom ts ) = { 1,2 } by FINSEQ_1:2,FINSEQ_1:89;
reconsider x = <* xl,xr *> as (FinSequence of D());
A8: ( dom x ) = { 1,2 } by FINSEQ_1:2,FINSEQ_1:89;
A9: ( ts . 2 ) = tr by FINSEQ_1:44;
A10: ( dom f ) = ( TS G() ) by FUNCT_2:def 1;
A11:now
let y being set;
A12:now
assume that
A13: y in ( dom ts )
and
( ts . y ) in ( dom f );
per cases  by A7,A13,TARSKI:def 2;
suppose y = 1;

hence y in ( dom x ) by A8,TARSKI:def 2;
end;
suppose y = 2;

hence y in ( dom x ) by A8,TARSKI:def 2;
end;
end;
now
assume A14: y in ( dom x );
per cases  by A8,A14,TARSKI:def 2;
suppose y = 1;

hence (y in ( dom ts ) & ( ts . y ) in ( dom f )) by A10,A6,A7,TARSKI:def 2;
end;
suppose y = 2;

hence (y in ( dom ts ) & ( ts . y ) in ( dom f )) by A10,A9,A7,TARSKI:def 2;
end;
end;
hence (y in ( dom x ) iff (y in ( dom ts ) & ( ts . y ) in ( dom f ))) by A12;
end;
assume A15: (xl = ( f . tl ) & xr = ( f . tr ));
now
let y being set;
assume y in ( dom x );
then (y = 1 or y = 2) by A8,TARSKI:def 2;
hence ( x . y ) = ( f . ( ts . y ) ) by A15,A6,A9,FINSEQ_1:44;
end;
then A16: x = ( f * ts ) by A11,FUNCT_1:10;
A17: ( rts . 2 ) = rtr by FINSEQ_1:44;
A18: ( rts . 1 ) = rtl by FINSEQ_1:44;
A19:now
let i being (Element of ( NAT ));
assume i in ( dom ts );
then i in ( Seg ( len ts ) ) by FINSEQ_1:def 3;
then A20: i in ( Seg 2 ) by FINSEQ_1:44;
per cases  by A20,FINSEQ_1:2,TARSKI:def 2;
suppose i = 1;

hence (ex T being DecoratedTree st (T = ( ts . i ) & ( rts . i ) = ( T . ( {} ) ))) by A3,A6,A18;
end;
suppose i = 2;

hence (ex T being DecoratedTree st (T = ( ts . i ) & ( rts . i ) = ( T . ( {} ) ))) by A4,A9,A17;
end;
end;
( dom rts ) = { 1,2 } by FINSEQ_1:2,FINSEQ_1:89;
then rts = ( roots ts ) by A7,A19,TREES_3:def 18;
then A21: ( f . ( nt -tree ts ) ) = NTermVal(nt,( rts . 1 ),( rts . 2 ),( x . 1 ),( x . 2 )) by A2,A5,A16;
A22: (( x . 1 ) = xl & ( x . 2 ) = xr) by FINSEQ_1:44;
(( rts . 1 ) = rtl & ( rts . 2 ) = rtr) by FINSEQ_1:44;
hence thesis by A21,A22,TREES_4:def 6;
end;
