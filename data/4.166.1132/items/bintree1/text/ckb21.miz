environ
vocabularies NUMBERS,XBOOLE_0,TREES_2,SUBSET_1,FUNCT_1,TREES_4,TREES_3,FINSEQ_1,TREES_1,ORDINAL1,ORDINAL4,CARD_1,XXREAL_0,ARYTM_3,FINSET_1,RELAT_1,TARSKI,TREES_A,LANG1,TDGROUP,DTCONSTR,STRUCT_0,ZFMISC_1,FUNCT_2,BINTREE1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,NAT_1,RELAT_1,STRUCT_0,MCART_1,FUNCT_1,RELSET_1,FUNCT_2,FINSEQ_1,FINSET_1,LANG1,TREES_1,TREES_2,TREES_3,TREES_4,DTCONSTR,PRE_POLY,XXREAL_0,CKB1,CKB4,CKB11,CKB20;
definitions DTCONSTR,CKB1,CKB4,CKB11,CKB20;
theorems TARSKI,NAT_1,MCART_1,ZFMISC_1,ENUMSET1,MODAL_1,RELSET_1,FUNCT_1,FUNCT_2,FINSEQ_1,FINSEQ_2,FINSEQ_3,LANG1,TREES_1,TREES_2,TREES_3,TREES_4,DTCONSTR,FINSET_1,RELAT_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB8,CKB9,CKB11,CKB15,CKB16,CKB17,CKB18,CKB20;
schemes FUNCT_2,DTCONSTR,MULTOP_1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,MEMBERED,FINSEQ_1,TREES_2,TREES_3,STRUCT_0,DTCONSTR,FINSET_1,PRE_POLY,TREES_4,TREES_1,RELSET_1,CKB6,CKB7,CKB10,CKB12,CKB13,CKB14,CKB19;
constructors DOMAIN_1,XXREAL_0,NAT_1,MEMBERED,FINSEQOP,DTCONSTR,RELSET_1,PRE_POLY,CKB1,CKB4,CKB11,CKB20;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
registration
cluster  binary  with_terminals  with_nonterminals  with_useful_nonterminals  strict for non empty non empty DTConstrStr;
existence
proof
reconsider 01 = { ( 0 ),1 } as non empty set;
reconsider a90 = ( 0 ),a91 = 1 as (Element of 01) by TARSKI:def 2;
reconsider a9119 = ( <* a91 *> ^ <* a91 *> ) as (Element of ( 01 * ));
reconsider P = { [ a90,a9119 ] } as (Relation of 01,( 01 * )) by RELSET_1:3;
take cherry = DTConstrStr (# 01,P #);
reconsider a90,a91 as (Symbol of cherry);
hereby
let s being (Symbol of cherry);
let p being FinSequence;
assume A1: s ==> p;
take x1 = a91;
take x2 = a91;
[ s,p ] in P by A1,LANG1:def 1;
then [ s,p ] = [ ( 0 ),a9119 ] by TARSKI:def 1;
then p = a9119 by ZFMISC_1:27
.= <* 1,1 *> by FINSEQ_1:def 9;
hence p = <* x1,x2 *>;
end;
now
let s being FinSequence;
assume a91 ==> s;
then [ 1,s ] in P by LANG1:def 1;
then [ 1,s ] = [ ( 0 ),a9119 ] by TARSKI:def 1;
hence contradiction by ZFMISC_1:27;
end;
then A2: a91 in { t where t is (Symbol of cherry): (not (ex s being FinSequence st t ==> s)) };
then A3: a91 in ( Terminals cherry ) by LANG1:def 2;
thus ( Terminals cherry ) <> ( {} ) by A2,LANG1:def 2;
[ a90,a9119 ] in P by TARSKI:def 1;
then a90 ==> a9119 by LANG1:def 1;
then a90 in { t where t is (Symbol of cherry): (ex s being FinSequence st t ==> s) };
hence ( NonTerminals cherry ) <> ( {} ) by LANG1:def 3;
A4: { s where s is (Symbol of cherry): (ex p being FinSequence st s ==> p) } = ( NonTerminals cherry ) by LANG1:def 3;
hereby
reconsider X = ( TS cherry ) as non empty set by A3,DTCONSTR:def 1;
let nt being (Symbol of cherry);
reconsider rt1 = ( root-tree a91 ) as (Element of X) by A3,DTCONSTR:def 1;
reconsider q = ( <* rt1 *> ^ <* rt1 *> ) as (FinSequence of ( TS cherry ));
q = <* ( root-tree 1 ),( root-tree 1 ) *> by FINSEQ_1:def 9;
then A5: ( roots q ) = <* ( ( root-tree a91 ) . ( {} ) ),( ( root-tree a91 ) . ( {} ) ) *> by DTCONSTR:6;
assume nt in ( NonTerminals cherry );
then (ex s being (Symbol of cherry) st (nt = s & (ex p being FinSequence st s ==> p))) by A4;
then consider p being FinSequence such that A6: nt ==> p;
take q9 = q;
[ nt,p ] in P by A6,LANG1:def 1;
then A7: [ nt,p ] = [ ( 0 ),a9119 ] by TARSKI:def 1;
(a9119 = <* 1,1 *> & ( ( root-tree 1 ) . ( {} ) ) = 1) by FINSEQ_1:def 9,TREES_4:3;
hence nt ==> ( roots q9 ) by A6,A7,A5,ZFMISC_1:27;
end;
thus thesis;
end;
end;
