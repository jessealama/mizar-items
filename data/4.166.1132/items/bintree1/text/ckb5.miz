environ
vocabularies NUMBERS,XBOOLE_0,TREES_2,SUBSET_1,FUNCT_1,TREES_4,TREES_3,FINSEQ_1,TREES_1,ORDINAL1,ORDINAL4,CARD_1,XXREAL_0,ARYTM_3,FINSET_1,RELAT_1,TARSKI,TREES_A,LANG1,TDGROUP,DTCONSTR,STRUCT_0,ZFMISC_1,FUNCT_2,BINTREE1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,NAT_1,RELAT_1,STRUCT_0,MCART_1,FUNCT_1,RELSET_1,FUNCT_2,FINSEQ_1,FINSET_1,LANG1,TREES_1,TREES_2,TREES_3,TREES_4,DTCONSTR,PRE_POLY,XXREAL_0,CKB1,CKB4;
definitions DTCONSTR,CKB1,CKB4;
theorems TARSKI,NAT_1,MCART_1,ZFMISC_1,ENUMSET1,MODAL_1,RELSET_1,FUNCT_1,FUNCT_2,FINSEQ_1,FINSEQ_2,FINSEQ_3,LANG1,TREES_1,TREES_2,TREES_3,TREES_4,DTCONSTR,FINSET_1,RELAT_1,CKB1,CKB2,CKB3,CKB4;
schemes FUNCT_2,DTCONSTR,MULTOP_1;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,MEMBERED,FINSEQ_1,TREES_2,TREES_3,STRUCT_0,DTCONSTR,FINSET_1,PRE_POLY,TREES_4,TREES_1,RELSET_1;
constructors DOMAIN_1,XXREAL_0,NAT_1,MEMBERED,FINSEQOP,DTCONSTR,RELSET_1,PRE_POLY,CKB1,CKB4;
requirements NUMERALS,REAL,SUBSET,BOOLE,ARITHM;
begin
theorem
(for T being Tree holds (for t being (Element of T) holds (( succ t ) = ( {} ) iff t in ( Leaves T ))))
proof
let T being Tree;
let t being (Element of T);
hereby
assume ( succ t ) = ( {} );
then (not ( t ^ <* ( 0 ) *> ) in { ( t ^ <* n *> ) where n is (Element of ( NAT )): ( t ^ <* n *> ) in T }) by TREES_2:def 5;
then (not ( t ^ <* ( 0 ) *> ) in T);
hence t in ( Leaves T ) by TREES_1:54;
end;
set x = the (Element of ( succ t ));
assume t in ( Leaves T );
then A1: (not ( t ^ <* ( 0 ) *> ) in T) by TREES_1:54;
assume ( succ t ) <> ( {} );
then x in ( succ t );
then x in { ( t ^ <* n *> ) where n is (Element of ( NAT )): ( t ^ <* n *> ) in T } by TREES_2:def 5;
then consider n being (Element of ( NAT )) such that x = ( t ^ <* n *> ) and A2: ( t ^ <* n *> ) in T;
( 0 ) <= n by NAT_1:2;
hence contradiction by A1,A2,TREES_1:def 3;
end;
