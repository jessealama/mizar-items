environ
vocabularies FUNCT_1,RELAT_1,TARSKI,STRUCT_0,SUBSET_1,XBOOLE_0,VECTSP_1,RLVECT_5,FINSET_1,RLVECT_3,LOPBAN_1,ARYTM_3,SUPINF_2,CARD_1,RLSUB_1,FUNCT_2,ARYTM_1,MESFUNC1,VECTSP10,RLVECT_2,FUNCT_4,REALSET1,FUNCOP_1,QC_LANG1,CARD_3,RLSUB_2,FINSEQ_1,VALUED_1,NAT_1,XXREAL_0,PARTFUN1,NUMBERS,PBOOLE,RANKNULL,MSSUBFAM,UNIALG_1;
notations TARSKI,XBOOLE_0,SUBSET_1,DOMAIN_1,RELAT_1,RELSET_1,FUNCT_1,NAT_1,NUMBERS,FUNCOP_1,PARTFUN1,FUNCT_2,FUNCT_4,XCMPLX_0,XXREAL_0,CARD_1,FINSET_1,FINSEQ_1,FINSEQOP,STRUCT_0,RLVECT_1,RLVECT_2,VECTSP_1,FUNCT_7,VECTSP_4,VECTSP_5,VECTSP_6,VECTSP_7,MOD_2,MATRLIN,VECTSP_9,GRCAT_1,LOPBAN_1,CKB9,CKB13,CKB15,CKB16;
definitions TARSKI,RELAT_1,FUNCT_1,FINSEQ_1,VECTSP_4,VECTSP_6,XBOOLE_0,RLVECT_1,STRUCT_0,MOD_2,MATRLIN,FUNCOP_1,LOPBAN_1,FUNCT_2,CKB13,CKB16;
theorems TARSKI,ZFMISC_1,RELAT_1,FINSET_1,FINSEQ_1,FUNCT_1,VECTSP_7,VECTSP_9,CARD_2,XBOOLE_1,FUNCT_2,SUBSET_1,XBOOLE_0,VECTSP_1,RLVECT_1,VECTSP_4,VECTSP_6,STRUCT_0,RLVECT_2,MOD_2,MATRLIN,CARD_1,FUNCOP_1,VECTSP_5,FUNCT_7,FINSEQ_2,FUNCT_4,ENUMSET1,ORDINAL1,PARTFUN1,GRCAT_1,CKB1,CKB2,CKB3,CKB6,CKB7,CKB8,CKB10,CKB11,CKB12,CKB13,CKB14,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28;
schemes CLASSES1;
registrations RELAT_1,FUNCT_1,STRUCT_0,CARD_1,FINSET_1,VECTSP_9,XBOOLE_0,MATRLIN,FUNCOP_1,ORDINAL1,XREAL_0,SUBSET_1,FINSEQ_1,MOD_2,GRCAT_1,RELSET_1,CKB4,CKB5;
constructors NAT_1,FINSEQOP,HAHNBAN,VECTSP_6,VECTSP_7,MOD_2,VECTSP_9,REALSET1,RLVECT_2,WELLORD2,LOPBAN_1,VECTSP_5,FUNCT_7,FUNCT_4,XXREAL_0,MATRLIN,RELSET_1,CKB13,CKB15,CKB16;
requirements BOOLE,SUBSET,NUMERALS,ARITHM;
begin
reserve F for Field;
reserve V for (VectSp of F);
theorem
(for A being (Subset of V) holds (for l being (Linear_Combination of A) holds (for x being (Element of V) holds (for a being (Element of F) holds ( l +* (x,a) ) is (Linear_Combination of ( A \/ { x } ))))))
proof
let A being (Subset of V);
let l being (Linear_Combination of A);
let x being (Element of V);
let a being (Element of F);
set m = ( l +* (x,a) );
A1: ( dom m ) = ( [#] V ) by FUNCT_2:def 1;
( rng m ) c= ( [#] F )
proof
let y being set;
assume y in ( rng m );
then consider x9 being set such that A2: x9 in ( dom m ) and A3: ( m . x9 ) = y by FUNCT_1:def 3;
A4: x9 in ( dom l ) by A1,A2,FUNCT_2:92;
per cases ;
suppose x9 = x;

then ( m . x9 ) = a by A4,FUNCT_7:31;
hence thesis by A3;
end;
suppose A5: x9 <> x;

A6: (( l . x9 ) in ( rng l ) & ( rng l ) c= ( [#] F )) by A4,FUNCT_1:3,FUNCT_2:92;
( m . x9 ) = ( l . x9 ) by A5,FUNCT_7:32;
hence thesis by A3,A6;
end;
end;
then reconsider m as (Element of ( Funcs (( [#] V ),( [#] F )) )) by A1,FUNCT_2:def 2;
set T = ( ( Carrier l ) \/ { x } );
(for v being (Element of V) holds ((not v in T) implies ( m . v ) = ( 0. F )))
proof
let v being (Element of V);
assume that
A7: (not v in T);
(not v in { x }) by A7,XBOOLE_0:def 3;
then v <> x by TARSKI:def 1;
then A8: ( m . v ) = ( l . v ) by FUNCT_7:32;
(not v in ( Carrier l )) by A7,XBOOLE_0:def 3;
hence thesis by A8;
end;
then reconsider m as (Linear_Combination of V) by VECTSP_6:def 1;
A9: ( Carrier m ) c= T
proof
let y being set;
assume y in ( Carrier m );
then consider z being (Element of V) such that A10: y = z and A11: ( m . z ) <> ( 0. F );
per cases ;
suppose A12: z = x;

(x in { x } & { x } c= T) by TARSKI:def 1,XBOOLE_1:7;
hence thesis by A10,A12;
end;
suppose z <> x;

then ( m . z ) = ( l . z ) by FUNCT_7:32;
then A13: z in ( Carrier l ) by A11;
( Carrier l ) c= T by XBOOLE_1:7;
hence thesis by A10,A13;
end;
end;
( Carrier l ) c= A by VECTSP_6:def 4;
then T c= ( A \/ { x } ) by XBOOLE_1:9;
then ( Carrier m ) c= ( A \/ { x } ) by A9,XBOOLE_1:1;
hence thesis by VECTSP_6:def 4;
end;
