environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,ORDINAL1,SETFAM_1,AMI_1,FSM_1,FUNCT_4,FUNCOP_1,RELAT_1,TARSKI,STRUCT_0,FUNCT_1,CARD_3,ZFMISC_1,CIRCUIT2,CAT_1,NAT_1,GLIB_000,XXREAL_0,PARTFUN1,FINSEQ_1,ARYTM_3,CARD_1,GOBOARD5,FUNCT_2,FINSEQ_4,ARYTM_1,FINSET_1,FRECHET,AMISTD_1,SCMNORM,AFINSQ_1,COMPOS_1,AMISTD_2,PBOOLE,SCMFSA6B;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,SETFAM_1,ORDINAL1,CARD_1,XXREAL_0,NUMBERS,XCMPLX_0,NAT_1,MEMBERED,FUNCT_1,RELSET_1,PARTFUN1,MCART_1,VALUED_1,DOMAIN_1,CARD_3,FINSEQ_1,FINSEQ_4,FUNCOP_1,FINSET_1,FUNCT_4,FUNCT_7,AFINSQ_1,PBOOLE,STRUCT_0,GRAPH_2,NAT_D,XXREAL_2,MEMSTR_0,COMPOS_1,EXTPRO_1,FUNCT_2,CKB2,CKB3,CKB4,CKB6,CKB7,CKB10;
definitions TARSKI,STRUCT_0,COMPOS_1,EXTPRO_1,XBOOLE_0,MEMSTR_0,FUNCT_1,FUNCOP_1,NAT_1,RELAT_1,FUNCT_4,NAT_D,AFINSQ_1,VALUED_1,CKB2,CKB3,CKB4,CKB6,CKB7,CKB10;
theorems TARSKI,FINSEQ_4,FINSEQ_1,NAT_1,FUNCT_4,FUNCT_1,FUNCT_2,ENUMSET1,ZFMISC_1,CARD_1,FUNCOP_1,CARD_3,ORDINAL1,MCART_1,FINSEQ_3,INT_1,SETFAM_1,REVROT_1,EXTPRO_1,RELSET_1,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,COMPOS_1,FUNCT_7,PARTFUN1,XREAL_0,NAT_D,PBOOLE,AFINSQ_1,RECDEF_2,MEMSTR_0,GRFUNC_1,PARTFUN2,CKB2,CKB3,CKB4,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12;
schemes NAT_1,FINSEQ_2,FUNCT_2;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCOP_1,FINSET_1,NUMBERS,XREAL_0,NAT_1,MEMBERED,FINSEQ_1,CARD_3,REALSET1,FUNCT_7,STRUCT_0,CARD_1,XXREAL_2,RELSET_1,FUNCT_4,AFINSQ_1,ORDINAL1,ZFMISC_1,SUBSET_1,VALUED_1,COMPOS_1,EXTPRO_1,PBOOLE,PRE_POLY,MEMSTR_0,CKB1,CKB5;
constructors WELLORD2,REAL_1,FINSEQ_4,REALSET1,NAT_D,XXREAL_2,COMPOS_1,EXTPRO_1,RELSET_1,PRE_POLY,GRAPH_2,AFINSQ_1,MCART_1,FUNCT_7,PBOOLE,XXREAL_1,FUNCT_4,MEMSTR_0,CKB2,CKB3,CKB4,CKB6,CKB7,CKB10;
requirements NUMERALS,BOOLE,REAL,SUBSET,ARITHM;
begin
reserve N for  with_non-empty_elements non  empty set;
reserve S for  IC-Ins-separated non  empty AMI-Struct over N;
reserve s for (State of S);
set III = { [ 1,( 0 ),( 0 ) ],[ ( 0 ),( 0 ),( 0 ) ] };
definition
let N being  with_non-empty_elements set;
func STC N ->  strict AMI-Struct over N means 
:Def11: ((((((the carrier of it) = { ( 0 ) } & (the ZeroF of it) = ( 0 )) & (the Instructions of it) = { [ ( 0 ),( 0 ),( 0 ) ],[ 1,( 0 ),( 0 ) ] }) & (the haltF of it) = [ ( 0 ),( 0 ),( 0 ) ]) & (the Object-Kind of it) = ( ( 0 ) .--> ( NAT ) )) & (ex f being (Function of ( product (the Object-Kind of it) ),( product (the Object-Kind of it) )) st ((for s being (Element of ( product (the Object-Kind of it) )) holds ( f . s ) = ( s +* ( ( 0 ) .--> ( succ ( s . ( 0 ) ) ) ) )) & (the Execution of it) = ( ( [ 1,( 0 ),( 0 ) ] .--> f ) +* ( [ ( 0 ),( 0 ),( 0 ) ] .--> ( id ( product (the Object-Kind of it) ) ) ) ))));
existence
proof
set O = { ( 0 ) };
reconsider IC1 = ( 0 ) as (Element of O) by TARSKI:def 1;
A1: ( 0 ) in ( ( NAT ) * ) by FINSEQ_1:49;
( 0 ) in ( ( ( union N ) \/ O ) * ) by FINSEQ_1:49;
then ([ 1,( 0 ),( 0 ) ] in [: ( NAT ),( ( NAT ) * ),( ( ( union N ) \/ O ) * ) :] & [ ( 0 ),( 0 ),( 0 ) ] in [: ( NAT ),( ( NAT ) * ),( ( ( union N ) \/ O ) * ) :]) by A1,MCART_1:69;
then reconsider ins = III as non  empty (Subset of [: ( NAT ),( ( NAT ) * ),( ( ( union N ) \/ O ) * ) :]) by ZFMISC_1:32;
reconsider i = [ ( 0 ),( 0 ),( 0 ) ] as (Element of ins) by TARSKI:def 2;
A2: ( dom ( ( 0 ) .--> ( NAT ) ) ) = O by FUNCOP_1:13;
A3: { ( NAT ) } c= ( N \/ { ( NAT ) } ) by XBOOLE_1:7;
( rng ( ( 0 ) .--> ( NAT ) ) ) c= ( N \/ { ( NAT ) } ) by A3,FUNCOP_1:8;
then reconsider Ok = ( ( 0 ) .--> ( NAT ) ) as (Function of O,( N \/ { ( NAT ) } )) by A2,RELSET_1:4;
deffunc F((Element of ( product Ok ))) = ( $1 +* ( ( 0 ) .--> ( succ ( $1 . ( 0 ) ) ) ) );
A4:now
let s being (Element of ( product Ok ));
now
thus ( dom ( s +* ( ( 0 ) .--> ( succ ( s . ( 0 ) ) ) ) ) ) = ( ( dom s ) \/ ( dom ( ( 0 ) .--> ( succ ( s . ( 0 ) ) ) ) ) ) by FUNCT_4:def 1
.= ( ( dom s ) \/ { ( 0 ) } ) by FUNCOP_1:13
.= ( { ( 0 ) } \/ { ( 0 ) } ) by PARTFUN1:def 2
.= ( dom Ok ) by FUNCOP_1:13;
let o being set;
A5: ( dom ( ( 0 ) .--> ( succ ( s . ( 0 ) ) ) ) ) = { ( 0 ) } by FUNCOP_1:13;
assume Z: o in ( dom Ok );
A8: o = ( 0 ) by Z,TARSKI:def 1;
A10: ( Ok . o ) = ( NAT ) by Z,FUNCOP_1:7;
A12: ( ( s +* ( ( 0 ) .--> ( succ ( s . ( 0 ) ) ) ) ) . o ) = ( ( ( 0 ) .--> ( succ ( s . ( 0 ) ) ) ) . o ) by A5,Z,FUNCT_4:13
.= ( succ ( s . ( 0 ) ) ) by Z,FUNCOP_1:7;
( 0 ) in ( dom Ok ) by A2,TARSKI:def 1;
then reconsider k = ( s . ( 0 ) ) as (Element of ( NAT )) by A8,A10,CARD_3:9;
( succ k ) in ( NAT );
hence ( ( s +* ( ( 0 ) .--> ( succ ( s . ( 0 ) ) ) ) ) . o ) in ( Ok . o ) by Z,FUNCOP_1:7,A12;
end;
hence F(s) in ( product Ok ) by CARD_3:9;
end;
consider f being (Function of ( product Ok ),( product Ok )) such that A13: (for s being (Element of ( product Ok )) holds ( f . s ) = F(s)) from FUNCT_2:sch 8(A4);
set E = ( ( [ 1,( 0 ),( 0 ) ] .--> f ) +* ( [ ( 0 ),( 0 ),( 0 ) ] .--> ( id ( product Ok ) ) ) );
A14: ( dom E ) = ( ( dom ( [ 1,( 0 ),( 0 ) ] .--> f ) ) \/ ( dom ( [ ( 0 ),( 0 ),( 0 ) ] .--> ( id ( product Ok ) ) ) ) ) by FUNCT_4:def 1
.= ( { [ 1,( 0 ),( 0 ) ] } \/ ( dom ( [ ( 0 ),( 0 ),( 0 ) ] .--> ( id ( product Ok ) ) ) ) ) by FUNCOP_1:13
.= ( { [ 1,( 0 ),( 0 ) ] } \/ { [ ( 0 ),( 0 ),( 0 ) ] } ) by FUNCOP_1:13
.= ins by ENUMSET1:1;
A15: (( rng ( [ 1,( 0 ),( 0 ) ] .--> f ) ) c= { f } & ( rng ( [ ( 0 ),( 0 ),( 0 ) ] .--> ( id ( product Ok ) ) ) ) c= { ( id ( product Ok ) ) }) by FUNCOP_1:13;
A16: ( rng E ) c= ( ( rng ( [ 1,( 0 ),( 0 ) ] .--> f ) ) \/ ( rng ( [ ( 0 ),( 0 ),( 0 ) ] .--> ( id ( product Ok ) ) ) ) ) by FUNCT_4:17;
( rng E ) c= ( Funcs (( product Ok ),( product Ok )) )
proof
let e being set;
assume e in ( rng E );
then (e in ( rng ( [ 1,( 0 ),( 0 ) ] .--> f ) ) or e in ( rng ( [ ( 0 ),( 0 ),( 0 ) ] .--> ( id ( product Ok ) ) ) )) by A16,XBOOLE_0:def 3;
then (e = f or e = ( id ( product Ok ) )) by A15,TARSKI:def 1;
hence thesis by FUNCT_2:9;
end;
then reconsider E as (Function of ins,( Funcs (( product Ok ),( product Ok )) )) by A14,FUNCT_2:def 1,RELSET_1:4;
set M = AMI-Struct (# O,IC1,ins,i,Ok,E #);
take (M qua  strict AMI-Struct over N);
thus (the carrier of M) = { ( 0 ) };
thus (the ZeroF of M) = ( 0 );
thus (the Instructions of M) = { [ ( 0 ),( 0 ),( 0 ) ],[ 1,( 0 ),( 0 ) ] };
thus (the haltF of M) = [ ( 0 ),( 0 ),( 0 ) ];
thus (the Object-Kind of M) = ( ( 0 ) .--> ( NAT ) );
reconsider f as (Function of ( product (the Object-Kind of M) ),( product (the Object-Kind of M) ));
take f;
thus (for s being (Element of ( product (the Object-Kind of M) )) holds ( f . s ) = ( s +* ( ( 0 ) .--> ( succ ( s . ( 0 ) ) ) ) )) by A13;
thus thesis;
end;
uniqueness
proof
let it1 being  strict AMI-Struct over N;
let it2 being  strict AMI-Struct over N;
assume that
A17: ((((the carrier of it1) = { ( 0 ) } & (the ZeroF of it1) = ( 0 )) & (the Instructions of it1) = { [ ( 0 ),( 0 ),( 0 ) ],[ 1,( 0 ),( 0 ) ] }) & (the haltF of it1) = [ ( 0 ),( 0 ),( 0 ) ])
and
A18: (the Object-Kind of it1) = ( ( 0 ) .--> ( NAT ) );
given f1 being (Function of ( product (the Object-Kind of it1) ),( product (the Object-Kind of it1) )) such that
A19: (for s being (Element of ( product (the Object-Kind of it1) )) holds ( f1 . s ) = ( s +* ( ( 0 ) .--> ( succ ( s . ( 0 ) ) ) ) ))
and
A20: (the Execution of it1) = ( ( [ 1,( 0 ),( 0 ) ] .--> f1 ) +* ( [ ( 0 ),( 0 ),( 0 ) ] .--> ( id ( product (the Object-Kind of it1) ) ) ) );

assume that
A21: ((((the carrier of it2) = { ( 0 ) } & (the ZeroF of it2) = ( 0 )) & (the Instructions of it2) = { [ ( 0 ),( 0 ),( 0 ) ],[ 1,( 0 ),( 0 ) ] }) & (the haltF of it2) = [ ( 0 ),( 0 ),( 0 ) ])
and
A22: (the Object-Kind of it2) = ( ( 0 ) .--> ( NAT ) );
given f2 being (Function of ( product (the Object-Kind of it2) ),( product (the Object-Kind of it2) )) such that
A23: (for s being (Element of ( product (the Object-Kind of it2) )) holds ( f2 . s ) = ( s +* ( ( 0 ) .--> ( succ ( s . ( 0 ) ) ) ) ))
and
A24: (the Execution of it2) = ( ( [ 1,( 0 ),( 0 ) ] .--> f2 ) +* ( [ ( 0 ),( 0 ),( 0 ) ] .--> ( id ( product (the Object-Kind of it2) ) ) ) );

now
let c being (Element of ( product (the Object-Kind of it1) ));
thus ( f1 . c ) = ( c +* ( ( 0 ) .--> ( succ ( c . ( 0 ) ) ) ) ) by A19
.= ( f2 . c ) by A18,A22,A23;
end;
hence thesis by A17,A18,A20,A21,A22,A24,FUNCT_2:63;
end;
end;
