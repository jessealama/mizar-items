environ
vocabularies NUMBERS,NAT_1,INT_1,FINSEQ_1,ARYTM_3,XXREAL_0,CARD_1,SUBSET_1,ARYTM_1,INT_2,COMPLEX1,RELAT_1,TARSKI,FUNCT_1,CLASSES1,CARD_3,ORDINAL4,RFINSEQ,XBOOLE_0,NEWTON,EULER_1,FINSET_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,XXREAL_0,CARD_1,RELAT_1,FUNCT_1,RECDEF_1,INT_1,INT_2,FINSET_1,NAT_1,NAT_D,NEWTON,EULER_1,CLASSES1,RFINSEQ,RVSUM_1,FINSEQ_1,FINSEQ_3,TREES_4,WSIERP_1,CKB14,CKB16;
definitions TARSKI,FUNCT_1,XBOOLE_0,RELAT_1,CKB16;
theorems INT_2,FINSEQ_1,NAT_1,ABSVALUE,INT_1,FUNCT_1,EULER_1,PREPOWER,RFINSEQ,FINSEQ_2,RVSUM_1,FINSEQ_3,NEWTON,RELAT_1,XBOOLE_1,XCMPLX_1,XREAL_1,FINSEQ_5,XXREAL_0,ORDINAL1,NAT_D,CLASSES1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB15,CKB16,CKB17;
schemes NAT_1,FINSEQ_1;
registrations FUNCT_1,ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,SEQM_3,NEWTON,XBOOLE_0,VALUED_0,FINSET_1,CARD_1;
constructors REAL_1,SQUARE_1,NAT_1,NAT_D,NEWTON,RFINSEQ,WSIERP_1,EULER_1,SEQ_1,RECDEF_1,CLASSES1,BINOP_2,RELSET_1,CKB14,CKB16;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve a for Nat;
reserve m for Nat;
reserve n for Nat;
theorem
Th27: ((((a <> ( 0 ) & m > 1) & ( ( a * n ) mod m ) = ( n mod m )) & m,n are_relative_prime ) implies ( a mod m ) = 1)
proof
assume that
A1: a <> ( 0 )
and
A2: m > 1
and
A3: ( ( a * n ) mod m ) = ( n mod m )
and
A4: m,n are_relative_prime ;
consider k2 being Nat such that A5: n = ( ( m * k2 ) + ( n mod m ) ) and ( n mod m ) < m by A2,NAT_D:def 2;
consider k1 being Nat such that A6: ( a * n ) = ( ( m * k1 ) + ( ( a * n ) mod m ) ) and ( ( a * n ) mod m ) < m by A2,NAT_D:def 2;
( ( a - 1 ) * n ) = ( m * ( k1 - k2 ) ) by A3,A6,A5;
then A7: m divides ( ( a - 1 ) * n ) by INT_1:def 3;
reconsider t = ( a - 1 ),m as Integer;
m divides t by A4,A7,INT_2:25;
then consider tt being Integer such that A8: ( a - 1 ) = ( m * tt ) by INT_1:def 3;
( a - 1 ) >= ( 0 ) by A1,CKB2:1;
then A9: tt >= ( 0 ) by A2,A8,XREAL_1:158;
A10: a = ( ( m * tt ) + 1 ) by A8;
reconsider tt,m as (Element of ( NAT )) by A9,INT_1:3;
( a mod m ) = ( ( ( ( m * tt ) mod m ) + 1 ) mod m ) by A10,NAT_D:22
.= ( ( ( 0 ) + 1 ) mod m ) by NAT_D:13
.= 1 by A2,NAT_D:24;
hence thesis;
end;
