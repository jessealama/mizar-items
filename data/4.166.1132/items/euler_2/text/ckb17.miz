environ
vocabularies NUMBERS,NAT_1,INT_1,FINSEQ_1,ARYTM_3,XXREAL_0,CARD_1,SUBSET_1,ARYTM_1,INT_2,COMPLEX1,RELAT_1,TARSKI,FUNCT_1,CLASSES1,CARD_3,ORDINAL4,RFINSEQ,XBOOLE_0,NEWTON,EULER_1,FINSET_1;
notations TARSKI,XBOOLE_0,SUBSET_1,NUMBERS,XCMPLX_0,XXREAL_0,CARD_1,RELAT_1,FUNCT_1,RECDEF_1,INT_1,INT_2,FINSET_1,NAT_1,NAT_D,NEWTON,EULER_1,CLASSES1,RFINSEQ,RVSUM_1,FINSEQ_1,FINSEQ_3,TREES_4,WSIERP_1,CKB14,CKB16;
definitions TARSKI,FUNCT_1,XBOOLE_0,RELAT_1,CKB16;
theorems INT_2,FINSEQ_1,NAT_1,ABSVALUE,INT_1,FUNCT_1,EULER_1,PREPOWER,RFINSEQ,FINSEQ_2,RVSUM_1,FINSEQ_3,NEWTON,RELAT_1,XBOOLE_1,XCMPLX_1,XREAL_1,FINSEQ_5,XXREAL_0,ORDINAL1,NAT_D,CLASSES1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB15,CKB16;
schemes NAT_1,FINSEQ_1;
registrations FUNCT_1,ORDINAL1,RELSET_1,NUMBERS,XXREAL_0,XREAL_0,NAT_1,INT_1,FINSEQ_1,SEQM_3,NEWTON,XBOOLE_0,VALUED_0,FINSET_1,CARD_1;
constructors REAL_1,SQUARE_1,NAT_1,NAT_D,NEWTON,RFINSEQ,WSIERP_1,EULER_1,SEQ_1,RECDEF_1,CLASSES1,BINOP_2,RELSET_1,CKB14,CKB16;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve m for Nat;
reserve n for Nat;
theorem
(for f being (FinSequence of ( NAT )) holds (m <> ( 0 ) implies ( ( Product ( f mod m ) ) mod m ) = ( ( Product f ) mod m )))
proof
defpred P[ Nat ]
 means
(for f being (FinSequence of ( NAT )) holds ((m <> ( 0 ) & ( len f ) = $1) implies ( ( Product ( f mod m ) ) mod m ) = ( ( Product f ) mod m )));
let f being (FinSequence of ( NAT ));
assume A1: m <> ( 0 );
A2: ( len f ) is (Element of ( NAT ));
A3: (for n holds (P[ n ] implies P[ ( n + 1 ) ]))
proof
let n;
assume A4: P[ n ];
let f being (FinSequence of ( NAT ));
assume that
A5: m <> ( 0 )
and
A6: ( len f ) = ( n + 1 );
reconsider fn = ( f | n ) as (FinSequence of ( NAT ));
A7: ( len fn ) = n by A6,FINSEQ_1:59,NAT_1:11;
A8: ( len ( f mod m ) ) = ( n + 1 ) by A6,CKB16:def 1;
then A9: ( len ( ( f mod m ) | n ) ) = n by FINSEQ_1:59,NAT_1:11;
A10: n <= ( len f ) by A6,NAT_1:11;
A11: (for i being Nat holds ((1 <= i & i <= ( len ( ( f mod m ) | n ) )) implies ( ( ( f mod m ) | n ) . i ) = ( ( fn mod m ) . i )))
proof
let i being Nat;
assume that
A12: 1 <= i
and
A13: i <= ( len ( ( f mod m ) | n ) );
A14: ( ( f | n ) . i ) = ( ( f | ( Seg n ) ) . i ) by FINSEQ_1:def 15;
A15: i in ( Seg n ) by A9,A12,A13,FINSEQ_1:1;
then A16: ( ( ( f mod m ) | ( Seg n ) ) . i ) = ( ( f mod m ) . i ) by FUNCT_1:49;
i <= ( len f ) by A10,A9,A13,XXREAL_0:2;
then A17: i in ( dom f ) by A12,FINSEQ_3:25;
i in ( dom fn ) by A7,A9,A12,A13,FINSEQ_3:25;
then ( ( fn mod m ) . i ) = ( ( fn . i ) mod m ) by CKB16:def 1
.= ( ( f . i ) mod m ) by A15,A14,FUNCT_1:49
.= ( ( f mod m ) . i ) by A17,CKB16:def 1;
hence thesis by A16,FINSEQ_1:def 15;
end;
( ( 0 ) + 1 ) <= ( n + 1 ) by NAT_1:13;
then ( n + 1 ) in ( dom f ) by A6,FINSEQ_3:25;
then A18: ( ( f mod m ) . ( n + 1 ) ) = ( ( f . ( n + 1 ) ) mod m ) by CKB16:def 1;
( len ( ( f mod m ) | n ) ) = ( len ( fn mod m ) ) by A7,A9,CKB16:def 1;
then ( ( f mod m ) | n ) = ( fn mod m ) by A11,FINSEQ_1:14;
then ( f mod m ) = ( ( fn mod m ) ^ <* ( ( f . ( n + 1 ) ) mod m ) *> ) by A8,A18,RFINSEQ:7;
then A19: ( ( Product ( f mod m ) ) mod m ) = ( ( ( Product ( fn mod m ) ) * ( ( f . ( n + 1 ) ) mod m ) ) mod m ) by RVSUM_1:96
.= ( ( ( ( Product ( fn mod m ) ) mod m ) * ( ( ( f . ( n + 1 ) ) mod m ) mod m ) ) mod m ) by CKB13:1
.= ( ( ( ( Product fn ) mod m ) * ( ( ( f . ( n + 1 ) ) mod m ) mod m ) ) mod m ) by A4,A5,A7
.= ( ( ( ( Product fn ) mod m ) * ( ( f . ( n + 1 ) ) mod m ) ) mod m ) by CKB9:1;
( ( Product f ) mod m ) = ( ( Product ( fn ^ <* ( f . ( n + 1 ) ) *> ) ) mod m ) by A6,RFINSEQ:7
.= ( ( ( Product fn ) * ( f . ( n + 1 ) ) ) mod m ) by RVSUM_1:96;
hence thesis by A19,CKB13:1;
end;
A20: P[ ( 0 ) ]
proof
let f being (FinSequence of ( NAT ));
assume that
m <> ( 0 )
and
A21: ( len f ) = ( 0 );
A22: (f = ( <*> ( NAT ) ) & ( len ( f mod m ) ) = ( 0 )) by A21,CKB16:def 1;
then ( f mod m ) = ( <*> ( NAT ) );
hence thesis by A22;
end;
(for n holds P[ n ]) from NAT_1:sch 2(A20,A3);
hence thesis by A1,A2;
end;
