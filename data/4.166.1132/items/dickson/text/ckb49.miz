environ
vocabularies FUNCT_1,RELAT_1,FUNCOP_1,NAT_1,TARSKI,ARYTM_3,XBOOLE_0,SUBSET_1,NUMBERS,XXREAL_0,FINSET_1,CARD_1,ORDERS_2,REARRAN1,RELAT_2,STRUCT_0,WELLORD1,WAYBEL_4,WAYBEL20,EQREL_1,ORDERS_1,ZFMISC_1,WELLFND1,SETFAM_1,VALUED_0,ORDINAL2,MCART_1,CAT_1,YELLOW_1,PBOOLE,CARD_3,RLVECT_2,YELLOW_6,WAYBEL_3,FUNCT_4,YELLOW_3,DICKSON;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,SETFAM_1,RELAT_1,FUNCT_1,PBOOLE,RELSET_1,XXREAL_2,SEQ_4,PARTFUN1,FUNCT_2,CARD_3,NAT_1,STRUCT_0,RELAT_2,XXREAL_0,FUNCT_4,FUNCOP_1,DOMAIN_1,FINSET_1,MCART_1,WELLORD1,ORDERS_2,ORDERS_1,EQREL_1,WELLFND1,WAYBEL_0,CARD_1,NUMBERS,WAYBEL_4,VALUED_0,PRALG_1,YELLOW_3,WAYBEL_1,YELLOW_1,WAYBEL_3,YELLOW_6,CKB5,CKB6,CKB11,CKB12,CKB14,CKB17,CKB19,CKB20,CKB32,CKB39,CKB42,CKB45,CKB46;
definitions TARSKI,RELAT_2,ORDERS_2,ORDERS_1,FUNCOP_1,CKB5,CKB6,CKB11,CKB12,CKB14,CKB17,CKB20,CKB32,CKB39,CKB42,CKB45,CKB46;
theorems WELLORD1,ORDERS_1,SUBSET_1,TARSKI,RELAT_1,RELAT_2,RELSET_1,ZFMISC_1,EQREL_1,WAYBEL_0,ORDERS_2,NAT_1,FUNCT_1,FUNCT_2,CARD_2,CARD_1,NORMSP_1,SEQM_3,FINSET_1,AXIOMS,YELLOW_3,WAYBEL_1,WAYBEL20,YELLOW_1,CARD_3,FUNCOP_1,WAYBEL_3,MCART_1,FUNCT_4,WELLFND1,WAYBEL_4,PRALG_1,YELLOW_6,AFINSQ_1,XBOOLE_0,XBOOLE_1,PARTFUN1,XXREAL_0,ORDINAL1,XXREAL_2,VALUED_0,CKB1,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB20,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48;
schemes PRE_CIRC,RECDEF_1,NAT_1,FUNCT_2,DOMAIN_1,FRAENKEL,FINSEQ_1,FUNCT_1,RELSET_1,CKB3;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCOP_1,FINSET_1,XXREAL_0,NAT_1,MEMBERED,EQREL_1,CARD_5,PRE_CIRC,STRUCT_0,ORDERS_2,YELLOW_1,YELLOW_3,WAYBEL18,WAYBEL_3,VALUED_0,CARD_1,XXREAL_2,CARD_3,ZFMISC_1,RELSET_1,CKB18,CKB21,CKB22,CKB23;
constructors WELLORD1,DOMAIN_1,NAT_1,BINOP_2,BHSP_3,PRALG_1,ORDERS_3,WAYBEL_1,YELLOW_3,WAYBEL_3,WAYBEL_4,WELLFND1,SEQ_1,RECDEF_1,SEQ_4,XXREAL_2,RELSET_1,PBOOLE,YELLOW_6,CKB5,CKB6,CKB11,CKB12,CKB14,CKB17,CKB19,CKB20,CKB32,CKB39,CKB42,CKB45,CKB46;
requirements BOOLE,SUBSET,NUMERALS;
begin
theorem
Th32: (for R being non empty RelStr holds ((R is  quasi_ordered & (for f being (sequence of R) holds (ex i,j being (Element of ( NAT )) st (i < j & ( f . i ) <= ( f . j ))))) implies (for N being non empty (Subset of R) holds (( min-classes N ) is  finite & ( min-classes N ) is non empty))))
proof
let R being non empty RelStr;
assume that
A1: R is  quasi_ordered
and
A2: (for f being (sequence of R) holds (ex i,j being (Element of ( NAT )) st (i < j & ( f . i ) <= ( f . j ))));
set IR = (the InternalRel of R);
set IR9 = (the InternalRel of ( R \~ ));
A3: R is  transitive by A1,CKB11:def 1;
let N being non empty (Subset of R);
assume that
A4: (not (( min-classes N ) is  finite & ( min-classes N ) is non empty));
per cases  by A4;
suppose A5: ( min-classes N ) is  infinite;

then reconsider MCN = ( min-classes N ) as  infinite set;
consider f being (Function of ( NAT ),( min-classes N )) such that A6: f is  one-to-one by A5,CKB4:1;
deffunc F(set) = ( choose ( f . $1 ) );
A7:now
let x being set;
assume x in ( NAT );
then reconsider x9 = x as (Element of ( NAT ));
( f . x9 ) is (Element of ( min-classes N ));
then A8: ( f . x ) in MCN;
then ( f . x ) is non empty by CKB36:1;
then ( choose ( f . x9 ) ) in ( f . x );
hence F(x) in (the carrier of R) by A8;
end;
consider g being (Function of ( NAT ),(the carrier of R)) such that A9: (for x being set holds (x in ( NAT ) implies ( g . x ) = F(x))) from FUNCT_2:sch 2(A7);
reconsider g as (sequence of R);
consider i being (Element of ( NAT )),j being (Element of ( NAT )) such that A10: i < j and A11: ( g . i ) <= ( g . j ) by A2;
reconsider gi = ( g . i ),gj = ( g . j ) as (Element of ( R \~ ));
A12: [ gi,gj ] in IR by A11,ORDERS_2:def 5;
A13: ( f . i ) in MCN;
then A14: ( f . i ) is non empty by CKB36:1;
A15: ( f . j ) in MCN;
then A16: ( f . j ) is non empty by CKB36:1;
A17: ( g . j ) = ( choose ( f . j ) ) by A9;
A18: ( g . i ) = ( choose ( f . i ) ) by A9;
A19: gj is_minimal_wrt N,(the InternalRel of ( R \~ )) by A1,A15,A16,A17,CKB33:1;
gi is_minimal_wrt N,(the InternalRel of ( R \~ )) by A1,A13,A14,A18,CKB33:1;
then A20: gi in N by WAYBEL_4:def 25;
A21:now
per cases ;
suppose gi = gj;

hence [ gi,gj ] in ( IR ~ ) by A12,RELAT_1:def 7;
end;
suppose A22: gi <> gj;

now
assume (not [ gi,gj ] in ( IR ~ ));
then [ gi,gj ] in ( IR \ ( IR ~ ) ) by A12,XBOOLE_0:def 5;
hence contradiction by A19,A20,A22,WAYBEL_4:def 25;
end;
hence [ gi,gj ] in ( IR ~ );
end;
end;
[ gi,gj ] in IR by A11,ORDERS_2:def 5;
then [ gi,gj ] in ( IR /\ ( IR ~ ) ) by A21,XBOOLE_0:def 4;
then [ gi,gj ] in ( EqRel R ) by A1,CKB12:def 1;
then gi in ( Class (( EqRel R ),gj) ) by EQREL_1:19;
then A23: ( Class (( EqRel R ),gj) ) = ( Class (( EqRel R ),gi) ) by EQREL_1:23;
consider mj being (Element of ( R \~ )) such that mj is_minimal_wrt N,IR9 and A24: ( f . j ) = ( ( Class (( EqRel R ),mj) ) /\ N ) by A15,CKB32:def 1;
consider mi being (Element of ( R \~ )) such that mi is_minimal_wrt N,IR9 and A25: ( f . i ) = ( ( Class (( EqRel R ),mi) ) /\ N ) by A13,CKB32:def 1;
gj in ( Class (( EqRel R ),mj) ) by A16,A17,A24,XBOOLE_0:def 4;
then A26: ( Class (( EqRel R ),gj) ) = ( Class (( EqRel R ),mj) ) by EQREL_1:23;
gi in ( Class (( EqRel R ),mi) ) by A14,A18,A25,XBOOLE_0:def 4;
then ( f . i ) = ( f . j ) by A23,A24,A25,A26,EQREL_1:23;
hence contradiction by A5,A6,A10,FUNCT_2:19;
end;
suppose A27: ( min-classes N ) is  empty;

deffunc F(set,set) = ( choose ( ( ( IR -Seg $2 ) /\ N ) \ ( Class (( EqRel R ),$2) ) ) );
consider f being Function such that A28: ( dom f ) = ( NAT ) and A29: ( f . ( 0 ) ) = ( choose N ) and A30: (for n being Nat holds ( f . ( n + 1 ) ) = F(n,( f . n ))) from NAT_1:sch 11;
defpred P[ Nat ]
 means
( f . $1 ) in N;
A31: P[ ( 0 ) ] by A29;
A32:now
let i being (Element of ( NAT ));
assume that
A33: P[ i ];
reconsider fi = ( f . i ) as (Element of ( R \~ )) by A33;
set IC = ( ( ( IR -Seg fi ) /\ N ) \ ( Class (( EqRel R ),fi) ) );
A34: ( f . ( i + 1 ) ) = ( choose ( ( ( IR -Seg ( f . i ) ) /\ N ) \ ( Class (( EqRel R ),( f . i )) ) ) ) by A30;
now
assume IC is  empty;
then ( ( IR -Seg fi ) /\ N ) c= ( Class (( EqRel R ),fi) ) by XBOOLE_1:37;
hence contradiction by A1,A27,A33,CKB35:1,CKB48:1;
end;
then ( f . ( i + 1 ) ) in ( ( IR -Seg ( f . i ) ) /\ N ) by A34,XBOOLE_0:def 5;
hence P[ ( i + 1 ) ] by XBOOLE_0:def 4;
end;
A35: (for i being (Element of ( NAT )) holds P[ i ]) from NAT_1:sch 1(A31,A32);
now
let x being set;
assume x in ( NAT );
then ( f . x ) in N by A35;
hence ( f . x ) in (the carrier of R);
end;
then reconsider f as (sequence of R) by A28,FUNCT_2:3;
A36:now
let i being (Element of ( NAT ));
defpred P[ (Element of ( NAT )) ]
 means
(i < $1 implies ( f . i ) >= ( f . $1 ));
A37: P[ ( 0 ) ] by NAT_1:2;
A38: (for j being (Element of ( NAT )) holds (P[ j ] implies P[ ( j + 1 ) ]))
proof
let j being (Element of ( NAT ));
assume that
A39: (i < j implies ( f . i ) >= ( f . j ))
and
A40: i < ( j + 1 );
A41: i <= j by A40,NAT_1:13;
reconsider fj = ( f . j ),fj1 = ( f . ( j + 1 ) ) as (Element of ( R \~ ));
set IC = ( ( ( IR -Seg fj ) /\ N ) \ ( Class (( EqRel R ),fj) ) );
A42: fj in N by A35;
A43: fj1 = ( choose IC ) by A30;
now
assume IC is  empty;
then ( ( IR -Seg fj ) /\ N ) c= ( Class (( EqRel R ),fj) ) by XBOOLE_1:37;
hence contradiction by A1,A27,A42,CKB35:1,CKB48:1;
end;
then fj1 in ( ( IR -Seg fj ) /\ N ) by A43,XBOOLE_0:def 5;
then fj1 in ( IR -Seg fj ) by XBOOLE_0:def 4;
then A44: [ fj1,fj ] in IR by WELLORD1:1;
then A45: ( f . j ) >= ( f . ( j + 1 ) ) by ORDERS_2:def 5;
per cases  by A41,XXREAL_0:1;
suppose i < j;

hence thesis by A3,A39,A45,ORDERS_2:3;
end;
suppose i = j;

hence thesis by A44,ORDERS_2:def 5;
end;
end;
thus (for j being (Element of ( NAT )) holds P[ j ]) from NAT_1:sch 1(A37,A38);
end;
now
let i being (Element of ( NAT ));
defpred P[ (Element of ( NAT )) ]
 means
(i < $1 implies (not ( f . i ) <= ( f . $1 )));
A46: P[ ( 0 ) ] by NAT_1:2;
A47: (for j being (Element of ( NAT )) holds (P[ j ] implies P[ ( j + 1 ) ]))
proof
let j being (Element of ( NAT ));
assume that
(i < j implies (not ( f . i ) <= ( f . j )))
and
A48: i < ( j + 1 );
A49: i <= j by A48,NAT_1:13;
reconsider fj = ( f . j ),fj1 = ( f . ( j + 1 ) ) as (Element of ( R \~ ));
A50: fj in N by A35;
per cases  by A49,XXREAL_0:1;
suppose A51: i < j;

assume A52: ( f . i ) <= ( f . ( j + 1 ) );
j < ( j + 1 ) by NAT_1:13;
then A53: ( f . j ) >= ( f . ( j + 1 ) ) by A36;
( f . i ) >= ( f . j ) by A36,A51;
then ( f . j ) <= ( f . ( j + 1 ) ) by A3,A52,ORDERS_2:3;
then A54: fj1 in ( Class (( EqRel R ),fj) ) by A1,A53,CKB13:1;
set IC = ( ( ( IR -Seg fj ) /\ N ) \ ( Class (( EqRel R ),fj) ) );
A55: fj1 = ( choose IC ) by A30;
now
assume IC is  empty;
then ( ( IR -Seg fj ) /\ N ) c= ( Class (( EqRel R ),fj) ) by XBOOLE_1:37;
hence contradiction by A1,A27,A50,CKB35:1,CKB48:1;
end;
hence contradiction by A54,A55,XBOOLE_0:def 5;
end;
suppose A56: i = j;

assume A57: ( f . i ) <= ( f . ( j + 1 ) );
j < ( j + 1 ) by NAT_1:13;
then ( f . ( j + 1 ) ) <= ( f . j ) by A36;
then A58: fj1 in ( Class (( EqRel R ),fj) ) by A1,A56,A57,CKB13:1;
set IC = ( ( ( IR -Seg fj ) /\ N ) \ ( Class (( EqRel R ),fj) ) );
A59: fj1 = ( choose IC ) by A30;
now
assume IC is  empty;
then ( ( IR -Seg fj ) /\ N ) c= ( Class (( EqRel R ),fj) ) by XBOOLE_1:37;
hence contradiction by A1,A27,A50,CKB35:1,CKB48:1;
end;
hence contradiction by A58,A59,XBOOLE_0:def 5;
end;
end;
thus (for j being (Element of ( NAT )) holds P[ j ]) from NAT_1:sch 1(A46,A47);
end;
hence contradiction by A2;
end;
end;
