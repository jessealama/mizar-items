environ
vocabularies FUNCT_1,RELAT_1,FUNCOP_1,NAT_1,TARSKI,ARYTM_3,XBOOLE_0,SUBSET_1,NUMBERS,XXREAL_0,FINSET_1,CARD_1,ORDERS_2,REARRAN1,RELAT_2,STRUCT_0,WELLORD1,WAYBEL_4,WAYBEL20,EQREL_1,ORDERS_1,ZFMISC_1,WELLFND1,SETFAM_1,VALUED_0,ORDINAL2,MCART_1,CAT_1,YELLOW_1,PBOOLE,CARD_3,RLVECT_2,YELLOW_6,WAYBEL_3,FUNCT_4,YELLOW_3,DICKSON;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,SETFAM_1,RELAT_1,FUNCT_1,PBOOLE,RELSET_1,XXREAL_2,SEQ_4,PARTFUN1,FUNCT_2,CARD_3,NAT_1,STRUCT_0,RELAT_2,XXREAL_0,FUNCT_4,FUNCOP_1,DOMAIN_1,FINSET_1,MCART_1,WELLORD1,ORDERS_2,ORDERS_1,EQREL_1,WELLFND1,WAYBEL_0,CARD_1,NUMBERS,WAYBEL_4,VALUED_0,PRALG_1,YELLOW_3,WAYBEL_1,YELLOW_1,WAYBEL_3,YELLOW_6,CKB5,CKB6,CKB11,CKB12,CKB14,CKB17,CKB19,CKB20,CKB32,CKB39,CKB42,CKB45,CKB46,CKB53;
definitions TARSKI,RELAT_2,ORDERS_2,ORDERS_1,FUNCOP_1,CKB5,CKB6,CKB11,CKB12,CKB14,CKB17,CKB20,CKB32,CKB39,CKB42,CKB45,CKB46,CKB53;
theorems WELLORD1,ORDERS_1,SUBSET_1,TARSKI,RELAT_1,RELAT_2,RELSET_1,ZFMISC_1,EQREL_1,WAYBEL_0,ORDERS_2,NAT_1,FUNCT_1,FUNCT_2,CARD_2,CARD_1,NORMSP_1,SEQM_3,FINSET_1,AXIOMS,YELLOW_3,WAYBEL_1,WAYBEL20,YELLOW_1,CARD_3,FUNCOP_1,WAYBEL_3,MCART_1,FUNCT_4,WELLFND1,WAYBEL_4,PRALG_1,YELLOW_6,AFINSQ_1,XBOOLE_0,XBOOLE_1,PARTFUN1,XXREAL_0,ORDINAL1,XXREAL_2,VALUED_0,CKB1,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB20,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55,CKB56,CKB57,CKB58;
schemes PRE_CIRC,RECDEF_1,NAT_1,FUNCT_2,DOMAIN_1,FRAENKEL,FINSEQ_1,FUNCT_1,RELSET_1,CKB3;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCOP_1,FINSET_1,XXREAL_0,NAT_1,MEMBERED,EQREL_1,CARD_5,PRE_CIRC,STRUCT_0,ORDERS_2,YELLOW_1,YELLOW_3,WAYBEL18,WAYBEL_3,VALUED_0,CARD_1,XXREAL_2,CARD_3,ZFMISC_1,RELSET_1,CKB18,CKB21,CKB22,CKB23,CKB59;
constructors WELLORD1,DOMAIN_1,NAT_1,BINOP_2,BHSP_3,PRALG_1,ORDERS_3,WAYBEL_1,YELLOW_3,WAYBEL_3,WAYBEL_4,WELLFND1,SEQ_1,RECDEF_1,SEQ_4,XXREAL_2,RELSET_1,PBOOLE,YELLOW_6,CKB5,CKB6,CKB11,CKB12,CKB14,CKB17,CKB19,CKB20,CKB32,CKB39,CKB42,CKB45,CKB46,CKB53;
requirements BOOLE,SUBSET,NUMERALS;
begin
theorem
Th41: (for n being non empty Nat holds (for p being  RelStr-yielding (ManySortedSet of n) holds (( product p ) is non empty iff p is  non-Empty)))
proof
let n being non empty Nat;
let p being  RelStr-yielding (ManySortedSet of n);
hereby
assume ( product p ) is non empty;
then ( product ( Carrier p ) ) is non empty by YELLOW_1:def 4;
then consider z being set such that A1: z in ( product ( Carrier p ) ) by XBOOLE_0:def 1;
A2: (ex g being Function st ((z = g & ( dom g ) = ( dom ( Carrier p ) )) & (for i being set holds (i in ( dom ( Carrier p ) ) implies ( g . i ) in ( ( Carrier p ) . i ))))) by A1,CARD_3:def 5;
now
let S being 1-sorted;
assume S in ( rng p );
then consider x being set such that A3: x in ( dom p ) and A4: S = ( p . x ) by FUNCT_1:def 3;
A5: x in n by A3,PARTFUN1:def 2;
then A6: x in ( dom ( Carrier p ) ) by PARTFUN1:def 2;
(ex R being 1-sorted st (R = ( p . x ) & ( ( Carrier p ) . x ) = (the carrier of R))) by A5,PRALG_1:def 13;
hence S is non empty by A2,A4,A6;
end;
hence p is  non-Empty by WAYBEL_3:def 7;
end;
assume A7: p is  non-Empty;
A8: ( dom ( Carrier p ) ) = n by PARTFUN1:def 2;
deffunc F(set) = ( choose ( ( Carrier p ) . $1 ) );
consider g being Function such that A9: ( dom g ) = ( dom ( Carrier p ) ) and A10: (for i being set holds (i in ( dom ( Carrier p ) ) implies ( g . i ) = F(i))) from FUNCT_1:sch 3;
set x = g;
now
take g;
thus x = g;
thus ( dom g ) = ( dom ( Carrier p ) ) by A9;
thus (for i being set holds (i in ( dom ( Carrier p ) ) implies ( g . i ) in ( ( Carrier p ) . i )))
proof
let i being set;
assume that
A11: i in ( dom ( Carrier p ) );
i in ( dom p ) by A8,A11,PARTFUN1:def 2;
then A12: ( p . i ) in ( rng p ) by FUNCT_1:def 3;
then reconsider pi1 = ( p . i ) as RelStr by YELLOW_1:def 3;
pi1 is non empty by A7,A12,WAYBEL_3:def 7;
then A13: (the carrier of pi1) is non empty;
i in n by A11,PARTFUN1:def 2;
then A14: (ex R being 1-sorted st (R = ( p . i ) & ( ( Carrier p ) . i ) = (the carrier of R))) by PRALG_1:def 13;
( g . i ) = ( choose ( ( Carrier p ) . i ) ) by A10,A11;
hence thesis by A13,A14;
end;

end;
then ( product ( Carrier p ) ) is non empty by CARD_3:def 5;
hence thesis by YELLOW_1:def 4;
end;
