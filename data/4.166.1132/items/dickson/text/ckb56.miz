environ
vocabularies FUNCT_1,RELAT_1,FUNCOP_1,NAT_1,TARSKI,ARYTM_3,XBOOLE_0,SUBSET_1,NUMBERS,XXREAL_0,FINSET_1,CARD_1,ORDERS_2,REARRAN1,RELAT_2,STRUCT_0,WELLORD1,WAYBEL_4,WAYBEL20,EQREL_1,ORDERS_1,ZFMISC_1,WELLFND1,SETFAM_1,VALUED_0,ORDINAL2,MCART_1,CAT_1,YELLOW_1,PBOOLE,CARD_3,RLVECT_2,YELLOW_6,WAYBEL_3,FUNCT_4,YELLOW_3,DICKSON;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,SETFAM_1,RELAT_1,FUNCT_1,PBOOLE,RELSET_1,XXREAL_2,SEQ_4,PARTFUN1,FUNCT_2,CARD_3,NAT_1,STRUCT_0,RELAT_2,XXREAL_0,FUNCT_4,FUNCOP_1,DOMAIN_1,FINSET_1,MCART_1,WELLORD1,ORDERS_2,ORDERS_1,EQREL_1,WELLFND1,WAYBEL_0,CARD_1,NUMBERS,WAYBEL_4,VALUED_0,PRALG_1,YELLOW_3,WAYBEL_1,YELLOW_1,WAYBEL_3,YELLOW_6,CKB5,CKB6,CKB11,CKB12,CKB14,CKB17,CKB19,CKB20,CKB32,CKB39,CKB42,CKB45,CKB46,CKB53;
definitions TARSKI,RELAT_2,ORDERS_2,ORDERS_1,FUNCOP_1,CKB5,CKB6,CKB11,CKB12,CKB14,CKB17,CKB20,CKB32,CKB39,CKB42,CKB45,CKB46,CKB53;
theorems WELLORD1,ORDERS_1,SUBSET_1,TARSKI,RELAT_1,RELAT_2,RELSET_1,ZFMISC_1,EQREL_1,WAYBEL_0,ORDERS_2,NAT_1,FUNCT_1,FUNCT_2,CARD_2,CARD_1,NORMSP_1,SEQM_3,FINSET_1,AXIOMS,YELLOW_3,WAYBEL_1,WAYBEL20,YELLOW_1,CARD_3,FUNCOP_1,WAYBEL_3,MCART_1,FUNCT_4,WELLFND1,WAYBEL_4,PRALG_1,YELLOW_6,AFINSQ_1,XBOOLE_0,XBOOLE_1,PARTFUN1,XXREAL_0,ORDINAL1,XXREAL_2,VALUED_0,CKB1,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB20,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45,CKB46,CKB47,CKB48,CKB49,CKB50,CKB51,CKB52,CKB53,CKB54,CKB55;
schemes PRE_CIRC,RECDEF_1,NAT_1,FUNCT_2,DOMAIN_1,FRAENKEL,FINSEQ_1,FUNCT_1,RELSET_1,CKB3;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCOP_1,FINSET_1,XXREAL_0,NAT_1,MEMBERED,EQREL_1,CARD_5,PRE_CIRC,STRUCT_0,ORDERS_2,YELLOW_1,YELLOW_3,WAYBEL18,WAYBEL_3,VALUED_0,CARD_1,XXREAL_2,CARD_3,ZFMISC_1,RELSET_1,CKB18,CKB21,CKB22,CKB23;
constructors WELLORD1,DOMAIN_1,NAT_1,BINOP_2,BHSP_3,PRALG_1,ORDERS_3,WAYBEL_1,YELLOW_3,WAYBEL_3,WAYBEL_4,WELLFND1,SEQ_1,RECDEF_1,SEQ_4,XXREAL_2,RELSET_1,PBOOLE,YELLOW_6,CKB5,CKB6,CKB11,CKB12,CKB14,CKB17,CKB19,CKB20,CKB32,CKB39,CKB42,CKB45,CKB46,CKB53;
requirements BOOLE,SUBSET,NUMERALS;
begin
theorem
Th38: (for M,N being RelStr holds ((((M is  Dickson & N is  Dickson) & M is  quasi_ordered) & N is  quasi_ordered) implies ([: M,N :] is  quasi_ordered & [: M,N :] is  Dickson)))
proof
let M being RelStr,N being RelStr;
assume that
A1: M is  Dickson
and
A2: N is  Dickson
and
A3: M is  quasi_ordered
and
A4: N is  quasi_ordered;
reconsider M9 = M as  reflexive  transitive RelStr by A3,CKB11:def 1;
reconsider N9 = N as  reflexive  transitive RelStr by A4,CKB11:def 1;
[: M9,N9 :] is  reflexive;
hence A5: [: M,N :] is  quasi_ordered by CKB11:def 1;
per cases ;
suppose (M is non empty & N is non empty);

then reconsider Me = M,Ne = N as non empty RelStr;
set CPMN = [: Me,Ne :];
(for f being (sequence of [: Me,Ne :]) holds (ex i,j being (Element of ( NAT )) st (i < j & ( f . i ) <= ( f . j ))))
proof
let f being (sequence of [: Me,Ne :]);
deffunc F((Element of ( NAT ))) = ( ( f . $1 ) `1 );
consider a being (Function of ( NAT ),(the carrier of Me)) such that A6: (for x being (Element of ( NAT )) holds ( a . x ) = F(x)) from FUNCT_2:sch 4;
reconsider a as (sequence of Me);
consider sa being (sequence of Me) such that A7: sa is (subsequence of a) and A8: sa is  weakly-ascending by A1,CKB54:1;
consider NS being  increasing (sequence of ( NAT )) such that A9: sa = ( a * NS ) by A7,VALUED_0:def 17;
deffunc G((Element of ( NAT ))) = ( ( f . ( NS . $1 ) ) `2 );
consider b being (Function of ( NAT ),(the carrier of Ne)) such that A10: (for x being (Element of ( NAT )) holds ( b . x ) = G(x)) from FUNCT_2:sch 4;
reconsider b as (sequence of Ne);
consider i being (Element of ( NAT )),j being (Element of ( NAT )) such that A11: i < j and A12: ( b . i ) <= ( b . j ) by A2,CKB47:1;
take ( NS . i );
take ( NS . j );
( dom NS ) = ( NAT ) by FUNCT_2:def 1;
hence ( NS . i ) < ( NS . j ) by A11,VALUED_0:def 13;
reconsider x = ( f . ( NS . i ) ),y = ( f . ( NS . j ) ) as (Element of [: Me,Ne :]);
A13: ( dom sa ) = ( NAT ) by FUNCT_2:def 1;
then A14: ( sa . i ) = ( a . ( NS . i ) ) by A9,FUNCT_1:12
.= ( ( f . ( NS . i ) ) `1 ) by A6;
A15: ( sa . j ) = ( a . ( NS . j ) ) by A9,A13,FUNCT_1:12
.= ( ( f . ( NS . j ) ) `1 ) by A6;
M is  transitive by A3,CKB11:def 1;
then A16: ( x `1 ) <= ( y `1 ) by A8,A11,A14,A15,CKB7:1;
A17: ( b . i ) = ( x `2 ) by A10;
( b . j ) = ( y `2 ) by A10;
hence thesis by A12,A16,A17,YELLOW_3:12;
end;
then (for N being non empty (Subset of CPMN) holds (( min-classes N ) is  finite & ( min-classes N ) is non empty)) by A5,CKB49:1;
hence thesis by A5,CKB50:1;
end;
suppose A18: (not (M is non empty & N is non empty));

now
per cases  by A18;
suppose M is  empty;

then reconsider M2 = (the carrier of M) as  empty set;
[: M2,(the carrier of N) :] is  empty;
hence [: (the carrier of M),(the carrier of N) :] is  empty;
end;
suppose N is  empty;

then reconsider N2 = (the carrier of N) as  empty set;
[: (the carrier of M),N2 :] is  empty;
hence [: (the carrier of M),(the carrier of N) :] is  empty;
end;
end;
then [: M,N :] is  empty by YELLOW_3:def 2;
hence thesis by CKB55:1;
end;
end;
