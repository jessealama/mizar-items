environ
vocabularies FUNCT_1,RELAT_1,FUNCOP_1,NAT_1,TARSKI,ARYTM_3,XBOOLE_0,SUBSET_1,NUMBERS,XXREAL_0,FINSET_1,CARD_1,ORDERS_2,REARRAN1,RELAT_2,STRUCT_0,WELLORD1,WAYBEL_4,WAYBEL20,EQREL_1,ORDERS_1,ZFMISC_1,WELLFND1,SETFAM_1,VALUED_0,ORDINAL2,MCART_1,CAT_1,YELLOW_1,PBOOLE,CARD_3,RLVECT_2,YELLOW_6,WAYBEL_3,FUNCT_4,YELLOW_3,DICKSON;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,SETFAM_1,RELAT_1,FUNCT_1,PBOOLE,RELSET_1,XXREAL_2,SEQ_4,PARTFUN1,FUNCT_2,CARD_3,NAT_1,STRUCT_0,RELAT_2,XXREAL_0,FUNCT_4,FUNCOP_1,DOMAIN_1,FINSET_1,MCART_1,WELLORD1,ORDERS_2,ORDERS_1,EQREL_1,WELLFND1,WAYBEL_0,CARD_1,NUMBERS,WAYBEL_4,VALUED_0,PRALG_1,YELLOW_3,WAYBEL_1,YELLOW_1,WAYBEL_3,YELLOW_6,CKB5,CKB6,CKB11,CKB12,CKB14,CKB17,CKB19,CKB20,CKB32,CKB39,CKB42,CKB45;
definitions TARSKI,RELAT_2,ORDERS_2,ORDERS_1,FUNCOP_1,CKB5,CKB6,CKB11,CKB12,CKB14,CKB17,CKB20,CKB32,CKB39,CKB42,CKB45;
theorems WELLORD1,ORDERS_1,SUBSET_1,TARSKI,RELAT_1,RELAT_2,RELSET_1,ZFMISC_1,EQREL_1,WAYBEL_0,ORDERS_2,NAT_1,FUNCT_1,FUNCT_2,CARD_2,CARD_1,NORMSP_1,SEQM_3,FINSET_1,AXIOMS,YELLOW_3,WAYBEL_1,WAYBEL20,YELLOW_1,CARD_3,FUNCOP_1,WAYBEL_3,MCART_1,FUNCT_4,WELLFND1,WAYBEL_4,PRALG_1,YELLOW_6,AFINSQ_1,XBOOLE_0,XBOOLE_1,PARTFUN1,XXREAL_0,ORDINAL1,XXREAL_2,VALUED_0,CKB1,CKB2,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB20,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42,CKB43,CKB44,CKB45;
schemes PRE_CIRC,RECDEF_1,NAT_1,FUNCT_2,DOMAIN_1,FRAENKEL,FINSEQ_1,FUNCT_1,RELSET_1,CKB3;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCOP_1,FINSET_1,XXREAL_0,NAT_1,MEMBERED,EQREL_1,CARD_5,PRE_CIRC,STRUCT_0,ORDERS_2,YELLOW_1,YELLOW_3,WAYBEL18,WAYBEL_3,VALUED_0,CARD_1,XXREAL_2,CARD_3,ZFMISC_1,RELSET_1,CKB18,CKB21,CKB22,CKB23;
constructors WELLORD1,DOMAIN_1,NAT_1,BINOP_2,BHSP_3,PRALG_1,ORDERS_3,WAYBEL_1,YELLOW_3,WAYBEL_3,WAYBEL_4,WELLFND1,SEQ_1,RECDEF_1,SEQ_4,XXREAL_2,RELSET_1,PBOOLE,YELLOW_6,CKB5,CKB6,CKB11,CKB12,CKB14,CKB17,CKB19,CKB20,CKB32,CKB39,CKB42,CKB45;
requirements BOOLE,SUBSET,NUMERALS;
begin
definition
let R being non empty 1-sorted;
let f being (sequence of R);
let b being set;
let m being (Element of ( NAT ));
assume A1: (ex j being (Element of ( NAT )) st (m < j & ( f . j ) = b));
func f mindex (b,m) -> (Element of ( NAT ))
means
:Def12: ((( f . it ) = b & m < it) & (for i being (Element of ( NAT )) holds ((m < i & ( f . i ) = b) implies it <= i)));
existence
proof
set N = { i where i is (Element of ( NAT )): (m < i & ( f . i ) = b) };
consider j being (Element of ( NAT )) such that A2: m < j and A3: ( f . j ) = b by A1;
A4: j in N by A2,A3;
now
let x being set;
assume x in N;
then (ex i being (Element of ( NAT )) st ((x = i & m < i) & ( f . i ) = b));
hence x in ( NAT );
end;
then reconsider N as non empty (Subset of ( NAT )) by A4,TARSKI:def 3;
take I = ( min N );
I in N by XXREAL_2:def 7;
then (ex II being (Element of ( NAT )) st ((II = I & m < II) & ( f . II ) = b));
hence (( f . I ) = b & m < I);
let i being (Element of ( NAT ));
assume that
A5: m < i
and
A6: ( f . i ) = b;
i in N by A5,A6;
hence thesis by XXREAL_2:def 7;
end;
uniqueness
proof
let IT1 being (Element of ( NAT )),IT2 being (Element of ( NAT ));
assume that
A7: ( f . IT1 ) = b
and
A8: m < IT1
and
A9: (for i being (Element of ( NAT )) holds ((m < i & ( f . i ) = b) implies IT1 <= i))
and
A10: ( f . IT2 ) = b
and
A11: m < IT2
and
A12: (for i being (Element of ( NAT )) holds ((m < i & ( f . i ) = b) implies IT2 <= i));
assume A13: IT1 <> IT2;
per cases  by A13,XXREAL_0:1;
suppose IT1 < IT2;

hence contradiction by A7,A8,A12;
end;
suppose IT1 > IT2;

hence contradiction by A9,A10,A11;
end;
end;
end;
