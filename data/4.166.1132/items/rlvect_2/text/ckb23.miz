environ
vocabularies NUMBERS,FINSEQ_1,SUBSET_1,RLVECT_1,REAL_1,STRUCT_0,FUNCT_1,XBOOLE_0,ALGSTR_0,RELAT_1,PARTFUN1,ARYTM_3,CARD_3,ORDINAL4,XXREAL_0,TARSKI,CARD_1,SUPINF_2,ARYTM_1,NAT_1,FUNCT_2,FINSET_1,FUNCOP_1,VALUED_1,RLSUB_1,QC_LANG1,BINOP_1,ZFMISC_1,XREAL_0,ORDINAL1,RLVECT_2,LATTICES,VECTSP_1,PRE_POLY;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,CARD_1,ORDINAL1,NUMBERS,XCMPLX_0,XREAL_0,FINSET_1,FINSEQ_1,RELAT_1,FUNCT_1,RELSET_1,PRE_POLY,PARTFUN1,FUNCT_2,FUNCOP_1,DOMAIN_1,VALUED_1,FINSEQ_4,STRUCT_0,ALGSTR_0,GROUP_1,RLVECT_1,VECTSP_1,REAL_1,RLSUB_1,NAT_1,BINOP_1,XXREAL_0,CKB1,CKB9,CKB21,CKB22;
definitions FUNCT_1,RLSUB_1,TARSKI,XBOOLE_0,BINOP_1,RLVECT_1,RELAT_1,FUNCT_2,STRUCT_0,ALGSTR_0,CKB1,CKB9,CKB21;
theorems BINOP_1,CARD_1,CARD_2,ENUMSET1,FINSEQ_1,FINSEQ_2,FINSEQ_3,FINSEQ_4,FUNCT_1,FUNCT_2,NAT_1,RLSUB_1,RLSUB_2,RLVECT_1,TARSKI,ZFMISC_1,RELAT_1,RELSET_1,XBOOLE_0,XBOOLE_1,XCMPLX_1,FUNCOP_1,XREAL_1,XXREAL_0,ORDINAL1,STRUCT_0,PARTFUN1,VALUED_1,XREAL_0,VECTSP_1,PRE_POLY,CKB1,CKB2,CKB3,CKB4,CKB5,CKB6,CKB7,CKB8,CKB9,CKB10,CKB11,CKB12,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB21;
schemes BINOP_1,FINSEQ_1,FUNCT_2,NAT_1,XBOOLE_0;
registrations SUBSET_1,FUNCT_1,RELSET_1,FUNCT_2,FINSET_1,NUMBERS,XREAL_0,STRUCT_0,RLVECT_1,RLSUB_1,VALUED_1,VALUED_0,MEMBERED,FINSEQ_1,CARD_1,VECTSP_1,VECTSP_2;
constructors PARTFUN1,BINOP_1,DOMAIN_1,FUNCOP_1,XXREAL_0,REAL_1,NAT_1,FINSEQ_4,RLSUB_1,VALUED_1,RELSET_1,VECTSP_1,PRE_POLY,RLVECT_1,CKB1,CKB9,CKB21;
requirements REAL,NUMERALS,BOOLE,SUBSET,ARITHM;
begin
reserve x for set;
reserve V for RealLinearSpace;
reserve L for (Linear_Combination of V);
Lm1:now
let V being non  empty addLoopStr;
let L being (Element of ( Funcs ((the carrier of V),( REAL )) ));
A1: ( support L ) c= ( dom L ) by PRE_POLY:37;
thus ( Carrier L ) c= (the carrier of V)
proof
let x being set;
assume x in ( support L );
then x in ( dom L ) by A1;
hence thesis;
end;

end;
definition
let V being non  empty addLoopStr;
let L being (Element of ( Funcs ((the carrier of V),( REAL )) ));
redefine func Carrier L -> (Subset of V) equals 
{ v where v is (Element of V): ( L . v ) <> ( 0 ) };
coherence by Lm1;
compatibility
proof
let X being (Subset of V);
set A = ( Carrier L );
set B = { v where v is (Element of V): ( L . v ) <> ( 0 ) };
thus (X = A implies X = B)
proof
assume A1: X = A;
thus X c= B
proof
let x;
assume A2: x in X;
then ( L . x ) <> ( 0 ) by A1,PRE_POLY:def 7;
hence thesis by A2;
end;

let x being set;
assume x in B;
then (ex v being (Element of V) st (x = v & ( L . v ) <> ( 0 )));
hence thesis by A1,PRE_POLY:def 7;
end;

assume A3: X = B;
thus X c= A
proof
let x;
assume x in X;
then (ex v being (Element of V) st (x = v & ( L . v ) <> ( 0 ))) by A3;
hence thesis by PRE_POLY:def 7;
end;

let x;
assume A4: x in A;
then A5: ( L . x ) <> ( 0 ) by PRE_POLY:def 7;
( Carrier L ) c= (the carrier of V) by Lm1;
hence thesis by A3,A4,A5;
end;
end;
