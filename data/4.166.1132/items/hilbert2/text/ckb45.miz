environ
vocabularies NUMBERS,PBOOLE,FUNCT_1,CARD_3,RELAT_1,TARSKI,FINSEQ_1,ORDINAL4,XBOOLE_0,SUBSET_1,HILBERT1,TREES_1,TREES_A,CARD_1,ARYTM_3,TREES_2,TREES_4,TREES_3,TREES_9,FUNCT_6,QC_LANG1,XBOOLEAN,ZF_LANG,GLIB_000,XXREAL_0,NAT_1,ORDINAL1,ZFMISC_1,PARTFUN1,FUNCT_4,FUNCOP_1,HILBERT2;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,NUMBERS,CARD_3,RELAT_1,ORDINAL1,FUNCT_1,PARTFUN1,NAT_1,FINSEQ_1,FUNCOP_1,FUNCT_4,FUNCT_6,PBOOLE,TREES_1,TREES_2,TREES_3,TREES_4,TREES_9,HILBERT1,XXREAL_0,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
definitions TARSKI,FUNCT_1,HILBERT1,PARTFUN1,FUNCOP_1,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20;
theorems PBOOLE,ZFMISC_1,FUNCT_1,HILBERT1,ORDERS_1,SUBSET_1,TARSKI,FUNCT_4,FUNCOP_1,WELLFND1,CARD_3,GRFUNC_1,NAT_1,FINSEQ_1,TREES_1,TREES_4,TREES_2,TREES_9,FINSEQ_2,TREES_3,RELAT_1,ORDINAL1,XBOOLE_0,XBOOLE_1,XREAL_1,XXREAL_0,CARD_1,PARTFUN1,EQREL_1,CKB1,CKB2,CKB3,CKB4,CKB5,CKB7,CKB8,CKB9,CKB13,CKB14,CKB15,CKB16,CKB17,CKB18,CKB19,CKB20,CKB22,CKB23,CKB24,CKB25,CKB26,CKB27,CKB28,CKB29,CKB30,CKB31,CKB32,CKB33,CKB34,CKB35,CKB36,CKB37,CKB38,CKB39,CKB40,CKB41,CKB42;
schemes PBOOLE,NAT_1,FINSEQ_1,CKB6,CKB21,CKB43,CKB44;
registrations XBOOLE_0,SUBSET_1,RELAT_1,FUNCT_1,ORDINAL1,FUNCOP_1,XREAL_0,NAT_1,FINSEQ_1,TREES_2,TREES_3,HILBERT1,TREES_4,CKB10,CKB11,CKB12;
constructors PARTFUN1,FUNCT_4,XXREAL_0,XREAL_0,NAT_1,CARD_3,PBOOLE,TREES_4,TREES_9,HILBERT1,RELSET_1,CKB13,CKB18,CKB19,CKB20;
requirements NUMERALS,REAL,BOOLE,SUBSET,ARITHM;
begin
reserve n for (Element of ( NAT ));
reserve p for (Element of ( HP-WFF ));
reserve q for (Element of ( HP-WFF ));
reserve r for (Element of ( HP-WFF ));
reserve s for (Element of ( HP-WFF ));
definition
func HP-Subformulae -> (ManySortedSet of ( HP-WFF )) means 
:Def9: ((( it . ( VERUM ) ) = ( root-tree ( VERUM ) ) & (for n holds ( it . ( prop n ) ) = ( root-tree ( prop n ) ))) & (for p holds (for q holds (ex p9,q9 being (DecoratedTree of ( HP-WFF )) st (((p9 = ( it . p ) & q9 = ( it . q )) & ( it . ( p '&' q ) ) = ( ( p '&' q ) -tree (p9,q9) )) & ( it . ( p => q ) ) = ( ( p => q ) -tree (p9,q9) ))))));
existence
proof
deffunc P((Element of ( NAT ))) = ( root-tree ( prop $1 ) );
defpred I[ (Element of ( HP-WFF )),(Element of ( HP-WFF )),set,set,set ]
 means
((($3 is (DecoratedTree of ( HP-WFF )) & $4 is (DecoratedTree of ( HP-WFF ))) implies (ex p9,q9 being (DecoratedTree of ( HP-WFF )) st ((p9 = $3 & q9 = $4) & $5 = ( ( $1 => $2 ) -tree (p9,q9) )))) & (((not $3 is (DecoratedTree of ( HP-WFF ))) or (not $4 is (DecoratedTree of ( HP-WFF )))) implies $5 = ( {} )));
defpred C[ (Element of ( HP-WFF )),(Element of ( HP-WFF )),set,set,set ]
 means
((($3 is (DecoratedTree of ( HP-WFF )) & $4 is (DecoratedTree of ( HP-WFF ))) implies (ex p9,q9 being (DecoratedTree of ( HP-WFF )) st ((p9 = $3 & q9 = $4) & $5 = ( ( $1 '&' $2 ) -tree (p9,q9) )))) & (((not $3 is (DecoratedTree of ( HP-WFF ))) or (not $4 is (DecoratedTree of ( HP-WFF )))) implies $5 = ( {} )));
A1: (for p holds (for q holds (for a,b being set holds (ex c being set st C[ p,q,a,b,c ]))))
proof
let p;
let q;
let a being set;
let b being set;
per cases ;
suppose that A2: a is (DecoratedTree of ( HP-WFF ))
and
A3: b is (DecoratedTree of ( HP-WFF ));
reconsider q9 = b as (DecoratedTree of ( HP-WFF )) by A3;
reconsider p9 = a as (DecoratedTree of ( HP-WFF )) by A2;
take ( ( p '&' q ) -tree (p9,q9) );
thus thesis;
end;
suppose ((not a is (DecoratedTree of ( HP-WFF ))) or (not b is (DecoratedTree of ( HP-WFF ))));

hence thesis;
end;
end;
A4: (for p holds (for q holds (for a,b being set holds (ex d being set st I[ p,q,a,b,d ]))))
proof
let p;
let q;
let a being set;
let b being set;
per cases ;
suppose that A5: a is (DecoratedTree of ( HP-WFF ))
and
A6: b is (DecoratedTree of ( HP-WFF ));
reconsider q9 = b as (DecoratedTree of ( HP-WFF )) by A6;
reconsider p9 = a as (DecoratedTree of ( HP-WFF )) by A5;
take ( ( p => q ) -tree (p9,q9) );
thus thesis;
end;
suppose ((not a is (DecoratedTree of ( HP-WFF ))) or (not b is (DecoratedTree of ( HP-WFF ))));

hence thesis;
end;
end;
A7: (for p holds (for q holds (for a,b,c,d being set holds ((I[ p,q,a,b,c ] & I[ p,q,a,b,d ]) implies c = d))));
A8: (for p holds (for q holds (for a,b,c,d being set holds ((C[ p,q,a,b,c ] & C[ p,q,a,b,d ]) implies c = d))));
consider M being (ManySortedSet of ( HP-WFF )) such that A9: ( M . ( VERUM ) ) = ( root-tree ( VERUM ) ) and A10: (for n holds ( M . ( prop n ) ) = P(n)) and A11: (for p holds (for q holds (C[ p,q,( M . p ),( M . q ),( M . ( p '&' q ) ) ] & I[ p,q,( M . p ),( M . q ),( M . ( p => q ) ) ]))) from CKB43:sch 1(A1,A4,A8,A7);
take M;
thus ( M . ( VERUM ) ) = ( root-tree ( VERUM ) ) by A9;
thus (for n holds ( M . ( prop n ) ) = ( root-tree ( prop n ) )) by A10;
let p;
let q;
A12: (C[ p,q,( M . p ),( M . q ),( M . ( p '&' q ) ) ] & I[ p,q,( M . p ),( M . q ),( M . ( p => q ) ) ]) by A11;
defpred P[ (Element of ( HP-WFF )) ]
 means
( M . $1 ) is (DecoratedTree of ( HP-WFF ));
A13: (for r holds (for s holds ((P[ r ] & P[ s ]) implies (P[ ( r '&' s ) ] & P[ ( r => s ) ]))))
proof
let r;
let s;
assume that
A14: (( M . r ) is (DecoratedTree of ( HP-WFF )) & ( M . s ) is (DecoratedTree of ( HP-WFF )));
C[ r,s,( M . r ),( M . s ),( M . ( r '&' s ) ) ] by A11;
hence ( M . ( r '&' s ) ) is (DecoratedTree of ( HP-WFF )) by A14;
I[ r,s,( M . r ),( M . s ),( M . ( r => s ) ) ] by A11;
hence thesis by A14;
end;
A15: (for n holds P[ ( prop n ) ])
proof
let n;
( M . ( prop n ) ) = ( root-tree ( prop n ) ) by A10;
hence thesis;
end;
A16: P[ ( VERUM ) ] by A9;
(for p holds P[ p ]) from CKB21:sch 1(A16,A15,A13);
hence thesis by A12;
end;
uniqueness
proof
let M1 being (ManySortedSet of ( HP-WFF ));
let M2 being (ManySortedSet of ( HP-WFF ));
assume that
A17: ( M1 . ( VERUM ) ) = ( root-tree ( VERUM ) )
and
A18: (for n holds ( M1 . ( prop n ) ) = ( root-tree ( prop n ) ))
and
A19: (for p holds (for q holds (ex p9,q9 being (DecoratedTree of ( HP-WFF )) st (((p9 = ( M1 . p ) & q9 = ( M1 . q )) & ( M1 . ( p '&' q ) ) = ( ( p '&' q ) -tree (p9,q9) )) & ( M1 . ( p => q ) ) = ( ( p => q ) -tree (p9,q9) )))))
and
A20: ( M2 . ( VERUM ) ) = ( root-tree ( VERUM ) )
and
A21: (for n holds ( M2 . ( prop n ) ) = ( root-tree ( prop n ) ))
and
A22: (for p holds (for q holds (ex p9,q9 being (DecoratedTree of ( HP-WFF )) st (((p9 = ( M2 . p ) & q9 = ( M2 . q )) & ( M2 . ( p '&' q ) ) = ( ( p '&' q ) -tree (p9,q9) )) & ( M2 . ( p => q ) ) = ( ( p => q ) -tree (p9,q9) )))));
defpred P[ (Element of ( HP-WFF )) ]
 means
( M1 . $1 ) = ( M2 . $1 );
A23: (for n holds P[ ( prop n ) ])
proof
let n;
thus ( M1 . ( prop n ) ) = ( root-tree ( prop n ) ) by A18
.= ( M2 . ( prop n ) ) by A21;
end;
A24: (for r holds (for s holds ((P[ r ] & P[ s ]) implies (P[ ( r '&' s ) ] & P[ ( r => s ) ]))))
proof
let r;
let s;
assume that
A25: (( M1 . r ) = ( M2 . r ) & ( M1 . s ) = ( M2 . s ));
A26: ((ex p9,q9 being (DecoratedTree of ( HP-WFF )) st (((p9 = ( M1 . r ) & q9 = ( M1 . s )) & ( M1 . ( r '&' s ) ) = ( ( r '&' s ) -tree (p9,q9) )) & ( M1 . ( r => s ) ) = ( ( r => s ) -tree (p9,q9) ))) & (ex p9,q9 being (DecoratedTree of ( HP-WFF )) st (((p9 = ( M2 . r ) & q9 = ( M2 . s )) & ( M2 . ( r '&' s ) ) = ( ( r '&' s ) -tree (p9,q9) )) & ( M2 . ( r => s ) ) = ( ( r => s ) -tree (p9,q9) )))) by A19,A22;
hence ( M1 . ( r '&' s ) ) = ( M2 . ( r '&' s ) ) by A25;
thus thesis by A25,A26;
end;
A27: P[ ( VERUM ) ] by A17,A20;
(for r holds P[ r ]) from CKB21:sch 1(A27,A23,A24);
then (for r being set holds (r in ( HP-WFF ) implies ( M1 . r ) = ( M2 . r )));
hence M1 = M2 by PBOOLE:3;
end;
end;
