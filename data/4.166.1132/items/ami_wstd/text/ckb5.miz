environ
vocabularies NUMBERS,XBOOLE_0,SUBSET_1,ORDINAL1,SETFAM_1,AMI_1,FSM_1,FUNCT_4,FUNCOP_1,RELAT_1,TARSKI,FUNCT_1,CARD_3,ZFMISC_1,CIRCUIT2,NAT_1,GLIB_000,XXREAL_0,PARTFUN1,FINSEQ_1,ARYTM_3,GRAPH_2,CARD_1,FUNCT_2,FINSEQ_4,ARYTM_1,FINSET_1,FRECHET,RCOMP_1,WAYBEL_0,MEMBERED,AMISTD_1,SCMNORM,AMI_WSTD,STRUCT_0,PBOOLE,COMPOS_1;
notations TARSKI,XBOOLE_0,ZFMISC_1,SUBSET_1,RELAT_1,SETFAM_1,ORDINAL1,CARD_1,XXREAL_0,NUMBERS,XCMPLX_0,NAT_1,MEMBERED,FUNCT_1,RELSET_1,PARTFUN1,MCART_1,DOMAIN_1,CARD_3,FINSEQ_1,FINSEQ_4,FUNCOP_1,FINSET_1,FUNCT_4,FUNCT_7,PBOOLE,AFINSQ_1,STRUCT_0,GRAPH_2,NAT_D,XXREAL_2,MEMSTR_0,COMPOS_1,EXTPRO_1,FUNCT_2,AMISTD_1,CKB1,CKB3,CKB4;
definitions TARSKI,STRUCT_0,COMPOS_1,EXTPRO_1,XBOOLE_0,FUNCOP_1,NAT_1,RELAT_1,FUNCT_4,NAT_D,AFINSQ_1,AMISTD_1,MEMSTR_0,CKB1,CKB3,CKB4;
theorems TARSKI,FINSEQ_4,FINSEQ_1,GRAPH_2,NAT_1,FUNCT_4,FUNCT_1,FUNCT_2,RELAT_1,ZFMISC_1,CARD_1,FUNCOP_1,ORDINAL1,GRFUNC_1,FINSEQ_3,INT_1,REVROT_1,FUNCT_7,XBOOLE_0,MEMBERED,XREAL_1,XXREAL_0,FINSEQ_6,PARTFUN1,XXREAL_2,XREAL_0,NAT_D,PBOOLE,RECDEF_2,AMISTD_1,COMPOS_1,MEMSTR_0,CARD_3,CKB1,CKB2,CKB3,CKB4;
schemes NAT_1,FUNCT_7,FINSEQ_2,FRAENKEL,DOMAIN_1,FINSEQ_4;
registrations XBOOLE_0,SETFAM_1,RELAT_1,FUNCT_1,PARTFUN1,FUNCT_2,FUNCOP_1,FINSET_1,NUMBERS,XREAL_0,NAT_1,MEMBERED,FINSEQ_1,CARD_3,REALSET1,FUNCT_7,STRUCT_0,JORDAN1J,CARD_1,XXREAL_2,RELSET_1,FUNCT_4,AFINSQ_1,ORDINAL1,ZFMISC_1,SUBSET_1,AMISTD_1,COMPOS_1,EXTPRO_1,PBOOLE,VALUED_1,PRE_POLY,MEMSTR_0;
constructors WELLORD2,REAL_1,FINSEQ_4,REALSET1,NAT_D,XXREAL_2,RELSET_1,PRE_POLY,GRAPH_2,AFINSQ_1,MCART_1,AMISTD_1,PBOOLE,FUNCT_7,FUNCT_4,MEMSTR_0,CKB1,CKB3,CKB4;
requirements NUMERALS,BOOLE,REAL,SUBSET,ARITHM;
begin
reserve N for  with_non-empty_elements non  empty set;
reserve S for  IC-Ins-separated non  empty AMI-Struct over N;
theorem
Th17: (for f1,f2 being (Function of ( NAT ),( NAT )) holds ((((f1 is  bijective & (for m,n being (Element of ( NAT )) holds (m <= n iff ( f1 . m ) <= ( f1 . n ),S))) & f2 is  bijective) & (for m,n being (Element of ( NAT )) holds (m <= n iff ( f2 . m ) <= ( f2 . n ),S))) implies f1 = f2))
proof
let f1 being (Function of ( NAT ),( NAT ));
let f2 being (Function of ( NAT ),( NAT ));
assume that
A1: f1 is  bijective
and
A2: (for m,n being (Element of ( NAT )) holds (m <= n iff ( f1 . m ) <= ( f1 . n ),S))
and
A3: f2 is  bijective
and
A4: (for m,n being (Element of ( NAT )) holds (m <= n iff ( f2 . m ) <= ( f2 . n ),S));
A5: ( dom f1 ) = ( NAT ) by FUNCT_2:def 1;
A6: ( dom f2 ) = ( NAT ) by FUNCT_2:def 1;
defpred P[ Nat ]
 means
( f1 . $1 ) <> ( f2 . $1 );
assume f1 <> f2;
then (ex c being (Element of ( NAT )) st P[ c ]) by FUNCT_2:63;
then A7: (ex c being Nat st P[ c ]);
consider d being Nat such that A8: P[ d ] and A9: (for n being Nat holds (P[ n ] implies d <= n)) from NAT_1:sch 5(A7);
reconsider d as (Element of ( NAT )) by ORDINAL1:def 12;
A10: ( rng f1 ) = ( NAT ) by A1,FUNCT_2:def 3;
A11: ( rng f2 ) = ( NAT ) by A3,FUNCT_2:def 3;
consider d1 being set such that A12: d1 in ( dom f1 ) and A13: ( f2 . d ) = ( f1 . d1 ) by A10,FUNCT_1:def 3;
reconsider d1 as (Element of ( NAT )) by A12;
consider d2 being set such that A14: d2 in ( dom f2 ) and A15: ( f1 . d ) = ( f2 . d2 ) by A11,FUNCT_1:def 3;
reconsider d2 as (Element of ( NAT )) by A14;
per cases ;
suppose A16: (d1 <= d & d2 <= d);

then ( f2 . d2 ) <= ( f2 . d ),S by A4;
then d <= d1 by A2,A15,A13;
hence contradiction by A8,A13,A16,XXREAL_0:1;
end;
suppose A17: (d <= d1 & d2 <= d);

( f2 . d2 ) = ( f1 . d2 )
proof
assume (not thesis);
then d <= d2 by A9;
hence contradiction by A8,A15,A17,XXREAL_0:1;
end;
hence contradiction by A1,A8,A15,A5,FUNCT_1:def 4;
end;
suppose A18: (d1 <= d & d <= d2);

( f1 . d1 ) = ( f2 . d1 )
proof
assume (not thesis);
then d <= d1 by A9;
hence contradiction by A8,A13,A18,XXREAL_0:1;
end;
hence contradiction by A3,A8,A13,A6,FUNCT_1:def 4;
end;
suppose A19: (d <= d1 & d <= d2);

then ( f2 . d ) <= ( f2 . d2 ),S by A4;
then d1 <= d by A2,A15,A13;
hence contradiction by A8,A13,A19,XXREAL_0:1;
end;
end;
