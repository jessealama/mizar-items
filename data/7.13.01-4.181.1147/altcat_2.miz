:: Examples of Category Structures.Subcategories
::  by Andrzej Trybulec
::
:: Received January 22, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies ZFMISC_1, FUNCOP_1, RELAT_1, FUNCT_1, PBOOLE, PZFMISC1, MEMBER_1,
      XBOOLE_0, PARTFUN1, SUBSET_1, TARSKI, CAT_1, MCART_1, GRAPH_1, STRUCT_0,
      ALTCAT_1, BINOP_1, RELAT_2, REALSET1, ALTCAT_2, MONOID_0, RECDEF_2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, XTUPLE_0, MCART_1,
      FUNCT_1, PZFMISC1, REALSET1, DOMAIN_1, STRUCT_0, PARTFUN1, FUNCT_2,
      BINOP_1, MULTOP_1, FUNCT_3, FUNCT_4, GRAPH_1, CAT_1, PBOOLE, FUNCOP_1,
      ALTCAT_1;
 constructors FUNCT_3, REALSET1, PZFMISC1, CAT_1, ALTCAT_1, RELSET_1, FUNCT_4,
      XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, RELAT_1, PBOOLE, FUNCOP_1,
      REALSET1, STRUCT_0, ALTCAT_1, CAT_1, PRALG_1, RELSET_1, XTUPLE_0;
 requirements SUBSET, BOOLE;
 definitions STRUCT_0, ALTCAT_1, FUNCOP_1, FUNCT_1, RELAT_1, TARSKI, PBOOLE,
      BINOP_1, REALSET1, CAT_1, XTUPLE_0;
 theorems MCART_1, ALTCAT_1, PBOOLE, TARSKI, GRFUNC_1, ZFMISC_1, MULTOP_1,
      RELAT_1, FUNCT_2, FUNCOP_1, FUNCT_4, FUNCT_1, FUNCT_3, DOMAIN_1,
      MSSUBFAM, FUNCT_7, CAT_1, RELSET_1, XBOOLE_0, XBOOLE_1, PZFMISC1,
      PARTFUN1, XTUPLE_0;
 schemes ALTCAT_1, FUNCT_1;

begin
theorem
L1: (for B1 , B2 being set holds (for B3 , B4 being set holds [: ( B1 --> B3 ) , ( B2 --> B4 ) :] = ( [: B1 , B2 :] --> [ B3 , B4 ] )))
proof
let C1 , C2 being set;
let C3 , C4 being set;
L2: (( dom ( C1 --> C3 ) ) = C1 & ( dom ( C2 --> C4 ) ) = C2) by FUNCOP_1:13;
L3: ( dom ( [: C1 , C2 :] --> [ C3 , C4 ] ) ) = [: ( dom ( C1 --> C3 ) ) , ( dom ( C2 --> C4 ) ) :] by L2 , FUNCOP_1:13;
L4:
now
let C5 , C6 being set;
assume L5: (C5 in ( dom ( C1 --> C3 ) ) & C6 in ( dom ( C2 --> C4 ) ));
L6: [ C5 , C6 ] in ( dom ( [: C1 , C2 :] --> [ C3 , C4 ] ) ) by L5 , L3 , ZFMISC_1:87;
L7: [ C5 , C6 ] in [: C1 , C2 :] by L6 , FUNCOP_1:13;
L8: (( ( C1 --> C3 ) . C5 ) = C3 & ( ( C2 --> C4 ) . C6 ) = C4) by L2 , L5 , FUNCOP_1:7;
thus L9: ( ( [: C1 , C2 :] --> [ C3 , C4 ] ) . (C5 , C6) ) = [ ( ( C1 --> C3 ) . C5 ) , ( ( C2 --> C4 ) . C6 ) ] by L8 , L7 , FUNCOP_1:7;
end;
thus L10: thesis by L4 , L3 , FUNCT_3:def 8;
end;
registration
let C7 being set;
cluster ( [[0]] C7 ) ->  Function-yielding;
coherence;
end;
theorem
L12: (for B5 , B6 being Function holds ( ~ ( B6 * B5 ) ) = ( B6 * ( ~ B5 ) ))
proof
let C8 , C9 being Function;
L13:
now
let C10 being set;
thus L14:now
assume L15: C10 in ( dom ( C9 * ( ~ C8 ) ) );
L16: C10 in ( dom ( ~ C8 ) ) by L15 , FUNCT_1:11;
consider C11 , C12 being set such that L17: C10 = [ C12 , C11 ] and L18: [ C11 , C12 ] in ( dom C8 ) by L16 , FUNCT_4:def 2;
take D1 = C11;
take D2 = C12;
thus L19: C10 = [ D2 , D1 ] by L17;
L20: ( ( ~ C8 ) . (D2 , D1) ) in ( dom C9 ) by L15 , L17 , FUNCT_1:11;
L21: ( C8 . (D1 , D2) ) in ( dom C9 ) by L20 , L18 , FUNCT_4:def 2;
thus L22: [ D1 , D2 ] in ( dom ( C9 * C8 ) ) by L21 , L18 , FUNCT_1:11;
end;
given C13 , C14 being set such that
L23: C10 = [ C14 , C13 ]
and
L24: [ C13 , C14 ] in ( dom ( C9 * C8 ) );

L25: [ C13 , C14 ] in ( dom C8 ) by L24 , FUNCT_1:11;
L26: C10 in ( dom ( ~ C8 ) ) by L25 , L23 , FUNCT_4:def 2;
L27: ( C8 . (C13 , C14) ) in ( dom C9 ) by L24 , FUNCT_1:11;
L28: ( ( ~ C8 ) . (C14 , C13) ) in ( dom C9 ) by L27 , L25 , FUNCT_4:def 2;
thus L29: C10 in ( dom ( C9 * ( ~ C8 ) ) ) by L28 , L23 , L26 , FUNCT_1:11;
end;
L30:
now
let C15 , C16 being set;
assume L31: [ C15 , C16 ] in ( dom ( C9 * C8 ) );
L32: [ C15 , C16 ] in ( dom C8 ) by L31 , FUNCT_1:11;
L33: [ C16 , C15 ] in ( dom ( ~ C8 ) ) by L32 , FUNCT_4:42;
thus L34: ( ( C9 * ( ~ C8 ) ) . (C16 , C15) ) = ( C9 . ( ( ~ C8 ) . (C16 , C15) ) ) by L33 , FUNCT_1:13
.= ( C9 . ( C8 . (C15 , C16) ) ) by L33 , FUNCT_4:43
.= ( ( C9 * C8 ) . (C15 , C16) ) by L31 , FUNCT_1:12;
end;
thus L35: thesis by L30 , L13 , FUNCT_4:def 2;
end;
theorem
L36: (for B7 , B8 , B9 being Function holds ( ~ ( B7 * [: B8 , B9 :] ) ) = ( ( ~ B7 ) * [: B9 , B8 :] ))
proof
let C17 , C18 , C19 being Function;
L37:
now
let C20 being set;
thus L38:now
assume L39: C20 in ( dom ( ( ~ C17 ) * [: C19 , C18 :] ) );
L40: C20 in ( dom [: C19 , C18 :] ) by L39 , FUNCT_1:11;
L41: C20 in [: ( dom C19 ) , ( dom C18 ) :] by L40 , FUNCT_3:def 8;
consider C21 , C22 being set such that L42: (C21 in ( dom C19 ) & C22 in ( dom C18 )) and L43: C20 = [ C21 , C22 ] by L41 , ZFMISC_1:84;
L44: (( [: C19 , C18 :] . (C21 , C22) ) = [ ( C19 . C21 ) , ( C18 . C22 ) ] & ( [: C18 , C19 :] . (C22 , C21) ) = [ ( C18 . C22 ) , ( C19 . C21 ) ]) by L42 , FUNCT_3:def 8;
L45: ( [: C19 , C18 :] . (C21 , C22) ) in ( dom ( ~ C17 ) ) by L39 , L43 , FUNCT_1:11;
L46: ( [: C18 , C19 :] . (C22 , C21) ) in ( dom C17 ) by L45 , L44 , FUNCT_4:42;
take D3 = C22;
take D4 = C21;
thus L47: C20 = [ D4 , D3 ] by L43;
L48: ( dom [: C18 , C19 :] ) = [: ( dom C18 ) , ( dom C19 ) :] by FUNCT_3:def 8;
L49: [ D3 , D4 ] in ( dom [: C18 , C19 :] ) by L48 , L42 , ZFMISC_1:87;
thus L50: [ D3 , D4 ] in ( dom ( C17 * [: C18 , C19 :] ) ) by L49 , L46 , FUNCT_1:11;
end;
given C23 , C24 being set such that
L51: C20 = [ C24 , C23 ]
and
L52: [ C23 , C24 ] in ( dom ( C17 * [: C18 , C19 :] ) );

L53: ( [: C18 , C19 :] . (C23 , C24) ) in ( dom C17 ) by L52 , FUNCT_1:11;
L54: ( dom [: C18 , C19 :] ) = [: ( dom C18 ) , ( dom C19 ) :] by FUNCT_3:def 8;
L55: [ C23 , C24 ] in ( dom [: C18 , C19 :] ) by L52 , FUNCT_1:11;
L56: (C23 in ( dom C18 ) & C24 in ( dom C19 )) by L55 , L54 , ZFMISC_1:87;
L57: (( [: C18 , C19 :] . (C23 , C24) ) = [ ( C18 . C23 ) , ( C19 . C24 ) ] & ( [: C19 , C18 :] . (C24 , C23) ) = [ ( C19 . C24 ) , ( C18 . C23 ) ]) by L56 , FUNCT_3:def 8;
L58: ( [: C19 , C18 :] . C20 ) in ( dom ( ~ C17 ) ) by L57 , L51 , L53 , FUNCT_4:42;
L59: ( dom [: C19 , C18 :] ) = [: ( dom C19 ) , ( dom C18 ) :] by FUNCT_3:def 8;
L60: C20 in ( dom [: C19 , C18 :] ) by L59 , L51 , L56 , ZFMISC_1:87;
thus L61: C20 in ( dom ( ( ~ C17 ) * [: C19 , C18 :] ) ) by L60 , L58 , FUNCT_1:11;
end;
L62:
now
let C25 , C26 being set;
assume L63: [ C25 , C26 ] in ( dom ( C17 * [: C18 , C19 :] ) );
L64: [ C25 , C26 ] in ( dom [: C18 , C19 :] ) by L63 , FUNCT_1:11;
L65: [ C25 , C26 ] in [: ( dom C18 ) , ( dom C19 ) :] by L64 , FUNCT_3:def 8;
L66: (C25 in ( dom C18 ) & C26 in ( dom C19 )) by L65 , ZFMISC_1:87;
L67: ( [: C18 , C19 :] . (C25 , C26) ) in ( dom C17 ) by L63 , FUNCT_1:11;
L68: [ ( C18 . C25 ) , ( C19 . C26 ) ] in ( dom C17 ) by L67 , L66 , FUNCT_3:def 8;
L69: [ C26 , C25 ] in [: ( dom C19 ) , ( dom C18 ) :] by L66 , ZFMISC_1:87;
L70: [ C26 , C25 ] in ( dom [: C19 , C18 :] ) by L69 , FUNCT_3:def 8;
thus L71: ( ( ( ~ C17 ) * [: C19 , C18 :] ) . (C26 , C25) ) = ( ( ~ C17 ) . ( [: C19 , C18 :] . (C26 , C25) ) ) by L70 , FUNCT_1:13
.= ( ( ~ C17 ) . (( C19 . C26 ) , ( C18 . C25 )) ) by L66 , FUNCT_3:def 8
.= ( C17 . (( C18 . C25 ) , ( C19 . C26 )) ) by L68 , FUNCT_4:def 2
.= ( C17 . ( [: C18 , C19 :] . (C25 , C26) ) ) by L66 , FUNCT_3:def 8
.= ( ( C17 * [: C18 , C19 :] ) . (C25 , C26) ) by L63 , FUNCT_1:12;
end;
thus L72: thesis by L62 , L37 , FUNCT_4:def 2;
end;
registration
let C27 being  Function-yielding Function;
cluster ( ~ C27 ) ->  Function-yielding;
coherence
proof
let C28 being set;
assume L73: C28 in ( dom ( ~ C27 ) );
consider C29 , C30 being set such that L74: C28 = [ C30 , C29 ] and L75: [ C29 , C30 ] in ( dom C27 ) by L73 , FUNCT_4:def 2;
L76: ( C27 . (C29 , C30) ) = ( ( ~ C27 ) . (C30 , C29) ) by L75 , FUNCT_4:def 2;
thus L77: thesis by L76 , L74;
end;
end;
theorem
L79: (for B10 being set holds (for B11 , B12 , B13 being (ManySortedSet of B10) holds (B11 is_transformable_to B12 implies (for B14 being (ManySortedFunction of B11 , B12) holds (for B15 being (ManySortedFunction of B12 , B13) holds ( B15 ** B14 ) is (ManySortedFunction of B11 , B13))))))
proof
let C31 being set;
let C32 , C33 , C34 being (ManySortedSet of C31);
assume that
L80: C32 is_transformable_to C33;
let C35 being (ManySortedFunction of C32 , C33);
let C36 being (ManySortedFunction of C33 , C34);
reconsider D5 = ( C36 ** C35 ) as (ManySortedFunction of C31) by MSSUBFAM:15;
L81: D5 is (ManySortedFunction of C32 , C34)
proof
let C37 being set;
assume L82: C37 in C31;
reconsider D6 = ( C36 . C37 ) as (Function of ( C33 . C37 ) , ( C34 . C37 )) by L82 , PBOOLE:def 15;
reconsider D7 = ( C35 . C37 ) as (Function of ( C32 . C37 ) , ( C33 . C37 )) by L82 , PBOOLE:def 15;
L83: C37 in ( dom D5 ) by L82 , PARTFUN1:def 2;
L84: ( ( C36 ** C35 ) . C37 ) = ( D6 * D7 ) by L83 , PBOOLE:def 19;
L85: (( C33 . C37 ) = ( {} ) implies ( C32 . C37 ) = ( {} )) by L80 , L82 , PZFMISC1:def 3;
thus L86: thesis by L85 , L84 , FUNCT_2:13;
end;
thus L87: thesis by L81;
end;
registration
let C38 being set;
let C39 being (ManySortedSet of [: C38 , C38 :]);
cluster ( ~ C39 ) -> [: C38 , C38 :] -defined;
coherence;
end;
registration
let C40 being set;
let C41 being (ManySortedSet of [: C40 , C40 :]);
cluster ( ~ C41 ) ->  total for [: C40 , C40 :] -defined [: C40 , C40 :] -defined [: C40 , C40 :] -defined [: C40 , C40 :] -defined Function;
coherence;
end;
theorem
L90: (for B16 being set holds (for B17 being non  empty set holds (for B18 being (Function of B16 , B17) holds (for B19 , B20 being (ManySortedSet of B17) holds (for B21 being (ManySortedFunction of B19 , B20) holds ( B21 * B18 ) is (ManySortedFunction of ( B19 * B18 ) , ( B20 * B18 )))))))
proof
let C42 being set;
let C43 being non  empty set;
let C44 being (Function of C42 , C43);
let C45 , C46 being (ManySortedSet of C43);
let C47 being (ManySortedFunction of C45 , C46);
let C48 being set;
assume L91: C48 in C42;
L92: ( C47 . ( C44 . C48 ) ) is (Function of ( C45 . ( C44 . C48 ) ) , ( C46 . ( C44 . C48 ) )) by L91 , FUNCT_2:5 , PBOOLE:def 15;
L93: C48 in ( dom C44 ) by L91 , FUNCT_2:def 1;
L94: (( C45 . ( C44 . C48 ) ) = ( ( C45 * C44 ) . C48 ) & ( C46 . ( C44 . C48 ) ) = ( ( C46 * C44 ) . C48 )) by L93 , FUNCT_1:13;
thus L95: thesis by L94 , L93 , L92 , FUNCT_1:13;
end;
definition
let C49 being set;
let C50 , C51 being (ManySortedSet of [: C49 , C49 :]);
let C52 being (ManySortedFunction of C50 , C51);
redefine func ~ C52 -> (ManySortedFunction of ( ~ C50 ) , ( ~ C51 ));

coherence
proof
reconsider D8 = ( ~ C52 ) as (ManySortedSet of [: C49 , C49 :]);
L96: D8 is (ManySortedFunction of ( ~ C50 ) , ( ~ C51 ))
proof
let C53 being set;
assume L97: C53 in [: C49 , C49 :];
consider C54 , C55 being set such that L98: (C54 in C49 & C55 in C49) and L99: C53 = [ C54 , C55 ] by L97 , ZFMISC_1:84;
L100: [ C55 , C54 ] in [: C49 , C49 :] by L98 , ZFMISC_1:87;
L101: ( dom C51 ) = [: C49 , C49 :] by PARTFUN1:def 2;
L102: ( C51 . (C55 , C54) ) = ( ( ~ C51 ) . (C54 , C55) ) by L101 , L100 , FUNCT_4:def 2;
L103: ( dom C50 ) = [: C49 , C49 :] by PARTFUN1:def 2;
L104: ( C50 . (C55 , C54) ) = ( ( ~ C50 ) . (C54 , C55) ) by L103 , L100 , FUNCT_4:def 2;
L105: ( dom C52 ) = [: C49 , C49 :] by PARTFUN1:def 2;
L106: ( C52 . (C55 , C54) ) = ( D8 . (C54 , C55) ) by L105 , L100 , FUNCT_4:def 2;
thus L107: thesis by L106 , L99 , L100 , L104 , L102 , PBOOLE:def 15;
end;
thus L108: thesis by L96;
end;
end;
theorem
L110: (for B22 , B23 being non  empty set holds (for B24 being (ManySortedSet of [: B22 , B23 :]) holds (for B25 being (Element of B22) holds (for B26 being (Element of B23) holds ( ( ~ B24 ) . (B26 , B25) ) = ( B24 . (B25 , B26) )))))
proof
let C56 , C57 being non  empty set;
let C58 being (ManySortedSet of [: C56 , C57 :]);
let C59 being (Element of C56);
let C60 being (Element of C57);
L111: [ C59 , C60 ] in [: C56 , C57 :];
L112: [ C59 , C60 ] in ( dom C58 ) by L111 , PARTFUN1:def 2;
thus L113: thesis by L112 , FUNCT_4:def 2;
end;
registration
let C61 being set;
let C62 , C63 being (ManySortedFunction of C61);
cluster ( C63 ** C62 ) -> C61 -defined;
coherence
proof
L114: (( dom C62 ) = C61 & ( dom C63 ) = C61) by PARTFUN1:def 2;
L115: ( dom ( C63 ** C62 ) ) = ( ( dom C63 ) /\ ( dom C62 ) ) by PBOOLE:def 19
.= C61 by L114;
thus L116: thesis by L115 , RELAT_1:def 18;
end;
end;
registration
let C64 being set;
let C65 , C66 being (ManySortedFunction of C64);
cluster ( C66 ** C65 ) ->  total;
coherence
proof
L118: (( dom C65 ) = C64 & ( dom C66 ) = C64) by PARTFUN1:def 2;
L119: ( dom ( C66 ** C65 ) ) = ( ( dom C66 ) /\ ( dom C65 ) ) by PBOOLE:def 19
.= C64 by L118;
thus L120: thesis by L119 , PARTFUN1:def 2;
end;
end;
begin
definition
let C67 , C68 being Function;
pred C67 cc= C68
means
:L122: (( dom C67 ) c= ( dom C68 ) & (for B27 being set holds (B27 in ( dom C67 ) implies ( C67 . B27 ) c= ( C68 . B27 ))))
;reflexivity
;
end;
definition
let C69 , C70 being set;
let C71 being (ManySortedSet of C69);
let C72 being (ManySortedSet of C70);
redefine pred C71 cc= C72
means
:L124: (C69 c= C70 & (for B28 being set holds (B28 in C69 implies ( C71 . B28 ) c= ( C72 . B28 ))))
;compatibility
proof
L125: ( dom C71 ) = C69 by PARTFUN1:def 2;
L126: ( dom C72 ) = C70 by PARTFUN1:def 2;
thus L127: (C71 cc= C72 implies (C69 c= C70 & (for B29 being set holds (B29 in C69 implies ( C71 . B29 ) c= ( C72 . B29 ))))) by L126 , L125 , L122;
assume that
L128: C69 c= C70
and
L129: (for B30 being set holds (B30 in C69 implies ( C71 . B30 ) c= ( C72 . B30 )));
thus L130: ( dom C71 ) c= ( dom C72 ) by L125 , L128 , PARTFUN1:def 2;
let C73 being set;
assume L131: C73 in ( dom C71 );
thus L132: thesis by L131 , L125 , L129;
end;
end;
theorem
L134: (for B31 , B32 being set holds (for B33 being (ManySortedSet of B31) holds (for B34 being (ManySortedSet of B32) holds ((B33 cc= B34 & B34 cc= B33) implies B33 = B34))))
proof
let C74 , C75 being set;
let C76 being (ManySortedSet of C74);
let C77 being (ManySortedSet of C75);
assume that
L135: C76 cc= C77
and
L136: C77 cc= C76;
L137: C74 c= C75 by L135 , L124;
L138: C75 c= C74 by L136 , L124;
L139: C74 = C75 by L138 , L137 , XBOOLE_0:def 10;
reconsider D9 = C77 as (ManySortedSet of C74) by L139;
L140:
now
let C78 being set;
assume L141: C78 in C74;
L142: (( C76 . C78 ) c= ( C77 . C78 ) & ( C77 . C78 ) c= ( C76 . C78 )) by L141 , L135 , L136 , L137 , L124;
thus L143: ( C76 . C78 ) = ( D9 . C78 ) by L142 , XBOOLE_0:def 10;
end;
thus L144: thesis by L140 , PBOOLE:3;
end;
theorem
L145: (for B35 , B36 , B37 being set holds (for B38 being (ManySortedSet of B35) holds (for B39 being (ManySortedSet of B36) holds (for B40 being (ManySortedSet of B37) holds ((B38 cc= B39 & B39 cc= B40) implies B38 cc= B40)))))
proof
let C79 , C80 , C81 being set;
let C82 being (ManySortedSet of C79);
let C83 being (ManySortedSet of C80);
let C84 being (ManySortedSet of C81);
assume that
L146: C82 cc= C83
and
L147: C83 cc= C84;
L148: C79 c= C80 by L146 , L124;
L149: C80 c= C81 by L147 , L124;
thus L150: C79 c= C81 by L149 , L148 , XBOOLE_1:1;
let C85 being set;
assume L151: C85 in C79;
L152: ( C82 . C85 ) c= ( C83 . C85 ) by L151 , L146 , L124;
L153: ( C83 . C85 ) c= ( C84 . C85 ) by L147 , L148 , L151 , L124;
thus L154: thesis by L153 , L152 , XBOOLE_1:1;
end;
theorem
L155: (for B41 being set holds (for B42 being (ManySortedSet of B41) holds (for B43 being (ManySortedSet of B41) holds (B42 cc= B43 iff B42 c= B43))))
proof
let C86 being set;
let C87 being (ManySortedSet of C86);
let C88 being (ManySortedSet of C86);
thus L156: (C87 cc= C88 implies C87 c= C88)
proof
assume L157: C87 cc= C88;
let C89 being set;
thus L158: thesis by L157 , L124;
end;

assume L159: C87 c= C88;
thus L160: C86 c= C86;
thus L161: thesis by L159 , PBOOLE:def 2;
end;
begin
scheme OnSingletons { F1() -> non  empty set , F2(set) -> set , P1[set] } : { [ B44 , F2(B44) ] where B44 is (Element of F1()) : P1[ B44 ] } is Function
proof
set D10 = { [ B45 , F2(B45) ] where B45 is (Element of F1()) : P1[ B45 ] };
L162: D10 is  Function-like
proof
let C90 , C91 , C92 being set;
assume L163: [ C90 , C91 ] in D10;
consider C93 being (Element of F1()) such that L164: [ C90 , C91 ] = [ C93 , F2(C93) ] and L165: P1[ C93 ] by L163;
L166: C93 = C90 by L164 , XTUPLE_0:1;
assume L167: [ C90 , C92 ] in D10;
consider C94 being (Element of F1()) such that L168: [ C90 , C92 ] = [ C94 , F2(C94) ] and L169: P1[ C94 ] by L167;
L170: C94 = C90 by L168 , XTUPLE_0:1;
thus L171: thesis by L170 , L164 , L168 , L166 , XTUPLE_0:1;
end;
L172: D10 is  Relation-like
proof
let C95 being set;
assume L173: C95 in D10;
consider C96 being (Element of F1()) such that L174: C95 = [ C96 , F2(C96) ] and L175: P1[ C96 ] by L173;
take C96;
take F2(C96);
thus L176: thesis by L174;
end;
thus L177: thesis by L172 , L162;
end;
scheme DomOnSingletons { F3() -> non  empty set , F4() -> Function , F5(set) -> set , P2[set] } : ( dom F4() ) = { B46 where B46 is (Element of F3()) : P2[ B46 ] }
provided
L178: F4() = { [ B47 , F5(B47) ] where B47 is (Element of F3()) : P2[ B47 ] }
proof
set D11 = { B48 where B48 is (Element of F3()) : P2[ B48 ] };
L179:
now
let C97 being set;
thus L180:now
assume L181: C97 in D11;
consider C98 being (Element of F3()) such that L182: (C97 = C98 & P2[ C98 ]) by L181;
take D12 = F5(C98);
thus L183: [ C97 , D12 ] in F4() by L178 , L182;
end;
given C99 being set such that
L184: [ C97 , C99 ] in F4();

consider C100 being (Element of F3()) such that L185: [ C97 , C99 ] = [ C100 , F5(C100) ] and L186: P2[ C100 ] by L178 , L184;
L187: C97 = C100 by L185 , XTUPLE_0:1;
thus L188: C97 in D11 by L187 , L186;
end;
thus L189: thesis by L179 , XTUPLE_0:def 12;
end;
scheme ValOnSingletons { F6() -> non  empty set , F7() -> Function , F8() -> (Element of F6()) , F9(set) -> set , P3[set] } : ( F7() . F8() ) = F9(F8())
provided
L190: F7() = { [ B49 , F9(B49) ] where B49 is (Element of F6()) : P3[ B49 ] }
and
L191: P3[ F8() ]
proof
L192: F7() = { [ B50 , F9(B50) ] where B50 is (Element of F6()) : P3[ B50 ] } by L190;
L193: ( dom F7() ) = { B51 where B51 is (Element of F6()) : P3[ B51 ] } from DomOnSingletons(L192);
L194: F8() in ( dom F7() ) by L193 , L191;
L195: [ F8() , F9(F8()) ] in { [ B52 , F9(B52) ] where B52 is (Element of F6()) : P3[ B52 ] } by L191;
thus L196: thesis by L195 , L190 , L194 , FUNCT_1:def 2;
end;
begin
theorem
L197: (for B53 being Category holds (for B54 , B55 , B56 being (Object of B53) holds [: ( Hom (B55 , B56) ) , ( Hom (B54 , B55) ) :] c= ( dom (the Comp of B53) )))
proof
let C101 being Category;
let C102 , C103 , C104 being (Object of C101);
let C105 being set;
assume L198: C105 in [: ( Hom (C103 , C104) ) , ( Hom (C102 , C103) ) :];
reconsider D13 = ( C105 `1 ) , D14 = ( C105 `2 ) as (Morphism of C101) by L198 , MCART_1:10;
L199: ( C105 `2 ) in ( Hom (C102 , C103) ) by L198 , MCART_1:10;
L200: C105 = [ D13 , D14 ] by L198 , MCART_1:21;
L201: ( C105 `1 ) in ( Hom (C103 , C104) ) by L198 , MCART_1:10;
L202: ( dom D13 ) = C103 by L201 , CAT_1:1
.= ( cod D14 ) by L199 , CAT_1:1;
thus L203: thesis by L202 , L200 , CAT_1:15;
end;
theorem
L204: (for B57 being Category holds (for B58 , B59 , B60 being (Object of B57) holds ( (the Comp of B57) .: [: ( Hom (B59 , B60) ) , ( Hom (B58 , B59) ) :] ) c= ( Hom (B58 , B60) )))
proof
let C106 being Category;
let C107 , C108 , C109 being (Object of C106);
let C110 being set;
assume L205: C110 in ( (the Comp of C106) .: [: ( Hom (C108 , C109) ) , ( Hom (C107 , C108) ) :] );
consider C111 being set such that L206: C111 in ( dom (the Comp of C106) ) and L207: C111 in [: ( Hom (C108 , C109) ) , ( Hom (C107 , C108) ) :] and L208: C110 = ( (the Comp of C106) . C111 ) by L205 , FUNCT_1:def 6;
reconsider D15 = ( C111 `1 ) , D16 = ( C111 `2 ) as (Morphism of C106) by L207 , MCART_1:10;
L209: (C111 = [ D15 , D16 ] & C110 = ( (the Comp of C106) . (D15 , D16) )) by L207 , L208 , MCART_1:21;
L210: ( C111 `2 ) in ( Hom (C107 , C108) ) by L207 , MCART_1:10;
L211: D16 is (Morphism of C107 , C108) by L210 , CAT_1:def 5;
L212: ( C111 `1 ) in ( Hom (C108 , C109) ) by L207 , MCART_1:10;
L213: D15 is (Morphism of C108 , C109) by L212 , CAT_1:def 5;
L214: ( D15 (*) D16 ) in ( Hom (C107 , C109) ) by L213 , L212 , L210 , L211 , CAT_1:23;
thus L215: thesis by L214 , L206 , L209 , CAT_1:def 1;
end;
definition
let C112 being non  void non  empty CatStr;
func the_hom_sets_of C112 -> (ManySortedSet of [: (the carrier of C112) , (the carrier of C112) :]) means 
:L216: (for B61 , B62 being (Object of C112) holds ( it . (B61 , B62) ) = ( Hom (B61 , B62) ));
existence
proof
deffunc H1((Object of C112) , (Object of C112)) = ( Hom ($1 , $2) );
thus L217: (ex B63 being (ManySortedSet of [: (the carrier of C112) , (the carrier of C112) :]) st (for B64 , B65 being (Object of C112) holds ( B63 . (B64 , B65) ) = H1(B64 , B65))) from ALTCAT_1:sch 2;
end;
uniqueness
proof
let C113 , C114 being (ManySortedSet of [: (the carrier of C112) , (the carrier of C112) :]);
assume that
L218: (for B66 , B67 being (Object of C112) holds ( C113 . (B66 , B67) ) = ( Hom (B66 , B67) ))
and
L219: (for B68 , B69 being (Object of C112) holds ( C114 . (B68 , B69) ) = ( Hom (B68 , B69) ));
L220:
now
let C115 , C116 being (Object of C112);
thus L221: ( C113 . (C115 , C116) ) = ( Hom (C115 , C116) ) by L218
.= ( C114 . (C115 , C116) ) by L219;
end;
thus L222: thesis by L220 , ALTCAT_1:7;
end;
end;
theorem
L224: (for B70 being Category holds (for B71 being (Object of B70) holds ( id B71 ) in ( ( the_hom_sets_of B70 ) . (B71 , B71) )))
proof
let C117 being Category;
let C118 being (Object of C117);
L225: ( id C118 ) in ( Hom (C118 , C118) ) by CAT_1:27;
thus L226: thesis by L225 , L216;
end;
definition
let C119 being Category;
func the_comps_of C119 -> (BinComp of ( the_hom_sets_of C119 )) means 
:L227: (for B72 , B73 , B74 being (Object of C119) holds ( it . (B72 , B73 , B74) ) = ( (the Comp of C119) | ([: ( ( the_hom_sets_of C119 ) . (B73 , B74) ) , ( ( the_hom_sets_of C119 ) . (B72 , B73) ) :] qua set) ));
existence
proof
deffunc H2(set) = ( (the Comp of C119) | ([: ( ( the_hom_sets_of C119 ) . (( ( $1 `1 ) `2 ) , ( $1 `2 )) ) , ( ( the_hom_sets_of C119 ) . (( ( $1 `1 ) `1 ) , ( ( $1 `1 ) `2 )) ) :] qua set) );
set D17 = [: (the carrier of C119) , (the carrier of C119) , (the carrier of C119) :];
set D18 = ( the_hom_sets_of C119 );
consider C120 being Function such that L228: ( dom C120 ) = D17 and L229: (for R1 being set holds (R1 in D17 implies ( C120 . R1 ) = H2(R1))) from FUNCT_1:sch 3;
reconsider D19 = C120 as (ManySortedSet of D17) by L228 , PARTFUN1:def 2 , RELAT_1:def 18;
L230:
now
let R1 being set;
assume L231: R1 in ( dom D19 );
L232: ( D19 . R1 ) = ( (the Comp of C119) | ([: ( ( the_hom_sets_of C119 ) . (( ( R1 `1 ) `2 ) , ( R1 `2 )) ) , ( ( the_hom_sets_of C119 ) . (( ( R1 `1 ) `1 ) , ( ( R1 `1 ) `2 )) ) :] qua set) ) by L231 , L228 , L229;
thus L233: ( D19 . R1 ) is Function by L232;
end;
reconsider D20 = D19 as (ManySortedFunction of D17) by L230 , FUNCOP_1:def 6;
L234:
now
let R1 being set;
reconsider D21 = ( D20 . R1 ) as Function;
assume L235: R1 in D17;
consider C121 , C122 , C123 being (Object of C119) such that L236: R1 = [ C121 , C122 , C123 ] by L235 , DOMAIN_1:3;
reconsider D22 = R1 as (Element of D17) by L235;
L237: ( ( ([ C121 , C122 , C123 ] qua set) `1 ) `2 ) = ( D22 `2_3 ) by L236
.= C122 by L236 , MCART_1:def 6;
L238: ( ([ C121 , C122 , C123 ] qua set) `2 ) = ( D22 `3_3 ) by L236
.= C123 by L236 , MCART_1:def 7;
L239: ( ( ([ C121 , C122 , C123 ] qua set) `1 ) `1 ) = ( D22 `1_3 ) by L236
.= C121 by L236 , MCART_1:def 5;
L240: D21 = ( (the Comp of C119) | ([: ( D18 . (C122 , C123) ) , ( D18 . (C121 , C122) ) :] qua set) ) by L239 , L229 , L236 , L237 , L238;
L241: (( D18 . (C121 , C122) ) = ( Hom (C121 , C122) ) & ( D18 . (C122 , C123) ) = ( Hom (C122 , C123) )) by L216;
L242: ( {| D18 |} . R1 ) = ( {| D18 |} . (C121 , C122 , C123) ) by L236 , MULTOP_1:def 1
.= ( D18 . (C121 , C123) ) by ALTCAT_1:def 3
.= ( Hom (C121 , C123) ) by L216;
L243: ( {| D18 , D18 |} . R1 ) = ( {| D18 , D18 |} . (C121 , C122 , C123) ) by L236 , MULTOP_1:def 1
.= [: ( Hom (C122 , C123) ) , ( Hom (C121 , C122) ) :] by L241 , ALTCAT_1:def 4;
L244: ( (the Comp of C119) .: [: ( Hom (C122 , C123) ) , ( Hom (C121 , C122) ) :] ) c= ( Hom (C121 , C123) ) by L204;
L245: ( rng D21 ) c= ( {| D18 |} . R1 ) by L244 , L241 , L240 , L242 , RELAT_1:115;
L246: [: ( Hom (C122 , C123) ) , ( Hom (C121 , C122) ) :] c= ( dom (the Comp of C119) ) by L197;
L247: ( dom D21 ) = ( {| D18 , D18 |} . R1 ) by L246 , L241 , L240 , L243 , RELAT_1:62;
thus L248: ( D20 . R1 ) is (Function of ( {| D18 , D18 |} . R1 ) , ( {| D18 |} . R1 )) by L247 , L245 , FUNCT_2:2;
end;
reconsider D23 = D20 as (BinComp of D18) by L234 , PBOOLE:def 15;
take D23;
let C124 , C125 , C126 being (Object of C119);
reconsider D24 = [ C124 , C125 , C126 ] as (Element of D17);
L249: ( ( ([ C124 , C125 , C126 ] qua set) `1 ) `1 ) = ( D24 `1_3 )
.= C124 by MCART_1:def 5;
L250: ( ( ([ C124 , C125 , C126 ] qua set) `1 ) `2 ) = ( D24 `2_3 )
.= C125 by MCART_1:def 6;
L251: ( ([ C124 , C125 , C126 ] qua set) `2 ) = ( D24 `3_3 )
.= C126 by MCART_1:def 7;
thus L252: ( D23 . (C124 , C125 , C126) ) = ( D23 . [ C124 , C125 , C126 ] ) by MULTOP_1:def 1
.= ( (the Comp of C119) | ([: ( ( the_hom_sets_of C119 ) . (C125 , C126) ) , ( ( the_hom_sets_of C119 ) . (C124 , C125) ) :] qua set) ) by L229 , L249 , L250 , L251;
end;
uniqueness
proof
let C127 , C128 being (BinComp of ( the_hom_sets_of C119 ));
assume that
L253: (for B75 , B76 , B77 being (Object of C119) holds ( C127 . (B75 , B76 , B77) ) = ( (the Comp of C119) | ([: ( ( the_hom_sets_of C119 ) . (B76 , B77) ) , ( ( the_hom_sets_of C119 ) . (B75 , B76) ) :] qua set) ))
and
L254: (for B78 , B79 , B80 being (Object of C119) holds ( C128 . (B78 , B79 , B80) ) = ( (the Comp of C119) | ([: ( ( the_hom_sets_of C119 ) . (B79 , B80) ) , ( ( the_hom_sets_of C119 ) . (B78 , B79) ) :] qua set) ));
L255:
now
let C129 being set;
assume L256: C129 in [: (the carrier of C119) , (the carrier of C119) , (the carrier of C119) :];
consider C130 , C131 , C132 being (Object of C119) such that L257: C129 = [ C130 , C131 , C132 ] by L256 , DOMAIN_1:3;
thus L258: ( C127 . C129 ) = ( C127 . (C130 , C131 , C132) ) by L257 , MULTOP_1:def 1
.= ( (the Comp of C119) | ([: ( ( the_hom_sets_of C119 ) . (C131 , C132) ) , ( ( the_hom_sets_of C119 ) . (C130 , C131) ) :] qua set) ) by L253
.= ( C128 . (C130 , C131 , C132) ) by L254
.= ( C128 . C129 ) by L257 , MULTOP_1:def 1;
end;
thus L259: C127 = C128 by L255 , PBOOLE:3;
end;
end;
theorem
L261: (for B81 being Category holds (for B82 , B83 , B84 being (Object of B81) holds ((( Hom (B82 , B83) ) <> ( {} ) & ( Hom (B83 , B84) ) <> ( {} )) implies (for B85 being (Morphism of B82 , B83) holds (for B86 being (Morphism of B83 , B84) holds ( ( ( the_comps_of B81 ) . (B82 , B83 , B84) ) . (B86 , B85) ) = ( B86 * B85 ))))))
proof
let C133 being Category;
let C134 , C135 , C136 being (Object of C133);
assume that
L262: ( Hom (C134 , C135) ) <> ( {} )
and
L263: ( Hom (C135 , C136) ) <> ( {} );
let C137 being (Morphism of C134 , C135);
let C138 being (Morphism of C135 , C136);
L264: C138 in ( Hom (C135 , C136) ) by L263 , CAT_1:def 5;
L265: C138 in ( ( the_hom_sets_of C133 ) . (C135 , C136) ) by L264 , L216;
L266: C137 in ( Hom (C134 , C135) ) by L262 , CAT_1:def 5;
L267: C137 in ( ( the_hom_sets_of C133 ) . (C134 , C135) ) by L266 , L216;
L268: [ C138 , C137 ] in [: ( ( the_hom_sets_of C133 ) . (C135 , C136) ) , ( ( the_hom_sets_of C133 ) . (C134 , C135) ) :] by L267 , L265 , ZFMISC_1:87;
L269: ( dom C138 ) = C135 by L264 , CAT_1:1
.= ( cod C137 ) by L266 , CAT_1:1;
thus L270: ( ( ( the_comps_of C133 ) . (C134 , C135 , C136) ) . (C138 , C137) ) = ( ( (the Comp of C133) | ([: ( ( the_hom_sets_of C133 ) . (C135 , C136) ) , ( ( the_hom_sets_of C133 ) . (C134 , C135) ) :] qua set) ) . [ C138 , C137 ] ) by L227
.= ( (the Comp of C133) . (C138 , C137) ) by L268 , FUNCT_1:49
.= ( C138 (*) (C137 qua (Morphism of C133)) ) by L269 , CAT_1:16
.= ( C138 * C137 ) by L262 , L263 , CAT_1:def 13;
end;
theorem
L271: (for B87 being Category holds ( the_comps_of B87 ) is  associative)
proof
let C139 being Category;
let C140 , C141 , C142 , C143 being (Object of C139);
let C144 , C145 , C146 being set;
assume L272: C144 in ( ( the_hom_sets_of C139 ) . (C140 , C141) );
L273: C144 in ( Hom (C140 , C141) ) by L272 , L216;
reconsider D25 = C144 as (Morphism of C140 , C141) by L273 , CAT_1:def 5;
assume L274: C145 in ( ( the_hom_sets_of C139 ) . (C141 , C142) );
L275: C145 in ( Hom (C141 , C142) ) by L274 , L216;
reconsider D26 = C145 as (Morphism of C141 , C142) by L275 , CAT_1:def 5;
assume L276: C146 in ( ( the_hom_sets_of C139 ) . (C142 , C143) );
L277: C146 in ( Hom (C142 , C143) ) by L276 , L216;
reconsider D27 = C146 as (Morphism of C142 , C143) by L277 , CAT_1:def 5;
L278: (( Hom (C141 , C143) ) <> ( {} ) & ( ( ( the_comps_of C139 ) . (C141 , C142 , C143) ) . (C146 , C145) ) = ( D27 * D26 )) by L275 , L277 , L261 , CAT_1:24;
L279: (( Hom (C140 , C142) ) <> ( {} ) & ( ( ( the_comps_of C139 ) . (C140 , C141 , C142) ) . (C145 , C144) ) = ( D26 * D25 )) by L273 , L275 , L261 , CAT_1:24;
thus L280: ( ( ( the_comps_of C139 ) . (C140 , C142 , C143) ) . (C146 , ( ( ( the_comps_of C139 ) . (C140 , C141 , C142) ) . (C145 , C144) )) ) = ( D27 * ( D26 * D25 ) ) by L279 , L277 , L261
.= ( ( D27 * D26 ) * D25 ) by L273 , L275 , L277 , CAT_1:25
.= ( ( ( the_comps_of C139 ) . (C140 , C141 , C143) ) . (( ( ( the_comps_of C139 ) . (C141 , C142 , C143) ) . (C146 , C145) ) , C144) ) by L273 , L278 , L261;
end;
theorem
L281: (for B88 being Category holds ( the_comps_of B88 ) is  with_left_units  with_right_units)
proof
let C147 being Category;
thus L282: ( the_comps_of C147 ) is  with_left_units
proof
let C148 being (Object of C147);
take ( id C148 );
thus L283: ( id C148 ) in ( ( the_hom_sets_of C147 ) . (C148 , C148) ) by L224;
let C149 being (Object of C147);
let C150 being set;
assume L284: C150 in ( ( the_hom_sets_of C147 ) . (C149 , C148) );
L285: C150 in ( Hom (C149 , C148) ) by L284 , L216;
reconsider D28 = C150 as (Morphism of C149 , C148) by L285 , CAT_1:def 5;
L286: ( Hom (C148 , C148) ) <> ( {} );
thus L287: ( ( ( the_comps_of C147 ) . (C149 , C148 , C148) ) . (( id C148 ) , C150) ) = ( ( id C148 ) * D28 ) by L286 , L285 , L261
.= C150 by L285 , CAT_1:28;
end;

let C151 being (Object of C147);
take ( id C151 );
thus L288: ( id C151 ) in ( ( the_hom_sets_of C147 ) . (C151 , C151) ) by L224;
let C152 being (Object of C147);
let C153 being set;
assume L289: C153 in ( ( the_hom_sets_of C147 ) . (C151 , C152) );
L290: C153 in ( Hom (C151 , C152) ) by L289 , L216;
reconsider D29 = C153 as (Morphism of C151 , C152) by L290 , CAT_1:def 5;
L291: ( Hom (C151 , C151) ) <> ( {} );
thus L292: ( ( ( the_comps_of C147 ) . (C151 , C151 , C152) ) . (C153 , ( id C151 )) ) = ( D29 * ( id C151 ) ) by L291 , L290 , L261
.= C153 by L290 , CAT_1:29;
end;
begin
definition
let C154 being Category;
func Alter C154 ->  strict non  empty AltCatStr equals 
AltCatStr (# (the carrier of C154) , ( the_hom_sets_of C154 ) , ( the_comps_of C154 ) #);
correctness;
end;
theorem
L294: (for B89 being Category holds ( Alter B89 ) is  associative)
proof
let C155 being Category;
thus L295: (the Comp of ( Alter C155 )) is  associative by L271;
end;
theorem
L296: (for B90 being Category holds ( Alter B90 ) is  with_units)
proof
let C156 being Category;
thus L297: (the Comp of ( Alter C156 )) is  with_left_units  with_right_units by L281;
end;
theorem
L298: (for B91 being Category holds ( Alter B91 ) is  transitive)
proof
let C157 being Category;
let C158 , C159 , C160 being (object of ( Alter C157 ));
assume that
L299: (<^ C158 , C159 ^> <> ( {} ) & <^ C159 , C160 ^> <> ( {} ));
reconsider D30 = C158 , D31 = C159 , D32 = C160 as (Object of C157);
L300: <^ C158 , C160 ^> = ( Hom (D30 , D32) ) by L216;
L301: (<^ C158 , C159 ^> = ( Hom (D30 , D31) ) & <^ C159 , C160 ^> = ( Hom (D31 , D32) )) by L216;
thus L302: thesis by L301 , L299 , L300 , CAT_1:24;
end;
registration
let C161 being Category;
cluster ( Alter C161 ) ->  transitive  associative  with_units;
coherence by L294 , L296 , L298;
end;
begin
registration
cluster non  empty  strict for AltGraph;
existence
proof
set D33 = the (ManySortedSet of [: 1 , 1 :]);
take D34 = AltGraph (# 1 , D33 #);
thus L304: (the carrier of D34) is non  empty;
thus L305: thesis;
end;
end;
definition
let C162 being AltGraph;
attr C162 is  reflexive
means
:L307: (for B92 being set holds (B92 in (the carrier of C162) implies ( (the Arrows of C162) . (B92 , B92) ) <> ( {} )));
end;
definition
let C163 being non  empty AltGraph;
redefine attr C163 is  reflexive
means
(for B93 being (object of C163) holds <^ B93 , B93 ^> <> ( {} ));
compatibility
proof
thus L309: (C163 is  reflexive implies (for B94 being (object of C163) holds <^ B94 , B94 ^> <> ( {} ))) by L307;
assume L310: (for B95 being (object of C163) holds <^ B95 , B95 ^> <> ( {} ));
let C164 being set;
assume L311: C164 in (the carrier of C163);
reconsider D35 = C164 as (object of C163) by L311;
L312: ( (the Arrows of C163) . (C164 , C164) ) = <^ D35 , D35 ^>;
thus L313: thesis by L312 , L310;
end;
end;
definition
let C165 being non  empty  transitive AltCatStr;
redefine attr C165 is  associative
means
:L315: (for B96 , B97 , B98 , B99 being (object of C165) holds (for B100 being (Morphism of B96 , B97) holds (for B101 being (Morphism of B97 , B98) holds (for B102 being (Morphism of B98 , B99) holds ((<^ B96 , B97 ^> <> ( {} ) & <^ B97 , B98 ^> <> ( {} ) & <^ B98 , B99 ^> <> ( {} )) implies ( ( B102 * B101 ) * B100 ) = ( B102 * ( B101 * B100 ) ))))));
compatibility
proof
thus L316: (C165 is  associative implies (for B103 , B104 , B105 , B106 being (object of C165) holds (for B107 being (Morphism of B103 , B104) holds (for B108 being (Morphism of B104 , B105) holds (for B109 being (Morphism of B105 , B106) holds ((<^ B103 , B104 ^> <> ( {} ) & <^ B104 , B105 ^> <> ( {} ) & <^ B105 , B106 ^> <> ( {} )) implies ( ( B109 * B108 ) * B107 ) = ( B109 * ( B108 * B107 ) ))))))) by ALTCAT_1:21;
assume L317: (for B110 , B111 , B112 , B113 being (object of C165) holds (for B114 being (Morphism of B110 , B111) holds (for B115 being (Morphism of B111 , B112) holds (for B116 being (Morphism of B112 , B113) holds ((<^ B110 , B111 ^> <> ( {} ) & <^ B111 , B112 ^> <> ( {} ) & <^ B112 , B113 ^> <> ( {} )) implies ( ( B116 * B115 ) * B114 ) = ( B116 * ( B115 * B114 ) ))))));
let C166 , C167 , C168 , C169 being (Element of C165);
reconsider D36 = C166 , D37 = C167 , D38 = C168 , D39 = C169 as (object of C165);
let C170 , C171 , C172 being set;
assume L318: C170 in ( (the Arrows of C165) . (C166 , C167) );
reconsider D40 = C170 as (Morphism of D36 , D37) by L318;
assume L319: C171 in ( (the Arrows of C165) . (C167 , C168) );
L320: C171 in <^ D37 , D38 ^> by L319;
L321: C170 in <^ D36 , D37 ^> by L318;
L322: <^ D36 , D38 ^> <> ( {} ) by L321 , L320 , ALTCAT_1:def 2;
reconsider D41 = C171 as (Morphism of D37 , D38) by L319;
assume L323: C172 in ( (the Arrows of C165) . (C168 , C169) );
reconsider D42 = C172 as (Morphism of D38 , D39) by L323;
L324: ( ( (the Comp of C165) . (C167 , C168 , C169) ) . (C172 , C171) ) = ( D42 * D41 ) by L319 , L323 , ALTCAT_1:def 8;
L325: C172 in <^ D38 , D39 ^> by L323;
L326: <^ D37 , D39 ^> <> ( {} ) by L325 , L320 , ALTCAT_1:def 2;
L327: ( ( (the Comp of C165) . (C166 , C167 , C168) ) . (C171 , C170) ) = ( D41 * D40 ) by L318 , L319 , ALTCAT_1:def 8;
thus L328: ( ( (the Comp of C165) . (C166 , C168 , C169) ) . (C172 , ( ( (the Comp of C165) . (C166 , C167 , C168) ) . (C171 , C170) )) ) = ( D42 * ( D41 * D40 ) ) by L327 , L323 , L322 , ALTCAT_1:def 8
.= ( ( D42 * D41 ) * D40 ) by L317 , L318 , L319 , L323
.= ( ( (the Comp of C165) . (C166 , C167 , C169) ) . (( ( (the Comp of C165) . (C167 , C168 , C169) ) . (C172 , C171) ) , C170) ) by L318 , L326 , L324 , ALTCAT_1:def 8;
end;
end;
definition
let C173 being non  empty AltCatStr;
redefine attr C173 is  with_units
means
(for B117 being (object of C173) holds (<^ B117 , B117 ^> <> ( {} ) & (ex B118 being (Morphism of B117 , B117) st (for B119 being (object of C173) holds (for B120 being (Morphism of B119 , B117) holds (for B121 being (Morphism of B117 , B119) holds ((<^ B119 , B117 ^> <> ( {} ) implies ( B118 * B120 ) = B120) & (<^ B117 , B119 ^> <> ( {} ) implies ( B121 * B118 ) = B121))))))));
compatibility
proof
thus L330:now
assume L331: C173 is  with_units;
reconsider D43 = C173 as  with_units non  empty AltCatStr by L331;
let C174 being (object of C173);
thus L332: <^ C174 , C174 ^> <> ( {} ) by L331 , ALTCAT_1:18;
reconsider D44 = C174 as (object of D43);
reconsider D45 = ( idm D44 ) as (Morphism of C174 , C174);
take D46 = D45;
let C175 being (object of C173);
let C176 being (Morphism of C175 , C174);
let C177 being (Morphism of C174 , C175);
thus L333: (<^ C175 , C174 ^> <> ( {} ) implies ( D46 * C176 ) = C176) by ALTCAT_1:20;
thus L334: (<^ C174 , C175 ^> <> ( {} ) implies ( C177 * D46 ) = C177) by ALTCAT_1:def 17;
end;
assume L335: (for B122 being (object of C173) holds (<^ B122 , B122 ^> <> ( {} ) & (ex B123 being (Morphism of B122 , B122) st (for B124 being (object of C173) holds (for B125 being (Morphism of B124 , B122) holds (for B126 being (Morphism of B122 , B124) holds ((<^ B124 , B122 ^> <> ( {} ) implies ( B123 * B125 ) = B125) & (<^ B122 , B124 ^> <> ( {} ) implies ( B126 * B123 ) = B126))))))));
thus L336:now
let C178 being (Element of C173);
reconsider D47 = C178 as (object of C173);
consider C179 being (Morphism of D47 , D47) such that L337: (for B127 being (object of C173) holds (for B128 being (Morphism of B127 , D47) holds (for B129 being (Morphism of D47 , B127) holds ((<^ B127 , D47 ^> <> ( {} ) implies ( C179 * B128 ) = B128) & (<^ D47 , B127 ^> <> ( {} ) implies ( B129 * C179 ) = B129))))) by L335;
reconsider D48 = C179 as set;
take D49 = D48;
L338: <^ D47 , D47 ^> <> ( {} ) by L335;
thus L339: D49 in ( (the Arrows of C173) . (C178 , C178) ) by L338;
let C180 being (Element of C173);
let C181 being set;
assume that
L340: C181 in ( (the Arrows of C173) . (C180 , C178) );
reconsider D50 = C180 as (object of C173);
reconsider D51 = C181 as (Morphism of D50 , D47) by L340;
thus L341: ( ( (the Comp of C173) . (C180 , C178 , C178) ) . (D49 , C181) ) = ( C179 * D51 ) by L338 , L340 , ALTCAT_1:def 8
.= C181 by L337 , L340;
end;
let C182 being (Element of C173);
reconsider D52 = C182 as (object of C173);
consider C183 being (Morphism of D52 , D52) such that L342: (for B130 being (object of C173) holds (for B131 being (Morphism of B130 , D52) holds (for B132 being (Morphism of D52 , B130) holds ((<^ B130 , D52 ^> <> ( {} ) implies ( C183 * B131 ) = B131) & (<^ D52 , B130 ^> <> ( {} ) implies ( B132 * C183 ) = B132))))) by L335;
take D53 = C183;
L343: <^ D52 , D52 ^> <> ( {} ) by L335;
thus L344: D53 in ( (the Arrows of C173) . (C182 , C182) ) by L343;
let C184 being (Element of C173);
let C185 being set;
assume that
L345: C185 in ( (the Arrows of C173) . (C182 , C184) );
reconsider D54 = C184 as (object of C173);
reconsider D55 = C185 as (Morphism of D52 , D54) by L345;
thus L346: ( ( (the Comp of C173) . (C182 , C182 , C184) ) . (C185 , D53) ) = ( D55 * C183 ) by L343 , L345 , ALTCAT_1:def 8
.= C185 by L342 , L345;
end;
end;
registration
cluster  with_units ->  reflexive for non  empty non  empty non  empty non  empty AltCatStr;
coherence
proof
let C186 being non  empty AltCatStr;
assume L348: C186 is  with_units;
let C187 being (object of C186);
thus L349: thesis by L348 , ALTCAT_1:18;
end;
end;
registration
cluster non  empty  reflexive for AltGraph;
existence
proof
set D56 = the  with_units non  empty AltCatStr;
take D56;
thus L351: thesis;
end;
end;
registration
cluster non  empty  reflexive for AltCatStr;
existence
proof
set D57 = the category;
take D57;
thus L353: thesis;
end;
end;
begin
L355: (for B133 , B134 being  strict AltCatStr holds (((the carrier of B133) is  empty & (the carrier of B134) is  empty) implies B133 = B134))
proof
let C188 , C189 being  strict AltCatStr;
set D58 = (the carrier of C188);
set D59 = (the carrier of C189);
assume that
L356: D58 is  empty
and
L357: D59 is  empty;
L358: [: D59 , D59 , D59 :] = ( {} ) by L357 , MCART_1:31;
L359: [: D58 , D58 , D58 :] = ( {} ) by L356 , MCART_1:31;
L360: (the Comp of C188) = ( {} ) by L359
.= (the Comp of C189) by L358;
L361: [: D59 , D59 :] = ( {} ) by L357 , ZFMISC_1:90;
L362: [: D58 , D58 :] = ( {} ) by L356 , ZFMISC_1:90;
L363: (the Arrows of C188) = ( {} ) by L362
.= (the Arrows of C189) by L361;
thus L364: thesis by L363 , L356 , L357 , L360;
end;
definition
func the_empty_category ->  strict AltCatStr means 
:L365: (the carrier of it) is  empty;
existence
proof
reconsider D60 = ( {} ) as set;
set D61 = the (ManySortedSet of [: D60 , D60 :]);
set D62 = the (BinComp of D61);
take AltCatStr (# D60 , D61 , D62 #);
thus L366: thesis;
end;
uniqueness by L355;
end;
registration
cluster ( the_empty_category ) ->  empty;
coherence by L365;
end;
registration
cluster  empty  strict for AltCatStr;
existence
proof
take ( the_empty_category );
thus L369: thesis;
end;
end;
theorem
L371: (for B135 being  empty  strict AltCatStr holds B135 = ( the_empty_category )) by L355;
begin
definition
let C190 being AltCatStr;
mode SubCatStr of C190
 -> AltCatStr
means :L372: ((the carrier of it) c= (the carrier of C190) & (the Arrows of it) cc= (the Arrows of C190) & (the Comp of it) cc= (the Comp of C190));
existence;
end;
theorem
L374: (for R2 being AltCatStr holds R2 is (SubCatStr of R2))
proof
let R2 being AltCatStr;
thus L375: (the carrier of R2) c= (the carrier of R2);
thus L376: thesis;
end;
theorem
L377: (for R3 being AltCatStr holds (for R4 being AltCatStr holds (for R5 being AltCatStr holds ((R3 is (SubCatStr of R4) & R4 is (SubCatStr of R5)) implies R3 is (SubCatStr of R5)))))
proof
let R3 being AltCatStr;
let R4 being AltCatStr;
let R5 being AltCatStr;
assume L378: ((the carrier of R3) c= (the carrier of R4) & (the Arrows of R3) cc= (the Arrows of R4) & (the Comp of R3) cc= (the Comp of R4) & (the carrier of R4) c= (the carrier of R5) & (the Arrows of R4) cc= (the Arrows of R5) & (the Comp of R4) cc= (the Comp of R5));
thus L379: ((the carrier of R3) c= (the carrier of R5) & (the Arrows of R3) cc= (the Arrows of R5) & (the Comp of R3) cc= (the Comp of R5)) by L378 , L145 , XBOOLE_1:1;
end;
theorem
L380: (for B136 , B137 being AltCatStr holds ((B136 is (SubCatStr of B137) & B137 is (SubCatStr of B136)) implies ( the AltCatStr of B136 ) = ( the AltCatStr of B137 )))
proof
let C191 , C192 being AltCatStr;
assume that
L381: ((the carrier of C191) c= (the carrier of C192) & (the Arrows of C191) cc= (the Arrows of C192))
and
L382: (the Comp of C191) cc= (the Comp of C192)
and
L383: ((the carrier of C192) c= (the carrier of C191) & (the Arrows of C192) cc= (the Arrows of C191))
and
L384: (the Comp of C192) cc= (the Comp of C191);
L385: ((the carrier of C191) = (the carrier of C192) & (the Arrows of C191) = (the Arrows of C192)) by L381 , L383 , L134 , XBOOLE_0:def 10;
thus L386: thesis by L385 , L382 , L384 , L134;
end;
registration
let C193 being AltCatStr;
cluster  strict for (SubCatStr of C193);
existence
proof
set D63 = ( the AltCatStr of C193 );
reconsider D64 = D63 as (SubCatStr of C193) by L372;
take D64;
thus L387: thesis;
end;
end;
definition
let C194 being non  empty AltCatStr;
let C195 being (object of C194);
func ObCat C195 ->  strict (SubCatStr of C194) means 
:L389: ((the carrier of it) = { C195 } & (the Arrows of it) = ( (C195 , C195) :-> <^ C195 , C195 ^> ) & (the Comp of it) = ( [ C195 , C195 , C195 ] .--> ( (the Comp of C194) . (C195 , C195 , C195) ) ));
existence
proof
set D65 = ( [ C195 , C195 , C195 ] .--> ( (the Comp of C194) . (C195 , C195 , C195) ) );
L390: ( dom D65 ) = { [ C195 , C195 , C195 ] } by FUNCOP_1:13
.= [: { C195 } , { C195 } , { C195 } :] by MCART_1:35;
reconsider D66 = D65 as (ManySortedSet of [: { C195 } , { C195 } , { C195 } :]) by L390 , PARTFUN1:def 2 , RELAT_1:def 18;
set D67 = ( (C195 , C195) :-> <^ C195 , C195 ^> );
L391: ( dom D67 ) = [: { C195 } , { C195 } :] by FUNCT_2:def 1;
reconsider D68 = D67 as (ManySortedSet of [: { C195 } , { C195 } :]) by L391 , PARTFUN1:def 2;
L392: ( D68 . (C195 , C195) ) = ( (the Arrows of C194) . (C195 , C195) ) by ALTCAT_1:10;
L393: D66 is (ManySortedFunction of {| D68 , D68 |} , {| D68 |})
proof
let C196 being set;
L394: C195 in { C195 } by TARSKI:def 1;
assume L395: C196 in [: { C195 } , { C195 } , { C195 } :];
L396: C196 in { [ C195 , C195 , C195 ] } by L395 , MCART_1:35;
L397: C196 = [ C195 , C195 , C195 ] by L396 , TARSKI:def 1;
L398: ( {| D68 |} . C196 ) = ( {| D68 |} . (C195 , C195 , C195) ) by L397 , MULTOP_1:def 1
.= ( (the Arrows of C194) . (C195 , C195) ) by L392 , L394 , ALTCAT_1:def 3;
L399: ( {| D68 , D68 |} . C196 ) = ( {| D68 , D68 |} . (C195 , C195 , C195) ) by L397 , MULTOP_1:def 1
.= [: ( (the Arrows of C194) . (C195 , C195) ) , ( (the Arrows of C194) . (C195 , C195) ) :] by L392 , L394 , ALTCAT_1:def 4;
thus L400: thesis by L399 , L397 , L398 , FUNCOP_1:72;
end;
reconsider D69 = D66 as (BinComp of D68) by L393;
set D70 = AltCatStr (# { C195 } , D68 , D69 #);
L401: D70 is (SubCatStr of C194)
proof
thus L402: (the carrier of D70) c= (the carrier of C194);
thus L403: (the Arrows of D70) cc= (the Arrows of C194)
proof
thus L404: [: (the carrier of D70) , (the carrier of D70) :] c= [: (the carrier of C194) , (the carrier of C194) :];
let C197 being set;
assume L405: C197 in [: (the carrier of D70) , (the carrier of D70) :];
L406: C197 in { [ C195 , C195 ] } by L405 , ZFMISC_1:29;
L407: C197 = [ C195 , C195 ] by L406 , TARSKI:def 1;
thus L408: thesis by L407 , L392;
end;

thus L409: [: (the carrier of D70) , (the carrier of D70) , (the carrier of D70) :] c= [: (the carrier of C194) , (the carrier of C194) , (the carrier of C194) :];
let C198 being set;
assume L410: C198 in [: (the carrier of D70) , (the carrier of D70) , (the carrier of D70) :];
L411: C198 in { [ C195 , C195 , C195 ] } by L410 , MCART_1:35;
L412: C198 = [ C195 , C195 , C195 ] by L411 , TARSKI:def 1;
L413: ( (the Comp of D70) . C198 ) = ( (the Comp of C194) . (C195 , C195 , C195) ) by L412 , FUNCOP_1:72
.= ( (the Comp of C194) . C198 ) by L412 , MULTOP_1:def 1;
thus L414: thesis by L413;
end;
reconsider D71 = D70 as  strict (SubCatStr of C194) by L401;
take D71;
thus L415: thesis;
end;
uniqueness;
end;
theorem
L417: (for R6 being non  empty AltCatStr holds (for R7 being (object of R6) holds (for B138 being (object of ( ObCat R7 )) holds B138 = R7)))
proof
let R6 being non  empty AltCatStr;
let R7 being (object of R6);
let C199 being (object of ( ObCat R7 ));
L418: (the carrier of ( ObCat R7 )) = { R7 } by L389;
thus L419: thesis by L418 , TARSKI:def 1;
end;
registration
let C200 being non  empty AltCatStr;
let C201 being (object of C200);
cluster ( ObCat C201 ) ->  transitive non  empty;
coherence
proof
thus L420: ( ObCat C201 ) is  transitive
proof
let C202 , C203 , C204 being (object of ( ObCat C201 ));
assume that
L421: <^ C202 , C203 ^> <> ( {} )
and
L422: <^ C203 , C204 ^> <> ( {} );
L423: C202 = C201 by L417;
thus L424: thesis by L423 , L422 , L417;
end;

L425: (the carrier of ( ObCat C201 )) = { C201 } by L389;
thus L426: (the carrier of ( ObCat C201 )) is non  empty by L425;
end;
end;
registration
let C205 being non  empty AltCatStr;
cluster  transitive non  empty  strict for (SubCatStr of C205);
existence
proof
set D72 = the (object of C205);
take ( ObCat D72 );
thus L428: thesis;
end;
end;
theorem
L430: (for B139 being  transitive non  empty AltCatStr holds (for B140 , B141 being  transitive non  empty (SubCatStr of B139) holds (((the carrier of B140) c= (the carrier of B141) & (the Arrows of B140) cc= (the Arrows of B141)) implies B140 is (SubCatStr of B141))))
proof
let C206 being  transitive non  empty AltCatStr;
let C207 , C208 being  transitive non  empty (SubCatStr of C206);
assume that
L431: (the carrier of C207) c= (the carrier of C208)
and
L432: (the Arrows of C207) cc= (the Arrows of C208);
thus L433: (the carrier of C207) c= (the carrier of C208) by L431;
thus L434: (the Arrows of C207) cc= (the Arrows of C208) by L432;
thus L435: [: (the carrier of C207) , (the carrier of C207) , (the carrier of C207) :] c= [: (the carrier of C208) , (the carrier of C208) , (the carrier of C208) :] by L431 , MCART_1:73;
let C209 being set;
assume L436: C209 in [: (the carrier of C207) , (the carrier of C207) , (the carrier of C207) :];
consider C210 , C211 , C212 being set such that L437: (C210 in (the carrier of C207) & C211 in (the carrier of C207) & C212 in (the carrier of C207)) and L438: C209 = [ C210 , C211 , C212 ] by L436 , MCART_1:68;
reconsider D73 = C210 , D74 = C211 , D75 = C212 as (object of C207) by L437;
reconsider D76 = D73 , D77 = D74 , D78 = D75 as (object of C208) by L431 , L437;
L439: [ D74 , D75 ] in [: (the carrier of C207) , (the carrier of C207) :];
L440: <^ D74 , D75 ^> c= <^ D77 , D78 ^> by L439 , L432 , L124;
reconsider D79 = ( (the Comp of C208) . (D76 , D77 , D78) ) as (Function of [: <^ D77 , D78 ^> , <^ D76 , D77 ^> :] , <^ D76 , D78 ^>);
reconsider D80 = ( (the Comp of C207) . (D73 , D74 , D75) ) as (Function of [: <^ D74 , D75 ^> , <^ D73 , D74 ^> :] , <^ D73 , D75 ^>);
L441: (<^ D73 , D75 ^> = ( {} ) implies (<^ D74 , D75 ^> = ( {} ) or <^ D73 , D74 ^> = ( {} ))) by ALTCAT_1:def 2;
L442: (<^ D73 , D75 ^> = ( {} ) implies [: <^ D74 , D75 ^> , <^ D73 , D74 ^> :] = ( {} )) by L441 , ZFMISC_1:90;
L443: ( dom D80 ) = [: <^ D74 , D75 ^> , <^ D73 , D74 ^> :] by L442 , FUNCT_2:def 1;
L444: (<^ D76 , D78 ^> = ( {} ) implies (<^ D77 , D78 ^> = ( {} ) or <^ D76 , D77 ^> = ( {} ))) by ALTCAT_1:def 2;
L445: (<^ D76 , D78 ^> = ( {} ) implies [: <^ D77 , D78 ^> , <^ D76 , D77 ^> :] = ( {} )) by L444 , ZFMISC_1:90;
L446: ( dom D79 ) = [: <^ D77 , D78 ^> , <^ D76 , D77 ^> :] by L445 , FUNCT_2:def 1;
L447: [ D73 , D74 ] in [: (the carrier of C207) , (the carrier of C207) :];
L448: <^ D73 , D74 ^> c= <^ D76 , D77 ^> by L447 , L432 , L124;
L449: ( dom D80 ) c= ( dom D79 ) by L448 , L443 , L440 , L446 , ZFMISC_1:96;
L450:
now
L451: (the carrier of C207) c= (the carrier of C206) by L372;
reconsider D81 = D73 , D82 = D74 , D83 = D75 as (object of C206) by L451 , L437;
reconsider D84 = ( (the Comp of C206) . (D81 , D82 , D83) ) as (Function of [: <^ D82 , D83 ^> , <^ D81 , D82 ^> :] , <^ D81 , D83 ^>);
let C213 being set;
L452: D84 = ( (the Comp of C206) . [ D81 , D82 , D83 ] ) by MULTOP_1:def 1;
L453: D79 = ( (the Comp of C208) . [ D81 , D82 , D83 ] ) by MULTOP_1:def 1;
L454: ([ D81 , D82 , D83 ] in [: (the carrier of C208) , (the carrier of C208) , (the carrier of C208) :] & (the Comp of C208) cc= (the Comp of C206)) by L431 , L437 , L372 , MCART_1:69;
L455: D79 c= D84 by L454 , L452 , L453 , L124;
assume L456: C213 in ( dom D80 );
L457: ((the Comp of C207) cc= (the Comp of C206) & D80 = ( (the Comp of C207) . [ D81 , D82 , D83 ] )) by L372 , MULTOP_1:def 1;
L458: D80 c= D84 by L457 , L436 , L438 , L452 , L124;
thus L459: ( D80 . C213 ) = ( D84 . C213 ) by L458 , L456 , GRFUNC_1:2
.= ( D79 . C213 ) by L449 , L456 , L455 , GRFUNC_1:2;
end;
L460: (D80 = ( (the Comp of C207) . C209 ) & D79 = ( (the Comp of C208) . C209 )) by L438 , MULTOP_1:def 1;
thus L461: thesis by L460 , L449 , L450 , GRFUNC_1:2;
end;
definition
let C214 being AltCatStr;
let C215 being (SubCatStr of C214);
attr C215 is  full
means
:L462: (the Arrows of C215) = ( (the Arrows of C214) || (the carrier of C215) );
end;
definition
let C216 being  with_units non  empty AltCatStr;
let C217 being (SubCatStr of C216);
attr C217 is  id-inheriting
means
:L464: (for B142 being (object of C217) holds (for B143 being (object of C216) holds (B142 = B143 implies ( idm B143 ) in <^ B142 , B142 ^>))) if C217 is non  empty otherwise (not contradiction);
consistency;
end;
registration
let C218 being AltCatStr;
cluster  full  strict for (SubCatStr of C218);
existence
proof
set D85 = ( the AltCatStr of C218 );
reconsider D86 = D85 as (SubCatStr of C218) by L372;
take D86;
L466: ( dom (the Arrows of C218) ) = [: (the carrier of D86) , (the carrier of D86) :] by PARTFUN1:def 2;
thus L467: (the Arrows of D86) = ( (the Arrows of C218) || (the carrier of D86) ) by L466 , RELAT_1:69;
thus L468: thesis;
end;
end;
registration
let C219 being non  empty AltCatStr;
cluster  full non  empty  strict for (SubCatStr of C219);
existence
proof
set D87 = ( the AltCatStr of C219 );
reconsider D88 = D87 as (SubCatStr of C219) by L372;
take D88;
L470: ( dom (the Arrows of C219) ) = [: (the carrier of D88) , (the carrier of D88) :] by PARTFUN1:def 2;
thus L471: (the Arrows of D88) = ( (the Arrows of C219) || (the carrier of D88) ) by L470 , RELAT_1:69;
thus L472: (the carrier of D88) is non  empty;
thus L473: thesis;
end;
end;
registration
let C220 being category;
let C221 being (object of C220);
cluster ( ObCat C221 ) ->  full  id-inheriting;
coherence
proof
L475: (the carrier of ( ObCat C221 )) = { C221 } by L389;
L476: (the Arrows of ( ObCat C221 )) = ( (C221 , C221) :-> <^ C221 , C221 ^> ) by L389
.= ( (the Arrows of C220) || (the carrier of ( ObCat C221 )) ) by L475 , FUNCT_7:8;
thus L477: ( ObCat C221 ) is  full by L476 , L462;
L478:
now
let C222 being (object of ( ObCat C221 ));
let C223 being (object of C220);
assume L479: C222 = C223;
L480: C222 = C221 by L417;
L481: <^ C222 , C222 ^> = ( ( (C221 , C221) :-> <^ C221 , C221 ^> ) . (C221 , C221) ) by L480 , L389
.= <^ C223 , C223 ^> by L480 , L479 , ALTCAT_1:10;
thus L482: ( idm C223 ) in <^ C222 , C222 ^> by L481 , ALTCAT_1:19;
end;
thus L483: thesis by L478 , L464;
end;
end;
registration
let C224 being category;
cluster  full  id-inheriting non  empty  strict for (SubCatStr of C224);
existence
proof
set D89 = the (object of C224);
take ( ObCat D89 );
thus L485: thesis;
end;
end;
theorem
L487: (for R8 being non  empty  transitive AltCatStr holds (for B144 being (SubCatStr of R8) holds (((the carrier of B144) = (the carrier of R8) & (the Arrows of B144) = (the Arrows of R8)) implies ( the AltCatStr of B144 ) = ( the AltCatStr of R8 ))))
proof
let R8 being non  empty  transitive AltCatStr;
let C225 being (SubCatStr of R8);
assume that
L488: (the carrier of C225) = (the carrier of R8)
and
L489: (the Arrows of C225) = (the Arrows of R8);
L490: C225 is  transitive
proof
let C226 , C227 , C228 being (object of C225);
reconsider D90 = C226 , D91 = C227 , D92 = C228 as (object of R8) by L488;
assume L491: (<^ C226 , C227 ^> <> ( {} ) & <^ C227 , C228 ^> <> ( {} ));
L492: <^ C226 , C228 ^> = <^ D90 , D92 ^> by L489;
L493: (<^ C226 , C227 ^> = <^ D90 , D91 ^> & <^ C227 , C228 ^> = <^ D91 , D92 ^>) by L489;
thus L494: thesis by L493 , L492 , L491 , ALTCAT_1:def 2;
end;
L495: R8 is (SubCatStr of R8) by L374;
L496: C225 is non  empty by L488;
L497: R8 is (SubCatStr of C225) by L496 , L488 , L489 , L490 , L495 , L430;
thus L498: thesis by L497 , L380;
end;
theorem
L499: (for R8 being non  empty  transitive AltCatStr holds (for B145 , B146 being non  empty  transitive (SubCatStr of R8) holds (((the carrier of B145) = (the carrier of B146) & (the Arrows of B145) = (the Arrows of B146)) implies ( the AltCatStr of B145 ) = ( the AltCatStr of B146 ))))
proof
let R8 being non  empty  transitive AltCatStr;
let C229 , C230 being non  empty  transitive (SubCatStr of R8);
assume L500: ((the carrier of C229) = (the carrier of C230) & (the Arrows of C229) = (the Arrows of C230));
L501: (C229 is (SubCatStr of C230) & C230 is (SubCatStr of C229)) by L500 , L430;
thus L502: thesis by L501 , L380;
end;
theorem
L503: (for R8 being non  empty  transitive AltCatStr holds (for B147 being  full (SubCatStr of R8) holds ((the carrier of B147) = (the carrier of R8) implies ( the AltCatStr of B147 ) = ( the AltCatStr of R8 ))))
proof
let R8 being non  empty  transitive AltCatStr;
let C231 being  full (SubCatStr of R8);
assume that
L504: (the carrier of C231) = (the carrier of R8);
L505: ( dom (the Arrows of R8) ) = [: (the carrier of R8) , (the carrier of R8) :] by PARTFUN1:def 2;
L506: (the Arrows of C231) = ( (the Arrows of R8) || (the carrier of C231) ) by L462
.= (the Arrows of R8) by L504 , L505 , RELAT_1:69;
thus L507: thesis by L506 , L504 , L487;
end;
theorem
L508: (for B148 being non  empty AltCatStr holds (for B149 being  full non  empty (SubCatStr of B148) holds (for B150 , B151 being (object of B148) holds (for B152 , B153 being (object of B149) holds ((B150 = B152 & B151 = B153) implies <^ B150 , B151 ^> = <^ B152 , B153 ^>)))))
proof
let C232 being non  empty AltCatStr;
let C233 being  full non  empty (SubCatStr of C232);
let C234 , C235 being (object of C232);
let C236 , C237 being (object of C233);
assume that
L509: (C234 = C236 & C235 = C237);
L510: [ C236 , C237 ] in [: (the carrier of C233) , (the carrier of C233) :];
thus L511: <^ C234 , C235 ^> = ( ( (the Arrows of C232) || (the carrier of C233) ) . (C236 , C237) ) by L510 , L509 , FUNCT_1:49
.= <^ C236 , C237 ^> by L462;
end;
theorem
L512: (for B154 being non  empty AltCatStr holds (for B155 being non  empty (SubCatStr of B154) holds (for B156 being (object of B155) holds B156 is (object of B154))))
proof
let C238 being non  empty AltCatStr;
let C239 being non  empty (SubCatStr of C238);
let C240 being (object of C239);
L513: (C240 in (the carrier of C239) & (the carrier of C239) c= (the carrier of C238)) by L372;
thus L514: thesis by L513;
end;
registration
let C241 being  transitive non  empty AltCatStr;
cluster  full non  empty ->  transitive for (SubCatStr of C241);
coherence
proof
let C242 being (SubCatStr of C241);
assume L515: C242 is  full non  empty;
let C243 , C244 , C245 being (object of C242);
assume that
L516: (<^ C243 , C244 ^> <> ( {} ) & <^ C244 , C245 ^> <> ( {} ));
reconsider D93 = C243 , D94 = C244 , D95 = C245 as (object of C241) by L515 , L512;
L517: (<^ D93 , D94 ^> <> ( {} ) & <^ D94 , D95 ^> <> ( {} )) by L515 , L516 , L508;
L518: <^ D93 , D95 ^> <> ( {} ) by L517 , ALTCAT_1:def 2;
thus L519: thesis by L518 , L515 , L508;
end;
end;
theorem
L521: (for R8 being non  empty  transitive AltCatStr holds (for B157 , B158 being  full non  empty (SubCatStr of R8) holds ((the carrier of B157) = (the carrier of B158) implies ( the AltCatStr of B157 ) = ( the AltCatStr of B158 ))))
proof
let R8 being non  empty  transitive AltCatStr;
let C246 , C247 being  full non  empty (SubCatStr of R8);
assume L522: (the carrier of C246) = (the carrier of C247);
L523: (the Arrows of C246) = ( (the Arrows of R8) || (the carrier of C247) ) by L522 , L462
.= (the Arrows of C247) by L462;
thus L524: thesis by L523 , L522 , L499;
end;
theorem
L525: (for B159 being non  empty AltCatStr holds (for B160 being non  empty (SubCatStr of B159) holds (for B161 , B162 being (object of B159) holds (for B163 , B164 being (object of B160) holds ((B161 = B163 & B162 = B164) implies <^ B163 , B164 ^> c= <^ B161 , B162 ^>)))))
proof
let C248 being non  empty AltCatStr;
let C249 being non  empty (SubCatStr of C248);
let C250 , C251 being (object of C248);
let C252 , C253 being (object of C249);
assume that
L526: (C250 = C252 & C251 = C253);
L527: ([ C252 , C253 ] in [: (the carrier of C249) , (the carrier of C249) :] & (the Arrows of C249) cc= (the Arrows of C248)) by L372;
thus L528: thesis by L527 , L526 , L124;
end;
theorem
L529: (for B165 being non  empty  transitive AltCatStr holds (for B166 being non  empty  transitive (SubCatStr of B165) holds (for B167 , B168 , B169 being (object of B166) holds ((<^ B167 , B168 ^> <> ( {} ) & <^ B168 , B169 ^> <> ( {} )) implies (for B170 , B171 , B172 being (object of B165) holds ((B170 = B167 & B171 = B168 & B172 = B169) implies (for B173 being (Morphism of B170 , B171) holds (for B174 being (Morphism of B171 , B172) holds (for B175 being (Morphism of B167 , B168) holds (for B176 being (Morphism of B168 , B169) holds ((B173 = B175 & B174 = B176) implies ( B174 * B173 ) = ( B176 * B175 ))))))))))))
proof
let C254 being non  empty  transitive AltCatStr;
let C255 being non  empty  transitive (SubCatStr of C254);
let C256 , C257 , C258 being (object of C255);
assume that
L530: (<^ C256 , C257 ^> <> ( {} ) & <^ C257 , C258 ^> <> ( {} ));
let C259 , C260 , C261 being (object of C254);
assume that
L531: (C259 = C256 & C260 = C257 & C261 = C258);
let C262 being (Morphism of C259 , C260);
let C263 being (Morphism of C260 , C261);
let C264 being (Morphism of C256 , C257);
let C265 being (Morphism of C257 , C258);
assume that
L532: (C262 = C264 & C263 = C265);
L533: <^ C256 , C258 ^> <> ( {} ) by L530 , ALTCAT_1:def 2;
L534: ( dom ( (the Comp of C255) . (C256 , C257 , C258) ) ) = [: <^ C257 , C258 ^> , <^ C256 , C257 ^> :] by L533 , FUNCT_2:def 1;
L535: [ C265 , C264 ] in ( dom ( (the Comp of C255) . (C256 , C257 , C258) ) ) by L534 , L530 , ZFMISC_1:87;
L536: (the Comp of C255) cc= (the Comp of C254) by L372;
L537: (( (the Comp of C255) . (C256 , C257 , C258) ) = ( (the Comp of C255) . [ C256 , C257 , C258 ] ) & ( (the Comp of C254) . (C259 , C260 , C261) ) = ( (the Comp of C254) . [ C259 , C260 , C261 ] )) by MULTOP_1:def 1;
L538: ( (the Comp of C255) . (C256 , C257 , C258) ) c= ( (the Comp of C254) . (C259 , C260 , C261) ) by L537 , L531 , L536 , L124;
L539: (<^ C259 , C260 ^> <> ( {} ) & <^ C260 , C261 ^> <> ( {} )) by L530 , L531 , L525 , XBOOLE_1:3;
thus L540: ( C263 * C262 ) = ( ( (the Comp of C254) . (C259 , C260 , C261) ) . (C263 , C262) ) by L539 , ALTCAT_1:def 8
.= ( ( (the Comp of C255) . (C256 , C257 , C258) ) . (C265 , C264) ) by L532 , L535 , L538 , GRFUNC_1:2
.= ( C265 * C264 ) by L530 , ALTCAT_1:def 8;
end;
registration
let C266 being  associative  transitive non  empty AltCatStr;
cluster  transitive ->  associative for non  empty non  empty non  empty non  empty (SubCatStr of C266);
coherence
proof
let C267 being non  empty (SubCatStr of C266);
assume L541: C267 is  transitive;
reconsider D96 = C267 as  transitive non  empty (SubCatStr of C266) by L541;
L542: D96 is  associative
proof
let C268 , C269 , C270 , C271 being (object of D96);
L543: (C268 in (the carrier of D96) & C269 in (the carrier of D96));
L544: (C270 in (the carrier of D96) & C271 in (the carrier of D96));
L545: (the carrier of D96) c= (the carrier of C266) by L372;
reconsider D97 = C268 , D98 = C269 , D99 = C270 , D100 = C271 as (object of C266) by L545 , L543 , L544;
let C272 being (Morphism of C268 , C269);
let C273 being (Morphism of C269 , C270);
let C274 being (Morphism of C270 , C271);
assume that
L546: <^ C268 , C269 ^> <> ( {} )
and
L547: <^ C269 , C270 ^> <> ( {} )
and
L548: <^ C270 , C271 ^> <> ( {} );
L549: <^ C269 , C270 ^> c= <^ D98 , D99 ^> by L525;
L550: C273 in <^ C269 , C270 ^> by L547;
reconsider D101 = C273 as (Morphism of D98 , D99) by L550 , L549;
L551: <^ C268 , C269 ^> c= <^ D97 , D98 ^> by L525;
L552: C272 in <^ C268 , C269 ^> by L546;
reconsider D102 = C272 as (Morphism of D97 , D98) by L552 , L551;
L553: (<^ C268 , C270 ^> <> ( {} ) & ( C273 * C272 ) = ( D101 * D102 )) by L546 , L547 , L529 , ALTCAT_1:def 2;
L554: <^ C270 , C271 ^> c= <^ D99 , D100 ^> by L525;
L555: C274 in <^ C270 , C271 ^> by L548;
reconsider D103 = C274 as (Morphism of D99 , D100) by L555 , L554;
L556: <^ D99 , D100 ^> <> ( {} ) by L548 , L525 , XBOOLE_1:3;
L557: (<^ D97 , D98 ^> <> ( {} ) & <^ D98 , D99 ^> <> ( {} )) by L546 , L547 , L525 , XBOOLE_1:3;
L558: (<^ C269 , C271 ^> <> ( {} ) & ( C274 * C273 ) = ( D103 * D101 )) by L547 , L548 , L529 , ALTCAT_1:def 2;
thus L559: ( ( C274 * C273 ) * C272 ) = ( ( D103 * D101 ) * D102 ) by L558 , L546 , L529
.= ( D103 * ( D101 * D102 ) ) by L557 , L556 , L315
.= ( C274 * ( C273 * C272 ) ) by L548 , L553 , L529;
end;
thus L560: thesis by L542;
end;
end;
theorem
L562: (for B177 being non  empty AltCatStr holds (for B178 being non  empty (SubCatStr of B177) holds (for B179 , B180 being (object of B177) holds (for B181 , B182 being (object of B178) holds ((B179 = B181 & B180 = B182 & <^ B181 , B182 ^> <> ( {} )) implies (for B183 being (Morphism of B181 , B182) holds B183 is (Morphism of B179 , B180)))))))
proof
let C275 being non  empty AltCatStr;
let C276 being non  empty (SubCatStr of C275);
let C277 , C278 being (object of C275);
let C279 , C280 being (object of C276);
assume that
L563: (C277 = C279 & C278 = C280 & <^ C279 , C280 ^> <> ( {} ));
let C281 being (Morphism of C279 , C280);
L564: (C281 in <^ C279 , C280 ^> & <^ C279 , C280 ^> c= <^ C277 , C278 ^>) by L563 , L525;
thus L565: thesis by L564;
end;
registration
let C282 being  transitive  with_units non  empty AltCatStr;
cluster  id-inheriting  transitive ->  with_units for non  empty non  empty non  empty non  empty (SubCatStr of C282);
coherence
proof
let C283 being non  empty (SubCatStr of C282);
assume that
L566: C283 is  id-inheriting
and
L567: C283 is  transitive;
let C284 being (object of C283);
reconsider D104 = C284 as (object of C282) by L512;
reconsider D105 = ( idm D104 ) as (Morphism of C284 , C284) by L566 , L464;
L568: ( idm D104 ) in <^ C284 , C284 ^> by L566 , L464;
thus L569: <^ C284 , C284 ^> <> ( {} ) by L568;
take D105;
let C285 being (object of C283);
let C286 being (Morphism of C285 , C284);
let C287 being (Morphism of C284 , C285);
thus L570:now
reconsider D106 = C285 as (object of C282) by L512;
assume L571: <^ C285 , C284 ^> <> ( {} );
L572: <^ D106 , D104 ^> <> ( {} ) by L571 , L525 , XBOOLE_1:3;
reconsider D107 = C286 as (Morphism of D106 , D104) by L571 , L562;
thus L573: ( D105 * C286 ) = ( ( idm D104 ) * D107 ) by L567 , L568 , L571 , L529
.= C286 by L572 , ALTCAT_1:20;
end;
reconsider D108 = C285 as (object of C282) by L512;
assume L574: <^ C284 , C285 ^> <> ( {} );
L575: <^ D104 , D108 ^> <> ( {} ) by L574 , L525 , XBOOLE_1:3;
reconsider D109 = C287 as (Morphism of D104 , D108) by L574 , L562;
thus L576: ( C287 * D105 ) = ( D109 * ( idm D104 ) ) by L567 , L568 , L574 , L529
.= C287 by L575 , ALTCAT_1:def 17;
end;
end;
registration
let C288 being category;
cluster  id-inheriting  transitive for non  empty non  empty non  empty non  empty (SubCatStr of C288);
existence
proof
set D110 = the (object of C288);
take ( ObCat D110 );
thus L578: thesis;
end;
end;
definition
let C289 being category;
mode subcategory of C289
 is  id-inheriting  transitive (SubCatStr of C289);
end;
theorem
L581: (for B184 being category holds (for B185 being non  empty (subcategory of B184) holds (for B186 being (object of B185) holds (for B187 being (object of B184) holds (B186 = B187 implies ( idm B186 ) = ( idm B187 ))))))
proof
let C290 being category;
let C291 being non  empty (subcategory of C290);
let C292 being (object of C291);
let C293 being (object of C290);
assume L582: C292 = C293;
reconsider D111 = ( idm C293 ) as (Morphism of C292 , C292) by L582 , L464;
L583: ( idm C293 ) in <^ C292 , C292 ^> by L582 , L464;
L584:
now
let C294 being (object of C291);
assume that
L585: <^ C292 , C294 ^> <> ( {} );
reconsider D112 = C294 as (object of C290) by L512;
L586: <^ C293 , D112 ^> <> ( {} ) by L582 , L585 , L525 , XBOOLE_1:3;
let C295 being (Morphism of C292 , C294);
reconsider D113 = C295 as (Morphism of C293 , D112) by L582 , L585 , L562;
thus L587: ( C295 * D111 ) = ( D113 * ( idm C293 ) ) by L582 , L583 , L585 , L529
.= C295 by L586 , ALTCAT_1:def 17;
end;
thus L588: thesis by L584 , ALTCAT_1:def 17;
end;
