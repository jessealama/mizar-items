:: Stability of the 4-2 Binary Addition Circuit Cells. Part {I}
::  by Katsumi Wasaki
::
:: Received August 28, 2008
:: Copyright (c) 2008-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies CIRCCOMB, STRUCT_0, XBOOLE_0, MSUALG_1, GFACIRC1, FUNCT_4,
      LATTICES, CIRCUIT1, MSAFREE2, FINSEQ_1, TWOSCOMP, PARTFUN1, RELAT_1,
      MCART_1, FACIRC_1, SUBSET_1, FSM_1, MARGREL1, FUNCT_1, CIRCUIT2,
      XBOOLEAN, ARYTM_3, FTACELL1;
 notations TARSKI, XBOOLE_0, ENUMSET1,
      XTUPLE_0, SUBSET_1, NAT_1, MCART_1, RELAT_1,
      STRUCT_0, FUNCT_1, PARTFUN1, FINSEQ_1, MARGREL1, BINARITH, MSUALG_1,
      MSAFREE2, CIRCUIT1, CIRCUIT2, CIRCCOMB, FACIRC_1, TWOSCOMP, GFACIRC1;
 constructors ENUMSET1, BINARITH, CIRCUIT1, CIRCUIT2, FACIRC_1, TWOSCOMP,
      NAT_1, GFACIRC1, RELSET_1, XTUPLE_0;
 registrations RELAT_1, MARGREL1, CARD_3, CIRCCOMB, FACIRC_1, ORDINAL1,
      FINSEQ_1, FUNCT_1, XTUPLE_0;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FACIRC_1, GFACIRC1, XBOOLEAN, XTUPLE_0;
 theorems XBOOLE_0, XBOOLE_1, ZFMISC_1, ENUMSET1, MCART_1, FUNCT_1, FINSEQ_2,
      CIRCUIT1, CIRCUIT2, CIRCCOMB, FACIRC_1, TWOSCOMP, CIRCCMB2, GFACIRC1,
      XBOOLEAN;

begin
definition
let C1 , C2 , C3 , C4 , C5 being set;
func BitFTA0Str (C1 , C2 , C3 , C4 , C5) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( BitGFA0Str (C1 , C2 , C3) ) +* ( BitGFA0Str (( GFA0AdderOutput (C1 , C2 , C3) ) , C5 , C4) ) );
coherence;
end;
definition
let C6 , C7 , C8 , C9 , C10 being set;
func BitFTA0Circ (C6 , C7 , C8 , C9 , C10) ->  strict  Boolean  gate`2=den (Circuit of ( BitFTA0Str (C6 , C7 , C8 , C9 , C10) )) equals 
( ( BitGFA0Circ (C6 , C7 , C8) ) +* ( BitGFA0Circ (( GFA0AdderOutput (C6 , C7 , C8) ) , C10 , C9) ) );
coherence;
end;
theorem
L3: (for B1 , B2 , B3 , B4 , B5 being set holds ( InnerVertices ( BitFTA0Str (B1 , B2 , B3 , B4 , B5) ) ) = ( ( ( { [ <* B1 , B2 *> , ( xor2 ) ] , ( GFA0AdderOutput (B1 , B2 , B3) ) } \/ { [ <* B1 , B2 *> , ( and2 ) ] , [ <* B2 , B3 *> , ( and2 ) ] , [ <* B3 , B1 *> , ( and2 ) ] , ( GFA0CarryOutput (B1 , B2 , B3) ) } ) \/ { [ <* ( GFA0AdderOutput (B1 , B2 , B3) ) , B5 *> , ( xor2 ) ] , ( GFA0AdderOutput (( GFA0AdderOutput (B1 , B2 , B3) ) , B5 , B4) ) } ) \/ { [ <* ( GFA0AdderOutput (B1 , B2 , B3) ) , B5 *> , ( and2 ) ] , [ <* B5 , B4 *> , ( and2 ) ] , [ <* B4 , ( GFA0AdderOutput (B1 , B2 , B3) ) *> , ( and2 ) ] , ( GFA0CarryOutput (( GFA0AdderOutput (B1 , B2 , B3) ) , B5 , B4) ) } ))
proof
let C11 , C12 , C13 , C14 , C15 being set;
set D1 = ( BitFTA0Str (C11 , C12 , C13 , C14 , C15) );
set D2 = ( BitGFA0Str (C11 , C12 , C13) );
set D3 = ( GFA0AdderOutput (C11 , C12 , C13) );
set D4 = ( GFA0CarryOutput (C11 , C12 , C13) );
set D5 = ( BitGFA0Str (D3 , C15 , C14) );
set D6 = ( GFA0AdderOutput (D3 , C15 , C14) );
set D7 = ( GFA0CarryOutput (D3 , C15 , C14) );
set D8 = [ <* C11 , C12 *> , ( xor2 ) ];
set D9 = [ <* C11 , C12 *> , ( and2 ) ];
set D10 = [ <* C12 , C13 *> , ( and2 ) ];
set D11 = [ <* C13 , C11 *> , ( and2 ) ];
set D12 = [ <* D3 , C15 *> , ( xor2 ) ];
set D13 = [ <* D3 , C15 *> , ( and2 ) ];
set D14 = [ <* C15 , C14 *> , ( and2 ) ];
set D15 = [ <* C14 , D3 *> , ( and2 ) ];
L4: D2 tolerates D5 by CIRCCOMB:47;
thus L5: ( InnerVertices D1 ) = ( ( InnerVertices D2 ) \/ ( InnerVertices D5 ) ) by L4 , CIRCCOMB:11
.= ( ( ( ( { D8 } \/ { D3 } ) \/ { D9 , D10 , D11 } ) \/ { D4 } ) \/ ( InnerVertices D5 ) ) by GFACIRC1:31
.= ( ( ( { D8 , D3 } \/ { D9 , D10 , D11 } ) \/ { D4 } ) \/ ( InnerVertices D5 ) ) by ENUMSET1:1
.= ( ( { D8 , D3 } \/ ( { D9 , D10 , D11 } \/ { D4 } ) ) \/ ( InnerVertices D5 ) ) by XBOOLE_1:4
.= ( ( { D8 , D3 } \/ { D9 , D10 , D11 , D4 } ) \/ ( InnerVertices D5 ) ) by ENUMSET1:6
.= ( ( { D8 , D3 } \/ { D9 , D10 , D11 , D4 } ) \/ ( ( ( { D12 } \/ { D6 } ) \/ { D13 , D14 , D15 } ) \/ { D7 } ) ) by GFACIRC1:31
.= ( ( { D8 , D3 } \/ { D9 , D10 , D11 , D4 } ) \/ ( ( { D12 , D6 } \/ { D13 , D14 , D15 } ) \/ { D7 } ) ) by ENUMSET1:1
.= ( ( { D8 , D3 } \/ { D9 , D10 , D11 , D4 } ) \/ ( { D12 , D6 } \/ ( { D13 , D14 , D15 } \/ { D7 } ) ) ) by XBOOLE_1:4
.= ( ( { D8 , D3 } \/ { D9 , D10 , D11 , D4 } ) \/ ( { D12 , D6 } \/ { D13 , D14 , D15 , D7 } ) ) by ENUMSET1:6
.= ( ( ( { D8 , D3 } \/ { D9 , D10 , D11 , D4 } ) \/ { D12 , D6 } ) \/ { D13 , D14 , D15 , D7 } ) by XBOOLE_1:4;
end;
theorem
L6: (for B6 , B7 , B8 , B9 , B10 being set holds ( InnerVertices ( BitFTA0Str (B6 , B7 , B8 , B9 , B10) ) ) is Relation)
proof
let C16 , C17 , C18 , C19 , C20 being set;
set D16 = ( BitGFA0Str (C16 , C17 , C18) );
set D17 = ( GFA0AdderOutput (C16 , C17 , C18) );
set D18 = ( BitGFA0Str (D17 , C20 , C19) );
L7: (( InnerVertices D16 ) is Relation & ( InnerVertices D18 ) is Relation) by GFACIRC1:32;
thus L8: thesis by L7 , FACIRC_1:3;
end;
L9: (for B11 , B12 , B13 being set holds (for B14 being set holds ( GFA0AdderOutput (B11 , B12 , B13) ) <> [ B14 , ( and2 ) ]))
proof
let C21 , C22 , C23 being set;
let C24 being set;
set D19 = ( GFA0AdderOutput (C21 , C22 , C23) );
L10:
now
assume L11: ( [ C24 , ( and2 ) ] `2 ) = ( D19 `2 );
L12: ( [ C24 , ( and2 ) ] `2 ) = ( xor2 ) by L11 , MCART_1:7;
thus L13: contradiction by L12 , TWOSCOMP:9 , TWOSCOMP:11;
end;
thus L14: thesis by L10;
end;
L15: (for B15 , B16 , B17 being non  pair set holds (for B18 , B19 , B20 being set holds ( InputVertices ( BitGFA0Str (B15 , B16 , B17) ) ) misses ( InnerVertices ( BitGFA0Str (B18 , B19 , B20) ) )))
proof
let C25 , C26 , C27 being non  pair set;
let C28 , C29 , C30 being set;
set D20 = ( BitGFA0Str (C25 , C26 , C27) );
L16: ( InputVertices D20 ) is  without_pairs by GFACIRC1:35;
thus L17: thesis by L16 , FACIRC_1:5 , GFACIRC1:32;
end;
theorem
L18: (for B21 , B22 , B23 , B24 being non  pair set holds (for B25 being set holds ((B25 <> [ <* B24 , ( GFA0AdderOutput (B21 , B22 , B23) ) *> , ( and2 ) ] & (not B25 in ( InnerVertices ( BitGFA0Str (B21 , B22 , B23) ) ))) implies ( InputVertices ( BitFTA0Str (B21 , B22 , B23 , B24 , B25) ) ) = { B21 , B22 , B23 , B24 , B25 })))
proof
let C31 , C32 , C33 , C34 being non  pair set;
let C35 being set;
set D21 = ( BitFTA0Str (C31 , C32 , C33 , C34 , C35) );
set D22 = ( BitGFA0Str (C31 , C32 , C33) );
set D23 = ( GFA0AdderOutput (C31 , C32 , C33) );
set D24 = ( GFA0CarryOutput (C31 , C32 , C33) );
set D25 = ( BitGFA0Str (D23 , C35 , C34) );
set D26 = [ <* C31 , C32 *> , ( xor2 ) ];
set D27 = [ <* C31 , C32 *> , ( and2 ) ];
set D28 = [ <* C32 , C33 *> , ( and2 ) ];
set D29 = [ <* C33 , C31 *> , ( and2 ) ];
set D30 = [ <* C35 , C34 *> , ( and2 ) ];
set D31 = [ <* C34 , D23 *> , ( and2 ) ];
assume that
L19: C35 <> D31
and
L20: (not C35 in ( InnerVertices D22 ));
L21: (not C34 in { D23 , D26 , D27 , D28 , D29 , D24 }) by ENUMSET1:def 4;
L22: D23 in { D23 , D26 , D27 , D28 , D29 , D24 } by ENUMSET1:def 4;
L23: ( { D23 } \ { D23 , D26 , D27 , D28 , D29 , D24 } ) = ( {} ) by L22 , ZFMISC_1:60;
L24: ( InnerVertices D22 ) = ( ( ( { D26 } \/ { D23 } ) \/ { D27 , D28 , D29 } ) \/ { D24 } ) by GFACIRC1:31
.= ( ( { D26 , D23 } \/ { D27 , D28 , D29 } ) \/ { D24 } ) by ENUMSET1:1
.= ( { D26 , D23 } \/ ( { D27 , D28 , D29 } \/ { D24 } ) ) by XBOOLE_1:4
.= ( { D23 , D26 } \/ { D27 , D28 , D29 , D24 } ) by ENUMSET1:6
.= { D23 , D26 , D27 , D28 , D29 , D24 } by ENUMSET1:12;
L25: ( { D23 , C35 , C34 } \ ( InnerVertices D22 ) ) = ( ( { D23 } \/ { C35 , C34 } ) \ { D23 , D26 , D27 , D28 , D29 , D24 } ) by L24 , ENUMSET1:2
.= ( ( { D23 } \ { D23 , D26 , D27 , D28 , D29 , D24 } ) \/ ( { C35 , C34 } \ { D23 , D26 , D27 , D28 , D29 , D24 } ) ) by XBOOLE_1:42
.= ( ( { C35 } \/ { C34 } ) \ { D23 , D26 , D27 , D28 , D29 , D24 } ) by L23 , ENUMSET1:1
.= ( ( { C35 } \ { D23 , D26 , D27 , D28 , D29 , D24 } ) \/ ( { C34 } \ { D23 , D26 , D27 , D28 , D29 , D24 } ) ) by XBOOLE_1:42
.= ( { C35 } \/ ( { C34 } \ { D23 , D26 , D27 , D28 , D29 , D24 } ) ) by L20 , L24 , ZFMISC_1:59
.= ( { C35 } \/ { C34 } ) by L21 , ZFMISC_1:59
.= { C35 , C34 } by ENUMSET1:1;
L26: D23 <> D30 by L9;
L27: (( InnerVertices D25 ) misses ( InputVertices D22 ) & D22 tolerates D25) by L15 , CIRCCOMB:47;
thus L28: ( InputVertices D21 ) = ( ( InputVertices D22 ) \/ ( ( InputVertices D25 ) \ ( InnerVertices D22 ) ) ) by L27 , FACIRC_1:4
.= ( { C31 , C32 , C33 } \/ ( ( InputVertices D25 ) \ ( InnerVertices D22 ) ) ) by GFACIRC1:34
.= ( { C31 , C32 , C33 } \/ ( { D23 , C35 , C34 } \ ( InnerVertices D22 ) ) ) by L19 , L26 , GFACIRC1:33
.= { C31 , C32 , C33 , C34 , C35 } by L25 , ENUMSET1:9;
end;
theorem
L29: (for B26 , B27 , B28 , B29 , B30 being set holds (B26 in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) )) & B27 in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) )) & B28 in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) )) & B29 in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) )) & B30 in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) )) & [ <* B26 , B27 *> , ( xor2 ) ] in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) )) & ( GFA0AdderOutput (B26 , B27 , B28) ) in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) )) & [ <* B26 , B27 *> , ( and2 ) ] in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) )) & [ <* B27 , B28 *> , ( and2 ) ] in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) )) & [ <* B28 , B26 *> , ( and2 ) ] in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) )) & ( GFA0CarryOutput (B26 , B27 , B28) ) in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) )) & [ <* ( GFA0AdderOutput (B26 , B27 , B28) ) , B30 *> , ( xor2 ) ] in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) )) & ( GFA0AdderOutput (( GFA0AdderOutput (B26 , B27 , B28) ) , B30 , B29) ) in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) )) & [ <* ( GFA0AdderOutput (B26 , B27 , B28) ) , B30 *> , ( and2 ) ] in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) )) & [ <* B30 , B29 *> , ( and2 ) ] in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) )) & [ <* B29 , ( GFA0AdderOutput (B26 , B27 , B28) ) *> , ( and2 ) ] in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) )) & ( GFA0CarryOutput (( GFA0AdderOutput (B26 , B27 , B28) ) , B30 , B29) ) in (the carrier of ( BitFTA0Str (B26 , B27 , B28 , B29 , B30) ))))
proof
let C36 , C37 , C38 , C39 , C40 being set;
set D32 = ( BitGFA0Str (C36 , C37 , C38) );
set D33 = ( GFA0AdderOutput (C36 , C37 , C38) );
set D34 = ( GFA0CarryOutput (C36 , C37 , C38) );
set D35 = ( BitGFA0Str (D33 , C40 , C39) );
set D36 = ( GFA0AdderOutput (D33 , C40 , C39) );
set D37 = ( GFA0CarryOutput (D33 , C40 , C39) );
set D38 = [ <* C36 , C37 *> , ( xor2 ) ];
set D39 = [ <* C36 , C37 *> , ( and2 ) ];
set D40 = [ <* C37 , C38 *> , ( and2 ) ];
set D41 = [ <* C38 , C36 *> , ( and2 ) ];
set D42 = [ <* D33 , C40 *> , ( xor2 ) ];
set D43 = [ <* D33 , C40 *> , ( and2 ) ];
set D44 = [ <* C40 , C39 *> , ( and2 ) ];
set D45 = [ <* C39 , D33 *> , ( and2 ) ];
L30: (C38 in (the carrier of D32) & D38 in (the carrier of D32)) by GFACIRC1:36;
L31: (D39 in (the carrier of D32) & D40 in (the carrier of D32)) by GFACIRC1:36;
L32: (D33 in (the carrier of D35) & C40 in (the carrier of D35)) by GFACIRC1:36;
L33: (D41 in (the carrier of D32) & D34 in (the carrier of D32)) by GFACIRC1:36;
L34: D37 in (the carrier of D35) by GFACIRC1:36;
L35: (D44 in (the carrier of D35) & D45 in (the carrier of D35)) by GFACIRC1:36;
L36: (D36 in (the carrier of D35) & D43 in (the carrier of D35)) by GFACIRC1:36;
L37: (C39 in (the carrier of D35) & D42 in (the carrier of D35)) by GFACIRC1:36;
L38: (C36 in (the carrier of D32) & C37 in (the carrier of D32)) by GFACIRC1:36;
thus L39: thesis by L38 , L30 , L31 , L33 , L32 , L37 , L36 , L35 , L34 , FACIRC_1:20;
end;
theorem
L40: (for B31 , B32 , B33 , B34 , B35 being set holds ([ <* B31 , B32 *> , ( xor2 ) ] in ( InnerVertices ( BitFTA0Str (B31 , B32 , B33 , B34 , B35) ) ) & ( GFA0AdderOutput (B31 , B32 , B33) ) in ( InnerVertices ( BitFTA0Str (B31 , B32 , B33 , B34 , B35) ) ) & [ <* B31 , B32 *> , ( and2 ) ] in ( InnerVertices ( BitFTA0Str (B31 , B32 , B33 , B34 , B35) ) ) & [ <* B32 , B33 *> , ( and2 ) ] in ( InnerVertices ( BitFTA0Str (B31 , B32 , B33 , B34 , B35) ) ) & [ <* B33 , B31 *> , ( and2 ) ] in ( InnerVertices ( BitFTA0Str (B31 , B32 , B33 , B34 , B35) ) ) & ( GFA0CarryOutput (B31 , B32 , B33) ) in ( InnerVertices ( BitFTA0Str (B31 , B32 , B33 , B34 , B35) ) ) & [ <* ( GFA0AdderOutput (B31 , B32 , B33) ) , B35 *> , ( xor2 ) ] in ( InnerVertices ( BitFTA0Str (B31 , B32 , B33 , B34 , B35) ) ) & ( GFA0AdderOutput (( GFA0AdderOutput (B31 , B32 , B33) ) , B35 , B34) ) in ( InnerVertices ( BitFTA0Str (B31 , B32 , B33 , B34 , B35) ) ) & [ <* ( GFA0AdderOutput (B31 , B32 , B33) ) , B35 *> , ( and2 ) ] in ( InnerVertices ( BitFTA0Str (B31 , B32 , B33 , B34 , B35) ) ) & [ <* B35 , B34 *> , ( and2 ) ] in ( InnerVertices ( BitFTA0Str (B31 , B32 , B33 , B34 , B35) ) ) & [ <* B34 , ( GFA0AdderOutput (B31 , B32 , B33) ) *> , ( and2 ) ] in ( InnerVertices ( BitFTA0Str (B31 , B32 , B33 , B34 , B35) ) ) & ( GFA0CarryOutput (( GFA0AdderOutput (B31 , B32 , B33) ) , B35 , B34) ) in ( InnerVertices ( BitFTA0Str (B31 , B32 , B33 , B34 , B35) ) )))
proof
let C41 , C42 , C43 , C44 , C45 being set;
set D46 = ( BitFTA0Str (C41 , C42 , C43 , C44 , C45) );
set D47 = ( GFA0AdderOutput (C41 , C42 , C43) );
set D48 = ( GFA0CarryOutput (C41 , C42 , C43) );
set D49 = ( GFA0AdderOutput (D47 , C45 , C44) );
set D50 = ( GFA0CarryOutput (D47 , C45 , C44) );
set D51 = [ <* C41 , C42 *> , ( xor2 ) ];
set D52 = [ <* C41 , C42 *> , ( and2 ) ];
set D53 = [ <* C42 , C43 *> , ( and2 ) ];
set D54 = [ <* C43 , C41 *> , ( and2 ) ];
set D55 = [ <* D47 , C45 *> , ( xor2 ) ];
set D56 = [ <* D47 , C45 *> , ( and2 ) ];
set D57 = [ <* C45 , C44 *> , ( and2 ) ];
set D58 = [ <* C44 , D47 *> , ( and2 ) ];
set D59 = { D51 , D47 , D52 , D53 , D54 , D48 };
set D60 = { D55 , D49 , D56 , D57 , D58 , D50 };
L41: (D51 in D59 & D47 in D59) by ENUMSET1:def 4;
L42: (D52 in D59 & D53 in D59) by ENUMSET1:def 4;
L43: (D55 in D60 & D49 in D60) by ENUMSET1:def 4;
L44: (D54 in D59 & D48 in D59) by ENUMSET1:def 4;
L45: (D58 in D60 & D50 in D60) by ENUMSET1:def 4;
L46: (D56 in D60 & D57 in D60) by ENUMSET1:def 4;
L47: ( InnerVertices D46 ) = ( ( ( { D51 , D47 } \/ { D52 , D53 , D54 , D48 } ) \/ { D55 , D49 } ) \/ { D56 , D57 , D58 , D50 } ) by L3
.= ( ( D59 \/ { D55 , D49 } ) \/ { D56 , D57 , D58 , D50 } ) by ENUMSET1:12
.= ( D59 \/ ( { D55 , D49 } \/ { D56 , D57 , D58 , D50 } ) ) by XBOOLE_1:4
.= ( D59 \/ D60 ) by ENUMSET1:12;
thus L48: thesis by L47 , L41 , L42 , L44 , L43 , L46 , L45 , XBOOLE_0:def 3;
end;
theorem
L49: (for B36 , B37 , B38 , B39 being non  pair set holds (for B40 being set holds ((B40 <> [ <* B39 , ( GFA0AdderOutput (B36 , B37 , B38) ) *> , ( and2 ) ] & (not B40 in ( InnerVertices ( BitGFA0Str (B36 , B37 , B38) ) ))) implies (B36 in ( InputVertices ( BitFTA0Str (B36 , B37 , B38 , B39 , B40) ) ) & B37 in ( InputVertices ( BitFTA0Str (B36 , B37 , B38 , B39 , B40) ) ) & B38 in ( InputVertices ( BitFTA0Str (B36 , B37 , B38 , B39 , B40) ) ) & B39 in ( InputVertices ( BitFTA0Str (B36 , B37 , B38 , B39 , B40) ) ) & B40 in ( InputVertices ( BitFTA0Str (B36 , B37 , B38 , B39 , B40) ) )))))
proof
let C46 , C47 , C48 , C49 being non  pair set;
let C50 being set;
set D61 = ( BitFTA0Str (C46 , C47 , C48 , C49 , C50) );
set D62 = ( BitGFA0Str (C46 , C47 , C48) );
set D63 = ( GFA0AdderOutput (C46 , C47 , C48) );
set D64 = [ <* C49 , D63 *> , ( and2 ) ];
assume L50: (C50 <> D64 & (not C50 in ( InnerVertices D62 )));
L51: ( InputVertices D61 ) = { C46 , C47 , C48 , C49 , C50 } by L50 , L18;
thus L52: thesis by L51 , ENUMSET1:def 3;
end;
definition
let C51 , C52 , C53 , C54 , C55 being set;
func BitFTA0CarryOutput (C51 , C52 , C53 , C54 , C55) -> (Element of ( InnerVertices ( BitFTA0Str (C51 , C52 , C53 , C54 , C55) ) )) equals 
( GFA0CarryOutput (C51 , C52 , C53) );
coherence by L40;
func BitFTA0AdderOutputI (C51 , C52 , C53 , C54 , C55) -> (Element of ( InnerVertices ( BitFTA0Str (C51 , C52 , C53 , C54 , C55) ) )) equals 
( GFA0AdderOutput (C51 , C52 , C53) );
coherence by L40;
func BitFTA0AdderOutputP (C51 , C52 , C53 , C54 , C55) -> (Element of ( InnerVertices ( BitFTA0Str (C51 , C52 , C53 , C54 , C55) ) )) equals 
( GFA0CarryOutput (( GFA0AdderOutput (C51 , C52 , C53) ) , C55 , C54) );
coherence by L40;
func BitFTA0AdderOutputQ (C51 , C52 , C53 , C54 , C55) -> (Element of ( InnerVertices ( BitFTA0Str (C51 , C52 , C53 , C54 , C55) ) )) equals 
( GFA0AdderOutput (( GFA0AdderOutput (C51 , C52 , C53) ) , C55 , C54) );
coherence by L40;
end;
theorem
L54: (for B41 , B42 , B43 being non  pair set holds (for B44 , B45 being set holds (for B46 being (State of ( BitFTA0Circ (B41 , B42 , B43 , B44 , B45) )) holds (for B47 , B48 , B49 being (Element of ( BOOLEAN )) holds ((B47 = ( B46 . B41 ) & B48 = ( B46 . B42 ) & B49 = ( B46 . B43 )) implies (( ( Following (B46 , 2) ) . ( BitFTA0CarryOutput (B41 , B42 , B43 , B44 , B45) ) ) = ( ( ( B47 '&' B48 ) 'or' ( B48 '&' B49 ) ) 'or' ( B49 '&' B47 ) ) & ( ( Following (B46 , 2) ) . ( BitFTA0AdderOutputI (B41 , B42 , B43 , B44 , B45) ) ) = ( ( B47 'xor' B48 ) 'xor' B49 )))))))
proof
let C56 , C57 , C58 being non  pair set;
let C59 , C60 being set;
let C61 being (State of ( BitFTA0Circ (C56 , C57 , C58 , C59 , C60) ));
set D65 = ( BitGFA0Str (C56 , C57 , C58) );
set D66 = ( BitGFA0Circ (C56 , C57 , C58) );
set D67 = ( GFA0AdderOutput (C56 , C57 , C58) );
set D68 = ( GFA0CarryOutput (C56 , C57 , C58) );
set D69 = ( BitGFA0Str (D67 , C60 , C59) );
set D70 = ( BitGFA0Circ (D67 , C60 , C59) );
let C62 , C63 , C64 being (Element of ( BOOLEAN ));
assume that
L55: C62 = ( C61 . C56 )
and
L56: C63 = ( C61 . C57 )
and
L57: C64 = ( C61 . C58 );
reconsider D71 = ( C61 | (the carrier of D65) ) as (State of D66) by FACIRC_1:26;
L58: ( dom D71 ) = (the carrier of D65) by CIRCUIT1:3;
L59: C56 in (the carrier of D65) by GFACIRC1:36;
L60: C62 = ( D71 . C56 ) by L59 , L55 , L58 , FUNCT_1:47;
reconsider D72 = C61 as (State of ( D66 +* D70 ));
L61: ( InputVertices D65 ) misses ( InnerVertices D69 ) by L15;
L62: C58 in (the carrier of D65) by GFACIRC1:36;
L63: C64 = ( D71 . C58 ) by L62 , L57 , L58 , FUNCT_1:47;
L64: C57 in (the carrier of D65) by GFACIRC1:36;
L65: C63 = ( D71 . C57 ) by L64 , L56 , L58 , FUNCT_1:47;
L66: D68 in (the carrier of D65) by GFACIRC1:36;
L67: ( ( Following (D72 , 2) ) . ( GFA0CarryOutput (C56 , C57 , C58) ) ) = ( ( Following (D71 , 2) ) . ( GFA0CarryOutput (C56 , C57 , C58) ) ) by L66 , L61 , FACIRC_1:32;
thus L68: ( ( Following (C61 , 2) ) . ( BitFTA0CarryOutput (C56 , C57 , C58 , C59 , C60) ) ) = ( ( ( C62 '&' C63 ) 'or' ( C63 '&' C64 ) ) 'or' ( C64 '&' C62 ) ) by L67 , L60 , L65 , L63 , GFACIRC1:39;
L69: D67 in (the carrier of D65) by GFACIRC1:36;
L70: ( ( Following (D72 , 2) ) . ( GFA0AdderOutput (C56 , C57 , C58) ) ) = ( ( Following (D71 , 2) ) . ( GFA0AdderOutput (C56 , C57 , C58) ) ) by L69 , L61 , FACIRC_1:32;
thus L71: thesis by L70 , L60 , L65 , L63 , GFACIRC1:39;
end;
theorem
L72: (for B50 , B51 , B52 , B53 being non  pair set holds (for B54 being set holds ((B54 <> [ <* B53 , ( GFA0AdderOutput (B50 , B51 , B52) ) *> , ( and2 ) ] & (not B54 in ( InnerVertices ( BitGFA0Str (B50 , B51 , B52) ) ))) implies (for B55 being (State of ( BitFTA0Circ (B50 , B51 , B52 , B53 , B54) )) holds (for B56 , B57 , B58 , B59 , B60 being (Element of ( BOOLEAN )) holds ((B56 = ( B55 . B50 ) & B57 = ( B55 . B51 ) & B58 = ( B55 . B52 ) & B59 = ( B55 . B53 ) & B60 = ( B55 . B54 )) implies (( ( Following (B55 , 2) ) . ( GFA0AdderOutput (B50 , B51 , B52) ) ) = ( ( B56 'xor' B57 ) 'xor' B58 ) & ( ( Following (B55 , 2) ) . B50 ) = B56 & ( ( Following (B55 , 2) ) . B51 ) = B57 & ( ( Following (B55 , 2) ) . B52 ) = B58 & ( ( Following (B55 , 2) ) . B53 ) = B59 & ( ( Following (B55 , 2) ) . B54 ) = B60)))))))
proof
let C65 , C66 , C67 , C68 being non  pair set;
let C69 being set;
assume that
L73: (C69 <> [ <* C68 , ( GFA0AdderOutput (C65 , C66 , C67) ) *> , ( and2 ) ] & (not C69 in ( InnerVertices ( BitGFA0Str (C65 , C66 , C67) ) )));
set D73 = ( GFA0AdderOutput (C65 , C66 , C67) );
set D74 = ( BitGFA0Circ (C65 , C66 , C67) );
set D75 = ( BitGFA0Str (C65 , C66 , C67) );
set D76 = ( BitGFA0Str (D73 , C69 , C68) );
set D77 = ( BitGFA0Circ (D73 , C69 , C68) );
set D78 = ( BitFTA0Str (C65 , C66 , C67 , C68 , C69) );
let C70 being (State of ( BitFTA0Circ (C65 , C66 , C67 , C68 , C69) ));
let C71 , C72 , C73 , C74 , C75 being (Element of ( BOOLEAN ));
assume that
L74: C71 = ( C70 . C65 )
and
L75: C72 = ( C70 . C66 )
and
L76: C73 = ( C70 . C67 )
and
L77: C74 = ( C70 . C68 )
and
L78: C75 = ( C70 . C69 );
reconsider D79 = ( C70 | (the carrier of D75) ) as (State of D74) by FACIRC_1:26;
L79: ( dom D79 ) = (the carrier of D75) by CIRCUIT1:3;
L80: C68 in ( InputVertices D78 ) by L73 , L49;
L81: ( ( Following C70 ) . C68 ) = C74 by L80 , L77 , CIRCUIT2:def 5;
L82: C67 in ( InputVertices D78 ) by L73 , L49;
L83: ( ( Following C70 ) . C67 ) = C73 by L82 , L76 , CIRCUIT2:def 5;
L84: C66 in (the carrier of D75) by GFACIRC1:36;
L85: C72 = ( D79 . C66 ) by L84 , L75 , L79 , FUNCT_1:47;
reconsider D80 = C70 as (State of ( D74 +* D77 ));
L86: (D73 in (the carrier of D75) & ( InputVertices D75 ) misses ( InnerVertices D76 )) by L15 , GFACIRC1:36;
L87: ( ( Following (D80 , 2) ) . ( GFA0AdderOutput (C65 , C66 , C67) ) ) = ( ( Following (D79 , 2) ) . ( GFA0AdderOutput (C65 , C66 , C67) ) ) by L86 , FACIRC_1:32;
L88: C67 in (the carrier of D75) by GFACIRC1:36;
L89: C73 = ( D79 . C67 ) by L88 , L76 , L79 , FUNCT_1:47;
L90: C65 in (the carrier of D75) by GFACIRC1:36;
L91: C71 = ( D79 . C65 ) by L90 , L74 , L79 , FUNCT_1:47;
thus L92: ( ( Following (C70 , 2) ) . ( GFA0AdderOutput (C65 , C66 , C67) ) ) = ( ( C71 'xor' C72 ) 'xor' C73 ) by L91 , L85 , L89 , L87 , GFACIRC1:39;
L93: C66 in ( InputVertices D78 ) by L73 , L49;
L94: ( ( Following C70 ) . C66 ) = C72 by L93 , L75 , CIRCUIT2:def 5;
L95: C69 in ( InputVertices D78 ) by L73 , L49;
L96: ( ( Following C70 ) . C69 ) = C75 by L95 , L78 , CIRCUIT2:def 5;
L97: C65 in ( InputVertices D78 ) by L73 , L49;
L98: (( Following (C70 , 2) ) = ( Following ( Following C70 ) ) & ( ( Following C70 ) . C65 ) = C71) by L97 , L74 , CIRCUIT2:def 5 , FACIRC_1:15;
thus L99: thesis by L98 , L97 , L93 , L82 , L80 , L95 , L94 , L83 , L81 , L96 , CIRCUIT2:def 5;
end;
L100: (for B61 , B62 , B63 , B64 being non  pair set holds (for B65 being set holds (for B66 being (State of ( BitFTA0Circ (B61 , B62 , B63 , B64 , B65) )) holds (for B67 , B68 , B69 being (Element of ( BOOLEAN )) holds ((B67 = ( B66 . ( GFA0AdderOutput (B61 , B62 , B63) ) ) & B68 = ( B66 . B64 ) & B69 = ( B66 . B65 )) implies (( ( Following B66 ) . [ <* ( GFA0AdderOutput (B61 , B62 , B63) ) , B65 *> , ( and2 ) ] ) = ( B67 '&' B69 ) & ( ( Following B66 ) . [ <* B65 , B64 *> , ( and2 ) ] ) = ( B69 '&' B68 ) & ( ( Following B66 ) . [ <* B64 , ( GFA0AdderOutput (B61 , B62 , B63) ) *> , ( and2 ) ] ) = ( B68 '&' B67 )))))))
proof
let C76 , C77 , C78 , C79 being non  pair set;
let C80 being set;
set D81 = ( BitFTA0Str (C76 , C77 , C78 , C79 , C80) );
set D82 = ( BitFTA0Circ (C76 , C77 , C78 , C79 , C80) );
set D83 = ( GFA0AdderOutput (C76 , C77 , C78) );
set D84 = [ <* D83 , C80 *> , ( and2 ) ];
set D85 = [ <* C80 , C79 *> , ( and2 ) ];
set D86 = [ <* C79 , D83 *> , ( and2 ) ];
let C81 being (State of D82);
let C82 , C83 , C84 being (Element of ( BOOLEAN ));
assume that
L101: C82 = ( C81 . D83 )
and
L102: C83 = ( C81 . C79 )
and
L103: C84 = ( C81 . C80 );
L104: ( dom C81 ) = (the carrier of D81) by CIRCUIT1:3;
L105: C80 in (the carrier of D81) by L29;
L106: D83 in (the carrier of D81) by L29;
L107: ( InnerVertices D81 ) = (the carrier' of D81) by FACIRC_1:37;
L108: D84 in (the carrier' of D81) by L107 , L40;
thus L109: ( ( Following C81 ) . D84 ) = ( ( and2 ) . ( C81 * <* D83 , C80 *> ) ) by L108 , FACIRC_1:35
.= ( ( and2 ) . <* C82 , C84 *> ) by L101 , L103 , L106 , L105 , L104 , FINSEQ_2:125
.= ( C82 '&' C84 ) by TWOSCOMP:def 1;
L110: C79 in (the carrier of D81) by L29;
L111: D85 in (the carrier' of D81) by L107 , L40;
thus L112: ( ( Following C81 ) . D85 ) = ( ( and2 ) . ( C81 * <* C80 , C79 *> ) ) by L111 , FACIRC_1:35
.= ( ( and2 ) . <* C84 , C83 *> ) by L102 , L103 , L110 , L105 , L104 , FINSEQ_2:125
.= ( C84 '&' C83 ) by TWOSCOMP:def 1;
L113: D86 in (the carrier' of D81) by L107 , L40;
thus L114: ( ( Following C81 ) . D86 ) = ( ( and2 ) . ( C81 * <* C79 , D83 *> ) ) by L113 , FACIRC_1:35
.= ( ( and2 ) . <* C83 , C82 *> ) by L101 , L102 , L106 , L110 , L104 , FINSEQ_2:125
.= ( C83 '&' C82 ) by TWOSCOMP:def 1;
end;
L115: (for B70 , B71 , B72 , B73 being non  pair set holds (for B74 being set holds (for B75 being (State of ( BitFTA0Circ (B70 , B71 , B72 , B73 , B74) )) holds (for B76 , B77 being (Element of ( BOOLEAN )) holds ((B76 = ( B75 . ( GFA0AdderOutput (B70 , B71 , B72) ) ) & B77 = ( B75 . B74 )) implies ( ( Following B75 ) . [ <* ( GFA0AdderOutput (B70 , B71 , B72) ) , B74 *> , ( xor2 ) ] ) = ( B76 'xor' B77 ))))))
proof
let C85 , C86 , C87 , C88 being non  pair set;
let C89 being set;
set D87 = ( BitFTA0Str (C85 , C86 , C87 , C88 , C89) );
set D88 = ( BitFTA0Circ (C85 , C86 , C87 , C88 , C89) );
set D89 = ( GFA0AdderOutput (C85 , C86 , C87) );
set D90 = [ <* D89 , C89 *> , ( xor2 ) ];
let C90 being (State of D88);
let C91 , C92 being (Element of ( BOOLEAN ));
assume that
L116: (C91 = ( C90 . D89 ) & C92 = ( C90 . C89 ));
L117: ( dom C90 ) = (the carrier of D87) by CIRCUIT1:3;
L118: (D89 in (the carrier of D87) & C89 in (the carrier of D87)) by L29;
L119: ( InnerVertices D87 ) = (the carrier' of D87) by FACIRC_1:37;
L120: D90 in (the carrier' of D87) by L119 , L40;
thus L121: ( ( Following C90 ) . D90 ) = ( ( xor2 ) . ( C90 * <* D89 , C89 *> ) ) by L120 , FACIRC_1:35
.= ( ( xor2 ) . <* C91 , C92 *> ) by L116 , L118 , L117 , FINSEQ_2:125
.= ( C91 'xor' C92 ) by TWOSCOMP:def 13;
end;
L122: (for B78 , B79 , B80 , B81 being non  pair set holds (for B82 being set holds ((B82 <> [ <* B81 , ( GFA0AdderOutput (B78 , B79 , B80) ) *> , ( and2 ) ] & (not B82 in ( InnerVertices ( BitGFA0Str (B78 , B79 , B80) ) ))) implies (for B83 being (State of ( BitFTA0Circ (B78 , B79 , B80 , B81 , B82) )) holds (for B84 , B85 , B86 , B87 , B88 being (Element of ( BOOLEAN )) holds ((B84 = ( B83 . B78 ) & B85 = ( B83 . B79 ) & B86 = ( B83 . B80 ) & B87 = ( B83 . B81 ) & B88 = ( B83 . B82 )) implies (( ( Following (B83 , 3) ) . [ <* ( GFA0AdderOutput (B78 , B79 , B80) ) , B82 *> , ( and2 ) ] ) = ( ( ( B84 'xor' B85 ) 'xor' B86 ) '&' B88 ) & ( ( Following (B83 , 3) ) . [ <* B82 , B81 *> , ( and2 ) ] ) = ( B88 '&' B87 ) & ( ( Following (B83 , 3) ) . [ <* B81 , ( GFA0AdderOutput (B78 , B79 , B80) ) *> , ( and2 ) ] ) = ( B87 '&' ( ( B84 'xor' B85 ) 'xor' B86 ) ) & ( ( Following (B83 , 3) ) . B78 ) = B84 & ( ( Following (B83 , 3) ) . B79 ) = B85 & ( ( Following (B83 , 3) ) . B80 ) = B86 & ( ( Following (B83 , 3) ) . B81 ) = B87 & ( ( Following (B83 , 3) ) . B82 ) = B88)))))))
proof
let C93 , C94 , C95 , C96 being non  pair set;
let C97 being set;
assume that
L123: (C97 <> [ <* C96 , ( GFA0AdderOutput (C93 , C94 , C95) ) *> , ( and2 ) ] & (not C97 in ( InnerVertices ( BitGFA0Str (C93 , C94 , C95) ) )));
set D91 = ( BitFTA0Str (C93 , C94 , C95 , C96 , C97) );
L124: (C93 in ( InputVertices D91 ) & C94 in ( InputVertices D91 )) by L123 , L49;
L125: (C95 in ( InputVertices D91 ) & C96 in ( InputVertices D91 )) by L123 , L49;
let C98 being (State of ( BitFTA0Circ (C93 , C94 , C95 , C96 , C97) ));
let C99 , C100 , C101 , C102 , C103 being (Element of ( BOOLEAN ));
assume that
L126: (C99 = ( C98 . C93 ) & C100 = ( C98 . C94 ) & C101 = ( C98 . C95 ) & C102 = ( C98 . C96 ) & C103 = ( C98 . C97 ));
L127: ( ( Following (C98 , 2) ) . C97 ) = C103 by L123 , L126 , L72;
set D92 = [ <* C97 , C96 *> , ( and2 ) ];
set D93 = ( GFA0AdderOutput (C93 , C94 , C95) );
set D94 = [ <* D93 , C97 *> , ( and2 ) ];
set D95 = [ <* C96 , D93 *> , ( and2 ) ];
L128: ( Following (C98 , ( 2 + 1 )) ) = ( Following ( Following (C98 , 2) ) ) by FACIRC_1:12;
L129: (( ( Following (C98 , 2) ) . D93 ) = ( ( C99 'xor' C100 ) 'xor' C101 ) & ( ( Following (C98 , 2) ) . C96 ) = C102) by L123 , L126 , L72;
thus L130: (( ( Following (C98 , 3) ) . D94 ) = ( ( ( C99 'xor' C100 ) 'xor' C101 ) '&' C103 ) & ( ( Following (C98 , 3) ) . D92 ) = ( C103 '&' C102 ) & ( ( Following (C98 , 3) ) . D95 ) = ( C102 '&' ( ( C99 'xor' C100 ) 'xor' C101 ) )) by L129 , L128 , L127 , L100;
L131: (( ( Following (C98 , 2) ) . C95 ) = C101 & ( ( Following (C98 , 2) ) . C96 ) = C102) by L123 , L126 , L72;
L132: ( ( Following (C98 , 2) ) . C97 ) = C103 by L123 , L126 , L72;
L133: C97 in ( InputVertices D91 ) by L123 , L49;
L134: (( ( Following (C98 , 2) ) . C93 ) = C99 & ( ( Following (C98 , 2) ) . C94 ) = C100) by L123 , L126 , L72;
thus L135: thesis by L134 , L128 , L124 , L125 , L133 , L131 , L132 , CIRCUIT2:def 5;
end;
L136: (for B89 , B90 , B91 , B92 being non  pair set holds (for B93 being set holds ((B93 <> [ <* B92 , ( GFA0AdderOutput (B89 , B90 , B91) ) *> , ( and2 ) ] & (not B93 in ( InnerVertices ( BitGFA0Str (B89 , B90 , B91) ) ))) implies (for B94 being (State of ( BitFTA0Circ (B89 , B90 , B91 , B92 , B93) )) holds (for B95 , B96 , B97 , B98 , B99 being (Element of ( BOOLEAN )) holds ((B95 = ( B94 . B89 ) & B96 = ( B94 . B90 ) & B97 = ( B94 . B91 ) & B98 = ( B94 . B92 ) & B99 = ( B94 . B93 )) implies (( ( Following (B94 , 3) ) . [ <* ( GFA0AdderOutput (B89 , B90 , B91) ) , B93 *> , ( xor2 ) ] ) = ( ( ( B95 'xor' B96 ) 'xor' B97 ) 'xor' B99 ) & ( ( Following (B94 , 3) ) . B89 ) = B95 & ( ( Following (B94 , 3) ) . B90 ) = B96 & ( ( Following (B94 , 3) ) . B91 ) = B97 & ( ( Following (B94 , 3) ) . B92 ) = B98 & ( ( Following (B94 , 3) ) . B93 ) = B99)))))))
proof
let C104 , C105 , C106 , C107 being non  pair set;
let C108 being set;
assume that
L137: (C108 <> [ <* C107 , ( GFA0AdderOutput (C104 , C105 , C106) ) *> , ( and2 ) ] & (not C108 in ( InnerVertices ( BitGFA0Str (C104 , C105 , C106) ) )));
set D96 = ( BitFTA0Str (C104 , C105 , C106 , C107 , C108) );
L138: (C104 in ( InputVertices D96 ) & C105 in ( InputVertices D96 )) by L137 , L49;
L139: (C106 in ( InputVertices D96 ) & C107 in ( InputVertices D96 )) by L137 , L49;
let C109 being (State of ( BitFTA0Circ (C104 , C105 , C106 , C107 , C108) ));
let C110 , C111 , C112 , C113 , C114 being (Element of ( BOOLEAN ));
assume that
L140: (C110 = ( C109 . C104 ) & C111 = ( C109 . C105 ) & C112 = ( C109 . C106 ) & C113 = ( C109 . C107 ) & C114 = ( C109 . C108 ));
L141: (( ( Following (C109 , 2) ) . C106 ) = C112 & ( ( Following (C109 , 2) ) . C107 ) = C113) by L137 , L140 , L72;
set D97 = ( GFA0AdderOutput (C104 , C105 , C106) );
set D98 = [ <* D97 , C108 *> , ( xor2 ) ];
L142: ( Following (C109 , ( 2 + 1 )) ) = ( Following ( Following (C109 , 2) ) ) by FACIRC_1:12;
L143: (( ( Following (C109 , 2) ) . D97 ) = ( ( C110 'xor' C111 ) 'xor' C112 ) & ( ( Following (C109 , 2) ) . C108 ) = C114) by L137 , L140 , L72;
thus L144: ( ( Following (C109 , 3) ) . D98 ) = ( ( ( C110 'xor' C111 ) 'xor' C112 ) 'xor' C114 ) by L143 , L142 , L115;
L145: ( ( Following (C109 , 2) ) . C108 ) = C114 by L137 , L140 , L72;
L146: C108 in ( InputVertices D96 ) by L137 , L49;
L147: (( ( Following (C109 , 2) ) . C104 ) = C110 & ( ( Following (C109 , 2) ) . C105 ) = C111) by L137 , L140 , L72;
thus L148: thesis by L147 , L142 , L138 , L139 , L146 , L141 , L145 , CIRCUIT2:def 5;
end;
L149: (for B100 , B101 , B102 , B103 being non  pair set holds (for B104 being set holds (for B105 being (State of ( BitFTA0Circ (B100 , B101 , B102 , B103 , B104) )) holds (for B106 , B107 , B108 being (Element of ( BOOLEAN )) holds ((B106 = ( B105 . [ <* ( GFA0AdderOutput (B100 , B101 , B102) ) , B104 *> , ( and2 ) ] ) & B107 = ( B105 . [ <* B104 , B103 *> , ( and2 ) ] ) & B108 = ( B105 . [ <* B103 , ( GFA0AdderOutput (B100 , B101 , B102) ) *> , ( and2 ) ] )) implies ( ( Following B105 ) . ( GFA0CarryOutput (( GFA0AdderOutput (B100 , B101 , B102) ) , B104 , B103) ) ) = ( ( B106 'or' B107 ) 'or' B108 ))))))
proof
let C115 , C116 , C117 , C118 being non  pair set;
let C119 being set;
set D99 = ( BitFTA0Str (C115 , C116 , C117 , C118 , C119) );
set D100 = ( BitFTA0Circ (C115 , C116 , C117 , C118 , C119) );
set D101 = ( GFA0AdderOutput (C115 , C116 , C117) );
set D102 = ( GFA0CarryOutput (D101 , C119 , C118) );
set D103 = [ <* D101 , C119 *> , ( and2 ) ];
set D104 = [ <* C119 , C118 *> , ( and2 ) ];
set D105 = [ <* C118 , D101 *> , ( and2 ) ];
let C120 being (State of D100);
let C121 , C122 , C123 being (Element of ( BOOLEAN ));
assume that
L150: (C121 = ( C120 . D103 ) & C122 = ( C120 . D104 ) & C123 = ( C120 . D105 ));
L151: (D103 in (the carrier of D99) & D104 in (the carrier of D99)) by L29;
L152: (D105 in (the carrier of D99) & ( dom C120 ) = (the carrier of D99)) by L29 , CIRCUIT1:3;
L153: ( InnerVertices D99 ) = (the carrier' of D99) by FACIRC_1:37;
L154: D102 in (the carrier' of D99) by L153 , L40;
thus L155: ( ( Following C120 ) . D102 ) = ( ( or3 ) . ( C120 * <* D103 , D104 , D105 *> ) ) by L154 , FACIRC_1:35
.= ( ( or3 ) . <* C121 , C122 , C123 *> ) by L150 , L151 , L152 , FINSEQ_2:126
.= ( ( C121 'or' C122 ) 'or' C123 ) by TWOSCOMP:def 24;
end;
L156: (for B109 , B110 , B111 , B112 being non  pair set holds (for B113 being set holds (for B114 being (State of ( BitFTA0Circ (B109 , B110 , B111 , B112 , B113) )) holds (for B115 , B116 being (Element of ( BOOLEAN )) holds ((B115 = ( B114 . [ <* ( GFA0AdderOutput (B109 , B110 , B111) ) , B113 *> , ( xor2 ) ] ) & B116 = ( B114 . B112 )) implies ( ( Following B114 ) . ( GFA0AdderOutput (( GFA0AdderOutput (B109 , B110 , B111) ) , B113 , B112) ) ) = ( B115 'xor' B116 ))))))
proof
let C124 , C125 , C126 , C127 being non  pair set;
let C128 being set;
set D106 = ( BitFTA0Str (C124 , C125 , C126 , C127 , C128) );
set D107 = ( BitFTA0Circ (C124 , C125 , C126 , C127 , C128) );
set D108 = ( GFA0AdderOutput (C124 , C125 , C126) );
set D109 = ( GFA0AdderOutput (D108 , C128 , C127) );
set D110 = [ <* D108 , C128 *> , ( xor2 ) ];
let C129 being (State of D107);
let C130 , C131 being (Element of ( BOOLEAN ));
assume that
L157: (C130 = ( C129 . D110 ) & C131 = ( C129 . C127 ));
L158: ( dom C129 ) = (the carrier of D106) by CIRCUIT1:3;
L159: (D110 in (the carrier of D106) & C127 in (the carrier of D106)) by L29;
L160: ( InnerVertices D106 ) = (the carrier' of D106) by FACIRC_1:37;
L161: D109 in (the carrier' of D106) by L160 , L40;
thus L162: ( ( Following C129 ) . D109 ) = ( ( xor2 ) . ( C129 * <* D110 , C127 *> ) ) by L161 , FACIRC_1:35
.= ( ( xor2 ) . <* C130 , C131 *> ) by L157 , L159 , L158 , FINSEQ_2:125
.= ( C130 'xor' C131 ) by TWOSCOMP:def 13;
end;
L163: (for B117 , B118 , B119 , B120 being non  pair set holds (for B121 being set holds ((B121 <> [ <* B120 , ( GFA0AdderOutput (B117 , B118 , B119) ) *> , ( and2 ) ] & (not B121 in ( InnerVertices ( BitGFA0Str (B117 , B118 , B119) ) ))) implies (for B122 being (State of ( BitFTA0Circ (B117 , B118 , B119 , B120 , B121) )) holds (for B123 , B124 , B125 , B126 , B127 being (Element of ( BOOLEAN )) holds ((B123 = ( B122 . B117 ) & B124 = ( B122 . B118 ) & B125 = ( B122 . B119 ) & B126 = ( B122 . B120 ) & B127 = ( B122 . B121 )) implies (( ( Following (B122 , 4) ) . ( GFA0CarryOutput (( GFA0AdderOutput (B117 , B118 , B119) ) , B121 , B120) ) ) = ( ( ( ( ( B123 'xor' B124 ) 'xor' B125 ) '&' B127 ) 'or' ( B127 '&' B126 ) ) 'or' ( B126 '&' ( ( B123 'xor' B124 ) 'xor' B125 ) ) ) & ( ( Following (B122 , 4) ) . B117 ) = B123 & ( ( Following (B122 , 4) ) . B118 ) = B124 & ( ( Following (B122 , 4) ) . B119 ) = B125 & ( ( Following (B122 , 4) ) . B120 ) = B126 & ( ( Following (B122 , 4) ) . B121 ) = B127)))))))
proof
let C132 , C133 , C134 , C135 being non  pair set;
let C136 being set;
assume that
L164: (C136 <> [ <* C135 , ( GFA0AdderOutput (C132 , C133 , C134) ) *> , ( and2 ) ] & (not C136 in ( InnerVertices ( BitGFA0Str (C132 , C133 , C134) ) )));
set D111 = ( BitFTA0Str (C132 , C133 , C134 , C135 , C136) );
L165: (C132 in ( InputVertices D111 ) & C133 in ( InputVertices D111 )) by L164 , L49;
L166: (C134 in ( InputVertices D111 ) & C135 in ( InputVertices D111 )) by L164 , L49;
set D112 = ( GFA0AdderOutput (C132 , C133 , C134) );
let C137 being (State of ( BitFTA0Circ (C132 , C133 , C134 , C135 , C136) ));
set D113 = [ <* C135 , D112 *> , ( and2 ) ];
let C138 , C139 , C140 , C141 , C142 being (Element of ( BOOLEAN ));
assume that
L167: (C138 = ( C137 . C132 ) & C139 = ( C137 . C133 ) & C140 = ( C137 . C134 ) & C141 = ( C137 . C135 ) & C142 = ( C137 . C136 ));
L168: ( ( Following (C137 , 3) ) . D113 ) = ( C141 '&' ( ( C138 'xor' C139 ) 'xor' C140 ) ) by L164 , L167 , L122;
set D114 = [ <* C136 , C135 *> , ( and2 ) ];
set D115 = [ <* D112 , C136 *> , ( and2 ) ];
set D116 = ( GFA0CarryOutput (D112 , C136 , C135) );
L169: ( Following (C137 , ( 3 + 1 )) ) = ( Following ( Following (C137 , 3) ) ) by FACIRC_1:12;
L170: (( ( Following (C137 , 3) ) . D115 ) = ( ( ( C138 'xor' C139 ) 'xor' C140 ) '&' C142 ) & ( ( Following (C137 , 3) ) . D114 ) = ( C142 '&' C141 )) by L164 , L167 , L122;
thus L171: ( ( Following (C137 , 4) ) . D116 ) = ( ( ( ( ( C138 'xor' C139 ) 'xor' C140 ) '&' C142 ) 'or' ( C142 '&' C141 ) ) 'or' ( C141 '&' ( ( C138 'xor' C139 ) 'xor' C140 ) ) ) by L170 , L169 , L168 , L149;
L172: (( ( Following (C137 , 3) ) . C134 ) = C140 & ( ( Following (C137 , 3) ) . C135 ) = C141) by L164 , L167 , L122;
L173: ( ( Following (C137 , 3) ) . C136 ) = C142 by L164 , L167 , L122;
L174: C136 in ( InputVertices D111 ) by L164 , L49;
L175: (( ( Following (C137 , 3) ) . C132 ) = C138 & ( ( Following (C137 , 3) ) . C133 ) = C139) by L164 , L167 , L122;
thus L176: thesis by L175 , L169 , L165 , L166 , L174 , L172 , L173 , CIRCUIT2:def 5;
end;
L177: (for B128 , B129 , B130 , B131 being non  pair set holds (for B132 being set holds ((B132 <> [ <* B131 , ( GFA0AdderOutput (B128 , B129 , B130) ) *> , ( and2 ) ] & (not B132 in ( InnerVertices ( BitGFA0Str (B128 , B129 , B130) ) ))) implies (for B133 being (State of ( BitFTA0Circ (B128 , B129 , B130 , B131 , B132) )) holds (for B134 , B135 , B136 , B137 , B138 being (Element of ( BOOLEAN )) holds ((B134 = ( B133 . B128 ) & B135 = ( B133 . B129 ) & B136 = ( B133 . B130 ) & B137 = ( B133 . B131 ) & B138 = ( B133 . B132 )) implies (( ( Following (B133 , 4) ) . ( GFA0AdderOutput (( GFA0AdderOutput (B128 , B129 , B130) ) , B132 , B131) ) ) = ( ( ( ( B134 'xor' B135 ) 'xor' B136 ) 'xor' B137 ) 'xor' B138 ) & ( ( Following (B133 , 4) ) . B128 ) = B134 & ( ( Following (B133 , 4) ) . B129 ) = B135 & ( ( Following (B133 , 4) ) . B130 ) = B136 & ( ( Following (B133 , 4) ) . B131 ) = B137 & ( ( Following (B133 , 4) ) . B132 ) = B138)))))))
proof
let C143 , C144 , C145 , C146 being non  pair set;
let C147 being set;
assume that
L178: (C147 <> [ <* C146 , ( GFA0AdderOutput (C143 , C144 , C145) ) *> , ( and2 ) ] & (not C147 in ( InnerVertices ( BitGFA0Str (C143 , C144 , C145) ) )));
set D117 = ( BitFTA0Str (C143 , C144 , C145 , C146 , C147) );
L179: (C143 in ( InputVertices D117 ) & C144 in ( InputVertices D117 )) by L178 , L49;
L180: (C145 in ( InputVertices D117 ) & C146 in ( InputVertices D117 )) by L178 , L49;
let C148 being (State of ( BitFTA0Circ (C143 , C144 , C145 , C146 , C147) ));
let C149 , C150 , C151 , C152 , C153 being (Element of ( BOOLEAN ));
assume that
L181: (C149 = ( C148 . C143 ) & C150 = ( C148 . C144 ) & C151 = ( C148 . C145 ) & C152 = ( C148 . C146 ) & C153 = ( C148 . C147 ));
L182: (( ( Following (C148 , 3) ) . C145 ) = C151 & ( ( Following (C148 , 3) ) . C146 ) = C152) by L178 , L181 , L136;
set D118 = ( GFA0AdderOutput (C143 , C144 , C145) );
set D119 = ( GFA0AdderOutput (D118 , C147 , C146) );
set D120 = [ <* D118 , C147 *> , ( xor2 ) ];
L183: ( Following (C148 , ( 3 + 1 )) ) = ( Following ( Following (C148 , 3) ) ) by FACIRC_1:12;
L184: (( ( Following (C148 , 3) ) . D120 ) = ( ( ( C149 'xor' C150 ) 'xor' C151 ) 'xor' C153 ) & ( ( Following (C148 , 3) ) . C146 ) = C152) by L178 , L181 , L136;
thus L185: ( ( Following (C148 , 4) ) . D119 ) = ( ( ( ( C149 'xor' C150 ) 'xor' C151 ) 'xor' C153 ) 'xor' C152 ) by L184 , L183 , L156
.= ( ( ( ( C149 'xor' C150 ) 'xor' C151 ) 'xor' C152 ) 'xor' C153 ) by XBOOLEAN:73;
L186: ( ( Following (C148 , 3) ) . C147 ) = C153 by L178 , L181 , L136;
L187: C147 in ( InputVertices D117 ) by L178 , L49;
L188: (( ( Following (C148 , 3) ) . C143 ) = C149 & ( ( Following (C148 , 3) ) . C144 ) = C150) by L178 , L181 , L136;
thus L189: thesis by L188 , L183 , L179 , L180 , L187 , L182 , L186 , CIRCUIT2:def 5;
end;
theorem
L190: (for B139 , B140 , B141 , B142 being non  pair set holds (for B143 being set holds ((B143 <> [ <* B142 , ( GFA0AdderOutput (B139 , B140 , B141) ) *> , ( and2 ) ] & (not B143 in ( InnerVertices ( BitGFA0Str (B139 , B140 , B141) ) ))) implies (for B144 being (State of ( BitFTA0Circ (B139 , B140 , B141 , B142 , B143) )) holds (for B145 , B146 , B147 , B148 , B149 being (Element of ( BOOLEAN )) holds ((B145 = ( B144 . B139 ) & B146 = ( B144 . B140 ) & B147 = ( B144 . B141 ) & B148 = ( B144 . B142 ) & B149 = ( B144 . B143 )) implies (( ( Following (B144 , 4) ) . ( BitFTA0AdderOutputP (B139 , B140 , B141 , B142 , B143) ) ) = ( ( ( ( ( B145 'xor' B146 ) 'xor' B147 ) '&' B149 ) 'or' ( B149 '&' B148 ) ) 'or' ( B148 '&' ( ( B145 'xor' B146 ) 'xor' B147 ) ) ) & ( ( Following (B144 , 4) ) . ( BitFTA0AdderOutputQ (B139 , B140 , B141 , B142 , B143) ) ) = ( ( ( ( B145 'xor' B146 ) 'xor' B147 ) 'xor' B148 ) 'xor' B149 )))))))) by L163 , L177;
theorem
L191: (for B150 , B151 , B152 , B153 being non  pair set holds (for B154 being set holds (B154 <> [ <* B153 , ( GFA0AdderOutput (B150 , B151 , B152) ) *> , ( and2 ) ] implies (for B155 being (State of ( BitFTA0Circ (B150 , B151 , B152 , B153 , B154) )) holds ( Following (B155 , 4) ) is  stable))))
proof
set D121 = 2;
set D122 = 2;
let C154 , C155 , C156 , C157 being non  pair set;
let C158 being set;
set D123 = ( BitFTA0Circ (C154 , C155 , C156 , C157 , C158) );
set D124 = ( BitGFA0Str (C154 , C155 , C156) );
set D125 = ( BitGFA0Circ (C154 , C155 , C156) );
set D126 = ( GFA0AdderOutput (C154 , C155 , C156) );
set D127 = ( BitGFA0Str (D126 , C158 , C157) );
set D128 = ( BitGFA0Circ (D126 , C158 , C157) );
set D129 = [ <* C158 , C157 *> , ( and2 ) ];
set D130 = [ <* C157 , D126 *> , ( and2 ) ];
assume L192: C158 <> D130;
let C159 being (State of D123);
L193: D125 tolerates D128 by CIRCCOMB:60;
L194: (the Sorts of D125) tolerates (the Sorts of D128) by L193 , CIRCCOMB:def 3;
reconsider D131 = ( C159 | (the carrier of D124) ) as (State of D125) by L194 , CIRCCOMB:26;
reconsider D132 = ( ( Following (C159 , D121) ) | (the carrier of D127) ) as (State of D128) by L194 , CIRCCOMB:26;
L195: (( InputVertices D124 ) misses ( InnerVertices D127 ) & ( Following (D131 , D121) ) is  stable) by L15 , GFACIRC1:40;
L196: D126 <> D129 by L9;
L197: ( Following (D132 , D122) ) is  stable by L196 , L192 , GFACIRC1:40;
L198: ( Following (C159 , ( D121 + D122 )) ) is  stable by L197 , L195 , CIRCCMB2:19 , CIRCCOMB:60;
thus L199: thesis by L198;
end;
begin
definition
let C160 , C161 , C162 , C163 , C164 being set;
func BitFTA1Str (C160 , C161 , C162 , C163 , C164) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( BitGFA1Str (C160 , C161 , C162) ) +* ( BitGFA2Str (( GFA1AdderOutput (C160 , C161 , C162) ) , C164 , C163) ) );
coherence;
end;
definition
let C165 , C166 , C167 , C168 , C169 being set;
func BitFTA1Circ (C165 , C166 , C167 , C168 , C169) ->  strict  Boolean  gate`2=den (Circuit of ( BitFTA1Str (C165 , C166 , C167 , C168 , C169) )) equals 
( ( BitGFA1Circ (C165 , C166 , C167) ) +* ( BitGFA2Circ (( GFA1AdderOutput (C165 , C166 , C167) ) , C169 , C168) ) );
coherence;
end;
theorem
L202: (for B156 , B157 , B158 , B159 , B160 being set holds ( InnerVertices ( BitFTA1Str (B156 , B157 , B158 , B159 , B160) ) ) = ( ( ( { [ <* B156 , B157 *> , ( xor2c ) ] , ( GFA1AdderOutput (B156 , B157 , B158) ) } \/ { [ <* B156 , B157 *> , ( and2c ) ] , [ <* B157 , B158 *> , ( and2a ) ] , [ <* B158 , B156 *> , ( and2 ) ] , ( GFA1CarryOutput (B156 , B157 , B158) ) } ) \/ { [ <* ( GFA1AdderOutput (B156 , B157 , B158) ) , B160 *> , ( xor2c ) ] , ( GFA2AdderOutput (( GFA1AdderOutput (B156 , B157 , B158) ) , B160 , B159) ) } ) \/ { [ <* ( GFA1AdderOutput (B156 , B157 , B158) ) , B160 *> , ( and2a ) ] , [ <* B160 , B159 *> , ( and2c ) ] , [ <* B159 , ( GFA1AdderOutput (B156 , B157 , B158) ) *> , ( and2b ) ] , ( GFA2CarryOutput (( GFA1AdderOutput (B156 , B157 , B158) ) , B160 , B159) ) } ))
proof
let C170 , C171 , C172 , C173 , C174 being set;
set D133 = ( BitFTA1Str (C170 , C171 , C172 , C173 , C174) );
set D134 = ( BitGFA1Str (C170 , C171 , C172) );
set D135 = ( GFA1AdderOutput (C170 , C171 , C172) );
set D136 = ( GFA1CarryOutput (C170 , C171 , C172) );
set D137 = ( BitGFA2Str (D135 , C174 , C173) );
set D138 = ( GFA2AdderOutput (D135 , C174 , C173) );
set D139 = ( GFA2CarryOutput (D135 , C174 , C173) );
set D140 = [ <* C170 , C171 *> , ( xor2c ) ];
set D141 = [ <* C170 , C171 *> , ( and2c ) ];
set D142 = [ <* C171 , C172 *> , ( and2a ) ];
set D143 = [ <* C172 , C170 *> , ( and2 ) ];
set D144 = [ <* D135 , C174 *> , ( xor2c ) ];
set D145 = [ <* D135 , C174 *> , ( and2a ) ];
set D146 = [ <* C174 , C173 *> , ( and2c ) ];
set D147 = [ <* C173 , D135 *> , ( and2b ) ];
L203: D134 tolerates D137 by CIRCCOMB:47;
thus L204: ( InnerVertices D133 ) = ( ( InnerVertices D134 ) \/ ( InnerVertices D137 ) ) by L203 , CIRCCOMB:11
.= ( ( ( ( { D140 } \/ { D135 } ) \/ { D141 , D142 , D143 } ) \/ { D136 } ) \/ ( InnerVertices D137 ) ) by GFACIRC1:63
.= ( ( ( { D140 , D135 } \/ { D141 , D142 , D143 } ) \/ { D136 } ) \/ ( InnerVertices D137 ) ) by ENUMSET1:1
.= ( ( { D140 , D135 } \/ ( { D141 , D142 , D143 } \/ { D136 } ) ) \/ ( InnerVertices D137 ) ) by XBOOLE_1:4
.= ( ( { D140 , D135 } \/ { D141 , D142 , D143 , D136 } ) \/ ( InnerVertices D137 ) ) by ENUMSET1:6
.= ( ( { D140 , D135 } \/ { D141 , D142 , D143 , D136 } ) \/ ( ( ( { D144 } \/ { D138 } ) \/ { D145 , D146 , D147 } ) \/ { D139 } ) ) by GFACIRC1:95
.= ( ( { D140 , D135 } \/ { D141 , D142 , D143 , D136 } ) \/ ( ( { D144 , D138 } \/ { D145 , D146 , D147 } ) \/ { D139 } ) ) by ENUMSET1:1
.= ( ( { D140 , D135 } \/ { D141 , D142 , D143 , D136 } ) \/ ( { D144 , D138 } \/ ( { D145 , D146 , D147 } \/ { D139 } ) ) ) by XBOOLE_1:4
.= ( ( { D140 , D135 } \/ { D141 , D142 , D143 , D136 } ) \/ ( { D144 , D138 } \/ { D145 , D146 , D147 , D139 } ) ) by ENUMSET1:6
.= ( ( ( { D140 , D135 } \/ { D141 , D142 , D143 , D136 } ) \/ { D144 , D138 } ) \/ { D145 , D146 , D147 , D139 } ) by XBOOLE_1:4;
end;
theorem
L205: (for B161 , B162 , B163 , B164 , B165 being set holds ( InnerVertices ( BitFTA1Str (B161 , B162 , B163 , B164 , B165) ) ) is Relation)
proof
let C175 , C176 , C177 , C178 , C179 being set;
set D148 = ( BitGFA1Str (C175 , C176 , C177) );
set D149 = ( GFA1AdderOutput (C175 , C176 , C177) );
set D150 = ( BitGFA2Str (D149 , C179 , C178) );
L206: (( InnerVertices D148 ) is Relation & ( InnerVertices D150 ) is Relation) by GFACIRC1:64 , GFACIRC1:96;
thus L207: thesis by L206 , FACIRC_1:3;
end;
L208: (for B166 , B167 , B168 being set holds (for B169 being set holds ( GFA1AdderOutput (B166 , B167 , B168) ) <> [ B169 , ( and2c ) ]))
proof
let C180 , C181 , C182 being set;
let C183 being set;
set D151 = ( GFA1AdderOutput (C180 , C181 , C182) );
L209:
now
assume L210: ( [ C183 , ( and2c ) ] `2 ) = ( D151 `2 );
L211: ( [ C183 , ( and2c ) ] `2 ) = ( xor2c ) by L210 , MCART_1:7;
thus L212: contradiction by L211 , GFACIRC1:3 , GFACIRC1:4;
end;
thus L213: thesis by L209;
end;
L214: (for B170 , B171 , B172 being non  pair set holds (for B173 , B174 , B175 being set holds ( InputVertices ( BitGFA1Str (B170 , B171 , B172) ) ) misses ( InnerVertices ( BitGFA2Str (B173 , B174 , B175) ) )))
proof
let C184 , C185 , C186 being non  pair set;
let C187 , C188 , C189 being set;
set D152 = ( BitGFA1Str (C184 , C185 , C186) );
L215: ( InputVertices D152 ) is  without_pairs by GFACIRC1:67;
thus L216: thesis by L215 , FACIRC_1:5 , GFACIRC1:96;
end;
theorem
L217: (for B176 , B177 , B178 , B179 being non  pair set holds (for B180 being set holds ((B180 <> [ <* B179 , ( GFA1AdderOutput (B176 , B177 , B178) ) *> , ( and2b ) ] & (not B180 in ( InnerVertices ( BitGFA1Str (B176 , B177 , B178) ) ))) implies ( InputVertices ( BitFTA1Str (B176 , B177 , B178 , B179 , B180) ) ) = { B176 , B177 , B178 , B179 , B180 })))
proof
let C190 , C191 , C192 , C193 being non  pair set;
let C194 being set;
set D153 = ( BitFTA1Str (C190 , C191 , C192 , C193 , C194) );
set D154 = ( BitGFA1Str (C190 , C191 , C192) );
set D155 = ( GFA1AdderOutput (C190 , C191 , C192) );
set D156 = ( GFA1CarryOutput (C190 , C191 , C192) );
set D157 = ( BitGFA2Str (D155 , C194 , C193) );
set D158 = [ <* C190 , C191 *> , ( xor2c ) ];
set D159 = [ <* C190 , C191 *> , ( and2c ) ];
set D160 = [ <* C191 , C192 *> , ( and2a ) ];
set D161 = [ <* C192 , C190 *> , ( and2 ) ];
set D162 = [ <* C193 , D155 *> , ( and2b ) ];
assume that
L218: C194 <> D162
and
L219: (not C194 in ( InnerVertices D154 ));
L220: (not C193 in { D155 , D158 , D159 , D160 , D161 , D156 }) by ENUMSET1:def 4;
L221: D155 in { D155 , D158 , D159 , D160 , D161 , D156 } by ENUMSET1:def 4;
L222: ( { D155 } \ { D155 , D158 , D159 , D160 , D161 , D156 } ) = ( {} ) by L221 , ZFMISC_1:60;
L223: ( InnerVertices D154 ) = ( ( ( { D158 } \/ { D155 } ) \/ { D159 , D160 , D161 } ) \/ { D156 } ) by GFACIRC1:63
.= ( ( { D158 , D155 } \/ { D159 , D160 , D161 } ) \/ { D156 } ) by ENUMSET1:1
.= ( { D158 , D155 } \/ ( { D159 , D160 , D161 } \/ { D156 } ) ) by XBOOLE_1:4
.= ( { D155 , D158 } \/ { D159 , D160 , D161 , D156 } ) by ENUMSET1:6
.= { D155 , D158 , D159 , D160 , D161 , D156 } by ENUMSET1:12;
L224: ( { D155 , C194 , C193 } \ ( InnerVertices D154 ) ) = ( ( { D155 } \/ { C194 , C193 } ) \ { D155 , D158 , D159 , D160 , D161 , D156 } ) by L223 , ENUMSET1:2
.= ( ( { D155 } \ { D155 , D158 , D159 , D160 , D161 , D156 } ) \/ ( { C194 , C193 } \ { D155 , D158 , D159 , D160 , D161 , D156 } ) ) by XBOOLE_1:42
.= ( ( { C194 } \/ { C193 } ) \ { D155 , D158 , D159 , D160 , D161 , D156 } ) by L222 , ENUMSET1:1
.= ( ( { C194 } \ { D155 , D158 , D159 , D160 , D161 , D156 } ) \/ ( { C193 } \ { D155 , D158 , D159 , D160 , D161 , D156 } ) ) by XBOOLE_1:42
.= ( { C194 } \/ ( { C193 } \ { D155 , D158 , D159 , D160 , D161 , D156 } ) ) by L219 , L223 , ZFMISC_1:59
.= ( { C194 } \/ { C193 } ) by L220 , ZFMISC_1:59
.= { C194 , C193 } by ENUMSET1:1;
L225: (( InnerVertices D157 ) misses ( InputVertices D154 ) & D154 tolerates D157) by L214 , CIRCCOMB:47;
thus L226: ( InputVertices D153 ) = ( ( InputVertices D154 ) \/ ( ( InputVertices D157 ) \ ( InnerVertices D154 ) ) ) by L225 , FACIRC_1:4
.= ( { C190 , C191 , C192 } \/ ( ( InputVertices D157 ) \ ( InnerVertices D154 ) ) ) by GFACIRC1:66
.= ( { C190 , C191 , C192 } \/ ( { D155 , C194 , C193 } \ ( InnerVertices D154 ) ) ) by L218 , L208 , GFACIRC1:97
.= { C190 , C191 , C192 , C193 , C194 } by L224 , ENUMSET1:9;
end;
theorem
L227: (for B181 , B182 , B183 , B184 , B185 being set holds (B181 in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) )) & B182 in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) )) & B183 in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) )) & B184 in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) )) & B185 in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) )) & [ <* B181 , B182 *> , ( xor2c ) ] in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) )) & ( GFA1AdderOutput (B181 , B182 , B183) ) in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) )) & [ <* B181 , B182 *> , ( and2c ) ] in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) )) & [ <* B182 , B183 *> , ( and2a ) ] in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) )) & [ <* B183 , B181 *> , ( and2 ) ] in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) )) & ( GFA1CarryOutput (B181 , B182 , B183) ) in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) )) & [ <* ( GFA1AdderOutput (B181 , B182 , B183) ) , B185 *> , ( xor2c ) ] in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) )) & ( GFA2AdderOutput (( GFA1AdderOutput (B181 , B182 , B183) ) , B185 , B184) ) in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) )) & [ <* ( GFA1AdderOutput (B181 , B182 , B183) ) , B185 *> , ( and2a ) ] in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) )) & [ <* B185 , B184 *> , ( and2c ) ] in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) )) & [ <* B184 , ( GFA1AdderOutput (B181 , B182 , B183) ) *> , ( and2b ) ] in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) )) & ( GFA2CarryOutput (( GFA1AdderOutput (B181 , B182 , B183) ) , B185 , B184) ) in (the carrier of ( BitFTA1Str (B181 , B182 , B183 , B184 , B185) ))))
proof
let C195 , C196 , C197 , C198 , C199 being set;
set D163 = ( BitGFA1Str (C195 , C196 , C197) );
set D164 = ( GFA1AdderOutput (C195 , C196 , C197) );
set D165 = ( GFA1CarryOutput (C195 , C196 , C197) );
set D166 = ( BitGFA2Str (D164 , C199 , C198) );
set D167 = ( GFA2AdderOutput (D164 , C199 , C198) );
set D168 = ( GFA2CarryOutput (D164 , C199 , C198) );
set D169 = [ <* C195 , C196 *> , ( xor2c ) ];
set D170 = [ <* C195 , C196 *> , ( and2c ) ];
set D171 = [ <* C196 , C197 *> , ( and2a ) ];
set D172 = [ <* C197 , C195 *> , ( and2 ) ];
set D173 = [ <* D164 , C199 *> , ( xor2c ) ];
set D174 = [ <* D164 , C199 *> , ( and2a ) ];
set D175 = [ <* C199 , C198 *> , ( and2c ) ];
set D176 = [ <* C198 , D164 *> , ( and2b ) ];
L228: (C197 in (the carrier of D163) & D169 in (the carrier of D163)) by GFACIRC1:68;
L229: (D170 in (the carrier of D163) & D171 in (the carrier of D163)) by GFACIRC1:68;
L230: (D164 in (the carrier of D166) & C199 in (the carrier of D166)) by GFACIRC1:100;
L231: (D172 in (the carrier of D163) & D165 in (the carrier of D163)) by GFACIRC1:68;
L232: D168 in (the carrier of D166) by GFACIRC1:100;
L233: (D175 in (the carrier of D166) & D176 in (the carrier of D166)) by GFACIRC1:100;
L234: (D167 in (the carrier of D166) & D174 in (the carrier of D166)) by GFACIRC1:100;
L235: (C198 in (the carrier of D166) & D173 in (the carrier of D166)) by GFACIRC1:100;
L236: (C195 in (the carrier of D163) & C196 in (the carrier of D163)) by GFACIRC1:68;
thus L237: thesis by L236 , L228 , L229 , L231 , L230 , L235 , L234 , L233 , L232 , FACIRC_1:20;
end;
theorem
L238: (for B186 , B187 , B188 , B189 , B190 being set holds ([ <* B186 , B187 *> , ( xor2c ) ] in ( InnerVertices ( BitFTA1Str (B186 , B187 , B188 , B189 , B190) ) ) & ( GFA1AdderOutput (B186 , B187 , B188) ) in ( InnerVertices ( BitFTA1Str (B186 , B187 , B188 , B189 , B190) ) ) & [ <* B186 , B187 *> , ( and2c ) ] in ( InnerVertices ( BitFTA1Str (B186 , B187 , B188 , B189 , B190) ) ) & [ <* B187 , B188 *> , ( and2a ) ] in ( InnerVertices ( BitFTA1Str (B186 , B187 , B188 , B189 , B190) ) ) & [ <* B188 , B186 *> , ( and2 ) ] in ( InnerVertices ( BitFTA1Str (B186 , B187 , B188 , B189 , B190) ) ) & ( GFA1CarryOutput (B186 , B187 , B188) ) in ( InnerVertices ( BitFTA1Str (B186 , B187 , B188 , B189 , B190) ) ) & [ <* ( GFA1AdderOutput (B186 , B187 , B188) ) , B190 *> , ( xor2c ) ] in ( InnerVertices ( BitFTA1Str (B186 , B187 , B188 , B189 , B190) ) ) & ( GFA2AdderOutput (( GFA1AdderOutput (B186 , B187 , B188) ) , B190 , B189) ) in ( InnerVertices ( BitFTA1Str (B186 , B187 , B188 , B189 , B190) ) ) & [ <* ( GFA1AdderOutput (B186 , B187 , B188) ) , B190 *> , ( and2a ) ] in ( InnerVertices ( BitFTA1Str (B186 , B187 , B188 , B189 , B190) ) ) & [ <* B190 , B189 *> , ( and2c ) ] in ( InnerVertices ( BitFTA1Str (B186 , B187 , B188 , B189 , B190) ) ) & [ <* B189 , ( GFA1AdderOutput (B186 , B187 , B188) ) *> , ( and2b ) ] in ( InnerVertices ( BitFTA1Str (B186 , B187 , B188 , B189 , B190) ) ) & ( GFA2CarryOutput (( GFA1AdderOutput (B186 , B187 , B188) ) , B190 , B189) ) in ( InnerVertices ( BitFTA1Str (B186 , B187 , B188 , B189 , B190) ) )))
proof
let C200 , C201 , C202 , C203 , C204 being set;
set D177 = ( BitFTA1Str (C200 , C201 , C202 , C203 , C204) );
set D178 = ( GFA1AdderOutput (C200 , C201 , C202) );
set D179 = ( GFA1CarryOutput (C200 , C201 , C202) );
set D180 = ( GFA2AdderOutput (D178 , C204 , C203) );
set D181 = ( GFA2CarryOutput (D178 , C204 , C203) );
set D182 = [ <* C200 , C201 *> , ( xor2c ) ];
set D183 = [ <* C200 , C201 *> , ( and2c ) ];
set D184 = [ <* C201 , C202 *> , ( and2a ) ];
set D185 = [ <* C202 , C200 *> , ( and2 ) ];
set D186 = [ <* D178 , C204 *> , ( xor2c ) ];
set D187 = [ <* D178 , C204 *> , ( and2a ) ];
set D188 = [ <* C204 , C203 *> , ( and2c ) ];
set D189 = [ <* C203 , D178 *> , ( and2b ) ];
set D190 = { D182 , D178 , D183 , D184 , D185 , D179 };
set D191 = { D186 , D180 , D187 , D188 , D189 , D181 };
L239: (D182 in D190 & D178 in D190) by ENUMSET1:def 4;
L240: (D183 in D190 & D184 in D190) by ENUMSET1:def 4;
L241: (D186 in D191 & D180 in D191) by ENUMSET1:def 4;
L242: (D185 in D190 & D179 in D190) by ENUMSET1:def 4;
L243: (D189 in D191 & D181 in D191) by ENUMSET1:def 4;
L244: (D187 in D191 & D188 in D191) by ENUMSET1:def 4;
L245: ( InnerVertices D177 ) = ( ( ( { D182 , D178 } \/ { D183 , D184 , D185 , D179 } ) \/ { D186 , D180 } ) \/ { D187 , D188 , D189 , D181 } ) by L202
.= ( ( D190 \/ { D186 , D180 } ) \/ { D187 , D188 , D189 , D181 } ) by ENUMSET1:12
.= ( D190 \/ ( { D186 , D180 } \/ { D187 , D188 , D189 , D181 } ) ) by XBOOLE_1:4
.= ( D190 \/ D191 ) by ENUMSET1:12;
thus L246: thesis by L245 , L239 , L240 , L242 , L241 , L244 , L243 , XBOOLE_0:def 3;
end;
theorem
L247: (for B191 , B192 , B193 , B194 being non  pair set holds (for B195 being set holds ((B195 <> [ <* B194 , ( GFA1AdderOutput (B191 , B192 , B193) ) *> , ( and2b ) ] & (not B195 in ( InnerVertices ( BitGFA1Str (B191 , B192 , B193) ) ))) implies (B191 in ( InputVertices ( BitFTA1Str (B191 , B192 , B193 , B194 , B195) ) ) & B192 in ( InputVertices ( BitFTA1Str (B191 , B192 , B193 , B194 , B195) ) ) & B193 in ( InputVertices ( BitFTA1Str (B191 , B192 , B193 , B194 , B195) ) ) & B194 in ( InputVertices ( BitFTA1Str (B191 , B192 , B193 , B194 , B195) ) ) & B195 in ( InputVertices ( BitFTA1Str (B191 , B192 , B193 , B194 , B195) ) )))))
proof
let C205 , C206 , C207 , C208 being non  pair set;
let C209 being set;
set D192 = ( BitFTA1Str (C205 , C206 , C207 , C208 , C209) );
set D193 = ( BitGFA1Str (C205 , C206 , C207) );
set D194 = ( GFA1AdderOutput (C205 , C206 , C207) );
set D195 = [ <* C208 , D194 *> , ( and2b ) ];
assume L248: (C209 <> D195 & (not C209 in ( InnerVertices D193 )));
L249: ( InputVertices D192 ) = { C205 , C206 , C207 , C208 , C209 } by L248 , L217;
thus L250: thesis by L249 , ENUMSET1:def 3;
end;
definition
let C210 , C211 , C212 , C213 , C214 being set;
func BitFTA1CarryOutput (C210 , C211 , C212 , C213 , C214) -> (Element of ( InnerVertices ( BitFTA1Str (C210 , C211 , C212 , C213 , C214) ) )) equals 
( GFA1CarryOutput (C210 , C211 , C212) );
coherence by L238;
func BitFTA1AdderOutputI (C210 , C211 , C212 , C213 , C214) -> (Element of ( InnerVertices ( BitFTA1Str (C210 , C211 , C212 , C213 , C214) ) )) equals 
( GFA1AdderOutput (C210 , C211 , C212) );
coherence by L238;
func BitFTA1AdderOutputP (C210 , C211 , C212 , C213 , C214) -> (Element of ( InnerVertices ( BitFTA1Str (C210 , C211 , C212 , C213 , C214) ) )) equals 
( GFA2CarryOutput (( GFA1AdderOutput (C210 , C211 , C212) ) , C214 , C213) );
coherence by L238;
func BitFTA1AdderOutputQ (C210 , C211 , C212 , C213 , C214) -> (Element of ( InnerVertices ( BitFTA1Str (C210 , C211 , C212 , C213 , C214) ) )) equals 
( GFA2AdderOutput (( GFA1AdderOutput (C210 , C211 , C212) ) , C214 , C213) );
coherence by L238;
end;
theorem
L252: (for B196 , B197 , B198 being non  pair set holds (for B199 , B200 being set holds (for B201 being (State of ( BitFTA1Circ (B196 , B197 , B198 , B199 , B200) )) holds (for B202 , B203 , B204 being (Element of ( BOOLEAN )) holds ((B202 = ( B201 . B196 ) & B203 = ( B201 . B197 ) & B204 = ( B201 . B198 )) implies (( ( Following (B201 , 2) ) . ( BitFTA1CarryOutput (B196 , B197 , B198 , B199 , B200) ) ) = ( ( ( B202 '&' ( 'not' B203 ) ) 'or' ( ( 'not' B203 ) '&' B204 ) ) 'or' ( B204 '&' B202 ) ) & ( ( Following (B201 , 2) ) . ( BitFTA1AdderOutputI (B196 , B197 , B198 , B199 , B200) ) ) = ( 'not' ( ( B202 'xor' ( 'not' B203 ) ) 'xor' B204 ) )))))))
proof
let C215 , C216 , C217 being non  pair set;
let C218 , C219 being set;
let C220 being (State of ( BitFTA1Circ (C215 , C216 , C217 , C218 , C219) ));
set D196 = ( BitGFA1Str (C215 , C216 , C217) );
set D197 = ( BitGFA1Circ (C215 , C216 , C217) );
set D198 = ( GFA1AdderOutput (C215 , C216 , C217) );
set D199 = ( GFA1CarryOutput (C215 , C216 , C217) );
set D200 = ( BitGFA2Str (D198 , C219 , C218) );
set D201 = ( BitGFA2Circ (D198 , C219 , C218) );
let C221 , C222 , C223 being (Element of ( BOOLEAN ));
assume that
L253: C221 = ( C220 . C215 )
and
L254: C222 = ( C220 . C216 )
and
L255: C223 = ( C220 . C217 );
reconsider D202 = ( C220 | (the carrier of D196) ) as (State of D197) by FACIRC_1:26;
L256: ( dom D202 ) = (the carrier of D196) by CIRCUIT1:3;
L257: C215 in (the carrier of D196) by GFACIRC1:68;
L258: C221 = ( D202 . C215 ) by L257 , L253 , L256 , FUNCT_1:47;
reconsider D203 = C220 as (State of ( D197 +* D201 ));
L259: ( InputVertices D196 ) misses ( InnerVertices D200 ) by L214;
L260: C217 in (the carrier of D196) by GFACIRC1:68;
L261: C223 = ( D202 . C217 ) by L260 , L255 , L256 , FUNCT_1:47;
L262: C216 in (the carrier of D196) by GFACIRC1:68;
L263: C222 = ( D202 . C216 ) by L262 , L254 , L256 , FUNCT_1:47;
L264: D199 in (the carrier of D196) by GFACIRC1:68;
L265: ( ( Following (D203 , 2) ) . ( GFA1CarryOutput (C215 , C216 , C217) ) ) = ( ( Following (D202 , 2) ) . ( GFA1CarryOutput (C215 , C216 , C217) ) ) by L264 , L259 , FACIRC_1:32;
thus L266: ( ( Following (C220 , 2) ) . ( BitFTA1CarryOutput (C215 , C216 , C217 , C218 , C219) ) ) = ( ( ( C221 '&' ( 'not' C222 ) ) 'or' ( ( 'not' C222 ) '&' C223 ) ) 'or' ( C223 '&' C221 ) ) by L265 , L258 , L263 , L261 , GFACIRC1:71;
L267: D198 in (the carrier of D196) by GFACIRC1:68;
L268: ( ( Following (D203 , 2) ) . ( GFA1AdderOutput (C215 , C216 , C217) ) ) = ( ( Following (D202 , 2) ) . ( GFA1AdderOutput (C215 , C216 , C217) ) ) by L267 , L259 , FACIRC_1:32;
thus L269: thesis by L268 , L258 , L263 , L261 , GFACIRC1:71;
end;
theorem
L270: (for B205 , B206 , B207 , B208 being non  pair set holds (for B209 being set holds ((B209 <> [ <* B208 , ( GFA1AdderOutput (B205 , B206 , B207) ) *> , ( and2b ) ] & (not B209 in ( InnerVertices ( BitGFA1Str (B205 , B206 , B207) ) ))) implies (for B210 being (State of ( BitFTA1Circ (B205 , B206 , B207 , B208 , B209) )) holds (for B211 , B212 , B213 , B214 , B215 being (Element of ( BOOLEAN )) holds ((B211 = ( B210 . B205 ) & B212 = ( B210 . B206 ) & B213 = ( B210 . B207 ) & B214 = ( B210 . B208 ) & B215 = ( B210 . B209 )) implies (( ( Following (B210 , 2) ) . ( GFA1AdderOutput (B205 , B206 , B207) ) ) = ( 'not' ( ( B211 'xor' ( 'not' B212 ) ) 'xor' B213 ) ) & ( ( Following (B210 , 2) ) . B205 ) = B211 & ( ( Following (B210 , 2) ) . B206 ) = B212 & ( ( Following (B210 , 2) ) . B207 ) = B213 & ( ( Following (B210 , 2) ) . B208 ) = B214 & ( ( Following (B210 , 2) ) . B209 ) = B215)))))))
proof
let C224 , C225 , C226 , C227 being non  pair set;
let C228 being set;
assume that
L271: (C228 <> [ <* C227 , ( GFA1AdderOutput (C224 , C225 , C226) ) *> , ( and2b ) ] & (not C228 in ( InnerVertices ( BitGFA1Str (C224 , C225 , C226) ) )));
set D204 = ( GFA1AdderOutput (C224 , C225 , C226) );
set D205 = ( BitGFA1Circ (C224 , C225 , C226) );
set D206 = ( BitGFA1Str (C224 , C225 , C226) );
set D207 = ( BitGFA2Str (D204 , C228 , C227) );
set D208 = ( BitGFA2Circ (D204 , C228 , C227) );
set D209 = ( BitFTA1Str (C224 , C225 , C226 , C227 , C228) );
let C229 being (State of ( BitFTA1Circ (C224 , C225 , C226 , C227 , C228) ));
let C230 , C231 , C232 , C233 , C234 being (Element of ( BOOLEAN ));
assume that
L272: C230 = ( C229 . C224 )
and
L273: C231 = ( C229 . C225 )
and
L274: C232 = ( C229 . C226 )
and
L275: C233 = ( C229 . C227 )
and
L276: C234 = ( C229 . C228 );
reconsider D210 = ( C229 | (the carrier of D206) ) as (State of D205) by FACIRC_1:26;
L277: ( dom D210 ) = (the carrier of D206) by CIRCUIT1:3;
L278: C227 in ( InputVertices D209 ) by L271 , L247;
L279: ( ( Following C229 ) . C227 ) = C233 by L278 , L275 , CIRCUIT2:def 5;
L280: C226 in ( InputVertices D209 ) by L271 , L247;
L281: ( ( Following C229 ) . C226 ) = C232 by L280 , L274 , CIRCUIT2:def 5;
L282: C225 in (the carrier of D206) by GFACIRC1:68;
L283: C231 = ( D210 . C225 ) by L282 , L273 , L277 , FUNCT_1:47;
reconsider D211 = C229 as (State of ( D205 +* D208 ));
L284: (D204 in (the carrier of D206) & ( InputVertices D206 ) misses ( InnerVertices D207 )) by L214 , GFACIRC1:68;
L285: ( ( Following (D211 , 2) ) . ( GFA1AdderOutput (C224 , C225 , C226) ) ) = ( ( Following (D210 , 2) ) . ( GFA1AdderOutput (C224 , C225 , C226) ) ) by L284 , FACIRC_1:32;
L286: C226 in (the carrier of D206) by GFACIRC1:68;
L287: C232 = ( D210 . C226 ) by L286 , L274 , L277 , FUNCT_1:47;
L288: C224 in (the carrier of D206) by GFACIRC1:68;
L289: C230 = ( D210 . C224 ) by L288 , L272 , L277 , FUNCT_1:47;
thus L290: ( ( Following (C229 , 2) ) . ( GFA1AdderOutput (C224 , C225 , C226) ) ) = ( 'not' ( ( C230 'xor' ( 'not' C231 ) ) 'xor' C232 ) ) by L289 , L283 , L287 , L285 , GFACIRC1:71;
L291: C225 in ( InputVertices D209 ) by L271 , L247;
L292: ( ( Following C229 ) . C225 ) = C231 by L291 , L273 , CIRCUIT2:def 5;
L293: C228 in ( InputVertices D209 ) by L271 , L247;
L294: ( ( Following C229 ) . C228 ) = C234 by L293 , L276 , CIRCUIT2:def 5;
L295: C224 in ( InputVertices D209 ) by L271 , L247;
L296: (( Following (C229 , 2) ) = ( Following ( Following C229 ) ) & ( ( Following C229 ) . C224 ) = C230) by L295 , L272 , CIRCUIT2:def 5 , FACIRC_1:15;
thus L297: thesis by L296 , L295 , L291 , L280 , L278 , L293 , L292 , L281 , L279 , L294 , CIRCUIT2:def 5;
end;
L298: (for B216 , B217 , B218 , B219 being non  pair set holds (for B220 being set holds (for B221 being (State of ( BitFTA1Circ (B216 , B217 , B218 , B219 , B220) )) holds (for B222 , B223 , B224 being (Element of ( BOOLEAN )) holds ((B222 = ( B221 . ( GFA1AdderOutput (B216 , B217 , B218) ) ) & B223 = ( B221 . B219 ) & B224 = ( B221 . B220 )) implies (( ( Following B221 ) . [ <* ( GFA1AdderOutput (B216 , B217 , B218) ) , B220 *> , ( and2a ) ] ) = ( ( 'not' B222 ) '&' B224 ) & ( ( Following B221 ) . [ <* B220 , B219 *> , ( and2c ) ] ) = ( B224 '&' ( 'not' B223 ) ) & ( ( Following B221 ) . [ <* B219 , ( GFA1AdderOutput (B216 , B217 , B218) ) *> , ( and2b ) ] ) = ( ( 'not' B223 ) '&' ( 'not' B222 ) )))))))
proof
let C235 , C236 , C237 , C238 being non  pair set;
let C239 being set;
set D212 = ( BitFTA1Str (C235 , C236 , C237 , C238 , C239) );
set D213 = ( BitFTA1Circ (C235 , C236 , C237 , C238 , C239) );
set D214 = ( GFA1AdderOutput (C235 , C236 , C237) );
set D215 = [ <* D214 , C239 *> , ( and2a ) ];
set D216 = [ <* C239 , C238 *> , ( and2c ) ];
set D217 = [ <* C238 , D214 *> , ( and2b ) ];
let C240 being (State of D213);
let C241 , C242 , C243 being (Element of ( BOOLEAN ));
assume that
L299: C241 = ( C240 . D214 )
and
L300: C242 = ( C240 . C238 )
and
L301: C243 = ( C240 . C239 );
L302: ( dom C240 ) = (the carrier of D212) by CIRCUIT1:3;
L303: C239 in (the carrier of D212) by L227;
L304: D214 in (the carrier of D212) by L227;
L305: ( InnerVertices D212 ) = (the carrier' of D212) by FACIRC_1:37;
L306: D215 in (the carrier' of D212) by L305 , L238;
thus L307: ( ( Following C240 ) . D215 ) = ( ( and2a ) . ( C240 * <* D214 , C239 *> ) ) by L306 , FACIRC_1:35
.= ( ( and2a ) . <* C241 , C243 *> ) by L299 , L301 , L304 , L303 , L302 , FINSEQ_2:125
.= ( ( 'not' C241 ) '&' C243 ) by TWOSCOMP:def 2;
L308: C238 in (the carrier of D212) by L227;
L309: D216 in (the carrier' of D212) by L305 , L238;
thus L310: ( ( Following C240 ) . D216 ) = ( ( and2c ) . ( C240 * <* C239 , C238 *> ) ) by L309 , FACIRC_1:35
.= ( ( and2c ) . <* C243 , C242 *> ) by L300 , L301 , L308 , L303 , L302 , FINSEQ_2:125
.= ( C243 '&' ( 'not' C242 ) ) by GFACIRC1:def 3;
L311: D217 in (the carrier' of D212) by L305 , L238;
thus L312: ( ( Following C240 ) . D217 ) = ( ( and2b ) . ( C240 * <* C238 , D214 *> ) ) by L311 , FACIRC_1:35
.= ( ( and2b ) . <* C242 , C241 *> ) by L299 , L300 , L304 , L308 , L302 , FINSEQ_2:125
.= ( ( 'not' C242 ) '&' ( 'not' C241 ) ) by TWOSCOMP:def 3;
end;
L313: (for B225 , B226 , B227 , B228 being non  pair set holds (for B229 being set holds (for B230 being (State of ( BitFTA1Circ (B225 , B226 , B227 , B228 , B229) )) holds (for B231 , B232 being (Element of ( BOOLEAN )) holds ((B231 = ( B230 . ( GFA1AdderOutput (B225 , B226 , B227) ) ) & B232 = ( B230 . B229 )) implies ( ( Following B230 ) . [ <* ( GFA1AdderOutput (B225 , B226 , B227) ) , B229 *> , ( xor2c ) ] ) = ( B231 'xor' ( 'not' B232 ) ))))))
proof
let C244 , C245 , C246 , C247 being non  pair set;
let C248 being set;
set D218 = ( BitFTA1Str (C244 , C245 , C246 , C247 , C248) );
set D219 = ( BitFTA1Circ (C244 , C245 , C246 , C247 , C248) );
set D220 = ( GFA1AdderOutput (C244 , C245 , C246) );
set D221 = [ <* D220 , C248 *> , ( xor2c ) ];
let C249 being (State of D219);
let C250 , C251 being (Element of ( BOOLEAN ));
assume that
L314: (C250 = ( C249 . D220 ) & C251 = ( C249 . C248 ));
L315: ( dom C249 ) = (the carrier of D218) by CIRCUIT1:3;
L316: (D220 in (the carrier of D218) & C248 in (the carrier of D218)) by L227;
L317: ( InnerVertices D218 ) = (the carrier' of D218) by FACIRC_1:37;
L318: D221 in (the carrier' of D218) by L317 , L238;
thus L319: ( ( Following C249 ) . D221 ) = ( ( xor2c ) . ( C249 * <* D220 , C248 *> ) ) by L318 , FACIRC_1:35
.= ( ( xor2c ) . <* C250 , C251 *> ) by L314 , L316 , L315 , FINSEQ_2:125
.= ( C250 'xor' ( 'not' C251 ) ) by GFACIRC1:def 4;
end;
L320: (for B233 , B234 , B235 , B236 being non  pair set holds (for B237 being set holds ((B237 <> [ <* B236 , ( GFA1AdderOutput (B233 , B234 , B235) ) *> , ( and2b ) ] & (not B237 in ( InnerVertices ( BitGFA1Str (B233 , B234 , B235) ) ))) implies (for B238 being (State of ( BitFTA1Circ (B233 , B234 , B235 , B236 , B237) )) holds (for B239 , B240 , B241 , B242 , B243 being (Element of ( BOOLEAN )) holds ((B239 = ( B238 . B233 ) & B240 = ( B238 . B234 ) & B241 = ( B238 . B235 ) & B242 = ( B238 . B236 ) & B243 = ( B238 . B237 )) implies (( ( Following (B238 , 3) ) . [ <* ( GFA1AdderOutput (B233 , B234 , B235) ) , B237 *> , ( and2a ) ] ) = ( ( ( B239 'xor' ( 'not' B240 ) ) 'xor' B241 ) '&' B243 ) & ( ( Following (B238 , 3) ) . [ <* B237 , B236 *> , ( and2c ) ] ) = ( B243 '&' ( 'not' B242 ) ) & ( ( Following (B238 , 3) ) . [ <* B236 , ( GFA1AdderOutput (B233 , B234 , B235) ) *> , ( and2b ) ] ) = ( ( 'not' B242 ) '&' ( ( B239 'xor' ( 'not' B240 ) ) 'xor' B241 ) ) & ( ( Following (B238 , 3) ) . B233 ) = B239 & ( ( Following (B238 , 3) ) . B234 ) = B240 & ( ( Following (B238 , 3) ) . B235 ) = B241 & ( ( Following (B238 , 3) ) . B236 ) = B242 & ( ( Following (B238 , 3) ) . B237 ) = B243)))))))
proof
let C252 , C253 , C254 , C255 being non  pair set;
let C256 being set;
assume that
L321: (C256 <> [ <* C255 , ( GFA1AdderOutput (C252 , C253 , C254) ) *> , ( and2b ) ] & (not C256 in ( InnerVertices ( BitGFA1Str (C252 , C253 , C254) ) )));
set D222 = ( BitFTA1Str (C252 , C253 , C254 , C255 , C256) );
L322: (C252 in ( InputVertices D222 ) & C253 in ( InputVertices D222 )) by L321 , L247;
L323: (C254 in ( InputVertices D222 ) & C255 in ( InputVertices D222 )) by L321 , L247;
let C257 being (State of ( BitFTA1Circ (C252 , C253 , C254 , C255 , C256) ));
let C258 , C259 , C260 , C261 , C262 being (Element of ( BOOLEAN ));
assume that
L324: (C258 = ( C257 . C252 ) & C259 = ( C257 . C253 ) & C260 = ( C257 . C254 ) & C261 = ( C257 . C255 ) & C262 = ( C257 . C256 ));
L325: ( ( Following (C257 , 2) ) . C256 ) = C262 by L321 , L324 , L270;
set D223 = [ <* C256 , C255 *> , ( and2c ) ];
set D224 = ( GFA1AdderOutput (C252 , C253 , C254) );
set D225 = [ <* D224 , C256 *> , ( and2a ) ];
set D226 = [ <* C255 , D224 *> , ( and2b ) ];
L326: ( Following (C257 , ( 2 + 1 )) ) = ( Following ( Following (C257 , 2) ) ) by FACIRC_1:12;
L327: (( ( Following (C257 , 2) ) . D224 ) = ( 'not' ( ( C258 'xor' ( 'not' C259 ) ) 'xor' C260 ) ) & ( ( Following (C257 , 2) ) . C255 ) = C261) by L321 , L324 , L270;
thus L328: (( ( Following (C257 , 3) ) . D225 ) = ( ( ( C258 'xor' ( 'not' C259 ) ) 'xor' C260 ) '&' C262 ) & ( ( Following (C257 , 3) ) . D223 ) = ( C262 '&' ( 'not' C261 ) ) & ( ( Following (C257 , 3) ) . D226 ) = ( ( 'not' C261 ) '&' ( ( C258 'xor' ( 'not' C259 ) ) 'xor' C260 ) )) by L327 , L326 , L325 , L298;
L329: (( ( Following (C257 , 2) ) . C254 ) = C260 & ( ( Following (C257 , 2) ) . C255 ) = C261) by L321 , L324 , L270;
L330: ( ( Following (C257 , 2) ) . C256 ) = C262 by L321 , L324 , L270;
L331: C256 in ( InputVertices D222 ) by L321 , L247;
L332: (( ( Following (C257 , 2) ) . C252 ) = C258 & ( ( Following (C257 , 2) ) . C253 ) = C259) by L321 , L324 , L270;
thus L333: thesis by L332 , L326 , L322 , L323 , L331 , L329 , L330 , CIRCUIT2:def 5;
end;
L334: (for B244 , B245 , B246 , B247 being non  pair set holds (for B248 being set holds ((B248 <> [ <* B247 , ( GFA1AdderOutput (B244 , B245 , B246) ) *> , ( and2b ) ] & (not B248 in ( InnerVertices ( BitGFA1Str (B244 , B245 , B246) ) ))) implies (for B249 being (State of ( BitFTA1Circ (B244 , B245 , B246 , B247 , B248) )) holds (for B250 , B251 , B252 , B253 , B254 being (Element of ( BOOLEAN )) holds ((B250 = ( B249 . B244 ) & B251 = ( B249 . B245 ) & B252 = ( B249 . B246 ) & B253 = ( B249 . B247 ) & B254 = ( B249 . B248 )) implies (( ( Following (B249 , 3) ) . [ <* ( GFA1AdderOutput (B244 , B245 , B246) ) , B248 *> , ( xor2c ) ] ) = ( ( 'not' ( ( B250 'xor' ( 'not' B251 ) ) 'xor' B252 ) ) 'xor' ( 'not' B254 ) ) & ( ( Following (B249 , 3) ) . B244 ) = B250 & ( ( Following (B249 , 3) ) . B245 ) = B251 & ( ( Following (B249 , 3) ) . B246 ) = B252 & ( ( Following (B249 , 3) ) . B247 ) = B253 & ( ( Following (B249 , 3) ) . B248 ) = B254)))))))
proof
let C263 , C264 , C265 , C266 being non  pair set;
let C267 being set;
assume that
L335: (C267 <> [ <* C266 , ( GFA1AdderOutput (C263 , C264 , C265) ) *> , ( and2b ) ] & (not C267 in ( InnerVertices ( BitGFA1Str (C263 , C264 , C265) ) )));
set D227 = ( BitFTA1Str (C263 , C264 , C265 , C266 , C267) );
L336: (C263 in ( InputVertices D227 ) & C264 in ( InputVertices D227 )) by L335 , L247;
L337: (C265 in ( InputVertices D227 ) & C266 in ( InputVertices D227 )) by L335 , L247;
let C268 being (State of ( BitFTA1Circ (C263 , C264 , C265 , C266 , C267) ));
let C269 , C270 , C271 , C272 , C273 being (Element of ( BOOLEAN ));
assume that
L338: (C269 = ( C268 . C263 ) & C270 = ( C268 . C264 ) & C271 = ( C268 . C265 ) & C272 = ( C268 . C266 ) & C273 = ( C268 . C267 ));
L339: (( ( Following (C268 , 2) ) . C265 ) = C271 & ( ( Following (C268 , 2) ) . C266 ) = C272) by L335 , L338 , L270;
set D228 = ( GFA1AdderOutput (C263 , C264 , C265) );
set D229 = [ <* D228 , C267 *> , ( xor2c ) ];
L340: ( Following (C268 , ( 2 + 1 )) ) = ( Following ( Following (C268 , 2) ) ) by FACIRC_1:12;
L341: (( ( Following (C268 , 2) ) . D228 ) = ( 'not' ( ( C269 'xor' ( 'not' C270 ) ) 'xor' C271 ) ) & ( ( Following (C268 , 2) ) . C267 ) = C273) by L335 , L338 , L270;
thus L342: ( ( Following (C268 , 3) ) . D229 ) = ( ( 'not' ( ( C269 'xor' ( 'not' C270 ) ) 'xor' C271 ) ) 'xor' ( 'not' C273 ) ) by L341 , L340 , L313;
L343: ( ( Following (C268 , 2) ) . C267 ) = C273 by L335 , L338 , L270;
L344: C267 in ( InputVertices D227 ) by L335 , L247;
L345: (( ( Following (C268 , 2) ) . C263 ) = C269 & ( ( Following (C268 , 2) ) . C264 ) = C270) by L335 , L338 , L270;
thus L346: thesis by L345 , L340 , L336 , L337 , L344 , L339 , L343 , CIRCUIT2:def 5;
end;
L347: (for B255 , B256 , B257 , B258 being non  pair set holds (for B259 being set holds (for B260 being (State of ( BitFTA1Circ (B255 , B256 , B257 , B258 , B259) )) holds (for B261 , B262 , B263 being (Element of ( BOOLEAN )) holds ((B261 = ( B260 . [ <* ( GFA1AdderOutput (B255 , B256 , B257) ) , B259 *> , ( and2a ) ] ) & B262 = ( B260 . [ <* B259 , B258 *> , ( and2c ) ] ) & B263 = ( B260 . [ <* B258 , ( GFA1AdderOutput (B255 , B256 , B257) ) *> , ( and2b ) ] )) implies ( ( Following B260 ) . ( GFA2CarryOutput (( GFA1AdderOutput (B255 , B256 , B257) ) , B259 , B258) ) ) = ( 'not' ( ( B261 'or' B262 ) 'or' B263 ) ))))))
proof
let C274 , C275 , C276 , C277 being non  pair set;
let C278 being set;
set D230 = ( BitFTA1Str (C274 , C275 , C276 , C277 , C278) );
set D231 = ( BitFTA1Circ (C274 , C275 , C276 , C277 , C278) );
set D232 = ( GFA1AdderOutput (C274 , C275 , C276) );
set D233 = ( GFA2CarryOutput (D232 , C278 , C277) );
set D234 = [ <* D232 , C278 *> , ( and2a ) ];
set D235 = [ <* C278 , C277 *> , ( and2c ) ];
set D236 = [ <* C277 , D232 *> , ( and2b ) ];
let C279 being (State of D231);
let C280 , C281 , C282 being (Element of ( BOOLEAN ));
assume that
L348: (C280 = ( C279 . D234 ) & C281 = ( C279 . D235 ) & C282 = ( C279 . D236 ));
L349: (D234 in (the carrier of D230) & D235 in (the carrier of D230)) by L227;
L350: (D236 in (the carrier of D230) & ( dom C279 ) = (the carrier of D230)) by L227 , CIRCUIT1:3;
L351: ( InnerVertices D230 ) = (the carrier' of D230) by FACIRC_1:37;
L352: D233 in (the carrier' of D230) by L351 , L238;
thus L353: ( ( Following C279 ) . D233 ) = ( ( nor3 ) . ( C279 * <* D234 , D235 , D236 *> ) ) by L352 , FACIRC_1:35
.= ( ( nor3 ) . <* C280 , C281 , C282 *> ) by L348 , L349 , L350 , FINSEQ_2:126
.= ( 'not' ( ( C280 'or' C281 ) 'or' C282 ) ) by TWOSCOMP:def 28;
end;
L354: (for B264 , B265 , B266 , B267 being non  pair set holds (for B268 being set holds (for B269 being (State of ( BitFTA1Circ (B264 , B265 , B266 , B267 , B268) )) holds (for B270 , B271 being (Element of ( BOOLEAN )) holds ((B270 = ( B269 . [ <* ( GFA1AdderOutput (B264 , B265 , B266) ) , B268 *> , ( xor2c ) ] ) & B271 = ( B269 . B267 )) implies ( ( Following B269 ) . ( GFA2AdderOutput (( GFA1AdderOutput (B264 , B265 , B266) ) , B268 , B267) ) ) = ( B270 'xor' ( 'not' B271 ) ))))))
proof
let C283 , C284 , C285 , C286 being non  pair set;
let C287 being set;
set D237 = ( BitFTA1Str (C283 , C284 , C285 , C286 , C287) );
set D238 = ( BitFTA1Circ (C283 , C284 , C285 , C286 , C287) );
set D239 = ( GFA1AdderOutput (C283 , C284 , C285) );
set D240 = ( GFA2AdderOutput (D239 , C287 , C286) );
set D241 = [ <* D239 , C287 *> , ( xor2c ) ];
let C288 being (State of D238);
let C289 , C290 being (Element of ( BOOLEAN ));
assume that
L355: (C289 = ( C288 . D241 ) & C290 = ( C288 . C286 ));
L356: ( dom C288 ) = (the carrier of D237) by CIRCUIT1:3;
L357: (D241 in (the carrier of D237) & C286 in (the carrier of D237)) by L227;
L358: ( InnerVertices D237 ) = (the carrier' of D237) by FACIRC_1:37;
L359: D240 in (the carrier' of D237) by L358 , L238;
thus L360: ( ( Following C288 ) . D240 ) = ( ( xor2c ) . ( C288 * <* D241 , C286 *> ) ) by L359 , FACIRC_1:35
.= ( ( xor2c ) . <* C289 , C290 *> ) by L355 , L357 , L356 , FINSEQ_2:125
.= ( C289 'xor' ( 'not' C290 ) ) by GFACIRC1:def 4;
end;
L361: (for B272 , B273 , B274 , B275 being non  pair set holds (for B276 being set holds ((B276 <> [ <* B275 , ( GFA1AdderOutput (B272 , B273 , B274) ) *> , ( and2b ) ] & (not B276 in ( InnerVertices ( BitGFA1Str (B272 , B273 , B274) ) ))) implies (for B277 being (State of ( BitFTA1Circ (B272 , B273 , B274 , B275 , B276) )) holds (for B278 , B279 , B280 , B281 , B282 being (Element of ( BOOLEAN )) holds ((B278 = ( B277 . B272 ) & B279 = ( B277 . B273 ) & B280 = ( B277 . B274 ) & B281 = ( B277 . B275 ) & B282 = ( B277 . B276 )) implies (( ( Following (B277 , 4) ) . ( GFA2CarryOutput (( GFA1AdderOutput (B272 , B273 , B274) ) , B276 , B275) ) ) = ( 'not' ( ( ( ( ( B278 'xor' ( 'not' B279 ) ) 'xor' B280 ) '&' B282 ) 'or' ( B282 '&' ( 'not' B281 ) ) ) 'or' ( ( 'not' B281 ) '&' ( ( B278 'xor' ( 'not' B279 ) ) 'xor' B280 ) ) ) ) & ( ( Following (B277 , 4) ) . B272 ) = B278 & ( ( Following (B277 , 4) ) . B273 ) = B279 & ( ( Following (B277 , 4) ) . B274 ) = B280 & ( ( Following (B277 , 4) ) . B275 ) = B281 & ( ( Following (B277 , 4) ) . B276 ) = B282)))))))
proof
let C291 , C292 , C293 , C294 being non  pair set;
let C295 being set;
assume that
L362: (C295 <> [ <* C294 , ( GFA1AdderOutput (C291 , C292 , C293) ) *> , ( and2b ) ] & (not C295 in ( InnerVertices ( BitGFA1Str (C291 , C292 , C293) ) )));
set D242 = ( BitFTA1Str (C291 , C292 , C293 , C294 , C295) );
L363: (C291 in ( InputVertices D242 ) & C292 in ( InputVertices D242 )) by L362 , L247;
L364: (C293 in ( InputVertices D242 ) & C294 in ( InputVertices D242 )) by L362 , L247;
set D243 = ( GFA1AdderOutput (C291 , C292 , C293) );
let C296 being (State of ( BitFTA1Circ (C291 , C292 , C293 , C294 , C295) ));
set D244 = [ <* C294 , D243 *> , ( and2b ) ];
let C297 , C298 , C299 , C300 , C301 being (Element of ( BOOLEAN ));
assume that
L365: (C297 = ( C296 . C291 ) & C298 = ( C296 . C292 ) & C299 = ( C296 . C293 ) & C300 = ( C296 . C294 ) & C301 = ( C296 . C295 ));
L366: ( ( Following (C296 , 3) ) . D244 ) = ( ( 'not' C300 ) '&' ( ( C297 'xor' ( 'not' C298 ) ) 'xor' C299 ) ) by L362 , L365 , L320;
set D245 = [ <* C295 , C294 *> , ( and2c ) ];
set D246 = [ <* D243 , C295 *> , ( and2a ) ];
set D247 = ( GFA2CarryOutput (D243 , C295 , C294) );
L367: ( Following (C296 , ( 3 + 1 )) ) = ( Following ( Following (C296 , 3) ) ) by FACIRC_1:12;
L368: (( ( Following (C296 , 3) ) . D246 ) = ( ( ( C297 'xor' ( 'not' C298 ) ) 'xor' C299 ) '&' C301 ) & ( ( Following (C296 , 3) ) . D245 ) = ( C301 '&' ( 'not' C300 ) )) by L362 , L365 , L320;
thus L369: ( ( Following (C296 , 4) ) . D247 ) = ( 'not' ( ( ( ( ( C297 'xor' ( 'not' C298 ) ) 'xor' C299 ) '&' C301 ) 'or' ( C301 '&' ( 'not' C300 ) ) ) 'or' ( ( 'not' C300 ) '&' ( ( C297 'xor' ( 'not' C298 ) ) 'xor' C299 ) ) ) ) by L368 , L367 , L366 , L347;
L370: (( ( Following (C296 , 3) ) . C293 ) = C299 & ( ( Following (C296 , 3) ) . C294 ) = C300) by L362 , L365 , L320;
L371: ( ( Following (C296 , 3) ) . C295 ) = C301 by L362 , L365 , L320;
L372: C295 in ( InputVertices D242 ) by L362 , L247;
L373: (( ( Following (C296 , 3) ) . C291 ) = C297 & ( ( Following (C296 , 3) ) . C292 ) = C298) by L362 , L365 , L320;
thus L374: thesis by L373 , L367 , L363 , L364 , L372 , L370 , L371 , CIRCUIT2:def 5;
end;
L375: (for B283 , B284 , B285 , B286 being non  pair set holds (for B287 being set holds ((B287 <> [ <* B286 , ( GFA1AdderOutput (B283 , B284 , B285) ) *> , ( and2b ) ] & (not B287 in ( InnerVertices ( BitGFA1Str (B283 , B284 , B285) ) ))) implies (for B288 being (State of ( BitFTA1Circ (B283 , B284 , B285 , B286 , B287) )) holds (for B289 , B290 , B291 , B292 , B293 being (Element of ( BOOLEAN )) holds ((B289 = ( B288 . B283 ) & B290 = ( B288 . B284 ) & B291 = ( B288 . B285 ) & B292 = ( B288 . B286 ) & B293 = ( B288 . B287 )) implies (( ( Following (B288 , 4) ) . ( GFA2AdderOutput (( GFA1AdderOutput (B283 , B284 , B285) ) , B287 , B286) ) ) = ( ( ( ( B289 'xor' ( 'not' B290 ) ) 'xor' B291 ) 'xor' ( 'not' B292 ) ) 'xor' B293 ) & ( ( Following (B288 , 4) ) . B283 ) = B289 & ( ( Following (B288 , 4) ) . B284 ) = B290 & ( ( Following (B288 , 4) ) . B285 ) = B291 & ( ( Following (B288 , 4) ) . B286 ) = B292 & ( ( Following (B288 , 4) ) . B287 ) = B293)))))))
proof
let C302 , C303 , C304 , C305 being non  pair set;
let C306 being set;
assume that
L376: (C306 <> [ <* C305 , ( GFA1AdderOutput (C302 , C303 , C304) ) *> , ( and2b ) ] & (not C306 in ( InnerVertices ( BitGFA1Str (C302 , C303 , C304) ) )));
set D248 = ( BitFTA1Str (C302 , C303 , C304 , C305 , C306) );
L377: (C302 in ( InputVertices D248 ) & C303 in ( InputVertices D248 )) by L376 , L247;
L378: (C304 in ( InputVertices D248 ) & C305 in ( InputVertices D248 )) by L376 , L247;
let C307 being (State of ( BitFTA1Circ (C302 , C303 , C304 , C305 , C306) ));
let C308 , C309 , C310 , C311 , C312 being (Element of ( BOOLEAN ));
assume that
L379: (C308 = ( C307 . C302 ) & C309 = ( C307 . C303 ) & C310 = ( C307 . C304 ) & C311 = ( C307 . C305 ) & C312 = ( C307 . C306 ));
L380: (( ( Following (C307 , 3) ) . C304 ) = C310 & ( ( Following (C307 , 3) ) . C305 ) = C311) by L376 , L379 , L334;
set D249 = ( GFA1AdderOutput (C302 , C303 , C304) );
set D250 = ( GFA2AdderOutput (D249 , C306 , C305) );
set D251 = [ <* D249 , C306 *> , ( xor2c ) ];
L381: ( Following (C307 , ( 3 + 1 )) ) = ( Following ( Following (C307 , 3) ) ) by FACIRC_1:12;
L382: (( ( Following (C307 , 3) ) . D251 ) = ( ( 'not' ( ( C308 'xor' ( 'not' C309 ) ) 'xor' C310 ) ) 'xor' ( 'not' C312 ) ) & ( ( Following (C307 , 3) ) . C305 ) = C311) by L376 , L379 , L334;
thus L383: ( ( Following (C307 , 4) ) . D250 ) = ( ( ( ( C308 'xor' ( 'not' C309 ) ) 'xor' C310 ) 'xor' C312 ) 'xor' ( 'not' C311 ) ) by L382 , L381 , L354
.= ( ( ( ( C308 'xor' ( 'not' C309 ) ) 'xor' C310 ) 'xor' ( 'not' C311 ) ) 'xor' C312 ) by XBOOLEAN:73;
L384: ( ( Following (C307 , 3) ) . C306 ) = C312 by L376 , L379 , L334;
L385: C306 in ( InputVertices D248 ) by L376 , L247;
L386: (( ( Following (C307 , 3) ) . C302 ) = C308 & ( ( Following (C307 , 3) ) . C303 ) = C309) by L376 , L379 , L334;
thus L387: thesis by L386 , L381 , L377 , L378 , L385 , L380 , L384 , CIRCUIT2:def 5;
end;
theorem
L388: (for B294 , B295 , B296 , B297 being non  pair set holds (for B298 being set holds ((B298 <> [ <* B297 , ( GFA1AdderOutput (B294 , B295 , B296) ) *> , ( and2b ) ] & (not B298 in ( InnerVertices ( BitGFA1Str (B294 , B295 , B296) ) ))) implies (for B299 being (State of ( BitFTA1Circ (B294 , B295 , B296 , B297 , B298) )) holds (for B300 , B301 , B302 , B303 , B304 being (Element of ( BOOLEAN )) holds ((B300 = ( B299 . B294 ) & B301 = ( B299 . B295 ) & B302 = ( B299 . B296 ) & B303 = ( B299 . B297 ) & B304 = ( B299 . B298 )) implies (( ( Following (B299 , 4) ) . ( BitFTA1AdderOutputP (B294 , B295 , B296 , B297 , B298) ) ) = ( 'not' ( ( ( ( ( B300 'xor' ( 'not' B301 ) ) 'xor' B302 ) '&' B304 ) 'or' ( B304 '&' ( 'not' B303 ) ) ) 'or' ( ( 'not' B303 ) '&' ( ( B300 'xor' ( 'not' B301 ) ) 'xor' B302 ) ) ) ) & ( ( Following (B299 , 4) ) . ( BitFTA1AdderOutputQ (B294 , B295 , B296 , B297 , B298) ) ) = ( ( ( ( B300 'xor' ( 'not' B301 ) ) 'xor' B302 ) 'xor' ( 'not' B303 ) ) 'xor' B304 )))))))) by L361 , L375;
theorem
L389: (for B305 , B306 , B307 , B308 being non  pair set holds (for B309 being set holds (B309 <> [ <* B308 , ( GFA1AdderOutput (B305 , B306 , B307) ) *> , ( and2b ) ] implies (for B310 being (State of ( BitFTA1Circ (B305 , B306 , B307 , B308 , B309) )) holds ( Following (B310 , 4) ) is  stable))))
proof
set D252 = 2;
set D253 = 2;
let C313 , C314 , C315 , C316 being non  pair set;
let C317 being set;
set D254 = ( BitFTA1Circ (C313 , C314 , C315 , C316 , C317) );
set D255 = ( BitGFA1Str (C313 , C314 , C315) );
set D256 = ( BitGFA1Circ (C313 , C314 , C315) );
set D257 = ( GFA1AdderOutput (C313 , C314 , C315) );
set D258 = ( BitGFA2Str (D257 , C317 , C316) );
set D259 = ( BitGFA2Circ (D257 , C317 , C316) );
set D260 = [ <* C316 , D257 *> , ( and2b ) ];
assume L390: C317 <> D260;
let C318 being (State of D254);
L391: D256 tolerates D259 by CIRCCOMB:60;
L392: (the Sorts of D256) tolerates (the Sorts of D259) by L391 , CIRCCOMB:def 3;
reconsider D261 = ( C318 | (the carrier of D255) ) as (State of D256) by L392 , CIRCCOMB:26;
reconsider D262 = ( ( Following (C318 , D252) ) | (the carrier of D258) ) as (State of D259) by L392 , CIRCCOMB:26;
L393: (( InputVertices D255 ) misses ( InnerVertices D258 ) & ( Following (D261 , D252) ) is  stable) by L214 , GFACIRC1:72;
L394: ( Following (D262 , D253) ) is  stable by L390 , L208 , GFACIRC1:104;
L395: ( Following (C318 , ( D252 + D253 )) ) is  stable by L394 , L393 , CIRCCMB2:19 , CIRCCOMB:60;
thus L396: thesis by L395;
end;
begin
definition
let C319 , C320 , C321 , C322 , C323 being set;
func BitFTA2Str (C319 , C320 , C321 , C322 , C323) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( BitGFA2Str (C319 , C320 , C321) ) +* ( BitGFA1Str (( GFA2AdderOutput (C319 , C320 , C321) ) , C323 , C322) ) );
coherence;
end;
definition
let C324 , C325 , C326 , C327 , C328 being set;
func BitFTA2Circ (C324 , C325 , C326 , C327 , C328) ->  strict  Boolean  gate`2=den (Circuit of ( BitFTA2Str (C324 , C325 , C326 , C327 , C328) )) equals 
( ( BitGFA2Circ (C324 , C325 , C326) ) +* ( BitGFA1Circ (( GFA2AdderOutput (C324 , C325 , C326) ) , C328 , C327) ) );
coherence;
end;
theorem
L399: (for B311 , B312 , B313 , B314 , B315 being set holds ( InnerVertices ( BitFTA2Str (B311 , B312 , B313 , B314 , B315) ) ) = ( ( ( { [ <* B311 , B312 *> , ( xor2c ) ] , ( GFA2AdderOutput (B311 , B312 , B313) ) } \/ { [ <* B311 , B312 *> , ( and2a ) ] , [ <* B312 , B313 *> , ( and2c ) ] , [ <* B313 , B311 *> , ( and2b ) ] , ( GFA2CarryOutput (B311 , B312 , B313) ) } ) \/ { [ <* ( GFA2AdderOutput (B311 , B312 , B313) ) , B315 *> , ( xor2c ) ] , ( GFA1AdderOutput (( GFA2AdderOutput (B311 , B312 , B313) ) , B315 , B314) ) } ) \/ { [ <* ( GFA2AdderOutput (B311 , B312 , B313) ) , B315 *> , ( and2c ) ] , [ <* B315 , B314 *> , ( and2a ) ] , [ <* B314 , ( GFA2AdderOutput (B311 , B312 , B313) ) *> , ( and2 ) ] , ( GFA1CarryOutput (( GFA2AdderOutput (B311 , B312 , B313) ) , B315 , B314) ) } ))
proof
let C329 , C330 , C331 , C332 , C333 being set;
set D263 = ( BitFTA2Str (C329 , C330 , C331 , C332 , C333) );
set D264 = ( BitGFA2Str (C329 , C330 , C331) );
set D265 = ( GFA2AdderOutput (C329 , C330 , C331) );
set D266 = ( GFA2CarryOutput (C329 , C330 , C331) );
set D267 = ( BitGFA1Str (D265 , C333 , C332) );
set D268 = ( GFA1AdderOutput (D265 , C333 , C332) );
set D269 = ( GFA1CarryOutput (D265 , C333 , C332) );
set D270 = [ <* C329 , C330 *> , ( xor2c ) ];
set D271 = [ <* C329 , C330 *> , ( and2a ) ];
set D272 = [ <* C330 , C331 *> , ( and2c ) ];
set D273 = [ <* C331 , C329 *> , ( and2b ) ];
set D274 = [ <* D265 , C333 *> , ( xor2c ) ];
set D275 = [ <* D265 , C333 *> , ( and2c ) ];
set D276 = [ <* C333 , C332 *> , ( and2a ) ];
set D277 = [ <* C332 , D265 *> , ( and2 ) ];
L400: D264 tolerates D267 by CIRCCOMB:47;
thus L401: ( InnerVertices D263 ) = ( ( InnerVertices D264 ) \/ ( InnerVertices D267 ) ) by L400 , CIRCCOMB:11
.= ( ( ( ( { D270 } \/ { D265 } ) \/ { D271 , D272 , D273 } ) \/ { D266 } ) \/ ( InnerVertices D267 ) ) by GFACIRC1:95
.= ( ( ( { D270 , D265 } \/ { D271 , D272 , D273 } ) \/ { D266 } ) \/ ( InnerVertices D267 ) ) by ENUMSET1:1
.= ( ( { D270 , D265 } \/ ( { D271 , D272 , D273 } \/ { D266 } ) ) \/ ( InnerVertices D267 ) ) by XBOOLE_1:4
.= ( ( { D270 , D265 } \/ { D271 , D272 , D273 , D266 } ) \/ ( InnerVertices D267 ) ) by ENUMSET1:6
.= ( ( { D270 , D265 } \/ { D271 , D272 , D273 , D266 } ) \/ ( ( ( { D274 } \/ { D268 } ) \/ { D275 , D276 , D277 } ) \/ { D269 } ) ) by GFACIRC1:63
.= ( ( { D270 , D265 } \/ { D271 , D272 , D273 , D266 } ) \/ ( ( { D274 , D268 } \/ { D275 , D276 , D277 } ) \/ { D269 } ) ) by ENUMSET1:1
.= ( ( { D270 , D265 } \/ { D271 , D272 , D273 , D266 } ) \/ ( { D274 , D268 } \/ ( { D275 , D276 , D277 } \/ { D269 } ) ) ) by XBOOLE_1:4
.= ( ( { D270 , D265 } \/ { D271 , D272 , D273 , D266 } ) \/ ( { D274 , D268 } \/ { D275 , D276 , D277 , D269 } ) ) by ENUMSET1:6
.= ( ( ( { D270 , D265 } \/ { D271 , D272 , D273 , D266 } ) \/ { D274 , D268 } ) \/ { D275 , D276 , D277 , D269 } ) by XBOOLE_1:4;
end;
theorem
L402: (for B316 , B317 , B318 , B319 , B320 being set holds ( InnerVertices ( BitFTA2Str (B316 , B317 , B318 , B319 , B320) ) ) is Relation)
proof
let C334 , C335 , C336 , C337 , C338 being set;
set D278 = ( BitGFA2Str (C334 , C335 , C336) );
set D279 = ( GFA2AdderOutput (C334 , C335 , C336) );
set D280 = ( BitGFA1Str (D279 , C338 , C337) );
L403: (( InnerVertices D278 ) is Relation & ( InnerVertices D280 ) is Relation) by GFACIRC1:64 , GFACIRC1:96;
thus L404: thesis by L403 , FACIRC_1:3;
end;
L405: (for B321 , B322 , B323 being set holds (for B324 being set holds ( GFA2AdderOutput (B321 , B322 , B323) ) <> [ B324 , ( and2a ) ]))
proof
let C339 , C340 , C341 being set;
let C342 being set;
set D281 = ( GFA2AdderOutput (C339 , C340 , C341) );
L406:
now
assume L407: ( [ C342 , ( and2a ) ] `2 ) = ( D281 `2 );
L408: ( [ C342 , ( and2a ) ] `2 ) = ( xor2c ) by L407 , MCART_1:7;
thus L409: contradiction by L408 , GFACIRC1:4 , TWOSCOMP:9;
end;
thus L410: thesis by L406;
end;
L411: (for B325 , B326 , B327 being non  pair set holds (for B328 , B329 , B330 being set holds ( InputVertices ( BitGFA2Str (B325 , B326 , B327) ) ) misses ( InnerVertices ( BitGFA1Str (B328 , B329 , B330) ) )))
proof
let C343 , C344 , C345 being non  pair set;
let C346 , C347 , C348 being set;
set D282 = ( BitGFA2Str (C343 , C344 , C345) );
L412: ( InputVertices D282 ) is  without_pairs by GFACIRC1:99;
thus L413: thesis by L412 , FACIRC_1:5 , GFACIRC1:64;
end;
theorem
L414: (for B331 , B332 , B333 , B334 being non  pair set holds (for B335 being set holds ((B335 <> [ <* B334 , ( GFA2AdderOutput (B331 , B332 , B333) ) *> , ( and2 ) ] & (not B335 in ( InnerVertices ( BitGFA2Str (B331 , B332 , B333) ) ))) implies ( InputVertices ( BitFTA2Str (B331 , B332 , B333 , B334 , B335) ) ) = { B331 , B332 , B333 , B334 , B335 })))
proof
let C349 , C350 , C351 , C352 being non  pair set;
let C353 being set;
set D283 = ( BitFTA2Str (C349 , C350 , C351 , C352 , C353) );
set D284 = ( BitGFA2Str (C349 , C350 , C351) );
set D285 = ( GFA2AdderOutput (C349 , C350 , C351) );
set D286 = ( GFA2CarryOutput (C349 , C350 , C351) );
set D287 = ( BitGFA1Str (D285 , C353 , C352) );
set D288 = [ <* C349 , C350 *> , ( xor2c ) ];
set D289 = [ <* C349 , C350 *> , ( and2a ) ];
set D290 = [ <* C350 , C351 *> , ( and2c ) ];
set D291 = [ <* C351 , C349 *> , ( and2b ) ];
set D292 = [ <* C352 , D285 *> , ( and2 ) ];
assume that
L415: C353 <> D292
and
L416: (not C353 in ( InnerVertices D284 ));
L417: (not C352 in { D285 , D288 , D289 , D290 , D291 , D286 }) by ENUMSET1:def 4;
L418: D285 in { D285 , D288 , D289 , D290 , D291 , D286 } by ENUMSET1:def 4;
L419: ( { D285 } \ { D285 , D288 , D289 , D290 , D291 , D286 } ) = ( {} ) by L418 , ZFMISC_1:60;
L420: ( InnerVertices D284 ) = ( ( ( { D288 } \/ { D285 } ) \/ { D289 , D290 , D291 } ) \/ { D286 } ) by GFACIRC1:95
.= ( ( { D288 , D285 } \/ { D289 , D290 , D291 } ) \/ { D286 } ) by ENUMSET1:1
.= ( { D288 , D285 } \/ ( { D289 , D290 , D291 } \/ { D286 } ) ) by XBOOLE_1:4
.= ( { D285 , D288 } \/ { D289 , D290 , D291 , D286 } ) by ENUMSET1:6
.= { D285 , D288 , D289 , D290 , D291 , D286 } by ENUMSET1:12;
L421: ( { D285 , C353 , C352 } \ ( InnerVertices D284 ) ) = ( ( { D285 } \/ { C353 , C352 } ) \ { D285 , D288 , D289 , D290 , D291 , D286 } ) by L420 , ENUMSET1:2
.= ( ( { D285 } \ { D285 , D288 , D289 , D290 , D291 , D286 } ) \/ ( { C353 , C352 } \ { D285 , D288 , D289 , D290 , D291 , D286 } ) ) by XBOOLE_1:42
.= ( ( { C353 } \/ { C352 } ) \ { D285 , D288 , D289 , D290 , D291 , D286 } ) by L419 , ENUMSET1:1
.= ( ( { C353 } \ { D285 , D288 , D289 , D290 , D291 , D286 } ) \/ ( { C352 } \ { D285 , D288 , D289 , D290 , D291 , D286 } ) ) by XBOOLE_1:42
.= ( { C353 } \/ ( { C352 } \ { D285 , D288 , D289 , D290 , D291 , D286 } ) ) by L416 , L420 , ZFMISC_1:59
.= ( { C353 } \/ { C352 } ) by L417 , ZFMISC_1:59
.= { C353 , C352 } by ENUMSET1:1;
L422: (( InnerVertices D287 ) misses ( InputVertices D284 ) & D284 tolerates D287) by L411 , CIRCCOMB:47;
thus L423: ( InputVertices D283 ) = ( ( InputVertices D284 ) \/ ( ( InputVertices D287 ) \ ( InnerVertices D284 ) ) ) by L422 , FACIRC_1:4
.= ( { C349 , C350 , C351 } \/ ( ( InputVertices D287 ) \ ( InnerVertices D284 ) ) ) by GFACIRC1:98
.= ( { C349 , C350 , C351 } \/ ( { D285 , C353 , C352 } \ ( InnerVertices D284 ) ) ) by L415 , L405 , GFACIRC1:65
.= { C349 , C350 , C351 , C352 , C353 } by L421 , ENUMSET1:9;
end;
theorem
L424: (for B336 , B337 , B338 , B339 , B340 being set holds (B336 in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) )) & B337 in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) )) & B338 in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) )) & B339 in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) )) & B340 in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) )) & [ <* B336 , B337 *> , ( xor2c ) ] in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) )) & ( GFA2AdderOutput (B336 , B337 , B338) ) in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) )) & [ <* B336 , B337 *> , ( and2a ) ] in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) )) & [ <* B337 , B338 *> , ( and2c ) ] in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) )) & [ <* B338 , B336 *> , ( and2b ) ] in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) )) & ( GFA2CarryOutput (B336 , B337 , B338) ) in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) )) & [ <* ( GFA2AdderOutput (B336 , B337 , B338) ) , B340 *> , ( xor2c ) ] in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) )) & ( GFA1AdderOutput (( GFA2AdderOutput (B336 , B337 , B338) ) , B340 , B339) ) in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) )) & [ <* ( GFA2AdderOutput (B336 , B337 , B338) ) , B340 *> , ( and2c ) ] in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) )) & [ <* B340 , B339 *> , ( and2a ) ] in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) )) & [ <* B339 , ( GFA2AdderOutput (B336 , B337 , B338) ) *> , ( and2 ) ] in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) )) & ( GFA1CarryOutput (( GFA2AdderOutput (B336 , B337 , B338) ) , B340 , B339) ) in (the carrier of ( BitFTA2Str (B336 , B337 , B338 , B339 , B340) ))))
proof
let C354 , C355 , C356 , C357 , C358 being set;
set D293 = ( BitGFA2Str (C354 , C355 , C356) );
set D294 = ( GFA2AdderOutput (C354 , C355 , C356) );
set D295 = ( GFA2CarryOutput (C354 , C355 , C356) );
set D296 = ( BitGFA1Str (D294 , C358 , C357) );
set D297 = ( GFA1AdderOutput (D294 , C358 , C357) );
set D298 = ( GFA1CarryOutput (D294 , C358 , C357) );
set D299 = [ <* C354 , C355 *> , ( xor2c ) ];
set D300 = [ <* C354 , C355 *> , ( and2a ) ];
set D301 = [ <* C355 , C356 *> , ( and2c ) ];
set D302 = [ <* C356 , C354 *> , ( and2b ) ];
set D303 = [ <* D294 , C358 *> , ( xor2c ) ];
set D304 = [ <* D294 , C358 *> , ( and2c ) ];
set D305 = [ <* C358 , C357 *> , ( and2a ) ];
set D306 = [ <* C357 , D294 *> , ( and2 ) ];
L425: (C356 in (the carrier of D293) & D299 in (the carrier of D293)) by GFACIRC1:100;
L426: (D300 in (the carrier of D293) & D301 in (the carrier of D293)) by GFACIRC1:100;
L427: (D294 in (the carrier of D296) & C358 in (the carrier of D296)) by GFACIRC1:68;
L428: (D302 in (the carrier of D293) & D295 in (the carrier of D293)) by GFACIRC1:100;
L429: D298 in (the carrier of D296) by GFACIRC1:68;
L430: (D305 in (the carrier of D296) & D306 in (the carrier of D296)) by GFACIRC1:68;
L431: (D297 in (the carrier of D296) & D304 in (the carrier of D296)) by GFACIRC1:68;
L432: (C357 in (the carrier of D296) & D303 in (the carrier of D296)) by GFACIRC1:68;
L433: (C354 in (the carrier of D293) & C355 in (the carrier of D293)) by GFACIRC1:100;
thus L434: thesis by L433 , L425 , L426 , L428 , L427 , L432 , L431 , L430 , L429 , FACIRC_1:20;
end;
theorem
L435: (for B341 , B342 , B343 , B344 , B345 being set holds ([ <* B341 , B342 *> , ( xor2c ) ] in ( InnerVertices ( BitFTA2Str (B341 , B342 , B343 , B344 , B345) ) ) & ( GFA2AdderOutput (B341 , B342 , B343) ) in ( InnerVertices ( BitFTA2Str (B341 , B342 , B343 , B344 , B345) ) ) & [ <* B341 , B342 *> , ( and2a ) ] in ( InnerVertices ( BitFTA2Str (B341 , B342 , B343 , B344 , B345) ) ) & [ <* B342 , B343 *> , ( and2c ) ] in ( InnerVertices ( BitFTA2Str (B341 , B342 , B343 , B344 , B345) ) ) & [ <* B343 , B341 *> , ( and2b ) ] in ( InnerVertices ( BitFTA2Str (B341 , B342 , B343 , B344 , B345) ) ) & ( GFA2CarryOutput (B341 , B342 , B343) ) in ( InnerVertices ( BitFTA2Str (B341 , B342 , B343 , B344 , B345) ) ) & [ <* ( GFA2AdderOutput (B341 , B342 , B343) ) , B345 *> , ( xor2c ) ] in ( InnerVertices ( BitFTA2Str (B341 , B342 , B343 , B344 , B345) ) ) & ( GFA1AdderOutput (( GFA2AdderOutput (B341 , B342 , B343) ) , B345 , B344) ) in ( InnerVertices ( BitFTA2Str (B341 , B342 , B343 , B344 , B345) ) ) & [ <* ( GFA2AdderOutput (B341 , B342 , B343) ) , B345 *> , ( and2c ) ] in ( InnerVertices ( BitFTA2Str (B341 , B342 , B343 , B344 , B345) ) ) & [ <* B345 , B344 *> , ( and2a ) ] in ( InnerVertices ( BitFTA2Str (B341 , B342 , B343 , B344 , B345) ) ) & [ <* B344 , ( GFA2AdderOutput (B341 , B342 , B343) ) *> , ( and2 ) ] in ( InnerVertices ( BitFTA2Str (B341 , B342 , B343 , B344 , B345) ) ) & ( GFA1CarryOutput (( GFA2AdderOutput (B341 , B342 , B343) ) , B345 , B344) ) in ( InnerVertices ( BitFTA2Str (B341 , B342 , B343 , B344 , B345) ) )))
proof
let C359 , C360 , C361 , C362 , C363 being set;
set D307 = ( BitFTA2Str (C359 , C360 , C361 , C362 , C363) );
set D308 = ( GFA2AdderOutput (C359 , C360 , C361) );
set D309 = ( GFA2CarryOutput (C359 , C360 , C361) );
set D310 = ( GFA1AdderOutput (D308 , C363 , C362) );
set D311 = ( GFA1CarryOutput (D308 , C363 , C362) );
set D312 = [ <* C359 , C360 *> , ( xor2c ) ];
set D313 = [ <* C359 , C360 *> , ( and2a ) ];
set D314 = [ <* C360 , C361 *> , ( and2c ) ];
set D315 = [ <* C361 , C359 *> , ( and2b ) ];
set D316 = [ <* D308 , C363 *> , ( xor2c ) ];
set D317 = [ <* D308 , C363 *> , ( and2c ) ];
set D318 = [ <* C363 , C362 *> , ( and2a ) ];
set D319 = [ <* C362 , D308 *> , ( and2 ) ];
set D320 = { D312 , D308 , D313 , D314 , D315 , D309 };
set D321 = { D316 , D310 , D317 , D318 , D319 , D311 };
L436: (D312 in D320 & D308 in D320) by ENUMSET1:def 4;
L437: (D313 in D320 & D314 in D320) by ENUMSET1:def 4;
L438: (D316 in D321 & D310 in D321) by ENUMSET1:def 4;
L439: (D315 in D320 & D309 in D320) by ENUMSET1:def 4;
L440: (D319 in D321 & D311 in D321) by ENUMSET1:def 4;
L441: (D317 in D321 & D318 in D321) by ENUMSET1:def 4;
L442: ( InnerVertices D307 ) = ( ( ( { D312 , D308 } \/ { D313 , D314 , D315 , D309 } ) \/ { D316 , D310 } ) \/ { D317 , D318 , D319 , D311 } ) by L399
.= ( ( D320 \/ { D316 , D310 } ) \/ { D317 , D318 , D319 , D311 } ) by ENUMSET1:12
.= ( D320 \/ ( { D316 , D310 } \/ { D317 , D318 , D319 , D311 } ) ) by XBOOLE_1:4
.= ( D320 \/ D321 ) by ENUMSET1:12;
thus L443: thesis by L442 , L436 , L437 , L439 , L438 , L441 , L440 , XBOOLE_0:def 3;
end;
theorem
L444: (for B346 , B347 , B348 , B349 being non  pair set holds (for B350 being set holds ((B350 <> [ <* B349 , ( GFA2AdderOutput (B346 , B347 , B348) ) *> , ( and2 ) ] & (not B350 in ( InnerVertices ( BitGFA2Str (B346 , B347 , B348) ) ))) implies (B346 in ( InputVertices ( BitFTA2Str (B346 , B347 , B348 , B349 , B350) ) ) & B347 in ( InputVertices ( BitFTA2Str (B346 , B347 , B348 , B349 , B350) ) ) & B348 in ( InputVertices ( BitFTA2Str (B346 , B347 , B348 , B349 , B350) ) ) & B349 in ( InputVertices ( BitFTA2Str (B346 , B347 , B348 , B349 , B350) ) ) & B350 in ( InputVertices ( BitFTA2Str (B346 , B347 , B348 , B349 , B350) ) )))))
proof
let C364 , C365 , C366 , C367 being non  pair set;
let C368 being set;
set D322 = ( BitFTA2Str (C364 , C365 , C366 , C367 , C368) );
set D323 = ( BitGFA2Str (C364 , C365 , C366) );
set D324 = ( GFA2AdderOutput (C364 , C365 , C366) );
set D325 = [ <* C367 , D324 *> , ( and2 ) ];
assume L445: (C368 <> D325 & (not C368 in ( InnerVertices D323 )));
L446: ( InputVertices D322 ) = { C364 , C365 , C366 , C367 , C368 } by L445 , L414;
thus L447: thesis by L446 , ENUMSET1:def 3;
end;
definition
let C369 , C370 , C371 , C372 , C373 being set;
func BitFTA2CarryOutput (C369 , C370 , C371 , C372 , C373) -> (Element of ( InnerVertices ( BitFTA2Str (C369 , C370 , C371 , C372 , C373) ) )) equals 
( GFA2CarryOutput (C369 , C370 , C371) );
coherence by L435;
func BitFTA2AdderOutputI (C369 , C370 , C371 , C372 , C373) -> (Element of ( InnerVertices ( BitFTA2Str (C369 , C370 , C371 , C372 , C373) ) )) equals 
( GFA2AdderOutput (C369 , C370 , C371) );
coherence by L435;
func BitFTA2AdderOutputP (C369 , C370 , C371 , C372 , C373) -> (Element of ( InnerVertices ( BitFTA2Str (C369 , C370 , C371 , C372 , C373) ) )) equals 
( GFA1CarryOutput (( GFA2AdderOutput (C369 , C370 , C371) ) , C373 , C372) );
coherence by L435;
func BitFTA2AdderOutputQ (C369 , C370 , C371 , C372 , C373) -> (Element of ( InnerVertices ( BitFTA2Str (C369 , C370 , C371 , C372 , C373) ) )) equals 
( GFA1AdderOutput (( GFA2AdderOutput (C369 , C370 , C371) ) , C373 , C372) );
coherence by L435;
end;
theorem
L449: (for B351 , B352 , B353 being non  pair set holds (for B354 , B355 being set holds (for B356 being (State of ( BitFTA2Circ (B351 , B352 , B353 , B354 , B355) )) holds (for B357 , B358 , B359 being (Element of ( BOOLEAN )) holds ((B357 = ( B356 . B351 ) & B358 = ( B356 . B352 ) & B359 = ( B356 . B353 )) implies (( ( Following (B356 , 2) ) . ( BitFTA2CarryOutput (B351 , B352 , B353 , B354 , B355) ) ) = ( 'not' ( ( ( ( 'not' B357 ) '&' B358 ) 'or' ( B358 '&' ( 'not' B359 ) ) ) 'or' ( ( 'not' B359 ) '&' ( 'not' B357 ) ) ) ) & ( ( Following (B356 , 2) ) . ( BitFTA2AdderOutputI (B351 , B352 , B353 , B354 , B355) ) ) = ( ( ( 'not' B357 ) 'xor' B358 ) 'xor' ( 'not' B359 ) )))))))
proof
let C374 , C375 , C376 being non  pair set;
let C377 , C378 being set;
let C379 being (State of ( BitFTA2Circ (C374 , C375 , C376 , C377 , C378) ));
set D326 = ( BitGFA2Str (C374 , C375 , C376) );
set D327 = ( BitGFA2Circ (C374 , C375 , C376) );
set D328 = ( GFA2AdderOutput (C374 , C375 , C376) );
set D329 = ( GFA2CarryOutput (C374 , C375 , C376) );
set D330 = ( BitGFA1Str (D328 , C378 , C377) );
set D331 = ( BitGFA1Circ (D328 , C378 , C377) );
let C380 , C381 , C382 being (Element of ( BOOLEAN ));
assume that
L450: C380 = ( C379 . C374 )
and
L451: C381 = ( C379 . C375 )
and
L452: C382 = ( C379 . C376 );
reconsider D332 = ( C379 | (the carrier of D326) ) as (State of D327) by FACIRC_1:26;
L453: ( dom D332 ) = (the carrier of D326) by CIRCUIT1:3;
L454: C374 in (the carrier of D326) by GFACIRC1:100;
L455: C380 = ( D332 . C374 ) by L454 , L450 , L453 , FUNCT_1:47;
reconsider D333 = C379 as (State of ( D327 +* D331 ));
L456: ( InputVertices D326 ) misses ( InnerVertices D330 ) by L411;
L457: C376 in (the carrier of D326) by GFACIRC1:100;
L458: C382 = ( D332 . C376 ) by L457 , L452 , L453 , FUNCT_1:47;
L459: C375 in (the carrier of D326) by GFACIRC1:100;
L460: C381 = ( D332 . C375 ) by L459 , L451 , L453 , FUNCT_1:47;
L461: D329 in (the carrier of D326) by GFACIRC1:100;
L462: ( ( Following (D333 , 2) ) . ( GFA2CarryOutput (C374 , C375 , C376) ) ) = ( ( Following (D332 , 2) ) . ( GFA2CarryOutput (C374 , C375 , C376) ) ) by L461 , L456 , FACIRC_1:32;
thus L463: ( ( Following (C379 , 2) ) . ( BitFTA2CarryOutput (C374 , C375 , C376 , C377 , C378) ) ) = ( 'not' ( ( ( ( 'not' C380 ) '&' C381 ) 'or' ( C381 '&' ( 'not' C382 ) ) ) 'or' ( ( 'not' C382 ) '&' ( 'not' C380 ) ) ) ) by L462 , L455 , L460 , L458 , GFACIRC1:103;
L464: D328 in (the carrier of D326) by GFACIRC1:100;
L465: ( ( Following (D333 , 2) ) . ( GFA2AdderOutput (C374 , C375 , C376) ) ) = ( ( Following (D332 , 2) ) . ( GFA2AdderOutput (C374 , C375 , C376) ) ) by L464 , L456 , FACIRC_1:32;
thus L466: thesis by L465 , L455 , L460 , L458 , GFACIRC1:103;
end;
theorem
L467: (for B360 , B361 , B362 , B363 being non  pair set holds (for B364 being set holds ((B364 <> [ <* B363 , ( GFA2AdderOutput (B360 , B361 , B362) ) *> , ( and2 ) ] & (not B364 in ( InnerVertices ( BitGFA2Str (B360 , B361 , B362) ) ))) implies (for B365 being (State of ( BitFTA2Circ (B360 , B361 , B362 , B363 , B364) )) holds (for B366 , B367 , B368 , B369 , B370 being (Element of ( BOOLEAN )) holds ((B366 = ( B365 . B360 ) & B367 = ( B365 . B361 ) & B368 = ( B365 . B362 ) & B369 = ( B365 . B363 ) & B370 = ( B365 . B364 )) implies (( ( Following (B365 , 2) ) . ( GFA2AdderOutput (B360 , B361 , B362) ) ) = ( ( ( 'not' B366 ) 'xor' B367 ) 'xor' ( 'not' B368 ) ) & ( ( Following (B365 , 2) ) . B360 ) = B366 & ( ( Following (B365 , 2) ) . B361 ) = B367 & ( ( Following (B365 , 2) ) . B362 ) = B368 & ( ( Following (B365 , 2) ) . B363 ) = B369 & ( ( Following (B365 , 2) ) . B364 ) = B370)))))))
proof
let C383 , C384 , C385 , C386 being non  pair set;
let C387 being set;
assume that
L468: (C387 <> [ <* C386 , ( GFA2AdderOutput (C383 , C384 , C385) ) *> , ( and2 ) ] & (not C387 in ( InnerVertices ( BitGFA2Str (C383 , C384 , C385) ) )));
set D334 = ( GFA2AdderOutput (C383 , C384 , C385) );
set D335 = ( BitGFA2Circ (C383 , C384 , C385) );
set D336 = ( BitGFA2Str (C383 , C384 , C385) );
set D337 = ( BitGFA1Str (D334 , C387 , C386) );
set D338 = ( BitGFA1Circ (D334 , C387 , C386) );
set D339 = ( BitFTA2Str (C383 , C384 , C385 , C386 , C387) );
let C388 being (State of ( BitFTA2Circ (C383 , C384 , C385 , C386 , C387) ));
let C389 , C390 , C391 , C392 , C393 being (Element of ( BOOLEAN ));
assume that
L469: C389 = ( C388 . C383 )
and
L470: C390 = ( C388 . C384 )
and
L471: C391 = ( C388 . C385 )
and
L472: C392 = ( C388 . C386 )
and
L473: C393 = ( C388 . C387 );
reconsider D340 = ( C388 | (the carrier of D336) ) as (State of D335) by FACIRC_1:26;
L474: ( dom D340 ) = (the carrier of D336) by CIRCUIT1:3;
L475: C386 in ( InputVertices D339 ) by L468 , L444;
L476: ( ( Following C388 ) . C386 ) = C392 by L475 , L472 , CIRCUIT2:def 5;
L477: C385 in ( InputVertices D339 ) by L468 , L444;
L478: ( ( Following C388 ) . C385 ) = C391 by L477 , L471 , CIRCUIT2:def 5;
L479: C384 in (the carrier of D336) by GFACIRC1:100;
L480: C390 = ( D340 . C384 ) by L479 , L470 , L474 , FUNCT_1:47;
reconsider D341 = C388 as (State of ( D335 +* D338 ));
L481: (D334 in (the carrier of D336) & ( InputVertices D336 ) misses ( InnerVertices D337 )) by L411 , GFACIRC1:100;
L482: ( ( Following (D341 , 2) ) . ( GFA2AdderOutput (C383 , C384 , C385) ) ) = ( ( Following (D340 , 2) ) . ( GFA2AdderOutput (C383 , C384 , C385) ) ) by L481 , FACIRC_1:32;
L483: C385 in (the carrier of D336) by GFACIRC1:100;
L484: C391 = ( D340 . C385 ) by L483 , L471 , L474 , FUNCT_1:47;
L485: C383 in (the carrier of D336) by GFACIRC1:100;
L486: C389 = ( D340 . C383 ) by L485 , L469 , L474 , FUNCT_1:47;
thus L487: ( ( Following (C388 , 2) ) . ( GFA2AdderOutput (C383 , C384 , C385) ) ) = ( ( ( 'not' C389 ) 'xor' C390 ) 'xor' ( 'not' C391 ) ) by L486 , L480 , L484 , L482 , GFACIRC1:103;
L488: C384 in ( InputVertices D339 ) by L468 , L444;
L489: ( ( Following C388 ) . C384 ) = C390 by L488 , L470 , CIRCUIT2:def 5;
L490: C387 in ( InputVertices D339 ) by L468 , L444;
L491: ( ( Following C388 ) . C387 ) = C393 by L490 , L473 , CIRCUIT2:def 5;
L492: C383 in ( InputVertices D339 ) by L468 , L444;
L493: (( Following (C388 , 2) ) = ( Following ( Following C388 ) ) & ( ( Following C388 ) . C383 ) = C389) by L492 , L469 , CIRCUIT2:def 5 , FACIRC_1:15;
thus L494: thesis by L493 , L492 , L488 , L477 , L475 , L490 , L489 , L478 , L476 , L491 , CIRCUIT2:def 5;
end;
L495: (for B371 , B372 , B373 , B374 being non  pair set holds (for B375 being set holds (for B376 being (State of ( BitFTA2Circ (B371 , B372 , B373 , B374 , B375) )) holds (for B377 , B378 , B379 being (Element of ( BOOLEAN )) holds ((B377 = ( B376 . ( GFA2AdderOutput (B371 , B372 , B373) ) ) & B378 = ( B376 . B374 ) & B379 = ( B376 . B375 )) implies (( ( Following B376 ) . [ <* ( GFA2AdderOutput (B371 , B372 , B373) ) , B375 *> , ( and2c ) ] ) = ( B377 '&' ( 'not' B379 ) ) & ( ( Following B376 ) . [ <* B375 , B374 *> , ( and2a ) ] ) = ( ( 'not' B379 ) '&' B378 ) & ( ( Following B376 ) . [ <* B374 , ( GFA2AdderOutput (B371 , B372 , B373) ) *> , ( and2 ) ] ) = ( B378 '&' B377 )))))))
proof
let C394 , C395 , C396 , C397 being non  pair set;
let C398 being set;
set D342 = ( BitFTA2Str (C394 , C395 , C396 , C397 , C398) );
set D343 = ( BitFTA2Circ (C394 , C395 , C396 , C397 , C398) );
set D344 = ( GFA2AdderOutput (C394 , C395 , C396) );
set D345 = [ <* D344 , C398 *> , ( and2c ) ];
set D346 = [ <* C398 , C397 *> , ( and2a ) ];
set D347 = [ <* C397 , D344 *> , ( and2 ) ];
let C399 being (State of D343);
let C400 , C401 , C402 being (Element of ( BOOLEAN ));
assume that
L496: C400 = ( C399 . D344 )
and
L497: C401 = ( C399 . C397 )
and
L498: C402 = ( C399 . C398 );
L499: ( dom C399 ) = (the carrier of D342) by CIRCUIT1:3;
L500: C398 in (the carrier of D342) by L424;
L501: D344 in (the carrier of D342) by L424;
L502: ( InnerVertices D342 ) = (the carrier' of D342) by FACIRC_1:37;
L503: D345 in (the carrier' of D342) by L502 , L435;
thus L504: ( ( Following C399 ) . D345 ) = ( ( and2c ) . ( C399 * <* D344 , C398 *> ) ) by L503 , FACIRC_1:35
.= ( ( and2c ) . <* C400 , C402 *> ) by L496 , L498 , L501 , L500 , L499 , FINSEQ_2:125
.= ( C400 '&' ( 'not' C402 ) ) by GFACIRC1:def 3;
L505: C397 in (the carrier of D342) by L424;
L506: D346 in (the carrier' of D342) by L502 , L435;
thus L507: ( ( Following C399 ) . D346 ) = ( ( and2a ) . ( C399 * <* C398 , C397 *> ) ) by L506 , FACIRC_1:35
.= ( ( and2a ) . <* C402 , C401 *> ) by L497 , L498 , L505 , L500 , L499 , FINSEQ_2:125
.= ( ( 'not' C402 ) '&' C401 ) by TWOSCOMP:def 2;
L508: D347 in (the carrier' of D342) by L502 , L435;
thus L509: ( ( Following C399 ) . D347 ) = ( ( and2 ) . ( C399 * <* C397 , D344 *> ) ) by L508 , FACIRC_1:35
.= ( ( and2 ) . <* C401 , C400 *> ) by L496 , L497 , L501 , L505 , L499 , FINSEQ_2:125
.= ( C401 '&' C400 ) by TWOSCOMP:def 1;
end;
L510: (for B380 , B381 , B382 , B383 being non  pair set holds (for B384 being set holds (for B385 being (State of ( BitFTA2Circ (B380 , B381 , B382 , B383 , B384) )) holds (for B386 , B387 being (Element of ( BOOLEAN )) holds ((B386 = ( B385 . ( GFA2AdderOutput (B380 , B381 , B382) ) ) & B387 = ( B385 . B384 )) implies ( ( Following B385 ) . [ <* ( GFA2AdderOutput (B380 , B381 , B382) ) , B384 *> , ( xor2c ) ] ) = ( B386 'xor' ( 'not' B387 ) ))))))
proof
let C403 , C404 , C405 , C406 being non  pair set;
let C407 being set;
set D348 = ( BitFTA2Str (C403 , C404 , C405 , C406 , C407) );
set D349 = ( BitFTA2Circ (C403 , C404 , C405 , C406 , C407) );
set D350 = ( GFA2AdderOutput (C403 , C404 , C405) );
set D351 = [ <* D350 , C407 *> , ( xor2c ) ];
let C408 being (State of D349);
let C409 , C410 being (Element of ( BOOLEAN ));
assume that
L511: (C409 = ( C408 . D350 ) & C410 = ( C408 . C407 ));
L512: ( dom C408 ) = (the carrier of D348) by CIRCUIT1:3;
L513: (D350 in (the carrier of D348) & C407 in (the carrier of D348)) by L424;
L514: ( InnerVertices D348 ) = (the carrier' of D348) by FACIRC_1:37;
L515: D351 in (the carrier' of D348) by L514 , L435;
thus L516: ( ( Following C408 ) . D351 ) = ( ( xor2c ) . ( C408 * <* D350 , C407 *> ) ) by L515 , FACIRC_1:35
.= ( ( xor2c ) . <* C409 , C410 *> ) by L511 , L513 , L512 , FINSEQ_2:125
.= ( C409 'xor' ( 'not' C410 ) ) by GFACIRC1:def 4;
end;
L517: (for B388 , B389 , B390 , B391 being non  pair set holds (for B392 being set holds ((B392 <> [ <* B391 , ( GFA2AdderOutput (B388 , B389 , B390) ) *> , ( and2 ) ] & (not B392 in ( InnerVertices ( BitGFA2Str (B388 , B389 , B390) ) ))) implies (for B393 being (State of ( BitFTA2Circ (B388 , B389 , B390 , B391 , B392) )) holds (for B394 , B395 , B396 , B397 , B398 being (Element of ( BOOLEAN )) holds ((B394 = ( B393 . B388 ) & B395 = ( B393 . B389 ) & B396 = ( B393 . B390 ) & B397 = ( B393 . B391 ) & B398 = ( B393 . B392 )) implies (( ( Following (B393 , 3) ) . [ <* ( GFA2AdderOutput (B388 , B389 , B390) ) , B392 *> , ( and2c ) ] ) = ( ( ( ( 'not' B394 ) 'xor' B395 ) 'xor' ( 'not' B396 ) ) '&' ( 'not' B398 ) ) & ( ( Following (B393 , 3) ) . [ <* B392 , B391 *> , ( and2a ) ] ) = ( ( 'not' B398 ) '&' B397 ) & ( ( Following (B393 , 3) ) . [ <* B391 , ( GFA2AdderOutput (B388 , B389 , B390) ) *> , ( and2 ) ] ) = ( B397 '&' ( ( ( 'not' B394 ) 'xor' B395 ) 'xor' ( 'not' B396 ) ) ) & ( ( Following (B393 , 3) ) . B388 ) = B394 & ( ( Following (B393 , 3) ) . B389 ) = B395 & ( ( Following (B393 , 3) ) . B390 ) = B396 & ( ( Following (B393 , 3) ) . B391 ) = B397 & ( ( Following (B393 , 3) ) . B392 ) = B398)))))))
proof
let C411 , C412 , C413 , C414 being non  pair set;
let C415 being set;
assume that
L518: (C415 <> [ <* C414 , ( GFA2AdderOutput (C411 , C412 , C413) ) *> , ( and2 ) ] & (not C415 in ( InnerVertices ( BitGFA2Str (C411 , C412 , C413) ) )));
set D352 = ( BitFTA2Str (C411 , C412 , C413 , C414 , C415) );
L519: (C411 in ( InputVertices D352 ) & C412 in ( InputVertices D352 )) by L518 , L444;
L520: (C413 in ( InputVertices D352 ) & C414 in ( InputVertices D352 )) by L518 , L444;
let C416 being (State of ( BitFTA2Circ (C411 , C412 , C413 , C414 , C415) ));
let C417 , C418 , C419 , C420 , C421 being (Element of ( BOOLEAN ));
assume that
L521: (C417 = ( C416 . C411 ) & C418 = ( C416 . C412 ) & C419 = ( C416 . C413 ) & C420 = ( C416 . C414 ) & C421 = ( C416 . C415 ));
L522: ( ( Following (C416 , 2) ) . C415 ) = C421 by L518 , L521 , L467;
set D353 = [ <* C415 , C414 *> , ( and2a ) ];
set D354 = ( GFA2AdderOutput (C411 , C412 , C413) );
set D355 = [ <* D354 , C415 *> , ( and2c ) ];
set D356 = [ <* C414 , D354 *> , ( and2 ) ];
L523: ( Following (C416 , ( 2 + 1 )) ) = ( Following ( Following (C416 , 2) ) ) by FACIRC_1:12;
L524: (( ( Following (C416 , 2) ) . D354 ) = ( ( ( 'not' C417 ) 'xor' C418 ) 'xor' ( 'not' C419 ) ) & ( ( Following (C416 , 2) ) . C414 ) = C420) by L518 , L521 , L467;
thus L525: (( ( Following (C416 , 3) ) . D355 ) = ( ( ( ( 'not' C417 ) 'xor' C418 ) 'xor' ( 'not' C419 ) ) '&' ( 'not' C421 ) ) & ( ( Following (C416 , 3) ) . D353 ) = ( ( 'not' C421 ) '&' C420 ) & ( ( Following (C416 , 3) ) . D356 ) = ( C420 '&' ( ( ( 'not' C417 ) 'xor' C418 ) 'xor' ( 'not' C419 ) ) )) by L524 , L523 , L522 , L495;
L526: (( ( Following (C416 , 2) ) . C413 ) = C419 & ( ( Following (C416 , 2) ) . C414 ) = C420) by L518 , L521 , L467;
L527: ( ( Following (C416 , 2) ) . C415 ) = C421 by L518 , L521 , L467;
L528: C415 in ( InputVertices D352 ) by L518 , L444;
L529: (( ( Following (C416 , 2) ) . C411 ) = C417 & ( ( Following (C416 , 2) ) . C412 ) = C418) by L518 , L521 , L467;
thus L530: thesis by L529 , L523 , L519 , L520 , L528 , L526 , L527 , CIRCUIT2:def 5;
end;
L531: (for B399 , B400 , B401 , B402 being non  pair set holds (for B403 being set holds ((B403 <> [ <* B402 , ( GFA2AdderOutput (B399 , B400 , B401) ) *> , ( and2 ) ] & (not B403 in ( InnerVertices ( BitGFA2Str (B399 , B400 , B401) ) ))) implies (for B404 being (State of ( BitFTA2Circ (B399 , B400 , B401 , B402 , B403) )) holds (for B405 , B406 , B407 , B408 , B409 being (Element of ( BOOLEAN )) holds ((B405 = ( B404 . B399 ) & B406 = ( B404 . B400 ) & B407 = ( B404 . B401 ) & B408 = ( B404 . B402 ) & B409 = ( B404 . B403 )) implies (( ( Following (B404 , 3) ) . [ <* ( GFA2AdderOutput (B399 , B400 , B401) ) , B403 *> , ( xor2c ) ] ) = ( ( ( ( 'not' B405 ) 'xor' B406 ) 'xor' ( 'not' B407 ) ) 'xor' ( 'not' B409 ) ) & ( ( Following (B404 , 3) ) . B399 ) = B405 & ( ( Following (B404 , 3) ) . B400 ) = B406 & ( ( Following (B404 , 3) ) . B401 ) = B407 & ( ( Following (B404 , 3) ) . B402 ) = B408 & ( ( Following (B404 , 3) ) . B403 ) = B409)))))))
proof
let C422 , C423 , C424 , C425 being non  pair set;
let C426 being set;
assume that
L532: (C426 <> [ <* C425 , ( GFA2AdderOutput (C422 , C423 , C424) ) *> , ( and2 ) ] & (not C426 in ( InnerVertices ( BitGFA2Str (C422 , C423 , C424) ) )));
set D357 = ( BitFTA2Str (C422 , C423 , C424 , C425 , C426) );
L533: (C422 in ( InputVertices D357 ) & C423 in ( InputVertices D357 )) by L532 , L444;
L534: (C424 in ( InputVertices D357 ) & C425 in ( InputVertices D357 )) by L532 , L444;
let C427 being (State of ( BitFTA2Circ (C422 , C423 , C424 , C425 , C426) ));
let C428 , C429 , C430 , C431 , C432 being (Element of ( BOOLEAN ));
assume that
L535: (C428 = ( C427 . C422 ) & C429 = ( C427 . C423 ) & C430 = ( C427 . C424 ) & C431 = ( C427 . C425 ) & C432 = ( C427 . C426 ));
L536: (( ( Following (C427 , 2) ) . C424 ) = C430 & ( ( Following (C427 , 2) ) . C425 ) = C431) by L532 , L535 , L467;
set D358 = ( GFA2AdderOutput (C422 , C423 , C424) );
set D359 = [ <* D358 , C426 *> , ( xor2c ) ];
L537: ( Following (C427 , ( 2 + 1 )) ) = ( Following ( Following (C427 , 2) ) ) by FACIRC_1:12;
L538: (( ( Following (C427 , 2) ) . D358 ) = ( ( ( 'not' C428 ) 'xor' C429 ) 'xor' ( 'not' C430 ) ) & ( ( Following (C427 , 2) ) . C426 ) = C432) by L532 , L535 , L467;
thus L539: ( ( Following (C427 , 3) ) . D359 ) = ( ( ( ( 'not' C428 ) 'xor' C429 ) 'xor' ( 'not' C430 ) ) 'xor' ( 'not' C432 ) ) by L538 , L537 , L510;
L540: ( ( Following (C427 , 2) ) . C426 ) = C432 by L532 , L535 , L467;
L541: C426 in ( InputVertices D357 ) by L532 , L444;
L542: (( ( Following (C427 , 2) ) . C422 ) = C428 & ( ( Following (C427 , 2) ) . C423 ) = C429) by L532 , L535 , L467;
thus L543: thesis by L542 , L537 , L533 , L534 , L541 , L536 , L540 , CIRCUIT2:def 5;
end;
L544: (for B410 , B411 , B412 , B413 being non  pair set holds (for B414 being set holds (for B415 being (State of ( BitFTA2Circ (B410 , B411 , B412 , B413 , B414) )) holds (for B416 , B417 , B418 being (Element of ( BOOLEAN )) holds ((B416 = ( B415 . [ <* ( GFA2AdderOutput (B410 , B411 , B412) ) , B414 *> , ( and2c ) ] ) & B417 = ( B415 . [ <* B414 , B413 *> , ( and2a ) ] ) & B418 = ( B415 . [ <* B413 , ( GFA2AdderOutput (B410 , B411 , B412) ) *> , ( and2 ) ] )) implies ( ( Following B415 ) . ( GFA1CarryOutput (( GFA2AdderOutput (B410 , B411 , B412) ) , B414 , B413) ) ) = ( ( B416 'or' B417 ) 'or' B418 ))))))
proof
let C433 , C434 , C435 , C436 being non  pair set;
let C437 being set;
set D360 = ( BitFTA2Str (C433 , C434 , C435 , C436 , C437) );
set D361 = ( BitFTA2Circ (C433 , C434 , C435 , C436 , C437) );
set D362 = ( GFA2AdderOutput (C433 , C434 , C435) );
set D363 = ( GFA1CarryOutput (D362 , C437 , C436) );
set D364 = [ <* D362 , C437 *> , ( and2c ) ];
set D365 = [ <* C437 , C436 *> , ( and2a ) ];
set D366 = [ <* C436 , D362 *> , ( and2 ) ];
let C438 being (State of D361);
let C439 , C440 , C441 being (Element of ( BOOLEAN ));
assume that
L545: (C439 = ( C438 . D364 ) & C440 = ( C438 . D365 ) & C441 = ( C438 . D366 ));
L546: (D364 in (the carrier of D360) & D365 in (the carrier of D360)) by L424;
L547: (D366 in (the carrier of D360) & ( dom C438 ) = (the carrier of D360)) by L424 , CIRCUIT1:3;
L548: ( InnerVertices D360 ) = (the carrier' of D360) by FACIRC_1:37;
L549: D363 in (the carrier' of D360) by L548 , L435;
thus L550: ( ( Following C438 ) . D363 ) = ( ( or3 ) . ( C438 * <* D364 , D365 , D366 *> ) ) by L549 , FACIRC_1:35
.= ( ( or3 ) . <* C439 , C440 , C441 *> ) by L545 , L546 , L547 , FINSEQ_2:126
.= ( ( C439 'or' C440 ) 'or' C441 ) by TWOSCOMP:def 24;
end;
L551: (for B419 , B420 , B421 , B422 being non  pair set holds (for B423 being set holds (for B424 being (State of ( BitFTA2Circ (B419 , B420 , B421 , B422 , B423) )) holds (for B425 , B426 being (Element of ( BOOLEAN )) holds ((B425 = ( B424 . [ <* ( GFA2AdderOutput (B419 , B420 , B421) ) , B423 *> , ( xor2c ) ] ) & B426 = ( B424 . B422 )) implies ( ( Following B424 ) . ( GFA1AdderOutput (( GFA2AdderOutput (B419 , B420 , B421) ) , B423 , B422) ) ) = ( B425 'xor' ( 'not' B426 ) ))))))
proof
let C442 , C443 , C444 , C445 being non  pair set;
let C446 being set;
set D367 = ( BitFTA2Str (C442 , C443 , C444 , C445 , C446) );
set D368 = ( BitFTA2Circ (C442 , C443 , C444 , C445 , C446) );
set D369 = ( GFA2AdderOutput (C442 , C443 , C444) );
set D370 = ( GFA1AdderOutput (D369 , C446 , C445) );
set D371 = [ <* D369 , C446 *> , ( xor2c ) ];
let C447 being (State of D368);
let C448 , C449 being (Element of ( BOOLEAN ));
assume that
L552: (C448 = ( C447 . D371 ) & C449 = ( C447 . C445 ));
L553: ( dom C447 ) = (the carrier of D367) by CIRCUIT1:3;
L554: (D371 in (the carrier of D367) & C445 in (the carrier of D367)) by L424;
L555: ( InnerVertices D367 ) = (the carrier' of D367) by FACIRC_1:37;
L556: D370 in (the carrier' of D367) by L555 , L435;
thus L557: ( ( Following C447 ) . D370 ) = ( ( xor2c ) . ( C447 * <* D371 , C445 *> ) ) by L556 , FACIRC_1:35
.= ( ( xor2c ) . <* C448 , C449 *> ) by L552 , L554 , L553 , FINSEQ_2:125
.= ( C448 'xor' ( 'not' C449 ) ) by GFACIRC1:def 4;
end;
L558: (for B427 , B428 , B429 , B430 being non  pair set holds (for B431 being set holds ((B431 <> [ <* B430 , ( GFA2AdderOutput (B427 , B428 , B429) ) *> , ( and2 ) ] & (not B431 in ( InnerVertices ( BitGFA2Str (B427 , B428 , B429) ) ))) implies (for B432 being (State of ( BitFTA2Circ (B427 , B428 , B429 , B430 , B431) )) holds (for B433 , B434 , B435 , B436 , B437 being (Element of ( BOOLEAN )) holds ((B433 = ( B432 . B427 ) & B434 = ( B432 . B428 ) & B435 = ( B432 . B429 ) & B436 = ( B432 . B430 ) & B437 = ( B432 . B431 )) implies (( ( Following (B432 , 4) ) . ( GFA1CarryOutput (( GFA2AdderOutput (B427 , B428 , B429) ) , B431 , B430) ) ) = ( ( ( ( ( ( 'not' B433 ) 'xor' B434 ) 'xor' ( 'not' B435 ) ) '&' ( 'not' B437 ) ) 'or' ( ( 'not' B437 ) '&' B436 ) ) 'or' ( B436 '&' ( ( ( 'not' B433 ) 'xor' B434 ) 'xor' ( 'not' B435 ) ) ) ) & ( ( Following (B432 , 4) ) . B427 ) = B433 & ( ( Following (B432 , 4) ) . B428 ) = B434 & ( ( Following (B432 , 4) ) . B429 ) = B435 & ( ( Following (B432 , 4) ) . B430 ) = B436 & ( ( Following (B432 , 4) ) . B431 ) = B437)))))))
proof
let C450 , C451 , C452 , C453 being non  pair set;
let C454 being set;
assume that
L559: (C454 <> [ <* C453 , ( GFA2AdderOutput (C450 , C451 , C452) ) *> , ( and2 ) ] & (not C454 in ( InnerVertices ( BitGFA2Str (C450 , C451 , C452) ) )));
set D372 = ( BitFTA2Str (C450 , C451 , C452 , C453 , C454) );
L560: (C450 in ( InputVertices D372 ) & C451 in ( InputVertices D372 )) by L559 , L444;
L561: (C452 in ( InputVertices D372 ) & C453 in ( InputVertices D372 )) by L559 , L444;
set D373 = ( GFA2AdderOutput (C450 , C451 , C452) );
let C455 being (State of ( BitFTA2Circ (C450 , C451 , C452 , C453 , C454) ));
set D374 = [ <* C453 , D373 *> , ( and2 ) ];
let C456 , C457 , C458 , C459 , C460 being (Element of ( BOOLEAN ));
assume that
L562: (C456 = ( C455 . C450 ) & C457 = ( C455 . C451 ) & C458 = ( C455 . C452 ) & C459 = ( C455 . C453 ) & C460 = ( C455 . C454 ));
L563: ( ( Following (C455 , 3) ) . D374 ) = ( C459 '&' ( ( ( 'not' C456 ) 'xor' C457 ) 'xor' ( 'not' C458 ) ) ) by L559 , L562 , L517;
set D375 = [ <* C454 , C453 *> , ( and2a ) ];
set D376 = [ <* D373 , C454 *> , ( and2c ) ];
set D377 = ( GFA1CarryOutput (D373 , C454 , C453) );
L564: ( Following (C455 , ( 3 + 1 )) ) = ( Following ( Following (C455 , 3) ) ) by FACIRC_1:12;
L565: (( ( Following (C455 , 3) ) . D376 ) = ( ( ( ( 'not' C456 ) 'xor' C457 ) 'xor' ( 'not' C458 ) ) '&' ( 'not' C460 ) ) & ( ( Following (C455 , 3) ) . D375 ) = ( ( 'not' C460 ) '&' C459 )) by L559 , L562 , L517;
thus L566: ( ( Following (C455 , 4) ) . D377 ) = ( ( ( ( ( ( 'not' C456 ) 'xor' C457 ) 'xor' ( 'not' C458 ) ) '&' ( 'not' C460 ) ) 'or' ( ( 'not' C460 ) '&' C459 ) ) 'or' ( C459 '&' ( ( ( 'not' C456 ) 'xor' C457 ) 'xor' ( 'not' C458 ) ) ) ) by L565 , L564 , L563 , L544;
L567: (( ( Following (C455 , 3) ) . C452 ) = C458 & ( ( Following (C455 , 3) ) . C453 ) = C459) by L559 , L562 , L517;
L568: ( ( Following (C455 , 3) ) . C454 ) = C460 by L559 , L562 , L517;
L569: C454 in ( InputVertices D372 ) by L559 , L444;
L570: (( ( Following (C455 , 3) ) . C450 ) = C456 & ( ( Following (C455 , 3) ) . C451 ) = C457) by L559 , L562 , L517;
thus L571: thesis by L570 , L564 , L560 , L561 , L569 , L567 , L568 , CIRCUIT2:def 5;
end;
L572: (for B438 , B439 , B440 , B441 being non  pair set holds (for B442 being set holds ((B442 <> [ <* B441 , ( GFA2AdderOutput (B438 , B439 , B440) ) *> , ( and2 ) ] & (not B442 in ( InnerVertices ( BitGFA2Str (B438 , B439 , B440) ) ))) implies (for B443 being (State of ( BitFTA2Circ (B438 , B439 , B440 , B441 , B442) )) holds (for B444 , B445 , B446 , B447 , B448 being (Element of ( BOOLEAN )) holds ((B444 = ( B443 . B438 ) & B445 = ( B443 . B439 ) & B446 = ( B443 . B440 ) & B447 = ( B443 . B441 ) & B448 = ( B443 . B442 )) implies (( ( Following (B443 , 4) ) . ( GFA1AdderOutput (( GFA2AdderOutput (B438 , B439 , B440) ) , B442 , B441) ) ) = ( 'not' ( ( ( ( ( 'not' B444 ) 'xor' B445 ) 'xor' ( 'not' B446 ) ) 'xor' B447 ) 'xor' ( 'not' B448 ) ) ) & ( ( Following (B443 , 4) ) . B438 ) = B444 & ( ( Following (B443 , 4) ) . B439 ) = B445 & ( ( Following (B443 , 4) ) . B440 ) = B446 & ( ( Following (B443 , 4) ) . B441 ) = B447 & ( ( Following (B443 , 4) ) . B442 ) = B448)))))))
proof
let C461 , C462 , C463 , C464 being non  pair set;
let C465 being set;
assume that
L573: (C465 <> [ <* C464 , ( GFA2AdderOutput (C461 , C462 , C463) ) *> , ( and2 ) ] & (not C465 in ( InnerVertices ( BitGFA2Str (C461 , C462 , C463) ) )));
set D378 = ( BitFTA2Str (C461 , C462 , C463 , C464 , C465) );
L574: (C461 in ( InputVertices D378 ) & C462 in ( InputVertices D378 )) by L573 , L444;
L575: (C463 in ( InputVertices D378 ) & C464 in ( InputVertices D378 )) by L573 , L444;
let C466 being (State of ( BitFTA2Circ (C461 , C462 , C463 , C464 , C465) ));
let C467 , C468 , C469 , C470 , C471 being (Element of ( BOOLEAN ));
assume that
L576: (C467 = ( C466 . C461 ) & C468 = ( C466 . C462 ) & C469 = ( C466 . C463 ) & C470 = ( C466 . C464 ) & C471 = ( C466 . C465 ));
L577: (( ( Following (C466 , 3) ) . C463 ) = C469 & ( ( Following (C466 , 3) ) . C464 ) = C470) by L573 , L576 , L531;
set D379 = ( GFA2AdderOutput (C461 , C462 , C463) );
set D380 = ( GFA1AdderOutput (D379 , C465 , C464) );
set D381 = [ <* D379 , C465 *> , ( xor2c ) ];
L578: ( Following (C466 , ( 3 + 1 )) ) = ( Following ( Following (C466 , 3) ) ) by FACIRC_1:12;
L579: (( ( Following (C466 , 3) ) . D381 ) = ( ( ( ( 'not' C467 ) 'xor' C468 ) 'xor' ( 'not' C469 ) ) 'xor' ( 'not' C471 ) ) & ( ( Following (C466 , 3) ) . C464 ) = C470) by L573 , L576 , L531;
thus L580: ( ( Following (C466 , 4) ) . D380 ) = ( ( ( ( ( 'not' C467 ) 'xor' C468 ) 'xor' ( 'not' C469 ) ) 'xor' ( 'not' C471 ) ) 'xor' ( 'not' C470 ) ) by L579 , L578 , L551
.= ( 'not' ( ( ( ( ( 'not' C467 ) 'xor' C468 ) 'xor' ( 'not' C469 ) ) 'xor' ( 'not' C471 ) ) 'xor' C470 ) ) by XBOOLEAN:74
.= ( 'not' ( ( ( ( ( 'not' C467 ) 'xor' C468 ) 'xor' ( 'not' C469 ) ) 'xor' C470 ) 'xor' ( 'not' C471 ) ) ) by XBOOLEAN:73;
L581: ( ( Following (C466 , 3) ) . C465 ) = C471 by L573 , L576 , L531;
L582: C465 in ( InputVertices D378 ) by L573 , L444;
L583: (( ( Following (C466 , 3) ) . C461 ) = C467 & ( ( Following (C466 , 3) ) . C462 ) = C468) by L573 , L576 , L531;
thus L584: thesis by L583 , L578 , L574 , L575 , L582 , L577 , L581 , CIRCUIT2:def 5;
end;
theorem
L585: (for B449 , B450 , B451 , B452 being non  pair set holds (for B453 being set holds ((B453 <> [ <* B452 , ( GFA2AdderOutput (B449 , B450 , B451) ) *> , ( and2 ) ] & (not B453 in ( InnerVertices ( BitGFA2Str (B449 , B450 , B451) ) ))) implies (for B454 being (State of ( BitFTA2Circ (B449 , B450 , B451 , B452 , B453) )) holds (for B455 , B456 , B457 , B458 , B459 being (Element of ( BOOLEAN )) holds ((B455 = ( B454 . B449 ) & B456 = ( B454 . B450 ) & B457 = ( B454 . B451 ) & B458 = ( B454 . B452 ) & B459 = ( B454 . B453 )) implies (( ( Following (B454 , 4) ) . ( BitFTA2AdderOutputP (B449 , B450 , B451 , B452 , B453) ) ) = ( ( ( ( ( ( 'not' B455 ) 'xor' B456 ) 'xor' ( 'not' B457 ) ) '&' ( 'not' B459 ) ) 'or' ( ( 'not' B459 ) '&' B458 ) ) 'or' ( B458 '&' ( ( ( 'not' B455 ) 'xor' B456 ) 'xor' ( 'not' B457 ) ) ) ) & ( ( Following (B454 , 4) ) . ( BitFTA2AdderOutputQ (B449 , B450 , B451 , B452 , B453) ) ) = ( 'not' ( ( ( ( ( 'not' B455 ) 'xor' B456 ) 'xor' ( 'not' B457 ) ) 'xor' B458 ) 'xor' ( 'not' B459 ) ) )))))))) by L558 , L572;
theorem
L586: (for B460 , B461 , B462 , B463 being non  pair set holds (for B464 being set holds (B464 <> [ <* B463 , ( GFA2AdderOutput (B460 , B461 , B462) ) *> , ( and2 ) ] implies (for B465 being (State of ( BitFTA2Circ (B460 , B461 , B462 , B463 , B464) )) holds ( Following (B465 , 4) ) is  stable))))
proof
set D382 = 2;
set D383 = 2;
let C472 , C473 , C474 , C475 being non  pair set;
let C476 being set;
set D384 = ( BitFTA2Circ (C472 , C473 , C474 , C475 , C476) );
set D385 = ( BitGFA2Str (C472 , C473 , C474) );
set D386 = ( BitGFA2Circ (C472 , C473 , C474) );
set D387 = ( GFA2AdderOutput (C472 , C473 , C474) );
set D388 = ( BitGFA1Str (D387 , C476 , C475) );
set D389 = ( BitGFA1Circ (D387 , C476 , C475) );
set D390 = [ <* C475 , D387 *> , ( and2 ) ];
assume L587: C476 <> D390;
let C477 being (State of D384);
L588: D386 tolerates D389 by CIRCCOMB:60;
L589: (the Sorts of D386) tolerates (the Sorts of D389) by L588 , CIRCCOMB:def 3;
reconsider D391 = ( C477 | (the carrier of D385) ) as (State of D386) by L589 , CIRCCOMB:26;
reconsider D392 = ( ( Following (C477 , D382) ) | (the carrier of D388) ) as (State of D389) by L589 , CIRCCOMB:26;
L590: (( InputVertices D385 ) misses ( InnerVertices D388 ) & ( Following (D391 , D382) ) is  stable) by L411 , GFACIRC1:104;
L591: ( Following (D392 , D383) ) is  stable by L587 , L405 , GFACIRC1:72;
L592: ( Following (C477 , ( D382 + D383 )) ) is  stable by L591 , L590 , CIRCCMB2:19 , CIRCCOMB:60;
thus L593: thesis by L592;
end;
begin
definition
let C478 , C479 , C480 , C481 , C482 being set;
func BitFTA3Str (C478 , C479 , C480 , C481 , C482) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( BitGFA3Str (C478 , C479 , C480) ) +* ( BitGFA3Str (( GFA3AdderOutput (C478 , C479 , C480) ) , C482 , C481) ) );
coherence;
end;
definition
let C483 , C484 , C485 , C486 , C487 being set;
func BitFTA3Circ (C483 , C484 , C485 , C486 , C487) ->  strict  Boolean  gate`2=den (Circuit of ( BitFTA3Str (C483 , C484 , C485 , C486 , C487) )) equals 
( ( BitGFA3Circ (C483 , C484 , C485) ) +* ( BitGFA3Circ (( GFA3AdderOutput (C483 , C484 , C485) ) , C487 , C486) ) );
coherence;
end;
theorem
L596: (for B466 , B467 , B468 , B469 , B470 being set holds ( InnerVertices ( BitFTA3Str (B466 , B467 , B468 , B469 , B470) ) ) = ( ( ( { [ <* B466 , B467 *> , ( xor2 ) ] , ( GFA3AdderOutput (B466 , B467 , B468) ) } \/ { [ <* B466 , B467 *> , ( and2b ) ] , [ <* B467 , B468 *> , ( and2b ) ] , [ <* B468 , B466 *> , ( and2b ) ] , ( GFA3CarryOutput (B466 , B467 , B468) ) } ) \/ { [ <* ( GFA3AdderOutput (B466 , B467 , B468) ) , B470 *> , ( xor2 ) ] , ( GFA3AdderOutput (( GFA3AdderOutput (B466 , B467 , B468) ) , B470 , B469) ) } ) \/ { [ <* ( GFA3AdderOutput (B466 , B467 , B468) ) , B470 *> , ( and2b ) ] , [ <* B470 , B469 *> , ( and2b ) ] , [ <* B469 , ( GFA3AdderOutput (B466 , B467 , B468) ) *> , ( and2b ) ] , ( GFA3CarryOutput (( GFA3AdderOutput (B466 , B467 , B468) ) , B470 , B469) ) } ))
proof
let C488 , C489 , C490 , C491 , C492 being set;
set D393 = ( BitFTA3Str (C488 , C489 , C490 , C491 , C492) );
set D394 = ( BitGFA3Str (C488 , C489 , C490) );
set D395 = ( GFA3AdderOutput (C488 , C489 , C490) );
set D396 = ( GFA3CarryOutput (C488 , C489 , C490) );
set D397 = ( BitGFA3Str (D395 , C492 , C491) );
set D398 = ( GFA3AdderOutput (D395 , C492 , C491) );
set D399 = ( GFA3CarryOutput (D395 , C492 , C491) );
set D400 = [ <* C488 , C489 *> , ( xor2 ) ];
set D401 = [ <* C488 , C489 *> , ( and2b ) ];
set D402 = [ <* C489 , C490 *> , ( and2b ) ];
set D403 = [ <* C490 , C488 *> , ( and2b ) ];
set D404 = [ <* D395 , C492 *> , ( xor2 ) ];
set D405 = [ <* D395 , C492 *> , ( and2b ) ];
set D406 = [ <* C492 , C491 *> , ( and2b ) ];
set D407 = [ <* C491 , D395 *> , ( and2b ) ];
L597: D394 tolerates D397 by CIRCCOMB:47;
thus L598: ( InnerVertices D393 ) = ( ( InnerVertices D394 ) \/ ( InnerVertices D397 ) ) by L597 , CIRCCOMB:11
.= ( ( ( ( { D400 } \/ { D395 } ) \/ { D401 , D402 , D403 } ) \/ { D396 } ) \/ ( InnerVertices D397 ) ) by GFACIRC1:127
.= ( ( ( { D400 , D395 } \/ { D401 , D402 , D403 } ) \/ { D396 } ) \/ ( InnerVertices D397 ) ) by ENUMSET1:1
.= ( ( { D400 , D395 } \/ ( { D401 , D402 , D403 } \/ { D396 } ) ) \/ ( InnerVertices D397 ) ) by XBOOLE_1:4
.= ( ( { D400 , D395 } \/ { D401 , D402 , D403 , D396 } ) \/ ( InnerVertices D397 ) ) by ENUMSET1:6
.= ( ( { D400 , D395 } \/ { D401 , D402 , D403 , D396 } ) \/ ( ( ( { D404 } \/ { D398 } ) \/ { D405 , D406 , D407 } ) \/ { D399 } ) ) by GFACIRC1:127
.= ( ( { D400 , D395 } \/ { D401 , D402 , D403 , D396 } ) \/ ( ( { D404 , D398 } \/ { D405 , D406 , D407 } ) \/ { D399 } ) ) by ENUMSET1:1
.= ( ( { D400 , D395 } \/ { D401 , D402 , D403 , D396 } ) \/ ( { D404 , D398 } \/ ( { D405 , D406 , D407 } \/ { D399 } ) ) ) by XBOOLE_1:4
.= ( ( { D400 , D395 } \/ { D401 , D402 , D403 , D396 } ) \/ ( { D404 , D398 } \/ { D405 , D406 , D407 , D399 } ) ) by ENUMSET1:6
.= ( ( ( { D400 , D395 } \/ { D401 , D402 , D403 , D396 } ) \/ { D404 , D398 } ) \/ { D405 , D406 , D407 , D399 } ) by XBOOLE_1:4;
end;
theorem
L599: (for B471 , B472 , B473 , B474 , B475 being set holds ( InnerVertices ( BitFTA3Str (B471 , B472 , B473 , B474 , B475) ) ) is Relation)
proof
let C493 , C494 , C495 , C496 , C497 being set;
set D408 = ( BitGFA3Str (C493 , C494 , C495) );
set D409 = ( GFA3AdderOutput (C493 , C494 , C495) );
set D410 = ( BitGFA3Str (D409 , C497 , C496) );
L600: (( InnerVertices D408 ) is Relation & ( InnerVertices D410 ) is Relation) by GFACIRC1:128;
thus L601: thesis by L600 , FACIRC_1:3;
end;
L602: (for B476 , B477 , B478 being set holds (for B479 being set holds ( GFA3AdderOutput (B476 , B477 , B478) ) <> [ B479 , ( and2b ) ]))
proof
let C498 , C499 , C500 being set;
let C501 being set;
set D411 = ( GFA3AdderOutput (C498 , C499 , C500) );
L603:
now
assume L604: ( [ C501 , ( and2b ) ] `2 ) = ( D411 `2 );
L605: ( [ C501 , ( and2b ) ] `2 ) = ( xor2 ) by L604 , MCART_1:7;
thus L606: contradiction by L605 , TWOSCOMP:9 , TWOSCOMP:11;
end;
thus L607: thesis by L603;
end;
L608: (for B480 , B481 , B482 being non  pair set holds (for B483 , B484 , B485 being set holds ( InputVertices ( BitGFA3Str (B480 , B481 , B482) ) ) misses ( InnerVertices ( BitGFA3Str (B483 , B484 , B485) ) )))
proof
let C502 , C503 , C504 being non  pair set;
let C505 , C506 , C507 being set;
set D412 = ( BitGFA3Str (C502 , C503 , C504) );
L609: ( InputVertices D412 ) is  without_pairs by GFACIRC1:131;
thus L610: thesis by L609 , FACIRC_1:5 , GFACIRC1:128;
end;
theorem
L611: (for B486 , B487 , B488 , B489 being non  pair set holds (for B490 being set holds ((B490 <> [ <* B489 , ( GFA3AdderOutput (B486 , B487 , B488) ) *> , ( and2b ) ] & (not B490 in ( InnerVertices ( BitGFA3Str (B486 , B487 , B488) ) ))) implies ( InputVertices ( BitFTA3Str (B486 , B487 , B488 , B489 , B490) ) ) = { B486 , B487 , B488 , B489 , B490 })))
proof
let C508 , C509 , C510 , C511 being non  pair set;
let C512 being set;
set D413 = ( BitFTA3Str (C508 , C509 , C510 , C511 , C512) );
set D414 = ( BitGFA3Str (C508 , C509 , C510) );
set D415 = ( GFA3AdderOutput (C508 , C509 , C510) );
set D416 = ( GFA3CarryOutput (C508 , C509 , C510) );
set D417 = ( BitGFA3Str (D415 , C512 , C511) );
set D418 = [ <* C508 , C509 *> , ( xor2 ) ];
set D419 = [ <* C508 , C509 *> , ( and2b ) ];
set D420 = [ <* C509 , C510 *> , ( and2b ) ];
set D421 = [ <* C510 , C508 *> , ( and2b ) ];
set D422 = [ <* C512 , C511 *> , ( and2b ) ];
set D423 = [ <* C511 , D415 *> , ( and2b ) ];
assume that
L612: C512 <> D423
and
L613: (not C512 in ( InnerVertices D414 ));
L614: (not C511 in { D415 , D418 , D419 , D420 , D421 , D416 }) by ENUMSET1:def 4;
L615: D415 in { D415 , D418 , D419 , D420 , D421 , D416 } by ENUMSET1:def 4;
L616: ( { D415 } \ { D415 , D418 , D419 , D420 , D421 , D416 } ) = ( {} ) by L615 , ZFMISC_1:60;
L617: ( InnerVertices D414 ) = ( ( ( { D418 } \/ { D415 } ) \/ { D419 , D420 , D421 } ) \/ { D416 } ) by GFACIRC1:127
.= ( ( { D418 , D415 } \/ { D419 , D420 , D421 } ) \/ { D416 } ) by ENUMSET1:1
.= ( { D418 , D415 } \/ ( { D419 , D420 , D421 } \/ { D416 } ) ) by XBOOLE_1:4
.= ( { D415 , D418 } \/ { D419 , D420 , D421 , D416 } ) by ENUMSET1:6
.= { D415 , D418 , D419 , D420 , D421 , D416 } by ENUMSET1:12;
L618: ( { D415 , C512 , C511 } \ ( InnerVertices D414 ) ) = ( ( { D415 } \/ { C512 , C511 } ) \ { D415 , D418 , D419 , D420 , D421 , D416 } ) by L617 , ENUMSET1:2
.= ( ( { D415 } \ { D415 , D418 , D419 , D420 , D421 , D416 } ) \/ ( { C512 , C511 } \ { D415 , D418 , D419 , D420 , D421 , D416 } ) ) by XBOOLE_1:42
.= ( ( { C512 } \/ { C511 } ) \ { D415 , D418 , D419 , D420 , D421 , D416 } ) by L616 , ENUMSET1:1
.= ( ( { C512 } \ { D415 , D418 , D419 , D420 , D421 , D416 } ) \/ ( { C511 } \ { D415 , D418 , D419 , D420 , D421 , D416 } ) ) by XBOOLE_1:42
.= ( { C512 } \/ ( { C511 } \ { D415 , D418 , D419 , D420 , D421 , D416 } ) ) by L613 , L617 , ZFMISC_1:59
.= ( { C512 } \/ { C511 } ) by L614 , ZFMISC_1:59
.= { C512 , C511 } by ENUMSET1:1;
L619: D415 <> D422 by L602;
L620: (( InnerVertices D417 ) misses ( InputVertices D414 ) & D414 tolerates D417) by L608 , CIRCCOMB:47;
thus L621: ( InputVertices D413 ) = ( ( InputVertices D414 ) \/ ( ( InputVertices D417 ) \ ( InnerVertices D414 ) ) ) by L620 , FACIRC_1:4
.= ( { C508 , C509 , C510 } \/ ( ( InputVertices D417 ) \ ( InnerVertices D414 ) ) ) by GFACIRC1:130
.= ( { C508 , C509 , C510 } \/ ( { D415 , C512 , C511 } \ ( InnerVertices D414 ) ) ) by L612 , L619 , GFACIRC1:129
.= { C508 , C509 , C510 , C511 , C512 } by L618 , ENUMSET1:9;
end;
theorem
L622: (for B491 , B492 , B493 , B494 , B495 being set holds (B491 in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) )) & B492 in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) )) & B493 in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) )) & B494 in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) )) & B495 in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) )) & [ <* B491 , B492 *> , ( xor2 ) ] in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) )) & ( GFA3AdderOutput (B491 , B492 , B493) ) in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) )) & [ <* B491 , B492 *> , ( and2b ) ] in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) )) & [ <* B492 , B493 *> , ( and2b ) ] in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) )) & [ <* B493 , B491 *> , ( and2b ) ] in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) )) & ( GFA3CarryOutput (B491 , B492 , B493) ) in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) )) & [ <* ( GFA3AdderOutput (B491 , B492 , B493) ) , B495 *> , ( xor2 ) ] in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) )) & ( GFA3AdderOutput (( GFA3AdderOutput (B491 , B492 , B493) ) , B495 , B494) ) in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) )) & [ <* ( GFA3AdderOutput (B491 , B492 , B493) ) , B495 *> , ( and2b ) ] in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) )) & [ <* B495 , B494 *> , ( and2b ) ] in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) )) & [ <* B494 , ( GFA3AdderOutput (B491 , B492 , B493) ) *> , ( and2b ) ] in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) )) & ( GFA3CarryOutput (( GFA3AdderOutput (B491 , B492 , B493) ) , B495 , B494) ) in (the carrier of ( BitFTA3Str (B491 , B492 , B493 , B494 , B495) ))))
proof
let C513 , C514 , C515 , C516 , C517 being set;
set D424 = ( BitGFA3Str (C513 , C514 , C515) );
set D425 = ( GFA3AdderOutput (C513 , C514 , C515) );
set D426 = ( GFA3CarryOutput (C513 , C514 , C515) );
set D427 = ( BitGFA3Str (D425 , C517 , C516) );
set D428 = ( GFA3AdderOutput (D425 , C517 , C516) );
set D429 = ( GFA3CarryOutput (D425 , C517 , C516) );
set D430 = [ <* C513 , C514 *> , ( xor2 ) ];
set D431 = [ <* C513 , C514 *> , ( and2b ) ];
set D432 = [ <* C514 , C515 *> , ( and2b ) ];
set D433 = [ <* C515 , C513 *> , ( and2b ) ];
set D434 = [ <* D425 , C517 *> , ( xor2 ) ];
set D435 = [ <* D425 , C517 *> , ( and2b ) ];
set D436 = [ <* C517 , C516 *> , ( and2b ) ];
set D437 = [ <* C516 , D425 *> , ( and2b ) ];
L623: (C515 in (the carrier of D424) & D430 in (the carrier of D424)) by GFACIRC1:132;
L624: (D431 in (the carrier of D424) & D432 in (the carrier of D424)) by GFACIRC1:132;
L625: (D425 in (the carrier of D427) & C517 in (the carrier of D427)) by GFACIRC1:132;
L626: (D433 in (the carrier of D424) & D426 in (the carrier of D424)) by GFACIRC1:132;
L627: D429 in (the carrier of D427) by GFACIRC1:132;
L628: (D436 in (the carrier of D427) & D437 in (the carrier of D427)) by GFACIRC1:132;
L629: (D428 in (the carrier of D427) & D435 in (the carrier of D427)) by GFACIRC1:132;
L630: (C516 in (the carrier of D427) & D434 in (the carrier of D427)) by GFACIRC1:132;
L631: (C513 in (the carrier of D424) & C514 in (the carrier of D424)) by GFACIRC1:132;
thus L632: thesis by L631 , L623 , L624 , L626 , L625 , L630 , L629 , L628 , L627 , FACIRC_1:20;
end;
theorem
L633: (for B496 , B497 , B498 , B499 , B500 being set holds ([ <* B496 , B497 *> , ( xor2 ) ] in ( InnerVertices ( BitFTA3Str (B496 , B497 , B498 , B499 , B500) ) ) & ( GFA3AdderOutput (B496 , B497 , B498) ) in ( InnerVertices ( BitFTA3Str (B496 , B497 , B498 , B499 , B500) ) ) & [ <* B496 , B497 *> , ( and2b ) ] in ( InnerVertices ( BitFTA3Str (B496 , B497 , B498 , B499 , B500) ) ) & [ <* B497 , B498 *> , ( and2b ) ] in ( InnerVertices ( BitFTA3Str (B496 , B497 , B498 , B499 , B500) ) ) & [ <* B498 , B496 *> , ( and2b ) ] in ( InnerVertices ( BitFTA3Str (B496 , B497 , B498 , B499 , B500) ) ) & ( GFA3CarryOutput (B496 , B497 , B498) ) in ( InnerVertices ( BitFTA3Str (B496 , B497 , B498 , B499 , B500) ) ) & [ <* ( GFA3AdderOutput (B496 , B497 , B498) ) , B500 *> , ( xor2 ) ] in ( InnerVertices ( BitFTA3Str (B496 , B497 , B498 , B499 , B500) ) ) & ( GFA3AdderOutput (( GFA3AdderOutput (B496 , B497 , B498) ) , B500 , B499) ) in ( InnerVertices ( BitFTA3Str (B496 , B497 , B498 , B499 , B500) ) ) & [ <* ( GFA3AdderOutput (B496 , B497 , B498) ) , B500 *> , ( and2b ) ] in ( InnerVertices ( BitFTA3Str (B496 , B497 , B498 , B499 , B500) ) ) & [ <* B500 , B499 *> , ( and2b ) ] in ( InnerVertices ( BitFTA3Str (B496 , B497 , B498 , B499 , B500) ) ) & [ <* B499 , ( GFA3AdderOutput (B496 , B497 , B498) ) *> , ( and2b ) ] in ( InnerVertices ( BitFTA3Str (B496 , B497 , B498 , B499 , B500) ) ) & ( GFA3CarryOutput (( GFA3AdderOutput (B496 , B497 , B498) ) , B500 , B499) ) in ( InnerVertices ( BitFTA3Str (B496 , B497 , B498 , B499 , B500) ) )))
proof
let C518 , C519 , C520 , C521 , C522 being set;
set D438 = ( BitFTA3Str (C518 , C519 , C520 , C521 , C522) );
set D439 = ( GFA3AdderOutput (C518 , C519 , C520) );
set D440 = ( GFA3CarryOutput (C518 , C519 , C520) );
set D441 = ( GFA3AdderOutput (D439 , C522 , C521) );
set D442 = ( GFA3CarryOutput (D439 , C522 , C521) );
set D443 = [ <* C518 , C519 *> , ( xor2 ) ];
set D444 = [ <* C518 , C519 *> , ( and2b ) ];
set D445 = [ <* C519 , C520 *> , ( and2b ) ];
set D446 = [ <* C520 , C518 *> , ( and2b ) ];
set D447 = [ <* D439 , C522 *> , ( xor2 ) ];
set D448 = [ <* D439 , C522 *> , ( and2b ) ];
set D449 = [ <* C522 , C521 *> , ( and2b ) ];
set D450 = [ <* C521 , D439 *> , ( and2b ) ];
set D451 = { D443 , D439 , D444 , D445 , D446 , D440 };
set D452 = { D447 , D441 , D448 , D449 , D450 , D442 };
L634: (D443 in D451 & D439 in D451) by ENUMSET1:def 4;
L635: (D444 in D451 & D445 in D451) by ENUMSET1:def 4;
L636: (D447 in D452 & D441 in D452) by ENUMSET1:def 4;
L637: (D446 in D451 & D440 in D451) by ENUMSET1:def 4;
L638: (D450 in D452 & D442 in D452) by ENUMSET1:def 4;
L639: (D448 in D452 & D449 in D452) by ENUMSET1:def 4;
L640: ( InnerVertices D438 ) = ( ( ( { D443 , D439 } \/ { D444 , D445 , D446 , D440 } ) \/ { D447 , D441 } ) \/ { D448 , D449 , D450 , D442 } ) by L596
.= ( ( D451 \/ { D447 , D441 } ) \/ { D448 , D449 , D450 , D442 } ) by ENUMSET1:12
.= ( D451 \/ ( { D447 , D441 } \/ { D448 , D449 , D450 , D442 } ) ) by XBOOLE_1:4
.= ( D451 \/ D452 ) by ENUMSET1:12;
thus L641: thesis by L640 , L634 , L635 , L637 , L636 , L639 , L638 , XBOOLE_0:def 3;
end;
theorem
L642: (for B501 , B502 , B503 , B504 being non  pair set holds (for B505 being set holds ((B505 <> [ <* B504 , ( GFA3AdderOutput (B501 , B502 , B503) ) *> , ( and2b ) ] & (not B505 in ( InnerVertices ( BitGFA3Str (B501 , B502 , B503) ) ))) implies (B501 in ( InputVertices ( BitFTA3Str (B501 , B502 , B503 , B504 , B505) ) ) & B502 in ( InputVertices ( BitFTA3Str (B501 , B502 , B503 , B504 , B505) ) ) & B503 in ( InputVertices ( BitFTA3Str (B501 , B502 , B503 , B504 , B505) ) ) & B504 in ( InputVertices ( BitFTA3Str (B501 , B502 , B503 , B504 , B505) ) ) & B505 in ( InputVertices ( BitFTA3Str (B501 , B502 , B503 , B504 , B505) ) )))))
proof
let C523 , C524 , C525 , C526 being non  pair set;
let C527 being set;
set D453 = ( BitFTA3Str (C523 , C524 , C525 , C526 , C527) );
set D454 = ( BitGFA3Str (C523 , C524 , C525) );
set D455 = ( GFA3AdderOutput (C523 , C524 , C525) );
set D456 = [ <* C526 , D455 *> , ( and2b ) ];
assume L643: (C527 <> D456 & (not C527 in ( InnerVertices D454 )));
L644: ( InputVertices D453 ) = { C523 , C524 , C525 , C526 , C527 } by L643 , L611;
thus L645: thesis by L644 , ENUMSET1:def 3;
end;
definition
let C528 , C529 , C530 , C531 , C532 being set;
func BitFTA3CarryOutput (C528 , C529 , C530 , C531 , C532) -> (Element of ( InnerVertices ( BitFTA3Str (C528 , C529 , C530 , C531 , C532) ) )) equals 
( GFA3CarryOutput (C528 , C529 , C530) );
coherence by L633;
func BitFTA3AdderOutputI (C528 , C529 , C530 , C531 , C532) -> (Element of ( InnerVertices ( BitFTA3Str (C528 , C529 , C530 , C531 , C532) ) )) equals 
( GFA3AdderOutput (C528 , C529 , C530) );
coherence by L633;
func BitFTA3AdderOutputP (C528 , C529 , C530 , C531 , C532) -> (Element of ( InnerVertices ( BitFTA3Str (C528 , C529 , C530 , C531 , C532) ) )) equals 
( GFA3CarryOutput (( GFA3AdderOutput (C528 , C529 , C530) ) , C532 , C531) );
coherence by L633;
func BitFTA3AdderOutputQ (C528 , C529 , C530 , C531 , C532) -> (Element of ( InnerVertices ( BitFTA3Str (C528 , C529 , C530 , C531 , C532) ) )) equals 
( GFA3AdderOutput (( GFA3AdderOutput (C528 , C529 , C530) ) , C532 , C531) );
coherence by L633;
end;
theorem
L647: (for B506 , B507 , B508 being non  pair set holds (for B509 , B510 being set holds (for B511 being (State of ( BitFTA3Circ (B506 , B507 , B508 , B509 , B510) )) holds (for B512 , B513 , B514 being (Element of ( BOOLEAN )) holds ((B512 = ( B511 . B506 ) & B513 = ( B511 . B507 ) & B514 = ( B511 . B508 )) implies (( ( Following (B511 , 2) ) . ( BitFTA3CarryOutput (B506 , B507 , B508 , B509 , B510) ) ) = ( 'not' ( ( ( ( 'not' B512 ) '&' ( 'not' B513 ) ) 'or' ( ( 'not' B513 ) '&' ( 'not' B514 ) ) ) 'or' ( ( 'not' B514 ) '&' ( 'not' B512 ) ) ) ) & ( ( Following (B511 , 2) ) . ( BitFTA3AdderOutputI (B506 , B507 , B508 , B509 , B510) ) ) = ( 'not' ( ( ( 'not' B512 ) 'xor' ( 'not' B513 ) ) 'xor' ( 'not' B514 ) ) )))))))
proof
let C533 , C534 , C535 being non  pair set;
let C536 , C537 being set;
let C538 being (State of ( BitFTA3Circ (C533 , C534 , C535 , C536 , C537) ));
set D457 = ( BitGFA3Str (C533 , C534 , C535) );
set D458 = ( BitGFA3Circ (C533 , C534 , C535) );
set D459 = ( GFA3AdderOutput (C533 , C534 , C535) );
set D460 = ( GFA3CarryOutput (C533 , C534 , C535) );
set D461 = ( BitGFA3Str (D459 , C537 , C536) );
set D462 = ( BitGFA3Circ (D459 , C537 , C536) );
let C539 , C540 , C541 being (Element of ( BOOLEAN ));
assume that
L648: C539 = ( C538 . C533 )
and
L649: C540 = ( C538 . C534 )
and
L650: C541 = ( C538 . C535 );
reconsider D463 = ( C538 | (the carrier of D457) ) as (State of D458) by FACIRC_1:26;
L651: ( dom D463 ) = (the carrier of D457) by CIRCUIT1:3;
L652: C533 in (the carrier of D457) by GFACIRC1:132;
L653: C539 = ( D463 . C533 ) by L652 , L648 , L651 , FUNCT_1:47;
reconsider D464 = C538 as (State of ( D458 +* D462 ));
L654: ( InputVertices D457 ) misses ( InnerVertices D461 ) by L608;
L655: C535 in (the carrier of D457) by GFACIRC1:132;
L656: C541 = ( D463 . C535 ) by L655 , L650 , L651 , FUNCT_1:47;
L657: C534 in (the carrier of D457) by GFACIRC1:132;
L658: C540 = ( D463 . C534 ) by L657 , L649 , L651 , FUNCT_1:47;
L659: D460 in (the carrier of D457) by GFACIRC1:132;
L660: ( ( Following (D464 , 2) ) . ( GFA3CarryOutput (C533 , C534 , C535) ) ) = ( ( Following (D463 , 2) ) . ( GFA3CarryOutput (C533 , C534 , C535) ) ) by L659 , L654 , FACIRC_1:32;
thus L661: ( ( Following (C538 , 2) ) . ( BitFTA3CarryOutput (C533 , C534 , C535 , C536 , C537) ) ) = ( 'not' ( ( ( ( 'not' C539 ) '&' ( 'not' C540 ) ) 'or' ( ( 'not' C540 ) '&' ( 'not' C541 ) ) ) 'or' ( ( 'not' C541 ) '&' ( 'not' C539 ) ) ) ) by L660 , L653 , L658 , L656 , GFACIRC1:135;
L662: D459 in (the carrier of D457) by GFACIRC1:132;
L663: ( ( Following (D464 , 2) ) . ( GFA3AdderOutput (C533 , C534 , C535) ) ) = ( ( Following (D463 , 2) ) . ( GFA3AdderOutput (C533 , C534 , C535) ) ) by L662 , L654 , FACIRC_1:32;
thus L664: thesis by L663 , L653 , L658 , L656 , GFACIRC1:135;
end;
theorem
L665: (for B515 , B516 , B517 , B518 being non  pair set holds (for B519 being set holds ((B519 <> [ <* B518 , ( GFA3AdderOutput (B515 , B516 , B517) ) *> , ( and2b ) ] & (not B519 in ( InnerVertices ( BitGFA3Str (B515 , B516 , B517) ) ))) implies (for B520 being (State of ( BitFTA3Circ (B515 , B516 , B517 , B518 , B519) )) holds (for B521 , B522 , B523 , B524 , B525 being (Element of ( BOOLEAN )) holds ((B521 = ( B520 . B515 ) & B522 = ( B520 . B516 ) & B523 = ( B520 . B517 ) & B524 = ( B520 . B518 ) & B525 = ( B520 . B519 )) implies (( ( Following (B520 , 2) ) . ( GFA3AdderOutput (B515 , B516 , B517) ) ) = ( 'not' ( ( ( 'not' B521 ) 'xor' ( 'not' B522 ) ) 'xor' ( 'not' B523 ) ) ) & ( ( Following (B520 , 2) ) . B515 ) = B521 & ( ( Following (B520 , 2) ) . B516 ) = B522 & ( ( Following (B520 , 2) ) . B517 ) = B523 & ( ( Following (B520 , 2) ) . B518 ) = B524 & ( ( Following (B520 , 2) ) . B519 ) = B525)))))))
proof
let C542 , C543 , C544 , C545 being non  pair set;
let C546 being set;
assume that
L666: (C546 <> [ <* C545 , ( GFA3AdderOutput (C542 , C543 , C544) ) *> , ( and2b ) ] & (not C546 in ( InnerVertices ( BitGFA3Str (C542 , C543 , C544) ) )));
set D465 = ( GFA3AdderOutput (C542 , C543 , C544) );
set D466 = ( BitGFA3Circ (C542 , C543 , C544) );
set D467 = ( BitGFA3Str (C542 , C543 , C544) );
set D468 = ( BitGFA3Str (D465 , C546 , C545) );
set D469 = ( BitGFA3Circ (D465 , C546 , C545) );
set D470 = ( BitFTA3Str (C542 , C543 , C544 , C545 , C546) );
let C547 being (State of ( BitFTA3Circ (C542 , C543 , C544 , C545 , C546) ));
let C548 , C549 , C550 , C551 , C552 being (Element of ( BOOLEAN ));
assume that
L667: C548 = ( C547 . C542 )
and
L668: C549 = ( C547 . C543 )
and
L669: C550 = ( C547 . C544 )
and
L670: C551 = ( C547 . C545 )
and
L671: C552 = ( C547 . C546 );
reconsider D471 = ( C547 | (the carrier of D467) ) as (State of D466) by FACIRC_1:26;
L672: ( dom D471 ) = (the carrier of D467) by CIRCUIT1:3;
L673: C545 in ( InputVertices D470 ) by L666 , L642;
L674: ( ( Following C547 ) . C545 ) = C551 by L673 , L670 , CIRCUIT2:def 5;
L675: C544 in ( InputVertices D470 ) by L666 , L642;
L676: ( ( Following C547 ) . C544 ) = C550 by L675 , L669 , CIRCUIT2:def 5;
L677: C543 in (the carrier of D467) by GFACIRC1:132;
L678: C549 = ( D471 . C543 ) by L677 , L668 , L672 , FUNCT_1:47;
reconsider D472 = C547 as (State of ( D466 +* D469 ));
L679: (D465 in (the carrier of D467) & ( InputVertices D467 ) misses ( InnerVertices D468 )) by L608 , GFACIRC1:132;
L680: ( ( Following (D472 , 2) ) . ( GFA3AdderOutput (C542 , C543 , C544) ) ) = ( ( Following (D471 , 2) ) . ( GFA3AdderOutput (C542 , C543 , C544) ) ) by L679 , FACIRC_1:32;
L681: C544 in (the carrier of D467) by GFACIRC1:132;
L682: C550 = ( D471 . C544 ) by L681 , L669 , L672 , FUNCT_1:47;
L683: C542 in (the carrier of D467) by GFACIRC1:132;
L684: C548 = ( D471 . C542 ) by L683 , L667 , L672 , FUNCT_1:47;
thus L685: ( ( Following (C547 , 2) ) . ( GFA3AdderOutput (C542 , C543 , C544) ) ) = ( 'not' ( ( ( 'not' C548 ) 'xor' ( 'not' C549 ) ) 'xor' ( 'not' C550 ) ) ) by L684 , L678 , L682 , L680 , GFACIRC1:135;
L686: C543 in ( InputVertices D470 ) by L666 , L642;
L687: ( ( Following C547 ) . C543 ) = C549 by L686 , L668 , CIRCUIT2:def 5;
L688: C546 in ( InputVertices D470 ) by L666 , L642;
L689: ( ( Following C547 ) . C546 ) = C552 by L688 , L671 , CIRCUIT2:def 5;
L690: C542 in ( InputVertices D470 ) by L666 , L642;
L691: (( Following (C547 , 2) ) = ( Following ( Following C547 ) ) & ( ( Following C547 ) . C542 ) = C548) by L690 , L667 , CIRCUIT2:def 5 , FACIRC_1:15;
thus L692: thesis by L691 , L690 , L686 , L675 , L673 , L688 , L687 , L676 , L674 , L689 , CIRCUIT2:def 5;
end;
L693: (for B526 , B527 , B528 , B529 being non  pair set holds (for B530 being set holds (for B531 being (State of ( BitFTA3Circ (B526 , B527 , B528 , B529 , B530) )) holds (for B532 , B533 , B534 being (Element of ( BOOLEAN )) holds ((B532 = ( B531 . ( GFA3AdderOutput (B526 , B527 , B528) ) ) & B533 = ( B531 . B529 ) & B534 = ( B531 . B530 )) implies (( ( Following B531 ) . [ <* ( GFA3AdderOutput (B526 , B527 , B528) ) , B530 *> , ( and2b ) ] ) = ( ( 'not' B532 ) '&' ( 'not' B534 ) ) & ( ( Following B531 ) . [ <* B530 , B529 *> , ( and2b ) ] ) = ( ( 'not' B534 ) '&' ( 'not' B533 ) ) & ( ( Following B531 ) . [ <* B529 , ( GFA3AdderOutput (B526 , B527 , B528) ) *> , ( and2b ) ] ) = ( ( 'not' B533 ) '&' ( 'not' B532 ) )))))))
proof
let C553 , C554 , C555 , C556 being non  pair set;
let C557 being set;
set D473 = ( BitFTA3Str (C553 , C554 , C555 , C556 , C557) );
set D474 = ( BitFTA3Circ (C553 , C554 , C555 , C556 , C557) );
set D475 = ( GFA3AdderOutput (C553 , C554 , C555) );
set D476 = [ <* D475 , C557 *> , ( and2b ) ];
set D477 = [ <* C557 , C556 *> , ( and2b ) ];
set D478 = [ <* C556 , D475 *> , ( and2b ) ];
let C558 being (State of D474);
let C559 , C560 , C561 being (Element of ( BOOLEAN ));
assume that
L694: C559 = ( C558 . D475 )
and
L695: C560 = ( C558 . C556 )
and
L696: C561 = ( C558 . C557 );
L697: ( dom C558 ) = (the carrier of D473) by CIRCUIT1:3;
L698: C557 in (the carrier of D473) by L622;
L699: D475 in (the carrier of D473) by L622;
L700: ( InnerVertices D473 ) = (the carrier' of D473) by FACIRC_1:37;
L701: D476 in (the carrier' of D473) by L700 , L633;
thus L702: ( ( Following C558 ) . D476 ) = ( ( and2b ) . ( C558 * <* D475 , C557 *> ) ) by L701 , FACIRC_1:35
.= ( ( and2b ) . <* C559 , C561 *> ) by L694 , L696 , L699 , L698 , L697 , FINSEQ_2:125
.= ( ( 'not' C559 ) '&' ( 'not' C561 ) ) by TWOSCOMP:def 3;
L703: C556 in (the carrier of D473) by L622;
L704: D477 in (the carrier' of D473) by L700 , L633;
thus L705: ( ( Following C558 ) . D477 ) = ( ( and2b ) . ( C558 * <* C557 , C556 *> ) ) by L704 , FACIRC_1:35
.= ( ( and2b ) . <* C561 , C560 *> ) by L695 , L696 , L703 , L698 , L697 , FINSEQ_2:125
.= ( ( 'not' C561 ) '&' ( 'not' C560 ) ) by TWOSCOMP:def 3;
L706: D478 in (the carrier' of D473) by L700 , L633;
thus L707: ( ( Following C558 ) . D478 ) = ( ( and2b ) . ( C558 * <* C556 , D475 *> ) ) by L706 , FACIRC_1:35
.= ( ( and2b ) . <* C560 , C559 *> ) by L694 , L695 , L699 , L703 , L697 , FINSEQ_2:125
.= ( ( 'not' C560 ) '&' ( 'not' C559 ) ) by TWOSCOMP:def 3;
end;
L708: (for B535 , B536 , B537 , B538 being non  pair set holds (for B539 being set holds (for B540 being (State of ( BitFTA3Circ (B535 , B536 , B537 , B538 , B539) )) holds (for B541 , B542 being (Element of ( BOOLEAN )) holds ((B541 = ( B540 . ( GFA3AdderOutput (B535 , B536 , B537) ) ) & B542 = ( B540 . B539 )) implies ( ( Following B540 ) . [ <* ( GFA3AdderOutput (B535 , B536 , B537) ) , B539 *> , ( xor2 ) ] ) = ( B541 'xor' B542 ))))))
proof
let C562 , C563 , C564 , C565 being non  pair set;
let C566 being set;
set D479 = ( BitFTA3Str (C562 , C563 , C564 , C565 , C566) );
set D480 = ( BitFTA3Circ (C562 , C563 , C564 , C565 , C566) );
set D481 = ( GFA3AdderOutput (C562 , C563 , C564) );
set D482 = [ <* D481 , C566 *> , ( xor2 ) ];
let C567 being (State of D480);
let C568 , C569 being (Element of ( BOOLEAN ));
assume that
L709: (C568 = ( C567 . D481 ) & C569 = ( C567 . C566 ));
L710: ( dom C567 ) = (the carrier of D479) by CIRCUIT1:3;
L711: (D481 in (the carrier of D479) & C566 in (the carrier of D479)) by L622;
L712: ( InnerVertices D479 ) = (the carrier' of D479) by FACIRC_1:37;
L713: D482 in (the carrier' of D479) by L712 , L633;
thus L714: ( ( Following C567 ) . D482 ) = ( ( xor2 ) . ( C567 * <* D481 , C566 *> ) ) by L713 , FACIRC_1:35
.= ( ( xor2 ) . <* C568 , C569 *> ) by L709 , L711 , L710 , FINSEQ_2:125
.= ( C568 'xor' C569 ) by TWOSCOMP:def 13;
end;
L715: (for B543 , B544 , B545 , B546 being non  pair set holds (for B547 being set holds ((B547 <> [ <* B546 , ( GFA3AdderOutput (B543 , B544 , B545) ) *> , ( and2b ) ] & (not B547 in ( InnerVertices ( BitGFA3Str (B543 , B544 , B545) ) ))) implies (for B548 being (State of ( BitFTA3Circ (B543 , B544 , B545 , B546 , B547) )) holds (for B549 , B550 , B551 , B552 , B553 being (Element of ( BOOLEAN )) holds ((B549 = ( B548 . B543 ) & B550 = ( B548 . B544 ) & B551 = ( B548 . B545 ) & B552 = ( B548 . B546 ) & B553 = ( B548 . B547 )) implies (( ( Following (B548 , 3) ) . [ <* ( GFA3AdderOutput (B543 , B544 , B545) ) , B547 *> , ( and2b ) ] ) = ( ( ( ( 'not' B549 ) 'xor' ( 'not' B550 ) ) 'xor' ( 'not' B551 ) ) '&' ( 'not' B553 ) ) & ( ( Following (B548 , 3) ) . [ <* B547 , B546 *> , ( and2b ) ] ) = ( ( 'not' B553 ) '&' ( 'not' B552 ) ) & ( ( Following (B548 , 3) ) . [ <* B546 , ( GFA3AdderOutput (B543 , B544 , B545) ) *> , ( and2b ) ] ) = ( ( 'not' B552 ) '&' ( ( ( 'not' B549 ) 'xor' ( 'not' B550 ) ) 'xor' ( 'not' B551 ) ) ) & ( ( Following (B548 , 3) ) . B543 ) = B549 & ( ( Following (B548 , 3) ) . B544 ) = B550 & ( ( Following (B548 , 3) ) . B545 ) = B551 & ( ( Following (B548 , 3) ) . B546 ) = B552 & ( ( Following (B548 , 3) ) . B547 ) = B553)))))))
proof
let C570 , C571 , C572 , C573 being non  pair set;
let C574 being set;
assume that
L716: (C574 <> [ <* C573 , ( GFA3AdderOutput (C570 , C571 , C572) ) *> , ( and2b ) ] & (not C574 in ( InnerVertices ( BitGFA3Str (C570 , C571 , C572) ) )));
set D483 = ( BitFTA3Str (C570 , C571 , C572 , C573 , C574) );
L717: (C570 in ( InputVertices D483 ) & C571 in ( InputVertices D483 )) by L716 , L642;
L718: (C572 in ( InputVertices D483 ) & C573 in ( InputVertices D483 )) by L716 , L642;
let C575 being (State of ( BitFTA3Circ (C570 , C571 , C572 , C573 , C574) ));
let C576 , C577 , C578 , C579 , C580 being (Element of ( BOOLEAN ));
assume that
L719: (C576 = ( C575 . C570 ) & C577 = ( C575 . C571 ) & C578 = ( C575 . C572 ) & C579 = ( C575 . C573 ) & C580 = ( C575 . C574 ));
L720: ( ( Following (C575 , 2) ) . C574 ) = C580 by L716 , L719 , L665;
set D484 = [ <* C574 , C573 *> , ( and2b ) ];
set D485 = ( GFA3AdderOutput (C570 , C571 , C572) );
set D486 = [ <* D485 , C574 *> , ( and2b ) ];
set D487 = [ <* C573 , D485 *> , ( and2b ) ];
L721: ( Following (C575 , ( 2 + 1 )) ) = ( Following ( Following (C575 , 2) ) ) by FACIRC_1:12;
L722: (( ( Following (C575 , 2) ) . D485 ) = ( 'not' ( ( ( 'not' C576 ) 'xor' ( 'not' C577 ) ) 'xor' ( 'not' C578 ) ) ) & ( ( Following (C575 , 2) ) . C573 ) = C579) by L716 , L719 , L665;
thus L723: (( ( Following (C575 , 3) ) . D486 ) = ( ( ( ( 'not' C576 ) 'xor' ( 'not' C577 ) ) 'xor' ( 'not' C578 ) ) '&' ( 'not' C580 ) ) & ( ( Following (C575 , 3) ) . D484 ) = ( ( 'not' C580 ) '&' ( 'not' C579 ) ) & ( ( Following (C575 , 3) ) . D487 ) = ( ( 'not' C579 ) '&' ( ( ( 'not' C576 ) 'xor' ( 'not' C577 ) ) 'xor' ( 'not' C578 ) ) )) by L722 , L721 , L720 , L693;
L724: (( ( Following (C575 , 2) ) . C572 ) = C578 & ( ( Following (C575 , 2) ) . C573 ) = C579) by L716 , L719 , L665;
L725: ( ( Following (C575 , 2) ) . C574 ) = C580 by L716 , L719 , L665;
L726: C574 in ( InputVertices D483 ) by L716 , L642;
L727: (( ( Following (C575 , 2) ) . C570 ) = C576 & ( ( Following (C575 , 2) ) . C571 ) = C577) by L716 , L719 , L665;
thus L728: thesis by L727 , L721 , L717 , L718 , L726 , L724 , L725 , CIRCUIT2:def 5;
end;
L729: (for B554 , B555 , B556 , B557 being non  pair set holds (for B558 being set holds ((B558 <> [ <* B557 , ( GFA3AdderOutput (B554 , B555 , B556) ) *> , ( and2b ) ] & (not B558 in ( InnerVertices ( BitGFA3Str (B554 , B555 , B556) ) ))) implies (for B559 being (State of ( BitFTA3Circ (B554 , B555 , B556 , B557 , B558) )) holds (for B560 , B561 , B562 , B563 , B564 being (Element of ( BOOLEAN )) holds ((B560 = ( B559 . B554 ) & B561 = ( B559 . B555 ) & B562 = ( B559 . B556 ) & B563 = ( B559 . B557 ) & B564 = ( B559 . B558 )) implies (( ( Following (B559 , 3) ) . [ <* ( GFA3AdderOutput (B554 , B555 , B556) ) , B558 *> , ( xor2 ) ] ) = ( ( 'not' ( ( ( 'not' B560 ) 'xor' ( 'not' B561 ) ) 'xor' ( 'not' B562 ) ) ) 'xor' B564 ) & ( ( Following (B559 , 3) ) . B554 ) = B560 & ( ( Following (B559 , 3) ) . B555 ) = B561 & ( ( Following (B559 , 3) ) . B556 ) = B562 & ( ( Following (B559 , 3) ) . B557 ) = B563 & ( ( Following (B559 , 3) ) . B558 ) = B564)))))))
proof
let C581 , C582 , C583 , C584 being non  pair set;
let C585 being set;
assume that
L730: (C585 <> [ <* C584 , ( GFA3AdderOutput (C581 , C582 , C583) ) *> , ( and2b ) ] & (not C585 in ( InnerVertices ( BitGFA3Str (C581 , C582 , C583) ) )));
set D488 = ( BitFTA3Str (C581 , C582 , C583 , C584 , C585) );
L731: (C581 in ( InputVertices D488 ) & C582 in ( InputVertices D488 )) by L730 , L642;
L732: (C583 in ( InputVertices D488 ) & C584 in ( InputVertices D488 )) by L730 , L642;
let C586 being (State of ( BitFTA3Circ (C581 , C582 , C583 , C584 , C585) ));
let C587 , C588 , C589 , C590 , C591 being (Element of ( BOOLEAN ));
assume that
L733: (C587 = ( C586 . C581 ) & C588 = ( C586 . C582 ) & C589 = ( C586 . C583 ) & C590 = ( C586 . C584 ) & C591 = ( C586 . C585 ));
L734: (( ( Following (C586 , 2) ) . C583 ) = C589 & ( ( Following (C586 , 2) ) . C584 ) = C590) by L730 , L733 , L665;
set D489 = ( GFA3AdderOutput (C581 , C582 , C583) );
set D490 = [ <* D489 , C585 *> , ( xor2 ) ];
L735: ( Following (C586 , ( 2 + 1 )) ) = ( Following ( Following (C586 , 2) ) ) by FACIRC_1:12;
L736: (( ( Following (C586 , 2) ) . D489 ) = ( 'not' ( ( ( 'not' C587 ) 'xor' ( 'not' C588 ) ) 'xor' ( 'not' C589 ) ) ) & ( ( Following (C586 , 2) ) . C585 ) = C591) by L730 , L733 , L665;
thus L737: ( ( Following (C586 , 3) ) . D490 ) = ( ( 'not' ( ( ( 'not' C587 ) 'xor' ( 'not' C588 ) ) 'xor' ( 'not' C589 ) ) ) 'xor' C591 ) by L736 , L735 , L708;
L738: ( ( Following (C586 , 2) ) . C585 ) = C591 by L730 , L733 , L665;
L739: C585 in ( InputVertices D488 ) by L730 , L642;
L740: (( ( Following (C586 , 2) ) . C581 ) = C587 & ( ( Following (C586 , 2) ) . C582 ) = C588) by L730 , L733 , L665;
thus L741: thesis by L740 , L735 , L731 , L732 , L739 , L734 , L738 , CIRCUIT2:def 5;
end;
L742: (for B565 , B566 , B567 , B568 being non  pair set holds (for B569 being set holds (for B570 being (State of ( BitFTA3Circ (B565 , B566 , B567 , B568 , B569) )) holds (for B571 , B572 , B573 being (Element of ( BOOLEAN )) holds ((B571 = ( B570 . [ <* ( GFA3AdderOutput (B565 , B566 , B567) ) , B569 *> , ( and2b ) ] ) & B572 = ( B570 . [ <* B569 , B568 *> , ( and2b ) ] ) & B573 = ( B570 . [ <* B568 , ( GFA3AdderOutput (B565 , B566 , B567) ) *> , ( and2b ) ] )) implies ( ( Following B570 ) . ( GFA3CarryOutput (( GFA3AdderOutput (B565 , B566 , B567) ) , B569 , B568) ) ) = ( 'not' ( ( B571 'or' B572 ) 'or' B573 ) ))))))
proof
let C592 , C593 , C594 , C595 being non  pair set;
let C596 being set;
set D491 = ( BitFTA3Str (C592 , C593 , C594 , C595 , C596) );
set D492 = ( BitFTA3Circ (C592 , C593 , C594 , C595 , C596) );
set D493 = ( GFA3AdderOutput (C592 , C593 , C594) );
set D494 = ( GFA3CarryOutput (D493 , C596 , C595) );
set D495 = [ <* D493 , C596 *> , ( and2b ) ];
set D496 = [ <* C596 , C595 *> , ( and2b ) ];
set D497 = [ <* C595 , D493 *> , ( and2b ) ];
let C597 being (State of D492);
let C598 , C599 , C600 being (Element of ( BOOLEAN ));
assume that
L743: (C598 = ( C597 . D495 ) & C599 = ( C597 . D496 ) & C600 = ( C597 . D497 ));
L744: (D495 in (the carrier of D491) & D496 in (the carrier of D491)) by L622;
L745: (D497 in (the carrier of D491) & ( dom C597 ) = (the carrier of D491)) by L622 , CIRCUIT1:3;
L746: ( InnerVertices D491 ) = (the carrier' of D491) by FACIRC_1:37;
L747: D494 in (the carrier' of D491) by L746 , L633;
thus L748: ( ( Following C597 ) . D494 ) = ( ( nor3 ) . ( C597 * <* D495 , D496 , D497 *> ) ) by L747 , FACIRC_1:35
.= ( ( nor3 ) . <* C598 , C599 , C600 *> ) by L743 , L744 , L745 , FINSEQ_2:126
.= ( 'not' ( ( C598 'or' C599 ) 'or' C600 ) ) by TWOSCOMP:def 28;
end;
L749: (for B574 , B575 , B576 , B577 being non  pair set holds (for B578 being set holds (for B579 being (State of ( BitFTA3Circ (B574 , B575 , B576 , B577 , B578) )) holds (for B580 , B581 being (Element of ( BOOLEAN )) holds ((B580 = ( B579 . [ <* ( GFA3AdderOutput (B574 , B575 , B576) ) , B578 *> , ( xor2 ) ] ) & B581 = ( B579 . B577 )) implies ( ( Following B579 ) . ( GFA3AdderOutput (( GFA3AdderOutput (B574 , B575 , B576) ) , B578 , B577) ) ) = ( B580 'xor' B581 ))))))
proof
let C601 , C602 , C603 , C604 being non  pair set;
let C605 being set;
set D498 = ( BitFTA3Str (C601 , C602 , C603 , C604 , C605) );
set D499 = ( BitFTA3Circ (C601 , C602 , C603 , C604 , C605) );
set D500 = ( GFA3AdderOutput (C601 , C602 , C603) );
set D501 = ( GFA3AdderOutput (D500 , C605 , C604) );
set D502 = [ <* D500 , C605 *> , ( xor2 ) ];
let C606 being (State of D499);
let C607 , C608 being (Element of ( BOOLEAN ));
assume that
L750: (C607 = ( C606 . D502 ) & C608 = ( C606 . C604 ));
L751: ( dom C606 ) = (the carrier of D498) by CIRCUIT1:3;
L752: (D502 in (the carrier of D498) & C604 in (the carrier of D498)) by L622;
L753: ( InnerVertices D498 ) = (the carrier' of D498) by FACIRC_1:37;
L754: D501 in (the carrier' of D498) by L753 , L633;
thus L755: ( ( Following C606 ) . D501 ) = ( ( xor2 ) . ( C606 * <* D502 , C604 *> ) ) by L754 , FACIRC_1:35
.= ( ( xor2 ) . <* C607 , C608 *> ) by L750 , L752 , L751 , FINSEQ_2:125
.= ( C607 'xor' C608 ) by TWOSCOMP:def 13;
end;
L756: (for B582 , B583 , B584 , B585 being non  pair set holds (for B586 being set holds ((B586 <> [ <* B585 , ( GFA3AdderOutput (B582 , B583 , B584) ) *> , ( and2b ) ] & (not B586 in ( InnerVertices ( BitGFA3Str (B582 , B583 , B584) ) ))) implies (for B587 being (State of ( BitFTA3Circ (B582 , B583 , B584 , B585 , B586) )) holds (for B588 , B589 , B590 , B591 , B592 being (Element of ( BOOLEAN )) holds ((B588 = ( B587 . B582 ) & B589 = ( B587 . B583 ) & B590 = ( B587 . B584 ) & B591 = ( B587 . B585 ) & B592 = ( B587 . B586 )) implies (( ( Following (B587 , 4) ) . ( GFA3CarryOutput (( GFA3AdderOutput (B582 , B583 , B584) ) , B586 , B585) ) ) = ( 'not' ( ( ( ( ( ( 'not' B588 ) 'xor' ( 'not' B589 ) ) 'xor' ( 'not' B590 ) ) '&' ( 'not' B592 ) ) 'or' ( ( 'not' B592 ) '&' ( 'not' B591 ) ) ) 'or' ( ( 'not' B591 ) '&' ( ( ( 'not' B588 ) 'xor' ( 'not' B589 ) ) 'xor' ( 'not' B590 ) ) ) ) ) & ( ( Following (B587 , 4) ) . B582 ) = B588 & ( ( Following (B587 , 4) ) . B583 ) = B589 & ( ( Following (B587 , 4) ) . B584 ) = B590 & ( ( Following (B587 , 4) ) . B585 ) = B591 & ( ( Following (B587 , 4) ) . B586 ) = B592)))))))
proof
let C609 , C610 , C611 , C612 being non  pair set;
let C613 being set;
assume that
L757: (C613 <> [ <* C612 , ( GFA3AdderOutput (C609 , C610 , C611) ) *> , ( and2b ) ] & (not C613 in ( InnerVertices ( BitGFA3Str (C609 , C610 , C611) ) )));
set D503 = ( BitFTA3Str (C609 , C610 , C611 , C612 , C613) );
L758: (C609 in ( InputVertices D503 ) & C610 in ( InputVertices D503 )) by L757 , L642;
L759: (C611 in ( InputVertices D503 ) & C612 in ( InputVertices D503 )) by L757 , L642;
set D504 = ( GFA3AdderOutput (C609 , C610 , C611) );
let C614 being (State of ( BitFTA3Circ (C609 , C610 , C611 , C612 , C613) ));
set D505 = [ <* C612 , D504 *> , ( and2b ) ];
let C615 , C616 , C617 , C618 , C619 being (Element of ( BOOLEAN ));
assume that
L760: (C615 = ( C614 . C609 ) & C616 = ( C614 . C610 ) & C617 = ( C614 . C611 ) & C618 = ( C614 . C612 ) & C619 = ( C614 . C613 ));
L761: ( ( Following (C614 , 3) ) . D505 ) = ( ( 'not' C618 ) '&' ( ( ( 'not' C615 ) 'xor' ( 'not' C616 ) ) 'xor' ( 'not' C617 ) ) ) by L757 , L760 , L715;
set D506 = [ <* C613 , C612 *> , ( and2b ) ];
set D507 = [ <* D504 , C613 *> , ( and2b ) ];
set D508 = ( GFA3CarryOutput (D504 , C613 , C612) );
L762: ( Following (C614 , ( 3 + 1 )) ) = ( Following ( Following (C614 , 3) ) ) by FACIRC_1:12;
L763: (( ( Following (C614 , 3) ) . D507 ) = ( ( ( ( 'not' C615 ) 'xor' ( 'not' C616 ) ) 'xor' ( 'not' C617 ) ) '&' ( 'not' C619 ) ) & ( ( Following (C614 , 3) ) . D506 ) = ( ( 'not' C619 ) '&' ( 'not' C618 ) )) by L757 , L760 , L715;
thus L764: ( ( Following (C614 , 4) ) . D508 ) = ( 'not' ( ( ( ( ( ( 'not' C615 ) 'xor' ( 'not' C616 ) ) 'xor' ( 'not' C617 ) ) '&' ( 'not' C619 ) ) 'or' ( ( 'not' C619 ) '&' ( 'not' C618 ) ) ) 'or' ( ( 'not' C618 ) '&' ( ( ( 'not' C615 ) 'xor' ( 'not' C616 ) ) 'xor' ( 'not' C617 ) ) ) ) ) by L763 , L762 , L761 , L742;
L765: (( ( Following (C614 , 3) ) . C611 ) = C617 & ( ( Following (C614 , 3) ) . C612 ) = C618) by L757 , L760 , L715;
L766: ( ( Following (C614 , 3) ) . C613 ) = C619 by L757 , L760 , L715;
L767: C613 in ( InputVertices D503 ) by L757 , L642;
L768: (( ( Following (C614 , 3) ) . C609 ) = C615 & ( ( Following (C614 , 3) ) . C610 ) = C616) by L757 , L760 , L715;
thus L769: thesis by L768 , L762 , L758 , L759 , L767 , L765 , L766 , CIRCUIT2:def 5;
end;
L770: (for B593 , B594 , B595 , B596 being non  pair set holds (for B597 being set holds ((B597 <> [ <* B596 , ( GFA3AdderOutput (B593 , B594 , B595) ) *> , ( and2b ) ] & (not B597 in ( InnerVertices ( BitGFA3Str (B593 , B594 , B595) ) ))) implies (for B598 being (State of ( BitFTA3Circ (B593 , B594 , B595 , B596 , B597) )) holds (for B599 , B600 , B601 , B602 , B603 being (Element of ( BOOLEAN )) holds ((B599 = ( B598 . B593 ) & B600 = ( B598 . B594 ) & B601 = ( B598 . B595 ) & B602 = ( B598 . B596 ) & B603 = ( B598 . B597 )) implies (( ( Following (B598 , 4) ) . ( GFA3AdderOutput (( GFA3AdderOutput (B593 , B594 , B595) ) , B597 , B596) ) ) = ( 'not' ( ( ( ( ( 'not' B599 ) 'xor' ( 'not' B600 ) ) 'xor' ( 'not' B601 ) ) 'xor' ( 'not' B602 ) ) 'xor' ( 'not' B603 ) ) ) & ( ( Following (B598 , 4) ) . B593 ) = B599 & ( ( Following (B598 , 4) ) . B594 ) = B600 & ( ( Following (B598 , 4) ) . B595 ) = B601 & ( ( Following (B598 , 4) ) . B596 ) = B602 & ( ( Following (B598 , 4) ) . B597 ) = B603)))))))
proof
let C620 , C621 , C622 , C623 being non  pair set;
let C624 being set;
assume that
L771: (C624 <> [ <* C623 , ( GFA3AdderOutput (C620 , C621 , C622) ) *> , ( and2b ) ] & (not C624 in ( InnerVertices ( BitGFA3Str (C620 , C621 , C622) ) )));
set D509 = ( BitFTA3Str (C620 , C621 , C622 , C623 , C624) );
L772: (C620 in ( InputVertices D509 ) & C621 in ( InputVertices D509 )) by L771 , L642;
L773: (C622 in ( InputVertices D509 ) & C623 in ( InputVertices D509 )) by L771 , L642;
let C625 being (State of ( BitFTA3Circ (C620 , C621 , C622 , C623 , C624) ));
let C626 , C627 , C628 , C629 , C630 being (Element of ( BOOLEAN ));
assume that
L774: (C626 = ( C625 . C620 ) & C627 = ( C625 . C621 ) & C628 = ( C625 . C622 ) & C629 = ( C625 . C623 ) & C630 = ( C625 . C624 ));
L775: (( ( Following (C625 , 3) ) . C622 ) = C628 & ( ( Following (C625 , 3) ) . C623 ) = C629) by L771 , L774 , L729;
set D510 = ( GFA3AdderOutput (C620 , C621 , C622) );
set D511 = ( GFA3AdderOutput (D510 , C624 , C623) );
set D512 = [ <* D510 , C624 *> , ( xor2 ) ];
L776: ( Following (C625 , ( 3 + 1 )) ) = ( Following ( Following (C625 , 3) ) ) by FACIRC_1:12;
L777: (( ( Following (C625 , 3) ) . D512 ) = ( ( 'not' ( ( ( 'not' C626 ) 'xor' ( 'not' C627 ) ) 'xor' ( 'not' C628 ) ) ) 'xor' C630 ) & ( ( Following (C625 , 3) ) . C623 ) = C629) by L771 , L774 , L729;
thus L778: ( ( Following (C625 , 4) ) . D511 ) = ( ( ( 'not' ( ( ( 'not' C626 ) 'xor' ( 'not' C627 ) ) 'xor' ( 'not' C628 ) ) ) 'xor' C630 ) 'xor' C629 ) by L777 , L776 , L749
.= ( 'not' ( ( ( ( ( 'not' C626 ) 'xor' ( 'not' C627 ) ) 'xor' ( 'not' C628 ) ) 'xor' ( 'not' C630 ) ) 'xor' ( 'not' C629 ) ) ) by XBOOLEAN:74
.= ( 'not' ( ( ( ( ( 'not' C626 ) 'xor' ( 'not' C627 ) ) 'xor' ( 'not' C628 ) ) 'xor' ( 'not' C629 ) ) 'xor' ( 'not' C630 ) ) ) by XBOOLEAN:73;
L779: ( ( Following (C625 , 3) ) . C624 ) = C630 by L771 , L774 , L729;
L780: C624 in ( InputVertices D509 ) by L771 , L642;
L781: (( ( Following (C625 , 3) ) . C620 ) = C626 & ( ( Following (C625 , 3) ) . C621 ) = C627) by L771 , L774 , L729;
thus L782: thesis by L781 , L776 , L772 , L773 , L780 , L775 , L779 , CIRCUIT2:def 5;
end;
theorem
L783: (for B604 , B605 , B606 , B607 being non  pair set holds (for B608 being set holds ((B608 <> [ <* B607 , ( GFA3AdderOutput (B604 , B605 , B606) ) *> , ( and2b ) ] & (not B608 in ( InnerVertices ( BitGFA3Str (B604 , B605 , B606) ) ))) implies (for B609 being (State of ( BitFTA3Circ (B604 , B605 , B606 , B607 , B608) )) holds (for B610 , B611 , B612 , B613 , B614 being (Element of ( BOOLEAN )) holds ((B610 = ( B609 . B604 ) & B611 = ( B609 . B605 ) & B612 = ( B609 . B606 ) & B613 = ( B609 . B607 ) & B614 = ( B609 . B608 )) implies (( ( Following (B609 , 4) ) . ( BitFTA3AdderOutputP (B604 , B605 , B606 , B607 , B608) ) ) = ( 'not' ( ( ( ( ( ( 'not' B610 ) 'xor' ( 'not' B611 ) ) 'xor' ( 'not' B612 ) ) '&' ( 'not' B614 ) ) 'or' ( ( 'not' B614 ) '&' ( 'not' B613 ) ) ) 'or' ( ( 'not' B613 ) '&' ( ( ( 'not' B610 ) 'xor' ( 'not' B611 ) ) 'xor' ( 'not' B612 ) ) ) ) ) & ( ( Following (B609 , 4) ) . ( BitFTA3AdderOutputQ (B604 , B605 , B606 , B607 , B608) ) ) = ( 'not' ( ( ( ( ( 'not' B610 ) 'xor' ( 'not' B611 ) ) 'xor' ( 'not' B612 ) ) 'xor' ( 'not' B613 ) ) 'xor' ( 'not' B614 ) ) )))))))) by L756 , L770;
theorem
L784: (for B615 , B616 , B617 , B618 being non  pair set holds (for B619 being set holds (B619 <> [ <* B618 , ( GFA3AdderOutput (B615 , B616 , B617) ) *> , ( and2b ) ] implies (for B620 being (State of ( BitFTA3Circ (B615 , B616 , B617 , B618 , B619) )) holds ( Following (B620 , 4) ) is  stable))))
proof
set D513 = 2;
set D514 = 2;
let C631 , C632 , C633 , C634 being non  pair set;
let C635 being set;
set D515 = ( BitFTA3Circ (C631 , C632 , C633 , C634 , C635) );
set D516 = ( BitGFA3Str (C631 , C632 , C633) );
set D517 = ( BitGFA3Circ (C631 , C632 , C633) );
set D518 = ( GFA3AdderOutput (C631 , C632 , C633) );
set D519 = ( BitGFA3Str (D518 , C635 , C634) );
set D520 = ( BitGFA3Circ (D518 , C635 , C634) );
set D521 = [ <* C635 , C634 *> , ( and2b ) ];
set D522 = [ <* C634 , D518 *> , ( and2b ) ];
assume L785: C635 <> D522;
let C636 being (State of D515);
L786: D517 tolerates D520 by CIRCCOMB:60;
L787: (the Sorts of D517) tolerates (the Sorts of D520) by L786 , CIRCCOMB:def 3;
reconsider D523 = ( C636 | (the carrier of D516) ) as (State of D517) by L787 , CIRCCOMB:26;
reconsider D524 = ( ( Following (C636 , D513) ) | (the carrier of D519) ) as (State of D520) by L787 , CIRCCOMB:26;
L788: (( InputVertices D516 ) misses ( InnerVertices D519 ) & ( Following (D523 , D513) ) is  stable) by L608 , GFACIRC1:136;
L789: D518 <> D521 by L602;
L790: ( Following (D524 , D514) ) is  stable by L789 , L785 , GFACIRC1:136;
L791: ( Following (C636 , ( D513 + D514 )) ) is  stable by L790 , L788 , CIRCCMB2:19 , CIRCCOMB:60;
thus L792: thesis by L791;
end;
