:: Algebraic group on Fixed-length bit integer and its adaptation
::  to {IDEA} Cryptography
::  by Yasushi Fuwa and Yoshinori Fujisawa
::
:: Received September 7, 1998
:: Copyright (c) 1998-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, FINSEQ_2, MARGREL1, CARD_1, ARYTM_3, INT_2,
      NAT_1, RELAT_1, XXREAL_0, INT_1, ARYTM_1, GRCAT_1, XBOOLEAN, FINSEQ_1,
      PARTFUN1, FUNCT_1, POWER, BINARI_3, FUNCOP_1, XBOOLE_0, BINARITH,
      MATRIX_1, INCSP_1, ORDINAL4, FUNCT_7, FUNCT_2, TARSKI, TREES_1, IDEA_1;
 notations TARSKI, XBOOLE_0,
      XTUPLE_0, SUBSET_1, NUMBERS, XCMPLX_0, INT_1, INT_2,
      ORDINAL1, NAT_1, NAT_D, MARGREL1, RELAT_1, FUNCT_1, FUNCOP_1, MATRIX_1,
      PARTFUN1, FUNCT_2, FUNCT_7, SERIES_1, FINSEQ_1, FINSEQ_2, RECDEF_1,
      BINARITH, BINARI_3, XXREAL_0;
 constructors NAT_D, SERIES_1, BINARITH, FUNCT_7, MATRIX_1, BINARI_3, RECDEF_1,
      RELSET_1, XTUPLE_0;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, FUNCT_2, XXREAL_0,
      XREAL_0, NAT_1, INT_1, FINSEQ_1, MARGREL1, FUNCT_7, VALUED_0, CARD_1,
      FINSEQ_2, RELSET_1, XTUPLE_0;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FINSEQ_2, XBOOLEAN, XTUPLE_0;
 theorems NAT_1, NAT_2, NEWTON, INT_1, INT_2, FINSEQ_1, FINSEQ_2, FUNCT_1,
      FUNCT_2, FUNCT_7, FUNCOP_1, POWER, EULER_1, EULER_2, BINARITH, BINARI_3,
      MATRIX_1, RELSET_1, RELAT_1, XBOOLE_1, XREAL_1, XXREAL_0, XBOOLEAN,
      NAT_D, PARTFUN1, ORDINAL1, XREAL_0, CARD_1;
 schemes FINSEQ_1, FINSEQ_2, NAT_1, FUNCT_2;

begin
L1: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds ((R1 <> ( 0 ) & R1 < R2 & R2 is  prime) implies R1 , R2 are_relative_prime )))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
assume that
L2: R1 <> ( 0 )
and
L3: R1 < R2
and
L4: R2 is  prime;
L5:
now
set D1 = ( R1 gcd R2 );
L6: D1 <> R2
proof
assume L7: D1 = R2;
L8: R2 divides R1 by L7 , NAT_D:def 5;
consider C1 being Nat such that L9: R1 = ( R2 * C1 ) by L8 , NAT_D:def 3;
L10: C1 <> ( 0 ) by L2 , L9;
L11: ( R2 * C1 ) >= ( R2 * 1 ) by L10 , NAT_1:14 , XREAL_1:64;
thus L12: contradiction by L11 , L3 , L9;
end;
L13: D1 divides R2 by NAT_D:def 5;
L14: (D1 = 1 or D1 = R2) by L13 , L4 , INT_2:def 4;
thus L15: thesis by L14 , L6 , INT_2:def 3;
end;
thus L16: thesis by L5;
end;
L17: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R3 being (Element of ( NAT )) holds ((R2 is  prime & R1 < R2 & R3 < R2 & R1 <> ( 0 )) implies (ex B1 being (Element of ( NAT )) st ( ( B1 * R1 ) mod R2 ) = R3)))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R3 being (Element of ( NAT ));
assume that
L18: R2 is  prime
and
L19: R1 < R2
and
L20: R3 < R2
and
L21: R1 <> ( 0 );
consider C2 , C3 being Integer such that L22: ( ( C2 * R1 ) + ( C3 * R2 ) ) = R3 by L18 , L19 , L21 , L1 , EULER_1:10;
L23: R2 > ( 0 ) by L18 , INT_2:def 4;
L24:
now
per cases ;
suppose L25: C2 >= ( 0 );

L26:
now
per cases ;
suppose L27: C3 >= ( 0 );

reconsider D2 = C2 , D3 = C3 as (Element of ( NAT )) by L27 , L25 , INT_1:3;
take D4 = D2;
L28: ( ( ( D4 * R1 ) + ( D3 * R2 ) ) mod R2 ) = ( ( ( D4 * R1 ) + ( ( D3 * R2 ) mod R2 ) ) mod R2 ) by NAT_D:23
.= ( ( ( D4 * R1 ) + ( 0 ) ) mod R2 ) by NAT_D:13
.= ( ( D4 * R1 ) mod R2 );
thus L29: thesis by L28 , L20 , L22 , NAT_D:24;
end;
suppose L30: C3 < ( 0 );

reconsider D5 = C2 as (Element of ( NAT )) by L25 , INT_1:3;
consider C4 being Integer such that L31: C4 = ( ( 0 ) - C3 );
take D6 = D5;
reconsider D7 = C4 as (Element of ( NAT )) by L30 , L31 , INT_1:3;
L32: ( ( ( D6 * R1 ) + ( C3 * R2 ) ) + ( D7 * R2 ) ) = ( D6 * R1 ) by L31;
L33: ( ( D6 * R1 ) mod R2 ) = ( R3 mod R2 ) by L32 , L22 , NAT_D:21
.= R3 by L20 , NAT_D:24;
thus L34: thesis by L33;
end;
end;
thus L36: thesis by L26;
end;
suppose L37: C2 < ( 0 );

consider C5 being Integer such that L38: C5 = ( ( 0 ) - C2 );
reconsider D8 = C5 as (Element of ( NAT )) by L37 , L38 , INT_1:3;
consider C6 being (Element of ( NAT )) such that L39: C6 = ( ( D8 div R2 ) + 1 );
consider C7 being Integer such that L40: C7 = ( C2 + ( C6 * R2 ) );
L41: C7 = ( ( ( - D8 ) + ( ( D8 div R2 ) * R2 ) ) + R2 ) by L38 , L39 , L40;
consider C8 being Nat such that L42: D8 = ( ( R2 * ( D8 div R2 ) ) + C8 ) and L43: C8 < R2 by L23 , NAT_D:def 1;
L44: ( ( - C8 ) + C8 ) < ( ( - C8 ) + R2 ) by L43 , XREAL_1:6;
reconsider D9 = C7 as (Element of ( NAT )) by L44 , L41 , L42 , INT_1:3;
L45:
now
per cases ;
suppose L46: C3 >= ( 0 );

reconsider D10 = C3 as (Element of ( NAT )) by L46 , INT_1:3;
take D11 = D9;
L47: ( ( R3 + ( ( C6 * R2 ) * R1 ) ) mod R2 ) = ( ( R3 + ( ( C6 * R1 ) * R2 ) ) mod R2 )
.= ( R3 mod R2 ) by NAT_D:21
.= R3 by L20 , NAT_D:24;
L48: ( ( ( C2 * R1 ) + ( D10 * R2 ) ) + ( ( C6 * R2 ) * R1 ) ) = ( ( D11 * R1 ) + ( D10 * R2 ) ) by L40;
thus L49: ( ( D11 * R1 ) mod R2 ) = R3 by L48 , L22 , L47 , NAT_D:21;
end;
suppose L50: C3 < ( 0 );

take D12 = D9;
consider C9 being Integer such that L51: C9 = ( ( 0 ) - C3 );
reconsider D13 = C9 as (Element of ( NAT )) by L50 , L51 , INT_1:3;
L52: ( ( R3 + ( ( C6 * R2 ) * R1 ) ) + ( D13 * R2 ) ) = ( R3 + ( ( ( C6 * R1 ) + D13 ) * R2 ) );
thus L53: ( ( D12 * R1 ) mod R2 ) = ( R3 mod R2 ) by L52 , L22 , L40 , L51 , NAT_D:21
.= R3 by L20 , NAT_D:24;
end;
end;
thus L55: thesis by L45;
end;
end;
thus L57: thesis by L24;
end;
theorem
L58: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R3 being (Element of ( NAT )) holds ((R2 is  prime & R1 < R2 & R3 < R2 & R1 <> ( 0 )) implies (ex B2 being (Element of ( NAT )) st (( ( B2 * R1 ) mod R2 ) = R3 & B2 < R2))))))
proof
let C10 , C11 , C12 being (Element of ( NAT ));
assume that
L59: C11 is  prime
and
L60: C10 < C11
and
L61: (C12 < C11 & C10 <> ( 0 ));
consider C13 being (Element of ( NAT )) such that L62: ( ( C13 * C10 ) mod C11 ) = C12 by L59 , L60 , L61 , L17;
consider C14 being (Element of ( NAT )) such that L63: C14 = ( C13 mod C11 );
take C14;
thus L64: thesis by L60 , L62 , L63 , EULER_2:8 , NAT_D:1;
end;
theorem
L65: (for B3 , B4 , B5 being (Element of ( NAT )) holds ((B3 <> ( 0 ) & ( B4 mod B3 ) = ( B5 mod B3 ) & B4 <= B5) implies (ex B6 being (Element of ( NAT )) st ( B5 - B4 ) = ( B3 * B6 ))))
proof
let C15 , C16 , C17 being (Element of ( NAT ));
assume that
L66: C15 <> ( 0 )
and
L67: ( C16 mod C15 ) = ( C17 mod C15 )
and
L68: C16 <= C17;
consider C18 being Integer such that L69: C18 = ( ( C17 div C15 ) - ( C16 div C15 ) );
L70: ( C17 div C15 ) >= ( C16 div C15 ) by L68 , NAT_2:24;
L71: ( ( C17 div C15 ) - ( C16 div C15 ) ) >= ( ( C16 div C15 ) - ( C16 div C15 ) ) by L70 , XREAL_1:9;
reconsider D14 = C18 as (Element of ( NAT )) by L71 , L69 , INT_1:3;
take D14;
L72: (C16 = ( ( C15 * ( C16 div C15 ) ) + ( C16 mod C15 ) ) & C17 = ( ( C15 * ( C17 div C15 ) ) + ( C17 mod C15 ) )) by L66 , NAT_D:2;
thus L73: thesis by L72 , L67 , L69;
end;
theorem
L74: (for B7 , B8 being (Element of ( NAT )) holds ( B7 - B8 ) <= B7)
proof
let C19 , C20 being (Element of ( NAT ));
L75: ( C19 - C20 ) <= ( C19 - ( 0 ) ) by XREAL_1:13;
thus L76: thesis by L75;
end;
theorem
L77: (for B9 , B10 , B11 being (Element of ( NAT )) holds (B10 <= B11 implies ( B10 - B9 ) <= B11))
proof
let C21 , C22 , C23 being (Element of ( NAT ));
assume L78: C22 <= C23;
L79: ( C22 - C21 ) <= ( C23 - C21 ) by L78 , XREAL_1:9;
L80: ( C23 - C21 ) <= C23 by L74;
thus L81: thesis by L80 , L79 , XXREAL_0:2;
end;
theorem
L82: (for B12 , B13 , B14 being (Element of ( NAT )) holds ((( 0 ) < B12 & ( 0 ) < B13 & B12 < B14 & B13 < B14 & B14 is  prime) implies ( ( B12 * B13 ) mod B14 ) <> ( 0 )))
proof
let C24 , C25 , C26 being (Element of ( NAT ));
assume that
L83: (( 0 ) < C24 & ( 0 ) < C25)
and
L84: C24 < C26
and
L85: C25 < C26
and
L86: C26 is  prime;
assume L87: ( ( C24 * C25 ) mod C26 ) = ( 0 );
L88: ( C24 * C25 ) = ( ( C26 * ( ( C24 * C25 ) div C26 ) ) + ( 0 ) ) by L87 , L84 , NAT_D:2;
L89: C26 divides ( C24 * C25 ) by L88 , NAT_D:def 3;
L90: (C26 divides C24 or C26 divides C25) by L89 , L86 , NEWTON:80;
thus L91: contradiction by L90 , L83 , L84 , L85 , NAT_D:7;
end;
begin
definition
let R4 being (Element of ( NAT ));
func ZERO R4 -> (Tuple of R4 , ( BOOLEAN )) equals 
( R4 |-> ( FALSE ) );
correctness;
end;
definition
let R4 being (Element of ( NAT ));
let C27 , C28 being (Tuple of R4 , ( BOOLEAN ));
func C27 'xor' C28 -> (Tuple of R4 , ( BOOLEAN )) means 
:L93: (for R1 being (Element of ( NAT )) holds (R1 in ( Seg R4 ) implies ( it /. R1 ) = ( ( C27 /. R1 ) 'xor' ( C28 /. R1 ) )));
existence
proof
deffunc H1(Nat) = ( ( C27 /. $1 ) 'xor' ( C28 /. $1 ) );
consider C29 being (FinSequence of ( BOOLEAN )) such that L94: ( len C29 ) = R4 and L95: (for B15 being Nat holds (B15 in ( dom C29 ) implies ( C29 . B15 ) = H1(B15))) from FINSEQ_2:sch 1;
L96: ( dom C29 ) = ( Seg R4 ) by L94 , FINSEQ_1:def 3;
L97: C29 is (Element of ( R4 -tuples_on ( BOOLEAN ) )) by L94 , FINSEQ_2:92;
reconsider D15 = C29 as (Tuple of R4 , ( BOOLEAN )) by L97;
take D15;
let R1 being (Element of ( NAT ));
assume L98: R1 in ( Seg R4 );
L99: R1 in ( dom D15 ) by L98 , L94 , FINSEQ_1:def 3;
thus L100: ( D15 /. R1 ) = ( D15 . R1 ) by L99 , PARTFUN1:def 6
.= ( ( C27 /. R1 ) 'xor' ( C28 /. R1 ) ) by L95 , L96 , L98;
end;
uniqueness
proof
let C30 , C31 being (Tuple of R4 , ( BOOLEAN ));
assume that
L101: (for R1 being (Element of ( NAT )) holds (R1 in ( Seg R4 ) implies ( C30 /. R1 ) = ( ( C27 /. R1 ) 'xor' ( C28 /. R1 ) )))
and
L102: (for R1 being (Element of ( NAT )) holds (R1 in ( Seg R4 ) implies ( C31 /. R1 ) = ( ( C27 /. R1 ) 'xor' ( C28 /. R1 ) )));
L103: ( len C30 ) = R4 by CARD_1:def 7;
L104: ( dom C30 ) = ( Seg R4 ) by L103 , FINSEQ_1:def 3;
L105: ( len C31 ) = R4 by CARD_1:def 7;
L106:
now
let C32 being Nat;
assume L107: C32 in ( dom C30 );
L108: C32 in ( dom C31 ) by L107 , L105 , L104 , FINSEQ_1:def 3;
thus L109: ( C30 . C32 ) = ( C30 /. C32 ) by L107 , PARTFUN1:def 6
.= ( ( C27 /. C32 ) 'xor' ( C28 /. C32 ) ) by L101 , L104 , L107
.= ( C31 /. C32 ) by L102 , L104 , L107
.= ( C31 . C32 ) by L108 , PARTFUN1:def 6;
end;
thus L110: thesis by L106 , L103 , L105 , FINSEQ_2:9;
end;
end;
theorem
L112: (for R4 being (Element of ( NAT )) holds (for R5 being (Tuple of R4 , ( BOOLEAN )) holds ( R5 'xor' R5 ) = ( ZERO R4 )))
proof
let R4 being (Element of ( NAT ));
let C33 being (Tuple of R4 , ( BOOLEAN ));
L113: ( len ( C33 'xor' C33 ) ) = R4 by CARD_1:def 7;
L114: ( dom ( C33 'xor' C33 ) ) = ( Seg R4 ) by L113 , FINSEQ_1:def 3;
L115:
now
let C34 being Nat;
assume L116: C34 in ( dom ( C33 'xor' C33 ) );
L117: ( ( ZERO R4 ) . C34 ) = ( FALSE );
thus L118: ( ( C33 'xor' C33 ) . C34 ) = ( ( C33 'xor' C33 ) /. C34 ) by L116 , PARTFUN1:def 6
.= ( ( C33 /. C34 ) 'xor' ( C33 /. C34 ) ) by L114 , L116 , L93
.= ( ( ZERO R4 ) . C34 ) by L117 , XBOOLEAN:138;
end;
L119: ( len ( ZERO R4 ) ) = R4 by CARD_1:def 7;
thus L120: thesis by L119 , L113 , L115 , FINSEQ_2:9;
end;
theorem
L121: (for R4 being (Element of ( NAT )) holds (for R5 being (Tuple of R4 , ( BOOLEAN )) holds (for R6 being (Tuple of R4 , ( BOOLEAN )) holds ( R5 'xor' R6 ) = ( R6 'xor' R5 ))))
proof
let R4 being (Element of ( NAT ));
let C35 , C36 being (Tuple of R4 , ( BOOLEAN ));
L122: ( len ( C35 'xor' C36 ) ) = R4 by CARD_1:def 7;
L123: ( dom ( C35 'xor' C36 ) ) = ( Seg R4 ) by L122 , FINSEQ_1:def 3;
L124: ( len ( C36 'xor' C35 ) ) = R4 by CARD_1:def 7;
L125:
now
let C37 being Nat;
assume L126: C37 in ( dom ( C35 'xor' C36 ) );
L127: C37 in ( dom ( C36 'xor' C35 ) ) by L126 , L124 , L123 , FINSEQ_1:def 3;
thus L128: ( ( C35 'xor' C36 ) . C37 ) = ( ( C35 'xor' C36 ) /. C37 ) by L126 , PARTFUN1:def 6
.= ( ( C36 /. C37 ) 'xor' ( C35 /. C37 ) ) by L123 , L126 , L93
.= ( ( C36 'xor' C35 ) /. C37 ) by L123 , L126 , L93
.= ( ( C36 'xor' C35 ) . C37 ) by L127 , PARTFUN1:def 6;
end;
thus L129: thesis by L125 , L122 , L124 , FINSEQ_2:9;
end;
definition
let R4 being (Element of ( NAT ));
let C38 , C39 being (Tuple of R4 , ( BOOLEAN ));
redefine func C38 'xor' C39;

commutativity
 by L121;
end;
theorem
L131: (for R4 being (Element of ( NAT )) holds (for R5 being (Tuple of R4 , ( BOOLEAN )) holds ( ( ZERO R4 ) 'xor' R5 ) = R5))
proof
let R4 being (Element of ( NAT ));
let C40 being (Tuple of R4 , ( BOOLEAN ));
L132: ( len ( ( ZERO R4 ) 'xor' C40 ) ) = R4 by CARD_1:def 7;
L133: ( dom ( ( ZERO R4 ) 'xor' C40 ) ) = ( Seg R4 ) by L132 , FINSEQ_1:def 3;
L134: ( len C40 ) = R4 by CARD_1:def 7;
L135:
now
let C41 being Nat;
assume L136: C41 in ( dom ( ( ZERO R4 ) 'xor' C40 ) );
L137: C41 in ( dom C40 ) by L136 , L134 , L133 , FINSEQ_1:def 3;
L138: C41 in ( dom ( ZERO R4 ) ) by L133 , L136 , FUNCOP_1:13;
L139: ( ( ZERO R4 ) /. C41 ) = ( ( R4 |-> ( FALSE ) ) . C41 ) by L138 , PARTFUN1:def 6
.= ( FALSE );
thus L140: ( ( ( ZERO R4 ) 'xor' C40 ) . C41 ) = ( ( ( ZERO R4 ) 'xor' C40 ) /. C41 ) by L136 , PARTFUN1:def 6
.= ( ( FALSE ) 'xor' ( C40 /. C41 ) ) by L133 , L136 , L139 , L93
.= ( C40 /. C41 ) by BINARITH:8
.= ( C40 . C41 ) by L137 , PARTFUN1:def 6;
end;
thus L141: thesis by L135 , L132 , L134 , FINSEQ_2:9;
end;
theorem
L142: (for R4 being (Element of ( NAT )) holds (for R5 being (Tuple of R4 , ( BOOLEAN )) holds (for R6 being (Tuple of R4 , ( BOOLEAN )) holds (for R7 being (Tuple of R4 , ( BOOLEAN )) holds ( ( R5 'xor' R6 ) 'xor' R7 ) = ( R5 'xor' ( R6 'xor' R7 ) )))))
proof
let R4 being (Element of ( NAT ));
let C42 , C43 , C44 being (Tuple of R4 , ( BOOLEAN ));
L143: ( len ( ( C42 'xor' C43 ) 'xor' C44 ) ) = R4 by CARD_1:def 7;
L144: ( dom ( ( C42 'xor' C43 ) 'xor' C44 ) ) = ( Seg R4 ) by L143 , FINSEQ_1:def 3;
L145: ( len ( C42 'xor' ( C43 'xor' C44 ) ) ) = R4 by CARD_1:def 7;
L146:
now
let C45 being Nat;
assume L147: C45 in ( dom ( ( C42 'xor' C43 ) 'xor' C44 ) );
L148: C45 in ( dom ( C42 'xor' ( C43 'xor' C44 ) ) ) by L147 , L145 , L144 , FINSEQ_1:def 3;
thus L149: ( ( ( C42 'xor' C43 ) 'xor' C44 ) . C45 ) = ( ( ( C42 'xor' C43 ) 'xor' C44 ) /. C45 ) by L147 , PARTFUN1:def 6
.= ( ( ( C42 'xor' C43 ) /. C45 ) 'xor' ( C44 /. C45 ) ) by L144 , L147 , L93
.= ( ( ( C42 /. C45 ) 'xor' ( C43 /. C45 ) ) 'xor' ( C44 /. C45 ) ) by L144 , L147 , L93
.= ( ( C42 /. C45 ) 'xor' ( ( C43 /. C45 ) 'xor' ( C44 /. C45 ) ) ) by XBOOLEAN:73
.= ( ( C42 /. C45 ) 'xor' ( ( C43 'xor' C44 ) /. C45 ) ) by L144 , L147 , L93
.= ( ( C42 'xor' ( C43 'xor' C44 ) ) /. C45 ) by L144 , L147 , L93
.= ( ( C42 'xor' ( C43 'xor' C44 ) ) . C45 ) by L148 , PARTFUN1:def 6;
end;
thus L150: thesis by L146 , L143 , L145 , FINSEQ_2:9;
end;
definition
let R4 being (Element of ( NAT ));
let C46 being (Element of ( NAT ));
pred C46 is_expressible_by R4
means
:L151: C46 < ( 2 to_power R4 )
;end;
theorem
L153: (for R4 being (Element of ( NAT )) holds ( R4 -BinarySequence ( 0 ) ) = ( ZERO R4 ))
proof
let R4 being (Element of ( NAT ));
L154: ( len ( R4 -BinarySequence ( 0 ) ) ) = R4 by CARD_1:def 7;
L155: ( dom ( R4 -BinarySequence ( 0 ) ) ) = ( Seg R4 ) by L154 , FINSEQ_1:def 3;
L156: ( len ( ZERO R4 ) ) = R4 by CARD_1:def 7;
L157: ( dom ( ZERO R4 ) ) = ( Seg R4 ) by L156 , FINSEQ_1:def 3;
L158: ( dom ( R4 -BinarySequence ( 0 ) ) ) = ( Seg R4 ) by L154 , FINSEQ_1:def 3;
L159:
now
let C47 being Nat;
L160: ( ( ( 0 ) div ( 2 to_power ( C47 -' 1 ) ) ) mod 2 ) = ( ( 0 ) mod 2 ) by NAT_2:2
.= ( 0 ) by NAT_D:26;
assume L161: C47 in ( dom ( R4 -BinarySequence ( 0 ) ) );
L162: C47 in ( dom ( ZERO R4 ) ) by L161 , L155 , FUNCOP_1:13;
L163: ( ( ZERO R4 ) /. C47 ) = ( ( R4 |-> ( FALSE ) ) . C47 ) by L162 , PARTFUN1:def 6
.= ( FALSE );
thus L164: ( ( R4 -BinarySequence ( 0 ) ) . C47 ) = ( ( R4 -BinarySequence ( 0 ) ) /. C47 ) by L161 , PARTFUN1:def 6
.= ( IFEQ (( ( ( 0 ) div ( 2 to_power ( C47 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L155 , L161 , BINARI_3:def 1
.= ( ( ZERO R4 ) /. C47 ) by L160 , L163 , FUNCOP_1:def 8
.= ( ( ZERO R4 ) . C47 ) by L158 , L157 , L161 , PARTFUN1:def 6;
end;
thus L165: thesis by L159 , L154 , L156 , FINSEQ_2:9;
end;
definition
let R4 being (Element of ( NAT ));
let C48 , C49 being Nat;
func ADD_MOD (C48 , C49 , R4) -> (Element of ( NAT )) equals 
( ( C48 + C49 ) mod ( 2 to_power R4 ) );
coherence;
end;
definition
let R4 being (Element of ( NAT ));
let C50 being (Element of ( NAT ));
assume L167: C50 is_expressible_by R4;
func NEG_N (C50 , R4) -> (Element of ( NAT )) equals 
:L168: ( ( 2 to_power R4 ) - C50 );
coherence
proof
L169: C50 < ( 2 to_power R4 ) by L167 , L151;
L170: ( ( 2 to_power R4 ) - C50 ) > ( C50 - C50 ) by L169 , XREAL_1:9;
thus L171: thesis by L170 , INT_1:3;
end;
end;
definition
let R4 being (Element of ( NAT ));
let C51 being (Element of ( NAT ));
func NEG_MOD (C51 , R4) -> (Element of ( NAT )) equals 
( ( NEG_N (C51 , R4) ) mod ( 2 to_power R4 ) );
coherence;
end;
theorem
L174: (for R1 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds (R1 is_expressible_by R4 implies ( ADD_MOD (R1 , ( NEG_MOD (R1 , R4) ) , R4) ) = ( 0 ))))
proof
let R1 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
assume L175: R1 is_expressible_by R4;
L176: ( R1 + ( NEG_N (R1 , R4) ) ) = ( R1 + ( ( 2 to_power R4 ) - R1 ) ) by L175 , L168
.= ( ( 0 ) + ( 2 to_power R4 ) );
thus L177: ( ADD_MOD (R1 , ( NEG_MOD (R1 , R4) ) , R4) ) = ( ( 2 to_power R4 ) mod ( 2 to_power R4 ) ) by L176 , NAT_D:23
.= ( 0 ) by NAT_D:25;
end;
theorem
L178: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds ( ADD_MOD (R1 , R2 , R4) ) = ( ADD_MOD (R2 , R1 , R4) ))));
theorem
L179: (for R1 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds (R1 is_expressible_by R4 implies ( ADD_MOD (( 0 ) , R1 , R4) ) = R1)))
proof
let R1 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
assume L180: R1 is_expressible_by R4;
L181: R1 < ( 2 to_power R4 ) by L180 , L151;
thus L182: thesis by L181 , NAT_D:24;
end;
theorem
L183: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R3 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds ( ADD_MOD (( ADD_MOD (R1 , R2 , R4) ) , R3 , R4) ) = ( ADD_MOD (R1 , ( ADD_MOD (R2 , R3 , R4) ) , R4) )))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R3 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
thus L184: ( ADD_MOD (( ADD_MOD (R1 , R2 , R4) ) , R3 , R4) ) = ( ( ( R1 + R2 ) + R3 ) mod ( 2 to_power R4 ) ) by NAT_D:23
.= ( ( R1 + ( R2 + R3 ) ) mod ( 2 to_power R4 ) )
.= ( ADD_MOD (R1 , ( ADD_MOD (R2 , R3 , R4) ) , R4) ) by NAT_D:22;
end;
theorem
L185: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds ( ADD_MOD (R1 , R2 , R4) ) is_expressible_by R4)))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
L186: ( ADD_MOD (R1 , R2 , R4) ) < ( 2 to_power R4 ) by NAT_D:1 , POWER:34;
thus L187: thesis by L186 , L151;
end;
theorem
L188: (for R1 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds ( NEG_MOD (R1 , R4) ) is_expressible_by R4))
proof
let R1 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
L189: ( NEG_MOD (R1 , R4) ) < ( 2 to_power R4 ) by NAT_D:1 , POWER:34;
thus L190: thesis by L189 , L151;
end;
definition
let C52 , C53 being Nat;
func ChangeVal_1 (C53 , C52) -> (Element of ( NAT )) equals 
:L191: ( 2 to_power C52 ) if C53 = ( 0 ) otherwise C53;
coherence by ORDINAL1:def 12;
correctness;
end;
theorem
L193: (for R1 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds (R1 is_expressible_by R4 implies (( ChangeVal_1 (R1 , R4) ) <= ( 2 to_power R4 ) & ( ChangeVal_1 (R1 , R4) ) > ( 0 )))))
proof
let R1 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
assume L194: R1 is_expressible_by R4;
L195: ( 2 to_power R4 ) > ( 0 ) by POWER:34;
per cases ;
suppose L196: R1 = ( 0 );

thus L197: thesis by L196 , L195 , L191;
end;
suppose L198: R1 <> ( 0 );

L199: ( ChangeVal_1 (R1 , R4) ) = R1 by L198 , L191;
thus L200: thesis by L199 , L194 , L198 , L151;
end;
end;
theorem
L202: (for B16 , B17 , B18 being (Element of ( NAT )) holds ((B17 is_expressible_by B16 & B18 is_expressible_by B16 & ( ChangeVal_1 (B17 , B16) ) = ( ChangeVal_1 (B18 , B16) )) implies B17 = B18))
proof
let R4 being (Element of ( NAT ));
let C54 , C55 being (Element of ( NAT ));
assume that
L203: C54 is_expressible_by R4
and
L204: C55 is_expressible_by R4
and
L205: ( ChangeVal_1 (C54 , R4) ) = ( ChangeVal_1 (C55 , R4) );
L206: C54 <> ( 2 to_power R4 ) by L203 , L151;
L207: C55 <> ( 2 to_power R4 ) by L204 , L151;
per cases ;
suppose L208: ( ChangeVal_1 (C54 , R4) ) = ( 2 to_power R4 );

thus L209: C55 = ( 0 ) by L208 , L205 , L207 , L191
.= C54 by L206 , L208 , L191;
end;
suppose L210: ( ChangeVal_1 (C54 , R4) ) <> ( 2 to_power R4 );

thus L211: C55 = ( ChangeVal_1 (C54 , R4) ) by L210 , L205 , L191
.= C54 by L210 , L191;
end;
end;
definition
let R4 being (Element of ( NAT ));
let C56 being (Element of ( NAT ));
func ChangeVal_2 (C56 , R4) -> (Element of ( NAT )) equals 
:L213: ( 0 ) if C56 = ( 2 to_power R4 ) otherwise C56;
correctness;
end;
theorem
L215: (for R1 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds (R1 is_expressible_by R4 implies ( ChangeVal_2 (R1 , R4) ) is_expressible_by R4)))
proof
let R1 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
assume L216: R1 is_expressible_by R4;
L217: R1 < ( 2 to_power R4 ) by L216 , L151;
L218: ( ChangeVal_2 (R1 , R4) ) < ( 2 to_power R4 ) by L217 , L213;
thus L219: thesis by L218 , L151;
end;
theorem
L220: (for B19 , B20 , B21 being (Element of ( NAT )) holds ((B20 <> ( 0 ) & B21 <> ( 0 ) & ( ChangeVal_2 (B20 , B19) ) = ( ChangeVal_2 (B21 , B19) )) implies B20 = B21))
proof
let R4 being (Element of ( NAT ));
let C57 , C58 being (Element of ( NAT ));
assume that
L221: (C57 <> ( 0 ) & C58 <> ( 0 ))
and
L222: ( ChangeVal_2 (C57 , R4) ) = ( ChangeVal_2 (C58 , R4) );
per cases ;
suppose L223: ( ChangeVal_2 (C57 , R4) ) = ( 0 );

L224: (C58 = ( 2 to_power R4 ) or C58 = ( 0 )) by L223 , L222 , L213;
thus L225: thesis by L224 , L221 , L223 , L213;
end;
suppose L226: ( ChangeVal_2 (C57 , R4) ) <> ( 0 );

L227: C57 <> ( 2 to_power R4 ) by L226 , L213;
L228: C58 <> ( 2 to_power R4 ) by L222 , L226 , L213;
thus L229: C58 = ( ChangeVal_2 (C57 , R4) ) by L228 , L222 , L213
.= C57 by L227 , L213;
end;
end;
definition
let R4 being (Element of ( NAT ));
let C59 , C60 being Nat;
func MUL_MOD (C59 , C60 , R4) -> (Element of ( NAT )) equals 
( ChangeVal_2 (( ( ( ChangeVal_1 (C59 , R4) ) * ( ChangeVal_1 (C60 , R4) ) ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) );
coherence;
end;
definition
let C61 being non  empty (Element of ( NAT ));
let C62 being (Element of ( NAT ));
assume that
L232: C62 is_expressible_by C61
and
L233: ( ( 2 to_power C61 ) + 1 ) is  prime;
func INV_MOD (C62 , C61) -> (Element of ( NAT )) means 
:L234: (( MUL_MOD (C62 , it , C61) ) = 1 & it is_expressible_by C61);
existence
proof
L235: ( 2 to_power C61 ) > ( 0 ) by POWER:34;
L236: ( ( 2 to_power C61 ) + 1 ) > ( ( 0 ) + 1 ) by L235 , XREAL_1:6;
L237: ( ( ( 2 to_power C61 ) + 1 ) - 1 ) >= ( ( 1 + 1 ) - 1 ) by L236 , NAT_1:13;
L238: ( ( ( ( 2 to_power C61 ) + 1 ) - 1 ) - 1 ) >= ( ( ( 1 + 1 ) - 1 ) - 1 ) by L237 , XREAL_1:9;
reconsider D16 = ( ( ( ( 2 to_power C61 ) + 1 ) - 1 ) - 1 ) as (Element of ( NAT )) by L238 , INT_1:3;
reconsider D17 = ( ( 2 to_power C61 ) + 1 ) as (Element of ( NAT ));
reconsider D18 = ( ( ( 2 to_power C61 ) + 1 ) - 1 ) as (Element of ( NAT ));
L239: ( 2 to_power C61 ) <> 1 by POWER:35;
L240: ( D18 * D18 ) = ( ( D17 * D16 ) + 1 );
L241: ( ( D18 * D18 ) mod D17 ) = ( 1 mod D17 ) by L240 , NAT_D:21
.= 1 by L236 , NAT_D:24;
L242:
now
per cases ;
suppose L243: C62 = ( 0 );

consider R2 being (Element of ( NAT )) such that L244: R2 = ( 0 );
take D19 = R2;
L245: D19 is_expressible_by C61 by L235 , L244 , L151;
L246: ( MUL_MOD (C62 , D19 , C61) ) = ( ChangeVal_2 (( ( ( 2 to_power C61 ) * ( ChangeVal_1 (( 0 ) , C61) ) ) mod D17 ) , C61) ) by L243 , L244 , L191
.= ( ChangeVal_2 (( ( D18 * D18 ) mod D17 ) , C61) ) by L191
.= 1 by L239 , L241 , L213;
thus L247: thesis by L246 , L245;
end;
suppose L248: C62 <> ( 0 );

L249: C62 < ( 2 to_power C61 ) by L232 , L151;
L250: C62 < ( ( 2 to_power C61 ) + 1 ) by L249 , NAT_1:13;
consider C63 being (Element of ( NAT )) such that L251: ( ( C63 * C62 ) mod ( ( 2 to_power C61 ) + 1 ) ) = 1 and L252: C63 < ( ( 2 to_power C61 ) + 1 ) by L250 , L233 , L236 , L248 , L58;
take D20 = ( ChangeVal_2 (C63 , C61) );
L253: C63 <> ( 0 ) by L251 , NAT_D:24;
L254:
now
per cases ;
suppose L255: C63 <> ( 2 to_power C61 );

L256: D20 = C63 by L255 , L213;
L257: D20 <= ( 2 to_power C61 ) by L256 , L252 , NAT_1:13;
L258: D20 < ( 2 to_power C61 ) by L257 , L255 , L256 , XXREAL_0:1;
L259: D20 is_expressible_by C61 by L258 , L151;
L260: ( MUL_MOD (C62 , D20 , C61) ) = ( ChangeVal_2 (( ( C62 * ( ChangeVal_1 (D20 , C61) ) ) mod ( ( 2 to_power C61 ) + 1 ) ) , C61) ) by L248 , L191
.= ( ChangeVal_2 (( ( C62 * C63 ) mod ( ( 2 to_power C61 ) + 1 ) ) , C61) ) by L253 , L256 , L191
.= 1 by L239 , L251 , L213;
thus L261: thesis by L260 , L259;
end;
suppose L262: C63 = ( 2 to_power C61 );

L263: D20 = ( 0 ) by L262 , L213;
L264: D20 is_expressible_by C61 by L263 , L235 , L151;
L265: ( MUL_MOD (C62 , D20 , C61) ) = ( ChangeVal_2 (( ( C62 * ( ChangeVal_1 (D20 , C61) ) ) mod ( ( 2 to_power C61 ) + 1 ) ) , C61) ) by L248 , L191
.= ( ChangeVal_2 (( ( C62 * C63 ) mod ( ( 2 to_power C61 ) + 1 ) ) , C61) ) by L262 , L263 , L191
.= 1 by L239 , L251 , L213;
thus L266: thesis by L265 , L264;
end;
end;
thus L268: thesis by L254;
end;
end;
thus L270: thesis by L242;
end;
uniqueness
proof
let C64 , C65 being (Element of ( NAT ));
assume that
L271: ( MUL_MOD (C62 , C64 , C61) ) = 1
and
L272: C64 is_expressible_by C61
and
L273: ( MUL_MOD (C62 , C65 , C61) ) = 1
and
L274: C65 is_expressible_by C61;
consider C66 being (Element of ( NAT )) such that L275: C66 = ( ChangeVal_1 (C65 , C61) );
L276: C66 <= ( 2 to_power C61 ) by L274 , L275 , L193;
L277: C66 < ( ( 2 to_power C61 ) + 1 ) by L276 , NAT_1:13;
consider C67 being (Element of ( NAT )) such that L278: C67 = ( ChangeVal_1 (C64 , C61) );
L279: C67 <= ( 2 to_power C61 ) by L272 , L278 , L193;
L280: C67 < ( ( 2 to_power C61 ) + 1 ) by L279 , NAT_1:13;
consider C68 being (Element of ( NAT )) such that L281: C68 = ( ChangeVal_1 (C62 , C61) );
L282: C68 <= ( 2 to_power C61 ) by L232 , L281 , L193;
L283: C68 < ( ( 2 to_power C61 ) + 1 ) by L282 , NAT_1:13;
L284: C68 > ( 0 ) by L232 , L281 , L193;
L285: C66 > ( 0 ) by L274 , L275 , L193;
L286: ( ( C68 * C66 ) mod ( ( 2 to_power C61 ) + 1 ) ) <> ( 0 ) by L285 , L233 , L284 , L283 , L277 , L82;
L287: C67 > ( 0 ) by L272 , L278 , L193;
L288: ( ( C68 * C67 ) mod ( ( 2 to_power C61 ) + 1 ) ) <> ( 0 ) by L287 , L233 , L284 , L283 , L280 , L82;
L289: ( ( C68 * C67 ) mod ( ( 2 to_power C61 ) + 1 ) ) = ( ( C68 * C66 ) mod ( ( 2 to_power C61 ) + 1 ) ) by L288 , L271 , L273 , L281 , L278 , L275 , L286 , L220;
L290:
now
per cases ;
suppose L291: C67 <= C66;

consider C69 being Integer such that L292: C69 = ( C66 - C67 );
L293: ( C67 - C67 ) <= ( C66 - C67 ) by L291 , XREAL_1:9;
reconsider D21 = C69 as (Element of ( NAT )) by L293 , L292 , INT_1:3;
L294: (ex B22 being (Element of ( NAT )) st ( ( C68 * C66 ) - ( C68 * C67 ) ) = ( ( ( 2 to_power C61 ) + 1 ) * B22 )) by L289 , L291 , L65 , NAT_1:4;
L295: ( ( 2 to_power C61 ) + 1 ) divides ( C68 * D21 ) by L294 , L292 , NAT_D:def 3;
L296: (( ( 2 to_power C61 ) + 1 ) divides C68 or ( ( 2 to_power C61 ) + 1 ) divides D21) by L295 , L233 , NEWTON:80;
L297: D21 <= ( 2 to_power C61 ) by L274 , L275 , L292 , L77 , L193;
L298: (not ( ( 2 to_power C61 ) + 1 ) <= D21) by L297 , NAT_1:13;
L299: (not ( ( 2 to_power C61 ) + 1 ) <= C68) by L282 , NAT_1:13;
L300: (not ( 0 ) < D21) by L299 , L284 , L296 , L298 , NAT_D:7;
L301: ( ( C66 - C67 ) + C67 ) = ( ( 0 ) + C67 ) by L300 , L292;
thus L302: C67 = C66 by L301;
end;
suppose L303: C66 <= C67;

consider C70 being Integer such that L304: C70 = ( C67 - C66 );
L305: ( C66 - C66 ) <= ( C67 - C66 ) by L303 , XREAL_1:9;
reconsider D22 = C70 as (Element of ( NAT )) by L305 , L304 , INT_1:3;
L306: (ex B23 being (Element of ( NAT )) st ( ( C68 * C67 ) - ( C68 * C66 ) ) = ( ( ( 2 to_power C61 ) + 1 ) * B23 )) by L289 , L303 , L65 , NAT_1:4;
L307: ( ( 2 to_power C61 ) + 1 ) divides ( C68 * D22 ) by L306 , L304 , NAT_D:def 3;
L308: (( ( 2 to_power C61 ) + 1 ) divides C68 or ( ( 2 to_power C61 ) + 1 ) divides D22) by L307 , L233 , NEWTON:80;
L309: D22 <= ( 2 to_power C61 ) by L272 , L278 , L304 , L77 , L193;
L310: (not ( ( 2 to_power C61 ) + 1 ) <= D22) by L309 , NAT_1:13;
L311: (not ( ( 2 to_power C61 ) + 1 ) <= C68) by L282 , NAT_1:13;
L312: (not ( 0 ) < D22) by L311 , L284 , L308 , L310 , NAT_D:7;
L313: ( ( C67 - C66 ) + C66 ) = ( ( 0 ) + C66 ) by L312 , L304;
thus L314: C66 = C67 by L313;
end;
end;
thus L316: thesis by L290 , L272 , L274 , L278 , L275 , L202;
end;
end;
theorem
L318: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds ( MUL_MOD (R1 , R2 , R4) ) = ( MUL_MOD (R2 , R1 , R4) ))));
theorem
L319: (for R1 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds (R1 is_expressible_by R4 implies ( MUL_MOD (1 , R1 , R4) ) = R1)))
proof
let R1 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
L320: ( ChangeVal_1 (1 , R4) ) = 1 by L191;
assume L321: R1 is_expressible_by R4;
L322: R1 < ( 2 to_power R4 ) by L321 , L151;
per cases ;
suppose L323: R1 = ( 0 );

L324: ( ChangeVal_1 (R1 , R4) ) = ( 2 to_power R4 ) by L323 , L191;
L325: ( ( ChangeVal_1 (R1 , R4) ) mod ( ( 2 to_power R4 ) + 1 ) ) = ( 2 to_power R4 ) by L324 , NAT_D:24 , XREAL_1:29;
thus L326: thesis by L325 , L320 , L323 , L213;
end;
suppose L327: R1 <> ( 0 );

L328: ( 2 to_power R4 ) < ( ( 2 to_power R4 ) + 1 ) by XREAL_1:29;
L329: R1 < ( ( 2 to_power R4 ) + 1 ) by L328 , L322 , XXREAL_0:2;
L330: ( ( ChangeVal_1 (R1 , R4) ) mod ( ( 2 to_power R4 ) + 1 ) ) = ( R1 mod ( ( 2 to_power R4 ) + 1 ) ) by L327 , L191;
L331: ( ( ChangeVal_1 (R1 , R4) ) mod ( ( 2 to_power R4 ) + 1 ) ) = R1 by L330 , L329 , NAT_D:24;
thus L332: thesis by L331 , L322 , L320 , L213;
end;
end;
theorem
L334: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R3 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds ((( ( 2 to_power R4 ) + 1 ) is  prime & R1 is_expressible_by R4 & R2 is_expressible_by R4 & R3 is_expressible_by R4) implies ( MUL_MOD (( MUL_MOD (R1 , R2 , R4) ) , R3 , R4) ) = ( MUL_MOD (R1 , ( MUL_MOD (R2 , R3 , R4) ) , R4) ))))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R3 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
assume that
L335: ( ( 2 to_power R4 ) + 1 ) is  prime
and
L336: R1 is_expressible_by R4
and
L337: R2 is_expressible_by R4
and
L338: R3 is_expressible_by R4;
set D23 = ( ChangeVal_1 (R2 , R4) );
L339: D23 > ( 0 ) by L337 , L193;
set D24 = ( ChangeVal_1 (R1 , R4) );
L340: D24 <= ( 2 to_power R4 ) by L336 , L193;
L341: D24 < ( ( 2 to_power R4 ) + 1 ) by L340 , NAT_1:13;
L342: D23 <= ( 2 to_power R4 ) by L337 , L193;
L343: D23 < ( ( 2 to_power R4 ) + 1 ) by L342 , NAT_1:13;
set D25 = ( ChangeVal_1 (R3 , R4) );
L344: D25 > ( 0 ) by L338 , L193;
L345: D25 <= ( 2 to_power R4 ) by L338 , L193;
L346: D25 < ( ( 2 to_power R4 ) + 1 ) by L345 , NAT_1:13;
L347: D24 > ( 0 ) by L336 , L193;
L348:
now
set D26 = ( ( D24 * D23 ) mod ( ( 2 to_power R4 ) + 1 ) );
L349: ( ( D24 * D23 ) mod ( ( 2 to_power R4 ) + 1 ) ) < ( ( 2 to_power R4 ) + 1 ) by NAT_D:1;
L350: ( ( D24 * D23 ) mod ( ( 2 to_power R4 ) + 1 ) ) <= ( 2 to_power R4 ) by L349 , NAT_1:13;
L351: D26 <> ( 0 ) by L335 , L341 , L347 , L343 , L339 , L82;
L352:
now
per cases  by L350 , XXREAL_0:1;
suppose L353: D26 = ( 2 to_power R4 );

L354: ( MUL_MOD (( MUL_MOD (R1 , R2 , R4) ) , R3 , R4) ) = ( ChangeVal_2 (( ( ( ChangeVal_1 (( 0 ) , R4) ) * D25 ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) ) by L353 , L213
.= ( ChangeVal_2 (( ( D26 * D25 ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) ) by L353 , L191
.= ( ChangeVal_2 (( ( ( D24 * D23 ) * D25 ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) ) by EULER_2:8;
set D27 = ( ( D23 * D25 ) mod ( ( 2 to_power R4 ) + 1 ) );
L355: D27 < ( ( 2 to_power R4 ) + 1 ) by NAT_D:1;
L356: D27 <= ( 2 to_power R4 ) by L355 , NAT_1:13;
L357: D27 <> ( 0 ) by L335 , L343 , L339 , L346 , L344 , L82;
L358:
now
per cases  by L356 , XXREAL_0:1;
suppose L359: D27 = ( 2 to_power R4 );

L360: ( MUL_MOD (R1 , ( MUL_MOD (R2 , R3 , R4) ) , R4) ) = ( ChangeVal_2 (( ( D24 * ( ChangeVal_1 (( 0 ) , R4) ) ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) ) by L359 , L213
.= ( ChangeVal_2 (( ( D24 * D27 ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) ) by L359 , L191
.= ( ChangeVal_2 (( ( D24 * ( D23 * D25 ) ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) ) by EULER_2:8
.= ( ChangeVal_2 (( ( ( D24 * D23 ) * D25 ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) );
thus L361: thesis by L360 , L354;
end;
suppose L362: D27 < ( 2 to_power R4 );

L363: ( MUL_MOD (R2 , R3 , R4) ) = D27 by L362 , L213;
L364: ( MUL_MOD (R1 , ( MUL_MOD (R2 , R3 , R4) ) , R4) ) = ( ChangeVal_2 (( ( D24 * D27 ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) ) by L363 , L357 , L191
.= ( ChangeVal_2 (( ( D24 * ( D23 * D25 ) ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) ) by EULER_2:8
.= ( ChangeVal_2 (( ( ( D24 * D23 ) * D25 ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) );
thus L365: thesis by L364 , L354;
end;
end;
thus L367: thesis by L358;
end;
suppose L368: D26 < ( 2 to_power R4 );

L369: ( MUL_MOD (( MUL_MOD (R1 , R2 , R4) ) , R3 , R4) ) = ( ChangeVal_2 (( ( ( ChangeVal_1 (D26 , R4) ) * D25 ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) ) by L368 , L213
.= ( ChangeVal_2 (( ( D26 * D25 ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) ) by L351 , L191
.= ( ChangeVal_2 (( ( ( D24 * D23 ) * D25 ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) ) by EULER_2:8;
set D28 = ( ( D23 * D25 ) mod ( ( 2 to_power R4 ) + 1 ) );
L370: D28 < ( ( 2 to_power R4 ) + 1 ) by NAT_D:1;
L371: D28 <= ( 2 to_power R4 ) by L370 , NAT_1:13;
L372: D28 <> ( 0 ) by L335 , L343 , L339 , L346 , L344 , L82;
L373:
now
per cases  by L371 , XXREAL_0:1;
suppose L374: D28 = ( 2 to_power R4 );

L375: ( MUL_MOD (R1 , ( MUL_MOD (R2 , R3 , R4) ) , R4) ) = ( ChangeVal_2 (( ( D24 * ( ChangeVal_1 (( 0 ) , R4) ) ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) ) by L374 , L213
.= ( ChangeVal_2 (( ( D24 * D28 ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) ) by L374 , L191
.= ( ChangeVal_2 (( ( D24 * ( D23 * D25 ) ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) ) by EULER_2:8
.= ( ChangeVal_2 (( ( ( D24 * D23 ) * D25 ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) );
thus L376: thesis by L375 , L369;
end;
suppose L377: D28 < ( 2 to_power R4 );

L378: ( MUL_MOD (R2 , R3 , R4) ) = D28 by L377 , L213;
L379: ( MUL_MOD (R1 , ( MUL_MOD (R2 , R3 , R4) ) , R4) ) = ( ChangeVal_2 (( ( D24 * D28 ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) ) by L378 , L372 , L191
.= ( ChangeVal_2 (( ( D24 * ( D23 * D25 ) ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) ) by EULER_2:8
.= ( ChangeVal_2 (( ( ( D24 * D23 ) * D25 ) mod ( ( 2 to_power R4 ) + 1 ) ) , R4) );
thus L380: thesis by L379 , L369;
end;
end;
thus L382: thesis by L373;
end;
end;
thus L384: thesis by L352;
end;
thus L385: thesis by L348;
end;
theorem
L386: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds ( MUL_MOD (R1 , R2 , R4) ) is_expressible_by R4)))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
set D29 = ( ( ( ChangeVal_1 (R1 , R4) ) * ( ChangeVal_1 (R2 , R4) ) ) mod ( ( 2 to_power R4 ) + 1 ) );
L387: ( ( ( ChangeVal_1 (R1 , R4) ) * ( ChangeVal_1 (R2 , R4) ) ) mod ( ( 2 to_power R4 ) + 1 ) ) < ( ( 2 to_power R4 ) + 1 ) by NAT_D:1;
L388: ( ( ( ChangeVal_1 (R1 , R4) ) * ( ChangeVal_1 (R2 , R4) ) ) mod ( ( 2 to_power R4 ) + 1 ) ) <= ( 2 to_power R4 ) by L387 , NAT_1:13;
L389: ( 0 ) < ( 2 to_power R4 ) by POWER:34;
L390:
now
per cases  by L388 , XXREAL_0:1;
suppose L391: D29 = ( 2 to_power R4 );

L392: ( ChangeVal_2 (D29 , R4) ) = ( 0 ) by L391 , L213;
thus L393: thesis by L392 , L389 , L151;
end;
suppose L394: D29 < ( 2 to_power R4 );

L395: ( ChangeVal_2 (D29 , R4) ) = D29 by L394 , L213;
thus L396: thesis by L395 , L394 , L151;
end;
end;
thus L398: thesis by L390;
end;
theorem
L399: (for R1 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds (( ChangeVal_2 (R1 , R4) ) = 1 implies R1 = 1)))
proof
let R1 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
assume L400: ( ChangeVal_2 (R1 , R4) ) = 1;
assume L401: R1 <> 1;
L402:
now
per cases ;
suppose L403: R1 = ( 2 to_power R4 );

thus L404: contradiction by L403 , L400 , L213;
end;
suppose L405: R1 <> ( 2 to_power R4 );

thus L406: contradiction by L405 , L400 , L401 , L213;
end;
end;
thus L408: thesis by L402;
end;
begin
definition
let R4 being (Element of ( NAT ));
let C71 , C72 being (FinSequence of ( NAT ));
func IDEAoperationA (C71 , C72 , R4) -> (FinSequence of ( NAT )) means 
:L409: (( len it ) = ( len C71 ) & (for B24 being (Element of ( NAT )) holds (B24 in ( dom C71 ) implies ((B24 = 1 implies ( it . B24 ) = ( MUL_MOD (( C71 . 1 ) , ( C72 . 1 ) , R4) )) & (B24 = 2 implies ( it . B24 ) = ( ADD_MOD (( C71 . 2 ) , ( C72 . 2 ) , R4) )) & (B24 = 3 implies ( it . B24 ) = ( ADD_MOD (( C71 . 3 ) , ( C72 . 3 ) , R4) )) & (B24 = 4 implies ( it . B24 ) = ( MUL_MOD (( C71 . 4 ) , ( C72 . 4 ) , R4) )) & ((B24 <> 1 & B24 <> 2 & B24 <> 3 & B24 <> 4) implies ( it . B24 ) = ( C71 . B24 ))))));
existence
proof
defpred S1[ set , set ] means (($1 = 1 implies $2 = ( MUL_MOD (( C71 . 1 ) , ( C72 . 1 ) , R4) )) & ($1 = 2 implies $2 = ( ADD_MOD (( C71 . 2 ) , ( C72 . 2 ) , R4) )) & ($1 = 3 implies $2 = ( ADD_MOD (( C71 . 3 ) , ( C72 . 3 ) , R4) )) & ($1 = 4 implies $2 = ( MUL_MOD (( C71 . 4 ) , ( C72 . 4 ) , R4) )) & (($1 <> 1 & $1 <> 2 & $1 <> 3 & $1 <> 4) implies $2 = ( C71 . $1 )));
L410: (for B25 being Nat holds (B25 in ( Seg ( len C71 ) ) implies (ex B26 being (Element of ( NAT )) st S1[ B25 , B26 ])))
proof
let C73 being Nat;
assume L411: C73 in ( Seg ( len C71 ) );
reconsider D30 = C73 as (Element of ( NAT )) by L411;
per cases ;
suppose L412: D30 = 1;

take ( MUL_MOD (( C71 . 1 ) , ( C72 . 1 ) , R4) );
thus L413: thesis by L412;
end;
suppose L414: D30 = 2;

take ( ADD_MOD (( C71 . 2 ) , ( C72 . 2 ) , R4) );
thus L415: thesis by L414;
end;
suppose L416: D30 = 3;

take ( ADD_MOD (( C71 . 3 ) , ( C72 . 3 ) , R4) );
thus L417: thesis by L416;
end;
suppose L418: D30 = 4;

take ( MUL_MOD (( C71 . 4 ) , ( C72 . 4 ) , R4) );
thus L419: thesis by L418;
end;
suppose L420: (D30 <> 1 & D30 <> 2 & D30 <> 3 & D30 <> 4);

take ( C71 . D30 );
thus L421: thesis by L420;
end;
end;
consider C74 being (FinSequence of ( NAT )) such that L423: (( dom C74 ) = ( Seg ( len C71 ) ) & (for B27 being Nat holds (B27 in ( Seg ( len C71 ) ) implies S1[ B27 , ( C74 . B27 ) ]))) from FINSEQ_1:sch 5(L410);
take C74;
L424: ( dom C71 ) = ( Seg ( len C71 ) ) by FINSEQ_1:def 3;
thus L425: thesis by L424 , L423 , FINSEQ_1:def 3;
end;
uniqueness
proof
let C75 , C76 being (FinSequence of ( NAT ));
assume that
L426: ( len C75 ) = ( len C71 )
and
L427: (for B28 being (Element of ( NAT )) holds (B28 in ( dom C71 ) implies ((B28 = 1 implies ( C75 . B28 ) = ( MUL_MOD (( C71 . 1 ) , ( C72 . 1 ) , R4) )) & (B28 = 2 implies ( C75 . B28 ) = ( ADD_MOD (( C71 . 2 ) , ( C72 . 2 ) , R4) )) & (B28 = 3 implies ( C75 . B28 ) = ( ADD_MOD (( C71 . 3 ) , ( C72 . 3 ) , R4) )) & (B28 = 4 implies ( C75 . B28 ) = ( MUL_MOD (( C71 . 4 ) , ( C72 . 4 ) , R4) )) & ((B28 <> 1 & B28 <> 2 & B28 <> 3 & B28 <> 4) implies ( C75 . B28 ) = ( C71 . B28 )))))
and
L428: ( len C76 ) = ( len C71 )
and
L429: (for R1 being (Element of ( NAT )) holds (R1 in ( dom C71 ) implies ((R1 = 1 implies ( C76 . R1 ) = ( MUL_MOD (( C71 . 1 ) , ( C72 . 1 ) , R4) )) & (R1 = 2 implies ( C76 . R1 ) = ( ADD_MOD (( C71 . 2 ) , ( C72 . 2 ) , R4) )) & (R1 = 3 implies ( C76 . R1 ) = ( ADD_MOD (( C71 . 3 ) , ( C72 . 3 ) , R4) )) & (R1 = 4 implies ( C76 . R1 ) = ( MUL_MOD (( C71 . 4 ) , ( C72 . 4 ) , R4) )) & ((R1 <> 1 & R1 <> 2 & R1 <> 3 & R1 <> 4) implies ( C76 . R1 ) = ( C71 . R1 )))));
L430: ( dom C71 ) = ( Seg ( len C76 ) ) by L428 , FINSEQ_1:def 3
.= ( dom C76 ) by FINSEQ_1:def 3;
L431:
now
let C77 being Nat;
assume L432: C77 in ( dom C71 );
L433:
now
per cases ;
suppose L434: C77 = 1;

thus L435: ( C75 . C77 ) = ( MUL_MOD (( C71 . 1 ) , ( C72 . 1 ) , R4) ) by L434 , L427 , L432
.= ( C76 . C77 ) by L429 , L432 , L434;
end;
suppose L436: C77 = 2;

thus L437: ( C75 . C77 ) = ( ADD_MOD (( C71 . 2 ) , ( C72 . 2 ) , R4) ) by L436 , L427 , L432
.= ( C76 . C77 ) by L429 , L432 , L436;
end;
suppose L438: C77 = 3;

thus L439: ( C75 . C77 ) = ( ADD_MOD (( C71 . 3 ) , ( C72 . 3 ) , R4) ) by L438 , L427 , L432
.= ( C76 . C77 ) by L429 , L432 , L438;
end;
suppose L440: C77 = 4;

thus L441: ( C75 . C77 ) = ( MUL_MOD (( C71 . 4 ) , ( C72 . 4 ) , R4) ) by L440 , L427 , L432
.= ( C76 . C77 ) by L429 , L432 , L440;
end;
suppose L442: (C77 <> 1 & C77 <> 2 & C77 <> 3 & C77 <> 4);

thus L443: ( C75 . C77 ) = ( C71 . C77 ) by L442 , L427 , L432
.= ( C76 . C77 ) by L429 , L432 , L442;
end;
end;
thus L445: ( C75 . C77 ) = ( C76 . C77 ) by L433;
end;
L446: ( dom C71 ) = ( Seg ( len C75 ) ) by L426 , FINSEQ_1:def 3
.= ( dom C75 ) by FINSEQ_1:def 3;
thus L447: thesis by L446 , L430 , L431 , FINSEQ_1:13;
end;
end;
definition
let C78 being non  empty (Element of ( NAT ));
let C79 , C80 being (FinSequence of ( NAT ));
func IDEAoperationB (C79 , C80 , C78) -> (FinSequence of ( NAT )) means 
:L449: (( len it ) = ( len C79 ) & (for B29 being (Element of ( NAT )) holds (B29 in ( dom C79 ) implies ((B29 = 1 implies ( it . B29 ) = ( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) ) ) )) & (B29 = 2 implies ( it . B29 ) = ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) , C78) ) ) ) )) & (B29 = 3 implies ( it . B29 ) = ( Absval ( ( C78 -BinarySequence ( C79 . 3 ) ) 'xor' ( C78 -BinarySequence ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) ) ) )) & (B29 = 4 implies ( it . B29 ) = ( Absval ( ( C78 -BinarySequence ( C79 . 4 ) ) 'xor' ( C78 -BinarySequence ( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) , C78) ) ) ) )) & ((B29 <> 1 & B29 <> 2 & B29 <> 3 & B29 <> 4) implies ( it . B29 ) = ( C79 . B29 ))))));
existence
proof
defpred S2[ set , set ] means (($1 = 1 implies $2 = ( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) ) ) )) & ($1 = 2 implies $2 = ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) , C78) ) ) ) )) & ($1 = 3 implies $2 = ( Absval ( ( C78 -BinarySequence ( C79 . 3 ) ) 'xor' ( C78 -BinarySequence ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) ) ) )) & ($1 = 4 implies $2 = ( Absval ( ( C78 -BinarySequence ( C79 . 4 ) ) 'xor' ( C78 -BinarySequence ( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) , C78) ) ) ) )) & (($1 <> 1 & $1 <> 2 & $1 <> 3 & $1 <> 4) implies $2 = ( C79 . $1 )));
L450: (for B30 being Nat holds (B30 in ( Seg ( len C79 ) ) implies (ex B31 being (Element of ( NAT )) st S2[ B30 , B31 ])))
proof
let C81 being Nat;
assume L451: C81 in ( Seg ( len C79 ) );
reconsider D31 = C81 as (Element of ( NAT )) by L451;
per cases ;
suppose L452: D31 = 1;

take ( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) ) ) );
thus L453: thesis by L452;
end;
suppose L454: D31 = 2;

take ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) , C78) ) ) ) );
thus L455: thesis by L454;
end;
suppose L456: D31 = 3;

take ( Absval ( ( C78 -BinarySequence ( C79 . 3 ) ) 'xor' ( C78 -BinarySequence ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) ) ) );
thus L457: thesis by L456;
end;
suppose L458: D31 = 4;

take ( Absval ( ( C78 -BinarySequence ( C79 . 4 ) ) 'xor' ( C78 -BinarySequence ( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) , C78) ) ) ) );
thus L459: thesis by L458;
end;
suppose L460: (D31 <> 1 & D31 <> 2 & D31 <> 3 & D31 <> 4);

take ( C79 . D31 );
thus L461: thesis by L460;
end;
end;
consider C82 being (FinSequence of ( NAT )) such that L463: (( dom C82 ) = ( Seg ( len C79 ) ) & (for B32 being Nat holds (B32 in ( Seg ( len C79 ) ) implies S2[ B32 , ( C82 . B32 ) ]))) from FINSEQ_1:sch 5(L450);
take C82;
L464: ( Seg ( len C79 ) ) = ( dom C79 ) by FINSEQ_1:def 3;
thus L465: thesis by L464 , L463 , FINSEQ_1:def 3;
end;
uniqueness
proof
let C83 , C84 being (FinSequence of ( NAT ));
assume that
L466: ( len C83 ) = ( len C79 )
and
L467: (for R1 being (Element of ( NAT )) holds (R1 in ( dom C79 ) implies ((R1 = 1 implies ( C83 . R1 ) = ( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) ) ) )) & (R1 = 2 implies ( C83 . R1 ) = ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) , C78) ) ) ) )) & (R1 = 3 implies ( C83 . R1 ) = ( Absval ( ( C78 -BinarySequence ( C79 . 3 ) ) 'xor' ( C78 -BinarySequence ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) ) ) )) & (R1 = 4 implies ( C83 . R1 ) = ( Absval ( ( C78 -BinarySequence ( C79 . 4 ) ) 'xor' ( C78 -BinarySequence ( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) , C78) ) ) ) )) & ((R1 <> 1 & R1 <> 2 & R1 <> 3 & R1 <> 4) implies ( C83 . R1 ) = ( C79 . R1 )))))
and
L468: ( len C84 ) = ( len C79 )
and
L469: (for R1 being (Element of ( NAT )) holds (R1 in ( dom C79 ) implies ((R1 = 1 implies ( C84 . R1 ) = ( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) ) ) )) & (R1 = 2 implies ( C84 . R1 ) = ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) , C78) ) ) ) )) & (R1 = 3 implies ( C84 . R1 ) = ( Absval ( ( C78 -BinarySequence ( C79 . 3 ) ) 'xor' ( C78 -BinarySequence ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) ) ) )) & (R1 = 4 implies ( C84 . R1 ) = ( Absval ( ( C78 -BinarySequence ( C79 . 4 ) ) 'xor' ( C78 -BinarySequence ( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) , C78) ) ) ) )) & ((R1 <> 1 & R1 <> 2 & R1 <> 3 & R1 <> 4) implies ( C84 . R1 ) = ( C79 . R1 )))));
L470: ( dom C79 ) = ( Seg ( len C84 ) ) by L468 , FINSEQ_1:def 3
.= ( dom C84 ) by FINSEQ_1:def 3;
L471:
now
let C85 being Nat;
assume L472: C85 in ( dom C79 );
L473:
now
per cases ;
suppose L474: C85 = 1;

thus L475: ( C83 . C85 ) = ( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) ) ) ) by L474 , L467 , L472
.= ( C84 . C85 ) by L469 , L472 , L474;
end;
suppose L476: C85 = 2;

thus L477: ( C83 . C85 ) = ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) , C78) ) ) ) ) by L476 , L467 , L472
.= ( C84 . C85 ) by L469 , L472 , L476;
end;
suppose L478: C85 = 3;

thus L479: ( C83 . C85 ) = ( Absval ( ( C78 -BinarySequence ( C79 . 3 ) ) 'xor' ( C78 -BinarySequence ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) ) ) ) by L478 , L467 , L472
.= ( C84 . C85 ) by L469 , L472 , L478;
end;
suppose L480: C85 = 4;

thus L481: ( C83 . C85 ) = ( Absval ( ( C78 -BinarySequence ( C79 . 4 ) ) 'xor' ( C78 -BinarySequence ( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C78 -BinarySequence ( C79 . 1 ) ) 'xor' ( C78 -BinarySequence ( C79 . 3 ) ) ) ) , ( C80 . 5 ) , C78) ) , ( Absval ( ( C78 -BinarySequence ( C79 . 2 ) ) 'xor' ( C78 -BinarySequence ( C79 . 4 ) ) ) ) , C78) ) , ( C80 . 6 ) , C78) ) , C78) ) ) ) ) by L480 , L467 , L472
.= ( C84 . C85 ) by L469 , L472 , L480;
end;
suppose L482: (C85 <> 1 & C85 <> 2 & C85 <> 3 & C85 <> 4);

thus L483: ( C83 . C85 ) = ( C79 . C85 ) by L482 , L467 , L472
.= ( C84 . C85 ) by L469 , L472 , L482;
end;
end;
thus L485: ( C83 . C85 ) = ( C84 . C85 ) by L473;
end;
L486: ( dom C79 ) = ( Seg ( len C83 ) ) by L466 , FINSEQ_1:def 3
.= ( dom C83 ) by FINSEQ_1:def 3;
thus L487: thesis by L486 , L470 , L471 , FINSEQ_1:13;
end;
end;
definition
let C86 being (FinSequence of ( NAT ));
func IDEAoperationC C86 -> (FinSequence of ( NAT )) means 
:L489: (( len it ) = ( len C86 ) & (for B33 being (Element of ( NAT )) holds (B33 in ( dom C86 ) implies ( it . B33 ) = ( IFEQ (B33 , 2 , ( C86 . 3 ) , ( IFEQ (B33 , 3 , ( C86 . 2 ) , ( C86 . B33 )) )) ))));
existence
proof
defpred S3[ set , set ] means (($1 = 2 implies $2 = ( C86 . 3 )) & ($1 = 3 implies $2 = ( C86 . 2 )) & (($1 <> 2 & $1 <> 3) implies $2 = ( C86 . $1 )));
L490: (for B34 being Nat holds (B34 in ( Seg ( len C86 ) ) implies (ex B35 being (Element of ( NAT )) st S3[ B34 , B35 ])))
proof
let C87 being Nat;
assume L491: C87 in ( Seg ( len C86 ) );
reconsider D32 = C87 as (Element of ( NAT )) by L491;
per cases ;
suppose L492: D32 = 2;

take ( C86 . 3 );
thus L493: thesis by L492;
end;
suppose L494: D32 = 3;

take ( C86 . 2 );
thus L495: thesis by L494;
end;
suppose L496: (D32 <> 2 & D32 <> 3);

take ( C86 . D32 );
thus L497: thesis by L496;
end;
end;
consider C88 being (FinSequence of ( NAT )) such that L499: ( dom C88 ) = ( Seg ( len C86 ) ) and L500: (for B36 being Nat holds (B36 in ( Seg ( len C86 ) ) implies S3[ B36 , ( C88 . B36 ) ])) from FINSEQ_1:sch 5(L490);
L501: (for R1 being (Element of ( NAT )) holds (R1 in ( Seg ( len C86 ) ) implies ( IFEQ (R1 , 2 , ( C86 . 3 ) , ( IFEQ (R1 , 3 , ( C86 . 2 ) , ( C86 . R1 )) )) ) = ( C88 . R1 )))
proof
let C89 being (Element of ( NAT ));
assume L502: C89 in ( Seg ( len C86 ) );
L503: (C89 = 3 implies ( IFEQ (C89 , 2 , ( C86 . 3 ) , ( IFEQ (C89 , 3 , ( C86 . 2 ) , ( C86 . C89 )) )) ) = ( C86 . 2 ))
proof
assume L504: C89 = 3;
L505: ( IFEQ (C89 , 2 , ( C86 . 3 ) , ( IFEQ (C89 , 3 , ( C86 . 2 ) , ( C86 . C89 )) )) ) = ( IFEQ (C89 , 3 , ( C86 . 2 ) , ( C86 . C89 )) ) by L504 , FUNCOP_1:def 8
.= ( C86 . 2 ) by L504 , FUNCOP_1:def 8;
thus L506: thesis by L505;
end;
L507: (C89 = 2 implies ( IFEQ (C89 , 2 , ( C86 . 3 ) , ( IFEQ (C89 , 3 , ( C86 . 2 ) , ( C86 . C89 )) )) ) = ( C86 . 3 )) by FUNCOP_1:def 8;
L508: ((C89 <> 2 & C89 <> 3) implies ( IFEQ (C89 , 2 , ( C86 . 3 ) , ( IFEQ (C89 , 3 , ( C86 . 2 ) , ( C86 . C89 )) )) ) = ( C86 . C89 ))
proof
assume that
L509: C89 <> 2
and
L510: C89 <> 3;
L511: ( IFEQ (C89 , 2 , ( C86 . 3 ) , ( IFEQ (C89 , 3 , ( C86 . 2 ) , ( C86 . C89 )) )) ) = ( IFEQ (C89 , 3 , ( C86 . 2 ) , ( C86 . C89 )) ) by L509 , FUNCOP_1:def 8
.= ( C86 . C89 ) by L510 , FUNCOP_1:def 8;
thus L512: thesis by L511;
end;
L513: ((C89 <> 2 & C89 <> 3) implies ( IFEQ (C89 , 2 , ( C86 . 3 ) , ( IFEQ (C89 , 3 , ( C86 . 2 ) , ( C86 . C89 )) )) ) = ( C88 . C89 )) by L508 , L500 , L502;
thus L514: thesis by L513 , L500 , L502 , L507 , L503;
end;
take C88;
L515: ( Seg ( len C86 ) ) = ( dom C86 ) by FINSEQ_1:def 3;
thus L516: thesis by L515 , L499 , L501 , FINSEQ_1:def 3;
end;
uniqueness
proof
let C90 , C91 being (FinSequence of ( NAT ));
assume that
L517: ( len C90 ) = ( len C86 )
and
L518: (for R1 being (Element of ( NAT )) holds (R1 in ( dom C86 ) implies ( C90 . R1 ) = ( IFEQ (R1 , 2 , ( C86 . 3 ) , ( IFEQ (R1 , 3 , ( C86 . 2 ) , ( C86 . R1 )) )) )))
and
L519: ( len C91 ) = ( len C86 )
and
L520: (for R1 being (Element of ( NAT )) holds (R1 in ( dom C86 ) implies ( C91 . R1 ) = ( IFEQ (R1 , 2 , ( C86 . 3 ) , ( IFEQ (R1 , 3 , ( C86 . 2 ) , ( C86 . R1 )) )) )));
L521: ( dom C86 ) = ( Seg ( len C91 ) ) by L519 , FINSEQ_1:def 3
.= ( dom C91 ) by FINSEQ_1:def 3;
L522:
now
let C92 being Nat;
assume L523: C92 in ( dom C86 );
L524:
now
per cases ;
suppose L525: C92 = 2;

L526: ( IFEQ (C92 , 2 , ( C86 . 3 ) , ( IFEQ (C92 , 3 , ( C86 . 2 ) , ( C86 . C92 )) )) ) = ( C86 . 3 ) by L525 , FUNCOP_1:def 8;
L527: ( C91 . C92 ) = ( C86 . 3 ) by L526 , L520 , L523;
thus L528: ( C90 . C92 ) = ( C91 . C92 ) by L527 , L518 , L523 , L526;
end;
suppose L529: C92 = 3;

L530: (C92 = 3 implies ( IFEQ (C92 , 2 , ( C86 . 3 ) , ( IFEQ (C92 , 3 , ( C86 . 2 ) , ( C86 . C92 )) )) ) = ( C86 . 2 ))
proof
assume L531: C92 = 3;
L532: ( IFEQ (C92 , 2 , ( C86 . 3 ) , ( IFEQ (C92 , 3 , ( C86 . 2 ) , ( C86 . C92 )) )) ) = ( IFEQ (C92 , 3 , ( C86 . 2 ) , ( C86 . C92 )) ) by L531 , FUNCOP_1:def 8
.= ( C86 . 2 ) by L531 , FUNCOP_1:def 8;
thus L533: thesis by L532;
end;
L534: ( C91 . C92 ) = ( C86 . 2 ) by L530 , L520 , L523 , L529;
thus L535: ( C90 . C92 ) = ( C91 . C92 ) by L534 , L518 , L523 , L529 , L530;
end;
suppose L536: (C92 <> 2 & C92 <> 3);

L537: ((C92 <> 2 & C92 <> 3) implies ( IFEQ (C92 , 2 , ( C86 . 3 ) , ( IFEQ (C92 , 3 , ( C86 . 2 ) , ( C86 . C92 )) )) ) = ( C86 . C92 ))
proof
assume that
L538: C92 <> 2
and
L539: C92 <> 3;
L540: ( IFEQ (C92 , 2 , ( C86 . 3 ) , ( IFEQ (C92 , 3 , ( C86 . 2 ) , ( C86 . C92 )) )) ) = ( IFEQ (C92 , 3 , ( C86 . 2 ) , ( C86 . C92 )) ) by L538 , FUNCOP_1:def 8
.= ( C86 . C92 ) by L539 , FUNCOP_1:def 8;
thus L541: thesis by L540;
end;
L542: ( C91 . C92 ) = ( C86 . C92 ) by L537 , L520 , L523 , L536;
thus L543: ( C90 . C92 ) = ( C91 . C92 ) by L542 , L518 , L523 , L536 , L537;
end;
end;
thus L545: ( C90 . C92 ) = ( C91 . C92 ) by L524;
end;
L546: ( dom C86 ) = ( Seg ( len C90 ) ) by L517 , FINSEQ_1:def 3
.= ( dom C90 ) by FINSEQ_1:def 3;
thus L547: thesis by L546 , L521 , L522 , FINSEQ_1:13;
end;
end;
theorem
L549: (for R4 being (Element of ( NAT )) holds (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds (( len R8 ) >= 4 implies (( ( IDEAoperationA (R8 , R9 , R4) ) . 1 ) is_expressible_by R4 & ( ( IDEAoperationA (R8 , R9 , R4) ) . 2 ) is_expressible_by R4 & ( ( IDEAoperationA (R8 , R9 , R4) ) . 3 ) is_expressible_by R4 & ( ( IDEAoperationA (R8 , R9 , R4) ) . 4 ) is_expressible_by R4)))))
proof
let R4 being (Element of ( NAT ));
let R8 being (FinSequence of ( NAT ));
let R9 being (FinSequence of ( NAT ));
assume L550: ( len R8 ) >= 4;
L551: 1 <= ( len R8 ) by L550 , XXREAL_0:2;
L552: 1 in ( Seg ( len R8 ) ) by L551 , FINSEQ_1:1;
L553: 1 in ( dom R8 ) by L552 , FINSEQ_1:def 3;
L554: ( ( IDEAoperationA (R8 , R9 , R4) ) . 1 ) = ( MUL_MOD (( R8 . 1 ) , ( R9 . 1 ) , R4) ) by L553 , L409;
L555: 3 <= ( len R8 ) by L550 , XXREAL_0:2;
L556: 3 in ( Seg ( len R8 ) ) by L555 , FINSEQ_1:1;
L557: 3 in ( dom R8 ) by L556 , FINSEQ_1:def 3;
L558: ( ( IDEAoperationA (R8 , R9 , R4) ) . 3 ) = ( ADD_MOD (( R8 . 3 ) , ( R9 . 3 ) , R4) ) by L557 , L409;
L559: 2 <= ( len R8 ) by L550 , XXREAL_0:2;
L560: 2 in ( Seg ( len R8 ) ) by L559 , FINSEQ_1:1;
L561: 2 in ( dom R8 ) by L560 , FINSEQ_1:def 3;
L562: ( ( IDEAoperationA (R8 , R9 , R4) ) . 2 ) = ( ADD_MOD (( R8 . 2 ) , ( R9 . 2 ) , R4) ) by L561 , L409;
L563: 4 in ( Seg ( len R8 ) ) by L550 , FINSEQ_1:1;
L564: 4 in ( dom R8 ) by L563 , FINSEQ_1:def 3;
L565: ( ( IDEAoperationA (R8 , R9 , R4) ) . 4 ) = ( MUL_MOD (( R8 . 4 ) , ( R9 . 4 ) , R4) ) by L564 , L409;
thus L566: thesis by L565 , L554 , L562 , L558 , L185 , L386;
end;
theorem
L567: (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds (for B37 being non  empty (Element of ( NAT )) holds (( len R8 ) >= 4 implies (( ( IDEAoperationB (R8 , R9 , B37) ) . 1 ) is_expressible_by B37 & ( ( IDEAoperationB (R8 , R9 , B37) ) . 2 ) is_expressible_by B37 & ( ( IDEAoperationB (R8 , R9 , B37) ) . 3 ) is_expressible_by B37 & ( ( IDEAoperationB (R8 , R9 , B37) ) . 4 ) is_expressible_by B37)))))
proof
let R8 being (FinSequence of ( NAT ));
let R9 being (FinSequence of ( NAT ));
let C93 being non  empty (Element of ( NAT ));
assume L568: ( len R8 ) >= 4;
L569: 1 <= ( len R8 ) by L568 , XXREAL_0:2;
L570: 1 in ( Seg ( len R8 ) ) by L569 , FINSEQ_1:1;
L571: 1 in ( dom R8 ) by L570 , FINSEQ_1:def 3;
L572: ( ( IDEAoperationB (R8 , R9 , C93) ) . 1 ) = ( Absval ( ( C93 -BinarySequence ( R8 . 1 ) ) 'xor' ( C93 -BinarySequence ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C93 -BinarySequence ( R8 . 1 ) ) 'xor' ( C93 -BinarySequence ( R8 . 3 ) ) ) ) , ( R9 . 5 ) , C93) ) , ( Absval ( ( C93 -BinarySequence ( R8 . 2 ) ) 'xor' ( C93 -BinarySequence ( R8 . 4 ) ) ) ) , C93) ) , ( R9 . 6 ) , C93) ) ) ) ) by L571 , L449;
L573: ( ( IDEAoperationB (R8 , R9 , C93) ) . 1 ) < ( 2 to_power C93 ) by L572 , BINARI_3:1;
L574: 3 <= ( len R8 ) by L568 , XXREAL_0:2;
L575: 3 in ( Seg ( len R8 ) ) by L574 , FINSEQ_1:1;
L576: 3 in ( dom R8 ) by L575 , FINSEQ_1:def 3;
L577: ( ( IDEAoperationB (R8 , R9 , C93) ) . 3 ) = ( Absval ( ( C93 -BinarySequence ( R8 . 3 ) ) 'xor' ( C93 -BinarySequence ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C93 -BinarySequence ( R8 . 1 ) ) 'xor' ( C93 -BinarySequence ( R8 . 3 ) ) ) ) , ( R9 . 5 ) , C93) ) , ( Absval ( ( C93 -BinarySequence ( R8 . 2 ) ) 'xor' ( C93 -BinarySequence ( R8 . 4 ) ) ) ) , C93) ) , ( R9 . 6 ) , C93) ) ) ) ) by L576 , L449;
L578: ( ( IDEAoperationB (R8 , R9 , C93) ) . 3 ) < ( 2 to_power C93 ) by L577 , BINARI_3:1;
L579: 2 <= ( len R8 ) by L568 , XXREAL_0:2;
L580: 2 in ( Seg ( len R8 ) ) by L579 , FINSEQ_1:1;
L581: 2 in ( dom R8 ) by L580 , FINSEQ_1:def 3;
L582: ( ( IDEAoperationB (R8 , R9 , C93) ) . 2 ) = ( Absval ( ( C93 -BinarySequence ( R8 . 2 ) ) 'xor' ( C93 -BinarySequence ( ADD_MOD (( MUL_MOD (( Absval ( ( C93 -BinarySequence ( R8 . 1 ) ) 'xor' ( C93 -BinarySequence ( R8 . 3 ) ) ) ) , ( R9 . 5 ) , C93) ) , ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C93 -BinarySequence ( R8 . 1 ) ) 'xor' ( C93 -BinarySequence ( R8 . 3 ) ) ) ) , ( R9 . 5 ) , C93) ) , ( Absval ( ( C93 -BinarySequence ( R8 . 2 ) ) 'xor' ( C93 -BinarySequence ( R8 . 4 ) ) ) ) , C93) ) , ( R9 . 6 ) , C93) ) , C93) ) ) ) ) by L581 , L449;
L583: ( ( IDEAoperationB (R8 , R9 , C93) ) . 2 ) < ( 2 to_power C93 ) by L582 , BINARI_3:1;
L584: 4 in ( Seg ( len R8 ) ) by L568 , FINSEQ_1:1;
L585: 4 in ( dom R8 ) by L584 , FINSEQ_1:def 3;
L586: ( ( IDEAoperationB (R8 , R9 , C93) ) . 4 ) = ( Absval ( ( C93 -BinarySequence ( R8 . 4 ) ) 'xor' ( C93 -BinarySequence ( ADD_MOD (( MUL_MOD (( Absval ( ( C93 -BinarySequence ( R8 . 1 ) ) 'xor' ( C93 -BinarySequence ( R8 . 3 ) ) ) ) , ( R9 . 5 ) , C93) ) , ( MUL_MOD (( ADD_MOD (( MUL_MOD (( Absval ( ( C93 -BinarySequence ( R8 . 1 ) ) 'xor' ( C93 -BinarySequence ( R8 . 3 ) ) ) ) , ( R9 . 5 ) , C93) ) , ( Absval ( ( C93 -BinarySequence ( R8 . 2 ) ) 'xor' ( C93 -BinarySequence ( R8 . 4 ) ) ) ) , C93) ) , ( R9 . 6 ) , C93) ) , C93) ) ) ) ) by L585 , L449;
L587: ( ( IDEAoperationB (R8 , R9 , C93) ) . 4 ) < ( 2 to_power C93 ) by L586 , BINARI_3:1;
thus L588: thesis by L587 , L573 , L583 , L578 , L151;
end;
L589: (for R8 being (FinSequence of ( NAT )) holds (for R1 being (Element of ( NAT )) holds ((R1 = 2 & R1 in ( dom R8 )) implies ( ( IDEAoperationC R8 ) . R1 ) = ( R8 . 3 ))))
proof
let R8 being (FinSequence of ( NAT ));
let C94 being (Element of ( NAT ));
assume that
L590: C94 = 2
and
L591: C94 in ( dom R8 );
L592: ( ( IDEAoperationC R8 ) . C94 ) = ( IFEQ (C94 , 2 , ( R8 . 3 ) , ( IFEQ (C94 , 3 , ( R8 . 2 ) , ( R8 . C94 )) )) ) by L591 , L489
.= ( R8 . 3 ) by L590 , FUNCOP_1:def 8;
thus L593: thesis by L592;
end;
L594: (for R8 being (FinSequence of ( NAT )) holds (for R1 being (Element of ( NAT )) holds ((R1 = 3 & R1 in ( dom R8 )) implies ( ( IDEAoperationC R8 ) . R1 ) = ( R8 . 2 ))))
proof
let R8 being (FinSequence of ( NAT ));
let C95 being (Element of ( NAT ));
assume that
L595: C95 = 3
and
L596: C95 in ( dom R8 );
L597: ( ( IDEAoperationC R8 ) . C95 ) = ( IFEQ (C95 , 2 , ( R8 . 3 ) , ( IFEQ (C95 , 3 , ( R8 . 2 ) , ( R8 . C95 )) )) ) by L596 , L489
.= ( IFEQ (C95 , 3 , ( R8 . 2 ) , ( R8 . C95 )) ) by L595 , FUNCOP_1:def 8
.= ( R8 . 2 ) by L595 , FUNCOP_1:def 8;
thus L598: thesis by L597;
end;
L599: (for R8 being (FinSequence of ( NAT )) holds (for R1 being (Element of ( NAT )) holds ((R1 <> 2 & R1 <> 3 & R1 in ( dom R8 )) implies ( ( IDEAoperationC R8 ) . R1 ) = ( R8 . R1 ))))
proof
let R8 being (FinSequence of ( NAT ));
let C96 being (Element of ( NAT ));
assume that
L600: C96 <> 2
and
L601: C96 <> 3
and
L602: C96 in ( dom R8 );
L603: ( ( IDEAoperationC R8 ) . C96 ) = ( IFEQ (C96 , 2 , ( R8 . 3 ) , ( IFEQ (C96 , 3 , ( R8 . 2 ) , ( R8 . C96 )) )) ) by L602 , L489
.= ( IFEQ (C96 , 3 , ( R8 . 2 ) , ( R8 . C96 )) ) by L600 , FUNCOP_1:def 8
.= ( R8 . C96 ) by L601 , FUNCOP_1:def 8;
thus L604: thesis by L603;
end;
theorem
L605: (for R4 being (Element of ( NAT )) holds (for R8 being (FinSequence of ( NAT )) holds ((( len R8 ) >= 4 & ( R8 . 1 ) is_expressible_by R4 & ( R8 . 2 ) is_expressible_by R4 & ( R8 . 3 ) is_expressible_by R4 & ( R8 . 4 ) is_expressible_by R4) implies (( ( IDEAoperationC R8 ) . 1 ) is_expressible_by R4 & ( ( IDEAoperationC R8 ) . 2 ) is_expressible_by R4 & ( ( IDEAoperationC R8 ) . 3 ) is_expressible_by R4 & ( ( IDEAoperationC R8 ) . 4 ) is_expressible_by R4))))
proof
let R4 being (Element of ( NAT ));
let R8 being (FinSequence of ( NAT ));
assume that
L606: ( len R8 ) >= 4
and
L607: (( R8 . 1 ) is_expressible_by R4 & ( R8 . 2 ) is_expressible_by R4 & ( R8 . 3 ) is_expressible_by R4 & ( R8 . 4 ) is_expressible_by R4);
L608: 1 <= ( len R8 ) by L606 , XXREAL_0:2;
L609: 1 in ( Seg ( len R8 ) ) by L608 , FINSEQ_1:1;
L610: 1 in ( dom R8 ) by L609 , FINSEQ_1:def 3;
L611: 3 <= ( len R8 ) by L606 , XXREAL_0:2;
L612: 3 in ( Seg ( len R8 ) ) by L611 , FINSEQ_1:1;
L613: 3 in ( dom R8 ) by L612 , FINSEQ_1:def 3;
L614: 2 <= ( len R8 ) by L606 , XXREAL_0:2;
L615: 2 in ( Seg ( len R8 ) ) by L614 , FINSEQ_1:1;
L616: 2 in ( dom R8 ) by L615 , FINSEQ_1:def 3;
L617: 4 in ( Seg ( len R8 ) ) by L606 , FINSEQ_1:1;
L618: 4 in ( dom R8 ) by L617 , FINSEQ_1:def 3;
thus L619: thesis by L618 , L607 , L610 , L616 , L613 , L589 , L594 , L599;
end;
theorem
L620: (for B38 being non  empty (Element of ( NAT )) holds (for R8 being (FinSequence of ( NAT )) holds (for R10 being (FinSequence of ( NAT )) holds (for R11 being (FinSequence of ( NAT )) holds ((( ( 2 to_power B38 ) + 1 ) is  prime & ( len R8 ) >= 4 & ( R8 . 1 ) is_expressible_by B38 & ( R8 . 2 ) is_expressible_by B38 & ( R8 . 3 ) is_expressible_by B38 & ( R8 . 4 ) is_expressible_by B38 & ( R10 . 1 ) is_expressible_by B38 & ( R10 . 2 ) is_expressible_by B38 & ( R10 . 3 ) is_expressible_by B38 & ( R10 . 4 ) is_expressible_by B38 & ( R11 . 1 ) = ( INV_MOD (( R10 . 1 ) , B38) ) & ( R11 . 2 ) = ( NEG_MOD (( R10 . 2 ) , B38) ) & ( R11 . 3 ) = ( NEG_MOD (( R10 . 3 ) , B38) ) & ( R11 . 4 ) = ( INV_MOD (( R10 . 4 ) , B38) )) implies ( IDEAoperationA (( IDEAoperationA (R8 , R10 , B38) ) , R11 , B38) ) = R8)))))
proof
let C97 being non  empty (Element of ( NAT ));
let C98 , C99 , C100 being (FinSequence of ( NAT ));
assume that
L621: ( ( 2 to_power C97 ) + 1 ) is  prime
and
L622: ( len C98 ) >= 4
and
L623: ( C98 . 1 ) is_expressible_by C97
and
L624: ( C98 . 2 ) is_expressible_by C97
and
L625: ( C98 . 3 ) is_expressible_by C97
and
L626: ( C98 . 4 ) is_expressible_by C97
and
L627: ( C99 . 1 ) is_expressible_by C97
and
L628: ( C99 . 2 ) is_expressible_by C97
and
L629: ( C99 . 3 ) is_expressible_by C97
and
L630: ( C99 . 4 ) is_expressible_by C97
and
L631: ( C100 . 1 ) = ( INV_MOD (( C99 . 1 ) , C97) )
and
L632: ( C100 . 2 ) = ( NEG_MOD (( C99 . 2 ) , C97) )
and
L633: ( C100 . 3 ) = ( NEG_MOD (( C99 . 3 ) , C97) )
and
L634: ( C100 . 4 ) = ( INV_MOD (( C99 . 4 ) , C97) );
L635: ( C100 . 4 ) is_expressible_by C97 by L621 , L630 , L634 , L234;
L636: 2 <= ( len C98 ) by L622 , XXREAL_0:2;
L637: 2 in ( Seg ( len C98 ) ) by L636 , FINSEQ_1:1;
L638: 2 in ( dom C98 ) by L637 , FINSEQ_1:def 3;
L639: ( Seg ( len C98 ) ) = ( dom C98 ) by FINSEQ_1:def 3;
L640: 4 in ( dom C98 ) by L639 , L622 , FINSEQ_1:1;
L641: 1 <= ( len C98 ) by L622 , XXREAL_0:2;
L642: 1 in ( Seg ( len C98 ) ) by L641 , FINSEQ_1:1;
L643: 1 in ( dom C98 ) by L642 , FINSEQ_1:def 3;
L644: 3 <= ( len C98 ) by L622 , XXREAL_0:2;
L645: 3 in ( Seg ( len C98 ) ) by L644 , FINSEQ_1:1;
L646: 3 in ( dom C98 ) by L645 , FINSEQ_1:def 3;
consider C101 being (FinSequence of ( NAT )) such that L647: C101 = ( IDEAoperationA (C98 , C99 , C97) );
consider C102 being (FinSequence of ( NAT )) such that L648: C102 = ( IDEAoperationA (C101 , C100 , C97) );
L649: ( C100 . 1 ) is_expressible_by C97 by L621 , L627 , L631 , L234;
L650:
now
let C103 being Nat;
assume L651: C103 in ( Seg ( len C98 ) );
L652: C103 in ( Seg ( len C101 ) ) by L651 , L647 , L409;
L653: C103 in ( dom C101 ) by L652 , FINSEQ_1:def 3;
L654: C103 in ( dom C98 ) by L651 , FINSEQ_1:def 3;
L655:
now
per cases ;
suppose L656: C103 = 1;

thus L657: ( C102 . C103 ) = ( MUL_MOD (( C101 . 1 ) , ( C100 . 1 ) , C97) ) by L656 , L648 , L653 , L409
.= ( MUL_MOD (( MUL_MOD (( C98 . 1 ) , ( C99 . 1 ) , C97) ) , ( C100 . 1 ) , C97) ) by L647 , L643 , L409
.= ( MUL_MOD (( C98 . 1 ) , ( MUL_MOD (( C99 . 1 ) , ( C100 . 1 ) , C97) ) , C97) ) by L621 , L623 , L627 , L649 , L334
.= ( MUL_MOD (1 , ( C98 . 1 ) , C97) ) by L621 , L627 , L631 , L234
.= ( C98 . C103 ) by L623 , L656 , L319;
end;
suppose L658: C103 = 2;

thus L659: ( C102 . C103 ) = ( ADD_MOD (( C101 . 2 ) , ( C100 . 2 ) , C97) ) by L658 , L648 , L653 , L409
.= ( ADD_MOD (( ADD_MOD (( C98 . 2 ) , ( C99 . 2 ) , C97) ) , ( C100 . 2 ) , C97) ) by L647 , L638 , L409
.= ( ADD_MOD (( C98 . 2 ) , ( ADD_MOD (( C99 . 2 ) , ( C100 . 2 ) , C97) ) , C97) ) by L183
.= ( ADD_MOD (( 0 ) , ( C98 . 2 ) , C97) ) by L628 , L632 , L174
.= ( C98 . C103 ) by L624 , L658 , L179;
end;
suppose L660: C103 = 3;

thus L661: ( C102 . C103 ) = ( ADD_MOD (( C101 . 3 ) , ( C100 . 3 ) , C97) ) by L660 , L648 , L653 , L409
.= ( ADD_MOD (( ADD_MOD (( C98 . 3 ) , ( C99 . 3 ) , C97) ) , ( C100 . 3 ) , C97) ) by L647 , L646 , L409
.= ( ADD_MOD (( C98 . 3 ) , ( ADD_MOD (( C99 . 3 ) , ( C100 . 3 ) , C97) ) , C97) ) by L183
.= ( ADD_MOD (( 0 ) , ( C98 . 3 ) , C97) ) by L629 , L633 , L174
.= ( C98 . C103 ) by L625 , L660 , L179;
end;
suppose L662: C103 = 4;

thus L663: ( C102 . C103 ) = ( MUL_MOD (( C101 . 4 ) , ( C100 . 4 ) , C97) ) by L662 , L648 , L653 , L409
.= ( MUL_MOD (( MUL_MOD (( C98 . 4 ) , ( C99 . 4 ) , C97) ) , ( C100 . 4 ) , C97) ) by L647 , L640 , L409
.= ( MUL_MOD (( C98 . 4 ) , ( MUL_MOD (( C99 . 4 ) , ( C100 . 4 ) , C97) ) , C97) ) by L621 , L626 , L630 , L635 , L334
.= ( MUL_MOD (1 , ( C98 . 4 ) , C97) ) by L621 , L630 , L634 , L234
.= ( C98 . C103 ) by L626 , L662 , L319;
end;
suppose L664: (C103 <> 1 & C103 <> 2 & C103 <> 3 & C103 <> 4);

thus L665: ( C102 . C103 ) = ( C101 . C103 ) by L664 , L648 , L653 , L409
.= ( C98 . C103 ) by L647 , L654 , L664 , L409;
end;
end;
thus L667: ( C102 . C103 ) = ( C98 . C103 ) by L655;
end;
L668: ( Seg ( len C98 ) ) = ( dom C98 ) by FINSEQ_1:def 3;
L669: ( Seg ( len C98 ) ) = ( Seg ( len C101 ) ) by L647 , L409
.= ( Seg ( len C102 ) ) by L648 , L409
.= ( dom C102 ) by FINSEQ_1:def 3;
thus L670: thesis by L669 , L647 , L648 , L668 , L650 , FINSEQ_1:13;
end;
theorem
L671: (for B39 being non  empty (Element of ( NAT )) holds (for R8 being (FinSequence of ( NAT )) holds (for R10 being (FinSequence of ( NAT )) holds (for R11 being (FinSequence of ( NAT )) holds ((( ( 2 to_power B39 ) + 1 ) is  prime & ( len R8 ) >= 4 & ( R8 . 1 ) is_expressible_by B39 & ( R8 . 2 ) is_expressible_by B39 & ( R8 . 3 ) is_expressible_by B39 & ( R8 . 4 ) is_expressible_by B39 & ( R10 . 1 ) is_expressible_by B39 & ( R10 . 2 ) is_expressible_by B39 & ( R10 . 3 ) is_expressible_by B39 & ( R10 . 4 ) is_expressible_by B39 & ( R11 . 1 ) = ( INV_MOD (( R10 . 1 ) , B39) ) & ( R11 . 2 ) = ( NEG_MOD (( R10 . 3 ) , B39) ) & ( R11 . 3 ) = ( NEG_MOD (( R10 . 2 ) , B39) ) & ( R11 . 4 ) = ( INV_MOD (( R10 . 4 ) , B39) )) implies ( IDEAoperationA (( IDEAoperationC ( IDEAoperationA (( IDEAoperationC R8 ) , R10 , B39) ) ) , R11 , B39) ) = R8)))))
proof
let C104 being non  empty (Element of ( NAT ));
let C105 , C106 , C107 being (FinSequence of ( NAT ));
assume that
L672: ( ( 2 to_power C104 ) + 1 ) is  prime
and
L673: ( len C105 ) >= 4
and
L674: ( C105 . 1 ) is_expressible_by C104
and
L675: ( C105 . 2 ) is_expressible_by C104
and
L676: ( C105 . 3 ) is_expressible_by C104
and
L677: ( C105 . 4 ) is_expressible_by C104
and
L678: ( C106 . 1 ) is_expressible_by C104
and
L679: ( C106 . 2 ) is_expressible_by C104
and
L680: ( C106 . 3 ) is_expressible_by C104
and
L681: ( C106 . 4 ) is_expressible_by C104
and
L682: ( C107 . 1 ) = ( INV_MOD (( C106 . 1 ) , C104) )
and
L683: ( C107 . 2 ) = ( NEG_MOD (( C106 . 3 ) , C104) )
and
L684: ( C107 . 3 ) = ( NEG_MOD (( C106 . 2 ) , C104) )
and
L685: ( C107 . 4 ) = ( INV_MOD (( C106 . 4 ) , C104) );
L686: ( C107 . 1 ) is_expressible_by C104 by L672 , L678 , L682 , L234;
L687: 1 <= ( len C105 ) by L673 , XXREAL_0:2;
L688: 1 in ( Seg ( len C105 ) ) by L687 , FINSEQ_1:1;
L689: 1 in ( dom C105 ) by L688 , FINSEQ_1:def 3;
L690: 4 in ( Seg ( len C105 ) ) by L673 , FINSEQ_1:1;
L691: 4 in ( dom C105 ) by L690 , FINSEQ_1:def 3;
L692: 3 <= ( len C105 ) by L673 , XXREAL_0:2;
L693: 3 in ( Seg ( len C105 ) ) by L692 , FINSEQ_1:1;
L694: 3 in ( dom C105 ) by L693 , FINSEQ_1:def 3;
L695: ( C107 . 4 ) is_expressible_by C104 by L672 , L681 , L685 , L234;
consider C108 being (FinSequence of ( NAT )) such that L696: C108 = ( IDEAoperationC C105 );
L697: 4 in ( Seg ( len C108 ) ) by L696 , L690 , L489;
L698: 4 in ( dom C108 ) by L697 , FINSEQ_1:def 3;
L699: 1 in ( Seg ( len C108 ) ) by L696 , L688 , L489;
L700: 1 in ( dom C108 ) by L699 , FINSEQ_1:def 3;
L701: 2 <= ( len C105 ) by L673 , XXREAL_0:2;
L702: 2 in ( Seg ( len C105 ) ) by L701 , FINSEQ_1:1;
L703: 2 in ( dom C105 ) by L702 , FINSEQ_1:def 3;
L704: 3 in ( Seg ( len C108 ) ) by L696 , L693 , L489;
L705: 3 in ( dom C108 ) by L704 , FINSEQ_1:def 3;
L706: 2 in ( Seg ( len C108 ) ) by L696 , L702 , L489;
L707: 2 in ( dom C108 ) by L706 , FINSEQ_1:def 3;
consider C109 being (FinSequence of ( NAT )) such that L708: C109 = ( IDEAoperationA (C108 , C106 , C104) );
L709: ( len C109 ) = ( len C108 ) by L708 , L409;
L710: 2 in ( Seg ( len C109 ) ) by L709 , L696 , L702 , L489;
L711: 2 in ( dom C109 ) by L710 , FINSEQ_1:def 3;
L712: 4 in ( Seg ( len C109 ) ) by L696 , L709 , L690 , L489;
L713: 4 in ( dom C109 ) by L712 , FINSEQ_1:def 3;
L714: 1 in ( Seg ( len C109 ) ) by L696 , L709 , L688 , L489;
L715: 1 in ( dom C109 ) by L714 , FINSEQ_1:def 3;
L716: 3 in ( Seg ( len C109 ) ) by L696 , L709 , L693 , L489;
L717: 3 in ( dom C109 ) by L716 , FINSEQ_1:def 3;
consider C110 being (FinSequence of ( NAT )) such that L718: C110 = ( IDEAoperationC C109 );
L719: ( len C110 ) = ( len C109 ) by L718 , L489;
L720: 2 in ( Seg ( len C110 ) ) by L719 , L696 , L709 , L702 , L489;
L721: 2 in ( dom C110 ) by L720 , FINSEQ_1:def 3;
L722: 4 in ( Seg ( len C110 ) ) by L696 , L709 , L719 , L690 , L489;
L723: 4 in ( dom C110 ) by L722 , FINSEQ_1:def 3;
L724: 3 in ( Seg ( len C110 ) ) by L696 , L709 , L719 , L693 , L489;
L725: 3 in ( dom C110 ) by L724 , FINSEQ_1:def 3;
consider C111 being (FinSequence of ( NAT )) such that L726: C111 = ( IDEAoperationA (C110 , C107 , C104) );
L727: 1 in ( Seg ( len C110 ) ) by L696 , L709 , L719 , L688 , L489;
L728: 1 in ( dom C110 ) by L727 , FINSEQ_1:def 3;
L729:
now
let C112 being Nat;
assume L730: C112 in ( Seg ( len C105 ) );
L731: C112 in ( dom C105 ) by L730 , FINSEQ_1:def 3;
L732: C112 in ( Seg ( len C108 ) ) by L696 , L730 , L489;
L733: C112 in ( Seg ( len C109 ) ) by L732 , L708 , L409;
L734: C112 in ( dom C109 ) by L733 , FINSEQ_1:def 3;
L735: C112 in ( Seg ( len C110 ) ) by L718 , L733 , L489;
L736: C112 in ( dom C110 ) by L735 , FINSEQ_1:def 3;
L737: C112 in ( dom C108 ) by L732 , FINSEQ_1:def 3;
L738:
now
per cases ;
suppose L739: C112 = 1;

thus L740: ( C111 . C112 ) = ( MUL_MOD (( C110 . 1 ) , ( C107 . 1 ) , C104) ) by L739 , L726 , L728 , L409
.= ( MUL_MOD (( C109 . 1 ) , ( C107 . 1 ) , C104) ) by L718 , L715 , L599
.= ( MUL_MOD (( MUL_MOD (( C108 . 1 ) , ( C106 . 1 ) , C104) ) , ( C107 . 1 ) , C104) ) by L708 , L700 , L409
.= ( MUL_MOD (( MUL_MOD (( C105 . 1 ) , ( C106 . 1 ) , C104) ) , ( C107 . 1 ) , C104) ) by L696 , L689 , L599
.= ( MUL_MOD (( C105 . 1 ) , ( MUL_MOD (( C106 . 1 ) , ( C107 . 1 ) , C104) ) , C104) ) by L672 , L674 , L678 , L686 , L334
.= ( MUL_MOD (1 , ( C105 . 1 ) , C104) ) by L672 , L678 , L682 , L234
.= ( C105 . C112 ) by L674 , L739 , L319;
end;
suppose L741: C112 = 2;

thus L742: ( C111 . C112 ) = ( ADD_MOD (( C110 . 2 ) , ( C107 . 2 ) , C104) ) by L741 , L726 , L721 , L409
.= ( ADD_MOD (( C109 . 3 ) , ( C107 . 2 ) , C104) ) by L718 , L711 , L589
.= ( ADD_MOD (( ADD_MOD (( C108 . 3 ) , ( C106 . 3 ) , C104) ) , ( C107 . 2 ) , C104) ) by L708 , L705 , L409
.= ( ADD_MOD (( ADD_MOD (( C105 . 2 ) , ( C106 . 3 ) , C104) ) , ( C107 . 2 ) , C104) ) by L696 , L694 , L594
.= ( ADD_MOD (( C105 . 2 ) , ( ADD_MOD (( C106 . 3 ) , ( C107 . 2 ) , C104) ) , C104) ) by L183
.= ( ADD_MOD (( 0 ) , ( C105 . 2 ) , C104) ) by L680 , L683 , L174
.= ( C105 . C112 ) by L675 , L741 , L179;
end;
suppose L743: C112 = 3;

thus L744: ( C111 . C112 ) = ( ADD_MOD (( C110 . 3 ) , ( C107 . 3 ) , C104) ) by L743 , L726 , L725 , L409
.= ( ADD_MOD (( C109 . 2 ) , ( C107 . 3 ) , C104) ) by L718 , L717 , L594
.= ( ADD_MOD (( ADD_MOD (( C108 . 2 ) , ( C106 . 2 ) , C104) ) , ( C107 . 3 ) , C104) ) by L708 , L707 , L409
.= ( ADD_MOD (( ADD_MOD (( C105 . 3 ) , ( C106 . 2 ) , C104) ) , ( C107 . 3 ) , C104) ) by L696 , L703 , L589
.= ( ADD_MOD (( C105 . 3 ) , ( ADD_MOD (( C106 . 2 ) , ( C107 . 3 ) , C104) ) , C104) ) by L183
.= ( ADD_MOD (( 0 ) , ( C105 . 3 ) , C104) ) by L679 , L684 , L174
.= ( C105 . C112 ) by L676 , L743 , L179;
end;
suppose L745: C112 = 4;

thus L746: ( C111 . C112 ) = ( MUL_MOD (( C110 . 4 ) , ( C107 . 4 ) , C104) ) by L745 , L726 , L723 , L409
.= ( MUL_MOD (( C109 . 4 ) , ( C107 . 4 ) , C104) ) by L718 , L713 , L599
.= ( MUL_MOD (( MUL_MOD (( C108 . 4 ) , ( C106 . 4 ) , C104) ) , ( C107 . 4 ) , C104) ) by L708 , L698 , L409
.= ( MUL_MOD (( MUL_MOD (( C105 . 4 ) , ( C106 . 4 ) , C104) ) , ( C107 . 4 ) , C104) ) by L696 , L691 , L599
.= ( MUL_MOD (( C105 . 4 ) , ( MUL_MOD (( C106 . 4 ) , ( C107 . 4 ) , C104) ) , C104) ) by L672 , L677 , L681 , L695 , L334
.= ( MUL_MOD (1 , ( C105 . 4 ) , C104) ) by L672 , L681 , L685 , L234
.= ( C105 . C112 ) by L677 , L745 , L319;
end;
suppose L747: (C112 <> 1 & C112 <> 2 & C112 <> 3 & C112 <> 4);

thus L748: ( C111 . C112 ) = ( C110 . C112 ) by L747 , L726 , L736 , L409
.= ( C109 . C112 ) by L718 , L734 , L747 , L599
.= ( C108 . C112 ) by L708 , L737 , L747 , L409
.= ( C105 . C112 ) by L696 , L731 , L747 , L599;
end;
end;
thus L750: ( C111 . C112 ) = ( C105 . C112 ) by L738;
end;
L751: ( Seg ( len C105 ) ) = ( dom C105 ) by FINSEQ_1:def 3;
L752: ( Seg ( len C105 ) ) = ( Seg ( len C108 ) ) by L696 , L489
.= ( Seg ( len C109 ) ) by L708 , L409
.= ( Seg ( len C110 ) ) by L718 , L489
.= ( Seg ( len C111 ) ) by L726 , L409
.= ( dom C111 ) by FINSEQ_1:def 3;
thus L753: thesis by L752 , L696 , L708 , L718 , L726 , L751 , L729 , FINSEQ_1:13;
end;
theorem
L754: (for B40 being non  empty (Element of ( NAT )) holds (for R8 being (FinSequence of ( NAT )) holds (for R10 being (FinSequence of ( NAT )) holds (for R11 being (FinSequence of ( NAT )) holds ((( len R8 ) >= 4 & ( R8 . 1 ) is_expressible_by B40 & ( R8 . 2 ) is_expressible_by B40 & ( R8 . 3 ) is_expressible_by B40 & ( R8 . 4 ) is_expressible_by B40 & ( R11 . 5 ) = ( R10 . 5 ) & ( R11 . 6 ) = ( R10 . 6 )) implies ( IDEAoperationB (( IDEAoperationB (R8 , R10 , B40) ) , R11 , B40) ) = R8)))))
proof
let C113 being non  empty (Element of ( NAT ));
let C114 , C115 , C116 being (FinSequence of ( NAT ));
assume that
L755: ( len C114 ) >= 4
and
L756: ( C114 . 1 ) is_expressible_by C113
and
L757: ( C114 . 2 ) is_expressible_by C113
and
L758: ( C114 . 3 ) is_expressible_by C113
and
L759: ( C114 . 4 ) is_expressible_by C113
and
L760: ( C116 . 5 ) = ( C115 . 5 )
and
L761: ( C116 . 6 ) = ( C115 . 6 );
consider C117 being (Element of ( NAT )) such that L762: C117 = ( MUL_MOD (( Absval ( ( C113 -BinarySequence ( C114 . 1 ) ) 'xor' ( C113 -BinarySequence ( C114 . 3 ) ) ) ) , ( C115 . 5 ) , C113) );
consider C118 being (Element of ( NAT )) such that L763: C118 = ( MUL_MOD (( ADD_MOD (C117 , ( Absval ( ( C113 -BinarySequence ( C114 . 2 ) ) 'xor' ( C113 -BinarySequence ( C114 . 4 ) ) ) ) , C113) ) , ( C115 . 6 ) , C113) );
consider C119 being (FinSequence of ( NAT )) such that L764: C119 = ( IDEAoperationB (C114 , C115 , C113) );
L765: 1 <= ( len C114 ) by L755 , XXREAL_0:2;
L766: 1 in ( Seg ( len C114 ) ) by L765 , FINSEQ_1:1;
L767: 1 in ( dom C114 ) by L766 , FINSEQ_1:def 3;
L768: ( C119 . 1 ) = ( Absval ( ( C113 -BinarySequence ( C114 . 1 ) ) 'xor' ( C113 -BinarySequence C118 ) ) ) by L767 , L762 , L763 , L764 , L449;
consider C120 being (Element of ( NAT )) such that L769: C120 = ( MUL_MOD (( Absval ( ( C113 -BinarySequence ( C119 . 1 ) ) 'xor' ( C113 -BinarySequence ( C119 . 3 ) ) ) ) , ( C116 . 5 ) , C113) );
L770: 3 <= ( len C114 ) by L755 , XXREAL_0:2;
L771: 3 in ( Seg ( len C114 ) ) by L770 , FINSEQ_1:1;
L772: 3 in ( dom C114 ) by L771 , FINSEQ_1:def 3;
L773: ( C119 . 3 ) = ( Absval ( ( C113 -BinarySequence ( C114 . 3 ) ) 'xor' ( C113 -BinarySequence C118 ) ) ) by L772 , L762 , L763 , L764 , L449;
L774: C120 = ( MUL_MOD (( Absval ( ( ( C113 -BinarySequence ( C114 . 1 ) ) 'xor' ( C113 -BinarySequence C118 ) ) 'xor' ( C113 -BinarySequence ( Absval ( ( C113 -BinarySequence ( C114 . 3 ) ) 'xor' ( C113 -BinarySequence C118 ) ) ) ) ) ) , ( C116 . 5 ) , C113) ) by L773 , L769 , L768 , BINARI_3:36
.= ( MUL_MOD (( Absval ( ( ( C113 -BinarySequence ( C114 . 1 ) ) 'xor' ( C113 -BinarySequence C118 ) ) 'xor' ( ( C113 -BinarySequence ( C114 . 3 ) ) 'xor' ( C113 -BinarySequence C118 ) ) ) ) , ( C116 . 5 ) , C113) ) by BINARI_3:36
.= ( MUL_MOD (( Absval ( ( C113 -BinarySequence ( C114 . 1 ) ) 'xor' ( ( C113 -BinarySequence C118 ) 'xor' ( ( C113 -BinarySequence C118 ) 'xor' ( C113 -BinarySequence ( C114 . 3 ) ) ) ) ) ) , ( C116 . 5 ) , C113) ) by L142
.= ( MUL_MOD (( Absval ( ( C113 -BinarySequence ( C114 . 1 ) ) 'xor' ( ( ( C113 -BinarySequence C118 ) 'xor' ( C113 -BinarySequence C118 ) ) 'xor' ( C113 -BinarySequence ( C114 . 3 ) ) ) ) ) , ( C116 . 5 ) , C113) ) by L142
.= ( MUL_MOD (( Absval ( ( C113 -BinarySequence ( C114 . 1 ) ) 'xor' ( ( ZERO C113 ) 'xor' ( C113 -BinarySequence ( C114 . 3 ) ) ) ) ) , ( C116 . 5 ) , C113) ) by L112
.= C117 by L760 , L762 , L131;
consider C121 being (Element of ( NAT )) such that L775: C121 = ( MUL_MOD (( ADD_MOD (C120 , ( Absval ( ( C113 -BinarySequence ( C119 . 2 ) ) 'xor' ( C113 -BinarySequence ( C119 . 4 ) ) ) ) , C113) ) , ( C116 . 6 ) , C113) );
consider C122 being (Element of ( NAT )) such that L776: C122 = ( ADD_MOD (C117 , C118 , C113) );
L777: 2 <= ( len C114 ) by L755 , XXREAL_0:2;
L778: 2 in ( Seg ( len C114 ) ) by L777 , FINSEQ_1:1;
L779: 2 in ( dom C114 ) by L778 , FINSEQ_1:def 3;
L780: ( C119 . 2 ) = ( Absval ( ( C113 -BinarySequence ( C114 . 2 ) ) 'xor' ( C113 -BinarySequence C122 ) ) ) by L779 , L762 , L763 , L776 , L764 , L449;
consider C123 being (FinSequence of ( NAT )) such that L781: C123 = ( IDEAoperationB (C119 , C116 , C113) );
L782: 4 in ( Seg ( len C114 ) ) by L755 , FINSEQ_1:1;
L783: 4 in ( dom C114 ) by L782 , FINSEQ_1:def 3;
L784: ( C119 . 4 ) = ( Absval ( ( C113 -BinarySequence ( C114 . 4 ) ) 'xor' ( C113 -BinarySequence C122 ) ) ) by L783 , L762 , L763 , L776 , L764 , L449;
L785: C121 = ( MUL_MOD (( ADD_MOD (C117 , ( Absval ( ( ( C113 -BinarySequence ( C114 . 2 ) ) 'xor' ( C113 -BinarySequence C122 ) ) 'xor' ( C113 -BinarySequence ( Absval ( ( C113 -BinarySequence ( C114 . 4 ) ) 'xor' ( C113 -BinarySequence C122 ) ) ) ) ) ) , C113) ) , ( C116 . 6 ) , C113) ) by L784 , L775 , L780 , L774 , BINARI_3:36
.= ( MUL_MOD (( ADD_MOD (C117 , ( Absval ( ( ( C113 -BinarySequence ( C114 . 2 ) ) 'xor' ( C113 -BinarySequence C122 ) ) 'xor' ( ( C113 -BinarySequence ( C114 . 4 ) ) 'xor' ( C113 -BinarySequence C122 ) ) ) ) , C113) ) , ( C116 . 6 ) , C113) ) by BINARI_3:36
.= ( MUL_MOD (( ADD_MOD (C117 , ( Absval ( ( C113 -BinarySequence ( C114 . 2 ) ) 'xor' ( ( C113 -BinarySequence C122 ) 'xor' ( ( C113 -BinarySequence C122 ) 'xor' ( C113 -BinarySequence ( C114 . 4 ) ) ) ) ) ) , C113) ) , ( C116 . 6 ) , C113) ) by L142
.= ( MUL_MOD (( ADD_MOD (C117 , ( Absval ( ( C113 -BinarySequence ( C114 . 2 ) ) 'xor' ( ( ( C113 -BinarySequence C122 ) 'xor' ( C113 -BinarySequence C122 ) ) 'xor' ( C113 -BinarySequence ( C114 . 4 ) ) ) ) ) , C113) ) , ( C116 . 6 ) , C113) ) by L142
.= ( MUL_MOD (( ADD_MOD (C117 , ( Absval ( ( C113 -BinarySequence ( C114 . 2 ) ) 'xor' ( ( ZERO C113 ) 'xor' ( C113 -BinarySequence ( C114 . 4 ) ) ) ) ) , C113) ) , ( C116 . 6 ) , C113) ) by L112
.= C118 by L761 , L763 , L131;
L786:
now
let C124 being Nat;
assume L787: C124 in ( Seg ( len C114 ) );
L788: C124 in ( Seg ( len C119 ) ) by L787 , L764 , L449;
L789: C124 in ( dom C119 ) by L788 , FINSEQ_1:def 3;
L790: C124 in ( dom C114 ) by L787 , FINSEQ_1:def 3;
L791:
now
per cases ;
suppose L792: C124 = 1;

L793: ( C114 . 1 ) < ( 2 to_power C113 ) by L756 , L151;
thus L794: ( C123 . C124 ) = ( Absval ( ( C113 -BinarySequence ( C119 . 1 ) ) 'xor' ( C113 -BinarySequence C118 ) ) ) by L769 , L775 , L781 , L785 , L789 , L792 , L449
.= ( Absval ( ( ( C113 -BinarySequence ( C114 . 1 ) ) 'xor' ( C113 -BinarySequence C118 ) ) 'xor' ( C113 -BinarySequence C118 ) ) ) by L768 , BINARI_3:36
.= ( Absval ( ( C113 -BinarySequence ( C114 . 1 ) ) 'xor' ( ( C113 -BinarySequence C118 ) 'xor' ( C113 -BinarySequence C118 ) ) ) ) by L142
.= ( Absval ( ( ZERO C113 ) 'xor' ( C113 -BinarySequence ( C114 . 1 ) ) ) ) by L112
.= ( Absval ( C113 -BinarySequence ( C114 . 1 ) ) ) by L131
.= ( C114 . C124 ) by L792 , L793 , BINARI_3:35;
end;
suppose L795: C124 = 2;

L796: ( C114 . 2 ) < ( 2 to_power C113 ) by L757 , L151;
thus L797: ( C123 . C124 ) = ( Absval ( ( C113 -BinarySequence ( C119 . 2 ) ) 'xor' ( C113 -BinarySequence C122 ) ) ) by L776 , L769 , L775 , L781 , L774 , L785 , L789 , L795 , L449
.= ( Absval ( ( ( C113 -BinarySequence ( C114 . 2 ) ) 'xor' ( C113 -BinarySequence C122 ) ) 'xor' ( C113 -BinarySequence C122 ) ) ) by L780 , BINARI_3:36
.= ( Absval ( ( C113 -BinarySequence ( C114 . 2 ) ) 'xor' ( ( C113 -BinarySequence C122 ) 'xor' ( C113 -BinarySequence C122 ) ) ) ) by L142
.= ( Absval ( ( ZERO C113 ) 'xor' ( C113 -BinarySequence ( C114 . 2 ) ) ) ) by L112
.= ( Absval ( C113 -BinarySequence ( C114 . 2 ) ) ) by L131
.= ( C114 . C124 ) by L795 , L796 , BINARI_3:35;
end;
suppose L798: C124 = 3;

L799: ( C114 . 3 ) < ( 2 to_power C113 ) by L758 , L151;
thus L800: ( C123 . C124 ) = ( Absval ( ( C113 -BinarySequence ( C119 . 3 ) ) 'xor' ( C113 -BinarySequence C118 ) ) ) by L769 , L775 , L781 , L785 , L789 , L798 , L449
.= ( Absval ( ( ( C113 -BinarySequence ( C114 . 3 ) ) 'xor' ( C113 -BinarySequence C118 ) ) 'xor' ( C113 -BinarySequence C118 ) ) ) by L773 , BINARI_3:36
.= ( Absval ( ( C113 -BinarySequence ( C114 . 3 ) ) 'xor' ( ( C113 -BinarySequence C118 ) 'xor' ( C113 -BinarySequence C118 ) ) ) ) by L142
.= ( Absval ( ( ZERO C113 ) 'xor' ( C113 -BinarySequence ( C114 . 3 ) ) ) ) by L112
.= ( Absval ( C113 -BinarySequence ( C114 . 3 ) ) ) by L131
.= ( C114 . C124 ) by L798 , L799 , BINARI_3:35;
end;
suppose L801: C124 = 4;

L802: ( C114 . 4 ) < ( 2 to_power C113 ) by L759 , L151;
thus L803: ( C123 . C124 ) = ( Absval ( ( C113 -BinarySequence ( C119 . 4 ) ) 'xor' ( C113 -BinarySequence C122 ) ) ) by L776 , L769 , L775 , L781 , L774 , L785 , L789 , L801 , L449
.= ( Absval ( ( ( C113 -BinarySequence ( C114 . 4 ) ) 'xor' ( C113 -BinarySequence C122 ) ) 'xor' ( C113 -BinarySequence C122 ) ) ) by L784 , BINARI_3:36
.= ( Absval ( ( C113 -BinarySequence ( C114 . 4 ) ) 'xor' ( ( C113 -BinarySequence C122 ) 'xor' ( C113 -BinarySequence C122 ) ) ) ) by L142
.= ( Absval ( ( ZERO C113 ) 'xor' ( C113 -BinarySequence ( C114 . 4 ) ) ) ) by L112
.= ( Absval ( C113 -BinarySequence ( C114 . 4 ) ) ) by L131
.= ( C114 . C124 ) by L801 , L802 , BINARI_3:35;
end;
suppose L804: (C124 <> 1 & C124 <> 2 & C124 <> 3 & C124 <> 4);

thus L805: ( C123 . C124 ) = ( C119 . C124 ) by L804 , L781 , L789 , L449
.= ( C114 . C124 ) by L764 , L790 , L804 , L449;
end;
end;
thus L807: ( C123 . C124 ) = ( C114 . C124 ) by L791;
end;
L808: ( Seg ( len C114 ) ) = ( dom C114 ) by FINSEQ_1:def 3;
L809: ( Seg ( len C114 ) ) = ( Seg ( len C119 ) ) by L764 , L449
.= ( Seg ( len C123 ) ) by L781 , L449
.= ( dom C123 ) by FINSEQ_1:def 3;
thus L810: thesis by L809 , L764 , L781 , L808 , L786 , FINSEQ_1:13;
end;
theorem
L811: (for R8 being (FinSequence of ( NAT )) holds (( len R8 ) >= 4 implies ( IDEAoperationC ( IDEAoperationC R8 ) ) = R8))
proof
let C125 being (FinSequence of ( NAT ));
consider C126 being (FinSequence of ( NAT )) such that L812: C126 = ( IDEAoperationC C125 );
assume L813: ( len C125 ) >= 4;
L814: 2 <= ( len C125 ) by L813 , XXREAL_0:2;
L815: 2 in ( Seg ( len C125 ) ) by L814 , FINSEQ_1:1;
L816: 2 in ( dom C125 ) by L815 , FINSEQ_1:def 3;
L817: ( C126 . 2 ) = ( C125 . 3 ) by L816 , L812 , L589;
consider C127 being (FinSequence of ( NAT )) such that L818: C127 = ( IDEAoperationC C126 );
L819: 3 <= ( len C125 ) by L813 , XXREAL_0:2;
L820: 3 in ( Seg ( len C125 ) ) by L819 , FINSEQ_1:1;
L821: 3 in ( dom C125 ) by L820 , FINSEQ_1:def 3;
L822: ( C126 . 3 ) = ( C125 . 2 ) by L821 , L812 , L594;
L823:
now
let C128 being Nat;
assume L824: C128 in ( Seg ( len C125 ) );
L825: C128 in ( Seg ( len C126 ) ) by L824 , L812 , L489;
L826: C128 in ( dom C126 ) by L825 , FINSEQ_1:def 3;
L827: C128 in ( dom C125 ) by L824 , FINSEQ_1:def 3;
L828:
now
per cases ;
suppose L829: C128 = 2;

thus L830: ( C127 . C128 ) = ( C125 . C128 ) by L829 , L818 , L822 , L826 , L589;
end;
suppose L831: C128 = 3;

thus L832: ( C127 . C128 ) = ( C125 . C128 ) by L831 , L818 , L817 , L826 , L594;
end;
suppose L833: (C128 <> 2 & C128 <> 3);

thus L834: ( C127 . C128 ) = ( C126 . C128 ) by L833 , L818 , L826 , L599
.= ( C125 . C128 ) by L812 , L827 , L833 , L599;
end;
end;
thus L836: ( C127 . C128 ) = ( C125 . C128 ) by L828;
end;
L837: ( Seg ( len C125 ) ) = ( dom C125 ) by FINSEQ_1:def 3;
L838: ( Seg ( len C125 ) ) = ( Seg ( len C126 ) ) by L812 , L489
.= ( Seg ( len C127 ) ) by L818 , L489
.= ( dom C127 ) by FINSEQ_1:def 3;
thus L839: thesis by L838 , L812 , L818 , L837 , L823 , FINSEQ_1:13;
end;
begin
definition
func MESSAGES -> set equals 
( ( NAT ) * );
coherence;
end;
registration
cluster ( MESSAGES ) -> non  empty;
coherence;
end;
registration
cluster ( MESSAGES ) ->  functional;
coherence;
end;
registration
cluster  ->  FinSequence-like for (Element of ( MESSAGES ));
coherence;
end;
definition
let C129 being non  empty (Element of ( NAT ));
let R9 being (FinSequence of ( NAT ));
func IDEA_P (R9 , C129) -> (Function of ( MESSAGES ) , ( MESSAGES )) means 
:L844: (for R8 being (FinSequence of ( NAT )) holds ( it . R8 ) = ( IDEAoperationA (( IDEAoperationC ( IDEAoperationB (R8 , R9 , C129) ) ) , R9 , C129) ));
existence
proof
defpred S4[ set , set ] means (ex B41 being (FinSequence of ( NAT )) st ($1 = B41 & $2 = ( IDEAoperationA (( IDEAoperationC ( IDEAoperationB (B41 , R9 , C129) ) ) , R9 , C129) )));
L845: (for B42 being (Element of ( MESSAGES )) holds (ex B43 being (Element of ( MESSAGES )) st S4[ B42 , B43 ]))
proof
let C130 being (Element of ( MESSAGES ));
reconsider D33 = C130 as (FinSequence of ( NAT )) by FINSEQ_1:def 11;
reconsider D34 = ( IDEAoperationA (( IDEAoperationC ( IDEAoperationB (D33 , R9 , C129) ) ) , R9 , C129) ) as (Element of ( MESSAGES )) by FINSEQ_1:def 11;
take D34;
thus L846: thesis;
end;
consider C131 being (Function of ( MESSAGES ) , ( MESSAGES )) such that L847: (for B44 being (Element of ( MESSAGES )) holds S4[ B44 , ( C131 . B44 ) ]) from FUNCT_2:sch 3(L845);
take C131;
let C132 being (FinSequence of ( NAT ));
L848: C132 is (Element of ( MESSAGES )) by FINSEQ_1:def 11;
L849: (ex B45 being (FinSequence of ( NAT )) st (C132 = B45 & ( C131 . C132 ) = ( IDEAoperationA (( IDEAoperationC ( IDEAoperationB (B45 , R9 , C129) ) ) , R9 , C129) ))) by L848 , L847;
thus L850: thesis by L849;
end;
uniqueness
proof
let C133 , C134 being (Function of ( MESSAGES ) , ( MESSAGES ));
assume that
L851: (for B46 being (FinSequence of ( NAT )) holds ( C133 . B46 ) = ( IDEAoperationA (( IDEAoperationC ( IDEAoperationB (B46 , R9 , C129) ) ) , R9 , C129) ))
and
L852: (for B47 being (FinSequence of ( NAT )) holds ( C134 . B47 ) = ( IDEAoperationA (( IDEAoperationC ( IDEAoperationB (B47 , R9 , C129) ) ) , R9 , C129) ));
L853:
now
let C135 being set;
consider C136 being set such that L854: C136 = C135;
assume L855: C135 in ( MESSAGES );
reconsider D35 = C136 as (FinSequence of ( NAT )) by L855 , L854 , FINSEQ_1:def 11;
thus L856: ( C133 . C135 ) = ( IDEAoperationA (( IDEAoperationC ( IDEAoperationB (D35 , R9 , C129) ) ) , R9 , C129) ) by L851 , L854
.= ( C134 . C135 ) by L852 , L854;
end;
L857: (( dom C133 ) = ( MESSAGES ) & ( dom C134 ) = ( MESSAGES )) by FUNCT_2:def 1;
thus L858: thesis by L857 , L853 , FUNCT_1:2;
end;
end;
definition
let C137 being non  empty (Element of ( NAT ));
let R9 being (FinSequence of ( NAT ));
func IDEA_Q (R9 , C137) -> (Function of ( MESSAGES ) , ( MESSAGES )) means 
:L860: (for R8 being (FinSequence of ( NAT )) holds ( it . R8 ) = ( IDEAoperationB (( IDEAoperationA (( IDEAoperationC R8 ) , R9 , C137) ) , R9 , C137) ));
existence
proof
defpred S5[ set , set ] means (ex B48 being (FinSequence of ( NAT )) st ($1 = B48 & $2 = ( IDEAoperationB (( IDEAoperationA (( IDEAoperationC B48 ) , R9 , C137) ) , R9 , C137) )));
L861: (for B49 being (Element of ( MESSAGES )) holds (ex B50 being (Element of ( MESSAGES )) st S5[ B49 , B50 ]))
proof
let C138 being (Element of ( MESSAGES ));
reconsider D36 = C138 as (FinSequence of ( NAT )) by FINSEQ_1:def 11;
reconsider D37 = ( IDEAoperationB (( IDEAoperationA (( IDEAoperationC D36 ) , R9 , C137) ) , R9 , C137) ) as (Element of ( MESSAGES )) by FINSEQ_1:def 11;
take D37;
thus L862: thesis;
end;
consider C139 being (Function of ( MESSAGES ) , ( MESSAGES )) such that L863: (for B51 being (Element of ( MESSAGES )) holds S5[ B51 , ( C139 . B51 ) ]) from FUNCT_2:sch 3(L861);
take C139;
let C140 being (FinSequence of ( NAT ));
L864: C140 is (Element of ( MESSAGES )) by FINSEQ_1:def 11;
L865: (ex B52 being (FinSequence of ( NAT )) st (C140 = B52 & ( C139 . C140 ) = ( IDEAoperationB (( IDEAoperationA (( IDEAoperationC B52 ) , R9 , C137) ) , R9 , C137) ))) by L864 , L863;
thus L866: thesis by L865;
end;
uniqueness
proof
let C141 , C142 being (Function of ( MESSAGES ) , ( MESSAGES ));
assume that
L867: (for B53 being (FinSequence of ( NAT )) holds ( C141 . B53 ) = ( IDEAoperationB (( IDEAoperationA (( IDEAoperationC B53 ) , R9 , C137) ) , R9 , C137) ))
and
L868: (for B54 being (FinSequence of ( NAT )) holds ( C142 . B54 ) = ( IDEAoperationB (( IDEAoperationA (( IDEAoperationC B54 ) , R9 , C137) ) , R9 , C137) ));
L869:
now
let C143 being set;
consider C144 being set such that L870: C144 = C143;
assume L871: C143 in ( MESSAGES );
reconsider D38 = C144 as (FinSequence of ( NAT )) by L871 , L870 , FINSEQ_1:def 11;
thus L872: ( C141 . C143 ) = ( IDEAoperationB (( IDEAoperationA (( IDEAoperationC D38 ) , R9 , C137) ) , R9 , C137) ) by L867 , L870
.= ( C142 . C143 ) by L868 , L870;
end;
L873: (( dom C141 ) = ( MESSAGES ) & ( dom C142 ) = ( MESSAGES )) by FUNCT_2:def 1;
thus L874: thesis by L873 , L869 , FUNCT_1:2;
end;
end;
definition
let C145 , C146 being (Element of ( NAT ));
let C147 being non  empty (Element of ( NAT ));
let C148 being (Matrix of C146 , 6 , ( NAT ));
func IDEA_P_F (C148 , C147 , C145) -> FinSequence means 
:L876: (( len it ) = C145 & (for R1 being (Element of ( NAT )) holds (R1 in ( dom it ) implies ( it . R1 ) = ( IDEA_P (( Line (C148 , R1) ) , C147) ))));
existence
proof
deffunc H2(Nat) = ( IDEA_P (( Line (C148 , $1) ) , C147) );
consider C149 being FinSequence such that L877: (( len C149 ) = C145 & (for B55 being Nat holds (B55 in ( dom C149 ) implies ( C149 . B55 ) = H2(B55)))) from FINSEQ_1:sch 2;
take C149;
thus L878: thesis by L877;
end;
uniqueness
proof
let C150 , C151 being FinSequence;
assume that
L879: ( len C150 ) = C145
and
L880: (for B56 being (Element of ( NAT )) holds (B56 in ( dom C150 ) implies ( C150 . B56 ) = ( IDEA_P (( Line (C148 , B56) ) , C147) )))
and
L881: ( len C151 ) = C145
and
L882: (for B57 being (Element of ( NAT )) holds (B57 in ( dom C151 ) implies ( C151 . B57 ) = ( IDEA_P (( Line (C148 , B57) ) , C147) )));
L883:
now
let C152 being Nat;
assume L884: C152 in ( Seg C145 );
L885: C152 in ( dom C151 ) by L884 , L881 , FINSEQ_1:def 3;
L886: C152 in ( dom C150 ) by L879 , L884 , FINSEQ_1:def 3;
L887: ( C150 . C152 ) = ( IDEA_P (( Line (C148 , C152) ) , C147) ) by L886 , L880
.= ( C151 . C152 ) by L882 , L885;
thus L888: ( C150 . C152 ) = ( C151 . C152 ) by L887;
end;
L889: (( Seg C145 ) = ( dom C150 ) & ( Seg C145 ) = ( dom C151 )) by L879 , L881 , FINSEQ_1:def 3;
thus L890: thesis by L889 , L883 , FINSEQ_1:13;
end;
end;
registration
let C153 , C154 being (Element of ( NAT ));
let C155 being non  empty (Element of ( NAT ));
let C156 being (Matrix of C154 , 6 , ( NAT ));
cluster ( IDEA_P_F (C156 , C155 , C153) ) ->  Function-yielding;
coherence
proof
L892: (for B58 being set holds (B58 in ( dom ( IDEA_P_F (C156 , C155 , C153) ) ) implies ( ( IDEA_P_F (C156 , C155 , C153) ) . B58 ) is Function))
proof
let C157 being set;
assume L893: C157 in ( dom ( IDEA_P_F (C156 , C155 , C153) ) );
consider C158 being (Element of ( NAT )) such that L894: C158 = C157 by L893;
L895: ( ( IDEA_P_F (C156 , C155 , C153) ) . C158 ) = ( IDEA_P (( Line (C156 , C158) ) , C155) ) by L893 , L894 , L876;
thus L896: thesis by L895 , L894;
end;
thus L897: thesis by L892 , FUNCOP_1:def 6;
end;
end;
definition
let C159 , C160 being (Element of ( NAT ));
let C161 being non  empty (Element of ( NAT ));
let C162 being (Matrix of C160 , 6 , ( NAT ));
func IDEA_Q_F (C162 , C161 , C159) -> FinSequence means 
:L899: (( len it ) = C159 & (for R1 being (Element of ( NAT )) holds (R1 in ( dom it ) implies ( it . R1 ) = ( IDEA_Q (( Line (C162 , ( ( C159 -' R1 ) + 1 )) ) , C161) ))));
existence
proof
deffunc H3(Nat) = ( IDEA_Q (( Line (C162 , ( ( C159 -' $1 ) + 1 )) ) , C161) );
consider C163 being FinSequence such that L900: (( len C163 ) = C159 & (for B59 being Nat holds (B59 in ( dom C163 ) implies ( C163 . B59 ) = H3(B59)))) from FINSEQ_1:sch 2;
take C163;
thus L901: thesis by L900;
end;
uniqueness
proof
let C164 , C165 being FinSequence;
assume that
L902: ( len C164 ) = C159
and
L903: (for B60 being (Element of ( NAT )) holds (B60 in ( dom C164 ) implies ( C164 . B60 ) = ( IDEA_Q (( Line (C162 , ( ( C159 -' B60 ) + 1 )) ) , C161) )))
and
L904: ( len C165 ) = C159
and
L905: (for B61 being (Element of ( NAT )) holds (B61 in ( dom C165 ) implies ( C165 . B61 ) = ( IDEA_Q (( Line (C162 , ( ( C159 -' B61 ) + 1 )) ) , C161) )));
L906:
now
let C166 being Nat;
assume L907: C166 in ( Seg C159 );
L908: C166 in ( dom C165 ) by L907 , L904 , FINSEQ_1:def 3;
L909: C166 in ( dom C164 ) by L902 , L907 , FINSEQ_1:def 3;
L910: ( C164 . C166 ) = ( IDEA_Q (( Line (C162 , ( ( C159 -' C166 ) + 1 )) ) , C161) ) by L909 , L903
.= ( C165 . C166 ) by L905 , L908;
thus L911: ( C164 . C166 ) = ( C165 . C166 ) by L910;
end;
L912: (( Seg C159 ) = ( dom C164 ) & ( Seg C159 ) = ( dom C165 )) by L902 , L904 , FINSEQ_1:def 3;
thus L913: thesis by L912 , L906 , FINSEQ_1:13;
end;
end;
registration
let C167 , C168 being (Element of ( NAT ));
let C169 being non  empty (Element of ( NAT ));
let C170 being (Matrix of C168 , 6 , ( NAT ));
cluster ( IDEA_Q_F (C170 , C169 , C167) ) ->  Function-yielding;
coherence
proof
L915: (for B62 being set holds (B62 in ( dom ( IDEA_Q_F (C170 , C169 , C167) ) ) implies ( ( IDEA_Q_F (C170 , C169 , C167) ) . B62 ) is Function))
proof
let C171 being set;
assume L916: C171 in ( dom ( IDEA_Q_F (C170 , C169 , C167) ) );
consider C172 being (Element of ( NAT )) such that L917: C172 = C171 by L916;
L918: ( ( IDEA_Q_F (C170 , C169 , C167) ) . C172 ) = ( IDEA_Q (( Line (C170 , ( ( C167 -' C172 ) + 1 )) ) , C169) ) by L916 , L917 , L899;
thus L919: thesis by L918 , L917;
end;
thus L920: thesis by L915 , FUNCOP_1:def 6;
end;
end;
definition
let R9 being (FinSequence of ( NAT ));
let R4 being (Element of ( NAT ));
func IDEA_PS (R9 , R4) -> (Function of ( MESSAGES ) , ( MESSAGES )) means 
:L922: (for R8 being (FinSequence of ( NAT )) holds ( it . R8 ) = ( IDEAoperationA (R8 , R9 , R4) ));
existence
proof
defpred S6[ set , set ] means (ex B63 being (FinSequence of ( NAT )) st ($1 = B63 & $2 = ( IDEAoperationA (B63 , R9 , R4) )));
L923: (for B64 being (Element of ( MESSAGES )) holds (ex B65 being (Element of ( MESSAGES )) st S6[ B64 , B65 ]))
proof
let C173 being (Element of ( MESSAGES ));
reconsider D39 = C173 as (FinSequence of ( NAT )) by FINSEQ_1:def 11;
reconsider D40 = ( IDEAoperationA (D39 , R9 , R4) ) as (Element of ( MESSAGES )) by FINSEQ_1:def 11;
take D40;
thus L924: thesis;
end;
consider C174 being (Function of ( MESSAGES ) , ( MESSAGES )) such that L925: (for B66 being (Element of ( MESSAGES )) holds S6[ B66 , ( C174 . B66 ) ]) from FUNCT_2:sch 3(L923);
take C174;
let C175 being (FinSequence of ( NAT ));
L926: C175 is (Element of ( MESSAGES )) by FINSEQ_1:def 11;
L927: (ex B67 being (FinSequence of ( NAT )) st (C175 = B67 & ( C174 . C175 ) = ( IDEAoperationA (B67 , R9 , R4) ))) by L926 , L925;
thus L928: thesis by L927;
end;
uniqueness
proof
let C176 , C177 being (Function of ( MESSAGES ) , ( MESSAGES ));
assume that
L929: (for B68 being (FinSequence of ( NAT )) holds ( C176 . B68 ) = ( IDEAoperationA (B68 , R9 , R4) ))
and
L930: (for B69 being (FinSequence of ( NAT )) holds ( C177 . B69 ) = ( IDEAoperationA (B69 , R9 , R4) ));
L931:
now
let C178 being set;
consider C179 being set such that L932: C179 = C178;
assume L933: C178 in ( MESSAGES );
reconsider D41 = C179 as (FinSequence of ( NAT )) by L933 , L932 , FINSEQ_1:def 11;
thus L934: ( C176 . C178 ) = ( IDEAoperationA (D41 , R9 , R4) ) by L929 , L932
.= ( C177 . C178 ) by L930 , L932;
end;
L935: (( dom C176 ) = ( MESSAGES ) & ( dom C177 ) = ( MESSAGES )) by FUNCT_2:def 1;
thus L936: thesis by L935 , L931 , FUNCT_1:2;
end;
end;
definition
let R9 being (FinSequence of ( NAT ));
let R4 being (Element of ( NAT ));
func IDEA_QS (R9 , R4) -> (Function of ( MESSAGES ) , ( MESSAGES )) means 
:L938: (for R8 being (FinSequence of ( NAT )) holds ( it . R8 ) = ( IDEAoperationA (R8 , R9 , R4) ));
existence
proof
defpred S7[ set , set ] means (ex B70 being (FinSequence of ( NAT )) st ($1 = B70 & $2 = ( IDEAoperationA (B70 , R9 , R4) )));
L939: (for B71 being (Element of ( MESSAGES )) holds (ex B72 being (Element of ( MESSAGES )) st S7[ B71 , B72 ]))
proof
let C180 being (Element of ( MESSAGES ));
reconsider D42 = C180 as (FinSequence of ( NAT )) by FINSEQ_1:def 11;
reconsider D43 = ( IDEAoperationA (D42 , R9 , R4) ) as (Element of ( MESSAGES )) by FINSEQ_1:def 11;
take D43;
thus L940: thesis;
end;
consider C181 being (Function of ( MESSAGES ) , ( MESSAGES )) such that L941: (for B73 being (Element of ( MESSAGES )) holds S7[ B73 , ( C181 . B73 ) ]) from FUNCT_2:sch 3(L939);
take C181;
let C182 being (FinSequence of ( NAT ));
L942: C182 is (Element of ( MESSAGES )) by FINSEQ_1:def 11;
L943: (ex B74 being (FinSequence of ( NAT )) st (C182 = B74 & ( C181 . C182 ) = ( IDEAoperationA (B74 , R9 , R4) ))) by L942 , L941;
thus L944: thesis by L943;
end;
uniqueness
proof
let C183 , C184 being (Function of ( MESSAGES ) , ( MESSAGES ));
assume that
L945: (for B75 being (FinSequence of ( NAT )) holds ( C183 . B75 ) = ( IDEAoperationA (B75 , R9 , R4) ))
and
L946: (for B76 being (FinSequence of ( NAT )) holds ( C184 . B76 ) = ( IDEAoperationA (B76 , R9 , R4) ));
L947:
now
let C185 being set;
consider C186 being set such that L948: C186 = C185;
assume L949: C185 in ( MESSAGES );
reconsider D44 = C186 as (FinSequence of ( NAT )) by L949 , L948 , FINSEQ_1:def 11;
thus L950: ( C183 . C185 ) = ( IDEAoperationA (D44 , R9 , R4) ) by L945 , L948
.= ( C184 . C185 ) by L946 , L948;
end;
L951: (( dom C183 ) = ( MESSAGES ) & ( dom C184 ) = ( MESSAGES )) by FUNCT_2:def 1;
thus L952: thesis by L951 , L947 , FUNCT_1:2;
end;
end;
definition
let C187 being non  empty (Element of ( NAT ));
let R9 being (FinSequence of ( NAT ));
func IDEA_PE (R9 , C187) -> (Function of ( MESSAGES ) , ( MESSAGES )) means 
:L954: (for R8 being (FinSequence of ( NAT )) holds ( it . R8 ) = ( IDEAoperationA (( IDEAoperationB (R8 , R9 , C187) ) , R9 , C187) ));
existence
proof
defpred S8[ set , set ] means (ex B77 being (FinSequence of ( NAT )) st ($1 = B77 & $2 = ( IDEAoperationA (( IDEAoperationB (B77 , R9 , C187) ) , R9 , C187) )));
L955: (for B78 being (Element of ( MESSAGES )) holds (ex B79 being (Element of ( MESSAGES )) st S8[ B78 , B79 ]))
proof
let C188 being (Element of ( MESSAGES ));
reconsider D45 = C188 as (FinSequence of ( NAT )) by FINSEQ_1:def 11;
reconsider D46 = ( IDEAoperationA (( IDEAoperationB (D45 , R9 , C187) ) , R9 , C187) ) as (Element of ( MESSAGES )) by FINSEQ_1:def 11;
take D46;
thus L956: thesis;
end;
consider C189 being (Function of ( MESSAGES ) , ( MESSAGES )) such that L957: (for B80 being (Element of ( MESSAGES )) holds S8[ B80 , ( C189 . B80 ) ]) from FUNCT_2:sch 3(L955);
take C189;
let C190 being (FinSequence of ( NAT ));
L958: C190 is (Element of ( MESSAGES )) by FINSEQ_1:def 11;
L959: (ex B81 being (FinSequence of ( NAT )) st (C190 = B81 & ( C189 . C190 ) = ( IDEAoperationA (( IDEAoperationB (B81 , R9 , C187) ) , R9 , C187) ))) by L958 , L957;
thus L960: thesis by L959;
end;
uniqueness
proof
let C191 , C192 being (Function of ( MESSAGES ) , ( MESSAGES ));
assume that
L961: (for B82 being (FinSequence of ( NAT )) holds ( C191 . B82 ) = ( IDEAoperationA (( IDEAoperationB (B82 , R9 , C187) ) , R9 , C187) ))
and
L962: (for B83 being (FinSequence of ( NAT )) holds ( C192 . B83 ) = ( IDEAoperationA (( IDEAoperationB (B83 , R9 , C187) ) , R9 , C187) ));
L963:
now
let C193 being set;
consider C194 being set such that L964: C194 = C193;
assume L965: C193 in ( MESSAGES );
reconsider D47 = C194 as (FinSequence of ( NAT )) by L965 , L964 , FINSEQ_1:def 11;
thus L966: ( C191 . C193 ) = ( IDEAoperationA (( IDEAoperationB (D47 , R9 , C187) ) , R9 , C187) ) by L961 , L964
.= ( C192 . C193 ) by L962 , L964;
end;
L967: (( dom C191 ) = ( MESSAGES ) & ( dom C192 ) = ( MESSAGES )) by FUNCT_2:def 1;
thus L968: thesis by L967 , L963 , FUNCT_1:2;
end;
end;
definition
let C195 being non  empty (Element of ( NAT ));
let R9 being (FinSequence of ( NAT ));
func IDEA_QE (R9 , C195) -> (Function of ( MESSAGES ) , ( MESSAGES )) means 
:L970: (for R8 being (FinSequence of ( NAT )) holds ( it . R8 ) = ( IDEAoperationB (( IDEAoperationA (R8 , R9 , C195) ) , R9 , C195) ));
existence
proof
defpred S9[ set , set ] means (ex B84 being (FinSequence of ( NAT )) st ($1 = B84 & $2 = ( IDEAoperationB (( IDEAoperationA (B84 , R9 , C195) ) , R9 , C195) )));
L971: (for B85 being (Element of ( MESSAGES )) holds (ex B86 being (Element of ( MESSAGES )) st S9[ B85 , B86 ]))
proof
let C196 being (Element of ( MESSAGES ));
reconsider D48 = C196 as (FinSequence of ( NAT )) by FINSEQ_1:def 11;
reconsider D49 = ( IDEAoperationB (( IDEAoperationA (D48 , R9 , C195) ) , R9 , C195) ) as (Element of ( MESSAGES )) by FINSEQ_1:def 11;
take D49;
thus L972: thesis;
end;
consider C197 being (Function of ( MESSAGES ) , ( MESSAGES )) such that L973: (for B87 being (Element of ( MESSAGES )) holds S9[ B87 , ( C197 . B87 ) ]) from FUNCT_2:sch 3(L971);
take C197;
let C198 being (FinSequence of ( NAT ));
L974: C198 is (Element of ( MESSAGES )) by FINSEQ_1:def 11;
L975: (ex B88 being (FinSequence of ( NAT )) st (C198 = B88 & ( C197 . C198 ) = ( IDEAoperationB (( IDEAoperationA (B88 , R9 , C195) ) , R9 , C195) ))) by L974 , L973;
thus L976: thesis by L975;
end;
uniqueness
proof
let C199 , C200 being (Function of ( MESSAGES ) , ( MESSAGES ));
assume that
L977: (for B89 being (FinSequence of ( NAT )) holds ( C199 . B89 ) = ( IDEAoperationB (( IDEAoperationA (B89 , R9 , C195) ) , R9 , C195) ))
and
L978: (for B90 being (FinSequence of ( NAT )) holds ( C200 . B90 ) = ( IDEAoperationB (( IDEAoperationA (B90 , R9 , C195) ) , R9 , C195) ));
L979:
now
let C201 being set;
consider C202 being set such that L980: C202 = C201;
assume L981: C201 in ( MESSAGES );
reconsider D50 = C202 as (FinSequence of ( NAT )) by L981 , L980 , FINSEQ_1:def 11;
thus L982: ( C199 . C201 ) = ( IDEAoperationB (( IDEAoperationA (D50 , R9 , C195) ) , R9 , C195) ) by L977 , L980
.= ( C200 . C201 ) by L978 , L980;
end;
L983: (( dom C199 ) = ( MESSAGES ) & ( dom C200 ) = ( MESSAGES )) by FUNCT_2:def 1;
thus L984: thesis by L983 , L979 , FUNCT_1:2;
end;
end;
theorem
L986: (for B91 being non  empty (Element of ( NAT )) holds (for R8 being (FinSequence of ( NAT )) holds (for R10 being (FinSequence of ( NAT )) holds (for R11 being (FinSequence of ( NAT )) holds ((( ( 2 to_power B91 ) + 1 ) is  prime & ( len R8 ) >= 4 & ( R8 . 1 ) is_expressible_by B91 & ( R8 . 2 ) is_expressible_by B91 & ( R8 . 3 ) is_expressible_by B91 & ( R8 . 4 ) is_expressible_by B91 & ( R10 . 1 ) is_expressible_by B91 & ( R10 . 2 ) is_expressible_by B91 & ( R10 . 3 ) is_expressible_by B91 & ( R10 . 4 ) is_expressible_by B91 & ( R11 . 1 ) = ( INV_MOD (( R10 . 1 ) , B91) ) & ( R11 . 2 ) = ( NEG_MOD (( R10 . 3 ) , B91) ) & ( R11 . 3 ) = ( NEG_MOD (( R10 . 2 ) , B91) ) & ( R11 . 4 ) = ( INV_MOD (( R10 . 4 ) , B91) ) & ( R11 . 5 ) = ( R10 . 5 ) & ( R11 . 6 ) = ( R10 . 6 )) implies ( ( ( IDEA_Q (R11 , B91) ) * ( IDEA_P (R10 , B91) ) ) . R8 ) = R8)))))
proof
let C203 being non  empty (Element of ( NAT ));
let R8 being (FinSequence of ( NAT ));
let R10 being (FinSequence of ( NAT ));
let R11 being (FinSequence of ( NAT ));
assume that
L987: ( ( 2 to_power C203 ) + 1 ) is  prime
and
L988: ( len R8 ) >= 4
and
L989: (( R8 . 1 ) is_expressible_by C203 & ( R8 . 2 ) is_expressible_by C203 & ( R8 . 3 ) is_expressible_by C203 & ( R8 . 4 ) is_expressible_by C203)
and
L990: (( R10 . 1 ) is_expressible_by C203 & ( R10 . 2 ) is_expressible_by C203 & ( R10 . 3 ) is_expressible_by C203 & ( R10 . 4 ) is_expressible_by C203 & ( R11 . 1 ) = ( INV_MOD (( R10 . 1 ) , C203) ) & ( R11 . 2 ) = ( NEG_MOD (( R10 . 3 ) , C203) ) & ( R11 . 3 ) = ( NEG_MOD (( R10 . 2 ) , C203) ) & ( R11 . 4 ) = ( INV_MOD (( R10 . 4 ) , C203) ))
and
L991: (( R11 . 5 ) = ( R10 . 5 ) & ( R11 . 6 ) = ( R10 . 6 ));
L992: (( ( IDEAoperationB (R8 , R10 , C203) ) . 2 ) is_expressible_by C203 & ( ( IDEAoperationB (R8 , R10 , C203) ) . 3 ) is_expressible_by C203) by L988 , L567;
L993: ( ( IDEAoperationB (R8 , R10 , C203) ) . 4 ) is_expressible_by C203 by L988 , L567;
L994: (( len ( IDEAoperationB (R8 , R10 , C203) ) ) >= 4 & ( ( IDEAoperationB (R8 , R10 , C203) ) . 1 ) is_expressible_by C203) by L988 , L449 , L567;
L995: ( dom ( IDEA_P (R10 , C203) ) ) = ( MESSAGES ) by FUNCT_2:def 1;
L996: R8 in ( dom ( IDEA_P (R10 , C203) ) ) by L995 , FINSEQ_1:def 11;
L997: ( ( ( IDEA_Q (R11 , C203) ) * ( IDEA_P (R10 , C203) ) ) . R8 ) = ( ( IDEA_Q (R11 , C203) ) . ( ( IDEA_P (R10 , C203) ) . R8 ) ) by L996 , FUNCT_1:13
.= ( ( IDEA_Q (R11 , C203) ) . ( IDEAoperationA (( IDEAoperationC ( IDEAoperationB (R8 , R10 , C203) ) ) , R10 , C203) ) ) by L844
.= ( IDEAoperationB (( IDEAoperationA (( IDEAoperationC ( IDEAoperationA (( IDEAoperationC ( IDEAoperationB (R8 , R10 , C203) ) ) , R10 , C203) ) ) , R11 , C203) ) , R11 , C203) ) by L860
.= ( IDEAoperationB (( IDEAoperationB (R8 , R10 , C203) ) , R11 , C203) ) by L987 , L990 , L994 , L992 , L993 , L671
.= R8 by L988 , L989 , L991 , L754;
thus L998: thesis by L997;
end;
theorem
L999: (for B92 being non  empty (Element of ( NAT )) holds (for R8 being (FinSequence of ( NAT )) holds (for R10 being (FinSequence of ( NAT )) holds (for R11 being (FinSequence of ( NAT )) holds ((( ( 2 to_power B92 ) + 1 ) is  prime & ( len R8 ) >= 4 & ( R8 . 1 ) is_expressible_by B92 & ( R8 . 2 ) is_expressible_by B92 & ( R8 . 3 ) is_expressible_by B92 & ( R8 . 4 ) is_expressible_by B92 & ( R10 . 1 ) is_expressible_by B92 & ( R10 . 2 ) is_expressible_by B92 & ( R10 . 3 ) is_expressible_by B92 & ( R10 . 4 ) is_expressible_by B92 & ( R11 . 1 ) = ( INV_MOD (( R10 . 1 ) , B92) ) & ( R11 . 2 ) = ( NEG_MOD (( R10 . 2 ) , B92) ) & ( R11 . 3 ) = ( NEG_MOD (( R10 . 3 ) , B92) ) & ( R11 . 4 ) = ( INV_MOD (( R10 . 4 ) , B92) )) implies ( ( ( IDEA_QS (R11 , B92) ) * ( IDEA_PS (R10 , B92) ) ) . R8 ) = R8)))))
proof
let C204 being non  empty (Element of ( NAT ));
let R8 being (FinSequence of ( NAT ));
let R10 being (FinSequence of ( NAT ));
let R11 being (FinSequence of ( NAT ));
assume L1000: (( ( 2 to_power C204 ) + 1 ) is  prime & ( len R8 ) >= 4 & ( R8 . 1 ) is_expressible_by C204 & ( R8 . 2 ) is_expressible_by C204 & ( R8 . 3 ) is_expressible_by C204 & ( R8 . 4 ) is_expressible_by C204 & ( R10 . 1 ) is_expressible_by C204 & ( R10 . 2 ) is_expressible_by C204 & ( R10 . 3 ) is_expressible_by C204 & ( R10 . 4 ) is_expressible_by C204 & ( R11 . 1 ) = ( INV_MOD (( R10 . 1 ) , C204) ) & ( R11 . 2 ) = ( NEG_MOD (( R10 . 2 ) , C204) ) & ( R11 . 3 ) = ( NEG_MOD (( R10 . 3 ) , C204) ) & ( R11 . 4 ) = ( INV_MOD (( R10 . 4 ) , C204) ));
L1001: ( dom ( IDEA_PS (R10 , C204) ) ) = ( MESSAGES ) by FUNCT_2:def 1;
L1002: R8 in ( dom ( IDEA_PS (R10 , C204) ) ) by L1001 , FINSEQ_1:def 11;
L1003: ( ( ( IDEA_QS (R11 , C204) ) * ( IDEA_PS (R10 , C204) ) ) . R8 ) = ( ( IDEA_QS (R11 , C204) ) . ( ( IDEA_PS (R10 , C204) ) . R8 ) ) by L1002 , FUNCT_1:13
.= ( ( IDEA_QS (R11 , C204) ) . ( IDEAoperationA (R8 , R10 , C204) ) ) by L922
.= ( IDEAoperationA (( IDEAoperationA (R8 , R10 , C204) ) , R11 , C204) ) by L938
.= R8 by L1000 , L620;
thus L1004: thesis by L1003;
end;
theorem
L1005: (for B93 being non  empty (Element of ( NAT )) holds (for R8 being (FinSequence of ( NAT )) holds (for R10 being (FinSequence of ( NAT )) holds (for R11 being (FinSequence of ( NAT )) holds ((( ( 2 to_power B93 ) + 1 ) is  prime & ( len R8 ) >= 4 & ( R8 . 1 ) is_expressible_by B93 & ( R8 . 2 ) is_expressible_by B93 & ( R8 . 3 ) is_expressible_by B93 & ( R8 . 4 ) is_expressible_by B93 & ( R10 . 1 ) is_expressible_by B93 & ( R10 . 2 ) is_expressible_by B93 & ( R10 . 3 ) is_expressible_by B93 & ( R10 . 4 ) is_expressible_by B93 & ( R11 . 1 ) = ( INV_MOD (( R10 . 1 ) , B93) ) & ( R11 . 2 ) = ( NEG_MOD (( R10 . 2 ) , B93) ) & ( R11 . 3 ) = ( NEG_MOD (( R10 . 3 ) , B93) ) & ( R11 . 4 ) = ( INV_MOD (( R10 . 4 ) , B93) ) & ( R11 . 5 ) = ( R10 . 5 ) & ( R11 . 6 ) = ( R10 . 6 )) implies ( ( ( IDEA_QE (R11 , B93) ) * ( IDEA_PE (R10 , B93) ) ) . R8 ) = R8)))))
proof
let C205 being non  empty (Element of ( NAT ));
let R8 being (FinSequence of ( NAT ));
let R10 being (FinSequence of ( NAT ));
let R11 being (FinSequence of ( NAT ));
assume that
L1006: ( ( 2 to_power C205 ) + 1 ) is  prime
and
L1007: ( len R8 ) >= 4
and
L1008: (( R8 . 1 ) is_expressible_by C205 & ( R8 . 2 ) is_expressible_by C205 & ( R8 . 3 ) is_expressible_by C205 & ( R8 . 4 ) is_expressible_by C205)
and
L1009: (( R10 . 1 ) is_expressible_by C205 & ( R10 . 2 ) is_expressible_by C205 & ( R10 . 3 ) is_expressible_by C205 & ( R10 . 4 ) is_expressible_by C205 & ( R11 . 1 ) = ( INV_MOD (( R10 . 1 ) , C205) ) & ( R11 . 2 ) = ( NEG_MOD (( R10 . 2 ) , C205) ) & ( R11 . 3 ) = ( NEG_MOD (( R10 . 3 ) , C205) ) & ( R11 . 4 ) = ( INV_MOD (( R10 . 4 ) , C205) ))
and
L1010: (( R11 . 5 ) = ( R10 . 5 ) & ( R11 . 6 ) = ( R10 . 6 ));
L1011: (( ( IDEAoperationB (R8 , R10 , C205) ) . 2 ) is_expressible_by C205 & ( ( IDEAoperationB (R8 , R10 , C205) ) . 3 ) is_expressible_by C205) by L1007 , L567;
L1012: ( ( IDEAoperationB (R8 , R10 , C205) ) . 4 ) is_expressible_by C205 by L1007 , L567;
L1013: (( len ( IDEAoperationB (R8 , R10 , C205) ) ) >= 4 & ( ( IDEAoperationB (R8 , R10 , C205) ) . 1 ) is_expressible_by C205) by L1007 , L449 , L567;
L1014: ( dom ( IDEA_PE (R10 , C205) ) ) = ( MESSAGES ) by FUNCT_2:def 1;
L1015: R8 in ( dom ( IDEA_PE (R10 , C205) ) ) by L1014 , FINSEQ_1:def 11;
L1016: ( ( ( IDEA_QE (R11 , C205) ) * ( IDEA_PE (R10 , C205) ) ) . R8 ) = ( ( IDEA_QE (R11 , C205) ) . ( ( IDEA_PE (R10 , C205) ) . R8 ) ) by L1015 , FUNCT_1:13
.= ( ( IDEA_QE (R11 , C205) ) . ( IDEAoperationA (( IDEAoperationB (R8 , R10 , C205) ) , R10 , C205) ) ) by L954
.= ( IDEAoperationB (( IDEAoperationA (( IDEAoperationA (( IDEAoperationB (R8 , R10 , C205) ) , R10 , C205) ) , R11 , C205) ) , R11 , C205) ) by L970
.= ( IDEAoperationB (( IDEAoperationB (R8 , R10 , C205) ) , R11 , C205) ) by L1006 , L1009 , L1013 , L1011 , L1012 , L620
.= R8 by L1007 , L1008 , L1010 , L754;
thus L1017: thesis by L1016;
end;
theorem
L1018: (for B94 being non  empty (Element of ( NAT )) holds (for B95 being (Element of ( NAT )) holds (for B96 being (Matrix of B95 , 6 , ( NAT )) holds (for B97 being (Element of ( NAT )) holds ( IDEA_P_F (B96 , B94 , ( B97 + 1 )) ) = ( ( IDEA_P_F (B96 , B94 , B97) ) ^ <* ( IDEA_P (( Line (B96 , ( B97 + 1 )) ) , B94) ) *> )))))
proof
let C206 being non  empty (Element of ( NAT ));
let C207 being (Element of ( NAT ));
let C208 being (Matrix of C207 , 6 , ( NAT ));
let C209 being (Element of ( NAT ));
L1019: (for B98 being Nat holds ((1 <= B98 & B98 <= ( len ( IDEA_P_F (C208 , C206 , ( C209 + 1 )) ) )) implies ( ( IDEA_P_F (C208 , C206 , ( C209 + 1 )) ) . B98 ) = ( ( ( IDEA_P_F (C208 , C206 , C209) ) ^ <* ( IDEA_P (( Line (C208 , ( C209 + 1 )) ) , C206) ) *> ) . B98 )))
proof
L1020: ( dom <* ( IDEA_P (( Line (C208 , ( C209 + 1 )) ) , C206) ) *> ) = ( Seg 1 ) by FINSEQ_1:def 8;
L1021: 1 in ( dom <* ( IDEA_P (( Line (C208 , ( C209 + 1 )) ) , C206) ) *> ) by L1020 , FINSEQ_1:1;
let C210 being Nat;
assume that
L1022: 1 <= C210
and
L1023: C210 <= ( len ( IDEA_P_F (C208 , C206 , ( C209 + 1 )) ) );
L1024: C210 in ( Seg ( len ( IDEA_P_F (C208 , C206 , ( C209 + 1 )) ) ) ) by L1022 , L1023 , FINSEQ_1:1;
L1025: C210 in ( dom ( IDEA_P_F (C208 , C206 , ( C209 + 1 )) ) ) by L1024 , FINSEQ_1:def 3;
L1026: C210 <= ( C209 + 1 ) by L1023 , L876;
L1027:
now
per cases ;
suppose L1028: C210 <> ( C209 + 1 );

L1029: C210 <= C209 by L1028 , L1026 , NAT_1:8;
L1030: C210 in ( Seg C209 ) by L1029 , L1022 , FINSEQ_1:1;
L1031: C210 in ( Seg ( len ( IDEA_P_F (C208 , C206 , C209) ) ) ) by L1030 , L876;
L1032: C210 in ( dom ( IDEA_P_F (C208 , C206 , C209) ) ) by L1031 , FINSEQ_1:def 3;
thus L1033: ( ( ( IDEA_P_F (C208 , C206 , C209) ) ^ <* ( IDEA_P (( Line (C208 , ( C209 + 1 )) ) , C206) ) *> ) . C210 ) = ( ( IDEA_P_F (C208 , C206 , C209) ) . C210 ) by L1032 , FINSEQ_1:def 7
.= ( IDEA_P (( Line (C208 , C210) ) , C206) ) by L1032 , L876
.= ( ( IDEA_P_F (C208 , C206 , ( C209 + 1 )) ) . C210 ) by L1025 , L876;
end;
suppose L1034: C210 = ( C209 + 1 );

thus L1035: ( ( ( IDEA_P_F (C208 , C206 , C209) ) ^ <* ( IDEA_P (( Line (C208 , ( C209 + 1 )) ) , C206) ) *> ) . C210 ) = ( ( ( IDEA_P_F (C208 , C206 , C209) ) ^ <* ( IDEA_P (( Line (C208 , ( C209 + 1 )) ) , C206) ) *> ) . ( ( len ( IDEA_P_F (C208 , C206 , C209) ) ) + 1 ) ) by L1034 , L876
.= ( <* ( IDEA_P (( Line (C208 , ( C209 + 1 )) ) , C206) ) *> . 1 ) by L1021 , FINSEQ_1:def 7
.= ( IDEA_P (( Line (C208 , ( C209 + 1 )) ) , C206) ) by FINSEQ_1:40
.= ( ( IDEA_P_F (C208 , C206 , ( C209 + 1 )) ) . C210 ) by L1025 , L1034 , L876;
end;
end;
thus L1037: thesis by L1027;
end;
L1038: ( len ( ( IDEA_P_F (C208 , C206 , C209) ) ^ <* ( IDEA_P (( Line (C208 , ( C209 + 1 )) ) , C206) ) *> ) ) = ( ( len ( IDEA_P_F (C208 , C206 , C209) ) ) + ( len <* ( IDEA_P (( Line (C208 , ( C209 + 1 )) ) , C206) ) *> ) ) by FINSEQ_1:22
.= ( C209 + ( len <* ( IDEA_P (( Line (C208 , ( C209 + 1 )) ) , C206) ) *> ) ) by L876
.= ( C209 + 1 ) by FINSEQ_1:39;
L1039: ( len ( IDEA_P_F (C208 , C206 , ( C209 + 1 )) ) ) = ( len ( ( IDEA_P_F (C208 , C206 , C209) ) ^ <* ( IDEA_P (( Line (C208 , ( C209 + 1 )) ) , C206) ) *> ) ) by L1038 , L876;
thus L1040: thesis by L1039 , L1019 , FINSEQ_1:14;
end;
theorem
L1041: (for B99 being non  empty (Element of ( NAT )) holds (for B100 being (Element of ( NAT )) holds (for B101 being (Matrix of B100 , 6 , ( NAT )) holds (for B102 being (Element of ( NAT )) holds ( IDEA_Q_F (B101 , B99 , ( B102 + 1 )) ) = ( <* ( IDEA_Q (( Line (B101 , ( B102 + 1 )) ) , B99) ) *> ^ ( IDEA_Q_F (B101 , B99 , B102) ) )))))
proof
let C211 being non  empty (Element of ( NAT ));
let C212 being (Element of ( NAT ));
let C213 being (Matrix of C212 , 6 , ( NAT ));
let C214 being (Element of ( NAT ));
L1042: (for B103 being Nat holds ((1 <= B103 & B103 <= ( len ( IDEA_Q_F (C213 , C211 , ( C214 + 1 )) ) )) implies ( ( IDEA_Q_F (C213 , C211 , ( C214 + 1 )) ) . B103 ) = ( ( <* ( IDEA_Q (( Line (C213 , ( C214 + 1 )) ) , C211) ) *> ^ ( IDEA_Q_F (C213 , C211 , C214) ) ) . B103 )))
proof
L1043: ( dom <* ( IDEA_Q (( Line (C213 , ( C214 + 1 )) ) , C211) ) *> ) = ( Seg 1 ) by FINSEQ_1:def 8;
L1044: 1 in ( dom <* ( IDEA_Q (( Line (C213 , ( C214 + 1 )) ) , C211) ) *> ) by L1043 , FINSEQ_1:1;
let C215 being Nat;
assume that
L1045: 1 <= C215
and
L1046: C215 <= ( len ( IDEA_Q_F (C213 , C211 , ( C214 + 1 )) ) );
L1047: C215 <= ( C214 + 1 ) by L1046 , L899;
L1048: 1 <= ( len ( IDEA_Q_F (C213 , C211 , ( C214 + 1 )) ) ) by L1045 , L1046 , XXREAL_0:2;
L1049: 1 in ( Seg ( len ( IDEA_Q_F (C213 , C211 , ( C214 + 1 )) ) ) ) by L1048 , FINSEQ_1:1;
L1050: 1 in ( dom ( IDEA_Q_F (C213 , C211 , ( C214 + 1 )) ) ) by L1049 , FINSEQ_1:def 3;
L1051: C215 in ( Seg ( len ( IDEA_Q_F (C213 , C211 , ( C214 + 1 )) ) ) ) by L1045 , L1046 , FINSEQ_1:1;
L1052: C215 in ( dom ( IDEA_Q_F (C213 , C211 , ( C214 + 1 )) ) ) by L1051 , FINSEQ_1:def 3;
L1053:
now
per cases ;
suppose L1054: C215 <> 1;

consider C216 being Integer such that L1055: C216 = ( C215 - 1 );
L1056: ( C216 + 1 ) = C215 by L1055;
L1057: ( ( C214 + 1 ) - C215 ) >= ( C215 - C215 ) by L1047 , XREAL_1:9;
L1058: ( 1 - 1 ) <= ( C215 - 1 ) by L1045 , XREAL_1:9;
reconsider D51 = C216 as (Element of ( NAT )) by L1058 , L1055 , INT_1:3;
L1059: ( C215 - 1 ) <= ( ( C214 + 1 ) - 1 ) by L1047 , XREAL_1:9;
L1060: ( D51 - D51 ) <= ( C214 - D51 ) by L1059 , L1055 , XREAL_1:9;
L1061: ( C214 -' D51 ) = ( ( C214 + 1 ) + ( - C215 ) ) by L1060 , L1055 , XREAL_0:def 2
.= ( ( C214 + 1 ) -' C215 ) by L1057 , XREAL_0:def 2;
L1062: 1 < C215 by L1045 , L1054 , XXREAL_0:1;
L1063: ( 1 + 1 ) <= C215 by L1062 , NAT_1:13;
L1064: ( ( 1 + 1 ) - 1 ) <= ( C215 - 1 ) by L1063 , XREAL_1:9;
L1065: D51 in ( Seg C214 ) by L1064 , L1055 , L1059 , FINSEQ_1:1;
L1066: D51 in ( Seg ( len ( IDEA_Q_F (C213 , C211 , C214) ) ) ) by L1065 , L899;
L1067: D51 in ( dom ( IDEA_Q_F (C213 , C211 , C214) ) ) by L1066 , FINSEQ_1:def 3;
thus L1068: ( ( <* ( IDEA_Q (( Line (C213 , ( C214 + 1 )) ) , C211) ) *> ^ ( IDEA_Q_F (C213 , C211 , C214) ) ) . C215 ) = ( ( <* ( IDEA_Q (( Line (C213 , ( C214 + 1 )) ) , C211) ) *> ^ ( IDEA_Q_F (C213 , C211 , C214) ) ) . ( ( len <* ( IDEA_Q (( Line (C213 , ( C214 + 1 )) ) , C211) ) *> ) + D51 ) ) by L1056 , FINSEQ_1:40
.= ( ( IDEA_Q_F (C213 , C211 , C214) ) . D51 ) by L1067 , FINSEQ_1:def 7
.= ( IDEA_Q (( Line (C213 , ( ( ( C214 + 1 ) -' C215 ) + 1 )) ) , C211) ) by L1067 , L1061 , L899
.= ( ( IDEA_Q_F (C213 , C211 , ( C214 + 1 )) ) . C215 ) by L1052 , L899;
end;
suppose L1069: C215 = 1;

thus L1070: ( ( <* ( IDEA_Q (( Line (C213 , ( C214 + 1 )) ) , C211) ) *> ^ ( IDEA_Q_F (C213 , C211 , C214) ) ) . C215 ) = ( <* ( IDEA_Q (( Line (C213 , ( C214 + 1 )) ) , C211) ) *> . 1 ) by L1069 , L1044 , FINSEQ_1:def 7
.= ( IDEA_Q (( Line (C213 , ( C214 + 1 )) ) , C211) ) by FINSEQ_1:40
.= ( IDEA_Q (( Line (C213 , ( ( ( C214 + 1 ) -' 1 ) + 1 )) ) , C211) ) by L1045 , L1047 , XREAL_1:235 , XXREAL_0:2
.= ( ( IDEA_Q_F (C213 , C211 , ( C214 + 1 )) ) . C215 ) by L1050 , L1069 , L899;
end;
end;
thus L1072: thesis by L1053;
end;
L1073: ( len ( <* ( IDEA_Q (( Line (C213 , ( C214 + 1 )) ) , C211) ) *> ^ ( IDEA_Q_F (C213 , C211 , C214) ) ) ) = ( ( len <* ( IDEA_Q (( Line (C213 , ( C214 + 1 )) ) , C211) ) *> ) + ( len ( IDEA_Q_F (C213 , C211 , C214) ) ) ) by FINSEQ_1:22
.= ( ( len <* ( IDEA_Q (( Line (C213 , ( C214 + 1 )) ) , C211) ) *> ) + C214 ) by L899
.= ( C214 + 1 ) by FINSEQ_1:39;
L1074: ( len ( IDEA_Q_F (C213 , C211 , ( C214 + 1 )) ) ) = ( len ( <* ( IDEA_Q (( Line (C213 , ( C214 + 1 )) ) , C211) ) *> ^ ( IDEA_Q_F (C213 , C211 , C214) ) ) ) by L1073 , L899;
thus L1075: thesis by L1074 , L1042 , FINSEQ_1:14;
end;
theorem
L1076: (for B104 being non  empty (Element of ( NAT )) holds (for B105 being (Element of ( NAT )) holds (for B106 being (Matrix of B105 , 6 , ( NAT )) holds (for B107 being (Element of ( NAT )) holds ( IDEA_P_F (B106 , B104 , B107) ) is  FuncSeq-like  FuncSeq-like  FuncSeq-like  FuncSeq-like FinSequence))))
proof
let C217 being non  empty (Element of ( NAT ));
let C218 being (Element of ( NAT ));
let C219 being (Matrix of C218 , 6 , ( NAT ));
let C220 being (Element of ( NAT ));
set D52 = ( ( Seg ( C220 + 1 ) ) --> ( MESSAGES ) );
L1077: ( dom D52 ) = ( Seg ( C220 + 1 ) ) by FUNCOP_1:13;
reconsider D53 = D52 as FinSequence;
L1078: (for B108 being (Element of ( NAT )) holds (B108 in ( dom ( IDEA_P_F (C219 , C217 , C220) ) ) implies ( ( IDEA_P_F (C219 , C217 , C220) ) . B108 ) in ( Funcs (( D53 . B108 ) , ( D53 . ( B108 + 1 ) )) )))
proof
let C221 being (Element of ( NAT ));
assume L1079: C221 in ( dom ( IDEA_P_F (C219 , C217 , C220) ) );
L1080: C221 in ( Seg ( len ( IDEA_P_F (C219 , C217 , C220) ) ) ) by L1079 , FINSEQ_1:def 3;
L1081: C221 in ( Seg C220 ) by L1080 , L876;
L1082: C221 <= C220 by L1081 , FINSEQ_1:1;
L1083: C221 <= ( C220 + 1 ) by L1082 , NAT_1:12;
L1084: (1 <= ( C221 + 1 ) & ( C221 + 1 ) <= ( C220 + 1 )) by L1082 , NAT_1:12 , XREAL_1:6;
L1085: ( C221 + 1 ) in ( Seg ( C220 + 1 ) ) by L1084 , FINSEQ_1:1;
L1086: ( D53 . ( C221 + 1 ) ) = ( MESSAGES ) by L1085 , FUNCOP_1:7;
L1087: 1 <= C221 by L1080 , FINSEQ_1:1;
L1088: C221 in ( Seg ( C220 + 1 ) ) by L1087 , L1083 , FINSEQ_1:1;
L1089: ( D53 . C221 ) = ( MESSAGES ) by L1088 , FUNCOP_1:7;
L1090: ( ( IDEA_P_F (C219 , C217 , C220) ) . C221 ) = ( IDEA_P (( Line (C219 , C221) ) , C217) ) by L1079 , L876;
thus L1091: thesis by L1090 , L1089 , L1086 , FUNCT_2:9;
end;
L1092: ( len D53 ) = ( C220 + 1 ) by L1077 , FINSEQ_1:def 3;
L1093: ( len D53 ) = ( ( len ( IDEA_P_F (C219 , C217 , C220) ) ) + 1 ) by L1092 , L876;
thus L1094: thesis by L1093 , L1078 , FUNCT_7:def 8;
end;
theorem
L1095: (for B109 being non  empty (Element of ( NAT )) holds (for B110 being (Element of ( NAT )) holds (for B111 being (Matrix of B110 , 6 , ( NAT )) holds (for B112 being (Element of ( NAT )) holds ( IDEA_Q_F (B111 , B109 , B112) ) is  FuncSeq-like  FuncSeq-like  FuncSeq-like  FuncSeq-like FinSequence))))
proof
let C222 being non  empty (Element of ( NAT ));
let C223 being (Element of ( NAT ));
let C224 being (Matrix of C223 , 6 , ( NAT ));
let C225 being (Element of ( NAT ));
set D54 = ( ( Seg ( C225 + 1 ) ) --> ( MESSAGES ) );
L1096: ( dom D54 ) = ( Seg ( C225 + 1 ) ) by FUNCOP_1:13;
reconsider D55 = D54 as FinSequence;
L1097: (for B113 being (Element of ( NAT )) holds (B113 in ( dom ( IDEA_Q_F (C224 , C222 , C225) ) ) implies ( ( IDEA_Q_F (C224 , C222 , C225) ) . B113 ) in ( Funcs (( D55 . B113 ) , ( D55 . ( B113 + 1 ) )) )))
proof
let C226 being (Element of ( NAT ));
assume L1098: C226 in ( dom ( IDEA_Q_F (C224 , C222 , C225) ) );
L1099: C226 in ( Seg ( len ( IDEA_Q_F (C224 , C222 , C225) ) ) ) by L1098 , FINSEQ_1:def 3;
L1100: C226 in ( Seg C225 ) by L1099 , L899;
L1101: C226 <= C225 by L1100 , FINSEQ_1:1;
L1102: C226 <= ( C225 + 1 ) by L1101 , NAT_1:12;
L1103: (1 <= ( C226 + 1 ) & ( C226 + 1 ) <= ( C225 + 1 )) by L1101 , NAT_1:12 , XREAL_1:6;
L1104: ( C226 + 1 ) in ( Seg ( C225 + 1 ) ) by L1103 , FINSEQ_1:1;
L1105: ( D55 . ( C226 + 1 ) ) = ( MESSAGES ) by L1104 , FUNCOP_1:7;
L1106: 1 <= C226 by L1099 , FINSEQ_1:1;
L1107: C226 in ( Seg ( C225 + 1 ) ) by L1106 , L1102 , FINSEQ_1:1;
L1108: ( D55 . C226 ) = ( MESSAGES ) by L1107 , FUNCOP_1:7;
L1109: ( ( IDEA_Q_F (C224 , C222 , C225) ) . C226 ) = ( IDEA_Q (( Line (C224 , ( ( C225 -' C226 ) + 1 )) ) , C222) ) by L1098 , L899;
thus L1110: thesis by L1109 , L1108 , L1105 , FUNCT_2:9;
end;
L1111: ( len D55 ) = ( C225 + 1 ) by L1096 , FINSEQ_1:def 3;
L1112: ( len D55 ) = ( ( len ( IDEA_Q_F (C224 , C222 , C225) ) ) + 1 ) by L1111 , L899;
thus L1113: thesis by L1112 , L1097 , FUNCT_7:def 8;
end;
theorem
L1114: (for B114 being non  empty (Element of ( NAT )) holds (for B115 being (Element of ( NAT )) holds (for B116 being (Matrix of B115 , 6 , ( NAT )) holds (for B117 being (Element of ( NAT )) holds (B117 <> ( 0 ) implies ( IDEA_P_F (B116 , B114 , B117) ) is (FuncSequence of ( MESSAGES ) , ( MESSAGES )))))))
proof
let C227 being non  empty (Element of ( NAT ));
let C228 being (Element of ( NAT ));
let C229 being (Matrix of C228 , 6 , ( NAT ));
let C230 being (Element of ( NAT ));
L1115: C230 = ( len ( IDEA_P_F (C229 , C227 , C230) ) ) by L876;
assume L1116: C230 <> ( 0 );
L1117: ( ( 0 ) + 1 ) < ( C230 + 1 ) by L1116 , XREAL_1:6;
L1118: 1 <= C230 by L1117 , NAT_1:13;
L1119: ( ( 0 ) + 1 ) < ( C230 + 1 ) by L1116 , XREAL_1:6;
L1120: 1 <= C230 by L1119 , NAT_1:13;
L1121: 1 in ( Seg ( len ( IDEA_P_F (C229 , C227 , C230) ) ) ) by L1120 , L1115 , FINSEQ_1:1;
L1122: 1 in ( dom ( IDEA_P_F (C229 , C227 , C230) ) ) by L1121 , FINSEQ_1:def 3;
L1123: ( len ( IDEA_P_F (C229 , C227 , C230) ) ) = C230 by L876;
L1124: (not ( IDEA_P_F (C229 , C227 , C230) ) = ( <*> ( MESSAGES ) )) by L1123 , L1116;
L1125: ( firstdom ( IDEA_P_F (C229 , C227 , C230) ) ) = ( proj1 ( ( IDEA_P_F (C229 , C227 , C230) ) . 1 ) ) by L1124 , FUNCT_7:def 6
.= ( proj1 ( IDEA_P (( Line (C229 , 1) ) , C227) ) ) by L1122 , L876
.= ( dom ( IDEA_P (( Line (C229 , 1) ) , C227) ) )
.= ( MESSAGES ) by FUNCT_2:def 1;
L1126: C230 = ( len ( IDEA_P_F (C229 , C227 , C230) ) ) by L876;
L1127: C230 in ( Seg ( len ( IDEA_P_F (C229 , C227 , C230) ) ) ) by L1126 , L1118 , FINSEQ_1:1;
L1128: C230 in ( dom ( IDEA_P_F (C229 , C227 , C230) ) ) by L1127 , FINSEQ_1:def 3;
L1129: ( len ( IDEA_P_F (C229 , C227 , C230) ) ) <> ( 0 ) by L1116 , L876;
L1130: (not ( IDEA_P_F (C229 , C227 , C230) ) = ( <*> ( MESSAGES ) )) by L1129;
L1131: ( lastrng ( IDEA_P_F (C229 , C227 , C230) ) ) = ( proj2 ( ( IDEA_P_F (C229 , C227 , C230) ) . ( len ( IDEA_P_F (C229 , C227 , C230) ) ) ) ) by L1130 , FUNCT_7:def 7
.= ( proj2 ( ( IDEA_P_F (C229 , C227 , C230) ) . C230 ) ) by L876
.= ( proj2 ( IDEA_P (( Line (C229 , C230) ) , C227) ) ) by L1128 , L876
.= ( rng ( IDEA_P (( Line (C229 , C230) ) , C227) ) );
L1132: ( lastrng ( IDEA_P_F (C229 , C227 , C230) ) ) c= ( MESSAGES ) by L1131 , RELAT_1:def 19;
L1133: ( IDEA_P_F (C229 , C227 , C230) ) is FuncSequence by L1076;
thus L1134: thesis by L1133 , L1132 , L1125 , FUNCT_7:def 9;
end;
theorem
L1135: (for B118 being non  empty (Element of ( NAT )) holds (for B119 being (Element of ( NAT )) holds (for B120 being (Matrix of B119 , 6 , ( NAT )) holds (for B121 being (Element of ( NAT )) holds (B121 <> ( 0 ) implies ( IDEA_Q_F (B120 , B118 , B121) ) is (FuncSequence of ( MESSAGES ) , ( MESSAGES )))))))
proof
let C231 being non  empty (Element of ( NAT ));
let C232 being (Element of ( NAT ));
let C233 being (Matrix of C232 , 6 , ( NAT ));
let C234 being (Element of ( NAT ));
assume L1136: C234 <> ( 0 );
L1137: ( ( 0 ) + 1 ) < ( C234 + 1 ) by L1136 , XREAL_1:6;
L1138: 1 <= C234 by L1137 , NAT_1:13;
L1139: ( ( 0 ) + 1 ) < ( C234 + 1 ) by L1136 , XREAL_1:6;
L1140: 1 <= C234 by L1139 , NAT_1:13;
L1141: C234 = ( len ( IDEA_Q_F (C233 , C231 , C234) ) ) by L899;
L1142: 1 in ( Seg ( len ( IDEA_Q_F (C233 , C231 , C234) ) ) ) by L1141 , L1140 , FINSEQ_1:1;
L1143: 1 in ( dom ( IDEA_Q_F (C233 , C231 , C234) ) ) by L1142 , FINSEQ_1:def 3;
L1144: ( len ( IDEA_Q_F (C233 , C231 , C234) ) ) <> ( 0 ) by L1136 , L899;
L1145: (not ( IDEA_Q_F (C233 , C231 , C234) ) = ( <*> ( MESSAGES ) )) by L1144;
L1146: ( firstdom ( IDEA_Q_F (C233 , C231 , C234) ) ) = ( proj1 ( ( IDEA_Q_F (C233 , C231 , C234) ) . 1 ) ) by L1145 , FUNCT_7:def 6
.= ( proj1 ( IDEA_Q (( Line (C233 , ( ( C234 -' 1 ) + 1 )) ) , C231) ) ) by L1143 , L899
.= ( dom ( IDEA_Q (( Line (C233 , ( ( C234 -' 1 ) + 1 )) ) , C231) ) )
.= ( MESSAGES ) by FUNCT_2:def 1;
L1147: C234 = ( len ( IDEA_Q_F (C233 , C231 , C234) ) ) by L899;
L1148: C234 in ( Seg ( len ( IDEA_Q_F (C233 , C231 , C234) ) ) ) by L1147 , L1138 , FINSEQ_1:1;
L1149: C234 in ( dom ( IDEA_Q_F (C233 , C231 , C234) ) ) by L1148 , FINSEQ_1:def 3;
L1150: ( len ( IDEA_Q_F (C233 , C231 , C234) ) ) <> ( 0 ) by L1136 , L899;
L1151: (not ( IDEA_Q_F (C233 , C231 , C234) ) = ( <*> ( MESSAGES ) )) by L1150;
L1152: ( lastrng ( IDEA_Q_F (C233 , C231 , C234) ) ) = ( proj2 ( ( IDEA_Q_F (C233 , C231 , C234) ) . ( len ( IDEA_Q_F (C233 , C231 , C234) ) ) ) ) by L1151 , FUNCT_7:def 7
.= ( proj2 ( ( IDEA_Q_F (C233 , C231 , C234) ) . C234 ) ) by L899
.= ( proj2 ( IDEA_Q (( Line (C233 , ( ( C234 -' C234 ) + 1 )) ) , C231) ) ) by L1149 , L899
.= ( rng ( IDEA_Q (( Line (C233 , ( ( C234 -' C234 ) + 1 )) ) , C231) ) );
L1153: ( lastrng ( IDEA_Q_F (C233 , C231 , C234) ) ) c= ( MESSAGES ) by L1152 , RELAT_1:def 19;
L1154: ( IDEA_Q_F (C233 , C231 , C234) ) is FuncSequence by L1095;
thus L1155: thesis by L1154 , L1153 , L1146 , FUNCT_7:def 9;
end;
theorem
L1156: (for B122 being non  empty (Element of ( NAT )) holds (for B123 being (FinSequence of ( NAT )) holds (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds ((B123 = ( ( IDEA_P (R9 , B122) ) . R8 ) & ( len R8 ) >= 4) implies (( len B123 ) >= 4 & ( B123 . 1 ) is_expressible_by B122 & ( B123 . 2 ) is_expressible_by B122 & ( B123 . 3 ) is_expressible_by B122 & ( B123 . 4 ) is_expressible_by B122))))))
proof
let C235 being non  empty (Element of ( NAT ));
let C236 being (FinSequence of ( NAT ));
let R8 being (FinSequence of ( NAT ));
let R9 being (FinSequence of ( NAT ));
assume that
L1157: C236 = ( ( IDEA_P (R9 , C235) ) . R8 )
and
L1158: ( len R8 ) >= 4;
L1159: ( len R8 ) = ( len ( IDEAoperationB (R8 , R9 , C235) ) ) by L449
.= ( len ( IDEAoperationC ( IDEAoperationB (R8 , R9 , C235) ) ) ) by L489;
L1160: C236 = ( IDEAoperationA (( IDEAoperationC ( IDEAoperationB (R8 , R9 , C235) ) ) , R9 , C235) ) by L1157 , L844;
thus L1161: thesis by L1160 , L1158 , L1159 , L409 , L549;
end;
theorem
L1162: (for B124 being non  empty (Element of ( NAT )) holds (for B125 being (Element of ( NAT )) holds (for B126 being (Matrix of B125 , 6 , ( NAT )) holds (for B127 being (Element of ( NAT )) holds (( rng ( compose (( IDEA_P_F (B126 , B124 , B127) ) , ( MESSAGES )) ) ) c= ( MESSAGES ) & ( dom ( compose (( IDEA_P_F (B126 , B124 , B127) ) , ( MESSAGES )) ) ) = ( MESSAGES ))))))
proof
let C237 being non  empty (Element of ( NAT ));
let C238 being (Element of ( NAT ));
let C239 being (Matrix of C238 , 6 , ( NAT ));
let C240 being (Element of ( NAT ));
L1163: ( rng ( compose (( IDEA_P_F (C239 , C237 , C240) ) , ( MESSAGES )) ) ) c= ( MESSAGES )
proof
per cases ;
suppose L1164: C240 <> ( 0 );

L1165: ( ( 0 ) + 1 ) < ( C240 + 1 ) by L1164 , XREAL_1:6;
L1166: 1 <= C240 by L1165 , NAT_1:13;
L1167: C240 = ( len ( IDEA_P_F (C239 , C237 , C240) ) ) by L876;
L1168: C240 in ( Seg ( len ( IDEA_P_F (C239 , C237 , C240) ) ) ) by L1167 , L1166 , FINSEQ_1:1;
L1169: C240 in ( dom ( IDEA_P_F (C239 , C237 , C240) ) ) by L1168 , FINSEQ_1:def 3;
L1170: ( len ( IDEA_P_F (C239 , C237 , C240) ) ) <> ( 0 ) by L1164 , L876;
L1171: (not ( IDEA_P_F (C239 , C237 , C240) ) = ( <*> ( MESSAGES ) )) by L1170;
L1172: ( lastrng ( IDEA_P_F (C239 , C237 , C240) ) ) = ( proj2 ( ( IDEA_P_F (C239 , C237 , C240) ) . ( len ( IDEA_P_F (C239 , C237 , C240) ) ) ) ) by L1171 , FUNCT_7:def 7
.= ( proj2 ( ( IDEA_P_F (C239 , C237 , C240) ) . C240 ) ) by L876
.= ( proj2 ( IDEA_P (( Line (C239 , C240) ) , C237) ) ) by L1169 , L876
.= ( rng ( IDEA_P (( Line (C239 , C240) ) , C237) ) );
L1173: ( lastrng ( IDEA_P_F (C239 , C237 , C240) ) ) c= ( MESSAGES ) by L1172 , RELAT_1:def 19;
L1174: ( rng ( compose (( IDEA_P_F (C239 , C237 , C240) ) , ( MESSAGES )) ) ) c= ( lastrng ( IDEA_P_F (C239 , C237 , C240) ) ) by L1171 , FUNCT_7:59;
thus L1175: thesis by L1174 , L1173 , XBOOLE_1:1;
end;
suppose L1176: C240 = ( 0 );

L1177: ( len ( IDEA_P_F (C239 , C237 , C240) ) ) = ( 0 ) by L1176 , L876;
L1178: ( IDEA_P_F (C239 , C237 , C240) ) = ( {} ) by L1177;
L1179: ( compose (( IDEA_P_F (C239 , C237 , C240) ) , ( MESSAGES )) ) = ( id ( MESSAGES ) ) by L1178 , FUNCT_7:39;
thus L1180: thesis by L1179 , RELAT_1:def 19;
end;
end;
L1182: ( IDEA_P_F (C239 , C237 , C240) ) is FuncSequence by L1076;
L1183: ( dom ( compose (( IDEA_P_F (C239 , C237 , C240) ) , ( MESSAGES )) ) ) = ( MESSAGES )
proof
per cases ;
suppose L1184: C240 = ( 0 );

L1185: ( len ( IDEA_P_F (C239 , C237 , C240) ) ) = ( 0 ) by L1184 , L876;
L1186: ( IDEA_P_F (C239 , C237 , C240) ) = ( {} ) by L1185;
L1187: ( compose (( IDEA_P_F (C239 , C237 , C240) ) , ( MESSAGES )) ) = ( id ( MESSAGES ) ) by L1186 , FUNCT_7:39;
thus L1188: thesis by L1187 , FUNCT_2:52;
end;
suppose L1189: C240 <> ( 0 );

L1190: ( ( 0 ) + 1 ) < ( C240 + 1 ) by L1189 , XREAL_1:6;
L1191: 1 <= C240 by L1190 , NAT_1:13;
L1192: C240 = ( len ( IDEA_P_F (C239 , C237 , C240) ) ) by L876;
L1193: 1 in ( Seg ( len ( IDEA_P_F (C239 , C237 , C240) ) ) ) by L1192 , L1191 , FINSEQ_1:1;
L1194: 1 in ( dom ( IDEA_P_F (C239 , C237 , C240) ) ) by L1193 , FINSEQ_1:def 3;
L1195: ( len ( IDEA_P_F (C239 , C237 , C240) ) ) <> ( 0 ) by L1189 , L876;
L1196: (not ( IDEA_P_F (C239 , C237 , C240) ) = ( <*> ( MESSAGES ) )) by L1195;
L1197: ( firstdom ( IDEA_P_F (C239 , C237 , C240) ) ) = ( proj1 ( ( IDEA_P_F (C239 , C237 , C240) ) . 1 ) ) by L1196 , FUNCT_7:def 6
.= ( proj1 ( IDEA_P (( Line (C239 , 1) ) , C237) ) ) by L1194 , L876
.= ( dom ( IDEA_P (( Line (C239 , 1) ) , C237) ) )
.= ( MESSAGES ) by FUNCT_2:def 1;
thus L1198: thesis by L1197 , L1182 , FUNCT_7:62;
end;
end;
thus L1200: thesis by L1183 , L1163;
end;
theorem
L1201: (for B128 being non  empty (Element of ( NAT )) holds (for B129 being (Element of ( NAT )) holds (for B130 being (Matrix of B129 , 6 , ( NAT )) holds (for B131 being (Element of ( NAT )) holds (( rng ( compose (( IDEA_Q_F (B130 , B128 , B131) ) , ( MESSAGES )) ) ) c= ( MESSAGES ) & ( dom ( compose (( IDEA_Q_F (B130 , B128 , B131) ) , ( MESSAGES )) ) ) = ( MESSAGES ))))))
proof
let C241 being non  empty (Element of ( NAT ));
let C242 being (Element of ( NAT ));
let C243 being (Matrix of C242 , 6 , ( NAT ));
let C244 being (Element of ( NAT ));
L1202: ( rng ( compose (( IDEA_Q_F (C243 , C241 , C244) ) , ( MESSAGES )) ) ) c= ( MESSAGES )
proof
per cases ;
suppose L1203: C244 <> ( 0 );

L1204: ( ( 0 ) + 1 ) < ( C244 + 1 ) by L1203 , XREAL_1:6;
L1205: 1 <= C244 by L1204 , NAT_1:13;
L1206: C244 = ( len ( IDEA_Q_F (C243 , C241 , C244) ) ) by L899;
L1207: C244 in ( Seg ( len ( IDEA_Q_F (C243 , C241 , C244) ) ) ) by L1206 , L1205 , FINSEQ_1:1;
L1208: C244 in ( dom ( IDEA_Q_F (C243 , C241 , C244) ) ) by L1207 , FINSEQ_1:def 3;
L1209: ( len ( IDEA_Q_F (C243 , C241 , C244) ) ) <> ( 0 ) by L1203 , L899;
L1210: (not ( IDEA_Q_F (C243 , C241 , C244) ) = ( <*> ( MESSAGES ) )) by L1209;
L1211: ( lastrng ( IDEA_Q_F (C243 , C241 , C244) ) ) = ( proj2 ( ( IDEA_Q_F (C243 , C241 , C244) ) . ( len ( IDEA_Q_F (C243 , C241 , C244) ) ) ) ) by L1210 , FUNCT_7:def 7
.= ( proj2 ( ( IDEA_Q_F (C243 , C241 , C244) ) . C244 ) ) by L899
.= ( proj2 ( IDEA_Q (( Line (C243 , ( ( C244 -' C244 ) + 1 )) ) , C241) ) ) by L1208 , L899
.= ( rng ( IDEA_Q (( Line (C243 , ( ( C244 -' C244 ) + 1 )) ) , C241) ) );
L1212: ( lastrng ( IDEA_Q_F (C243 , C241 , C244) ) ) c= ( MESSAGES ) by L1211 , RELAT_1:def 19;
L1213: ( rng ( compose (( IDEA_Q_F (C243 , C241 , C244) ) , ( MESSAGES )) ) ) c= ( lastrng ( IDEA_Q_F (C243 , C241 , C244) ) ) by L1210 , FUNCT_7:59;
thus L1214: thesis by L1213 , L1212 , XBOOLE_1:1;
end;
suppose L1215: C244 = ( 0 );

L1216: ( len ( IDEA_Q_F (C243 , C241 , C244) ) ) = ( 0 ) by L1215 , L899;
L1217: ( IDEA_Q_F (C243 , C241 , C244) ) = ( {} ) by L1216;
L1218: ( compose (( IDEA_Q_F (C243 , C241 , C244) ) , ( MESSAGES )) ) = ( id ( MESSAGES ) ) by L1217 , FUNCT_7:39;
thus L1219: thesis by L1218 , RELAT_1:def 19;
end;
end;
L1221: ( IDEA_Q_F (C243 , C241 , C244) ) is FuncSequence by L1095;
L1222: ( dom ( compose (( IDEA_Q_F (C243 , C241 , C244) ) , ( MESSAGES )) ) ) = ( MESSAGES )
proof
per cases ;
suppose L1223: C244 = ( 0 );

L1224: ( len ( IDEA_Q_F (C243 , C241 , C244) ) ) = ( 0 ) by L1223 , L899;
L1225: ( IDEA_Q_F (C243 , C241 , C244) ) = ( {} ) by L1224;
L1226: ( compose (( IDEA_Q_F (C243 , C241 , C244) ) , ( MESSAGES )) ) = ( id ( MESSAGES ) ) by L1225 , FUNCT_7:39;
thus L1227: thesis by L1226 , FUNCT_2:52;
end;
suppose L1228: C244 <> ( 0 );

L1229: ( ( 0 ) + 1 ) < ( C244 + 1 ) by L1228 , XREAL_1:6;
L1230: 1 <= C244 by L1229 , NAT_1:13;
L1231: C244 = ( len ( IDEA_Q_F (C243 , C241 , C244) ) ) by L899;
L1232: 1 in ( Seg ( len ( IDEA_Q_F (C243 , C241 , C244) ) ) ) by L1231 , L1230 , FINSEQ_1:1;
L1233: 1 in ( dom ( IDEA_Q_F (C243 , C241 , C244) ) ) by L1232 , FINSEQ_1:def 3;
L1234: ( len ( IDEA_Q_F (C243 , C241 , C244) ) ) <> ( 0 ) by L1228 , L899;
L1235: (not ( IDEA_Q_F (C243 , C241 , C244) ) = ( <*> ( MESSAGES ) )) by L1234;
L1236: ( firstdom ( IDEA_Q_F (C243 , C241 , C244) ) ) = ( proj1 ( ( IDEA_Q_F (C243 , C241 , C244) ) . 1 ) ) by L1235 , FUNCT_7:def 6
.= ( proj1 ( IDEA_Q (( Line (C243 , ( ( C244 -' 1 ) + 1 )) ) , C241) ) ) by L1233 , L899
.= ( dom ( IDEA_Q (( Line (C243 , ( ( C244 -' 1 ) + 1 )) ) , C241) ) )
.= ( MESSAGES ) by FUNCT_2:def 1;
thus L1237: thesis by L1236 , L1221 , FUNCT_7:62;
end;
end;
thus L1239: thesis by L1222 , L1202;
end;
theorem
L1240: (for B132 being non  empty (Element of ( NAT )) holds (for B133 being (Element of ( NAT )) holds (for B134 being (Matrix of B133 , 6 , ( NAT )) holds (for B135 being (Element of ( NAT )) holds (for B136 being (FinSequence of ( NAT )) holds (for R8 being (FinSequence of ( NAT )) holds ((B136 = ( ( compose (( IDEA_P_F (B134 , B132 , B135) ) , ( MESSAGES )) ) . R8 ) & ( len R8 ) >= 4 & ( R8 . 1 ) is_expressible_by B132 & ( R8 . 2 ) is_expressible_by B132 & ( R8 . 3 ) is_expressible_by B132 & ( R8 . 4 ) is_expressible_by B132) implies (( len B136 ) >= 4 & ( B136 . 1 ) is_expressible_by B132 & ( B136 . 2 ) is_expressible_by B132 & ( B136 . 3 ) is_expressible_by B132 & ( B136 . 4 ) is_expressible_by B132))))))))
proof
let C245 being non  empty (Element of ( NAT ));
let C246 being (Element of ( NAT ));
let C247 being (Matrix of C246 , 6 , ( NAT ));
let C248 being (Element of ( NAT ));
let C249 being (FinSequence of ( NAT ));
let R8 being (FinSequence of ( NAT ));
assume that
L1241: C249 = ( ( compose (( IDEA_P_F (C247 , C245 , C248) ) , ( MESSAGES )) ) . R8 )
and
L1242: ( len R8 ) >= 4
and
L1243: (( R8 . 1 ) is_expressible_by C245 & ( R8 . 2 ) is_expressible_by C245 & ( R8 . 3 ) is_expressible_by C245 & ( R8 . 4 ) is_expressible_by C245);
L1244: R8 in ( MESSAGES ) by FINSEQ_1:def 11;
per cases ;
suppose L1245: C248 = ( 0 );

L1246: ( len ( IDEA_P_F (C247 , C245 , C248) ) ) = ( 0 ) by L1245 , L876;
L1247: ( IDEA_P_F (C247 , C245 , C248) ) = ( {} ) by L1246;
L1248: C249 = ( ( id ( MESSAGES ) ) . R8 ) by L1247 , L1241 , FUNCT_7:39
.= R8 by L1244 , FUNCT_1:18;
thus L1249: thesis by L1248 , L1242 , L1243;
end;
suppose L1250: C248 <> ( 0 );

consider C250 being Integer such that L1251: C250 = ( C248 - 1 );
defpred S10[ (Element of ( NAT )) ] means (for B137 being (FinSequence of ( NAT )) holds (B137 = ( ( compose (( IDEA_P_F (C247 , C245 , $1) ) , ( MESSAGES )) ) . R8 ) implies ( len B137 ) >= 4));
L1252: R8 in ( MESSAGES ) by FINSEQ_1:def 11;
L1253: (for B138 being (Element of ( NAT )) holds (S10[ B138 ] implies S10[ ( B138 + 1 ) ]))
proof
let C251 being (Element of ( NAT ));
L1254: ( dom ( compose (( IDEA_P_F (C247 , C245 , C251) ) , ( MESSAGES )) ) ) = ( MESSAGES ) by L1162;
L1255: ( rng ( compose (( IDEA_P_F (C247 , C245 , C251) ) , ( MESSAGES )) ) ) c= ( MESSAGES ) by L1162;
L1256: ( rng ( compose (( IDEA_P_F (C247 , C245 , C251) ) , ( MESSAGES )) ) ) c= ( dom ( IDEA_P (( Line (C247 , ( C251 + 1 )) ) , C245) ) ) by L1255 , FUNCT_2:def 1;
L1257: ( dom ( ( IDEA_P (( Line (C247 , ( C251 + 1 )) ) , C245) ) * ( compose (( IDEA_P_F (C247 , C245 , C251) ) , ( MESSAGES )) ) ) ) = ( MESSAGES ) by L1256 , L1254 , RELAT_1:27;
L1258: ( ( compose (( IDEA_P_F (C247 , C245 , C251) ) , ( MESSAGES )) ) . R8 ) in ( rng ( compose (( IDEA_P_F (C247 , C245 , C251) ) , ( MESSAGES )) ) ) by L1252 , L1254 , FUNCT_1:def 3;
reconsider D56 = ( ( compose (( IDEA_P_F (C247 , C245 , C251) ) , ( MESSAGES )) ) . R8 ) as (FinSequence of ( NAT )) by L1258 , L1255 , FINSEQ_1:def 11;
assume L1259: S10[ C251 ];
L1260: ( len D56 ) >= 4 by L1259;
let C252 being (FinSequence of ( NAT ));
assume L1261: C252 = ( ( compose (( IDEA_P_F (C247 , C245 , ( C251 + 1 )) ) , ( MESSAGES )) ) . R8 );
L1262: C252 = ( ( compose (( ( IDEA_P_F (C247 , C245 , C251) ) ^ <* ( IDEA_P (( Line (C247 , ( C251 + 1 )) ) , C245) ) *> ) , ( MESSAGES )) ) . R8 ) by L1261 , L1018;
L1263: C252 = ( ( ( IDEA_P (( Line (C247 , ( C251 + 1 )) ) , C245) ) * ( compose (( IDEA_P_F (C247 , C245 , C251) ) , ( MESSAGES )) ) ) . R8 ) by L1262 , FUNCT_7:41;
L1264: C252 = ( ( IDEA_P (( Line (C247 , ( C251 + 1 )) ) , C245) ) . ( ( compose (( IDEA_P_F (C247 , C245 , C251) ) , ( MESSAGES )) ) . R8 ) ) by L1263 , L1252 , L1257 , FUNCT_1:12;
thus L1265: thesis by L1264 , L1260 , L1156;
end;
L1266: 1 <= C248 by L1250 , NAT_1:14;
L1267: ( 1 - 1 ) <= ( C248 - 1 ) by L1266 , XREAL_1:9;
reconsider D57 = C250 as (Element of ( NAT )) by L1267 , L1251 , INT_1:3;
L1268: ( dom ( compose (( IDEA_P_F (C247 , C245 , D57) ) , ( MESSAGES )) ) ) = ( MESSAGES ) by L1162;
L1269: ( ( compose (( IDEA_P_F (C247 , C245 , D57) ) , ( MESSAGES )) ) . R8 ) in ( rng ( compose (( IDEA_P_F (C247 , C245 , D57) ) , ( MESSAGES )) ) ) by L1268 , L1244 , FUNCT_1:def 3;
L1270: ( rng ( compose (( IDEA_P_F (C247 , C245 , D57) ) , ( MESSAGES )) ) ) c= ( MESSAGES ) by L1162;
reconsider D58 = ( ( compose (( IDEA_P_F (C247 , C245 , D57) ) , ( MESSAGES )) ) . R8 ) as (FinSequence of ( NAT )) by L1270 , L1269 , FINSEQ_1:def 11;
L1271: S10[ ( 0 ) ]
proof
let C253 being (FinSequence of ( NAT ));
L1272: ( len ( IDEA_P_F (C247 , C245 , ( 0 )) ) ) = ( 0 ) by L876;
L1273: ( IDEA_P_F (C247 , C245 , ( 0 )) ) = ( {} ) by L1272;
assume L1274: C253 = ( ( compose (( IDEA_P_F (C247 , C245 , ( 0 )) ) , ( MESSAGES )) ) . R8 );
L1275: C253 = ( ( id ( MESSAGES ) ) . R8 ) by L1274 , L1273 , FUNCT_7:39
.= R8 by L1252 , FUNCT_1:18;
thus L1276: thesis by L1275 , L1242;
end;
L1277: (for B139 being (Element of ( NAT )) holds S10[ B139 ]) from NAT_1:sch 1(L1271 , L1253);
L1278: ( len D58 ) >= 4 by L1277;
L1279: ( IDEA_P_F (C247 , C245 , ( D57 + 1 )) ) = ( ( IDEA_P_F (C247 , C245 , D57) ) ^ <* ( IDEA_P (( Line (C247 , ( D57 + 1 )) ) , C245) ) *> ) by L1018;
L1280: ( compose (( IDEA_P_F (C247 , C245 , C248) ) , ( MESSAGES )) ) = ( ( IDEA_P (( Line (C247 , C248) ) , C245) ) * ( compose (( IDEA_P_F (C247 , C245 , D57) ) , ( MESSAGES )) ) ) by L1279 , L1251 , FUNCT_7:41;
L1281: R8 in ( dom ( ( IDEA_P (( Line (C247 , C248) ) , C245) ) * ( compose (( IDEA_P_F (C247 , C245 , D57) ) , ( MESSAGES )) ) ) ) by L1280 , L1244 , L1162;
L1282: C249 = ( ( IDEA_P (( Line (C247 , C248) ) , C245) ) . ( ( compose (( IDEA_P_F (C247 , C245 , D57) ) , ( MESSAGES )) ) . R8 ) ) by L1281 , L1241 , L1280 , FUNCT_1:12;
thus L1283: thesis by L1282 , L1278 , L1156;
end;
end;
begin
theorem
L1285: (for B140 being non  empty (Element of ( NAT )) holds (for B141 being (Element of ( NAT )) holds (for B142 , B143 being (Matrix of B141 , 6 , ( NAT )) holds (for B144 being (Element of ( NAT )) holds (for R8 being (FinSequence of ( NAT )) holds ((B141 >= B144 & ( ( 2 to_power B140 ) + 1 ) is  prime & ( len R8 ) >= 4 & ( R8 . 1 ) is_expressible_by B140 & ( R8 . 2 ) is_expressible_by B140 & ( R8 . 3 ) is_expressible_by B140 & ( R8 . 4 ) is_expressible_by B140 & (for B145 being (Element of ( NAT )) holds (B145 <= B144 implies (( B142 * (B145 , 1) ) is_expressible_by B140 & ( B142 * (B145 , 2) ) is_expressible_by B140 & ( B142 * (B145 , 3) ) is_expressible_by B140 & ( B142 * (B145 , 4) ) is_expressible_by B140 & ( B142 * (B145 , 5) ) is_expressible_by B140 & ( B142 * (B145 , 6) ) is_expressible_by B140 & ( B143 * (B145 , 1) ) is_expressible_by B140 & ( B143 * (B145 , 2) ) is_expressible_by B140 & ( B143 * (B145 , 3) ) is_expressible_by B140 & ( B143 * (B145 , 4) ) is_expressible_by B140 & ( B143 * (B145 , 5) ) is_expressible_by B140 & ( B143 * (B145 , 6) ) is_expressible_by B140 & ( B143 * (B145 , 1) ) = ( INV_MOD (( B142 * (B145 , 1) ) , B140) ) & ( B143 * (B145 , 2) ) = ( NEG_MOD (( B142 * (B145 , 3) ) , B140) ) & ( B143 * (B145 , 3) ) = ( NEG_MOD (( B142 * (B145 , 2) ) , B140) ) & ( B143 * (B145 , 4) ) = ( INV_MOD (( B142 * (B145 , 4) ) , B140) ) & ( B142 * (B145 , 5) ) = ( B143 * (B145 , 5) ) & ( B142 * (B145 , 6) ) = ( B143 * (B145 , 6) ))))) implies ( ( compose (( ( IDEA_P_F (B142 , B140 , B144) ) ^ ( IDEA_Q_F (B143 , B140 , B144) ) ) , ( MESSAGES )) ) . R8 ) = R8))))))
proof
let C254 being non  empty (Element of ( NAT ));
let C255 being (Element of ( NAT ));
let C256 , C257 being (Matrix of C255 , 6 , ( NAT ));
L1286: (for R8 being (FinSequence of ( NAT )) holds (for B146 being (Element of ( NAT )) holds ((C255 >= B146 & ( ( 2 to_power C254 ) + 1 ) is  prime & ( len R8 ) >= 4 & ( R8 . 1 ) is_expressible_by C254 & ( R8 . 2 ) is_expressible_by C254 & ( R8 . 3 ) is_expressible_by C254 & ( R8 . 4 ) is_expressible_by C254 & (for B147 being (Element of ( NAT )) holds (B147 <= B146 implies (( C256 * (B147 , 1) ) is_expressible_by C254 & ( C256 * (B147 , 2) ) is_expressible_by C254 & ( C256 * (B147 , 3) ) is_expressible_by C254 & ( C256 * (B147 , 4) ) is_expressible_by C254 & ( C256 * (B147 , 5) ) is_expressible_by C254 & ( C256 * (B147 , 6) ) is_expressible_by C254 & ( C257 * (B147 , 1) ) is_expressible_by C254 & ( C257 * (B147 , 2) ) is_expressible_by C254 & ( C257 * (B147 , 3) ) is_expressible_by C254 & ( C257 * (B147 , 4) ) is_expressible_by C254 & ( C257 * (B147 , 5) ) is_expressible_by C254 & ( C257 * (B147 , 6) ) is_expressible_by C254 & ( C257 * (B147 , 1) ) = ( INV_MOD (( C256 * (B147 , 1) ) , C254) ) & ( C257 * (B147 , 2) ) = ( NEG_MOD (( C256 * (B147 , 3) ) , C254) ) & ( C257 * (B147 , 3) ) = ( NEG_MOD (( C256 * (B147 , 2) ) , C254) ) & ( C257 * (B147 , 4) ) = ( INV_MOD (( C256 * (B147 , 4) ) , C254) ) & ( C256 * (B147 , 5) ) = ( C257 * (B147 , 5) ) & ( C256 * (B147 , 6) ) = ( C257 * (B147 , 6) ))))) implies ( ( compose (( ( IDEA_P_F (C256 , C254 , B146) ) ^ ( IDEA_Q_F (C257 , C254 , B146) ) ) , ( MESSAGES )) ) . R8 ) = R8)))
proof
let R8 being (FinSequence of ( NAT ));
defpred S11[ (Element of ( NAT )) ] means ((C255 >= $1 & ( ( 2 to_power C254 ) + 1 ) is  prime & ( len R8 ) >= 4 & ( R8 . 1 ) is_expressible_by C254 & ( R8 . 2 ) is_expressible_by C254 & ( R8 . 3 ) is_expressible_by C254 & ( R8 . 4 ) is_expressible_by C254 & (for B148 being (Element of ( NAT )) holds (B148 <= $1 implies (( C256 * (B148 , 1) ) is_expressible_by C254 & ( C256 * (B148 , 2) ) is_expressible_by C254 & ( C256 * (B148 , 3) ) is_expressible_by C254 & ( C256 * (B148 , 4) ) is_expressible_by C254 & ( C256 * (B148 , 5) ) is_expressible_by C254 & ( C256 * (B148 , 6) ) is_expressible_by C254 & ( C257 * (B148 , 1) ) is_expressible_by C254 & ( C257 * (B148 , 2) ) is_expressible_by C254 & ( C257 * (B148 , 3) ) is_expressible_by C254 & ( C257 * (B148 , 4) ) is_expressible_by C254 & ( C257 * (B148 , 5) ) is_expressible_by C254 & ( C257 * (B148 , 6) ) is_expressible_by C254 & ( C257 * (B148 , 1) ) = ( INV_MOD (( C256 * (B148 , 1) ) , C254) ) & ( C257 * (B148 , 2) ) = ( NEG_MOD (( C256 * (B148 , 3) ) , C254) ) & ( C257 * (B148 , 3) ) = ( NEG_MOD (( C256 * (B148 , 2) ) , C254) ) & ( C257 * (B148 , 4) ) = ( INV_MOD (( C256 * (B148 , 4) ) , C254) ) & ( C256 * (B148 , 5) ) = ( C257 * (B148 , 5) ) & ( C256 * (B148 , 6) ) = ( C257 * (B148 , 6) ))))) implies ( ( compose (( ( IDEA_P_F (C256 , C254 , $1) ) ^ ( IDEA_Q_F (C257 , C254 , $1) ) ) , ( MESSAGES )) ) . R8 ) = R8);
L1287: ( len ( IDEA_P_F (C256 , C254 , ( 0 )) ) ) = ( 0 ) by L876;
L1288: (for B149 being (Element of ( NAT )) holds (S11[ B149 ] implies S11[ ( B149 + 1 ) ]))
proof
let C258 being (Element of ( NAT ));
assume L1289: S11[ C258 ];
consider C259 being (Element of ( NAT )) such that L1290: C259 = ( C258 + 1 );
L1291: ( dom ( compose (( IDEA_P_F (C256 , C254 , C258) ) , ( MESSAGES )) ) ) = ( MESSAGES ) by L1162;
L1292: ( rng ( compose (( IDEA_P_F (C256 , C254 , C258) ) , ( MESSAGES )) ) ) c= ( MESSAGES ) by L1162;
L1293: R8 in ( MESSAGES ) by FINSEQ_1:def 11;
L1294: ( ( compose (( IDEA_P_F (C256 , C254 , C258) ) , ( MESSAGES )) ) . R8 ) in ( rng ( compose (( IDEA_P_F (C256 , C254 , C258) ) , ( MESSAGES )) ) ) by L1293 , L1291 , FUNCT_1:def 3;
reconsider D59 = ( ( compose (( IDEA_P_F (C256 , C254 , C258) ) , ( MESSAGES )) ) . R8 ) as (FinSequence of ( NAT )) by L1294 , L1292 , FINSEQ_1:def 11;
assume that
L1295: C255 >= ( C258 + 1 )
and
L1296: ( ( 2 to_power C254 ) + 1 ) is  prime
and
L1297: (( len R8 ) >= 4 & ( R8 . 1 ) is_expressible_by C254 & ( R8 . 2 ) is_expressible_by C254 & ( R8 . 3 ) is_expressible_by C254 & ( R8 . 4 ) is_expressible_by C254)
and
L1298: (for B150 being (Element of ( NAT )) holds (B150 <= ( C258 + 1 ) implies (( C256 * (B150 , 1) ) is_expressible_by C254 & ( C256 * (B150 , 2) ) is_expressible_by C254 & ( C256 * (B150 , 3) ) is_expressible_by C254 & ( C256 * (B150 , 4) ) is_expressible_by C254 & ( C256 * (B150 , 5) ) is_expressible_by C254 & ( C256 * (B150 , 6) ) is_expressible_by C254 & ( C257 * (B150 , 1) ) is_expressible_by C254 & ( C257 * (B150 , 2) ) is_expressible_by C254 & ( C257 * (B150 , 3) ) is_expressible_by C254 & ( C257 * (B150 , 4) ) is_expressible_by C254 & ( C257 * (B150 , 5) ) is_expressible_by C254 & ( C257 * (B150 , 6) ) is_expressible_by C254 & ( C257 * (B150 , 1) ) = ( INV_MOD (( C256 * (B150 , 1) ) , C254) ) & ( C257 * (B150 , 2) ) = ( NEG_MOD (( C256 * (B150 , 3) ) , C254) ) & ( C257 * (B150 , 3) ) = ( NEG_MOD (( C256 * (B150 , 2) ) , C254) ) & ( C257 * (B150 , 4) ) = ( INV_MOD (( C256 * (B150 , 4) ) , C254) ) & ( C256 * (B150 , 5) ) = ( C257 * (B150 , 5) ) & ( C256 * (B150 , 6) ) = ( C257 * (B150 , 6) ))));
L1299: (( len D59 ) >= 4 & ( D59 . 1 ) is_expressible_by C254) by L1297 , L1240;
L1300: ( width C256 ) = 6 by L1295 , MATRIX_1:23;
L1301: 1 in ( Seg ( width C256 ) ) by L1300 , FINSEQ_1:1;
L1302: ( ( Line (C256 , ( C258 + 1 )) ) . 1 ) = ( C256 * (C259 , 1) ) by L1301 , L1290 , MATRIX_1:def 7;
L1303: ( ( Line (C256 , ( C258 + 1 )) ) . 1 ) is_expressible_by C254 by L1302 , L1298 , L1290;
L1304: ( width C257 ) = 6 by L1295 , MATRIX_1:23;
L1305: 5 in ( Seg ( width C257 ) ) by L1304 , FINSEQ_1:1;
L1306: ( ( Line (C257 , ( C258 + 1 )) ) . 5 ) = ( C257 * (C259 , 5) ) by L1305 , L1290 , MATRIX_1:def 7;
L1307: 3 in ( Seg ( width C256 ) ) by L1300 , FINSEQ_1:1;
L1308: ( ( Line (C256 , ( C258 + 1 )) ) . 3 ) = ( C256 * (C259 , 3) ) by L1307 , L1290 , MATRIX_1:def 7;
L1309: ( ( Line (C256 , ( C258 + 1 )) ) . 3 ) is_expressible_by C254 by L1308 , L1298 , L1290;
L1310: 2 in ( Seg ( width C256 ) ) by L1300 , FINSEQ_1:1;
L1311: ( ( Line (C256 , ( C258 + 1 )) ) . 2 ) = ( C256 * (C259 , 2) ) by L1310 , L1290 , MATRIX_1:def 7;
L1312: ( ( Line (C256 , ( C258 + 1 )) ) . 2 ) is_expressible_by C254 by L1311 , L1298 , L1290;
L1313: 3 in ( Seg ( width C257 ) ) by L1304 , FINSEQ_1:1;
L1314: ( ( Line (C257 , ( C258 + 1 )) ) . 3 ) = ( C257 * (C259 , 3) ) by L1313 , L1290 , MATRIX_1:def 7;
L1315: ( ( Line (C257 , ( C258 + 1 )) ) . 3 ) = ( NEG_MOD (( ( Line (C256 , ( C258 + 1 )) ) . 2 ) , C254) ) by L1314 , L1298 , L1290 , L1311;
L1316: 2 in ( Seg ( width C257 ) ) by L1304 , FINSEQ_1:1;
L1317: ( ( Line (C257 , ( C258 + 1 )) ) . 2 ) = ( C257 * (C259 , 2) ) by L1316 , L1290 , MATRIX_1:def 7;
L1318: ( ( Line (C257 , ( C258 + 1 )) ) . 2 ) = ( NEG_MOD (( ( Line (C256 , ( C258 + 1 )) ) . 3 ) , C254) ) by L1317 , L1298 , L1290 , L1308;
L1319: 5 in ( Seg ( width C256 ) ) by L1300 , FINSEQ_1:1;
L1320: ( ( Line (C256 , ( C258 + 1 )) ) . 5 ) = ( C256 * (C259 , 5) ) by L1319 , L1290 , MATRIX_1:def 7;
L1321: ( ( Line (C257 , ( C258 + 1 )) ) . 5 ) = ( ( Line (C256 , ( C258 + 1 )) ) . 5 ) by L1320 , L1298 , L1290 , L1306;
L1322: ( D59 . 4 ) is_expressible_by C254 by L1297 , L1240;
L1323: (( D59 . 2 ) is_expressible_by C254 & ( D59 . 3 ) is_expressible_by C254) by L1297 , L1240;
L1324: 4 in ( Seg ( width C256 ) ) by L1300 , FINSEQ_1:1;
L1325: ( ( Line (C256 , ( C258 + 1 )) ) . 4 ) = ( C256 * (C259 , 4) ) by L1324 , L1290 , MATRIX_1:def 7;
L1326: ( ( Line (C256 , ( C258 + 1 )) ) . 4 ) is_expressible_by C254 by L1325 , L1298 , L1290;
L1327: 4 in ( Seg ( width C257 ) ) by L1304 , FINSEQ_1:1;
L1328: ( ( Line (C257 , ( C258 + 1 )) ) . 4 ) = ( C257 * (C259 , 4) ) by L1327 , L1290 , MATRIX_1:def 7;
L1329: ( ( Line (C257 , ( C258 + 1 )) ) . 4 ) = ( INV_MOD (( ( Line (C256 , ( C258 + 1 )) ) . 4 ) , C254) ) by L1328 , L1298 , L1290 , L1325;
L1330: 6 in ( Seg ( width C257 ) ) by L1304 , FINSEQ_1:1;
L1331: ( ( Line (C257 , ( C258 + 1 )) ) . 6 ) = ( C257 * (C259 , 6) ) by L1330 , L1290 , MATRIX_1:def 7;
L1332: 6 in ( Seg ( width C256 ) ) by L1300 , FINSEQ_1:1;
L1333: ( ( Line (C256 , ( C258 + 1 )) ) . 6 ) = ( C256 * (C259 , 6) ) by L1332 , L1290 , MATRIX_1:def 7;
L1334: ( ( Line (C257 , ( C258 + 1 )) ) . 6 ) = ( ( Line (C256 , ( C258 + 1 )) ) . 6 ) by L1333 , L1298 , L1290 , L1331;
L1335: ( dom ( ( IDEA_Q (( Line (C257 , ( C258 + 1 )) ) , C254) ) * ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) ) ) = ( MESSAGES ) by FUNCT_2:def 1;
L1336: ( dom ( ( ( IDEA_Q (( Line (C257 , ( C258 + 1 )) ) , C254) ) * ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) ) * ( compose (( IDEA_P_F (C256 , C254 , C258) ) , ( MESSAGES )) ) ) ) = ( MESSAGES ) by L1335 , L1292 , L1291 , RELAT_1:27;
L1337: ( rng ( compose (( ( IDEA_P_F (C256 , C254 , C258) ) ^ ( <* ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) *> ^ <* ( IDEA_Q (( Line (C257 , ( C258 + 1 )) ) , C254) ) *> ) ) , ( MESSAGES )) ) ) = ( rng ( compose (( ( ( IDEA_P_F (C256 , C254 , C258) ) ^ <* ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) *> ) ^ <* ( IDEA_Q (( Line (C257 , ( C258 + 1 )) ) , C254) ) *> ) , ( MESSAGES )) ) ) by FINSEQ_1:32
.= ( rng ( ( IDEA_Q (( Line (C257 , ( C258 + 1 )) ) , C254) ) * ( compose (( ( IDEA_P_F (C256 , C254 , C258) ) ^ <* ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) *> ) , ( MESSAGES )) ) ) ) by FUNCT_7:41;
L1338: ( rng ( compose (( ( IDEA_P_F (C256 , C254 , C258) ) ^ ( <* ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) *> ^ <* ( IDEA_Q (( Line (C257 , ( C258 + 1 )) ) , C254) ) *> ) ) , ( MESSAGES )) ) ) c= ( MESSAGES ) by L1337 , RELAT_1:def 19;
L1339: 1 in ( Seg ( width C257 ) ) by L1304 , FINSEQ_1:1;
L1340: ( ( Line (C257 , ( C258 + 1 )) ) . 1 ) = ( C257 * (C259 , 1) ) by L1339 , L1290 , MATRIX_1:def 7;
L1341: ( ( Line (C257 , ( C258 + 1 )) ) . 1 ) = ( INV_MOD (( ( Line (C256 , ( C258 + 1 )) ) . 1 ) , C254) ) by L1340 , L1298 , L1290 , L1302;
L1342: ( C258 + 1 ) >= C258 by NAT_1:11;
L1343: (for B151 being (Element of ( NAT )) holds (B151 <= C258 implies (( C256 * (B151 , 1) ) is_expressible_by C254 & ( C256 * (B151 , 2) ) is_expressible_by C254 & ( C256 * (B151 , 3) ) is_expressible_by C254 & ( C256 * (B151 , 4) ) is_expressible_by C254 & ( C256 * (B151 , 5) ) is_expressible_by C254 & ( C256 * (B151 , 6) ) is_expressible_by C254 & ( C257 * (B151 , 1) ) is_expressible_by C254 & ( C257 * (B151 , 2) ) is_expressible_by C254 & ( C257 * (B151 , 3) ) is_expressible_by C254 & ( C257 * (B151 , 4) ) is_expressible_by C254 & ( C257 * (B151 , 5) ) is_expressible_by C254 & ( C257 * (B151 , 6) ) is_expressible_by C254 & ( C257 * (B151 , 1) ) = ( INV_MOD (( C256 * (B151 , 1) ) , C254) ) & ( C257 * (B151 , 2) ) = ( NEG_MOD (( C256 * (B151 , 3) ) , C254) ) & ( C257 * (B151 , 3) ) = ( NEG_MOD (( C256 * (B151 , 2) ) , C254) ) & ( C257 * (B151 , 4) ) = ( INV_MOD (( C256 * (B151 , 4) ) , C254) ) & ( C256 * (B151 , 5) ) = ( C257 * (B151 , 5) ) & ( C256 * (B151 , 6) ) = ( C257 * (B151 , 6) ))))
proof
let C260 being (Element of ( NAT ));
assume L1344: C260 <= C258;
L1345: C260 <= ( C258 + 1 ) by L1344 , L1342 , XXREAL_0:2;
thus L1346: thesis by L1345 , L1298;
end;
L1347: ( ( compose (( ( IDEA_P_F (C256 , C254 , ( C258 + 1 )) ) ^ ( IDEA_Q_F (C257 , C254 , ( C258 + 1 )) ) ) , ( MESSAGES )) ) . R8 ) = ( ( compose (( ( ( IDEA_P_F (C256 , C254 , C258) ) ^ <* ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) *> ) ^ ( IDEA_Q_F (C257 , C254 , ( C258 + 1 )) ) ) , ( MESSAGES )) ) . R8 ) by L1018
.= ( ( compose (( ( ( IDEA_P_F (C256 , C254 , C258) ) ^ <* ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) *> ) ^ ( <* ( IDEA_Q (( Line (C257 , ( C258 + 1 )) ) , C254) ) *> ^ ( IDEA_Q_F (C257 , C254 , C258) ) ) ) , ( MESSAGES )) ) . R8 ) by L1041
.= ( ( compose (( ( ( ( IDEA_P_F (C256 , C254 , C258) ) ^ <* ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) *> ) ^ <* ( IDEA_Q (( Line (C257 , ( C258 + 1 )) ) , C254) ) *> ) ^ ( IDEA_Q_F (C257 , C254 , C258) ) ) , ( MESSAGES )) ) . R8 ) by FINSEQ_1:32
.= ( ( compose (( ( ( IDEA_P_F (C256 , C254 , C258) ) ^ ( <* ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) *> ^ <* ( IDEA_Q (( Line (C257 , ( C258 + 1 )) ) , C254) ) *> ) ) ^ ( IDEA_Q_F (C257 , C254 , C258) ) ) , ( MESSAGES )) ) . R8 ) by FINSEQ_1:32
.= ( ( ( compose (( IDEA_Q_F (C257 , C254 , C258) ) , ( MESSAGES )) ) * ( compose (( ( IDEA_P_F (C256 , C254 , C258) ) ^ ( <* ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) *> ^ <* ( IDEA_Q (( Line (C257 , ( C258 + 1 )) ) , C254) ) *> ) ) , ( MESSAGES )) ) ) . R8 ) by L1338 , FUNCT_7:48
.= ( ( ( compose (( IDEA_Q_F (C257 , C254 , C258) ) , ( MESSAGES )) ) * ( ( compose (( <* ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) *> ^ <* ( IDEA_Q (( Line (C257 , ( C258 + 1 )) ) , C254) ) *> ) , ( MESSAGES )) ) * ( compose (( IDEA_P_F (C256 , C254 , C258) ) , ( MESSAGES )) ) ) ) . R8 ) by L1292 , FUNCT_7:48
.= ( ( ( compose (( IDEA_Q_F (C257 , C254 , C258) ) , ( MESSAGES )) ) * ( ( compose (<* ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) , ( IDEA_Q (( Line (C257 , ( C258 + 1 )) ) , C254) ) *> , ( MESSAGES )) ) * ( compose (( IDEA_P_F (C256 , C254 , C258) ) , ( MESSAGES )) ) ) ) . R8 ) by FINSEQ_1:def 9
.= ( ( ( compose (( IDEA_Q_F (C257 , C254 , C258) ) , ( MESSAGES )) ) * ( ( ( ( IDEA_Q (( Line (C257 , ( C258 + 1 )) ) , C254) ) * ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) ) * ( id ( MESSAGES ) ) ) * ( compose (( IDEA_P_F (C256 , C254 , C258) ) , ( MESSAGES )) ) ) ) . R8 ) by FUNCT_7:51
.= ( ( ( compose (( IDEA_Q_F (C257 , C254 , C258) ) , ( MESSAGES )) ) * ( ( ( IDEA_Q (( Line (C257 , ( C258 + 1 )) ) , C254) ) * ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) ) * ( compose (( IDEA_P_F (C256 , C254 , C258) ) , ( MESSAGES )) ) ) ) . R8 ) by FUNCT_2:17
.= ( ( compose (( IDEA_Q_F (C257 , C254 , C258) ) , ( MESSAGES )) ) . ( ( ( ( IDEA_Q (( Line (C257 , ( C258 + 1 )) ) , C254) ) * ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) ) * ( compose (( IDEA_P_F (C256 , C254 , C258) ) , ( MESSAGES )) ) ) . R8 ) ) by L1336 , L1293 , FUNCT_1:13
.= ( ( compose (( IDEA_Q_F (C257 , C254 , C258) ) , ( MESSAGES )) ) . ( ( ( IDEA_Q (( Line (C257 , ( C258 + 1 )) ) , C254) ) * ( IDEA_P (( Line (C256 , ( C258 + 1 )) ) , C254) ) ) . ( ( compose (( IDEA_P_F (C256 , C254 , C258) ) , ( MESSAGES )) ) . R8 ) ) ) by L1291 , L1293 , FUNCT_1:13
.= ( ( compose (( IDEA_Q_F (C257 , C254 , C258) ) , ( MESSAGES )) ) . ( ( compose (( IDEA_P_F (C256 , C254 , C258) ) , ( MESSAGES )) ) . R8 ) ) by L1296 , L1299 , L1323 , L1322 , L1303 , L1312 , L1309 , L1326 , L1341 , L1318 , L1315 , L1329 , L1321 , L1334 , L986
.= ( ( ( compose (( IDEA_Q_F (C257 , C254 , C258) ) , ( MESSAGES )) ) * ( compose (( IDEA_P_F (C256 , C254 , C258) ) , ( MESSAGES )) ) ) . R8 ) by L1291 , L1293 , FUNCT_1:13
.= R8 by L1289 , L1295 , L1296 , L1297 , L1342 , L1343 , L1292 , FUNCT_7:48 , XXREAL_0:2;
thus L1348: thesis by L1347;
end;
L1349: ( len ( IDEA_Q_F (C257 , C254 , ( 0 )) ) ) = ( 0 ) by L899;
L1350: ( IDEA_Q_F (C257 , C254 , ( 0 )) ) = ( {} ) by L1349;
L1351: ( ( IDEA_P_F (C256 , C254 , ( 0 )) ) ^ ( IDEA_Q_F (C257 , C254 , ( 0 )) ) ) = ( IDEA_P_F (C256 , C254 , ( 0 )) ) by L1350 , FINSEQ_1:34
.= ( {} ) by L1287;
L1352: (R8 in ( MESSAGES ) & ( compose (( ( IDEA_P_F (C256 , C254 , ( 0 )) ) ^ ( IDEA_Q_F (C257 , C254 , ( 0 )) ) ) , ( MESSAGES )) ) = ( id ( MESSAGES ) )) by L1351 , FINSEQ_1:def 11 , FUNCT_7:39;
L1353: S11[ ( 0 ) ] by L1352 , FUNCT_1:18;
thus L1354: (for B152 being (Element of ( NAT )) holds S11[ B152 ]) from NAT_1:sch 1(L1353 , L1288);
end;
thus L1355: thesis by L1286;
end;
theorem
L1356: (for B153 being non  empty (Element of ( NAT )) holds (for B154 being (Element of ( NAT )) holds (for B155 , B156 being (Matrix of B154 , 6 , ( NAT )) holds (for B157 being (Element of ( NAT )) holds (for B158 , B159 , B160 , B161 being (FinSequence of ( NAT )) holds (for R8 being (FinSequence of ( NAT )) holds ((B154 >= B157 & ( ( 2 to_power B153 ) + 1 ) is  prime & ( len R8 ) >= 4 & ( R8 . 1 ) is_expressible_by B153 & ( R8 . 2 ) is_expressible_by B153 & ( R8 . 3 ) is_expressible_by B153 & ( R8 . 4 ) is_expressible_by B153 & (for B162 being (Element of ( NAT )) holds (B162 <= B157 implies (( B155 * (B162 , 1) ) is_expressible_by B153 & ( B155 * (B162 , 2) ) is_expressible_by B153 & ( B155 * (B162 , 3) ) is_expressible_by B153 & ( B155 * (B162 , 4) ) is_expressible_by B153 & ( B155 * (B162 , 5) ) is_expressible_by B153 & ( B155 * (B162 , 6) ) is_expressible_by B153 & ( B156 * (B162 , 1) ) is_expressible_by B153 & ( B156 * (B162 , 2) ) is_expressible_by B153 & ( B156 * (B162 , 3) ) is_expressible_by B153 & ( B156 * (B162 , 4) ) is_expressible_by B153 & ( B156 * (B162 , 5) ) is_expressible_by B153 & ( B156 * (B162 , 6) ) is_expressible_by B153 & ( B156 * (B162 , 1) ) = ( INV_MOD (( B155 * (B162 , 1) ) , B153) ) & ( B156 * (B162 , 2) ) = ( NEG_MOD (( B155 * (B162 , 3) ) , B153) ) & ( B156 * (B162 , 3) ) = ( NEG_MOD (( B155 * (B162 , 2) ) , B153) ) & ( B156 * (B162 , 4) ) = ( INV_MOD (( B155 * (B162 , 4) ) , B153) ) & ( B155 * (B162 , 5) ) = ( B156 * (B162 , 5) ) & ( B155 * (B162 , 6) ) = ( B156 * (B162 , 6) )))) & ( B158 . 1 ) is_expressible_by B153 & ( B158 . 2 ) is_expressible_by B153 & ( B158 . 3 ) is_expressible_by B153 & ( B158 . 4 ) is_expressible_by B153 & ( B159 . 1 ) = ( INV_MOD (( B158 . 1 ) , B153) ) & ( B159 . 2 ) = ( NEG_MOD (( B158 . 2 ) , B153) ) & ( B159 . 3 ) = ( NEG_MOD (( B158 . 3 ) , B153) ) & ( B159 . 4 ) = ( INV_MOD (( B158 . 4 ) , B153) ) & ( B160 . 1 ) is_expressible_by B153 & ( B160 . 2 ) is_expressible_by B153 & ( B160 . 3 ) is_expressible_by B153 & ( B160 . 4 ) is_expressible_by B153 & ( B161 . 1 ) = ( INV_MOD (( B160 . 1 ) , B153) ) & ( B161 . 2 ) = ( NEG_MOD (( B160 . 2 ) , B153) ) & ( B161 . 3 ) = ( NEG_MOD (( B160 . 3 ) , B153) ) & ( B161 . 4 ) = ( INV_MOD (( B160 . 4 ) , B153) ) & ( B161 . 5 ) = ( B160 . 5 ) & ( B161 . 6 ) = ( B160 . 6 )) implies ( ( ( IDEA_QS (B159 , B153) ) * ( ( compose (( IDEA_Q_F (B156 , B153 , B157) ) , ( MESSAGES )) ) * ( ( IDEA_QE (B161 , B153) ) * ( ( IDEA_PE (B160 , B153) ) * ( ( compose (( IDEA_P_F (B155 , B153 , B157) ) , ( MESSAGES )) ) * ( IDEA_PS (B158 , B153) ) ) ) ) ) ) . R8 ) = R8)))))))
proof
let C261 being non  empty (Element of ( NAT ));
let C262 being (Element of ( NAT ));
let C263 , C264 being (Matrix of C262 , 6 , ( NAT ));
let C265 being (Element of ( NAT ));
let C266 , C267 , C268 , C269 being (FinSequence of ( NAT ));
let R8 being (FinSequence of ( NAT ));
assume that
L1357: C262 >= C265
and
L1358: ( ( 2 to_power C261 ) + 1 ) is  prime
and
L1359: ( len R8 ) >= 4
and
L1360: (( R8 . 1 ) is_expressible_by C261 & ( R8 . 2 ) is_expressible_by C261 & ( R8 . 3 ) is_expressible_by C261 & ( R8 . 4 ) is_expressible_by C261)
and
L1361: (for B163 being (Element of ( NAT )) holds (B163 <= C265 implies (( C263 * (B163 , 1) ) is_expressible_by C261 & ( C263 * (B163 , 2) ) is_expressible_by C261 & ( C263 * (B163 , 3) ) is_expressible_by C261 & ( C263 * (B163 , 4) ) is_expressible_by C261 & ( C263 * (B163 , 5) ) is_expressible_by C261 & ( C263 * (B163 , 6) ) is_expressible_by C261 & ( C264 * (B163 , 1) ) is_expressible_by C261 & ( C264 * (B163 , 2) ) is_expressible_by C261 & ( C264 * (B163 , 3) ) is_expressible_by C261 & ( C264 * (B163 , 4) ) is_expressible_by C261 & ( C264 * (B163 , 5) ) is_expressible_by C261 & ( C264 * (B163 , 6) ) is_expressible_by C261 & ( C264 * (B163 , 1) ) = ( INV_MOD (( C263 * (B163 , 1) ) , C261) ) & ( C264 * (B163 , 2) ) = ( NEG_MOD (( C263 * (B163 , 3) ) , C261) ) & ( C264 * (B163 , 3) ) = ( NEG_MOD (( C263 * (B163 , 2) ) , C261) ) & ( C264 * (B163 , 4) ) = ( INV_MOD (( C263 * (B163 , 4) ) , C261) ) & ( C263 * (B163 , 5) ) = ( C264 * (B163 , 5) ) & ( C263 * (B163 , 6) ) = ( C264 * (B163 , 6) ))))
and
L1362: (( C266 . 1 ) is_expressible_by C261 & ( C266 . 2 ) is_expressible_by C261 & ( C266 . 3 ) is_expressible_by C261 & ( C266 . 4 ) is_expressible_by C261 & ( C267 . 1 ) = ( INV_MOD (( C266 . 1 ) , C261) ) & ( C267 . 2 ) = ( NEG_MOD (( C266 . 2 ) , C261) ) & ( C267 . 3 ) = ( NEG_MOD (( C266 . 3 ) , C261) ) & ( C267 . 4 ) = ( INV_MOD (( C266 . 4 ) , C261) ))
and
L1363: (( C268 . 1 ) is_expressible_by C261 & ( C268 . 2 ) is_expressible_by C261 & ( C268 . 3 ) is_expressible_by C261 & ( C268 . 4 ) is_expressible_by C261 & ( C269 . 1 ) = ( INV_MOD (( C268 . 1 ) , C261) ) & ( C269 . 2 ) = ( NEG_MOD (( C268 . 2 ) , C261) ) & ( C269 . 3 ) = ( NEG_MOD (( C268 . 3 ) , C261) ) & ( C269 . 4 ) = ( INV_MOD (( C268 . 4 ) , C261) ) & ( C269 . 5 ) = ( C268 . 5 ) & ( C269 . 6 ) = ( C268 . 6 ));
L1364: R8 in ( MESSAGES ) by FINSEQ_1:def 11;
L1365: ( ( IDEA_PS (C266 , C261) ) . R8 ) in ( MESSAGES ) by L1364 , FUNCT_2:5;
reconsider D60 = ( ( IDEA_PS (C266 , C261) ) . R8 ) as (FinSequence of ( NAT )) by L1365 , FINSEQ_1:def 11;
L1366: D60 in ( MESSAGES ) by FINSEQ_1:def 11;
L1367: ( len D60 ) = ( len ( IDEAoperationA (R8 , C266 , C261) ) ) by L922
.= ( len R8 ) by L409;
L1368: ( D60 . 4 ) = ( ( IDEAoperationA (R8 , C266 , C261) ) . 4 ) by L922;
L1369: ( D60 . 4 ) is_expressible_by C261 by L1368 , L1359 , L549;
L1370: ( D60 . 3 ) = ( ( IDEAoperationA (R8 , C266 , C261) ) . 3 ) by L922;
L1371: ( D60 . 3 ) is_expressible_by C261 by L1370 , L1359 , L549;
L1372: ( D60 . 2 ) = ( ( IDEAoperationA (R8 , C266 , C261) ) . 2 ) by L922;
L1373: ( D60 . 2 ) is_expressible_by C261 by L1372 , L1359 , L549;
L1374: ( D60 . 1 ) = ( ( IDEAoperationA (R8 , C266 , C261) ) . 1 ) by L922;
L1375: ( D60 . 1 ) is_expressible_by C261 by L1374 , L1359 , L549;
per cases ;
suppose L1376: C265 = ( 0 );

L1377: ( len ( IDEA_Q_F (C264 , C261 , C265) ) ) = ( 0 ) by L1376 , L899;
L1378: ( IDEA_Q_F (C264 , C261 , C265) ) = ( {} ) by L1377;
L1379: ( len ( IDEA_P_F (C263 , C261 , C265) ) ) = ( 0 ) by L1376 , L876;
L1380: ( IDEA_P_F (C263 , C261 , C265) ) = ( {} ) by L1379;
thus L1381: ( ( ( IDEA_QS (C267 , C261) ) * ( ( compose (( IDEA_Q_F (C264 , C261 , C265) ) , ( MESSAGES )) ) * ( ( IDEA_QE (C269 , C261) ) * ( ( IDEA_PE (C268 , C261) ) * ( ( compose (( IDEA_P_F (C263 , C261 , C265) ) , ( MESSAGES )) ) * ( IDEA_PS (C266 , C261) ) ) ) ) ) ) . R8 ) = ( ( ( IDEA_QS (C267 , C261) ) * ( ( compose (( {} ) , ( MESSAGES )) ) * ( ( IDEA_QE (C269 , C261) ) * ( ( IDEA_PE (C268 , C261) ) * ( ( compose (( {} ) , ( MESSAGES )) ) * ( IDEA_PS (C266 , C261) ) ) ) ) ) ) . R8 ) by L1380 , L1378
.= ( ( ( IDEA_QS (C267 , C261) ) * ( ( id ( MESSAGES ) ) * ( ( IDEA_QE (C269 , C261) ) * ( ( IDEA_PE (C268 , C261) ) * ( ( compose (( {} ) , ( MESSAGES )) ) * ( IDEA_PS (C266 , C261) ) ) ) ) ) ) . R8 ) by FUNCT_7:39
.= ( ( ( IDEA_QS (C267 , C261) ) * ( ( id ( MESSAGES ) ) * ( ( IDEA_QE (C269 , C261) ) * ( ( IDEA_PE (C268 , C261) ) * ( ( id ( MESSAGES ) ) * ( IDEA_PS (C266 , C261) ) ) ) ) ) ) . R8 ) by FUNCT_7:39
.= ( ( ( IDEA_QS (C267 , C261) ) * ( ( IDEA_QE (C269 , C261) ) * ( ( IDEA_PE (C268 , C261) ) * ( ( id ( MESSAGES ) ) * ( IDEA_PS (C266 , C261) ) ) ) ) ) . R8 ) by FUNCT_2:17
.= ( ( ( IDEA_QS (C267 , C261) ) * ( ( IDEA_QE (C269 , C261) ) * ( ( IDEA_PE (C268 , C261) ) * ( IDEA_PS (C266 , C261) ) ) ) ) . R8 ) by FUNCT_2:17
.= ( ( IDEA_QS (C267 , C261) ) . ( ( ( IDEA_QE (C269 , C261) ) * ( ( IDEA_PE (C268 , C261) ) * ( IDEA_PS (C266 , C261) ) ) ) . R8 ) ) by L1364 , FUNCT_2:15
.= ( ( IDEA_QS (C267 , C261) ) . ( ( IDEA_QE (C269 , C261) ) . ( ( ( IDEA_PE (C268 , C261) ) * ( IDEA_PS (C266 , C261) ) ) . R8 ) ) ) by L1364 , FUNCT_2:15
.= ( ( IDEA_QS (C267 , C261) ) . ( ( IDEA_QE (C269 , C261) ) . ( ( IDEA_PE (C268 , C261) ) . D60 ) ) ) by L1364 , FUNCT_2:15
.= ( ( IDEA_QS (C267 , C261) ) . ( ( ( IDEA_QE (C269 , C261) ) * ( IDEA_PE (C268 , C261) ) ) . D60 ) ) by L1366 , FUNCT_2:15
.= ( ( IDEA_QS (C267 , C261) ) . ( ( IDEA_PS (C266 , C261) ) . R8 ) ) by L1358 , L1359 , L1363 , L1367 , L1375 , L1373 , L1371 , L1369 , L1005
.= ( ( ( IDEA_QS (C267 , C261) ) * ( IDEA_PS (C266 , C261) ) ) . R8 ) by L1364 , FUNCT_2:15
.= R8 by L1358 , L1359 , L1360 , L1362 , L999;
end;
suppose L1382: C265 <> ( 0 );

L1383: ( IDEA_P_F (C263 , C261 , C265) ) is (FuncSequence of ( MESSAGES ) , ( MESSAGES )) by L1382 , L1114;
L1384: ( firstdom ( IDEA_P_F (C263 , C261 , C265) ) ) = ( MESSAGES ) by L1383 , FUNCT_7:def 9;
L1385: ( dom ( compose (( IDEA_P_F (C263 , C261 , C265) ) , ( MESSAGES )) ) ) = ( MESSAGES ) by L1384 , L1383 , FUNCT_7:62;
L1386: (( IDEA_P_F (C263 , C261 , C265) ) = ( {} ) implies ( rng ( compose (( IDEA_P_F (C263 , C261 , C265) ) , ( MESSAGES )) ) ) = ( {} )) by L1384 , FUNCT_7:def 6;
L1387: ( rng ( compose (( IDEA_P_F (C263 , C261 , C265) ) , ( MESSAGES )) ) ) c= ( lastrng ( IDEA_P_F (C263 , C261 , C265) ) ) by L1386 , FUNCT_7:59 , XBOOLE_1:2;
L1388: ( lastrng ( IDEA_P_F (C263 , C261 , C265) ) ) c= ( MESSAGES ) by L1383 , FUNCT_7:def 9;
L1389: ( rng ( compose (( IDEA_P_F (C263 , C261 , C265) ) , ( MESSAGES )) ) ) c= ( MESSAGES ) by L1388 , L1387 , XBOOLE_1:1;
reconsider D61 = ( compose (( IDEA_P_F (C263 , C261 , C265) ) , ( MESSAGES )) ) as (Function of ( MESSAGES ) , ( MESSAGES )) by L1389 , L1385 , FUNCT_2:def 1 , RELSET_1:4;
L1390: ( rng D61 ) c= ( MESSAGES ) by RELAT_1:def 19;
L1391: ( D61 . D60 ) in ( MESSAGES ) by L1366 , FUNCT_2:5;
reconsider D62 = ( D61 . D60 ) as (FinSequence of ( NAT )) by L1391 , FINSEQ_1:def 11;
L1392: (( len D62 ) >= 4 & ( D62 . 1 ) is_expressible_by C261) by L1359 , L1367 , L1375 , L1373 , L1371 , L1369 , L1240;
L1393: ( IDEA_Q_F (C264 , C261 , C265) ) is (FuncSequence of ( MESSAGES ) , ( MESSAGES )) by L1382 , L1135;
L1394: ( firstdom ( IDEA_Q_F (C264 , C261 , C265) ) ) = ( MESSAGES ) by L1393 , FUNCT_7:def 9;
L1395: ( dom ( compose (( IDEA_Q_F (C264 , C261 , C265) ) , ( MESSAGES )) ) ) = ( MESSAGES ) by L1394 , L1393 , FUNCT_7:62;
L1396: (( IDEA_Q_F (C264 , C261 , C265) ) = ( {} ) implies ( rng ( compose (( IDEA_Q_F (C264 , C261 , C265) ) , ( MESSAGES )) ) ) = ( {} )) by L1394 , FUNCT_7:def 6;
L1397: ( rng ( compose (( IDEA_Q_F (C264 , C261 , C265) ) , ( MESSAGES )) ) ) c= ( lastrng ( IDEA_Q_F (C264 , C261 , C265) ) ) by L1396 , FUNCT_7:59 , XBOOLE_1:2;
L1398: ( lastrng ( IDEA_Q_F (C264 , C261 , C265) ) ) c= ( MESSAGES ) by L1393 , FUNCT_7:def 9;
L1399: ( rng ( compose (( IDEA_Q_F (C264 , C261 , C265) ) , ( MESSAGES )) ) ) c= ( MESSAGES ) by L1398 , L1397 , XBOOLE_1:1;
reconsider D63 = ( compose (( IDEA_Q_F (C264 , C261 , C265) ) , ( MESSAGES )) ) as (Function of ( MESSAGES ) , ( MESSAGES )) by L1399 , L1395 , FUNCT_2:def 1 , RELSET_1:4;
L1400: D62 in ( MESSAGES ) by FINSEQ_1:def 11;
L1401: ( D63 . ( D61 . D60 ) ) = ( ( D63 * D61 ) . D60 ) by L1366 , FUNCT_2:15
.= ( ( compose (( ( IDEA_P_F (C263 , C261 , C265) ) ^ ( IDEA_Q_F (C264 , C261 , C265) ) ) , ( MESSAGES )) ) . D60 ) by L1390 , FUNCT_7:48
.= D60 by L1357 , L1358 , L1359 , L1361 , L1367 , L1375 , L1373 , L1371 , L1369 , L1285;
L1402: ( D62 . 4 ) is_expressible_by C261 by L1359 , L1367 , L1375 , L1373 , L1371 , L1369 , L1240;
L1403: (( D62 . 2 ) is_expressible_by C261 & ( D62 . 3 ) is_expressible_by C261) by L1359 , L1367 , L1375 , L1373 , L1371 , L1369 , L1240;
thus L1404: ( ( ( IDEA_QS (C267 , C261) ) * ( ( compose (( IDEA_Q_F (C264 , C261 , C265) ) , ( MESSAGES )) ) * ( ( IDEA_QE (C269 , C261) ) * ( ( IDEA_PE (C268 , C261) ) * ( ( compose (( IDEA_P_F (C263 , C261 , C265) ) , ( MESSAGES )) ) * ( IDEA_PS (C266 , C261) ) ) ) ) ) ) . R8 ) = ( ( IDEA_QS (C267 , C261) ) . ( ( D63 * ( ( IDEA_QE (C269 , C261) ) * ( ( IDEA_PE (C268 , C261) ) * ( D61 * ( IDEA_PS (C266 , C261) ) ) ) ) ) . R8 ) ) by L1364 , FUNCT_2:15
.= ( ( IDEA_QS (C267 , C261) ) . ( D63 . ( ( ( IDEA_QE (C269 , C261) ) * ( ( IDEA_PE (C268 , C261) ) * ( D61 * ( IDEA_PS (C266 , C261) ) ) ) ) . R8 ) ) ) by L1364 , FUNCT_2:15
.= ( ( IDEA_QS (C267 , C261) ) . ( D63 . ( ( IDEA_QE (C269 , C261) ) . ( ( ( IDEA_PE (C268 , C261) ) * ( D61 * ( IDEA_PS (C266 , C261) ) ) ) . R8 ) ) ) ) by L1364 , FUNCT_2:15
.= ( ( IDEA_QS (C267 , C261) ) . ( D63 . ( ( IDEA_QE (C269 , C261) ) . ( ( IDEA_PE (C268 , C261) ) . ( ( D61 * ( IDEA_PS (C266 , C261) ) ) . R8 ) ) ) ) ) by L1364 , FUNCT_2:15
.= ( ( IDEA_QS (C267 , C261) ) . ( D63 . ( ( IDEA_QE (C269 , C261) ) . ( ( IDEA_PE (C268 , C261) ) . ( D61 . ( ( IDEA_PS (C266 , C261) ) . R8 ) ) ) ) ) ) by L1364 , FUNCT_2:15
.= ( ( IDEA_QS (C267 , C261) ) . ( D63 . ( ( ( IDEA_QE (C269 , C261) ) * ( IDEA_PE (C268 , C261) ) ) . D62 ) ) ) by L1400 , FUNCT_2:15
.= ( ( IDEA_QS (C267 , C261) ) . D60 ) by L1358 , L1363 , L1392 , L1403 , L1402 , L1401 , L1005
.= ( ( ( IDEA_QS (C267 , C261) ) * ( IDEA_PS (C266 , C261) ) ) . R8 ) by L1364 , FUNCT_2:15
.= R8 by L1358 , L1359 , L1360 , L1362 , L999;
end;
end;
