:: Robbins Algebras vs. Boolean Algebras
::  by Adam Grabowski
::
:: Received June 12, 2001
:: Copyright (c) 2001-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies STRUCT_0, BINOP_1, LATTICES, FUNCT_5, XBOOLE_0, SUBSET_1,
      FUNCT_1, ARYTM_3, EQREL_1, XXREAL_2, ARYTM_1, ROBBINS1, CARD_1;
 notations TARSKI, CARD_1, STRUCT_0, LATTICES, BINOP_1, FUNCT_2, FUNCT_5;
 constructors BINOP_1, LATTICES, FUNCT_5;
 registrations RELSET_1, STRUCT_0, LATTICES, LATTICE2, XBOOLE_0, ZFMISC_1,
      CARD_1, ORDINAL1;
 requirements SUBSET, NUMERALS;
 definitions LATTICES, STRUCT_0;
 theorems STRUCT_0, LATTICES, BINOP_1, CARD_1;
 schemes BINOP_1;

begin
definition
struct (1-sorted) ComplStr(# carrier -> set , Compl -> (UnOp of the carrier) #);
end;
definition
struct (\/-SemiLattStr , ComplStr) ComplLLattStr(# carrier -> set , L_join -> (BinOp of the carrier) , Compl -> (UnOp of the carrier) #);
end;
definition
struct (/\-SemiLattStr , ComplStr) ComplULattStr(# carrier -> set , L_meet -> (BinOp of the carrier) , Compl -> (UnOp of the carrier) #);
end;
definition
struct (ComplLLattStr , LattStr) OrthoLattStr(# carrier -> set , L_join , L_meet -> (BinOp of the carrier) , Compl -> (UnOp of the carrier) #);
end;
definition
func TrivComplLat ->  strict ComplLLattStr equals 
ComplLLattStr (# 1 , ( op2 ) , ( op1 ) #);
coherence;
end;
definition
func TrivOrtLat ->  strict OrthoLattStr equals 
OrthoLattStr (# 1 , ( op2 ) , ( op2 ) , ( op1 ) #);
coherence;
end;
registration
cluster ( TrivComplLat ) -> 1 -element;
coherence
proof
L7: (the carrier of ( TrivComplLat )) = { ( 0 ) } by CARD_1:49;
thus L8: (the carrier of ( TrivComplLat )) is 1 -element by L7;
end;
cluster ( TrivOrtLat ) -> 1 -element;
coherence
proof
L9: (the carrier of ( TrivOrtLat )) = { ( 0 ) } by CARD_1:49;
thus L10: (the carrier of ( TrivOrtLat )) is 1 -element by L9;
end;
end;
registration
cluster  strict 1 -element for OrthoLattStr;
existence
proof
take ( TrivOrtLat );
thus L12: thesis;
end;
cluster  strict 1 -element for ComplLLattStr;
existence
proof
take ( TrivComplLat );
thus L13: thesis;
end;
end;
registration
let C1 being 1 -element ComplLLattStr;
cluster ( the ComplStr of C1 ) -> 1 -element;
coherence
proof
thus L15: (the carrier of ( the ComplStr of C1 )) is 1 -element;
end;
end;
registration
cluster  strict 1 -element for ComplStr;
existence
proof
take ( the ComplStr of ( TrivOrtLat ) );
thus L17: thesis;
end;
end;
definition
let C2 being non  empty ComplStr;
let C3 being (Element of C2);
func C3 ` -> (Element of C2) equals 
( (the Compl of C2) . C3 );
coherence;
end;
notation
let C4 being non  empty ComplLLattStr;
let C5 , C6 being (Element of C4);
synonym C5 + C6 for C5 "\/" C6;
end;
definition
let C7 being non  empty ComplLLattStr;
let C8 , C9 being (Element of C7);
func C8 *' C9 -> (Element of C7) equals 
( ( ( C8 ` ) "\/" ( C9 ` ) ) ` );
coherence;
end;
definition
let C10 being non  empty ComplLLattStr;
attr C10 is  Robbins
means
:L22: (for B1 , B2 being (Element of C10) holds ( ( ( ( B1 + B2 ) ` ) + ( ( B1 + ( B2 ` ) ) ` ) ) ` ) = B1);
attr C10 is  Huntington
means
:L23: (for B3 , B4 being (Element of C10) holds ( ( ( ( B3 ` ) + ( B4 ` ) ) ` ) + ( ( ( B3 ` ) + B4 ) ` ) ) = B3);
end;
definition
let C11 being non  empty \/-SemiLattStr;
attr C11 is  join-idempotent
means
:L25: (for B5 being (Element of C11) holds ( B5 "\/" B5 ) = B5);
end;
registration
cluster ( TrivComplLat ) ->  join-commutative  join-associative  Robbins  Huntington  join-idempotent;
coherence
proof
set D1 = ( TrivComplLat );
thus L27: (for B6 , B7 being (Element of D1) holds ( B6 + B7 ) = ( B7 + B6 )) by STRUCT_0:def 10;
thus L28: (for B8 , B9 , B10 being (Element of D1) holds ( ( B8 + B9 ) + B10 ) = ( B8 + ( B9 + B10 ) )) by STRUCT_0:def 10;
thus L29: (for B11 , B12 being (Element of D1) holds ( ( ( ( B11 + B12 ) ` ) + ( ( B11 + ( B12 ` ) ) ` ) ) ` ) = B11) by STRUCT_0:def 10;
thus L30: (for B13 , B14 being (Element of D1) holds ( ( ( ( B13 ` ) + ( B14 ` ) ) ` ) + ( ( ( B13 ` ) + B14 ) ` ) ) = B13) by STRUCT_0:def 10;
let C12 being (Element of D1);
thus L31: thesis by STRUCT_0:def 10;
end;
cluster ( TrivOrtLat ) ->  join-commutative  join-associative  Huntington  Robbins;
coherence
proof
set D2 = ( TrivOrtLat );
thus L32: (for B15 , B16 being (Element of D2) holds ( B15 + B16 ) = ( B16 + B15 )) by STRUCT_0:def 10;
thus L33: (for B17 , B18 , B19 being (Element of D2) holds ( ( B17 + B18 ) + B19 ) = ( B17 + ( B18 + B19 ) )) by STRUCT_0:def 10;
thus L34: (for B20 , B21 being (Element of D2) holds ( ( ( ( B20 ` ) + ( B21 ` ) ) ` ) + ( ( ( B20 ` ) + B21 ) ` ) ) = B20) by STRUCT_0:def 10;
let C13 , C14 being (Element of D2);
thus L35: thesis by STRUCT_0:def 10;
end;
end;
registration
cluster ( TrivOrtLat ) ->  meet-commutative  meet-associative  meet-absorbing  join-absorbing;
coherence
proof
set D3 = ( TrivOrtLat );
thus L37: (for B22 , B23 being (Element of D3) holds ( B22 "/\" B23 ) = ( B23 "/\" B22 )) by STRUCT_0:def 10;
thus L38: (for B24 , B25 , B26 being (Element of D3) holds ( ( B24 "/\" B25 ) "/\" B26 ) = ( B24 "/\" ( B25 "/\" B26 ) )) by STRUCT_0:def 10;
thus L39: (for B27 , B28 being (Element of D3) holds ( ( B27 "/\" B28 ) "\/" B28 ) = B28) by STRUCT_0:def 10;
let C15 , C16 being (Element of D3);
thus L40: ( C15 "/\" ( C15 "\/" C16 ) ) = C15 by STRUCT_0:def 10;
end;
end;
registration
cluster  strict  join-associative  join-commutative  Robbins  join-idempotent  Huntington for non  empty non  empty non  empty non  empty ComplLLattStr;
existence
proof
take ( TrivComplLat );
thus L42: thesis;
end;
end;
registration
cluster  strict  Lattice-like  Robbins  Huntington for non  empty non  empty non  empty non  empty OrthoLattStr;
existence
proof
take ( TrivOrtLat );
thus L44: thesis;
end;
end;
definition
let C17 being  join-commutative non  empty ComplLLattStr;
let C18 , C19 being (Element of C17);
redefine func C18 + C19;

commutativity
 by LATTICES:def 4;
end;
theorem
L47: (for B29 being  Huntington  join-commutative  join-associative non  empty ComplLLattStr holds (for B30 , B31 being (Element of B29) holds ( ( B30 *' B31 ) + ( B30 *' ( B31 ` ) ) ) = B30)) by L23;
theorem
L48: (for B32 being  Huntington  join-commutative  join-associative non  empty ComplLLattStr holds (for B33 being (Element of B32) holds ( B33 + ( B33 ` ) ) = ( ( B33 ` ) + ( ( B33 ` ) ` ) )))
proof
let C20 being  Huntington  join-commutative  join-associative non  empty ComplLLattStr;
let C21 being (Element of C20);
set D4 = ( C21 ` );
set D5 = ( ( D4 ` ) ` );
L49: (C21 = ( ( ( ( C21 ` ) + ( ( D4 ` ) ` ) ) ` ) + ( ( ( C21 ` ) + ( D4 ` ) ) ` ) ) & ( C21 ` ) = ( ( ( ( ( C21 ` ) ` ) + ( ( ( C21 ` ) ` ) ` ) ) ` ) + ( ( ( ( C21 ` ) ` ) + ( ( C21 ` ) ` ) ) ` ) )) by L23;
L50: ( C21 + ( C21 ` ) ) = ( ( ( ( ( D4 + D5 ) ` ) + ( ( D4 + ( D4 ` ) ) ` ) ) + ( ( ( D4 ` ) + ( D4 ` ) ) ` ) ) + ( ( ( D4 ` ) + D5 ) ` ) ) by L49 , LATTICES:def 5
.= ( ( ( ( ( ( D4 ` ) + ( D4 ` ) ) ` ) + ( ( D4 + ( D4 ` ) ) ` ) ) + ( ( D4 + D5 ) ` ) ) + ( ( ( D4 ` ) + D5 ) ` ) ) by LATTICES:def 5
.= ( ( ( ( ( D4 ` ) + D4 ) ` ) + ( ( ( D4 ` ) + ( D4 ` ) ) ` ) ) + ( ( ( D4 + D5 ) ` ) + ( ( ( D4 ` ) + D5 ) ` ) ) ) by LATTICES:def 5
.= ( D4 + ( ( ( D4 + D5 ) ` ) + ( ( ( D4 ` ) + D5 ) ` ) ) ) by L23
.= ( D4 + ( D4 ` ) ) by L23;
thus L51: thesis by L50;
end;
theorem
L52: (for B34 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B35 being (Element of B34) holds ( ( B35 ` ) ` ) = B35))
proof
let C22 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C23 being (Element of C22);
set D6 = ( C23 ` );
L53: (( ( ( ( ( D6 ` ) ` ) + ( D6 ` ) ) ` ) + ( ( ( ( D6 ` ) ` ) + D6 ) ` ) ) = ( D6 ` ) & ( ( ( D6 + ( ( D6 ` ) ` ) ) ` ) + ( ( D6 + ( D6 ` ) ) ` ) ) = C23) by L23;
thus L54: thesis by L53 , L48;
end;
theorem
L55: (for B36 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B37 , B38 being (Element of B36) holds ( B37 + ( B37 ` ) ) = ( B38 + ( B38 ` ) )))
proof
let C24 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C25 , C26 being (Element of C24);
thus L56: ( C25 + ( C25 ` ) ) = ( ( ( ( ( C25 ` ) + ( ( C26 ` ) ` ) ) ` ) + ( ( ( C25 ` ) + ( C26 ` ) ) ` ) ) + ( C25 ` ) ) by L23
.= ( ( ( ( ( C25 ` ) + ( ( C26 ` ) ` ) ) ` ) + ( ( ( C25 ` ) + ( C26 ` ) ) ` ) ) + ( ( ( ( ( C25 ` ) ` ) + ( ( C26 ` ) ` ) ) ` ) + ( ( ( ( C25 ` ) ` ) + ( C26 ` ) ) ` ) ) ) by L23
.= ( ( ( ( ( C25 ` ) ` ) + ( C26 ` ) ) ` ) + ( ( ( ( ( C25 ` ) ` ) + ( ( C26 ` ) ` ) ) ` ) + ( ( ( ( C25 ` ) + ( ( C26 ` ) ` ) ) ` ) + ( ( ( C25 ` ) + ( C26 ` ) ) ` ) ) ) ) by LATTICES:def 5
.= ( ( ( ( ( C25 ` ) ` ) + ( C26 ` ) ) ` ) + ( ( ( ( C25 ` ) + ( C26 ` ) ) ` ) + ( ( ( ( C25 ` ) + ( ( C26 ` ) ` ) ) ` ) + ( ( ( ( C25 ` ) ` ) + ( ( C26 ` ) ` ) ) ` ) ) ) ) by LATTICES:def 5
.= ( ( ( ( ( ( C25 ` ) ` ) + ( C26 ` ) ) ` ) + ( ( ( C25 ` ) + ( C26 ` ) ) ` ) ) + ( ( ( ( C25 ` ) + ( ( C26 ` ) ` ) ) ` ) + ( ( ( ( C25 ` ) ` ) + ( ( C26 ` ) ` ) ) ` ) ) ) by LATTICES:def 5
.= ( C26 + ( ( ( ( ( C25 ` ) ` ) + ( ( C26 ` ) ` ) ) ` ) + ( ( ( C25 ` ) + ( ( C26 ` ) ` ) ) ` ) ) ) by L23
.= ( C26 + ( C26 ` ) ) by L23;
end;
theorem
L57: (for B39 being  join-commutative  join-associative  join-idempotent  Huntington non  empty ComplLLattStr holds (ex B40 being (Element of B39) st (for B41 being (Element of B39) holds (( B40 + B41 ) = B40 & ( B41 + ( B41 ` ) ) = B40))))
proof
let C27 being  join-commutative  join-associative  join-idempotent  Huntington non  empty ComplLLattStr;
set D7 = the (Element of C27);
take D8 = ( ( D7 ` ) + D7 );
let C28 being (Element of C27);
thus L58: ( D8 + C28 ) = ( ( ( C28 ` ) + C28 ) + C28 ) by L55
.= ( ( C28 ` ) + ( C28 + C28 ) ) by LATTICES:def 5
.= ( ( C28 ` ) + C28 ) by L25
.= D8 by L55;
thus L59: thesis by L55;
end;
theorem
L60: (for B42 being  join-commutative  join-associative  join-idempotent  Huntington non  empty ComplLLattStr holds B42 is  upper-bounded)
proof
let C29 being  join-commutative  join-associative  join-idempotent  Huntington non  empty ComplLLattStr;
consider C30 being (Element of C29) such that L61: (for B43 being (Element of C29) holds (( C30 + B43 ) = C30 & ( B43 + ( B43 ` ) ) = C30)) by L57;
L62: (for B44 being (Element of C29) holds (( B44 + C30 ) = C30 & ( B44 + ( B44 ` ) ) = C30)) by L61;
thus L63: thesis by L62 , L61 , LATTICES:def 14;
end;
registration
cluster  join-commutative  join-associative  join-idempotent  Huntington ->  upper-bounded for non  empty non  empty non  empty non  empty ComplLLattStr;
coherence by L60;
end;
definition
let C31 being  join-commutative  join-associative  join-idempotent  Huntington non  empty ComplLLattStr;
redefine func Top C31 means 
:L65: (ex B45 being (Element of C31) st it = ( B45 + ( B45 ` ) ));
compatibility
proof
let C32 being (Element of C31);
thus L66:now
set D9 = the (Element of C31);
assume L67: C32 = ( Top C31 );
take D10 = D9;
L68: (for B46 being (Element of C31) holds (( ( D10 + ( D10 ` ) ) + B46 ) = ( D10 + ( D10 ` ) ) & ( B46 + ( D10 + ( D10 ` ) ) ) = ( D10 + ( D10 ` ) )))
proof
let C33 being (Element of C31);
L69: ( ( D10 + ( D10 ` ) ) + C33 ) = ( ( C33 + ( C33 ` ) ) + C33 ) by L55
.= ( ( C33 ` ) + ( C33 + C33 ) ) by LATTICES:def 5
.= ( ( C33 ` ) + C33 ) by L25
.= ( ( D10 ` ) + D10 ) by L55;
thus L70: thesis by L69;
end;
thus L71: C32 = ( D10 + ( D10 ` ) ) by L68 , L67 , LATTICES:def 17;
end;
given C34 being (Element of C31) such that
L72: C32 = ( C34 + ( C34 ` ) );

L73: (for B47 being (Element of C31) holds ( ( C34 + ( C34 ` ) ) + B47 ) = ( C34 + ( C34 ` ) ))
proof
let C35 being (Element of C31);
L74: ( ( C34 + ( C34 ` ) ) + C35 ) = ( ( C35 + ( C35 ` ) ) + C35 ) by L55
.= ( ( C35 ` ) + ( C35 + C35 ) ) by LATTICES:def 5
.= ( ( C35 ` ) + C35 ) by L25
.= ( ( C34 ` ) + C34 ) by L55;
thus L75: thesis by L74;
end;
L76: (for B48 being (Element of C31) holds ( B48 + ( C34 + ( C34 ` ) ) ) = ( C34 + ( C34 ` ) )) by L73;
thus L77: thesis by L76 , L72 , L73 , LATTICES:def 17;
end;
end;
theorem
L79: (for B49 being  join-commutative  join-associative  join-idempotent  Huntington non  empty ComplLLattStr holds (ex B50 being (Element of B49) st (for B51 being (Element of B49) holds (( B50 *' B51 ) = B50 & ( ( B51 + ( B51 ` ) ) ` ) = B50))))
proof
let C36 being  join-commutative  join-associative  join-idempotent  Huntington non  empty ComplLLattStr;
set D11 = the (Element of C36);
take D12 = ( ( ( D11 ` ) + D11 ) ` );
let C37 being (Element of C36);
thus L80: ( D12 *' C37 ) = ( ( ( ( D11 ` ) + D11 ) + ( C37 ` ) ) ` ) by L52
.= ( ( ( ( C37 ` ) + C37 ) + ( C37 ` ) ) ` ) by L55
.= ( ( C37 + ( ( C37 ` ) + ( C37 ` ) ) ) ` ) by LATTICES:def 5
.= ( ( C37 + ( C37 ` ) ) ` ) by L25
.= D12 by L55;
thus L81: thesis by L55;
end;
definition
let C38 being  join-commutative  join-associative non  empty ComplLLattStr;
let C39 , C40 being (Element of C38);
redefine func C39 *' C40;

commutativity
proof
let C41 , C42 being (Element of C38);
thus L82: ( C41 *' C42 ) = ( ( ( C41 ` ) + ( C42 ` ) ) ` )
.= ( C42 *' C41 );
end;
end;
definition
let C43 being  join-commutative  join-associative  join-idempotent  Huntington non  empty ComplLLattStr;
func Bot C43 -> (Element of C43) means 
:L84: (for B52 being (Element of C43) holds ( it *' B52 ) = it);
existence
proof
L85: (ex B53 being (Element of C43) st (for B54 being (Element of C43) holds (( B53 *' B54 ) = B53 & ( ( B54 + ( B54 ` ) ) ` ) = B53))) by L79;
thus L86: thesis by L85;
end;
uniqueness
proof
let C44 , C45 being (Element of C43);
assume that
L87: (for B55 being (Element of C43) holds ( C44 *' B55 ) = C44)
and
L88: (for B56 being (Element of C43) holds ( C45 *' B56 ) = C45);
thus L89: C44 = ( C45 *' C44 ) by L87
.= C45 by L88;
end;
end;
theorem
L91: (for B57 being  join-commutative  join-associative  join-idempotent  Huntington non  empty ComplLLattStr holds (for B58 being (Element of B57) holds ( Bot B57 ) = ( ( B58 + ( B58 ` ) ) ` )))
proof
let C46 being  join-commutative  join-associative  join-idempotent  Huntington non  empty ComplLLattStr;
let C47 being (Element of C46);
L92: (for B59 being (Element of C46) holds ( ( ( C47 + ( C47 ` ) ) ` ) *' B59 ) = ( ( C47 + ( C47 ` ) ) ` ))
proof
let C48 being (Element of C46);
L93: ( ( ( C47 + ( C47 ` ) ) ` ) *' C48 ) = ( ( ( ( ( C48 + ( C48 ` ) ) ` ) ` ) + ( C48 ` ) ) ` ) by L55
.= ( ( ( C48 + ( C48 ` ) ) + ( C48 ` ) ) ` ) by L52
.= ( ( C48 + ( ( C48 ` ) + ( C48 ` ) ) ) ` ) by LATTICES:def 5
.= ( ( C48 + ( C48 ` ) ) ` ) by L25
.= ( ( ( C47 ` ) + C47 ) ` ) by L55;
thus L94: thesis by L93;
end;
thus L95: thesis by L92 , L84;
end;
theorem
L96: (for B60 being  join-commutative  join-associative  join-idempotent  Huntington non  empty ComplLLattStr holds (( ( Top B60 ) ` ) = ( Bot B60 ) & ( Top B60 ) = ( ( Bot B60 ) ` )))
proof
let C49 being  join-commutative  join-associative  join-idempotent  Huntington non  empty ComplLLattStr;
set D13 = the (Element of C49);
thus L97: ( ( Top C49 ) ` ) = ( ( D13 + ( D13 ` ) ) ` ) by L65
.= ( Bot C49 ) by L91;
thus L98: thesis by L97 , L52;
end;
theorem
L99: (for B61 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B62 , B63 being (Element of B61) holds (( B62 ` ) = ( B63 ` ) implies B62 = B63)))
proof
let C50 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C51 , C52 being (Element of C50);
assume L100: ( C51 ` ) = ( C52 ` );
thus L101: C51 = ( ( C51 ` ) ` ) by L52
.= C52 by L100 , L52;
end;
theorem
L102: (for B64 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B65 , B66 being (Element of B64) holds ( B65 + ( ( B66 + ( B66 ` ) ) ` ) ) = B65))
proof
let C53 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C54 , C55 being (Element of C53);
set D14 = ( C55 + ( C55 ` ) );
L103: ( ( D14 ` ) ` ) = D14 by L52;
L104: ( D14 ` ) = ( ( ( ( ( D14 ` ) ` ) + ( ( D14 ` ) ` ) ) ` ) + ( ( ( ( D14 ` ) ` ) + ( D14 ` ) ) ` ) ) by L23
.= ( ( ( D14 + D14 ) ` ) + ( D14 ` ) ) by L103 , L55;
L105: D14 = ( ( C54 ` ) + C54 ) by L55;
L106: D14 = ( D14 + ( D14 ` ) ) by L55
.= ( ( D14 + ( D14 ` ) ) + ( ( D14 + D14 ) ` ) ) by L104 , LATTICES:def 5
.= ( D14 + ( ( D14 + D14 ) ` ) ) by L55;
L107: ( D14 + D14 ) = ( ( D14 + D14 ) + ( ( D14 + D14 ) ` ) ) by L106 , LATTICES:def 5
.= D14 by L55;
thus L108: ( C54 + ( D14 ` ) ) = ( ( ( ( ( C54 ` ) + ( C54 ` ) ) ` ) + ( ( ( C54 ` ) + C54 ) ` ) ) + ( ( ( ( C54 ` ) + C54 ) ` ) + ( ( ( C54 ` ) + C54 ) ` ) ) ) by L107 , L104 , L105 , L23
.= ( ( ( ( C54 ` ) + ( C54 ` ) ) ` ) + ( ( ( ( C54 ` ) + C54 ) ` ) + ( ( ( C54 ` ) + C54 ) ` ) ) ) by L104 , L107 , L105 , LATTICES:def 5
.= C54 by L104 , L107 , L105 , L23;
end;
theorem
L109: (for B67 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B68 being (Element of B67) holds ( B68 + B68 ) = B68))
proof
let C56 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C57 being (Element of C56);
L110: ( ( C57 + C57 ) ` ) = ( ( ( ( ( C57 ` ) ` ) + ( C57 ` ) ) ` ) + ( ( C57 + C57 ) ` ) ) by L102
.= ( ( ( ( ( C57 ` ) ` ) + ( C57 ` ) ) ` ) + ( ( ( ( C57 ` ) ` ) + C57 ) ` ) ) by L52
.= ( C57 ` ) by L23;
thus L111: ( C57 + C57 ) = ( ( ( C57 + C57 ) ` ) ` ) by L52
.= C57 by L110 , L52;
end;
registration
cluster  join-commutative  join-associative  Huntington ->  join-idempotent for non  empty non  empty non  empty non  empty ComplLLattStr;
coherence
proof
let C58 being non  empty ComplLLattStr;
assume L112: C58 is  join-commutative  join-associative  Huntington;
L113: (for B69 being (Element of C58) holds ( B69 + B69 ) = B69) by L112 , L109;
thus L114: thesis by L113 , L25;
end;
end;
theorem
L116: (for B70 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B71 being (Element of B70) holds ( B71 + ( Bot B70 ) ) = B71))
proof
let C59 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C60 being (Element of C59);
L117: C60 = ( ( ( ( C60 ` ) + ( C60 ` ) ) ` ) + ( ( ( C60 ` ) + C60 ) ` ) ) by L23
.= ( ( ( C60 ` ) ` ) + ( ( ( C60 ` ) + C60 ) ` ) ) by L25
.= ( C60 + ( ( ( C60 ` ) + C60 ) ` ) ) by L52;
thus L118: thesis by L117 , L91;
end;
theorem
L119: (for B72 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B73 being (Element of B72) holds ( B73 *' ( Top B72 ) ) = B73))
proof
let C61 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C62 being (Element of C61);
L120: ( C62 *' ( Top C61 ) ) = ( ( ( C62 ` ) + ( Bot C61 ) ) ` ) by L96
.= ( ( C62 ` ) ` ) by L116
.= C62 by L52;
thus L121: thesis by L120;
end;
theorem
L122: (for B74 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B75 being (Element of B74) holds ( B75 *' ( B75 ` ) ) = ( Bot B74 )))
proof
let C63 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C64 being (Element of C63);
thus L123: ( C64 *' ( C64 ` ) ) = ( ( Top C63 ) ` ) by L65
.= ( Bot C63 ) by L96;
end;
theorem
L124: (for B76 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B77 , B78 , B79 being (Element of B76) holds ( B77 *' ( B78 *' B79 ) ) = ( ( B77 *' B78 ) *' B79 )))
proof
let C65 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C66 , C67 , C68 being (Element of C65);
thus L125: ( ( C66 *' C67 ) *' C68 ) = ( ( ( ( C66 ` ) + ( C67 ` ) ) + ( C68 ` ) ) ` ) by L52
.= ( ( ( C66 ` ) + ( ( C67 ` ) + ( C68 ` ) ) ) ` ) by LATTICES:def 5
.= ( C66 *' ( C67 *' C68 ) ) by L52;
end;
theorem
L126: (for B80 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B81 , B82 being (Element of B80) holds ( B81 + B82 ) = ( ( ( B81 ` ) *' ( B82 ` ) ) ` )))
proof
let C69 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C70 , C71 being (Element of C69);
L127: ( ( C70 ` ) *' ( C71 ` ) ) = ( ( ( ( C70 ` ) ` ) + C71 ) ` ) by L52
.= ( ( C70 + C71 ) ` ) by L52;
thus L128: thesis by L127 , L52;
end;
theorem
L129: (for B83 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B84 being (Element of B83) holds ( B84 *' B84 ) = B84))
proof
let C72 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C73 being (Element of C72);
thus L130: ( C73 *' C73 ) = ( ( C73 ` ) ` ) by L25
.= C73 by L52;
end;
theorem
L131: (for B85 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B86 being (Element of B85) holds ( B86 + ( Top B85 ) ) = ( Top B85 )))
proof
let C74 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C75 being (Element of C74);
thus L132: ( C75 + ( Top C74 ) ) = ( C75 + ( C75 + ( C75 ` ) ) ) by L65
.= ( ( C75 + C75 ) + ( C75 ` ) ) by LATTICES:def 5
.= ( C75 + ( C75 ` ) ) by L25
.= ( Top C74 ) by L65;
end;
theorem
L133: (for B87 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B88 , B89 being (Element of B87) holds ( B88 + ( B88 *' B89 ) ) = B88))
proof
let C76 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C77 , C78 being (Element of C76);
thus L134: ( C77 + ( C77 *' C78 ) ) = ( ( C77 *' C78 ) + ( ( C77 *' C78 ) + ( C77 *' ( C78 ` ) ) ) ) by L23
.= ( ( ( C77 *' C78 ) + ( C77 *' C78 ) ) + ( C77 *' ( C78 ` ) ) ) by LATTICES:def 5
.= ( ( C77 *' C78 ) + ( C77 *' ( C78 ` ) ) ) by L25
.= C77 by L23;
end;
theorem
L135: (for B90 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B91 , B92 being (Element of B90) holds ( B91 *' ( B91 + B92 ) ) = B91))
proof
let C79 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C80 , C81 being (Element of C79);
thus L136: ( C80 *' ( C80 + C81 ) ) = ( ( ( C80 ` ) + ( ( ( ( C80 ` ) *' ( C81 ` ) ) ` ) ` ) ) ` ) by L126
.= ( ( ( C80 ` ) + ( ( C80 ` ) *' ( C81 ` ) ) ) ` ) by L52
.= ( ( C80 ` ) ` ) by L133
.= C80 by L52;
end;
theorem
L137: (for B93 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B94 , B95 being (Element of B93) holds ((( ( B94 ` ) + B95 ) = ( Top B93 ) & ( ( B95 ` ) + B94 ) = ( Top B93 )) implies B94 = B95)))
proof
let C82 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C83 , C84 being (Element of C82);
assume L138: (( ( C83 ` ) + C84 ) = ( Top C82 ) & ( ( C84 ` ) + C83 ) = ( Top C82 ));
thus L139: C83 = ( ( ( ( C83 ` ) + ( C84 ` ) ) ` ) + ( ( ( C83 ` ) + C84 ) ` ) ) by L23
.= C84 by L138 , L23;
end;
theorem
L140: (for B96 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B97 , B98 being (Element of B96) holds ((( B97 + B98 ) = ( Top B96 ) & ( B97 *' B98 ) = ( Bot B96 )) implies ( B97 ` ) = B98)))
proof
let C85 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C86 , C87 being (Element of C85);
assume L141: ( C86 + C87 ) = ( Top C85 );
L142: ( ( ( C86 ` ) ` ) + C87 ) = ( Top C85 ) by L141 , L52;
assume L143: ( C86 *' C87 ) = ( Bot C85 );
L144: ( ( C87 ` ) + ( C86 ` ) ) = ( ( ( ( C86 ` ) + ( C87 ` ) ) ` ) ` ) by L52
.= ( Top C85 ) by L143 , L96;
thus L145: thesis by L144 , L142 , L137;
end;
theorem
L146: (for B99 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B100 , B101 , B102 being (Element of B99) holds ( ( ( ( ( ( ( ( ( B100 *' B101 ) *' B102 ) + ( ( B100 *' B101 ) *' ( B102 ` ) ) ) + ( ( B100 *' ( B101 ` ) ) *' B102 ) ) + ( ( B100 *' ( B101 ` ) ) *' ( B102 ` ) ) ) + ( ( ( B100 ` ) *' B101 ) *' B102 ) ) + ( ( ( B100 ` ) *' B101 ) *' ( B102 ` ) ) ) + ( ( ( B100 ` ) *' ( B101 ` ) ) *' B102 ) ) + ( ( ( B100 ` ) *' ( B101 ` ) ) *' ( B102 ` ) ) ) = ( Top B99 )))
proof
let C88 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C89 , C90 , C91 being (Element of C88);
set D15 = ( ( C89 *' C90 ) *' C91 );
set D16 = ( ( C89 *' C90 ) *' ( C91 ` ) );
set D17 = ( ( C89 *' ( C90 ` ) ) *' C91 );
set D18 = ( ( C89 *' ( C90 ` ) ) *' ( C91 ` ) );
set D19 = ( ( ( C89 ` ) *' C90 ) *' C91 );
set D20 = ( ( ( C89 ` ) *' C90 ) *' ( C91 ` ) );
set D21 = ( ( ( C89 ` ) *' ( C90 ` ) ) *' C91 );
set D22 = ( ( ( C89 ` ) *' ( C90 ` ) ) *' ( C91 ` ) );
L147: ( ( ( ( ( ( ( D15 + D16 ) + D17 ) + D18 ) + D19 ) + D20 ) + D21 ) + D22 ) = ( ( ( ( ( ( ( C89 *' C90 ) + D17 ) + D18 ) + D19 ) + D20 ) + D21 ) + D22 ) by L23
.= ( ( ( ( ( ( C89 *' C90 ) + ( D17 + D18 ) ) + D19 ) + D20 ) + D21 ) + D22 ) by LATTICES:def 5
.= ( ( ( ( ( ( C89 *' C90 ) + ( C89 *' ( C90 ` ) ) ) + D19 ) + D20 ) + D21 ) + D22 ) by L23
.= ( ( ( ( ( C89 *' C90 ) + ( C89 *' ( C90 ` ) ) ) + ( D19 + D20 ) ) + D21 ) + D22 ) by LATTICES:def 5
.= ( ( ( ( ( C89 *' C90 ) + ( C89 *' ( C90 ` ) ) ) + ( ( C89 ` ) *' C90 ) ) + D21 ) + D22 ) by L23
.= ( ( ( ( C89 *' C90 ) + ( C89 *' ( C90 ` ) ) ) + ( ( C89 ` ) *' C90 ) ) + ( D21 + D22 ) ) by LATTICES:def 5
.= ( ( ( ( C89 *' C90 ) + ( C89 *' ( C90 ` ) ) ) + ( ( C89 ` ) *' C90 ) ) + ( ( C89 ` ) *' ( C90 ` ) ) ) by L23
.= ( ( C89 + ( ( C89 ` ) *' C90 ) ) + ( ( C89 ` ) *' ( C90 ` ) ) ) by L23
.= ( C89 + ( ( ( C89 ` ) *' C90 ) + ( ( C89 ` ) *' ( C90 ` ) ) ) ) by LATTICES:def 5
.= ( C89 + ( C89 ` ) ) by L23;
thus L148: thesis by L147 , L65;
end;
theorem
L149: (for B103 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B104 , B105 , B106 being (Element of B103) holds (( ( B104 *' B106 ) *' ( B105 *' ( B106 ` ) ) ) = ( Bot B103 ) & ( ( ( B104 *' B105 ) *' B106 ) *' ( ( ( B104 ` ) *' B105 ) *' B106 ) ) = ( Bot B103 ) & ( ( ( B104 *' ( B105 ` ) ) *' B106 ) *' ( ( ( B104 ` ) *' B105 ) *' B106 ) ) = ( Bot B103 ) & ( ( ( B104 *' B105 ) *' B106 ) *' ( ( ( B104 ` ) *' ( B105 ` ) ) *' B106 ) ) = ( Bot B103 ) & ( ( ( B104 *' B105 ) *' ( B106 ` ) ) *' ( ( ( B104 ` ) *' ( B105 ` ) ) *' ( B106 ` ) ) ) = ( Bot B103 ))))
proof
let C92 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C93 , C94 , C95 being (Element of C92);
L150: (for B107 , B108 , B109 being (Element of C92) holds ( ( B107 *' B109 ) *' ( B108 *' ( B109 ` ) ) ) = ( Bot C92 ))
proof
let C96 , C97 , C98 being (Element of C92);
thus L151: ( ( C96 *' C98 ) *' ( C97 *' ( C98 ` ) ) ) = ( ( ( C96 *' C98 ) *' ( C98 ` ) ) *' C97 ) by L124
.= ( ( C96 *' ( C98 *' ( C98 ` ) ) ) *' C97 ) by L124
.= ( ( C96 *' ( Bot C92 ) ) *' C97 ) by L122
.= ( ( Bot C92 ) *' C97 ) by L84
.= ( Bot C92 ) by L84;
end;
thus L152: ( ( C93 *' C95 ) *' ( C94 *' ( C95 ` ) ) ) = ( Bot C92 ) by L150;
thus L153: ( ( ( C93 *' C94 ) *' C95 ) *' ( ( ( C93 ` ) *' C94 ) *' C95 ) ) = ( ( C93 *' ( C94 *' C95 ) ) *' ( ( ( C93 ` ) *' C94 ) *' C95 ) ) by L124
.= ( ( ( ( C94 *' C95 ) *' C93 ) *' ( ( C93 ` ) *' C94 ) ) *' C95 ) by L124
.= ( ( ( ( ( C94 *' C95 ) *' C93 ) *' ( C93 ` ) ) *' C94 ) *' C95 ) by L124
.= ( ( ( ( C94 *' C95 ) *' ( C93 *' ( C93 ` ) ) ) *' C94 ) *' C95 ) by L124
.= ( ( ( C94 *' C95 ) *' ( C93 *' ( C93 ` ) ) ) *' ( C94 *' C95 ) ) by L124
.= ( ( ( C94 *' C95 ) *' ( Bot C92 ) ) *' ( C94 *' C95 ) ) by L122
.= ( ( Bot C92 ) *' ( C94 *' C95 ) ) by L84
.= ( Bot C92 ) by L84;
thus L154: ( ( ( C93 *' ( C94 ` ) ) *' C95 ) *' ( ( ( C93 ` ) *' C94 ) *' C95 ) ) = ( ( C93 *' ( ( C94 ` ) *' C95 ) ) *' ( ( ( C93 ` ) *' C94 ) *' C95 ) ) by L124
.= ( ( ( ( C94 ` ) *' C95 ) *' C93 ) *' ( ( C93 ` ) *' ( C94 *' C95 ) ) ) by L124
.= ( ( ( ( ( C94 ` ) *' C95 ) *' C93 ) *' ( C93 ` ) ) *' ( C94 *' C95 ) ) by L124
.= ( ( ( ( C94 ` ) *' C95 ) *' ( C93 *' ( C93 ` ) ) ) *' ( C94 *' C95 ) ) by L124
.= ( ( ( ( C94 ` ) *' C95 ) *' ( Bot C92 ) ) *' ( C94 *' C95 ) ) by L122
.= ( ( Bot C92 ) *' ( C94 *' C95 ) ) by L84
.= ( Bot C92 ) by L84;
thus L155: ( ( ( C93 *' C94 ) *' C95 ) *' ( ( ( C93 ` ) *' ( C94 ` ) ) *' C95 ) ) = ( ( C93 *' ( C94 *' C95 ) ) *' ( ( ( C93 ` ) *' ( C94 ` ) ) *' C95 ) ) by L124
.= ( ( C93 *' ( C94 *' C95 ) ) *' ( ( C93 ` ) *' ( ( C94 ` ) *' C95 ) ) ) by L124
.= ( Bot C92 ) by L150;
thus L156: ( ( ( C93 *' C94 ) *' ( C95 ` ) ) *' ( ( ( C93 ` ) *' ( C94 ` ) ) *' ( C95 ` ) ) ) = ( ( C93 *' ( C94 *' ( C95 ` ) ) ) *' ( ( ( C93 ` ) *' ( C94 ` ) ) *' ( C95 ` ) ) ) by L124
.= ( ( C93 *' ( C94 *' ( C95 ` ) ) ) *' ( ( C93 ` ) *' ( ( C94 ` ) *' ( C95 ` ) ) ) ) by L124
.= ( Bot C92 ) by L150;
end;
theorem
L157: (for B110 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B111 , B112 , B113 being (Element of B110) holds ( ( B111 *' B112 ) + ( B111 *' B113 ) ) = ( ( ( ( B111 *' B112 ) *' B113 ) + ( ( B111 *' B112 ) *' ( B113 ` ) ) ) + ( ( B111 *' ( B112 ` ) ) *' B113 ) )))
proof
let C99 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C100 , C101 , C102 being (Element of C99);
set D23 = ( ( C100 *' C101 ) *' C102 );
L158: ( C100 *' C102 ) = ( ( ( C100 *' C102 ) *' C101 ) + ( ( C100 *' C102 ) *' ( C101 ` ) ) ) by L23
.= ( D23 + ( ( C100 *' C102 ) *' ( C101 ` ) ) ) by L124
.= ( D23 + ( ( C100 *' ( C101 ` ) ) *' C102 ) ) by L124;
thus L159: ( ( C100 *' C101 ) + ( C100 *' C102 ) ) = ( ( D23 + ( ( C100 *' C101 ) *' ( C102 ` ) ) ) + ( D23 + ( ( C100 *' ( C101 ` ) ) *' C102 ) ) ) by L158 , L23
.= ( ( D23 + ( ( ( C100 *' C101 ) *' ( C102 ` ) ) + D23 ) ) + ( ( C100 *' ( C101 ` ) ) *' C102 ) ) by LATTICES:def 5
.= ( ( ( D23 + D23 ) + ( ( C100 *' C101 ) *' ( C102 ` ) ) ) + ( ( C100 *' ( C101 ` ) ) *' C102 ) ) by LATTICES:def 5
.= ( ( D23 + ( ( C100 *' C101 ) *' ( C102 ` ) ) ) + ( ( C100 *' ( C101 ` ) ) *' C102 ) ) by L25;
end;
theorem
L160: (for B114 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B115 , B116 , B117 being (Element of B114) holds ( ( B115 *' ( B116 + B117 ) ) ` ) = ( ( ( ( ( ( B115 *' ( B116 ` ) ) *' ( B117 ` ) ) + ( ( ( B115 ` ) *' B116 ) *' B117 ) ) + ( ( ( B115 ` ) *' B116 ) *' ( B117 ` ) ) ) + ( ( ( B115 ` ) *' ( B116 ` ) ) *' B117 ) ) + ( ( ( B115 ` ) *' ( B116 ` ) ) *' ( B117 ` ) ) )))
proof
let C103 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C104 , C105 , C106 being (Element of C103);
set D24 = ( ( C104 *' ( C105 ` ) ) *' ( C106 ` ) );
set D25 = ( ( ( C104 ` ) *' C105 ) *' C106 );
set D26 = ( ( ( C104 ` ) *' C105 ) *' ( C106 ` ) );
set D27 = ( ( ( C104 ` ) *' ( C105 ` ) ) *' C106 );
set D28 = ( ( ( C104 ` ) *' ( C105 ` ) ) *' ( C106 ` ) );
L161: ( C104 ` ) = ( ( ( C104 ` ) *' C105 ) + ( ( C104 ` ) *' ( C105 ` ) ) ) by L23
.= ( ( D25 + D26 ) + ( ( C104 ` ) *' ( C105 ` ) ) ) by L23
.= ( ( D25 + D26 ) + ( D27 + D28 ) ) by L23;
L162: ( ( C105 ` ) *' ( C106 ` ) ) = ( ( C104 *' ( ( C105 ` ) *' ( C106 ` ) ) ) + ( ( C104 ` ) *' ( ( C105 ` ) *' ( C106 ` ) ) ) ) by L47
.= ( D24 + ( ( C104 ` ) *' ( ( C105 ` ) *' ( C106 ` ) ) ) ) by L124
.= ( D24 + D28 ) by L124;
L163: ( ( C104 *' ( C105 + C106 ) ) ` ) = ( ( C104 ` ) + ( ( C105 + C106 ) ` ) ) by L52
.= ( ( C104 ` ) + ( ( ( ( C105 ` ) *' ( C106 ` ) ) ` ) ` ) ) by L126
.= ( ( C104 ` ) + ( ( C105 ` ) *' ( C106 ` ) ) ) by L52;
thus L164: ( ( C104 *' ( C105 + C106 ) ) ` ) = ( ( ( ( D25 + D26 ) + ( D27 + D28 ) ) + D28 ) + D24 ) by L163 , L161 , L162 , LATTICES:def 5
.= ( ( ( ( ( D25 + D26 ) + D27 ) + D28 ) + D28 ) + D24 ) by LATTICES:def 5
.= ( ( ( ( D25 + D26 ) + D27 ) + ( D28 + D28 ) ) + D24 ) by LATTICES:def 5
.= ( ( ( ( D25 + D26 ) + D27 ) + D28 ) + D24 ) by L25
.= ( D24 + ( ( D25 + D26 ) + ( D27 + D28 ) ) ) by LATTICES:def 5
.= ( ( D24 + ( D25 + D26 ) ) + ( D27 + D28 ) ) by LATTICES:def 5
.= ( ( ( D24 + ( D25 + D26 ) ) + D27 ) + D28 ) by LATTICES:def 5
.= ( ( ( ( D24 + D25 ) + D26 ) + D27 ) + D28 ) by LATTICES:def 5;
end;
theorem
L165: (for B118 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B119 , B120 , B121 being (Element of B118) holds ( ( ( B119 *' B120 ) + ( B119 *' B121 ) ) + ( ( B119 *' ( B120 + B121 ) ) ` ) ) = ( Top B118 )))
proof
let C107 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C108 , C109 , C110 being (Element of C107);
set D29 = ( ( C108 *' C109 ) *' C110 );
set D30 = ( ( C108 *' C109 ) *' ( C110 ` ) );
set D31 = ( ( C108 *' ( C109 ` ) ) *' C110 );
set D32 = ( ( C108 *' ( C109 ` ) ) *' ( C110 ` ) );
set D33 = ( ( ( C108 ` ) *' C109 ) *' C110 );
set D34 = ( ( ( C108 ` ) *' C109 ) *' ( C110 ` ) );
set D35 = ( ( ( C108 ` ) *' ( C109 ` ) ) *' C110 );
set D36 = ( ( ( C108 ` ) *' ( C109 ` ) ) *' ( C110 ` ) );
set D37 = ( ( D29 + D30 ) + D31 );
set D38 = ( D35 + D36 );
L166: (( ( C108 *' ( C109 + C110 ) ) ` ) = ( ( ( ( D32 + D33 ) + D34 ) + D35 ) + D36 ) & ( ( C108 *' C109 ) + ( C108 *' C110 ) ) = D37) by L157 , L160;
L167: ( ( ( C108 *' C109 ) + ( C108 *' C110 ) ) + ( ( C108 *' ( C109 + C110 ) ) ` ) ) = ( D37 + ( ( ( D32 + D33 ) + D34 ) + D38 ) ) by L166 , LATTICES:def 5
.= ( D37 + ( ( D32 + D33 ) + ( D34 + D38 ) ) ) by LATTICES:def 5
.= ( ( D37 + ( D32 + D33 ) ) + ( D34 + D38 ) ) by LATTICES:def 5
.= ( ( ( D37 + D32 ) + D33 ) + ( D34 + D38 ) ) by LATTICES:def 5
.= ( ( D37 + D32 ) + ( D33 + ( D34 + D38 ) ) ) by LATTICES:def 5
.= ( ( D37 + D32 ) + ( D33 + ( ( D34 + D35 ) + D36 ) ) ) by LATTICES:def 5
.= ( ( ( D37 + D32 ) + D33 ) + ( ( D34 + D35 ) + D36 ) ) by LATTICES:def 5
.= ( ( ( D37 + D32 ) + D33 ) + ( D34 + D38 ) ) by LATTICES:def 5
.= ( ( ( ( D37 + D32 ) + D33 ) + D34 ) + D38 ) by LATTICES:def 5
.= ( ( ( ( ( D37 + D32 ) + D33 ) + D34 ) + D35 ) + D36 ) by LATTICES:def 5
.= ( Top C107 ) by L146;
thus L168: thesis by L167;
end;
theorem
L169: (for B122 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B123 , B124 , B125 being (Element of B122) holds ( ( ( B123 *' B124 ) + ( B123 *' B125 ) ) *' ( ( B123 *' ( B124 + B125 ) ) ` ) ) = ( Bot B122 )))
proof
let C111 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C112 , C113 , C114 being (Element of C111);
set D39 = ( ( C112 *' C113 ) *' C114 );
set D40 = ( ( C112 *' C113 ) *' ( C114 ` ) );
set D41 = ( ( C112 *' ( C113 ` ) ) *' C114 );
set D42 = ( ( C112 *' ( C113 ` ) ) *' ( C114 ` ) );
set D43 = ( ( ( C112 ` ) *' C113 ) *' C114 );
set D44 = ( ( ( C112 ` ) *' C113 ) *' ( C114 ` ) );
set D45 = ( ( ( C112 ` ) *' ( C113 ` ) ) *' C114 );
set D46 = ( ( ( C112 ` ) *' ( C113 ` ) ) *' ( C114 ` ) );
set D47 = ( ( ( D42 + D43 ) + D44 ) + D45 );
L170: ( ( D39 *' D42 ) + ( D39 *' D43 ) ) = ( ( Bot C111 ) + ( D39 *' D43 ) ) by L149
.= ( ( Bot C111 ) + ( Bot C111 ) ) by L149
.= ( Bot C111 ) by L25;
L171: ( Top C111 ) = ( ( Bot C111 ) + ( ( D39 *' ( D42 + D43 ) ) ` ) ) by L170 , L165
.= ( ( D39 *' ( D42 + D43 ) ) ` ) by L116;
L172: ( Bot C111 ) = ( ( ( D39 *' ( D42 + D43 ) ) ` ) ` ) by L171 , L96
.= ( D39 *' ( D42 + D43 ) ) by L52;
L173: ( ( D39 *' ( D42 + D43 ) ) + ( D39 *' D44 ) ) = ( ( Bot C111 ) + ( Bot C111 ) ) by L172 , L149
.= ( Bot C111 ) by L25;
L174: ( Top C111 ) = ( ( Bot C111 ) + ( ( D39 *' ( ( D42 + D43 ) + D44 ) ) ` ) ) by L173 , L165
.= ( ( D39 *' ( ( D42 + D43 ) + D44 ) ) ` ) by L116;
L175: ( Bot C111 ) = ( ( ( D39 *' ( ( D42 + D43 ) + D44 ) ) ` ) ` ) by L174 , L96
.= ( D39 *' ( ( D42 + D43 ) + D44 ) ) by L52;
L176: ( D39 *' D45 ) = ( Bot C111 ) by L149;
L177: ( ( D39 *' ( ( D42 + D43 ) + D44 ) ) + ( D39 *' D45 ) ) = ( Bot C111 ) by L176 , L175 , L25;
L178: ( Top C111 ) = ( ( Bot C111 ) + ( ( D39 *' D47 ) ` ) ) by L177 , L165
.= ( ( D39 *' D47 ) ` ) by L116;
L179: ( Bot C111 ) = ( ( ( D39 *' D47 ) ` ) ` ) by L178 , L96
.= ( D39 *' D47 ) by L52;
L180: ( ( D39 *' D47 ) + ( D39 *' D46 ) ) = ( ( Bot C111 ) + ( Bot C111 ) ) by L179 , L149
.= ( Bot C111 ) by L25;
L181: ( Top C111 ) = ( ( Bot C111 ) + ( ( D39 *' ( D47 + D46 ) ) ` ) ) by L180 , L165
.= ( ( D39 *' ( D47 + D46 ) ) ` ) by L116;
L182: ( ( D40 *' D42 ) + ( D40 *' D43 ) ) = ( ( Bot C111 ) + ( D40 *' D43 ) ) by L149
.= ( ( Bot C111 ) + ( Bot C111 ) ) by L149
.= ( Bot C111 ) by L25;
L183: ( Top C111 ) = ( ( Bot C111 ) + ( ( D40 *' ( D42 + D43 ) ) ` ) ) by L182 , L165
.= ( ( D40 *' ( D42 + D43 ) ) ` ) by L116;
L184: ( Bot C111 ) = ( ( ( D40 *' ( D42 + D43 ) ) ` ) ` ) by L183 , L96
.= ( D40 *' ( D42 + D43 ) ) by L52;
L185: ( ( D40 *' ( D42 + D43 ) ) + ( D40 *' D44 ) ) = ( ( Bot C111 ) + ( Bot C111 ) ) by L184 , L149
.= ( Bot C111 ) by L25;
L186: ( Top C111 ) = ( ( Bot C111 ) + ( ( D40 *' ( ( D42 + D43 ) + D44 ) ) ` ) ) by L185 , L165
.= ( ( D40 *' ( ( D42 + D43 ) + D44 ) ) ` ) by L116;
L187: ( Bot C111 ) = ( ( ( D40 *' ( ( D42 + D43 ) + D44 ) ) ` ) ` ) by L186 , L96
.= ( D40 *' ( ( D42 + D43 ) + D44 ) ) by L52;
L188: ( ( D40 *' ( ( D42 + D43 ) + D44 ) ) + ( D40 *' D45 ) ) = ( ( Bot C111 ) + ( Bot C111 ) ) by L187 , L149
.= ( Bot C111 ) by L25;
L189: ( Top C111 ) = ( ( Bot C111 ) + ( ( D40 *' D47 ) ` ) ) by L188 , L165
.= ( ( D40 *' D47 ) ` ) by L116;
L190: ( Bot C111 ) = ( ( ( D40 *' D47 ) ` ) ` ) by L189 , L96
.= ( D40 *' D47 ) by L52;
L191: ( D41 *' D42 ) = ( Bot C111 ) by L149;
L192: ( ( D41 *' D42 ) + ( D41 *' D43 ) ) = ( ( Bot C111 ) + ( Bot C111 ) ) by L191 , L149
.= ( Bot C111 ) by L25;
L193: ( Top C111 ) = ( ( Bot C111 ) + ( ( D41 *' ( D42 + D43 ) ) ` ) ) by L192 , L165
.= ( ( D41 *' ( D42 + D43 ) ) ` ) by L116;
L194: ( Bot C111 ) = ( ( ( D41 *' ( D42 + D43 ) ) ` ) ` ) by L193 , L96
.= ( D41 *' ( D42 + D43 ) ) by L52;
L195: ( ( D41 *' ( D42 + D43 ) ) + ( D41 *' D44 ) ) = ( ( Bot C111 ) + ( Bot C111 ) ) by L194 , L149
.= ( Bot C111 ) by L25;
L196: ( Top C111 ) = ( ( Bot C111 ) + ( ( D41 *' ( ( D42 + D43 ) + D44 ) ) ` ) ) by L195 , L165
.= ( ( D41 *' ( ( D42 + D43 ) + D44 ) ) ` ) by L116;
L197: ( Bot C111 ) = ( ( ( D41 *' ( ( D42 + D43 ) + D44 ) ) ` ) ` ) by L196 , L96
.= ( D41 *' ( ( D42 + D43 ) + D44 ) ) by L52;
L198: ( ( D41 *' ( ( D42 + D43 ) + D44 ) ) + ( D41 *' D45 ) ) = ( ( Bot C111 ) + ( Bot C111 ) ) by L197 , L149
.= ( Bot C111 ) by L25;
L199: ( Top C111 ) = ( ( Bot C111 ) + ( ( D41 *' D47 ) ` ) ) by L198 , L165
.= ( ( D41 *' D47 ) ` ) by L116;
L200: ( Bot C111 ) = ( ( ( D41 *' D47 ) ` ) ` ) by L199 , L96
.= ( D41 *' D47 ) by L52;
L201: ( ( D41 *' D47 ) + ( D41 *' D46 ) ) = ( ( Bot C111 ) + ( Bot C111 ) ) by L200 , L149
.= ( Bot C111 ) by L25;
L202: ( Top C111 ) = ( ( Bot C111 ) + ( ( D41 *' ( D47 + D46 ) ) ` ) ) by L201 , L165
.= ( ( D41 *' ( D47 + D46 ) ) ` ) by L116;
L203: ( D40 *' D46 ) = ( Bot C111 ) by L149;
L204: ( ( D40 *' D47 ) + ( D40 *' D46 ) ) = ( Bot C111 ) by L203 , L190 , L25;
L205: ( Top C111 ) = ( ( Bot C111 ) + ( ( D40 *' ( D47 + D46 ) ) ` ) ) by L204 , L165
.= ( ( D40 *' ( D47 + D46 ) ) ` ) by L116;
L206: ( D40 *' ( D47 + D46 ) ) = ( ( ( D40 *' ( D47 + D46 ) ) ` ) ` ) by L52
.= ( Bot C111 ) by L205 , L96;
L207: ( D39 *' ( D47 + D46 ) ) = ( ( ( D39 *' ( D47 + D46 ) ) ` ) ` ) by L52
.= ( Bot C111 ) by L181 , L96;
L208: ( ( D39 *' ( D47 + D46 ) ) + ( D40 *' ( D47 + D46 ) ) ) = ( Bot C111 ) by L207 , L206 , L25;
L209: ( Top C111 ) = ( ( Bot C111 ) + ( ( ( D39 + D40 ) *' ( D47 + D46 ) ) ` ) ) by L208 , L165
.= ( ( ( D39 + D40 ) *' ( D47 + D46 ) ) ` ) by L116;
L210: ( Bot C111 ) = ( ( ( ( D39 + D40 ) *' ( D47 + D46 ) ) ` ) ` ) by L209 , L96
.= ( ( D39 + D40 ) *' ( D47 + D46 ) ) by L52;
L211: ( D41 *' ( D47 + D46 ) ) = ( ( ( D41 *' ( D47 + D46 ) ) ` ) ` ) by L52
.= ( Bot C111 ) by L202 , L96;
L212: ( ( ( D39 + D40 ) *' ( D47 + D46 ) ) + ( D41 *' ( D47 + D46 ) ) ) = ( Bot C111 ) by L211 , L210 , L25;
L213: ( Top C111 ) = ( ( Bot C111 ) + ( ( ( ( D39 + D40 ) + D41 ) *' ( D47 + D46 ) ) ` ) ) by L212 , L165
.= ( ( ( ( D39 + D40 ) + D41 ) *' ( D47 + D46 ) ) ` ) by L116;
L214: ( Bot C111 ) = ( ( ( ( ( D39 + D40 ) + D41 ) *' ( D47 + D46 ) ) ` ) ` ) by L213 , L96
.= ( ( ( D39 + D40 ) + D41 ) *' ( D47 + D46 ) ) by L52;
L215: ( ( C112 *' ( C113 + C114 ) ) ` ) = ( D47 + D46 ) by L160;
thus L216: thesis by L215 , L214 , L157;
end;
theorem
L217: (for B126 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B127 , B128 , B129 being (Element of B126) holds ( B127 *' ( B128 + B129 ) ) = ( ( B127 *' B128 ) + ( B127 *' B129 ) )))
proof
let C115 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C116 , C117 , C118 being (Element of C115);
L218: (( ( ( C116 *' C117 ) + ( C116 *' C118 ) ) + ( ( C116 *' ( C117 + C118 ) ) ` ) ) = ( Top C115 ) & ( ( ( C116 *' C117 ) + ( C116 *' C118 ) ) *' ( ( C116 *' ( C117 + C118 ) ) ` ) ) = ( Bot C115 )) by L165 , L169;
L219: ( ( ( C116 *' C117 ) + ( C116 *' C118 ) ) ` ) = ( ( C116 *' ( C117 + C118 ) ) ` ) by L218 , L140;
thus L220: thesis by L219 , L99;
end;
theorem
L221: (for B130 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B131 , B132 , B133 being (Element of B130) holds ( B131 + ( B132 *' B133 ) ) = ( ( B131 + B132 ) *' ( B131 + B133 ) )))
proof
let C119 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C120 , C121 , C122 being (Element of C119);
thus L222: ( C120 + ( C121 *' C122 ) ) = ( ( ( C120 ` ) *' ( ( ( ( C121 ` ) + ( C122 ` ) ) ` ) ` ) ) ` ) by L126
.= ( ( ( C120 ` ) *' ( ( C121 ` ) + ( C122 ` ) ) ) ` ) by L52
.= ( ( ( ( C120 ` ) *' ( C121 ` ) ) + ( ( C120 ` ) *' ( C122 ` ) ) ) ` ) by L217
.= ( ( ( ( ( ( C120 ` ) *' ( C121 ` ) ) ` ) *' ( ( ( C120 ` ) *' ( C122 ` ) ) ` ) ) ` ) ` ) by L126
.= ( ( ( ( C120 ` ) *' ( C121 ` ) ) ` ) *' ( ( ( C120 ` ) *' ( C122 ` ) ) ` ) ) by L52
.= ( ( C120 + C121 ) *' ( ( ( C120 ` ) *' ( C122 ` ) ) ` ) ) by L126
.= ( ( C120 + C121 ) *' ( C120 + C122 ) ) by L126;
end;
begin
definition
let C123 being non  empty OrthoLattStr;
attr C123 is  well-complemented
means
:L223: (for B134 being (Element of C123) holds ( B134 ` ) is_a_complement_of B134);
end;
registration
cluster ( TrivOrtLat ) ->  Boolean  well-complemented;
coherence
proof
set D48 = ( TrivOrtLat );
thus L225: D48 is  lower-bounded;
thus L226: D48 is  upper-bounded;
thus L227: D48 is  complemented
proof
let C124 being (Element of D48);
take D49 = C124;
L228: (( D49 "\/" C124 ) = ( Top D48 ) & ( D49 "/\" C124 ) = ( Bottom D48 )) by STRUCT_0:def 10;
thus L229: thesis by L228 , LATTICES:def 18;
end;

thus L230: D48 is  distributive
proof
let C125 , C126 , C127 being (Element of D48);
thus L231: thesis by STRUCT_0:def 10;
end;

thus L232: D48 is  well-complemented
proof
let C128 being (Element of D48);
L233: (( ( C128 ` ) "\/" C128 ) = ( Top D48 ) & ( ( C128 ` ) "/\" C128 ) = ( Bottom D48 )) by STRUCT_0:def 10;
thus L234: ( C128 ` ) is_a_complement_of C128 by L233 , LATTICES:def 18;
end;

end;
end;
definition
mode preOrthoLattice
 is  Lattice-like non  empty OrthoLattStr;
end;
registration
cluster  strict  Boolean  well-complemented for preOrthoLattice;
existence
proof
take ( TrivOrtLat );
thus L235: thesis;
end;
end;
theorem
L237: (for B135 being  distributive  well-complemented preOrthoLattice holds (for B136 being (Element of B135) holds ( ( B136 ` ) ` ) = B136))
proof
let C129 being  distributive  well-complemented preOrthoLattice;
let C130 being (Element of C129);
L238: ( ( C130 ` ) ` ) is_a_complement_of ( C130 ` ) by L223;
L239: (( ( ( C130 ` ) ` ) + ( C130 ` ) ) = ( Top C129 ) & ( ( ( C130 ` ) ` ) "/\" ( C130 ` ) ) = ( Bottom C129 )) by L238 , LATTICES:def 18;
L240: ( C130 ` ) is_a_complement_of C130 by L223;
L241: (( ( C130 ` ) "\/" C130 ) = ( Top C129 ) & ( ( C130 ` ) "/\" C130 ) = ( Bottom C129 )) by L240 , LATTICES:def 18;
thus L242: thesis by L241 , L239 , LATTICES:12;
end;
theorem
L243: (for B137 being  bounded  distributive  well-complemented preOrthoLattice holds (for B138 , B139 being (Element of B137) holds ( B138 "/\" B139 ) = ( ( ( B138 ` ) "\/" ( B139 ` ) ) ` )))
proof
let C131 being  bounded  distributive  well-complemented preOrthoLattice;
let C132 , C133 being (Element of C131);
L244: ( ( C132 ` ) "\/" ( Top C131 ) ) = ( Top C131 );
L245: ( ( C133 ` ) "\/" ( Top C131 ) ) = ( Top C131 );
L246: ( C133 ` ) is_a_complement_of C133 by L223;
L247: ( ( C133 ` ) "\/" C133 ) = ( Top C131 ) by L246 , LATTICES:def 18;
L248: ( ( C132 "/\" C133 ) ` ) is_a_complement_of ( C132 "/\" C133 ) by L223;
L249: (( ( ( C132 "/\" C133 ) ` ) "\/" ( C132 "/\" C133 ) ) = ( Top C131 ) & ( ( ( C132 "/\" C133 ) ` ) "/\" ( C132 "/\" C133 ) ) = ( Bottom C131 )) by L248 , LATTICES:def 18;
L250: ( C132 ` ) is_a_complement_of C132 by L223;
L251: ( ( C132 ` ) "\/" C132 ) = ( Top C131 ) by L250 , LATTICES:def 18;
L252: ( ( C133 ` ) "/\" C133 ) = ( Bottom C131 ) by L246 , LATTICES:def 18;
L253: ( ( C132 ` ) "/\" C132 ) = ( Bottom C131 ) by L250 , LATTICES:def 18;
L254: ( ( ( C132 ` ) "\/" ( C133 ` ) ) "/\" ( C132 "/\" C133 ) ) = ( ( ( C132 "/\" C133 ) "/\" ( C132 ` ) ) "\/" ( ( C132 "/\" C133 ) "/\" ( C133 ` ) ) ) by LATTICES:def 11
.= ( ( C133 "/\" ( C132 "/\" ( C132 ` ) ) ) "\/" ( ( C132 "/\" C133 ) "/\" ( C133 ` ) ) ) by LATTICES:def 7
.= ( ( C133 "/\" ( Bottom C131 ) ) "\/" ( C132 "/\" ( C133 "/\" ( C133 ` ) ) ) ) by L253 , LATTICES:def 7
.= ( ( Bottom C131 ) "\/" ( C132 "/\" ( Bottom C131 ) ) ) by L252
.= ( ( Bottom C131 ) "\/" ( Bottom C131 ) )
.= ( Bottom C131 );
L255: ( ( ( C132 ` ) "\/" ( C133 ` ) ) "\/" ( C132 "/\" C133 ) ) = ( ( ( ( C132 ` ) "\/" ( C133 ` ) ) "\/" C132 ) "/\" ( ( ( C132 ` ) "\/" ( C133 ` ) ) "\/" C133 ) ) by LATTICES:11
.= ( ( ( ( C133 ` ) "\/" ( C132 ` ) ) "\/" C132 ) "/\" ( Top C131 ) ) by L247 , L244 , LATTICES:def 5
.= ( ( Top C131 ) "/\" ( Top C131 ) ) by L251 , L245 , LATTICES:def 5
.= ( Top C131 );
L256: ( ( C132 "/\" C133 ) ` ) = ( ( C132 ` ) "\/" ( C133 ` ) ) by L255 , L254 , L249 , LATTICES:12;
thus L257: thesis by L256 , L237;
end;
begin
definition
let C134 being non  empty ComplLLattStr;
func CLatt C134 ->  strict OrthoLattStr means 
:L258: ((the carrier of it) = (the carrier of C134) & (the L_join of it) = (the L_join of C134) & (the Compl of it) = (the Compl of C134) & (for B140 , B141 being (Element of C134) holds ( (the L_meet of it) . (B140 , B141) ) = ( B140 *' B141 )));
existence
proof
deffunc H1((Element of C134) , (Element of C134)) = ( $1 *' $2 );
consider C135 being (BinOp of (the carrier of C134)) such that L259: (for B142 , B143 being (Element of C134) holds ( C135 . (B142 , B143) ) = H1(B142 , B143)) from BINOP_1:sch 4;
take OrthoLattStr (# (the carrier of C134) , (the L_join of C134) , C135 , (the Compl of C134) #);
thus L260: thesis by L259;
end;
uniqueness
proof
let C136 , C137 being  strict OrthoLattStr;
assume that
L261: (the carrier of C136) = (the carrier of C134)
and
L262: ((the L_join of C136) = (the L_join of C134) & (the Compl of C136) = (the Compl of C134))
and
L263: (for B144 , B145 being (Element of C134) holds ( (the L_meet of C136) . (B144 , B145) ) = ( B144 *' B145 ))
and
L264: (the carrier of C137) = (the carrier of C134)
and
L265: ((the L_join of C137) = (the L_join of C134) & (the Compl of C137) = (the Compl of C134))
and
L266: (for B146 , B147 being (Element of C134) holds ( (the L_meet of C137) . (B146 , B147) ) = ( B146 *' B147 ));
reconsider D50 = (the L_meet of C136) , D51 = (the L_meet of C137) as (BinOp of (the carrier of C134)) by L261 , L264;
L267:
now
let C138 , C139 being (Element of C134);
thus L268: ( D50 . (C138 , C139) ) = ( C138 *' C139 ) by L263
.= ( D51 . (C138 , C139) ) by L266;
end;
thus L269: thesis by L267 , L261 , L262 , L264 , L265 , BINOP_1:2;
end;
end;
registration
let C140 being non  empty ComplLLattStr;
cluster ( CLatt C140 ) -> non  empty;
coherence
proof
L271: (the carrier of ( CLatt C140 )) = (the carrier of C140) by L258;
thus L272: thesis by L271;
end;
end;
registration
let C141 being  join-commutative non  empty ComplLLattStr;
cluster ( CLatt C141 ) ->  join-commutative;
coherence
proof
let C142 , C143 being (Element of ( CLatt C141 ));
L274: ((the carrier of C141) = (the carrier of ( CLatt C141 )) & (the L_join of C141) = (the L_join of ( CLatt C141 ))) by L258;
thus L275: thesis by L274 , BINOP_1:def 2;
end;
end;
registration
let C144 being  join-associative non  empty ComplLLattStr;
cluster ( CLatt C144 ) ->  join-associative;
coherence
proof
set D52 = (the L_join of C144);
set D53 = (the L_join of ( CLatt C144 ));
let C145 , C146 , C147 being (Element of ( CLatt C144 ));
L277: ((the carrier of C144) = (the carrier of ( CLatt C144 )) & D52 = D53) by L258;
thus L278: thesis by L277 , BINOP_1:def 3;
end;
end;
registration
let C148 being  join-commutative  join-associative non  empty ComplLLattStr;
cluster ( CLatt C148 ) ->  meet-commutative;
coherence
proof
let C149 , C150 being (Element of ( CLatt C148 ));
reconsider D54 = C149 , D55 = C150 as (Element of C148) by L258;
thus L280: ( C149 "/\" C150 ) = ( D55 *' D54 ) by L258
.= ( C150 "/\" C149 ) by L258;
end;
end;
theorem
L282: (for B148 being non  empty ComplLLattStr holds (for B149 , B150 being (Element of B148) holds (for B151 , B152 being (Element of ( CLatt B148 )) holds ((B149 = B151 & B150 = B152) implies (( B149 *' B150 ) = ( B151 "/\" B152 ) & ( B149 + B150 ) = ( B151 "\/" B152 ) & ( B149 ` ) = ( B151 ` )))))) by L258;
registration
let C151 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
cluster ( CLatt C151 ) ->  meet-associative  join-absorbing  meet-absorbing;
coherence
proof
thus L283:now
let C152 , C153 , C154 being (Element of ( CLatt C151 ));
reconsider D56 = C152 , D57 = C153 , D58 = C154 as (Element of C151) by L258;
L284: ( D57 *' D58 ) = ( C153 "/\" C154 ) by L258;
L285: ( D56 *' D57 ) = ( C152 "/\" C153 ) by L258;
thus L286: ( ( C152 "/\" C153 ) "/\" C154 ) = ( ( D56 *' D57 ) *' D58 ) by L285 , L258
.= ( D56 *' ( D57 *' D58 ) ) by L124
.= ( C152 "/\" ( C153 "/\" C154 ) ) by L284 , L258;
end;
thus L287:now
let C155 , C156 being (Element of ( CLatt C151 ));
reconsider D59 = C155 , D60 = C156 as (Element of C151) by L258;
L288: ( D59 + D60 ) = ( C155 "\/" C156 ) by L258;
thus L289: ( C155 "/\" ( C155 "\/" C156 ) ) = ( D59 *' ( D59 + D60 ) ) by L288 , L258
.= C155 by L135;
end;
let C157 , C158 being (Element of ( CLatt C151 ));
reconsider D61 = C157 , D62 = C158 as (Element of C151) by L258;
L290: ( D61 *' D62 ) = ( C157 "/\" C158 ) by L258;
thus L291: ( ( C157 "/\" C158 ) "\/" C158 ) = ( ( D61 *' D62 ) + D62 ) by L290 , L258
.= C158 by L133;
end;
end;
registration
let C159 being  Huntington non  empty ComplLLattStr;
cluster ( CLatt C159 ) ->  Huntington;
coherence
proof
let C160 , C161 being (Element of ( CLatt C159 ));
reconsider D63 = C160 , D64 = C161 as (Element of C159) by L258;
L293: ( C160 ` ) = ( D63 ` ) by L258;
L294: ( C161 ` ) = ( D64 ` ) by L258;
L295: ( ( C160 ` ) + ( C161 ` ) ) = ( ( D63 ` ) + ( D64 ` ) ) by L294 , L293 , L258;
L296: ( ( ( C160 ` ) + ( C161 ` ) ) ` ) = ( ( ( D63 ` ) + ( D64 ` ) ) ` ) by L295 , L258;
L297: ( ( C160 ` ) + C161 ) = ( ( D63 ` ) + D64 ) by L293 , L258;
L298: ( ( ( C160 ` ) + C161 ) ` ) = ( ( ( D63 ` ) + D64 ) ` ) by L297 , L258;
thus L299: ( ( ( ( C160 ` ) + ( C161 ` ) ) ` ) + ( ( ( C160 ` ) + C161 ) ` ) ) = ( ( ( ( D63 ` ) + ( D64 ` ) ) ` ) + ( ( ( D63 ` ) + D64 ) ` ) ) by L298 , L296 , L258
.= C160 by L23;
end;
end;
registration
let C162 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
cluster ( CLatt C162 ) ->  lower-bounded;
coherence
proof
thus L301: ( CLatt C162 ) is  lower-bounded
proof
set D65 = ( Bot C162 );
reconsider D66 = D65 as (Element of ( CLatt C162 )) by L258;
take D66;
let C163 being (Element of ( CLatt C162 ));
reconsider D67 = C163 as (Element of C162) by L258;
thus L302: ( D66 "/\" C163 ) = ( D65 *' D67 ) by L258
.= D66 by L84;
thus L303: ( C163 "/\" D66 ) = D66 by L302;
end;

end;
end;
theorem
L303: (for B153 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds ( Bot B153 ) = ( Bottom ( CLatt B153 ) ))
proof
let C164 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
reconsider D68 = ( Bot C164 ) as (Element of ( CLatt C164 )) by L258;
L304: (for B154 being (Element of ( CLatt C164 )) holds (( D68 "/\" B154 ) = D68 & ( B154 "/\" D68 ) = D68))
proof
let C165 being (Element of ( CLatt C164 ));
reconsider D69 = C165 as (Element of C164) by L258;
thus L305: ( D68 "/\" C165 ) = ( ( Bot C164 ) *' D69 ) by L258
.= D68 by L84;
thus L306: thesis by L305;
end;
thus L307: thesis by L304 , LATTICES:def 16;
end;
registration
let C166 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
cluster ( CLatt C166 ) ->  complemented  distributive  bounded;
coherence
proof
thus L308: ( CLatt C166 ) is  complemented
proof
let C167 being (Element of ( CLatt C166 ));
take D70 = ( C167 ` );
reconsider D71 = D70 , D72 = C167 as (Element of C166) by L258;
thus L309: ( D70 + C167 ) = ( Top ( CLatt C166 ) ) by L65;
thus L310: ( C167 + D70 ) = ( Top ( CLatt C166 ) ) by L65;
L311: ( D71 ` ) = ( D70 ` ) by L258
.= D72 by L52;
thus L312: ( D70 "/\" C167 ) = ( D71 *' D72 ) by L258
.= ( Bot C166 ) by L311 , L91
.= ( Bottom ( CLatt C166 ) ) by L303;
thus L313: ( C167 "/\" D70 ) = ( Bottom ( CLatt C166 ) ) by L312;
end;

thus L314:now
let C168 , C169 , C170 being (Element of ( CLatt C166 ));
reconsider D73 = C168 , D74 = C169 , D75 = C170 as (Element of C166) by L258;
L315: (( C168 "/\" C169 ) = ( D73 *' D74 ) & ( C168 "/\" C170 ) = ( D73 *' D75 )) by L258;
L316: ( D74 + D75 ) = ( C169 "\/" C170 ) by L258;
thus L317: ( C168 "/\" ( C169 "\/" C170 ) ) = ( D73 *' ( D74 + D75 ) ) by L316 , L258
.= ( ( D73 *' D74 ) + ( D73 *' D75 ) ) by L217
.= ( ( C168 "/\" C169 ) "\/" ( C168 "/\" C170 ) ) by L315 , L258;
end;
thus L318: ( CLatt C166 ) is  lower-bounded;
thus L319: thesis;
end;
end;
begin
notation
let C171 being non  empty ComplLLattStr;
let C172 being (Element of C171);
synonym - C172 for C172 `;
end;
definition
let C173 being  join-commutative non  empty ComplLLattStr;
redefine attr C173 is  Huntington
means
:L322: (for B155 , B156 being (Element of C173) holds ( ( - ( ( - B155 ) + ( - B156 ) ) ) + ( - ( B155 + ( - B156 ) ) ) ) = B156);
compatibility
proof
thus L323: (C173 is  Huntington implies (for B157 , B158 being (Element of C173) holds ( ( - ( ( - B157 ) + ( - B158 ) ) ) + ( - ( B157 + ( - B158 ) ) ) ) = B158)) by L23;
assume L324: (for B159 , B160 being (Element of C173) holds ( ( - ( ( - B159 ) + ( - B160 ) ) ) + ( - ( B159 + ( - B160 ) ) ) ) = B160);
let C174 , C175 being (Element of C173);
L325: ( ( ( ( C174 ` ) + ( C175 ` ) ) ` ) + ( ( ( C174 ` ) + C175 ) ` ) ) = C174 by L324;
thus L326: thesis by L325;
end;
end;
definition
let C176 being non  empty ComplLLattStr;
attr C176 is  with_idempotent_element
means
:L328: (ex B161 being (Element of C176) st ( B161 + B161 ) = B161);
correctness;
end;
definition
let C177 being non  empty ComplLLattStr;
let C178 , C179 being (Element of C177);
func \delta (C178 , C179) -> (Element of C177) equals 
( - ( ( - C178 ) + C179 ) );
coherence;
end;
definition
let C180 being non  empty ComplLLattStr;
let C181 , C182 being (Element of C180);
func Expand (C181 , C182) -> (Element of C180) equals 
( \delta (( C181 + C182 ) , ( \delta (C181 , C182) )) );
coherence;
end;
definition
let C183 being non  empty ComplLLattStr;
let C184 being (Element of C183);
func C184 _0 -> (Element of C183) equals 
( - ( ( - C184 ) + C184 ) );
coherence;
func Double C184 -> (Element of C183) equals 
( C184 + C184 );
coherence;
end;
definition
let C185 being non  empty ComplLLattStr;
let C186 being (Element of C185);
func C186 _1 -> (Element of C185) equals 
( ( C186 _0 ) + C186 );
coherence;
func C186 _2 -> (Element of C185) equals 
( ( C186 _0 ) + ( Double C186 ) );
coherence;
func C186 _3 -> (Element of C185) equals 
( ( C186 _0 ) + ( ( Double C186 ) + C186 ) );
coherence;
func C186 _4 -> (Element of C185) equals 
( ( C186 _0 ) + ( ( Double C186 ) + ( Double C186 ) ) );
coherence;
end;
theorem
L334: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( \delta (( R2 + R3 ) , ( \delta (R2 , R3) )) ) = R3)))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L335: ( \delta (( R2 + R3 ) , ( \delta (R2 , R3) )) ) = ( - ( ( - ( R2 + R3 ) ) + ( - ( ( - R2 ) + R3 ) ) ) )
.= R3 by L22;
end;
theorem
L336: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( Expand (R2 , R3) ) = R3))) by L334;
theorem
L337: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( \delta (( ( - R2 ) + R3 ) , R4) ) = ( - ( ( \delta (R2 , R3) ) + R4 ) )))));
theorem
L338: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds ( \delta (R2 , R2) ) = ( R2 _0 )));
theorem
L339: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds ( \delta (( Double R2 ) , ( R2 _0 )) ) = R2))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
let R2 being (Element of R1);
thus L340: ( \delta (( Double R2 ) , ( R2 _0 )) ) = ( Expand (R2 , R2) )
.= R2 by L334;
end;
theorem
L341: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds ( \delta (( R2 _2 ) , R2) ) = ( R2 _0 )))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
let R2 being (Element of R1);
thus L342: ( \delta (( R2 _2 ) , R2) ) = ( \delta (( ( Double R2 ) + ( R2 _0 ) ) , ( \delta (( Double R2 ) , ( R2 _0 )) )) ) by L339
.= ( R2 _0 ) by L334;
end;
theorem
L343: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds ( ( R2 _4 ) + ( R2 _0 ) ) = ( ( R2 _3 ) + ( R2 _1 ) )))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
let R2 being (Element of R1);
thus L344: ( ( R2 _4 ) + ( R2 _0 ) ) = ( ( ( ( R2 _0 ) + ( Double R2 ) ) + ( Double R2 ) ) + ( R2 _0 ) ) by LATTICES:def 5
.= ( ( ( ( ( R2 _0 ) + ( Double R2 ) ) + R2 ) + R2 ) + ( R2 _0 ) ) by LATTICES:def 5
.= ( ( ( R2 _3 ) + R2 ) + ( R2 _0 ) ) by LATTICES:def 5
.= ( ( R2 _3 ) + ( R2 _1 ) ) by LATTICES:def 5;
end;
theorem
L345: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds ( ( R2 _3 ) + ( R2 _0 ) ) = ( ( R2 _2 ) + ( R2 _1 ) )))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
let R2 being (Element of R1);
thus L346: ( ( R2 _3 ) + ( R2 _0 ) ) = ( ( ( ( R2 _0 ) + ( Double R2 ) ) + R2 ) + ( R2 _0 ) ) by LATTICES:def 5
.= ( ( R2 _2 ) + ( R2 _1 ) ) by LATTICES:def 5;
end;
theorem
L347: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds ( ( R2 _3 ) + R2 ) = ( R2 _4 )))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
let R2 being (Element of R1);
thus L348: ( ( R2 _3 ) + R2 ) = ( ( R2 _0 ) + ( ( ( Double R2 ) + R2 ) + R2 ) ) by LATTICES:def 5
.= ( R2 _4 ) by LATTICES:def 5;
end;
theorem
L349: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds ( \delta (( R2 _3 ) , ( R2 _0 )) ) = R2))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
let R2 being (Element of R1);
thus L350: R2 = ( Expand (( R2 _2 ) , R2) ) by L334
.= ( \delta (( R2 + ( R2 _2 ) ) , ( R2 _0 )) ) by L341
.= ( \delta (( R2 _3 ) , ( R2 _0 )) ) by LATTICES:def 5;
end;
theorem
L351: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds (( - R2 ) = ( - R3 ) implies ( \delta (R2 , R4) ) = ( \delta (R3 , R4) ))))));
theorem
L352: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( \delta (R2 , ( - R3 )) ) = ( \delta (R3 , ( - R2 )) ))))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L353: ( \delta (R2 , ( - R3 )) ) = ( - ( ( - R2 ) + ( - R3 ) ) )
.= ( \delta (R3 , ( - R2 )) );
end;
theorem
L354: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds ( \delta (( R2 _3 ) , R2) ) = ( R2 _0 )))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
let R2 being (Element of R1);
set D76 = ( ( ( - ( R2 _3 ) ) + ( R2 _1 ) ) + ( - ( Double R2 ) ) );
L355: R2 = ( Expand (( ( - ( R2 _3 ) ) + ( R2 _0 ) ) , R2) ) by L334
.= ( \delta (( ( - ( R2 _3 ) ) + ( R2 _1 ) ) , ( - ( ( \delta (( R2 _3 ) , ( R2 _0 )) ) + R2 ) )) ) by LATTICES:def 5
.= ( \delta (( ( - ( R2 _3 ) ) + ( R2 _1 ) ) , ( - ( Double R2 ) )) ) by L349;
L356: ( - ( Double R2 ) ) = ( \delta (( ( ( - ( R2 _3 ) ) + ( R2 _1 ) ) + ( - ( Double R2 ) ) ) , R2) ) by L355 , L334;
L357: R2 = ( \delta (( Double R2 ) , ( R2 _0 )) ) by L339
.= ( \delta (( ( - D76 ) + R2 ) , ( R2 _0 )) ) by L356;
L358: ( - ( R2 _3 ) ) = ( Expand (( ( R2 _1 ) + ( - ( Double R2 ) ) ) , ( - ( R2 _3 ) )) ) by L334
.= ( \delta (( ( ( - ( R2 _3 ) ) + ( R2 _1 ) ) + ( - ( Double R2 ) ) ) , ( \delta (( ( R2 _1 ) + ( - ( Double R2 ) ) ) , ( - ( R2 _3 ) )) )) ) by LATTICES:def 5
.= ( \delta (D76 , ( \delta (( ( R2 _0 ) + ( R2 + ( Double R2 ) ) ) , ( \delta (( Double R2 ) , ( R2 _1 )) )) )) ) by L352
.= ( \delta (D76 , ( \delta (( ( Double R2 ) + ( R2 _1 ) ) , ( \delta (( Double R2 ) , ( R2 _1 )) )) )) ) by LATTICES:def 5
.= ( - ( ( - D76 ) + ( R2 _1 ) ) ) by L334;
thus L359: ( \delta (( R2 _3 ) , R2) ) = ( \delta (( ( - D76 ) + ( ( R2 _0 ) + R2 ) ) , R2) ) by L358
.= ( Expand (( ( - D76 ) + R2 ) , ( R2 _0 )) ) by L357 , LATTICES:def 5
.= ( R2 _0 ) by L334;
end;
theorem
L360: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds ( \delta (( ( R2 _1 ) + ( R2 _3 ) ) , R2) ) = ( R2 _0 )))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
let R2 being (Element of R1);
L361: ( R2 _0 ) = ( Expand (( R2 _4 ) , ( R2 _0 )) ) by L334
.= ( \delta (( ( R2 _4 ) + ( R2 _0 ) ) , ( \delta (( R2 _4 ) , ( \delta (( R2 _3 ) , R2) )) )) ) by L354
.= ( \delta (( ( R2 _3 ) + ( R2 _1 ) ) , ( \delta (( R2 _4 ) , ( \delta (( R2 _3 ) , R2) )) )) ) by L343
.= ( \delta (( ( R2 _3 ) + ( R2 _1 ) ) , ( Expand (( R2 _3 ) , R2) )) ) by L347
.= ( \delta (( ( R2 _3 ) + ( R2 _1 ) ) , R2) ) by L334;
thus L362: thesis by L361;
end;
theorem
L363: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds ( \delta (( ( R2 _1 ) + ( R2 _2 ) ) , R2) ) = ( R2 _0 )))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
let R2 being (Element of R1);
thus L364: ( R2 _0 ) = ( Expand (( R2 _3 ) , ( R2 _0 )) ) by L334
.= ( \delta (( ( R2 _1 ) + ( R2 _2 ) ) , ( \delta (( R2 _3 ) , ( R2 _0 )) )) ) by L345
.= ( \delta (( ( R2 _1 ) + ( R2 _2 ) ) , R2) ) by L349;
end;
theorem
L365: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds ( \delta (( ( R2 _1 ) + ( R2 _3 ) ) , ( R2 _0 )) ) = R2))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
let R2 being (Element of R1);
thus L366: R2 = ( Expand (( ( R2 _1 ) + ( R2 _2 ) ) , R2) ) by L334
.= ( \delta (( ( R2 _1 ) + ( ( R2 _2 ) + R2 ) ) , ( \delta (( ( R2 _1 ) + ( R2 _2 ) ) , R2) )) ) by LATTICES:def 5
.= ( \delta (( ( R2 _1 ) + ( R2 _3 ) ) , ( \delta (( ( R2 _1 ) + ( R2 _2 ) ) , R2) )) ) by LATTICES:def 5
.= ( \delta (( ( R2 _1 ) + ( R2 _3 ) ) , ( R2 _0 )) ) by L363;
end;
definition
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
let R2 being (Element of R1);
func \beta R2 -> (Element of R1) equals 
( ( ( - ( ( R2 _1 ) + ( R2 _3 ) ) ) + R2 ) + ( - ( R2 _3 ) ) );
coherence;
end;
theorem
L368: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds ( \delta (( \beta R2 ) , R2) ) = ( - ( R2 _3 ) )))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
let R2 being (Element of R1);
thus L369: ( - ( R2 _3 ) ) = ( \delta (( \beta R2 ) , ( \delta (( ( - ( ( R2 _1 ) + ( R2 _3 ) ) ) + R2 ) , ( - ( R2 _3 ) )) )) ) by L334
.= ( \delta (( \beta R2 ) , ( \delta (( R2 _3 ) , ( \delta (( ( R2 _1 ) + ( R2 _3 ) ) , R2) )) )) ) by L352
.= ( \delta (( \beta R2 ) , ( \delta (( R2 _3 ) , ( R2 _0 )) )) ) by L360
.= ( \delta (( \beta R2 ) , R2) ) by L349;
end;
theorem
L370: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (for R2 being (Element of R1) holds ( \delta (( \beta R2 ) , R2) ) = ( - ( ( R2 _1 ) + ( R2 _3 ) ) )))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
let R2 being (Element of R1);
thus L371: ( - ( ( R2 _1 ) + ( R2 _3 ) ) ) = ( \delta (( ( - ( ( R2 _1 ) + ( R2 _3 ) ) ) + ( R2 + ( - ( R2 _3 ) ) ) ) , ( \delta (( R2 + ( - ( R2 _3 ) ) ) , ( - ( ( R2 _1 ) + ( R2 _3 ) ) )) )) ) by L334
.= ( \delta (( \beta R2 ) , ( \delta (( R2 + ( - ( R2 _3 ) ) ) , ( - ( ( R2 _1 ) + ( R2 _3 ) ) )) )) ) by LATTICES:def 5
.= ( \delta (( \beta R2 ) , ( \delta (( ( R2 _1 ) + ( R2 _3 ) ) , ( \delta (( R2 _3 ) , R2) )) )) ) by L352
.= ( \delta (( \beta R2 ) , ( \delta (( ( R2 _1 ) + ( R2 _3 ) ) , ( R2 _0 )) )) ) by L354
.= ( \delta (( \beta R2 ) , R2) ) by L365;
end;
theorem
L372: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (ex R3 being (Element of R1) st (ex R4 being (Element of R1) st ( - ( R3 + R4 ) ) = ( - R4 ))))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
set D77 = the (Element of R1);
take D78 = ( D77 _1 );
take D79 = ( D77 _3 );
L373: ( - ( D78 + D79 ) ) = ( \delta (( \beta D77 ) , D77) ) by L370
.= ( - D79 ) by L368;
thus L374: thesis by L373;
end;
begin
theorem
L375: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds ((for R4 being (Element of R1) holds ( - ( - R4 ) ) = R4) implies R1 is  Huntington))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
assume L376: (for R4 being (Element of R1) holds ( - ( - R4 ) ) = R4);
let R2 being (Element of R1);
let R3 being (Element of R1);
L377: ( - ( - ( ( - ( ( - R2 ) + ( - R3 ) ) ) + ( - ( R2 + ( - R3 ) ) ) ) ) ) = ( - ( - R3 ) ) by L22;
L378: ( ( - ( ( - R2 ) + ( - R3 ) ) ) + ( - ( R2 + ( - R3 ) ) ) ) = ( - ( - ( ( - ( ( - R2 ) + ( - R3 ) ) ) + ( - ( R2 + ( - R3 ) ) ) ) ) ) by L376
.= R3 by L376 , L377;
thus L379: thesis by L378;
end;
theorem
L380: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (R1 is  with_idempotent_element implies R1 is  Huntington))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
assume L381: R1 is  with_idempotent_element;
consider C187 being (Element of R1) such that L382: ( C187 + C187 ) = C187 by L381 , L328;
L383:
now
let R2 being (Element of R1);
thus L384: ( C187 + R2 ) = ( - ( ( - ( ( - C187 ) + ( C187 + R2 ) ) ) + ( - ( C187 + ( C187 + R2 ) ) ) ) ) by L22
.= ( - ( ( - ( ( ( - C187 ) + C187 ) + R2 ) ) + ( - ( C187 + ( C187 + R2 ) ) ) ) ) by LATTICES:def 5
.= ( - ( ( - ( ( C187 + ( - C187 ) ) + R2 ) ) + ( - ( C187 + R2 ) ) ) ) by L382 , LATTICES:def 5;
end;
assume L385: R1 is non  Huntington;
consider C188 , C189 being (Element of R1) such that L386: ( ( - ( ( - C188 ) + ( - C189 ) ) ) + ( - ( C188 + ( - C189 ) ) ) ) <> C189 by L385 , L322;
set D80 = ( ( C187 + ( - C187 ) ) + ( - C187 ) );
L387: C187 = ( - ( ( - C187 ) + ( - ( C187 + ( - C187 ) ) ) ) ) by L382 , L22;
L388: ( - ( C187 + ( - ( ( C187 + ( - C187 ) ) + ( - C187 ) ) ) ) ) = ( - C187 ) by L387 , L22;
L389: ( - ( ( - C187 ) + ( - ( ( C187 + ( - C187 ) ) + ( - C187 ) ) ) ) ) = ( - ( ( - ( ( - ( ( C187 + ( - C187 ) ) + ( - C187 ) ) ) + C187 ) ) + ( - ( ( C187 + C187 ) + ( ( - C187 ) + ( - C187 ) ) ) ) ) ) by L388 , L382 , LATTICES:def 5
.= ( - ( ( - ( ( - ( ( C187 + ( - C187 ) ) + ( - C187 ) ) ) + C187 ) ) + ( - ( C187 + ( C187 + ( ( - C187 ) + ( - C187 ) ) ) ) ) ) ) by LATTICES:def 5
.= ( - ( ( - ( ( - D80 ) + C187 ) ) + ( - ( D80 + C187 ) ) ) ) by LATTICES:def 5
.= C187 by L22;
L390: ( - ( C187 + ( - C187 ) ) ) = ( - ( ( C187 + ( - C187 ) ) + ( - C187 ) ) ) by L389 , L388 , L22;
L391: C187 = ( - ( ( - ( C187 + C187 ) ) + ( - ( ( ( - C187 ) + ( - ( C187 + ( - C187 ) ) ) ) + C187 ) ) ) ) by L387 , L22
.= ( - ( ( - C187 ) + ( - ( ( C187 + ( - C187 ) ) + ( - ( C187 + ( - C187 ) ) ) ) ) ) ) by L382 , LATTICES:def 5;
L392: C187 = ( C187 + ( - ( C187 + ( - C187 ) ) ) ) by L391 , L383 , L388 , L390;
L393:
now
let R2 being (Element of R1);
thus L394: R2 = ( - ( ( - ( ( C187 + ( - ( C187 + ( - C187 ) ) ) ) + R2 ) ) + ( - ( ( ( - C187 ) + ( - ( C187 + ( - C187 ) ) ) ) + R2 ) ) ) ) by L387 , L392 , L22
.= ( - ( ( - ( C187 + ( ( - ( C187 + ( - C187 ) ) ) + R2 ) ) ) + ( - ( ( ( - C187 ) + ( - ( C187 + ( - C187 ) ) ) ) + R2 ) ) ) ) by LATTICES:def 5
.= ( - ( ( - ( C187 + ( ( - ( C187 + ( - C187 ) ) ) + R2 ) ) ) + ( - ( ( - C187 ) + ( ( - ( C187 + ( - C187 ) ) ) + R2 ) ) ) ) ) by LATTICES:def 5
.= ( ( - ( C187 + ( - C187 ) ) ) + R2 ) by L22;
end;
L395:
now
let R2 being (Element of R1);
thus L396: ( - ( C187 + ( - C187 ) ) ) = ( - ( ( - ( ( - R2 ) + ( - ( C187 + ( - C187 ) ) ) ) ) + ( - ( R2 + ( - ( C187 + ( - C187 ) ) ) ) ) ) ) by L22
.= ( - ( ( - ( - R2 ) ) + ( - ( R2 + ( - ( C187 + ( - C187 ) ) ) ) ) ) ) by L393
.= ( - ( ( - ( - R2 ) ) + ( - R2 ) ) ) by L393;
end;
L397:
now
let R2 being (Element of R1);
thus L398: ( - ( - R2 ) ) = ( - ( ( - ( ( - R2 ) + ( - ( - R2 ) ) ) ) + ( - ( R2 + ( - ( - R2 ) ) ) ) ) ) by L22
.= ( - ( ( - ( C187 + ( - C187 ) ) ) + ( - ( R2 + ( - ( - R2 ) ) ) ) ) ) by L395
.= ( - ( - ( R2 + ( - ( - R2 ) ) ) ) ) by L393;
end;
L399:
now
let R2 being (Element of R1);
thus L400: ( - R2 ) = ( - ( ( - ( ( - ( - ( - R2 ) ) ) + ( - R2 ) ) ) + ( - ( ( - ( - R2 ) ) + ( - R2 ) ) ) ) ) by L22
.= ( - ( ( - ( ( - ( - ( - R2 ) ) ) + ( - R2 ) ) ) + ( - ( C187 + ( - C187 ) ) ) ) ) by L395
.= ( - ( - ( ( - ( - ( - R2 ) ) ) + ( - R2 ) ) ) ) by L393
.= ( - ( - ( - R2 ) ) ) by L397;
end;
L401:
now
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L402: R3 = ( - ( ( - ( ( - R2 ) + R3 ) ) + ( - ( R2 + R3 ) ) ) ) by L22
.= ( - ( - ( - ( ( - ( ( - R2 ) + R3 ) ) + ( - ( R2 + R3 ) ) ) ) ) ) by L399
.= ( - ( - R3 ) ) by L22;
end;
L403:
now
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L404: ( ( - ( ( - R2 ) + R3 ) ) + ( - ( R2 + R3 ) ) ) = ( - ( - ( ( - ( ( - R2 ) + R3 ) ) + ( - ( R2 + R3 ) ) ) ) ) by L401
.= ( - R3 ) by L22;
end;
L405: ( ( - ( ( - C188 ) + ( - C189 ) ) ) + ( - ( C188 + ( - C189 ) ) ) ) = ( - ( - C189 ) ) by L403
.= C189 by L401;
thus L406: thesis by L405 , L386;
end;
registration
cluster ( TrivComplLat ) ->  with_idempotent_element;
coherence
proof
set D81 = the (Element of ( TrivComplLat ));
take D81;
thus L407: D81 = ( D81 + D81 ) by STRUCT_0:def 10;
end;
end;
registration
cluster  with_idempotent_element ->  Huntington for  Robbins  join-associative  join-commutative non  empty  Robbins  join-associative  join-commutative non  empty  Robbins  join-associative  join-commutative non  empty  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
coherence by L380;
end;
theorem
L410: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds ((ex B162 , B163 being (Element of R1) st ( B162 + B163 ) = B162) implies R1 is  Huntington))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
L411:
now
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
set D82 = ( - ( ( - R2 ) + R3 ) );
thus L412: ( - ( ( - ( ( ( - ( ( - R2 ) + R3 ) ) + R2 ) + R3 ) ) + R3 ) ) = ( - ( ( - ( ( D82 + R2 ) + R3 ) ) + ( - ( D82 + ( - ( R2 + R3 ) ) ) ) ) ) by L22
.= ( - ( ( - ( D82 + ( R2 + R3 ) ) ) + ( - ( D82 + ( - ( R2 + R3 ) ) ) ) ) ) by LATTICES:def 5
.= ( - ( ( - R2 ) + R3 ) ) by L22;
end;
L413:
now
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
set D83 = ( - ( ( - R2 ) + R3 ) );
L414: ( - ( ( - ( ( D83 + R2 ) + R3 ) ) + R3 ) ) = D83 by L411;
thus L415: R4 = ( - ( ( - ( ( ( - ( ( ( - ( ( - R2 ) + R3 ) ) + R2 ) + R3 ) ) + R3 ) + R4 ) ) + ( - ( ( - ( ( - R2 ) + R3 ) ) + R4 ) ) ) ) by L414 , L22;
end;
given C190 , C191 being (Element of R1) such that
L416: ( C190 + C191 ) = C190;

L417:
now
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
set D84 = ( ( - ( ( - R2 ) + R3 ) ) + ( - ( R2 + R3 ) ) );
thus L418: ( - ( ( - ( ( ( - ( ( - R2 ) + R3 ) ) + ( - ( R2 + R3 ) ) ) + R4 ) ) + ( - ( R3 + R4 ) ) ) ) = ( - ( ( - ( D84 + R4 ) ) + ( - ( ( - D84 ) + R4 ) ) ) ) by L22
.= R4 by L22;
end;
L419:
now
let R2 being (Element of R1);
thus L420: C191 = ( - ( ( - ( ( ( - ( ( - R2 ) + C190 ) ) + ( - ( R2 + C190 ) ) ) + C191 ) ) + ( - ( C190 + C191 ) ) ) ) by L417
.= ( - ( ( - C190 ) + ( - ( ( C191 + ( - ( C190 + ( - R2 ) ) ) ) + ( - ( C190 + R2 ) ) ) ) ) ) by L416 , LATTICES:def 5;
end;
set D85 = ( - ( C190 + ( - C190 ) ) );
set D86 = ( - ( ( C190 + C190 ) + ( - ( C190 + ( - C190 ) ) ) ) );
L421: D86 = ( - ( ( C190 + ( - ( C190 + ( - C190 ) ) ) ) + C190 ) ) by LATTICES:def 5;
L422:
now
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L423: ( - ( ( - ( ( C191 + ( - ( C190 + R2 ) ) ) + R3 ) ) + ( - ( ( C190 + R2 ) + R3 ) ) ) ) = ( - ( ( - ( ( - ( C190 + R2 ) ) + ( C191 + R3 ) ) ) + ( - ( ( ( C190 + C191 ) + R2 ) + R3 ) ) ) ) by L416 , LATTICES:def 5
.= ( - ( ( - ( ( - ( C190 + R2 ) ) + ( C191 + R3 ) ) ) + ( - ( ( ( C190 + R2 ) + C191 ) + R3 ) ) ) ) by LATTICES:def 5
.= ( - ( ( - ( ( - ( C190 + R2 ) ) + ( C191 + R3 ) ) ) + ( - ( ( C190 + R2 ) + ( C191 + R3 ) ) ) ) ) by LATTICES:def 5
.= ( C191 + R3 ) by L22;
end;
set D87 = ( - ( C191 + ( - C190 ) ) );
set D88 = ( C191 + ( - C190 ) );
L424: ( - ( ( - C190 ) + ( - ( C191 + ( - C190 ) ) ) ) ) = C191 by L416 , L22;
L425: ( - ( C191 + ( - ( C190 + ( - D88 ) ) ) ) ) = ( - D88 ) by L424 , L22;
L426: ( - ( D87 + ( - ( C190 + D87 ) ) ) ) = ( - ( ( - ( C191 + ( - ( C190 + D87 ) ) ) ) + ( - ( ( C191 + C190 ) + D87 ) ) ) ) by L416 , L424 , L22
.= ( - ( ( - ( C191 + ( - ( C190 + D87 ) ) ) ) + ( - ( C191 + ( C190 + D87 ) ) ) ) ) by LATTICES:def 5
.= C191 by L22;
L427: ( - ( C191 + ( - ( ( C191 + ( - C190 ) ) + ( - ( C190 + ( - ( C191 + ( - C190 ) ) ) ) ) ) ) ) ) = ( - ( C190 + ( - ( C191 + ( - C190 ) ) ) ) ) by L426 , L22;
L428: ( - ( C190 + ( - ( C191 + ( - C190 ) ) ) ) ) = ( - ( C191 + ( - ( ( C191 + ( - ( C190 + ( - ( C191 + ( - C190 ) ) ) ) ) ) + ( - C190 ) ) ) ) ) by L427 , LATTICES:def 5
.= ( - C190 ) by L424 , L425 , L22;
set D89 = ( C190 + ( - ( C191 + ( - C190 ) ) ) );
L429: C190 = ( - ( ( - ( ( C191 + ( - D89 ) ) + C190 ) ) + ( - ( ( - ( C191 + ( - C190 ) ) ) + C190 ) ) ) ) by L425 , L22
.= ( - ( ( - D89 ) + ( - ( C190 + ( - D89 ) ) ) ) ) by L416 , LATTICES:def 5;
L430: ( - ( C190 + ( - ( C190 + ( - ( C190 + ( - C190 ) ) ) ) ) ) ) = ( - ( C190 + ( - C190 ) ) ) by L429 , L428 , L22;
L431: C190 = ( - ( ( - ( C190 + ( - C190 ) ) ) + D86 ) ) by L430 , L421 , L22;
L432: ( - ( C190 + ( - ( ( C190 + ( - C190 ) ) + D86 ) ) ) ) = D86 by L431 , L22;
L433: D86 = ( - ( ( - ( ( D86 + C190 ) + ( - C190 ) ) ) + C190 ) ) by L432 , LATTICES:def 5
.= ( - ( ( - ( ( ( - ( ( ( - ( C190 + ( - C190 ) ) ) + C190 ) + C190 ) ) + C190 ) + ( - C190 ) ) ) + C190 ) ) by LATTICES:def 5
.= ( - C190 ) by L429 , L413 , L428;
L434: ( C191 + ( - ( C190 + ( - C190 ) ) ) ) = ( - ( ( - ( ( C191 + ( - ( C190 + C190 ) ) ) + ( - ( C190 + ( - C190 ) ) ) ) ) + ( - C190 ) ) ) by L433 , L422
.= ( - ( ( - C190 ) + ( - ( ( C191 + ( - ( C190 + ( - C190 ) ) ) ) + ( - ( C190 + C190 ) ) ) ) ) ) by LATTICES:def 5
.= C191 by L419;
L435: ( C190 + ( - ( C190 + ( - C190 ) ) ) ) = C190 by L434 , L416 , LATTICES:def 5;
L436:
now
let R2 being (Element of R1);
thus L437: R2 = ( - ( ( - ( ( C190 + ( - ( C190 + ( - C190 ) ) ) ) + R2 ) ) + ( - ( ( ( - C190 ) + ( - ( C190 + ( - C190 ) ) ) ) + R2 ) ) ) ) by L429 , L428 , L435 , L22
.= ( - ( ( - ( C190 + ( ( - ( C190 + ( - C190 ) ) ) + R2 ) ) ) + ( - ( ( ( - C190 ) + ( - ( C190 + ( - C190 ) ) ) ) + R2 ) ) ) ) by LATTICES:def 5
.= ( - ( ( - ( C190 + ( ( - ( C190 + ( - C190 ) ) ) + R2 ) ) ) + ( - ( ( - C190 ) + ( ( - ( C190 + ( - C190 ) ) ) + R2 ) ) ) ) ) by LATTICES:def 5
.= ( ( - ( C190 + ( - C190 ) ) ) + R2 ) by L22;
end;
L438: D85 = ( D85 + D85 ) by L436;
L439: R1 is  with_idempotent_element by L438 , L328;
thus L440: thesis by L439;
end;
theorem
L441: (for R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr holds (ex R3 being (Element of R1) st (ex R4 being (Element of R1) st ( R3 + R4 ) = R4)))
proof
let R1 being  Robbins  join-associative  join-commutative non  empty ComplLLattStr;
L442:
now
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L443: ( - ( R2 + R3 ) ) = ( - ( ( - ( ( - ( ( - R2 ) + R3 ) ) + ( - ( R2 + R3 ) ) ) ) + ( - ( ( ( - R2 ) + R3 ) + ( - ( R2 + R3 ) ) ) ) ) ) by L22
.= ( - ( R3 + ( - ( ( ( - R2 ) + R3 ) + ( - ( R2 + R3 ) ) ) ) ) ) by L22
.= ( - ( ( - ( ( ( - ( R2 + R3 ) ) + ( - R2 ) ) + R3 ) ) + R3 ) ) by LATTICES:def 5;
end;
L444:
now
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L445: ( - ( ( - R2 ) + R3 ) ) = ( - ( ( - ( ( - ( R2 + R3 ) ) + ( - ( ( - R2 ) + R3 ) ) ) ) + ( - ( ( R2 + R3 ) + ( - ( ( - R2 ) + R3 ) ) ) ) ) ) by L22
.= ( - ( R3 + ( - ( ( R2 + R3 ) + ( - ( ( - R2 ) + R3 ) ) ) ) ) ) by L22
.= ( - ( ( - ( ( ( - ( ( - R2 ) + R3 ) ) + R2 ) + R3 ) ) + R3 ) ) by LATTICES:def 5;
end;
L446:
now
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L447: R3 = ( - ( ( - ( ( - ( ( ( - ( ( - R2 ) + R3 ) ) + R2 ) + R3 ) ) + R3 ) ) + ( - ( ( ( ( - ( ( - R2 ) + R3 ) ) + R2 ) + R3 ) + R3 ) ) ) ) by L22
.= ( - ( ( - ( ( - R2 ) + R3 ) ) + ( - ( ( ( ( - ( ( - R2 ) + R3 ) ) + R2 ) + R3 ) + R3 ) ) ) ) by L444
.= ( - ( ( - ( ( ( - ( ( - R2 ) + R3 ) ) + R2 ) + ( Double R3 ) ) ) + ( - ( ( - R2 ) + R3 ) ) ) ) by LATTICES:def 5;
end;
L448:
now
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
thus L449: R4 = ( - ( ( - ( ( - ( ( - ( ( ( - ( ( - R2 ) + R3 ) ) + R2 ) + ( Double R3 ) ) ) + ( - ( ( - R2 ) + R3 ) ) ) ) + R4 ) ) + ( - ( ( ( - ( ( ( - ( ( - R2 ) + R3 ) ) + R2 ) + ( Double R3 ) ) ) + ( - ( ( - R2 ) + R3 ) ) ) + R4 ) ) ) ) by L22
.= ( - ( ( - ( ( ( - ( ( ( - ( ( - R2 ) + R3 ) ) + R2 ) + ( Double R3 ) ) ) + ( - ( ( - R2 ) + R3 ) ) ) + R4 ) ) + ( - ( R3 + R4 ) ) ) ) by L446;
end;
L450:
now
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
set D90 = ( ( ( - ( ( ( - ( ( - R2 ) + R3 ) ) + R2 ) + ( Double R3 ) ) ) + ( - ( ( - R2 ) + R3 ) ) ) + R4 );
thus L451: ( - ( R3 + R4 ) ) = ( - ( ( - ( ( - D90 ) + ( - ( R3 + R4 ) ) ) ) + ( - ( D90 + ( - ( R3 + R4 ) ) ) ) ) ) by L22
.= ( - ( R4 + ( - ( D90 + ( - ( R3 + R4 ) ) ) ) ) ) by L448
.= ( - ( ( - ( ( ( ( - ( ( ( - ( ( - R2 ) + R3 ) ) + R2 ) + ( Double R3 ) ) ) + ( - ( ( - R2 ) + R3 ) ) ) + ( - ( R3 + R4 ) ) ) + R4 ) ) + R4 ) ) by LATTICES:def 5;
end;
L452:
now
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
let R5 being (Element of R1);
set D91 = ( ( - ( ( ( ( - ( ( ( - ( ( - R2 ) + R3 ) ) + R2 ) + ( Double R3 ) ) ) + ( - ( ( - R2 ) + R3 ) ) ) + ( - ( R3 + R4 ) ) ) + R4 ) ) + R4 );
thus L453: R5 = ( - ( ( - ( ( - D91 ) + R5 ) ) + ( - ( D91 + R5 ) ) ) ) by L22
.= ( - ( ( - ( ( - ( R3 + R4 ) ) + R5 ) ) + ( - ( D91 + R5 ) ) ) ) by L450;
end;
L454:
now
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
let R6 being (Element of R1);
set D92 = ( - ( ( - ( ( Double R6 ) + R6 ) ) + R6 ) );
set D93 = ( ( - ( ( - ( ( Double R6 ) + R6 ) ) + R6 ) ) + ( Double R6 ) );
set D94 = ( ( ( Double R6 ) + ( Double R6 ) ) + R6 );
L455: ( - ( ( ( Double R6 ) + R6 ) + D93 ) ) = ( - ( ( - ( ( ( - ( ( ( Double R6 ) + R6 ) + D93 ) ) + ( - ( ( Double R6 ) + R6 ) ) ) + D93 ) ) + D93 ) ) by L442
.= ( - ( ( - ( ( ( - ( ( ( Double R6 ) + R6 ) + D93 ) ) + D93 ) + ( - ( ( Double R6 ) + R6 ) ) ) ) + D93 ) ) by LATTICES:def 5;
thus L456: D92 = ( - ( ( - ( ( - ( R6 + ( Double R6 ) ) ) + D92 ) ) + ( - ( ( ( - ( ( ( ( - ( ( ( - ( ( - ( ( Double R6 ) + R6 ) ) + R6 ) ) + ( ( Double R6 ) + R6 ) ) + ( Double R6 ) ) ) + ( - ( ( - ( ( Double R6 ) + R6 ) ) + R6 ) ) ) + ( - ( R6 + ( Double R6 ) ) ) ) + ( Double R6 ) ) ) + ( Double R6 ) ) + D92 ) ) ) ) by L452
.= ( - ( ( - ( ( - ( R6 + ( Double R6 ) ) ) + D92 ) ) + ( - ( ( ( - ( ( ( ( - ( ( ( ( Double R6 ) + R6 ) + D92 ) + ( Double R6 ) ) ) + D92 ) + ( Double R6 ) ) + ( - ( R6 + ( Double R6 ) ) ) ) ) + ( Double R6 ) ) + D92 ) ) ) ) by LATTICES:def 5
.= ( - ( ( - ( ( - ( R6 + ( Double R6 ) ) ) + D92 ) ) + ( - ( ( ( - ( ( ( - ( ( ( ( Double R6 ) + R6 ) + D92 ) + ( Double R6 ) ) ) + ( D92 + ( Double R6 ) ) ) + ( - ( R6 + ( Double R6 ) ) ) ) ) + ( Double R6 ) ) + D92 ) ) ) ) by LATTICES:def 5
.= ( - ( ( - ( ( - ( R6 + ( Double R6 ) ) ) + D92 ) ) + ( - ( ( ( - ( ( ( - ( ( ( Double R6 ) + R6 ) + ( D92 + ( Double R6 ) ) ) ) + D93 ) + ( - ( R6 + ( Double R6 ) ) ) ) ) + ( Double R6 ) ) + D92 ) ) ) ) by LATTICES:def 5
.= ( - ( ( - ( ( - ( R6 + ( Double R6 ) ) ) + D92 ) ) + ( - ( ( - ( ( ( - ( ( ( Double R6 ) + R6 ) + D93 ) ) + D93 ) + ( - ( R6 + ( Double R6 ) ) ) ) ) + D93 ) ) ) ) by LATTICES:def 5
.= ( - ( ( - ( ( - ( ( Double R6 ) + R6 ) ) + D92 ) ) + ( - ( ( ( ( Double R6 ) + R6 ) + ( Double R6 ) ) + D92 ) ) ) ) by L455 , LATTICES:def 5
.= ( - ( ( - ( ( - ( ( Double R6 ) + R6 ) ) + D92 ) ) + ( - ( D94 + D92 ) ) ) ) by LATTICES:def 5;
end;
L457:
now
let R2 being (Element of R1);
set D95 = ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( - ( ( Double R2 ) + R2 ) ) );
set D96 = ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( ( ( Double R2 ) + ( Double R2 ) ) + R2 ) ) );
L458: ( - ( ( Double R2 ) + R2 ) ) = ( - ( ( - ( ( ( - ( ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( ( Double R2 ) + R2 ) ) + ( Double R2 ) ) ) + ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) ) + ( - ( ( Double R2 ) + R2 ) ) ) ) + ( - ( R2 + ( - ( ( Double R2 ) + R2 ) ) ) ) ) ) by L448
.= ( - ( ( - ( ( - ( ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( ( Double R2 ) + R2 ) ) + ( Double R2 ) ) ) + D95 ) ) + ( - ( R2 + ( - ( ( Double R2 ) + R2 ) ) ) ) ) ) by LATTICES:def 5
.= ( - ( ( - ( ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( ( ( Double R2 ) + R2 ) + ( Double R2 ) ) ) ) + D95 ) ) + ( - ( R2 + ( - ( ( Double R2 ) + R2 ) ) ) ) ) ) by LATTICES:def 5
.= ( - ( ( - ( D96 + D95 ) ) + ( - ( R2 + ( - ( ( Double R2 ) + R2 ) ) ) ) ) ) by LATTICES:def 5;
L459: D96 = ( - ( ( - ( ( - D95 ) + D96 ) ) + ( - ( D95 + D96 ) ) ) ) by L22
.= ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( - ( D95 + D96 ) ) ) ) by L454;
thus L460: ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( ( ( Double R2 ) + ( Double R2 ) ) + R2 ) ) ) = ( - ( ( Double R2 ) + R2 ) ) by L459 , L458;
end;
L461:
now
let R2 being (Element of R1);
L462: ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) = ( - ( ( - ( ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( ( Double R2 ) + R2 ) ) + R2 ) ) + R2 ) ) by L444
.= ( - ( ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( ( ( Double R2 ) + R2 ) + R2 ) ) ) + R2 ) ) by LATTICES:def 5
.= ( - ( ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( ( Double R2 ) + ( Double R2 ) ) ) ) + R2 ) ) by LATTICES:def 5;
thus L463: R2 = ( - ( ( - ( ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( ( Double R2 ) + ( Double R2 ) ) ) ) + R2 ) ) + ( - ( ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( ( Double R2 ) + ( Double R2 ) ) ) + R2 ) ) ) ) by L22
.= ( - ( ( - ( ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( ( Double R2 ) + ( Double R2 ) ) ) ) + R2 ) ) + ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( ( ( Double R2 ) + ( Double R2 ) ) + R2 ) ) ) ) ) by LATTICES:def 5
.= ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( - ( ( Double R2 ) + R2 ) ) ) ) by L457 , L462;
end;
L464:
now
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L465: R3 = ( - ( ( - ( ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( - ( ( Double R2 ) + R2 ) ) ) ) + R3 ) ) + ( - ( ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( - ( ( Double R2 ) + R2 ) ) ) + R3 ) ) ) ) by L22
.= ( - ( ( - ( ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( - ( ( Double R2 ) + R2 ) ) ) + R3 ) ) + ( - ( R2 + R3 ) ) ) ) by L461;
end;
L466:
now
let R2 being (Element of R1);
thus L467: ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( Double R2 ) ) = ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( Double R2 ) ) ) ) + ( - ( ( ( Double R2 ) + R2 ) + ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( Double R2 ) ) ) ) ) ) by L22
.= ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( Double R2 ) ) ) ) + ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( ( ( Double R2 ) + R2 ) + ( Double R2 ) ) ) ) ) ) by LATTICES:def 5
.= ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( Double R2 ) ) ) ) + ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( ( ( Double R2 ) + ( Double R2 ) ) + R2 ) ) ) ) ) by LATTICES:def 5
.= ( - ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( Double R2 ) ) ) ) + ( - ( ( Double R2 ) + R2 ) ) ) ) by L457
.= ( - ( ( - ( ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( - ( ( Double R2 ) + R2 ) ) ) + ( Double R2 ) ) ) + ( - ( ( Double R2 ) + R2 ) ) ) ) by LATTICES:def 5;
end;
L468:
now
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L469: ( Double R2 ) = ( - ( ( - ( ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( - ( ( Double R2 ) + R2 ) ) ) + ( Double R2 ) ) ) + ( - ( R2 + ( Double R2 ) ) ) ) ) by L464
.= ( ( - ( ( - ( ( Double R2 ) + R2 ) ) + R2 ) ) + ( Double R2 ) ) by L466;
end;
set D97 = the (Element of R1);
set D98 = ( Double D97 );
set D99 = ( - ( ( - ( ( Double D97 ) + D97 ) ) + D97 ) );
take D99;
take D98;
thus L470: thesis by L468;
end;
registration
cluster  Robbins ->  Huntington for  join-associative  join-commutative non  empty  join-associative  join-commutative non  empty  join-associative  join-commutative non  empty  join-associative  join-commutative non  empty ComplLLattStr;
coherence
proof
let C192 being  join-associative  join-commutative non  empty ComplLLattStr;
assume L471: C192 is  Robbins;
L472: (ex B164 , B165 being (Element of C192) st ( B164 + B165 ) = B165) by L471 , L441;
thus L473: thesis by L472 , L471 , L410;
end;
end;
definition
let C193 being non  empty OrthoLattStr;
attr C193 is  de_Morgan
means
:L475: (for B166 , B167 being (Element of C193) holds ( B166 "/\" B167 ) = ( ( ( B166 ` ) "\/" ( B167 ` ) ) ` ));
end;
registration
let C194 being non  empty ComplLLattStr;
cluster ( CLatt C194 ) ->  de_Morgan;
coherence
proof
let C195 , C196 being (Element of ( CLatt C194 ));
reconsider D100 = C195 , D101 = C196 as (Element of C194) by L258;
L477: (( D100 ` ) = ( C195 ` ) & ( D101 ` ) = ( C196 ` )) by L258;
L478: ( ( D100 ` ) "\/" ( D101 ` ) ) = ( ( C195 ` ) "\/" ( C196 ` ) ) by L477 , L258;
L479: ( ( ( C195 ` ) "\/" ( C196 ` ) ) ` ) = ( D100 *' D101 ) by L478 , L258;
thus L480: thesis by L479 , L258;
end;
end;
theorem
L482: (for B168 being  well-complemented  join-commutative  meet-commutative non  empty OrthoLattStr holds (for B169 being (Element of B168) holds (( B169 + ( B169 ` ) ) = ( Top B168 ) & ( B169 "/\" ( B169 ` ) ) = ( Bottom B168 ))))
proof
let C197 being  well-complemented  join-commutative  meet-commutative non  empty OrthoLattStr;
let C198 being (Element of C197);
L483: ( C198 ` ) is_a_complement_of C198 by L223;
thus L484: ( C198 + ( C198 ` ) ) = ( Top C197 ) by L483 , LATTICES:def 18;
thus L485: thesis by L483 , LATTICES:def 18;
end;
theorem
L486: (for B170 being  bounded  distributive  well-complemented preOrthoLattice holds ( ( Top B170 ) ` ) = ( Bottom B170 ))
proof
let C199 being  bounded  distributive  well-complemented preOrthoLattice;
set D102 = the (Element of C199);
L487: ( ( Top C199 ) ` ) = ( ( ( ( D102 ` ) ` ) + ( D102 ` ) ) ` ) by L482
.= ( ( D102 ` ) "/\" D102 ) by L243
.= ( Bottom C199 ) by L482;
thus L488: thesis by L487;
end;
registration
cluster ( TrivOrtLat ) ->  de_Morgan;
coherence
proof
let C200 , C201 being (Element of ( TrivOrtLat ));
thus L489: thesis by STRUCT_0:def 10;
end;
end;
registration
cluster  strict  de_Morgan  Boolean  Robbins  Huntington for preOrthoLattice;
existence
proof
take ( TrivOrtLat );
thus L491: thesis;
end;
end;
registration
cluster  join-associative  join-commutative  de_Morgan ->  meet-commutative for non  empty non  empty non  empty non  empty OrthoLattStr;
coherence
proof
let C202 being non  empty OrthoLattStr;
assume L493: C202 is  join-associative  join-commutative  de_Morgan;
reconsider D103 = C202 as  join-associative  join-commutative  de_Morgan non  empty OrthoLattStr by L493;
let C203 , C204 being (Element of C202);
reconsider D104 = C203 , D105 = C204 as (Element of D103);
thus L494: ( C203 "/\" C204 ) = ( D104 *' D105 ) by L475
.= ( D105 *' D104 )
.= ( C204 "/\" C203 ) by L475;
end;
end;
theorem
L496: (for B171 being  Huntington  de_Morgan preOrthoLattice holds ( Bot B171 ) = ( Bottom B171 ))
proof
let C205 being  Huntington  de_Morgan preOrthoLattice;
reconsider D106 = ( Bot C205 ) as (Element of C205);
L497: (for B172 being (Element of C205) holds (( D106 "/\" B172 ) = D106 & ( B172 "/\" D106 ) = D106))
proof
let C206 being (Element of C205);
reconsider D107 = C206 as (Element of C205);
thus L498: ( D106 "/\" C206 ) = ( ( Bot C205 ) *' D107 ) by L475
.= D106 by L84;
thus L499: thesis by L498;
end;
L500: C205 is  lower-bounded by L497 , LATTICES:def 13;
thus L501: thesis by L500 , L497 , LATTICES:def 16;
end;
registration
cluster  Boolean ->  Huntington for  well-complemented  well-complemented  well-complemented  well-complemented preOrthoLattice;
coherence
proof
let C207 being  well-complemented preOrthoLattice;
assume L502: C207 is  Boolean;
reconsider D108 = C207 as  Boolean preOrthoLattice by L502;
L503: (for B173 being (Element of D108) holds ( ( Top D108 ) "/\" B173 ) = B173);
L504:
now
let C208 , C209 being (Element of C207);
thus L505: ( ( ( ( C208 ` ) "\/" ( C209 ` ) ) ` ) "\/" ( ( ( C208 ` ) "\/" C209 ) ` ) ) = ( ( C208 "/\" C209 ) + ( ( ( C208 ` ) + C209 ) ` ) ) by L502 , L243
.= ( ( C208 + ( ( ( C208 ` ) + C209 ) ` ) ) "/\" ( C209 + ( ( ( C208 ` ) + C209 ) ` ) ) ) by L502 , LATTICES:11
.= ( ( C208 + ( ( ( C208 ` ) + ( ( C209 ` ) ` ) ) ` ) ) "/\" ( C209 + ( ( ( C208 ` ) + C209 ) ` ) ) ) by L502 , L237
.= ( ( C208 + ( C208 "/\" ( C209 ` ) ) ) "/\" ( C209 + ( ( ( C208 ` ) + C209 ) ` ) ) ) by L502 , L243
.= ( C208 "/\" ( C209 + ( ( ( C208 ` ) + C209 ) ` ) ) ) by LATTICES:def 8
.= ( C208 "/\" ( C209 + ( ( ( C208 ` ) + ( ( C209 ` ) ` ) ) ` ) ) ) by L502 , L237
.= ( C208 "/\" ( C209 + ( C208 "/\" ( C209 ` ) ) ) ) by L502 , L243
.= ( C208 "/\" ( ( C209 + C208 ) "/\" ( C209 + ( C209 ` ) ) ) ) by L502 , LATTICES:11
.= ( ( C208 "/\" ( C209 + C208 ) ) "/\" ( C209 + ( C209 ` ) ) ) by LATTICES:def 7
.= ( C208 "/\" ( C209 + ( C209 ` ) ) ) by LATTICES:def 9
.= ( C208 "/\" ( Top C207 ) ) by L482
.= C208 by L503;
end;
thus L506: thesis by L504 , L23;
end;
end;
registration
cluster  Huntington ->  Boolean for  de_Morgan  de_Morgan  de_Morgan  de_Morgan preOrthoLattice;
coherence
proof
let C210 being  de_Morgan preOrthoLattice;
assume L508: C210 is  Huntington;
reconsider D109 = C210 as  Huntington preOrthoLattice by L508;
L509: C210 is  lower-bounded
proof
set D110 = ( Bot D109 );
reconsider D111 = D110 as (Element of C210);
take D111;
let C211 being (Element of C210);
reconsider D112 = C211 as (Element of D109);
thus L510: ( D111 "/\" C211 ) = ( D110 *' D112 ) by L475
.= D111 by L84;
thus L511: ( C211 "/\" D111 ) = ( D110 *' D112 ) by L475
.= D111 by L84;
end;
L512: D109 is  upper-bounded;
thus L513: C210 is  bounded by L512 , L509;
thus L514: C210 is  complemented
proof
let C212 being (Element of C210);
take D113 = ( C212 ` );
L515: D109 is  join-idempotent;
thus L516: ( D113 + C212 ) = ( Top C210 ) by L515 , L65;
thus L517: ( C212 + D113 ) = ( Top C210 ) by L515 , L65;
thus L518: ( D113 "/\" C212 ) = ( ( ( D113 ` ) + ( C212 ` ) ) ` ) by L475
.= ( Bot D109 ) by L91
.= ( Bottom C210 ) by L496;
thus L519: ( C212 "/\" D113 ) = ( Bottom C210 ) by L518;
end;

thus L520: C210 is  distributive
proof
let C213 , C214 , C215 being (Element of C210);
L521: (( C213 "/\" C214 ) = ( C213 *' C214 ) & ( C213 "/\" C215 ) = ( C213 *' C215 )) by L475;
thus L522: ( C213 "/\" ( C214 "\/" C215 ) ) = ( C213 *' ( C214 + C215 ) ) by L475
.= ( ( C213 "/\" C214 ) "\/" ( C213 "/\" C215 ) ) by L508 , L521 , L217;
end;

end;
end;
registration
cluster  Robbins  de_Morgan ->  Boolean for preOrthoLattice;
coherence;
cluster  Boolean ->  Robbins for  well-complemented  well-complemented  well-complemented  well-complemented preOrthoLattice;
coherence
proof
let C216 being  well-complemented preOrthoLattice;
assume L522: C216 is  Boolean;
reconsider D114 = C216 as  Boolean  well-complemented preOrthoLattice by L522;
L523:
now
let C217 , C218 being (Element of D114);
thus L524: ( ( ( ( C217 + C218 ) ` ) + ( ( C217 + ( C218 ` ) ) ` ) ) ` ) = ( ( C217 + C218 ) "/\" ( C217 + ( C218 ` ) ) ) by L243
.= ( ( ( C217 + C218 ) "/\" C217 ) + ( ( C217 + C218 ) "/\" ( C218 ` ) ) ) by LATTICES:def 11
.= ( ( ( C217 + C218 ) "/\" C217 ) + ( ( C217 "/\" ( C218 ` ) ) + ( C218 "/\" ( C218 ` ) ) ) ) by LATTICES:def 11
.= ( ( ( C217 + C218 ) "/\" C217 ) + ( ( C217 "/\" ( C218 ` ) ) + ( ( ( C218 ` ) + ( ( C218 ` ) ` ) ) ` ) ) ) by L243
.= ( C217 + ( ( C217 "/\" ( C218 ` ) ) + ( ( ( C218 ` ) + ( ( C218 ` ) ` ) ) ` ) ) ) by LATTICES:def 9
.= ( ( C217 + ( C217 "/\" ( C218 ` ) ) ) + ( ( ( C218 ` ) + ( ( C218 ` ) ` ) ) ` ) ) by LATTICES:def 5
.= ( C217 + ( ( ( C218 ` ) + ( ( C218 ` ) ` ) ) ` ) ) by LATTICES:def 8
.= ( C217 + ( ( Top D114 ) ` ) ) by L482
.= ( C217 + ( Bottom D114 ) ) by L486
.= C217;
end;
thus L525: thesis by L523 , L22;
end;
end;
