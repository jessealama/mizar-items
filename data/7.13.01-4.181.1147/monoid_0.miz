:: Monoids
::  by Grzegorz Bancerek
::
:: Received December 29, 1992
:: Copyright (c) 1992-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies STRUCT_0, ALGSTR_0, BINOP_1, SUBSET_1, FUNCT_1, FINSEQ_1,
      RELAT_1, ORDINAL4, XBOOLE_0, ALGSTR_1, SETWISEO, FUNCOP_1, ZFMISC_1,
      GROUP_1, FINSEQOP, MESFUNC1, VECTSP_1, TARSKI, REALSET1, MCART_1,
      NUMBERS, BINOP_2, REAL_1, ARYTM_3, CARD_1, GR_CY_1, INT_1, PARTFUN1,
      FUNCT_2, MONOID_0;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, REAL_1, XTUPLE_0,
      MCART_1, DOMAIN_1, BINOP_2, REALSET1, STRUCT_0, RELAT_1, FINSEQOP,
      FUNCT_1, FINSEQ_1, PARTFUN1, FUNCT_2, BINOP_1, FINSEQ_2, INT_1, GROUP_1,
      VECTSP_1, SETWISEO, FUNCOP_1, GR_CY_1, ALGSTR_0;
 constructors RELAT_2, PARTFUN1, BINOP_1, SETWISEO, BINOP_2, FINSEQOP,
      REALSET1, VECTSP_2, GR_CY_1, RELSET_1, XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, PARTFUN1,
      FUNCT_2, NUMBERS, BINOP_2, MEMBERED, FINSEQ_1, REALSET1, STRUCT_0,
      GROUP_1, ALGSTR_0, GR_CY_1, XTUPLE_0;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, BINOP_1, SETWISEO, FINSEQOP, GROUP_1, STRUCT_0, XBOOLE_0,
      REALSET1, VECTSP_1, ALGSTR_0, FUNCOP_1, XTUPLE_0;
 theorems TARSKI, NAT_1, INT_1, FINSEQ_1, BINOP_1, GROUP_1, FINSEQOP, SETWISEO,
      VECTSP_1, MCART_1, ZFMISC_1, FUNCT_1, FUNCT_2, FUNCT_4, FUNCOP_1,
      PARTFUN1, GR_CY_1, GRFUNC_1, RELAT_1, RELSET_1, XBOOLE_1, XCMPLX_1,
      NUMBERS, BINOP_2;
 schemes FUNCT_2, BINOP_1, XBOOLE_0;

begin
deffunc H1(1-sorted) = (the carrier of $1);
deffunc H2(multMagma) = (the multF of $1);
definition
let C1 being 1-sorted;
mode BinOp of C1
 is (BinOp of (the carrier of C1));
end;
definition
let C2 being 1-sorted;
attr C2 is  constituted-Functions
means
:L2: (for B1 being (Element of C2) holds B1 is Function);
attr C2 is  constituted-FinSeqs
means
:L3: (for B2 being (Element of C2) holds B2 is FinSequence);
end;
registration
cluster  constituted-Functions for 1-sorted;
existence
proof
set D1 = the Function;
take D2 = 1-sorted (# { D1 } #);
let C3 being (Element of D2);
thus L5: thesis;
end;
cluster  constituted-FinSeqs for 1-sorted;
existence
proof
set D3 = the FinSequence;
take D4 = 1-sorted (# { D3 } #);
let C4 being (Element of D4);
thus L6: thesis by TARSKI:def 1;
end;
end;
registration
let C5 being  constituted-Functions 1-sorted;
cluster  ->  Function-like  Relation-like for (Element of C5);
coherence by L2;
end;
registration
cluster  constituted-FinSeqs ->  constituted-Functions for 1-sorted;
coherence
proof
let C6 being 1-sorted;
assume that
L9: C6 is  constituted-FinSeqs;
let C7 being (Element of H1(C6));
thus L10: thesis by L9 , L3;
end;
end;
registration
let C8 being  constituted-FinSeqs 1-sorted;
cluster  ->  FinSequence-like for (Element of C8);
coherence by L3;
end;
definition
let C9 being set;
let C10 , C11 being (FinSequence of C9);
redefine func C10 ^ C11 -> (Element of ( C9 * ));

coherence
proof
thus L13: ( C10 ^ C11 ) is (Element of ( C9 * )) by FINSEQ_1:def 11;
end;
end;
notation
let C12 , C13 being Function;
synonym C13 (*) C12 for C13 * C12;
end;
definition
let C14 being non  empty set;
let C15 being (BinOp of C14);
attr C15 is  left-invertible
means
(for B3 , B4 being (Element of C14) holds (ex B5 being (Element of C14) st ( C15 . (B5 , B3) ) = B4));
attr C15 is  right-invertible
means
(for B6 , B7 being (Element of C14) holds (ex B8 being (Element of C14) st ( C15 . (B6 , B8) ) = B7));
attr C15 is  invertible
means
:L16: (for B9 , B10 being (Element of C14) holds (ex B11 , B12 being (Element of C14) st (( C15 . (B9 , B11) ) = B10 & ( C15 . (B12 , B9) ) = B10)));
attr C15 is  left-cancelable
means
(for B13 , B14 , B15 being (Element of C14) holds (( C15 . (B13 , B14) ) = ( C15 . (B13 , B15) ) implies B14 = B15));
attr C15 is  right-cancelable
means
(for B16 , B17 , B18 being (Element of C14) holds (( C15 . (B17 , B16) ) = ( C15 . (B18 , B16) ) implies B17 = B18));
attr C15 is  cancelable
means
(for B19 , B20 , B21 being (Element of C14) holds ((( C15 . (B19 , B20) ) = ( C15 . (B19 , B21) ) or ( C15 . (B20 , B19) ) = ( C15 . (B21 , B19) )) implies B20 = B21));
attr C15 is  uniquely-decomposable
means
(C15 is  having_a_unity & (for B22 , B23 being (Element of C14) holds (( C15 . (B22 , B23) ) = ( the_unity_wrt C15 ) implies (B22 = B23 & B23 = ( the_unity_wrt C15 )))));
end;
theorem
L18: (for B24 being non  empty set holds (for B25 being (BinOp of B24) holds (B25 is  invertible iff B25 is  left-invertible  right-invertible)))
proof
let C16 being non  empty set;
let C17 being (BinOp of C16);
thus L19: (C17 is  invertible implies C17 is  left-invertible  right-invertible)
proof
assume L20: (for B26 , B27 being (Element of C16) holds (ex B28 , B29 being (Element of C16) st (( C17 . (B26 , B28) ) = B27 & ( C17 . (B29 , B26) ) = B27)));
L21:
now
let C18 , C19 being (Element of C16);
consider C20 , C21 being (Element of C16) such that L22: ( C17 . (C18 , C20) ) = C19 and L23: ( C17 . (C21 , C18) ) = C19 by L20;
take D5 = C21;
thus L24: ( C17 . (D5 , C18) ) = C19 by L23;
end;
thus L25: (for B30 , B31 being (Element of C16) holds (ex B32 being (Element of C16) st ( C17 . (B32 , B30) ) = B31)) by L21;
let C22 , C23 being (Element of C16);
consider C24 , C25 being (Element of C16) such that L26: ( C17 . (C22 , C24) ) = C23 and L27: ( C17 . (C25 , C22) ) = C23 by L20;
take C24;
thus L28: thesis by L26;
end;

assume that
L29: (for B33 , B34 being (Element of C16) holds (ex B35 being (Element of C16) st ( C17 . (B35 , B33) ) = B34))
and
L30: (for B36 , B37 being (Element of C16) holds (ex B38 being (Element of C16) st ( C17 . (B36 , B38) ) = B37));
let C26 , C27 being (Element of C16);
consider C28 being (Element of C16) such that L31: ( C17 . (C28 , C26) ) = C27 by L29;
consider C29 being (Element of C16) such that L32: ( C17 . (C26 , C29) ) = C27 by L30;
take C29;
take C28;
thus L33: thesis by L31 , L32;
end;
theorem
L34: (for B39 being non  empty set holds (for B40 being (BinOp of B39) holds (B40 is  cancelable iff B40 is  left-cancelable  right-cancelable)))
proof
let C30 being non  empty set;
let C31 being (BinOp of C30);
thus L35: (C31 is  cancelable implies C31 is  left-cancelable  right-cancelable)
proof
assume L36: (for B41 , B42 , B43 being (Element of C30) holds ((( C31 . (B41 , B42) ) = ( C31 . (B41 , B43) ) or ( C31 . (B42 , B41) ) = ( C31 . (B43 , B41) )) implies B42 = B43));
thus L37: (for B44 , B45 , B46 being (Element of C30) holds (( C31 . (B44 , B45) ) = ( C31 . (B44 , B46) ) implies B45 = B46)) by L36;
thus L38: (for B47 , B48 , B49 being (Element of C30) holds (( C31 . (B48 , B47) ) = ( C31 . (B49 , B47) ) implies B48 = B49)) by L36;
end;

assume L39: ((for B50 , B51 , B52 being (Element of C30) holds (( C31 . (B50 , B51) ) = ( C31 . (B50 , B52) ) implies B51 = B52)) & (for B53 , B54 , B55 being (Element of C30) holds (( C31 . (B54 , B53) ) = ( C31 . (B55 , B53) ) implies B54 = B55)));
thus L40: (for B56 , B57 , B58 being (Element of C30) holds ((( C31 . (B56 , B57) ) = ( C31 . (B56 , B58) ) or ( C31 . (B57 , B56) ) = ( C31 . (B58 , B56) )) implies B57 = B58)) by L39;
end;
theorem
L41: (for R1 being set holds (for B59 being (BinOp of { R1 }) holds (B59 = ( (R1 , R1) .--> R1 ) & B59 is  having_a_unity & B59 is  commutative & B59 is  associative & B59 is  idempotent & B59 is  invertible  cancelable  uniquely-decomposable)))
proof
let R1 being set;
let C32 being (BinOp of { R1 });
reconsider D6 = R1 as (Element of { R1 }) by TARSKI:def 1;
L42: [: { R1 } , { R1 } :] = { [ R1 , R1 ] } by ZFMISC_1:29;
L43:
now
let R2 being set;
assume L44: R2 in { [ R1 , R1 ] };
reconsider D7 = R2 as (Element of [: { R1 } , { R1 } :]) by L44 , ZFMISC_1:29;
thus L45: ( C32 . R2 ) = ( C32 . D7 )
.= R1 by TARSKI:def 1
.= ( ( (R1 , R1) .--> R1 ) . R2 ) by L44 , FUNCOP_1:7;
end;
L46: (( dom C32 ) = [: { R1 } , { R1 } :] & ( dom ( (R1 , R1) .--> R1 ) ) = { [ R1 , R1 ] }) by FUNCT_2:def 1;
thus L47: C32 = ( (R1 , R1) .--> R1 ) by L46 , L42 , L43 , FUNCT_1:2;
L48:
now
let C33 , C34 being (Element of { R1 });
L49: C33 = R1 by TARSKI:def 1;
thus L50: C33 = C34 by L49 , TARSKI:def 1;
end;
L51: (for B60 being (Element of { R1 }) holds (( C32 . (D6 , B60) ) = B60 & ( C32 . (B60 , D6) ) = B60)) by L48;
L52: D6 is_a_unity_wrt C32 by L51 , BINOP_1:3;
thus L53: (ex B61 being (Element of { R1 }) st B61 is_a_unity_wrt C32) by L52;
thus L54: (for B62 , B63 being (Element of { R1 }) holds ( C32 . (B62 , B63) ) = ( C32 . (B63 , B62) )) by L48;
thus L55: (for B64 , B65 , B66 being (Element of { R1 }) holds ( C32 . (B64 , ( C32 . (B65 , B66) )) ) = ( C32 . (( C32 . (B64 , B65) ) , B66) )) by L48;
thus L56: (for B67 being (Element of { R1 }) holds ( C32 . (B67 , B67) ) = B67) by L48;
thus L57: (for B68 , B69 being (Element of { R1 }) holds (ex B70 , B71 being (Element of { R1 }) st (( C32 . (B68 , B70) ) = B69 & ( C32 . (B71 , B68) ) = B69)))
proof
let C35 , C36 being (Element of { R1 });
take C35;
take C35;
thus L58: thesis by L48;
end;

thus L59: (for B72 , B73 , B74 being (Element of { R1 }) holds ((( C32 . (B72 , B73) ) = ( C32 . (B72 , B74) ) or ( C32 . (B73 , B72) ) = ( C32 . (B74 , B72) )) implies B73 = B74)) by L48;
thus L60: (ex B75 being (Element of { R1 }) st B75 is_a_unity_wrt C32) by L52;
let C37 , C38 being (Element of { R1 });
thus L61: thesis by L48;
end;
begin
definition
let C39 being non  empty multMagma;
redefine attr C39 is  unital
means
:L62: (the multF of C39) is  having_a_unity;
compatibility
proof
thus L63: (C39 is  unital implies (the multF of C39) is  having_a_unity);
given C40 being (Element of C39) such that
L64: C40 is_a_unity_wrt (the multF of C39);

take C40;
let C41 being (Element of C39);
thus L65: thesis by L64 , BINOP_1:3;
end;
end;
definition
let R5 being non  empty multMagma;
redefine attr R5 is  commutative
means
:L67: (the multF of R5) is  commutative;
compatibility
proof
thus L68: (R5 is  commutative implies (the multF of R5) is  commutative)
proof
assume L69: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds ( R7 * R8 ) = ( R8 * R7 )));
let R7 being (Element of R5);
let R8 being (Element of R5);
L70: (( H2(R5) . (R7 , R8) ) = ( R7 * R8 ) & ( H2(R5) . (R8 , R7) ) = ( R8 * R7 ));
thus L71: thesis by L70 , L69;
end;

assume L72: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds ( H2(R5) . (R7 , R8) ) = ( H2(R5) . (R8 , R7) )));
let R7 being (Element of R5);
let R8 being (Element of R5);
thus L73: thesis by L72;
end;
redefine attr R5 is  associative
means
:L74: (the multF of R5) is  associative;
compatibility
proof
thus L75: (R5 is  associative implies (the multF of R5) is  associative);
assume L76: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds ( H2(R5) . (R7 , ( H2(R5) . (R8 , R9) )) ) = ( H2(R5) . (( H2(R5) . (R7 , R8) ) , R9) ))));
let R7 being (Element of R5);
let R8 being (Element of R5);
let R9 being (Element of R5);
thus L77: thesis by L76;
end;
end;
definition
let C42 being non  empty multMagma;
attr C42 is  idempotent
means
(the multF of C42) is  idempotent;
attr C42 is  left-invertible
means
(the multF of C42) is  left-invertible;
attr C42 is  right-invertible
means
(the multF of C42) is  right-invertible;
attr C42 is  invertible
means
:L79: (the multF of C42) is  invertible;
attr C42 is  left-cancelable
means
(the multF of C42) is  left-cancelable;
attr C42 is  right-cancelable
means
(the multF of C42) is  right-cancelable;
attr C42 is  cancelable
means
(the multF of C42) is  cancelable;
attr C42 is  uniquely-decomposable
means
:L80: (the multF of C42) is  uniquely-decomposable;
end;
registration
cluster  unital  commutative  associative  cancelable  idempotent  invertible  uniquely-decomposable  constituted-Functions  constituted-FinSeqs  strict for non  empty non  empty non  empty non  empty multMagma;
existence
proof
set D8 = the FinSequence;
set D9 = the (BinOp of { D8 });
take D10 = multMagma (# { D8 } , D9 #);
thus L82: (H2(D10) is  having_a_unity & H2(D10) is  commutative & H2(D10) is  associative & H2(D10) is  cancelable & H2(D10) is  idempotent & H2(D10) is  invertible  uniquely-decomposable) by L41;
thus L83: ((for B76 being (Element of D10) holds B76 is Function) & (for B77 being (Element of D10) holds B77 is FinSequence)) by TARSKI:def 1;
thus L84: thesis;
end;
end;
theorem
L86: (for R5 being non  empty multMagma holds (R5 is  unital implies ( the_unity_wrt (the multF of R5) ) is_a_unity_wrt (the multF of R5)))
proof
let R5 being non  empty multMagma;
given R7 being (Element of R5) such that
L87: R7 is_a_unity_wrt H2(R5);

thus L88: thesis by L87 , BINOP_1:def 8;
end;
theorem
L89: (for R5 being non  empty multMagma holds (R5 is  unital iff (for R7 being (Element of R5) holds (( ( the_unity_wrt (the multF of R5) ) * R7 ) = R7 & ( R7 * ( the_unity_wrt (the multF of R5) ) ) = R7))))
proof
let R5 being non  empty multMagma;
set D11 = ( the_unity_wrt (the multF of R5) );
thus L90: (R5 is  unital implies (for R8 being (Element of R5) holds (( D11 * R8 ) = R8 & ( R8 * D11 ) = R8)))
proof
given R7 being (Element of R5) such that
L91: R7 is_a_unity_wrt H2(R5);

let R8 being (Element of R5);
L92: D11 = R7 by L91 , BINOP_1:def 8;
thus L93: thesis by L92 , L91 , BINOP_1:3;
end;

assume L94: (for R8 being (Element of R5) holds (( D11 * R8 ) = R8 & ( R8 * D11 ) = R8));
take D12 = D11;
thus L95: D12 is_a_left_unity_wrt (the multF of R5)
proof
let R8 being (Element of R5);
L96: ( D12 * R8 ) = R8 by L94;
thus L97: thesis by L96;
end;

let R8 being (Element of R5);
L98: ( R8 * D12 ) = R8 by L94;
thus L99: thesis by L98;
end;
theorem
L100: (for R5 being non  empty multMagma holds (R5 is  unital iff (ex R7 being (Element of R5) st (for R8 being (Element of R5) holds (( R7 * R8 ) = R8 & ( R8 * R7 ) = R8)))))
proof
let R5 being non  empty multMagma;
thus L101: (R5 is  unital implies (ex R7 being (Element of R5) st (for R8 being (Element of R5) holds (( R7 * R8 ) = R8 & ( R8 * R7 ) = R8))))
proof
given R7 being (Element of R5) such that
L102: R7 is_a_unity_wrt (the multF of R5);

take R7;
let R8 being (Element of R5);
L103: (R7 is_a_left_unity_wrt H2(R5) & R7 is_a_right_unity_wrt (the multF of R5)) by L102 , BINOP_1:def 7;
thus L104: thesis by L103 , BINOP_1:def 5 , BINOP_1:def 6;
end;

given R7 being (Element of R5) such that
L105: (for R8 being (Element of R5) holds (( R7 * R8 ) = R8 & ( R8 * R7 ) = R8));

take R7;
thus L106: R7 is_a_left_unity_wrt (the multF of R5)
proof
let R8 being (Element of R5);
L107: ( R7 * R8 ) = R8 by L105;
thus L108: thesis by L107;
end;

let R8 being (Element of R5);
L109: ( R8 * R7 ) = R8 by L105;
thus L110: thesis by L109;
end;
L111: (for R5 being non  empty multMagma holds (R5 is  commutative iff (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds ( R7 * R8 ) = ( R8 * R7 )))))
proof
let R5 being non  empty multMagma;
thus L112: (R5 is  commutative implies (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds ( R7 * R8 ) = ( R8 * R7 ))))
proof
assume L113: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds ( H2(R5) . (R7 , R8) ) = ( H2(R5) . (R8 , R7) )));
let R7 being (Element of R5);
let R8 being (Element of R5);
thus L114: thesis by L113;
end;

assume L115: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds ( R7 * R8 ) = ( R8 * R7 )));
let R7 being (Element of R5);
let R8 being (Element of R5);
L116: (( H2(R5) . (R7 , R8) ) = ( R7 * R8 ) & ( H2(R5) . (R8 , R7) ) = ( R8 * R7 ));
thus L117: thesis by L116 , L115;
end;
L118: (for R5 being non  empty multMagma holds (R5 is  associative iff (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds ( ( R7 * R8 ) * R9 ) = ( R7 * ( R8 * R9 ) ))))))
proof
let R5 being non  empty multMagma;
thus L119: (R5 is  associative implies (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds ( ( R7 * R8 ) * R9 ) = ( R7 * ( R8 * R9 ) )))))
proof
assume L120: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds ( H2(R5) . (R7 , ( H2(R5) . (R8 , R9) )) ) = ( H2(R5) . (( H2(R5) . (R7 , R8) ) , R9) ))));
let R7 being (Element of R5);
let R8 being (Element of R5);
let R9 being (Element of R5);
thus L121: thesis by L120;
end;

assume L122: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds ( ( R7 * R8 ) * R9 ) = ( R7 * ( R8 * R9 ) ))));
let R7 being (Element of R5);
let R8 being (Element of R5);
let R9 being (Element of R5);
L123: (( H2(R5) . (( R7 * R8 ) , R9) ) = ( ( R7 * R8 ) * R9 ) & ( H2(R5) . (R7 , ( R8 * R9 )) ) = ( R7 * ( R8 * R9 ) ));
thus L124: thesis by L123 , L122;
end;
theorem
L125: (for R5 being non  empty multMagma holds (R5 is  idempotent iff (for R7 being (Element of R5) holds ( R7 * R7 ) = R7)))
proof
let R5 being non  empty multMagma;
thus L126: (R5 is  idempotent implies (for R7 being (Element of R5) holds ( R7 * R7 ) = R7))
proof
assume L127: (for R7 being (Element of R5) holds ( H2(R5) . (R7 , R7) ) = R7);
let R7 being (Element of R5);
thus L128: thesis by L127;
end;

assume L129: (for R7 being (Element of R5) holds ( R7 * R7 ) = R7);
let R7 being (Element of R5);
thus L130: ( H2(R5) . (R7 , R7) ) = ( R7 * R7 )
.= R7 by L129;
end;
theorem
L131: (for R5 being non  empty multMagma holds (R5 is  left-invertible iff (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (ex R11 being (Element of R5) st ( R11 * R7 ) = R8)))))
proof
let R5 being non  empty multMagma;
thus L132: (R5 is  left-invertible implies (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (ex R11 being (Element of R5) st ( R11 * R7 ) = R8))))
proof
assume L133: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (ex R11 being (Element of R5) st ( H2(R5) . (R11 , R7) ) = R8)));
let R7 being (Element of R5);
let R8 being (Element of R5);
consider R11 being (Element of R5) such that L134: ( H2(R5) . (R11 , R7) ) = R8 by L133;
take R11;
thus L135: thesis by L134;
end;

assume L136: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (ex R11 being (Element of R5) st ( R11 * R7 ) = R8)));
let R7 being (Element of R5);
let R8 being (Element of R5);
consider R11 being (Element of R5) such that L137: ( R11 * R7 ) = R8 by L136;
take R11;
thus L138: thesis by L137;
end;
theorem
L139: (for R5 being non  empty multMagma holds (R5 is  right-invertible iff (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (ex R10 being (Element of R5) st ( R7 * R10 ) = R8)))))
proof
let R5 being non  empty multMagma;
thus L140: (R5 is  right-invertible implies (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (ex R10 being (Element of R5) st ( R7 * R10 ) = R8))))
proof
assume L141: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (ex R10 being (Element of R5) st ( H2(R5) . (R7 , R10) ) = R8)));
let R7 being (Element of R5);
let R8 being (Element of R5);
consider R10 being (Element of R5) such that L142: ( H2(R5) . (R7 , R10) ) = R8 by L141;
take R10;
thus L143: thesis by L142;
end;

assume L144: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (ex R10 being (Element of R5) st ( R7 * R10 ) = R8)));
let R7 being (Element of R5);
let R8 being (Element of R5);
consider R10 being (Element of R5) such that L145: ( R7 * R10 ) = R8 by L144;
take R10;
thus L146: thesis by L145;
end;
theorem
L147: (for R5 being non  empty multMagma holds (R5 is  invertible iff (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (ex R10 being (Element of R5) st (ex R11 being (Element of R5) st (( R7 * R10 ) = R8 & ( R11 * R7 ) = R8)))))))
proof
let R5 being non  empty multMagma;
thus L148: (R5 is  invertible implies (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (ex R10 being (Element of R5) st (ex R11 being (Element of R5) st (( R7 * R10 ) = R8 & ( R11 * R7 ) = R8))))))
proof
assume L149: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (ex R10 being (Element of R5) st (ex R11 being (Element of R5) st (( H2(R5) . (R7 , R10) ) = R8 & ( H2(R5) . (R11 , R7) ) = R8)))));
let R7 being (Element of R5);
let R8 being (Element of R5);
consider R10 being (Element of R5), R11 being (Element of R5) such that L150: (( H2(R5) . (R7 , R10) ) = R8 & ( H2(R5) . (R11 , R7) ) = R8) by L149;
take R10;
take R11;
thus L151: thesis by L150;
end;

assume L152: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (ex R10 being (Element of R5) st (ex R11 being (Element of R5) st (( R7 * R10 ) = R8 & ( R11 * R7 ) = R8)))));
let R7 being (Element of R5);
let R8 being (Element of R5);
consider R10 being (Element of R5), R11 being (Element of R5) such that L153: (( R7 * R10 ) = R8 & ( R11 * R7 ) = R8) by L152;
take R10;
take R11;
thus L154: thesis by L153;
end;
theorem
L155: (for R5 being non  empty multMagma holds (R5 is  left-cancelable iff (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds (( R7 * R8 ) = ( R7 * R9 ) implies R8 = R9))))))
proof
let R5 being non  empty multMagma;
thus L156: (R5 is  left-cancelable implies (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds (( R7 * R8 ) = ( R7 * R9 ) implies R8 = R9)))))
proof
assume L157: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds (( H2(R5) . (R7 , R8) ) = ( H2(R5) . (R7 , R9) ) implies R8 = R9))));
let R7 being (Element of R5);
let R8 being (Element of R5);
let R9 being (Element of R5);
thus L158: thesis by L157;
end;

assume L159: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds (( R7 * R8 ) = ( R7 * R9 ) implies R8 = R9))));
let R7 being (Element of R5);
let R8 being (Element of R5);
let R9 being (Element of R5);
L160: (( R7 * R8 ) = ( H2(R5) . (R7 , R8) ) & ( R7 * R9 ) = ( H2(R5) . (R7 , R9) ));
thus L161: thesis by L160 , L159;
end;
theorem
L162: (for R5 being non  empty multMagma holds (R5 is  right-cancelable iff (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds (( R8 * R7 ) = ( R9 * R7 ) implies R8 = R9))))))
proof
let R5 being non  empty multMagma;
thus L163: (R5 is  right-cancelable implies (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds (( R8 * R7 ) = ( R9 * R7 ) implies R8 = R9)))))
proof
assume L164: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds (( H2(R5) . (R8 , R7) ) = ( H2(R5) . (R9 , R7) ) implies R8 = R9))));
let R7 being (Element of R5);
let R8 being (Element of R5);
let R9 being (Element of R5);
thus L165: thesis by L164;
end;

assume L166: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds (( R8 * R7 ) = ( R9 * R7 ) implies R8 = R9))));
let R7 being (Element of R5);
let R8 being (Element of R5);
let R9 being (Element of R5);
L167: (( R8 * R7 ) = ( H2(R5) . (R8 , R7) ) & ( R9 * R7 ) = ( H2(R5) . (R9 , R7) ));
thus L168: thesis by L167 , L166;
end;
theorem
L169: (for R5 being non  empty multMagma holds (R5 is  cancelable iff (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds ((( R7 * R8 ) = ( R7 * R9 ) or ( R8 * R7 ) = ( R9 * R7 )) implies R8 = R9))))))
proof
let R5 being non  empty multMagma;
thus L170: (R5 is  cancelable implies (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds ((( R7 * R8 ) = ( R7 * R9 ) or ( R8 * R7 ) = ( R9 * R7 )) implies R8 = R9)))))
proof
assume L171: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds ((( H2(R5) . (R7 , R8) ) = ( H2(R5) . (R7 , R9) ) or ( H2(R5) . (R8 , R7) ) = ( H2(R5) . (R9 , R7) )) implies R8 = R9))));
let R7 being (Element of R5);
let R8 being (Element of R5);
let R9 being (Element of R5);
thus L172: thesis by L171;
end;

assume L173: (for R7 being (Element of R5) holds (for R8 being (Element of R5) holds (for R9 being (Element of R5) holds ((( R7 * R8 ) = ( R7 * R9 ) or ( R8 * R7 ) = ( R9 * R7 )) implies R8 = R9))));
let R7 being (Element of R5);
let R8 being (Element of R5);
let R9 being (Element of R5);
L174: (( R8 * R7 ) = ( H2(R5) . (R8 , R7) ) & ( R9 * R7 ) = ( H2(R5) . (R9 , R7) ));
L175: (( R7 * R8 ) = ( H2(R5) . (R7 , R8) ) & ( R7 * R9 ) = ( H2(R5) . (R7 , R9) ));
thus L176: thesis by L175 , L173 , L174;
end;
theorem
L177: (for R5 being non  empty multMagma holds (R5 is  uniquely-decomposable iff ((the multF of R5) is  having_a_unity & (for B78 , B79 being (Element of R5) holds (( B78 * B79 ) = ( the_unity_wrt (the multF of R5) ) implies (B78 = B79 & B79 = ( the_unity_wrt (the multF of R5) )))))))
proof
let R5 being non  empty multMagma;
thus L178: (R5 is  uniquely-decomposable implies (H2(R5) is  having_a_unity & (for B80 , B81 being (Element of R5) holds (( B80 * B81 ) = ( the_unity_wrt H2(R5) ) implies (B80 = B81 & B81 = ( the_unity_wrt (the multF of R5) ))))))
proof
assume that
L179: H2(R5) is  having_a_unity
and
L180: (for B82 , B83 being (Element of R5) holds (( H2(R5) . (B82 , B83) ) = ( the_unity_wrt H2(R5) ) implies (B82 = B83 & B83 = ( the_unity_wrt H2(R5) ))));
thus L181: H2(R5) is  having_a_unity by L179;
let C43 , C44 being (Element of R5);
thus L182: thesis by L180;
end;

assume that
L183: H2(R5) is  having_a_unity
and
L184: (for B84 , B85 being (Element of R5) holds (( B84 * B85 ) = ( the_unity_wrt H2(R5) ) implies (B84 = B85 & B85 = ( the_unity_wrt H2(R5) ))));
thus L185: H2(R5) is  having_a_unity by L183;
let C45 , C46 being (Element of R5);
L186: ( C45 * C46 ) = ( H2(R5) . (C45 , C46) );
thus L187: thesis by L186 , L184;
end;
theorem
L188: (for R5 being non  empty multMagma holds (R5 is  associative implies (R5 is  invertible iff (R5 is  unital & (the multF of R5) is  having_an_inverseOp))))
proof
let R5 being non  empty multMagma;
assume L189: R5 is  associative;
thus L190: (R5 is  invertible implies (R5 is  unital & H2(R5) is  having_an_inverseOp))
proof
set D13 = the (Element of R5);
assume L191: R5 is  invertible;
consider C47 , C48 being (Element of R5) such that L192: ( D13 * C47 ) = D13 and L193: ( C48 * D13 ) = D13 by L191 , L147;
L194:
now
let R7 being (Element of R5);
L195: (ex R8 being (Element of R5) st (ex R9 being (Element of R5) st (( D13 * R8 ) = R7 & ( R9 * D13 ) = R7))) by L191 , L147;
thus L196: ( C48 * R7 ) = R7 by L195 , L189 , L193 , L118;
thus L197: ( R7 * C47 ) = R7 by L189 , L192 , L195 , L118;
end;
L198: (( C48 * C47 ) = C47 & ( C48 * C47 ) = C48) by L194;
thus L199: R5 is  unital by L198 , L194 , L100;
defpred S1[ (Element of R5) , (Element of R5) ] means (( $1 * $2 ) = C47 & ( $2 * $1 ) = C47);
L200: (for R7 being (Element of R5) holds (ex R8 being (Element of R5) st S1[ R7 , R8 ]))
proof
let R7 being (Element of R5);
consider R8 being (Element of R5), R9 being (Element of R5) such that L201: (( R7 * R8 ) = C47 & ( R9 * R7 ) = C47) by L191 , L147;
take R8;
L202: (( R9 * ( R7 * R8 ) ) = ( ( R9 * R7 ) * R8 ) & ( C47 * R8 ) = R8) by L189 , L194 , L198 , L118;
thus L203: thesis by L202 , L194 , L201;
end;
L204: (ex B86 being (Function of (the carrier of R5) , (the carrier of R5)) st (for B87 being (Element of R5) holds S1[ B87 , ( B86 . B87 ) ])) from FUNCT_2:sch 3(L200);
consider C49 being (UnOp of H1(R5)) such that L205: (for B88 being (Element of R5) holds S1[ B88 , ( C49 . B88 ) ]) by L204;
L206:
now
let R8 being (Element of R5);
L207: (( C47 * R8 ) = ( H2(R5) . (C47 , R8) ) & ( R8 * C47 ) = ( H2(R5) . (R8 , C47) ));
thus L208: (( H2(R5) . (C47 , R8) ) = R8 & ( H2(R5) . (R8 , C47) ) = R8) by L207 , L194 , L198;
end;
L209: C47 is_a_unity_wrt H2(R5) by L206 , BINOP_1:3;
L210: C47 = ( the_unity_wrt H2(R5) ) by L209 , BINOP_1:def 8;
take C49;
let R7 being (Element of R5);
L211: (( H2(R5) . (R7 , ( C49 . R7 )) ) = ( R7 * ( C49 . R7 ) ) & ( H2(R5) . (( C49 . R7 ) , R7) ) = ( ( C49 . R7 ) * R7 ));
thus L212: thesis by L211 , L205 , L210;
end;

assume L213: H2(R5) is  having_a_unity;
given C50 being (UnOp of H1(R5)) such that
L214: C50 is_an_inverseOp_wrt H2(R5);

let R7 being (Element of R5);
let R9 being (Element of R5);
take D14 = ( ( C50 . R7 ) * R9 );
take D15 = ( R9 * ( C50 . R7 ) );
thus L215: ( H2(R5) . (R7 , D14) ) = ( R7 * D14 )
.= ( ( R7 * ( C50 . R7 ) ) * R9 ) by L189 , L118
.= ( H2(R5) . (( the_unity_wrt H2(R5) ) , R9) ) by L214 , FINSEQOP:def 1
.= R9 by L213 , SETWISEO:15;
thus L216: ( H2(R5) . (D15 , R7) ) = ( D15 * R7 )
.= ( R9 * ( ( C50 . R7 ) * R7 ) ) by L189 , L118
.= ( H2(R5) . (R9 , ( the_unity_wrt H2(R5) )) ) by L214 , FINSEQOP:def 1
.= R9 by L213 , SETWISEO:15;
end;
L217: (for R5 being non  empty multMagma holds (R5 is  invertible iff R5 is  left-invertible  right-invertible))
proof
let R5 being non  empty multMagma;
thus L218: (R5 is  invertible implies R5 is  left-invertible  right-invertible)
proof
assume L219: H2(R5) is  invertible;
thus L220: H2(R5) is  left-invertible  right-invertible by L219 , L18;
end;

assume L221: H2(R5) is  left-invertible  right-invertible;
thus L222: H2(R5) is  invertible by L221 , L18;
end;
L223: (for R5 being non  empty multMagma holds (R5 is  cancelable iff R5 is  left-cancelable  right-cancelable))
proof
let R5 being non  empty multMagma;
thus L224: (R5 is  cancelable implies R5 is  left-cancelable  right-cancelable)
proof
assume L225: H2(R5) is  cancelable;
thus L226: H2(R5) is  left-cancelable  right-cancelable by L225 , L34;
end;

assume L227: H2(R5) is  left-cancelable  right-cancelable;
thus L228: H2(R5) is  cancelable by L227 , L34;
end;
L229: (for R5 being non  empty multMagma holds (R5 is  associative  invertible implies R5 is  Group-like))
proof
let R5 being non  empty multMagma;
assume L230: R5 is  associative  invertible;
L231: R5 is  unital by L230 , L188;
consider R7 being (Element of R5) such that L232: (for R8 being (Element of R5) holds (( R7 * R8 ) = R8 & ( R8 * R7 ) = R8)) by L231 , L100;
take R7;
let R8 being (Element of R5);
thus L233: (( R8 * R7 ) = R8 & ( R7 * R8 ) = R8) by L232;
L234: H2(R5) is  invertible by L230 , L79;
consider C51 , C52 being (Element of R5) such that L235: (( H2(R5) . (R8 , C51) ) = R7 & ( H2(R5) . (C52 , R8) ) = R7) by L234 , L16;
take C51;
L236: (( R8 * C51 ) = R7 & ( C52 * R8 ) = R7) by L235;
L237: C52 = ( C52 * R7 ) by L232
.= ( R7 * C51 ) by L230 , L236 , L118
.= C51 by L232;
thus L238: thesis by L237 , L235;
end;
registration
cluster  associative  Group-like ->  invertible for non  empty non  empty non  empty non  empty multMagma;
coherence
proof
let C53 being non  empty multMagma;
assume L239: C53 is  associative  Group-like;
reconsider D16 = C53 as  associative  Group-like non  empty multMagma by L239;
L240: H2(D16) is  having_an_inverseOp;
thus L241: thesis by L240 , L188;
end;
cluster  associative  invertible ->  Group-like for non  empty non  empty non  empty non  empty multMagma;
coherence by L229;
end;
registration
cluster  invertible ->  left-invertible  right-invertible for non  empty non  empty non  empty non  empty multMagma;
coherence by L217;
cluster  left-invertible  right-invertible ->  invertible for non  empty non  empty non  empty non  empty multMagma;
coherence by L217;
cluster  cancelable ->  left-cancelable  right-cancelable for non  empty non  empty non  empty non  empty multMagma;
coherence by L223;
cluster  left-cancelable  right-cancelable ->  cancelable for non  empty non  empty non  empty non  empty multMagma;
coherence by L223;
cluster  associative  invertible ->  unital  cancelable for non  empty non  empty non  empty non  empty multMagma;
coherence
proof
let C54 being non  empty multMagma;
assume L243: C54 is  associative  invertible;
reconsider D17 = C54 as  associative  invertible non  empty multMagma by L243;
L244: (for B89 , B90 , B91 being (Element of D17) holds ((( B89 * B90 ) = ( B89 * B91 ) or ( B90 * B89 ) = ( B91 * B89 )) implies B90 = B91)) by GROUP_1:6;
thus L245: thesis by L244 , L169;
end;
end;
begin
deffunc H3(multLoopStr) = ( 1. $1 );
definition
let C55 being non  empty multLoopStr;
redefine attr C55 is  well-unital
means
:L247: ( 1. C55 ) is_a_unity_wrt (the multF of C55);
compatibility
proof
thus L248: (C55 is  well-unital implies ( 1. C55 ) is_a_unity_wrt (the multF of C55))
proof
assume L249: C55 is  well-unital;
thus L250: ( 1. C55 ) is_a_left_unity_wrt (the multF of C55)
proof
let C56 being (Element of C55);
thus L251: ( (the multF of C55) . (( 1. C55 ) , C56) ) = ( ( 1. C55 ) * C56 )
.= C56 by L249 , VECTSP_1:def 6;
end;

let C57 being (Element of C55);
thus L252: ( (the multF of C55) . (C57 , ( 1. C55 )) ) = ( C57 * ( 1. C55 ) )
.= C57 by L249 , VECTSP_1:def 6;
end;

assume L253: ( 1. C55 ) is_a_unity_wrt (the multF of C55);
let C58 being (Element of C55);
L254: ( 1. C55 ) is_a_right_unity_wrt (the multF of C55) by L253 , BINOP_1:def 7;
thus L255: ( C58 * ( 1. C55 ) ) = C58 by L254 , BINOP_1:def 6;
L256: ( 1. C55 ) is_a_left_unity_wrt (the multF of C55) by L253 , BINOP_1:def 7;
thus L257: thesis by L256 , BINOP_1:def 5;
end;
end;
theorem
L259: (for R12 being non  empty multLoopStr holds (R12 is  well-unital iff (for B92 being (Element of R12) holds (( ( 1. R12 ) * B92 ) = B92 & ( B92 * ( 1. R12 ) ) = B92))))
proof
let R12 being non  empty multLoopStr;
L260: (R12 is  well-unital iff H3(R12) is_a_unity_wrt H2(R12)) by L247;
thus L261: (R12 is  well-unital implies (for B93 being (Element of R12) holds (( H3(R12) * B93 ) = B93 & ( B93 * H3(R12) ) = B93))) by L260 , BINOP_1:3;
assume L262: (for B94 being (Element of R12) holds (( H3(R12) * B94 ) = B94 & ( B94 * H3(R12) ) = B94));
L263:
now
let C59 being (Element of R12);
L264: (( H3(R12) * C59 ) = C59 & ( C59 * H3(R12) ) = C59) by L262;
thus L265: (( H2(R12) . (H3(R12) , C59) ) = C59 & ( H2(R12) . (C59 , H3(R12)) ) = C59) by L264;
end;
thus L266: thesis by L263 , L260 , BINOP_1:3;
end;
theorem
L267: (for B95 being non  empty multLoopStr holds (B95 is  well-unital implies ( 1. B95 ) = ( the_unity_wrt (the multF of B95) )))
proof
let C60 being non  empty multLoopStr;
assume L268: H3(C60) is_a_unity_wrt (the multF of C60);
thus L269: thesis by L268 , BINOP_1:def 8;
end;
registration
cluster  well-unital  commutative  associative  cancelable  idempotent  invertible  uniquely-decomposable  unital  constituted-Functions  constituted-FinSeqs  strict for non  empty non  empty non  empty non  empty multLoopStr;
existence
proof
set D18 = the FinSequence;
set D19 = the (BinOp of { D18 });
set D20 = the (Element of { D18 });
take D21 = multLoopStr (# { D18 } , D19 , D20 #);
reconsider D22 = D20 as (Element of D21);
reconsider D23 = D19 as (BinOp of D21);
L270:
now
let C61 being (Element of D21);
L271: (( D23 . (D22 , C61) ) = D18 & ( D23 . (C61 , D22) ) = D18) by TARSKI:def 1;
thus L272: (( D23 . (D22 , C61) ) = C61 & ( D23 . (C61 , D22) ) = C61) by L271 , TARSKI:def 1;
end;
thus L273: H3(D21) is_a_unity_wrt H2(D21) by L270 , BINOP_1:3;
thus L274: (H2(D21) is  commutative & H2(D21) is  associative & H2(D21) is  cancelable & H2(D21) is  idempotent & H2(D21) is  invertible  uniquely-decomposable & (ex B96 being (Element of D21) st B96 is_a_unity_wrt H2(D21))) by L273 , L41;
thus L275: ((for B97 being (Element of D21) holds B97 is Function) & (for B98 being (Element of D21) holds B98 is FinSequence)) by TARSKI:def 1;
thus L276: thesis;
end;
end;
definition
mode Monoid
 is  well-unital  associative non  empty multLoopStr;
end;
definition
let C62 being multMagma;
mode MonoidalExtension of C62
 -> multLoopStr
means :L279: ( the multMagma of it ) = ( the multMagma of C62 );
existence
proof
set D24 = the (Element of C62);
take multLoopStr (# H1(C62) , H2(C62) , D24 #);
thus L280: thesis;
end;
end;
registration
let C63 being non  empty multMagma;
cluster  -> non  empty for (MonoidalExtension of C63);
coherence
proof
let C64 being (MonoidalExtension of C63);
L282: ( the multMagma of C64 ) = ( the multMagma of C63 ) by L279;
thus L283: (the carrier of C64) is non  empty by L282;
end;
end;
theorem
L285: (for R5 being non  empty multMagma holds (for B99 being (MonoidalExtension of R5) holds ((the carrier of B99) = (the carrier of R5) & (the multF of B99) = (the multF of R5) & (for B100 , B101 being (Element of B99) holds (for B102 , B103 being (Element of R5) holds ((B100 = B102 & B101 = B103) implies ( B100 * B101 ) = ( B102 * B103 )))))))
proof
let R5 being non  empty multMagma;
let C65 being (MonoidalExtension of R5);
L286: ( the multMagma of C65 ) = ( the multMagma of R5 ) by L279;
thus L287: (H1(C65) = H1(R5) & H2(C65) = H2(R5)) by L286;
let C66 , C67 being (Element of C65);
let C68 , C69 being (Element of R5);
thus L288: thesis by L286;
end;
registration
let C70 being multMagma;
cluster  strict for (MonoidalExtension of C70);
existence
proof
set D25 = the (Element of C70);
set D26 = multLoopStr (# H1(C70) , H2(C70) , D25 #);
L289: ( the multMagma of D26 ) = ( the multMagma of C70 );
L290: D26 is (MonoidalExtension of C70) by L289 , L279;
thus L291: thesis by L290;
end;
end;
theorem
L293: (for B104 being non  empty multMagma holds (for B105 being (MonoidalExtension of B104) holds ((B104 is  unital implies B105 is  unital) & (B104 is  commutative implies B105 is  commutative) & (B104 is  associative implies B105 is  associative) & (B104 is  invertible implies B105 is  invertible) & (B104 is  uniquely-decomposable implies B105 is  uniquely-decomposable) & (B104 is  cancelable implies B105 is  cancelable))))
proof
let C71 being non  empty multMagma;
let C72 being (MonoidalExtension of C71);
L294: ( the multMagma of C72 ) = ( the multMagma of C71 ) by L279;
thus L295: (C71 is  unital implies C72 is  unital)
proof
assume L296: H2(C71) is  having_a_unity;
thus L297: H2(C72) is  having_a_unity by L296 , L294;
end;

thus L298: (C71 is  commutative implies C72 is  commutative)
proof
assume L299: H2(C71) is  commutative;
thus L300: H2(C72) is  commutative by L299 , L294;
end;

thus L301: (C71 is  associative implies C72 is  associative)
proof
assume L302: H2(C71) is  associative;
thus L303: H2(C72) is  associative by L302 , L294;
end;

thus L304: (C71 is  invertible implies C72 is  invertible)
proof
assume L305: H2(C71) is  invertible;
thus L306: H2(C72) is  invertible by L305 , L294;
end;

thus L307: (C71 is  uniquely-decomposable implies C72 is  uniquely-decomposable)
proof
assume L308: H2(C71) is  uniquely-decomposable;
thus L309: H2(C72) is  uniquely-decomposable by L308 , L294;
end;

assume L310: H2(C71) is  cancelable;
thus L311: H2(C72) is  cancelable by L310 , L294;
end;
registration
let C73 being  constituted-Functions multMagma;
cluster  ->  constituted-Functions for (MonoidalExtension of C73);
coherence
proof
let C74 being (MonoidalExtension of C73);
let C75 being (Element of C74);
L312: ( the multMagma of C74 ) = ( the multMagma of C73 ) by L279;
thus L313: thesis by L312;
end;
end;
registration
let C76 being  constituted-FinSeqs multMagma;
cluster  ->  constituted-FinSeqs for (MonoidalExtension of C76);
coherence
proof
let C77 being (MonoidalExtension of C76);
let C78 being (Element of C77);
L315: ( the multMagma of C77 ) = ( the multMagma of C76 ) by L279;
thus L316: thesis by L315;
end;
end;
registration
let C79 being  unital non  empty multMagma;
cluster  ->  unital for (MonoidalExtension of C79);
coherence by L293;
end;
registration
let C80 being  associative non  empty multMagma;
cluster  ->  associative for (MonoidalExtension of C80);
coherence by L293;
end;
registration
let C81 being  commutative non  empty multMagma;
cluster  ->  commutative for (MonoidalExtension of C81);
coherence by L293;
end;
registration
let C82 being  invertible non  empty multMagma;
cluster  ->  invertible for (MonoidalExtension of C82);
coherence by L293;
end;
registration
let C83 being  cancelable non  empty multMagma;
cluster  ->  cancelable for (MonoidalExtension of C83);
coherence by L293;
end;
registration
let C84 being  uniquely-decomposable non  empty multMagma;
cluster  ->  uniquely-decomposable for (MonoidalExtension of C84);
coherence by L293;
end;
registration
let C85 being  unital non  empty multMagma;
cluster  well-unital  strict for (MonoidalExtension of C85);
existence
proof
set D27 = multLoopStr (# H1(C85) , H2(C85) , ( the_unity_wrt H2(C85) ) #);
L324: ( the multMagma of D27 ) = ( the multMagma of C85 );
reconsider D28 = D27 as (MonoidalExtension of C85) by L324 , L279;
take D28;
thus L325: H3(D28) is_a_unity_wrt H2(D28) by L86;
thus L326: thesis;
end;
end;
theorem
L328: (for B106 being  unital non  empty multMagma holds (for B107 , B108 being  well-unital  strict (MonoidalExtension of B106) holds B107 = B108))
proof
let C86 being  unital non  empty multMagma;
let C87 , C88 being  well-unital  strict (MonoidalExtension of C86);
L329: (H3(C87) = ( the_unity_wrt H2(C87) ) & H3(C88) = ( the_unity_wrt H2(C88) )) by L267;
L330: (( the multMagma of C87 ) = ( the multMagma of C86 ) & ( the multMagma of C88 ) = ( the multMagma of C86 )) by L279;
thus L331: thesis by L330 , L329;
end;
begin
definition
let C89 being multMagma;
mode SubStr of C89
 -> multMagma
means :L332: (the multF of it) c= (the multF of C89);
existence;
end;
registration
let C90 being multMagma;
cluster  strict for (SubStr of C90);
existence
proof
L334: ( the multMagma of C90 ) is (SubStr of C90) by L332;
thus L335: thesis by L334;
end;
end;
registration
let C91 being non  empty multMagma;
cluster  strict non  empty for (SubStr of C91);
existence
proof
L337: ( the multMagma of C91 ) is (SubStr of C91) by L332;
thus L338: thesis by L337;
end;
end;
registration
let C92 being  unital non  empty multMagma;
cluster  unital  associative  commutative  cancelable  idempotent  invertible  uniquely-decomposable  strict for non  empty non  empty non  empty non  empty (SubStr of C92);
existence
proof
consider C93 being (Element of C92) such that L340: (for B109 being (Element of C92) holds (( C93 * B109 ) = B109 & ( B109 * C93 ) = B109)) by L100;
L341: C93 = ( C93 * C93 ) by L340;
set D29 = the (BinOp of { C93 });
set D30 = multMagma (# { C93 } , D29 #);
L342: ( dom H2(C92) ) = [: H1(C92) , H1(C92) :] by FUNCT_2:def 1;
L343: D29 = ( (C93 , C93) .--> C93 ) by L41
.= ( [ C93 , C93 ] .--> C93 );
L344: H2(D30) c= H2(C92) by L343 , L341 , L342 , FUNCT_4:7;
reconsider D31 = D30 as non  empty (SubStr of C92) by L344 , L332;
take D31;
thus L345: (H2(D31) is  having_a_unity & H2(D31) is  associative & H2(D31) is  commutative & H2(D31) is  cancelable & H2(D31) is  idempotent & H2(D31) is  invertible  uniquely-decomposable) by L41;
thus L346: thesis;
end;
end;
definition
let C94 being multMagma;
mode MonoidalSubStr of C94
 -> multLoopStr
means :L348: ((the multF of it) c= (the multF of C94) & (for B110 being multLoopStr holds (C94 = B110 implies ( 1. it ) = ( 1. B110 ))));
existence
proof
set D32 = the (MonoidalExtension of C94);
L349:
now
given C95 being multLoopStr such that
L350: C94 = C95;

take D33 = C95;
thus L351: H2(D33) c= H2(C94) by L350;
thus L352: (for B111 being multLoopStr holds (C94 = B111 implies H3(D33) = H3(B111))) by L350;
end;
L353: ((ex B112 being multLoopStr st C94 = B112) or (for B113 being multLoopStr holds (C94 = B113 implies H3(D32) = H3(B113))));
L354: ( the multMagma of D32 ) = ( the multMagma of C94 ) by L279;
thus L355: thesis by L354 , L349 , L353;
end;
end;
registration
let C96 being multMagma;
cluster  strict for (MonoidalSubStr of C96);
existence
proof
set D34 = the (MonoidalSubStr of C96);
L357: H3(( the multLoopStr of D34 )) = H3(D34);
L358: (for B114 being multLoopStr holds (C96 = B114 implies H3(( the multLoopStr of D34 )) = H3(B114))) by L357 , L348;
L359: H2(( the multLoopStr of D34 )) c= H2(C96) by L348;
L360: ( the multLoopStr of D34 ) is (MonoidalSubStr of C96) by L359 , L358 , L348;
thus L361: thesis by L360;
end;
end;
registration
let C97 being non  empty multMagma;
cluster  strict non  empty for (MonoidalSubStr of C97);
existence
proof
per cases ;
suppose L363: C97 is multLoopStr;

reconsider D35 = C97 as multLoopStr by L363;
L364: (for B115 being multLoopStr holds (C97 = B115 implies ( 1. ( the multLoopStr of D35 ) ) = ( 1. B115 )));
reconsider D36 = ( the multLoopStr of D35 ) as (MonoidalSubStr of C97) by L364 , L348;
take D36;
thus L365: D36 is  strict;
thus L366: (the carrier of D36) is non  empty;
end;
suppose L367: (not C97 is multLoopStr);

set D37 = the  strict (MonoidalExtension of C97);
L368: (for B116 being multLoopStr holds (C97 = B116 implies ( 1. D37 ) = ( 1. B116 ))) by L367;
L369: ( the multMagma of D37 ) = ( the multMagma of C97 ) by L279;
reconsider D38 = D37 as (MonoidalSubStr of C97) by L369 , L368 , L348;
take D38;
thus L370: thesis;
end;
end;
end;
definition
let C98 being multLoopStr;
redefine mode MonoidalSubStr of C98
means :L373: ((the multF of it) c= (the multF of C98) & ( 1. it ) = ( 1. C98 ));
compatibility
proof
let C99 being multLoopStr;
thus L374: (C99 is (MonoidalSubStr of C98) implies (H2(C99) c= H2(C98) & H3(C99) = H3(C98)))
proof
assume L375: (H2(C99) c= H2(C98) & (for B117 being multLoopStr holds (C98 = B117 implies H3(C99) = H3(B117))));
thus L376: thesis by L375;
end;

assume L377: (H2(C99) c= H2(C98) & H3(C99) = H3(C98));
thus L378: (H2(C99) c= H2(C98) & (for B118 being multLoopStr holds (C98 = B118 implies H3(C99) = H3(B118)))) by L377;
end;
end;
registration
let C100 being  well-unital non  empty multLoopStr;
cluster  well-unital  associative  commutative  cancelable  idempotent  invertible  uniquely-decomposable  strict for non  empty non  empty non  empty non  empty (MonoidalSubStr of C100);
existence
proof
set D39 = H3(C100);
reconsider D40 = D39 as (Element of { D39 }) by TARSKI:def 1;
set D41 = the (BinOp of { D39 });
set D42 = multLoopStr (# { D39 } , D41 , D40 #);
L380: (D39 = ( D39 * D39 ) & ( dom H2(C100) ) = [: H1(C100) , H1(C100) :]) by L259 , FUNCT_2:def 1;
L381: (( [ D39 , D39 ] .--> D39 ) = ( { [ D39 , D39 ] } --> D39 ) & D41 = ( (D39 , D39) .--> D39 )) by L41;
L382: (( 1. D42 ) = ( 1. C100 ) & H2(D42) c= H2(C100)) by L381 , L380 , FUNCT_4:7;
reconsider D43 = D42 as non  empty (MonoidalSubStr of C100) by L382 , L373;
take D43;
L383:
now
let C101 being (Element of D43);
L384: C101 = D39 by TARSKI:def 1;
thus L385: (( H2(D43) . (H3(D43) , C101) ) = C101 & ( H2(D43) . (C101 , H3(D43)) ) = C101) by L384 , TARSKI:def 1;
end;
thus L386: H3(D43) is_a_unity_wrt H2(D43) by L383 , BINOP_1:3;
thus L387: (H2(D43) is  associative & H2(D43) is  commutative & H2(D43) is  cancelable & H2(D43) is  idempotent & H2(D43) is  invertible  uniquely-decomposable) by L41;
thus L388: thesis;
end;
end;
theorem
L390: (for B119 being multMagma holds (for B120 being (MonoidalSubStr of B119) holds B120 is (SubStr of B119)))
proof
let C102 being multMagma;
let C103 being (MonoidalSubStr of C102);
thus L391: H2(C103) c= H2(C102) by L348;
end;
definition
let C104 being multMagma;
let C105 being (MonoidalExtension of C104);
redefine mode SubStr of C105
 -> (SubStr of C104);
coherence
proof
let C106 being (SubStr of C105);
L392: ( the multMagma of C105 ) = ( the multMagma of C104 ) by L279;
thus L393: H2(C106) c= H2(C104) by L392 , L332;
end;
end;
definition
let C107 being multMagma;
let C108 being (SubStr of C107);
redefine mode SubStr of C108
 -> (SubStr of C107);
coherence
proof
let C109 being (SubStr of C108);
L395: (H2(C109) c= H2(C108) & H2(C108) c= H2(C107)) by L332;
thus L396: H2(C109) c= H2(C107) by L395 , XBOOLE_1:1;
end;
end;
definition
let C110 being multMagma;
let C111 being (MonoidalSubStr of C110);
redefine mode SubStr of C111
 -> (SubStr of C110);
coherence
proof
reconsider D44 = C111 as (SubStr of C110) by L390;
let C112 being (SubStr of C111);
L398: C112 is (SubStr of D44);
thus L399: thesis by L398;
end;
end;
definition
let C113 being multMagma;
let C114 being (MonoidalSubStr of C113);
redefine mode MonoidalSubStr of C114
 -> (MonoidalSubStr of C113);
coherence
proof
let C115 being (MonoidalSubStr of C114);
L401: H3(C115) = H3(C114) by L348;
L402: (H2(C115) c= H2(C114) & H2(C114) c= H2(C113)) by L348;
thus L403: (H2(C115) c= H2(C113) & (for B121 being multLoopStr holds (C113 = B121 implies H3(C115) = H3(B121)))) by L402 , L401 , L348 , XBOOLE_1:1;
end;
end;
theorem
L405: (for R5 being non  empty multMagma holds (for R12 being non  empty multLoopStr holds (R5 is (SubStr of R5) & R12 is (MonoidalSubStr of R12))))
proof
let R5 being non  empty multMagma;
let R12 being non  empty multLoopStr;
thus L406: H2(R5) c= H2(R5);
thus L407: H2(R12) c= H2(R12);
thus L408: thesis;
end;
theorem
L409: (for R5 being non  empty multMagma holds (for R13 being non  empty (SubStr of R5) holds (for R14 being non  empty (MonoidalSubStr of R5) holds ((the carrier of R13) c= (the carrier of R5) & (the carrier of R14) c= (the carrier of R5)))))
proof
let R5 being non  empty multMagma;
let R13 being non  empty (SubStr of R5);
let R14 being non  empty (MonoidalSubStr of R5);
L410: ( dom H2(R14) ) = [: H1(R14) , H1(R14) :] by FUNCT_2:def 1;
L411: ( dom H2(R5) ) = [: H1(R5) , H1(R5) :] by FUNCT_2:def 1;
L412: H2(R13) c= H2(R5) by L332;
L413: ( dom H2(R13) ) c= ( dom H2(R5) ) by L412 , GRFUNC_1:2;
L414: ( dom H2(R13) ) = [: H1(R13) , H1(R13) :] by FUNCT_2:def 1;
thus L415: H1(R13) c= H1(R5)
proof
let R1 being set;
assume L416: R1 in H1(R13);
L417: [ R1 , R1 ] in ( dom H2(R13) ) by L416 , L414 , ZFMISC_1:87;
thus L418: thesis by L417 , L413 , L411 , ZFMISC_1:87;
end;

let R1 being set;
L419: H2(R14) c= H2(R5) by L348;
L420: ( dom H2(R14) ) c= ( dom H2(R5) ) by L419 , GRFUNC_1:2;
assume L421: R1 in H1(R14);
L422: [ R1 , R1 ] in ( dom H2(R14) ) by L421 , L410 , ZFMISC_1:87;
thus L423: thesis by L422 , L420 , L411 , ZFMISC_1:87;
end;
theorem
L424: (for B122 being non  empty multMagma holds (for B123 being non  empty (SubStr of B122) holds (the multF of B123) = ( (the multF of B122) || (the carrier of B123) )))
proof
let C116 being non  empty multMagma;
let C117 being non  empty (SubStr of C116);
L425: (H2(C117) c= H2(C116) & ( dom H2(C117) ) = [: H1(C117) , H1(C117) :]) by L332 , FUNCT_2:def 1;
thus L426: thesis by L425 , GRFUNC_1:23;
end;
theorem
L427: (for R5 being non  empty multMagma holds (for R13 being non  empty (SubStr of R5) holds (for B124 , B125 being (Element of R13) holds (for B126 , B127 being (Element of R5) holds ((B124 = B126 & B125 = B127) implies ( B124 * B125 ) = ( B126 * B127 ))))))
proof
let R5 being non  empty multMagma;
let R13 being non  empty (SubStr of R5);
let C118 , C119 being (Element of R13);
let C120 , C121 being (Element of R5);
assume that
L428: (C118 = C120 & C119 = C121);
L429: (( dom H2(R13) ) = [: H1(R13) , H1(R13) :] & H2(R13) c= H2(R5)) by L332 , FUNCT_2:def 1;
thus L430: ( C118 * C119 ) = ( H2(R13) . [ C118 , C119 ] )
.= ( C120 * C121 ) by L428 , L429 , GRFUNC_1:2;
end;
theorem
L431: (for R5 being non  empty multMagma holds (for B128 , B129 being non  empty (SubStr of R5) holds ((the carrier of B128) = (the carrier of B129) implies ( the multMagma of B128 ) = ( the multMagma of B129 ))))
proof
let R5 being non  empty multMagma;
let C122 , C123 being non  empty (SubStr of R5);
L432: H2(C123) c= H2(R5) by L332;
L433: (H2(C122) c= H2(R5) & ( dom H2(C122) ) = [: H1(C122) , H1(C122) :]) by L332 , FUNCT_2:def 1;
L434: H2(C122) = ( H2(R5) || H1(C122) ) by L433 , GRFUNC_1:23;
assume L435: H1(C122) = H1(C123);
L436: ( dom H2(C123) ) = [: H1(C122) , H1(C122) :] by L435 , FUNCT_2:def 1;
thus L437: thesis by L436 , L435 , L432 , L434 , GRFUNC_1:23;
end;
theorem
L438: (for R12 being non  empty multLoopStr holds (for B130 , B131 being non  empty (MonoidalSubStr of R12) holds ((the carrier of B130) = (the carrier of B131) implies ( the multLoopStr of B130 ) = ( the multLoopStr of B131 ))))
proof
let R12 being non  empty multLoopStr;
let C124 , C125 being non  empty (MonoidalSubStr of R12);
assume that
L439: (the carrier of C124) = (the carrier of C125);
reconsider D45 = C124 , D46 = C125 as (SubStr of R12) by L390;
L440: (H3(C124) = H3(R12) & H3(C125) = H3(R12)) by L373;
L441: ( the multMagma of D45 ) = ( the multMagma of D46 ) by L439 , L431;
thus L442: thesis by L441 , L440;
end;
theorem
L443: (for R5 being non  empty multMagma holds (for B132 , B133 being non  empty (SubStr of R5) holds ((the carrier of B132) c= (the carrier of B133) implies B132 is (SubStr of B133))))
proof
let R5 being non  empty multMagma;
let C126 , C127 being non  empty (SubStr of R5);
assume L444: H1(C126) c= H1(C127);
L445: [: H1(C126) , H1(C126) :] c= [: H1(C127) , H1(C127) :] by L444 , ZFMISC_1:96;
L446: ( ( H2(R5) || H1(C127) ) || H1(C126) ) = ( H2(R5) || H1(C126) ) by L445 , FUNCT_1:51;
L447: (H2(C127) c= H2(R5) & ( dom H2(C127) ) = [: H1(C127) , H1(C127) :]) by L332 , FUNCT_2:def 1;
L448: H2(C127) = ( H2(R5) || H1(C127) ) by L447 , GRFUNC_1:23;
L449: (H2(C126) c= H2(R5) & ( dom H2(C126) ) = [: H1(C126) , H1(C126) :]) by L332 , FUNCT_2:def 1;
L450: H2(C126) = ( H2(R5) || H1(C126) ) by L449 , GRFUNC_1:23;
thus L451: H2(C126) c= H2(C127) by L450 , L446 , L448 , RELAT_1:59;
end;
theorem
L452: (for R12 being non  empty multLoopStr holds (for B134 , B135 being non  empty (MonoidalSubStr of R12) holds ((the carrier of B134) c= (the carrier of B135) implies B134 is (MonoidalSubStr of B135))))
proof
let R12 being non  empty multLoopStr;
let C128 , C129 being non  empty (MonoidalSubStr of R12);
assume that
L453: H1(C128) c= H1(C129);
L454: (C128 is (SubStr of R12) & C129 is (SubStr of R12)) by L390;
L455: C128 is (SubStr of C129) by L454 , L453 , L443;
thus L456: H2(C128) c= H2(C129) by L455 , L332;
L457: H3(C128) = H3(R12) by L373;
thus L458: thesis by L457 , L373;
end;
theorem
L459: (for R5 being non  empty multMagma holds (for R13 being non  empty (SubStr of R5) holds ((R5 is  unital & ( the_unity_wrt (the multF of R5) ) in (the carrier of R13)) implies (R13 is  unital & ( the_unity_wrt (the multF of R5) ) = ( the_unity_wrt (the multF of R13) )))))
proof
let R5 being non  empty multMagma;
let R13 being non  empty (SubStr of R5);
set D47 = ( the_unity_wrt H2(R5) );
assume L460: R5 is  unital;
L461: D47 is_a_unity_wrt H2(R5) by L460 , L86;
assume L462: ( the_unity_wrt H2(R5) ) in H1(R13);
reconsider D48 = ( the_unity_wrt H2(R5) ) as (Element of R13) by L462;
L463:
now
let C130 being (Element of R13);
L464: H1(R13) c= H1(R5) by L409;
reconsider D49 = C130 as (Element of R5) by L464 , TARSKI:def 3;
thus L465: ( D48 * C130 ) = ( D47 * D49 ) by L427
.= C130 by L461 , BINOP_1:3;
thus L466: ( C130 * D48 ) = ( D49 * D47 ) by L427
.= C130 by L461 , BINOP_1:3;
end;
thus L467: R13 is  unital by L463 , L100;
L468:
now
let C131 being (Element of R13);
L469: (( D48 * C131 ) = ( H2(R13) . (D48 , C131) ) & ( C131 * D48 ) = ( H2(R13) . (C131 , D48) ));
thus L470: (( H2(R13) . (D48 , C131) ) = C131 & ( H2(R13) . (C131 , D48) ) = C131) by L469 , L463;
end;
L471: D48 is_a_unity_wrt H2(R13) by L468 , BINOP_1:3;
thus L472: thesis by L471 , BINOP_1:def 8;
end;
theorem
L473: (for B136 being  well-unital non  empty multLoopStr holds (for B137 being non  empty (MonoidalSubStr of B136) holds B137 is  well-unital))
proof
let C132 being  well-unital non  empty multLoopStr;
let C133 being non  empty (MonoidalSubStr of C132);
L474: H3(C132) is_a_unity_wrt H2(C132) by L247;
L475: (C133 is (SubStr of C132) & H3(C133) = H3(C132)) by L348 , L390;
L476:
now
let C134 being (Element of C133);
L477: H1(C133) c= H1(C132) by L409;
reconsider D50 = C134 as (Element of C132) by L477 , TARSKI:def 3;
thus L478: ( H2(C133) . (H3(C133) , C134) ) = ( H3(C133) * C134 )
.= ( H3(C132) * D50 ) by L475 , L427
.= C134 by L474 , BINOP_1:3;
thus L479: ( H2(C133) . (C134 , H3(C133)) ) = ( C134 * H3(C133) )
.= ( D50 * H3(C132) ) by L475 , L427
.= C134 by L474 , BINOP_1:3;
end;
thus L480: H3(C133) is_a_unity_wrt H2(C133) by L476 , BINOP_1:3;
end;
theorem
L481: (for R5 being non  empty multMagma holds (for R13 being non  empty (SubStr of R5) holds (R5 is  commutative implies R13 is  commutative)))
proof
let R5 being non  empty multMagma;
let R13 being non  empty (SubStr of R5);
assume L482: R5 is  commutative;
L483:
now
let C135 , C136 being (Element of R13);
L484: H1(R13) c= H1(R5) by L409;
reconsider D51 = C135 , D52 = C136 as (Element of R5) by L484 , TARSKI:def 3;
thus L485: ( C135 * C136 ) = ( D51 * D52 ) by L427
.= ( D52 * D51 ) by L482 , L111
.= ( C136 * C135 ) by L427;
end;
thus L486: thesis by L483 , L111;
end;
theorem
L487: (for R5 being non  empty multMagma holds (for R13 being non  empty (SubStr of R5) holds (R5 is  associative implies R13 is  associative)))
proof
let R5 being non  empty multMagma;
let R13 being non  empty (SubStr of R5);
assume L488: R5 is  associative;
L489:
now
let C137 , C138 , C139 being (Element of R13);
L490: H1(R13) c= H1(R5) by L409;
reconsider D53 = C137 , D54 = C138 , D55 = C139 , D56 = ( C137 * C138 ) , D57 = ( C138 * C139 ) as (Element of R5) by L490 , TARSKI:def 3;
thus L491: ( ( C137 * C138 ) * C139 ) = ( D56 * D55 ) by L427
.= ( ( D53 * D54 ) * D55 ) by L427
.= ( D53 * ( D54 * D55 ) ) by L488 , L118
.= ( D53 * D57 ) by L427
.= ( C137 * ( C138 * C139 ) ) by L427;
end;
thus L492: thesis by L489 , L118;
end;
theorem
L493: (for R5 being non  empty multMagma holds (for R13 being non  empty (SubStr of R5) holds (R5 is  idempotent implies R13 is  idempotent)))
proof
let R5 being non  empty multMagma;
let R13 being non  empty (SubStr of R5);
assume L494: R5 is  idempotent;
L495: H1(R13) c= H1(R5) by L409;
L496:
now
let C140 being (Element of R13);
reconsider D58 = C140 as (Element of R5) by L495 , TARSKI:def 3;
thus L497: ( C140 * C140 ) = ( D58 * D58 ) by L427
.= C140 by L494 , L125;
end;
thus L498: thesis by L496 , L125;
end;
theorem
L499: (for R5 being non  empty multMagma holds (for R13 being non  empty (SubStr of R5) holds (R5 is  cancelable implies R13 is  cancelable)))
proof
let R5 being non  empty multMagma;
let R13 being non  empty (SubStr of R5);
assume L500: R5 is  cancelable;
L501: H1(R13) c= H1(R5) by L409;
L502:
now
let C141 , C142 , C143 being (Element of R13);
reconsider D59 = C141 , D60 = C142 , D61 = C143 as (Element of R5) by L501 , TARSKI:def 3;
L503: (( C142 * C141 ) = ( D60 * D59 ) & ( C143 * C141 ) = ( D61 * D59 )) by L427;
L504: (( C141 * C142 ) = ( D59 * D60 ) & ( C141 * C143 ) = ( D59 * D61 )) by L427;
thus L505: ((( C141 * C142 ) = ( C141 * C143 ) or ( C142 * C141 ) = ( C143 * C141 )) implies C142 = C143) by L504 , L500 , L503 , L169;
end;
thus L506: thesis by L502 , L169;
end;
theorem
L507: (for R5 being non  empty multMagma holds (for R13 being non  empty (SubStr of R5) holds ((( the_unity_wrt (the multF of R5) ) in (the carrier of R13) & R5 is  uniquely-decomposable) implies R13 is  uniquely-decomposable)))
proof
let R5 being non  empty multMagma;
let R13 being non  empty (SubStr of R5);
assume L508: ( the_unity_wrt H2(R5) ) in H1(R13);
assume that
L509: H2(R5) is  having_a_unity
and
L510: (for B138 , B139 being (Element of R5) holds (( H2(R5) . (B138 , B139) ) = ( the_unity_wrt H2(R5) ) implies (B138 = B139 & B139 = ( the_unity_wrt H2(R5) ))));
L511: R5 is  unital by L509 , L62;
L512: R13 is  unital by L511 , L508 , L459;
thus L513: H2(R13) is  having_a_unity by L512;
let C144 , C145 being (Element of R13);
L514: H1(R13) c= H1(R5) by L409;
reconsider D62 = C144 , D63 = C145 as (Element of R5) by L514 , TARSKI:def 3;
L515: ( H2(R13) . (C144 , C145) ) = ( C144 * C145 )
.= ( D62 * D63 ) by L427
.= ( H2(R5) . (D62 , D63) );
L516: ( the_unity_wrt H2(R5) ) = ( the_unity_wrt H2(R13) ) by L508 , L511 , L459;
thus L517: thesis by L516 , L510 , L515;
end;
theorem
L518: (for B140 being  well-unital  uniquely-decomposable non  empty multLoopStr holds (for B141 being non  empty (MonoidalSubStr of B140) holds B141 is  uniquely-decomposable))
proof
let C146 being  well-unital  uniquely-decomposable non  empty multLoopStr;
let C147 being non  empty (MonoidalSubStr of C146);
L519: H3(C146) = H3(C147) by L373;
L520: (C147 is (SubStr of C146) & H3(C146) = ( the_unity_wrt H2(C146) )) by L267 , L390;
thus L521: thesis by L520 , L519 , L507;
end;
registration
let C148 being  constituted-Functions non  empty multMagma;
cluster  ->  constituted-Functions for non  empty non  empty non  empty non  empty (SubStr of C148);
coherence
proof
let C149 being non  empty (SubStr of C148);
let C150 being (Element of C149);
L522: H1(C149) c= H1(C148) by L409;
L523: C150 is (Element of C148) by L522 , TARSKI:def 3;
thus L524: thesis by L523;
end;
cluster  ->  constituted-Functions for non  empty non  empty non  empty non  empty (MonoidalSubStr of C148);
coherence
proof
let C151 being non  empty (MonoidalSubStr of C148);
let C152 being (Element of C151);
L525: H1(C151) c= H1(C148) by L409;
L526: C152 is (Element of C148) by L525 , TARSKI:def 3;
thus L527: thesis by L526;
end;
end;
registration
let C153 being  constituted-FinSeqs non  empty multMagma;
cluster  ->  constituted-FinSeqs for non  empty non  empty non  empty non  empty (SubStr of C153);
coherence
proof
let C154 being non  empty (SubStr of C153);
let C155 being (Element of C154);
L529: H1(C154) c= H1(C153) by L409;
L530: C155 is (Element of C153) by L529 , TARSKI:def 3;
thus L531: thesis by L530;
end;
cluster  ->  constituted-FinSeqs for non  empty non  empty non  empty non  empty (MonoidalSubStr of C153);
coherence
proof
let C156 being non  empty (MonoidalSubStr of C153);
let C157 being (Element of C156);
L532: H1(C156) c= H1(C153) by L409;
L533: C157 is (Element of C153) by L532 , TARSKI:def 3;
thus L534: thesis by L533;
end;
end;
registration
let C158 being  well-unital non  empty multLoopStr;
cluster  ->  well-unital for non  empty non  empty non  empty non  empty (MonoidalSubStr of C158);
coherence by L473;
end;
registration
let C159 being  commutative non  empty multMagma;
cluster  ->  commutative for non  empty non  empty non  empty non  empty (SubStr of C159);
coherence by L481;
cluster  ->  commutative for non  empty non  empty non  empty non  empty (MonoidalSubStr of C159);
coherence
proof
let C160 being non  empty (MonoidalSubStr of C159);
L537: C160 is (SubStr of C159) by L390;
thus L538: thesis by L537;
end;
end;
registration
let C161 being  associative non  empty multMagma;
cluster  ->  associative for non  empty non  empty non  empty non  empty (SubStr of C161);
coherence by L487;
cluster  ->  associative for non  empty non  empty non  empty non  empty (MonoidalSubStr of C161);
coherence
proof
let C162 being non  empty (MonoidalSubStr of C161);
L540: C162 is (SubStr of C161) by L390;
thus L541: thesis by L540;
end;
end;
registration
let C163 being  idempotent non  empty multMagma;
cluster  ->  idempotent for non  empty non  empty non  empty non  empty (SubStr of C163);
coherence by L493;
cluster  ->  idempotent for non  empty non  empty non  empty non  empty (MonoidalSubStr of C163);
coherence
proof
let C164 being non  empty (MonoidalSubStr of C163);
L543: C164 is (SubStr of C163) by L390;
thus L544: thesis by L543;
end;
end;
registration
let C165 being  cancelable non  empty multMagma;
cluster  ->  cancelable for non  empty non  empty non  empty non  empty (SubStr of C165);
coherence by L499;
cluster  ->  cancelable for non  empty non  empty non  empty non  empty (MonoidalSubStr of C165);
coherence
proof
let C166 being non  empty (MonoidalSubStr of C165);
L546: C166 is (SubStr of C165) by L390;
thus L547: thesis by L546;
end;
end;
registration
let C167 being  well-unital  uniquely-decomposable non  empty multLoopStr;
cluster  ->  uniquely-decomposable for non  empty non  empty non  empty non  empty (MonoidalSubStr of C167);
coherence by L518;
end;
L550:
now
let C168 being non  empty multMagma;
let C169 being non  empty (Subset of C168);
assume L551: (for B142 , B143 being (Element of C169) holds ( B142 * B143 ) in C169);
thus L552: (ex B144 being  strict non  empty (SubStr of C168) st (the carrier of B144) = C169)
proof
set D64 = (the multF of C168);
set D65 = (the carrier of C168);
L553: ( dom D64 ) = [: D65 , D65 :] by FUNCT_2:def 1;
L554: ( rng ( D64 || C169 ) ) c= C169
proof
let R1 being set;
assume L555: R1 in ( rng ( D64 || C169 ) );
consider R2 being set such that L556: R2 in ( dom ( D64 || C169 ) ) and L557: R1 = ( ( D64 || C169 ) . R2 ) by L555 , FUNCT_1:def 3;
reconsider D66 = R2 as (Element of [: C169 , C169 :]) by L553 , L556 , RELAT_1:62;
reconsider D67 = ( D66 `1 ) , D68 = ( D66 `2 ) as (Element of C169);
L558: D66 = [ D67 , D68 ] by MCART_1:21;
L559: R1 = ( D67 * D68 ) by L558 , L556 , L557 , FUNCT_1:47;
thus L560: thesis by L559 , L551;
end;
L561: ( dom ( D64 || C169 ) ) = [: C169 , C169 :] by L553 , RELAT_1:62;
reconsider D69 = ( D64 || C169 ) as (BinOp of C169) by L561 , L554 , FUNCT_2:def 1 , RELSET_1:4;
L562: D69 c= D64 by RELAT_1:59;
reconsider D70 = multMagma (# C169 , D69 #) as  strict non  empty (SubStr of C168) by L562 , L332;
take D70;
thus L563: thesis;
end;

end;
scheme SubStrEx2 { F1() -> non  empty multMagma , P1[set] } : (ex B145 being  strict non  empty (SubStr of F1()) st (for B146 being (Element of F1()) holds (B146 in (the carrier of B145) iff P1[ B146 ])))
provided
L553: (for B147 , B148 being (Element of F1()) holds ((P1[ B147 ] & P1[ B148 ]) implies P1[ ( B147 * B148 ) ]))
and
L554: (ex B149 being (Element of F1()) st P1[ B149 ])
proof
consider R3 being set such that L555: (for R1 being set holds (R1 in R3 iff (R1 in H1(F1()) & P1[ R1 ]))) from XBOOLE_0:sch 1;
reconsider D71 = R3 as non  empty set by L554 , L555;
L556: D71 c= H1(F1())
proof
let R1 being set;
thus L557: thesis by L555;
end;
reconsider D72 = D71 as non  empty (Subset of F1()) by L556;
L558:
now
let C170 , C171 being (Element of D72);
L559: (P1[ C170 ] & P1[ C171 ]) by L555;
L560: P1[ ( C170 * C171 ) ] by L559 , L553;
thus L561: ( C170 * C171 ) in D72 by L560 , L555;
end;
consider C172 being  strict non  empty (SubStr of F1()) such that L562: (the carrier of C172) = D72 by L550 , L558;
take C172;
thus L563: thesis by L555 , L562;
end;
scheme MonoidalSubStrEx2 { F2() -> non  empty multLoopStr , P2[set] } : (ex B150 being  strict non  empty (MonoidalSubStr of F2()) st (for B151 being (Element of F2()) holds (B151 in (the carrier of B150) iff P2[ B151 ])))
provided
L564: (for B152 , B153 being (Element of F2()) holds ((P2[ B152 ] & P2[ B153 ]) implies P2[ ( B152 * B153 ) ]))
and
L565: P2[ ( 1. F2() ) ]
proof
reconsider D73 = F2() as non  empty multMagma;
L566: (ex B154 being (Element of D73) st P2[ B154 ]) by L565;
L567: (for B155 , B156 being (Element of D73) holds ((P2[ B155 ] & P2[ B156 ]) implies P2[ ( B155 * B156 ) ])) by L564;
consider C173 being  strict non  empty (SubStr of D73) such that L568: (for B157 being (Element of D73) holds (B157 in (the carrier of C173) iff P2[ B157 ])) from SubStrEx2(L567 , L566);
reconsider D74 = ( 1. F2() ) as (Element of C173) by L565 , L568;
set D75 = multLoopStr (# H1(C173) , H2(C173) , D74 #);
L569: (( 1. F2() ) = ( 1. D75 ) & (the multF of C173) c= (the multF of F2())) by L332;
reconsider D76 = D75 as  strict non  empty (MonoidalSubStr of F2()) by L569 , L373;
take D76;
thus L570: thesis by L568;
end;
notation
let C174 being multMagma;
let C175 , C176 being (Element of C174);
synonym C175 [*] C176 for C175 * C176;
end;
begin
definition
func <REAL,+> -> non  empty multMagma equals 
multMagma (# ( REAL ) , ( addreal ) #);
coherence;
end;
registration
cluster ( <REAL,+> ) ->  unital  associative  invertible  commutative  cancelable  strict;
coherence by GROUP_1:46;
end;
theorem
L574: (for R1 being set holds (R1 is (Element of ( <REAL,+> )) iff R1 is Real));
theorem
L575: (for B158 being non  empty (SubStr of ( <REAL,+> )) holds (for B159 , B160 being (Element of B158) holds (for B161 , B162 being Real holds ((B159 = B161 & B160 = B162) implies ( B159 * B160 ) = ( B161 + B162 )))))
proof
let C177 being non  empty (SubStr of ( <REAL,+> ));
let C178 , C179 being (Element of C177);
L576: H1(C177) c= H1(( <REAL,+> )) by L409;
reconsider D77 = C178 , D78 = C179 as (Element of ( <REAL,+> )) by L576 , TARSKI:def 3;
L577: ( C178 * C179 ) = ( D77 * D78 ) by L427;
thus L578: thesis by L577 , BINOP_2:def 9;
end;
theorem
L579: (for B163 being  unital non  empty (SubStr of ( <REAL,+> )) holds ( the_unity_wrt (the multF of B163) ) = ( 0 ))
proof
let C180 being  unital non  empty (SubStr of ( <REAL,+> ));
consider C181 being (Element of C180) such that L580: (for B164 being (Element of C180) holds (( C181 * B164 ) = B164 & ( B164 * C181 ) = B164)) by L100;
L581: H1(C180) c= ( REAL ) by L409;
reconsider D79 = C181 as Real by L581 , TARSKI:def 3;
L582:
now
let C182 being (Element of C180);
L583: (( C181 * C182 ) = ( H2(C180) . (C181 , C182) ) & ( C182 * C181 ) = ( H2(C180) . (C182 , C181) ));
thus L584: (( H2(C180) . (C181 , C182) ) = C182 & ( H2(C180) . (C182 , C181) ) = C182) by L583 , L580;
end;
L585: C181 is_a_unity_wrt H2(C180) by L582 , BINOP_1:3;
L586: ( D79 + ( 0 ) ) = ( C181 * C181 ) by L580
.= ( D79 + D79 ) by L575;
thus L587: thesis by L586 , L585 , BINOP_1:def 8;
end;
registration
let C183 being  unital non  empty multMagma;
cluster  associative  invertible ->  unital  cancelable  Group-like for non  empty non  empty non  empty non  empty (SubStr of C183);
coherence;
end;
definition
redefine func INT.Group ->  strict non  empty (SubStr of ( <REAL,+> ));

coherence
proof
L589: ( dom ( addreal ) ) = [: ( REAL ) , ( REAL ) :] by FUNCT_2:def 1;
L590: ( dom ( ( addreal ) || ( INT ) ) ) = [: ( INT ) , ( INT ) :] by L589 , NUMBERS:15 , RELAT_1:62 , ZFMISC_1:96;
L591:
now
let R1 being set;
assume L592: R1 in [: ( INT ) , ( INT ) :];
L593: R1 = [ ( R1 `1 ) , ( R1 `2 ) ] by L592 , MCART_1:21;
reconsider D80 = ( R1 `1 ) , D81 = ( R1 `2 ) as (Element of ( INT )) by L592 , MCART_1:10;
thus L594: ( ( addint ) . R1 ) = ( ( addint ) . (D80 , D81) ) by L592 , MCART_1:21
.= ( ( addreal ) . (D80 , D81) ) by GR_CY_1:def 1
.= ( ( ( addreal ) || ( INT ) ) . R1 ) by L590 , L592 , L593 , FUNCT_1:47;
end;
L595: ( dom ( addint ) ) = [: ( INT ) , ( INT ) :] by FUNCT_2:def 1;
L596: ( addint ) = ( ( addreal ) || ( INT ) ) by L595 , L590 , L591 , FUNCT_1:2;
L597: H2(( INT.Group )) c= H2(( <REAL,+> )) by L596 , GR_CY_1:def 3 , RELAT_1:59;
thus L598: thesis by L597 , L332;
end;
end;
theorem
L600: (for B165 being  strict non  empty (SubStr of ( <REAL,+> )) holds (B165 = ( INT.Group ) iff (the carrier of B165) = ( INT ))) by L431 , GR_CY_1:def 3;
theorem
L601: (for R1 being set holds (R1 is (Element of ( INT.Group )) iff R1 is Integer)) by GR_CY_1:def 3 , INT_1:def 2;
definition
func <NAT,+> ->  unital  uniquely-decomposable  strict non  empty (SubStr of ( INT.Group )) means 
:L602: (the carrier of it) = ( NAT );
existence
proof
set D82 = ( ( addint ) || ( NAT ) );
L603: ( dom ( addint ) ) = [: ( INT ) , ( INT ) :] by FUNCT_2:def 1;
L604: ( dom D82 ) = [: ( NAT ) , ( NAT ) :] by L603 , NUMBERS:17 , RELAT_1:62 , ZFMISC_1:96;
L605: ( rng D82 ) c= ( NAT )
proof
let R1 being set;
assume L606: R1 in ( rng D82 );
consider R2 being set such that L607: R2 in ( dom D82 ) and L608: R1 = ( D82 . R2 ) by L606 , FUNCT_1:def 3;
reconsider D83 = ( R2 `1 ) , D84 = ( R2 `2 ) as (Element of ( NAT )) by L604 , L607 , MCART_1:10;
reconsider D85 = D83 , D86 = D84 as Integer;
L609: R1 = ( ( addint ) . R2 ) by L607 , L608 , FUNCT_1:47
.= ( ( addint ) . (D85 , D86) ) by L604 , L607 , MCART_1:21
.= ( D83 + D84 ) by BINOP_2:def 20;
thus L610: thesis by L609;
end;
reconsider D87 = D82 as (BinOp of ( NAT )) by L605 , L604 , FUNCT_2:def 1 , RELSET_1:4;
L611: D87 c= H2(( INT.Group )) by GR_CY_1:def 3 , RELAT_1:59;
reconsider D88 = multMagma (# ( NAT ) , D87 #) as  strict non  empty (SubStr of ( INT.Group )) by L611 , L332;
reconsider D89 = ( 0 ) as (Element of D88);
L612:
now
let C184 being (Element of D88);
reconsider D90 = C184 as (Element of ( NAT ));
thus L613: ( D89 * C184 ) = ( ( 0 ) + D90 ) by L575
.= C184;
thus L614: ( C184 * D89 ) = ( D90 + ( 0 ) ) by L575
.= C184;
end;
L615:
now
let C185 being (Element of D88);
thus L616: ( H2(D88) . (D89 , C185) ) = ( D89 * C185 )
.= C185 by L612;
thus L617: ( H2(D88) . (C185 , D89) ) = ( C185 * D89 )
.= C185 by L612;
end;
L618: D89 is_a_unity_wrt H2(D88) by L615 , BINOP_1:3;
L619: ( the_unity_wrt H2(D88) ) = D89 by L618 , BINOP_1:def 8;
L620:
now
let C186 , C187 being (Element of D88);
assume that
L621: ( C186 * C187 ) = ( the_unity_wrt H2(D88) );
reconsider D91 = C186 , D92 = C187 as (Element of ( NAT ));
L622: ( C186 * C187 ) = ( D91 + D92 ) by L575;
L623: C186 = ( 0 ) by L622 , L619 , L621 , NAT_1:7;
thus L624: (C186 = C187 & C187 = ( the_unity_wrt H2(D88) )) by L623 , L618 , L621 , L622 , BINOP_1:def 8;
end;
L625: D88 is  unital by L612 , L100;
L626: D88 is  uniquely-decomposable by L625 , L620 , L177;
thus L627: thesis by L626 , L625;
end;
uniqueness by L431;
end;
definition
func <NAT,+,0> ->  well-unital  strict non  empty (MonoidalExtension of ( <NAT,+> )) means 
(not contradiction);
existence;
uniqueness by L328;
end;
definition
redefine func addnat equals 
(the multF of ( <NAT,+> ));
compatibility
proof
let C188 being (BinOp of ( NAT ));
L630: (the carrier of ( <NAT,+> )) = ( NAT ) by L602;
L631:
now
let C189 , C190 being (Element of ( NAT ));
thus L632: ( ( addnat ) . (C189 , C190) ) = ( C189 + C190 ) by BINOP_2:def 23
.= ( ( addint ) . (C189 , C190) ) by BINOP_2:def 20
.= ( ( ( addint ) || ( NAT ) ) . [ C189 , C190 ] ) by FUNCT_1:49
.= ( (the multF of ( <NAT,+> )) . (C189 , C190) ) by L630 , L424 , GR_CY_1:def 3;
end;
thus L633: thesis by L631 , L630 , BINOP_1:2;
end;
end;
theorem
L635: ( <NAT,+> ) = multMagma (# ( NAT ) , ( addnat ) #) by L602;
theorem
L636: (for R1 being set holds (R1 is (Element of ( <NAT,+,0> )) iff R1 is (Element of ( NAT ))))
proof
let R1 being set;
L637: H1(( <NAT,+,0> )) = H1(( <NAT,+> )) by L285
.= ( NAT ) by L602;
thus L638: thesis by L637;
end;
theorem
L639: (for B166 , B167 being (Element of ( NAT )) holds (for B168 , B169 being (Element of ( <NAT,+,0> )) holds ((B166 = B168 & B167 = B169) implies ( B168 * B169 ) = ( B166 + B167 ))))
proof
L640: H2(( <NAT,+,0> )) = H2(( <NAT,+> )) by L285;
L641: ( <NAT,+,0> ) is (SubStr of (( <NAT,+> ) qua (SubStr of ( <REAL,+> )))) by L640 , L332;
thus L642: thesis by L641 , L575;
end;
theorem
L643: ( <NAT,+,0> ) = multLoopStr (# ( NAT ) , ( addnat ) , ( 0 ) #)
proof
set D93 = ( <NAT,+,0> );
L644: (( the multMagma of D93 ) = ( <NAT,+> ) & ( the_unity_wrt H2(D93) ) = H3(D93)) by L279 , L267;
thus L645: thesis by L644 , L579 , L635;
end;
theorem
L646: (( addnat ) = ( ( addreal ) || ( NAT ) ) & ( addnat ) = ( ( addint ) || ( NAT ) ))
proof
L647: H1(( <NAT,+> )) = ( NAT ) by L602;
thus L648: thesis by L647 , L424 , GR_CY_1:def 3;
end;
theorem
L649: (( 0 ) is_a_unity_wrt ( addnat ) & ( addnat ) is  uniquely-decomposable)
proof
L650: (( the_unity_wrt ( addnat ) ) = ( 0 ) & (ex B170 being (Element of ( NAT )) st B170 is_a_unity_wrt ( addnat ))) by L579 , L635 , SETWISEO:def 2;
thus L651: ( 0 ) is_a_unity_wrt ( addnat ) by L650 , BINOP_1:def 8;
thus L652: thesis by L80 , L635;
end;
definition
func <REAL,*> ->  unital  commutative  associative  strict non  empty multMagma equals 
multMagma (# ( REAL ) , ( multreal ) #);
coherence by L62 , L67 , L74;
end;
theorem
L654: (for R1 being set holds (R1 is (Element of ( <REAL,*> )) iff R1 is Real));
theorem
L655: (for B171 being non  empty (SubStr of ( <REAL,*> )) holds (for B172 , B173 being (Element of B171) holds (for B174 , B175 being Real holds ((B172 = B174 & B173 = B175) implies ( B172 * B173 ) = ( B174 * B175 )))))
proof
let C191 being non  empty (SubStr of ( <REAL,*> ));
let C192 , C193 being (Element of C191);
L656: H1(C191) c= H1(( <REAL,*> )) by L409;
reconsider D94 = C192 , D95 = C193 as (Element of ( <REAL,*> )) by L656 , TARSKI:def 3;
L657: ( C192 * C193 ) = ( D94 * D95 ) by L427;
thus L658: thesis by L657 , BINOP_2:def 11;
end;
theorem
L659: (for B176 being  unital non  empty (SubStr of ( <REAL,*> )) holds (( the_unity_wrt (the multF of B176) ) = ( 0 ) or ( the_unity_wrt (the multF of B176) ) = 1))
proof
let C194 being  unital non  empty (SubStr of ( <REAL,*> ));
set D96 = ( the_unity_wrt H2(C194) );
L660: H1(C194) c= H1(( <REAL,*> )) by L409;
reconsider D97 = D96 as Real by L660 , TARSKI:def 3;
L661: D96 is_a_unity_wrt H2(C194) by L86;
L662: D96 = ( D96 * D96 ) by L661 , BINOP_1:3
.= ( D97 * D97 ) by L655;
L663: ( D97 * 1 ) = ( D97 * D97 ) by L662;
thus L664: thesis by L663 , XCMPLX_1:5;
end;
definition
func <NAT,*> ->  unital  uniquely-decomposable  strict non  empty (SubStr of ( <REAL,*> )) means 
:L665: (the carrier of it) = ( NAT );
existence
proof
set D98 = ( ( multreal ) || ( NAT ) );
L666: ( dom ( multreal ) ) = [: ( REAL ) , ( REAL ) :] by FUNCT_2:def 1;
L667: ( dom D98 ) = [: ( NAT ) , ( NAT ) :] by L666 , RELAT_1:62;
L668: ( rng D98 ) c= ( NAT )
proof
let R1 being set;
assume L669: R1 in ( rng D98 );
consider R2 being set such that L670: R2 in ( dom D98 ) and L671: R1 = ( D98 . R2 ) by L669 , FUNCT_1:def 3;
reconsider D99 = ( R2 `1 ) , D100 = ( R2 `2 ) as (Element of ( NAT )) by L667 , L670 , MCART_1:10;
L672: R1 = ( ( multreal ) . R2 ) by L670 , L671 , FUNCT_1:47
.= ( ( multreal ) . (D99 , D100) ) by L667 , L670 , MCART_1:21
.= ( D99 * D100 ) by BINOP_2:def 11;
thus L673: thesis by L672;
end;
reconsider D101 = D98 as (BinOp of ( NAT )) by L668 , L667 , FUNCT_2:def 1 , RELSET_1:4;
L674: D101 c= H2(( <REAL,*> )) by RELAT_1:59;
reconsider D102 = multMagma (# ( NAT ) , D101 #) as  strict non  empty (SubStr of ( <REAL,*> )) by L674 , L332;
reconsider D103 = 1 as (Element of D102);
L675:
now
let C195 being (Element of D102);
reconsider D104 = C195 as (Element of ( NAT ));
thus L676: ( D103 * C195 ) = ( 1 * D104 ) by L655
.= C195;
thus L677: ( C195 * D103 ) = ( D104 * 1 ) by L655
.= C195;
end;
L678:
now
let C196 being (Element of D102);
thus L679: ( H2(D102) . (D103 , C196) ) = ( D103 * C196 )
.= C196 by L675;
thus L680: ( H2(D102) . (C196 , D103) ) = ( C196 * D103 )
.= C196 by L675;
end;
L681: D103 is_a_unity_wrt H2(D102) by L678 , BINOP_1:3;
L682: ( the_unity_wrt H2(D102) ) = D103 by L681 , BINOP_1:def 8;
L683:
now
let C197 , C198 being (Element of D102);
assume that
L684: ( C197 * C198 ) = ( the_unity_wrt H2(D102) );
reconsider D105 = C197 , D106 = C198 as (Element of ( NAT ));
L685: ( C197 * C198 ) = ( D105 * D106 ) by L655;
L686: C197 = 1 by L685 , L682 , L684 , NAT_1:15;
thus L687: (C197 = C198 & C198 = ( the_unity_wrt H2(D102) )) by L686 , L681 , L684 , L685 , BINOP_1:def 8;
end;
L688: D102 is  unital by L675 , L100;
L689: D102 is  uniquely-decomposable by L688 , L683 , L177;
thus L690: thesis by L689 , L688;
end;
uniqueness by L431;
end;
definition
func <NAT,*,1> ->  well-unital  strict non  empty (MonoidalExtension of ( <NAT,*> )) means 
(not contradiction);
uniqueness by L328;
existence;
end;
definition
redefine func multnat equals 
(the multF of ( <NAT,*> ));
compatibility
proof
let C199 being (BinOp of ( NAT ));
L693: (the carrier of ( <NAT,*> )) = ( NAT ) by L665;
L694:
now
let C200 , C201 being (Element of ( NAT ));
thus L695: ( ( multnat ) . (C200 , C201) ) = ( C200 * C201 ) by BINOP_2:def 24
.= ( ( multreal ) . (C200 , C201) ) by BINOP_2:def 11
.= ( ( ( multreal ) || ( NAT ) ) . [ C200 , C201 ] ) by FUNCT_1:49
.= ( (the multF of ( <NAT,*> )) . (C200 , C201) ) by L693 , L424;
end;
thus L696: thesis by L694 , L693 , BINOP_1:2;
end;
end;
theorem
L698: ( <NAT,*> ) = multMagma (# ( NAT ) , ( multnat ) #) by L665;
theorem
L699: (for B177 , B178 being (Element of ( NAT )) holds (for B179 , B180 being (Element of ( <NAT,*> )) holds ((B177 = B179 & B178 = B180) implies ( B179 * B180 ) = ( B177 * B178 )))) by L655;
theorem
L700: ( the_unity_wrt (the multF of ( <NAT,*> )) ) = 1
proof
L701: H1(( <NAT,*> )) = ( NAT ) by L665;
thus L702: thesis by L701 , L459 , BINOP_2:7;
end;
theorem
L703: (for B181 , B182 being (Element of ( NAT )) holds (for B183 , B184 being (Element of ( <NAT,*,1> )) holds ((B181 = B183 & B182 = B184) implies ( B183 * B184 ) = ( B181 * B182 ))))
proof
let C202 , C203 being (Element of ( NAT ));
let C204 , C205 being (Element of ( <NAT,*,1> ));
L704: ( the multMagma of ( <NAT,*,1> ) ) = ( <NAT,*> ) by L279;
reconsider D107 = C204 , D108 = C205 as (Element of ( <NAT,*> )) by L704;
L705: ( D107 * D108 ) = ( C204 * C205 ) by L285;
thus L706: thesis by L705 , L655;
end;
theorem
L707: ( <NAT,*,1> ) = multLoopStr (# ( NAT ) , ( multnat ) , 1 #)
proof
set D109 = ( <NAT,*,1> );
L708: (( the multMagma of D109 ) = ( <NAT,*> ) & ( the_unity_wrt H2(D109) ) = H3(D109)) by L279 , L267;
thus L709: thesis by L708 , L665 , L700;
end;
theorem
L710: ( multnat ) = ( ( multreal ) || ( NAT ) ) by L424 , L698;
theorem
L711: (1 is_a_unity_wrt ( multnat ) & ( multnat ) is  uniquely-decomposable)
proof
L712: (ex B185 being (Element of ( NAT )) st B185 is_a_unity_wrt ( multnat )) by SETWISEO:def 2;
thus L713: 1 is_a_unity_wrt ( multnat ) by L712 , L698 , L700 , BINOP_1:def 8;
thus L714: thesis by L80 , L698;
end;
begin
definition
let C206 being non  empty set;
func C206 *+^ ->  unital  associative  cancelable  uniquely-decomposable  constituted-FinSeqs  strict non  empty multMagma means 
:L715: ((the carrier of it) = ( C206 * ) & (for B186 , B187 being (Element of it) holds ( B186 [*] B187 ) = ( B186 ^ B187 )));
existence
proof
deffunc H4((Element of ( C206 * )) , (Element of ( C206 * ))) = ( ($1 qua (Element of ( C206 * ))) ^ ($2 qua (Element of ( C206 * ))) );
consider C207 being (BinOp of ( C206 * )) such that L716: (for B188 , B189 being (Element of ( C206 * )) holds ( C207 . (B188 , B189) ) = H4(B188 , B189)) from BINOP_1:sch 4;
set D110 = multMagma (# ( C206 * ) , C207 #);
L717: D110 is  constituted-FinSeqs
proof
let C208 being (Element of D110);
thus L718: thesis;
end;
reconsider D111 = D110 as  constituted-FinSeqs  strict non  empty multMagma by L717;
L719: D111 is  unital  associative  cancelable  uniquely-decomposable
proof
set D112 = D111;
set D113 = H2(D112);
L720: ( <*> C206 ) = ( {} );
reconsider D114 = ( {} ) as (Element of D112) by L720 , FINSEQ_1:def 11;
L721:
now
let C209 being (Element of D112);
thus L722: ( D114 [*] C209 ) = ( D114 ^ C209 ) by L716
.= C209 by FINSEQ_1:34;
thus L723: ( C209 [*] D114 ) = ( C209 ^ D114 ) by L716
.= C209 by FINSEQ_1:34;
end;
thus L724: D112 is  unital by L721 , L100;
L725:
now
let C210 , C211 , C212 being (Element of D112);
reconsider D115 = ( C210 [*] C211 ) , D116 = ( C211 [*] C212 ) as (Element of D112);
thus L726: ( ( C210 * C211 ) * C212 ) = ( D115 ^ C212 ) by L716
.= ( ( C210 ^ C211 ) ^ C212 ) by L716
.= ( C210 ^ ( C211 ^ C212 ) ) by FINSEQ_1:32
.= ( C210 ^ D116 ) by L716
.= ( C210 * ( C211 * C212 ) ) by L716;
end;
thus L727: D112 is  associative by L725 , L118;
L728:
now
let C213 , C214 , C215 being (Element of D112);
L729: (( C214 * C213 ) = ( C214 ^ C213 ) & ( C215 * C213 ) = ( C215 ^ C213 )) by L716;
L730: (( C213 * C214 ) = ( C213 ^ C214 ) & ( C213 * C215 ) = ( C213 ^ C215 )) by L716;
thus L731: ((( C213 * C214 ) = ( C213 * C215 ) or ( C214 * C213 ) = ( C215 * C213 )) implies C214 = C215) by L730 , L729 , FINSEQ_1:33;
end;
thus L732: D112 is  cancelable by L728 , L169;
L733: D112 is  unital by L721 , L100;
thus L734: H2(D112) is  having_a_unity by L733;
let C216 , C217 being (Element of D112);
L735:
now
let C218 being (Element of D112);
L736: (( D114 [*] C218 ) = ( D113 . (D114 , C218) ) & ( C218 [*] D114 ) = ( D113 . (C218 , D114) ));
thus L737: (( D113 . (D114 , C218) ) = C218 & ( D113 . (C218 , D114) ) = C218) by L736 , L721;
end;
L738: D114 is_a_unity_wrt H2(D112) by L735 , BINOP_1:3;
assume L739: ( D113 . (C216 , C217) ) = ( the_unity_wrt H2(D112) );
L740: ( {} ) = ( C216 [*] C217 ) by L739 , L738 , BINOP_1:def 8
.= ( C216 ^ C217 ) by L716;
L741: D114 = C217 by L740;
thus L742: thesis by L741 , L738 , L740 , BINOP_1:def 8;
end;
reconsider D117 = D111 as  unital  associative  cancelable  uniquely-decomposable  constituted-FinSeqs  strict non  empty multMagma by L719;
take D117;
thus L743: thesis by L716;
end;
uniqueness
proof
let C219 , C220 being  unital  associative  cancelable  uniquely-decomposable  constituted-FinSeqs  strict non  empty multMagma;
assume that
L744: H1(C219) = ( C206 * )
and
L745: (for B190 , B191 being (Element of C219) holds ( B190 [*] B191 ) = ( B190 ^ B191 ))
and
L746: H1(C220) = ( C206 * )
and
L747: (for B192 , B193 being (Element of C220) holds ( B192 [*] B193 ) = ( B192 ^ B193 ));
set D118 = H2(C219);
set D119 = H2(C220);
L748:
now
let C221 , C222 being (Element of ( C206 * ));
reconsider D120 = C221 , D121 = C222 as (Element of C220) by L746;
reconsider D122 = C221 , D123 = C222 as (Element of C219) by L744;
reconsider D124 = C221 , D125 = C222 as (Element of ( C206 * ));
L749: (( D120 [*] D121 ) = ( D124 ^ D125 ) & ( D122 [*] D123 ) = ( D124 ^ D125 )) by L745 , L747;
thus L750: ( D118 . (C221 , C222) ) = ( D119 . (C221 , C222) ) by L749;
end;
thus L751: thesis by L748 , L744 , L746 , BINOP_1:2;
end;
end;
definition
let R6 being non  empty set;
func R6 *+^+<0> ->  well-unital  strict non  empty (MonoidalExtension of ( R6 *+^ )) means 
(not contradiction);
correctness by L328;
func R6 -concatenation -> (BinOp of ( R6 * )) equals 
(the multF of ( R6 *+^ ));
correctness
proof
L753: H1(( R6 *+^ )) = ( R6 * ) by L715;
thus L754: thesis by L753;
end;
end;
theorem
L756: (for R6 being non  empty set holds ( R6 *+^ ) = multMagma (# ( R6 * ) , ( R6 -concatenation ) #)) by L715;
theorem
L757: (for R6 being non  empty set holds ( the_unity_wrt (the multF of ( R6 *+^ )) ) = ( {} ))
proof
let R6 being non  empty set;
set D126 = ( R6 *+^ );
set D127 = H2(D126);
L758: (H1(D126) = ( R6 * ) & ( {} ) = ( <*> R6 )) by L715;
reconsider D128 = ( {} ) as (Element of D126) by L758 , FINSEQ_1:def 11;
L759:
now
let C223 being (Element of D126);
thus L760: ( D127 . (D128 , C223) ) = ( D128 [*] C223 )
.= ( ( {} ) ^ C223 ) by L715
.= C223 by FINSEQ_1:34;
thus L761: ( D127 . (C223 , D128) ) = ( C223 [*] D128 )
.= ( C223 ^ ( {} ) ) by L715
.= C223 by FINSEQ_1:34;
end;
L762: D128 is_a_unity_wrt H2(D126) by L759 , BINOP_1:3;
thus L763: thesis by L762 , BINOP_1:def 8;
end;
theorem
L764: (for R6 being non  empty set holds ((the carrier of ( R6 *+^+<0> )) = ( R6 * ) & (the multF of ( R6 *+^+<0> )) = ( R6 -concatenation ) & ( 1. ( R6 *+^+<0> ) ) = ( {} )))
proof
let R6 being non  empty set;
set D129 = ( R6 *+^+<0> );
L765: (( the multMagma of D129 ) = ( R6 *+^ ) & ( the_unity_wrt H2(D129) ) = H3(D129)) by L279 , L267;
thus L766: thesis by L765 , L715 , L757;
end;
theorem
L767: (for R6 being non  empty set holds (for B194 , B195 being (Element of ( R6 *+^+<0> )) holds ( B194 [*] B195 ) = ( B194 ^ B195 )))
proof
let R6 being non  empty set;
let C224 , C225 being (Element of ( R6 *+^+<0> ));
L768: ( the multMagma of ( R6 *+^+<0> ) ) = ( R6 *+^ ) by L279;
reconsider D130 = C224 , D131 = C225 as (Element of ( R6 *+^ )) by L768;
thus L769: ( C224 [*] C225 ) = ( D130 [*] D131 ) by L285
.= ( C224 ^ C225 ) by L715;
end;
theorem
L770: (for R6 being non  empty set holds (for B196 being non  empty (SubStr of ( R6 *+^ )) holds (for B197 , B198 being (Element of B196) holds ( B197 [*] B198 ) = ( B197 ^ B198 ))))
proof
let R6 being non  empty set;
let C226 being non  empty (SubStr of ( R6 *+^ ));
let C227 , C228 being (Element of C226);
L771: H1(C226) c= H1(( R6 *+^ )) by L409;
reconsider D132 = C227 , D133 = C228 as (Element of ( R6 *+^ )) by L771 , TARSKI:def 3;
thus L772: ( C227 [*] C228 ) = ( D132 [*] D133 ) by L427
.= ( C227 ^ C228 ) by L715;
end;
theorem
L773: (for R6 being non  empty set holds (for B199 being  unital non  empty (SubStr of ( R6 *+^ )) holds ( the_unity_wrt (the multF of B199) ) = ( {} )))
proof
let R6 being non  empty set;
let C229 being  unital non  empty (SubStr of ( R6 *+^ ));
set D134 = ( the_unity_wrt H2(C229) );
reconsider D135 = D134 as (Element of (C229 qua (SubStr of ( R6 *+^ ))));
L774: ( D135 ^ ( {} ) ) = D134 by FINSEQ_1:34
.= ( D134 [*] D134 ) by SETWISEO:15
.= ( D135 ^ D135 ) by L770;
thus L775: thesis by L774 , FINSEQ_1:33;
end;
theorem
L776: (for R6 being non  empty set holds (for B200 being non  empty (SubStr of ( R6 *+^ )) holds (( {} ) is (Element of B200) implies (B200 is  unital & ( the_unity_wrt (the multF of B200) ) = ( {} )))))
proof
let R6 being non  empty set;
let C230 being non  empty (SubStr of ( R6 *+^ ));
L777: ( the_unity_wrt H2(( R6 *+^ )) ) = ( {} ) by L757;
thus L778: thesis by L777 , L459;
end;
theorem
L779: (for B201 , B202 being non  empty set holds (B201 c= B202 implies ( B201 *+^ ) is (SubStr of ( B202 *+^ ))))
proof
let C231 , C232 being non  empty set;
L780: H1(( C231 *+^ )) = ( C231 * ) by L715;
L781: ( dom H2(( C231 *+^ )) ) = [: ( C231 * ) , ( C231 * ) :] by L780 , FUNCT_2:def 1;
L782: H1(( C232 *+^ )) = ( C232 * ) by L715;
L783: ( dom H2(( C232 *+^ )) ) = [: ( C232 * ) , ( C232 * ) :] by L782 , FUNCT_2:def 1;
assume L784: C231 c= C232;
L785: ( C231 * ) c= ( C232 * ) by L784 , FINSEQ_1:62;
L786:
now
let R1 being set;
assume L787: R1 in [: ( C231 * ) , ( C231 * ) :];
L788: (( R1 `1 ) in ( C231 * ) & ( R1 `2 ) in ( C231 * )) by L787 , MCART_1:10;
reconsider D136 = ( R1 `1 ) , D137 = ( R1 `2 ) as (Element of ( C231 *+^ )) by L788 , L715;
reconsider D138 = ( R1 `1 ) , D139 = ( R1 `2 ) as (Element of ( C232 *+^ )) by L785 , L788 , L715;
thus L789: ( H2(( C231 *+^ )) . R1 ) = ( D136 [*] D137 ) by L787 , MCART_1:21
.= ( D136 ^ D137 ) by L715
.= ( D138 [*] D139 ) by L715
.= ( H2(( C232 *+^ )) . R1 ) by L787 , MCART_1:21;
end;
L790: [: ( C231 * ) , ( C231 * ) :] c= [: ( C232 * ) , ( C232 * ) :] by L785 , ZFMISC_1:96;
thus L791: H2(( C231 *+^ )) c= H2(( C232 *+^ )) by L790 , L781 , L783 , L786 , GRFUNC_1:2;
end;
theorem
L792: (for R6 being non  empty set holds (( R6 -concatenation ) is  having_a_unity & ( the_unity_wrt ( R6 -concatenation ) ) = ( {} ) & ( R6 -concatenation ) is  associative))
proof
let R6 being non  empty set;
L793: multMagma (# ( R6 * ) , ( R6 -concatenation ) #) = ( R6 *+^ ) by L715;
thus L794: thesis by L793 , L757;
end;
begin
definition
let C233 being set;
func GPFuncs C233 ->  constituted-Functions  strict multMagma means 
:L795: ((the carrier of it) = ( PFuncs (C233 , C233) ) & (for B203 , B204 being (Element of it) holds ( B203 [*] B204 ) = ( B204 (*) B203 )));
existence
proof
reconsider D140 = ( id C233 ) as (PartFunc of C233 , C233);
set D141 = ( PFuncs (C233 , C233) );
defpred S2[ (Element of D141) , (Element of D141) , (Element of D141) ] means (ex B205 , B206 being (PartFunc of C233 , C233) st ($1 = B205 & $2 = B206 & $3 = ( B206 (*) B205 )));
L796: (for B207 , B208 being (Element of D141) holds (ex B209 being (Element of D141) st S2[ B207 , B208 , B209 ]))
proof
let C234 , C235 being (Element of D141);
reconsider D142 = C234 , D143 = C235 as (PartFunc of C233 , C233) by PARTFUN1:46;
reconsider D144 = ( D143 * D142 ) as (Element of D141) by PARTFUN1:45;
take D144;
take D142;
take D143;
thus L797: thesis;
end;
consider C236 being (BinOp of D141) such that L798: (for B210 , B211 being (Element of D141) holds S2[ B210 , B211 , ( C236 . (B210 , B211) ) ]) from BINOP_1:sch 3(L796);
set D145 = multMagma (# D141 , C236 #);
L799: D145 is  constituted-Functions
proof
let C237 being (Element of D145);
thus L800: thesis;
end;
reconsider D146 = D145 as  constituted-Functions  strict multMagma by L799;
take D146;
thus L801: H1(D146) = ( PFuncs (C233 , C233) );
let C238 , C239 being (Element of D146);
reconsider D147 = C238 , D148 = C239 as (Element of D141);
L802: (ex B212 , B213 being (PartFunc of C233 , C233) st (D147 = B212 & D148 = B213 & ( C236 . (D147 , D148) ) = ( B213 (*) B212 ))) by L798;
thus L803: thesis by L802;
end;
uniqueness
proof
let C240 , C241 being  constituted-Functions  strict multMagma;
assume that
L804: H1(C240) = ( PFuncs (C233 , C233) )
and
L805: (for B214 , B215 being (Element of C240) holds ( B214 [*] B215 ) = ( B215 (*) B214 ))
and
L806: H1(C241) = ( PFuncs (C233 , C233) )
and
L807: (for B216 , B217 being (Element of C241) holds ( B216 [*] B217 ) = ( B217 (*) B216 ));
set D149 = H2(C240);
set D150 = H2(C241);
L808:
now
let C242 , C243 being (Element of C240);
reconsider D151 = C242 , D152 = C243 as (Element of C241) by L804 , L806;
L809: (( C242 [*] C243 ) = ( C243 (*) C242 ) & ( D151 [*] D152 ) = ( D152 (*) D151 )) by L805 , L807;
thus L810: ( D149 . (C242 , C243) ) = ( D150 . (C242 , C243) ) by L809;
end;
thus L811: thesis by L808 , L804 , L806 , BINOP_1:2;
end;
end;
registration
let C244 being set;
cluster ( GPFuncs C244 ) ->  unital  associative non  empty;
coherence
proof
set D153 = ( GPFuncs C244 );
reconsider D154 = ( id C244 ) as (PartFunc of C244 , C244);
set D155 = ( PFuncs (C244 , C244) );
L813: (the carrier of ( GPFuncs C244 )) = D155 by L795;
L814:
now
let C245 , C246 , C247 being (Element of D153);
reconsider D156 = ( C245 [*] C246 ) , D157 = ( C246 [*] C247 ) as (Element of D153);
thus L815: ( ( C245 [*] C246 ) [*] C247 ) = ( C247 (*) D156 ) by L795
.= ( C247 (*) ( C246 (*) C245 ) ) by L795
.= ( ( C247 (*) C246 ) (*) C245 ) by RELAT_1:36
.= ( D157 (*) C245 ) by L795
.= ( C245 [*] ( C246 [*] C247 ) ) by L795;
end;
reconsider D158 = D154 as (Element of D153) by L813 , PARTFUN1:45;
L816:
now
let C248 being (Element of D153);
reconsider D159 = C248 as (PartFunc of C244 , C244) by L813 , PARTFUN1:46;
thus L817: ( D158 [*] C248 ) = ( D159 (*) D154 ) by L795
.= C248 by PARTFUN1:6;
thus L818: ( C248 [*] D158 ) = ( D154 (*) D159 ) by L795
.= C248 by PARTFUN1:7;
end;
thus L819: thesis by L816 , L813 , L814 , L118 , L100;
end;
end;
definition
let C249 being set;
func MPFuncs C249 ->  well-unital  strict non  empty (MonoidalExtension of ( GPFuncs C249 )) means 
(not contradiction);
existence;
uniqueness by L328;
func C249 -composition -> (BinOp of ( PFuncs (C249 , C249) )) equals 
(the multF of ( GPFuncs C249 ));
correctness
proof
L821: H1(( GPFuncs C249 )) = ( PFuncs (C249 , C249) ) by L795;
thus L822: thesis by L821;
end;
end;
theorem
L824: (for R1 being set holds (for R3 being set holds (R1 is (Element of ( GPFuncs R3 )) iff R1 is (PartFunc of R3 , R3))))
proof
let R1 being set;
let R3 being set;
L825: H1(( GPFuncs R3 )) = ( PFuncs (R3 , R3) ) by L795;
thus L826: thesis by L825 , PARTFUN1:45 , PARTFUN1:46;
end;
theorem
L827: (for R3 being set holds ( the_unity_wrt (the multF of ( GPFuncs R3 )) ) = ( id R3 ))
proof
let R3 being set;
reconsider D160 = ( id R3 ) as (PartFunc of R3 , R3);
set D161 = H2(( GPFuncs R3 ));
L828: H1(( GPFuncs R3 )) = ( PFuncs (R3 , R3) ) by L795;
reconsider D162 = D160 as (Element of ( GPFuncs R3 )) by L828 , PARTFUN1:45;
L829:
now
let C250 being (Element of ( GPFuncs R3 ));
reconsider D163 = C250 as (PartFunc of R3 , R3) by L828 , PARTFUN1:46;
thus L830: ( D161 . (D162 , C250) ) = ( D162 [*] C250 )
.= ( D163 (*) D160 ) by L795
.= C250 by PARTFUN1:6;
thus L831: ( D161 . (C250 , D162) ) = ( C250 [*] D162 )
.= ( D160 (*) D163 ) by L795
.= C250 by PARTFUN1:7;
end;
L832: D162 is_a_unity_wrt D161 by L829 , BINOP_1:3;
thus L833: thesis by L832 , BINOP_1:def 8;
end;
theorem
L834: (for R3 being set holds (for B218 being non  empty (SubStr of ( GPFuncs R3 )) holds (for B219 , B220 being (Element of B218) holds ( B219 [*] B220 ) = ( B220 (*) B219 ))))
proof
let R3 being set;
let C251 being non  empty (SubStr of ( GPFuncs R3 ));
let C252 , C253 being (Element of C251);
L835: H1(C251) c= H1(( GPFuncs R3 )) by L409;
reconsider D164 = C252 , D165 = C253 as (Element of ( GPFuncs R3 )) by L835 , TARSKI:def 3;
L836: ( C252 [*] C253 ) = ( D164 [*] D165 ) by L427;
thus L837: thesis by L836 , L795;
end;
theorem
L838: (for R3 being set holds (for B221 being non  empty (SubStr of ( GPFuncs R3 )) holds (( id R3 ) is (Element of B221) implies (B221 is  unital & ( the_unity_wrt (the multF of B221) ) = ( id R3 )))))
proof
let R3 being set;
let C254 being non  empty (SubStr of ( GPFuncs R3 ));
L839: ( the_unity_wrt H2(( GPFuncs R3 )) ) = ( id R3 ) by L827;
thus L840: thesis by L839 , L459;
end;
theorem
L841: (for R3 being set holds (for R4 being set holds (R4 c= R3 implies ( GPFuncs R4 ) is (SubStr of ( GPFuncs R3 )))))
proof
let R3 being set;
let R4 being set;
L842: H1(( GPFuncs R4 )) = ( PFuncs (R4 , R4) ) by L795;
L843: ( dom H2(( GPFuncs R4 )) ) = [: ( PFuncs (R4 , R4) ) , ( PFuncs (R4 , R4) ) :] by L842 , FUNCT_2:def 1;
L844: H1(( GPFuncs R3 )) = ( PFuncs (R3 , R3) ) by L795;
L845: ( dom H2(( GPFuncs R3 )) ) = [: ( PFuncs (R3 , R3) ) , ( PFuncs (R3 , R3) ) :] by L844 , FUNCT_2:def 1;
assume L846: R4 c= R3;
L847: ( PFuncs (R4 , R4) ) c= ( PFuncs (R3 , R3) ) by L846 , PARTFUN1:50;
L848:
now
let R1 being set;
assume L849: R1 in [: ( PFuncs (R4 , R4) ) , ( PFuncs (R4 , R4) ) :];
L850: (( R1 `1 ) in ( PFuncs (R4 , R4) ) & ( R1 `2 ) in ( PFuncs (R4 , R4) )) by L849 , MCART_1:10;
reconsider D166 = ( R1 `1 ) , D167 = ( R1 `2 ) as (Element of ( GPFuncs R4 )) by L850 , L795;
reconsider D168 = ( R1 `1 ) , D169 = ( R1 `2 ) as (Element of ( GPFuncs R3 )) by L847 , L850 , L795;
thus L851: ( H2(( GPFuncs R4 )) . R1 ) = ( D166 [*] D167 ) by L849 , MCART_1:21
.= ( D167 (*) D166 ) by L795
.= ( D168 [*] D169 ) by L795
.= ( H2(( GPFuncs R3 )) . R1 ) by L849 , MCART_1:21;
end;
L852: [: ( PFuncs (R4 , R4) ) , ( PFuncs (R4 , R4) ) :] c= [: ( PFuncs (R3 , R3) ) , ( PFuncs (R3 , R3) ) :] by L847 , ZFMISC_1:96;
thus L853: H2(( GPFuncs R4 )) c= H2(( GPFuncs R3 )) by L852 , L843 , L845 , L848 , GRFUNC_1:2;
end;
definition
let C255 being set;
func GFuncs C255 ->  strict (SubStr of ( GPFuncs C255 )) means 
:L854: (the carrier of it) = ( Funcs (C255 , C255) );
existence
proof
L855: ( Funcs (C255 , C255) ) c= ( PFuncs (C255 , C255) ) by FUNCT_2:72;
reconsider D170 = ( Funcs (C255 , C255) ) as non  empty (Subset of ( GPFuncs C255 )) by L855 , L795;
L856: (for B222 , B223 being (Element of D170) holds ( B222 [*] B223 ) in D170)
proof
let C256 , C257 being (Element of D170);
reconsider D171 = C256 , D172 = C257 as (Function of C255 , C255) by FUNCT_2:66;
L857: ( C256 [*] C257 ) = ( D172 * D171 ) by L795;
thus L858: thesis by L857 , FUNCT_2:9;
end;
consider C258 being  strict non  empty (SubStr of ( GPFuncs C255 )) such that L859: (the carrier of C258) = D170 by L550 , L856;
take C258;
thus L860: thesis by L859;
end;
uniqueness by L431;
end;
registration
let C259 being set;
cluster ( GFuncs C259 ) ->  unital non  empty;
coherence
proof
L862: (the carrier of ( GFuncs C259 )) = ( Funcs (C259 , C259) ) by L854;
L863: ( id C259 ) in ( Funcs (C259 , C259) ) by FUNCT_2:9;
thus L864: thesis by L863 , L862 , L838;
end;
end;
definition
let C260 being set;
func MFuncs C260 ->  well-unital  strict (MonoidalExtension of ( GFuncs C260 )) means 
(not contradiction);
correctness by L328;
end;
theorem
L867: (for R1 being set holds (for R3 being set holds (R1 is (Element of ( GFuncs R3 )) iff R1 is (Function of R3 , R3))))
proof
let R1 being set;
let R3 being set;
L868: H1(( GFuncs R3 )) = ( Funcs (R3 , R3) ) by L854;
thus L869: thesis by L868 , FUNCT_2:9 , FUNCT_2:66;
end;
theorem
L870: (for R3 being set holds (the multF of ( GFuncs R3 )) = ( ( R3 -composition ) || ( Funcs (R3 , R3) ) ))
proof
let R3 being set;
L871: H1(( GFuncs R3 )) = ( Funcs (R3 , R3) ) by L854;
L872: (H2(( GFuncs R3 )) c= H2(( GPFuncs R3 )) & ( dom H2(( GFuncs R3 )) ) = [: H1(( GFuncs R3 )) , H1(( GFuncs R3 )) :]) by L332 , FUNCT_2:def 1;
thus L873: thesis by L872 , L871 , GRFUNC_1:23;
end;
theorem
L874: (for R3 being set holds ( the_unity_wrt (the multF of ( GFuncs R3 )) ) = ( id R3 ))
proof
let R3 being set;
L875: (( id R3 ) in ( Funcs (R3 , R3) ) & H1(( GFuncs R3 )) = ( Funcs (R3 , R3) )) by L854 , FUNCT_2:9;
thus L876: thesis by L875 , L838;
end;
theorem
L877: (for R3 being set holds ((the carrier of ( MFuncs R3 )) = ( Funcs (R3 , R3) ) & (the multF of ( MFuncs R3 )) = ( ( R3 -composition ) || ( Funcs (R3 , R3) ) ) & ( 1. ( MFuncs R3 ) ) = ( id R3 )))
proof
let R3 being set;
L878: (( the_unity_wrt H2(( GFuncs R3 )) ) = ( id R3 ) & ( the multMagma of ( MFuncs R3 ) ) = ( GFuncs R3 )) by L279 , L874;
thus L879: thesis by L878 , L854 , L267 , L870;
end;
definition
let C261 being set;
func GPerms C261 ->  strict non  empty (SubStr of ( GFuncs C261 )) means 
:L880: (for B224 being (Element of ( GFuncs C261 )) holds (B224 in (the carrier of it) iff B224 is (Permutation of C261)));
existence
proof
defpred S3[ (Element of ( GFuncs C261 )) ] means $1 is (Permutation of C261);
L881: (ex B225 being (Element of ( GFuncs C261 )) st S3[ B225 ])
proof
set D173 = the (Permutation of C261);
L882: H1(( GFuncs C261 )) = ( Funcs (C261 , C261) ) by L854;
reconsider D174 = D173 as (Element of ( GFuncs C261 )) by L882 , FUNCT_2:9;
take D174;
thus L883: thesis;
end;
L884: H1(( GFuncs C261 )) = ( Funcs (C261 , C261) ) by L854;
reconsider D175 = ( id C261 ) as (Element of ( GFuncs C261 )) by L884 , FUNCT_2:9;
L885: (for B226 , B227 being (Element of ( GFuncs C261 )) holds ((S3[ B226 ] & S3[ B227 ]) implies S3[ ( B226 [*] B227 ) ]))
proof
let C262 , C263 being (Element of ( GFuncs C261 ));
assume L886: (C262 is (Permutation of C261) & C263 is (Permutation of C261));
reconsider D176 = C262 , D177 = C263 as (Permutation of C261) by L886;
L887: ( C262 [*] C263 ) = ( D177 * D176 ) by L834;
thus L888: thesis by L887;
end;
consider C264 being  strict non  empty (SubStr of ( GFuncs C261 )) such that L889: (for B228 being (Element of ( GFuncs C261 )) holds (B228 in (the carrier of C264) iff S3[ B228 ])) from SubStrEx2(L885 , L881);
take C264;
thus L890: thesis by L889;
end;
uniqueness
proof
let C265 , C266 being  strict non  empty (SubStr of ( GFuncs C261 ));
assume that
L891: (for B229 being (Element of ( GFuncs C261 )) holds (B229 in H1(C265) iff B229 is (Permutation of C261)))
and
L892: (for B230 being (Element of ( GFuncs C261 )) holds (B230 in H1(C266) iff B230 is (Permutation of C261)));
L893: H1(C266) c= H1(( GFuncs C261 )) by L409;
L894: H1(C265) c= H1(( GFuncs C261 )) by L409;
L895: H1(C265) = H1(C266)
proof
thus L896: H1(C265) c= H1(C266)
proof
let R1 being set;
assume L897: R1 in H1(C265);
reconsider D178 = R1 as (Element of ( GFuncs C261 )) by L897 , L894;
L898: D178 is (Permutation of C261) by L891 , L897;
thus L899: thesis by L898 , L892;
end;

let R1 being set;
assume L900: R1 in H1(C266);
reconsider D179 = R1 as (Element of ( GFuncs C261 )) by L900 , L893;
L901: D179 is (Permutation of C261) by L892 , L900;
thus L902: thesis by L901 , L891;
end;
thus L903: thesis by L895 , L431;
end;
end;
registration
let C267 being set;
cluster ( GPerms C267 ) ->  unital  invertible;
coherence
proof
set D180 = ( GPerms C267 );
L905: H1(( GFuncs C267 )) = ( Funcs (C267 , C267) ) by L854;
reconsider D181 = ( id C267 ) as (Element of ( GFuncs C267 )) by L905 , FUNCT_2:9;
L906: D181 in H1(D180) by L880;
thus L907: D180 is  unital by L906 , L838;
L908:
now
reconsider D182 = D181 as (Element of D180) by L880;
let C268 , C269 being (Element of D180);
L909: H1(D180) c= H1(( GFuncs C267 )) by L409;
reconsider D183 = C268 , D184 = C269 as (Element of ( GFuncs C267 )) by L909 , TARSKI:def 3;
reconsider D185 = D183 , D186 = D184 as (Permutation of C267) by L880;
L910: (D182 = ( D185 (*) ( D185 " ) ) & D182 = ( ( D185 " ) (*) D185 )) by FUNCT_2:61;
reconsider D187 = ( D185 " ) as (Element of ( GFuncs C267 )) by L905 , FUNCT_2:9;
L911: (( D186 (*) D182 ) = D186 & ( D182 (*) D186 ) = D186) by FUNCT_2:17;
reconsider D188 = D187 as (Element of D180) by L880;
reconsider D189 = ( D188 [*] C269 ) , D190 = ( C269 [*] D188 ) as (Element of D180);
take D191 = D189;
take D192 = D190;
L912: (( D182 [*] C269 ) = ( D186 (*) ( id C267 ) ) & ( C269 [*] D182 ) = ( ( id C267 ) (*) D186 )) by L834;
L913: (( C268 [*] D188 ) = ( ( D185 " ) (*) D185 ) & ( D188 [*] C268 ) = ( D185 (*) ( D185 " ) )) by L834;
thus L914: (( C268 [*] D191 ) = C269 & ( D192 [*] C268 ) = C269) by L913 , L910 , L911 , L912 , L118;
end;
thus L915: thesis by L908 , L147;
end;
end;
theorem
L917: (for R1 being set holds (for R3 being set holds (R1 is (Element of ( GPerms R3 )) iff R1 is (Permutation of R3))))
proof
let R1 being set;
let R3 being set;
L918: (R1 is (Permutation of R3) implies R1 in ( Funcs (R3 , R3) )) by FUNCT_2:9;
L919: H1(( GPerms R3 )) c= H1(( GFuncs R3 )) by L409;
L920: (R1 is (Element of ( GPerms R3 )) implies R1 is (Element of ( GFuncs R3 ))) by L919 , TARSKI:def 3;
L921: H1(( GFuncs R3 )) = ( Funcs (R3 , R3) ) by L854;
thus L922: thesis by L921 , L918 , L920 , L880;
end;
theorem
L923: (for R3 being set holds (( the_unity_wrt (the multF of ( GPerms R3 )) ) = ( id R3 ) & ( 1_ ( GPerms R3 ) ) = ( id R3 )))
proof
let R3 being set;
reconsider D193 = ( id R3 ) as (Element of ( GPerms R3 )) by L917;
L924:
now
let C270 being (Element of ( GPerms R3 ));
reconsider D194 = C270 as (Permutation of R3) by L917;
L925: ( C270 [*] D193 ) = ( D193 (*) C270 ) by L834;
L926: ( H2(( GPerms R3 )) . (C270 , D193) ) = ( D193 (*) D194 ) by L925;
L927: ( D193 [*] C270 ) = ( C270 (*) D193 ) by L834;
thus L928: (( H2(( GPerms R3 )) . (D193 , C270) ) = C270 & ( H2(( GPerms R3 )) . (C270 , D193) ) = C270) by L927 , L926 , FUNCT_2:17;
end;
L929: D193 is_a_unity_wrt H2(( GPerms R3 )) by L924 , BINOP_1:3;
thus L930: ( the_unity_wrt H2(( GPerms R3 )) ) = ( id R3 ) by L929 , BINOP_1:def 8;
thus L931: thesis by L930 , GROUP_1:22;
end;
theorem
L932: (for R3 being set holds (for B231 being (Element of ( GPerms R3 )) holds ( B231 " ) = ( (B231 qua Function) " )))
proof
let R3 being set;
let C271 being (Element of ( GPerms R3 ));
reconsider D195 = C271 as (Permutation of R3) by L917;
L933: (( D195 (*) ( D195 " ) ) = ( id R3 ) & ( ( D195 " ) (*) D195 ) = ( id R3 )) by FUNCT_2:61;
reconsider D196 = ( D195 " ) as (Element of ( GPerms R3 )) by L917;
reconsider D197 = D196 as (Element of ( GPerms R3 ));
L934: ( D197 [*] C271 ) = ( D195 (*) ( D195 " ) ) by L834;
L935: (( id R3 ) = ( 1_ ( GPerms R3 ) ) & ( C271 [*] D197 ) = ( ( D195 " ) (*) D195 )) by L834 , L923;
thus L936: thesis by L935 , L933 , L934 , GROUP_1:def 5;
end;
theorem
L937: (for B232 being 1-sorted holds ((the carrier of B232) is  functional implies B232 is  constituted-Functions))
proof
let C272 being 1-sorted;
assume that
L938: (the carrier of C272) is  functional;
let C273 being (Element of C272);
thus L939: thesis by L938;
end;
theorem
L940: (for B233 being non  empty multMagma holds (for B234 being non  empty (Subset of B233) holds ((for B235 , B236 being (Element of B234) holds ( B235 * B236 ) in B234) implies (ex B237 being  strict non  empty (SubStr of B233) st (the carrier of B237) = B234)))) by L550;
theorem
L941: (for B238 being non  empty multLoopStr holds (for B239 being non  empty (Subset of B238) holds (((for B240 , B241 being (Element of B239) holds ( B240 * B241 ) in B239) & ( 1. B238 ) in B239) implies (ex B242 being  strict non  empty (MonoidalSubStr of B238) st (the carrier of B242) = B239))))
proof
let C274 being non  empty multLoopStr;
let C275 being non  empty (Subset of C274);
assume that
L942: (for B243 , B244 being (Element of C275) holds ( B243 * B244 ) in C275)
and
L943: ( 1. C274 ) in C275;
thus L944: (ex B245 being  strict non  empty (MonoidalSubStr of C274) st (the carrier of B245) = C275)
proof
consider C276 being  strict non  empty (SubStr of C274) such that L945: (the carrier of C276) = C275 by L550 , L942;
reconsider D198 = ( 1. C274 ) as (Element of C276) by L943 , L945;
set D199 = multLoopStr (# (the carrier of C276) , (the multF of C276) , D198 #);
L946: (H2(D199) c= H2(C274) & (for B246 being multLoopStr holds (C274 = B246 implies ( 1. D199 ) = ( 1. B246 )))) by L332;
reconsider D200 = D199 as  strict non  empty (MonoidalSubStr of C274) by L946 , L373;
take D200;
thus L947: thesis by L945;
end;

end;
