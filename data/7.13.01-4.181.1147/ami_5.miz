:: On the Decomposition of the States of SCM
::  by Yasushi Tanaka
::
:: Received November 23, 1993
:: Copyright (c) 1993-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, AMI_3, SUBSET_1, AMI_2, AMI_1, STRUCT_0, XBOOLE_0,
      FSM_1, RELAT_1, FUNCT_1, TARSKI, FINSET_1, CARD_1, XXREAL_0, FINSEQ_1,
      GRAPHSP, ARYTM_3, ARYTM_1, INT_1, FUNCT_4, FUNCOP_1, CIRCUIT2, ORDINAL1,
      PARTFUN1, EXTPRO_1, RECDEF_2, CAT_1, AMISTD_5, COMPOS_1;
 notations TARSKI, XBOOLE_0,
      XTUPLE_0, SUBSET_1, CARD_1, XCMPLX_0, DOMAIN_1,
      RELAT_1, FUNCT_1, FUNCOP_1, PARTFUN1, FUNCT_4, NUMBERS, INT_1, NAT_1,
      RECDEF_2, STRUCT_0, FINSET_1, FINSEQ_1, MEMSTR_0, COMPOS_0, SCM_INST,
      COMPOS_1, EXTPRO_1, AMI_3, XXREAL_0, AMISTD_5;
 constructors DOMAIN_1, FINSEQ_4, AMI_3, PRE_POLY, AMISTD_5, FUNCT_7, RELSET_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, XREAL_0, INT_1,
      AMI_3, FINSET_1, CARD_1, COMPOS_1, EXTPRO_1, FUNCT_4, FUNCOP_1, MEMSTR_0,
      COMPOS_0, XTUPLE_0;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, EXTPRO_1, AMI_3, FUNCOP_1, AMI_2, FUNCT_1, AMISTD_5,
      MEMSTR_0, SCM_INST, XTUPLE_0;
 theorems AMI_3, GRFUNC_1, TARSKI, FUNCOP_1, FUNCT_4, MEMSTR_0, FUNCT_1,
      ZFMISC_1, ENUMSET1, RELAT_1, XBOOLE_0, XBOOLE_1, PBOOLE, PARTFUN1,
      RECDEF_2, EXTPRO_1, AMISTD_5, NAT_1, AMI_2, COMPOS_1;

begin
theorem
L1: (for B1 being Data-Location holds (ex B2 being (Element of ( NAT )) st B1 = ( dl. B2 )))
proof
let C1 being Data-Location;
L2: C1 in ( Data-Locations ( SCM ) ) by AMI_2:def 16 , AMI_3:27;
consider R1 being set, R2 being set such that L3: R1 in { 1 } and L4: R2 in ( NAT ) and L5: C1 = [ R1 , R2 ] by L2 , AMI_3:27 , ZFMISC_1:84;
reconsider D1 = R2 as (Element of ( NAT )) by L4;
take D1;
thus L6: thesis by L3 , L5 , TARSKI:def 1;
end;
theorem
L7: (for B3 being Data-Location holds B3 <> ( IC ( SCM ) ))
proof
let C2 being Data-Location;
L8: (ex B4 being (Element of ( NAT )) st C2 = ( dl. B4 )) by L1;
thus L9: thesis by L8 , AMI_3:13;
end;
theorem
L10: (for B5 being (Element of ( NAT )) holds (for B6 being Data-Location holds B5 <> B6))
proof
let C3 being (Element of ( NAT ));
let C4 being Data-Location;
L11: (ex B7 being (Element of ( NAT )) st C4 = ( dl. B7 )) by L1;
thus L12: thesis by L11;
end;
theorem
L13: (for B8 being (State of ( SCM )) holds (for B9 being Data-Location holds B9 in ( dom B8 )))
proof
let C5 being (State of ( SCM ));
let C6 being Data-Location;
L14: ( dom C5 ) = (the carrier of ( SCM )) by PARTFUN1:def 2;
thus L15: C6 in ( dom C5 ) by L14;
end;
registration
cluster ( Data-Locations ( SCM ) ) ->  infinite;
coherence by AMI_3:27;
end;
L17: (for R11 being (Element of ( Data-Locations ( SCM ) )) holds R11 is Data-Location)
proof
let R11 being (Element of ( Data-Locations ( SCM ) ));
L18: R11 in ( Data-Locations ( SCM ) );
reconsider D2 = R11 as (Object of ( SCM )) by L18;
L19: D2 is Data-Location by AMI_2:def 16 , AMI_3:27;
thus L20: thesis by L19;
end;
theorem
L21: (for B10 being (Instruction of ( SCM )) holds ( InsCode B10 ) <= 8)
proof
let C7 being (Instruction of ( SCM ));
L22: (C7 in ( ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R7 , <* R9 *> , ( {} ) ] where R7 is (Element of ( Segm 9 )) , R9 is (Element of ( NAT )) : R7 = 6 } ) \/ { [ R8 , <* R10 *> , <* R12 *> ] where R8 is (Element of ( Segm 9 )) , R10 is (Element of ( NAT )) , R12 is (Element of ( Data-Locations ( SCM ) )) : R8 in { 7 , 8 } } ) or C7 in { [ R6 , ( {} ) , <* R11 , R13 *> ] where R6 is (Element of ( Segm 9 )) , R11 is (Element of ( Data-Locations ( SCM ) )) , R13 is (Element of ( Data-Locations ( SCM ) )) : R6 in { 1 , 2 , 3 , 4 , 5 } }) by AMI_3:27 , XBOOLE_0:def 3;
L23: (C7 in ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R7 , <* R9 *> , ( {} ) ] where R7 is (Element of ( Segm 9 )) , R9 is (Element of ( NAT )) : R7 = 6 } ) or C7 in { [ R8 , <* R10 *> , <* R12 *> ] where R8 is (Element of ( Segm 9 )) , R10 is (Element of ( NAT )) , R12 is (Element of ( Data-Locations ( SCM ) )) : R8 in { 7 , 8 } } or C7 in { [ R6 , ( {} ) , <* R11 , R13 *> ] where R6 is (Element of ( Segm 9 )) , R11 is (Element of ( Data-Locations ( SCM ) )) , R13 is (Element of ( Data-Locations ( SCM ) )) : R6 in { 1 , 2 , 3 , 4 , 5 } }) by L22 , XBOOLE_0:def 3;
per cases  by L23 , XBOOLE_0:def 3;
suppose L24: C7 in { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] };

L25: C7 = [ ( SCM-Halt ) , ( {} ) , ( {} ) ] by L24 , TARSKI:def 1;
L26: ( C7 `1_3 ) = ( 0 ) by L25 , RECDEF_2:def 1;
thus L27: thesis by L26;
end;
suppose L28: C7 in { [ R7 , <* R9 *> , ( {} ) ] where R7 is (Element of ( Segm 9 )) , R9 is (Element of ( NAT )) : R7 = 6 };

L29: (ex R7 being (Element of ( Segm 9 )) st (ex R9 being (Element of ( NAT )) st (C7 = [ R7 , <* R9 *> , ( {} ) ] & R7 = 6))) by L28;
L30: ( C7 `1_3 ) = 6 by L29 , RECDEF_2:def 1;
thus L31: thesis by L30;
end;
suppose L32: C7 in { [ R8 , <* R10 *> , <* R12 *> ] where R8 is (Element of ( Segm 9 )) , R10 is (Element of ( NAT )) , R12 is (Element of ( Data-Locations ( SCM ) )) : R8 in { 7 , 8 } };

L33: (ex R8 being (Element of ( Segm 9 )) st (ex R10 being (Element of ( NAT )) st (ex R12 being (Element of ( Data-Locations ( SCM ) )) st (C7 = [ R8 , <* R10 *> , <* R12 *> ] & R8 in { 7 , 8 })))) by L32;
L34: ( C7 `1_3 ) in { 7 , 8 } by L33 , RECDEF_2:def 1;
L35: (( C7 `1_3 ) = 7 or ( C7 `1_3 ) = 8) by L34 , TARSKI:def 2;
thus L36: thesis by L35;
end;
suppose L37: C7 in { [ R6 , ( {} ) , <* R11 , R13 *> ] where R6 is (Element of ( Segm 9 )) , R11 is (Element of ( Data-Locations ( SCM ) )) , R13 is (Element of ( Data-Locations ( SCM ) )) : R6 in { 1 , 2 , 3 , 4 , 5 } };

L38: (ex R6 being (Element of ( Segm 9 )) st (ex R11 being (Element of ( Data-Locations ( SCM ) )) st (ex R13 being (Element of ( Data-Locations ( SCM ) )) st (C7 = [ R6 , ( {} ) , <* R11 , R13 *> ] & R6 in { 1 , 2 , 3 , 4 , 5 })))) by L37;
L39: ( C7 `1_3 ) in { 1 , 2 , 3 , 4 , 5 } by L38 , RECDEF_2:def 1;
L40: (( C7 `1_3 ) = 1 or ( C7 `1_3 ) = 2 or ( C7 `1_3 ) = 3 or ( C7 `1_3 ) = 4 or ( C7 `1_3 ) = 5) by L39 , ENUMSET1:def 3;
thus L41: thesis by L40;
end;
end;
canceled 1;
theorem
L43: (for B11 being (Instruction of ( SCM )) holds (( InsCode B11 ) = ( 0 ) implies B11 = ( halt ( SCM ) )))
proof
let C8 being (Instruction of ( SCM ));
assume that
L44: ( InsCode C8 ) = ( 0 );
L45:
now
assume L46: C8 in { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 };
L47: (ex R18 being (Element of ( Segm 9 )) st (ex R20 being (Element of ( NAT )) st (C8 = [ R18 , <* R20 *> , ( {} ) ] & R18 = 6))) by L46;
thus L48: contradiction by L47 , L44 , RECDEF_2:def 1;
end;
L49:
now
assume L50: C8 in { [ R17 , ( {} ) , <* R22 , R24 *> ] where R17 is (Element of ( Segm 9 )) , R22 is (Element of ( Data-Locations ( SCM ) )) , R24 is (Element of ( Data-Locations ( SCM ) )) : R17 in { 1 , 2 , 3 , 4 , 5 } };
L51: (ex R17 being (Element of ( Segm 9 )) st (ex R22 being (Element of ( Data-Locations ( SCM ) )) st (ex R24 being (Element of ( Data-Locations ( SCM ) )) st (C8 = [ R17 , ( {} ) , <* R22 , R24 *> ] & R17 in { 1 , 2 , 3 , 4 , 5 })))) by L50;
thus L52: contradiction by L51 , L44 , RECDEF_2:def 1;
end;
L53: C8 in ( ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } ) \/ { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } } ) by L49 , AMI_3:27 , XBOOLE_0:def 3;
L54:
now
assume L55: C8 in { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } };
L56: (ex R19 being (Element of ( Segm 9 )) st (ex R21 being (Element of ( NAT )) st (ex R23 being (Element of ( Data-Locations ( SCM ) )) st (C8 = [ R19 , <* R21 *> , <* R23 *> ] & R19 in { 7 , 8 })))) by L55;
thus L57: contradiction by L56 , L44 , RECDEF_2:def 1;
end;
L58: C8 in ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } ) by L54 , L53 , XBOOLE_0:def 3;
L59: C8 in { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } by L58 , L45 , XBOOLE_0:def 3;
thus L60: thesis by L59 , AMI_3:26 , TARSKI:def 1;
end;
theorem
L61: (for B12 being (Instruction of ( SCM )) holds (( InsCode B12 ) = 1 implies (ex R25 being Data-Location st (ex R26 being Data-Location st B12 = ( R25 := R26 )))))
proof
let C9 being (Instruction of ( SCM ));
assume that
L62: ( InsCode C9 ) = 1;
L63:
now
assume L64: C9 in { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 };
L65: (ex R18 being (Element of ( Segm 9 )) st (ex R20 being (Element of ( NAT )) st (C9 = [ R18 , <* R20 *> , ( {} ) ] & R18 = 6))) by L64;
thus L66: contradiction by L65 , L62 , RECDEF_2:def 1;
end;
L67:
now
assume L68: C9 in { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } };
consider R19 being (Element of ( Segm 9 )), R21 being (Element of ( NAT )), R23 being (Element of ( Data-Locations ( SCM ) )) such that L69: C9 = [ R19 , <* R21 *> , <* R23 *> ] and L70: R19 in { 7 , 8 } by L68;
L71: ( InsCode C9 ) = R19 by L69 , RECDEF_2:def 1;
thus L72: contradiction by L71 , L62 , L70 , TARSKI:def 2;
end;
L73: ( InsCode ( halt ( SCM ) ) ) = ( 0 ) by COMPOS_1:70;
L74: (not C9 in { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] }) by L73 , L62 , AMI_3:26 , TARSKI:def 1;
L75: (not C9 in ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } )) by L74 , L63 , XBOOLE_0:def 3;
L76: (not C9 in ( ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } ) \/ { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } } )) by L75 , L67 , XBOOLE_0:def 3;
L77: C9 in { [ R17 , ( {} ) , <* R22 , R24 *> ] where R17 is (Element of ( Segm 9 )) , R22 is (Element of ( Data-Locations ( SCM ) )) , R24 is (Element of ( Data-Locations ( SCM ) )) : R17 in { 1 , 2 , 3 , 4 , 5 } } by L76 , AMI_3:27 , XBOOLE_0:def 3;
consider R17 being (Element of ( Segm 9 )), R22 being (Element of ( Data-Locations ( SCM ) )), R24 being (Element of ( Data-Locations ( SCM ) )) such that L78: C9 = [ R17 , ( {} ) , <* R22 , R24 *> ] and L79: R17 in { 1 , 2 , 3 , 4 , 5 } by L77;
reconsider D3 = R22 , D4 = R24 as Data-Location by L17;
take D3;
take D4;
thus L80: thesis by L62 , L78 , RECDEF_2:def 1;
end;
theorem
L81: (for B13 being (Instruction of ( SCM )) holds (( InsCode B13 ) = 2 implies (ex R25 being Data-Location st (ex R26 being Data-Location st B13 = ( AddTo (R25 , R26) )))))
proof
let C10 being (Instruction of ( SCM ));
assume that
L82: ( InsCode C10 ) = 2;
L83:
now
assume L84: C10 in { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 };
L85: (ex R18 being (Element of ( Segm 9 )) st (ex R20 being (Element of ( NAT )) st (C10 = [ R18 , <* R20 *> , ( {} ) ] & R18 = 6))) by L84;
thus L86: contradiction by L85 , L82 , RECDEF_2:def 1;
end;
L87:
now
assume L88: C10 in { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } };
consider R19 being (Element of ( Segm 9 )), R21 being (Element of ( NAT )), R23 being (Element of ( Data-Locations ( SCM ) )) such that L89: C10 = [ R19 , <* R21 *> , <* R23 *> ] and L90: R19 in { 7 , 8 } by L88;
L91: ( InsCode C10 ) = R19 by L89 , RECDEF_2:def 1;
thus L92: contradiction by L91 , L82 , L90 , TARSKI:def 2;
end;
L93: ( InsCode ( halt ( SCM ) ) ) = ( 0 ) by COMPOS_1:70;
L94: (not C10 in { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] }) by L93 , L82 , AMI_3:26 , TARSKI:def 1;
L95: (not C10 in ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } )) by L94 , L83 , XBOOLE_0:def 3;
L96: (not C10 in ( ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } ) \/ { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } } )) by L95 , L87 , XBOOLE_0:def 3;
L97: C10 in { [ R17 , ( {} ) , <* R22 , R24 *> ] where R17 is (Element of ( Segm 9 )) , R22 is (Element of ( Data-Locations ( SCM ) )) , R24 is (Element of ( Data-Locations ( SCM ) )) : R17 in { 1 , 2 , 3 , 4 , 5 } } by L96 , AMI_3:27 , XBOOLE_0:def 3;
consider R17 being (Element of ( Segm 9 )), R22 being (Element of ( Data-Locations ( SCM ) )), R24 being (Element of ( Data-Locations ( SCM ) )) such that L98: C10 = [ R17 , ( {} ) , <* R22 , R24 *> ] and L99: R17 in { 1 , 2 , 3 , 4 , 5 } by L97;
reconsider D5 = R22 , D6 = R24 as Data-Location by L17;
take D5;
take D6;
thus L100: thesis by L82 , L98 , RECDEF_2:def 1;
end;
theorem
L101: (for B14 being (Instruction of ( SCM )) holds (( InsCode B14 ) = 3 implies (ex R25 being Data-Location st (ex R26 being Data-Location st B14 = ( SubFrom (R25 , R26) )))))
proof
let C11 being (Instruction of ( SCM ));
assume that
L102: ( InsCode C11 ) = 3;
L103:
now
assume L104: C11 in { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 };
L105: (ex R18 being (Element of ( Segm 9 )) st (ex R20 being (Element of ( NAT )) st (C11 = [ R18 , <* R20 *> , ( {} ) ] & R18 = 6))) by L104;
thus L106: contradiction by L105 , L102 , RECDEF_2:def 1;
end;
L107:
now
assume L108: C11 in { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } };
consider R19 being (Element of ( Segm 9 )), R21 being (Element of ( NAT )), R23 being (Element of ( Data-Locations ( SCM ) )) such that L109: C11 = [ R19 , <* R21 *> , <* R23 *> ] and L110: R19 in { 7 , 8 } by L108;
L111: ( InsCode C11 ) = R19 by L109 , RECDEF_2:def 1;
thus L112: contradiction by L111 , L102 , L110 , TARSKI:def 2;
end;
L113: ( InsCode ( halt ( SCM ) ) ) = ( 0 ) by COMPOS_1:70;
L114: (not C11 in { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] }) by L113 , L102 , AMI_3:26 , TARSKI:def 1;
L115: (not C11 in ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } )) by L114 , L103 , XBOOLE_0:def 3;
L116: (not C11 in ( ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } ) \/ { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } } )) by L115 , L107 , XBOOLE_0:def 3;
L117: C11 in { [ R17 , ( {} ) , <* R22 , R24 *> ] where R17 is (Element of ( Segm 9 )) , R22 is (Element of ( Data-Locations ( SCM ) )) , R24 is (Element of ( Data-Locations ( SCM ) )) : R17 in { 1 , 2 , 3 , 4 , 5 } } by L116 , AMI_3:27 , XBOOLE_0:def 3;
consider R17 being (Element of ( Segm 9 )), R22 being (Element of ( Data-Locations ( SCM ) )), R24 being (Element of ( Data-Locations ( SCM ) )) such that L118: C11 = [ R17 , ( {} ) , <* R22 , R24 *> ] and L119: R17 in { 1 , 2 , 3 , 4 , 5 } by L117;
reconsider D7 = R22 , D8 = R24 as Data-Location by L17;
take D7;
take D8;
thus L120: thesis by L102 , L118 , RECDEF_2:def 1;
end;
theorem
L121: (for B15 being (Instruction of ( SCM )) holds (( InsCode B15 ) = 4 implies (ex R25 being Data-Location st (ex R26 being Data-Location st B15 = ( MultBy (R25 , R26) )))))
proof
let C12 being (Instruction of ( SCM ));
assume that
L122: ( InsCode C12 ) = 4;
L123:
now
assume L124: C12 in { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 };
L125: (ex R18 being (Element of ( Segm 9 )) st (ex R20 being (Element of ( NAT )) st (C12 = [ R18 , <* R20 *> , ( {} ) ] & R18 = 6))) by L124;
thus L126: contradiction by L125 , L122 , RECDEF_2:def 1;
end;
L127:
now
assume L128: C12 in { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } };
consider R19 being (Element of ( Segm 9 )), R21 being (Element of ( NAT )), R23 being (Element of ( Data-Locations ( SCM ) )) such that L129: C12 = [ R19 , <* R21 *> , <* R23 *> ] and L130: R19 in { 7 , 8 } by L128;
L131: ( InsCode C12 ) = R19 by L129 , RECDEF_2:def 1;
thus L132: contradiction by L131 , L122 , L130 , TARSKI:def 2;
end;
L133: ( InsCode ( halt ( SCM ) ) ) = ( 0 ) by COMPOS_1:70;
L134: (not C12 in { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] }) by L133 , L122 , AMI_3:26 , TARSKI:def 1;
L135: (not C12 in ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } )) by L134 , L123 , XBOOLE_0:def 3;
L136: (not C12 in ( ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } ) \/ { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } } )) by L135 , L127 , XBOOLE_0:def 3;
L137: C12 in { [ R17 , ( {} ) , <* R22 , R24 *> ] where R17 is (Element of ( Segm 9 )) , R22 is (Element of ( Data-Locations ( SCM ) )) , R24 is (Element of ( Data-Locations ( SCM ) )) : R17 in { 1 , 2 , 3 , 4 , 5 } } by L136 , AMI_3:27 , XBOOLE_0:def 3;
consider R17 being (Element of ( Segm 9 )), R22 being (Element of ( Data-Locations ( SCM ) )), R24 being (Element of ( Data-Locations ( SCM ) )) such that L138: C12 = [ R17 , ( {} ) , <* R22 , R24 *> ] and L139: R17 in { 1 , 2 , 3 , 4 , 5 } by L137;
reconsider D9 = R22 , D10 = R24 as Data-Location by L17;
take D9;
take D10;
thus L140: thesis by L122 , L138 , RECDEF_2:def 1;
end;
theorem
L141: (for B16 being (Instruction of ( SCM )) holds (( InsCode B16 ) = 5 implies (ex R25 being Data-Location st (ex R26 being Data-Location st B16 = ( Divide (R25 , R26) )))))
proof
let C13 being (Instruction of ( SCM ));
assume that
L142: ( InsCode C13 ) = 5;
L143:
now
assume L144: C13 in { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 };
L145: (ex R18 being (Element of ( Segm 9 )) st (ex R20 being (Element of ( NAT )) st (C13 = [ R18 , <* R20 *> , ( {} ) ] & R18 = 6))) by L144;
thus L146: contradiction by L145 , L142 , RECDEF_2:def 1;
end;
L147:
now
assume L148: C13 in { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } };
consider R19 being (Element of ( Segm 9 )), R21 being (Element of ( NAT )), R23 being (Element of ( Data-Locations ( SCM ) )) such that L149: C13 = [ R19 , <* R21 *> , <* R23 *> ] and L150: R19 in { 7 , 8 } by L148;
L151: ( InsCode C13 ) = R19 by L149 , RECDEF_2:def 1;
thus L152: contradiction by L151 , L142 , L150 , TARSKI:def 2;
end;
L153: ( InsCode ( halt ( SCM ) ) ) = ( 0 ) by COMPOS_1:70;
L154: (not C13 in { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] }) by L153 , L142 , AMI_3:26 , TARSKI:def 1;
L155: (not C13 in ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } )) by L154 , L143 , XBOOLE_0:def 3;
L156: (not C13 in ( ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } ) \/ { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } } )) by L155 , L147 , XBOOLE_0:def 3;
L157: C13 in { [ R17 , ( {} ) , <* R22 , R24 *> ] where R17 is (Element of ( Segm 9 )) , R22 is (Element of ( Data-Locations ( SCM ) )) , R24 is (Element of ( Data-Locations ( SCM ) )) : R17 in { 1 , 2 , 3 , 4 , 5 } } by L156 , AMI_3:27 , XBOOLE_0:def 3;
consider R17 being (Element of ( Segm 9 )), R22 being (Element of ( Data-Locations ( SCM ) )), R24 being (Element of ( Data-Locations ( SCM ) )) such that L158: C13 = [ R17 , ( {} ) , <* R22 , R24 *> ] and L159: R17 in { 1 , 2 , 3 , 4 , 5 } by L157;
reconsider D11 = R22 , D12 = R24 as Data-Location by L17;
take D11;
take D12;
thus L160: thesis by L142 , L158 , RECDEF_2:def 1;
end;
theorem
L161: (for B17 being (Instruction of ( SCM )) holds (( InsCode B17 ) = 6 implies (ex R16 being (Element of ( NAT )) st B17 = ( SCM-goto R16 ))))
proof
let C14 being (Instruction of ( SCM ));
assume that
L162: ( InsCode C14 ) = 6;
L163:
now
assume L164: C14 in { [ R17 , ( {} ) , <* R22 , R24 *> ] where R17 is (Element of ( Segm 9 )) , R22 is (Element of ( Data-Locations ( SCM ) )) , R24 is (Element of ( Data-Locations ( SCM ) )) : R17 in { 1 , 2 , 3 , 4 , 5 } };
consider R17 being (Element of ( Segm 9 )), R22 being (Element of ( Data-Locations ( SCM ) )), R24 being (Element of ( Data-Locations ( SCM ) )) such that L165: C14 = [ R17 , ( {} ) , <* R22 , R24 *> ] and L166: R17 in { 1 , 2 , 3 , 4 , 5 } by L164;
L167: ( InsCode C14 ) = R17 by L165 , RECDEF_2:def 1;
thus L168: contradiction by L167 , L162 , L166 , ENUMSET1:def 3;
end;
L169: C14 in ( ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } ) \/ { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } } ) by L163 , AMI_3:27 , XBOOLE_0:def 3;
L170:
now
assume L171: C14 in { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } };
consider R19 being (Element of ( Segm 9 )), R21 being (Element of ( NAT )), R23 being (Element of ( Data-Locations ( SCM ) )) such that L172: C14 = [ R19 , <* R21 *> , <* R23 *> ] and L173: R19 in { 7 , 8 } by L171;
L174: ( InsCode C14 ) = R19 by L172 , RECDEF_2:def 1;
thus L175: contradiction by L174 , L162 , L173 , TARSKI:def 2;
end;
L176: C14 in ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } ) by L170 , L169 , XBOOLE_0:def 3;
L177: ( InsCode ( halt ( SCM ) ) ) = ( 0 ) by COMPOS_1:70;
L178: (not C14 in { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] }) by L177 , L162 , AMI_3:26 , TARSKI:def 1;
L179: C14 in { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } by L178 , L176 , XBOOLE_0:def 3;
consider R18 being (Element of ( Segm 9 )), R20 being (Element of ( NAT )) such that L180: (C14 = [ R18 , <* R20 *> , ( {} ) ] & R18 = 6) by L179;
reconsider D13 = R20 as (Element of ( NAT ));
take D13;
thus L181: thesis by L180;
end;
theorem
L182: (for B18 being (Instruction of ( SCM )) holds (( InsCode B18 ) = 7 implies (ex R16 being (Element of ( NAT )) st (ex R25 being Data-Location st B18 = ( R25 =0_goto R16 )))))
proof
let C15 being (Instruction of ( SCM ));
assume that
L183: ( InsCode C15 ) = 7;
L184:
now
assume L185: C15 in { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 };
L186: (ex R18 being (Element of ( Segm 9 )) st (ex R20 being (Element of ( NAT )) st (C15 = [ R18 , <* R20 *> , ( {} ) ] & R18 = 6))) by L185;
thus L187: contradiction by L186 , L183 , RECDEF_2:def 1;
end;
L188:
now
assume L189: C15 in { [ R17 , ( {} ) , <* R22 , R24 *> ] where R17 is (Element of ( Segm 9 )) , R22 is (Element of ( Data-Locations ( SCM ) )) , R24 is (Element of ( Data-Locations ( SCM ) )) : R17 in { 1 , 2 , 3 , 4 , 5 } };
consider R17 being (Element of ( Segm 9 )), R22 being (Element of ( Data-Locations ( SCM ) )), R24 being (Element of ( Data-Locations ( SCM ) )) such that L190: C15 = [ R17 , ( {} ) , <* R22 , R24 *> ] and L191: R17 in { 1 , 2 , 3 , 4 , 5 } by L189;
L192: ( InsCode C15 ) = R17 by L190 , RECDEF_2:def 1;
thus L193: contradiction by L192 , L183 , L191 , ENUMSET1:def 3;
end;
L194: C15 in ( ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } ) \/ { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } } ) by L188 , AMI_3:27 , XBOOLE_0:def 3;
L195: ( InsCode ( halt ( SCM ) ) ) = ( 0 ) by COMPOS_1:70;
L196: (not C15 in { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] }) by L195 , L183 , AMI_3:26 , TARSKI:def 1;
L197: (not C15 in ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } )) by L196 , L184 , XBOOLE_0:def 3;
L198: C15 in { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } } by L197 , L194 , XBOOLE_0:def 3;
consider R19 being (Element of ( Segm 9 )), R21 being (Element of ( NAT )), R23 being (Element of ( Data-Locations ( SCM ) )) such that L199: C15 = [ R19 , <* R21 *> , <* R23 *> ] and L200: R19 in { 7 , 8 } by L198;
reconsider D14 = R23 as Data-Location by L17;
reconsider D15 = R21 as (Element of ( NAT ));
take D15;
take D14;
thus L201: thesis by L183 , L199 , RECDEF_2:def 1;
end;
theorem
L202: (for B19 being (Instruction of ( SCM )) holds (( InsCode B19 ) = 8 implies (ex R16 being (Element of ( NAT )) st (ex R25 being Data-Location st B19 = ( R25 >0_goto R16 )))))
proof
let C16 being (Instruction of ( SCM ));
assume that
L203: ( InsCode C16 ) = 8;
L204:
now
assume L205: C16 in { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 };
L206: (ex R18 being (Element of ( Segm 9 )) st (ex R20 being (Element of ( NAT )) st (C16 = [ R18 , <* R20 *> , ( {} ) ] & R18 = 6))) by L205;
thus L207: contradiction by L206 , L203 , RECDEF_2:def 1;
end;
L208:
now
assume L209: C16 in { [ R17 , ( {} ) , <* R22 , R24 *> ] where R17 is (Element of ( Segm 9 )) , R22 is (Element of ( Data-Locations ( SCM ) )) , R24 is (Element of ( Data-Locations ( SCM ) )) : R17 in { 1 , 2 , 3 , 4 , 5 } };
consider R17 being (Element of ( Segm 9 )), R22 being (Element of ( Data-Locations ( SCM ) )), R24 being (Element of ( Data-Locations ( SCM ) )) such that L210: C16 = [ R17 , ( {} ) , <* R22 , R24 *> ] and L211: R17 in { 1 , 2 , 3 , 4 , 5 } by L209;
L212: ( InsCode C16 ) = R17 by L210 , RECDEF_2:def 1;
thus L213: contradiction by L212 , L203 , L211 , ENUMSET1:def 3;
end;
L214: C16 in ( ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } ) \/ { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } } ) by L208 , AMI_3:27 , XBOOLE_0:def 3;
L215: ( InsCode ( halt ( SCM ) ) ) = ( 0 ) by COMPOS_1:70;
L216: (not C16 in { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] }) by L215 , L203 , AMI_3:26 , TARSKI:def 1;
L217: (not C16 in ( { [ ( SCM-Halt ) , ( {} ) , ( {} ) ] } \/ { [ R18 , <* R20 *> , ( {} ) ] where R18 is (Element of ( Segm 9 )) , R20 is (Element of ( NAT )) : R18 = 6 } )) by L216 , L204 , XBOOLE_0:def 3;
L218: C16 in { [ R19 , <* R21 *> , <* R23 *> ] where R19 is (Element of ( Segm 9 )) , R21 is (Element of ( NAT )) , R23 is (Element of ( Data-Locations ( SCM ) )) : R19 in { 7 , 8 } } by L217 , L214 , XBOOLE_0:def 3;
consider R19 being (Element of ( Segm 9 )), R21 being (Element of ( NAT )), R23 being (Element of ( Data-Locations ( SCM ) )) such that L219: C16 = [ R19 , <* R21 *> , <* R23 *> ] and L220: R19 in { 7 , 8 } by L218;
reconsider D16 = R23 as Data-Location by L17;
reconsider D17 = R21 as (Element of ( NAT ));
take D17;
take D16;
thus L221: thesis by L203 , L219 , RECDEF_2:def 1;
end;
begin
theorem
L222: (for B20 being (State of ( SCM )) holds (for B21 being (Element of ( NAT )) holds (for B22 being Data-Location holds ( B20 . B22 ) = ( ( B20 +* ( Start-At (B21 , ( SCM )) ) ) . B22 ))))
proof
let C17 being (State of ( SCM ));
let C18 being (Element of ( NAT ));
let C19 being Data-Location;
L223: C19 in (the carrier of ( SCM ));
L224: C19 in ( dom C17 ) by L223 , PARTFUN1:def 2;
L225: (( dom ( Start-At (C18 , ( SCM )) ) ) = { ( IC ( SCM ) ) } & C19 in ( ( dom C17 ) \/ ( dom ( Start-At (C18 , ( SCM )) ) ) )) by L224 , FUNCOP_1:13 , XBOOLE_0:def 3;
L226: C19 <> ( IC ( SCM ) ) by L7;
L227: (not C19 in { ( IC ( SCM ) ) }) by L226 , TARSKI:def 1;
thus L228: thesis by L227 , L225 , FUNCT_4:def 1;
end;
begin
registration
cluster ( SCM ) ->  IC-recognized;
coherence
proof
L229: (for B23 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function holds (for B24 being B23 -autonomic (FinPartState of ( SCM )) holds (( DataPart B24 ) <> ( {} ) implies ( IC ( SCM ) ) in ( dom B24 ))))
proof
let C20 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function;
let C21 being C20 -autonomic (FinPartState of ( SCM ));
assume L230: ( DataPart C21 ) <> ( {} );
L231: ( dom ( DataPart C21 ) ) <> ( {} ) by L230;
assume L232: (not ( IC ( SCM ) ) in ( dom C21 ));
L233: ( dom C21 ) misses { ( IC ( SCM ) ) } by L232 , ZFMISC_1:50;
L234: ( ( dom C21 ) /\ { ( IC ( SCM ) ) } ) = ( {} ) by L233 , XBOOLE_0:def 7;
L235: (not C21 is C20 -autonomic)
proof
set D18 = the (Element of ( ( NAT ) \ ( dom C20 ) ));
set D19 = the (Element of ( ( Data-Locations ( SCM ) ) \ ( dom C21 ) ));
set D20 = the (Element of ( dom ( DataPart C21 ) ));
L236: D20 in ( dom ( DataPart C21 ) ) by L231;
L237: ( DataPart C21 ) c= C21 by MEMSTR_0:12;
L238: ( dom ( DataPart C21 ) ) c= ( dom C21 ) by L237 , RELAT_1:11;
L239: ( dom ( DataPart C21 ) ) c= (the carrier of ( SCM )) by RELAT_1:def 18;
reconsider D21 = D20 as (Element of ( SCM )) by L239 , L236;
L240: (not ( Data-Locations ( SCM ) ) c= ( dom C21 ));
L241: ( ( Data-Locations ( SCM ) ) \ ( dom C21 ) ) <> ( {} ) by L240 , XBOOLE_1:37;
L242: D19 in ( Data-Locations ( SCM ) ) by L241 , XBOOLE_0:def 5;
reconsider D22 = D19 as Data-Location by L242 , AMI_2:def 16 , AMI_3:27;
L243: (not D22 in ( dom C21 )) by L241 , XBOOLE_0:def 5;
L244: ( dom C21 ) misses { D22 } by L243 , ZFMISC_1:50;
L245: (not ( NAT ) c= ( dom C20 ));
L246: ( ( NAT ) \ ( dom C20 ) ) <> ( {} ) by L245 , XBOOLE_1:37;
reconsider D23 = D18 as (Element of ( NAT )) by L246 , XBOOLE_0:def 5;
L247: (not D23 in ( dom C20 )) by L246 , XBOOLE_0:def 5;
L248: ( dom ( DataPart C21 ) ) c= ( Data-Locations ( SCM ) ) by RELAT_1:58;
reconsider D24 = D21 as Data-Location by L248 , L236 , AMI_2:def 16 , AMI_3:27;
set D25 = ( C21 +* ( ( D22 .--> 1 ) +* ( Start-At (D23 , ( SCM )) ) ) );
set D26 = ( C21 +* ( ( D22 .--> ( 0 ) ) +* ( Start-At (D23 , ( SCM )) ) ) );
set D27 = ( C20 +* ( D23 .--> ( D24 := D22 ) ) );
set D28 = ( C20 +* ( D23 .--> ( D24 := D22 ) ) );
consider C22 being (State of ( SCM )) such that L249: D26 c= C22 by PBOOLE:141;
consider C23 being (Instruction-Sequence of ( SCM )) such that L250: D28 c= C23 by PBOOLE:145;
L251: ( dom C21 ) misses { D22 } by L243 , ZFMISC_1:50;
L252: ( dom ( ( D22 .--> 1 ) +* ( Start-At (D23 , ( SCM )) ) ) ) = ( ( dom ( D22 .--> 1 ) ) \/ ( dom ( Start-At (D23 , ( SCM )) ) ) ) by FUNCT_4:def 1;
consider C24 being (State of ( SCM )) such that L253: D25 c= C24 by PBOOLE:141;
consider C25 being (Instruction-Sequence of ( SCM )) such that L254: D27 c= C25 by PBOOLE:145;
L255: ( dom C21 ) c= (the carrier of ( SCM )) by RELAT_1:def 18;
L256: ( dom ( Comput (C25 , C24 , 1) ) ) = (the carrier of ( SCM )) by PARTFUN1:def 2;
L257: ( dom ( ( Comput (C25 , C24 , 1) ) | ( dom C21 ) ) ) = ( dom C21 ) by L256 , L255 , RELAT_1:62;
L258: ( dom ( Comput (C23 , C22 , 1) ) ) = (the carrier of ( SCM )) by PARTFUN1:def 2;
L259: ( dom ( ( Comput (C23 , C22 , 1) ) | ( dom C21 ) ) ) = ( dom C21 ) by L255 , L258 , RELAT_1:62;
L260: ( dom D25 ) = ( ( dom C21 ) \/ ( dom ( ( D22 .--> 1 ) +* ( Start-At (D23 , ( SCM )) ) ) ) ) by FUNCT_4:def 1;
L261: ( dom D27 ) = ( ( dom C20 ) \/ ( dom ( D23 .--> ( D24 := D22 ) ) ) ) by FUNCT_4:def 1;
L262: ( dom ( Start-At (D23 , ( SCM )) ) ) = { ( IC ( SCM ) ) } by FUNCOP_1:13;
L263: ( IC ( SCM ) ) in ( dom ( Start-At (D23 , ( SCM )) ) ) by L262 , TARSKI:def 1;
L264: ( IC ( SCM ) ) in ( dom ( ( D22 .--> 1 ) +* ( Start-At (D23 , ( SCM )) ) ) ) by L263 , L252 , XBOOLE_0:def 3;
L265: ( IC ( SCM ) ) in ( dom D25 ) by L264 , L260 , XBOOLE_0:def 3;
L266: ( IC C24 ) = ( D25 . ( IC ( SCM ) ) ) by L265 , L253 , GRFUNC_1:2
.= ( ( ( D22 .--> 1 ) +* ( Start-At (D23 , ( SCM )) ) ) . ( IC ( SCM ) ) ) by L264 , FUNCT_4:13
.= ( ( Start-At (D23 , ( SCM )) ) . ( IC ( SCM ) ) ) by L263 , FUNCT_4:13
.= D23 by FUNCOP_1:72;
L267: D22 <> ( IC ( SCM ) ) by L7;
L268: (not D22 in ( dom ( Start-At (D23 , ( SCM )) ) )) by L267 , L262 , TARSKI:def 1;
L269: ( dom ( D22 .--> 1 ) ) = { D22 } by FUNCOP_1:13;
L270: D22 in ( dom ( D22 .--> 1 ) ) by L269 , TARSKI:def 1;
L271: D22 in ( dom ( ( D22 .--> 1 ) +* ( Start-At (D23 , ( SCM )) ) ) ) by L270 , L252 , XBOOLE_0:def 3;
L272: D22 in ( dom D25 ) by L271 , L260 , XBOOLE_0:def 3;
L273: ( C24 . D22 ) = ( D25 . D22 ) by L272 , L253 , GRFUNC_1:2
.= ( ( ( D22 .--> 1 ) +* ( Start-At (D23 , ( SCM )) ) ) . D22 ) by L271 , FUNCT_4:13
.= ( ( D22 .--> 1 ) . D22 ) by L268 , FUNCT_4:11
.= 1 by FUNCOP_1:72;
L274: ( dom ( D23 .--> ( D24 := D22 ) ) ) = { D23 } by FUNCOP_1:13;
L275: D23 in ( dom ( D23 .--> ( D24 := D22 ) ) ) by L274 , TARSKI:def 1;
L276: D23 in ( dom D27 ) by L275 , L261 , XBOOLE_0:def 3;
L277: ( C25 . D23 ) = ( D27 . D23 ) by L276 , L254 , GRFUNC_1:2
.= ( ( D23 .--> ( D24 := D22 ) ) . D23 ) by L275 , FUNCT_4:13
.= ( D24 := D22 ) by FUNCOP_1:72;
L278: ( C25 /. ( IC C24 ) ) = ( C25 . ( IC C24 ) ) by PBOOLE:143;
L279: ( ( Comput (C25 , C24 , ( ( 0 ) + 1 )) ) . D24 ) = ( ( Following (C25 , ( Comput (C25 , C24 , ( 0 )) )) ) . D24 ) by EXTPRO_1:3
.= ( ( Following (C25 , C24) ) . D24 )
.= 1 by L266 , L277 , L273 , L278 , AMI_3:2;
L280: ( dom C21 ) misses { ( IC ( SCM ) ) } by L232 , ZFMISC_1:50;
L281: ( ( dom C21 ) /\ { ( IC ( SCM ) ) } ) = ( {} ) by L280 , XBOOLE_0:def 7;
take D29 = C23;
take D30 = C25;
L282: ( dom ( ( D22 .--> ( 0 ) ) +* ( Start-At (D23 , ( SCM )) ) ) ) = ( ( dom ( D22 .--> ( 0 ) ) ) \/ ( dom ( Start-At (D23 , ( SCM )) ) ) ) by FUNCT_4:def 1
.= ( ( dom ( D22 .--> ( 0 ) ) ) \/ { ( IC ( SCM ) ) } ) by FUNCOP_1:13
.= ( { D22 } \/ { ( IC ( SCM ) ) } ) by FUNCOP_1:13;
L283: ( ( dom C21 ) /\ ( dom ( ( D22 .--> ( 0 ) ) +* ( Start-At (D23 , ( SCM )) ) ) ) ) = ( ( ( dom C21 ) /\ { D22 } ) \/ ( {} ) ) by L282 , L281 , XBOOLE_1:23
.= ( {} ) by L244 , XBOOLE_0:def 7;
L284: ( dom C21 ) misses ( dom ( ( D22 .--> ( 0 ) ) +* ( Start-At (D23 , ( SCM )) ) ) ) by L283 , XBOOLE_0:def 7;
L285: C21 c= D26 by L284 , FUNCT_4:32;
L286: C21 c= C22 by L285 , L249 , XBOOLE_1:1;
L287: ( dom C20 ) misses ( dom ( D23 .--> ( D24 := D22 ) ) ) by L274 , L247 , ZFMISC_1:50;
L288: C20 c= D28 by L287 , FUNCT_4:32;
thus L289: C20 c= D29 by L288 , L250 , XBOOLE_1:1;
L290: ( dom D26 ) = ( ( dom C21 ) \/ ( dom ( ( D22 .--> ( 0 ) ) +* ( Start-At (D23 , ( SCM )) ) ) ) ) by FUNCT_4:def 1;
L291: ( dom ( ( D22 .--> 1 ) +* ( Start-At (D23 , ( SCM )) ) ) ) = ( ( dom ( D22 .--> 1 ) ) \/ ( dom ( Start-At (D23 , ( SCM )) ) ) ) by FUNCT_4:def 1
.= ( ( dom ( D22 .--> 1 ) ) \/ { ( IC ( SCM ) ) } ) by FUNCOP_1:13
.= ( { D22 } \/ { ( IC ( SCM ) ) } ) by FUNCOP_1:13;
L292: ( ( dom C21 ) /\ ( dom ( ( D22 .--> 1 ) +* ( Start-At (D23 , ( SCM )) ) ) ) ) = ( ( ( dom C21 ) /\ { D22 } ) \/ ( {} ) ) by L291 , L234 , XBOOLE_1:23
.= ( {} ) by L251 , XBOOLE_0:def 7;
L293: ( dom C21 ) misses ( dom ( ( D22 .--> 1 ) +* ( Start-At (D23 , ( SCM )) ) ) ) by L292 , XBOOLE_0:def 7;
L294: C21 c= D25 by L293 , FUNCT_4:32;
L295: C21 c= C24 by L294 , L253 , XBOOLE_1:1;
L296: ( dom C20 ) misses ( dom ( D23 .--> ( D24 := D22 ) ) ) by L274 , L247 , ZFMISC_1:50;
L297: C20 c= D27 by L296 , FUNCT_4:32;
thus L298: C20 c= D30 by L297 , L254 , XBOOLE_1:1;
take C22;
take C24;
thus L299: C21 c= C22 by L286;
thus L300: C21 c= C24 by L295;
take 1;
L301: ( dom ( ( D22 .--> ( 0 ) ) +* ( Start-At (D23 , ( SCM )) ) ) ) = ( ( dom ( D22 .--> ( 0 ) ) ) \/ ( dom ( Start-At (D23 , ( SCM )) ) ) ) by FUNCT_4:def 1;
L302: ( dom ( Start-At (D23 , ( SCM )) ) ) = { ( IC ( SCM ) ) } by FUNCOP_1:13;
L303: ( IC ( SCM ) ) in ( dom ( Start-At (D23 , ( SCM )) ) ) by L302 , TARSKI:def 1;
L304: ( IC ( SCM ) ) in ( dom ( ( D22 .--> ( 0 ) ) +* ( Start-At (D23 , ( SCM )) ) ) ) by L303 , L301 , XBOOLE_0:def 3;
L305: ( IC ( SCM ) ) in ( dom D26 ) by L304 , L290 , XBOOLE_0:def 3;
L306: ( IC C22 ) = ( D26 . ( IC ( SCM ) ) ) by L305 , L249 , GRFUNC_1:2
.= ( ( ( D22 .--> ( 0 ) ) +* ( Start-At (D23 , ( SCM )) ) ) . ( IC ( SCM ) ) ) by L304 , FUNCT_4:13
.= ( ( Start-At (D23 , ( SCM )) ) . ( IC ( SCM ) ) ) by L303 , FUNCT_4:13
.= D23 by FUNCOP_1:72;
L307: D22 <> ( IC ( SCM ) ) by L7;
L308: (not D22 in ( dom ( Start-At (D23 , ( SCM )) ) )) by L307 , L302 , TARSKI:def 1;
L309: ( dom ( D22 .--> ( 0 ) ) ) = { D22 } by FUNCOP_1:13;
L310: D22 in ( dom ( D22 .--> ( 0 ) ) ) by L309 , TARSKI:def 1;
L311: D22 in ( dom ( ( D22 .--> ( 0 ) ) +* ( Start-At (D23 , ( SCM )) ) ) ) by L310 , L301 , XBOOLE_0:def 3;
L312: D22 in ( dom D26 ) by L311 , L290 , XBOOLE_0:def 3;
L313: ( C22 . D22 ) = ( D26 . D22 ) by L312 , L249 , GRFUNC_1:2
.= ( ( ( D22 .--> ( 0 ) ) +* ( Start-At (D23 , ( SCM )) ) ) . D22 ) by L311 , FUNCT_4:13
.= ( ( D22 .--> ( 0 ) ) . D22 ) by L308 , FUNCT_4:11
.= ( 0 ) by FUNCOP_1:72;
L314: ( dom ( D23 .--> ( D24 := D22 ) ) ) = { D23 } by FUNCOP_1:13;
L315: D23 in ( dom ( D23 .--> ( D24 := D22 ) ) ) by L314 , TARSKI:def 1;
L316: ( dom D28 ) = ( ( dom C20 ) \/ ( dom ( D23 .--> ( D24 := D22 ) ) ) ) by FUNCT_4:def 1;
L317: D23 in ( dom D28 ) by L316 , L315 , XBOOLE_0:def 3;
L318: ( C23 . D23 ) = ( D28 . D23 ) by L317 , L250 , GRFUNC_1:2
.= ( ( D23 .--> ( D24 := D22 ) ) . D23 ) by L315 , FUNCT_4:13
.= ( D24 := D22 ) by FUNCOP_1:72;
L319: ( C23 /. ( IC C22 ) ) = ( C23 . ( IC C22 ) ) by PBOOLE:143;
L320: ( ( Comput (C23 , C22 , ( ( 0 ) + 1 )) ) . D24 ) = ( ( Following (C23 , ( Comput (C23 , C22 , ( 0 )) )) ) . D24 ) by EXTPRO_1:3
.= ( 0 ) by L306 , L318 , L313 , L319 , AMI_3:2;
L321: ( ( ( Comput (D29 , C22 , 1) ) | ( dom C21 ) ) . D24 ) = ( 0 ) by L320 , L236 , L238 , L259 , FUNCT_1:47;
thus L322: ( ( Comput (D29 , C22 , 1) ) | ( dom C21 ) ) <> ( ( Comput (D30 , C24 , 1) ) | ( dom C21 ) ) by L321 , L257 , L279 , L236 , L238 , FUNCT_1:47;
end;
thus L323: contradiction by L235;
end;
thus L324: thesis by L229 , AMISTD_5:3;
end;
end;
registration
cluster ( SCM ) ->  CurIns-recognized;
coherence
proof
let C26 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function;
let C27 being C26 -autonomic non  empty (FinPartState of ( SCM ));
let C28 being (State of ( SCM ));
assume that
L326: C27 c= C28;
let C29 being (Instruction-Sequence of ( SCM ));
assume that
L327: C26 c= C29;
let C30 being (Element of ( NAT ));
set D31 = ( Comput (C29 , C28 , C30) );
set D32 = ( IC D31 );
set D33 = ( D32 + 1 );
assume L328: (not ( IC ( Comput (C29 , C28 , C30) ) ) in ( dom C26 ));
set D34 = ( ( dl. ( 0 ) ) := ( dl. ( 0 ) ) );
set D35 = ( C26 +* ( D32 .--> D34 ) );
set D36 = ( C26 +* ( D32 .--> ( halt ( SCM ) ) ) );
reconsider D37 = ( C29 +* ( D32 .--> D34 ) ) as (Instruction-Sequence of ( SCM ));
reconsider D38 = ( C29 +* ( D32 .--> ( halt ( SCM ) ) ) ) as (Instruction-Sequence of ( SCM ));
L329: ( dom ( D32 .--> ( halt ( SCM ) ) ) ) = { D32 } by FUNCOP_1:13;
L330: D32 in ( dom ( D32 .--> ( halt ( SCM ) ) ) ) by L329 , TARSKI:def 1;
L331: ( dom ( D32 .--> D34 ) ) = { D32 } by FUNCOP_1:13;
L332: D32 in ( dom ( D32 .--> D34 ) ) by L331 , TARSKI:def 1;
L333: ( dom C26 ) misses ( dom ( D32 .--> ( halt ( SCM ) ) ) ) by L328 , L329 , ZFMISC_1:50;
L334: ( dom C26 ) misses ( dom ( D32 .--> D34 ) ) by L328 , L331 , ZFMISC_1:50;
L335: D35 c= D37 by L327 , FUNCT_4:123;
L336: D36 c= D38 by L327 , FUNCT_4:123;
set D39 = ( Comput (D38 , C28 , C30) );
set D40 = ( Comput (D37 , C28 , C30) );
L337: (not C27 is C26 -autonomic)
proof
L338: ( ( D32 .--> ( halt ( SCM ) ) ) . D32 ) = ( halt ( SCM ) ) by FUNCOP_1:72;
L339: ( D38 . D32 ) = ( halt ( SCM ) ) by L338 , L330 , FUNCT_4:13;
L340: ( ( D32 .--> D34 ) . D32 ) = D34 by FUNCOP_1:72;
take D37;
take D38;
L341: C26 c= D35 by L334 , FUNCT_4:32;
thus L342: C26 c= D37 by L341 , L335 , XBOOLE_1:1;
L343: C26 c= D36 by L333 , FUNCT_4:32;
thus L344: C26 c= D38 by L343 , L336 , XBOOLE_1:1;
take C28;
take C28;
thus L345: C27 c= C28 by L326;
L346: ( D40 | ( dom C27 ) ) = ( D31 | ( dom C27 ) ) by L342 , L327 , L326 , EXTPRO_1:def 10;
thus L347: C27 c= C28 by L326;
L348: ( D40 | ( dom C27 ) ) = ( D39 | ( dom C27 ) ) by L342 , L344 , L326 , EXTPRO_1:def 10;
take D41 = ( C30 + 1 );
set D42 = ( Comput (D37 , C28 , D41) );
L349: ( IC ( SCM ) ) in ( dom C27 ) by AMISTD_5:6;
L350: ( IC D31 ) = ( IC ( D31 | ( dom C27 ) ) ) by L349 , FUNCT_1:49;
L351: ( IC D40 ) = D32 by L350 , L346 , L349 , FUNCT_1:49;
L352: ( CurInstr (D37 , D40) ) = ( D37 . D32 ) by L351 , PBOOLE:143
.= D34 by L340 , L332 , FUNCT_4:13;
L353: D42 = ( Following (D37 , D40) ) by EXTPRO_1:3
.= ( Exec (D34 , D40) ) by L352;
L354: ( IC ( Exec (D34 , D40) ) ) = ( succ ( IC D40 ) ) by AMI_3:2;
L355: ( IC ( SCM ) ) in ( dom C27 ) by AMISTD_5:6;
L356: ( IC D31 ) = ( IC ( D31 | ( dom C27 ) ) ) by L355 , FUNCT_1:49;
L357: ( IC D42 ) = ( succ D32 ) by L356 , L353 , L354 , L346 , L355 , FUNCT_1:49
.= D33 by NAT_1:38;
set D43 = ( Comput (D38 , C28 , D41) );
L358: D43 = ( Following (D38 , D39) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D38 , D39) ) , D39) );
L359: ( D38 /. ( IC D39 ) ) = ( D38 . ( IC D39 ) ) by PBOOLE:143;
L360: ( IC D39 ) = D32 by L346 , L356 , L348 , L355 , FUNCT_1:49;
L361: ( IC D43 ) = D32 by L360 , L358 , L339 , L359 , EXTPRO_1:def 3;
L362: (( IC ( D42 | ( dom C27 ) ) ) = ( IC D42 ) & ( IC ( D43 | ( dom C27 ) ) ) = ( IC D43 )) by L355 , FUNCT_1:49;
thus L363: thesis by L362 , L357 , L361;
end;
thus L364: contradiction by L337;
end;
end;
theorem
L366: (for B25 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function holds (for B26 being B25 -autonomic non  empty (FinPartState of ( SCM )) holds (for B27 , B28 being (State of ( SCM )) holds ((B26 c= B27 & B26 c= B28) implies (for B29 , B30 being (Instruction-Sequence of ( SCM )) holds ((B25 c= B29 & B25 c= B30) implies (for B31 being (Element of ( NAT )) holds (for B32 , B33 being Data-Location holds (for B34 being (Instruction of ( SCM )) holds (B34 = ( CurInstr (B29 , ( Comput (B29 , B27 , B31) )) ) implies ((B34 = ( B32 := B33 ) & B32 in ( dom B26 )) implies ( ( Comput (B29 , B27 , B31) ) . B33 ) = ( ( Comput (B30 , B28 , B31) ) . B33 ))))))))))))
proof
let C31 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function;
let C32 being C31 -autonomic non  empty (FinPartState of ( SCM ));
let C33 , C34 being (State of ( SCM ));
assume that
L367: (C32 c= C33 & C32 c= C34);
let C35 , C36 being (Instruction-Sequence of ( SCM ));
assume that
L368: (C31 c= C35 & C31 c= C36);
let C37 being (Element of ( NAT ));
let C38 , C39 being Data-Location;
let C40 being (Instruction of ( SCM ));
assume that
L369: C40 = ( CurInstr (C35 , ( Comput (C35 , C33 , C37) )) );
set D44 = ( Comput (C36 , C34 , ( C37 + 1 )) );
set D45 = ( Comput (C36 , C34 , C37) );
L370: D44 = ( Following (C36 , D45) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C36 , D45) ) , D45) );
assume that
L371: C40 = ( C38 := C39 )
and
L372: (C38 in ( dom C32 ) & ( ( Comput (C35 , C33 , C37) ) . C39 ) <> ( ( Comput (C36 , C34 , C37) ) . C39 ));
L373: C40 = ( CurInstr (C36 , ( Comput (C36 , C34 , C37) )) ) by L369 , L368 , L367 , AMISTD_5:7;
L374: ( D44 . C38 ) = ( D45 . C39 ) by L373 , L370 , L371 , AMI_3:2;
set D46 = ( Comput (C35 , C33 , ( C37 + 1 )) );
set D47 = ( Comput (C35 , C33 , C37) );
L375: (C38 in ( dom C32 ) implies (( ( D46 | ( dom C32 ) ) . C38 ) = ( D46 . C38 ) & ( ( D44 | ( dom C32 ) ) . C38 ) = ( D44 . C38 ))) by FUNCT_1:49;
L376: D46 = ( Following (C35 , D47) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C35 , D47) ) , D47) );
L377: ( D46 . C38 ) = ( D47 . C39 ) by L376 , L369 , L371 , AMI_3:2;
thus L378: contradiction by L377 , L375 , L372 , L374 , L368 , L367 , EXTPRO_1:def 10;
end;
theorem
L379: (for B35 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function holds (for B36 being B35 -autonomic non  empty (FinPartState of ( SCM )) holds (for B37 , B38 being (State of ( SCM )) holds ((B36 c= B37 & B36 c= B38) implies (for B39 , B40 being (Instruction-Sequence of ( SCM )) holds ((B35 c= B39 & B35 c= B40) implies (for B41 being (Element of ( NAT )) holds (for B42 , B43 being Data-Location holds (for B44 being (Instruction of ( SCM )) holds (B44 = ( CurInstr (B39 , ( Comput (B39 , B37 , B41) )) ) implies ((B44 = ( AddTo (B42 , B43) ) & B42 in ( dom B36 )) implies ( ( ( Comput (B39 , B37 , B41) ) . B42 ) + ( ( Comput (B39 , B37 , B41) ) . B43 ) ) = ( ( ( Comput (B40 , B38 , B41) ) . B42 ) + ( ( Comput (B40 , B38 , B41) ) . B43 ) ))))))))))))
proof
let C41 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function;
let C42 being C41 -autonomic non  empty (FinPartState of ( SCM ));
let C43 , C44 being (State of ( SCM ));
assume that
L380: (C42 c= C43 & C42 c= C44);
let C45 , C46 being (Instruction-Sequence of ( SCM ));
assume that
L381: (C41 c= C45 & C41 c= C46);
let C47 being (Element of ( NAT ));
let C48 , C49 being Data-Location;
let C50 being (Instruction of ( SCM ));
assume that
L382: C50 = ( CurInstr (C45 , ( Comput (C45 , C43 , C47) )) );
set D48 = ( Comput (C46 , C44 , ( C47 + 1 )) );
set D49 = ( Comput (C46 , C44 , C47) );
L383: D48 = ( Following (C46 , D49) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C46 , D49) ) , D49) );
assume that
L384: C50 = ( AddTo (C48 , C49) )
and
L385: (C48 in ( dom C42 ) & ( ( ( Comput (C45 , C43 , C47) ) . C48 ) + ( ( Comput (C45 , C43 , C47) ) . C49 ) ) <> ( ( ( Comput (C46 , C44 , C47) ) . C48 ) + ( ( Comput (C46 , C44 , C47) ) . C49 ) ));
L386: C50 = ( CurInstr (C46 , ( Comput (C46 , C44 , C47) )) ) by L382 , L381 , L380 , AMISTD_5:7;
L387: ( D48 . C48 ) = ( ( D49 . C48 ) + ( D49 . C49 ) ) by L386 , L383 , L384 , AMI_3:3;
set D50 = ( Comput (C45 , C43 , ( C47 + 1 )) );
set D51 = ( Comput (C45 , C43 , C47) );
L388: (C48 in ( dom C42 ) implies (( ( D50 | ( dom C42 ) ) . C48 ) = ( D50 . C48 ) & ( ( D48 | ( dom C42 ) ) . C48 ) = ( D48 . C48 ))) by FUNCT_1:49;
L389: D50 = ( Following (C45 , D51) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C45 , D51) ) , D51) );
L390: ( D50 . C48 ) = ( ( D51 . C48 ) + ( D51 . C49 ) ) by L389 , L382 , L384 , AMI_3:3;
thus L391: contradiction by L390 , L388 , L385 , L387 , L381 , L380 , EXTPRO_1:def 10;
end;
theorem
L392: (for B45 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function holds (for B46 being B45 -autonomic non  empty (FinPartState of ( SCM )) holds (for B47 , B48 being (State of ( SCM )) holds ((B46 c= B47 & B46 c= B48) implies (for B49 , B50 being (Instruction-Sequence of ( SCM )) holds ((B45 c= B49 & B45 c= B50) implies (for B51 being (Element of ( NAT )) holds (for B52 , B53 being Data-Location holds (for B54 being (Instruction of ( SCM )) holds (B54 = ( CurInstr (B49 , ( Comput (B49 , B47 , B51) )) ) implies ((B54 = ( SubFrom (B52 , B53) ) & B52 in ( dom B46 )) implies ( ( ( Comput (B49 , B47 , B51) ) . B52 ) - ( ( Comput (B49 , B47 , B51) ) . B53 ) ) = ( ( ( Comput (B50 , B48 , B51) ) . B52 ) - ( ( Comput (B50 , B48 , B51) ) . B53 ) ))))))))))))
proof
let C51 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function;
let C52 being C51 -autonomic non  empty (FinPartState of ( SCM ));
let C53 , C54 being (State of ( SCM ));
assume that
L393: (C52 c= C53 & C52 c= C54);
let C55 , C56 being (Instruction-Sequence of ( SCM ));
assume that
L394: (C51 c= C55 & C51 c= C56);
let C57 being (Element of ( NAT ));
let C58 , C59 being Data-Location;
let C60 being (Instruction of ( SCM ));
assume that
L395: C60 = ( CurInstr (C55 , ( Comput (C55 , C53 , C57) )) );
set D52 = ( Comput (C56 , C54 , ( C57 + 1 )) );
set D53 = ( Comput (C56 , C54 , C57) );
L396: D52 = ( Following (C56 , D53) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C56 , D53) ) , D53) );
assume that
L397: C60 = ( SubFrom (C58 , C59) )
and
L398: (C58 in ( dom C52 ) & ( ( ( Comput (C55 , C53 , C57) ) . C58 ) - ( ( Comput (C55 , C53 , C57) ) . C59 ) ) <> ( ( ( Comput (C56 , C54 , C57) ) . C58 ) - ( ( Comput (C56 , C54 , C57) ) . C59 ) ));
L399: C60 = ( CurInstr (C56 , ( Comput (C56 , C54 , C57) )) ) by L395 , L394 , L393 , AMISTD_5:7;
L400: ( D52 . C58 ) = ( ( D53 . C58 ) - ( D53 . C59 ) ) by L399 , L396 , L397 , AMI_3:4;
set D54 = ( Comput (C55 , C53 , ( C57 + 1 )) );
set D55 = ( Comput (C55 , C53 , C57) );
L401: (C58 in ( dom C52 ) implies (( ( D54 | ( dom C52 ) ) . C58 ) = ( D54 . C58 ) & ( ( D52 | ( dom C52 ) ) . C58 ) = ( D52 . C58 ))) by FUNCT_1:49;
L402: D54 = ( Following (C55 , D55) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C55 , D55) ) , D55) );
L403: ( D54 . C58 ) = ( ( D55 . C58 ) - ( D55 . C59 ) ) by L402 , L395 , L397 , AMI_3:4;
thus L404: contradiction by L403 , L401 , L398 , L400 , L394 , L393 , EXTPRO_1:def 10;
end;
theorem
L405: (for B55 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function holds (for B56 being B55 -autonomic non  empty (FinPartState of ( SCM )) holds (for B57 , B58 being (State of ( SCM )) holds ((B56 c= B57 & B56 c= B58) implies (for B59 , B60 being (Instruction-Sequence of ( SCM )) holds ((B55 c= B59 & B55 c= B60) implies (for B61 being (Element of ( NAT )) holds (for B62 , B63 being Data-Location holds (for B64 being (Instruction of ( SCM )) holds (B64 = ( CurInstr (B59 , ( Comput (B59 , B57 , B61) )) ) implies ((B64 = ( MultBy (B62 , B63) ) & B62 in ( dom B56 )) implies ( ( ( Comput (B59 , B57 , B61) ) . B62 ) * ( ( Comput (B59 , B57 , B61) ) . B63 ) ) = ( ( ( Comput (B60 , B58 , B61) ) . B62 ) * ( ( Comput (B60 , B58 , B61) ) . B63 ) ))))))))))))
proof
let C61 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function;
let C62 being C61 -autonomic non  empty (FinPartState of ( SCM ));
let C63 , C64 being (State of ( SCM ));
assume that
L406: (C62 c= C63 & C62 c= C64);
let C65 , C66 being (Instruction-Sequence of ( SCM ));
assume that
L407: (C61 c= C65 & C61 c= C66);
let C67 being (Element of ( NAT ));
let C68 , C69 being Data-Location;
let C70 being (Instruction of ( SCM ));
assume that
L408: C70 = ( CurInstr (C65 , ( Comput (C65 , C63 , C67) )) );
set D56 = ( Comput (C66 , C64 , ( C67 + 1 )) );
set D57 = ( Comput (C66 , C64 , C67) );
L409: D56 = ( Following (C66 , D57) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C66 , D57) ) , D57) );
assume that
L410: C70 = ( MultBy (C68 , C69) )
and
L411: (C68 in ( dom C62 ) & ( ( ( Comput (C65 , C63 , C67) ) . C68 ) * ( ( Comput (C65 , C63 , C67) ) . C69 ) ) <> ( ( ( Comput (C66 , C64 , C67) ) . C68 ) * ( ( Comput (C66 , C64 , C67) ) . C69 ) ));
L412: C70 = ( CurInstr (C66 , ( Comput (C66 , C64 , C67) )) ) by L408 , L407 , L406 , AMISTD_5:7;
L413: ( D56 . C68 ) = ( ( D57 . C68 ) * ( D57 . C69 ) ) by L412 , L409 , L410 , AMI_3:5;
set D58 = ( Comput (C65 , C63 , ( C67 + 1 )) );
set D59 = ( Comput (C65 , C63 , C67) );
L414: (C68 in ( dom C62 ) implies (( ( D58 | ( dom C62 ) ) . C68 ) = ( D58 . C68 ) & ( ( D56 | ( dom C62 ) ) . C68 ) = ( D56 . C68 ))) by FUNCT_1:49;
L415: D58 = ( Following (C65 , D59) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C65 , D59) ) , D59) );
L416: ( D58 . C68 ) = ( ( D59 . C68 ) * ( D59 . C69 ) ) by L415 , L408 , L410 , AMI_3:5;
thus L417: contradiction by L416 , L414 , L411 , L413 , L407 , L406 , EXTPRO_1:def 10;
end;
theorem
L418: (for B65 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function holds (for B66 being B65 -autonomic non  empty (FinPartState of ( SCM )) holds (for B67 , B68 being (State of ( SCM )) holds ((B66 c= B67 & B66 c= B68) implies (for B69 , B70 being (Instruction-Sequence of ( SCM )) holds ((B65 c= B69 & B65 c= B70) implies (for B71 being (Element of ( NAT )) holds (for B72 , B73 being Data-Location holds (for B74 being (Instruction of ( SCM )) holds (B74 = ( CurInstr (B69 , ( Comput (B69 , B67 , B71) )) ) implies ((B74 = ( Divide (B72 , B73) ) & B72 in ( dom B66 ) & B72 <> B73) implies ( ( ( Comput (B69 , B67 , B71) ) . B72 ) div ( ( Comput (B69 , B67 , B71) ) . B73 ) ) = ( ( ( Comput (B70 , B68 , B71) ) . B72 ) div ( ( Comput (B70 , B68 , B71) ) . B73 ) ))))))))))))
proof
let C71 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function;
let C72 being C71 -autonomic non  empty (FinPartState of ( SCM ));
let C73 , C74 being (State of ( SCM ));
assume that
L419: (C72 c= C73 & C72 c= C74);
let C75 , C76 being (Instruction-Sequence of ( SCM ));
assume that
L420: (C71 c= C75 & C71 c= C76);
let C77 being (Element of ( NAT ));
let C78 , C79 being Data-Location;
let C80 being (Instruction of ( SCM ));
assume that
L421: C80 = ( CurInstr (C75 , ( Comput (C75 , C73 , C77) )) );
set D60 = ( Comput (C76 , C74 , ( C77 + 1 )) );
set D61 = ( Comput (C76 , C74 , C77) );
L422: D60 = ( Following (C76 , D61) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C76 , D61) ) , D61) );
assume that
L423: C80 = ( Divide (C78 , C79) )
and
L424: C78 in ( dom C72 )
and
L425: C78 <> C79
and
L426: ( ( ( Comput (C75 , C73 , C77) ) . C78 ) div ( ( Comput (C75 , C73 , C77) ) . C79 ) ) <> ( ( ( Comput (C76 , C74 , C77) ) . C78 ) div ( ( Comput (C76 , C74 , C77) ) . C79 ) );
L427: C80 = ( CurInstr (C76 , ( Comput (C76 , C74 , C77) )) ) by L421 , L420 , L419 , AMISTD_5:7;
L428: ( D60 . C78 ) = ( ( D61 . C78 ) div ( D61 . C79 ) ) by L427 , L422 , L423 , L425 , AMI_3:6;
set D62 = ( Comput (C75 , C73 , ( C77 + 1 )) );
set D63 = ( Comput (C75 , C73 , C77) );
L429: (C78 in ( dom C72 ) implies (( ( D62 | ( dom C72 ) ) . C78 ) = ( D62 . C78 ) & ( ( D60 | ( dom C72 ) ) . C78 ) = ( D60 . C78 ))) by FUNCT_1:49;
L430: D62 = ( Following (C75 , D63) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C75 , D63) ) , D63) );
L431: ( D62 . C78 ) = ( ( D63 . C78 ) div ( D63 . C79 ) ) by L430 , L421 , L423 , L425 , AMI_3:6;
thus L432: contradiction by L431 , L429 , L426 , L428 , L420 , L424 , L419 , EXTPRO_1:def 10;
end;
theorem
L433: (for B75 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function holds (for B76 being B75 -autonomic non  empty (FinPartState of ( SCM )) holds (for B77 , B78 being (State of ( SCM )) holds ((B76 c= B77 & B76 c= B78) implies (for B79 , B80 being (Instruction-Sequence of ( SCM )) holds ((B75 c= B79 & B75 c= B80) implies (for B81 being (Element of ( NAT )) holds (for B82 , B83 being Data-Location holds (for B84 being (Instruction of ( SCM )) holds (B84 = ( CurInstr (B79 , ( Comput (B79 , B77 , B81) )) ) implies ((B84 = ( Divide (B82 , B83) ) & B83 in ( dom B76 )) implies ( ( ( Comput (B79 , B77 , B81) ) . B82 ) mod ( ( Comput (B79 , B77 , B81) ) . B83 ) ) = ( ( ( Comput (B80 , B78 , B81) ) . B82 ) mod ( ( Comput (B80 , B78 , B81) ) . B83 ) ))))))))))))
proof
let C81 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function;
let C82 being C81 -autonomic non  empty (FinPartState of ( SCM ));
let C83 , C84 being (State of ( SCM ));
assume that
L434: (C82 c= C83 & C82 c= C84);
let C85 , C86 being (Instruction-Sequence of ( SCM ));
assume that
L435: (C81 c= C85 & C81 c= C86);
let C87 being (Element of ( NAT ));
let C88 , C89 being Data-Location;
let C90 being (Instruction of ( SCM ));
assume that
L436: C90 = ( CurInstr (C85 , ( Comput (C85 , C83 , C87) )) );
set D64 = ( Comput (C85 , C83 , ( C87 + 1 )) );
set D65 = ( Comput (C85 , C83 , C87) );
set D66 = ( Comput (C86 , C84 , ( C87 + 1 )) );
set D67 = ( Comput (C86 , C84 , C87) );
L437: D66 = ( Following (C86 , D67) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C86 , D67) ) , D67) );
assume that
L438: C90 = ( Divide (C88 , C89) )
and
L439: C89 in ( dom C82 )
and
L440: ( ( ( Comput (C85 , C83 , C87) ) . C88 ) mod ( ( Comput (C85 , C83 , C87) ) . C89 ) ) <> ( ( ( Comput (C86 , C84 , C87) ) . C88 ) mod ( ( Comput (C86 , C84 , C87) ) . C89 ) );
L441: (( ( D64 | ( dom C82 ) ) . C89 ) = ( D64 . C89 ) & ( ( D66 | ( dom C82 ) ) . C89 ) = ( D66 . C89 )) by L439 , FUNCT_1:49;
L442: C90 = ( CurInstr (C86 , ( Comput (C86 , C84 , C87) )) ) by L436 , L435 , L434 , AMISTD_5:7;
L443: ( D66 . C89 ) = ( ( D67 . C88 ) mod ( D67 . C89 ) ) by L442 , L437 , L438 , AMI_3:6;
L444: D64 = ( Following (C85 , D65) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C85 , D65) ) , D65) );
L445: ( D64 . C89 ) = ( ( D65 . C88 ) mod ( D65 . C89 ) ) by L444 , L436 , L438 , AMI_3:6;
thus L446: contradiction by L445 , L440 , L441 , L443 , L435 , L434 , EXTPRO_1:def 10;
end;
theorem
L447: (for B85 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function holds (for B86 being B85 -autonomic non  empty (FinPartState of ( SCM )) holds (for B87 , B88 being (State of ( SCM )) holds ((B86 c= B87 & B86 c= B88) implies (for B89 , B90 being (Instruction-Sequence of ( SCM )) holds ((B85 c= B89 & B85 c= B90) implies (for B91 being (Element of ( NAT )) holds (for B92 being Data-Location holds (for B93 being (Element of ( NAT )) holds (for B94 being (Instruction of ( SCM )) holds (B94 = ( CurInstr (B89 , ( Comput (B89 , B87 , B91) )) ) implies ((B94 = ( B92 =0_goto B93 ) & B93 <> ( succ ( IC ( Comput (B89 , B87 , B91) ) ) )) implies (( ( Comput (B89 , B87 , B91) ) . B92 ) = ( 0 ) iff ( ( Comput (B90 , B88 , B91) ) . B92 ) = ( 0 ))))))))))))))
proof
let C91 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function;
let C92 being C91 -autonomic non  empty (FinPartState of ( SCM ));
let C93 , C94 being (State of ( SCM ));
assume that
L448: (C92 c= C93 & C92 c= C94);
let C95 , C96 being (Instruction-Sequence of ( SCM ));
assume that
L449: (C91 c= C95 & C91 c= C96);
let C97 being (Element of ( NAT ));
let C98 being Data-Location;
let C99 being (Element of ( NAT ));
let C100 being (Instruction of ( SCM ));
assume that
L450: C100 = ( CurInstr (C95 , ( Comput (C95 , C93 , C97) )) );
set D68 = ( Comput (C96 , C94 , ( C97 + 1 )) );
set D69 = ( Comput (C95 , C93 , ( C97 + 1 )) );
set D70 = ( Comput (C96 , C94 , C97) );
set D71 = ( Comput (C95 , C93 , C97) );
L451: D69 = ( Following (C95 , D71) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C95 , D71) ) , D71) );
L452: D68 = ( Following (C96 , D70) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C96 , D70) ) , D70) );
L453: ( IC ( SCM ) ) in ( dom C92 ) by AMISTD_5:6;
L454: (( ( D69 | ( dom C92 ) ) . ( IC ( SCM ) ) ) = ( IC D69 ) & ( ( D68 | ( dom C92 ) ) . ( IC ( SCM ) ) ) = ( IC D68 )) by L453 , FUNCT_1:49;
assume that
L455: C100 = ( C98 =0_goto C99 )
and
L456: C99 <> ( succ ( IC ( Comput (C95 , C93 , C97) ) ) );
L457: C100 = ( CurInstr (C96 , ( Comput (C96 , C94 , C97) )) ) by L450 , L449 , L448 , AMISTD_5:7;
L458:
now
assume L459: (( ( Comput (C96 , C94 , C97) ) . C98 ) = ( 0 ) & ( ( Comput (C95 , C93 , C97) ) . C98 ) <> ( 0 ));
L460: (( D68 . ( IC ( SCM ) ) ) = C99 & ( D69 . ( IC ( SCM ) ) ) = ( succ ( IC D71 ) )) by L459 , L450 , L457 , L451 , L452 , L455 , AMI_3:8;
thus L461: contradiction by L460 , L454 , L456 , L449 , L448 , EXTPRO_1:def 10;
end;
L462: ( D69 | ( dom C92 ) ) = ( D68 | ( dom C92 ) ) by L449 , L448 , EXTPRO_1:def 10;
L463:
now
assume L464: (( ( Comput (C95 , C93 , C97) ) . C98 ) = ( 0 ) & ( ( Comput (C96 , C94 , C97) ) . C98 ) <> ( 0 ));
L465: (( D69 . ( IC ( SCM ) ) ) = C99 & ( D68 . ( IC ( SCM ) ) ) = ( succ ( IC D70 ) )) by L464 , L450 , L457 , L451 , L452 , L455 , AMI_3:8;
thus L466: contradiction by L465 , L454 , L462 , L456 , L449 , L448 , AMISTD_5:7;
end;
thus L467: thesis by L463 , L458;
end;
theorem
L468: (for B95 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function holds (for B96 being B95 -autonomic non  empty (FinPartState of ( SCM )) holds (for B97 , B98 being (State of ( SCM )) holds ((B96 c= B97 & B96 c= B98) implies (for B99 , B100 being (Instruction-Sequence of ( SCM )) holds ((B95 c= B99 & B95 c= B100) implies (for B101 being (Element of ( NAT )) holds (for B102 being Data-Location holds (for B103 being (Element of ( NAT )) holds (for B104 being (Instruction of ( SCM )) holds (B104 = ( CurInstr (B99 , ( Comput (B99 , B97 , B101) )) ) implies ((B104 = ( B102 >0_goto B103 ) & B103 <> ( succ ( IC ( Comput (B99 , B97 , B101) ) ) )) implies (( ( Comput (B99 , B97 , B101) ) . B102 ) > ( 0 ) iff ( ( Comput (B100 , B98 , B101) ) . B102 ) > ( 0 ))))))))))))))
proof
let C101 being non  halt-free  finite (the InstructionsF of ( SCM )) -valued ( NAT ) -defined Function;
let C102 being C101 -autonomic non  empty (FinPartState of ( SCM ));
let C103 , C104 being (State of ( SCM ));
assume that
L469: (C102 c= C103 & C102 c= C104);
let C105 , C106 being (Instruction-Sequence of ( SCM ));
assume that
L470: (C101 c= C105 & C101 c= C106);
let C107 being (Element of ( NAT ));
let C108 being Data-Location;
let C109 being (Element of ( NAT ));
let C110 being (Instruction of ( SCM ));
assume that
L471: C110 = ( CurInstr (C105 , ( Comput (C105 , C103 , C107) )) );
set D72 = ( Comput (C106 , C104 , ( C107 + 1 )) );
set D73 = ( Comput (C105 , C103 , ( C107 + 1 )) );
L472: ( D73 | ( dom C102 ) ) = ( D72 | ( dom C102 ) ) by L470 , L469 , EXTPRO_1:def 10;
set D74 = ( Comput (C106 , C104 , C107) );
set D75 = ( Comput (C105 , C103 , C107) );
L473: D73 = ( Following (C105 , D75) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C105 , D75) ) , D75) );
L474: ( IC ( SCM ) ) in ( dom C102 ) by AMISTD_5:6;
L475: (( ( D73 | ( dom C102 ) ) . ( IC ( SCM ) ) ) = ( IC D73 ) & ( ( D72 | ( dom C102 ) ) . ( IC ( SCM ) ) ) = ( IC D72 )) by L474 , FUNCT_1:49;
L476: D72 = ( Following (C106 , D74) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C106 , D74) ) , D74) );
assume that
L477: C110 = ( C108 >0_goto C109 )
and
L478: C109 <> ( succ ( IC ( Comput (C105 , C103 , C107) ) ) );
L479: C110 = ( CurInstr (C106 , ( Comput (C106 , C104 , C107) )) ) by L471 , L470 , L469 , AMISTD_5:7;
L480:
now
assume that
L481: ( ( Comput (C106 , C104 , C107) ) . C108 ) > ( 0 )
and
L482: ( ( Comput (C105 , C103 , C107) ) . C108 ) <= ( 0 );
L483: ( D72 . ( IC ( SCM ) ) ) = C109 by L479 , L476 , L477 , L481 , AMI_3:9;
thus L484: contradiction by L483 , L471 , L473 , L475 , L472 , L477 , L478 , L482 , AMI_3:9;
end;
L485: ( IC D75 ) = ( IC D74 ) by L470 , L469 , AMISTD_5:7;
L486:
now
assume that
L487: ( ( Comput (C105 , C103 , C107) ) . C108 ) > ( 0 )
and
L488: ( ( Comput (C106 , C104 , C107) ) . C108 ) <= ( 0 );
L489: ( D73 . ( IC ( SCM ) ) ) = C109 by L471 , L473 , L477 , L487 , AMI_3:9;
thus L490: contradiction by L489 , L485 , L479 , L476 , L475 , L472 , L477 , L478 , L488 , AMI_3:9;
end;
thus L491: thesis by L486 , L480;
end;
theorem
L492: (for B105 , B106 being (State of ( SCM )) holds ((( IC B105 ) = ( IC B106 ) & (for B107 being Data-Location holds ( B105 . B107 ) = ( B106 . B107 ))) implies B105 = B106))
proof
let C111 , C112 being (State of ( SCM ));
assume that
L493: ( IC C111 ) = ( IC C112 );
L494: (( IC ( SCM ) ) in ( dom C111 ) & ( IC ( SCM ) ) in ( dom C112 )) by MEMSTR_0:2;
L495: (C111 = ( ( DataPart C111 ) +* ( Start-At (( IC C111 ) , ( SCM )) ) ) & C112 = ( ( DataPart C112 ) +* ( Start-At (( IC C112 ) , ( SCM )) ) )) by L494 , MEMSTR_0:26;
assume L496: (for B108 being Data-Location holds ( C111 . B108 ) = ( C112 . B108 ));
L497: ( DataPart C111 ) = ( DataPart C112 )
proof
L498: ( dom ( DataPart C111 ) ) = ( Data-Locations ( SCM ) ) by MEMSTR_0:9;
thus L499: ( dom ( DataPart C111 ) ) = ( dom ( DataPart C112 ) ) by L498 , MEMSTR_0:9;
let C113 being set;
assume L500: C113 in ( dom ( DataPart C111 ) );
L501: C113 is Data-Location by L500 , L498 , AMI_2:def 16 , AMI_3:27;
thus L502: ( ( DataPart C111 ) . C113 ) = ( C111 . C113 ) by L500 , L498 , FUNCT_1:49
.= ( C112 . C113 ) by L501 , L496
.= ( ( DataPart C112 ) . C113 ) by L500 , L498 , FUNCT_1:49;
end;
thus L503: thesis by L497 , L493 , L495;
end;
