:: Formalization of Ortholattices via Orthoposets
::  by Adam Grabowski and Markus Moschner
::
:: Received December 28, 2004
:: Copyright (c) 2004-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, LATTICES, SUBSET_1, EQREL_1, SHEFFER1, ROBBINS1,
      OPOSET_1, QMAX_1, FUNCT_1, WAYBEL_0, XXREAL_0, LATTICE3, STRUCT_0,
      ORDERS_2, BINOP_1, RELAT_1, FUNCT_5, ZFMISC_1, RELAT_2, FILTER_1,
      ORDERS_1, PBOOLE, TARSKI, YELLOW_0, WAYBEL_1, ROBBINS3, CARD_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, BINOP_1, RELAT_1, RELSET_1, PARTFUN1,
      RELAT_2, FUNCT_2, FUNCT_5, CARD_1, STRUCT_0, LATTICE3, LATTICES,
      ORDERS_1, ORDERS_2, FILTER_1, ROBBINS1, QMAX_1, OPOSET_1, WAYBEL_0,
      WAYBEL_1, YELLOW_0, SHEFFER1, PARTIT_2;
 constructors BINOP_1, REALSET2, LATTICE3, WAYBEL_1, YELLOW_6, OPOSET_1,
      SHEFFER1, FUNCT_5, RELSET_1, PARTIT_2;
 registrations RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, STRUCT_0, LATTICES,
      YELLOW_0, YELLOW_1, ROBBINS1, OPOSET_1, SHEFFER1, PARTIT_2, CARD_1;
 requirements SUBSET, BOOLE;
 definitions LATTICES, RELAT_2, TARSKI, STRUCT_0;
 theorems ZFMISC_1, STRUCT_0, LATTICE3, RELAT_1, FILTER_1, LATTICES, OPOSET_1,
      ORDERS_1, ROBBINS1, PARTFUN1, RELAT_2, YELLOW_0, ORDERS_2, WAYBEL_9,
      WAYBEL_1, FUNCT_2, YELLOW_7, SHEFFER1, CARD_1, PARTIT_2;

begin
definition
let C1 being non  empty \/-SemiLattStr;
attr C1 is  join-Associative
means
:L1: (for B1 , B2 , B3 being (Element of C1) holds ( B1 "\/" ( B2 "\/" B3 ) ) = ( B2 "\/" ( B1 "\/" B3 ) ));
end;
definition
let C2 being non  empty /\-SemiLattStr;
attr C2 is  meet-Associative
means
:L3: (for B4 , B5 , B6 being (Element of C2) holds ( B4 "/\" ( B5 "/\" B6 ) ) = ( B5 "/\" ( B4 "/\" B6 ) ));
end;
definition
let C3 being non  empty LattStr;
attr C3 is  meet-Absorbing
means
:L5: (for B7 , B8 being (Element of C3) holds ( B7 "\/" ( B7 "/\" B8 ) ) = B7);
end;
theorem
L7: (for B9 being non  empty LattStr holds (B9 is  meet-Associative  join-Associative  meet-Absorbing  join-absorbing implies B9 is  meet-idempotent  join-idempotent))
proof
let C4 being non  empty LattStr;
assume L8: C4 is  meet-Associative  join-Associative  meet-Absorbing  join-absorbing;
L9: (for B10 being (Element of C4) holds ( B10 "\/" B10 ) = B10)
proof
let C5 being (Element of C4);
L10: C5 = ( C5 "\/" ( C5 "/\" C5 ) ) by L8 , L5;
thus L11: thesis by L10 , L8 , LATTICES:def 9;
end;
L12: (for B11 being (Element of C4) holds ( B11 "/\" B11 ) = B11)
proof
let C6 being (Element of C4);
L13: C6 = ( C6 "/\" ( C6 "\/" C6 ) ) by L8 , LATTICES:def 9;
thus L14: thesis by L13 , L8 , L5;
end;
thus L15: thesis by L12 , L9 , ROBBINS1:def 7 , SHEFFER1:def 9;
end;
theorem
L16: (for B12 being non  empty LattStr holds (B12 is  meet-Associative  join-Associative  meet-Absorbing  join-absorbing implies B12 is  meet-commutative  join-commutative))
proof
let C7 being non  empty LattStr;
assume L17: C7 is  meet-Associative  join-Associative  meet-Absorbing  join-absorbing;
L18: C7 is  join-idempotent  meet-idempotent by L17 , L7;
L19: (for B13 , B14 being (Element of C7) holds ( B13 "/\" B14 ) = ( B14 "/\" B13 ))
proof
let C8 , C9 being (Element of C7);
L20: ( C8 "/\" C9 ) = ( C8 "/\" ( C9 "/\" ( C9 "\/" C8 ) ) ) by L17 , LATTICES:def 9
.= ( C9 "/\" ( C8 "/\" ( C9 "\/" C8 ) ) ) by L17 , L3
.= ( C9 "/\" ( C8 "/\" ( C9 "\/" ( C8 "\/" C8 ) ) ) ) by L18 , ROBBINS1:def 7
.= ( C9 "/\" ( C8 "/\" ( C8 "\/" ( C9 "\/" C8 ) ) ) ) by L17 , L1
.= ( C9 "/\" C8 ) by L17 , LATTICES:def 9;
thus L21: thesis by L20;
end;
L22: (for B15 , B16 being (Element of C7) holds ( B15 "\/" B16 ) = ( B16 "\/" B15 ))
proof
let C10 , C11 being (Element of C7);
L23: ( C10 "\/" C11 ) = ( C10 "\/" ( C11 "\/" ( C11 "/\" C10 ) ) ) by L17 , L5
.= ( C11 "\/" ( C10 "\/" ( C11 "/\" C10 ) ) ) by L17 , L1
.= ( C11 "\/" ( C10 "\/" ( C11 "/\" ( C10 "/\" C10 ) ) ) ) by L18 , SHEFFER1:def 9
.= ( C11 "\/" ( C10 "\/" ( C10 "/\" ( C11 "/\" C10 ) ) ) ) by L17 , L3
.= ( C11 "\/" C10 ) by L17 , L5;
thus L24: thesis by L23;
end;
thus L25: thesis by L22 , L19 , LATTICES:def 4 , LATTICES:def 6;
end;
theorem
L26: (for B17 being non  empty LattStr holds (B17 is  meet-Associative  join-Associative  meet-Absorbing  join-absorbing implies B17 is  meet-absorbing))
proof
let C12 being non  empty LattStr;
assume L27: C12 is  meet-Associative  join-Associative  meet-Absorbing  join-absorbing;
L28: C12 is  meet-commutative  join-commutative by L27 , L16;
L29: (for B18 , B19 being (Element of C12) holds ( ( B18 "/\" B19 ) "\/" B19 ) = B19)
proof
let C13 , C14 being (Element of C12);
L30: C14 = ( C14 "\/" ( C14 "/\" C13 ) ) by L27 , L5
.= ( C14 "\/" ( C13 "/\" C14 ) ) by L28 , LATTICES:def 6
.= ( ( C13 "/\" C14 ) "\/" C14 ) by L28 , LATTICES:def 4;
thus L31: thesis by L30;
end;
thus L32: thesis by L29 , LATTICES:def 8;
end;
theorem
L33: (for B20 being non  empty LattStr holds (B20 is  meet-Associative  join-Associative  meet-Absorbing  join-absorbing implies B20 is  meet-associative  join-associative))
proof
let C15 being non  empty LattStr;
assume L34: C15 is  meet-Associative  join-Associative  meet-Absorbing  join-absorbing;
L35: C15 is  meet-commutative  join-commutative by L34 , L16;
L36: (for B21 , B22 , B23 being (Element of C15) holds ( B21 "\/" ( B22 "\/" B23 ) ) = ( ( B21 "\/" B22 ) "\/" B23 ))
proof
let C16 , C17 , C18 being (Element of C15);
L37: ( C16 "\/" ( C17 "\/" C18 ) ) = ( C16 "\/" ( C18 "\/" C17 ) ) by L35 , LATTICES:def 4
.= ( C18 "\/" ( C16 "\/" C17 ) ) by L34 , L1
.= ( ( C16 "\/" C17 ) "\/" C18 ) by L35 , LATTICES:def 4;
thus L38: thesis by L37;
end;
L39: (for B24 , B25 , B26 being (Element of C15) holds ( B24 "/\" ( B25 "/\" B26 ) ) = ( ( B24 "/\" B25 ) "/\" B26 ))
proof
let C19 , C20 , C21 being (Element of C15);
L40: ( C19 "/\" ( C20 "/\" C21 ) ) = ( C19 "/\" ( C21 "/\" C20 ) ) by L35 , LATTICES:def 6
.= ( C21 "/\" ( C19 "/\" C20 ) ) by L34 , L3
.= ( ( C19 "/\" C20 ) "/\" C21 ) by L35 , LATTICES:def 6;
thus L41: thesis by L40;
end;
thus L42: thesis by L39 , L36 , LATTICES:def 5 , LATTICES:def 7;
end;
theorem
L43: (for B27 being non  empty LattStr holds (B27 is  Lattice-like iff B27 is  meet-Associative  join-Associative  meet-Absorbing  join-absorbing))
proof
let C22 being non  empty LattStr;
L44: (C22 is  Lattice-like implies C22 is  meet-Associative  join-Associative  meet-Absorbing  join-absorbing)
proof
assume L45: C22 is  Lattice-like;
L46: (for B28 , B29 , B30 being (Element of C22) holds ( B28 "/\" ( B29 "/\" B30 ) ) = ( B29 "/\" ( B28 "/\" B30 ) ))
proof
let C23 , C24 , C25 being (Element of C22);
L47: ( C23 "/\" ( C24 "/\" C25 ) ) = ( ( C23 "/\" C24 ) "/\" C25 ) by L45 , LATTICES:def 7
.= ( ( C24 "/\" C23 ) "/\" C25 ) by L45 , LATTICES:def 6
.= ( C24 "/\" ( C23 "/\" C25 ) ) by L45 , LATTICES:def 7;
thus L48: thesis by L47;
end;
L49: (for B31 , B32 being (Element of C22) holds ( B31 "\/" ( B31 "/\" B32 ) ) = B31)
proof
let C26 , C27 being (Element of C22);
L50: C26 = ( ( C27 "/\" C26 ) "\/" C26 ) by L45 , LATTICES:def 8
.= ( ( C26 "/\" C27 ) "\/" C26 ) by L45 , LATTICES:def 6
.= ( C26 "\/" ( C26 "/\" C27 ) ) by L45 , LATTICES:def 4;
thus L51: thesis by L50;
end;
L52: (for B33 , B34 , B35 being (Element of C22) holds ( B33 "\/" ( B34 "\/" B35 ) ) = ( B34 "\/" ( B33 "\/" B35 ) ))
proof
let C28 , C29 , C30 being (Element of C22);
L53: ( C28 "\/" ( C29 "\/" C30 ) ) = ( ( C28 "\/" C29 ) "\/" C30 ) by L45 , LATTICES:def 5
.= ( ( C29 "\/" C28 ) "\/" C30 ) by L45 , LATTICES:def 4
.= ( C29 "\/" ( C28 "\/" C30 ) ) by L45 , LATTICES:def 5;
thus L54: thesis by L53;
end;
thus L55: thesis by L52 , L45 , L46 , L49 , L1 , L3 , L5;
end;
L56: (C22 is  meet-Associative  join-Associative  meet-Absorbing  join-absorbing implies C22 is  Lattice-like)
proof
assume L57: C22 is  meet-Associative  join-Associative  meet-Absorbing  join-absorbing;
L58: C22 is  meet-absorbing by L57 , L26;
L59: (C22 is  meet-commutative  join-commutative & C22 is  meet-associative  join-associative) by L57 , L16 , L33;
thus L60: thesis by L59 , L57 , L58;
end;
thus L61: thesis by L56 , L44;
end;
registration
cluster  Lattice-like ->  meet-Associative  join-Associative  meet-Absorbing for non  empty non  empty non  empty non  empty LattStr;
coherence by L43;
cluster  meet-Associative  join-Associative  meet-Absorbing  join-absorbing ->  Lattice-like for non  empty non  empty non  empty non  empty LattStr;
coherence by L43;
end;
begin
registration
cluster  OrderInvolutive ->  Dneg for  PartialOrdered non  empty  PartialOrdered non  empty  PartialOrdered non  empty  PartialOrdered non  empty OrthoRelStr;
coherence
proof
let C31 being  PartialOrdered non  empty OrthoRelStr;
assume L63: C31 is  OrderInvolutive;
consider C32 being (Function of C31 , C31) such that L64: C32 = (the Compl of C31) and L65: C32 is  Orderinvolutive by L63 , OPOSET_1:def 18;
L66: C32 is  involutive  antitone by L65 , OPOSET_1:def 17;
thus L67: thesis by L66 , L64 , OPOSET_1:def 3;
end;
end;
theorem
L69: (for B36 being  Dneg non  empty OrthoRelStr holds (for B37 being (Element of B36) holds ( ( B37 ` ) ` ) = B37))
proof
let C33 being  Dneg non  empty OrthoRelStr;
let C34 being (Element of C33);
consider C35 being (Function of C33 , C33) such that L70: C35 = (the Compl of C33) and L71: C35 is  involutive by OPOSET_1:def 3;
L72: (( C35 . C34 ) = ( C34 ` ) & ( C35 . ( C35 . C34 ) ) = C34) by L70 , L71 , PARTIT_2:def 3 , ROBBINS1:def 3;
thus L73: thesis by L72 , L70 , ROBBINS1:def 3;
end;
theorem
L74: (for B38 being  OrderInvolutive  PartialOrdered non  empty OrthoRelStr holds (for B39 , B40 being (Element of B38) holds (B39 <= B40 implies ( B40 ` ) <= ( B39 ` ))))
proof
let C36 being  OrderInvolutive  PartialOrdered non  empty OrthoRelStr;
let C37 , C38 being (Element of C36);
assume L75: C37 <= C38;
consider C39 being (Function of C36 , C36) such that L76: C39 = (the Compl of C36) and L77: C39 is  Orderinvolutive by OPOSET_1:def 18;
L78: C39 is  involutive  antitone by L77 , OPOSET_1:def 17;
L79: ( C39 . C37 ) >= ( C39 . C38 ) by L78 , L75 , WAYBEL_9:def 1;
L80: ( C37 ` ) >= ( C39 . C38 ) by L79 , L76 , ROBBINS1:def 3;
thus L81: thesis by L80 , L76 , ROBBINS1:def 3;
end;
registration
cluster  with_infima  with_suprema  strict for PreOrthoPoset;
existence
proof
take ( TrivOrthoRelStr );
thus L82: thesis;
end;
end;
notation
let C40 being non  empty \/-SemiLattStr;
let C41 , C42 being (Element of C40);
synonym C41 |_| C42 for C41 "\/" C42;
end;
notation
let C43 being non  empty /\-SemiLattStr;
let C44 , C45 being (Element of C43);
synonym C44 |^| C45 for C44 "/\" C45;
end;
notation
let C46 being non  empty RelStr;
let C47 , C48 being (Element of C46);
synonym C47 "|^|" C48 for C47 "/\" C48;
synonym C47 "|_|" C48 for C47 "\/" C48;
end;
begin
definition
struct (\/-SemiLattStr , RelStr) \/-SemiLattRelStr(# carrier -> set , L_join -> (BinOp of the carrier) , InternalRel -> (Relation of the carrier) #);
end;
definition
struct (/\-SemiLattStr , RelStr) /\-SemiLattRelStr(# carrier -> set , L_meet -> (BinOp of the carrier) , InternalRel -> (Relation of the carrier) #);
end;
definition
struct (/\-SemiLattRelStr , \/-SemiLattRelStr , LattStr) LattRelStr(# carrier -> set , L_join , L_meet -> (BinOp of the carrier) , InternalRel -> (Relation of the carrier) #);
end;
definition
func TrivLattRelStr -> LattRelStr equals 
LattRelStr (# 1 , ( op2 ) , ( op2 ) , ( id 1 ) #);
coherence;
end;
registration
cluster ( TrivLattRelStr ) -> 1 -element;
coherence
proof
L91: (the carrier of ( TrivLattRelStr )) = { ( 0 ) } by CARD_1:49;
thus L92: (the carrier of ( TrivLattRelStr )) is 1 -element by L91;
end;
end;
registration
cluster non  empty for \/-SemiLattRelStr;
existence
proof
take ( TrivLattRelStr );
thus L94: thesis;
end;
cluster non  empty for /\-SemiLattRelStr;
existence
proof
take ( TrivLattRelStr );
thus L95: thesis;
end;
cluster non  empty for LattRelStr;
existence
proof
take ( TrivLattRelStr );
thus L96: thesis;
end;
end;
theorem
L98: (for B41 being non  empty RelStr holds (((the InternalRel of B41) is_reflexive_in (the carrier of B41) & (the InternalRel of B41) is  antisymmetric  transitive) implies B41 is  reflexive  antisymmetric  transitive))
proof
let C49 being non  empty RelStr;
set D1 = (the InternalRel of C49);
set D2 = (the carrier of C49);
assume that
L99: D1 is_reflexive_in D2
and
L100: D1 is  antisymmetric  transitive;
L101: D1 is_transitive_in ( field D1 ) by L100 , RELAT_2:def 16;
L102: ( field D1 ) = D2 by L99 , PARTIT_2:21;
L103: D1 is_antisymmetric_in D2 by L102 , L100 , RELAT_2:def 12;
thus L104: thesis by L103 , L99 , L102 , L101 , ORDERS_2:def 2 , ORDERS_2:def 3 , ORDERS_2:def 4;
end;
registration
cluster ( TrivLattRelStr ) ->  reflexive;
coherence
proof
set D3 = ( TrivLattRelStr );
set D4 = (the carrier of D3);
set D5 = (the InternalRel of D3);
L105: ( field D5 ) = D4 by PARTIT_2:18;
L106: D5 is_reflexive_in D4 by L105 , RELAT_2:def 9;
thus L107: thesis by L106 , ORDERS_2:def 2;
end;
end;
registration
cluster  antisymmetric  reflexive  transitive  with_suprema  with_infima for LattRelStr;
existence
proof
take ( TrivLattRelStr );
thus L109: thesis;
end;
end;
registration
cluster ( TrivLattRelStr ) ->  meet-Absorbing;
coherence;
end;
L112: ( TrivLattRelStr ) is  Lattice-like;
registration
cluster  Lattice-like for non  empty non  empty non  empty non  empty LattRelStr;
existence by L112;
end;
definition
let C50 being Lattice;
redefine func LattRel C50 -> (Order of (the carrier of C50));

coherence
proof
L114: ( LattRel C50 ) = { [ B42 , B43 ] where B42 is (Element of C50) , B43 is (Element of C50) : B42 [= B43 } by FILTER_1:def 8;
L115: ( LattRel C50 ) c= [: (the carrier of C50) , (the carrier of C50) :]
proof
let C51 being set;
assume L116: C51 in ( LattRel C50 );
L117: (ex B44 , B45 being (Element of C50) st (C51 = [ B44 , B45 ] & B44 [= B45)) by L116 , L114;
thus L118: thesis by L117 , ZFMISC_1:87;
end;
reconsider D6 = ( LattRel C50 ) as (Relation of (the carrier of C50)) by L115;
L119: D6 is_antisymmetric_in (the carrier of C50)
proof
let C52 , C53 being set;
assume L120: (C52 in (the carrier of C50) & C53 in (the carrier of C50));
reconsider D7 = C52 , D8 = C53 as (Element of C50) by L120;
assume L121: ([ C52 , C53 ] in D6 & [ C53 , C52 ] in D6);
L122: (D7 [= D8 & D8 [= D7) by L121 , FILTER_1:31;
thus L123: thesis by L122 , LATTICES:8;
end;
L124: D6 is_transitive_in (the carrier of C50)
proof
let C54 , C55 , C56 being set;
assume L125: (C54 in (the carrier of C50) & C55 in (the carrier of C50) & C56 in (the carrier of C50));
reconsider D9 = C54 , D10 = C55 , D11 = C56 as (Element of C50) by L125;
assume L126: ([ C54 , C55 ] in D6 & [ C55 , C56 ] in D6);
L127: (D9 [= D10 & D10 [= D11) by L126 , FILTER_1:31;
L128: D9 [= D11 by L127 , LATTICES:7;
thus L129: thesis by L128 , FILTER_1:31;
end;
L130: D6 is_reflexive_in (the carrier of C50)
proof
let C57 being set;
assume L131: C57 in (the carrier of C50);
reconsider D12 = C57 as (Element of C50) by L131;
L132: D12 [= D12;
thus L133: thesis by L132 , FILTER_1:31;
end;
L134: (( dom D6 ) = (the carrier of C50) & ( field D6 ) = (the carrier of C50)) by L130 , ORDERS_1:13;
thus L135: thesis by L134 , L130 , L119 , L124 , PARTFUN1:def 2 , RELAT_2:def 9 , RELAT_2:def 12 , RELAT_2:def 16;
end;
end;
begin
definition
struct (LattRelStr , OrthoLattStr , OrthoRelStr) OrthoLattRelStr(# carrier -> set , L_join , L_meet -> (BinOp of the carrier) , InternalRel -> (Relation of the carrier) , Compl -> (UnOp of the carrier) #);
end;
definition
func TrivCLRelStr -> OrthoLattRelStr equals 
OrthoLattRelStr (# 1 , ( op2 ) , ( op2 ) , ( id 1 ) , ( op1 ) #);
coherence;
end;
definition
let C58 being non  empty ComplStr;
attr C58 is  involutive
means
:L139: (for B46 being (Element of C58) holds ( ( B46 ` ) ` ) = B46);
end;
definition
let C59 being non  empty ComplLLattStr;
attr C59 is  with_Top
means
:L141: (for B47 , B48 being (Element of C59) holds ( B47 |_| ( B47 ` ) ) = ( B48 |_| ( B48 ` ) ));
end;
registration
cluster ( TrivOrtLat ) ->  involutive  with_Top;
coherence
proof
thus L143: ( TrivOrtLat ) is  involutive
proof
let C60 being (Element of ( TrivOrtLat ));
thus L144: thesis by STRUCT_0:def 10;
end;

thus L145: ( TrivOrtLat ) is  with_Top
proof
let C61 , C62 being (Element of ( TrivOrtLat ));
thus L146: thesis by STRUCT_0:def 10;
end;

end;
end;
registration
cluster ( TrivCLRelStr ) -> 1 -element;
coherence
proof
L147: (the carrier of ( TrivCLRelStr )) = { ( 0 ) } by CARD_1:49;
thus L148: (the carrier of ( TrivCLRelStr )) is 1 -element by L147;
end;
end;
registration
cluster ( TrivCLRelStr ) ->  reflexive;
coherence
proof
L150: (for B49 being (Element of ( TrivCLRelStr )) holds B49 <= B49)
proof
let C63 being (Element of ( TrivCLRelStr ));
L151: [ C63 , C63 ] in ( id { ( {} ) } ) by CARD_1:49 , RELAT_1:def 10;
thus L152: thesis by L151 , CARD_1:49 , ORDERS_2:def 5;
end;
thus L153: thesis by L150 , YELLOW_0:def 1;
end;
end;
registration
cluster ( TrivCLRelStr ) ->  involutive  with_Top;
coherence
proof
set D13 = ( TrivCLRelStr );
thus L155: D13 is  involutive
proof
let C64 being (Element of D13);
thus L156: thesis by STRUCT_0:def 10;
end;

thus L157: D13 is  with_Top
proof
let C65 , C66 being (Element of D13);
thus L158: thesis by STRUCT_0:def 10;
end;

end;
end;
registration
cluster  involutive  with_Top  de_Morgan  Lattice-like for 1 -element 1 -element 1 -element 1 -element OrthoLattStr;
existence
proof
take ( TrivOrtLat );
thus L159: thesis;
end;
end;
definition
mode Ortholattice
 is  involutive  with_Top  de_Morgan  Lattice-like non  empty OrthoLattStr;
end;
begin
theorem
L162: (for B50 , B51 being non  empty LattStr holds ((( the LattStr of B50 ) = ( the LattStr of B51 ) & B50 is  join-commutative) implies B51 is  join-commutative))
proof
let C67 , C68 being non  empty LattStr;
assume that
L163: ( the LattStr of C67 ) = ( the LattStr of C68 )
and
L164: C67 is  join-commutative;
L165: C68 is  join-commutative
proof
let C69 , C70 being (Element of C68);
reconsider D14 = C69 , D15 = C70 as (Element of C67) by L163;
L166: ( D14 |_| D15 ) = ( D15 |_| D14 ) by L164 , LATTICES:def 4;
thus L167: thesis by L166 , L163;
end;
thus L168: thesis by L165;
end;
theorem
L169: (for B52 , B53 being non  empty LattStr holds ((( the LattStr of B52 ) = ( the LattStr of B53 ) & B52 is  meet-commutative) implies B53 is  meet-commutative))
proof
let C71 , C72 being non  empty LattStr;
assume that
L170: ( the LattStr of C71 ) = ( the LattStr of C72 )
and
L171: C71 is  meet-commutative;
L172: C72 is  meet-commutative
proof
let C73 , C74 being (Element of C72);
reconsider D16 = C73 , D17 = C74 as (Element of C71) by L170;
L173: ( D16 "/\" D17 ) = ( D17 "/\" D16 ) by L171 , LATTICES:def 6;
thus L174: thesis by L173 , L170;
end;
thus L175: thesis by L172;
end;
theorem
L176: (for B54 , B55 being non  empty LattStr holds ((( the LattStr of B54 ) = ( the LattStr of B55 ) & B54 is  join-associative) implies B55 is  join-associative))
proof
let C75 , C76 being non  empty LattStr;
assume that
L177: ( the LattStr of C75 ) = ( the LattStr of C76 )
and
L178: C75 is  join-associative;
L179: C76 is  join-associative
proof
let C77 , C78 , C79 being (Element of C76);
reconsider D18 = C77 , D19 = C78 , D20 = C79 as (Element of C75) by L177;
L180: ( ( D18 |_| D19 ) |_| D20 ) = ( D18 |_| ( D19 |_| D20 ) ) by L178 , LATTICES:def 5;
thus L181: thesis by L180 , L177;
end;
thus L182: thesis by L179;
end;
theorem
L183: (for B56 , B57 being non  empty LattStr holds ((( the LattStr of B56 ) = ( the LattStr of B57 ) & B56 is  meet-associative) implies B57 is  meet-associative))
proof
let C80 , C81 being non  empty LattStr;
assume that
L184: ( the LattStr of C80 ) = ( the LattStr of C81 )
and
L185: C80 is  meet-associative;
L186: C81 is  meet-associative
proof
let C82 , C83 , C84 being (Element of C81);
reconsider D21 = C82 , D22 = C83 , D23 = C84 as (Element of C80) by L184;
L187: ( ( D21 "/\" D22 ) "/\" D23 ) = ( D21 "/\" ( D22 "/\" D23 ) ) by L185 , LATTICES:def 7;
thus L188: thesis by L187 , L184;
end;
thus L189: thesis by L186;
end;
theorem
L190: (for B58 , B59 being non  empty LattStr holds ((( the LattStr of B58 ) = ( the LattStr of B59 ) & B58 is  join-absorbing) implies B59 is  join-absorbing))
proof
let C85 , C86 being non  empty LattStr;
assume that
L191: ( the LattStr of C85 ) = ( the LattStr of C86 )
and
L192: C85 is  join-absorbing;
L193: C86 is  join-absorbing
proof
let C87 , C88 being (Element of C86);
reconsider D24 = C87 , D25 = C88 as (Element of C85) by L191;
L194: ( D24 "/\" ( D24 "\/" D25 ) ) = D24 by L192 , LATTICES:def 9;
thus L195: thesis by L194 , L191;
end;
thus L196: thesis by L193;
end;
theorem
L197: (for B60 , B61 being non  empty LattStr holds ((( the LattStr of B60 ) = ( the LattStr of B61 ) & B60 is  meet-absorbing) implies B61 is  meet-absorbing))
proof
let C89 , C90 being non  empty LattStr;
assume that
L198: ( the LattStr of C89 ) = ( the LattStr of C90 )
and
L199: C89 is  meet-absorbing;
L200: C90 is  meet-absorbing
proof
let C91 , C92 being (Element of C90);
reconsider D26 = C91 , D27 = C92 as (Element of C89) by L198;
L201: ( ( D26 "/\" D27 ) "\/" D27 ) = D27 by L199 , LATTICES:def 8;
thus L202: thesis by L201 , L198;
end;
thus L203: thesis by L200;
end;
theorem
L204: (for B62 , B63 being non  empty LattStr holds ((( the LattStr of B62 ) = ( the LattStr of B63 ) & B62 is  Lattice-like) implies B63 is  Lattice-like))
proof
let C93 , C94 being non  empty LattStr;
assume L205: (( the LattStr of C93 ) = ( the LattStr of C94 ) & C93 is  Lattice-like);
L206: C94 is  join-commutative  join-associative  meet-absorbing  meet-commutative  meet-associative  join-absorbing by L205 , L162 , L169 , L176 , L183 , L190 , L197;
thus L207: thesis by L206;
end;
theorem
L208: (for B64 , B65 being non  empty \/-SemiLattStr holds (( the \/-SemiLattStr of B64 ) = ( the \/-SemiLattStr of B65 ) implies (for B66 , B67 being (Element of B64) holds (for B68 , B69 being (Element of B65) holds ((B66 = B68 & B67 = B69) implies ( B66 "\/" B67 ) = ( B68 "\/" B69 ))))));
theorem
L209: (for B70 , B71 being non  empty /\-SemiLattStr holds (( the /\-SemiLattStr of B70 ) = ( the /\-SemiLattStr of B71 ) implies (for B72 , B73 being (Element of B70) holds (for B74 , B75 being (Element of B71) holds ((B72 = B74 & B73 = B75) implies ( B72 "/\" B73 ) = ( B74 "/\" B75 ))))));
theorem
L210: (for B76 , B77 being non  empty ComplStr holds (for B78 being (Element of B76) holds (for B79 being (Element of B77) holds (((the Compl of B76) = (the Compl of B77) & B78 = B79) implies ( B78 ` ) = ( B79 ` )))))
proof
let C95 , C96 being non  empty ComplStr;
let C97 being (Element of C95);
let C98 being (Element of C96);
assume L211: ((the Compl of C95) = (the Compl of C96) & C97 = C98);
L212: ( C97 ` ) = ( (the Compl of C96) . C98 ) by L211 , ROBBINS1:def 3
.= ( C98 ` ) by ROBBINS1:def 3;
thus L213: thesis by L212;
end;
theorem
L214: (for B80 , B81 being non  empty ComplLLattStr holds ((( the ComplLLattStr of B80 ) = ( the ComplLLattStr of B81 ) & B80 is  with_Top) implies B81 is  with_Top))
proof
let C99 , C100 being non  empty ComplLLattStr;
assume that
L215: ( the ComplLLattStr of C99 ) = ( the ComplLLattStr of C100 )
and
L216: C99 is  with_Top;
L217: (for B82 , B83 being (Element of C100) holds ( B82 |_| ( B82 ` ) ) = ( B83 |_| ( B83 ` ) ))
proof
let C101 , C102 being (Element of C100);
reconsider D28 = C101 , D29 = C102 as (Element of C99) by L215;
L218: ( C101 |_| ( C101 ` ) ) = ( D28 |_| ( D28 ` ) ) by L215 , L210
.= ( D29 |_| ( D29 ` ) ) by L216 , L141
.= ( C102 |_| ( C102 ` ) ) by L215 , L210;
thus L219: thesis by L218;
end;
thus L220: thesis by L217 , L141;
end;
theorem
L221: (for B84 , B85 being non  empty OrthoLattStr holds ((( the OrthoLattStr of B84 ) = ( the OrthoLattStr of B85 ) & B84 is  de_Morgan) implies B85 is  de_Morgan))
proof
let C103 , C104 being non  empty OrthoLattStr;
assume that
L222: ( the OrthoLattStr of C103 ) = ( the OrthoLattStr of C104 )
and
L223: C103 is  de_Morgan;
L224: (for B86 , B87 being (Element of C104) holds ( B86 "/\" B87 ) = ( ( ( B86 ` ) "\/" ( B87 ` ) ) ` ))
proof
let C105 , C106 being (Element of C104);
reconsider D30 = C105 , D31 = C106 as (Element of C103) by L222;
L225: (( C105 ` ) = ( D30 ` ) & ( C106 ` ) = ( D31 ` )) by L222 , L210;
L226: ( C105 "/\" C106 ) = ( D30 "/\" D31 ) by L222
.= ( ( ( D30 ` ) "\/" ( D31 ` ) ) ` ) by L223 , ROBBINS1:def 23
.= ( ( ( C105 ` ) "\/" ( C106 ` ) ) ` ) by L222 , L225 , L210;
thus L227: thesis by L226;
end;
thus L228: thesis by L224 , ROBBINS1:def 23;
end;
theorem
L229: (for B88 , B89 being non  empty OrthoLattStr holds ((( the OrthoLattStr of B88 ) = ( the OrthoLattStr of B89 ) & B88 is  involutive) implies B89 is  involutive))
proof
let C107 , C108 being non  empty OrthoLattStr;
assume that
L230: ( the OrthoLattStr of C107 ) = ( the OrthoLattStr of C108 )
and
L231: C107 is  involutive;
L232: (for B90 being (Element of C108) holds ( ( B90 ` ) ` ) = B90)
proof
let C109 being (Element of C108);
reconsider D32 = C109 as (Element of C107) by L230;
L233: ( C109 ` ) = ( D32 ` ) by L230 , L210;
L234: ( ( C109 ` ) ` ) = ( ( D32 ` ) ` ) by L233 , L230 , L210
.= C109 by L231 , L139;
thus L235: thesis by L234;
end;
thus L236: thesis by L232 , L139;
end;
begin
definition
let C110 being RelStr;
mode RelAugmentation of C110
 -> LattRelStr
means ( the RelStr of it ) = ( the RelStr of C110 );
existence
proof
set D33 = the (BinOp of (the carrier of C110));
set D34 = LattRelStr (# (the carrier of C110) , D33 , D33 , (the InternalRel of C110) #);
take D34;
thus L237: thesis;
end;
end;
definition
let C111 being LattStr;
mode LatAugmentation of C111
 -> LattRelStr
means :L239: ( the LattStr of it ) = ( the LattStr of C111 );
existence
proof
set D35 = the (Relation of (the carrier of C111));
set D36 = LattRelStr (# (the carrier of C111) , (the L_join of C111) , (the L_meet of C111) , D35 #);
take D36;
thus L240: thesis;
end;
end;
registration
let C112 being non  empty LattStr;
cluster  -> non  empty for (LatAugmentation of C112);
coherence
proof
let C113 being (LatAugmentation of C112);
L242: ( the LattStr of C112 ) = ( the LattStr of C113 ) by L239;
thus L243: thesis by L242;
end;
end;
registration
let C114 being  meet-associative non  empty LattStr;
cluster  ->  meet-associative for (LatAugmentation of C114);
coherence
proof
let C115 being (LatAugmentation of C114);
L245: ( the LattStr of C114 ) = ( the LattStr of C115 ) by L239;
thus L246: thesis by L245 , L183;
end;
end;
registration
let C116 being  join-associative non  empty LattStr;
cluster  ->  join-associative for (LatAugmentation of C116);
coherence
proof
let C117 being (LatAugmentation of C116);
L248: ( the LattStr of C116 ) = ( the LattStr of C117 ) by L239;
thus L249: thesis by L248 , L176;
end;
end;
registration
let C118 being  meet-commutative non  empty LattStr;
cluster  ->  meet-commutative for (LatAugmentation of C118);
coherence
proof
let C119 being (LatAugmentation of C118);
L251: ( the LattStr of C118 ) = ( the LattStr of C119 ) by L239;
thus L252: thesis by L251 , L169;
end;
end;
registration
let C120 being  join-commutative non  empty LattStr;
cluster  ->  join-commutative for (LatAugmentation of C120);
coherence
proof
let C121 being (LatAugmentation of C120);
L254: ( the LattStr of C120 ) = ( the LattStr of C121 ) by L239;
thus L255: thesis by L254 , L162;
end;
end;
registration
let C122 being  join-absorbing non  empty LattStr;
cluster  ->  join-absorbing for (LatAugmentation of C122);
coherence
proof
let C123 being (LatAugmentation of C122);
L257: ( the LattStr of C122 ) = ( the LattStr of C123 ) by L239;
thus L258: thesis by L257 , L190;
end;
end;
registration
let C124 being  meet-absorbing non  empty LattStr;
cluster  ->  meet-absorbing for (LatAugmentation of C124);
coherence
proof
let C125 being (LatAugmentation of C124);
L260: ( the LattStr of C124 ) = ( the LattStr of C125 ) by L239;
thus L261: thesis by L260 , L197;
end;
end;
definition
let C126 being non  empty \/-SemiLattRelStr;
attr C126 is  naturally_sup-generated
means
:L263: (for B91 , B92 being (Element of C126) holds (B91 <= B92 iff ( B91 |_| B92 ) = B92));
end;
definition
let C127 being non  empty /\-SemiLattRelStr;
attr C127 is  naturally_inf-generated
means
:L265: (for B93 , B94 being (Element of C127) holds (B93 <= B94 iff ( B93 |^| B94 ) = B93));
end;
registration
let C128 being Lattice;
cluster  naturally_sup-generated  naturally_inf-generated  Lattice-like for (LatAugmentation of C128);
existence
proof
set D37 = ( LattRel C128 );
set D38 = LattRelStr (# (the carrier of C128) , (the L_join of C128) , (the L_meet of C128) , D37 #);
L267: ( the LattStr of C128 ) = ( the LattStr of D38 );
reconsider D39 = D38 as (LatAugmentation of C128) by L267 , L239;
L268: (for B95 , B96 being (Element of D39) holds (B95 <= B96 iff ( B95 |^| B96 ) = B95))
proof
let C129 , C130 being (Element of D39);
reconsider D40 = C129 , D41 = C130 as (Element of C128);
thus L269:now
assume L270: C129 <= C130;
L271: [ C129 , C130 ] in (the InternalRel of D39) by L270 , ORDERS_2:def 5;
L272: D40 [= D41 by L271 , FILTER_1:31;
L273: ( D40 |^| D41 ) = D40 by L272 , LATTICES:4;
thus L274: ( C129 |^| C130 ) = C129 by L273;
end;
L275: ( D40 |^| D41 ) = ( C129 |^| C130 );
assume L276: ( C129 |^| C130 ) = C129;
L277: D40 [= D41 by L276 , L275 , LATTICES:4;
L278: [ D40 , D41 ] in ( LattRel C128 ) by L277 , FILTER_1:31;
thus L279: thesis by L278 , ORDERS_2:def 5;
end;
L280: D39 is  naturally_inf-generated by L268 , L265;
L281: (for B97 , B98 being (Element of D39) holds (B97 <= B98 iff ( B97 |_| B98 ) = B98))
proof
let C131 , C132 being (Element of D39);
reconsider D42 = C131 , D43 = C132 as (Element of C128);
thus L282:now
assume L283: C131 <= C132;
L284: [ C131 , C132 ] in (the InternalRel of D39) by L283 , ORDERS_2:def 5;
L285: D42 [= D43 by L284 , FILTER_1:31;
L286: ( D42 |_| D43 ) = D43 by L285 , LATTICES:def 3;
thus L287: ( C131 |_| C132 ) = C132 by L286;
end;
L288: ( D42 |_| D43 ) = ( C131 |_| C132 );
assume L289: ( C131 |_| C132 ) = C132;
L290: D42 [= D43 by L289 , L288 , LATTICES:def 3;
L291: [ D42 , D43 ] in ( LattRel C128 ) by L290 , FILTER_1:31;
thus L292: thesis by L291 , ORDERS_2:def 5;
end;
L293: D39 is  naturally_sup-generated by L281 , L263;
thus L294: thesis by L293 , L280;
end;
end;
registration
cluster 1 -element  reflexive for LattRelStr;
existence
proof
take ( TrivLattRelStr );
thus L296: thesis;
end;
end;
registration
cluster 1 -element  reflexive for OrthoLattRelStr;
existence
proof
take ( TrivCLRelStr );
thus L298: thesis;
end;
end;
registration
cluster 1 -element  reflexive for OrthoRelStr;
existence
proof
take ( TrivOrthoRelStr );
thus L300: thesis;
end;
end;
registration
cluster  ->  involutive  with_Top  de_Morgan  well-complemented for 1 -element 1 -element 1 -element 1 -element OrthoLattStr;
coherence
proof
let C133 being 1 -element OrthoLattStr;
reconsider D44 = C133 as 1 -element OrthoLattStr;
L302: (for B99 being (Element of D44) holds ( ( B99 ` ) ` ) = B99) by STRUCT_0:def 10;
L303: (for B100 being (Element of D44) holds ( B100 ` ) is_a_complement_of B100)
proof
let C134 being (Element of D44);
L304: (( ( C134 ` ) |_| C134 ) = ( Top D44 ) & ( ( C134 ` ) |^| C134 ) = ( Bottom D44 )) by STRUCT_0:def 10;
L305: (( C134 |_| ( C134 ` ) ) = ( Top D44 ) & ( C134 |^| ( C134 ` ) ) = ( Bottom D44 )) by STRUCT_0:def 10;
thus L306: thesis by L305 , L304 , LATTICES:def 18;
end;
L307: ((for B101 , B102 being (Element of D44) holds ( B101 |_| ( B101 ` ) ) = ( B102 |_| ( B102 ` ) )) & (for B103 , B104 being (Element of D44) holds ( B103 |^| B104 ) = ( ( ( B103 ` ) |_| ( B104 ` ) ) ` ))) by STRUCT_0:def 10;
thus L308: thesis by L307 , L302 , L303 , L139 , L141 , ROBBINS1:def 10 , ROBBINS1:def 23;
end;
end;
registration
cluster  ->  OrderInvolutive  Pure  PartialOrdered for 1 -element  reflexive 1 -element  reflexive 1 -element  reflexive 1 -element  reflexive OrthoRelStr;
coherence
proof
let C135 being 1 -element  reflexive OrthoRelStr;
reconsider D45 = C135 as 1 -element  reflexive OrthoRelStr;
reconsider D46 = (the Compl of D45) as (Function of D45 , D45);
consider C136 being set such that L310: (the carrier of D45) = { C136 } by ZFMISC_1:131;
L311: D46 = ( id { C136 } ) by L310 , FUNCT_2:51;
L312: D46 is  involutive by L311;
L313: D45 is  Dneg by L312 , OPOSET_1:def 3;
L314: (for B105 , B106 being (Element of D45) holds (B105 <= B106 implies ( D46 . B105 ) >= ( D46 . B106 )))
proof
let C137 , C138 being (Element of D45);
assume L315: C137 <= C138;
L316: (( D46 . C137 ) = C136 & ( D46 . C138 ) = C136) by L310 , FUNCT_2:50;
thus L317: thesis by L316 , YELLOW_0:def 1;
end;
L318: D46 is  antitone by L314 , WAYBEL_9:def 1;
L319: D46 is  Orderinvolutive by L318 , L312 , OPOSET_1:def 17;
thus L320: thesis by L319 , L313 , OPOSET_1:def 15 , OPOSET_1:def 18;
end;
end;
registration
cluster  ->  naturally_sup-generated  naturally_inf-generated for 1 -element  reflexive 1 -element  reflexive 1 -element  reflexive 1 -element  reflexive LattRelStr;
coherence
proof
let C139 being 1 -element  reflexive LattRelStr;
reconsider D47 = C139 as 1 -element  reflexive LattRelStr;
L322: ((for B107 , B108 being (Element of D47) holds (B107 <= B108 iff ( B107 |_| B108 ) = B108)) & (for B109 , B110 being (Element of D47) holds (B109 <= B110 iff ( B109 |^| B110 ) = B109))) by STRUCT_0:def 10;
thus L323: thesis by L322 , L263 , L265;
end;
end;
registration
cluster  with_infima  with_suprema  naturally_sup-generated  naturally_inf-generated  de_Morgan  Lattice-like  OrderInvolutive  Pure  PartialOrdered for non  empty non  empty non  empty non  empty OrthoLattRelStr;
existence
proof
take ( TrivCLRelStr );
thus L325: thesis;
end;
end;
registration
cluster  with_infima  with_suprema  naturally_sup-generated  naturally_inf-generated  Lattice-like for non  empty non  empty non  empty non  empty LattRelStr;
existence
proof
take ( TrivLattRelStr );
thus L327: thesis;
end;
end;
theorem
L329: (for B111 being  naturally_sup-generated non  empty LattRelStr holds (for B112 , B113 being (Element of B111) holds (B112 <= B113 iff B112 [= B113)))
proof
let C140 being  naturally_sup-generated non  empty LattRelStr;
let C141 , C142 being (Element of C140);
thus L330:now
assume L331: C141 <= C142;
L332: ( C141 |_| C142 ) = C142 by L331 , L263;
thus L333: C141 [= C142 by L332 , LATTICES:def 3;
end;
assume L334: C141 [= C142;
L335: ( C141 |_| C142 ) = C142 by L334 , LATTICES:def 3;
thus L336: thesis by L335 , L263;
end;
theorem
L337: (for B114 being  naturally_sup-generated  Lattice-like non  empty LattRelStr holds ( the RelStr of B114 ) = ( LattPOSet B114 ))
proof
let C143 being  naturally_sup-generated  Lattice-like non  empty LattRelStr;
L338: (for B115 , B116 being set holds ([ B115 , B116 ] in (the InternalRel of C143) iff [ B115 , B116 ] in ( LattRel C143 )))
proof
let C144 , C145 being set;
thus L339:now
assume L340: [ C144 , C145 ] in (the InternalRel of C143);
reconsider D48 = C144 , D49 = C145 as (Element of C143) by L340 , ZFMISC_1:87;
L341: D48 <= D49 by L340 , ORDERS_2:def 5;
L342: D48 [= D49 by L341 , L329;
thus L343: [ C144 , C145 ] in ( LattRel C143 ) by L342 , FILTER_1:31;
end;
assume L344: [ C144 , C145 ] in ( LattRel C143 );
reconsider D50 = C144 , D51 = C145 as (Element of C143) by L344 , ZFMISC_1:87;
L345: D50 [= D51 by L344 , FILTER_1:31;
L346: D50 <= D51 by L345 , L329;
thus L347: thesis by L346 , ORDERS_2:def 5;
end;
L348: ( LattPOSet C143 ) = RelStr (# (the carrier of C143) , ( LattRel C143 ) #) by LATTICE3:def 2;
thus L349: thesis by L348 , L338 , RELAT_1:def 2;
end;
registration
cluster  naturally_sup-generated  Lattice-like ->  with_infima  with_suprema for non  empty non  empty non  empty non  empty LattRelStr;
coherence
proof
let C146 being non  empty LattRelStr;
assume L350: C146 is  naturally_sup-generated  Lattice-like;
reconsider D52 = C146 as  naturally_sup-generated  Lattice-like non  empty LattRelStr by L350;
L351: ( LattPOSet D52 ) is  with_suprema  with_infima;
L352: ( the RelStr of D52 ) is  with_suprema  with_infima by L351 , L337;
thus L353: thesis by L352 , YELLOW_7:14 , YELLOW_7:15;
end;
end;
begin
definition
let C147 being OrthoLattStr;
mode CLatAugmentation of C147
 -> OrthoLattRelStr
means :L355: ( the OrthoLattStr of it ) = ( the OrthoLattStr of C147 );
existence
proof
set D53 = the (Relation of (the carrier of C147));
set D54 = OrthoLattRelStr (# (the carrier of C147) , (the L_join of C147) , (the L_meet of C147) , D53 , (the Compl of C147) #);
take D54;
thus L356: thesis;
end;
end;
registration
let C148 being non  empty OrthoLattStr;
cluster  -> non  empty for (CLatAugmentation of C148);
coherence
proof
let C149 being (CLatAugmentation of C148);
L358: ( the OrthoLattStr of C148 ) = ( the OrthoLattStr of C149 ) by L355;
thus L359: thesis by L358;
end;
end;
registration
let C150 being  meet-associative non  empty OrthoLattStr;
cluster  ->  meet-associative for (CLatAugmentation of C150);
coherence
proof
let C151 being (CLatAugmentation of C150);
L361: ( the OrthoLattStr of C150 ) = ( the OrthoLattStr of C151 ) by L355;
L362: ( the LattStr of C150 ) = ( the LattStr of C151 ) by L361;
thus L363: thesis by L362 , L183;
end;
end;
registration
let C152 being  join-associative non  empty OrthoLattStr;
cluster  ->  join-associative for (CLatAugmentation of C152);
coherence
proof
let C153 being (CLatAugmentation of C152);
L365: ( the OrthoLattStr of C152 ) = ( the OrthoLattStr of C153 ) by L355;
L366: ( the LattStr of C152 ) = ( the LattStr of C153 ) by L365;
thus L367: thesis by L366 , L176;
end;
end;
registration
let C154 being  meet-commutative non  empty OrthoLattStr;
cluster  ->  meet-commutative for (CLatAugmentation of C154);
coherence
proof
let C155 being (CLatAugmentation of C154);
L369: ( the OrthoLattStr of C154 ) = ( the OrthoLattStr of C155 ) by L355;
L370: ( the LattStr of C154 ) = ( the LattStr of C155 ) by L369;
thus L371: thesis by L370 , L169;
end;
end;
registration
let C156 being  join-commutative non  empty OrthoLattStr;
cluster  ->  join-commutative for (CLatAugmentation of C156);
coherence
proof
let C157 being (CLatAugmentation of C156);
L373: ( the OrthoLattStr of C156 ) = ( the OrthoLattStr of C157 ) by L355;
L374: ( the LattStr of C156 ) = ( the LattStr of C157 ) by L373;
thus L375: thesis by L374 , L162;
end;
end;
registration
let C158 being  meet-absorbing non  empty OrthoLattStr;
cluster  ->  meet-absorbing for (CLatAugmentation of C158);
coherence
proof
let C159 being (CLatAugmentation of C158);
L377: ( the OrthoLattStr of C158 ) = ( the OrthoLattStr of C159 ) by L355;
L378: ( the LattStr of C158 ) = ( the LattStr of C159 ) by L377;
thus L379: thesis by L378 , L197;
end;
end;
registration
let C160 being  join-absorbing non  empty OrthoLattStr;
cluster  ->  join-absorbing for (CLatAugmentation of C160);
coherence
proof
let C161 being (CLatAugmentation of C160);
L381: ( the OrthoLattStr of C160 ) = ( the OrthoLattStr of C161 ) by L355;
L382: ( the LattStr of C160 ) = ( the LattStr of C161 ) by L381;
thus L383: thesis by L382 , L190;
end;
end;
registration
let C162 being  with_Top non  empty OrthoLattStr;
cluster  ->  with_Top for (CLatAugmentation of C162);
coherence
proof
let C163 being (CLatAugmentation of C162);
L385: ( the OrthoLattStr of C162 ) = ( the OrthoLattStr of C163 ) by L355;
L386: ( the ComplLLattStr of C162 ) = ( the ComplLLattStr of C163 ) by L385;
thus L387: thesis by L386 , L214;
end;
end;
registration
let C164 being non  empty Ortholattice;
cluster  naturally_sup-generated  naturally_inf-generated  Lattice-like for (CLatAugmentation of C164);
existence
proof
set D55 = ( LattRel C164 );
set D56 = OrthoLattRelStr (# (the carrier of C164) , (the L_join of C164) , (the L_meet of C164) , D55 , (the Compl of C164) #);
L389: ( the OrthoLattStr of C164 ) = ( the OrthoLattStr of D56 );
reconsider D57 = D56 as (CLatAugmentation of C164) by L389 , L355;
L390: (for B117 , B118 being (Element of D57) holds (B117 <= B118 iff ( B117 |^| B118 ) = B117))
proof
let C165 , C166 being (Element of D57);
reconsider D58 = C165 , D59 = C166 as (Element of C164);
thus L391:now
assume L392: C165 <= C166;
L393: [ D58 , D59 ] in (the InternalRel of D57) by L392 , ORDERS_2:def 5;
L394: D58 [= D59 by L393 , FILTER_1:31;
L395: ( D58 |^| D59 ) = D58 by L394 , LATTICES:4;
thus L396: ( C165 |^| C166 ) = C165 by L395;
end;
L397: ( D58 |^| D59 ) = ( C165 |^| C166 );
assume L398: ( C165 |^| C166 ) = C165;
L399: D58 [= D59 by L398 , L397 , LATTICES:4;
L400: [ D58 , D59 ] in ( LattRel C164 ) by L399 , FILTER_1:31;
thus L401: thesis by L400 , ORDERS_2:def 5;
end;
L402: D57 is  naturally_inf-generated by L390 , L265;
L403: (for B119 , B120 being (Element of D57) holds (B119 <= B120 iff ( B119 |_| B120 ) = B120))
proof
let C167 , C168 being (Element of D57);
reconsider D60 = C167 , D61 = C168 as (Element of C164);
thus L404:now
assume L405: C167 <= C168;
L406: [ C167 , C168 ] in (the InternalRel of D57) by L405 , ORDERS_2:def 5;
L407: D60 [= D61 by L406 , FILTER_1:31;
L408: ( D60 |_| D61 ) = D61 by L407 , LATTICES:def 3;
thus L409: ( C167 |_| C168 ) = C168 by L408;
end;
L410: ( D60 |_| D61 ) = ( C167 |_| C168 );
assume L411: ( C167 |_| C168 ) = C168;
L412: D60 [= D61 by L411 , L410 , LATTICES:def 3;
L413: [ D60 , D61 ] in ( LattRel C164 ) by L412 , FILTER_1:31;
thus L414: thesis by L413 , ORDERS_2:def 5;
end;
L415: D57 is  naturally_sup-generated by L403 , L263;
thus L416: thesis by L415 , L402;
end;
end;
registration
cluster  involutive  with_Top  de_Morgan  Lattice-like  naturally_sup-generated  well-complemented for non  empty non  empty non  empty non  empty OrthoLattRelStr;
existence
proof
take ( TrivCLRelStr );
thus L418: thesis;
end;
end;
theorem
L420: (for B121 being  with_infima  with_suprema  PartialOrdered non  empty OrthoRelStr holds (for B122 , B123 being (Element of B121) holds (B122 <= B123 implies (B123 = ( B122 "|_|" B123 ) & B122 = ( B122 "|^|" B123 )))))
proof
let C169 being  with_infima  with_suprema  PartialOrdered non  empty OrthoRelStr;
let C170 , C171 being (Element of C169);
assume L421: C170 <= C171;
L422: C171 = ( C171 "|_|" C170 ) by L421 , YELLOW_0:24;
thus L423: thesis by L422 , L421 , LATTICE3:13 , YELLOW_0:25;
end;
definition
let C172 being  meet-commutative non  empty /\-SemiLattStr;
let C173 , C174 being (Element of C172);
redefine func C173 |^| C174;

commutativity
 by LATTICES:def 6;
end;
definition
let C175 being  join-commutative non  empty \/-SemiLattStr;
let C176 , C177 being (Element of C175);
redefine func C176 |_| C177;

commutativity
 by LATTICES:def 4;
end;
registration
cluster  meet-absorbing  join-absorbing  meet-commutative  naturally_sup-generated ->  reflexive for non  empty non  empty non  empty non  empty LattRelStr;
coherence
proof
let C178 being non  empty LattRelStr;
assume L426: C178 is  meet-absorbing  join-absorbing  meet-commutative  naturally_sup-generated;
reconsider D62 = C178 as  meet-absorbing  join-absorbing  meet-commutative  naturally_sup-generated non  empty LattRelStr by L426;
L427: (for B124 being (Element of D62) holds B124 <= B124)
proof
let C179 being (Element of D62);
L428: C179 [= C179;
thus L429: thesis by L428 , L329;
end;
thus L430: thesis by L427 , YELLOW_0:def 1;
end;
end;
registration
cluster  join-associative  naturally_sup-generated ->  transitive for non  empty non  empty non  empty non  empty LattRelStr;
coherence
proof
let C180 being non  empty LattRelStr;
assume L432: C180 is  join-associative  naturally_sup-generated;
reconsider D63 = C180 as  join-associative  naturally_sup-generated non  empty LattRelStr by L432;
L433: (for B125 , B126 , B127 being (Element of D63) holds ((B125 <= B126 & B126 <= B127) implies B125 <= B127))
proof
let C181 , C182 , C183 being (Element of D63);
assume L434: (C181 <= C182 & C182 <= C183);
L435: (C181 [= C182 & C182 [= C183) by L434 , L329;
L436: C181 [= C183 by L435 , LATTICES:7;
thus L437: thesis by L436 , L329;
end;
thus L438: thesis by L433 , YELLOW_0:def 2;
end;
end;
registration
cluster  join-commutative  naturally_sup-generated ->  antisymmetric for non  empty non  empty non  empty non  empty LattRelStr;
coherence
proof
let C184 being non  empty LattRelStr;
assume L440: C184 is  join-commutative  naturally_sup-generated;
reconsider D64 = C184 as  join-commutative  naturally_sup-generated non  empty LattRelStr by L440;
L441: (for B128 , B129 being (Element of D64) holds ((B128 <= B129 & B129 <= B128) implies B128 = B129))
proof
let C185 , C186 being (Element of D64);
assume L442: (C185 <= C186 & C186 <= C185);
L443: (C185 [= C186 & C186 [= C185) by L442 , L329;
thus L444: thesis by L443 , LATTICES:8;
end;
thus L445: thesis by L441 , YELLOW_0:def 3;
end;
end;
theorem
L447: (for B130 being  with_infima  with_suprema  naturally_sup-generated  Lattice-like non  empty OrthoLattRelStr holds (for B131 , B132 being (Element of B130) holds ( B131 "|_|" B132 ) = ( B131 |_| B132 )))
proof
let C187 being  with_infima  with_suprema  naturally_sup-generated  Lattice-like non  empty OrthoLattRelStr;
let C188 , C189 being (Element of C187);
L448: C188 <= ( C188 "|_|" C189 ) by YELLOW_0:22;
L449: C188 [= ( C188 "|_|" C189 ) by L448 , L329;
L450: C189 <= ( C188 "|_|" C189 ) by YELLOW_0:22;
L451: C189 [= ( C188 "|_|" C189 ) by L450 , L329;
L452: C188 [= ( C188 |_| C189 ) by LATTICES:5;
L453: C188 <= ( C188 |_| C189 ) by L452 , L329;
L454: C189 [= ( C188 |_| C189 ) by LATTICES:5;
L455: C189 <= ( C188 |_| C189 ) by L454 , L329;
L456: ( ( C188 |_| C189 ) "|_|" ( C188 "|_|" C189 ) ) = ( ( ( C188 |_| C189 ) "|_|" C188 ) "|_|" C189 ) by LATTICE3:14
.= ( ( C188 |_| C189 ) "|_|" C189 ) by L453 , YELLOW_0:24
.= ( C188 |_| C189 ) by L455 , YELLOW_0:24;
L457: ( C188 "|_|" C189 ) <= ( C188 |_| C189 ) by L456 , YELLOW_0:24;
L458: ( C188 "|_|" C189 ) [= ( C188 |_| C189 ) by L457 , L329;
L459: ( ( C188 "|_|" C189 ) |_| ( C188 |_| C189 ) ) = ( ( ( C188 "|_|" C189 ) |_| C188 ) |_| C189 ) by LATTICES:def 5
.= ( ( C188 "|_|" C189 ) |_| C189 ) by L449 , LATTICES:def 3
.= ( C188 "|_|" C189 ) by L451 , LATTICES:def 3;
thus L460: thesis by L459 , L458 , LATTICES:def 3;
end;
theorem
L461: (for B133 being  with_infima  with_suprema  naturally_sup-generated  Lattice-like non  empty OrthoLattRelStr holds (for B134 , B135 being (Element of B133) holds ( B134 "|^|" B135 ) = ( B134 |^| B135 )))
proof
let C190 being  with_infima  with_suprema  naturally_sup-generated  Lattice-like non  empty OrthoLattRelStr;
let C191 , C192 being (Element of C190);
L462: ( C191 "|^|" C192 ) <= C191 by YELLOW_0:23;
L463: ( C191 "|^|" C192 ) [= C191 by L462 , L329;
L464: ( C191 "|^|" C192 ) <= C192 by YELLOW_0:23;
L465: ( C191 "|^|" C192 ) [= C192 by L464 , L329;
L466: ( C191 |^| C192 ) [= C191 by LATTICES:6;
L467: ( C191 |^| C192 ) <= C191 by L466 , L329;
L468: ( C191 |^| C192 ) [= C192 by LATTICES:6;
L469: ( C191 |^| C192 ) <= C192 by L468 , L329;
L470: ( ( C191 |^| C192 ) "|^|" ( C191 "|^|" C192 ) ) = ( ( ( C191 |^| C192 ) "|^|" C191 ) "|^|" C192 ) by LATTICE3:16
.= ( ( C191 |^| C192 ) "|^|" C192 ) by L467 , YELLOW_0:25
.= ( C191 |^| C192 ) by L469 , YELLOW_0:25;
L471: ( C191 |^| C192 ) <= ( C191 "|^|" C192 ) by L470 , YELLOW_0:25;
L472: ( C191 |^| C192 ) [= ( C191 "|^|" C192 ) by L471 , L329;
L473: ( ( C191 "|^|" C192 ) |^| ( C191 |^| C192 ) ) = ( ( ( C191 "|^|" C192 ) |^| C191 ) |^| C192 ) by LATTICES:def 7
.= ( ( C191 "|^|" C192 ) |^| C192 ) by L463 , LATTICES:4
.= ( C191 "|^|" C192 ) by L465 , LATTICES:4;
thus L474: thesis by L473 , L472 , LATTICES:4;
end;
theorem
L475: (for B136 being  with_infima  with_suprema  naturally_sup-generated  naturally_inf-generated  Lattice-like  OrderInvolutive  PartialOrdered non  empty OrthoLattRelStr holds B136 is  de_Morgan)
proof
let C193 being  with_infima  with_suprema  naturally_sup-generated  naturally_inf-generated  Lattice-like  OrderInvolutive  PartialOrdered non  empty OrthoLattRelStr;
L476: (for B137 , B138 being (Element of C193) holds ( ( B137 ` ) "|_|" ( B138 ` ) ) <= ( ( B137 "|^|" B138 ) ` ))
proof
let C194 , C195 being (Element of C193);
set D65 = ( C194 "|^|" C195 );
set D66 = ( ( C194 ` ) "|_|" ( C195 ` ) );
L477: D65 <= C194 by YELLOW_0:23;
L478: ( C194 ` ) <= ( D65 ` ) by L477 , L74;
L479: D66 <= ( ( D65 ` ) "|_|" ( C195 ` ) ) by L478 , WAYBEL_1:2;
L480: D65 <= C195 by YELLOW_0:23;
L481: ( C195 ` ) <= ( D65 ` ) by L480 , L74;
L482: ( D65 ` ) = ( ( C195 ` ) "|_|" ( D65 ` ) ) by L481 , L420;
thus L483: thesis by L482 , L479 , LATTICE3:13;
end;
L484: (for B139 , B140 being (Element of C193) holds ( ( B139 "|_|" B140 ) ` ) <= ( ( B139 ` ) "|^|" ( B140 ` ) ))
proof
let C196 , C197 being (Element of C193);
set D67 = ( ( C196 ` ) "|^|" ( C197 ` ) );
set D68 = ( C196 "|_|" C197 );
L485: C196 <= D68 by YELLOW_0:22;
L486: ( D68 ` ) <= ( C196 ` ) by L485 , L74;
L487: ( ( D68 ` ) "|^|" ( C197 ` ) ) <= D67 by L486 , WAYBEL_1:1;
L488: C197 <= D68 by YELLOW_0:22;
L489: ( D68 ` ) <= ( C197 ` ) by L488 , L74;
thus L490: thesis by L489 , L487 , L420;
end;
L491: (for B141 , B142 being (Element of C193) holds ( ( ( B141 ` ) |_| ( B142 ` ) ) ` ) = ( B141 |^| B142 ))
proof
let C198 , C199 being (Element of C193);
set D69 = ( ( C198 ` ) "|_|" ( C199 ` ) );
set D70 = ( C198 "|^|" C199 );
L492: (( ( C198 ` ) ` ) = C198 & ( ( C199 ` ) ` ) = C199) by L69;
L493: ( D69 ` ) <= D70 by L492 , L484;
L494: ( ( D70 ` ) ` ) <= ( D69 ` ) by L476 , L74;
L495: D70 <= ( D69 ` ) by L494 , L69;
L496: (D70 = ( C198 |^| C199 ) & D69 = ( ( C198 ` ) |_| ( C199 ` ) )) by L447 , L461;
thus L497: thesis by L496 , L493 , L495 , ORDERS_2:2;
end;
thus L498: thesis by L491 , ROBBINS1:def 23;
end;
registration
let C200 being Ortholattice;
cluster  ->  involutive for (CLatAugmentation of C200);
coherence
proof
let C201 being (CLatAugmentation of C200);
L499: ( the OrthoLattStr of C200 ) = ( the OrthoLattStr of C201 ) by L355;
thus L500: thesis by L499 , L229;
end;
end;
registration
let C202 being Ortholattice;
cluster  ->  de_Morgan for (CLatAugmentation of C202);
coherence
proof
let C203 being (CLatAugmentation of C202);
L502: ( the OrthoLattStr of C202 ) = ( the OrthoLattStr of C203 ) by L355;
thus L503: thesis by L502 , L221;
end;
end;
theorem
L505: (for B143 being non  empty OrthoLattRelStr holds (B143 is  involutive  with_Top  de_Morgan  Lattice-like  naturally_sup-generated implies B143 is  Orthocomplemented  PartialOrdered))
proof
let C204 being non  empty OrthoLattRelStr;
assume L506: C204 is  involutive  with_Top  de_Morgan  Lattice-like  naturally_sup-generated;
reconsider D71 = C204 as  involutive  with_Top  de_Morgan  Lattice-like  naturally_sup-generated non  empty OrthoLattRelStr by L506;
reconsider D72 = (the Compl of D71) as (Function of D71 , D71);
L507: (for B144 , B145 being (Element of D71) holds (B144 <= B145 implies ( D72 . B144 ) >= ( D72 . B145 )))
proof
let C205 , C206 being (Element of D71);
assume L508: C205 <= C206;
L509: C205 [= C206 by L508 , L329;
L510: ( C205 ` ) = ( ( C205 |^| C206 ) ` ) by L509 , LATTICES:4
.= ( ( ( ( C205 ` ) |_| ( C206 ` ) ) ` ) ` ) by ROBBINS1:def 23
.= ( ( C205 ` ) |_| ( C206 ` ) ) by L139;
L511: (( D72 . C205 ) = ( C205 ` ) & ( D72 . C206 ) = ( C206 ` )) by ROBBINS1:def 3;
thus L512: thesis by L511 , L510 , L263;
end;
L513: D72 is  antitone by L507 , WAYBEL_9:def 1;
L514: (for B146 being (Element of D71) holds ( ex_sup_of { B146 , ( D72 . B146 ) } , D71 &  ex_inf_of { B146 , ( D72 . B146 ) } , D71 & ( "\/" ({ B146 , ( D72 . B146 ) } , D71) ) is_maximum_of (the carrier of D71) & ( "/\" ({ B146 , ( D72 . B146 ) } , D71) ) is_minimum_of (the carrier of D71)))
proof
set D73 = ( "\/" ((the carrier of D71) , D71) );
let C207 being (Element of D71);
thus L515:  ex_sup_of { C207 , ( D72 . C207 ) } , D71 by YELLOW_0:20;
thus L516:  ex_inf_of { C207 , ( D72 . C207 ) } , D71 by YELLOW_0:21;
set D74 = ( C207 |_| ( C207 ` ) );
L517: (for B147 being (Element of D71) holds (B147 in (the carrier of D71) implies B147 <= D74))
proof
let C208 being (Element of D71);
assume L518: C208 in (the carrier of D71);
L519: ( C208 |_| ( C207 |_| ( C207 ` ) ) ) = ( C208 |_| ( C208 |_| ( C208 ` ) ) ) by L141
.= ( ( C208 |_| C208 ) |_| ( C208 ` ) ) by LATTICES:def 5
.= ( C208 |_| ( C208 ` ) )
.= ( C207 |_| ( C207 ` ) ) by L141;
L520: C208 [= D74 by L519 , LATTICES:def 3;
thus L521: thesis by L520 , L329;
end;
L522: D74 is_>=_than (the carrier of D71) by L517 , LATTICE3:def 9;
L523: D71 is  upper-bounded by L522 , YELLOW_0:def 5;
L524:  ex_sup_of (the carrier of D71) , D71 by L523 , YELLOW_0:43;
reconsider D75 = D74 as (Element of D71);
L525: (for B148 being (Element of D71) holds ((the carrier of D71) is_<=_than B148 implies D75 <= B148)) by LATTICE3:def 9;
L526: ( "\/" ({ C207 , ( D72 . C207 ) } , D71) ) = ( "\/" ({ C207 , ( C207 ` ) } , D71) ) by ROBBINS1:def 3
.= ( C207 "|_|" ( C207 ` ) ) by YELLOW_0:41
.= ( C207 |_| ( C207 ` ) ) by L447
.= D73 by L522 , L524 , L525 , YELLOW_0:def 9;
thus L527: ( "\/" ({ C207 , ( D72 . C207 ) } , D71) ) is_maximum_of (the carrier of D71) by L526 , L524 , WAYBEL_1:def 7;
set D76 = ( "/\" ((the carrier of D71) , D71) );
set D77 = ( C207 |^| ( C207 ` ) );
L528: (for B149 , B150 being (Element of D71) holds ( B149 |^| ( B149 ` ) ) = ( B150 |^| ( B150 ` ) ))
proof
let C209 , C210 being (Element of D71);
L529: ( C209 |^| ( C209 ` ) ) = ( ( ( C209 ` ) |_| ( ( C209 ` ) ` ) ) ` ) by ROBBINS1:def 23
.= ( ( ( C210 ` ) |_| ( ( C210 ` ) ` ) ) ` ) by L141
.= ( C210 |^| ( C210 ` ) ) by ROBBINS1:def 23;
thus L530: thesis by L529;
end;
L531: (for B151 being (Element of D71) holds (B151 in (the carrier of D71) implies B151 >= D77))
proof
let C211 being (Element of D71);
assume L532: C211 in (the carrier of D71);
L533: ( C211 |^| ( C207 |^| ( C207 ` ) ) ) = ( C211 |^| ( C211 |^| ( C211 ` ) ) ) by L528
.= ( ( C211 |^| C211 ) |^| ( C211 ` ) ) by LATTICES:def 7
.= ( C211 |^| ( C211 ` ) )
.= ( C207 |^| ( C207 ` ) ) by L528;
L534: D77 [= C211 by L533 , LATTICES:4;
thus L535: thesis by L534 , L329;
end;
L536: D77 is_<=_than (the carrier of D71) by L531 , LATTICE3:def 8;
L537: D71 is  lower-bounded by L536 , YELLOW_0:def 4;
L538:  ex_inf_of (the carrier of D71) , D71 by L537 , YELLOW_0:42;
reconsider D78 = D77 as (Element of D71);
L539: (for B152 being (Element of D71) holds ((the carrier of D71) is_>=_than B152 implies D78 >= B152)) by LATTICE3:def 8;
L540: ( "/\" ({ C207 , ( D72 . C207 ) } , D71) ) = ( "/\" ({ C207 , ( C207 ` ) } , D71) ) by ROBBINS1:def 3
.= ( C207 "|^|" ( C207 ` ) ) by YELLOW_0:40
.= ( C207 |^| ( C207 ` ) ) by L461
.= D76 by L536 , L538 , L539 , YELLOW_0:def 10;
thus L541: thesis by L540 , L538 , WAYBEL_1:def 6;
end;
L542: (for B153 being (Element of D71) holds ( D72 . ( D72 . B153 ) ) = B153)
proof
let C212 being (Element of D71);
L543: ( D72 . ( D72 . C212 ) ) = ( D72 . ( C212 ` ) ) by ROBBINS1:def 3
.= ( ( C212 ` ) ` ) by ROBBINS1:def 3
.= C212 by L139;
thus L544: thesis by L543;
end;
L545: D72 is  involutive by L542 , PARTIT_2:def 3;
L546: D72 is  Orderinvolutive by L545 , L513 , OPOSET_1:def 17;
L547: D72 OrthoComplement_on D71 by L546 , L514 , OPOSET_1:def 21;
thus L548: thesis by L547 , OPOSET_1:def 22;
end;
theorem
L549: (for B154 being Ortholattice holds (for B155 being  naturally_sup-generated (CLatAugmentation of B154) holds B155 is  Orthocomplemented)) by L505;
registration
let C213 being Ortholattice;
cluster  ->  Orthocomplemented for  naturally_sup-generated  naturally_sup-generated  naturally_sup-generated  naturally_sup-generated (CLatAugmentation of C213);
coherence by L505;
end;
theorem
L551: (for B156 being non  empty OrthoLattStr holds (B156 is  Boolean  well-complemented  Lattice-like implies B156 is Ortholattice))
proof
let C214 being non  empty OrthoLattStr;
assume L552: C214 is  Boolean  well-complemented  Lattice-like;
reconsider D79 = C214 as  Boolean  well-complemented  Lattice-like non  empty OrthoLattStr by L552;
L553: (for B157 , B158 being (Element of D79) holds ( B157 "/\" B158 ) = ( ( ( B157 ` ) "\/" ( B158 ` ) ) ` )) by ROBBINS1:33;
L554: ((for B159 being (Element of D79) holds ( ( B159 ` ) ` ) = B159) & (for B160 , B161 being (Element of D79) holds ( B160 |_| ( B160 ` ) ) = ( B161 |_| ( B161 ` ) ))) by ROBBINS1:3 , ROBBINS1:4;
thus L555: thesis by L554 , L553 , L139 , L141 , ROBBINS1:def 23;
end;
registration
cluster  Boolean  well-complemented  Lattice-like ->  involutive  with_Top  de_Morgan for non  empty non  empty non  empty non  empty OrthoLattStr;
coherence by L551;
end;
