:: The Construction of { \bf SCM } over Ring
::  by Artur Korni{\l}owicz
::
:: Received November 29, 1998
:: Copyright (c) 1998-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, CARD_1, AMI_2, XBOOLE_0, STRUCT_0, ZFMISC_1,
      RELAT_1, FINSEQ_1, FUNCSDOM, FUNCT_1, AMI_1, PARTFUN1, TARSKI, SCMRING1,
      RECDEF_2, ALGSTR_0, UNIALG_1, AMISTD_2, VALUED_0, COMPOS_0, XXREAL_0;
 notations TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1,
      XTUPLE_0, SUBSET_1, RELAT_1, FUNCT_1,
      PARTFUN1, VALUED_0, CARD_1, RECDEF_2, XXREAL_0, NUMBERS, STRUCT_0,
      ALGSTR_0, FUNCSDOM, MCART_1, FINSEQ_1, FINSEQ_4, COMPOS_0, SCM_INST;
 constructors FINSEQ_4, REALSET2, FINSEQ_2, COMPOS_1, SCM_INST, VALUED_0,
      XTUPLE_0;
 registrations XBOOLE_0, RELAT_1, ORDINAL1, FINSEQ_1, STRUCT_0, GR_CY_1, GCD_1,
      FUNCT_1, ALGSTR_0, ALGSTR_1, COMPOS_0, SCM_INST, XXREAL_0, VALUED_0,
      XTUPLE_0;
 requirements NUMERALS, REAL, SUBSET, BOOLE;
 definitions TARSKI, FINSEQ_1, CARD_1, MCART_1, COMPOS_0, SCM_INST, XTUPLE_0;
 theorems ENUMSET1, FINSEQ_1, FINSEQ_4, FUNCT_1, MCART_1, TARSKI, SUBSET_1,
      ZFMISC_1, XBOOLE_0, XBOOLE_1, NAT_1, RELAT_1, FUNCT_7, RECDEF_2,
      COMPOS_0, ORDINAL1, XTUPLE_0;

begin
registration
cluster ( SCM-Instr ) -> non  trivial;
coherence
proof
set D1 = the (Element of ( SCM-Data-Loc ));
L1: (1 in { 1 , 2 , 3 , 4 , 5 } & 1 is (Element of ( Segm 9 ))) by ENUMSET1:def 3 , NAT_1:44;
L2: [ 1 , ( {} ) , <* D1 , D1 *> ] in { [ B1 , ( {} ) , <* B2 , B3 *> ] where B1 is (Element of ( Segm 9 )) , B2 , B3 is (Element of ( SCM-Data-Loc )) : B1 in { 1 , 2 , 3 , 4 , 5 } } by L1;
L3: [ 1 , ( {} ) , <* D1 , D1 *> ] in ( SCM-Instr ) by L2 , XBOOLE_0:def 3;
L4: (2 in { 1 , 2 , 3 , 4 , 5 } & 2 is (Element of ( Segm 9 ))) by ENUMSET1:def 3 , NAT_1:44;
L5: [ 2 , ( {} ) , <* D1 , D1 *> ] in { [ B4 , ( {} ) , <* B5 , B6 *> ] where B4 is (Element of ( Segm 9 )) , B5 , B6 is (Element of ( SCM-Data-Loc )) : B4 in { 1 , 2 , 3 , 4 , 5 } } by L4;
L6: [ 2 , ( {} ) , <* D1 , D1 *> ] in ( SCM-Instr ) by L5 , XBOOLE_0:def 3;
L7: [ 1 , ( {} ) , <* D1 , D1 *> ] <> [ 2 , ( {} ) , <* D1 , D1 *> ] by XTUPLE_0:3;
thus L8: thesis by L7 , L3 , L6 , SUBSET_1:def 7;
end;
end;
definition
let C1 being non  empty 1-sorted;
func SCM-Instr C1 -> non  empty set equals 
( ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B7 , ( {} ) , <* B8 , B9 *> ] where B7 is (Element of ( Segm 8 )) , B8 , B9 is (Element of ( SCM-Data-Loc )) : B7 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B10 *> , ( {} ) ] where B10 is (Element of ( NAT )) : (not contradiction) } ) \/ { [ 7 , <* B11 *> , <* B12 *> ] where B11 is (Element of ( NAT )) , B12 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) \/ { [ 5 , ( {} ) , <* B13 , B14 *> ] where B13 is (Element of ( SCM-Data-Loc )) , B14 is (Element of C1) : (not contradiction) } );
coherence;
end;
registration
let C2 being non  empty 1-sorted;
cluster ( SCM-Instr C2 ) -> non  trivial;
coherence
proof
set D2 = the (Element of ( SCM-Data-Loc ));
L11: ( SCM-Instr C2 ) = ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ R4 , ( {} ) , <* R7 , R8 *> ] where R4 is (Element of ( Segm 8 )) , R7 is (Element of ( SCM-Data-Loc )) , R8 is (Element of ( SCM-Data-Loc )) : R4 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* R5 *> , ( {} ) ] where R5 is (Element of ( NAT )) : (not contradiction) } ) \/ ( { [ 7 , <* R6 *> , <* R9 *> ] where R6 is (Element of ( NAT )) , R9 is (Element of ( SCM-Data-Loc )) : (not contradiction) } \/ { [ 5 , ( {} ) , <* R10 , B15 *> ] where R10 is (Element of ( SCM-Data-Loc )) , B15 is (Element of C2) : (not contradiction) } ) ) by XBOOLE_1:4
.= ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ R4 , ( {} ) , <* R7 , R8 *> ] where R4 is (Element of ( Segm 8 )) , R7 is (Element of ( SCM-Data-Loc )) , R8 is (Element of ( SCM-Data-Loc )) : R4 in { 1 , 2 , 3 , 4 } } ) \/ ( { [ 6 , <* R5 *> , ( {} ) ] where R5 is (Element of ( NAT )) : (not contradiction) } \/ ( { [ 7 , <* R6 *> , <* R9 *> ] where R6 is (Element of ( NAT )) , R9 is (Element of ( SCM-Data-Loc )) : (not contradiction) } \/ { [ 5 , ( {} ) , <* R10 , B16 *> ] where R10 is (Element of ( SCM-Data-Loc )) , B16 is (Element of C2) : (not contradiction) } ) ) ) by XBOOLE_1:4
.= ( { [ R4 , ( {} ) , <* R7 , R8 *> ] where R4 is (Element of ( Segm 8 )) , R7 is (Element of ( SCM-Data-Loc )) , R8 is (Element of ( SCM-Data-Loc )) : R4 in { 1 , 2 , 3 , 4 } } \/ ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ ( { [ 6 , <* R5 *> , ( {} ) ] where R5 is (Element of ( NAT )) : (not contradiction) } \/ ( { [ 7 , <* R6 *> , <* R9 *> ] where R6 is (Element of ( NAT )) , R9 is (Element of ( SCM-Data-Loc )) : (not contradiction) } \/ { [ 5 , ( {} ) , <* R10 , B17 *> ] where R10 is (Element of ( SCM-Data-Loc )) , B17 is (Element of C2) : (not contradiction) } ) ) ) ) by XBOOLE_1:4;
L12: (2 in ( Segm 8 ) & 2 in { 1 , 2 , 3 , 4 }) by ENUMSET1:def 2 , NAT_1:44;
L13: [ 2 , ( {} ) , <* D2 , D2 *> ] in { [ B18 , ( {} ) , <* B19 , B20 *> ] where B18 is (Element of ( Segm 8 )) , B19 , B20 is (Element of ( SCM-Data-Loc )) : B18 in { 1 , 2 , 3 , 4 } } by L12;
L14: [ 2 , ( {} ) , <* D2 , D2 *> ] in ( SCM-Instr C2 ) by L13 , L11 , XBOOLE_0:def 3;
L15: [ 1 , ( {} ) , <* D2 , D2 *> ] <> [ 2 , ( {} ) , <* D2 , D2 *> ] by XTUPLE_0:3;
L16: (1 in ( Segm 8 ) & 1 in { 1 , 2 , 3 , 4 }) by ENUMSET1:def 2 , NAT_1:44;
L17: [ 1 , ( {} ) , <* D2 , D2 *> ] in { [ R4 , ( {} ) , <* B21 , B22 *> ] where R4 is (Element of ( Segm 8 )) , B21 , B22 is (Element of ( SCM-Data-Loc )) : R4 in { 1 , 2 , 3 , 4 } } by L16;
L18: [ 1 , ( {} ) , <* D2 , D2 *> ] in ( SCM-Instr C2 ) by L17 , L11 , XBOOLE_0:def 3;
thus L19: thesis by L18 , L14 , L15 , SUBSET_1:def 7;
end;
end;
definition
let C3 being non  empty 1-sorted;
let C4 being (Element of ( SCM-Instr C3 ));
given C5 , C6 being (Element of ( SCM-Data-Loc )) , R4 being (Element of ( Segm 8 )) such that
L21: C4 = [ R4 , ( {} ) , <* C5 , C6 *> ];

func C4 address_1 -> (Element of ( SCM-Data-Loc )) means 
:L22: (ex B23 being (FinSequence of ( SCM-Data-Loc )) st (B23 = ( C4 `3_3 ) & it = ( B23 /. 1 )));
existence
proof
take C5;
take <* C5 , C6 *>;
thus L23: thesis by L21 , FINSEQ_4:17 , RECDEF_2:def 3;
end;
uniqueness;
func C4 address_2 -> (Element of ( SCM-Data-Loc )) means 
:L24: (ex B24 being (FinSequence of ( SCM-Data-Loc )) st (B24 = ( C4 `3_3 ) & it = ( B24 /. 2 )));
existence
proof
take C6;
take <* C5 , C6 *>;
thus L25: thesis by L21 , FINSEQ_4:17 , RECDEF_2:def 3;
end;
uniqueness;
end;
theorem
L27: (for R4 being (Element of ( Segm 8 )) holds (for R11 being non  empty 1-sorted holds (for B25 being (Element of ( SCM-Instr R11 )) holds (for B26 , B27 being (Element of ( SCM-Data-Loc )) holds (B25 = [ R4 , ( {} ) , <* B26 , B27 *> ] implies (( B25 address_1 ) = B26 & ( B25 address_2 ) = B27))))))
proof
let R4 being (Element of ( Segm 8 ));
let R11 being non  empty 1-sorted;
let C7 being (Element of ( SCM-Instr R11 ));
let C8 , C9 being (Element of ( SCM-Data-Loc ));
assume L28: C7 = [ R4 , ( {} ) , <* C8 , C9 *> ];
consider C10 being (FinSequence of ( SCM-Data-Loc )) such that L29: C10 = ( C7 `3_3 ) and L30: ( C7 address_1 ) = ( C10 /. 1 ) by L28 , L22;
L31: C10 = <* C8 , C9 *> by L28 , L29 , RECDEF_2:def 3;
thus L32: ( C7 address_1 ) = C8 by L31 , L30 , FINSEQ_4:17;
consider C11 being (FinSequence of ( SCM-Data-Loc )) such that L33: C11 = ( C7 `3_3 ) and L34: ( C7 address_2 ) = ( C11 /. 2 ) by L28 , L24;
L35: C11 = <* C8 , C9 *> by L28 , L33 , RECDEF_2:def 3;
thus L36: thesis by L35 , L34 , FINSEQ_4:17;
end;
definition
let C12 being non  empty 1-sorted;
let C13 being (Element of ( SCM-Instr C12 ));
given C14 being (Element of ( NAT )) , R4 being (Element of ( Segm 8 )) such that
L37: C13 = [ R4 , <* C14 *> , ( {} ) ];

func C13 jump_address -> (Element of ( NAT )) means 
:L38: (ex B28 being (FinSequence of ( NAT )) st (B28 = ( C13 `2_3 ) & it = ( B28 /. 1 )));
existence
proof
take C14;
take <* C14 *>;
thus L39: thesis by L37 , FINSEQ_4:16 , RECDEF_2:def 2;
end;
uniqueness;
end;
theorem
L41: (for R4 being (Element of ( Segm 8 )) holds (for R11 being non  empty 1-sorted holds (for B29 being (Element of ( SCM-Instr R11 )) holds (for B30 being (Element of ( NAT )) holds (B29 = [ R4 , <* B30 *> , ( {} ) ] implies ( B29 jump_address ) = B30)))))
proof
let R4 being (Element of ( Segm 8 ));
let R11 being non  empty 1-sorted;
let C15 being (Element of ( SCM-Instr R11 ));
let C16 being (Element of ( NAT ));
assume L42: C15 = [ R4 , <* C16 *> , ( {} ) ];
consider C17 being (FinSequence of ( NAT )) such that L43: C17 = ( C15 `2_3 ) and L44: ( C15 jump_address ) = ( C17 /. 1 ) by L42 , L38;
L45: C17 = <* C16 *> by L42 , L43 , RECDEF_2:def 2;
thus L46: thesis by L45 , L44 , FINSEQ_4:16;
end;
definition
let C18 being non  empty 1-sorted;
let C19 being (Element of ( SCM-Instr C18 ));
given C20 being (Element of ( NAT )) , C21 being (Element of ( SCM-Data-Loc )) , R4 being (Element of ( Segm 8 )) such that
L47: C19 = [ R4 , <* C20 *> , <* C21 *> ];

func C19 cjump_address -> (Element of ( NAT )) means 
:L48: (ex B31 being (Element of ( NAT )) st (<* B31 *> = ( C19 `2_3 ) & it = ( <* B31 *> /. 1 )));
existence
proof
take C20;
take C20;
thus L49: thesis by L47 , FINSEQ_4:16 , RECDEF_2:def 2;
end;
uniqueness;
func C19 cond_address -> (Element of ( SCM-Data-Loc )) means 
:L50: (ex B32 being (Element of ( SCM-Data-Loc )) st (<* B32 *> = ( C19 `3_3 ) & it = ( <* B32 *> /. 1 )));
existence
proof
take C21;
take C21;
thus L51: thesis by L47 , FINSEQ_4:16 , RECDEF_2:def 3;
end;
uniqueness;
end;
theorem
L53: (for R4 being (Element of ( Segm 8 )) holds (for R11 being non  empty 1-sorted holds (for B33 being (Element of ( SCM-Instr R11 )) holds (for B34 being (Element of ( NAT )) holds (for B35 being (Element of ( SCM-Data-Loc )) holds (B33 = [ R4 , <* B34 *> , <* B35 *> ] implies (( B33 cjump_address ) = B34 & ( B33 cond_address ) = B35)))))))
proof
let R4 being (Element of ( Segm 8 ));
let R11 being non  empty 1-sorted;
let C22 being (Element of ( SCM-Instr R11 ));
let C23 being (Element of ( NAT ));
let C24 being (Element of ( SCM-Data-Loc ));
assume L54: C22 = [ R4 , <* C23 *> , <* C24 *> ];
consider C25 being (Element of ( NAT )) such that L55: <* C25 *> = ( C22 `2_3 ) and L56: ( C22 cjump_address ) = ( <* C25 *> /. 1 ) by L54 , L48;
L57: <* C25 *> = <* C23 *> by L54 , L55 , RECDEF_2:def 2;
thus L58: ( C22 cjump_address ) = C23 by L57 , L56 , FINSEQ_4:16;
consider C26 being (Element of ( SCM-Data-Loc )) such that L59: <* C26 *> = ( C22 `3_3 ) and L60: ( C22 cond_address ) = ( <* C26 *> /. 1 ) by L54 , L50;
L61: <* C26 *> = <* C24 *> by L54 , L59 , RECDEF_2:def 3;
thus L62: thesis by L61 , L60 , FINSEQ_4:16;
end;
definition
let C27 being non  empty 1-sorted;
let C28 being (Element of ( SCM-Data-Loc ));
let C29 being (Element of C27);
redefine func <*C28 , C29 *> -> (FinSequence of ( ( SCM-Data-Loc ) \/ (the carrier of C27) ));

coherence
proof
let C30 being set;
L63: ( dom <* C28 , C29 *> ) = { 1 , 2 } by FINSEQ_1:2 , FINSEQ_1:89;
assume L64: C30 in ( rng <* C28 , C29 *> );
consider C31 being set such that L65: C31 in ( dom <* C28 , C29 *> ) and L66: ( <* C28 , C29 *> . C31 ) = C30 by L64 , FUNCT_1:def 3;
per cases  by L65 , L63 , TARSKI:def 2;
suppose L67: C31 = 1;

L68: C30 = C28 by L67 , L66 , FINSEQ_1:44;
thus L69: thesis by L68 , XBOOLE_0:def 3;
end;
suppose L70: C31 = 2;

L71: C30 = C29 by L70 , L66 , FINSEQ_1:44;
thus L72: thesis by L71 , XBOOLE_0:def 3;
end;
end;
end;
definition
let C32 being non  empty 1-sorted;
let C33 being (Element of ( SCM-Instr C32 ));
given C34 being (Element of ( SCM-Data-Loc )) , C35 being (Element of C32) , R4 being (Element of ( Segm 8 )) such that
L75: C33 = [ R4 , ( {} ) , <* C34 , C35 *> ];

func C33 const_address -> (Element of ( SCM-Data-Loc )) means 
:L76: (ex B36 being (FinSequence of ( ( SCM-Data-Loc ) \/ (the carrier of C32) )) st (B36 = ( C33 `3_3 ) & it = ( B36 /. 1 )));
existence
proof
take C34;
take <* C34 , C35 *>;
L77: (C34 is (Element of ( ( SCM-Data-Loc ) \/ (the carrier of C32) )) & C35 is (Element of ( ( SCM-Data-Loc ) \/ (the carrier of C32) ))) by XBOOLE_0:def 3;
thus L78: thesis by L77 , L75 , FINSEQ_4:17 , RECDEF_2:def 3;
end;
uniqueness;
func C33 const_value -> (Element of C32) means 
:L79: (ex B37 being (FinSequence of ( ( SCM-Data-Loc ) \/ (the carrier of C32) )) st (B37 = ( C33 `3_3 ) & it = ( B37 /. 2 )));
existence
proof
take C35;
take <* C34 , C35 *>;
L80: (C34 is (Element of ( ( SCM-Data-Loc ) \/ (the carrier of C32) )) & C35 is (Element of ( ( SCM-Data-Loc ) \/ (the carrier of C32) ))) by XBOOLE_0:def 3;
thus L81: thesis by L80 , L75 , FINSEQ_4:17 , RECDEF_2:def 3;
end;
uniqueness;
end;
theorem
L83: (for R4 being (Element of ( Segm 8 )) holds (for R11 being non  empty 1-sorted holds (for B38 being (Element of ( SCM-Instr R11 )) holds (for B39 being (Element of ( SCM-Data-Loc )) holds (for B40 being (Element of R11) holds (B38 = [ R4 , ( {} ) , <* B39 , B40 *> ] implies (( B38 const_address ) = B39 & ( B38 const_value ) = B40)))))))
proof
let R4 being (Element of ( Segm 8 ));
let R11 being non  empty 1-sorted;
let C36 being (Element of ( SCM-Instr R11 ));
let C37 being (Element of ( SCM-Data-Loc ));
let C38 being (Element of R11);
L84: (C37 is (Element of ( ( SCM-Data-Loc ) \/ (the carrier of R11) )) & C38 is (Element of ( ( SCM-Data-Loc ) \/ (the carrier of R11) ))) by XBOOLE_0:def 3;
assume L85: C36 = [ R4 , ( {} ) , <* C37 , C38 *> ];
consider C39 being (FinSequence of ( ( SCM-Data-Loc ) \/ (the carrier of R11) )) such that L86: C39 = ( C36 `3_3 ) and L87: ( C36 const_address ) = ( C39 /. 1 ) by L85 , L76;
L88: C39 = <* C37 , C38 *> by L85 , L86 , RECDEF_2:def 3;
thus L89: ( C36 const_address ) = C37 by L88 , L87 , L84 , FINSEQ_4:17;
consider C40 being (FinSequence of ( ( SCM-Data-Loc ) \/ (the carrier of R11) )) such that L90: C40 = ( C36 `3_3 ) and L91: ( C36 const_value ) = ( C40 /. 2 ) by L85 , L79;
L92: C40 = <* C37 , C38 *> by L85 , L90 , RECDEF_2:def 3;
thus L93: thesis by L92 , L84 , L91 , FINSEQ_4:17;
end;
theorem
L94: (for B41 being non  empty 1-sorted holds ( SCM-Instr B41 ) c= [: ( NAT ) , ( ( NAT ) * ) , ( proj2 ( SCM-Instr B41 ) ) :])
proof
let C41 being non  empty 1-sorted;
set D3 = ( proj2 ( SCM-Instr C41 ) );
let C42 being set;
assume L95: C42 in ( SCM-Instr C41 );
L96: ( {} ) in ( ( NAT ) * ) by FINSEQ_1:49;
per cases  by L95 , XBOOLE_0:def 3;
suppose L97: C42 in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B42 , ( {} ) , <* B43 , B44 *> ] where B42 is (Element of ( Segm 8 )) , B43 , B44 is (Element of ( SCM-Data-Loc )) : B42 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B45 *> , ( {} ) ] where B45 is (Element of ( NAT )) : (not contradiction) } ) \/ { [ 7 , <* B46 *> , <* B47 *> ] where B46 is (Element of ( NAT )) , B47 is (Element of ( SCM-Data-Loc )) : (not contradiction) } );

per cases  by L97 , XBOOLE_0:def 3;
suppose L98: C42 in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B48 , ( {} ) , <* B49 , B50 *> ] where B48 is (Element of ( Segm 8 )) , B49 , B50 is (Element of ( SCM-Data-Loc )) : B48 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B51 *> , ( {} ) ] where B51 is (Element of ( NAT )) : (not contradiction) } );

per cases  by L98 , XBOOLE_0:def 3;
suppose L99: C42 in ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B52 , ( {} ) , <* B53 , B54 *> ] where B52 is (Element of ( Segm 8 )) , B53 , B54 is (Element of ( SCM-Data-Loc )) : B52 in { 1 , 2 , 3 , 4 } } );

per cases  by L99 , XBOOLE_0:def 3;
suppose L100: C42 in { [ ( 0 ) , ( {} ) , ( {} ) ] };

L101: C42 = [ ( 0 ) , ( {} ) , ( {} ) ] by L100 , TARSKI:def 1;
L102: (( 0 ) in ( NAT ) & ( {} ) in ( proj2 ( SCM-Instr C41 ) )) by L101 , L95 , XTUPLE_0:def 13;
thus L103: C42 in [: ( NAT ) , ( ( NAT ) * ) , D3 :] by L102 , L101 , L96 , MCART_1:69;
end;
suppose L104: C42 in { [ B55 , ( {} ) , <* B56 , B57 *> ] where B55 is (Element of ( Segm 8 )) , B56 , B57 is (Element of ( SCM-Data-Loc )) : B55 in { 1 , 2 , 3 , 4 } };

consider C43 being (Element of ( Segm 8 )), C44 , C45 being (Element of ( SCM-Data-Loc )) such that L105: (C42 = [ C43 , ( {} ) , <* C44 , C45 *> ] & C43 in { 1 , 2 , 3 , 4 }) by L104;
L106: (C43 in ( NAT ) & <* C44 , C45 *> in ( proj2 ( SCM-Instr C41 ) )) by L105 , L95 , XTUPLE_0:def 13;
thus L107: C42 in [: ( NAT ) , ( ( NAT ) * ) , D3 :] by L106 , L105 , L96 , MCART_1:69;
end;
end;
suppose L109: C42 in { [ 6 , <* B58 *> , ( {} ) ] where B58 is (Element of ( NAT )) : (not contradiction) };

consider C46 being (Element of ( NAT )) such that L110: C42 = [ 6 , <* C46 *> , ( {} ) ] by L109;
L111: <* C46 *> in ( ( NAT ) * ) by FUNCT_7:18;
L112: (6 in ( NAT ) & ( {} ) in ( proj2 ( SCM-Instr C41 ) )) by L110 , L95 , XTUPLE_0:def 13;
thus L113: C42 in [: ( NAT ) , ( ( NAT ) * ) , D3 :] by L112 , L110 , L111 , MCART_1:69;
end;
end;
suppose L115: C42 in { [ 7 , <* B59 *> , <* B60 *> ] where B59 is (Element of ( NAT )) , B60 is (Element of ( SCM-Data-Loc )) : (not contradiction) };

consider C47 being (Element of ( NAT )), C48 being (Element of ( SCM-Data-Loc )) such that L116: C42 = [ 7 , <* C47 *> , <* C48 *> ] by L115;
L117: <* C47 *> in ( ( NAT ) * ) by FUNCT_7:18;
L118: (7 in ( NAT ) & <* C48 *> in ( proj2 ( SCM-Instr C41 ) )) by L116 , L95 , XTUPLE_0:def 13;
thus L119: C42 in [: ( NAT ) , ( ( NAT ) * ) , D3 :] by L118 , L116 , L117 , MCART_1:69;
end;
end;
suppose L121: C42 in { [ 5 , ( {} ) , <* B61 , B62 *> ] where B61 is (Element of ( SCM-Data-Loc )) , B62 is (Element of C41) : (not contradiction) };

consider C49 being (Element of ( SCM-Data-Loc )), C50 being (Element of C41) such that L122: C42 = [ 5 , ( {} ) , <* C49 , C50 *> ] by L121;
L123: (5 in ( NAT ) & <* C49 , C50 *> in ( proj2 ( SCM-Instr C41 ) )) by L122 , L95 , XTUPLE_0:def 13;
thus L124: C42 in [: ( NAT ) , ( ( NAT ) * ) , D3 :] by L123 , L122 , L96 , MCART_1:69;
end;
end;
registration
let C51 being non  empty 1-sorted;
cluster ( proj2 ( SCM-Instr C51 ) ) ->  FinSequence-membered;
coherence
proof
let C52 being set;
assume L126: C52 in ( proj2 ( SCM-Instr C51 ) );
consider C53 being set such that L127: [ C53 , C52 ] in ( SCM-Instr C51 ) by L126 , XTUPLE_0:def 13;
set D4 = [ C53 , C52 ];
per cases  by L127 , XBOOLE_0:def 3;
suppose L128: D4 in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B63 , ( {} ) , <* B64 , B65 *> ] where B63 is (Element of ( Segm 8 )) , B64 , B65 is (Element of ( SCM-Data-Loc )) : B63 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B66 *> , ( {} ) ] where B66 is (Element of ( NAT )) : (not contradiction) } ) \/ { [ 7 , <* B67 *> , <* B68 *> ] where B67 is (Element of ( NAT )) , B68 is (Element of ( SCM-Data-Loc )) : (not contradiction) } );

per cases  by L128 , XBOOLE_0:def 3;
suppose L129: D4 in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B69 , ( {} ) , <* B70 , B71 *> ] where B69 is (Element of ( Segm 8 )) , B70 , B71 is (Element of ( SCM-Data-Loc )) : B69 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B72 *> , ( {} ) ] where B72 is (Element of ( NAT )) : (not contradiction) } );

per cases  by L129 , XBOOLE_0:def 3;
suppose L130: D4 in ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B73 , ( {} ) , <* B74 , B75 *> ] where B73 is (Element of ( Segm 8 )) , B74 , B75 is (Element of ( SCM-Data-Loc )) : B73 in { 1 , 2 , 3 , 4 } } );

per cases  by L130 , XBOOLE_0:def 3;
suppose L131: D4 in { [ ( 0 ) , ( {} ) , ( {} ) ] };

L132: D4 = [ ( 0 ) , ( {} ) , ( {} ) ] by L131 , TARSKI:def 1;
L133: C52 = ( {} ) by L132 , XTUPLE_0:1;
thus L134: C52 is FinSequence by L133;
end;
suppose L135: D4 in { [ B76 , ( {} ) , <* B77 , B78 *> ] where B76 is (Element of ( Segm 8 )) , B77 , B78 is (Element of ( SCM-Data-Loc )) : B76 in { 1 , 2 , 3 , 4 } };

consider C54 being (Element of ( Segm 8 )), C55 , C56 being (Element of ( SCM-Data-Loc )) such that L136: (D4 = [ C54 , ( {} ) , <* C55 , C56 *> ] & C54 in { 1 , 2 , 3 , 4 }) by L135;
L137: C52 = <* C55 , C56 *> by L136 , XTUPLE_0:1;
thus L138: C52 is FinSequence by L137;
end;
end;
suppose L140: D4 in { [ 6 , <* B79 *> , ( {} ) ] where B79 is (Element of ( NAT )) : (not contradiction) };

consider C57 being (Element of ( NAT )) such that L141: D4 = [ 6 , <* C57 *> , ( {} ) ] by L140;
L142: C52 = ( {} ) by L141 , XTUPLE_0:1;
thus L143: C52 is FinSequence by L142;
end;
end;
suppose L145: D4 in { [ 7 , <* B80 *> , <* B81 *> ] where B80 is (Element of ( NAT )) , B81 is (Element of ( SCM-Data-Loc )) : (not contradiction) };

consider C58 being (Element of ( NAT )), C59 being (Element of ( SCM-Data-Loc )) such that L146: D4 = [ 7 , <* C58 *> , <* C59 *> ] by L145;
L147: C52 = <* C59 *> by L146 , XTUPLE_0:1;
thus L148: C52 is FinSequence by L147;
end;
end;
suppose L150: D4 in { [ 5 , ( {} ) , <* B82 , B83 *> ] where B82 is (Element of ( SCM-Data-Loc )) , B83 is (Element of C51) : (not contradiction) };

consider C60 being (Element of ( SCM-Data-Loc )), C61 being (Element of C51) such that L151: D4 = [ 5 , ( {} ) , <* C60 , C61 *> ] by L150;
L152: C52 = <* C60 , C61 *> by L151 , XTUPLE_0:1;
thus L153: C52 is FinSequence by L152;
end;
end;
end;
theorem
L156: (for R11 being non  empty 1-sorted holds [ ( 0 ) , ( {} ) , ( {} ) ] in ( SCM-Instr R11 ))
proof
let R11 being non  empty 1-sorted;
L157: [ ( 0 ) , ( {} ) , ( {} ) ] in { [ ( 0 ) , ( {} ) , ( {} ) ] } by TARSKI:def 1;
L158: [ ( 0 ) , ( {} ) , ( {} ) ] in ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ R4 , ( {} ) , <* B84 , B85 *> ] where R4 is (Element of ( Segm 8 )) , B84 , B85 is (Element of ( SCM-Data-Loc )) : R4 in { 1 , 2 , 3 , 4 } } ) by L157 , XBOOLE_0:def 3;
L159: [ ( 0 ) , ( {} ) , ( {} ) ] in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ R4 , ( {} ) , <* B86 , B87 *> ] where R4 is (Element of ( Segm 8 )) , B86 , B87 is (Element of ( SCM-Data-Loc )) : R4 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B88 *> , ( {} ) ] where B88 is (Element of ( NAT )) : (not contradiction) } ) by L158 , XBOOLE_0:def 3;
L160: [ ( 0 ) , ( {} ) , ( {} ) ] in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ R4 , ( {} ) , <* B89 , B90 *> ] where R4 is (Element of ( Segm 8 )) , B89 , B90 is (Element of ( SCM-Data-Loc )) : R4 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B91 *> , ( {} ) ] where B91 is (Element of ( NAT )) : (not contradiction) } ) \/ { [ 7 , <* B92 *> , <* B93 *> ] where B92 is (Element of ( NAT )) , B93 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) by L159 , XBOOLE_0:def 3;
thus L161: thesis by L160 , XBOOLE_0:def 3;
end;
theorem
L162: (for B94 being non  empty 1-sorted holds (for B95 being (Element of ( SCM-Instr B94 )) holds ((B95 in { [ ( 0 ) , ( {} ) , ( {} ) ] } & ( InsCode B95 ) = ( 0 )) or (B95 in { [ B96 , ( {} ) , <* B97 , B98 *> ] where B96 is (Element of ( Segm 8 )) , B97 , B98 is (Element of ( SCM-Data-Loc )) : B96 in { 1 , 2 , 3 , 4 } } & (( InsCode B95 ) = 1 or ( InsCode B95 ) = 2 or ( InsCode B95 ) = 3 or ( InsCode B95 ) = 4)) or (B95 in { [ 6 , <* B99 *> , ( {} ) ] where B99 is (Element of ( NAT )) : (not contradiction) } & ( InsCode B95 ) = 6) or (B95 in { [ 7 , <* B100 *> , <* B101 *> ] where B100 is (Element of ( NAT )) , B101 is (Element of ( SCM-Data-Loc )) : (not contradiction) } & ( InsCode B95 ) = 7) or (B95 in { [ 5 , ( {} ) , <* B102 , B103 *> ] where B102 is (Element of ( SCM-Data-Loc )) , B103 is (Element of B94) : (not contradiction) } & ( InsCode B95 ) = 5))))
proof
let C62 being non  empty 1-sorted;
let C63 being (Element of ( SCM-Instr C62 ));
L163: (C63 in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B104 , ( {} ) , <* B105 , B106 *> ] where B104 is (Element of ( Segm 8 )) , B105 , B106 is (Element of ( SCM-Data-Loc )) : B104 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B107 *> , ( {} ) ] where B107 is (Element of ( NAT )) : (not contradiction) } ) \/ { [ 7 , <* B108 *> , <* B109 *> ] where B108 is (Element of ( NAT )) , B109 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) or C63 in { [ 5 , ( {} ) , <* B110 , B111 *> ] where B110 is (Element of ( SCM-Data-Loc )) , B111 is (Element of C62) : (not contradiction) }) by XBOOLE_0:def 3;
L164: (C63 in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B112 , ( {} ) , <* B113 , B114 *> ] where B112 is (Element of ( Segm 8 )) , B113 , B114 is (Element of ( SCM-Data-Loc )) : B112 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B115 *> , ( {} ) ] where B115 is (Element of ( NAT )) : (not contradiction) } ) or C63 in { [ 7 , <* B116 *> , <* B117 *> ] where B116 is (Element of ( NAT )) , B117 is (Element of ( SCM-Data-Loc )) : (not contradiction) } or C63 in { [ 5 , ( {} ) , <* B118 , B119 *> ] where B118 is (Element of ( SCM-Data-Loc )) , B119 is (Element of C62) : (not contradiction) }) by L163 , XBOOLE_0:def 3;
L165: (C63 in ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B120 , ( {} ) , <* B121 , B122 *> ] where B120 is (Element of ( Segm 8 )) , B121 , B122 is (Element of ( SCM-Data-Loc )) : B120 in { 1 , 2 , 3 , 4 } } ) or C63 in { [ 6 , <* B123 *> , ( {} ) ] where B123 is (Element of ( NAT )) : (not contradiction) } or C63 in { [ 7 , <* B124 *> , <* B125 *> ] where B124 is (Element of ( NAT )) , B125 is (Element of ( SCM-Data-Loc )) : (not contradiction) } or C63 in { [ 5 , ( {} ) , <* B126 , B127 *> ] where B126 is (Element of ( SCM-Data-Loc )) , B127 is (Element of C62) : (not contradiction) }) by L164 , XBOOLE_0:def 3;
per cases  by L165 , XBOOLE_0:def 3;
case L166: C63 in { [ ( 0 ) , ( {} ) , ( {} ) ] };
L167: C63 = [ ( 0 ) , ( {} ) , ( {} ) ] by L166 , TARSKI:def 1;
thus L168: thesis by L167 , RECDEF_2:def 1;
end;
case L169: C63 in { [ B128 , ( {} ) , <* B129 , B130 *> ] where B128 is (Element of ( Segm 8 )) , B129 , B130 is (Element of ( SCM-Data-Loc )) : B128 in { 1 , 2 , 3 , 4 } };
consider C64 being (Element of ( Segm 8 )), C65 , C66 being (Element of ( SCM-Data-Loc )) such that L170: C63 = [ C64 , ( {} ) , <* C65 , C66 *> ] and L171: C64 in { 1 , 2 , 3 , 4 } by L169;
L172: ( InsCode C63 ) = C64 by L170 , RECDEF_2:def 1;
thus L173: thesis by L172 , L171 , ENUMSET1:def 2;
end;
case L174: C63 in { [ 6 , <* B131 *> , ( {} ) ] where B131 is (Element of ( NAT )) : (not contradiction) };
L175: (ex R1 being (Element of ( NAT )) st C63 = [ 6 , <* R1 *> , ( {} ) ]) by L174;
thus L176: thesis by L175 , RECDEF_2:def 1;
end;
case L177: C63 in { [ 7 , <* B132 *> , <* B133 *> ] where B132 is (Element of ( NAT )) , B133 is (Element of ( SCM-Data-Loc )) : (not contradiction) };
L178: (ex B134 being (Element of ( NAT )) st (ex B135 being (Element of ( SCM-Data-Loc )) st C63 = [ 7 , <* B134 *> , <* B135 *> ])) by L177;
thus L179: thesis by L178 , RECDEF_2:def 1;
end;
case L180: C63 in { [ 5 , ( {} ) , <* B136 , B137 *> ] where B136 is (Element of ( SCM-Data-Loc )) , B137 is (Element of C62) : (not contradiction) };
L181: (ex B138 being (Element of ( SCM-Data-Loc )) st (ex B139 being (Element of C62) st C63 = [ 5 , ( {} ) , <* B138 , B139 *> ])) by L180;
thus L182: thesis by L181 , RECDEF_2:def 1;
end;
end;
begin
registration
cluster  strict  trivial for Ring;
existence
proof
take the  strict 1 -element doubleLoopStr;
thus L184: thesis;
end;
end;
registration
let C67 being Ring;
cluster ( SCM-Instr C67 ) ->  standard-ins;
coherence
proof
consider C68 being non  empty set such that L186: ( proj2 ( SCM-Instr C67 ) ) c= ( C68 * ) by FINSEQ_1:85;
take C68;
L187: ( SCM-Instr C67 ) c= [: ( NAT ) , ( ( NAT ) * ) , ( proj2 ( SCM-Instr C67 ) ) :] by L94;
L188: [: ( NAT ) , ( ( NAT ) * ) , ( proj2 ( SCM-Instr C67 ) ) :] c= [: ( NAT ) , ( ( NAT ) * ) , ( C68 * ) :] by L186 , MCART_1:73;
thus L189: ( SCM-Instr C67 ) c= [: ( NAT ) , ( ( NAT ) * ) , ( C68 * ) :] by L188 , L187 , XBOOLE_1:1;
end;
end;
L191: (for B140 being Ring holds (for B141 being (Element of ( SCM-Instr B140 )) holds ( InsCode B141 ) <= 7))
proof
let C69 being Ring;
let C70 being (Element of ( SCM-Instr C69 ));
L192: (( InsCode C70 ) = ( 0 ) or ( InsCode C70 ) = 1 or ( InsCode C70 ) = 2 or ( InsCode C70 ) = 3 or ( InsCode C70 ) = 4 or ( InsCode C70 ) = 5 or ( InsCode C70 ) = 6 or ( InsCode C70 ) = 7) by L162;
thus L193: thesis by L192;
end;
L194: (for B142 being non  empty 1-sorted holds (for B143 being (Element of ( SCM-Instr B142 )) holds ((( InsCode B143 ) = 1 or ( InsCode B143 ) = 2 or ( InsCode B143 ) = 3 or ( InsCode B143 ) = 4) implies ( JumpPart B143 ) = ( {} ))))
proof
let C71 being non  empty 1-sorted;
let C72 being (Element of ( SCM-Instr C71 ));
assume L195: (( InsCode C72 ) = 1 or ( InsCode C72 ) = 2 or ( InsCode C72 ) = 3 or ( InsCode C72 ) = 4);
L196: C72 in { [ B144 , ( {} ) , <* B145 , B146 *> ] where B144 is (Element of ( Segm 8 )) , B145 , B146 is (Element of ( SCM-Data-Loc )) : B144 in { 1 , 2 , 3 , 4 } } by L195 , L162;
L197: (ex B147 being (Element of ( Segm 8 )) st (ex B148 , B149 being (Element of ( SCM-Data-Loc )) st (C72 = [ B147 , ( {} ) , <* B148 , B149 *> ] & B147 in { 1 , 2 , 3 , 4 }))) by L196;
thus L198: thesis by L197 , RECDEF_2:def 2;
end;
L199: (for B150 being non  empty 1-sorted holds (for B151 being (Element of ( SCM-Instr B150 )) holds (( InsCode B151 ) = 5 implies ( JumpPart B151 ) = ( {} ))))
proof
let C73 being non  empty 1-sorted;
let C74 being (Element of ( SCM-Instr C73 ));
assume L200: ( InsCode C74 ) = 5;
L201: C74 in { [ 5 , ( {} ) , <* B152 , B153 *> ] where B152 is (Element of ( SCM-Data-Loc )) , B153 is (Element of C73) : (not contradiction) } by L200 , L162;
L202: (ex B154 being (Element of ( SCM-Data-Loc )) st (ex B155 being (Element of C73) st C74 = [ 5 , ( {} ) , <* B154 , B155 *> ])) by L201;
thus L203: thesis by L202 , RECDEF_2:def 2;
end;
L204: (for B156 being Ring holds (for B157 being (Element of ( SCM-Instr B156 )) holds (( InsCode B157 ) = 6 implies ( dom ( JumpPart B157 ) ) = ( Seg 1 ))))
proof
let C75 being Ring;
let C76 being (Element of ( SCM-Instr C75 ));
assume L205: ( InsCode C76 ) = 6;
L206: C76 in { [ 6 , <* B158 *> , ( {} ) ] where B158 is (Element of ( NAT )) : (not contradiction) } by L205 , L162;
consider C77 being (Element of ( NAT )) such that L207: C76 = [ 6 , <* C77 *> , ( {} ) ] by L206;
L208: ( JumpPart C76 ) = <* C77 *> by L207 , RECDEF_2:def 2;
thus L209: thesis by L208 , FINSEQ_1:38;
end;
L210: (for B159 being Ring holds (for B160 being (Element of ( SCM-Instr B159 )) holds (( InsCode B160 ) = 7 implies ( dom ( JumpPart B160 ) ) = ( Seg 1 ))))
proof
let C78 being Ring;
let C79 being (Element of ( SCM-Instr C78 ));
assume L211: ( InsCode C79 ) = 7;
L212: C79 in { [ 7 , <* B161 *> , <* B162 *> ] where B161 is (Element of ( NAT )) , B162 is (Element of ( SCM-Data-Loc )) : (not contradiction) } by L211 , L162;
consider C80 being (Element of ( NAT )), C81 being (Element of ( SCM-Data-Loc )) such that L213: C79 = [ 7 , <* C80 *> , <* C81 *> ] by L212;
L214: ( JumpPart C79 ) = <* C80 *> by L213 , RECDEF_2:def 2;
thus L215: thesis by L214 , FINSEQ_1:38;
end;
registration
let C82 being Ring;
cluster ( SCM-Instr C82 ) ->  homogeneous;
coherence
proof
let C83 , C84 being (Element of ( SCM-Instr C82 ));
assume that
L216: ( InsCode C83 ) = ( InsCode C84 );
L217: ( InsCode C83 ) <= 7 by L191;
per cases  by L217 , NAT_1:31;
suppose L218: ( InsCode C83 ) = ( 0 );

L219: (C83 in { [ ( 0 ) , ( {} ) , ( {} ) ] } & C84 in { [ ( 0 ) , ( {} ) , ( {} ) ] }) by L218 , L216 , L162;
L220: (C83 = [ ( 0 ) , ( {} ) , ( {} ) ] & C84 = [ ( 0 ) , ( {} ) , ( {} ) ]) by L219 , TARSKI:def 1;
thus L221: thesis by L220;
end;
suppose L222: (( InsCode C83 ) = 1 or ( InsCode C83 ) = 2 or ( InsCode C83 ) = 3 or ( InsCode C83 ) = 4);

L223: (( JumpPart C83 ) = ( {} ) & ( JumpPart C84 ) = ( {} )) by L222 , L216 , L194;
thus L224: thesis by L223;
end;
suppose L225: ( InsCode C83 ) = 5;

L226: (( JumpPart C83 ) = ( {} ) & ( JumpPart C84 ) = ( {} )) by L225 , L216 , L199;
thus L227: thesis by L226;
end;
suppose L228: ( InsCode C83 ) = 6;

L229: (( dom ( JumpPart C83 ) ) = ( Seg 1 ) & ( dom ( JumpPart C84 ) ) = ( Seg 1 )) by L228 , L216 , L204;
thus L230: thesis by L229;
end;
suppose L231: ( InsCode C83 ) = 7;

L232: (( dom ( JumpPart C83 ) ) = ( Seg 1 ) & ( dom ( JumpPart C84 ) ) = ( Seg 1 )) by L231 , L216 , L210;
thus L233: thesis by L232;
end;
end;
end;
registration
let C85 being Ring;
cluster ( SCM-Instr C85 ) ->  J/A-independent;
coherence
proof
let C86 being (InsType of ( SCM-Instr C85 ));
let C87 , C88 being  natural-valued Function;
assume that
L236: C87 in ( JumpParts C86 )
and
L237: ( dom C87 ) = ( dom C88 );
let C89 being set;
assume that
L238: [ C86 , C87 , C89 ] in ( SCM-Instr C85 );
reconsider D5 = [ C86 , C87 , C89 ] as (Element of ( SCM-Instr C85 )) by L238;
L239: ( InsCode D5 ) = C86 by RECDEF_2:def 1;
L240: ( InsCode D5 ) <= 7 by L191;
per cases  by L240 , L239 , NAT_1:31;
suppose L241: C86 = ( 0 );

L242: D5 in { [ ( 0 ) , ( {} ) , ( {} ) ] } by L241 , L239 , L162;
L243: D5 = [ ( 0 ) , ( {} ) , ( {} ) ] by L242 , TARSKI:def 1;
L244: ( JumpPart D5 ) = ( {} ) by L243 , RECDEF_2:def 2;
L245: ( JumpParts C86 ) = { ( 0 ) } by L244 , L239 , COMPOS_0:11;
L246: C87 = ( 0 ) by L245 , L236 , TARSKI:def 1;
L247: C87 = C88 by L246 , L237;
thus L248: [ C86 , C88 , C89 ] in ( SCM-Instr C85 ) by L247 , L238;
end;
suppose L249: (C86 = 1 or C86 = 2 or C86 = 3 or C86 = 4);

L250: D5 in { [ B163 , ( {} ) , <* B164 , B165 *> ] where B163 is (Element of ( Segm 8 )) , B164 , B165 is (Element of ( SCM-Data-Loc )) : B163 in { 1 , 2 , 3 , 4 } } by L249 , L239 , L162;
L251: (ex B166 being (Element of ( Segm 8 )) st (ex B167 , B168 being (Element of ( SCM-Data-Loc )) st (D5 = [ B166 , ( {} ) , <* B167 , B168 *> ] & B166 in { 1 , 2 , 3 , 4 }))) by L250;
L252: ( JumpPart D5 ) = ( {} ) by L251 , RECDEF_2:def 2;
L253: ( JumpParts C86 ) = { ( 0 ) } by L252 , L239 , COMPOS_0:11;
L254: C87 = ( 0 ) by L253 , L236 , TARSKI:def 1;
L255: C87 = C88 by L254 , L237;
thus L256: [ C86 , C88 , C89 ] in ( SCM-Instr C85 ) by L255 , L238;
end;
suppose L257: C86 = 5;

L258: D5 in { [ 5 , ( {} ) , <* B169 , B170 *> ] where B169 is (Element of ( SCM-Data-Loc )) , B170 is (Element of C85) : (not contradiction) } by L257 , L239 , L162;
L259: (ex B171 being (Element of ( SCM-Data-Loc )) st (ex B172 being (Element of C85) st D5 = [ 5 , ( {} ) , <* B171 , B172 *> ])) by L258;
L260: ( JumpPart D5 ) = ( {} ) by L259 , RECDEF_2:def 2;
L261: ( JumpParts C86 ) = { ( 0 ) } by L260 , L239 , COMPOS_0:11;
L262: C87 = ( 0 ) by L261 , L236 , TARSKI:def 1;
L263: C87 = C88 by L262 , L237;
thus L264: [ C86 , C88 , C89 ] in ( SCM-Instr C85 ) by L263 , L238;
end;
suppose L265: C86 = 6;

reconsider D6 = [ C86 , C87 , C89 ] as (Element of ( SCM-Instr C85 )) by L238;
L266: ( InsCode D6 ) = 6 by L265 , RECDEF_2:def 1;
L267: D6 in { [ 6 , <* B173 *> , ( {} ) ] where B173 is (Element of ( NAT )) : (not contradiction) } by L266 , L162;
consider C90 being (Element of ( NAT )) such that L268: D6 = [ 6 , <* C90 *> , ( {} ) ] by L267;
L269: C89 = ( {} ) by L268 , XTUPLE_0:3;
L270: C87 = <* C90 *> by L268 , XTUPLE_0:3;
L271: ( dom C88 ) = { 1 } by L270 , L237 , FINSEQ_1:2 , FINSEQ_1:38;
reconsider D7 = ( C88 . 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
set D8 = [ C86 , C88 , ( {} ) ];
L272: D8 = [ 6 , <* D7 *> , ( {} ) ] by L265 , L271 , FINSEQ_1:2 , FINSEQ_1:def 8;
L273: [ 6 , <* D7 *> , ( {} ) ] in { [ 6 , <* B174 *> , ( {} ) ] where B174 is (Element of ( NAT )) : (not contradiction) };
L274: [ 6 , <* D7 *> , ( {} ) ] in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B175 , ( {} ) , <* B176 , B177 *> ] where B175 is (Element of ( Segm 8 )) , B176 , B177 is (Element of ( SCM-Data-Loc )) : B175 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B178 *> , ( {} ) ] where B178 is (Element of ( NAT )) : (not contradiction) } ) by L273 , XBOOLE_0:def 3;
L275: [ 6 , <* D7 *> , ( {} ) ] in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B179 , ( {} ) , <* B180 , B181 *> ] where B179 is (Element of ( Segm 8 )) , B180 , B181 is (Element of ( SCM-Data-Loc )) : B179 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B182 *> , ( {} ) ] where B182 is (Element of ( NAT )) : (not contradiction) } ) \/ { [ 7 , <* B183 *> , <* B184 *> ] where B183 is (Element of ( NAT )) , B184 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) by L274 , XBOOLE_0:def 3;
L276: [ 6 , <* D7 *> , ( {} ) ] in ( SCM-Instr C85 ) by L275 , XBOOLE_0:def 3;
reconsider D9 = D8 as (Element of ( SCM-Instr C85 )) by L276 , L272;
L277: C88 = ( JumpPart D9 ) by RECDEF_2:def 2;
thus L278: [ C86 , C88 , C89 ] in ( SCM-Instr C85 ) by L277 , L269;
end;
suppose L279: C86 = 7;

reconsider D10 = [ C86 , C87 , C89 ] as (Element of ( SCM-Instr C85 )) by L238;
L280: ( InsCode D10 ) = C86 by RECDEF_2:def 1;
L281: D10 in { [ 7 , <* B185 *> , <* B186 *> ] where B185 is (Element of ( NAT )) , B186 is (Element of ( SCM-Data-Loc )) : (not contradiction) } by L280 , L279 , L162;
consider C91 being (Element of ( NAT )), C92 being (Element of ( SCM-Data-Loc )) such that L282: D10 = [ 7 , <* C91 *> , <* C92 *> ] by L281;
L283: C89 = <* C92 *> by L282 , XTUPLE_0:3;
L284: C87 = <* C91 *> by L282 , XTUPLE_0:3;
L285: ( dom C88 ) = { 1 } by L284 , L237 , FINSEQ_1:2 , FINSEQ_1:38;
reconsider D11 = ( C88 . 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
set D12 = [ C86 , C88 , C89 ];
L286: D12 = [ C86 , <* D11 *> , <* C92 *> ] by L283 , L285 , FINSEQ_1:2 , FINSEQ_1:def 8;
L287: [ ( InsCode D12 ) , <* D11 *> , <* C92 *> ] in { [ 7 , <* B187 *> , <* B188 *> ] where B187 is (Element of ( NAT )) , B188 is (Element of ( SCM-Data-Loc )) : (not contradiction) } by L279;
L288: [ ( InsCode D12 ) , <* D11 *> , <* C92 *> ] in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B189 , ( {} ) , <* B190 , B191 *> ] where B189 is (Element of ( Segm 8 )) , B190 , B191 is (Element of ( SCM-Data-Loc )) : B189 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B192 *> , ( {} ) ] where B192 is (Element of ( NAT )) : (not contradiction) } ) \/ { [ 7 , <* B193 *> , <* B194 *> ] where B193 is (Element of ( NAT )) , B194 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) by L287 , XBOOLE_0:def 3;
L289: [ ( InsCode D12 ) , <* D11 *> , <* C92 *> ] in ( ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B195 , ( {} ) , <* B196 , B197 *> ] where B195 is (Element of ( Segm 8 )) , B196 , B197 is (Element of ( SCM-Data-Loc )) : B195 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B198 *> , ( {} ) ] where B198 is (Element of ( NAT )) : (not contradiction) } ) \/ { [ 7 , <* B199 *> , <* B200 *> ] where B199 is (Element of ( NAT )) , B200 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) \/ { [ 5 , ( {} ) , <* B201 , B202 *> ] where B201 is (Element of ( SCM-Data-Loc )) , B202 is (Element of C85) : (not contradiction) } ) by L288 , XBOOLE_0:def 3;
L290: [ ( InsCode D12 ) , <* D11 *> , <* C92 *> ] in ( SCM-Instr C85 ) by L289;
reconsider D13 = D12 as (Element of ( SCM-Instr C85 )) by L290 , L286;
L291: ( InsCode D13 ) = C86 by RECDEF_2:def 1;
L292: D13 in { [ 7 , <* B203 *> , <* B204 *> ] where B203 is (Element of ( NAT )) , B204 is (Element of ( SCM-Data-Loc )) : (not contradiction) } by L291 , L279 , L162;
consider C93 being (Element of ( NAT )), C94 being (Element of ( SCM-Data-Loc )) such that L293: D13 = [ 7 , <* C93 *> , <* C94 *> ] by L292;
L294: 7 = ( InsCode D13 ) by L293 , RECDEF_2:def 1
.= C86 by RECDEF_2:def 1;
L295: D13 = [ C86 , <* C93 *> , <* C94 *> ] by L294 , L293;
thus L296: [ C86 , C88 , C89 ] in ( SCM-Instr C85 ) by L295;
end;
end;
end;
theorem
L299: (for R14 being non  empty 1-sorted holds (for R16 being set holds (for R25 being (Element of ( SCM-Data-Loc )) holds (for R26 being (Element of ( SCM-Data-Loc )) holds (R16 in { 1 , 2 , 3 , 4 } implies [ R16 , ( {} ) , <* R25 , R26 *> ] in ( SCM-Instr R14 ))))))
proof
let R14 being non  empty 1-sorted;
let R16 being set;
let R25 being (Element of ( SCM-Data-Loc ));
let R26 being (Element of ( SCM-Data-Loc ));
reconsider D14 = R25 , D15 = R26 as (Element of ( SCM-Data-Loc ));
assume L300: R16 in { 1 , 2 , 3 , 4 };
L301: (R16 = 1 or R16 = 2 or R16 = 3 or R16 = 4) by L300 , ENUMSET1:def 2;
reconsider D16 = R16 as (Element of ( Segm 8 )) by L301 , NAT_1:44;
L302: [ D16 , ( {} ) , <* D14 , D15 *> ] in { [ R13 , ( {} ) , <* B205 , B206 *> ] where R13 is (Element of ( Segm 8 )) , B205 , B206 is (Element of ( SCM-Data-Loc )) : R13 in { 1 , 2 , 3 , 4 } } by L300;
L303: [ D16 , ( {} ) , <* D14 , D15 *> ] in ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ R13 , ( {} ) , <* B207 , B208 *> ] where R13 is (Element of ( Segm 8 )) , B207 , B208 is (Element of ( SCM-Data-Loc )) : R13 in { 1 , 2 , 3 , 4 } } ) by L302 , XBOOLE_0:def 3;
L304: [ D16 , ( {} ) , <* D14 , D15 *> ] in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ R13 , ( {} ) , <* B209 , B210 *> ] where R13 is (Element of ( Segm 8 )) , B209 , B210 is (Element of ( SCM-Data-Loc )) : R13 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B211 *> , ( {} ) ] where B211 is (Element of ( NAT )) : (not contradiction) } ) by L303 , XBOOLE_0:def 3;
L305: [ D16 , ( {} ) , <* D14 , D15 *> ] in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ R13 , ( {} ) , <* B212 , B213 *> ] where R13 is (Element of ( Segm 8 )) , B212 , B213 is (Element of ( SCM-Data-Loc )) : R13 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B214 *> , ( {} ) ] where B214 is (Element of ( NAT )) : (not contradiction) } ) \/ { [ 7 , <* B215 *> , <* B216 *> ] where B215 is (Element of ( NAT )) , B216 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) by L304 , XBOOLE_0:def 3;
thus L306: thesis by L305 , XBOOLE_0:def 3;
end;
theorem
L307: (for R14 being non  empty 1-sorted holds (for R15 being (Element of R14) holds (for R25 being (Element of ( SCM-Data-Loc )) holds [ 5 , ( {} ) , <* R25 , R15 *> ] in ( SCM-Instr R14 ))))
proof
let R14 being non  empty 1-sorted;
let R15 being (Element of R14);
let R25 being (Element of ( SCM-Data-Loc ));
reconsider D17 = R25 as (Element of ( SCM-Data-Loc ));
L308: [ 5 , ( {} ) , <* D17 , R15 *> ] in { [ 5 , ( {} ) , <* B217 , B218 *> ] where B217 is (Element of ( SCM-Data-Loc )) , B218 is (Element of R14) : (not contradiction) };
thus L309: thesis by L308 , XBOOLE_0:def 3;
end;
theorem
L310: (for R14 being non  empty 1-sorted holds (for R27 being (Element of ( NAT )) holds [ 6 , <* R27 *> , ( {} ) ] in ( SCM-Instr R14 )))
proof
let R14 being non  empty 1-sorted;
let R27 being (Element of ( NAT ));
reconsider D18 = R27 as (Element of ( NAT ));
L311: [ 6 , <* D18 *> , ( {} ) ] in { [ 6 , <* B219 *> , ( {} ) ] where B219 is (Element of ( NAT )) : (not contradiction) };
L312: [ 6 , <* D18 *> , ( {} ) ] in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ R13 , ( {} ) , <* B220 , B221 *> ] where R13 is (Element of ( Segm 8 )) , B220 , B221 is (Element of ( SCM-Data-Loc )) : R13 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B222 *> , ( {} ) ] where B222 is (Element of ( NAT )) : (not contradiction) } ) by L311 , XBOOLE_0:def 3;
L313: [ 6 , <* D18 *> , ( {} ) ] in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ R13 , ( {} ) , <* B223 , B224 *> ] where R13 is (Element of ( Segm 8 )) , B223 , B224 is (Element of ( SCM-Data-Loc )) : R13 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B225 *> , ( {} ) ] where B225 is (Element of ( NAT )) : (not contradiction) } ) \/ { [ 7 , <* B226 *> , <* B227 *> ] where B226 is (Element of ( NAT )) , B227 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) by L312 , XBOOLE_0:def 3;
thus L314: thesis by L313 , XBOOLE_0:def 3;
end;
theorem
L315: (for R14 being non  empty 1-sorted holds (for R25 being (Element of ( SCM-Data-Loc )) holds (for R27 being (Element of ( NAT )) holds [ 7 , <* R27 *> , <* R25 *> ] in ( SCM-Instr R14 ))))
proof
let R14 being non  empty 1-sorted;
let R25 being (Element of ( SCM-Data-Loc ));
let R27 being (Element of ( NAT ));
reconsider D19 = R25 as (Element of ( SCM-Data-Loc ));
reconsider D20 = R27 as (Element of ( NAT ));
L316: [ 7 , <* D20 *> , <* D19 *> ] in { [ 7 , <* B228 *> , <* B229 *> ] where B228 is (Element of ( NAT )) , B229 is (Element of ( SCM-Data-Loc )) : (not contradiction) };
L317: [ 7 , <* D20 *> , <* D19 *> ] in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ R13 , ( {} ) , <* B230 , B231 *> ] where R13 is (Element of ( Segm 8 )) , B230 , B231 is (Element of ( SCM-Data-Loc )) : R13 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B232 *> , ( {} ) ] where B232 is (Element of ( NAT )) : (not contradiction) } ) \/ { [ 7 , <* B233 *> , <* B234 *> ] where B233 is (Element of ( NAT )) , B234 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) by L316 , XBOOLE_0:def 3;
thus L318: thesis by L317 , XBOOLE_0:def 3;
end;
registration
let R14 being non  empty 1-sorted;
cluster ( SCM-Instr R14 ) ->  with_halt;
coherence
proof
thus L319: [ ( 0 ) , ( {} ) , ( {} ) ] in ( SCM-Instr R14 ) by L156;
end;
end;
