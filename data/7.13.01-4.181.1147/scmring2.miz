:: The Basic Properties of { \bf SCM } over Ring
::  by Artur Korni{\l}owicz
::
:: Received November 29, 1998
:: Copyright (c) 1998-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, CARD_1, XBOOLE_0, STRUCT_0, FUNCSDOM, AMI_3,
      AMI_1, AMI_2, FUNCT_7, TARSKI, RELAT_1, FSM_1, FUNCT_1, CAT_1, FINSEQ_1,
      GRAPHSP, FUNCT_2, CARD_3, ORDINAL1, ARYTM_3, ARYTM_1, SUPINF_2, FUNCOP_1,
      SCMRING1, GLIB_000, FUNCT_4, RECDEF_2, GOBRD13, MEMSTR_0;
 notations TARSKI, XBOOLE_0,
      XTUPLE_0, SUBSET_1, DOMAIN_1, RELAT_1, FUNCT_1, CARD_1,
      FUNCT_2, RECDEF_2, STRUCT_0, ALGSTR_0, FUNCSDOM, CARD_3,
      FINSEQ_1, NUMBERS, FUNCOP_1, FUNCT_4, FUNCT_7, MEMSTR_0, COMPOS_0,
      COMPOS_1, EXTPRO_1, AMI_2, AMI_3, SCMRINGI, SCMRING1;
 constructors FINSEQ_4, REALSET1, AMI_3, SCMRING1, PRE_POLY, FUNCT_7, RELSET_1;
 registrations ORDINAL1, RELSET_1, FUNCOP_1, FINSEQ_1, CARD_3, STRUCT_0, AMI_3,
      SCMRING1, AMI_2, FUNCT_1, EXTPRO_1, SCMRINGI, SCM_INST, XTUPLE_0;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions XBOOLE_0, STRUCT_0, AMI_3, FUNCOP_1, SCMRING1, COMPOS_1, EXTPRO_1,
      CARD_1, NAT_1, AMI_2, MEMSTR_0, COMPOS_0, SCMRINGI, XTUPLE_0;
 theorems AMI_2, AMI_3, AMI_5, CARD_3, FUNCOP_1, ENUMSET1, FUNCT_4, SCMRING1,
      TARSKI, ZFMISC_1, XBOOLE_0, XBOOLE_1, FUNCT_7, NAT_1, FUNCT_1, PARTFUN1,
      RELAT_1, RECDEF_2, EXTPRO_1, MEMSTR_0, SCMRINGI;

begin
definition
let C1 being Ring;
func SCM C1 ->  strict AMI-Struct over 2 means 
:L1: ((the carrier of it) = ( SCM-Memory ) & (the ZeroF of it) = ( NAT ) & (the InstructionsF of it) = ( SCM-Instr C1 ) & (the Object-Kind of it) = ( SCM-OK ) & (the ValuesF of it) = ( SCM-VAL C1 ) & (the Execution of it) = ( SCM-Exec C1 ));
existence
proof
take AMI-Struct (# ( SCM-Memory ) , ( In (( NAT ) , ( SCM-Memory )) ) , ( SCM-Instr C1 ) , ( SCM-OK ) , ( SCM-VAL C1 ) , ( SCM-Exec C1 ) #);
thus L2: thesis by AMI_2:22 , FUNCT_7:def 1;
end;
uniqueness;
end;
registration
let C2 being Ring;
cluster ( SCM C2 ) -> non  empty;
coherence by L1;
end;
L5:
now
let C3 being Ring;
thus L6: ( the_Values_of ( SCM C3 ) ) = ( (the ValuesF of ( SCM C3 )) * (the Object-Kind of ( SCM C3 )) )
.= ( (the ValuesF of ( SCM C3 )) * ( SCM-OK ) ) by L1
.= ( ( SCM-VAL C3 ) * ( SCM-OK ) ) by L1;
end;
registration
let C4 being Ring;
cluster ( SCM C4 ) ->  with_non-empty_values;
coherence
proof
L7: ( the_Values_of ( SCM C4 ) ) = ( ( SCM-VAL C4 ) * ( SCM-OK ) ) by L5;
thus L8: ( the_Values_of ( SCM C4 ) ) is  non-empty by L7;
end;
end;
L10: (for B1 being Ring holds ( (the carrier of ( SCM B1 )) \ { ( NAT ) } ) = ( SCM-Data-Loc ))
proof
let C5 being Ring;
L11: (not ( NAT ) in ( SCM-Data-Loc )) by AMI_2:20;
thus L12: ( (the carrier of ( SCM C5 )) \ { ( NAT ) } ) = ( ( SCM-Memory ) \ { ( NAT ) } ) by L1
.= ( ( { ( NAT ) } \/ ( SCM-Data-Loc ) ) \ { ( NAT ) } )
.= ( SCM-Data-Loc ) by L11 , ZFMISC_1:117;
end;
registration
let C6 being Ring;
cluster  Int-like for (Object of ( SCM C6 ));
existence
proof
L13: (the carrier of ( SCM C6 )) = ( SCM-Memory ) by L1;
reconsider D1 = the (Element of ( SCM-Data-Loc )) as (Object of ( SCM C6 )) by L13;
take D1;
thus L14: thesis by AMI_2:def 16;
end;
end;
definition
let C7 being Ring;
mode Data-Location of C7
 is  Int-like (Object of ( SCM C7 ));
canceled 1;
end;
theorem
L17: (for R4 being set holds (for R8 being Ring holds (R4 is (Data-Location of R8) iff R4 in ( Data-Locations ( SCM ) )))) by L1 , AMI_2:def 16 , AMI_3:27;
definition
let C8 being Ring;
let C9 being (State of ( SCM C8 ));
let C10 being (Data-Location of C8);
redefine func C9 . C10 -> (Element of C8);

coherence
proof
L18: ( the_Values_of ( SCM C8 ) ) = ( ( SCM-VAL C8 ) * ( SCM-OK ) ) by L5;
reconsider D2 = C9 as (SCM-State of C8) by L18 , CARD_3:107;
L19: C10 is (Element of ( Data-Locations ( SCM ) )) by L17;
reconsider D3 = C10 as (Element of ( SCM-Data-Loc )) by L19 , AMI_3:27;
L20: ( D2 . D3 ) in (the carrier of C8);
thus L21: thesis by L20;
end;
end;
theorem
L23: (for R8 being Ring holds [ ( 0 ) , ( {} ) , ( {} ) ] is (Instruction of ( SCM R8 )))
proof
let R8 being Ring;
L24: ( halt ( SCM R8 ) ) = [ ( 0 ) , ( {} ) , ( {} ) ];
thus L25: thesis by L24;
end;
theorem
L26: (for R2 being non  empty 1-sorted holds (for R4 being set holds (for R8 being Ring holds (for R13 being (Data-Location of R8) holds (for R14 being (Data-Location of R8) holds (R4 in { 1 , 2 , 3 , 4 } implies [ R4 , ( {} ) , <* R13 , R14 *> ] in ( SCM-Instr R2 )))))))
proof
let R2 being non  empty 1-sorted;
let R4 being set;
let R8 being Ring;
let R13 being (Data-Location of R8);
let R14 being (Data-Location of R8);
reconsider D4 = R13 , D5 = R14 as (Element of ( SCM-Data-Loc )) by L17 , AMI_3:27;
L27: (R4 in { 1 , 2 , 3 , 4 } implies [ R4 , ( {} ) , <* D4 , D5 *> ] in ( SCM-Instr R2 )) by SCMRINGI:8;
thus L28: thesis by L27;
end;
theorem
L29: (for R2 being non  empty 1-sorted holds (for R3 being (Element of R2) holds (for R8 being Ring holds (for R13 being (Data-Location of R8) holds [ 5 , ( {} ) , <* R13 , R3 *> ] in ( SCM-Instr R2 )))))
proof
let R2 being non  empty 1-sorted;
let R3 being (Element of R2);
let R8 being Ring;
let R13 being (Data-Location of R8);
reconsider D6 = R13 as (Element of ( SCM-Data-Loc )) by L17 , AMI_3:27;
L30: [ 5 , ( {} ) , <* D6 , R3 *> ] in ( SCM-Instr R2 ) by SCMRINGI:9;
thus L31: thesis by L30;
end;
theorem
L32: (for R2 being non  empty 1-sorted holds (for R15 being (Element of ( NAT )) holds [ 6 , <* R15 *> , ( {} ) ] in ( SCM-Instr R2 ))) by SCMRINGI:10;
theorem
L33: (for R2 being non  empty 1-sorted holds (for R8 being Ring holds (for R13 being (Data-Location of R8) holds (for R15 being (Element of ( NAT )) holds [ 7 , <* R15 *> , <* R13 *> ] in ( SCM-Instr R2 )))))
proof
let R2 being non  empty 1-sorted;
let R8 being Ring;
let R13 being (Data-Location of R8);
let R15 being (Element of ( NAT ));
reconsider D7 = R13 as (Element of ( SCM-Data-Loc )) by L17 , AMI_3:27;
L34: [ 7 , <* R15 *> , <* D7 *> ] in ( SCM-Instr R2 ) by SCMRINGI:11;
thus L35: thesis by L34;
end;
definition
let C11 being Ring;
let C12 , C13 being (Data-Location of C11);
func C12 := C13 -> (Instruction of ( SCM C11 )) equals 
[ 1 , ( {} ) , <* C12 , C13 *> ];
coherence
proof
L36: 1 in { 1 , 2 , 3 , 4 } by ENUMSET1:def 2;
L37: [ 1 , ( {} ) , <* C12 , C13 *> ] in ( SCM-Instr C11 ) by L36 , L26;
thus L38: thesis by L37 , L1;
end;
func AddTo (C12 , C13) -> (Instruction of ( SCM C11 )) equals 
[ 2 , ( {} ) , <* C12 , C13 *> ];
coherence
proof
L39: 2 in { 1 , 2 , 3 , 4 } by ENUMSET1:def 2;
L40: [ 2 , ( {} ) , <* C12 , C13 *> ] in ( SCM-Instr C11 ) by L39 , L26;
thus L41: thesis by L40 , L1;
end;
func SubFrom (C12 , C13) -> (Instruction of ( SCM C11 )) equals 
[ 3 , ( {} ) , <* C12 , C13 *> ];
coherence
proof
L42: 3 in { 1 , 2 , 3 , 4 } by ENUMSET1:def 2;
L43: [ 3 , ( {} ) , <* C12 , C13 *> ] in ( SCM-Instr C11 ) by L42 , L26;
thus L44: thesis by L43 , L1;
end;
func MultBy (C12 , C13) -> (Instruction of ( SCM C11 )) equals 
[ 4 , ( {} ) , <* C12 , C13 *> ];
coherence
proof
L45: 4 in { 1 , 2 , 3 , 4 } by ENUMSET1:def 2;
L46: [ 4 , ( {} ) , <* C12 , C13 *> ] in ( SCM-Instr C11 ) by L45 , L26;
thus L47: thesis by L46 , L1;
end;
end;
definition
let C14 being Ring;
let C15 being (Data-Location of C14);
let C16 being (Element of C14);
func C15 := C16 -> (Instruction of ( SCM C14 )) equals 
[ 5 , ( {} ) , <* C15 , C16 *> ];
coherence
proof
L49: [ 5 , ( {} ) , <* C15 , C16 *> ] in ( SCM-Instr C14 ) by L29;
thus L50: thesis by L49 , L1;
end;
end;
definition
let C17 being Ring;
let C18 being (Element of ( NAT ));
func goto (C18 , C17) -> (Instruction of ( SCM C17 )) equals 
[ 6 , <* C18 *> , ( {} ) ];
coherence
proof
L52: [ 6 , <* C18 *> , ( {} ) ] in ( SCM-Instr C17 ) by L32;
thus L53: thesis by L52 , L1;
end;
end;
definition
let C19 being Ring;
let C20 being (Element of ( NAT ));
let C21 being (Data-Location of C19);
func C21 =0_goto C20 -> (Instruction of ( SCM C19 )) equals 
[ 7 , <* C20 *> , <* C21 *> ];
coherence
proof
L55: [ 7 , <* C20 *> , <* C21 *> ] in ( SCM-Instr C19 ) by L33;
thus L56: thesis by L55 , L1;
end;
end;
theorem
L58: (for R8 being Ring holds (for B2 being set holds (B2 is (Instruction of ( SCM R8 )) iff (B2 = [ ( 0 ) , ( {} ) , ( {} ) ] or (ex R10 being (Data-Location of R8) st (ex R11 being (Data-Location of R8) st B2 = ( R10 := R11 ))) or (ex R10 being (Data-Location of R8) st (ex R11 being (Data-Location of R8) st B2 = ( AddTo (R10 , R11) ))) or (ex R10 being (Data-Location of R8) st (ex R11 being (Data-Location of R8) st B2 = ( SubFrom (R10 , R11) ))) or (ex R10 being (Data-Location of R8) st (ex R11 being (Data-Location of R8) st B2 = ( MultBy (R10 , R11) ))) or (ex R15 being (Element of ( NAT )) st B2 = ( goto (R15 , R8) )) or (ex R10 being (Data-Location of R8) st (ex R15 being (Element of ( NAT )) st B2 = ( R10 =0_goto R15 ))) or (ex R10 being (Data-Location of R8) st (ex R9 being (Element of R8) st B2 = ( R10 := R9 )))))))
proof
let R8 being Ring;
let C22 being set;
L59: (the InstructionsF of ( SCM R8 )) = ( SCM-Instr R8 ) by L1;
thus L60: (C22 is (Instruction of ( SCM R8 )) implies (C22 = [ ( 0 ) , ( {} ) , ( {} ) ] or (ex R10 being (Data-Location of R8) st (ex R11 being (Data-Location of R8) st C22 = ( R10 := R11 ))) or (ex R10 being (Data-Location of R8) st (ex R11 being (Data-Location of R8) st C22 = ( AddTo (R10 , R11) ))) or (ex R10 being (Data-Location of R8) st (ex R11 being (Data-Location of R8) st C22 = ( SubFrom (R10 , R11) ))) or (ex R10 being (Data-Location of R8) st (ex R11 being (Data-Location of R8) st C22 = ( MultBy (R10 , R11) ))) or (ex R15 being (Element of ( NAT )) st C22 = ( goto (R15 , R8) )) or (ex R10 being (Data-Location of R8) st (ex R15 being (Element of ( NAT )) st C22 = ( R10 =0_goto R15 ))) or (ex R10 being (Data-Location of R8) st (ex R9 being (Element of R8) st C22 = ( R10 := R9 )))))
proof
assume L61: C22 is (Instruction of ( SCM R8 ));
L62: (C22 in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B3 , ( {} ) , <* B4 , B5 *> ] where B3 is (Element of ( Segm 8 )) , B4 , B5 is (Element of ( Data-Locations ( SCM ) )) : B3 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B6 *> , ( {} ) ] where B6 is (Element of ( NAT )) : (not contradiction) } ) \/ { [ 7 , <* B7 *> , <* B8 *> ] where B7 is (Element of ( NAT )) , B8 is (Element of ( Data-Locations ( SCM ) )) : (not contradiction) } ) or C22 in { [ 5 , ( {} ) , <* B9 , B10 *> ] where B9 is (Element of ( Data-Locations ( SCM ) )) , B10 is (Element of R8) : (not contradiction) }) by L61 , L59 , AMI_3:27 , XBOOLE_0:def 3;
L63: (C22 in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B11 , ( {} ) , <* B12 , B13 *> ] where B11 is (Element of ( Segm 8 )) , B12 , B13 is (Element of ( Data-Locations ( SCM ) )) : B11 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B14 *> , ( {} ) ] where B14 is (Element of ( NAT )) : (not contradiction) } ) or C22 in { [ 7 , <* B15 *> , <* B16 *> ] where B15 is (Element of ( NAT )) , B16 is (Element of ( Data-Locations ( SCM ) )) : (not contradiction) } or C22 in { [ 5 , ( {} ) , <* B17 , B18 *> ] where B17 is (Element of ( Data-Locations ( SCM ) )) , B18 is (Element of R8) : (not contradiction) }) by L62 , XBOOLE_0:def 3;
L64: (C22 in ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B19 , ( {} ) , <* B20 , B21 *> ] where B19 is (Element of ( Segm 8 )) , B20 , B21 is (Element of ( Data-Locations ( SCM ) )) : B19 in { 1 , 2 , 3 , 4 } } ) or C22 in { [ 6 , <* B22 *> , ( {} ) ] where B22 is (Element of ( NAT )) : (not contradiction) } or C22 in { [ 7 , <* B23 *> , <* B24 *> ] where B23 is (Element of ( NAT )) , B24 is (Element of ( Data-Locations ( SCM ) )) : (not contradiction) } or C22 in { [ 5 , ( {} ) , <* B25 , B26 *> ] where B25 is (Element of ( Data-Locations ( SCM ) )) , B26 is (Element of R8) : (not contradiction) }) by L63 , XBOOLE_0:def 3;
per cases  by L64 , XBOOLE_0:def 3;
suppose L65: C22 in { [ ( 0 ) , ( {} ) , ( {} ) ] };

thus L66: thesis by L65 , TARSKI:def 1;
end;
suppose L67: C22 in { [ 6 , <* B27 *> , ( {} ) ] where B27 is (Element of ( NAT )) : (not contradiction) };

consider C23 being (Element of ( NAT )) such that L68: C22 = [ 6 , <* C23 *> , ( {} ) ] and L69: (not contradiction) by L67;
reconsider D8 = C23 as (Element of ( NAT ));
L70: C22 = ( goto (D8 , R8) ) by L68;
thus L71: thesis by L70;
end;
suppose L72: C22 in { [ 7 , <* B28 *> , <* B29 *> ] where B28 is (Element of ( NAT )) , B29 is (Element of ( Data-Locations ( SCM ) )) : (not contradiction) };

consider C24 being (Element of ( NAT )), C25 being (Element of ( Data-Locations ( SCM ) )) such that L73: C22 = [ 7 , <* C24 *> , <* C25 *> ] and L74: (not contradiction) by L72;
reconsider D9 = C25 as (Data-Location of R8) by L17 , AMI_3:27;
reconsider D10 = C24 as (Element of ( NAT ));
L75: C22 = ( D9 =0_goto D10 ) by L73;
thus L76: thesis by L75;
end;
suppose L77: C22 in { [ 5 , ( {} ) , <* B30 , B31 *> ] where B30 is (Element of ( Data-Locations ( SCM ) )) , B31 is (Element of R8) : (not contradiction) };

consider C26 being (Element of ( Data-Locations ( SCM ) )), C27 being (Element of R8) such that L78: C22 = [ 5 , ( {} ) , <* C26 , C27 *> ] and L79: (not contradiction) by L77;
reconsider D11 = C26 as (Data-Location of R8) by L17 , AMI_3:27;
L80: C22 = ( D11 := C27 ) by L78;
thus L81: thesis by L80;
end;
suppose L82: C22 in { [ B32 , ( {} ) , <* B33 , B34 *> ] where B32 is (Element of ( Segm 8 )) , B33 , B34 is (Element of ( Data-Locations ( SCM ) )) : B32 in { 1 , 2 , 3 , 4 } };

consider C28 being (Element of ( Segm 8 )), C29 , C30 being (Element of ( Data-Locations ( SCM ) )) such that L83: (C22 = [ C28 , ( {} ) , <* C29 , C30 *> ] & C28 in { 1 , 2 , 3 , 4 }) by L82;
reconsider D12 = C29 , D13 = C30 as (Data-Location of R8) by L17 , AMI_3:27;
L84: (C22 = ( D12 := D13 ) or C22 = ( AddTo (D12 , D13) ) or C22 = ( SubFrom (D12 , D13) ) or C22 = ( MultBy (D12 , D13) )) by L83 , ENUMSET1:def 2;
thus L85: thesis by L84;
end;
end;

thus L87: thesis by L59 , SCMRINGI:6;
end;
registration
let C31 being non  empty Ring;
cluster ( SCM C31 ) ->  IC-Ins-separated;
coherence
proof
L88: ( the_Values_of ( SCM C31 ) ) = ( ( SCM-VAL C31 ) * ( SCM-OK ) ) by L5;
L89: ( IC ( SCM C31 ) ) = ( NAT ) by L1;
L90: ( Values ( IC ( SCM C31 ) ) ) = ( NAT ) by L89 , L88 , SCMRING1:2;
thus L91: ( SCM C31 ) is  IC-Ins-separated by L90 , MEMSTR_0:def 6;
end;
end;
theorem
L93: (for R8 being Ring holds ( IC ( SCM R8 ) ) = ( NAT )) by L1;
theorem
L94: (for R8 being Ring holds (for R16 being (State of ( SCM R8 )) holds (for B35 being (SCM-State of R8) holds (B35 = R16 implies ( IC R16 ) = ( IC B35 ))))) by L1;
theorem
L95: (for R8 being Ring holds (for R16 being (State of ( SCM R8 )) holds (for B36 being (Instruction of ( SCM R8 )) holds (for B37 being (Element of ( SCM-Instr R8 )) holds (B37 = B36 implies (for B38 being (SCM-State of R8) holds (B38 = R16 implies ( Exec (B36 , R16) ) = ( SCM-Exec-Res (B37 , B38) ))))))))
proof
let R8 being Ring;
let R16 being (State of ( SCM R8 ));
let C32 being (Instruction of ( SCM R8 ));
let C33 being (Element of ( SCM-Instr R8 ));
assume that
L96: C33 = C32;
let C34 being (SCM-State of R8);
assume L97: C34 = R16;
thus L98: ( Exec (C32 , R16) ) = ( (( ( SCM-Exec R8 ) . C33 ) qua (Element of ( Funcs (( product ( ( SCM-VAL R8 ) * ( SCM-OK ) ) ) , ( product ( ( SCM-VAL R8 ) * ( SCM-OK ) ) )) ))) . C34 ) by L97 , L96 , L1
.= ( SCM-Exec-Res (C33 , C34) ) by SCMRING1:def 15;
end;
begin
theorem
L99: (for R8 being Ring holds (for R10 being (Data-Location of R8) holds (for R11 being (Data-Location of R8) holds (for R16 being (State of ( SCM R8 )) holds (( ( Exec (( R10 := R11 ) , R16) ) . ( IC ( SCM R8 ) ) ) = ( succ ( IC R16 ) ) & ( ( Exec (( R10 := R11 ) , R16) ) . R10 ) = ( R16 . R11 ) & (for R12 being (Data-Location of R8) holds (R12 <> R10 implies ( ( Exec (( R10 := R11 ) , R16) ) . R12 ) = ( R16 . R12 ))))))))
proof
let R8 being Ring;
let R10 being (Data-Location of R8);
let R11 being (Data-Location of R8);
let R16 being (State of ( SCM R8 ));
L100: R10 is (Element of ( Data-Locations ( SCM ) )) by L17;
L101: ( the_Values_of ( SCM R8 ) ) = ( ( SCM-VAL R8 ) * ( SCM-OK ) ) by L5;
reconsider D14 = R16 as (SCM-State of R8) by L101 , CARD_3:107;
reconsider D15 = ( R10 := R11 ) as (Element of ( SCM-Instr R8 )) by L1;
set D16 = ( SCM-Chg (D14 , ( D15 address_1 ) , ( D14 . ( D15 address_2 ) )) );
reconsider D17 = 1 as (Element of ( Segm 8 )) by NAT_1:44;
L102: ( IC R16 ) = ( IC D14 ) by L1;
L103: R11 is (Element of ( Data-Locations ( SCM ) )) by L17;
L104: ( Exec (( R10 := R11 ) , R16) ) = ( SCM-Exec-Res (D15 , D14) ) by L95
.= ( SCM-Chg (D16 , ( succ ( IC D14 ) )) ) by L100 , L103 , AMI_3:27 , SCMRING1:def 14;
L105: D15 = [ D17 , ( {} ) , <* R10 , R11 *> ];
L106: ( D15 address_1 ) = R10 by L105 , L100 , L103 , AMI_3:27 , SCMRINGI:1;
L107: ( D15 address_2 ) = R11 by L105 , L100 , L103 , AMI_3:27 , SCMRINGI:1;
thus L108: ( ( Exec (( R10 := R11 ) , R16) ) . ( IC ( SCM R8 ) ) ) = ( ( Exec (( R10 := R11 ) , R16) ) . ( NAT ) ) by L1
.= ( succ ( IC R16 ) ) by L102 , L104 , SCMRING1:7;
thus L109: ( ( Exec (( R10 := R11 ) , R16) ) . R10 ) = ( D16 . R10 ) by L100 , L104 , AMI_3:27 , SCMRING1:8
.= ( R16 . R11 ) by L106 , L107 , SCMRING1:11;
let R12 being (Data-Location of R8);
assume L110: R12 <> R10;
L111: R12 is (Element of ( Data-Locations ( SCM ) )) by L17;
thus L112: ( ( Exec (( R10 := R11 ) , R16) ) . R12 ) = ( D16 . R12 ) by L111 , L104 , AMI_3:27 , SCMRING1:8
.= ( R16 . R12 ) by L106 , L110 , L111 , AMI_3:27 , SCMRING1:12;
end;
theorem
L113: (for R8 being Ring holds (for R10 being (Data-Location of R8) holds (for R11 being (Data-Location of R8) holds (for R16 being (State of ( SCM R8 )) holds (( ( Exec (( AddTo (R10 , R11) ) , R16) ) . ( IC ( SCM R8 ) ) ) = ( succ ( IC R16 ) ) & ( ( Exec (( AddTo (R10 , R11) ) , R16) ) . R10 ) = ( ( R16 . R10 ) + ( R16 . R11 ) ) & (for R12 being (Data-Location of R8) holds (R12 <> R10 implies ( ( Exec (( AddTo (R10 , R11) ) , R16) ) . R12 ) = ( R16 . R12 ))))))))
proof
let R8 being Ring;
let R10 being (Data-Location of R8);
let R11 being (Data-Location of R8);
let R16 being (State of ( SCM R8 ));
L114: R10 is (Element of ( Data-Locations ( SCM ) )) by L17;
L115: ( the_Values_of ( SCM R8 ) ) = ( ( SCM-VAL R8 ) * ( SCM-OK ) ) by L5;
reconsider D18 = R16 as (SCM-State of R8) by L115 , CARD_3:107;
reconsider D19 = ( AddTo (R10 , R11) ) as (Element of ( SCM-Instr R8 )) by L1;
set D20 = ( SCM-Chg (D18 , ( D19 address_1 ) , ( ( D18 . ( D19 address_1 ) ) + ( D18 . ( D19 address_2 ) ) )) );
reconsider D21 = 2 as (Element of ( Segm 8 )) by NAT_1:44;
L116: ( IC R16 ) = ( IC D18 ) by L1;
L117: R11 is (Element of ( Data-Locations ( SCM ) )) by L17;
L118: ( Exec (( AddTo (R10 , R11) ) , R16) ) = ( SCM-Exec-Res (D19 , D18) ) by L95
.= ( SCM-Chg (D20 , ( succ ( IC D18 ) )) ) by L114 , L117 , AMI_3:27 , SCMRING1:def 14;
L119: D19 = [ D21 , ( {} ) , <* R10 , R11 *> ];
L120: ( D19 address_1 ) = R10 by L119 , L114 , L117 , AMI_3:27 , SCMRINGI:1;
L121: ( D19 address_2 ) = R11 by L119 , L114 , L117 , AMI_3:27 , SCMRINGI:1;
thus L122: ( ( Exec (( AddTo (R10 , R11) ) , R16) ) . ( IC ( SCM R8 ) ) ) = ( ( Exec (( AddTo (R10 , R11) ) , R16) ) . ( NAT ) ) by L1
.= ( succ ( IC R16 ) ) by L116 , L118 , SCMRING1:7;
thus L123: ( ( Exec (( AddTo (R10 , R11) ) , R16) ) . R10 ) = ( D20 . R10 ) by L114 , L118 , AMI_3:27 , SCMRING1:8
.= ( ( R16 . R10 ) + ( R16 . R11 ) ) by L120 , L121 , SCMRING1:11;
let R12 being (Data-Location of R8);
assume L124: R12 <> R10;
L125: R12 is (Element of ( Data-Locations ( SCM ) )) by L17;
thus L126: ( ( Exec (( AddTo (R10 , R11) ) , R16) ) . R12 ) = ( D20 . R12 ) by L125 , L118 , AMI_3:27 , SCMRING1:8
.= ( R16 . R12 ) by L120 , L124 , L125 , AMI_3:27 , SCMRING1:12;
end;
theorem
L127: (for R8 being Ring holds (for R10 being (Data-Location of R8) holds (for R11 being (Data-Location of R8) holds (for R16 being (State of ( SCM R8 )) holds (( ( Exec (( SubFrom (R10 , R11) ) , R16) ) . ( IC ( SCM R8 ) ) ) = ( succ ( IC R16 ) ) & ( ( Exec (( SubFrom (R10 , R11) ) , R16) ) . R10 ) = ( ( R16 . R10 ) - ( R16 . R11 ) ) & (for R12 being (Data-Location of R8) holds (R12 <> R10 implies ( ( Exec (( SubFrom (R10 , R11) ) , R16) ) . R12 ) = ( R16 . R12 ))))))))
proof
let R8 being Ring;
let R10 being (Data-Location of R8);
let R11 being (Data-Location of R8);
let R16 being (State of ( SCM R8 ));
L128: R10 is (Element of ( Data-Locations ( SCM ) )) by L17;
L129: ( the_Values_of ( SCM R8 ) ) = ( ( SCM-VAL R8 ) * ( SCM-OK ) ) by L5;
reconsider D22 = R16 as (SCM-State of R8) by L129 , CARD_3:107;
reconsider D23 = ( SubFrom (R10 , R11) ) as (Element of ( SCM-Instr R8 )) by L1;
set D24 = ( SCM-Chg (D22 , ( D23 address_1 ) , ( ( D22 . ( D23 address_1 ) ) - ( D22 . ( D23 address_2 ) ) )) );
reconsider D25 = 3 as (Element of ( Segm 8 )) by NAT_1:44;
L130: ( IC R16 ) = ( IC D22 ) by L1;
L131: R11 is (Element of ( Data-Locations ( SCM ) )) by L17;
L132: ( Exec (( SubFrom (R10 , R11) ) , R16) ) = ( SCM-Exec-Res (D23 , D22) ) by L95
.= ( SCM-Chg (D24 , ( succ ( IC D22 ) )) ) by L128 , L131 , AMI_3:27 , SCMRING1:def 14;
L133: D23 = [ D25 , ( {} ) , <* R10 , R11 *> ];
L134: ( D23 address_1 ) = R10 by L133 , L128 , L131 , AMI_3:27 , SCMRINGI:1;
L135: ( D23 address_2 ) = R11 by L133 , L128 , L131 , AMI_3:27 , SCMRINGI:1;
thus L136: ( ( Exec (( SubFrom (R10 , R11) ) , R16) ) . ( IC ( SCM R8 ) ) ) = ( ( Exec (( SubFrom (R10 , R11) ) , R16) ) . ( NAT ) ) by L1
.= ( succ ( IC R16 ) ) by L130 , L132 , SCMRING1:7;
thus L137: ( ( Exec (( SubFrom (R10 , R11) ) , R16) ) . R10 ) = ( D24 . R10 ) by L128 , L132 , AMI_3:27 , SCMRING1:8
.= ( ( R16 . R10 ) - ( R16 . R11 ) ) by L134 , L135 , SCMRING1:11;
let R12 being (Data-Location of R8);
assume L138: R12 <> R10;
L139: R12 is (Element of ( Data-Locations ( SCM ) )) by L17;
thus L140: ( ( Exec (( SubFrom (R10 , R11) ) , R16) ) . R12 ) = ( D24 . R12 ) by L139 , L132 , AMI_3:27 , SCMRING1:8
.= ( R16 . R12 ) by L134 , L138 , L139 , AMI_3:27 , SCMRING1:12;
end;
theorem
L141: (for R8 being Ring holds (for R10 being (Data-Location of R8) holds (for R11 being (Data-Location of R8) holds (for R16 being (State of ( SCM R8 )) holds (( ( Exec (( MultBy (R10 , R11) ) , R16) ) . ( IC ( SCM R8 ) ) ) = ( succ ( IC R16 ) ) & ( ( Exec (( MultBy (R10 , R11) ) , R16) ) . R10 ) = ( ( R16 . R10 ) * ( R16 . R11 ) ) & (for R12 being (Data-Location of R8) holds (R12 <> R10 implies ( ( Exec (( MultBy (R10 , R11) ) , R16) ) . R12 ) = ( R16 . R12 ))))))))
proof
let R8 being Ring;
let R10 being (Data-Location of R8);
let R11 being (Data-Location of R8);
let R16 being (State of ( SCM R8 ));
L142: R10 is (Element of ( Data-Locations ( SCM ) )) by L17;
L143: ( the_Values_of ( SCM R8 ) ) = ( ( SCM-VAL R8 ) * ( SCM-OK ) ) by L5;
reconsider D26 = R16 as (SCM-State of R8) by L143 , CARD_3:107;
reconsider D27 = ( MultBy (R10 , R11) ) as (Element of ( SCM-Instr R8 )) by L1;
set D28 = ( SCM-Chg (D26 , ( D27 address_1 ) , ( ( D26 . ( D27 address_1 ) ) * ( D26 . ( D27 address_2 ) ) )) );
reconsider D29 = 4 as (Element of ( Segm 8 )) by NAT_1:44;
L144: ( IC R16 ) = ( IC D26 ) by L1;
L145: R11 is (Element of ( Data-Locations ( SCM ) )) by L17;
L146: ( Exec (( MultBy (R10 , R11) ) , R16) ) = ( SCM-Exec-Res (D27 , D26) ) by L95
.= ( SCM-Chg (D28 , ( succ ( IC D26 ) )) ) by L142 , L145 , AMI_3:27 , SCMRING1:def 14;
L147: D27 = [ D29 , ( {} ) , <* R10 , R11 *> ];
L148: ( D27 address_1 ) = R10 by L147 , L142 , L145 , AMI_3:27 , SCMRINGI:1;
L149: ( D27 address_2 ) = R11 by L147 , L142 , L145 , AMI_3:27 , SCMRINGI:1;
thus L150: ( ( Exec (( MultBy (R10 , R11) ) , R16) ) . ( IC ( SCM R8 ) ) ) = ( ( Exec (( MultBy (R10 , R11) ) , R16) ) . ( NAT ) ) by L1
.= ( succ ( IC R16 ) ) by L144 , L146 , SCMRING1:7;
thus L151: ( ( Exec (( MultBy (R10 , R11) ) , R16) ) . R10 ) = ( D28 . R10 ) by L142 , L146 , AMI_3:27 , SCMRING1:8
.= ( ( R16 . R10 ) * ( R16 . R11 ) ) by L148 , L149 , SCMRING1:11;
let R12 being (Data-Location of R8);
assume L152: R12 <> R10;
L153: R12 is (Element of ( Data-Locations ( SCM ) )) by L17;
thus L154: ( ( Exec (( MultBy (R10 , R11) ) , R16) ) . R12 ) = ( D28 . R12 ) by L153 , L146 , AMI_3:27 , SCMRING1:8
.= ( R16 . R12 ) by L148 , L152 , L153 , AMI_3:27 , SCMRING1:12;
end;
theorem
L155: (for R8 being Ring holds (for R12 being (Data-Location of R8) holds (for R15 being (Element of ( NAT )) holds (for R16 being (State of ( SCM R8 )) holds (( ( Exec (( goto (R15 , R8) ) , R16) ) . ( IC ( SCM R8 ) ) ) = R15 & ( ( Exec (( goto (R15 , R8) ) , R16) ) . R12 ) = ( R16 . R12 ))))))
proof
let R8 being Ring;
let R12 being (Data-Location of R8);
let R15 being (Element of ( NAT ));
let R16 being (State of ( SCM R8 ));
L156: ( the_Values_of ( SCM R8 ) ) = ( ( SCM-VAL R8 ) * ( SCM-OK ) ) by L5;
reconsider D30 = R16 as (SCM-State of R8) by L156 , CARD_3:107;
reconsider D31 = 6 as (Element of ( Segm 8 )) by NAT_1:44;
reconsider D32 = ( goto (R15 , R8) ) as (Element of ( SCM-Instr R8 )) by L1;
L157: D32 = [ D31 , <* R15 *> , ( {} ) ];
L158: ( D32 jump_address ) = R15 by L157 , SCMRINGI:2;
L159: ( Exec (( goto (R15 , R8) ) , R16) ) = ( SCM-Exec-Res (D32 , D30) ) by L95
.= ( SCM-Chg (D30 , ( D32 jump_address )) ) by SCMRING1:def 14;
thus L160: ( ( Exec (( goto (R15 , R8) ) , R16) ) . ( IC ( SCM R8 ) ) ) = ( ( Exec (( goto (R15 , R8) ) , R16) ) . ( NAT ) ) by L1
.= R15 by L159 , L158 , SCMRING1:7;
L161: R12 is (Element of ( Data-Locations ( SCM ) )) by L17;
thus L162: thesis by L161 , L159 , AMI_3:27 , SCMRING1:8;
end;
theorem
L163: (for R8 being Ring holds (for R10 being (Data-Location of R8) holds (for R12 being (Data-Location of R8) holds (for R15 being (Element of ( NAT )) holds (for R16 being (State of ( SCM R8 )) holds ((( R16 . R10 ) = ( 0. R8 ) implies ( ( Exec (( R10 =0_goto R15 ) , R16) ) . ( IC ( SCM R8 ) ) ) = R15) & (( R16 . R10 ) <> ( 0. R8 ) implies ( ( Exec (( R10 =0_goto R15 ) , R16) ) . ( IC ( SCM R8 ) ) ) = ( succ ( IC R16 ) )) & ( ( Exec (( R10 =0_goto R15 ) , R16) ) . R12 ) = ( R16 . R12 )))))))
proof
let R8 being Ring;
let R10 being (Data-Location of R8);
let R12 being (Data-Location of R8);
let R15 being (Element of ( NAT ));
let R16 being (State of ( SCM R8 ));
L164: ( the_Values_of ( SCM R8 ) ) = ( ( SCM-VAL R8 ) * ( SCM-OK ) ) by L5;
reconsider D33 = R16 as (SCM-State of R8) by L164 , CARD_3:107;
reconsider D34 = ( R10 =0_goto R15 ) as (Element of ( SCM-Instr R8 )) by L1;
reconsider D35 = 7 as (Element of ( Segm 8 )) by NAT_1:44;
L165: (R10 is (Element of ( Data-Locations ( SCM ) )) & R15 is (Element of ( NAT ))) by L17;
L166: ( Exec (( R10 =0_goto R15 ) , R16) ) = ( SCM-Exec-Res (D34 , D33) ) by L95
.= ( SCM-Chg (D33 , ( IFEQ (( D33 . ( D34 cond_address ) ) , ( 0. R8 ) , ( D34 cjump_address ) , ( succ ( IC D33 ) )) )) ) by L165 , AMI_3:27 , SCMRING1:def 14;
L167: D34 = [ D35 , <* R15 *> , <* R10 *> ];
thus L168: (( R16 . R10 ) = ( 0. R8 ) implies ( ( Exec (( R10 =0_goto R15 ) , R16) ) . ( IC ( SCM R8 ) ) ) = R15)
proof
assume L169: ( R16 . R10 ) = ( 0. R8 );
L170: ( D33 . ( D34 cond_address ) ) = ( 0. R8 ) by L169 , L167 , L165 , AMI_3:27 , SCMRINGI:3;
thus L171: ( ( Exec (( R10 =0_goto R15 ) , R16) ) . ( IC ( SCM R8 ) ) ) = ( ( Exec (( R10 =0_goto R15 ) , R16) ) . ( NAT ) ) by L1
.= ( IFEQ (( D33 . ( D34 cond_address ) ) , ( 0. R8 ) , ( D34 cjump_address ) , ( succ ( IC D33 ) )) ) by L166 , SCMRING1:7
.= ( D34 cjump_address ) by L170 , FUNCOP_1:def 8
.= R15 by L167 , L165 , AMI_3:27 , SCMRINGI:3;
end;

L172: ( IC R16 ) = ( IC D33 ) by L1;
thus L173: (( R16 . R10 ) <> ( 0. R8 ) implies ( ( Exec (( R10 =0_goto R15 ) , R16) ) . ( IC ( SCM R8 ) ) ) = ( succ ( IC R16 ) ))
proof
assume L174: ( R16 . R10 ) <> ( 0. R8 );
L175: ( D33 . ( D34 cond_address ) ) <> ( 0. R8 ) by L174 , L167 , L165 , AMI_3:27 , SCMRINGI:3;
thus L176: ( ( Exec (( R10 =0_goto R15 ) , R16) ) . ( IC ( SCM R8 ) ) ) = ( ( Exec (( R10 =0_goto R15 ) , R16) ) . ( NAT ) ) by L1
.= ( IFEQ (( D33 . ( D34 cond_address ) ) , ( 0. R8 ) , ( D34 cjump_address ) , ( succ ( IC D33 ) )) ) by L166 , SCMRING1:7
.= ( succ ( IC R16 ) ) by L172 , L175 , FUNCOP_1:def 8;
end;

L177: R12 is (Element of ( Data-Locations ( SCM ) )) by L17;
thus L178: thesis by L177 , L166 , AMI_3:27 , SCMRING1:8;
end;
theorem
L179: (for R8 being Ring holds (for R9 being (Element of R8) holds (for R10 being (Data-Location of R8) holds (for R16 being (State of ( SCM R8 )) holds (( ( Exec (( R10 := R9 ) , R16) ) . ( IC ( SCM R8 ) ) ) = ( succ ( IC R16 ) ) & ( ( Exec (( R10 := R9 ) , R16) ) . R10 ) = R9 & (for R12 being (Data-Location of R8) holds (R12 <> R10 implies ( ( Exec (( R10 := R9 ) , R16) ) . R12 ) = ( R16 . R12 ))))))))
proof
let R8 being Ring;
let R9 being (Element of R8);
let R10 being (Data-Location of R8);
let R16 being (State of ( SCM R8 ));
L180: R10 is (Element of ( Data-Locations ( SCM ) )) by L17;
L181: ( the_Values_of ( SCM R8 ) ) = ( ( SCM-VAL R8 ) * ( SCM-OK ) ) by L5;
reconsider D36 = R16 as (SCM-State of R8) by L181 , CARD_3:107;
reconsider D37 = ( R10 := R9 ) as (Element of ( SCM-Instr R8 )) by L1;
set D38 = ( SCM-Chg (D36 , ( D37 const_address ) , ( D37 const_value )) );
reconsider D39 = 5 as (Element of ( Segm 8 )) by NAT_1:44;
L182: ( IC R16 ) = ( IC D36 ) by L1;
L183: D37 = [ D39 , ( {} ) , <* R10 , R9 *> ];
L184: ( D37 const_address ) = R10 by L183 , L180 , AMI_3:27 , SCMRINGI:4;
L185: ( D37 const_value ) = R9 by L183 , L180 , AMI_3:27 , SCMRINGI:4;
L186: ( Exec (( R10 := R9 ) , R16) ) = ( SCM-Exec-Res (D37 , D36) ) by L95
.= ( SCM-Chg (D38 , ( succ ( IC D36 ) )) ) by L180 , AMI_3:27 , SCMRING1:def 14;
thus L187: ( ( Exec (( R10 := R9 ) , R16) ) . ( IC ( SCM R8 ) ) ) = ( ( Exec (( R10 := R9 ) , R16) ) . ( NAT ) ) by L1
.= ( succ ( IC R16 ) ) by L182 , L186 , SCMRING1:7;
thus L188: ( ( Exec (( R10 := R9 ) , R16) ) . R10 ) = ( D38 . R10 ) by L180 , L186 , AMI_3:27 , SCMRING1:8
.= R9 by L184 , L185 , SCMRING1:11;
let R12 being (Data-Location of R8);
assume L189: R12 <> R10;
L190: R12 is (Element of ( Data-Locations ( SCM ) )) by L17;
thus L191: ( ( Exec (( R10 := R9 ) , R16) ) . R12 ) = ( D38 . R12 ) by L190 , L186 , AMI_3:27 , SCMRING1:8
.= ( R16 . R12 ) by L184 , L189 , L190 , AMI_3:27 , SCMRING1:12;
end;
begin
theorem
L192: (for R8 being Ring holds (for B39 being (Instruction of ( SCM R8 )) holds ((ex R16 being (State of ( SCM R8 )) st ( ( Exec (B39 , R16) ) . ( IC ( SCM R8 ) ) ) = ( succ ( IC R16 ) )) implies B39 is non  halting)))
proof
let R8 being Ring;
let C35 being (Instruction of ( SCM R8 ));
given R16 being (State of ( SCM R8 )) such that
L193: ( ( Exec (C35 , R16) ) . ( IC ( SCM R8 ) ) ) = ( succ ( IC R16 ) );

L194: ( the_Values_of ( SCM R8 ) ) = ( ( SCM-VAL R8 ) * ( SCM-OK ) ) by L5;
reconsider D40 = R16 as (SCM-State of R8) by L194 , CARD_3:107;
L195: ( IC D40 ) = ( D40 . ( NAT ) );
reconsider D41 = ( D40 . ( NAT ) ) as (Element of ( NAT )) by L195;
L196: ( ( Exec (C35 , R16) ) . ( IC ( SCM R8 ) ) ) = ( succ D41 ) by L193 , L1;
assume L197: C35 is  halting;
L198: ( IC D40 ) = ( IC R16 ) by L1;
L199: ( ( Exec (C35 , R16) ) . ( IC ( SCM R8 ) ) ) = ( D40 . ( NAT ) ) by L198 , L197 , EXTPRO_1:def 3;
thus L200: contradiction by L199 , L196;
end;
theorem
L201: (for R8 being Ring holds (for B40 being (Instruction of ( SCM R8 )) holds (B40 = [ ( 0 ) , ( {} ) , ( {} ) ] implies B40 is  halting)))
proof
let R8 being Ring;
let C36 being (Instruction of ( SCM R8 ));
assume that
L202: C36 = [ ( 0 ) , ( {} ) , ( {} ) ];
L203: ( C36 `3_3 ) = ( {} ) by L202 , RECDEF_2:def 3;
L204: ((not (ex B41 , B42 being (Element of ( Data-Locations ( SCM ) )) st C36 = [ 1 , ( {} ) , <* B41 , B42 *> ])) & (not (ex B43 , B44 being (Element of ( Data-Locations ( SCM ) )) st C36 = [ 2 , ( {} ) , <* B43 , B44 *> ]))) by L203 , RECDEF_2:def 3;
L205: (not (ex B45 being (Element of ( Data-Locations ( SCM ) )) st (ex B46 being (Element of R8) st C36 = [ 5 , ( {} ) , <* B45 , B46 *> ]))) by L203 , RECDEF_2:def 3;
L206: ( C36 `2_3 ) = ( {} ) by L202 , RECDEF_2:def 2;
L207: ((not (ex B47 being (Element of ( NAT )) st C36 = [ 6 , <* B47 *> , ( {} ) ])) & (not (ex B48 being (Element of ( NAT )) st (ex B49 being (Element of ( Data-Locations ( SCM ) )) st C36 = [ 7 , <* B48 *> , <* B49 *> ])))) by L206 , RECDEF_2:def 2;
reconsider D42 = C36 as (Element of ( SCM-Instr R8 )) by L202 , SCMRINGI:6;
let C37 being (State of ( SCM R8 ));
L208: ( the_Values_of ( SCM R8 ) ) = ( ( SCM-VAL R8 ) * ( SCM-OK ) ) by L5;
reconsider D43 = C37 as (SCM-State of R8) by L208 , CARD_3:107;
L209: ((not (ex B50 , B51 being (Element of ( Data-Locations ( SCM ) )) st C36 = [ 3 , ( {} ) , <* B50 , B51 *> ])) & (not (ex B52 , B53 being (Element of ( Data-Locations ( SCM ) )) st C36 = [ 4 , ( {} ) , <* B52 , B53 *> ]))) by L203 , RECDEF_2:def 3;
thus L210: ( Exec (C36 , C37) ) = ( SCM-Exec-Res (D42 , D43) ) by L95
.= C37 by L204 , L209 , L207 , L205 , AMI_3:27 , SCMRING1:def 14;
end;
L211: (for R8 being Ring holds (for R10 being (Data-Location of R8) holds (for R11 being (Data-Location of R8) holds ( R10 := R11 ) is non  halting)))
proof
let R8 being Ring;
let R10 being (Data-Location of R8);
let R11 being (Data-Location of R8);
set D44 = the (State of ( SCM R8 ));
L212: ( ( Exec (( R10 := R11 ) , D44) ) . ( IC ( SCM R8 ) ) ) = ( succ ( IC D44 ) ) by L99;
thus L213: thesis by L212 , L192;
end;
L214: (for R8 being Ring holds (for R10 being (Data-Location of R8) holds (for R11 being (Data-Location of R8) holds ( AddTo (R10 , R11) ) is non  halting)))
proof
let R8 being Ring;
let R10 being (Data-Location of R8);
let R11 being (Data-Location of R8);
set D45 = the (State of ( SCM R8 ));
L215: ( ( Exec (( AddTo (R10 , R11) ) , D45) ) . ( IC ( SCM R8 ) ) ) = ( succ ( IC D45 ) ) by L113;
thus L216: thesis by L215 , L192;
end;
L217: (for R8 being Ring holds (for R10 being (Data-Location of R8) holds (for R11 being (Data-Location of R8) holds ( SubFrom (R10 , R11) ) is non  halting)))
proof
let R8 being Ring;
let R10 being (Data-Location of R8);
let R11 being (Data-Location of R8);
set D46 = the (State of ( SCM R8 ));
L218: ( ( Exec (( SubFrom (R10 , R11) ) , D46) ) . ( IC ( SCM R8 ) ) ) = ( succ ( IC D46 ) ) by L127;
thus L219: thesis by L218 , L192;
end;
L220: (for R8 being Ring holds (for R10 being (Data-Location of R8) holds (for R11 being (Data-Location of R8) holds ( MultBy (R10 , R11) ) is non  halting)))
proof
let R8 being Ring;
let R10 being (Data-Location of R8);
let R11 being (Data-Location of R8);
set D47 = the (State of ( SCM R8 ));
L221: ( ( Exec (( MultBy (R10 , R11) ) , D47) ) . ( IC ( SCM R8 ) ) ) = ( succ ( IC D47 ) ) by L141;
thus L222: thesis by L221 , L192;
end;
L223: (for R8 being Ring holds (for R15 being (Element of ( NAT )) holds ( goto (R15 , R8) ) is non  halting))
proof
let R8 being Ring;
let R15 being (Element of ( NAT ));
reconsider D48 = R15 as (Element of ( NAT ));
set D49 = the (SCM-State of R8);
set D50 = ( D49 +* ( ( NAT ) .--> ( succ R15 ) ) );
set D51 = ( the_Values_of ( SCM R8 ) );
L224: { ( NAT ) } c= ( SCM-Memory ) by AMI_2:22 , ZFMISC_1:31;
L225: ( dom D50 ) = ( ( dom D49 ) \/ ( dom ( ( NAT ) .--> ( succ R15 ) ) ) ) by FUNCT_4:def 1
.= ( ( SCM-Memory ) \/ ( dom ( ( NAT ) .--> ( succ R15 ) ) ) ) by SCMRING1:19
.= ( ( SCM-Memory ) \/ { ( NAT ) } ) by FUNCOP_1:13
.= ( SCM-Memory ) by L224 , XBOOLE_1:12;
L226: D51 = ( ( SCM-VAL R8 ) * ( SCM-OK ) ) by L5;
L227: ( dom ( ( NAT ) .--> ( succ R15 ) ) ) = { ( NAT ) } by FUNCOP_1:13;
L228: ( NAT ) in ( dom ( ( NAT ) .--> ( succ R15 ) ) ) by L227 , TARSKI:def 1;
L229: ( D50 . ( NAT ) ) = ( ( ( NAT ) .--> ( succ R15 ) ) . ( NAT ) ) by L228 , FUNCT_4:13
.= ( succ D48 ) by FUNCOP_1:72;
L230: ( dom D50 ) = (the carrier of ( SCM R8 )) by L225 , L1
.= ( dom D51 ) by PARTFUN1:def 2;
L231: (for B54 being set holds (B54 in ( dom D50 ) implies ( D50 . B54 ) in ( D51 . B54 )))
proof
let C38 being set;
assume that
L232: C38 in ( dom D50 );
per cases ;
suppose L233: C38 = ( NAT );

L234: ( D51 . C38 ) = ( NAT ) by L233 , L226 , SCMRING1:2;
thus L235: thesis by L234 , L229 , L233;
end;
suppose L236: C38 <> ( NAT );

L237: (not C38 in ( dom ( ( NAT ) .--> ( succ R15 ) ) )) by L236 , L227 , TARSKI:def 1;
L238: ( D50 . C38 ) = ( D49 . C38 ) by L237 , FUNCT_4:11;
thus L239: thesis by L238 , L226 , L232 , L230 , CARD_3:9;
end;
end;
L241: ( the_Values_of ( SCM R8 ) ) = ( ( SCM-VAL R8 ) * ( SCM-OK ) ) by L5;
L242: ( dom D50 ) = (the carrier of ( SCM R8 )) by L225 , L1;
reconsider D52 = D50 as (PartState of ( SCM R8 )) by L242 , L231 , FUNCT_1:def 14 , RELAT_1:def 18;
L243: ( dom D52 ) = (the carrier of ( SCM R8 )) by L225 , L1;
reconsider D53 = D52 as (State of ( SCM R8 )) by L243 , PARTFUN1:def 2;
reconsider D54 = D53 as (SCM-State of R8) by L241 , CARD_3:107;
L244: ( dom ( ( NAT ) .--> R15 ) ) = { ( NAT ) } by FUNCOP_1:13;
L245: ( NAT ) in ( dom ( ( NAT ) .--> R15 ) ) by L244 , TARSKI:def 1;
L246: ( ( D54 +* ( ( NAT ) .--> R15 ) ) . ( NAT ) ) = ( ( ( NAT ) .--> R15 ) . ( NAT ) ) by L245 , FUNCT_4:13
.= R15 by FUNCOP_1:72;
reconsider D55 = ( goto (R15 , R8) ) as (Element of ( SCM-Instr R8 )) by L1;
assume L247: ( goto (R15 , R8) ) is  halting;
L248: 6 is (Element of ( Segm 8 )) by NAT_1:44;
L249: ( D54 +* ( ( NAT ) .--> R15 ) ) = ( SCM-Chg (D54 , D48) )
.= ( SCM-Chg (D54 , ( D55 jump_address )) ) by L248 , SCMRINGI:2
.= ( SCM-Exec-Res (D55 , D54) ) by SCMRING1:def 14
.= ( Exec (( goto (R15 , R8) ) , D53) ) by L95
.= D53 by L247 , EXTPRO_1:def 3;
thus L250: contradiction by L249 , L229 , L246;
end;
L251: (for R8 being Ring holds (for R10 being (Data-Location of R8) holds (for R15 being (Element of ( NAT )) holds ( R10 =0_goto R15 ) is non  halting)))
proof
let R8 being Ring;
let R10 being (Data-Location of R8);
let R15 being (Element of ( NAT ));
reconsider D56 = R15 as (Element of ( NAT ));
set D57 = the (SCM-State of R8);
set D58 = ( D57 +* ( ( NAT ) .--> ( succ R15 ) ) );
set D59 = ( the_Values_of ( SCM R8 ) );
reconsider D60 = ( R10 =0_goto R15 ) as (Element of ( SCM-Instr R8 )) by L1;
L252: { ( NAT ) } c= ( SCM-Memory ) by AMI_2:22 , ZFMISC_1:31;
L253: ( dom D58 ) = ( ( dom D57 ) \/ ( dom ( ( NAT ) .--> ( succ R15 ) ) ) ) by FUNCT_4:def 1
.= ( ( SCM-Memory ) \/ ( dom ( ( NAT ) .--> ( succ R15 ) ) ) ) by SCMRING1:19
.= ( ( SCM-Memory ) \/ { ( NAT ) } ) by FUNCOP_1:13
.= ( SCM-Memory ) by L252 , XBOOLE_1:12;
L254: D59 = ( ( SCM-VAL R8 ) * ( SCM-OK ) ) by L5;
L255: ( dom ( ( NAT ) .--> ( succ R15 ) ) ) = { ( NAT ) } by FUNCOP_1:13;
L256: ( NAT ) in ( dom ( ( NAT ) .--> ( succ R15 ) ) ) by L255 , TARSKI:def 1;
L257: ( D58 . ( NAT ) ) = ( ( ( NAT ) .--> ( succ R15 ) ) . ( NAT ) ) by L256 , FUNCT_4:13
.= ( succ D56 ) by FUNCOP_1:72;
L258: ( dom D58 ) = (the carrier of ( SCM R8 )) by L253 , L1
.= ( dom D59 ) by PARTFUN1:def 2;
L259: (for B55 being set holds (B55 in ( dom D58 ) implies ( D58 . B55 ) in ( D59 . B55 )))
proof
let C39 being set;
assume that
L260: C39 in ( dom D58 );
per cases ;
suppose L261: C39 = ( NAT );

L262: ( D59 . C39 ) = ( NAT ) by L261 , L254 , SCMRING1:2;
thus L263: thesis by L262 , L257 , L261;
end;
suppose L264: C39 <> ( NAT );

L265: (not C39 in ( dom ( ( NAT ) .--> ( succ R15 ) ) )) by L264 , L255 , TARSKI:def 1;
L266: ( D58 . C39 ) = ( D57 . C39 ) by L265 , FUNCT_4:11;
thus L267: thesis by L266 , L254 , L260 , L258 , CARD_3:9;
end;
end;
L269: ( dom D58 ) = (the carrier of ( SCM R8 )) by L253 , L1;
reconsider D61 = D58 as (PartState of ( SCM R8 )) by L269 , L259 , FUNCT_1:def 14 , RELAT_1:def 18;
L270: ( dom D61 ) = (the carrier of ( SCM R8 )) by L253 , L1;
reconsider D62 = D61 as (State of ( SCM R8 )) by L270 , PARTFUN1:def 2;
L271: ( the_Values_of ( SCM R8 ) ) = ( ( SCM-VAL R8 ) * ( SCM-OK ) ) by L5;
reconsider D63 = D62 as (SCM-State of R8) by L271 , CARD_3:107;
L272: ( dom ( ( NAT ) .--> R15 ) ) = { ( NAT ) } by FUNCOP_1:13;
L273: ( NAT ) in ( dom ( ( NAT ) .--> R15 ) ) by L272 , TARSKI:def 1;
L274: ( ( D63 +* ( ( NAT ) .--> R15 ) ) . ( NAT ) ) = ( ( ( NAT ) .--> R15 ) . ( NAT ) ) by L273 , FUNCT_4:13
.= R15 by FUNCOP_1:72;
L275: 7 is (Element of ( Segm 8 )) by NAT_1:44;
L276: R10 is (Element of ( Data-Locations ( SCM ) )) by L17;
assume L277: ( R10 =0_goto R15 ) is  halting;
per cases ;
suppose L278: ( D63 . ( D60 cond_address ) ) <> ( 0. R8 );

L279: ( IC D63 ) = ( D63 . ( NAT ) );
reconsider D64 = ( D63 . ( NAT ) ) as (Element of ( NAT )) by L279;
L280: ( IC D62 ) = ( IC D63 ) by L1;
L281: ( ( Exec (( R10 =0_goto R15 ) , D62) ) . ( IC ( SCM R8 ) ) ) = ( D63 . ( NAT ) ) by L280 , L277 , EXTPRO_1:def 3;
L282: R10 is (Element of ( Data-Locations ( SCM ) )) by L17;
L283: ( D62 . R10 ) <> ( 0. R8 ) by L282 , L275 , L278 , AMI_3:27 , SCMRINGI:3;
L284: ( ( Exec (( R10 =0_goto R15 ) , D62) ) . ( IC ( SCM R8 ) ) ) = ( succ D64 ) by L283 , L280 , L163;
thus L285: contradiction by L284 , L281;
end;
suppose L286: ( D63 . ( D60 cond_address ) ) = ( 0. R8 );

L287: ( D63 +* ( ( NAT ) .--> R15 ) ) = ( SCM-Chg (D63 , D56) )
.= ( SCM-Chg (D63 , ( D60 cjump_address )) ) by L275 , L276 , AMI_3:27 , SCMRINGI:3
.= ( SCM-Chg (D63 , ( IFEQ (( D63 . ( D60 cond_address ) ) , ( 0. R8 ) , ( D60 cjump_address ) , ( succ ( IC D63 ) )) )) ) by L286 , FUNCOP_1:def 8
.= ( SCM-Exec-Res (D60 , D63) ) by L276 , AMI_3:27 , SCMRING1:def 14
.= ( Exec (( R10 =0_goto R15 ) , D62) ) by L95
.= D62 by L277 , EXTPRO_1:def 3;
thus L288: contradiction by L287 , L257 , L274;
end;
end;
L290: (for R8 being Ring holds (for R9 being (Element of R8) holds (for R10 being (Data-Location of R8) holds ( R10 := R9 ) is non  halting)))
proof
let R8 being Ring;
let R9 being (Element of R8);
let R10 being (Data-Location of R8);
set D65 = the (State of ( SCM R8 ));
L291: ( ( Exec (( R10 := R9 ) , D65) ) . ( IC ( SCM R8 ) ) ) = ( succ ( IC D65 ) ) by L179;
thus L292: thesis by L291 , L192;
end;
registration
let R8 being Ring;
let R10 being (Data-Location of R8);
let R11 being (Data-Location of R8);
cluster ( R10 := R11 ) -> non  halting;
coherence by L211;
cluster ( AddTo (R10 , R11) ) -> non  halting;
coherence by L214;
cluster ( SubFrom (R10 , R11) ) -> non  halting;
coherence by L217;
cluster ( MultBy (R10 , R11) ) -> non  halting;
coherence by L220;
end;
registration
let R8 being Ring;
let R15 being (Element of ( NAT ));
cluster ( goto (R15 , R8) ) -> non  halting;
coherence by L223;
end;
registration
let R8 being Ring;
let R10 being (Data-Location of R8);
let R15 being (Element of ( NAT ));
cluster ( R10 =0_goto R15 ) -> non  halting;
coherence by L251;
end;
registration
let R8 being Ring;
let R10 being (Data-Location of R8);
let R9 being (Element of R8);
cluster ( R10 := R9 ) -> non  halting;
coherence by L290;
end;
L297: (for R8 being Ring holds (for B56 being (Instruction of ( SCM R8 )) holds (B56 is  halting implies B56 = [ ( 0 ) , ( {} ) , ( {} ) ])))
proof
let R8 being Ring;
set D66 = [ ( 0 ) , ( {} ) , ( {} ) ];
let C40 being (Instruction of ( SCM R8 ));
assume that
L298: C40 is  halting;
assume L299: D66 <> C40;
per cases  by L58;
suppose L300: C40 = [ ( 0 ) , ( {} ) , ( {} ) ];

thus L301: thesis by L300 , L299;
end;
suppose L302: (ex R10 being (Data-Location of R8) st (ex R11 being (Data-Location of R8) st C40 = ( R10 := R11 )));

thus L303: thesis by L302 , L298;
end;
suppose L304: (ex R10 being (Data-Location of R8) st (ex R11 being (Data-Location of R8) st C40 = ( AddTo (R10 , R11) )));

thus L305: thesis by L304 , L298;
end;
suppose L306: (ex R10 being (Data-Location of R8) st (ex R11 being (Data-Location of R8) st C40 = ( SubFrom (R10 , R11) )));

thus L307: thesis by L306 , L298;
end;
suppose L308: (ex R10 being (Data-Location of R8) st (ex R11 being (Data-Location of R8) st C40 = ( MultBy (R10 , R11) )));

thus L309: thesis by L308 , L298;
end;
suppose L310: (ex R15 being (Element of ( NAT )) st C40 = ( goto (R15 , R8) ));

thus L311: thesis by L310 , L298;
end;
suppose L312: (ex R10 being (Data-Location of R8) st (ex R15 being (Element of ( NAT )) st C40 = ( R10 =0_goto R15 )));

thus L313: thesis by L312 , L298;
end;
suppose L314: (ex R10 being (Data-Location of R8) st (ex R9 being (Element of R8) st C40 = ( R10 := R9 )));

thus L315: thesis by L314 , L298;
end;
end;
registration
let R8 being Ring;
cluster ( SCM R8 ) ->  halting;
coherence
proof
thus L317: ( halt ( SCM R8 ) ) is  halting by L201;
end;
end;
theorem
L319: (for R8 being Ring holds (for B57 being (Instruction of ( SCM R8 )) holds (B57 is  halting implies B57 = ( halt ( SCM R8 ) )))) by L297;
theorem
L320: (for R8 being Ring holds ( halt ( SCM R8 ) ) = [ ( 0 ) , ( {} ) , ( {} ) ]);
theorem
L321: (for R8 being Ring holds ( Data-Locations ( SCM R8 ) ) = ( Data-Locations ( SCM ) ))
proof
let R8 being Ring;
L322: ( Data-Locations ( SCM ) ) misses { ( NAT ) } by AMI_2:20 , AMI_3:27 , ZFMISC_1:50;
L323: ( Data-Locations ( SCM ) ) misses { ( NAT ) } by L322;
thus L324: ( Data-Locations ( SCM R8 ) ) = ( ( SCM-Memory ) \ { ( IC ( SCM R8 ) ) } ) by L1
.= ( ( SCM-Memory ) \ { ( NAT ) } ) by L1
.= ( ( ( Data-Locations ( SCM ) ) \/ { ( NAT ) } ) \ { ( NAT ) } ) by AMI_3:27
.= ( ( Data-Locations ( SCM ) ) \ { ( NAT ) } ) by XBOOLE_1:40
.= ( Data-Locations ( SCM ) ) by L323 , XBOOLE_1:83;
end;
theorem
L325: (for R4 being set holds (for R8 being Ring holds (R4 is (Data-Location of R8) iff R4 in ( Data-Locations ( SCM R8 ) ))))
proof
let R4 being set;
let R8 being Ring;
L326: ( Data-Locations ( SCM R8 ) ) = ( Data-Locations ( SCM ) ) by L321;
thus L327: thesis by L326 , L17;
end;
theorem
L328: (for B58 being Ring holds ( the_Values_of ( SCM B58 ) ) = ( ( SCM-VAL B58 ) * ( SCM-OK ) )) by L5;
theorem
L329: (for B59 being Ring holds ( (the carrier of ( SCM B59 )) \ { ( NAT ) } ) = ( SCM-Data-Loc )) by L10;
