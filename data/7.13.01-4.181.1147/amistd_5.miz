:: Relocable Instructions
::  by Andrzej Trybulec
::
:: Received November 20, 2010
:: Copyright (c) 2010-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, ORDINAL1, SETFAM_1, ARYTM_1, ARYTM_3, CARD_1, SUBSET_1,
      AMI_1, XBOOLE_0, RELAT_1, TARSKI, FUNCOP_1, GLIB_000, GOBOARD5, AMISTD_1,
      UNIALG_1, FUNCT_1, CARD_5, STRUCT_0, VALUED_1, FSM_1, FUNCT_4, TURING_1,
      CIRCUIT2, AMISTD_2, PARTFUN1, EXTPRO_1, NAT_1, RELOC, PBOOLE, AMISTD_5,
      COMPOS_1, MSUALG_1, FINSET_1, QUANTAL1, MEMSTR_0, SCMFSA6B;
 notations TARSKI, XBOOLE_0,
      XTUPLE_0, SUBSET_1, ORDINAL1, SETFAM_1, MEMBERED,
      RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_4, PBOOLE, FINSET_1, CARD_1,
      NUMBERS, XCMPLX_0, XXREAL_0, NAT_1, CARD_3, FINSEQ_1, FUNCOP_1, NAT_D,
      FUNCT_7, VALUED_0, VALUED_1, AFINSQ_1, MEASURE6,
      STRUCT_0, MEMSTR_0, COMPOS_0, COMPOS_1,
      EXTPRO_1, AMISTD_1, AMISTD_2;
 constructors WELLORD2, REALSET1, NAT_D, AMISTD_1, XXREAL_2, PRE_POLY,
      AFINSQ_1, ORDINAL4, VALUED_1, AMISTD_2, PBOOLE, RELSET_1,
      FUNCT_7, FUNCT_4, MEMSTR_0, MEASURE6, XTUPLE_0;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, FINSET_1,
      XXREAL_0, XREAL_0, NAT_1, MEMBERED, FINSEQ_1, CARD_3, REALSET1, FUNCT_7,
      STRUCT_0, AMISTD_1, CARD_1, FUNCT_4, XXREAL_2, RELSET_1, GRFUNC_1,
      FUNCT_2, ORDINAL1, AFINSQ_1, VALUED_1, VALUED_0, COMPOS_1, EXTPRO_1,
      XCMPLX_0, REAL_1, PBOOLE, AMISTD_2, MEMSTR_0, MEASURE6, COMPOS_0,
      XTUPLE_0;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;
 definitions RELAT_1, FUNCT_1, WELLORD2, FUNCT_7, COMPOS_1, EXTPRO_1, AMISTD_1,
      XBOOLE_0, FUNCOP_1, CARD_3, NAT_1, AFINSQ_1, MCART_1, VALUED_1, TARSKI,
      AMISTD_2, STRUCT_0, MEMSTR_0, COMPOS_0, XTUPLE_0;
 theorems AMISTD_1, FUNCOP_1, FUNCT_1, FUNCT_4, GRFUNC_1, RELAT_1, TARSKI,
      ZFMISC_1, XBOOLE_0, XBOOLE_1, PBOOLE, PARTFUN1, RECDEF_2, VALUED_1,
      COMPOS_1, EXTPRO_1, ORDINAL1, NAT_D, AMISTD_2, RELSET_1, PRE_CIRC,
      MEMSTR_0, COMPOS_0;
 schemes NAT_1;

begin
theorem
L1: (for B1 being  with_zero set holds (for B2 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over B1 holds (for B3 being (Instruction of B2) holds (B3 is  jump-only implies (for B4 being (Element of ( NAT )) holds ( IncAddr (B3 , B4) ) is  jump-only)))))
proof
let C1 being  with_zero set;
let C2 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C1;
let C3 being (Instruction of C2);
assume that
L2: C3 is  jump-only;
let C4 being (Element of ( NAT ));
L3: ( InsCode C3 ) = ( InsCode ( IncAddr (C3 , C4) ) ) by COMPOS_0:def 9;
L4: ( InsCode C3 ) is  jump-only by L2 , AMISTD_1:def 2;
thus L5: thesis by L4 , L3 , AMISTD_1:def 2;
end;
registration
let C5 being  with_zero set;
let C6 being  with_explicit_jumps  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over C5;
let C7 being  IC-relocable (Instruction of C6);
let C8 being (Element of ( NAT ));
cluster ( IncAddr (C7 , C8) ) ->  IC-relocable;
coherence
proof
let C9 , C10 being Nat;
let C11 being (State of C6);
thus L6: ( ( IC ( Exec (( IncAddr (( IncAddr (C7 , C8) ) , C9) ) , C11) ) ) + C10 ) = ( ( IC ( Exec (( IncAddr (C7 , ( C8 + C9 )) ) , C11) ) ) + C10 ) by COMPOS_0:7
.= ( IC ( Exec (( IncAddr (C7 , ( ( C8 + C9 ) + C10 )) ) , ( IncIC (C11 , C10) )) ) ) by AMISTD_2:def 3
.= ( IC ( Exec (( IncAddr (C7 , ( C8 + ( C9 + C10 ) )) ) , ( IncIC (C11 , C10) )) ) )
.= ( IC ( Exec (( IncAddr (( IncAddr (C7 , C8) ) , ( C9 + C10 )) ) , ( IncIC (C11 , C10) )) ) ) by COMPOS_0:7;
end;
end;
definition
let C12 being  with_zero set;
let C13 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C12;
let C14 being (Instruction of C13);
attr C14 is  relocable
means
:L8: (for B5 , B6 being Nat holds (for B7 being (State of C13) holds ( Exec (( IncAddr (C14 , ( B5 + B6 )) ) , ( IncIC (B7 , B6) )) ) = ( IncIC (( Exec (( IncAddr (C14 , B5) ) , B7) ) , B6) )));
end;
registration
let C15 being  with_zero set;
let C16 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C15;
cluster  relocable ->  IC-relocable for (Instruction of C16);
coherence
proof
let C17 being (Instruction of C16);
assume that
L10: C17 is  relocable;
let C18 , C19 being Nat;
let C20 being (State of C16);
reconsider D1 = C19 as (Element of ( NAT )) by ORDINAL1:def 12;
thus L11: ( ( IC ( Exec (( IncAddr (C17 , C18) ) , C20) ) ) + C19 ) = ( IC ( IncIC (( Exec (( IncAddr (C17 , C18) ) , C20) ) , D1) ) ) by MEMSTR_0:53
.= ( IC ( Exec (( IncAddr (C17 , ( C18 + C19 )) ) , ( IncIC (C20 , C19) )) ) ) by L10 , L8;
end;
end;
definition
let C21 being  with_zero set;
let C22 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C21;
attr C22 is  relocable
means
:L13: (for B8 being (Instruction of C22) holds B8 is  relocable);
end;
theorem
L15: (for B9 being  with_zero set holds (for B10 being (Instruction of ( STC B9 )) holds (for B11 being (State of ( STC B9 )) holds (for B12 being Nat holds ( Exec (B10 , ( IncIC (B11 , B12) )) ) = ( IncIC (( Exec (B10 , B11) ) , B12) )))))
proof
let C23 being  with_zero set;
let C24 being (Instruction of ( STC C23 ));
let C25 being (State of ( STC C23 ));
let C26 being Nat;
per cases  by AMISTD_1:6;
suppose L16: ( InsCode C24 ) = 1;

thus L17: ( Exec (C24 , ( IncIC (C25 , C26) )) ) = ( IncIC (( IncIC (C25 , C26) ) , 1) ) by L16 , AMISTD_1:20
.= ( IncIC (C25 , ( 1 + C26 )) ) by MEMSTR_0:57
.= ( IncIC (( IncIC (C25 , 1) ) , C26) ) by MEMSTR_0:57
.= ( IncIC (( Exec (C24 , C25) ) , C26) ) by L16 , AMISTD_1:20;
end;
suppose L18: ( InsCode C24 ) = ( 0 );

L19: C24 is  halting by L18 , AMISTD_1:4;
thus L20: ( Exec (C24 , ( IncIC (C25 , C26) )) ) = ( IncIC (C25 , C26) ) by L19 , EXTPRO_1:def 3
.= ( IncIC (( Exec (C24 , C25) ) , C26) ) by L19 , EXTPRO_1:def 3;
end;
end;
definition
let C27 being  with_zero set;
let C28 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C27;
attr C28 is  IC-recognized
means
:L22: (for B13 being non  halt-free  finite (the InstructionsF of C28) -valued ( NAT ) -defined Function holds (for B14 being B13 -autonomic (FinPartState of C28) holds (B14 is non  empty implies ( IC C28 ) in ( dom B14 ))));
end;
theorem
L24: (for B15 being  with_zero set holds (for B16 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over B15 holds (B16 is  IC-recognized iff (for B17 being non  halt-free  finite (the InstructionsF of B16) -valued ( NAT ) -defined Function holds (for B18 being B17 -autonomic (FinPartState of B16) holds (( DataPart B18 ) <> ( {} ) implies ( IC B16 ) in ( dom B18 )))))))
proof
let C29 being  with_zero set;
let C30 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C29;
thus L25: (C30 is  IC-recognized implies (for B19 being non  halt-free  finite (the InstructionsF of C30) -valued ( NAT ) -defined Function holds (for B20 being B19 -autonomic (FinPartState of C30) holds (( DataPart B20 ) <> ( {} ) implies ( IC C30 ) in ( dom B20 )))))
proof
assume L26: C30 is  IC-recognized;
let C31 being non  halt-free  finite (the InstructionsF of C30) -valued ( NAT ) -defined Function;
let C32 being C31 -autonomic (FinPartState of C30);
assume L27: ( DataPart C32 ) <> ( {} );
L28: C32 is non  empty by L27;
thus L29: thesis by L28 , L26 , L22;
end;

assume L30: (for B21 being non  halt-free  finite (the InstructionsF of C30) -valued ( NAT ) -defined Function holds (for B22 being B21 -autonomic (FinPartState of C30) holds (( DataPart B22 ) <> ( {} ) implies ( IC C30 ) in ( dom B22 ))));
let C33 being non  halt-free  finite (the InstructionsF of C30) -valued ( NAT ) -defined Function;
let C34 being C33 -autonomic (FinPartState of C30);
L31: ( dom C34 ) c= ( { ( IC C30 ) } \/ ( dom ( DataPart C34 ) ) ) by MEMSTR_0:32;
assume L32: C34 is non  empty;
per cases ;
suppose L33: ( IC C30 ) in ( dom C34 );

thus L34: ( IC C30 ) in ( dom C34 ) by L33;
end;
suppose L35: (not ( IC C30 ) in ( dom C34 ));

L36: { ( IC C30 ) } misses ( dom C34 ) by L35 , ZFMISC_1:50;
L37: ( dom ( DataPart C34 ) ) is non  empty by L36 , L32 , L31 , XBOOLE_1:3 , XBOOLE_1:73;
L38: ( DataPart C34 ) is non  empty by L37;
thus L39: ( IC C30 ) in ( dom C34 ) by L38 , L30;
end;
end;
registration
let C35 being  with_zero set;
cluster ( Data-Locations ( STC C35 ) ) ->  empty;
coherence
proof
L41: (the carrier of ( STC C35 )) = { ( 0 ) } by AMISTD_1:def 7
.= { ( IC ( STC C35 ) ) } by AMISTD_1:def 7;
thus L42: thesis by L41 , XBOOLE_1:37;
end;
end;
registration
let C36 being  with_zero set;
let C37 being (PartState of ( STC C36 ));
cluster ( DataPart C37 ) ->  empty;
coherence;
end;
registration
let C38 being  with_zero set;
cluster ( STC C38 ) ->  IC-recognized  relocable;
coherence
proof
L45: (for B23 being non  halt-free  finite (the InstructionsF of ( STC C38 )) -valued ( NAT ) -defined Function holds (for B24 being B23 -autonomic (FinPartState of ( STC C38 )) holds (( DataPart B24 ) <> ( {} ) implies ( IC ( STC C38 ) ) in ( dom B24 ))));
thus L46: ( STC C38 ) is  IC-recognized by L45 , L24;
let C39 being (Instruction of ( STC C38 ));
let C40 , C41 being Nat;
let C42 being (State of ( STC C38 ));
thus L47: ( Exec (( IncAddr (C39 , ( C40 + C41 )) ) , ( IncIC (C42 , C41) )) ) = ( Exec (C39 , ( IncIC (C42 , C41) )) ) by COMPOS_0:4
.= ( IncIC (( Exec (C39 , C42) ) , C41) ) by L15
.= ( IncIC (( Exec (( IncAddr (C39 , C40) ) , C42) ) , C41) ) by COMPOS_0:4;
end;
end;
registration
let C43 being  with_zero set;
cluster  relocable  IC-recognized for  standard  halting  IC-Ins-separated non  empty  with_non-empty_values  standard  halting  IC-Ins-separated non  empty  with_non-empty_values  standard  halting  IC-Ins-separated non  empty  with_non-empty_values  standard  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C43;
existence
proof
take ( STC C43 );
thus L49: thesis;
end;
end;
registration
let C44 being  with_zero set;
let C45 being  relocable  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C44;
cluster  ->  relocable for (Instruction of C45);
coherence by L13;
end;
theorem
L52: (for R1 being Nat holds (for B25 being  with_zero set holds (for B26 being  relocable  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over B25 holds (for B27 being (Instruction of B26) holds (for B28 being (State of B26) holds ( Exec (( IncAddr (B27 , R1) ) , ( IncIC (B28 , R1) )) ) = ( IncIC (( Exec (B27 , B28) ) , R1) ))))))
proof
let R1 being Nat;
let C46 being  with_zero set;
let C47 being  relocable  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C46;
let C48 being (Instruction of C47);
let C49 being (State of C47);
thus L53: ( Exec (( IncAddr (C48 , R1) ) , ( IncIC (C49 , R1) )) ) = ( Exec (( IncAddr (C48 , ( (( 0 ) qua Nat) + R1 )) ) , ( IncIC (C49 , R1) )) )
.= ( IncIC (( Exec (( IncAddr (C48 , ( 0 )) ) , C49) ) , R1) ) by L8
.= ( IncIC (( Exec (C48 , C49) ) , R1) ) by COMPOS_0:3;
end;
theorem
L54: (for B29 being  with_zero set holds (for B30 being  relocable  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over B29 holds (for B31 being (Instruction of B30) holds (for B32 being (State of B30) holds (for B33 , B34 being (Element of ( NAT )) holds (( IC B32 ) = ( B33 + B34 ) implies ( Exec (B31 , ( DecIC (B32 , B34) )) ) = ( DecIC (( Exec (( IncAddr (B31 , B34) ) , B32) ) , B34) )))))))
proof
let C50 being  with_zero set;
let C51 being  relocable  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C50;
let C52 being (Instruction of C51);
let C53 being (State of C51);
let C54 , C55 being (Element of ( NAT ));
assume that
L55: ( IC C53 ) = ( C54 + C55 );
set D2 = ( C53 +* ( Start-At (C54 , C51) ) );
L56: ( IncIC (D2 , C55) ) = ( C53 +* ( Start-At (( IC C53 ) , C51) ) ) by L55 , MEMSTR_0:58
.= C53 by MEMSTR_0:31;
thus L57: ( Exec (C52 , ( DecIC (C53 , C55) )) ) = ( Exec (C52 , D2) ) by L55 , NAT_D:34
.= ( ( Exec (C52 , D2) ) +* ( Start-At (( IC ( Exec (C52 , D2) ) ) , C51) ) ) by MEMSTR_0:31
.= ( ( IncIC (( Exec (C52 , D2) ) , C55) ) +* ( Start-At (( IC ( Exec (C52 , D2) ) ) , C51) ) ) by FUNCT_4:114
.= ( DecIC (( IncIC (( Exec (C52 , D2) ) , C55) ) , C55) ) by MEMSTR_0:59
.= ( DecIC (( Exec (( IncAddr (C52 , C55) ) , C53) ) , C55) ) by L56 , L52;
end;
registration
let C56 being  with_zero set;
cluster  relocable  IC-recognized for  halting  IC-Ins-separated non  empty  with_non-empty_values  halting  IC-Ins-separated non  empty  with_non-empty_values  halting  IC-Ins-separated non  empty  with_non-empty_values  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C56;
existence
proof
take ( STC C56 );
thus L58: thesis;
end;
end;
theorem
L60: (for R2 being  with_zero set holds (for R3 being  IC-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2 holds (for B35 being non  halt-free  finite (the InstructionsF of R3) -valued ( NAT ) -defined Function holds (for B36 being B35 -autonomic non  empty (FinPartState of R3) holds ( IC R3 ) in ( dom B36 )))))
proof
let R2 being  with_zero set;
let R3 being  IC-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
let C57 being non  halt-free  finite (the InstructionsF of R3) -valued ( NAT ) -defined Function;
let C58 being C57 -autonomic non  empty (FinPartState of R3);
L61: ( dom C58 ) meets ( { ( IC R3 ) } \/ ( Data-Locations R3 ) ) by MEMSTR_0:41;
per cases  by L61 , XBOOLE_1:70;
suppose L62: ( dom C58 ) meets { ( IC R3 ) };

thus L63: thesis by L62 , ZFMISC_1:50;
end;
suppose L64: ( dom C58 ) meets ( Data-Locations R3 );

L65: ( ( dom C58 ) /\ ( Data-Locations R3 ) ) <> ( {} ) by L64 , XBOOLE_0:def 7;
L66: ( DataPart C58 ) <> ( {} ) by L65 , RELAT_1:38 , RELAT_1:61;
thus L67: thesis by L66 , L24;
end;
end;
definition
let R2 being  with_zero set;
let C59 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
attr C59 is  CurIns-recognized
means
:L69: (for B37 being non  halt-free  finite (the InstructionsF of C59) -valued ( NAT ) -defined Function holds (for B38 being B37 -autonomic non  empty (FinPartState of C59) holds (for B39 being (State of C59) holds (B38 c= B39 implies (for B40 being (Instruction-Sequence of C59) holds (B37 c= B40 implies (for B41 being (Element of ( NAT )) holds ( IC ( Comput (B40 , B39 , B41) ) ) in ( dom B37 ))))))));
end;
registration
let R2 being  with_zero set;
cluster ( STC R2 ) ->  CurIns-recognized;
coherence
proof
let C60 being non  halt-free  finite (the InstructionsF of ( STC R2 )) -valued ( NAT ) -defined Function;
let C61 being C60 -autonomic non  empty (FinPartState of ( STC R2 ));
let C62 being (State of ( STC R2 ));
assume that
L71: C61 c= C62;
let C63 being (Instruction-Sequence of ( STC R2 ));
assume that
L72: C60 c= C63;
let C64 being (Element of ( NAT ));
set D3 = ( Comput (C63 , C62 , C64) );
set D4 = ( IC D3 );
set D5 = ( D4 + 1 );
assume L73: (not ( IC ( Comput (C63 , C62 , C64) ) ) in ( dom C60 ));
L74: (the InstructionsF of ( STC R2 )) = { [ ( 0 ) , ( 0 ) , ( 0 ) ] , [ 1 , ( 0 ) , ( 0 ) ] } by AMISTD_1:def 7;
reconsider D6 = [ 1 , ( 0 ) , ( 0 ) ] as (Instruction of ( STC R2 )) by L74 , TARSKI:def 2;
set D7 = ( C60 +* ( D4 .--> D6 ) );
set D8 = ( C60 +* ( D4 .--> ( halt ( STC R2 ) ) ) );
reconsider D9 = ( C63 +* ( D4 .--> D6 ) ) as (Instruction-Sequence of ( STC R2 ));
reconsider D10 = ( C63 +* ( D4 .--> ( halt ( STC R2 ) ) ) ) as (Instruction-Sequence of ( STC R2 ));
L75: ( dom ( D4 .--> ( halt ( STC R2 ) ) ) ) = { D4 } by FUNCOP_1:13;
L76: D4 in ( dom ( D4 .--> ( halt ( STC R2 ) ) ) ) by L75 , TARSKI:def 1;
L77: ( dom ( D4 .--> D6 ) ) = { D4 } by FUNCOP_1:13;
L78: D4 in ( dom ( D4 .--> D6 ) ) by L77 , TARSKI:def 1;
L79: ( dom C60 ) misses ( dom ( D4 .--> ( halt ( STC R2 ) ) ) ) by L73 , L75 , ZFMISC_1:50;
L80: ( dom C60 ) misses ( dom ( D4 .--> D6 ) ) by L73 , L77 , ZFMISC_1:50;
L81: D7 c= D9 by L72 , FUNCT_4:123;
L82: D8 c= D10 by L72 , FUNCT_4:123;
set D11 = ( Comput (D10 , C62 , C64) );
set D12 = ( Comput (D9 , C62 , C64) );
L83: (not C61 is C60 -autonomic)
proof
L84: ( ( D4 .--> ( halt ( STC R2 ) ) ) . D4 ) = ( halt ( STC R2 ) ) by FUNCOP_1:72;
L85: ( D10 . D4 ) = ( halt ( STC R2 ) ) by L84 , L76 , FUNCT_4:13;
L86: ( ( D4 .--> D6 ) . D4 ) = D6 by FUNCOP_1:72;
L87: ( D9 . D4 ) = D6 by L86 , L78 , FUNCT_4:13;
take D9;
take D10;
L88: C60 c= D7 by L80 , FUNCT_4:32;
thus L89: C60 c= D9 by L88 , L81 , XBOOLE_1:1;
L90: C60 c= D8 by L79 , FUNCT_4:32;
thus L91: C60 c= D10 by L90 , L82 , XBOOLE_1:1;
take C62;
take C62;
thus L92: C61 c= C62 by L71;
L93: ( D12 | ( dom C61 ) ) = ( D3 | ( dom C61 ) ) by L89 , L72 , L71 , EXTPRO_1:def 10;
thus L94: C61 c= C62 by L71;
L95: ( D12 | ( dom C61 ) ) = ( D11 | ( dom C61 ) ) by L89 , L91 , L71 , EXTPRO_1:def 10;
take D13 = ( C64 + 1 );
set D14 = ( Comput (D9 , C62 , D13) );
L96: D14 = ( Following (D9 , D12) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D9 , D12) ) , D12) );
L97: ( InsCode D6 ) = 1 by RECDEF_2:def 1;
L98: ( IC ( Exec (D6 , D12) ) ) = ( succ ( IC D12 ) ) by L97 , AMISTD_1:9;
L99: ( IC D3 ) = ( IC ( D3 | ( dom C61 ) ) ) by L60 , FUNCT_1:49;
L100: ( IC D12 ) = D4 by L99 , L93 , L60 , FUNCT_1:49;
L101: ( IC D14 ) = D5 by L100 , L98 , L96 , L87 , PBOOLE:143;
set D15 = ( Comput (D10 , C62 , D13) );
L102: D15 = ( Following (D10 , D11) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D10 , D11) ) , D11) );
L103: ( D10 /. ( IC D11 ) ) = ( D10 . ( IC D11 ) ) by PBOOLE:143;
L104: ( IC D11 ) = D4 by L93 , L99 , L95 , L60 , FUNCT_1:49;
L105: ( IC D15 ) = D4 by L104 , L102 , L85 , L103 , EXTPRO_1:def 3;
L106: (( IC ( D14 | ( dom C61 ) ) ) = ( IC D14 ) & ( IC ( D15 | ( dom C61 ) ) ) = ( IC D15 )) by L60 , FUNCT_1:49;
thus L107: thesis by L106 , L101 , L105;
end;
thus L108: contradiction by L83;
end;
end;
registration
let C65 being  with_zero set;
cluster  relocable  IC-recognized  CurIns-recognized for  halting  IC-Ins-separated non  empty  with_non-empty_values  halting  IC-Ins-separated non  empty  with_non-empty_values  halting  IC-Ins-separated non  empty  with_non-empty_values  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C65;
existence
proof
take ( STC C65 );
thus L110: thesis;
end;
end;
theorem
L112: (for R2 being  with_zero set holds (for R4 being  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2 holds (for B42 being non  halt-free  finite (the InstructionsF of R4) -valued ( NAT ) -defined Function holds (for B43 being B42 -autonomic non  empty (FinPartState of R4) holds (for B44 , B45 being (State of R4) holds ((B43 c= B44 & B43 c= B45) implies (for B46 , B47 being (Instruction-Sequence of R4) holds ((B42 c= B46 & B42 c= B47) implies (for B48 being (Element of ( NAT )) holds (( IC ( Comput (B46 , B44 , B48) ) ) = ( IC ( Comput (B47 , B45 , B48) ) ) & ( CurInstr (B46 , ( Comput (B46 , B44 , B48) )) ) = ( CurInstr (B47 , ( Comput (B47 , B45 , B48) )) )))))))))))
proof
let R2 being  with_zero set;
let R4 being  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
let C66 being non  halt-free  finite (the InstructionsF of R4) -valued ( NAT ) -defined Function;
let C67 being C66 -autonomic non  empty (FinPartState of R4);
let C68 , C69 being (State of R4);
assume that
L113: C67 c= C68
and
L114: C67 c= C69;
let C70 , C71 being (Instruction-Sequence of R4);
assume that
L115: C66 c= C70
and
L116: C66 c= C71;
L117: ( dom C66 ) c= ( dom C70 ) by L115 , RELAT_1:11;
L118: ( dom C66 ) c= ( dom C71 ) by L116 , RELAT_1:11;
let C72 being (Element of ( NAT ));
set D16 = ( Comput (C71 , C69 , C72) );
set D17 = ( Comput (C70 , C68 , C72) );
L119: ( IC D17 ) in ( dom C66 ) by L115 , L69 , L113;
L120: ( IC D16 ) in ( dom C66 ) by L116 , L69 , L114;
thus L121: ( IC D17 ) = ( IC D16 )
proof
assume L122: ( IC ( Comput (C70 , C68 , C72) ) ) <> ( IC ( Comput (C71 , C69 , C72) ) );
L123: (( ( D17 | ( dom C67 ) ) . ( IC R4 ) ) = ( D17 . ( IC R4 ) ) & ( ( D16 | ( dom C67 ) ) . ( IC R4 ) ) = ( D16 . ( IC R4 ) )) by L60 , FUNCT_1:49;
thus L124: contradiction by L123 , L122 , L115 , L116 , L113 , L114 , EXTPRO_1:def 10;
end;

thus L125: ( CurInstr (C70 , ( Comput (C70 , C68 , C72) )) ) = ( C70 . ( IC D17 ) ) by L119 , L117 , PARTFUN1:def 6
.= ( C66 . ( IC D17 ) ) by L119 , L115 , GRFUNC_1:2
.= ( C71 . ( IC D16 ) ) by L120 , L116 , L121 , GRFUNC_1:2
.= ( CurInstr (C71 , ( Comput (C71 , C69 , C72) )) ) by L120 , L118 , PARTFUN1:def 6;
end;
theorem
L126: (for R2 being  with_zero set holds (for R5 being  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2 holds (for B49 being (Element of ( NAT )) holds (for B50 being non  halt-free  finite (the InstructionsF of R5) -valued ( NAT ) -defined Function holds (for B51 being B50 -autonomic (FinPartState of R5) holds (( IC R5 ) in ( dom B51 ) implies (for B52 being (State of R5) holds (B51 c= B52 implies (for B53 being (Instruction-Sequence of R5) holds (B50 c= B53 implies (for B54 being (Element of ( NAT )) holds ( Comput (( B53 +* ( Reloc (B50 , B49) ) ) , ( B52 +* ( IncIC (B51 , B49) ) ) , B54) ) = ( IncIC (( Comput (B53 , B52 , B54) ) , B49) ))))))))))))
proof
let R2 being  with_zero set;
let R5 being  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
let C73 being (Element of ( NAT ));
let C74 being non  halt-free  finite (the InstructionsF of R5) -valued ( NAT ) -defined Function;
let C75 being C74 -autonomic (FinPartState of R5);
assume that
L127: ( IC R5 ) in ( dom C75 );
let C76 being (State of R5);
assume that
L128: C75 c= C76;
let C77 being (Instruction-Sequence of R5);
assume L129: C74 c= C77;
defpred S1[ (Element of ( NAT )) ] means ( Comput (( C77 +* ( Reloc (C74 , C73) ) ) , ( C76 +* ( IncIC (C75 , C73) ) ) , $1) ) = ( IncIC (( Comput (C77 , C76 , $1) ) , C73) );
L130: (for B55 being (Element of ( NAT )) holds (S1[ B55 ] implies S1[ ( B55 + 1 ) ]))
proof
let C78 being (Element of ( NAT ));
assume that
L131: ( Comput (( C77 +* ( Reloc (C74 , C73) ) ) , ( C76 +* ( IncIC (C75 , C73) ) ) , C78) ) = ( IncIC (( Comput (C77 , C76 , C78) ) , C73) );
reconsider D18 = ( IC ( Comput (C77 , C76 , C78) ) ) as (Element of ( NAT ));
L132: ( dom ( Start-At (( ( IC ( Comput (C77 , C76 , C78) ) ) + C73 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L133: ( IC R5 ) in ( dom ( Start-At (( ( IC ( Comput (C77 , C76 , C78) ) ) + C73 ) , R5) ) ) by L132 , TARSKI:def 1;
L134: ( IC ( IncIC (( Comput (C77 , C76 , C78) ) , C73) ) ) = ( IC ( Start-At (( ( IC ( Comput (C77 , C76 , C78) ) ) + C73 ) , R5) ) ) by L133 , FUNCT_4:13
.= ( ( IC ( Comput (C77 , C76 , C78) ) ) + C73 ) by FUNCOP_1:72;
L135: (not C75 is  empty) by L127;
L136: ( IC ( Comput (C77 , C76 , C78) ) ) in ( dom C74 ) by L135 , L129 , L69 , L128;
L137: ( IC ( Comput (C77 , C76 , C78) ) ) in ( dom ( IncAddr (C74 , C73) ) ) by L136 , COMPOS_1:def 21;
L138: ( C74 /. D18 ) = ( C74 . ( IC ( Comput (C77 , C76 , C78) ) ) ) by L136 , PARTFUN1:def 6
.= ( C77 . ( IC ( Comput (C77 , C76 , C78) ) ) ) by L136 , L129 , GRFUNC_1:2;
reconsider D19 = ( IC ( Comput (C77 , C76 , C78) ) ) as (Element of ( NAT ));
L139: ( ( IC ( Comput (C77 , C76 , C78) ) ) + C73 ) in ( dom ( Reloc (C74 , C73) ) ) by L136 , COMPOS_1:46;
L140: ( CurInstr (( C77 +* ( Reloc (C74 , C73) ) ) , ( Comput (( C77 +* ( Reloc (C74 , C73) ) ) , ( C76 +* ( IncIC (C75 , C73) ) ) , C78) )) ) = ( ( C77 +* ( Reloc (C74 , C73) ) ) . ( IC ( Comput (( C77 +* ( Reloc (C74 , C73) ) ) , ( C76 +* ( IncIC (C75 , C73) ) ) , C78) ) ) ) by PBOOLE:143
.= ( ( Reloc (C74 , C73) ) . ( ( IC ( Comput (C77 , C76 , C78) ) ) + C73 ) ) by L131 , L134 , L139 , FUNCT_4:13
.= ( ( IncAddr (C74 , C73) ) . D19 ) by L137 , VALUED_1:def 12
.= ( IncAddr (( C74 /. D19 ) , C73) ) by L136 , COMPOS_1:def 21
.= ( IncAddr (( CurInstr (C77 , ( Comput (C77 , C76 , C78) )) ) , C73) ) by L138 , PBOOLE:143;
thus L141: ( Comput (( C77 +* ( Reloc (C74 , C73) ) ) , ( C76 +* ( IncIC (C75 , C73) ) ) , ( C78 + 1 )) ) = ( Following (( C77 +* ( Reloc (C74 , C73) ) ) , ( Comput (( C77 +* ( Reloc (C74 , C73) ) ) , ( C76 +* ( IncIC (C75 , C73) ) ) , C78) )) ) by EXTPRO_1:3
.= ( IncIC (( Following (C77 , ( Comput (C77 , C76 , C78) )) ) , C73) ) by L131 , L140 , L52
.= ( IncIC (( Comput (C77 , C76 , ( C78 + 1 )) ) , C73) ) by EXTPRO_1:3;
end;
L142: ( IC C75 ) = ( IC C76 ) by L128 , L127 , GRFUNC_1:2;
L143: ( DataPart C75 ) c= C75 by MEMSTR_0:12;
L144: ( Comput (( C77 +* ( Reloc (C74 , C73) ) ) , ( C76 +* ( IncIC (C75 , C73) ) ) , ( 0 )) ) = ( C76 +* ( ( DataPart C75 ) +* ( Start-At (( ( IC C75 ) + C73 ) , R5) ) ) ) by L127 , MEMSTR_0:56
.= ( ( C76 +* ( DataPart C75 ) ) +* ( Start-At (( ( IC C75 ) + C73 ) , R5) ) ) by FUNCT_4:14
.= ( IncIC (( Comput (C77 , C76 , ( 0 )) ) , C73) ) by L142 , L143 , L128 , FUNCT_4:98 , XBOOLE_1:1;
L145: S1[ ( 0 ) ] by L144;
thus L146: (for B56 being (Element of ( NAT )) holds S1[ B56 ]) from NAT_1:sch 1(L145 , L130);
end;
theorem
L147: (for R2 being  with_zero set holds (for R5 being  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2 holds (for B57 being (Element of ( NAT )) holds (for B58 being non  halt-free  finite (the InstructionsF of R5) -valued ( NAT ) -defined Function holds (for B59 being B58 -autonomic (FinPartState of R5) holds (( IC R5 ) in ( dom B59 ) implies (for B60 being (State of R5) holds (( IncIC (B59 , B57) ) c= B60 implies (for B61 being (Instruction-Sequence of R5) holds (( Reloc (B58 , B57) ) c= B61 implies (for B62 being (Element of ( NAT )) holds ( Comput (B61 , B60 , B62) ) = ( IncIC (( Comput (( B61 +* B58 ) , ( B60 +* B59 ) , B62) ) , B57) ))))))))))))
proof
let R2 being  with_zero set;
let R5 being  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
let C79 being (Element of ( NAT ));
let C80 being non  halt-free  finite (the InstructionsF of R5) -valued ( NAT ) -defined Function;
let C81 being C80 -autonomic (FinPartState of R5);
assume that
L148: ( IC R5 ) in ( dom C81 );
let C82 being (State of R5);
assume that
L149: ( IncIC (C81 , C79) ) c= C82;
let C83 being (Instruction-Sequence of R5);
assume that
L150: ( Reloc (C80 , C79) ) c= C83;
defpred S2[ (Element of ( NAT )) ] means ( Comput (C83 , C82 , $1) ) = ( IncIC (( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , $1) ) , C79) );
L151: (for B63 being (Element of ( NAT )) holds (S2[ B63 ] implies S2[ ( B63 + 1 ) ]))
proof
let C84 being (Element of ( NAT ));
assume that
L152: ( Comput (C83 , C82 , C84) ) = ( IncIC (( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , C84) ) , C79) );
reconsider D20 = ( IC ( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , C84) ) ) as (Element of ( NAT ));
L153: ( dom ( Start-At (( ( IC ( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , C84) ) ) + C79 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L154: ( IC R5 ) in ( dom ( Start-At (( ( IC ( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , C84) ) ) + C79 ) , R5) ) ) by L153 , TARSKI:def 1;
L155: C81 c= ( C82 +* C81 ) by FUNCT_4:25;
L156: C80 c= ( C83 +* C80 ) by FUNCT_4:25;
L157: (not C81 is  empty) by L148;
L158: ( IC ( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , C84) ) ) in ( dom C80 ) by L157 , L69 , L155 , L156;
L159: ( IC ( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , C84) ) ) in ( dom ( IncAddr (C80 , C79) ) ) by L158 , COMPOS_1:def 21;
L160: ( ( IC ( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , C84) ) ) + C79 ) in ( dom ( Reloc (C80 , C79) ) ) by L158 , COMPOS_1:46;
reconsider D21 = ( IC ( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , C84) ) ) as (Element of ( NAT ));
L161: ( IC ( Comput (C83 , C82 , C84) ) ) = ( IC ( Start-At (( ( IC ( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , C84) ) ) + C79 ) , R5) ) ) by L152 , L154 , FUNCT_4:13
.= ( ( IC ( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , C84) ) ) + C79 ) by FUNCOP_1:72;
L162: C80 c= ( C83 +* C80 ) by FUNCT_4:25;
L163: ( C80 /. D21 ) = ( C80 . D21 ) by L158 , PARTFUN1:def 6;
L164: ( dom ( C83 +* C80 ) ) = ( NAT ) by PARTFUN1:def 2;
L165: ( dom C83 ) = ( NAT ) by PARTFUN1:def 2;
L166: ( CurInstr (C83 , ( Comput (C83 , C82 , C84) )) ) = ( C83 . ( IC ( Comput (C83 , C82 , C84) ) ) ) by L165 , PARTFUN1:def 6
.= ( ( Reloc (C80 , C79) ) . ( IC ( Comput (C83 , C82 , C84) ) ) ) by L150 , L160 , L161 , GRFUNC_1:2
.= ( ( IncAddr (C80 , C79) ) . D21 ) by L159 , L161 , VALUED_1:def 12
.= ( IncAddr (( C80 /. D21 ) , C79) ) by L158 , COMPOS_1:def 21
.= ( IncAddr (( ( C83 +* C80 ) . ( IC ( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , C84) ) ) ) , C79) ) by L158 , L163 , L162 , GRFUNC_1:2
.= ( IncAddr (( CurInstr (( C83 +* C80 ) , ( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , C84) )) ) , C79) ) by L164 , PARTFUN1:def 6;
thus L167: ( Comput (C83 , C82 , ( C84 + 1 )) ) = ( Following (C83 , ( Comput (C83 , C82 , C84) )) ) by EXTPRO_1:3
.= ( IncIC (( Following (( C83 +* C80 ) , ( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , C84) )) ) , C79) ) by L152 , L166 , L52
.= ( IncIC (( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , ( C84 + 1 )) ) , C79) ) by EXTPRO_1:3;
end;
set D22 = ( Start-At (( IC C81 ) , R5) );
L168: ( dom ( Start-At (( IC C81 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L169: ( Start-At (( ( IC C81 ) + C79 ) , R5) ) c= ( IncIC (C81 , C79) ) by MEMSTR_0:55;
L170: ( IC ( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , ( 0 )) ) ) = ( IC C81 ) by L148 , FUNCT_4:13;
set D23 = ( DataPart C81 );
L171: ( DataPart ( IncIC (C81 , C79) ) ) c= ( IncIC (C81 , C79) ) by RELAT_1:59;
L172: ( DataPart ( IncIC (C81 , C79) ) ) c= C82 by L171 , L149 , XBOOLE_1:1;
L173: ( DataPart C81 ) c= C82 by L172 , MEMSTR_0:51;
set D24 = ( Reloc (C80 , C79) );
set D25 = ( Start-At (( ( IC ( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , ( 0 )) ) ) + C79 ) , R5) );
L174: ( dom ( Start-At (( ( IC ( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , ( 0 )) ) ) + C79 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L175: ( Comput (C83 , C82 , ( 0 )) ) = ( C82 +* D25 ) by L170 , L149 , L169 , FUNCT_4:98 , XBOOLE_1:1
.= ( ( C82 +* D23 ) +* D25 ) by L173 , FUNCT_4:98
.= ( ( ( C82 +* D23 ) +* D22 ) +* D25 ) by L174 , L168 , FUNCT_4:74
.= ( ( C82 +* ( D23 +* D22 ) ) +* D25 ) by FUNCT_4:14
.= ( IncIC (( Comput (( C83 +* C80 ) , ( C82 +* C81 ) , ( 0 )) ) , C79) ) by L148 , MEMSTR_0:26;
L176: S2[ ( 0 ) ] by L175;
thus L177: (for B64 being (Element of ( NAT )) holds S2[ B64 ]) from NAT_1:sch 1(L176 , L151);
end;
theorem
L178: (for R2 being  with_zero set holds (for R5 being  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2 holds (for B65 being (Element of ( NAT )) holds (for B66 being non  halt-free  finite (the InstructionsF of R5) -valued ( NAT ) -defined Function holds (for B67 being non  empty (FinPartState of R5) holds (( IC R5 ) in ( dom B67 ) implies (for B68 being (State of R5) holds ((B67 c= B68 & ( IncIC (B67 , B65) ) is ( Reloc (B66 , B65) ) -autonomic) implies (for B69 being (Instruction-Sequence of R5) holds (B66 c= B69 implies (for B70 being (Element of ( NAT )) holds ( Comput (B69 , B68 , B70) ) = ( DecIC (( Comput (( B69 +* ( Reloc (B66 , B65) ) ) , ( B68 +* ( IncIC (B67 , B65) ) ) , B70) ) , B65) ))))))))))))
proof
let R2 being  with_zero set;
let R5 being  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
let C85 being (Element of ( NAT ));
let C86 being non  halt-free  finite (the InstructionsF of R5) -valued ( NAT ) -defined Function;
let C87 being non  empty (FinPartState of R5);
assume L179: ( IC R5 ) in ( dom C87 );
L180: ( Start-At (( IC C87 ) , R5) ) c= C87 by L179 , FUNCOP_1:84;
let C88 being (State of R5);
assume that
L181: C87 c= C88
and
L182: ( IncIC (C87 , C85) ) is ( Reloc (C86 , C85) ) -autonomic;
let C89 being (Instruction-Sequence of R5);
assume that
L183: C86 c= C89;
defpred S3[ (Element of ( NAT )) ] means ( Comput (C89 , C88 , $1) ) = ( DecIC (( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , $1) ) , C85) );
L184: (for B71 being (Element of ( NAT )) holds (S3[ B71 ] implies S3[ ( B71 + 1 ) ]))
proof
reconsider D26 = C86 as (preProgram of R5);
let C90 being (Element of ( NAT ));
assume that
L185: ( Comput (C89 , C88 , C90) ) = ( DecIC (( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , C90) ) , C85) );
reconsider D27 = ( IC ( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , C90) ) ) as (Element of ( NAT ));
reconsider D28 = ( IC ( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , C90) ) ) as (Element of ( NAT ));
L186: ( IncIC (C87 , C85) ) c= ( C88 +* ( IncIC (C87 , C85) ) ) by FUNCT_4:25;
L187: ( Reloc (C86 , C85) ) c= ( C89 +* ( Reloc (C86 , C85) ) ) by FUNCT_4:25;
L188: ( IC ( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , C90) ) ) in ( dom ( Reloc (C86 , C85) ) ) by L182 , L69 , L186 , L187;
L189: D28 in { ( R7 + C85 ) where R7 is (Element of ( NAT )) : R7 in ( dom C86 ) } by L188 , COMPOS_1:33;
L190: ( dom ( Start-At (( ( IC ( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , C90) ) ) -' C85 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L191: ( IC R5 ) in ( dom ( Start-At (( ( IC ( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , C90) ) ) -' C85 ) , R5) ) ) by L190 , TARSKI:def 1;
consider C91 being (Element of ( NAT )) such that L192: D28 = ( C91 + C85 ) and L193: C91 in ( dom C86 ) by L189;
L194: ( dom ( C89 +* ( Reloc (C86 , C85) ) ) ) = ( NAT ) by PARTFUN1:def 2;
L195: ( Reloc (C86 , C85) ) c= ( C89 +* ( Reloc (C86 , C85) ) ) by FUNCT_4:25;
L196: ( Reloc (C86 , C85) ) = ( IncAddr (( Shift (C86 , C85) ) , C85) ) by COMPOS_1:34;
L197: ( dom ( Shift (D26 , C85) ) ) = { ( R6 + C85 ) where R6 is (Element of ( NAT )) : R6 in ( dom D26 ) } by VALUED_1:def 12;
L198: ( C91 + C85 ) in ( dom ( Shift (C86 , C85) ) ) by L197 , L193;
L199: ( IncAddr (( ( Shift (C86 , C85) ) /. D27 ) , C85) ) = ( ( Reloc (C86 , C85) ) . ( IC ( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , C90) ) ) ) by L198 , L192 , COMPOS_1:def 21 , L196
.= ( ( C89 +* ( Reloc (C86 , C85) ) ) . ( IC ( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , C90) ) ) ) by L188 , L195 , GRFUNC_1:2
.= ( CurInstr (( C89 +* ( Reloc (C86 , C85) ) ) , ( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , C90) )) ) by L194 , PARTFUN1:def 6;
L200: ( ( C91 + C85 ) -' C85 ) = C91 by NAT_D:34;
L201: ( dom C89 ) = ( NAT ) by PARTFUN1:def 2;
L202: ( IC ( DecIC (( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , C90) ) , C85) ) ) = ( ( Start-At (( ( IC ( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , C90) ) ) -' C85 ) , R5) ) . ( IC R5 ) ) by L191 , FUNCT_4:13
.= ( ( IC ( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , C90) ) ) -' C85 ) by FUNCOP_1:72;
L203: ( CurInstr (C89 , ( Comput (C89 , C88 , C90) )) ) = ( C89 . ( IC ( Comput (C89 , C88 , C90) ) ) ) by L201 , PARTFUN1:def 6
.= ( C86 . ( IC ( Comput (C89 , C88 , C90) ) ) ) by L185 , L192 , L193 , L200 , L183 , L202 , GRFUNC_1:2
.= ( ( Shift (C86 , C85) ) . ( IC ( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , C90) ) ) ) by L192 , L193 , L200 , L185 , L202 , VALUED_1:def 12
.= ( ( Shift (C86 , C85) ) /. D27 ) by L192 , L198 , PARTFUN1:def 6;
L204: (( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , ( C90 + 1 )) ) = ( Following (( C89 +* ( Reloc (C86 , C85) ) ) , ( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , C90) )) ) & ( Exec (( CurInstr (C89 , ( Comput (C89 , C88 , C90) )) ) , ( DecIC (( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , C90) ) , C85) )) ) = ( DecIC (( Following (( C89 +* ( Reloc (C86 , C85) ) ) , ( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , C90) )) ) , C85) )) by L203 , L192 , L199 , L54 , EXTPRO_1:3;
thus L205: ( Comput (C89 , C88 , ( C90 + 1 )) ) = ( Following (C89 , ( Comput (C89 , C88 , C90) )) ) by EXTPRO_1:3
.= ( DecIC (( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , ( C90 + 1 )) ) , C85) ) by L185 , L204;
end;
L206: ( IC R5 ) in ( dom ( IncIC (C87 , C85) ) ) by MEMSTR_0:52;
L207: ( IC ( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , ( 0 )) ) ) = ( IC ( IncIC (C87 , C85) ) ) by L206 , FUNCT_4:13;
L208: ( DataPart C87 ) c= C87 by RELAT_1:59;
set D29 = ( DataPart C87 );
set D30 = ( Start-At (( ( IC C87 ) + C85 ) , R5) );
set D31 = C86;
set D32 = ( Start-At (( ( IC ( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , ( 0 )) ) ) -' C85 ) , R5) );
L209: ( dom ( Start-At (( ( IC C87 ) + C85 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
set D33 = ( Reloc (C86 , C85) );
set D34 = ( C88 | ( dom ( Reloc (C86 , C85) ) ) );
L210: { ( IC R5 ) } misses ( dom ( DataPart C87 ) ) by MEMSTR_0:4;
L211: ( dom ( Start-At (( ( IC ( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , ( 0 )) ) ) -' C85 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L212: ( dom D30 ) misses ( dom D29 ) by L210 , FUNCOP_1:13;
L213: ( D30 +* D29 ) = ( D29 +* D30 ) by L212 , FUNCT_4:35
.= ( IncIC (C87 , C85) ) by L179 , MEMSTR_0:56;
L214: ( Comput (C89 , C88 , ( 0 )) ) = ( C88 +* ( Start-At (( IC C87 ) , R5) ) ) by L181 , L180 , FUNCT_4:98 , XBOOLE_1:1
.= ( C88 +* ( Start-At (( ( ( IC C87 ) + C85 ) -' C85 ) , R5) ) ) by NAT_D:34
.= ( C88 +* D32 ) by L207 , MEMSTR_0:53
.= ( ( C88 +* D29 ) +* D32 ) by L208 , L181 , FUNCT_4:98 , XBOOLE_1:1
.= ( ( ( C88 +* D29 ) +* D30 ) +* D32 ) by L211 , L209 , FUNCT_4:74
.= ( ( C88 +* ( D29 +* D30 ) ) +* D32 ) by FUNCT_4:14
.= ( DecIC (( Comput (( C89 +* ( Reloc (C86 , C85) ) ) , ( C88 +* ( IncIC (C87 , C85) ) ) , ( 0 )) ) , C85) ) by L213 , L209 , L210 , FUNCT_4:35;
L215: S3[ ( 0 ) ] by L214;
thus L216: (for B72 being (Element of ( NAT )) holds S3[ B72 ]) from NAT_1:sch 1(L215 , L184);
end;
theorem
L217: (for R2 being  with_zero set holds (for R5 being  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2 holds (for B73 being non  halt-free  finite (the InstructionsF of R5) -valued ( NAT ) -defined Function holds (for B74 being non  empty (FinPartState of R5) holds (( IC R5 ) in ( dom B74 ) implies (for B75 being (Element of ( NAT )) holds (B74 is B73 -autonomic iff ( IncIC (B74 , B75) ) is ( Reloc (B73 , B75) ) -autonomic)))))))
proof
let R2 being  with_zero set;
let R5 being  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
let C92 being non  halt-free  finite (the InstructionsF of R5) -valued ( NAT ) -defined Function;
let C93 being non  empty (FinPartState of R5);
assume that
L218: ( IC R5 ) in ( dom C93 );
let C94 being (Element of ( NAT ));
thus L219:now
assume L220: C93 is C92 -autonomic;
thus L221: ( IncIC (C93 , C94) ) is ( Reloc (C92 , C94) ) -autonomic
proof
let C95 , C96 being (Instruction-Sequence of R5);
assume that
L222: ( Reloc (C92 , C94) ) c= C95
and
L223: ( Reloc (C92 , C94) ) c= C96;
let C97 , C98 being (State of R5);
assume that
L224: ( IncIC (C93 , C94) ) c= C97
and
L225: ( IncIC (C93 , C94) ) c= C98;
let C99 being (Element of ( NAT ));
L226: ( dom ( Start-At (( ( IC ( Comput (( C96 +* C92 ) , ( C98 +* C93 ) , C99) ) ) + C94 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L227: ( dom ( DataPart C93 ) ) misses ( dom ( Start-At (( ( IC ( Comput (( C96 +* C92 ) , ( C98 +* C93 ) , C99) ) ) + C94 ) , R5) ) ) by L226 , MEMSTR_0:4;
L228: ( dom ( Start-At (( ( IC ( Comput (( C95 +* C92 ) , ( C97 +* C93 ) , C99) ) ) + C94 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L229: ( dom ( DataPart C93 ) ) misses ( dom ( Start-At (( ( IC ( Comput (( C95 +* C92 ) , ( C97 +* C93 ) , C99) ) ) + C94 ) , R5) ) ) by L228 , MEMSTR_0:4;
L230: (C92 c= ( C95 +* C92 ) & C92 c= ( C96 +* C92 )) by FUNCT_4:25;
L231: (C93 c= ( C97 +* C93 ) & C93 c= ( C98 +* C93 )) by FUNCT_4:25;
L232: ( ( Comput (( C95 +* C92 ) , ( C97 +* C93 ) , C99) ) | ( dom C93 ) ) = ( ( Comput (( C96 +* C92 ) , ( C98 +* C93 ) , C99) ) | ( dom C93 ) ) by L231 , L220 , L230 , EXTPRO_1:def 10;
L233: ( DataPart C93 ) c= C93 by MEMSTR_0:12;
L234: ( ( Comput (C95 , C97 , C99) ) | ( dom ( DataPart C93 ) ) ) = ( ( IncIC (( Comput (( C95 +* C92 ) , ( C97 +* C93 ) , C99) ) , C94) ) | ( dom ( DataPart C93 ) ) ) by L218 , L220 , L224 , L147 , L222
.= ( ( Comput (( C95 +* C92 ) , ( C97 +* C93 ) , C99) ) | ( dom ( DataPart C93 ) ) ) by L229 , FUNCT_4:72
.= ( ( Comput (( C96 +* C92 ) , ( C98 +* C93 ) , C99) ) | ( dom ( DataPart C93 ) ) ) by L232 , L233 , RELAT_1:11 , RELAT_1:153
.= ( ( IncIC (( Comput (( C96 +* C92 ) , ( C98 +* C93 ) , C99) ) , C94) ) | ( dom ( DataPart C93 ) ) ) by L227 , FUNCT_4:72
.= ( ( Comput (C96 , C98 , C99) ) | ( dom ( DataPart C93 ) ) ) by L218 , L220 , L225 , L147 , L223;
L235: { ( IC R5 ) } c= ( dom C93 ) by L218 , ZFMISC_1:31;
L236: ( Start-At (( IC ( Comput (( C95 +* C92 ) , ( C97 +* C93 ) , C99) ) ) , R5) ) = ( ( Comput (( C95 +* C92 ) , ( C97 +* C93 ) , C99) ) | { ( IC R5 ) } ) by MEMSTR_0:18
.= ( ( Comput (( C96 +* C92 ) , ( C98 +* C93 ) , C99) ) | { ( IC R5 ) } ) by L232 , L235 , RELAT_1:153
.= ( Start-At (( IC ( Comput (( C96 +* C92 ) , ( C98 +* C93 ) , C99) ) ) , R5) ) by MEMSTR_0:18;
L237: ( dom ( Start-At (( ( IC C93 ) + C94 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L238: ( ( Comput (C95 , C97 , C99) ) | ( dom ( Start-At (( ( IC C93 ) + C94 ) , R5) ) ) ) = ( ( IncIC (( Comput (( C95 +* C92 ) , ( C97 +* C93 ) , C99) ) , C94) ) | ( dom ( Start-At (( ( IC C93 ) + C94 ) , R5) ) ) ) by L218 , L220 , L224 , L147 , L222
.= ( Start-At (( ( IC ( Comput (( C95 +* C92 ) , ( C97 +* C93 ) , C99) ) ) + C94 ) , R5) ) by L237 , L228 , FUNCT_4:23
.= ( Start-At (( ( IC ( Comput (( C96 +* C92 ) , ( C98 +* C93 ) , C99) ) ) + C94 ) , R5) ) by L236 , MEMSTR_0:21
.= ( ( IncIC (( Comput (( C96 +* C92 ) , ( C98 +* C93 ) , C99) ) , C94) ) | ( dom ( Start-At (( ( IC C93 ) + C94 ) , R5) ) ) ) by L237 , L226 , FUNCT_4:23
.= ( ( Comput (C96 , C98 , C99) ) | ( dom ( Start-At (( ( IC C93 ) + C94 ) , R5) ) ) ) by L218 , L220 , L225 , L147 , L223;
L239: ( dom ( Start-At (( ( IC C93 ) + C94 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L240: ( dom C93 ) = ( { ( IC R5 ) } \/ ( dom ( DataPart C93 ) ) ) by L218 , MEMSTR_0:24;
L241: ( ( Comput (C95 , C97 , C99) ) | ( dom C93 ) ) = ( ( ( Comput (C95 , C97 , C99) ) | { ( IC R5 ) } ) \/ ( ( Comput (C95 , C97 , C99) ) | ( dom ( DataPart C93 ) ) ) ) by L240 , RELAT_1:78
.= ( ( Comput (C96 , C98 , C99) ) | ( dom C93 ) ) by L240 , L239 , L234 , L238 , RELAT_1:78;
L242: ( dom ( IncIC (C93 , C94) ) ) = ( ( dom C93 ) \/ ( dom ( Start-At (( ( IC C93 ) + C94 ) , R5) ) ) ) by FUNCT_4:def 1;
L243: ( ( Comput (C95 , C97 , C99) ) | ( dom ( IncIC (C93 , C94) ) ) ) = ( ( ( Comput (C95 , C97 , C99) ) | ( dom C93 ) ) \/ ( ( Comput (C95 , C97 , C99) ) | ( dom ( Start-At (( ( IC C93 ) + C94 ) , R5) ) ) ) ) by L242 , RELAT_1:78
.= ( ( Comput (C96 , C98 , C99) ) | ( dom ( IncIC (C93 , C94) ) ) ) by L242 , L238 , L241 , RELAT_1:78;
thus L244: ( ( Comput (C95 , C97 , C99) ) | ( dom ( IncIC (C93 , C94) ) ) ) = ( ( Comput (C96 , C98 , C99) ) | ( dom ( IncIC (C93 , C94) ) ) ) by L243;
end;

end;
assume L222: ( IncIC (C93 , C94) ) is ( Reloc (C92 , C94) ) -autonomic;
L223: ( DataPart C93 ) c= ( IncIC (C93 , C94) ) by MEMSTR_0:62;
let C100 , C101 being (Instruction-Sequence of R5);
assume that
L224: C92 c= C100
and
L225: C92 c= C101;
L226: (( Reloc (C92 , C94) ) c= ( C100 +* ( Reloc (C92 , C94) ) ) & ( Reloc (C92 , C94) ) c= ( C101 +* ( Reloc (C92 , C94) ) )) by FUNCT_4:25;
let C102 , C103 being (State of R5);
assume that
L227: C93 c= C102
and
L228: C93 c= C103;
let C104 being (Element of ( NAT ));
L229: (( IncIC (C93 , C94) ) c= ( C102 +* ( IncIC (C93 , C94) ) ) & ( IncIC (C93 , C94) ) c= ( C103 +* ( IncIC (C93 , C94) ) )) by FUNCT_4:25;
L230: ( ( Comput (( C100 +* ( Reloc (C92 , C94) ) ) , ( C102 +* ( IncIC (C93 , C94) ) ) , C104) ) | ( dom ( IncIC (C93 , C94) ) ) ) = ( ( Comput (( C101 +* ( Reloc (C92 , C94) ) ) , ( C103 +* ( IncIC (C93 , C94) ) ) , C104) ) | ( dom ( IncIC (C93 , C94) ) ) ) by L229 , L222 , L226 , EXTPRO_1:def 10;
L231: ( dom ( Start-At (( ( IC ( Comput (( C101 +* ( Reloc (C92 , C94) ) ) , ( C103 +* ( IncIC (C93 , C94) ) ) , C104) ) ) -' C94 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L232: ( dom ( DataPart C93 ) ) misses ( dom ( Start-At (( ( IC ( Comput (( C101 +* ( Reloc (C92 , C94) ) ) , ( C103 +* ( IncIC (C93 , C94) ) ) , C104) ) ) -' C94 ) , R5) ) ) by L231 , MEMSTR_0:4;
L233: ( dom ( Start-At (( ( IC ( Comput (( C100 +* ( Reloc (C92 , C94) ) ) , ( C102 +* ( IncIC (C93 , C94) ) ) , C104) ) ) -' C94 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L234: ( dom ( DataPart C93 ) ) misses ( dom ( Start-At (( ( IC ( Comput (( C100 +* ( Reloc (C92 , C94) ) ) , ( C102 +* ( IncIC (C93 , C94) ) ) , C104) ) ) -' C94 ) , R5) ) ) by L233 , MEMSTR_0:4;
L235: ( ( Comput (C100 , C102 , C104) ) | ( dom ( DataPart C93 ) ) ) = ( ( DecIC (( Comput (( C100 +* ( Reloc (C92 , C94) ) ) , ( C102 +* ( IncIC (C93 , C94) ) ) , C104) ) , C94) ) | ( dom ( DataPart C93 ) ) ) by L218 , L222 , L227 , L178 , L224
.= ( ( Comput (( C100 +* ( Reloc (C92 , C94) ) ) , ( C102 +* ( IncIC (C93 , C94) ) ) , C104) ) | ( dom ( DataPart C93 ) ) ) by L234 , FUNCT_4:72
.= ( ( Comput (( C101 +* ( Reloc (C92 , C94) ) ) , ( C103 +* ( IncIC (C93 , C94) ) ) , C104) ) | ( dom ( DataPart C93 ) ) ) by L230 , L223 , RELAT_1:11 , RELAT_1:153
.= ( ( DecIC (( Comput (( C101 +* ( Reloc (C92 , C94) ) ) , ( C103 +* ( IncIC (C93 , C94) ) ) , C104) ) , C94) ) | ( dom ( DataPart C93 ) ) ) by L232 , FUNCT_4:72
.= ( ( Comput (C101 , C103 , C104) ) | ( dom ( DataPart C93 ) ) ) by L218 , L222 , L228 , L178 , L225;
L236: ( IC R5 ) in ( dom ( IncIC (C93 , C94) ) ) by MEMSTR_0:52;
L237: { ( IC R5 ) } c= ( dom ( IncIC (C93 , C94) ) ) by L236 , ZFMISC_1:31;
L238: ( Start-At (( IC ( Comput (( C100 +* ( Reloc (C92 , C94) ) ) , ( C102 +* ( IncIC (C93 , C94) ) ) , C104) ) ) , R5) ) = ( ( Comput (( C100 +* ( Reloc (C92 , C94) ) ) , ( C102 +* ( IncIC (C93 , C94) ) ) , C104) ) | { ( IC R5 ) } ) by MEMSTR_0:18
.= ( ( Comput (( C101 +* ( Reloc (C92 , C94) ) ) , ( C103 +* ( IncIC (C93 , C94) ) ) , C104) ) | { ( IC R5 ) } ) by L230 , L237 , RELAT_1:153
.= ( Start-At (( IC ( Comput (( C101 +* ( Reloc (C92 , C94) ) ) , ( C103 +* ( IncIC (C93 , C94) ) ) , C104) ) ) , R5) ) by MEMSTR_0:18;
L239: ( dom ( Start-At (( IC C93 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L240: ( ( Comput (C100 , C102 , C104) ) | ( dom ( Start-At (( IC C93 ) , R5) ) ) ) = ( ( DecIC (( Comput (( C100 +* ( Reloc (C92 , C94) ) ) , ( C102 +* ( IncIC (C93 , C94) ) ) , C104) ) , C94) ) | ( dom ( Start-At (( IC C93 ) , R5) ) ) ) by L218 , L222 , L227 , L178 , L224
.= ( Start-At (( ( IC ( Comput (( C100 +* ( Reloc (C92 , C94) ) ) , ( C102 +* ( IncIC (C93 , C94) ) ) , C104) ) ) -' C94 ) , R5) ) by L239 , L233 , FUNCT_4:23
.= ( Start-At (( ( IC ( Comput (( C101 +* ( Reloc (C92 , C94) ) ) , ( C103 +* ( IncIC (C93 , C94) ) ) , C104) ) ) -' C94 ) , R5) ) by L238 , MEMSTR_0:22
.= ( ( DecIC (( Comput (( C101 +* ( Reloc (C92 , C94) ) ) , ( C103 +* ( IncIC (C93 , C94) ) ) , C104) ) , C94) ) | ( dom ( Start-At (( IC C93 ) , R5) ) ) ) by L239 , L231 , FUNCT_4:23
.= ( ( Comput (C101 , C103 , C104) ) | ( dom ( Start-At (( IC C93 ) , R5) ) ) ) by L218 , L222 , L228 , L178 , L225;
thus L241: ( ( Comput (C100 , C102 , C104) ) | ( dom C93 ) ) = ( ( Comput (C100 , C102 , C104) ) | ( dom ( ( Start-At (( IC C93 ) , R5) ) +* ( DataPart C93 ) ) ) ) by L218 , MEMSTR_0:19
.= ( ( Comput (C100 , C102 , C104) ) | ( ( dom ( Start-At (( IC C93 ) , R5) ) ) \/ ( dom ( DataPart C93 ) ) ) ) by FUNCT_4:def 1
.= ( ( ( Comput (C101 , C103 , C104) ) | ( dom ( Start-At (( IC C93 ) , R5) ) ) ) \/ ( ( Comput (C101 , C103 , C104) ) | ( dom ( DataPart C93 ) ) ) ) by L235 , L240 , RELAT_1:78
.= ( ( Comput (C101 , C103 , C104) ) | ( ( dom ( Start-At (( IC C93 ) , R5) ) ) \/ ( dom ( DataPart C93 ) ) ) ) by RELAT_1:78
.= ( ( Comput (C101 , C103 , C104) ) | ( dom ( ( Start-At (( IC C93 ) , R5) ) +* ( DataPart C93 ) ) ) ) by FUNCT_4:def 1
.= ( ( Comput (C101 , C103 , C104) ) | ( dom C93 ) ) by L218 , MEMSTR_0:19;
end;
definition
let R2 being  with_zero set;
let R5 being  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
attr R5 is  relocable1
means
:L242: (for B76 being (Element of ( NAT )) holds (for B77 being non  halt-free  finite (the InstructionsF of R5) -valued ( NAT ) -defined Function holds (for B78 being B77 -autonomic non  empty (FinPartState of R5) holds (for B79 , B80 being (State of R5) holds ((B78 c= B79 & ( IncIC (B78 , B76) ) c= B80) implies (for B81 , B82 being (Instruction-Sequence of R5) holds ((B77 c= B81 & ( Reloc (B77 , B76) ) c= B82) implies (for B83 being (Element of ( NAT )) holds ( IncAddr (( CurInstr (B81 , ( Comput (B81 , B79 , B83) )) ) , B76) ) = ( CurInstr (B82 , ( Comput (B82 , B80 , B83) )) )))))))));
attr R5 is  relocable2
means
:L243: (for B84 being (Element of ( NAT )) holds (for B85 being non  halt-free  finite (the InstructionsF of R5) -valued ( NAT ) -defined Function holds (for B86 being B85 -autonomic non  empty (FinPartState of R5) holds (for B87 , B88 being (State of R5) holds ((B86 c= B87 & ( IncIC (B86 , B84) ) c= B88) implies (for B89 , B90 being (Instruction-Sequence of R5) holds ((B85 c= B89 & ( Reloc (B85 , B84) ) c= B90) implies (for B91 being (Element of ( NAT )) holds ( ( Comput (B89 , B87 , B91) ) | ( dom ( DataPart B86 ) ) ) = ( ( Comput (B90 , B88 , B91) ) | ( dom ( DataPart B86 ) ) )))))))));
end;
L245: (for R2 being  with_zero set holds (for B92 being (Element of ( NAT )) holds (for B93 being non  halt-free  finite (the InstructionsF of ( STC R2 )) -valued ( NAT ) -defined Function holds (for B94 being non  empty B93 -autonomic (FinPartState of ( STC R2 )) holds (for B95 , B96 being (State of ( STC R2 )) holds ((B94 c= B95 & ( IncIC (B94 , B92) ) c= B96) implies (for B97 , B98 being (Instruction-Sequence of ( STC R2 )) holds ((B93 c= B97 & ( Reloc (B93 , B92) ) c= B98) implies (for B99 being (Element of ( NAT )) holds (( ( IC ( Comput (B97 , B95 , B99) ) ) + B92 ) = ( IC ( Comput (B98 , B96 , B99) ) ) & ( IncAddr (( CurInstr (B97 , ( Comput (B97 , B95 , B99) )) ) , B92) ) = ( CurInstr (B98 , ( Comput (B98 , B96 , B99) )) )))))))))))
proof
let R2 being  with_zero set;
let C105 being (Element of ( NAT ));
let C106 being non  halt-free  finite (the InstructionsF of ( STC R2 )) -valued ( NAT ) -defined Function;
let C107 being non  empty C106 -autonomic (FinPartState of ( STC R2 ));
let C108 , C109 being (State of ( STC R2 ));
assume that
L246: C107 c= C108
and
L247: ( IncIC (C107 , C105) ) c= C109;
L248: ( IC ( STC R2 ) ) in ( dom C107 ) by L60;
let C110 , C111 being (Instruction-Sequence of ( STC R2 ));
assume that
L249: (C106 c= C110 & ( Reloc (C106 , C105) ) c= C111);
set D35 = ( C108 +* ( DataPart C109 ) );
defpred S4[ (Element of ( NAT )) ] means (( ( IC ( Comput (C110 , C108 , $1) ) ) + C105 ) = ( IC ( Comput (C111 , C109 , $1) ) ) & ( IncAddr (( CurInstr (C110 , ( Comput (C110 , C108 , $1) )) ) , C105) ) = ( CurInstr (C111 , ( Comput (C111 , C109 , $1) )) ));
L250: (for B100 being (Element of ( NAT )) holds (S4[ B100 ] implies S4[ ( B100 + 1 ) ]))
proof
set D36 = ( DataPart C107 );
let C112 being (Element of ( NAT ));
assume that
L251: ( ( IC ( Comput (C110 , C108 , C112) ) ) + C105 ) = ( IC ( Comput (C111 , C109 , C112) ) )
and
L252: ( IncAddr (( CurInstr (C110 , ( Comput (C110 , C108 , C112) )) ) , C105) ) = ( CurInstr (C111 , ( Comput (C111 , C109 , C112) )) );
set D37 = ( Comput (C111 , C109 , ( C112 + 1 )) );
set D38 = ( Comput (C110 , D35 , C112) );
set D39 = ( Comput (C111 , C109 , C112) );
set D40 = ( Comput (C110 , D35 , ( C112 + 1 )) );
set D41 = ( Comput (C110 , C108 , ( C112 + 1 )) );
set D42 = ( Comput (C110 , C108 , C112) );
L253:
now
reconsider D43 = ( IC D41 ) as (Element of ( NAT ));
assume L254: ( ( IC ( Comput (C110 , C108 , ( C112 + 1 )) ) ) + C105 ) = ( IC ( Comput (C111 , C109 , ( C112 + 1 )) ) );
reconsider D44 = D43 as (Element of ( NAT ));
L255: D43 in ( dom C106 ) by L69 , L249 , L246;
L256: ( D43 + C105 ) in ( dom ( Reloc (C106 , C105) ) ) by L255 , COMPOS_1:46;
L257: ( dom C111 ) = ( NAT ) by PARTFUN1:def 2;
L258: ( dom C110 ) = ( NAT ) by PARTFUN1:def 2;
L259: ( CurInstr (C110 , D41) ) = ( C110 . D43 ) by L258 , PARTFUN1:def 6
.= ( C106 . D43 ) by L255 , L249 , GRFUNC_1:2;
thus L260: ( IncAddr (( CurInstr (C110 , ( Comput (C110 , C108 , ( C112 + 1 )) )) ) , C105) ) = ( ( Reloc (C106 , C105) ) . ( D43 + C105 ) ) by L259 , L255 , COMPOS_1:35
.= ( C111 . ( IC ( Comput (C111 , C109 , ( C112 + 1 )) ) ) ) by L254 , L256 , L249 , GRFUNC_1:2
.= ( CurInstr (C111 , ( Comput (C111 , C109 , ( C112 + 1 )) )) ) by L257 , PARTFUN1:def 6;
end;
set D45 = ( CurInstr (C110 , D42) );
L261: D37 = ( Following (C111 , D39) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C111 , D39) ) , D39) );
reconsider D46 = ( IC D42 ) as (Element of ( NAT ));
L262: D41 = ( Following (C110 , D42) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C110 , D42) ) , D42) );
L263: (the InstructionsF of ( STC R2 )) = { [ ( 0 ) , ( 0 ) , ( 0 ) ] , [ 1 , ( 0 ) , ( 0 ) ] } by AMISTD_1:def 7;
per cases  by L263 , TARSKI:def 2;
suppose L264: D45 = [ ( 0 ) , ( 0 ) , ( 0 ) ];

L265: D45 = ( halt ( STC R2 ) ) by L264;
thus L266: ( ( IC ( Comput (C110 , C108 , ( C112 + 1 )) ) ) + C105 ) = ( ( IC D42 ) + C105 ) by L262 , L265 , EXTPRO_1:def 3
.= ( IC ( Comput (C111 , C109 , ( C112 + 1 )) ) ) by L251 , L261 , L265 , L252 , EXTPRO_1:def 3;
thus L267: ( IncAddr (( CurInstr (C110 , ( Comput (C110 , C108 , ( C112 + 1 )) )) ) , C105) ) = ( CurInstr (C111 , ( Comput (C111 , C109 , ( C112 + 1 )) )) ) by L266 , L253;
end;
suppose L268: D45 = [ 1 , ( 0 ) , ( 0 ) ];

L269: ( InsCode D45 ) = 1 by L268 , RECDEF_2:def 1;
L270: ( Exec (D45 , D39) ) = ( IncIC (D39 , 1) ) by L269 , AMISTD_1:20;
thus L271: ( ( IC ( Comput (C110 , C108 , ( C112 + 1 )) ) ) + C105 ) = ( ( succ ( IC D42 ) ) + C105 ) by L262 , L269 , AMISTD_1:9
.= ( IC ( Exec (D45 , D39) ) ) by L270 , L251 , MEMSTR_0:53
.= ( IC ( Comput (C111 , C109 , ( C112 + 1 )) ) ) by L261 , L252 , COMPOS_0:4;
thus L272: ( IncAddr (( CurInstr (C110 , ( Comput (C110 , C108 , ( C112 + 1 )) )) ) , C105) ) = ( CurInstr (C111 , ( Comput (C111 , C109 , ( C112 + 1 )) )) ) by L271 , L253;
end;
end;
L274: ( IC ( STC R2 ) ) in ( dom ( IncIC (C107 , C105) ) ) by MEMSTR_0:52;
L275:
now
thus L276: ( ( IC ( Comput (C110 , C108 , ( 0 )) ) ) + C105 ) = ( ( IC C107 ) + C105 ) by L246 , L248 , GRFUNC_1:2
.= ( IC ( IncIC (C107 , C105) ) ) by MEMSTR_0:53
.= ( IC ( Comput (C111 , C109 , ( 0 )) ) ) by L247 , L274 , GRFUNC_1:2;
reconsider D47 = ( IC C107 ) as (Element of ( NAT ));
L277: ( IC C107 ) = ( IC C108 ) by L246 , L248 , GRFUNC_1:2;
L278: ( IC C107 ) = ( IC ( Comput (C110 , C108 , ( 0 )) ) ) by L246 , L248 , GRFUNC_1:2;
L279: D47 in ( dom C106 ) by L278 , L69 , L249 , L246;
L280: ( ( IC C107 ) + C105 ) in ( dom ( Reloc (C106 , C105) ) ) by L279 , COMPOS_1:46;
L281: ( IC ( STC R2 ) ) in ( dom ( IncIC (C107 , C105) ) ) by MEMSTR_0:52;
L282: ( C106 . ( IC C107 ) ) = ( C110 . ( IC C108 ) ) by L277 , L279 , L249 , GRFUNC_1:2;
L283: ( dom C111 ) = ( NAT ) by PARTFUN1:def 2;
L284: ( CurInstr (C111 , ( Comput (C111 , C109 , ( 0 )) )) ) = ( C111 . ( IC ( Comput (C111 , C109 , ( 0 )) ) ) ) by L283 , PARTFUN1:def 6
.= ( C111 . ( IC ( IncIC (C107 , C105) ) ) ) by L247 , L281 , GRFUNC_1:2
.= ( C111 . ( ( IC C107 ) + C105 ) ) by MEMSTR_0:53
.= ( ( Reloc (C106 , C105) ) . ( ( IC C107 ) + C105 ) ) by L280 , L249 , GRFUNC_1:2;
L285: ( dom C110 ) = ( NAT ) by PARTFUN1:def 2;
L286: ( CurInstr (C110 , ( Comput (C110 , C108 , ( 0 )) )) ) = ( C110 . ( IC C108 ) ) by L285 , PARTFUN1:def 6;
thus L287: ( IncAddr (( CurInstr (C110 , ( Comput (C110 , C108 , ( 0 )) )) ) , C105) ) = ( CurInstr (C111 , ( Comput (C111 , C109 , ( 0 )) )) ) by L286 , L284 , L279 , L282 , COMPOS_1:35;
end;
L288: S4[ ( 0 ) ] by L275;
thus L289: (for B101 being (Element of ( NAT )) holds S4[ B101 ]) from NAT_1:sch 1(L288 , L250);
end;
registration
let R2 being  with_zero set;
cluster ( STC R2 ) ->  relocable1  relocable2;
coherence
proof
thus L290: (for B102 being (Element of ( NAT )) holds (for B103 being non  halt-free  finite (the InstructionsF of ( STC R2 )) -valued ( NAT ) -defined Function holds (for B104 being B103 -autonomic non  empty (FinPartState of ( STC R2 )) holds (for B105 , B106 being (State of ( STC R2 )) holds ((B104 c= B105 & ( IncIC (B104 , B102) ) c= B106) implies (for B107 , B108 being (Instruction-Sequence of ( STC R2 )) holds ((B103 c= B107 & ( Reloc (B103 , B102) ) c= B108) implies (for B109 being (Element of ( NAT )) holds ( IncAddr (( CurInstr (B107 , ( Comput (B107 , B105 , B109) )) ) , B102) ) = ( CurInstr (B108 , ( Comput (B108 , B106 , B109) )) ))))))))) by L245;
let C113 being (Element of ( NAT ));
let C114 being non  halt-free  finite (the InstructionsF of ( STC R2 )) -valued ( NAT ) -defined Function;
let C115 being C114 -autonomic non  empty (FinPartState of ( STC R2 ));
let C116 , C117 being (State of ( STC R2 ));
assume that
L291: C115 c= C116
and
L292: ( IncIC (C115 , C113) ) c= C117;
let C118 , C119 being (Instruction-Sequence of ( STC R2 ));
assume that
L293: C114 c= C118
and
L294: ( Reloc (C114 , C113) ) c= C119;
let C120 being (Element of ( NAT ));
thus L295: ( ( Comput (C118 , C116 , C120) ) | ( dom ( DataPart C115 ) ) ) = ( ( Comput (C119 , C117 , C120) ) | ( dom ( DataPart C115 ) ) );
end;
end;
registration
let C121 being  with_zero set;
cluster  relocable1  relocable2 for  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C121;
existence
proof
take ( STC C121 );
thus L297: thesis;
end;
end;
theorem
L299: (for R2 being  with_zero set holds (for R8 being  relocable1  relocable2  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2 holds (for B110 being non  halt-free  finite (the InstructionsF of R8) -valued ( NAT ) -defined Function holds (for B111 being B110 -autonomic non  empty (FinPartState of R8) holds (for B112 being (Element of ( NAT )) holds (( IC R8 ) in ( dom B111 ) implies (B111 is B110 -halted iff ( IncIC (B111 , B112) ) is ( Reloc (B110 , B112) ) -halted)))))))
proof
let R2 being  with_zero set;
let R8 being  relocable1  relocable2  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
let C122 being non  halt-free  finite (the InstructionsF of R8) -valued ( NAT ) -defined Function;
let C123 being C122 -autonomic non  empty (FinPartState of R8);
let C124 being (Element of ( NAT ));
assume L300: ( IC R8 ) in ( dom C123 );
thus L301:now
assume L302: C123 is C122 -halted;
thus L303: ( IncIC (C123 , C124) ) is ( Reloc (C122 , C124) ) -halted
proof
let C125 being (State of R8);
assume L304: ( IncIC (C123 , C124) ) c= C125;
let C126 being (Instruction-Sequence of R8);
assume that
L305: ( Reloc (C122 , C124) ) c= C126;
reconsider D48 = ( C126 +* C122 ) as (Instruction-Sequence of R8);
set D49 = ( C125 +* C123 );
L306: C122 c= D48 by FUNCT_4:25;
L307: C123 c= ( C125 +* C123 ) by FUNCT_4:25;
L308: D48 halts_on D49 by L307 , L302 , L306 , EXTPRO_1:def 11;
consider C127 being (Element of ( NAT )) such that L309: ( CurInstr (D48 , ( Comput (D48 , D49 , C127) )) ) = ( halt R8 ) by L308 , EXTPRO_1:29;
take C127;
L310: ( dom C126 ) = ( NAT ) by PARTFUN1:def 2;
thus L311: ( IC ( Comput (C126 , C125 , C127) ) ) in ( dom C126 ) by L310;
L312: ( CurInstr (C126 , ( Comput (C126 , C125 , C127) )) ) = ( IncAddr (( halt R8 ) , C124) ) by L304 , L309 , L242 , L305 , L306 , L307
.= ( halt R8 ) by COMPOS_0:4;
thus L313: thesis by L312;
end;

end;
assume L304: ( IncIC (C123 , C124) ) is ( Reloc (C122 , C124) ) -halted;
let C128 being (State of R8);
assume L305: C123 c= C128;
let C129 being (Instruction-Sequence of R8);
assume that
L306: C122 c= C129;
reconsider D50 = ( C129 +* ( Reloc (C122 , C124) ) ) as (Instruction-Sequence of R8);
set D51 = ( C128 +* ( IncIC (C123 , C124) ) );
L307: ( Reloc (C122 , C124) ) c= D50 by FUNCT_4:25;
L308: ( IncIC (C123 , C124) ) c= ( C128 +* ( IncIC (C123 , C124) ) ) by FUNCT_4:25;
L309: D50 halts_on D51 by L308 , L304 , L307 , EXTPRO_1:def 11;
consider C130 being (Element of ( NAT )) such that L310: ( CurInstr (D50 , ( Comput (D50 , D51 , C130) )) ) = ( halt R8 ) by L309 , EXTPRO_1:29;
take C130;
L311: ( dom C129 ) = ( NAT ) by PARTFUN1:def 2;
thus L312: ( IC ( Comput (C129 , C128 , C130) ) ) in ( dom C129 ) by L311;
L313: ( IncAddr (( CurInstr (C129 , ( Comput (C129 , C128 , C130) )) ) , C124) ) = ( halt R8 ) by L305 , L310 , L242 , L308 , L306 , L307
.= ( IncAddr (( halt R8 ) , C124) ) by COMPOS_0:4;
thus L314: ( CurInstr (C129 , ( Comput (C129 , C128 , C130) )) ) = ( halt R8 ) by L313 , COMPOS_0:6;
end;
theorem
L315: (for R2 being  with_zero set holds (for R8 being  relocable1  relocable2  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2 holds (for B113 being non  halt-free  finite (the InstructionsF of R8) -valued ( NAT ) -defined Function holds (for B114 being B113 -halted B113 -autonomic non  empty (FinPartState of R8) holds (( IC R8 ) in ( dom B114 ) implies (for B115 being (Element of ( NAT )) holds ( DataPart ( Result (B113 , B114) ) ) = ( DataPart ( Result (( Reloc (B113 , B115) ) , ( IncIC (B114 , B115) )) ) )))))))
proof
let R2 being  with_zero set;
let R8 being  relocable1  relocable2  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
let C131 being non  halt-free  finite (the InstructionsF of R8) -valued ( NAT ) -defined Function;
let C132 being C131 -halted C131 -autonomic non  empty (FinPartState of R8);
assume that
L316: ( IC R8 ) in ( dom C132 );
let C133 being (Element of ( NAT ));
consider C134 being (State of R8) such that L317: C132 c= C134 by PBOOLE:141;
consider C135 being (Instruction-Sequence of R8) such that L318: C131 c= C135 by PBOOLE:145;
L319: ( IncIC (C132 , C133) ) is ( Reloc (C131 , C133) ) -halted ( Reloc (C131 , C133) ) -autonomic by L316 , L299 , L217;
L320: ( IncIC (C132 , C133) ) is (Autonomy of ( Reloc (C131 , C133) )) by L319 , EXTPRO_1:def 12;
L321: C135 halts_on C134 by L317 , L318 , EXTPRO_1:def 11;
consider C136 being (Element of ( NAT )) such that L322: ( Result (C135 , C134) ) = ( Comput (C135 , C134 , C136) ) and L323: ( CurInstr (C135 , ( Result (C135 , C134) )) ) = ( halt R8 ) by L321 , EXTPRO_1:def 9;
consider C137 being (State of R8) such that L324: ( IncIC (C132 , C133) ) c= C137 by PBOOLE:141;
consider C138 being (Instruction-Sequence of R8) such that L325: ( Reloc (C131 , C133) ) c= C138 by PBOOLE:145;
L326: ( C138 . ( IC ( Comput (C138 , C137 , C136) ) ) ) = ( CurInstr (C138 , ( Comput (C138 , C137 , C136) )) ) by PBOOLE:143
.= ( IncAddr (( CurInstr (C135 , ( Comput (C135 , C134 , C136) )) ) , C133) ) by L242 , L318 , L325 , L317 , L324
.= ( halt R8 ) by L322 , L323 , COMPOS_0:4;
L327: ( Result (C138 , C137) ) = ( Comput (C138 , C137 , C136) ) by L326 , EXTPRO_1:7;
L328: ( ( Comput (C138 , C137 , C136) ) | ( dom ( DataPart C132 ) ) ) = ( ( Comput (C135 , C134 , C136) ) | ( dom ( DataPart C132 ) ) ) by L243 , L325 , L318 , L324 , L317;
L329: ( DataPart C132 ) = ( DataPart ( IncIC (C132 , C133) ) ) by MEMSTR_0:51;
L330: C132 is (Autonomy of C131) by EXTPRO_1:def 12;
thus L331: ( DataPart ( Result (C131 , C132) ) ) = ( DataPart ( ( Result (C135 , C134) ) | ( dom C132 ) ) ) by L317 , L318 , L330 , EXTPRO_1:def 13
.= ( ( Result (C135 , C134) ) | ( ( dom C132 ) /\ ( Data-Locations R8 ) ) ) by RELAT_1:71
.= ( ( Result (C135 , C134) ) | ( dom ( DataPart C132 ) ) ) by MEMSTR_0:14
.= ( ( Result (C138 , C137) ) | ( ( dom ( IncIC (C132 , C133) ) ) /\ ( Data-Locations R8 ) ) ) by L322 , L327 , L328 , L329 , MEMSTR_0:14
.= ( ( ( Result (C138 , C137) ) | ( dom ( IncIC (C132 , C133) ) ) ) | ( Data-Locations R8 ) ) by RELAT_1:71
.= ( DataPart ( Result (( Reloc (C131 , C133) ) , ( IncIC (C132 , C133) )) ) ) by L320 , L325 , L324 , EXTPRO_1:def 13;
end;
registration
let R2 being  with_zero set;
let R8 being  relocable1  relocable2  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
let C139 being non  halt-free  finite (the InstructionsF of R8) -valued ( NAT ) -defined Function;
let C140 being C139 -autonomic C139 -halted non  empty (FinPartState of R8);
let C141 being (Element of ( NAT ));
cluster ( IncIC (C140 , C141) ) -> ( Reloc (C139 , C141) ) -halted;
coherence
proof
L332: ( IC R8 ) in ( dom C140 ) by L60;
thus L333: thesis by L332 , L299;
end;
end;
theorem
L335: (for R2 being  with_zero set holds (for R8 being  relocable1  relocable2  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2 holds (for B116 being  data-only (PartFunc of ( FinPartSt R8 ) , ( FinPartSt R8 )) holds (for B117 being (Element of ( NAT )) holds (for B118 being non  halt-free  finite (the InstructionsF of R8) -valued ( NAT ) -defined Function holds (for B119 being B118 -autonomic B118 -halted non  empty (FinPartState of R8) holds (( IC R8 ) in ( dom B119 ) implies (for B120 being (Element of ( NAT )) holds (B118 , B119 computes B116 iff ( Reloc (B118 , B120) ) , ( IncIC (B119 , B120) ) computes B116)))))))))
proof
let R2 being  with_zero set;
let R8 being  relocable1  relocable2  relocable  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
let C142 being  data-only (PartFunc of ( FinPartSt R8 ) , ( FinPartSt R8 ));
let C143 being (Element of ( NAT ));
let C144 being non  halt-free  finite (the InstructionsF of R8) -valued ( NAT ) -defined Function;
let C145 being C144 -autonomic C144 -halted non  empty (FinPartState of R8);
assume that
L336: ( IC R8 ) in ( dom C145 );
let C146 being (Element of ( NAT ));
thus L337:now
assume L338: C144 , C145 computes C142;
thus L339: ( Reloc (C144 , C146) ) , ( IncIC (C145 , C146) ) computes C142
proof
let C147 being set;
assume L340: C147 in ( dom C142 );
consider C148 being (FinPartState of R8) such that L341: C147 = C148 and L342: ( C145 +* C148 ) is (Autonomy of C144) and L343: ( C142 . C148 ) c= ( Result (C144 , ( C145 +* C148 )) ) by L340 , L338 , EXTPRO_1:def 14;
L344: ( dom C142 ) c= ( FinPartSt R8 ) by RELAT_1:def 18;
reconsider D52 = C147 as (FinPartState of R8) by L344 , L340 , MEMSTR_0:76;
reconsider D53 = D52 as  data-only (FinPartState of R8) by L340 , MEMSTR_0:def 17;
L345: ( dom ( C145 +* D53 ) ) = ( ( dom C145 ) \/ ( dom D53 ) ) by FUNCT_4:def 1;
L346: ( IC R8 ) in ( dom ( C145 +* D53 ) ) by L345 , L336 , XBOOLE_0:def 3;
L347: ( C145 +* D53 ) is C144 -autonomic by L341 , L342 , EXTPRO_1:def 12;
L348: ( IncIC (( C145 +* D53 ) , C146) ) is ( Reloc (C144 , C146) ) -autonomic by L347 , L346 , L217;
L349: ( C145 +* D53 ) is C144 -halted by L341 , L342 , EXTPRO_1:def 12;
reconsider D54 = ( C145 +* D53 ) as C144 -halted C144 -autonomic non  empty (FinPartState of R8) by L341 , L342 , EXTPRO_1:def 12;
L350: ( DataPart ( Result (C144 , D54) ) ) = ( DataPart ( Result (( Reloc (C144 , C146) ) , ( IncIC (( C145 +* D53 ) , C146) )) ) ) by L346 , L315
.= ( DataPart ( Result (( Reloc (C144 , C146) ) , ( ( IncIC (C145 , C146) ) +* D53 )) ) ) by MEMSTR_0:54;
reconsider D55 = ( C142 . C148 ) as (FinPartState of R8) by L343;
take D53;
thus L351: C147 = D53;
L352: ( ( IncIC (C145 , C146) ) +* D53 ) = ( IncIC (( C145 +* D53 ) , C146) ) by MEMSTR_0:54;
thus L353: ( ( IncIC (C145 , C146) ) +* D53 ) is (Autonomy of ( Reloc (C144 , C146) )) by L352 , L347 , L349 , L348 , EXTPRO_1:def 12;
L354: D55 is  data-only by L340 , L341 , MEMSTR_0:def 17;
L355: ( C142 . C148 ) c= ( DataPart ( Result (( Reloc (C144 , C146) ) , ( ( IncIC (C145 , C146) ) +* D53 )) ) ) by L343 , L354 , L341 , L350 , MEMSTR_0:5;
thus L356: ( C142 . D53 ) c= ( Result (( Reloc (C144 , C146) ) , ( ( IncIC (C145 , C146) ) +* D53 )) ) by L355 , L341 , L354 , MEMSTR_0:5;
end;

end;
assume L340: ( Reloc (C144 , C146) ) , ( IncIC (C145 , C146) ) computes C142;
let C149 being set;
assume L341: C149 in ( dom C142 );
consider C150 being (FinPartState of R8) such that L342: C149 = C150 and L343: ( ( IncIC (C145 , C146) ) +* C150 ) is (Autonomy of ( Reloc (C144 , C146) )) and L344: ( C142 . C150 ) c= ( Result (( Reloc (C144 , C146) ) , ( ( IncIC (C145 , C146) ) +* C150 )) ) by L341 , L340 , EXTPRO_1:def 14;
L345: ( dom C142 ) c= ( FinPartSt R8 ) by RELAT_1:def 18;
reconsider D56 = C149 as (FinPartState of R8) by L345 , L341 , MEMSTR_0:76;
reconsider D57 = D56 as  data-only (FinPartState of R8) by L341 , MEMSTR_0:def 17;
L346: ( dom ( C145 +* D57 ) ) = ( ( dom C145 ) \/ ( dom D57 ) ) by FUNCT_4:def 1;
L347: ( IC R8 ) in ( dom ( C145 +* D57 ) ) by L346 , L336 , XBOOLE_0:def 3;
L348: ( ( IncIC (C145 , C146) ) +* D57 ) = ( IncIC (( C145 +* D57 ) , C146) ) by MEMSTR_0:54;
L349: ( IncIC (( C145 +* D57 ) , C146) ) is ( Reloc (C144 , C146) ) -autonomic by L342 , L343 , L348 , EXTPRO_1:def 12;
L350: ( C145 +* D57 ) is C144 -autonomic by L349 , L347 , L217;
L351: ( IncIC (( C145 +* D57 ) , C146) ) is ( Reloc (C144 , C146) ) -halted by L342 , L343 , L348 , EXTPRO_1:def 12;
L352: ( C145 +* D57 ) is C144 -halted by L347 , L299 , L350 , L351;
reconsider D58 = ( C145 +* D57 ) as C144 -halted C144 -autonomic non  empty (FinPartState of R8) by L347 , L299 , L350 , L351;
L353: ( IC R8 ) in ( dom D58 ) by L346 , L336 , XBOOLE_0:def 3;
L354: ( DataPart ( Result (( Reloc (C144 , C146) ) , ( ( IncIC (C145 , C146) ) +* C150 )) ) ) = ( DataPart ( Result (( Reloc (C144 , C146) ) , ( IncIC (( C145 +* D57 ) , C146) )) ) ) by L342 , MEMSTR_0:54
.= ( DataPart ( Result (C144 , ( C145 +* D57 )) ) ) by L315 , L353;
take D57;
thus L355: C149 = D57;
thus L356: ( C145 +* D57 ) is (Autonomy of C144) by L350 , L352 , EXTPRO_1:def 12;
reconsider D59 = ( C142 . C150 ) as (FinPartState of R8) by L344;
L357: D59 is  data-only by L341 , L342 , MEMSTR_0:def 17;
L358: ( C142 . C150 ) c= ( DataPart ( Result (C144 , ( C145 +* D57 )) ) ) by L357 , L354 , L344 , MEMSTR_0:5;
thus L359: thesis by L358 , L342 , L357 , MEMSTR_0:5;
end;
theorem
L360: (for R2 being  with_zero set holds (for R9 being  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2 holds (for B121 being non  halt-free  finite (the InstructionsF of R9) -valued ( NAT ) -defined Function holds (for B122 being B121 -autonomic (FinPartState of R9) holds (( IC R9 ) in ( dom B122 ) implies ( IC B122 ) in ( dom B121 ))))))
proof
let R2 being  with_zero set;
let R9 being  IC-recognized  CurIns-recognized  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
let C151 being non  halt-free  finite (the InstructionsF of R9) -valued ( NAT ) -defined Function;
let C152 being C151 -autonomic (FinPartState of R9);
assume L361: ( IC R9 ) in ( dom C152 );
L362: C152 is non  empty by L361;
consider C153 being (State of R9) such that L363: C152 c= C153 by PBOOLE:141;
set D60 = ( the (Instruction-Sequence of R9) +* C151 );
L364: C151 c= D60 by FUNCT_4:25;
L365: ( IC ( Comput (D60 , C153 , ( 0 )) ) ) in ( dom C151 ) by L364 , L69 , L362 , L363;
thus L366: ( IC C152 ) in ( dom C151 ) by L365 , L363 , L361 , GRFUNC_1:2;
end;
definition
let C154 being  with_zero set;
let C155 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C154;
let C156 being Nat;
let C157 being ( NAT ) -defined (the InstructionsF of C155) -valued Function;
attr C157 is C156 -halting
means
:L367: (for B123 being C156 -started (State of C155) holds (for B124 being (Instruction-Sequence of C155) holds (C157 c= B124 implies B124 halts_on B123)));
end;
registration
let C158 being  with_zero set;
let C159 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C158;
cluster  parahalting -> ( 0 ) -halting for ( NAT ) -defined (the InstructionsF of C159) -valued ( NAT ) -defined (the InstructionsF of C159) -valued ( NAT ) -defined (the InstructionsF of C159) -valued ( NAT ) -defined (the InstructionsF of C159) -valued Function;
coherence
proof
let C160 being ( NAT ) -defined (the InstructionsF of C159) -valued Function;
assume that
L369: C160 is  parahalting;
let C161 being ( 0 ) -started (State of C159);
thus L370: thesis by L369 , AMISTD_1:def 11;
end;
cluster ( 0 ) -halting ->  parahalting for ( NAT ) -defined (the InstructionsF of C159) -valued ( NAT ) -defined (the InstructionsF of C159) -valued ( NAT ) -defined (the InstructionsF of C159) -valued ( NAT ) -defined (the InstructionsF of C159) -valued Function;
coherence
proof
let C162 being ( NAT ) -defined (the InstructionsF of C159) -valued Function;
assume that
L371: C162 is ( 0 ) -halting;
let C163 being ( 0 ) -started (State of C159);
thus L372: thesis by L371 , L367;
end;
end;
