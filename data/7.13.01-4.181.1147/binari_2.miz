:: Binary Arithmetics. Addition and Subtraction of Integers
::  by Yasuho Mizuhara and Takaya Nishiyama
::
:: Received March 18, 1994
:: Copyright (c) 1994-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, NAT_1, XBOOLE_0, FINSEQ_2, MARGREL1, SUBSET_1, FINSEQ_1,
      PARTFUN1, RELAT_1, FUNCT_1, FUNCOP_1, XBOOLEAN, ARYTM_3, INT_1, BINARITH,
      ARYTM_1, POWER, ORDINAL4, CARD_1, TARSKI, BINOP_2, SETWISEO, BINARI_2;
 notations TARSKI, XBOOLE_0, SUBSET_1, XCMPLX_0, NUMBERS, FUNCT_1, ORDINAL1,
      NAT_1, NAT_D, INT_1, PARTFUN1, BINOP_1, SETWOP_2, SERIES_1, FUNCOP_1,
      FINSEQ_1, FINSEQ_2, FINSEQ_4, BINOP_2, XBOOLEAN, MARGREL1, BINARITH;
 constructors PARTFUN1, BINOP_1, SETWISEO, XXREAL_0, NAT_1, INT_1, FINSEQ_4,
      FINSOP_1, SERIES_1, BINARITH, BINOP_2, NAT_D, RELSET_1;
 registrations ORDINAL1, RELSET_1, XREAL_0, NAT_1, INT_1, BINOP_2, XBOOLEAN,
      MARGREL1, XBOOLE_0, FINSEQ_2, CARD_1, FINSEQ_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions XBOOLEAN;
 theorems BINARITH, FINSEQ_1, FINSEQ_2, FINSEQ_4, FUNCOP_1, POWER, NAT_1,
      FINSOP_1, BINOP_2, XBOOLEAN, PARTFUN1, XREAL_0, CARD_1;
 schemes FINSEQ_2, NAT_1;

begin
L1: (for R2 being Nat holds (for R4 being (Tuple of R2 , ( BOOLEAN )) holds (for R5 being (Tuple of R2 , ( BOOLEAN )) holds ((( len R4 ) = R2 & ( len R5 ) = R2 & (for R1 being Nat holds (R1 in ( Seg R2 ) implies ( R4 /. R1 ) = ( R5 /. R1 )))) implies R4 = R5))))
proof
let R2 being Nat;
let R4 being (Tuple of R2 , ( BOOLEAN ));
let R5 being (Tuple of R2 , ( BOOLEAN ));
assume that
L2: ( len R4 ) = R2
and
L3: ( len R5 ) = R2
and
L4: (for R1 being Nat holds (R1 in ( Seg R2 ) implies ( R4 /. R1 ) = ( R5 /. R1 )));
L5: ( dom R4 ) = ( Seg R2 ) by L2 , FINSEQ_1:def 3;
L6: (for B1 being Nat holds (B1 in ( dom R4 ) implies ( R4 . B1 ) = ( R5 . B1 )))
proof
let C1 being Nat;
assume L7: C1 in ( dom R4 );
L8: C1 in ( dom R5 ) by L7 , L3 , L5 , FINSEQ_1:def 3;
L9: ( R4 /. C1 ) = ( R4 . C1 ) by L7 , PARTFUN1:def 6;
L10: ( R5 /. C1 ) = ( R5 . C1 ) by L8 , PARTFUN1:def 6;
thus L11: thesis by L10 , L4 , L5 , L7 , L9;
end;
thus L12: thesis by L6 , L2 , L3 , FINSEQ_2:9;
end;
definition
let C2 being Nat;
func Bin1 C2 -> (Tuple of C2 , ( BOOLEAN )) means 
:L13: (for R1 being Nat holds (R1 in ( Seg C2 ) implies ( it /. R1 ) = ( IFEQ (R1 , 1 , ( TRUE ) , ( FALSE )) )));
existence
proof
deffunc H1(set) = ( IFEQ ($1 , 1 , ( TRUE ) , ( FALSE )) );
consider C3 being (FinSequence of ( BOOLEAN )) such that L14: ( len C3 ) = C2 and L15: (for B2 being Nat holds (B2 in ( dom C3 ) implies ( C3 . B2 ) = H1(B2))) from FINSEQ_2:sch 1;
L16: ( dom C3 ) = ( Seg C2 ) by L14 , FINSEQ_1:def 3;
L17: C3 is (Element of ( C2 -tuples_on ( BOOLEAN ) )) by L14 , FINSEQ_2:92;
reconsider D1 = C3 as (Tuple of C2 , ( BOOLEAN )) by L17;
take D1;
let R1 being Nat;
assume L18: R1 in ( Seg C2 );
L19: R1 in ( dom D1 ) by L18 , L14 , FINSEQ_1:def 3;
thus L20: ( D1 /. R1 ) = ( D1 . R1 ) by L19 , PARTFUN1:def 6
.= ( IFEQ (R1 , 1 , ( TRUE ) , ( FALSE )) ) by L15 , L16 , L18;
end;
uniqueness
proof
let C4 , C5 being (Tuple of C2 , ( BOOLEAN ));
assume that
L21: (for R1 being Nat holds (R1 in ( Seg C2 ) implies ( C4 /. R1 ) = ( IFEQ (R1 , 1 , ( TRUE ) , ( FALSE )) )))
and
L22: (for R1 being Nat holds (R1 in ( Seg C2 ) implies ( C5 /. R1 ) = ( IFEQ (R1 , 1 , ( TRUE ) , ( FALSE )) )));
L23: ( len C4 ) = C2 by CARD_1:def 7;
L24: ( len C5 ) = C2 by CARD_1:def 7;
L25: ( dom C4 ) = ( Seg C2 ) by L23 , FINSEQ_1:def 3;
L26:
now
let C6 being Nat;
assume L27: C6 in ( dom C4 );
L28: C6 in ( dom C5 ) by L27 , L24 , L25 , FINSEQ_1:def 3;
thus L29: ( C4 . C6 ) = ( C4 /. C6 ) by L27 , PARTFUN1:def 6
.= ( IFEQ (C6 , 1 , ( TRUE ) , ( FALSE )) ) by L21 , L25 , L27
.= ( C5 /. C6 ) by L22 , L25 , L27
.= ( C5 . C6 ) by L28 , PARTFUN1:def 6;
end;
thus L30: thesis by L26 , L23 , L24 , FINSEQ_2:9;
end;
end;
definition
let C7 being non  empty Nat;
let C8 being (Tuple of C7 , ( BOOLEAN ));
func Neg2 C8 -> (Tuple of C7 , ( BOOLEAN )) equals 
( ( 'not' C8 ) + ( Bin1 C7 ) );
correctness;
end;
definition
let C9 being Nat;
let C10 being (Tuple of C9 , ( BOOLEAN ));
func Intval C10 -> Integer equals 
:L33: ( Absval C10 ) if ( C10 /. C9 ) = ( FALSE ) otherwise ( ( Absval C10 ) - ( 2 to_power C9 ) );
correctness;
end;
definition
let C11 being non  empty Nat;
let C12 , C13 being (Tuple of C11 , ( BOOLEAN ));
func Int_add_ovfl (C12 , C13) -> (Element of ( BOOLEAN )) equals 
( ( ( 'not' ( C12 /. C11 ) ) '&' ( 'not' ( C13 /. C11 ) ) ) '&' ( ( carry (C12 , C13) ) /. C11 ) );
correctness;
end;
definition
let C14 being non  empty Nat;
let C15 , C16 being (Tuple of C14 , ( BOOLEAN ));
func Int_add_udfl (C15 , C16) -> (Element of ( BOOLEAN )) equals 
( ( ( C15 /. C14 ) '&' ( C16 /. C14 ) ) '&' ( 'not' ( ( carry (C15 , C16) ) /. C14 ) ) );
correctness;
end;
theorem
L37: (for B3 being (Tuple of 2 , ( BOOLEAN )) holds (B3 = ( <* ( FALSE ) *> ^ <* ( FALSE ) *> ) implies ( Intval B3 ) = ( 0 )))
proof
let C17 being (Tuple of 2 , ( BOOLEAN ));
assume L38: C17 = ( <* ( FALSE ) *> ^ <* ( FALSE ) *> );
consider C18 , C19 being (Element of ( NAT )) such that L39: ( Binary C17 ) = <* C18 , C19 *> by FINSEQ_2:100;
L40: C17 = <* ( FALSE ) , ( FALSE ) *> by L38 , FINSEQ_1:def 9;
L41: ( C17 /. 1 ) = ( FALSE ) by L40 , FINSEQ_4:17;
L42: ( C17 /. 2 ) = ( FALSE ) by L40 , FINSEQ_4:17;
L43: (1 in ( Seg 1 ) & ( Seg 1 ) c= ( Seg 2 )) by FINSEQ_1:3 , FINSEQ_1:5;
L44: ( ( Binary C17 ) /. 1 ) = ( IFEQ (( C17 /. 1 ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( 1 -' 1 ) )) ) by L43 , BINARITH:def 3
.= ( 0 ) by L41 , FUNCOP_1:def 8;
L45: 2 in ( Seg 2 ) by FINSEQ_1:3;
L46: ( ( Binary C17 ) /. 2 ) = ( IFEQ (( C17 /. 2 ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( 2 -' 1 ) )) ) by L45 , BINARITH:def 3
.= ( 0 ) by L42 , FUNCOP_1:def 8;
L47: (( ( Binary C17 ) /. 1 ) = C18 & ( ( Binary C17 ) /. 2 ) = C19) by L39 , FINSEQ_4:17;
L48: ( Absval C17 ) = ( ( addnat ) $$ <* ( 0 ) , ( 0 ) *> ) by L47 , L39 , L44 , L46 , BINARITH:def 4
.= ( ( addnat ) $$ ( <* ( 0 ) *> ^ <* ( 0 ) *> ) ) by FINSEQ_1:def 9
.= ( ( addnat ) . (( ( addnat ) $$ <* ( 0 ) *> ) , ( ( addnat ) $$ <* ( 0 ) *> )) ) by FINSOP_1:5
.= ( ( addnat ) . (( 0 ) , ( ( addnat ) $$ <* ( 0 ) *> )) ) by FINSOP_1:11
.= ( ( addnat ) . (( 0 ) , ( 0 )) ) by FINSOP_1:11
.= ( ( 0 ) + ( 0 ) ) by BINOP_2:def 23
.= ( 0 );
thus L49: thesis by L48 , L42 , L33;
end;
theorem
L50: (for B4 being (Tuple of 2 , ( BOOLEAN )) holds (B4 = ( <* ( TRUE ) *> ^ <* ( FALSE ) *> ) implies ( Intval B4 ) = 1))
proof
let C20 being (Tuple of 2 , ( BOOLEAN ));
assume L51: C20 = ( <* ( TRUE ) *> ^ <* ( FALSE ) *> );
consider C21 , C22 being (Element of ( NAT )) such that L52: ( Binary C20 ) = <* C21 , C22 *> by FINSEQ_2:100;
L53: C20 = <* ( TRUE ) , ( FALSE ) *> by L51 , FINSEQ_1:def 9;
L54: ( C20 /. 1 ) = ( TRUE ) by L53 , FINSEQ_4:17;
L55: ( C20 /. 2 ) = ( FALSE ) by L53 , FINSEQ_4:17;
L56: (1 in ( Seg 1 ) & ( Seg 1 ) c= ( Seg 2 )) by FINSEQ_1:3 , FINSEQ_1:5;
L57: ( ( Binary C20 ) /. 1 ) = ( IFEQ (( C20 /. 1 ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( 1 -' 1 ) )) ) by L56 , BINARITH:def 3
.= ( 2 to_power ( 1 -' 1 ) ) by L54 , FUNCOP_1:def 8;
L58: ( 1 - 1 ) = ( 0 );
L59: ( 1 -' 1 ) = ( 0 ) by L58 , XREAL_0:def 2;
L60: ( ( Binary C20 ) /. 1 ) = 1 by L59 , L57 , POWER:24;
L61: 2 in ( Seg 2 ) by FINSEQ_1:3;
L62: ( ( Binary C20 ) /. 2 ) = ( IFEQ (( C20 /. 2 ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( 2 -' 1 ) )) ) by L61 , BINARITH:def 3
.= ( 0 ) by L55 , FUNCOP_1:def 8;
L63: (( ( Binary C20 ) /. 1 ) = C21 & ( ( Binary C20 ) /. 2 ) = C22) by L52 , FINSEQ_4:17;
L64: ( Absval C20 ) = ( ( addnat ) $$ <* 1 , ( 0 ) *> ) by L63 , L52 , L60 , L62 , BINARITH:def 4
.= ( ( addnat ) $$ ( <* 1 *> ^ <* ( 0 ) *> ) ) by FINSEQ_1:def 9
.= ( ( addnat ) . (( ( addnat ) $$ <* 1 *> ) , ( ( addnat ) $$ <* ( 0 ) *> )) ) by FINSOP_1:5
.= ( ( addnat ) . (1 , ( ( addnat ) $$ <* ( 0 ) *> )) ) by FINSOP_1:11
.= ( ( addnat ) . (1 , ( 0 )) ) by FINSOP_1:11
.= ( 1 + ( 0 ) ) by BINOP_2:def 23
.= 1;
thus L65: thesis by L64 , L55 , L33;
end;
theorem
L66: (for B5 being (Tuple of 2 , ( BOOLEAN )) holds (B5 = ( <* ( FALSE ) *> ^ <* ( TRUE ) *> ) implies ( Intval B5 ) = ( - 2 )))
proof
let C23 being (Tuple of 2 , ( BOOLEAN ));
assume L67: C23 = ( <* ( FALSE ) *> ^ <* ( TRUE ) *> );
consider C24 , C25 being (Element of ( NAT )) such that L68: ( Binary C23 ) = <* C24 , C25 *> by FINSEQ_2:100;
L69: C23 = <* ( FALSE ) , ( TRUE ) *> by L67 , FINSEQ_1:def 9;
L70: ( C23 /. 1 ) = ( FALSE ) by L69 , FINSEQ_4:17;
L71: ( C23 /. 2 ) = ( TRUE ) by L69 , FINSEQ_4:17;
L72: ( Intval C23 ) = ( ( Absval C23 ) - ( 2 to_power ( 1 + 1 ) ) ) by L71 , L33
.= ( ( Absval C23 ) - ( ( 2 to_power 1 ) * ( 2 to_power 1 ) ) ) by POWER:27
.= ( ( Absval C23 ) - ( 2 * ( 2 to_power 1 ) ) ) by POWER:25
.= ( ( Absval C23 ) - ( 2 * 2 ) ) by POWER:25
.= ( ( Absval C23 ) - 4 );
L73: (1 in ( Seg 1 ) & ( Seg 1 ) c= ( Seg 2 )) by FINSEQ_1:3 , FINSEQ_1:5;
L74: ( ( Binary C23 ) /. 1 ) = ( IFEQ (( C23 /. 1 ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( 1 -' 1 ) )) ) by L73 , BINARITH:def 3
.= ( 0 ) by L70 , FUNCOP_1:def 8;
L75: 2 in ( Seg 2 ) by FINSEQ_1:3;
L76: ( ( Binary C23 ) /. 2 ) = ( IFEQ (( C23 /. 2 ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( 2 -' 1 ) )) ) by L75 , BINARITH:def 3
.= ( 2 to_power ( 2 -' 1 ) ) by L71 , FUNCOP_1:def 8;
L77: ( 2 - 1 ) = 1;
L78: ( 2 -' 1 ) = 1 by L77 , XREAL_0:def 2;
L79: ( ( Binary C23 ) /. 2 ) = 2 by L78 , L76 , POWER:25;
L80: (( ( Binary C23 ) /. 1 ) = C24 & ( ( Binary C23 ) /. 2 ) = C25) by L68 , FINSEQ_4:17;
L81: ( Absval C23 ) = ( ( addnat ) $$ <* ( 0 ) , 2 *> ) by L80 , L68 , L74 , L79 , BINARITH:def 4
.= ( ( addnat ) $$ ( <* ( 0 ) *> ^ <* 2 *> ) ) by FINSEQ_1:def 9
.= ( ( addnat ) . (( ( addnat ) $$ <* ( 0 ) *> ) , ( ( addnat ) $$ <* 2 *> )) ) by FINSOP_1:5
.= ( ( addnat ) . (( 0 ) , ( ( addnat ) $$ <* 2 *> )) ) by FINSOP_1:11
.= ( ( addnat ) . (( 0 ) , 2) ) by FINSOP_1:11
.= ( ( 0 ) + 2 ) by BINOP_2:def 23
.= 2;
thus L82: thesis by L81 , L72;
end;
theorem
L83: (for B6 being (Tuple of 2 , ( BOOLEAN )) holds (B6 = ( <* ( TRUE ) *> ^ <* ( TRUE ) *> ) implies ( Intval B6 ) = ( - 1 )))
proof
let C26 being (Tuple of 2 , ( BOOLEAN ));
assume L84: C26 = ( <* ( TRUE ) *> ^ <* ( TRUE ) *> );
consider C27 , C28 being (Element of ( NAT )) such that L85: ( Binary C26 ) = <* C27 , C28 *> by FINSEQ_2:100;
L86: C26 = <* ( TRUE ) , ( TRUE ) *> by L84 , FINSEQ_1:def 9;
L87: ( C26 /. 1 ) <> ( FALSE ) by L86 , FINSEQ_4:17;
L88: ( C26 /. 2 ) <> ( FALSE ) by L86 , FINSEQ_4:17;
L89: ( Intval C26 ) = ( ( Absval C26 ) - ( 2 to_power ( 1 + 1 ) ) ) by L88 , L33
.= ( ( Absval C26 ) - ( ( 2 to_power 1 ) * ( 2 to_power 1 ) ) ) by POWER:27
.= ( ( Absval C26 ) - ( 2 * ( 2 to_power 1 ) ) ) by POWER:25
.= ( ( Absval C26 ) - ( 2 * 2 ) ) by POWER:25
.= ( ( Absval C26 ) - 4 );
L90: (1 in ( Seg 1 ) & ( Seg 1 ) c= ( Seg 2 )) by FINSEQ_1:3 , FINSEQ_1:5;
L91: ( ( Binary C26 ) /. 1 ) = ( IFEQ (( C26 /. 1 ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( 1 -' 1 ) )) ) by L90 , BINARITH:def 3
.= ( 2 to_power ( 1 -' 1 ) ) by L87 , FUNCOP_1:def 8;
L92: ( 1 - 1 ) = ( 0 );
L93: ( 1 -' 1 ) = ( 0 ) by L92 , XREAL_0:def 2;
L94: ( ( Binary C26 ) /. 1 ) = 1 by L93 , L91 , POWER:24;
L95: 2 in ( Seg 2 ) by FINSEQ_1:3;
L96: ( ( Binary C26 ) /. 2 ) = ( IFEQ (( C26 /. 2 ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( 2 -' 1 ) )) ) by L95 , BINARITH:def 3
.= ( 2 to_power ( 2 -' 1 ) ) by L88 , FUNCOP_1:def 8;
L97: ( 2 - 1 ) = 1;
L98: ( 2 -' 1 ) = 1 by L97 , XREAL_0:def 2;
L99: ( ( Binary C26 ) /. 2 ) = 2 by L98 , L96 , POWER:25;
L100: (( ( Binary C26 ) /. 1 ) = C27 & ( ( Binary C26 ) /. 2 ) = C28) by L85 , FINSEQ_4:17;
L101: ( Absval C26 ) = ( ( addnat ) $$ <* 1 , 2 *> ) by L100 , L85 , L94 , L99 , BINARITH:def 4
.= ( ( addnat ) $$ ( <* 1 *> ^ <* 2 *> ) ) by FINSEQ_1:def 9
.= ( ( addnat ) . (( ( addnat ) $$ <* 1 *> ) , ( ( addnat ) $$ <* 2 *> )) ) by FINSOP_1:5
.= ( ( addnat ) . (1 , ( ( addnat ) $$ <* 2 *> )) ) by FINSOP_1:11
.= ( ( addnat ) . (1 , 2) ) by FINSOP_1:11
.= ( 1 + 2 ) by BINOP_2:def 23
.= 3;
thus L102: thesis by L101 , L89;
end;
theorem
L103: (for R2 being Nat holds (for R1 being Nat holds ((R1 in ( Seg R2 ) & R1 = 1) implies ( ( Bin1 R2 ) /. R1 ) = ( TRUE ))))
proof
let R2 being Nat;
let C29 being Nat;
assume that
L104: C29 in ( Seg R2 )
and
L105: C29 = 1;
thus L106: ( ( Bin1 R2 ) /. C29 ) = ( IFEQ (C29 , 1 , ( TRUE ) , ( FALSE )) ) by L104 , L13
.= ( TRUE ) by L105 , FUNCOP_1:def 8;
end;
theorem
L107: (for R2 being Nat holds (for R1 being Nat holds ((R1 in ( Seg R2 ) & R1 <> 1) implies ( ( Bin1 R2 ) /. R1 ) = ( FALSE ))))
proof
let R2 being Nat;
let C30 being Nat;
assume that
L108: C30 in ( Seg R2 )
and
L109: C30 <> 1;
thus L110: ( ( Bin1 R2 ) /. C30 ) = ( IFEQ (C30 , 1 , ( TRUE ) , ( FALSE )) ) by L108 , L13
.= ( FALSE ) by L109 , FUNCOP_1:def 8;
end;
theorem
L111: (for R3 being non  empty Nat holds ( Bin1 ( R3 + 1 ) ) = ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ))
proof
let R3 being non  empty Nat;
L112: (( len ( Bin1 ( R3 + 1 ) ) ) = ( R3 + 1 ) & ( len ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) ) = ( R3 + 1 )) by CARD_1:def 7;
L113: (for R1 being Nat holds (R1 in ( Seg ( R3 + 1 ) ) implies ( ( Bin1 ( R3 + 1 ) ) /. R1 ) = ( ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) /. R1 )))
proof
let R1 being Nat;
assume that
L114: R1 in ( Seg ( R3 + 1 ) );
per cases  by L114 , FINSEQ_2:7;
suppose L115: R1 in ( Seg R3 );

thus L116: ( ( Bin1 ( R3 + 1 ) ) /. R1 ) = ( ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) /. R1 )
proof
per cases ;
suppose L117: R1 = 1;

L118: ( ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) /. R1 ) = ( ( Bin1 R3 ) /. R1 ) by L115 , BINARITH:1
.= ( TRUE ) by L115 , L117 , L103;
thus L119: thesis by L118 , L114 , L117 , L103;
end;
suppose L120: R1 <> 1;

L121: ( ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) /. R1 ) = ( ( Bin1 R3 ) /. R1 ) by L115 , BINARITH:1
.= ( FALSE ) by L115 , L120 , L107;
thus L122: thesis by L121 , L114 , L120 , L107;
end;
end;

end;
suppose L117: R1 = ( R3 + 1 );

L118: 1 <> ( R3 + 1 ) by NAT_1:14;
L119: ( ( Bin1 ( R3 + 1 ) ) /. R1 ) = ( FALSE ) by L118 , L114 , L117 , L107;
thus L120: thesis by L119 , L117 , BINARITH:2;
end;
end;
thus L122: thesis by L113 , L112 , L1;
end;
theorem
L123: (for R3 being non  empty Nat holds ( Intval ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) ) = 1)
proof
defpred S1[ non  empty Nat ] means ( Intval ( ( Bin1 $1 ) ^ <* ( FALSE ) *> ) ) = 1;
L124: S1[ 1 ]
proof
consider C31 being (Element of ( BOOLEAN )) such that L125: ( Bin1 1 ) = <* C31 *> by FINSEQ_2:97;
L126: ( ( Bin1 1 ) /. 1 ) = C31 by L125 , FINSEQ_4:16;
L127: 1 in ( Seg 1 ) by FINSEQ_1:3;
L128: ( Bin1 1 ) = <* ( TRUE ) *> by L127 , L125 , L126 , L103;
thus L129: thesis by L128 , L50;
end;
L130:
now
let C32 being non  empty Nat;
assume that
L131: S1[ C32 ];
L132: ( ( ( Bin1 C32 ) ^ <* ( FALSE ) *> ) /. ( C32 + 1 ) ) = ( FALSE ) by BINARITH:2;
L133: ( Absval ( ( Bin1 C32 ) ^ <* ( FALSE ) *> ) ) = 1 by L132 , L131 , L33;
L134: ( ( ( Bin1 ( C32 + 1 ) ) ^ <* ( FALSE ) *> ) /. ( ( C32 + 1 ) + 1 ) ) = ( FALSE ) by BINARITH:2;
L135: ( Intval ( ( Bin1 ( C32 + 1 ) ) ^ <* ( FALSE ) *> ) ) = ( Absval ( ( Bin1 ( C32 + 1 ) ) ^ <* ( FALSE ) *> ) ) by L134 , L33
.= ( Absval ( ( ( Bin1 C32 ) ^ <* ( FALSE ) *> ) ^ <* ( FALSE ) *> ) ) by L111
.= ( ( Absval ( ( Bin1 C32 ) ^ <* ( FALSE ) *> ) ) + ( IFEQ (( FALSE ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( C32 + 1 ) )) ) ) by BINARITH:20
.= ( 1 + ( 0 ) ) by L133 , FUNCOP_1:def 8
.= 1;
thus L136: S1[ ( C32 + 1 ) ] by L135;
end;
thus L137: (for R3 being non  empty Nat holds S1[ R3 ]) from NAT_1:sch 10(L124 , L130);
end;
theorem
L138: (for R3 being non  empty Nat holds (for B7 being (Tuple of R3 , ( BOOLEAN )) holds (for B8 being (Element of ( BOOLEAN )) holds ( 'not' ( B7 ^ <* B8 *> ) ) = ( ( 'not' B7 ) ^ <* ( 'not' B8 ) *> ))))
proof
let R3 being non  empty Nat;
let C33 being (Tuple of R3 , ( BOOLEAN ));
let R6 being (Element of ( BOOLEAN ));
L139: (( len ( 'not' ( C33 ^ <* R6 *> ) ) ) = ( R3 + 1 ) & ( len ( ( 'not' C33 ) ^ <* ( 'not' R6 ) *> ) ) = ( R3 + 1 )) by CARD_1:def 7;
L140: (for R1 being Nat holds (R1 in ( Seg ( R3 + 1 ) ) implies ( ( 'not' ( C33 ^ <* R6 *> ) ) /. R1 ) = ( ( ( 'not' C33 ) ^ <* ( 'not' R6 ) *> ) /. R1 )))
proof
let R1 being Nat;
assume that
L141: R1 in ( Seg ( R3 + 1 ) );
per cases  by L141 , FINSEQ_2:7;
suppose L142: R1 in ( Seg R3 );

L143: ( ( 'not' ( C33 ^ <* R6 *> ) ) /. R1 ) = ( 'not' ( ( C33 ^ <* R6 *> ) /. R1 ) ) by L141 , BINARITH:def 1
.= ( 'not' ( C33 /. R1 ) ) by L142 , BINARITH:1;
L144: ( ( ( 'not' C33 ) ^ <* ( 'not' R6 ) *> ) /. R1 ) = ( ( 'not' C33 ) /. R1 ) by L142 , BINARITH:1
.= ( 'not' ( C33 /. R1 ) ) by L142 , BINARITH:def 1;
thus L145: thesis by L144 , L143;
end;
suppose L146: R1 = ( R3 + 1 );

L147: ( ( 'not' ( C33 ^ <* R6 *> ) ) /. R1 ) = ( 'not' ( ( C33 ^ <* R6 *> ) /. R1 ) ) by L141 , BINARITH:def 1
.= ( 'not' R6 ) by L146 , BINARITH:2;
thus L148: thesis by L147 , L146 , BINARITH:2;
end;
end;
thus L150: thesis by L140 , L139 , L1;
end;
theorem
L151: (for R3 being non  empty Nat holds (for B9 being (Tuple of R3 , ( BOOLEAN )) holds (for B10 being (Element of ( BOOLEAN )) holds ( Intval ( B9 ^ <* B10 *> ) ) = ( ( Absval B9 ) - (( IFEQ (B10 , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) qua Nat) ))))
proof
let R3 being non  empty Nat;
let C34 being (Tuple of R3 , ( BOOLEAN ));
let R6 being (Element of ( BOOLEAN ));
per cases  by XBOOLEAN:def 3;
suppose L152: R6 = ( FALSE );

L153: ( ( C34 ^ <* R6 *> ) /. ( R3 + 1 ) ) = ( FALSE ) by L152 , BINARITH:2;
L154: ( Intval ( C34 ^ <* R6 *> ) ) = ( Absval ( C34 ^ <* R6 *> ) ) by L153 , L33
.= ( ( Absval C34 ) + ( IFEQ (R6 , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) by BINARITH:20
.= ( ( Absval C34 ) + ( 0 ) ) by L152 , FUNCOP_1:def 8
.= ( Absval C34 );
L155: ( ( Absval C34 ) - (( IFEQ (R6 , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) qua Nat) ) = ( ( Absval C34 ) - ( 0 ) ) by L152 , FUNCOP_1:def 8
.= ( Absval C34 );
thus L156: thesis by L155 , L154;
end;
suppose L157: R6 = ( TRUE );

L158: ( ( C34 ^ <* R6 *> ) /. ( R3 + 1 ) ) <> ( FALSE ) by L157 , BINARITH:2;
L159: ( Intval ( C34 ^ <* R6 *> ) ) = ( ( Absval ( C34 ^ <* R6 *> ) ) - ( 2 to_power ( R3 + 1 ) ) ) by L158 , L33
.= ( ( ( Absval C34 ) + ( IFEQ (R6 , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) - ( 2 to_power ( R3 + 1 ) ) ) by BINARITH:20
.= ( ( ( Absval C34 ) + ( 2 to_power R3 ) ) - ( 2 to_power ( R3 + 1 ) ) ) by L157 , FUNCOP_1:def 8
.= ( ( ( Absval C34 ) + ( 2 to_power R3 ) ) - ( ( 2 to_power R3 ) * ( 2 to_power 1 ) ) ) by POWER:27
.= ( ( ( Absval C34 ) + ( 2 to_power R3 ) ) - ( 2 * ( 2 to_power R3 ) ) ) by POWER:25
.= ( ( Absval C34 ) - ( 2 to_power R3 ) );
thus L160: thesis by L159 , L157 , FUNCOP_1:def 8;
end;
end;
theorem
L162: (for R3 being non  empty Nat holds (for B11 , B12 being (Tuple of R3 , ( BOOLEAN )) holds (for B13 , B14 being (Element of ( BOOLEAN )) holds ( ( ( Intval ( ( B11 ^ <* B13 *> ) + ( B12 ^ <* B14 *> ) ) ) + ( IFEQ (( Int_add_ovfl (( B11 ^ <* B13 *> ) , ( B12 ^ <* B14 *> )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) - ( IFEQ (( Int_add_udfl (( B11 ^ <* B13 *> ) , ( B12 ^ <* B14 *> )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) = ( ( Intval ( B11 ^ <* B13 *> ) ) + ( Intval ( B12 ^ <* B14 *> ) ) ))))
proof
let R3 being non  empty Nat;
let C35 , C36 being (Tuple of R3 , ( BOOLEAN ));
let C37 , C38 being (Element of ( BOOLEAN ));
set D2 = ( FALSE );
set D3 = ( TRUE );
L163: ( Absval ( C35 + C36 ) ) = ( ( ( Absval C35 ) + ( Absval C36 ) ) - ( IFEQ (( add_ovfl (C35 , C36) ) , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) )
proof
set D4 = ( Absval ( C35 + C36 ) );
set D5 = ( IFEQ (( add_ovfl (C35 , C36) ) , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) );
L164: ( ( D4 + D5 ) - D5 ) = D4;
thus L165: thesis by L164 , BINARITH:21;
end;
L166: ( Intval ( ( C35 ^ <* C37 *> ) + ( C36 ^ <* C38 *> ) ) ) = ( Intval ( ( C35 + C36 ) ^ <* ( ( C37 'xor' C38 ) 'xor' ( add_ovfl (C35 , C36) ) ) *> ) ) by BINARITH:19
.= ( ( ( ( Absval C35 ) + ( Absval C36 ) ) - ( IFEQ (( add_ovfl (C35 , C36) ) , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) - ( IFEQ (( ( C37 'xor' C38 ) 'xor' ( add_ovfl (C35 , C36) ) ) , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) by L163 , L151;
L167: ( Int_add_ovfl (( C35 ^ <* C37 *> ) , ( C36 ^ <* C38 *> )) ) = ( ( ( 'not' C37 ) '&' ( 'not' ( ( C36 ^ <* C38 *> ) /. ( R3 + 1 ) ) ) ) '&' ( ( carry (( C35 ^ <* C37 *> ) , ( C36 ^ <* C38 *> )) ) /. ( R3 + 1 ) ) ) by BINARITH:2
.= ( ( ( 'not' C37 ) '&' ( 'not' C38 ) ) '&' ( ( carry (( C35 ^ <* C37 *> ) , ( C36 ^ <* C38 *> )) ) /. ( R3 + 1 ) ) ) by BINARITH:2
.= ( ( ( 'not' C37 ) '&' ( 'not' C38 ) ) '&' ( add_ovfl (C35 , C36) ) ) by BINARITH:18;
L168: ( Int_add_udfl (( C35 ^ <* C37 *> ) , ( C36 ^ <* C38 *> )) ) = ( ( C37 '&' ( ( C36 ^ <* C38 *> ) /. ( R3 + 1 ) ) ) '&' ( 'not' ( ( carry (( C35 ^ <* C37 *> ) , ( C36 ^ <* C38 *> )) ) /. ( R3 + 1 ) ) ) ) by BINARITH:2
.= ( ( C37 '&' C38 ) '&' ( 'not' ( ( carry (( C35 ^ <* C37 *> ) , ( C36 ^ <* C38 *> )) ) /. ( R3 + 1 ) ) ) ) by BINARITH:2
.= ( ( C37 '&' C38 ) '&' ( 'not' ( add_ovfl (C35 , C36) ) ) ) by BINARITH:18;
L169: ( Intval ( C35 ^ <* C37 *> ) ) = ( ( Absval C35 ) - ( IFEQ (C37 , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) by L151;
L170: ( Intval ( C36 ^ <* C38 *> ) ) = ( ( Absval C36 ) - ( IFEQ (C38 , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) by L151;
per cases  by XBOOLEAN:def 3;
suppose L171: (C37 = D2 & C38 = D2);

L172: ( ( Absval C35 ) - ( IFEQ (C37 , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) = ( ( Absval C35 ) - ( 0 ) ) by L171 , FUNCOP_1:def 8
.= ( Absval C35 );
L173: ( ( Absval C36 ) - ( IFEQ (C38 , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) = ( ( Absval C36 ) - ( 0 ) ) by L171 , FUNCOP_1:def 8
.= ( Absval C36 );
L174: ( IFEQ (( ( C37 '&' C38 ) '&' ( 'not' ( add_ovfl (C35 , C36) ) ) ) , D2 , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) = ( 0 ) by L171 , FUNCOP_1:def 8;
thus L175: thesis
proof
per cases  by XBOOLEAN:def 3;
suppose L176: ( add_ovfl (C35 , C36) ) = D2;

thus L177: thesis by L176 , L166 , L167 , L168 , L170 , L171 , L172 , L151;
end;
suppose L178: ( add_ovfl (C35 , C36) ) = D3;

L179: ( IFEQ (( add_ovfl (C35 , C36) ) , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) = ( 2 to_power R3 ) by L178 , FUNCOP_1:def 8;
L180: ( ( ( Intval ( ( C35 ^ <* C37 *> ) + ( C36 ^ <* C38 *> ) ) ) + ( IFEQ (( Int_add_ovfl (( C35 ^ <* C37 *> ) , ( C36 ^ <* C38 *> )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) - ( IFEQ (( Int_add_udfl (( C35 ^ <* C37 *> ) , ( C36 ^ <* C38 *> )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) = ( ( ( ( Absval C35 ) + ( Absval C36 ) ) - ( 2 * ( 2 to_power R3 ) ) ) + ( 2 to_power ( R3 + 1 ) ) ) by L179 , L166 , L167 , L168 , L171 , L174 , L178 , FUNCOP_1:def 8
.= ( ( ( ( Absval C35 ) + ( Absval C36 ) ) - ( ( 2 to_power 1 ) * ( 2 to_power R3 ) ) ) + ( 2 to_power ( R3 + 1 ) ) ) by POWER:25
.= ( ( ( ( Absval C35 ) + ( Absval C36 ) ) - ( 2 to_power ( R3 + 1 ) ) ) + ( 2 to_power ( R3 + 1 ) ) ) by POWER:27
.= ( ( Absval C35 ) + ( Absval C36 ) );
thus L181: thesis by L180 , L170 , L172 , L173 , L151;
end;
end;

end;
suppose L176: (C37 = D3 & C38 = D2);

L177: ( ( Absval C36 ) - ( IFEQ (C38 , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) = ( ( Absval C36 ) - ( 0 ) ) by L176 , FUNCOP_1:def 8
.= ( Absval C36 );
thus L178: thesis
proof
per cases  by XBOOLEAN:def 3;
suppose L179: ( add_ovfl (C35 , C36) ) = D2;

L180: ( IFEQ (( add_ovfl (C35 , C36) ) , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) = ( 0 ) by L179 , FUNCOP_1:def 8;
thus L181: thesis by L180 , L166 , L167 , L168 , L169 , L170 , L176 , L177 , L179;
end;
suppose L182: ( add_ovfl (C35 , C36) ) = D3;

thus L183: thesis by L182 , L166 , L167 , L168 , L169 , L170 , L176;
end;
end;

end;
suppose L179: (C37 = D2 & C38 = D3);

L180: ( ( Absval C35 ) - ( IFEQ (C37 , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) = ( ( Absval C35 ) - ( 0 ) ) by L179 , FUNCOP_1:def 8
.= ( Absval C35 );
thus L181: thesis
proof
per cases  by XBOOLEAN:def 3;
suppose L182: ( add_ovfl (C35 , C36) ) = D2;

L183: ( IFEQ (( add_ovfl (C35 , C36) ) , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) = ( 0 ) by L182 , FUNCOP_1:def 8;
thus L184: thesis by L183 , L166 , L167 , L168 , L169 , L170 , L179 , L180 , L182;
end;
suppose L185: ( add_ovfl (C35 , C36) ) = D3;

thus L186: thesis by L185 , L166 , L167 , L168 , L169 , L170 , L179;
end;
end;

end;
suppose L182: (C37 = D3 & C38 = D3);

L183: ( ( Absval C36 ) - ( IFEQ (C38 , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) = ( ( Absval C36 ) - ( 2 to_power R3 ) ) by L182 , FUNCOP_1:def 8;
L184: ( ( Intval ( C35 ^ <* C37 *> ) ) + ( Intval ( C36 ^ <* C38 *> ) ) ) = ( ( ( Absval C35 ) - ( IFEQ (C37 , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) + ( Intval ( C36 ^ <* C38 *> ) ) ) by L169
.= ( ( ( Absval C35 ) + ( Absval C36 ) ) - ( 2 * ( 2 to_power R3 ) ) ) by L170 , L182 , L183
.= ( ( ( Absval C35 ) + ( Absval C36 ) ) - ( ( 2 to_power 1 ) * ( 2 to_power R3 ) ) ) by POWER:25
.= ( ( ( Absval C35 ) + ( Absval C36 ) ) - ( 2 to_power ( R3 + 1 ) ) ) by POWER:27;
L185: ( IFEQ (( ( ( 'not' C37 ) '&' ( 'not' C38 ) ) '&' ( add_ovfl (C35 , C36) ) ) , D2 , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) = ( 0 ) by L182 , FUNCOP_1:def 8;
thus L186: thesis
proof
per cases  by XBOOLEAN:def 3;
suppose L187: ( add_ovfl (C35 , C36) ) = D2;

L188: ( IFEQ (( add_ovfl (C35 , C36) ) , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) = ( 0 ) by L187 , FUNCOP_1:def 8;
thus L189: thesis by L188 , L166 , L167 , L168 , L182 , L184 , L185 , L187 , FUNCOP_1:def 8;
end;
suppose L190: ( add_ovfl (C35 , C36) ) = D3;

L191: ( IFEQ (( add_ovfl (C35 , C36) ) , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) = ( 2 to_power R3 ) by L190 , FUNCOP_1:def 8;
L192: ( ( ( Intval ( ( C35 ^ <* C37 *> ) + ( C36 ^ <* C38 *> ) ) ) + ( IFEQ (( Int_add_ovfl (( C35 ^ <* C37 *> ) , ( C36 ^ <* C38 *> )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) - ( IFEQ (( Int_add_udfl (( C35 ^ <* C37 *> ) , ( C36 ^ <* C38 *> )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) = ( ( ( Absval C35 ) + ( Absval C36 ) ) - ( 2 * ( 2 to_power R3 ) ) ) by L191 , L166 , L167 , L168 , L182 , L190
.= ( ( ( Absval C35 ) + ( Absval C36 ) ) - ( ( 2 to_power 1 ) * ( 2 to_power R3 ) ) ) by POWER:25
.= ( ( ( Absval C35 ) + ( Absval C36 ) ) - ( 2 to_power ( R3 + 1 ) ) ) by POWER:27;
thus L193: thesis by L192 , L184;
end;
end;

end;
end;
theorem
L188: (for R3 being non  empty Nat holds (for B15 , B16 being (Tuple of R3 , ( BOOLEAN )) holds (for B17 , B18 being (Element of ( BOOLEAN )) holds ( Intval ( ( B15 ^ <* B17 *> ) + ( B16 ^ <* B18 *> ) ) ) = ( ( ( ( Intval ( B15 ^ <* B17 *> ) ) + ( Intval ( B16 ^ <* B18 *> ) ) ) - ( IFEQ (( Int_add_ovfl (( B15 ^ <* B17 *> ) , ( B16 ^ <* B18 *> )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) + ( IFEQ (( Int_add_udfl (( B15 ^ <* B17 *> ) , ( B16 ^ <* B18 *> )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ))))
proof
let R3 being non  empty Nat;
let C39 , C40 being (Tuple of R3 , ( BOOLEAN ));
let R7 being (Element of ( BOOLEAN ));
let R8 being (Element of ( BOOLEAN ));
set D6 = ( Intval ( ( C39 ^ <* R7 *> ) + ( C40 ^ <* R8 *> ) ) );
set D7 = ( IFEQ (( Int_add_ovfl (( C39 ^ <* R7 *> ) , ( C40 ^ <* R8 *> )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) );
set D8 = ( IFEQ (( Int_add_udfl (( C39 ^ <* R7 *> ) , ( C40 ^ <* R8 *> )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) );
set D9 = ( ( Intval ( C39 ^ <* R7 *> ) ) + ( Intval ( C40 ^ <* R8 *> ) ) );
L189: ( ( D6 + D7 ) - D8 ) = D9 by L162;
thus L190: thesis by L189;
end;
theorem
L191: (for R3 being non  empty Nat holds (for B19 being (Tuple of R3 , ( BOOLEAN )) holds ( Absval ( 'not' B19 ) ) = ( ( ( - ( Absval B19 ) ) + ( 2 to_power R3 ) ) - 1 )))
proof
defpred S2[ Nat ] means (for B20 being (Tuple of $1 , ( BOOLEAN )) holds ( Absval ( 'not' B20 ) ) = ( ( ( - ( Absval B20 ) ) + ( 2 to_power $1 ) ) - 1 ));
L192: S2[ 1 ]
proof
let C41 being (Tuple of 1 , ( BOOLEAN ));
per cases  by BINARITH:14;
suppose L193: C41 = <* ( FALSE ) *>;

L194: ( C41 /. 1 ) = ( FALSE ) by L193 , FINSEQ_4:16;
consider C42 being (Element of ( BOOLEAN )) such that L195: ( 'not' C41 ) = <* C42 *> by FINSEQ_2:97;
L196: ( ( 'not' C41 ) /. 1 ) = C42 by L195 , FINSEQ_4:16;
L197: 1 in ( Seg 1 ) by FINSEQ_1:3;
L198: ( ( 'not' C41 ) /. 1 ) = ( 'not' ( FALSE ) ) by L197 , L194 , BINARITH:def 1
.= ( TRUE );
L199: ( ( ( - ( Absval C41 ) ) + ( 2 to_power 1 ) ) - 1 ) = ( ( ( - ( 0 ) ) + ( 2 to_power 1 ) ) - 1 ) by L193 , BINARITH:15
.= ( ( ( 0 ) + 2 ) - 1 ) by POWER:25
.= 1;
thus L200: thesis by L199 , L195 , L196 , L198 , BINARITH:16;
end;
suppose L201: C41 = <* ( TRUE ) *>;

L202: ( C41 /. 1 ) = ( TRUE ) by L201 , FINSEQ_4:16;
consider C43 being (Element of ( BOOLEAN )) such that L203: ( 'not' C41 ) = <* C43 *> by FINSEQ_2:97;
L204: ( ( 'not' C41 ) /. 1 ) = C43 by L203 , FINSEQ_4:16;
L205: 1 in ( Seg 1 ) by FINSEQ_1:3;
L206: ( ( 'not' C41 ) /. 1 ) = ( 'not' ( TRUE ) ) by L205 , L202 , BINARITH:def 1
.= ( FALSE );
L207: ( ( ( - ( Absval C41 ) ) + ( 2 to_power 1 ) ) - 1 ) = ( ( ( - 1 ) + ( 2 to_power 1 ) ) - 1 ) by L201 , BINARITH:16
.= ( ( ( - 1 ) + 2 ) - 1 ) by POWER:25
.= ( 0 );
thus L208: thesis by L207 , L203 , L204 , L206 , BINARITH:15;
end;
end;
L210:
now
let R3 being non  empty Nat;
assume L211: S2[ R3 ];
L212:
now
let C44 being (Tuple of ( R3 + 1 ) , ( BOOLEAN ));
consider C45 being (Element of ( R3 -tuples_on ( BOOLEAN ) )), C46 being (Element of ( BOOLEAN )) such that L213: C44 = ( C45 ^ <* C46 *> ) by FINSEQ_2:117;
L214: ( Absval ( 'not' C44 ) ) = ( Absval ( ( 'not' C45 ) ^ <* ( 'not' C46 ) *> ) ) by L213 , L138
.= ( ( Absval ( 'not' C45 ) ) + ( IFEQ (( 'not' C46 ) , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) by BINARITH:20
.= ( ( ( ( - ( Absval C45 ) ) + ( 2 to_power R3 ) ) - 1 ) + ( IFEQ (( 'not' C46 ) , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) by L211;
L215: ( ( ( - ( Absval C44 ) ) + ( 2 to_power ( R3 + 1 ) ) ) - 1 ) = ( ( ( - ( ( Absval C45 ) + ( IFEQ (C46 , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) ) + ( 2 to_power ( R3 + 1 ) ) ) - 1 ) by L213 , BINARITH:20;
thus L216: ( Absval ( 'not' C44 ) ) = ( ( ( - ( Absval C44 ) ) + ( 2 to_power ( R3 + 1 ) ) ) - 1 )
proof
per cases  by XBOOLEAN:def 3;
suppose L217: C46 = ( FALSE );

L218: ( Absval ( 'not' C44 ) ) = ( ( ( ( - ( Absval C45 ) ) + ( 2 to_power R3 ) ) - 1 ) + ( 2 to_power R3 ) ) by L217 , L214 , FUNCOP_1:def 8
.= ( ( ( - ( Absval C45 ) ) + ( 2 * ( 2 to_power R3 ) ) ) - 1 )
.= ( ( ( - ( Absval C45 ) ) + ( ( 2 to_power 1 ) * ( 2 to_power R3 ) ) ) - 1 ) by POWER:25
.= ( ( ( - ( Absval C45 ) ) + ( 2 to_power ( R3 + 1 ) ) ) - 1 ) by POWER:27;
L219: ( ( ( - ( Absval C44 ) ) + ( 2 to_power ( R3 + 1 ) ) ) - 1 ) = ( ( ( - ( ( Absval C45 ) + ( 0 ) ) ) + ( 2 to_power ( R3 + 1 ) ) ) - 1 ) by L215 , L217 , FUNCOP_1:def 8
.= ( ( ( - ( Absval C45 ) ) + ( 2 to_power ( R3 + 1 ) ) ) - 1 );
thus L220: thesis by L219 , L218;
end;
suppose L221: C46 = ( TRUE );

L222: ( Absval ( 'not' C44 ) ) = ( ( ( ( - ( Absval C45 ) ) + ( 2 to_power R3 ) ) - 1 ) + ( 0 ) ) by L221 , L214 , FUNCOP_1:def 8
.= ( ( ( - ( Absval C45 ) ) + ( 2 to_power R3 ) ) - 1 );
L223: ( ( ( - ( Absval C44 ) ) + ( 2 to_power ( R3 + 1 ) ) ) - 1 ) = ( ( ( - ( ( Absval C45 ) + ( 2 to_power R3 ) ) ) + ( 2 to_power ( R3 + 1 ) ) ) - 1 ) by L215 , L221 , FUNCOP_1:def 8
.= ( ( ( ( - ( Absval C45 ) ) - ( 2 to_power R3 ) ) + ( ( 2 to_power 1 ) * ( 2 to_power R3 ) ) ) - 1 ) by POWER:27
.= ( ( ( ( - ( Absval C45 ) ) - ( 2 to_power R3 ) ) + ( 2 * ( 2 to_power R3 ) ) ) - 1 ) by POWER:25
.= ( ( ( - ( Absval C45 ) ) + ( 2 to_power R3 ) ) - 1 );
thus L224: thesis by L223 , L222;
end;
end;

end;
thus L217: S2[ ( R3 + 1 ) ] by L212;
end;
thus L218: (for R3 being non  empty Nat holds S2[ R3 ]) from NAT_1:sch 10(L192 , L210);
end;
theorem
L219: (for R3 being non  empty Nat holds (for B21 being (Tuple of R3 , ( BOOLEAN )) holds (for B22 being (Element of ( BOOLEAN )) holds ( Neg2 ( B21 ^ <* B22 *> ) ) = ( ( Neg2 B21 ) ^ <* ( ( 'not' B22 ) 'xor' ( add_ovfl (( 'not' B21 ) , ( Bin1 R3 )) ) ) *> ))))
proof
let R3 being non  empty Nat;
let C47 being (Tuple of R3 , ( BOOLEAN ));
let R6 being (Element of ( BOOLEAN ));
thus L220: ( Neg2 ( C47 ^ <* R6 *> ) ) = ( ( ( 'not' C47 ) ^ <* ( 'not' R6 ) *> ) + ( Bin1 ( R3 + 1 ) ) ) by L138
.= ( ( ( 'not' C47 ) ^ <* ( 'not' R6 ) *> ) + ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) ) by L111
.= ( ( ( 'not' C47 ) + ( Bin1 R3 ) ) ^ <* ( ( ( 'not' R6 ) 'xor' ( FALSE ) ) 'xor' ( add_ovfl (( 'not' C47 ) , ( Bin1 R3 )) ) ) *> ) by BINARITH:19
.= ( ( Neg2 C47 ) ^ <* ( ( 'not' R6 ) 'xor' ( add_ovfl (( 'not' C47 ) , ( Bin1 R3 )) ) ) *> );
end;
theorem
L221: (for R3 being non  empty Nat holds (for B23 being (Tuple of R3 , ( BOOLEAN )) holds (for B24 being (Element of ( BOOLEAN )) holds ( ( Intval ( Neg2 ( B23 ^ <* B24 *> ) ) ) + ( IFEQ (( Int_add_ovfl (( 'not' ( B23 ^ <* B24 *> ) ) , ( Bin1 ( R3 + 1 ) )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) = ( - ( Intval ( B23 ^ <* B24 *> ) ) ))))
proof
let R3 being non  empty Nat;
let C48 being (Tuple of R3 , ( BOOLEAN ));
let R6 being (Element of ( BOOLEAN ));
set D10 = ( IFEQ (( Int_add_ovfl (( ( 'not' C48 ) ^ <* ( 'not' R6 ) *> ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) );
set D11 = ( IFEQ (( Int_add_udfl (( ( 'not' C48 ) ^ <* ( 'not' R6 ) *> ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) );
L222: ( Int_add_udfl (( ( 'not' C48 ) ^ <* ( 'not' R6 ) *> ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) = ( ( ( ( ( 'not' C48 ) ^ <* ( 'not' R6 ) *> ) /. ( R3 + 1 ) ) '&' ( FALSE ) ) '&' ( 'not' ( ( carry (( ( 'not' C48 ) ^ <* ( 'not' R6 ) *> ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) ) by BINARITH:2
.= ( FALSE );
L223: ( ( Intval ( Neg2 ( C48 ^ <* R6 *> ) ) ) + ( IFEQ (( Int_add_ovfl (( 'not' ( C48 ^ <* R6 *> ) ) , ( Bin1 ( R3 + 1 ) )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) = ( ( Intval ( ( ( 'not' C48 ) ^ <* ( 'not' R6 ) *> ) + ( Bin1 ( R3 + 1 ) ) ) ) + ( IFEQ (( Int_add_ovfl (( 'not' ( C48 ^ <* R6 *> ) ) , ( Bin1 ( R3 + 1 ) )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) by L138
.= ( ( Intval ( ( ( 'not' C48 ) ^ <* ( 'not' R6 ) *> ) + ( Bin1 ( R3 + 1 ) ) ) ) + ( IFEQ (( Int_add_ovfl (( ( 'not' C48 ) ^ <* ( 'not' R6 ) *> ) , ( Bin1 ( R3 + 1 ) )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) by L138
.= ( ( Intval ( ( ( 'not' C48 ) ^ <* ( 'not' R6 ) *> ) + ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) ) ) + ( IFEQ (( Int_add_ovfl (( ( 'not' C48 ) ^ <* ( 'not' R6 ) *> ) , ( Bin1 ( R3 + 1 ) )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) by L111
.= ( ( Intval ( ( ( 'not' C48 ) ^ <* ( 'not' R6 ) *> ) + ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) ) ) + D10 ) by L111
.= ( ( ( ( ( Intval ( ( 'not' C48 ) ^ <* ( 'not' R6 ) *> ) ) + ( Intval ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) ) ) - D10 ) + D11 ) + D10 ) by L188
.= ( ( ( ( ( Intval ( ( 'not' C48 ) ^ <* ( 'not' R6 ) *> ) ) + 1 ) - D10 ) + D11 ) + D10 ) by L123
.= ( ( ( ( Intval ( ( 'not' C48 ) ^ <* ( 'not' R6 ) *> ) ) + 1 ) + D11 ) - ( D10 - D10 ) )
.= ( ( ( Intval ( ( 'not' C48 ) ^ <* ( 'not' R6 ) *> ) ) + 1 ) + ( 0 ) ) by L222 , FUNCOP_1:def 8
.= ( ( ( Absval ( 'not' C48 ) ) - ( IFEQ (( 'not' R6 ) , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) + 1 ) by L151
.= ( ( ( ( ( - ( Absval C48 ) ) + ( 2 to_power R3 ) ) - 1 ) - ( IFEQ (( 'not' R6 ) , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) + 1 ) by L191
.= ( ( ( - ( Absval C48 ) ) + ( 2 to_power R3 ) ) - ( IFEQ (( 'not' R6 ) , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) );
L224: ( - ( Intval ( C48 ^ <* R6 *> ) ) ) = ( - ( ( Absval C48 ) - ( IFEQ (R6 , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) ) ) by L151
.= ( ( - ( Absval C48 ) ) + ( IFEQ (R6 , ( FALSE ) , ( 0 ) , ( 2 to_power R3 )) ) );
per cases  by XBOOLEAN:def 3;
suppose L225: R6 = ( FALSE );

L226: ( ( Intval ( Neg2 ( C48 ^ <* R6 *> ) ) ) + ( IFEQ (( Int_add_ovfl (( 'not' ( C48 ^ <* R6 *> ) ) , ( Bin1 ( R3 + 1 ) )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) = ( ( ( - ( Absval C48 ) ) + ( 2 to_power R3 ) ) - ( 2 to_power R3 ) ) by L225 , L223 , FUNCOP_1:def 8
.= ( ( - ( Absval C48 ) ) + ( 0 ) );
thus L227: thesis by L226 , L224 , L225 , FUNCOP_1:def 8;
end;
suppose L228: R6 = ( TRUE );

L229: ( ( Intval ( Neg2 ( C48 ^ <* R6 *> ) ) ) + ( IFEQ (( Int_add_ovfl (( 'not' ( C48 ^ <* R6 *> ) ) , ( Bin1 ( R3 + 1 ) )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) = ( ( ( - ( Absval C48 ) ) + ( 2 to_power R3 ) ) - ( 0 ) ) by L228 , L223 , FUNCOP_1:def 8
.= ( ( - ( Absval C48 ) ) + ( 2 to_power R3 ) );
thus L230: thesis by L229 , L224 , L228 , FUNCOP_1:def 8;
end;
end;
theorem
L232: (for R3 being non  empty Nat holds (for B25 being (Tuple of R3 , ( BOOLEAN )) holds (for B26 being (Element of ( BOOLEAN )) holds ( Neg2 ( Neg2 ( B25 ^ <* B26 *> ) ) ) = ( B25 ^ <* B26 *> ))))
proof
defpred S3[ non  empty Nat ] means (for B27 being (Tuple of $1 , ( BOOLEAN )) holds (for B28 being (Element of ( BOOLEAN )) holds ( Neg2 ( Neg2 ( B27 ^ <* B28 *> ) ) ) = ( B27 ^ <* B28 *> )));
L233: S3[ 1 ]
proof
let C49 being (Tuple of 1 , ( BOOLEAN ));
let C50 being (Element of ( BOOLEAN ));
set D12 = ( ( 'not' C50 ) 'xor' ( 'not' ( C49 /. 1 ) ) );
set D13 = ( C50 '&' ( C49 /. 1 ) );
set D14 = ( ( 'not' C49 ) /. 1 );
set D15 = ( ( Bin1 1 ) /. 1 );
L234: 1 in ( Seg 1 ) by FINSEQ_1:3;
L235: ( ( ( 'not' C50 ) 'xor' ( FALSE ) ) 'xor' ( add_ovfl (( 'not' C49 ) , ( Bin1 1 )) ) ) = ( ( 'not' C50 ) 'xor' ( ( ( D14 '&' D15 ) 'or' ( D14 '&' ( ( carry (( 'not' C49 ) , ( Bin1 1 )) ) /. 1 ) ) ) 'or' ( D15 '&' ( ( carry (( 'not' C49 ) , ( Bin1 1 )) ) /. 1 ) ) ) ) by BINARITH:def 6
.= ( ( 'not' C50 ) 'xor' ( ( ( D14 '&' D15 ) 'or' ( D14 '&' ( FALSE ) ) ) 'or' ( D15 '&' ( ( carry (( 'not' C49 ) , ( Bin1 1 )) ) /. 1 ) ) ) ) by BINARITH:def 2
.= ( ( 'not' C50 ) 'xor' ( ( ( D14 '&' D15 ) 'or' ( FALSE ) ) 'or' ( D15 '&' ( FALSE ) ) ) ) by BINARITH:def 2
.= ( ( 'not' C50 ) 'xor' ( ( TRUE ) '&' D14 ) ) by L234 , L103
.= ( ( 'not' C50 ) 'xor' ( 'not' ( C49 /. 1 ) ) ) by L234 , BINARITH:def 1;
L236: ( ( ( 'not' D12 ) 'xor' ( FALSE ) ) 'xor' ( add_ovfl (( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) , ( Bin1 1 )) ) ) = ( ( 'not' D12 ) 'xor' ( ( ( ( ( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) /. 1 ) '&' D15 ) 'or' ( ( ( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) /. 1 ) '&' ( ( carry (( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) , ( Bin1 1 )) ) /. 1 ) ) ) 'or' ( D15 '&' ( ( carry (( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) , ( Bin1 1 )) ) /. 1 ) ) ) ) by BINARITH:def 6
.= ( ( 'not' D12 ) 'xor' ( ( ( ( ( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) /. 1 ) '&' ( ( Bin1 1 ) /. 1 ) ) 'or' ( ( ( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) /. 1 ) '&' ( FALSE ) ) ) 'or' ( ( ( Bin1 1 ) /. 1 ) '&' ( ( carry (( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) , ( Bin1 1 )) ) /. 1 ) ) ) ) by BINARITH:def 2
.= ( ( 'not' D12 ) 'xor' ( ( ( ( ( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) /. 1 ) '&' ( ( Bin1 1 ) /. 1 ) ) 'or' ( FALSE ) ) 'or' ( D15 '&' ( FALSE ) ) ) ) by BINARITH:def 2
.= ( ( 'not' D12 ) 'xor' ( ( TRUE ) '&' ( ( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) /. 1 ) ) ) by L234 , L103
.= ( ( 'not' D12 ) 'xor' ( 'not' ( ( ( 'not' C49 ) + ( Bin1 1 ) ) /. 1 ) ) ) by L234 , BINARITH:def 1
.= ( ( 'not' D12 ) 'xor' ( 'not' ( ( ( ( 'not' C49 ) /. 1 ) 'xor' ( ( Bin1 1 ) /. 1 ) ) 'xor' ( ( carry (( 'not' C49 ) , ( Bin1 1 )) ) /. 1 ) ) ) ) by L234 , BINARITH:def 5
.= ( ( 'not' D12 ) 'xor' ( 'not' ( ( ( ( 'not' C49 ) /. 1 ) 'xor' ( ( Bin1 1 ) /. 1 ) ) 'xor' ( FALSE ) ) ) ) by BINARITH:def 2
.= ( ( 'not' D12 ) 'xor' ( 'not' ( D14 'xor' ( TRUE ) ) ) ) by L234 , L103
.= ( ( 'not' D12 ) 'xor' ( 'not' ( C49 /. 1 ) ) ) by L234 , BINARITH:def 1;
L237: ( Neg2 ( Neg2 ( C49 ^ <* C50 *> ) ) ) = ( ( 'not' ( ( ( 'not' C49 ) ^ <* ( 'not' C50 ) *> ) + ( Bin1 ( 1 + 1 ) ) ) ) + ( Bin1 ( 1 + 1 ) ) ) by L138
.= ( ( 'not' ( ( ( 'not' C49 ) ^ <* ( 'not' C50 ) *> ) + ( ( Bin1 1 ) ^ <* ( FALSE ) *> ) ) ) + ( Bin1 ( 1 + 1 ) ) ) by L111
.= ( ( 'not' ( ( ( 'not' C49 ) + ( Bin1 1 ) ) ^ <* ( ( ( 'not' C50 ) 'xor' ( FALSE ) ) 'xor' ( add_ovfl (( 'not' C49 ) , ( Bin1 1 )) ) ) *> ) ) + ( Bin1 ( 1 + 1 ) ) ) by BINARITH:19
.= ( ( ( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) ^ <* ( 'not' D12 ) *> ) + ( Bin1 ( 1 + 1 ) ) ) by L235 , L138
.= ( ( ( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) ^ <* ( 'not' D12 ) *> ) + ( ( Bin1 1 ) ^ <* ( FALSE ) *> ) ) by L111
.= ( ( ( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) + ( Bin1 1 ) ) ^ <* ( ( 'not' D12 ) 'xor' ( 'not' ( C49 /. 1 ) ) ) *> ) by L236 , BINARITH:19;
L238: ( ( Neg2 ( Neg2 ( C49 ^ <* C50 *> ) ) ) /. 1 ) = ( ( ( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) + ( Bin1 1 ) ) /. 1 ) by L237 , L234 , BINARITH:1
.= ( ( ( ( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) /. 1 ) 'xor' ( ( Bin1 1 ) /. 1 ) ) 'xor' ( ( carry (( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) , ( Bin1 1 )) ) /. 1 ) ) by L234 , BINARITH:def 5
.= ( ( ( ( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) /. 1 ) 'xor' ( ( Bin1 1 ) /. 1 ) ) 'xor' ( FALSE ) ) by BINARITH:def 2
.= ( ( ( 'not' ( ( 'not' C49 ) + ( Bin1 1 ) ) ) /. 1 ) 'xor' ( TRUE ) ) by L234 , L103
.= ( 'not' ( 'not' ( ( ( 'not' C49 ) + ( Bin1 1 ) ) /. 1 ) ) ) by L234 , BINARITH:def 1
.= ( ( ( ( 'not' C49 ) /. 1 ) 'xor' ( ( Bin1 1 ) /. 1 ) ) 'xor' ( ( carry (( 'not' C49 ) , ( Bin1 1 )) ) /. 1 ) ) by L234 , BINARITH:def 5
.= ( ( D14 'xor' ( ( Bin1 1 ) /. 1 ) ) 'xor' ( FALSE ) ) by BINARITH:def 2
.= ( D14 'xor' ( TRUE ) ) by L234 , L103
.= ( 'not' ( 'not' ( C49 /. 1 ) ) ) by L234 , BINARITH:def 1
.= ( C49 /. 1 );
reconsider D16 = C50 , D17 = ( C49 /. 1 ) as  boolean set;
L239: ( ( Neg2 ( Neg2 ( C49 ^ <* C50 *> ) ) ) /. 2 ) = ( ( ( ( 'not' C50 ) 'or' ( 'not' ( 'not' ( C49 /. 1 ) ) ) ) '&' ( ( 'not' ( 'not' C50 ) ) 'or' ( 'not' ( C49 /. 1 ) ) ) ) 'xor' ( 'not' ( C49 /. 1 ) ) ) by L237 , BINARITH:2
.= ( ( ( ( ( 'not' D16 ) 'or' D17 ) '&' D16 ) 'or' ( ( ( 'not' D16 ) 'or' D17 ) '&' ( 'not' D17 ) ) ) 'xor' ( 'not' ( C49 /. 1 ) ) ) by XBOOLEAN:8
.= ( ( ( ( D16 '&' ( 'not' D16 ) ) 'or' ( D16 '&' D17 ) ) 'or' ( ( 'not' D17 ) '&' ( ( 'not' D16 ) 'or' D17 ) ) ) 'xor' ( 'not' ( C49 /. 1 ) ) ) by XBOOLEAN:8
.= ( ( ( ( C50 '&' ( 'not' C50 ) ) 'or' ( C50 '&' ( C49 /. 1 ) ) ) 'or' ( ( ( 'not' ( C49 /. 1 ) ) '&' ( 'not' C50 ) ) 'or' ( ( 'not' ( C49 /. 1 ) ) '&' ( C49 /. 1 ) ) ) ) 'xor' ( 'not' ( C49 /. 1 ) ) ) by XBOOLEAN:8
.= ( ( ( ( FALSE ) 'or' ( C50 '&' ( C49 /. 1 ) ) ) 'or' ( ( ( 'not' ( C49 /. 1 ) ) '&' ( 'not' C50 ) ) 'or' ( ( 'not' ( C49 /. 1 ) ) '&' ( C49 /. 1 ) ) ) ) 'xor' ( 'not' ( C49 /. 1 ) ) ) by XBOOLEAN:138
.= ( ( D13 'or' ( ( ( 'not' ( C49 /. 1 ) ) '&' ( 'not' C50 ) ) 'or' ( FALSE ) ) ) 'xor' ( 'not' ( C49 /. 1 ) ) ) by XBOOLEAN:138
.= ( ( ( ( 'not' C50 ) 'or' ( 'not' ( C49 /. 1 ) ) ) '&' ( ( 'not' ( C49 /. 1 ) ) '&' ( ( C49 /. 1 ) 'or' C50 ) ) ) 'or' ( ( D13 'or' ( ( 'not' ( C49 /. 1 ) ) '&' ( 'not' C50 ) ) ) '&' ( 'not' ( 'not' ( C49 /. 1 ) ) ) ) )
.= ( ( ( ( 'not' C50 ) 'or' ( 'not' ( C49 /. 1 ) ) ) '&' ( ( ( 'not' ( C49 /. 1 ) ) '&' ( C49 /. 1 ) ) 'or' ( ( 'not' ( C49 /. 1 ) ) '&' C50 ) ) ) 'or' ( ( D13 'or' ( ( 'not' ( C49 /. 1 ) ) '&' ( 'not' C50 ) ) ) '&' ( 'not' ( 'not' ( C49 /. 1 ) ) ) ) ) by XBOOLEAN:8
.= ( ( ( ( 'not' C50 ) 'or' ( 'not' ( C49 /. 1 ) ) ) '&' ( ( FALSE ) 'or' ( ( 'not' ( C49 /. 1 ) ) '&' C50 ) ) ) 'or' ( ( ( C50 '&' ( C49 /. 1 ) ) 'or' ( ( 'not' ( C49 /. 1 ) ) '&' ( 'not' C50 ) ) ) '&' ( 'not' ( 'not' ( C49 /. 1 ) ) ) ) ) by XBOOLEAN:138
.= ( ( ( ( ( 'not' ( C49 /. 1 ) ) '&' C50 ) '&' ( 'not' C50 ) ) 'or' ( ( ( 'not' ( C49 /. 1 ) ) '&' C50 ) '&' ( 'not' ( C49 /. 1 ) ) ) ) 'or' ( ( D13 'or' ( ( 'not' ( C49 /. 1 ) ) '&' ( 'not' C50 ) ) ) '&' ( 'not' ( 'not' ( C49 /. 1 ) ) ) ) ) by XBOOLEAN:8
.= ( ( ( ( 'not' ( C49 /. 1 ) ) '&' ( C50 '&' ( 'not' C50 ) ) ) 'or' ( ( ( 'not' ( C49 /. 1 ) ) '&' C50 ) '&' ( 'not' ( C49 /. 1 ) ) ) ) 'or' ( ( D13 'or' ( ( 'not' ( C49 /. 1 ) ) '&' ( 'not' C50 ) ) ) '&' ( 'not' ( 'not' ( C49 /. 1 ) ) ) ) )
.= ( ( ( ( 'not' ( C49 /. 1 ) ) '&' ( FALSE ) ) 'or' ( ( ( 'not' ( C49 /. 1 ) ) '&' C50 ) '&' ( 'not' ( C49 /. 1 ) ) ) ) 'or' ( ( D13 'or' ( ( 'not' ( C49 /. 1 ) ) '&' ( 'not' C50 ) ) ) '&' ( 'not' ( 'not' ( C49 /. 1 ) ) ) ) ) by XBOOLEAN:138
.= ( ( C50 '&' ( ( 'not' ( C49 /. 1 ) ) '&' ( 'not' ( C49 /. 1 ) ) ) ) 'or' ( ( D13 'or' ( ( 'not' ( C49 /. 1 ) ) '&' ( 'not' C50 ) ) ) '&' ( 'not' ( 'not' ( C49 /. 1 ) ) ) ) )
.= ( ( C50 '&' ( 'not' ( C49 /. 1 ) ) ) 'or' ( ( ( C49 /. 1 ) '&' ( ( C49 /. 1 ) '&' C50 ) ) 'or' ( ( C49 /. 1 ) '&' ( ( 'not' ( C49 /. 1 ) ) '&' ( 'not' C50 ) ) ) ) ) by XBOOLEAN:8
.= ( ( C50 '&' ( 'not' ( C49 /. 1 ) ) ) 'or' ( ( ( ( C49 /. 1 ) '&' ( C49 /. 1 ) ) '&' C50 ) 'or' ( ( C49 /. 1 ) '&' ( ( 'not' ( C49 /. 1 ) ) '&' ( 'not' C50 ) ) ) ) )
.= ( ( C50 '&' ( 'not' ( C49 /. 1 ) ) ) 'or' ( ( ( C49 /. 1 ) '&' C50 ) 'or' ( ( ( C49 /. 1 ) '&' ( 'not' ( C49 /. 1 ) ) ) '&' ( 'not' C50 ) ) ) )
.= ( ( C50 '&' ( 'not' ( C49 /. 1 ) ) ) 'or' ( ( ( C49 /. 1 ) '&' C50 ) 'or' ( ( FALSE ) '&' ( 'not' C50 ) ) ) ) by XBOOLEAN:138
.= ( C50 '&' ( ( 'not' ( C49 /. 1 ) ) 'or' ( C49 /. 1 ) ) ) by XBOOLEAN:8
.= ( ( TRUE ) '&' C50 ) by XBOOLEAN:102
.= C50;
consider C51 , C52 being (Element of ( BOOLEAN )) such that L240: ( Neg2 ( Neg2 ( C49 ^ <* C50 *> ) ) ) = <* C51 , C52 *> by FINSEQ_2:100;
L241: (( ( Neg2 ( Neg2 ( C49 ^ <* C50 *> ) ) ) /. 1 ) = C51 & ( ( Neg2 ( Neg2 ( C49 ^ <* C50 *> ) ) ) /. 2 ) = C52) by L240 , FINSEQ_4:17;
consider C53 being (Element of ( BOOLEAN )) such that L242: C49 = <* C53 *> by FINSEQ_2:97;
L243: ( Neg2 ( Neg2 ( C49 ^ <* C50 *> ) ) ) = <* C53 , C50 *> by L238 , L239 , L240 , L241 , L242 , FINSEQ_4:16;
thus L244: thesis by L243 , L242 , FINSEQ_1:def 9;
end;
L245:
now
let R3 being non  empty Nat;
assume L246: S3[ R3 ];
L247:
now
let C54 being (Tuple of ( R3 + 1 ) , ( BOOLEAN ));
let C55 being (Element of ( BOOLEAN ));
consider C56 being (Element of ( R3 -tuples_on ( BOOLEAN ) )), C57 being (Element of ( BOOLEAN )) such that L248: C54 = ( C56 ^ <* C57 *> ) by FINSEQ_2:117;
set D18 = ( add_ovfl (( 'not' C56 ) , ( Bin1 R3 )) );
set D19 = ( add_ovfl (( 'not' ( Neg2 C56 ) ) , ( Bin1 R3 )) );
L249: ( Neg2 ( Neg2 ( C56 ^ <* C57 *> ) ) ) = ( Neg2 ( ( Neg2 C56 ) ^ <* ( ( 'not' C57 ) 'xor' ( add_ovfl (( 'not' C56 ) , ( Bin1 R3 )) ) ) *> ) ) by L219
.= ( ( Neg2 ( Neg2 C56 ) ) ^ <* ( ( 'not' ( ( 'not' C57 ) 'xor' ( add_ovfl (( 'not' C56 ) , ( Bin1 R3 )) ) ) ) 'xor' ( add_ovfl (( 'not' ( Neg2 C56 ) ) , ( Bin1 R3 )) ) ) *> ) by L219;
L250: ( ( Neg2 ( Neg2 ( C56 ^ <* C57 *> ) ) ) /. ( R3 + 1 ) ) = ( ( 'not' ( ( 'not' C57 ) 'xor' ( add_ovfl (( 'not' C56 ) , ( Bin1 R3 )) ) ) ) 'xor' ( add_ovfl (( 'not' ( Neg2 C56 ) ) , ( Bin1 R3 )) ) ) by L249 , BINARITH:2;
L251: ( ( C56 ^ <* C57 *> ) /. ( R3 + 1 ) ) = C57 by BINARITH:2;
reconsider D20 = C57 , D21 = D18 as  boolean set;
L252: ( ( 'not' ( ( 'not' C57 ) 'xor' D18 ) ) 'xor' D19 ) = ( ( ( D20 '&' ( ( 'not' D20 ) 'or' ( 'not' D21 ) ) ) 'or' ( ( ( 'not' D20 ) 'or' ( 'not' D21 ) ) '&' D21 ) ) 'xor' D19 ) by XBOOLEAN:8
.= ( ( ( C57 '&' ( 'not' D18 ) ) 'or' ( D18 '&' ( ( 'not' C57 ) 'or' ( 'not' D18 ) ) ) ) 'xor' D19 ) by XBOOLEAN:11
.= ( ( D18 'xor' C57 ) 'xor' D19 ) by XBOOLEAN:11
.= ( C57 'xor' ( D18 'xor' D19 ) ) by XBOOLEAN:73;
L253: ( C57 'xor' ( D18 'xor' D19 ) ) = ( C57 'xor' ( FALSE ) ) by L252 , L246 , L250 , L251;
L254: ( C57 'xor' ( C57 'xor' ( D18 'xor' D19 ) ) ) = ( ( C57 'xor' C57 ) 'xor' ( D18 'xor' D19 ) ) by XBOOLEAN:73
.= ( ( FALSE ) 'xor' ( D18 'xor' D19 ) ) by XBOOLEAN:138
.= ( D18 'xor' D19 );
L255: ( C57 'xor' ( C57 'xor' ( FALSE ) ) ) = ( FALSE ) by XBOOLEAN:138;
L256: ( D18 'xor' ( D18 'xor' D19 ) ) = ( ( D18 'xor' D18 ) 'xor' D19 ) by XBOOLEAN:73
.= ( ( FALSE ) 'xor' D19 ) by XBOOLEAN:138
.= D19;
L257: ( R3 + 1 ) in ( Seg ( R3 + 1 ) ) by FINSEQ_1:3;
L258: ( add_ovfl (( 'not' C54 ) , ( Bin1 ( R3 + 1 ) )) ) = ( add_ovfl (( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) , ( Bin1 ( R3 + 1 ) )) ) by L248 , L138
.= ( add_ovfl (( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) by L111
.= ( ( ( ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) /. ( R3 + 1 ) ) '&' ( ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) /. ( R3 + 1 ) ) ) 'or' ( ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) /. ( R3 + 1 ) ) '&' ( ( carry (( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) ) 'or' ( ( ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) /. ( R3 + 1 ) ) '&' ( ( carry (( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) ) by BINARITH:def 6
.= ( ( ( ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) /. ( R3 + 1 ) ) '&' ( FALSE ) ) 'or' ( ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) /. ( R3 + 1 ) ) '&' ( ( carry (( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) ) 'or' ( ( ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) /. ( R3 + 1 ) ) '&' ( ( carry (( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) ) by BINARITH:2
.= ( ( ( FALSE ) 'or' ( ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) /. ( R3 + 1 ) ) '&' ( ( carry (( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) ) 'or' ( ( FALSE ) '&' ( ( carry (( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) ) by BINARITH:2
.= ( ( 'not' C57 ) '&' ( ( carry (( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) by BINARITH:2
.= ( ( 'not' C57 ) '&' D18 ) by BINARITH:18;
L259: ( add_ovfl (( 'not' ( Neg2 C54 ) ) , ( Bin1 ( R3 + 1 ) )) ) = ( add_ovfl (( 'not' ( Neg2 C54 ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) by L111
.= ( ( ( ( ( 'not' ( Neg2 C54 ) ) /. ( R3 + 1 ) ) '&' ( ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) /. ( R3 + 1 ) ) ) 'or' ( ( ( 'not' ( Neg2 C54 ) ) /. ( R3 + 1 ) ) '&' ( ( carry (( 'not' ( Neg2 C54 ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) ) 'or' ( ( ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) /. ( R3 + 1 ) ) '&' ( ( carry (( 'not' ( Neg2 C54 ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) ) by BINARITH:def 6
.= ( ( ( ( ( 'not' ( Neg2 C54 ) ) /. ( R3 + 1 ) ) '&' ( FALSE ) ) 'or' ( ( ( 'not' ( Neg2 C54 ) ) /. ( R3 + 1 ) ) '&' ( ( carry (( 'not' ( Neg2 C54 ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) ) 'or' ( ( ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) /. ( R3 + 1 ) ) '&' ( ( carry (( 'not' ( Neg2 C54 ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) ) by BINARITH:2
.= ( ( ( FALSE ) 'or' ( ( ( 'not' ( Neg2 C54 ) ) /. ( R3 + 1 ) ) '&' ( ( carry (( 'not' ( Neg2 C54 ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) ) 'or' ( ( FALSE ) '&' ( ( carry (( 'not' ( Neg2 C54 ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) ) by BINARITH:2
.= ( ( ( 'not' ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) + ( Bin1 ( R3 + 1 ) ) ) ) /. ( R3 + 1 ) ) '&' ( ( carry (( 'not' ( ( 'not' ( C56 ^ <* C57 *> ) ) + ( Bin1 ( R3 + 1 ) ) ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) by L248 , L138
.= ( ( ( 'not' ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) + ( Bin1 ( R3 + 1 ) ) ) ) /. ( R3 + 1 ) ) '&' ( ( carry (( 'not' ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) + ( Bin1 ( R3 + 1 ) ) ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) by L138
.= ( ( ( 'not' ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) + ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) ) ) /. ( R3 + 1 ) ) '&' ( ( carry (( 'not' ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) + ( Bin1 ( R3 + 1 ) ) ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) by L111
.= ( ( ( 'not' ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) + ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) ) ) /. ( R3 + 1 ) ) '&' ( ( carry (( 'not' ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) + ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) by L111
.= ( ( 'not' ( ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) + ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) ) /. ( R3 + 1 ) ) ) '&' ( ( carry (( 'not' ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) + ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) by L257 , BINARITH:def 1
.= ( ( 'not' ( ( ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) /. ( R3 + 1 ) ) 'xor' ( ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) /. ( R3 + 1 ) ) ) 'xor' ( ( carry (( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) ) '&' ( ( carry (( 'not' ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) + ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) by L257 , BINARITH:def 5
.= ( ( 'not' ( ( ( 'not' C57 ) 'xor' ( ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) /. ( R3 + 1 ) ) ) 'xor' ( ( carry (( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) ) '&' ( ( carry (( 'not' ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) + ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) by BINARITH:2
.= ( ( 'not' ( ( ( 'not' C57 ) 'xor' ( FALSE ) ) 'xor' ( ( carry (( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) ) '&' ( ( carry (( 'not' ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) + ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) by BINARITH:2
.= ( ( 'not' ( ( ( 'not' C57 ) 'xor' ( FALSE ) ) 'xor' ( add_ovfl (( 'not' C56 ) , ( Bin1 R3 )) ) ) ) '&' ( ( carry (( 'not' ( ( ( 'not' C56 ) ^ <* ( 'not' C57 ) *> ) + ( ( Bin1 R3 ) ^ <* ( FALSE ) *> ) ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) by BINARITH:18
.= ( ( 'not' ( ( 'not' C57 ) 'xor' ( add_ovfl (( 'not' C56 ) , ( Bin1 R3 )) ) ) ) '&' ( ( carry (( 'not' ( ( ( 'not' C56 ) + ( Bin1 R3 ) ) ^ <* ( ( ( 'not' C57 ) 'xor' ( FALSE ) ) 'xor' ( add_ovfl (( 'not' C56 ) , ( Bin1 R3 )) ) ) *> ) ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) by BINARITH:19
.= ( ( 'not' ( ( 'not' C57 ) 'xor' ( add_ovfl (( 'not' C56 ) , ( Bin1 R3 )) ) ) ) '&' ( ( carry (( ( 'not' ( ( 'not' C56 ) + ( Bin1 R3 ) ) ) ^ <* ( 'not' ( ( ( 'not' C57 ) 'xor' ( FALSE ) ) 'xor' ( add_ovfl (( 'not' C56 ) , ( Bin1 R3 )) ) ) ) *> ) , ( ( Bin1 R3 ) ^ <* ( FALSE ) *> )) ) /. ( R3 + 1 ) ) ) by L138
.= ( ( ( ( 'not' C57 ) 'or' ( 'not' D18 ) ) '&' ( C57 'or' ( 'not' ( 'not' D18 ) ) ) ) '&' D18 ) by L253 , L254 , L255 , L256 , BINARITH:18
.= ( ( ( 'not' C57 ) 'or' ( 'not' D18 ) ) '&' ( D18 '&' ( C57 'or' D18 ) ) )
.= ( D18 '&' ( ( 'not' D18 ) 'or' ( 'not' C57 ) ) ) by XBOOLEAN:6
.= ( D18 '&' ( 'not' C57 ) ) by XBOOLEAN:11;
set D22 = ( ( 'not' C57 ) '&' D18 );
reconsider D23 = C55 , D24 = D22 as  boolean set;
L260: ( ( 'not' ( ( 'not' C55 ) 'xor' D22 ) ) 'xor' D22 ) = ( ( ( D23 '&' ( ( 'not' D23 ) 'or' ( 'not' D24 ) ) ) 'or' ( ( ( 'not' D23 ) 'or' ( 'not' D24 ) ) '&' D24 ) ) 'xor' D22 ) by XBOOLEAN:8
.= ( ( ( C55 '&' ( 'not' D22 ) ) 'or' ( D22 '&' ( ( 'not' C55 ) 'or' ( 'not' D22 ) ) ) ) 'xor' D22 ) by XBOOLEAN:11
.= ( ( D22 'xor' C55 ) 'xor' D22 ) by XBOOLEAN:11
.= ( C55 'xor' ( D22 'xor' D22 ) ) by XBOOLEAN:73
.= ( C55 'xor' ( FALSE ) ) by XBOOLEAN:138
.= C55;
thus L261: ( Neg2 ( Neg2 ( C54 ^ <* C55 *> ) ) ) = ( Neg2 ( ( Neg2 C54 ) ^ <* ( ( 'not' C55 ) 'xor' ( add_ovfl (( 'not' C54 ) , ( Bin1 ( R3 + 1 ) )) ) ) *> ) ) by L219
.= ( ( Neg2 ( Neg2 C54 ) ) ^ <* ( ( 'not' ( ( 'not' C55 ) 'xor' ( add_ovfl (( 'not' C54 ) , ( Bin1 ( R3 + 1 ) )) ) ) ) 'xor' ( add_ovfl (( 'not' ( Neg2 C54 ) ) , ( Bin1 ( R3 + 1 ) )) ) ) *> ) by L219
.= ( C54 ^ <* C55 *> ) by L246 , L248 , L258 , L259 , L260;
end;
thus L262: S3[ ( R3 + 1 ) ] by L247;
end;
thus L263: (for R3 being non  empty Nat holds S3[ R3 ]) from NAT_1:sch 10(L233 , L245);
end;
definition
let C58 being non  empty Nat;
let C59 , C60 being (Tuple of C58 , ( BOOLEAN ));
func C59 - C60 -> (Tuple of C58 , ( BOOLEAN )) means 
:L264: (for R1 being Nat holds (R1 in ( Seg C58 ) implies ( it /. R1 ) = ( ( ( C59 /. R1 ) 'xor' ( ( Neg2 C60 ) /. R1 ) ) 'xor' ( ( carry (C59 , ( Neg2 C60 )) ) /. R1 ) )));
existence
proof
deffunc H2(Nat) = ( ( ( C59 /. $1 ) 'xor' ( ( Neg2 C60 ) /. $1 ) ) 'xor' ( ( carry (C59 , ( Neg2 C60 )) ) /. $1 ) );
consider C61 being (FinSequence of ( BOOLEAN )) such that L265: ( len C61 ) = C58 and L266: (for B29 being Nat holds (B29 in ( dom C61 ) implies ( C61 . B29 ) = H2(B29))) from FINSEQ_2:sch 1;
L267: ( dom C61 ) = ( Seg C58 ) by L265 , FINSEQ_1:def 3;
L268: C61 is (Element of ( C58 -tuples_on ( BOOLEAN ) )) by L265 , FINSEQ_2:92;
reconsider D25 = C61 as (Tuple of C58 , ( BOOLEAN )) by L268;
take D25;
let R1 being Nat;
assume L269: R1 in ( Seg C58 );
L270: R1 in ( dom D25 ) by L269 , L265 , FINSEQ_1:def 3;
thus L271: ( D25 /. R1 ) = ( D25 . R1 ) by L270 , PARTFUN1:def 6
.= ( ( ( C59 /. R1 ) 'xor' ( ( Neg2 C60 ) /. R1 ) ) 'xor' ( ( carry (C59 , ( Neg2 C60 )) ) /. R1 ) ) by L266 , L267 , L269;
end;
uniqueness
proof
let C62 , C63 being (Tuple of C58 , ( BOOLEAN ));
assume that
L272: (for R1 being Nat holds (R1 in ( Seg C58 ) implies ( C62 /. R1 ) = ( ( ( C59 /. R1 ) 'xor' ( ( Neg2 C60 ) /. R1 ) ) 'xor' ( ( carry (C59 , ( Neg2 C60 )) ) /. R1 ) )))
and
L273: (for R1 being Nat holds (R1 in ( Seg C58 ) implies ( C63 /. R1 ) = ( ( ( C59 /. R1 ) 'xor' ( ( Neg2 C60 ) /. R1 ) ) 'xor' ( ( carry (C59 , ( Neg2 C60 )) ) /. R1 ) )));
L274: ( len C62 ) = C58 by CARD_1:def 7;
L275: ( len C63 ) = C58 by CARD_1:def 7;
L276: ( dom C62 ) = ( Seg C58 ) by L274 , FINSEQ_1:def 3;
L277:
now
let C64 being Nat;
assume L278: C64 in ( dom C62 );
L279: ( Seg C58 ) = ( Seg ( len C63 ) ) by CARD_1:def 7;
L280: C64 in ( dom C63 ) by L279 , L276 , L278 , FINSEQ_1:def 3;
thus L281: ( C62 . C64 ) = ( C62 /. C64 ) by L278 , PARTFUN1:def 6
.= ( ( ( C59 /. C64 ) 'xor' ( ( Neg2 C60 ) /. C64 ) ) 'xor' ( ( carry (C59 , ( Neg2 C60 )) ) /. C64 ) ) by L272 , L276 , L278
.= ( C63 /. C64 ) by L273 , L276 , L278
.= ( C63 . C64 ) by L280 , PARTFUN1:def 6;
end;
thus L282: thesis by L277 , L274 , L275 , FINSEQ_2:9;
end;
end;
theorem
L284: (for R3 being non  empty Nat holds (for B30 , B31 being (Tuple of R3 , ( BOOLEAN )) holds ( B30 - B31 ) = ( B30 + ( Neg2 B31 ) )))
proof
let R3 being non  empty Nat;
let C65 , C66 being (Tuple of R3 , ( BOOLEAN ));
L285: (for R1 being Nat holds (R1 in ( Seg R3 ) implies ( ( C65 - C66 ) /. R1 ) = ( ( ( C65 /. R1 ) 'xor' ( ( Neg2 C66 ) /. R1 ) ) 'xor' ( ( carry (C65 , ( Neg2 C66 )) ) /. R1 ) ))) by L264;
thus L286: thesis by L285 , BINARITH:def 5;
end;
theorem
L287: (for R3 being non  empty Nat holds (for B32 , B33 being (Tuple of R3 , ( BOOLEAN )) holds (for B34 , B35 being (Element of ( BOOLEAN )) holds ( ( B32 ^ <* B34 *> ) - ( B33 ^ <* B35 *> ) ) = ( ( B32 + ( Neg2 B33 ) ) ^ <* ( ( ( B34 'xor' ( 'not' B35 ) ) 'xor' ( add_ovfl (( 'not' B33 ) , ( Bin1 R3 )) ) ) 'xor' ( add_ovfl (B32 , ( Neg2 B33 )) ) ) *> ))))
proof
let R3 being non  empty Nat;
let C67 , C68 being (Tuple of R3 , ( BOOLEAN ));
let R7 being (Element of ( BOOLEAN ));
let R8 being (Element of ( BOOLEAN ));
thus L288: ( ( C67 ^ <* R7 *> ) - ( C68 ^ <* R8 *> ) ) = ( ( C67 ^ <* R7 *> ) + ( Neg2 ( C68 ^ <* R8 *> ) ) ) by L284
.= ( ( C67 ^ <* R7 *> ) + ( ( Neg2 C68 ) ^ <* ( ( 'not' R8 ) 'xor' ( add_ovfl (( 'not' C68 ) , ( Bin1 R3 )) ) ) *> ) ) by L219
.= ( ( C67 + ( Neg2 C68 ) ) ^ <* ( ( R7 'xor' ( ( 'not' R8 ) 'xor' ( add_ovfl (( 'not' C68 ) , ( Bin1 R3 )) ) ) ) 'xor' ( add_ovfl (C67 , ( Neg2 C68 )) ) ) *> ) by BINARITH:19
.= ( ( C67 + ( Neg2 C68 ) ) ^ <* ( ( ( R7 'xor' ( 'not' R8 ) ) 'xor' ( add_ovfl (( 'not' C68 ) , ( Bin1 R3 )) ) ) 'xor' ( add_ovfl (C67 , ( Neg2 C68 )) ) ) *> ) by XBOOLEAN:73;
end;
theorem
L289: (for R3 being non  empty Nat holds (for B36 , B37 being (Tuple of R3 , ( BOOLEAN )) holds (for B38 , B39 being (Element of ( BOOLEAN )) holds ( ( ( ( Intval ( ( B36 ^ <* B38 *> ) - ( B37 ^ <* B39 *> ) ) ) + ( IFEQ (( Int_add_ovfl (( B36 ^ <* B38 *> ) , ( Neg2 ( B37 ^ <* B39 *> ) )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) - ( IFEQ (( Int_add_udfl (( B36 ^ <* B38 *> ) , ( Neg2 ( B37 ^ <* B39 *> ) )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) + ( IFEQ (( Int_add_ovfl (( 'not' ( B37 ^ <* B39 *> ) ) , ( Bin1 ( R3 + 1 ) )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) = ( ( Intval ( B36 ^ <* B38 *> ) ) - ( Intval ( B37 ^ <* B39 *> ) ) ))))
proof
let R3 being non  empty Nat;
let C69 , C70 being (Tuple of R3 , ( BOOLEAN ));
let R7 being (Element of ( BOOLEAN ));
let R8 being (Element of ( BOOLEAN ));
set D26 = ( IFEQ (( Int_add_ovfl (( C69 ^ <* R7 *> ) , ( Neg2 ( C70 ^ <* R8 *> ) )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) );
set D27 = ( IFEQ (( Int_add_udfl (( C69 ^ <* R7 *> ) , ( Neg2 ( C70 ^ <* R8 *> ) )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) );
set D28 = ( IFEQ (( Int_add_ovfl (( 'not' ( C70 ^ <* R8 *> ) ) , ( Bin1 ( R3 + 1 ) )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) );
set D29 = ( ( Neg2 C70 ) ^ <* ( ( 'not' R8 ) 'xor' ( add_ovfl (( 'not' C70 ) , ( Bin1 R3 )) ) ) *> );
thus L290: ( ( ( ( Intval ( ( C69 ^ <* R7 *> ) - ( C70 ^ <* R8 *> ) ) ) + D26 ) - D27 ) + D28 ) = ( ( ( ( Intval ( ( C69 ^ <* R7 *> ) + ( Neg2 ( C70 ^ <* R8 *> ) ) ) ) + D26 ) - D27 ) + D28 ) by L284
.= ( ( ( ( Intval ( ( C69 ^ <* R7 *> ) + D29 ) ) + D26 ) - D27 ) + D28 ) by L219
.= ( ( ( ( Intval ( ( C69 ^ <* R7 *> ) + D29 ) ) + ( IFEQ (( Int_add_ovfl (( C69 ^ <* R7 *> ) , D29) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) - D27 ) + D28 ) by L219
.= ( ( ( ( Intval ( ( C69 ^ <* R7 *> ) + D29 ) ) + ( IFEQ (( Int_add_ovfl (( C69 ^ <* R7 *> ) , D29) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) - ( IFEQ (( Int_add_udfl (( C69 ^ <* R7 *> ) , D29) ) , ( FALSE ) , ( 0 ) , ( 2 to_power ( R3 + 1 ) )) ) ) + D28 ) by L219
.= ( ( ( Intval ( C69 ^ <* R7 *> ) ) + ( Intval D29 ) ) + D28 ) by L162
.= ( ( Intval ( C69 ^ <* R7 *> ) ) + ( ( Intval D29 ) + D28 ) )
.= ( ( Intval ( C69 ^ <* R7 *> ) ) + ( ( Intval ( Neg2 ( C70 ^ <* R8 *> ) ) ) + D28 ) ) by L219
.= ( ( Intval ( C69 ^ <* R7 *> ) ) + ( - ( Intval ( C70 ^ <* R8 *> ) ) ) ) by L221
.= ( ( Intval ( C69 ^ <* R7 *> ) ) - ( Intval ( C70 ^ <* R8 *> ) ) );
end;
