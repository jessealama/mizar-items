:: Standard Ordering of Instruction Locations
::  by Andrzej Trybulec , Piotr Rudnicki and Artur Korni{\l}owicz
::
:: Received April 14, 2000
:: Copyright (c) 2000-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, XBOOLE_0, SUBSET_1, ORDINAL1, SETFAM_1, AMI_1, FSM_1,
      FUNCT_4, FUNCOP_1, RELAT_1, TARSKI, STRUCT_0, FUNCT_1, CARD_3, ZFMISC_1,
      CIRCUIT2, CAT_1, NAT_1, GLIB_000, XXREAL_0, PARTFUN1, FINSEQ_1, ARYTM_3,
      CARD_1, GOBOARD5, FUNCT_2, FINSEQ_4, ARYTM_1, FINSET_1, FRECHET,
      AMISTD_1, EXTPRO_1, AFINSQ_1, COMPOS_1, AMISTD_2, PBOOLE, SCMFSA6B,
      QUANTAL1, GOBRD13, MEMSTR_0, UNIALG_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, SETFAM_1, ORDINAL1,
      CARD_1, XXREAL_0, NUMBERS, XCMPLX_0, NAT_1, MEMBERED, FUNCT_1, RELSET_1,
      PARTFUN1, XTUPLE_0, MCART_1, VALUED_1, DOMAIN_1, CARD_3, FINSEQ_1,
      FINSEQ_4, FUNCOP_1, FINSET_1, FUNCT_4, FUNCT_7, AFINSQ_1, PBOOLE,
      MEASURE6, STRUCT_0, GRAPH_2, NAT_D, XXREAL_2, MEMSTR_0, COMPOS_0,
      COMPOS_1, EXTPRO_1, FUNCT_2;
 constructors WELLORD2, REAL_1, FINSEQ_4, REALSET1, NAT_D, XXREAL_2, COMPOS_1,
      EXTPRO_1, RELSET_1, PRE_POLY, GRAPH_2, AFINSQ_1, MCART_1, FUNCT_7,
      PBOOLE, XXREAL_1, FUNCT_4, MEASURE6, MEMSTR_0, XTUPLE_0;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2,
      FUNCOP_1, FINSET_1, NUMBERS, XREAL_0, NAT_1, MEMBERED, FINSEQ_1, CARD_3,
      REALSET1, FUNCT_7, STRUCT_0, CARD_1, XXREAL_2, RELSET_1, FUNCT_4,
      AFINSQ_1, ORDINAL1, ZFMISC_1, SUBSET_1, VALUED_1, COMPOS_1, EXTPRO_1,
      PBOOLE, PRE_POLY, MEMSTR_0, MEASURE6, COMPOS_0, XTUPLE_0;
 requirements NUMERALS, BOOLE, REAL, SUBSET, ARITHM;
 definitions TARSKI, STRUCT_0, COMPOS_1, EXTPRO_1, XBOOLE_0, MEMSTR_0,
      FUNCOP_1, NAT_1, RELAT_1, FUNCT_4, NAT_D, AFINSQ_1, VALUED_1, FUNCT_1,
      COMPOS_0, XTUPLE_0;
 theorems TARSKI, FINSEQ_4, FINSEQ_1, NAT_1, FUNCT_4, FUNCT_1, FUNCT_2,
      ENUMSET1, ZFMISC_1, CARD_1, FUNCOP_1, CARD_3, ORDINAL1, MCART_1,
      FINSEQ_3, INT_1, SETFAM_1, REVROT_1, EXTPRO_1, RELSET_1, XBOOLE_0,
      XBOOLE_1, XREAL_1, XXREAL_0, COMPOS_1, FUNCT_7, PARTFUN1, XREAL_0, NAT_D,
      PBOOLE, AFINSQ_1, RECDEF_2, MEMSTR_0, GRFUNC_1, PARTFUN2, MEASURE6,
      COMPOS_0, RELAT_1;
 schemes NAT_1, FINSEQ_2, FUNCT_2;

begin
registration
let C1 being  with_zero set;
let C2 being  with_non-empty_values AMI-Struct over C1;
let C3 being (Element of (the InstructionsF of C2));
let C4 being (State of C2);
cluster ( ( (the Execution of C2) . C3 ) . C4 ) ->  Function-like  Relation-like;
coherence
proof
reconsider D1 = ( (the Execution of C2) . C3 ) as (Function of ( product ( the_Values_of C2 ) ) , ( product ( the_Values_of C2 ) )) by FUNCT_2:66;
reconsider D2 = C4 as (Element of ( product ( the_Values_of C2 ) )) by CARD_3:107;
L1: ( D1 . D2 ) in ( product ( the_Values_of C2 ) );
thus L2: thesis by L1;
end;
end;
registration
let R6 being  with_zero set;
cluster non  empty  with_non-empty_values for AMI-Struct over R6;
existence
proof
take ( Trivial-AMI R6 );
thus L4: thesis;
end;
end;
definition
let C5 being  with_zero set;
let C6 being non  empty  with_non-empty_values AMI-Struct over C5;
let C7 being (InsType of (the InstructionsF of C6));
attr C7 is  jump-only
means
(for B1 being (State of C6) holds (for B2 being (Object of C6) holds (for B3 being (Instruction of C6) holds ((( InsCode B3 ) = C7 & B2 in ( Data-Locations C6 )) implies ( ( Exec (B3 , B1) ) . B2 ) = ( B1 . B2 )))));
end;
definition
let C8 being  with_zero set;
let C9 being non  empty  with_non-empty_values AMI-Struct over C8;
let C10 being (Instruction of C9);
attr C10 is  jump-only
means
( InsCode C10 ) is  jump-only;
end;
definition
let R6 being  with_zero set;
let R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C11 being Nat;
let C12 being (Element of (the InstructionsF of R7));
func NIC (C12 , C11) -> (Subset of ( NAT )) equals 
{ ( IC ( Exec (C12 , R14) ) ) where R14 is (Element of ( product ( the_Values_of R7 ) )) : ( IC R14 ) = C11 };
coherence
proof
L8: { ( IC ( Exec (C12 , R14) ) ) where R14 is (Element of ( product ( the_Values_of R7 ) )) : ( IC R14 ) = C11 } c= ( NAT )
proof
let C13 being set;
assume L9: C13 in { ( IC ( Exec (C12 , R14) ) ) where R14 is (Element of ( product ( the_Values_of R7 ) )) : ( IC R14 ) = C11 };
L10: (ex R14 being (Element of ( product ( the_Values_of R7 ) )) st (C13 = ( IC ( Exec (C12 , R14) ) ) & ( IC R14 ) = C11)) by L9;
thus L11: thesis by L10;
end;
thus L12: thesis by L8;
end;
end;
L14:
now
let R6 being  with_zero set;
let C14 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C15 being (Element of (the InstructionsF of C14));
let C16 being (Element of ( NAT ));
let C17 being (State of C14);
let C18 being (Instruction-Sequence of C14);
reconsider D3 = ( C17 +* (( IC C14 ) , C16) ) as (Element of ( product ( the_Values_of C14 ) )) by CARD_3:107;
L15: C16 in ( NAT );
L16: C16 in ( dom C18 ) by L15 , PARTFUN1:def 2;
L17: ( IC C14 ) in ( dom C17 ) by MEMSTR_0:2;
L18: ( IC D3 ) = C16 by L17 , FUNCT_7:31;
L19: ( CurInstr (( C18 +* (C16 , C15) ) , D3) ) = ( ( C18 +* (C16 , C15) ) . C16 ) by L18 , PBOOLE:143
.= C15 by L16 , FUNCT_7:31;
thus L20: ( IC ( Following (( C18 +* (C16 , C15) ) , ( C17 +* (( IC C14 ) , C16) )) ) ) in ( NIC (C15 , C16) ) by L19 , L18;
end;
registration
let C19 being  with_zero set;
let C20 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C19;
let C21 being (Element of (the InstructionsF of C20));
let C22 being (Element of ( NAT ));
cluster ( NIC (C21 , C22) ) -> non  empty;
coherence by L14;
end;
definition
let R6 being  with_zero set;
let R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let R8 being (Element of (the InstructionsF of R7));
func JUMP R8 -> (Subset of ( NAT )) equals 
( meet { ( NIC (R8 , R9) ) where R9 is (Element of ( NAT )) : (not contradiction) } );
coherence
proof
set D4 = { ( NIC (R8 , R9) ) where R9 is (Element of ( NAT )) : (not contradiction) };
L22: D4 c= ( bool ( NAT ) )
proof
let C23 being set;
assume L23: C23 in D4;
L24: (ex R9 being (Element of ( NAT )) st C23 = ( NIC (R8 , R9) )) by L23;
thus L25: thesis by L24;
end;
reconsider D5 = D4 as (Subset-Family of ( NAT )) by L22;
L26: ( meet D5 ) c= ( NAT );
thus L27: thesis by L26;
end;
end;
definition
let R6 being  with_zero set;
let R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C24 being Nat;
func SUCC (C24 , R7) -> (Subset of ( NAT )) equals 
( union { ( ( NIC (R8 , C24) ) \ ( JUMP R8 ) ) where R8 is (Element of (the InstructionsF of R7)) : (not contradiction) } );
coherence
proof
set D6 = { ( ( NIC (R8 , C24) ) \ ( JUMP R8 ) ) where R8 is (Element of (the InstructionsF of R7)) : (not contradiction) };
L29: D6 c= ( bool ( NAT ) )
proof
let C25 being set;
assume L30: C25 in D6;
L31: (ex R8 being (Element of (the InstructionsF of R7)) st C25 = ( ( NIC (R8 , C24) ) \ ( JUMP R8 ) )) by L30;
thus L32: thesis by L31;
end;
reconsider D7 = D6 as (Subset-Family of ( NAT )) by L29;
L33: ( union D7 ) c= ( NAT );
thus L34: thesis by L33;
end;
end;
theorem
L36: (for R6 being  with_zero set holds (for R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B4 being (Element of (the InstructionsF of R7)) holds ((for B5 being (Element of ( NAT )) holds ( NIC (B4 , B5) ) = { B5 }) implies ( JUMP B4 ) is  empty))))
proof
let R6 being  with_zero set;
let R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C26 being (Element of (the InstructionsF of R7));
set D8 = ( 0 );
set D9 = 1;
set D10 = { ( NIC (C26 , B6) ) where B6 is (Element of ( NAT )) : (not contradiction) };
reconsider D11 = D8 , D12 = D9 as (Element of ( NAT ));
assume L37: (for B7 being (Element of ( NAT )) holds ( NIC (C26 , B7) ) = { B7 });
assume L38: (not thesis);
consider C27 being set such that L39: C27 in ( meet D10 ) by L38 , XBOOLE_0:def 1;
L40: ( NIC (C26 , D11) ) = { D11 } by L37;
L41: { D11 } in D10 by L40;
L42: C27 in { D11 } by L41 , L39 , SETFAM_1:def 1;
L43: ( NIC (C26 , D12) ) = { D12 } by L37;
L44: { D12 } in D10 by L43;
L45: C27 in { D12 } by L44 , L39 , SETFAM_1:def 1;
thus L46: contradiction by L45 , L42 , TARSKI:def 1;
end;
theorem
L47: (for R6 being  with_zero set holds (for B8 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B9 being (Element of ( NAT )) holds (for B10 being (Instruction of B8) holds (B10 is  halting implies ( NIC (B10 , B9) ) = { B9 })))))
proof
let R6 being  with_zero set;
let C28 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C29 being (Element of ( NAT ));
let C30 being (Instruction of C28);
assume that
L48: (for B11 being (State of C28) holds ( Exec (C30 , B11) ) = B11);
thus L49:now
let C31 being set;
assume L50: C31 in ( NIC (C30 , C29) );
L51: (ex B12 being (Element of ( product ( the_Values_of C28 ) )) st (C31 = ( IC ( Exec (C30 , B12) ) ) & ( IC B12 ) = C29)) by L50;
L52: C31 = C29 by L51 , L48;
thus L53: C31 in { C29 } by L52 , TARSKI:def 1;
end;
set D13 = the (State of C28);
set D14 = the (Instruction-Sequence of C28);
let C32 being set;
assume L54: C32 in { C29 };
L55: C32 = C29 by L54 , TARSKI:def 1;
L56: C29 in ( NAT );
L57: C29 in ( dom D14 ) by L56 , PARTFUN1:def 2;
L58: ( IC C28 ) in ( dom D13 ) by MEMSTR_0:2;
L59: ( IC ( D13 +* (( IC C28 ) , C29) ) ) = C29 by L58 , FUNCT_7:31;
L60: ( CurInstr (( D14 +* (C29 , C30) ) , ( D13 +* (( IC C28 ) , C29) )) ) = ( ( D14 +* (C29 , C30) ) . C29 ) by L59 , PBOOLE:143
.= C30 by L57 , FUNCT_7:31;
L61: ( IC ( Following (( D14 +* (C29 , C30) ) , ( D13 +* (( IC C28 ) , C29) )) ) ) = ( IC ( D13 +* (( IC C28 ) , C29) ) ) by L60 , L48
.= C32 by L55 , L58 , FUNCT_7:31;
thus L62: C32 in ( NIC (C30 , C29) ) by L61 , L14;
end;
begin
definition
let R6 being  with_zero set;
let R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
attr R7 is  standard
means
:L63: (for B13 , B14 being (Element of ( NAT )) holds (B13 <= B14 iff (ex B15 being non  empty (FinSequence of ( NAT )) st (( B15 /. 1 ) = B13 & ( B15 /. ( len B15 ) ) = B14 & (for R4 being (Element of ( NAT )) holds ((1 <= R4 & R4 < ( len B15 )) implies ( B15 /. ( R4 + 1 ) ) in ( SUCC (( B15 /. R4 ) , R7) )))))));
end;
L65: (for R3 being (Element of ( NAT )) holds (for R6 being  with_zero set holds (for R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (ex B16 being non  empty (FinSequence of ( NAT )) st (( B16 /. 1 ) = R3 & ( B16 /. ( len B16 ) ) = R3 & (for R4 being (Element of ( NAT )) holds ((1 <= R4 & R4 < ( len B16 )) implies ( B16 /. ( R4 + 1 ) ) in ( SUCC (( B16 /. R4 ) , R7) ))))))))
proof
let R3 being (Element of ( NAT ));
let R6 being  with_zero set;
let R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
reconsider D15 = R3 as (Element of ( NAT ));
reconsider D16 = <* D15 *> as non  empty (FinSequence of ( NAT ));
take D16;
thus L66: ( D16 /. 1 ) = R3 by FINSEQ_4:16;
thus L67: thesis by L66 , FINSEQ_1:39;
end;
theorem
L68: (for R6 being  with_zero set holds (for R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (R7 is  standard iff (for B17 being (Element of ( NAT )) holds (( B17 + 1 ) in ( SUCC (B17 , R7) ) & (for B18 being (Element of ( NAT )) holds (B18 in ( SUCC (B17 , R7) ) implies B17 <= B18)))))))
proof
let R6 being  with_zero set;
let R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
thus L69:now
assume L70: R7 is  standard;
let C33 being (Element of ( NAT ));
L71: C33 <= ( C33 + 1 ) by NAT_1:11;
consider C34 being non  empty (FinSequence of ( NAT )) such that L72: ( C34 /. 1 ) = C33 and L73: ( C34 /. ( len C34 ) ) = ( C33 + 1 ) and L74: (for R4 being (Element of ( NAT )) holds ((1 <= R4 & R4 < ( len C34 )) implies ( C34 /. ( R4 + 1 ) ) in ( SUCC (( C34 /. R4 ) , R7) ))) by L71 , L70 , L63;
set D17 = ( C34 -| ( C33 + 1 ) );
set D18 = ( ( C33 + 1 ) .. C34 );
L75: ( C33 + 1 ) in ( rng C34 ) by L73 , REVROT_1:3;
L76: ( len D17 ) = ( D18 - 1 ) by L75 , FINSEQ_4:34;
L77: ( ( len D17 ) + 1 ) = D18 by L76;
L78: D18 in ( dom C34 ) by L75 , FINSEQ_4:20;
L79: ( C34 /. ( ( len D17 ) + 1 ) ) = ( C34 . D18 ) by L78 , L76 , PARTFUN1:def 6
.= ( C33 + 1 ) by L75 , FINSEQ_4:19;
L80: D18 <= ( len C34 ) by L78 , FINSEQ_3:25;
L81: ( len D17 ) < ( len C34 ) by L80 , L77 , NAT_1:13;
L82: 1 <= ( len C34 ) by NAT_1:14;
L83: 1 in ( dom C34 ) by L82 , FINSEQ_3:25;
L84: ( C34 /. 1 ) = ( C34 . 1 ) by L83 , PARTFUN1:def 6;
L85: ( C34 . D18 ) = ( C33 + 1 ) by L75 , FINSEQ_4:19;
L86: C33 <> ( C33 + 1 );
L87: ( len D17 ) <> ( 0 ) by L86 , L72 , L85 , L83 , L76 , PARTFUN1:def 6;
L88: 1 <= D18 by L78 , FINSEQ_3:25;
L89: 1 < D18 by L88 , L72 , L86 , L85 , L84 , XXREAL_0:1;
L90: 1 <= ( len D17 ) by L89 , L77 , NAT_1:13;
reconsider D19 = D17 as non  empty (FinSequence of ( NAT )) by L87 , L75 , FINSEQ_4:41;
set D20 = ( C34 /. ( len D19 ) );
reconsider D21 = D20 as (Element of ( NAT ));
L91: ( len D19 ) in ( dom C34 ) by L90 , L81 , FINSEQ_3:25;
L92: ( len D19 ) in ( dom D19 ) by L90 , FINSEQ_3:25;
L93: ( D19 /. ( len D19 ) ) = ( D19 . ( len D19 ) ) by L92 , PARTFUN1:def 6
.= ( C34 . ( len D19 ) ) by L75 , L92 , FINSEQ_4:36
.= ( C34 /. ( len D19 ) ) by L91 , PARTFUN1:def 6;
L94:
now
L95: ( rng D19 ) misses { ( C33 + 1 ) } by L75 , FINSEQ_4:38;
L96: ( ( rng D19 ) /\ { ( C33 + 1 ) } ) = ( {} ) by L95 , XBOOLE_0:def 7;
L97: ((not ( C33 + 1 ) in ( rng D19 )) or (not ( C33 + 1 ) in { ( C33 + 1 ) })) by L96 , XBOOLE_0:def 4;
assume L98: D21 = ( C33 + 1 );
L99: ( len D19 ) in ( dom D19 ) by L90 , FINSEQ_3:25;
L100: ( D19 /. ( len D19 ) ) = ( D19 . ( len D19 ) ) by L99 , PARTFUN1:def 6;
thus L101: contradiction by L100 , L93 , L98 , L97 , L99 , FUNCT_1:def 3 , TARSKI:def 1;
end;
reconsider D22 = <* ( C34 /. ( len D19 ) ) , ( C34 /. D18 ) *> as non  empty (FinSequence of ( NAT ));
L102: ( len D22 ) = 2 by FINSEQ_1:44;
L103: 2 in ( dom D22 ) by L102 , FINSEQ_3:25;
L104: ( D22 /. ( len D22 ) ) = ( D22 . 2 ) by L103 , L102 , PARTFUN1:def 6
.= ( C34 /. D18 ) by FINSEQ_1:44
.= ( C33 + 1 ) by L85 , L78 , PARTFUN1:def 6;
L105: 1 in ( dom D22 ) by L102 , FINSEQ_3:25;
L106:
now
let R4 being (Element of ( NAT ));
assume L107: (1 <= R4 & R4 < ( len D22 ));
L108: (R4 <> ( 0 ) & R4 < 2) by L107 , FINSEQ_1:44;
L109: R4 = 1 by L108 , NAT_1:26;
L110: ( D22 /. R4 ) = ( D22 . 1 ) by L109 , L105 , PARTFUN1:def 6
.= ( C34 /. ( len D19 ) ) by FINSEQ_1:44;
L111: ( D22 /. ( R4 + 1 ) ) = ( D22 . 2 ) by L103 , L109 , PARTFUN1:def 6
.= ( C34 /. ( ( len D19 ) + 1 ) ) by L76 , FINSEQ_1:44;
thus L112: ( D22 /. ( R4 + 1 ) ) in ( SUCC (( D22 /. R4 ) , R7) ) by L111 , L74 , L90 , L81 , L110;
end;
L113:
now
let R4 being (Element of ( NAT ));
assume that
L114: 1 <= R4
and
L115: R4 < ( len D19 );
L116: 1 <= ( R4 + 1 ) by L114 , NAT_1:13;
L117: ( R4 + 1 ) <= ( len D19 ) by L115 , NAT_1:13;
L118: ( R4 + 1 ) <= ( len C34 ) by L117 , L81 , XXREAL_0:2;
L119: ( R4 + 1 ) in ( dom C34 ) by L118 , L116 , FINSEQ_3:25;
L120: R4 <= ( len C34 ) by L81 , L115 , XXREAL_0:2;
L121: R4 in ( dom C34 ) by L120 , L114 , FINSEQ_3:25;
L122: R4 in ( dom D19 ) by L114 , L115 , FINSEQ_3:25;
L123: ( D19 /. R4 ) = ( D19 . R4 ) by L122 , PARTFUN1:def 6
.= ( C34 . R4 ) by L75 , L122 , FINSEQ_4:36
.= ( C34 /. R4 ) by L121 , PARTFUN1:def 6;
L124: R4 < ( len C34 ) by L81 , L115 , XXREAL_0:2;
L125: ( R4 + 1 ) in ( dom D19 ) by L116 , L117 , FINSEQ_3:25;
L126: ( D19 /. ( R4 + 1 ) ) = ( D19 . ( R4 + 1 ) ) by L125 , PARTFUN1:def 6
.= ( C34 . ( R4 + 1 ) ) by L75 , L125 , FINSEQ_4:36
.= ( C34 /. ( R4 + 1 ) ) by L119 , PARTFUN1:def 6;
thus L127: ( D19 /. ( R4 + 1 ) ) in ( SUCC (( D19 /. R4 ) , R7) ) by L126 , L74 , L114 , L123 , L124;
end;
L128: ( D22 /. 1 ) = ( D22 . 1 ) by L105 , PARTFUN1:def 6
.= D21 by FINSEQ_1:44;
L129: D21 <= ( C33 + 1 ) by L128 , L70 , L104 , L106 , L63;
L130: 1 in ( dom D19 ) by L90 , FINSEQ_3:25;
L131: ( D19 /. 1 ) = ( D19 . 1 ) by L130 , PARTFUN1:def 6
.= ( C34 . 1 ) by L75 , L130 , FINSEQ_4:36
.= C33 by L72 , L83 , PARTFUN1:def 6;
L132: C33 <= D21 by L131 , L70 , L93 , L113 , L63;
L133: (D21 = C33 or D21 = ( C33 + 1 )) by L132 , L129 , NAT_1:9;
thus L134: ( C33 + 1 ) in ( SUCC (C33 , R7) ) by L133 , L74 , L90 , L81 , L79 , L94;
let C35 being (Element of ( NAT ));
reconsider D23 = C33 , D24 = C35 as (Element of ( NAT ));
reconsider D25 = <* D23 , D24 *> as non  empty (FinSequence of ( NAT ));
L135: ( len D25 ) = 2 by FINSEQ_1:44;
L136: 2 in ( dom D25 ) by L135 , FINSEQ_3:25;
L137: 1 in ( dom D25 ) by L135 , FINSEQ_3:25;
L138: ( D25 /. 1 ) = ( D25 . 1 ) by L137 , PARTFUN1:def 6
.= C33 by FINSEQ_1:44;
assume L139: C35 in ( SUCC (C33 , R7) );
L140:
now
let C36 being (Element of ( NAT ));
assume L141: (1 <= C36 & C36 < ( len D25 ));
L142: (C36 <> ( 0 ) & C36 < 2) by L141 , FINSEQ_1:44;
L143: C36 = 1 by L142 , NAT_1:26;
L144: ( D25 /. C36 ) = ( D25 . 1 ) by L143 , L137 , PARTFUN1:def 6
.= C33 by FINSEQ_1:44;
L145: ( D25 /. ( C36 + 1 ) ) = ( D25 . 2 ) by L136 , L143 , PARTFUN1:def 6
.= C35 by FINSEQ_1:44;
thus L146: ( D25 /. ( C36 + 1 ) ) in ( SUCC (( D25 /. C36 ) , R7) ) by L145 , L139 , L144;
end;
L147: ( D25 /. ( len D25 ) ) = ( D25 . 2 ) by L135 , L136 , PARTFUN1:def 6
.= C35 by FINSEQ_1:44;
thus L148: C33 <= C35 by L147 , L70 , L138 , L140 , L63;
end;
assume L149: (for B19 being (Element of ( NAT )) holds (( B19 + 1 ) in ( SUCC (B19 , R7) ) & (for B20 being (Element of ( NAT )) holds (B20 in ( SUCC (B19 , R7) ) implies B19 <= B20))));
thus L150: R7 is  standard
proof
let C37 , C38 being (Element of ( NAT ));
thus L151: (C37 <= C38 implies (ex B21 being non  empty (FinSequence of ( NAT )) st (( B21 /. 1 ) = C37 & ( B21 /. ( len B21 ) ) = C38 & (for R3 being (Element of ( NAT )) holds ((1 <= R3 & R3 < ( len B21 )) implies ( B21 /. ( R3 + 1 ) ) in ( SUCC (( B21 /. R3 ) , R7) ))))))
proof
assume L152: C37 <= C38;
per cases  by L152 , XXREAL_0:1;
suppose L153: C37 = C38;

thus L154: (ex B22 being non  empty (FinSequence of ( NAT )) st (( B22 /. 1 ) = C37 & ( B22 /. ( len B22 ) ) = C38 & (for R4 being (Element of ( NAT )) holds ((1 <= R4 & R4 < ( len B22 )) implies ( B22 /. ( R4 + 1 ) ) in ( SUCC (( B22 /. R4 ) , R7) ))))) by L153 , L65;
end;
suppose L155: C37 < C38;

thus L156: (ex B23 being non  empty (FinSequence of ( NAT )) st (( B23 /. 1 ) = C37 & ( B23 /. ( len B23 ) ) = C38 & (for R4 being (Element of ( NAT )) holds ((1 <= R4 & R4 < ( len B23 )) implies ( B23 /. ( R4 + 1 ) ) in ( SUCC (( B23 /. R4 ) , R7) )))))
proof
set D26 = ( C38 -' C37 );
deffunc H1(Nat) = ( ( C37 + $1 ) -' 1 );
consider C39 being (FinSequence of ( NAT )) such that L157: ( len C39 ) = ( D26 + 1 ) and L158: (for B24 being Nat holds (B24 in ( dom C39 ) implies ( C39 . B24 ) = H1(B24))) from FINSEQ_2:sch 1;
reconsider D27 = C39 as non  empty (FinSequence of ( NAT )) by L157;
take D27;
L159: 1 <= ( D26 + 1 ) by NAT_1:11;
L160: 1 in ( dom D27 ) by L159 , L157 , FINSEQ_3:25;
thus L161: ( D27 /. 1 ) = ( D27 . 1 ) by L160 , PARTFUN1:def 6
.= ( ( C37 + 1 ) -' 1 ) by L158 , L160
.= C37 by NAT_D:34;
L162: ( C37 + 1 ) <= C38 by L155 , INT_1:7;
L163: 1 <= ( C38 - C37 ) by L162 , XREAL_1:19;
L164: ( 0 ) <= ( C38 - C37 ) by L163 , XXREAL_0:2;
L165: D26 = ( C38 - C37 ) by L164 , XREAL_0:def 2;
L166: ( len D27 ) in ( dom D27 ) by L157 , L159 , FINSEQ_3:25;
thus L167: ( D27 /. ( len D27 ) ) = ( D27 . ( len D27 ) ) by L166 , PARTFUN1:def 6
.= ( ( C37 + ( D26 + 1 ) ) -' 1 ) by L157 , L158 , L166
.= ( ( ( C37 + D26 ) + 1 ) -' 1 )
.= C38 by L165 , NAT_D:34;
let C40 being (Element of ( NAT ));
assume that
L168: 1 <= C40
and
L169: C40 < ( len D27 );
L170: C40 in ( dom D27 ) by L168 , L169 , FINSEQ_3:25;
L171: ( D27 /. C40 ) = ( D27 . C40 ) by L170 , PARTFUN1:def 6
.= ( ( C37 + C40 ) -' 1 ) by L158 , L170;
L172: C40 <= ( C37 + C40 ) by NAT_1:11;
L173: (1 <= ( C40 + 1 ) & ( C40 + 1 ) <= ( len D27 )) by L168 , L169 , NAT_1:13;
L174: ( C40 + 1 ) in ( dom D27 ) by L173 , FINSEQ_3:25;
L175: ( D27 /. ( C40 + 1 ) ) = ( D27 . ( C40 + 1 ) ) by L174 , PARTFUN1:def 6
.= ( ( C37 + ( C40 + 1 ) ) -' 1 ) by L158 , L174
.= ( ( ( C37 + C40 ) + 1 ) -' 1 )
.= ( ( ( C37 + C40 ) -' 1 ) + 1 ) by L168 , L172 , NAT_D:38 , XXREAL_0:2;
thus L176: thesis by L175 , L149 , L171;
end;

end;
end;

given C41 being non  empty (FinSequence of ( NAT )) such that
L158: ( C41 /. 1 ) = C37
and
L159: ( C41 /. ( len C41 ) ) = C38
and
L160: (for B25 being (Element of ( NAT )) holds ((1 <= B25 & B25 < ( len C41 )) implies ( C41 /. ( B25 + 1 ) ) in ( SUCC (( C41 /. B25 ) , R7) )));

defpred S1[ (Element of ( NAT )) ] means ((1 <= $1 & $1 <= ( len C41 )) implies (ex B26 being (Element of ( NAT )) st (( C41 /. $1 ) = B26 & C37 <= B26)));
L161:
now
let C42 being (Element of ( NAT ));
assume that
L162: S1[ C42 ];
L163:
now
assume that
L164: 1 <= ( C42 + 1 )
and
L165: ( C42 + 1 ) <= ( len C41 );
per cases  by NAT_1:3;
suppose L166: C42 = ( 0 );

thus L167: (ex B27 being (Element of ( NAT )) st (( C41 /. ( C42 + 1 ) ) = B27 & C37 <= B27)) by L166 , L158;
end;
suppose L168: C42 > ( 0 );

set D28 = ( C41 /. ( C42 + 1 ) );
consider C43 being (Element of ( NAT )) such that L169: ( C41 /. C42 ) = C43 and L170: C37 <= C43 by L162 , L165 , L168 , NAT_1:13 , NAT_1:14;
reconsider D29 = D28 as (Element of ( NAT ));
L171: C42 < ( len C41 ) by L165 , NAT_1:13;
L172: ( C41 /. ( C42 + 1 ) ) in ( SUCC (( C41 /. C42 ) , R7) ) by L171 , L160 , L168 , NAT_1:14;
L173: C43 <= D29 by L172 , L149 , L169;
thus L174: (ex B28 being (Element of ( NAT )) st (( C41 /. ( C42 + 1 ) ) = B28 & C37 <= B28)) by L173 , L170 , XXREAL_0:2;
end;
end;
thus L176: S1[ ( C42 + 1 ) ] by L163;
end;
L177: 1 <= ( len C41 ) by NAT_1:14;
L178: S1[ ( 0 ) ];
L179: (for B29 being (Element of ( NAT )) holds S1[ B29 ]) from NAT_1:sch 1(L178 , L161);
L180: (ex B30 being (Element of ( NAT )) st (( C41 /. ( len C41 ) ) = B30 & C37 <= B30)) by L179 , L177;
thus L181: thesis by L180 , L159;
end;

end;
set D30 = { [ 1 , ( 0 ) , ( 0 ) ] , [ ( 0 ) , ( 0 ) , ( 0 ) ] };
begin
definition
let C44 being  with_zero set;
func STC C44 ->  strict AMI-Struct over C44 means 
:L151: ((the carrier of it) = { ( 0 ) } & (the ZeroF of it) = ( 0 ) & (the InstructionsF of it) = { [ ( 0 ) , ( 0 ) , ( 0 ) ] , [ 1 , ( 0 ) , ( 0 ) ] } & (the Object-Kind of it) = ( ( 0 ) .--> ( 0 ) ) & (the ValuesF of it) = ( C44 --> ( NAT ) ) & (ex B31 being (Function of ( product ( the_Values_of it ) ) , ( product ( the_Values_of it ) )) st ((for B32 being (Element of ( product ( the_Values_of it ) )) holds ( B31 . B32 ) = ( B32 +* ( ( 0 ) .--> ( succ ( B32 . ( 0 ) ) ) ) )) & (the Execution of it) = ( ( [ 1 , ( 0 ) , ( 0 ) ] .--> B31 ) +* ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( the_Values_of it ) ) ) ) ))));
existence
proof
set D31 = { ( 0 ) };
set D32 = ( C44 --> ( NAT ) );
reconsider D33 = ( 0 ) as (Element of D31) by TARSKI:def 1;
reconsider D34 = [ ( 0 ) , ( 0 ) , ( 0 ) ] as (Element of D30) by TARSKI:def 2;
L152: ( 0 ) in C44 by MEASURE6:def 2;
L153: ( D32 * ( ( 0 ) .--> ( 0 ) ) ) = ( ( 0 ) .--> ( NAT ) ) by L152 , FUNCOP_1:89;
L154: ( dom ( D32 * ( ( 0 ) .--> ( 0 ) ) ) ) = D31 by L153 , FUNCOP_1:13;
L155: ( dom ( ( 0 ) .--> ( 0 ) ) ) = D31 by FUNCOP_1:13;
L156: ( rng ( ( 0 ) .--> ( 0 ) ) ) = { ( 0 ) } by FUNCOP_1:88;
L157: ( rng ( ( 0 ) .--> ( 0 ) ) ) c= C44 by L156 , L152 , ZFMISC_1:31;
reconsider D35 = ( ( 0 ) .--> ( 0 ) ) as (Function of D31 , C44) by L157 , L155 , RELSET_1:4;
deffunc H2((Element of ( product ( D32 * D35 ) ))) = ( $1 +* ( ( 0 ) .--> ( succ ( $1 . ( 0 ) ) ) ) );
L158:
now
let C45 being (Element of ( product ( D32 * D35 ) ));
L159:
now
thus L160: ( dom ( C45 +* ( ( 0 ) .--> ( succ ( C45 . ( 0 ) ) ) ) ) ) = ( ( dom C45 ) \/ ( dom ( ( 0 ) .--> ( succ ( C45 . ( 0 ) ) ) ) ) ) by FUNCT_4:def 1
.= ( ( dom C45 ) \/ { ( 0 ) } ) by FUNCOP_1:13
.= ( { ( 0 ) } \/ { ( 0 ) } ) by PARTFUN1:def 2
.= ( dom ( D32 * D35 ) ) by L154;
let C46 being set;
L161: ( dom ( ( 0 ) .--> ( succ ( C45 . ( 0 ) ) ) ) ) = { ( 0 ) } by FUNCOP_1:13;
assume L162: C46 in ( dom ( D32 * D35 ) );
L163: C46 = ( 0 ) by L162 , TARSKI:def 1;
L164: ( ( D32 * D35 ) . C46 ) = ( NAT ) by L162 , L153 , FUNCOP_1:7;
L165: ( ( C45 +* ( ( 0 ) .--> ( succ ( C45 . ( 0 ) ) ) ) ) . C46 ) = ( ( ( 0 ) .--> ( succ ( C45 . ( 0 ) ) ) ) . C46 ) by L161 , L162 , FUNCT_4:13
.= ( succ ( C45 . ( 0 ) ) ) by L162 , FUNCOP_1:7;
L166: ( 0 ) in ( dom ( D32 * D35 ) ) by L154 , TARSKI:def 1;
reconsider D36 = ( C45 . ( 0 ) ) as (Element of ( NAT )) by L166 , L163 , L164 , CARD_3:9;
L167: ( succ D36 ) in ( NAT );
thus L168: ( ( C45 +* ( ( 0 ) .--> ( succ ( C45 . ( 0 ) ) ) ) ) . C46 ) in ( ( D32 * D35 ) . C46 ) by L167 , L164 , L165;
end;
thus L169: H2(C45) in ( product ( D32 * D35 ) ) by L159 , CARD_3:9;
end;
consider C47 being (Function of ( product ( D32 * D35 ) ) , ( product ( D32 * D35 ) )) such that L170: (for B33 being (Element of ( product ( D32 * D35 ) )) holds ( C47 . B33 ) = H2(B33)) from FUNCT_2:sch 8(L158);
set D37 = ( ( [ 1 , ( 0 ) , ( 0 ) ] .--> C47 ) +* ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( D32 * D35 ) ) ) ) );
L171: ( dom D37 ) = ( ( dom ( [ 1 , ( 0 ) , ( 0 ) ] .--> C47 ) ) \/ ( dom ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( D32 * D35 ) ) ) ) ) ) by FUNCT_4:def 1
.= ( { [ 1 , ( 0 ) , ( 0 ) ] } \/ ( dom ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( D32 * D35 ) ) ) ) ) ) by FUNCOP_1:13
.= ( { [ 1 , ( 0 ) , ( 0 ) ] } \/ { [ ( 0 ) , ( 0 ) , ( 0 ) ] } ) by FUNCOP_1:13
.= D30 by ENUMSET1:1;
L172: (( rng ( [ 1 , ( 0 ) , ( 0 ) ] .--> C47 ) ) c= { C47 } & ( rng ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( D32 * D35 ) ) ) ) ) c= { ( id ( product ( D32 * D35 ) ) ) }) by FUNCOP_1:13;
L173: ( rng D37 ) c= ( ( rng ( [ 1 , ( 0 ) , ( 0 ) ] .--> C47 ) ) \/ ( rng ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( D32 * D35 ) ) ) ) ) ) by FUNCT_4:17;
L174: ( rng D37 ) c= ( Funcs (( product ( D32 * D35 ) ) , ( product ( D32 * D35 ) )) )
proof
let C48 being set;
assume L175: C48 in ( rng D37 );
L176: (C48 in ( rng ( [ 1 , ( 0 ) , ( 0 ) ] .--> C47 ) ) or C48 in ( rng ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( D32 * D35 ) ) ) ) )) by L175 , L173 , XBOOLE_0:def 3;
L177: (C48 = C47 or C48 = ( id ( product ( D32 * D35 ) ) )) by L176 , L172 , TARSKI:def 1;
thus L178: thesis by L177 , FUNCT_2:9;
end;
reconsider D38 = D37 as (Function of D30 , ( Funcs (( product ( D32 * D35 ) ) , ( product ( D32 * D35 ) )) )) by L174 , L171 , FUNCT_2:def 1 , RELSET_1:4;
set D39 = ( C44 --> ( NAT ) );
set D40 = AMI-Struct (# D31 , D33 , D30 , D35 , D39 , D38 #);
take (D40 qua  strict AMI-Struct over C44);
thus L179: (the carrier of D40) = { ( 0 ) };
thus L180: (the ZeroF of D40) = ( 0 );
thus L181: (the InstructionsF of D40) = { [ ( 0 ) , ( 0 ) , ( 0 ) ] , [ 1 , ( 0 ) , ( 0 ) ] };
thus L182: (the Object-Kind of D40) = ( ( 0 ) .--> ( 0 ) );
thus L183: (the ValuesF of D40) = ( C44 --> ( NAT ) );
reconsider D41 = C47 as (Function of ( product ( the_Values_of D40 ) ) , ( product ( the_Values_of D40 ) ));
take D41;
thus L184: (for B34 being (Element of ( product ( the_Values_of D40 ) )) holds ( D41 . B34 ) = ( B34 +* ( ( 0 ) .--> ( succ ( B34 . ( 0 ) ) ) ) )) by L170;
thus L185: thesis;
end;
uniqueness
proof
let C49 , C50 being  strict AMI-Struct over C44;
assume that
L186: ((the carrier of C49) = { ( 0 ) } & (the ZeroF of C49) = ( 0 ) & (the InstructionsF of C49) = { [ ( 0 ) , ( 0 ) , ( 0 ) ] , [ 1 , ( 0 ) , ( 0 ) ] })
and
L187: (the Object-Kind of C49) = ( ( 0 ) .--> ( 0 ) )
and
L188: (the ValuesF of C49) = ( C44 --> ( NAT ) );
given C51 being (Function of ( product ( the_Values_of C49 ) ) , ( product ( the_Values_of C49 ) )) such that
L189: (for B35 being (Element of ( product ( the_Values_of C49 ) )) holds ( C51 . B35 ) = ( B35 +* ( ( 0 ) .--> ( succ ( B35 . ( 0 ) ) ) ) ))
and
L190: (the Execution of C49) = ( ( [ 1 , ( 0 ) , ( 0 ) ] .--> C51 ) +* ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( the_Values_of C49 ) ) ) ) );

assume that
L191: ((the carrier of C50) = { ( 0 ) } & (the ZeroF of C50) = ( 0 ) & (the InstructionsF of C50) = { [ ( 0 ) , ( 0 ) , ( 0 ) ] , [ 1 , ( 0 ) , ( 0 ) ] })
and
L192: (the Object-Kind of C50) = ( ( 0 ) .--> ( 0 ) )
and
L193: (the ValuesF of C50) = ( C44 --> ( NAT ) );
given C52 being (Function of ( product ( the_Values_of C50 ) ) , ( product ( the_Values_of C50 ) )) such that
L194: (for B36 being (Element of ( product ( the_Values_of C50 ) )) holds ( C52 . B36 ) = ( B36 +* ( ( 0 ) .--> ( succ ( B36 . ( 0 ) ) ) ) ))
and
L195: (the Execution of C50) = ( ( [ 1 , ( 0 ) , ( 0 ) ] .--> C52 ) +* ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( the_Values_of C50 ) ) ) ) );

L196: ( the_Values_of C49 ) = ( the_Values_of C50 ) by L187 , L188 , L192 , L193;
L197:
now
let C53 being (Element of ( product ( the_Values_of C49 ) ));
thus L198: ( C51 . C53 ) = ( C53 +* ( ( 0 ) .--> ( succ ( C53 . ( 0 ) ) ) ) ) by L189
.= ( C52 . C53 ) by L194 , L196;
end;
thus L199: thesis by L197 , L186 , L187 , L190 , L191 , L192 , L195 , L188 , L193 , FUNCT_2:63;
end;
end;
registration
let C54 being  with_zero set;
cluster ( STC C54 ) ->  finite non  empty;
coherence by L151;
end;
registration
let C55 being  with_zero set;
cluster ( STC C55 ) ->  with_non-empty_values;
coherence
proof
let C56 being set;
set D42 = ( STC C55 );
set D43 = ( the_Values_of D42 );
assume L202: C56 in ( dom D43 );
L203: ( (the Object-Kind of D42) . C56 ) in ( dom (the ValuesF of D42) ) by L202 , FUNCT_1:11;
L204: (the ValuesF of D42) = ( C55 --> ( NAT ) ) by L151;
L205: ( (the Object-Kind of D42) . C56 ) in C55 by L203;
L206: ( D43 . C56 ) = ( (the ValuesF of D42) . ( (the Object-Kind of D42) . C56 ) ) by L202 , FUNCT_1:12
.= ( NAT ) by L205 , L204 , FUNCOP_1:7;
thus L207: ( D43 . C56 ) is non  empty by L206;
end;
end;
registration
let C57 being  with_zero set;
cluster ( STC C57 ) ->  IC-Ins-separated;
coherence
proof
set D44 = ( STC C57 );
set D45 = ( the_Values_of D44 );
L209: ( 0 ) in { ( 0 ) } by TARSKI:def 1;
L210: ( the_Values_of D44 ) = ( (the ValuesF of D44) * (the Object-Kind of D44) )
.= ( (the ValuesF of D44) * ( ( 0 ) .--> ( 0 ) ) ) by L151
.= ( ( C57 --> ( NAT ) ) * ( ( 0 ) .--> ( 0 ) ) ) by L151;
L211: ( 0 ) in C57 by MEASURE6:def 2;
L212: ( D45 . ( 0 ) ) = ( ( ( 0 ) .--> ( NAT ) ) . ( 0 ) ) by L211 , L210 , FUNCOP_1:89
.= ( NAT ) by L209 , FUNCOP_1:7;
L213: ( Values ( IC D44 ) ) = ( NAT ) by L212 , L151;
thus L214: ( STC C57 ) is  IC-Ins-separated by L213 , MEMSTR_0:def 6;
end;
end;
L216: (for R6 being  with_zero set holds (for B37 being (Instruction of ( STC R6 )) holds (for B38 being (State of ( STC R6 )) holds (( InsCode B37 ) = 1 implies ( ( Exec (B37 , B38) ) . ( IC ( STC R6 ) ) ) = ( succ ( IC B38 ) )))))
proof
let R6 being  with_zero set;
let C58 being (Instruction of ( STC R6 ));
let C59 being (State of ( STC R6 ));
set D46 = ( STC R6 );
assume L217: ( InsCode C58 ) = 1;
L218:
now
assume L219: C58 in { [ ( 0 ) , ( 0 ) , ( 0 ) ] };
L220: C58 = [ ( 0 ) , ( 0 ) , ( 0 ) ] by L219 , TARSKI:def 1;
thus L221: contradiction by L220 , L217 , RECDEF_2:def 1;
end;
L222: (the InstructionsF of D46) = D30 by L151;
L223: (C58 = [ 1 , ( 0 ) , ( 0 ) ] or C58 = [ ( 0 ) , ( 0 ) , ( 0 ) ]) by L222 , TARSKI:def 2;
L224: C58 in { [ 1 , ( 0 ) , ( 0 ) ] } by L223 , L217 , RECDEF_2:def 1 , TARSKI:def 1;
L225: ( 0 ) in { ( 0 ) } by TARSKI:def 1;
L226: ( 0 ) in ( dom ( ( 0 ) .--> ( succ ( C59 . ( 0 ) ) ) ) ) by L225 , FUNCOP_1:13;
consider C60 being (Function of ( product ( the_Values_of D46 ) ) , ( product ( the_Values_of D46 ) )) such that L227: (for B39 being (Element of ( product ( the_Values_of D46 ) )) holds ( C60 . B39 ) = ( B39 +* ( ( 0 ) .--> ( succ ( B39 . ( 0 ) ) ) ) )) and L228: (the Execution of D46) = ( ( [ 1 , ( 0 ) , ( 0 ) ] .--> C60 ) +* ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( the_Values_of D46 ) ) ) ) ) by L151;
L229: (for B40 being (State of D46) holds ( C60 . B40 ) = ( B40 +* ( ( 0 ) .--> ( succ ( B40 . ( 0 ) ) ) ) ))
proof
let C61 being (State of D46);
reconsider D47 = C61 as (Element of ( product ( the_Values_of D46 ) )) by CARD_3:107;
L230: ( C60 . D47 ) = ( D47 +* ( ( 0 ) .--> ( succ ( D47 . ( 0 ) ) ) ) ) by L227;
thus L231: thesis by L230;
end;
L232: (the ZeroF of D46) = ( 0 ) by L151;
L233: ( dom ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( the_Values_of D46 ) ) ) ) ) = { [ ( 0 ) , ( 0 ) , ( 0 ) ] } by FUNCOP_1:13;
L234: ( (the Execution of D46) . C58 ) = ( ( [ 1 , ( 0 ) , ( 0 ) ] .--> C60 ) . C58 ) by L233 , L228 , L218 , FUNCT_4:11
.= C60 by L224 , FUNCOP_1:7;
thus L235: ( ( Exec (C58 , C59) ) . ( IC ( STC R6 ) ) ) = ( ( C59 +* ( ( 0 ) .--> ( succ ( C59 . ( 0 ) ) ) ) ) . ( 0 ) ) by L234 , L232 , L229
.= ( ( ( 0 ) .--> ( succ ( C59 . ( 0 ) ) ) ) . ( 0 ) ) by L226 , FUNCT_4:13
.= ( succ ( IC C59 ) ) by L232 , L225 , FUNCOP_1:7;
end;
theorem
L236: (for R6 being  with_zero set holds (for B41 being (Instruction of ( STC R6 )) holds (( InsCode B41 ) = ( 0 ) implies B41 is  halting)))
proof
let R6 being  with_zero set;
let C62 being (Instruction of ( STC R6 ));
set D48 = ( STC R6 );
L237: (the InstructionsF of D48) = D30 by L151;
L238: (C62 = [ 1 , ( 0 ) , ( 0 ) ] or C62 = [ ( 0 ) , ( 0 ) , ( 0 ) ]) by L237 , TARSKI:def 2;
assume L239: ( InsCode C62 ) = ( 0 );
L240: C62 in { [ ( 0 ) , ( 0 ) , ( 0 ) ] } by L239 , L238 , RECDEF_2:def 1 , TARSKI:def 1;
let C63 being (State of D48);
reconsider D49 = C63 as (Element of ( product ( the_Values_of D48 ) )) by CARD_3:107;
L241: ((ex B42 being (Function of ( product ( the_Values_of D48 ) ) , ( product ( the_Values_of D48 ) )) st ((for B43 being (Element of ( product ( the_Values_of D48 ) )) holds ( B42 . B43 ) = ( B43 +* ( ( 0 ) .--> ( succ ( B43 . ( 0 ) ) ) ) )) & (the Execution of D48) = ( ( [ 1 , ( 0 ) , ( 0 ) ] .--> B42 ) +* ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( the_Values_of D48 ) ) ) ) ))) & ( dom ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( the_Values_of D48 ) ) ) ) ) = { [ ( 0 ) , ( 0 ) , ( 0 ) ] }) by L151 , FUNCOP_1:13;
L242: ( (the Execution of D48) . C62 ) = ( ( { [ ( 0 ) , ( 0 ) , ( 0 ) ] } --> ( id ( product ( the_Values_of D48 ) ) ) ) . C62 ) by L241 , L240 , FUNCT_4:13
.= ( id ( product ( the_Values_of D48 ) ) ) by L240 , FUNCOP_1:7;
L243: ( ( (the Execution of D48) . C62 ) . D49 ) = D49 by L242 , FUNCT_1:18;
thus L244: thesis by L243;
end;
theorem
L245: (for R6 being  with_zero set holds (for B44 being (Instruction of ( STC R6 )) holds (( InsCode B44 ) = 1 implies B44 is non  halting)))
proof
let R6 being  with_zero set;
let C64 being (Instruction of ( STC R6 ));
set D50 = ( STC R6 );
set D51 = the (State of D50);
assume L246: ( InsCode C64 ) = 1;
L247: ( ( Exec (C64 , D51) ) . ( IC D50 ) ) = ( succ ( IC D51 ) ) by L246 , L216;
assume L248: (for B45 being (State of D50) holds ( Exec (C64 , B45) ) = B45);
L249: ( ( Exec (C64 , D51) ) . ( IC D50 ) ) = ( IC D51 ) by L248;
thus L250: thesis by L249 , L247;
end;
theorem
L251: (for R6 being  with_zero set holds (for B46 being (Element of (the InstructionsF of ( STC R6 ))) holds (( InsCode B46 ) = 1 or ( InsCode B46 ) = ( 0 ))))
proof
let R6 being  with_zero set;
let C65 being (Element of (the InstructionsF of ( STC R6 )));
L252: (the InstructionsF of ( STC R6 )) = D30 by L151;
L253: (C65 = [ 1 , ( 0 ) , ( 0 ) ] or C65 = [ ( 0 ) , ( 0 ) , ( 0 ) ]) by L252 , TARSKI:def 2;
thus L254: thesis by L253 , RECDEF_2:def 1;
end;
theorem
L255: (for R6 being  with_zero set holds (for B47 being (Instruction of ( STC R6 )) holds B47 is  jump-only))
proof
let R6 being  with_zero set;
let C66 being (Instruction of ( STC R6 ));
set D52 = ( STC R6 );
let C67 being (State of D52);
let C68 being (Object of D52);
let C69 being (Instruction of D52);
assume that
L256: ( InsCode C69 ) = ( InsCode C66 )
and
L257: C68 in ( Data-Locations D52 );
L258: (the ZeroF of D52) = ( 0 ) by L151;
L259: ( Data-Locations D52 ) = ( { ( 0 ) } \ { ( 0 ) } ) by L258 , L151
.= ( {} ) by XBOOLE_1:37;
thus L260: thesis by L259 , L257;
end;
registration
let R6 being  with_zero set;
cluster  ->  ins-loc-free for (Instruction of ( STC R6 ));
coherence
proof
let C70 being (Instruction of ( STC R6 ));
L261: C70 in (the InstructionsF of ( STC R6 ));
L262: C70 in { [ ( 0 ) , ( 0 ) , ( 0 ) ] , [ 1 , ( 0 ) , ( 0 ) ] } by L261 , L151;
L263: (C70 = [ ( 0 ) , ( 0 ) , ( 0 ) ] or C70 = [ 1 , ( 0 ) , ( 0 ) ]) by L262 , TARSKI:def 2;
thus L264: ( JumpPart C70 ) is  empty by L263 , RECDEF_2:def 2;
end;
end;
L266: (for R5 being Nat holds (for R6 being  with_zero set holds (for B48 being (Element of ( NAT )) holds (for B49 being (Element of (the InstructionsF of ( STC R6 ))) holds ((B48 = R5 & ( InsCode B49 ) = 1) implies ( NIC (B49 , B48) ) = { ( R5 + 1 ) })))))
proof
let R5 being Nat;
let R6 being  with_zero set;
let C71 being (Element of ( NAT ));
let C72 being (Element of (the InstructionsF of ( STC R6 )));
assume that
L267: C71 = R5
and
L268: ( InsCode C72 ) = 1;
set D53 = ( STC R6 );
set D54 = { ( IC ( Exec (C72 , B50) ) ) where B50 is (Element of ( product ( the_Values_of ( STC R6 ) ) )) : ( IC B50 ) = C71 };
L269:
now
set D55 = ( ( NAT ) --> C72 );
set D56 = the (State of D53);
reconsider D57 = C71 as (Element of ( Values ( IC D53 ) )) by MEMSTR_0:def 6;
set D58 = ( ( IC D53 ) .--> D57 );
L270: ( dom D58 ) = { ( IC D53 ) } by FUNCOP_1:13;
let C73 being set;
reconsider D59 = ( D56 +* D58 ) as (Element of ( product ( the_Values_of ( STC R6 ) ) )) by CARD_3:107;
L271: ( D55 /. C71 ) = C72 by FUNCOP_1:7;
thus L272:now
assume L273: C73 in D54;
L274: (ex B51 being (Element of ( product ( the_Values_of ( STC R6 ) ) )) st (C73 = ( IC ( Exec (C72 , B51) ) ) & ( IC B51 ) = C71)) by L273;
L275: C73 = ( succ R5 ) by L274 , L267 , L268 , L216
.= ( R5 + 1 );
thus L276: C73 in { ( R5 + 1 ) } by L275 , TARSKI:def 1;
end;
assume L277: C73 in { ( R5 + 1 ) };
L278: C73 = ( succ R5 ) by L277 , TARSKI:def 1;
L279: ( IC D53 ) in ( dom D58 ) by L270 , TARSKI:def 1;
L280: ( IC D59 ) = ( D58 . ( IC D53 ) ) by L279 , FUNCT_4:13
.= R5 by L267 , FUNCOP_1:72;
L281: ( IC ( Following (D55 , D59) ) ) = ( succ R5 ) by L280 , L267 , L268 , L271 , L216;
thus L282: C73 in D54 by L281 , L267 , L278 , L280 , L271;
end;
thus L283: thesis by L269 , TARSKI:1;
end;
L284: (for R6 being  with_zero set holds (for B52 being (Element of (the InstructionsF of ( STC R6 ))) holds ( JUMP B52 ) is  empty))
proof
let R6 being  with_zero set;
let C74 being (Element of (the InstructionsF of ( STC R6 )));
per cases  by L251;
suppose L285: ( InsCode C74 ) = 1;

reconsider D60 = ( 0 ) , D61 = 1 as (Element of ( NAT ));
set D62 = { ( NIC (C74 , B53) ) where B53 is (Element of ( NAT )) : (not contradiction) };
assume L286: (not thesis);
consider C75 being set such that L287: C75 in ( meet D62 ) by L286 , XBOOLE_0:def 1;
L288: ( NIC (C74 , D60) ) in D62;
L289: { ( ( 0 ) + 1 ) } in D62 by L288 , L285 , L266;
L290: C75 in { 1 } by L289 , L287 , SETFAM_1:def 1;
L291: C75 = 1 by L290 , TARSKI:def 1;
L292: ( NIC (C74 , D61) ) in D62;
L293: { ( 1 + 1 ) } in D62 by L292 , L285 , L266;
L294: C75 in { 2 } by L293 , L287 , SETFAM_1:def 1;
thus L295: contradiction by L294 , L291 , TARSKI:def 1;
end;
suppose L296: ( InsCode C74 ) = ( 0 );

reconsider D63 = C74 as (Instruction of ( STC R6 ));
L297: (for B54 being (Element of ( NAT )) holds ( NIC (D63 , B54) ) = { B54 }) by L296 , L47 , L236;
thus L298: thesis by L297 , L36;
end;
end;
theorem
L300: (for R5 being Nat holds (for R6 being  with_zero set holds (for B55 being (Element of ( NAT )) holds (B55 = R5 implies ( SUCC (B55 , ( STC R6 )) ) = { R5 , ( R5 + 1 ) }))))
proof
let R5 being Nat;
let R6 being  with_zero set;
let C76 being (Element of ( NAT ));
assume that
L301: C76 = R5;
set D64 = ( STC R6 );
set D65 = { ( ( NIC (B56 , C76) ) \ ( JUMP B56 ) ) where B56 is (Element of (the InstructionsF of ( STC R6 ))) : (not contradiction) };
L302:
now
let C77 being set;
thus L303:now
assume L304: C77 in D65;
consider C78 being (Element of (the InstructionsF of ( STC R6 ))) such that L305: C77 = ( ( NIC (C78 , C76) ) \ ( JUMP C78 ) ) and L306: (not contradiction) by L304;
reconsider D66 = C78 as (Instruction of ( STC R6 ));
L307:
now
per cases  by L251;
suppose L308: ( InsCode D66 ) = 1;

L309: ( JUMP D66 ) = ( {} ) by L284;
L310: C77 = { ( R5 + 1 ) } by L309 , L301 , L305 , L308 , L266;
thus L311: C77 in { { R5 } , { ( R5 + 1 ) } } by L310 , TARSKI:def 2;
end;
suppose L312: ( InsCode D66 ) = ( 0 );

L313: ( JUMP D66 ) = ( {} ) by L284;
L314: C77 = { R5 } by L313 , L301 , L305 , L312 , L47 , L236;
thus L315: C77 in { { R5 } , { ( R5 + 1 ) } } by L314 , TARSKI:def 2;
end;
end;
thus L317: C77 in { { R5 } , { ( R5 + 1 ) } } by L307;
end;
assume L318: C77 in { { R5 } , { ( R5 + 1 ) } };
per cases  by L318 , TARSKI:def 2;
suppose L319: C77 = { R5 };

L320: ( halt D64 ) = [ ( 0 ) , ( {} ) , ( {} ) ];
reconsider D67 = [ ( 0 ) , ( 0 ) , ( 0 ) ] as (Instruction of D64) by L320;
L321: (( JUMP D67 ) = ( {} ) & ( InsCode D67 ) = ( 0 )) by L284 , RECDEF_2:def 1;
L322: ( ( NIC (D67 , C76) ) \ ( JUMP D67 ) ) = C77 by L321 , L301 , L319 , L47 , L236;
thus L323: C77 in D65 by L322;
end;
suppose L324: C77 = { ( R5 + 1 ) };

set D68 = [ 1 , ( 0 ) , ( 0 ) ];
L325: D68 in D30 by TARSKI:def 2;
reconsider D69 = D68 as (Instruction of D64) by L325 , L151;
L326: (( JUMP D69 ) = ( {} ) & ( InsCode D69 ) = 1) by L284 , RECDEF_2:def 1;
L327: ( ( NIC (D69 , C76) ) \ ( JUMP D69 ) ) = C77 by L326 , L301 , L324 , L266;
thus L328: C77 in D65 by L327;
end;
end;
L330: D65 = { { R5 } , { ( R5 + 1 ) } } by L302 , TARSKI:1;
thus L331: thesis by L330 , ZFMISC_1:26;
end;
registration
let C79 being  with_zero set;
cluster ( STC C79 ) ->  standard;
coherence
proof
set D70 = ( STC C79 );
L332:
now
let C80 being (Element of ( NAT ));
L333: ( SUCC (C80 , ( STC C79 )) ) = { C80 , ( C80 + 1 ) } by L300;
thus L334: ( C80 + 1 ) in ( SUCC (C80 , ( STC C79 )) ) by L333 , TARSKI:def 2;
let C81 being (Element of ( NAT ));
assume L335: C81 in ( SUCC (C80 , ( STC C79 )) );
L336: (C81 = C80 or C81 = ( C80 + 1 )) by L335 , L333 , TARSKI:def 2;
thus L337: C80 <= C81 by L336 , NAT_1:11;
end;
thus L338: thesis by L332 , L68;
end;
end;
registration
let C82 being  with_zero set;
cluster ( STC C82 ) ->  halting;
coherence
proof
set D71 = ( halt ( STC C82 ) );
L340: ( InsCode D71 ) = ( 0 ) by RECDEF_2:def 1;
thus L341: D71 is  halting by L340 , L236;
end;
end;
registration
let C83 being  with_zero set;
cluster  standard  halting for  IC-Ins-separated non  empty  with_non-empty_values  IC-Ins-separated non  empty  with_non-empty_values  IC-Ins-separated non  empty  with_non-empty_values  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C83;
existence
proof
take ( STC C83 );
thus L343: thesis;
end;
end;
theorem
L345: (for R6 being  with_zero set holds (for B57 being (Instruction of ( STC R6 )) holds (for B58 being (State of ( STC R6 )) holds (( InsCode B57 ) = 1 implies ( ( Exec (B57 , B58) ) . ( IC ( STC R6 ) ) ) = ( succ ( IC B58 ) ))))) by L216;
theorem
L346: (for R6 being  with_zero set holds (for B59 being (Element of ( NAT )) holds (for B60 being (Element of (the InstructionsF of ( STC R6 ))) holds (( InsCode B60 ) = 1 implies ( NIC (B60 , B59) ) = { ( succ B59 ) })))) by L266;
theorem
L347: (for R6 being  with_zero set holds (for B61 being (Element of ( NAT )) holds ( SUCC (B61 , ( STC R6 )) ) = { B61 , ( succ B61 ) })) by L300;
definition
let C84 being  with_zero set;
let C85 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C84;
let C86 being (Instruction of C85);
attr C86 is  sequential
means
(for B62 being (State of C85) holds ( ( Exec (C86 , B62) ) . ( IC C85 ) ) = ( succ ( IC B62 ) ));
end;
theorem
L349: (for R6 being  with_zero set holds (for B63 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B64 being (Element of ( NAT )) holds (for B65 being (Instruction of B63) holds (B65 is  sequential implies ( NIC (B65 , B64) ) = { ( succ B64 ) })))))
proof
let R6 being  with_zero set;
let C87 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C88 being (Element of ( NAT ));
let C89 being (Instruction of C87);
assume that
L350: (for B66 being (State of C87) holds ( ( Exec (C89 , B66) ) . ( IC C87 ) ) = ( succ ( IC B66 ) ));
L351:
now
let C90 being set;
L352:
now
reconsider D72 = C88 as (Element of ( Values ( IC C87 ) )) by MEMSTR_0:def 6;
set D73 = C89;
set D74 = the (State of C87);
set D75 = the (Instruction-Sequence of C87);
assume L353: C90 = ( succ C88 );
reconsider D76 = ( D74 +* (( IC C87 ) , D72) ) as (Element of ( product ( the_Values_of C87 ) )) by CARD_3:107;
L354: C88 in ( NAT );
L355: C88 in ( dom D75 ) by L354 , PARTFUN1:def 2;
L356: ( ( D75 +* (C88 , C89) ) /. C88 ) = ( ( D75 +* (C88 , C89) ) . C88 ) by PBOOLE:143
.= C89 by L355 , FUNCT_7:31;
L357: ( IC C87 ) in ( dom D74 ) by MEMSTR_0:2;
L358: ( IC D76 ) = C88 by L357 , FUNCT_7:31;
L359: ( IC ( Following (( D75 +* (C88 , C89) ) , D76) ) ) = ( succ C88 ) by L358 , L350 , L356;
thus L360: C90 in { ( IC ( Exec (C89 , B67) ) ) where B67 is (Element of ( product ( the_Values_of C87 ) )) : ( IC B67 ) = C88 } by L359 , L353 , L358 , L356;
end;
L361:
now
assume L362: C90 in { ( IC ( Exec (C89 , B68) ) ) where B68 is (Element of ( product ( the_Values_of C87 ) )) : ( IC B68 ) = C88 };
L363: (ex B69 being (Element of ( product ( the_Values_of C87 ) )) st (C90 = ( IC ( Exec (C89 , B69) ) ) & ( IC B69 ) = C88)) by L362;
thus L364: C90 = ( succ C88 ) by L363 , L350;
end;
thus L365: (C90 in { ( succ C88 ) } iff C90 in { ( IC ( Exec (C89 , B70) ) ) where B70 is (Element of ( product ( the_Values_of C87 ) )) : ( IC B70 ) = C88 }) by L361 , L352 , TARSKI:def 1;
end;
thus L366: thesis by L351 , TARSKI:1;
end;
registration
let R6 being  with_zero set;
let C91 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
cluster  sequential -> non  halting for (Instruction of C91);
coherence
proof
let C92 being (Instruction of C91);
assume that
L367: C92 is  sequential;
set D77 = the (State of C91);
L368: ( NIC (C92 , ( IC D77 )) ) = { ( succ ( IC D77 ) ) } by L367 , L349;
L369: ( NIC (C92 , ( IC D77 )) ) <> { ( IC D77 ) } by L368 , ORDINAL1:9 , ZFMISC_1:3;
thus L370: thesis by L369 , L47;
end;
cluster  halting -> non  sequential for (Instruction of C91);
coherence;
end;
theorem
L372: (for R6 being  with_zero set holds (for B71 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B72 being (Instruction of B71) holds (( JUMP B72 ) is non  empty implies B72 is non  sequential))))
proof
let R6 being  with_zero set;
let C93 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C94 being (Instruction of C93);
set D78 = { ( NIC (C94 , B73) ) where B73 is (Element of ( NAT )) : (not contradiction) };
assume L373: ( JUMP C94 ) is non  empty;
consider C95 being set such that L374: C95 in ( JUMP C94 ) by L373 , XBOOLE_0:def 1;
reconsider D79 = C95 as (Element of ( NAT )) by L374;
L375: ( NIC (C94 , D79) ) in D78;
L376: D79 in ( NIC (C94 , D79) ) by L375 , L374 , SETFAM_1:def 1;
consider C96 being (Element of ( product ( the_Values_of C93 ) )) such that L377: (D79 = ( IC ( Exec (C94 , C96) ) ) & ( IC C96 ) = D79) by L376;
take C96;
thus L378: thesis by L377;
end;
begin
definition
let C97 being  with_zero set;
let C98 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C97;
let C99 being  finite (preProgram of C98);
attr C99 is  really-closed
means
:L379: (for B74 being (Element of ( NAT )) holds (B74 in ( dom C99 ) implies ( NIC (( C99 /. B74 ) , B74) ) c= ( dom C99 )));
end;
definition
let C100 being  with_zero set;
let C101 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C100;
let C102 being ( NAT ) -defined (the InstructionsF of C101) -valued Function;
attr C102 is  paraclosed
means
(for B75 being ( 0 ) -started (State of C101) holds (for B76 being (Instruction-Sequence of C101) holds (C102 c= B76 implies (for B77 being (Element of ( NAT )) holds ( IC ( Comput (B76 , B75 , B77) ) ) in ( dom C102 )))));
end;
definition
let C103 being  with_zero set;
let C104 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C103;
let C105 being ( NAT ) -defined (the InstructionsF of C104) -valued Function;
attr C105 is  parahalting
means
(for B78 being ( 0 ) -started (State of C104) holds (for B79 being (Instruction-Sequence of C104) holds (C105 c= B79 implies B79 halts_on B78)));
end;
theorem
L383: (for B80 being  with_zero set holds (for B81 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over B80 holds (for B82 being  finite (preProgram of B81) holds (B82 is  really-closed iff (for B83 being (State of B81) holds (( IC B83 ) in ( dom B82 ) implies (for B84 being (Element of ( NAT )) holds ( IC ( Comput (B82 , B83 , B84) ) ) in ( dom B82 ))))))))
proof
let C106 being  with_zero set;
let C107 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C106;
let C108 being  finite (preProgram of C107);
thus L384: (C108 is  really-closed implies (for B85 being (State of C107) holds (( IC B85 ) in ( dom C108 ) implies (for B86 being (Element of ( NAT )) holds ( IC ( Comput (C108 , B85 , B86) ) ) in ( dom C108 )))))
proof
assume L385: C108 is  really-closed;
let C109 being (State of C107);
assume that
L386: ( IC C109 ) in ( dom C108 );
defpred S2[ (Element of ( NAT )) ] means ( IC ( Comput (C108 , C109 , $1) ) ) in ( dom C108 );
L387:
now
let C110 being (Element of ( NAT ));
assume that
L388: S2[ C110 ];
reconsider D80 = ( Comput (C108 , C109 , C110) ) as (Element of ( product ( the_Values_of C107 ) )) by CARD_3:107;
set D81 = ( IC ( Comput (C108 , C109 , C110) ) );
L389: ( IC ( Following (C108 , D80) ) ) in ( NIC (( C108 /. D81 ) , D81) );
L390: ( Comput (C108 , C109 , ( C110 + 1 )) ) = ( Following (C108 , D80) ) by EXTPRO_1:3;
L391: ( NIC (( C108 /. D81 ) , D81) ) c= ( dom C108 ) by L385 , L388 , L379;
thus L392: S2[ ( C110 + 1 ) ] by L391 , L389 , L390;
end;
L393: S2[ ( 0 ) ] by L386;
thus L394: (for B87 being (Element of ( NAT )) holds S2[ B87 ]) from NAT_1:sch 1(L393 , L387);
end;

assume L395: (for B88 being (State of C107) holds (( IC B88 ) in ( dom C108 ) implies (for B89 being (Element of ( NAT )) holds ( IC ( Comput (C108 , B88 , B89) ) ) in ( dom C108 ))));
let C111 being (Element of ( NAT ));
assume that
L396: C111 in ( dom C108 );
let R1 being set;
assume L397: R1 in ( NIC (( C108 /. C111 ) , C111) );
consider C112 being (Element of ( product ( the_Values_of C107 ) )) such that L398: R1 = ( IC ( Exec (( C108 /. C111 ) , C112) ) ) and L399: ( IC C112 ) = C111 by L397;
reconsider D82 = C112 as (State of C107);
L400: ( IC ( Comput (C108 , D82 , ( ( 0 ) + 1 )) ) ) = ( IC ( Following (C108 , ( Comput (C108 , D82 , ( 0 )) )) ) ) by EXTPRO_1:3
.= ( IC ( Following (C108 , D82) ) )
.= ( IC ( Exec (( C108 /. ( IC D82 ) ) , D82) ) );
thus L401: R1 in ( dom C108 ) by L400 , L398 , L399 , L395 , L396;
end;
L402: (for B90 being  with_zero set holds (for B91 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over B90 holds (for B92 being  finite (preProgram of B91) holds (B92 is  really-closed iff (for B93 being (State of B91) holds (( IC B93 ) in ( dom B92 ) implies (for B94 being (Instruction-Sequence of B91) holds (B92 c= B94 implies (for B95 being (Element of ( NAT )) holds ( IC ( Comput (B94 , B93 , B95) ) ) in ( dom B92 ))))))))))
proof
let C113 being  with_zero set;
let C114 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C113;
let C115 being  finite (preProgram of C114);
thus L403: (C115 is  really-closed implies (for B96 being (State of C114) holds (( IC B96 ) in ( dom C115 ) implies (for B97 being (Instruction-Sequence of C114) holds (C115 c= B97 implies (for B98 being (Element of ( NAT )) holds ( IC ( Comput (B97 , B96 , B98) ) ) in ( dom C115 )))))))
proof
assume L404: C115 is  really-closed;
let C116 being (State of C114);
assume that
L405: ( IC C116 ) in ( dom C115 );
let C117 being (Instruction-Sequence of C114);
assume that
L406: C115 c= C117;
defpred S3[ (Element of ( NAT )) ] means ( IC ( Comput (C117 , C116 , $1) ) ) in ( dom C115 );
L407:
now
let C118 being (Element of ( NAT ));
assume that
L408: S3[ C118 ];
reconsider D83 = ( Comput (C117 , C116 , C118) ) as (Element of ( product ( the_Values_of C114 ) )) by CARD_3:107;
set D84 = ( IC ( Comput (C117 , C116 , C118) ) );
L409: ( IC ( Following (C117 , D83) ) ) in ( NIC (( C117 /. D84 ) , D84) );
L410: ( Comput (C117 , C116 , ( C118 + 1 )) ) = ( Following (C117 , D83) ) by EXTPRO_1:3;
L411: ( C117 /. D84 ) = ( C115 /. D84 ) by L408 , L406 , PARTFUN2:61;
L412: ( NIC (( C117 /. D84 ) , D84) ) c= ( dom C115 ) by L411 , L404 , L408 , L379;
thus L413: S3[ ( C118 + 1 ) ] by L412 , L409 , L410;
end;
L414: S3[ ( 0 ) ] by L405;
thus L415: (for B99 being (Element of ( NAT )) holds S3[ B99 ]) from NAT_1:sch 1(L414 , L407);
end;

assume L416: (for B100 being (State of C114) holds (( IC B100 ) in ( dom C115 ) implies (for B101 being (Instruction-Sequence of C114) holds (C115 c= B101 implies (for B102 being (Element of ( NAT )) holds ( IC ( Comput (B101 , B100 , B102) ) ) in ( dom C115 ))))));
L417: (for B103 being (State of C114) holds (( IC B103 ) in ( dom C115 ) implies (for B104 being (Element of ( NAT )) holds ( IC ( Comput (C115 , B103 , B104) ) ) in ( dom C115 ))))
proof
let C119 being (State of C114);
assume that
L418: ( IC C119 ) in ( dom C115 );
consider C120 being (Instruction-Sequence of C114) such that L419: C115 c= C120 by PBOOLE:145;
let C121 being (Element of ( NAT ));
L420: ( IC ( Comput (C120 , C119 , C121) ) ) in ( dom C115 ) by L416 , L418 , L419;
defpred S4[ Nat ] means ( Comput (C120 , C119 , $1) ) = ( Comput (C115 , C119 , $1) );
L421: S4[ ( 0 ) ];
L422: (for B105 being Nat holds (S4[ B105 ] implies S4[ ( B105 + 1 ) ]))
proof
let C122 being Nat;
assume L423: S4[ C122 ];
reconsider D85 = C122 as (Element of ( NAT )) by ORDINAL1:def 12;
L424: ( IC ( Comput (C120 , C119 , D85) ) ) in ( dom C115 ) by L416 , L418 , L419;
L425: ( Comput (C120 , C119 , ( C122 + 1 )) ) = ( Following (C120 , ( Comput (C115 , C119 , C122) )) ) by L423 , EXTPRO_1:3
.= ( Following (C115 , ( Comput (C115 , C119 , C122) )) ) by L424 , L419 , L423 , PARTFUN2:61
.= ( Comput (C115 , C119 , ( C122 + 1 )) ) by EXTPRO_1:3;
thus L426: S4[ ( C122 + 1 ) ] by L425;
end;
L427: (for B106 being Nat holds S4[ B106 ]) from NAT_1:sch 2(L421 , L422);
thus L428: ( IC ( Comput (C115 , C119 , C121) ) ) in ( dom C115 ) by L427 , L420;
end;
thus L429: thesis by L417 , L383;
end;
theorem
L430: (for R6 being  with_zero set holds (for B107 being  standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B108 being ( NAT ) -defined (the InstructionsF of B107) -valued  finite Function holds ((B108 is  really-closed & ( 0 ) in ( dom B108 )) implies B108 is  paraclosed))))
proof
let R6 being  with_zero set;
let C123 being  standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C124 being ( NAT ) -defined (the InstructionsF of C123) -valued  finite Function;
assume L431: C124 is  really-closed;
assume L432: ( 0 ) in ( dom C124 );
let C125 being ( 0 ) -started (State of C123);
L433: ( IC C125 ) = ( 0 ) by MEMSTR_0:def 11;
let C126 being (Instruction-Sequence of C123);
assume that
L434: C124 c= C126;
let C127 being (Element of ( NAT ));
thus L435: ( IC ( Comput (C126 , C125 , C127) ) ) in ( dom C124 ) by L431 , L433 , L434 , L402 , L432;
end;
theorem
L436: (for R6 being  with_zero set holds (for B109 being  standard  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (( ( 0 ) .--> ( halt B109 ) ) qua ( NAT ) -defined (the InstructionsF of B109) -valued  finite Function) is  really-closed))
proof
let R6 being  with_zero set;
let C128 being  standard  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
reconsider D86 = ( ( 0 ) .--> ( halt C128 ) ) as ( NAT ) -defined (the InstructionsF of C128) -valued  finite Function;
let C129 being (Element of ( NAT ));
assume L437: C129 in ( dom ( ( 0 ) .--> ( halt C128 ) ) );
L438: ( dom D86 ) = { ( 0 ) } by FUNCOP_1:13;
L439: C129 = ( 0 ) by L437 , TARSKI:def 1;
L440: ( D86 /. C129 ) = ( D86 . C129 ) by L437 , PARTFUN1:def 6
.= ( halt C128 ) by L439 , FUNCOP_1:72;
thus L441: thesis by L440 , L438 , L439 , L47;
end;
registration
let C130 being  with_zero set;
let C131 being  standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C130;
cluster  really-closed  initial non  empty ->  paraclosed for ( NAT ) -defined (the InstructionsF of C131) -valued  finite ( NAT ) -defined (the InstructionsF of C131) -valued  finite ( NAT ) -defined (the InstructionsF of C131) -valued  finite ( NAT ) -defined (the InstructionsF of C131) -valued  finite Function;
coherence
proof
let C132 being ( NAT ) -defined (the InstructionsF of C131) -valued  finite Function;
assume L442: C132 is  really-closed;
assume L443: C132 is  initial non  empty;
L444: ( 0 ) in ( dom C132 ) by L443 , AFINSQ_1:65;
thus L445: thesis by L444 , L442 , L430;
end;
end;
L447:
now
let R6 being  with_zero set;
let C133 being  standard  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
set D87 = <% ( halt C133 ) %>;
L448: ( dom D87 ) = { ( 0 ) } by FUNCOP_1:13;
L449: ( card ( dom D87 ) ) = 1 by L448 , CARD_1:30;
L450: ( LastLoc D87 ) = ( ( card D87 ) -' 1 ) by AFINSQ_1:70
.= ( 0 ) by L449 , XREAL_1:232;
thus L451: ( D87 . ( LastLoc D87 ) ) = ( halt C133 ) by L450 , FUNCOP_1:72;
let C134 being Nat;
assume that
L452: ( D87 . C134 ) = ( halt C133 );
assume L453: C134 in ( dom D87 );
thus L454: C134 = ( LastLoc D87 ) by L453 , L448 , L450 , TARSKI:def 1;
end;
registration
let C135 being  with_zero set;
let C136 being  standard  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C135;
cluster  trivial  really-closed  initial non  empty for ( NAT ) -defined (the InstructionsF of C136) -valued  finite ( NAT ) -defined (the InstructionsF of C136) -valued  finite ( NAT ) -defined (the InstructionsF of C136) -valued  finite ( NAT ) -defined (the InstructionsF of C136) -valued  finite Function;
existence
proof
reconsider D88 = <% ( halt C136 ) %> as  initial non  empty ( NAT ) -defined (the InstructionsF of C136) -valued  finite Function;
take D88;
thus L455: thesis by L436;
end;
end;
registration
let C137 being  with_zero set;
let C138 being  standard  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C137;
cluster  halt-ending  unique-halt  trivial  really-closed for  initial non  empty ( NAT ) -defined (the InstructionsF of C138) -valued  finite  initial non  empty ( NAT ) -defined (the InstructionsF of C138) -valued  finite  initial non  empty ( NAT ) -defined (the InstructionsF of C138) -valued  finite  initial non  empty ( NAT ) -defined (the InstructionsF of C138) -valued  finite Function;
existence
proof
reconsider D89 = <% ( halt C138 ) %> as  initial non  empty ( NAT ) -defined (the InstructionsF of C138) -valued  finite Function;
take D89;
thus L457: ( D89 . ( LastLoc D89 ) ) = ( halt C138 ) by L447;
thus L458: (for B110 being Nat holds ((( D89 . B110 ) = ( halt C138 ) & B110 in ( dom D89 )) implies B110 = ( LastLoc D89 ))) by L447;
thus L459: thesis by L436;
end;
end;
registration
let C139 being  with_zero set;
let C140 being  standard  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C139;
cluster  really-closed for (MacroInstruction of C140);
existence
proof
reconsider D90 = <% ( halt C140 ) %> as (Program of C140);
L461: (( D90 . ( LastLoc D90 ) ) = ( halt C140 ) & (for B111 being (Element of ( NAT )) holds ((( D90 . B111 ) = ( halt C140 ) & B111 in ( dom D90 )) implies B111 = ( LastLoc D90 )))) by L447;
reconsider D91 = D90 as (MacroInstruction of C140) by L461 , COMPOS_1:def 14;
take D91;
thus L462: thesis by L436;
end;
end;
theorem
L464: (for R6 being  with_zero set holds (for B112 being (Instruction of ( Trivial-AMI R6 )) holds B112 is  halting))
proof
let R6 being  with_zero set;
let C141 being (Instruction of ( Trivial-AMI R6 ));
set D92 = ( Trivial-AMI R6 );
L465: (the InstructionsF of D92) = { [ ( 0 ) , ( {} ) , ( {} ) ] } by EXTPRO_1:def 1;
let C142 being (State of D92);
reconsider D93 = C142 as (Element of ( product ( the_Values_of D92 ) )) by CARD_3:107;
L466: ((the Object-Kind of D92) = ( ( 0 ) .--> ( 0 ) ) & (the ValuesF of D92) = ( R6 --> ( NAT ) )) by EXTPRO_1:def 1;
L467: ( (the Execution of D92) . C141 ) = ( ( [ ( 0 ) , ( {} ) , ( {} ) ] .--> ( id ( product ( the_Values_of D92 ) ) ) ) . C141 ) by L466 , EXTPRO_1:def 1
.= ( id ( product ( the_Values_of D92 ) ) ) by L465 , FUNCOP_1:7;
L468: ( ( (the Execution of D92) . C141 ) . D93 ) = D93 by L467 , FUNCT_1:18;
thus L469: thesis by L468;
end;
theorem
L470: (for R6 being  with_zero set holds (for B113 being (Element of (the InstructionsF of ( Trivial-AMI R6 ))) holds ( InsCode B113 ) = ( 0 )))
proof
let R6 being  with_zero set;
let C143 being (Element of (the InstructionsF of ( Trivial-AMI R6 )));
L471: (the InstructionsF of ( Trivial-AMI R6 )) = { [ ( 0 ) , ( {} ) , ( {} ) ] } by EXTPRO_1:def 1;
L472: C143 = [ ( 0 ) , ( {} ) , ( {} ) ] by L471 , TARSKI:def 1;
thus L473: thesis by L472 , RECDEF_2:def 1;
end;
begin
theorem
L474: (for B114 being  with_zero set holds (for B115 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over B114 holds (for B116 being (Instruction of B115) holds (for B117 being (Element of ( NAT )) holds ( JUMP B116 ) c= ( NIC (B116 , B117) )))))
proof
let C144 being  with_zero set;
let C145 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C144;
let C146 being (Instruction of C145);
let C147 being (Element of ( NAT ));
set D94 = { ( NIC (C146 , B118) ) where B118 is (Element of ( NAT )) : (not contradiction) };
let C148 being set;
L475: ( NIC (C146 , C147) ) in D94;
assume L476: C148 in ( JUMP C146 );
thus L477: thesis by L476 , L475 , SETFAM_1:def 1;
end;
theorem
L478: (for R6 being  with_zero set holds (for B119 being (Instruction of ( STC R6 )) holds (for B120 being (State of ( STC R6 )) holds (( InsCode B119 ) = 1 implies ( Exec (B119 , B120) ) = ( IncIC (B120 , 1) )))))
proof
let R6 being  with_zero set;
let C149 being (Instruction of ( STC R6 ));
let C150 being (State of ( STC R6 ));
set D95 = ( STC R6 );
assume L479: ( InsCode C149 ) = 1;
L480:
now
assume L481: C149 in { [ ( 0 ) , ( 0 ) , ( 0 ) ] };
L482: C149 = [ ( 0 ) , ( 0 ) , ( 0 ) ] by L481 , TARSKI:def 1;
thus L483: contradiction by L482 , L479 , RECDEF_2:def 1;
end;
L484: (the InstructionsF of D95) = D30 by L151;
L485: (C149 = [ 1 , ( 0 ) , ( 0 ) ] or C149 = [ ( 0 ) , ( 0 ) , ( 0 ) ]) by L484 , TARSKI:def 2;
L486: C149 in { [ 1 , ( 0 ) , ( 0 ) ] } by L485 , L479 , RECDEF_2:def 1 , TARSKI:def 1;
consider C151 being (Function of ( product ( the_Values_of D95 ) ) , ( product ( the_Values_of D95 ) )) such that L487: (for B121 being (Element of ( product ( the_Values_of D95 ) )) holds ( C151 . B121 ) = ( B121 +* ( ( 0 ) .--> ( succ ( B121 . ( 0 ) ) ) ) )) and L488: (the Execution of D95) = ( ( [ 1 , ( 0 ) , ( 0 ) ] .--> C151 ) +* ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( the_Values_of D95 ) ) ) ) ) by L151;
L489: (for B122 being (State of D95) holds ( C151 . B122 ) = ( B122 +* ( ( 0 ) .--> ( succ ( B122 . ( 0 ) ) ) ) ))
proof
let C152 being (State of D95);
reconsider D96 = C152 as (Element of ( product ( the_Values_of D95 ) )) by CARD_3:107;
L490: ( C151 . D96 ) = ( D96 +* ( ( 0 ) .--> ( succ ( D96 . ( 0 ) ) ) ) ) by L487;
thus L491: thesis by L490;
end;
L492: (the ZeroF of D95) = ( 0 ) by L151;
L493: ( Start-At (( ( IC C150 ) + 1 ) , D95) ) = ( ( 0 ) .--> ( succ ( C150 . ( 0 ) ) ) ) by L492 , NAT_1:38;
L494: ( dom ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( the_Values_of D95 ) ) ) ) ) = { [ ( 0 ) , ( 0 ) , ( 0 ) ] } by FUNCOP_1:13;
L495: ( (the Execution of D95) . C149 ) = ( ( [ 1 , ( 0 ) , ( 0 ) ] .--> C151 ) . C149 ) by L494 , L488 , L480 , FUNCT_4:11
.= C151 by L486 , FUNCOP_1:7;
thus L496: ( Exec (C149 , C150) ) = ( IncIC (C150 , 1) ) by L495 , L493 , L489;
end;
registration
let R6 being  with_zero set;
let C153 being (PartState of ( STC R6 ));
cluster ( DataPart C153 ) ->  empty;
coherence
proof
L497: ( Data-Locations ( STC R6 ) ) = ( (the carrier of ( STC R6 )) \ { ( 0 ) } ) by L151
.= ( { ( 0 ) } \ { ( 0 ) } ) by L151
.= ( {} ) by XBOOLE_1:37;
thus L498: thesis by L497;
end;
end;
theorem
L500: (for B123 being  with_zero set holds (for B124 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over B123 holds (for B125 being  finite (preProgram of B124) holds (B125 is  really-closed iff (for B126 being (State of B124) holds (( IC B126 ) in ( dom B125 ) implies (for B127 being (Instruction-Sequence of B124) holds (B125 c= B127 implies (for B128 being (Element of ( NAT )) holds ( IC ( Comput (B127 , B126 , B128) ) ) in ( dom B125 )))))))))) by L402;
registration
let C154 being  with_zero set;
let C155 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C154;
cluster  parahalting for  finite non  halt-free non  empty ( NAT ) -defined (the InstructionsF of C155) -valued  finite non  halt-free non  empty ( NAT ) -defined (the InstructionsF of C155) -valued  finite non  halt-free non  empty ( NAT ) -defined (the InstructionsF of C155) -valued  finite non  halt-free non  empty ( NAT ) -defined (the InstructionsF of C155) -valued Function;
existence
proof
take ( Stop C155 );
let C156 being ( 0 ) -started (State of C155);
let C157 being (Instruction-Sequence of C155);
assume that
L501: ( Stop C155 ) c= C157;
take ( 0 );
L502: ( 0 ) in ( dom ( Stop C155 ) ) by COMPOS_1:3;
L503: ( dom ( Stop C155 ) ) c= ( dom C157 ) by L501 , RELAT_1:11;
L504: ( 0 ) in ( dom C157 ) by L503 , L502;
L505: ( IC C156 ) = ( 0 ) by MEMSTR_0:def 11;
thus L506: ( IC ( Comput (C157 , C156 , ( 0 )) ) ) in ( dom C157 ) by L505 , L504;
thus L507: ( CurInstr (C157 , ( Comput (C157 , C156 , ( 0 )) )) ) = ( C157 /. ( 0 ) ) by L505
.= ( C157 . ( 0 ) ) by L504 , PARTFUN1:def 6
.= ( ( Stop C155 ) . ( 0 ) ) by L501 , L502 , GRFUNC_1:2
.= ( halt C155 ) by AFINSQ_1:34;
end;
end;
