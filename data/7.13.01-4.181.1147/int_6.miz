:: Modular Integer Arithmetic
::  by Christoph Schwarzweller
::
:: Received May 13, 2008
:: Copyright (c) 2008-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FINSEQ_1, RELAT_1, TARSKI, VALUED_0, ORDINAL1, RFINSEQ,
      XXREAL_0, ARYTM_1, SUBSET_1, FUNCT_1, ARYTM_3, INT_1, ORDINAL4, XBOOLE_0,
      NAT_1, VALUED_1, CARD_3, BINOP_2, SETWISEO, BINOP_1, SETWOP_2, CARD_1,
      FINSOP_1, PARTFUN1, COMPLEX1, INT_2, PARTFUN3, XREAL_0, INT_6;
 notations TARSKI, XBOOLE_0, SUBSET_1, INT_1, INT_2, ORDINAL1, NUMBERS,
      RELAT_1, PARTFUN1, PARTFUN3, XXREAL_0, XREAL_0, FUNCT_1,
      VALUED_0, VALUED_1, BINOP_2, SETWISEO, RFINSEQ, BINOP_1, FINSEQ_1,
      SETWOP_2, RVSUM_1, XCMPLX_0, NAT_1, FINSOP_1;
 constructors FINSOP_1, RFINSEQ, INT_2, BINOP_2, REAL_1, SETWISEO, SETWOP_2,
      PARTFUN3, XXREAL_0, RVSUM_1, BINOP_1, RELSET_1;
 registrations NUMBERS, XREAL_0, NAT_1, INT_1, RELAT_1, FINSEQ_1, RVSUM_1,
      XBOOLE_0, MEMBERED, BINOP_2, ORDINAL1, XXREAL_0, VALUED_0, VALUED_1,
      FUNCT_1, CARD_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions INT_2, XCMPLX_0, FINSEQ_1, FUNCT_1;
 theorems INT_1, FUNCT_1, FINSEQ_1, RVSUM_1, NAT_1, SETWOP_2, FINSEQ_3,
      BINOP_2, SETWISEO, TARSKI, NAT_D, INT_2, XCMPLX_0, XCMPLX_1, XREAL_1,
      RFINSEQ, FINSEQ_5, FINSEQ_2, ABSVALUE, PARTFUN3, XBOOLE_0, XXREAL_0,
      ORDINAL1, XBOOLE_1, PARTFUN1, XREAL_0, WSIERP_1, VALUED_1, COMPLEX1,
      RELAT_1;
 schemes FINSEQ_1, NAT_1, INT_1;

begin
L1: (for B1 being ( INT ) -valued FinSequence holds B1 is (FinSequence of ( INT )))
proof
let C1 being ( INT ) -valued FinSequence;
L2: ( rng C1 ) c= ( INT ) by RELAT_1:def 19;
thus L3: thesis by L2 , FINSEQ_1:def 4;
end;
registration
let C2 being  complex-valued FinSequence;
let C3 being Nat;
cluster ( C2 | C3 ) ->  complex-valued;
coherence;
end;
registration
let C4 being ( INT ) -valued FinSequence;
let C5 being Nat;
cluster ( C4 | C5 ) -> ( INT ) -valued;
coherence;
end;
registration
let C6 being ( INT ) -valued FinSequence;
let C7 being Nat;
cluster ( C6 /^ C7 ) -> ( INT ) -valued;
coherence
proof
per cases ;
suppose L6: C7 > ( len C6 );

thus L7: thesis by L6 , RFINSEQ:def 1;
end;
suppose L8: C7 <= ( len C6 );

L9:
now
reconsider D1 = C6 as (FinSequence of ( INT )) by L1;
let C8 being set;
reconsider D2 = C7 as (Element of ( NAT )) by ORDINAL1:def 12;
L10: ( rng C6 ) c= ( INT ) by RELAT_1:def 19;
assume L11: C8 in ( rng ( C6 /^ C7 ) );
consider C9 being set such that L12: C9 in ( dom ( C6 /^ C7 ) ) and L13: ( ( C6 /^ C7 ) . C9 ) = C8 by L11 , FUNCT_1:def 3;
reconsider D3 = C9 as (Element of ( NAT )) by L12;
L14: ( D3 + D2 ) in ( dom D1 ) by L12 , FINSEQ_5:26;
L15: ( C6 . ( D3 + C7 ) ) in ( rng C6 ) by L14 , FUNCT_1:def 3;
L16: ( ( C6 /^ C7 ) . D3 ) = ( C6 . ( D3 + C7 ) ) by L8 , L12 , RFINSEQ:def 1;
thus L17: C8 in ( INT ) by L16 , L13 , L15 , L10;
end;
L18: ( rng ( C6 /^ C7 ) ) c= ( INT ) by L9 , TARSKI:def 3;
thus L19: thesis by L18 , RELAT_1:def 19;
end;
end;
end;
registration
let C10 being Integer;
cluster <* C10 *> -> ( INT ) -valued;
coherence
proof
L22: (for B2 being set holds (B2 in { C10 } implies B2 in ( INT ))) by INT_1:def 2;
L23: { C10 } c= ( INT ) by L22 , TARSKI:def 3;
L24: ( rng <* C10 *> ) = { C10 } by FINSEQ_1:39;
thus L25: thesis by L24 , L23 , RELAT_1:def 19;
end;
end;
registration
let C11 , C12 being ( INT ) -valued FinSequence;
cluster ( C11 ^ C12 ) -> ( INT ) -valued;
coherence
proof
L27:
now
let C13 being set;
L28: ( rng ( C11 ^ C12 ) ) = ( ( rng C11 ) \/ ( rng C12 ) ) by FINSEQ_1:31;
assume L29: C13 in ( rng ( C11 ^ C12 ) );
L30:
now
per cases  by L29 , L28 , XBOOLE_0:def 3;
case L31: C13 in ( rng C11 );
L32: ( rng C11 ) c= ( INT ) by RELAT_1:def 19;
thus L33: C13 in ( INT ) by L32 , L31;
end;
case L34: C13 in ( rng C12 );
L35: ( rng C12 ) c= ( INT ) by RELAT_1:def 19;
thus L36: C13 in ( INT ) by L35 , L34;
end;
end;
thus L38: C13 in ( INT ) by L30;
end;
L39: ( rng ( C11 ^ C12 ) ) c= ( INT ) by L27 , TARSKI:def 3;
thus L40: thesis by L39 , RELAT_1:def 19;
end;
end;
theorem
L42: (for B3 , B4 being  complex-valued FinSequence holds ( len ( B3 + B4 ) ) = ( min (( len B3 ) , ( len B4 )) ))
proof
let C14 , C15 being  complex-valued FinSequence;
set D4 = ( C14 + C15 );
consider C16 being Nat such that L43: ( dom C14 ) = ( Seg C16 ) by FINSEQ_1:def 2;
L44: C16 in ( NAT ) by ORDINAL1:def 12;
L45: ( len C14 ) = C16 by L44 , L43 , FINSEQ_1:def 3;
consider C17 being Nat such that L46: ( dom C15 ) = ( Seg C17 ) by FINSEQ_1:def 2;
L47: C17 in ( NAT ) by ORDINAL1:def 12;
L48: ( len C15 ) = C17 by L47 , L46 , FINSEQ_1:def 3;
L49: ( dom D4 ) = ( ( dom C14 ) /\ ( dom C15 ) ) by VALUED_1:def 1;
L50:
now
per cases ;
case L51: C16 <= C17;
L52: ( dom C14 ) c= ( dom C15 ) by L51 , L43 , L46 , FINSEQ_1:5;
L53: ( dom D4 ) = ( Seg C16 ) by L52 , L43 , L49 , XBOOLE_1:28;
L54: ( min (C16 , C17) ) = C16 by L51 , XXREAL_0:def 9;
thus L55: thesis by L54 , L45 , L48 , L53 , FINSEQ_1:def 3;
end;
case L56: C17 <= C16;
L57: ( dom C15 ) c= ( dom C14 ) by L56 , L43 , L46 , FINSEQ_1:5;
L58: ( dom D4 ) = ( Seg C17 ) by L57 , L46 , L49 , XBOOLE_1:28;
L59: ( min (C16 , C17) ) = C17 by L56 , XXREAL_0:def 9;
thus L60: thesis by L59 , L45 , L48 , L58 , FINSEQ_1:def 3;
end;
end;
thus L62: thesis by L50;
end;
theorem
L63: (for B5 , B6 being  complex-valued FinSequence holds ( len ( B5 - B6 ) ) = ( min (( len B5 ) , ( len B6 )) ))
proof
let C18 , C19 being  complex-valued FinSequence;
set D5 = ( C18 - C19 );
consider C20 being Nat such that L64: ( dom C18 ) = ( Seg C20 ) by FINSEQ_1:def 2;
L65: C20 in ( NAT ) by ORDINAL1:def 12;
L66: ( len C18 ) = C20 by L65 , L64 , FINSEQ_1:def 3;
consider C21 being Nat such that L67: ( dom C19 ) = ( Seg C21 ) by FINSEQ_1:def 2;
L68: C21 in ( NAT ) by ORDINAL1:def 12;
L69: ( len C19 ) = C21 by L68 , L67 , FINSEQ_1:def 3;
L70: ( dom D5 ) = ( ( dom C18 ) /\ ( dom C19 ) ) by VALUED_1:12;
L71:
now
per cases ;
case L72: C20 <= C21;
L73: ( dom C18 ) c= ( dom C19 ) by L72 , L64 , L67 , FINSEQ_1:5;
L74: ( dom D5 ) = ( Seg C20 ) by L73 , L64 , L70 , XBOOLE_1:28;
L75: ( min (C20 , C21) ) = C20 by L72 , XXREAL_0:def 9;
thus L76: thesis by L75 , L66 , L69 , L74 , FINSEQ_1:def 3;
end;
case L77: C21 <= C20;
L78: ( dom C19 ) c= ( dom C18 ) by L77 , L64 , L67 , FINSEQ_1:5;
L79: ( dom D5 ) = ( Seg C21 ) by L78 , L67 , L70 , XBOOLE_1:28;
L80: ( min (C20 , C21) ) = C21 by L77 , XXREAL_0:def 9;
thus L81: thesis by L80 , L66 , L69 , L79 , FINSEQ_1:def 3;
end;
end;
thus L83: thesis by L71;
end;
theorem
L84: (for B7 , B8 being  complex-valued FinSequence holds ( len ( B7 (#) B8 ) ) = ( min (( len B7 ) , ( len B8 )) ))
proof
let C22 , C23 being  complex-valued FinSequence;
set D6 = ( C22 (#) C23 );
consider C24 being Nat such that L85: ( dom C22 ) = ( Seg C24 ) by FINSEQ_1:def 2;
L86: C24 in ( NAT ) by ORDINAL1:def 12;
L87: ( len C22 ) = C24 by L86 , L85 , FINSEQ_1:def 3;
consider C25 being Nat such that L88: ( dom C23 ) = ( Seg C25 ) by FINSEQ_1:def 2;
L89: C25 in ( NAT ) by ORDINAL1:def 12;
L90: ( len C23 ) = C25 by L89 , L88 , FINSEQ_1:def 3;
L91: ( dom D6 ) = ( ( dom C22 ) /\ ( dom C23 ) ) by VALUED_1:def 4;
L92:
now
per cases ;
case L93: C24 <= C25;
L94: ( dom C22 ) c= ( dom C23 ) by L93 , L85 , L88 , FINSEQ_1:5;
L95: ( dom D6 ) = ( Seg C24 ) by L94 , L85 , L91 , XBOOLE_1:28;
L96: ( min (C24 , C25) ) = C24 by L93 , XXREAL_0:def 9;
thus L97: thesis by L96 , L87 , L90 , L95 , FINSEQ_1:def 3;
end;
case L98: C25 <= C24;
L99: ( dom C23 ) c= ( dom C22 ) by L98 , L85 , L88 , FINSEQ_1:5;
L100: ( dom D6 ) = ( Seg C25 ) by L99 , L88 , L91 , XBOOLE_1:28;
L101: ( min (C24 , C25) ) = C25 by L98 , XXREAL_0:def 9;
thus L102: thesis by L101 , L87 , L90 , L100 , FINSEQ_1:def 3;
end;
end;
thus L104: thesis by L92;
end;
L105: (for B9 , B10 being  complex-valued FinSequence holds (( len B9 ) = ( len B10 ) implies ( len ( B9 + B10 ) ) = ( len B9 )))
proof
let C26 , C27 being  complex-valued FinSequence;
assume L106: ( len C26 ) = ( len C27 );
thus L107: ( len ( C26 + C27 ) ) = ( min (( len C26 ) , ( len C27 )) ) by L42
.= ( len C26 ) by L106;
end;
L108: (for B11 , B12 being  complex-valued FinSequence holds (( len B11 ) = ( len B12 ) implies ( len ( B11 - B12 ) ) = ( len B11 )))
proof
let C28 , C29 being  complex-valued FinSequence;
assume L109: ( len C28 ) = ( len C29 );
thus L110: ( len ( C28 - C29 ) ) = ( min (( len C28 ) , ( len C29 )) ) by L63
.= ( len C28 ) by L109;
end;
L111: (for B13 , B14 being  complex-valued FinSequence holds (( len B13 ) = ( len B14 ) implies ( len ( B13 (#) B14 ) ) = ( len B13 )))
proof
let C30 , C31 being  complex-valued FinSequence;
assume L112: ( len C30 ) = ( len C31 );
thus L113: ( len ( C30 (#) C31 ) ) = ( min (( len C30 ) , ( len C31 )) ) by L84
.= ( len C30 ) by L112;
end;
theorem
L114: (for B15 , B16 being  complex-valued FinSequence holds (( len B15 ) = ( len B16 ) implies (for B17 being Nat holds (B17 <= ( len B15 ) implies ( ( B15 (#) B16 ) | B17 ) = ( ( B15 | B17 ) (#) ( B16 | B17 ) )))))
proof
let C32 , C33 being  complex-valued FinSequence;
assume L115: ( len C32 ) = ( len C33 );
let C34 being Nat;
set D7 = ( ( C32 (#) C33 ) | C34 );
set D8 = ( ( C32 | C34 ) (#) ( C33 | C34 ) );
assume L116: C34 <= ( len C32 );
L117: ( len ( C32 | C34 ) ) = C34 by L116 , FINSEQ_1:59;
reconsider D9 = C34 as (Element of ( NAT )) by ORDINAL1:def 12;
L118: C34 <= ( len ( C32 (#) C33 ) ) by L115 , L116 , L111;
L119: ( len D7 ) = C34 by L118 , FINSEQ_1:59;
L120: ( len ( C33 | C34 ) ) = C34 by L115 , L116 , FINSEQ_1:59;
L121: ( len D8 ) = C34 by L120 , L117 , L111;
L122:
now
L123: ( len ( C32 (#) C33 ) ) = ( len C32 ) by L115 , L111;
let C35 being Nat;
assume that
L124: 1 <= C35
and
L125: C35 <= ( len D7 );
L126: C35 in ( NAT ) by ORDINAL1:def 12;
L127: C35 in ( Seg D9 ) by L126 , L119 , L124 , L125;
L128: C35 in ( dom ( C32 | D9 ) ) by L127 , L117 , FINSEQ_1:def 3;
L129: C35 in ( dom D8 ) by L121 , L127 , FINSEQ_1:def 3;
L130: C35 in ( dom ( C33 | D9 ) ) by L120 , L127 , FINSEQ_1:def 3;
L131: C35 <= ( len C32 ) by L116 , L119 , L125 , XXREAL_0:2;
L132: C35 in ( Seg ( len ( C32 (#) C33 ) ) ) by L131 , L124 , L126 , L123;
L133: C35 in ( dom ( C32 (#) C33 ) ) by L132 , FINSEQ_1:def 3;
L134: C35 in ( dom D7 ) by L124 , L125 , FINSEQ_3:25;
thus L135: ( D7 . C35 ) = ( ( C32 (#) C33 ) . C35 ) by L134 , FUNCT_1:47
.= ( ( C32 . C35 ) * ( C33 . C35 ) ) by L133 , VALUED_1:def 4
.= ( ( ( C32 | D9 ) . C35 ) * ( C33 . C35 ) ) by L128 , FUNCT_1:47
.= ( ( ( C32 | D9 ) . C35 ) * ( ( C33 | D9 ) . C35 ) ) by L130 , FUNCT_1:47
.= ( D8 . C35 ) by L129 , VALUED_1:def 4;
end;
thus L136: thesis by L122 , L118 , L121 , FINSEQ_1:14 , FINSEQ_1:59;
end;
registration
let C36 being ( INT ) -valued FinSequence;
cluster ( Sum C36 ) ->  integer;
coherence
proof
set D10 = ( addcomplex );
consider C37 being (FinSequence of ( COMPLEX )) such that L137: C37 = C36 and L138: ( Sum C36 ) = ( ( addcomplex ) $$ C37 ) by RVSUM_1:def 10;
set D11 = ( [#] (C37 , ( the_unity_wrt D10 )) );
defpred S1[ (Element of ( NAT )) ] means ( D10 $$ (( finSeg $1 ) , ( [#] (C37 , ( the_unity_wrt D10 )) )) ) is  integer;
L139: (for B18 being (Element of ( NAT )) holds (S1[ B18 ] implies S1[ ( B18 + 1 ) ]))
proof
let C38 being (Element of ( NAT ));
L140: ( D11 . ( C38 + 1 ) ) is  integer
proof
per cases ;
suppose L141: ( C38 + 1 ) in ( dom C37 );

L142: ( D11 . ( C38 + 1 ) ) = ( C37 . ( C38 + 1 ) ) by L141 , SETWOP_2:20;
thus L143: thesis by L142 , L137;
end;
suppose L144: (not ( C38 + 1 ) in ( dom C37 ));

thus L145: thesis by L144 , BINOP_2:1 , SETWOP_2:20;
end;
end;
assume L147: S1[ C38 ];
reconsider D12 = ( D11 . ( C38 + 1 ) ) , D13 = ( D10 $$ (( finSeg C38 ) , D11) ) as  integer number by L147 , L140;
L148: (not ( C38 + 1 ) in ( Seg C38 )) by FINSEQ_3:8;
L149: ( D10 $$ (( ( finSeg C38 ) \/ {. ( C38 + 1 ) .} ) , D11) ) = ( D10 . (( D10 $$ (( finSeg C38 ) , D11) ) , ( D11 . ( C38 + 1 ) )) ) by L148 , SETWOP_2:2
.= ( D13 + D12 ) by BINOP_2:def 3;
thus L150: thesis by L149 , FINSEQ_1:9;
end;
L151: ( Seg ( 0 ) ) = ( {}. ( NAT ) );
L152: S1[ ( 0 ) ] by L151 , BINOP_2:1 , SETWISEO:31;
L153: (for B19 being (Element of ( NAT )) holds S1[ B19 ]) from NAT_1:sch 1(L152 , L139);
consider C39 being Nat such that L154: ( dom C37 ) = ( Seg C39 ) by FINSEQ_1:def 2;
L155: ( D10 $$ C37 ) = ( D10 $$ (( findom C37 ) , ( [#] (C37 , ( the_unity_wrt D10 )) )) ) by SETWOP_2:def 2;
L156: C39 in ( NAT ) by ORDINAL1:def 12;
thus L157: thesis by L156 , L138 , L155 , L154 , L153;
end;
cluster ( Product C36 ) ->  integer;
coherence
proof
set D14 = ( multcomplex );
consider C40 being (FinSequence of ( COMPLEX )) such that L158: C40 = C36 and L159: ( Product C36 ) = ( ( multcomplex ) $$ C40 ) by RVSUM_1:def 13;
set D15 = ( [#] (C40 , ( the_unity_wrt D14 )) );
defpred S2[ (Element of ( NAT )) ] means ( D14 $$ (( finSeg $1 ) , ( [#] (C40 , ( the_unity_wrt D14 )) )) ) is  integer;
L160: (for B20 being (Element of ( NAT )) holds (S2[ B20 ] implies S2[ ( B20 + 1 ) ]))
proof
let C41 being (Element of ( NAT ));
L161: ( D15 . ( C41 + 1 ) ) is  integer
proof
per cases ;
suppose L162: ( C41 + 1 ) in ( dom C40 );

L163: ( D15 . ( C41 + 1 ) ) = ( C40 . ( C41 + 1 ) ) by L162 , SETWOP_2:20;
thus L164: thesis by L163 , L158;
end;
suppose L165: (not ( C41 + 1 ) in ( dom C40 ));

thus L166: thesis by L165 , BINOP_2:6 , SETWOP_2:20;
end;
end;
assume L168: S2[ C41 ];
reconsider D16 = ( D15 . ( C41 + 1 ) ) , D17 = ( D14 $$ (( finSeg C41 ) , D15) ) as  integer number by L168 , L161;
L169: (not ( C41 + 1 ) in ( Seg C41 )) by FINSEQ_3:8;
L170: ( D14 $$ (( ( finSeg C41 ) \/ {. ( C41 + 1 ) .} ) , D15) ) = ( D14 . (( D14 $$ (( finSeg C41 ) , D15) ) , ( D15 . ( C41 + 1 ) )) ) by L169 , SETWOP_2:2
.= ( D17 * D16 ) by BINOP_2:def 5;
thus L171: thesis by L170 , FINSEQ_1:9;
end;
L172: ( Seg ( 0 ) ) = ( {}. ( NAT ) );
L173: S2[ ( 0 ) ] by L172 , BINOP_2:6 , SETWISEO:31;
L174: (for B21 being (Element of ( NAT )) holds S2[ B21 ]) from NAT_1:sch 1(L173 , L160);
consider C42 being Nat such that L175: ( dom C40 ) = ( Seg C42 ) by FINSEQ_1:def 2;
L176: ( D14 $$ C40 ) = ( D14 $$ (( findom C40 ) , ( [#] (C40 , ( the_unity_wrt D14 )) )) ) by SETWOP_2:def 2;
L177: C42 in ( NAT ) by ORDINAL1:def 12;
thus L178: thesis by L177 , L159 , L176 , L175 , L174;
end;
end;
L180: (for B22 being ( INT ) -valued FinSequence holds B22 is (FinSequence of ( REAL )))
proof
let C43 being ( INT ) -valued FinSequence;
L181: ( rng C43 ) c= ( REAL );
thus L182: thesis by L181 , FINSEQ_1:def 4;
end;
theorem
L183: (for B23 being  complex-valued FinSequence holds (for B24 being Nat holds (( B24 + 1 ) <= ( len B23 ) implies ( ( B23 | B24 ) ^ <* ( B23 . ( B24 + 1 ) ) *> ) = ( B23 | ( B24 + 1 ) ))))
proof
let C44 being  complex-valued FinSequence;
let C45 being Nat;
assume L184: ( C45 + 1 ) <= ( len C44 );
set D18 = ( ( C44 | C45 ) ^ <* ( C44 . ( C45 + 1 ) ) *> );
set D19 = ( C44 | ( C45 + 1 ) );
L185: C45 <= ( C45 + 1 ) by NAT_1:11;
reconsider D20 = D18 as  complex-valued FinSequence;
L186: ( len D20 ) = ( ( len ( C44 | C45 ) ) + ( len <* ( C44 . ( C45 + 1 ) ) *> ) ) by FINSEQ_1:22
.= ( ( len ( C44 | C45 ) ) + 1 ) by FINSEQ_1:39
.= ( C45 + 1 ) by L184 , L185 , FINSEQ_1:59 , XXREAL_0:2
.= ( len D19 ) by L184 , FINSEQ_1:59;
L187: ( dom D20 ) = ( Seg ( len D19 ) ) by L186 , FINSEQ_1:def 3
.= ( dom D19 ) by FINSEQ_1:def 3;
L188: C45 <= ( len C44 ) by L184 , L185 , XXREAL_0:2;
L189:
now
let C46 being set;
assume L190: C46 in ( dom D20 );
reconsider D21 = C46 as (Element of ( NAT )) by L190;
L191: ( dom D20 ) = ( Seg ( len D20 ) ) by FINSEQ_1:def 3;
L192: 1 <= D21 by L191 , L190 , FINSEQ_1:1;
L193: D21 <= ( len D20 ) by L190 , L191 , FINSEQ_1:1;
L194: D21 <= ( C45 + 1 ) by L193 , L184 , L186 , FINSEQ_1:59;
per cases  by L194 , XXREAL_0:1;
suppose L195: D21 = ( C45 + 1 );

L196: D21 in ( Seg ( C45 + 1 ) ) by L195 , L192;
L197: D21 in ( dom D19 ) by L196 , L184 , FINSEQ_1:17;
L198: ( dom <* ( C44 . ( C45 + 1 ) ) *> ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
L199: 1 in ( dom <* ( C44 . ( C45 + 1 ) ) *> ) by L198 , TARSKI:def 1;
L200: ( len ( C44 | C45 ) ) = C45 by L184 , L185 , FINSEQ_1:59 , XXREAL_0:2;
thus L201: ( D20 . C46 ) = ( <* ( C44 . ( C45 + 1 ) ) *> . 1 ) by L200 , L195 , L199 , FINSEQ_1:def 7
.= ( C44 . ( C45 + 1 ) ) by FINSEQ_1:40
.= ( D19 . C46 ) by L195 , L197 , FUNCT_1:47;
end;
suppose L202: D21 < ( C45 + 1 );

L203: D21 <= C45 by L202 , NAT_1:13;
L204: 1 <= D21 by L190 , L191 , FINSEQ_1:1;
L205: D21 in ( Seg C45 ) by L204 , L203;
L206: D21 in ( dom ( C44 | C45 ) ) by L205 , L188 , FINSEQ_1:17;
thus L207: ( D20 . C46 ) = ( ( C44 | C45 ) . D21 ) by L206 , FINSEQ_1:def 7
.= ( C44 . D21 ) by L206 , FUNCT_1:47
.= ( D19 . C46 ) by L187 , L190 , FUNCT_1:47;
end;
end;
thus L209: thesis by L189 , L187 , FUNCT_1:2;
end;
theorem
L210: (for B25 being  complex-valued FinSequence holds ((ex B26 being Nat st (B26 in ( dom B25 ) & ( B25 . B26 ) = ( 0 ))) implies ( Product B25 ) = ( 0 )))
proof
defpred S3[ Nat ] means (for B27 being  complex-valued FinSequence holds (( len B27 ) = $1 implies ((ex B28 being Nat st (B28 in ( dom B27 ) & ( B27 . B28 ) = ( 0 ))) implies ( Product B27 ) = ( 0 ))));
let C47 being  complex-valued FinSequence;
L211: (for B29 being (Element of ( NAT )) holds (S3[ B29 ] implies S3[ ( B29 + 1 ) ]))
proof
let C48 being (Element of ( NAT ));
assume L212: S3[ C48 ];
L213:
now
let C49 being  complex-valued FinSequence;
set D22 = ( C49 | C48 );
assume L214: ( len C49 ) = ( C48 + 1 );
L215: ( len D22 ) = C48 by L214 , FINSEQ_1:59 , NAT_1:11;
reconsider D23 = D22 as  complex-valued FinSequence;
L216: C49 = ( D23 ^ <* ( C49 . ( C48 + 1 ) ) *> ) by L214 , FINSEQ_3:55;
L217: ( Product C49 ) = ( ( Product D23 ) * ( C49 . ( C48 + 1 ) ) ) by L216 , RVSUM_1:96;
assume L218: (ex B30 being Nat st (B30 in ( dom C49 ) & ( C49 . B30 ) = ( 0 )));
per cases ;
suppose L219: ( C49 . ( C48 + 1 ) ) = ( 0 );

thus L220: ( Product C49 ) = ( 0 ) by L219 , L217;
end;
suppose L221: ( C49 . ( C48 + 1 ) ) <> ( 0 );

consider C50 being Nat such that L222: C50 in ( dom C49 ) and L223: ( C49 . C50 ) = ( 0 ) by L218;
reconsider D24 = C50 as (Element of ( NAT )) by ORDINAL1:def 12;
L224: D24 in ( Seg ( len C49 ) ) by L222 , FINSEQ_1:def 3;
L225: D24 <= ( C48 + 1 ) by L224 , L214 , FINSEQ_1:1;
L226: D24 < ( C48 + 1 ) by L225 , L221 , L223 , XXREAL_0:1;
L227: D24 <= C48 by L226 , NAT_1:13;
L228: 1 <= D24 by L224 , FINSEQ_1:1;
L229: D24 in ( Seg C48 ) by L228 , L227;
L230: D24 in ( dom D23 ) by L229 , L215 , FINSEQ_1:def 3;
L231: ( D23 . D24 ) = ( C49 . D24 ) by L230 , FUNCT_1:47;
L232: ( Product D23 ) = ( 0 ) by L231 , L212 , L215 , L223 , L230;
thus L233: ( Product C49 ) = ( 0 ) by L232 , L217;
end;
end;
thus L235: thesis by L213;
end;
L236: S3[ ( 0 ) ]
proof
let C51 being  complex-valued FinSequence;
assume L237: ( len C51 ) = ( 0 );
L238: ( Seg ( len C51 ) ) = ( {} ) by L237;
thus L239: thesis by L238 , FINSEQ_1:def 3;
end;
L240: (for B31 being (Element of ( NAT )) holds S3[ B31 ]) from NAT_1:sch 1(L236 , L211);
L241: (ex B32 being Nat st ( len C47 ) = B32);
assume L242: (ex B33 being Nat st (B33 in ( dom C47 ) & ( C47 . B33 ) = ( 0 )));
thus L243: thesis by L242 , L240 , L241;
end;
theorem
L244: (for B34 , B35 , B36 being Integer holds ( ( B35 - B36 ) mod B34 ) = ( ( ( B35 mod B34 ) - ( B36 mod B34 ) ) mod B34 ))
proof
let C52 , C53 , C54 being Integer;
per cases ;
suppose L245: C52 = ( 0 );

thus L246: ( ( C53 - C54 ) mod C52 ) = ( 0 ) by L245 , INT_1:def 10
.= ( ( ( C53 mod C52 ) - ( C54 mod C52 ) ) mod C52 ) by L245 , INT_1:def 10;
end;
suppose L247: C52 <> ( 0 );

L248: ( ( C54 mod C52 ) + ( ( C54 div C52 ) * C52 ) ) = ( ( C54 - ( ( C54 div C52 ) * C52 ) ) + ( ( C54 div C52 ) * C52 ) ) by L247 , INT_1:def 10;
L249: ( ( C53 mod C52 ) + ( ( C53 div C52 ) * C52 ) ) = ( ( C53 - ( ( C53 div C52 ) * C52 ) ) + ( ( C53 div C52 ) * C52 ) ) by L247 , INT_1:def 10;
L250: ( ( C53 - C54 ) - ( ( C53 mod C52 ) - ( C54 mod C52 ) ) ) = ( ( ( C53 div C52 ) - ( C54 div C52 ) ) * C52 ) by L249 , L248;
L251: C52 divides ( ( C53 - C54 ) - ( ( C53 mod C52 ) - ( C54 mod C52 ) ) ) by L250 , INT_1:def 3;
L252: ( C53 - C54 ) , ( ( C53 mod C52 ) - ( C54 mod C52 ) ) are_congruent_mod C52 by L251 , INT_2:15;
thus L253: thesis by L252 , NAT_D:64;
end;
end;
theorem
L255: (for B37 , B38 , B39 being Integer holds (B37 divides B38 implies ( B39 * B37 ) divides ( B39 * B38 )))
proof
let C55 , C56 , C57 being Integer;
assume L256: C55 divides C56;
consider C58 being Integer such that L257: ( C55 * C58 ) = C56 by L256 , INT_1:def 3;
L258: ( ( C55 * C57 ) * C58 ) = ( C56 * C57 ) by L257;
thus L259: thesis by L258 , INT_1:def 3;
end;
theorem
L260: (for B40 being ( INT ) -valued FinSequence holds (for B41 being Nat holds ((B41 in ( dom B40 ) & ( B40 . B41 ) <> ( 0 )) implies ( ( Product B40 ) / ( B40 . B41 ) ) is Integer)))
proof
let C59 being ( INT ) -valued FinSequence;
let C60 being Nat;
reconsider D25 = C60 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D26 = ( C59 /^ D25 ) as (FinSequence of ( INT )) by L1;
reconsider D27 = ( C59 | D25 ) as (FinSequence of ( INT )) by L1;
reconsider D28 = C59 as (FinSequence of ( INT )) by L1;
assume that
L261: C60 in ( dom C59 )
and
L262: ( C59 . C60 ) <> ( 0 );
L263: ( dom C59 ) = ( Seg ( len C59 ) ) by FINSEQ_1:def 3;
L264: 1 <= D25 by L263 , L261 , FINSEQ_1:1;
L265: ( 1 - 1 ) <= ( D25 - 1 ) by L264 , XREAL_1:9;
reconsider D29 = ( D25 - 1 ) as (Element of ( NAT )) by L265 , INT_1:3;
set D30 = ( ( C59 | D29 ) ^ ( C59 /^ D25 ) );
reconsider D31 = D30 as (FinSequence of ( INT )) by L1;
L266: D28 = ( D27 ^ D26 ) by RFINSEQ:8;
L267: ( D29 + 1 ) <= ( len C59 ) by L261 , L263 , FINSEQ_1:1;
L268: ( ( C59 | D29 ) ^ <* ( C59 . D25 ) *> ) = ( C59 | D25 ) by L267 , L183;
L269: ( Product C59 ) = ( ( Product ( ( C59 | D29 ) ^ <* ( C59 . D25 ) *> ) ) * ( Product ( C59 /^ D25 ) ) ) by L268 , L266 , RVSUM_1:97
.= ( ( ( Product ( C59 | D29 ) ) * ( Product <* ( C59 . D25 ) *> ) ) * ( Product ( C59 /^ D25 ) ) ) by RVSUM_1:97
.= ( ( ( Product ( C59 | D29 ) ) * ( Product ( C59 /^ D25 ) ) ) * ( Product <* ( C59 . D25 ) *> ) )
.= ( ( ( Product ( C59 | D29 ) ) * ( Product ( C59 /^ D25 ) ) ) * ( C59 . D25 ) ) by RVSUM_1:95
.= ( ( Product D31 ) * ( C59 . D25 ) ) by RVSUM_1:97;
L270: ( C59 . D25 ) divides ( Product C59 ) by L269 , INT_1:def 3;
thus L271: thesis by L270 , L262 , WSIERP_1:17;
end;
theorem
L272: (for B42 being ( INT ) -valued FinSequence holds (for B43 being Nat holds (B43 in ( dom B42 ) implies (ex B44 being Integer st ( B44 * ( B42 . B43 ) ) = ( Product B42 )))))
proof
let C61 being ( INT ) -valued FinSequence;
let C62 being Nat;
assume L273: C62 in ( dom C61 );
per cases ;
suppose L274: ( C61 . C62 ) <> ( 0 );

reconsider D32 = ( ( Product C61 ) / ( C61 . C62 ) ) as Integer by L274 , L273 , L260;
take D32;
thus L275: ( D32 * ( C61 . C62 ) ) = ( ( Product C61 ) * ( ( ( C61 . C62 ) " ) * ( C61 . C62 ) ) )
.= ( ( Product C61 ) * 1 ) by L274 , XCMPLX_0:def 7
.= ( Product C61 );
end;
suppose L276: ( C61 . C62 ) = ( 0 );

take 1;
thus L277: thesis by L273 , L276 , L210;
end;
end;
L279: (for B45 being ( INT ) -valued FinSequence holds (for B46 , B47 being Nat holds ((B46 in ( dom B45 ) & B47 in ( dom B45 ) & B47 <> B46 & ( B45 . B47 ) <> ( 0 )) implies (ex B48 being Integer st ( B48 * ( B45 . B46 ) ) = ( ( Product B45 ) / ( B45 . B47 ) )))))
proof
let C63 being ( INT ) -valued FinSequence;
let C64 , C65 being Nat;
reconsider D33 = C63 as (FinSequence of ( INT )) by L1;
assume that
L280: C64 in ( dom C63 )
and
L281: C65 in ( dom C63 )
and
L282: C65 <> C64
and
L283: ( C63 . C65 ) <> ( 0 );
reconsider D34 = C64 , D35 = C65 as (Element of ( NAT )) by ORDINAL1:def 12;
L284: ( dom C63 ) = ( Seg ( len C63 ) ) by FINSEQ_1:def 3;
L285: D35 <= ( len C63 ) by L284 , L281 , FINSEQ_1:1;
L286: 1 <= D35 by L281 , L284 , FINSEQ_1:1;
L287: ( 1 - 1 ) <= ( D35 - 1 ) by L286 , XREAL_1:9;
reconsider D36 = ( D35 - 1 ) as (Element of ( NAT )) by L287 , INT_1:3;
set D37 = ( ( C63 | D36 ) ^ ( C63 /^ D35 ) );
reconsider D38 = D37 as (FinSequence of ( INT )) by L1;
L288: ( D36 + 1 ) = D35;
L289: D36 <= D35 by L288 , NAT_1:11;
L290: ( len ( C63 | D36 ) ) = D36 by L289 , L285 , FINSEQ_1:59 , XXREAL_0:2;
L291: ( dom C63 ) = ( Seg ( len C63 ) ) by FINSEQ_1:def 3;
L292: 1 <= D34 by L291 , L280 , FINSEQ_1:1;
L293: ( 1 - 1 ) <= ( D34 - 1 ) by L292 , XREAL_1:9;
reconsider D39 = ( D34 - 1 ) as (Element of ( NAT )) by L293 , INT_1:3;
L294: D34 <= ( len C63 ) by L280 , L291 , FINSEQ_1:1;
L295: (ex B49 being (Element of ( NAT )) st (B49 in ( dom D38 ) & ( D38 . B49 ) = ( C63 . D34 )))
proof
per cases  by L282 , XXREAL_0:1;
suppose L296: D34 < D35;

L297: ( dom ( C63 | D36 ) ) c= ( dom D38 ) by FINSEQ_1:26;
L298: D34 < ( D36 + 1 ) by L296;
L299: D34 <= ( D35 - 1 ) by L298 , NAT_1:13;
L300: D34 in ( Seg D36 ) by L299 , L292;
L301: D34 in ( dom ( C63 | D36 ) ) by L300 , L290 , FINSEQ_1:def 3;
L302: ( ( C63 | D36 ) . D34 ) = ( C63 . D34 ) by L301 , FUNCT_1:47;
L303: ( D38 . D34 ) = ( C63 . D34 ) by L302 , L301 , FINSEQ_1:def 7;
thus L304: thesis by L303 , L301 , L297;
end;
suppose L305: D34 > D35;

L306: ( D34 - 1 ) > D36 by L305 , XREAL_1:9;
reconsider D40 = ( ( D34 - 1 ) - D36 ) as (Element of ( NAT )) by L306 , INT_1:5;
L307: ( D34 - D36 ) > ( ( D36 + 1 ) - D36 ) by L305 , XREAL_1:9;
L308: ( ( D34 - D36 ) - 1 ) > ( 1 - 1 ) by L307 , XREAL_1:9;
L309: (ex B50 being Nat st D40 = ( B50 + 1 )) by L308 , NAT_1:6;
L310: 1 <= ( ( D34 - 1 ) - D36 ) by L309 , NAT_1:11;
L311: ( len ( C63 /^ D35 ) ) = ( ( len C63 ) - D35 ) by L285 , RFINSEQ:def 1;
L312: ( len D38 ) = ( D36 + ( ( len C63 ) - D35 ) ) by L311 , L290 , FINSEQ_1:22
.= ( ( len C63 ) - 1 );
L313: D39 <= ( len D38 ) by L312 , L294 , XREAL_1:9;
L314: ( D34 - D35 ) <= ( ( len C63 ) - D35 ) by L294 , XREAL_1:9;
L315: D40 in ( Seg ( len ( C63 /^ D35 ) ) ) by L314 , L311 , L310;
L316: ( ( D34 - 1 ) - D36 ) in ( dom ( D33 /^ D35 ) ) by L315 , FINSEQ_1:def 3;
L317: ( D39 + 1 ) > 1 by L286 , L305 , XXREAL_0:2;
L318: D39 >= 1 by L317 , NAT_1:13;
L319: D39 in ( Seg ( len D38 ) ) by L318 , L313;
L320: D39 in ( dom D38 ) by L319 , FINSEQ_1:def 3;
reconsider D41 = ( INT ) as set;
reconsider D42 = D33 as (FinSequence of D41);
L321: ( len ( C63 | D36 ) ) < ( D34 - 1 ) by L290 , L305 , XREAL_1:9;
L322: ( D38 . D39 ) = ( ( C63 /^ D35 ) . ( D39 - D36 ) ) by L321 , L290 , L313 , FINSEQ_1:24
.= ( ( D42 /^ D35 ) /. ( D39 - D36 ) ) by L316 , PARTFUN1:def 6
.= ( D42 /. ( D35 + D40 ) ) by L316 , FINSEQ_5:27
.= ( C63 . D34 ) by L280 , PARTFUN1:def 6;
thus L323: thesis by L322 , L320;
end;
end;
consider C66 being (Element of ( NAT )) such that L325: C66 in ( dom D38 ) and L326: ( D38 . C66 ) = ( C63 . D34 ) by L295;
L327: C66 in ( Seg ( len D38 ) ) by L325 , FINSEQ_1:def 3;
L328: 1 <= C66 by L327 , FINSEQ_1:1;
reconsider D43 = ( C66 - 1 ) as (Element of ( NAT )) by L328 , INT_1:5;
L329: C66 in ( Seg ( len D38 ) ) by L325 , FINSEQ_1:def 3;
L330: ( D43 + 1 ) <= ( len D38 ) by L329 , FINSEQ_1:1;
L331: ( ( D38 | D43 ) ^ <* ( D38 . C66 ) *> ) = ( D38 | C66 ) by L330 , L183;
L332: D38 = ( ( ( D38 | D43 ) ^ <* ( D38 . C66 ) *> ) ^ ( D38 /^ C66 ) ) by L331 , RFINSEQ:8;
L333: ( Product D38 ) = ( ( Product ( ( D38 | D43 ) ^ <* ( D38 . C66 ) *> ) ) * ( Product ( D38 /^ C66 ) ) ) by L332 , RVSUM_1:97
.= ( ( ( Product ( D38 | D43 ) ) * ( Product <* ( D38 . C66 ) *> ) ) * ( Product ( D38 /^ C66 ) ) ) by RVSUM_1:97
.= ( ( ( Product ( D38 | D43 ) ) * ( Product ( D38 /^ C66 ) ) ) * ( Product <* ( C63 . D34 ) *> ) ) by L326
.= ( ( ( Product ( D38 | D43 ) ) * ( Product ( D38 /^ C66 ) ) ) * ( C63 . D34 ) ) by RVSUM_1:95
.= ( ( Product ( ( D38 | D43 ) ^ ( D38 /^ C66 ) ) ) * ( C63 . D34 ) ) by RVSUM_1:97;
L334: ( D36 + 1 ) <= ( len C63 ) by L281 , L284 , FINSEQ_1:1;
L335: ( ( C63 | D36 ) ^ <* ( C63 . D35 ) *> ) = ( C63 | D35 ) by L334 , L183;
reconsider D44 = ( C63 /^ D35 ) as (FinSequence of ( INT )) by L1;
reconsider D45 = ( C63 | D35 ) as (FinSequence of ( INT )) by L1;
L336: D33 = ( D45 ^ D44 ) by RFINSEQ:8;
L337: ( Product C63 ) = ( ( Product ( ( C63 | D36 ) ^ <* ( C63 . D35 ) *> ) ) * ( Product ( C63 /^ D35 ) ) ) by L336 , L335 , RVSUM_1:97
.= ( ( ( Product ( C63 | D36 ) ) * ( Product <* ( C63 . D35 ) *> ) ) * ( Product ( C63 /^ D35 ) ) ) by RVSUM_1:97
.= ( ( ( Product ( C63 | D36 ) ) * ( Product ( C63 /^ D35 ) ) ) * ( Product <* ( C63 . D35 ) *> ) )
.= ( ( ( Product ( C63 | D36 ) ) * ( Product ( C63 /^ D35 ) ) ) * ( C63 . D35 ) ) by RVSUM_1:95
.= ( ( Product D38 ) * ( C63 . D35 ) ) by RVSUM_1:97;
L338: ( ( Product C63 ) / ( C63 . D35 ) ) = ( ( Product D38 ) * ( ( C63 . D35 ) * ( ( C63 . D35 ) " ) ) ) by L337
.= ( ( Product D38 ) * 1 ) by L283 , XCMPLX_0:def 7;
thus L339: thesis by L338 , L333;
end;
theorem
L340: (for B51 being ( INT ) -valued FinSequence holds (for B52 , B53 being Nat holds ((B52 in ( dom B51 ) & B53 in ( dom B51 ) & B53 <> B52 & ( B51 . B53 ) <> ( 0 )) implies ( ( Product B51 ) / ( ( B51 . B52 ) * ( B51 . B53 ) ) ) is Integer)))
proof
let C67 being ( INT ) -valued FinSequence;
let C68 , C69 being Nat;
assume that
L341: C68 in ( dom C67 )
and
L342: C69 in ( dom C67 )
and
L343: C69 <> C68
and
L344: ( C67 . C69 ) <> ( 0 );
reconsider D46 = C68 , D47 = C69 as (Element of ( NAT )) by ORDINAL1:def 12;
L345: (ex B54 being Integer st ( B54 * ( C67 . D46 ) ) = ( ( Product C67 ) / ( C67 . D47 ) )) by L341 , L342 , L343 , L344 , L279;
per cases ;
suppose L346: ( C67 . D46 ) = ( 0 );

thus L347: thesis by L346;
end;
suppose L348: ( C67 . D46 ) <> ( 0 );

reconsider D48 = ( ( Product C67 ) / ( C67 . D47 ) ) as Integer by L342 , L344 , L260;
L349: ( D48 / ( C67 . D46 ) ) = ( ( Product C67 ) * ( ( ( C67 . D47 ) " ) * ( ( C67 . D46 ) " ) ) )
.= ( ( Product C67 ) / ( ( C67 . D46 ) * ( C67 . D47 ) ) ) by XCMPLX_1:204;
L350: ( C67 . D46 ) divides D48 by L345 , INT_1:def 3;
thus L351: thesis by L350 , L348 , L349 , WSIERP_1:17;
end;
end;
theorem
L353: (for B55 being ( INT ) -valued FinSequence holds (for B56 , B57 being Nat holds ((B56 in ( dom B55 ) & B57 in ( dom B55 ) & B57 <> B56 & ( B55 . B57 ) <> ( 0 )) implies (ex B58 being Integer st ( B58 * ( B55 . B56 ) ) = ( ( Product B55 ) / ( B55 . B57 ) ))))) by L279;
begin
theorem
L354: (for B59 being Integer holds (( abs B59 ) divides B59 & B59 divides ( abs B59 )))
proof
let C70 being Integer;
per cases  by ABSVALUE:1;
suppose L355: ( abs C70 ) = C70;

thus L356: thesis by L355;
end;
suppose L357: ( abs C70 ) = ( - C70 );

L358: ( C70 * ( - 1 ) ) = ( abs C70 ) by L357;
L359: ( ( abs C70 ) * ( - 1 ) ) = C70 by L357;
thus L360: thesis by L359 , L358 , INT_1:def 3;
end;
end;
theorem
L362: (for B60 , B61 being Integer holds ( B60 gcd B61 ) = ( B60 gcd ( abs B61 ) ))
proof
let C71 , C72 being Integer;
set D49 = ( C71 gcd ( abs C72 ) );
L363: D49 divides ( abs C72 ) by INT_2:def 2;
consider C73 being Integer such that L364: ( D49 * C73 ) = ( abs C72 ) by L363 , INT_1:def 3;
L365: ( abs C72 ) divides C72 by L354;
consider C74 being Integer such that L366: ( ( abs C72 ) * C74 ) = C72 by L365 , INT_1:def 3;
L367: (for B62 being Integer holds ((B62 divides C71 & B62 divides C72) implies B62 divides D49))
proof
L368: C72 divides ( abs C72 ) by L354;
consider C75 being Integer such that L369: ( C72 * C75 ) = ( abs C72 ) by L368 , INT_1:def 3;
let C76 being Integer;
assume that
L370: C76 divides C71
and
L371: C76 divides C72;
consider C77 being Integer such that L372: ( C76 * C77 ) = C72 by L371 , INT_1:def 3;
L373: ( C76 * ( C77 * C75 ) ) = ( abs C72 ) by L372 , L369;
L374: C76 divides ( abs C72 ) by L373 , INT_1:def 3;
thus L375: thesis by L374 , L370 , INT_2:def 2;
end;
L376: ( D49 * ( C73 * C74 ) ) = C72 by L364 , L366;
L377: D49 divides C72 by L376 , INT_1:def 3;
L378: D49 divides C71 by INT_2:def 2;
thus L379: thesis by L378 , L377 , L367 , INT_2:def 2;
end;
theorem
L380: (for B63 , B64 being Integer holds (B63 , B64 are_relative_prime  implies ( B63 lcm B64 ) = ( abs ( B63 * B64 ) )))
proof
let C78 , C79 being Integer;
assume L381: ( C78 gcd C79 ) = 1;
per cases ;
suppose L382: (C78 = ( 0 ) or C79 = ( 0 ));

thus L383: ( C78 lcm C79 ) = ( 0 ) by L382 , INT_2:4
.= ( abs ( C78 * C79 ) ) by L382 , ABSVALUE:2;
end;
suppose L384: (C78 <> ( 0 ) & C79 <> ( 0 ));

L385: (for B65 being Integer holds ((C78 divides B65 & C79 divides B65) implies ( abs ( C78 * C79 ) ) divides B65))
proof
L386: C79 divides ( C78 lcm C79 ) by INT_2:def 1;
consider C80 being Integer such that L387: ( C79 * C80 ) = ( C78 lcm C79 ) by L386 , INT_1:def 3;
L388: C78 divides ( C78 lcm C79 ) by INT_2:def 1;
consider C81 being Integer such that L389: ( C78 * C81 ) = ( C78 lcm C79 ) by L388 , INT_1:def 3;
L390: C79 divides ( C78 * C79 ) by INT_2:2;
L391: C78 divides ( C78 * C79 ) by INT_2:2;
L392: ( C78 lcm C79 ) divides ( C78 * C79 ) by L391 , L390 , INT_2:def 1;
consider C82 being Integer such that L393: ( ( C78 lcm C79 ) * C82 ) = ( C78 * C79 ) by L392 , INT_1:def 3;
L394: ( C78 * C79 ) = ( C79 * ( C80 * C82 ) ) by L387 , L393;
L395: C78 = ( C80 * C82 ) by L394 , L384 , XCMPLX_1:5;
L396: C82 divides C78 by L395 , INT_1:def 3;
L397: ( C78 * C79 ) = ( C78 * ( C81 * C82 ) ) by L389 , L393;
L398: C79 = ( C81 * C82 ) by L397 , L384 , XCMPLX_1:5;
L399: C82 divides C79 by L398 , INT_1:def 3;
L400: C82 divides 1 by L399 , L381 , L396 , INT_2:def 2;
let C83 being Integer;
assume that
L401: C78 divides C83
and
L402: C79 divides C83;
L403: ( C78 lcm C79 ) divides C83 by L401 , L402 , INT_2:def 1;
per cases  by L400 , INT_2:13;
suppose L404: C82 = 1;

thus L405: thesis by L404 , L393 , L403 , ABSVALUE:def 1;
end;
suppose L406: C82 = ( - 1 );

L407: ( - ( C78 * C79 ) ) <> ( 0 ) by L384 , XCMPLX_1:6;
L408: ( - ( - ( C78 * C79 ) ) ) < ( 0 ) by L407 , L393 , L406;
thus L409: thesis by L408 , L393 , L403 , L406 , ABSVALUE:def 1;
end;
end;
L411: C79 divides ( abs C79 ) by L354;
L412: C79 divides ( ( abs C78 ) * ( abs C79 ) ) by L411 , INT_2:2;
L413: C79 divides ( abs ( C78 * C79 ) ) by L412 , COMPLEX1:65;
L414: C78 divides ( abs C78 ) by L354;
L415: C78 divides ( ( abs C78 ) * ( abs C79 ) ) by L414 , INT_2:2;
L416: C78 divides ( abs ( C78 * C79 ) ) by L415 , COMPLEX1:65;
thus L417: thesis by L416 , L413 , L385 , INT_2:def 1;
end;
end;
theorem
L419: (for B66 , B67 , B68 being Integer holds ( ( B66 * B67 ) gcd ( B66 * B68 ) ) = ( ( abs B66 ) * ( B67 gcd B68 ) ))
proof
let C84 , C85 , C86 being Integer;
per cases ;
suppose L420: C84 = ( 0 );

thus L421: ( ( C84 * C85 ) gcd ( C84 * C86 ) ) = ( ( 0 ) * ( C85 gcd C86 ) ) by L420 , INT_2:5
.= ( ( abs C84 ) * ( C85 gcd C86 ) ) by L420 , ABSVALUE:def 1;
end;
suppose L422: C84 <> ( 0 );

set D50 = ( C85 gcd C86 );
set D51 = ( ( C84 * C85 ) gcd ( C84 * C86 ) );
per cases ;
suppose L423: D50 = ( 0 );

L424: C86 = ( 0 ) by L423 , INT_2:5;
L425: C85 = ( 0 ) by L423 , INT_2:5;
thus L426: thesis by L425 , L423 , L424;
end;
suppose L427: D50 <> ( 0 );

L428: D51 divides ( C84 * C86 ) by INT_2:21;
L429: ( C84 * D50 ) divides ( C84 * C86 ) by L255 , INT_2:21;
L430: ( C84 * D50 ) divides ( C84 * C85 ) by L255 , INT_2:21;
L431: ( C84 * D50 ) divides D51 by L430 , L429 , INT_2:22;
consider C87 being Integer such that L432: D51 = ( ( C84 * D50 ) * C87 ) by L431 , INT_1:def 3;
L433: D51 divides ( C84 * C85 ) by INT_2:21;
L434: (( D50 * C87 ) divides C85 & ( D50 * C87 ) divides C86)
proof
consider C88 being Integer such that L435: ( ( ( C84 * D50 ) * C87 ) * C88 ) = ( C84 * C85 ) by L432 , L433 , INT_1:def 3;
L436: ( C84 * ( ( D50 * C87 ) * C88 ) ) = ( C84 * C85 ) by L435;
L437: ( ( D50 * C87 ) * C88 ) = C85 by L436 , L422 , XCMPLX_1:5;
thus L438: ( D50 * C87 ) divides C85 by L437 , INT_1:def 3;
consider C89 being Integer such that L439: ( ( ( C84 * D50 ) * C87 ) * C89 ) = ( C84 * C86 ) by L432 , L428 , INT_1:def 3;
L440: ( C84 * ( ( D50 * C87 ) * C89 ) ) = ( C84 * C86 ) by L439;
L441: ( ( D50 * C87 ) * C89 ) = C86 by L440 , L422 , XCMPLX_1:5;
thus L442: thesis by L441 , INT_1:def 3;
end;
L443: ( D50 * C87 ) divides D50 by L434 , INT_2:22;
consider C90 being Integer such that L444: ( ( D50 * C87 ) * C90 ) = D50 by L443 , INT_1:def 3;
L445: ( D50 * ( C87 * C90 ) ) = ( D50 * 1 ) by L444;
L446: ( C87 * C90 ) = 1 by L445 , L427 , XCMPLX_1:5;
L447: C87 divides 1 by L446 , INT_1:def 3;
per cases  by L447 , INT_2:13;
suppose L448: C87 = 1;

L449: (C84 < ( 0 ) implies ( D50 * C84 ) < ( ( 0 ) * C84 )) by L427 , XREAL_1:69;
thus L450: thesis by L449 , L432 , L448 , ABSVALUE:def 1;
end;
suppose L451: C87 = ( - 1 );

L452:
now
assume L453: C84 > ( 0 );
L454: ( - ( - C84 ) ) > ( 0 ) by L453;
L455: ( - C84 ) < ( 0 ) by L454;
thus L456: ( D50 * ( - C84 ) ) < ( ( 0 ) * ( - C84 ) ) by L455 , L427 , XREAL_1:69;
end;
L457: ( ( C84 * C85 ) gcd ( C84 * C86 ) ) = ( ( - C84 ) * D50 ) by L432 , L451;
thus L458: thesis by L457 , L422 , L452 , ABSVALUE:def 1;
end;
end;
end;
end;
theorem
L462: (for B69 , B70 being Integer holds ( ( B69 * B70 ) gcd B69 ) = ( abs B69 ))
proof
let C91 , C92 being Integer;
L463: (for B71 being Integer holds ((B71 divides ( C91 * C92 ) & B71 divides C91) implies B71 divides ( abs C91 )))
proof
let C93 being Integer;
assume that
L464: C93 divides ( C91 * C92 )
and
L465: C93 divides C91;
consider C94 being Integer such that L466: ( C93 * C94 ) = C91 by L465 , INT_1:def 3;
L467: C91 divides ( abs C91 ) by L354;
consider C95 being Integer such that L468: ( C91 * C95 ) = ( abs C91 ) by L467 , INT_1:def 3;
L469: ( C93 * ( C94 * C95 ) ) = ( abs C91 ) by L466 , L468;
thus L470: thesis by L469 , INT_1:def 3;
end;
L471: ( abs C91 ) divides C91 by L354;
L472: ( abs C91 ) divides ( C91 * C92 ) by L471 , INT_2:2;
thus L473: thesis by L472 , L471 , L463 , INT_2:def 2;
end;
theorem
L474: (for B72 , B73 , B74 being Integer holds ( B72 gcd ( B73 gcd B74 ) ) = ( ( B72 gcd B73 ) gcd B74 ))
proof
let C96 , C97 , C98 being Integer;
per cases ;
suppose L475: (C96 = ( 0 ) & C97 = ( 0 ) & C98 = ( 0 ));

thus L476: thesis by L475;
end;
suppose L477: (C96 <> ( 0 ) or C97 <> ( 0 ) or C98 <> ( 0 ));

L478:
now
assume L479: ( C96 gcd ( C97 gcd C98 ) ) = ( - ( ( C96 gcd C97 ) gcd C98 ) );
L480: ( ( - ( ( C96 gcd C97 ) gcd C98 ) ) * ( - 1 ) ) <= ( ( 0 ) * ( - 1 ) ) by L479;
L481: ( ( C96 gcd C97 ) gcd C98 ) = ( 0 ) by L480;
L482: ( C96 gcd C97 ) = ( 0 ) by L481 , INT_2:5;
thus L483: contradiction by L482 , L477 , L481 , INT_2:5;
end;
L484: ( C96 gcd ( C97 gcd C98 ) ) divides C96 by INT_2:21;
L485: ( ( C96 gcd C97 ) gcd C98 ) divides C98 by INT_2:21;
L486: ( ( C96 gcd C97 ) gcd C98 ) divides ( C96 gcd C97 ) by INT_2:21;
L487: ( C96 gcd C97 ) divides C97 by INT_2:21;
L488: ( ( C96 gcd C97 ) gcd C98 ) divides C97 by L487 , L486 , INT_2:9;
L489: ( ( C96 gcd C97 ) gcd C98 ) divides ( C97 gcd C98 ) by L488 , L485 , INT_2:22;
L490: ( C96 gcd C97 ) divides C96 by INT_2:21;
L491: ( ( C96 gcd C97 ) gcd C98 ) divides C96 by L490 , L486 , INT_2:9;
L492: ( ( C96 gcd C97 ) gcd C98 ) divides ( C96 gcd ( C97 gcd C98 ) ) by L491 , L489 , INT_2:22;
L493: ( C96 gcd ( C97 gcd C98 ) ) divides ( C97 gcd C98 ) by INT_2:21;
L494: ( C97 gcd C98 ) divides C97 by INT_2:21;
L495: ( C96 gcd ( C97 gcd C98 ) ) divides C97 by L494 , L493 , INT_2:9;
L496: ( C96 gcd ( C97 gcd C98 ) ) divides ( C96 gcd C97 ) by L495 , L484 , INT_2:22;
L497: ( C97 gcd C98 ) divides C98 by INT_2:21;
L498: ( C96 gcd ( C97 gcd C98 ) ) divides C98 by L497 , L493 , INT_2:9;
L499: ( C96 gcd ( C97 gcd C98 ) ) divides ( ( C96 gcd C97 ) gcd C98 ) by L498 , L496 , INT_2:22;
thus L500: thesis by L499 , L492 , L478 , INT_2:11;
end;
end;
theorem
L502: (for B75 , B76 , B77 being Integer holds (B75 , B76 are_relative_prime  implies ( B75 gcd ( B76 * B77 ) ) = ( B75 gcd B77 )))
proof
let C99 , C100 , C101 being Integer;
assume L503: ( C99 gcd C100 ) = 1;
L504: ( ( C99 * C101 ) gcd ( C100 * C101 ) ) = ( ( abs C101 ) * ( C99 gcd C100 ) ) by L419;
L505: ( C99 gcd ( abs C101 ) ) = ( ( C99 gcd ( C99 * C101 ) ) gcd ( C100 * C101 ) ) by L504 , L503 , L474
.= ( ( abs C99 ) gcd ( C100 * C101 ) ) by L462
.= ( ( C100 * C101 ) gcd C99 ) by L362;
thus L506: thesis by L505 , L362;
end;
theorem
L507: (for B78 , B79 being Integer holds (B78 , B79 are_relative_prime  implies ( B78 * B79 ) divides ( B78 lcm B79 )))
proof
let C102 , C103 being Integer;
assume L508: C102 , C103 are_relative_prime ;
L509: ( abs ( C102 * C103 ) ) divides ( C102 lcm C103 ) by L508 , L380;
consider C104 being Integer such that L510: ( ( abs ( C102 * C103 ) ) * C104 ) = ( C102 lcm C103 ) by L509 , INT_1:def 3;
per cases ;
suppose L511: ( 0 ) <= ( C102 * C103 );

L512: ( C104 * ( C102 * C103 ) ) = ( C102 lcm C103 ) by L511 , L510 , ABSVALUE:def 1;
thus L513: thesis by L512 , INT_1:def 3;
end;
suppose L514: ( 0 ) > ( C102 * C103 );

L515: ( ( - C104 ) * ( C102 * C103 ) ) = ( C104 * ( - ( C102 * C103 ) ) )
.= ( C102 lcm C103 ) by L510 , L514 , ABSVALUE:def 1;
thus L516: thesis by L515 , INT_1:def 3;
end;
end;
theorem
L518: (for B80 , B81 , B82 , B83 being Integer holds (B82 , B83 are_relative_prime  implies ((B80 , B81 are_congruent_mod B82 & B80 , B81 are_congruent_mod B83) implies B80 , B81 are_congruent_mod ( B82 * B83 ))))
proof
let C105 , C106 , C107 , C108 being Integer;
assume L519: C107 , C108 are_relative_prime ;
L520: ( C107 * C108 ) divides ( C107 lcm C108 ) by L519 , L507;
assume that
L521: C105 , C106 are_congruent_mod C107
and
L522: C105 , C106 are_congruent_mod C108;
L523: C108 divides ( C105 - C106 ) by L522 , INT_2:15;
L524: C107 divides ( C105 - C106 ) by L521 , INT_2:15;
L525: ( C107 lcm C108 ) divides ( C105 - C106 ) by L524 , L523 , INT_2:19;
L526: ( C107 * C108 ) divides ( C105 - C106 ) by L525 , L520 , INT_2:9;
thus L527: thesis by L526 , INT_2:15;
end;
theorem
L528: (for B84 , B85 being Integer holds (B84 , B85 are_relative_prime  implies (ex B86 being Integer st ( B86 * B84 ) , 1 are_congruent_mod B85)))
proof
let C109 , C110 being Integer;
assume L529: ( C109 gcd C110 ) = 1;
consider C111 , C112 being Integer such that L530: 1 = ( ( C111 * C109 ) + ( C112 * C110 ) ) by L529 , NAT_D:68;
take C111;
L531: ( ( C111 * C109 ) - 1 ) = ( ( - C112 ) * C110 ) by L530;
L532: C110 divides ( ( C111 * C109 ) - 1 ) by L531 , INT_1:def 3;
thus L533: thesis by L532 , INT_2:15;
end;
begin
notation
let C113 being ( INT ) -valued FinSequence;
antonym C113 is  multiplicative-trivial for C113 is  non-empty;
end;
definition
let C114 being ( INT ) -valued FinSequence;
redefine attr C114 is  multiplicative-trivial
means
:L535: (ex B87 being Nat st (B87 in ( dom C114 ) & ( C114 . B87 ) = ( 0 )));
compatibility
proof
thus L536: (C114 is  non-empty implies (not (ex B88 being Nat st (B88 in ( dom C114 ) & ( C114 . B88 ) = ( 0 ))))) by FUNCT_1:def 9;
assume L537: (not (ex B89 being Nat st (B89 in ( dom C114 ) & ( C114 . B89 ) = ( 0 ))));
let C115 being set;
assume L538: C115 in ( dom C114 );
thus L539: thesis by L538 , L537;
end;
end;
registration
cluster  multiplicative-trivial for ( INT ) -valued ( INT ) -valued ( INT ) -valued ( INT ) -valued FinSequence;
existence
proof
set D52 = <* ( 0 ) *>;
L541:
now
let C116 being set;
assume L542: C116 in { ( 0 ) };
reconsider D53 = C116 as (Element of ( NAT )) by L542 , TARSKI:def 1;
L543: D53 is  integer  integer  integer  integer number;
thus L544: C116 in ( INT ) by L543 , INT_1:def 1;
end;
L545: { ( 0 ) } c= ( INT ) by L541 , TARSKI:def 3;
L546: ( rng D52 ) c= ( INT ) by L545 , FINSEQ_1:39;
reconsider D54 = D52 as (FinSequence of ( INT )) by L546 , FINSEQ_1:def 4;
take D54;
take 1;
L547: ( len D54 ) = 1 by FINSEQ_1:40;
L548: ( dom D54 ) = ( Seg 1 ) by L547 , FINSEQ_1:def 3;
thus L549: 1 in ( dom D54 ) by L548;
thus L550: thesis by FINSEQ_1:40;
end;
cluster non  multiplicative-trivial for ( INT ) -valued ( INT ) -valued ( INT ) -valued ( INT ) -valued FinSequence;
existence by L535;
cluster non  empty  positive-yielding for ( INT ) -valued ( INT ) -valued ( INT ) -valued ( INT ) -valued FinSequence;
existence
proof
set D55 = <* 1 *>;
L551:
now
let C117 being set;
assume L552: C117 in { 1 };
reconsider D56 = C117 as (Element of ( NAT )) by L552 , TARSKI:def 1;
L553: D56 is  integer  integer  integer  integer number;
thus L554: C117 in ( INT ) by L553 , INT_1:def 1;
end;
L555: { 1 } c= ( INT ) by L551 , TARSKI:def 3;
L556: ( rng D55 ) c= ( INT ) by L555 , FINSEQ_1:39;
reconsider D57 = D55 as (FinSequence of ( INT )) by L556 , FINSEQ_1:def 4;
take D57;
L557:
now
let C118 being  real number;
assume L558: C118 in ( rng D57 );
L559: C118 in { 1 } by L558 , FINSEQ_1:39;
thus L560: ( 0 ) < C118 by L559 , TARSKI:def 1;
end;
thus L561: thesis by L557 , PARTFUN3:def 1;
end;
end;
theorem
L563: (for B90 being  multiplicative-trivial ( INT ) -valued FinSequence holds ( Product B90 ) = ( 0 ))
proof
let C119 being  multiplicative-trivial ( INT ) -valued FinSequence;
L564: (ex B91 being Nat st (B91 in ( dom C119 ) & ( C119 . B91 ) = ( 0 ))) by L535;
thus L565: thesis by L564 , L210;
end;
definition
let C120 being ( INT ) -valued FinSequence;
attr C120 is  Chinese_Remainder
means
:L566: (for B92 , B93 being Nat holds ((B92 in ( dom C120 ) & B93 in ( dom C120 ) & B92 <> B93) implies ( C120 . B92 ) , ( C120 . B93 ) are_relative_prime ));
end;
registration
cluster non  empty  positive-yielding  Chinese_Remainder for ( INT ) -valued ( INT ) -valued ( INT ) -valued ( INT ) -valued FinSequence;
existence
proof
set D58 = <* 1 *>;
L568:
now
let C121 being set;
assume L569: C121 in { 1 };
reconsider D59 = C121 as (Element of ( NAT )) by L569 , TARSKI:def 1;
L570: D59 is  integer  integer  integer  integer number;
thus L571: C121 in ( INT ) by L570 , INT_1:def 1;
end;
L572: { 1 } c= ( INT ) by L568 , TARSKI:def 3;
L573: ( rng D58 ) c= ( INT ) by L572 , FINSEQ_1:39;
reconsider D60 = D58 as (FinSequence of ( INT )) by L573 , FINSEQ_1:def 4;
take D60;
L574:
now
let C122 being (Element of ( NAT ));
assume L575: C122 in ( dom D60 );
L576: C122 in ( Seg 1 ) by L575 , FINSEQ_1:38;
thus L577: C122 = 1 by L576 , FINSEQ_1:2 , TARSKI:def 1;
end;
L578:
now
let C123 , C124 being Nat;
assume that
L579: C123 in ( dom D60 )
and
L580: C124 in ( dom D60 )
and
L581: C123 <> C124;
reconsider D61 = C123 , D62 = C124 as (Element of ( NAT )) by ORDINAL1:def 12;
L582: D61 = 1 by L574 , L579
.= D62 by L574 , L580;
thus L583: ( D60 . C123 ) , ( D60 . C124 ) are_relative_prime  by L582 , L581;
end;
L584:
now
let C125 being  real number;
assume L585: C125 in ( rng D60 );
L586: C125 in { 1 } by L585 , FINSEQ_1:39;
thus L587: ( 0 ) < C125 by L586 , TARSKI:def 1;
end;
thus L588: thesis by L584 , L578 , L566 , PARTFUN3:def 1;
end;
end;
definition
mode CR_Sequence
 is non  empty  positive-yielding  Chinese_Remainder ( INT ) -valued FinSequence;
end;
registration
cluster  -> non  multiplicative-trivial for CR_Sequence;
coherence
proof
let C126 being CR_Sequence;
L591:
now
let C127 being Nat;
assume L592: C127 in ( dom C126 );
L593: ( C126 . C127 ) in ( rng C126 ) by L592 , FUNCT_1:3;
thus L594: ( C126 . C127 ) <> ( 0 ) by L593 , PARTFUN3:def 1;
end;
thus L595: thesis by L591 , L535;
end;
end;
registration
cluster  multiplicative-trivial -> non  empty for ( INT ) -valued ( INT ) -valued ( INT ) -valued ( INT ) -valued FinSequence;
coherence;
end;
theorem
L598: (for B94 being CR_Sequence holds (for B95 being Nat holds ((( 0 ) < B95 & B95 <= ( len B94 )) implies ( B94 | B95 ) is CR_Sequence)))
proof
let C128 being CR_Sequence;
let C129 being Nat;
reconsider D63 = ( C128 | C129 ) as (FinSequence of ( INT )) by L1;
assume that
L599: C129 > ( 0 )
and
L600: C129 <= ( len C128 );
L601: ( len D63 ) = C129 by L600 , FINSEQ_1:59;
L602:
now
let C130 being (Element of ( NAT ));
assume L603: C130 in ( dom D63 );
L604: C130 in ( Seg C129 ) by L603 , L601 , FINSEQ_1:def 3;
L605: C130 <= C129 by L604 , FINSEQ_1:1;
L606: C130 <= ( len C128 ) by L605 , L600 , XXREAL_0:2;
L607: 1 <= C130 by L604 , FINSEQ_1:1;
L608: C130 in ( Seg ( len C128 ) ) by L607 , L606;
thus L609: C130 in ( dom C128 ) by L608 , FINSEQ_1:def 3;
end;
L610:
now
let C131 , C132 being Nat;
assume that
L611: C131 in ( dom D63 )
and
L612: C132 in ( dom D63 )
and
L613: C131 <> C132;
reconsider D64 = C131 , D65 = C132 as (Element of ( NAT )) by ORDINAL1:def 12;
L614: ( C128 . D64 ) = ( D63 . D64 ) by L611 , FUNCT_1:47;
L615: ( C128 . D65 ) = ( D63 . D65 ) by L612 , FUNCT_1:47;
L616: D65 in ( dom C128 ) by L602 , L612;
L617: D64 in ( dom C128 ) by L602 , L611;
thus L618: ( D63 . C131 ) , ( D63 . C132 ) are_relative_prime  by L617 , L613 , L616 , L614 , L615 , L566;
end;
L619:
now
let C133 being  real number;
assume L620: C133 in ( rng D63 );
consider C134 being set such that L621: C134 in ( dom D63 ) and L622: ( D63 . C134 ) = C133 by L620 , FUNCT_1:def 3;
reconsider D66 = C134 as (Element of ( NAT )) by L621;
L623: ( C128 . D66 ) in ( rng C128 ) by L602 , L621 , FUNCT_1:3;
L624: ( C128 . D66 ) > ( 0 ) by L623 , PARTFUN3:def 1;
thus L625: C133 > ( 0 ) by L624 , L621 , L622 , FUNCT_1:47;
end;
thus L626: thesis by L619 , L599 , L601 , L610 , L566 , PARTFUN3:def 1;
end;
L627: (for B96 being CR_Sequence holds ( Product B96 ) > ( 0 ))
proof
defpred S4[ Nat ] means (for B97 being CR_Sequence holds (( len B97 ) = $1 implies ( Product B97 ) > ( 0 )));
let C135 being CR_Sequence;
L628: (ex B98 being Nat st ( len C135 ) = B98);
L629: (for B99 being (Element of ( NAT )) holds (S4[ B99 ] implies S4[ ( B99 + 1 ) ]))
proof
let C136 being (Element of ( NAT ));
assume L630: S4[ C136 ];
L631:
now
let C137 being CR_Sequence;
assume L632: ( len C137 ) = ( C136 + 1 );
set D67 = ( C137 | C136 );
per cases ;
suppose L633: C136 > ( 0 );

reconsider D68 = D67 as CR_Sequence by L633 , L632 , L598 , NAT_1:11;
L634: C137 = ( D68 ^ <* ( C137 . ( C136 + 1 ) ) *> ) by L632 , FINSEQ_3:55;
L635: 1 <= ( C136 + 1 ) by NAT_1:11;
L636: ( C136 + 1 ) in ( Seg ( C136 + 1 ) ) by L635;
L637: ( C136 + 1 ) in ( dom C137 ) by L636 , L632 , FINSEQ_1:def 3;
L638: ( C137 . ( C136 + 1 ) ) in ( rng C137 ) by L637 , FUNCT_1:3;
L639: ( C137 . ( C136 + 1 ) ) > ( 0 ) by L638 , PARTFUN3:def 1;
L640: ( len D68 ) = C136 by L632 , FINSEQ_1:59 , NAT_1:11;
L641: ( Product D68 ) > ( 0 ) by L640 , L630;
L642: ( ( 0 ) * ( C137 . ( C136 + 1 ) ) ) < ( ( Product D68 ) * ( C137 . ( C136 + 1 ) ) ) by L641 , L639 , XREAL_1:68;
thus L643: ( Product C137 ) > ( 0 ) by L642 , L634 , RVSUM_1:96;
end;
suppose L644: C136 = ( 0 );

L645: C137 = <* ( C137 . 1 ) *> by L644 , L632 , FINSEQ_1:40;
L646: ( dom C137 ) = ( Seg 1 ) by L645 , FINSEQ_1:38;
L647: 1 in ( dom C137 ) by L646;
L648: ( C137 . 1 ) in ( rng C137 ) by L647 , FUNCT_1:3;
L649: ( C137 . 1 ) > ( 0 ) by L648 , PARTFUN3:def 1;
thus L650: ( Product C137 ) > ( 0 ) by L649 , L645 , RVSUM_1:95;
end;
end;
thus L652: thesis by L631;
end;
L653: S4[ ( 0 ) ];
L654: (for B100 being (Element of ( NAT )) holds S4[ B100 ]) from NAT_1:sch 1(L653 , L629);
thus L655: thesis by L654 , L628;
end;
registration
let C138 being CR_Sequence;
cluster ( Product C138 ) ->  positive  natural;
coherence
proof
L656: ( Product C138 ) > ( 0 ) by L627;
L657: ( Product C138 ) is (Element of ( NAT )) by L656 , INT_1:3;
thus L658: thesis by L657 , L627;
end;
end;
theorem
L660: (for B101 being CR_Sequence holds (for B102 being Nat holds (B102 in ( dom B101 ) implies (for B103 being Integer holds (B103 = ( ( Product B101 ) / ( B101 . B102 ) ) implies B103 , ( B101 . B102 ) are_relative_prime )))))
proof
defpred S5[ Nat ] means (for B104 being CR_Sequence holds (( len B104 ) = $1 implies (for B105 being Nat holds (B105 in ( dom B104 ) implies (for B106 being Integer holds (B106 = ( ( Product B104 ) / ( B104 . B105 ) ) implies B106 , ( B104 . B105 ) are_relative_prime ))))));
let C139 being CR_Sequence;
let C140 being Nat;
assume L661: C140 in ( dom C139 );
let C141 being Integer;
L662: (ex B107 being (Element of ( NAT )) st ( len C139 ) = B107);
L663:
now
let C142 being (Element of ( NAT ));
assume L664: S5[ C142 ];
L665:
now
let C143 being CR_Sequence;
set D69 = ( C143 | C142 );
assume L666: ( len C143 ) = ( C142 + 1 );
L667: ( D69 ^ <* ( C143 . ( C142 + 1 ) ) *> ) = ( C143 | ( C142 + 1 ) ) by L666 , L183
.= C143 by L666 , FINSEQ_1:58;
L668: ( len D69 ) = C142 by L666 , FINSEQ_1:59 , NAT_1:11;
L669: 1 <= ( C142 + 1 ) by NAT_1:11;
L670: ( C142 + 1 ) in ( Seg ( C142 + 1 ) ) by L669;
L671: ( C142 + 1 ) in ( dom C143 ) by L670 , L666 , FINSEQ_1:def 3;
let C144 being Nat;
reconsider D70 = C144 as (Element of ( NAT )) by ORDINAL1:def 12;
assume L672: C144 in ( dom C143 );
L673: D70 in ( Seg ( C142 + 1 ) ) by L672 , L666 , FINSEQ_1:def 3;
L674: D70 <= ( C142 + 1 ) by L673 , FINSEQ_1:1;
let C145 being Integer;
assume L675: C145 = ( ( Product C143 ) / ( C143 . C144 ) );
per cases ;
suppose L676: C142 > ( 0 );

reconsider D71 = D69 as CR_Sequence by L676 , L666 , L598 , NAT_1:11;
per cases ;
suppose L677: D70 in ( dom D71 );

L678: D70 in ( Seg C142 ) by L677 , L668 , FINSEQ_1:def 3;
L679: D70 <= C142 by L678 , FINSEQ_1:1;
L680: D70 <> ( C142 + 1 ) by L679 , NAT_1:13;
L681: ( C143 . D70 ) , ( C143 . ( C142 + 1 ) ) are_relative_prime  by L680 , L672 , L671 , L566;
reconsider D72 = ( ( Product D71 ) / ( D71 . D70 ) ) as Integer by L677 , L260;
L682: ( D71 . D70 ) = ( C143 . D70 ) by L677 , FUNCT_1:47;
L683: D72 , ( C143 . D70 ) are_relative_prime  by L682 , L664 , L668 , L677;
L684: ( ( C143 . D70 ) gcd ( D72 * ( C143 . ( C142 + 1 ) ) ) ) = ( ( C143 . D70 ) gcd ( C143 . ( C142 + 1 ) ) ) by L683 , L502
.= 1 by L681 , INT_2:def 3;
L685: ( D72 * ( C143 . ( C142 + 1 ) ) ) = ( ( ( Product D71 ) * ( C143 . ( C142 + 1 ) ) ) * ( ( C143 . D70 ) " ) ) by L682
.= C145 by L675 , L667 , RVSUM_1:96;
thus L686: C145 , ( C143 . C144 ) are_relative_prime  by L685 , L684 , INT_2:def 3;
end;
suppose L687: (not D70 in ( dom D71 ));

L688: ( C143 . ( C142 + 1 ) ) in ( rng C143 ) by L671 , FUNCT_1:3;
L689: ( C143 . ( C142 + 1 ) ) > ( 0 ) by L688 , PARTFUN3:def 1;
defpred S6[ Nat ] means ($1 <= ( len D71 ) implies (for B108 being (Element of ( NAT )) holds (B108 = $1 implies ( Product ( D71 | B108 ) ) , ( C143 . ( C142 + 1 ) ) are_relative_prime )));
L690: ( D71 | ( len D71 ) ) = D71 by FINSEQ_1:58;
L691:
now
let C146 being (Element of ( NAT ));
assume that
L692: ( 0 ) <= C146
and
L693: C146 < ( len D71 );
assume L694: S6[ C146 ];
L695:
now
assume L696: ( C146 + 1 ) <= ( len D71 );
L697: ( ( 0 ) + 1 ) <= ( C146 + 1 ) by XREAL_1:6;
L698: ( C146 + 1 ) in ( Seg ( len D71 ) ) by L697 , L696;
L699: ( C146 + 1 ) in ( dom D71 ) by L698 , FINSEQ_1:def 3;
L700: ( C146 + 1 ) <= ( len C143 ) by L666 , L668 , L693 , XREAL_1:8;
L701: ( C146 + 1 ) in ( Seg ( len C143 ) ) by L700 , L697;
L702: ( C146 + 1 ) in ( dom C143 ) by L701 , FINSEQ_1:def 3;
L703: ( C146 + 1 ) <= C142 by L666 , L696 , FINSEQ_1:59 , NAT_1:11;
L704: ( C146 + 1 ) <> ( C142 + 1 ) by L703 , NAT_1:13;
L705:
now
reconsider D73 = C146 as (Element of ( NAT ));
let C147 being (Element of ( NAT ));
L706: ( D71 . ( C146 + 1 ) ) = ( C143 . ( C146 + 1 ) ) by L699 , FUNCT_1:47;
L707: ( C143 . ( C146 + 1 ) ) , ( C143 . ( C142 + 1 ) ) are_relative_prime  by L671 , L704 , L702 , L566;
L708: C146 <= ( C146 + 1 ) by NAT_1:11;
L709: ( Product ( D71 | D73 ) ) , ( C143 . ( C142 + 1 ) ) are_relative_prime  by L708 , L694 , L696 , XXREAL_0:2;
L710: ( ( ( Product ( D71 | D73 ) ) * ( C143 . ( C146 + 1 ) ) ) gcd ( C143 . ( C142 + 1 ) ) ) = ( ( C143 . ( C146 + 1 ) ) gcd ( C143 . ( C142 + 1 ) ) ) by L709 , L502
.= 1 by L707 , INT_2:def 3;
assume L711: C147 = ( C146 + 1 );
L712: ( ( D71 | D73 ) ^ <* ( D71 . C147 ) *> ) = ( D71 | C147 ) by L711 , L696 , L183;
L713: ( ( Product ( D71 | C147 ) ) gcd ( C143 . ( C142 + 1 ) ) ) = 1 by L712 , L711 , L710 , L706 , RVSUM_1:96;
thus L714: ( Product ( D71 | C147 ) ) , ( C143 . ( C142 + 1 ) ) are_relative_prime  by L713 , INT_2:def 3;
end;
thus L715: S6[ ( C146 + 1 ) ] by L705;
end;
thus L716: S6[ ( C146 + 1 ) ] by L695;
end;
L717: ( D71 | ( 0 ) ) is  empty;
L718: S6[ ( 0 ) ] by L717 , RVSUM_1:94 , WSIERP_1:9;
L719: (for B109 being (Element of ( NAT )) holds ((( 0 ) <= B109 & B109 <= ( len D71 )) implies S6[ B109 ])) from INT_1:sch 7(L718 , L691);
L720: (not D70 in ( Seg C142 )) by L668 , L687 , FINSEQ_1:def 3;
L721: (not (1 <= D70 & D70 <= C142)) by L720;
L722: (not D70 < ( C142 + 1 )) by L721 , L673 , FINSEQ_1:1 , NAT_1:13;
L723: D70 = ( C142 + 1 ) by L722 , L674 , XXREAL_0:1;
L724: C145 = ( ( ( Product D71 ) * ( C143 . ( C142 + 1 ) ) ) * ( ( C143 . ( C142 + 1 ) ) " ) ) by L723 , L675 , L667 , RVSUM_1:96
.= ( ( Product D71 ) * ( ( C143 . ( C142 + 1 ) ) * ( ( C143 . ( C142 + 1 ) ) " ) ) )
.= ( ( Product D71 ) * 1 ) by L689 , XCMPLX_0:def 7;
thus L725: C145 , ( C143 . C144 ) are_relative_prime  by L724 , L723 , L719 , L690;
end;
end;
suppose L727: C142 = ( 0 );

L728: C143 = <* ( C143 . 1 ) *> by L727 , L666 , FINSEQ_1:40;
L729: ( dom C143 ) = ( Seg 1 ) by L728 , FINSEQ_1:38;
L730: D70 <= 1 by L729 , L672 , FINSEQ_1:1;
L731: 1 <= D70 by L672 , L729 , FINSEQ_1:1;
L732: D70 = 1 by L731 , L730 , XXREAL_0:1;
L733: ( Product C143 ) = ( C143 . 1 ) by L728 , RVSUM_1:95;
L734: C145 = 1 by L733 , L675 , L732 , XCMPLX_0:def 7;
thus L735: C145 , ( C143 . C144 ) are_relative_prime  by L734 , WSIERP_1:9;
end;
end;
thus L737: S5[ ( C142 + 1 ) ] by L665;
end;
L738: S5[ ( 0 ) ];
L739: (for B110 being (Element of ( NAT )) holds S5[ B110 ]) from NAT_1:sch 1(L738 , L663);
assume L740: C141 = ( ( Product C139 ) / ( C139 . C140 ) );
thus L741: thesis by L740 , L661 , L739 , L662;
end;
L742: (for B111 being ( INT ) -valued FinSequence holds (for B112 being CR_Sequence holds (for B113 , B114 being Integer holds ((( 0 ) <= B113 & B113 < ( Product B112 ) & (for B115 being Nat holds (B115 in ( dom B112 ) implies B113 , ( B111 . B115 ) are_congruent_mod ( B112 . B115 ))) & ( 0 ) <= B114 & B114 < ( Product B112 ) & (for B116 being Nat holds (B116 in ( dom B112 ) implies B114 , ( B111 . B116 ) are_congruent_mod ( B112 . B116 )))) implies B113 = B114))))
proof
let C148 being ( INT ) -valued FinSequence;
let C149 being CR_Sequence;
let C150 , C151 being Integer;
assume that
L743: ( 0 ) <= C150
and
L744: C150 < ( Product C149 )
and
L745: (for B117 being Nat holds (B117 in ( dom C149 ) implies C150 , ( C148 . B117 ) are_congruent_mod ( C149 . B117 )))
and
L746: ( 0 ) <= C151
and
L747: C151 < ( Product C149 )
and
L748: (for B118 being Nat holds (B118 in ( dom C149 ) implies C151 , ( C148 . B118 ) are_congruent_mod ( C149 . B118 )));
defpred S7[ Nat ] means (for B119 being CR_Sequence holds (B119 = ( C149 | $1 ) implies C150 , C151 are_congruent_mod ( Product B119 )));
L749:
now
let C152 being (Element of ( NAT ));
assume L750: C152 in ( dom C149 );
L751: ( C148 . C152 ) , C151 are_congruent_mod ( C149 . C152 ) by L750 , L748 , INT_1:14;
L752: C150 , ( C148 . C152 ) are_congruent_mod ( C149 . C152 ) by L745 , L750;
thus L753: C150 , C151 are_congruent_mod ( C149 . C152 ) by L752 , L751 , INT_1:15;
end;
L754:
now
let C153 being (Element of ( NAT ));
assume that
L755: ( 0 ) <= C153
and
L756: C153 < ( len C149 );
assume L757: S7[ C153 ];
L758:
now
set D74 = ( C149 | C153 );
let C154 being CR_Sequence;
L759: 1 <= ( C153 + 1 ) by NAT_1:11;
L760: ( C153 + 1 ) <= ( len C149 ) by L756 , NAT_1:13;
L761: ( C153 + 1 ) in ( Seg ( len C149 ) ) by L760 , L759;
L762: ( C153 + 1 ) in ( dom C149 ) by L761 , FINSEQ_1:def 3;
assume L763: C154 = ( C149 | ( C153 + 1 ) );
L764: ( len C154 ) = ( C153 + 1 ) by L763 , L760 , FINSEQ_1:59;
L765: ( C153 + 1 ) in ( Seg ( len C154 ) ) by L764 , L759;
L766: ( C153 + 1 ) in ( dom C154 ) by L765 , FINSEQ_1:def 3;
per cases ;
suppose L767: C153 > ( 0 );

reconsider D75 = D74 as CR_Sequence by L767 , L756 , L598;
set D76 = ( ( Product C154 ) / ( C154 . ( C153 + 1 ) ) );
L768: C150 , C151 are_congruent_mod ( Product D75 ) by L757;
reconsider D77 = C149 as (FinSequence of ( INT )) by L1;
L769: ( C149 . ( C153 + 1 ) ) = ( C154 . ( C153 + 1 ) ) by L763 , L766 , FUNCT_1:47;
L770: ( C149 . ( C153 + 1 ) ) in ( rng C149 ) by L762 , FUNCT_1:3;
L771: ( C154 . ( C153 + 1 ) ) > ( 0 ) by L770 , L769 , PARTFUN3:def 1;
reconsider D78 = D76 as Integer by L766 , L260;
L772: ( D78 * ( C154 . ( C153 + 1 ) ) ) = ( ( Product C154 ) * ( ( ( C154 . ( C153 + 1 ) ) " ) * ( C154 . ( C153 + 1 ) ) ) )
.= ( ( Product C154 ) * 1 ) by L771 , XCMPLX_0:def 7
.= ( Product C154 );
L773: ( ( D77 | ( C153 + 1 ) ) | C153 ) = ( D77 | C153 ) by FINSEQ_1:82 , NAT_1:11;
L774: C154 = ( D75 ^ <* ( C154 . ( C153 + 1 ) ) *> ) by L773 , L763 , L764 , FINSEQ_3:55;
L775: ( Product C154 ) = ( ( Product D75 ) * ( C154 . ( C153 + 1 ) ) ) by L774 , RVSUM_1:96;
L776: D78 = ( ( Product D75 ) * ( ( C154 . ( C153 + 1 ) ) * ( ( C154 . ( C153 + 1 ) ) " ) ) ) by L775;
L777: D78 = ( ( Product D75 ) * 1 ) by L776 , L771 , XCMPLX_0:def 7;
L778: C150 , C151 are_congruent_mod ( C154 . ( C153 + 1 ) ) by L749 , L762 , L769;
thus L779: C150 , C151 are_congruent_mod ( Product C154 ) by L778 , L766 , L768 , L777 , L772 , L518 , L660;
end;
suppose L780: C153 = ( 0 );

L781: C154 = <* ( C154 . 1 ) *> by L780 , L764 , FINSEQ_1:40;
L782: ( dom C154 ) = ( Seg 1 ) by L781 , FINSEQ_1:38;
L783: 1 in ( dom C154 ) by L782;
L784: 1 <= ( len C149 ) by L760 , L759 , XXREAL_0:2;
L785: 1 in ( Seg ( len C149 ) ) by L784;
L786: 1 in ( dom C149 ) by L785 , FINSEQ_1:def 3;
L787: ( Product C154 ) = ( C154 . 1 ) by L781 , RVSUM_1:95
.= ( C149 . 1 ) by L763 , L783 , FUNCT_1:47;
thus L788: C150 , C151 are_congruent_mod ( Product C154 ) by L787 , L749 , L786;
end;
end;
thus L790: S7[ ( C153 + 1 ) ] by L758;
end;
L791: ( C149 | ( len C149 ) ) = C149 by FINSEQ_1:58;
L792: S7[ ( 0 ) ];
L793: (for B120 being (Element of ( NAT )) holds ((( 0 ) <= B120 & B120 <= ( len C149 )) implies S7[ B120 ])) from INT_1:sch 7(L792 , L754);
L794: C150 , C151 are_congruent_mod ( Product C149 ) by L793 , L791;
thus L795: C150 = ( C150 mod ( Product C149 ) ) by L743 , L744 , NAT_D:63
.= ( C151 mod ( Product C149 ) ) by L794 , NAT_D:64
.= C151 by L746 , L747 , NAT_D:63;
end;
begin
definition
let C155 being Integer;
let C156 being ( INT ) -valued FinSequence;
func mod (C155 , C156) -> FinSequence means 
:L796: (( len it ) = ( len C156 ) & (for B121 being Nat holds (B121 in ( dom it ) implies ( it . B121 ) = ( C155 mod ( C156 . B121 ) ))));
existence
proof
defpred S8[ set , set ] means $2 = ( C155 mod ( C156 . $1 ) );
L797: (for B122 being Nat holds (B122 in ( Seg ( len C156 ) ) implies (ex B123 being (Element of ( INT )) st S8[ B122 , B123 ])))
proof
let C157 being Nat;
assume L798: C157 in ( Seg ( len C156 ) );
reconsider D79 = ( C155 mod ( C156 . C157 ) ) as (Element of ( INT )) by INT_1:def 2;
take D79;
thus L799: thesis;
end;
consider C158 being (FinSequence of ( INT )) such that L800: (( dom C158 ) = ( Seg ( len C156 ) ) & (for B124 being Nat holds (B124 in ( Seg ( len C156 ) ) implies S8[ B124 , ( C158 . B124 ) ]))) from FINSEQ_1:sch 5(L797);
take C158;
thus L801: ( len C158 ) = ( len C156 ) by L800 , FINSEQ_1:def 3;
thus L802: thesis by L800;
end;
uniqueness
proof
let C159 , C160 being FinSequence;
assume that
L803: ( len C159 ) = ( len C156 )
and
L804: (for B125 being Nat holds (B125 in ( dom C159 ) implies ( C159 . B125 ) = ( C155 mod ( C156 . B125 ) )));
assume that
L805: ( len C160 ) = ( len C156 )
and
L806: (for B126 being Nat holds (B126 in ( dom C160 ) implies ( C160 . B126 ) = ( C155 mod ( C156 . B126 ) )));
L807: ( dom C159 ) = ( Seg ( len C159 ) ) by FINSEQ_1:def 3
.= ( dom C160 ) by L803 , L805 , FINSEQ_1:def 3;
L808:
now
let C161 being set;
assume L809: C161 in ( dom C159 );
reconsider D80 = C161 as (Element of ( NAT )) by L809;
thus L810: ( C159 . C161 ) = ( C155 mod ( C156 . D80 ) ) by L804 , L809
.= ( C160 . C161 ) by L806 , L807 , L809;
end;
thus L811: thesis by L808 , L807 , FUNCT_1:2;
end;
end;
registration
let C162 being Integer;
let C163 being ( INT ) -valued FinSequence;
cluster ( mod (C162 , C163) ) -> ( INT ) -valued;
coherence
proof
L813:
now
let C164 being set;
assume L814: C164 in ( rng ( mod (C162 , C163) ) );
consider C165 being set such that L815: C165 in ( dom ( mod (C162 , C163) ) ) and L816: ( ( mod (C162 , C163) ) . C165 ) = C164 by L814 , FUNCT_1:def 3;
reconsider D81 = C165 as (Element of ( NAT )) by L815;
reconsider D82 = D81 as Nat;
L817: C164 = ( C162 mod ( C163 . D82 ) ) by L815 , L816 , L796;
thus L818: C164 in ( INT ) by L817 , INT_1:def 2;
end;
L819: ( rng ( mod (C162 , C163) ) ) c= ( INT ) by L813 , TARSKI:def 3;
thus L820: thesis by L819 , RELAT_1:def 19;
end;
end;
definition
let C166 being CR_Sequence;
mode CR_coefficients of C166
 -> FinSequence
means :L822: (( len it ) = ( len C166 ) & (for B127 being Nat holds (B127 in ( dom it ) implies (ex B128 being Integer st (ex B129 being Integer st (B129 = ( ( Product C166 ) / ( C166 . B127 ) ) & ( B128 * B129 ) , 1 are_congruent_mod ( C166 . B127 ) & ( it . B127 ) = ( B128 * ( ( Product C166 ) / ( C166 . B127 ) ) )))))));
existence
proof
defpred S9[ set , set ] means (ex B130 being Integer st (ex B131 being Integer st (B131 = ( ( Product C166 ) / ( C166 . $1 ) ) & ( B130 * B131 ) , 1 are_congruent_mod ( C166 . $1 ) & $2 = ( B130 * ( ( Product C166 ) / ( C166 . $1 ) ) ))));
L823: (for B132 being Nat holds (B132 in ( Seg ( len C166 ) ) implies (ex B133 being (Element of ( INT )) st S9[ B132 , B133 ])))
proof
let C167 being Nat;
assume L824: C167 in ( Seg ( len C166 ) );
L825: C167 in ( dom C166 ) by L824 , FINSEQ_1:def 3;
reconsider D83 = ( ( Product C166 ) / ( C166 . C167 ) ) as Integer by L825 , L260;
consider C168 being Integer such that L826: ( C168 * D83 ) , 1 are_congruent_mod ( C166 . C167 ) by L825 , L528 , L660;
set D84 = ( C168 * D83 );
reconsider D85 = D84 as (Element of ( INT )) by INT_1:def 2;
take D85;
take C168;
take D83;
thus L827: thesis by L826;
end;
consider C169 being (FinSequence of ( INT )) such that L828: (( dom C169 ) = ( Seg ( len C166 ) ) & (for B134 being Nat holds (B134 in ( Seg ( len C166 ) ) implies S9[ B134 , ( C169 . B134 ) ]))) from FINSEQ_1:sch 5(L823);
take C169;
thus L829: thesis by L828 , FINSEQ_1:def 3;
end;
end;
registration
let C170 being CR_Sequence;
cluster  -> ( INT ) -valued for (CR_coefficients of C170);
coherence
proof
let C171 being (CR_coefficients of C170);
L831:
now
let C172 being set;
assume L832: C172 in ( rng C171 );
consider C173 being set such that L833: C173 in ( dom C171 ) and L834: ( C171 . C173 ) = C172 by L832 , FUNCT_1:def 3;
reconsider D86 = C173 as (Element of ( NAT )) by L833;
reconsider D87 = D86 as Nat;
L835: (ex B135 being Integer st (ex B136 being Integer st (B136 = ( ( Product C170 ) / ( C170 . D87 ) ) & ( B135 * B136 ) , 1 are_congruent_mod ( C170 . D87 ) & ( C171 . D87 ) = ( B135 * ( ( Product C170 ) / ( C170 . D87 ) ) )))) by L833 , L822;
thus L836: C172 in ( INT ) by L835 , L834 , INT_1:def 2;
end;
L837: ( rng C171 ) c= ( INT ) by L831 , TARSKI:def 3;
thus L838: thesis by L837 , RELAT_1:def 19;
end;
end;
theorem
L840: (for B137 being CR_Sequence holds (for B138 being (CR_coefficients of B137) holds (for B139 being Nat holds (B139 in ( dom B138 ) implies ( B138 . B139 ) , 1 are_congruent_mod ( B137 . B139 )))))
proof
let C174 being CR_Sequence;
let C175 being (CR_coefficients of C174);
let C176 being Nat;
assume L841: C176 in ( dom C175 );
L842: (ex B140 being Integer st (ex B141 being Integer st (B141 = ( ( Product C174 ) / ( C174 . C176 ) ) & ( B140 * B141 ) , 1 are_congruent_mod ( C174 . C176 ) & ( C175 . C176 ) = ( B140 * ( ( Product C174 ) / ( C174 . C176 ) ) )))) by L841 , L822;
thus L843: thesis by L842;
end;
theorem
L844: (for B142 being CR_Sequence holds (for B143 being (CR_coefficients of B142) holds (for B144 , B145 being Nat holds ((B144 in ( dom B143 ) & B145 in ( dom B143 ) & B144 <> B145) implies ( B143 . B144 ) , ( 0 ) are_congruent_mod ( B142 . B145 )))))
proof
let C177 being CR_Sequence;
let C178 being (CR_coefficients of C177);
let C179 , C180 being Nat;
assume that
L845: C179 in ( dom C178 )
and
L846: C180 in ( dom C178 )
and
L847: C179 <> C180;
consider C181 being Integer, C182 being Integer such that L848: C182 = ( ( Product C177 ) / ( C177 . C179 ) ) and L849: ( C181 * C182 ) , 1 are_congruent_mod ( C177 . C179 ) and L850: ( C178 . C179 ) = ( C181 * ( ( Product C177 ) / ( C177 . C179 ) ) ) by L845 , L822;
L851: ( len C177 ) = ( len C178 ) by L822;
L852: ( dom C177 ) = ( Seg ( len C178 ) ) by L851 , FINSEQ_1:def 3
.= ( dom C178 ) by FINSEQ_1:def 3;
consider C183 being Integer such that L853: ( C183 * ( C177 . C180 ) ) = C182 by L852 , L845 , L846 , L847 , L848 , L279;
L854: ( C177 . C180 ) , ( 0 ) are_congruent_mod ( C177 . C180 ) by INT_1:12;
L855: C181 , C181 are_congruent_mod ( C177 . C180 ) by INT_1:11;
L856: C183 , C183 are_congruent_mod ( C177 . C180 ) by INT_1:11;
L857: ( C183 * ( C177 . C180 ) ) , ( C183 * ( 0 ) ) are_congruent_mod ( C177 . C180 ) by L856 , L854 , INT_1:18;
L858: ( C181 * C182 ) , ( C181 * ( 0 ) ) are_congruent_mod ( C177 . C180 ) by L857 , L853 , L855 , INT_1:18;
thus L859: thesis by L858 , L848 , L850;
end;
theorem
L860: (for B146 being CR_Sequence holds (for B147 , B148 being (CR_coefficients of B146) holds (for B149 being Nat holds (B149 in ( dom B147 ) implies ( B147 . B149 ) , ( B148 . B149 ) are_congruent_mod ( B146 . B149 )))))
proof
let C184 being CR_Sequence;
let C185 , C186 being (CR_coefficients of C184);
let C187 being Nat;
assume L861: C187 in ( dom C185 );
L862: (ex B150 being Integer st (ex B151 being Integer st (B151 = ( ( Product C184 ) / ( C184 . C187 ) ) & ( B150 * B151 ) , 1 are_congruent_mod ( C184 . C187 ) & ( C185 . C187 ) = ( B150 * ( ( Product C184 ) / ( C184 . C187 ) ) )))) by L861 , L822;
L863: ( len C185 ) = ( len C184 ) by L822
.= ( len C186 ) by L822;
L864: ( dom C185 ) = ( Seg ( len C185 ) ) by FINSEQ_1:def 3
.= ( dom C186 ) by L863 , FINSEQ_1:def 3;
consider C188 being Integer, C189 being Integer such that L865: C189 = ( ( Product C184 ) / ( C184 . C187 ) ) and L866: ( C188 * C189 ) , 1 are_congruent_mod ( C184 . C187 ) and L867: ( C186 . C187 ) = ( C188 * ( ( Product C184 ) / ( C184 . C187 ) ) ) by L864 , L861 , L822;
L868: 1 , ( C188 * C189 ) are_congruent_mod ( C184 . C187 ) by L866 , INT_1:14;
thus L869: thesis by L868 , L862 , L865 , L867 , INT_1:15;
end;
theorem
L870: (for B152 being ( INT ) -valued FinSequence holds (for B153 being CR_Sequence holds (( len B153 ) = ( len B152 ) implies (for B154 being (CR_coefficients of B153) holds (for B155 being Nat holds (B155 in ( dom B153 ) implies ( Sum ( B152 (#) B154 ) ) , ( B152 . B155 ) are_congruent_mod ( B153 . B155 )))))))
proof
let C190 being ( INT ) -valued FinSequence;
let C191 being CR_Sequence;
assume L871: ( len C191 ) = ( len C190 );
let C192 being (CR_coefficients of C191);
let C193 being Nat;
defpred S10[ Nat ] means (for B156 , B157 being ( INT ) -valued FinSequence holds ((B156 = ( C190 | $1 ) & B157 = ( C192 | $1 )) implies (($1 < C193 & ( Sum ( B156 (#) B157 ) ) , ( 0 ) are_congruent_mod ( C191 . C193 )) or ($1 >= C193 & ( Sum ( B156 (#) B157 ) ) , ( C190 . C193 ) are_congruent_mod ( C191 . C193 )))));
assume L872: C193 in ( dom C191 );
L873: ( len C191 ) = ( len C192 ) by L822;
L874: ( dom C191 ) = ( Seg ( len C192 ) ) by L873 , FINSEQ_1:def 3
.= ( dom C192 ) by FINSEQ_1:def 3;
L875:
now
let C194 being (Element of ( NAT ));
assume that
L876: ( 0 ) <= C194
and
L877: C194 < ( len C190 )
and
L878: S10[ C194 ];
L879:
now
set D88 = ( C190 | C194 );
set D89 = ( C192 | C194 );
let C195 , C196 being ( INT ) -valued FinSequence;
L880: ( ( 0 ) + 1 ) <= ( C194 + 1 ) by XREAL_1:6;
reconsider D90 = ( C195 (#) C196 ) , D91 = ( D88 (#) D89 ) as (FinSequence of ( REAL )) by L180;
assume that
L881: C195 = ( C190 | ( C194 + 1 ) )
and
L882: C196 = ( C192 | ( C194 + 1 ) );
L883: ( C194 + 1 ) <= ( len C190 ) by L877 , NAT_1:13;
L884: ( len C195 ) = ( C194 + 1 ) by L883 , L881 , FINSEQ_1:59;
L885: ( C194 + 1 ) in ( Seg ( len C195 ) ) by L884 , L880;
L886: ( C194 + 1 ) in ( dom C195 ) by L885 , FINSEQ_1:def 3;
L887: ( C195 . ( C194 + 1 ) ) = ( C190 . ( C194 + 1 ) ) by L886 , L881 , FUNCT_1:47;
L888: ( C194 + 1 ) <= ( len C192 ) by L871 , L873 , L877 , NAT_1:13;
L889: ( C194 + 1 ) in ( Seg ( len C192 ) ) by L888 , L880;
L890: ( C194 + 1 ) in ( dom C192 ) by L889 , FINSEQ_1:def 3;
reconsider D92 = ( ( C195 . ( C194 + 1 ) ) * ( C196 . ( C194 + 1 ) ) ) as (Element of ( REAL )) by XREAL_0:def 1;
reconsider D93 = <* D92 *> as (FinSequence of ( REAL ));
L891: ( len C190 ) = ( len C192 ) by L871 , L822;
L892: ( len C196 ) = ( C194 + 1 ) by L882 , L888 , FINSEQ_1:59;
L893: ( C194 + 1 ) in ( Seg ( len C196 ) ) by L892 , L880;
L894: ( C194 + 1 ) in ( dom C196 ) by L893 , FINSEQ_1:def 3;
L895: ( C196 . ( C194 + 1 ) ) = ( C192 . ( C194 + 1 ) ) by L894 , L882 , FUNCT_1:47;
L896: ( C194 + 1 ) <= ( len C190 ) by L877 , NAT_1:13;
L897: ( ( ( C190 (#) C192 ) | C194 ) ^ <* ( ( C195 . ( C194 + 1 ) ) * ( C196 . ( C194 + 1 ) ) ) *> ) = ( ( C190 (#) C192 ) | ( C194 + 1 ) )
proof
set D94 = ( ( ( C190 (#) C192 ) | C194 ) ^ <* ( ( C195 . ( C194 + 1 ) ) * ( C196 . ( C194 + 1 ) ) ) *> );
set D95 = ( ( C190 (#) C192 ) | ( C194 + 1 ) );
L898: ( C194 + 1 ) <= ( len ( C190 (#) C192 ) ) by L871 , L873 , L896 , L111;
L899: C194 <= ( len ( C190 (#) C192 ) ) by L898 , NAT_1:13;
L900: ( len D94 ) = ( ( len ( ( C190 (#) C192 ) | C194 ) ) + 1 ) by FINSEQ_2:16
.= ( C194 + 1 ) by L899 , FINSEQ_1:59;
L901: ( C194 + 1 ) = ( len D95 ) by L898 , FINSEQ_1:59;
L902:
now
let C197 being Nat;
assume that
L903: 1 <= C197
and
L904: C197 <= ( len D94 );
L905: C197 in ( NAT ) by ORDINAL1:def 12;
per cases ;
suppose L906: C197 in ( dom ( ( C190 (#) C192 ) | C194 ) );

L907: C197 in ( Seg ( C194 + 1 ) ) by L900 , L903 , L904 , L905;
L908: C197 in ( dom D95 ) by L907 , L901 , FINSEQ_1:def 3;
thus L909: ( D94 . C197 ) = ( ( ( C190 (#) C192 ) | C194 ) . C197 ) by L906 , FINSEQ_1:def 7
.= ( ( C190 (#) C192 ) . C197 ) by L906 , FUNCT_1:47
.= ( D95 . C197 ) by L908 , FUNCT_1:47;
end;
suppose L910: (not C197 in ( dom ( ( C190 (#) C192 ) | C194 ) ));

L911: C194 <= ( len ( C190 (#) C192 ) ) by L877 , L891 , L111;
L912: ( len ( ( C190 (#) C192 ) | C194 ) ) = C194 by L911 , FINSEQ_1:59;
L913: ( dom ( ( C190 (#) C192 ) | C194 ) ) = ( Seg C194 ) by L912 , FINSEQ_1:def 3;
L914: C197 > C194 by L913 , L903 , L905 , L910;
L915: C197 >= ( C194 + 1 ) by L914 , NAT_1:13;
L916: C197 = ( C194 + 1 ) by L915 , L900 , L904 , XXREAL_0:1;
L917: ( dom <* ( ( C195 . ( C194 + 1 ) ) * ( C196 . ( C194 + 1 ) ) ) *> ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
L918: 1 in ( dom <* ( ( C195 . ( C194 + 1 ) ) * ( C196 . ( C194 + 1 ) ) ) *> ) by L917 , TARSKI:def 1;
L919: ( D94 . ( C194 + 1 ) ) = ( <* ( ( C195 . ( C194 + 1 ) ) * ( C196 . ( C194 + 1 ) ) ) *> . 1 ) by L918 , L912 , FINSEQ_1:def 7
.= ( ( C195 . ( C194 + 1 ) ) * ( C196 . ( C194 + 1 ) ) ) by FINSEQ_1:40;
L920: ( C194 + 1 ) <= ( len ( C190 (#) C192 ) ) by L888 , L891 , L111;
L921: C197 in ( Seg ( len ( C190 (#) C192 ) ) ) by L920 , L880 , L916;
L922: C197 in ( dom ( C190 (#) C192 ) ) by L921 , FINSEQ_1:def 3;
L923: C197 in ( Seg ( C194 + 1 ) ) by L900 , L903 , L904 , L905;
L924: C197 in ( dom D95 ) by L923 , L901 , FINSEQ_1:def 3;
L925: ( D95 . C197 ) = ( ( C190 (#) C192 ) . C197 ) by L924 , FUNCT_1:47
.= ( ( C195 . ( C194 + 1 ) ) * ( C196 . ( C194 + 1 ) ) ) by L895 , L887 , L916 , L922 , VALUED_1:def 4;
thus L926: ( D94 . C197 ) = ( D95 . C197 ) by L925 , L900 , L904 , L915 , L919 , XXREAL_0:1;
end;
end;
thus L928: thesis by L902 , L900 , L901 , FINSEQ_1:14;
end;
L929: ( D88 (#) D89 ) = ( ( C190 (#) C192 ) | C194 ) by L877 , L891 , L114;
L930: D90 = ( D91 ^ D93 ) by L929 , L881 , L882 , L896 , L891 , L897 , L114;
L931: ( Sum ( C195 (#) C196 ) ) = ( ( Sum D91 ) + ( Sum D93 ) ) by L930 , RVSUM_1:75
.= ( ( Sum ( D88 (#) D89 ) ) + ( ( C195 . ( C194 + 1 ) ) * ( C196 . ( C194 + 1 ) ) ) ) by RVSUM_1:73;
L932: C194 < ( C194 + 1 ) by NAT_1:13;
L933:
now
per cases  by XXREAL_0:1;
case L934: ( C194 + 1 ) < C193;
L935: C194 < C193 by L934 , NAT_1:13;
L936: ( Sum ( D88 (#) D89 ) ) , ( 0 ) are_congruent_mod ( C191 . C193 ) by L935 , L878;
L937: ( C195 . ( C194 + 1 ) ) , ( C195 . ( C194 + 1 ) ) are_congruent_mod ( C191 . C193 ) by INT_1:11;
L938: ( C196 . ( C194 + 1 ) ) , ( 0 ) are_congruent_mod ( C191 . C193 ) by L872 , L874 , L890 , L895 , L934 , L844;
L939: ( ( C195 . ( C194 + 1 ) ) * ( C196 . ( C194 + 1 ) ) ) , ( ( C195 . ( C194 + 1 ) ) * ( 0 ) ) are_congruent_mod ( C191 . C193 ) by L938 , L937 , INT_1:18;
L940: ( Sum ( C195 (#) C196 ) ) , ( ( 0 ) + ( ( C195 . ( C194 + 1 ) ) * ( 0 ) ) ) are_congruent_mod ( C191 . C193 ) by L939 , L931 , L936 , INT_1:16;
thus L941: ( Sum ( C195 (#) C196 ) ) , ( 0 ) are_congruent_mod ( C191 . C193 ) by L940;
end;
case L942: ( C194 + 1 ) = C193;
L943: ( C195 . ( C194 + 1 ) ) , ( C195 . ( C194 + 1 ) ) are_congruent_mod ( C191 . C193 ) by INT_1:11;
L944: ( C196 . ( C194 + 1 ) ) , 1 are_congruent_mod ( C191 . C193 ) by L890 , L895 , L942 , L840;
L945: ( ( C195 . ( C194 + 1 ) ) * ( C196 . ( C194 + 1 ) ) ) , ( ( C190 . ( C194 + 1 ) ) * 1 ) are_congruent_mod ( C191 . C193 ) by L944 , L887 , L943 , INT_1:18;
L946: ( Sum ( D88 (#) D89 ) ) , ( 0 ) are_congruent_mod ( C191 . C193 ) by L878 , L932 , L942;
thus L947: ( Sum ( C195 (#) C196 ) ) , ( ( 0 ) + ( C190 . C193 ) ) are_congruent_mod ( C191 . C193 ) by L946 , L931 , L942 , L945 , INT_1:16;
end;
case L948: ( C194 + 1 ) > C193;
L949: C194 >= C193 by L948 , NAT_1:13;
L950: ( Sum ( D88 (#) D89 ) ) , ( C190 . C193 ) are_congruent_mod ( C191 . C193 ) by L949 , L878;
L951: ( C195 . ( C194 + 1 ) ) , ( C195 . ( C194 + 1 ) ) are_congruent_mod ( C191 . C193 ) by INT_1:11;
L952: ( C196 . ( C194 + 1 ) ) , ( 0 ) are_congruent_mod ( C191 . C193 ) by L872 , L874 , L890 , L895 , L948 , L844;
L953: ( ( C195 . ( C194 + 1 ) ) * ( C196 . ( C194 + 1 ) ) ) , ( ( C190 . ( C194 + 1 ) ) * ( 0 ) ) are_congruent_mod ( C191 . C193 ) by L952 , L887 , L951 , INT_1:18;
thus L954: ( Sum ( C195 (#) C196 ) ) , ( ( C190 . C193 ) + ( 0 ) ) are_congruent_mod ( C191 . C193 ) by L953 , L931 , L950 , INT_1:16;
end;
end;
thus L956: ((( C194 + 1 ) < C193 & ( Sum ( C195 (#) C196 ) ) , ( 0 ) are_congruent_mod ( C191 . C193 )) or (( C194 + 1 ) >= C193 & ( Sum ( C195 (#) C196 ) ) , ( C190 . C193 ) are_congruent_mod ( C191 . C193 ))) by L933;
end;
thus L957: S10[ ( C194 + 1 ) ] by L879;
end;
L958: ( dom C191 ) = ( Seg ( len C190 ) ) by L871 , FINSEQ_1:def 3;
L959:
now
let C198 , C199 being ( INT ) -valued FinSequence;
assume that
L960: C198 = ( C190 | ( 0 ) )
and
L961: C199 = ( C192 | ( 0 ) );
L962: ( ( dom C198 ) /\ ( dom C199 ) ) = ( {} ) by L960 , L961;
L963: ( dom ( C198 (#) C199 ) ) = ( {} ) by L962 , VALUED_1:def 4;
L964: ( C198 (#) C199 ) = ( {} ) by L963;
thus L965: ((( 0 ) < C193 & ( Sum ( C198 (#) C199 ) ) , ( 0 ) are_congruent_mod ( C191 . C193 )) or (( 0 ) >= C193 & ( Sum ( C198 (#) C199 ) ) , ( C190 . C193 ) are_congruent_mod ( C191 . C193 ))) by L964 , L872 , L958 , FINSEQ_1:1 , INT_1:11 , RVSUM_1:72;
end;
L966: S10[ ( 0 ) ] by L959;
L967: (for B158 being (Element of ( NAT )) holds ((( 0 ) <= B158 & B158 <= ( len C190 )) implies S10[ B158 ])) from INT_1:sch 7(L966 , L875);
L968: ( len C190 ) = ( len C192 ) by L871 , L822;
L969: ( C192 | ( len C190 ) ) = C192 by L968 , FINSEQ_1:58;
L970: C190 = ( C190 | ( len C190 ) ) by FINSEQ_1:58;
L971: C193 <= ( len C190 ) by L872 , L958 , FINSEQ_1:1;
thus L972: thesis by L971 , L967 , L970 , L969;
end;
theorem
L973: (for B159 being ( INT ) -valued FinSequence holds (for B160 being CR_Sequence holds (( len B160 ) = ( len B159 ) implies (for B161 , B162 being (CR_coefficients of B160) holds ( Sum ( B159 (#) B161 ) ) , ( Sum ( B159 (#) B162 ) ) are_congruent_mod ( Product B160 )))))
proof
let C200 being ( INT ) -valued FinSequence;
let C201 being CR_Sequence;
assume L974: ( len C200 ) = ( len C201 );
let C202 , C203 being (CR_coefficients of C201);
set D96 = ( ( Sum ( C200 (#) C202 ) ) mod ( Product C201 ) );
set D97 = ( ( Sum ( C200 (#) C203 ) ) mod ( Product C201 ) );
L975: D96 < ( Product C201 ) by NAT_D:62;
L976: (for B163 being Nat holds (B163 in ( dom C201 ) implies D96 , ( C200 . B163 ) are_congruent_mod ( C201 . B163 )))
proof
let C204 being Nat;
L977: ( D96 mod ( Product C201 ) ) = ( ( Sum ( C200 (#) C202 ) ) mod ( Product C201 ) ) by NAT_D:65;
L978: D96 , ( Sum ( C200 (#) C202 ) ) are_congruent_mod ( Product C201 ) by L977 , NAT_D:64;
assume L979: C204 in ( dom C201 );
L980: ( C201 . C204 ) in ( rng C201 ) by L979 , FUNCT_1:3;
L981: ( C201 . C204 ) > ( 0 ) by L980 , PARTFUN3:def 1;
L982: (ex B164 being Integer st ( B164 * ( C201 . C204 ) ) = ( Product C201 )) by L979 , L272;
L983: D96 , ( Sum ( C200 (#) C202 ) ) are_congruent_mod ( C201 . C204 ) by L982 , L978 , INT_1:20;
L984: ( D96 mod ( C201 . C204 ) ) = ( ( Sum ( C200 (#) C202 ) ) mod ( C201 . C204 ) ) by L983 , NAT_D:64;
L985: ( Sum ( C200 (#) C202 ) ) , ( C200 . C204 ) are_congruent_mod ( C201 . C204 ) by L974 , L979 , L870;
L986: ( ( Sum ( C200 (#) C202 ) ) mod ( C201 . C204 ) ) = ( ( C200 . C204 ) mod ( C201 . C204 ) ) by L985 , NAT_D:64;
thus L987: thesis by L986 , L981 , L984 , NAT_D:64;
end;
L988: ( 0 ) <= D97 by NAT_D:62;
L989: (for B165 being Nat holds (B165 in ( dom C201 ) implies D97 , ( C200 . B165 ) are_congruent_mod ( C201 . B165 )))
proof
let C205 being Nat;
L990: ( D97 mod ( Product C201 ) ) = ( ( Sum ( C200 (#) C203 ) ) mod ( Product C201 ) ) by NAT_D:65;
L991: D97 , ( Sum ( C200 (#) C203 ) ) are_congruent_mod ( Product C201 ) by L990 , NAT_D:64;
assume L992: C205 in ( dom C201 );
L993: ( C201 . C205 ) in ( rng C201 ) by L992 , FUNCT_1:3;
L994: ( C201 . C205 ) > ( 0 ) by L993 , PARTFUN3:def 1;
L995: (ex B166 being Integer st ( B166 * ( C201 . C205 ) ) = ( Product C201 )) by L992 , L272;
L996: D97 , ( Sum ( C200 (#) C203 ) ) are_congruent_mod ( C201 . C205 ) by L995 , L991 , INT_1:20;
L997: ( D97 mod ( C201 . C205 ) ) = ( ( Sum ( C200 (#) C203 ) ) mod ( C201 . C205 ) ) by L996 , NAT_D:64;
L998: ( Sum ( C200 (#) C203 ) ) , ( C200 . C205 ) are_congruent_mod ( C201 . C205 ) by L974 , L992 , L870;
L999: ( ( Sum ( C200 (#) C203 ) ) mod ( C201 . C205 ) ) = ( ( C200 . C205 ) mod ( C201 . C205 ) ) by L998 , NAT_D:64;
thus L1000: thesis by L999 , L994 , L997 , NAT_D:64;
end;
L1001: D97 < ( Product C201 ) by NAT_D:62;
L1002: ( 0 ) <= D96 by NAT_D:62;
L1003: D96 = D97 by L1002 , L976 , L989 , L975 , L988 , L1001 , L742;
thus L1004: thesis by L1003 , NAT_D:64;
end;
definition
let C206 being ( INT ) -valued FinSequence;
let C207 being CR_Sequence;
assume that
L1005: ( len C207 ) = ( len C206 );
func to_int (C206 , C207) -> Integer means 
:L1006: (for B167 being (CR_coefficients of C207) holds it = ( ( Sum ( C206 (#) B167 ) ) mod ( Product C207 ) ));
existence
proof
set D98 = the (CR_coefficients of C207);
set D99 = ( ( Sum ( C206 (#) D98 ) ) mod ( Product C207 ) );
take D99;
L1007:
now
let C208 being (CR_coefficients of C207);
L1008: ( Sum ( C206 (#) C208 ) ) , ( Sum ( C206 (#) D98 ) ) are_congruent_mod ( Product C207 ) by L1005 , L973;
thus L1009: D99 = ( ( Sum ( C206 (#) C208 ) ) mod ( Product C207 ) ) by L1008 , NAT_D:64;
end;
thus L1010: thesis by L1007;
end;
uniqueness
proof
set D100 = the (CR_coefficients of C207);
let C209 , C210 being Integer;
assume L1011: (for B168 being (CR_coefficients of C207) holds C209 = ( ( Sum ( C206 (#) B168 ) ) mod ( Product C207 ) ));
assume L1012: (for B169 being (CR_coefficients of C207) holds C210 = ( ( Sum ( C206 (#) B169 ) ) mod ( Product C207 ) ));
thus L1013: C209 = ( ( Sum ( C206 (#) D100 ) ) mod ( Product C207 ) ) by L1011
.= C210 by L1012;
end;
end;
theorem
L1015: (for B170 being ( INT ) -valued FinSequence holds (for B171 being CR_Sequence holds (( len B171 ) = ( len B170 ) implies (( 0 ) <= ( to_int (B170 , B171) ) & ( to_int (B170 , B171) ) < ( Product B171 )))))
proof
let C211 being ( INT ) -valued FinSequence;
let C212 being CR_Sequence;
set D101 = ( to_int (C211 , C212) );
set D102 = the (CR_coefficients of C212);
assume L1016: ( len C211 ) = ( len C212 );
L1017: D101 = ( ( Sum ( C211 (#) D102 ) ) mod ( Product C212 ) ) by L1016 , L1006;
thus L1018: thesis by L1017 , NAT_D:62;
end;
theorem
L1019: (for B172 being Integer holds (for B173 being CR_Sequence holds (for B174 being Nat holds (B174 in ( dom B173 ) implies B172 , ( ( mod (B172 , B173) ) . B174 ) are_congruent_mod ( B173 . B174 )))))
proof
let C213 being Integer;
let C214 being CR_Sequence;
let C215 being Nat;
L1020: ( len ( mod (C213 , C214) ) ) = ( len C214 ) by L796;
assume L1021: C215 in ( dom C214 );
L1022: ( C214 . C215 ) in ( rng C214 ) by L1021 , FUNCT_1:3;
L1023: ( C214 . C215 ) > ( 0 ) by L1022 , PARTFUN3:def 1;
L1024: ( C213 mod ( C214 . C215 ) ) = ( C213 - ( ( C213 div ( C214 . C215 ) ) * ( C214 . C215 ) ) ) by L1023 , INT_1:def 10;
L1025: ( C213 - ( C213 mod ( C214 . C215 ) ) ) = ( ( C213 div ( C214 . C215 ) ) * ( C214 . C215 ) ) by L1024;
L1026: ( dom ( mod (C213 , C214) ) ) = ( Seg ( len ( mod (C213 , C214) ) ) ) by FINSEQ_1:def 3
.= ( dom C214 ) by L1020 , FINSEQ_1:def 3;
L1027: ( ( mod (C213 , C214) ) . C215 ) = ( C213 mod ( C214 . C215 ) ) by L1026 , L1021 , L796;
thus L1028: thesis by L1027 , L1025 , INT_1:def 5;
end;
theorem
L1029: (for B175 , B176 being Integer holds (for B177 being CR_Sequence holds (for B178 being Nat holds (B178 in ( dom B177 ) implies ( ( ( mod (B175 , B177) ) + ( mod (B176 , B177) ) ) . B178 ) , ( B175 + B176 ) are_congruent_mod ( B177 . B178 )))))
proof
let C216 , C217 being Integer;
let C218 being CR_Sequence;
let C219 being Nat;
assume L1030: C219 in ( dom C218 );
L1031: ( len ( mod (C217 , C218) ) ) = ( len C218 ) by L796;
L1032: ( dom ( mod (C217 , C218) ) ) = ( Seg ( len C218 ) ) by L1031 , FINSEQ_1:def 3
.= ( dom C218 ) by FINSEQ_1:def 3;
L1033: ( ( mod (C217 , C218) ) . C219 ) = ( C217 mod ( C218 . C219 ) ) by L1032 , L1030 , L796;
L1034: ( len ( mod (C216 , C218) ) ) = ( len C218 ) by L796;
L1035: ( len ( ( mod (C216 , C218) ) + ( mod (C217 , C218) ) ) ) = ( len C218 ) by L1034 , L1031 , L105;
L1036: ( dom ( ( mod (C216 , C218) ) + ( mod (C217 , C218) ) ) ) = ( Seg ( len C218 ) ) by L1035 , FINSEQ_1:def 3
.= ( dom C218 ) by FINSEQ_1:def 3;
L1037: ( ( ( mod (C216 , C218) ) + ( mod (C217 , C218) ) ) . C219 ) = ( ( ( mod (C216 , C218) ) . C219 ) + ( ( mod (C217 , C218) ) . C219 ) ) by L1036 , L1030 , VALUED_1:def 1;
L1038: ( dom ( mod (C216 , C218) ) ) = ( Seg ( len C218 ) ) by L1034 , FINSEQ_1:def 3
.= ( dom C218 ) by FINSEQ_1:def 3;
L1039: ( ( mod (C216 , C218) ) . C219 ) = ( C216 mod ( C218 . C219 ) ) by L1038 , L1030 , L796;
L1040: ( ( ( ( mod (C216 , C218) ) . C219 ) + ( ( mod (C217 , C218) ) . C219 ) ) mod ( C218 . C219 ) ) = ( ( C216 + C217 ) mod ( C218 . C219 ) ) by L1039 , L1033 , NAT_D:66;
L1041: ( C218 . C219 ) in ( rng C218 ) by L1030 , FUNCT_1:3;
L1042: ( C218 . C219 ) > ( 0 ) by L1041 , PARTFUN3:def 1;
thus L1043: thesis by L1042 , L1037 , L1040 , NAT_D:64;
end;
L1044: (for B179 , B180 being Integer holds (for B181 being CR_Sequence holds (for B182 being Nat holds (B182 in ( dom B181 ) implies ( ( ( mod (B179 , B181) ) - ( mod (B180 , B181) ) ) . B182 ) , ( B179 - B180 ) are_congruent_mod ( B181 . B182 )))))
proof
let C220 , C221 being Integer;
let C222 being CR_Sequence;
let C223 being Nat;
assume L1045: C223 in ( dom C222 );
L1046: ( len ( mod (C221 , C222) ) ) = ( len C222 ) by L796;
L1047: ( dom ( mod (C221 , C222) ) ) = ( Seg ( len C222 ) ) by L1046 , FINSEQ_1:def 3
.= ( dom C222 ) by FINSEQ_1:def 3;
L1048: ( ( mod (C221 , C222) ) . C223 ) = ( C221 mod ( C222 . C223 ) ) by L1047 , L1045 , L796;
L1049: ( len ( mod (C220 , C222) ) ) = ( len C222 ) by L796;
L1050: ( len ( ( mod (C220 , C222) ) - ( mod (C221 , C222) ) ) ) = ( len C222 ) by L1049 , L1046 , L108;
L1051: ( dom ( ( mod (C220 , C222) ) - ( mod (C221 , C222) ) ) ) = ( Seg ( len C222 ) ) by L1050 , FINSEQ_1:def 3
.= ( dom C222 ) by FINSEQ_1:def 3;
L1052: ( ( ( mod (C220 , C222) ) - ( mod (C221 , C222) ) ) . C223 ) = ( ( ( mod (C220 , C222) ) . C223 ) - ( ( mod (C221 , C222) ) . C223 ) ) by L1051 , L1045 , VALUED_1:13;
L1053: ( dom ( mod (C220 , C222) ) ) = ( Seg ( len C222 ) ) by L1049 , FINSEQ_1:def 3
.= ( dom C222 ) by FINSEQ_1:def 3;
L1054: ( ( mod (C220 , C222) ) . C223 ) = ( C220 mod ( C222 . C223 ) ) by L1053 , L1045 , L796;
L1055: ( ( ( ( mod (C220 , C222) ) . C223 ) - ( ( mod (C221 , C222) ) . C223 ) ) mod ( C222 . C223 ) ) = ( ( C220 - C221 ) mod ( C222 . C223 ) ) by L1054 , L1048 , L244;
L1056: ( C222 . C223 ) in ( rng C222 ) by L1045 , FUNCT_1:3;
L1057: ( C222 . C223 ) > ( 0 ) by L1056 , PARTFUN3:def 1;
thus L1058: thesis by L1057 , L1052 , L1055 , NAT_D:64;
end;
theorem
L1059: (for B183 , B184 being Integer holds (for B185 being CR_Sequence holds (for B186 being Nat holds (B186 in ( dom B185 ) implies ( ( ( mod (B183 , B185) ) (#) ( mod (B184 , B185) ) ) . B186 ) , ( B183 * B184 ) are_congruent_mod ( B185 . B186 )))))
proof
let C224 , C225 being Integer;
let C226 being CR_Sequence;
let C227 being Nat;
assume L1060: C227 in ( dom C226 );
L1061: ( len ( mod (C225 , C226) ) ) = ( len C226 ) by L796;
L1062: ( dom ( mod (C225 , C226) ) ) = ( Seg ( len C226 ) ) by L1061 , FINSEQ_1:def 3
.= ( dom C226 ) by FINSEQ_1:def 3;
L1063: ( ( mod (C225 , C226) ) . C227 ) = ( C225 mod ( C226 . C227 ) ) by L1062 , L1060 , L796;
L1064: ( len ( mod (C224 , C226) ) ) = ( len C226 ) by L796;
L1065: ( len ( ( mod (C224 , C226) ) (#) ( mod (C225 , C226) ) ) ) = ( len C226 ) by L1064 , L1061 , L111;
L1066: ( dom ( ( mod (C224 , C226) ) (#) ( mod (C225 , C226) ) ) ) = ( Seg ( len C226 ) ) by L1065 , FINSEQ_1:def 3
.= ( dom C226 ) by FINSEQ_1:def 3;
L1067: ( ( ( mod (C224 , C226) ) (#) ( mod (C225 , C226) ) ) . C227 ) = ( ( ( mod (C224 , C226) ) . C227 ) * ( ( mod (C225 , C226) ) . C227 ) ) by L1066 , L1060 , VALUED_1:def 4;
L1068: ( dom ( mod (C224 , C226) ) ) = ( Seg ( len C226 ) ) by L1064 , FINSEQ_1:def 3
.= ( dom C226 ) by FINSEQ_1:def 3;
L1069: ( ( mod (C224 , C226) ) . C227 ) = ( C224 mod ( C226 . C227 ) ) by L1068 , L1060 , L796;
L1070: ( ( ( ( mod (C224 , C226) ) . C227 ) * ( ( mod (C225 , C226) ) . C227 ) ) mod ( C226 . C227 ) ) = ( ( C224 * C225 ) mod ( C226 . C227 ) ) by L1069 , L1063 , NAT_D:67;
L1071: ( C226 . C227 ) in ( rng C226 ) by L1060 , FUNCT_1:3;
L1072: ( C226 . C227 ) > ( 0 ) by L1071 , PARTFUN3:def 1;
thus L1073: thesis by L1072 , L1067 , L1070 , NAT_D:64;
end;
theorem
L1074: (for B187 , B188 being Integer holds (for B189 being CR_Sequence holds (for B190 being Nat holds (B190 in ( dom B189 ) implies ( to_int (( ( mod (B187 , B189) ) + ( mod (B188 , B189) ) ) , B189) ) , ( B187 + B188 ) are_congruent_mod ( B189 . B190 )))))
proof
let C228 , C229 being Integer;
let C230 being CR_Sequence;
let C231 being Nat;
set D103 = ( to_int (( ( mod (C228 , C230) ) + ( mod (C229 , C230) ) ) , C230) );
set D104 = the (CR_coefficients of C230);
L1075: ( len ( mod (C228 , C230) ) ) = ( len C230 ) by L796;
L1076: ( len ( mod (C229 , C230) ) ) = ( len C230 ) by L796;
L1077: ( len ( ( mod (C228 , C230) ) + ( mod (C229 , C230) ) ) ) = ( len C230 ) by L1076 , L1075 , L105;
L1078: D103 = ( ( Sum ( ( ( mod (C228 , C230) ) + ( mod (C229 , C230) ) ) (#) D104 ) ) mod ( Product C230 ) ) by L1077 , L1006;
L1079: ( D103 mod ( Product C230 ) ) = ( ( Sum ( ( ( mod (C228 , C230) ) + ( mod (C229 , C230) ) ) (#) D104 ) ) mod ( Product C230 ) ) by L1078 , NAT_D:65;
L1080: D103 , ( Sum ( ( ( mod (C228 , C230) ) + ( mod (C229 , C230) ) ) (#) D104 ) ) are_congruent_mod ( Product C230 ) by L1079 , NAT_D:64;
assume L1081: C231 in ( dom C230 );
L1082: (ex B191 being Integer st ( B191 * ( C230 . C231 ) ) = ( Product C230 )) by L1081 , L272;
L1083: D103 , ( Sum ( ( ( mod (C228 , C230) ) + ( mod (C229 , C230) ) ) (#) D104 ) ) are_congruent_mod ( C230 . C231 ) by L1082 , L1080 , INT_1:20;
L1084: ( Sum ( ( ( mod (C228 , C230) ) + ( mod (C229 , C230) ) ) (#) D104 ) ) , ( ( ( mod (C228 , C230) ) + ( mod (C229 , C230) ) ) . C231 ) are_congruent_mod ( C230 . C231 ) by L1081 , L1077 , L870;
L1085: D103 , ( ( ( mod (C228 , C230) ) + ( mod (C229 , C230) ) ) . C231 ) are_congruent_mod ( C230 . C231 ) by L1084 , L1083 , INT_1:15;
L1086: ( ( ( mod (C228 , C230) ) + ( mod (C229 , C230) ) ) . C231 ) , ( C228 + C229 ) are_congruent_mod ( C230 . C231 ) by L1081 , L1029;
thus L1087: thesis by L1086 , L1085 , INT_1:15;
end;
theorem
L1088: (for B192 , B193 being Integer holds (for B194 being CR_Sequence holds (for B195 being Nat holds (B195 in ( dom B194 ) implies ( to_int (( ( mod (B192 , B194) ) - ( mod (B193 , B194) ) ) , B194) ) , ( B192 - B193 ) are_congruent_mod ( B194 . B195 )))))
proof
let C232 , C233 being Integer;
let C234 being CR_Sequence;
let C235 being Nat;
set D105 = ( to_int (( ( mod (C232 , C234) ) - ( mod (C233 , C234) ) ) , C234) );
set D106 = the (CR_coefficients of C234);
L1089: ( len ( mod (C232 , C234) ) ) = ( len C234 ) by L796;
L1090: ( len ( mod (C233 , C234) ) ) = ( len C234 ) by L796;
L1091: ( len ( ( mod (C232 , C234) ) - ( mod (C233 , C234) ) ) ) = ( len C234 ) by L1090 , L1089 , L108;
L1092: D105 = ( ( Sum ( ( ( mod (C232 , C234) ) - ( mod (C233 , C234) ) ) (#) D106 ) ) mod ( Product C234 ) ) by L1091 , L1006;
L1093: ( D105 mod ( Product C234 ) ) = ( ( Sum ( ( ( mod (C232 , C234) ) - ( mod (C233 , C234) ) ) (#) D106 ) ) mod ( Product C234 ) ) by L1092 , NAT_D:65;
L1094: D105 , ( Sum ( ( ( mod (C232 , C234) ) - ( mod (C233 , C234) ) ) (#) D106 ) ) are_congruent_mod ( Product C234 ) by L1093 , NAT_D:64;
assume L1095: C235 in ( dom C234 );
L1096: (ex B196 being Integer st ( B196 * ( C234 . C235 ) ) = ( Product C234 )) by L1095 , L272;
L1097: D105 , ( Sum ( ( ( mod (C232 , C234) ) - ( mod (C233 , C234) ) ) (#) D106 ) ) are_congruent_mod ( C234 . C235 ) by L1096 , L1094 , INT_1:20;
L1098: ( Sum ( ( ( mod (C232 , C234) ) - ( mod (C233 , C234) ) ) (#) D106 ) ) , ( ( ( mod (C232 , C234) ) - ( mod (C233 , C234) ) ) . C235 ) are_congruent_mod ( C234 . C235 ) by L1095 , L1091 , L870;
L1099: D105 , ( ( ( mod (C232 , C234) ) - ( mod (C233 , C234) ) ) . C235 ) are_congruent_mod ( C234 . C235 ) by L1098 , L1097 , INT_1:15;
L1100: ( ( ( mod (C232 , C234) ) - ( mod (C233 , C234) ) ) . C235 ) , ( C232 - C233 ) are_congruent_mod ( C234 . C235 ) by L1095 , L1044;
thus L1101: thesis by L1100 , L1099 , INT_1:15;
end;
theorem
L1102: (for B197 , B198 being Integer holds (for B199 being CR_Sequence holds (for B200 being Nat holds (B200 in ( dom B199 ) implies ( to_int (( ( mod (B197 , B199) ) (#) ( mod (B198 , B199) ) ) , B199) ) , ( B197 * B198 ) are_congruent_mod ( B199 . B200 )))))
proof
let C236 , C237 being Integer;
let C238 being CR_Sequence;
let C239 being Nat;
set D107 = ( to_int (( ( mod (C236 , C238) ) (#) ( mod (C237 , C238) ) ) , C238) );
set D108 = the (CR_coefficients of C238);
L1103: ( len ( mod (C236 , C238) ) ) = ( len C238 ) by L796;
L1104: ( len ( mod (C237 , C238) ) ) = ( len C238 ) by L796;
L1105: ( len ( ( mod (C236 , C238) ) (#) ( mod (C237 , C238) ) ) ) = ( len C238 ) by L1104 , L1103 , L111;
L1106: D107 = ( ( Sum ( ( ( mod (C236 , C238) ) (#) ( mod (C237 , C238) ) ) (#) D108 ) ) mod ( Product C238 ) ) by L1105 , L1006;
L1107: ( D107 mod ( Product C238 ) ) = ( ( Sum ( ( ( mod (C236 , C238) ) (#) ( mod (C237 , C238) ) ) (#) D108 ) ) mod ( Product C238 ) ) by L1106 , NAT_D:65;
L1108: D107 , ( Sum ( ( ( mod (C236 , C238) ) (#) ( mod (C237 , C238) ) ) (#) D108 ) ) are_congruent_mod ( Product C238 ) by L1107 , NAT_D:64;
assume L1109: C239 in ( dom C238 );
L1110: (ex B201 being Integer st ( B201 * ( C238 . C239 ) ) = ( Product C238 )) by L1109 , L272;
L1111: D107 , ( Sum ( ( ( mod (C236 , C238) ) (#) ( mod (C237 , C238) ) ) (#) D108 ) ) are_congruent_mod ( C238 . C239 ) by L1110 , L1108 , INT_1:20;
L1112: ( Sum ( ( ( mod (C236 , C238) ) (#) ( mod (C237 , C238) ) ) (#) D108 ) ) , ( ( ( mod (C236 , C238) ) (#) ( mod (C237 , C238) ) ) . C239 ) are_congruent_mod ( C238 . C239 ) by L1109 , L1105 , L870;
L1113: D107 , ( ( ( mod (C236 , C238) ) (#) ( mod (C237 , C238) ) ) . C239 ) are_congruent_mod ( C238 . C239 ) by L1112 , L1111 , INT_1:15;
L1114: ( ( ( mod (C236 , C238) ) (#) ( mod (C237 , C238) ) ) . C239 ) , ( C236 * C237 ) are_congruent_mod ( C238 . C239 ) by L1109 , L1059;
thus L1115: thesis by L1114 , L1113 , INT_1:15;
end;
theorem
L1116: (for B202 , B203 being Integer holds (for B204 being CR_Sequence holds ((( 0 ) <= ( B202 + B203 ) & ( B202 + B203 ) < ( Product B204 )) implies ( to_int (( ( mod (B202 , B204) ) + ( mod (B203 , B204) ) ) , B204) ) = ( B202 + B203 ))))
proof
let C240 , C241 being Integer;
let C242 being CR_Sequence;
assume that
L1117: ( 0 ) <= ( C240 + C241 )
and
L1118: ( C240 + C241 ) < ( Product C242 );
set D109 = ( to_int (( ( mod (C240 , C242) ) + ( mod (C241 , C242) ) ) , C242) );
L1119: (for B205 being Nat holds (B205 in ( dom C242 ) implies ( C240 + C241 ) , ( ( mod (( C240 + C241 ) , C242) ) . B205 ) are_congruent_mod ( C242 . B205 ))) by L1019;
L1120: ( len ( mod (( C240 + C241 ) , C242) ) ) = ( len C242 ) by L796;
L1121: (for B206 being Nat holds (B206 in ( dom C242 ) implies D109 , ( ( mod (( C240 + C241 ) , C242) ) . B206 ) are_congruent_mod ( C242 . B206 )))
proof
let C243 being Nat;
assume L1122: C243 in ( dom C242 );
L1123: D109 , ( C240 + C241 ) are_congruent_mod ( C242 . C243 ) by L1122 , L1074;
L1124: ( D109 mod ( C242 . C243 ) ) = ( ( C240 + C241 ) mod ( C242 . C243 ) ) by L1123 , NAT_D:64;
L1125: ( dom ( mod (( C240 + C241 ) , C242) ) ) = ( Seg ( len C242 ) ) by L1120 , FINSEQ_1:def 3
.= ( dom C242 ) by FINSEQ_1:def 3;
L1126: ( ( mod (( C240 + C241 ) , C242) ) . C243 ) = ( ( C240 + C241 ) mod ( C242 . C243 ) ) by L1125 , L1122 , L796;
L1127: ( C242 . C243 ) in ( rng C242 ) by L1122 , FUNCT_1:3;
L1128: ( C242 . C243 ) > ( 0 ) by L1127 , PARTFUN3:def 1;
L1129: ( C242 . C243 ) is (Element of ( NAT )) by L1128 , INT_1:3;
L1130: ( ( C240 + C241 ) mod ( C242 . C243 ) ) = ( ( ( C240 + C241 ) mod ( C242 . C243 ) ) mod ( C242 . C243 ) ) by L1129 , NAT_D:65;
thus L1131: thesis by L1130 , L1126 , L1124 , L1128 , NAT_D:64;
end;
L1132: ( len ( mod (C240 , C242) ) ) = ( len C242 ) by L796;
L1133: ( len ( mod (C241 , C242) ) ) = ( len C242 ) by L796;
L1134: ( len ( ( mod (C240 , C242) ) + ( mod (C241 , C242) ) ) ) = ( len C242 ) by L1133 , L1132 , L105;
L1135: D109 < ( Product C242 ) by L1134 , L1015;
L1136: ( 0 ) <= D109 by L1134 , L1015;
thus L1137: thesis by L1136 , L1117 , L1118 , L1119 , L1135 , L1121 , L742;
end;
theorem
L1138: (for B207 , B208 being Integer holds (for B209 being CR_Sequence holds ((( 0 ) <= ( B207 - B208 ) & ( B207 - B208 ) < ( Product B209 )) implies ( to_int (( ( mod (B207 , B209) ) - ( mod (B208 , B209) ) ) , B209) ) = ( B207 - B208 ))))
proof
let C244 , C245 being Integer;
let C246 being CR_Sequence;
assume that
L1139: ( 0 ) <= ( C244 - C245 )
and
L1140: ( C244 - C245 ) < ( Product C246 );
set D110 = ( to_int (( ( mod (C244 , C246) ) - ( mod (C245 , C246) ) ) , C246) );
L1141: (for B210 being Nat holds (B210 in ( dom C246 ) implies ( C244 - C245 ) , ( ( mod (( C244 - C245 ) , C246) ) . B210 ) are_congruent_mod ( C246 . B210 ))) by L1019;
L1142: ( len ( mod (( C244 - C245 ) , C246) ) ) = ( len C246 ) by L796;
L1143: (for B211 being Nat holds (B211 in ( dom C246 ) implies D110 , ( ( mod (( C244 - C245 ) , C246) ) . B211 ) are_congruent_mod ( C246 . B211 )))
proof
let C247 being Nat;
assume L1144: C247 in ( dom C246 );
L1145: D110 , ( C244 - C245 ) are_congruent_mod ( C246 . C247 ) by L1144 , L1088;
L1146: ( D110 mod ( C246 . C247 ) ) = ( ( C244 - C245 ) mod ( C246 . C247 ) ) by L1145 , NAT_D:64;
L1147: ( dom ( mod (( C244 - C245 ) , C246) ) ) = ( Seg ( len C246 ) ) by L1142 , FINSEQ_1:def 3
.= ( dom C246 ) by FINSEQ_1:def 3;
L1148: ( ( mod (( C244 - C245 ) , C246) ) . C247 ) = ( ( C244 - C245 ) mod ( C246 . C247 ) ) by L1147 , L1144 , L796;
L1149: ( C246 . C247 ) in ( rng C246 ) by L1144 , FUNCT_1:3;
L1150: ( C246 . C247 ) > ( 0 ) by L1149 , PARTFUN3:def 1;
L1151: ( C246 . C247 ) is (Element of ( NAT )) by L1150 , INT_1:3;
L1152: ( ( C244 - C245 ) mod ( C246 . C247 ) ) = ( ( ( C244 - C245 ) mod ( C246 . C247 ) ) mod ( C246 . C247 ) ) by L1151 , NAT_D:65;
thus L1153: thesis by L1152 , L1148 , L1146 , L1150 , NAT_D:64;
end;
L1154: ( len ( mod (C244 , C246) ) ) = ( len C246 ) by L796;
L1155: ( len ( mod (C245 , C246) ) ) = ( len C246 ) by L796;
L1156: ( len ( ( mod (C244 , C246) ) - ( mod (C245 , C246) ) ) ) = ( len C246 ) by L1155 , L1154 , L108;
L1157: D110 < ( Product C246 ) by L1156 , L1015;
L1158: ( 0 ) <= D110 by L1156 , L1015;
thus L1159: thesis by L1158 , L1139 , L1140 , L1141 , L1157 , L1143 , L742;
end;
theorem
L1160: (for B212 , B213 being Integer holds (for B214 being CR_Sequence holds ((( 0 ) <= ( B212 * B213 ) & ( B212 * B213 ) < ( Product B214 )) implies ( to_int (( ( mod (B212 , B214) ) (#) ( mod (B213 , B214) ) ) , B214) ) = ( B212 * B213 ))))
proof
let C248 , C249 being Integer;
let C250 being CR_Sequence;
assume that
L1161: ( 0 ) <= ( C248 * C249 )
and
L1162: ( C248 * C249 ) < ( Product C250 );
set D111 = ( to_int (( ( mod (C248 , C250) ) (#) ( mod (C249 , C250) ) ) , C250) );
L1163: (for B215 being Nat holds (B215 in ( dom C250 ) implies ( C248 * C249 ) , ( ( mod (( C248 * C249 ) , C250) ) . B215 ) are_congruent_mod ( C250 . B215 ))) by L1019;
L1164: ( len ( mod (( C248 * C249 ) , C250) ) ) = ( len C250 ) by L796;
L1165: (for B216 being Nat holds (B216 in ( dom C250 ) implies D111 , ( ( mod (( C248 * C249 ) , C250) ) . B216 ) are_congruent_mod ( C250 . B216 )))
proof
let C251 being Nat;
assume L1166: C251 in ( dom C250 );
L1167: D111 , ( C248 * C249 ) are_congruent_mod ( C250 . C251 ) by L1166 , L1102;
L1168: ( D111 mod ( C250 . C251 ) ) = ( ( C248 * C249 ) mod ( C250 . C251 ) ) by L1167 , NAT_D:64;
L1169: ( dom ( mod (( C248 * C249 ) , C250) ) ) = ( Seg ( len C250 ) ) by L1164 , FINSEQ_1:def 3
.= ( dom C250 ) by FINSEQ_1:def 3;
L1170: ( ( mod (( C248 * C249 ) , C250) ) . C251 ) = ( ( C248 * C249 ) mod ( C250 . C251 ) ) by L1169 , L1166 , L796;
L1171: ( C250 . C251 ) in ( rng C250 ) by L1166 , FUNCT_1:3;
L1172: ( C250 . C251 ) > ( 0 ) by L1171 , PARTFUN3:def 1;
L1173: ( C250 . C251 ) is (Element of ( NAT )) by L1172 , INT_1:3;
L1174: ( ( C248 * C249 ) mod ( C250 . C251 ) ) = ( ( ( C248 * C249 ) mod ( C250 . C251 ) ) mod ( C250 . C251 ) ) by L1173 , NAT_D:65;
thus L1175: thesis by L1174 , L1170 , L1168 , L1172 , NAT_D:64;
end;
L1176: ( len ( mod (C248 , C250) ) ) = ( len C250 ) by L796;
L1177: ( len ( mod (C249 , C250) ) ) = ( len C250 ) by L796;
L1178: ( len ( ( mod (C248 , C250) ) (#) ( mod (C249 , C250) ) ) ) = ( len C250 ) by L1177 , L1176 , L111;
L1179: D111 < ( Product C250 ) by L1178 , L1015;
L1180: ( 0 ) <= D111 by L1178 , L1015;
thus L1181: thesis by L1180 , L1161 , L1162 , L1163 , L1179 , L1165 , L742;
end;
begin
theorem
L1182: (for B217 being ( INT ) -valued FinSequence holds (for B218 being CR_Sequence holds (( len B217 ) = ( len B218 ) implies (ex B219 being Integer st (( 0 ) <= B219 & B219 < ( Product B218 ) & (for B220 being Nat holds (B220 in ( dom B217 ) implies B219 , ( B217 . B220 ) are_congruent_mod ( B218 . B220 ))))))))
proof
let C252 being ( INT ) -valued FinSequence;
let C253 being CR_Sequence;
assume L1183: ( len C252 ) = ( len C253 );
take D112 = ( to_int (C252 , C253) );
L1184:
now
set D113 = the (CR_coefficients of C253);
let C254 being Nat;
assume L1185: C254 in ( dom C252 );
set D114 = ( ( Sum ( C252 (#) D113 ) ) mod ( Product C253 ) );
L1186: ( D114 mod ( Product C253 ) ) = ( ( Sum ( C252 (#) D113 ) ) mod ( Product C253 ) ) by NAT_D:65;
L1187: D114 , ( Sum ( C252 (#) D113 ) ) are_congruent_mod ( Product C253 ) by L1186 , NAT_D:64;
L1188: ( dom C253 ) = ( Seg ( len C252 ) ) by L1183 , FINSEQ_1:def 3
.= ( dom C252 ) by FINSEQ_1:def 3;
L1189: (ex B221 being Integer st ( B221 * ( C253 . C254 ) ) = ( Product C253 )) by L1188 , L1185 , L272;
L1190: D114 , ( Sum ( C252 (#) D113 ) ) are_congruent_mod ( C253 . C254 ) by L1189 , L1187 , INT_1:20;
L1191: ( D114 mod ( C253 . C254 ) ) = ( ( Sum ( C252 (#) D113 ) ) mod ( C253 . C254 ) ) by L1190 , NAT_D:64;
L1192: ( dom C253 ) = ( Seg ( len C252 ) ) by L1183 , FINSEQ_1:def 3
.= ( dom C252 ) by FINSEQ_1:def 3;
L1193: ( C253 . C254 ) in ( rng C253 ) by L1192 , L1185 , FUNCT_1:3;
L1194: ( C253 . C254 ) > ( 0 ) by L1193 , PARTFUN3:def 1;
L1195: ( Sum ( C252 (#) D113 ) ) , ( C252 . C254 ) are_congruent_mod ( C253 . C254 ) by L1183 , L1185 , L1188 , L870;
L1196: ( ( Sum ( C252 (#) D113 ) ) mod ( C253 . C254 ) ) = ( ( C252 . C254 ) mod ( C253 . C254 ) ) by L1195 , NAT_D:64;
L1197: D114 , ( C252 . C254 ) are_congruent_mod ( C253 . C254 ) by L1196 , L1194 , L1191 , NAT_D:64;
thus L1198: D112 , ( C252 . C254 ) are_congruent_mod ( C253 . C254 ) by L1197 , L1183 , L1006;
end;
thus L1199: thesis by L1184 , L1183 , L1015;
end;
theorem
L1200: (for B222 being ( INT ) -valued FinSequence holds (for B223 being CR_Sequence holds (for B224 , B225 being Integer holds ((( 0 ) <= B224 & B224 < ( Product B223 ) & (for B226 being Nat holds (B226 in ( dom B223 ) implies B224 , ( B222 . B226 ) are_congruent_mod ( B223 . B226 ))) & ( 0 ) <= B225 & B225 < ( Product B223 ) & (for B227 being Nat holds (B227 in ( dom B223 ) implies B225 , ( B222 . B227 ) are_congruent_mod ( B223 . B227 )))) implies B224 = B225)))) by L742;
