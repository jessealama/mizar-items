:: Vectors in Real Linear Space
::  by Wojciech A. Trybulec
::
:: Received July 24, 1989
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, ALGSTR_0, STRUCT_0, SUBSET_1, BINOP_1, FUNCT_1,
      ZFMISC_1, XBOOLE_0, XREAL_0, ORDINAL1, RELAT_1, REAL_1, ARYTM_3,
      SUPINF_2, FUNCT_5, MCART_1, ARYTM_1, CARD_1, FINSEQ_1, ORDINAL4, CARD_3,
      TARSKI, XXREAL_0, FUNCOP_1, NAT_1, VALUED_0, RLVECT_1, PARTFUN1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, CARD_1, NUMBERS,
      XCMPLX_0, XXREAL_0, XREAL_0, RELAT_1, FUNCT_1, FUNCT_2, BINOP_1,
      FUNCOP_1, REAL_1, FINSEQ_1, NAT_1, FUNCT_3, FUNCT_5, FINSEQ_4, STRUCT_0,
      ALGSTR_0;
 constructors BINOP_1, FUNCOP_1, XXREAL_0, REAL_1, NAT_1, FINSEQ_1, FUNCT_3,
      FUNCT_5, ALGSTR_0, REALSET1, RELSET_1, FINSEQ_4, VALUED_0;
 registrations XBOOLE_0, ORDINAL1, RELSET_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      STRUCT_0, REAL_1, ALGSTR_0, FINSEQ_1, CARD_1, ZFMISC_1, FUNCT_1, RELAT_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCT_1, TARSKI, STRUCT_0, RELAT_1, ALGSTR_0;
 theorems FUNCT_1, NAT_1, TARSKI, RELAT_1, STRUCT_0, XBOOLE_0, XBOOLE_1,
      FINSEQ_1, XCMPLX_0, FUNCOP_1, XREAL_1, XXREAL_0, ORDINAL1, ALGSTR_0,
      CARD_1, FINSEQ_3, XREAL_0;
 schemes FINSEQ_1, FUNCT_2, NAT_1;

begin
definition
struct (addLoopStr) RLSStruct(# carrier -> set , ZeroF -> (Element of the carrier) , addF -> (BinOp of the carrier) , Mult -> (Function of [: ( REAL ) , the carrier :] , the carrier) #);
end;
registration
cluster non  empty for RLSStruct;
existence
proof
set D1 = the non  empty set;
set D2 = the (Element of D1);
set D3 = the (BinOp of D1);
set D4 = the (Function of [: ( REAL ) , D1 :] , D1);
take RLSStruct (# D1 , D2 , D3 , D4 #);
thus L2: (the carrier of RLSStruct (# D1 , D2 , D3 , D4 #)) is non  empty;
end;
end;
definition
let C1 being RLSStruct;
mode VECTOR of C1
 is (Element of C1);
end;
theorem
L5: (for B1 being non  empty 1-sorted holds (for B2 being (Element of B1) holds B2 in B1)) by STRUCT_0:def 5;
definition
let R1 being non  empty RLSStruct;
let R5 being (VECTOR of R1);
let C2 being  real number;
func C2 * R5 -> (Element of R1) equals 
( (the Mult of R1) . (C2 , R5) );
coherence
proof
reconsider D5 = C2 as Real by XREAL_0:def 1;
L6: ( (the Mult of R1) . (D5 , R5) ) is (Element of R1);
thus L7: thesis by L6;
end;
end;
theorem
L9: (for B3 being non  empty addMagma holds (for B4 , B5 being (Element of B3) holds ( B4 + B5 ) = ( (the addF of B3) . (B4 , B5) )));
registration
let C3 being non  empty set;
let C4 being (Element of C3);
let C5 being (BinOp of C3);
let C6 being (Function of [: ( REAL ) , C3 :] , C3);
cluster RLSStruct (# C3 , C4 , C5 , C6 #) -> non  empty;
coherence;
end;
definition
let C7 being addMagma;
attr C7 is  Abelian
means
:L11: (for B6 , B7 being (Element of C7) holds ( B6 + B7 ) = ( B7 + B6 ));
attr C7 is  add-associative
means
:L12: (for B8 , B9 , B10 being (Element of C7) holds ( ( B8 + B9 ) + B10 ) = ( B8 + ( B9 + B10 ) ));
end;
definition
let C8 being addLoopStr;
attr C8 is  right_zeroed
means
:L14: (for B11 being (Element of C8) holds ( B11 + ( 0. C8 ) ) = B11);
end;
definition
let C9 being non  empty RLSStruct;
attr C9 is  vector-distributive
means
:L16: (for R6 being  real number holds (for B12 , B13 being (VECTOR of C9) holds ( R6 * ( B12 + B13 ) ) = ( ( R6 * B12 ) + ( R6 * B13 ) )));
attr C9 is  scalar-distributive
means
:L17: (for R6 being  real number holds (for R7 being  real number holds (for B14 being (VECTOR of C9) holds ( ( R6 + R7 ) * B14 ) = ( ( R6 * B14 ) + ( R7 * B14 ) ))));
attr C9 is  scalar-associative
means
:L18: (for R6 being  real number holds (for R7 being  real number holds (for B15 being (VECTOR of C9) holds ( ( R6 * R7 ) * B15 ) = ( R6 * ( R7 * B15 ) ))));
attr C9 is  scalar-unital
means
:L19: (for B16 being (VECTOR of C9) holds ( 1 * B16 ) = B16);
end;
definition
func Trivial-RLSStruct ->  strict RLSStruct equals 
RLSStruct (# 1 , ( op0 ) , ( op2 ) , ( pr2 (( REAL ) , 1) ) #);
coherence;
end;
registration
cluster ( Trivial-RLSStruct ) -> 1 -element;
coherence
proof
L22: (the carrier of ( Trivial-RLSStruct )) = { ( {} ) } by CARD_1:49;
thus L23: (the carrier of ( Trivial-RLSStruct )) is 1 -element by L22;
end;
end;
registration
cluster  strict  Abelian  add-associative non  empty for addMagma;
existence
proof
take D6 = ( Trivial-addMagma );
thus L25: D6 is  strict;
thus L26: D6 is  Abelian
proof
let C10 being (Element of D6);
thus L27: thesis by STRUCT_0:def 10;
end;

thus L28: D6 is  add-associative
proof
let C11 being (Element of D6);
thus L29: thesis by STRUCT_0:def 10;
end;

thus L30: thesis;
end;
end;
registration
cluster  strict  Abelian  add-associative  right_zeroed  right_complementable non  empty for addLoopStr;
existence
proof
take D7 = ( Trivial-addLoopStr );
thus L32: D7 is  strict;
thus L33: D7 is  Abelian
proof
let C12 being (Element of D7);
thus L34: thesis by STRUCT_0:def 10;
end;

thus L35: D7 is  add-associative
proof
let C13 being (Element of D7);
thus L36: thesis by STRUCT_0:def 10;
end;

thus L37: D7 is  right_zeroed
proof
let C14 being (Element of D7);
thus L38: thesis by STRUCT_0:def 10;
end;

thus L39: thesis;
end;
end;
registration
cluster  strict  Abelian  add-associative  right_zeroed  right_complementable  scalar-distributive  vector-distributive  scalar-associative  scalar-unital for non  empty non  empty non  empty non  empty RLSStruct;
existence
proof
take D8 = ( Trivial-RLSStruct );
thus L41: D8 is  strict;
thus L42: D8 is  Abelian
proof
let C15 being (Element of D8);
thus L43: thesis by STRUCT_0:def 10;
end;

thus L44: D8 is  add-associative
proof
let C16 being (Element of D8);
thus L45: thesis by STRUCT_0:def 10;
end;

thus L46: D8 is  right_zeroed
proof
let C17 being (Element of D8);
thus L47: thesis by STRUCT_0:def 10;
end;

thus L48: D8 is  right_complementable
proof
let C18 being (Element of D8);
take C18;
thus L49: thesis by STRUCT_0:def 10;
end;

thus L50: (for R6 being  real number holds (for R7 being  real number holds (for B17 being (VECTOR of D8) holds ( ( R6 + R7 ) * B17 ) = ( ( R6 * B17 ) + ( R7 * B17 ) )))) by STRUCT_0:def 10;
thus L51: (for R6 being  real number holds (for B18 , B19 being (VECTOR of D8) holds ( R6 * ( B18 + B19 ) ) = ( ( R6 * B18 ) + ( R6 * B19 ) ))) by STRUCT_0:def 10;
thus L52: (for R6 being  real number holds (for R7 being  real number holds (for B20 being (VECTOR of D8) holds ( ( R6 * R7 ) * B20 ) = ( R6 * ( R7 * B20 ) )))) by STRUCT_0:def 10;
thus L53: (for B21 being (VECTOR of D8) holds ( 1 * B21 ) = B21) by STRUCT_0:def 10;
end;
end;
definition
mode RealLinearSpace
 is  Abelian  add-associative  right_zeroed  right_complementable  scalar-distributive  vector-distributive  scalar-associative  scalar-unital non  empty RLSStruct;
end;
definition
let C19 being  Abelian addMagma;
let C20 , C21 being (Element of C19);
redefine func C20 + C21;

commutativity
 by L11;
end;
L57: (for B22 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B23 , B24 being (Element of B22) holds (( B23 + B24 ) = ( 0. B22 ) implies ( B24 + B23 ) = ( 0. B22 ))))
proof
let C22 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C23 , C24 being (Element of C22);
assume L58: ( C23 + C24 ) = ( 0. C22 );
consider C25 being (Element of C22) such that L59: ( C24 + C25 ) = ( 0. C22 ) by ALGSTR_0:def 11;
L60: ( C24 + C23 ) = ( C24 + ( C23 + ( C24 + C25 ) ) ) by L59 , L14
.= ( C24 + ( ( C23 + C24 ) + C25 ) ) by L12
.= ( ( C24 + ( C23 + C24 ) ) + C25 ) by L12
.= ( C24 + C25 ) by L58 , L14;
thus L61: thesis by L60 , L59;
end;
theorem
L62: (for B25 being  add-associative  right_zeroed  right_complementable addLoopStr holds B25 is  right_add-cancelable)
proof
let C26 being  add-associative  right_zeroed  right_complementable addLoopStr;
let C27 being (Element of C26);
consider C28 being (Element of C26) such that L63: ( C27 + C28 ) = ( 0. C26 ) by ALGSTR_0:def 11;
let C29 , C30 being (Element of C26);
assume L64: ( C29 + C27 ) = ( C30 + C27 );
thus L65: C29 = ( C29 + ( 0. C26 ) ) by L14
.= ( ( C29 + C27 ) + C28 ) by L63 , L12
.= ( C30 + ( 0. C26 ) ) by L63 , L64 , L12
.= C30 by L14;
end;
theorem
L66: (for B26 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B27 being (Element of B26) holds (( B27 + ( 0. B26 ) ) = B27 & ( ( 0. B26 ) + B27 ) = B27)))
proof
let C31 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C32 being (Element of C31);
consider C33 being (Element of C31) such that L67: ( C32 + C33 ) = ( 0. C31 ) by ALGSTR_0:def 11;
thus L68: ( C32 + ( 0. C31 ) ) = C32 by L14;
L69: ( C33 + C32 ) = ( 0. C31 ) by L67 , L57;
thus L70: thesis by L69 , L68 , L67 , L12;
end;
definition
let C34 being non  empty addLoopStr;
let C35 being (Element of C34);
assume L71: C34 is  add-associative  right_zeroed  right_complementable;
redefine func - C35 means 
:L72: ( C35 + it ) = ( 0. C34 );
compatibility
proof
let C36 being (Element of C34);
consider C37 being (Element of C34) such that L73: ( C35 + C37 ) = ( 0. C34 ) by L71 , ALGSTR_0:def 11;
L74: C34 is  right_add-cancelable by L71 , L62;
L75: C35 is  left_complementable
proof
take C37;
L76: ( ( C37 + C35 ) + C37 ) = ( C37 + ( 0. C34 ) ) by L71 , L73 , L12
.= C37 by L71 , L66
.= ( ( 0. C34 ) + C37 ) by L71 , L66;
thus L77: thesis by L76 , L74 , ALGSTR_0:def 4;
end;
L78: ( ( C35 + ( - C35 ) ) + C35 ) = ( C35 + ( ( - C35 ) + C35 ) ) by L71 , L12
.= ( C35 + ( 0. C34 ) ) by L74 , L75 , ALGSTR_0:def 13
.= C35 by L71 , L66
.= ( ( 0. C34 ) + C35 ) by L71 , L66;
thus L79: (C36 = ( - C35 ) implies ( C35 + C36 ) = ( 0. C34 )) by L78 , L74 , ALGSTR_0:def 4;
assume L80: ( C35 + C36 ) = ( 0. C34 );
thus L81: C36 = ( ( 0. C34 ) + C36 ) by L71 , L66
.= ( ( ( - C35 ) + C35 ) + C36 ) by L74 , L75 , ALGSTR_0:def 13
.= ( ( - C35 ) + ( 0. C34 ) ) by L71 , L80 , L12
.= ( - C35 ) by L71 , L66;
end;
end;
L83: (for B28 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B29 , B30 being (Element of B28) holds (ex B31 being (Element of B28) st ( B29 + B31 ) = B30)))
proof
let C38 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C39 , C40 being (Element of C38);
take D9 = ( ( - C39 ) + C40 );
thus L84: ( C39 + D9 ) = ( ( C39 + ( - C39 ) ) + C40 ) by L12
.= ( ( 0. C38 ) + C40 ) by L72
.= C40 by L66;
end;
definition
let C41 being addLoopStr;
let C42 , C43 being (Element of C41);
redefine func C42 - C43 equals 
( C42 + ( - C43 ) );
correctness;
end;
theorem
L86: (for B32 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B33 being (Element of B32) holds (( B33 + ( - B33 ) ) = ( 0. B32 ) & ( ( - B33 ) + B33 ) = ( 0. B32 ))))
proof
let C44 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C45 being (Element of C44);
thus L87: ( C45 + ( - C45 ) ) = ( 0. C44 ) by L72;
thus L88: thesis by L87 , L57;
end;
theorem
L89: (for B34 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B35 , B36 being (Element of B34) holds (( B35 + B36 ) = ( 0. B34 ) implies B35 = ( - B36 ))))
proof
let C46 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C47 , C48 being (Element of C46);
assume L90: ( C47 + C48 ) = ( 0. C46 );
L91: ( C48 + C47 ) = ( 0. C46 ) by L90 , L57;
thus L92: thesis by L91 , L72;
end;
theorem
L93: (for B37 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B38 , B39 being (Element of B37) holds (ex B40 being (Element of B37) st ( B38 + B40 ) = B39))) by L83;
theorem
L94: (for B41 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B42 , B43 , B44 , B45 being (Element of B41) holds ((( B42 + B44 ) = ( B42 + B45 ) or ( B44 + B42 ) = ( B45 + B42 )) implies B44 = B45)))
proof
let C49 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C50 , C51 , C52 , C53 being (Element of C49);
L95:
now
assume L96: ( C52 + C50 ) = ( C53 + C50 );
thus L97: C52 = ( C52 + ( 0. C49 ) ) by L66
.= ( C52 + ( C50 + ( - C50 ) ) ) by L86
.= ( ( C52 + C50 ) + ( - C50 ) ) by L12
.= ( C53 + ( C50 + ( - C50 ) ) ) by L96 , L12
.= ( C53 + ( 0. C49 ) ) by L86
.= C53 by L66;
end;
L98:
now
assume L99: ( C50 + C52 ) = ( C50 + C53 );
thus L100: C52 = ( ( 0. C49 ) + C52 ) by L66
.= ( ( ( - C50 ) + C50 ) + C52 ) by L86
.= ( ( - C50 ) + ( C50 + C52 ) ) by L12
.= ( ( ( - C50 ) + C50 ) + C53 ) by L99 , L12
.= ( ( 0. C49 ) + C53 ) by L86
.= C53 by L66;
end;
thus L101: thesis by L98 , L95;
end;
theorem
L102: (for B46 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B47 , B48 being (Element of B46) holds ((( B47 + B48 ) = B47 or ( B48 + B47 ) = B47) implies B48 = ( 0. B46 ))))
proof
let C54 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C55 , C56 being (Element of C54);
assume L103: (( C55 + C56 ) = C55 or ( C56 + C55 ) = C55);
L104: (( C55 + C56 ) = ( C55 + ( 0. C54 ) ) or ( C56 + C55 ) = ( ( 0. C54 ) + C55 )) by L103 , L66;
thus L105: thesis by L104 , L94;
end;
theorem
L106: (for R6 being  real number holds (for R8 being RealLinearSpace holds (for R9 being (VECTOR of R8) holds ((R6 = ( 0 ) or R9 = ( 0. R8 )) implies ( R6 * R9 ) = ( 0. R8 )))))
proof
let R6 being  real number;
let R8 being RealLinearSpace;
let R9 being (VECTOR of R8);
assume L107: (R6 = ( 0 ) or R9 = ( 0. R8 ));
L108:
now
per cases  by L107;
suppose L109: R6 = ( 0 );

L110: ( R9 + ( ( 0 ) * R9 ) ) = ( ( 1 * R9 ) + ( ( 0 ) * R9 ) ) by L19
.= ( ( 1 + ( 0 ) ) * R9 ) by L17
.= R9 by L19
.= ( R9 + ( 0. R8 ) ) by L66;
thus L111: thesis by L110 , L109 , L94;
end;
suppose L112: R9 = ( 0. R8 );

L113: ( ( R6 * ( 0. R8 ) ) + ( R6 * ( 0. R8 ) ) ) = ( R6 * ( ( 0. R8 ) + ( 0. R8 ) ) ) by L16
.= ( R6 * ( 0. R8 ) ) by L66
.= ( ( R6 * ( 0. R8 ) ) + ( 0. R8 ) ) by L66;
thus L114: thesis by L113 , L112 , L94;
end;
end;
thus L116: thesis by L108;
end;
theorem
L117: (for R6 being  real number holds (for R8 being RealLinearSpace holds (for R9 being (VECTOR of R8) holds (( R6 * R9 ) = ( 0. R8 ) implies (R6 = ( 0 ) or R9 = ( 0. R8 ))))))
proof
let R6 being  real number;
let R8 being RealLinearSpace;
let R9 being (VECTOR of R8);
assume that
L118: ( R6 * R9 ) = ( 0. R8 )
and
L119: R6 <> ( 0 );
thus L120: R9 = ( 1 * R9 ) by L19
.= ( ( ( R6 " ) * R6 ) * R9 ) by L119 , XCMPLX_0:def 7
.= ( ( R6 " ) * ( 0. R8 ) ) by L118 , L18
.= ( 0. R8 ) by L106;
end;
theorem
L121: (for B49 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds ( - ( 0. B49 ) ) = ( 0. B49 ))
proof
let C57 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
thus L122: ( 0. C57 ) = ( ( 0. C57 ) + ( - ( 0. C57 ) ) ) by L72
.= ( - ( 0. C57 ) ) by L66;
end;
theorem
L123: (for B50 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B51 being (Element of B50) holds ( B51 - ( 0. B50 ) ) = B51))
proof
let C58 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C59 being (Element of C58);
thus L124: ( C59 - ( 0. C58 ) ) = ( C59 + ( 0. C58 ) ) by L121
.= C59 by L66;
end;
theorem
L125: (for B52 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B53 being (Element of B52) holds ( ( 0. B52 ) - B53 ) = ( - B53 ))) by L66;
theorem
L126: (for B54 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B55 being (Element of B54) holds ( B55 - B55 ) = ( 0. B54 ))) by L72;
theorem
L127: (for R8 being RealLinearSpace holds (for R9 being (VECTOR of R8) holds ( - R9 ) = ( ( - 1 ) * R9 )))
proof
let R8 being RealLinearSpace;
let R9 being (VECTOR of R8);
L128: ( R9 + ( ( - 1 ) * R9 ) ) = ( ( 1 * R9 ) + ( ( - 1 ) * R9 ) ) by L19
.= ( ( 1 + ( - 1 ) ) * R9 ) by L17
.= ( 0. R8 ) by L106;
thus L129: ( - R9 ) = ( ( - R9 ) + ( R9 + ( ( - 1 ) * R9 ) ) ) by L128 , L66
.= ( ( ( - R9 ) + R9 ) + ( ( - 1 ) * R9 ) ) by L12
.= ( ( 0. R8 ) + ( ( - 1 ) * R9 ) ) by L72
.= ( ( - 1 ) * R9 ) by L66;
end;
theorem
L130: (for B56 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B57 being (Element of B56) holds ( - ( - B57 ) ) = B57))
proof
let C60 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C61 being (Element of C60);
L131: ( C61 + ( - C61 ) ) = ( 0. C60 ) by L72;
thus L132: thesis by L131 , L89;
end;
theorem
L133: (for B58 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B59 , B60 being (Element of B58) holds (( - B59 ) = ( - B60 ) implies B59 = B60)))
proof
let C62 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C63 , C64 being (Element of C62);
assume L134: ( - C63 ) = ( - C64 );
thus L135: C63 = ( - ( - C64 ) ) by L134 , L130
.= C64 by L130;
end;
theorem
L136: (for R8 being RealLinearSpace holds (for R9 being (VECTOR of R8) holds (R9 = ( - R9 ) implies R9 = ( 0. R8 ))))
proof
let R8 being RealLinearSpace;
let R9 being (VECTOR of R8);
assume L137: R9 = ( - R9 );
L138: ( 0. R8 ) = ( R9 + R9 ) by L137 , L72
.= ( ( 1 * R9 ) + R9 ) by L19
.= ( ( 1 * R9 ) + ( 1 * R9 ) ) by L19
.= ( ( 1 + 1 ) * R9 ) by L17
.= ( 2 * R9 );
thus L139: thesis by L138 , L117;
end;
theorem
L140: (for R8 being RealLinearSpace holds (for R9 being (VECTOR of R8) holds (( R9 + R9 ) = ( 0. R8 ) implies R9 = ( 0. R8 ))))
proof
let R8 being RealLinearSpace;
let R9 being (VECTOR of R8);
assume L141: ( R9 + R9 ) = ( 0. R8 );
L142: R9 = ( - R9 ) by L141 , L72;
thus L143: thesis by L142 , L136;
end;
theorem
L144: (for B61 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B62 , B63 being (Element of B61) holds (( B62 - B63 ) = ( 0. B61 ) implies B62 = B63)))
proof
let C65 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C66 , C67 being (Element of C65);
assume L145: ( C66 - C67 ) = ( 0. C65 );
L146: ( - C66 ) = ( - C67 ) by L145 , L72;
thus L147: thesis by L146 , L133;
end;
theorem
L148: (for B64 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B65 , B66 being (Element of B64) holds (ex B67 being (Element of B64) st ( B66 - B67 ) = B65)))
proof
let C68 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C69 , C70 being (Element of C68);
consider C71 being (Element of C68) such that L149: ( C70 + C71 ) = C69 by L83;
take ( - C71 );
thus L150: thesis by L149 , L130;
end;
theorem
L151: (for B68 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B69 , B70 , B71 being (Element of B68) holds (( B69 - B70 ) = ( B69 - B71 ) implies B70 = B71)))
proof
let C72 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C73 , C74 , C75 being (Element of C72);
assume L152: ( C73 - C74 ) = ( C73 - C75 );
L153: ( - C74 ) = ( - C75 ) by L152 , L94;
thus L154: thesis by L153 , L133;
end;
theorem
L155: (for R6 being  real number holds (for R8 being RealLinearSpace holds (for R9 being (VECTOR of R8) holds ( R6 * ( - R9 ) ) = ( ( - R6 ) * R9 ))))
proof
let R6 being  real number;
let R8 being RealLinearSpace;
let R9 being (VECTOR of R8);
thus L156: ( R6 * ( - R9 ) ) = ( R6 * ( ( - 1 ) * R9 ) ) by L127
.= ( ( R6 * ( - 1 ) ) * R9 ) by L18
.= ( ( - R6 ) * R9 );
end;
theorem
L157: (for R6 being  real number holds (for R8 being RealLinearSpace holds (for R9 being (VECTOR of R8) holds ( R6 * ( - R9 ) ) = ( - ( R6 * R9 ) ))))
proof
let R6 being  real number;
let R8 being RealLinearSpace;
let R9 being (VECTOR of R8);
thus L158: ( R6 * ( - R9 ) ) = ( ( - ( 1 * R6 ) ) * R9 ) by L155
.= ( ( ( - 1 ) * R6 ) * R9 )
.= ( ( - 1 ) * ( R6 * R9 ) ) by L18
.= ( - ( R6 * R9 ) ) by L127;
end;
theorem
L159: (for R6 being  real number holds (for R8 being RealLinearSpace holds (for R9 being (VECTOR of R8) holds ( ( - R6 ) * ( - R9 ) ) = ( R6 * R9 ))))
proof
let R6 being  real number;
let R8 being RealLinearSpace;
let R9 being (VECTOR of R8);
thus L160: ( ( - R6 ) * ( - R9 ) ) = ( ( - ( - R6 ) ) * R9 ) by L155
.= ( R6 * R9 );
end;
L161: (for B72 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B73 , B74 being (Element of B72) holds ( - ( B73 + B74 ) ) = ( ( - B74 ) + ( - B73 ) )))
proof
let C76 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C77 , C78 being (Element of C76);
L162: ( ( C77 + C78 ) + ( ( - C78 ) + ( - C77 ) ) ) = ( C77 + ( C78 + ( ( - C78 ) + ( - C77 ) ) ) ) by L12
.= ( C77 + ( ( C78 + ( - C78 ) ) + ( - C77 ) ) ) by L12
.= ( C77 + ( ( 0. C76 ) + ( - C77 ) ) ) by L72
.= ( C77 + ( - C77 ) ) by L66
.= ( 0. C76 ) by L72;
thus L163: thesis by L162 , L72;
end;
theorem
L164: (for B75 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B76 , B77 , B78 being (Element of B75) holds ( B76 - ( B77 + B78 ) ) = ( ( B76 - B78 ) - B77 )))
proof
let C79 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C80 , C81 , C82 being (Element of C79);
thus L165: ( C80 - ( C81 + C82 ) ) = ( C80 + ( ( - C82 ) + ( - C81 ) ) ) by L161
.= ( ( C80 - C82 ) - C81 ) by L12;
end;
theorem
L166: (for B79 being  add-associative non  empty addLoopStr holds (for B80 , B81 , B82 being (Element of B79) holds ( ( B80 + B81 ) - B82 ) = ( B80 + ( B81 - B82 ) ))) by L12;
theorem
L167: (for B83 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B84 , B85 , B86 being (Element of B83) holds ( B84 - ( B85 - B86 ) ) = ( ( B84 - B85 ) + B86 )))
proof
let C83 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C84 , C85 , C86 being (Element of C83);
thus L168: ( C84 - ( C85 - C86 ) ) = ( C84 - ( C85 + ( - C86 ) ) )
.= ( ( C84 - C85 ) - ( - C86 ) ) by L164
.= ( ( C84 - C85 ) + C86 ) by L130;
end;
theorem
L169: (for B87 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B88 , B89 being (Element of B87) holds ( - ( B88 + B89 ) ) = ( ( - B89 ) - B88 )))
proof
let C87 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C88 , C89 being (Element of C87);
thus L170: ( - ( C88 + C89 ) ) = ( ( 0. C87 ) - ( C88 + C89 ) ) by L66
.= ( ( ( 0. C87 ) - C89 ) - C88 ) by L164
.= ( ( - C89 ) - C88 ) by L66;
end;
theorem
L171: (for B90 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B91 , B92 being (Element of B90) holds ( - ( B91 + B92 ) ) = ( ( - B92 ) + ( - B91 ) ))) by L161;
theorem
L172: (for B93 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B94 , B95 being (Element of B93) holds ( ( - B94 ) - B95 ) = ( ( - B95 ) - B94 )))
proof
let C90 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C91 , C92 being (Element of C90);
thus L173: ( ( - C91 ) - C92 ) = ( - ( C92 + C91 ) ) by L169
.= ( ( - C92 ) - C91 ) by L169;
end;
theorem
L174: (for B96 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B97 , B98 being (Element of B96) holds ( - ( B97 - B98 ) ) = ( B98 + ( - B97 ) )))
proof
let C93 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C94 , C95 being (Element of C93);
thus L175: ( - ( C94 - C95 ) ) = ( ( - ( - C95 ) ) + ( - C94 ) ) by L161
.= ( C95 + ( - C94 ) ) by L130;
end;
theorem
L176: (for R6 being  real number holds (for R8 being RealLinearSpace holds (for R9 being (VECTOR of R8) holds (for R10 being (VECTOR of R8) holds ( R6 * ( R9 - R10 ) ) = ( ( R6 * R9 ) - ( R6 * R10 ) )))))
proof
let R6 being  real number;
let R8 being RealLinearSpace;
let R9 being (VECTOR of R8);
let R10 being (VECTOR of R8);
thus L177: ( R6 * ( R9 - R10 ) ) = ( ( R6 * R9 ) + ( R6 * ( - R10 ) ) ) by L16
.= ( ( R6 * R9 ) - ( R6 * R10 ) ) by L157;
end;
theorem
L178: (for R6 being  real number holds (for R7 being  real number holds (for R8 being RealLinearSpace holds (for R9 being (VECTOR of R8) holds ( ( R6 - R7 ) * R9 ) = ( ( R6 * R9 ) - ( R7 * R9 ) )))))
proof
let R6 being  real number;
let R7 being  real number;
let R8 being RealLinearSpace;
let R9 being (VECTOR of R8);
thus L179: ( ( R6 - R7 ) * R9 ) = ( ( R6 + ( - R7 ) ) * R9 )
.= ( ( R6 * R9 ) + ( ( - R7 ) * R9 ) ) by L17
.= ( ( R6 * R9 ) + ( R7 * ( - R9 ) ) ) by L155
.= ( ( R6 * R9 ) - ( R7 * R9 ) ) by L157;
end;
theorem
L180: (for R6 being  real number holds (for R8 being RealLinearSpace holds (for R9 being (VECTOR of R8) holds (for R10 being (VECTOR of R8) holds ((R6 <> ( 0 ) & ( R6 * R9 ) = ( R6 * R10 )) implies R9 = R10)))))
proof
let R6 being  real number;
let R8 being RealLinearSpace;
let R9 being (VECTOR of R8);
let R10 being (VECTOR of R8);
assume that
L181: R6 <> ( 0 )
and
L182: ( R6 * R9 ) = ( R6 * R10 );
L183: ( 0. R8 ) = ( ( R6 * R9 ) - ( R6 * R10 ) ) by L182 , L72
.= ( R6 * ( R9 - R10 ) ) by L176;
L184: ( R9 - R10 ) = ( 0. R8 ) by L183 , L181 , L117;
thus L185: thesis by L184 , L144;
end;
theorem
L186: (for R6 being  real number holds (for R7 being  real number holds (for R8 being RealLinearSpace holds (for R9 being (VECTOR of R8) holds ((R9 <> ( 0. R8 ) & ( R6 * R9 ) = ( R7 * R9 )) implies R6 = R7)))))
proof
let R6 being  real number;
let R7 being  real number;
let R8 being RealLinearSpace;
let R9 being (VECTOR of R8);
assume that
L187: R9 <> ( 0. R8 )
and
L188: ( R6 * R9 ) = ( R7 * R9 );
L189: ( 0. R8 ) = ( ( R6 * R9 ) - ( R7 * R9 ) ) by L188 , L72
.= ( ( R6 - R7 ) * R9 ) by L178;
L190: ( ( - R7 ) + R6 ) = ( 0 ) by L189 , L187 , L117;
thus L191: thesis by L190;
end;
definition
let R11 being non  empty addLoopStr;
let C96 being (the carrier of R11) -valued FinSequence;
func Sum C96 -> (Element of R11) means 
:L192: (ex R13 being (Function of ( NAT ) , R11) st (it = ( R13 . ( len C96 ) ) & ( R13 . ( 0 ) ) = ( 0. R11 ) & (for R18 being (Element of ( NAT )) holds (for R16 being (Element of R11) holds ((R18 < ( len C96 ) & R16 = ( C96 . ( R18 + 1 ) )) implies ( R13 . ( R18 + 1 ) ) = ( ( R13 . R18 ) + R16 ))))));
existence
proof
defpred S1[ set ] means (for B99 being (the carrier of R11) -valued FinSequence holds (( len B99 ) = $1 implies (ex R17 being (Element of R11) st (ex R13 being (Function of ( NAT ) , R11) st (R17 = ( R13 . ( len B99 ) ) & ( R13 . ( 0 ) ) = ( 0. R11 ) & (for R18 being (Element of ( NAT )) holds (for R16 being (Element of R11) holds ((R18 < ( len B99 ) & R16 = ( B99 . ( R18 + 1 ) )) implies ( R13 . ( R18 + 1 ) ) = ( ( R13 . R18 ) + R16 )))))))));
L193: (for B100 being (Element of ( NAT )) holds (S1[ B100 ] implies S1[ ( B100 + 1 ) ]))
proof
let R20 being (Element of ( NAT ));
assume L194: (for B101 being (the carrier of R11) -valued FinSequence holds (( len B101 ) = R20 implies (ex R17 being (Element of R11) st (ex R13 being (Function of ( NAT ) , R11) st (R17 = ( R13 . ( len B101 ) ) & ( R13 . ( 0 ) ) = ( 0. R11 ) & (for R18 being (Element of ( NAT )) holds (for R16 being (Element of R11) holds ((R18 < ( len B101 ) & R16 = ( B101 . ( R18 + 1 ) )) implies ( R13 . ( R18 + 1 ) ) = ( ( R13 . R18 ) + R16 )))))))));
let C97 being (the carrier of R11) -valued FinSequence;
L195: ( rng C97 ) c= (the carrier of R11) by RELAT_1:def 19;
reconsider D10 = C97 as (FinSequence of R11) by L195 , FINSEQ_1:def 4;
reconsider D11 = ( D10 | ( Seg R20 ) ) as (FinSequence of R11) by FINSEQ_1:18;
assume L196: ( len C97 ) = ( R20 + 1 );
L197: ( dom C97 ) = ( Seg ( R20 + 1 ) ) by L196 , FINSEQ_1:def 3;
L198: ( R20 + 1 ) in ( dom C97 ) by L197 , FINSEQ_1:4;
L199: ( C97 . ( R20 + 1 ) ) in ( rng C97 ) by L198 , FUNCT_1:def 3;
reconsider D12 = ( C97 . ( R20 + 1 ) ) as (Element of R11) by L199 , L195;
L200: R20 < ( R20 + 1 ) by NAT_1:13;
consider R17 being (Element of R11), R13 being (Function of ( NAT ) , R11) such that L201: R17 = ( R13 . ( len D11 ) ) and L202: ( R13 . ( 0 ) ) = ( 0. R11 ) and L203: (for R18 being (Element of ( NAT )) holds (for R16 being (Element of R11) holds ((R18 < ( len D11 ) & R16 = ( D11 . ( R18 + 1 ) )) implies ( R13 . ( R18 + 1 ) ) = ( ( R13 . R18 ) + R16 )))) by L200 , L194 , L196 , FINSEQ_1:17;
defpred S2[ set , set ] means (for R18 being (Element of ( NAT )) holds ($1 = R18 implies ((R18 < ( R20 + 1 ) implies $2 = ( R13 . $1 )) & (( R20 + 1 ) <= R18 implies (for R17 being (Element of R11) holds (R17 = ( C97 . ( R20 + 1 ) ) implies $2 = ( ( R13 . ( len D11 ) ) + R17 )))))));
L204: (for B102 being (Element of (( NAT ) qua non  empty set)) holds (ex B103 being (Element of R11) st S2[ B102 , B103 ]))
proof
let C98 being (Element of (( NAT ) qua non  empty set));
reconsider D13 = C98 as (Element of ( NAT ));
L205:
now
assume L206: ( R20 + 1 ) <= D13;
take D14 = ( ( R13 . ( len D11 ) ) + D12 );
let R18 being (Element of ( NAT ));
assume L207: C98 = R18;
thus L208: (R18 < ( R20 + 1 ) implies D14 = ( R13 . C98 )) by L207 , L206;
assume L209: ( R20 + 1 ) <= R18;
let C99 being (Element of R11);
assume L210: C99 = ( C97 . ( R20 + 1 ) );
thus L211: D14 = ( ( R13 . ( len D11 ) ) + C99 ) by L210;
end;
L212:
now
assume L213: D13 < ( R20 + 1 );
take D15 = ( R13 . C98 );
let R18 being (Element of ( NAT ));
assume that
L214: C98 = R18;
thus L215: (R18 < ( R20 + 1 ) implies D15 = ( R13 . C98 ));
thus L216: (( R20 + 1 ) <= R18 implies (for R17 being (Element of R11) holds (R17 = ( C97 . ( R20 + 1 ) ) implies D15 = ( ( R13 . ( len D11 ) ) + R17 )))) by L213 , L214;
end;
thus L217: thesis by L212 , L205;
end;
consider C100 being (Function of (( NAT ) qua non  empty set) , (the carrier of R11)) such that L218: (for B104 being (Element of (( NAT ) qua non  empty set)) holds S2[ B104 , ( C100 . B104 ) ]) from FUNCT_2:sch 3(L204);
take D16 = ( C100 . ( R20 + 1 ) );
take D17 = C100;
thus L219: D16 = ( D17 . ( len C97 ) ) by L196;
thus L220: ( D17 . ( 0 ) ) = ( 0. R11 ) by L202 , L218;
let R18 being (Element of ( NAT ));
let R16 being (Element of R11);
assume that
L221: R18 < ( len C97 )
and
L222: R16 = ( C97 . ( R18 + 1 ) );
L223: ( len D11 ) = R20 by L196 , L200 , FINSEQ_1:17;
L224:
now
assume L225: R18 = R20;
L226: ( D17 . ( R18 + 1 ) ) = ( ( R13 . R18 ) + R16 ) by L225 , L223 , L218 , L222;
thus L227: ( D17 . ( R18 + 1 ) ) = ( ( D17 . R18 ) + R16 ) by L226 , L200 , L218 , L225;
end;
L228:
now
assume L229: R18 < R20;
L230: ( R18 + 1 ) < ( R20 + 1 ) by L229 , XREAL_1:6;
L231: (1 <= ( 1 + R18 ) & ( R18 + 1 ) <= R20) by L229 , NAT_1:11 , NAT_1:13;
L232: ( R18 + 1 ) in ( Seg R20 ) by L231 , FINSEQ_1:1;
L233: R16 = ( D11 . ( R18 + 1 ) ) by L232 , L222 , FUNCT_1:49;
L234: R18 < ( len D11 ) by L196 , L200 , L229 , FINSEQ_1:17;
L235: ( R13 . ( R18 + 1 ) ) = ( ( R13 . R18 ) + R16 ) by L234 , L203 , L233;
L236: R18 < ( R20 + 1 ) by L229 , NAT_1:13;
L237: ( R13 . ( R18 + 1 ) ) = ( ( C100 . R18 ) + R16 ) by L236 , L218 , L235;
thus L238: ( D17 . ( R18 + 1 ) ) = ( ( D17 . R18 ) + R16 ) by L237 , L218 , L230;
end;
L239: R18 <= R20 by L196 , L221 , NAT_1:13;
thus L240: ( D17 . ( R18 + 1 ) ) = ( ( D17 . R18 ) + R16 ) by L239 , L228 , L224 , XXREAL_0:1;
end;
L241: S1[ ( 0 ) ]
proof
reconsider D18 = ( ( NAT ) --> ( 0. R11 ) ) as (Function of ( NAT ) , (the carrier of R11));
let C101 being (the carrier of R11) -valued FinSequence;
assume L242: ( len C101 ) = ( 0 );
take D19 = ( D18 . ( len C101 ) );
take D20 = D18;
thus L243: (D19 = ( D20 . ( len C101 ) ) & ( D20 . ( 0 ) ) = ( 0. R11 )) by FUNCOP_1:7;
let R18 being (Element of ( NAT ));
thus L244: (for R16 being (Element of R11) holds ((R18 < ( len C101 ) & R16 = ( C101 . ( R18 + 1 ) )) implies ( D20 . ( R18 + 1 ) ) = ( ( D20 . R18 ) + R16 ))) by L242;
end;
L245: (for R20 being (Element of ( NAT )) holds S1[ R20 ]) from NAT_1:sch 1(L241 , L193);
thus L246: thesis by L245;
end;
uniqueness
proof
let C102 , C103 being (Element of R11);
given R13 being (Function of ( NAT ) , R11) such that
L247: C102 = ( R13 . ( len C96 ) )
and
L248: ( R13 . ( 0 ) ) = ( 0. R11 )
and
L249: (for R18 being (Element of ( NAT )) holds (for R16 being (Element of R11) holds ((R18 < ( len C96 ) & R16 = ( C96 . ( R18 + 1 ) )) implies ( R13 . ( R18 + 1 ) ) = ( ( R13 . R18 ) + R16 ))));

given R14 being (Function of ( NAT ) , R11) such that
L250: C103 = ( R14 . ( len C96 ) )
and
L251: ( R14 . ( 0 ) ) = ( 0. R11 )
and
L252: (for R18 being (Element of ( NAT )) holds (for R16 being (Element of R11) holds ((R18 < ( len C96 ) & R16 = ( C96 . ( R18 + 1 ) )) implies ( R14 . ( R18 + 1 ) ) = ( ( R14 . R18 ) + R16 ))));

defpred S3[ (Element of ( NAT )) ] means ($1 <= ( len C96 ) implies ( R13 . $1 ) = ( R14 . $1 ));
L253:
now
L254: ( rng C96 ) c= (the carrier of R11) by RELAT_1:def 19;
let R19 being (Element of ( NAT ));
assume L255: (R19 <= ( len C96 ) implies ( R13 . R19 ) = ( R14 . R19 ));
assume L256: ( R19 + 1 ) <= ( len C96 );
L257: (1 <= ( R19 + 1 ) & ( dom C96 ) = ( Seg ( len C96 ) )) by FINSEQ_1:def 3 , NAT_1:11;
L258: ( R19 + 1 ) in ( dom C96 ) by L257 , L256 , FINSEQ_1:1;
L259: ( C96 . ( R19 + 1 ) ) in ( rng C96 ) by L258 , FUNCT_1:def 3;
reconsider D21 = ( C96 . ( R19 + 1 ) ) as (Element of R11) by L259 , L254;
L260: R19 < ( len C96 ) by L256 , NAT_1:13;
L261: ( R13 . ( R19 + 1 ) ) = ( ( R13 . R19 ) + D21 ) by L260 , L249;
thus L262: ( R13 . ( R19 + 1 ) ) = ( R14 . ( R19 + 1 ) ) by L261 , L252 , L255 , L260;
end;
L263: (for R19 being (Element of ( NAT )) holds (S3[ R19 ] implies S3[ ( R19 + 1 ) ])) by L253;
L264: S3[ ( 0 ) ] by L248 , L251;
L265: (for R19 being (Element of ( NAT )) holds S3[ R19 ]) from NAT_1:sch 1(L264 , L263);
thus L266: thesis by L265 , L247 , L250;
end;
end;
L268: (for R11 being non  empty addLoopStr holds ( Sum ( <*> (the carrier of R11) ) ) = ( 0. R11 ))
proof
let R11 being non  empty addLoopStr;
set D22 = ( <*> (the carrier of R11) );
L269: (ex R13 being (Function of ( NAT ) , R11) st (( Sum D22 ) = ( R13 . ( len D22 ) ) & ( R13 . ( 0 ) ) = ( 0. R11 ) & (for R18 being (Element of ( NAT )) holds (for R16 being (Element of R11) holds ((R18 < ( len D22 ) & R16 = ( D22 . ( R18 + 1 ) )) implies ( R13 . ( R18 + 1 ) ) = ( ( R13 . R18 ) + R16 )))))) by L192;
thus L270: thesis by L269;
end;
L271: (for R11 being non  empty addLoopStr holds (for R12 being  FinSequence-like (PartFunc of ( NAT ) , R11) holds (( len R12 ) = ( 0 ) implies ( Sum R12 ) = ( 0. R11 ))))
proof
let R11 being non  empty addLoopStr;
let R12 being  FinSequence-like (PartFunc of ( NAT ) , R11);
assume L272: ( len R12 ) = ( 0 );
L273: R12 = ( <*> (the carrier of R11) ) by L272;
thus L274: thesis by L273 , L268;
end;
theorem
L275: (for R11 being non  empty addLoopStr holds (for R16 being (Element of R11) holds (for B105 , B106 being (FinSequence of R11) holds ((( len B105 ) = ( ( len B106 ) + 1 ) & B106 = ( B105 | ( dom B106 ) ) & R16 = ( B105 . ( len B105 ) )) implies ( Sum B105 ) = ( ( Sum B106 ) + R16 )))))
proof
let R11 being non  empty addLoopStr;
let R16 being (Element of R11);
let C104 , C105 being (FinSequence of R11);
assume that
L276: ( len C104 ) = ( ( len C105 ) + 1 )
and
L277: C105 = ( C104 | ( dom C105 ) )
and
L278: R16 = ( C104 . ( len C104 ) );
consider R15 being (Function of ( NAT ) , R11) such that L279: ( Sum C105 ) = ( R15 . ( len C105 ) ) and L280: ( R15 . ( 0 ) ) = ( 0. R11 ) and L281: (for R18 being (Element of ( NAT )) holds (for R16 being (Element of R11) holds ((R18 < ( len C105 ) & R16 = ( C105 . ( R18 + 1 ) )) implies ( R15 . ( R18 + 1 ) ) = ( ( R15 . R18 ) + R16 )))) by L192;
consider R13 being (Function of ( NAT ) , R11) such that L282: ( Sum C104 ) = ( R13 . ( len C104 ) ) and L283: ( R13 . ( 0 ) ) = ( 0. R11 ) and L284: (for R18 being (Element of ( NAT )) holds (for R16 being (Element of R11) holds ((R18 < ( len C104 ) & R16 = ( C104 . ( R18 + 1 ) )) implies ( R13 . ( R18 + 1 ) ) = ( ( R13 . R18 ) + R16 )))) by L192;
defpred S4[ (Element of ( NAT )) ] means (for B107 being (FinSequence of R11) holds ((( len B107 ) = $1 & B107 = ( C104 | ( Seg $1 ) ) & ( len B107 ) <= ( len C105 )) implies ( R13 . ( len B107 ) ) = ( R15 . ( len B107 ) )));
L285:
now
let R19 being (Element of ( NAT ));
assume L286: (for B108 being (FinSequence of R11) holds ((( len B108 ) = R19 & B108 = ( C104 | ( Seg R19 ) ) & ( len B108 ) <= ( len C105 )) implies ( R13 . ( len B108 ) ) = ( R15 . ( len B108 ) )));
let C106 being (FinSequence of R11);
assume that
L287: ( len C106 ) = ( R19 + 1 )
and
L288: C106 = ( C104 | ( Seg ( R19 + 1 ) ) )
and
L289: ( len C106 ) <= ( len C105 );
L290: (1 <= ( R19 + 1 ) & ( R19 + 1 ) <= ( len C104 )) by L276 , L287 , L289 , NAT_1:12;
L291: ( R19 + 1 ) in ( dom C104 ) by L290 , FINSEQ_3:25;
reconsider D23 = ( C104 . ( R19 + 1 ) ) as (Element of R11) by L291 , FUNCT_1:102;
L292: 1 <= ( R19 + 1 ) by NAT_1:12;
L293: ( R19 + 1 ) in ( Seg ( len C105 ) ) by L292 , L287 , L289 , FINSEQ_1:1;
L294: ( R19 + 1 ) in ( dom C105 ) by L293 , FINSEQ_1:def 3;
L295: D23 = ( C105 . ( R19 + 1 ) ) by L294 , L277 , FUNCT_1:47;
reconsider D24 = C106 as (FinSequence of R11);
reconsider D25 = ( D24 | ( Seg R19 ) ) as (FinSequence of R11) by FINSEQ_1:18;
L296: R19 <= ( len C106 ) by L287 , NAT_1:12;
L297: ( Seg R19 ) c= ( Seg ( R19 + 1 ) ) by L296 , L287 , FINSEQ_1:5;
L298: D25 = ( C104 | ( Seg R19 ) ) by L297 , L288 , FUNCT_1:51;
L299: R19 < ( R19 + 1 ) by XREAL_1:29;
L300: R19 < ( len C105 ) by L299 , L287 , L289 , XXREAL_0:2;
L301: ( R15 . ( R19 + 1 ) ) = ( ( R15 . R19 ) + D23 ) by L300 , L281 , L295;
L302: ( len C105 ) < ( len C104 ) by L276 , XREAL_1:29;
L303: R19 <= ( len C105 ) by L289 , L296 , XXREAL_0:2;
L304: R19 < ( len C104 ) by L303 , L302 , XXREAL_0:2;
L305: ( R13 . ( R19 + 1 ) ) = ( ( R13 . R19 ) + D23 ) by L304 , L284;
L306: ( len D25 ) = R19 by L296 , FINSEQ_1:17;
thus L307: ( R13 . ( len C106 ) ) = ( R15 . ( len C106 ) ) by L306 , L286 , L287 , L289 , L296 , L298 , L305 , L301 , XXREAL_0:2;
end;
L308: (for R19 being (Element of ( NAT )) holds (S4[ R19 ] implies S4[ ( R19 + 1 ) ])) by L285;
L309: ( dom C105 ) = ( Seg ( len C105 ) ) by FINSEQ_1:def 3;
L310: S4[ ( 0 ) ] by L283 , L280;
L311: (for R19 being (Element of ( NAT )) holds S4[ R19 ]) from NAT_1:sch 1(L310 , L308);
L312: ( R13 . ( len C105 ) ) = ( R15 . ( len C105 ) ) by L311 , L277 , L309;
thus L313: thesis by L312 , L276 , L278 , L282 , L284 , L279 , XREAL_1:29;
end;
theorem
L314: (for R6 being  real number holds (for R21 being RealLinearSpace holds (for R23 being (FinSequence of R21) holds (for R24 being (FinSequence of R21) holds ((( len R23 ) = ( len R24 ) & (for R19 being (Element of ( NAT )) holds (for R22 being (VECTOR of R21) holds ((R19 in ( dom R23 ) & R22 = ( R24 . R19 )) implies ( R23 . R19 ) = ( R6 * R22 ))))) implies ( Sum R23 ) = ( R6 * ( Sum R24 ) ))))))
proof
let R6 being  real number;
let R21 being RealLinearSpace;
let R23 being (FinSequence of R21);
let R24 being (FinSequence of R21);
defpred S5[ set ] means (for R25 being (FinSequence of R21) holds (for R26 being (FinSequence of R21) holds ((( len R25 ) = ( len R26 ) & ( len R25 ) = $1 & (for R19 being (Element of ( NAT )) holds (for R22 being (VECTOR of R21) holds ((R19 in ( Seg ( len R25 ) ) & R22 = ( R26 . R19 )) implies ( R25 . R19 ) = ( R6 * R22 ))))) implies ( Sum R25 ) = ( R6 * ( Sum R26 ) ))));
L315: ( dom R23 ) = ( Seg ( len R23 ) ) by FINSEQ_1:def 3;
L316:
now
let R20 being (Element of ( NAT ));
assume L317: (for R25 being (FinSequence of R21) holds (for R26 being (FinSequence of R21) holds ((( len R25 ) = ( len R26 ) & ( len R25 ) = R20 & (for R19 being (Element of ( NAT )) holds (for R22 being (VECTOR of R21) holds ((R19 in ( Seg ( len R25 ) ) & R22 = ( R26 . R19 )) implies ( R25 . R19 ) = ( R6 * R22 ))))) implies ( Sum R25 ) = ( R6 * ( Sum R26 ) ))));
let R25 being (FinSequence of R21);
let R26 being (FinSequence of R21);
assume that
L318: ( len R25 ) = ( len R26 )
and
L319: ( len R25 ) = ( R20 + 1 )
and
L320: (for R19 being (Element of ( NAT )) holds (for R22 being (VECTOR of R21) holds ((R19 in ( Seg ( len R25 ) ) & R22 = ( R26 . R19 )) implies ( R25 . R19 ) = ( R6 * R22 ))));
reconsider D26 = ( R25 | ( Seg R20 ) ) , D27 = ( R26 | ( Seg R20 ) ) as (FinSequence of (the carrier of R21)) by FINSEQ_1:18;
L321: R20 <= ( R20 + 1 ) by NAT_1:12;
L322: ( len D27 ) = R20 by L321 , L318 , L319 , FINSEQ_1:17;
L323: ( len D26 ) = R20 by L319 , L321 , FINSEQ_1:17;
L324:
now
L325: ( len D26 ) <= ( len R25 ) by L319 , L321 , FINSEQ_1:17;
L326: ( Seg ( len D26 ) ) c= ( Seg ( len R25 ) ) by L325 , FINSEQ_1:5;
L327: ( dom D26 ) = ( Seg R20 ) by L319 , L321 , FINSEQ_1:17;
let R19 being (Element of ( NAT ));
let R22 being (VECTOR of R21);
assume that
L328: R19 in ( Seg ( len D26 ) )
and
L329: R22 = ( D27 . R19 );
L330: ( dom D27 ) = ( Seg R20 ) by L318 , L319 , L321 , FINSEQ_1:17;
L331: ( R26 . R19 ) = ( D27 . R19 ) by L330 , L323 , L328 , FUNCT_1:47;
L332: ( R25 . R19 ) = ( R6 * R22 ) by L331 , L320 , L328 , L329 , L326;
thus L333: ( D26 . R19 ) = ( R6 * R22 ) by L332 , L323 , L328 , L327 , FUNCT_1:47;
end;
L334: 1 <= ( R20 + 1 ) by NAT_1:11;
L335: (( R20 + 1 ) in ( dom R25 ) & ( R20 + 1 ) in ( dom R26 )) by L334 , L318 , L319 , FINSEQ_3:25;
reconsider D28 = ( R25 . ( R20 + 1 ) ) , D29 = ( R26 . ( R20 + 1 ) ) as (VECTOR of R21) by L335 , FUNCT_1:102;
L336: D28 = ( R6 * D29 ) by L319 , L320 , FINSEQ_1:4;
L337: ( dom D27 ) = ( Seg ( len D27 ) ) by FINSEQ_1:def 3;
L338: ( dom D26 ) = ( Seg ( len D26 ) ) by FINSEQ_1:def 3;
thus L339: ( Sum R25 ) = ( ( Sum D26 ) + D28 ) by L338 , L319 , L323 , L275
.= ( ( R6 * ( Sum D27 ) ) + ( R6 * D29 ) ) by L317 , L323 , L322 , L324 , L336
.= ( R6 * ( ( Sum D27 ) + D29 ) ) by L16
.= ( R6 * ( Sum R26 ) ) by L318 , L319 , L322 , L337 , L275;
end;
L340: (for R20 being (Element of ( NAT )) holds (S5[ R20 ] implies S5[ ( R20 + 1 ) ])) by L316;
L341:
now
let R25 being (FinSequence of R21);
let R26 being (FinSequence of R21);
assume that
L342: ( len R25 ) = ( len R26 )
and
L343: ( len R25 ) = ( 0 )
and
L344: (for R19 being (Element of ( NAT )) holds (for R22 being (VECTOR of R21) holds ((R19 in ( Seg ( len R25 ) ) & R22 = ( R26 . R19 )) implies ( R25 . R19 ) = ( R6 * R22 ))));
L345: ( Sum R25 ) = ( 0. R21 ) by L343 , L271;
thus L346: ( Sum R25 ) = ( R6 * ( Sum R26 ) ) by L345 , L342 , L343 , L271 , L106;
end;
L347: S5[ ( 0 ) ] by L341;
L348: (for R20 being (Element of ( NAT )) holds S5[ R20 ]) from NAT_1:sch 1(L347 , L340);
thus L349: thesis by L348 , L315;
end;
theorem
L350: (for B109 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B110 , B111 being (FinSequence of B109) holds ((( len B110 ) = ( len B111 ) & (for R19 being (Element of ( NAT )) holds (for B112 being (Element of B109) holds ((R19 in ( dom B110 ) & B112 = ( B111 . R19 )) implies ( B110 . R19 ) = ( - B112 ))))) implies ( Sum B110 ) = ( - ( Sum B111 ) ))))
proof
let C107 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C108 , C109 being (FinSequence of C107);
defpred S6[ set ] means (for B113 , B114 being (FinSequence of C107) holds ((( len B113 ) = ( len B114 ) & ( len B113 ) = $1 & (for R19 being (Element of ( NAT )) holds (for B115 being (Element of C107) holds ((R19 in ( Seg ( len B113 ) ) & B115 = ( B114 . R19 )) implies ( B113 . R19 ) = ( - B115 ))))) implies ( Sum B113 ) = ( - ( Sum B114 ) )));
L351: ( dom C108 ) = ( Seg ( len C108 ) ) by FINSEQ_1:def 3;
L352:
now
let R20 being (Element of ( NAT ));
assume L353: (for B116 , B117 being (FinSequence of C107) holds ((( len B116 ) = ( len B117 ) & ( len B116 ) = R20 & (for R19 being (Element of ( NAT )) holds (for B118 being (Element of C107) holds ((R19 in ( Seg ( len B116 ) ) & B118 = ( B117 . R19 )) implies ( B116 . R19 ) = ( - B118 ))))) implies ( Sum B116 ) = ( - ( Sum B117 ) )));
let C110 , C111 being (FinSequence of C107);
assume that
L354: ( len C110 ) = ( len C111 )
and
L355: ( len C110 ) = ( R20 + 1 )
and
L356: (for R19 being (Element of ( NAT )) holds (for B119 being (Element of C107) holds ((R19 in ( Seg ( len C110 ) ) & B119 = ( C111 . R19 )) implies ( C110 . R19 ) = ( - B119 ))));
reconsider D30 = ( C110 | ( Seg R20 ) ) , D31 = ( C111 | ( Seg R20 ) ) as (FinSequence of (the carrier of C107)) by FINSEQ_1:18;
L357: R20 <= ( R20 + 1 ) by NAT_1:12;
L358: ( len D31 ) = R20 by L357 , L354 , L355 , FINSEQ_1:17;
L359: ( len D30 ) = R20 by L355 , L357 , FINSEQ_1:17;
L360:
now
L361: ( len D30 ) <= ( len C110 ) by L355 , L357 , FINSEQ_1:17;
L362: ( Seg ( len D30 ) ) c= ( Seg ( len C110 ) ) by L361 , FINSEQ_1:5;
L363: ( dom D30 ) = ( Seg R20 ) by L355 , L357 , FINSEQ_1:17;
let R19 being (Element of ( NAT ));
let C112 being (Element of C107);
assume that
L364: R19 in ( Seg ( len D30 ) )
and
L365: C112 = ( D31 . R19 );
L366: ( dom D31 ) = ( Seg R20 ) by L354 , L355 , L357 , FINSEQ_1:17;
L367: ( C111 . R19 ) = ( D31 . R19 ) by L366 , L359 , L364 , FUNCT_1:47;
L368: ( C110 . R19 ) = ( - C112 ) by L367 , L356 , L364 , L365 , L362;
thus L369: ( D30 . R19 ) = ( - C112 ) by L368 , L359 , L364 , L363 , FUNCT_1:47;
end;
L370: 1 <= ( R20 + 1 ) by NAT_1:11;
L371: (( R20 + 1 ) in ( dom C110 ) & ( R20 + 1 ) in ( dom C111 )) by L370 , L354 , L355 , FINSEQ_3:25;
reconsider D32 = ( C110 . ( R20 + 1 ) ) , D33 = ( C111 . ( R20 + 1 ) ) as (Element of C107) by L371 , FUNCT_1:102;
L372: D32 = ( - D33 ) by L355 , L356 , FINSEQ_1:4;
L373: ( dom D31 ) = ( Seg ( len D31 ) ) by FINSEQ_1:def 3;
L374: ( dom D30 ) = ( Seg ( len D30 ) ) by FINSEQ_1:def 3;
thus L375: ( Sum C110 ) = ( ( Sum D30 ) + D32 ) by L374 , L355 , L359 , L275
.= ( ( - ( Sum D31 ) ) + ( - D33 ) ) by L353 , L359 , L358 , L360 , L372
.= ( - ( ( Sum D31 ) + D33 ) ) by L161
.= ( - ( Sum C111 ) ) by L354 , L355 , L358 , L373 , L275;
end;
L376: (for R20 being (Element of ( NAT )) holds (S6[ R20 ] implies S6[ ( R20 + 1 ) ])) by L352;
L377:
now
let C113 , C114 being (FinSequence of C107);
assume that
L378: (( len C113 ) = ( len C114 ) & ( len C113 ) = ( 0 ))
and
L379: (for R19 being (Element of ( NAT )) holds (for B120 being (Element of C107) holds ((R19 in ( Seg ( len C113 ) ) & B120 = ( C114 . R19 )) implies ( C113 . R19 ) = ( - B120 ))));
L380: (( Sum C113 ) = ( 0. C107 ) & ( Sum C114 ) = ( 0. C107 )) by L378 , L271;
thus L381: ( Sum C113 ) = ( - ( Sum C114 ) ) by L380 , L121;
end;
L382: S6[ ( 0 ) ] by L377;
L383: (for R20 being (Element of ( NAT )) holds S6[ R20 ]) from NAT_1:sch 1(L382 , L376);
thus L384: thesis by L383 , L351;
end;
theorem
L385: (for B121 being  add-associative  right_zeroed non  empty addLoopStr holds (for B122 , B123 being (FinSequence of B121) holds ( Sum ( B122 ^ B123 ) ) = ( ( Sum B122 ) + ( Sum B123 ) )))
proof
let C115 being  add-associative  right_zeroed non  empty addLoopStr;
let C116 , C117 being (FinSequence of C115);
defpred S7[ set ] means (for B124 being (FinSequence of C115) holds (( len B124 ) = $1 implies ( Sum ( C116 ^ B124 ) ) = ( ( Sum C116 ) + ( Sum B124 ) )));
L386: (for R19 being (Element of ( NAT )) holds (S7[ R19 ] implies S7[ ( R19 + 1 ) ]))
proof
let R19 being (Element of ( NAT ));
assume L387: (for B125 being (FinSequence of C115) holds (( len B125 ) = R19 implies ( Sum ( C116 ^ B125 ) ) = ( ( Sum C116 ) + ( Sum B125 ) )));
let C118 being (FinSequence of C115);
reconsider D34 = ( C118 | ( Seg R19 ) ) as (FinSequence of C115) by FINSEQ_1:18;
L388: ( rng C118 ) c= (the carrier of C115) by FINSEQ_1:def 4;
assume L389: ( len C118 ) = ( R19 + 1 );
L390: ( dom C118 ) = ( Seg ( R19 + 1 ) ) by L389 , FINSEQ_1:def 3;
L391: ( R19 + 1 ) in ( dom C118 ) by L390 , FINSEQ_1:4;
L392: ( C118 . ( R19 + 1 ) ) in ( rng C118 ) by L391 , FUNCT_1:def 3;
reconsider D35 = ( C118 . ( R19 + 1 ) ) as (Element of C115) by L392 , L388;
L393: R19 <= ( R19 + 1 ) by NAT_1:12;
L394:
now
let C119 being Nat;
assume L395: C119 in ( dom D34 );
L396: C119 in ( Seg R19 ) by L395 , L389 , L393 , FINSEQ_1:17;
thus L397: ( D34 . C119 ) = ( C118 . C119 ) by L396 , FUNCT_1:49;
end;
L398: ( dom D34 ) = ( Seg ( len D34 ) ) by FINSEQ_1:def 3;
L399: ( Seg ( len ( C116 ^ D34 ) ) ) = ( Seg ( ( len C116 ) + ( len D34 ) ) ) by FINSEQ_1:22;
L400: ( dom ( C116 ^ C118 ) ) = ( Seg ( len ( C116 ^ C118 ) ) ) by FINSEQ_1:def 3
.= ( Seg ( ( len C116 ) + ( len C118 ) ) ) by FINSEQ_1:22;
L401: ( dom ( C116 ^ D34 ) ) = ( Seg ( len ( C116 ^ D34 ) ) ) by FINSEQ_1:def 3;
L402: ( dom D34 ) = ( Seg R19 ) by L389 , L393 , FINSEQ_1:17;
L403: ( dom D34 ) c= ( dom C118 ) by L402 , L390 , L393 , FINSEQ_1:5;
L404:
now
let C120 being set;
assume L405: C120 in ( dom ( C116 ^ D34 ) );
reconsider D36 = C120 as (Element of ( NAT )) by L405;
L406:
now
assume L407: (not D36 in ( dom C116 ));
L408: (not D36 in ( Seg ( len C116 ) )) by L407 , FINSEQ_1:def 3;
L409: 1 <= D36 by L401 , L405 , FINSEQ_1:1;
L410: ( len C116 ) <= D36 by L409 , L408 , FINSEQ_1:1;
consider C121 being Nat such that L411: D36 = ( ( len C116 ) + C121 ) by L410 , NAT_1:10;
L412:
now
assume L413: (not C121 <= R19);
L414: ( ( len C116 ) + R19 ) < D36 by L413 , L411 , XREAL_1:6;
L415: D36 <= ( ( len C116 ) + ( len D34 ) ) by L401 , L399 , L405 , FINSEQ_1:1;
thus L416: contradiction by L415 , L389 , L393 , L414 , FINSEQ_1:17;
end;
L417:
now
assume L418: (not 1 <= C121);
L419: C121 = ( 0 ) by L418 , NAT_1:14;
thus L420: contradiction by L419 , L408 , L409 , L411 , FINSEQ_1:1;
end;
L421: C121 in ( Seg R19 ) by L417 , L412 , FINSEQ_1:1;
L422: C121 in ( dom D34 ) by L421 , L389 , L393 , FINSEQ_1:17;
L423: (( ( C116 ^ D34 ) . D36 ) = ( D34 . C121 ) & ( ( C116 ^ C118 ) . D36 ) = ( C118 . C121 )) by L422 , L403 , L411 , FINSEQ_1:def 7;
thus L424: ( ( C116 ^ D34 ) . C120 ) = ( ( C116 ^ C118 ) . C120 ) by L423 , L394 , L422;
end;
L425:
now
assume L426: D36 in ( dom C116 );
L427: ( ( C116 ^ D34 ) . D36 ) = ( C116 . D36 ) by L426 , FINSEQ_1:def 7;
thus L428: ( ( C116 ^ D34 ) . C120 ) = ( ( C116 ^ C118 ) . C120 ) by L427 , L426 , FINSEQ_1:def 7;
end;
thus L429: ( ( C116 ^ D34 ) . C120 ) = ( ( C116 ^ C118 ) . C120 ) by L425 , L406;
end;
L430: ( len D34 ) = R19 by L389 , L393 , FINSEQ_1:17;
L431: ( ( len C116 ) + ( len D34 ) ) <= ( ( len C116 ) + ( len C118 ) ) by L430 , L389 , L393 , XREAL_1:7;
L432: ( Seg ( len ( C116 ^ D34 ) ) ) c= ( dom ( C116 ^ C118 ) ) by L431 , L400 , L399 , FINSEQ_1:5;
L433: ( dom ( C116 ^ D34 ) ) = ( ( dom ( C116 ^ C118 ) ) /\ ( Seg ( len ( C116 ^ D34 ) ) ) ) by L432 , L401 , XBOOLE_1:28;
L434: ( C116 ^ D34 ) = ( ( C116 ^ C118 ) | ( Seg ( len ( C116 ^ D34 ) ) ) ) by L433 , L404 , FUNCT_1:46
.= ( ( C116 ^ C118 ) | ( dom ( C116 ^ D34 ) ) ) by FINSEQ_1:def 3;
L435:
now
let C122 being Nat;
assume L436: C122 in ( dom <* D35 *> );
L437: C122 in { 1 } by L436 , FINSEQ_1:2 , FINSEQ_1:38;
L438: C122 = 1 by L437 , TARSKI:def 1;
thus L439: ( C118 . ( ( len D34 ) + C122 ) ) = ( <* D35 *> . C122 ) by L438 , L430 , FINSEQ_1:def 8;
end;
L440: ( dom C118 ) = ( Seg ( ( len D34 ) + ( len <* D35 *> ) ) ) by L390 , L430 , FINSEQ_1:39;
L441: C118 = ( D34 ^ <* D35 *> ) by L440 , L394 , L435 , FINSEQ_1:def 7;
L442: ( C116 ^ C118 ) = ( ( C116 ^ D34 ) ^ <* D35 *> ) by L441 , FINSEQ_1:32;
L443: ( len ( C116 ^ C118 ) ) = ( ( len ( C116 ^ D34 ) ) + ( len <* D35 *> ) ) by L442 , FINSEQ_1:22;
L444: ( len ( C116 ^ C118 ) ) = ( ( len ( C116 ^ D34 ) ) + 1 ) by L443 , FINSEQ_1:39;
L445: D35 = ( ( C116 ^ C118 ) . ( ( len C116 ) + ( len C118 ) ) ) by L389 , L391 , FINSEQ_1:def 7
.= ( ( C116 ^ C118 ) . ( len ( C116 ^ C118 ) ) ) by FINSEQ_1:22;
thus L446: ( Sum ( C116 ^ C118 ) ) = ( ( Sum ( C116 ^ D34 ) ) + D35 ) by L445 , L444 , L434 , L275
.= ( ( ( Sum C116 ) + ( Sum D34 ) ) + D35 ) by L387 , L430
.= ( ( Sum C116 ) + ( ( Sum D34 ) + D35 ) ) by L12
.= ( ( Sum C116 ) + ( Sum C118 ) ) by L389 , L430 , L398 , L275;
end;
L447: S7[ ( 0 ) ]
proof
let C123 being (FinSequence of C115);
assume L448: ( len C123 ) = ( 0 );
L449: C123 = ( <*> (the carrier of C115) ) by L448;
L450: (( C116 ^ C123 ) = C116 & ( Sum C123 ) = ( 0. C115 )) by L449 , L268 , FINSEQ_1:34;
thus L451: thesis by L450 , L14;
end;
L452: (for R19 being (Element of ( NAT )) holds S7[ R19 ]) from NAT_1:sch 1(L447 , L386);
L453: (( len C117 ) = ( len C117 ) implies thesis) by L452;
thus L454: thesis by L453;
end;
L455: (for B126 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B127 being (Element of B126) holds ( Sum <* B127 *> ) = B127))
proof
let C124 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C125 being (Element of C124);
set D37 = <* C125 *>;
consider C126 being (Function of ( NAT ) , (the carrier of C124)) such that L456: ( Sum D37 ) = ( C126 . ( len D37 ) ) and L457: (( C126 . ( 0 ) ) = ( 0. C124 ) & (for R34 being (Element of ( NAT )) holds (for B128 being (Element of C124) holds ((R34 < ( len D37 ) & B128 = ( D37 . ( R34 + 1 ) )) implies ( C126 . ( R34 + 1 ) ) = ( ( C126 . R34 ) + B128 ))))) by L192;
L458: ( 0 ) < 1;
consider R34 being (Element of ( NAT )) such that L459: R34 < ( len D37 ) by L458;
L460: ( len D37 ) = 1 by FINSEQ_1:39;
L461: ( D37 . ( R34 + 1 ) ) = ( D37 . ( ( 0 ) + 1 ) ) by L460 , L459 , NAT_1:14
.= C125 by FINSEQ_1:40;
L462: R34 = ( 0 ) by L460 , L459 , NAT_1:14;
L463: ( C126 . 1 ) = ( ( 0. C124 ) + C125 ) by L462 , L457 , L461
.= C125 by L66;
thus L464: thesis by L463 , L456 , FINSEQ_1:39;
end;
theorem
L465: (for B129 being  Abelian  add-associative  right_zeroed non  empty addLoopStr holds (for B130 , B131 being (FinSequence of B129) holds ((( rng B130 ) = ( rng B131 ) & B130 is  one-to-one & B131 is  one-to-one) implies ( Sum B130 ) = ( Sum B131 ))))
proof
let C127 being  Abelian  add-associative  right_zeroed non  empty addLoopStr;
let C128 , C129 being (FinSequence of C127);
defpred S8[ set ] means (for B132 , B133 being (FinSequence of C127) holds ((( len B132 ) = $1 & ( rng B132 ) = ( rng B133 ) & B132 is  one-to-one & B133 is  one-to-one) implies ( Sum B132 ) = ( Sum B133 )));
L466: ( len C128 ) = ( len C128 );
L467:
now
let R35 being (Element of ( NAT ));
assume L468: (for B134 , B135 being (FinSequence of C127) holds ((( len B134 ) = R35 & ( rng B134 ) = ( rng B135 ) & B134 is  one-to-one & B135 is  one-to-one) implies ( Sum B134 ) = ( Sum B135 )));
let C130 , C131 being (FinSequence of C127);
assume that
L469: ( len C130 ) = ( R35 + 1 )
and
L470: ( rng C130 ) = ( rng C131 )
and
L471: C130 is  one-to-one
and
L472: C131 is  one-to-one;
L473: ( R35 + 1 ) in ( Seg ( R35 + 1 ) ) by FINSEQ_1:4;
L474: ( R35 + 1 ) in ( dom C130 ) by L473 , L469 , FINSEQ_1:def 3;
L475: ( C130 . ( R35 + 1 ) ) in ( rng C131 ) by L474 , L470 , FUNCT_1:def 3;
consider R2 being set such that L476: R2 in ( dom C131 ) and L477: ( C130 . ( R35 + 1 ) ) = ( C131 . R2 ) by L475 , FUNCT_1:def 3;
reconsider D38 = ( C130 . ( R35 + 1 ) ) as (Element of C127) by L474 , FUNCT_1:102;
reconsider D39 = R2 as (Element of ( NAT )) by L476;
L478: ( len C130 ) = ( len C131 ) by L470 , L471 , L472 , FINSEQ_1:48;
L479: R2 in ( Seg ( R35 + 1 ) ) by L478 , L469 , L476 , FINSEQ_1:def 3;
L480: D39 <= ( R35 + 1 ) by L479 , FINSEQ_1:1;
consider C132 being Nat such that L481: ( D39 + C132 ) = ( R35 + 1 ) by L480 , NAT_1:10;
defpred S9[ Nat , set ] means $2 = ( C131 . ( D39 + $1 ) );
reconsider D40 = C132 as (Element of ( NAT )) by ORDINAL1:def 12;
L482: (for B136 being Nat holds (B136 in ( Seg D40 ) implies (ex R2 being set st S9[ B136 , R2 ])));
consider C133 being FinSequence such that L483: ( dom C133 ) = ( Seg D40 ) and L484: (for B137 being Nat holds (B137 in ( Seg D40 ) implies S9[ B137 , ( C133 . B137 ) ])) from FINSEQ_1:sch 1(L482);
L485: ( rng C133 ) c= (the carrier of C127)
proof
let R2 being set;
assume L486: R2 in ( rng C133 );
consider R3 being set such that L487: R3 in ( dom C133 ) and L488: R2 = ( C133 . R3 ) by L486 , FUNCT_1:def 3;
reconsider D41 = R3 as (Element of ( NAT )) by L487;
L489: 1 <= D41 by L483 , L487 , FINSEQ_1:1;
L490: 1 <= ( D39 + D41 ) by L489 , NAT_1:12;
L491: D41 <= D40 by L483 , L487 , FINSEQ_1:1;
L492: ( D39 + D41 ) <= ( len C131 ) by L491 , L469 , L478 , L481 , XREAL_1:7;
L493: ( D39 + D41 ) in ( dom C131 ) by L492 , L490 , FINSEQ_3:25;
reconsider D42 = ( C131 . ( D39 + D41 ) ) as (Element of C127) by L493 , FUNCT_1:102;
L494: D42 in (the carrier of C127);
thus L495: thesis by L494 , L483 , L484 , L487 , L488;
end;
reconsider D43 = ( C130 | ( Seg R35 ) ) as (FinSequence of C127) by FINSEQ_1:18;
L496: D43 is  one-to-one by L471 , FUNCT_1:52;
L497: ( Seg R35 ) = ( ( Seg ( R35 + 1 ) ) \ { ( R35 + 1 ) } ) by FINSEQ_1:10;
L498: ( C130 .: ( Seg R35 ) ) = ( ( C130 .: ( Seg ( R35 + 1 ) ) ) \ ( Im (C130 , ( R35 + 1 )) ) ) by L497 , L471 , FUNCT_1:64;
L499: 1 <= D39 by L479 , FINSEQ_1:1;
consider C134 being Nat such that L500: ( 1 + C134 ) = D39 by L499 , NAT_1:10;
reconsider D44 = ( C131 | ( Seg C134 ) ) as (FinSequence of C127) by FINSEQ_1:18;
reconsider D45 = C133 as (FinSequence of C127) by L485 , FINSEQ_1:def 4;
L501: C134 <= D39 by L500 , NAT_1:11;
L502: C134 <= ( R35 + 1 ) by L501 , L480 , XXREAL_0:2;
L503: ( len D44 ) = C134 by L502 , L469 , L478 , FINSEQ_1:17;
L504:
now
let C135 being Nat;
assume L505: C135 in ( dom D45 );
L506: ( len ( D44 ^ <* D38 *> ) ) = ( C134 + ( len <* D38 *> ) ) by L503 , FINSEQ_1:22
.= D39 by L500 , FINSEQ_1:39;
thus L507: ( C131 . ( ( len ( D44 ^ <* D38 *> ) ) + C135 ) ) = ( D45 . C135 ) by L506 , L483 , L484 , L505;
end;
set D46 = ( D44 ^ D45 );
L508: C134 < D39 by L500 , XREAL_1:29;
L509: { D38 } misses ( rng D46 )
proof
set D47 = the (Element of ( { D38 } /\ ( rng D46 ) ));
assume L510: (not thesis);
L511: ( { D38 } /\ ( rng D46 ) ) <> ( {} ) by L510 , XBOOLE_0:def 7;
L512: D47 in { D38 } by L511 , XBOOLE_0:def 4;
L513:
now
assume L514: D47 in ( rng D44 );
consider R4 being set such that L515: R4 in ( dom D44 ) and L516: D47 = ( D44 . R4 ) by L514 , FUNCT_1:def 3;
L517: R4 in ( Seg C134 ) by L469 , L478 , L502 , L515 , FINSEQ_1:17;
reconsider D48 = R4 as (Element of ( NAT )) by L515;
L518: D48 <= C134 by L517 , FINSEQ_1:1;
L519: D48 <= ( R35 + 1 ) by L518 , L502 , XXREAL_0:2;
L520: 1 <= D48 by L517 , FINSEQ_1:1;
L521: D48 in ( Seg ( R35 + 1 ) ) by L520 , L519 , FINSEQ_1:1;
L522: D48 in ( dom C131 ) by L521 , L469 , L478 , FINSEQ_1:def 3;
L523: ( D44 . D48 ) = ( C131 . D48 ) by L515 , FUNCT_1:47;
L524: ( C131 . D48 ) = ( C131 . D39 ) by L523 , L477 , L512 , L516 , TARSKI:def 1;
L525: D48 <> D39 by L508 , L517 , FINSEQ_1:1;
thus L526: contradiction by L525 , L472 , L476 , L522 , L524 , FUNCT_1:def 4;
end;
L527: D47 = ( C131 . D39 ) by L477 , L512 , TARSKI:def 1;
L528:
now
assume L529: D47 in ( rng D45 );
consider R4 being set such that L530: R4 in ( dom D45 ) and L531: D47 = ( D45 . R4 ) by L529 , FUNCT_1:def 3;
reconsider D49 = R4 as (Element of ( NAT )) by L530;
L532: D49 <= D40 by L483 , L530 , FINSEQ_1:1;
L533: ( D39 + D49 ) <= ( R35 + 1 ) by L532 , L481 , XREAL_1:7;
L534: 1 <= ( D39 + D49 ) by L499 , NAT_1:12;
L535: ( D39 + D49 ) in ( Seg ( R35 + 1 ) ) by L534 , L533 , FINSEQ_1:1;
L536: ( D39 + D49 ) in ( dom C131 ) by L535 , L469 , L478 , FINSEQ_1:def 3;
L537: ( C131 . D39 ) = ( C131 . ( D39 + D49 ) ) by L483 , L484 , L527 , L530 , L531;
L538: D39 = ( D39 + D49 ) by L537 , L472 , L476 , L536 , FUNCT_1:def 4;
L539: D49 <> ( 0 ) by L483 , L530 , FINSEQ_1:1;
thus L540: contradiction by L539 , L538;
end;
L541: D47 in ( rng D46 ) by L511 , XBOOLE_0:def 4;
L542: D47 in ( ( rng D44 ) \/ ( rng D45 ) ) by L541 , FINSEQ_1:31;
thus L543: thesis by L542 , L513 , L528 , XBOOLE_0:def 3;
end;
L544: D46 is  one-to-one
proof
let C136 , C137 being set;
assume that
L545: (C136 in ( dom D46 ) & C137 in ( dom D46 ))
and
L546: ( D46 . C136 ) = ( D46 . C137 );
reconsider D50 = C136 , D51 = C137 as (Element of ( NAT )) by L545;
L547:
now
given C138 being Nat such that
L548: C138 in ( dom D45 )
and
L549: D50 = ( ( len D44 ) + C138 );

L550: ( D45 . C138 ) = ( C131 . ( D39 + C138 ) ) by L483 , L484 , L548;
L551: C138 <= D40 by L483 , L548 , FINSEQ_1:1;
L552: ( D39 + C138 ) <= ( R35 + 1 ) by L551 , L481 , XREAL_1:7;
L553: 1 <= ( D39 + C138 ) by L499 , NAT_1:12;
L554: ( D39 + C138 ) in ( Seg ( R35 + 1 ) ) by L553 , L552 , FINSEQ_1:1;
L555: ( D39 + C138 ) in ( dom C131 ) by L554 , L469 , L478 , FINSEQ_1:def 3;
given C139 being Nat such that
L556: C139 in ( dom D45 )
and
L557: D51 = ( ( len D44 ) + C139 );

L558: ( D45 . C139 ) = ( C131 . ( D39 + C139 ) ) by L483 , L484 , L556;
L559: C139 <= D40 by L483 , L556 , FINSEQ_1:1;
L560: ( D39 + C139 ) <= ( R35 + 1 ) by L559 , L481 , XREAL_1:7;
L561: 1 <= ( D39 + C139 ) by L499 , NAT_1:12;
L562: ( D39 + C139 ) in ( Seg ( R35 + 1 ) ) by L561 , L560 , FINSEQ_1:1;
L563: ( D39 + C139 ) in ( dom C131 ) by L562 , L469 , L478 , FINSEQ_1:def 3;
L564: ( D45 . C138 ) = ( D46 . ( C134 + C139 ) ) by L503 , L546 , L548 , L549 , L557 , FINSEQ_1:def 7
.= ( D45 . C139 ) by L503 , L556 , FINSEQ_1:def 7;
L565: ( D39 + C138 ) = ( D39 + C139 ) by L564 , L472 , L550 , L558 , L555 , L563 , FUNCT_1:def 4;
thus L566: thesis by L565 , L549 , L557;
end;
L567:
now
assume L568: D51 in ( dom D44 );
L569: ( D44 . D51 ) = ( C131 . D51 ) by L568 , FUNCT_1:47;
L570: ( D46 . D51 ) = ( C131 . D51 ) by L569 , L568 , FINSEQ_1:def 7;
L571: D51 in ( Seg C134 ) by L469 , L478 , L502 , L568 , FINSEQ_1:17;
L572: 1 <= D51 by L571 , FINSEQ_1:1;
L573: D51 <= C134 by L571 , FINSEQ_1:1;
L574: D51 <= ( R35 + 1 ) by L573 , L502 , XXREAL_0:2;
L575: D51 in ( Seg ( R35 + 1 ) ) by L574 , L572 , FINSEQ_1:1;
L576: D51 in ( dom C131 ) by L575 , L469 , L478 , FINSEQ_1:def 3;
given C140 being Nat such that
L577: C140 in ( dom D45 )
and
L578: D50 = ( ( len D44 ) + C140 );

L579: ( D45 . C140 ) = ( C131 . ( D39 + C140 ) ) by L483 , L484 , L577;
L580: ( C131 . D51 ) = ( C131 . ( D39 + C140 ) ) by L579 , L546 , L577 , L578 , L570 , FINSEQ_1:def 7;
L581: C140 <= D40 by L483 , L577 , FINSEQ_1:1;
L582: ( D39 + C140 ) <= ( R35 + 1 ) by L581 , L481 , XREAL_1:7;
L583: 1 <= ( D39 + C140 ) by L499 , NAT_1:12;
L584: ( D39 + C140 ) in ( Seg ( R35 + 1 ) ) by L583 , L582 , FINSEQ_1:1;
L585: ( D39 + C140 ) in ( dom C131 ) by L584 , L469 , L478 , FINSEQ_1:def 3;
L586: D39 <= ( D39 + C140 ) by NAT_1:12;
L587: D51 < D39 by L508 , L573 , XXREAL_0:2;
thus L588: thesis by L587 , L472 , L580 , L576 , L585 , L586 , FUNCT_1:def 4;
end;
L589:
now
assume L590: D50 in ( dom D44 );
L591: ( D44 . D50 ) = ( C131 . D50 ) by L590 , FUNCT_1:47;
L592: ( D46 . D50 ) = ( C131 . D50 ) by L591 , L590 , FINSEQ_1:def 7;
L593: D50 in ( Seg C134 ) by L469 , L478 , L502 , L590 , FINSEQ_1:17;
L594: 1 <= D50 by L593 , FINSEQ_1:1;
L595: D50 <= C134 by L593 , FINSEQ_1:1;
L596: D50 <= ( R35 + 1 ) by L595 , L502 , XXREAL_0:2;
L597: D50 in ( Seg ( R35 + 1 ) ) by L596 , L594 , FINSEQ_1:1;
L598: D50 in ( dom C131 ) by L597 , L469 , L478 , FINSEQ_1:def 3;
given C141 being Nat such that
L599: C141 in ( dom D45 )
and
L600: D51 = ( ( len D44 ) + C141 );

L601: ( D45 . C141 ) = ( C131 . ( D39 + C141 ) ) by L483 , L484 , L599;
L602: ( C131 . D50 ) = ( C131 . ( D39 + C141 ) ) by L601 , L546 , L599 , L600 , L592 , FINSEQ_1:def 7;
L603: C141 <= D40 by L483 , L599 , FINSEQ_1:1;
L604: ( D39 + C141 ) <= ( R35 + 1 ) by L603 , L481 , XREAL_1:7;
L605: 1 <= ( D39 + C141 ) by L499 , NAT_1:12;
L606: ( D39 + C141 ) in ( Seg ( R35 + 1 ) ) by L605 , L604 , FINSEQ_1:1;
L607: ( D39 + C141 ) in ( dom C131 ) by L606 , L469 , L478 , FINSEQ_1:def 3;
L608: D39 <= ( D39 + C141 ) by NAT_1:12;
L609: D50 < D39 by L508 , L595 , XXREAL_0:2;
thus L610: thesis by L609 , L472 , L602 , L598 , L607 , L608 , FUNCT_1:def 4;
end;
L611: D44 is  one-to-one by L472 , FUNCT_1:52;
L612:
now
assume L613: (D50 in ( dom D44 ) & D51 in ( dom D44 ));
L614: (( D44 . D50 ) = ( D46 . D50 ) & ( D44 . D51 ) = ( D46 . D51 )) by L613 , FINSEQ_1:def 7;
thus L615: thesis by L614 , L546 , L611 , L613 , FUNCT_1:def 4;
end;
thus L616: thesis by L612 , L545 , L589 , L567 , L547 , FINSEQ_1:25;
end;
L617: R35 <= ( R35 + 1 ) by NAT_1:12;
L618: ( len D43 ) = R35 by L617 , L469 , FINSEQ_1:17;
L619:
now
let C142 being Nat;
assume L620: C142 in ( dom <* D38 *> );
L621: C142 in ( Seg 1 ) by L620 , FINSEQ_1:38;
L622: C142 = 1 by L621 , FINSEQ_1:2 , TARSKI:def 1;
thus L623: ( C130 . ( ( len D43 ) + C142 ) ) = ( <* D38 *> . C142 ) by L622 , L618 , FINSEQ_1:40;
end;
L624:
now
let C143 being Nat;
assume L625: C143 in ( dom ( D44 ^ <* D38 *> ) );
L626:
now
assume L627: C143 in ( Seg C134 );
L628: C143 in ( dom D44 ) by L627 , L469 , L478 , L502 , FINSEQ_1:17;
L629: ( D44 . C143 ) = ( C131 . C143 ) by L628 , FUNCT_1:47;
thus L630: ( C131 . C143 ) = ( ( D44 ^ <* D38 *> ) . C143 ) by L629 , L628 , FINSEQ_1:def 7;
end;
L631:
now
L632: (1 in ( Seg 1 ) & ( len <* D38 *> ) = 1) by FINSEQ_1:1 , FINSEQ_1:39;
L633: 1 in ( dom <* D38 *> ) by L632 , FINSEQ_1:def 3;
L634: ( ( D44 ^ <* D38 *> ) . ( ( len D44 ) + 1 ) ) = ( <* D38 *> . 1 ) by L633 , FINSEQ_1:def 7;
assume L635: C143 in { D39 };
L636: C143 = D39 by L635 , TARSKI:def 1;
thus L637: ( ( D44 ^ <* D38 *> ) . C143 ) = ( C131 . C143 ) by L636 , L477 , L500 , L503 , L634 , FINSEQ_1:40;
end;
L638: ( len ( D44 ^ <* D38 *> ) ) = ( C134 + ( len <* D38 *> ) ) by L503 , FINSEQ_1:22
.= ( C134 + 1 ) by FINSEQ_1:40;
L639: C143 in ( Seg ( C134 + 1 ) ) by L638 , L625 , FINSEQ_1:def 3;
L640: C143 in ( ( Seg C134 ) \/ { D39 } ) by L639 , L500 , FINSEQ_1:9;
thus L641: ( C131 . C143 ) = ( ( D44 ^ <* D38 *> ) . C143 ) by L640 , L626 , L631 , XBOOLE_0:def 3;
end;
L642: ( len D45 ) = D40 by L483 , FINSEQ_1:def 3;
L643: ( ( len ( D44 ^ <* D38 *> ) ) + ( len D45 ) ) = ( ( ( len D44 ) + ( len <* D38 *> ) ) + D40 ) by L642 , FINSEQ_1:22
.= ( R35 + 1 ) by L500 , L481 , L503 , FINSEQ_1:40;
L644: ( dom C131 ) = ( Seg ( ( len ( D44 ^ <* D38 *> ) ) + ( len D45 ) ) ) by L643 , L469 , L478 , FINSEQ_1:def 3;
L645: C131 = ( ( D44 ^ <* D38 *> ) ^ D45 ) by L644 , L624 , L504 , FINSEQ_1:def 7;
L646: ( rng C131 ) = ( ( rng ( D44 ^ <* D38 *> ) ) \/ ( rng D45 ) ) by L645 , FINSEQ_1:31
.= ( ( ( rng <* D38 *> ) \/ ( rng D44 ) ) \/ ( rng D45 ) ) by FINSEQ_1:31
.= ( ( { D38 } \/ ( rng D44 ) ) \/ ( rng D45 ) ) by FINSEQ_1:39
.= ( { D38 } \/ ( ( rng D44 ) \/ ( rng D45 ) ) ) by XBOOLE_1:4
.= ( { D38 } \/ ( rng D46 ) ) by FINSEQ_1:31;
L647: ( rng D46 ) = ( ( rng C131 ) \ { D38 } ) by L646 , L509 , XBOOLE_1:88;
L648: ( Seg ( R35 + 1 ) ) = ( dom C130 ) by L469 , FINSEQ_1:def 3;
L649: (( rng D43 ) = ( C130 .: ( Seg R35 ) ) & ( rng C130 ) = ( C130 .: ( Seg ( R35 + 1 ) ) )) by L648 , RELAT_1:113 , RELAT_1:115;
L650: ( rng D43 ) = ( rng D46 ) by L649 , L470 , L647 , L648 , L498 , FINSEQ_1:4 , FUNCT_1:59;
L651: (( len <* D38 *> ) = 1 & (for B138 being Nat holds (B138 in ( dom D43 ) implies ( C130 . B138 ) = ( D43 . B138 )))) by FINSEQ_1:39 , FUNCT_1:47;
L652: C130 = ( D43 ^ <* D38 *> ) by L651 , L618 , L648 , L619 , FINSEQ_1:def 7;
L653: ( Sum C130 ) = ( ( Sum D43 ) + ( Sum <* D38 *> ) ) by L652 , L385;
L654: ( Sum C131 ) = ( ( Sum ( D44 ^ <* D38 *> ) ) + ( Sum D45 ) ) by L645 , L385
.= ( ( ( Sum D44 ) + ( Sum <* D38 *> ) ) + ( Sum D45 ) ) by L385
.= ( ( Sum <* D38 *> ) + ( ( Sum D44 ) + ( Sum D45 ) ) ) by L12
.= ( ( Sum D46 ) + ( Sum <* D38 *> ) ) by L385;
thus L655: ( Sum C130 ) = ( Sum C131 ) by L654 , L468 , L618 , L650 , L496 , L544 , L653;
end;
L656: (for R35 being (Element of ( NAT )) holds (S8[ R35 ] implies S8[ ( R35 + 1 ) ])) by L467;
L657:
now
let C144 , C145 being (FinSequence of C127);
assume that
L658: ( len C144 ) = ( 0 )
and
L659: ( rng C144 ) = ( rng C145 )
and
L660: C144 is  one-to-one
and
L661: C145 is  one-to-one;
L662: C144 = ( {} ) by L658;
L663: C145 = ( {} ) by L662 , L659;
L664: ( len C145 ) = ( 0 ) by L663;
L665: ( Sum C144 ) = ( 0. C127 ) by L658 , L271;
thus L666: ( Sum C144 ) = ( Sum C145 ) by L665 , L664 , L271;
end;
L667: S8[ ( 0 ) ] by L657;
L668: (for R35 being (Element of ( NAT )) holds S8[ R35 ]) from NAT_1:sch 1(L667 , L656);
thus L669: thesis by L668 , L466;
end;
theorem
L670: (for B139 being non  empty addLoopStr holds ( Sum ( <*> (the carrier of B139) ) ) = ( 0. B139 )) by L268;
theorem
L671: (for B140 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B141 being (Element of B140) holds ( Sum <* B141 *> ) = B141)) by L455;
theorem
L672: (for B142 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B143 , B144 being (Element of B142) holds ( Sum <* B143 , B144 *> ) = ( B143 + B144 )))
proof
let C146 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C147 , C148 being (Element of C146);
L673: <* C147 , C148 *> = ( <* C147 *> ^ <* C148 *> ) by FINSEQ_1:def 9;
thus L674: ( Sum <* C147 , C148 *> ) = ( ( Sum <* C147 *> ) + ( Sum <* C148 *> ) ) by L673 , L385
.= ( C147 + ( Sum <* C148 *> ) ) by L455
.= ( C147 + C148 ) by L455;
end;
theorem
L675: (for B145 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B146 , B147 , B148 being (Element of B145) holds ( Sum <* B146 , B147 , B148 *> ) = ( ( B146 + B147 ) + B148 )))
proof
let C149 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C150 , C151 , C152 being (Element of C149);
L676: <* C150 , C151 , C152 *> = ( <* C150 , C151 *> ^ <* C152 *> ) by FINSEQ_1:43;
thus L677: ( Sum <* C150 , C151 , C152 *> ) = ( ( Sum <* C150 , C151 *> ) + ( Sum <* C152 *> ) ) by L676 , L385
.= ( ( Sum <* C150 , C151 *> ) + C152 ) by L455
.= ( ( C150 + C151 ) + C152 ) by L672;
end;
theorem
L678: (for B149 being RealLinearSpace holds (for B150 being Real holds ( B150 * ( Sum ( <*> (the carrier of B149) ) ) ) = ( 0. B149 ))) by L268 , L106;
theorem
L679: (for B151 being RealLinearSpace holds (for B152 being Real holds (for B153 , B154 being (VECTOR of B151) holds ( B152 * ( Sum <* B153 , B154 *> ) ) = ( ( B152 * B153 ) + ( B152 * B154 ) ))))
proof
let C153 being RealLinearSpace;
let C154 being Real;
let C155 , C156 being (VECTOR of C153);
thus L680: ( C154 * ( Sum <* C155 , C156 *> ) ) = ( C154 * ( C155 + C156 ) ) by L672
.= ( ( C154 * C155 ) + ( C154 * C156 ) ) by L16;
end;
theorem
L681: (for B155 being RealLinearSpace holds (for B156 being Real holds (for B157 , B158 , B159 being (VECTOR of B155) holds ( B156 * ( Sum <* B157 , B158 , B159 *> ) ) = ( ( ( B156 * B157 ) + ( B156 * B158 ) ) + ( B156 * B159 ) ))))
proof
let C157 being RealLinearSpace;
let C158 being Real;
let C159 , C160 , C161 being (VECTOR of C157);
thus L682: ( C158 * ( Sum <* C159 , C160 , C161 *> ) ) = ( C158 * ( ( C159 + C160 ) + C161 ) ) by L675
.= ( ( C158 * ( C159 + C160 ) ) + ( C158 * C161 ) ) by L16
.= ( ( ( C158 * C159 ) + ( C158 * C160 ) ) + ( C158 * C161 ) ) by L16;
end;
theorem
L683: (for R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds ( - ( Sum ( <*> (the carrier of R27) ) ) ) = ( 0. R27 ))
proof
let R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
thus L684: ( - ( Sum ( <*> (the carrier of R27) ) ) ) = ( - ( 0. R27 ) ) by L268
.= ( 0. R27 ) by L121;
end;
theorem
L685: (for R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R29 being (Element of R27) holds ( - ( Sum <* R29 *> ) ) = ( - R29 ))) by L455;
theorem
L686: (for B160 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B161 , B162 being (Element of B160) holds ( - ( Sum <* B161 , B162 *> ) ) = ( ( - B161 ) - B162 )))
proof
let C162 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C163 , C164 being (Element of C162);
thus L687: ( - ( Sum <* C163 , C164 *> ) ) = ( - ( C163 + C164 ) ) by L672
.= ( ( - C163 ) - C164 ) by L169;
end;
theorem
L688: (for B163 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B164 , B165 , B166 being (Element of B163) holds ( - ( Sum <* B164 , B165 , B166 *> ) ) = ( ( ( - B164 ) - B165 ) - B166 )))
proof
let C165 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C166 , C167 , C168 being (Element of C165);
thus L689: ( - ( Sum <* C166 , C167 , C168 *> ) ) = ( - ( ( C166 + C167 ) + C168 ) ) by L675
.= ( ( - ( C166 + C167 ) ) - C168 ) by L169
.= ( ( ( - C166 ) - C167 ) - C168 ) by L169;
end;
theorem
L690: (for B167 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B168 , B169 being (Element of B167) holds ( Sum <* B168 , B169 *> ) = ( Sum <* B169 , B168 *> )))
proof
let C169 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C170 , C171 being (Element of C169);
thus L691: ( Sum <* C170 , C171 *> ) = ( C170 + C171 ) by L672
.= ( Sum <* C171 , C170 *> ) by L672;
end;
theorem
L692: (for R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R29 being (Element of R27) holds (for R33 being (Element of R27) holds ( Sum <* R29 , R33 *> ) = ( ( Sum <* R29 *> ) + ( Sum <* R33 *> ) ))))
proof
let R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R29 being (Element of R27);
let R33 being (Element of R27);
thus L693: ( Sum <* R29 , R33 *> ) = ( R29 + R33 ) by L672
.= ( ( Sum <* R29 *> ) + R33 ) by L455
.= ( ( Sum <* R29 *> ) + ( Sum <* R33 *> ) ) by L455;
end;
canceled 1;
theorem
L694: (for R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R29 being (Element of R27) holds (( Sum <* ( 0. R27 ) , R29 *> ) = R29 & ( Sum <* R29 , ( 0. R27 ) *> ) = R29)))
proof
let R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R29 being (Element of R27);
thus L695: ( Sum <* ( 0. R27 ) , R29 *> ) = ( ( 0. R27 ) + R29 ) by L672
.= R29 by L66;
thus L696: ( Sum <* R29 , ( 0. R27 ) *> ) = ( R29 + ( 0. R27 ) ) by L672
.= R29 by L66;
end;
theorem
L697: (for R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R29 being (Element of R27) holds (( Sum <* R29 , ( - R29 ) *> ) = ( 0. R27 ) & ( Sum <* ( - R29 ) , R29 *> ) = ( 0. R27 ))))
proof
let R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R29 being (Element of R27);
L698: ( R29 + ( - R29 ) ) = ( 0. R27 ) by L72;
thus L699: ( Sum <* R29 , ( - R29 ) *> ) = ( 0. R27 ) by L698 , L672;
L700: ( ( - R29 ) + R29 ) = ( 0. R27 ) by L698 , L57;
thus L701: thesis by L700 , L672;
end;
theorem
L702: (for R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R29 being (Element of R27) holds (for R33 being (Element of R27) holds ( Sum <* R29 , ( - R33 ) *> ) = ( R29 - R33 )))) by L672;
theorem
L703: (for R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R29 being (Element of R27) holds (for R33 being (Element of R27) holds ( Sum <* ( - R29 ) , ( - R33 ) *> ) = ( - ( R33 + R29 ) ))))
proof
let R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R29 being (Element of R27);
let R33 being (Element of R27);
thus L704: ( Sum <* ( - R29 ) , ( - R33 ) *> ) = ( ( - R29 ) + ( - R33 ) ) by L672
.= ( - ( R33 + R29 ) ) by L161;
end;
theorem
L705: (for B170 being RealLinearSpace holds (for B171 being (VECTOR of B170) holds ( Sum <* B171 , B171 *> ) = ( 2 * B171 )))
proof
let C172 being RealLinearSpace;
let C173 being (VECTOR of C172);
thus L706: ( Sum <* C173 , C173 *> ) = ( C173 + C173 ) by L672
.= ( ( 1 * C173 ) + C173 ) by L19
.= ( ( 1 * C173 ) + ( 1 * C173 ) ) by L19
.= ( ( 1 + 1 ) * C173 ) by L17
.= ( 2 * C173 );
end;
theorem
L707: (for B172 being RealLinearSpace holds (for B173 being (VECTOR of B172) holds ( Sum <* ( - B173 ) , ( - B173 ) *> ) = ( ( - 2 ) * B173 )))
proof
let C174 being RealLinearSpace;
let C175 being (VECTOR of C174);
thus L708: ( Sum <* ( - C175 ) , ( - C175 ) *> ) = ( - ( C175 + C175 ) ) by L703
.= ( - ( Sum <* C175 , C175 *> ) ) by L672
.= ( - ( 2 * C175 ) ) by L705
.= ( ( - 1 ) * ( 2 * C175 ) ) by L127
.= ( ( ( - 1 ) * 2 ) * C175 ) by L18
.= ( ( - 2 ) * C175 );
end;
theorem
L709: (for R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R29 being (Element of R27) holds (for R32 being (Element of R27) holds (for R33 being (Element of R27) holds ( Sum <* R32 , R29 , R33 *> ) = ( ( ( Sum <* R32 *> ) + ( Sum <* R29 *> ) ) + ( Sum <* R33 *> ) )))))
proof
let R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R29 being (Element of R27);
let R32 being (Element of R27);
let R33 being (Element of R27);
thus L710: ( Sum <* R32 , R29 , R33 *> ) = ( ( R32 + R29 ) + R33 ) by L675
.= ( ( ( Sum <* R32 *> ) + R29 ) + R33 ) by L455
.= ( ( ( Sum <* R32 *> ) + R29 ) + ( Sum <* R33 *> ) ) by L455
.= ( ( ( Sum <* R32 *> ) + ( Sum <* R29 *> ) ) + ( Sum <* R33 *> ) ) by L455;
end;
theorem
L711: (for R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R29 being (Element of R27) holds (for R32 being (Element of R27) holds (for R33 being (Element of R27) holds ( Sum <* R32 , R29 , R33 *> ) = ( ( Sum <* R32 , R29 *> ) + R33 )))))
proof
let R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R29 being (Element of R27);
let R32 being (Element of R27);
let R33 being (Element of R27);
thus L712: ( Sum <* R32 , R29 , R33 *> ) = ( ( R32 + R29 ) + R33 ) by L675
.= ( ( Sum <* R32 , R29 *> ) + R33 ) by L672;
end;
theorem
L713: (for B174 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B175 , B176 , B177 being (Element of B174) holds ( Sum <* B176 , B175 , B177 *> ) = ( ( Sum <* B175 , B177 *> ) + B176 )))
proof
let C176 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C177 , C178 , C179 being (Element of C176);
thus L714: ( Sum <* C178 , C177 , C179 *> ) = ( ( C178 + C177 ) + C179 ) by L675
.= ( C178 + ( C177 + C179 ) ) by L12
.= ( ( Sum <* C177 , C179 *> ) + C178 ) by L672;
end;
theorem
L715: (for B178 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B179 , B180 , B181 being (Element of B178) holds ( Sum <* B180 , B179 , B181 *> ) = ( ( Sum <* B180 , B181 *> ) + B179 )))
proof
let C180 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C181 , C182 , C183 being (Element of C180);
thus L716: ( Sum <* C182 , C181 , C183 *> ) = ( ( C182 + C181 ) + C183 ) by L675
.= ( ( C182 + C183 ) + C181 ) by L12
.= ( ( Sum <* C182 , C183 *> ) + C181 ) by L672;
end;
theorem
L717: (for B182 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B183 , B184 , B185 being (Element of B182) holds ( Sum <* B184 , B183 , B185 *> ) = ( Sum <* B184 , B185 , B183 *> )))
proof
let C184 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C185 , C186 , C187 being (Element of C184);
thus L718: ( Sum <* C186 , C185 , C187 *> ) = ( ( C186 + C185 ) + C187 ) by L675
.= ( ( C186 + C187 ) + C185 ) by L12
.= ( Sum <* C186 , C187 , C185 *> ) by L675;
end;
theorem
L719: (for B186 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B187 , B188 , B189 being (Element of B186) holds ( Sum <* B188 , B187 , B189 *> ) = ( Sum <* B187 , B188 , B189 *> )))
proof
let C188 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C189 , C190 , C191 being (Element of C188);
thus L720: ( Sum <* C190 , C189 , C191 *> ) = ( ( C190 + C189 ) + C191 ) by L675
.= ( Sum <* C189 , C190 , C191 *> ) by L675;
end;
theorem
L721: (for B190 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B191 , B192 , B193 being (Element of B190) holds ( Sum <* B192 , B191 , B193 *> ) = ( Sum <* B191 , B193 , B192 *> )))
proof
let C192 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C193 , C194 , C195 being (Element of C192);
thus L722: ( Sum <* C194 , C193 , C195 *> ) = ( Sum <* C193 , C194 , C195 *> ) by L719
.= ( Sum <* C193 , C195 , C194 *> ) by L717;
end;
theorem
L723: (for B194 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B195 , B196 , B197 being (Element of B194) holds ( Sum <* B196 , B195 , B197 *> ) = ( Sum <* B197 , B195 , B196 *> )))
proof
let C196 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C197 , C198 , C199 being (Element of C196);
thus L724: ( Sum <* C198 , C197 , C199 *> ) = ( Sum <* C199 , C198 , C197 *> ) by L721
.= ( Sum <* C199 , C197 , C198 *> ) by L717;
end;
canceled 1;
theorem
L725: (for R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R29 being (Element of R27) holds (( Sum <* ( 0. R27 ) , ( 0. R27 ) , R29 *> ) = R29 & ( Sum <* ( 0. R27 ) , R29 , ( 0. R27 ) *> ) = R29 & ( Sum <* R29 , ( 0. R27 ) , ( 0. R27 ) *> ) = R29)))
proof
let R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R29 being (Element of R27);
thus L726: ( Sum <* ( 0. R27 ) , ( 0. R27 ) , R29 *> ) = ( ( ( 0. R27 ) + ( 0. R27 ) ) + R29 ) by L675
.= ( ( 0. R27 ) + R29 ) by L66
.= R29 by L66;
thus L727: ( Sum <* ( 0. R27 ) , R29 , ( 0. R27 ) *> ) = ( ( ( 0. R27 ) + R29 ) + ( 0. R27 ) ) by L675
.= ( ( 0. R27 ) + R29 ) by L66
.= R29 by L66;
thus L728: ( Sum <* R29 , ( 0. R27 ) , ( 0. R27 ) *> ) = ( ( R29 + ( 0. R27 ) ) + ( 0. R27 ) ) by L675
.= ( R29 + ( 0. R27 ) ) by L66
.= R29 by L66;
end;
theorem
L729: (for R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R29 being (Element of R27) holds (for R32 being (Element of R27) holds (( Sum <* ( 0. R27 ) , R32 , R29 *> ) = ( R32 + R29 ) & ( Sum <* R32 , R29 , ( 0. R27 ) *> ) = ( R32 + R29 ) & ( Sum <* R32 , ( 0. R27 ) , R29 *> ) = ( R32 + R29 )))))
proof
let R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R29 being (Element of R27);
let R32 being (Element of R27);
thus L730: ( Sum <* ( 0. R27 ) , R32 , R29 *> ) = ( ( ( 0. R27 ) + R32 ) + R29 ) by L675
.= ( R32 + R29 ) by L66;
thus L731: ( Sum <* R32 , R29 , ( 0. R27 ) *> ) = ( ( R32 + R29 ) + ( 0. R27 ) ) by L675
.= ( R32 + R29 ) by L66;
thus L732: ( Sum <* R32 , ( 0. R27 ) , R29 *> ) = ( ( R32 + ( 0. R27 ) ) + R29 ) by L675
.= ( R32 + R29 ) by L66;
end;
theorem
L733: (for B198 being RealLinearSpace holds (for B199 being (VECTOR of B198) holds ( Sum <* B199 , B199 , B199 *> ) = ( 3 * B199 )))
proof
let C200 being RealLinearSpace;
let C201 being (VECTOR of C200);
thus L734: ( Sum <* C201 , C201 , C201 *> ) = ( ( Sum <* C201 , C201 *> ) + C201 ) by L715
.= ( ( 2 * C201 ) + C201 ) by L705
.= ( ( 2 * C201 ) + ( 1 * C201 ) ) by L19
.= ( ( 2 + 1 ) * C201 ) by L17
.= ( 3 * C201 );
end;
theorem
L735: (for R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R28 being (FinSequence of R27) holds (( len R28 ) = ( 0 ) implies ( Sum R28 ) = ( 0. R27 )))) by L271;
theorem
L736: (for R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R28 being (FinSequence of R27) holds (( len R28 ) = 1 implies ( Sum R28 ) = ( R28 . 1 ))))
proof
let R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R28 being (FinSequence of R27);
assume L737: ( len R28 ) = 1;
L738: ( dom R28 ) = { 1 } by L737 , FINSEQ_1:2 , FINSEQ_1:def 3;
L739: 1 in ( dom R28 ) by L738 , TARSKI:def 1;
L740: ( R28 . 1 ) in ( rng R28 ) by L739 , FUNCT_1:def 3;
L741: ( rng R28 ) c= (the carrier of R27) by FINSEQ_1:def 4;
reconsider D52 = ( R28 . 1 ) as (Element of R27) by L741 , L740;
L742: R28 = <* D52 *> by L737 , FINSEQ_1:40;
thus L743: thesis by L742 , L455;
end;
theorem
L744: (for R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R28 being (FinSequence of R27) holds (for R30 being (Element of R27) holds (for R31 being (Element of R27) holds ((( len R28 ) = 2 & R30 = ( R28 . 1 ) & R31 = ( R28 . 2 )) implies ( Sum R28 ) = ( R30 + R31 ))))))
proof
let R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R28 being (FinSequence of R27);
let R30 being (Element of R27);
let R31 being (Element of R27);
assume L745: (( len R28 ) = 2 & R30 = ( R28 . 1 ) & R31 = ( R28 . 2 ));
L746: R28 = <* R30 , R31 *> by L745 , FINSEQ_1:44;
thus L747: thesis by L746 , L672;
end;
theorem
L748: (for R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R28 being (FinSequence of R27) holds (for R29 being (Element of R27) holds (for R30 being (Element of R27) holds (for R31 being (Element of R27) holds ((( len R28 ) = 3 & R30 = ( R28 . 1 ) & R31 = ( R28 . 2 ) & R29 = ( R28 . 3 )) implies ( Sum R28 ) = ( ( R30 + R31 ) + R29 )))))))
proof
let R27 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R28 being (FinSequence of R27);
let R29 being (Element of R27);
let R30 being (Element of R27);
let R31 being (Element of R27);
assume L749: (( len R28 ) = 3 & R30 = ( R28 . 1 ) & R31 = ( R28 . 2 ) & R29 = ( R28 . 3 ));
L750: R28 = <* R30 , R31 , R29 *> by L749 , FINSEQ_1:45;
thus L751: thesis by L750 , L675;
end;
begin
definition
let C202 being non  empty addLoopStr;
attr C202 is  zeroed
means
:L752: (for B200 being (Element of C202) holds (( B200 + ( 0. C202 ) ) = B200 & ( ( 0. C202 ) + B200 ) = B200));
end;
registration
cluster  zeroed ->  right_zeroed for non  empty non  empty non  empty non  empty addLoopStr;
coherence
proof
let C203 being non  empty addLoopStr;
assume L754: C203 is  zeroed;
thus L755: (for B201 being (Element of C203) holds ( B201 + ( 0. C203 ) ) = B201) by L754 , L752;
end;
end;
registration
cluster  Abelian  right_zeroed ->  zeroed for non  empty non  empty non  empty non  empty addLoopStr;
coherence
proof
let C204 being non  empty addLoopStr;
assume L757: C204 is  Abelian  right_zeroed;
let C205 being (Element of C204);
thus L758: ( C205 + ( 0. C204 ) ) = C205 by L757 , L14;
thus L759: thesis by L758 , L757 , L11;
end;
cluster  Abelian  right_complementable ->  left_complementable for non  empty non  empty non  empty non  empty addLoopStr;
coherence
proof
let C206 being non  empty addLoopStr;
assume L760: C206 is  Abelian  right_complementable;
let C207 being (Element of C206);
consider C208 being (Element of C206) such that L761: ( C207 + C208 ) = ( 0. C206 ) by L760 , ALGSTR_0:def 11;
take C208;
thus L762: thesis by L760 , L761 , L11;
end;
end;
theorem
L764: (for R6 being  real number holds (for R36 being RealLinearSpace holds (for R37 being (VECTOR of R36) holds ( ( - R6 ) * R37 ) = ( - ( R6 * R37 ) ))))
proof
let R6 being  real number;
let R36 being RealLinearSpace;
let R37 being (VECTOR of R36);
thus L765: ( ( - R6 ) * R37 ) = ( R6 * ( - R37 ) ) by L155
.= ( - ( R6 * R37 ) ) by L157;
end;
begin
theorem
L766: (for B202 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds ( - ( Sum ( <*> (the carrier of B202) ) ) ) = ( 0. B202 ))
proof
let C209 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
thus L767: ( - ( Sum ( <*> (the carrier of C209) ) ) ) = ( - ( 0. C209 ) ) by L670
.= ( 0. C209 ) by L121;
end;
theorem
L768: (for B203 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B204 , B205 being (Element of B203) holds ( - ( Sum <* B204 , B205 *> ) ) = ( ( - B204 ) - B205 )))
proof
let C210 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C211 , C212 being (Element of C210);
thus L769: ( - ( Sum <* C211 , C212 *> ) ) = ( - ( C211 + C212 ) ) by L672
.= ( ( - C211 ) - C212 ) by L169;
end;
theorem
L770: (for B206 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B207 , B208 , B209 being (Element of B206) holds ( - ( Sum <* B207 , B208 , B209 *> ) ) = ( ( ( - B207 ) - B208 ) - B209 )))
proof
let C213 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C214 , C215 , C216 being (Element of C213);
thus L771: ( - ( Sum <* C214 , C215 , C216 *> ) ) = ( - ( ( C214 + C215 ) + C216 ) ) by L675
.= ( ( - ( C214 + C215 ) ) - C216 ) by L169
.= ( ( ( - C214 ) - C215 ) - C216 ) by L169;
end;
theorem
L772: (for B210 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B211 being (Element of B210) holds (( Sum <* B211 , ( - B211 ) *> ) = ( 0. B210 ) & ( Sum <* ( - B211 ) , B211 *> ) = ( 0. B210 ))))
proof
let C217 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C218 being (Element of C217);
thus L773: ( Sum <* C218 , ( - C218 ) *> ) = ( C218 + ( - C218 ) ) by L672
.= ( 0. C217 ) by L86;
thus L774: thesis by L773 , L690;
end;
theorem
L775: (for B212 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B213 , B214 being (Element of B212) holds (( Sum <* B213 , ( - B214 ) *> ) = ( B213 - B214 ) & ( Sum <* ( - B214 ) , B213 *> ) = ( B213 - B214 ))))
proof
let C219 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C220 , C221 being (Element of C219);
thus L776: ( Sum <* C220 , ( - C221 ) *> ) = ( C220 + ( - C221 ) ) by L672
.= ( C220 - C221 );
thus L777: thesis by L776 , L690;
end;
theorem
L778: (for B215 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B216 , B217 being (Element of B215) holds (( Sum <* ( - B216 ) , ( - B217 ) *> ) = ( - ( B216 + B217 ) ) & ( Sum <* ( - B217 ) , ( - B216 ) *> ) = ( - ( B216 + B217 ) ))))
proof
let C222 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C223 , C224 being (Element of C222);
thus L779: ( Sum <* ( - C223 ) , ( - C224 ) *> ) = ( ( - C223 ) + ( - C224 ) ) by L672
.= ( - ( C223 + C224 ) ) by L171;
thus L780: thesis by L779 , L690;
end;
