:: More About Polynomials: Monomials and Constant Polynomials
::  by Christoph Schwarzweller
::
:: Received November 28, 2001
:: Copyright (c) 2001-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies RLVECT_1, ALGSTR_1, ALGSTR_0, VECTSP_1, BINOP_1, LATTICES,
      VECTSP_2, ZFMISC_1, XBOOLE_0, STRUCT_0, POLYNOM1, VALUED_0, SUBSET_1,
      SUPINF_2, FUNCT_4, PRE_POLY, FUNCT_1, FUNCOP_1, RELAT_1, ORDINAL1,
      CARD_1, PARTFUN1, POLYNOM2, FINSEQ_1, CARD_3, NUMBERS, XXREAL_0,
      QC_LANG1, FINSET_1, ORDERS_1, ARYTM_3, NAT_1, MESFUNC1, QUOFIELD,
      GROUP_1, TARSKI, MSSUBFAM, ALGSEQ_1, CAT_3, XCMPLX_0, ORDINAL4, POLYNOM7;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, RELSET_1, FUNCT_1,
      FINSET_1, ORDINAL1, PARTFUN1, FUNCT_2, FUNCT_7, POLYNOM1, NUMBERS,
      XXREAL_0, DOMAIN_1, STRUCT_0, ALGSTR_0, FUNCT_4, NAT_1, ALGSTR_1,
      RLVECT_1, ORDERS_1, FINSEQ_1, FUNCOP_1, GROUP_1, QUOFIELD, GRCAT_1,
      VECTSP_2, POLYNOM2, VECTSP_1, GROUP_6, PRE_POLY;
 constructors REALSET2, GRCAT_1, GROUP_6, TRIANG_1, QUOFIELD, POLYNOM2,
      ALGSTR_1, RELSET_1, FUNCT_7, FVSUM_1;
 registrations XBOOLE_0, ORDINAL1, RELSET_1, FUNCOP_1, FINSET_1, XREAL_0,
      STRUCT_0, VECTSP_1, ALGSTR_1, POLYNOM1, POLYNOM2, ALGSTR_0, CARD_1,
      SUBSET_1, PRE_POLY, FUNCT_1;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCOP_1, STRUCT_0;
 theorems TARSKI, FINSEQ_1, FUNCT_1, FUNCT_2, RELAT_1, ZFMISC_1, VECTSP_1,
      POLYNOM1, STRUCT_0, QUOFIELD, FUNCT_7, FUNCT_4, FUNCOP_1, BINOM,
      FINSEQ_3, RLVECT_1, VECTSP_2, GROUP_1, NAT_1, FINSEQ_2, FINSEQ_5,
      MATRLIN, POLYNOM2, XBOOLE_0, XREAL_1, GROUP_6, XXREAL_0, ORDINAL1,
      PARTFUN1, PRE_POLY, XTUPLE_0;
 schemes FUNCT_2;

begin
registration
cluster  Abelian  left_zeroed  right_zeroed  add-associative  right_complementable  well-unital  associative  commutative  distributive  domRing-like for non  trivial non  trivial non  trivial non  trivial doubleLoopStr;
existence
proof
set D1 = the domRing;
take D1;
thus L1: thesis;
end;
end;
definition
let C1 being set;
let C2 being non  empty ZeroStr;
let C3 being (Series of C1 , C2);
attr C3 is  non-zero
means
:L3: C3 <> ( 0_ (C1 , C2) );
end;
registration
let C4 being set;
let C5 being non  trivial ZeroStr;
cluster  non-zero for (Series of C4 , C5);
existence
proof
set D2 = the (Element of ( NonZero C5 ));
L5: (not D2 in { ( 0. C5 ) }) by XBOOLE_0:def 5;
reconsider D3 = D2 as (Element of C5);
set D4 = ( ( 0_ (C4 , C5) ) +* (( EmptyBag C4 ) , D3) );
reconsider D5 = D4 as (Function of ( Bags C4 ) , (the carrier of C5));
reconsider D6 = D5 as (Function of ( Bags C4 ) , C5);
reconsider D7 = D6 as (Series of C4 , C5);
take D7;
L6: ( 0_ (C4 , C5) ) = ( ( Bags C4 ) --> ( 0. C5 ) ) by POLYNOM1:def 7;
L7: ( dom ( 0_ (C4 , C5) ) ) = ( Bags C4 ) by L6 , FUNCOP_1:13;
L8: ( D7 . ( EmptyBag C4 ) ) = D3 by L7 , FUNCT_7:31;
L9: D3 <> ( 0. C5 ) by L5 , TARSKI:def 1;
L10: D7 <> ( 0_ (C4 , C5) ) by L9 , L8 , POLYNOM1:22;
thus L11: thesis by L10 , L3;
end;
end;
registration
let C6 being Ordinal;
let C7 being non  trivial ZeroStr;
cluster  non-zero for (Polynomial of C6 , C7);
existence
proof
set D8 = the (Element of ( NonZero C7 ));
L13: (not D8 in { ( 0. C7 ) }) by XBOOLE_0:def 5;
reconsider D9 = D8 as (Element of C7);
set D10 = ( ( 0_ (C6 , C7) ) +* (( EmptyBag C6 ) , D9) );
reconsider D11 = D10 as (Function of ( Bags C6 ) , (the carrier of C7));
reconsider D12 = D11 as (Function of ( Bags C6 ) , C7);
reconsider D13 = D12 as (Series of C6 , C7);
L14:
now
let C8 being set;
assume L15: C8 in ( Support D13 );
L16: C8 is (Element of ( Bags C6 )) by L15;
L17: C8 is (bag of C6) by L16;
L18:
now
assume L19: C8 <> ( EmptyBag C6 );
L20: ( D13 . C8 ) = ( ( 0_ (C6 , C7) ) . C8 ) by L19 , FUNCT_7:32
.= ( 0. C7 ) by L17 , POLYNOM1:22;
thus L21: contradiction by L20 , L15 , POLYNOM1:def 3;
end;
thus L22: C8 in { ( EmptyBag C6 ) } by L18 , TARSKI:def 1;
end;
L23: ( 0_ (C6 , C7) ) = ( ( Bags C6 ) --> ( 0. C7 ) ) by POLYNOM1:def 7;
L24: ( dom ( 0_ (C6 , C7) ) ) = ( Bags C6 ) by L23 , FUNCOP_1:13;
L25: ( D13 . ( EmptyBag C6 ) ) = D9 by L24 , FUNCT_7:31;
L26:
now
let C9 being set;
assume L27: C9 in { ( EmptyBag C6 ) };
L28: C9 = ( EmptyBag C6 ) by L27 , TARSKI:def 1;
L29: D9 <> ( 0. C7 ) by L13 , TARSKI:def 1;
thus L30: C9 in ( Support D13 ) by L29 , L25 , L28 , POLYNOM1:def 3;
end;
L31: ( Support D13 ) = { ( EmptyBag C6 ) } by L26 , L14 , TARSKI:1;
reconsider D14 = D13 as (Polynomial of C6 , C7) by L31 , POLYNOM1:def 4;
take D14;
L32: D9 <> ( 0. C7 ) by L13 , TARSKI:def 1;
L33: D14 <> ( 0_ (C6 , C7) ) by L32 , L25 , POLYNOM1:22;
thus L34: thesis by L33 , L3;
end;
end;
theorem
L36: (for B1 being set holds (for B2 being non  empty ZeroStr holds (for B3 being (Series of B1 , B2) holds (B3 = ( 0_ (B1 , B2) ) iff ( Support B3 ) = ( {} )))))
proof
let C10 being set;
let C11 being non  empty ZeroStr;
let C12 being (Series of C10 , C11);
L37:
now
assume L38: ( Support C12 ) = ( {} );
L39:
now
let C13 being set;
assume L40: C13 in ( Bags C10 );
reconsider D15 = C13 as (Element of ( Bags C10 )) by L40;
L41: ( C12 . D15 ) = ( 0. C11 ) by L38 , POLYNOM1:def 3;
thus L42: ( C12 . C13 ) = ( ( 0_ (C10 , C11) ) . C13 ) by L41 , POLYNOM1:22;
end;
L43: (( dom C12 ) = ( Bags C10 ) & ( dom ( 0_ (C10 , C11) ) ) = ( Bags C10 )) by FUNCT_2:def 1;
thus L44: C12 = ( 0_ (C10 , C11) ) by L43 , L39 , FUNCT_1:2;
end;
L45:
now
assume L46: C12 = ( 0_ (C10 , C11) );
L47:
now
set D16 = the (Element of ( Support C12 ));
assume L48: ( Support C12 ) <> ( {} );
L49: D16 in ( Support C12 ) by L48;
reconsider D17 = D16 as (bag of C10) by L49;
L50: ( C12 . D17 ) <> ( 0. C11 ) by L49 , POLYNOM1:def 3;
thus L51: contradiction by L50 , L46 , POLYNOM1:22;
end;
thus L52: ( Support C12 ) = ( {} ) by L47;
end;
thus L53: thesis by L45 , L37;
end;
theorem
L54: (for B4 being set holds (for B5 being non  empty ZeroStr holds (B5 is non  trivial iff (ex B6 being (Series of B4 , B5) st ( Support B6 ) <> ( {} )))))
proof
let C14 being set;
let C15 being non  empty ZeroStr;
L55:
now
set D18 = ( EmptyBag C14 );
assume L56: C15 is non  trivial;
L57:
now
assume L58: (not (ex B7 being (Element of C15) st B7 <> ( 0. C15 )));
L59: (ex B8 being set st (the carrier of C15) = { B8 })
proof
take ( 0. C15 );
L60:
now
let C16 being set;
assume L61: C16 in (the carrier of C15);
L62: C16 = ( 0. C15 ) by L61 , L58;
thus L63: C16 in { ( 0. C15 ) } by L62 , TARSKI:def 1;
end;
L64: (for B9 being set holds (B9 in { ( 0. C15 ) } implies B9 in (the carrier of C15)));
thus L65: thesis by L64 , L60 , TARSKI:1;
end;
thus L66: contradiction by L59 , L56;
end;
consider C17 being (Element of C15) such that L67: C17 <> ( 0. C15 ) by L57;
set D19 = ( ( Bags C14 ) --> C17 );
reconsider D20 = D19 as (Function of ( Bags C14 ) , (the carrier of C15));
reconsider D21 = D20 as (Function of ( Bags C14 ) , C15);
reconsider D22 = D21 as (Series of C14 , C15);
take D23 = D22;
L68: ( D23 . D18 ) = C17 by FUNCOP_1:7;
L69: ( EmptyBag C14 ) in ( Support D23 ) by L68 , L67 , POLYNOM1:def 3;
thus L70: (ex B10 being (Series of C14 , C15) st ( Support B10 ) <> ( {} )) by L69;
end;
L71:
now
assume L72: (ex B11 being (Series of C14 , C15) st ( Support B11 ) <> ( {} ));
consider C18 being (Series of C14 , C15) such that L73: ( Support C18 ) <> ( {} ) by L72;
set D24 = the (Element of ( Support C18 ));
L74: D24 in ( Support C18 ) by L73;
reconsider D25 = D24 as (Element of ( Bags C14 )) by L74;
L75:
now
assume L76: (ex B12 being set st (the carrier of C15) = { B12 });
consider C19 being set such that L77: (the carrier of C15) = { C19 } by L76;
L78: ( 0. C15 ) = C19 by L77 , TARSKI:def 1
.= ( C18 . D25 ) by L77 , TARSKI:def 1;
thus L79: contradiction by L78 , L73 , POLYNOM1:def 3;
end;
thus L80: C15 is non  trivial by L75 , ZFMISC_1:131;
end;
thus L81: thesis by L71 , L55;
end;
definition
let C20 being set;
let C21 being (bag of C20);
attr C21 is  univariate
means
:L82: (ex B13 being (Element of C20) st ( support C21 ) = { B13 });
end;
registration
let C22 being non  empty set;
cluster  univariate for (bag of C22);
existence
proof
set D26 = the (Element of C22);
set D27 = ( ( EmptyBag C22 ) +* (D26 , 1) );
take D27;
L84: ( dom ( EmptyBag C22 ) ) = C22 by PARTFUN1:def 2;
L85: ( D27 . D26 ) = ( ( ( EmptyBag C22 ) +* ( D26 .--> 1 ) ) . D26 ) by L84 , FUNCT_7:def 3;
L86: ( dom ( D26 .--> 1 ) ) = { D26 } by FUNCOP_1:13;
L87: (for B14 being set holds (B14 in ( support D27 ) implies B14 in { D26 }))
proof
let C23 being set;
assume L88: C23 in ( support D27 );
L89:
now
assume L90: C23 <> D26;
L91: (not C23 in ( dom ( D26 .--> 1 ) )) by L90 , L86 , TARSKI:def 1;
L92: ( D27 . C23 ) = ( ( ( EmptyBag C22 ) +* ( D26 .--> 1 ) ) . C23 ) by L84 , FUNCT_7:def 3;
L93: ( D27 . C23 ) = ( ( EmptyBag C22 ) . C23 ) by L92 , L91 , FUNCT_4:11
.= ( 0 ) by PRE_POLY:52;
thus L94: contradiction by L93 , L88 , PRE_POLY:def 7;
end;
thus L95: thesis by L89 , TARSKI:def 1;
end;
L96: D26 in ( dom ( D26 .--> 1 ) ) by L86 , TARSKI:def 1;
L97: ( D27 . D26 ) = ( ( D26 .--> 1 ) . D26 ) by L96 , L85 , FUNCT_4:13
.= 1 by FUNCOP_1:72;
L98: (for B15 being set holds (B15 in { D26 } implies B15 in ( support D27 )))
proof
let C24 being set;
assume L99: C24 in { D26 };
L100: C24 = D26 by L99 , TARSKI:def 1;
thus L101: thesis by L100 , L97 , PRE_POLY:def 7;
end;
L102: ( support D27 ) = { D26 } by L98 , L87 , TARSKI:1;
thus L103: thesis by L102 , L82;
end;
end;
registration
let C25 being non  empty set;
cluster  univariate -> non  empty for (bag of C25);
coherence
proof
let C26 being (bag of C25);
assume L105: C26 is  univariate;
consider C27 being (Element of C25) such that L106: ( support C26 ) = { C27 } by L105 , L82;
L107: C27 in ( support C26 ) by L106 , TARSKI:def 1;
L108: ( C26 . C27 ) <> ( 0 ) by L107 , PRE_POLY:def 7;
L109: ( C26 . C27 ) <> ( ( EmptyBag C25 ) . C27 ) by L108 , PRE_POLY:52;
thus L110: thesis by L109 , POLYNOM2:def 1;
end;
end;
begin
theorem
L112: (for B16 being (bag of ( {} )) holds B16 = ( EmptyBag ( {} ) ))
proof
set D28 = ( {} );
let C28 being (bag of ( {} ));
L113: (for B17 being (bag of D28) holds B17 = ( {} ))
proof
let C29 being (bag of D28);
L114: C29 in ( Bags D28 ) by PRE_POLY:def 12;
thus L115: thesis by L114 , PRE_POLY:51 , TARSKI:def 1;
end;
L116: ( EmptyBag D28 ) = ( {} ) by L113;
thus L117: thesis by L116 , L113;
end;
L118: (for B18 being non  empty doubleLoopStr holds (for B19 being (Polynomial of ( {} ) , B18) holds (ex B20 being (Element of B18) st B19 = ( { ( EmptyBag ( {} ) ) } --> B20 ))))
proof
set D29 = ( {} );
let C30 being non  empty doubleLoopStr;
let C31 being (Polynomial of ( {} ) , C30);
L119: (for B21 being (bag of ( {} )) holds B21 = ( {} ))
proof
let C32 being (bag of ( {} ));
L120: C32 in ( Bags ( {} ) ) by PRE_POLY:def 12;
thus L121: thesis by L120 , PRE_POLY:51 , TARSKI:def 1;
end;
reconsider D30 = C31 as (Function of ( Bags ( {} ) ) , C30);
reconsider D31 = D30 as (Function of { ( {} ) } , (the carrier of C30)) by PRE_POLY:51;
set D32 = ( D31 /. ( {} ) );
L122: ( dom D31 ) = { ( {} ) } by FUNCT_2:def 1
.= { ( EmptyBag D29 ) } by L119;
L123: (for B22 being set holds (B22 in D31 implies B22 in [: { ( EmptyBag D29 ) } , { D32 } :]))
proof
let C33 being set;
assume L124: C33 in D31;
consider C34 , C35 being set such that L125: C33 = [ C34 , C35 ] by L124 , RELAT_1:def 1;
L126: C34 in ( dom D31 ) by L124 , L125 , XTUPLE_0:def 12;
reconsider D33 = C34 as (bag of D29) by L126 , L122;
L127: D33 = ( {} ) by L119;
L128: C35 = ( D31 . ( {} ) ) by L127 , L124 , L125 , L126 , FUNCT_1:def 2
.= ( D31 /. ( {} ) ) by L126 , L127 , PARTFUN1:def 6;
L129: C35 in { D32 } by L128 , TARSKI:def 1;
thus L130: thesis by L129 , L122 , L125 , L126 , ZFMISC_1:def 2;
end;
take D32;
L131: ( EmptyBag D29 ) = ( {} ) by L119;
L132: (for B23 being set holds (B23 in [: { ( EmptyBag D29 ) } , { D32 } :] implies B23 in D31))
proof
let C36 being set;
assume L133: C36 in [: { ( EmptyBag D29 ) } , { D32 } :];
consider C37 , C38 being set such that L134: C37 in { ( EmptyBag D29 ) } and L135: C38 in { D32 } and L136: C36 = [ C37 , C38 ] by L133 , ZFMISC_1:def 2;
L137: C37 = ( {} ) by L131 , L134 , TARSKI:def 1;
L138: C38 = D32 by L135 , TARSKI:def 1
.= ( D31 . ( {} ) ) by L122 , L134 , L137 , PARTFUN1:def 6;
thus L139: thesis by L138 , L122 , L134 , L136 , L137 , FUNCT_1:1;
end;
thus L140: thesis by L132 , L123 , TARSKI:1;
end;
theorem
L141: (for B24 being  right_zeroed  add-associative  right_complementable  well-unital  distributive non  trivial doubleLoopStr holds (for B25 being (Polynomial of ( {} ) , B24) holds (for B26 being (Function of ( {} ) , B24) holds ( eval (B25 , B26) ) = ( B25 . ( EmptyBag ( {} ) ) ))))
proof
set D34 = ( {} );
let C39 being  right_zeroed  add-associative  right_complementable  well-unital  distributive non  trivial doubleLoopStr;
let C40 being (Polynomial of ( {} ) , C39);
let C41 being (Function of ( {} ) , C39);
L142: (for B27 being (bag of D34) holds B27 = ( {} ))
proof
let C42 being (bag of D34);
L143: C42 in ( Bags D34 ) by PRE_POLY:def 12;
thus L144: thesis by L143 , PRE_POLY:51 , TARSKI:def 1;
end;
L145: ( EmptyBag D34 ) = ( {} ) by L142;
consider C43 being (Element of C39) such that L146: C40 = ( { ( EmptyBag D34 ) } --> C43 ) by L118;
L147: ( EmptyBag D34 ) in { ( EmptyBag D34 ) } by TARSKI:def 1;
L148: ( C40 . ( EmptyBag D34 ) ) = C43 by L147 , L146 , FUNCOP_1:7;
L149: ( dom C40 ) = { ( EmptyBag D34 ) } by L146 , FUNCOP_1:13;
L150:
now
per cases ;
case L151: C43 = ( 0. C39 );
L152: ( Support C40 ) = ( {} )
proof
set D35 = the (Element of ( Support C40 ));
assume L153: ( Support C40 ) <> ( {} );
L154: D35 in ( Support C40 ) by L153;
reconsider D36 = D35 as (Element of ( Bags D34 )) by L154;
L155: ( C40 . D36 ) <> ( 0. C39 ) by L153 , POLYNOM1:def 3;
thus L156: thesis by L155 , L142 , L145 , L148 , L151;
end;
reconsider D37 = ( Support C40 ) as  empty (Subset of ( Bags D34 )) by L152;
consider C44 being (FinSequence of (the carrier of C39)) such that L157: ( len C44 ) = ( len ( SgmX (( BagOrder D34 ) , ( Support C40 )) ) ) and L158: ( eval (C40 , C41) ) = ( Sum C44 ) and L159: (for B28 being (Element of ( NAT )) holds ((1 <= B28 & B28 <= ( len C44 )) implies ( C44 /. B28 ) = ( ( ( C40 * ( SgmX (( BagOrder D34 ) , ( Support C40 )) ) ) /. B28 ) * ( eval (( ( ( SgmX (( BagOrder D34 ) , ( Support C40 )) ) /. B28 ) @ ) , C41) ) ))) by POLYNOM2:def 4;
L160: ( SgmX (( BagOrder D34 ) , D37) ) = ( {} ) by POLYNOM2:7 , POLYNOM2:18;
L161: C44 = ( <*> (the carrier of C39) ) by L160 , L157;
thus L162: ( eval (C40 , C41) ) = C43 by L161 , L151 , L158 , RLVECT_1:43;
end;
case L163: C43 <> ( 0. C39 );
reconsider D38 = ( Support C40 ) as  finite (Subset of ( Bags D34 ));
set D39 = ( SgmX (( BagOrder D34 ) , D38) );
L164: ( BagOrder D34 ) linearly_orders D38 by POLYNOM2:18;
L165: (for B29 being set holds (B29 in ( Support C40 ) implies B29 in { ( {} ) }))
proof
let C45 being set;
assume L166: C45 in ( Support C40 );
reconsider D40 = C45 as (Element of ( Bags D34 )) by L166;
L167: D40 = ( {} ) by L142;
thus L168: thesis by L167 , TARSKI:def 1;
end;
L169: (for B30 being set holds (B30 in { ( {} ) } implies B30 in ( Support C40 )))
proof
let C46 being set;
assume L170: C46 in { ( {} ) };
L171: C46 = ( EmptyBag D34 ) by L170 , L145 , TARSKI:def 1;
thus L172: thesis by L171 , L148 , L163 , POLYNOM1:def 3;
end;
L173: ( Support C40 ) = { ( {} ) } by L169 , L165 , TARSKI:1;
L174: ( rng D39 ) = { ( {} ) } by L173 , L164 , PRE_POLY:def 2;
L175: ( {} ) in ( rng D39 ) by L174 , TARSKI:def 1;
L176: 1 in ( dom D39 ) by L175 , FINSEQ_3:31;
L177: ( D39 . 1 ) in ( dom C40 ) by L176 , L145 , L149 , L174 , FUNCT_1:3;
L178: 1 in ( dom ( C40 * D39 ) ) by L177 , L176 , FUNCT_1:11;
L179: ( ( C40 * D39 ) /. 1 ) = ( ( C40 * D39 ) . 1 ) by L178 , PARTFUN1:def 6
.= ( C40 . ( D39 . 1 ) ) by L176 , FUNCT_1:13
.= C43 by L145 , L146 , L174 , L176 , FUNCOP_1:7 , FUNCT_1:3;
L180: (for B31 being set holds (B31 in ( dom D39 ) implies B31 in { 1 }))
proof
let C47 being set;
assume L181: C47 in ( dom D39 );
assume L182: (not C47 in { 1 });
reconsider D41 = C47 as (Element of ( NAT )) by L181;
L183: ( D39 /. D41 ) = ( D39 . D41 ) by L181 , PARTFUN1:def 6;
L184: ( D39 /. D41 ) in ( rng D39 ) by L183 , L181 , FUNCT_1:3;
L185: D41 <> 1 by L182 , TARSKI:def 1;
L186: 1 < D41
proof
consider C48 being Nat such that L187: ( dom D39 ) = ( Seg C48 ) by FINSEQ_1:def 2;
L188: ( Seg C48 ) = { B32 where B32 is (Element of ( NAT )) : (1 <= B32 & B32 <= C48) } by FINSEQ_1:def 1;
L189: (ex B33 being (Element of ( NAT )) st (B33 = D41 & 1 <= B33 & B33 <= C48)) by L188 , L181 , L187;
thus L190: thesis by L189 , L185 , XXREAL_0:1;
end;
L191: ( D39 /. 1 ) = ( D39 . 1 ) by L175 , L181 , FINSEQ_3:31 , PARTFUN1:def 6;
L192: ( D39 /. 1 ) in ( rng D39 ) by L191 , L176 , FUNCT_1:3;
L193: ( D39 /. 1 ) = ( {} ) by L192 , L174 , TARSKI:def 1
.= ( D39 /. D41 ) by L174 , L184 , TARSKI:def 1;
thus L194: thesis by L193 , L164 , L176 , L181 , L186 , PRE_POLY:def 2;
end;
L195: (for B34 being set holds (B34 in { 1 } implies B34 in ( dom D39 ))) by L176 , TARSKI:def 1;
L196: ( dom D39 ) = ( Seg 1 ) by L195 , L180 , FINSEQ_1:2 , TARSKI:1;
L197: ( len D39 ) = 1 by L196 , FINSEQ_1:def 3;
consider C49 being (FinSequence of (the carrier of C39)) such that L198: ( len C49 ) = ( len D39 ) and L199: ( Sum C49 ) = ( eval (C40 , C41) ) and L200: (for B35 being (Element of ( NAT )) holds ((1 <= B35 & B35 <= ( len C49 )) implies ( C49 /. B35 ) = ( ( ( C40 * D39 ) /. B35 ) * ( eval (( ( D39 /. B35 ) @ ) , C41) ) ))) by POLYNOM2:def 4;
L201: ( dom C49 ) = ( Seg ( len C49 ) ) by FINSEQ_1:def 3
.= ( dom D39 ) by L198 , FINSEQ_1:def 3;
L202: ( C49 . 1 ) = ( C49 /. 1 ) by L201 , L175 , FINSEQ_3:31 , PARTFUN1:def 6
.= ( ( ( C40 * D39 ) /. 1 ) * ( eval (( ( D39 /. 1 ) @ ) , C41) ) ) by L197 , L198 , L200
.= ( ( ( C40 * D39 ) /. 1 ) * ( eval (( EmptyBag D34 ) , C41) ) ) by L142 , L145
.= ( ( ( C40 * D39 ) /. 1 ) * ( 1. C39 ) ) by POLYNOM2:14
.= C43 by L179 , VECTSP_1:def 4;
L203: C49 = <* C43 *> by L202 , L197 , L198 , FINSEQ_1:40;
thus L204: ( eval (C40 , C41) ) = C43 by L203 , L199 , RLVECT_1:44;
end;
end;
thus L206: thesis by L150 , L146 , L147 , FUNCOP_1:7;
end;
theorem
L207: (for B36 being  right_zeroed  add-associative  right_complementable  Abelian  well-unital  distributive  associative non  trivial non  trivial doubleLoopStr holds ( Polynom-Ring (( {} ) , B36) ) is_ringisomorph_to B36)
proof
set D42 = ( {} );
let C50 being  right_zeroed  add-associative  right_complementable  Abelian  well-unital  distributive  associative non  trivial non  trivial doubleLoopStr;
set D43 = ( Polynom-Ring (D42 , C50) );
defpred S1[ set , set ] means (ex B37 being (Polynomial of D42 , C50) st (B37 = $1 & ( B37 . ( {} ) ) = $2));
L208: ( dom ( 0_ (D42 , C50) ) ) = ( Bags D42 ) by FUNCT_2:def 1;
L209: ( dom ( ( EmptyBag D42 ) .--> ( 1_ C50 ) ) ) = { ( EmptyBag D42 ) } by FUNCOP_1:13;
L210: ( EmptyBag D42 ) in ( dom ( ( EmptyBag D42 ) .--> ( 1_ C50 ) ) ) by L209 , TARSKI:def 1;
L211: (for B38 being (bag of ( {} )) holds B38 = ( {} ))
proof
let C51 being (bag of ( {} ));
L212: C51 in ( Bags ( {} ) ) by PRE_POLY:def 12;
thus L213: thesis by L212 , PRE_POLY:51 , TARSKI:def 1;
end;
L214: ( EmptyBag D42 ) = ( {} ) by L211;
reconsider D44 = ( {} ) as (bag of D42) by L214;
L215: (for B39 being (Element of D43) holds (ex B40 being (Element of C50) st S1[ B39 , B40 ]))
proof
let C52 being (Element of D43);
reconsider D45 = C52 as (Polynomial of D42 , C50) by POLYNOM1:def 10;
take ( D45 . ( {} ) );
L216: ( dom D45 ) = ( Bags D42 ) by FUNCT_2:def 1;
L217: ( D45 . ( {} ) ) in ( rng D45 ) by L216 , L214 , FUNCT_1:3;
L218: ( rng D45 ) c= (the carrier of C50) by RELAT_1:def 19;
thus L219: thesis by L218 , L217;
end;
consider C53 being (Function of (the carrier of D43) , (the carrier of C50)) such that L220: (for B41 being (Element of D43) holds S1[ B41 , ( C53 . B41 ) ]) from FUNCT_2:sch 3(L215);
L221: ( dom C53 ) = (the carrier of D43) by FUNCT_2:def 1;
reconsider D46 = C53 as (Function of D43 , C50);
consider C54 being (Polynomial of D42 , C50) such that L222: C54 = ( 1_ D43 ) and L223: ( C54 . ( {} ) ) = ( D46 . ( 1. D43 ) ) by L220;
L224: C54 = ( 1_ (D42 , C50) ) by L222 , POLYNOM1:31
.= ( ( 0_ (D42 , C50) ) +* (( EmptyBag D42 ) , ( 1_ C50 )) ) by POLYNOM1:def 8;
L225: (for B42 , B43 being (Element of D43) holds ( D46 . ( B42 * B43 ) ) = ( ( D46 . B42 ) * ( D46 . B43 ) ))
proof
let C55 , C56 being (Element of D43);
consider C57 being (Polynomial of D42 , C50) such that L226: (C57 = C55 & ( C57 . ( {} ) ) = ( D46 . C55 )) by L220;
consider C58 being (Polynomial of D42 , C50) such that L227: (C58 = C56 & ( C58 . ( {} ) ) = ( D46 . C56 )) by L220;
L228: ( ( C57 *' C58 ) . ( {} ) ) = ( ( C57 . D44 ) * ( C58 . D44 ) )
proof
L229: ( decomp ( EmptyBag D42 ) ) = <* <* ( EmptyBag D42 ) , ( EmptyBag D42 ) *> *> by PRE_POLY:73;
L230: ( len ( decomp ( EmptyBag D42 ) ) ) = 1 by L229 , FINSEQ_1:39;
set D47 = ( ( C57 . D44 ) * ( C58 . D44 ) );
consider C59 being (FinSequence of (the carrier of C50)) such that L231: ( ( C57 *' C58 ) . ( EmptyBag D42 ) ) = ( Sum C59 ) and L232: ( len C59 ) = ( len ( decomp ( EmptyBag D42 ) ) ) and L233: (for B44 being (Element of ( NAT )) holds (B44 in ( dom C59 ) implies (ex B45 , B46 being (bag of D42) st (( ( decomp ( EmptyBag D42 ) ) /. B44 ) = <* B45 , B46 *> & ( C59 /. B44 ) = ( ( C57 . B45 ) * ( C58 . B46 ) ))))) by POLYNOM1:def 9;
L234: ( len C59 ) = 1 by L229 , L232 , FINSEQ_1:39;
L235: ( Seg 1 ) = ( dom C59 ) by L234 , FINSEQ_1:def 3;
L236: 1 in ( dom C59 ) by L235 , FINSEQ_1:2 , TARSKI:def 1;
consider C60 , C61 being (bag of D42) such that L237: ( ( decomp ( EmptyBag D42 ) ) /. 1 ) = <* C60 , C61 *> and L238: ( C59 /. 1 ) = ( ( C57 . C60 ) * ( C58 . C61 ) ) by L236 , L233;
L239: ( C59 . 1 ) = ( ( C57 . C60 ) * ( C58 . C61 ) ) by L236 , L238 , PARTFUN1:def 6
.= ( ( C57 . D44 ) * ( C58 . C61 ) ) by L211
.= ( ( C57 . D44 ) * ( C58 . D44 ) ) by L211;
L240: C59 = <* D47 *> by L239 , L230 , L232 , FINSEQ_1:40;
L241: ( Sum C59 ) = D47 by L240 , RLVECT_1:44;
thus L242: thesis by L241 , L211 , L231;
end;
L243: (ex B47 being (Polynomial of D42 , C50) st (B47 = ( C55 * C56 ) & ( B47 . ( {} ) ) = ( D46 . ( C55 * C56 ) ))) by L220;
thus L244: thesis by L243 , L226 , L227 , L228 , POLYNOM1:def 10;
end;
L245: D46 is  multiplicative by L225 , GROUP_6:def 6;
L246: (for B48 , B49 being (Element of D43) holds ( D46 . ( B48 + B49 ) ) = ( ( D46 . B48 ) + ( D46 . B49 ) ))
proof
let C62 , C63 being (Element of D43);
consider C64 being (Polynomial of D42 , C50) such that L247: C64 = C62 and L248: ( C64 . ( {} ) ) = ( D46 . C62 ) by L220;
consider C65 being (Polynomial of D42 , C50) such that L249: C65 = C63 and L250: ( C65 . ( {} ) ) = ( D46 . C63 ) by L220;
consider C66 being (Element of C50) such that L251: C64 = ( { ( EmptyBag D42 ) } --> C66 ) by L118;
L252: (ex B50 being (Polynomial of D42 , C50) st (B50 = ( C62 + C63 ) & ( B50 . ( {} ) ) = ( D46 . ( C62 + C63 ) ))) by L220;
consider C67 being (Element of C50) such that L253: C65 = ( { ( EmptyBag D42 ) } --> C67 ) by L118;
L254: ( EmptyBag D42 ) in { ( EmptyBag D42 ) } by TARSKI:def 1;
L255: ( C64 . ( {} ) ) = C66 by L254 , L214 , L251 , FUNCOP_1:7;
L256: ( ( C64 + C65 ) . ( {} ) ) = ( ( C64 . D44 ) + ( C65 . D44 ) ) by POLYNOM1:15
.= ( C66 + C67 ) by L214 , L254 , L255 , L253 , FUNCOP_1:7;
L257: ( C65 . ( {} ) ) = C67 by L214 , L254 , L253 , FUNCOP_1:7;
L258: ( ( D46 . C62 ) + ( D46 . C63 ) ) = ( C66 + C67 ) by L257 , L214 , L248 , L250 , L251 , L254 , FUNCOP_1:7;
thus L259: thesis by L258 , L247 , L249 , L252 , L256 , POLYNOM1:def 10;
end;
L260: D46 is  additive by L246 , VECTSP_1:def 20;
L261: ( C54 . D44 ) = ( C54 . ( EmptyBag D42 ) ) by L211
.= ( ( ( 0_ (D42 , C50) ) +* ( ( EmptyBag D42 ) .--> ( 1_ C50 ) ) ) . ( EmptyBag D42 ) ) by L224 , L208 , FUNCT_7:def 3
.= ( ( ( EmptyBag D42 ) .--> ( 1_ C50 ) ) . ( EmptyBag D42 ) ) by L210 , FUNCT_4:13
.= ( 1_ C50 ) by FUNCOP_1:72;
L262: D46 is  unity-preserving by L261 , L222 , L223 , GROUP_1:def 13;
L263: D46 is  RingHomomorphism by L262 , L260 , L245 , QUOFIELD:def 18;
L264: (for B51 being set holds (B51 in (the carrier of C50) implies B51 in ( rng D46 )))
proof
let C68 being set;
assume L265: C68 in (the carrier of C50);
reconsider D48 = C68 as (Element of C50) by L265;
set D49 = ( ( EmptyBag D42 ) .--> D48 );
reconsider D50 = D49 as Function;
L266: ( dom D50 ) = { ( EmptyBag D42 ) } by FUNCOP_1:13;
L267: (( rng D50 ) = { D48 } & ( dom D50 ) = ( Bags D42 )) by L266 , FUNCOP_1:8 , PRE_POLY:51 , TARSKI:def 1;
reconsider D51 = D50 as (Function of ( Bags D42 ) , (the carrier of C50)) by L267 , FUNCT_2:2;
reconsider D52 = D51 as (Function of ( Bags D42 ) , C50);
reconsider D53 = D52 as (Series of D42 , C50);
L268:
now
per cases ;
case L269: D48 = ( 0. C50 );
L270: ( Support D53 ) = ( {} )
proof
set D54 = the (Element of ( Support D53 ));
assume L271: ( Support D53 ) <> ( {} );
L272: D54 in ( Support D53 ) by L271;
L273: D54 is (bag of D42) by L272;
L274: ( D53 . D54 ) = ( D53 . ( EmptyBag D42 ) ) by L273 , L211 , L214
.= D48 by FUNCOP_1:72;
thus L275: thesis by L274 , L269 , L272 , POLYNOM1:def 3;
end;
thus L276: ( Support D53 ) is  finite by L270;
end;
case L277: D48 <> ( 0. C50 );
L278: (for B52 being set holds (B52 in { ( EmptyBag D42 ) } implies B52 in ( Support D53 )))
proof
let C69 being set;
assume L279: C69 in { ( EmptyBag D42 ) };
reconsider D55 = C69 as (Element of ( Bags D42 )) by L279;
L280: ( D53 . D55 ) = ( D53 . ( EmptyBag D42 ) ) by L279 , TARSKI:def 1
.= D48 by FUNCOP_1:72;
thus L281: thesis by L280 , L277 , POLYNOM1:def 3;
end;
L282: (for B53 being set holds (B53 in ( Support D53 ) implies B53 in { ( EmptyBag D42 ) }))
proof
let C70 being set;
assume L283: C70 in ( Support D53 );
reconsider D56 = C70 as (bag of D42) by L283;
L284: D56 = ( EmptyBag D42 ) by L211 , L214;
thus L285: thesis by L284 , TARSKI:def 1;
end;
thus L286: ( Support D53 ) is  finite by L282 , L278 , TARSKI:1;
end;
end;
reconsider D57 = D53 as (Polynomial of D42 , C50) by L268 , POLYNOM1:def 4;
reconsider D58 = D57 as (Element of D43) by POLYNOM1:def 10;
consider C71 being (Polynomial of D42 , C50) such that L288: C71 = D58 and L289: ( C71 . ( {} ) ) = ( D46 . D58 ) by L220;
L290: ( C71 . ( {} ) ) = ( D57 . ( EmptyBag D42 ) ) by L211 , L288
.= D48 by FUNCOP_1:72;
thus L291: thesis by L290 , L221 , L289 , FUNCT_1:3;
end;
L292: ( rng D46 ) c= (the carrier of C50) by RELAT_1:def 19;
L293: (for B54 being set holds (B54 in ( rng D46 ) implies B54 in (the carrier of C50))) by L292;
L294: ( rng D46 ) = (the carrier of C50) by L293 , L264 , TARSKI:1;
L295: D46 is  RingEpimorphism by L294 , L263 , QUOFIELD:def 19;
L296: (for B55 , B56 being set holds ((B55 in ( dom D46 ) & B56 in ( dom D46 ) & ( D46 . B55 ) = ( D46 . B56 )) implies B55 = B56))
proof
let C72 , C73 being set;
assume that
L297: (C72 in ( dom D46 ) & C73 in ( dom D46 ))
and
L298: ( D46 . C72 ) = ( D46 . C73 );
reconsider D59 = C72 , D60 = C73 as (Element of D43) by L297;
consider C74 being (Polynomial of D42 , C50) such that L299: (C74 = D59 & ( C74 . ( {} ) ) = ( D46 . D59 )) by L220;
consider C75 being (Polynomial of D42 , C50) such that L300: (C75 = D60 & ( C75 . ( {} ) ) = ( D46 . D60 )) by L220;
consider C76 being (Element of C50) such that L301: C75 = ( { ( EmptyBag D42 ) } --> C76 ) by L118;
L302: ( EmptyBag D42 ) in { ( EmptyBag D42 ) } by TARSKI:def 1;
L303: ( C75 . ( EmptyBag D42 ) ) = C76 by L302 , L301 , FUNCOP_1:7;
L304: ( C74 . ( {} ) ) = ( C74 . ( EmptyBag D42 ) ) by L211;
consider C77 being (Element of C50) such that L305: C74 = ( { ( EmptyBag D42 ) } --> C77 ) by L118;
L306: ( C74 . ( EmptyBag D42 ) ) = C77 by L305 , L302 , FUNCOP_1:7;
thus L307: thesis by L306 , L211 , L298 , L299 , L300 , L305 , L301 , L303 , L304;
end;
L308: D46 is  one-to-one by L296 , FUNCT_1:def 4;
L309: D46 is  RingMonomorphism by L308 , L263 , QUOFIELD:def 20;
L310: D46 is  RingIsomorphism by L309 , L295 , QUOFIELD:def 21;
thus L311: thesis by L310 , QUOFIELD:def 23;
end;
begin
definition
let C78 being set;
let C79 being non  empty ZeroStr;
let C80 being (Series of C78 , C79);
attr C80 is  monomial-like
means
:L312: (ex B57 being (bag of C78) st (for B58 being (bag of C78) holds (B58 <> B57 implies ( C80 . B58 ) = ( 0. C79 ))));
end;
registration
let C81 being set;
let C82 being non  empty ZeroStr;
cluster  monomial-like for (Series of C81 , C82);
existence
proof
set D61 = ( 0_ (C81 , C82) );
take D61;
L314: (for B59 being (bag of C81) holds (B59 <> ( EmptyBag C81 ) implies ( D61 . B59 ) = ( 0. C82 ))) by POLYNOM1:22;
thus L315: thesis by L314 , L312;
end;
end;
definition
let C83 being set;
let C84 being non  empty ZeroStr;
mode Monomial of C83 , C84
 is  monomial-like (Series of C83 , C84);
end;
registration
let C85 being set;
let C86 being non  empty ZeroStr;
cluster  monomial-like ->  finite-Support for (Series of C85 , C86);
coherence
proof
let C87 being (Series of C85 , C86);
assume L318: C87 is  monomial-like;
consider C88 being (bag of C85) such that L319: (for B60 being (bag of C85) holds (B60 <> C88 implies ( C87 . B60 ) = ( 0. C86 ))) by L318 , L312;
per cases ;
suppose L320: ( C87 . C88 ) = ( 0. C86 );

L321:
now
assume L322: ( Support C87 ) <> ( {} );
reconsider D62 = ( Support C87 ) as non  empty (Subset of ( Bags C85 )) by L322;
set D63 = the (Element of D62);
L323: ( C87 . D63 ) <> ( 0. C86 ) by POLYNOM1:def 3;
thus L324: contradiction by L323 , L319 , L320;
end;
thus L325: thesis by L321 , POLYNOM1:def 4;
end;
suppose L326: ( C87 . C88 ) <> ( 0. C86 );

L327:
now
let C89 being set;
assume L328: C89 in ( Support C87 );
reconsider D64 = C89 as (Element of ( Bags C85 )) by L328;
L329: ( C87 . D64 ) <> ( 0. C86 ) by L328 , POLYNOM1:def 3;
L330: D64 = C88 by L329 , L319;
thus L331: C89 in { C88 } by L330 , TARSKI:def 1;
end;
L332:
now
let C90 being set;
assume L333: C90 in { C88 };
L334: C90 = C88 by L333 , TARSKI:def 1;
reconsider D65 = C90 as (Element of ( Bags C85 )) by L334 , PRE_POLY:def 12;
L335: D65 in ( Support C87 ) by L326 , L334 , POLYNOM1:def 3;
thus L336: C90 in ( Support C87 ) by L335;
end;
L337: ( Support C87 ) = { C88 } by L332 , L327 , TARSKI:1;
thus L338: thesis by L337 , POLYNOM1:def 4;
end;
end;
end;
theorem
L341: (for B61 being set holds (for B62 being non  empty ZeroStr holds (for B63 being (Series of B61 , B62) holds (B63 is (Monomial of B61 , B62) iff (( Support B63 ) = ( {} ) or (ex B64 being (bag of B61) st ( Support B63 ) = { B64 }))))))
proof
let C91 being set;
let C92 being non  empty ZeroStr;
let C93 being (Series of C91 , C92);
L342:
now
assume L343: (ex B65 being (bag of C91) st ( Support C93 ) = { B65 });
consider C94 being (bag of C91) such that L344: ( Support C93 ) = { C94 } by L343;
L345: (for B66 being (bag of C91) holds (B66 <> C94 implies ( C93 . B66 ) = ( 0. C92 )))
proof
let C95 being (bag of C91);
assume L346: C95 <> C94;
assume L347: ( C93 . C95 ) <> ( 0. C92 );
reconsider D66 = C95 as (Element of ( Bags C91 )) by PRE_POLY:def 12;
L348: D66 in ( Support C93 ) by L347 , POLYNOM1:def 3;
thus L349: thesis by L348 , L344 , L346 , TARSKI:def 1;
end;
thus L350: C93 is (Monomial of C91 , C92) by L345 , L312;
end;
L351:
now
assume L352: C93 is (Monomial of C91 , C92);
consider C96 being (bag of C91) such that L353: (for B67 being (bag of C91) holds (B67 <> C96 implies ( C93 . B67 ) = ( 0. C92 ))) by L352 , L312;
L354:
now
per cases ;
case L355: ( C93 . C96 ) <> ( 0. C92 );
L356: (for B68 being set holds (B68 in { C96 } implies B68 in ( Support C93 )))
proof
let C97 being set;
assume L357: C97 in { C96 };
L358: C97 = C96 by L357 , TARSKI:def 1;
reconsider D67 = C97 as (Element of ( Bags C91 )) by L358 , PRE_POLY:def 12;
L359: ( C93 . D67 ) <> ( 0. C92 ) by L355 , L357 , TARSKI:def 1;
thus L360: thesis by L359 , POLYNOM1:def 3;
end;
L361: (for B69 being set holds (B69 in ( Support C93 ) implies B69 in { C96 }))
proof
let C98 being set;
assume L362: C98 in ( Support C93 );
reconsider D68 = C98 as (bag of C91) by L362;
L363: ( C93 . C98 ) <> ( 0. C92 ) by L362 , POLYNOM1:def 3;
L364: D68 = C96 by L363 , L353;
thus L365: thesis by L364 , TARSKI:def 1;
end;
L366: ( Support C93 ) = { C96 } by L361 , L356 , TARSKI:1;
thus L367: (ex B70 being (bag of C91) st ( Support C93 ) = { B70 }) by L366;
end;
case L368: ( C93 . C96 ) = ( 0. C92 );
thus L369: ( Support C93 ) = ( {} )
proof
assume L370: ( Support C93 ) <> ( {} );
reconsider D69 = ( Support C93 ) as non  empty (Subset of ( Bags C91 )) by L370;
set D70 = the (Element of D69);
L371: ( C93 . D70 ) <> ( 0. C92 ) by POLYNOM1:def 3;
thus L372: thesis by L371 , L353 , L368;
end;

end;
end;
thus L371: (( Support C93 ) = ( {} ) or (ex B71 being (bag of C91) st ( Support C93 ) = { B71 })) by L354;
end;
L372:
now
set D71 = the (bag of C91);
assume L373: ( Support C93 ) = ( {} );
L374: (for B72 being (bag of C91) holds (B72 <> D71 implies ( C93 . B72 ) = ( 0. C92 )))
proof
let C99 being (bag of C91);
assume L375: C99 <> D71;
reconsider D72 = C99 as (Element of ( Bags C91 )) by PRE_POLY:def 12;
assume L376: ( C93 . C99 ) <> ( 0. C92 );
L377: D72 in ( Support C93 ) by L376 , POLYNOM1:def 3;
thus L378: thesis by L377 , L373;
end;
thus L379: C93 is (Monomial of C91 , C92) by L374 , L312;
end;
thus L380: thesis by L372 , L342 , L351;
end;
definition
let C100 being set;
let C101 being non  empty ZeroStr;
let C102 being (Element of C101);
let C103 being (bag of C100);
func Monom (C102 , C103) -> (Monomial of C100 , C101) equals 
( ( 0_ (C100 , C101) ) +* (C103 , C102) );
coherence
proof
L381: ( dom ( C103 .--> C102 ) ) = { C103 } by FUNCOP_1:13;
L382: C103 in ( dom ( C103 .--> C102 ) ) by L381 , TARSKI:def 1;
set D73 = ( ( 0_ (C100 , C101) ) +* (C103 , C102) );
reconsider D74 = D73 as (Function of ( Bags C100 ) , (the carrier of C101));
reconsider D75 = D74 as (Function of ( Bags C100 ) , C101);
reconsider D76 = D75 as (Series of C100 , C101);
L383: C103 in ( Bags C100 ) by PRE_POLY:def 12;
L384: ( dom ( 0_ (C100 , C101) ) ) = ( dom ( ( Bags C100 ) --> ( 0. C101 ) ) ) by POLYNOM1:def 7
.= ( Bags C100 ) by FUNCOP_1:13;
L385: D76 = ( ( 0_ (C100 , C101) ) +* ( C103 .--> C102 ) ) by L384 , L383 , FUNCT_7:def 3;
L386: ( D76 . C103 ) = ( ( ( 0_ (C100 , C101) ) +* ( C103 .--> C102 ) ) . C103 ) by L384 , L383 , FUNCT_7:def 3
.= ( ( C103 .--> C102 ) . C103 ) by L382 , FUNCT_4:13
.= C102 by FUNCOP_1:72;
L387:
now
per cases ;
case L388: C102 <> ( 0. C101 );
L389: (for B73 being set holds (B73 in ( Support D76 ) implies B73 in { C103 }))
proof
let C104 being set;
assume L390: C104 in ( Support D76 );
assume L391: (not C104 in { C103 });
L392: (not C104 in ( dom ( C103 .--> C102 ) )) by L391;
reconsider D77 = C104 as (bag of C100) by L390;
L393: ( D76 . D77 ) = ( ( 0_ (C100 , C101) ) . D77 ) by L385 , L392 , FUNCT_4:11
.= ( 0. C101 ) by POLYNOM1:22;
thus L394: thesis by L393 , L390 , POLYNOM1:def 3;
end;
L395: C103 in ( Support D76 ) by L383 , L386 , L388 , POLYNOM1:def 3;
L396: (for B74 being set holds (B74 in { C103 } implies B74 in ( Support D76 ))) by L395 , TARSKI:def 1;
L397: ( Support D76 ) = { C103 } by L396 , L389 , TARSKI:1;
thus L398: thesis by L397 , L341;
end;
case L399: C102 = ( 0. C101 );
L400:
now
assume L401: ( Support D76 ) <> ( {} );
reconsider D78 = ( Support D76 ) as non  empty (Subset of ( Bags C100 )) by L401;
set D79 = the (Element of D78);
L402: ( D76 . D79 ) <> ( 0. C101 ) by POLYNOM1:def 3;
L403: (not D79 in { C103 }) by L402 , L386 , L399 , TARSKI:def 1;
L404: (not D79 in ( dom ( C103 .--> C102 ) )) by L403;
reconsider D80 = D79 as (bag of C100);
L405: ( D76 . D80 ) = ( ( 0_ (C100 , C101) ) . D80 ) by L385 , L404 , FUNCT_4:11
.= ( 0. C101 ) by POLYNOM1:22;
thus L406: contradiction by L405 , POLYNOM1:def 3;
end;
thus L407: thesis by L400 , L341;
end;
end;
thus L409: thesis by L387;
end;
end;
definition
let C105 being set;
let C106 being non  empty ZeroStr;
let C107 being (Monomial of C105 , C106);
func term C107 -> (bag of C105) means 
:L411: (( C107 . it ) <> ( 0. C106 ) or (( Support C107 ) = ( {} ) & it = ( EmptyBag C105 )));
existence
proof
consider C108 being (bag of C105) such that L412: (for B75 being (bag of C105) holds (B75 <> C108 implies ( C107 . B75 ) = ( 0. C106 ))) by L312;
L413:
now
per cases ;
case L414: ( C107 . C108 ) <> ( 0. C106 );
thus L415: thesis by L414;
end;
case L416: ( C107 . C108 ) = ( 0. C106 );
L417: ( Support C107 ) = ( {} )
proof
assume L418: ( Support C107 ) <> ( {} );
reconsider D81 = ( Support C107 ) as non  empty (Subset of ( Bags C105 )) by L418;
set D82 = the (Element of D81);
L419: ( C107 . D82 ) <> ( 0. C106 ) by POLYNOM1:def 3;
thus L420: thesis by L419 , L412 , L416;
end;
thus L421: thesis by L417;
end;
end;
thus L423: thesis by L413;
end;
uniqueness
proof
let C109 , C110 being (bag of C105);
assume L424: (( C107 . C109 ) <> ( 0. C106 ) or (( Support C107 ) = ( {} ) & C109 = ( EmptyBag C105 )));
consider C111 being (bag of C105) such that L425: (for B76 being (bag of C105) holds (B76 <> C111 implies ( C107 . B76 ) = ( 0. C106 ))) by L312;
assume L426: (( C107 . C110 ) <> ( 0. C106 ) or (( Support C107 ) = ( {} ) & C110 = ( EmptyBag C105 )));
L427:
now
per cases ;
case L428: ( C107 . C109 ) <> ( 0. C106 );
reconsider D83 = C109 as (Element of ( Bags C105 )) by PRE_POLY:def 12;
L429: D83 in ( Support C107 ) by L428 , POLYNOM1:def 3;
thus L430: C109 = C111 by L425 , L428
.= C110 by L426 , L425 , L429;
end;
case L431: ( C107 . C109 ) = ( 0. C106 );
L432:
now
per cases  by L426;
case L433: ( C107 . C110 ) <> ( 0. C106 );
reconsider D84 = C110 as (Element of ( Bags C105 )) by PRE_POLY:def 12;
L434: D84 in ( Support C107 ) by L433 , POLYNOM1:def 3;
thus L435: thesis by L434 , L424 , L431;
end;
case L436: (( Support C107 ) = ( {} ) & C110 = ( EmptyBag C105 ));
thus L437: thesis by L436 , L424 , L431;
end;
end;
thus L439: thesis by L432;
end;
end;
thus L441: thesis by L427;
end;
end;
definition
let C112 being set;
let C113 being non  empty ZeroStr;
let C114 being (Monomial of C112 , C113);
func coefficient C114 -> (Element of C113) equals 
( C114 . ( term C114 ) );
coherence;
end;
theorem
L444: (for B77 being set holds (for B78 being non  empty ZeroStr holds (for B79 being (Monomial of B77 , B78) holds (( Support B79 ) = ( {} ) or ( Support B79 ) = { ( term B79 ) }))))
proof
let C115 being set;
let C116 being non  empty ZeroStr;
let C117 being (Monomial of C115 , C116);
L445: ( term C117 ) is (Element of ( Bags C115 )) by PRE_POLY:def 12;
assume L446: ( Support C117 ) <> ( {} );
L447: ( C117 . ( term C117 ) ) <> ( 0. C116 ) by L446 , L411;
L448: ( term C117 ) in ( Support C117 ) by L447 , L445 , POLYNOM1:def 3;
L449: (ex B80 being (bag of C115) st ( Support C117 ) = { B80 }) by L446 , L341;
thus L450: thesis by L449 , L448 , TARSKI:def 1;
end;
theorem
L451: (for B81 being set holds (for B82 being non  empty ZeroStr holds (for B83 being (bag of B81) holds (( coefficient ( Monom (( 0. B82 ) , B83) ) ) = ( 0. B82 ) & ( term ( Monom (( 0. B82 ) , B83) ) ) = ( EmptyBag B81 )))))
proof
let C118 being set;
let C119 being non  empty ZeroStr;
let C120 being (bag of C118);
set D85 = ( ( 0_ (C118 , C119) ) +* (C120 , ( 0. C119 )) );
reconsider D86 = D85 as (Function of ( Bags C118 ) , (the carrier of C119));
reconsider D87 = D86 as (Function of ( Bags C118 ) , C119);
reconsider D88 = D87 as (Series of C118 , C119);
L452: C120 in ( Bags C118 ) by PRE_POLY:def 12;
L453: ( dom ( 0_ (C118 , C119) ) ) = ( dom ( ( Bags C118 ) --> ( 0. C119 ) ) ) by POLYNOM1:def 7
.= ( Bags C118 ) by FUNCOP_1:13;
L454: D88 = ( ( 0_ (C118 , C119) ) +* ( C120 .--> ( 0. C119 ) ) ) by L453 , L452 , FUNCT_7:def 3;
L455: ( dom ( C120 .--> ( 0. C119 ) ) ) = { C120 } by FUNCOP_1:13;
L456: C120 in ( dom ( C120 .--> ( 0. C119 ) ) ) by L455 , TARSKI:def 1;
L457: ( D88 . C120 ) = ( ( ( 0_ (C118 , C119) ) +* ( C120 .--> ( 0. C119 ) ) ) . C120 ) by L453 , L452 , FUNCT_7:def 3
.= ( ( C120 .--> ( 0. C119 ) ) . C120 ) by L456 , FUNCT_4:13
.= ( 0. C119 ) by FUNCOP_1:72;
L458:
now
let C121 being (bag of C118);
L459:
now
per cases ;
case L460: C121 = C120;
thus L461: ( D88 . C121 ) = ( 0. C119 ) by L460 , L457;
end;
case L462: C121 <> C120;
L463: (not C121 in ( dom ( C120 .--> ( 0. C119 ) ) )) by L462 , TARSKI:def 1;
thus L464: ( D88 . C121 ) = ( ( 0_ (C118 , C119) ) . C121 ) by L463 , L454 , FUNCT_4:11
.= ( 0. C119 ) by POLYNOM1:22;
end;
end;
thus L466: ( D88 . C121 ) = ( 0. C119 ) by L459;
end;
thus L467: ( coefficient ( Monom (( 0. C119 ) , C120) ) ) = ( 0. C119 ) by L458;
L468: ( ( Monom (( 0. C119 ) , C120) ) . ( term ( Monom (( 0. C119 ) , C120) ) ) ) = ( 0. C119 ) by L458;
thus L469: thesis by L468 , L411;
end;
theorem
L470: (for B84 being set holds (for B85 being non  empty ZeroStr holds (for B86 being (Element of B85) holds (for B87 being (bag of B84) holds ( coefficient ( Monom (B86 , B87) ) ) = B86))))
proof
let C122 being set;
let C123 being non  empty ZeroStr;
let C124 being (Element of C123);
let C125 being (bag of C122);
set D89 = ( ( 0_ (C122 , C123) ) +* (C125 , C124) );
reconsider D90 = D89 as (Function of ( Bags C122 ) , (the carrier of C123));
reconsider D91 = D90 as (Function of ( Bags C122 ) , C123);
reconsider D92 = D91 as (Series of C122 , C123);
L471: C125 in ( Bags C122 ) by PRE_POLY:def 12;
L472: ( dom ( C125 .--> C124 ) ) = { C125 } by FUNCOP_1:13;
L473: C125 in ( dom ( C125 .--> C124 ) ) by L472 , TARSKI:def 1;
L474: ( dom ( 0_ (C122 , C123) ) ) = ( dom ( ( Bags C122 ) --> ( 0. C123 ) ) ) by POLYNOM1:def 7
.= ( Bags C122 ) by FUNCOP_1:13;
L475: ( D92 . C125 ) = ( ( ( 0_ (C122 , C123) ) +* ( C125 .--> C124 ) ) . C125 ) by L474 , L471 , FUNCT_7:def 3
.= ( ( C125 .--> C124 ) . C125 ) by L473 , FUNCT_4:13
.= C124 by FUNCOP_1:72;
per cases ;
suppose L476: ( D92 . C125 ) <> ( 0. C123 );

thus L477: thesis by L476 , L475 , L411;
end;
suppose L478: ( D92 . C125 ) = ( 0. C123 );

thus L479: thesis by L478 , L475 , L451;
end;
end;
theorem
L481: (for B88 being set holds (for B89 being non  trivial ZeroStr holds (for B90 being non  zero (Element of B89) holds (for B91 being (bag of B88) holds ( term ( Monom (B90 , B91) ) ) = B91))))
proof
let C126 being set;
let C127 being non  trivial ZeroStr;
let C128 being non  zero (Element of C127);
let C129 being (bag of C126);
set D93 = ( ( 0_ (C126 , C127) ) +* (C129 , C128) );
reconsider D94 = D93 as (Function of ( Bags C126 ) , (the carrier of C127));
reconsider D95 = D94 as (Function of ( Bags C126 ) , C127);
reconsider D96 = D95 as (Series of C126 , C127);
L482: C129 in ( Bags C126 ) by PRE_POLY:def 12;
L483: ( dom ( C129 .--> C128 ) ) = { C129 } by FUNCOP_1:13;
L484: C129 in ( dom ( C129 .--> C128 ) ) by L483 , TARSKI:def 1;
L485: ( dom ( 0_ (C126 , C127) ) ) = ( dom ( ( Bags C126 ) --> ( 0. C127 ) ) ) by POLYNOM1:def 7
.= ( Bags C126 ) by FUNCOP_1:13;
L486: ( D96 . C129 ) = ( ( ( 0_ (C126 , C127) ) +* ( C129 .--> C128 ) ) . C129 ) by L485 , L482 , FUNCT_7:def 3
.= ( ( C129 .--> C128 ) . C129 ) by L484 , FUNCT_4:13
.= C128 by FUNCOP_1:72;
L487: ( D96 . C129 ) <> ( 0. C127 ) by L486;
thus L488: thesis by L487 , L411;
end;
theorem
L489: (for B92 being set holds (for B93 being non  empty ZeroStr holds (for B94 being (Monomial of B92 , B93) holds ( Monom (( coefficient B94 ) , ( term B94 )) ) = B94)))
proof
let C130 being set;
let C131 being non  empty ZeroStr;
let C132 being (Monomial of C130 , C131);
L490: (( dom C132 ) = ( Bags C130 ) & ( dom ( Monom (( coefficient C132 ) , ( term C132 )) ) ) = ( Bags C130 )) by FUNCT_2:def 1;
per cases  by L341;
suppose L491: ( Support C132 ) = ( {} );

L492:
now
L493: ( term C132 ) is (Element of ( Bags C130 )) by PRE_POLY:def 12;
assume L494: ( coefficient C132 ) <> ( 0. C131 );
thus L495: contradiction by L494 , L491 , L493 , POLYNOM1:def 3;
end;
L496: C132 = ( 0_ (C130 , C131) ) by L491 , L36;
set D97 = ( Monom (( coefficient C132 ) , ( term C132 )) );
L497: ( dom ( 0_ (C130 , C131) ) ) = ( dom ( ( Bags C130 ) --> ( 0. C131 ) ) ) by POLYNOM1:def 7
.= ( Bags C130 ) by FUNCOP_1:13;
L498: ( dom ( ( EmptyBag C130 ) .--> ( 0. C131 ) ) ) = { ( EmptyBag C130 ) } by FUNCOP_1:13;
L499: ( EmptyBag C130 ) in ( dom ( ( EmptyBag C130 ) .--> ( 0. C131 ) ) ) by L498 , TARSKI:def 1;
L500: ( term C132 ) = ( EmptyBag C130 ) by L491 , L411;
L501: ( D97 . ( EmptyBag C130 ) ) = ( ( ( 0_ (C130 , C131) ) +* ( ( EmptyBag C130 ) .--> ( 0. C131 ) ) ) . ( EmptyBag C130 ) ) by L500 , L492 , L497 , FUNCT_7:def 3
.= ( ( ( EmptyBag C130 ) .--> ( 0. C131 ) ) . ( EmptyBag C130 ) ) by L499 , FUNCT_4:13
.= ( 0. C131 ) by FUNCOP_1:72;
L502:
now
let C133 being set;
assume L503: C133 in ( Bags C130 );
reconsider D98 = C133 as (Element of ( Bags C130 )) by L503;
L504:
now
per cases ;
case L505: D98 = ( EmptyBag C130 );
thus L506: ( D97 . D98 ) = ( 0. C131 ) by L505 , L501;
end;
case L507: C133 <> ( EmptyBag C130 );
L508: (not D98 in ( dom ( ( EmptyBag C130 ) .--> ( 0. C131 ) ) )) by L507 , TARSKI:def 1;
L509: ( D97 . D98 ) = ( ( ( 0_ (C130 , C131) ) +* ( ( EmptyBag C130 ) .--> ( 0. C131 ) ) ) . D98 ) by L500 , L492 , L497 , FUNCT_7:def 3
.= ( ( 0_ (C130 , C131) ) . D98 ) by L508 , FUNCT_4:11;
thus L510: ( D97 . D98 ) = ( 0. C131 ) by L509 , POLYNOM1:22;
end;
end;
thus L512: ( C132 . C133 ) = ( D97 . C133 ) by L504 , L496 , POLYNOM1:22;
end;
thus L513: thesis by L502 , L490 , FUNCT_1:2;
end;
suppose L514: (ex B95 being (bag of C130) st ( Support C132 ) = { B95 });

consider C134 being (bag of C130) such that L515: ( Support C132 ) = { C134 } by L514;
set D99 = ( C132 . C134 );
L516: ( dom ( C134 .--> D99 ) ) = { C134 } by FUNCOP_1:13;
L517: C134 in ( dom ( C134 .--> D99 ) ) by L516 , TARSKI:def 1;
set D100 = ( Monom (( coefficient C132 ) , ( term C132 )) );
L518: ( dom ( 0_ (C130 , C131) ) ) = ( dom ( ( Bags C130 ) --> ( 0. C131 ) ) ) by POLYNOM1:def 7
.= ( Bags C130 ) by FUNCOP_1:13;
L519: C134 in ( Support C132 ) by L515 , TARSKI:def 1;
L520: D99 <> ( 0. C131 ) by L519 , POLYNOM1:def 3;
L521: ( term C132 ) = C134 by L520 , L411;
L522:
now
let C135 being set;
assume L523: C135 in ( Support ( Monom (( coefficient C132 ) , ( term C132 )) ) );
reconsider D101 = C135 as (Element of ( Bags C130 )) by L523;
L524:
now
assume L525: C135 <> C134;
L526: (not D101 in ( dom ( C134 .--> D99 ) )) by L525 , TARSKI:def 1;
L527: C134 in ( dom ( 0_ (C130 , C131) ) ) by L518 , PRE_POLY:def 12;
L528: ( D100 . D101 ) = ( ( ( 0_ (C130 , C131) ) +* ( C134 .--> D99 ) ) . D101 ) by L527 , L521 , FUNCT_7:def 3
.= ( ( 0_ (C130 , C131) ) . D101 ) by L526 , FUNCT_4:11;
thus L529: ( D100 . D101 ) = ( 0. C131 ) by L528 , POLYNOM1:22;
end;
thus L530: C135 in { C134 } by L524 , L523 , POLYNOM1:def 3 , TARSKI:def 1;
end;
L531: C134 in ( Bags C130 ) by PRE_POLY:def 12;
L532: ( D100 . C134 ) = ( ( ( 0_ (C130 , C131) ) +* ( C134 .--> D99 ) ) . C134 ) by L531 , L521 , L518 , FUNCT_7:def 3
.= ( ( C134 .--> D99 ) . C134 ) by L517 , FUNCT_4:13
.= D99 by FUNCOP_1:72;
L533:
now
let C136 being set;
assume L534: C136 in { C134 };
L535: C136 = C134 by L534 , TARSKI:def 1;
L536: ( D100 . C134 ) <> ( 0. C131 ) by L519 , L532 , POLYNOM1:def 3;
thus L537: C136 in ( Support ( Monom (( coefficient C132 ) , ( term C132 )) ) ) by L536 , L519 , L535 , POLYNOM1:def 3;
end;
L538: ( Support ( Monom (( coefficient C132 ) , ( term C132 )) ) ) = { C134 } by L533 , L522 , TARSKI:1;
L539:
now
let C137 being set;
assume L540: C137 in ( Bags C130 );
reconsider D102 = C137 as (Element of ( Bags C130 )) by L540;
L541:
now
per cases ;
case L542: C137 = C134;
thus L543: ( ( Monom (( coefficient C132 ) , ( term C132 )) ) . D102 ) = ( C132 . D102 ) by L542 , L532;
end;
case L544: C137 <> C134;
L545: (not C137 in ( Support ( Monom (( coefficient C132 ) , ( term C132 )) ) )) by L544 , L538 , TARSKI:def 1;
L546: (not C137 in ( Support C132 )) by L515 , L544 , TARSKI:def 1;
thus L547: ( C132 . D102 ) = ( 0. C131 ) by L546 , POLYNOM1:def 3
.= ( ( Monom (( coefficient C132 ) , ( term C132 )) ) . D102 ) by L545 , POLYNOM1:def 3;
end;
end;
thus L549: ( C132 . C137 ) = ( ( Monom (( coefficient C132 ) , ( term C132 )) ) . C137 ) by L541;
end;
thus L550: thesis by L539 , L490 , FUNCT_1:2;
end;
end;
theorem
L552: (for B96 being Ordinal holds (for B97 being  right_zeroed  add-associative  right_complementable  well-unital  distributive non  trivial doubleLoopStr holds (for B98 being (Monomial of B96 , B97) holds (for B99 being (Function of B96 , B97) holds ( eval (B98 , B99) ) = ( ( coefficient B98 ) * ( eval (( term B98 ) , B99) ) )))))
proof
let C138 being Ordinal;
let C139 being  right_zeroed  add-associative  right_complementable  well-unital  distributive non  trivial doubleLoopStr;
let C140 being (Monomial of C138 , C139);
let C141 being (Function of C138 , C139);
consider C142 being (FinSequence of (the carrier of C139)) such that L553: ( len C142 ) = ( len ( SgmX (( BagOrder C138 ) , ( Support C140 )) ) ) and L554: ( eval (C140 , C141) ) = ( Sum C142 ) and L555: (for B100 being (Element of ( NAT )) holds ((1 <= B100 & B100 <= ( len C142 )) implies ( C142 /. B100 ) = ( ( ( C140 * ( SgmX (( BagOrder C138 ) , ( Support C140 )) ) ) /. B100 ) * ( eval (( ( ( SgmX (( BagOrder C138 ) , ( Support C140 )) ) /. B100 ) @ ) , C141) ) ))) by POLYNOM2:def 4;
consider C143 being (bag of C138) such that L556: (for B101 being (bag of C138) holds (B101 <> C143 implies ( C140 . B101 ) = ( 0. C139 ))) by L312;
L557:
now
per cases ;
case L558: ( C140 . C143 ) <> ( 0. C139 );
L559: (for B102 being set holds (B102 in ( Support C140 ) implies B102 in { C143 }))
proof
let C144 being set;
assume L560: C144 in ( Support C140 );
assume L561: (not C144 in { C143 });
reconsider D103 = C144 as (Element of ( Bags C138 )) by L560;
L562: D103 <> C143 by L561 , TARSKI:def 1;
L563: ( C140 . D103 ) = ( 0. C139 ) by L562 , L556;
thus L564: thesis by L563 , L560 , POLYNOM1:def 3;
end;
L565: (C143 in ( Bags C138 ) & ( dom C140 ) = ( Bags C138 )) by FUNCT_2:def 1 , PRE_POLY:def 12;
reconsider D104 = ( Support C140 ) as  finite (Subset of ( Bags C138 ));
set D105 = ( SgmX (( BagOrder C138 ) , D104) );
L566: ( BagOrder C138 ) linearly_orders D104 by POLYNOM2:18;
L567: (for B103 being set holds (B103 in { C143 } implies B103 in ( Support C140 )))
proof
let C145 being set;
assume L568: C145 in { C143 };
L569: C145 = C143 by L568 , TARSKI:def 1;
reconsider D106 = C145 as (Element of ( Bags C138 )) by L569 , PRE_POLY:def 12;
L570: ( C140 . D106 ) <> ( 0. C139 ) by L558 , L568 , TARSKI:def 1;
thus L571: thesis by L570 , POLYNOM1:def 3;
end;
L572: ( Support C140 ) = { C143 } by L567 , L559 , TARSKI:1;
L573: ( rng D105 ) = { C143 } by L572 , L566 , PRE_POLY:def 2;
L574: C143 in ( rng D105 ) by L573 , TARSKI:def 1;
L575: 1 in ( dom D105 ) by L574 , FINSEQ_3:31;
L576: ( D105 . 1 ) in ( rng D105 ) by L575 , FUNCT_1:3;
L577: ( D105 . 1 ) = C143 by L576 , L573 , TARSKI:def 1;
L578: 1 in ( dom ( C140 * D105 ) ) by L577 , L575 , L565 , FUNCT_1:11;
L579: ( ( C140 * D105 ) /. 1 ) = ( ( C140 * D105 ) . 1 ) by L578 , PARTFUN1:def 6
.= ( C140 . ( D105 . 1 ) ) by L575 , FUNCT_1:13
.= ( C140 . C143 ) by L573 , L576 , TARSKI:def 1
.= ( coefficient C140 ) by L558 , L411;
L580: (for B104 being set holds (B104 in ( dom D105 ) implies B104 in { 1 }))
proof
let C146 being set;
assume L581: C146 in ( dom D105 );
assume L582: (not C146 in { 1 });
reconsider D107 = C146 as (Element of ( NAT )) by L581;
L583: ( D105 /. D107 ) = ( D105 . D107 ) by L581 , PARTFUN1:def 6;
L584: ( D105 /. D107 ) in ( rng D105 ) by L583 , L581 , FUNCT_1:3;
L585: D107 <> 1 by L582 , TARSKI:def 1;
L586: 1 < D107
proof
consider C147 being Nat such that L587: ( dom D105 ) = ( Seg C147 ) by FINSEQ_1:def 2;
L588: ( Seg C147 ) = { B105 where B105 is (Element of ( NAT )) : (1 <= B105 & B105 <= C147) } by FINSEQ_1:def 1;
L589: (ex B106 being (Element of ( NAT )) st (B106 = D107 & 1 <= B106 & B106 <= C147)) by L588 , L581 , L587;
thus L590: thesis by L589 , L585 , XXREAL_0:1;
end;
L591: ( D105 /. 1 ) = ( D105 . 1 ) by L574 , L581 , FINSEQ_3:31 , PARTFUN1:def 6;
L592: ( D105 /. 1 ) in ( rng D105 ) by L591 , L575 , FUNCT_1:3;
L593: ( D105 /. 1 ) = C143 by L592 , L573 , TARSKI:def 1
.= ( D105 /. D107 ) by L573 , L584 , TARSKI:def 1;
thus L594: thesis by L593 , L566 , L575 , L581 , L586 , PRE_POLY:def 2;
end;
L595: (for B107 being set holds (B107 in { 1 } implies B107 in ( dom D105 ))) by L575 , TARSKI:def 1;
L596: ( dom D105 ) = ( Seg 1 ) by L595 , L580 , FINSEQ_1:2 , TARSKI:1;
L597: 1 in ( dom D105 ) by L596 , FINSEQ_1:2 , TARSKI:def 1;
L598: ( D105 /. 1 ) = ( D105 . 1 ) by L575 , PARTFUN1:def 6;
L599: ( D105 /. 1 ) in ( rng D105 ) by L598 , L597 , FUNCT_1:3;
L600: ( D105 /. 1 ) = C143 by L599 , L573 , TARSKI:def 1;
L601: ( len D105 ) = 1 by L596 , FINSEQ_1:def 3;
L602: ( dom C142 ) = ( Seg ( len C142 ) ) by FINSEQ_1:def 3
.= ( dom D105 ) by L553 , FINSEQ_1:def 3;
L603: ( C142 . 1 ) = ( C142 /. 1 ) by L602 , L597 , PARTFUN1:def 6
.= ( ( ( C140 * D105 ) /. 1 ) * ( eval (( ( D105 /. 1 ) @ ) , C141) ) ) by L553 , L555 , L601
.= ( ( ( C140 * D105 ) /. 1 ) * ( eval (C143 , C141) ) ) by L600 , POLYNOM2:def 3;
L604: C142 = <* ( ( coefficient C140 ) * ( eval (C143 , C141) ) ) *> by L603 , L553 , L601 , L579 , FINSEQ_1:40;
thus L605: ( eval (C140 , C141) ) = ( ( coefficient C140 ) * ( eval (C143 , C141) ) ) by L604 , L554 , RLVECT_1:44
.= ( ( coefficient C140 ) * ( eval (( term C140 ) , C141) ) ) by L558 , L411;
end;
case L606: ( C140 . C143 ) = ( 0. C139 );
L607: ( Support C140 ) = ( {} )
proof
assume L608: ( Support C140 ) <> ( {} );
reconsider D108 = ( Support C140 ) as non  empty (Subset of ( Bags C138 )) by L608;
set D109 = the (Element of D108);
L609: ( C140 . D109 ) <> ( 0. C139 ) by POLYNOM1:def 3;
thus L610: thesis by L609 , L556 , L606;
end;
L611: (( term C140 ) = ( EmptyBag C138 ) & ( C140 . ( EmptyBag C138 ) ) = ( 0. C139 )) by L607 , L411 , POLYNOM1:def 3;
L612: ( ( coefficient C140 ) * ( eval (( term C140 ) , C141) ) ) = ( 0. C139 ) by L611 , VECTSP_1:7;
consider C148 being (FinSequence of (the carrier of C139)) such that L613: ( len C148 ) = ( len ( SgmX (( BagOrder C138 ) , ( Support C140 )) ) ) and L614: ( eval (C140 , C141) ) = ( Sum C148 ) and L615: (for B108 being (Element of ( NAT )) holds ((1 <= B108 & B108 <= ( len C148 )) implies ( C148 /. B108 ) = ( ( ( C140 * ( SgmX (( BagOrder C138 ) , ( Support C140 )) ) ) /. B108 ) * ( eval (( ( ( SgmX (( BagOrder C138 ) , ( Support C140 )) ) /. B108 ) @ ) , C141) ) ))) by POLYNOM2:def 4;
L616: ( BagOrder C138 ) linearly_orders ( Support C140 ) by POLYNOM2:18;
L617: ( rng ( SgmX (( BagOrder C138 ) , ( Support C140 )) ) ) = ( {} ) by L616 , L607 , PRE_POLY:def 2;
L618: ( SgmX (( BagOrder C138 ) , ( Support C140 )) ) = ( {} ) by L617 , RELAT_1:41;
L619: C148 = ( <*> (the carrier of C139) ) by L618 , L613;
thus L620: thesis by L619 , L612 , L614 , RLVECT_1:43;
end;
end;
thus L622: thesis by L557;
end;
theorem
L623: (for B109 being Ordinal holds (for B110 being  right_zeroed  add-associative  right_complementable  well-unital  distributive non  trivial doubleLoopStr holds (for B111 being (Element of B110) holds (for B112 being (bag of B109) holds (for B113 being (Function of B109 , B110) holds ( eval (( Monom (B111 , B112) ) , B113) ) = ( B111 * ( eval (B112 , B113) ) ))))))
proof
let C149 being Ordinal;
let C150 being  right_zeroed  add-associative  right_complementable  well-unital  distributive non  trivial doubleLoopStr;
let C151 being (Element of C150);
let C152 being (bag of C149);
let C153 being (Function of C149 , C150);
set D110 = ( Monom (C151 , C152) );
L624:
now
per cases ;
case L625: C151 <> ( 0. C150 );
L626: C151 is non  zero by L625 , STRUCT_0:def 12;
thus L627: ( eval (D110 , C153) ) = ( ( coefficient D110 ) * ( eval (( term D110 ) , C153) ) ) by L552
.= ( C151 * ( eval (( term D110 ) , C153) ) ) by L470
.= ( C151 * ( eval (C152 , C153) ) ) by L626 , L481;
end;
case L628: C151 = ( 0. C150 );
L629: (for B114 being (bag of C149) holds ( D110 . B114 ) = ( 0. C150 ))
proof
let C154 being (bag of C149);
L630:
now
per cases ;
case L631: C154 = C152;
L632: C152 in ( Bags C149 ) by PRE_POLY:def 12;
L633: ( dom ( C152 .--> C151 ) ) = { C152 } by FUNCOP_1:13;
L634: C152 in ( dom ( C152 .--> C151 ) ) by L633 , TARSKI:def 1;
L635: ( dom ( 0_ (C149 , C150) ) ) = ( dom ( ( Bags C149 ) --> ( 0. C150 ) ) ) by POLYNOM1:def 7
.= ( Bags C149 ) by FUNCOP_1:13;
L636: D110 = ( ( 0_ (C149 , C150) ) +* ( C152 .--> C151 ) ) by L635 , L632 , FUNCT_7:def 3;
thus L637: ( D110 . C154 ) = ( ( C152 .--> C151 ) . C152 ) by L636 , L631 , L634 , FUNCT_4:13
.= ( 0. C150 ) by L628 , FUNCOP_1:72;
end;
case L638: C154 <> C152;
thus L639: ( D110 . C154 ) = ( ( 0_ (C149 , C150) ) . C154 ) by L638 , FUNCT_7:32
.= ( 0. C150 ) by POLYNOM1:22;
end;
end;
thus L641: thesis by L630;
end;
L642: ( D110 . ( term D110 ) ) = ( 0. C150 ) by L629;
thus L643: ( eval (D110 , C153) ) = ( ( coefficient D110 ) * ( eval (( term D110 ) , C153) ) ) by L552
.= ( 0. C150 ) by L642 , VECTSP_1:7
.= ( C151 * ( eval (C152 , C153) ) ) by L628 , VECTSP_1:7;
end;
end;
thus L645: thesis by L624;
end;
begin
definition
let C155 being set;
let C156 being non  empty ZeroStr;
let C157 being (Series of C155 , C156);
attr C157 is  Constant
means
:L646: (for B115 being (bag of C155) holds (B115 <> ( EmptyBag C155 ) implies ( C157 . B115 ) = ( 0. C156 )));
end;
registration
let C158 being set;
let C159 being non  empty ZeroStr;
cluster  Constant for (Series of C158 , C159);
existence
proof
set D111 = ( 0_ (C158 , C159) );
take D111;
L648: (for B116 being (bag of C158) holds (B116 <> ( EmptyBag C158 ) implies ( D111 . B116 ) = ( 0. C159 ))) by POLYNOM1:22;
thus L649: thesis by L648 , L646;
end;
end;
definition
let C160 being set;
let C161 being non  empty ZeroStr;
mode ConstPoly of C160 , C161
 is  Constant (Series of C160 , C161);
end;
registration
let C162 being set;
let C163 being non  empty ZeroStr;
cluster  Constant ->  monomial-like for (Series of C162 , C163);
coherence
proof
let C164 being (Series of C162 , C163);
assume L652: C164 is  Constant;
L653: (for B117 being (bag of C162) holds (B117 <> ( EmptyBag C162 ) implies ( C164 . B117 ) = ( 0. C163 ))) by L652 , L646;
thus L654: thesis by L653 , L312;
end;
end;
theorem
L656: (for B118 being set holds (for B119 being non  empty ZeroStr holds (for B120 being (Series of B118 , B119) holds (B120 is (ConstPoly of B118 , B119) iff (B120 = ( 0_ (B118 , B119) ) or ( Support B120 ) = { ( EmptyBag B118 ) })))))
proof
let C165 being set;
let C166 being non  empty ZeroStr;
let C167 being (Series of C165 , C166);
L657:
now
assume L658: C167 is (ConstPoly of C165 , C166);
L659: (for B121 being set holds (B121 in ( Support C167 ) implies B121 in { ( EmptyBag C165 ) }))
proof
let C168 being set;
assume L660: C168 in ( Support C167 );
reconsider D112 = C168 as (Element of ( Bags C165 )) by L660;
reconsider D113 = D112 as (bag of C165);
L661: ( C167 . D113 ) <> ( 0. C166 ) by L660 , POLYNOM1:def 3;
L662: D113 = ( EmptyBag C165 ) by L661 , L658 , L646;
thus L663: thesis by L662 , TARSKI:def 1;
end;
thus L664: (( Support C167 ) = { ( EmptyBag C165 ) } or C167 = ( 0_ (C165 , C166) ))
proof
assume L665: (not ( Support C167 ) = { ( EmptyBag C165 ) });
L666: (not ( EmptyBag C165 ) in ( Support C167 ))
proof
assume L667: ( EmptyBag C165 ) in ( Support C167 );
L668: (for B122 being set holds (B122 in { ( EmptyBag C165 ) } implies B122 in ( Support C167 ))) by L667 , TARSKI:def 1;
thus L669: thesis by L668 , L659 , L665 , TARSKI:1;
end;
L670: ( Support C167 ) = ( {} )
proof
set D114 = the (Element of ( Support C167 ));
assume L671: ( Support C167 ) <> ( {} );
L672: (D114 in ( Support C167 ) & D114 in { ( EmptyBag C165 ) }) by L671 , L659;
thus L673: thesis by L672 , L666 , TARSKI:def 1;
end;
L674: (for B123 being (bag of C165) holds ( C167 . B123 ) = ( 0. C166 ))
proof
let C169 being (bag of C165);
L675: C169 is (Element of ( Bags C165 )) by PRE_POLY:def 12;
assume L676: ( C167 . C169 ) <> ( 0. C166 );
thus L677: thesis by L676 , L670 , L675 , POLYNOM1:def 3;
end;
L678: (for B124 being set holds (B124 in ( rng C167 ) implies B124 in { ( 0. C166 ) }))
proof
let C170 being set;
assume L679: C170 in ( rng C167 );
consider C171 being set such that L680: C171 in ( dom C167 ) and L681: ( C167 . C171 ) = C170 by L679 , FUNCT_1:def 3;
L682: C171 is (bag of C165) by L680;
L683: C170 = ( 0. C166 ) by L682 , L674 , L681;
thus L684: thesis by L683 , TARSKI:def 1;
end;
L685: ( dom C167 ) = ( Bags C165 ) by FUNCT_2:def 1;
L686: (for B125 being set holds (B125 in { ( 0. C166 ) } implies B125 in ( rng C167 )))
proof
set D115 = the (bag of C165);
let C172 being set;
assume L687: C172 in { ( 0. C166 ) };
L688: C172 = ( 0. C166 ) by L687 , TARSKI:def 1;
L689: ( C167 . D115 ) = C172 by L688 , L674;
L690: D115 in ( dom C167 ) by L685 , PRE_POLY:def 12;
thus L691: thesis by L690 , L689 , FUNCT_1:def 3;
end;
L692: ( rng C167 ) = { ( 0. C166 ) } by L686 , L678 , TARSKI:1;
L693: C167 = ( ( Bags C165 ) --> ( 0. C166 ) ) by L692 , L685 , FUNCOP_1:9;
thus L694: thesis by L693 , POLYNOM1:def 7;
end;

end;
L665:
now
assume L666: (C167 = ( 0_ (C165 , C166) ) or ( Support C167 ) = { ( EmptyBag C165 ) });
per cases  by L666;
suppose L667: C167 = ( 0_ (C165 , C166) );

L668: (for B126 being (bag of C165) holds (B126 <> ( EmptyBag C165 ) implies ( C167 . B126 ) = ( 0. C166 ))) by L667 , POLYNOM1:22;
thus L669: C167 is (ConstPoly of C165 , C166) by L668 , L646;
end;
suppose L670: ( Support C167 ) = { ( EmptyBag C165 ) };

L671: (for B127 being (bag of C165) holds (B127 <> ( EmptyBag C165 ) implies ( C167 . B127 ) = ( 0. C166 )))
proof
let C173 being (bag of C165);
assume L672: C173 <> ( EmptyBag C165 );
reconsider D116 = C173 as (Element of ( Bags C165 )) by PRE_POLY:def 12;
L673: (not D116 in ( Support C167 )) by L670 , L672 , TARSKI:def 1;
thus L674: thesis by L673 , POLYNOM1:def 3;
end;
thus L675: C167 is (ConstPoly of C165 , C166) by L671 , L646;
end;
end;
thus L677: thesis by L665 , L657;
end;
registration
let C174 being set;
let C175 being non  empty ZeroStr;
cluster ( 0_ (C174 , C175) ) ->  Constant;
coherence
proof
L678: (for B128 being (bag of C174) holds (B128 <> ( EmptyBag C174 ) implies ( ( 0_ (C174 , C175) ) . B128 ) = ( 0. C175 ))) by POLYNOM1:22;
thus L679: thesis by L678 , L646;
end;
end;
registration
let C176 being set;
let C177 being  well-unital non  empty doubleLoopStr;
cluster ( 1_ (C176 , C177) ) ->  Constant;
coherence
proof
L681: (for B129 being (bag of C176) holds (B129 <> ( EmptyBag C176 ) implies ( ( 1_ (C176 , C177) ) . B129 ) = ( 0. C177 ))) by POLYNOM1:25;
thus L682: thesis by L681 , L646;
end;
end;
L684: (for B130 being set holds (for B131 being non  empty ZeroStr holds (for B132 being (ConstPoly of B130 , B131) holds (( term B132 ) = ( EmptyBag B130 ) & ( coefficient B132 ) = ( B132 . ( EmptyBag B130 ) )))))
proof
let C178 being set;
let C179 being non  empty ZeroStr;
let C180 being (ConstPoly of C178 , C179);
set D117 = ( EmptyBag C178 );
L685:
now
per cases ;
case L686: ( C180 . D117 ) <> ( 0. C179 );
thus L687: ( term C180 ) = ( EmptyBag C178 ) by L686 , L411;
end;
case L688: ( C180 . D117 ) = ( 0. C179 );
L689: ( Support C180 ) = ( {} )
proof
set D118 = the (Element of ( Support C180 ));
assume L690: ( Support C180 ) <> ( {} );
L691: D118 in ( Support C180 ) by L690;
reconsider D119 = D118 as (Element of ( Bags C178 )) by L691;
L692: ( C180 . D119 ) <> ( 0. C179 ) by L690 , POLYNOM1:def 3;
thus L693: thesis by L692 , L688 , L646;
end;
thus L694: ( term C180 ) = ( EmptyBag C178 ) by L689 , L411;
end;
end;
thus L696: ( term C180 ) = ( EmptyBag C178 ) by L685;
thus L697: thesis by L685;
end;
theorem
L698: (for B133 being set holds (for B134 being non  empty ZeroStr holds (for B135 being (ConstPoly of B133 , B134) holds (( Support B135 ) = ( {} ) or ( Support B135 ) = { ( EmptyBag B133 ) }))))
proof
let C181 being set;
let C182 being non  empty ZeroStr;
let C183 being (ConstPoly of C181 , C182);
assume L699: ( Support C183 ) <> ( {} );
thus L700: ( Support C183 ) = { ( term C183 ) } by L699 , L444
.= { ( EmptyBag C181 ) } by L684;
end;
theorem
L701: (for B136 being set holds (for B137 being non  empty ZeroStr holds (for B138 being (ConstPoly of B136 , B137) holds (( term B138 ) = ( EmptyBag B136 ) & ( coefficient B138 ) = ( B138 . ( EmptyBag B136 ) ))))) by L684;
definition
let C184 being set;
let C185 being non  empty ZeroStr;
let C186 being (Element of C185);
func C186 | (C184 , C185) -> (Series of C184 , C185) equals 
( ( 0_ (C184 , C185) ) +* (( EmptyBag C184 ) , C186) );
coherence;
end;
registration
let C187 being set;
let C188 being non  empty ZeroStr;
let C189 being (Element of C188);
cluster ( C189 | (C187 , C188) ) ->  Constant;
coherence
proof
set D120 = ( 0_ (C187 , C188) );
set D121 = ( D120 +* (( EmptyBag C187 ) , C189) );
reconsider D122 = D121 as (Function of ( Bags C187 ) , (the carrier of C188));
reconsider D123 = D122 as (Function of ( Bags C187 ) , C188);
reconsider D124 = D123 as (Series of C187 , C188);
L703:
now
let C190 being (bag of C187);
L704: ( dom D120 ) = ( dom ( ( Bags C187 ) --> ( 0. C188 ) ) ) by POLYNOM1:def 7
.= ( Bags C187 ) by FUNCOP_1:13;
L705: D124 = ( ( 0_ (C187 , C188) ) +* ( ( EmptyBag C187 ) .--> C189 ) ) by L704 , FUNCT_7:def 3;
assume L706: C190 <> ( EmptyBag C187 );
L707: (not C190 in ( dom ( ( EmptyBag C187 ) .--> C189 ) )) by L706 , TARSKI:def 1;
thus L708: ( D124 . C190 ) = ( ( 0_ (C187 , C188) ) . C190 ) by L707 , L705 , FUNCT_4:11
.= ( 0. C188 ) by POLYNOM1:22;
end;
thus L709: thesis by L703 , L646;
end;
end;
L711: (for B139 being set holds (for B140 being non  empty ZeroStr holds ( ( 0. B140 ) | (B139 , B140) ) = ( 0_ (B139 , B140) )))
proof
let C191 being set;
let C192 being non  empty ZeroStr;
set D125 = ( ( 0. C192 ) | (C191 , C192) );
set D126 = ( 0_ (C191 , C192) );
L712:
now
set D127 = ( ( 0_ (C191 , C192) ) +* (( EmptyBag C191 ) , ( 0. C192 )) );
let C193 being set;
reconsider D128 = D127 as (Function of ( Bags C191 ) , (the carrier of C192));
reconsider D129 = D128 as (Function of ( Bags C191 ) , C192);
reconsider D130 = D129 as (Series of C191 , C192);
assume L713: C193 in ( Bags C191 );
reconsider D131 = C193 as (bag of C191) by L713;
L714: ( dom ( 0_ (C191 , C192) ) ) = ( dom ( ( Bags C191 ) --> ( 0. C192 ) ) ) by POLYNOM1:def 7
.= ( Bags C191 ) by FUNCOP_1:13;
L715: D130 = ( ( 0_ (C191 , C192) ) +* ( ( EmptyBag C191 ) .--> ( 0. C192 ) ) ) by L714 , FUNCT_7:def 3;
L716: ( dom ( ( EmptyBag C191 ) .--> ( 0. C192 ) ) ) = { ( EmptyBag C191 ) } by FUNCOP_1:13;
L717: ( EmptyBag C191 ) in ( dom ( ( EmptyBag C191 ) .--> ( 0. C192 ) ) ) by L716 , TARSKI:def 1;
L718: ( D130 . ( EmptyBag C191 ) ) = ( ( ( 0_ (C191 , C192) ) +* ( ( EmptyBag C191 ) .--> ( 0. C192 ) ) ) . ( EmptyBag C191 ) ) by L714 , FUNCT_7:def 3
.= ( ( ( EmptyBag C191 ) .--> ( 0. C192 ) ) . ( EmptyBag C191 ) ) by L717 , FUNCT_4:13
.= ( 0. C192 ) by FUNCOP_1:72;
per cases ;
suppose L719: D131 = ( EmptyBag C191 );

thus L720: ( D125 . C193 ) = ( D126 . C193 ) by L719 , L718 , POLYNOM1:22;
end;
suppose L721: D131 <> ( EmptyBag C191 );

L722: (not D131 in ( dom ( ( EmptyBag C191 ) .--> ( 0. C192 ) ) )) by L721 , TARSKI:def 1;
thus L723: ( D125 . C193 ) = ( D126 . C193 ) by L722 , L715 , FUNCT_4:11;
end;
end;
L725: (( Bags C191 ) = ( dom D125 ) & ( Bags C191 ) = ( dom D126 )) by FUNCT_2:def 1;
thus L726: thesis by L725 , L712 , FUNCT_1:2;
end;
theorem
L727: (for B141 being set holds (for B142 being non  empty ZeroStr holds (for B143 being (Series of B141 , B142) holds (B143 is (ConstPoly of B141 , B142) iff (ex B144 being (Element of B142) st B143 = ( B144 | (B141 , B142) ))))))
proof
let C194 being set;
let C195 being non  empty ZeroStr;
let C196 being (Series of C194 , C195);
L728:
now
assume L729: C196 is (ConstPoly of C194 , C195);
L730:
now
per cases  by L729 , L656;
case L731: C196 = ( 0_ (C194 , C195) );
L732: C196 = ( ( 0. C195 ) | (C194 , C195) ) by L731 , L711;
thus L733: (ex B145 being (Element of C195) st C196 = ( B145 | (C194 , C195) )) by L732;
end;
case L734: ( Support C196 ) = { ( EmptyBag C194 ) };
set D132 = ( ( 0_ (C194 , C195) ) +* (( EmptyBag C194 ) , ( C196 . ( EmptyBag C194 ) )) );
L735:
now
let C197 being set;
assume L736: C197 in ( Bags C194 );
reconsider D133 = C197 as (bag of C194) by L736;
L737: ( dom ( 0_ (C194 , C195) ) ) = ( dom ( ( Bags C194 ) --> ( 0. C195 ) ) ) by POLYNOM1:def 7
.= ( Bags C194 ) by FUNCOP_1:13;
L738: D132 = ( ( 0_ (C194 , C195) ) +* ( ( EmptyBag C194 ) .--> ( C196 . ( EmptyBag C194 ) ) ) ) by L737 , FUNCT_7:def 3;
L739: ( dom ( ( EmptyBag C194 ) .--> ( C196 . ( EmptyBag C194 ) ) ) ) = { ( EmptyBag C194 ) } by FUNCOP_1:13;
L740: ( EmptyBag C194 ) in ( dom ( ( EmptyBag C194 ) .--> ( C196 . ( EmptyBag C194 ) ) ) ) by L739 , TARSKI:def 1;
L741: ( D132 . ( EmptyBag C194 ) ) = ( ( ( 0_ (C194 , C195) ) +* ( ( EmptyBag C194 ) .--> ( C196 . ( EmptyBag C194 ) ) ) ) . ( EmptyBag C194 ) ) by L737 , FUNCT_7:def 3
.= ( ( ( EmptyBag C194 ) .--> ( C196 . ( EmptyBag C194 ) ) ) . ( EmptyBag C194 ) ) by L740 , FUNCT_4:13
.= ( C196 . ( EmptyBag C194 ) ) by FUNCOP_1:72;
L742:
now
per cases ;
case L743: D133 = ( EmptyBag C194 );
thus L744: ( C196 . C197 ) = ( D132 . C197 ) by L743 , L741;
end;
case L745: D133 <> ( EmptyBag C194 );
L746: D133 is (Element of ( Bags C194 )) by PRE_POLY:def 12;
L747: (not D133 in ( Support C196 )) by L734 , L745 , TARSKI:def 1;
L748: ( C196 . D133 ) = ( 0. C195 ) by L747 , L746 , POLYNOM1:def 3;
L749: (not D133 in ( dom ( ( EmptyBag C194 ) .--> ( C196 . ( EmptyBag C194 ) ) ) )) by L745 , TARSKI:def 1;
L750: ( D132 . D133 ) = ( ( 0_ (C194 , C195) ) . D133 ) by L749 , L738 , FUNCT_4:11;
thus L751: ( C196 . C197 ) = ( D132 . C197 ) by L750 , L748 , POLYNOM1:22;
end;
end;
thus L753: ( C196 . C197 ) = ( D132 . C197 ) by L742;
end;
L754: ( Bags C194 ) = ( dom D132 ) by FUNCT_2:def 1;
L755: (D132 = ( ( C196 . ( EmptyBag C194 ) ) | (C194 , C195) ) & ( Bags C194 ) = ( dom C196 )) by FUNCT_2:def 1;
thus L756: (ex B146 being (Element of C195) st C196 = ( B146 | (C194 , C195) )) by L755 , L754 , L735 , FUNCT_1:2;
end;
end;
thus L758: (ex B147 being (Element of C195) st C196 = ( B147 | (C194 , C195) )) by L730;
end;
thus L759: thesis by L728;
end;
theorem
L760: (for B148 being set holds (for B149 being non  empty multLoopStr_0 holds (for B150 being (Element of B149) holds (( ( B150 | (B148 , B149) ) . ( EmptyBag B148 ) ) = B150 & (for B151 being (bag of B148) holds (B151 <> ( EmptyBag B148 ) implies ( ( B150 | (B148 , B149) ) . B151 ) = ( 0. B149 )))))))
proof
let C198 being set;
let C199 being non  empty multLoopStr_0;
let C200 being (Element of C199);
set D134 = ( 0_ (C198 , C199) );
L761: D134 = ( ( Bags C198 ) --> ( 0. C199 ) ) by POLYNOM1:def 7;
L762: ( dom D134 ) = ( Bags C198 ) by L761 , FUNCOP_1:13;
thus L763: ( ( C200 | (C198 , C199) ) . ( EmptyBag C198 ) ) = C200 by L762 , FUNCT_7:31;
let C201 being (bag of C198);
L764: C201 in ( Bags C198 ) by PRE_POLY:def 12;
assume L765: C201 <> ( EmptyBag C198 );
thus L766: ( ( C200 | (C198 , C199) ) . C201 ) = ( D134 . C201 ) by L765 , FUNCT_7:32
.= ( 0. C199 ) by L761 , L764 , FUNCOP_1:7;
end;
theorem
L767: (for B152 being set holds (for B153 being non  empty ZeroStr holds ( ( 0. B153 ) | (B152 , B153) ) = ( 0_ (B152 , B153) ))) by L711;
theorem
L768: (for B154 being set holds (for B155 being  well-unital non  empty multLoopStr_0 holds ( ( 1. B155 ) | (B154 , B155) ) = ( 1_ (B154 , B155) )))
proof
let C202 being set;
let C203 being  well-unital non  empty multLoopStr_0;
set D135 = ( ( 1. C203 ) | (C202 , C203) );
set D136 = ( 1_ (C202 , C203) );
L769:
now
set D137 = ( ( 0_ (C202 , C203) ) +* (( EmptyBag C202 ) , ( 1. C203 )) );
let C204 being set;
reconsider D138 = D137 as (Function of ( Bags C202 ) , (the carrier of C203));
reconsider D139 = D138 as (Function of ( Bags C202 ) , C203);
reconsider D140 = D139 as (Series of C202 , C203);
assume L770: C204 in ( Bags C202 );
reconsider D141 = C204 as (bag of C202) by L770;
L771: ( dom ( 0_ (C202 , C203) ) ) = ( dom ( ( Bags C202 ) --> ( 0. C203 ) ) ) by POLYNOM1:def 7
.= ( Bags C202 ) by FUNCOP_1:13;
L772: D140 = ( ( 0_ (C202 , C203) ) +* ( ( EmptyBag C202 ) .--> ( 1. C203 ) ) ) by L771 , FUNCT_7:def 3;
L773: ( dom ( ( EmptyBag C202 ) .--> ( 1. C203 ) ) ) = { ( EmptyBag C202 ) } by FUNCOP_1:13;
L774: ( EmptyBag C202 ) in ( dom ( ( EmptyBag C202 ) .--> ( 1. C203 ) ) ) by L773 , TARSKI:def 1;
L775: ( D140 . ( EmptyBag C202 ) ) = ( ( ( 0_ (C202 , C203) ) +* ( ( EmptyBag C202 ) .--> ( 1. C203 ) ) ) . ( EmptyBag C202 ) ) by L771 , FUNCT_7:def 3
.= ( ( ( EmptyBag C202 ) .--> ( 1. C203 ) ) . ( EmptyBag C202 ) ) by L774 , FUNCT_4:13
.= ( 1. C203 ) by FUNCOP_1:72;
per cases ;
suppose L776: D141 = ( EmptyBag C202 );

thus L777: ( D135 . C204 ) = ( D136 . C204 ) by L776 , L775 , POLYNOM1:25;
end;
suppose L778: D141 <> ( EmptyBag C202 );

L779: (not D141 in ( dom ( ( EmptyBag C202 ) .--> ( 1. C203 ) ) )) by L778 , TARSKI:def 1;
L780: ( D140 . D141 ) = ( ( 0_ (C202 , C203) ) . D141 ) by L779 , L772 , FUNCT_4:11
.= ( 0. C203 ) by POLYNOM1:22
.= ( D136 . D141 ) by L778 , POLYNOM1:25;
thus L781: ( D135 . C204 ) = ( D136 . C204 ) by L780;
end;
end;
L783: (( Bags C202 ) = ( dom D135 ) & ( Bags C202 ) = ( dom D136 )) by FUNCT_2:def 1;
thus L784: thesis by L783 , L769 , FUNCT_1:2;
end;
theorem
L785: (for B156 being set holds (for B157 being non  empty ZeroStr holds (for B158 , B159 being (Element of B157) holds (( B158 | (B156 , B157) ) = ( B159 | (B156 , B157) ) iff B158 = B159))))
proof
let C205 being set;
let C206 being non  empty ZeroStr;
let C207 , C208 being (Element of C206);
set D142 = ( ( 0_ (C205 , C206) ) +* (( EmptyBag C205 ) , C207) );
reconsider D143 = D142 as (Function of ( Bags C205 ) , (the carrier of C206));
reconsider D144 = D143 as (Function of ( Bags C205 ) , C206);
reconsider D145 = D144 as (Series of C205 , C206);
set D146 = ( ( 0_ (C205 , C206) ) +* (( EmptyBag C205 ) , C208) );
reconsider D147 = D146 as (Function of ( Bags C205 ) , (the carrier of C206));
reconsider D148 = D147 as (Function of ( Bags C205 ) , C206);
reconsider D149 = D148 as (Series of C205 , C206);
L786: ( dom ( ( EmptyBag C205 ) .--> C207 ) ) = { ( EmptyBag C205 ) } by FUNCOP_1:13;
L787: ( EmptyBag C205 ) in ( dom ( ( EmptyBag C205 ) .--> C207 ) ) by L786 , TARSKI:def 1;
L788: ( dom ( ( EmptyBag C205 ) .--> C208 ) ) = { ( EmptyBag C205 ) } by FUNCOP_1:13;
L789: ( EmptyBag C205 ) in ( dom ( ( EmptyBag C205 ) .--> C208 ) ) by L788 , TARSKI:def 1;
L790: ( dom ( 0_ (C205 , C206) ) ) = ( dom ( ( Bags C205 ) --> ( 0. C206 ) ) ) by POLYNOM1:def 7
.= ( Bags C205 ) by FUNCOP_1:13;
L791: ( D149 . ( EmptyBag C205 ) ) = ( ( ( 0_ (C205 , C206) ) +* ( ( EmptyBag C205 ) .--> C208 ) ) . ( EmptyBag C205 ) ) by L790 , FUNCT_7:def 3
.= ( ( ( EmptyBag C205 ) .--> C208 ) . ( EmptyBag C205 ) ) by L789 , FUNCT_4:13
.= C208 by FUNCOP_1:72;
L792: ( dom ( 0_ (C205 , C206) ) ) = ( dom ( ( Bags C205 ) --> ( 0. C206 ) ) ) by POLYNOM1:def 7
.= ( Bags C205 ) by FUNCOP_1:13;
L793: ( D145 . ( EmptyBag C205 ) ) = ( ( ( 0_ (C205 , C206) ) +* ( ( EmptyBag C205 ) .--> C207 ) ) . ( EmptyBag C205 ) ) by L792 , FUNCT_7:def 3
.= ( ( ( EmptyBag C205 ) .--> C207 ) . ( EmptyBag C205 ) ) by L787 , FUNCT_4:13
.= C207 by FUNCOP_1:72;
thus L794: thesis by L793 , L791;
end;
theorem
L795: (for B160 being set holds (for B161 being non  empty ZeroStr holds (for B162 being (Element of B161) holds (( Support ( B162 | (B160 , B161) ) ) = ( {} ) or ( Support ( B162 | (B160 , B161) ) ) = { ( EmptyBag B160 ) })))) by L698;
theorem
L796: (for B163 being set holds (for B164 being non  empty ZeroStr holds (for B165 being (Element of B164) holds (( term ( B165 | (B163 , B164) ) ) = ( EmptyBag B163 ) & ( coefficient ( B165 | (B163 , B164) ) ) = B165))))
proof
let C209 being set;
let C210 being non  empty ZeroStr;
let C211 being (Element of C210);
set D150 = ( ( 0_ (C209 , C210) ) +* (( EmptyBag C209 ) , C211) );
reconsider D151 = D150 as (Function of ( Bags C209 ) , (the carrier of C210));
reconsider D152 = D151 as (Function of ( Bags C209 ) , C210);
reconsider D153 = D152 as (Series of C209 , C210);
L797: ( dom ( ( EmptyBag C209 ) .--> C211 ) ) = { ( EmptyBag C209 ) } by FUNCOP_1:13;
L798: ( EmptyBag C209 ) in ( dom ( ( EmptyBag C209 ) .--> C211 ) ) by L797 , TARSKI:def 1;
L799: ( dom ( 0_ (C209 , C210) ) ) = ( dom ( ( Bags C209 ) --> ( 0. C210 ) ) ) by POLYNOM1:def 7
.= ( Bags C209 ) by FUNCOP_1:13;
L800: ( D153 . ( EmptyBag C209 ) ) = ( ( ( 0_ (C209 , C210) ) +* ( ( EmptyBag C209 ) .--> C211 ) ) . ( EmptyBag C209 ) ) by L799 , FUNCT_7:def 3
.= ( ( ( EmptyBag C209 ) .--> C211 ) . ( EmptyBag C209 ) ) by L798 , FUNCT_4:13
.= C211 by FUNCOP_1:72;
thus L801: thesis by L800 , L684;
end;
theorem
L802: (for B166 being Ordinal holds (for B167 being  right_zeroed  add-associative  right_complementable  well-unital  distributive non  trivial doubleLoopStr holds (for B168 being (ConstPoly of B166 , B167) holds (for B169 being (Function of B166 , B167) holds ( eval (B168 , B169) ) = ( coefficient B168 )))))
proof
let C212 being Ordinal;
let C213 being  right_zeroed  add-associative  right_complementable  well-unital  distributive non  trivial doubleLoopStr;
let C214 being (ConstPoly of C212 , C213);
let C215 being (Function of C212 , C213);
consider C216 being (FinSequence of (the carrier of C213)) such that L803: ( len C216 ) = ( len ( SgmX (( BagOrder C212 ) , ( Support C214 )) ) ) and L804: ( eval (C214 , C215) ) = ( Sum C216 ) and L805: (for B170 being (Element of ( NAT )) holds ((1 <= B170 & B170 <= ( len C216 )) implies ( C216 /. B170 ) = ( ( ( C214 * ( SgmX (( BagOrder C212 ) , ( Support C214 )) ) ) /. B170 ) * ( eval (( ( ( SgmX (( BagOrder C212 ) , ( Support C214 )) ) /. B170 ) @ ) , C215) ) ))) by POLYNOM2:def 4;
L806:
now
per cases ;
case L807: ( coefficient C214 ) = ( 0. C213 );
L808: ( Support C214 ) = ( {} )
proof
set D154 = the (Element of ( Support C214 ));
assume L809: ( Support C214 ) <> ( {} );
L810: D154 in ( Support C214 ) by L809;
reconsider D155 = D154 as (Element of ( Bags C212 )) by L810;
L811: ( C214 . D155 ) <> ( 0. C213 ) by L809 , POLYNOM1:def 3;
L812: D155 <> ( EmptyBag C212 ) by L811 , L807 , L684;
L813: ( C214 . D155 ) = ( 0. C213 ) by L812 , L646;
thus L814: thesis by L813 , L809 , POLYNOM1:def 3;
end;
reconsider D156 = ( Support C214 ) as  empty (Subset of ( Bags C212 )) by L808;
L815: ( SgmX (( BagOrder C212 ) , D156) ) = ( {} ) by POLYNOM2:7 , POLYNOM2:18;
L816: C216 = ( <*> (the carrier of C213) ) by L815 , L803;
thus L817: thesis by L816 , L804 , L807 , RLVECT_1:43;
end;
case L818: ( coefficient C214 ) <> ( 0. C213 );
reconsider D157 = ( Support C214 ) as  finite (Subset of ( Bags C212 ));
set D158 = ( SgmX (( BagOrder C212 ) , D157) );
L819: ( BagOrder C212 ) linearly_orders D157 by POLYNOM2:18;
L820: (for B171 being set holds (B171 in ( Support C214 ) implies B171 in { ( EmptyBag C212 ) }))
proof
let C217 being set;
assume L821: C217 in ( Support C214 );
assume L822: (not C217 in { ( EmptyBag C212 ) });
reconsider D159 = C217 as (Element of ( Bags C212 )) by L821;
L823: D159 <> ( EmptyBag C212 ) by L822 , TARSKI:def 1;
L824: ( C214 . D159 ) = ( 0. C213 ) by L823 , L646;
thus L825: thesis by L824 , L821 , POLYNOM1:def 3;
end;
L826: (for B172 being set holds (B172 in { ( EmptyBag C212 ) } implies B172 in ( Support C214 )))
proof
let C218 being set;
assume L827: C218 in { ( EmptyBag C212 ) };
L828: C218 = ( EmptyBag C212 ) by L827 , TARSKI:def 1;
reconsider D160 = C218 as (Element of ( Bags C212 )) by L827;
L829: ( C214 . D160 ) <> ( 0. C213 ) by L818 , L828 , L684;
thus L830: thesis by L829 , POLYNOM1:def 3;
end;
L831: ( Support C214 ) = { ( EmptyBag C212 ) } by L826 , L820 , TARSKI:1;
L832: ( rng D158 ) = { ( EmptyBag C212 ) } by L831 , L819 , PRE_POLY:def 2;
L833: ( EmptyBag C212 ) in ( rng D158 ) by L832 , TARSKI:def 1;
L834: 1 in ( dom D158 ) by L833 , FINSEQ_3:31;
L835: ( D158 . 1 ) in ( rng D158 ) by L834 , FUNCT_1:3;
L836: (for B173 being set holds (B173 in ( dom D158 ) implies B173 in { 1 }))
proof
let C219 being set;
assume L837: C219 in ( dom D158 );
assume L838: (not C219 in { 1 });
reconsider D161 = C219 as (Element of ( NAT )) by L837;
L839: ( D158 /. D161 ) = ( D158 . D161 ) by L837 , PARTFUN1:def 6;
L840: ( D158 /. D161 ) in ( rng D158 ) by L839 , L837 , FUNCT_1:3;
L841: D161 <> 1 by L838 , TARSKI:def 1;
L842: 1 < D161
proof
consider C220 being Nat such that L843: ( dom D158 ) = ( Seg C220 ) by FINSEQ_1:def 2;
L844: ( Seg C220 ) = { B174 where B174 is (Element of ( NAT )) : (1 <= B174 & B174 <= C220) } by FINSEQ_1:def 1;
L845: (ex B175 being (Element of ( NAT )) st (B175 = D161 & 1 <= B175 & B175 <= C220)) by L844 , L837 , L843;
thus L846: thesis by L845 , L841 , XXREAL_0:1;
end;
L847: ( D158 /. 1 ) = ( D158 . 1 ) by L833 , L837 , FINSEQ_3:31 , PARTFUN1:def 6;
L848: ( D158 /. 1 ) in ( rng D158 ) by L847 , L834 , FUNCT_1:3;
L849: ( D158 /. 1 ) = ( EmptyBag C212 ) by L848 , L832 , TARSKI:def 1
.= ( D158 /. D161 ) by L832 , L840 , TARSKI:def 1;
thus L850: thesis by L849 , L819 , L834 , L837 , L842 , PRE_POLY:def 2;
end;
L851: (for B176 being set holds (B176 in { 1 } implies B176 in ( dom D158 ))) by L834 , TARSKI:def 1;
L852: ( dom D158 ) = ( Seg 1 ) by L851 , L836 , FINSEQ_1:2 , TARSKI:1;
L853: 1 in ( dom D158 ) by L852 , FINSEQ_1:2 , TARSKI:def 1;
L854: ( D158 /. 1 ) = ( D158 . 1 ) by L834 , PARTFUN1:def 6;
L855: ( D158 /. 1 ) in ( rng D158 ) by L854 , L853 , FUNCT_1:3;
L856: ( D158 /. 1 ) = ( EmptyBag C212 ) by L855 , L832 , TARSKI:def 1;
L857: ( len D158 ) = 1 by L852 , FINSEQ_1:def 3;
L858: ( dom C214 ) = ( Bags C212 ) by FUNCT_2:def 1;
L859: 1 in ( dom ( C214 * D158 ) ) by L858 , L832 , L834 , L835 , FUNCT_1:11;
L860: ( ( C214 * D158 ) /. 1 ) = ( ( C214 * D158 ) . 1 ) by L859 , PARTFUN1:def 6
.= ( C214 . ( D158 . 1 ) ) by L834 , FUNCT_1:13
.= ( C214 . ( EmptyBag C212 ) ) by L832 , L835 , TARSKI:def 1
.= ( coefficient C214 ) by L684;
L861: ( dom C216 ) = ( Seg ( len C216 ) ) by FINSEQ_1:def 3
.= ( dom D158 ) by L803 , FINSEQ_1:def 3;
L862: ( C216 . 1 ) = ( C216 /. 1 ) by L861 , L853 , PARTFUN1:def 6
.= ( ( ( C214 * D158 ) /. 1 ) * ( eval (( ( D158 /. 1 ) @ ) , C215) ) ) by L803 , L805 , L857
.= ( ( coefficient C214 ) * ( eval (( EmptyBag C212 ) , C215) ) ) by L856 , L860 , POLYNOM2:def 3
.= ( ( coefficient C214 ) * ( 1. C213 ) ) by POLYNOM2:14
.= ( coefficient C214 ) by VECTSP_1:def 6;
L863: C216 = <* ( coefficient C214 ) *> by L862 , L803 , L857 , FINSEQ_1:40;
thus L864: thesis by L863 , L804 , RLVECT_1:44;
end;
end;
thus L866: thesis by L806;
end;
theorem
L867: (for B177 being Ordinal holds (for B178 being  right_zeroed  add-associative  right_complementable  well-unital  distributive non  trivial doubleLoopStr holds (for B179 being (Element of B178) holds (for B180 being (Function of B177 , B178) holds ( eval (( B179 | (B177 , B178) ) , B180) ) = B179))))
proof
let C221 being Ordinal;
let C222 being  right_zeroed  add-associative  right_complementable  well-unital  distributive non  trivial doubleLoopStr;
let C223 being (Element of C222);
let C224 being (Function of C221 , C222);
thus L868: ( eval (( C223 | (C221 , C222) ) , C224) ) = ( coefficient ( C223 | (C221 , C222) ) ) by L802
.= C223 by L796;
end;
begin
definition
let C225 being set;
let C226 being non  empty multLoopStr_0;
let C227 being (Series of C225 , C226);
let C228 being (Element of C226);
func C228 * C227 -> (Series of C225 , C226) means 
:L869: (for B181 being (bag of C225) holds ( it . B181 ) = ( C228 * ( C227 . B181 ) ));
existence
proof
deffunc H1((Element of ( Bags C225 ))) = ( C228 * ( C227 . $1 ) );
consider C229 being (Function of ( Bags C225 ) , (the carrier of C226)) such that L870: (for B182 being (Element of ( Bags C225 )) holds ( C229 . B182 ) = H1(B182)) from FUNCT_2:sch 4;
reconsider D162 = C229 as (Function of ( Bags C225 ) , C226);
reconsider D163 = D162 as (Series of C225 , C226);
reconsider D164 = D163 as (Series of C225 , C226);
take D164;
let C230 being (bag of C225);
L871: C230 in ( Bags C225 ) by PRE_POLY:def 12;
thus L872: thesis by L871 , L870;
end;
uniqueness
proof
let C231 , C232 being (Series of C225 , C226);
assume that
L873: (for B183 being (bag of C225) holds ( C231 . B183 ) = ( C228 * ( C227 . B183 ) ))
and
L874: (for B184 being (bag of C225) holds ( C232 . B184 ) = ( C228 * ( C227 . B184 ) ));
L875:
now
let C233 being (Element of ( Bags C225 ));
reconsider D165 = C233 as (bag of C225);
thus L876: ( C231 . C233 ) = ( C228 * ( C227 . D165 ) ) by L873
.= ( C232 . C233 ) by L874;
end;
thus L877: C231 = C232 by L875 , FUNCT_2:63;
end;
func C227 * C228 -> (Series of C225 , C226) means 
:L878: (for B185 being (bag of C225) holds ( it . B185 ) = ( ( C227 . B185 ) * C228 ));
existence
proof
deffunc H2((Element of ( Bags C225 ))) = ( ( C227 . $1 ) * C228 );
consider C234 being (Function of ( Bags C225 ) , (the carrier of C226)) such that L879: (for B186 being (Element of ( Bags C225 )) holds ( C234 . B186 ) = H2(B186)) from FUNCT_2:sch 4;
reconsider D166 = C234 as (Function of ( Bags C225 ) , C226);
reconsider D167 = D166 as (Series of C225 , C226);
reconsider D168 = D167 as (Series of C225 , C226);
take D168;
let C235 being (bag of C225);
L880: C235 in ( Bags C225 ) by PRE_POLY:def 12;
thus L881: thesis by L880 , L879;
end;
uniqueness
proof
let C236 , C237 being (Series of C225 , C226);
assume that
L882: (for B187 being (bag of C225) holds ( C236 . B187 ) = ( ( C227 . B187 ) * C228 ))
and
L883: (for B188 being (bag of C225) holds ( C237 . B188 ) = ( ( C227 . B188 ) * C228 ));
L884:
now
let C238 being (Element of ( Bags C225 ));
reconsider D169 = C238 as (bag of C225);
thus L885: ( C236 . C238 ) = ( ( C227 . D169 ) * C228 ) by L882
.= ( C237 . C238 ) by L883;
end;
thus L886: C236 = C237 by L884 , FUNCT_2:63;
end;
end;
registration
let C239 being set;
let C240 being  left_zeroed  right_zeroed  add-cancelable  distributive non  empty doubleLoopStr;
let C241 being  finite-Support (Series of C239 , C240);
let C242 being (Element of C240);
cluster ( C242 * C241 ) ->  finite-Support;
coherence
proof
set D170 = ( C242 * C241 );
L888:
now
let C243 being set;
assume L889: C243 in ( Support D170 );
reconsider D171 = C243 as (Element of ( Bags C239 )) by L889;
L890: ( D170 . C243 ) <> ( 0. C240 ) by L889 , POLYNOM1:def 3;
L891: ( C242 * ( C241 . D171 ) ) <> ( 0. C240 ) by L890 , L869;
L892: ( C241 . D171 ) <> ( 0. C240 ) by L891 , BINOM:2;
thus L893: C243 in ( Support C241 ) by L892 , POLYNOM1:def 3;
end;
L894: (( Support C241 ) is  finite & ( Support D170 ) c= ( Support C241 )) by L888 , POLYNOM1:def 4 , TARSKI:def 3;
thus L895: thesis by L894 , POLYNOM1:def 4;
end;
cluster ( C241 * C242 ) ->  finite-Support;
coherence
proof
set D172 = ( C241 * C242 );
L896:
now
let C244 being set;
assume L897: C244 in ( Support D172 );
reconsider D173 = C244 as (Element of ( Bags C239 )) by L897;
L898: ( D172 . C244 ) <> ( 0. C240 ) by L897 , POLYNOM1:def 3;
L899: ( ( C241 . D173 ) * C242 ) <> ( 0. C240 ) by L898 , L878;
L900: ( C241 . D173 ) <> ( 0. C240 ) by L899 , BINOM:1;
thus L901: C244 in ( Support C241 ) by L900 , POLYNOM1:def 3;
end;
L902: (( Support C241 ) is  finite & ( Support D172 ) c= ( Support C241 )) by L896 , POLYNOM1:def 4 , TARSKI:def 3;
thus L903: thesis by L902 , POLYNOM1:def 4;
end;
end;
theorem
L905: (for B189 being set holds (for B190 being  commutative non  empty multLoopStr_0 holds (for B191 being (Series of B189 , B190) holds (for B192 being (Element of B190) holds ( B192 * B191 ) = ( B191 * B192 )))))
proof
let C245 being set;
let C246 being  commutative non  empty multLoopStr_0;
let C247 being (Series of C245 , C246);
let C248 being (Element of C246);
L906:
now
let C249 being (Element of ( Bags C245 ));
reconsider D174 = C249 as (bag of C245);
thus L907: ( ( C248 * C247 ) . C249 ) = ( C248 * ( C247 . D174 ) ) by L869
.= ( ( C247 * C248 ) . C249 ) by L878;
end;
thus L908: thesis by L906 , FUNCT_2:63;
end;
theorem
L909: (for B193 being Ordinal holds (for B194 being  add-associative  right_complementable  right_zeroed  left-distributive non  empty doubleLoopStr holds (for B195 being (Series of B193 , B194) holds (for B196 being (Element of B194) holds ( B196 * B195 ) = ( ( B196 | (B193 , B194) ) *' B195 )))))
proof
let C250 being Ordinal;
let C251 being  add-associative  right_complementable  left-distributive  right_zeroed non  empty doubleLoopStr;
let C252 being (Series of C250 , C251);
let C253 being (Element of C251);
L910: (for B197 being set holds (B197 in ( Bags C250 ) implies ( ( C253 * C252 ) . B197 ) = ( ( ( C253 | (C250 , C251) ) *' C252 ) . B197 )))
proof
set D175 = ( C253 | (C250 , C251) );
set D176 = (the carrier of C251);
let C254 being set;
assume L911: C254 in ( Bags C250 );
reconsider D177 = C254 as (bag of C250) by L911;
L912: (for B198 being (Element of ( Bags C250 )) holds ( ( ( C253 | (C250 , C251) ) *' C252 ) . B198 ) = ( C253 * ( C252 . B198 ) ))
proof
let C255 being (Element of ( Bags C250 ));
consider C256 being (FinSequence of D176) such that L913: ( ( D175 *' C252 ) . C255 ) = ( Sum C256 ) and L914: ( len C256 ) = ( len ( decomp C255 ) ) and L915: (for B199 being (Element of ( NAT )) holds (B199 in ( dom C256 ) implies (ex B200 , B201 being (bag of C250) st (( ( decomp C255 ) /. B199 ) = <* B200 , B201 *> & ( C256 /. B199 ) = ( ( D175 . B200 ) * ( C252 . B201 ) ))))) by POLYNOM1:def 9;
L916: C256 is non  empty by L914;
consider C257 being (Element of D176), C258 being (FinSequence of D176) such that L917: C257 = ( C256 . 1 ) and L918: C256 = ( <* C257 *> ^ C258 ) by L916 , FINSEQ_3:102;
L919: ( Sum C256 ) = ( ( Sum <* C257 *> ) + ( Sum C258 ) ) by L918 , RLVECT_1:41;
L920:
now
per cases ;
suppose L921: C258 = ( <*> D176 );

thus L922: ( Sum C258 ) = ( 0. C251 ) by L921 , RLVECT_1:43;
end;
suppose L923: C258 <> ( <*> D176 );

L924:
now
let C259 being Nat;
L925: ( len C256 ) = ( ( len C258 ) + ( len <* C257 *> ) ) by L918 , FINSEQ_1:22
.= ( ( len C258 ) + 1 ) by FINSEQ_1:39;
assume L926: C259 in ( dom C258 );
L927: ( C258 /. C259 ) = ( C258 . C259 ) by L926 , PARTFUN1:def 6
.= ( C256 . ( C259 + 1 ) ) by L918 , L926 , FINSEQ_3:103;
L928: 1 <= C259 by L926 , FINSEQ_3:25;
L929: 1 < ( C259 + 1 ) by L928 , NAT_1:13;
L930: C259 <= ( len C258 ) by L926 , FINSEQ_3:25;
L931: ( C259 + 1 ) <= ( len C256 ) by L930 , L925 , XREAL_1:6;
L932: ( C259 + 1 ) in ( dom ( decomp C255 ) ) by L931 , L914 , L929 , FINSEQ_3:25;
L933: ( dom C256 ) = ( dom ( decomp C255 ) ) by L914 , FINSEQ_3:29;
L934: ( C256 /. ( C259 + 1 ) ) = ( C256 . ( C259 + 1 ) ) by L933 , L932 , PARTFUN1:def 6;
per cases  by L931 , XXREAL_0:1;
suppose L935: ( C259 + 1 ) < ( len C256 );

reconsider D178 = C259 as (Element of ( NAT )) by ORDINAL1:def 12;
consider C260 , C261 being (bag of C250) such that L936: ( ( decomp C255 ) /. ( D178 + 1 ) ) = <* C260 , C261 *> and L937: ( C256 /. ( D178 + 1 ) ) = ( ( D175 . C260 ) * ( C252 . C261 ) ) by L915 , L933 , L932;
L938: C260 <> ( EmptyBag C250 ) by L914 , L929 , L935 , L936 , PRE_POLY:72;
thus L939: ( C258 /. C259 ) = ( ( 0. C251 ) * ( C252 . C261 ) ) by L938 , L927 , L934 , L937 , L760
.= ( 0. C251 ) by VECTSP_1:7;
end;
suppose L940: ( C259 + 1 ) = ( len C256 );

L941:
now
assume L942: C255 = ( EmptyBag C250 );
L943: ( decomp C255 ) = <* <* ( EmptyBag C250 ) , ( EmptyBag C250 ) *> *> by L942 , PRE_POLY:73;
L944: ( ( len C258 ) + 1 ) = ( ( 0 ) + 1 ) by L943 , L914 , L925 , FINSEQ_1:39;
thus L945: contradiction by L944 , L923;
end;
consider C262 , C263 being (bag of C250) such that L946: ( ( decomp C255 ) /. ( C259 + 1 ) ) = <* C262 , C263 *> and L947: ( C256 /. ( C259 + 1 ) ) = ( ( D175 . C262 ) * ( C252 . C263 ) ) by L915 , L933 , L932;
L948: ( ( decomp C255 ) /. ( len C256 ) ) = <* C255 , ( EmptyBag C250 ) *> by L914 , PRE_POLY:71;
L949: (C263 = ( EmptyBag C250 ) & C262 = C255) by L948 , L940 , L946 , FINSEQ_1:77;
L950: ( C256 . ( C259 + 1 ) ) = ( ( 0. C251 ) * ( C252 . ( EmptyBag C250 ) ) ) by L949 , L934 , L947 , L941 , L760
.= ( 0. C251 ) by VECTSP_1:7;
thus L951: ( C258 /. C259 ) = ( 0. C251 ) by L950 , L927;
end;
end;
thus L953: ( Sum C258 ) = ( 0. C251 ) by L924 , MATRLIN:11;
end;
end;
L955: C256 is non  empty by L914;
consider C264 , C265 being (bag of C250) such that L956: ( ( decomp C255 ) /. 1 ) = <* C264 , C265 *> and L957: ( C256 /. 1 ) = ( ( D175 . C264 ) * ( C252 . C265 ) ) by L955 , L915 , FINSEQ_5:6;
L958: 1 in ( dom C256 ) by L955 , FINSEQ_5:6;
L959: ( C256 /. 1 ) = ( C256 . 1 ) by L958 , PARTFUN1:def 6;
L960: ( ( decomp C255 ) /. 1 ) = <* ( EmptyBag C250 ) , C255 *> by PRE_POLY:71;
L961: (C265 = C255 & C264 = ( EmptyBag C250 )) by L960 , L956 , FINSEQ_1:77;
L962: ( Sum <* C257 *> ) = C257 by RLVECT_1:44
.= ( C253 * ( C252 . C255 ) ) by L917 , L957 , L961 , L959 , L760;
thus L963: thesis by L962 , L913 , L919 , L920 , RLVECT_1:4;
end;
L964: D177 is (Element of ( Bags C250 )) by PRE_POLY:def 12;
L965: ( ( D175 *' C252 ) . D177 ) = ( C253 * ( C252 . D177 ) ) by L964 , L912
.= ( ( C253 * C252 ) . D177 ) by L869;
thus L966: thesis by L965;
end;
L967: (( Bags C250 ) = ( dom ( C253 * C252 ) ) & ( Bags C250 ) = ( dom ( ( C253 | (C250 , C251) ) *' C252 ) )) by FUNCT_2:def 1;
thus L968: thesis by L967 , L910 , FUNCT_1:2;
end;
theorem
L969: (for B202 being Ordinal holds (for B203 being  add-associative  right_complementable  right_zeroed  right-distributive non  empty doubleLoopStr holds (for B204 being (Series of B202 , B203) holds (for B205 being (Element of B203) holds ( B204 * B205 ) = ( B204 *' ( B205 | (B202 , B203) ) )))))
proof
let C266 being Ordinal;
let C267 being  add-associative  right_complementable  right-distributive  right_zeroed non  empty doubleLoopStr;
let C268 being (Series of C266 , C267);
let C269 being (Element of C267);
L970: (for B206 being set holds (B206 in ( Bags C266 ) implies ( ( C268 * C269 ) . B206 ) = ( ( C268 *' ( C269 | (C266 , C267) ) ) . B206 )))
proof
set D179 = ( C269 | (C266 , C267) );
set D180 = (the carrier of C267);
let C270 being set;
assume L971: C270 in ( Bags C266 );
reconsider D181 = C270 as (bag of C266) by L971;
L972: (for B207 being (Element of ( Bags C266 )) holds ( ( C268 *' ( C269 | (C266 , C267) ) ) . B207 ) = ( ( C268 . B207 ) * C269 ))
proof
let C271 being (Element of ( Bags C266 ));
consider C272 being (FinSequence of D180) such that L973: ( ( C268 *' D179 ) . C271 ) = ( Sum C272 ) and L974: ( len C272 ) = ( len ( decomp C271 ) ) and L975: (for B208 being (Element of ( NAT )) holds (B208 in ( dom C272 ) implies (ex B209 , B210 being (bag of C266) st (( ( decomp C271 ) /. B208 ) = <* B209 , B210 *> & ( C272 /. B208 ) = ( ( C268 . B209 ) * ( D179 . B210 ) ))))) by POLYNOM1:def 9;
consider C273 being (FinSequence of D180), C274 being (Element of D180) such that L976: C272 = ( C273 ^ <* C274 *> ) by L974 , FINSEQ_2:19;
L977:
now
per cases ;
suppose L978: C273 = ( <*> D180 );

thus L979: ( Sum C273 ) = ( 0. C267 ) by L978 , RLVECT_1:43;
end;
suppose L980: C273 <> ( <*> D180 );

L981:
now
let C275 being Nat;
L982: ( len C272 ) = ( ( len C273 ) + ( len <* C274 *> ) ) by L976 , FINSEQ_1:22
.= ( ( len C273 ) + 1 ) by FINSEQ_1:39;
assume L983: C275 in ( dom C273 );
L984: ( C273 /. C275 ) = ( C273 . C275 ) by L983 , PARTFUN1:def 6
.= ( C272 . C275 ) by L976 , L983 , FINSEQ_1:def 7;
L985: C275 <= ( len C273 ) by L983 , FINSEQ_3:25;
L986: C275 < ( len C272 ) by L985 , L982 , NAT_1:13;
L987: 1 <= C275 by L983 , FINSEQ_3:25;
L988: C275 in ( dom ( decomp C271 ) ) by L987 , L974 , L986 , FINSEQ_3:25;
L989: ( dom C272 ) = ( dom ( decomp C271 ) ) by L974 , FINSEQ_3:29;
L990: ( C272 /. C275 ) = ( C272 . C275 ) by L989 , L988 , PARTFUN1:def 6;
per cases  by L987 , XXREAL_0:1;
suppose L991: 1 < C275;

reconsider D182 = C275 as (Element of ( NAT )) by ORDINAL1:def 12;
consider C276 , C277 being (bag of C266) such that L992: ( ( decomp C271 ) /. D182 ) = <* C276 , C277 *> and L993: ( C272 /. D182 ) = ( ( C268 . C276 ) * ( D179 . C277 ) ) by L975 , L989 , L988;
L994: C277 <> ( EmptyBag C266 ) by L974 , L986 , L991 , L992 , PRE_POLY:72;
thus L995: ( C273 /. C275 ) = ( ( C268 . C276 ) * ( 0. C267 ) ) by L994 , L984 , L990 , L993 , L760
.= ( 0. C267 ) by VECTSP_1:6;
end;
suppose L996: C275 = 1;

L997:
now
assume L998: C271 = ( EmptyBag C266 );
L999: ( decomp C271 ) = <* <* ( EmptyBag C266 ) , ( EmptyBag C266 ) *> *> by L998 , PRE_POLY:73;
L1000: ( ( len C273 ) + 1 ) = ( ( 0 ) + 1 ) by L999 , L974 , L982 , FINSEQ_1:39;
thus L1001: contradiction by L1000 , L980;
end;
consider C278 , C279 being (bag of C266) such that L1002: ( ( decomp C271 ) /. C275 ) = <* C278 , C279 *> and L1003: ( C272 /. C275 ) = ( ( C268 . C278 ) * ( D179 . C279 ) ) by L975 , L989 , L988;
L1004: ( ( decomp C271 ) /. 1 ) = <* ( EmptyBag C266 ) , C271 *> by PRE_POLY:71;
L1005: (C278 = ( EmptyBag C266 ) & C279 = C271) by L1004 , L996 , L1002 , FINSEQ_1:77;
L1006: ( C272 . C275 ) = ( ( C268 . ( EmptyBag C266 ) ) * ( 0. C267 ) ) by L1005 , L990 , L1003 , L997 , L760
.= ( 0. C267 ) by VECTSP_1:6;
thus L1007: ( C273 /. C275 ) = ( 0. C267 ) by L1006 , L984;
end;
end;
thus L1009: ( Sum C273 ) = ( 0. C267 ) by L981 , MATRLIN:11;
end;
end;
L1011: ( C272 . ( len C272 ) ) = ( ( C273 ^ <* C274 *> ) . ( ( len C273 ) + 1 ) ) by L976 , FINSEQ_2:16
.= C274 by FINSEQ_1:42;
L1012: ( Sum C272 ) = ( ( Sum C273 ) + ( Sum <* C274 *> ) ) by L976 , RLVECT_1:41;
L1013: C272 is non  empty by L974;
L1014: ( len C272 ) in ( dom C272 ) by L1013 , FINSEQ_5:6;
consider C280 , C281 being (bag of C266) such that L1015: ( ( decomp C271 ) /. ( len C272 ) ) = <* C280 , C281 *> and L1016: ( C272 /. ( len C272 ) ) = ( ( C268 . C280 ) * ( D179 . C281 ) ) by L1014 , L975;
L1017: ( C272 /. ( len C272 ) ) = ( C272 . ( len C272 ) ) by L1014 , PARTFUN1:def 6;
L1018: ( ( decomp C271 ) /. ( len C272 ) ) = <* C271 , ( EmptyBag C266 ) *> by L974 , PRE_POLY:71;
L1019: (C280 = C271 & C281 = ( EmptyBag C266 )) by L1018 , L1015 , FINSEQ_1:77;
L1020: ( Sum <* C274 *> ) = C274 by RLVECT_1:44
.= ( ( C268 . C271 ) * C269 ) by L1016 , L1019 , L1017 , L1011 , L760;
thus L1021: thesis by L1020 , L973 , L1012 , L977 , RLVECT_1:4;
end;
L1022: D181 is (Element of ( Bags C266 )) by PRE_POLY:def 12;
L1023: ( ( C268 *' D179 ) . D181 ) = ( ( C268 . D181 ) * C269 ) by L1022 , L972
.= ( ( C268 * C269 ) . D181 ) by L878;
thus L1024: thesis by L1023;
end;
L1025: (( Bags C266 ) = ( dom ( C268 * C269 ) ) & ( Bags C266 ) = ( dom ( C268 *' ( C269 | (C266 , C267) ) ) )) by FUNCT_2:def 1;
thus L1026: thesis by L1025 , L970 , FUNCT_1:2;
end;
L1027: (for B211 being Ordinal holds (for B212 being  Abelian  left_zeroed  right_zeroed  add-associative  right_complementable  well-unital  associative  commutative  distributive non  trivial doubleLoopStr holds (for B213 being (Polynomial of B211 , B212) holds (for B214 being (Element of B212) holds (for B215 being (Function of B211 , B212) holds ( eval (( ( B214 | (B211 , B212) ) *' B213 ) , B215) ) = ( B214 * ( eval (B213 , B215) ) ))))))
proof
let C282 being Ordinal;
let C283 being  left_zeroed  right_zeroed  add-associative  right_complementable  well-unital  associative  commutative  Abelian  distributive non  trivial doubleLoopStr;
let C284 being (Polynomial of C282 , C283);
let C285 being (Element of C283);
let C286 being (Function of C282 , C283);
thus L1028: ( eval (( ( C285 | (C282 , C283) ) *' C284 ) , C286) ) = ( ( eval (( C285 | (C282 , C283) ) , C286) ) * ( eval (C284 , C286) ) ) by POLYNOM2:25
.= ( C285 * ( eval (C284 , C286) ) ) by L867;
end;
L1029: (for B216 being Ordinal holds (for B217 being  Abelian  left_zeroed  right_zeroed  add-associative  right_complementable  well-unital  associative  commutative  distributive non  trivial doubleLoopStr holds (for B218 being (Polynomial of B216 , B217) holds (for B219 being (Element of B217) holds (for B220 being (Function of B216 , B217) holds ( eval (( B218 *' ( B219 | (B216 , B217) ) ) , B220) ) = ( ( eval (B218 , B220) ) * B219 ))))))
proof
let C287 being Ordinal;
let C288 being  left_zeroed  right_zeroed  add-associative  right_complementable  well-unital  associative  commutative  Abelian  distributive non  trivial doubleLoopStr;
let C289 being (Polynomial of C287 , C288);
let C290 being (Element of C288);
let C291 being (Function of C287 , C288);
thus L1030: ( eval (( C289 *' ( C290 | (C287 , C288) ) ) , C291) ) = ( ( eval (C289 , C291) ) * ( eval (( C290 | (C287 , C288) ) , C291) ) ) by POLYNOM2:25
.= ( ( eval (C289 , C291) ) * C290 ) by L867;
end;
theorem
L1031: (for B221 being Ordinal holds (for B222 being  Abelian  left_zeroed  right_zeroed  add-associative  right_complementable  well-unital  associative  commutative  distributive non  trivial doubleLoopStr holds (for B223 being (Polynomial of B221 , B222) holds (for B224 being (Element of B222) holds (for B225 being (Function of B221 , B222) holds ( eval (( B224 * B223 ) , B225) ) = ( B224 * ( eval (B223 , B225) ) ))))))
proof
let C292 being Ordinal;
let C293 being  Abelian  left_zeroed  right_zeroed  add-associative  right_complementable  well-unital  associative  commutative  distributive non  trivial doubleLoopStr;
let C294 being (Polynomial of C292 , C293);
let C295 being (Element of C293);
let C296 being (Function of C292 , C293);
thus L1032: ( eval (( C295 * C294 ) , C296) ) = ( eval (( ( C295 | (C292 , C293) ) *' C294 ) , C296) ) by L909
.= ( C295 * ( eval (C294 , C296) ) ) by L1027;
end;
theorem
L1033: (for B226 being Ordinal holds (for B227 being  left_zeroed  right_zeroed  left_add-cancelable  add-associative  right_complementable  well-unital  associative  domRing-like  distributive non  trivial doubleLoopStr holds (for B228 being (Polynomial of B226 , B227) holds (for B229 being (Element of B227) holds (for B230 being (Function of B226 , B227) holds ( eval (( B229 * B228 ) , B230) ) = ( B229 * ( eval (B228 , B230) ) ))))))
proof
let C297 being Ordinal;
let C298 being  left_zeroed  right_zeroed  left_add-cancelable  add-associative  right_complementable  well-unital  associative  domRing-like  distributive non  trivial doubleLoopStr;
let C299 being (Polynomial of C297 , C298);
let C300 being (Element of C298);
let C301 being (Function of C297 , C298);
consider C302 being (FinSequence of (the carrier of C298)) such that L1034: ( len C302 ) = ( len ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) ) and L1035: ( eval (( C300 * C299 ) , C301) ) = ( Sum C302 ) and L1036: (for B231 being (Element of ( NAT )) holds ((1 <= B231 & B231 <= ( len C302 )) implies ( C302 /. B231 ) = ( ( ( ( C300 * C299 ) * ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) ) /. B231 ) * ( eval (( ( ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) /. B231 ) @ ) , C301) ) ))) by POLYNOM2:def 4;
L1037: ( BagOrder C297 ) linearly_orders ( Support ( C300 * C299 ) ) by POLYNOM2:18;
consider C303 being (FinSequence of (the carrier of C298)) such that L1038: ( len C303 ) = ( len ( SgmX (( BagOrder C297 ) , ( Support C299 )) ) ) and L1039: ( eval (C299 , C301) ) = ( Sum C303 ) and L1040: (for B232 being (Element of ( NAT )) holds ((1 <= B232 & B232 <= ( len C303 )) implies ( C303 /. B232 ) = ( ( ( C299 * ( SgmX (( BagOrder C297 ) , ( Support C299 )) ) ) /. B232 ) * ( eval (( ( ( SgmX (( BagOrder C297 ) , ( Support C299 )) ) /. B232 ) @ ) , C301) ) ))) by POLYNOM2:def 4;
per cases ;
suppose L1041: C300 = ( 0. C298 );

L1042:
now
let C304 being (bag of C297);
thus L1043: ( ( C300 * C299 ) . C304 ) = ( C300 * ( C299 . C304 ) ) by L869
.= ( 0. C298 ) by L1041 , BINOM:1;
end;
L1044:
now
assume L1045: ( Support ( C300 * C299 ) ) <> ( {} );
reconsider D183 = ( Support ( C300 * C299 ) ) as non  empty (Subset of ( Bags C297 )) by L1045;
set D184 = the (Element of D183);
L1046: ( ( C300 * C299 ) . D184 ) <> ( 0. C298 ) by POLYNOM1:def 3;
thus L1047: contradiction by L1046 , L1042;
end;
L1048: ( rng ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) ) = ( {} ) by L1044 , L1037 , PRE_POLY:def 2;
L1049: ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) = ( {} ) by L1048 , RELAT_1:41;
L1050: C302 = ( <*> (the carrier of C298) ) by L1049 , L1034;
L1051: ( Sum C302 ) = ( 0. C298 ) by L1050 , RLVECT_1:43
.= ( C300 * ( Sum C303 ) ) by L1041 , BINOM:1;
thus L1052: thesis by L1051 , L1035 , L1039;
end;
suppose L1053: C300 <> ( 0. C298 );

L1054: (for B233 being set holds (B233 in ( Support ( C300 * C299 ) ) implies B233 in ( Support C299 )))
proof
let C305 being set;
assume L1055: C305 in ( Support ( C300 * C299 ) );
reconsider D185 = C305 as (Element of ( Bags C297 )) by L1055;
L1056: ( ( C300 * C299 ) . C305 ) <> ( 0. C298 ) by L1055 , POLYNOM1:def 3;
L1057: ( C300 * ( C299 . D185 ) ) <> ( 0. C298 ) by L1056 , L869;
L1058: ( C299 . D185 ) <> ( 0. C298 ) by L1057 , BINOM:2;
thus L1059: thesis by L1058 , POLYNOM1:def 3;
end;
L1060: (for B234 being set holds (B234 in ( Support C299 ) implies B234 in ( Support ( C300 * C299 ) )))
proof
let C306 being set;
assume L1061: C306 in ( Support C299 );
reconsider D186 = C306 as (Element of ( Bags C297 )) by L1061;
L1062: ( C299 . C306 ) <> ( 0. C298 ) by L1061 , POLYNOM1:def 3;
L1063: ( C300 * ( C299 . D186 ) ) <> ( 0. C298 ) by L1062 , L1053 , VECTSP_2:def 1;
L1064: ( ( C300 * C299 ) . D186 ) <> ( 0. C298 ) by L1063 , L869;
thus L1065: thesis by L1064 , POLYNOM1:def 3;
end;
L1066: ( len C303 ) = ( len C302 ) by L1060 , L1034 , L1038 , L1054 , TARSKI:1;
L1067: ( dom C303 ) = ( Seg ( len C302 ) ) by L1066 , FINSEQ_1:def 3
.= ( dom C302 ) by FINSEQ_1:def 3;
L1068: ( Support ( C300 * C299 ) ) = ( Support C299 ) by L1060 , L1054 , TARSKI:1;
L1069:
now
L1070: ( dom ( C300 * C299 ) ) = ( Bags C297 ) by FUNCT_2:def 1;
L1071:
now
let C307 being set;
assume L1072: C307 in ( rng ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) );
L1073: C307 in ( Support ( C300 * C299 ) ) by L1072 , L1037 , PRE_POLY:def 2;
thus L1074: C307 in ( dom ( C300 * C299 ) ) by L1073 , L1070;
end;
L1075: ( rng ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) ) c= ( dom ( C300 * C299 ) ) by L1071 , TARSKI:def 3;
reconsider D187 = ( ( C300 * C299 ) * ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) ) as FinSequence by L1075 , FINSEQ_1:16;
L1076: (for B235 being set holds (B235 in ( rng D187 ) implies B235 in (the carrier of C298)))
proof
let C308 being set;
assume L1077: C308 in ( rng D187 );
L1078: C308 in ( rng ( C300 * C299 ) ) by L1077 , FUNCT_1:14;
L1079: ( rng ( C300 * C299 ) ) c= (the carrier of C298) by RELAT_1:def 19;
thus L1080: thesis by L1079 , L1078;
end;
L1081: ( rng D187 ) c= (the carrier of C298) by L1076 , TARSKI:def 3;
L1082: ( dom C299 ) = ( Bags C297 ) by FUNCT_2:def 1;
L1083:
now
let C309 being set;
assume L1084: C309 in ( rng ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) );
L1085: C309 in ( Support ( C300 * C299 ) ) by L1084 , L1037 , PRE_POLY:def 2;
thus L1086: C309 in ( dom C299 ) by L1085 , L1082;
end;
L1087: ( rng ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) ) c= ( dom C299 ) by L1083 , TARSKI:def 3;
reconsider D188 = ( C299 * ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) ) as FinSequence by L1087 , FINSEQ_1:16;
L1088: (for B236 being set holds (B236 in ( rng D188 ) implies B236 in (the carrier of C298)))
proof
let C310 being set;
assume L1089: C310 in ( rng D188 );
L1090: C310 in ( rng C299 ) by L1089 , FUNCT_1:14;
L1091: ( rng C299 ) c= (the carrier of C298) by RELAT_1:def 19;
thus L1092: thesis by L1091 , L1090;
end;
L1093: ( rng D188 ) c= (the carrier of C298) by L1088 , TARSKI:def 3;
reconsider D189 = D187 as (FinSequence of (the carrier of C298)) by L1081 , FINSEQ_1:def 4;
reconsider D190 = D188 as (FinSequence of (the carrier of C298)) by L1093 , FINSEQ_1:def 4;
let C311 being set;
assume L1094: C311 in ( dom C303 );
L1095: C311 in ( Seg ( len C303 ) ) by L1094 , FINSEQ_1:def 3;
L1096: C311 in { B237 where B237 is (Element of ( NAT )) : (1 <= B237 & B237 <= ( len C303 )) } by L1095 , FINSEQ_1:def 1;
consider C312 being (Element of ( NAT )) such that L1097: C311 = C312 and L1098: (1 <= C312 & C312 <= ( len C303 )) by L1096;
L1099: ( dom C303 ) = ( Seg ( len ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) ) ) by L1034 , L1067 , FINSEQ_1:def 3
.= ( dom ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) ) by FINSEQ_1:def 3;
L1100: ( ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) . C312 ) = ( ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) /. C312 ) by L1099 , L1094 , L1097 , PARTFUN1:def 6;
L1101: C312 in ( dom D190 ) by L1100 , L1094 , L1097 , L1099 , L1082 , FUNCT_1:11;
L1102: ( ( C299 * ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) ) /. C312 ) = ( D190 . C312 ) by L1101 , PARTFUN1:def 6
.= ( C299 . ( ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) . C312 ) ) by L1094 , L1097 , L1099 , FUNCT_1:13
.= ( C299 . ( ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) /. C312 ) ) by L1094 , L1097 , L1099 , PARTFUN1:def 6;
reconsider D191 = ( ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) /. C312 ) as (Element of ( Bags C297 ));
reconsider D192 = D191 as (bag of C297);
L1103: ( C300 * ( C303 /. C312 ) ) = ( C300 * ( ( ( C299 * ( SgmX (( BagOrder C297 ) , ( Support C299 )) ) ) /. C312 ) * ( eval (( ( ( SgmX (( BagOrder C297 ) , ( Support C299 )) ) /. C312 ) @ ) , C301) ) ) ) by L1040 , L1098
.= ( ( C300 * ( ( C299 * ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) ) /. C312 ) ) * ( eval (( ( ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) /. C312 ) @ ) , C301) ) ) by L1068 , GROUP_1:def 3;
L1104: ( ( C300 * C299 ) . ( ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) /. C312 ) ) = ( ( C300 * C299 ) . D192 )
.= ( C300 * ( ( C299 * ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) ) /. C312 ) ) by L1102 , L869;
L1105: ( ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) . C312 ) = ( ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) /. C312 ) by L1094 , L1097 , L1099 , PARTFUN1:def 6;
L1106: C312 in ( dom D189 ) by L1105 , L1094 , L1097 , L1099 , L1070 , FUNCT_1:11;
L1107: ( ( ( C300 * C299 ) * ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) ) /. C312 ) = ( D189 . C312 ) by L1106 , PARTFUN1:def 6
.= ( ( C300 * C299 ) . ( ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) . C312 ) ) by L1094 , L1097 , L1099 , FUNCT_1:13
.= ( C300 * ( ( C299 * ( SgmX (( BagOrder C297 ) , ( Support ( C300 * C299 ) )) ) ) /. C312 ) ) by L1094 , L1097 , L1099 , L1104 , PARTFUN1:def 6;
thus L1108: ( C302 /. C311 ) = ( C300 * ( C303 /. C311 ) ) by L1107 , L1036 , L1066 , L1097 , L1098 , L1103;
end;
L1109: C302 = ( C300 * C303 ) by L1069 , L1067 , POLYNOM1:def 1;
thus L1110: thesis by L1109 , L1035 , L1039 , BINOM:4;
end;
end;
theorem
L1112: (for B238 being Ordinal holds (for B239 being  Abelian  left_zeroed  right_zeroed  add-associative  right_complementable  well-unital  associative  commutative  distributive non  trivial doubleLoopStr holds (for B240 being (Polynomial of B238 , B239) holds (for B241 being (Element of B239) holds (for B242 being (Function of B238 , B239) holds ( eval (( B240 * B241 ) , B242) ) = ( ( eval (B240 , B242) ) * B241 ))))))
proof
let C313 being Ordinal;
let C314 being  Abelian  left_zeroed  right_zeroed  add-associative  right_complementable  well-unital  associative  commutative  distributive non  trivial doubleLoopStr;
let C315 being (Polynomial of C313 , C314);
let C316 being (Element of C314);
let C317 being (Function of C313 , C314);
thus L1113: ( eval (( C315 * C316 ) , C317) ) = ( eval (( C315 *' ( C316 | (C313 , C314) ) ) , C317) ) by L969
.= ( ( eval (C315 , C317) ) * C316 ) by L1029;
end;
theorem
L1114: (for B243 being Ordinal holds (for B244 being  left_zeroed  right_zeroed  left_add-cancelable  add-associative  right_complementable  well-unital  associative  commutative  distributive  domRing-like non  trivial doubleLoopStr holds (for B245 being (Polynomial of B243 , B244) holds (for B246 being (Element of B244) holds (for B247 being (Function of B243 , B244) holds ( eval (( B245 * B246 ) , B247) ) = ( ( eval (B245 , B247) ) * B246 ))))))
proof
let C318 being Ordinal;
let C319 being  left_zeroed  right_zeroed  left_add-cancelable  add-associative  right_complementable  well-unital  associative  commutative  distributive  domRing-like non  trivial doubleLoopStr;
let C320 being (Polynomial of C318 , C319);
let C321 being (Element of C319);
let C322 being (Function of C318 , C319);
consider C323 being (FinSequence of (the carrier of C319)) such that L1115: ( len C323 ) = ( len ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) ) and L1116: ( eval (( C320 * C321 ) , C322) ) = ( Sum C323 ) and L1117: (for B248 being (Element of ( NAT )) holds ((1 <= B248 & B248 <= ( len C323 )) implies ( C323 /. B248 ) = ( ( ( ( C320 * C321 ) * ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) ) /. B248 ) * ( eval (( ( ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) /. B248 ) @ ) , C322) ) ))) by POLYNOM2:def 4;
consider C324 being (FinSequence of (the carrier of C319)) such that L1118: ( len C324 ) = ( len ( SgmX (( BagOrder C318 ) , ( Support C320 )) ) ) and L1119: ( eval (C320 , C322) ) = ( Sum C324 ) and L1120: (for B249 being (Element of ( NAT )) holds ((1 <= B249 & B249 <= ( len C324 )) implies ( C324 /. B249 ) = ( ( ( C320 * ( SgmX (( BagOrder C318 ) , ( Support C320 )) ) ) /. B249 ) * ( eval (( ( ( SgmX (( BagOrder C318 ) , ( Support C320 )) ) /. B249 ) @ ) , C322) ) ))) by POLYNOM2:def 4;
L1121:
now
per cases ;
case L1122: C321 = ( 0. C319 );
L1123:
now
let C325 being (bag of C318);
thus L1124: ( ( C320 * C321 ) . C325 ) = ( ( C320 . C325 ) * C321 ) by L878
.= ( 0. C319 ) by L1122 , BINOM:2;
end;
L1125:
now
assume L1126: ( Support ( C320 * C321 ) ) <> ( {} );
reconsider D193 = ( Support ( C320 * C321 ) ) as non  empty (Subset of ( Bags C318 )) by L1126;
set D194 = the (Element of D193);
L1127: ( ( C320 * C321 ) . D194 ) <> ( 0. C319 ) by POLYNOM1:def 3;
thus L1128: contradiction by L1127 , L1123;
end;
L1129: ( BagOrder C318 ) linearly_orders ( Support ( C320 * C321 ) ) by POLYNOM2:18;
L1130: ( rng ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) ) = ( {} ) by L1129 , L1125 , PRE_POLY:def 2;
L1131: ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) = ( {} ) by L1130 , RELAT_1:41;
L1132: C323 = ( <*> (the carrier of C319) ) by L1131 , L1115;
L1133: ( Sum C323 ) = ( 0. C319 ) by L1132 , RLVECT_1:43
.= ( ( Sum C324 ) * C321 ) by L1122 , BINOM:2;
thus L1134: thesis by L1133 , L1116 , L1119;
end;
case L1135: C321 <> ( 0. C319 );
L1136: (for B250 being set holds (B250 in ( Support ( C320 * C321 ) ) implies B250 in ( Support C320 )))
proof
let C326 being set;
assume L1137: C326 in ( Support ( C320 * C321 ) );
reconsider D195 = C326 as (Element of ( Bags C318 )) by L1137;
L1138: ( ( C320 * C321 ) . C326 ) <> ( 0. C319 ) by L1137 , POLYNOM1:def 3;
L1139: ( ( C320 . D195 ) * C321 ) <> ( 0. C319 ) by L1138 , L878;
L1140: ( C320 . D195 ) <> ( 0. C319 ) by L1139 , BINOM:1;
thus L1141: thesis by L1140 , POLYNOM1:def 3;
end;
L1142: (for B251 being set holds (B251 in ( Support C320 ) implies B251 in ( Support ( C320 * C321 ) )))
proof
let C327 being set;
assume L1143: C327 in ( Support C320 );
reconsider D196 = C327 as (Element of ( Bags C318 )) by L1143;
L1144: ( C320 . C327 ) <> ( 0. C319 ) by L1143 , POLYNOM1:def 3;
L1145: ( ( C320 . D196 ) * C321 ) <> ( 0. C319 ) by L1144 , L1135 , VECTSP_2:def 1;
L1146: ( ( C320 * C321 ) . D196 ) <> ( 0. C319 ) by L1145 , L878;
thus L1147: thesis by L1146 , POLYNOM1:def 3;
end;
L1148: ( len C324 ) = ( len C323 ) by L1142 , L1115 , L1118 , L1136 , TARSKI:1;
L1149: ( dom C324 ) = ( Seg ( len C323 ) ) by L1148 , FINSEQ_1:def 3
.= ( dom C323 ) by FINSEQ_1:def 3;
L1150: ( BagOrder C318 ) linearly_orders ( Support ( C320 * C321 ) ) by POLYNOM2:18;
L1151: ( Support ( C320 * C321 ) ) = ( Support C320 ) by L1142 , L1136 , TARSKI:1;
L1152:
now
L1153: ( dom ( C320 * C321 ) ) = ( Bags C318 ) by FUNCT_2:def 1;
L1154:
now
let C328 being set;
assume L1155: C328 in ( rng ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) );
L1156: C328 in ( Support ( C320 * C321 ) ) by L1155 , L1150 , PRE_POLY:def 2;
thus L1157: C328 in ( dom ( C320 * C321 ) ) by L1156 , L1153;
end;
L1158: ( rng ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) ) c= ( dom ( C320 * C321 ) ) by L1154 , TARSKI:def 3;
reconsider D197 = ( ( C320 * C321 ) * ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) ) as FinSequence by L1158 , FINSEQ_1:16;
L1159: (for B252 being set holds (B252 in ( rng D197 ) implies B252 in (the carrier of C319)))
proof
let C329 being set;
assume L1160: C329 in ( rng D197 );
L1161: C329 in ( rng ( C320 * C321 ) ) by L1160 , FUNCT_1:14;
L1162: ( rng ( C320 * C321 ) ) c= (the carrier of C319) by RELAT_1:def 19;
thus L1163: thesis by L1162 , L1161;
end;
L1164: ( rng D197 ) c= (the carrier of C319) by L1159 , TARSKI:def 3;
L1165: ( dom C320 ) = ( Bags C318 ) by FUNCT_2:def 1;
L1166:
now
let C330 being set;
assume L1167: C330 in ( rng ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) );
L1168: C330 in ( Support ( C320 * C321 ) ) by L1167 , L1150 , PRE_POLY:def 2;
thus L1169: C330 in ( dom C320 ) by L1168 , L1165;
end;
L1170: ( rng ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) ) c= ( dom C320 ) by L1166 , TARSKI:def 3;
reconsider D198 = ( C320 * ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) ) as FinSequence by L1170 , FINSEQ_1:16;
L1171: (for B253 being set holds (B253 in ( rng D198 ) implies B253 in (the carrier of C319)))
proof
let C331 being set;
assume L1172: C331 in ( rng D198 );
L1173: C331 in ( rng C320 ) by L1172 , FUNCT_1:14;
L1174: ( rng C320 ) c= (the carrier of C319) by RELAT_1:def 19;
thus L1175: thesis by L1174 , L1173;
end;
L1176: ( rng D198 ) c= (the carrier of C319) by L1171 , TARSKI:def 3;
reconsider D199 = D197 as (FinSequence of (the carrier of C319)) by L1164 , FINSEQ_1:def 4;
reconsider D200 = D198 as (FinSequence of (the carrier of C319)) by L1176 , FINSEQ_1:def 4;
let C332 being set;
assume L1177: C332 in ( dom C324 );
L1178: C332 in ( Seg ( len C324 ) ) by L1177 , FINSEQ_1:def 3;
L1179: C332 in { B254 where B254 is (Element of ( NAT )) : (1 <= B254 & B254 <= ( len C324 )) } by L1178 , FINSEQ_1:def 1;
consider C333 being (Element of ( NAT )) such that L1180: C332 = C333 and L1181: (1 <= C333 & C333 <= ( len C324 )) by L1179;
L1182: ( dom C324 ) = ( Seg ( len ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) ) ) by L1115 , L1149 , FINSEQ_1:def 3
.= ( dom ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) ) by FINSEQ_1:def 3;
L1183: ( ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) . C333 ) = ( ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) /. C333 ) by L1182 , L1177 , L1180 , PARTFUN1:def 6;
L1184: C333 in ( dom D200 ) by L1183 , L1177 , L1180 , L1182 , L1165 , FUNCT_1:11;
L1185: ( ( C320 * ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) ) /. C333 ) = ( D200 . C333 ) by L1184 , PARTFUN1:def 6
.= ( C320 . ( ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) . C333 ) ) by L1177 , L1180 , L1182 , FUNCT_1:13
.= ( C320 . ( ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) /. C333 ) ) by L1177 , L1180 , L1182 , PARTFUN1:def 6;
reconsider D201 = ( ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) /. C333 ) as (Element of ( Bags C318 ));
reconsider D202 = D201 as (bag of C318);
L1186: ( ( C324 /. C333 ) * C321 ) = ( ( ( ( C320 * ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) ) /. C333 ) * ( eval (( ( ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) /. C333 ) @ ) , C322) ) ) * C321 ) by L1120 , L1151 , L1181
.= ( ( ( ( C320 * ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) ) /. C333 ) * C321 ) * ( eval (( ( ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) /. C333 ) @ ) , C322) ) ) by GROUP_1:def 3;
L1187: ( ( C320 * C321 ) . ( ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) /. C333 ) ) = ( ( C320 * C321 ) . D202 )
.= ( ( ( C320 * ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) ) /. C333 ) * C321 ) by L1185 , L878;
L1188: ( ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) . C333 ) = ( ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) /. C333 ) by L1177 , L1180 , L1182 , PARTFUN1:def 6;
L1189: C333 in ( dom D199 ) by L1188 , L1177 , L1180 , L1182 , L1153 , FUNCT_1:11;
L1190: ( ( ( C320 * C321 ) * ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) ) /. C333 ) = ( D199 . C333 ) by L1189 , PARTFUN1:def 6
.= ( ( C320 * C321 ) . ( ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) . C333 ) ) by L1177 , L1180 , L1182 , FUNCT_1:13
.= ( ( ( C320 * ( SgmX (( BagOrder C318 ) , ( Support ( C320 * C321 ) )) ) ) /. C333 ) * C321 ) by L1177 , L1180 , L1182 , L1187 , PARTFUN1:def 6;
thus L1191: ( C323 /. C332 ) = ( ( C324 /. C332 ) * C321 ) by L1190 , L1117 , L1148 , L1180 , L1181 , L1186;
end;
L1192: C323 = ( C324 * C321 ) by L1152 , L1149 , POLYNOM1:def 2;
thus L1193: thesis by L1192 , L1116 , L1119 , BINOM:5;
end;
end;
thus L1195: thesis by L1121;
end;
theorem
L1196: (for B255 being Ordinal holds (for B256 being  Abelian  left_zeroed  right_zeroed  add-associative  right_complementable  well-unital  associative  commutative  distributive non  trivial doubleLoopStr holds (for B257 being (Polynomial of B255 , B256) holds (for B258 being (Element of B256) holds (for B259 being (Function of B255 , B256) holds ( eval (( ( B258 | (B255 , B256) ) *' B257 ) , B259) ) = ( B258 * ( eval (B257 , B259) ) )))))) by L1027;
theorem
L1197: (for B260 being Ordinal holds (for B261 being  Abelian  left_zeroed  right_zeroed  add-associative  right_complementable  well-unital  associative  commutative  distributive non  trivial doubleLoopStr holds (for B262 being (Polynomial of B260 , B261) holds (for B263 being (Element of B261) holds (for B264 being (Function of B260 , B261) holds ( eval (( B262 *' ( B263 | (B260 , B261) ) ) , B264) ) = ( ( eval (B262 , B264) ) * B263 ))))))
proof
let C334 being Ordinal;
let C335 being  left_zeroed  right_zeroed  add-associative  right_complementable  well-unital  associative  commutative  Abelian  distributive non  trivial doubleLoopStr;
let C336 being (Polynomial of C334 , C335);
let C337 being (Element of C335);
let C338 being (Function of C334 , C335);
thus L1198: ( eval (( C336 *' ( C337 | (C334 , C335) ) ) , C338) ) = ( ( eval (C336 , C338) ) * ( eval (( C337 | (C334 , C335) ) , C338) ) ) by POLYNOM2:25
.= ( ( eval (C336 , C338) ) * C337 ) by L867;
end;
