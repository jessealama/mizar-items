:: On the Composition of non-parahalting Macro Instructions
::  by Piotr Rudnicki
::
:: Received June 3, 1998
:: Copyright (c) 1998-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies AMI_1, SCMFSA_2, SCMFSA7B, SCMFSA6A, SF_MASTR, GRAPHSP, AMI_3,
      SCMFSA6B, AOFA_I00, SCMFSA8C, SCMFSA8B, SCMFSA8A, CARD_1,
      AMISTD_2, RELAT_1, TARSKI, XXREAL_0, ARYTM_3, FSM_1, XBOOLE_0, FUNCT_4,
      NUMBERS, SCMFSA6C, UNIALG_2, CIRCUIT2, FUNCT_1, MSUALG_1, SUBSET_1,
      NAT_1, STRUCT_0, FINSET_1, EXTPRO_1, PRE_FF, ARYTM_1,
      SFMASTR1, PARTFUN1, RELOC, FUNCOP_1, COMPOS_1, SCMPDS_4;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS,
      XCMPLX_0, FINSET_1, ORDINAL1, NAT_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2,
      FUNCT_4, FUNCOP_1, PBOOLE, VALUED_1, FUNCT_7, PRE_FF, AMI_2,
      STRUCT_0, MEMSTR_0, COMPOS_0, COMPOS_1,
      EXTPRO_1, AMISTD_1, AMISTD_2, SCMFSA_1, SCMFSA_2, SCMFSA6A, SCMFSA6B,
      SF_MASTR, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B, SCMFSA8C, XXREAL_0,
      SEQ_4, SCMFSA_M;
 constructors DOMAIN_1, SETWISEO, SEQ_4, PRE_FF, SCM_1, SCMFSA6A, SF_MASTR,
      SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMFSA8C, RELSET_1, PRE_POLY,
      AMISTD_2, SCMFSA7B, SCMFSA_1, PBOOLE, AMISTD_1, COMPLEX1, INT_2, NAT_D,
      XXREAL_1, MEMSTR_0, SCMFSA_M, FUNCT_7;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, FUNCT_1, ORDINAL1, FINSET_1,
      NUMBERS, XREAL_0, NAT_1, INT_1, MEMBERED, AMI_5, SCMFSA_2, SF_MASTR,
      SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8C, SCMFSA_9, XXREAL_2,
      RELAT_1, SCMFSA10, AMISTD_2, COMPOS_1, EXTPRO_1, PBOOLE, FUNCT_4,
      FUNCOP_1, SCMFSA6A, STRUCT_0, MEMSTR_0, FINSEQ_1, AMI_3, COMPOS_0,
      SCMFSA_M;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions EXTPRO_1, COMPOS_1, SCMFSA_2, SCMFSA7B, FUNCOP_1, SCMFSA6A,
      MEMSTR_0, COMPOS_0, SCMFSA_M;
 theorems TARSKI, ZFMISC_1, ENUMSET1, NAT_1, RELAT_1, FUNCT_1, GRFUNC_1,
      FUNCT_4, PRE_FF, SCMFSA_2, MEMSTR_0, SCMFSA6A, SCMFSA6B, SF_MASTR,
      SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B, SCMFSA8C, XBOOLE_0, XBOOLE_1,
      XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0, PBOOLE, PARTFUN1, COMPOS_1,
      EXTPRO_1, AMI_2, COMPOS_0, SCMFSA_M;
 schemes NAT_1;

begin
definition
let C1 being (Instruction of ( SCM+FSA ));
attr C1 is  good
means
:L1: ( Macro C1 ) is  good;
end;
registration
let C2 being  read-write Int-Location;
let C3 being Int-Location;
cluster ( C2 := C3 ) ->  good;
coherence
proof
thus L3: ( Macro ( C2 := C3 ) ) is  good by SCMFSA7B:6 , SCMFSA8C:70;
end;
cluster ( AddTo (C2 , C3) ) ->  good;
coherence
proof
thus L4: ( Macro ( AddTo (C2 , C3) ) ) is  good by SCMFSA7B:7 , SCMFSA8C:70;
end;
cluster ( SubFrom (C2 , C3) ) ->  good;
coherence
proof
thus L5: ( Macro ( SubFrom (C2 , C3) ) ) is  good by SCMFSA7B:8 , SCMFSA8C:70;
end;
cluster ( MultBy (C2 , C3) ) ->  good;
coherence
proof
thus L6: ( Macro ( MultBy (C2 , C3) ) ) is  good by SCMFSA7B:9 , SCMFSA8C:70;
end;
end;
registration
cluster  good  parahalting for (Instruction of ( SCM+FSA ));
existence
proof
set D1 = the  read-write Int-Location;
L8: ( D1 := D1 ) is  good  parahalting;
thus L9: thesis by L8;
end;
end;
registration
let C4 , C5 being  read-write Int-Location;
cluster ( Divide (C4 , C5) ) ->  good;
coherence
proof
thus L11: ( Macro ( Divide (C4 , C5) ) ) is  good by SCMFSA7B:10 , SCMFSA8C:70;
end;
end;
registration
let C6 being (Element of ( NAT ));
cluster ( goto C6 ) ->  good;
coherence
proof
thus L13: ( Macro ( goto C6 ) ) is  good by SCMFSA7B:11 , SCMFSA8C:70;
end;
end;
registration
let C7 being Int-Location;
let C8 being (Element of ( NAT ));
cluster ( C7 =0_goto C8 ) ->  good;
coherence
proof
thus L15: ( Macro ( C7 =0_goto C8 ) ) is  good by SCMFSA7B:12 , SCMFSA8C:70;
end;
cluster ( C7 >0_goto C8 ) ->  good;
coherence
proof
thus L16: ( Macro ( C7 >0_goto C8 ) ) is  good by SCMFSA7B:13 , SCMFSA8C:70;
end;
end;
registration
let C9 being Int-Location;
let C10 being FinSeq-Location;
let C11 being  read-write Int-Location;
cluster ( C11 := (C10 , C9) ) ->  good;
coherence
proof
thus L18: ( Macro ( C11 := (C10 , C9) ) ) is  good by SCMFSA7B:14 , SCMFSA8C:70;
end;
end;
registration
let C12 being FinSeq-Location;
let C13 being  read-write Int-Location;
cluster ( C13 :=len C12 ) ->  good;
coherence
proof
thus L20: ( Macro ( C13 :=len C12 ) ) is  good by SCMFSA7B:16 , SCMFSA8C:70;
end;
end;
registration
let C14 being FinSeq-Location;
let C15 being Int-Location;
cluster ( C14 :=<0,...,0> C15 ) ->  good;
coherence
proof
thus L22: ( Macro ( C14 :=<0,...,0> C15 ) ) is  good by SCMFSA7B:17 , SCMFSA8C:70;
end;
let C16 being Int-Location;
cluster ( (C14 , C15) := C16 ) ->  good;
coherence
proof
thus L23: ( Macro ( (C14 , C15) := C16 ) ) is  good by SCMFSA7B:15 , SCMFSA8C:70;
end;
end;
registration
let C17 being  good (Instruction of ( SCM+FSA ));
cluster ( Macro C17 ) ->  good;
coherence by L1;
end;
registration
let C18 , C19 being  good (Instruction of ( SCM+FSA ));
cluster ( C18 ";" C19 ) ->  good;
coherence;
end;
registration
let C20 being  good (Instruction of ( SCM+FSA ));
let C21 being  good (Program of ( SCM+FSA ));
cluster ( C20 ";" C21 ) ->  good;
coherence;
cluster ( C21 ";" C20 ) ->  good;
coherence;
end;
registration
let C22 , C23 being  read-write Int-Location;
cluster ( swap (C22 , C23) ) ->  good;
coherence
proof
L28: ( swap (C22 , C23) ) = ( ( ( ( FirstNotUsed ( Macro ( C22 := C23 ) ) ) := C22 ) ";" ( C22 := C23 ) ) ";" ( C23 := ( FirstNotUsed ( Macro ( C22 := C23 ) ) ) ) ) by SCMFSA6C:def 3;
thus L29: thesis by L28;
end;
end;
registration
let C24 being  good (Program of ( SCM+FSA ));
let C25 being  read-write Int-Location;
cluster ( Times (C25 , C24) ) ->  good;
coherence
proof
reconsider D2 = ( if=0 (C25 , ( Goto 2 ) , ( C24 ";" ( SubFrom (C25 , ( intloc ( 0 ) )) ) )) ) as  good (Program of ( SCM+FSA ));
L31: ( if>0 (C25 , ( loop D2 ) , ( Stop ( SCM+FSA ) )) ) is  good;
thus L32: thesis by L31 , SCMFSA8C:def 2;
end;
end;
theorem
L34: (for B1 being Int-Location holds (for B2 being (Program of ( SCM+FSA )) holds ((not B1 in ( UsedIntLoc B2 )) implies (not B2 destroy B1))))
proof
let C26 being Int-Location;
let C27 being (Program of ( SCM+FSA ));
assume that
L35: (not C26 in ( UsedIntLoc C27 ));
let C28 being (Instruction of ( SCM+FSA ));
assume L36: C28 in ( rng C27 );
L37: ( UsedIntLoc C28 ) c= ( UsedIntLoc C27 ) by L36 , SF_MASTR:19;
L38: (not C26 in ( UsedIntLoc C28 )) by L37 , L35;
L39: ( InsCode C28 ) <= 12 by SCMFSA_2:16;
per cases  by L39 , NAT_1:36;
suppose L40: ( InsCode C28 ) = ( 0 );

L41: C28 = ( halt ( SCM+FSA ) ) by L40 , SCMFSA_2:95;
thus L42: thesis by L41 , SCMFSA7B:5;
end;
suppose L43: ( InsCode C28 ) = 1;

consider C29 , C30 being Int-Location such that L44: C28 = ( C29 := C30 ) by L43 , SCMFSA_2:30;
L45: ( UsedIntLoc C28 ) = { C29 , C30 } by L44 , SF_MASTR:14;
L46: C29 in ( UsedIntLoc C28 ) by L45 , TARSKI:def 2;
thus L47: thesis by L46 , L38 , L44 , SCMFSA7B:6;
end;
suppose L48: ( InsCode C28 ) = 2;

consider C31 , C32 being Int-Location such that L49: C28 = ( AddTo (C31 , C32) ) by L48 , SCMFSA_2:31;
L50: ( UsedIntLoc C28 ) = { C31 , C32 } by L49 , SF_MASTR:14;
L51: C31 in ( UsedIntLoc C28 ) by L50 , TARSKI:def 2;
thus L52: thesis by L51 , L38 , L49 , SCMFSA7B:7;
end;
suppose L53: ( InsCode C28 ) = 3;

consider C33 , C34 being Int-Location such that L54: C28 = ( SubFrom (C33 , C34) ) by L53 , SCMFSA_2:32;
L55: ( UsedIntLoc C28 ) = { C33 , C34 } by L54 , SF_MASTR:14;
L56: C33 in ( UsedIntLoc C28 ) by L55 , TARSKI:def 2;
thus L57: thesis by L56 , L38 , L54 , SCMFSA7B:8;
end;
suppose L58: ( InsCode C28 ) = 4;

consider C35 , C36 being Int-Location such that L59: C28 = ( MultBy (C35 , C36) ) by L58 , SCMFSA_2:33;
L60: ( UsedIntLoc C28 ) = { C35 , C36 } by L59 , SF_MASTR:14;
L61: C35 in ( UsedIntLoc C28 ) by L60 , TARSKI:def 2;
thus L62: thesis by L61 , L38 , L59 , SCMFSA7B:9;
end;
suppose L63: ( InsCode C28 ) = 5;

consider C37 , C38 being Int-Location such that L64: C28 = ( Divide (C37 , C38) ) by L63 , SCMFSA_2:34;
L65: ( UsedIntLoc C28 ) = { C37 , C38 } by L64 , SF_MASTR:14;
L66: C38 in ( UsedIntLoc C28 ) by L65 , TARSKI:def 2;
L67: C37 in ( UsedIntLoc C28 ) by L65 , TARSKI:def 2;
thus L68: thesis by L67 , L38 , L64 , L66 , SCMFSA7B:10;
end;
suppose L69: ( InsCode C28 ) = 6;

L70: (ex B3 being (Element of ( NAT )) st C28 = ( goto B3 )) by L69 , SCMFSA_2:35;
thus L71: thesis by L70 , SCMFSA7B:11;
end;
suppose L72: ( InsCode C28 ) = 7;

L73: (ex B4 being (Element of ( NAT )) st (ex B5 being Int-Location st C28 = ( B5 =0_goto B4 ))) by L72 , SCMFSA_2:36;
thus L74: thesis by L73 , SCMFSA7B:12;
end;
suppose L75: ( InsCode C28 ) = 8;

L76: (ex B6 being (Element of ( NAT )) st (ex B7 being Int-Location st C28 = ( B7 >0_goto B6 ))) by L75 , SCMFSA_2:37;
thus L77: thesis by L76 , SCMFSA7B:13;
end;
suppose L78: ( InsCode C28 ) = 9;

consider C39 , C40 being Int-Location, C41 being FinSeq-Location such that L79: C28 = ( C40 := (C41 , C39) ) by L78 , SCMFSA_2:38;
L80: ( UsedIntLoc C28 ) = { C39 , C40 } by L79 , SF_MASTR:17;
L81: C40 in ( UsedIntLoc C28 ) by L80 , TARSKI:def 2;
thus L82: thesis by L81 , L38 , L79 , SCMFSA7B:14;
end;
suppose L83: ( InsCode C28 ) = 10;

L84: (ex B8 , B9 being Int-Location st (ex B10 being FinSeq-Location st C28 = ( (B10 , B8) := B9 ))) by L83 , SCMFSA_2:39;
thus L85: thesis by L84 , SCMFSA7B:15;
end;
suppose L86: ( InsCode C28 ) = 11;

consider C42 being Int-Location, C43 being FinSeq-Location such that L87: C28 = ( C42 :=len C43 ) by L86 , SCMFSA_2:40;
L88: ( UsedIntLoc C28 ) = { C42 } by L87 , SF_MASTR:18;
L89: C42 in ( UsedIntLoc C28 ) by L88 , TARSKI:def 1;
thus L90: thesis by L89 , L38 , L87 , SCMFSA7B:16;
end;
suppose L91: ( InsCode C28 ) = 12;

L92: (ex B11 being Int-Location st (ex B12 being FinSeq-Location st C28 = ( B12 :=<0,...,0> B11 ))) by L91 , SCMFSA_2:41;
thus L93: thesis by L92 , SCMFSA7B:17;
end;
end;
begin
set D3 = ( Data-Locations ( SCM+FSA ) );
set D4 = ( Start-At (( 0 ) , ( SCM+FSA )) );
theorem
L95: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being (State of ( SCM+FSA )) holds (for R7 being (Program of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds ((R7 is_halting_on ( Initialized R6 ) , R2 & R7 is_closed_on ( Initialized R6 ) , R2 & R8 is_closed_on ( IExec (R7 , R2 , R6) ) , R2) implies ( R7 ";" R8 ) is_closed_on ( Initialized R6 ) , R2)))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being (State of ( SCM+FSA ));
let R7 being (Program of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
assume that
L96: R7 is_halting_on ( Initialized R6 ) , R2
and
L97: R7 is_closed_on ( Initialized R6 ) , R2
and
L98: R8 is_closed_on ( IExec (R7 , R2 , R6) ) , R2;
set D5 = ( Initialized R6 );
set D6 = R2;
set D7 = ( Initialize D5 );
set D8 = ( R2 +* ( R7 ";" R8 ) );
L99: ( R7 ";" R8 ) c= D8 by FUNCT_4:25;
L100: ( Directed R7 ) c= ( R7 ";" R8 ) by SCMFSA6A:16;
L101: ( R7 ";" R8 ) c= D8 by FUNCT_4:25;
L102: ( Directed R7 ) c= D8 by L101 , L100 , XBOOLE_1:1;
L103: ( D8 +* ( Directed R7 ) ) = D8 by L102 , FUNCT_4:98;
L104: ( DataPart D5 ) = ( DataPart D7 ) by MEMSTR_0:79;
L105: R7 is_closed_on D7 , D8 by L104 , L97 , SCMFSA8B:3;
L106: R7 is_halting_on D7 , D8 by L96 , L97 , L104 , SCMFSA8B:5;
L107: ( D8 +* R7 ) halts_on ( Initialize D7 ) by L106 , SCMFSA7B:def 7;
set D9 = ( Initialize D7 );
set D10 = ( D8 +* R7 );
set D11 = ( Start-At (( 0 ) , ( SCM+FSA )) );
set D12 = ( Initialize ( Comput (D10 , D9 , ( LifeSpan (D10 , D9) )) ) );
set D13 = ( D10 +* R8 );
L108: R8 c= D13 by FUNCT_4:25;
set D14 = ( LifeSpan (D10 , D9) );
set D15 = ( R7 ";" R8 );
L109: ( D5 . ( intloc ( 0 ) ) ) = 1 by SCMFSA_M:9;
L110: ( D7 . ( intloc ( 0 ) ) ) = 1 by L109 , L104 , SCMFSA_M:2;
L111: ( Initialized D9 ) = D7 by L110 , SCMFSA_M:18;
L112: ( DataPart ( IExec (R7 , R2 , R6) ) ) = ( DataPart ( IExec (R7 , R2 , D5) ) ) by SCMFSA8C:3
.= ( DataPart ( IExec (R7 , D8 , D7) ) ) by L96 , L97 , L104 , L109 , SCMFSA8C:20
.= ( DataPart ( Result (( D8 +* R7 ) , ( Initialized D7 )) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Comput (D10 , D9 , ( LifeSpan (D10 , D9) )) ) ) by L111 , L107 , EXTPRO_1:23;
L113: ( DataPart ( IExec (R7 , R2 , R6) ) ) = ( DataPart D12 ) by L112 , MEMSTR_0:79;
L114: R8 is_closed_on D12 , D13 by L113 , L98 , SCMFSA8B:3;
set D16 = ( Reloc (R8 , ( card R7 )) );
set D17 = ( Comput (D8 , D7 , ( D14 + 1 )) );
reconsider D18 = ( DataPart D11 ) as Function;
L115: ( DataPart D12 ) = ( ( DataPart ( Comput (D10 , D9 , D14) ) ) +* D18 ) by FUNCT_4:71;
let C44 being (Element of ( NAT ));
L116: ( IC ( Comput (( D8 +* ( Directed R7 ) ) , D7 , ( ( LifeSpan (( D8 +* R7 ) , ( Initialize D7 )) ) + 1 )) ) ) = ( card R7 ) by L105 , L106 , SCMFSA8A:22;
L117: ( IC D17 ) = ( card R7 ) by L116 , L103;
L118: ( DataPart D11 ) = ( {} ) by MEMSTR_0:20;
L119: ( DataPart ( Comput (D10 , D9 , D14) ) ) = ( DataPart D12 ) by L118 , L115 , FUNCT_4:98 , XBOOLE_1:2;
L120: ( DataPart D17 ) = ( DataPart D12 ) by L119 , L105 , L106 , L103 , SCMFSA8A:22;
L121: D16 c= ( R7 ";" R8 ) by FUNCT_4:25;
L122: D16 c= D8 by L99 , L121 , XBOOLE_1:1;
per cases  by NAT_1:13;
suppose L123: C44 <= D14;

L124: ( dom R7 ) c= ( dom D15 ) by SCMFSA6A:17;
L125: ( IC ( Comput (D10 , D9 , C44) ) ) in ( dom R7 ) by L105 , SCMFSA7B:def 6;
L126: ( Comput (D10 , D9 , C44) ) = ( Comput (D8 , D7 , C44) ) by L105 , L106 , L123 , L103 , SCMFSA8A:21;
L127: ( IC ( Comput (D10 , D9 , C44) ) ) = ( IC ( Comput (D8 , D7 , C44) ) ) by L126;
thus L128: thesis by L127 , L125 , L124;
end;
suppose L129: ( D14 + 1 ) <= C44;

consider C45 being Nat such that L130: C44 = ( ( D14 + 1 ) + C45 ) by L129 , NAT_1:10;
reconsider D19 = C45 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D20 = ( IC ( Comput (D13 , D12 , D19) ) ) as (Element of ( NAT ));
L131: D12 = ( Initialize D12 );
L132: ( D13 +* R8 ) = D13;
L133: ( IC ( Comput (D13 , D12 , D19) ) ) in ( dom R8 ) by L132 , L114 , L131 , SCMFSA7B:def 6;
L134: ( dom D16 ) = { ( B13 + ( card R7 ) ) where B13 is (Element of ( NAT )) : B13 in ( dom R8 ) } by COMPOS_1:33;
L135: ( D20 + ( card R7 ) ) in ( dom D16 ) by L134 , L133;
L136: ( dom D16 ) c= ( dom D15 ) by L121 , RELAT_1:11;
L137: ( ( IC ( Comput (D13 , D12 , D19) ) ) + ( card R7 ) ) = ( IC ( Comput (D8 , ( Comput (D8 , D7 , ( D14 + 1 )) ) , D19) ) ) by L117 , L120 , L114 , L108 , L122 , SCMFSA8C:16
.= ( IC ( Comput (D8 , D7 , ( ( D14 + 1 ) + D19 )) ) ) by EXTPRO_1:4;
thus L138: thesis by L137 , L130 , L135 , L136;
end;
end;
theorem
L140: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being (State of ( SCM+FSA )) holds (for R7 being (Program of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds ((R7 is_halting_on ( Initialized R6 ) , R2 & R8 is_halting_on ( IExec (R7 , R2 , R6) ) , R2 & R7 is_closed_on ( Initialized R6 ) , R2 & R8 is_closed_on ( IExec (R7 , R2 , R6) ) , R2) implies ( R7 ";" R8 ) is_halting_on ( Initialized R6 ) , R2)))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being (State of ( SCM+FSA ));
let R7 being (Program of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
assume that
L141: R7 is_halting_on ( Initialized R6 ) , R2
and
L142: R8 is_halting_on ( IExec (R7 , R2 , R6) ) , R2
and
L143: R7 is_closed_on ( Initialized R6 ) , R2
and
L144: R8 is_closed_on ( IExec (R7 , R2 , R6) ) , R2;
set D21 = ( Initialize ( Initialized R6 ) );
set D22 = ( R2 +* ( R7 ";" R8 ) );
L145: ( R7 ";" R8 ) c= D22 by FUNCT_4:25;
L146: ( Directed R7 ) c= ( R7 ";" R8 ) by SCMFSA6A:16;
L147: ( Directed R7 ) c= D22 by L146 , L145 , XBOOLE_1:1;
L148: ( D22 +* ( Directed R7 ) ) = D22 by L147 , FUNCT_4:98;
L149: ( DataPart ( Initialized R6 ) ) = ( DataPart D21 ) by MEMSTR_0:79;
L150: R7 is_halting_on D21 , D22 by L149 , L141 , L143 , SCMFSA8B:5;
L151: ( D22 +* R7 ) halts_on ( Initialize D21 ) by L150 , SCMFSA7B:def 7;
set D23 = ( Initialize D21 );
set D24 = ( D22 +* R7 );
L152: ( ( Initialized R6 ) . ( intloc ( 0 ) ) ) = 1 by SCMFSA_M:9;
L153: ( D21 . ( intloc ( 0 ) ) ) = 1 by L152 , L149 , SCMFSA_M:2;
L154: D23 = ( Initialized D21 ) by L153 , SCMFSA_M:18;
set D25 = ( Start-At (( 0 ) , ( SCM+FSA )) );
set D26 = ( Initialize ( Comput (D24 , D23 , ( LifeSpan (D24 , D23) )) ) );
set D27 = ( D24 +* R8 );
L155: R8 c= D27 by FUNCT_4:25;
set D28 = ( LifeSpan (D27 , D26) );
L156: ( DataPart ( IExec (R7 , R2 , R6) ) ) = ( DataPart ( IExec (R7 , R2 , ( Initialized R6 )) ) ) by SCMFSA8C:3
.= ( DataPart ( IExec (R7 , D22 , D21) ) ) by L141 , L143 , L149 , L152 , SCMFSA8C:20
.= ( DataPart ( Result (( D22 +* R7 ) , ( Initialized D21 )) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Result (( D22 +* R7 ) , ( Initialized D21 )) ) )
.= ( DataPart ( Comput (D24 , D23 , ( LifeSpan (D24 , D23) )) ) ) by L154 , L151 , EXTPRO_1:23;
L157: R8 is_halting_on ( Comput (D24 , D23 , ( LifeSpan (D24 , D23) )) ) , D24 by L156 , L142 , L144 , SCMFSA8B:5;
L158: D27 halts_on D26 by L157 , SCMFSA7B:def 7;
L159: ( DataPart ( IExec (R7 , R2 , R6) ) ) = ( DataPart D26 ) by L156 , MEMSTR_0:79;
L160: R8 is_closed_on D26 , D27 by L159 , L144 , SCMFSA8B:3;
L161: ( Reloc (R8 , ( card R7 )) ) c= ( R7 ";" R8 ) by FUNCT_4:25;
set D29 = ( LifeSpan (D24 , D23) );
set D30 = ( Comput (D22 , D21 , ( D29 + 1 )) );
set D31 = D22;
L162: ( Reloc (R8 , ( card R7 )) ) c= D22 by L145 , L161 , XBOOLE_1:1;
reconsider D32 = ( ( D29 + 1 ) + D28 ) as (Element of ( NAT ));
reconsider D33 = ( DataPart D25 ) as Function;
L163: ( DataPart D26 ) = ( ( DataPart ( Comput (D24 , D23 , D29) ) ) +* D33 ) by FUNCT_4:71;
take D32;
L164: ( IC ( Comput (D22 , D21 , D32) ) ) in ( NAT );
thus L165: ( IC ( Comput (D22 , D21 , D32) ) ) in ( dom D22 ) by L164 , PARTFUN1:def 2;
L166: R7 is_closed_on D21 , D22 by L143 , L149 , SCMFSA8B:3;
L167: ( IC D30 ) = ( card R7 ) by L166 , L150 , L148 , SCMFSA8A:22;
L168: ( Comput (D22 , D21 , ( ( D29 + 1 ) + D28 )) ) = ( Comput (D22 , ( Comput (D22 , D21 , ( D29 + 1 )) ) , D28) ) by EXTPRO_1:4;
L169: ( DataPart D25 ) = ( {} ) by MEMSTR_0:20;
L170: ( DataPart ( Comput (D24 , D23 , D29) ) ) = ( DataPart D26 ) by L169 , L163 , FUNCT_4:98 , XBOOLE_1:2;
L171: ( DataPart D30 ) = ( DataPart D26 ) by L170 , L166 , L150 , L148 , SCMFSA8A:22;
L172: ( IncAddr (( CurInstr (D27 , ( Comput (D27 , D26 , D28) )) ) , ( card R7 )) ) = ( CurInstr (D22 , ( Comput (D22 , D30 , D28) )) ) by L171 , L167 , L160 , L162 , L155 , SCMFSA8C:16;
L173: ( IncAddr (( CurInstr (D27 , ( Comput (D27 , D26 , D28) )) ) , ( card R7 )) ) = ( CurInstr (D22 , ( Comput (D22 , D21 , ( ( D29 + 1 ) + D28 )) )) ) by L172 , L168;
L174: ( CurInstr (D22 , ( Comput (D22 , D21 , D32) )) ) = ( IncAddr (( halt ( SCM+FSA ) ) , ( card R7 )) ) by L173 , L158 , EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
thus L175: thesis by L174;
end;
theorem
L176: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R7 being (Program of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds (for B14 being ( 0 ) -started (State of ( SCM+FSA )) holds ((R7 is_closed_on B14 , R1 & R7 c= R1 & R1 halts_on B14) implies (for B15 being (Element of ( NAT )) holds (B15 <= ( LifeSpan (R1 , B14) ) implies ( Comput (R1 , B14 , B15) ) = ( Comput (( R1 +* ( R7 ";" R8 ) ) , B14 , B15) ))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R7 being (Program of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
let C46 being ( 0 ) -started (State of ( SCM+FSA ));
assume that
L177: R7 is_closed_on C46 , R1
and
L178: R7 c= R1
and
L179: R1 halts_on C46;
L180: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C46 by MEMSTR_0:29;
L181: ( R1 +* R7 ) = R1 by L178 , FUNCT_4:98;
defpred S1[ (Element of ( NAT )) ] means ($1 <= ( LifeSpan (R1 , C46) ) implies ( Comput (R1 , C46 , $1) ) = ( Comput (( R1 +* ( R7 ";" R8 ) ) , C46 , $1) ));
L182: (for B16 being (Element of ( NAT )) holds (S1[ B16 ] implies S1[ ( B16 + 1 ) ]))
proof
L183: ( dom ( R7 ";" R8 ) ) = ( ( dom ( Directed R7 ) ) \/ ( dom ( Reloc (R8 , ( card R7 )) ) ) ) by FUNCT_4:def 1
.= ( ( dom R7 ) \/ ( dom ( Reloc (R8 , ( card R7 )) ) ) ) by FUNCT_4:99;
L184: ( dom R7 ) c= ( dom ( R7 ";" R8 ) ) by L183 , XBOOLE_1:7;
set D34 = C46;
set D35 = ( R1 +* ( R7 ";" R8 ) );
L185: ( R7 ";" R8 ) c= D35 by FUNCT_4:25;
let C47 being (Element of ( NAT ));
assume L186: (C47 <= ( LifeSpan (R1 , C46) ) implies ( Comput (R1 , C46 , C47) ) = ( Comput (( R1 +* ( R7 ";" R8 ) ) , C46 , C47) ));
L187: ( Comput (D35 , D34 , ( C47 + 1 )) ) = ( Following (D35 , ( Comput (D35 , D34 , C47) )) ) by EXTPRO_1:3;
L188: ( Comput (R1 , C46 , ( C47 + 1 )) ) = ( Following (R1 , ( Comput (R1 , C46 , C47) )) ) by EXTPRO_1:3;
L189: ( R1 /. ( IC ( Comput (R1 , C46 , C47) ) ) ) = ( R1 . ( IC ( Comput (R1 , C46 , C47) ) ) ) by PBOOLE:143;
assume L190: ( C47 + 1 ) <= ( LifeSpan (R1 , C46) );
L191: ( IC ( Comput (R1 , C46 , C47) ) ) = ( IC ( Comput (D35 , D34 , C47) ) ) by L190 , L186 , NAT_1:13;
L192: C46 = ( Initialize C46 ) by L180 , FUNCT_4:98;
L193: ( IC ( Comput (R1 , C46 , C47) ) ) in ( dom R7 ) by L192 , L177 , L181 , SCMFSA7B:def 6;
L194: ( CurInstr (R1 , ( Comput (R1 , C46 , C47) )) ) = ( R7 . ( IC ( Comput (R1 , C46 , C47) ) ) ) by L193 , L189 , L178 , GRFUNC_1:2;
L195: ( D35 /. ( IC ( Comput (D35 , D34 , C47) ) ) ) = ( D35 . ( IC ( Comput (D35 , D34 , C47) ) ) ) by PBOOLE:143;
L196: C47 < ( LifeSpan (R1 , C46) ) by L190 , NAT_1:13;
L197: ( R7 . ( IC ( Comput (R1 , C46 , C47) ) ) ) <> ( halt ( SCM+FSA ) ) by L196 , L179 , L194 , EXTPRO_1:def 15;
L198: ( CurInstr (R1 , ( Comput (R1 , C46 , C47) )) ) = ( ( R7 ";" R8 ) . ( IC ( Comput (R1 , C46 , C47) ) ) ) by L197 , L193 , L194 , SCMFSA6A:15
.= ( CurInstr (D35 , ( Comput (D35 , D34 , C47) )) ) by L191 , L193 , L184 , L195 , L185 , GRFUNC_1:2;
thus L199: thesis by L198 , L186 , L190 , L188 , L187 , NAT_1:13;
end;
L200: S1[ ( 0 ) ];
thus L201: (for B17 being (Element of ( NAT )) holds S1[ B17 ]) from NAT_1:sch 1(L200 , L182);
end;
L202: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B18 being  good (Program of ( SCM+FSA )) holds (for B19 being (Program of ( SCM+FSA )) holds (for B20 being (State of ( SCM+FSA )) holds ((( B20 . ( intloc ( 0 ) ) ) = 1 & B18 is_halting_on B20 , R1 & B19 is_halting_on ( IExec (B18 , R1 , B20) ) , R1 & B18 is_closed_on B20 , R1 & B19 is_closed_on ( IExec (B18 , R1 , B20) ) , R1 & ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= B20 & ( B18 ";" B19 ) c= R1) implies (( IC ( Comput (R1 , B20 , ( ( LifeSpan (( R1 +* B18 ) , B20) ) + 1 )) ) ) = ( card B18 ) & ( DataPart ( Comput (R1 , B20 , ( ( LifeSpan (( R1 +* B18 ) , B20) ) + 1 )) ) ) = ( DataPart ( Initialized ( Comput (( R1 +* B18 ) , B20 , ( LifeSpan (( R1 +* B18 ) , B20) )) ) ) ) & ( Reloc (B19 , ( card B18 )) ) c= R1 & ( ( Comput (R1 , B20 , ( ( LifeSpan (( R1 +* B18 ) , B20) ) + 1 )) ) . ( intloc ( 0 ) ) ) = 1 & R1 halts_on B20 & ( LifeSpan (R1 , B20) ) = ( ( ( LifeSpan (( R1 +* B18 ) , B20) ) + 1 ) + ( LifeSpan (( ( R1 +* B18 ) +* B19 ) , ( Initialized ( Result (( R1 +* B18 ) , B20) ) )) ) ) & (B19 is  good implies ( ( Result (R1 , B20) ) . ( intloc ( 0 ) ) ) = 1)))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C48 being  good (Program of ( SCM+FSA ));
let C49 being (Program of ( SCM+FSA ));
let C50 being (State of ( SCM+FSA ));
assume that
L203: ( C50 . ( intloc ( 0 ) ) ) = 1
and
L204: C48 is_halting_on C50 , R1
and
L205: C49 is_halting_on ( IExec (C48 , R1 , C50) ) , R1
and
L206: C48 is_closed_on C50 , R1
and
L207: C49 is_closed_on ( IExec (C48 , R1 , C50) ) , R1;
set D36 = C50;
set D37 = ( R1 +* C48 );
set D38 = ( LifeSpan (D37 , D36) );
set D39 = ( Comput (R1 , C50 , ( D38 + 1 )) );
set D40 = R1;
assume L208: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= C50;
L209: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C50 by L208 , MEMSTR_0:50;
L210: D4 c= C50 by L209;
L211: C50 = ( C50 +* D4 ) by L210 , FUNCT_4:98
.= ( Initialize C50 );
L212: ( R1 +* C48 ) halts_on C50 by L211 , L204 , SCMFSA7B:def 7;
assume L213: ( C48 ";" C49 ) c= R1;
L214: ( Directed C48 ) c= ( C48 ";" C49 ) by SCMFSA6A:16;
L215: ( Directed C48 ) c= R1 by L214 , L213 , XBOOLE_1:1;
L216: ( R1 +* ( Directed C48 ) ) = R1 by L215 , FUNCT_4:98;
L217: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C50 by L208 , MEMSTR_0:50;
L218: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C50 by L217;
L219: C50 = ( Initialize C50 ) by L218 , FUNCT_4:98;
thus L220: ( IC D39 ) = ( card C48 ) by L219 , L204 , L206 , L216 , SCMFSA8A:22;
set D41 = ( Start-At (( 0 ) , ( SCM+FSA )) );
set D42 = ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) );
set D43 = ( Initialized ( Comput (D37 , D36 , D38) ) );
set D44 = ( D37 +* C49 );
L221: C49 c= D44 by FUNCT_4:25;
reconsider D45 = ( DataPart D41 ) as Function;
L222: ( DataPart D41 ) = ( {} ) by MEMSTR_0:20;
L223: ( ( Comput (D37 , D36 , D38) ) . ( intloc ( 0 ) ) ) = ( C50 . ( intloc ( 0 ) ) ) by L206 , L211 , SCMFSA8C:68;
L224: D43 = ( Initialize ( Comput (D37 , D36 , D38) ) ) by L223 , L203 , SCMFSA_M:18;
L225: ( DataPart D43 ) = ( ( DataPart ( Comput (D37 , D36 , D38) ) ) +* D45 ) by L224 , FUNCT_4:71;
L226: ( DataPart ( Comput (D37 , D36 , D38) ) ) = ( DataPart D43 ) by L225 , L222 , FUNCT_4:98 , XBOOLE_1:2;
thus L227: ( DataPart D39 ) = ( DataPart D43 ) by L226 , L204 , L206 , L211 , L216 , SCMFSA8A:22;
L228: ( Reloc (C49 , ( card C48 )) ) c= ( C48 ";" C49 ) by FUNCT_4:25;
L229: ( intloc ( 0 ) ) in ( dom D42 ) by SCMFSA_M:10;
L230: D36 = ( C50 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L208 , FUNCT_4:98;
L231: ( DataPart ( IExec (C48 , R1 , C50) ) ) = ( DataPart ( Result (( R1 +* C48 ) , ( Initialized C50 )) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Comput (D37 , D36 , ( LifeSpan (D37 , D36) )) ) ) by L212 , L230 , EXTPRO_1:23;
L232: C49 is_halting_on ( Comput (D37 , D36 , ( LifeSpan (D37 , D36) )) ) , D37 by L231 , L205 , L207 , SCMFSA8B:5;
L233: D44 halts_on D43 by L232 , L224 , SCMFSA7B:def 7;
L234: ( C48 ";" C49 ) c= R1 by L213;
L235: ( Reloc (C49 , ( card C48 )) ) c= R1 by L234 , L228 , XBOOLE_1:1;
L236: ( Reloc (C49 , ( card C48 )) ) c= R1 by L235;
thus L237: ( Reloc (C49 , ( card C48 )) ) c= R1 by L236;
L238: ( Reloc (C49 , ( card C48 )) ) c= R1 by L213 , L228 , XBOOLE_1:1;
L239: ( intloc ( 0 ) ) in ( Int-Locations ) by AMI_2:def 16;
L240: ( intloc ( 0 ) ) in D3 by L239 , SCMFSA_2:100 , XBOOLE_0:def 3;
thus L241: ( D39 . ( intloc ( 0 ) ) ) = ( ( DataPart D43 ) . ( intloc ( 0 ) ) ) by L240 , L227 , FUNCT_1:49
.= ( D43 . ( intloc ( 0 ) ) ) by L240 , FUNCT_1:49
.= 1 by L229 , FUNCT_4:13 , SCMFSA_M:12;
set D46 = ( LifeSpan (D44 , D43) );
reconsider D47 = ( ( D38 + 1 ) + D46 ) as (Element of ( NAT ));
L242: ( DataPart ( IExec (C48 , R1 , C50) ) ) = ( DataPart D43 ) by L224 , L231 , MEMSTR_0:79;
L243: C49 is_closed_on D43 , D44 by L242 , L207 , SCMFSA8B:3;
L244: ( Comput (R1 , C50 , ( ( D38 + 1 ) + D46 )) ) = ( Comput (R1 , ( Comput (R1 , C50 , ( D38 + 1 )) ) , D46) ) by EXTPRO_1:4;
L245: ( IncAddr (( CurInstr (D44 , ( Comput (D44 , D43 , D46) )) ) , ( card C48 )) ) = ( CurInstr (R1 , ( Comput (R1 , D39 , D46) )) ) by L243 , L220 , L227 , L238 , L221 , SCMFSA8C:16;
L246: ( IncAddr (( CurInstr (D44 , ( Comput (D44 , D43 , D46) )) ) , ( card C48 )) ) = ( CurInstr (R1 , ( Comput (R1 , C50 , ( ( D38 + 1 ) + D46 )) )) ) by L245 , L244;
L247: ( CurInstr (R1 , ( Comput (R1 , C50 , D47) )) ) = ( IncAddr (( halt ( SCM+FSA ) ) , ( card C48 )) ) by L246 , L233 , EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
thus L248: R1 halts_on C50 by L247 , EXTPRO_1:29;
L249:
now
let C51 being (Element of ( NAT ));
assume L250: ( ( D38 + 1 ) + C51 ) < D47;
L251: C51 < D46 by L250 , XREAL_1:6;
L252: ( Comput (R1 , C50 , ( ( D38 + 1 ) + C51 )) ) = ( Comput (R1 , ( Comput (R1 , C50 , ( D38 + 1 )) ) , C51) ) by EXTPRO_1:4;
assume L253: ( CurInstr (R1 , ( Comput (R1 , C50 , ( ( D38 + 1 ) + C51 )) )) ) = ( halt ( SCM+FSA ) );
L254: ( InsCode ( halt ( SCM+FSA ) ) ) = ( 0 ) by COMPOS_1:70;
L255: ( IncAddr (( CurInstr (D44 , ( Comput (D44 , D43 , C51) )) ) , ( card C48 )) ) = ( halt ( SCM+FSA ) ) by L253 , L252 , L243 , L220 , L227 , L238 , L221 , SCMFSA8C:16;
L256: ( InsCode ( CurInstr (D44 , ( Comput (D44 , D43 , C51) )) ) ) = ( 0 ) by L255 , COMPOS_0:def 9 , L254;
L257: ( CurInstr (D44 , ( Comput (D44 , D43 , C51) )) ) = ( halt ( SCM+FSA ) ) by L256 , SCMFSA_2:95;
thus L258: contradiction by L257 , L233 , L251 , EXTPRO_1:def 15;
end;
L259:
now
let C52 being (Element of ( NAT ));
assume L260: C52 < D47;
per cases ;
suppose L261: C52 <= D38;

thus L262: ( CurInstr (R1 , ( Comput (R1 , C50 , C52) )) ) <> ( halt ( SCM+FSA ) ) by L261 , L204 , L206 , L211 , L216 , SCMFSA8A:21;
end;
suppose L263: D38 < C52;

L264: ( D38 + 1 ) <= C52 by L263 , NAT_1:13;
consider C53 being Nat such that L265: ( ( D38 + 1 ) + C53 ) = C52 by L264 , NAT_1:10;
reconsider D48 = C53 as (Element of ( NAT )) by ORDINAL1:def 12;
L266: ( ( D38 + 1 ) + D48 ) = C52 by L265;
thus L267: ( CurInstr (R1 , ( Comput (R1 , C50 , C52) )) ) <> ( halt ( SCM+FSA ) ) by L266 , L249 , L260;
end;
end;
L269: (for B21 being (Element of ( NAT )) holds (( CurInstr (R1 , ( Comput (R1 , C50 , B21) )) ) = ( halt ( SCM+FSA ) ) implies D47 <= B21)) by L259;
L270: ( LifeSpan (R1 , C50) ) = D47 by L269 , L247 , L248 , EXTPRO_1:def 15;
L271: ( Comput (( R1 +* C48 ) , C50 , D38) ) = ( Result (( R1 +* C48 ) , C50) ) by L212 , EXTPRO_1:23;
thus L272: ( LifeSpan (R1 , C50) ) = ( ( ( LifeSpan (( R1 +* C48 ) , C50) ) + 1 ) + ( LifeSpan (( ( R1 +* C48 ) +* C49 ) , ( Initialized ( Result (( R1 +* C48 ) , C50) ) )) ) ) by L271 , L270;
L273: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= D43 by FUNCT_4:25 , MEMSTR_0:50;
L274: ( Initialize D43 ) = D43 by L273 , FUNCT_4:98;
L275: D42 c= D43 by FUNCT_4:25;
thus L276:now
L277: ( DataPart ( Comput (D44 , D43 , D46) ) ) = ( DataPart ( Comput (R1 , D39 , D46) ) ) by L243 , L220 , L227 , L238 , L221 , SCMFSA8C:16;
assume L278: C49 is  good;
thus L279: ( ( Result (R1 , C50) ) . ( intloc ( 0 ) ) ) = ( ( Comput (R1 , C50 , D47) ) . ( intloc ( 0 ) ) ) by L248 , L270 , EXTPRO_1:23
.= ( ( Comput (R1 , D39 , D46) ) . ( intloc ( 0 ) ) ) by EXTPRO_1:4
.= ( ( Comput (D44 , D43 , D46) ) . ( intloc ( 0 ) ) ) by L277 , SCMFSA_M:2
.= ( D43 . ( intloc ( 0 ) ) ) by L207 , L242 , L274 , L278 , SCMFSA8B:3 , SCMFSA8C:68
.= 1 by L229 , L275 , GRFUNC_1:2 , SCMFSA_M:12;
end;
end;
theorem
L277: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (State of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds (for R9 being  good (Program of ( SCM+FSA )) holds ((R9 is_halting_on ( Initialized R5 ) , R1 & R8 is_halting_on ( IExec (R9 , R1 , R5) ) , R1 & R9 is_closed_on ( Initialized R5 ) , R1 & R8 is_closed_on ( IExec (R9 , R1 , R5) ) , R1) implies ( LifeSpan (( R1 +* ( R9 ";" R8 ) ) , ( Initialized R5 )) ) = ( ( ( LifeSpan (( R1 +* R9 ) , ( Initialized R5 )) ) + 1 ) + ( LifeSpan (( ( R1 +* R9 ) +* R8 ) , ( Initialized ( Result (( R1 +* R9 ) , ( Initialized R5 )) ) )) ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (State of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
let R9 being  good (Program of ( SCM+FSA ));
set D49 = R9;
assume that
L278: D49 is_halting_on ( Initialized R5 ) , R1
and
L279: R8 is_halting_on ( IExec (D49 , R1 , R5) ) , R1
and
L280: D49 is_closed_on ( Initialized R5 ) , R1
and
L281: R8 is_closed_on ( IExec (D49 , R1 , R5) ) , R1;
set D50 = ( Initialized R5 );
L282: ( ( Initialized R5 ) . ( intloc ( 0 ) ) ) = 1 by SCMFSA_M:9;
set D51 = ( Initialized R5 );
set D52 = ( R1 +* D49 );
set D53 = ( LifeSpan (D52 , D51) );
set D54 = ( Initialized ( Comput (D52 , D51 , D53) ) );
set D55 = ( D52 +* R8 );
L283: ( D55 +* R8 ) = D55;
L284: D51 = ( Initialized D50 );
L285: D51 = ( Initialize D50 ) by L284 , L282 , SCMFSA_M:18;
L286: D52 halts_on D51 by L285 , L278 , SCMFSA7B:def 7;
L287: D54 = ( Initialized ( Result (D52 , D51) ) ) by L286 , EXTPRO_1:23;
set D56 = ( Initialized R5 );
set D57 = ( R1 +* ( D49 ";" R8 ) );
L288: ( D49 ";" R8 ) c= D57 by FUNCT_4:25;
L289: ( DataPart D50 ) = ( DataPart D56 );
L290: ( D56 . ( intloc ( 0 ) ) ) = 1 by L282;
set D58 = ( Start-At (( 0 ) , ( SCM+FSA )) );
L291: ( ( Comput (D52 , D51 , D53) ) . ( intloc ( 0 ) ) ) = 1 by L280 , L282 , L285 , SCMFSA8C:68;
L292: ( Initialized ( Comput (D52 , D51 , D53) ) ) = ( Initialize ( Comput (D52 , D51 , D53) ) ) by L291 , SCMFSA_M:18;
L293: D58 c= D54 by L292 , FUNCT_4:25;
L294: D54 = ( Initialize D54 ) by L293 , FUNCT_4:98;
L295: ( DataPart ( IExec (D49 , R1 , R5) ) ) = ( DataPart ( Result (( R1 +* D49 ) , ( Initialized R5 )) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Result (( R1 +* D49 ) , ( Initialized R5 )) ) )
.= ( DataPart ( Comput (D52 , D51 , ( LifeSpan (D52 , D51) )) ) ) by L286 , EXTPRO_1:23;
L296: ( DataPart ( IExec (D49 , R1 , R5) ) ) = ( DataPart D54 ) by L295 , L292 , MEMSTR_0:79;
L297: R8 is_halting_on D54 , D55 by L296 , L279 , L281 , SCMFSA8B:5;
L298: ( Initialize D56 ) = D56 by MEMSTR_0:44;
L299: ( Result (( D57 +* D49 ) , D56) ) = ( Result (D52 , D51) ) by L298 , L278 , L280 , L289 , SCMFSA8C:72;
L300: ( Initialized ( Result (( D57 +* D49 ) , D56) ) ) = D54 by L299 , L287;
L301: ( DataPart ( Initialized ( Result (( D57 +* D49 ) , D56) ) ) ) = ( DataPart D54 ) by L300;
L302: ( DataPart ( IExec (D49 , R1 , R5) ) ) = ( DataPart ( IExec (D49 , R1 , D50) ) ) by SCMFSA8C:3
.= ( DataPart ( IExec (D49 , D57 , D56) ) ) by L278 , L280 , L282 , L289 , SCMFSA8C:20;
L303: R8 is_closed_on ( IExec (D49 , D57 , D56) ) , D57 by L302 , L279 , L281 , SCMFSA8B:5;
L304: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= ( Initialized R5 ) by FUNCT_4:25;
L305: D49 is_closed_on D56 , D57 by L280 , L289 , SCMFSA8B:3;
L306: R8 is_halting_on ( IExec (D49 , D57 , D56) ) , D57 by L279 , L281 , L302 , SCMFSA8B:5;
L307: D49 is_halting_on D56 , D57 by L278 , L280 , L289 , SCMFSA8B:5;
L308: ( LifeSpan (D57 , D56) ) = ( ( ( LifeSpan (( D57 +* D49 ) , D56) ) + 1 ) + ( LifeSpan (( ( D57 +* D49 ) +* R8 ) , ( Initialized ( Result (( D57 +* D49 ) , D56) ) )) ) ) by L307 , L305 , L290 , L303 , L306 , L304 , L202 , L288;
L309: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= ( Initialized ( Result (( D57 +* D49 ) , D56) ) ) by FUNCT_4:25 , MEMSTR_0:50;
L310: ( Initialized ( Result (( D57 +* D49 ) , D56) ) ) = ( Initialize ( Initialized ( Result (( D57 +* D49 ) , D56) ) ) ) by L309 , FUNCT_4:98;
L311: R8 is_closed_on D54 , D55 by L281 , L296 , SCMFSA8B:3;
L312: ( LifeSpan (( D57 +* D49 ) , D56) ) = D53 by L278 , L280 , L285 , L289 , SCMFSA8C:72;
L313: ( LifeSpan (( ( D57 +* D49 ) +* R8 ) , ( Initialized ( Result (( D57 +* D49 ) , D56) ) )) ) = ( LifeSpan (D55 , D54) ) by L311 , L297 , L294 , L310 , L301 , L283 , SCMFSA8C:72;
thus L314: thesis by L313 , L287 , L308 , L312;
end;
theorem
L315: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (State of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds (for R9 being  good (Program of ( SCM+FSA )) holds ((R9 is_halting_on ( Initialized R5 ) , R1 & R8 is_halting_on ( IExec (R9 , R1 , R5) ) , R1 & R9 is_closed_on ( Initialized R5 ) , R1 & R8 is_closed_on ( IExec (R9 , R1 , R5) ) , R1) implies ( IExec (( R9 ";" R8 ) , R1 , R5) ) = ( ( IExec (R8 , R1 , ( IExec (R9 , R1 , R5) )) ) +* ( Start-At (( ( IC ( IExec (R8 , R1 , ( IExec (R9 , R1 , R5) )) ) ) + ( card R9 ) ) , ( SCM+FSA )) ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (State of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
let R9 being  good (Program of ( SCM+FSA ));
set D59 = R9;
assume that
L316: D59 is_halting_on ( Initialized R5 ) , R1
and
L317: R8 is_halting_on ( IExec (D59 , R1 , R5) ) , R1
and
L318: D59 is_closed_on ( Initialized R5 ) , R1
and
L319: R8 is_closed_on ( IExec (D59 , R1 , R5) ) , R1;
set D60 = ( Initialized R5 );
set D61 = R1;
L320: ( ( Initialized R5 ) . ( intloc ( 0 ) ) ) = 1 by SCMFSA_M:9;
set D62 = ( Initialized R5 );
set D63 = ( R1 +* D59 );
L321: D59 c= D63 by FUNCT_4:25;
set D64 = ( LifeSpan (D63 , D62) );
L322: D62 = ( Initialized D60 );
L323: D62 = ( Initialize D60 ) by L322 , L320 , SCMFSA_M:18;
L324: ( DataPart D60 ) = ( DataPart D62 );
L325: D59 is_closed_on D62 , D63 by L324 , L318 , SCMFSA8B:3;
set D65 = ( Initialized ( Comput (D63 , D62 , D64) ) );
set D66 = ( D63 +* R8 );
L326: R8 c= D66 by FUNCT_4:25;
L327: D63 halts_on D62 by L316 , L323 , SCMFSA7B:def 7;
L328: D65 = ( Initialized ( Result (D63 , D62) ) ) by L327 , EXTPRO_1:23;
set D67 = ( Initialized R5 );
set D68 = ( R1 +* ( D59 ";" R8 ) );
L329: ( D59 ";" R8 ) c= D68 by FUNCT_4:25;
L330: D67 = ( Initialized D60 );
L331: D67 = ( Initialize D60 ) by L330 , L320 , SCMFSA_M:18;
L332: ( DataPart D60 ) = ( DataPart D67 );
L333: ( D67 . ( intloc ( 0 ) ) ) = 1 by L320;
L334: ( DataPart ( IExec (D59 , R1 , R5) ) ) = ( DataPart ( IExec (D59 , R1 , D60) ) ) by SCMFSA8C:3
.= ( DataPart ( IExec (D59 , D68 , D67) ) ) by L316 , L318 , L320 , L332 , SCMFSA8C:20;
L335: R8 is_closed_on ( IExec (D59 , D68 , D67) ) , D68 by L334 , L317 , L319 , SCMFSA8B:5;
L336: D67 = ( Initialize D67 ) by MEMSTR_0:44;
L337: ( LifeSpan (( D68 +* D59 ) , D67) ) = D64 by L336 , L316 , L318 , L332 , SCMFSA8C:72;
set D69 = ( Start-At (( 0 ) , ( SCM+FSA )) );
L338: ( ( Comput (D63 , D62 , D64) ) . ( intloc ( 0 ) ) ) = 1 by L318 , L320 , L323 , SCMFSA8C:68;
L339: D65 = ( Initialize ( Comput (D63 , D62 , D64) ) ) by L338 , SCMFSA_M:18;
set D70 = ( LifeSpan (D66 , D65) );
L340: ( D59 ";" R8 ) is_halting_on D60 , D61 by L316 , L317 , L318 , L319 , L140;
L341: D68 halts_on D67 by L340 , L331 , SCMFSA7B:def 7;
L342: ( IExec (( D59 ";" R8 ) , R1 , R5) ) = ( Result (( R1 +* ( D59 ";" R8 ) ) , ( Initialized R5 )) ) by SCMFSA6B:def 1
.= ( Comput (D68 , D67 , ( LifeSpan (D68 , D67) )) ) by L341 , EXTPRO_1:23
.= ( Comput (D68 , D67 , ( ( D64 + 1 ) + D70 )) ) by L316 , L317 , L318 , L319 , L328 , L277;
L343: ( DataPart ( IExec (D59 , R1 , R5) ) ) = ( DataPart ( Result (( R1 +* D59 ) , ( Initialized R5 )) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Result (( R1 +* D59 ) , ( R5 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) )
.= ( DataPart ( Comput (D63 , D62 , ( LifeSpan (D63 , D62) )) ) ) by L327 , EXTPRO_1:23;
L344: R8 is_halting_on ( Comput (D63 , D62 , ( LifeSpan (D63 , D62) )) ) , D63 by L343 , L317 , L319 , SCMFSA8B:5;
L345: D66 halts_on D65 by L344 , L339 , SCMFSA7B:def 7;
set D71 = ( IExec (R8 , R1 , ( IExec (D59 , R1 , R5) )) );
set D72 = ( Start-At (( 0 ) , ( SCM+FSA )) );
L346: ( DataPart ( IExec (D59 , R1 , R5) ) ) = ( DataPart D65 ) by L339 , L343 , MEMSTR_0:79;
L347: R8 is_closed_on D65 , D66 by L346 , L319 , SCMFSA8B:3;
L348: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= D67 by FUNCT_4:25;
L349: ( ( IExec (D59 , R1 , R5) ) . ( intloc ( 0 ) ) ) = 1 by L316 , L318 , SCMFSA8C:67;
L350: ( Initialized ( IExec (D59 , R1 , R5) ) ) = ( Initialize ( IExec (D59 , R1 , R5) ) ) by L349 , SCMFSA_M:18;
L351: ( Result (( D63 +* R8 ) , ( ( Result (D63 , D62) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) = ( Result (( R1 +* R8 ) , ( ( IExec (D59 , R1 , R5) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) by L350 , L317 , L319 , L339 , L343 , L328 , SCMFSA8C:72;
L352: ( IC ( Result (( D63 +* R8 ) , ( Initialized ( Result (D63 , D62) ) )) ) ) = ( IC ( Result (( R1 +* R8 ) , ( Initialized ( IExec (D59 , R1 , R5) ) )) ) ) by L351;
L353: ( Result (( R1 +* R8 ) , ( Initialized ( IExec (D59 , R1 , R5) ) )) ) = ( Result (D66 , D65) ) by L317 , L319 , L339 , L343 , L350 , SCMFSA8C:72;
L354: D71 = ( Result (( R1 +* R8 ) , ( Initialized ( IExec (D59 , R1 , R5) ) )) ) by SCMFSA6B:def 1
.= ( Comput (D66 , D65 , D70) ) by L345 , L353 , EXTPRO_1:23;
L355: D59 is_halting_on D67 , D68 by L316 , L318 , L332 , SCMFSA8B:5;
reconsider D73 = ( ( IC D71 ) + ( card D59 ) ) as (Element of ( NAT ));
reconsider D74 = ( R5 +* ( ( intloc ( 0 ) ) .--> 1 ) ) as (State of ( SCM+FSA ));
L356: ( DataPart D67 ) = ( DataPart D67 );
L357: D59 is_closed_on D67 , ( D68 +* D59 ) by L356 , L318 , SCMFSA8B:3;
L358: ( dom ( Start-At (D73 , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L359: ( D59 +* ( D59 ";" R8 ) ) = ( D59 ";" R8 ) by SCMFSA6A:18;
L360: ( ( D68 +* D59 ) +* ( D59 ";" R8 ) ) = ( D68 +* ( D59 +* ( D59 ";" R8 ) ) ) by FUNCT_4:14;
L361: D59 c= ( D68 +* D59 ) by FUNCT_4:25;
L362: ( D63 +* ( D59 ";" R8 ) ) = D68 by L359 , FUNCT_4:14;
L363: ( Comput (D63 , D62 , D64) ) = ( Comput (D68 , D67 , D64) ) by L327 , L325 , L176 , L321 , L362;
L364: D67 = ( Initialize D67 ) by MEMSTR_0:44;
L365: ( D68 +* D59 ) halts_on D67 by L364 , L355 , SCMFSA7B:def 7;
L366: ( Comput (( D68 +* D59 ) , D67 , D64) ) = ( Comput (( ( D68 +* D59 ) +* ( D59 ";" R8 ) ) , D67 , D64) ) by L365 , L357 , L337 , L176 , L361;
L367: ( DataPart ( Comput (( D68 +* D59 ) , D67 , D64) ) ) = ( DataPart ( Comput (( ( D68 +* D59 ) +* ( D59 ";" R8 ) ) , D67 , D64) ) ) by L366
.= ( DataPart ( Comput (( ( D68 +* D59 ) +* ( D59 ";" R8 ) ) , D67 , D64) ) )
.= ( DataPart ( Comput (( D68 +* ( D59 ";" R8 ) ) , D67 , D64) ) ) by L359 , L360
.= ( DataPart ( Comput (D68 , D67 , D64) ) )
.= ( DataPart ( Comput (D63 , D62 , D64) ) ) by L363;
L368: ( DataPart ( ( Comput (( D68 +* D59 ) , D67 , D64) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) = ( ( DataPart ( Comput (D63 , D62 , D64) ) ) +* ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) by L367 , FUNCT_4:71
.= ( DataPart ( ( Comput (D63 , D62 , D64) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) by FUNCT_4:71;
L369: D59 is_closed_on D67 , D68 by L318 , L332 , SCMFSA8B:3;
L370: R8 is_halting_on ( IExec (D59 , D68 , D67) ) , D68 by L317 , L319 , L334 , SCMFSA8B:5;
L371: ( DataPart ( Comput (D68 , D67 , ( D64 + 1 )) ) ) = ( DataPart ( Initialized ( Comput (( D68 +* D59 ) , D67 , D64) ) ) ) by L370 , L348 , L369 , L355 , L337 , L333 , L335 , L202 , L329;
L372: ( Reloc (R8 , ( card D59 )) ) c= ( D59 ";" R8 ) by FUNCT_4:25;
L373: ( Reloc (R8 , ( card D59 )) ) c= D68 by L372 , L329 , XBOOLE_1:1;
L374: ( IC ( Comput (D68 , D67 , ( D64 + 1 )) ) ) = ( card D59 ) by L348 , L369 , L355 , L337 , L333 , L335 , L370 , L202 , L329;
L375: ( DataPart ( Comput (D68 , ( Comput (D68 , D67 , ( D64 + 1 )) ) , D70) ) ) = ( DataPart ( Comput (D66 , D65 , D70) ) ) by L374 , L347 , L368 , L371 , L326 , L373 , SCMFSA8C:16;
L376: ( DataPart ( IExec (( D59 ";" R8 ) , R1 , R5) ) ) = ( DataPart ( Comput (D68 , D67 , ( ( D64 + 1 ) + D70 )) ) ) by L342
.= ( DataPart ( Comput (D66 , D65 , D70) ) ) by L375 , EXTPRO_1:4
.= ( DataPart D71 ) by L354;
L377: ( IC ( Comput (D68 , ( Comput (D68 , D67 , ( D64 + 1 )) ) , D70) ) ) = ( ( IC ( Comput (D66 , D65 , D70) ) ) + ( card D59 ) ) by L347 , L368 , L374 , L371 , L326 , L373 , SCMFSA8C:16;
L378: D65 = ( Initialized ( Result (D63 , D62) ) ) by L327 , EXTPRO_1:23;
L379: ( IC ( IExec (( D59 ";" R8 ) , R1 , R5) ) ) = ( IC ( Result (( R1 +* ( D59 ";" R8 ) ) , ( Initialized R5 )) ) ) by SCMFSA6B:def 1
.= ( IC ( Comput (D68 , D67 , ( LifeSpan (D68 , D67) )) ) ) by L341 , EXTPRO_1:23
.= ( IC ( Comput (D68 , D67 , ( ( D64 + 1 ) + D70 )) ) ) by L316 , L317 , L318 , L319 , L328 , L277
.= ( ( IC ( Comput (D66 , D65 , D70) ) ) + ( card D59 ) ) by L377 , EXTPRO_1:4
.= ( ( IC ( Result (D66 , D65) ) ) + ( card D59 ) ) by L345 , EXTPRO_1:23
.= ( ( IC D71 ) + ( card D59 ) ) by L352 , L378 , SCMFSA6B:def 1;
L380:
now
let C54 being set;
assume L381: C54 in ( dom ( IExec (( D59 ";" R8 ) , R1 , R5) ) );
per cases  by L381 , SCMFSA_M:1;
suppose L382: C54 is Int-Location;

L383: C54 <> ( IC ( SCM+FSA ) ) by L382 , SCMFSA_2:56;
L384: (not C54 in ( dom ( Start-At (D73 , ( SCM+FSA )) ) )) by L383 , L358 , TARSKI:def 1;
L385: ( ( IExec (( D59 ";" R8 ) , R1 , R5) ) . C54 ) = ( D71 . C54 ) by L376 , L382 , SCMFSA_M:2;
thus L386: ( ( IExec (( D59 ";" R8 ) , R1 , R5) ) . C54 ) = ( ( D71 +* ( Start-At (( ( IC D71 ) + ( card D59 ) ) , ( SCM+FSA )) ) ) . C54 ) by L385 , L384 , FUNCT_4:11;
end;
suppose L387: C54 is FinSeq-Location;

L388: C54 <> ( IC ( SCM+FSA ) ) by L387 , SCMFSA_2:57;
L389: (not C54 in ( dom ( Start-At (D73 , ( SCM+FSA )) ) )) by L388 , L358 , TARSKI:def 1;
L390: ( ( IExec (( D59 ";" R8 ) , R1 , R5) ) . C54 ) = ( D71 . C54 ) by L376 , L387 , SCMFSA_M:2;
thus L391: ( ( IExec (( D59 ";" R8 ) , R1 , R5) ) . C54 ) = ( ( D71 +* ( Start-At (( ( IC D71 ) + ( card D59 ) ) , ( SCM+FSA )) ) ) . C54 ) by L390 , L389 , FUNCT_4:11;
end;
suppose L392: C54 = ( IC ( SCM+FSA ) );

L393: C54 in { ( IC ( SCM+FSA ) ) } by L392 , TARSKI:def 1;
L394: C54 in ( dom ( Start-At (D73 , ( SCM+FSA )) ) ) by L393 , FUNCOP_1:13;
thus L395: ( ( IExec (( D59 ";" R8 ) , R1 , R5) ) . C54 ) = ( ( Start-At (D73 , ( SCM+FSA )) ) . ( IC ( SCM+FSA ) ) ) by L379 , L392 , FUNCOP_1:72
.= ( ( D71 +* ( Start-At (( ( IC D71 ) + ( card D59 ) ) , ( SCM+FSA )) ) ) . C54 ) by L392 , L394 , FUNCT_4:13;
end;
end;
L397: ( dom ( IExec (( D59 ";" R8 ) , R1 , R5) ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2
.= ( dom ( D71 +* ( Start-At (( ( IC D71 ) + ( card D59 ) ) , ( SCM+FSA )) ) ) ) by PARTFUN1:def 2;
thus L398: thesis by L397 , L380 , FUNCT_1:2;
end;
theorem
L399: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (State of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds (for R9 being  good (Program of ( SCM+FSA )) holds (for R12 being Int-Location holds (((R9 is  parahalting or (R9 is_halting_on ( Initialized R5 ) , R1 & R9 is_closed_on ( Initialized R5 ) , R1)) & (R8 is  parahalting or (R8 is_halting_on ( IExec (R9 , R1 , R5) ) , R1 & R8 is_closed_on ( IExec (R9 , R1 , R5) ) , R1))) implies ( ( IExec (( R9 ";" R8 ) , R1 , R5) ) . R12 ) = ( ( IExec (R8 , R1 , ( IExec (R9 , R1 , R5) )) ) . R12 )))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (State of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
let R9 being  good (Program of ( SCM+FSA ));
let R12 being Int-Location;
set D75 = R9;
assume that
L400: (D75 is  parahalting or (D75 is_halting_on ( Initialized R5 ) , R1 & D75 is_closed_on ( Initialized R5 ) , R1))
and
L401: (R8 is  parahalting or (R8 is_halting_on ( IExec (D75 , R1 , R5) ) , R1 & R8 is_closed_on ( IExec (D75 , R1 , R5) ) , R1));
L402: R8 is_halting_on ( IExec (D75 , R1 , R5) ) , R1 by L401 , SCMFSA7B:19;
L403: D75 is_closed_on ( Initialized R5 ) , R1 by L400 , SCMFSA7B:18;
L404: (not R12 in ( dom ( Start-At (( ( IC ( IExec (R8 , R1 , ( IExec (D75 , R1 , R5) )) ) ) + ( card D75 ) ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L405: R8 is_closed_on ( IExec (D75 , R1 , R5) ) , R1 by L401 , SCMFSA7B:18;
L406: D75 is_halting_on ( Initialized R5 ) , R1 by L400 , SCMFSA7B:19;
L407: ( IExec (( D75 ";" R8 ) , R1 , R5) ) = ( ( IExec (R8 , R1 , ( IExec (D75 , R1 , R5) )) ) +* ( Start-At (( ( IC ( IExec (R8 , R1 , ( IExec (D75 , R1 , R5) )) ) ) + ( card D75 ) ) , ( SCM+FSA )) ) ) by L406 , L402 , L403 , L405 , L315;
thus L408: thesis by L407 , L404 , FUNCT_4:11;
end;
theorem
L409: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (State of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds (for R9 being  good (Program of ( SCM+FSA )) holds (for R14 being FinSeq-Location holds (((R9 is  parahalting or (R9 is_halting_on ( Initialized R5 ) , R1 & R9 is_closed_on ( Initialized R5 ) , R1)) & (R8 is  parahalting or (R8 is_halting_on ( IExec (R9 , R1 , R5) ) , R1 & R8 is_closed_on ( IExec (R9 , R1 , R5) ) , R1))) implies ( ( IExec (( R9 ";" R8 ) , R1 , R5) ) . R14 ) = ( ( IExec (R8 , R1 , ( IExec (R9 , R1 , R5) )) ) . R14 )))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (State of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
let R9 being  good (Program of ( SCM+FSA ));
let R14 being FinSeq-Location;
set D76 = R9;
assume that
L410: (D76 is  parahalting or (D76 is_halting_on ( Initialized R5 ) , R1 & D76 is_closed_on ( Initialized R5 ) , R1))
and
L411: (R8 is  parahalting or (R8 is_halting_on ( IExec (D76 , R1 , R5) ) , R1 & R8 is_closed_on ( IExec (D76 , R1 , R5) ) , R1));
L412: R8 is_halting_on ( IExec (D76 , R1 , R5) ) , R1 by L411 , SCMFSA7B:19;
L413: D76 is_closed_on ( Initialized R5 ) , R1 by L410 , SCMFSA7B:18;
L414: (not R14 in ( dom ( Start-At (( ( IC ( IExec (R8 , R1 , ( IExec (D76 , R1 , R5) )) ) ) + ( card D76 ) ) , ( SCM+FSA )) ) )) by SCMFSA_2:103;
L415: R8 is_closed_on ( IExec (D76 , R1 , R5) ) , R1 by L411 , SCMFSA7B:18;
L416: D76 is_halting_on ( Initialized R5 ) , R1 by L410 , SCMFSA7B:19;
L417: ( IExec (( D76 ";" R8 ) , R1 , R5) ) = ( ( IExec (R8 , R1 , ( IExec (D76 , R1 , R5) )) ) +* ( Start-At (( ( IC ( IExec (R8 , R1 , ( IExec (D76 , R1 , R5) )) ) ) + ( card D76 ) ) , ( SCM+FSA )) ) ) by L416 , L412 , L413 , L415 , L315;
thus L418: thesis by L417 , L414 , FUNCT_4:11;
end;
theorem
L419: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (State of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds (for R9 being  good (Program of ( SCM+FSA )) holds (((R9 is  parahalting or (R9 is_halting_on ( Initialized R5 ) , R1 & R9 is_closed_on ( Initialized R5 ) , R1)) & (R8 is  parahalting or (R8 is_halting_on ( IExec (R9 , R1 , R5) ) , R1 & R8 is_closed_on ( IExec (R9 , R1 , R5) ) , R1))) implies ( DataPart ( IExec (( R9 ";" R8 ) , R1 , R5) ) ) = ( DataPart ( IExec (R8 , R1 , ( IExec (R9 , R1 , R5) )) ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (State of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
let R9 being  good (Program of ( SCM+FSA ));
set D77 = R9;
assume that
L420: (D77 is  parahalting or (D77 is_halting_on ( Initialized R5 ) , R1 & D77 is_closed_on ( Initialized R5 ) , R1))
and
L421: (R8 is  parahalting or (R8 is_halting_on ( IExec (D77 , R1 , R5) ) , R1 & R8 is_closed_on ( IExec (D77 , R1 , R5) ) , R1));
L422: (for R14 being FinSeq-Location holds ( ( IExec (( D77 ";" R8 ) , R1 , R5) ) . R14 ) = ( ( IExec (R8 , R1 , ( IExec (D77 , R1 , R5) )) ) . R14 )) by L420 , L421 , L409;
L423: (for R12 being Int-Location holds ( ( IExec (( D77 ";" R8 ) , R1 , R5) ) . R12 ) = ( ( IExec (R8 , R1 , ( IExec (D77 , R1 , R5) )) ) . R12 )) by L420 , L421 , L399;
thus L424: thesis by L423 , L422 , SCMFSA_M:2;
end;
theorem
L425: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (State of ( SCM+FSA )) holds (for R9 being  good (Program of ( SCM+FSA )) holds ((R9 is  parahalting or (R9 is_closed_on ( Initialized R5 ) , R1 & R9 is_halting_on ( Initialized R5 ) , R1)) implies ( DataPart ( Initialized ( IExec (R9 , R1 , R5) ) ) ) = ( DataPart ( IExec (R9 , R1 , R5) ) )))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (State of ( SCM+FSA ));
let R9 being  good (Program of ( SCM+FSA ));
set D78 = R9;
set D79 = ( IExec (D78 , R1 , R5) );
assume that
L426: (D78 is  parahalting or (D78 is_closed_on ( Initialized R5 ) , R1 & D78 is_halting_on ( Initialized R5 ) , R1));
L427: D78 is_halting_on ( Initialized R5 ) , R1 by L426 , SCMFSA7B:19;
L428: D78 is_closed_on ( Initialized R5 ) , R1 by L426 , SCMFSA7B:18;
L429:
now
L430: ( dom ( Initialized D79 ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2;
L431: ( dom ( Initialized D79 ) ) = ( D3 \/ { ( IC ( SCM+FSA ) ) } ) by MEMSTR_0:13
.= ( D3 \/ { ( IC ( SCM+FSA ) ) } );
L432: ( dom D79 ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2;
thus L433: ( dom ( DataPart ( Initialized D79 ) ) ) = ( ( dom D79 ) /\ D3 ) by L432 , L430 , RELAT_1:61;
L434: ( dom ( DataPart ( Initialized D79 ) ) ) = D3 by L433 , L430 , L432 , L431 , XBOOLE_1:21;
let C55 being set;
assume L435: C55 in ( dom ( DataPart ( Initialized D79 ) ) );
per cases  by L435 , L434 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L436: C55 in ( Int-Locations );

reconsider D80 = C55 as Int-Location by L436 , AMI_2:def 16;
thus L437:now
per cases ;
suppose L438: D80 is  read-write;

thus L439: ( ( DataPart ( Initialized D79 ) ) . C55 ) = ( ( Initialized D79 ) . C55 ) by L435 , L434 , FUNCT_1:49
.= ( D79 . C55 ) by L438 , SCMFSA_M:37;
end;
suppose L440: D80 is  read-only;

L441: D80 = ( intloc ( 0 ) ) by L440 , SCMFSA_M:def 2;
thus L442: ( ( DataPart ( Initialized D79 ) ) . C55 ) = ( ( Initialized D79 ) . D80 ) by L435 , L434 , FUNCT_1:49
.= 1 by L441 , SCMFSA_M:9
.= ( D79 . C55 ) by L428 , L427 , L441 , SCMFSA8C:67;
end;
end;
end;
suppose L438: C55 in ( FinSeq-Locations );

reconsider D81 = C55 as FinSeq-Location by L438 , SCMFSA_2:def 5;
thus L439: ( ( DataPart ( Initialized D79 ) ) . C55 ) = ( ( Initialized D79 ) . D81 ) by L435 , L434 , FUNCT_1:49
.= ( D79 . C55 ) by SCMFSA_M:37;
end;
end;
thus L441: thesis by L429 , FUNCT_1:46;
end;
theorem
L442: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (State of ( SCM+FSA )) holds (for R9 being  good (Program of ( SCM+FSA )) holds (for R11 being  parahalting (Instruction of ( SCM+FSA )) holds (for R12 being Int-Location holds ((R9 is  parahalting or (R9 is_halting_on ( Initialized R5 ) , R1 & R9 is_closed_on ( Initialized R5 ) , R1)) implies ( ( IExec (( R9 ";" R11 ) , R1 , R5) ) . R12 ) = ( ( Exec (R11 , ( IExec (R9 , R1 , R5) )) ) . R12 )))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (State of ( SCM+FSA ));
let R9 being  good (Program of ( SCM+FSA ));
let R11 being  parahalting (Instruction of ( SCM+FSA ));
let R12 being Int-Location;
set D82 = R9;
set D83 = ( Macro R11 );
L443: R12 in ( Int-Locations ) by AMI_2:def 16;
L444: R12 in D3 by L443 , SCMFSA_2:100 , XBOOLE_0:def 3;
assume that
L445: (D82 is  parahalting or (D82 is_halting_on ( Initialized R5 ) , R1 & D82 is_closed_on ( Initialized R5 ) , R1));
L446: ( DataPart ( Initialized ( IExec (D82 , R1 , R5) ) ) ) = ( DataPart ( IExec (D82 , R1 , R5) ) ) by L445 , L425;
thus L447: ( ( IExec (( D82 ";" R11 ) , R1 , R5) ) . R12 ) = ( ( IExec (D83 , R1 , ( IExec (D82 , R1 , R5) )) ) . R12 ) by L445 , L399
.= ( ( IExec (D83 , R1 , ( IExec (D82 , R1 , R5) )) ) . R12 )
.= ( ( Exec (R11 , ( Initialized ( IExec (D82 , R1 , R5) ) )) ) . R12 ) by SCMFSA6C:5
.= ( ( Exec (R11 , ( Initialized ( IExec (D82 , R1 , R5) ) )) ) . R12 )
.= ( ( DataPart ( Exec (R11 , ( Initialized ( IExec (D82 , R1 , R5) ) )) ) ) . R12 ) by L444 , FUNCT_1:49
.= ( ( DataPart ( Exec (R11 , ( IExec (D82 , R1 , R5) )) ) ) . R12 ) by L446 , SCMFSA6C:4
.= ( ( Exec (R11 , ( IExec (D82 , R1 , R5) )) ) . R12 ) by L444 , FUNCT_1:49;
end;
theorem
L448: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (State of ( SCM+FSA )) holds (for R9 being  good (Program of ( SCM+FSA )) holds (for R11 being  parahalting (Instruction of ( SCM+FSA )) holds (for R14 being FinSeq-Location holds ((R9 is  parahalting or (R9 is_halting_on ( Initialized R5 ) , R1 & R9 is_closed_on ( Initialized R5 ) , R1)) implies ( ( IExec (( R9 ";" R11 ) , R1 , R5) ) . R14 ) = ( ( Exec (R11 , ( IExec (R9 , R1 , R5) )) ) . R14 )))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (State of ( SCM+FSA ));
let R9 being  good (Program of ( SCM+FSA ));
let R11 being  parahalting (Instruction of ( SCM+FSA ));
let R14 being FinSeq-Location;
set D84 = R9;
set D85 = ( Macro R11 );
L449: R14 in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L450: R14 in D3 by L449 , SCMFSA_2:100 , XBOOLE_0:def 3;
assume that
L451: (D84 is  parahalting or (D84 is_halting_on ( Initialized R5 ) , R1 & D84 is_closed_on ( Initialized R5 ) , R1));
L452: ( DataPart ( Initialized ( IExec (D84 , R1 , R5) ) ) ) = ( DataPart ( IExec (D84 , R1 , R5) ) ) by L451 , L425;
thus L453: ( ( IExec (( D84 ";" R11 ) , R1 , R5) ) . R14 ) = ( ( IExec (D85 , R1 , ( IExec (D84 , R1 , R5) )) ) . R14 ) by L451 , L409
.= ( ( IExec (D85 , R1 , ( IExec (D84 , R1 , R5) )) ) . R14 )
.= ( ( Exec (R11 , ( Initialized ( IExec (D84 , R1 , R5) ) )) ) . R14 ) by SCMFSA6C:5
.= ( ( Exec (R11 , ( Initialized ( IExec (D84 , R1 , R5) ) )) ) . R14 )
.= ( ( DataPart ( Exec (R11 , ( Initialized ( IExec (D84 , R1 , R5) ) )) ) ) . R14 ) by L450 , FUNCT_1:49
.= ( ( DataPart ( Exec (R11 , ( IExec (D84 , R1 , R5) )) ) ) . R14 ) by L452 , SCMFSA6C:4
.= ( ( Exec (R11 , ( IExec (D84 , R1 , R5) )) ) . R14 ) by L450 , FUNCT_1:49;
end;
theorem
L454: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (State of ( SCM+FSA )) holds (for R9 being  good (Program of ( SCM+FSA )) holds (for R11 being  parahalting (Instruction of ( SCM+FSA )) holds ((R9 is  parahalting or (R9 is_halting_on ( Initialized R5 ) , R1 & R9 is_closed_on ( Initialized R5 ) , R1)) implies ( DataPart ( IExec (( R9 ";" R11 ) , R1 , R5) ) ) = ( DataPart ( Exec (R11 , ( IExec (R9 , R1 , R5) )) ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (State of ( SCM+FSA ));
let R9 being  good (Program of ( SCM+FSA ));
let R11 being  parahalting (Instruction of ( SCM+FSA ));
set D86 = R9;
assume L455: (D86 is  parahalting or (D86 is_halting_on ( Initialized R5 ) , R1 & D86 is_closed_on ( Initialized R5 ) , R1));
L456: (for R14 being FinSeq-Location holds ( ( IExec (( D86 ";" R11 ) , R1 , R5) ) . R14 ) = ( ( Exec (R11 , ( IExec (D86 , R1 , R5) )) ) . R14 )) by L455 , L448;
L457: (for R12 being Int-Location holds ( ( IExec (( D86 ";" R11 ) , R1 , R5) ) . R12 ) = ( ( Exec (R11 , ( IExec (D86 , R1 , R5) )) ) . R12 )) by L455 , L442;
thus L458: thesis by L457 , L456 , SCMFSA_M:2;
end;
theorem
L459: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (State of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds (for R10 being  good  parahalting (Instruction of ( SCM+FSA )) holds (for R12 being Int-Location holds ((R8 is  parahalting or (R8 is_halting_on ( Exec (R10 , ( Initialized R5 )) ) , R1 & R8 is_closed_on ( Exec (R10 , ( Initialized R5 )) ) , R1)) implies ( ( IExec (( R10 ";" R8 ) , R1 , R5) ) . R12 ) = ( ( IExec (R8 , R1 , ( Exec (R10 , ( Initialized R5 )) )) ) . R12 )))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (State of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
let R10 being  good  parahalting (Instruction of ( SCM+FSA ));
let R12 being Int-Location;
set D87 = ( Macro R10 );
L460: ( IExec (D87 , R1 , R5) ) = ( Exec (R10 , ( Initialized R5 )) ) by SCMFSA6C:5;
assume L461: (R8 is  parahalting or (R8 is_halting_on ( Exec (R10 , ( Initialized R5 )) ) , R1 & R8 is_closed_on ( Exec (R10 , ( Initialized R5 )) ) , R1));
L462: (R8 is_halting_on ( Exec (R10 , ( Initialized R5 )) ) , R1 & R8 is_closed_on ( Exec (R10 , ( Initialized R5 )) ) , R1) by L461 , SCMFSA7B:18 , SCMFSA7B:19;
L463: R8 is_closed_on ( IExec (D87 , R1 , R5) ) , R1 by L462 , L460;
L464: R8 is_halting_on ( IExec (D87 , R1 , R5) ) , R1 by L462 , L460;
thus L465: ( ( IExec (( R10 ";" R8 ) , R1 , R5) ) . R12 ) = ( ( IExec (R8 , R1 , ( IExec (D87 , R1 , R5) )) ) . R12 ) by L464 , L463 , L399
.= ( ( IExec (R8 , R1 , ( IExec (D87 , R1 , R5) )) ) . R12 )
.= ( ( IExec (R8 , R1 , ( Exec (R10 , ( Initialized R5 )) )) ) . R12 ) by L460
.= ( ( IExec (R8 , R1 , ( Exec (R10 , ( Initialized R5 )) )) ) . R12 );
end;
theorem
L466: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (State of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds (for R10 being  good  parahalting (Instruction of ( SCM+FSA )) holds (for R14 being FinSeq-Location holds ((R8 is  parahalting or (R8 is_halting_on ( Exec (R10 , ( Initialized R5 )) ) , R1 & R8 is_closed_on ( Exec (R10 , ( Initialized R5 )) ) , R1)) implies ( ( IExec (( R10 ";" R8 ) , R1 , R5) ) . R14 ) = ( ( IExec (R8 , R1 , ( Exec (R10 , ( Initialized R5 )) )) ) . R14 )))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (State of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
let R10 being  good  parahalting (Instruction of ( SCM+FSA ));
let R14 being FinSeq-Location;
set D88 = ( Macro R10 );
L467: ( IExec (D88 , R1 , R5) ) = ( Exec (R10 , ( Initialized R5 )) ) by SCMFSA6C:5;
assume L468: (R8 is  parahalting or (R8 is_halting_on ( Exec (R10 , ( Initialized R5 )) ) , R1 & R8 is_closed_on ( Exec (R10 , ( Initialized R5 )) ) , R1));
L469: (R8 is_halting_on ( Exec (R10 , ( Initialized R5 )) ) , R1 & R8 is_closed_on ( Exec (R10 , ( Initialized R5 )) ) , R1) by L468 , SCMFSA7B:18 , SCMFSA7B:19;
L470: R8 is_closed_on ( IExec (D88 , R1 , R5) ) , R1 by L469 , L467;
L471: R8 is_halting_on ( IExec (D88 , R1 , R5) ) , R1 by L469 , L467;
thus L472: ( ( IExec (( R10 ";" R8 ) , R1 , R5) ) . R14 ) = ( ( IExec (R8 , R1 , ( IExec (D88 , R1 , R5) )) ) . R14 ) by L471 , L470 , L409
.= ( ( IExec (R8 , R1 , ( IExec (D88 , R1 , R5) )) ) . R14 )
.= ( ( IExec (R8 , R1 , ( Exec (R10 , ( Initialized R5 )) )) ) . R14 ) by L467
.= ( ( IExec (R8 , R1 , ( Exec (R10 , ( Initialized R5 )) )) ) . R14 );
end;
theorem
L473: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (State of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds (for R10 being  good  parahalting (Instruction of ( SCM+FSA )) holds ((R8 is  parahalting or (R8 is_halting_on ( Exec (R10 , ( Initialized R5 )) ) , R1 & R8 is_closed_on ( Exec (R10 , ( Initialized R5 )) ) , R1)) implies ( DataPart ( IExec (( R10 ";" R8 ) , R1 , R5) ) ) = ( DataPart ( IExec (R8 , R1 , ( Exec (R10 , ( Initialized R5 )) )) ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (State of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
let R10 being  good  parahalting (Instruction of ( SCM+FSA ));
assume L474: (R8 is  parahalting or (R8 is_halting_on ( Exec (R10 , ( Initialized R5 )) ) , R1 & R8 is_closed_on ( Exec (R10 , ( Initialized R5 )) ) , R1));
L475: (for R14 being FinSeq-Location holds ( ( IExec (( R10 ";" R8 ) , R1 , R5) ) . R14 ) = ( ( IExec (R8 , R1 , ( Exec (R10 , ( Initialized R5 )) )) ) . R14 )) by L474 , L466;
L476: (for R12 being Int-Location holds ( ( IExec (( R10 ";" R8 ) , R1 , R5) ) . R12 ) = ( ( IExec (R8 , R1 , ( Exec (R10 , ( Initialized R5 )) )) ) . R12 )) by L474 , L459;
thus L477: thesis by L476 , L475 , SCMFSA_M:2;
end;
begin
definition
canceled 2;
let C56 being (Element of ( NAT ));
let C57 being (preProgram of ( SCM+FSA ));
func C56 -thNotUsed C57 -> Int-Location equals 
( C56 -thRWNotIn ( UsedIntLoc C57 ) );
correctness;
end;
notation
let C58 being (Element of ( NAT ));
let C59 being (preProgram of ( SCM+FSA ));
synonym C58 -stNotUsed C59 for C58 -thNotUsed C59;
synonym C58 -ndNotUsed C59 for C58 -thNotUsed C59;
synonym C58 -rdNotUsed C59 for C58 -thNotUsed C59;
end;
registration
let C60 being (Element of ( NAT ));
let C61 being (preProgram of ( SCM+FSA ));
cluster ( C60 -thNotUsed C61 ) ->  read-write;
coherence;
end;
begin
canceled 5;
theorem
L481: (for R12 being Int-Location holds (for R13 being Int-Location holds (R12 in ( UsedIntLoc ( swap (R12 , R13) ) ) & R13 in ( UsedIntLoc ( swap (R12 , R13) ) ))))
proof
let R12 being Int-Location;
let R13 being Int-Location;
set D89 = ( FirstNotUsed ( Macro ( R12 := R13 ) ) );
set D90 = ( ( FirstNotUsed ( Macro ( R12 := R13 ) ) ) := R12 );
set D91 = ( R12 := R13 );
set D92 = ( R13 := ( FirstNotUsed ( Macro ( R12 := R13 ) ) ) );
L482: ( UsedIntLoc ( swap (R12 , R13) ) ) = ( UsedIntLoc ( ( D90 ";" D91 ) ";" D92 ) ) by SCMFSA6C:def 3
.= ( ( UsedIntLoc ( D90 ";" D91 ) ) \/ ( UsedIntLoc D92 ) ) by SF_MASTR:30
.= ( ( UsedIntLoc ( D90 ";" D91 ) ) \/ { R13 , D89 } ) by SF_MASTR:14
.= ( ( ( UsedIntLoc D90 ) \/ ( UsedIntLoc D91 ) ) \/ { R13 , D89 } ) by SF_MASTR:31
.= ( ( ( UsedIntLoc D90 ) \/ { R12 , R13 } ) \/ { R13 , D89 } ) by SF_MASTR:14
.= ( ( { D89 , R12 } \/ { R12 , R13 } ) \/ { R13 , D89 } ) by SF_MASTR:14
.= ( { D89 , R12 , R12 , R13 } \/ { R13 , D89 } ) by ENUMSET1:5
.= { D89 , R12 , R12 , R13 , R13 , D89 } by ENUMSET1:14;
thus L483: R12 in ( UsedIntLoc ( swap (R12 , R13) ) ) by L482 , ENUMSET1:def 4;
thus L484: thesis by L482 , ENUMSET1:def 4;
end;
definition
let C62 , C63 being Int-Location;
func Fib_macro (C62 , C63) -> (Program of ( SCM+FSA )) equals 
( ( ( ( ( ( ( 2 -ndRWNotIn ( UsedIntLoc ( swap (C63 , ( 1 -stRWNotIn { C62 , C63 } )) ) ) ) := C62 ) ";" ( SubFrom (C63 , C63) ) ) ";" ( ( 1 -stRWNotIn { C62 , C63 } ) := ( intloc ( 0 ) ) ) ) ";" ( ( 1 -stRWNotIn ( UsedIntLoc ( swap (C63 , ( 1 -stRWNotIn { C62 , C63 } )) ) ) ) := ( 2 -ndRWNotIn ( UsedIntLoc ( swap (C63 , ( 1 -stRWNotIn { C62 , C63 } )) ) ) ) ) ) ";" ( Times (( 1 -stRWNotIn ( UsedIntLoc ( swap (C63 , ( 1 -stRWNotIn { C62 , C63 } )) ) ) ) , ( ( AddTo (C63 , ( 1 -stRWNotIn { C62 , C63 } )) ) ";" ( swap (C63 , ( 1 -stRWNotIn { C62 , C63 } )) ) )) ) ) ";" ( C62 := ( 2 -ndRWNotIn ( UsedIntLoc ( swap (C63 , ( 1 -stRWNotIn { C62 , C63 } )) ) ) ) ) );
correctness;
end;
theorem
L486: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (State of ( SCM+FSA )) holds (for B22 , B23 being  read-write Int-Location holds (B22 <> B23 implies (for B24 being (Element of ( NAT )) holds (B24 = ( R5 . B22 ) implies (( ( IExec (( Fib_macro (B22 , B23) ) , R1 , R5) ) . B23 ) = ( Fib B24 ) & ( ( IExec (( Fib_macro (B22 , B23) ) , R1 , R5) ) . B22 ) = ( R5 . B22 ))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (State of ( SCM+FSA ));
let C64 , C65 being  read-write Int-Location;
assume that
L487: C64 <> C65;
set D93 = ( SubFrom (C65 , C65) );
set D94 = ( 1 -stRWNotIn { C64 , C65 } );
set D95 = ( 1 -stRWNotIn ( UsedIntLoc ( swap (C65 , D94) ) ) );
set D96 = ( 2 -ndRWNotIn ( UsedIntLoc ( swap (C65 , D94) ) ) );
set D97 = ( D96 := C64 );
set D98 = ( D94 := ( intloc ( 0 ) ) );
set D99 = ( D95 := D96 );
set D100 = ( AddTo (C65 , D94) );
set D101 = ( swap (C65 , D94) );
set D102 = ( ( ( D97 ";" D93 ) ";" D98 ) ";" D99 );
set D103 = ( IExec (D102 , R1 , R5) );
set D104 = R1;
reconsider D105 = ( D100 ";" D101 ) as  good  parahalting (Program of ( SCM+FSA ));
set D106 = ( Times (D95 , D105) );
set D107 = ( C64 := D96 );
defpred S2[ (Element of ( NAT )) ] means (for B25 being (State of ( SCM+FSA )) holds (($1 = ( B25 . D95 ) & ( B25 . ( intloc ( 0 ) ) ) = 1) implies (( ( IExec (D106 , D104 , B25) ) . D96 ) = ( B25 . D96 ) & (for B26 being (Element of ( NAT )) holds ((( B25 . C65 ) = ( Fib B26 ) & ( B25 . D94 ) = ( Fib ( B26 + 1 ) )) implies (( ( IExec (D106 , D104 , B25) ) . C65 ) = ( Fib ( B26 + $1 ) ) & ( ( IExec (D106 , D104 , B25) ) . D94 ) = ( Fib ( ( B26 + 1 ) + $1 ) )))))));
let C66 being (Element of ( NAT ));
assume that
L488: C66 = ( R5 . C64 );
L489: (not D94 in { C64 , C65 }) by SCMFSA_M:25;
L490: C65 <> D94 by L489 , TARSKI:def 2;
L491: D96 <> D95 by SCMFSA_M:26;
L492: D96 <> D94 by L481 , SCMFSA_M:25;
L493: D96 <> C65 by L481 , SCMFSA_M:25;
L494: ( D103 . D95 ) = ( ( Exec (D99 , ( IExec (( ( D97 ";" D93 ) ";" D98 ) , R1 , R5) )) ) . D95 ) by SCMFSA6C:6
.= ( ( IExec (( ( D97 ";" D93 ) ";" D98 ) , R1 , R5) ) . D96 ) by SCMFSA_2:63
.= ( ( Exec (D98 , ( IExec (( D97 ";" D93 ) , R1 , R5) )) ) . D96 ) by SCMFSA6C:6
.= ( ( IExec (( D97 ";" D93 ) , R1 , R5) ) . D96 ) by L492 , SCMFSA_2:63
.= ( ( Exec (D93 , ( Exec (D97 , ( Initialized R5 )) )) ) . D96 ) by SCMFSA6C:8
.= ( ( Exec (D97 , ( Initialized R5 )) ) . D96 ) by L493 , SCMFSA_2:65
.= ( ( Initialized R5 ) . C64 ) by SCMFSA_2:63
.= ( R5 . C64 ) by SCMFSA_M:37;
L495: (not D101 destroy D95) by L34 , SCMFSA_M:25;
L496: D102 is_closed_on ( Initialized R5 ) , R1 by SCMFSA7B:18;
L497: ( D103 . D96 ) = ( ( Exec (D99 , ( IExec (( ( D97 ";" D93 ) ";" D98 ) , R1 , R5) )) ) . D96 ) by SCMFSA6C:6
.= ( ( IExec (( ( D97 ";" D93 ) ";" D98 ) , R1 , R5) ) . D96 ) by L491 , SCMFSA_2:63
.= ( ( Exec (D98 , ( IExec (( D97 ";" D93 ) , R1 , R5) )) ) . D96 ) by SCMFSA6C:6
.= ( ( IExec (( D97 ";" D93 ) , R1 , R5) ) . D96 ) by L492 , SCMFSA_2:63
.= ( ( Exec (D93 , ( Exec (D97 , ( Initialized R5 )) )) ) . D96 ) by SCMFSA6C:8
.= ( ( Exec (D97 , ( Initialized R5 )) ) . D96 ) by L493 , SCMFSA_2:65
.= ( ( Initialized R5 ) . C64 ) by SCMFSA_2:63
.= ( R5 . C64 ) by SCMFSA_M:37;
L498: D102 is_halting_on ( Initialized R5 ) , R1 by SCMFSA7B:19;
reconsider D108 = D102 as  good (Program of ( SCM+FSA ));
L499: (not D95 in ( UsedIntLoc D101 )) by SCMFSA_M:25;
L500: C65 in ( UsedIntLoc D101 ) by L481;
L501: (not ( Macro D100 ) destroy D95) by L500 , L499 , SCMFSA7B:7 , SCMFSA8C:48;
L502: (not D105 destroy D95) by L501 , L495 , SCMFSA8C:52;
L503: D94 in ( UsedIntLoc D101 ) by L481;
L504:
now
let C67 being (Element of ( NAT ));
assume that
L505: S2[ C67 ];
thus L506: S2[ ( C67 + 1 ) ]
proof
let C68 being (State of ( SCM+FSA ));
assume that
L507: ( C67 + 1 ) = ( C68 . D95 )
and
L508: ( C68 . ( intloc ( 0 ) ) ) = 1;
set D109 = ( IExec (( D105 ";" ( SubFrom (D95 , ( intloc ( 0 ) )) ) ) , D104 , C68) );
set D110 = D104;
L509: ( C68 . D95 ) > ( 0 ) by L507 , NAT_1:3;
L510: ( D109 . D95 ) = ( ( C67 + 1 ) - 1 ) by L509 , L502 , L507 , SCMFSA8C:91
.= C67;
L511: ( D109 . ( intloc ( 0 ) ) ) = ( ( Exec (( SubFrom (D95 , ( intloc ( 0 ) )) ) , ( IExec (D105 , D104 , C68) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:6
.= ( ( IExec (D105 , D104 , C68) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:65
.= 1 by SCMFSA6B:11;
L512: ( DataPart ( IExec (D106 , D104 , C68) ) ) = ( DataPart ( IExec (D106 , D110 , D109) ) ) by L502 , L509 , SCMFSA8C:91;
thus L513: ( ( IExec (D106 , D104 , C68) ) . D96 ) = ( ( IExec (D106 , D110 , D109) ) . D96 ) by L512 , SCMFSA_M:2
.= ( D109 . D96 ) by L505 , L510 , L511
.= ( ( Exec (( SubFrom (D95 , ( intloc ( 0 ) )) ) , ( IExec (D105 , D104 , C68) )) ) . D96 ) by SCMFSA6C:6
.= ( ( IExec (D105 , D104 , C68) ) . D96 ) by L491 , SCMFSA_2:65
.= ( ( IExec (D101 , D104 , ( Exec (D100 , ( Initialized C68 )) )) ) . D96 ) by SCMFSA8B:9
.= ( ( Exec (D100 , ( Initialized C68 )) ) . D96 ) by SCMFSA6B:3 , SCMFSA_M:25
.= ( ( Initialized C68 ) . D96 ) by L493 , SCMFSA_2:64
.= ( C68 . D96 ) by SCMFSA_M:37;
let C69 being (Element of ( NAT ));
assume that
L514: ( C68 . C65 ) = ( Fib C69 )
and
L515: ( C68 . D94 ) = ( Fib ( C69 + 1 ) );
L516: ( D109 . D94 ) = ( ( Exec (( SubFrom (D95 , ( intloc ( 0 ) )) ) , ( IExec (D105 , D104 , C68) )) ) . D94 ) by SCMFSA6C:6
.= ( ( IExec (D105 , D104 , C68) ) . D94 ) by L499 , L503 , SCMFSA_2:65
.= ( ( IExec (D101 , D104 , ( Exec (D100 , ( Initialized C68 )) )) ) . D94 ) by SCMFSA8B:9
.= ( ( Exec (D100 , ( Initialized C68 )) ) . C65 ) by SCMFSA6C:10
.= ( ( ( Initialized C68 ) . C65 ) + ( ( Initialized C68 ) . D94 ) ) by SCMFSA_2:64
.= ( ( C68 . C65 ) + ( ( Initialized C68 ) . D94 ) ) by SCMFSA_M:37
.= ( ( C68 . C65 ) + ( C68 . D94 ) ) by SCMFSA_M:37
.= ( Fib ( ( C69 + 1 ) + 1 ) ) by L514 , L515 , PRE_FF:1;
L517: ( D109 . C65 ) = ( ( Exec (( SubFrom (D95 , ( intloc ( 0 ) )) ) , ( IExec (D105 , D104 , C68) )) ) . C65 ) by SCMFSA6C:6
.= ( ( IExec (D105 , D104 , C68) ) . C65 ) by L499 , L500 , SCMFSA_2:65
.= ( ( IExec (D101 , D104 , ( Exec (D100 , ( Initialized C68 )) )) ) . C65 ) by SCMFSA8B:9
.= ( ( Exec (D100 , ( Initialized C68 )) ) . D94 ) by SCMFSA6C:10
.= ( ( Initialized C68 ) . D94 ) by L490 , SCMFSA_2:64
.= ( Fib ( C69 + 1 ) ) by L515 , SCMFSA_M:37;
thus L518: ( ( IExec (D106 , D104 , C68) ) . C65 ) = ( ( IExec (D106 , D110 , D109) ) . C65 ) by L512 , SCMFSA_M:2
.= ( Fib ( ( C69 + 1 ) + C67 ) ) by L505 , L510 , L511 , L517 , L516
.= ( Fib ( C69 + ( C67 + 1 ) ) );
thus L519: ( ( IExec (D106 , D104 , C68) ) . D94 ) = ( ( IExec (D106 , D110 , D109) ) . D94 ) by L512 , SCMFSA_M:2
.= ( Fib ( ( ( C69 + 1 ) + 1 ) + C67 ) ) by L505 , L510 , L511 , L517 , L516
.= ( Fib ( ( C69 + 1 ) + ( C67 + 1 ) ) );
end;

end;
L507: ( D103 . C65 ) = ( ( Exec (D99 , ( IExec (( ( D97 ";" D93 ) ";" D98 ) , R1 , R5) )) ) . C65 ) by SCMFSA6C:6
.= ( ( IExec (( ( D97 ";" D93 ) ";" D98 ) , R1 , R5) ) . C65 ) by L499 , L500 , SCMFSA_2:63
.= ( ( Exec (D98 , ( IExec (( D97 ";" D93 ) , R1 , R5) )) ) . C65 ) by SCMFSA6C:6
.= ( ( IExec (( D97 ";" D93 ) , R1 , R5) ) . C65 ) by L490 , SCMFSA_2:63
.= ( ( Exec (D93 , ( Exec (D97 , ( Initialized R5 )) )) ) . C65 ) by SCMFSA6C:8
.= ( ( ( Exec (D97 , ( Initialized R5 )) ) . C65 ) - ( ( Exec (D97 , ( Initialized R5 )) ) . C65 ) ) by SCMFSA_2:65
.= ( Fib ( 0 ) ) by PRE_FF:1;
L508: ( D103 . D94 ) = ( ( Exec (D99 , ( IExec (( ( D97 ";" D93 ) ";" D98 ) , R1 , R5) )) ) . D94 ) by SCMFSA6C:6
.= ( ( IExec (( ( D97 ";" D93 ) ";" D98 ) , R1 , R5) ) . D94 ) by L499 , L503 , SCMFSA_2:63
.= ( ( Exec (D98 , ( IExec (( D97 ";" D93 ) , R1 , R5) )) ) . D94 ) by SCMFSA6C:6
.= ( ( IExec (( D97 ";" D93 ) , R1 , R5) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= ( ( Exec (D93 , ( Exec (D97 , ( Initialized R5 )) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:8
.= ( ( Exec (D97 , ( Initialized R5 )) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:65
.= ( ( Initialized R5 ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= ( Fib ( ( 0 ) + 1 ) ) by PRE_FF:1 , SCMFSA_M:9;
L509: ( D103 . ( intloc ( 0 ) ) ) = ( ( Exec (D99 , ( IExec (( ( D97 ";" D93 ) ";" D98 ) , R1 , R5) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:6
.= ( ( IExec (( ( D97 ";" D93 ) ";" D98 ) , R1 , R5) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= ( ( Exec (D98 , ( IExec (( D97 ";" D93 ) , R1 , R5) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:6
.= ( ( IExec (( D97 ";" D93 ) , R1 , R5) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= ( ( Exec (D93 , ( Exec (D97 , ( Initialized R5 )) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:8
.= ( ( Exec (D97 , ( Initialized R5 )) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:65
.= ( ( Initialized R5 ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= 1 by SCMFSA_M:9;
L510: D106 is_closed_on D103 , D104 by L509 , L502 , SCMFSA8C:86;
L511: S2[ ( 0 ) ]
proof
let C70 being (State of ( SCM+FSA ));
assume that
L512: ( 0 ) = ( C70 . D95 )
and
L513: ( C70 . ( intloc ( 0 ) ) ) = 1;
L514: ( DataPart ( IExec (D106 , D104 , C70) ) ) = ( DataPart C70 ) by L512 , L513 , SCMFSA8C:90;
thus L515: ( ( IExec (D106 , D104 , C70) ) . D96 ) = ( C70 . D96 ) by L514 , SCMFSA_M:2;
let C71 being (Element of ( NAT ));
assume that
L516: ( C70 . C65 ) = ( Fib C71 )
and
L517: ( C70 . D94 ) = ( Fib ( C71 + 1 ) );
thus L518: ( ( IExec (D106 , D104 , C70) ) . C65 ) = ( Fib ( C71 + ( 0 ) ) ) by L514 , L516 , SCMFSA_M:2;
thus L519: thesis by L514 , L517 , SCMFSA_M:2;
end;
L520: (for B27 being (Element of ( NAT )) holds S2[ B27 ]) from NAT_1:sch 1(L511 , L504);
L521: D106 is_halting_on D103 , D104 by L502 , L509 , SCMFSA8C:86;
L522: ( D108 ";" D106 ) is_closed_on ( Initialized R5 ) , R1 by L498 , L510 , L496 , L95;
thus L523: ( ( IExec (( Fib_macro (C64 , C65) ) , R1 , R5) ) . C65 ) = ( ( Exec (D107 , ( IExec (( D108 ";" D106 ) , R1 , R5) )) ) . C65 ) by L522 , L498 , L510 , L521 , L496 , L140 , L442
.= ( ( IExec (( D108 ";" D106 ) , R1 , R5) ) . C65 ) by L487 , SCMFSA_2:63
.= ( ( IExec (D106 , D104 , D103) ) . C65 ) by L510 , L521 , L399
.= ( Fib ( ( 0 ) + C66 ) ) by L520 , L509 , L507 , L508 , L494 , L488
.= ( Fib C66 );
thus L524: ( ( IExec (( Fib_macro (C64 , C65) ) , R1 , R5) ) . C64 ) = ( ( Exec (D107 , ( IExec (( D108 ";" D106 ) , R1 , R5) )) ) . C64 ) by L498 , L510 , L521 , L496 , L522 , L140 , L442
.= ( ( IExec (( D108 ";" D106 ) , R1 , R5) ) . D96 ) by SCMFSA_2:63
.= ( ( IExec (D106 , D104 , D103) ) . D96 ) by L510 , L521 , L399
.= ( R5 . C64 ) by L520 , L509 , L497 , L494 , L488;
end;
