:: Variables in Formulae of the First Order Language
::  by Czes{\l}aw Byli\'nski and Grzegorz Bancerek
::
:: Received November 23, 1989
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies SUBSET_1, NUMBERS, QC_LANG1, FINSEQ_1, XBOOLE_0, FUNCT_1,
      ZF_LANG, XXREAL_0, CLASSES2, REALSET1, BVFUNC_2, XBOOLEAN, MARGREL1,
      ZF_LANG1, TARSKI, ZFMISC_1, QC_LANG2, RCOMP_1, ZF_MODEL, QC_LANG3;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, FUNCT_1, FUNCT_2,
      FINSEQ_1, QC_LANG1, QC_LANG2, XXREAL_0;
 constructors FUNCT_2, XXREAL_0, MEMBERED, QC_LANG2, RELSET_1;
 registrations SUBSET_1, ORDINAL1, RELSET_1, MEMBERED, QC_LANG1;
 requirements NUMERALS, BOOLE, SUBSET;
 definitions TARSKI, QC_LANG1;
 theorems TARSKI, ZFMISC_1, FUNCT_2, QC_LANG1, QC_LANG2, XBOOLE_1, XTUPLE_0;
 schemes QC_LANG1;

begin
scheme QCFuncUniq { F1() -> QC-alphabet , F2() -> non  empty set , F3 , F4() -> (Function of ( QC-WFF F1() ) , F2()) , F5() -> (Element of F2()) , F6 , F7(set) -> (Element of F2()) , F8(set , set) -> (Element of F2()) , F9(set , set) -> (Element of F2()) } : F3() = F4()
provided
L1: (for B1 being (Element of ( QC-WFF F1() )) holds (for B2 , B3 being (Element of F2()) holds ((B1 = ( VERUM F1() ) implies ( F3() . B1 ) = F5()) & (B1 is  atomic implies ( F3() . B1 ) = F6(B1)) & ((B1 is  negative & B2 = ( F3() . ( the_argument_of B1 ) )) implies ( F3() . B1 ) = F7(B2)) & ((B1 is  conjunctive & B2 = ( F3() . ( the_left_argument_of B1 ) ) & B3 = ( F3() . ( the_right_argument_of B1 ) )) implies ( F3() . B1 ) = F8(B2 , B3)) & ((B1 is  universal & B2 = ( F3() . ( the_scope_of B1 ) )) implies ( F3() . B1 ) = F9(B1 , B2)))))
and
L2: (for B4 being (Element of ( QC-WFF F1() )) holds (for B5 , B6 being (Element of F2()) holds ((B4 = ( VERUM F1() ) implies ( F4() . B4 ) = F5()) & (B4 is  atomic implies ( F4() . B4 ) = F6(B4)) & ((B4 is  negative & B5 = ( F4() . ( the_argument_of B4 ) )) implies ( F4() . B4 ) = F7(B5)) & ((B4 is  conjunctive & B5 = ( F4() . ( the_left_argument_of B4 ) ) & B6 = ( F4() . ( the_right_argument_of B4 ) )) implies ( F4() . B4 ) = F8(B5 , B6)) & ((B4 is  universal & B5 = ( F4() . ( the_scope_of B4 ) )) implies ( F4() . B4 ) = F9(B4 , B5)))))
proof
defpred S1[ (Element of ( QC-WFF F1() )) ] means ( F3() . $1 ) = ( F4() . $1 );
L3: (for R2 being (Element of ( NAT )) holds (for B7 being (QC-pred_symbol of R2 , F1()) holds (for B8 being (QC-variable_list of R2 , F1()) holds S1[ ( B7 ! B8 ) ])))
proof
let R2 being (Element of ( NAT ));
let C1 being (QC-pred_symbol of R2 , F1());
let C2 being (QC-variable_list of R2 , F1());
L4: ( C1 ! C2 ) is  atomic by QC_LANG1:def 18;
thus L5: ( F3() . ( C1 ! C2 ) ) = F6(( C1 ! C2 )) by L4 , L1
.= ( F4() . ( C1 ! C2 ) ) by L2 , L4;
end;
L6: (for B9 being (bound_QC-variable of F1()) holds (for B10 being (Element of ( QC-WFF F1() )) holds (S1[ B10 ] implies S1[ ( All (B9 , B10) ) ])))
proof
let C3 being (bound_QC-variable of F1());
let C4 being (Element of ( QC-WFF F1() ));
assume that
L7: ( F3() . C4 ) = ( F4() . C4 );
L8: ( All (C3 , C4) ) is  universal by QC_LANG1:def 21;
L9: ( the_scope_of ( All (C3 , C4) ) ) = C4 by L8 , QC_LANG1:def 28;
thus L10: ( F3() . ( All (C3 , C4) ) ) = F9(( All (C3 , C4) ) , ( F4() . ( the_scope_of ( All (C3 , C4) ) ) )) by L9 , L1 , L7 , L8
.= ( F4() . ( All (C3 , C4) ) ) by L2 , L8;
end;
L11: (for B11 , B12 being (Element of ( QC-WFF F1() )) holds ((S1[ B11 ] & S1[ B12 ]) implies S1[ ( B11 '&' B12 ) ]))
proof
let C5 , C6 being (Element of ( QC-WFF F1() ));
assume that
L12: (( F3() . C5 ) = ( F4() . C5 ) & ( F3() . C6 ) = ( F4() . C6 ));
L13: ( C5 '&' C6 ) is  conjunctive by QC_LANG1:def 20;
L14: (( the_left_argument_of ( C5 '&' C6 ) ) = C5 & ( the_right_argument_of ( C5 '&' C6 ) ) = C6) by L13 , QC_LANG1:def 25 , QC_LANG1:def 26;
thus L15: ( F3() . ( C5 '&' C6 ) ) = F8(( F4() . C5 ) , ( F4() . C6 )) by L14 , L1 , L12 , L13
.= ( F4() . ( C5 '&' C6 ) ) by L2 , L13 , L14;
end;
L16: (for B13 being (Element of ( QC-WFF F1() )) holds (S1[ B13 ] implies S1[ ( 'not' B13 ) ]))
proof
let C7 being (Element of ( QC-WFF F1() ));
assume that
L17: ( F3() . C7 ) = ( F4() . C7 );
L18: ( 'not' C7 ) is  negative by QC_LANG1:def 19;
L19: ( the_argument_of ( 'not' C7 ) ) = C7 by L18 , QC_LANG1:def 24;
thus L20: ( F3() . ( 'not' C7 ) ) = F7(( F4() . C7 )) by L19 , L1 , L17 , L18
.= ( F4() . ( 'not' C7 ) ) by L2 , L18 , L19;
end;
L21: ( F3() . ( VERUM F1() ) ) = F5() by L1;
L22: S1[ ( VERUM F1() ) ] by L21 , L2;
L23: (for B14 being (Element of ( QC-WFF F1() )) holds S1[ B14 ]) from QC_LANG1:sch 1(L3 , L22 , L16 , L11 , L6);
thus L24: thesis by L23 , FUNCT_2:63;
end;
scheme QCDefD { F10() -> QC-alphabet , F11() -> non  empty set , F12() -> (Element of F11()) , F13() -> (Element of ( QC-WFF F10() )) , F14((Element of ( QC-WFF F10() ))) -> (Element of F11()) , F15((Element of F11())) -> (Element of F11()) , F16((Element of F11()) , (Element of F11())) -> (Element of F11()) , F17((Element of ( QC-WFF F10() )) , (Element of F11())) -> (Element of F11()) } : ((ex B15 being (Element of F11()) st (ex B16 being (Function of ( QC-WFF F10() ) , F11()) st (B15 = ( B16 . F13() ) & (for B17 being (Element of ( QC-WFF F10() )) holds (for B18 , B19 being (Element of F11()) holds ((B17 = ( VERUM F10() ) implies ( B16 . B17 ) = F12()) & (B17 is  atomic implies ( B16 . B17 ) = F14(B17)) & ((B17 is  negative & B18 = ( B16 . ( the_argument_of B17 ) )) implies ( B16 . B17 ) = F15(B18)) & ((B17 is  conjunctive & B18 = ( B16 . ( the_left_argument_of B17 ) ) & B19 = ( B16 . ( the_right_argument_of B17 ) )) implies ( B16 . B17 ) = F16(B18 , B19)) & ((B17 is  universal & B18 = ( B16 . ( the_scope_of B17 ) )) implies ( B16 . B17 ) = F17(B17 , B18)))))))) & (for B20 , B21 being (Element of F11()) holds (((ex B22 being (Function of ( QC-WFF F10() ) , F11()) st (B20 = ( B22 . F13() ) & (for B23 being (Element of ( QC-WFF F10() )) holds (for B24 , B25 being (Element of F11()) holds ((B23 = ( VERUM F10() ) implies ( B22 . B23 ) = F12()) & (B23 is  atomic implies ( B22 . B23 ) = F14(B23)) & ((B23 is  negative & B24 = ( B22 . ( the_argument_of B23 ) )) implies ( B22 . B23 ) = F15(B24)) & ((B23 is  conjunctive & B24 = ( B22 . ( the_left_argument_of B23 ) ) & B25 = ( B22 . ( the_right_argument_of B23 ) )) implies ( B22 . B23 ) = F16(B24 , B25)) & ((B23 is  universal & B24 = ( B22 . ( the_scope_of B23 ) )) implies ( B22 . B23 ) = F17(B23 , B24))))))) & (ex B26 being (Function of ( QC-WFF F10() ) , F11()) st (B21 = ( B26 . F13() ) & (for B27 being (Element of ( QC-WFF F10() )) holds (for B28 , B29 being (Element of F11()) holds ((B27 = ( VERUM F10() ) implies ( B26 . B27 ) = F12()) & (B27 is  atomic implies ( B26 . B27 ) = F14(B27)) & ((B27 is  negative & B28 = ( B26 . ( the_argument_of B27 ) )) implies ( B26 . B27 ) = F15(B28)) & ((B27 is  conjunctive & B28 = ( B26 . ( the_left_argument_of B27 ) ) & B29 = ( B26 . ( the_right_argument_of B27 ) )) implies ( B26 . B27 ) = F16(B28 , B29)) & ((B27 is  universal & B28 = ( B26 . ( the_scope_of B27 ) )) implies ( B26 . B27 ) = F17(B27 , B28)))))))) implies B20 = B21)))
proof
thus L25: (ex B30 being (Element of F11()) st (ex B31 being (Function of ( QC-WFF F10() ) , F11()) st (B30 = ( B31 . F13() ) & (for B32 being (Element of ( QC-WFF F10() )) holds (for B33 , B34 being (Element of F11()) holds ((B32 = ( VERUM F10() ) implies ( B31 . B32 ) = F12()) & (B32 is  atomic implies ( B31 . B32 ) = F14(B32)) & ((B32 is  negative & B33 = ( B31 . ( the_argument_of B32 ) )) implies ( B31 . B32 ) = F15(B33)) & ((B32 is  conjunctive & B33 = ( B31 . ( the_left_argument_of B32 ) ) & B34 = ( B31 . ( the_right_argument_of B32 ) )) implies ( B31 . B32 ) = F16(B33 , B34)) & ((B32 is  universal & B33 = ( B31 . ( the_scope_of B32 ) )) implies ( B31 . B32 ) = F17(B32 , B33))))))))
proof
consider C8 being (Function of ( QC-WFF F10() ) , F11()) such that L26: (( C8 . ( VERUM F10() ) ) = F12() & (for B35 being (Element of ( QC-WFF F10() )) holds ((B35 is  atomic implies ( C8 . B35 ) = F14(B35)) & (B35 is  negative implies ( C8 . B35 ) = F15(( C8 . ( the_argument_of B35 ) ))) & (B35 is  conjunctive implies ( C8 . B35 ) = F16(( C8 . ( the_left_argument_of B35 ) ) , ( C8 . ( the_right_argument_of B35 ) ))) & (B35 is  universal implies ( C8 . B35 ) = F17(B35 , ( C8 . ( the_scope_of B35 ) )))))) from QC_LANG1:sch 3;
take ( C8 . F13() );
take C8;
thus L27: thesis by L26;
end;

let C9 , C10 being (Element of F11());
given C11 being (Function of ( QC-WFF F10() ) , F11()) such that
L28: C9 = ( C11 . F13() )
and
L29: (for B36 being (Element of ( QC-WFF F10() )) holds (for B37 , B38 being (Element of F11()) holds ((B36 = ( VERUM F10() ) implies ( C11 . B36 ) = F12()) & (B36 is  atomic implies ( C11 . B36 ) = F14(B36)) & ((B36 is  negative & B37 = ( C11 . ( the_argument_of B36 ) )) implies ( C11 . B36 ) = F15(B37)) & ((B36 is  conjunctive & B37 = ( C11 . ( the_left_argument_of B36 ) ) & B38 = ( C11 . ( the_right_argument_of B36 ) )) implies ( C11 . B36 ) = F16(B37 , B38)) & ((B36 is  universal & B37 = ( C11 . ( the_scope_of B36 ) )) implies ( C11 . B36 ) = F17(B36 , B37)))));

given C12 being (Function of ( QC-WFF F10() ) , F11()) such that
L30: C10 = ( C12 . F13() )
and
L31: (for B39 being (Element of ( QC-WFF F10() )) holds (for B40 , B41 being (Element of F11()) holds ((B39 = ( VERUM F10() ) implies ( C12 . B39 ) = F12()) & (B39 is  atomic implies ( C12 . B39 ) = F14(B39)) & ((B39 is  negative & B40 = ( C12 . ( the_argument_of B39 ) )) implies ( C12 . B39 ) = F15(B40)) & ((B39 is  conjunctive & B40 = ( C12 . ( the_left_argument_of B39 ) ) & B41 = ( C12 . ( the_right_argument_of B39 ) )) implies ( C12 . B39 ) = F16(B40 , B41)) & ((B39 is  universal & B40 = ( C12 . ( the_scope_of B39 ) )) implies ( C12 . B39 ) = F17(B39 , B40)))));

L32: C11 = C12 from QCFuncUniq(L29 , L31);
thus L33: thesis by L32 , L28 , L30;
end;
scheme QCDResult9VERUM { F18() -> QC-alphabet , F19() -> non  empty set , F20((Element of ( QC-WFF F18() ))) -> (Element of F19()) , F21() -> (Element of F19()) , F22((Element of ( QC-WFF F18() ))) -> (Element of F19()) , F23((Element of F19())) -> (Element of F19()) , F24((Element of F19()) , (Element of F19())) -> (Element of F19()) , F25((Element of ( QC-WFF F18() )) , (Element of F19())) -> (Element of F19()) } : F20(( VERUM F18() )) = F21()
provided
L34: (for B42 being (QC-formula of F18()) holds (for B43 being (Element of F19()) holds (B43 = F20(B42) iff (ex B44 being (Function of ( QC-WFF F18() ) , F19()) st (B43 = ( B44 . B42 ) & (for B45 being (Element of ( QC-WFF F18() )) holds (for B46 , B47 being (Element of F19()) holds ((B45 = ( VERUM F18() ) implies ( B44 . B45 ) = F21()) & (B45 is  atomic implies ( B44 . B45 ) = F22(B45)) & ((B45 is  negative & B46 = ( B44 . ( the_argument_of B45 ) )) implies ( B44 . B45 ) = F23(B46)) & ((B45 is  conjunctive & B46 = ( B44 . ( the_left_argument_of B45 ) ) & B47 = ( B44 . ( the_right_argument_of B45 ) )) implies ( B44 . B45 ) = F24(B46 , B47)) & ((B45 is  universal & B46 = ( B44 . ( the_scope_of B45 ) )) implies ( B44 . B45 ) = F25(B45 , B46))))))))))
proof
L35: (ex B48 being (Function of ( QC-WFF F18() ) , F19()) st (F20(( VERUM F18() )) = ( B48 . ( VERUM F18() ) ) & (for B49 being (Element of ( QC-WFF F18() )) holds (for B50 , B51 being (Element of F19()) holds ((B49 = ( VERUM F18() ) implies ( B48 . B49 ) = F21()) & (B49 is  atomic implies ( B48 . B49 ) = F22(B49)) & ((B49 is  negative & B50 = ( B48 . ( the_argument_of B49 ) )) implies ( B48 . B49 ) = F23(B50)) & ((B49 is  conjunctive & B50 = ( B48 . ( the_left_argument_of B49 ) ) & B51 = ( B48 . ( the_right_argument_of B49 ) )) implies ( B48 . B49 ) = F24(B50 , B51)) & ((B49 is  universal & B50 = ( B48 . ( the_scope_of B49 ) )) implies ( B48 . B49 ) = F25(B49 , B50))))))) by L34;
thus L36: thesis by L35;
end;
scheme QCDResult9atomic { F26() -> QC-alphabet , F27() -> non  empty set , F28() -> (Element of F27()) , F29((Element of ( QC-WFF F26() ))) -> (Element of F27()) , F30() -> (QC-formula of F26()) , F31((Element of ( QC-WFF F26() ))) -> (Element of F27()) , F32((Element of F27())) -> (Element of F27()) , F33((Element of F27()) , (Element of F27())) -> (Element of F27()) , F34((Element of ( QC-WFF F26() )) , (Element of F27())) -> (Element of F27()) } : F29(F30()) = F31(F30())
provided
L37: (for B52 being (QC-formula of F26()) holds (for B53 being (Element of F27()) holds (B53 = F29(B52) iff (ex B54 being (Function of ( QC-WFF F26() ) , F27()) st (B53 = ( B54 . B52 ) & (for B55 being (Element of ( QC-WFF F26() )) holds (for B56 , B57 being (Element of F27()) holds ((B55 = ( VERUM F26() ) implies ( B54 . B55 ) = F28()) & (B55 is  atomic implies ( B54 . B55 ) = F31(B55)) & ((B55 is  negative & B56 = ( B54 . ( the_argument_of B55 ) )) implies ( B54 . B55 ) = F32(B56)) & ((B55 is  conjunctive & B56 = ( B54 . ( the_left_argument_of B55 ) ) & B57 = ( B54 . ( the_right_argument_of B55 ) )) implies ( B54 . B55 ) = F33(B56 , B57)) & ((B55 is  universal & B56 = ( B54 . ( the_scope_of B55 ) )) implies ( B54 . B55 ) = F34(B55 , B56))))))))))
and
L38: F30() is  atomic
proof
L39: (ex B58 being (Function of ( QC-WFF F26() ) , F27()) st (F29(F30()) = ( B58 . F30() ) & (for B59 being (Element of ( QC-WFF F26() )) holds (for B60 , B61 being (Element of F27()) holds ((B59 = ( VERUM F26() ) implies ( B58 . B59 ) = F28()) & (B59 is  atomic implies ( B58 . B59 ) = F31(B59)) & ((B59 is  negative & B60 = ( B58 . ( the_argument_of B59 ) )) implies ( B58 . B59 ) = F32(B60)) & ((B59 is  conjunctive & B60 = ( B58 . ( the_left_argument_of B59 ) ) & B61 = ( B58 . ( the_right_argument_of B59 ) )) implies ( B58 . B59 ) = F33(B60 , B61)) & ((B59 is  universal & B60 = ( B58 . ( the_scope_of B59 ) )) implies ( B58 . B59 ) = F34(B59 , B60))))))) by L37;
thus L40: thesis by L39 , L38;
end;
scheme QCDResult9negative { F35() -> QC-alphabet , F36() -> non  empty set , F37() -> (Element of F36()) , F38() -> (QC-formula of F35()) , F39((Element of ( QC-WFF F35() ))) -> (Element of F36()) , F40((Element of F36())) -> (Element of F36()) , F41((Element of F36()) , (Element of F36())) -> (Element of F36()) , F42((Element of ( QC-WFF F35() )) , (Element of F36())) -> (Element of F36()) , F43((Element of ( QC-WFF F35() ))) -> (Element of F36()) } : F43(F38()) = F40(F43(( the_argument_of F38() )))
provided
L41: (for B62 being (QC-formula of F35()) holds (for B63 being (Element of F36()) holds (B63 = F43(B62) iff (ex B64 being (Function of ( QC-WFF F35() ) , F36()) st (B63 = ( B64 . B62 ) & (for B65 being (Element of ( QC-WFF F35() )) holds (for B66 , B67 being (Element of F36()) holds ((B65 = ( VERUM F35() ) implies ( B64 . B65 ) = F37()) & (B65 is  atomic implies ( B64 . B65 ) = F39(B65)) & ((B65 is  negative & B66 = ( B64 . ( the_argument_of B65 ) )) implies ( B64 . B65 ) = F40(B66)) & ((B65 is  conjunctive & B66 = ( B64 . ( the_left_argument_of B65 ) ) & B67 = ( B64 . ( the_right_argument_of B65 ) )) implies ( B64 . B65 ) = F41(B66 , B67)) & ((B65 is  universal & B66 = ( B64 . ( the_scope_of B65 ) )) implies ( B64 . B65 ) = F42(B65 , B66))))))))))
and
L42: F38() is  negative
proof
consider C13 being (Function of ( QC-WFF F35() ) , F36()) such that L43: F43(F38()) = ( C13 . F38() ) and L44: (for B68 being (Element of ( QC-WFF F35() )) holds (for B69 , B70 being (Element of F36()) holds ((B68 = ( VERUM F35() ) implies ( C13 . B68 ) = F37()) & (B68 is  atomic implies ( C13 . B68 ) = F39(B68)) & ((B68 is  negative & B69 = ( C13 . ( the_argument_of B68 ) )) implies ( C13 . B68 ) = F40(B69)) & ((B68 is  conjunctive & B69 = ( C13 . ( the_left_argument_of B68 ) ) & B70 = ( C13 . ( the_right_argument_of B68 ) )) implies ( C13 . B68 ) = F41(B69 , B70)) & ((B68 is  universal & B69 = ( C13 . ( the_scope_of B68 ) )) implies ( C13 . B68 ) = F42(B68 , B69))))) by L41;
L45: ( C13 . ( the_argument_of F38() ) ) = F43(( the_argument_of F38() )) by L41 , L44;
thus L46: thesis by L45 , L42 , L43 , L44;
end;
scheme QCDResult9conjunctive { F44() -> QC-alphabet , F45() -> non  empty set , F46() -> (Element of F45()) , F47((Element of ( QC-WFF F44() ))) -> (Element of F45()) , F48((Element of F45())) -> (Element of F45()) , F49((Element of F45()) , (Element of F45())) -> (Element of F45()) , F50((Element of ( QC-WFF F44() )) , (Element of F45())) -> (Element of F45()) , F51((Element of ( QC-WFF F44() ))) -> (Element of F45()) , F52() -> (QC-formula of F44()) } : (for B71 , B72 being (Element of F45()) holds ((B71 = F51(( the_left_argument_of F52() )) & B72 = F51(( the_right_argument_of F52() ))) implies F51(F52()) = F49(B71 , B72)))
provided
L47: (for B73 being (QC-formula of F44()) holds (for B74 being (Element of F45()) holds (B74 = F51(B73) iff (ex B75 being (Function of ( QC-WFF F44() ) , F45()) st (B74 = ( B75 . B73 ) & (for B76 being (Element of ( QC-WFF F44() )) holds (for B77 , B78 being (Element of F45()) holds ((B76 = ( VERUM F44() ) implies ( B75 . B76 ) = F46()) & (B76 is  atomic implies ( B75 . B76 ) = F47(B76)) & ((B76 is  negative & B77 = ( B75 . ( the_argument_of B76 ) )) implies ( B75 . B76 ) = F48(B77)) & ((B76 is  conjunctive & B77 = ( B75 . ( the_left_argument_of B76 ) ) & B78 = ( B75 . ( the_right_argument_of B76 ) )) implies ( B75 . B76 ) = F49(B77 , B78)) & ((B76 is  universal & B77 = ( B75 . ( the_scope_of B76 ) )) implies ( B75 . B76 ) = F50(B76 , B77))))))))))
and
L48: F52() is  conjunctive
proof
consider C14 being (Function of ( QC-WFF F44() ) , F45()) such that L49: F51(F52()) = ( C14 . F52() ) and L50: (for B79 being (Element of ( QC-WFF F44() )) holds (for B80 , B81 being (Element of F45()) holds ((B79 = ( VERUM F44() ) implies ( C14 . B79 ) = F46()) & (B79 is  atomic implies ( C14 . B79 ) = F47(B79)) & ((B79 is  negative & B80 = ( C14 . ( the_argument_of B79 ) )) implies ( C14 . B79 ) = F48(B80)) & ((B79 is  conjunctive & B80 = ( C14 . ( the_left_argument_of B79 ) ) & B81 = ( C14 . ( the_right_argument_of B79 ) )) implies ( C14 . B79 ) = F49(B80 , B81)) & ((B79 is  universal & B80 = ( C14 . ( the_scope_of B79 ) )) implies ( C14 . B79 ) = F50(B79 , B80))))) by L47;
let C15 , C16 being (Element of F45());
assume L51: (C15 = F51(( the_left_argument_of F52() )) & C16 = F51(( the_right_argument_of F52() )));
L52: (( C14 . ( the_left_argument_of F52() ) ) = C15 & ( C14 . ( the_right_argument_of F52() ) ) = C16) by L51 , L47 , L50;
thus L53: thesis by L52 , L48 , L49 , L50;
end;
scheme QCDResult9universal { F53() -> QC-alphabet , F54() -> non  empty set , F55() -> (Element of F54()) , F56() -> (QC-formula of F53()) , F57((Element of ( QC-WFF F53() ))) -> (Element of F54()) , F58((Element of F54())) -> (Element of F54()) , F59((Element of F54()) , (Element of F54())) -> (Element of F54()) , F60((Element of ( QC-WFF F53() )) , (Element of F54())) -> (Element of F54()) , F61((Element of ( QC-WFF F53() ))) -> (Element of F54()) } : F61(F56()) = F60(F56() , F61(( the_scope_of F56() )))
provided
L54: (for B82 being (QC-formula of F53()) holds (for B83 being (Element of F54()) holds (B83 = F61(B82) iff (ex B84 being (Function of ( QC-WFF F53() ) , F54()) st (B83 = ( B84 . B82 ) & (for B85 being (Element of ( QC-WFF F53() )) holds (for B86 , B87 being (Element of F54()) holds ((B85 = ( VERUM F53() ) implies ( B84 . B85 ) = F55()) & (B85 is  atomic implies ( B84 . B85 ) = F57(B85)) & ((B85 is  negative & B86 = ( B84 . ( the_argument_of B85 ) )) implies ( B84 . B85 ) = F58(B86)) & ((B85 is  conjunctive & B86 = ( B84 . ( the_left_argument_of B85 ) ) & B87 = ( B84 . ( the_right_argument_of B85 ) )) implies ( B84 . B85 ) = F59(B86 , B87)) & ((B85 is  universal & B86 = ( B84 . ( the_scope_of B85 ) )) implies ( B84 . B85 ) = F60(B85 , B86))))))))))
and
L55: F56() is  universal
proof
consider C17 being (Function of ( QC-WFF F53() ) , F54()) such that L56: F61(F56()) = ( C17 . F56() ) and L57: (for B88 being (Element of ( QC-WFF F53() )) holds (for B89 , B90 being (Element of F54()) holds ((B88 = ( VERUM F53() ) implies ( C17 . B88 ) = F55()) & (B88 is  atomic implies ( C17 . B88 ) = F57(B88)) & ((B88 is  negative & B89 = ( C17 . ( the_argument_of B88 ) )) implies ( C17 . B88 ) = F58(B89)) & ((B88 is  conjunctive & B89 = ( C17 . ( the_left_argument_of B88 ) ) & B90 = ( C17 . ( the_right_argument_of B88 ) )) implies ( C17 . B88 ) = F59(B89 , B90)) & ((B88 is  universal & B89 = ( C17 . ( the_scope_of B88 ) )) implies ( C17 . B88 ) = F60(B88 , B89))))) by L54;
L58: ( C17 . ( the_scope_of F56() ) ) = F61(( the_scope_of F56() )) by L54 , L57;
thus L59: thesis by L58 , L55 , L56 , L57;
end;
theorem
L60: (for R3 being QC-alphabet holds (for R9 being (QC-pred_symbol of R3) holds R9 is (QC-pred_symbol of ( the_arity_of R9 ) , R3)))
proof
let R3 being QC-alphabet;
let R9 being (QC-pred_symbol of R3);
set D1 = ( the_arity_of R9 );
set D2 = { R10 where R10 is (QC-pred_symbol of R3) : ( the_arity_of R10 ) = D1 };
L61: R9 in D2;
thus L62: thesis by L61;
end;
definition
let R3 being QC-alphabet;
let R8 being (FinSequence of ( QC-variables R3 ));
let R11 being non  empty (Subset of ( QC-variables R3 ));
func variables_in (R8 , R11) -> (Subset of R11) equals 
{ ( R8 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len R8 ) & ( R8 . R2 ) in R11) };
coherence
proof
set D3 = { ( R8 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len R8 ) & ( R8 . R2 ) in R11) };
L63: D3 c= R11
proof
let C18 being set;
assume L64: C18 in D3;
L65: (ex R2 being (Element of ( NAT )) st (( R8 . R2 ) = C18 & 1 <= R2 & R2 <= ( len R8 ) & ( R8 . R2 ) in R11)) by L64;
thus L66: thesis by L65;
end;
thus L67: thesis by L63;
end;
end;
theorem
L69: (for R3 being QC-alphabet holds (for R8 being (FinSequence of ( QC-variables R3 )) holds ( still_not-bound_in R8 ) = ( variables_in (R8 , ( bound_QC-variables R3 )) )));
L70:
now
let C19 being QC-alphabet;
deffunc H1((Element of ( QC-WFF C19 ))) = ( still_not-bound_in $1 );
deffunc H2((Element of ( QC-WFF C19 ))) = ( still_not-bound_in ( the_arguments_of $1 ) );
deffunc H3((Element of ( QC-WFF C19 )) , (Subset of ( bound_QC-variables C19 ))) = ( $2 \ { ( bound_in $1 ) } );
deffunc H4((Subset of ( bound_QC-variables C19 ))) = $1;
deffunc H5((Subset of ( bound_QC-variables C19 )) , (Subset of ( bound_QC-variables C19 ))) = ( $1 \/ $2 );
thus L71: (for B91 being (QC-formula of C19) holds (for B92 being (Subset of ( bound_QC-variables C19 )) holds (B92 = H1(B91) iff (ex B93 being (Function of ( QC-WFF C19 ) , ( bool ( bound_QC-variables C19 ) )) st (B92 = ( B93 . B91 ) & (for B94 being (Element of ( QC-WFF C19 )) holds (for B95 , B96 being (Subset of ( bound_QC-variables C19 )) holds ((B94 = ( VERUM C19 ) implies ( B93 . B94 ) = ( {} ( bound_QC-variables C19 ) )) & (B94 is  atomic implies ( B93 . B94 ) = H2(B94)) & ((B94 is  negative & B95 = ( B93 . ( the_argument_of B94 ) )) implies ( B93 . B94 ) = H4(B95)) & ((B94 is  conjunctive & B95 = ( B93 . ( the_left_argument_of B94 ) ) & B96 = ( B93 . ( the_right_argument_of B94 ) )) implies ( B93 . B94 ) = H5(B95 , B96)) & ((B94 is  universal & B95 = ( B93 . ( the_scope_of B94 ) )) implies ( B93 . B94 ) = H3(B94 , B95))))))))))
proof
let C20 being (QC-formula of C19);
let C21 being (Subset of ( bound_QC-variables C19 ));
thus L72: (C21 = ( still_not-bound_in C20 ) implies (ex B97 being (Function of ( QC-WFF C19 ) , ( bool ( bound_QC-variables C19 ) )) st (C21 = ( B97 . C20 ) & (for B98 being (Element of ( QC-WFF C19 )) holds (for B99 , B100 being (Subset of ( bound_QC-variables C19 )) holds ((B98 = ( VERUM C19 ) implies ( B97 . B98 ) = ( {} ( bound_QC-variables C19 ) )) & (B98 is  atomic implies ( B97 . B98 ) = ( still_not-bound_in ( the_arguments_of B98 ) )) & ((B98 is  negative & B99 = ( B97 . ( the_argument_of B98 ) )) implies ( B97 . B98 ) = B99) & ((B98 is  conjunctive & B99 = ( B97 . ( the_left_argument_of B98 ) ) & B100 = ( B97 . ( the_right_argument_of B98 ) )) implies ( B97 . B98 ) = ( B99 \/ B100 )) & ((B98 is  universal & B99 = ( B97 . ( the_scope_of B98 ) )) implies ( B97 . B98 ) = ( B99 \ { ( bound_in B98 ) } ))))))))
proof
assume L73: C21 = ( still_not-bound_in C20 );
consider C22 being (Function of ( QC-WFF C19 ) , ( bool ( bound_QC-variables C19 ) )) such that L74: (C21 = ( C22 . C20 ) & (for B101 being (Element of ( QC-WFF C19 )) holds (( C22 . ( VERUM C19 ) ) = ( {} ) & (B101 is  atomic implies ( C22 . B101 ) = { ( ( the_arguments_of B101 ) . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len ( the_arguments_of B101 ) ) & ( ( the_arguments_of B101 ) . R2 ) in ( bound_QC-variables C19 )) }) & (B101 is  negative implies ( C22 . B101 ) = ( C22 . ( the_argument_of B101 ) )) & (B101 is  conjunctive implies ( C22 . B101 ) = ( ( C22 . ( the_left_argument_of B101 ) ) \/ ( C22 . ( the_right_argument_of B101 ) ) )) & (B101 is  universal implies ( C22 . B101 ) = ( ( C22 . ( the_scope_of B101 ) ) \ { ( bound_in B101 ) } ))))) by L73 , QC_LANG1:def 30;
take C22;
thus L75: C21 = ( C22 . C20 ) by L74;
let C23 being (Element of ( QC-WFF C19 ));
let C24 , C25 being (Subset of ( bound_QC-variables C19 ));
thus L76: ((C23 = ( VERUM C19 ) implies ( C22 . C23 ) = ( {} ( bound_QC-variables C19 ) )) & (C23 is  atomic implies ( C22 . C23 ) = ( still_not-bound_in ( the_arguments_of C23 ) )) & ((C23 is  negative & C24 = ( C22 . ( the_argument_of C23 ) )) implies ( C22 . C23 ) = C24)) by L74;
thus L77: thesis by L74;
end;

given C26 being (Function of ( QC-WFF C19 ) , ( bool ( bound_QC-variables C19 ) )) such that
L78: C21 = ( C26 . C20 )
and
L79: (for B102 being (Element of ( QC-WFF C19 )) holds (for B103 , B104 being (Subset of ( bound_QC-variables C19 )) holds ((B102 = ( VERUM C19 ) implies ( C26 . B102 ) = ( {} ( bound_QC-variables C19 ) )) & (B102 is  atomic implies ( C26 . B102 ) = ( still_not-bound_in ( the_arguments_of B102 ) )) & ((B102 is  negative & B103 = ( C26 . ( the_argument_of B102 ) )) implies ( C26 . B102 ) = B103) & ((B102 is  conjunctive & B103 = ( C26 . ( the_left_argument_of B102 ) ) & B104 = ( C26 . ( the_right_argument_of B102 ) )) implies ( C26 . B102 ) = ( B103 \/ B104 )) & ((B102 is  universal & B103 = ( C26 . ( the_scope_of B102 ) )) implies ( C26 . B102 ) = ( B103 \ { ( bound_in B102 ) } )))));

L80:
now
let C27 being (Element of ( QC-WFF C19 ));
thus L81: ( C26 . ( VERUM C19 ) ) = ( {} ) by L79;
thus L82: (C27 is  atomic implies ( C26 . C27 ) = { ( ( the_arguments_of C27 ) . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len ( the_arguments_of C27 ) ) & ( ( the_arguments_of C27 ) . R2 ) in ( bound_QC-variables C19 )) })
proof
assume L83: C27 is  atomic;
L84: ( C26 . C27 ) = ( still_not-bound_in ( the_arguments_of C27 ) ) by L83 , L79;
thus L85: thesis by L84;
end;

thus L86: (C27 is  negative implies ( C26 . C27 ) = ( C26 . ( the_argument_of C27 ) )) by L79;
thus L87: (C27 is  conjunctive implies ( C26 . C27 ) = ( ( C26 . ( the_left_argument_of C27 ) ) \/ ( C26 . ( the_right_argument_of C27 ) ) )) by L79;
assume L88: C27 is  universal;
thus L89: ( C26 . C27 ) = ( ( C26 . ( the_scope_of C27 ) ) \ { ( bound_in C27 ) } ) by L88 , L79;
end;
thus L90: thesis by L80 , L78 , QC_LANG1:def 30;
end;

end;
theorem
L72: (for R3 being QC-alphabet holds ( still_not-bound_in ( VERUM R3 ) ) = ( {} ))
proof
let R3 being QC-alphabet;
deffunc H6((Element of ( QC-WFF R3 ))) = ( still_not-bound_in $1 );
deffunc H7((Element of ( QC-WFF R3 ))) = ( still_not-bound_in ( the_arguments_of $1 ) );
deffunc H8((Element of ( QC-WFF R3 )) , (Subset of ( bound_QC-variables R3 ))) = ( $2 \ { ( bound_in $1 ) } );
deffunc H9((Subset of ( bound_QC-variables R3 ))) = $1;
deffunc H10((Subset of ( bound_QC-variables R3 )) , (Subset of ( bound_QC-variables R3 ))) = ( $1 \/ $2 );
L73: (for B105 being (QC-formula of R3) holds (for B106 being (Subset of ( bound_QC-variables R3 )) holds (B106 = H6(B105) iff (ex B107 being (Function of ( QC-WFF R3 ) , ( bool ( bound_QC-variables R3 ) )) st (B106 = ( B107 . B105 ) & (for B108 being (Element of ( QC-WFF R3 )) holds (for B109 , B110 being (Subset of ( bound_QC-variables R3 )) holds ((B108 = ( VERUM R3 ) implies ( B107 . B108 ) = ( {} ( bound_QC-variables R3 ) )) & (B108 is  atomic implies ( B107 . B108 ) = H7(B108)) & ((B108 is  negative & B109 = ( B107 . ( the_argument_of B108 ) )) implies ( B107 . B108 ) = H9(B109)) & ((B108 is  conjunctive & B109 = ( B107 . ( the_left_argument_of B108 ) ) & B110 = ( B107 . ( the_right_argument_of B108 ) )) implies ( B107 . B108 ) = H10(B109 , B110)) & ((B108 is  universal & B109 = ( B107 . ( the_scope_of B108 ) )) implies ( B107 . B108 ) = H8(B108 , B109)))))))))) by L70;
thus L74: H6(( VERUM R3 )) = ( {} ( bound_QC-variables R3 ) ) from QCDResult9VERUM(L73)
.= ( {} );
end;
theorem
L75: (for R3 being QC-alphabet holds (for B111 being (QC-formula of R3) holds (B111 is  atomic implies ( still_not-bound_in B111 ) = ( still_not-bound_in ( the_arguments_of B111 ) ))))
proof
let R3 being QC-alphabet;
deffunc H11((Element of ( QC-WFF R3 ))) = ( still_not-bound_in $1 );
deffunc H12((Element of ( QC-WFF R3 ))) = ( still_not-bound_in ( the_arguments_of $1 ) );
deffunc H13((Element of ( QC-WFF R3 )) , (Subset of ( bound_QC-variables R3 ))) = ( $2 \ { ( bound_in $1 ) } );
deffunc H14((Subset of ( bound_QC-variables R3 ))) = $1;
deffunc H15((Subset of ( bound_QC-variables R3 )) , (Subset of ( bound_QC-variables R3 ))) = ( $1 \/ $2 );
L76: (for B112 being (QC-formula of R3) holds (for B113 being (Subset of ( bound_QC-variables R3 )) holds (B113 = H11(B112) iff (ex B114 being (Function of ( QC-WFF R3 ) , ( bool ( bound_QC-variables R3 ) )) st (B113 = ( B114 . B112 ) & (for B115 being (Element of ( QC-WFF R3 )) holds (for B116 , B117 being (Subset of ( bound_QC-variables R3 )) holds ((B115 = ( VERUM R3 ) implies ( B114 . B115 ) = ( {} ( bound_QC-variables R3 ) )) & (B115 is  atomic implies ( B114 . B115 ) = H12(B115)) & ((B115 is  negative & B116 = ( B114 . ( the_argument_of B115 ) )) implies ( B114 . B115 ) = H14(B116)) & ((B115 is  conjunctive & B116 = ( B114 . ( the_left_argument_of B115 ) ) & B117 = ( B114 . ( the_right_argument_of B115 ) )) implies ( B114 . B115 ) = H15(B116 , B117)) & ((B115 is  universal & B116 = ( B114 . ( the_scope_of B115 ) )) implies ( B114 . B115 ) = H13(B115 , B116)))))))))) by L70;
let C28 being (QC-formula of R3);
assume that
L77: C28 is  atomic;
thus L78: H11(C28) = H12(C28) from QCDResult9atomic(L76 , L77);
end;
theorem
L79: (for R2 being (Element of ( NAT )) holds (for R3 being QC-alphabet holds (for B118 being (QC-pred_symbol of R2 , R3) holds (for B119 being (QC-variable_list of R2 , R3) holds ( still_not-bound_in ( B118 ! B119 ) ) = ( still_not-bound_in B119 )))))
proof
let R2 being (Element of ( NAT ));
let R3 being QC-alphabet;
let C29 being (QC-pred_symbol of R2 , R3);
let C30 being (QC-variable_list of R2 , R3);
L80: ( C29 ! C30 ) is  atomic by QC_LANG1:def 18;
L81: ( the_arguments_of ( C29 ! C30 ) ) = C30 by L80 , QC_LANG1:def 23;
thus L82: thesis by L81 , L80 , L75;
end;
theorem
L83: (for R3 being QC-alphabet holds (for B120 being (QC-formula of R3) holds (B120 is  negative implies ( still_not-bound_in B120 ) = ( still_not-bound_in ( the_argument_of B120 ) ))))
proof
let R3 being QC-alphabet;
deffunc H16((Element of ( QC-WFF R3 ))) = ( still_not-bound_in $1 );
deffunc H17((Element of ( QC-WFF R3 ))) = ( still_not-bound_in ( the_arguments_of $1 ) );
deffunc H18((Element of ( QC-WFF R3 )) , (Subset of ( bound_QC-variables R3 ))) = ( $2 \ { ( bound_in $1 ) } );
deffunc H19((Subset of ( bound_QC-variables R3 ))) = $1;
deffunc H20((Subset of ( bound_QC-variables R3 )) , (Subset of ( bound_QC-variables R3 ))) = ( $1 \/ $2 );
L84: (for B121 being (QC-formula of R3) holds (for B122 being (Subset of ( bound_QC-variables R3 )) holds (B122 = H16(B121) iff (ex B123 being (Function of ( QC-WFF R3 ) , ( bool ( bound_QC-variables R3 ) )) st (B122 = ( B123 . B121 ) & (for B124 being (Element of ( QC-WFF R3 )) holds (for B125 , B126 being (Subset of ( bound_QC-variables R3 )) holds ((B124 = ( VERUM R3 ) implies ( B123 . B124 ) = ( {} ( bound_QC-variables R3 ) )) & (B124 is  atomic implies ( B123 . B124 ) = H17(B124)) & ((B124 is  negative & B125 = ( B123 . ( the_argument_of B124 ) )) implies ( B123 . B124 ) = H19(B125)) & ((B124 is  conjunctive & B125 = ( B123 . ( the_left_argument_of B124 ) ) & B126 = ( B123 . ( the_right_argument_of B124 ) )) implies ( B123 . B124 ) = H20(B125 , B126)) & ((B124 is  universal & B125 = ( B123 . ( the_scope_of B124 ) )) implies ( B123 . B124 ) = H18(B124 , B125)))))))))) by L70;
let C31 being (QC-formula of R3);
assume that
L85: C31 is  negative;
thus L86: H16(C31) = H19(H16(( the_argument_of C31 ))) from QCDResult9negative(L84 , L85);
end;
theorem
L87: (for R3 being QC-alphabet holds (for B127 being (QC-formula of R3) holds ( still_not-bound_in ( 'not' B127 ) ) = ( still_not-bound_in B127 )))
proof
let R3 being QC-alphabet;
let C32 being (QC-formula of R3);
L88: ( 'not' C32 ) is  negative by QC_LANG1:def 19;
L89: ( the_argument_of ( 'not' C32 ) ) = C32 by L88 , QC_LANG1:def 24;
thus L90: thesis by L89 , L88 , L83;
end;
theorem
L91: (for R3 being QC-alphabet holds ( still_not-bound_in ( FALSUM R3 ) ) = ( {} ))
proof
let R3 being QC-alphabet;
L92: ( still_not-bound_in ( FALSUM R3 ) ) = ( still_not-bound_in ( 'not' ( VERUM R3 ) ) ) by QC_LANG2:def 1
.= ( still_not-bound_in ( VERUM R3 ) ) by L87
.= ( {} ) by L72;
thus L93: thesis by L92;
end;
theorem
L94: (for R3 being QC-alphabet holds (for B128 being (QC-formula of R3) holds (B128 is  conjunctive implies ( still_not-bound_in B128 ) = ( ( still_not-bound_in ( the_left_argument_of B128 ) ) \/ ( still_not-bound_in ( the_right_argument_of B128 ) ) ))))
proof
let R3 being QC-alphabet;
deffunc H21((Element of ( QC-WFF R3 ))) = ( still_not-bound_in $1 );
deffunc H22((Element of ( QC-WFF R3 ))) = ( still_not-bound_in ( the_arguments_of $1 ) );
deffunc H23((Element of ( QC-WFF R3 )) , (Subset of ( bound_QC-variables R3 ))) = ( $2 \ { ( bound_in $1 ) } );
deffunc H24((Subset of ( bound_QC-variables R3 ))) = $1;
deffunc H25((Subset of ( bound_QC-variables R3 )) , (Subset of ( bound_QC-variables R3 ))) = ( $1 \/ $2 );
L95: (for B129 being (QC-formula of R3) holds (for B130 being (Subset of ( bound_QC-variables R3 )) holds (B130 = H21(B129) iff (ex B131 being (Function of ( QC-WFF R3 ) , ( bool ( bound_QC-variables R3 ) )) st (B130 = ( B131 . B129 ) & (for B132 being (Element of ( QC-WFF R3 )) holds (for B133 , B134 being (Subset of ( bound_QC-variables R3 )) holds ((B132 = ( VERUM R3 ) implies ( B131 . B132 ) = ( {} ( bound_QC-variables R3 ) )) & (B132 is  atomic implies ( B131 . B132 ) = H22(B132)) & ((B132 is  negative & B133 = ( B131 . ( the_argument_of B132 ) )) implies ( B131 . B132 ) = H24(B133)) & ((B132 is  conjunctive & B133 = ( B131 . ( the_left_argument_of B132 ) ) & B134 = ( B131 . ( the_right_argument_of B132 ) )) implies ( B131 . B132 ) = H25(B133 , B134)) & ((B132 is  universal & B133 = ( B131 . ( the_scope_of B132 ) )) implies ( B131 . B132 ) = H23(B132 , B133)))))))))) by L70;
let C33 being (QC-formula of R3);
assume that
L96: C33 is  conjunctive;
L97: (for B135 , B136 being (Subset of ( bound_QC-variables R3 )) holds ((B135 = H21(( the_left_argument_of C33 )) & B136 = H21(( the_right_argument_of C33 ))) implies H21(C33) = H25(B135 , B136))) from QCDResult9conjunctive(L95 , L96);
thus L98: thesis by L97;
end;
theorem
L99: (for R3 being QC-alphabet holds (for B137 , B138 being (QC-formula of R3) holds ( still_not-bound_in ( B137 '&' B138 ) ) = ( ( still_not-bound_in B137 ) \/ ( still_not-bound_in B138 ) )))
proof
let R3 being QC-alphabet;
let C34 , C35 being (QC-formula of R3);
set D4 = ( C34 '&' C35 );
L100: D4 is  conjunctive by QC_LANG1:def 20;
L101: (( the_left_argument_of D4 ) = C34 & ( the_right_argument_of D4 ) = C35) by L100 , QC_LANG1:def 25 , QC_LANG1:def 26;
thus L102: thesis by L101 , L100 , L94;
end;
theorem
L103: (for R3 being QC-alphabet holds (for B139 being (QC-formula of R3) holds (B139 is  universal implies ( still_not-bound_in B139 ) = ( ( still_not-bound_in ( the_scope_of B139 ) ) \ { ( bound_in B139 ) } ))))
proof
let R3 being QC-alphabet;
deffunc H26((Element of ( QC-WFF R3 ))) = ( still_not-bound_in $1 );
deffunc H27((Element of ( QC-WFF R3 ))) = ( still_not-bound_in ( the_arguments_of $1 ) );
deffunc H28((Element of ( QC-WFF R3 )) , (Subset of ( bound_QC-variables R3 ))) = ( $2 \ { ( bound_in $1 ) } );
deffunc H29((Subset of ( bound_QC-variables R3 ))) = $1;
deffunc H30((Subset of ( bound_QC-variables R3 )) , (Subset of ( bound_QC-variables R3 ))) = ( $1 \/ $2 );
L104: (for B140 being (QC-formula of R3) holds (for B141 being (Subset of ( bound_QC-variables R3 )) holds (B141 = H26(B140) iff (ex B142 being (Function of ( QC-WFF R3 ) , ( bool ( bound_QC-variables R3 ) )) st (B141 = ( B142 . B140 ) & (for B143 being (Element of ( QC-WFF R3 )) holds (for B144 , B145 being (Subset of ( bound_QC-variables R3 )) holds ((B143 = ( VERUM R3 ) implies ( B142 . B143 ) = ( {} ( bound_QC-variables R3 ) )) & (B143 is  atomic implies ( B142 . B143 ) = H27(B143)) & ((B143 is  negative & B144 = ( B142 . ( the_argument_of B143 ) )) implies ( B142 . B143 ) = H29(B144)) & ((B143 is  conjunctive & B144 = ( B142 . ( the_left_argument_of B143 ) ) & B145 = ( B142 . ( the_right_argument_of B143 ) )) implies ( B142 . B143 ) = H30(B144 , B145)) & ((B143 is  universal & B144 = ( B142 . ( the_scope_of B143 ) )) implies ( B142 . B143 ) = H28(B143 , B144)))))))))) by L70;
let C36 being (QC-formula of R3);
assume that
L105: C36 is  universal;
thus L106: H26(C36) = H28(C36 , H26(( the_scope_of C36 ))) from QCDResult9universal(L104 , L105);
end;
theorem
L107: (for R3 being QC-alphabet holds (for R4 being (bound_QC-variable of R3) holds (for B146 being (QC-formula of R3) holds ( still_not-bound_in ( All (R4 , B146) ) ) = ( ( still_not-bound_in B146 ) \ { R4 } ))))
proof
let R3 being QC-alphabet;
let R4 being (bound_QC-variable of R3);
let C37 being (QC-formula of R3);
set D5 = ( All (R4 , C37) );
L108: D5 is  universal by QC_LANG1:def 21;
L109: (( the_scope_of D5 ) = C37 & ( bound_in D5 ) = R4) by L108 , QC_LANG1:def 27 , QC_LANG1:def 28;
thus L110: thesis by L109 , L108 , L103;
end;
theorem
L111: (for R3 being QC-alphabet holds (for B147 being (QC-formula of R3) holds (B147 is  disjunctive implies ( still_not-bound_in B147 ) = ( ( still_not-bound_in ( the_left_disjunct_of B147 ) ) \/ ( still_not-bound_in ( the_right_disjunct_of B147 ) ) ))))
proof
let R3 being QC-alphabet;
let C38 being (QC-formula of R3);
set D6 = ( the_left_disjunct_of C38 );
set D7 = ( the_right_disjunct_of C38 );
assume L112: C38 is  disjunctive;
L113: C38 = ( ( the_left_disjunct_of C38 ) 'or' ( the_right_disjunct_of C38 ) ) by L112 , QC_LANG2:37;
L114: C38 = ( 'not' ( ( 'not' D6 ) '&' ( 'not' D7 ) ) ) by L113 , QC_LANG2:def 3;
L115: ( still_not-bound_in C38 ) = ( still_not-bound_in ( ( 'not' D6 ) '&' ( 'not' D7 ) ) ) by L114 , L87
.= ( ( still_not-bound_in ( 'not' D6 ) ) \/ ( still_not-bound_in ( 'not' D7 ) ) ) by L99
.= ( ( still_not-bound_in D6 ) \/ ( still_not-bound_in ( 'not' D7 ) ) ) by L87
.= ( ( still_not-bound_in D6 ) \/ ( still_not-bound_in D7 ) ) by L87;
thus L116: thesis by L115;
end;
theorem
L117: (for R3 being QC-alphabet holds (for B148 , B149 being (QC-formula of R3) holds ( still_not-bound_in ( B148 'or' B149 ) ) = ( ( still_not-bound_in B148 ) \/ ( still_not-bound_in B149 ) )))
proof
let R3 being QC-alphabet;
let C39 , C40 being (QC-formula of R3);
L118: ( the_right_disjunct_of ( C39 'or' C40 ) ) = C40 by QC_LANG2:29;
L119: (( C39 'or' C40 ) is  disjunctive & ( the_left_disjunct_of ( C39 'or' C40 ) ) = C39) by QC_LANG2:29 , QC_LANG2:def 10;
thus L120: thesis by L119 , L118 , L111;
end;
theorem
L121: (for R3 being QC-alphabet holds (for B150 being (QC-formula of R3) holds (B150 is  conditional implies ( still_not-bound_in B150 ) = ( ( still_not-bound_in ( the_antecedent_of B150 ) ) \/ ( still_not-bound_in ( the_consequent_of B150 ) ) ))))
proof
let R3 being QC-alphabet;
let C41 being (QC-formula of R3);
set D8 = ( the_antecedent_of C41 );
set D9 = ( the_consequent_of C41 );
assume L122: C41 is  conditional;
L123: C41 = ( ( the_antecedent_of C41 ) => ( the_consequent_of C41 ) ) by L122 , QC_LANG2:38;
L124: C41 = ( 'not' ( D8 '&' ( 'not' D9 ) ) ) by L123 , QC_LANG2:def 2;
L125: ( still_not-bound_in C41 ) = ( still_not-bound_in ( D8 '&' ( 'not' D9 ) ) ) by L124 , L87
.= ( ( still_not-bound_in D8 ) \/ ( still_not-bound_in ( 'not' D9 ) ) ) by L99
.= ( ( still_not-bound_in D8 ) \/ ( still_not-bound_in D9 ) ) by L87;
thus L126: thesis by L125;
end;
theorem
L127: (for R3 being QC-alphabet holds (for B151 , B152 being (QC-formula of R3) holds ( still_not-bound_in ( B151 => B152 ) ) = ( ( still_not-bound_in B151 ) \/ ( still_not-bound_in B152 ) )))
proof
let R3 being QC-alphabet;
let C42 , C43 being (QC-formula of R3);
L128: ( the_consequent_of ( C42 => C43 ) ) = C43 by QC_LANG2:30;
L129: (( C42 => C43 ) is  conditional & ( the_antecedent_of ( C42 => C43 ) ) = C42) by QC_LANG2:30 , QC_LANG2:def 11;
thus L130: thesis by L129 , L128 , L121;
end;
theorem
L131: (for R3 being QC-alphabet holds (for B153 being (QC-formula of R3) holds (B153 is  biconditional implies ( still_not-bound_in B153 ) = ( ( still_not-bound_in ( the_left_side_of B153 ) ) \/ ( still_not-bound_in ( the_right_side_of B153 ) ) ))))
proof
let R3 being QC-alphabet;
let C44 being (QC-formula of R3);
set D10 = ( the_left_side_of C44 );
set D11 = ( the_right_side_of C44 );
assume L132: C44 is  biconditional;
L133: C44 = ( ( the_left_side_of C44 ) <=> ( the_right_side_of C44 ) ) by L132 , QC_LANG2:39;
L134: C44 = ( ( D10 => D11 ) '&' ( D11 => D10 ) ) by L133 , QC_LANG2:def 4;
L135: ( still_not-bound_in C44 ) = ( ( still_not-bound_in ( D10 => D11 ) ) \/ ( still_not-bound_in ( D11 => D10 ) ) ) by L134 , L99
.= ( ( ( still_not-bound_in D10 ) \/ ( still_not-bound_in D11 ) ) \/ ( still_not-bound_in ( D11 => D10 ) ) ) by L127
.= ( ( ( still_not-bound_in D10 ) \/ ( still_not-bound_in D11 ) ) \/ ( ( still_not-bound_in D10 ) \/ ( still_not-bound_in D11 ) ) ) by L127
.= ( ( still_not-bound_in D10 ) \/ ( still_not-bound_in D11 ) );
thus L136: thesis by L135;
end;
theorem
L137: (for R3 being QC-alphabet holds (for B154 , B155 being (QC-formula of R3) holds ( still_not-bound_in ( B154 <=> B155 ) ) = ( ( still_not-bound_in B154 ) \/ ( still_not-bound_in B155 ) )))
proof
let R3 being QC-alphabet;
let C45 , C46 being (QC-formula of R3);
L138: ( the_right_side_of ( C45 <=> C46 ) ) = C46 by QC_LANG2:31;
L139: (( C45 <=> C46 ) is  biconditional & ( the_left_side_of ( C45 <=> C46 ) ) = C45) by QC_LANG2:31 , QC_LANG2:def 12;
thus L140: thesis by L139 , L138 , L131;
end;
theorem
L141: (for R3 being QC-alphabet holds (for R4 being (bound_QC-variable of R3) holds (for B156 being (QC-formula of R3) holds ( still_not-bound_in ( Ex (R4 , B156) ) ) = ( ( still_not-bound_in B156 ) \ { R4 } ))))
proof
let R3 being QC-alphabet;
let R4 being (bound_QC-variable of R3);
let C47 being (QC-formula of R3);
L142: ( Ex (R4 , C47) ) = ( 'not' ( All (R4 , ( 'not' C47 )) ) ) by QC_LANG2:def 5;
thus L143: ( still_not-bound_in ( Ex (R4 , C47) ) ) = ( still_not-bound_in ( All (R4 , ( 'not' C47 )) ) ) by L142 , L87
.= ( ( still_not-bound_in ( 'not' C47 ) ) \ { R4 } ) by L107
.= ( ( still_not-bound_in C47 ) \ { R4 } ) by L87;
end;
theorem
L144: (for R3 being QC-alphabet holds (( VERUM R3 ) is  closed & ( FALSUM R3 ) is  closed))
proof
let R3 being QC-alphabet;
L145: (( still_not-bound_in ( VERUM R3 ) ) = ( {} ) & ( still_not-bound_in ( FALSUM R3 ) ) = ( {} )) by L72 , L91;
thus L146: (( VERUM R3 ) is  closed & ( FALSUM R3 ) is  closed) by L145 , QC_LANG1:def 31;
end;
theorem
L147: (for R3 being QC-alphabet holds (for B157 being (QC-formula of R3) holds (B157 is  closed iff ( 'not' B157 ) is  closed)))
proof
let R3 being QC-alphabet;
let C48 being (QC-formula of R3);
thus L148: (C48 is  closed implies ( 'not' C48 ) is  closed)
proof
assume L149: ( still_not-bound_in C48 ) = ( {} );
thus L150: ( still_not-bound_in ( 'not' C48 ) ) = ( {} ) by L149 , L87;
end;

assume L151: ( still_not-bound_in ( 'not' C48 ) ) = ( {} );
thus L152: ( still_not-bound_in C48 ) = ( {} ) by L151 , L87;
end;
theorem
L153: (for R3 being QC-alphabet holds (for B158 , B159 being (QC-formula of R3) holds ((B158 is  closed & B159 is  closed) iff ( B158 '&' B159 ) is  closed)))
proof
let R3 being QC-alphabet;
let C49 , C50 being (QC-formula of R3);
thus L154: ((C49 is  closed & C50 is  closed) implies ( C49 '&' C50 ) is  closed)
proof
assume L155: (( still_not-bound_in C49 ) = ( {} ) & ( still_not-bound_in C50 ) = ( {} ));
L156: ( ( still_not-bound_in C49 ) \/ ( still_not-bound_in C50 ) ) = ( {} ) by L155;
thus L157: ( still_not-bound_in ( C49 '&' C50 ) ) = ( {} ) by L156 , L99;
end;

assume L158: ( still_not-bound_in ( C49 '&' C50 ) ) = ( {} );
L159: ( still_not-bound_in ( C49 '&' C50 ) ) = ( ( still_not-bound_in C49 ) \/ ( still_not-bound_in C50 ) ) by L99;
thus L160: (( still_not-bound_in C49 ) = ( {} ) & ( still_not-bound_in C50 ) = ( {} )) by L159 , L158 , XBOOLE_1:15;
end;
theorem
L161: (for R3 being QC-alphabet holds (for R4 being (bound_QC-variable of R3) holds (for B160 being (QC-formula of R3) holds (( All (R4 , B160) ) is  closed iff ( still_not-bound_in B160 ) c= { R4 }))))
proof
let R3 being QC-alphabet;
let R4 being (bound_QC-variable of R3);
let C51 being (QC-formula of R3);
thus L162: (( All (R4 , C51) ) is  closed implies ( still_not-bound_in C51 ) c= { R4 })
proof
assume L163: ( still_not-bound_in ( All (R4 , C51) ) ) = ( {} );
L164: ( {} ) = ( ( still_not-bound_in C51 ) \ { R4 } ) by L163 , L107;
thus L165: thesis by L164 , XBOOLE_1:37;
end;

assume L166: ( still_not-bound_in C51 ) c= { R4 };
L167: ( {} ) = ( ( still_not-bound_in C51 ) \ { R4 } ) by L166 , XBOOLE_1:37;
thus L168: ( still_not-bound_in ( All (R4 , C51) ) ) = ( {} ) by L167 , L107;
end;
theorem
L169: (for R3 being QC-alphabet holds (for R4 being (bound_QC-variable of R3) holds (for B161 being (QC-formula of R3) holds (B161 is  closed implies ( All (R4 , B161) ) is  closed))))
proof
let R3 being QC-alphabet;
let R4 being (bound_QC-variable of R3);
let C52 being (QC-formula of R3);
assume L170: ( still_not-bound_in C52 ) = ( {} );
L171: ( still_not-bound_in C52 ) c= { R4 } by L170 , XBOOLE_1:2;
thus L172: thesis by L171 , L161;
end;
theorem
L173: (for R3 being QC-alphabet holds (for B162 , B163 being (QC-formula of R3) holds ((B162 is  closed & B163 is  closed) iff ( B162 'or' B163 ) is  closed)))
proof
let R3 being QC-alphabet;
let C53 , C54 being (QC-formula of R3);
L174: ( C53 'or' C54 ) = ( 'not' ( ( 'not' C53 ) '&' ( 'not' C54 ) ) ) by QC_LANG2:def 3;
L175: (( ( 'not' C53 ) '&' ( 'not' C54 ) ) is  closed iff (( 'not' C53 ) is  closed & ( 'not' C54 ) is  closed)) by L153;
thus L176: thesis by L175 , L174 , L147;
end;
theorem
L177: (for R3 being QC-alphabet holds (for B164 , B165 being (QC-formula of R3) holds ((B164 is  closed & B165 is  closed) iff ( B164 => B165 ) is  closed)))
proof
let R3 being QC-alphabet;
let C55 , C56 being (QC-formula of R3);
L178: ( C55 => C56 ) = ( 'not' ( C55 '&' ( 'not' C56 ) ) ) by QC_LANG2:def 2;
L179: (( C55 '&' ( 'not' C56 ) ) is  closed iff (C55 is  closed & ( 'not' C56 ) is  closed)) by L153;
thus L180: thesis by L179 , L178 , L147;
end;
theorem
L181: (for R3 being QC-alphabet holds (for B166 , B167 being (QC-formula of R3) holds ((B166 is  closed & B167 is  closed) iff ( B166 <=> B167 ) is  closed)))
proof
let R3 being QC-alphabet;
let C57 , C58 being (QC-formula of R3);
L182: ( C57 <=> C58 ) = ( ( C57 => C58 ) '&' ( C58 => C57 ) ) by QC_LANG2:def 4;
L183: (( C57 <=> C58 ) is  closed iff (( C57 => C58 ) is  closed & ( C58 => C57 ) is  closed)) by L182 , L153;
thus L184: thesis by L183 , L177;
end;
theorem
L185: (for R3 being QC-alphabet holds (for R4 being (bound_QC-variable of R3) holds (for B168 being (QC-formula of R3) holds (( Ex (R4 , B168) ) is  closed iff ( still_not-bound_in B168 ) c= { R4 }))))
proof
let R3 being QC-alphabet;
let R4 being (bound_QC-variable of R3);
let C59 being (QC-formula of R3);
thus L186: (( Ex (R4 , C59) ) is  closed implies ( still_not-bound_in C59 ) c= { R4 })
proof
assume L187: ( still_not-bound_in ( Ex (R4 , C59) ) ) = ( {} );
L188: ( {} ) = ( ( still_not-bound_in C59 ) \ { R4 } ) by L187 , L141;
thus L189: thesis by L188 , XBOOLE_1:37;
end;

assume L190: ( still_not-bound_in C59 ) c= { R4 };
L191: ( {} ) = ( ( still_not-bound_in C59 ) \ { R4 } ) by L190 , XBOOLE_1:37;
thus L192: ( still_not-bound_in ( Ex (R4 , C59) ) ) = ( {} ) by L191 , L141;
end;
theorem
L193: (for R3 being QC-alphabet holds (for R4 being (bound_QC-variable of R3) holds (for B169 being (QC-formula of R3) holds (B169 is  closed implies ( Ex (R4 , B169) ) is  closed))))
proof
let R3 being QC-alphabet;
let R4 being (bound_QC-variable of R3);
let C60 being (QC-formula of R3);
assume L194: ( still_not-bound_in C60 ) = ( {} );
L195: ( still_not-bound_in C60 ) c= { R4 } by L194 , XBOOLE_1:2;
thus L196: thesis by L195 , L185;
end;
definition
let R3 being QC-alphabet;
let R12 being (QC-symbol of R3);
func x. R12 -> (bound_QC-variable of R3) equals 
[ 4 , R12 ];
coherence
proof
L197: 4 in { 4 } by TARSKI:def 1;
thus L198: thesis by L197 , ZFMISC_1:def 2;
end;
end;
theorem
L200: (for R3 being QC-alphabet holds (for R4 being (bound_QC-variable of R3) holds (ex R13 being (QC-symbol of R3) st ( x. R13 ) = R4)))
proof
let R3 being QC-alphabet;
let R4 being (bound_QC-variable of R3);
consider C61 , C62 being set such that L201: C61 in { 4 } and L202: C62 in ( QC-symbols R3 ) and L203: [ C61 , C62 ] = R4 by ZFMISC_1:def 2;
reconsider D12 = C62 as (QC-symbol of R3) by L202;
take D12;
thus L204: thesis by L201 , L203 , TARSKI:def 1;
end;
definition
let R3 being QC-alphabet;
let R2 being (Element of ( NAT ));
func R3 a. R2 -> (free_QC-variable of R3) equals 
[ 6 , R2 ];
coherence
proof
L205: 6 in { 6 } by TARSKI:def 1;
thus L206: thesis by L205 , ZFMISC_1:def 2;
end;
end;
theorem
L208: (for R3 being QC-alphabet holds (for R5 being (free_QC-variable of R3) holds (ex R1 being (Element of ( NAT )) st ( R3 a. R1 ) = R5)))
proof
let R3 being QC-alphabet;
let R5 being (free_QC-variable of R3);
consider C63 , C64 being set such that L209: C63 in { 6 } and L210: C64 in ( NAT ) and L211: [ C63 , C64 ] = R5 by ZFMISC_1:def 2;
reconsider D13 = C64 as (Element of ( NAT )) by L210;
take D13;
thus L212: thesis by L209 , L211 , TARSKI:def 1;
end;
theorem
L213: (for R3 being QC-alphabet holds (for B170 being (Element of ( fixed_QC-variables R3 )) holds (for B171 being (Element of ( free_QC-variables R3 )) holds B170 <> B171)))
proof
let R3 being QC-alphabet;
let C65 being (Element of ( fixed_QC-variables R3 ));
let C66 being (Element of ( free_QC-variables R3 ));
consider C67 , C68 being set such that L214: C67 in { 6 } and L215: C68 in ( NAT ) and L216: C66 = [ C67 , C68 ] by ZFMISC_1:def 2;
consider C69 , C70 being set such that L217: C69 in { 5 } and L218: C70 in ( QC-symbols R3 ) and L219: C65 = [ C69 , C70 ] by ZFMISC_1:def 2;
L220: C69 = 5 by L217 , TARSKI:def 1;
L221: C67 = 6 by L214 , TARSKI:def 1;
thus L222: thesis by L221 , L216 , L219 , L220 , XTUPLE_0:1;
end;
theorem
L223: (for R3 being QC-alphabet holds (for B172 being (Element of ( fixed_QC-variables R3 )) holds (for B173 being (Element of ( bound_QC-variables R3 )) holds B172 <> B173)))
proof
let R3 being QC-alphabet;
let C71 being (Element of ( fixed_QC-variables R3 ));
let C72 being (Element of ( bound_QC-variables R3 ));
consider C73 , C74 being set such that L224: C73 in { 4 } and L225: C74 in ( QC-symbols R3 ) and L226: C72 = [ C73 , C74 ] by ZFMISC_1:def 2;
consider C75 , C76 being set such that L227: C75 in { 5 } and L228: C76 in ( QC-symbols R3 ) and L229: C71 = [ C75 , C76 ] by ZFMISC_1:def 2;
L230: C75 = 5 by L227 , TARSKI:def 1;
L231: C73 = 4 by L224 , TARSKI:def 1;
thus L232: thesis by L231 , L226 , L229 , L230 , XTUPLE_0:1;
end;
theorem
L233: (for R3 being QC-alphabet holds (for B174 being (Element of ( free_QC-variables R3 )) holds (for B175 being (Element of ( bound_QC-variables R3 )) holds B174 <> B175)))
proof
let R3 being QC-alphabet;
let C77 being (Element of ( free_QC-variables R3 ));
let C78 being (Element of ( bound_QC-variables R3 ));
consider C79 , C80 being set such that L234: C79 in { 4 } and L235: C80 in ( QC-symbols R3 ) and L236: C78 = [ C79 , C80 ] by ZFMISC_1:def 2;
consider C81 , C82 being set such that L237: C81 in { 6 } and L238: C82 in ( NAT ) and L239: C77 = [ C81 , C82 ] by ZFMISC_1:def 2;
L240: C81 = 6 by L237 , TARSKI:def 1;
L241: C79 = 4 by L234 , TARSKI:def 1;
thus L242: thesis by L241 , L236 , L239 , L240 , XTUPLE_0:1;
end;
definition
let R3 being QC-alphabet;
let R11 being non  empty (Subset of ( QC-variables R3 ));
let R6 being (Element of ( QC-WFF R3 ));
func Vars (R6 , R11) -> (Subset of R11) means 
:L243: (ex B176 being (Function of ( QC-WFF R3 ) , ( bool R11 )) st (it = ( B176 . R6 ) & (for B177 being (Element of ( QC-WFF R3 )) holds (for B178 , B179 being (Subset of R11) holds ((B177 = ( VERUM R3 ) implies ( B176 . B177 ) = ( {} R11 )) & (B177 is  atomic implies ( B176 . B177 ) = ( variables_in (( the_arguments_of B177 ) , R11) )) & ((B177 is  negative & B178 = ( B176 . ( the_argument_of B177 ) )) implies ( B176 . B177 ) = B178) & ((B177 is  conjunctive & B178 = ( B176 . ( the_left_argument_of B177 ) ) & B179 = ( B176 . ( the_right_argument_of B177 ) )) implies ( B176 . B177 ) = ( B178 \/ B179 )) & ((B177 is  universal & B178 = ( B176 . ( the_scope_of B177 ) )) implies ( B176 . B177 ) = B178))))));
correctness
proof
deffunc H31((Element of ( QC-WFF R3 )) , (Subset of R11)) = $2;
deffunc H32((Subset of R11) , (Subset of R11)) = ( $1 \/ $2 );
deffunc H33((Subset of R11)) = $1;
deffunc H34((Element of ( QC-WFF R3 ))) = ( variables_in (( the_arguments_of $1 ) , R11) );
thus L244: ((ex B180 being (Subset of R11) st (ex B181 being (Function of ( QC-WFF R3 ) , ( bool R11 )) st (B180 = ( B181 . R6 ) & (for B182 being (Element of ( QC-WFF R3 )) holds (for B183 , B184 being (Subset of R11) holds ((B182 = ( VERUM R3 ) implies ( B181 . B182 ) = ( {} R11 )) & (B182 is  atomic implies ( B181 . B182 ) = H34(B182)) & ((B182 is  negative & B183 = ( B181 . ( the_argument_of B182 ) )) implies ( B181 . B182 ) = H33(B183)) & ((B182 is  conjunctive & B183 = ( B181 . ( the_left_argument_of B182 ) ) & B184 = ( B181 . ( the_right_argument_of B182 ) )) implies ( B181 . B182 ) = H32(B183 , B184)) & ((B182 is  universal & B183 = ( B181 . ( the_scope_of B182 ) )) implies ( B181 . B182 ) = H31(B182 , B183)))))))) & (for B185 , B186 being (Subset of R11) holds (((ex B187 being (Function of ( QC-WFF R3 ) , ( bool R11 )) st (B185 = ( B187 . R6 ) & (for B188 being (Element of ( QC-WFF R3 )) holds (for B189 , B190 being (Subset of R11) holds ((B188 = ( VERUM R3 ) implies ( B187 . B188 ) = ( {} R11 )) & (B188 is  atomic implies ( B187 . B188 ) = H34(B188)) & ((B188 is  negative & B189 = ( B187 . ( the_argument_of B188 ) )) implies ( B187 . B188 ) = H33(B189)) & ((B188 is  conjunctive & B189 = ( B187 . ( the_left_argument_of B188 ) ) & B190 = ( B187 . ( the_right_argument_of B188 ) )) implies ( B187 . B188 ) = H32(B189 , B190)) & ((B188 is  universal & B189 = ( B187 . ( the_scope_of B188 ) )) implies ( B187 . B188 ) = H31(B188 , B189))))))) & (ex B191 being (Function of ( QC-WFF R3 ) , ( bool R11 )) st (B186 = ( B191 . R6 ) & (for B192 being (Element of ( QC-WFF R3 )) holds (for B193 , B194 being (Subset of R11) holds ((B192 = ( VERUM R3 ) implies ( B191 . B192 ) = ( {} R11 )) & (B192 is  atomic implies ( B191 . B192 ) = H34(B192)) & ((B192 is  negative & B193 = ( B191 . ( the_argument_of B192 ) )) implies ( B191 . B192 ) = H33(B193)) & ((B192 is  conjunctive & B193 = ( B191 . ( the_left_argument_of B192 ) ) & B194 = ( B191 . ( the_right_argument_of B192 ) )) implies ( B191 . B192 ) = H32(B193 , B194)) & ((B192 is  universal & B193 = ( B191 . ( the_scope_of B192 ) )) implies ( B191 . B192 ) = H31(B192 , B193)))))))) implies B185 = B186))) from QCDefD;
end;
end;
L246:
now
let R3 being QC-alphabet;
let R11 being non  empty (Subset of ( QC-variables R3 ));
deffunc H35((Element of ( QC-WFF R3 ))) = ( Vars ($1 , R11) );
deffunc H36((Element of ( QC-WFF R3 ))) = ( variables_in (( the_arguments_of $1 ) , R11) );
deffunc H37((Subset of R11)) = $1;
deffunc H38((Subset of R11) , (Subset of R11)) = ( $1 \/ $2 );
deffunc H39((Element of ( QC-WFF R3 )) , (Subset of R11)) = $2;
L247: (for R6 being (Element of ( QC-WFF R3 )) holds (for B195 being (Subset of R11) holds (B195 = H35(R6) iff (ex B196 being (Function of ( QC-WFF R3 ) , ( bool R11 )) st (B195 = ( B196 . R6 ) & (for B197 being (Element of ( QC-WFF R3 )) holds (for B198 , B199 being (Subset of R11) holds ((B197 = ( VERUM R3 ) implies ( B196 . B197 ) = ( {} R11 )) & (B197 is  atomic implies ( B196 . B197 ) = H36(B197)) & ((B197 is  negative & B198 = ( B196 . ( the_argument_of B197 ) )) implies ( B196 . B197 ) = H37(B198)) & ((B197 is  conjunctive & B198 = ( B196 . ( the_left_argument_of B197 ) ) & B199 = ( B196 . ( the_right_argument_of B197 ) )) implies ( B196 . B197 ) = H38(B198 , B199)) & ((B197 is  universal & B198 = ( B196 . ( the_scope_of B197 ) )) implies ( B196 . B197 ) = H39(B197 , B198)))))))))) by L243;
thus L248: H35(( VERUM R3 )) = ( {} R11 ) from QCDResult9VERUM(L247)
.= ( {} );
thus L249: (for R6 being (Element of ( QC-WFF R3 )) holds (R6 is  atomic implies ( Vars (R6 , R11) ) = ( variables_in (( the_arguments_of R6 ) , R11) )))
proof
let R6 being (Element of ( QC-WFF R3 ));
assume L250: R6 is  atomic;
thus L251: H35(R6) = H36(R6) from QCDResult9atomic(L247 , L250);
end;

thus L252: (for R6 being (Element of ( QC-WFF R3 )) holds (R6 is  negative implies ( Vars (R6 , R11) ) = ( Vars (( the_argument_of R6 ) , R11) )))
proof
let R6 being (Element of ( QC-WFF R3 ));
assume L253: R6 is  negative;
thus L254: H35(R6) = H37(H35(( the_argument_of R6 ))) from QCDResult9negative(L247 , L253);
end;

thus L255: (for R6 being (Element of ( QC-WFF R3 )) holds (R6 is  conjunctive implies ( Vars (R6 , R11) ) = ( ( Vars (( the_left_argument_of R6 ) , R11) ) \/ ( Vars (( the_right_argument_of R6 ) , R11) ) )))
proof
let R6 being (Element of ( QC-WFF R3 ));
assume L256: R6 is  conjunctive;
L257: (for B200 , B201 being (Subset of R11) holds ((B200 = H35(( the_left_argument_of R6 )) & B201 = H35(( the_right_argument_of R6 ))) implies H35(R6) = H38(B200 , B201))) from QCDResult9conjunctive(L247 , L256);
thus L258: thesis by L257;
end;

thus L259: (for R6 being (Element of ( QC-WFF R3 )) holds (R6 is  universal implies ( Vars (R6 , R11) ) = ( Vars (( the_scope_of R6 ) , R11) )))
proof
let R6 being (Element of ( QC-WFF R3 ));
assume L260: R6 is  universal;
thus L261: H35(R6) = H39(R6 , H35(( the_scope_of R6 ))) from QCDResult9universal(L247 , L260);
end;

end;
theorem
L260: (for R3 being QC-alphabet holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds ( Vars (( VERUM R3 ) , R11) ) = ( {} ))) by L246;
theorem
L261: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds (R6 is  atomic implies (( Vars (R6 , R11) ) = ( variables_in (( the_arguments_of R6 ) , R11) ) & ( Vars (R6 , R11) ) = { ( ( the_arguments_of R6 ) . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len ( the_arguments_of R6 ) ) & ( ( the_arguments_of R6 ) . R2 ) in R11) })))))
proof
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
let R11 being non  empty (Subset of ( QC-variables R3 ));
assume L262: R6 is  atomic;
thus L263: ( Vars (R6 , R11) ) = ( variables_in (( the_arguments_of R6 ) , R11) ) by L262 , L246;
thus L264: thesis by L263;
end;
theorem
L265: (for R2 being (Element of ( NAT )) holds (for R3 being QC-alphabet holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds (for B202 being (QC-pred_symbol of R2 , R3) holds (for B203 being (QC-variable_list of R2 , R3) holds (( Vars (( B202 ! B203 ) , R11) ) = ( variables_in (B203 , R11) ) & ( Vars (( B202 ! B203 ) , R11) ) = { ( B203 . R1 ) where R1 is (Element of ( NAT )) : (1 <= R1 & R1 <= ( len B203 ) & ( B203 . R1 ) in R11) }))))))
proof
let R2 being (Element of ( NAT ));
let R3 being QC-alphabet;
let R11 being non  empty (Subset of ( QC-variables R3 ));
let C83 being (QC-pred_symbol of R2 , R3);
let C84 being (QC-variable_list of R2 , R3);
L266: ( C83 ! C84 ) is  atomic by QC_LANG1:def 18;
L267: ( the_arguments_of ( C83 ! C84 ) ) = C84 by L266 , QC_LANG1:def 23;
thus L268: thesis by L267 , L266 , L261;
end;
theorem
L269: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds (R6 is  negative implies ( Vars (R6 , R11) ) = ( Vars (( the_argument_of R6 ) , R11) ))))) by L246;
theorem
L270: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds ( Vars (( 'not' R6 ) , R11) ) = ( Vars (R6 , R11) ))))
proof
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
let R11 being non  empty (Subset of ( QC-variables R3 ));
set D14 = ( 'not' R6 );
L271: D14 is  negative by QC_LANG1:def 19;
L272: ( the_argument_of D14 ) = R6 by L271 , QC_LANG1:def 24;
thus L273: thesis by L272 , L271 , L246;
end;
theorem
L274: (for R3 being QC-alphabet holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds ( Vars (( FALSUM R3 ) , R11) ) = ( {} )))
proof
let R3 being QC-alphabet;
let R11 being non  empty (Subset of ( QC-variables R3 ));
L275: ( FALSUM R3 ) = ( 'not' ( VERUM R3 ) ) by QC_LANG2:def 1;
thus L276: ( Vars (( FALSUM R3 ) , R11) ) = ( Vars (( VERUM R3 ) , R11) ) by L275 , L270
.= ( {} ) by L246;
end;
theorem
L277: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds (R6 is  conjunctive implies ( Vars (R6 , R11) ) = ( ( Vars (( the_left_argument_of R6 ) , R11) ) \/ ( Vars (( the_right_argument_of R6 ) , R11) ) ))))) by L246;
theorem
L278: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R7 being (Element of ( QC-WFF R3 )) holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds ( Vars (( R6 '&' R7 ) , R11) ) = ( ( Vars (R6 , R11) ) \/ ( Vars (R7 , R11) ) )))))
proof
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
let R7 being (Element of ( QC-WFF R3 ));
let R11 being non  empty (Subset of ( QC-variables R3 ));
set D15 = ( R6 '&' R7 );
L279: ( R6 '&' R7 ) is  conjunctive by QC_LANG1:def 20;
L280: (( the_left_argument_of D15 ) = R6 & ( the_right_argument_of D15 ) = R7) by L279 , QC_LANG1:def 25 , QC_LANG1:def 26;
thus L281: thesis by L280 , L279 , L246;
end;
theorem
L282: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds (R6 is  universal implies ( Vars (R6 , R11) ) = ( Vars (( the_scope_of R6 ) , R11) ))))) by L246;
theorem
L283: (for R3 being QC-alphabet holds (for R4 being (bound_QC-variable of R3) holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds ( Vars (( All (R4 , R6) ) , R11) ) = ( Vars (R6 , R11) )))))
proof
let R3 being QC-alphabet;
let R4 being (bound_QC-variable of R3);
let R6 being (Element of ( QC-WFF R3 ));
let R11 being non  empty (Subset of ( QC-variables R3 ));
L284: ( All (R4 , R6) ) is  universal by QC_LANG1:def 21;
L285: ( the_scope_of ( All (R4 , R6) ) ) = R6 by L284 , QC_LANG1:def 28;
thus L286: thesis by L285 , L284 , L246;
end;
theorem
L287: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds (R6 is  disjunctive implies ( Vars (R6 , R11) ) = ( ( Vars (( the_left_disjunct_of R6 ) , R11) ) \/ ( Vars (( the_right_disjunct_of R6 ) , R11) ) )))))
proof
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
let R11 being non  empty (Subset of ( QC-variables R3 ));
set D16 = ( the_left_disjunct_of R6 );
set D17 = ( the_right_disjunct_of R6 );
assume L288: R6 is  disjunctive;
L289: R6 = ( D16 'or' D17 ) by L288 , QC_LANG2:37;
L290: R6 = ( 'not' ( ( 'not' D16 ) '&' ( 'not' D17 ) ) ) by L289 , QC_LANG2:def 3;
thus L291: ( Vars (R6 , R11) ) = ( Vars (( ( 'not' D16 ) '&' ( 'not' D17 ) ) , R11) ) by L290 , L270
.= ( ( Vars (( 'not' D16 ) , R11) ) \/ ( Vars (( 'not' D17 ) , R11) ) ) by L278
.= ( ( Vars (D16 , R11) ) \/ ( Vars (( 'not' D17 ) , R11) ) ) by L270
.= ( ( Vars (( the_left_disjunct_of R6 ) , R11) ) \/ ( Vars (( the_right_disjunct_of R6 ) , R11) ) ) by L270;
end;
theorem
L292: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R7 being (Element of ( QC-WFF R3 )) holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds ( Vars (( R6 'or' R7 ) , R11) ) = ( ( Vars (R6 , R11) ) \/ ( Vars (R7 , R11) ) )))))
proof
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
let R7 being (Element of ( QC-WFF R3 ));
let R11 being non  empty (Subset of ( QC-variables R3 ));
L293: ( the_right_disjunct_of ( R6 'or' R7 ) ) = R7 by QC_LANG2:29;
L294: (( R6 'or' R7 ) is  disjunctive & ( the_left_disjunct_of ( R6 'or' R7 ) ) = R6) by QC_LANG2:29 , QC_LANG2:def 10;
thus L295: thesis by L294 , L293 , L287;
end;
theorem
L296: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds (R6 is  conditional implies ( Vars (R6 , R11) ) = ( ( Vars (( the_antecedent_of R6 ) , R11) ) \/ ( Vars (( the_consequent_of R6 ) , R11) ) )))))
proof
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
let R11 being non  empty (Subset of ( QC-variables R3 ));
set D18 = ( the_antecedent_of R6 );
set D19 = ( the_consequent_of R6 );
assume L297: R6 is  conditional;
L298: R6 = ( D18 => D19 ) by L297 , QC_LANG2:38;
L299: R6 = ( 'not' ( D18 '&' ( 'not' D19 ) ) ) by L298 , QC_LANG2:def 2;
thus L300: ( Vars (R6 , R11) ) = ( Vars (( D18 '&' ( 'not' D19 ) ) , R11) ) by L299 , L270
.= ( ( Vars (D18 , R11) ) \/ ( Vars (( 'not' D19 ) , R11) ) ) by L278
.= ( ( Vars (( the_antecedent_of R6 ) , R11) ) \/ ( Vars (( the_consequent_of R6 ) , R11) ) ) by L270;
end;
theorem
L301: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R7 being (Element of ( QC-WFF R3 )) holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds ( Vars (( R6 => R7 ) , R11) ) = ( ( Vars (R6 , R11) ) \/ ( Vars (R7 , R11) ) )))))
proof
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
let R7 being (Element of ( QC-WFF R3 ));
let R11 being non  empty (Subset of ( QC-variables R3 ));
L302: ( the_consequent_of ( R6 => R7 ) ) = R7 by QC_LANG2:30;
L303: (( R6 => R7 ) is  conditional & ( the_antecedent_of ( R6 => R7 ) ) = R6) by QC_LANG2:30 , QC_LANG2:def 11;
thus L304: thesis by L303 , L302 , L296;
end;
theorem
L305: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds (R6 is  biconditional implies ( Vars (R6 , R11) ) = ( ( Vars (( the_left_side_of R6 ) , R11) ) \/ ( Vars (( the_right_side_of R6 ) , R11) ) )))))
proof
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
let R11 being non  empty (Subset of ( QC-variables R3 ));
set D20 = ( the_left_side_of R6 );
set D21 = ( the_right_side_of R6 );
assume L306: R6 is  biconditional;
L307: R6 = ( D20 <=> D21 ) by L306 , QC_LANG2:39;
L308: R6 = ( ( D20 => D21 ) '&' ( D21 => D20 ) ) by L307 , QC_LANG2:def 4;
thus L309: ( Vars (R6 , R11) ) = ( ( Vars (( D20 => D21 ) , R11) ) \/ ( Vars (( D21 => D20 ) , R11) ) ) by L308 , L278
.= ( ( ( Vars (D20 , R11) ) \/ ( Vars (D21 , R11) ) ) \/ ( Vars (( D21 => D20 ) , R11) ) ) by L301
.= ( ( ( Vars (D20 , R11) ) \/ ( Vars (D21 , R11) ) ) \/ ( ( Vars (D20 , R11) ) \/ ( Vars (D21 , R11) ) ) ) by L301
.= ( ( Vars (( the_left_side_of R6 ) , R11) ) \/ ( Vars (( the_right_side_of R6 ) , R11) ) );
end;
theorem
L310: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R7 being (Element of ( QC-WFF R3 )) holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds ( Vars (( R6 <=> R7 ) , R11) ) = ( ( Vars (R6 , R11) ) \/ ( Vars (R7 , R11) ) )))))
proof
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
let R7 being (Element of ( QC-WFF R3 ));
let R11 being non  empty (Subset of ( QC-variables R3 ));
L311: ( the_right_side_of ( R6 <=> R7 ) ) = R7 by QC_LANG2:31;
L312: (( R6 <=> R7 ) is  biconditional & ( the_left_side_of ( R6 <=> R7 ) ) = R6) by QC_LANG2:31 , QC_LANG2:def 12;
thus L313: thesis by L312 , L311 , L305;
end;
theorem
L314: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds (R6 is  existential implies ( Vars (R6 , R11) ) = ( Vars (( the_argument_of ( the_scope_of ( the_argument_of R6 ) ) ) , R11) )))))
proof
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
let R11 being non  empty (Subset of ( QC-variables R3 ));
set D22 = ( the_argument_of ( the_scope_of ( the_argument_of R6 ) ) );
set D23 = ( bound_in ( the_argument_of R6 ) );
assume L315: R6 is  existential;
L316: R6 = ( Ex (D23 , D22) ) by L315 , QC_LANG2:40;
L317: R6 = ( 'not' ( All (D23 , ( 'not' D22 )) ) ) by L316 , QC_LANG2:def 5;
L318: ( Vars (R6 , R11) ) = ( Vars (( All (D23 , ( 'not' D22 )) ) , R11) ) by L317 , L270
.= ( Vars (( 'not' D22 ) , R11) ) by L283
.= ( Vars (D22 , R11) ) by L270;
thus L319: thesis by L318;
end;
theorem
L320: (for R3 being QC-alphabet holds (for R4 being (bound_QC-variable of R3) holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R11 being non  empty (Subset of ( QC-variables R3 )) holds ( Vars (( Ex (R4 , R6) ) , R11) ) = ( Vars (R6 , R11) )))))
proof
let R3 being QC-alphabet;
let R4 being (bound_QC-variable of R3);
let R6 being (Element of ( QC-WFF R3 ));
let R11 being non  empty (Subset of ( QC-variables R3 ));
L321: ( Ex (R4 , R6) ) = ( 'not' ( All (R4 , ( 'not' R6 )) ) ) by QC_LANG2:def 5;
thus L322: ( Vars (( Ex (R4 , R6) ) , R11) ) = ( Vars (( All (R4 , ( 'not' R6 )) ) , R11) ) by L321 , L270
.= ( Vars (( 'not' R6 ) , R11) ) by L283
.= ( Vars (R6 , R11) ) by L270;
end;
definition
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
func Free R6 -> (Subset of ( free_QC-variables R3 )) equals 
( Vars (R6 , ( free_QC-variables R3 )) );
correctness;
end;
theorem
L324: (for R3 being QC-alphabet holds ( Free ( VERUM R3 ) ) = ( {} )) by L246;
theorem
L325: (for R2 being (Element of ( NAT )) holds (for R3 being QC-alphabet holds (for B204 being (QC-pred_symbol of R2 , R3) holds (for B205 being (QC-variable_list of R2 , R3) holds ( Free ( B204 ! B205 ) ) = { ( B205 . R1 ) where R1 is (Element of ( NAT )) : (1 <= R1 & R1 <= ( len B205 ) & ( B205 . R1 ) in ( free_QC-variables R3 )) })))) by L265;
theorem
L326: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds ( Free ( 'not' R6 ) ) = ( Free R6 ))) by L270;
theorem
L327: (for R3 being QC-alphabet holds ( Free ( FALSUM R3 ) ) = ( {} )) by L274;
theorem
L328: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R7 being (Element of ( QC-WFF R3 )) holds ( Free ( R6 '&' R7 ) ) = ( ( Free R6 ) \/ ( Free R7 ) )))) by L278;
theorem
L329: (for R3 being QC-alphabet holds (for R4 being (bound_QC-variable of R3) holds (for R6 being (Element of ( QC-WFF R3 )) holds ( Free ( All (R4 , R6) ) ) = ( Free R6 )))) by L283;
theorem
L330: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R7 being (Element of ( QC-WFF R3 )) holds ( Free ( R6 'or' R7 ) ) = ( ( Free R6 ) \/ ( Free R7 ) ))))
proof
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
let R7 being (Element of ( QC-WFF R3 ));
L331: ( R6 'or' R7 ) = ( 'not' ( ( 'not' R6 ) '&' ( 'not' R7 ) ) ) by QC_LANG2:def 3;
thus L332: ( Free ( R6 'or' R7 ) ) = ( Free ( ( 'not' R6 ) '&' ( 'not' R7 ) ) ) by L331 , L270
.= ( ( Free ( 'not' R6 ) ) \/ ( Free ( 'not' R7 ) ) ) by L278
.= ( ( Free R6 ) \/ ( Free ( 'not' R7 ) ) ) by L270
.= ( ( Free R6 ) \/ ( Free R7 ) ) by L270;
end;
theorem
L333: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R7 being (Element of ( QC-WFF R3 )) holds ( Free ( R6 => R7 ) ) = ( ( Free R6 ) \/ ( Free R7 ) ))))
proof
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
let R7 being (Element of ( QC-WFF R3 ));
L334: ( R6 => R7 ) = ( 'not' ( R6 '&' ( 'not' R7 ) ) ) by QC_LANG2:def 2;
thus L335: ( Free ( R6 => R7 ) ) = ( Free ( R6 '&' ( 'not' R7 ) ) ) by L334 , L270
.= ( ( Free R6 ) \/ ( Free ( 'not' R7 ) ) ) by L278
.= ( ( Free R6 ) \/ ( Free R7 ) ) by L270;
end;
theorem
L336: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R7 being (Element of ( QC-WFF R3 )) holds ( Free ( R6 <=> R7 ) ) = ( ( Free R6 ) \/ ( Free R7 ) ))))
proof
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
let R7 being (Element of ( QC-WFF R3 ));
L337: ( R6 <=> R7 ) = ( ( R6 => R7 ) '&' ( R7 => R6 ) ) by QC_LANG2:def 4;
thus L338: ( Free ( R6 <=> R7 ) ) = ( ( Free ( R6 => R7 ) ) \/ ( Free ( R7 => R6 ) ) ) by L337 , L278
.= ( ( ( Free R6 ) \/ ( Free R7 ) ) \/ ( Free ( R7 => R6 ) ) ) by L333
.= ( ( ( Free R6 ) \/ ( Free R7 ) ) \/ ( ( Free R6 ) \/ ( Free R7 ) ) ) by L333
.= ( ( Free R6 ) \/ ( Free R7 ) );
end;
theorem
L339: (for R3 being QC-alphabet holds (for R4 being (bound_QC-variable of R3) holds (for R6 being (Element of ( QC-WFF R3 )) holds ( Free ( Ex (R4 , R6) ) ) = ( Free R6 ))))
proof
let R3 being QC-alphabet;
let R4 being (bound_QC-variable of R3);
let R6 being (Element of ( QC-WFF R3 ));
L340: ( Ex (R4 , R6) ) = ( 'not' ( All (R4 , ( 'not' R6 )) ) ) by QC_LANG2:def 5;
thus L341: ( Free ( Ex (R4 , R6) ) ) = ( Free ( All (R4 , ( 'not' R6 )) ) ) by L340 , L270
.= ( Free ( 'not' R6 ) ) by L283
.= ( Free R6 ) by L270;
end;
definition
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
func Fixed R6 -> (Subset of ( fixed_QC-variables R3 )) equals 
( Vars (R6 , ( fixed_QC-variables R3 )) );
correctness;
end;
theorem
L343: (for R3 being QC-alphabet holds ( Fixed ( VERUM R3 ) ) = ( {} )) by L246;
theorem
L344: (for R2 being (Element of ( NAT )) holds (for R3 being QC-alphabet holds (for B206 being (QC-pred_symbol of R2 , R3) holds (for B207 being (QC-variable_list of R2 , R3) holds ( Fixed ( B206 ! B207 ) ) = { ( B207 . R1 ) where R1 is (Element of ( NAT )) : (1 <= R1 & R1 <= ( len B207 ) & ( B207 . R1 ) in ( fixed_QC-variables R3 )) })))) by L265;
theorem
L345: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds ( Fixed ( 'not' R6 ) ) = ( Fixed R6 ))) by L270;
theorem
L346: (for R3 being QC-alphabet holds ( Fixed ( FALSUM R3 ) ) = ( {} ))
proof
let R3 being QC-alphabet;
thus L347: ( Fixed ( FALSUM R3 ) ) = ( Fixed ( 'not' ( VERUM R3 ) ) ) by QC_LANG2:def 1
.= ( Fixed ( VERUM R3 ) ) by L270
.= ( {} ) by L246;
end;
theorem
L348: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R7 being (Element of ( QC-WFF R3 )) holds ( Fixed ( R6 '&' R7 ) ) = ( ( Fixed R6 ) \/ ( Fixed R7 ) )))) by L278;
theorem
L349: (for R3 being QC-alphabet holds (for R4 being (bound_QC-variable of R3) holds (for R6 being (Element of ( QC-WFF R3 )) holds ( Fixed ( All (R4 , R6) ) ) = ( Fixed R6 )))) by L283;
theorem
L350: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R7 being (Element of ( QC-WFF R3 )) holds ( Fixed ( R6 'or' R7 ) ) = ( ( Fixed R6 ) \/ ( Fixed R7 ) ))))
proof
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
let R7 being (Element of ( QC-WFF R3 ));
L351: ( R6 'or' R7 ) = ( 'not' ( ( 'not' R6 ) '&' ( 'not' R7 ) ) ) by QC_LANG2:def 3;
thus L352: ( Fixed ( R6 'or' R7 ) ) = ( Fixed ( ( 'not' R6 ) '&' ( 'not' R7 ) ) ) by L351 , L270
.= ( ( Fixed ( 'not' R6 ) ) \/ ( Fixed ( 'not' R7 ) ) ) by L278
.= ( ( Fixed R6 ) \/ ( Fixed ( 'not' R7 ) ) ) by L270
.= ( ( Fixed R6 ) \/ ( Fixed R7 ) ) by L270;
end;
theorem
L353: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R7 being (Element of ( QC-WFF R3 )) holds ( Fixed ( R6 => R7 ) ) = ( ( Fixed R6 ) \/ ( Fixed R7 ) ))))
proof
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
let R7 being (Element of ( QC-WFF R3 ));
L354: ( R6 => R7 ) = ( 'not' ( R6 '&' ( 'not' R7 ) ) ) by QC_LANG2:def 2;
thus L355: ( Fixed ( R6 => R7 ) ) = ( Fixed ( R6 '&' ( 'not' R7 ) ) ) by L354 , L270
.= ( ( Fixed R6 ) \/ ( Fixed ( 'not' R7 ) ) ) by L278
.= ( ( Fixed R6 ) \/ ( Fixed R7 ) ) by L270;
end;
theorem
L356: (for R3 being QC-alphabet holds (for R6 being (Element of ( QC-WFF R3 )) holds (for R7 being (Element of ( QC-WFF R3 )) holds ( Fixed ( R6 <=> R7 ) ) = ( ( Fixed R6 ) \/ ( Fixed R7 ) ))))
proof
let R3 being QC-alphabet;
let R6 being (Element of ( QC-WFF R3 ));
let R7 being (Element of ( QC-WFF R3 ));
L357: ( R6 <=> R7 ) = ( ( R6 => R7 ) '&' ( R7 => R6 ) ) by QC_LANG2:def 4;
thus L358: ( Fixed ( R6 <=> R7 ) ) = ( ( Fixed ( R6 => R7 ) ) \/ ( Fixed ( R7 => R6 ) ) ) by L357 , L278
.= ( ( ( Fixed R6 ) \/ ( Fixed R7 ) ) \/ ( Fixed ( R7 => R6 ) ) ) by L353
.= ( ( ( Fixed R6 ) \/ ( Fixed R7 ) ) \/ ( ( Fixed R7 ) \/ ( Fixed R6 ) ) ) by L353
.= ( ( Fixed R6 ) \/ ( Fixed R7 ) );
end;
theorem
L359: (for R3 being QC-alphabet holds (for R4 being (bound_QC-variable of R3) holds (for R6 being (Element of ( QC-WFF R3 )) holds ( Fixed ( Ex (R4 , R6) ) ) = ( Fixed R6 ))))
proof
let R3 being QC-alphabet;
let R4 being (bound_QC-variable of R3);
let R6 being (Element of ( QC-WFF R3 ));
L360: ( Ex (R4 , R6) ) = ( 'not' ( All (R4 , ( 'not' R6 )) ) ) by QC_LANG2:def 5;
thus L361: ( Fixed ( Ex (R4 , R6) ) ) = ( Fixed ( All (R4 , ( 'not' R6 )) ) ) by L360 , L270
.= ( Fixed ( 'not' R6 ) ) by L283
.= ( Fixed R6 ) by L270;
end;
