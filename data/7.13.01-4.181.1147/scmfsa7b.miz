:: Constant assignment macro instructions of SCM+FSA, Part II
::  by Noriko Asamoto
::
:: Received August 27, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, FINSEQ_1, AMI_1, SCMFSA_2, RELAT_1, SCMFSA_7,
      ARYTM_3, ARYTM_1, TARSKI, FUNCT_1, XXREAL_0, PARTFUN1, CAT_1, NAT_1,
      CARD_1, FUNCOP_1, SCMFSA6A, ORDINAL4, AMI_3, FUNCT_4, INT_1, GRAPHSP,
      FSM_1, CIRCUIT2, EXTPRO_1, SCMFSA6B, GLIB_000, SF_MASTR, MSUALG_1,
      XBOOLE_0, PRE_POLY, UNIALG_2, AMISTD_2, SCMFSA7B, ORDINAL1, AFINSQ_1,
      PBOOLE, SCMFSA6C, STRUCT_0, COMPOS_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, COMPLEX1,
      ORDINAL1, NAT_1, INT_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FINSEQ_1,
      FINSEQ_2, FUNCT_4, DOMAIN_1, VALUED_1, AFINSQ_1, STRUCT_0, MEMSTR_0,
      COMPOS_0, COMPOS_1, EXTPRO_1, FUNCT_7, SCMFSA_2, AMISTD_1, AMISTD_2,
      FUNCOP_1, XXREAL_0, ENUMSET1, NAT_D, PBOOLE, AFINSQ_2, SCMFSA_7,
      SCMFSA6A, SF_MASTR, SCMFSA6B, INT_2, PRE_POLY, SCMFSA_M;
 constructors ENUMSET1, XXREAL_0, REAL_1, SCMFSA_7, SCMFSA6A, SF_MASTR,
      SCMFSA6B, NAT_D, RELSET_1, PRE_POLY, DOMAIN_1, AFINSQ_2, PARTFUN3,
      PBOOLE, AMISTD_1, AMISTD_2, AMI_3, MEMSTR_0, SCMFSA_M, FUNCT_7;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, FINSEQ_1, FUNCT_7, SCMFSA_2, SF_MASTR,
      SCMFSA6B, ORDINAL1, FINSET_1, FINSEQ_2, CARD_1, AFINSQ_1, COMPOS_1,
      AFINSQ_2, ORDINAL5, EXTPRO_1, PBOOLE, FUNCT_4, STRUCT_0, SCMFSA6A,
      SCMFSA_4, MEMSTR_0, VALUED_1, SCMFSA10, AMISTD_2, AMI_3, COMPOS_0,
      SCMFSA_M;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, AFINSQ_1, RELAT_1, FINSEQ_1, FINSEQ_2, SCMFSA_2, FUNCOP_1,
      SCMFSA6A, SCMFSA6B, COMPOS_1, AMISTD_1, SCMFSA_7, EXTPRO_1, MEMSTR_0,
      AFINSQ_2, SCMFSA_M;
 theorems SCMFSA_7, NAT_1, GRFUNC_1, FUNCT_1, FUNCT_4, FUNCT_7, ENUMSET1,
      SCMFSA_2, FUNCOP_1, INT_1, RELAT_1, TARSKI, SCMFSA6A, SF_MASTR, SCMFSA6B,
      XBOOLE_0, XBOOLE_1, XREAL_1, XXREAL_0, AFINSQ_1, COMPOS_1, AFINSQ_2,
      CARD_1, EXTPRO_1, PARTFUN1, AMISTD_1, MEMSTR_0, SCMFSA_M;
 schemes NAT_1, AFINSQ_1;

begin
set D1 = ( NAT );
theorem
L1: (for B1 being (Instruction of ( SCM+FSA )) holds ((B1 = ( halt ( SCM+FSA ) ) implies ( ( Directed ( Macro B1 ) ) . ( 0 ) ) = ( goto 2 )) & (B1 <> ( halt ( SCM+FSA ) ) implies ( ( Directed ( Macro B1 ) ) . ( 0 ) ) = B1)))
proof
L2: ( dom ( id (the InstructionsF of ( SCM+FSA )) ) ) = (the InstructionsF of ( SCM+FSA ));
let C1 being (Instruction of ( SCM+FSA ));
L3: ( ( Macro C1 ) . ( 0 ) ) = C1 by COMPOS_1:58;
L4: ( 0 ) in { ( 0 ) , 1 } by TARSKI:def 2;
L5: ( 0 ) in ( dom ( Macro C1 ) ) by L4 , COMPOS_1:61;
L6: ( card ( Macro C1 ) ) = 2 by COMPOS_1:56;
thus L7:now
L8: ( dom ( id (the InstructionsF of ( SCM+FSA )) ) ) = (the InstructionsF of ( SCM+FSA ));
assume L9: C1 = ( halt ( SCM+FSA ) );
L10: ( dom ( ( halt ( SCM+FSA ) ) .--> ( goto 2 ) ) ) = { ( halt ( SCM+FSA ) ) } by FUNCOP_1:13;
L11: C1 in ( dom ( ( halt ( SCM+FSA ) ) .--> ( goto 2 ) ) ) by L10 , L9 , TARSKI:def 1;
L12: ( rng ( Macro C1 ) ) c= (the InstructionsF of ( SCM+FSA )) by RELAT_1:def 19;
thus L13: ( ( Directed ( Macro C1 ) ) . ( 0 ) ) = ( ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* (( halt ( SCM+FSA ) ) , ( goto 2 )) ) * ( Macro C1 ) ) . ( 0 ) ) by L12 , L6 , FUNCT_7:116
.= ( ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* ( ( halt ( SCM+FSA ) ) .--> ( goto 2 ) ) ) * ( Macro C1 ) ) . ( 0 ) ) by L8 , FUNCT_7:def 3
.= ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* ( ( halt ( SCM+FSA ) ) .--> ( goto 2 ) ) ) . C1 ) by L5 , L3 , FUNCT_1:13
.= ( ( ( halt ( SCM+FSA ) ) .--> ( goto 2 ) ) . C1 ) by L11 , FUNCT_4:13
.= ( goto 2 ) by L9 , FUNCOP_1:72;
end;
L14: ( dom ( ( halt ( SCM+FSA ) ) .--> ( goto 2 ) ) ) = { ( halt ( SCM+FSA ) ) } by FUNCOP_1:13;
assume L15: C1 <> ( halt ( SCM+FSA ) );
L16: (not C1 in ( dom ( ( halt ( SCM+FSA ) ) .--> ( goto 2 ) ) )) by L15 , L14 , TARSKI:def 1;
L17: ( rng ( Macro C1 ) ) c= (the InstructionsF of ( SCM+FSA )) by RELAT_1:def 19;
thus L18: ( ( Directed ( Macro C1 ) ) . ( 0 ) ) = ( ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* (( halt ( SCM+FSA ) ) , ( goto 2 )) ) * ( Macro C1 ) ) . ( 0 ) ) by L17 , L6 , FUNCT_7:116
.= ( ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* ( ( halt ( SCM+FSA ) ) .--> ( goto 2 ) ) ) * ( Macro C1 ) ) . ( 0 ) ) by L2 , FUNCT_7:def 3
.= ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* ( ( halt ( SCM+FSA ) ) .--> ( goto 2 ) ) ) . C1 ) by L5 , L3 , FUNCT_1:13
.= ( ( id (the InstructionsF of ( SCM+FSA )) ) . C1 ) by L16 , FUNCT_4:11
.= C1 by FUNCT_1:18;
end;
theorem
L19: (for B2 being (Instruction of ( SCM+FSA )) holds ( ( Directed ( Macro B2 ) ) . 1 ) = ( goto 2 ))
proof
let C2 being (Instruction of ( SCM+FSA ));
L20: ( ( Macro C2 ) . 1 ) = ( halt ( SCM+FSA ) ) by COMPOS_1:59;
L21: 1 in { ( 0 ) , 1 } by TARSKI:def 2;
L22: 1 in ( dom ( Macro C2 ) ) by L21 , COMPOS_1:61;
L23: ( dom ( ( halt ( SCM+FSA ) ) .--> ( goto 2 ) ) ) = { ( halt ( SCM+FSA ) ) } by FUNCOP_1:13;
L24: ( halt ( SCM+FSA ) ) in ( dom ( ( halt ( SCM+FSA ) ) .--> ( goto 2 ) ) ) by L23 , TARSKI:def 1;
L25: ( dom ( id (the InstructionsF of ( SCM+FSA )) ) ) = (the InstructionsF of ( SCM+FSA ));
L26: (( card ( Macro C2 ) ) = 2 & ( rng ( Macro C2 ) ) c= (the InstructionsF of ( SCM+FSA ))) by COMPOS_1:56 , RELAT_1:def 19;
thus L27: ( ( Directed ( Macro C2 ) ) . 1 ) = ( ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* (( halt ( SCM+FSA ) ) , ( goto 2 )) ) * ( Macro C2 ) ) . 1 ) by L26 , FUNCT_7:116
.= ( ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* ( ( halt ( SCM+FSA ) ) .--> ( goto 2 ) ) ) * ( Macro C2 ) ) . 1 ) by L25 , FUNCT_7:def 3
.= ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* ( ( halt ( SCM+FSA ) ) .--> ( goto 2 ) ) ) . ( halt ( SCM+FSA ) ) ) by L22 , L20 , FUNCT_1:13
.= ( ( ( halt ( SCM+FSA ) ) .--> ( goto 2 ) ) . ( halt ( SCM+FSA ) ) ) by L24 , FUNCT_4:13
.= ( goto 2 ) by FUNCOP_1:72;
end;
registration
let C3 being Int-Location;
let C4 being Integer;
cluster ( C3 := C4 ) ->  initial non  empty ( NAT ) -defined (the InstructionsF of ( SCM+FSA )) -valued;
coherence
proof
L28: ( C3 := C4 ) = ( ( aSeq (C3 , C4) ) ^ <% ( halt ( SCM+FSA ) ) %> ) by SCMFSA_7:1;
thus L29: thesis by L28;
end;
end;
L31: (for B3 being (State of ( SCM+FSA )) holds (( IC B3 ) = ( 0 ) implies (for B4 being (Instruction-Sequence of ( SCM+FSA )) holds (for B5 being Int-Location holds (for B6 being Integer holds (( B5 := B6 ) c= B4 implies B4 halts_on B3))))))
proof
let C5 being (State of ( SCM+FSA ));
assume L32: ( IC C5 ) = ( 0 );
let C6 being (Instruction-Sequence of ( SCM+FSA ));
L33: ( dom C6 ) = ( NAT ) by PARTFUN1:def 2;
let C7 being Int-Location;
let C8 being Integer;
assume L34: ( C7 := C8 ) c= C6;
per cases ;
suppose L35: C8 > ( 0 );

consider C9 being (Element of ( NAT )) such that L36: ( C9 + 1 ) = C8 and L37: ( C7 := C8 ) = ( ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( C9 --> ( AddTo (C7 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> ) by L35 , SCMFSA_7:def 1;
L38: ( len ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( C9 --> ( AddTo (C7 , ( intloc ( 0 ) )) ) ) ) ) = ( ( len <% ( C7 := ( intloc ( 0 ) ) ) %> ) + ( len ( C9 --> ( AddTo (C7 , ( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:17
.= ( 1 + ( len ( C9 --> ( AddTo (C7 , ( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:34
.= C8 by L36 , CARD_1:64;
set D2 = ( ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( C9 --> ( AddTo (C7 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> );
L39: ( D2 . ( 0 ) ) = ( ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( ( C9 --> ( AddTo (C7 , ( intloc ( 0 ) )) ) ) ^ <% ( halt ( SCM+FSA ) ) %> ) ) . ( 0 ) ) by AFINSQ_1:27
.= ( C7 := ( intloc ( 0 ) ) ) by AFINSQ_1:35;
reconsider D3 = C8 as (Element of ( NAT )) by L35 , INT_1:3;
L40: ( len D2 ) = ( ( len ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( C9 --> ( AddTo (C7 , ( intloc ( 0 ) )) ) ) ) ) + ( len <% ( halt ( SCM+FSA ) ) %> ) ) by AFINSQ_1:17
.= ( D3 + 1 ) by L38 , AFINSQ_1:34;
L41:
now
let C10 being (Element of ( NAT ));
assume that
L42: C10 <= D3;
L43: C10 < ( D3 + 1 ) by L42 , NAT_1:13;
thus L44: C10 in ( dom D2 ) by L43 , L40 , NAT_1:44;
end;
L45:
now
let C11 being (Element of ( NAT ));
assume that
L46: C11 <= D3;
L47: C11 in ( dom D2 ) by L41 , L46;
thus L48: ( C6 . C11 ) = ( D2 . C11 ) by L47 , L34 , L37 , GRFUNC_1:2;
end;
L49: ( C6 . ( 0 ) ) = ( C7 := ( intloc ( 0 ) ) ) by L45 , L39;
L50:
now
let C12 being (Element of ( NAT ));
assume L51: C12 = ( 0 );
thus L52: ( Comput (C6 , C5 , C12) ) = C5 by L51 , EXTPRO_1:2;
thus L53: ( CurInstr (C6 , ( Comput (C6 , C5 , C12) )) ) = ( C7 := ( intloc ( 0 ) ) ) by L52 , L32 , L49 , L33 , PARTFUN1:def 6;
thus L54: ( Comput (C6 , C5 , ( C12 + 1 )) ) = ( Following (C6 , ( Comput (C6 , C5 , C12) )) ) by EXTPRO_1:3
.= ( Exec (( C7 := ( intloc ( 0 ) ) ) , C5) ) by L52 , L32 , L49 , L33 , PARTFUN1:def 6;
end;
L55:
now
let C13 being (Element of ( NAT ));
assume that
L56: 1 <= C13
and
L57: C13 < D3;
reconsider D4 = ( C13 - 1 ) as (Element of ( NAT )) by L56 , INT_1:5;
L58: ( C13 - 1 ) < ( D3 - 1 ) by L57 , XREAL_1:9;
L59: D4 in C9 by L58 , L36 , NAT_1:44;
L60: ( len <% ( C7 := ( intloc ( 0 ) ) ) %> ) = 1 by AFINSQ_1:33;
L61: ( len ( C9 --> ( AddTo (C7 , ( intloc ( 0 ) )) ) ) ) = C9 by CARD_1:64;
L62: C13 in ( dom ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( C9 --> ( AddTo (C7 , ( intloc ( 0 ) )) ) ) ) ) by L57 , L38 , NAT_1:44;
thus L63: ( D2 . C13 ) = ( ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( C9 --> ( AddTo (C7 , ( intloc ( 0 ) )) ) ) ) . C13 ) by L62 , AFINSQ_1:def 3
.= ( ( C9 --> ( AddTo (C7 , ( intloc ( 0 ) )) ) ) . ( C13 - 1 ) ) by L56 , L57 , L60 , L61 , L36 , AFINSQ_1:18
.= ( AddTo (C7 , ( intloc ( 0 ) )) ) by L59 , FUNCOP_1:7;
end;
L64:
now
let C14 being (Element of ( NAT ));
assume that
L65: ( 0 ) < C14
and
L66: C14 < D3;
L67: ( ( 0 ) + 1 ) <= C14 by L65 , NAT_1:13;
thus L68: ( C6 . C14 ) = ( D2 . C14 ) by L45 , L66
.= ( AddTo (C7 , ( intloc ( 0 ) )) ) by L55 , L67 , L66;
end;
L69: (for B7 being (Element of ( NAT )) holds (B7 <= D3 implies ( IC ( Comput (C6 , C5 , B7) ) ) = B7))
proof
defpred S1[ Nat ] means ($1 <= D3 implies ( IC ( Comput (C6 , C5 , $1) ) ) = $1);
let C15 being (Element of ( NAT ));
assume L70: C15 <= D3;
L71: (for B8 being (Element of ( NAT )) holds (S1[ B8 ] implies S1[ ( B8 + 1 ) ]))
proof
let C16 being (Element of ( NAT ));
assume L72: S1[ C16 ];
assume L73: ( C16 + 1 ) <= D3;
L74: C16 < D3 by L73 , NAT_1:13;
per cases ;
suppose L75: C16 = ( 0 );

thus L76: ( IC ( Comput (C6 , C5 , ( C16 + 1 )) ) ) = ( ( Exec (( C7 := ( intloc ( 0 ) ) ) , C5) ) . ( IC ( SCM+FSA ) ) ) by L75 , L50
.= ( succ C16 ) by L32 , L75 , SCMFSA_2:63
.= ( C16 + 1 ) by NAT_1:38;
end;
suppose L77: C16 > ( 0 );

L78: ( C16 + ( 0 ) ) <= ( C16 + 1 ) by XREAL_1:7;
L79: ( CurInstr (C6 , ( Comput (C6 , C5 , C16) )) ) = ( C6 . C16 ) by L78 , L72 , L73 , L33 , PARTFUN1:def 6 , XXREAL_0:2
.= ( AddTo (C7 , ( intloc ( 0 ) )) ) by L64 , L74 , L77;
L80: ( Comput (C6 , C5 , ( C16 + 1 )) ) = ( Following (C6 , ( Comput (C6 , C5 , C16) )) ) by EXTPRO_1:3
.= ( Exec (( AddTo (C7 , ( intloc ( 0 ) )) ) , ( Comput (C6 , C5 , C16) )) ) by L79;
thus L81: ( IC ( Comput (C6 , C5 , ( C16 + 1 )) ) ) = ( succ ( IC ( Comput (C6 , C5 , C16) ) ) ) by L80 , SCMFSA_2:64
.= ( C16 + 1 ) by L72 , L73 , NAT_1:13 , NAT_1:38;
end;
end;
L83: S1[ ( 0 ) ] by L32;
L84: (for B9 being (Element of ( NAT )) holds S1[ B9 ]) from NAT_1:sch 1(L83 , L71);
thus L85: thesis by L84 , L70;
end;
L86: D3 < ( D3 + ( len <% ( halt ( SCM+FSA ) ) %> ) ) by XREAL_1:29;
L87: ( D2 . D3 ) = ( <% ( halt ( SCM+FSA ) ) %> . ( D3 - D3 ) ) by L86 , L38 , AFINSQ_1:18
.= ( halt ( SCM+FSA ) ) by AFINSQ_1:34;
L88: ( CurInstr (C6 , ( Comput (C6 , C5 , D3) )) ) = ( C6 . ( IC ( Comput (C6 , C5 , D3) ) ) ) by L33 , PARTFUN1:def 6
.= ( C6 . D3 ) by L69
.= ( halt ( SCM+FSA ) ) by L87 , L45;
thus L89: thesis by L88 , EXTPRO_1:29;
end;
suppose L90: C8 <= ( 0 );

reconsider D5 = ( - C8 ) as (Element of ( NAT )) by L90 , INT_1:3;
consider C17 being (Element of ( NAT )) such that L91: ( C17 + C8 ) = 1 and L92: ( C7 := C8 ) = ( ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( C17 --> ( SubFrom (C7 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> ) by L90 , SCMFSA_7:def 1;
L93: ( len ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( C17 --> ( SubFrom (C7 , ( intloc ( 0 ) )) ) ) ) ) = ( ( len <% ( C7 := ( intloc ( 0 ) ) ) %> ) + ( len ( C17 --> ( SubFrom (C7 , ( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:17
.= ( 1 + ( len ( C17 --> ( SubFrom (C7 , ( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:34
.= ( ( D5 + 1 ) + 1 ) by L91 , CARD_1:64;
set D6 = ( ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( C17 --> ( SubFrom (C7 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> );
L94: ( D6 . ( 0 ) ) = ( ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( ( C17 --> ( SubFrom (C7 , ( intloc ( 0 ) )) ) ) ^ <% ( halt ( SCM+FSA ) ) %> ) ) . ( 0 ) ) by AFINSQ_1:27
.= ( C7 := ( intloc ( 0 ) ) ) by AFINSQ_1:35;
L95: ( len D6 ) = ( ( len ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( C17 --> ( SubFrom (C7 , ( intloc ( 0 ) )) ) ) ) ) + ( len <% ( halt ( SCM+FSA ) ) %> ) ) by AFINSQ_1:17
.= ( ( ( D5 + 1 ) + 1 ) + 1 ) by L93 , AFINSQ_1:34;
L96:
now
let C18 being (Element of ( NAT ));
assume that
L97: ( 0 ) <= C18
and
L98: C18 <= ( ( D5 + 1 ) + 1 );
L99: C18 < ( ( ( D5 + 1 ) + 1 ) + 1 ) by L98 , NAT_1:13;
thus L100: C18 in ( dom D6 ) by L99 , L95 , NAT_1:44;
end;
L101:
now
let C19 being (Element of ( NAT ));
assume that
L102: ( 0 ) <= C19
and
L103: C19 <= ( ( D5 + 1 ) + 1 );
L104: C19 in ( dom D6 ) by L96 , L103;
thus L105: ( C6 . C19 ) = ( D6 . C19 ) by L104 , L34 , L92 , GRFUNC_1:2;
end;
L106: ( C6 . ( 0 ) ) = ( C7 := ( intloc ( 0 ) ) ) by L101 , L94;
L107:
now
let C20 being (Element of ( NAT ));
assume L108: C20 = ( 0 );
thus L109: ( Comput (C6 , C5 , C20) ) = C5 by L108 , EXTPRO_1:2;
thus L110: ( CurInstr (C6 , ( Comput (C6 , C5 , C20) )) ) = ( C7 := ( intloc ( 0 ) ) ) by L109 , L32 , L106 , L33 , PARTFUN1:def 6;
thus L111: ( Comput (C6 , C5 , ( C20 + 1 )) ) = ( Following (C6 , ( Comput (C6 , C5 , C20) )) ) by EXTPRO_1:3
.= ( Exec (( C7 := ( intloc ( 0 ) ) ) , C5) ) by L109 , L32 , L106 , L33 , PARTFUN1:def 6;
end;
L112:
now
L113: ( len <% ( C7 := ( intloc ( 0 ) ) ) %> ) = 1 by AFINSQ_1:33;
let C21 being (Element of ( NAT ));
assume that
L114: 1 <= C21
and
L115: C21 < ( ( D5 + 1 ) + 1 );
reconsider D7 = ( C21 - 1 ) as (Element of ( NAT )) by L114 , INT_1:5;
L116: ( C21 - 1 ) < ( ( C17 + 1 ) - 1 ) by L115 , L91 , XREAL_1:9;
L117: D7 in C17 by L116 , NAT_1:44;
L118: ( len ( C17 --> ( SubFrom (C7 , ( intloc ( 0 ) )) ) ) ) = C17 by CARD_1:64;
L119: C21 in ( dom ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( C17 --> ( SubFrom (C7 , ( intloc ( 0 ) )) ) ) ) ) by L115 , L93 , NAT_1:44;
thus L120: ( D6 . C21 ) = ( ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( C17 --> ( SubFrom (C7 , ( intloc ( 0 ) )) ) ) ) . C21 ) by L119 , AFINSQ_1:def 3
.= ( ( C17 --> ( SubFrom (C7 , ( intloc ( 0 ) )) ) ) . ( C21 - 1 ) ) by L91 , L114 , L115 , L113 , L118 , AFINSQ_1:18
.= ( SubFrom (C7 , ( intloc ( 0 ) )) ) by L117 , FUNCOP_1:7;
end;
L121:
now
let C22 being (Element of ( NAT ));
assume that
L122: ( 0 ) < C22
and
L123: C22 < ( ( D5 + 1 ) + 1 );
L124: ( ( 0 ) + 1 ) <= C22 by L122 , NAT_1:13;
thus L125: ( C6 . C22 ) = ( D6 . C22 ) by L101 , L123
.= ( SubFrom (C7 , ( intloc ( 0 ) )) ) by L112 , L124 , L123;
end;
L126: (for B10 being (Element of ( NAT )) holds (B10 <= ( ( D5 + 1 ) + 1 ) implies ( IC ( Comput (C6 , C5 , B10) ) ) = B10))
proof
defpred S2[ Nat ] means ($1 <= ( ( D5 + 1 ) + 1 ) implies ( IC ( Comput (C6 , C5 , $1) ) ) = $1);
let C23 being (Element of ( NAT ));
assume L127: C23 <= ( ( D5 + 1 ) + 1 );
L128: (for B11 being (Element of ( NAT )) holds (S2[ B11 ] implies S2[ ( B11 + 1 ) ]))
proof
let C24 being (Element of ( NAT ));
assume L129: S2[ C24 ];
assume L130: ( C24 + 1 ) <= ( ( D5 + 1 ) + 1 );
L131: C24 < ( ( D5 + 1 ) + 1 ) by L130 , NAT_1:13;
per cases ;
suppose L132: C24 = ( 0 );

thus L133: ( IC ( Comput (C6 , C5 , ( C24 + 1 )) ) ) = ( ( Exec (( C7 := ( intloc ( 0 ) ) ) , C5) ) . ( IC ( SCM+FSA ) ) ) by L132 , L107
.= ( succ C24 ) by L32 , L132 , SCMFSA_2:63
.= ( C24 + 1 ) by NAT_1:38;
end;
suppose L134: C24 > ( 0 );

L135: ( C24 + ( 0 ) ) <= ( C24 + 1 ) by XREAL_1:7;
L136: ( CurInstr (C6 , ( Comput (C6 , C5 , C24) )) ) = ( C6 . C24 ) by L135 , L129 , L130 , L33 , PARTFUN1:def 6 , XXREAL_0:2
.= ( SubFrom (C7 , ( intloc ( 0 ) )) ) by L121 , L131 , L134;
L137: ( Comput (C6 , C5 , ( C24 + 1 )) ) = ( Following (C6 , ( Comput (C6 , C5 , C24) )) ) by EXTPRO_1:3
.= ( Exec (( SubFrom (C7 , ( intloc ( 0 ) )) ) , ( Comput (C6 , C5 , C24) )) ) by L136;
thus L138: ( IC ( Comput (C6 , C5 , ( C24 + 1 )) ) ) = ( succ ( IC ( Comput (C6 , C5 , C24) ) ) ) by L137 , SCMFSA_2:65
.= ( C24 + 1 ) by L129 , L130 , NAT_1:13 , NAT_1:38;
end;
end;
L140: S2[ ( 0 ) ] by L32;
L141: (for B12 being (Element of ( NAT )) holds S2[ B12 ]) from NAT_1:sch 1(L140 , L128);
thus L142: thesis by L141 , L127;
end;
L143: ((( len ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( C17 --> ( SubFrom (C7 , ( intloc ( 0 ) )) ) ) ) ) <= ( ( D5 + 1 ) + 1 ) & ( ( D5 + 1 ) + 1 ) < ( ( len ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( C17 --> ( SubFrom (C7 , ( intloc ( 0 ) )) ) ) ) ) + ( len <% ( halt ( SCM+FSA ) ) %> ) )) implies ( D6 . ( ( D5 + 1 ) + 1 ) ) = ( <% ( halt ( SCM+FSA ) ) %> . ( ( ( D5 + 1 ) + 1 ) - ( len ( <% ( C7 := ( intloc ( 0 ) ) ) %> ^ ( C17 --> ( SubFrom (C7 , ( intloc ( 0 ) )) ) ) ) ) ) )) by AFINSQ_1:18;
L144: ( D6 . ( ( D5 + 1 ) + 1 ) ) = ( halt ( SCM+FSA ) ) by L143 , L93 , AFINSQ_1:34 , XREAL_1:29;
L145: ( CurInstr (C6 , ( Comput (C6 , C5 , ( ( D5 + 1 ) + 1 )) )) ) = ( C6 . ( IC ( Comput (C6 , C5 , ( ( D5 + 1 ) + 1 )) ) ) ) by L33 , PARTFUN1:def 6
.= ( C6 . ( ( D5 + 1 ) + 1 ) ) by L126
.= ( halt ( SCM+FSA ) ) by L144 , L101;
thus L146: thesis by L145 , EXTPRO_1:29;
end;
end;
registration
let C25 being Int-Location;
let C26 being Integer;
cluster ( C25 := C26 ) ->  parahalting;
correctness
proof
L148: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
let C27 being ( 0 ) -started (State of ( SCM+FSA ));
L149: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C27 by MEMSTR_0:29;
let C28 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L150: ( C25 := C26 ) c= C28;
L151: ( IC C27 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L149 , L148 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
thus L152: C28 halts_on C27 by L151 , L31 , L150;
end;
end;
theorem
L154: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B13 being (State of ( SCM+FSA )) holds (for B14 being  read-write Int-Location holds (for B15 being Integer holds (( ( IExec (( B14 := B15 ) , R2 , B13) ) . B14 ) = B15 & (for B16 being  read-write Int-Location holds (B16 <> B14 implies ( ( IExec (( B14 := B15 ) , R2 , B13) ) . B16 ) = ( B13 . B16 ))) & (for B17 being FinSeq-Location holds ( ( IExec (( B14 := B15 ) , R2 , B13) ) . B17 ) = ( B13 . B17 )))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C29 being (State of ( SCM+FSA ));
let C30 being  read-write Int-Location;
let C31 being Integer;
set D8 = ( C29 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) );
L155: ( D8 . ( intloc ( 0 ) ) ) = ( ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) . ( intloc ( 0 ) ) ) by FUNCT_4:13 , SCMFSA_M:10
.= 1 by SCMFSA_M:12;
reconsider D9 = D8 as ( 0 ) -started (State of ( SCM+FSA ));
L156: ( C30 := C31 ) c= ( R2 +* ( C30 := C31 ) ) by FUNCT_4:25;
thus L157: ( ( IExec (( C30 := C31 ) , R2 , C29) ) . C30 ) = ( ( Result (( R2 +* ( C30 := C31 ) ) , D9) ) . C30 )
.= C31 by L155 , L156 , SCMFSA_7:6;
thus L158:now
let C32 being  read-write Int-Location;
assume L159: C32 <> C30;
L160: (C32 <> ( intloc ( 0 ) ) & C32 <> ( IC ( SCM+FSA ) )) by SCMFSA_2:56;
L161: (not C32 in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) by L160 , SCMFSA_M:11 , TARSKI:def 2;
thus L162: ( ( IExec (( C30 := C31 ) , R2 , C29) ) . C32 ) = ( ( Result (( R2 +* ( C30 := C31 ) ) , D9) ) . C32 )
.= ( D9 . C32 ) by L155 , L156 , L159 , SCMFSA_7:6
.= ( C29 . C32 ) by L161 , FUNCT_4:11;
end;
let C33 being FinSeq-Location;
L163: (C33 <> ( intloc ( 0 ) ) & C33 <> ( IC ( SCM+FSA ) )) by SCMFSA_2:57 , SCMFSA_2:58;
L164: (not C33 in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) by L163 , SCMFSA_M:11 , TARSKI:def 2;
thus L165: ( ( IExec (( C30 := C31 ) , R2 , C29) ) . C33 ) = ( ( Result (( R2 +* ( C30 := C31 ) ) , D9) ) . C33 )
.= ( D9 . C33 ) by L155 , L156 , SCMFSA_7:6
.= ( C29 . C33 ) by L164 , FUNCT_4:11;
end;
L166: (for B18 , B19 , B20 , B21 being XFinSequence holds ( ( ( B18 ^ B19 ) ^ B20 ) ^ B21 ) = ( B18 ^ ( ( B19 ^ B20 ) ^ B21 ) ))
proof
let C34 , C35 , C36 , C37 being XFinSequence;
thus L167: ( ( ( C34 ^ C35 ) ^ C36 ) ^ C37 ) = ( ( C34 ^ ( C35 ^ C36 ) ) ^ C37 ) by AFINSQ_1:27
.= ( C34 ^ ( ( C35 ^ C36 ) ^ C37 ) ) by AFINSQ_1:27;
end;
L168: (for B22 being (Element of ( NAT )) holds (for B23 being B22 -started (State of ( SCM+FSA )) holds (for B24 being (Instruction-Sequence of ( SCM+FSA )) holds (for B25 being Int-Location holds (for B26 being Integer holds ((for B27 being (Element of ( NAT )) holds (B27 < ( len ( aSeq (B25 , B26) ) ) implies ( ( aSeq (B25 , B26) ) . B27 ) = ( B24 . ( B22 + B27 ) ))) implies (for B28 being (Element of ( NAT )) holds (B28 <= ( len ( aSeq (B25 , B26) ) ) implies ( IC ( Comput (B24 , B23 , B28) ) ) = ( B22 + B28 )))))))))
proof
let C38 being (Element of ( NAT ));
let C39 being C38 -started (State of ( SCM+FSA ));
let C40 being (Instruction-Sequence of ( SCM+FSA ));
L169: ( dom C40 ) = ( NAT ) by PARTFUN1:def 2;
L170: ( IC C39 ) = C38 by MEMSTR_0:def 12;
let C41 being Int-Location;
let C42 being Integer;
assume L171: (for B29 being (Element of ( NAT )) holds (B29 < ( len ( aSeq (C41 , C42) ) ) implies ( ( aSeq (C41 , C42) ) . B29 ) = ( C40 . ( C38 + B29 ) )));
L172: (for B30 being (Element of ( NAT )) holds (B30 in ( dom ( aSeq (C41 , C42) ) ) implies ( ( aSeq (C41 , C42) ) . B30 ) = ( C40 . ( C38 + B30 ) )))
proof
let C43 being (Element of ( NAT ));
assume L173: C43 in ( dom ( aSeq (C41 , C42) ) );
L174: C43 < ( len ( aSeq (C41 , C42) ) ) by L173 , AFINSQ_1:66;
thus L175: ( ( aSeq (C41 , C42) ) . C43 ) = ( C40 . ( C38 + C43 ) ) by L174 , L171;
end;
per cases ;
suppose L176: C42 > ( 0 );

reconsider D10 = C42 as (Element of ( NAT )) by L176 , INT_1:3;
consider C44 being (Element of ( NAT )) such that L177: ( C44 + 1 ) = D10 and L178: ( aSeq (C41 , D10) ) = ( <% ( C41 := ( intloc ( 0 ) ) ) %> ^ ( C44 --> ( AddTo (C41 , ( intloc ( 0 ) )) ) ) ) by L176 , SCMFSA_7:def 2;
defpred S3[ Nat ] means ($1 <= D10 implies ( IC ( Comput (C40 , C39 , $1) ) ) = ( C38 + $1 ));
L179: ( len ( aSeq (C41 , D10) ) ) = ( ( len <% ( C41 := ( intloc ( 0 ) ) ) %> ) + ( len ( C44 --> ( AddTo (C41 , ( intloc ( 0 ) )) ) ) ) ) by L178 , AFINSQ_1:17
.= ( 1 + ( len ( C44 --> ( AddTo (C41 , ( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:34
.= D10 by L177 , CARD_1:64;
L180: (for B31 being (Element of ( NAT )) holds (B31 <= ( len ( aSeq (C41 , D10) ) ) implies ( IC ( Comput (C40 , C39 , B31) ) ) = ( C38 + B31 )))
proof
L181:
now
let C45 being (Element of ( NAT ));
assume that
L182: 1 <= C45
and
L183: C45 < D10;
reconsider D11 = ( C45 - 1 ) as (Element of ( NAT )) by L182 , INT_1:5;
L184: C45 = ( D11 + 1 );
L185: D11 < C44 by L184 , L183 , L177 , XREAL_1:6;
L186: D11 in C44 by L185 , NAT_1:44;
L187: ( len ( C44 --> ( AddTo (C41 , ( intloc ( 0 ) )) ) ) ) = C44 by CARD_1:64;
L188: ( len <% ( C41 := ( intloc ( 0 ) ) ) %> ) = 1 by AFINSQ_1:33;
thus L189: ( ( aSeq (C41 , D10) ) . C45 ) = ( ( C44 --> ( AddTo (C41 , ( intloc ( 0 ) )) ) ) . ( C45 - 1 ) ) by L188 , L182 , L178 , L187 , L177 , L183 , AFINSQ_1:18
.= ( AddTo (C41 , ( intloc ( 0 ) )) ) by L186 , FUNCOP_1:7;
end;
L190: (for B32 being (Element of ( NAT )) holds (B32 < D10 implies B32 in ( dom ( aSeq (C41 , D10) ) ))) by L179 , NAT_1:44;
L191:
now
let C46 being (Element of ( NAT ));
assume that
L192: ( 0 ) < C46
and
L193: C46 < D10;
L194: ( ( 0 ) + 1 ) <= C46 by L192 , NAT_1:13;
thus L195: ( C40 . ( C38 + C46 ) ) = ( ( aSeq (C41 , D10) ) . C46 ) by L172 , L190 , L193
.= ( AddTo (C41 , ( intloc ( 0 ) )) ) by L181 , L194 , L193;
end;
L196: ( C40 . ( C38 + ( 0 ) ) ) = ( ( aSeq (C41 , D10) ) . ( 0 ) ) by L171 , L176 , L179
.= ( C41 := ( intloc ( 0 ) ) ) by L178 , AFINSQ_1:35;
L197:
now
let C47 being (Element of ( NAT ));
assume L198: C47 = ( 0 );
thus L199: ( Comput (C40 , C39 , C47) ) = C39 by L198 , EXTPRO_1:2;
thus L200: ( CurInstr (C40 , ( Comput (C40 , C39 , C47) )) ) = ( C40 . ( IC ( Comput (C40 , C39 , C47) ) ) ) by L169 , PARTFUN1:def 6
.= ( C41 := ( intloc ( 0 ) ) ) by L196 , L199 , MEMSTR_0:def 12;
thus L201: ( Comput (C40 , C39 , ( C47 + 1 )) ) = ( Following (C40 , ( Comput (C40 , C39 , C47) )) ) by EXTPRO_1:3
.= ( Exec (( C41 := ( intloc ( 0 ) ) ) , C39) ) by L199 , L170 , L196 , L169 , PARTFUN1:def 6;
end;
L202: (for B33 being (Element of ( NAT )) holds (S3[ B33 ] implies S3[ ( B33 + 1 ) ]))
proof
let C48 being (Element of ( NAT ));
assume L203: S3[ C48 ];
assume L204: ( C48 + 1 ) <= D10;
per cases ;
suppose L205: C48 = ( 0 );

thus L206: ( IC ( Comput (C40 , C39 , ( C48 + 1 )) ) ) = ( ( Exec (( C41 := ( intloc ( 0 ) ) ) , C39) ) . ( IC ( SCM+FSA ) ) ) by L205 , L197
.= ( ( succ C38 ) + C48 ) by L170 , L205 , SCMFSA_2:63
.= ( ( C38 + 1 ) + C48 ) by NAT_1:38
.= ( C38 + ( C48 + 1 ) );
end;
suppose L207: C48 > ( 0 );

L208: C48 < D10 by L204 , NAT_1:13;
L209: ( C48 + ( 0 ) ) <= ( C48 + 1 ) by XREAL_1:7;
L210: ( CurInstr (C40 , ( Comput (C40 , C39 , C48) )) ) = ( C40 . ( C38 + C48 ) ) by L203 , L204 , L209 , L169 , PARTFUN1:def 6 , XXREAL_0:2
.= ( AddTo (C41 , ( intloc ( 0 ) )) ) by L191 , L207 , L208;
L211: ( Comput (C40 , C39 , ( C48 + 1 )) ) = ( Following (C40 , ( Comput (C40 , C39 , C48) )) ) by EXTPRO_1:3
.= ( Exec (( AddTo (C41 , ( intloc ( 0 ) )) ) , ( Comput (C40 , C39 , C48) )) ) by L210;
thus L212: ( IC ( Comput (C40 , C39 , ( C48 + 1 )) ) ) = ( succ ( IC ( Comput (C40 , C39 , C48) ) ) ) by L211 , SCMFSA_2:64
.= ( ( C38 + C48 ) + 1 ) by L203 , L204 , L209 , NAT_1:38 , XXREAL_0:2
.= ( C38 + ( C48 + 1 ) );
end;
end;
let C49 being (Element of ( NAT ));
assume L214: C49 <= ( len ( aSeq (C41 , D10) ) );
L215: S3[ ( 0 ) ] by L170;
L216: (for B34 being (Element of ( NAT )) holds S3[ B34 ]) from NAT_1:sch 1(L215 , L202);
thus L217: thesis by L216 , L179 , L214;
end;
thus L218: thesis by L180;
end;
suppose L219: C42 <= ( 0 );

reconsider D12 = ( - C42 ) as (Element of ( NAT )) by L219 , INT_1:3;
defpred S4[ Nat ] means ($1 <= ( ( D12 + 1 ) + 1 ) implies ( IC ( Comput (C40 , C39 , $1) ) ) = ( C38 + $1 ));
consider C50 being (Element of ( NAT )) such that L220: ( C50 + C42 ) = 1 and L221: ( aSeq (C41 , C42) ) = ( <% ( C41 := ( intloc ( 0 ) ) ) %> ^ ( C50 --> ( SubFrom (C41 , ( intloc ( 0 ) )) ) ) ) by L219 , SCMFSA_7:def 2;
L222: ( len ( aSeq (C41 , C42) ) ) = ( ( len <% ( C41 := ( intloc ( 0 ) ) ) %> ) + ( len ( C50 --> ( SubFrom (C41 , ( intloc ( 0 ) )) ) ) ) ) by L221 , AFINSQ_1:17
.= ( 1 + ( len ( C50 --> ( SubFrom (C41 , ( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:34
.= ( ( D12 + 1 ) + 1 ) by L220 , CARD_1:64;
L223: (for B35 being (Element of ( NAT )) holds (B35 <= ( len ( aSeq (C41 , C42) ) ) implies ( IC ( Comput (C40 , C39 , B35) ) ) = ( C38 + B35 )))
proof
L224:
now
let C51 being (Element of ( NAT ));
assume that
L225: 1 <= C51
and
L226: C51 < ( ( D12 + 1 ) + 1 );
L227: ( C51 - 1 ) < ( ( ( D12 + 1 ) + 1 ) - 1 ) by L226 , XREAL_1:9;
reconsider D13 = ( C51 - 1 ) as (Element of ( NAT )) by L225 , INT_1:5;
L228: D13 in C50 by L220 , L227 , NAT_1:44;
L229: ( len ( C50 --> ( SubFrom (C41 , ( intloc ( 0 ) )) ) ) ) = C50 by CARD_1:64;
L230: ( len <% ( C41 := ( intloc ( 0 ) ) ) %> ) = 1 by AFINSQ_1:33;
thus L231: ( ( aSeq (C41 , C42) ) . C51 ) = ( ( C50 --> ( SubFrom (C41 , ( intloc ( 0 ) )) ) ) . ( C51 - 1 ) ) by L230 , L221 , L225 , L229 , L220 , L226 , AFINSQ_1:18
.= ( SubFrom (C41 , ( intloc ( 0 ) )) ) by L228 , FUNCOP_1:7;
end;
L232: (for B36 being (Element of ( NAT )) holds (B36 < ( ( D12 + 1 ) + 1 ) implies B36 in ( dom ( aSeq (C41 , C42) ) ))) by L222 , NAT_1:44;
L233:
now
let C52 being (Element of ( NAT ));
assume that
L234: ( 0 ) < C52
and
L235: C52 < ( ( D12 + 1 ) + 1 );
L236: ( ( 0 ) + 1 ) <= C52 by L234 , NAT_1:13;
thus L237: ( C40 . ( C38 + C52 ) ) = ( ( aSeq (C41 , C42) ) . C52 ) by L172 , L232 , L235
.= ( SubFrom (C41 , ( intloc ( 0 ) )) ) by L224 , L236 , L235;
end;
L238: ( C40 . ( C38 + ( 0 ) ) ) = ( ( aSeq (C41 , C42) ) . ( 0 ) ) by L171 , L222
.= ( C41 := ( intloc ( 0 ) ) ) by L221 , AFINSQ_1:35;
L239: (for B37 being (Element of ( NAT )) holds (B37 = ( 0 ) implies (( Comput (C40 , C39 , B37) ) = C39 & ( CurInstr (C40 , ( Comput (C40 , C39 , B37) )) ) = ( C41 := ( intloc ( 0 ) ) ) & ( Comput (C40 , C39 , ( B37 + 1 )) ) = ( Exec (( C41 := ( intloc ( 0 ) ) ) , C39) ))))
proof
let C53 being (Element of ( NAT ));
assume L240: C53 = ( 0 );
thus L241: ( Comput (C40 , C39 , C53) ) = C39 by L240 , EXTPRO_1:2;
thus L242: ( CurInstr (C40 , ( Comput (C40 , C39 , C53) )) ) = ( C40 . ( IC ( Comput (C40 , C39 , C53) ) ) ) by L169 , PARTFUN1:def 6
.= ( C41 := ( intloc ( 0 ) ) ) by L238 , L241 , MEMSTR_0:def 12;
thus L243: ( Comput (C40 , C39 , ( C53 + 1 )) ) = ( Following (C40 , ( Comput (C40 , C39 , C53) )) ) by EXTPRO_1:3
.= ( Exec (( C41 := ( intloc ( 0 ) ) ) , C39) ) by L241 , L170 , L238 , L169 , PARTFUN1:def 6;
end;
L244: (for B38 being (Element of ( NAT )) holds (S4[ B38 ] implies S4[ ( B38 + 1 ) ]))
proof
let C54 being (Element of ( NAT ));
assume L245: S4[ C54 ];
assume L246: ( C54 + 1 ) <= ( ( D12 + 1 ) + 1 );
per cases ;
suppose L247: C54 = ( 0 );

thus L248: ( IC ( Comput (C40 , C39 , ( C54 + 1 )) ) ) = ( ( Exec (( C41 := ( intloc ( 0 ) ) ) , C39) ) . ( IC ( SCM+FSA ) ) ) by L247 , L239
.= ( succ ( C38 + C54 ) ) by L170 , L247 , SCMFSA_2:63
.= ( ( C38 + C54 ) + 1 ) by NAT_1:38
.= ( C38 + ( C54 + 1 ) );
end;
suppose L249: C54 > ( 0 );

L250: C54 < ( ( D12 + 1 ) + 1 ) by L246 , NAT_1:13;
L251: ( C54 + ( 0 ) ) <= ( C54 + 1 ) by XREAL_1:7;
L252: ( CurInstr (C40 , ( Comput (C40 , C39 , C54) )) ) = ( C40 . ( C38 + C54 ) ) by L245 , L246 , L251 , L169 , PARTFUN1:def 6 , XXREAL_0:2
.= ( SubFrom (C41 , ( intloc ( 0 ) )) ) by L233 , L249 , L250;
L253: ( Comput (C40 , C39 , ( C54 + 1 )) ) = ( Following (C40 , ( Comput (C40 , C39 , C54) )) ) by EXTPRO_1:3
.= ( Exec (( SubFrom (C41 , ( intloc ( 0 ) )) ) , ( Comput (C40 , C39 , C54) )) ) by L252;
thus L254: ( IC ( Comput (C40 , C39 , ( C54 + 1 )) ) ) = ( succ ( IC ( Comput (C40 , C39 , C54) ) ) ) by L253 , SCMFSA_2:65
.= ( ( C38 + C54 ) + 1 ) by L245 , L246 , L251 , NAT_1:38 , XXREAL_0:2
.= ( C38 + ( C54 + 1 ) );
end;
end;
let C55 being (Element of ( NAT ));
assume L256: C55 <= ( len ( aSeq (C41 , C42) ) );
L257: S4[ ( 0 ) ] by L170;
L258: (for B39 being (Element of ( NAT )) holds S4[ B39 ]) from NAT_1:sch 1(L257 , L244);
thus L259: thesis by L258 , L222 , L256;
end;
thus L260: thesis by L223;
end;
end;
L262: (for B40 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B41 being (Instruction-Sequence of ( SCM+FSA )) holds (for B42 being Int-Location holds (for B43 being Integer holds (( aSeq (B42 , B43) ) c= B41 implies (for B44 being (Element of ( NAT )) holds (B44 <= ( len ( aSeq (B42 , B43) ) ) implies ( IC ( Comput (B41 , B40 , B44) ) ) = B44)))))))
proof
let C56 being ( 0 ) -started (State of ( SCM+FSA ));
let C57 being (Instruction-Sequence of ( SCM+FSA ));
let C58 being Int-Location;
let C59 being Integer;
assume L263: ( aSeq (C58 , C59) ) c= C57;
L264:
now
let C60 being (Element of ( NAT ));
assume L265: C60 < ( len ( aSeq (C58 , C59) ) );
L266: C60 in ( dom ( aSeq (C58 , C59) ) ) by L265 , NAT_1:44;
thus L267: ( C57 . ( ( 0 ) + C60 ) ) = ( ( aSeq (C58 , C59) ) . C60 ) by L266 , L263 , GRFUNC_1:2;
end;
let C61 being (Element of ( NAT ));
assume L268: C61 <= ( len ( aSeq (C58 , C59) ) );
L269: ( IC ( Comput (C57 , C56 , C61) ) ) = ( ( 0 ) + C61 ) by L268 , L264 , L168;
thus L270: thesis by L269;
end;
L271: (for B45 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B46 being (Instruction-Sequence of ( SCM+FSA )) holds (for B47 being FinSeq-Location holds (for B48 being (FinSequence of ( INT )) holds (( B47 := B48 ) c= B46 implies B46 halts_on B45)))))
proof
set D14 = ( intloc 2 );
set D15 = ( intloc 1 );
let C62 being ( 0 ) -started (State of ( SCM+FSA ));
let C63 being (Instruction-Sequence of ( SCM+FSA ));
L272: ( dom C63 ) = ( NAT ) by PARTFUN1:def 2;
set D16 = (the InstructionsF of ( SCM+FSA ));
let C64 being FinSeq-Location;
let C65 being (FinSequence of ( INT ));
set D17 = ( ( ( ( aSeq (D15 , ( len C65 )) ) ^ <% ( C64 :=<0,...,0> D15 ) %> ) ^ ( aSeq (C64 , C65) ) ) ^ <% ( halt ( SCM+FSA ) ) %> );
set D18 = ( ( aSeq (D15 , ( len C65 )) ) ^ <% ( C64 :=<0,...,0> D15 ) %> );
assume L273: ( C64 := C65 ) c= C63;
set D19 = ( ( ( ( aSeq (D15 , ( len C65 )) ) ^ <% ( C64 :=<0,...,0> D15 ) %> ) ^ ( aSeq (C64 , C65) ) ) ^ <% ( halt ( SCM+FSA ) ) %> );
L274:
now
let C66 , C67 being (Element of ( NAT ));
assume L275: C66 < ( len D19 );
L276: C66 in ( dom D19 ) by L275 , NAT_1:44;
thus L277: ( C63 . C66 ) = ( D19 . C66 ) by L273 , L276 , GRFUNC_1:2;
end;
consider C68 being (XFinSequence of ( D16 ^omega )) such that L278: (( len C68 ) = ( len C65 ) & (for B49 being (Element of ( NAT )) holds (B49 < ( len C68 ) implies (ex B50 being Integer st (B50 = ( C65 . ( B49 + 1 ) ) & ( C68 . B49 ) = ( ( ( aSeq (D15 , ( B49 + 1 )) ) ^ ( aSeq (D14 , B50) ) ) ^ <% ( (C64 , D15) := D14 ) %> )))))) and L279: ( aSeq (C64 , C65) ) = ( FlattenSeq C68 ) by SCMFSA_7:def 3;
L280: ( len D19 ) = ( ( len ( D18 ^ ( FlattenSeq C68 ) ) ) + 1 ) by L279 , AFINSQ_1:75;
L281: ( len ( D18 ^ ( FlattenSeq C68 ) ) ) < ( len D19 ) by L280 , NAT_1:13;
defpred S5[ XFinSequence ] means ($1 c= C68 implies (ex B51 being (XFinSequence of ( D16 ^omega )) st (B51 = $1 & (for B52 being (Element of ( NAT )) holds (B52 <= ( len ( D18 ^ ( FlattenSeq B51 ) ) ) implies ( IC ( Comput (C63 , C62 , B52) ) ) = B52)))));
L282: (for B53 being XFinSequence holds (for B54 being set holds (S5[ B53 ] implies S5[ ( B53 ^ <% B54 %> ) ])))
proof
let C69 being XFinSequence;
let C70 being set;
assume L283: S5[ C69 ];
set D20 = ( len C69 );
L284: ( len <% C70 %> ) = 1 by AFINSQ_1:34;
L285: ( len ( C69 ^ <% C70 %> ) ) = ( D20 + 1 ) by L284 , AFINSQ_1:17;
L286: D20 < ( len ( C69 ^ <% C70 %> ) ) by L285 , XREAL_1:29;
L287: D20 in ( dom ( C69 ^ <% C70 %> ) ) by L286 , NAT_1:44;
assume L288: ( C69 ^ <% C70 %> ) c= C68;
L289: ( dom ( C69 ^ <% C70 %> ) ) c= ( dom C68 ) by L288 , GRFUNC_1:2;
L290: D20 < ( len C68 ) by L289 , L287 , NAT_1:44;
consider C71 being Integer such that L291: C71 = ( C65 . ( D20 + 1 ) ) and L292: ( C68 . D20 ) = ( ( ( aSeq (D15 , ( D20 + 1 )) ) ^ ( aSeq (D14 , C71) ) ) ^ <% ( (C64 , D15) := D14 ) %> ) by L290 , L278;
L293: C69 c= ( C69 ^ <% C70 %> ) by AFINSQ_1:74;
consider C72 being (XFinSequence of ( D16 ^omega )) such that L294: C72 = C69 and L295: (for B55 being (Element of ( NAT )) holds (B55 <= ( len ( D18 ^ ( FlattenSeq C72 ) ) ) implies ( IC ( Comput (C63 , C62 , B55) ) ) = B55)) by L293 , L283 , L288 , XBOOLE_1:1;
set D21 = ( len ( ( D18 ^ ( FlattenSeq C72 ) ) ^ ( aSeq (D15 , ( D20 + 1 )) ) ) );
set D22 = ( len ( D18 ^ ( FlattenSeq C72 ) ) );
L296: ( IC ( Comput (C63 , C62 , D22) ) ) = D22 by L295;
reconsider D23 = ( Comput (C63 , C62 , D22) ) as D22 -started (State of ( SCM+FSA )) by L296 , MEMSTR_0:def 12;
L297: C70 = ( ( C69 ^ <% C70 %> ) . D20 ) by AFINSQ_1:36
.= ( C68 . D20 ) by L288 , L287 , GRFUNC_1:2;
L298: C70 in ( D16 ^omega ) by L297 , L287 , L289 , FUNCT_1:102;
reconsider D24 = ( C72 ^ <% C70 %> ) as (XFinSequence of ( D16 ^omega )) by L298;
take D24;
thus L299: D24 = ( C69 ^ <% C70 %> ) by L294;
reconsider D25 = C70 as (Element of ( D16 ^omega )) by L287 , L289 , L297 , FUNCT_1:102;
L300: ( FlattenSeq D24 ) = ( ( FlattenSeq C72 ) ^ ( FlattenSeq <% D25 %> ) ) by AFINSQ_2:75
.= ( ( FlattenSeq C72 ) ^ D25 ) by AFINSQ_2:73;
set D26 = ( Comput (C63 , C62 , D21) );
L301: D25 = ( ( aSeq (D15 , ( D20 + 1 )) ) ^ ( ( aSeq (D14 , C71) ) ^ <% ( (C64 , D15) := D14 ) %> ) ) by L292 , L297 , AFINSQ_1:27;
L302: ( ( len D18 ) + ( len ( FlattenSeq D24 ) ) ) = ( ( len D18 ) + ( len ( ( ( FlattenSeq C72 ) ^ ( aSeq (D15 , ( D20 + 1 )) ) ) ^ ( ( aSeq (D14 , C71) ) ^ <% ( (C64 , D15) := D14 ) %> ) ) ) ) by L301 , L300 , AFINSQ_1:27
.= ( len ( D18 ^ ( ( ( FlattenSeq C72 ) ^ ( aSeq (D15 , ( D20 + 1 )) ) ) ^ ( ( aSeq (D14 , C71) ) ^ <% ( (C64 , D15) := D14 ) %> ) ) ) ) by AFINSQ_1:17
.= ( len ( ( ( D18 ^ ( FlattenSeq C72 ) ) ^ ( aSeq (D15 , ( D20 + 1 )) ) ) ^ ( ( aSeq (D14 , C71) ) ^ <% ( (C64 , D15) := D14 ) %> ) ) ) by L166
.= ( D21 + ( len ( ( aSeq (D14 , C71) ) ^ <% ( (C64 , D15) := D14 ) %> ) ) ) by AFINSQ_1:17
.= ( D21 + ( ( len ( aSeq (D14 , C71) ) ) + ( len <% ( (C64 , D15) := D14 ) %> ) ) ) by AFINSQ_1:17
.= ( D21 + ( ( len ( aSeq (D14 , C71) ) ) + 1 ) ) by AFINSQ_1:34
.= ( ( D21 + ( len ( aSeq (D14 , C71) ) ) ) + 1 );
L303: ( len ( D18 ^ ( FlattenSeq D24 ) ) ) = ( ( D21 + ( len ( aSeq (D14 , C71) ) ) ) + 1 ) by L302 , AFINSQ_1:17;
L304: ( len ( D18 ^ ( FlattenSeq D24 ) ) ) > ( D21 + ( len ( aSeq (D14 , C71) ) ) ) by L303 , NAT_1:13;
L305: ( FlattenSeq D24 ) c= ( FlattenSeq C68 ) by L288 , L294 , AFINSQ_2:82;
L306:
now
let C73 being XFinSequence;
assume L307: C73 c= D25;
L308: ( ( FlattenSeq C72 ) ^ C73 ) c= ( ( FlattenSeq C72 ) ^ D25 ) by L307 , AFINSQ_2:81;
L309: ( ( FlattenSeq C72 ) ^ C73 ) c= ( FlattenSeq C68 ) by L308 , L305 , L300 , XBOOLE_1:1;
L310: ( D18 ^ ( ( FlattenSeq C72 ) ^ C73 ) ) c= ( D18 ^ ( FlattenSeq C68 ) ) by L309 , AFINSQ_2:81;
L311: ( ( D18 ^ ( FlattenSeq C72 ) ) ^ C73 ) c= ( D18 ^ ( FlattenSeq C68 ) ) by L310 , AFINSQ_1:27;
L312: ( D18 ^ ( FlattenSeq C68 ) ) c= D19 by L279 , AFINSQ_1:74;
thus L313: ( ( D18 ^ ( FlattenSeq C72 ) ) ^ C73 ) c= D19 by L312 , L311 , XBOOLE_1:1;
end;
L314: (for B56 being (Element of ( NAT )) holds (B56 < ( len ( aSeq (D15 , ( D20 + 1 )) ) ) implies ( ( aSeq (D15 , ( D20 + 1 )) ) . B56 ) = ( C63 . ( D22 + B56 ) )))
proof
let C74 being (Element of ( NAT ));
assume L315: C74 < ( len ( aSeq (D15 , ( D20 + 1 )) ) );
L316: C74 in ( dom ( aSeq (D15 , ( D20 + 1 )) ) ) by L315 , AFINSQ_1:66;
L317: ( D22 + C74 ) in ( dom ( ( D18 ^ ( FlattenSeq C72 ) ) ^ ( aSeq (D15 , ( D20 + 1 )) ) ) ) by L316 , AFINSQ_1:23;
L318: ( ( D18 ^ ( FlattenSeq C72 ) ) ^ ( aSeq (D15 , ( D20 + 1 )) ) ) c= D19 by L301 , L306 , AFINSQ_1:74;
L319: ( dom ( ( D18 ^ ( FlattenSeq C72 ) ) ^ ( aSeq (D15 , ( D20 + 1 )) ) ) ) c= ( dom D19 ) by L318 , GRFUNC_1:2;
thus L320: ( ( aSeq (D15 , ( D20 + 1 )) ) . C74 ) = ( ( ( D18 ^ ( FlattenSeq C72 ) ) ^ ( aSeq (D15 , ( D20 + 1 )) ) ) . ( D22 + C74 ) ) by L316 , AFINSQ_1:def 3
.= ( D19 . ( D22 + C74 ) ) by L318 , L317 , GRFUNC_1:2
.= ( C63 . ( D22 + C74 ) ) by L273 , L319 , L317 , GRFUNC_1:2;
end;
set D27 = ( len ( ( ( D18 ^ ( FlattenSeq C72 ) ) ^ ( aSeq (D15 , ( D20 + 1 )) ) ) ^ ( aSeq (D14 , C71) ) ) );
L321: D21 = ( D22 + ( len ( aSeq (D15 , ( D20 + 1 )) ) ) ) by AFINSQ_1:17;
L322: ( D18 ^ ( FlattenSeq D24 ) ) = ( ( D18 ^ ( FlattenSeq C72 ) ) ^ D25 ) by L300 , AFINSQ_1:27;
L323: ( len ( D18 ^ ( FlattenSeq D24 ) ) ) <= ( len D19 ) by L322 , L306 , NAT_1:43;
L324: ( D21 + ( len ( aSeq (D14 , C71) ) ) ) < ( len D19 ) by L323 , L303 , NAT_1:13;
L325: D27 = ( D21 + ( len ( aSeq (D14 , C71) ) ) ) by AFINSQ_1:17;
L326: ( Comput (C63 , C62 , D21) ) = ( Comput (C63 , D23 , ( len ( aSeq (D15 , ( D20 + 1 )) ) )) ) by L321 , EXTPRO_1:4;
L327: ( IC ( Comput (C63 , C62 , D21) ) ) = D21 by L321 , L326 , L314 , L168;
reconsider D28 = D26 as D21 -started (State of ( SCM+FSA )) by L327 , MEMSTR_0:def 12;
L328: (for B57 being (Element of ( NAT )) holds (B57 < ( len ( aSeq (D14 , C71) ) ) implies ( ( aSeq (D14 , C71) ) . B57 ) = ( C63 . ( D21 + B57 ) )))
proof
let C75 being (Element of ( NAT ));
assume L329: C75 < ( len ( aSeq (D14 , C71) ) );
L330: C75 in ( dom ( aSeq (D14 , C71) ) ) by L329 , AFINSQ_1:66;
L331: ( D21 + C75 ) in ( dom ( ( ( D18 ^ ( FlattenSeq C72 ) ) ^ ( aSeq (D15 , ( D20 + 1 )) ) ) ^ ( aSeq (D14 , C71) ) ) ) by L330 , AFINSQ_1:23;
L332: ( ( D18 ^ ( FlattenSeq C72 ) ) ^ ( ( aSeq (D15 , ( D20 + 1 )) ) ^ ( aSeq (D14 , C71) ) ) ) c= D19 by L292 , L297 , L306 , AFINSQ_1:74;
L333: ( ( ( D18 ^ ( FlattenSeq C72 ) ) ^ ( aSeq (D15 , ( D20 + 1 )) ) ) ^ ( aSeq (D14 , C71) ) ) c= D19 by L332 , AFINSQ_1:27;
L334: ( dom ( ( ( D18 ^ ( FlattenSeq C72 ) ) ^ ( aSeq (D15 , ( D20 + 1 )) ) ) ^ ( aSeq (D14 , C71) ) ) ) c= ( dom D19 ) by L333 , GRFUNC_1:2;
thus L335: ( ( aSeq (D14 , C71) ) . C75 ) = ( ( ( ( D18 ^ ( FlattenSeq C72 ) ) ^ ( aSeq (D15 , ( D20 + 1 )) ) ) ^ ( aSeq (D14 , C71) ) ) . ( D21 + C75 ) ) by L330 , AFINSQ_1:def 3
.= ( D19 . ( D21 + C75 ) ) by L331 , L333 , GRFUNC_1:2
.= ( C63 . ( D21 + C75 ) ) by L273 , L334 , L331 , GRFUNC_1:2;
end;
L336:
now
let C76 being (Element of ( NAT ));
assume L337: C76 <= ( len ( aSeq (D14 , C71) ) );
thus L338: ( D21 + C76 ) = ( IC ( Comput (C63 , D28 , C76) ) ) by L337 , L328 , L168
.= ( IC ( Comput (C63 , C62 , ( D21 + C76 )) ) ) by EXTPRO_1:4;
end;
L339:
now
let C77 being (Element of ( NAT ));
assume L340: C77 <= ( len ( aSeq (D15 , ( D20 + 1 )) ) );
thus L341: ( D22 + C77 ) = ( IC ( Comput (C63 , D23 , C77) ) ) by L340 , L314 , L168
.= ( IC ( Comput (C63 , C62 , ( D22 + C77 )) ) ) by EXTPRO_1:4;
end;
L342: (for B58 being (Element of ( NAT )) holds (B58 < ( len ( D18 ^ ( FlattenSeq D24 ) ) ) implies ( IC ( Comput (C63 , C62 , B58) ) ) = B58))
proof
let C78 being (Element of ( NAT ));
assume L343: C78 < ( len ( D18 ^ ( FlattenSeq D24 ) ) );
L344:
now
L345: C78 < ( ( len D18 ) + ( len ( FlattenSeq D24 ) ) ) by L343 , AFINSQ_1:17;
assume L346: (not C78 <= D22);
assume L347: (not (( D22 + 1 ) <= C78 & C78 <= D21));
thus L348: (( D21 + 1 ) <= C78 & C78 <= ( D21 + ( len ( aSeq (D14 , C71) ) ) )) by L347 , L302 , L346 , L345 , NAT_1:13;
end;
per cases  by L344;
suppose L349: C78 <= ( len ( D18 ^ ( FlattenSeq C72 ) ) );

thus L350: thesis by L349 , L295;
end;
suppose L351: (( D22 + 1 ) <= C78 & C78 <= D21);

L352: ( ( D22 + 1 ) - D22 ) <= ( C78 - D22 ) by L351 , XREAL_1:9;
reconsider D29 = ( C78 - D22 ) as (Element of ( NAT )) by L352 , INT_1:3;
L353: ( C78 - D22 ) <= ( D21 - D22 ) by L351 , XREAL_1:9;
thus L354: C78 = ( IC ( Comput (C63 , C62 , ( D22 + D29 )) ) ) by L353 , L321 , L339
.= ( IC ( Comput (C63 , C62 , C78) ) );
thus L355: thesis;
end;
suppose L356: (( D21 + 1 ) <= C78 & C78 <= ( D21 + ( len ( aSeq (D14 , C71) ) ) ));

L357: ( ( D21 + 1 ) - D21 ) <= ( C78 - D21 ) by L356 , XREAL_1:9;
reconsider D30 = ( C78 - D21 ) as (Element of ( NAT )) by L357 , INT_1:3;
L358: ( C78 - D21 ) <= ( ( D21 + ( len ( aSeq (D14 , C71) ) ) ) - D21 ) by L356 , XREAL_1:9;
thus L359: C78 = ( IC ( Comput (C63 , C62 , ( D21 + D30 )) ) ) by L358 , L336
.= ( IC ( Comput (C63 , C62 , C78) ) );
end;
end;
L361: ( ( D18 ^ ( FlattenSeq C72 ) ) ^ D25 ) c= D19 by L306;
consider C79 being (XFinSequence of D16) such that L362: ( ( ( D18 ^ ( FlattenSeq C72 ) ) ^ D25 ) ^ C79 ) = D19 by L361 , AFINSQ_2:80;
L363: ( len ( D18 ^ ( FlattenSeq D24 ) ) ) = ( ( D21 + ( len ( aSeq (D14 , C71) ) ) ) + 1 ) by L302 , AFINSQ_1:17;
L364: ( len ( D18 ^ ( FlattenSeq D24 ) ) ) > ( D21 + ( len ( aSeq (D14 , C71) ) ) ) by L363 , NAT_1:13;
L365: D27 in ( dom ( ( D18 ^ ( FlattenSeq C72 ) ) ^ D25 ) ) by L364 , L322 , L325 , AFINSQ_1:66;
L366: ( dom <% ( (C64 , D15) := D14 ) %> ) = 1 by AFINSQ_1:33;
L367: ( 0 ) in ( dom <% ( (C64 , D15) := D14 ) %> ) by L366 , CARD_1:49 , TARSKI:def 1;
L368: ( len <% ( (C64 , D15) := D14 ) %> ) = 1 by AFINSQ_1:34;
L369: ( len ( ( ( aSeq (D15 , ( D20 + 1 )) ) ^ ( aSeq (D14 , C71) ) ) ^ <% ( (C64 , D15) := D14 ) %> ) ) = ( ( len ( ( aSeq (D15 , ( D20 + 1 )) ) ^ ( aSeq (D14 , C71) ) ) ) + 1 ) by L368 , AFINSQ_1:17;
L370: ( len ( ( aSeq (D15 , ( D20 + 1 )) ) ^ ( aSeq (D14 , C71) ) ) ) < ( len ( ( ( aSeq (D15 , ( D20 + 1 )) ) ^ ( aSeq (D14 , C71) ) ) ^ <% ( (C64 , D15) := D14 ) %> ) ) by L369 , XREAL_1:29;
L371: ( len ( ( aSeq (D15 , ( D20 + 1 )) ) ^ ( aSeq (D14 , C71) ) ) ) in ( dom ( ( ( aSeq (D15 , ( D20 + 1 )) ) ^ ( aSeq (D14 , C71) ) ) ^ <% ( (C64 , D15) := D14 ) %> ) ) by L370 , AFINSQ_1:66;
L372: D27 = ( ( D22 + ( len ( aSeq (D15 , ( D20 + 1 )) ) ) ) + ( len ( aSeq (D14 , C71) ) ) ) by L321 , AFINSQ_1:17;
L373: ( C63 /. ( IC ( Comput (C63 , C62 , D27) ) ) ) = ( C63 . ( IC ( Comput (C63 , C62 , D27) ) ) ) by L272 , PARTFUN1:def 6;
L374: ( CurInstr (C63 , ( Comput (C63 , C62 , D27) )) ) = ( C63 . D27 ) by L325 , L342 , L373 , L364
.= ( D19 . D27 ) by L274 , L325 , L324
.= ( ( ( D18 ^ ( FlattenSeq C72 ) ) ^ D25 ) . ( D22 + ( ( len ( aSeq (D15 , ( D20 + 1 )) ) ) + ( len ( aSeq (D14 , C71) ) ) ) ) ) by L372 , L365 , L362 , AFINSQ_1:def 3
.= ( ( ( D18 ^ ( FlattenSeq C72 ) ) ^ D25 ) . ( D22 + ( len ( ( aSeq (D15 , ( D20 + 1 )) ) ^ ( aSeq (D14 , C71) ) ) ) ) ) by AFINSQ_1:17;
L375: ( CurInstr (C63 , ( Comput (C63 , C62 , D27) )) ) = ( ( ( ( aSeq (D15 , ( D20 + 1 )) ) ^ ( aSeq (D14 , C71) ) ) ^ <% ( (C64 , D15) := D14 ) %> ) . ( ( len ( ( aSeq (D15 , ( D20 + 1 )) ) ^ ( aSeq (D14 , C71) ) ) ) + ( 0 ) ) ) by L374 , L371 , L292 , L297 , AFINSQ_1:def 3
.= ( <% ( (C64 , D15) := D14 ) %> . ( 0 ) ) by L367 , AFINSQ_1:def 3
.= ( (C64 , D15) := D14 ) by AFINSQ_1:34;
L376: ( Comput (C63 , C62 , ( D27 + 1 )) ) = ( Following (C63 , ( Comput (C63 , C62 , D27) )) ) by EXTPRO_1:3
.= ( Exec (( (C64 , D15) := D14 ) , ( Comput (C63 , C62 , D27) )) ) by L375;
L377: ( IC ( Comput (C63 , C62 , ( len ( D18 ^ ( FlattenSeq D24 ) ) )) ) ) = ( ( Exec (( (C64 , D15) := D14 ) , ( Comput (C63 , C62 , D27) )) ) . ( IC ( SCM+FSA ) ) ) by L376 , L303 , AFINSQ_1:17
.= ( succ ( IC ( Comput (C63 , C62 , D27) ) ) ) by SCMFSA_2:73
.= ( succ D27 ) by L325 , L342 , L304;
thus L378: (for B59 being (Element of ( NAT )) holds (B59 <= ( len ( D18 ^ ( FlattenSeq D24 ) ) ) implies ( IC ( Comput (C63 , C62 , B59) ) ) = B59))
proof
let C80 being (Element of ( NAT ));
assume L379: C80 <= ( len ( D18 ^ ( FlattenSeq D24 ) ) );
per cases  by L379 , XXREAL_0:1;
suppose L380: C80 < ( len ( D18 ^ ( FlattenSeq D24 ) ) );

thus L381: thesis by L380 , L342;
end;
suppose L382: C80 = ( len ( D18 ^ ( FlattenSeq D24 ) ) );

thus L383: thesis by L382 , L325 , L303 , L377 , NAT_1:38;
end;
end;

end;
set D31 = ( len ( aSeq (D15 , ( len C65 )) ) );
L379: ( len D18 ) = ( D31 + 1 ) by AFINSQ_1:75;
L380: D19 = ( ( ( aSeq (D15 , ( len C65 )) ) ^ <% ( C64 :=<0,...,0> D15 ) %> ) ^ ( ( aSeq (C64 , C65) ) ^ <% ( halt ( SCM+FSA ) ) %> ) ) by AFINSQ_1:27
.= ( ( aSeq (D15 , ( len C65 )) ) ^ ( <% ( C64 :=<0,...,0> D15 ) %> ^ ( ( aSeq (C64 , C65) ) ^ <% ( halt ( SCM+FSA ) ) %> ) ) ) by AFINSQ_1:27;
L381: ( aSeq (D15 , ( len C65 )) ) c= ( C64 := C65 ) by L380 , AFINSQ_1:74;
L382: S5[ ( {} ) ]
proof
assume L383: ( {} ) c= C68;
take ( <%> ( D16 ^omega ) );
thus L384: ( <%> ( D16 ^omega ) ) = ( {} );
L385: D19 = ( ( ( aSeq (D15 , ( len C65 )) ) ^ <% ( C64 :=<0,...,0> D15 ) %> ) ^ ( ( aSeq (C64 , C65) ) ^ <% ( halt ( SCM+FSA ) ) %> ) ) by AFINSQ_1:27;
L386: ( len D19 ) = ( ( len D18 ) + ( len ( ( aSeq (C64 , C65) ) ^ <% ( halt ( SCM+FSA ) ) %> ) ) ) by L385 , AFINSQ_1:17;
L387: ( len D18 ) <= ( len D19 ) by L386 , NAT_1:11;
L388: D31 < ( len D19 ) by L387 , L379 , NAT_1:13;
L389:
now
let C81 being (Element of ( NAT ));
assume L390: C81 < ( len D18 );
L391: C81 <= ( len ( aSeq (D15 , ( len C65 )) ) ) by L390 , L379 , NAT_1:13;
thus L392: ( IC ( Comput (C63 , C62 , C81) ) ) = C81 by L391 , L273 , L381 , L262 , XBOOLE_1:1;
end;
L393: D31 < ( len D18 ) by L379 , NAT_1:13;
L394: D31 in ( dom D18 ) by L393 , AFINSQ_1:66;
L395: ( IC ( Comput (C63 , C62 , D31) ) ) = D31 by L389 , L393;
L396: ( CurInstr (C63 , ( Comput (C63 , C62 , D31) )) ) = ( C63 . D31 ) by L395 , L272 , PARTFUN1:def 6
.= ( D19 . D31 ) by L274 , L388
.= ( D18 . D31 ) by L385 , L394 , AFINSQ_1:def 3
.= ( C64 :=<0,...,0> D15 ) by AFINSQ_1:36;
L397: ( Comput (C63 , C62 , ( len D18 )) ) = ( Following (C63 , ( Comput (C63 , C62 , D31) )) ) by L379 , EXTPRO_1:3
.= ( Exec (( C64 :=<0,...,0> D15 ) , ( Comput (C63 , C62 , D31) )) ) by L396;
L398: ( IC ( Comput (C63 , C62 , ( len D18 )) ) ) = ( succ ( IC ( Comput (C63 , C62 , D31) ) ) ) by L397 , SCMFSA_2:75
.= ( len D18 ) by L379 , L395 , NAT_1:38;
L399:
now
let C82 being (Element of ( NAT ));
assume L400: C82 <= ( len D18 );
L401: (C82 < ( len D18 ) or C82 = ( len D18 )) by L400 , XXREAL_0:1;
thus L402: ( IC ( Comput (C63 , C62 , C82) ) ) = C82 by L401 , L389 , L398;
end;
L403: ( D18 ^ ( FlattenSeq ( <%> ( D16 ^omega ) ) ) ) = ( D18 ^ ( <%> D16 ) ) by AFINSQ_2:74
.= ( D18 ^ ( {} ) )
.= D18;
thus L404: thesis by L403 , L399;
end;
L405: (for B60 being XFinSequence holds S5[ B60 ]) from AFINSQ_1:sch 3(L382 , L282);
L406: (ex B61 being (XFinSequence of ( D16 ^omega )) st (B61 = C68 & (for B62 being (Element of ( NAT )) holds (B62 <= ( len ( D18 ^ ( FlattenSeq B61 ) ) ) implies ( IC ( Comput (C63 , C62 , B62) ) ) = B62)))) by L405;
L407: ( IC ( Comput (C63 , C62 , ( len ( D18 ^ ( FlattenSeq C68 ) ) )) ) ) = ( len ( D18 ^ ( FlattenSeq C68 ) ) ) by L406;
L408: ( CurInstr (C63 , ( Comput (C63 , C62 , ( len ( D18 ^ ( FlattenSeq C68 ) ) )) )) ) = ( C63 . ( len ( D18 ^ ( FlattenSeq C68 ) ) ) ) by L407 , L272 , PARTFUN1:def 6
.= ( D19 . ( len ( D18 ^ ( FlattenSeq C68 ) ) ) ) by L274 , L281
.= ( halt ( SCM+FSA ) ) by L279 , AFINSQ_1:36;
thus L409: thesis by L408 , EXTPRO_1:29;
end;
registration
let C83 being FinSeq-Location;
let C84 being (FinSequence of ( INT ));
cluster ( C83 := C84 ) ->  initial non  empty ( NAT ) -defined (the InstructionsF of ( SCM+FSA )) -valued;
coherence;
end;
registration
let C85 being FinSeq-Location;
let C86 being (FinSequence of ( INT ));
cluster ( C85 := C86 ) ->  parahalting;
correctness
proof
let C87 being ( 0 ) -started (State of ( SCM+FSA ));
let C88 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L411: ( C85 := C86 ) c= C88;
thus L412: C88 halts_on C87 by L271 , L411;
end;
end;
theorem
L414: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B63 being (State of ( SCM+FSA )) holds (for B64 being FinSeq-Location holds (for B65 being (FinSequence of ( INT )) holds (( ( IExec (( B64 := B65 ) , R2 , B63) ) . B64 ) = B65 & (for B66 being  read-write Int-Location holds ((B66 <> ( intloc 1 ) & B66 <> ( intloc 2 )) implies ( ( IExec (( B64 := B65 ) , R2 , B63) ) . B66 ) = ( B63 . B66 ))) & (for B67 being FinSeq-Location holds (B67 <> B64 implies ( ( IExec (( B64 := B65 ) , R2 , B63) ) . B67 ) = ( B63 . B67 ))))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C89 being (State of ( SCM+FSA ));
let C90 being FinSeq-Location;
let C91 being (FinSequence of ( INT ));
L415: ( ( C89 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) . ( intloc ( 0 ) ) ) = ( ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) . ( intloc ( 0 ) ) ) by FUNCT_4:13 , SCMFSA_M:10
.= 1 by SCMFSA_M:12;
reconsider D32 = ( C89 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) as ( 0 ) -started (State of ( SCM+FSA ));
L416: ( C90 := C91 ) c= ( R2 +* ( C90 := C91 ) ) by FUNCT_4:25;
thus L417: ( ( IExec (( C90 := C91 ) , R2 , C89) ) . C90 ) = ( ( Result (( R2 +* ( C90 := C91 ) ) , D32) ) . C90 )
.= C91 by L415 , L416 , SCMFSA_7:7;
thus L418:now
let C92 being  read-write Int-Location;
L419: (C92 <> ( intloc ( 0 ) ) & C92 <> ( IC ( SCM+FSA ) )) by SCMFSA_2:56;
L420: (not C92 in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) by L419 , SCMFSA_M:11 , TARSKI:def 2;
assume L421: (C92 <> ( intloc 1 ) & C92 <> ( intloc 2 ));
thus L422: ( ( IExec (( C90 := C91 ) , R2 , C89) ) . C92 ) = ( ( Result (( R2 +* ( C90 := C91 ) ) , ( C89 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) . C92 )
.= ( D32 . C92 ) by L415 , L416 , L421 , SCMFSA_7:7
.= ( C89 . C92 ) by L420 , FUNCT_4:11;
end;
let C93 being FinSeq-Location;
assume L423: C93 <> C90;
L424: (C93 <> ( intloc ( 0 ) ) & C93 <> ( IC ( SCM+FSA ) )) by SCMFSA_2:57 , SCMFSA_2:58;
L425: (not C93 in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) by L424 , SCMFSA_M:11 , TARSKI:def 2;
thus L426: ( ( IExec (( C90 := C91 ) , R2 , C89) ) . C93 ) = ( ( Result (( R2 +* ( C90 := C91 ) ) , ( C89 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) . C93 )
.= ( D32 . C93 ) by L415 , L416 , L423 , SCMFSA_7:7
.= ( C89 . C93 ) by L425 , FUNCT_4:11;
end;
definition
let C94 being (Instruction of ( SCM+FSA ));
let C95 being Int-Location;
pred C94 refer C95
means
(not (for B68 being Int-Location holds (for B69 being (Element of ( NAT )) holds (for B70 being FinSeq-Location holds (( B68 := C95 ) <> C94 & ( AddTo (B68 , C95) ) <> C94 & ( SubFrom (B68 , C95) ) <> C94 & ( MultBy (B68 , C95) ) <> C94 & ( Divide (B68 , C95) ) <> C94 & ( Divide (C95 , B68) ) <> C94 & ( C95 =0_goto B69 ) <> C94 & ( C95 >0_goto B69 ) <> C94 & ( B68 := (B70 , C95) ) <> C94 & ( (B70 , B68) := C95 ) <> C94 & ( (B70 , C95) := B68 ) <> C94 & ( B70 :=<0,...,0> C95 ) <> C94)))))
;end;
definition
let C96 being (preProgram of ( SCM+FSA ));
let C97 being Int-Location;
pred C96 refer C97
means
(ex B71 being (Instruction of ( SCM+FSA )) st (B71 in ( rng C96 ) & B71 refer C97))
;end;
definition
let C98 being (Instruction of ( SCM+FSA ));
let C99 being Int-Location;
pred C98 destroy C99
means
:L429: (not (for B72 being Int-Location holds (for B73 being FinSeq-Location holds (( C99 := B72 ) <> C98 & ( AddTo (C99 , B72) ) <> C98 & ( SubFrom (C99 , B72) ) <> C98 & ( MultBy (C99 , B72) ) <> C98 & ( Divide (C99 , B72) ) <> C98 & ( Divide (B72 , C99) ) <> C98 & ( C99 := (B73 , B72) ) <> C98 & ( C99 :=len B73 ) <> C98))))
;end;
definition
let C100 being ( NAT ) -defined (the InstructionsF of ( SCM+FSA )) -valued Function;
let C101 being Int-Location;
pred C100 destroy C101
means
:L431: (ex B74 being (Instruction of ( SCM+FSA )) st (B74 in ( rng C100 ) & B74 destroy C101))
;end;
definition
let C102 being ( NAT ) -defined (the InstructionsF of ( SCM+FSA )) -valued Function;
attr C102 is  good
means
:L433: (not C102 destroy ( intloc ( 0 ) ));
end;
theorem
L435: (for B75 being Int-Location holds (not ( halt ( SCM+FSA ) ) destroy B75))
proof
let C103 being Int-Location;
L436: (for B76 being Int-Location holds (for B77 being (Element of ( NAT )) holds (for B78 being FinSeq-Location holds (( C103 := B76 ) <> ( halt ( SCM+FSA ) ) & ( AddTo (C103 , B76) ) <> ( halt ( SCM+FSA ) ) & ( SubFrom (C103 , B76) ) <> ( halt ( SCM+FSA ) ) & ( MultBy (C103 , B76) ) <> ( halt ( SCM+FSA ) ) & ( Divide (C103 , B76) ) <> ( halt ( SCM+FSA ) ) & ( Divide (B76 , C103) ) <> ( halt ( SCM+FSA ) ) & ( C103 := (B78 , B76) ) <> ( halt ( SCM+FSA ) ) & ( C103 :=len B78 ) <> ( halt ( SCM+FSA ) )))));
thus L437: thesis by L436 , L429;
end;
theorem
L438: (for B79 , B80 , B81 being Int-Location holds (B79 <> B80 implies (not ( B80 := B81 ) destroy B79)))
proof
let C104 , C105 , C106 being Int-Location;
assume L439: C104 <> C105;
L440:
now
let C107 being Int-Location;
let C108 being (Element of ( NAT ));
let C109 being FinSeq-Location;
thus L441: ( C104 := C107 ) <> ( C105 := C106 ) by L439 , SF_MASTR:1;
L442: ( InsCode ( C105 := C106 ) ) = 1 by SCMFSA_2:18;
thus L443: ( AddTo (C104 , C107) ) <> ( C105 := C106 ) by L442 , SCMFSA_2:19;
thus L444: ( SubFrom (C104 , C107) ) <> ( C105 := C106 ) by L442 , SCMFSA_2:20;
thus L445: ( MultBy (C104 , C107) ) <> ( C105 := C106 ) by L442 , SCMFSA_2:21;
thus L446: (( Divide (C104 , C107) ) <> ( C105 := C106 ) & ( Divide (C107 , C104) ) <> ( C105 := C106 )) by L442 , SCMFSA_2:22;
thus L447: ( C104 := (C109 , C107) ) <> ( C105 := C106 ) by L442 , SCMFSA_2:26;
thus L448: ( C104 :=len C109 ) <> ( C105 := C106 ) by L442 , SCMFSA_2:28;
end;
thus L449: thesis by L440 , L429;
end;
theorem
L450: (for B82 , B83 , B84 being Int-Location holds (B82 <> B83 implies (not ( AddTo (B83 , B84) ) destroy B82)))
proof
let C110 , C111 , C112 being Int-Location;
assume L451: C110 <> C111;
L452:
now
let C113 being Int-Location;
let C114 being (Element of ( NAT ));
let C115 being FinSeq-Location;
L453: ( InsCode ( AddTo (C111 , C112) ) ) = 2 by SCMFSA_2:19;
thus L454: ( C110 := C113 ) <> ( AddTo (C111 , C112) ) by L453 , SCMFSA_2:18;
thus L455: ( AddTo (C110 , C113) ) <> ( AddTo (C111 , C112) ) by L451 , SF_MASTR:2;
thus L456: ( SubFrom (C110 , C113) ) <> ( AddTo (C111 , C112) ) by L453 , SCMFSA_2:20;
thus L457: ( MultBy (C110 , C113) ) <> ( AddTo (C111 , C112) ) by L453 , SCMFSA_2:21;
thus L458: (( Divide (C110 , C113) ) <> ( AddTo (C111 , C112) ) & ( Divide (C113 , C110) ) <> ( AddTo (C111 , C112) )) by L453 , SCMFSA_2:22;
thus L459: ( C110 := (C115 , C113) ) <> ( AddTo (C111 , C112) ) by L453 , SCMFSA_2:26;
thus L460: ( C110 :=len C115 ) <> ( AddTo (C111 , C112) ) by L453 , SCMFSA_2:28;
end;
thus L461: thesis by L452 , L429;
end;
theorem
L462: (for B85 , B86 , B87 being Int-Location holds (B85 <> B86 implies (not ( SubFrom (B86 , B87) ) destroy B85)))
proof
let C116 , C117 , C118 being Int-Location;
assume L463: C116 <> C117;
L464:
now
let C119 being Int-Location;
let C120 being (Element of ( NAT ));
let C121 being FinSeq-Location;
L465: ( InsCode ( SubFrom (C117 , C118) ) ) = 3 by SCMFSA_2:20;
thus L466: ( C116 := C119 ) <> ( SubFrom (C117 , C118) ) by L465 , SCMFSA_2:18;
thus L467: ( AddTo (C116 , C119) ) <> ( SubFrom (C117 , C118) ) by L465 , SCMFSA_2:19;
thus L468: ( SubFrom (C116 , C119) ) <> ( SubFrom (C117 , C118) ) by L463 , SF_MASTR:3;
thus L469: ( MultBy (C116 , C119) ) <> ( SubFrom (C117 , C118) ) by L465 , SCMFSA_2:21;
thus L470: (( Divide (C116 , C119) ) <> ( SubFrom (C117 , C118) ) & ( Divide (C119 , C116) ) <> ( SubFrom (C117 , C118) )) by L465 , SCMFSA_2:22;
thus L471: ( C116 := (C121 , C119) ) <> ( SubFrom (C117 , C118) ) by L465 , SCMFSA_2:26;
thus L472: ( C116 :=len C121 ) <> ( SubFrom (C117 , C118) ) by L465 , SCMFSA_2:28;
end;
thus L473: thesis by L464 , L429;
end;
theorem
L474: (for B88 , B89 , B90 being Int-Location holds (B88 <> B89 implies (not ( MultBy (B89 , B90) ) destroy B88)))
proof
let C122 , C123 , C124 being Int-Location;
assume L475: C122 <> C123;
L476:
now
let C125 being Int-Location;
let C126 being (Element of ( NAT ));
let C127 being FinSeq-Location;
L477: ( InsCode ( MultBy (C123 , C124) ) ) = 4 by SCMFSA_2:21;
thus L478: ( C122 := C125 ) <> ( MultBy (C123 , C124) ) by L477 , SCMFSA_2:18;
thus L479: ( AddTo (C122 , C125) ) <> ( MultBy (C123 , C124) ) by L477 , SCMFSA_2:19;
thus L480: ( SubFrom (C122 , C125) ) <> ( MultBy (C123 , C124) ) by L477 , SCMFSA_2:20;
thus L481: ( MultBy (C122 , C125) ) <> ( MultBy (C123 , C124) ) by L475 , SF_MASTR:4;
thus L482: (( Divide (C122 , C125) ) <> ( MultBy (C123 , C124) ) & ( Divide (C125 , C122) ) <> ( MultBy (C123 , C124) )) by L477 , SCMFSA_2:22;
thus L483: ( C122 := (C127 , C125) ) <> ( MultBy (C123 , C124) ) by L477 , SCMFSA_2:26;
thus L484: ( C122 :=len C127 ) <> ( MultBy (C123 , C124) ) by L477 , SCMFSA_2:28;
end;
thus L485: thesis by L476 , L429;
end;
theorem
L486: (for B91 , B92 , B93 being Int-Location holds ((B91 <> B92 & B91 <> B93) implies (not ( Divide (B92 , B93) ) destroy B91)))
proof
let C128 , C129 , C130 being Int-Location;
assume L487: (C128 <> C129 & C128 <> C130);
L488:
now
let C131 being Int-Location;
let C132 being (Element of ( NAT ));
let C133 being FinSeq-Location;
L489: ( InsCode ( Divide (C129 , C130) ) ) = 5 by SCMFSA_2:22;
thus L490: ( C128 := C131 ) <> ( Divide (C129 , C130) ) by L489 , SCMFSA_2:18;
thus L491: ( AddTo (C128 , C131) ) <> ( Divide (C129 , C130) ) by L489 , SCMFSA_2:19;
thus L492: ( SubFrom (C128 , C131) ) <> ( Divide (C129 , C130) ) by L489 , SCMFSA_2:20;
thus L493: ( MultBy (C128 , C131) ) <> ( Divide (C129 , C130) ) by L489 , SCMFSA_2:21;
thus L494: (( Divide (C131 , C128) ) <> ( Divide (C129 , C130) ) & ( Divide (C128 , C131) ) <> ( Divide (C129 , C130) )) by L487 , SF_MASTR:5;
thus L495: ( C128 := (C133 , C131) ) <> ( Divide (C129 , C130) ) by L489 , SCMFSA_2:26;
thus L496: ( C128 :=len C133 ) <> ( Divide (C129 , C130) ) by L489 , SCMFSA_2:28;
end;
thus L497: thesis by L488 , L429;
end;
theorem
L498: (for B94 being Int-Location holds (for B95 being (Element of ( NAT )) holds (not ( goto B95 ) destroy B94)))
proof
let C134 being Int-Location;
let C135 being (Element of ( NAT ));
L499: (for B96 being Int-Location holds (for B97 being (Element of ( NAT )) holds (for B98 being FinSeq-Location holds (( C134 := B96 ) <> ( goto C135 ) & ( AddTo (C134 , B96) ) <> ( goto C135 ) & ( SubFrom (C134 , B96) ) <> ( goto C135 ) & ( MultBy (C134 , B96) ) <> ( goto C135 ) & ( Divide (C134 , B96) ) <> ( goto C135 ) & ( Divide (B96 , C134) ) <> ( goto C135 ) & ( C134 := (B98 , B96) ) <> ( goto C135 ) & ( C134 :=len B98 ) <> ( goto C135 )))));
thus L500: thesis by L499 , L429;
end;
theorem
L501: (for B99 , B100 being Int-Location holds (for B101 being (Element of ( NAT )) holds (not ( B100 =0_goto B101 ) destroy B99)))
proof
let C136 , C137 being Int-Location;
let C138 being (Element of ( NAT ));
L502: (for B102 being Int-Location holds (for B103 being FinSeq-Location holds (( C136 := B102 ) <> ( C137 =0_goto C138 ) & ( AddTo (C136 , B102) ) <> ( C137 =0_goto C138 ) & ( SubFrom (C136 , B102) ) <> ( C137 =0_goto C138 ) & ( MultBy (C136 , B102) ) <> ( C137 =0_goto C138 ) & ( Divide (C136 , B102) ) <> ( C137 =0_goto C138 ) & ( Divide (B102 , C136) ) <> ( C137 =0_goto C138 ) & ( C136 := (B103 , B102) ) <> ( C137 =0_goto C138 ) & ( C136 :=len B103 ) <> ( C137 =0_goto C138 ))));
thus L503: thesis by L502 , L429;
end;
theorem
L504: (for B104 , B105 being Int-Location holds (for B106 being (Element of ( NAT )) holds (not ( B105 >0_goto B106 ) destroy B104)))
proof
let C139 , C140 being Int-Location;
let C141 being (Element of ( NAT ));
L505: (for B107 being Int-Location holds (for B108 being FinSeq-Location holds (( C139 := B107 ) <> ( C140 >0_goto C141 ) & ( AddTo (C139 , B107) ) <> ( C140 >0_goto C141 ) & ( SubFrom (C139 , B107) ) <> ( C140 >0_goto C141 ) & ( MultBy (C139 , B107) ) <> ( C140 >0_goto C141 ) & ( Divide (C139 , B107) ) <> ( C140 >0_goto C141 ) & ( Divide (B107 , C139) ) <> ( C140 >0_goto C141 ) & ( C139 := (B108 , B107) ) <> ( C140 >0_goto C141 ) & ( C139 :=len B108 ) <> ( C140 >0_goto C141 ))));
thus L506: thesis by L505 , L429;
end;
theorem
L507: (for B109 , B110 , B111 being Int-Location holds (for B112 being FinSeq-Location holds (B109 <> B110 implies (not ( B110 := (B112 , B111) ) destroy B109))))
proof
let C142 , C143 , C144 being Int-Location;
let C145 being FinSeq-Location;
assume L508: C142 <> C143;
L509:
now
let C146 being Int-Location;
let C147 being (Element of ( NAT ));
let C148 being FinSeq-Location;
L510: ( InsCode ( C143 := (C145 , C144) ) ) = 9 by SCMFSA_2:26;
thus L511: ( C142 := C146 ) <> ( C143 := (C145 , C144) ) by L510 , SCMFSA_2:18;
thus L512: ( AddTo (C142 , C146) ) <> ( C143 := (C145 , C144) ) by L510 , SCMFSA_2:19;
thus L513: ( SubFrom (C142 , C146) ) <> ( C143 := (C145 , C144) ) by L510 , SCMFSA_2:20;
thus L514: ( MultBy (C142 , C146) ) <> ( C143 := (C145 , C144) ) by L510 , SCMFSA_2:21;
thus L515: (( Divide (C142 , C146) ) <> ( C143 := (C145 , C144) ) & ( Divide (C146 , C142) ) <> ( C143 := (C145 , C144) )) by L510 , SCMFSA_2:22;
thus L516: ( C142 := (C148 , C146) ) <> ( C143 := (C145 , C144) ) by L508 , SF_MASTR:9;
thus L517: ( C142 :=len C148 ) <> ( C143 := (C145 , C144) ) by L510 , SCMFSA_2:28;
end;
thus L518: thesis by L509 , L429;
end;
theorem
L519: (for B113 , B114 , B115 being Int-Location holds (for B116 being FinSeq-Location holds (not ( (B116 , B115) := B114 ) destroy B113)))
proof
let C149 , C150 , C151 being Int-Location;
let C152 being FinSeq-Location;
L520:
now
let C153 being Int-Location;
let C154 being FinSeq-Location;
L521: ( InsCode ( (C152 , C151) := C150 ) ) = 10 by SCMFSA_2:27;
thus L522: ( C149 := C153 ) <> ( (C152 , C151) := C150 ) by L521 , SCMFSA_2:18;
thus L523: ( AddTo (C149 , C153) ) <> ( (C152 , C151) := C150 ) by L521 , SCMFSA_2:19;
thus L524: ( SubFrom (C149 , C153) ) <> ( (C152 , C151) := C150 ) by L521 , SCMFSA_2:20;
thus L525: ( MultBy (C149 , C153) ) <> ( (C152 , C151) := C150 ) by L521 , SCMFSA_2:21;
thus L526: (( Divide (C153 , C149) ) <> ( (C152 , C151) := C150 ) & ( Divide (C149 , C153) ) <> ( (C152 , C151) := C150 )) by L521 , SCMFSA_2:22;
thus L527: ( C149 := (C154 , C153) ) <> ( (C152 , C151) := C150 ) by L521 , SCMFSA_2:26;
thus L528: ( C149 :=len C154 ) <> ( (C152 , C151) := C150 ) by L521 , SCMFSA_2:28;
end;
thus L529: thesis by L520 , L429;
end;
theorem
L530: (for B117 , B118 being Int-Location holds (for B119 being FinSeq-Location holds (B117 <> B118 implies (not ( B118 :=len B119 ) destroy B117))))
proof
let C155 , C156 being Int-Location;
let C157 being FinSeq-Location;
assume L531: C155 <> C156;
L532:
now
let C158 being Int-Location;
let C159 being FinSeq-Location;
L533: ( InsCode ( C156 :=len C157 ) ) = 11 by SCMFSA_2:28;
thus L534: ( C155 := C158 ) <> ( C156 :=len C157 ) by L533 , SCMFSA_2:18;
thus L535: ( AddTo (C155 , C158) ) <> ( C156 :=len C157 ) by L533 , SCMFSA_2:19;
thus L536: ( SubFrom (C155 , C158) ) <> ( C156 :=len C157 ) by L533 , SCMFSA_2:20;
thus L537: ( MultBy (C155 , C158) ) <> ( C156 :=len C157 ) by L533 , SCMFSA_2:21;
thus L538: (( Divide (C155 , C158) ) <> ( C156 :=len C157 ) & ( Divide (C158 , C155) ) <> ( C156 :=len C157 )) by L533 , SCMFSA_2:22;
thus L539: ( C155 := (C159 , C158) ) <> ( C156 :=len C157 ) by L533 , SCMFSA_2:26;
thus L540: ( C155 :=len C159 ) <> ( C156 :=len C157 ) by L531 , SF_MASTR:11;
end;
thus L541: thesis by L532 , L429;
end;
theorem
L542: (for B120 , B121 being Int-Location holds (for B122 being FinSeq-Location holds (not ( B122 :=<0,...,0> B121 ) destroy B120)))
proof
let C160 , C161 being Int-Location;
let C162 being FinSeq-Location;
L543:
now
let C163 being Int-Location;
let C164 being FinSeq-Location;
L544: ( InsCode ( C162 :=<0,...,0> C161 ) ) = 12 by SCMFSA_2:29;
thus L545: ( C160 := C163 ) <> ( C162 :=<0,...,0> C161 ) by L544 , SCMFSA_2:18;
thus L546: ( AddTo (C160 , C163) ) <> ( C162 :=<0,...,0> C161 ) by L544 , SCMFSA_2:19;
thus L547: ( SubFrom (C160 , C163) ) <> ( C162 :=<0,...,0> C161 ) by L544 , SCMFSA_2:20;
thus L548: ( MultBy (C160 , C163) ) <> ( C162 :=<0,...,0> C161 ) by L544 , SCMFSA_2:21;
thus L549: (( Divide (C160 , C163) ) <> ( C162 :=<0,...,0> C161 ) & ( Divide (C163 , C160) ) <> ( C162 :=<0,...,0> C161 )) by L544 , SCMFSA_2:22;
thus L550: ( C160 := (C164 , C163) ) <> ( C162 :=<0,...,0> C161 ) by L544 , SCMFSA_2:26;
thus L551: ( C160 :=len C164 ) <> ( C162 :=<0,...,0> C161 ) by L544 , SCMFSA_2:28;
end;
thus L552: thesis by L543 , L429;
end;
definition
let C165 being (Program of ( SCM+FSA ));
let C166 being (State of ( SCM+FSA ));
let C167 being (Instruction-Sequence of ( SCM+FSA ));
pred C165 is_closed_on C166 , C167
means
:L553: (for B123 being (Element of ( NAT )) holds ( IC ( Comput (( C167 +* C165 ) , ( Initialize C166 ) , B123) ) ) in ( dom C165 ))
;pred C165 is_halting_on C166 , C167
means
:L554: ( C167 +* C165 ) halts_on ( Initialize C166 )
;end;
theorem
L556: (for B124 being (Program of ( SCM+FSA )) holds (B124 is  paraclosed iff (for B125 being (State of ( SCM+FSA )) holds (for B126 being (Instruction-Sequence of ( SCM+FSA )) holds B124 is_closed_on B125 , B126))))
proof
let C168 being (Program of ( SCM+FSA ));
thus L557: (C168 is  paraclosed implies (for B127 being (State of ( SCM+FSA )) holds (for B128 being (Instruction-Sequence of ( SCM+FSA )) holds C168 is_closed_on B127 , B128)))
proof
assume L558: C168 is  paraclosed;
let C169 being (State of ( SCM+FSA ));
let C170 being (Instruction-Sequence of ( SCM+FSA ));
let C171 being (Element of ( NAT ));
L559: C168 c= ( C170 +* C168 ) by FUNCT_4:25;
thus L560: ( IC ( Comput (( C170 +* C168 ) , ( Initialize C169 ) , C171) ) ) in ( dom C168 ) by L559 , L558 , AMISTD_1:def 10;
end;

assume L561: (for B129 being (State of ( SCM+FSA )) holds (for B130 being (Instruction-Sequence of ( SCM+FSA )) holds C168 is_closed_on B129 , B130));
let C172 being ( 0 ) -started (State of ( SCM+FSA ));
let C173 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L562: C168 c= C173;
let C174 being (Element of ( NAT ));
L563: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C172 by MEMSTR_0:29;
L564: C173 = ( C173 +* C168 ) by L562 , FUNCT_4:98;
L565: C172 = ( Initialize C172 ) by L563 , FUNCT_4:98;
L566: C168 is_closed_on C172 , C173 by L561;
thus L567: ( IC ( Comput (C173 , C172 , C174) ) ) in ( dom C168 ) by L566 , L564 , L565 , L553;
end;
theorem
L568: (for B131 being (Program of ( SCM+FSA )) holds (B131 is  parahalting iff (for B132 being (State of ( SCM+FSA )) holds (for B133 being (Instruction-Sequence of ( SCM+FSA )) holds B131 is_halting_on B132 , B133))))
proof
set D33 = ( Start-At (( 0 ) , ( SCM+FSA )) );
let C175 being (Program of ( SCM+FSA ));
thus L569: (C175 is  parahalting implies (for B134 being (State of ( SCM+FSA )) holds (for B135 being (Instruction-Sequence of ( SCM+FSA )) holds C175 is_halting_on B134 , B135)))
proof
assume L570: C175 is  parahalting;
let C176 being (State of ( SCM+FSA ));
let C177 being (Instruction-Sequence of ( SCM+FSA ));
L571: C175 c= ( C177 +* C175 ) by FUNCT_4:25;
thus L572: ( C177 +* C175 ) halts_on ( Initialize C176 ) by L571 , L570 , AMISTD_1:def 11;
end;

assume L573: (for B136 being (State of ( SCM+FSA )) holds (for B137 being (Instruction-Sequence of ( SCM+FSA )) holds C175 is_halting_on B136 , B137));
let C178 being ( 0 ) -started (State of ( SCM+FSA ));
L574: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C178 by MEMSTR_0:29;
let C179 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L575: C175 c= C179;
L576: C179 = ( C179 +* C175 ) by L575 , FUNCT_4:98;
L577: ( Initialize C178 ) = C178 by L574 , FUNCT_4:98;
L578: C175 is_halting_on C178 , C179 by L573;
thus L579: C179 halts_on C178 by L578 , L576 , L577 , L554;
end;
theorem
L580: (for B138 being (Instruction of ( SCM+FSA )) holds (for B139 being Int-Location holds (for B140 being (State of ( SCM+FSA )) holds ((not B138 destroy B139) implies ( ( Exec (B138 , B140) ) . B139 ) = ( B140 . B139 )))))
proof
let C180 being (Instruction of ( SCM+FSA ));
let C181 being Int-Location;
let C182 being (State of ( SCM+FSA ));
assume L581: (not C180 destroy C181);
per cases  by NAT_1:36 , SCMFSA_2:16;
suppose L582: ( InsCode C180 ) = ( 0 );

L583: C180 = ( halt ( SCM+FSA ) ) by L582 , SCMFSA_2:95;
thus L584: thesis by L583 , EXTPRO_1:def 3;
end;
suppose L585: ( InsCode C180 ) = 1;

consider C183 , C184 being Int-Location such that L586: C180 = ( C183 := C184 ) by L585 , SCMFSA_2:30;
L587: C183 <> C181 by L581 , L586 , L429;
thus L588: thesis by L587 , L586 , SCMFSA_2:63;
end;
suppose L589: ( InsCode C180 ) = 2;

consider C185 , C186 being Int-Location such that L590: C180 = ( AddTo (C185 , C186) ) by L589 , SCMFSA_2:31;
L591: C185 <> C181 by L581 , L590 , L429;
thus L592: thesis by L591 , L590 , SCMFSA_2:64;
end;
suppose L593: ( InsCode C180 ) = 3;

consider C187 , C188 being Int-Location such that L594: C180 = ( SubFrom (C187 , C188) ) by L593 , SCMFSA_2:32;
L595: C187 <> C181 by L581 , L594 , L429;
thus L596: thesis by L595 , L594 , SCMFSA_2:65;
end;
suppose L597: ( InsCode C180 ) = 4;

consider C189 , C190 being Int-Location such that L598: C180 = ( MultBy (C189 , C190) ) by L597 , SCMFSA_2:33;
L599: C189 <> C181 by L581 , L598 , L429;
thus L600: thesis by L599 , L598 , SCMFSA_2:66;
end;
suppose L601: ( InsCode C180 ) = 5;

consider C191 , C192 being Int-Location such that L602: C180 = ( Divide (C191 , C192) ) by L601 , SCMFSA_2:34;
L603: (C191 <> C181 & C192 <> C181) by L581 , L602 , L429;
thus L604: thesis by L603 , L602 , SCMFSA_2:67;
end;
suppose L605: ( InsCode C180 ) = 6;

L606: (ex B141 being (Element of ( NAT )) st C180 = ( goto B141 )) by L605 , SCMFSA_2:35;
thus L607: thesis by L606 , SCMFSA_2:69;
end;
suppose L608: ( InsCode C180 ) = 7;

L609: (ex B142 being (Element of ( NAT )) st (ex B143 being Int-Location st C180 = ( B143 =0_goto B142 ))) by L608 , SCMFSA_2:36;
thus L610: thesis by L609 , SCMFSA_2:70;
end;
suppose L611: ( InsCode C180 ) = 8;

L612: (ex B144 being (Element of ( NAT )) st (ex B145 being Int-Location st C180 = ( B145 >0_goto B144 ))) by L611 , SCMFSA_2:37;
thus L613: thesis by L612 , SCMFSA_2:71;
end;
suppose L614: ( InsCode C180 ) = 9;

consider C193 , C194 being Int-Location, C195 being FinSeq-Location such that L615: C180 = ( C194 := (C195 , C193) ) by L614 , SCMFSA_2:38;
L616: C194 <> C181 by L581 , L615 , L429;
thus L617: thesis by L616 , L615 , SCMFSA_2:72;
end;
suppose L618: ( InsCode C180 ) = 10;

L619: (ex B146 , B147 being Int-Location st (ex B148 being FinSeq-Location st C180 = ( (B148 , B146) := B147 ))) by L618 , SCMFSA_2:39;
thus L620: thesis by L619 , SCMFSA_2:73;
end;
suppose L621: ( InsCode C180 ) = 11;

consider C196 being Int-Location, C197 being FinSeq-Location such that L622: C180 = ( C196 :=len C197 ) by L621 , SCMFSA_2:40;
L623: C196 <> C181 by L581 , L622 , L429;
thus L624: thesis by L623 , L622 , SCMFSA_2:74;
end;
suppose L625: ( InsCode C180 ) = 12;

L626: (ex B149 being Int-Location st (ex B150 being FinSeq-Location st C180 = ( B150 :=<0,...,0> B149 ))) by L625 , SCMFSA_2:41;
thus L627: thesis by L626 , SCMFSA_2:75;
end;
end;
theorem
L629: (for B151 being (State of ( SCM+FSA )) holds (for B152 being (Instruction-Sequence of ( SCM+FSA )) holds (for B153 being (Program of ( SCM+FSA )) holds (for B154 being Int-Location holds (((not B153 destroy B154) & B153 is_closed_on B151 , B152) implies (for B155 being (Element of ( NAT )) holds ( ( Comput (( B152 +* B153 ) , ( Initialize B151 ) , B155) ) . B154 ) = ( B151 . B154 )))))))
proof
let C198 being (State of ( SCM+FSA ));
let C199 being (Instruction-Sequence of ( SCM+FSA ));
let C200 being (Program of ( SCM+FSA ));
let C201 being Int-Location;
assume L630: (not C200 destroy C201);
defpred S6[ Nat ] means ( ( Comput (( C199 +* C200 ) , ( Initialize C198 ) , $1) ) . C201 ) = ( C198 . C201 );
L631: C200 c= ( C199 +* C200 ) by FUNCT_4:25;
assume L632: C200 is_closed_on C198 , C199;
L633:
now
let C202 being (Element of ( NAT ));
assume L634: S6[ C202 ];
set D34 = ( IC ( Comput (( C199 +* C200 ) , ( Initialize C198 ) , C202) ) );
L635: D34 in ( dom C200 ) by L632 , L553;
L636: ( ( C199 +* C200 ) . D34 ) = ( C200 . D34 ) by L635 , L631 , GRFUNC_1:2;
L637: ( ( C199 +* C200 ) . D34 ) in ( rng C200 ) by L636 , L635 , FUNCT_1:def 3;
L638: (not ( ( C199 +* C200 ) . D34 ) destroy C201) by L637 , L630 , L431;
L639: ( dom ( C199 +* C200 ) ) = ( NAT ) by PARTFUN1:def 2;
L640: ( ( Comput (( C199 +* C200 ) , ( Initialize C198 ) , ( C202 + 1 )) ) . C201 ) = ( ( Following (( C199 +* C200 ) , ( Comput (( C199 +* C200 ) , ( Initialize C198 ) , C202) )) ) . C201 ) by EXTPRO_1:3
.= ( ( Exec (( ( C199 +* C200 ) . ( IC ( Comput (( C199 +* C200 ) , ( Initialize C198 ) , C202) ) ) ) , ( Comput (( C199 +* C200 ) , ( Initialize C198 ) , C202) )) ) . C201 ) by L639 , PARTFUN1:def 6
.= ( ( Comput (( C199 +* C200 ) , ( C198 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) , C202) ) . C201 ) by L638 , L580
.= ( C198 . C201 ) by L634;
thus L641: S6[ ( C202 + 1 ) ] by L640;
end;
L642: (not C201 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L643: ( ( Comput (( C199 +* C200 ) , ( Initialize C198 ) , ( 0 )) ) . C201 ) = ( ( Initialize C198 ) . C201 )
.= ( C198 . C201 ) by L642 , FUNCT_4:11;
L644: S6[ ( 0 ) ] by L643;
thus L645: (for B156 being (Element of ( NAT )) holds S6[ B156 ]) from NAT_1:sch 1(L644 , L633);
end;
registration
cluster ( Stop ( SCM+FSA ) ) ->  parahalting  good;
coherence
proof
thus L646: ( Stop ( SCM+FSA ) ) is  parahalting
proof
L647: ( 0 ) in ( dom ( Stop ( SCM+FSA ) ) ) by AFINSQ_1:65;
L648: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
let C203 being ( 0 ) -started (State of ( SCM+FSA ));
L649: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C203 by MEMSTR_0:29;
let C204 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L650: ( Stop ( SCM+FSA ) ) c= C204;
L651: ( dom C204 ) = ( NAT ) by PARTFUN1:def 2;
L652: ( CurInstr (C204 , ( Comput (C204 , C203 , ( 0 )) )) ) = ( CurInstr (C204 , C203) )
.= ( C204 . ( IC C203 ) ) by L651 , PARTFUN1:def 6
.= ( C204 . ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) ) by L649 , L648 , GRFUNC_1:2
.= ( C204 . ( 0 ) ) by FUNCOP_1:72
.= ( ( Stop ( SCM+FSA ) ) . ( 0 ) ) by L647 , L650 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by AFINSQ_1:34;
thus L653: thesis by L652 , EXTPRO_1:29;
end;

thus L654: (not ( Stop ( SCM+FSA ) ) destroy ( intloc ( 0 ) ))
proof
L655:
now
let C205 being (Instruction of ( SCM+FSA ));
L656: ( rng ( Stop ( SCM+FSA ) ) ) = { ( halt ( SCM+FSA ) ) } by AFINSQ_1:33;
assume L657: C205 in ( rng ( Stop ( SCM+FSA ) ) );
L658: C205 = ( halt ( SCM+FSA ) ) by L657 , L656 , TARSKI:def 1;
thus L659: (not C205 destroy ( intloc ( 0 ) )) by L658 , L435;
end;
thus L660: thesis by L655 , L431;
end;

end;
end;
registration
cluster  parahalting  good for (Program of ( SCM+FSA ));
existence
proof
take ( Stop ( SCM+FSA ) );
thus L656: thesis;
end;
end;
registration
cluster  paraclosed  good ->  keeping_0 for (Program of ( SCM+FSA ));
correctness
proof
let C206 being (Program of ( SCM+FSA ));
assume L658: C206 is  paraclosed  good;
L659: (not C206 destroy ( intloc ( 0 ) )) by L658 , L433;
let C207 being ( 0 ) -started (State of ( SCM+FSA ));
L660: ( Initialize C207 ) = C207 by MEMSTR_0:44;
let R2 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L661: C206 c= R2;
let C208 being (Element of ( NAT ));
L662: C206 is_closed_on C207 , R2 by L658 , L556;
L663: ( R2 +* C206 ) = R2 by L661 , FUNCT_4:98;
thus L664: ( ( Comput (R2 , C207 , C208) ) . ( intloc ( 0 ) ) ) = ( C207 . ( intloc ( 0 ) ) ) by L663 , L659 , L660 , L629 , L662;
end;
end;
theorem
L666: (for B157 being Int-Location holds (for B158 being Integer holds ( rng ( aSeq (B157 , B158) ) ) c= { ( B157 := ( intloc ( 0 ) ) ) , ( AddTo (B157 , ( intloc ( 0 ) )) ) , ( SubFrom (B157 , ( intloc ( 0 ) )) ) }))
proof
let C209 being Int-Location;
let C210 being Integer;
let C211 being set;
assume L667: C211 in ( rng ( aSeq (C209 , C210) ) );
per cases ;
suppose L668: (C210 > ( 0 ) & C210 = ( ( 0 ) + 1 ));

L669: (ex B159 being (Element of ( NAT )) st (( B159 + 1 ) = C210 & ( aSeq (C209 , C210) ) = ( <% ( C209 := ( intloc ( 0 ) ) ) %> ^ ( B159 --> ( AddTo (C209 , ( intloc ( 0 ) )) ) ) ))) by L668 , SCMFSA_7:def 2;
L670: ( aSeq (C209 , C210) ) = ( <% ( C209 := ( intloc ( 0 ) ) ) %> ^ ( {} ) ) by L669 , L668
.= <% ( C209 := ( intloc ( 0 ) ) ) %>;
L671: ( rng ( aSeq (C209 , C210) ) ) = { ( C209 := ( intloc ( 0 ) ) ) } by L670 , AFINSQ_1:33;
L672: C211 = ( C209 := ( intloc ( 0 ) ) ) by L671 , L667 , TARSKI:def 1;
thus L673: C211 in { ( C209 := ( intloc ( 0 ) ) ) , ( AddTo (C209 , ( intloc ( 0 ) )) ) , ( SubFrom (C209 , ( intloc ( 0 ) )) ) } by L672 , ENUMSET1:def 1;
end;
suppose L674: (C210 > ( 0 ) & C210 <> 1);

consider C212 being (Element of ( NAT )) such that L675: ( C212 + 1 ) = C210 and L676: ( aSeq (C209 , C210) ) = ( <% ( C209 := ( intloc ( 0 ) ) ) %> ^ ( C212 --> ( AddTo (C209 , ( intloc ( 0 ) )) ) ) ) by L674 , SCMFSA_7:def 2;
L677: C212 <> ( 0 ) by L674 , L675;
L678: ( rng ( aSeq (C209 , C210) ) ) = ( ( rng <% ( C209 := ( intloc ( 0 ) ) ) %> ) \/ ( rng ( C212 --> ( AddTo (C209 , ( intloc ( 0 ) )) ) ) ) ) by L676 , AFINSQ_1:26
.= ( { ( C209 := ( intloc ( 0 ) ) ) } \/ ( rng ( C212 --> ( AddTo (C209 , ( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:33
.= ( { ( C209 := ( intloc ( 0 ) ) ) } \/ { ( AddTo (C209 , ( intloc ( 0 ) )) ) } ) by L677 , FUNCOP_1:8;
L679: (C211 in { ( C209 := ( intloc ( 0 ) ) ) } or C211 in { ( AddTo (C209 , ( intloc ( 0 ) )) ) }) by L678 , L667 , XBOOLE_0:def 3;
L680: (C211 = ( C209 := ( intloc ( 0 ) ) ) or C211 = ( AddTo (C209 , ( intloc ( 0 ) )) )) by L679 , TARSKI:def 1;
thus L681: C211 in { ( C209 := ( intloc ( 0 ) ) ) , ( AddTo (C209 , ( intloc ( 0 ) )) ) , ( SubFrom (C209 , ( intloc ( 0 ) )) ) } by L680 , ENUMSET1:def 1;
end;
suppose L682: (not C210 > ( 0 ));

consider C213 being (Element of ( NAT )) such that L683: ( C213 + C210 ) = 1 and L684: ( aSeq (C209 , C210) ) = ( <% ( C209 := ( intloc ( 0 ) ) ) %> ^ ( C213 --> ( SubFrom (C209 , ( intloc ( 0 ) )) ) ) ) by L682 , SCMFSA_7:def 2;
L685: C213 <> ( 0 ) by L682 , L683;
L686: ( rng ( aSeq (C209 , C210) ) ) = ( ( rng <% ( C209 := ( intloc ( 0 ) ) ) %> ) \/ ( rng ( C213 --> ( SubFrom (C209 , ( intloc ( 0 ) )) ) ) ) ) by L684 , AFINSQ_1:26
.= ( { ( C209 := ( intloc ( 0 ) ) ) } \/ ( rng ( C213 --> ( SubFrom (C209 , ( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:33
.= ( { ( C209 := ( intloc ( 0 ) ) ) } \/ { ( SubFrom (C209 , ( intloc ( 0 ) )) ) } ) by L685 , FUNCOP_1:8;
L687: (C211 in { ( C209 := ( intloc ( 0 ) ) ) } or C211 in { ( SubFrom (C209 , ( intloc ( 0 ) )) ) }) by L686 , L667 , XBOOLE_0:def 3;
L688: (C211 = ( C209 := ( intloc ( 0 ) ) ) or C211 = ( SubFrom (C209 , ( intloc ( 0 ) )) )) by L687 , TARSKI:def 1;
thus L689: C211 in { ( C209 := ( intloc ( 0 ) ) ) , ( AddTo (C209 , ( intloc ( 0 ) )) ) , ( SubFrom (C209 , ( intloc ( 0 ) )) ) } by L688 , ENUMSET1:def 1;
end;
end;
theorem
L691: (for B160 being Int-Location holds (for B161 being Integer holds ( rng ( B160 := B161 ) ) c= { ( halt ( SCM+FSA ) ) , ( B160 := ( intloc ( 0 ) ) ) , ( AddTo (B160 , ( intloc ( 0 ) )) ) , ( SubFrom (B160 , ( intloc ( 0 ) )) ) }))
proof
let C214 being Int-Location;
let C215 being Integer;
L692:
now
let C216 being set;
L693: ( rng ( aSeq (C214 , C215) ) ) c= { ( C214 := ( intloc ( 0 ) ) ) , ( AddTo (C214 , ( intloc ( 0 ) )) ) , ( SubFrom (C214 , ( intloc ( 0 ) )) ) } by L666;
L694: ( rng ( C214 := C215 ) ) = ( rng ( ( aSeq (C214 , C215) ) ^ <% ( halt ( SCM+FSA ) ) %> ) ) by SCMFSA_7:1
.= ( ( rng ( aSeq (C214 , C215) ) ) \/ ( rng <% ( halt ( SCM+FSA ) ) %> ) ) by AFINSQ_1:26
.= ( ( rng ( aSeq (C214 , C215) ) ) \/ { ( halt ( SCM+FSA ) ) } ) by AFINSQ_1:33;
assume L695: C216 in ( rng ( C214 := C215 ) );
L696: (C216 in ( rng ( aSeq (C214 , C215) ) ) or C216 in { ( halt ( SCM+FSA ) ) }) by L695 , L694 , XBOOLE_0:def 3;
L697: (C216 = ( C214 := ( intloc ( 0 ) ) ) or C216 = ( AddTo (C214 , ( intloc ( 0 ) )) ) or C216 = ( SubFrom (C214 , ( intloc ( 0 ) )) ) or C216 = ( halt ( SCM+FSA ) )) by L696 , L693 , ENUMSET1:def 1 , TARSKI:def 1;
thus L698: C216 in { ( halt ( SCM+FSA ) ) , ( C214 := ( intloc ( 0 ) ) ) , ( AddTo (C214 , ( intloc ( 0 ) )) ) , ( SubFrom (C214 , ( intloc ( 0 ) )) ) } by L697 , ENUMSET1:def 2;
end;
thus L699: thesis by L692 , TARSKI:def 3;
end;
registration
let C217 being  read-write Int-Location;
let C218 being Integer;
cluster ( C217 := C218 ) ->  good;
correctness
proof
L700:
now
let C219 being (Instruction of ( SCM+FSA ));
L701: ( rng ( C217 := C218 ) ) c= { ( halt ( SCM+FSA ) ) , ( C217 := ( intloc ( 0 ) ) ) , ( AddTo (C217 , ( intloc ( 0 ) )) ) , ( SubFrom (C217 , ( intloc ( 0 ) )) ) } by L691;
assume L702: C219 in ( rng ( C217 := C218 ) );
per cases  by L702 , L701 , ENUMSET1:def 2;
suppose L703: C219 = ( halt ( SCM+FSA ) );

thus L704: (not C219 destroy ( intloc ( 0 ) )) by L703 , L435;
end;
suppose L705: C219 = ( C217 := ( intloc ( 0 ) ) );

thus L706: (not C219 destroy ( intloc ( 0 ) )) by L705 , L438;
end;
suppose L707: C219 = ( AddTo (C217 , ( intloc ( 0 ) )) );

thus L708: (not C219 destroy ( intloc ( 0 ) )) by L707 , L450;
end;
suppose L709: C219 = ( SubFrom (C217 , ( intloc ( 0 ) )) );

thus L710: (not C219 destroy ( intloc ( 0 ) )) by L709 , L462;
end;
end;
L712: (not ( C217 := C218 ) destroy ( intloc ( 0 ) )) by L700 , L431;
thus L713: thesis by L712 , L433;
end;
end;
registration
let C220 being  read-write Int-Location;
let C221 being Integer;
cluster ( C220 := C221 ) ->  keeping_0;
correctness;
end;
