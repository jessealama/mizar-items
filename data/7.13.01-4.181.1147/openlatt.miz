:: Representation Theorem for Heyting Lattices
::  by Jolanta Kamie\'nska
::
:: Received July 14, 1993
:: Copyright (c) 1993-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies LATTICE2, FILTER_0, LATTICES, PRE_TOPC, SUBSET_1, XBOOLE_0,
      TOPS_1, TARSKI, RCOMP_1, SETFAM_1, BINOP_1, FUNCT_1, EQREL_1, STRUCT_0,
      PBOOLE, CARD_FIL, INT_2, RELAT_1, ZFMISC_1, ORDINAL1, GROUP_6, FUNCT_2,
      WELLORD1, XBOOLEAN, LATTICE4, OPENLATT;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, RELAT_1, FUNCT_1, FUNCT_2,
      BINOP_1, SETFAM_1, DOMAIN_1, STRUCT_0, PRE_TOPC, TOPS_1, LATTICES,
      LATTICE2, FILTER_0, LATTICE4;
 constructors BINOP_1, DOMAIN_1, TOPS_1, LATTICE2, FILTER_1, LATTICE4,
      RELSET_1, FILTER_0;
 registrations XBOOLE_0, SUBSET_1, RELSET_1, STRUCT_0, LATTICES, PRE_TOPC,
      FILTER_0, LATTICE2, TOPS_1;
 requirements BOOLE, SUBSET;
 definitions TARSKI, PRE_TOPC, FILTER_0, LATTICES, LATTICE4, FUNCT_1, STRUCT_0,
      XBOOLE_0, SUBSET_1, FUNCT_2;
 theorems PRE_TOPC, LATTICES, TOPS_1, ZFMISC_1, FILTER_0, SETFAM_1, TARSKI,
      FUNCT_1, FUNCT_2, LATTICE4, RELAT_1, ORDINAL1, XBOOLE_0, XBOOLE_1,
      STRUCT_0, EQREL_1;
 schemes BINOP_1, DOMAIN_1, FUNCT_1, BINOP_2;

begin
registration
cluster  Heyting ->  implicative for 0_Lattice;
coherence;
cluster  implicative ->  upper-bounded for Lattice;
coherence;
end;
theorem
L2: (for R1 being TopSpace holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds ( R2 /\ ( Int ( ( R2 ` ) \/ R3 ) ) ) c= R3)))
proof
let R1 being TopSpace;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
L3: R2 misses ( R2 ` ) by XBOOLE_1:79;
L4: ( R2 /\ ( ( R2 ` ) \/ R3 ) ) = ( ( R2 /\ ( R2 ` ) ) \/ ( R2 /\ R3 ) ) by XBOOLE_1:23
.= ( ( {} ) \/ ( R2 /\ R3 ) ) by L3 , XBOOLE_0:def 7
.= ( R2 /\ R3 );
L5: ( R2 /\ ( ( R2 ` ) \/ R3 ) ) c= R3 by L4 , XBOOLE_1:17;
L6: ( R2 /\ ( Int ( ( R2 ` ) \/ R3 ) ) ) c= ( R2 /\ ( ( R2 ` ) \/ R3 ) ) by TOPS_1:16 , XBOOLE_1:26;
thus L7: thesis by L6 , L5 , XBOOLE_1:1;
end;
theorem
L8: (for R1 being TopSpace holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds (for B1 being (Subset of R1) holds ((B1 is  open & ( R2 /\ B1 ) c= R3) implies B1 c= ( Int ( ( R2 ` ) \/ R3 ) ))))))
proof
let R1 being TopSpace;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
let C1 being (Subset of R1);
assume that
L9: C1 is  open
and
L10: ( R2 /\ C1 ) c= R3;
L11: C1 c= ( C1 \/ ( R2 ` ) ) by XBOOLE_1:7;
L12: ( ( R2 /\ C1 ) \/ ( R2 ` ) ) = ( ( R2 \/ ( R2 ` ) ) /\ ( C1 \/ ( R2 ` ) ) ) by XBOOLE_1:24
.= ( ( [#] R1 ) /\ ( C1 \/ ( R2 ` ) ) ) by PRE_TOPC:2
.= ( C1 \/ ( R2 ` ) ) by XBOOLE_1:28;
L13: ( C1 \/ ( R2 ` ) ) c= ( R3 \/ ( R2 ` ) ) by L12 , L10 , XBOOLE_1:9;
L14: C1 c= ( R3 \/ ( R2 ` ) ) by L13 , L11 , XBOOLE_1:1;
L15: ( Int C1 ) c= ( Int ( ( R2 ` ) \/ R3 ) ) by L14 , TOPS_1:19;
thus L16: thesis by L15 , L9 , TOPS_1:23;
end;
definition
let C2 being TopStruct;
func Topology_of C2 -> (Subset-Family of C2) equals 
(the topology of C2);
coherence;
end;
registration
let R1 being TopSpace;
cluster ( Topology_of R1 ) -> non  empty;
coherence;
end;
definition
let C3 being non  empty TopSpace;
let C4 , C5 being (Element of ( Topology_of C3 ));
redefine func C4 \/ C5 -> (Element of ( Topology_of C3 ));

coherence
proof
reconsider D1 = C4 , D2 = C5 as (Subset of C3);
L19: D2 is  open by PRE_TOPC:def 2;
L20: D1 is  open by PRE_TOPC:def 2;
L21: ( C4 \/ C5 ) is  open by L20 , L19;
thus L22: thesis by L21 , PRE_TOPC:def 2;
end;
redefine func C4 /\ C5 -> (Element of ( Topology_of C3 ));

coherence
proof
reconsider D3 = C4 , D4 = C5 as (Subset of C3);
L23: D4 is  open by PRE_TOPC:def 2;
L24: D3 is  open by PRE_TOPC:def 2;
L25: ( C4 /\ C5 ) is  open by L24 , L23;
thus L26: thesis by L25 , PRE_TOPC:def 2;
end;
end;
definition
let R4 being non  empty TopSpace;
func Top_Union R4 -> (BinOp of ( Topology_of R4 )) means 
:L28: (for R5 being (Element of ( Topology_of R4 )) holds (for R6 being (Element of ( Topology_of R4 )) holds ( it . (R5 , R6) ) = ( R5 \/ R6 )));
existence
proof
deffunc H1((Element of ( Topology_of R4 )) , (Element of ( Topology_of R4 ))) = ( $1 \/ $2 );
thus L29: (ex B2 being (BinOp of ( Topology_of R4 )) st (for B3 , B4 being (Element of ( Topology_of R4 )) holds ( B2 . (B3 , B4) ) = H1(B3 , B4))) from BINOP_1:sch 4;
end;
uniqueness
proof
set D5 = ( Topology_of R4 );
deffunc H2((Element of D5) , (Element of D5)) = ( $1 \/ $2 );
thus L30: (for B5 , B6 being (BinOp of D5) holds (((for B7 , B8 being (Element of D5) holds ( B5 . (B7 , B8) ) = H2(B7 , B8)) & (for B9 , B10 being (Element of D5) holds ( B6 . (B9 , B10) ) = H2(B9 , B10))) implies B5 = B6)) from BINOP_2:sch 2;
end;
func Top_Meet R4 -> (BinOp of ( Topology_of R4 )) means 
:L31: (for R5 being (Element of ( Topology_of R4 )) holds (for R6 being (Element of ( Topology_of R4 )) holds ( it . (R5 , R6) ) = ( R5 /\ R6 )));
existence
proof
deffunc H3((Element of ( Topology_of R4 )) , (Element of ( Topology_of R4 ))) = ( $1 /\ $2 );
thus L32: (ex B11 being (BinOp of ( Topology_of R4 )) st (for B12 , B13 being (Element of ( Topology_of R4 )) holds ( B11 . (B12 , B13) ) = H3(B12 , B13))) from BINOP_1:sch 4;
end;
uniqueness
proof
set D6 = ( Topology_of R4 );
deffunc H4((Element of D6) , (Element of D6)) = ( $1 /\ $2 );
thus L33: (for B14 , B15 being (BinOp of D6) holds (((for B16 , B17 being (Element of D6) holds ( B14 . (B16 , B17) ) = H4(B16 , B17)) & (for B18 , B19 being (Element of D6) holds ( B15 . (B18 , B19) ) = H4(B18 , B19))) implies B14 = B15)) from BINOP_2:sch 2;
end;
end;
theorem
L35: (for B20 being non  empty TopSpace holds LattStr (# ( Topology_of B20 ) , ( Top_Union B20 ) , ( Top_Meet B20 ) #) is Lattice)
proof
let R4 being non  empty TopSpace;
set D7 = LattStr (# ( Topology_of R4 ) , ( Top_Union R4 ) , ( Top_Meet R4 ) #);
L36:
now
let C6 , C7 being (Element of D7);
thus L37: ( C6 "\/" C7 ) = ( C7 \/ C6 ) by L28
.= ( C7 "\/" C6 ) by L28;
end;
L38:
now
let C8 , C9 being (Element of D7);
thus L39: ( ( C8 "/\" C9 ) "\/" C9 ) = ( ( C8 "/\" C9 ) \/ C9 ) by L28
.= ( ( C8 /\ C9 ) \/ C9 ) by L31
.= C9 by XBOOLE_1:22;
end;
L40:
now
let C10 , C11 being (Element of D7);
thus L41: ( C10 "/\" ( C10 "\/" C11 ) ) = ( C10 /\ ( C10 "\/" C11 ) ) by L31
.= ( C10 /\ ( C10 \/ C11 ) ) by L28
.= C10 by XBOOLE_1:21;
end;
L42:
now
let C12 , C13 , C14 being (Element of D7);
thus L43: ( C12 "/\" ( C13 "/\" C14 ) ) = ( C12 /\ ( C13 "/\" C14 ) ) by L31
.= ( C12 /\ ( C13 /\ C14 ) ) by L31
.= ( ( C12 /\ C13 ) /\ C14 ) by XBOOLE_1:16
.= ( ( C12 "/\" C13 ) /\ C14 ) by L31
.= ( ( C12 "/\" C13 ) "/\" C14 ) by L31;
end;
L44:
now
let C15 , C16 being (Element of D7);
thus L45: ( C15 "/\" C16 ) = ( C16 /\ C15 ) by L31
.= ( C16 "/\" C15 ) by L31;
end;
L46:
now
let C17 , C18 , C19 being (Element of D7);
thus L47: ( C17 "\/" ( C18 "\/" C19 ) ) = ( C17 \/ ( C18 "\/" C19 ) ) by L28
.= ( C17 \/ ( C18 \/ C19 ) ) by L28
.= ( ( C17 \/ C18 ) \/ C19 ) by XBOOLE_1:4
.= ( ( C17 "\/" C18 ) \/ C19 ) by L28
.= ( ( C17 "\/" C18 ) "\/" C19 ) by L28;
end;
L48: D7 is  join-commutative  join-associative  meet-absorbing  meet-commutative  meet-associative  join-absorbing by L46 , L36 , L38 , L44 , L42 , L40 , LATTICES:def 4 , LATTICES:def 5 , LATTICES:def 6 , LATTICES:def 7 , LATTICES:def 8 , LATTICES:def 9;
thus L49: thesis by L48;
end;
definition
let R4 being non  empty TopSpace;
func Open_setLatt R4 -> Lattice equals 
LattStr (# ( Topology_of R4 ) , ( Top_Union R4 ) , ( Top_Meet R4 ) #);
coherence by L35;
end;
theorem
L51: (for R4 being non  empty TopSpace holds (the carrier of ( Open_setLatt R4 )) = ( Topology_of R4 ));
theorem
L52: (for R4 being non  empty TopSpace holds (for R7 being (Element of ( Open_setLatt R4 )) holds (for R8 being (Element of ( Open_setLatt R4 )) holds (( R7 "\/" R8 ) = ( R7 \/ R8 ) & ( R7 "/\" R8 ) = ( R7 /\ R8 ))))) by L28 , L31;
theorem
L53: (for R4 being non  empty TopSpace holds (for R7 being (Element of ( Open_setLatt R4 )) holds (for R8 being (Element of ( Open_setLatt R4 )) holds (R7 [= R8 iff R7 c= R8))))
proof
let R4 being non  empty TopSpace;
let R7 being (Element of ( Open_setLatt R4 ));
let R8 being (Element of ( Open_setLatt R4 ));
L54: (R7 [= R8 iff ( R7 "\/" R8 ) = R8) by LATTICES:def 3;
L55: ( R7 "\/" R8 ) = ( R7 \/ R8 ) by L28;
thus L56: thesis by L55 , L54 , XBOOLE_1:7 , XBOOLE_1:12;
end;
theorem
L57: (for R4 being non  empty TopSpace holds (for R7 being (Element of ( Open_setLatt R4 )) holds (for R8 being (Element of ( Open_setLatt R4 )) holds (for B21 , B22 being (Element of ( Topology_of R4 )) holds ((R7 = B21 & R8 = B22) implies (R7 [= R8 iff B21 c= B22))))))
proof
let R4 being non  empty TopSpace;
let R7 being (Element of ( Open_setLatt R4 ));
let R8 being (Element of ( Open_setLatt R4 ));
let C20 , C21 being (Element of ( Topology_of R4 ));
assume that
L58: R7 = C20
and
L59: R8 = C21;
thus L60:now
assume L61: R7 [= R8;
L62: ( C20 \/ C21 ) = ( R7 "\/" R8 ) by L58 , L59 , L28
.= C21 by L59 , L61 , LATTICES:def 3;
thus L63: C20 c= C21 by L62 , XBOOLE_1:7;
end;
assume L64: C20 c= C21;
L65: ( R7 "\/" R8 ) = ( C20 \/ C21 ) by L58 , L59 , L28
.= R8 by L59 , L64 , XBOOLE_1:12;
thus L66: thesis by L65 , LATTICES:def 3;
end;
registration
let R4 being non  empty TopSpace;
cluster ( Open_setLatt R4 ) ->  implicative;
coherence
proof
set D8 = ( Open_setLatt R4 );
let C22 , C23 being (Element of D8);
reconsider D9 = C22 , D10 = C23 as (Element of ( Topology_of R4 ));
reconsider D11 = ( Int ( ( D9 ` ) \/ D10 ) ) as (Element of ( Topology_of R4 )) by PRE_TOPC:def 2;
reconsider D12 = D11 as (Element of D8);
take D12;
L67: ( C22 "/\" D12 ) = ( D9 /\ D11 ) by L31;
L68: ( D9 /\ D12 ) c= D10 by L2;
thus L69: ( C22 "/\" D12 ) [= C23 by L68 , L67 , L57;
let C24 being (Element of D8);
reconsider D13 = C24 as (Element of ( Topology_of R4 ));
reconsider D14 = D13 as (Subset of R4);
L70: D14 is  open by PRE_TOPC:def 2;
assume L71: ( C22 "/\" C24 ) [= C23;
L72: ( C22 "/\" C24 ) = ( D9 /\ D14 ) by L31;
L73: ( D9 /\ D13 ) c= D10 by L72 , L71 , L57;
L74: D14 c= D11 by L73 , L70 , L8;
thus L75: C24 [= D12 by L74 , L57;
end;
end;
theorem
L77: (for R4 being non  empty TopSpace holds (( Open_setLatt R4 ) is  lower-bounded & ( Bottom ( Open_setLatt R4 ) ) = ( {} )))
proof
let R4 being non  empty TopSpace;
set D15 = ( Open_setLatt R4 );
reconsider D16 = ( {} ) as (Element of D15) by PRE_TOPC:1;
L78:
now
let R7 being (Element of ( Open_setLatt R4 ));
thus L79: ( D16 "/\" R7 ) = ( D16 /\ R7 ) by L31
.= D16;
thus L80: ( R7 "/\" D16 ) = D16 by L79;
end;
thus L81: D15 is  lower-bounded
proof
take D16;
thus L82: thesis by L78;
end;

thus L83: thesis by L81 , L78 , LATTICES:def 16;
end;
registration
let R4 being non  empty TopSpace;
cluster ( Open_setLatt R4 ) ->  Heyting;
coherence
proof
reconsider D17 = ( Open_setLatt R4 ) as 0_Lattice by L77;
L84: D17 is I_Lattice;
thus L85: thesis by L84;
end;
end;
theorem
L87: (for R4 being non  empty TopSpace holds ( Top ( Open_setLatt R4 ) ) = (the carrier of R4))
proof
let R4 being non  empty TopSpace;
set D18 = ( Open_setLatt R4 );
reconsider D19 = (the carrier of R4) as (Element of D18) by PRE_TOPC:def 1;
L88:
now
let C25 being (Element of D18);
reconsider D20 = C25 as (Element of ( Topology_of R4 ));
thus L89: ( D19 "\/" C25 ) = ( (the carrier of R4) \/ D20 ) by L28
.= D19 by XBOOLE_1:12;
thus L90: ( C25 "\/" D19 ) = D19 by L89;
end;
thus L91: thesis by L88 , LATTICES:def 17;
end;
definition
let R9 being D_Lattice;
func F_primeSet R9 -> set equals 
{ R10 where R10 is (Filter of R9) : (R10 <> (the carrier of R9) & R10 is  prime) };
coherence;
end;
theorem
L93: (for R9 being D_Lattice holds (for R10 being (Filter of R9) holds (R10 in ( F_primeSet R9 ) iff (R10 <> (the carrier of R9) & R10 is  prime))))
proof
let R9 being D_Lattice;
let R10 being (Filter of R9);
L94: (R10 in ( F_primeSet R9 ) iff (ex B23 being (Filter of R9) st (B23 = R10 & B23 <> (the carrier of R9) & B23 is  prime)));
thus L95: thesis by L94;
end;
definition
let R9 being D_Lattice;
func StoneH R9 -> Function means 
:L96: (for R11 being (Element of R9) holds (( dom it ) = (the carrier of R9) & ( it . R11 ) = { R10 where R10 is (Filter of R9) : (R10 in ( F_primeSet R9 ) & R11 in R10) }));
existence
proof
deffunc H5(set) = { R10 where R10 is (Filter of R9) : (R10 in ( F_primeSet R9 ) & $1 in R10) };
consider C26 being Function such that L97: (( dom C26 ) = (the carrier of R9) & (for R13 being set holds (R13 in (the carrier of R9) implies ( C26 . R13 ) = H5(R13)))) from FUNCT_1:sch 3;
take C26;
thus L98: thesis by L97;
end;
uniqueness
proof
let C27 , C28 being Function;
assume that
L99: (for R11 being (Element of R9) holds (( dom C27 ) = (the carrier of R9) & ( C27 . R11 ) = { R10 where R10 is (Filter of R9) : (R10 in ( F_primeSet R9 ) & R11 in R10) }))
and
L100: (for R11 being (Element of R9) holds (( dom C28 ) = (the carrier of R9) & ( C28 . R11 ) = { R10 where R10 is (Filter of R9) : (R10 in ( F_primeSet R9 ) & R11 in R10) }));
L101:
now
let R13 being set;
assume L102: R13 in (the carrier of R9);
reconsider D21 = R13 as (Element of R9) by L102;
thus L103: ( C27 . R13 ) = { R10 where R10 is (Filter of R9) : (R10 in ( F_primeSet R9 ) & D21 in R10) } by L99
.= ( C28 . R13 ) by L100;
end;
thus L104: thesis by L101 , L99 , L100 , FUNCT_1:2;
end;
end;
theorem
L106: (for R9 being D_Lattice holds (for R10 being (Filter of R9) holds (for R11 being (Element of R9) holds (R10 in ( ( StoneH R9 ) . R11 ) iff (R10 in ( F_primeSet R9 ) & R11 in R10)))))
proof
let R9 being D_Lattice;
let R10 being (Filter of R9);
let R11 being (Element of R9);
L107: ( ( StoneH R9 ) . R11 ) = { B24 where B24 is (Filter of R9) : (B24 in ( F_primeSet R9 ) & R11 in B24) } by L96;
L108: (R10 in ( ( StoneH R9 ) . R11 ) iff (ex B25 being (Filter of R9) st (R10 = B25 & B25 in ( F_primeSet R9 ) & R11 in B25))) by L107;
thus L109: thesis by L108;
end;
theorem
L110: (for R9 being D_Lattice holds (for R11 being (Element of R9) holds (for R13 being set holds (R13 in ( ( StoneH R9 ) . R11 ) iff (ex R10 being (Filter of R9) st (R10 = R13 & R10 <> (the carrier of R9) & R10 is  prime & R11 in R10))))))
proof
let R9 being D_Lattice;
let R11 being (Element of R9);
let R13 being set;
L111: ( ( StoneH R9 ) . R11 ) = { R10 where R10 is (Filter of R9) : (R10 in ( F_primeSet R9 ) & R11 in R10) } by L96;
thus L112:now
assume L113: R13 in ( ( StoneH R9 ) . R11 );
consider R10 being (Filter of R9) such that L114: R13 = R10 and L115: R10 in ( F_primeSet R9 ) and L116: R11 in R10 by L113 , L111;
L117: R10 is  prime by L115 , L93;
L118: R10 <> (the carrier of R9) by L115 , L93;
thus L119: (ex R10 being (Filter of R9) st (R10 = R13 & R10 <> (the carrier of R9) & R10 is  prime & R11 in R10)) by L118 , L114 , L116 , L117;
end;
given R10 being (Filter of R9) such that
L120: R10 = R13
and
L121: R10 <> (the carrier of R9)
and
L122: R10 is  prime
and
L123: R11 in R10;

L124: R10 in ( F_primeSet R9 ) by L121 , L122;
thus L125: thesis by L124 , L111 , L120 , L123;
end;
definition
let R9 being D_Lattice;
func StoneS R9 -> set equals 
( rng ( StoneH R9 ) );
coherence;
end;
registration
let R9 being D_Lattice;
cluster ( StoneS R9 ) -> non  empty;
coherence
proof
L127: ( dom ( StoneH R9 ) ) = (the carrier of R9) by L96;
thus L128: thesis by L127 , RELAT_1:42;
end;
end;
theorem
L130: (for R9 being D_Lattice holds (for R13 being set holds (R13 in ( StoneS R9 ) iff (ex R11 being (Element of R9) st R13 = ( ( StoneH R9 ) . R11 )))))
proof
let R9 being D_Lattice;
let R13 being set;
thus L131:now
assume L132: R13 in ( StoneS R9 );
consider C29 being set such that L133: C29 in ( dom ( StoneH R9 ) ) and L134: R13 = ( ( StoneH R9 ) . C29 ) by L132 , FUNCT_1:def 3;
reconsider D22 = C29 as (Element of R9) by L133 , L96;
take D23 = D22;
thus L135: R13 = ( ( StoneH R9 ) . D23 ) by L134;
end;
given R12 being (Element of R9) such that
L136: R13 = ( ( StoneH R9 ) . R12 );

L137: R12 in (the carrier of R9);
L138: R12 in ( dom ( StoneH R9 ) ) by L137 , L96;
thus L139: thesis by L138 , L136 , FUNCT_1:def 3;
end;
theorem
L140: (for R9 being D_Lattice holds (for R11 being (Element of R9) holds (for R12 being (Element of R9) holds ( ( StoneH R9 ) . ( R11 "\/" R12 ) ) = ( ( ( StoneH R9 ) . R11 ) \/ ( ( StoneH R9 ) . R12 ) ))))
proof
let R9 being D_Lattice;
let R11 being (Element of R9);
let R12 being (Element of R9);
set D24 = ( R11 "\/" R12 );
thus L141:now
set D25 = ( R11 "\/" R12 );
let R13 being set;
assume L142: R13 in ( ( StoneH R9 ) . D25 );
consider R10 being (Filter of R9) such that L143: R13 = R10 and L144: R10 <> (the carrier of R9) and L145: R10 is  prime and L146: D25 in R10 by L142 , L110;
L147: (R11 in R10 or R12 in R10) by L145 , L146 , FILTER_0:def 5;
L148: (R10 in ( ( StoneH R9 ) . R11 ) or R10 in ( ( StoneH R9 ) . R12 )) by L147 , L144 , L145 , L110;
thus L149: R13 in ( ( ( StoneH R9 ) . R11 ) \/ ( ( StoneH R9 ) . R12 ) ) by L148 , L143 , XBOOLE_0:def 3;
end;
let R13 being set;
assume L150: R13 in ( ( ( StoneH R9 ) . R11 ) \/ ( ( StoneH R9 ) . R12 ) );
L151: (R13 in ( ( StoneH R9 ) . R11 ) or R13 in ( ( StoneH R9 ) . R12 )) by L150 , XBOOLE_0:def 3;
L152: ((ex R10 being (Filter of R9) st (R13 = R10 & R10 <> (the carrier of R9) & R10 is  prime & R11 in R10)) or (ex R10 being (Filter of R9) st (R13 = R10 & R10 <> (the carrier of R9) & R10 is  prime & R12 in R10))) by L151 , L110;
consider R10 being (Filter of R9) such that L153: R13 = R10 and L154: R10 <> (the carrier of R9) and L155: R10 is  prime and L156: (R11 in R10 or R12 in R10) by L152;
L157: D24 in R10 by L155 , L156 , FILTER_0:def 5;
thus L158: thesis by L157 , L153 , L154 , L155 , L110;
end;
theorem
L159: (for R9 being D_Lattice holds (for R11 being (Element of R9) holds (for R12 being (Element of R9) holds ( ( StoneH R9 ) . ( R11 "/\" R12 ) ) = ( ( ( StoneH R9 ) . R11 ) /\ ( ( StoneH R9 ) . R12 ) ))))
proof
let R9 being D_Lattice;
let R11 being (Element of R9);
let R12 being (Element of R9);
set D26 = ( R11 "/\" R12 );
thus L160:now
set D27 = ( R11 "/\" R12 );
let R13 being set;
assume L161: R13 in ( ( StoneH R9 ) . D27 );
consider R10 being (Filter of R9) such that L162: R13 = R10 and L163: R10 <> (the carrier of R9) and L164: R10 is  prime and L165: D27 in R10 by L161 , L110;
L166: R12 in R10 by L165 , FILTER_0:8;
L167: R10 in ( ( StoneH R9 ) . R12 ) by L166 , L163 , L164 , L110;
L168: R11 in R10 by L165 , FILTER_0:8;
L169: R10 in ( ( StoneH R9 ) . R11 ) by L168 , L163 , L164 , L110;
thus L170: R13 in ( ( ( StoneH R9 ) . R11 ) /\ ( ( StoneH R9 ) . R12 ) ) by L169 , L162 , L167 , XBOOLE_0:def 4;
end;
let R13 being set;
assume L171: R13 in ( ( ( StoneH R9 ) . R11 ) /\ ( ( StoneH R9 ) . R12 ) );
L172: R13 in ( ( StoneH R9 ) . R12 ) by L171 , XBOOLE_0:def 4;
L173: (ex R10 being (Filter of R9) st (R13 = R10 & R10 <> (the carrier of R9) & R10 is  prime & R12 in R10)) by L172 , L110;
L174: R13 in ( ( StoneH R9 ) . R11 ) by L171 , XBOOLE_0:def 4;
L175: (ex R10 being (Filter of R9) st (R13 = R10 & R10 <> (the carrier of R9) & R10 is  prime & R11 in R10)) by L174 , L110;
consider R10 being (Filter of R9) such that L176: R13 = R10 and L177: R10 <> (the carrier of R9) and L178: R10 is  prime and L179: R11 in R10 and L180: R12 in R10 by L175 , L173;
L181: D26 in R10 by L179 , L180 , FILTER_0:8;
thus L182: thesis by L181 , L176 , L177 , L178 , L110;
end;
definition
let R9 being D_Lattice;
let R11 being (Element of R9);
func SF_have R11 -> (Subset-Family of R9) equals 
{ R10 where R10 is (Filter of R9) : R11 in R10 };
coherence
proof
set D28 = { R10 where R10 is (Filter of R9) : R11 in R10 };
L183: D28 c= ( bool (the carrier of R9) )
proof
let R13 being set;
assume L184: R13 in D28;
L185: (ex R10 being (Filter of R9) st (R13 = R10 & R11 in R10)) by L184;
thus L186: thesis by L185;
end;
thus L187: thesis by L183;
end;
end;
registration
let R9 being D_Lattice;
let R11 being (Element of R9);
cluster ( SF_have R11 ) -> non  empty;
coherence
proof
L189: R11 in <. R11 .);
L190: <. R11 .) in { R10 where R10 is (Filter of R9) : R11 in R10 } by L189;
thus L191: thesis by L190;
end;
end;
theorem
L193: (for R9 being D_Lattice holds (for R11 being (Element of R9) holds (for R13 being set holds (R13 in ( SF_have R11 ) iff (R13 is (Filter of R9) & R11 in R13)))))
proof
let R9 being D_Lattice;
let R11 being (Element of R9);
let R13 being set;
L194: (R13 in ( SF_have R11 ) iff (ex R10 being (Filter of R9) st (R10 = R13 & R11 in R10)));
thus L195: thesis by L194;
end;
L196: (for R9 being D_Lattice holds (for R10 being (Filter of R9) holds (for R11 being (Element of R9) holds (for R12 being (Element of R9) holds (R10 in ( ( SF_have R12 ) \ ( SF_have R11 ) ) iff (R12 in R10 & (not R11 in R10)))))))
proof
let R9 being D_Lattice;
let R10 being (Filter of R9);
let R11 being (Element of R9);
let R12 being (Element of R9);
L197: (R10 in ( ( SF_have R12 ) \ ( SF_have R11 ) ) iff (R10 in ( SF_have R12 ) & (not R10 in ( SF_have R11 )))) by XBOOLE_0:def 5;
thus L198: thesis by L197 , L193;
end;
theorem
L199: (for R9 being D_Lattice holds (for R11 being (Element of R9) holds (for R12 being (Element of R9) holds (for R13 being set holds (R13 in ( ( SF_have R12 ) \ ( SF_have R11 ) ) implies (R13 is (Filter of R9) & R12 in R13 & (not R11 in R13)))))))
proof
let R9 being D_Lattice;
let R11 being (Element of R9);
let R12 being (Element of R9);
let R13 being set;
assume L200: R13 in ( ( SF_have R12 ) \ ( SF_have R11 ) );
L201: (not R13 in ( SF_have R11 )) by L200 , XBOOLE_0:def 5;
L202: R13 in ( SF_have R12 ) by L200 , XBOOLE_0:def 5;
L203: R13 is (Filter of R9) by L202 , L193;
thus L204: thesis by L203 , L202 , L201 , L193;
end;
theorem
L205: (for R9 being D_Lattice holds (for R11 being (Element of R9) holds (for R12 being (Element of R9) holds (for R18 being set holds ((R18 <> ( {} ) & R18 c= ( ( SF_have R12 ) \ ( SF_have R11 ) ) & R18 is  c=-linear) implies (ex R17 being set st (R17 in ( ( SF_have R12 ) \ ( SF_have R11 ) ) & (for R15 being set holds (R15 in R18 implies R15 c= R17)))))))))
proof
let R9 being D_Lattice;
let R11 being (Element of R9);
let R12 being (Element of R9);
let R18 being set;
assume that
L206: R18 <> ( {} )
and
L207: R18 c= ( ( SF_have R12 ) \ ( SF_have R11 ) )
and
L208: R18 is  c=-linear;
reconsider D29 = R18 as (Subset-Family of R9) by L207 , XBOOLE_1:1;
take D30 = ( union D29 );
L209: D30 in ( ( SF_have R12 ) \ ( SF_have R11 ) )
proof
set D31 = the (Element of D29);
L210: (not R11 in D30)
proof
assume L211: R11 in D30;
L212: (ex R14 being set st (R11 in R14 & R14 in D29)) by L211 , TARSKI:def 4;
thus L213: contradiction by L212 , L207 , L199;
end;
L214: D31 in ( ( SF_have R12 ) \ ( SF_have R11 ) ) by L206 , L207 , TARSKI:def 3;
L215: R12 in D31 by L214 , L199;
L216: R12 in D30 by L215 , L206 , TARSKI:def 4;
reconsider D32 = D30 as non  empty (Subset of R9) by L206 , L215 , TARSKI:def 4;
L217:
now
let C30 , C31 being (Element of R9);
thus L218: ((C30 in D32 & C31 in D32) implies ( C30 "/\" C31 ) in D32)
proof
assume L219: C30 in D32;
consider R15 being set such that L220: C30 in R15 and L221: R15 in D29 by L219 , TARSKI:def 4;
L222: R15 is (Filter of R9) by L207 , L221 , L199;
assume L223: C31 in D32;
consider R16 being set such that L224: C31 in R16 and L225: R16 in D29 by L223 , TARSKI:def 4;
L226: R15 , R16 are_c=-comparable  by L208 , L221 , L225 , ORDINAL1:def 8;
L227: (R15 c= R16 or R16 c= R15) by L226 , XBOOLE_0:def 9;
L228: R16 is (Filter of R9) by L207 , L225 , L199;
L229: (( C30 "/\" C31 ) in R15 or ( C30 "/\" C31 ) in R16) by L228 , L220 , L224 , L222 , L227 , FILTER_0:8;
thus L230: thesis by L229 , L221 , L225 , TARSKI:def 4;
end;

assume L231: ( C30 "/\" C31 ) in D32;
consider R15 being set such that L232: ( C30 "/\" C31 ) in R15 and L233: R15 in D29 by L231 , TARSKI:def 4;
L234: R15 is (Filter of R9) by L207 , L233 , L199;
L235: C31 in R15 by L234 , L232 , FILTER_0:8;
L236: C30 in R15 by L232 , L234 , FILTER_0:8;
thus L237: (C30 in D32 & C31 in D32) by L236 , L233 , L235 , TARSKI:def 4;
end;
L238: D32 is (Filter of R9) by L217 , FILTER_0:8;
thus L239: thesis by L238 , L210 , L216 , L196;
end;
thus L240: thesis by L209 , ZFMISC_1:74;
end;
theorem
L241: (for R9 being D_Lattice holds (for R11 being (Element of R9) holds (for R12 being (Element of R9) holds ((not R12 [= R11) implies <. R12 .) in ( ( SF_have R12 ) \ ( SF_have R11 ) )))))
proof
let R9 being D_Lattice;
let R11 being (Element of R9);
let R12 being (Element of R9);
assume L242: (not R12 [= R11);
L243: (not R11 in <. R12 .)) by L242 , FILTER_0:15;
L244: (not <. R12 .) in ( SF_have R11 )) by L243 , L193;
L245: R12 in <. R12 .);
L246: <. R12 .) in ( SF_have R12 ) by L245;
thus L247: thesis by L246 , L244 , XBOOLE_0:def 5;
end;
theorem
L248: (for R9 being D_Lattice holds (for R11 being (Element of R9) holds (for R12 being (Element of R9) holds ((not R12 [= R11) implies (ex R10 being (Filter of R9) st (R10 in ( F_primeSet R9 ) & (not R11 in R10) & R12 in R10))))))
proof
let R9 being D_Lattice;
let R11 being (Element of R9);
let R12 being (Element of R9);
set D33 = ( ( SF_have R12 ) \ ( SF_have R11 ) );
assume L249: (not R12 [= R11);
L250: D33 <> ( {} ) by L249 , L241;
L251: (for R18 being set holds ((R18 <> ( {} ) & R18 c= ( ( SF_have R12 ) \ ( SF_have R11 ) ) & R18 is  c=-linear) implies (ex R17 being set st (R17 in ( ( SF_have R12 ) \ ( SF_have R11 ) ) & (for R15 being set holds (R15 in R18 implies R15 c= R17)))))) by L205;
consider R17 being set such that L252: R17 in D33 and L253: (for R18 being set holds ((R18 in D33 & R18 <> R17) implies (not R17 c= R18))) by L251 , L250 , LATTICE4:1;
reconsider D34 = R17 as (Filter of R9) by L252 , L199;
L254: R12 in D34 by L252 , L199;
L255: (not R11 in D34) by L252 , L199;
L256: D34 is  prime
proof
let C32 , C33 being (Element of R9);
thus L257: (( C32 "\/" C33 ) in D34 implies (C32 in D34 or C33 in D34))
proof
set D35 = <. ( <. C33 .) \/ D34 ) .);
set D36 = <. ( <. C32 .) \/ D34 ) .);
assume that
L258: ( C32 "\/" C33 ) in D34
and
L259: (not C32 in D34)
and
L260: (not C33 in D34);
L261: <. C32 .) c= D36 by LATTICE4:2;
L262: C32 in <. C32 .);
L263: C32 in D36 by L262 , L261;
L264: D34 c= D36 by LATTICE4:2;
L265: <. C33 .) c= D35 by LATTICE4:2;
L266: C33 in <. C33 .);
L267: C33 in D35 by L266 , L265;
L268: D34 c= D35 by LATTICE4:2;
L269: ((not R11 in D36) or (not R11 in D35))
proof
assume that
L270: R11 in D36
and
L271: R11 in D35;
consider C34 being (Element of R9) such that L272: C34 in D34 and L273: ( C32 "/\" C34 ) [= R11 by L270 , LATTICE4:3;
consider C35 being (Element of R9) such that L274: C35 in D34 and L275: ( C33 "/\" C35 ) [= R11 by L271 , LATTICE4:3;
set D37 = ( C34 "/\" C35 );
L276: ( C33 "/\" D37 ) [= ( C33 "/\" C35 ) by LATTICES:6 , LATTICES:9;
L277: ( C33 "/\" D37 ) [= R11 by L276 , L275 , LATTICES:7;
L278: ( C32 "/\" D37 ) [= ( C32 "/\" C34 ) by LATTICES:6 , LATTICES:9;
L279: ( C32 "/\" D37 ) [= R11 by L278 , L273 , LATTICES:7;
L280: ( ( C32 "/\" D37 ) "\/" ( C33 "/\" D37 ) ) [= R11 by L279 , L277 , FILTER_0:6;
L281: ( ( C32 "\/" C33 ) "/\" D37 ) [= R11 by L280 , LATTICES:def 11;
L282: D37 in D34 by L272 , L274 , FILTER_0:8;
L283: ( ( C32 "\/" C33 ) "/\" D37 ) in D34 by L282 , L258 , FILTER_0:8;
thus L284: contradiction by L283 , L255 , L281 , FILTER_0:9;
end;
L285: (D36 in D33 or D35 in D33) by L269 , L254 , L264 , L268 , L196;
thus L286: contradiction by L285 , L253 , L259 , L260 , L263 , L267 , L264 , L268;
end;

thus L287: thesis by FILTER_0:10;
end;
L288: D34 <> (the carrier of R9) by L252 , L199;
L289: D34 in ( F_primeSet R9 ) by L288 , L256;
thus L290: thesis by L289 , L255 , L254;
end;
theorem
L291: (for R9 being D_Lattice holds (for R11 being (Element of R9) holds (for R12 being (Element of R9) holds (R11 <> R12 implies (ex R10 being (Filter of R9) st R10 in ( F_primeSet R9 ))))))
proof
let R9 being D_Lattice;
let R11 being (Element of R9);
let R12 being (Element of R9);
assume L292: R11 <> R12;
L293: ((not R11 [= R12) or (not R12 [= R11)) by L292 , LATTICES:8;
L294: ((ex R10 being (Filter of R9) st (R10 in ( F_primeSet R9 ) & (not R12 in R10) & R11 in R10)) or (ex R10 being (Filter of R9) st (R10 in ( F_primeSet R9 ) & (not R11 in R10) & R12 in R10))) by L293 , L248;
thus L295: thesis by L294;
end;
theorem
L296: (for R9 being D_Lattice holds (for R11 being (Element of R9) holds (for R12 being (Element of R9) holds (R11 <> R12 implies ( ( StoneH R9 ) . R11 ) <> ( ( StoneH R9 ) . R12 )))))
proof
let R9 being D_Lattice;
let R11 being (Element of R9);
let R12 being (Element of R9);
assume L297: R11 <> R12;
L298: ((not R11 [= R12) or (not R12 [= R11)) by L297 , LATTICES:8;
L299: ((ex R10 being (Filter of R9) st (R10 in ( F_primeSet R9 ) & (not R12 in R10) & R11 in R10)) or (ex R10 being (Filter of R9) st (R10 in ( F_primeSet R9 ) & (not R11 in R10) & R12 in R10))) by L298 , L248;
consider R10 being (Filter of R9) such that L300: R10 in ( F_primeSet R9 ) and L301: ((R12 in R10 & (not R11 in R10)) or (R11 in R10 & (not R12 in R10))) by L299;
L302: ((R10 in ( ( StoneH R9 ) . R11 ) & (not R10 in ( ( StoneH R9 ) . R12 ))) or (R10 in ( ( StoneH R9 ) . R12 ) & (not R10 in ( ( StoneH R9 ) . R11 )))) by L300 , L301 , L106;
thus L303: thesis by L302;
end;
registration
let R9 being D_Lattice;
cluster ( StoneH R9 ) ->  one-to-one;
coherence
proof
let C36 , C37 being set;
assume that
L304: C36 in ( dom ( StoneH R9 ) )
and
L305: C37 in ( dom ( StoneH R9 ) )
and
L306: ( ( StoneH R9 ) . C36 ) = ( ( StoneH R9 ) . C37 );
reconsider D38 = C36 , D39 = C37 as (Element of R9) by L304 , L305 , L96;
L307: D38 = D39 by L306 , L296;
thus L308: thesis by L307;
end;
end;
definition
let R9 being D_Lattice;
let C38 , C39 being (Element of ( StoneS R9 ));
redefine func C38 \/ C39 -> (Element of ( StoneS R9 ));

coherence
proof
consider R12 being (Element of R9) such that L310: C39 = ( ( StoneH R9 ) . R12 ) by L130;
consider R11 being (Element of R9) such that L311: C38 = ( ( StoneH R9 ) . R11 ) by L130;
L312: ( C38 \/ C39 ) = ( ( StoneH R9 ) . ( R11 "\/" R12 ) ) by L311 , L310 , L140;
thus L313: thesis by L312 , L130;
end;
redefine func C38 /\ C39 -> (Element of ( StoneS R9 ));

coherence
proof
consider R12 being (Element of R9) such that L314: C39 = ( ( StoneH R9 ) . R12 ) by L130;
consider R11 being (Element of R9) such that L315: C38 = ( ( StoneH R9 ) . R11 ) by L130;
L316: ( C38 /\ C39 ) = ( ( StoneH R9 ) . ( R11 "/\" R12 ) ) by L315 , L314 , L159;
thus L317: thesis by L316 , L130;
end;
end;
definition
let R9 being D_Lattice;
func Set_Union R9 -> (BinOp of ( StoneS R9 )) means 
:L319: (for B26 , B27 being (Element of ( StoneS R9 )) holds ( it . (B26 , B27) ) = ( B26 \/ B27 ));
existence
proof
deffunc H6((Element of ( StoneS R9 )) , (Element of ( StoneS R9 ))) = ( $1 \/ $2 );
thus L320: (ex B28 being (BinOp of ( StoneS R9 )) st (for B29 , B30 being (Element of ( StoneS R9 )) holds ( B28 . (B29 , B30) ) = H6(B29 , B30))) from BINOP_1:sch 4;
end;
uniqueness
proof
set D40 = ( StoneS R9 );
deffunc H7((Element of D40) , (Element of D40)) = ( $1 \/ $2 );
thus L321: (for B31 , B32 being (BinOp of D40) holds (((for B33 , B34 being (Element of D40) holds ( B31 . (B33 , B34) ) = H7(B33 , B34)) & (for B35 , B36 being (Element of D40) holds ( B32 . (B35 , B36) ) = H7(B35 , B36))) implies B31 = B32)) from BINOP_2:sch 2;
end;
func Set_Meet R9 -> (BinOp of ( StoneS R9 )) means 
:L322: (for B37 , B38 being (Element of ( StoneS R9 )) holds ( it . (B37 , B38) ) = ( B37 /\ B38 ));
existence
proof
deffunc H8((Element of ( StoneS R9 )) , (Element of ( StoneS R9 ))) = ( $1 /\ $2 );
thus L323: (ex B39 being (BinOp of ( StoneS R9 )) st (for B40 , B41 being (Element of ( StoneS R9 )) holds ( B39 . (B40 , B41) ) = H8(B40 , B41))) from BINOP_1:sch 4;
end;
uniqueness
proof
set D41 = ( StoneS R9 );
deffunc H9((Element of D41) , (Element of D41)) = ( $1 /\ $2 );
thus L324: (for B42 , B43 being (BinOp of D41) holds (((for B44 , B45 being (Element of D41) holds ( B42 . (B44 , B45) ) = H9(B44 , B45)) & (for B46 , B47 being (Element of D41) holds ( B43 . (B46 , B47) ) = H9(B46 , B47))) implies B42 = B43)) from BINOP_2:sch 2;
end;
end;
theorem
L326: (for R9 being D_Lattice holds LattStr (# ( StoneS R9 ) , ( Set_Union R9 ) , ( Set_Meet R9 ) #) is Lattice)
proof
let R9 being D_Lattice;
set D42 = LattStr (# ( StoneS R9 ) , ( Set_Union R9 ) , ( Set_Meet R9 ) #);
L327:
now
let C40 , C41 being (Element of D42);
thus L328: ( C40 "\/" C41 ) = ( C41 \/ C40 ) by L319
.= ( C41 "\/" C40 ) by L319;
end;
L329:
now
let C42 , C43 being (Element of D42);
thus L330: ( ( C42 "/\" C43 ) "\/" C43 ) = ( ( C42 "/\" C43 ) \/ C43 ) by L319
.= ( ( C42 /\ C43 ) \/ C43 ) by L322
.= C43 by XBOOLE_1:22;
end;
L331:
now
let C44 , C45 being (Element of D42);
thus L332: ( C44 "/\" ( C44 "\/" C45 ) ) = ( C44 /\ ( C44 "\/" C45 ) ) by L322
.= ( C44 /\ ( C44 \/ C45 ) ) by L319
.= C44 by XBOOLE_1:21;
end;
L333:
now
let C46 , C47 , C48 being (Element of D42);
thus L334: ( C46 "/\" ( C47 "/\" C48 ) ) = ( C46 /\ ( C47 "/\" C48 ) ) by L322
.= ( C46 /\ ( C47 /\ C48 ) ) by L322
.= ( ( C46 /\ C47 ) /\ C48 ) by XBOOLE_1:16
.= ( ( C46 "/\" C47 ) /\ C48 ) by L322
.= ( ( C46 "/\" C47 ) "/\" C48 ) by L322;
end;
L335:
now
let C49 , C50 being (Element of D42);
thus L336: ( C49 "/\" C50 ) = ( C50 /\ C49 ) by L322
.= ( C50 "/\" C49 ) by L322;
end;
L337:
now
let C51 , C52 , C53 being (Element of D42);
thus L338: ( C51 "\/" ( C52 "\/" C53 ) ) = ( C51 \/ ( C52 "\/" C53 ) ) by L319
.= ( C51 \/ ( C52 \/ C53 ) ) by L319
.= ( ( C51 \/ C52 ) \/ C53 ) by XBOOLE_1:4
.= ( ( C51 "\/" C52 ) \/ C53 ) by L319
.= ( ( C51 "\/" C52 ) "\/" C53 ) by L319;
end;
L339: D42 is  join-commutative  join-associative  meet-absorbing  meet-commutative  meet-associative  join-absorbing by L337 , L327 , L329 , L335 , L333 , L331 , LATTICES:def 4 , LATTICES:def 5 , LATTICES:def 6 , LATTICES:def 7 , LATTICES:def 8 , LATTICES:def 9;
thus L340: thesis by L339;
end;
definition
let R9 being D_Lattice;
func StoneLatt R9 -> Lattice equals 
LattStr (# ( StoneS R9 ) , ( Set_Union R9 ) , ( Set_Meet R9 ) #);
coherence by L326;
end;
theorem
L342: (for R9 being D_Lattice holds (the carrier of ( StoneLatt R9 )) = ( StoneS R9 ));
theorem
L343: (for R9 being D_Lattice holds (for R19 being (Element of ( StoneLatt R9 )) holds (for R20 being (Element of ( StoneLatt R9 )) holds (( R19 "\/" R20 ) = ( R19 \/ R20 ) & ( R19 "/\" R20 ) = ( R19 /\ R20 ))))) by L319 , L322;
theorem
L344: (for R9 being D_Lattice holds (for R19 being (Element of ( StoneLatt R9 )) holds (for R20 being (Element of ( StoneLatt R9 )) holds (R19 [= R20 iff R19 c= R20))))
proof
let R9 being D_Lattice;
let R19 being (Element of ( StoneLatt R9 ));
let R20 being (Element of ( StoneLatt R9 ));
L345: (R19 [= R20 iff ( R19 "\/" R20 ) = R20) by LATTICES:def 3;
L346: ( R19 "\/" R20 ) = ( R19 \/ R20 ) by L319;
thus L347: thesis by L346 , L345 , XBOOLE_1:7 , XBOOLE_1:12;
end;
definition
let R9 being D_Lattice;
::$N Stone Representation Theorem for Heyting Lattices
redefine func StoneH R9 -> (Homomorphism of R9 , ( StoneLatt R9 ));

coherence
proof
L348: ( dom ( StoneH R9 ) ) = (the carrier of R9) by L96;
reconsider D43 = ( StoneH R9 ) as (Function of (the carrier of R9) , (the carrier of ( StoneLatt R9 ))) by L348 , FUNCT_2:1;
L349:
now
let R11 being (Element of R9);
let R12 being (Element of R9);
thus L350: ( D43 . ( R11 "\/" R12 ) ) = ( ( D43 . R11 ) \/ ( D43 . R12 ) ) by L140
.= ( ( D43 . R11 ) "\/" ( D43 . R12 ) ) by L319;
thus L351: ( D43 . ( R11 "/\" R12 ) ) = ( ( D43 . R11 ) /\ ( D43 . R12 ) ) by L159
.= ( ( D43 . R11 ) "/\" ( D43 . R12 ) ) by L322;
end;
thus L352: thesis by L349 , LATTICE4:def 1;
end;
end;
registration
let R9 being D_Lattice;
cluster ( StoneH R9 ) ->  bijective for (Function of R9 , ( StoneLatt R9 ));
coherence
proof
L354:
now
thus L355: ( StoneH R9 ) is  one-to-one;
thus L356: ( StoneH R9 ) is  onto
proof
thus L357: ( rng ( StoneH R9 ) ) = (the carrier of ( StoneLatt R9 ));
end;

end;
thus L357: thesis by L354 , FUNCT_2:def 4;
end;
cluster ( StoneLatt R9 ) ->  distributive;
coherence
proof
L358: ( StoneH R9 ) is  onto by FUNCT_2:def 3;
thus L359: thesis by L358 , LATTICE4:11;
end;
end;
theorem
L361: (for R9 being D_Lattice holds R9 , ( StoneLatt R9 ) are_isomorphic )
proof
let R9 being D_Lattice;
take ( StoneH R9 );
thus L362: thesis;
end;
registration
cluster non  trivial for H_Lattice;
existence
proof
set D44 = the non  empty TopSpace;
set D45 = ( Open_setLatt D44 );
L363: (the carrier of D44) = ( Top D45 ) by L87;
reconsider D46 = (the carrier of D44) as (Element of D45) by L363;
L364: ( {} ) = ( Bottom D45 ) by L77;
reconsider D47 = ( {} ) as (Element of D45) by L364;
take D45;
take D46;
take D47;
thus L365: thesis;
end;
end;
theorem
L367: (for R21 being non  trivial H_Lattice holds ( ( StoneH R21 ) . ( Top R21 ) ) = ( F_primeSet R21 ))
proof
let R21 being non  trivial H_Lattice;
thus L368:now
let R13 being set;
assume L369: R13 in ( ( StoneH R21 ) . ( Top R21 ) );
L370: (ex B48 being (Filter of R21) st (B48 = R13 & B48 <> (the carrier of R21) & B48 is  prime & ( Top R21 ) in B48)) by L369 , L110;
thus L371: R13 in ( F_primeSet R21 ) by L370;
end;
let R13 being set;
assume L372: R13 in ( F_primeSet R21 );
consider C54 being (Filter of R21) such that L373: C54 = R13 and L374: C54 <> (the carrier of R21) and L375: C54 is  prime by L372;
L376: ( Top R21 ) in C54 by FILTER_0:11;
thus L377: thesis by L376 , L373 , L374 , L375 , L110;
end;
theorem
L378: (for R21 being non  trivial H_Lattice holds ( ( StoneH R21 ) . ( Bottom R21 ) ) = ( {} ))
proof
let R21 being non  trivial H_Lattice;
set D48 = the (Element of ( ( StoneH R21 ) . ( Bottom R21 ) ));
assume L379: ( ( StoneH R21 ) . ( Bottom R21 ) ) <> ( {} );
L380: (ex B49 being (Filter of R21) st (B49 = D48 & B49 <> (the carrier of R21) & B49 is  prime & ( Bottom R21 ) in B49)) by L379 , L110;
thus L381: contradiction by L380 , FILTER_0:26;
end;
theorem
L382: (for R21 being non  trivial H_Lattice holds ( StoneS R21 ) c= ( bool ( F_primeSet R21 ) ))
proof
let R21 being non  trivial H_Lattice;
let R13 being set;
assume L383: R13 in ( StoneS R21 );
consider R22 being (Element of R21) such that L384: R13 = ( ( StoneH R21 ) . R22 ) by L383 , L130;
L385: R13 = { B50 where B50 is (Filter of R21) : (B50 in ( F_primeSet R21 ) & R22 in B50) } by L384 , L96;
L386: R13 c= ( F_primeSet R21 )
proof
let C55 being set;
assume L387: C55 in R13;
L388: (ex B51 being (Filter of R21) st (C55 = B51 & B51 in ( F_primeSet R21 ) & R22 in B51)) by L387 , L385;
thus L389: thesis by L388;
end;
thus L390: thesis by L386;
end;
registration
let R21 being non  trivial H_Lattice;
cluster ( F_primeSet R21 ) -> non  empty;
coherence
proof
L391: (ex R22 being (Element of R21) st (ex R23 being (Element of R21) st R22 <> R23)) by STRUCT_0:def 10;
L392: (ex B52 being (Filter of R21) st B52 in ( F_primeSet R21 )) by L391 , L291;
thus L393: thesis by L392;
end;
end;
definition
let R21 being non  trivial H_Lattice;
func HTopSpace R21 ->  strict TopStruct means 
:L395: ((the carrier of it) = ( F_primeSet R21 ) & (the topology of it) = { ( union B53 ) where B53 is (Subset of ( StoneS R21 )) : (not contradiction) });
existence
proof
set D49 = ( F_primeSet R21 );
set D50 = { ( union B54 ) where B54 is (Subset of ( StoneS R21 )) : (not contradiction) };
L396: ( StoneS R21 ) c= ( bool D49 ) by L382;
L397: D50 c= ( bool D49 )
proof
let R13 being set;
assume L398: R13 in D50;
consider C56 being (Subset of ( StoneS R21 )) such that L399: R13 = ( union C56 ) by L398;
L400: C56 c= ( bool D49 ) by L396 , XBOOLE_1:1;
L401: R13 c= ( union ( bool D49 ) ) by L400 , L399 , ZFMISC_1:77;
L402: R13 is (Subset of D49) by L401 , ZFMISC_1:81;
thus L403: thesis by L402;
end;
reconsider D51 = D50 as (Subset-Family of D49) by L397;
take TopStruct (# D49 , D51 #);
thus L404: thesis;
end;
uniqueness;
end;
registration
let R21 being non  trivial H_Lattice;
cluster ( HTopSpace R21 ) -> non  empty  TopSpace-like;
coherence
proof
reconsider D52 = { ( ( StoneH R21 ) . ( Top R21 ) ) } as (Subset of ( StoneS R21 ));
set D53 = ( HTopSpace R21 );
L406: (the topology of D53) = { ( union B55 ) where B55 is (Subset of ( StoneS R21 )) : (not contradiction) } by L395;
L407: (the carrier of D53) = ( F_primeSet R21 ) by L395;
thus L408: ( HTopSpace R21 ) is non  empty by L407;
L409: ( F_primeSet R21 ) = ( ( StoneH R21 ) . ( Top R21 ) ) by L367;
L410: ( F_primeSet R21 ) = ( union D52 ) by L409 , ZFMISC_1:25;
thus L411: (the carrier of D53) in (the topology of D53) by L410 , L407 , L406;
thus L412:now
let C57 being (Subset-Family of D53);
defpred S1[ set ] means ( union $1 ) in C57;
set D54 = { B56 where B56 is (Subset of ( StoneS R21 )) : S1[ B56 ] };
set D55 = { ( union B57 ) where B57 is (Subset of ( StoneS R21 )) : B57 in D54 };
assume L413: C57 c= (the topology of D53);
L414: C57 = D55
proof
thus L415:now
let R13 being set;
assume L416: R13 in C57;
L417: R13 in (the topology of D53) by L416 , L413;
consider C58 being (Subset of ( StoneS R21 )) such that L418: R13 = ( union C58 ) by L417 , L406;
L419: C58 in D54 by L416 , L418;
thus L420: R13 in D55 by L419 , L418;
end;
let R13 being set;
assume L421: R13 in D55;
consider C59 being (Subset of ( StoneS R21 )) such that L422: R13 = ( union C59 ) and L423: C59 in D54 by L421;
L424: (ex B58 being (Subset of ( StoneS R21 )) st (C59 = B58 & ( union B58 ) in C57)) by L423;
thus L425: thesis by L424 , L422;
end;
reconsider D56 = D54 as (Subset-Family of ( StoneS R21 )) from DOMAIN_1:sch 7;
L426: ( union ( union D56 ) ) = ( union C57 ) by L414 , EQREL_1:54;
thus L427: ( union C57 ) in (the topology of D53) by L426 , L406;
end;
let C60 , C61 being (Subset of D53);
assume that
L428: C60 in (the topology of D53)
and
L429: C61 in (the topology of D53);
consider C62 being (Subset of ( StoneS R21 )) such that L430: C60 = ( union C62 ) by L406 , L428;
consider C63 being (Subset of ( StoneS R21 )) such that L431: C61 = ( union C63 ) by L406 , L429;
L432: ( INTERSECTION (C62 , C63) ) c= ( StoneS R21 )
proof
let R13 being set;
assume L433: R13 in ( INTERSECTION (C62 , C63) );
consider C64 , C65 being set such that L434: C64 in C62 and L435: C65 in C63 and L436: R13 = ( C64 /\ C65 ) by L433 , SETFAM_1:def 5;
consider R22 being (Element of R21) such that L437: C64 = ( ( StoneH R21 ) . R22 ) by L434 , L130;
consider R23 being (Element of R21) such that L438: C65 = ( ( StoneH R21 ) . R23 ) by L435 , L130;
L439: R13 = ( ( StoneH R21 ) . ( R22 "/\" R23 ) ) by L436 , L437 , L438 , L159;
thus L440: thesis by L439;
end;
reconsider D57 = ( INTERSECTION (C62 , C63) ) as (Subset of ( StoneS R21 )) by L432;
L441: ( ( union C62 ) /\ ( union C63 ) ) = ( union D57 ) by SETFAM_1:28;
thus L442: thesis by L441 , L406 , L430 , L431;
end;
end;
theorem
L444: (for R21 being non  trivial H_Lattice holds (the carrier of ( Open_setLatt ( HTopSpace R21 ) )) = { ( union B59 ) where B59 is (Subset of ( StoneS R21 )) : (not contradiction) }) by L395;
theorem
L445: (for R21 being non  trivial H_Lattice holds ( StoneS R21 ) c= (the carrier of ( Open_setLatt ( HTopSpace R21 ) )))
proof
let R21 being non  trivial H_Lattice;
let R13 being set;
set D58 = (the carrier of ( Open_setLatt ( HTopSpace R21 ) ));
assume L446: R13 in ( StoneS R21 );
reconsider D59 = { R13 } as (Subset of ( StoneS R21 )) by L446 , ZFMISC_1:31;
L447: ( union D59 ) = R13 by ZFMISC_1:25;
L448: D58 = { ( union B60 ) where B60 is (Subset of ( StoneS R21 )) : (not contradiction) } by L395;
thus L449: thesis by L448 , L447;
end;
definition
let R21 being non  trivial H_Lattice;
redefine func StoneH R21 -> (Homomorphism of R21 , ( Open_setLatt ( HTopSpace R21 ) ));

coherence
proof
set D60 = ( Open_setLatt ( HTopSpace R21 ) );
reconsider D61 = ( StoneH R21 ) as (Function of (the carrier of R21) , (the carrier of ( StoneLatt R21 )));
L450: ( StoneS R21 ) c= (the carrier of D60) by L445;
reconsider D62 = D61 as (Function of (the carrier of R21) , (the carrier of D60)) by L450 , FUNCT_2:6;
L451:
now
let R22 being (Element of R21);
let R23 being (Element of R21);
thus L452: ( D62 . ( R22 "\/" R23 ) ) = ( ( ( StoneH R21 ) . R22 ) \/ ( ( StoneH R21 ) . R23 ) ) by L140
.= ( ( D62 . R22 ) "\/" ( D62 . R23 ) ) by L28;
thus L453: ( D62 . ( R22 "/\" R23 ) ) = ( ( ( StoneH R21 ) . R22 ) /\ ( ( StoneH R21 ) . R23 ) ) by L159
.= ( ( D62 . R22 ) "/\" ( D62 . R23 ) ) by L31;
end;
thus L454: thesis by L451 , LATTICE4:def 1;
end;
end;
theorem
L456: (for R21 being non  trivial H_Lattice holds (for R22 being (Element of R21) holds (for R23 being (Element of R21) holds ( ( StoneH R21 ) . ( R22 => R23 ) ) = ( ( ( StoneH R21 ) . R22 ) => ( ( StoneH R21 ) . R23 ) ))))
proof
let R21 being non  trivial H_Lattice;
let R22 being (Element of R21);
let R23 being (Element of R21);
L457: (the carrier of ( Open_setLatt ( HTopSpace R21 ) )) = { ( union B61 ) where B61 is (Subset of ( StoneS R21 )) : (not contradiction) } by L395;
L458:
now
let C66 being (Element of ( Open_setLatt ( HTopSpace R21 ) ));
L459: C66 in (the carrier of ( Open_setLatt ( HTopSpace R21 ) ));
consider C67 being (Subset of ( StoneS R21 )) such that L460: C66 = ( union C67 ) by L459 , L457;
assume L461: ( ( ( StoneH R21 ) . R22 ) "/\" C66 ) [= ( ( StoneH R21 ) . R23 );
L462: ( ( ( StoneH R21 ) . R22 ) "/\" C66 ) c= ( ( StoneH R21 ) . R23 ) by L461 , L53;
L463: ( ( ( StoneH R21 ) . R22 ) /\ ( union C67 ) ) c= ( ( StoneH R21 ) . R23 ) by L462 , L460 , L31;
L464: ( union ( INTERSECTION ({ ( ( StoneH R21 ) . R22 ) } , C67) ) ) c= ( ( StoneH R21 ) . R23 ) by L463 , SETFAM_1:25;
L465:
now
let R13 being set;
assume L466: R13 in C67;
consider C68 being (Element of R21) such that L467: R13 = ( ( StoneH R21 ) . C68 ) by L466 , L130;
L468: ( ( StoneH R21 ) . R22 ) in { ( ( StoneH R21 ) . R22 ) } by TARSKI:def 1;
L469: ( ( ( StoneH R21 ) . R22 ) /\ R13 ) in ( INTERSECTION ({ ( ( StoneH R21 ) . R22 ) } , C67) ) by L468 , L466 , SETFAM_1:def 5;
L470: ( ( ( StoneH R21 ) . R22 ) /\ ( ( StoneH R21 ) . C68 ) ) c= ( ( StoneH R21 ) . R23 ) by L469 , L464 , L467 , SETFAM_1:41;
L471: ( ( StoneH R21 ) . ( R22 "/\" C68 ) ) c= ( ( StoneH R21 ) . R23 ) by L470 , L159;
L472: ( ( StoneH R21 ) . ( R22 "/\" C68 ) ) [= ( ( StoneH R21 ) . R23 ) by L471 , L53;
L473: ( R22 "/\" C68 ) [= R23 by L472 , LATTICE4:5;
L474: C68 [= ( R22 => R23 ) by L473 , FILTER_0:def 7;
L475: ( ( StoneH R21 ) . C68 ) [= ( ( StoneH R21 ) . ( R22 => R23 ) ) by L474 , LATTICE4:4;
thus L476: R13 c= ( ( StoneH R21 ) . ( R22 => R23 ) ) by L475 , L467 , L53;
end;
L477: ( union C67 ) c= ( ( StoneH R21 ) . ( R22 => R23 ) ) by L465 , ZFMISC_1:76;
thus L478: C66 [= ( ( StoneH R21 ) . ( R22 => R23 ) ) by L477 , L460 , L53;
end;
L479: ( R22 "/\" ( R22 => R23 ) ) [= R23 by FILTER_0:def 7;
L480: ( ( StoneH R21 ) . ( R22 "/\" ( R22 => R23 ) ) ) [= ( ( StoneH R21 ) . R23 ) by L479 , LATTICE4:4;
L481: ( ( ( StoneH R21 ) . R22 ) "/\" ( ( StoneH R21 ) . ( R22 => R23 ) ) ) [= ( ( StoneH R21 ) . R23 ) by L480 , LATTICE4:def 1;
thus L482: thesis by L481 , L458 , FILTER_0:def 7;
end;
theorem
L483: (for R21 being non  trivial H_Lattice holds ( StoneH R21 ) preserves_implication )
proof
let R21 being non  trivial H_Lattice;
L484: (for R22 being (Element of R21) holds (for R23 being (Element of R21) holds ( ( StoneH R21 ) . ( R22 => R23 ) ) = ( ( ( StoneH R21 ) . R22 ) => ( ( StoneH R21 ) . R23 ) ))) by L456;
thus L485: thesis by L484 , LATTICE4:def 3;
end;
theorem
L486: (for R21 being non  trivial H_Lattice holds ( StoneH R21 ) preserves_top )
proof
let R21 being non  trivial H_Lattice;
L487: ( ( StoneH R21 ) . ( Top R21 ) ) = ( F_primeSet R21 ) by L367
.= (the carrier of ( HTopSpace R21 )) by L395
.= ( Top ( Open_setLatt ( HTopSpace R21 ) ) ) by L87;
thus L488: thesis by L487 , LATTICE4:def 4;
end;
theorem
L489: (for R21 being non  trivial H_Lattice holds ( StoneH R21 ) preserves_bottom )
proof
let R21 being non  trivial H_Lattice;
L490: ( ( StoneH R21 ) . ( Bottom R21 ) ) = ( {} ) by L378
.= ( Bottom ( Open_setLatt ( HTopSpace R21 ) ) ) by L77;
thus L491: thesis by L490 , LATTICE4:def 5;
end;
