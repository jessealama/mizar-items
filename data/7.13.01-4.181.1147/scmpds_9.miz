:: SCMPDS Is Not Standard
::  by Artur Korni{\l}owicz and Yasunari Shidama
::
:: Received September 27, 2003
:: Copyright (c) 2003-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SCMPDS_2, AMI_1, INT_1, FUNCOP_1, SUBSET_1, FSM_1,
      FUNCT_1, AMISTD_1, FUNCT_4, XBOOLE_0, SETFAM_1, AMI_3, COMPLEX1, ARYTM_3,
      ORDINAL1, XXREAL_0, ARYTM_1, CARD_1, AMI_2, RELAT_1, GRAPHSP, TARSKI,
      FINSET_1, XREAL_0, CARD_3, AMI_WSTD, NAT_1, GOBRD13, MEMSTR_0;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, ORDINAL1, CARD_3, NUMBERS,
      XCMPLX_0, XXREAL_0, XREAL_0, FUNCT_1, INT_1, NAT_1, FINSET_1, COMPLEX1,
      INT_2, RELAT_1, FUNCT_4, MEMSTR_0, COMPOS_1, EXTPRO_1, AMI_2, SCMPDS_2,
      SCMPDS_3, AMISTD_1, AMI_WSTD;
 constructors REAL_1, NAT_D, SCMPDS_1, SCMPDS_3, AMI_WSTD, PRE_POLY, AMISTD_1,
      FUNCT_4, FUNCT_7;
 registrations XXREAL_0, XREAL_0, NAT_1, INT_1, MEMBERED, CARD_3, SCMPDS_2,
      FUNCT_1, XBOOLE_0, FUNCT_4, MEMSTR_0, AMI_3;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;
 definitions TARSKI, XBOOLE_0, NAT_1, AMISTD_1, MEMSTR_0, SCMPDS_2;
 theorems AMI_WSTD, SETFAM_1, XBOOLE_0, SCMPDS_2, ABSVALUE, INT_1, TARSKI,
      AMI_2, NAT_1, XBOOLE_1, FUNCT_4, PRE_CIRC, WSIERP_1, PEPIN, COMPLEX1,
      XREAL_1, FUNCT_7, NAT_D, ZFMISC_1, AMISTD_1, MEMSTR_0, CARD_3, SCMPDS_I,
      XTUPLE_0;

begin
definition
let C1 , C2 being Int_position;
let C3 , C4 being Integer;
redefine func (C1 , C2) --> (C3 , C4) -> (PartState of ( SCMPDS ));

coherence
proof
L1: (( Values C1 ) = ( INT ) & ( Values C2 ) = ( INT )) by SCMPDS_2:5;
L2: (C3 is (Element of ( INT )) & C4 is (Element of ( INT ))) by INT_1:def 2;
reconsider D1 = C3 as (Element of ( Values C1 )) by L1 , L2;
reconsider D2 = C4 as (Element of ( Values C2 )) by L1 , L2;
L3: ( (C1 , C2) --> (D1 , D2) ) is (PartState of ( SCMPDS ));
thus L4: thesis by L3;
end;
end;
L6: (for R5 being Integer holds ( JUMP ( goto R5 ) ) = ( {} ))
proof
let R5 being Integer;
set D3 = ( goto R5 );
set D4 = { ( NIC (D3 , B1) ) where B1 is (Element of ( NAT )) : (not contradiction) };
thus L7:now
set D5 = 1;
set D6 = ( 0 );
let C5 being set;
assume L8: C5 in ( JUMP D3 );
L9: ( NIC (D3 , D5) ) in D4;
L10: C5 in ( NIC (D3 , D5) ) by L9 , L8 , SETFAM_1:def 1;
consider C6 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L11: C5 = ( IC ( Exec (D3 , C6) ) ) and L12: ( IC C6 ) = D5 by L10;
consider C7 being (Element of ( NAT )) such that L13: C7 = ( IC C6 ) and L14: ( ICplusConst (C6 , R5) ) = ( abs ( C7 + R5 ) ) by SCMPDS_2:def 18;
L15: ( NIC (D3 , D6) ) in D4;
L16: C5 in ( NIC (D3 , D6) ) by L15 , L8 , SETFAM_1:def 1;
consider C8 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L17: C5 = ( IC ( Exec (D3 , C8) ) ) and L18: ( IC C8 ) = D6 by L16;
consider C9 being (Element of ( NAT )) such that L19: C9 = ( IC C8 ) and L20: ( ICplusConst (C8 , R5) ) = ( abs ( C9 + R5 ) ) by SCMPDS_2:def 18;
L21: C5 = ( abs ( C9 + R5 ) ) by L17 , L20 , SCMPDS_2:54;
per cases  by L18 , L19 , L21 , L12 , L13 , L11 , L14 , ABSVALUE:28 , SCMPDS_2:54;
suppose L22: ( ( 0 ) + R5 ) = ( 1 + R5 );

thus L23: C5 in ( {} ) by L22;
end;
suppose L24: R5 = ( - ( 1 + R5 ) );

L25: ( - ( - ( 1 / 2 ) ) ) is  integer by L24;
thus L26: C5 in ( {} ) by L25 , NAT_D:33;
end;
end;
thus L28: thesis by XBOOLE_1:2;
end;
registration
let R5 being Integer;
cluster ( JUMP ( goto R5 ) ) ->  empty;
coherence by L6;
end;
theorem
L30: (for R3 being (Instruction of ( SCMPDS )) holds (for R4 being (Element of ( NAT )) holds ((for B2 being (State of ( SCMPDS )) holds (( IC B2 ) = R4 implies ( ( Exec (R3 , B2) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC B2 ) ))) implies ( NIC (R3 , R4) ) = { ( succ R4 ) })))
proof
let R3 being (Instruction of ( SCMPDS ));
let R4 being (Element of ( NAT ));
reconsider D7 = R3 as (Instruction of ( SCMPDS ));
reconsider D8 = R4 as (Element of ( NAT ));
assume L31: (for B3 being (State of ( SCMPDS )) holds (( IC B3 ) = R4 implies ( ( Exec (R3 , B3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC B3 ) )));
thus L32:now
let C10 being set;
assume L33: C10 in ( NIC (R3 , R4) );
consider C11 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L34: C10 = ( IC ( Exec (R3 , C11) ) ) and L35: ( IC C11 ) = R4 by L33;
L36: C10 = ( succ R4 ) by L31 , L34 , L35;
thus L37: C10 in { ( succ R4 ) } by L36 , TARSKI:def 1;
end;
set D9 = the R4 -started (State of ( SCMPDS ));
reconsider D10 = the R4 -started (State of ( SCMPDS )) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
L38: ( IC D10 ) = R4 by MEMSTR_0:def 11;
let C12 being set;
assume L39: C12 in { ( succ R4 ) };
L40: C12 = ( succ R4 ) by L39 , TARSKI:def 1;
L41: ( IC ( Exec (D7 , D10) ) ) = ( succ R4 ) by L31 , L38;
thus L42: thesis by L41 , L40 , L38;
end;
theorem
L43: (for R3 being (Instruction of ( SCMPDS )) holds ((for B4 being (Element of ( NAT )) holds ( NIC (R3 , B4) ) = { ( succ B4 ) }) implies ( JUMP R3 ) is  empty))
proof
let R3 being (Instruction of ( SCMPDS ));
set D11 = 1;
set D12 = 2;
assume L44: (for B5 being (Element of ( NAT )) holds ( NIC (R3 , B5) ) = { ( succ B5 ) });
set D13 = { ( NIC (R3 , B6) ) where B6 is (Element of ( NAT )) : (not contradiction) };
reconsider D14 = D11 , D15 = D12 as (Element of ( NAT ));
assume L45: (not thesis);
consider C13 being set such that L46: C13 in ( meet D13 ) by L45 , XBOOLE_0:def 1;
L47: ( NIC (R3 , D14) ) = { ( succ D14 ) } by L44;
L48: { ( succ D14 ) } in D13 by L47;
L49: C13 in { ( succ D14 ) } by L48 , L46 , SETFAM_1:def 1;
L50: C13 = ( succ D14 ) by L49 , TARSKI:def 1;
L51: ( NIC (R3 , D15) ) = { ( succ D15 ) } by L44;
L52: { ( succ D15 ) } in D13 by L51;
L53: C13 in { ( succ D15 ) } by L52 , L46 , SETFAM_1:def 1;
thus L54: contradiction by L53 , L50 , TARSKI:def 1;
end;
theorem
L55: (for R4 being (Element of ( NAT )) holds (for R5 being Integer holds ( NIC (( goto R5 ) , R4) ) = { ( abs ( R5 + R4 ) ) }))
proof
let R4 being (Element of ( NAT ));
let R5 being Integer;
set D16 = the (State of ( SCMPDS ));
set D17 = ( goto R5 );
set D18 = ( abs ( R5 + R4 ) );
set D19 = D17;
reconsider D20 = R4 as (Element of ( NAT ));
thus L56:now
let C14 being set;
assume L57: C14 in ( NIC (D17 , R4) );
consider C15 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L58: C14 = ( IC ( Exec (D17 , C15) ) ) and L59: ( IC C15 ) = R4 by L57;
L60: (ex B7 being (Element of ( NAT )) st (B7 = ( IC C15 ) & ( ICplusConst (C15 , R5) ) = ( abs ( B7 + R5 ) ))) by SCMPDS_2:def 18;
L61: C14 = D18 by L58 , L59 , L60 , SCMPDS_2:54;
thus L62: C14 in { D18 } by L61 , TARSKI:def 1;
end;
let C16 being set;
reconsider D21 = the D20 -started (State of ( SCMPDS )) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
L63: ( IC D21 ) = D20 by MEMSTR_0:def 11;
consider C17 being (Element of ( NAT )) such that L64: C17 = ( IC D21 ) and L65: ( ICplusConst (D21 , R5) ) = ( abs ( C17 + R5 ) ) by SCMPDS_2:def 18;
assume L66: C16 in { D18 };
L67: C16 = ( abs ( C17 + R5 ) ) by L66 , L63 , L64 , TARSKI:def 1
.= ( IC ( Exec (D17 , D21) ) ) by L65 , SCMPDS_2:54;
thus L68: thesis by L67 , L63;
end;
L69: (for B8 being Nat holds (B8 > 1 implies ( B8 - 2 ) is (Element of ( NAT ))))
proof
let C18 being Nat;
assume L70: C18 > 1;
L71: C18 >= ( 1 + 1 ) by L70 , NAT_1:13;
L72: ( C18 - 2 ) >= ( 2 - 2 ) by L71 , XREAL_1:9;
thus L73: thesis by L72 , INT_1:3;
end;
theorem
L74: (for R1 being Int_position holds (for R4 being (Element of ( NAT )) holds ( NIC (( return R1 ) , R4) ) = { B9 where B9 is (Element of ( NAT )) : B9 > 1 }))
proof
let R1 being Int_position;
let R4 being (Element of ( NAT ));
set D22 = the (State of ( SCMPDS ));
set D23 = { B10 where B10 is (Element of ( NAT )) : B10 > 1 };
set D24 = ( return R1 );
thus L75:now
let C19 being set;
assume L76: C19 in ( NIC (D24 , R4) );
consider C20 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L77: C19 = ( IC ( Exec (D24 , C20) ) ) and L78: ( IC C20 ) = R4 by L76;
reconsider D25 = C19 as (Element of ( NAT )) by L77;
L79: ( ( abs ( C20 . ( DataLoc (( C20 . R1 ) , 1) ) ) ) + 2 ) >= ( ( 0 ) + 2 ) by XREAL_1:6;
L80: D25 >= ( 1 + 1 ) by L79 , L77 , SCMPDS_2:58 , SCMPDS_I:def 14;
L81: D25 > 1 by L80 , NAT_1:13;
thus L82: C19 in D23 by L81;
end;
let C21 being set;
set D26 = D24;
reconsider D27 = R4 as (Element of ( NAT ));
assume L83: C21 in D23;
consider C22 being (Element of ( NAT )) such that L84: C21 = C22 and L85: C22 > 1 by L83;
reconsider D28 = ( C22 - 2 ) as (Element of ( NAT )) by L85 , L69;
reconsider D29 = the D27 -started (State of ( SCMPDS )) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
L86: ( IC D29 ) = D27 by MEMSTR_0:def 11;
L87: R1 in ( SCM-Data-Loc ) by AMI_2:def 16;
consider C23 being (Element of ( NAT )) such that L88: R1 = [ 1 , C23 ] by L87 , AMI_2:23;
set D30 = [ 1 , ( C23 + 1 ) ];
L89: D30 in ( SCM-Data-Loc ) by AMI_2:24;
reconsider D31 = D30 as Int_position by L89 , AMI_2:def 16;
L90: ( DataLoc (C23 , 1) ) = [ 1 , ( abs ( C23 + 1 ) ) ]
.= D30 by ABSVALUE:def 1;
set D32 = ( (R1 , D31) --> (C23 , D28) );
reconsider D33 = ( D29 +* D32 ) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
L91: ( dom D32 ) = { R1 , D30 } by FUNCT_4:62;
L92: C23 <> ( C23 + 1 );
L93: R1 <> D30 by L92 , L88 , XTUPLE_0:1;
L94: ( D33 . R1 ) = C23 by L93 , FUNCT_4:84;
L95: (R1 <> ( IC ( SCMPDS ) ) & D31 <> ( IC ( SCMPDS ) )) by SCMPDS_2:43;
L96: (not ( IC ( SCMPDS ) ) in ( dom D32 )) by L95 , L91 , TARSKI:def 2;
L97: ( IC D33 ) = R4 by L86 , L96 , FUNCT_4:11;
L98: ( D33 . D30 ) = D28 by L93 , FUNCT_4:84;
L99: C21 = ( D28 + 2 ) by L84
.= ( ( abs ( D33 . ( DataLoc (C23 , 1) ) ) ) + 2 ) by L98 , L90 , ABSVALUE:def 1
.= ( IC ( Exec (D24 , D33) ) ) by L94 , SCMPDS_2:58 , SCMPDS_I:def 14;
thus L100: thesis by L99 , L97;
end;
theorem
L101: (for R1 being Int_position holds (for R4 being (Element of ( NAT )) holds (for R6 being Integer holds ( NIC (( saveIC (R1 , R6) ) , R4) ) = { ( succ R4 ) })))
proof
let R1 being Int_position;
let R4 being (Element of ( NAT ));
let R6 being Integer;
set D34 = ( saveIC (R1 , R6) );
L102: (for B11 being (State of ( SCMPDS )) holds (( IC B11 ) = R4 implies ( ( Exec (D34 , B11) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC B11 ) ))) by SCMPDS_2:59;
thus L103: thesis by L102 , L30;
end;
theorem
L104: (for R1 being Int_position holds (for R4 being (Element of ( NAT )) holds (for R6 being Integer holds ( NIC (( R1 := R6 ) , R4) ) = { ( succ R4 ) })))
proof
let R1 being Int_position;
let R4 being (Element of ( NAT ));
let R6 being Integer;
set D35 = ( R1 := R6 );
L105: (for B12 being (State of ( SCMPDS )) holds (( IC B12 ) = R4 implies ( ( Exec (D35 , B12) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC B12 ) ))) by SCMPDS_2:45;
thus L106: thesis by L105 , L30;
end;
theorem
L107: (for R1 being Int_position holds (for R4 being (Element of ( NAT )) holds (for R6 being Integer holds (for R7 being Integer holds ( NIC (( (R1 , R6) := R7 ) , R4) ) = { ( succ R4 ) }))))
proof
let R1 being Int_position;
let R4 being (Element of ( NAT ));
let R6 being Integer;
let R7 being Integer;
set D36 = ( (R1 , R6) := R7 );
L108: (for B13 being (State of ( SCMPDS )) holds (( IC B13 ) = R4 implies ( ( Exec (D36 , B13) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC B13 ) ))) by SCMPDS_2:46;
thus L109: thesis by L108 , L30;
end;
theorem
L110: (for R1 being Int_position holds (for R2 being Int_position holds (for R4 being (Element of ( NAT )) holds (for R6 being Integer holds (for R7 being Integer holds ( NIC (( (R1 , R6) := (R2 , R7) ) , R4) ) = { ( succ R4 ) })))))
proof
let R1 being Int_position;
let R2 being Int_position;
let R4 being (Element of ( NAT ));
let R6 being Integer;
let R7 being Integer;
set D37 = ( (R1 , R6) := (R2 , R7) );
L111: (for B14 being (State of ( SCMPDS )) holds (( IC B14 ) = R4 implies ( ( Exec (D37 , B14) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC B14 ) ))) by SCMPDS_2:47;
thus L112: thesis by L111 , L30;
end;
theorem
L113: (for R1 being Int_position holds (for R4 being (Element of ( NAT )) holds (for R6 being Integer holds (for R7 being Integer holds ( NIC (( AddTo (R1 , R6 , R7) ) , R4) ) = { ( succ R4 ) }))))
proof
let R1 being Int_position;
let R4 being (Element of ( NAT ));
let R6 being Integer;
let R7 being Integer;
set D38 = ( AddTo (R1 , R6 , R7) );
L114: (for B15 being (State of ( SCMPDS )) holds (( IC B15 ) = R4 implies ( ( Exec (D38 , B15) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC B15 ) ))) by SCMPDS_2:48;
thus L115: thesis by L114 , L30;
end;
theorem
L116: (for R1 being Int_position holds (for R2 being Int_position holds (for R4 being (Element of ( NAT )) holds (for R6 being Integer holds (for R7 being Integer holds ( NIC (( AddTo (R1 , R6 , R2 , R7) ) , R4) ) = { ( succ R4 ) })))))
proof
let R1 being Int_position;
let R2 being Int_position;
let R4 being (Element of ( NAT ));
let R6 being Integer;
let R7 being Integer;
set D39 = ( AddTo (R1 , R6 , R2 , R7) );
L117: (for B16 being (State of ( SCMPDS )) holds (( IC B16 ) = R4 implies ( ( Exec (D39 , B16) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC B16 ) ))) by SCMPDS_2:49;
thus L118: thesis by L117 , L30;
end;
theorem
L119: (for R1 being Int_position holds (for R2 being Int_position holds (for R4 being (Element of ( NAT )) holds (for R6 being Integer holds (for R7 being Integer holds ( NIC (( SubFrom (R1 , R6 , R2 , R7) ) , R4) ) = { ( succ R4 ) })))))
proof
let R1 being Int_position;
let R2 being Int_position;
let R4 being (Element of ( NAT ));
let R6 being Integer;
let R7 being Integer;
set D40 = ( SubFrom (R1 , R6 , R2 , R7) );
L120: (for B17 being (State of ( SCMPDS )) holds (( IC B17 ) = R4 implies ( ( Exec (D40 , B17) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC B17 ) ))) by SCMPDS_2:50;
thus L121: thesis by L120 , L30;
end;
theorem
L122: (for R1 being Int_position holds (for R2 being Int_position holds (for R4 being (Element of ( NAT )) holds (for R6 being Integer holds (for R7 being Integer holds ( NIC (( MultBy (R1 , R6 , R2 , R7) ) , R4) ) = { ( succ R4 ) })))))
proof
let R1 being Int_position;
let R2 being Int_position;
let R4 being (Element of ( NAT ));
let R6 being Integer;
let R7 being Integer;
set D41 = ( MultBy (R1 , R6 , R2 , R7) );
L123: (for B18 being (State of ( SCMPDS )) holds (( IC B18 ) = R4 implies ( ( Exec (D41 , B18) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC B18 ) ))) by SCMPDS_2:51;
thus L124: thesis by L123 , L30;
end;
theorem
L125: (for R1 being Int_position holds (for R2 being Int_position holds (for R4 being (Element of ( NAT )) holds (for R6 being Integer holds (for R7 being Integer holds ( NIC (( Divide (R1 , R6 , R2 , R7) ) , R4) ) = { ( succ R4 ) })))))
proof
let R1 being Int_position;
let R2 being Int_position;
let R4 being (Element of ( NAT ));
let R6 being Integer;
let R7 being Integer;
set D42 = ( Divide (R1 , R6 , R2 , R7) );
L126: (for B19 being (State of ( SCMPDS )) holds (( IC B19 ) = R4 implies ( ( Exec (D42 , B19) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC B19 ) ))) by SCMPDS_2:52;
thus L127: thesis by L126 , L30;
end;
theorem
L128: (for R1 being Int_position holds (for R4 being (Element of ( NAT )) holds (for R6 being Integer holds (for R7 being Integer holds ( NIC (( (R1 , R6) <>0_goto R7 ) , R4) ) = { ( succ R4 ) , ( abs ( R7 + R4 ) ) }))))
proof
let R1 being Int_position;
let R4 being (Element of ( NAT ));
let R6 being Integer;
let R7 being Integer;
set D43 = the (State of ( SCMPDS ));
set D44 = ( (R1 , R6) <>0_goto R7 );
set D45 = ( abs ( R7 + R4 ) );
set D46 = D44;
reconsider D47 = R4 as (Element of ( NAT ));
reconsider D48 = the D47 -started (State of ( SCMPDS )) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
thus L129:now
let C24 being set;
assume L130: C24 in ( NIC (D44 , R4) );
consider C25 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L131: C24 = ( IC ( Exec (D44 , C25) ) ) and L132: ( IC C25 ) = R4 by L130;
L133: (ex B20 being (Element of ( NAT )) st (B20 = ( IC C25 ) & ( ICplusConst (C25 , R7) ) = ( abs ( B20 + R7 ) ))) by SCMPDS_2:def 18;
per cases ;
suppose L134: ( C25 . ( DataLoc (( C25 . R1 ) , R6) ) ) <> ( 0 );

L135: C24 = D45 by L131 , L132 , L133 , L134 , SCMPDS_2:55;
thus L136: C24 in { ( succ R4 ) , D45 } by L135 , TARSKI:def 2;
end;
suppose L137: ( C25 . ( DataLoc (( C25 . R1 ) , R6) ) ) = ( 0 );

L138: C24 = ( succ R4 ) by L131 , L132 , L137 , SCMPDS_2:55;
thus L139: C24 in { ( succ R4 ) , D45 } by L138 , TARSKI:def 2;
end;
end;
let C26 being set;
assume L141: C26 in { ( succ R4 ) , D45 };
per cases  by L141 , TARSKI:def 2;
suppose L142: C26 = ( succ R4 );

reconsider D49 = ( D48 +* ( R1 .--> ( 0 ) ) ) as (State of ( SCMPDS ));
reconsider D50 = ( D49 +* ( ( DataLoc (( D49 . R1 ) , R6) ) .--> ( 0 ) ) ) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
L143: ( IC D50 ) = ( D49 . ( IC ( SCMPDS ) ) ) by FUNCT_4:83 , SCMPDS_2:43
.= ( IC D48 ) by FUNCT_4:83 , SCMPDS_2:43
.= D47 by MEMSTR_0:def 11;
L144: ( D50 . ( DataLoc (( D49 . R1 ) , R6) ) ) = ( 0 ) by FUNCT_7:94;
L145: ( D50 . ( DataLoc (( D50 . R1 ) , R6) ) ) = ( 0 )
proof
per cases ;
suppose L146: R1 = ( DataLoc (( D49 . R1 ) , R6) );

thus L147: thesis by L146 , L144 , FUNCT_7:94;
end;
suppose L148: R1 <> ( DataLoc (( D49 . R1 ) , R6) );

L149: ( D50 . R1 ) = ( D49 . R1 ) by L148 , FUNCT_4:83;
thus L150: thesis by L149 , FUNCT_7:94;
end;
end;
L152: C26 = ( IC ( Exec (D44 , D50) ) ) by L145 , L142 , L143 , SCMPDS_2:55;
thus L153: thesis by L152 , L143;
end;
suppose L154: C26 = D45;

reconsider D51 = ( D48 +* ( R1 .--> 1 ) ) as (State of ( SCMPDS ));
reconsider D52 = ( D51 +* ( ( DataLoc (( D51 . R1 ) , R6) ) .--> 1 ) ) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
L155: ( D52 . ( DataLoc (( D51 . R1 ) , R6) ) ) = 1 by FUNCT_7:94;
L156: ( D52 . ( DataLoc (( D52 . R1 ) , R6) ) ) <> ( 0 )
proof
per cases ;
suppose L157: R1 = ( DataLoc (( D51 . R1 ) , R6) );

thus L158: thesis by L157 , L155 , FUNCT_7:94;
end;
suppose L159: R1 <> ( DataLoc (( D51 . R1 ) , R6) );

L160: ( D52 . R1 ) = ( D51 . R1 ) by L159 , FUNCT_4:83;
thus L161: thesis by L160 , FUNCT_7:94;
end;
end;
L163: ( IC D52 ) = ( D51 . ( IC ( SCMPDS ) ) ) by FUNCT_4:83 , SCMPDS_2:43
.= ( IC D48 ) by FUNCT_4:83 , SCMPDS_2:43
.= D47 by MEMSTR_0:def 11;
L164: (ex B21 being (Element of ( NAT )) st (B21 = ( IC D52 ) & ( ICplusConst (D52 , R7) ) = ( abs ( B21 + R7 ) ))) by SCMPDS_2:def 18;
L165: C26 = ( IC ( Exec (D44 , D52) ) ) by L164 , L154 , L163 , L156 , SCMPDS_2:55;
thus L166: thesis by L165 , L163;
end;
end;
theorem
L168: (for R1 being Int_position holds (for R4 being (Element of ( NAT )) holds (for R6 being Integer holds (for R7 being Integer holds ( NIC (( (R1 , R6) <=0_goto R7 ) , R4) ) = { ( succ R4 ) , ( abs ( R7 + R4 ) ) }))))
proof
let R1 being Int_position;
let R4 being (Element of ( NAT ));
let R6 being Integer;
let R7 being Integer;
set D53 = the (State of ( SCMPDS ));
set D54 = ( (R1 , R6) <=0_goto R7 );
set D55 = ( abs ( R7 + R4 ) );
set D56 = D54;
reconsider D57 = R4 as (Element of ( NAT ));
reconsider D58 = the D57 -started (State of ( SCMPDS )) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
thus L169:now
let C27 being set;
assume L170: C27 in ( NIC (D54 , R4) );
consider C28 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L171: C27 = ( IC ( Exec (D54 , C28) ) ) and L172: ( IC C28 ) = R4 by L170;
L173: (ex B22 being (Element of ( NAT )) st (B22 = ( IC C28 ) & ( ICplusConst (C28 , R7) ) = ( abs ( B22 + R7 ) ))) by SCMPDS_2:def 18;
per cases ;
suppose L174: ( C28 . ( DataLoc (( C28 . R1 ) , R6) ) ) <= ( 0 );

L175: C27 = D55 by L171 , L172 , L173 , L174 , SCMPDS_2:56;
thus L176: C27 in { ( succ R4 ) , D55 } by L175 , TARSKI:def 2;
end;
suppose L177: ( C28 . ( DataLoc (( C28 . R1 ) , R6) ) ) > ( 0 );

L178: C27 = ( succ R4 ) by L171 , L172 , L177 , SCMPDS_2:56;
thus L179: C27 in { ( succ R4 ) , D55 } by L178 , TARSKI:def 2;
end;
end;
let C29 being set;
assume L181: C29 in { ( succ R4 ) , D55 };
per cases  by L181 , TARSKI:def 2;
suppose L182: C29 = ( succ R4 );

reconsider D59 = ( D58 +* ( R1 .--> 1 ) ) as (State of ( SCMPDS ));
reconsider D60 = ( D59 +* ( ( DataLoc (( D59 . R1 ) , R6) ) .--> 1 ) ) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
L183: ( IC D60 ) = ( D59 . ( IC ( SCMPDS ) ) ) by FUNCT_4:83 , SCMPDS_2:43
.= ( IC D58 ) by FUNCT_4:83 , SCMPDS_2:43
.= D57 by MEMSTR_0:def 11;
L184: ( D60 . ( DataLoc (( D59 . R1 ) , R6) ) ) = 1 by FUNCT_7:94;
L185: ( D60 . ( DataLoc (( D60 . R1 ) , R6) ) ) > ( 0 )
proof
per cases ;
suppose L186: R1 = ( DataLoc (( D59 . R1 ) , R6) );

thus L187: thesis by L186 , L184 , FUNCT_7:94;
end;
suppose L188: R1 <> ( DataLoc (( D59 . R1 ) , R6) );

L189: ( D60 . R1 ) = ( D59 . R1 ) by L188 , FUNCT_4:83;
thus L190: thesis by L189 , FUNCT_7:94;
end;
end;
L192: C29 = ( IC ( Exec (D54 , D60) ) ) by L185 , L182 , L183 , SCMPDS_2:56;
thus L193: thesis by L192 , L183;
end;
suppose L194: C29 = D55;

reconsider D61 = ( D58 +* ( R1 .--> ( 0 ) ) ) as (State of ( SCMPDS ));
reconsider D62 = ( D61 +* ( ( DataLoc (( D61 . R1 ) , R6) ) .--> ( 0 ) ) ) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
L195: ( D62 . ( DataLoc (( D61 . R1 ) , R6) ) ) = ( 0 ) by FUNCT_7:94;
L196: ( D62 . ( DataLoc (( D62 . R1 ) , R6) ) ) <= ( 0 )
proof
per cases ;
suppose L197: R1 = ( DataLoc (( D61 . R1 ) , R6) );

thus L198: thesis by L197 , L195 , FUNCT_7:94;
end;
suppose L199: R1 <> ( DataLoc (( D61 . R1 ) , R6) );

L200: ( D62 . R1 ) = ( D61 . R1 ) by L199 , FUNCT_4:83;
thus L201: thesis by L200 , FUNCT_7:94;
end;
end;
L203: ( IC D62 ) = ( D61 . ( IC ( SCMPDS ) ) ) by FUNCT_4:83 , SCMPDS_2:43
.= ( IC D58 ) by FUNCT_4:83 , SCMPDS_2:43
.= D57 by MEMSTR_0:def 11;
L204: (ex B23 being (Element of ( NAT )) st (B23 = ( IC D62 ) & ( ICplusConst (D62 , R7) ) = ( abs ( B23 + R7 ) ))) by SCMPDS_2:def 18;
L205: C29 = ( IC ( Exec (D54 , D62) ) ) by L204 , L194 , L203 , L196 , SCMPDS_2:56;
thus L206: thesis by L205 , L203;
end;
end;
theorem
L208: (for R1 being Int_position holds (for R4 being (Element of ( NAT )) holds (for R6 being Integer holds (for R7 being Integer holds ( NIC (( (R1 , R6) >=0_goto R7 ) , R4) ) = { ( succ R4 ) , ( abs ( R7 + R4 ) ) }))))
proof
let R1 being Int_position;
let R4 being (Element of ( NAT ));
let R6 being Integer;
let R7 being Integer;
set D63 = the (State of ( SCMPDS ));
set D64 = ( (R1 , R6) >=0_goto R7 );
set D65 = ( abs ( R7 + R4 ) );
set D66 = D64;
reconsider D67 = R4 as (Element of ( NAT ));
reconsider D68 = the D67 -started (State of ( SCMPDS )) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
thus L209:now
let C30 being set;
assume L210: C30 in ( NIC (D64 , R4) );
consider C31 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L211: C30 = ( IC ( Exec (D64 , C31) ) ) and L212: ( IC C31 ) = R4 by L210;
L213: (ex B24 being (Element of ( NAT )) st (B24 = ( IC C31 ) & ( ICplusConst (C31 , R7) ) = ( abs ( B24 + R7 ) ))) by SCMPDS_2:def 18;
per cases ;
suppose L214: ( C31 . ( DataLoc (( C31 . R1 ) , R6) ) ) >= ( 0 );

L215: C30 = D65 by L211 , L212 , L213 , L214 , SCMPDS_2:57;
thus L216: C30 in { ( succ R4 ) , D65 } by L215 , TARSKI:def 2;
end;
suppose L217: ( C31 . ( DataLoc (( C31 . R1 ) , R6) ) ) < ( 0 );

L218: C30 = ( succ R4 ) by L211 , L212 , L217 , SCMPDS_2:57;
thus L219: C30 in { ( succ R4 ) , D65 } by L218 , TARSKI:def 2;
end;
end;
let C32 being set;
assume L221: C32 in { ( succ R4 ) , D65 };
per cases  by L221 , TARSKI:def 2;
suppose L222: C32 = ( succ R4 );

L223: ( - 1 ) < ( 0 );
reconsider D69 = ( D68 +* ( R1 .--> ( - 1 ) ) ) as (State of ( SCMPDS ));
reconsider D70 = ( D68 +* ( R1 .--> ( - 1 ) ) ) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
reconsider D71 = ( D70 +* ( ( DataLoc (( D70 . R1 ) , R6) ) .--> ( - 1 ) ) ) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
L224: ( IC D71 ) = ( D70 . ( IC ( SCMPDS ) ) ) by FUNCT_4:83 , SCMPDS_2:43
.= ( IC D68 ) by FUNCT_4:83 , SCMPDS_2:43
.= D67 by MEMSTR_0:def 11;
L225: ( D71 . ( DataLoc (( D70 . R1 ) , R6) ) ) = ( - 1 ) by FUNCT_7:94;
L226: ( D71 . ( DataLoc (( D71 . R1 ) , R6) ) ) < ( 0 )
proof
per cases ;
suppose L227: R1 = ( DataLoc (( D70 . R1 ) , R6) );

thus L228: thesis by L227 , L225 , L223 , FUNCT_7:94;
end;
suppose L229: R1 <> ( DataLoc (( D70 . R1 ) , R6) );

L230: ( D71 . R1 ) = ( D70 . R1 ) by L229 , FUNCT_4:83;
thus L231: thesis by L230 , L223 , FUNCT_7:94;
end;
end;
L233: C32 = ( IC ( Exec (D64 , D71) ) ) by L226 , L222 , L224 , SCMPDS_2:57;
thus L234: thesis by L233 , L224;
end;
suppose L235: C32 = D65;

reconsider D72 = ( D68 +* ( R1 .--> ( - 1 ) ) ) as (State of ( SCMPDS ));
reconsider D73 = ( D68 +* ( R1 .--> ( 0 ) ) ) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
reconsider D74 = ( D73 +* ( ( DataLoc (( D73 . R1 ) , R6) ) .--> ( 0 ) ) ) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
L236: ( D74 . ( DataLoc (( D73 . R1 ) , R6) ) ) = ( 0 ) by FUNCT_7:94;
L237: ( D74 . ( DataLoc (( D74 . R1 ) , R6) ) ) >= ( 0 )
proof
per cases ;
suppose L238: R1 = ( DataLoc (( D73 . R1 ) , R6) );

thus L239: thesis by L238 , L236 , FUNCT_7:94;
end;
suppose L240: R1 <> ( DataLoc (( D73 . R1 ) , R6) );

L241: ( D74 . R1 ) = ( D73 . R1 ) by L240 , FUNCT_4:83;
thus L242: thesis by L241 , FUNCT_7:94;
end;
end;
L244: ( IC D74 ) = ( D73 . ( IC ( SCMPDS ) ) ) by FUNCT_4:83 , SCMPDS_2:43
.= ( IC D68 ) by FUNCT_4:83 , SCMPDS_2:43
.= D67 by MEMSTR_0:def 11;
L245: (ex B25 being (Element of ( NAT )) st (B25 = ( IC D74 ) & ( ICplusConst (D74 , R7) ) = ( abs ( B25 + R7 ) ))) by SCMPDS_2:def 18;
L246: C32 = ( IC ( Exec (D64 , D74) ) ) by L245 , L235 , L244 , L237 , SCMPDS_2:57;
thus L247: thesis by L246 , L244;
end;
end;
theorem
L249: (for R1 being Int_position holds ( JUMP ( return R1 ) ) = { B26 where B26 is (Element of ( NAT )) : B26 > 1 })
proof
let R1 being Int_position;
set D75 = { B27 where B27 is (Element of ( NAT )) : B27 > 1 };
set D76 = ( return R1 );
set D77 = { ( NIC (D76 , B28) ) where B28 is (Element of ( NAT )) : (not contradiction) };
L250: ( JUMP D76 ) c= ( NIC (D76 , ( 0 )) ) by AMISTD_1:19;
thus L251: ( JUMP D76 ) c= D75 by L250 , L74;
let C33 being set;
assume L252: C33 in D75;
L253:
now
consider C34 being (Element of ( NAT )) such that L254: C33 = C34 and L255: C34 > 1 by L252;
reconsider D78 = ( C34 - 2 ) as (Element of ( NAT )) by L255 , L69;
L256: ( NIC (D76 , ( 0 )) ) in D77;
thus L257: D77 <> ( {} ) by L256;
L258: R1 in ( SCM-Data-Loc ) by AMI_2:def 16;
consider C35 being (Element of ( NAT )) such that L259: R1 = [ 1 , C35 ] by L258 , AMI_2:23;
set D79 = [ 1 , ( C35 + 1 ) ];
set D80 = the (State of ( SCMPDS ));
let C36 being set;
L260: ( DataLoc (C35 , 1) ) = [ 1 , ( abs ( C35 + 1 ) ) ]
.= D79 by ABSVALUE:def 1;
L261: D79 in ( SCM-Data-Loc ) by AMI_2:24;
reconsider D81 = D79 as Int_position by L261 , AMI_2:def 16;
assume L262: C36 in D77;
consider C37 being (Element of ( NAT )) such that L263: C36 = ( NIC (D76 , C37) ) by L262;
reconsider D82 = C37 as (Element of ( NAT ));
set D83 = D76;
reconsider D84 = the D82 -started (State of ( SCMPDS )) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
L264: ( IC D84 ) = D82 by MEMSTR_0:def 11;
set D85 = ( (R1 , D81) --> (C35 , D78) );
reconsider D86 = ( D84 +* D85 ) as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
L265: C35 <> ( C35 + 1 );
L266: R1 <> D81 by L265 , L259 , XTUPLE_0:1;
L267: ( D86 . R1 ) = C35 by L266 , FUNCT_4:84;
L268: ( D86 . D81 ) = D78 by L266 , FUNCT_4:84;
L269: ( dom D85 ) = { R1 , D81 } by FUNCT_4:62;
L270: (R1 <> ( IC ( SCMPDS ) ) & D81 <> ( IC ( SCMPDS ) )) by SCMPDS_2:43;
L271: (not ( IC ( SCMPDS ) ) in ( dom D85 )) by L270 , L269 , TARSKI:def 2;
L272: ( IC D86 ) = C37 by L264 , L271 , FUNCT_4:11;
L273: C33 = ( D78 + 2 ) by L254
.= ( ( abs ( D86 . ( DataLoc (C35 , 1) ) ) ) + 2 ) by L268 , L260 , ABSVALUE:def 1
.= ( IC ( Exec (D76 , D86) ) ) by L267 , SCMPDS_2:58 , SCMPDS_I:def 14;
thus L274: C33 in C36 by L273 , L263 , L272;
end;
thus L275: thesis by L253 , SETFAM_1:def 1;
end;
registration
let R1 being Int_position;
cluster ( JUMP ( return R1 ) ) ->  infinite;
coherence
proof
L276: { B29 where B29 is (Element of ( NAT )) : B29 > 1 } is  infinite by PRE_CIRC:23;
thus L277: thesis by L276 , L249;
end;
end;
registration
let R1 being Int_position;
let R6 being Integer;
cluster ( JUMP ( saveIC (R1 , R6) ) ) ->  empty;
coherence
proof
L279: (for B30 being (Element of ( NAT )) holds ( NIC (( saveIC (R1 , R6) ) , B30) ) = { ( succ B30 ) }) by L101;
thus L280: thesis by L279 , L43;
end;
end;
registration
let R1 being Int_position;
let R6 being Integer;
cluster ( JUMP ( R1 := R6 ) ) ->  empty;
coherence
proof
L282: (for B31 being (Element of ( NAT )) holds ( NIC (( R1 := R6 ) , B31) ) = { ( succ B31 ) }) by L104;
thus L283: thesis by L282 , L43;
end;
end;
registration
let R1 being Int_position;
let R6 being Integer;
let R7 being Integer;
cluster ( JUMP ( (R1 , R6) := R7 ) ) ->  empty;
coherence
proof
L285: (for B32 being (Element of ( NAT )) holds ( NIC (( (R1 , R6) := R7 ) , B32) ) = { ( succ B32 ) }) by L107;
thus L286: thesis by L285 , L43;
end;
end;
registration
let R1 being Int_position;
let R2 being Int_position;
let R6 being Integer;
let R7 being Integer;
cluster ( JUMP ( (R1 , R6) := (R2 , R7) ) ) ->  empty;
coherence
proof
L288: (for B33 being (Element of ( NAT )) holds ( NIC (( (R1 , R6) := (R2 , R7) ) , B33) ) = { ( succ B33 ) }) by L110;
thus L289: thesis by L288 , L43;
end;
end;
registration
let R1 being Int_position;
let R6 being Integer;
let R7 being Integer;
cluster ( JUMP ( AddTo (R1 , R6 , R7) ) ) ->  empty;
coherence
proof
L291: (for B34 being (Element of ( NAT )) holds ( NIC (( AddTo (R1 , R6 , R7) ) , B34) ) = { ( succ B34 ) }) by L113;
thus L292: thesis by L291 , L43;
end;
end;
registration
let R1 being Int_position;
let R2 being Int_position;
let R6 being Integer;
let R7 being Integer;
cluster ( JUMP ( AddTo (R1 , R6 , R2 , R7) ) ) ->  empty;
coherence
proof
L294: (for B35 being (Element of ( NAT )) holds ( NIC (( AddTo (R1 , R6 , R2 , R7) ) , B35) ) = { ( succ B35 ) }) by L116;
thus L295: thesis by L294 , L43;
end;
cluster ( JUMP ( SubFrom (R1 , R6 , R2 , R7) ) ) ->  empty;
coherence
proof
L296: (for B36 being (Element of ( NAT )) holds ( NIC (( SubFrom (R1 , R6 , R2 , R7) ) , B36) ) = { ( succ B36 ) }) by L119;
thus L297: thesis by L296 , L43;
end;
cluster ( JUMP ( MultBy (R1 , R6 , R2 , R7) ) ) ->  empty;
coherence
proof
L298: (for B37 being (Element of ( NAT )) holds ( NIC (( MultBy (R1 , R6 , R2 , R7) ) , B37) ) = { ( succ B37 ) }) by L122;
thus L299: thesis by L298 , L43;
end;
cluster ( JUMP ( Divide (R1 , R6 , R2 , R7) ) ) ->  empty;
coherence
proof
L300: (for B38 being (Element of ( NAT )) holds ( NIC (( Divide (R1 , R6 , R2 , R7) ) , B38) ) = { ( succ B38 ) }) by L125;
thus L301: thesis by L300 , L43;
end;
end;
L303: (not ( 5 / 3 ) is  integer)
proof
L304: (not (3 qua Integer) divides 5)
proof
assume L305: (not thesis);
L306: ( 5 mod 3 ) = ( 0 ) by L305 , PEPIN:6;
L307: 5 = ( ( 3 * 1 ) + 2 );
thus L308: contradiction by L307 , L306 , NAT_D:def 2;
end;
thus L309: thesis by L304 , WSIERP_1:17;
end;
L310: (for B39 being  real number holds ( ( ( ( ( abs B39 ) + ( ( ( - B39 ) + ( abs B39 ) ) + 4 ) ) + 2 ) - 2 ) + B39 ) <> ( - ( ( ( ( ( ( abs B39 ) + ( ( ( - B39 ) + ( abs B39 ) ) + 4 ) ) + ( ( ( - B39 ) + ( abs B39 ) ) + 4 ) ) + 2 ) - 2 ) + B39 ) ))
proof
let C38 being  real number;
set D87 = ( ( ( - C38 ) + ( abs C38 ) ) + 4 );
set D88 = ( ( D87 + D87 ) + D87 );
L311: ( ( - C38 ) + ( abs C38 ) ) >= ( 0 ) by ABSVALUE:27;
L312: ( ( - 2 ) * D88 ) < ( ( - 2 ) * ( 0 ) ) by L311 , XREAL_1:69;
L313: ( ( ( - 2 ) * D88 ) / 4 ) < ( ( 0 ) / 4 ) by L312 , XREAL_1:74;
assume L314: ( ( ( ( ( abs C38 ) + D87 ) + 2 ) - 2 ) + C38 ) = ( - ( ( ( ( ( ( abs C38 ) + D87 ) + ( ( ( - C38 ) + ( abs C38 ) ) + 4 ) ) + 2 ) - 2 ) + C38 ) );
L315: ( C38 + ( abs C38 ) ) = ( ( ( - 2 ) * D88 ) / 4 ) by L314;
thus L316: contradiction by L315 , L313 , ABSVALUE:26;
end;
L317: (for B40 , B41 being  real number holds ( B40 + 1 ) <> ( B40 + ( ( ( ( - B41 ) + ( abs B41 ) ) + 4 ) + B41 ) ))
proof
let C39 , C40 being  real number;
set D89 = ( ( ( - C40 ) + ( abs C40 ) ) + 4 );
L318: ( abs C40 ) >= ( 0 ) by COMPLEX1:46;
L319: ( ( abs C40 ) + 3 ) >= ( ( 0 ) + 3 ) by L318 , XREAL_1:7;
assume L320: ( C39 + 1 ) = ( C39 + ( D89 + C40 ) );
thus L321: thesis by L320 , L319;
end;
L322: (for B42 , B43 being  real number holds (B42 > ( 0 ) implies ( ( ( abs B43 ) + B42 ) + 1 ) <> ( - ( ( ( ( abs B43 ) + B42 ) + B42 ) + B43 ) )))
proof
let C41 , C42 being  real number;
assume that
L323: C41 > ( 0 );
assume L324: ( ( ( abs C42 ) + C41 ) + 1 ) = ( - ( ( ( ( abs C42 ) + C41 ) + C41 ) + C42 ) );
per cases ;
suppose L325: C42 >= ( 0 );

L326: ( abs C42 ) = C42 by L325 , ABSVALUE:def 1;
thus L327: contradiction by L326 , L323 , L324 , L325;
end;
suppose L328: C42 < ( 0 );

L329: ( abs C42 ) = ( - C42 ) by L328 , ABSVALUE:def 1;
L330: ( ( ( - C42 ) + ( 3 * C41 ) ) + 1 ) = ( 0 ) by L329 , L324;
thus L331: contradiction by L330 , L323 , L328;
end;
end;
L333: (for B44 being  real number holds (for B45 being Integer holds (B45 <> 5 implies ( ( B44 + ( ( ( - B45 ) + ( abs B45 ) ) + 4 ) ) + 1 ) <> ( B44 + B45 ))))
proof
let C43 being  real number;
let C44 being Integer;
assume L334: C44 <> 5;
assume L335: ( ( C43 + ( ( ( - C44 ) + ( abs C44 ) ) + 4 ) ) + 1 ) = ( C43 + C44 );
per cases ;
suppose L336: C44 >= ( 0 );

L337: ( abs C44 ) = C44 by L336 , ABSVALUE:def 1;
thus L338: thesis by L337 , L334 , L335;
end;
suppose L339: C44 < ( 0 );

L340: ( abs C44 ) = ( - C44 ) by L339 , ABSVALUE:def 1;
thus L341: thesis by L340 , L335 , L303;
end;
end;
L343: (for B46 , B47 being  real number holds (B46 > ( 0 ) implies ( ( ( ( abs B47 ) + B46 ) + B46 ) + 1 ) <> ( - ( ( ( abs B47 ) + B46 ) + B47 ) )))
proof
let C45 , C46 being  real number;
assume L344: C45 > ( 0 );
assume L345: ( ( ( ( abs C46 ) + C45 ) + C45 ) + 1 ) = ( - ( ( ( abs C46 ) + C45 ) + C46 ) );
per cases ;
suppose L346: C46 >= ( 0 );

L347: ( abs C46 ) = C46 by L346 , ABSVALUE:def 1;
thus L348: contradiction by L347 , L344 , L345 , L346;
end;
suppose L349: C46 < ( 0 );

L350: ( abs C46 ) = ( - C46 ) by L349 , ABSVALUE:def 1;
thus L351: contradiction by L350 , L344 , L345 , L349;
end;
end;
L353: (for R1 being Int_position holds (for R6 being Integer holds ( JUMP ( (R1 , R6) <>0_goto 5 ) ) = ( {} )))
proof
let R1 being Int_position;
let R6 being Integer;
set D90 = 5;
set D91 = ( (R1 , R6) <>0_goto D90 );
set D92 = { ( NIC (D91 , B48) ) where B48 is (Element of ( NAT )) : (not contradiction) };
thus L354:now
set D93 = 8;
set D94 = 5;
let C47 being set;
assume L355: C47 in ( JUMP D91 );
set D95 = D93;
L356: ( NIC (D91 , D95) ) in D92;
L357: C47 in ( NIC (D91 , D95) ) by L356 , L355 , SETFAM_1:def 1;
consider C48 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L358: C47 = ( IC ( Exec (D91 , C48) ) ) and L359: ( IC C48 ) = D95 by L357;
set D96 = D94;
L360: ( NIC (D91 , D96) ) in D92;
L361: C47 in ( NIC (D91 , D96) ) by L360 , L355 , SETFAM_1:def 1;
consider C49 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L362: C47 = ( IC ( Exec (D91 , C49) ) ) and L363: ( IC C49 ) = D96 by L361;
consider C50 being (Element of ( NAT )) such that L364: C50 = ( IC C48 ) and L365: ( ICplusConst (C48 , D90) ) = ( abs ( C50 + D90 ) ) by SCMPDS_2:def 18;
consider C51 being (Element of ( NAT )) such that L366: C51 = ( IC C49 ) and L367: ( ICplusConst (C49 , D90) ) = ( abs ( C51 + D90 ) ) by SCMPDS_2:def 18;
per cases ;
suppose that L368: ( C49 . ( DataLoc (( C49 . R1 ) , R6) ) ) <> ( 0 )
and
L369: ( C48 . ( DataLoc (( C48 . R1 ) , R6) ) ) <> ( 0 );
L370: C47 = ( abs ( C50 + D90 ) ) by L358 , L365 , L369 , SCMPDS_2:55;
L371: C47 = ( abs ( C51 + D90 ) ) by L362 , L367 , L368 , SCMPDS_2:55;
L372: (( D94 + D90 ) = ( D93 + D90 ) or ( D94 + D90 ) = ( - ( D93 + D90 ) )) by L371 , L363 , L366 , L359 , L364 , L370 , ABSVALUE:28;
thus L373: C47 in ( {} ) by L372;
end;
suppose that L374: ( C49 . ( DataLoc (( C49 . R1 ) , R6) ) ) = ( 0 )
and
L375: ( C48 . ( DataLoc (( C48 . R1 ) , R6) ) ) = ( 0 );
L376: C47 = ( succ D95 ) by L358 , L359 , L375 , SCMPDS_2:55;
L377: C47 = ( succ D96 ) by L362 , L363 , L374 , SCMPDS_2:55;
thus L378: C47 in ( {} ) by L377 , L376;
end;
suppose that L379: ( C49 . ( DataLoc (( C49 . R1 ) , R6) ) ) = ( 0 )
and
L380: ( C48 . ( DataLoc (( C48 . R1 ) , R6) ) ) <> ( 0 );
reconsider D97 = D96 as (Element of ( NAT ));
set D98 = D97;
L381: C47 = ( abs ( C50 + D90 ) ) by L358 , L365 , L380 , SCMPDS_2:55;
L382: C47 = ( succ D97 ) by L362 , L363 , L379 , SCMPDS_2:55
.= ( D97 + 1 );
L383: (( D98 + 1 ) = ( C50 + D90 ) or ( D98 + 1 ) = ( - ( C50 + D90 ) )) by L382 , L381 , ABSVALUE:1;
thus L384: C47 in ( {} ) by L383 , L359 , L364;
end;
suppose that L385: ( C49 . ( DataLoc (( C49 . R1 ) , R6) ) ) <> ( 0 )
and
L386: ( C48 . ( DataLoc (( C48 . R1 ) , R6) ) ) = ( 0 );
reconsider D99 = D95 as (Element of ( NAT ));
L387: C47 = ( succ D99 ) by L358 , L359 , L386 , SCMPDS_2:55
.= ( D99 + 1 );
set D100 = D99;
L388: C47 = ( abs ( C51 + D90 ) ) by L362 , L367 , L385 , SCMPDS_2:55;
L389: (( D100 + 1 ) = ( C51 + D90 ) or ( D100 + 1 ) = ( - ( C51 + D90 ) )) by L388 , L387 , ABSVALUE:1;
thus L390: C47 in ( {} ) by L389 , L363 , L366;
end;
end;
thus L392: thesis by XBOOLE_1:2;
end;
L393: (for R1 being Int_position holds (for R6 being Integer holds (for R7 being Integer holds (R7 <> 5 implies ( JUMP ( (R1 , R6) <>0_goto R7 ) ) = ( {} )))))
proof
let R1 being Int_position;
let R6 being Integer;
let R7 being Integer;
set D101 = ( (R1 , R6) <>0_goto R7 );
set D102 = { ( NIC (D101 , B49) ) where B49 is (Element of ( NAT )) : (not contradiction) };
assume L394: R7 <> 5;
thus L395:now
set D103 = ( ( ( - R7 ) + ( abs R7 ) ) + 4 );
let C52 being set;
assume L396: C52 in ( JUMP D101 );
L397: D103 > ( ( ( - R7 ) + ( abs R7 ) ) + ( 0 ) ) by XREAL_1:6;
L398: D103 > ( 0 ) by L397 , ABSVALUE:27;
reconsider D104 = D103 as (Element of ( NAT )) by L398 , INT_1:3;
set D105 = ( ( abs R7 ) + D104 );
set D106 = ( D105 + D104 );
set D107 = D105;
set D108 = D106;
L399: ( NIC (D101 , D107) ) in D102;
L400: C52 in ( NIC (D101 , D107) ) by L399 , L396 , SETFAM_1:def 1;
consider C53 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L401: C52 = ( IC ( Exec (D101 , C53) ) ) and L402: ( IC C53 ) = D107 by L400;
consider C54 being (Element of ( NAT )) such that L403: C54 = ( IC C53 ) and L404: ( ICplusConst (C53 , R7) ) = ( abs ( C54 + R7 ) ) by SCMPDS_2:def 18;
L405: ( NIC (D101 , D108) ) in D102;
L406: C52 in ( NIC (D101 , D108) ) by L405 , L396 , SETFAM_1:def 1;
consider C55 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L407: C52 = ( IC ( Exec (D101 , C55) ) ) and L408: ( IC C55 ) = D108 by L406;
consider C56 being (Element of ( NAT )) such that L409: C56 = ( IC C55 ) and L410: ( ICplusConst (C55 , R7) ) = ( abs ( C56 + R7 ) ) by SCMPDS_2:def 18;
per cases ;
suppose that L411: ( C53 . ( DataLoc (( C53 . R1 ) , R6) ) ) <> ( 0 )
and
L412: ( C55 . ( DataLoc (( C55 . R1 ) , R6) ) ) <> ( 0 );
L413: C52 = ( abs ( C56 + R7 ) ) by L407 , L410 , L412 , SCMPDS_2:55;
L414: C52 = ( abs ( C54 + R7 ) ) by L401 , L404 , L411 , SCMPDS_2:55;
thus L415: C52 in ( {} )
proof
per cases  by L402 , L403 , L408 , L409 , L414 , L413 , ABSVALUE:28;
suppose L416: ( ( ( D105 + 2 ) - 2 ) + R7 ) = ( ( ( D106 + 2 ) - 2 ) + R7 );

thus L417: thesis by L416 , L397 , ABSVALUE:27;
end;
suppose L418: ( ( ( D105 + 2 ) - 2 ) + R7 ) = ( - ( ( ( D106 + 2 ) - 2 ) + R7 ) );

thus L419: thesis by L418 , L310;
end;
end;

end;
suppose that L416: ( C53 . ( DataLoc (( C53 . R1 ) , R6) ) ) = ( 0 )
and
L417: ( C55 . ( DataLoc (( C55 . R1 ) , R6) ) ) = ( 0 );
L418: C52 = ( succ D108 ) by L407 , L408 , L417 , SCMPDS_2:55;
L419: C52 = ( succ D107 ) by L401 , L402 , L416 , SCMPDS_2:55;
thus L420: C52 in ( {} ) by L419 , L397 , L418 , ABSVALUE:27;
end;
suppose that L421: ( C53 . ( DataLoc (( C53 . R1 ) , R6) ) ) = ( 0 )
and
L422: ( C55 . ( DataLoc (( C55 . R1 ) , R6) ) ) <> ( 0 );
reconsider D109 = D107 as (Element of ( NAT ));
set D110 = D109;
L423: C52 = ( abs ( C56 + R7 ) ) by L407 , L410 , L422 , SCMPDS_2:55;
L424: C52 = ( succ D109 ) by L401 , L402 , L421 , SCMPDS_2:55
.= ( D109 + 1 );
thus L425: C52 in ( {} )
proof
per cases  by L424 , L423 , ABSVALUE:1;
suppose L426: ( D110 + 1 ) = ( C56 + R7 );

L427: ( D105 + 1 ) = ( D105 + ( D104 + R7 ) ) by L426 , L408 , L409;
thus L428: thesis by L427 , L317;
end;
suppose L429: ( D110 + 1 ) = ( - ( C56 + R7 ) );

thus L430: thesis by L429 , L398 , L408 , L409 , L322;
end;
end;

end;
suppose that L426: ( C53 . ( DataLoc (( C53 . R1 ) , R6) ) ) <> ( 0 )
and
L427: ( C55 . ( DataLoc (( C55 . R1 ) , R6) ) ) = ( 0 );
reconsider D111 = D108 as (Element of ( NAT ));
L428: C52 = ( succ D111 ) by L407 , L408 , L427 , SCMPDS_2:55
.= ( D111 + 1 );
set D112 = D111;
L429: C52 = ( abs ( C54 + R7 ) ) by L401 , L404 , L426 , SCMPDS_2:55;
thus L430: C52 in ( {} )
proof
per cases  by L429 , L428 , ABSVALUE:1;
suppose L431: ( D112 + 1 ) = ( C54 + R7 );

thus L432: thesis by L431 , L394 , L402 , L403 , L333;
end;
suppose L433: ( D112 + 1 ) = ( - ( C54 + R7 ) );

thus L434: thesis by L433 , L398 , L402 , L403 , L343;
end;
end;

end;
end;
thus L432: thesis by XBOOLE_1:2;
end;
L433: (for R1 being Int_position holds (for R6 being Integer holds ( JUMP ( (R1 , R6) <=0_goto 5 ) ) = ( {} )))
proof
let R1 being Int_position;
let R6 being Integer;
set D113 = 5;
set D114 = ( (R1 , R6) <=0_goto D113 );
set D115 = { ( NIC (D114 , B50) ) where B50 is (Element of ( NAT )) : (not contradiction) };
thus L434:now
set D116 = 8;
set D117 = 5;
let C57 being set;
assume L435: C57 in ( JUMP D114 );
set D118 = D116;
L436: ( NIC (D114 , D118) ) in D115;
L437: C57 in ( NIC (D114 , D118) ) by L436 , L435 , SETFAM_1:def 1;
consider C58 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L438: C57 = ( IC ( Exec (D114 , C58) ) ) and L439: ( IC C58 ) = D118 by L437;
set D119 = D117;
L440: ( NIC (D114 , D119) ) in D115;
L441: C57 in ( NIC (D114 , D119) ) by L440 , L435 , SETFAM_1:def 1;
consider C59 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L442: C57 = ( IC ( Exec (D114 , C59) ) ) and L443: ( IC C59 ) = D119 by L441;
consider C60 being (Element of ( NAT )) such that L444: C60 = ( IC C58 ) and L445: ( ICplusConst (C58 , D113) ) = ( abs ( C60 + D113 ) ) by SCMPDS_2:def 18;
consider C61 being (Element of ( NAT )) such that L446: C61 = ( IC C59 ) and L447: ( ICplusConst (C59 , D113) ) = ( abs ( C61 + D113 ) ) by SCMPDS_2:def 18;
per cases ;
suppose that L448: ( C59 . ( DataLoc (( C59 . R1 ) , R6) ) ) <= ( 0 )
and
L449: ( C58 . ( DataLoc (( C58 . R1 ) , R6) ) ) <= ( 0 );
L450: C57 = ( abs ( C60 + D113 ) ) by L438 , L445 , L449 , SCMPDS_2:56;
L451: C57 = ( abs ( C61 + D113 ) ) by L442 , L447 , L448 , SCMPDS_2:56;
L452: (( D117 + D113 ) = ( D116 + D113 ) or ( D117 + D113 ) = ( - ( D116 + D113 ) )) by L451 , L443 , L446 , L439 , L444 , L450 , ABSVALUE:28;
thus L453: C57 in ( {} ) by L452;
end;
suppose that L454: ( C59 . ( DataLoc (( C59 . R1 ) , R6) ) ) > ( 0 )
and
L455: ( C58 . ( DataLoc (( C58 . R1 ) , R6) ) ) > ( 0 );
L456: C57 = ( succ D118 ) by L438 , L439 , L455 , SCMPDS_2:56;
L457: C57 = ( succ D119 ) by L442 , L443 , L454 , SCMPDS_2:56;
thus L458: C57 in ( {} ) by L457 , L456;
end;
suppose that L459: ( C59 . ( DataLoc (( C59 . R1 ) , R6) ) ) > ( 0 )
and
L460: ( C58 . ( DataLoc (( C58 . R1 ) , R6) ) ) <= ( 0 );
reconsider D120 = D119 as (Element of ( NAT ));
set D121 = D120;
L461: C57 = ( abs ( C60 + D113 ) ) by L438 , L445 , L460 , SCMPDS_2:56;
L462: C57 = ( succ D120 ) by L442 , L443 , L459 , SCMPDS_2:56
.= ( D120 + 1 );
L463: (( D121 + 1 ) = ( C60 + D113 ) or ( D121 + 1 ) = ( - ( C60 + D113 ) )) by L462 , L461 , ABSVALUE:1;
thus L464: C57 in ( {} ) by L463 , L439 , L444;
end;
suppose that L465: ( C59 . ( DataLoc (( C59 . R1 ) , R6) ) ) <= ( 0 )
and
L466: ( C58 . ( DataLoc (( C58 . R1 ) , R6) ) ) > ( 0 );
reconsider D122 = D118 as (Element of ( NAT ));
L467: C57 = ( succ D122 ) by L438 , L439 , L466 , SCMPDS_2:56
.= ( D122 + 1 );
set D123 = D122;
L468: C57 = ( abs ( C61 + D113 ) ) by L442 , L447 , L465 , SCMPDS_2:56;
L469: (( D123 + 1 ) = ( C61 + D113 ) or ( D123 + 1 ) = ( - ( C61 + D113 ) )) by L468 , L467 , ABSVALUE:1;
thus L470: C57 in ( {} ) by L469 , L443 , L446;
end;
end;
thus L472: thesis by XBOOLE_1:2;
end;
L473: (for R1 being Int_position holds (for R6 being Integer holds (for R7 being Integer holds (R7 <> 5 implies ( JUMP ( (R1 , R6) <=0_goto R7 ) ) = ( {} )))))
proof
let R1 being Int_position;
let R6 being Integer;
let R7 being Integer;
set D124 = ( (R1 , R6) <=0_goto R7 );
set D125 = { ( NIC (D124 , B51) ) where B51 is (Element of ( NAT )) : (not contradiction) };
assume L474: R7 <> 5;
thus L475:now
set D126 = ( ( ( - R7 ) + ( abs R7 ) ) + 4 );
let C62 being set;
assume L476: C62 in ( JUMP D124 );
L477: D126 > ( ( ( - R7 ) + ( abs R7 ) ) + ( 0 ) ) by XREAL_1:6;
L478: D126 > ( 0 ) by L477 , ABSVALUE:27;
reconsider D127 = D126 as (Element of ( NAT )) by L478 , INT_1:3;
set D128 = ( ( abs R7 ) + D127 );
set D129 = ( D128 + D127 );
set D130 = D128;
set D131 = D129;
L479: ( NIC (D124 , D130) ) in D125;
L480: C62 in ( NIC (D124 , D130) ) by L479 , L476 , SETFAM_1:def 1;
consider C63 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L481: C62 = ( IC ( Exec (D124 , C63) ) ) and L482: ( IC C63 ) = D130 by L480;
consider C64 being (Element of ( NAT )) such that L483: C64 = ( IC C63 ) and L484: ( ICplusConst (C63 , R7) ) = ( abs ( C64 + R7 ) ) by SCMPDS_2:def 18;
L485: ( NIC (D124 , D131) ) in D125;
L486: C62 in ( NIC (D124 , D131) ) by L485 , L476 , SETFAM_1:def 1;
consider C65 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L487: C62 = ( IC ( Exec (D124 , C65) ) ) and L488: ( IC C65 ) = D131 by L486;
consider C66 being (Element of ( NAT )) such that L489: C66 = ( IC C65 ) and L490: ( ICplusConst (C65 , R7) ) = ( abs ( C66 + R7 ) ) by SCMPDS_2:def 18;
per cases ;
suppose that L491: ( C63 . ( DataLoc (( C63 . R1 ) , R6) ) ) <= ( 0 )
and
L492: ( C65 . ( DataLoc (( C65 . R1 ) , R6) ) ) <= ( 0 );
L493: C62 = ( abs ( C66 + R7 ) ) by L487 , L490 , L492 , SCMPDS_2:56;
L494: C62 = ( abs ( C64 + R7 ) ) by L481 , L484 , L491 , SCMPDS_2:56;
thus L495: C62 in ( {} )
proof
per cases  by L482 , L483 , L488 , L489 , L494 , L493 , ABSVALUE:28;
suppose L496: ( D128 + R7 ) = ( D129 + R7 );

thus L497: thesis by L496 , L477 , ABSVALUE:27;
end;
suppose L498: ( ( ( D128 + 2 ) - 2 ) + R7 ) = ( - ( ( ( D129 + 2 ) - 2 ) + R7 ) );

thus L499: thesis by L498 , L310;
end;
end;

end;
suppose that L496: ( C63 . ( DataLoc (( C63 . R1 ) , R6) ) ) > ( 0 )
and
L497: ( C65 . ( DataLoc (( C65 . R1 ) , R6) ) ) > ( 0 );
L498: C62 = ( succ D131 ) by L487 , L488 , L497 , SCMPDS_2:56;
L499: C62 = ( succ D130 ) by L481 , L482 , L496 , SCMPDS_2:56;
thus L500: C62 in ( {} ) by L499 , L477 , L498 , ABSVALUE:27;
end;
suppose that L501: ( C63 . ( DataLoc (( C63 . R1 ) , R6) ) ) > ( 0 )
and
L502: ( C65 . ( DataLoc (( C65 . R1 ) , R6) ) ) <= ( 0 );
reconsider D132 = D130 as (Element of ( NAT ));
set D133 = D132;
L503: C62 = ( abs ( C66 + R7 ) ) by L487 , L490 , L502 , SCMPDS_2:56;
L504: C62 = ( succ D132 ) by L481 , L482 , L501 , SCMPDS_2:56
.= ( D132 + 1 );
thus L505: C62 in ( {} )
proof
per cases  by L504 , L503 , ABSVALUE:1;
suppose L506: ( D133 + 1 ) = ( C66 + R7 );

L507: ( D128 + 1 ) = ( D128 + ( D127 + R7 ) ) by L506 , L488 , L489;
thus L508: thesis by L507 , L317;
end;
suppose L509: ( D133 + 1 ) = ( - ( C66 + R7 ) );

thus L510: thesis by L509 , L478 , L488 , L489 , L322;
end;
end;

end;
suppose that L506: ( C63 . ( DataLoc (( C63 . R1 ) , R6) ) ) <= ( 0 )
and
L507: ( C65 . ( DataLoc (( C65 . R1 ) , R6) ) ) > ( 0 );
reconsider D134 = D131 as (Element of ( NAT ));
L508: C62 = ( succ D134 ) by L487 , L488 , L507 , SCMPDS_2:56
.= ( D134 + 1 );
set D135 = D134;
L509: C62 = ( abs ( C64 + R7 ) ) by L481 , L484 , L506 , SCMPDS_2:56;
thus L510: C62 in ( {} )
proof
per cases  by L509 , L508 , ABSVALUE:1;
suppose L511: ( D135 + 1 ) = ( C64 + R7 );

thus L512: thesis by L511 , L474 , L482 , L483 , L333;
end;
suppose L513: ( D135 + 1 ) = ( - ( C64 + R7 ) );

thus L514: thesis by L513 , L478 , L482 , L483 , L343;
end;
end;

end;
end;
thus L512: thesis by XBOOLE_1:2;
end;
L513: (for R1 being Int_position holds (for R6 being Integer holds ( JUMP ( (R1 , R6) >=0_goto 5 ) ) = ( {} )))
proof
let R1 being Int_position;
let R6 being Integer;
set D136 = 5;
set D137 = ( (R1 , R6) >=0_goto D136 );
set D138 = { ( NIC (D137 , B52) ) where B52 is (Element of ( NAT )) : (not contradiction) };
thus L514:now
set D139 = 8;
set D140 = 5;
let C67 being set;
assume L515: C67 in ( JUMP D137 );
set D141 = D139;
L516: ( NIC (D137 , D141) ) in D138;
L517: C67 in ( NIC (D137 , D141) ) by L516 , L515 , SETFAM_1:def 1;
consider C68 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L518: C67 = ( IC ( Exec (D137 , C68) ) ) and L519: ( IC C68 ) = D141 by L517;
set D142 = D140;
L520: ( NIC (D137 , D142) ) in D138;
L521: C67 in ( NIC (D137 , D142) ) by L520 , L515 , SETFAM_1:def 1;
consider C69 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L522: C67 = ( IC ( Exec (D137 , C69) ) ) and L523: ( IC C69 ) = D142 by L521;
consider C70 being (Element of ( NAT )) such that L524: C70 = ( IC C68 ) and L525: ( ICplusConst (C68 , D136) ) = ( abs ( C70 + D136 ) ) by SCMPDS_2:def 18;
consider C71 being (Element of ( NAT )) such that L526: C71 = ( IC C69 ) and L527: ( ICplusConst (C69 , D136) ) = ( abs ( C71 + D136 ) ) by SCMPDS_2:def 18;
per cases ;
suppose that L528: ( C69 . ( DataLoc (( C69 . R1 ) , R6) ) ) >= ( 0 )
and
L529: ( C68 . ( DataLoc (( C68 . R1 ) , R6) ) ) >= ( 0 );
L530: C67 = ( abs ( C70 + D136 ) ) by L518 , L525 , L529 , SCMPDS_2:57;
L531: C67 = ( abs ( C71 + D136 ) ) by L522 , L527 , L528 , SCMPDS_2:57;
L532: (( ( ( D140 + 2 ) - 2 ) + D136 ) = ( ( ( D139 + 2 ) - 2 ) + D136 ) or ( ( ( D140 + 2 ) - 2 ) + D136 ) = ( - ( ( ( D139 + 2 ) - 2 ) + D136 ) )) by L531 , L523 , L526 , L519 , L524 , L530 , ABSVALUE:28;
thus L533: C67 in ( {} ) by L532;
end;
suppose that L534: ( C69 . ( DataLoc (( C69 . R1 ) , R6) ) ) < ( 0 )
and
L535: ( C68 . ( DataLoc (( C68 . R1 ) , R6) ) ) < ( 0 );
L536: C67 = ( succ D141 ) by L518 , L519 , L535 , SCMPDS_2:57;
L537: C67 = ( succ D142 ) by L522 , L523 , L534 , SCMPDS_2:57;
thus L538: C67 in ( {} ) by L537 , L536;
end;
suppose that L539: ( C69 . ( DataLoc (( C69 . R1 ) , R6) ) ) < ( 0 )
and
L540: ( C68 . ( DataLoc (( C68 . R1 ) , R6) ) ) >= ( 0 );
reconsider D143 = D142 as (Element of ( NAT ));
set D144 = D143;
L541: C67 = ( abs ( C70 + D136 ) ) by L518 , L525 , L540 , SCMPDS_2:57;
L542: C67 = ( succ D143 ) by L522 , L523 , L539 , SCMPDS_2:57
.= ( D143 + 1 );
L543: (( D144 + 1 ) = ( C70 + D136 ) or ( D144 + 1 ) = ( - ( C70 + D136 ) )) by L542 , L541 , ABSVALUE:1;
thus L544: C67 in ( {} ) by L543 , L519 , L524;
end;
suppose that L545: ( C69 . ( DataLoc (( C69 . R1 ) , R6) ) ) >= ( 0 )
and
L546: ( C68 . ( DataLoc (( C68 . R1 ) , R6) ) ) < ( 0 );
reconsider D145 = D141 as (Element of ( NAT ));
L547: C67 = ( succ D145 ) by L518 , L519 , L546 , SCMPDS_2:57
.= ( D145 + 1 );
set D146 = D145;
L548: C67 = ( abs ( C71 + D136 ) ) by L522 , L527 , L545 , SCMPDS_2:57;
L549: (( D146 + 1 ) = ( C71 + D136 ) or ( D146 + 1 ) = ( - ( C71 + D136 ) )) by L548 , L547 , ABSVALUE:1;
thus L550: C67 in ( {} ) by L549 , L523 , L526;
end;
end;
thus L552: thesis by XBOOLE_1:2;
end;
L553: (for R1 being Int_position holds (for R6 being Integer holds (for R7 being Integer holds (R7 <> 5 implies ( JUMP ( (R1 , R6) >=0_goto R7 ) ) = ( {} )))))
proof
let R1 being Int_position;
let R6 being Integer;
let R7 being Integer;
set D147 = ( (R1 , R6) >=0_goto R7 );
set D148 = { ( NIC (D147 , B53) ) where B53 is (Element of ( NAT )) : (not contradiction) };
assume L554: R7 <> 5;
thus L555:now
set D149 = ( ( ( - R7 ) + ( abs R7 ) ) + 4 );
let C72 being set;
assume L556: C72 in ( JUMP D147 );
L557: D149 > ( ( ( - R7 ) + ( abs R7 ) ) + ( 0 ) ) by XREAL_1:6;
L558: D149 > ( 0 ) by L557 , ABSVALUE:27;
reconsider D150 = D149 as (Element of ( NAT )) by L558 , INT_1:3;
set D151 = ( ( abs R7 ) + D150 );
set D152 = ( D151 + D150 );
set D153 = D151;
set D154 = D152;
L559: ( NIC (D147 , D153) ) in D148;
L560: C72 in ( NIC (D147 , D153) ) by L559 , L556 , SETFAM_1:def 1;
consider C73 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L561: C72 = ( IC ( Exec (D147 , C73) ) ) and L562: ( IC C73 ) = D153 by L560;
consider C74 being (Element of ( NAT )) such that L563: C74 = ( IC C73 ) and L564: ( ICplusConst (C73 , R7) ) = ( abs ( C74 + R7 ) ) by SCMPDS_2:def 18;
L565: ( NIC (D147 , D154) ) in D148;
L566: C72 in ( NIC (D147 , D154) ) by L565 , L556 , SETFAM_1:def 1;
consider C75 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) such that L567: C72 = ( IC ( Exec (D147 , C75) ) ) and L568: ( IC C75 ) = D154 by L566;
consider C76 being (Element of ( NAT )) such that L569: C76 = ( IC C75 ) and L570: ( ICplusConst (C75 , R7) ) = ( abs ( C76 + R7 ) ) by SCMPDS_2:def 18;
per cases ;
suppose that L571: ( C73 . ( DataLoc (( C73 . R1 ) , R6) ) ) >= ( 0 )
and
L572: ( C75 . ( DataLoc (( C75 . R1 ) , R6) ) ) >= ( 0 );
L573: C72 = ( abs ( C76 + R7 ) ) by L567 , L570 , L572 , SCMPDS_2:57;
L574: C72 = ( abs ( C74 + R7 ) ) by L561 , L564 , L571 , SCMPDS_2:57;
thus L575: C72 in ( {} )
proof
per cases  by L562 , L563 , L568 , L569 , L574 , L573 , ABSVALUE:28;
suppose L576: ( ( ( D151 + 2 ) - 2 ) + R7 ) = ( ( ( D152 + 2 ) - 2 ) + R7 );

thus L577: thesis by L576 , L557 , ABSVALUE:27;
end;
suppose L578: ( ( ( D151 + 2 ) - 2 ) + R7 ) = ( - ( ( ( D152 + 2 ) - 2 ) + R7 ) );

thus L579: thesis by L578 , L310;
end;
end;

end;
suppose that L576: ( C73 . ( DataLoc (( C73 . R1 ) , R6) ) ) < ( 0 )
and
L577: ( C75 . ( DataLoc (( C75 . R1 ) , R6) ) ) < ( 0 );
L578: C72 = ( succ D154 ) by L567 , L568 , L577 , SCMPDS_2:57;
L579: C72 = ( succ D153 ) by L561 , L562 , L576 , SCMPDS_2:57;
thus L580: C72 in ( {} ) by L579 , L557 , L578 , ABSVALUE:27;
end;
suppose that L581: ( C73 . ( DataLoc (( C73 . R1 ) , R6) ) ) < ( 0 )
and
L582: ( C75 . ( DataLoc (( C75 . R1 ) , R6) ) ) >= ( 0 );
reconsider D155 = D153 as (Element of ( NAT ));
set D156 = D155;
L583: C72 = ( abs ( C76 + R7 ) ) by L567 , L570 , L582 , SCMPDS_2:57;
L584: C72 = ( succ D155 ) by L561 , L562 , L581 , SCMPDS_2:57
.= ( D155 + 1 );
thus L585: C72 in ( {} )
proof
per cases  by L584 , L583 , ABSVALUE:1;
suppose L586: ( D156 + 1 ) = ( C76 + R7 );

L587: ( D151 + 1 ) = ( D151 + ( D150 + R7 ) ) by L586 , L568 , L569;
thus L588: thesis by L587 , L317;
end;
suppose L589: ( D156 + 1 ) = ( - ( C76 + R7 ) );

thus L590: thesis by L589 , L558 , L568 , L569 , L322;
end;
end;

end;
suppose that L586: ( C73 . ( DataLoc (( C73 . R1 ) , R6) ) ) >= ( 0 )
and
L587: ( C75 . ( DataLoc (( C75 . R1 ) , R6) ) ) < ( 0 );
reconsider D157 = D154 as (Element of ( NAT ));
L588: C72 = ( succ D157 ) by L567 , L568 , L587 , SCMPDS_2:57
.= ( D157 + 1 );
set D158 = D157;
L589: C72 = ( abs ( C74 + R7 ) ) by L561 , L564 , L586 , SCMPDS_2:57;
thus L590: C72 in ( {} )
proof
per cases  by L589 , L588 , ABSVALUE:1;
suppose L591: ( D158 + 1 ) = ( C74 + R7 );

thus L592: thesis by L591 , L554 , L562 , L563 , L333;
end;
suppose L593: ( D158 + 1 ) = ( - ( C74 + R7 ) );

thus L594: thesis by L593 , L558 , L562 , L563 , L343;
end;
end;

end;
end;
thus L592: thesis by XBOOLE_1:2;
end;
registration
let R1 being Int_position;
let R6 being Integer;
let R7 being Integer;
cluster ( JUMP ( (R1 , R6) <>0_goto R7 ) ) ->  empty;
coherence
proof
L593: (R7 = 5 or R7 <> 5);
thus L594: thesis by L593 , L353 , L393;
end;
cluster ( JUMP ( (R1 , R6) <=0_goto R7 ) ) ->  empty;
coherence
proof
L595: (R7 = 5 or R7 <> 5);
thus L596: thesis by L595 , L433 , L473;
end;
cluster ( JUMP ( (R1 , R6) >=0_goto R7 ) ) ->  empty;
coherence
proof
L597: (R7 = 5 or R7 <> 5);
thus L598: thesis by L597 , L513 , L553;
end;
end;
theorem
L600: (for R4 being (Element of ( NAT )) holds ( SUCC (R4 , ( SCMPDS )) ) = ( NAT ))
proof
let R4 being (Element of ( NAT ));
thus L601: ( SUCC (R4 , ( SCMPDS )) ) c= ( NAT );
let C77 being set;
set D159 = { ( ( NIC (B54 , R4) ) \ ( JUMP B54 ) ) where B54 is (Element of (the InstructionsF of ( SCMPDS ))) : (not contradiction) };
assume L602: C77 in ( NAT );
reconsider D160 = C77 as (Element of ( NAT )) by L602;
reconsider D161 = D160 as (Element of ( NAT ));
set D162 = ( goto ( D161 - R4 ) );
L603: ( NIC (D162 , R4) ) = { ( abs ( ( D161 - R4 ) + R4 ) ) } by L55
.= { D160 } by ABSVALUE:def 1;
L604: D160 in ( ( NIC (D162 , R4) ) \ ( JUMP D162 ) ) by L603 , TARSKI:def 1;
L605: ( ( NIC (D162 , R4) ) \ ( JUMP D162 ) ) in D159;
thus L606: thesis by L605 , L604 , TARSKI:def 4;
end;
registration
cluster ( SCMPDS ) -> non  InsLoc-antisymmetric;
coherence
proof
L607: ( SUCC (2 , ( SCMPDS )) ) = ( NAT ) by L600;
L608: 2 <= 1 , ( SCMPDS ) by L607 , AMI_WSTD:33;
L609: ( SUCC (1 , ( SCMPDS )) ) = ( NAT ) by L600;
L610: 1 <= 2 , ( SCMPDS ) by L609 , AMI_WSTD:33;
assume L611: ( SCMPDS ) is  InsLoc-antisymmetric;
thus L612: thesis by L611 , L610 , L608 , AMI_WSTD:def 2;
end;
end;
registration
cluster ( SCMPDS ) -> non  weakly_standard;
coherence by AMI_WSTD:10;
end;
