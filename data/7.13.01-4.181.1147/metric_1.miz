:: Metric Spaces
::  by Stanis{\l}awa Kanas, Adam Lecko and Mariusz Startek
::
:: Received May 3, 1990
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, STRUCT_0, FUNCT_1, ZFMISC_1, XBOOLE_0, PARTFUN1,
      SUBSET_1, REAL_1, RELAT_1, CARD_1, FUNCT_5, TARSKI, VALUED_0, ORDINAL1,
      XXREAL_0, ARYTM_3, RELAT_2, FUNCT_3, COMPLEX1, ARYTM_1, XREAL_0,
      METRIC_1, FUNCOP_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0,
      XXREAL_0, XREAL_0, COMPLEX1, REAL_1, RELAT_1, FUNCOP_1, FUNCT_1,
      PARTFUN1, FUNCT_2, FUNCT_3, BINOP_1, FUNCT_5, VALUED_0, STRUCT_0;
 constructors BINOP_1, FUNCT_3, XXREAL_0, REAL_1, COMPLEX1, STRUCT_0, VALUED_1,
      FUNCT_5, PARTFUN1, RELSET_1, FUNCOP_1;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, NUMBERS, XREAL_0, MEMBERED,
      STRUCT_0, VALUED_0, FUNCT_2, PARTFUN1, RELSET_1;
 requirements BOOLE, REAL, NUMERALS, SUBSET, ARITHM;
 definitions STRUCT_0, XBOOLE_0, BINOP_1, FUNCT_5;
 theorems TARSKI, BINOP_1, ZFMISC_1, FUNCT_2, RELSET_1, RELAT_1, FUNCT_3,
      ABSVALUE, SUBSET_1, PARTFUN1, CARD_1, FUNCT_1, XBOOLE_0, XBOOLE_1,
      XREAL_1, COMPLEX1, XXREAL_0, SQUARE_1, FUNCOP_1;
 schemes FRAENKEL, BINOP_1;

begin
definition
struct (1-sorted) MetrStruct(# carrier -> set , distance -> (Function of [: the carrier , the carrier :] , ( REAL )) #);
end;
registration
cluster non  empty  strict for MetrStruct;
existence
proof
set D1 = the non  empty set;
set D2 = the (Function of [: D1 , D1 :] , ( REAL ));
take MetrStruct (# D1 , D2 #);
thus L2: (the carrier of MetrStruct (# D1 , D2 #)) is non  empty;
thus L3: thesis;
end;
end;
definition
let C1 , C2 being set;
let C3 being (PartFunc of [: C1 , C2 :] , ( REAL ));
let C4 being (Element of C1);
let C5 being (Element of C2);
redefine func C3 . (C4 , C5) -> Real;

coherence
proof
per cases ;
suppose L5: [ C4 , C5 ] in ( dom C3 );

thus L6: thesis by L5 , PARTFUN1:4;
end;
suppose L7: (not [ C4 , C5 ] in ( dom C3 ));

L8: ( C3 . (C4 , C5) ) = ( 0 ) by L7 , FUNCT_1:def 2;
thus L9: thesis by L8;
end;
end;
end;
definition
let C6 being MetrStruct;
let C7 , C8 being (Element of C6);
func dist (C7 , C8) -> Real equals 
( (the distance of C6) . (C7 , C8) );
coherence;
end;
notation
synonym Empty^2-to-zero for op2;
end;
definition
redefine func Empty^2-to-zero -> (Function of [: 1 , 1 :] , ( REAL ));

coherence
proof
L14: ( 0 ) in ( REAL );
L15: (( op2 ) is (Function of [: 1 , 1 :] , 1) & 1 c= ( REAL )) by L14 , CARD_1:49 , ZFMISC_1:31;
thus L16: thesis by L15 , FUNCT_2:7;
end;
end;
L18: ( ( op2 ) . (( {} ) , ( {} )) ) = ( 0 )
proof
L19: [ ( {} ) , ( {} ) ] in [: { ( {} ) } , { ( {} ) } :] by ZFMISC_1:28;
thus L20: ( ( op2 ) . (( {} ) , ( {} )) ) = ( {} ) by L19 , FUNCT_2:50;
end;
L21: (for B1 , B2 being (Element of 1) holds (( ( op2 ) . (B1 , B2) ) = ( 0 ) iff B1 = B2))
proof
let C9 , C10 being (Element of 1);
L22: C9 = ( {} ) by CARD_1:49 , TARSKI:def 1;
thus L23: thesis by L22 , CARD_1:49 , TARSKI:def 1;
end;
L24: (for B3 , B4 being (Element of 1) holds ( ( op2 ) . (B3 , B4) ) = ( ( op2 ) . (B4 , B3) ))
proof
let C11 , C12 being (Element of 1);
L25: (C11 = ( {} ) & C12 = ( {} )) by CARD_1:49 , TARSKI:def 1;
thus L26: thesis by L25;
end;
registration
cluster ( op2 ) ->  natural-valued for Function;
coherence;
end;
registration
let C13 being  natural-valued Function;
let C14 , C15 being set;
cluster ( C13 . (C14 , C15) ) ->  natural;
coherence;
end;
L29: (for B5 , B6 , B7 being (Element of 1) holds ( ( op2 ) . (B5 , B7) ) <= ( ( ( op2 ) . (B5 , B6) ) + ( ( op2 ) . (B6 , B7) ) ))
proof
let C16 , C17 , C18 being (Element of 1);
L30: (C16 = ( {} ) & C17 = ( {} )) by CARD_1:49 , TARSKI:def 1;
thus L31: thesis by L30 , L18;
end;
definition
let C19 being set;
let C20 being (PartFunc of [: C19 , C19 :] , ( REAL ));
attr C20 is  Reflexive
means
:L32: (for B8 being (Element of C19) holds ( C20 . (B8 , B8) ) = ( 0 ));
attr C20 is  discerning
means
:L33: (for B9 , B10 being (Element of C19) holds (( C20 . (B9 , B10) ) = ( 0 ) implies B9 = B10));
attr C20 is  symmetric
means
:L34: (for B11 , B12 being (Element of C19) holds ( C20 . (B11 , B12) ) = ( C20 . (B12 , B11) ));
attr C20 is  triangle
means
:L35: (for B13 , B14 , B15 being (Element of C19) holds ( C20 . (B13 , B15) ) <= ( ( C20 . (B13 , B14) ) + ( C20 . (B14 , B15) ) ));
end;
definition
let C21 being MetrStruct;
attr C21 is  Reflexive
means
:L37: (the distance of C21) is  Reflexive;
attr C21 is  discerning
means
:L38: (the distance of C21) is  discerning;
attr C21 is  symmetric
means
:L39: (the distance of C21) is  symmetric;
attr C21 is  triangle
means
:L40: (the distance of C21) is  triangle;
end;
registration
cluster  strict  Reflexive  discerning  symmetric  triangle non  empty for MetrStruct;
existence
proof
reconsider D3 = MetrStruct (# 1 , ( Empty^2-to-zero ) #) as  strict non  empty MetrStruct;
take D3;
L42: (the distance of D3) is  discerning
proof
let C22 , C23 being (Element of D3);
assume L43: ( (the distance of D3) . (C22 , C23) ) = ( 0 );
thus L44: thesis by L43 , L21;
end;
L45: (the distance of D3) is  symmetric
proof
let C24 , C25 being (Element of D3);
thus L46: thesis by L24;
end;
L47: (the distance of D3) is  triangle
proof
let C26 , C27 , C28 being (Element of D3);
thus L48: thesis by L29;
end;
L49: (the distance of D3) is  Reflexive
proof
let C29 being (Element of D3);
thus L50: thesis by L21;
end;
thus L51: thesis by L49 , L42 , L45 , L47 , L37 , L38 , L39 , L40;
end;
end;
definition
mode MetrSpace
 is  Reflexive  discerning  symmetric  triangle MetrStruct;
end;
theorem
L54: (for B16 being MetrStruct holds ((for B17 being (Element of B16) holds ( dist (B17 , B17) ) = ( 0 )) iff B16 is  Reflexive))
proof
let C30 being MetrStruct;
thus L55:now
assume L56: (for B18 being (Element of C30) holds ( dist (B18 , B18) ) = ( 0 ));
L57: (the distance of C30) is  Reflexive
proof
let C31 being (Element of C30);
L58: ( (the distance of C30) . (C31 , C31) ) = ( dist (C31 , C31) )
.= ( 0 ) by L56;
thus L59: thesis by L58;
end;
thus L60: C30 is  Reflexive by L57 , L37;
end;
assume L61: C30 is  Reflexive;
L62: (the distance of C30) is  Reflexive by L61 , L37;
thus L63: thesis by L62 , L32;
end;
theorem
L64: (for B19 being MetrStruct holds ((for B20 , B21 being (Element of B19) holds (( dist (B20 , B21) ) = ( 0 ) implies B20 = B21)) iff B19 is  discerning))
proof
let C32 being MetrStruct;
thus L65:now
assume L66: (for B22 , B23 being (Element of C32) holds (( dist (B22 , B23) ) = ( 0 ) implies B22 = B23));
L67: (the distance of C32) is  discerning
proof
let C33 , C34 being (Element of C32);
assume L68: ( (the distance of C32) . (C33 , C34) ) = ( 0 );
L69: ( dist (C33 , C34) ) = ( 0 ) by L68;
thus L70: thesis by L69 , L66;
end;
thus L71: C32 is  discerning by L67 , L38;
end;
assume L72: C32 is  discerning;
L73: (the distance of C32) is  discerning by L72 , L38;
thus L74: thesis by L73 , L33;
end;
theorem
L75: (for B24 being MetrStruct holds ((for B25 , B26 being (Element of B24) holds ( dist (B25 , B26) ) = ( dist (B26 , B25) )) implies B24 is  symmetric))
proof
let C35 being MetrStruct;
assume L76: (for B27 , B28 being (Element of C35) holds ( dist (B27 , B28) ) = ( dist (B28 , B27) ));
L77: (the distance of C35) is  symmetric
proof
let C36 , C37 being (Element of C35);
thus L78: ( (the distance of C35) . (C36 , C37) ) = ( dist (C36 , C37) )
.= ( dist (C37 , C36) ) by L76
.= ( (the distance of C35) . (C37 , C36) );
end;
thus L79: C35 is  symmetric by L77 , L39;
end;
theorem
L80: (for B29 being MetrStruct holds ((for B30 , B31 , B32 being (Element of B29) holds ( dist (B30 , B32) ) <= ( ( dist (B30 , B31) ) + ( dist (B31 , B32) ) )) iff B29 is  triangle))
proof
let C38 being MetrStruct;
thus L81:now
assume L82: (for B33 , B34 , B35 being (Element of C38) holds ( dist (B33 , B35) ) <= ( ( dist (B33 , B34) ) + ( dist (B34 , B35) ) ));
L83: (the distance of C38) is  triangle
proof
let C39 , C40 , C41 being (Element of C38);
L84: ( (the distance of C38) . (C40 , C41) ) = ( dist (C40 , C41) );
L85: (( (the distance of C38) . (C39 , C40) ) = ( dist (C39 , C40) ) & ( (the distance of C38) . (C39 , C41) ) = ( dist (C39 , C41) ));
thus L86: thesis by L85 , L82 , L84;
end;
thus L87: C38 is  triangle by L83 , L40;
end;
assume L88: C38 is  triangle;
let C42 , C43 , C44 being (Element of C38);
L89: (the distance of C38) is  triangle by L88 , L40;
thus L90: thesis by L89 , L35;
end;
definition
let C45 being  symmetric MetrStruct;
let C46 , C47 being (Element of C45);
redefine func dist (C46 , C47);

commutativity
proof
L91: (the distance of C45) is  symmetric by L39;
thus L92: thesis by L91 , L34;
end;
end;
theorem
L94: (for B36 being  symmetric  triangle  Reflexive MetrStruct holds (for B37 , B38 being (Element of B36) holds ( 0 ) <= ( dist (B37 , B38) )))
proof
let C48 being  symmetric  triangle  Reflexive MetrStruct;
let C49 , C50 being (Element of C48);
L95: ( ( 1 / 2 ) * ( dist (C49 , C49) ) ) = ( ( 1 / 2 ) * ( 0 ) ) by L54;
L96: (( dist (C49 , C49) ) <= ( ( dist (C49 , C50) ) + ( dist (C50 , C49) ) ) & ( dist (C49 , C50) ) = ( ( 1 / 2 ) * ( ( 1 * ( dist (C49 , C50) ) ) + ( 1 * ( dist (C49 , C50) ) ) ) )) by L80;
thus L97: thesis by L96 , L95 , XREAL_1:64;
end;
theorem
L98: (for B39 being MetrStruct holds ((for B40 , B41 , B42 being (Element of B39) holds ((( dist (B40 , B41) ) = ( 0 ) iff B40 = B41) & ( dist (B40 , B41) ) = ( dist (B41 , B40) ) & ( dist (B40 , B42) ) <= ( ( dist (B40 , B41) ) + ( dist (B41 , B42) ) ))) implies B39 is MetrSpace))
proof
let C51 being MetrStruct;
assume L99: (for B43 , B44 , B45 being (Element of C51) holds ((( dist (B43 , B44) ) = ( 0 ) iff B43 = B44) & ( dist (B43 , B44) ) = ( dist (B44 , B43) ) & ( dist (B43 , B45) ) <= ( ( dist (B43 , B44) ) + ( dist (B44 , B45) ) )));
L100: (the distance of C51) is  symmetric
proof
let C52 , C53 being (Element of C51);
L101: ( (the distance of C51) . (C52 , C53) ) = ( dist (C52 , C53) )
.= ( dist (C53 , C52) ) by L99
.= ( (the distance of C51) . (C53 , C52) );
thus L102: thesis by L101;
end;
L103: (the distance of C51) is  triangle
proof
let C54 , C55 , C56 being (Element of C51);
L104: ( (the distance of C51) . (C55 , C56) ) = ( dist (C55 , C56) );
L105: (( (the distance of C51) . (C54 , C56) ) = ( dist (C54 , C56) ) & ( (the distance of C51) . (C54 , C55) ) = ( dist (C54 , C55) ));
thus L106: thesis by L105 , L99 , L104;
end;
L107: (the distance of C51) is  discerning
proof
let C57 , C58 being (Element of C51);
assume L108: ( (the distance of C51) . (C57 , C58) ) = ( 0 );
L109: ( dist (C57 , C58) ) = ( 0 ) by L108;
thus L110: thesis by L109 , L99;
end;
L111: (the distance of C51) is  Reflexive
proof
let C59 being (Element of C51);
L112: ( (the distance of C51) . (C59 , C59) ) = ( dist (C59 , C59) )
.= ( 0 ) by L99;
thus L113: thesis by L112;
end;
thus L114: thesis by L111 , L107 , L100 , L103 , L37 , L38 , L39 , L40;
end;
theorem
L115: (for B46 being MetrSpace holds (for B47 , B48 being (Element of B46) holds (B47 <> B48 implies ( 0 ) < ( dist (B47 , B48) ))))
proof
let C60 being MetrSpace;
let C61 , C62 being (Element of C60);
L116: ( dist (C61 , C62) ) >= ( 0 ) by L94;
assume L117: C61 <> C62;
L118: ( dist (C61 , C62) ) <> ( 0 ) by L117 , L64;
thus L119: thesis by L118 , L116 , XXREAL_0:1;
end;
definition
let C63 being set;
func discrete_dist C63 -> (Function of [: C63 , C63 :] , ( REAL )) means 
:L120: (for B49 , B50 being (Element of C63) holds (( it . (B49 , B49) ) = ( 0 ) & (B49 <> B50 implies ( it . (B49 , B50) ) = 1)));
existence
proof
per cases ;
suppose L121: C63 is  empty;

L122: [: C63 , C63 :] = ( {} ) by L121 , ZFMISC_1:90;
reconsider D4 = ( {} ) as (Function of [: C63 , C63 :] , ( REAL )) by L122 , RELSET_1:12;
take D4;
let C64 , C65 being (Element of C63);
thus L123: ( D4 . (C64 , C64) ) = ( 0 );
L124: C64 = ( {} ) by L121 , SUBSET_1:def 1
.= C65 by L121 , SUBSET_1:def 1;
thus L125: thesis by L124;
end;
suppose L126: C63 is non  empty;

L127: ({ ( 0 ) , 1 } c= ( REAL ) & ( rng ( chi (( [: C63 , C63 :] \ ( id C63 ) ) , [: C63 , C63 :]) ) ) c= { ( 0 ) , 1 }) by FUNCT_3:39 , ZFMISC_1:32;
L128: ( rng ( chi (( [: C63 , C63 :] \ ( id C63 ) ) , [: C63 , C63 :]) ) ) c= ( REAL ) by L127 , XBOOLE_1:1;
L129: ( dom ( chi (( [: C63 , C63 :] \ ( id C63 ) ) , [: C63 , C63 :]) ) ) = [: C63 , C63 :] by FUNCT_3:def 3;
reconsider D5 = ( chi (( [: C63 , C63 :] \ ( id C63 ) ) , [: C63 , C63 :]) ) as (Function of [: C63 , C63 :] , ( REAL )) by L129 , L128 , RELSET_1:4;
take D5;
let C66 , C67 being (Element of C63);
L130: ( [: C63 , C63 :] \ ( [: C63 , C63 :] \ ( id C63 ) ) ) = ( [: C63 , C63 :] /\ ( id C63 ) ) by XBOOLE_1:48
.= ( id C63 ) by XBOOLE_1:28;
L131: [ C66 , C66 ] in ( [: C63 , C63 :] \ ( [: C63 , C63 :] \ ( id C63 ) ) ) by L130 , L126 , RELAT_1:def 10;
thus L132: ( D5 . (C66 , C66) ) = ( 0 ) by L131 , FUNCT_3:37;
assume L133: C66 <> C67;
L134: (not [ C66 , C67 ] in ( id C63 )) by L133 , RELAT_1:def 10;
L135: [ C66 , C67 ] in [: C63 , C63 :] by L126 , ZFMISC_1:def 2;
L136: [ C66 , C67 ] in ( [: C63 , C63 :] \ ( id C63 ) ) by L135 , L134 , XBOOLE_0:def 5;
thus L137: thesis by L136 , FUNCT_3:def 3;
end;
end;
uniqueness
proof
let C68 , C69 being (Function of [: C63 , C63 :] , ( REAL ));
assume that
L139: (for B51 , B52 being (Element of C63) holds (( C68 . (B51 , B51) ) = ( 0 ) & (B51 <> B52 implies ( C68 . (B51 , B52) ) = 1)))
and
L140: (for B53 , B54 being (Element of C63) holds (( C69 . (B53 , B53) ) = ( 0 ) & (B53 <> B54 implies ( C69 . (B53 , B54) ) = 1)));
L141:
now
let C70 , C71 being (Element of C63);
L142:
now
per cases ;
suppose L143: C70 = C71;

thus L144: ( C68 . (C70 , C71) ) = ( 0 ) by L143 , L139
.= ( C69 . (C70 , C71) ) by L140 , L143;
end;
suppose L145: C70 <> C71;

thus L146: ( C68 . (C70 , C71) ) = 1 by L145 , L139
.= ( C69 . (C70 , C71) ) by L140 , L145;
end;
end;
thus L148: ( C68 . (C70 , C71) ) = ( C69 . (C70 , C71) ) by L142;
end;
thus L149: thesis by L141 , BINOP_1:2;
end;
end;
definition
let C72 being set;
func DiscreteSpace C72 ->  strict MetrStruct equals 
MetrStruct (# C72 , ( discrete_dist C72 ) #);
coherence;
end;
registration
let C73 being non  empty set;
cluster ( DiscreteSpace C73 ) -> non  empty;
coherence;
end;
registration
let C74 being set;
cluster ( DiscreteSpace C74 ) ->  Reflexive  discerning  symmetric  triangle;
coherence
proof
set D6 = MetrStruct (# C74 , ( discrete_dist C74 ) #);
L153: (the distance of D6) is  discerning
proof
let C75 , C76 being (Element of D6);
assume L154: ( (the distance of D6) . (C75 , C76) ) = ( 0 );
thus L155: thesis by L154 , L120;
end;
L156: (the distance of D6) is  symmetric
proof
let C77 , C78 being (Element of D6);
L157:
now
per cases ;
suppose L158: C77 <> C78;

thus L159: ( (the distance of D6) . (C77 , C78) ) = 1 by L158 , L120
.= ( (the distance of D6) . (C78 , C77) ) by L158 , L120;
end;
suppose L160: C77 = C78;

thus L161: thesis by L160;
end;
end;
thus L163: thesis by L157;
end;
L164: (the distance of D6) is  triangle
proof
let C79 , C80 , C81 being (Element of D6);
L165: (( (the distance of D6) . (C79 , C80) ) = ( 0 ) iff C79 = C80) by L120;
per cases ;
suppose L166: (C79 = C80 & C79 = C81);

thus L167: thesis by L166 , L165;
end;
suppose L168: (C79 = C80 & C79 <> C81);

thus L169: thesis by L168 , L165;
end;
suppose L170: (C79 = C81 & C79 <> C80);

L171: ( (the distance of D6) . (C80 , C81) ) = 1 by L170 , L120;
L172: (( (the distance of D6) . (C79 , C81) ) = ( 0 ) & ( (the distance of D6) . (C79 , C80) ) = 1) by L170 , L120;
thus L173: thesis by L172 , L171;
end;
suppose L174: (C80 = C81 & C79 <> C81);

L175: ( (the distance of D6) . (C80 , C81) ) = ( 0 ) by L174 , L120;
thus L176: thesis by L175 , L174;
end;
suppose L177: (C79 <> C80 & C79 <> C81 & C80 <> C81);

L178: ( (the distance of D6) . (C80 , C81) ) = 1 by L177 , L120;
L179: (( (the distance of D6) . (C79 , C81) ) = 1 & ( (the distance of D6) . (C79 , C80) ) = 1) by L177 , L120;
thus L180: thesis by L179 , L178;
end;
end;
L182: (the distance of D6) is  Reflexive
proof
let C82 being (Element of D6);
thus L183: thesis by L120;
end;
thus L184: thesis by L182 , L153 , L156 , L164 , L37 , L38 , L39 , L40;
end;
end;
definition
func real_dist -> (Function of [: ( REAL ) , ( REAL ) :] , ( REAL )) means 
:L186: (for B55 , B56 being (Element of ( REAL )) holds ( it . (B55 , B56) ) = ( abs ( B55 - B56 ) ));
existence
proof
deffunc H1((Element of ( REAL )) , (Element of ( REAL ))) = ( abs ( $1 - $2 ) );
consider C83 being (Function of [: ( REAL ) , ( REAL ) :] , ( REAL )) such that L187: (for B57 , B58 being (Element of ( REAL )) holds ( C83 . (B57 , B58) ) = H1(B57 , B58)) from BINOP_1:sch 4;
take C83;
let C84 , C85 being (Element of ( REAL ));
thus L188: thesis by L187;
end;
uniqueness
proof
let C86 , C87 being (Function of [: ( REAL ) , ( REAL ) :] , ( REAL ));
assume that
L189: (for B59 , B60 being (Element of ( REAL )) holds ( C86 . (B59 , B60) ) = ( abs ( B59 - B60 ) ))
and
L190: (for B61 , B62 being (Element of ( REAL )) holds ( C87 . (B61 , B62) ) = ( abs ( B61 - B62 ) ));
L191: (for B63 , B64 being (Element of ( REAL )) holds ( C86 . (B63 , B64) ) = ( C87 . (B63 , B64) ))
proof
let C88 , C89 being (Element of ( REAL ));
thus L192: ( C86 . (C88 , C89) ) = ( abs ( C88 - C89 ) ) by L189
.= ( C87 . (C88 , C89) ) by L190;
end;
thus L193: thesis by L191 , BINOP_1:2;
end;
end;
theorem
L195: (for B65 , B66 being (Element of ( REAL )) holds (( ( real_dist ) . (B65 , B66) ) = ( 0 ) iff B65 = B66))
proof
let C90 , C91 being (Element of ( REAL ));
thus L196: (( ( real_dist ) . (C90 , C91) ) = ( 0 ) implies C90 = C91)
proof
assume L197: ( ( real_dist ) . (C90 , C91) ) = ( 0 );
L198: ( 0 ) = ( abs ( C90 - C91 ) ) by L197 , L186;
L199: ( C90 - C91 ) = ( 0 ) by L198 , ABSVALUE:2;
thus L200: thesis by L199;
end;

assume L201: C90 = C91;
L202: ( abs ( C90 - C91 ) ) = ( 0 ) by L201 , ABSVALUE:2;
thus L203: thesis by L202 , L186;
end;
theorem
L204: (for B67 , B68 being (Element of ( REAL )) holds ( ( real_dist ) . (B67 , B68) ) = ( ( real_dist ) . (B68 , B67) ))
proof
let C92 , C93 being (Element of ( REAL ));
thus L205: ( ( real_dist ) . (C92 , C93) ) = ( abs ( C92 - C93 ) ) by L186
.= ( abs ( - ( C92 - C93 ) ) ) by COMPLEX1:52
.= ( abs ( C93 - C92 ) )
.= ( ( real_dist ) . (C93 , C92) ) by L186;
end;
theorem
L206: (for B69 , B70 , B71 being (Element of ( REAL )) holds ( ( real_dist ) . (B69 , B70) ) <= ( ( ( real_dist ) . (B69 , B71) ) + ( ( real_dist ) . (B71 , B70) ) ))
proof
let C94 , C95 , C96 being (Element of ( REAL ));
L207: ( abs ( C94 - C95 ) ) = ( abs ( ( C94 - C96 ) + ( C96 - C95 ) ) );
L208: ( abs ( C94 - C95 ) ) <= ( ( abs ( C94 - C96 ) ) + ( abs ( C96 - C95 ) ) ) by L207 , COMPLEX1:56;
L209: (( ( real_dist ) . (C94 , C95) ) = ( abs ( C94 - C95 ) ) & ( ( real_dist ) . (C94 , C96) ) = ( abs ( C94 - C96 ) )) by L186;
thus L210: thesis by L209 , L208 , L186;
end;
definition
func RealSpace ->  strict MetrStruct equals 
MetrStruct (# ( REAL ) , ( real_dist ) #);
coherence;
end;
registration
cluster ( RealSpace ) -> non  empty;
coherence;
end;
registration
cluster ( RealSpace ) ->  Reflexive  discerning  symmetric  triangle;
coherence
proof
reconsider D7 = MetrStruct (# ( REAL ) , ( real_dist ) #) as non  empty MetrStruct;
L213: (for B72 , B73 , B74 being (Element of D7) holds ((( dist (B72 , B73) ) = ( 0 ) iff B72 = B73) & ( dist (B72 , B73) ) = ( dist (B73 , B72) ) & ( dist (B72 , B74) ) <= ( ( dist (B72 , B73) ) + ( dist (B73 , B74) ) ))) by L195 , L204 , L206;
thus L214: thesis by L213 , L98;
end;
end;
definition
let C97 being MetrStruct;
let C98 being (Element of C97);
let C99 being  real number;
func Ball (C98 , C99) -> (Subset of C97) means 
:L216: it = { B75 where B75 is (Element of C97) : ( dist (C98 , B75) ) < C99 } if C97 is non  empty otherwise it is  empty;
existence
proof
reconsider D8 = ( {} ) as (Subset of C97) by XBOOLE_1:2;
thus L217: (C97 is non  empty implies (ex B76 being (Subset of C97) st B76 = { B77 where B77 is (Element of C97) : ( dist (C98 , B77) ) < C99 }))
proof
assume L218: C97 is non  empty;
reconsider D9 = C97 as non  empty MetrStruct by L218;
reconsider D10 = C98 as (Element of D9);
defpred S1[ (Element of D9) ] means ( dist (D10 , $1) ) < C99;
set D11 = { B78 where B78 is (Element of D9) : S1[ B78 ] };
L219: D11 c= (the carrier of D9) from FRAENKEL:sch 10;
reconsider D12 = D11 as (Subset of C97) by L219;
take D12;
thus L220: thesis;
end;

assume L221: C97 is  empty;
take D8;
thus L222: thesis;
end;
correctness;
end;
definition
let C100 being MetrStruct;
let C101 being (Element of C100);
let C102 being  real number;
func cl_Ball (C101 , C102) -> (Subset of C100) means 
:L224: it = { B79 where B79 is (Element of C100) : ( dist (C101 , B79) ) <= C102 } if C100 is non  empty otherwise it is  empty;
existence
proof
reconsider D13 = ( {} ) as (Subset of C100) by XBOOLE_1:2;
thus L225: (C100 is non  empty implies (ex B80 being (Subset of C100) st B80 = { B81 where B81 is (Element of C100) : ( dist (C101 , B81) ) <= C102 }))
proof
assume L226: C100 is non  empty;
reconsider D14 = C100 as non  empty MetrStruct by L226;
reconsider D15 = C101 as (Element of D14);
defpred S2[ (Element of D14) ] means ( dist (D15 , $1) ) <= C102;
set D16 = { B82 where B82 is (Element of D14) : S2[ B82 ] };
L227: D16 c= (the carrier of D14) from FRAENKEL:sch 10;
reconsider D17 = D16 as (Subset of C100) by L227;
take D17;
thus L228: thesis;
end;

assume L229: C100 is  empty;
take D13;
thus L230: thesis;
end;
correctness;
end;
definition
let C103 being MetrStruct;
let C104 being (Element of C103);
let C105 being  real number;
func Sphere (C104 , C105) -> (Subset of C103) means 
:L232: it = { B83 where B83 is (Element of C103) : ( dist (C104 , B83) ) = C105 } if C103 is non  empty otherwise it is  empty;
existence
proof
reconsider D18 = ( {} ) as (Subset of C103) by XBOOLE_1:2;
thus L233: (C103 is non  empty implies (ex B84 being (Subset of C103) st B84 = { B85 where B85 is (Element of C103) : ( dist (C104 , B85) ) = C105 }))
proof
assume L234: C103 is non  empty;
reconsider D19 = C103 as non  empty MetrStruct by L234;
reconsider D20 = C104 as (Element of D19);
defpred S3[ (Element of D19) ] means ( dist (D20 , $1) ) = C105;
set D21 = { B86 where B86 is (Element of D19) : S3[ B86 ] };
L235: D21 c= (the carrier of D19) from FRAENKEL:sch 10;
reconsider D22 = D21 as (Subset of C103) by L235;
take D22;
thus L236: thesis;
end;

assume L237: C103 is  empty;
take D18;
thus L238: thesis;
end;
correctness;
end;
theorem
L240: (for R1 being  real number holds (for B87 being MetrStruct holds (for B88 , B89 being (Element of B87) holds (B89 in ( Ball (B88 , R1) ) iff (B87 is non  empty & ( dist (B88 , B89) ) < R1)))))
proof
let R1 being  real number;
let C106 being MetrStruct;
let C107 , C108 being (Element of C106);
thus L241:now
assume L242: C108 in ( Ball (C107 , R1) );
reconsider D23 = C106 as non  empty MetrStruct by L242;
reconsider D24 = C107 as (Element of D23);
L243: C108 in { B90 where B90 is (Element of D23) : ( dist (D24 , B90) ) < R1 } by L242 , L216;
L244: (ex B91 being (Element of C106) st (C108 = B91 & ( dist (C107 , B91) ) < R1)) by L243;
thus L245: (C106 is non  empty & ( dist (C107 , C108) ) < R1) by L244 , L242;
end;
assume L246: C106 is non  empty;
reconsider D25 = C106 as non  empty MetrStruct by L246;
reconsider D26 = C107 as (Element of D25);
assume L247: ( dist (C107 , C108) ) < R1;
L248: C108 in { B92 where B92 is (Element of D25) : ( dist (D26 , B92) ) < R1 } by L247;
thus L249: thesis by L248 , L216;
end;
theorem
L250: (for R1 being  real number holds (for B93 being MetrStruct holds (for B94 , B95 being (Element of B93) holds (B95 in ( cl_Ball (B94 , R1) ) iff (B93 is non  empty & ( dist (B94 , B95) ) <= R1)))))
proof
let R1 being  real number;
let C109 being MetrStruct;
let C110 , C111 being (Element of C109);
thus L251:now
assume L252: C111 in ( cl_Ball (C110 , R1) );
reconsider D27 = C109 as non  empty MetrStruct by L252;
reconsider D28 = C110 as (Element of D27);
L253: C111 in { B96 where B96 is (Element of D27) : ( dist (D28 , B96) ) <= R1 } by L252 , L224;
L254: (ex B97 being (Element of C109) st (C111 = B97 & ( dist (C110 , B97) ) <= R1)) by L253;
thus L255: (C109 is non  empty & ( dist (C110 , C111) ) <= R1) by L254 , L252;
end;
assume L256: C109 is non  empty;
reconsider D29 = C109 as non  empty MetrStruct by L256;
reconsider D30 = C110 as (Element of D29);
assume L257: ( dist (C110 , C111) ) <= R1;
L258: C111 in { B98 where B98 is (Element of D29) : ( dist (D30 , B98) ) <= R1 } by L257;
thus L259: thesis by L258 , L224;
end;
theorem
L260: (for R1 being  real number holds (for B99 being MetrStruct holds (for B100 , B101 being (Element of B99) holds (B101 in ( Sphere (B100 , R1) ) iff (B99 is non  empty & ( dist (B100 , B101) ) = R1)))))
proof
let R1 being  real number;
let C112 being MetrStruct;
let C113 , C114 being (Element of C112);
thus L261:now
assume L262: C114 in ( Sphere (C113 , R1) );
reconsider D31 = C112 as non  empty MetrStruct by L262;
reconsider D32 = C113 as (Element of D31);
L263: C114 in { B102 where B102 is (Element of D31) : ( dist (D32 , B102) ) = R1 } by L262 , L232;
L264: (ex B103 being (Element of C112) st (C114 = B103 & ( dist (C113 , B103) ) = R1)) by L263;
thus L265: (C112 is non  empty & ( dist (C113 , C114) ) = R1) by L264 , L262;
end;
assume L266: C112 is non  empty;
reconsider D33 = C112 as non  empty MetrStruct by L266;
reconsider D34 = C113 as (Element of D33);
assume L267: ( dist (C113 , C114) ) = R1;
L268: C114 in { B104 where B104 is (Element of D33) : ( dist (D34 , B104) ) = R1 } by L267;
thus L269: thesis by L268 , L232;
end;
theorem
L270: (for R1 being  real number holds (for B105 being MetrStruct holds (for B106 being (Element of B105) holds ( Ball (B106 , R1) ) c= ( cl_Ball (B106 , R1) ))))
proof
let R1 being  real number;
let C115 being MetrStruct;
let C116 being (Element of C115);
per cases ;
suppose L271: C115 is non  empty;

L272:
now
let C117 being (Element of C115);
assume L273: C117 in ( Ball (C116 , R1) );
L274: ( dist (C116 , C117) ) <= R1 by L273 , L240;
L275: C117 in { B107 where B107 is (Element of C115) : ( dist (C116 , B107) ) <= R1 } by L274;
thus L276: C117 in ( cl_Ball (C116 , R1) ) by L275 , L271 , L224;
end;
thus L277: thesis by L272 , SUBSET_1:2;
end;
suppose L278: C115 is  empty;

L279: ( Ball (C116 , R1) ) is  empty by L278 , L216;
thus L280: thesis by L279 , L278 , L224;
end;
end;
theorem
L282: (for R1 being  real number holds (for B108 being MetrStruct holds (for B109 being (Element of B108) holds ( Sphere (B109 , R1) ) c= ( cl_Ball (B109 , R1) ))))
proof
let R1 being  real number;
let C118 being MetrStruct;
let C119 being (Element of C118);
per cases ;
suppose L283: C118 is non  empty;

L284:
now
let C120 being (Element of C118);
assume L285: C120 in ( Sphere (C119 , R1) );
L286: ( dist (C119 , C120) ) = R1 by L285 , L260;
L287: C120 in { B110 where B110 is (Element of C118) : ( dist (C119 , B110) ) <= R1 } by L286;
thus L288: C120 in ( cl_Ball (C119 , R1) ) by L287 , L224 , L283;
end;
thus L289: thesis by L284 , SUBSET_1:2;
end;
suppose L290: C118 is  empty;

L291: ( Sphere (C119 , R1) ) is  empty by L290 , L232;
thus L292: thesis by L291 , L290 , L224;
end;
end;
theorem
L294: (for R1 being  real number holds (for B111 being MetrStruct holds (for B112 being (Element of B111) holds ( ( Sphere (B112 , R1) ) \/ ( Ball (B112 , R1) ) ) = ( cl_Ball (B112 , R1) ))))
proof
let R1 being  real number;
let C121 being MetrStruct;
let C122 being (Element of C121);
L295: (( Sphere (C122 , R1) ) c= ( cl_Ball (C122 , R1) ) & ( Ball (C122 , R1) ) c= ( cl_Ball (C122 , R1) )) by L270 , L282;
thus L296: ( ( Sphere (C122 , R1) ) \/ ( Ball (C122 , R1) ) ) c= ( cl_Ball (C122 , R1) ) by L295 , XBOOLE_1:8;
per cases ;
suppose L297: C121 is non  empty;

L298:
now
let C123 being (Element of C121);
assume L299: C123 in ( cl_Ball (C122 , R1) );
L300: ( dist (C122 , C123) ) <= R1 by L299 , L250;
L301:
now
per cases  by L300 , XXREAL_0:1;
case L302: ( dist (C122 , C123) ) < R1;
thus L303: C123 in ( Ball (C122 , R1) ) by L302 , L297 , L240;
end;
case L304: ( dist (C122 , C123) ) = R1;
thus L305: C123 in ( Sphere (C122 , R1) ) by L304 , L297 , L260;
end;
end;
thus L307: C123 in ( ( Sphere (C122 , R1) ) \/ ( Ball (C122 , R1) ) ) by L301 , XBOOLE_0:def 3;
end;
thus L308: thesis by L298 , SUBSET_1:2;
end;
suppose L309: C121 is  empty;

L310: (( Ball (C122 , R1) ) is  empty & ( cl_Ball (C122 , R1) ) is  empty) by L309 , L216 , L224;
thus L311: thesis by L310 , L309 , L232;
end;
end;
theorem
L313: (for R1 being  real number holds (for B113 being non  empty MetrStruct holds (for B114 being (Element of B113) holds ( Ball (B114 , R1) ) = { B115 where B115 is (Element of B113) : ( dist (B114 , B115) ) < R1 }))) by L216;
theorem
L314: (for R1 being  real number holds (for B116 being non  empty MetrStruct holds (for B117 being (Element of B116) holds ( cl_Ball (B117 , R1) ) = { B118 where B118 is (Element of B116) : ( dist (B117 , B118) ) <= R1 }))) by L224;
theorem
L315: (for R1 being  real number holds (for B119 being non  empty MetrStruct holds (for B120 being (Element of B119) holds ( Sphere (B120 , R1) ) = { B121 where B121 is (Element of B119) : ( dist (B120 , B121) ) = R1 }))) by L232;
begin
theorem
L316: (for B122 being set holds ( ( Empty^2-to-zero ) . (B122 , B122) ) = ( 0 ))
proof
let C124 being set;
per cases ;
suppose L317: [ C124 , C124 ] in [: 1 , 1 :];

thus L318: thesis by L317 , CARD_1:49 , FUNCT_2:50;
end;
suppose L319: (not [ C124 , C124 ] in [: 1 , 1 :]);

L320: (not [ C124 , C124 ] in ( dom ( Empty^2-to-zero ) )) by L319 , FUNCT_2:def 1;
thus L321: thesis by L320 , FUNCT_1:def 2;
end;
end;
theorem
L323: (for B123 , B124 being (Element of 1) holds (B123 <> B124 implies ( 0 ) < ( ( Empty^2-to-zero ) . (B123 , B124) )))
proof
let C125 , C126 being (Element of 1);
L324: C125 = ( {} ) by CARD_1:49 , TARSKI:def 1;
thus L325: thesis by L324 , CARD_1:49 , TARSKI:def 1;
end;
theorem
L326: (for B125 , B126 being (Element of 1) holds ( ( Empty^2-to-zero ) . (B125 , B126) ) = ( ( Empty^2-to-zero ) . (B126 , B125) )) by L24;
theorem
L327: (for B127 , B128 , B129 being (Element of 1) holds ( ( Empty^2-to-zero ) . (B127 , B129) ) <= ( ( ( Empty^2-to-zero ) . (B127 , B128) ) + ( ( Empty^2-to-zero ) . (B128 , B129) ) )) by L29;
theorem
L328: (for B130 , B131 , B132 being (Element of 1) holds ( ( Empty^2-to-zero ) . (B130 , B132) ) <= ( max (( ( Empty^2-to-zero ) . (B130 , B131) ) , ( ( Empty^2-to-zero ) . (B131 , B132) )) ))
proof
let C127 , C128 , C129 being (Element of 1);
L329: C129 = ( {} ) by CARD_1:49 , TARSKI:def 1;
L330: (C127 = ( {} ) & C128 = ( {} )) by CARD_1:49 , TARSKI:def 1;
thus L331: thesis by L330 , L329;
end;
set D35 = MetrStruct (# 1 , ( Empty^2-to-zero ) #);
definition
let C130 being non  empty set;
let C131 being (Function of [: C130 , C130 :] , ( REAL ));
attr C131 is  Discerning
means
:L332: (for B133 , B134 being (Element of C130) holds (B133 <> B134 implies ( 0 ) < ( C131 . (B133 , B134) )));
end;
definition
let C132 being non  empty MetrStruct;
attr C132 is  Discerning
means
:L334: (the distance of C132) is  Discerning;
end;
theorem
L336: (for B135 being non  empty MetrStruct holds ((for B136 , B137 being (Element of B135) holds (B136 <> B137 implies ( 0 ) < ( dist (B136 , B137) ))) iff B135 is  Discerning))
proof
let C133 being non  empty MetrStruct;
thus L337:now
assume L338: (for B138 , B139 being (Element of C133) holds (B138 <> B139 implies ( 0 ) < ( dist (B138 , B139) )));
L339: (the distance of C133) is  Discerning
proof
let C134 , C135 being (Element of C133);
assume L340: C134 <> C135;
L341: ( 0 ) < ( dist (C134 , C135) ) by L340 , L338;
thus L342: thesis by L341;
end;
thus L343: C133 is  Discerning by L339 , L334;
end;
assume L344: C133 is  Discerning;
L345: (the distance of C133) is  Discerning by L344 , L334;
thus L346: thesis by L345 , L332;
end;
registration
cluster MetrStruct (# 1 , ( Empty^2-to-zero ) #) -> non  empty;
coherence;
end;
registration
cluster MetrStruct (# 1 , ( Empty^2-to-zero ) #) ->  Reflexive  symmetric  Discerning  triangle;
coherence
proof
L348: (for B140 being (Element of D35) holds ( dist (B140 , B140) ) = ( 0 )) by L21;
L349: (for B141 , B142 being (Element of D35) holds ( dist (B141 , B142) ) = ( dist (B142 , B141) )) by L326;
L350: (for B143 , B144 being (Element of D35) holds (B143 <> B144 implies ( 0 ) < ( dist (B143 , B144) ))) by L323;
L351: (for B145 , B146 , B147 being (Element of D35) holds ( dist (B145 , B147) ) <= ( ( dist (B145 , B146) ) + ( dist (B146 , B147) ) )) by L327;
thus L352: thesis by L351 , L349 , L348 , L350 , L336 , L54 , L75 , L80;
end;
end;
definition
let C136 being non  empty MetrStruct;
attr C136 is  ultra
means
:L354: (for B148 , B149 , B150 being (Element of C136) holds ( dist (B148 , B150) ) <= ( max (( dist (B148 , B149) ) , ( dist (B149 , B150) )) ));
end;
registration
cluster  strict  ultra  Reflexive  symmetric  Discerning  triangle for non  empty non  empty non  empty non  empty MetrStruct;
existence
proof
take D36 = MetrStruct (# 1 , ( Empty^2-to-zero ) #);
L356: D36 is  ultra
proof
let C137 , C138 , C139 being (Element of D36);
thus L357: thesis by L328;
end;
thus L358: thesis by L356;
end;
end;
theorem
L360: (for B151 being  Reflexive  Discerning non  empty MetrStruct holds (for B152 , B153 being (Element of B151) holds ( 0 ) <= ( dist (B152 , B153) )))
proof
let C140 being  Reflexive  Discerning non  empty MetrStruct;
let C141 , C142 being (Element of C140);
L361:
now
per cases ;
suppose L362: C141 = C142;

thus L363: thesis by L362 , L54;
end;
suppose L364: C141 <> C142;

thus L365: thesis by L364 , L336;
end;
end;
thus L367: thesis by L361;
end;
definition
mode PseudoMetricSpace
 is  Reflexive  symmetric  triangle non  empty MetrStruct;
mode SemiMetricSpace
 is  Reflexive  Discerning  symmetric non  empty MetrStruct;
mode NonSymmetricMetricSpace
 is  Reflexive  Discerning  triangle non  empty MetrStruct;
mode UltraMetricSpace
 is  ultra  Reflexive  symmetric  Discerning non  empty MetrStruct;
end;
registration
cluster  ->  Discerning for non  empty non  empty non  empty non  empty MetrSpace;
coherence
proof
let C143 being non  empty MetrSpace;
L369: (for B154 , B155 being (Element of C143) holds (B154 <> B155 implies ( 0 ) < ( dist (B154 , B155) ))) by L115;
thus L370: thesis by L369 , L336;
end;
end;
registration
cluster  ->  triangle  discerning for UltraMetricSpace;
coherence
proof
let C144 being UltraMetricSpace;
L372:
now
let C145 , C146 , C147 being (Element of C144);
thus L373: (( dist (C145 , C146) ) = ( 0 ) iff C145 = C146) by L336 , L54;
thus L374: ( dist (C145 , C146) ) = ( dist (C146 , C145) );
L375: (( 0 ) <= ( dist (C145 , C146) ) & ( 0 ) <= ( dist (C146 , C147) )) by L360;
L376: ( max (( dist (C145 , C146) ) , ( dist (C146 , C147) )) ) <= ( ( dist (C145 , C146) ) + ( dist (C146 , C147) ) ) by L375 , SQUARE_1:2;
L377: ( dist (C145 , C147) ) <= ( max (( dist (C145 , C146) ) , ( dist (C146 , C147) )) ) by L354;
thus L378: ( dist (C145 , C147) ) <= ( ( dist (C145 , C146) ) + ( dist (C146 , C147) ) ) by L377 , L376 , XXREAL_0:2;
end;
thus L379: thesis by L372 , L98;
end;
end;
definition
func Set_to_zero -> (Function of [: 2 , 2 :] , ( REAL )) equals 
( [: 2 , 2 :] --> ( 0 ) );
coherence;
end;
theorem
L382: (for B156 , B157 being (Element of 2) holds ( ( Set_to_zero ) . (B156 , B157) ) = ( 0 ))
proof
let C148 , C149 being (Element of 2);
L383: [ C148 , C149 ] in [: 2 , 2 :] by ZFMISC_1:87;
thus L384: ( ( Set_to_zero ) . (C148 , C149) ) = ( ( Set_to_zero ) . [ C148 , C149 ] )
.= ( 0 ) by L383 , FUNCOP_1:7;
end;
theorem
L385: (for B158 , B159 being (Element of 2) holds ( ( Set_to_zero ) . (B158 , B159) ) = ( ( Set_to_zero ) . (B159 , B158) ))
proof
let C150 , C151 being (Element of 2);
L386: ( ( Set_to_zero ) . (C150 , C151) ) = ( 0 ) by L382
.= ( ( Set_to_zero ) . (C151 , C150) ) by L382;
thus L387: thesis by L386;
end;
theorem
L388: (for B160 , B161 , B162 being (Element of 2) holds ( ( Set_to_zero ) . (B160 , B162) ) <= ( ( ( Set_to_zero ) . (B160 , B161) ) + ( ( Set_to_zero ) . (B161 , B162) ) ))
proof
let C152 , C153 , C154 being (Element of 2);
L389: (( ( Set_to_zero ) . (C152 , C153) ) = ( 0 ) & ( ( Set_to_zero ) . (C153 , C154) ) = ( 0 )) by L382;
thus L390: thesis by L389 , L382;
end;
definition
func ZeroSpace -> MetrStruct equals 
MetrStruct (# 2 , ( Set_to_zero ) #);
coherence;
end;
registration
cluster ( ZeroSpace ) ->  strict non  empty;
coherence;
end;
registration
cluster ( ZeroSpace ) ->  Reflexive  symmetric  triangle;
coherence
proof
set D37 = MetrStruct (# 2 , ( Set_to_zero ) #);
L393: (for B163 , B164 , B165 being (Element of D37) holds (( dist (B163 , B164) ) = ( dist (B164 , B163) ) & ( dist (B163 , B165) ) <= ( ( dist (B163 , B164) ) + ( dist (B164 , B165) ) ))) by L385 , L388;
L394: (for B166 being (Element of D37) holds ( dist (B166 , B166) ) = ( 0 )) by L382;
thus L395: thesis by L394 , L393 , L54 , L75 , L80;
end;
end;
definition
let C155 being MetrStruct;
let C156 , C157 , C158 being (Element of C155);
pred C157 is_between C156 , C158
means
:L397: (C156 <> C157 & C156 <> C158 & C157 <> C158 & ( dist (C156 , C158) ) = ( ( dist (C156 , C157) ) + ( dist (C157 , C158) ) ))
;end;
theorem
L399: (for B167 being  symmetric  triangle  Reflexive non  empty MetrStruct holds (for B168 , B169 , B170 being (Element of B167) holds (B169 is_between B168 , B170 implies B169 is_between B170 , B168)))
proof
let C159 being  symmetric  triangle  Reflexive non  empty MetrStruct;
let C160 , C161 , C162 being (Element of C159);
assume L400: C161 is_between C160 , C162;
thus L401: (C162 <> C161 & C162 <> C160 & C161 <> C160) by L400 , L397;
L402: ( dist (C160 , C162) ) = ( ( dist (C160 , C161) ) + ( dist (C161 , C162) ) ) by L400 , L397;
thus L403: thesis by L402;
end;
theorem
L404: (for B171 being MetrSpace holds (for B172 , B173 , B174 being (Element of B171) holds (B173 is_between B172 , B174 implies ((not B172 is_between B173 , B174) & (not B174 is_between B172 , B173)))))
proof
let C163 being MetrSpace;
let C164 , C165 , C166 being (Element of C163);
assume L405: C165 is_between C164 , C166;
L406: ( dist (C164 , C166) ) = ( ( dist (C164 , C165) ) + ( dist (C165 , C166) ) ) by L405 , L397;
L407: C164 <> C165 by L405 , L397;
thus L408: (not C164 is_between C165 , C166)
proof
assume L409: C164 is_between C165 , C166;
L410: ( dist (C164 , C166) ) = ( ( dist (C164 , C165) ) + ( ( dist (C165 , C164) ) + ( dist (C164 , C166) ) ) ) by L409 , L406 , L397;
thus L411: contradiction by L410 , L407 , L115;
end;

assume L412: C166 is_between C164 , C165;
L413: ( dist (C164 , C165) ) = ( ( ( dist (C164 , C165) ) + ( dist (C165 , C166) ) ) + ( dist (C166 , C165) ) ) by L412 , L406 , L397;
L414: C165 <> C166 by L405 , L397;
thus L415: contradiction by L414 , L413 , L115;
end;
theorem
L416: (for B175 being MetrSpace holds (for B176 , B177 , B178 , B179 being (Element of B175) holds ((B177 is_between B176 , B178 & B178 is_between B176 , B179) implies (B177 is_between B176 , B179 & B178 is_between B177 , B179))))
proof
let C167 being MetrSpace;
let C168 , C169 , C170 , C171 being (Element of C167);
assume L417: C169 is_between C168 , C170;
L418: C168 <> C169 by L417 , L397;
assume L419: C170 is_between C168 , C171;
L420: (C168 <> C171 & C170 <> C171) by L419 , L397;
L421: ( dist (C168 , C170) ) = ( ( dist (C168 , C169) ) + ( dist (C169 , C170) ) ) by L417 , L397;
L422: ( dist (C168 , C171) ) = ( ( ( dist (C168 , C169) ) + ( dist (C169 , C170) ) ) + ( dist (C170 , C171) ) ) by L421 , L419 , L397;
L423: (( dist (C168 , C171) ) <= ( ( dist (C168 , C169) ) + ( dist (C169 , C171) ) ) & ( ( dist (C168 , C169) ) + ( dist (C169 , C171) ) ) <= ( ( ( dist (C169 , C170) ) + ( dist (C170 , C171) ) ) + ( dist (C168 , C169) ) )) by L80 , XREAL_1:6;
L424: ( ( dist (C168 , C169) ) + ( dist (C169 , C171) ) ) = ( ( dist (C168 , C169) ) + ( ( dist (C169 , C170) ) + ( dist (C170 , C171) ) ) ) by L423 , L422 , XXREAL_0:1;
L425: C169 <> C170 by L417 , L397;
L426: C169 <> C171 by L425 , L422 , L115;
thus L427: thesis by L426 , L418 , L425 , L420 , L422 , L424 , L397;
end;
definition
let C172 being non  empty MetrStruct;
let C173 , C174 being (Element of C172);
func open_dist_Segment (C173 , C174) -> (Subset of C172) equals 
{ B180 where B180 is (Element of C172) : B180 is_between C173 , C174 };
coherence
proof
defpred S4[ (Element of C172) ] means $1 is_between C173 , C174;
L428: { B181 where B181 is (Element of C172) : S4[ B181 ] } c= (the carrier of C172) from FRAENKEL:sch 10;
thus L429: thesis by L428;
end;
end;
theorem
L431: (for B182 being non  empty MetrSpace holds (for B183 , B184 , B185 being (Element of B182) holds (B185 in ( open_dist_Segment (B183 , B184) ) iff B185 is_between B183 , B184)))
proof
let C175 being non  empty MetrSpace;
let C176 , C177 , C178 being (Element of C175);
L432: (C178 in ( open_dist_Segment (C176 , C177) ) implies C178 is_between C176 , C177)
proof
assume L433: C178 in ( open_dist_Segment (C176 , C177) );
L434: (ex B186 being (Element of C175) st (C178 = B186 & B186 is_between C176 , C177)) by L433;
thus L435: thesis by L434;
end;
thus L436: thesis by L432;
end;
definition
let C179 being non  empty MetrStruct;
let C180 , C181 being (Element of C179);
func close_dist_Segment (C180 , C181) -> (Subset of C179) equals 
( { B187 where B187 is (Element of C179) : B187 is_between C180 , C181 } \/ { C180 , C181 } );
coherence
proof
defpred S5[ (Element of C179) ] means $1 is_between C180 , C181;
L437: { C180 , C181 } c= (the carrier of C179) by ZFMISC_1:32;
L438: { B188 where B188 is (Element of C179) : S5[ B188 ] } c= (the carrier of C179) from FRAENKEL:sch 10;
thus L439: thesis by L438 , L437 , XBOOLE_1:8;
end;
end;
theorem
L441: (for B189 being non  empty MetrStruct holds (for B190 , B191 , B192 being (Element of B189) holds (B192 in ( close_dist_Segment (B190 , B191) ) iff (B192 is_between B190 , B191 or B192 = B190 or B192 = B191))))
proof
let C182 being non  empty MetrStruct;
let C183 , C184 , C185 being (Element of C182);
L442: (C185 in ( close_dist_Segment (C183 , C184) ) implies (C185 is_between C183 , C184 or C185 = C183 or C185 = C184))
proof
assume L443: C185 in ( close_dist_Segment (C183 , C184) );
L444: (C185 in { B193 where B193 is (Element of C182) : B193 is_between C183 , C184 } or C185 in { C183 , C184 }) by L443 , XBOOLE_0:def 3;
L445: ((ex B194 being (Element of C182) st (C185 = B194 & B194 is_between C183 , C184)) or C185 = C183 or C185 = C184) by L444 , TARSKI:def 2;
thus L446: thesis by L445;
end;
L447:
now
assume L448: (C185 is_between C183 , C184 or C185 = C183 or C185 = C184);
L449: (C185 in { B195 where B195 is (Element of C182) : B195 is_between C183 , C184 } or C185 in { C183 , C184 }) by L448 , TARSKI:def 2;
thus L450: C185 in ( close_dist_Segment (C183 , C184) ) by L449 , XBOOLE_0:def 3;
end;
thus L451: thesis by L447 , L442;
end;
