:: The Binomial Theorem for Algebraic Structures
::  by Christoph Schwarzweller
::
:: Received November 20, 2000
:: Copyright (c) 2000-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, RLVECT_1, ALGSTR_0, XBOOLE_0, SUBSET_1, ARYTM_3,
      ALGSTR_1, BINOP_1, LATTICES, GROUP_1, VECTSP_2, VECTSP_1, SUPINF_2,
      RELAT_1, FUNCT_1, ZFMISC_1, CARD_1, FUNCT_2, MCART_1, CARD_3, FINSEQ_1,
      STRUCT_0, XXREAL_0, PARTFUN1, NAT_1, NEWTON, ARYTM_1, ORDINAL4, FINSEQ_2,
      BINOM;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XCMPLX_0, STRUCT_0,
      ALGSTR_0, PARTFUN1, FUNCT_1, FUNCT_2, ORDINAL1, NAT_1, FINSEQ_1,
      RELSET_1, BINOP_1, ALGSTR_1, FINSEQ_2, VECTSP_1, VECTSP_2, GROUP_1,
      NEWTON, RLVECT_1, XTUPLE_0, MCART_1, POLYNOM1, XXREAL_0;
 constructors BINOP_1, REAL_1, NEWTON, ALGSTR_1, MONOID_0, POLYNOM1, RELSET_1,
      FVSUM_1, XTUPLE_0;
 registrations XBOOLE_0, ORDINAL1, RELSET_1, XXREAL_0, XREAL_0, NAT_1,
      FINSEQ_2, STRUCT_0, VECTSP_1, ALGSTR_1, MONOID_0, INT_1, ALGSTR_0,
      CARD_1, FINSEQ_1, XTUPLE_0;
 requirements NUMERALS, SUBSET, REAL, BOOLE, ARITHM;
 definitions BINOP_1, ALGSTR_0, XTUPLE_0;
 theorems TARSKI, FUNCT_2, VECTSP_1, RLVECT_1, ALGSTR_1, NAT_1, MCART_1,
      FINSEQ_1, GROUP_1, NEWTON, FINSEQ_2, FUNCT_1, ZFMISC_1, INT_1, RELAT_1,
      POLYNOM1, XBOOLE_0, XREAL_1, PARTFUN1, ORDINAL1, ALGSTR_0, CARD_1,
      FINSEQ_5, XTUPLE_0;
 schemes NAT_1, RECDEF_1, INT_1;

begin
registration
cluster  Abelian  right_add-cancelable ->  left_add-cancelable for non  empty non  empty non  empty non  empty addLoopStr;
coherence
proof
let C1 being non  empty addLoopStr;
assume L1: C1 is  Abelian  right_add-cancelable;
reconsider D1 = C1 as  Abelian  right_add-cancelable non  empty addLoopStr by L1;
L2: D1 is  left_add-cancelable
proof
let C2 , C3 , C4 being (Element of D1);
assume L3: ( C2 + C3 ) = ( C2 + C4 );
thus L4: thesis by L3 , ALGSTR_0:def 4;
end;
thus L5: thesis by L2;
end;
cluster  Abelian  left_add-cancelable ->  right_add-cancelable for non  empty non  empty non  empty non  empty addLoopStr;
coherence
proof
let C5 being non  empty addLoopStr;
assume L6: C5 is  Abelian  left_add-cancelable;
reconsider D2 = C5 as  Abelian  left_add-cancelable non  empty addLoopStr by L6;
L7: D2 is  right_add-cancelable
proof
let C6 , C7 , C8 being (Element of D2);
assume L8: ( C7 + C6 ) = ( C8 + C6 );
thus L9: thesis by L8 , ALGSTR_0:def 3;
end;
thus L10: thesis by L7;
end;
end;
registration
cluster  right_zeroed  right_complementable  add-associative ->  right_add-cancelable for non  empty non  empty non  empty non  empty addLoopStr;
coherence;
end;
registration
cluster  Abelian  add-associative  left_zeroed  right_zeroed  commutative  associative  add-cancelable  distributive  unital for non  empty non  empty non  empty non  empty doubleLoopStr;
existence
proof
set D3 = the comRing;
take D3;
thus L13: thesis;
end;
end;
theorem
L15: (for B1 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr holds (for B2 being (Element of B1) holds ( ( 0. B1 ) * B2 ) = ( 0. B1 )))
proof
let C9 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr;
let C10 being (Element of C9);
L16: ( ( 0. C9 ) * C10 ) = ( ( ( 0. C9 ) + ( 0. C9 ) ) * C10 ) by RLVECT_1:def 4
.= ( ( ( 0. C9 ) * C10 ) + ( ( 0. C9 ) * C10 ) ) by VECTSP_1:def 3;
L17: ( ( ( 0. C9 ) * C10 ) + ( ( 0. C9 ) * C10 ) ) = ( ( ( 0. C9 ) * C10 ) + ( 0. C9 ) ) by L16 , RLVECT_1:def 4;
thus L18: thesis by L17 , ALGSTR_0:def 3;
end;
theorem
L19: (for B3 being  left_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr holds (for B4 being (Element of B3) holds ( B4 * ( 0. B3 ) ) = ( 0. B3 )))
proof
let C11 being  left_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr;
let C12 being (Element of C11);
L20: ( C12 * ( 0. C11 ) ) = ( C12 * ( ( 0. C11 ) + ( 0. C11 ) ) ) by ALGSTR_1:def 2
.= ( ( C12 * ( 0. C11 ) ) + ( C12 * ( 0. C11 ) ) ) by VECTSP_1:def 2;
L21: ( ( C12 * ( 0. C11 ) ) + ( C12 * ( 0. C11 ) ) ) = ( ( 0. C11 ) + ( C12 * ( 0. C11 ) ) ) by L20 , ALGSTR_1:def 2;
thus L22: thesis by L21 , ALGSTR_0:def 4;
end;
L23:
now
let C13 , C14 being non  empty set;
let C15 being (Element of C14);
let C16 being (Function of [: C13 , C14 :] , C14);
thus L24: (ex B5 being (Function of [: ( NAT ) , C13 :] , C14) st (for B6 being (Element of C13) holds (( B5 . (( 0 ) , B6) ) = C15 & (for B7 being (Element of ( NAT )) holds ( B5 . (( B7 + 1 ) , B6) ) = ( C16 . (B6 , ( B5 . (B7 , B6) )) )))))
proof
L25: (for B8 being (Element of C13) holds (ex B9 being (Function of ( NAT ) , C14) st (( B9 . ( 0 ) ) = C15 & (for B10 being (Element of ( NAT )) holds ( B9 . ( B10 + 1 ) ) = ( C16 . (B8 , ( B9 . B10 )) )))))
proof
let C17 being (Element of C13);
defpred S1[ (Element of ( NAT )) , (Element of C14) , (Element of C14) ] means $3 = ( C16 . (C17 , $2) );
L26: (for B11 being (Element of ( NAT )) holds (for B12 being (Element of C14) holds (ex B13 being (Element of C14) st S1[ B11 , B12 , B13 ])));
L27: (ex B14 being (Function of ( NAT ) , C14) st (( B14 . ( 0 ) ) = C15 & (for B15 being (Element of ( NAT )) holds S1[ B15 , ( B14 . B15 ) , ( B14 . ( B15 + 1 ) ) ]))) from RECDEF_1:sch 2(L26);
thus L28: thesis by L27;
end;
L29: (ex B16 being (Function of C13 , ( Funcs (( NAT ) , C14) )) st (for B17 being (Element of C13) holds (ex B18 being (Function of ( NAT ) , C14) st (( B16 . B17 ) = B18 & ( B18 . ( 0 ) ) = C15 & (for B19 being (Element of ( NAT )) holds ( B18 . ( B19 + 1 ) ) = ( C16 . (B17 , ( B18 . B19 )) ))))))
proof
set D4 = { [ B20 , B21 ] where B20 is (Element of C13) , B21 is (Element of ( Funcs (( NAT ) , C14) )) : (ex B22 being (Function of ( NAT ) , C14) st (B22 = B21 & ( B22 . ( 0 ) ) = C15 & (for B23 being (Element of ( NAT )) holds ( B22 . ( B23 + 1 ) ) = ( C16 . (B20 , ( B22 . B23 )) )))) };
L30:
now
let C18 , C19 , C20 being set;
assume that
L31: [ C18 , C19 ] in D4
and
L32: [ C18 , C20 ] in D4;
consider C21 being (Element of C13), C22 being (Element of ( Funcs (( NAT ) , C14) )) such that L33: [ C18 , C19 ] = [ C21 , C22 ] and L34: (ex B24 being (Function of ( NAT ) , C14) st (B24 = C22 & ( B24 . ( 0 ) ) = C15 & (for B25 being (Element of ( NAT )) holds ( B24 . ( B25 + 1 ) ) = ( C16 . (C21 , ( B24 . B25 )) )))) by L31;
consider C23 being (Element of C13), C24 being (Element of ( Funcs (( NAT ) , C14) )) such that L35: [ C18 , C20 ] = [ C23 , C24 ] and L36: (ex B26 being (Function of ( NAT ) , C14) st (B26 = C24 & ( B26 . ( 0 ) ) = C15 & (for B27 being (Element of ( NAT )) holds ( B26 . ( B27 + 1 ) ) = ( C16 . (C23 , ( B26 . B27 )) )))) by L32;
consider C25 being (Function of ( NAT ) , C14) such that L37: C25 = C22 and L38: ( C25 . ( 0 ) ) = C15 and L39: (for B28 being (Element of ( NAT )) holds ( C25 . ( B28 + 1 ) ) = ( C16 . (C21 , ( C25 . B28 )) )) by L34;
consider C26 being (Function of ( NAT ) , C14) such that L40: C26 = C24 and L41: ( C26 . ( 0 ) ) = C15 and L42: (for B29 being (Element of ( NAT )) holds ( C26 . ( B29 + 1 ) ) = ( C16 . (C23 , ( C26 . B29 )) )) by L36;
L43: C21 = ( [ C21 , C22 ] `1 )
.= ( [ C18 , C19 ] `1 ) by L33
.= C18
.= ( [ C18 , C20 ] `1 )
.= ( [ C23 , C24 ] `1 ) by L35
.= C23;
L44:
now
defpred S2[ (Element of ( NAT )) ] means ( C25 . $1 ) = ( C26 . $1 );
let C27 being set;
assume L45: C27 in ( NAT );
reconsider D5 = C27 as (Element of ( NAT )) by L45;
L46:
now
let C28 being (Element of ( NAT ));
assume L47: S2[ C28 ];
L48: ( C25 . ( C28 + 1 ) ) = ( C16 . (C23 , ( C25 . C28 )) ) by L39 , L43
.= ( C26 . ( C28 + 1 ) ) by L42 , L47;
thus L49: S2[ ( C28 + 1 ) ] by L48;
end;
L50: S2[ ( 0 ) ] by L38 , L41;
L51: (for B30 being (Element of ( NAT )) holds S2[ B30 ]) from NAT_1:sch 1(L50 , L46);
thus L52: ( C25 . C27 ) = ( C26 . D5 ) by L51
.= ( C26 . C27 );
end;
L53: (( NAT ) = ( dom C25 ) & ( NAT ) = ( dom C26 )) by FUNCT_2:def 1;
thus L54: C19 = ( [ C18 , C19 ] `2 )
.= ( [ C21 , C22 ] `2 ) by L33
.= C22
.= C24 by L37 , L40 , L53 , L44 , FUNCT_1:2
.= ( [ C23 , C24 ] `2 )
.= ( [ C18 , C20 ] `2 ) by L35
.= C20;
end;
L55:
now
let C29 being set;
assume L56: C29 in D4;
L57: (ex B31 being (Element of C13) st (ex B32 being (Element of ( Funcs (( NAT ) , C14) )) st (C29 = [ B31 , B32 ] & (ex B33 being (Function of ( NAT ) , C14) st (B33 = B32 & ( B33 . ( 0 ) ) = C15 & (for B34 being (Element of ( NAT )) holds ( B33 . ( B34 + 1 ) ) = ( C16 . (B31 , ( B33 . B34 )) ))))))) by L56;
thus L58: C29 in [: C13 , ( Funcs (( NAT ) , C14) ) :] by L57 , ZFMISC_1:def 2;
end;
reconsider D6 = D4 as (Relation of C13 , ( Funcs (( NAT ) , C14) )) by L55 , TARSKI:def 3;
L59: (for B35 being set holds (B35 in C13 implies B35 in ( dom D6 )))
proof
let C30 being set;
assume L60: C30 in C13;
consider C31 being (Function of ( NAT ) , C14) such that L61: (( C31 . ( 0 ) ) = C15 & (for B36 being (Element of ( NAT )) holds ( C31 . ( B36 + 1 ) ) = ( C16 . (C30 , ( C31 . B36 )) ))) by L60 , L25;
reconsider D7 = C31 as (Element of ( Funcs (( NAT ) , C14) )) by FUNCT_2:8;
L62: [ C30 , D7 ] in D6 by L60 , L61;
thus L63: thesis by L62 , XTUPLE_0:def 12;
end;
L64: (for B37 being set holds (B37 in ( dom D6 ) implies B37 in C13));
L65: ( dom D6 ) = C13 by L64 , L59 , TARSKI:1;
reconsider D8 = D6 as (Function of C13 , ( Funcs (( NAT ) , C14) )) by L65 , L30 , FUNCT_1:def 1 , FUNCT_2:def 1;
take D8;
L66: (for B38 being (Element of C13) holds (ex B39 being (Function of ( NAT ) , C14) st (( D8 . B38 ) = B39 & ( B39 . ( 0 ) ) = C15 & (for B40 being (Element of ( NAT )) holds ( B39 . ( B40 + 1 ) ) = ( C16 . (B38 , ( B39 . B40 )) )))))
proof
let C32 being (Element of C13);
L67: ( dom D8 ) = C13 by FUNCT_2:def 1;
L68: [ C32 , ( D8 . C32 ) ] in D8 by L67 , FUNCT_1:1;
consider C33 being (Element of C13), C34 being (Element of ( Funcs (( NAT ) , C14) )) such that L69: [ C32 , ( D8 . C32 ) ] = [ C33 , C34 ] and L70: (ex B41 being (Function of ( NAT ) , C14) st (B41 = C34 & ( B41 . ( 0 ) ) = C15 & (for B42 being (Element of ( NAT )) holds ( B41 . ( B42 + 1 ) ) = ( C16 . (C33 , ( B41 . B42 )) )))) by L68;
L71: ( D8 . C32 ) = ( [ C32 , ( D8 . C32 ) ] `2 )
.= ( [ C33 , C34 ] `2 ) by L69
.= C34;
L72: C32 = ( [ C32 , ( D8 . C32 ) ] `1 )
.= ( [ C33 , C34 ] `1 ) by L69
.= C33;
thus L73: thesis by L72 , L70 , L71;
end;
thus L74: thesis by L66;
end;
consider C35 being (Function of C13 , ( Funcs (( NAT ) , C14) )) such that L75: (for B43 being (Element of C13) holds (ex B44 being (Function of ( NAT ) , C14) st (( C35 . B43 ) = B44 & ( B44 . ( 0 ) ) = C15 & (for B45 being (Element of ( NAT )) holds ( B44 . ( B45 + 1 ) ) = ( C16 . (B43 , ( B44 . B45 )) ))))) by L29;
set D9 = { [ [ B46 , B47 ] , B48 ] where B46 is (Element of ( NAT )) , B47 is (Element of C13) , B48 is (Element of C14) : (ex B49 being (Function of ( NAT ) , C14) st (B49 = ( C35 . B47 ) & B48 = ( B49 . B46 ))) };
L76:
now
let C36 , C37 , C38 being set;
assume that
L77: [ C36 , C37 ] in D9
and
L78: [ C36 , C38 ] in D9;
consider C39 being (Element of ( NAT )), C40 being (Element of C13), C41 being (Element of C14) such that L79: [ C36 , C37 ] = [ [ C39 , C40 ] , C41 ] and L80: (ex B50 being (Function of ( NAT ) , C14) st (B50 = ( C35 . C40 ) & C41 = ( B50 . C39 ))) by L77;
consider C42 being (Element of ( NAT )), C43 being (Element of C13), C44 being (Element of C14) such that L81: [ C36 , C38 ] = [ [ C42 , C43 ] , C44 ] and L82: (ex B51 being (Function of ( NAT ) , C14) st (B51 = ( C35 . C43 ) & C44 = ( B51 . C42 ))) by L78;
L83: [ C39 , C40 ] = ( [ [ C39 , C40 ] , C41 ] `1 )
.= ( [ C36 , C37 ] `1 ) by L79
.= C36
.= ( [ C36 , C38 ] `1 )
.= ( [ [ C42 , C43 ] , C44 ] `1 ) by L81
.= [ C42 , C43 ];
L84: C40 = ( [ C39 , C40 ] `2 )
.= ( [ C42 , C43 ] `2 ) by L83
.= C43;
L85: C39 = ( [ C39 , C40 ] `1 )
.= ( [ C42 , C43 ] `1 ) by L83
.= C42;
thus L86: C37 = ( [ C36 , C37 ] `2 )
.= ( [ C36 , C38 ] `2 ) by L79 , L80 , L81 , L82 , L84 , L85
.= C38;
end;
L87:
now
let C45 being set;
assume L88: C45 in D9;
consider C46 being (Element of ( NAT )), C47 being (Element of C13), C48 being (Element of C14) such that L89: C45 = [ [ C46 , C47 ] , C48 ] and L90: (ex B52 being (Function of ( NAT ) , C14) st (B52 = ( C35 . C47 ) & C48 = ( B52 . C46 ))) by L88;
L91: [ C46 , C47 ] in [: ( NAT ) , C13 :] by ZFMISC_1:def 2;
thus L92: C45 in [: [: ( NAT ) , C13 :] , C14 :] by L91 , L89 , ZFMISC_1:def 2;
end;
reconsider D10 = D9 as (Relation of [: ( NAT ) , C13 :] , C14) by L87 , TARSKI:def 3;
L93: (for B53 being set holds (B53 in [: ( NAT ) , C13 :] implies B53 in ( dom D10 )))
proof
let C49 being set;
assume L94: C49 in [: ( NAT ) , C13 :];
consider C50 , C51 being set such that L95: C50 in ( NAT ) and L96: C51 in C13 and L97: C49 = [ C50 , C51 ] by L94 , ZFMISC_1:def 2;
reconsider D11 = C51 as (Element of C13) by L96;
reconsider D12 = C50 as (Element of ( NAT )) by L95;
consider C52 being (Function of ( NAT ) , C14) such that L98: ( C35 . D11 ) = C52 and L99: ( C52 . ( 0 ) ) = C15 and L100: (for B54 being (Element of ( NAT )) holds ( C52 . ( B54 + 1 ) ) = ( C16 . (D11 , ( C52 . B54 )) )) by L75;
L101: (ex B55 being (Element of C14) st (ex B56 being (Function of ( NAT ) , C14) st (B56 = ( C35 . D11 ) & B55 = ( B56 . D12 ))))
proof
take ( C52 . D12 );
take C52;
thus L102: thesis by L98;
end;
consider C53 being (Element of C14) such that L103: (ex B57 being (Function of ( NAT ) , C14) st (B57 = ( C35 . D11 ) & C53 = ( B57 . D12 ))) by L101;
L104: [ C49 , C53 ] in D10 by L97 , L103;
thus L105: thesis by L104 , XTUPLE_0:def 12;
end;
L106: (for B58 being set holds (B58 in ( dom D10 ) implies B58 in [: ( NAT ) , C13 :]));
L107: ( dom D10 ) = [: ( NAT ) , C13 :] by L106 , L93 , TARSKI:1;
reconsider D13 = D10 as (Function of [: ( NAT ) , C13 :] , C14) by L107 , L76 , FUNCT_1:def 1 , FUNCT_2:def 1;
take D13;
L108: (for B59 being (Element of C13) holds (( D13 . (( 0 ) , B59) ) = C15 & (for B60 being (Element of ( NAT )) holds ( D13 . (( B60 + 1 ) , B59) ) = ( C16 . (B59 , ( D13 . (B60 , B59) )) ))))
proof
let C54 being (Element of C13);
consider C55 being (Function of ( NAT ) , C14) such that L109: ( C35 . C54 ) = C55 and L110: ( C55 . ( 0 ) ) = C15 and L111: (for B61 being (Element of ( NAT )) holds ( C55 . ( B61 + 1 ) ) = ( C16 . (C54 , ( C55 . B61 )) )) by L75;
L112:
now
let C56 being (Element of ( NAT ));
L113: [ ( C56 + 1 ) , C54 ] in [: ( NAT ) , C13 :] by ZFMISC_1:def 2;
L114: [ ( C56 + 1 ) , C54 ] in ( dom D13 ) by L113 , FUNCT_2:def 1;
consider C57 being set such that L115: [ [ ( C56 + 1 ) , C54 ] , C57 ] in D13 by L114 , XTUPLE_0:def 12;
L116: [ C56 , C54 ] in [: ( NAT ) , C13 :] by ZFMISC_1:def 2;
L117: [ C56 , C54 ] in ( dom D13 ) by L116 , FUNCT_2:def 1;
consider C58 being set such that L118: [ [ C56 , C54 ] , C58 ] in D13 by L117 , XTUPLE_0:def 12;
consider C59 being (Element of ( NAT )), C60 being (Element of C13), C61 being (Element of C14) such that L119: [ [ ( C56 + 1 ) , C54 ] , C57 ] = [ [ C59 , C60 ] , C61 ] and L120: (ex B62 being (Function of ( NAT ) , C14) st (B62 = ( C35 . C60 ) & C61 = ( B62 . C59 ))) by L115;
L121: C57 = ( [ [ ( C56 + 1 ) , C54 ] , C57 ] `2 )
.= ( [ [ C59 , C60 ] , C61 ] `2 ) by L119
.= C61;
consider C62 being (Element of ( NAT )), C63 being (Element of C13), C64 being (Element of C14) such that L122: [ [ C56 , C54 ] , C58 ] = [ [ C62 , C63 ] , C64 ] and L123: (ex B63 being (Function of ( NAT ) , C14) st (B63 = ( C35 . C63 ) & C64 = ( B63 . C62 ))) by L118;
L124: C58 = ( [ [ C56 , C54 ] , C58 ] `2 )
.= ( [ [ C62 , C63 ] , C64 ] `2 ) by L122
.= C64;
L125: [ ( C56 + 1 ) , C54 ] = ( [ [ ( C56 + 1 ) , C54 ] , C57 ] `1 )
.= ( [ [ C59 , C60 ] , C61 ] `1 ) by L119
.= [ C59 , C60 ];
L126: C60 = ( [ C59 , C60 ] `2 )
.= ( [ ( C56 + 1 ) , C54 ] `2 ) by L125
.= C54;
L127: [ C56 , C54 ] = ( [ [ C56 , C54 ] , C58 ] `1 )
.= ( [ [ C62 , C63 ] , C64 ] `1 ) by L122
.= [ C62 , C63 ];
L128: C62 = ( [ C62 , C63 ] `1 )
.= ( [ C56 , C54 ] `1 ) by L127
.= C56;
L129: C63 = ( [ C62 , C63 ] `2 )
.= ( [ C56 , C54 ] `2 ) by L127
.= C54;
L130: C59 = ( [ C59 , C60 ] `1 )
.= ( [ ( C56 + 1 ) , C54 ] `1 ) by L125
.= ( C56 + 1 );
thus L131: ( D13 . (( C56 + 1 ) , C54) ) = ( C55 . ( C56 + 1 ) ) by L130 , L109 , L115 , L120 , L121 , L126 , FUNCT_1:1
.= ( C16 . (C54 , C64) ) by L109 , L111 , L123 , L128 , L129
.= ( C16 . (C54 , ( D13 . (C56 , C54) )) ) by L118 , L124 , FUNCT_1:1;
end;
L132: [ ( 0 ) , C54 ] in [: ( NAT ) , C13 :] by ZFMISC_1:def 2;
L133: [ ( 0 ) , C54 ] in ( dom D13 ) by L132 , FUNCT_2:def 1;
consider C65 being set such that L134: [ [ ( 0 ) , C54 ] , C65 ] in D13 by L133 , XTUPLE_0:def 12;
consider C66 being (Element of ( NAT )), C67 being (Element of C13), C68 being (Element of C14) such that L135: [ [ ( 0 ) , C54 ] , C65 ] = [ [ C66 , C67 ] , C68 ] and L136: (ex B64 being (Function of ( NAT ) , C14) st (B64 = ( C35 . C67 ) & C68 = ( B64 . C66 ))) by L134;
L137: C65 = ( [ [ ( 0 ) , C54 ] , C65 ] `2 )
.= ( [ [ C66 , C67 ] , C68 ] `2 ) by L135
.= C68;
L138: [ ( 0 ) , C54 ] = ( [ [ ( 0 ) , C54 ] , C65 ] `1 )
.= ( [ [ C66 , C67 ] , C68 ] `1 ) by L135
.= [ C66 , C67 ];
L139: C67 = ( [ C66 , C67 ] `2 )
.= ( [ ( 0 ) , C54 ] `2 ) by L138
.= C54;
L140: C66 = ( [ C66 , C67 ] `1 )
.= ( [ ( 0 ) , C54 ] `1 ) by L138
.= ( 0 );
thus L141: thesis by L140 , L109 , L110 , L134 , L136 , L137 , L139 , L112 , FUNCT_1:1;
end;
thus L142: thesis by L108;
end;

end;
L25:
now
let C69 , C70 being non  empty set;
let C71 being (Element of C70);
let C72 being (Function of [: C70 , C69 :] , C70);
thus L26: (ex B65 being (Function of [: C69 , ( NAT ) :] , C70) st (for B66 being (Element of C69) holds (( B65 . (B66 , ( 0 )) ) = C71 & (for B67 being (Element of ( NAT )) holds ( B65 . (B66 , ( B67 + 1 )) ) = ( C72 . (( B65 . (B66 , B67) ) , B66) )))))
proof
L27: (for B68 being (Element of C69) holds (ex B69 being (Function of ( NAT ) , C70) st (( B69 . ( 0 ) ) = C71 & (for B70 being (Element of ( NAT )) holds ( B69 . ( B70 + 1 ) ) = ( C72 . (( B69 . B70 ) , B68) )))))
proof
let C73 being (Element of C69);
defpred S3[ (Element of ( NAT )) , (Element of C70) , (Element of C70) ] means $3 = ( C72 . ($2 , C73) );
L28: (for B71 being (Element of ( NAT )) holds (for B72 being (Element of C70) holds (ex B73 being (Element of C70) st S3[ B71 , B72 , B73 ])));
L29: (ex B74 being (Function of ( NAT ) , C70) st (( B74 . ( 0 ) ) = C71 & (for B75 being (Element of ( NAT )) holds S3[ B75 , ( B74 . B75 ) , ( B74 . ( B75 + 1 ) ) ]))) from RECDEF_1:sch 2(L28);
thus L30: thesis by L29;
end;
L31: (ex B76 being (Function of C69 , ( Funcs (( NAT ) , C70) )) st (for B77 being (Element of C69) holds (ex B78 being (Function of ( NAT ) , C70) st (( B76 . B77 ) = B78 & ( B78 . ( 0 ) ) = C71 & (for B79 being (Element of ( NAT )) holds ( B78 . ( B79 + 1 ) ) = ( C72 . (( B78 . B79 ) , B77) ))))))
proof
set D14 = { [ B80 , B81 ] where B80 is (Element of C69) , B81 is (Element of ( Funcs (( NAT ) , C70) )) : (ex B82 being (Function of ( NAT ) , C70) st (B82 = B81 & ( B82 . ( 0 ) ) = C71 & (for B83 being (Element of ( NAT )) holds ( B82 . ( B83 + 1 ) ) = ( C72 . (( B82 . B83 ) , B80) )))) };
L32:
now
let C74 , C75 , C76 being set;
assume that
L33: [ C74 , C75 ] in D14
and
L34: [ C74 , C76 ] in D14;
consider C77 being (Element of C69), C78 being (Element of ( Funcs (( NAT ) , C70) )) such that L35: [ C74 , C75 ] = [ C77 , C78 ] and L36: (ex B84 being (Function of ( NAT ) , C70) st (B84 = C78 & ( B84 . ( 0 ) ) = C71 & (for B85 being (Element of ( NAT )) holds ( B84 . ( B85 + 1 ) ) = ( C72 . (( B84 . B85 ) , C77) )))) by L33;
consider C79 being (Element of C69), C80 being (Element of ( Funcs (( NAT ) , C70) )) such that L37: [ C74 , C76 ] = [ C79 , C80 ] and L38: (ex B86 being (Function of ( NAT ) , C70) st (B86 = C80 & ( B86 . ( 0 ) ) = C71 & (for B87 being (Element of ( NAT )) holds ( B86 . ( B87 + 1 ) ) = ( C72 . (( B86 . B87 ) , C79) )))) by L34;
consider C81 being (Function of ( NAT ) , C70) such that L39: C81 = C78 and L40: ( C81 . ( 0 ) ) = C71 and L41: (for B88 being (Element of ( NAT )) holds ( C81 . ( B88 + 1 ) ) = ( C72 . (( C81 . B88 ) , C77) )) by L36;
consider C82 being (Function of ( NAT ) , C70) such that L42: C82 = C80 and L43: ( C82 . ( 0 ) ) = C71 and L44: (for B89 being (Element of ( NAT )) holds ( C82 . ( B89 + 1 ) ) = ( C72 . (( C82 . B89 ) , C79) )) by L38;
L45: C77 = ( [ C77 , C78 ] `1 )
.= ( [ C74 , C75 ] `1 ) by L35
.= C74
.= ( [ C74 , C76 ] `1 )
.= ( [ C79 , C80 ] `1 ) by L37
.= C79;
L46:
now
defpred S4[ (Element of ( NAT )) ] means ( C81 . $1 ) = ( C82 . $1 );
let C83 being set;
assume L47: C83 in ( NAT );
reconsider D15 = C83 as (Element of ( NAT )) by L47;
L48:
now
let C84 being (Element of ( NAT ));
assume L49: S4[ C84 ];
L50: ( C81 . ( C84 + 1 ) ) = ( C72 . (( C81 . C84 ) , C79) ) by L41 , L45
.= ( C82 . ( C84 + 1 ) ) by L44 , L49;
thus L51: S4[ ( C84 + 1 ) ] by L50;
end;
L52: S4[ ( 0 ) ] by L40 , L43;
L53: (for B90 being (Element of ( NAT )) holds S4[ B90 ]) from NAT_1:sch 1(L52 , L48);
thus L54: ( C81 . C83 ) = ( C82 . D15 ) by L53
.= ( C82 . C83 );
end;
L55: (( NAT ) = ( dom C81 ) & ( NAT ) = ( dom C82 )) by FUNCT_2:def 1;
thus L56: C75 = ( [ C74 , C75 ] `2 )
.= ( [ C77 , C78 ] `2 ) by L35
.= C78
.= C80 by L39 , L42 , L55 , L46 , FUNCT_1:2
.= ( [ C79 , C80 ] `2 )
.= ( [ C74 , C76 ] `2 ) by L37
.= C76;
end;
L57:
now
let C85 being set;
assume L58: C85 in D14;
L59: (ex B91 being (Element of C69) st (ex B92 being (Element of ( Funcs (( NAT ) , C70) )) st (C85 = [ B91 , B92 ] & (ex B93 being (Function of ( NAT ) , C70) st (B93 = B92 & ( B93 . ( 0 ) ) = C71 & (for B94 being (Element of ( NAT )) holds ( B93 . ( B94 + 1 ) ) = ( C72 . (( B93 . B94 ) , B91) ))))))) by L58;
thus L60: C85 in [: C69 , ( Funcs (( NAT ) , C70) ) :] by L59 , ZFMISC_1:def 2;
end;
reconsider D16 = D14 as (Relation of C69 , ( Funcs (( NAT ) , C70) )) by L57 , TARSKI:def 3;
L61: (for B95 being set holds (B95 in C69 implies B95 in ( dom D16 )))
proof
let C86 being set;
assume L62: C86 in C69;
consider C87 being (Function of ( NAT ) , C70) such that L63: (( C87 . ( 0 ) ) = C71 & (for B96 being (Element of ( NAT )) holds ( C87 . ( B96 + 1 ) ) = ( C72 . (( C87 . B96 ) , C86) ))) by L62 , L27;
reconsider D17 = C87 as (Element of ( Funcs (( NAT ) , C70) )) by FUNCT_2:8;
L64: [ C86 , D17 ] in D16 by L62 , L63;
thus L65: thesis by L64 , XTUPLE_0:def 12;
end;
L66: (for B97 being set holds (B97 in ( dom D16 ) implies B97 in C69));
L67: ( dom D16 ) = C69 by L66 , L61 , TARSKI:1;
reconsider D18 = D16 as (Function of C69 , ( Funcs (( NAT ) , C70) )) by L67 , L32 , FUNCT_1:def 1 , FUNCT_2:def 1;
take D18;
L68: (for B98 being (Element of C69) holds (ex B99 being (Function of ( NAT ) , C70) st (( D18 . B98 ) = B99 & ( B99 . ( 0 ) ) = C71 & (for B100 being (Element of ( NAT )) holds ( B99 . ( B100 + 1 ) ) = ( C72 . (( B99 . B100 ) , B98) )))))
proof
let C88 being (Element of C69);
L69: ( dom D18 ) = C69 by FUNCT_2:def 1;
L70: [ C88 , ( D18 . C88 ) ] in D18 by L69 , FUNCT_1:1;
consider C89 being (Element of C69), C90 being (Element of ( Funcs (( NAT ) , C70) )) such that L71: [ C88 , ( D18 . C88 ) ] = [ C89 , C90 ] and L72: (ex B101 being (Function of ( NAT ) , C70) st (B101 = C90 & ( B101 . ( 0 ) ) = C71 & (for B102 being (Element of ( NAT )) holds ( B101 . ( B102 + 1 ) ) = ( C72 . (( B101 . B102 ) , C89) )))) by L70;
L73: ( D18 . C88 ) = ( [ C88 , ( D18 . C88 ) ] `2 )
.= ( [ C89 , C90 ] `2 ) by L71
.= C90;
L74: C88 = ( [ C88 , ( D18 . C88 ) ] `1 )
.= ( [ C89 , C90 ] `1 ) by L71
.= C89;
thus L75: thesis by L74 , L72 , L73;
end;
thus L76: thesis by L68;
end;
consider C91 being (Function of C69 , ( Funcs (( NAT ) , C70) )) such that L77: (for B103 being (Element of C69) holds (ex B104 being (Function of ( NAT ) , C70) st (( C91 . B103 ) = B104 & ( B104 . ( 0 ) ) = C71 & (for B105 being (Element of ( NAT )) holds ( B104 . ( B105 + 1 ) ) = ( C72 . (( B104 . B105 ) , B103) ))))) by L31;
set D19 = { [ [ B107 , B106 ] , B108 ] where B106 is (Element of ( NAT )) , B107 is (Element of C69) , B108 is (Element of C70) : (ex B109 being (Function of ( NAT ) , C70) st (B109 = ( C91 . B107 ) & B108 = ( B109 . B106 ))) };
L78:
now
let C92 , C93 , C94 being set;
assume that
L79: [ C92 , C93 ] in D19
and
L80: [ C92 , C94 ] in D19;
consider C95 being (Element of ( NAT )), C96 being (Element of C69), C97 being (Element of C70) such that L81: [ C92 , C93 ] = [ [ C96 , C95 ] , C97 ] and L82: (ex B110 being (Function of ( NAT ) , C70) st (B110 = ( C91 . C96 ) & C97 = ( B110 . C95 ))) by L79;
consider C98 being (Element of ( NAT )), C99 being (Element of C69), C100 being (Element of C70) such that L83: [ C92 , C94 ] = [ [ C99 , C98 ] , C100 ] and L84: (ex B111 being (Function of ( NAT ) , C70) st (B111 = ( C91 . C99 ) & C100 = ( B111 . C98 ))) by L80;
L85: [ C96 , C95 ] = ( [ [ C96 , C95 ] , C97 ] `1 )
.= ( [ C92 , C93 ] `1 ) by L81
.= C92
.= ( [ C92 , C94 ] `1 )
.= ( [ [ C99 , C98 ] , C100 ] `1 ) by L83
.= [ C99 , C98 ];
L86: C95 = ( [ C96 , C95 ] `2 )
.= ( [ C99 , C98 ] `2 ) by L85
.= C98;
L87: C96 = ( [ C96 , C95 ] `1 )
.= ( [ C99 , C98 ] `1 ) by L85
.= C99;
thus L88: C93 = ( [ C92 , C93 ] `2 )
.= ( [ C92 , C94 ] `2 ) by L81 , L82 , L83 , L84 , L86 , L87
.= C94;
end;
L89:
now
let C101 being set;
assume L90: C101 in D19;
consider C102 being (Element of ( NAT )), C103 being (Element of C69), C104 being (Element of C70) such that L91: C101 = [ [ C103 , C102 ] , C104 ] and L92: (ex B112 being (Function of ( NAT ) , C70) st (B112 = ( C91 . C103 ) & C104 = ( B112 . C102 ))) by L90;
L93: [ C103 , C102 ] in [: C69 , ( NAT ) :] by ZFMISC_1:def 2;
thus L94: C101 in [: [: C69 , ( NAT ) :] , C70 :] by L93 , L91 , ZFMISC_1:def 2;
end;
reconsider D20 = D19 as (Relation of [: C69 , ( NAT ) :] , C70) by L89 , TARSKI:def 3;
L95: (for B113 being set holds (B113 in [: C69 , ( NAT ) :] implies B113 in ( dom D20 )))
proof
let C105 being set;
assume L96: C105 in [: C69 , ( NAT ) :];
consider C106 , C107 being set such that L97: C106 in C69 and L98: C107 in ( NAT ) and L99: C105 = [ C106 , C107 ] by L96 , ZFMISC_1:def 2;
reconsider D21 = C106 as (Element of C69) by L97;
reconsider D22 = C107 as (Element of ( NAT )) by L98;
consider C108 being (Function of ( NAT ) , C70) such that L100: ( C91 . D21 ) = C108 and L101: ( C108 . ( 0 ) ) = C71 and L102: (for B114 being (Element of ( NAT )) holds ( C108 . ( B114 + 1 ) ) = ( C72 . (( C108 . B114 ) , D21) )) by L77;
L103: (ex B115 being (Element of C70) st (ex B116 being (Function of ( NAT ) , C70) st (B116 = ( C91 . D21 ) & B115 = ( B116 . D22 ))))
proof
take ( C108 . D22 );
take C108;
thus L104: thesis by L100;
end;
consider C109 being (Element of C70) such that L105: (ex B117 being (Function of ( NAT ) , C70) st (B117 = ( C91 . D21 ) & C109 = ( B117 . D22 ))) by L103;
L106: [ C105 , C109 ] in D20 by L99 , L105;
thus L107: thesis by L106 , XTUPLE_0:def 12;
end;
L108: (for B118 being set holds (B118 in ( dom D20 ) implies B118 in [: C69 , ( NAT ) :]));
L109: ( dom D20 ) = [: C69 , ( NAT ) :] by L108 , L95 , TARSKI:1;
reconsider D23 = D20 as (Function of [: C69 , ( NAT ) :] , C70) by L109 , L78 , FUNCT_1:def 1 , FUNCT_2:def 1;
take D23;
L110: (for B119 being (Element of C69) holds (( D23 . (B119 , ( 0 )) ) = C71 & (for B120 being (Element of ( NAT )) holds ( D23 . (B119 , ( B120 + 1 )) ) = ( C72 . (( D23 . (B119 , B120) ) , B119) ))))
proof
let C110 being (Element of C69);
consider C111 being (Function of ( NAT ) , C70) such that L111: ( C91 . C110 ) = C111 and L112: ( C111 . ( 0 ) ) = C71 and L113: (for B121 being (Element of ( NAT )) holds ( C111 . ( B121 + 1 ) ) = ( C72 . (( C111 . B121 ) , C110) )) by L77;
L114:
now
let C112 being (Element of ( NAT ));
L115: [ C110 , ( C112 + 1 ) ] in [: C69 , ( NAT ) :] by ZFMISC_1:def 2;
L116: [ C110 , ( C112 + 1 ) ] in ( dom D23 ) by L115 , FUNCT_2:def 1;
consider C113 being set such that L117: [ [ C110 , ( C112 + 1 ) ] , C113 ] in D23 by L116 , XTUPLE_0:def 12;
L118: [ C110 , C112 ] in [: C69 , ( NAT ) :] by ZFMISC_1:def 2;
L119: [ C110 , C112 ] in ( dom D23 ) by L118 , FUNCT_2:def 1;
consider C114 being set such that L120: [ [ C110 , C112 ] , C114 ] in D23 by L119 , XTUPLE_0:def 12;
consider C115 being (Element of ( NAT )), C116 being (Element of C69), C117 being (Element of C70) such that L121: [ [ C110 , C112 ] , C114 ] = [ [ C116 , C115 ] , C117 ] and L122: (ex B122 being (Function of ( NAT ) , C70) st (B122 = ( C91 . C116 ) & C117 = ( B122 . C115 ))) by L120;
L123: C114 = ( [ [ C110 , C112 ] , C114 ] `2 )
.= ( [ [ C116 , C115 ] , C117 ] `2 ) by L121
.= C117;
L124: [ C110 , C112 ] = ( [ [ C110 , C112 ] , C114 ] `1 )
.= ( [ [ C116 , C115 ] , C117 ] `1 ) by L121
.= [ C116 , C115 ];
L125: C115 = ( [ C116 , C115 ] `2 )
.= ( [ C110 , C112 ] `2 ) by L124
.= C112;
consider C118 being (Function of ( NAT ) , C70) such that L126: C118 = ( C91 . C116 ) and L127: C117 = ( C118 . C115 ) by L122;
consider C119 being (Element of ( NAT )), C120 being (Element of C69), C121 being (Element of C70) such that L128: [ [ C110 , ( C112 + 1 ) ] , C113 ] = [ [ C120 , C119 ] , C121 ] and L129: (ex B123 being (Function of ( NAT ) , C70) st (B123 = ( C91 . C120 ) & C121 = ( B123 . C119 ))) by L117;
L130: [ C110 , ( C112 + 1 ) ] = ( [ [ C110 , ( C112 + 1 ) ] , C113 ] `1 )
.= ( [ [ C120 , C119 ] , C121 ] `1 ) by L128
.= [ C120 , C119 ];
L131: C119 = ( [ C120 , C119 ] `2 )
.= ( [ C110 , ( C112 + 1 ) ] `2 ) by L130
.= ( C112 + 1 );
L132: C116 = ( [ C116 , C115 ] `1 )
.= ( [ C110 , C112 ] `1 ) by L124
.= C110;
L133: C120 = ( [ C120 , C119 ] `1 )
.= ( [ C110 , ( C112 + 1 ) ] `1 ) by L130
.= C110;
L134: C113 = ( [ [ C110 , ( C112 + 1 ) ] , C113 ] `2 )
.= ( [ [ C120 , C119 ] , C121 ] `2 ) by L128
.= C121;
thus L135: ( D23 . (C110 , ( C112 + 1 )) ) = ( C111 . C119 ) by L134 , L111 , L117 , L129 , L133 , FUNCT_1:1
.= ( C72 . (( C118 . C115 ) , C110) ) by L111 , L113 , L131 , L126 , L125 , L132
.= ( C72 . (( D23 . (C110 , C112) ) , C110) ) by L120 , L127 , L123 , FUNCT_1:1;
end;
L136: [ C110 , ( 0 ) ] in [: C69 , ( NAT ) :] by ZFMISC_1:def 2;
L137: [ C110 , ( 0 ) ] in ( dom D23 ) by L136 , FUNCT_2:def 1;
consider C122 being set such that L138: [ [ C110 , ( 0 ) ] , C122 ] in D23 by L137 , XTUPLE_0:def 12;
consider C123 being (Element of ( NAT )), C124 being (Element of C69), C125 being (Element of C70) such that L139: [ [ C110 , ( 0 ) ] , C122 ] = [ [ C124 , C123 ] , C125 ] and L140: (ex B124 being (Function of ( NAT ) , C70) st (B124 = ( C91 . C124 ) & C125 = ( B124 . C123 ))) by L138;
L141: C122 = ( [ [ C110 , ( 0 ) ] , C122 ] `2 )
.= ( [ [ C124 , C123 ] , C125 ] `2 ) by L139
.= C125;
L142: [ C110 , ( 0 ) ] = ( [ [ C110 , ( 0 ) ] , C122 ] `1 )
.= ( [ [ C124 , C123 ] , C125 ] `1 ) by L139
.= [ C124 , C123 ];
L143: C124 = ( [ C124 , C123 ] `1 )
.= ( [ C110 , ( 0 ) ] `1 ) by L142
.= C110;
L144: C123 = ( [ C124 , C123 ] `2 )
.= ( [ C110 , ( 0 ) ] `2 ) by L142
.= ( 0 );
thus L145: thesis by L144 , L111 , L112 , L138 , L140 , L141 , L143 , L114 , FUNCT_1:1;
end;
thus L146: thesis by L110;
end;

end;
begin
theorem
L27: (for B125 being  left_zeroed non  empty addLoopStr holds (for B126 being (Element of B125) holds ( Sum <* B126 *> ) = B126))
proof
let C126 being  left_zeroed non  empty addLoopStr;
let C127 being (Element of C126);
reconsider D24 = C127 as (Element of C126);
set D25 = <* C127 *>;
consider C128 being (Function of ( NAT ) , (the carrier of C126)) such that L28: ( Sum D25 ) = ( C128 . ( len D25 ) ) and L29: (( C128 . ( 0 ) ) = ( 0. C126 ) & (for B127 being (Element of ( NAT )) holds (for B128 being (Element of C126) holds ((B127 < ( len D25 ) & B128 = ( D25 . ( B127 + 1 ) )) implies ( C128 . ( B127 + 1 ) ) = ( ( C128 . B127 ) + B128 ))))) by RLVECT_1:def 12;
L30: ( len <* D24 *> ) = 1 by FINSEQ_1:39;
L31: ( 0 ) < 1;
consider C129 being (Element of ( NAT )) such that L32: C129 < ( len D25 ) by L31;
L33: ( D25 . ( C129 + 1 ) ) = ( D25 . ( ( 0 ) + 1 ) ) by L30 , L32 , NAT_1:14
.= C127 by FINSEQ_1:40;
L34: C129 = ( 0 ) by L30 , L32 , NAT_1:14;
L35: ( C128 . 1 ) = ( ( 0. C126 ) + C127 ) by L34 , L29 , L33
.= D24 by ALGSTR_1:def 2;
thus L36: thesis by L35 , L28 , FINSEQ_1:39;
end;
theorem
L37: (for B129 being  left_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr holds (for B130 being (Element of B129) holds (for B131 being (FinSequence of (the carrier of B129)) holds ( Sum ( B130 * B131 ) ) = ( B130 * ( Sum B131 ) ))))
proof
let C130 being  left_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr;
let C131 being (Element of C130);
let C132 being (FinSequence of (the carrier of C130));
consider C133 being (Function of ( NAT ) , (the carrier of C130)) such that L38: ( Sum C132 ) = ( C133 . ( len C132 ) ) and L39: ( C133 . ( 0 ) ) = ( 0. C130 ) and L40: (for B132 being (Element of ( NAT )) holds (for B133 being (Element of C130) holds ((B132 < ( len C132 ) & B133 = ( C132 . ( B132 + 1 ) )) implies ( C133 . ( B132 + 1 ) ) = ( ( C133 . B132 ) + B133 )))) by RLVECT_1:def 12;
consider C134 being (Function of ( NAT ) , (the carrier of C130)) such that L41: ( Sum ( C131 * C132 ) ) = ( C134 . ( len ( C131 * C132 ) ) ) and L42: ( C134 . ( 0 ) ) = ( 0. C130 ) and L43: (for B134 being (Element of ( NAT )) holds (for B135 being (Element of C130) holds ((B134 < ( len ( C131 * C132 ) ) & B135 = ( ( C131 * C132 ) . ( B134 + 1 ) )) implies ( C134 . ( B134 + 1 ) ) = ( ( C134 . B134 ) + B135 )))) by RLVECT_1:def 12;
defpred S5[ (Element of ( NAT )) ] means ( C131 * ( C133 . $1 ) ) = ( C134 . $1 );
L44: ( Seg ( len ( C131 * C132 ) ) ) = ( dom ( C131 * C132 ) ) by FINSEQ_1:def 3
.= ( dom C132 ) by POLYNOM1:def 1
.= ( Seg ( len C132 ) ) by FINSEQ_1:def 3;
L45:
now
let C135 being (Element of ( NAT ));
assume that
L46: ( 0 ) <= C135
and
L47: C135 < ( len C132 );
thus L48: (S5[ C135 ] implies S5[ ( C135 + 1 ) ])
proof
L49: ( ( 0 ) + 1 ) <= ( C135 + 1 ) by XREAL_1:6;
L50: C135 < ( len ( C131 * C132 ) ) by L44 , L47 , FINSEQ_1:6;
L51: ( C135 + 1 ) <= ( len ( C131 * C132 ) ) by L50 , NAT_1:13;
L52: ( C135 + 1 ) in ( Seg ( len ( C131 * C132 ) ) ) by L51 , L49 , FINSEQ_1:1;
L53: ( C135 + 1 ) in ( dom ( C131 * C132 ) ) by L52 , FINSEQ_1:def 3;
L54: ( ( C131 * C132 ) /. ( C135 + 1 ) ) = ( ( C131 * C132 ) . ( C135 + 1 ) ) by L53 , PARTFUN1:def 6;
L55: ( C135 + 1 ) <= ( len C132 ) by L47 , NAT_1:13;
L56: ( C135 + 1 ) in ( Seg ( len C132 ) ) by L55 , L49 , FINSEQ_1:1;
L57: ( C135 + 1 ) in ( dom C132 ) by L56 , FINSEQ_1:def 3;
L58: ( C132 /. ( C135 + 1 ) ) = ( C132 . ( C135 + 1 ) ) by L57 , PARTFUN1:def 6;
assume L59: S5[ C135 ];
thus L60: ( C134 . ( C135 + 1 ) ) = ( ( C131 * ( C133 . C135 ) ) + ( ( C131 * C132 ) /. ( C135 + 1 ) ) ) by L59 , L43 , L50 , L54
.= ( ( C131 * ( C133 . C135 ) ) + ( C131 * ( C132 /. ( C135 + 1 ) ) ) ) by L57 , POLYNOM1:def 1
.= ( C131 * ( ( C133 . C135 ) + ( C132 /. ( C135 + 1 ) ) ) ) by VECTSP_1:def 2
.= ( C131 * ( C133 . ( C135 + 1 ) ) ) by L40 , L47 , L58;
end;

end;
L49: S5[ ( 0 ) ] by L39 , L42 , L19;
L50: (for B136 being (Element of ( NAT )) holds ((( 0 ) <= B136 & B136 <= ( len C132 )) implies S5[ B136 ])) from INT_1:sch 7(L49 , L45);
thus L51: ( Sum ( C131 * C132 ) ) = ( C134 . ( len C132 ) ) by L41 , L44 , FINSEQ_1:6
.= ( C131 * ( Sum C132 ) ) by L38 , L50;
end;
theorem
L52: (for B137 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr holds (for B138 being (Element of B137) holds (for B139 being (FinSequence of (the carrier of B137)) holds ( Sum ( B139 * B138 ) ) = ( ( Sum B139 ) * B138 ))))
proof
let C136 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr;
let C137 being (Element of C136);
let C138 being (FinSequence of (the carrier of C136));
consider C139 being (Function of ( NAT ) , (the carrier of C136)) such that L53: ( Sum C138 ) = ( C139 . ( len C138 ) ) and L54: ( C139 . ( 0 ) ) = ( 0. C136 ) and L55: (for B140 being (Element of ( NAT )) holds (for B141 being (Element of C136) holds ((B140 < ( len C138 ) & B141 = ( C138 . ( B140 + 1 ) )) implies ( C139 . ( B140 + 1 ) ) = ( ( C139 . B140 ) + B141 )))) by RLVECT_1:def 12;
consider C140 being (Function of ( NAT ) , (the carrier of C136)) such that L56: ( Sum ( C138 * C137 ) ) = ( C140 . ( len ( C138 * C137 ) ) ) and L57: ( C140 . ( 0 ) ) = ( 0. C136 ) and L58: (for B142 being (Element of ( NAT )) holds (for B143 being (Element of C136) holds ((B142 < ( len ( C138 * C137 ) ) & B143 = ( ( C138 * C137 ) . ( B142 + 1 ) )) implies ( C140 . ( B142 + 1 ) ) = ( ( C140 . B142 ) + B143 )))) by RLVECT_1:def 12;
defpred S6[ (Element of ( NAT )) ] means ( ( C139 . $1 ) * C137 ) = ( C140 . $1 );
L59: ( Seg ( len ( C138 * C137 ) ) ) = ( dom ( C138 * C137 ) ) by FINSEQ_1:def 3
.= ( dom C138 ) by POLYNOM1:def 2
.= ( Seg ( len C138 ) ) by FINSEQ_1:def 3;
L60:
now
let C141 being (Element of ( NAT ));
assume that
L61: ( 0 ) <= C141
and
L62: C141 < ( len C138 );
thus L63: (S6[ C141 ] implies S6[ ( C141 + 1 ) ])
proof
L64: C141 < ( len ( C138 * C137 ) ) by L59 , L62 , FINSEQ_1:6;
L65: ( C141 + 1 ) <= ( len ( C138 * C137 ) ) by L64 , NAT_1:13;
L66: ( ( 0 ) + 1 ) <= ( C141 + 1 ) by XREAL_1:6;
L67: ( C141 + 1 ) in ( Seg ( len ( C138 * C137 ) ) ) by L66 , L65 , FINSEQ_1:1;
L68: ( C141 + 1 ) in ( dom ( C138 * C137 ) ) by L67 , FINSEQ_1:def 3;
L69: ( ( C138 * C137 ) /. ( C141 + 1 ) ) = ( ( C138 * C137 ) . ( C141 + 1 ) ) by L68 , PARTFUN1:def 6;
L70: ( C141 + 1 ) in ( Seg ( len C138 ) ) by L59 , L65 , L66 , FINSEQ_1:1;
L71: ( C141 + 1 ) in ( dom C138 ) by L70 , FINSEQ_1:def 3;
L72: ( C138 /. ( C141 + 1 ) ) = ( C138 . ( C141 + 1 ) ) by L71 , PARTFUN1:def 6;
assume L73: ( ( C139 . C141 ) * C137 ) = ( C140 . C141 );
thus L74: ( C140 . ( C141 + 1 ) ) = ( ( ( C139 . C141 ) * C137 ) + ( ( C138 * C137 ) /. ( C141 + 1 ) ) ) by L73 , L58 , L64 , L69
.= ( ( ( C139 . C141 ) * C137 ) + ( ( C138 /. ( C141 + 1 ) ) * C137 ) ) by L71 , POLYNOM1:def 2
.= ( ( ( C139 . C141 ) + ( C138 /. ( C141 + 1 ) ) ) * C137 ) by VECTSP_1:def 3
.= ( ( C139 . ( C141 + 1 ) ) * C137 ) by L55 , L62 , L72;
end;

end;
L64: S6[ ( 0 ) ] by L54 , L57 , L15;
L65: (for B144 being (Element of ( NAT )) holds ((( 0 ) <= B144 & B144 <= ( len C138 )) implies S6[ B144 ])) from INT_1:sch 7(L64 , L60);
thus L66: ( Sum ( C138 * C137 ) ) = ( C140 . ( len C138 ) ) by L56 , L59 , FINSEQ_1:6
.= ( ( Sum C138 ) * C137 ) by L53 , L65;
end;
theorem
L67: (for B145 being  commutative non  empty multMagma holds (for B146 being (Element of B145) holds (for B147 being (FinSequence of (the carrier of B145)) holds ( B147 * B146 ) = ( B146 * B147 ))))
proof
let C142 being  commutative non  empty multMagma;
let C143 being (Element of C142);
let C144 being (FinSequence of (the carrier of C142));
set D26 = ( C144 * C143 );
set D27 = ( C143 * C144 );
L68: ( dom D26 ) = ( dom C144 ) by POLYNOM1:def 2;
L69: ( dom D27 ) = ( dom C144 ) by POLYNOM1:def 1;
L70:
now
let C145 being Nat;
assume that
L71: C145 in ( dom D26 );
thus L72: ( D26 /. C145 ) = ( ( C144 /. C145 ) * C143 ) by L68 , L71 , POLYNOM1:def 2
.= ( D27 /. C145 ) by L68 , L71 , POLYNOM1:def 1;
end;
thus L73: thesis by L70 , L68 , L69 , FINSEQ_5:12;
end;
definition
let C146 being non  empty addLoopStr;
let C147 , C148 being (FinSequence of (the carrier of C146));
func C147 + C148 -> (FinSequence of (the carrier of C146)) means 
:L74: (( dom it ) = ( dom C147 ) & (for B148 being Nat holds ((1 <= B148 & B148 <= ( len it )) implies ( it /. B148 ) = ( ( C147 /. B148 ) + ( C148 /. B148 ) ))));
existence
proof
defpred S7[ (Element of ( NAT )) , (Element of C146) ] means $2 = ( ( C147 /. $1 ) + ( C148 /. $1 ) );
L75: (for B149 being (Element of ( NAT )) holds (B149 in ( Seg ( len C147 ) ) implies (ex B150 being (Element of C146) st S7[ B149 , B150 ])));
consider C149 being (FinSequence of (the carrier of C146)) such that L76: (( dom C149 ) = ( Seg ( len C147 ) ) & (for B151 being (Element of ( NAT )) holds (B151 in ( Seg ( len C147 ) ) implies S7[ B151 , ( C149 /. B151 ) ]))) from RECDEF_1:sch 17(L75);
take C149;
L77: ( len C149 ) = ( len C147 ) by L76 , FINSEQ_1:def 3;
L78:
now
let C150 being Nat;
assume L79: (1 <= C150 & C150 <= ( len C149 ));
L80: C150 in ( Seg ( len C147 ) ) by L79 , L77 , FINSEQ_1:1;
thus L81: ( C149 /. C150 ) = ( ( C147 /. C150 ) + ( C148 /. C150 ) ) by L80 , L76;
end;
thus L82: thesis by L78 , L76 , FINSEQ_1:def 3;
end;
uniqueness
proof
let C151 , C152 being (FinSequence of (the carrier of C146));
assume that
L83: ( dom C151 ) = ( dom C147 )
and
L84: (for B152 being Nat holds ((1 <= B152 & B152 <= ( len C151 )) implies ( C151 /. B152 ) = ( ( C147 /. B152 ) + ( C148 /. B152 ) )))
and
L85: ( dom C152 ) = ( dom C147 )
and
L86: (for B153 being Nat holds ((1 <= B153 & B153 <= ( len C152 )) implies ( C152 /. B153 ) = ( ( C147 /. B153 ) + ( C148 /. B153 ) )));
L87: ( Seg ( len C151 ) ) = ( dom C152 ) by L83 , L85 , FINSEQ_1:def 3
.= ( Seg ( len C152 ) ) by FINSEQ_1:def 3;
L88: ( len C151 ) = ( len C152 ) by L87 , FINSEQ_1:6;
L89:
now
let C153 being Nat;
assume L90: (1 <= C153 & C153 <= ( len C151 ));
L91: C153 in ( Seg ( len C152 ) ) by L90 , L87 , FINSEQ_1:1;
L92: C153 in ( dom C152 ) by L91 , FINSEQ_1:def 3;
L93: C153 in ( Seg ( len C151 ) ) by L90 , FINSEQ_1:1;
L94: C153 in ( dom C151 ) by L93 , FINSEQ_1:def 3;
thus L95: ( C151 . C153 ) = ( C151 /. C153 ) by L94 , PARTFUN1:def 6
.= ( ( C147 /. C153 ) + ( C148 /. C153 ) ) by L84 , L90
.= ( C152 /. C153 ) by L86 , L88 , L90
.= ( C152 . C153 ) by L92 , PARTFUN1:def 6;
end;
thus L96: thesis by L89 , L87 , FINSEQ_1:6 , FINSEQ_1:14;
end;
end;
theorem
L98: (for B154 being  Abelian  right_zeroed  add-associative non  empty addLoopStr holds (for B155 , B156 being (FinSequence of (the carrier of B154)) holds (( dom B155 ) = ( dom B156 ) implies ( Sum ( B155 + B156 ) ) = ( ( Sum B155 ) + ( Sum B156 ) ))))
proof
let C154 being  Abelian  right_zeroed  add-associative non  empty addLoopStr;
let C155 , C156 being (FinSequence of (the carrier of C154));
consider C157 being (Function of ( NAT ) , (the carrier of C154)) such that L99: ( Sum C155 ) = ( C157 . ( len C155 ) ) and L100: ( C157 . ( 0 ) ) = ( 0. C154 ) and L101: (for B157 being (Element of ( NAT )) holds (for B158 being (Element of C154) holds ((B157 < ( len C155 ) & B158 = ( C155 . ( B157 + 1 ) )) implies ( C157 . ( B157 + 1 ) ) = ( ( C157 . B157 ) + B158 )))) by RLVECT_1:def 12;
consider C158 being (Function of ( NAT ) , (the carrier of C154)) such that L102: ( Sum C156 ) = ( C158 . ( len C156 ) ) and L103: ( C158 . ( 0 ) ) = ( 0. C154 ) and L104: (for B159 being (Element of ( NAT )) holds (for B160 being (Element of C154) holds ((B159 < ( len C156 ) & B160 = ( C156 . ( B159 + 1 ) )) implies ( C158 . ( B159 + 1 ) ) = ( ( C158 . B159 ) + B160 )))) by RLVECT_1:def 12;
assume L105: ( dom C155 ) = ( dom C156 );
L106: ( Seg ( len C155 ) ) = ( dom C156 ) by L105 , FINSEQ_1:def 3
.= ( Seg ( len C156 ) ) by FINSEQ_1:def 3;
L107: ( len C156 ) = ( len C155 ) by L106 , FINSEQ_1:6;
consider C159 being (Function of ( NAT ) , (the carrier of C154)) such that L108: ( Sum ( C155 + C156 ) ) = ( C159 . ( len ( C155 + C156 ) ) ) and L109: ( C159 . ( 0 ) ) = ( 0. C154 ) and L110: (for B161 being (Element of ( NAT )) holds (for B162 being (Element of C154) holds ((B161 < ( len ( C155 + C156 ) ) & B162 = ( ( C155 + C156 ) . ( B161 + 1 ) )) implies ( C159 . ( B161 + 1 ) ) = ( ( C159 . B161 ) + B162 )))) by RLVECT_1:def 12;
defpred S8[ (Element of ( NAT )) ] means ( ( C157 . $1 ) + ( C158 . $1 ) ) = ( C159 . $1 );
L111: ( Seg ( len C155 ) ) = ( dom C155 ) by FINSEQ_1:def 3
.= ( dom ( C155 + C156 ) ) by L74
.= ( Seg ( len ( C155 + C156 ) ) ) by FINSEQ_1:def 3;
L112: ( len ( C155 + C156 ) ) = ( len C155 ) by L111 , FINSEQ_1:6;
L113:
now
let C160 being (Element of ( NAT ));
assume that
L114: ( 0 ) <= C160
and
L115: C160 < ( len C155 );
thus L116: (S8[ C160 ] implies S8[ ( C160 + 1 ) ])
proof
assume L117: S8[ C160 ];
L118: ( ( 0 ) + 1 ) <= ( C160 + 1 ) by XREAL_1:6;
L119: ( C160 + 1 ) <= ( len C155 ) by L115 , NAT_1:13;
L120: ( C160 + 1 ) in ( Seg ( len C155 ) ) by L119 , L118 , FINSEQ_1:1;
L121: ( C160 + 1 ) in ( dom C155 ) by L120 , FINSEQ_1:def 3;
L122: ( C155 /. ( C160 + 1 ) ) = ( C155 . ( C160 + 1 ) ) by L121 , PARTFUN1:def 6;
L123: ( C160 + 1 ) in ( Seg ( len C156 ) ) by L106 , L119 , L118 , FINSEQ_1:1;
L124: ( C160 + 1 ) in ( dom C156 ) by L123 , FINSEQ_1:def 3;
L125: ( C156 /. ( C160 + 1 ) ) = ( C156 . ( C160 + 1 ) ) by L124 , PARTFUN1:def 6;
L126: ( C160 + 1 ) <= ( len ( C155 + C156 ) ) by L112 , L115 , NAT_1:13;
L127: ( C160 + 1 ) in ( Seg ( len ( C155 + C156 ) ) ) by L126 , L118 , FINSEQ_1:1;
L128: ( C160 + 1 ) in ( dom ( C155 + C156 ) ) by L127 , FINSEQ_1:def 3;
L129: ( ( C155 + C156 ) /. ( C160 + 1 ) ) = ( ( C155 + C156 ) . ( C160 + 1 ) ) by L128 , PARTFUN1:def 6;
L130: ( C159 . ( C160 + 1 ) ) = ( ( C159 . C160 ) + ( ( C155 + C156 ) /. ( C160 + 1 ) ) ) by L129 , L112 , L110 , L115
.= ( ( ( C157 . C160 ) + ( C158 . C160 ) ) + ( ( C155 /. ( C160 + 1 ) ) + ( C156 /. ( C160 + 1 ) ) ) ) by L117 , L126 , L118 , L74
.= ( ( C157 . C160 ) + ( ( C158 . C160 ) + ( ( C155 /. ( C160 + 1 ) ) + ( C156 /. ( C160 + 1 ) ) ) ) ) by RLVECT_1:def 3
.= ( ( C157 . C160 ) + ( ( C155 /. ( C160 + 1 ) ) + ( ( C158 . C160 ) + ( C156 /. ( C160 + 1 ) ) ) ) ) by RLVECT_1:def 3
.= ( ( ( C157 . C160 ) + ( C155 /. ( C160 + 1 ) ) ) + ( ( C158 . C160 ) + ( C156 /. ( C160 + 1 ) ) ) ) by RLVECT_1:def 3
.= ( ( C157 . ( C160 + 1 ) ) + ( ( C158 . C160 ) + ( C156 /. ( C160 + 1 ) ) ) ) by L101 , L115 , L122
.= ( ( C157 . ( C160 + 1 ) ) + ( C158 . ( C160 + 1 ) ) ) by L107 , L104 , L115 , L125;
thus L131: thesis by L130;
end;

end;
L117: S8[ ( 0 ) ] by L100 , L103 , L109 , RLVECT_1:def 4;
L118: (for B163 being (Element of ( NAT )) holds ((( 0 ) <= B163 & B163 <= ( len C155 )) implies S8[ B163 ])) from INT_1:sch 7(L117 , L113);
thus L119: ( Sum ( C155 + C156 ) ) = ( C159 . ( len C155 ) ) by L111 , L108 , FINSEQ_1:6
.= ( ( Sum C155 ) + ( Sum C156 ) ) by L107 , L99 , L102 , L118;
end;
begin
definition
let C161 being  unital non  empty multMagma;
let C162 being (Element of C161);
let C163 being Nat;
func C162 |^ C163 -> (Element of C161) equals 
( ( power C161 ) . (C162 , C163) );
coherence
proof
reconsider D28 = C163 as (Element of ( NAT )) by ORDINAL1:def 12;
L120: ( ( power C161 ) . (C162 , D28) ) is (Element of C161);
thus L121: thesis by L120;
end;
end;
theorem
L123: (for B164 being  unital non  empty multMagma holds (for B165 being (Element of B164) holds (( B165 |^ ( 0 ) ) = ( 1_ B164 ) & ( B165 |^ 1 ) = B165)))
proof
let C164 being  unital non  empty multMagma;
let C165 being (Element of C164);
thus L124: ( C165 |^ ( 0 ) ) = ( 1_ C164 ) by GROUP_1:def 7;
L125: ( ( 0 ) + 1 ) = 1;
L126: ( ( power C164 ) . (C165 , 1) ) = ( ( ( power C164 ) . (C165 , ( 0 )) ) * C165 ) by L125 , GROUP_1:def 7
.= ( ( 1_ C164 ) * C165 ) by GROUP_1:def 7
.= C165 by GROUP_1:def 4;
thus L127: thesis by L126;
end;
theorem
L128: (for B166 being  unital  associative  commutative non  empty multMagma holds (for B167 , B168 being (Element of B166) holds (for B169 being Nat holds ( ( B167 * B168 ) |^ B169 ) = ( ( B167 |^ B169 ) * ( B168 |^ B169 ) ))))
proof
let C166 being  unital  associative  commutative non  empty multMagma;
let C167 , C168 being (Element of C166);
let C169 being Nat;
L129: C169 in ( NAT ) by ORDINAL1:def 12;
defpred S9[ (Element of ( NAT )) ] means ( ( power C166 ) . (( C167 * C168 ) , $1) ) = ( ( ( power C166 ) . (C167 , $1) ) * ( ( power C166 ) . (C168 , $1) ) );
L130:
now
let C170 being (Element of ( NAT ));
assume L131: S9[ C170 ];
L132: ( ( power C166 ) . (( C167 * C168 ) , ( C170 + 1 )) ) = ( ( ( ( power C166 ) . (C167 , C170) ) * ( ( power C166 ) . (C168 , C170) ) ) * ( C167 * C168 ) ) by L131 , GROUP_1:def 7
.= ( ( ( ( ( power C166 ) . (C167 , C170) ) * ( ( power C166 ) . (C168 , C170) ) ) * C167 ) * C168 ) by GROUP_1:def 3
.= ( ( ( ( ( power C166 ) . (C167 , C170) ) * C167 ) * ( ( power C166 ) . (C168 , C170) ) ) * C168 ) by GROUP_1:def 3
.= ( ( ( ( power C166 ) . (C167 , C170) ) * C167 ) * ( ( ( power C166 ) . (C168 , C170) ) * C168 ) ) by GROUP_1:def 3
.= ( ( ( power C166 ) . (C167 , ( C170 + 1 )) ) * ( ( ( power C166 ) . (C168 , C170) ) * C168 ) ) by GROUP_1:def 7
.= ( ( ( power C166 ) . (C167 , ( C170 + 1 )) ) * ( ( power C166 ) . (C168 , ( C170 + 1 )) ) ) by GROUP_1:def 7;
thus L133: S9[ ( C170 + 1 ) ] by L132;
end;
L134: ( ( power C166 ) . (( C167 * C168 ) , ( 0 )) ) = ( 1_ C166 ) by GROUP_1:def 7
.= ( ( 1_ C166 ) * ( 1_ C166 ) ) by GROUP_1:def 4
.= ( ( ( power C166 ) . (C167 , ( 0 )) ) * ( 1_ C166 ) ) by GROUP_1:def 7
.= ( ( ( power C166 ) . (C167 , ( 0 )) ) * ( ( power C166 ) . (C168 , ( 0 )) ) ) by GROUP_1:def 7;
L135: S9[ ( 0 ) ] by L134;
L136: (for B170 being (Element of ( NAT )) holds S9[ B170 ]) from NAT_1:sch 1(L135 , L130);
thus L137: thesis by L136 , L129;
end;
L138: (for B171 being  unital  associative non  empty multMagma holds (for B172 being (Element of B171) holds (for B173 , B174 being (Element of ( NAT )) holds ( B172 |^ ( B173 + B174 ) ) = ( ( B172 |^ B173 ) * ( B172 |^ B174 ) ))))
proof
let C171 being  unital  associative non  empty multMagma;
let C172 being (Element of C171);
let C173 , C174 being (Element of ( NAT ));
defpred S10[ (Element of ( NAT )) ] means ( ( power C171 ) . (C172 , ( C173 + $1 )) ) = ( ( ( power C171 ) . (C172 , C173) ) * ( ( power C171 ) . (C172 , $1) ) );
L139:
now
let C175 being (Element of ( NAT ));
assume L140: S10[ C175 ];
L141: ( ( power C171 ) . (C172 , ( C173 + ( C175 + 1 ) )) ) = ( ( power C171 ) . (C172 , ( ( C173 + C175 ) + 1 )) )
.= ( ( ( ( power C171 ) . (C172 , C173) ) * ( ( power C171 ) . (C172 , C175) ) ) * C172 ) by L140 , GROUP_1:def 7
.= ( ( ( power C171 ) . (C172 , C173) ) * ( ( ( power C171 ) . (C172 , C175) ) * C172 ) ) by GROUP_1:def 3
.= ( ( ( power C171 ) . (C172 , C173) ) * ( ( power C171 ) . (C172 , ( C175 + 1 )) ) ) by GROUP_1:def 7;
thus L142: S10[ ( C175 + 1 ) ] by L141;
end;
L143: ( ( power C171 ) . (C172 , ( C173 + ( 0 ) )) ) = ( ( ( power C171 ) . (C172 , C173) ) * ( 1_ C171 ) ) by GROUP_1:def 4
.= ( ( ( power C171 ) . (C172 , C173) ) * ( ( power C171 ) . (C172 , ( 0 )) ) ) by GROUP_1:def 7;
L144: S10[ ( 0 ) ] by L143;
L145: (for B175 being (Element of ( NAT )) holds S10[ B175 ]) from NAT_1:sch 1(L144 , L139);
thus L146: thesis by L145;
end;
theorem
L147: (for B176 being  unital  associative non  empty multMagma holds (for B177 being (Element of B176) holds (for B178 , B179 being Nat holds ( B177 |^ ( B178 + B179 ) ) = ( ( B177 |^ B178 ) * ( B177 |^ B179 ) ))))
proof
let C176 being  unital  associative non  empty multMagma;
let C177 being (Element of C176);
let C178 , C179 being Nat;
reconsider D29 = C178 , D30 = C179 as (Element of ( NAT )) by ORDINAL1:def 12;
L148: ( C177 |^ ( D29 + D30 ) ) = ( ( C177 |^ D29 ) * ( C177 |^ D30 ) ) by L138;
thus L149: thesis by L148;
end;
theorem
L150: (for B180 being  unital  associative non  empty multMagma holds (for B181 being (Element of B180) holds (for B182 , B183 being Nat holds ( ( B181 |^ B182 ) |^ B183 ) = ( B181 |^ ( B182 * B183 ) ))))
proof
let C180 being  unital  associative non  empty multMagma;
let C181 being (Element of C180);
let C182 , C183 being Nat;
L151: (C182 in ( NAT ) & C183 in ( NAT )) by ORDINAL1:def 12;
defpred S11[ (Element of ( NAT )) ] means ( ( power C180 ) . (( C181 |^ C182 ) , $1) ) = ( ( power C180 ) . (C181 , ( C182 * $1 )) );
L152:
now
let C184 being (Element of ( NAT ));
assume L153: S11[ C184 ];
L154: ( ( power C180 ) . (( C181 |^ C182 ) , ( C184 + 1 )) ) = ( ( C181 |^ ( C182 * C184 ) ) * ( C181 |^ C182 ) ) by L153 , GROUP_1:def 7
.= ( C181 |^ ( ( C182 * C184 ) + C182 ) ) by L147
.= ( ( power C180 ) . (C181 , ( C182 * ( C184 + 1 ) )) );
thus L155: S11[ ( C184 + 1 ) ] by L154;
end;
L156: ( ( power C180 ) . (( C181 |^ C182 ) , ( 0 )) ) = ( 1_ C180 ) by GROUP_1:def 7
.= ( ( power C180 ) . (C181 , ( C182 * ( 0 ) )) ) by GROUP_1:def 7;
L157: S11[ ( 0 ) ] by L156;
L158: (for B184 being (Element of ( NAT )) holds S11[ B184 ]) from NAT_1:sch 1(L157 , L152);
thus L159: thesis by L158 , L151;
end;
begin
definition
let C185 being non  empty addLoopStr;
func Nat-mult-left C185 -> (Function of [: ( NAT ) , (the carrier of C185) :] , (the carrier of C185)) means 
:L160: (for B185 being (Element of C185) holds (( it . (( 0 ) , B185) ) = ( 0. C185 ) & (for B186 being (Element of ( NAT )) holds ( it . (( B186 + 1 ) , B185) ) = ( B185 + ( it . (B186 , B185) ) ))));
existence
proof
set D31 = (the carrier of C185);
consider C186 being (Function of [: ( NAT ) , D31 :] , D31) such that L161: (for B187 being (Element of D31) holds (( C186 . (( 0 ) , B187) ) = ( 0. C185 ) & (for B188 being (Element of ( NAT )) holds ( C186 . (( B188 + 1 ) , B187) ) = ( (the addF of C185) . (B187 , ( C186 . (B188 , B187) )) )))) by L23;
take C186;
thus L162: thesis by L161;
end;
uniqueness
proof
let C187 , C188 being (Function of [: ( NAT ) , (the carrier of C185) :] , (the carrier of C185));
assume L163: (for B189 being (Element of C185) holds (( C187 . (( 0 ) , B189) ) = ( 0. C185 ) & (for B190 being (Element of ( NAT )) holds ( C187 . (( B190 + 1 ) , B189) ) = ( B189 + ( C187 . (B190 , B189) ) ))));
defpred S12[ (Element of ( NAT )) ] means (for B191 being (Element of C185) holds ( C187 . ($1 , B191) ) = ( C188 . ($1 , B191) ));
assume L164: (for B192 being (Element of C185) holds (( C188 . (( 0 ) , B192) ) = ( 0. C185 ) & (for B193 being (Element of ( NAT )) holds ( C188 . (( B193 + 1 ) , B192) ) = ( B192 + ( C188 . (B193 , B192) ) ))));
L165:
now
let C189 being (Element of ( NAT ));
assume L166: S12[ C189 ];
L167:
now
let C190 being (Element of C185);
thus L168: ( C187 . (( C189 + 1 ) , C190) ) = ( C190 + ( C187 . (C189 , C190) ) ) by L163
.= ( C190 + ( C188 . (C189 , C190) ) ) by L166
.= ( C188 . (( C189 + 1 ) , C190) ) by L164;
end;
thus L169: S12[ ( C189 + 1 ) ] by L167;
end;
L170: S12[ ( 0 ) ]
proof
let C191 being (Element of C185);
thus L171: ( C187 . (( 0 ) , C191) ) = ( 0. C185 ) by L163
.= ( C188 . (( 0 ) , C191) ) by L164;
end;
L172: (for B194 being (Element of ( NAT )) holds S12[ B194 ]) from NAT_1:sch 1(L170 , L165);
L173:
now
let C192 being set;
assume L174: C192 in [: ( NAT ) , (the carrier of C185) :];
consider C193 , C194 being set such that L175: C193 in ( NAT ) and L176: C194 in (the carrier of C185) and L177: C192 = [ C193 , C194 ] by L174 , ZFMISC_1:def 2;
reconsider D32 = C194 as (Element of C185) by L176;
reconsider D33 = C193 as (Element of ( NAT )) by L175;
thus L178: ( C187 . C192 ) = ( C187 . (D33 , D32) ) by L177
.= ( C188 . (D33 , D32) ) by L172
.= ( C188 . C192 ) by L177;
end;
L179: (( dom C187 ) = [: ( NAT ) , (the carrier of C185) :] & ( dom C188 ) = [: ( NAT ) , (the carrier of C185) :]) by FUNCT_2:def 1;
thus L180: thesis by L179 , L173 , FUNCT_1:2;
end;
func Nat-mult-right C185 -> (Function of [: (the carrier of C185) , ( NAT ) :] , (the carrier of C185)) means 
:L181: (for B195 being (Element of C185) holds (( it . (B195 , ( 0 )) ) = ( 0. C185 ) & (for B196 being (Element of ( NAT )) holds ( it . (B195 , ( B196 + 1 )) ) = ( ( it . (B195 , B196) ) + B195 ))));
existence
proof
consider C195 being (Function of [: (the carrier of C185) , ( NAT ) :] , (the carrier of C185)) such that L182: (for B197 being (Element of C185) holds (( C195 . (B197 , ( 0 )) ) = ( 0. C185 ) & (for B198 being (Element of ( NAT )) holds ( C195 . (B197 , ( B198 + 1 )) ) = ( (the addF of C185) . (( C195 . (B197 , B198) ) , B197) )))) by L25;
take C195;
thus L183: thesis by L182;
end;
uniqueness
proof
let C196 , C197 being (Function of [: (the carrier of C185) , ( NAT ) :] , (the carrier of C185));
assume L184: (for B199 being (Element of C185) holds (( C196 . (B199 , ( 0 )) ) = ( 0. C185 ) & (for B200 being (Element of ( NAT )) holds ( C196 . (B199 , ( B200 + 1 )) ) = ( ( C196 . (B199 , B200) ) + B199 ))));
defpred S13[ (Element of ( NAT )) ] means (for B201 being (Element of C185) holds ( C196 . (B201 , $1) ) = ( C197 . (B201 , $1) ));
assume L185: (for B202 being (Element of C185) holds (( C197 . (B202 , ( 0 )) ) = ( 0. C185 ) & (for B203 being (Element of ( NAT )) holds ( C197 . (B202 , ( B203 + 1 )) ) = ( ( C197 . (B202 , B203) ) + B202 ))));
L186:
now
let C198 being (Element of ( NAT ));
assume L187: S13[ C198 ];
L188:
now
let C199 being (Element of C185);
thus L189: ( C196 . (C199 , ( C198 + 1 )) ) = ( ( C196 . (C199 , C198) ) + C199 ) by L184
.= ( ( C197 . (C199 , C198) ) + C199 ) by L187
.= ( C197 . (C199 , ( C198 + 1 )) ) by L185;
end;
thus L190: S13[ ( C198 + 1 ) ] by L188;
end;
L191: S13[ ( 0 ) ]
proof
let C200 being (Element of C185);
thus L192: ( C196 . (C200 , ( 0 )) ) = ( 0. C185 ) by L184
.= ( C197 . (C200 , ( 0 )) ) by L185;
end;
L193: (for B204 being (Element of ( NAT )) holds S13[ B204 ]) from NAT_1:sch 1(L191 , L186);
L194:
now
let C201 being set;
assume L195: C201 in [: (the carrier of C185) , ( NAT ) :];
consider C202 , C203 being set such that L196: C202 in (the carrier of C185) and L197: C203 in ( NAT ) and L198: C201 = [ C202 , C203 ] by L195 , ZFMISC_1:def 2;
reconsider D34 = C202 as (Element of C185) by L196;
reconsider D35 = C203 as (Element of ( NAT )) by L197;
thus L199: ( C196 . C201 ) = ( C196 . (D34 , D35) ) by L198
.= ( C197 . (D34 , D35) ) by L193
.= ( C197 . C201 ) by L198;
end;
L200: (( dom C196 ) = [: (the carrier of C185) , ( NAT ) :] & ( dom C197 ) = [: (the carrier of C185) , ( NAT ) :]) by FUNCT_2:def 1;
thus L201: thesis by L200 , L194 , FUNCT_1:2;
end;
end;
definition
let C204 being non  empty addLoopStr;
let C205 being (Element of C204);
let C206 being (Element of ( NAT ));
func C206 * C205 -> (Element of C204) equals 
( ( Nat-mult-left C204 ) . (C206 , C205) );
coherence;
func C205 * C206 -> (Element of C204) equals 
( ( Nat-mult-right C204 ) . (C205 , C206) );
coherence;
end;
theorem
L204: (for B205 being non  empty addLoopStr holds (for B206 being (Element of B205) holds (( ( 0 ) * B206 ) = ( 0. B205 ) & ( B206 * ( 0 ) ) = ( 0. B205 )))) by L160 , L181;
theorem
L205: (for B207 being  right_zeroed non  empty addLoopStr holds (for B208 being (Element of B207) holds ( 1 * B208 ) = B208))
proof
let C207 being  right_zeroed non  empty addLoopStr;
let C208 being (Element of C207);
thus L206: ( 1 * C208 ) = ( ( Nat-mult-left C207 ) . (( ( 0 ) + 1 ) , C208) )
.= ( C208 + ( ( Nat-mult-left C207 ) . (( 0 ) , C208) ) ) by L160
.= ( C208 + ( 0. C207 ) ) by L160
.= C208 by RLVECT_1:def 4;
end;
theorem
L207: (for B209 being  left_zeroed non  empty addLoopStr holds (for B210 being (Element of B209) holds ( B210 * 1 ) = B210))
proof
let C209 being  left_zeroed non  empty addLoopStr;
let C210 being (Element of C209);
thus L208: ( C210 * 1 ) = ( ( Nat-mult-right C209 ) . (C210 , ( ( 0 ) + 1 )) )
.= ( ( ( Nat-mult-right C209 ) . (C210 , ( 0 )) ) + C210 ) by L181
.= ( ( 0. C209 ) + C210 ) by L181
.= C210 by ALGSTR_1:def 2;
end;
theorem
L209: (for B211 being  left_zeroed  add-associative non  empty addLoopStr holds (for B212 being (Element of B211) holds (for B213 , B214 being (Element of ( NAT )) holds ( ( B213 + B214 ) * B212 ) = ( ( B213 * B212 ) + ( B214 * B212 ) ))))
proof
let C211 being  left_zeroed  add-associative non  empty addLoopStr;
let C212 being (Element of C211);
let C213 , C214 being (Element of ( NAT ));
defpred S14[ (Element of ( NAT )) ] means ( ( $1 + C214 ) * C212 ) = ( ( $1 * C212 ) + ( C214 * C212 ) );
L210:
now
let C215 being (Element of ( NAT ));
assume L211: S14[ C215 ];
L212: ( ( ( C215 + 1 ) + C214 ) * C212 ) = ( ( ( C215 + C214 ) + 1 ) * C212 )
.= ( C212 + ( ( C215 * C212 ) + ( C214 * C212 ) ) ) by L211 , L160
.= ( ( C212 + ( C215 * C212 ) ) + ( C214 * C212 ) ) by RLVECT_1:def 3
.= ( ( ( C215 + 1 ) * C212 ) + ( C214 * C212 ) ) by L160;
thus L213: S14[ ( C215 + 1 ) ] by L212;
end;
L214: ( ( ( 0 ) + C214 ) * C212 ) = ( ( 0. C211 ) + ( C214 * C212 ) ) by ALGSTR_1:def 2
.= ( ( ( 0 ) * C212 ) + ( C214 * C212 ) ) by L160;
L215: S14[ ( 0 ) ] by L214;
L216: (for B215 being (Element of ( NAT )) holds S14[ B215 ]) from NAT_1:sch 1(L215 , L210);
thus L217: thesis by L216;
end;
theorem
L218: (for B216 being  right_zeroed  add-associative non  empty addLoopStr holds (for B217 being (Element of B216) holds (for B218 , B219 being (Element of ( NAT )) holds ( B217 * ( B218 + B219 ) ) = ( ( B217 * B218 ) + ( B217 * B219 ) ))))
proof
let C216 being  right_zeroed  add-associative non  empty addLoopStr;
let C217 being (Element of C216);
let C218 , C219 being (Element of ( NAT ));
defpred S15[ (Element of ( NAT )) ] means ( C217 * ( C218 + $1 ) ) = ( ( C217 * C218 ) + ( C217 * $1 ) );
L219:
now
let C220 being (Element of ( NAT ));
assume L220: S15[ C220 ];
L221: ( C217 * ( C218 + ( C220 + 1 ) ) ) = ( C217 * ( ( C218 + C220 ) + 1 ) )
.= ( ( ( C217 * C218 ) + ( C217 * C220 ) ) + C217 ) by L220 , L181
.= ( ( C217 * C218 ) + ( ( C217 * C220 ) + C217 ) ) by RLVECT_1:def 3
.= ( ( C217 * C218 ) + ( C217 * ( C220 + 1 ) ) ) by L181;
thus L222: S15[ ( C220 + 1 ) ] by L221;
end;
L223: ( C217 * ( C218 + ( 0 ) ) ) = ( ( C217 * C218 ) + ( 0. C216 ) ) by RLVECT_1:def 4
.= ( ( C217 * C218 ) + ( C217 * ( 0 ) ) ) by L181;
L224: S15[ ( 0 ) ] by L223;
L225: (for B220 being (Element of ( NAT )) holds S15[ B220 ]) from NAT_1:sch 1(L224 , L219);
thus L226: thesis by L225;
end;
theorem
L227: (for B221 being  left_zeroed  right_zeroed  add-associative non  empty addLoopStr holds (for B222 being (Element of B221) holds (for B223 being (Element of ( NAT )) holds ( B223 * B222 ) = ( B222 * B223 ))))
proof
let C221 being  left_zeroed  right_zeroed  add-associative non  empty addLoopStr;
let C222 being (Element of C221);
let C223 being (Element of ( NAT ));
defpred S16[ (Element of ( NAT )) ] means ( $1 * C222 ) = ( C222 * $1 );
L228:
now
let C224 being (Element of ( NAT ));
assume L229: S16[ C224 ];
L230: ( ( C224 + 1 ) * C222 ) = ( ( C224 * C222 ) + ( 1 * C222 ) ) by L209
.= ( ( C224 * C222 ) + C222 ) by L205
.= ( ( C222 * C224 ) + ( C222 * 1 ) ) by L229 , L207
.= ( C222 * ( C224 + 1 ) ) by L218;
thus L231: S16[ ( C224 + 1 ) ] by L230;
end;
L232: ( ( 0 ) * C222 ) = ( 0. C221 ) by L160
.= ( C222 * ( 0 ) ) by L181;
L233: S16[ ( 0 ) ] by L232;
L234: (for B224 being (Element of ( NAT )) holds S16[ B224 ]) from NAT_1:sch 1(L233 , L228);
thus L235: thesis by L234;
end;
theorem
L236: (for B225 being  Abelian non  empty addLoopStr holds (for B226 being (Element of B225) holds (for B227 being (Element of ( NAT )) holds ( B227 * B226 ) = ( B226 * B227 ))))
proof
let C225 being  Abelian non  empty addLoopStr;
let C226 being (Element of C225);
let C227 being (Element of ( NAT ));
defpred S17[ (Element of ( NAT )) ] means ( $1 * C226 ) = ( C226 * $1 );
L237:
now
let C228 being (Element of ( NAT ));
assume L238: S17[ C228 ];
L239: ( ( C228 + 1 ) * C226 ) = ( C226 + ( C226 * C228 ) ) by L238 , L160
.= ( C226 * ( C228 + 1 ) ) by L181;
thus L240: S17[ ( C228 + 1 ) ] by L239;
end;
L241: ( ( 0 ) * C226 ) = ( 0. C225 ) by L160
.= ( C226 * ( 0 ) ) by L181;
L242: S17[ ( 0 ) ] by L241;
L243: (for B228 being (Element of ( NAT )) holds S17[ B228 ]) from NAT_1:sch 1(L242 , L237);
thus L244: thesis by L243;
end;
theorem
L245: (for B229 being  left_zeroed  right_zeroed  left_add-cancelable  add-associative  left-distributive non  empty doubleLoopStr holds (for B230 , B231 being (Element of B229) holds (for B232 being (Element of ( NAT )) holds ( ( B232 * B230 ) * B231 ) = ( B232 * ( B230 * B231 ) ))))
proof
let C229 being  left_zeroed  right_zeroed  left_add-cancelable  add-associative  left-distributive non  empty doubleLoopStr;
let C230 , C231 being (Element of C229);
let C232 being (Element of ( NAT ));
defpred S18[ (Element of ( NAT )) ] means ( ( $1 * C230 ) * C231 ) = ( $1 * ( C230 * C231 ) );
L246:
now
let C233 being (Element of ( NAT ));
assume L247: S18[ C233 ];
L248: ( ( ( C233 + 1 ) * C230 ) * C231 ) = ( ( C230 + ( C233 * C230 ) ) * C231 ) by L160
.= ( ( C230 * C231 ) + ( C233 * ( C230 * C231 ) ) ) by L247 , VECTSP_1:def 3
.= ( ( 1 * ( C230 * C231 ) ) + ( C233 * ( C230 * C231 ) ) ) by L205
.= ( ( C233 + 1 ) * ( C230 * C231 ) ) by L209;
thus L249: S18[ ( C233 + 1 ) ] by L248;
end;
L250: ( ( ( 0 ) * C230 ) * C231 ) = ( ( 0. C229 ) * C231 ) by L160
.= ( 0. C229 ) by L15
.= ( ( 0 ) * ( C230 * C231 ) ) by L160;
L251: S18[ ( 0 ) ] by L250;
L252: (for B233 being (Element of ( NAT )) holds S18[ B233 ]) from NAT_1:sch 1(L251 , L246);
thus L253: thesis by L252;
end;
theorem
L254: (for B234 being  left_zeroed  right_zeroed  right_add-cancelable  add-associative  distributive non  empty doubleLoopStr holds (for B235 , B236 being (Element of B234) holds (for B237 being (Element of ( NAT )) holds ( B236 * ( B237 * B235 ) ) = ( ( B236 * B235 ) * B237 ))))
proof
let C234 being  left_zeroed  right_zeroed  add-associative  right_add-cancelable  distributive non  empty doubleLoopStr;
let C235 , C236 being (Element of C234);
let C237 being (Element of ( NAT ));
defpred S19[ (Element of ( NAT )) ] means ( C236 * ( $1 * C235 ) ) = ( ( C236 * C235 ) * $1 );
L255:
now
let C238 being (Element of ( NAT ));
assume L256: S19[ C238 ];
L257: ( C236 * ( ( C238 + 1 ) * C235 ) ) = ( C236 * ( C235 + ( C238 * C235 ) ) ) by L160
.= ( ( C236 * C235 ) + ( ( C236 * C235 ) * C238 ) ) by L256 , VECTSP_1:def 2
.= ( ( ( C236 * C235 ) * 1 ) + ( ( C236 * C235 ) * C238 ) ) by L207
.= ( ( C236 * C235 ) * ( C238 + 1 ) ) by L218;
thus L258: S19[ ( C238 + 1 ) ] by L257;
end;
L259: ( C236 * ( ( 0 ) * C235 ) ) = ( C236 * ( 0. C234 ) ) by L160
.= ( 0. C234 ) by L19
.= ( ( C236 * C235 ) * ( 0 ) ) by L181;
L260: S19[ ( 0 ) ] by L259;
L261: (for B238 being (Element of ( NAT )) holds S19[ B238 ]) from NAT_1:sch 1(L260 , L255);
thus L262: thesis by L261;
end;
theorem
L263: (for B239 being  left_zeroed  right_zeroed  add-associative  add-cancelable  distributive non  empty doubleLoopStr holds (for B240 , B241 being (Element of B239) holds (for B242 being (Element of ( NAT )) holds ( ( B240 * B242 ) * B241 ) = ( B240 * ( B242 * B241 ) ))))
proof
let C239 being  left_zeroed  right_zeroed  distributive  add-cancelable  add-associative non  empty doubleLoopStr;
let C240 , C241 being (Element of C239);
let C242 being (Element of ( NAT ));
thus L264: ( ( C240 * C242 ) * C241 ) = ( ( C242 * C240 ) * C241 ) by L227
.= ( C242 * ( C240 * C241 ) ) by L245
.= ( ( C240 * C241 ) * C242 ) by L227
.= ( C240 * ( C242 * C241 ) ) by L254;
end;
begin
definition
let C243 , C244 being (Element of ( NAT ));
redefine func C244 choose C243 -> (Element of ( NAT ));

coherence by NEWTON:25;
end;
definition
let C245 being  unital non  empty doubleLoopStr;
let C246 , C247 being (Element of C245);
let C248 being (Element of ( NAT ));
func (C246 , C247) In_Power C248 -> (FinSequence of (the carrier of C245)) means 
:L266: (( len it ) = ( C248 + 1 ) & (for B243 , B244 , B245 being (Element of ( NAT )) holds ((B243 in ( dom it ) & B245 = ( B243 - 1 ) & B244 = ( C248 - B245 )) implies ( it /. B243 ) = ( ( ( C248 choose B245 ) * ( C246 |^ B244 ) ) * ( C247 |^ B245 ) ))));
existence
proof
defpred S20[ (Element of ( NAT )) , (Element of C245) ] means (for B246 , B247 being (Element of ( NAT )) holds ((B247 = ( $1 - 1 ) & B246 = ( C248 - B247 )) implies $2 = ( ( ( C248 choose B247 ) * ( C246 |^ B246 ) ) * ( C247 |^ B247 ) )));
L267: (for B248 being (Element of ( NAT )) holds (B248 in ( Seg ( C248 + 1 ) ) implies (ex B249 being (Element of C245) st S20[ B248 , B249 ])))
proof
let C249 being (Element of ( NAT ));
assume L268: C249 in ( Seg ( C248 + 1 ) );
L269: C249 >= 1 by L268 , FINSEQ_1:1;
reconsider D36 = ( C249 - 1 ) as (Element of ( NAT )) by L269 , INT_1:5;
L270: C249 <= ( C248 + 1 ) by L268 , FINSEQ_1:1;
L271: ( C249 - 1 ) <= ( ( C248 + 1 ) - 1 ) by L270 , XREAL_1:9;
reconsider D37 = ( C248 - D36 ) as (Element of ( NAT )) by L271 , INT_1:5;
reconsider D38 = ( ( ( C248 choose D36 ) * ( C246 |^ D37 ) ) * ( C247 |^ D36 ) ) as (Element of C245);
take D38;
thus L272: thesis;
end;
consider C250 being (FinSequence of (the carrier of C245)) such that L273: (( dom C250 ) = ( Seg ( C248 + 1 ) ) & (for B250 being (Element of ( NAT )) holds (B250 in ( Seg ( C248 + 1 ) ) implies S20[ B250 , ( C250 /. B250 ) ]))) from RECDEF_1:sch 17(L267);
take C250;
thus L274: thesis by L273 , FINSEQ_1:def 3;
end;
uniqueness
proof
let C251 , C252 being (FinSequence of (the carrier of C245));
assume that
L275: ( len C251 ) = ( C248 + 1 )
and
L276: (for B251 , B252 , B253 being (Element of ( NAT )) holds ((B251 in ( dom C251 ) & B253 = ( B251 - 1 ) & B252 = ( C248 - B253 )) implies ( C251 /. B251 ) = ( ( ( C248 choose B253 ) * ( C246 |^ B252 ) ) * ( C247 |^ B253 ) )));
assume that
L277: ( len C252 ) = ( C248 + 1 )
and
L278: (for B254 , B255 , B256 being (Element of ( NAT )) holds ((B254 in ( dom C252 ) & B256 = ( B254 - 1 ) & B255 = ( C248 - B256 )) implies ( C252 /. B254 ) = ( ( ( C248 choose B256 ) * ( C246 |^ B255 ) ) * ( C247 |^ B256 ) )));
L279: (for B257 being Nat holds ((1 <= B257 & B257 <= ( len C251 )) implies ( C251 . B257 ) = ( C252 . B257 )))
proof
let C253 being Nat;
assume that
L280: 1 <= C253
and
L281: C253 <= ( len C251 );
reconsider D39 = ( C253 - 1 ) as (Element of ( NAT )) by L280 , INT_1:5;
L282: ( C253 - 1 ) <= ( ( C248 + 1 ) - 1 ) by L275 , L281 , XREAL_1:9;
reconsider D40 = ( C248 - D39 ) as (Element of ( NAT )) by L282 , INT_1:5;
L283: C253 in ( Seg ( C248 + 1 ) ) by L275 , L280 , L281 , FINSEQ_1:1;
L284: C253 in ( dom C251 ) by L283 , L275 , FINSEQ_1:def 3;
L285: C253 in ( dom C252 ) by L277 , L283 , FINSEQ_1:def 3;
thus L286: ( C252 . C253 ) = ( C252 /. C253 ) by L285 , PARTFUN1:def 6
.= ( ( ( C248 choose D39 ) * ( C246 |^ D40 ) ) * ( C247 |^ D39 ) ) by L278 , L285
.= ( C251 /. C253 ) by L276 , L284
.= ( C251 . C253 ) by L284 , PARTFUN1:def 6;
end;
thus L287: C251 = C252 by L279 , L275 , L277 , FINSEQ_1:14;
end;
end;
theorem
L289: (for B258 being  right_zeroed  unital non  empty doubleLoopStr holds (for B259 , B260 being (Element of B258) holds ( (B259 , B260) In_Power ( 0 ) ) = <* ( 1_ B258 ) *>))
proof
let C254 being  right_zeroed  unital non  empty doubleLoopStr;
let C255 , C256 being (Element of C254);
set D41 = ( (C255 , C256) In_Power ( 0 ) );
L290: ( len D41 ) = ( ( 0 ) + 1 ) by L266
.= 1;
L291: ( dom D41 ) = { 1 } by L290 , FINSEQ_1:2 , FINSEQ_1:def 3;
L292: 1 in ( dom D41 ) by L291 , TARSKI:def 1;
consider C257 being (Element of ( NAT )) such that L293: C257 in ( dom D41 ) by L292;
L294: C257 = 1 by L291 , L293 , TARSKI:def 1;
reconsider D42 = ( C257 - 1 ) as (Element of ( NAT )) by L294 , INT_1:5;
reconsider D43 = ( ( 0 ) - D42 ) as (Element of ( NAT )) by L294;
L295: ( D41 . 1 ) = ( D41 /. 1 ) by L292 , PARTFUN1:def 6
.= ( ( ( ( 0 ) choose D42 ) * ( C255 |^ D43 ) ) * ( C256 |^ D42 ) ) by L292 , L294 , L266
.= ( ( 1 * ( C255 |^ D43 ) ) * ( C256 |^ D42 ) ) by L294 , NEWTON:19
.= ( ( 1 * ( C255 |^ ( 0 ) ) ) * ( 1_ C254 ) ) by L294 , L123
.= ( ( 1 * ( 1_ C254 ) ) * ( 1_ C254 ) ) by L123
.= ( ( 1_ C254 ) * ( 1_ C254 ) ) by L205
.= ( 1_ C254 ) by GROUP_1:def 4;
thus L296: thesis by L295 , L290 , FINSEQ_1:40;
end;
theorem
L297: (for B261 being  right_zeroed  unital non  empty doubleLoopStr holds (for B262 , B263 being (Element of B261) holds (for B264 being (Element of ( NAT )) holds ( ( (B262 , B263) In_Power B264 ) . 1 ) = ( B262 |^ B264 ))))
proof
reconsider D44 = ( 1 - 1 ) as (Element of ( NAT )) by NEWTON:19;
let C258 being  right_zeroed  unital non  empty doubleLoopStr;
let C259 , C260 being (Element of C258);
let C261 being (Element of ( NAT ));
reconsider D45 = ( C261 - D44 ) as (Element of ( NAT ));
L298: ( len ( (C259 , C260) In_Power C261 ) ) = ( C261 + 1 ) by L266;
L299: ( dom ( (C259 , C260) In_Power C261 ) ) = ( Seg ( C261 + 1 ) ) by L298 , FINSEQ_1:def 3;
L300: ( ( 0 ) + 1 ) <= ( C261 + 1 ) by XREAL_1:6;
L301: 1 in ( dom ( (C259 , C260) In_Power C261 ) ) by L300 , L299 , FINSEQ_1:1;
thus L302: ( ( (C259 , C260) In_Power C261 ) . 1 ) = ( ( (C259 , C260) In_Power C261 ) /. 1 ) by L301 , PARTFUN1:def 6
.= ( ( ( C261 choose ( 0 ) ) * ( C259 |^ D45 ) ) * ( C260 |^ D44 ) ) by L301 , L266
.= ( ( 1 * ( C259 |^ C261 ) ) * ( C260 |^ ( 0 ) ) ) by NEWTON:19
.= ( ( C259 |^ C261 ) * ( C260 |^ ( 0 ) ) ) by L205
.= ( ( C259 |^ C261 ) * ( 1_ C258 ) ) by L123
.= ( C259 |^ C261 ) by GROUP_1:def 4;
end;
theorem
L303: (for B265 being  right_zeroed  unital non  empty doubleLoopStr holds (for B266 , B267 being (Element of B265) holds (for B268 being (Element of ( NAT )) holds ( ( (B266 , B267) In_Power B268 ) . ( B268 + 1 ) ) = ( B267 |^ B268 ))))
proof
let C262 being  right_zeroed  unital non  empty doubleLoopStr;
let C263 , C264 being (Element of C262);
let C265 being (Element of ( NAT ));
reconsider D46 = ( ( C265 + 1 ) - 1 ) as (Element of ( NAT ));
reconsider D47 = ( C265 - D46 ) as (Element of ( NAT )) by INT_1:5;
L304: ( len ( (C263 , C264) In_Power C265 ) ) = ( C265 + 1 ) by L266;
L305: ( dom ( (C263 , C264) In_Power C265 ) ) = ( Seg ( C265 + 1 ) ) by L304 , FINSEQ_1:def 3;
L306: (D47 = ( 0 ) & ( C265 + 1 ) in ( dom ( (C263 , C264) In_Power C265 ) )) by L305 , FINSEQ_1:4;
thus L307: ( ( (C263 , C264) In_Power C265 ) . ( C265 + 1 ) ) = ( ( (C263 , C264) In_Power C265 ) /. ( C265 + 1 ) ) by L305 , FINSEQ_1:4 , PARTFUN1:def 6
.= ( ( ( C265 choose C265 ) * ( C263 |^ ( 0 ) ) ) * ( C264 |^ C265 ) ) by L306 , L266
.= ( ( 1 * ( C263 |^ ( 0 ) ) ) * ( C264 |^ C265 ) ) by NEWTON:21
.= ( ( 1 * ( 1_ C262 ) ) * ( C264 |^ C265 ) ) by L123
.= ( ( 1_ C262 ) * ( C264 |^ C265 ) ) by L205
.= ( C264 |^ C265 ) by GROUP_1:def 4;
end;
::$N Binomial Theorem
theorem
L308: (for B269 being  Abelian  add-associative  left_zeroed  right_zeroed  commutative  associative  add-cancelable  distributive  unital non  empty doubleLoopStr holds (for B270 , B271 being (Element of B269) holds (for B272 being (Element of ( NAT )) holds ( ( B270 + B271 ) |^ B272 ) = ( Sum ( (B270 , B271) In_Power B272 ) ))))
proof
let C266 being  add-associative  left_zeroed  right_zeroed  distributive  associative  Abelian  add-cancelable  commutative  unital non  empty doubleLoopStr;
let C267 , C268 being (Element of C266);
let C269 being (Element of ( NAT ));
defpred S21[ (Element of ( NAT )) ] means ( ( C267 + C268 ) |^ $1 ) = ( Sum ( (C267 , C268) In_Power $1 ) );
L309: (for B273 being (Element of ( NAT )) holds (S21[ B273 ] implies S21[ ( B273 + 1 ) ]))
proof
let C270 being (Element of ( NAT ));
set D48 = ( ( ( (C267 , C268) In_Power C270 ) * C267 ) ^ <* ( 0. C266 ) *> );
set D49 = ( <* ( 0. C266 ) *> ^ ( ( (C267 , C268) In_Power C270 ) * C268 ) );
L310: ( Seg ( len ( ( (C267 , C268) In_Power C270 ) * C267 ) ) ) = ( dom ( ( (C267 , C268) In_Power C270 ) * C267 ) ) by FINSEQ_1:def 3
.= ( dom ( (C267 , C268) In_Power C270 ) ) by POLYNOM1:def 2
.= ( Seg ( len ( (C267 , C268) In_Power C270 ) ) ) by FINSEQ_1:def 3;
L311: ( len D48 ) = ( ( len ( ( (C267 , C268) In_Power C270 ) * C267 ) ) + ( len <* ( 0. C266 ) *> ) ) by FINSEQ_1:22
.= ( ( len ( ( (C267 , C268) In_Power C270 ) * C267 ) ) + 1 ) by FINSEQ_1:40
.= ( ( len ( (C267 , C268) In_Power C270 ) ) + 1 ) by L310 , FINSEQ_1:6
.= ( ( C270 + 1 ) + 1 ) by L266;
reconsider D50 = D48 as (Element of ( ( ( C270 + 1 ) + 1 ) -tuples_on (the carrier of C266) )) by L311 , FINSEQ_2:92;
L312: ( Seg ( len ( ( (C267 , C268) In_Power C270 ) * C268 ) ) ) = ( dom ( ( (C267 , C268) In_Power C270 ) * C268 ) ) by FINSEQ_1:def 3
.= ( dom ( (C267 , C268) In_Power C270 ) ) by POLYNOM1:def 2
.= ( Seg ( len ( (C267 , C268) In_Power C270 ) ) ) by FINSEQ_1:def 3;
L313: ( len D49 ) = ( ( len ( ( (C267 , C268) In_Power C270 ) * C268 ) ) + ( len <* ( 0. C266 ) *> ) ) by FINSEQ_1:22
.= ( ( len ( ( (C267 , C268) In_Power C270 ) * C268 ) ) + 1 ) by FINSEQ_1:40
.= ( ( len ( (C267 , C268) In_Power C270 ) ) + 1 ) by L312 , FINSEQ_1:6
.= ( ( C270 + 1 ) + 1 ) by L266;
reconsider D51 = D49 as (Element of ( ( ( C270 + 1 ) + 1 ) -tuples_on (the carrier of C266) )) by L313 , FINSEQ_2:92;
L314: ( len D50 ) = ( ( C270 + 1 ) + 1 ) by CARD_1:def 7;
set D52 = ( D50 + D51 );
L315: ( len D51 ) = ( ( C270 + 1 ) + 1 ) by CARD_1:def 7;
L316: ( Seg ( len D52 ) ) = ( dom D52 ) by FINSEQ_1:def 3
.= ( dom D50 ) by L74
.= ( Seg ( len D50 ) ) by FINSEQ_1:def 3;
L317: ( len D52 ) = ( ( C270 + 1 ) + 1 ) by L316 , L314 , FINSEQ_1:6;
L318: (for B274 being Nat holds ((1 <= B274 & B274 <= ( len ( (C267 , C268) In_Power ( C270 + 1 ) ) )) implies ( D52 . B274 ) = ( ( (C267 , C268) In_Power ( C270 + 1 ) ) . B274 )))
proof
let C271 being Nat;
assume that
L319: 1 <= C271
and
L320: C271 <= ( len ( (C267 , C268) In_Power ( C270 + 1 ) ) );
L321: ( len ( (C267 , C268) In_Power ( C270 + 1 ) ) ) = ( ( C270 + 1 ) + 1 ) by L266;
L322: ( dom ( (C267 , C268) In_Power ( C270 + 1 ) ) ) = ( Seg ( ( C270 + 1 ) + 1 ) ) by L321 , FINSEQ_1:def 3;
L323: C271 in ( dom ( (C267 , C268) In_Power ( C270 + 1 ) ) ) by L322 , L319 , L320 , L321 , FINSEQ_1:1;
reconsider D53 = ( C271 - 1 ) as (Element of ( NAT )) by L319 , INT_1:5;
set D54 = ( ( (C267 , C268) In_Power C270 ) /. D53 );
set D55 = ( D50 /. C271 );
set D56 = ( D51 /. C271 );
set D57 = ( ( (C267 , C268) In_Power C270 ) /. C271 );
L324: C271 = ( D53 + 1 );
L325: C271 in ( Seg ( ( C270 + 1 ) + 1 ) ) by L319 , L320 , L321 , FINSEQ_1:1;
L326: C271 in ( dom D50 ) by L325 , L314 , FINSEQ_1:def 3;
L327: C271 in ( dom D51 ) by L315 , L325 , FINSEQ_1:def 3;
L328: C271 <= ( len ( D50 + D51 ) ) by L317 , L320 , L266;
L329: (C271 in { ( ( C270 + 1 ) + 1 ) } implies ( D52 . C271 ) = ( ( (C267 , C268) In_Power ( C270 + 1 ) ) . C271 ))
proof
assume L330: C271 in { ( ( C270 + 1 ) + 1 ) };
L331: C271 = ( ( C270 + 1 ) + 1 ) by L330 , TARSKI:def 1;
L332: ( C270 + 1 ) = ( len ( (C267 , C268) In_Power C270 ) ) by L266
.= ( len ( ( (C267 , C268) In_Power C270 ) * C267 ) ) by L310 , FINSEQ_1:6;
L333: D55 = ( ( ( ( (C267 , C268) In_Power C270 ) * C267 ) ^ <* ( 0. C266 ) *> ) . ( ( len ( ( (C267 , C268) In_Power C270 ) * C267 ) ) + 1 ) ) by L332 , L326 , L331 , PARTFUN1:def 6
.= ( 0. C266 ) by FINSEQ_1:42;
L334: D53 = ( ( ( C270 + 1 ) + 1 ) - 1 ) by L330 , TARSKI:def 1
.= ( C270 + 1 );
L335: ( C270 + 1 ) in ( Seg ( C270 + 1 ) ) by FINSEQ_1:4;
L336: D53 in ( Seg ( len ( (C267 , C268) In_Power C270 ) ) ) by L335 , L334 , L266;
L337: D53 in ( dom ( ( (C267 , C268) In_Power C270 ) * C268 ) ) by L336 , L312 , FINSEQ_1:def 3;
L338: D53 in ( dom ( (C267 , C268) In_Power C270 ) ) by L336 , FINSEQ_1:def 3;
L339: D54 = ( ( (C267 , C268) In_Power C270 ) . ( C270 + 1 ) ) by L338 , L334 , PARTFUN1:def 6
.= ( C268 |^ C270 ) by L303;
L340: D56 = ( ( <* ( 0. C266 ) *> ^ ( ( (C267 , C268) In_Power C270 ) * C268 ) ) . ( 1 + ( C270 + 1 ) ) ) by L327 , L331 , PARTFUN1:def 6
.= ( ( <* ( 0. C266 ) *> ^ ( ( (C267 , C268) In_Power C270 ) * C268 ) ) . ( ( len <* ( 0. C266 ) *> ) + D53 ) ) by L334 , FINSEQ_1:39
.= ( ( ( (C267 , C268) In_Power C270 ) * C268 ) . D53 ) by L337 , FINSEQ_1:def 7
.= ( ( ( (C267 , C268) In_Power C270 ) * C268 ) /. D53 ) by L337 , PARTFUN1:def 6
.= ( ( C268 |^ C270 ) * C268 ) by L338 , L339 , POLYNOM1:def 2
.= ( C268 |^ ( C270 + 1 ) ) by GROUP_1:def 7;
L341: ( dom D52 ) = ( Seg ( ( C270 + 1 ) + 1 ) ) by L314 , L316 , FINSEQ_1:def 3;
L342: C271 in ( dom D52 ) by L341 , L319 , L331 , FINSEQ_1:1;
thus L343: ( D52 . C271 ) = ( D52 /. C271 ) by L342 , PARTFUN1:def 6
.= ( ( 0. C266 ) + D56 ) by L319 , L328 , L333 , L74
.= ( C268 |^ ( C270 + 1 ) ) by L340 , ALGSTR_1:def 2
.= ( ( (C267 , C268) In_Power ( C270 + 1 ) ) . C271 ) by L331 , L303;
end;
L344: C271 in ( dom D52 ) by L314 , L316 , L325 , FINSEQ_1:def 3;
L345: (C271 in { B275 where B275 is (Element of ( NAT )) : (B275 > 1 & B275 < ( ( C270 + 1 ) + 1 )) } implies ( D52 . C271 ) = ( ( (C267 , C268) In_Power ( C270 + 1 ) ) . C271 ))
proof
assume L346: C271 in { B276 where B276 is (Element of ( NAT )) : (1 < B276 & B276 < ( ( C270 + 1 ) + 1 )) };
L347: (ex B277 being (Element of ( NAT )) st (B277 = C271 & 1 < B277 & B277 < ( ( C270 + 1 ) + 1 ))) by L346;
reconsider D58 = ( C271 - 1 ) as (Element of ( NAT )) by L347 , INT_1:5;
L348: C271 <= ( C270 + 1 ) by L347 , NAT_1:13;
L349: C271 in ( Seg ( C270 + 1 ) ) by L348 , L347 , FINSEQ_1:1;
L350: C271 in ( Seg ( len ( (C267 , C268) In_Power C270 ) ) ) by L349 , L266;
L351: C271 in ( dom ( (C267 , C268) In_Power C270 ) ) by L350 , FINSEQ_1:def 3;
L352: 1 <= D53 by L324 , L347 , NAT_1:13;
reconsider D59 = ( D53 - 1 ) as (Element of ( NAT )) by L352 , INT_1:5;
L353: D53 <= ( C270 + 1 ) by L324 , L347 , XREAL_1:6;
L354: ( D53 - 1 ) <= ( ( C270 + 1 ) - 1 ) by L353 , XREAL_1:9;
reconsider D60 = ( C270 - D59 ) as (Element of ( NAT )) by L354 , INT_1:5;
L355: 1 <= D53 by L324 , L347 , NAT_1:13;
L356: D53 in ( Seg ( C270 + 1 ) ) by L355 , L353 , FINSEQ_1:1;
L357: D53 in ( Seg ( len ( (C267 , C268) In_Power C270 ) ) ) by L356 , L266;
L358: D53 in ( dom ( (C267 , C268) In_Power C270 ) ) by L357 , FINSEQ_1:def 3;
L359: D53 in ( dom ( ( (C267 , C268) In_Power C270 ) * C268 ) ) by L312 , L357 , FINSEQ_1:def 3;
L360: D53 in ( dom ( ( (C267 , C268) In_Power C270 ) * C268 ) ) by L312 , L357 , FINSEQ_1:def 3;
L361: D56 = ( ( <* ( 0. C266 ) *> ^ ( ( (C267 , C268) In_Power C270 ) * C268 ) ) . C271 ) by L327 , PARTFUN1:def 6;
L362: D56 = ( ( <* ( 0. C266 ) *> ^ ( ( (C267 , C268) In_Power C270 ) * C268 ) ) . ( ( len <* ( 0. C266 ) *> ) + D53 ) ) by L361 , L324 , FINSEQ_1:40
.= ( ( ( (C267 , C268) In_Power C270 ) * C268 ) . D53 ) by L360 , FINSEQ_1:def 7
.= ( ( ( (C267 , C268) In_Power C270 ) * C268 ) /. D53 ) by L359 , PARTFUN1:def 6
.= ( D54 * C268 ) by L358 , POLYNOM1:def 2;
L363: ( C271 - 1 ) <= ( ( C270 + 1 ) - 1 ) by L348 , XREAL_1:9;
reconsider D61 = ( C270 - D58 ) as (Element of ( NAT )) by L363 , INT_1:5;
L364: ( D61 + 1 ) = ( ( C270 + 1 ) - ( D59 + 1 ) );
L365: C271 in ( dom ( ( (C267 , C268) In_Power C270 ) * C267 ) ) by L310 , L350 , FINSEQ_1:def 3;
L366: D55 = ( ( ( ( (C267 , C268) In_Power C270 ) * C267 ) ^ <* ( 0. C266 ) *> ) . C271 ) by L326 , PARTFUN1:def 6;
L367: D55 = ( ( ( (C267 , C268) In_Power C270 ) * C267 ) . C271 ) by L366 , L365 , FINSEQ_1:def 7
.= ( ( ( (C267 , C268) In_Power C270 ) * C267 ) /. C271 ) by L365 , PARTFUN1:def 6
.= ( D57 * C267 ) by L351 , POLYNOM1:def 2;
thus L368: ( D52 . C271 ) = ( D52 /. C271 ) by L344 , PARTFUN1:def 6
.= ( ( D50 /. C271 ) + ( D54 * C268 ) ) by L319 , L328 , L362 , L74
.= ( ( ( ( ( C270 choose D58 ) * ( C267 |^ D61 ) ) * ( C268 |^ D58 ) ) * C267 ) + ( D54 * C268 ) ) by L351 , L367 , L266
.= ( ( ( ( ( C267 |^ D61 ) * ( C270 choose D58 ) ) * ( C268 |^ D58 ) ) * C267 ) + ( D54 * C268 ) ) by L227
.= ( ( C267 * ( ( C267 |^ D61 ) * ( ( C270 choose D58 ) * ( C268 |^ D58 ) ) ) ) + ( D54 * C268 ) ) by L263
.= ( ( ( C267 * ( C267 |^ D61 ) ) * ( ( C270 choose D58 ) * ( C268 |^ D58 ) ) ) + ( D54 * C268 ) ) by GROUP_1:def 3
.= ( ( ( C267 |^ ( D61 + 1 ) ) * ( ( C270 choose D58 ) * ( C268 |^ D58 ) ) ) + ( D54 * C268 ) ) by GROUP_1:def 7
.= ( ( ( C267 |^ ( D61 + 1 ) ) * ( ( C270 choose D58 ) * ( C268 |^ D58 ) ) ) + ( ( ( C268 |^ D59 ) * ( ( C270 choose D59 ) * ( C267 |^ D60 ) ) ) * C268 ) ) by L358 , L266
.= ( ( ( C267 |^ ( D61 + 1 ) ) * ( ( C270 choose D58 ) * ( C268 |^ D58 ) ) ) + ( ( ( C268 |^ D59 ) * C268 ) * ( ( C270 choose D59 ) * ( C267 |^ D60 ) ) ) ) by GROUP_1:def 3
.= ( ( ( C267 |^ ( D61 + 1 ) ) * ( ( C270 choose ( D59 + 1 ) ) * ( C268 |^ ( D59 + 1 ) ) ) ) + ( ( C268 |^ ( D59 + 1 ) ) * ( ( C270 choose D59 ) * ( C267 |^ D60 ) ) ) ) by GROUP_1:def 7
.= ( ( ( ( C268 |^ ( D59 + 1 ) ) * ( C267 |^ ( D61 + 1 ) ) ) * ( C270 choose ( D59 + 1 ) ) ) + ( ( C268 |^ ( D59 + 1 ) ) * ( ( C270 choose D59 ) * ( C267 |^ D60 ) ) ) ) by L254
.= ( ( ( C268 |^ ( D59 + 1 ) ) * ( ( C270 choose ( D59 + 1 ) ) * ( C267 |^ ( D61 + 1 ) ) ) ) + ( ( C268 |^ ( D59 + 1 ) ) * ( ( C270 choose D59 ) * ( C267 |^ D60 ) ) ) ) by L254
.= ( ( ( C268 |^ ( D59 + 1 ) ) * ( ( C267 |^ ( D61 + 1 ) ) * ( C270 choose ( D59 + 1 ) ) ) ) + ( ( C268 |^ ( D59 + 1 ) ) * ( ( C270 choose D59 ) * ( C267 |^ D60 ) ) ) ) by L227
.= ( ( ( ( C267 |^ ( D61 + 1 ) ) * ( C270 choose ( D59 + 1 ) ) ) + ( ( C270 choose D59 ) * ( C267 |^ D60 ) ) ) * ( C268 |^ ( D59 + 1 ) ) ) by VECTSP_1:def 7
.= ( ( ( ( C270 choose ( D59 + 1 ) ) * ( C267 |^ ( D61 + 1 ) ) ) + ( ( C270 choose D59 ) * ( C267 |^ ( D61 + 1 ) ) ) ) * ( C268 |^ ( D59 + 1 ) ) ) by L227
.= ( ( ( ( C270 choose ( D59 + 1 ) ) + ( C270 choose D59 ) ) * ( C267 |^ ( D61 + 1 ) ) ) * ( C268 |^ ( D59 + 1 ) ) ) by L209
.= ( ( ( ( C270 + 1 ) choose ( D59 + 1 ) ) * ( C267 |^ ( D61 + 1 ) ) ) * ( C268 |^ ( D59 + 1 ) ) ) by NEWTON:22
.= ( ( (C267 , C268) In_Power ( C270 + 1 ) ) /. C271 ) by L323 , L364 , L266
.= ( ( (C267 , C268) In_Power ( C270 + 1 ) ) . C271 ) by L323 , PARTFUN1:def 6;
end;
L369: (C271 in { 1 } implies ( D52 . C271 ) = ( ( (C267 , C268) In_Power ( C270 + 1 ) ) . C271 ))
proof
assume L370: C271 in { 1 };
L371: C271 = 1 by L370 , TARSKI:def 1;
L372: D56 = ( ( <* ( 0. C266 ) *> ^ ( ( (C267 , C268) In_Power C270 ) * C268 ) ) . 1 ) by L371 , L327 , PARTFUN1:def 6
.= ( 0. C266 ) by FINSEQ_1:41;
L373: ( C270 + 1 ) >= ( ( 0 ) + 1 ) by XREAL_1:6;
L374: 1 in ( Seg ( C270 + 1 ) ) by L373 , FINSEQ_1:1;
L375: 1 in ( Seg ( len ( (C267 , C268) In_Power C270 ) ) ) by L374 , L266;
L376: 1 in ( dom ( (C267 , C268) In_Power C270 ) ) by L375 , FINSEQ_1:def 3;
L377: D57 = ( ( (C267 , C268) In_Power C270 ) . C271 ) by L376 , L371 , PARTFUN1:def 6;
L378: 1 in ( dom ( ( (C267 , C268) In_Power C270 ) * C267 ) ) by L310 , L375 , FINSEQ_1:def 3;
L379: D55 = ( ( ( ( (C267 , C268) In_Power C270 ) * C267 ) ^ <* ( 0. C266 ) *> ) . 1 ) by L326 , L371 , PARTFUN1:def 6
.= ( ( ( (C267 , C268) In_Power C270 ) * C267 ) . 1 ) by L378 , FINSEQ_1:def 7
.= ( ( ( (C267 , C268) In_Power C270 ) * C267 ) /. 1 ) by L378 , PARTFUN1:def 6
.= ( ( ( (C267 , C268) In_Power C270 ) /. 1 ) * C267 ) by L376 , POLYNOM1:def 2
.= ( ( C267 |^ C270 ) * C267 ) by L371 , L377 , L297
.= ( C267 |^ ( C270 + 1 ) ) by GROUP_1:def 7;
thus L380: ( D52 . C271 ) = ( D52 /. C271 ) by L344 , PARTFUN1:def 6
.= ( D55 + ( D51 /. C271 ) ) by L319 , L328 , L74
.= ( C267 |^ ( C270 + 1 ) ) by L379 , L372 , RLVECT_1:def 4
.= ( ( (C267 , C268) In_Power ( C270 + 1 ) ) . C271 ) by L371 , L297;
end;
L381:
now
assume L382: C271 in ( ( { 1 } \/ { B278 where B278 is (Element of ( NAT )) : (1 < B278 & B278 < ( ( C270 + 1 ) + 1 )) } ) \/ { ( ( C270 + 1 ) + 1 ) } );
L383: (C271 in ( { 1 } \/ { B279 where B279 is (Element of ( NAT )) : (1 < B279 & B279 < ( ( C270 + 1 ) + 1 )) } ) or C271 in { ( ( C270 + 1 ) + 1 ) }) by L382 , XBOOLE_0:def 3;
thus L384: thesis by L383 , L369 , L329 , L345 , XBOOLE_0:def 3;
end;
thus L385: thesis by L381 , L322 , L323 , NAT_1:12 , NEWTON:1;
end;
assume L386: S21[ C270 ];
L387: ( ( C267 + C268 ) |^ ( C270 + 1 ) ) = ( ( Sum ( (C267 , C268) In_Power C270 ) ) * ( C267 + C268 ) ) by L386 , GROUP_1:def 7
.= ( ( ( Sum ( (C267 , C268) In_Power C270 ) ) * C267 ) + ( ( Sum ( (C267 , C268) In_Power C270 ) ) * C268 ) ) by VECTSP_1:def 2
.= ( ( Sum ( ( (C267 , C268) In_Power C270 ) * C267 ) ) + ( ( Sum ( (C267 , C268) In_Power C270 ) ) * C268 ) ) by L52
.= ( ( Sum ( ( (C267 , C268) In_Power C270 ) * C267 ) ) + ( Sum ( ( (C267 , C268) In_Power C270 ) * C268 ) ) ) by L52;
L388: ( Sum D50 ) = ( ( Sum ( ( (C267 , C268) In_Power C270 ) * C267 ) ) + ( Sum <* ( 0. C266 ) *> ) ) by RLVECT_1:41
.= ( ( Sum ( ( (C267 , C268) In_Power C270 ) * C267 ) ) + ( 0. C266 ) ) by L27
.= ( Sum ( ( (C267 , C268) In_Power C270 ) * C267 ) ) by RLVECT_1:def 4;
L389: ( Sum D51 ) = ( ( Sum <* ( 0. C266 ) *> ) + ( Sum ( ( (C267 , C268) In_Power C270 ) * C268 ) ) ) by RLVECT_1:41
.= ( ( 0. C266 ) + ( Sum ( ( (C267 , C268) In_Power C270 ) * C268 ) ) ) by L27
.= ( Sum ( ( (C267 , C268) In_Power C270 ) * C268 ) ) by ALGSTR_1:def 2;
L390: ( dom D50 ) = ( Seg ( len D50 ) ) by FINSEQ_1:def 3
.= ( dom D51 ) by L314 , L315 , FINSEQ_1:def 3;
L391: ( Sum ( D48 + D49 ) ) = ( ( Sum ( ( (C267 , C268) In_Power C270 ) * C267 ) ) + ( Sum ( ( (C267 , C268) In_Power C270 ) * C268 ) ) ) by L390 , L388 , L389 , L98;
L392: ( len ( (C267 , C268) In_Power ( C270 + 1 ) ) ) = ( len D52 ) by L317 , L266;
thus L393: thesis by L392 , L387 , L391 , L318 , FINSEQ_1:14;
end;
L394: ( ( C267 + C268 ) |^ ( 0 ) ) = ( 1_ C266 ) by L123
.= ( Sum <* ( 1_ C266 ) *> ) by L27
.= ( Sum ( (C267 , C268) In_Power ( 0 ) ) ) by L289;
L395: S21[ ( 0 ) ] by L394;
L396: (for B280 being (Element of ( NAT )) holds S21[ B280 ]) from NAT_1:sch 1(L395 , L309);
thus L397: thesis by L396;
end;
theorem
L398: (for B281 , B282 being non  empty set holds (for B283 being (Element of B282) holds (for B284 being (Function of [: B281 , B282 :] , B282) holds (ex B285 being (Function of [: ( NAT ) , B281 :] , B282) st (for B286 being (Element of B281) holds (( B285 . (( 0 ) , B286) ) = B283 & (for B287 being (Element of ( NAT )) holds ( B285 . (( B287 + 1 ) , B286) ) = ( B284 . (B286 , ( B285 . (B287 , B286) )) )))))))) by L23;
theorem
L399: (for B288 , B289 being non  empty set holds (for B290 being (Element of B289) holds (for B291 being (Function of [: B289 , B288 :] , B289) holds (ex B292 being (Function of [: B288 , ( NAT ) :] , B289) st (for B293 being (Element of B288) holds (( B292 . (B293 , ( 0 )) ) = B290 & (for B294 being (Element of ( NAT )) holds ( B292 . (B293 , ( B294 + 1 )) ) = ( B291 . (( B292 . (B293 , B294) ) , B293) )))))))) by L25;
