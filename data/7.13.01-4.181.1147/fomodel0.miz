:: Preliminaries to Classical First-order Model Theory
::  by Marco B. Caminati
::
:: Received December 29, 2010
:: Copyright (c) 2010-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, NAT_1, INT_1,
      RELAT_1, FINSEQ_1, FUNCT_1, ARYTM_3, XCMPLX_0, CARD_1, MONOID_0,
      ORDINAL1, ARYTM_1, FUNCT_2, XXREAL_0, XREAL_0, ALGSTR_0, ORDINAL4,
      BINOP_1, FUNCT_7, FUNCT_4, FUNCOP_1, FINSEQ_2, MCART_1, PARTFUN1,
      FUNCT_3, MARGREL1, RELAT_2, PRE_POLY, XBOOLEAN, MATROID0, FINSET_1,
      COMPLEX1, SETFAM_1, CARD_3, FOMODEL0;
 notations TARSKI, XBOOLE_0,
      XTUPLE_0, SUBSET_1, ORDINAL1, NAT_1, ZFMISC_1, NUMBERS,
      INT_1, XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1, RELSET_1, FUNCT_2, FUNCT_4,
      PRE_POLY, FINSEQ_1, MONOID_0, STRUCT_0, XXREAL_0, XREAL_0, BINOP_1,
      FUNCT_7, FUNCOP_1, FINSEQ_2, MCART_1, FINSEQOP, ALGSTR_0, FUNCT_3,
      MARGREL1, RELAT_2, SETFAM_1, DOMAIN_1, FINSET_1, COMPLEX1,
      CARD_1, CARD_3;
 constructors MONOID_0, BINOP_1, FUNCT_7, FUNCT_4, RELSET_1, FINSEQOP,
      DOMAIN_1, SETWISEO, REAL_1, SETFAM_1, LEXBFS, COMPLEX1, XBOOLEAN,
      MARGREL1, WELLORD2, XTUPLE_0;
 registrations SUBSET_1, ORDINAL1, XCMPLX_0, NAT_1, RELAT_1, NUMBERS, FUNCT_1,
      INT_1, FINSEQ_1, MONOID_0, FUNCT_2, FUNCT_4, FINSEQ_2, RELSET_1,
      FUNCOP_1, ZFMISC_1, BINOP_1, XBOOLE_0, XXREAL_0, XREAL_0, EUCLID_9,
      FINSEQ_6, PRE_POLY, PRALG_1, CARD_1, PARTFUN1, LEXBFS, SIMPLEX0,
      FINSET_1, SETFAM_1, REALSET1, CARD_3, FUNCT_7, XTUPLE_0;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FINSEQ_1, BINOP_1, RELAT_1, MARGREL1, FUNCT_4, FUNCOP_1, XBOOLE_0,
      XBOOLEAN, XTUPLE_0;
 theorems TARSKI, XBOOLE_0, INT_1, ZFMISC_1, NUMBERS, FUNCT_1, FINSEQ_1,
      RELAT_1, XBOOLE_1, FUNCT_2, FUNCT_4, FUNCOP_1, MONOID_0, XXREAL_0, NAT_1,
      ORDINAL1, MCART_1, FINSEQ_5, FINSEQ_2, FINSEQ_3, PARTFUN1, XREAL_1,
      BINOP_1, RELSET_1, ALGSTR_0, FUNCT_5, FUNCT_3, FUNCT_7, ARYTM_3, RELAT_2,
      LANG1, XCMPLX_0, FRAENKEL, GRFUNC_1, SYSREL, PRE_POLY, FINSEQOP,
      XBOOLEAN, FINSEQ_6, COMPLEX1, SETFAM_1, CARD_4, CARD_1, COMPUT_1,
      FINSET_1, XTUPLE_0;
 schemes NAT_1, FUNCT_2, CLASSES1, FRAENKEL;

begin
definition
let C1 being set;
let C2 being Function;
attr C2 is C1 -one-to-one
means
:L1: ( C2 | C1 ) is  one-to-one;
end;
definition
let R2 being non  empty set;
let R14 being (BinOp of R2);
let C3 being set;
attr C3 is R14 -unambiguous
means
:L3: R14 is [: C3 , R2 :] -one-to-one;
end;
definition
let R2 being non  empty set;
let C4 being set;
attr C4 is R2 -prefix
means
:L5: C4 is ( R2 -concatenation ) -unambiguous;
end;
definition
let C5 being set;
func C5 -pr1 -> (BinOp of C5) equals 
( pr1 (C5 , C5) );
coherence;
end;
L8: (for R10 being set holds (for R18 being Function holds ((R18 is R10 -valued & R18 is  FinSequence-like) implies R18 is (FinSequence of R10))))
proof
let R10 being set;
let R18 being Function;
set D1 = R18;
set D2 = R10;
assume L9: (D1 is D2 -valued & D1 is  FinSequence-like);
reconsider D3 = D1 as FinSequence by L9;
L10: ( rng D3 ) c= D2 by L9 , RELAT_1:def 19;
thus L11: thesis by L10 , FINSEQ_1:def 4;
end;
L12: (for R7 being set holds (for R8 being set holds (for R10 being set holds (R10 c= ( Funcs (R7 , R8) ) implies ( union R10 ) c= [: R7 , R8 :]))))
proof
let R7 being set;
let R8 being set;
let R10 being set;
set D4 = [: R7 , R8 :];
set D5 = ( Funcs (R7 , R8) );
set D6 = R10;
assume L13: D6 c= D5;
L14: (D6 c= D5 & D5 c= ( bool D4 )) by L13 , FRAENKEL:2;
reconsider D7 = D6 as (Subset of ( bool D4 )) by L14 , XBOOLE_1:1;
L15: ( union D7 ) is (Subset of D4);
thus L16: thesis by L15;
end;
L17: (for B1 being set holds (for B2 being Function holds (B2 is B1 -one-to-one iff (for B3 , B4 being set holds ((B3 in ( ( dom B2 ) /\ B1 ) & B4 in ( ( dom B2 ) /\ B1 ) & ( B2 . B3 ) = ( B2 . B4 )) implies B3 = B4)))))
proof
let C6 being set;
let C7 being Function;
set D8 = ( C7 | C6 );
thus L18: (C7 is C6 -one-to-one implies (for B5 , B6 being set holds ((B5 in ( ( dom C7 ) /\ C6 ) & B6 in ( ( dom C7 ) /\ C6 ) & ( C7 . B5 ) = ( C7 . B6 )) implies B5 = B6)))
proof
assume L19: C7 is C6 -one-to-one;
L20: D8 is  one-to-one by L19 , L1;
let C8 , C9 being set;
assume L21: C8 in ( ( dom C7 ) /\ C6 );
L22: C8 in ( dom D8 ) by L21 , RELAT_1:61;
assume L23: C9 in ( ( dom C7 ) /\ C6 );
L24: C9 in ( dom D8 ) by L23 , RELAT_1:61;
assume L25: ( C7 . C8 ) = ( C7 . C9 );
L26: (( D8 . C8 ) = ( C7 . C8 ) & ( D8 . C9 ) = ( C7 . C9 ) & ( C7 . C8 ) = ( C7 . C9 )) by L25 , L22 , L24 , FUNCT_1:47;
thus L27: C8 = C9 by L26 , L20 , L22 , L24 , FUNCT_1:def 4;
end;

assume L28: (for B7 , B8 being set holds ((B7 in ( ( dom C7 ) /\ C6 ) & B8 in ( ( dom C7 ) /\ C6 ) & ( C7 . B7 ) = ( C7 . B8 )) implies B7 = B8));
L29:
now
let C10 , C11 being set;
assume L30: (C10 in ( dom D8 ) & C11 in ( dom D8 ) & ( D8 . C10 ) = ( D8 . C11 ));
L31: (( D8 . C10 ) = ( C7 . C10 ) & ( D8 . C11 ) = ( C7 . C11 ) & ( D8 . C10 ) = ( D8 . C11 )) by L30 , FUNCT_1:47;
L32: (C10 in ( ( dom C7 ) /\ C6 ) & C11 in ( ( dom C7 ) /\ C6 ) & ( C7 . C10 ) = ( C7 . C11 )) by L31 , L30 , RELAT_1:61;
thus L33: C10 = C11 by L32 , L28;
end;
L34: D8 is  one-to-one by L29 , FUNCT_1:def 4;
thus L35: thesis by L34 , L1;
end;
L36: (for R2 being non  empty set holds (for R7 being set holds (for R8 being set holds (for R14 being (BinOp of R2) holds ((R7 c= R8 & R14 is R8 -one-to-one) implies R14 is R7 -one-to-one)))))
proof
let R2 being non  empty set;
let R7 being set;
let R8 being set;
let R14 being (BinOp of R2);
assume L37: (R7 c= R8 & R14 is R8 -one-to-one);
L38: (( R14 | R8 ) is  one-to-one & ( R14 | R7 ) = ( ( R14 | R8 ) | R7 )) by L37 , L1 , FUNCT_1:51;
L39: (( ( R14 | R8 ) | R7 ) is  one-to-one & ( R14 | R7 ) = ( ( R14 | R8 ) | R7 )) by L38 , FUNCT_1:52;
thus L40: thesis by L39 , L1;
end;
L41: (for R7 being set holds (for R8 being set holds (for R16 being Nat holds (for R17 being Nat holds (( R16 -tuples_on R7 ) meets ( R17 -tuples_on R8 ) implies R16 = R17)))))
proof
let R7 being set;
let R8 being set;
let R16 being Nat;
let R17 being Nat;
assume L42: ( R16 -tuples_on R7 ) meets ( R17 -tuples_on R8 );
L43: ( ( R16 -tuples_on R7 ) /\ ( R17 -tuples_on R8 ) ) is non  empty by L42 , XBOOLE_0:def 7;
consider C12 being set such that L44: C12 in ( ( R16 -tuples_on R7 ) /\ ( R17 -tuples_on R8 ) ) by L43 , XBOOLE_0:def 1;
L45: (C12 in ( R16 -tuples_on R7 ) & C12 in ( R17 -tuples_on R8 )) by L44 , XBOOLE_0:def 4;
reconsider D9 = C12 as R16 -element FinSequence by L45 , FINSEQ_2:141;
reconsider D10 = C12 as R17 -element FinSequence by L45 , FINSEQ_2:141;
L46: R16 = ( len D9 ) by CARD_1:def 7
.= ( len D10 )
.= R17 by CARD_1:def 7;
thus L47: thesis by L46;
end;
L48: (for B9 being Nat holds (for B10 being set holds ( B9 -tuples_on B10 ) = ( Funcs (( Seg B9 ) , B10) )))
proof
let C13 being Nat;
let C14 being set;
per cases ;
suppose L49: C14 is  empty;

per cases ;
suppose L50: C13 is  zero;

L51: (C13 is  zero & ( Seg C13 ) = ( {} )) by L50;
L52: (( Funcs (( Seg C13 ) , C14) ) = { ( {} ) } & ( C13 -tuples_on C14 ) = { ( {} ) }) by L51 , COMPUT_1:5 , FUNCT_5:57;
thus L53: thesis by L52;
end;
suppose L54: C13 is non  zero;

L55: (( Funcs (( Seg C13 ) , C14) ) = ( {} ) & ( C13 -tuples_on C14 ) = ( {} )) by L54 , L49 , FINSEQ_3:119;
thus L56: thesis by L55;
end;
end;
suppose L58: C14 is non  empty;

reconsider D11 = C14 as non  empty set by L58;
L59: ( C13 -tuples_on D11 ) = ( Funcs (( Seg C13 ) , D11) ) by FINSEQ_2:93;
thus L60: thesis by L59;
end;
end;
L62: (for R7 being set holds (for R8 being set holds (for R16 being Nat holds ( ( R16 -tuples_on R7 ) /\ ( R8 * ) ) c= ( R16 -tuples_on R8 ))))
proof
let R7 being set;
let R8 being set;
let R16 being Nat;
reconsider D12 = R16 as (Element of ( NAT )) by ORDINAL1:def 12;
set D13 = ( ( R16 -tuples_on R7 ) /\ ( R8 * ) );
set D14 = ( R16 -tuples_on R8 );
L63:
now
let C15 being set;
assume L64: C15 in D13;
L65: (C15 in ( R16 -tuples_on R7 ) & C15 in ( R8 * )) by L64 , XBOOLE_0:def 4;
L66: (C15 is R16 -element R16 -element R16 -element R16 -element FinSequence & C15 is (FinSequence of R8)) by L65 , FINSEQ_1:def 11 , FINSEQ_2:141;
reconsider D15 = C15 as (FinSequence of R8) by L65 , FINSEQ_1:def 11;
L67: ( len D15 ) = R16 by L66 , CARD_1:def 7;
L68: (D15 = D15 & ( dom D15 ) = ( Seg R16 ) & ( rng D15 ) c= R8) by L67 , FINSEQ_1:def 3;
L69: D15 in ( Funcs (( Seg R16 ) , R8) ) by L68 , FUNCT_2:def 2;
thus L70: C15 in D14 by L69 , L48;
end;
thus L71: thesis by L63 , TARSKI:def 3;
end;
theorem
L72: (for R7 being set holds (for R8 being set holds (for R16 being Nat holds ( ( R16 -tuples_on R7 ) /\ ( R8 * ) ) = ( ( R16 -tuples_on R7 ) /\ ( R16 -tuples_on R8 ) ))))
proof
let R7 being set;
let R8 being set;
let R16 being Nat;
reconsider D16 = R16 as (Element of ( NAT )) by ORDINAL1:def 12;
set D17 = ( ( R16 -tuples_on R7 ) /\ ( R8 * ) );
set D18 = ( ( R16 -tuples_on R7 ) /\ ( R16 -tuples_on R8 ) );
L73: ( ( R16 -tuples_on R7 ) /\ D17 ) c= D18 by L62 , XBOOLE_1:26;
L74: ( ( ( R16 -tuples_on R7 ) /\ ( R16 -tuples_on R7 ) ) /\ ( R8 * ) ) c= D18 by L73 , XBOOLE_1:16;
L75:
now
let C16 being set;
assume L76: C16 in ( R16 -tuples_on R8 );
reconsider D19 = C16 as R16 -element FinSequence by L76 , FINSEQ_2:141;
L77: D19 in ( D16 -tuples_on R8 ) by L76;
L78: (( len D19 ) = D16 & ( rng D19 ) c= R8) by L77 , FINSEQ_2:132;
L79: C16 is (FinSequence of R8) by L78 , FINSEQ_1:def 4;
thus L80: C16 in ( R8 * ) by L79 , FINSEQ_1:def 11;
end;
L81: ( R16 -tuples_on R8 ) c= ( R8 * ) by L75 , TARSKI:def 3;
L82: D18 c= D17 by L81 , XBOOLE_1:26;
thus L83: thesis by L82 , L74 , XBOOLE_0:def 10;
end;
L84: (for R7 being set holds (for R8 being set holds (for R9 being set holds ( ( Funcs (R7 , R8) ) /\ ( Funcs (R7 , R9) ) ) = ( Funcs (R7 , ( R8 /\ R9 )) ))))
proof
let R7 being set;
let R8 being set;
let R9 being set;
set D20 = ( ( Funcs (R7 , R8) ) /\ ( Funcs (R7 , R9) ) );
set D21 = ( Funcs (R7 , ( R8 /\ R9 )) );
L85:
now
let C17 being set;
assume L86: C17 in D20;
L87: (C17 in ( Funcs (R7 , R8) ) & C17 in ( Funcs (R7 , R9) )) by L86 , XBOOLE_0:def 4;
consider C18 being Function such that L88: (C18 = C17 & ( dom C18 ) = R7 & ( rng C18 ) c= R8) by L87 , FUNCT_2:def 2;
consider C19 being Function such that L89: (C19 = C17 & ( dom C19 ) = R7 & ( rng C19 ) c= R9) by L87 , FUNCT_2:def 2;
L90: (C18 = C17 & ( dom C18 ) = R7 & ( rng C18 ) c= ( R8 /\ R9 )) by L88 , L89 , XBOOLE_1:19;
thus L91: C17 in ( Funcs (R7 , ( R8 /\ R9 )) ) by L90 , FUNCT_2:def 2;
end;
L92: D20 c= D21 by L85 , TARSKI:def 3;
L93: (D21 c= ( Funcs (R7 , R8) ) & D21 c= ( Funcs (R7 , R9) )) by FUNCT_5:56 , XBOOLE_1:17;
L94: D21 c= D20 by L93 , XBOOLE_1:19;
thus L95: thesis by L94 , L92 , XBOOLE_0:def 10;
end;
theorem
L96: (for R7 being set holds (for R8 being set holds (for R16 being Nat holds ( ( R16 -tuples_on R7 ) /\ ( R8 * ) ) = ( R16 -tuples_on ( R7 /\ R8 ) ))))
proof
let R7 being set;
let R8 being set;
let R16 being Nat;
L97: ( R16 -tuples_on ( R7 /\ R8 ) ) = ( Funcs (( Seg R16 ) , ( R7 /\ R8 )) ) by L48
.= ( ( Funcs (( Seg R16 ) , R7) ) /\ ( Funcs (( Seg R16 ) , R8) ) ) by L84
.= ( ( R16 -tuples_on R7 ) /\ ( Funcs (( Seg R16 ) , R8) ) ) by L48
.= ( ( R16 -tuples_on R7 ) /\ ( R16 -tuples_on R8 ) ) by L48
.= ( ( R16 -tuples_on R7 ) /\ ( R8 * ) ) by L72;
thus L98: thesis by L97;
end;
theorem
L99: (for R7 being set holds (for R8 being set holds (for R16 being Nat holds ( R16 -tuples_on ( R7 /\ R8 ) ) = ( ( R16 -tuples_on R7 ) /\ ( R16 -tuples_on R8 ) ))))
proof
let R7 being set;
let R8 being set;
let R16 being Nat;
L100: ( R16 -tuples_on ( R7 /\ R8 ) ) = ( ( R16 -tuples_on R7 ) /\ ( R8 * ) ) by L96
.= ( ( R16 -tuples_on R7 ) /\ ( R16 -tuples_on R8 ) ) by L72;
thus L101: thesis by L100;
end;
L102: (for R2 being non  empty set holds (for B11 , B12 being (FinSequence of R2) holds ( ( R2 -concatenation ) . (B11 , B12) ) = ( B11 ^ B12 )))
proof
let R2 being non  empty set;
let C20 , C21 being (FinSequence of R2);
reconsider D22 = C20 , D23 = C21 as (Element of ( R2 * )) by FINSEQ_1:def 11;
reconsider D24 = D22 , D25 = D23 as (Element of ( R2 *+^ )) by MONOID_0:def 34;
L103: ( R2 -concatenation ) = (the multF of ( R2 *+^ )) by MONOID_0:def 36;
L104: ( D24 ^ D25 ) = ( D24 * D25 ) by MONOID_0:def 34
.= ( ( R2 -concatenation ) . (D24 , D25) ) by L103 , ALGSTR_0:def 18;
thus L105: thesis by L104;
end;
theorem
L106: (for R1 being non  empty set holds (for B13 , B14 being FinSequence holds ((B13 is R1 -valued & B14 is R1 -valued) implies ( ( R1 -concatenation ) . (B13 , B14) ) = ( B13 ^ B14 ))))
proof
let R1 being non  empty set;
let C22 , C23 being FinSequence;
set D26 = ( R1 -concatenation );
assume L107: (C22 is R1 -valued & C23 is R1 -valued);
reconsider D27 = C22 , D28 = C23 as (FinSequence of R1) by L107 , L8;
L108: ( D26 . (D27 , D28) ) = ( D27 ^ D28 ) by L102;
thus L109: thesis by L108;
end;
theorem
L110: (for R2 being non  empty set holds (for B15 being set holds (B15 is non  empty non  empty non  empty non  empty (FinSequence of R2) iff B15 in ( ( R2 * ) \ { ( {} ) } ))))
proof
let R2 being non  empty set;
let C24 being set;
thus L111: (C24 is non  empty non  empty non  empty non  empty (FinSequence of R2) implies C24 in ( ( R2 * ) \ { ( {} ) } ))
proof
assume L112: C24 is non  empty non  empty non  empty non  empty (FinSequence of R2);
L113: ((not C24 in { ( {} ) }) & C24 in ( R2 * )) by L112 , FINSEQ_1:def 11 , TARSKI:def 1;
thus L114: thesis by L113 , XBOOLE_0:def 5;
end;

assume L115: C24 in ( ( R2 * ) \ { ( {} ) } );
L116: (C24 in ( R2 * ) & (not C24 in { ( {} ) })) by L115 , XBOOLE_0:def 5;
thus L117: thesis by L116 , FINSEQ_1:def 11 , TARSKI:def 1;
end;
L118: (for R2 being non  empty set holds (for R7 being set holds (for R8 being set holds (for R14 being (BinOp of R2) holds ((R8 is R14 -unambiguous & R7 c= R8) implies R7 is R14 -unambiguous)))))
proof
let R2 being non  empty set;
let R7 being set;
let R8 being set;
let R14 being (BinOp of R2);
assume L119: (R8 is R14 -unambiguous & R7 c= R8);
L120: (R14 is [: R8 , R2 :] -one-to-one & R7 c= R8) by L119 , L3;
L121: R14 is [: R7 , R2 :] -one-to-one by L120 , L36 , ZFMISC_1:96;
thus L122: thesis by L121 , L3;
end;
L123: (for R2 being non  empty set holds (for R14 being (BinOp of R2) holds ( {} ) is R14 -unambiguous))
proof
let R2 being non  empty set;
let R14 being (BinOp of R2);
reconsider D29 = [: ( {} ) , R2 :] as  empty set;
L124: ( R14 | D29 ) is  one-to-one;
L125: R14 is D29 -one-to-one by L124 , L1;
thus L126: thesis by L125 , L3;
end;
L127: (for B16 , B17 being FinSequence holds ( dom <: B16 , B17 :> ) = ( Seg ( min (( len B16 ) , ( len B17 )) ) ))
proof
let C25 , C26 being FinSequence;
set D30 = ( len C25 );
set D31 = ( len C26 );
set D32 = ( min (D30 , D31) );
thus L128: ( dom <: C25 , C26 :> ) = ( ( dom C25 ) /\ ( dom C26 ) ) by FUNCT_3:def 7
.= ( ( Seg D30 ) /\ ( dom C26 ) ) by FINSEQ_1:def 3
.= ( ( Seg D30 ) /\ ( Seg D31 ) ) by FINSEQ_1:def 3
.= ( Seg D32 ) by FINSEQ_2:2;
end;
registration
let C27 being non  empty set;
cluster ( C27 -pr1 ) ->  associative for (BinOp of C27);
coherence
proof
L129:
now
let C28 , C29 , C30 being (Element of C27);
L130: (( ( C27 -pr1 ) . (C28 , ( ( C27 -pr1 ) . (C29 , C30) )) ) = C28 & ( ( C27 -pr1 ) . (( ( C27 -pr1 ) . (C28 , C29) ) , C30) ) = ( ( C27 -pr1 ) . (C28 , C30) )) by FUNCT_3:def 4;
thus L131: ( ( C27 -pr1 ) . (C28 , ( ( C27 -pr1 ) . (C29 , C30) )) ) = ( ( C27 -pr1 ) . (( ( C27 -pr1 ) . (C28 , C29) ) , C30) ) by L130 , FUNCT_3:def 4;
end;
thus L132: thesis by L129 , BINOP_1:def 3;
end;
end;
registration
let C31 being set;
cluster  associative for (BinOp of C31);
existence
proof
per cases ;
suppose L134: C31 is non  empty;

reconsider D33 = C31 as non  empty set by L134;
reconsider D34 = ( D33 -pr1 ) as (BinOp of C31);
take D34;
thus L135: thesis;
end;
suppose L136: C31 is  empty;

reconsider D35 = C31 as  empty set by L136;
set D36 = the (BinOp of ( {} ));
L137: (D36 is  associative & D36 is (BinOp of D35));
thus L138: thesis by L137;
end;
end;
end;
definition
let C32 being set;
let C33 being (Subset of C32);
redefine func C33 * -> non  empty (Subset of ( C32 * ));

coherence by FINSEQ_1:62;
end;
registration
let C34 being non  empty set;
cluster ( C34 -concatenation ) ->  associative for (BinOp of ( C34 * ));
coherence by MONOID_0:67;
end;
registration
let C35 being non  empty set;
cluster ( ( C35 * ) \ { ( {} ) } ) -> non  empty;
coherence
proof
set D37 = the (Element of C35);
L143: (<* D37 *> in ( C35 * ) & (not <* D37 *> in { ( {} ) })) by FINSEQ_1:def 11 , TARSKI:def 1;
thus L144: thesis by L143 , XBOOLE_0:def 5;
end;
end;
registration
let C36 being non  empty set;
let C37 being Nat;
cluster C37 -element for (Element of ( C36 * ));
existence
proof
set D38 = the C37 -element (FinSequence of C36);
reconsider D39 = D38 as (Element of ( C36 * )) by FINSEQ_1:def 11;
take D39;
thus L146: thesis;
end;
end;
definition
let C38 being set;
let C39 being Function;
redefine attr C39 is C38 -one-to-one
means
:L148: (for B18 , B19 being set holds ((B18 in ( C38 /\ ( dom C39 ) ) & B19 in ( C38 /\ ( dom C39 ) ) & ( C39 . B18 ) = ( C39 . B19 )) implies B18 = B19));
compatibility by L17;
end;
registration
let R2 being non  empty set;
let R14 being (BinOp of R2);
cluster R14 -unambiguous for set;
existence
proof
take ( {} );
thus L150: thesis by L123;
end;
end;
registration
let C40 being Function;
let C41 being set;
cluster ( C40 | { C41 } ) ->  one-to-one;
coherence
proof
set D40 = ( C40 | { C41 } );
per cases ;
suppose L152: C41 in ( dom C40 );

L153: D40 = ( C41 .--> ( C40 . C41 ) ) by L152 , FUNCT_7:6;
thus L154: thesis by L153;
end;
suppose L155: (not C41 in ( dom C40 ));

reconsider D41 = D40 as  empty Function by L155 , RELAT_1:152 , ZFMISC_1:50;
L156: D41 is  one-to-one;
thus L157: thesis by L156;
end;
end;
end;
registration
let C42 being  empty set;
identify C42 * with {C42 };
compatibility by FUNCT_7:17;
identify {C42 } with C42 *;
compatibility;
end;
registration
cluster  empty ->  empty-membered for set;
coherence;
let C43 being  empty set;
cluster { C43 } ->  empty-membered;
coherence
proof
L161: (not (ex B20 being non  empty set st B20 in { C43 })) by TARSKI:def 1;
thus L162: thesis by L161 , SETFAM_1:def 10;
end;
end;
registration
let R1 being non  empty set;
let C44 being non  zero Nat;
cluster ( C44 -tuples_on R1 ) ->  with_non-empty_elements;
coherence
proof
L164: (not ( len ( {} ) ) = C44);
L165: (not ( {} ) is (Element of ( C44 -tuples_on R1 ))) by L164 , CARD_1:def 7;
thus L166: thesis by L165 , SETFAM_1:def 8;
end;
end;
registration
let C45 being  empty-membered set;
cluster  ->  empty-membered for (Subset of C45);
coherence
proof
let C46 being (Subset of C45);
L168: (not (ex B21 being non  empty set st B21 in C46)) by SETFAM_1:def 10;
thus L169: thesis by L168 , SETFAM_1:def 10;
end;
end;
registration
let R7 being set;
let C47 being  zero number;
cluster ( C47 -tuples_on R7 ) ->  empty-membered for set;
coherence by COMPUT_1:5;
end;
registration
let C48 being  empty set;
let C49 being non  zero Nat;
cluster ( C49 -tuples_on C48 ) ->  empty;
coherence by FINSEQ_3:119;
end;
registration
let R2 being non  empty set;
let R14 being (BinOp of R2);
let C50 being  empty set;
cluster ( C50 /\ R14 ) -> R14 -unambiguous;
coherence by L123;
end;
registration
let R1 being non  empty set;
let C51 being  empty set;
cluster ( C51 /\ R1 ) -> R1 -prefix;
coherence
proof
set D42 = ( R1 -concatenation );
L174: ( C51 /\ D42 ) is D42 -unambiguous;
thus L175: thesis by L174 , L5;
end;
end;
registration
let R1 being non  empty set;
cluster R1 -prefix for set;
existence
proof
take ( ( {} ) /\ R1 );
thus L177: thesis;
end;
end;
definition
let R2 being non  empty set;
let R14 being (BinOp of R2);
let C52 being (FinSequence of R2);
func MultPlace (R14 , C52) -> Function means 
:L179: (( dom it ) = ( NAT ) & ( it . ( 0 ) ) = ( C52 . 1 ) & (for B22 being Nat holds ( it . ( B22 + 1 ) ) = ( R14 . (( it . B22 ) , ( C52 . ( B22 + 2 ) )) )));
existence
proof
deffunc H1(Nat , set) = ( R14 . ($2 , ( C52 . ( $1 + 2 ) )) );
consider C53 being Function such that L180: (( dom C53 ) = ( NAT ) & ( C53 . ( 0 ) ) = ( C52 . 1 ) & (for B23 being Nat holds ( C53 . ( B23 + 1 ) ) = H1(B23 , ( C53 . B23 )))) from NAT_1:sch 11;
take C53;
thus L181: thesis by L180;
end;
uniqueness
proof
let C54 , C55 being Function;
assume L182: (( dom C54 ) = ( NAT ) & ( C54 . ( 0 ) ) = ( C52 . 1 ) & (for B24 being Nat holds ( C54 . ( B24 + 1 ) ) = ( R14 . (( C54 . B24 ) , ( C52 . ( B24 + 2 ) )) )));
assume L183: (( dom C55 ) = ( NAT ) & ( C55 . ( 0 ) ) = ( C52 . 1 ) & (for B25 being Nat holds ( C55 . ( B25 + 1 ) ) = ( R14 . (( C55 . B25 ) , ( C52 . ( B25 + 2 ) )) )));
deffunc H2(Nat , set) = ( R14 . ($2 , ( C52 . ( $1 + 2 ) )) );
L184: ( dom C54 ) = ( NAT ) by L182;
L185: ( C54 . ( 0 ) ) = ( C52 . 1 ) by L182;
L186: (for B26 being Nat holds ( C54 . ( B26 + 1 ) ) = H2(B26 , ( C54 . B26 ))) by L182;
L187: ( dom C55 ) = ( NAT ) by L183;
L188: ( C55 . ( 0 ) ) = ( C52 . 1 ) by L183;
L189: (for B27 being Nat holds ( C55 . ( B27 + 1 ) ) = H2(B27 , ( C55 . B27 ))) by L183;
thus L190: thesis from NAT_1:sch 15(L184 , L185 , L186 , L187 , L188 , L189);
end;
end;
L192: (for R2 being non  empty set holds (for R14 being (BinOp of R2) holds (for B28 being (FinSequence of R2) holds (for B29 being Nat holds ((( B29 + 1 ) <= ( len B28 ) implies ( ( MultPlace (R14 , B28) ) . B29 ) in R2) & (for B30 being Nat holds (B30 >= ( B29 + 1 ) implies ( ( MultPlace (R14 , ( B28 | B30 )) ) . B29 ) = ( ( MultPlace (R14 , B28) ) . B29 ))))))))
proof
let R2 being non  empty set;
let R14 being (BinOp of R2);
let C56 being (FinSequence of R2);
defpred S1[ Nat ] means (( $1 + 1 ) <= ( len C56 ) implies ( ( MultPlace (R14 , C56) ) . $1 ) in R2);
L193: S1[ ( 0 ) ]
proof
assume L194: ( ( 0 ) + 1 ) <= ( len C56 );
L195: 1 in ( Seg ( len C56 ) ) by L194;
L196: 1 in ( dom C56 ) by L195 , FINSEQ_1:def 3;
L197: (( C56 . 1 ) in ( rng C56 ) & ( rng C56 ) c= R2) by L196 , FUNCT_1:def 3;
L198: (( C56 . 1 ) in R2 & ( ( MultPlace (R14 , C56) ) . ( 0 ) ) = ( C56 . 1 )) by L197 , L179;
thus L199: thesis by L198;
end;
L200: (for B31 being Nat holds (S1[ B31 ] implies S1[ ( B31 + 1 ) ]))
proof
let C57 being Nat;
assume L201: S1[ C57 ];
assume L202: ( ( C57 + 1 ) + 1 ) <= ( len C56 );
L203: (( C57 + 2 ) <= ( len C56 ) & 1 <= ( C57 + 2 )) by L202 , NAT_1:12;
L204: ( C57 + 2 ) in ( Seg ( len C56 ) ) by L203 , FINSEQ_1:1;
L205: ( C57 + 2 ) in ( dom C56 ) by L204 , FINSEQ_1:def 3;
L206: (( C56 . ( C57 + 2 ) ) in ( rng C56 ) & ( rng C56 ) c= R2) by L205 , FUNCT_1:def 3;
L207: (( C57 + 1 ) <= ( C57 + 2 ) implies ( C57 + 1 ) <= ( len C56 )) by L202 , XXREAL_0:2;
L208: [ ( ( MultPlace (R14 , C56) ) . C57 ) , ( C56 . ( C57 + 2 ) ) ] in [: R2 , R2 :] by L207 , L201 , L206 , XREAL_1:6 , ZFMISC_1:def 2;
L209: ( R14 . (( ( MultPlace (R14 , C56) ) . C57 ) , ( C56 . ( C57 + 2 ) )) ) in R2 by L208 , FUNCT_2:5;
thus L210: thesis by L209 , L179;
end;
defpred S2[ Nat ] means (for B32 being Nat holds (B32 >= ( $1 + 1 ) implies ( ( MultPlace (R14 , ( C56 | B32 )) ) . $1 ) = ( ( MultPlace (R14 , C56) ) . $1 )));
L211: S2[ ( 0 ) ]
proof
let C58 being Nat;
assume L212: C58 >= ( ( 0 ) + 1 );
L213: ( ( MultPlace (R14 , ( C56 | C58 )) ) . ( 0 ) ) = ( ( C56 | C58 ) . 1 ) by L179
.= ( C56 . 1 ) by L212 , FINSEQ_3:112
.= ( ( MultPlace (R14 , C56) ) . ( 0 ) ) by L179;
thus L214: thesis by L213;
end;
L215: (for B33 being Nat holds (S2[ B33 ] implies S2[ ( B33 + 1 ) ]))
proof
let C59 being Nat;
assume L216: S2[ C59 ];
let C60 being Nat;
assume L217: C60 >= ( ( C59 + 1 ) + 1 );
L218: (( C59 + 2 ) >= ( C59 + 1 ) & C60 >= ( C59 + 2 )) by L217 , XREAL_1:6;
L219: ( ( MultPlace (R14 , ( C56 | C60 )) ) . ( C59 + 1 ) ) = ( R14 . (( ( MultPlace (R14 , ( C56 | C60 )) ) . C59 ) , ( ( C56 | C60 ) . ( C59 + 2 ) )) ) by L179
.= ( R14 . (( ( MultPlace (R14 , C56) ) . C59 ) , ( ( C56 | C60 ) . ( C59 + 2 ) )) ) by L216 , L218 , XXREAL_0:2
.= ( R14 . (( ( MultPlace (R14 , C56) ) . C59 ) , ( C56 . ( C59 + 2 ) )) ) by L217 , FINSEQ_3:112
.= ( ( MultPlace (R14 , C56) ) . ( C59 + 1 ) ) by L179;
thus L220: thesis by L219;
end;
defpred S3[ Nat ] means (S2[ $1 ] & S1[ $1 ]);
L221: S3[ ( 0 ) ] by L211 , L193;
L222: (for B34 being Nat holds (S3[ B34 ] implies S3[ ( B34 + 1 ) ])) by L215 , L200;
L223: (for B35 being Nat holds S3[ B35 ]) from NAT_1:sch 2(L221 , L222);
thus L224: thesis by L223;
end;
definition
let R2 being non  empty set;
let R14 being (BinOp of R2);
let C61 being (Element of ( ( R2 * ) \ { ( {} ) } ));
func MultPlace (R14 , C61) -> Function equals 
( MultPlace (R14 , (C61 qua (Element of ( R2 * )))) );
coherence;
end;
definition
let R2 being non  empty set;
let R14 being (BinOp of R2);
func MultPlace R14 -> (Function of ( ( R2 * ) \ { ( {} ) } ) , R2) means 
:L226: (for B36 being (Element of ( ( R2 * ) \ { ( {} ) } )) holds ( it . B36 ) = ( ( MultPlace (R14 , B36) ) . ( ( len B36 ) - 1 ) ));
existence
proof
defpred S4[ (Element of ( ( R2 * ) \ { ( {} ) } )) , (Element of R2) ] means $2 = ( ( MultPlace (R14 , $1) ) . ( ( len $1 ) - 1 ) );
L227: (for B37 being (Element of ( ( R2 * ) \ { ( {} ) } )) holds (ex B38 being (Element of R2) st S4[ B37 , B38 ]))
proof
let C62 being (Element of ( ( R2 * ) \ { ( {} ) } ));
reconsider D43 = C62 as (Element of ( R2 * ));
L228: (not D43 in { ( {} ) }) by XBOOLE_0:def 5;
L229: D43 <> ( {} ) by L228 , TARSKI:def 1;
L230: ( len D43 ) >= 1 by L229 , FINSEQ_1:20;
L231: ( ( len D43 ) - 1 ) in ( NAT ) by L230 , INT_1:3 , XREAL_1:48;
reconsider D44 = ( ( len D43 ) - 1 ) as Nat by L231;
L232: ( D44 + 1 ) <= ( len D43 );
reconsider D45 = ( ( MultPlace (R14 , D43) ) . D44 ) as (Element of R2) by L192 , L232;
take D45;
thus L233: thesis;
end;
consider C63 being (Function of ( ( R2 * ) \ { ( {} ) } ) , R2) such that L234: (for B39 being (Element of ( ( R2 * ) \ { ( {} ) } )) holds S4[ B39 , ( C63 . B39 ) ]) from FUNCT_2:sch 3(L227);
take C63;
thus L235: thesis by L234;
end;
uniqueness
proof
let C64 , C65 being (Function of ( ( R2 * ) \ { ( {} ) } ) , R2);
L236: (( dom C64 ) = ( ( R2 * ) \ { ( {} ) } ) & ( dom C65 ) = ( ( R2 * ) \ { ( {} ) } )) by FUNCT_2:def 1;
assume L237: (for B40 being (Element of ( ( R2 * ) \ { ( {} ) } )) holds ( C64 . B40 ) = ( ( MultPlace (R14 , B40) ) . ( ( len B40 ) - 1 ) ));
assume L238: (for B41 being (Element of ( ( R2 * ) \ { ( {} ) } )) holds ( C65 . B41 ) = ( ( MultPlace (R14 , B41) ) . ( ( len B41 ) - 1 ) ));
L239:
now
let C66 being set;
assume L240: C66 in ( dom C64 );
reconsider D46 = C66 as (Element of ( ( R2 * ) \ { ( {} ) } )) by L240;
L241: ( C64 . C66 ) = ( ( MultPlace (R14 , D46) ) . ( ( len D46 ) - 1 ) ) by L237
.= ( C65 . C66 ) by L238;
thus L242: ( C64 . C66 ) = ( C65 . C66 ) by L241;
end;
thus L243: thesis by L239 , L236 , FUNCT_1:2;
end;
end;
L245: (for R2 being non  empty set holds (for R14 being (BinOp of R2) holds (for B42 being non  empty (FinSequence of R2) holds (for B43 being (Element of R2) holds (( ( MultPlace R14 ) . <* B43 *> ) = B43 & ( ( MultPlace R14 ) . ( B42 ^ <* B43 *> ) ) = ( R14 . (( ( MultPlace R14 ) . B42 ) , B43) ))))))
proof
let R2 being non  empty set;
let R14 being (BinOp of R2);
set D47 = ( MultPlace R14 );
let C67 being non  empty (FinSequence of R2);
let C68 being (Element of R2);
consider C69 being Nat such that L246: ( C69 + 1 ) = ( len C67 ) by NAT_1:6;
reconsider D48 = C67 as (Element of ( ( R2 * ) \ { ( {} ) } )) by L110;
reconsider D49 = ( C67 ^ <* C68 *> ) as non  empty (FinSequence of R2);
L247: 1 in ( Seg 1 );
L248: 1 in ( dom <* C68 *> ) by L247 , FINSEQ_1:def 8;
L249: ( D49 . ( ( len C67 ) + 1 ) ) = ( <* C68 *> . 1 ) by L248 , FINSEQ_1:def 7
.= C68 by FINSEQ_1:40;
L250: ( D49 | ( len C67 ) ) = ( C67 | ( len C67 ) ) by FINSEQ_5:22
.= C67 by FINSEQ_3:49;
L251: ( len <* C68 *> ) = 1 by FINSEQ_1:40;
L252: ( len D49 ) = ( ( len C67 ) + 1 ) by L251 , FINSEQ_1:22;
reconsider D50 = <* C68 *> as non  empty (FinSequence of R2);
reconsider D51 = D50 as (Element of ( ( R2 * ) \ { ( {} ) } )) by L110;
L253: ( ( len D51 ) - 1 ) = ( 0 ) by L251;
L254: ( D47 . D51 ) = ( ( MultPlace (R14 , D51) ) . ( 0 ) ) by L253 , L226
.= ( D51 . 1 ) by L179
.= C68 by FINSEQ_1:def 8;
thus L255: ( D47 . <* C68 *> ) = C68 by L254;
reconsider D52 = D49 as (Element of ( ( R2 * ) \ { ( {} ) } )) by L110;
L256: ( D47 . D52 ) = ( ( MultPlace (R14 , D52) ) . ( ( len D52 ) - 1 ) ) by L226
.= ( R14 . (( ( MultPlace (R14 , D52) ) . C69 ) , ( D52 . ( C69 + 2 ) )) ) by L179 , L246 , L252
.= ( R14 . (( ( MultPlace (R14 , D48) ) . ( ( len C67 ) - 1 ) ) , ( D52 . ( ( len C67 ) + 1 ) )) ) by L250 , L246 , L192
.= ( R14 . (( D47 . D48 ) , C68) ) by L249 , L226;
thus L257: thesis by L256;
end;
L258: (for R2 being non  empty set holds (for R14 being (BinOp of R2) holds (for B44 being set holds (R14 is [: B44 , R2 :] -one-to-one iff (for B45 , B46 , B47 , B48 being set holds ((B45 in ( B44 /\ R2 ) & B46 in ( B44 /\ R2 ) & B47 in R2 & B48 in R2 & ( R14 . (B45 , B47) ) = ( R14 . (B46 , B48) )) implies (B45 = B46 & B47 = B48)))))))
proof
let R2 being non  empty set;
let R14 being (BinOp of R2);
L259: ( dom R14 ) = [: R2 , R2 :] by FUNCT_2:def 1;
let C70 being set;
thus L260: (R14 is [: C70 , R2 :] -one-to-one implies (for B49 , B50 , B51 , B52 being set holds ((B49 in ( C70 /\ R2 ) & B50 in ( C70 /\ R2 ) & B51 in R2 & B52 in R2 & ( R14 . (B49 , B51) ) = ( R14 . (B50 , B52) )) implies (B49 = B50 & B51 = B52))))
proof
assume L261: R14 is [: C70 , R2 :] -one-to-one;
let C71 , C72 , C73 , C74 being set;
assume L262: (C71 in ( C70 /\ R2 ) & C72 in ( C70 /\ R2 ) & C73 in R2 & C74 in R2 & ( R14 . (C71 , C73) ) = ( R14 . (C72 , C74) ));
L263: ([ C71 , C73 ] in [: ( C70 /\ R2 ) , ( R2 /\ R2 ) :] & [ C72 , C74 ] in [: ( C70 /\ R2 ) , ( R2 /\ R2 ) :]) by L262 , ZFMISC_1:def 2;
L264: ([ C71 , C73 ] in ( [: C70 , R2 :] /\ [: R2 , R2 :] ) & [ C72 , C74 ] in ( [: C70 , R2 :] /\ [: R2 , R2 :] )) by L263 , ZFMISC_1:100;
L265: [ C71 , C73 ] = [ C72 , C74 ] by L148 , L259 , L261 , L264 , L262;
thus L266: (C71 = C72 & C73 = C74) by L265 , XTUPLE_0:1;
end;

assume L267: (for B53 , B54 , B55 , B56 being set holds ((B53 in ( C70 /\ R2 ) & B54 in ( C70 /\ R2 ) & B55 in R2 & B56 in R2 & ( R14 . (B53 , B55) ) = ( R14 . (B54 , B56) )) implies (B53 = B54 & B55 = B56)));
L268:
now
let C75 , C76 being set;
assume L269: (C75 in ( [: C70 , R2 :] /\ ( dom R14 ) ) & C76 in ( [: C70 , R2 :] /\ ( dom R14 ) ) & ( R14 . C75 ) = ( R14 . C76 ));
L270: (C75 in [: ( C70 /\ R2 ) , ( R2 /\ R2 ) :] & C76 in [: ( C70 /\ R2 ) , ( R2 /\ R2 ) :] & ( R14 . C75 ) = ( R14 . C76 )) by L269 , L259 , ZFMISC_1:100;
consider C77 , C78 being set such that L271: (C77 in ( C70 /\ R2 ) & C78 in R2 & C75 = [ C77 , C78 ]) by L270 , ZFMISC_1:def 2;
consider C79 , C80 being set such that L272: (C79 in ( C70 /\ R2 ) & C80 in R2 & C76 = [ C79 , C80 ]) by L270 , ZFMISC_1:def 2;
L273: (C77 in ( C70 /\ R2 ) & C79 in ( C70 /\ R2 ) & C78 in R2 & C80 in R2 & ( R14 . (C77 , C78) ) = ( R14 . (C79 , C80) )) by L271 , L272 , L269;
L274: (C77 = C79 & C78 = C80) by L273 , L267;
thus L275: C75 = C76 by L274 , L271 , L272;
end;
thus L276: R14 is [: C70 , R2 :] -one-to-one by L268 , L148;
end;
definition
let R2 being non  empty set;
let R14 being (BinOp of R2);
let C81 being set;
redefine attr C81 is R14 -unambiguous
means
:L277: (for B57 , B58 , B59 , B60 being set holds ((B57 in ( C81 /\ R2 ) & B58 in ( C81 /\ R2 ) & B59 in R2 & B60 in R2 & ( R14 . (B57 , B59) ) = ( R14 . (B58 , B60) )) implies (B57 = B58 & B59 = B60)));
compatibility
proof
thus L278: (C81 is R14 -unambiguous implies (for B61 , B62 , B63 , B64 being set holds ((B61 in ( C81 /\ R2 ) & B62 in ( C81 /\ R2 ) & B63 in R2 & B64 in R2 & ( R14 . (B61 , B63) ) = ( R14 . (B62 , B64) )) implies (B61 = B62 & B63 = B64))))
proof
assume L279: C81 is R14 -unambiguous;
L280: R14 is [: C81 , R2 :] -one-to-one by L279 , L3;
thus L281: thesis by L280 , L258;
end;

assume L282: (for B65 , B66 , B67 , B68 being set holds ((B65 in ( C81 /\ R2 ) & B66 in ( C81 /\ R2 ) & B67 in R2 & B68 in R2 & ( R14 . (B65 , B67) ) = ( R14 . (B66 , B68) )) implies (B65 = B66 & B67 = B68)));
L283: R14 is [: C81 , R2 :] -one-to-one by L282 , L258;
thus L284: thesis by L283 , L3;
end;
end;
L286: (for R2 being non  empty set holds (for R14 being (BinOp of R2) holds (R14 is  associative implies (for B69 being (Element of R2) holds (for B70 being Nat holds (for B71 being (Element of ( ( B70 + 1 ) -tuples_on R2 )) holds ( ( MultPlace R14 ) . ( <* B69 *> ^ B71 ) ) = ( R14 . (B69 , ( ( MultPlace R14 ) . B71 )) )))))))
proof
let R2 being non  empty set;
let R14 being (BinOp of R2);
set D53 = ( MultPlace R14 );
assume L287: R14 is  associative;
let C82 being (Element of R2);
defpred S5[ Nat ] means (for B72 being (Element of ( ( $1 + 1 ) -tuples_on R2 )) holds ( D53 . ( <* C82 *> ^ B72 ) ) = ( R14 . (C82 , ( D53 . B72 )) ));
L288: S5[ ( 0 ) ]
proof
let C83 being (Element of ( ( ( 0 ) + 1 ) -tuples_on R2 ));
consider C84 being (Element of R2) such that L289: C83 = <* C84 *> by FINSEQ_2:97;
L290: ( D53 . ( <* C82 *> ^ C83 ) ) = ( R14 . (( D53 . <* C82 *> ) , C84) ) by L245 , L289
.= ( R14 . (C82 , C84) ) by L245
.= ( R14 . (C82 , ( D53 . C83 )) ) by L245 , L289;
thus L291: thesis by L290;
end;
L292: (for B73 being Nat holds (S5[ B73 ] implies S5[ ( B73 + 1 ) ]))
proof
let C85 being Nat;
assume L293: S5[ C85 ];
let C86 being (Element of ( ( ( C85 + 1 ) + 1 ) -tuples_on R2 ));
L294: (( ( C85 + 1 ) + ( 0 ) ) <= ( ( C85 + 1 ) + 1 ) & ( len C86 ) = ( ( C85 + 1 ) + 1 )) by CARD_1:def 7 , XREAL_1:6;
L295: ( len ( C86 | ( C85 + 1 ) ) ) = ( C85 + 1 ) by L294 , FINSEQ_1:59;
reconsider D54 = ( C86 | ( C85 + 1 ) ) as (Element of ( ( C85 + 1 ) -tuples_on R2 )) by L295 , FINSEQ_2:92;
reconsider D55 = D54 as non  empty (FinSequence of R2);
reconsider D56 = ( C86 /. ( len C86 ) ) as (Element of R2);
L296: D55 in ( ( R2 * ) \ { ( {} ) } ) by L110;
reconsider D57 = ( D53 . D55 ) as (Element of R2) by L296 , FUNCT_2:5;
L297: ( ( C85 + 1 ) + 1 ) = ( len C86 ) by CARD_1:def 7;
L298: ( D53 . ( <* C82 *> ^ C86 ) ) = ( D53 . ( <* C82 *> ^ ( ( C86 | ( C85 + 1 ) ) ^ <* D56 *> ) ) ) by L297 , FINSEQ_5:21
.= ( D53 . ( ( <* C82 *> ^ D54 ) ^ <* D56 *> ) ) by FINSEQ_1:32
.= ( R14 . (( D53 . ( <* C82 *> ^ D54 ) ) , D56) ) by L245
.= ( R14 . (( R14 . (C82 , ( D53 . D54 )) ) , D56) ) by L293
.= ( R14 . (C82 , ( R14 . (D57 , D56) )) ) by L287 , BINOP_1:def 3
.= ( R14 . (C82 , ( D53 . ( D55 ^ <* D56 *> ) )) ) by L245
.= ( R14 . (C82 , ( D53 . C86 )) ) by L297 , FINSEQ_5:21;
thus L299: thesis by L298;
end;
thus L300: (for B74 being Nat holds S5[ B74 ]) from NAT_1:sch 2(L288 , L292);
end;
L301: (for R2 being non  empty set holds (for R3 being non  empty (Subset of R2) holds (for R14 being (BinOp of R2) holds (for R16 being Nat holds ((R14 is  associative & R3 is R14 -unambiguous) implies ( ( MultPlace R14 ) .: ( ( R16 + 1 ) -tuples_on R3 ) ) is R14 -unambiguous)))))
proof
let R2 being non  empty set;
let R3 being non  empty (Subset of R2);
let R14 being (BinOp of R2);
let R16 being Nat;
set D58 = ( MultPlace R14 );
assume L302: R14 is  associative;
assume L303: R3 is R14 -unambiguous;
defpred S6[ Nat ] means ( D58 .: ( ( $1 + 1 ) -tuples_on R3 ) ) is R14 -unambiguous;
L304: S6[ ( 0 ) ]
proof
set D59 = ( ( ( 0 ) + 1 ) -tuples_on R3 );
set D60 = ( D58 .: D59 );
L305: (for B75 , B76 , B77 , B78 being set holds ((B75 in ( D60 /\ R2 ) & B76 in ( D60 /\ R2 ) & B77 in R2 & B78 in R2 & ( R14 . (B75 , B77) ) = ( R14 . (B76 , B78) )) implies (B75 = B76 & B77 = B78)))
proof
let C87 , C88 , C89 , C90 being set;
assume L306: C87 in ( D60 /\ R2 );
L307: C87 in D60 by L306 , XBOOLE_0:def 4;
consider C91 being set such that L308: (C91 in ( dom D58 ) & [ C91 , C87 ] in D58 & C91 in D59) by L307 , RELAT_1:110;
assume L309: C88 in ( D60 /\ R2 );
L310: C88 in D60 by L309 , XBOOLE_0:def 4;
consider C92 being set such that L311: (C92 in ( dom D58 ) & [ C92 , C88 ] in D58 & C92 in D59) by L310 , RELAT_1:110;
assume L312: C89 in R2;
reconsider D61 = C89 as (Element of R2) by L312;
assume L313: C90 in R2;
reconsider D62 = C90 as (Element of R2) by L313;
reconsider D63 = C91 as (Element of ( 1 -tuples_on R3 )) by L308;
reconsider D64 = C92 as (Element of ( 1 -tuples_on R3 )) by L311;
assume L314: ( R14 . (C87 , C89) ) = ( R14 . (C88 , C90) );
L315: (( R14 . (C87 , C89) ) = ( R14 . (C88 , C90) ) & ( D58 . D63 ) = C87 & ( D58 . D64 ) = C88) by L314 , L308 , L311 , FUNCT_1:def 2;
consider C93 being (Element of R3) such that L316: D63 = <* C93 *> by FINSEQ_2:97;
consider C94 being (Element of R3) such that L317: D64 = <* C94 *> by FINSEQ_2:97;
reconsider D65 = C93 , D66 = C94 as (Element of R2);
L318: (( R14 . (( D58 . <* D65 *> ) , C89) ) = ( R14 . (( D58 . <* D66 *> ) , C90) ) & ( D58 . <* D65 *> ) = D65 & ( D58 . <* D66 *> ) = D66) by L315 , L316 , L317 , L245;
L319: (C93 in ( R3 /\ R2 ) & C94 in ( R3 /\ R2 ) & D61 in R2 & D62 in R2 & ( R14 . (C93 , D61) ) = ( R14 . (C94 , D62) )) by L318 , XBOOLE_0:def 4;
thus L320: thesis by L319 , L315 , L316 , L317 , L303 , L277;
end;
thus L321: thesis by L305 , L277;
end;
L322: (for B79 being Nat holds (S6[ B79 ] implies S6[ ( B79 + 1 ) ]))
proof
let C95 being Nat;
assume L323: S6[ C95 ];
set D67 = ( ( ( C95 + 1 ) + 1 ) -tuples_on R3 );
set D68 = ( D58 .: D67 );
L324: (for B80 , B81 , B82 , B83 being set holds ((B80 in ( D68 /\ R2 ) & B81 in ( D68 /\ R2 ) & B82 in R2 & B83 in R2 & ( R14 . (B80 , B82) ) = ( R14 . (B81 , B83) )) implies (B80 = B81 & B82 = B83)))
proof
let C96 , C97 , C98 , C99 being set;
assume L325: C96 in ( D68 /\ R2 );
L326: C96 in D68 by L325 , XBOOLE_0:def 4;
consider C100 being set such that L327: (C100 in ( dom D58 ) & [ C100 , C96 ] in D58 & C100 in D67) by L326 , RELAT_1:110;
assume L328: C97 in ( D68 /\ R2 );
L329: C97 in D68 by L328 , XBOOLE_0:def 4;
consider C101 being set such that L330: (C101 in ( dom D58 ) & [ C101 , C97 ] in D58 & C101 in D67) by L329 , RELAT_1:110;
assume L331: C98 in R2;
reconsider D69 = C98 as (Element of R2) by L331;
assume L332: C99 in R2;
reconsider D70 = C99 as (Element of R2) by L332;
reconsider D71 = C100 as (Element of ( ( ( C95 + 1 ) + 1 ) -tuples_on R3 )) by L327;
reconsider D72 = C101 as (Element of ( ( ( C95 + 1 ) + 1 ) -tuples_on R3 )) by L330;
L333: (( len D71 ) = ( ( C95 + 1 ) + 1 ) & ( len D72 ) = ( ( C95 + 1 ) + 1 ) & ( C95 + 1 ) <= ( ( C95 + 1 ) + 1 )) by CARD_1:def 7 , NAT_1:11;
L334: (D71 = ( ( D71 | ( C95 + 1 ) ) ^ <* ( D71 /. ( len D71 ) ) *> ) & D72 = ( ( D72 | ( C95 + 1 ) ) ^ <* ( D72 /. ( len D72 ) ) *> ) & ( len ( D71 | ( C95 + 1 ) ) ) = ( C95 + 1 ) & ( len ( D72 | ( C95 + 1 ) ) ) = ( C95 + 1 )) by L333 , FINSEQ_1:59 , FINSEQ_5:21;
reconsider D73 = ( D71 | ( C95 + 1 ) ) , D74 = ( D72 | ( C95 + 1 ) ) as (Tuple of ( C95 + 1 ) , R3) by L334 , CARD_1:def 7;
L335: (( rng D73 ) c= R2 & ( rng D74 ) c= R2) by XBOOLE_1:1;
reconsider D75 = D73 , D76 = D74 as non  empty (FinSequence of R2) by L335 , L334 , FINSEQ_1:def 4;
reconsider D77 = D75 , D78 = D76 as (Element of ( ( R2 * ) \ { ( {} ) } )) by L110;
reconsider D79 = D75 , D80 = D78 as (Element of ( ( C95 + 1 ) -tuples_on R3 )) by FINSEQ_2:131;
reconsider D81 = ( D71 /. ( len D71 ) ) , D82 = ( D72 /. ( len D72 ) ) as (Element of R2) by TARSKI:def 3;
L336: (D81 in ( R3 /\ R2 ) & D82 in ( R3 /\ R2 )) by XBOOLE_0:def 4;
L337: (( D58 . ( D75 ^ <* D81 *> ) ) = ( R14 . (( D58 . D75 ) , D81) ) & ( D58 . ( D76 ^ <* D82 *> ) ) = ( R14 . (( D58 . D76 ) , D82) )) by L245;
L338: (( R14 . (( R14 . (( D58 . D77 ) , D81) ) , D69) ) = ( R14 . (( D58 . D77 ) , ( R14 . (D81 , D69) )) ) & ( R14 . (( R14 . (( D58 . D78 ) , D82) ) , D70) ) = ( R14 . (( D58 . D78 ) , ( R14 . (D82 , D70) )) )) by L302 , BINOP_1:def 3;
assume L339: ( R14 . (C96 , C98) ) = ( R14 . (C97 , C99) );
L340: (( R14 . (C96 , C98) ) = ( R14 . (C97 , C99) ) & ( D58 . D71 ) = C96 & ( D58 . D72 ) = C97) by L339 , L327 , L330 , FUNCT_1:def 2;
L341: ( dom D58 ) = ( ( R2 * ) \ { ( {} ) } ) by FUNCT_2:def 1;
L342: (D77 in ( dom D58 ) & D78 in ( dom D58 ) & D79 in ( ( C95 + 1 ) -tuples_on R3 ) & D80 in ( ( C95 + 1 ) -tuples_on R3 )) by L341;
L343: (( D58 . D79 ) in ( D58 .: ( ( C95 + 1 ) -tuples_on R3 ) ) & ( D58 . D80 ) in ( D58 .: ( ( C95 + 1 ) -tuples_on R3 ) ) & ( R14 . (D81 , D69) ) in R2 & ( R14 . (D82 , D70) ) in R2) by L342 , FUNCT_1:def 6;
L344: (( D58 . D79 ) in ( ( D58 .: ( ( C95 + 1 ) -tuples_on R3 ) ) /\ R2 ) & ( D58 . D80 ) in ( ( D58 .: ( ( C95 + 1 ) -tuples_on R3 ) ) /\ R2 ) & ( R14 . (D81 , D69) ) in R2 & ( R14 . (D82 , D70) ) in R2) by L343 , XBOOLE_0:def 4;
L345: (( D58 . D77 ) = ( D58 . D78 ) & ( R14 . (D81 , D69) ) = ( R14 . (D82 , D70) )) by L344 , L340 , L334 , L337 , L338 , L323 , L277;
thus L346: (C96 = C97 & C98 = C99) by L345 , L303 , L277 , L336 , L340 , L334 , L337;
end;
thus L347: thesis by L324 , L277;
end;
L348: (for B84 being Nat holds S6[ B84 ]) from NAT_1:sch 2(L304 , L322);
thus L349: thesis by L348;
end;
L350: (for R2 being non  empty set holds (for R10 being set holds (for R14 being (BinOp of R2) holds (for R16 being Nat holds ((R14 is  associative & R10 is R14 -unambiguous) implies ( ( MultPlace R14 ) .: ( ( R16 + 1 ) -tuples_on R10 ) ) is R14 -unambiguous)))))
proof
let R2 being non  empty set;
let R10 being set;
let R14 being (BinOp of R2);
let R16 being Nat;
set D83 = ( MultPlace R14 );
L351: ( dom D83 ) = ( ( R2 * ) \ { ( {} ) } ) by FUNCT_2:def 1;
assume L352: (R14 is  associative & R10 is R14 -unambiguous);
L353: (R14 is  associative & ( R10 /\ R2 ) is R14 -unambiguous) by L352 , L118 , XBOOLE_1:17;
L354: ( ( R16 + 1 ) -tuples_on ( R10 /\ R2 ) ) misses ( ( 0 ) -tuples_on R10 ) by L41;
L355: ( D83 .: ( ( R16 + 1 ) -tuples_on R10 ) ) = ( D83 .: ( ( ( R2 * ) \ { ( {} ) } ) /\ ( ( R16 + 1 ) -tuples_on R10 ) ) ) by L351 , RELAT_1:112
.= ( D83 .: ( ( ( R2 * ) /\ ( ( R16 + 1 ) -tuples_on R10 ) ) \ { ( {} ) } ) ) by XBOOLE_1:49
.= ( D83 .: ( ( ( R16 + 1 ) -tuples_on ( R10 /\ R2 ) ) \ { ( {} ) } ) ) by L96
.= ( D83 .: ( ( ( R16 + 1 ) -tuples_on ( R10 /\ R2 ) ) \ ( ( 0 ) -tuples_on R10 ) ) ) by COMPUT_1:5
.= ( D83 .: ( ( R16 + 1 ) -tuples_on ( R10 /\ R2 ) ) ) by L354 , XBOOLE_1:83;
per cases ;
suppose L356: ( R10 /\ R2 ) <> ( {} );

reconsider D84 = ( R10 /\ R2 ) as non  empty (Subset of R2) by L356 , XBOOLE_1:17;
L357: ( D83 .: ( ( R16 + 1 ) -tuples_on R10 ) ) = ( D83 .: ( ( R16 + 1 ) -tuples_on D84 ) ) by L355;
thus L358: thesis by L357 , L301 , L353;
end;
suppose L359: ( R10 /\ R2 ) = ( {} );

L360: ( D83 .: ( ( R16 + 1 ) -tuples_on R10 ) ) = ( D83 .: ( {} ) ) by L359 , L355
.= ( {} );
thus L361: thesis by L360 , L123;
end;
end;
L363: (for R2 being non  empty set holds (for R3 being non  empty (Subset of R2) holds (for R14 being (BinOp of R2) holds (for R16 being Nat holds ((R14 is  associative & R3 is R14 -unambiguous) implies ( MultPlace R14 ) is ( ( R16 + 1 ) -tuples_on R3 ) -one-to-one)))))
proof
let R2 being non  empty set;
let R3 being non  empty (Subset of R2);
let R14 being (BinOp of R2);
let R16 being Nat;
set D85 = ( MultPlace R14 );
L364: ( dom D85 ) = ( ( R2 * ) \ { ( {} ) } ) by FUNCT_2:def 1;
defpred S7[ Nat ] means D85 is ( ( $1 + 1 ) -tuples_on R3 ) -one-to-one;
assume L365: (R14 is  associative & R3 is R14 -unambiguous);
L366: S7[ ( 0 ) ]
proof
L367:
now
let C102 , C103 being set;
assume L368: (C102 in ( ( ( ( 0 ) + 1 ) -tuples_on R3 ) /\ ( dom D85 ) ) & C103 in ( ( ( ( 0 ) + 1 ) -tuples_on R3 ) /\ ( dom D85 ) ) & ( D85 . C102 ) = ( D85 . C103 ));
L369: (C102 is (Element of ( 1 -tuples_on R3 )) & C103 is (Element of ( 1 -tuples_on R3 )) & ( D85 . C102 ) = ( D85 . C103 )) by L368 , XBOOLE_0:def 4;
consider C104 being (Element of R3) such that L370: C102 = <* C104 *> by L369 , FINSEQ_2:97;
consider C105 being (Element of R3) such that L371: C103 = <* C105 *> by L369 , FINSEQ_2:97;
reconsider D86 = C104 , D87 = C105 as (Element of R2);
L372: D86 = ( D85 . C103 ) by L368 , L370 , L245
.= D87 by L371 , L245;
thus L373: C102 = C103 by L372 , L370 , L371;
end;
thus L374: D85 is ( ( ( 0 ) + 1 ) -tuples_on R3 ) -one-to-one by L367 , L148;
end;
L375: (for B85 being Nat holds (S7[ B85 ] implies S7[ ( B85 + 1 ) ]))
proof
let C106 being Nat;
assume L376: S7[ C106 ];
set D88 = ( ( ( C106 + 1 ) + 1 ) -tuples_on R3 );
L377:
now
let C107 , C108 being set;
assume L378: (C107 in ( D88 /\ ( dom D85 ) ) & C108 in ( D88 /\ ( dom D85 ) ) & ( D85 . C107 ) = ( D85 . C108 ));
reconsider D89 = C107 , D90 = C108 as (Element of ( ( ( C106 + 1 ) + 1 ) -tuples_on R3 )) by L378 , XBOOLE_0:def 4;
L379: (( len D89 ) = ( ( C106 + 1 ) + 1 ) & ( len D90 ) = ( ( C106 + 1 ) + 1 ) & ( ( C106 + 1 ) + ( 0 ) ) <= ( ( C106 + 1 ) + 1 )) by CARD_1:def 7 , NAT_1:11;
L380: (( len ( D89 | ( C106 + 1 ) ) ) = ( C106 + 1 ) & ( len ( D90 | ( C106 + 1 ) ) ) = ( C106 + 1 )) by L379 , FINSEQ_1:59;
reconsider D91 = ( D89 | ( C106 + 1 ) ) , D92 = ( D90 | ( C106 + 1 ) ) as (Element of ( ( C106 + 1 ) -tuples_on R3 )) by L380 , FINSEQ_2:92;
reconsider D93 = D91 , D94 = D92 as non  empty (FinSequence of R3);
L381: (( rng D93 ) c= R2 & ( rng D94 ) c= R2) by XBOOLE_1:1;
reconsider D95 = D93 , D96 = D94 as non  empty (FinSequence of R2) by L381 , FINSEQ_1:def 4;
reconsider D97 = ( D89 /. ( len D89 ) ) , D98 = ( D90 /. ( len D90 ) ) as (Element of R2) by TARSKI:def 3;
L382: (( D85 . ( D95 ^ <* D97 *> ) ) = ( R14 . (( D85 . D95 ) , D97) ) & ( D85 . ( D96 ^ <* D98 *> ) ) = ( R14 . (( D85 . D96 ) , D98) )) by L245;
L383: (( len D89 ) = ( ( C106 + 1 ) + 1 ) & ( len D90 ) = ( ( C106 + 1 ) + 1 )) by CARD_1:def 7;
L384: (D89 = ( D91 ^ <* D97 *> ) & D90 = ( D92 ^ <* D98 *> )) by L383 , FINSEQ_5:21;
L385: (D95 in ( dom D85 ) & D91 in ( ( C106 + 1 ) -tuples_on R3 ) & D96 in ( dom D85 ) & D92 in ( ( C106 + 1 ) -tuples_on R3 )) by L110 , L364;
L386: (( D85 . D91 ) in ( D85 .: ( ( C106 + 1 ) -tuples_on R3 ) ) & ( D85 . D95 ) in R2 & ( D85 . D92 ) in ( D85 .: ( ( C106 + 1 ) -tuples_on R3 ) ) & ( D85 . D96 ) in R2) by L385 , FUNCT_1:def 6 , PARTFUN1:4;
L387: (( D85 . D91 ) in ( ( D85 .: ( ( C106 + 1 ) -tuples_on R3 ) ) /\ R2 ) & ( D85 . D92 ) in ( ( D85 .: ( ( C106 + 1 ) -tuples_on R3 ) ) /\ R2 ) & D97 in R2 & D98 in R2 & ( R14 . (( D85 . D91 ) , D97) ) = ( R14 . (( D85 . D92 ) , D98) )) by L386 , L384 , L382 , L378 , XBOOLE_0:def 4;
L388: ( D85 .: ( ( C106 + 1 ) -tuples_on R3 ) ) is R14 -unambiguous by L365 , L301;
L389: (( D85 . D91 ) = ( D85 . D92 ) & D97 = D98) by L388 , L387 , L277;
L390: (D91 in ( ( ( C106 + 1 ) -tuples_on R3 ) /\ ( dom D85 ) ) & D92 in ( ( ( C106 + 1 ) -tuples_on R3 ) /\ ( dom D85 ) )) by L385 , XBOOLE_0:def 4;
thus L391: C107 = C108 by L390 , L389 , L376 , L148 , L384;
end;
thus L392: D85 is D88 -one-to-one by L377 , L148;
end;
L393: (for B86 being Nat holds S7[ B86 ]) from NAT_1:sch 2(L366 , L375);
thus L394: thesis by L393;
end;
L395: (for R2 being non  empty set holds (for R10 being set holds (for R14 being (BinOp of R2) holds (for R16 being Nat holds ((R14 is  associative & R10 is R14 -unambiguous) implies ( MultPlace R14 ) is ( ( R16 + 1 ) -tuples_on R10 ) -one-to-one)))))
proof
let R2 being non  empty set;
let R10 being set;
let R14 being (BinOp of R2);
let R16 being Nat;
L396: ( ( R16 + 1 ) -tuples_on R10 ) misses ( ( 0 ) -tuples_on R10 ) by L41;
assume L397: (R14 is  associative & R10 is R14 -unambiguous);
set D99 = ( MultPlace R14 );
L398: ( dom D99 ) = ( ( R2 * ) \ { ( {} ) } ) by FUNCT_2:def 1;
L399: ( D99 | ( ( R16 + 1 ) -tuples_on R10 ) ) = ( ( D99 | ( ( R2 * ) \ { ( {} ) } ) ) | ( ( R16 + 1 ) -tuples_on R10 ) )
.= ( D99 | ( ( ( R2 * ) \ { ( {} ) } ) /\ ( ( R16 + 1 ) -tuples_on R10 ) ) ) by RELAT_1:71
.= ( D99 | ( ( ( R2 * ) /\ ( ( R16 + 1 ) -tuples_on R10 ) ) \ { ( {} ) } ) ) by XBOOLE_1:49
.= ( D99 | ( ( R2 * ) /\ ( ( ( R16 + 1 ) -tuples_on R10 ) \ { ( {} ) } ) ) ) by XBOOLE_1:49
.= ( D99 | ( ( R2 * ) /\ ( ( ( R16 + 1 ) -tuples_on R10 ) \ ( ( 0 ) -tuples_on R10 ) ) ) ) by COMPUT_1:5
.= ( D99 | ( ( R2 * ) /\ ( ( R16 + 1 ) -tuples_on R10 ) ) ) by L396 , XBOOLE_1:83
.= ( D99 | ( ( R16 + 1 ) -tuples_on ( R10 /\ R2 ) ) ) by L96;
L400: ( R10 /\ R2 ) is R14 -unambiguous by L118 , L397 , XBOOLE_1:17;
per cases ;
suppose L401: ( R2 /\ R10 ) <> ( {} );

reconsider D100 = ( R2 /\ R10 ) as non  empty (Subset of R2) by L401 , XBOOLE_1:17;
L402: D99 is ( ( R16 + 1 ) -tuples_on D100 ) -one-to-one by L363 , L400 , L397;
L403: ( D99 | ( ( R16 + 1 ) -tuples_on R10 ) ) is  one-to-one by L402 , L1 , L399;
thus L404: thesis by L403 , L1;
end;
suppose L405: ( R2 /\ R10 ) = ( {} );

thus L406: thesis by L405 , L399 , L1;
end;
end;
definition
let R2 being non  empty set;
func R2 -firstChar -> (Function of ( ( R2 * ) \ { ( {} ) } ) , R2) equals 
( MultPlace ( R2 -pr1 ) );
coherence;
end;
L409: (for R2 being non  empty set holds (for B87 being non  empty (FinSequence of R2) holds ( ( R2 -firstChar ) . B87 ) = ( B87 . 1 )))
proof
let R2 being non  empty set;
let C109 being non  empty (FinSequence of R2);
consider C110 being (Element of R2), C111 being (FinSequence of R2) such that L410: (C110 = ( C109 . 1 ) & C109 = ( <* C110 *> ^ C111 )) by FINSEQ_3:102;
set D101 = ( R2 -pr1 );
set D102 = ( MultPlace D101 );
per cases ;
suppose L411: ( len C109 ) <= 1;

L412: (( len C109 ) <= ( 0 ) or ( len C109 ) = ( ( 0 ) + 1 )) by L411 , NAT_1:8;
L413: C109 = <* C110 *> by L412 , L410 , FINSEQ_1:40;
thus L414: thesis by L413 , L245 , L410;
end;
suppose L415: ( len C109 ) > 1;

L416: ( len C109 ) = ( ( len <* C110 *> ) + ( len C111 ) ) by L410 , FINSEQ_1:22
.= ( 1 + ( len C111 ) ) by FINSEQ_1:40;
L417: ( len C111 ) <> ( 0 ) by L416 , L415;
consider C112 being Nat such that L418: ( len C111 ) = ( C112 + 1 ) by L417 , NAT_1:6;
reconsider D103 = C111 as (Element of ( ( C112 + 1 ) -tuples_on R2 )) by L418 , FINSEQ_2:133;
reconsider D104 = D103 as (Element of ( ( R2 * ) \ { ( {} ) } )) by L110;
L419: ( D102 . C109 ) = ( ( pr1 (R2 , R2) ) . (C110 , ( ( MultPlace D101 ) . D104 )) ) by L410 , L286
.= ( C109 . 1 ) by L410 , FUNCT_3:def 4;
thus L420: thesis by L419;
end;
end;
theorem
L422: (for R1 being non  empty set holds (for B88 being FinSequence holds ((B88 is R1 -valued & B88 is non  empty) implies ( ( R1 -firstChar ) . B88 ) = ( B88 . 1 ))))
proof
let R1 being non  empty set;
let C113 being FinSequence;
assume L423: (C113 is R1 -valued & C113 is non  empty);
reconsider D105 = C113 as non  empty (FinSequence of R1) by L423 , L8;
L424: ( ( R1 -firstChar ) . D105 ) = ( D105 . 1 ) by L409;
thus L425: thesis by L424;
end;
definition
let R2 being non  empty set;
func R2 -multiCat -> Function equals 
( ( ( {} ) .--> ( {} ) ) +* ( MultPlace ( R2 -concatenation ) ) );
coherence;
end;
definition
let R2 being non  empty set;
redefine func R2 -multiCat -> (Function of ( ( R2 * ) * ) , ( R2 * ));

coherence
proof
L427: (( {} ) in ( ( R2 * ) * ) & ( {} ) in ( R2 * )) by FINSEQ_1:49;
L428: ({ ( {} ) } c= ( ( R2 * ) * ) & { ( {} ) } c= ( R2 * )) by L427 , ZFMISC_1:31;
L429: (( { ( {} ) } \/ ( ( R2 * ) * ) ) = ( ( R2 * ) * ) & ( { ( {} ) } \/ ( R2 * ) ) = ( R2 * )) by L428 , XBOOLE_1:12;
set D106 = ( ( {} ) .--> ( {} ) );
set D107 = ( MultPlace ( R2 -concatenation ) );
L430: (( dom D106 ) = { ( {} ) } & ( rng D106 ) c= { ( {} ) }) by FUNCOP_1:13;
L431: (( dom D107 ) = ( ( ( R2 * ) * ) \ { ( {} ) } ) & ( rng D107 ) c= ( R2 * )) by FUNCT_2:def 1;
L432: ( ( dom D106 ) \/ ( dom D107 ) ) = ( { ( {} ) } \/ ( ( R2 * ) * ) ) by L430 , L431 , XBOOLE_1:39;
L433: ( ( dom D106 ) \/ ( dom D107 ) ) = ( ( R2 * ) * ) by L432 , L428 , XBOOLE_1:12;
L434: (( ( rng D106 ) \/ ( rng D107 ) ) c= ( R2 * ) & ( rng ( D106 +* D107 ) ) c= ( ( rng D106 ) \/ ( rng D107 ) )) by L429 , L430 , FUNCT_4:17 , XBOOLE_1:13;
L435: (( dom ( R2 -multiCat ) ) = ( ( R2 * ) * ) & ( rng ( R2 -multiCat ) ) c= ( R2 * )) by L434 , L433 , FUNCT_4:def 1 , XBOOLE_1:1;
thus L436: thesis by L435 , FUNCT_2:67 , RELSET_1:4;
end;
end;
L438: (for R2 being non  empty set holds ( ( R2 -multiCat ) | ( ( ( R2 * ) * ) \ { ( {} ) } ) ) = ( MultPlace ( R2 -concatenation ) ))
proof
let R2 being non  empty set;
set D108 = ( R2 -concatenation );
set D109 = ( MultPlace D108 );
L439: ( dom D109 ) = ( ( ( R2 * ) * ) \ { ( {} ) } ) by FUNCT_2:def 1;
thus L440: thesis by L439 , FUNCT_4:23;
end;
L441: (for R2 being non  empty set holds (for R10 being set holds ( ( R2 -multiCat ) | ( R10 \ { ( {} ) } ) ) = ( ( MultPlace ( R2 -concatenation ) ) | R10 )))
proof
let R2 being non  empty set;
let R10 being set;
set D110 = ( R2 -multiCat );
L442: ( dom D110 ) = ( ( R2 * ) * ) by FUNCT_2:def 1;
L443: ( D110 | ( R10 \ { ( {} ) } ) ) = ( ( D110 | ( ( R2 * ) * ) ) | ( R10 \ { ( {} ) } ) )
.= ( D110 | ( ( ( R2 * ) * ) /\ ( R10 \ { ( {} ) } ) ) ) by RELAT_1:71
.= ( D110 | ( ( ( ( R2 * ) * ) /\ R10 ) \ { ( {} ) } ) ) by XBOOLE_1:49
.= ( ( R2 -multiCat ) | ( R10 /\ ( ( ( R2 * ) * ) \ { ( {} ) } ) ) ) by XBOOLE_1:49
.= ( ( ( R2 -multiCat ) | ( ( ( R2 * ) * ) \ { ( {} ) } ) ) | R10 ) by RELAT_1:71
.= ( ( MultPlace ( R2 -concatenation ) ) | R10 ) by L438;
thus L444: thesis by L443;
end;
L445: (for R2 being non  empty set holds ( ( {} ) .--> ( {} ) ) tolerates ( MultPlace ( R2 -concatenation ) ))
proof
let R2 being non  empty set;
set D111 = ( ( {} ) .--> ( {} ) );
set D112 = ( MultPlace ( R2 -concatenation ) );
L446: (( dom D111 ) = { ( {} ) } & ( dom D112 ) = ( ( ( R2 * ) * ) \ { ( {} ) } )) by FUNCT_2:def 1;
L447: ( dom D112 ) misses ( dom D111 ) by L446 , XBOOLE_1:79;
L448: (for B89 being set holds (B89 in ( ( dom D112 ) /\ ( dom D111 ) ) implies ( D111 . B89 ) = ( D112 . B89 ))) by L447 , XBOOLE_0:def 7;
thus L449: thesis by L448 , PARTFUN1:def 4;
end;
registration
let R2 being non  empty set;
let C114 being  empty set;
cluster ( ( R2 -multiCat ) . C114 ) ->  empty for set;
coherence
proof
set D113 = ( MultPlace ( R2 -concatenation ) );
set D114 = ( ( {} ) .--> ( {} ) );
L450: (( dom D114 ) = { ( {} ) } & ( dom D113 ) = ( ( ( R2 * ) * ) \ { ( {} ) } )) by FUNCT_2:def 1;
L451: ( {} ) in ( dom D114 ) by L450 , TARSKI:def 1;
L452: (( {} ) in ( dom D114 ) & ( {} ) in ( ( dom D113 ) \/ ( dom D114 ) )) by L451 , XBOOLE_0:def 3;
L453: D114 tolerates D113 by L445;
L454: ( R2 -multiCat ) = ( D113 +* D114 ) by L453 , FUNCT_4:34;
L455: (C114 = ( {} ) & ( ( R2 -multiCat ) . ( {} ) ) = ( D114 . ( {} ) )) by L454 , L452 , FUNCT_4:def 1;
thus L456: thesis by L455 , FUNCOP_1:72;
end;
end;
L458: (for R2 being non  empty set holds (for R7 being set holds (for R8 being set holds ((R8 is R2 -prefix & R7 c= R8) implies R7 is R2 -prefix))))
proof
let R2 being non  empty set;
let R7 being set;
let R8 being set;
set D115 = ( R2 -concatenation );
assume L459: (R8 is R2 -prefix & R7 c= R8);
L460: (R8 is D115 -unambiguous & R7 c= R8) by L459 , L5;
L461: R7 is D115 -unambiguous by L460 , L118;
thus L462: thesis by L461 , L5;
end;
registration
let R2 being non  empty set;
cluster  -> R2 -prefix for (Subset of ( 1 -tuples_on R2 ));
coherence
proof
set D116 = ( R2 -concatenation );
set D117 = ( 1 -tuples_on R2 );
let C115 being (Subset of D117);
L463: D117 c= ( R2 * ) by FINSEQ_2:134;
L464:
now
let C116 , C117 , C118 , C119 being set;
assume L465: (C116 in ( C115 /\ ( R2 * ) ) & C117 in ( C115 /\ ( R2 * ) ) & C118 in ( R2 * ) & C119 in ( R2 * ));
reconsider D118 = C116 , D119 = C117 as (Element of D117) by L465;
reconsider D120 = D118 , D121 = D119 as 1 -element FinSequence;
reconsider D122 = D118 , D123 = D119 as (Element of ( R2 * )) by L463 , TARSKI:def 3;
reconsider D124 = D122 , D125 = D123 , D126 = C118 , D127 = C119 as (FinSequence of R2) by L465 , FINSEQ_1:def 11;
L466: (( len D124 ) = 1 & ( len D125 ) = 1) by CARD_1:def 7;
L467: (D124 = <* ( D124 . 1 ) *> & D125 = <* ( D125 . 1 ) *>) by L466 , FINSEQ_1:40;
L468: (( D116 . (C116 , C118) ) = ( D124 ^ D126 ) & ( D116 . (C117 , C119) ) = ( D125 ^ D127 )) by L102;
assume L469: ( D116 . (C116 , C118) ) = ( D116 . (C117 , C119) );
L470: ( D124 . 1 ) = ( ( D124 ^ D126 ) . 1 ) by L467 , FINSEQ_1:41
.= ( D125 . 1 ) by L467 , L469 , L468 , FINSEQ_1:41;
thus L471: (C116 = C117 & C118 = C119) by L470 , L467 , L469 , L468 , FINSEQ_1:33;
end;
L472: C115 is D116 -unambiguous by L464 , L277;
thus L473: thesis by L472 , L5;
end;
end;
theorem
L475: (for R2 being non  empty set holds (for R7 being set holds (for R16 being Nat holds (R7 is R2 -prefix implies ( ( R2 -multiCat ) .: ( R16 -tuples_on R7 ) ) is R2 -prefix))))
proof
let R2 being non  empty set;
let R7 being set;
let R16 being Nat;
reconsider D128 = ( R2 -concatenation ) as (BinOp of ( R2 * ));
set D129 = ( R2 -multiCat );
set D130 = ( D129 .: ( R16 -tuples_on R7 ) );
L476: ( {} ) in ( ( R2 * ) * ) by FINSEQ_1:49;
L477: ( {} ) in ( dom D129 ) by L476 , FUNCT_2:def 1;
per cases ;
suppose L478: R16 = ( 0 );

L479: D130 = ( D129 .: { ( <*> R7 ) } ) by L478 , FINSEQ_2:94
.= ( Im (D129 , ( {} )) )
.= { ( D129 . ( {} ) ) } by L477 , FUNCT_1:59
.= { ( {} ) };
L480: (for B90 , B91 , B92 , B93 being set holds ((B90 in ( D130 /\ ( R2 * ) ) & B91 in ( D130 /\ ( R2 * ) ) & B92 in ( R2 * ) & B93 in ( R2 * ) & ( D128 . (B90 , B92) ) = ( D128 . (B91 , B93) )) implies (B90 = B91 & B92 = B93)))
proof
let C120 , C121 , C122 , C123 being set;
assume L481: (C120 in ( D130 /\ ( R2 * ) ) & C121 in ( D130 /\ ( R2 * ) ) & C122 in ( R2 * ) & C123 in ( R2 * ) & ( D128 . (C120 , C122) ) = ( D128 . (C121 , C123) ));
L482: (C120 in D130 & C120 in ( R2 * ) & C121 in D130 & C121 in ( R2 * )) by L481 , XBOOLE_0:def 4;
L483: (C120 = ( {} ) & C121 = ( {} )) by L482 , L479 , TARSKI:def 1;
reconsider D131 = C120 as (Element of ( R2 * )) by L481;
reconsider D132 = C121 as (Element of ( R2 * )) by L481;
reconsider D133 = C122 as (Element of ( R2 * )) by L481;
reconsider D134 = C123 as (Element of ( R2 * )) by L481;
L484: D133 = ( D131 ^ D133 ) by L483 , FINSEQ_1:34
.= ( D128 . (D132 , D134) ) by L102 , L481
.= ( ( {} ) ^ D134 ) by L483 , L102
.= D134 by FINSEQ_1:34;
thus L485: (C120 = C121 & C122 = C123) by L484 , L483;
end;
L486: D130 is D128 -unambiguous by L480 , L277;
thus L487: thesis by L486 , L5;
end;
suppose L488: R16 <> ( 0 );

consider C124 being Nat such that L489: R16 = ( C124 + 1 ) by L488 , NAT_1:6;
set D135 = ( ( C124 + 1 ) -tuples_on R7 );
L490: D135 misses ( ( 0 ) -tuples_on R7 ) by L41;
L491: D135 misses { ( {} ) } by L490 , COMPUT_1:5;
L492: ( D135 \ { ( {} ) } ) = D135 by L491 , XBOOLE_1:83;
assume L493: R7 is R2 -prefix;
L494: R7 is D128 -unambiguous by L493 , L5;
L495: ( ( MultPlace D128 ) .: D135 ) is D128 -unambiguous by L494 , L350;
L496: ( D129 .: D135 ) = ( ( D129 | ( D135 \ { ( {} ) } ) ) .: ( D135 \ { ( {} ) } ) ) by L492 , RELAT_1:129
.= ( ( ( MultPlace D128 ) | D135 ) .: D135 ) by L492 , L441
.= ( ( MultPlace D128 ) .: D135 ) by RELAT_1:129;
thus L497: thesis by L496 , L489 , L495 , L5;
end;
end;
theorem
L499: (for R2 being non  empty set holds (for R7 being set holds (for R16 being Nat holds (R7 is R2 -prefix implies ( R2 -multiCat ) is ( R16 -tuples_on R7 ) -one-to-one))))
proof
let R2 being non  empty set;
let R7 being set;
let R16 being Nat;
set D136 = ( R2 -concatenation );
set D137 = ( R2 -multiCat );
set D138 = ( R16 -tuples_on R7 );
assume L500: R7 is R2 -prefix;
L501: (D136 is  associative & R7 is D136 -unambiguous) by L500 , L5;
per cases ;
suppose L502: R16 = ( 0 );

L503: D138 = ( Funcs (( Seg ( 0 ) ) , R7) ) by L502 , L48
.= { ( {} ) } by FUNCT_5:57;
L504: ( D137 | D138 ) is  one-to-one by L503;
thus L505: thesis by L504 , L1;
end;
suppose L506: R16 <> ( 0 );

consider C125 being Nat such that L507: R16 = ( C125 + 1 ) by L506 , NAT_1:6;
reconsider D139 = ( C125 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
set D140 = ( D139 -tuples_on R7 );
L508: ( MultPlace D136 ) is D140 -one-to-one by L501 , L395;
L509: ( ( MultPlace D136 ) | D140 ) is  one-to-one by L508 , L1;
L510: ( len ( {} ) ) = ( 0 );
L511: (not ( {} ) in D140) by L510 , FINSEQ_2:132;
L512: { ( {} ) } misses D140 by L511 , ZFMISC_1:50;
L513: ( D140 \ { ( {} ) } ) = D140 by L512 , XBOOLE_1:83;
L514: ( D137 | D138 ) is  one-to-one by L513 , L441 , L509 , L507;
thus L515: thesis by L514 , L1;
end;
end;
theorem
L517: (for R10 being set holds (for R16 being Nat holds ( ( R16 + 1 ) -tuples_on R10 ) c= ( ( R10 * ) \ { ( {} ) } )))
proof
let R10 being set;
let R16 being Nat;
reconsider D141 = R16 , D142 = ( R16 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
L518: ( ( 0 ) -tuples_on R10 ) misses ( D142 -tuples_on R10 ) by L41;
L519: ( D142 -tuples_on R10 ) c= ( ( R10 * ) \ ( ( 0 ) -tuples_on R10 ) ) by L518 , FINSEQ_2:134 , XBOOLE_1:86;
thus L520: thesis by L519 , COMPUT_1:5;
end;
theorem
L521: (for R10 being set holds (for R16 being Nat holds (R16 is  zero implies ( R16 -tuples_on R10 ) = { ( {} ) }))) by COMPUT_1:5;
theorem
L522: (for R10 being set holds (for R15 being Nat holds ( R15 -tuples_on R10 ) = ( Funcs (( Seg R15 ) , R10) ))) by L48;
theorem
L523: (for R7 being set holds (for R11 being set holds (for R16 being Nat holds (R11 in ( R16 -tuples_on R7 ) implies R11 is (FinSequence of R7)))))
proof
let R7 being set;
let R11 being set;
let R16 being Nat;
assume L524: R11 in ( R16 -tuples_on R7 );
reconsider D143 = R11 as R16 -element FinSequence by L524 , FINSEQ_2:141;
L525: D143 in ( Funcs (( Seg R16 ) , R7) ) by L524 , L48;
consider C126 being Function such that L526: (D143 = C126 & ( dom C126 ) = ( Seg R16 ) & ( rng C126 ) c= R7) by L525 , FUNCT_2:def 2;
thus L527: R11 is (FinSequence of R7) by L526 , FINSEQ_1:def 4;
end;
definition
let C127 , C128 being set;
redefine func chi (C127 , C128) -> (Function of C128 , ( BOOLEAN ));

coherence
proof
L528: (( chi (C127 , C128) ) is (Function of C128 , { ( {} ) , 1 }) & { ( {} ) , 1 } = ( BOOLEAN ));
thus L529: thesis by L528;
end;
end;
theorem
L531: (for R2 being non  empty set holds (for R4 being (Element of R2) holds (for R14 being (BinOp of R2) holds (( ( MultPlace R14 ) . <* R4 *> ) = R4 & (for B94 being non  empty (FinSequence of R2) holds ( ( MultPlace R14 ) . ( B94 ^ <* R4 *> ) ) = ( R14 . (( ( MultPlace R14 ) . B94 ) , R4) )))))) by L245;
theorem
L532: (for R2 being non  empty set holds (for B95 being non  empty (Element of ( ( R2 * ) * )) holds ( ( R2 -multiCat ) . B95 ) = ( ( MultPlace ( R2 -concatenation ) ) . B95 )))
proof
let R2 being non  empty set;
let C129 being non  empty (Element of ( ( R2 * ) * ));
set D144 = ( R2 -concatenation );
set D145 = ( R2 -multiCat );
L533: (not C129 in { ( {} ) }) by TARSKI:def 1;
L534: C129 in ( ( ( R2 * ) * ) \ { ( {} ) } ) by L533 , XBOOLE_0:def 5;
thus L535: ( D145 . C129 ) = ( ( D145 | ( ( ( R2 * ) * ) \ { ( {} ) } ) ) . C129 ) by L534 , FUNCT_1:49
.= ( ( MultPlace D144 ) . C129 ) by L438;
end;
theorem
L536: (for R2 being non  empty set holds (for B96 , B97 being (Element of ( R2 * )) holds ( ( R2 -multiCat ) . <* B96 , B97 *> ) = ( B96 ^ B97 )))
proof
let R2 being non  empty set;
let C130 , C131 being (Element of ( R2 * ));
set D146 = ( R2 -multiCat );
set D147 = ( R2 -concatenation );
set D148 = <* C130 , C131 *>;
reconsider D149 = ( <* C130 *> ^ <* C131 *> ) as non  empty (Element of ( ( R2 * ) * ));
L537: ( D146 . D149 ) = ( ( MultPlace D147 ) . D149 ) by L532;
thus L538: ( D146 . D148 ) = ( D147 . (( ( MultPlace D147 ) . <* C130 *> ) , C131) ) by L245 , L537
.= ( D147 . (C130 , C131) ) by L245
.= ( C130 ^ C131 ) by L102;
end;
registration
let C132 , C133 being FinSequence;
cluster <: C132 , C133 :> ->  FinSequence-like;
coherence
proof
set D150 = ( len C132 );
set D151 = ( len C133 );
set D152 = ( min (D150 , D151) );
L539: ( dom <: C132 , C133 :> ) = ( Seg D152 ) by L127;
thus L540: thesis by L539 , FINSEQ_1:def 2;
end;
end;
registration
let R16 being Nat;
let C134 , C135 being R16 -element FinSequence;
cluster <: C134 , C135 :> -> R16 -element;
coherence
proof
set D153 = ( min (( len C134 ) , ( len C135 )) );
L542: (( len C134 ) = R16 & ( len C135 ) = R16) by CARD_1:def 7;
reconsider D154 = <: C134 , C135 :> as FinSequence;
reconsider D155 = D153 as (Element of ( NAT )) by ORDINAL1:def 12;
L543: ( dom D154 ) = ( Seg D155 ) by L127;
L544: ( len D154 ) = D155 by L543 , FINSEQ_1:def 3;
thus L545: thesis by L544 , L542 , CARD_1:def 7;
end;
end;
registration
let C136 , C137 being set;
let C138 being C136 -defined Function;
let C139 being C137 -defined Function;
cluster <: C138 , C139 :> -> ( C136 /\ C137 ) -defined for Function;
coherence
proof
reconsider D156 = ( dom C138 ) as (Subset of C136);
reconsider D157 = ( dom C139 ) as (Subset of C137);
set D158 = <: C138 , C139 :>;
L547: ( dom D158 ) = ( D157 /\ D156 ) by FUNCT_3:def 7;
L548: ( ( dom D158 ) /\ ( dom D158 ) ) c= ( C136 /\ C137 ) by L547 , XBOOLE_1:27;
thus L549: thesis by L548 , RELAT_1:def 18;
end;
end;
registration
let C140 being set;
let C141 , C142 being C140 -defined Function;
cluster <: C141 , C142 :> -> C140 -defined for Function;
coherence;
end;
registration
let C143 , C144 being set;
let C145 being  total C143 -defined Function;
let C146 being  total C144 -defined Function;
cluster <: C145 , C146 :> ->  total for ( C143 /\ C144 ) -defined ( C143 /\ C144 ) -defined ( C143 /\ C144 ) -defined ( C143 /\ C144 ) -defined Function;
coherence
proof
reconsider D159 = <: C145 , C146 :> as ( C143 /\ C144 ) -defined Function;
L552: (( dom C145 ) = C143 & ( dom C146 ) = C144) by PARTFUN1:def 2;
L553: ( dom D159 ) = ( C143 /\ C144 ) by L552 , FUNCT_3:def 7;
thus L554: thesis by L553 , PARTFUN1:def 2;
end;
end;
registration
let C147 being set;
let C148 , C149 being  total C147 -defined Function;
cluster <: C148 , C149 :> ->  total for C147 -defined C147 -defined C147 -defined C147 -defined Function;
coherence;
end;
registration
let C150 , C151 being set;
let C152 being C150 -valued Function;
let C153 being C151 -valued Function;
cluster <: C152 , C153 :> -> [: C150 , C151 :] -valued for Function;
coherence
proof
set D160 = <: C152 , C153 :>;
L557: ( rng D160 ) c= [: ( rng C152 ) , ( rng C153 ) :] by FUNCT_3:51;
L558: ( rng D160 ) c= [: C150 , C151 :] by L557 , XBOOLE_1:1;
thus L559: thesis by L558 , RELAT_1:def 19;
end;
end;
registration
let R2 being non  empty set;
cluster R2 -valued for FinSequence;
existence
proof
take the (FinSequence of R2);
thus L561: thesis;
end;
end;
registration
let R2 being non  empty set;
let R16 being Nat;
cluster R16 -element for R2 -valued R2 -valued R2 -valued R2 -valued FinSequence;
existence
proof
take the R16 -element (FinSequence of R2);
thus L563: thesis;
end;
end;
registration
let C154 , C155 being non  empty set;
let C156 being (Function of C154 , C155);
let C157 being C154 -valued FinSequence;
cluster ( C156 * C157 ) ->  FinSequence-like;
coherence
proof
L565: ( rng C157 ) c= C154;
reconsider D161 = C157 as (FinSequence of C154) by L565 , FINSEQ_1:def 4;
L566: ( C156 * D161 ) is (FinSequence of C155);
thus L567: thesis by L566;
end;
end;
registration
let C158 , C159 being non  empty set;
let R16 being Nat;
let C160 being (Function of C158 , C159);
let C161 being R16 -element C158 -valued FinSequence;
cluster ( C160 * C161 ) -> R16 -element;
coherence
proof
reconsider D162 = R16 as (Element of ( NAT )) by ORDINAL1:def 12;
L569: (( rng C161 ) c= C158 & ( dom C160 ) = C158) by FUNCT_2:def 1;
L570: ( dom ( C160 * C161 ) ) = ( dom C161 ) by L569 , RELAT_1:27
.= ( Seg ( len C161 ) ) by FINSEQ_1:def 3
.= ( Seg D162 ) by CARD_1:def 7;
L571: ( len ( C160 * C161 ) ) = D162 by L570 , FINSEQ_1:def 3;
thus L572: thesis by L571 , CARD_1:def 7;
end;
end;
definition
let R2 being non  empty set;
let R14 being (BinOp of R2);
let C162 , C163 being (Element of ( R2 * ));
func R14 AppliedPairwiseTo (C162 , C163) -> (FinSequence of R2) equals 
( R14 * <: C162 , C163 :> );
coherence
proof
L574: ( rng ( R14 * <: C162 , C163 :> ) ) c= R2;
thus L575: thesis by L574 , FINSEQ_1:def 4;
end;
end;
registration
let R2 being non  empty set;
let R14 being (BinOp of R2);
let R16 being Nat;
let C164 , C165 being R16 -element (Element of ( R2 * ));
cluster ( R14 AppliedPairwiseTo (C164 , C165) ) -> R16 -element;
coherence;
end;
notation
let R2 being non  empty set;
let R14 being (BinOp of R2);
let C166 , C167 being (Element of ( R2 * ));
synonym R14 _\ (C166 , C167) for R14 AppliedPairwiseTo (C166 , C167);
end;
definition
redefine func INT equals 
( ( NAT ) \/ ( [: { ( 0 ) } , ( NAT ) :] \ { [ ( 0 ) , ( 0 ) ] } ) );
compatibility
proof
L579: (not [ ( 0 ) , ( 0 ) ] in ( NAT )) by ARYTM_3:32;
L580: ( INT ) = ( ( ( NAT ) \ { [ ( 0 ) , ( 0 ) ] } ) \/ ( [: { ( 0 ) } , ( NAT ) :] \ { [ ( 0 ) , ( 0 ) ] } ) ) by NUMBERS:def 4 , XBOOLE_1:42
.= ( ( NAT ) \/ ( [: { ( 0 ) } , ( NAT ) :] \ { [ ( 0 ) , ( 0 ) ] } ) ) by L579 , ZFMISC_1:57;
thus L581: thesis by L580;
end;
end;
theorem
L583: (for R10 being set holds (for R16 being Nat holds (for B98 being FinSequence holds ((B98 is R10 -valued & B98 is R16 -element) implies B98 in ( R16 -tuples_on R10 )))))
proof
let R10 being set;
let R16 being Nat;
reconsider D163 = R16 as (Element of ( NAT )) by ORDINAL1:def 12;
let C168 being FinSequence;
assume L584: (C168 is R10 -valued & C168 is R16 -element);
L585: (( rng C168 ) c= R10 & ( len C168 ) = D163) by L584 , CARD_1:def 7 , RELAT_1:def 19;
thus L586: thesis by L585 , FINSEQ_2:132;
end;
definition
let R7 being set;
let R8 being set;
func R7 typed/\ R8 -> (Subset of R7) equals 
( R7 /\ R8 );
coherence by XBOOLE_1:17;
func R7 /\typed R8 -> (Subset of R8) equals 
( R7 /\ R8 );
coherence by XBOOLE_1:17;
end;
registration
let R7 being set;
let R8 being set;
identify R7 /\ R8 with R7 typed/\ R8;
compatibility;
identify R7 typed/\ R8 with R7 /\ R8;
compatibility;
identify R7 /\ R8 with R7 /\typed R8;
compatibility;
identify R7 /\typed R8 with R7 /\ R8;
compatibility;
end;
definition
let R8 being set;
let R7 being set;
func R7 null R8 equals 
R7;
coherence;
end;
registration
let R7 being set;
let C169 being (Subset of R7);
identify R7 /\ C169 with C169 null R7;
compatibility by XBOOLE_1:28;
identify C169 null R7 with R7 /\ C169;
compatibility;
end;
registration
let R7 being set;
let R8 being set;
let R9 being set;
cluster ( ( R8 \ R7 ) /\ ( R7 /\ R9 ) ) ->  empty for set;
coherence
proof
set D164 = ( R8 \ R7 );
set D165 = ( R7 /\ R9 );
L591: (D164 misses R7 & D165 c= R7) by XBOOLE_1:79;
L592: D164 misses D165 by L591 , XBOOLE_1:63;
thus L593: thesis by L592 , XBOOLE_0:def 7;
end;
end;
definition
let R7 being set;
let R8 being set;
func R7 typed\ R8 -> (Subset of R7) equals 
( R7 \ R8 );
coherence;
end;
registration
let R7 being set;
let R8 being set;
identify R7 \ R8 with R7 typed\ R8;
compatibility;
identify R7 typed\ R8 with R7 \ R8;
compatibility;
end;
definition
let R7 being set;
let R8 being set;
func R7 \typed/ R8 -> (Subset of ( R7 \/ R8 )) equals 
R7;
coherence by XBOOLE_1:7;
end;
registration
let R7 being set;
let R8 being set;
identify R7 \typed/ R8 with R7 null R8;
compatibility;
identify R7 null R8 with R7 \typed/ R8;
compatibility;
end;
registration
let R7 being set;
let C170 being (Subset of R7);
identify R7 \/ C170 with R7 null C170;
compatibility by XBOOLE_1:12;
identify R7 null C170 with R7 \/ C170;
compatibility;
end;
L600: (for R16 being Nat holds (for R18 being Function holds (for R23 being Function holds (R23 c= R18 implies ( iter (R23 , R16) ) c= ( iter (R18 , R16) )))))
proof
let R16 being Nat;
let R18 being Function;
let R23 being Function;
assume L601: R23 c= R18;
defpred S8[ Nat ] means ( iter (R23 , $1) ) c= ( iter (R18 , $1) );
L602: S8[ ( 0 ) ]
proof
L603: (( iter (R23 , ( 0 )) ) = ( id ( field R23 ) ) & ( iter (R18 , ( 0 )) ) = ( id ( field R18 ) )) by FUNCT_7:68;
L604: (( dom R23 ) c= ( dom R18 ) & ( rng R23 ) c= ( rng R18 )) by L601 , RELAT_1:11;
L605: ( ( dom R23 ) \/ ( rng R23 ) ) c= ( ( dom R18 ) \/ ( rng R18 ) ) by L604 , XBOOLE_1:13;
thus L606: thesis by L605 , L603 , FUNCT_4:3;
end;
L607: (for R17 being Nat holds (S8[ R17 ] implies S8[ ( R17 + 1 ) ]))
proof
let R17 being Nat;
assume L608: S8[ R17 ];
L609: ( R23 * ( iter (R23 , R17) ) ) c= ( R18 * ( iter (R18 , R17) ) ) by L608 , L601 , RELAT_1:31;
L610: ( iter (R23 , ( R17 + 1 )) ) c= ( R18 * ( iter (R18 , R17) ) ) by L609 , FUNCT_7:71;
thus L611: thesis by L610 , FUNCT_7:71;
end;
L612: (for R17 being Nat holds S8[ R17 ]) from NAT_1:sch 2(L602 , L607);
thus L613: thesis by L612;
end;
L614: (for R22 being Relation holds ( R22 [*] ) is_transitive_in ( field R22 ))
proof
let R22 being Relation;
set D166 = ( field R22 );
set D167 = ( R22 [*] );
L615:
now
let R11 being set;
let R12 being set;
let R13 being set;
assume L616: (R11 in D166 & R12 in D166 & R13 in D166);
assume L617: ([ R11 , R12 ] in D167 & [ R12 , R13 ] in D167);
consider C171 being FinSequence such that L618: (( len C171 ) >= 1 & ( C171 . 1 ) = R11 & ( C171 . ( len C171 ) ) = R12 & (for B99 being Nat holds ((B99 >= 1 & B99 < ( len C171 )) implies [ ( C171 . B99 ) , ( C171 . ( B99 + 1 ) ) ] in R22))) by L617 , FINSEQ_1:def 16;
consider C172 being Nat such that L619: ( len C171 ) = ( C172 + 1 ) by L618 , NAT_1:6;
consider C173 being FinSequence such that L620: (( len C173 ) >= 1 & ( C173 . 1 ) = R12 & ( C173 . ( len C173 ) ) = R13 & (for B100 being Nat holds ((B100 >= 1 & B100 < ( len C173 )) implies [ ( C173 . B100 ) , ( C173 . ( B100 + 1 ) ) ] in R22))) by L617 , FINSEQ_1:def 16;
L621: 1 in ( dom C173 ) by L620 , FINSEQ_3:25;
reconsider D168 = ( len C171 ) , D169 = ( len C173 ) as non  zero Nat by L618 , L620;
reconsider D170 = ( C171 | ( Seg C172 ) ) as FinSequence;
set D171 = ( D170 ^ C173 );
L622: ( C172 + ( 0 ) ) < ( C172 + 1 ) by XREAL_1:8;
L623: ( len D170 ) = C172 by L622 , L619 , FINSEQ_1:17;
L624: ( C172 + D169 ) >= ( ( 0 ) + 1 ) by L620 , XREAL_1:7;
L625: (for R17 being Nat holds ((R17 >= 1 & R17 <= ( len C173 )) implies ( D171 . ( C172 + R17 ) ) = ( C173 . R17 )))
proof
let R17 being Nat;
reconsider D172 = R17 as (Element of ( NAT )) by ORDINAL1:def 12;
L626: D172 = R17;
assume L627: (R17 >= 1 & R17 <= ( len C173 ));
L628: R17 in ( Seg ( len C173 ) ) by L627 , L626;
L629: R17 in ( dom C173 ) by L628 , FINSEQ_1:def 3;
thus L630: thesis by L629 , L623 , FINSEQ_1:def 7;
end;
L631: ( D171 . 1 ) = R11
proof
per cases ;
suppose L632: C172 = ( 0 );

thus L633: ( D171 . 1 ) = R11 by L632 , L619 , L618 , L625 , L620;
end;
suppose L634: C172 <> ( 0 );

L635: ( ( 0 ) + 1 ) <= C172 by L634 , INT_1:7;
L636: 1 in ( Seg C172 ) by L635;
L637: 1 in ( dom D170 ) by L636 , L622 , L619 , FINSEQ_1:17;
thus L638: ( D171 . 1 ) = ( D170 . 1 ) by L637 , FINSEQ_1:def 7
.= R11 by L618 , L637 , FUNCT_1:47;
end;
end;
L640: D169 in ( Seg D169 ) by L620;
L641: D169 in ( dom C173 ) by L640 , FINSEQ_1:def 3;
L642: ( D171 . ( ( len D170 ) + ( len C173 ) ) ) = R13 by L641 , L620 , FINSEQ_1:def 7;
L643: (for B101 being Nat holds ((B101 >= 1 & B101 < ( len D171 )) implies [ ( D171 . B101 ) , ( D171 . ( B101 + 1 ) ) ] in R22))
proof
let C174 being Nat;
assume L644: (C174 >= 1 & C174 < ( len D171 ));
L645: (( C174 + 1 ) >= 1 & C174 >= 1 & C174 < ( len D171 )) by L644 , NAT_1:11;
per cases  by XXREAL_0:1;
suppose L646: C174 < C172;

L647: (C174 < D168 & C174 < C172 & ( C174 + 1 ) <= C172) by L646 , L622 , L619 , INT_1:7 , XXREAL_0:2;
L648: (C174 in ( Seg C172 ) & ( C174 + 1 ) in ( Seg C172 )) by L647 , L645 , FINSEQ_1:1;
L649: (C174 in ( dom D170 ) & ( C174 + 1 ) in ( dom D170 )) by L648 , L622 , L619 , FINSEQ_1:17;
L650: (( D171 . C174 ) = ( D170 . C174 ) & ( D171 . ( C174 + 1 ) ) = ( D170 . ( C174 + 1 ) )) by L649 , FINSEQ_1:def 7;
L651: (( D171 . C174 ) = ( C171 . C174 ) & ( D171 . ( C174 + 1 ) ) = ( C171 . ( C174 + 1 ) )) by L650 , L649 , FUNCT_1:47;
thus L652: [ ( D171 . C174 ) , ( D171 . ( C174 + 1 ) ) ] in R22 by L651 , L618 , L644 , L647;
end;
suppose L653: C174 = C172;

L654: C172 in ( dom D170 ) by L653 , L644 , L623 , FINSEQ_3:25;
L655: ( D171 . C172 ) = ( D170 . C172 ) by L654 , FINSEQ_1:def 7
.= ( C171 . C172 ) by L654 , FUNCT_1:47;
L656: ( D171 . ( C172 + 1 ) ) = ( C171 . ( C172 + 1 ) ) by L618 , L621 , L619 , L623 , L620 , FINSEQ_1:def 7;
thus L657: [ ( D171 . C174 ) , ( D171 . ( C174 + 1 ) ) ] in R22 by L653 , L655 , L656 , L618 , L644 , L622 , L619;
end;
suppose L658: C174 > C172;

consider C175 being Nat such that L659: C174 = ( C172 + C175 ) by L658 , NAT_1:10;
L660: C175 <> ( 0 ) by L658 , L659;
L661: C175 >= ( ( 0 ) + 1 ) by L660 , INT_1:7;
L662: (C175 >= 1 & ( C175 + 1 ) >= ( 1 + ( 0 ) )) by L661 , XREAL_1:7;
L663: ( C172 + C175 ) < ( C172 + D169 ) by L659 , L644 , L623 , FINSEQ_1:22;
L664: C175 < D169 by L663 , XREAL_1:7;
L665: (C175 <= D169 & ( C175 + 1 ) <= D169) by L664 , INT_1:7;
L666: (C175 in ( Seg D169 ) & ( C175 + 1 ) in ( Seg D169 )) by L665 , L662 , FINSEQ_1:1;
L667: (C175 in ( dom C173 ) & ( C175 + 1 ) in ( dom C173 )) by L666 , FINSEQ_1:def 3;
L668: ( D171 . C174 ) = ( C173 . C175 ) by L667 , L659 , L623 , FINSEQ_1:def 7;
L669: ( D171 . ( C174 + 1 ) ) = ( D171 . ( ( len D170 ) + ( C175 + 1 ) ) ) by L659 , L623
.= ( C173 . ( C175 + 1 ) ) by L667 , FINSEQ_1:def 7;
thus L670: [ ( D171 . C174 ) , ( D171 . ( C174 + 1 ) ) ] in R22 by L668 , L669 , L620 , L664 , L661;
end;
end;
L672: (R11 in D166 & R13 in D166 & ( len D171 ) >= 1 & ( D171 . 1 ) = R11 & ( D171 . ( len D171 ) ) = R13 & (for B102 being Nat holds ((B102 >= 1 & B102 < ( len D171 )) implies [ ( D171 . B102 ) , ( D171 . ( B102 + 1 ) ) ] in R22))) by L616 , L624 , L623 , L631 , L642 , L643 , FINSEQ_1:22;
thus L673: [ R11 , R13 ] in D167 by L672 , FINSEQ_1:def 16;
end;
thus L674: thesis by L615 , RELAT_2:def 8;
end;
L675: (for R22 being Relation holds ( field ( R22 [*] ) ) c= ( field R22 ))
proof
let R22 being Relation;
set D173 = ( R22 [*] );
set D174 = ( field D173 );
set D175 = ( field R22 );
L676:
now
let R11 being set;
assume L677: R11 in D174;
per cases  by L677 , XBOOLE_0:def 3;
suppose L678: R11 in ( dom D173 );

consider R12 being set such that L679: [ R11 , R12 ] in D173 by L678 , XTUPLE_0:def 12;
thus L680: R11 in D175 by L679 , FINSEQ_1:def 16;
end;
suppose L681: R11 in ( rng D173 );

consider R12 being set such that L682: [ R12 , R11 ] in D173 by L681 , XTUPLE_0:def 13;
thus L683: R11 in D175 by L682 , FINSEQ_1:def 16;
end;
end;
thus L685: thesis by L676 , TARSKI:def 3;
end;
L686: (for R22 being Relation holds ( R22 [*] ) is_reflexive_in ( field R22 ))
proof
let R22 being Relation;
set D176 = ( R22 [*] );
set D177 = ( field R22 );
L687:
now
let R11 being set;
reconsider D178 = <* R11 *> as 1 -element FinSequence;
L688: (( len D178 ) = 1 & ( D178 . 1 ) = R11) by FINSEQ_1:40;
L689: (( len D178 ) >= 1 & ( D178 . 1 ) = R11 & ( D178 . ( len D178 ) ) = R11 & (for R15 being Nat holds ((R15 >= 1 & R15 < ( len D178 )) implies [ ( D178 . R15 ) , ( D178 . ( R15 + 1 ) ) ] in R22))) by L688;
assume L690: R11 in D177;
thus L691: [ R11 , R11 ] in D176 by L690 , L689 , FINSEQ_1:def 16;
end;
thus L692: thesis by L687 , RELAT_2:def 1;
end;
L693: (for R22 being Relation holds ( field ( R22 [*] ) ) = ( field R22 ))
proof
let R22 being Relation;
set D179 = ( field ( R22 [*] ) );
set D180 = ( field R22 );
L694: D180 c= D179 by LANG1:18 , RELAT_1:16;
L695: D179 c= D180 by L675;
thus L696: thesis by L695 , L694 , XBOOLE_0:def 10;
end;
registration
let C176 being Relation;
cluster ( C176 [*] ) ->  transitive for Relation;
coherence
proof
L697: ( C176 [*] ) is_transitive_in ( field C176 ) by L614;
L698: ( C176 [*] ) is_transitive_in ( field ( C176 [*] ) ) by L697 , L693;
thus L699: thesis by L698 , RELAT_2:def 16;
end;
cluster ( C176 [*] ) ->  reflexive for Relation;
coherence
proof
L700: ( C176 [*] ) is_reflexive_in ( field C176 ) by L686;
L701: ( C176 [*] ) is_reflexive_in ( field ( C176 [*] ) ) by L700 , L693;
thus L702: thesis by L701 , RELAT_2:def 9;
end;
end;
L704: (for R23 being Function holds ( iter (R23 , ( 0 )) ) c= ( R23 [*] ))
proof
let R23 being Function;
set D181 = ( iter (R23 , ( 0 )) );
set D182 = ( R23 [*] );
L705: D181 = ( id ( field R23 ) ) by FUNCT_7:68
.= ( id ( field D182 ) ) by L693;
thus L706: thesis by L705 , RELAT_2:1;
end;
L707: (for R16 being Nat holds (for R23 being Function holds ( iter (R23 , ( R16 + 1 )) ) c= ( R23 [*] )))
proof
let R16 being Nat;
let R23 being Function;
set D183 = ( R23 [*] );
defpred S9[ Nat ] means ( iter (R23 , ( $1 + 1 )) ) c= D183;
L708: S9[ ( 0 ) ]
proof
L709: ( iter (R23 , 1) ) = R23 by FUNCT_7:70;
thus L710: thesis by L709 , LANG1:18;
end;
L711: (for R17 being Nat holds (S9[ R17 ] implies S9[ ( R17 + 1 ) ]))
proof
let R17 being Nat;
assume L712: S9[ R17 ];
L713: (( iter (R23 , ( R17 + 1 )) ) c= D183 & R23 c= D183) by L712 , LANG1:18;
L714: ( ( iter (R23 , ( R17 + 1 )) ) * R23 ) c= ( D183 * D183 ) by L713 , RELAT_1:31;
L715: ( D183 * D183 ) c= D183 by RELAT_2:27;
L716: ( ( iter (R23 , ( R17 + 1 )) ) * R23 ) c= D183 by L715 , L714 , XBOOLE_1:1;
thus L717: thesis by L716 , FUNCT_7:69;
end;
L718: (for R17 being Nat holds S9[ R17 ]) from NAT_1:sch 2(L708 , L711);
thus L719: thesis by L718;
end;
L720: (for R16 being Nat holds (for R23 being Function holds ( iter (R23 , R16) ) c= ( R23 [*] )))
proof
let R16 being Nat;
let R23 being Function;
per cases ;
suppose L721: R16 = ( 0 );

thus L722: thesis by L721 , L704;
end;
suppose L723: R16 <> ( 0 );

consider R17 being Nat such that L724: R16 = ( R17 + 1 ) by L723 , NAT_1:6;
thus L725: thesis by L707 , L724;
end;
end;
L727: (for R11 being set holds (for R16 being Nat holds (for R18 being Function holds (for R23 being Function holds ((( rng R23 ) c= ( dom R23 ) & R11 in ( dom R23 ) & ( R18 . ( 0 ) ) = R11 & (for R15 being Nat holds (R15 < R16 implies ( R18 . ( R15 + 1 ) ) = ( R23 . ( R18 . R15 ) )))) implies ( R18 . R16 ) = ( ( iter (R23 , R16) ) . R11 ))))))
proof
let R11 being set;
let R16 being Nat;
let R18 being Function;
let R23 being Function;
assume L728: (( rng R23 ) c= ( dom R23 ) & R11 in ( dom R23 ));
L729: R11 in ( ( dom R23 ) \/ ( rng R23 ) ) by L728 , XBOOLE_0:def 3;
defpred S10[ Nat ] means ((( R18 . ( 0 ) ) = R11 & (for R15 being Nat holds (R15 < $1 implies ( R18 . ( R15 + 1 ) ) = ( R23 . ( R18 . R15 ) )))) implies ( R18 . $1 ) = ( ( iter (R23 , $1) ) . R11 ));
L730: S10[ ( 0 ) ]
proof
L731: ( iter (R23 , ( 0 )) ) = ( id ( field R23 ) ) by FUNCT_7:68;
assume L732: (( R18 . ( 0 ) ) = R11 & (for R15 being Nat holds (R15 < ( 0 ) implies ( R18 . ( R15 + 1 ) ) = ( R23 . ( R18 . R15 ) ))));
thus L733: thesis by L732 , L731 , L729 , FUNCT_1:17;
end;
L734: (for R17 being Nat holds (S10[ R17 ] implies S10[ ( R17 + 1 ) ]))
proof
let R17 being Nat;
assume L735: S10[ R17 ];
assume L736: ( R18 . ( 0 ) ) = R11;
assume L737: (for R15 being Nat holds (R15 < ( R17 + 1 ) implies ( R18 . ( R15 + 1 ) ) = ( R23 . ( R18 . R15 ) )));
L738: (for R15 being Nat holds (R15 < R17 implies ( R18 . ( R15 + 1 ) ) = ( R23 . ( R18 . R15 ) )))
proof
let R15 being Nat;
assume L739: R15 < R17;
L740: ( R15 + ( 0 ) ) < ( R17 + 1 ) by L739 , XREAL_1:8;
thus L741: thesis by L740 , L737;
end;
L742: R11 in ( dom ( iter (R23 , R17) ) ) by L728 , FUNCT_7:74;
L743: ( R17 + ( 0 ) ) < ( R17 + 1 ) by XREAL_1:8;
L744: ( R18 . ( R17 + 1 ) ) = ( R23 . ( R18 . R17 ) ) by L743 , L737
.= ( ( R23 * ( iter (R23 , R17) ) ) . R11 ) by L742 , L738 , L735 , L736 , FUNCT_1:13
.= ( ( iter (R23 , ( R17 + 1 )) ) . R11 ) by FUNCT_7:71;
thus L745: thesis by L744;
end;
L746: (for R17 being Nat holds S10[ R17 ]) from NAT_1:sch 2(L730 , L734);
thus L747: thesis by L746;
end;
definition
func plus -> (Function of ( COMPLEX ) , ( COMPLEX )) means 
:L748: (for B103 being  complex number holds ( it . B103 ) = ( B103 + 1 ));
existence
proof
defpred S11[ set , set ] means (for B104 being  complex number holds (B104 = $1 implies $2 = ( B104 + 1 )));
L749: (for B105 being (Element of ( COMPLEX )) holds (ex B106 being (Element of ( COMPLEX )) st S11[ B105 , B106 ]))
proof
let C177 being (Element of ( COMPLEX ));
reconsider D184 = C177 as  complex number;
reconsider D185 = ( D184 + 1 ) as (Element of ( COMPLEX )) by XCMPLX_0:def 2;
take D185;
thus L750: S11[ C177 , D185 ];
end;
consider C178 being (Function of ( COMPLEX ) , ( COMPLEX )) such that L751: (for B107 being (Element of ( COMPLEX )) holds S11[ B107 , ( C178 . B107 ) ]) from FUNCT_2:sch 3(L749);
take C178;
L752:
now
let C179 being  complex number;
reconsider D186 = C179 as (Element of ( COMPLEX )) by XCMPLX_0:def 2;
L753: (C179 = D186 & S11[ D186 , ( C178 . D186 ) ]) by L751;
thus L754: ( C178 . C179 ) = ( C179 + 1 ) by L753;
end;
thus L755: thesis by L752;
end;
uniqueness
proof
let C180 , C181 being (Function of ( COMPLEX ) , ( COMPLEX ));
assume L756: (for B108 being  complex number holds ( C180 . B108 ) = ( B108 + 1 ));
assume L757: (for B109 being  complex number holds ( C181 . B109 ) = ( B109 + 1 ));
L758:
now
let C182 being (Element of ( COMPLEX ));
thus L759: ( C180 . C182 ) = ( C182 + 1 ) by L756
.= ( C181 . C182 ) by L757;
end;
thus L760: thesis by L758 , FUNCT_2:63;
end;
end;
L762: (for R11 being set holds (for R16 being Nat holds (for R23 being Function holds (for R24 being FinSequence holds ((( rng R23 ) c= ( dom R23 ) & R11 in ( dom R23 ) & ( R24 . 1 ) = R11 & (for R15 being Nat holds ((R15 >= 1 & R15 < ( R16 + 1 )) implies ( R24 . ( R15 + 1 ) ) = ( R23 . ( R24 . R15 ) )))) implies ( R24 . ( R16 + 1 ) ) = ( ( iter (R23 , R16) ) . R11 ))))))
proof
let R11 being set;
let R16 being Nat;
let R23 being Function;
let R24 being FinSequence;
L763: ( dom ( plus ) ) = ( COMPLEX ) by FUNCT_2:def 1;
reconsider D187 = ( 0 ) as (Element of ( dom ( plus ) )) by L763 , XCMPLX_0:def 2;
reconsider D188 = ( R24 * ( plus ) ) as Function;
L764: (for B110 being  complex number holds ( D188 . B110 ) = ( R24 . ( B110 + 1 ) ))
proof
let C183 being  complex number;
reconsider D189 = C183 as (Element of ( dom ( plus ) )) by L763 , XCMPLX_0:def 2;
thus L765: ( D188 . C183 ) = ( R24 . ( ( plus ) . D189 ) ) by FUNCT_1:13
.= ( R24 . ( C183 + 1 ) ) by L748;
end;
assume L766: (( rng R23 ) c= ( dom R23 ) & R11 in ( dom R23 ));
assume L767: ( R24 . 1 ) = R11;
L768: ( R24 . ( ( 0 ) + 1 ) ) = R11 by L767;
L769: ( D188 . ( 0 ) ) = R11 by L768 , L764;
assume L770: (for R15 being Nat holds ((R15 >= 1 & R15 < ( R16 + 1 )) implies ( R24 . ( R15 + 1 ) ) = ( R23 . ( R24 . R15 ) )));
L771:
now
let C184 being Nat;
reconsider D190 = C184 as  complex number;
assume L772: C184 < R16;
L773: (( C184 + 1 ) >= ( ( 0 ) + 1 ) & ( C184 + 1 ) < ( R16 + 1 )) by L772 , XREAL_1:7 , XREAL_1:8;
L774: ( R24 . ( ( C184 + 1 ) + 1 ) ) = ( R23 . ( R24 . ( C184 + 1 ) ) ) by L773 , L770
.= ( R23 . ( D188 . C184 ) ) by L764;
thus L775: ( D188 . ( C184 + 1 ) ) = ( R23 . ( D188 . C184 ) ) by L774 , L764;
end;
L776: ( D188 . R16 ) = ( ( iter (R23 , R16) ) . R11 ) by L771 , L727 , L769 , L766;
thus L777: ( R24 . ( R16 + 1 ) ) = ( ( iter (R23 , R16) ) . R11 ) by L776 , L764;
end;
L778: (for R13 being set holds (for R23 being Function holds ((R13 in ( R23 [*] ) & ( rng R23 ) c= ( dom R23 )) implies (ex R17 being Nat st R13 in ( iter (R23 , R17) )))))
proof
let R13 being set;
let R23 being Function;
set D191 = ( R23 [*] );
assume L779: R13 in D191;
consider R11 being set, R12 being set such that L780: R13 = [ R11 , R12 ] by L779 , RELAT_1:def 1;
consider C185 being FinSequence such that L781: (( len C185 ) >= 1 & ( C185 . 1 ) = R11 & ( C185 . ( len C185 ) ) = R12 & (for B111 being Nat holds ((B111 >= 1 & B111 < ( len C185 )) implies [ ( C185 . B111 ) , ( C185 . ( B111 + 1 ) ) ] in R23))) by L780 , L779 , FINSEQ_1:def 16;
assume L782: ( rng R23 ) c= ( dom R23 );
L783: (( field R23 ) = ( dom R23 ) & R11 in ( field R23 )) by L782 , L780 , L779 , FINSEQ_1:def 16 , XBOOLE_1:12;
consider C186 being Nat such that L784: ( C186 + 1 ) = ( len C185 ) by L781 , NAT_1:6;
take C186;
L785: (for R15 being Nat holds ((R15 >= 1 & R15 < ( len C185 )) implies (( C185 . R15 ) in ( dom R23 ) & ( C185 . ( R15 + 1 ) ) = ( R23 . ( C185 . R15 ) ))))
proof
let R15 being Nat;
assume L786: (R15 >= 1 & R15 < ( len C185 ));
L787: [ ( C185 . R15 ) , ( C185 . ( R15 + 1 ) ) ] in R23 by L786 , L781;
thus L788: ( C185 . R15 ) in ( dom R23 ) by L787 , XTUPLE_0:def 12;
thus L789: ( C185 . ( R15 + 1 ) ) = ( R23 . ( C185 . R15 ) ) by L788 , L787 , FUNCT_1:def 2;
end;
L790: (( C186 + 1 ) >= 1 & ( C185 . 1 ) = R11 & ( C185 . ( C186 + 1 ) ) = R12 & (for B112 being Nat holds ((B112 >= 1 & B112 < ( C186 + 1 )) implies ( C185 . ( B112 + 1 ) ) = ( R23 . ( C185 . B112 ) )))) by L785 , L781 , L784;
L791: (R11 in ( dom ( iter (R23 , C186) ) ) & ( C185 . ( C186 + 1 ) ) = ( ( iter (R23 , C186) ) . R11 )) by L783 , L782 , L790 , L762 , FUNCT_7:74;
thus L792: R13 in ( iter (R23 , C186) ) by L791 , L780 , L781 , L784 , FUNCT_1:1;
end;
L793: (for R23 being Function holds (( rng R23 ) c= ( dom R23 ) implies ( R23 [*] ) = ( union { ( iter (R23 , B113) ) where B113 is (Element of ( NAT )) : (not contradiction) } )))
proof
let R23 being Function;
set D192 = { ( iter (R23 , B114) ) where B114 is (Element of ( NAT )) : (not contradiction) };
set D193 = ( R23 [*] );
set D194 = ( union D192 );
L794:
now
let R11 being set;
assume L795: R11 in D194;
consider C187 being set such that L796: (R11 in C187 & C187 in D192) by L795 , TARSKI:def 4;
consider C188 being (Element of ( NAT )) such that L797: (C187 = ( iter (R23 , C188) ) & (not contradiction)) by L796;
L798: (R11 in ( iter (R23 , C188) ) & ( iter (R23 , C188) ) c= ( R23 [*] )) by L796 , L797 , L720;
thus L799: R11 in D193 by L798;
end;
L800: D194 c= D193 by L794 , TARSKI:def 3;
assume L801: ( rng R23 ) c= ( dom R23 );
L802:
now
let R11 being set;
assume L803: R11 in D193;
consider R16 being Nat such that L804: R11 in ( iter (R23 , R16) ) by L803 , L801 , L778;
reconsider D195 = R16 as (Element of ( NAT )) by ORDINAL1:def 12;
L805: (R11 in ( iter (R23 , D195) ) & ( iter (R23 , D195) ) in D192) by L804;
thus L806: R11 in D194 by L805 , TARSKI:def 4;
end;
L807: D193 c= D194 by L802 , TARSKI:def 3;
thus L808: thesis by L800 , L807 , XBOOLE_0:def 10;
end;
theorem
L809: (for R23 being Function holds (( rng R23 ) c= ( dom R23 ) implies ( R23 [*] ) = ( union { ( iter (R23 , B115) ) where B115 is (Element of ( NAT )) : (not contradiction) } ))) by L793;
theorem
L810: (for R16 being Nat holds (for R18 being Function holds (for R23 being Function holds (R23 c= R18 implies ( iter (R23 , R16) ) c= ( iter (R18 , R16) ))))) by L600;
registration
let C189 being  functional set;
cluster ( union C189 ) ->  Relation-like;
coherence
proof
L811:
now
let R11 being set;
assume L812: R11 in ( union C189 );
consider R10 being set such that L813: (R11 in R10 & R10 in C189) by L812 , TARSKI:def 4;
thus L814: (ex R12 being set st (ex R13 being set st R11 = [ R12 , R13 ])) by L813 , RELAT_1:def 1;
end;
thus L815: thesis by L811 , RELAT_1:def 1;
end;
end;
theorem
L817: (for R7 being set holds (for R8 being set holds (for R10 being set holds (R10 c= ( Funcs (R7 , R8) ) implies ( union R10 ) c= [: R7 , R8 :])))) by L12;
registration
let R10 being set;
cluster ( R10 \ R10 ) ->  empty for set;
coherence by XBOOLE_1:37;
end;
registration
let R2 being non  empty set;
let R4 being (Element of R2);
cluster ( { ( ( id R2 ) . R4 ) } \ { R4 } ) ->  empty for set;
coherence
proof
L819: ( ( id R2 ) . R4 ) = R4 by FUNCT_1:17;
thus L820: thesis by L819;
end;
end;
registration
let C190 being FinSequence;
let C191 being  empty FinSequence;
identify C190 ^ C191 with C190 null C191;
compatibility by FINSEQ_1:34;
identify C190 null C191 with C190 ^ C191;
compatibility;
identify C191 ^ C190 with C190 null C191;
compatibility by FINSEQ_1:34;
identify C190 null C191 with C191 ^ C190;
compatibility;
end;
registration
let R10 being set;
let C192 being R10 -defined Relation;
identify C192 | R10 with C192 null R10;
compatibility
proof
thus L823: thesis;
end;
identify C192 null R10 with C192 | R10;
compatibility;
end;
theorem
L825: (for R23 being Function holds R23 = { [ B116 , ( R23 . B116 ) ] where B116 is (Element of ( dom R23 )) : B116 in ( dom R23 ) })
proof
let R23 being Function;
set D196 = { [ B117 , ( R23 . B117 ) ] where B117 is (Element of ( dom R23 )) : B117 in ( dom R23 ) };
L826:
now
let R13 being set;
assume L827: R13 in R23;
consider R11 being set, R12 being set such that L828: R13 = [ R11 , R12 ] by L827 , RELAT_1:def 1;
reconsider D197 = R11 as (Element of ( dom R23 )) by L828 , L827 , FUNCT_1:1;
L829: (R13 = [ D197 , ( R23 . D197 ) ] & D197 in ( dom R23 )) by L828 , L827 , FUNCT_1:1;
thus L830: R13 in D196 by L829;
end;
L831: R23 c= D196 by L826 , TARSKI:def 3;
L832:
now
let R13 being set;
assume L833: R13 in D196;
consider C193 being (Element of ( dom R23 )) such that L834: (R13 = [ C193 , ( R23 . C193 ) ] & C193 in ( dom R23 )) by L833;
thus L835: R13 in R23 by L834 , FUNCT_1:1;
end;
L836: D196 c= R23 by L832 , TARSKI:def 3;
thus L837: thesis by L836 , L831 , XBOOLE_0:def 10;
end;
theorem
L838: (for R10 being set holds (for B118 being  total R10 -defined Relation holds ( id R10 ) c= ( B118 * ( B118 ~ ) )))
proof
let R10 being set;
set D198 = R10;
let C194 being  total D198 -defined Relation;
reconsider D199 = ( id D198 ) as Function;
L839: D199 = { [ B119 , ( D199 . B119 ) ] where B119 is (Element of ( dom D199 )) : B119 in ( dom D199 ) } by L825;
L840:
now
let R13 being set;
assume L841: R13 in D199;
consider C195 being (Element of ( dom D199 )) such that L842: (R13 = [ C195 , ( ( id D198 ) . C195 ) ] & C195 in ( dom ( id D198 ) )) by L841 , L839;
L843: (C195 in D198 & R13 = [ C195 , C195 ]) by L842 , FUNCT_1:17;
L844: C195 in ( dom C194 ) by L843 , PARTFUN1:def 2;
consider R12 being set such that L845: [ C195 , R12 ] in C194 by L844 , XTUPLE_0:def 12;
L846: [ R12 , C195 ] in ( C194 ~ ) by L845 , RELAT_1:def 7;
L847: [ C195 , C195 ] in ( C194 * ( C194 ~ ) ) by L846 , L845 , RELAT_1:def 8;
thus L848: R13 in ( C194 * ( C194 ~ ) ) by L847 , L842 , FUNCT_1:17;
end;
thus L849: thesis by L840 , TARSKI:def 3;
end;
theorem
L850: (for R2 being non  empty set holds (for R16 being Nat holds (for R17 being Nat holds ( ( R16 + R17 ) -tuples_on R2 ) = ( ( R2 -concatenation ) .: [: ( R16 -tuples_on R2 ) , ( R17 -tuples_on R2 ) :] ))))
proof
let R2 being non  empty set;
let R16 being Nat;
let R17 being Nat;
reconsider D200 = R16 , D201 = R17 as (Element of ( NAT )) by ORDINAL1:def 12;
set D202 = R2;
set D203 = ( ( D200 + D201 ) -tuples_on D202 );
set D204 = ( D200 -tuples_on D202 );
set D205 = ( D201 -tuples_on D202 );
set D206 = ( D202 -concatenation );
set D207 = ( D206 .: [: D204 , D205 :] );
L851: D203 = { ( B120 ^ B121 ) where B120 is (Tuple of D200 , D202) , B121 is (Tuple of D201 , D202) : (not contradiction) } by FINSEQ_2:105;
L852: ( dom D206 ) = [: ( D202 * ) , ( D202 * ) :] by FUNCT_2:def 1;
L853: (D204 c= ( D202 * ) & D205 c= ( D202 * )) by FINSEQ_2:134;
L854: [: D204 , D205 :] c= [: ( D202 * ) , ( D202 * ) :] by L853 , ZFMISC_1:96;
L855:
now
let R12 being set;
assume L856: R12 in D203;
consider C196 being (Tuple of D200 , D202), C197 being (Tuple of D201 , D202) such that L857: (R12 = ( C196 ^ C197 ) & (not contradiction)) by L856 , L851;
reconsider D208 = C196 as (Element of D204) by FINSEQ_2:131;
reconsider D209 = C197 as (Element of D205) by FINSEQ_2:131;
reconsider D210 = [ D208 , D209 ] as (Element of [: D204 , D205 :]);
reconsider D211 = D210 as (Element of ( dom D206 )) by L852 , L854 , TARSKI:def 3;
L858: ( D206 .: { D210 } ) c= D207 by RELAT_1:123;
L859: R12 = ( D206 . (C196 , C197) ) by L857 , L102
.= ( D206 . D210 );
L860: R12 in { ( D206 . D211 ) } by L859 , TARSKI:def 1;
L861: R12 in ( Im (D206 , D211) ) by L860 , FUNCT_1:59;
thus L862: R12 in D207 by L861 , L858;
end;
L863: D203 c= D207 by L855 , TARSKI:def 3;
L864:
now
let R12 being set;
assume L865: R12 in D207;
consider R11 being set such that L866: (R11 in ( dom D206 ) & R11 in [: D204 , D205 :] & R12 = ( D206 . R11 )) by L865 , FUNCT_1:def 6;
consider C198 , C199 being set such that L867: (C198 in D204 & C199 in D205 & R11 = [ C198 , C199 ]) by L866 , ZFMISC_1:def 2;
reconsider D212 = C198 as (Element of D204) by L867;
reconsider D213 = C199 as (Element of D205) by L867;
reconsider D214 = D212 , D215 = D213 as (FinSequence of D202);
reconsider D216 = D212 as (Tuple of D200 , D202);
reconsider D217 = D213 as (Tuple of D201 , D202);
L868: R12 = ( D206 . (D214 , D215) ) by L866 , L867
.= ( D216 ^ D217 ) by L102;
thus L869: R12 in D203 by L868 , L851;
end;
L870: D207 c= D203 by L864 , TARSKI:def 3;
thus L871: thesis by L870 , L863 , XBOOLE_0:def 10;
end;
theorem
L872: (for R10 being set holds (for B122 , B123 being Relation holds ( ( B122 \/ B123 ) " R10 ) = ( ( B122 " R10 ) \/ ( B123 " R10 ) )))
proof
let R10 being set;
let C200 , C201 being Relation;
set D218 = ( C200 \/ C201 );
set D219 = ( D218 " R10 );
set D220 = ( ( C200 " R10 ) \/ ( C201 " R10 ) );
reconsider D221 = ( C200 null C201 ) , D222 = ( C201 null C200 ) as (Subset of D218);
L873:
now
let R11 being set;
assume L874: R11 in D219;
consider R12 being set such that L875: ([ R11 , R12 ] in D218 & R12 in R10) by L874 , RELAT_1:def 14;
set D223 = [ R11 , R12 ];
L876: ((D223 in C200 & R12 in R10) or (D223 in C201 & R12 in R10)) by L875 , XBOOLE_0:def 3;
L877: (R11 in ( C200 " R10 ) or R11 in ( C201 " R10 )) by L876 , RELAT_1:def 14;
thus L878: R11 in D220 by L877 , XBOOLE_0:def 3;
end;
L879: D219 c= D220 by L873 , TARSKI:def 3;
reconsider D224 = ( D221 " R10 ) , D225 = ( D222 " R10 ) as (Subset of D219) by RELAT_1:144;
L880: ( D224 \/ D225 ) c= D219;
thus L881: thesis by L880 , L879 , XBOOLE_0:def 10;
end;
L882: (for R7 being set holds (for R8 being set holds ( chi (R7 , R8) ) = ( ( R8 --> ( 0 ) ) +* ( ( R7 /\ R8 ) --> 1 ) )))
proof
let R7 being set;
let R8 being set;
set D226 = ( R8 --> ( 0 ) );
set D227 = ( ( R7 /\ R8 ) --> 1 );
set D228 = ( D226 +* D227 );
L883: (( dom D226 ) = R8 & ( dom D227 ) = ( R7 /\ R8 ) & ( dom D228 ) = ( ( dom D226 ) \/ ( dom D227 ) )) by FUNCOP_1:13 , FUNCT_4:def 1;
L884: ( dom D228 ) = R8 by L883 , XBOOLE_1:22;
L885:
now
let R11 being set;
assume L886: R11 in R8;
L887: (R11 in R8 & R11 in ( dom D228 ) & R11 in ( ( dom D226 ) \/ ( dom D227 ) )) by L886 , L883 , XBOOLE_1:22;
thus L888: (R11 in R7 implies ( D228 . R11 ) = 1)
proof
assume L889: R11 in R7;
L890: R11 in ( R7 /\ R8 ) by L889 , L886 , XBOOLE_0:def 4;
L891: R11 in ( dom D227 ) by L889 , L886 , L883 , XBOOLE_0:def 4;
L892: ( D228 . R11 ) = ( D227 . R11 ) by L891 , L887 , FUNCT_4:def 1
.= 1 by L890 , FUNCOP_1:7;
thus L893: thesis by L892;
end;

thus L894: ((not R11 in R7) implies ( D228 . R11 ) = ( {} ))
proof
assume L895: (not R11 in R7);
L896: (not R11 in ( R7 /\ R8 )) by L895;
L897: (not R11 in ( dom D227 )) by L896;
L898: ( D228 . R11 ) = ( D226 . R11 ) by L897 , L887 , FUNCT_4:def 1
.= ( 0 ) by L886 , FUNCOP_1:7;
thus L899: thesis by L898;
end;

end;
thus L895: thesis by L885 , L884 , FUNCT_3:def 3;
end;
L896: (for R7 being set holds (for R8 being set holds ( chi (R7 , R8) ) = ( ( ( R8 \ R7 ) --> ( 0 ) ) +* ( ( R7 /\ R8 ) --> 1 ) )))
proof
let R7 being set;
let R8 being set;
set D229 = ( R8 \ R7 );
set D230 = ( R7 /\ R8 );
set D231 = ( R8 --> ( 0 ) );
set D232 = ( D230 --> 1 );
set D233 = ( chi (R7 , R8) );
reconsider D234 = ( R8 /\ R8 ) , D235 = D230 , D236 = D229 as (Subset of R8);
reconsider D237 = ( D230 /\ D230 ) as (Subset of D230);
L897: (( D230 \/ D229 ) = R8 & ( dom D233 ) = D234) by FUNCT_3:def 3 , XBOOLE_1:51;
L898: (( R8 /\ D235 ) = D235 & ( D229 /\ D230 ) = ( {} ) & ( R8 /\ D236 ) = D236);
L899: (( ( D231 +* D232 ) | D229 ) = ( ( D231 | D229 ) +* ( D232 | D229 ) ) & ( ( D231 +* D232 ) | D230 ) = ( ( D231 | D230 ) +* ( D232 | D230 ) )) by FUNCT_4:71;
L900: (( D231 | D229 ) = ( ( R8 /\ D229 ) --> ( 0 ) ) & ( D232 | D229 ) = ( ( {} ) --> 1 ) & ( D231 | D230 ) = ( D237 --> ( 0 ) ) & ( D232 | D230 ) = D232) by L898 , FUNCOP_1:12;
L901: (( dom ( D231 | D230 ) ) = D237 & ( dom ( D232 | D230 ) ) = D230) by L900 , FUNCOP_1:13;
L902: ( ( D231 | D230 ) +* ( D232 | D230 ) ) = ( D232 | D230 ) by L901 , FUNCT_4:19;
thus L903: D233 = ( ( D233 | D229 ) +* ( D233 | D230 ) ) by L897 , FUNCT_4:70
.= ( ( ( D231 +* D232 ) | D229 ) +* ( D233 | D230 ) ) by L882
.= ( ( ( ( R8 /\ D229 ) --> ( 0 ) ) +* ( {} ) ) +* ( D232 | D230 ) ) by L899 , L882 , L900 , L902
.= ( ( D229 --> ( 0 ) ) +* D232 );
end;
L904: (for R7 being set holds (for R8 being set holds ( chi (R7 , R8) ) = ( ( ( R8 \ R7 ) --> ( 0 ) ) \/ ( ( R7 /\ R8 ) --> 1 ) )))
proof
let R7 being set;
let R8 being set;
set D238 = ( ( R8 \ R7 ) --> ( 0 ) );
set D239 = ( ( R7 /\ R8 ) --> 1 );
L905: ( ( R8 \ R7 ) /\ ( R7 /\ R8 ) ) = ( {} );
L906: ( R8 \ R7 ) misses ( R7 /\ R8 ) by L905 , XBOOLE_0:def 7;
L907: D238 tolerates D239 by L906 , FUNCOP_1:87;
L908: ( D238 +* D239 ) = ( D238 \/ D239 ) by L907 , FUNCT_4:30;
thus L909: thesis by L908 , L896;
end;
theorem
L910: (for R7 being set holds (for R8 being set holds (( ( chi (R7 , R8) ) " { ( 0 ) } ) = ( R8 \ R7 ) & ( ( chi (R7 , R8) ) " { 1 } ) = ( R7 /\ R8 ))))
proof
let R7 being set;
let R8 being set;
set D240 = ( ( R8 \ R7 ) --> ( 0 ) );
set D241 = ( ( R7 /\ R8 ) --> 1 );
set D242 = ( chi (R7 , R8) );
L911: (( 0 ) in { ( 0 ) } & 1 in { 1 } & (not 1 in { ( 0 ) }) & (not ( 0 ) in { 1 })) by TARSKI:def 1;
L912: (( D240 " { 1 } ) = ( {} ) & ( D241 " { ( 0 ) } ) = ( {} )) by L911 , FUNCOP_1:16;
thus L913: ( D242 " { ( 0 ) } ) = ( ( D240 \/ D241 ) " { ( 0 ) } ) by L904
.= ( ( D240 " { ( 0 ) } ) \/ ( D241 " { ( 0 ) } ) ) by L872
.= ( R8 \ R7 ) by L911 , L912 , FUNCOP_1:14;
thus L914: ( D242 " { 1 } ) = ( ( D240 \/ D241 ) " { 1 } ) by L904
.= ( ( D240 " { 1 } ) \/ ( D241 " { 1 } ) ) by L872
.= ( R7 /\ R8 ) by L911 , L912 , FUNCOP_1:14;
end;
theorem
L915: (for R11 being set holds (for R23 being Function holds (for B124 being non  empty set holds (B124 = ( R23 . R11 ) iff R11 in ( R23 " { B124 } )))))
proof
let R11 being set;
let R23 being Function;
let C202 being non  empty set;
thus L916: (C202 = ( R23 . R11 ) implies R11 in ( R23 " { C202 } ))
proof
assume L917: C202 = ( R23 . R11 );
L918: (R11 in ( dom R23 ) & ( R23 . R11 ) in { C202 }) by L917 , FUNCT_1:def 2 , TARSKI:def 1;
thus L919: thesis by L918 , FUNCT_1:def 7;
end;

assume L920: R11 in ( R23 " { C202 } );
L921: (R11 in ( dom R23 ) & ( R23 . R11 ) in { C202 }) by L920 , FUNCT_1:def 7;
thus L922: thesis by L921 , TARSKI:def 1;
end;
theorem
L923: (for R10 being set holds (for R23 being Function holds ((R23 is R10 -valued & R23 is  FinSequence-like) implies R23 is (FinSequence of R10)))) by L8;
registration
let R10 being set;
let C203 being (Subset of R10);
cluster C203 -valued -> R10 -valued for Relation;
coherence
proof
let C204 being Relation;
assume L924: C204 is C203 -valued;
L925: (( rng C204 ) c= C203 & C203 c= R10) by L924 , RELAT_1:def 19;
L926: ( rng C204 ) c= R10 by L925 , XBOOLE_1:1;
thus L927: thesis by L926 , RELAT_1:def 19;
end;
end;
L929: (for R10 being set holds (for B125 being  total R10 -defined Relation holds (ex B126 being (Function of R10 , ( rng B125 )) st (B126 c= B125 & ( dom B126 ) = R10))))
proof
let R10 being set;
set D243 = R10;
let C205 being  total D243 -defined Relation;
L930: ( dom C205 ) = D243 by PARTFUN1:def 2;
defpred S12[ set , set ] means [ $1 , $2 ] in C205;
L931: (for R11 being set holds (R11 in D243 implies (ex R12 being set st S12[ R11 , R12 ]))) by L930 , XTUPLE_0:def 12;
consider R23 being Function such that L932: (( dom R23 ) = D243 & (for R11 being set holds (R11 in D243 implies S12[ R11 , ( R23 . R11 ) ]))) from CLASSES1:sch 1(L931);
L933: R23 = { [ B127 , ( R23 . B127 ) ] where B127 is (Element of ( dom R23 )) : B127 in ( dom R23 ) } by L825;
L934:
now
let R13 being set;
assume L935: R13 in R23;
consider C206 being (Element of ( dom R23 )) such that L936: (R13 = [ C206 , ( R23 . C206 ) ] & C206 in ( dom R23 )) by L935 , L933;
thus L937: R13 in C205 by L936 , L932;
end;
L938: R23 c= C205 by L934 , TARSKI:def 3;
L939: ( rng R23 ) c= ( rng C205 ) by L938 , RELAT_1:11;
reconsider D244 = R23 as (Function of D243 , ( rng C205 )) by L939 , L932 , FUNCT_2:67 , RELSET_1:4;
take D244;
thus L940: thesis by L934 , L932 , TARSKI:def 3;
end;
L941: (for R22 being Relation holds (for R23 being Function holds ((( dom R23 ) c= ( dom R22 ) & R22 c= R23) implies R22 = R23)))
proof
let R22 being Relation;
let R23 being Function;
set D245 = ( dom R23 );
assume L942: (D245 c= ( dom R22 ) & R22 c= R23);
L943: (D245 c= ( dom R22 ) & ( dom R22 ) c= D245) by L942 , RELAT_1:11;
L944: ( dom R23 ) = ( dom R22 ) by L943 , XBOOLE_0:def 10;
reconsider D246 = R22 as D245 -defined Relation by L943 , RELAT_1:def 18;
reconsider D247 = D246 as  total D245 -defined Relation by L944 , PARTFUN1:def 2;
consider C207 being (Function of D245 , ( rng D247 )) such that L945: (C207 c= D247 & ( dom C207 ) = D245) by L929;
L946: R23 c= R22 by L945 , L942 , GRFUNC_1:3 , XBOOLE_1:1;
thus L947: thesis by L946 , L942 , XBOOLE_0:def 10;
end;
L948: (for R10 being set holds (for R20 being Relation holds (for R22 being Relation holds (for B128 being R10 -defined Relation holds ((B128 is  total & R22 is R10 -defined & ( ( ( R20 * B128 ) * ( B128 ~ ) ) * R22 ) is  Function-like & ( rng R20 ) c= ( dom R22 )) implies ( ( ( R20 * B128 ) * ( B128 ~ ) ) * R22 ) = ( R20 * R22 ))))))
proof
let R10 being set;
let R20 being Relation;
let R22 being Relation;
let C208 being R10 -defined Relation;
assume L949: C208 is  total;
reconsider D248 = C208 as  total R10 -defined Relation by L949;
set D249 = ( D248 ~ );
assume L950: R22 is R10 -defined;
reconsider D250 = R22 as R10 -defined Relation by L950;
assume L951: ( ( ( R20 * C208 ) * ( C208 ~ ) ) * R22 ) is  Function-like;
reconsider D251 = ( ( ( R20 * C208 ) * D249 ) * R22 ) as Function by L951;
L952: D251 = ( ( R20 * C208 ) * ( D249 * R22 ) ) by RELAT_1:36
.= ( R20 * ( C208 * ( D249 * R22 ) ) ) by RELAT_1:36
.= ( R20 * ( ( C208 * D249 ) * D250 ) ) by RELAT_1:36;
L953: ( ( id R10 ) * D250 ) c= ( ( C208 * D249 ) * D250 ) by L838 , RELAT_1:30;
L954: ( D250 | R10 ) c= ( ( C208 * D249 ) * D250 ) by L953 , RELAT_1:65;
assume L955: ( rng R20 ) c= ( dom R22 );
L956: ( dom ( R20 * R22 ) ) = ( dom R20 ) by L955 , RELAT_1:27;
L957: (( dom ( R20 * ( C208 * D249 ) ) ) c= ( dom R20 ) & ( dom ( ( ( R20 * C208 ) * D249 ) * R22 ) ) c= ( dom ( ( R20 * C208 ) * D249 ) )) by RELAT_1:25;
L958: (( dom ( ( R20 * C208 ) * D249 ) ) c= ( dom R20 ) & ( dom D251 ) c= ( dom ( ( R20 * C208 ) * D249 ) )) by L957 , RELAT_1:36;
L959: ( dom D251 ) c= ( dom ( R20 * R22 ) ) by L958 , L956 , XBOOLE_1:1;
thus L960: thesis by L959 , L954 , L952 , L941 , RELAT_1:29;
end;
theorem
L961: (for R7 being set holds (for R8 being set holds (for R26 being non  empty set holds (for R27 being non  empty set holds (for B129 being  quasi_total (Relation of R8 , R26) holds (for B130 being  quasi_total (Relation of R8 , R27) holds (for B131 being (Relation of R7 , R8) holds (( ( ( B131 * B129 ) * ( B129 ~ ) ) * B130 ) is  Function-like implies ( ( ( B131 * B129 ) * ( B129 ~ ) ) * B130 ) = ( B131 * B130 )))))))))
proof
let R7 being set;
let R8 being set;
let R26 being non  empty set;
let R27 being non  empty set;
let C209 being  quasi_total (Relation of R8 , R26);
let C210 being  quasi_total (Relation of R8 , R27);
let C211 being (Relation of R7 , R8);
reconsider D252 = C209 as  total R8 -defined Relation;
reconsider D253 = C210 as  total R8 -defined Relation;
L962: (( dom C210 ) = R8 & ( rng C211 ) c= R8) by PARTFUN1:def 2;
assume L963: ( ( ( C211 * C209 ) * ( C209 ~ ) ) * C210 ) is  Function-like;
thus L964: thesis by L963 , L962 , L948;
end;
theorem
L965: (for B132 , B133 being FinSequence holds (B132 is non  empty implies ( ( B132 ^ B133 ) . 1 ) = ( B132 . 1 )))
proof
let C212 , C213 being FinSequence;
assume L966: C212 is non  empty;
reconsider D254 = C212 as non  empty FinSequence by L966;
set D255 = ( len D254 );
L967: (1 <= 1 & 1 <= D255) by NAT_1:14;
L968: 1 in ( Seg D255 ) by L967;
L969: 1 in ( dom D254 ) by L968 , FINSEQ_1:def 3;
thus L970: thesis by L969 , FINSEQ_1:def 7;
end;
registration
let R1 being non  empty set;
let C214 , C215 being R1 -valued FinSequence;
cluster ( C214 ^ C215 ) -> R1 -valued for FinSequence;
coherence
proof
reconsider D256 = C214 , D257 = C215 as (FinSequence of R1) by L8;
L971: ( D256 ^ D257 ) is R1 -valued;
thus L972: thesis by L971;
end;
end;
definition
let R1 being non  empty set;
let R19 being set;
redefine attr R19 is R1 -prefix
means
(for B134 , B135 , B136 , B137 being R1 -valued FinSequence holds ((B134 in R19 & B136 in R19 & ( B134 ^ B135 ) = ( B136 ^ B137 )) implies (B134 = B136 & B135 = B137)));
compatibility
proof
set D258 = ( R1 -concatenation );
set D259 = ( R1 * );
defpred S13[ set ] means $1 is (FinSequence of R1);
defpred S14[  ] means (for B138 , B139 , B140 , B141 being R1 -valued FinSequence holds ((B138 in R19 & B140 in R19 & ( B138 ^ B139 ) = ( B140 ^ B141 )) implies (B138 = B140 & B139 = B141)));
thus L974: (R19 is R1 -prefix implies S14[  ])
proof
assume L975: R19 is R1 -prefix;
L976: R19 is D258 -unambiguous by L975 , L5;
let C216 , C217 , C218 , C219 being R1 -valued FinSequence;
L977: (S13[ C216 ] & S13[ C218 ] & S13[ C217 ] & S13[ C219 ]) by L8;
assume L978: (C216 in R19 & C218 in R19);
L979: (C217 in ( R1 * ) & C219 in ( R1 * ) & C216 in ( R1 * ) & C218 in ( R1 * )) by L977 , FINSEQ_1:def 11;
L980: (C216 in ( R19 /\ D259 ) & C218 in ( R19 /\ D259 ) & C217 in ( R1 * ) & C219 in ( R1 * )) by L979 , L978 , XBOOLE_0:def 4;
assume L981: ( C216 ^ C217 ) = ( C218 ^ C219 );
L982: ( D258 . (C216 , C217) ) = ( C218 ^ C219 ) by L981 , L106
.= ( D258 . (C218 , C219) ) by L106;
thus L983: (C216 = C218 & C217 = C219) by L982 , L976 , L277 , L980;
end;

assume L984: S14[  ];
L985:
now
let C220 , C221 , C222 , C223 being set;
assume L986: (C220 in ( R19 /\ D259 ) & C221 in ( R19 /\ D259 ) & C222 in D259 & C223 in D259);
reconsider D260 = C220 , D261 = C221 , D262 = C222 , D263 = C223 as (Element of D259) by L986;
assume L987: ( D258 . (C220 , C222) ) = ( D258 . (C221 , C223) );
L988: ( D260 ^ D262 ) = ( D258 . (D261 , D263) ) by L987 , L106
.= ( D261 ^ D263 ) by L106;
thus L989: (C220 = C221 & C222 = C223) by L988 , L984 , L986;
end;
L990: R19 is D258 -unambiguous by L985 , L277;
thus L991: thesis by L990 , L5;
end;
end;
registration
let C224 being set;
cluster  -> C224 -valued for (Element of ( C224 * ));
coherence;
end;
registration
let R1 being non  empty set;
let R16 being Nat;
let C225 being R1 -prefix set;
cluster ( ( R1 -multiCat ) .: ( R16 -tuples_on C225 ) ) -> R1 -prefix for set;
coherence by L475;
end;
theorem
L995: (for R10 being set holds (for R19 being set holds (( R19 \+\ R10 ) = ( {} ) iff R19 = R10)))
proof
let R10 being set;
let R19 being set;
set D264 = ( R19 \+\ R10 );
set D265 = ( R19 \ R10 );
set D266 = ( R10 \ R19 );
thus L996: (D264 = ( {} ) implies R19 = R10)
proof
assume L997: D264 = ( {} );
L998: (D265 = ( {} ) & D266 = ( {} )) by L997;
L999: (R19 c= R10 & R10 c= R19) by L998 , XBOOLE_1:37;
thus L1000: thesis by L999 , XBOOLE_0:def 10;
end;

assume L1001: R19 = R10;
thus L1002: thesis by L1001;
end;
registration
let R11 being set;
cluster ( ( id { R11 } ) \+\ { [ R11 , R11 ] } ) ->  empty for set;
coherence
proof
L1003: ( id { R11 } ) = { [ R11 , R11 ] } by SYSREL:13;
thus L1004: thesis by L1003;
end;
end;
registration
let R11 being set;
let R12 being set;
cluster ( ( R11 .--> R12 ) \+\ { [ R11 , R12 ] } ) ->  empty for set;
coherence
proof
L1006: ( R11 .--> R12 ) = { [ R11 , R12 ] } by ZFMISC_1:29;
thus L1007: thesis by L1006;
end;
end;
registration
let R11 being set;
cluster ( ( id { R11 } ) \+\ ( R11 .--> R11 ) ) ->  empty for set;
coherence
proof
L1009: (( ( id { R11 } ) \+\ { [ R11 , R11 ] } ) = ( {} ) & ( ( R11 .--> R11 ) \+\ { [ R11 , R11 ] } ) = ( {} ));
thus L1010: thesis by L1009 , L995;
end;
end;
theorem
L1012: (for R2 being non  empty set holds (for R11 being set holds (R11 in ( ( R2 * ) \ { ( {} ) } ) iff (R11 is R2 -valued R2 -valued R2 -valued R2 -valued FinSequence & R11 is non  empty))))
proof
let R2 being non  empty set;
let R11 being set;
L1013: ((R11 is R2 -valued R2 -valued R2 -valued R2 -valued FinSequence & R11 is non  empty) iff R11 is non  empty non  empty non  empty non  empty (FinSequence of R2)) by L8;
thus L1014: thesis by L1013 , L110;
end;
theorem
L1015: (for R2 being non  empty set holds (for R4 being (Element of R2) holds (for R28 being (BinOp of R2) holds (( ( MultPlace R28 ) . <* R4 *> ) = R4 & (for B142 being R2 -valued FinSequence holds (B142 is non  empty implies ( ( MultPlace R28 ) . ( B142 ^ <* R4 *> ) ) = ( R28 . (( ( MultPlace R28 ) . B142 ) , R4) )))))))
proof
let R2 being non  empty set;
let R4 being (Element of R2);
let R28 being (BinOp of R2);
set D267 = ( MultPlace R28 );
thus L1016: ( D267 . <* R4 *> ) = R4 by L245;
let C226 being R2 -valued FinSequence;
assume L1017: C226 is non  empty;
reconsider D268 = C226 as non  empty (FinSequence of R2) by L1017 , L8;
L1018: ( D267 . ( D268 ^ <* R4 *> ) ) = ( R28 . (( D267 . D268 ) , R4) ) by L245;
thus L1019: thesis by L1018;
end;
registration
let R62 being FinSequence;
let R35 being set;
let R38 being set;
cluster ( R62 +~ (R35 , R38) ) ->  FinSequence-like;
coherence
proof
set D269 = ( R62 +~ (R35 , R38) );
L1020: ( dom D269 ) = ( dom R62 ) by FUNCT_4:99
.= ( Seg ( len R62 ) ) by FINSEQ_1:def 3;
thus L1021: thesis by L1020 , FINSEQ_1:def 2;
end;
end;
definition
let R35 being set;
let R38 being set;
let R62 being FinSequence;
func (R35 , R38) -SymbolSubstIn R62 -> FinSequence equals 
( R62 +~ (R35 , R38) );
coherence;
end;
registration
let R35 being set;
let R38 being set;
let R55 being Nat;
let C227 being R55 -element FinSequence;
cluster ( (R35 , R38) -SymbolSubstIn C227 ) -> R55 -element for FinSequence;
coherence
proof
set D270 = ( (R35 , R38) -SymbolSubstIn C227 );
reconsider D271 = R55 as (Element of ( NAT )) by ORDINAL1:def 12;
L1024: ( dom D270 ) = ( dom C227 ) by FUNCT_4:99
.= ( Seg ( len C227 ) ) by FINSEQ_1:def 3
.= ( Seg D271 ) by CARD_1:def 7;
L1025: ( len D270 ) = D271 by L1024 , FINSEQ_1:def 3;
thus L1026: thesis by L1025 , CARD_1:def 7;
end;
end;
registration
let R35 being set;
let R42 being non  empty set;
let R46 being (Element of R42);
let C228 being R42 -valued FinSequence;
cluster ( (R35 , R46) -SymbolSubstIn C228 ) -> R42 -valued for FinSequence;
coherence;
end;
definition
let R32 being set;
let R35 being set;
let R38 being set;
let C229 being R32 -valued FinSequence;
redefine func (R35 , R38) -SymbolSubstIn C229 equals 
( ( ( id R32 ) +* (R35 , R38) ) * C229 );
compatibility
proof
L1029: ( rng C229 ) c= R32;
thus L1030: thesis by L1029 , FUNCT_7:116;
end;
end;
definition
let R42 being non  empty set;
let R35 being set;
let R46 being (Element of R42);
let R65 being R42 -valued FinSequence;
redefine func (R35 , R46) -SymbolSubstIn R65 -> (FinSequence of R42);

coherence by L8;
end;
L1033: (for R37 being set holds (for R42 being non  empty set holds (for R46 being (Element of R42) holds (for R47 being (Element of R42) holds ((R46 = R47 implies ( (R47 , R37) -SymbolSubstIn <* R46 *> ) = <* R37 *>) & (R46 <> R47 implies ( (R47 , R37) -SymbolSubstIn <* R46 *> ) = <* R46 *>))))))
proof
let R37 being set;
let R42 being non  empty set;
let R46 being (Element of R42);
let R47 being (Element of R42);
set D272 = R42;
set D273 = R46;
set D274 = R47;
set D275 = R37;
set D276 = <* D273 *>;
set D277 = ( (D274 , D275) -SymbolSubstIn D276 );
set D278 = ( 1 .--> D274 );
set D279 = ( 1 .--> D275 );
set D280 = ( 1 .--> D273 );
set D281 = ( D274 .--> D275 );
set D282 = ( id D272 );
set D283 = <* D274 *>;
set D284 = <* D275 *>;
L1034: (( D276 \+\ D280 ) = ( {} ) & ( D284 \+\ D279 ) = ( {} ) & ( D283 \+\ D278 ) = ( {} ));
L1035: (D276 = D280 & D284 = D279 & D283 = D278) by L1034 , L995;
L1036: (( dom D281 ) = { D274 } & ( dom D279 ) = { 1 } & ( dom D278 ) = { 1 } & ( dom D280 ) = { 1 } & ( rng D280 ) = { D273 }) by FUNCOP_1:8 , FUNCOP_1:13;
L1037: D274 in { D274 } by TARSKI:def 1;
L1038: ( D281 . D274 ) = D275 by L1037 , FUNCOP_1:7;
L1039: D277 = ( D276 +* ( D281 * D280 ) ) by L1034 , L995;
thus L1040: (D273 = D274 implies D277 = D284)
proof
assume L1041: D273 = D274;
L1042: D273 in ( dom D281 ) by L1041 , L1036 , TARSKI:def 1;
L1043: D277 = ( D280 +* D279 ) by L1042 , L1041 , L1035 , L1038 , FUNCOP_1:17
.= D284 by L1035 , L1036 , FUNCT_4:19;
thus L1044: D277 = D284 by L1043;
end;

assume L1045: D273 <> D274;
L1046: ( D281 * D280 ) = ( {} ) by L1045 , L1036 , RELAT_1:44 , ZFMISC_1:11;
L1047: D277 = ( D276 +* ( {} ) ) by L1046 , L1039;
thus L1048: thesis by L1047;
end;
L1049: (for R35 being set holds (for R42 being non  empty set holds (for R46 being (Element of R42) holds (for R66 being R42 -valued FinSequence holds (for R67 being R42 -valued FinSequence holds ( (R35 , R46) -SymbolSubstIn ( R66 ^ R67 ) ) = ( ( (R35 , R46) -SymbolSubstIn R66 ) ^ ( (R35 , R46) -SymbolSubstIn R67 ) ))))))
proof
let R35 being set;
let R42 being non  empty set;
let R46 being (Element of R42);
let R66 being R42 -valued FinSequence;
let R67 being R42 -valued FinSequence;
set D285 = R35;
set D286 = R46;
set D287 = R66;
set D288 = R67;
set D289 = ( D287 ^ D288 );
set D290 = ( (D285 , D286) -SymbolSubstIn D287 );
set D291 = ( (D285 , D286) -SymbolSubstIn D288 );
set D292 = ( (D285 , D286) -SymbolSubstIn D289 );
set D293 = ( D285 .--> D286 );
set D294 = ( id R42 );
reconsider D295 = ( D294 +* (D285 , D286) ) as (Function of R42 , R42);
reconsider D296 = D287 , D297 = D288 , D298 = D289 as (FinSequence of R42) by L8;
thus L1050: D292 = ( ( D295 * D296 ) ^ ( D295 * D297 ) ) by FINSEQOP:9
.= ( D290 ^ D291 );
end;
definition
let R42 being non  empty set;
let R35 being set;
let R46 being (Element of R42);
set D299 = ( R42 * );
deffunc H3((Element of ( R42 * ))) = ( (R35 , R46) -SymbolSubstIn $1 );
func R35 SubstWith R46 -> (Function of ( R42 * ) , ( R42 * )) means 
:L1051: (for R65 being R42 -valued FinSequence holds ( it . R65 ) = ( (R35 , R46) -SymbolSubstIn R65 ));
existence
proof
L1052: (for B143 being (Element of D299) holds H3(B143) is (Element of D299)) by FINSEQ_1:def 11;
consider C230 being (Function of D299 , D299) such that L1053: (for B144 being (Element of D299) holds ( C230 . B144 ) = H3(B144)) from FUNCT_2:sch 9(L1052);
take C230;
L1054:
now
let R65 being R42 -valued FinSequence;
reconsider D300 = R65 as (FinSequence of R42) by L8;
reconsider D301 = D300 as (Element of D299) by FINSEQ_1:def 11;
L1055: ( C230 . D301 ) = H3(D301) by L1053;
thus L1056: ( C230 . R65 ) = ( (R35 , R46) -SymbolSubstIn R65 ) by L1055;
end;
thus L1057: thesis by L1054;
end;
uniqueness
proof
let C231 , C232 being (Function of D299 , D299);
assume L1058: (for R65 being R42 -valued FinSequence holds ( C231 . R65 ) = ( (R35 , R46) -SymbolSubstIn R65 ));
assume L1059: (for R65 being R42 -valued FinSequence holds ( C232 . R65 ) = ( (R35 , R46) -SymbolSubstIn R65 ));
L1060:
now
let C233 being (Element of D299);
thus L1061: ( C231 . C233 ) = H3(C233) by L1058
.= ( C232 . C233 ) by L1059;
end;
thus L1062: thesis by L1060 , FUNCT_2:63;
end;
end;
L1064: (for R42 being non  empty set holds (for R46 being (Element of R42) holds (for R47 being (Element of R42) holds (for R48 being (Element of R42) holds ((R46 = R47 implies ( ( R47 SubstWith R48 ) . <* R46 *> ) = <* R48 *>) & (R46 <> R47 implies ( ( R47 SubstWith R48 ) . <* R46 *> ) = <* R46 *>))))))
proof
let R42 being non  empty set;
let R46 being (Element of R42);
let R47 being (Element of R42);
let R48 being (Element of R42);
set D302 = ( R47 SubstWith R48 );
set D303 = ( (R47 , R48) -SymbolSubstIn <* R46 *> );
L1065: D303 = ( D302 . <* R46 *> ) by L1051;
thus L1066: thesis by L1065 , L1033;
end;
registration
let R42 being non  empty set;
let R35 being set;
let R46 being (Element of R42);
cluster ( R35 SubstWith R46 ) ->  FinSequence-yielding for Function;
coherence
proof
set D304 = ( R35 SubstWith R46 );
L1067:
now
let R38 being set;
assume L1068: R38 in ( dom D304 );
reconsider D305 = R38 as (Element of ( R42 * )) by L1068;
thus L1069: ( D304 . R38 ) is FinSequence;
end;
thus L1070: thesis by L1067 , PRE_POLY:def 3;
end;
end;
registration
let C234 being  FinSequence-yielding Function;
let C235 being set;
cluster ( C234 . C235 ) ->  FinSequence-like;
coherence
proof
per cases ;
suppose L1072: C235 in ( dom C234 );

thus L1073: thesis by L1072 , PRE_POLY:def 3;
end;
suppose L1074: (not C235 in ( dom C234 ));

thus L1075: thesis by L1074 , FUNCT_1:def 2;
end;
end;
end;
L1078: (for R35 being set holds (for R42 being non  empty set holds (for R46 being (Element of R42) holds (for R66 being R42 -valued FinSequence holds (for R67 being R42 -valued FinSequence holds ( ( R35 SubstWith R46 ) . ( R66 ^ R67 ) ) = ( ( ( R35 SubstWith R46 ) . R66 ) ^ ( ( R35 SubstWith R46 ) . R67 ) ))))))
proof
let R35 being set;
let R42 being non  empty set;
let R46 being (Element of R42);
let R66 being R42 -valued FinSequence;
let R67 being R42 -valued FinSequence;
set D306 = ( R35 SubstWith R46 );
set D307 = R66;
set D308 = R67;
set D309 = ( D307 ^ D308 );
set D310 = ( (R35 , R46) -SymbolSubstIn D307 );
set D311 = ( (R35 , R46) -SymbolSubstIn D308 );
set D312 = ( (R35 , R46) -SymbolSubstIn D309 );
L1079: (( D306 . D307 ) = D310 & ( D306 . D308 ) = D311 & ( D306 . D309 ) = D312) by L1051;
thus L1080: thesis by L1079 , L1049;
end;
registration
let R42 being non  empty set;
let R35 being set;
let R46 being (Element of R42);
let R55 being Nat;
let C236 being R42 -valued R55 -element FinSequence;
cluster ( ( R35 SubstWith R46 ) . C236 ) -> R55 -element for FinSequence;
coherence
proof
L1081: ( ( R35 SubstWith R46 ) . C236 ) = ( (R35 , R46) -SymbolSubstIn C236 ) by L1051;
thus L1082: thesis by L1081;
end;
end;
registration
let R42 being non  empty set;
let R35 being set;
let R46 being (Element of R42);
let C237 being  empty set;
cluster ( ( R35 SubstWith R46 ) . C237 ) ->  empty for set;
coherence
proof
L1084: ( rng C237 ) = ( R42 /\ ( {} ) );
reconsider D313 = C237 as R42 -valued ( 0 ) -element FinSequence by L1084 , RELAT_1:def 19;
L1085: (for R32 being set holds ( ( R32 SubstWith R46 ) . D313 ) is ( 0 ) -element);
thus L1086: thesis by L1085;
end;
end;
registration
let R42 being non  empty set;
cluster ( R42 -multiCat ) ->  FinSequence-yielding for Function;
coherence
proof
set D314 = ( R42 -multiCat );
set D315 = ( R42 * );
set D316 = ( D315 * );
L1088:
now
let R35 being set;
assume L1089: R35 in ( dom D314 );
reconsider D317 = R35 as (Element of ( dom D314 )) by L1089;
thus L1090: ( D314 . R35 ) is FinSequence;
end;
thus L1091: thesis by L1088 , PRE_POLY:def 3;
end;
end;
registration
let R42 being non  empty set;
cluster non  empty for R42 -valued R42 -valued R42 -valued R42 -valued FinSequence;
existence
proof
take <* the (Element of R42) *>;
thus L1093: thesis;
end;
end;
registration
let R42 being non  empty set;
let R60 being non  zero Nat;
let R56 being Nat;
let C238 being ( R60 + R56 ) -element R42 -valued FinSequence;
cluster ( { ( C238 . R60 ) } \ R42 ) ->  empty for set;
coherence
proof
consider R55 being Nat such that L1095: R60 = ( R55 + 1 ) by NAT_1:6;
set D318 = ( { ( C238 . R60 ) } \ R42 );
set D319 = ( R60 + R56 );
L1096: C238 in ( D319 -tuples_on R42 ) by L583;
L1097: C238 is (Element of ( Funcs (( Seg D319 ) , R42) )) by L1096 , L48;
reconsider D320 = C238 as (Function of ( Seg D319 ) , R42) by L1097;
L1098: (1 <= ( R55 + 1 ) & ( R55 + 1 ) <= ( ( R55 + 1 ) + R56 )) by NAT_1:11;
reconsider D321 = R60 as (Element of ( Seg D319 )) by L1098 , L1095 , FINSEQ_1:1;
L1099: ( D320 . D321 ) in R42;
thus L1100: thesis by L1099 , ZFMISC_1:60;
end;
end;
registration
let R42 being non  empty set;
let R55 being Nat;
let R56 being Nat;
let C239 being ( ( R55 + 1 ) + R56 ) -element (Element of ( R42 * ));
cluster ( { ( C239 . ( R55 + 1 ) ) } \ R42 ) ->  empty for set;
coherence;
end;
registration
let R35 being set;
cluster ( <* R35 *> \+\ { [ 1 , R35 ] } ) ->  empty for set;
coherence;
end;
registration
let R55 being Nat;
let C240 being ( R55 + 1 ) -element FinSequence;
cluster ( ( ( C240 | ( Seg R55 ) ) ^ <* ( C240 . ( R55 + 1 ) ) *> ) \+\ C240 ) ->  empty for set;
coherence
proof
set D322 = ( C240 | ( Seg R55 ) );
L1104: ( len C240 ) = ( R55 + 1 ) by CARD_1:def 7;
L1105: C240 = ( D322 ^ <* ( C240 . ( R55 + 1 ) ) *> ) by L1104 , FINSEQ_3:55;
thus L1106: thesis by L1105;
end;
end;
registration
let R55 being Nat;
let R56 being Nat;
let C241 being ( R55 + R56 ) -element FinSequence;
cluster ( C241 | ( Seg R55 ) ) -> R55 -element for FinSequence;
coherence
proof
reconsider D323 = R55 as (Element of ( NAT )) by ORDINAL1:def 12;
set D324 = ( C241 | ( Seg R55 ) );
set D325 = ( R55 + R56 );
L1108: (( R55 + ( 0 ) ) <= D325 & ( len C241 ) = D325) by CARD_1:def 7 , XREAL_1:7;
L1109: (( Seg R55 ) c= ( Seg D325 ) & ( dom C241 ) = ( Seg D325 )) by L1108 , FINSEQ_1:5 , FINSEQ_1:def 3;
reconsider D326 = ( Seg R55 ) as (Subset of ( dom C241 )) by L1109;
L1110: ( dom D324 ) = ( D326 null ( dom C241 ) ) by RELAT_1:61
.= ( Seg D323 );
L1111: ( len D324 ) = D323 by L1110 , FINSEQ_1:def 3;
thus L1112: thesis by L1111 , CARD_1:def 7;
end;
end;
L1114: (for R51 being Relation holds (R51 is { ( {} ) } -valued iff R51 is  empty-yielding))
proof
let R51 being Relation;
L1115: (R51 is { ( {} ) } -valued iff ( rng R51 ) c= { ( {} ) }) by RELAT_1:def 19;
thus L1116: thesis by L1115 , RELAT_1:def 15;
end;
registration
cluster { ( {} ) } -valued ->  empty-yielding for Relation;
coherence by L1114;
cluster  empty-yielding -> { ( {} ) } -valued for Relation;
coherence by L1114;
end;
theorem
L1118: (for R35 being set holds (for R42 being non  empty set holds ( ( R42 -multiCat ) . R35 ) = ( ( MultPlace ( R42 -concatenation ) ) . R35 )))
proof
let R35 being set;
let R42 being non  empty set;
set D327 = ( R42 * );
set D328 = ( R42 -concatenation );
set D329 = ( MultPlace D328 );
set D330 = ( R42 -multiCat );
reconsider D331 = ( ( {} ) .--> ( {} ) ) as { ( {} ) } -valued Function;
L1119: (( dom D328 ) = [: D327 , D327 :] & ( dom D329 ) = ( ( D327 * ) \ { ( {} ) } ) & ( dom D330 ) = ( D327 * )) by FUNCT_2:def 1;
reconsider D332 = ( dom D329 ) as (Subset of ( dom D330 )) by L1119;
per cases ;
suppose L1120: R35 in ( dom D329 );

thus L1121: ( D330 . R35 ) = ( D329 . R35 ) by L1120 , FUNCT_4:13;
end;
suppose L1122: (not R35 in ( dom D329 ));

thus L1123: ( D330 . R35 ) = ( D331 . R35 ) by L1122 , FUNCT_4:11
.= ( D329 . R35 ) by L1122 , FUNCT_1:def 2;
end;
end;
theorem
L1125: (for R42 being non  empty set holds (for R62 being FinSequence holds (for R65 being R42 -valued FinSequence holds (R62 is ( R42 * ) -valued implies ( ( R42 -multiCat ) . ( R62 ^ <* R65 *> ) ) = ( ( ( R42 -multiCat ) . R62 ) ^ R65 )))))
proof
let R42 being non  empty set;
let R62 being FinSequence;
let R65 being R42 -valued FinSequence;
set D333 = ( R42 -multiCat );
set D334 = ( R42 -concatenation );
set D335 = ( MultPlace D334 );
L1126: R65 is (FinSequence of R42) by L8;
reconsider D336 = R65 as (Element of ( R42 * )) by L1126 , FINSEQ_1:def 11;
per cases ;
suppose L1127: R62 is  empty;

reconsider D337 = R62 as  empty set by L1127;
L1128: (( ( D333 . D337 ) ^ R65 ) = R65 & ( D333 . ( D337 ^ <* R65 *> ) ) = ( D333 . <* R65 *> ));
L1129: ( D333 . ( D337 ^ <* R65 *> ) ) = ( D335 . <* D336 *> ) by L1118
.= D336 by L1015;
thus L1130: thesis by L1129 , L1128;
end;
suppose L1131: (not R62 is  empty);

assume L1132: R62 is ( R42 * ) -valued;
reconsider D338 = R62 as non  empty ( R42 * ) -valued FinSequence by L1132 , L1131;
L1133: D338 is non  empty non  empty non  empty non  empty (FinSequence of ( R42 * )) by L8;
reconsider D339 = D338 as non  empty (Element of ( ( R42 * ) * )) by L1133 , FINSEQ_1:def 11;
L1134: ( D333 . ( D338 ^ <* R65 *> ) ) = ( D335 . ( D338 ^ <* D336 *> ) ) by L1118
.= ( D334 . (( D335 . D338 ) , D336) ) by L1015
.= ( D334 . (( D333 . D339 ) , R65) ) by L1118
.= ( ( D333 . R62 ) ^ R65 ) by L106;
thus L1135: thesis by L1134;
end;
end;
L1137: (for R35 being set holds (for R42 being non  empty set holds (for R46 being (Element of R42) holds (for R62 being FinSequence holds (R62 is ( R42 * ) -valued implies ( ( R35 SubstWith R46 ) . ( ( R42 -multiCat ) . R62 ) ) = ( ( R42 -multiCat ) . ( ( R35 SubstWith R46 ) * R62 ) ))))))
proof
let R35 being set;
let R42 being non  empty set;
let R46 being (Element of R42);
let R62 being FinSequence;
set D340 = R42;
set D341 = ( D340 -multiCat );
set D342 = R42;
set D343 = ( R42 * );
set D344 = ( R35 SubstWith R46 );
set D345 = ( len R62 );
set D346 = ( R42 -firstChar );
set D347 = ( D343 -firstChar );
set D348 = ( D342 -concatenation );
set D349 = ( MultPlace D348 );
defpred S15[ Nat ] means (for B145 being $1 -element D343 -valued FinSequence holds ( D344 . ( D341 . B145 ) ) = ( D341 . ( D344 * B145 ) ));
L1138: S15[ ( 0 ) ];
L1139: (for R56 being Nat holds (S15[ R56 ] implies S15[ ( R56 + 1 ) ]))
proof
let R56 being Nat;
set D350 = ( R56 + 1 );
assume L1140: S15[ R56 ];
let C242 being D350 -element D343 -valued FinSequence;
reconsider D351 = ( C242 | ( Seg R56 ) ) as R56 -element D343 -valued FinSequence;
L1141: D351 is R56 -element R56 -element R56 -element R56 -element (FinSequence of D343) by L8;
reconsider D352 = D351 as R56 -element (Element of ( D343 * )) by L1141 , FINSEQ_1:def 11;
L1142: C242 is ( D350 + ( 0 ) ) -element;
L1143: ( { ( C242 . D350 ) } \ D343 ) = ( {} ) by L1142;
reconsider D353 = ( C242 . D350 ) as (Element of D343) by L1143 , ZFMISC_1:60;
reconsider D354 = ( D344 . D353 ) as (Element of ( D342 * ));
L1144: ( ( D351 ^ <* D353 *> ) \+\ C242 ) = ( {} );
L1145: ( D351 ^ <* D353 *> ) = C242 by L1144 , L995;
L1146: ( D341 . ( D344 * C242 ) ) = ( D341 . ( ( D344 * D352 ) ^ <* D354 *> ) ) by L1145 , FINSEQOP:8
.= ( ( D341 . ( D344 * D352 ) ) ^ D354 ) by L1125
.= ( ( D344 . ( D341 . D352 ) ) ^ D354 ) by L1140
.= ( D344 . ( ( D341 . D352 ) ^ D353 ) ) by L1078
.= ( D344 . ( D341 . C242 ) ) by L1125 , L1145;
thus L1147: thesis by L1146;
end;
L1148: (for R56 being Nat holds S15[ R56 ]) from NAT_1:sch 2(L1138 , L1139);
assume L1149: R62 is ( R42 * ) -valued;
reconsider D355 = R62 as D345 -element ( R42 * ) -valued FinSequence by L1149 , CARD_1:def 7;
L1150: ( D344 . ( D341 . D355 ) ) = ( D341 . ( D344 * D355 ) ) by L1148;
thus L1151: thesis by L1150;
end;
registration
let R33 being set;
let C243 being (Subset of R33);
let C244 being  total R33 -defined Relation;
cluster ( C244 | C243 ) ->  total for C243 -defined C243 -defined C243 -defined C243 -defined Relation;
coherence
proof
set D356 = ( C244 | C243 );
L1152: ( dom C244 ) = R33 by PARTFUN1:def 2;
L1153: ( dom D356 ) = ( C243 null R33 ) by L1152 , RELAT_1:61;
reconsider D357 = D356 as C243 -defined Relation;
thus L1154: thesis by L1153 , PARTFUN1:def 2;
end;
end;
theorem
L1156: (for R37 being set holds (for R42 being non  empty set holds (for R46 being (Element of R42) holds (for R47 being (Element of R42) holds ((R46 = R47 implies ( (R47 , R37) -SymbolSubstIn <* R46 *> ) = <* R37 *>) & (R46 <> R47 implies ( (R47 , R37) -SymbolSubstIn <* R46 *> ) = <* R46 *>)))))) by L1033;
theorem
L1157: (for R42 being non  empty set holds (for R46 being (Element of R42) holds (for R47 being (Element of R42) holds (for R48 being (Element of R42) holds ((R46 = R47 implies ( ( R47 SubstWith R48 ) . <* R46 *> ) = <* R48 *>) & (R46 <> R47 implies ( ( R47 SubstWith R48 ) . <* R46 *> ) = <* R46 *>)))))) by L1064;
theorem
L1158: (for R35 being set holds (for R42 being non  empty set holds (for R46 being (Element of R42) holds (for R66 being R42 -valued FinSequence holds (for R67 being R42 -valued FinSequence holds ( ( R35 SubstWith R46 ) . ( R66 ^ R67 ) ) = ( ( ( R35 SubstWith R46 ) . R66 ) ^ ( ( R35 SubstWith R46 ) . R67 ) )))))) by L1078;
theorem
L1159: (for R35 being set holds (for R42 being non  empty set holds (for R46 being (Element of R42) holds (for R62 being FinSequence holds (R62 is ( R42 * ) -valued implies ( ( R35 SubstWith R46 ) . ( ( R42 -multiCat ) . R62 ) ) = ( ( R42 -multiCat ) . ( ( R35 SubstWith R46 ) * R62 ) )))))) by L1137;
theorem
L1160: (for R42 being non  empty set holds ( ( R42 -concatenation ) .: ( id ( 1 -tuples_on R42 ) ) ) = { <* B146 , B146 *> where B146 is (Element of R42) : (not contradiction) })
proof
let R42 being non  empty set;
set D358 = ( R42 -concatenation );
set D359 = ( 1 -tuples_on R42 );
set D360 = ( id D359 );
set D361 = ( 2 -tuples_on R42 );
set D362 = ( D358 .: D360 );
set D363 = { <* B147 , B147 *> where B147 is (Element of R42) : (not contradiction) };
L1161: (D360 c= [: D359 , D359 :] & D359 c= ( R42 * )) by FINSEQ_2:142;
L1162: [: D359 , D359 :] c= [: ( R42 * ) , ( R42 * ) :] by L1161 , ZFMISC_1:96;
reconsider D364 = D360 as (Subset of [: ( R42 * ) , ( R42 * ) :]) by L1162 , XBOOLE_1:1;
L1163: D359 = { <* B148 *> where B148 is (Element of R42) : (not contradiction) } by FINSEQ_2:96;
L1164: (( dom D360 ) = D359 & ( dom D358 ) = [: ( R42 * ) , ( R42 * ) :]) by FUNCT_2:def 1;
L1165: D360 = { [ B149 , ( D360 . B149 ) ] where B149 is (Element of D359) : B149 in D359 } by L1164 , L825;
L1166:
now
let R38 being set;
assume L1167: R38 in D362;
consider R35 being set such that L1168: (R35 in ( dom D358 ) & R35 in D360 & R38 = ( D358 . R35 )) by L1167 , FUNCT_1:def 6;
consider C245 being (Element of D359) such that L1169: (R35 = [ C245 , ( D360 . C245 ) ] & C245 in D359) by L1168 , L1165;
consider C246 being (Element of R42) such that L1170: (C245 = <* C246 *> & (not contradiction)) by L1169 , L1163;
reconsider D365 = C245 as (FinSequence of R42);
L1171: ( { ( D360 . C245 ) } \ { C245 } ) is  empty;
L1172: R38 = ( D358 . (D365 , D365) ) by L1171 , L1168 , L1169 , ZFMISC_1:15;
L1173: R38 = <* C246 , C246 *> by L1172 , L106 , L1170;
thus L1174: R38 in D363 by L1173;
end;
L1175: D362 c= D363 by L1166 , TARSKI:def 3;
L1176:
now
let R38 being set;
assume L1177: R38 in D363;
consider C247 being (Element of R42) such that L1178: (R38 = <* C247 , C247 *> & (not contradiction)) by L1177;
reconsider D366 = <* C247 *> as (Element of D359) by FINSEQ_2:98;
reconsider D367 = D366 as (FinSequence of R42);
L1179: ([ D366 , ( D360 . D366 ) ] = [ D366 , D366 ] & D366 in D359) by FUNCT_1:18;
L1180: [ D366 , D366 ] in D360 by L1179 , L1165;
reconsider D368 = [ D366 , D366 ] as (Element of D360) by L1180;
L1181: D368 in ( D364 null [: ( R42 * ) , ( R42 * ) :] );
L1182: R38 = ( D358 . (D367 , D367) ) by L1178 , L106
.= ( D358 . D368 );
thus L1183: R38 in ( D358 .: D360 ) by L1182 , L1181 , L1164 , FUNCT_1:def 6;
end;
L1184: D363 c= D362 by L1176 , TARSKI:def 3;
thus L1185: thesis by L1184 , L1175 , XBOOLE_0:def 10;
end;
registration
let R52 being Function;
let R42 being non  empty set;
let R46 being (Element of R42);
cluster ( ( ( R52 | R42 ) . R46 ) \+\ ( R52 . R46 ) ) ->  empty for set;
coherence
proof
L1186: ( ( R52 | R42 ) . R46 ) = ( R52 . R46 ) by FUNCT_1:49;
thus L1187: thesis by L1186;
end;
end;
registration
let R52 being Function;
let R43 being non  empty set;
let R44 being non  empty set;
let C248 being (Element of R43);
let C249 being (Function of R43 , R44);
cluster ( ( ( R52 * C249 ) . C248 ) \+\ ( R52 . ( C249 . C248 ) ) ) ->  empty for set;
coherence
proof
L1189: ( dom C249 ) = R43 by FUNCT_2:def 1;
L1190: ( ( R52 * C249 ) . C248 ) = ( R52 . ( C249 . C248 ) ) by L1189 , FUNCT_1:13;
thus L1191: thesis by L1190;
end;
end;
registration
cluster non  negative ->  natural for  integer  integer  integer  integer number;
coherence
proof
let C250 being  integer number;
assume L1193: C250 is non  negative;
L1194: C250 in ( NAT ) by L1193 , INT_1:3;
thus L1195: thesis by L1194;
end;
end;
registration
let C251 , C252 being  real number;
cluster ( ( max (C251 , C252) ) - C251 ) -> non  negative for  ext-real  ext-real  ext-real  ext-real number;
coherence
proof
set D369 = ( max (C251 , C252) );
L1197: C251 <= D369 by XXREAL_0:25;
L1198: ( C251 + ( - C251 ) ) <= ( D369 + ( - C251 ) ) by L1197 , XREAL_1:6;
L1199: ( 0 ) <= ( D369 - C251 ) by L1198;
thus L1200: thesis by L1199;
end;
end;
theorem
L1202: (for R35 being set holds (R35 is  boolean implies (R35 = 1 iff R35 <> ( 0 )))) by XBOOLEAN:def 3;
registration
let R33 being set;
let C253 being (Subset of R33);
cluster ( C253 \ R33 ) ->  empty for set;
coherence by XBOOLE_1:37;
end;
registration
let R35 being set;
let R38 being set;
cluster ( { R35 } \ { R35 , R38 } ) ->  empty for set;
coherence
proof
L1204: R35 in { R35 , R38 } by TARSKI:def 2;
thus L1205: thesis by L1204 , ZFMISC_1:60;
end;
cluster ( ( [ R35 , R38 ] `1 ) \+\ R35 ) ->  empty for set;
coherence
proof
thus L1206: thesis;
end;
end;
registration
let R35 being set;
let R38 being set;
cluster ( ( [ R35 , R38 ] `2 ) \+\ R38 ) ->  empty for set;
coherence
proof
thus L1208: thesis;
end;
end;
registration
let C254 being  positive Nat;
let C255 being non  empty set;
cluster C254 -element for (Element of ( ( C255 * ) \ { ( {} ) } ));
existence
proof
consider R55 being Nat such that L1210: C254 = ( R55 + 1 ) by NAT_1:6;
set D370 = the (Element of ( ( R55 + 1 ) -tuples_on C255 ));
reconsider D371 = ( R55 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
L1211: (D370 in ( D371 -tuples_on C255 ) & ( D371 -tuples_on C255 ) c= ( C255 * )) by FINSEQ_2:134;
L1212: (not D370 in { ( {} ) });
reconsider D372 = D370 as (Element of ( ( C255 * ) \ { ( {} ) } )) by L1212 , L1211 , XBOOLE_0:def 5;
take D372;
thus L1213: thesis by L1210;
end;
end;
registration
let R60 being non  zero Nat;
cluster ( R60 + ( 0 ) ) -element -> non  empty for FinSequence;
coherence
proof
let C256 being FinSequence;
assume L1215: C256 is ( R60 + ( 0 ) ) -element;
L1216: ( len C256 ) = R60 by L1215 , CARD_1:def 7;
thus L1217: thesis by L1216;
end;
end;
registration
let R51 being Relation;
let R35 being set;
cluster ( R51 null R35 ) ->  Relation-like for set;
coherence;
end;
registration
let C257 being  Function-like set;
let R35 being set;
cluster ( C257 null R35 ) ->  Function-like for set;
coherence;
end;
registration
let C258 being  FinSequence-like Relation;
let R35 being set;
cluster ( C258 null R35 ) ->  FinSequence-like for Relation;
coherence;
end;
registration
let R62 being FinSequence;
let R35 being set;
cluster ( R62 null R35 ) -> ( len R62 ) -element for FinSequence;
coherence by CARD_1:def 7;
end;
registration
let C259 being non  empty FinSequence;
cluster ( len C259 ) -> non  zero for number;
coherence;
end;
registration
let C260 being Relation;
let C261 being set;
cluster ( C260 | C261 ) -> C261 -defined for Relation;
coherence
proof
L1224: ( dom ( C260 | C261 ) ) c= C261 by RELAT_1:58;
thus L1225: thesis by L1224 , RELAT_1:def 18;
end;
end;
registration
let R35 being set;
let C262 being  empty set;
cluster ( C262 null R35 ) ->  empty for set;
coherence;
end;
registration
let R32 being set;
let C263 being  empty set;
cluster ( C263 null R32 ) -> R32 -valued for Relation;
coherence
proof
L1228: ( rng C263 ) = ( ( rng C263 ) /\ R32 );
thus L1229: thesis by L1228 , RELAT_1:def 19;
end;
end;
registration
let C264 being non  empty  FinSequence-membered set;
cluster C264 -valued ->  FinSequence-yielding for Function;
coherence
proof
let R52 being Function;
assume L1231: R52 is C264 -valued;
L1232: ( rng R52 ) c= C264 by L1231 , RELAT_1:def 19;
L1233:
now
let R35 being set;
assume L1234: R35 in ( dom R52 );
reconsider D373 = ( dom R52 ) as non  empty set by L1234;
reconsider D374 = R35 as (Element of D373) by L1234;
reconsider D375 = R52 as (Function of D373 , C264) by L1232 , FUNCT_2:2;
L1235: ( D375 . D374 ) in C264;
thus L1236: ( R52 . R35 ) is FinSequence by L1235;
end;
thus L1237: thesis by L1233 , PRE_POLY:def 3;
end;
end;
registration
let R32 being set;
let R33 being set;
cluster  ->  FinSequence-yielding for (Element of ( Funcs (R32 , ( R33 * )) ));
coherence;
end;
theorem
L1240: (for R32 being set holds (for R35 being set holds (for R52 being Function holds (R52 is ( R32 * ) -valued implies ( R52 . R35 ) in ( R32 * )))))
proof
let R32 being set;
let R35 being set;
let R52 being Function;
assume L1241: R52 is ( R32 * ) -valued;
L1242: ( rng R52 ) c= ( R32 * ) by L1241 , RELAT_1:def 19;
per cases ;
suppose L1243: R35 in ( dom R52 );

reconsider D376 = ( dom R52 ) as non  empty set by L1243;
reconsider D377 = R35 as (Element of D376) by L1243;
reconsider D378 = R52 as (Function of D376 , ( R32 * )) by L1242 , FUNCT_2:2;
L1244: ( D378 . D377 ) is (Element of ( R32 * ));
thus L1245: thesis by L1244;
end;
suppose L1246: (not R35 in ( dom R52 ));

L1247: ( R52 . R35 ) = ( {} ) by L1246 , FUNCT_1:def 2;
thus L1248: thesis by L1247 , FINSEQ_1:49;
end;
end;
registration
let R55 being Nat;
let R56 being Nat;
let C265 being R55 -element FinSequence;
cluster ( C265 null R56 ) -> ( Seg ( R55 + R56 ) ) -defined for Relation;
coherence
proof
L1250: ( dom C265 ) = ( Seg ( len C265 ) ) by FINSEQ_1:def 3;
L1251: (( R55 + ( 0 ) ) <= ( R55 + R56 ) & ( dom C265 ) = ( Seg R55 )) by L1250 , CARD_1:def 7 , XREAL_1:6;
L1252: ( dom C265 ) c= ( Seg ( R55 + R56 ) ) by L1251 , FINSEQ_1:5;
thus L1253: thesis by L1252 , RELAT_1:def 18;
end;
end;
L1255: (for R55 being Nat holds (for B150 , B151 , B152 , B153 being FinSequence holds ((B150 is R55 -element & B152 is R55 -element & ( B150 ^ B151 ) = ( B152 ^ B153 )) implies (B150 = B152 & B151 = B153))))
proof
let R55 being Nat;
let C266 , C267 , C268 , C269 being FinSequence;
set D379 = ( C266 ^ C267 );
set D380 = ( C268 ^ C269 );
assume L1256: (C266 is R55 -element & C268 is R55 -element);
reconsider D381 = C266 , D382 = C268 as R55 -element FinSequence by L1256;
L1257: (( Seg ( len C266 ) ) = ( dom C266 ) & ( Seg ( len C268 ) ) = ( dom C268 )) by FINSEQ_1:def 3;
L1258: (( dom D381 ) = ( Seg R55 ) & ( dom D382 ) = ( Seg R55 )) by L1257 , CARD_1:def 7;
assume L1259: D379 = D380;
L1260: (( D381 null ( 0 ) ) is ( Seg ( R55 + ( 0 ) ) ) -defined & ( D382 null ( 0 ) ) is ( Seg ( R55 + ( 0 ) ) ) -defined);
reconsider D383 = C266 , D384 = C268 as ( Seg R55 ) -defined FinSequence by L1260;
L1261: ( D383 null ( Seg R55 ) ) = ( ( D384 ^ C269 ) | ( Seg R55 ) ) by L1258 , L1259 , FINSEQ_6:11
.= ( D384 null ( Seg R55 ) ) by L1258 , FINSEQ_6:11;
thus L1262: C266 = C268 by L1261;
thus L1263: C267 = C269 by L1261 , L1259 , FINSEQ_1:33;
end;
registration
let R55 being Nat;
let R56 being Nat;
let C270 being R55 -element FinSequence;
let C271 being R56 -element FinSequence;
cluster ( C270 ^ C271 ) -> ( R55 + R56 ) -element for FinSequence;
coherence
proof
reconsider D385 = R55 , D386 = R56 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D387 = C270 as D385 -element FinSequence;
reconsider D388 = C271 as D386 -element FinSequence;
L1264: ( D387 ^ D388 ) is ( D385 + D386 ) -element;
thus L1265: thesis by L1264;
end;
end;
theorem
L1267: (for R55 being Nat holds (for B154 , B155 , B156 , B157 being FinSequence holds ((B154 is R55 -element & B156 is R55 -element & (( B154 ^ B155 ) = ( B156 ^ B157 ) or ( B155 ^ B154 ) = ( B157 ^ B156 ))) implies (B154 = B156 & B155 = B157))))
proof
let R55 being Nat;
let C272 , C273 , C274 , C275 being FinSequence;
set D389 = ( len C272 );
set D390 = ( len C273 );
set D391 = ( len C274 );
set D392 = ( len C275 );
assume L1268: (C272 is R55 -element & C274 is R55 -element);
reconsider D393 = C272 , D394 = C274 as R55 -element FinSequence by L1268;
reconsider D395 = ( C273 null C273 ) as D390 -element FinSequence;
reconsider D396 = ( C275 null C275 ) as D392 -element FinSequence;
set D397 = ( D393 ^ D395 );
set D398 = ( D395 ^ D393 );
set D399 = ( D394 ^ D396 );
set D400 = ( D396 ^ D394 );
L1269: (( len D397 ) = ( R55 + D390 ) & ( len D398 ) = ( D390 + R55 ) & ( len D399 ) = ( R55 + D392 ) & ( len D400 ) = ( D392 + R55 )) by CARD_1:def 7;
assume L1270: (( C272 ^ C273 ) = ( C274 ^ C275 ) or ( C273 ^ C272 ) = ( C275 ^ C274 ));
L1271: (D397 = D399 or D398 = D400) by L1270;
reconsider D401 = D396 as D390 -element FinSequence by L1270 , L1269;
L1272: (D395 is D390 -element & D401 is D390 -element);
thus L1273: thesis by L1272 , L1271 , L1255;
end;
theorem
L1274: (for R35 being set holds (for R42 being non  empty set holds (for R43 being non  empty set holds ((( ( R42 -multiCat ) . R35 ) is R43 -valued & R35 in ( ( R42 * ) * )) implies R35 is (FinSequence of ( R43 * ))))))
proof
let R35 being set;
let R42 being non  empty set;
let R43 being non  empty set;
set D402 = ( R42 -multiCat );
set D403 = ( R42 -concatenation );
set D404 = ( MultPlace D403 );
set D405 = ( R42 * );
L1275: ( ( {} ) null ( R42 * ) ) is ( R42 * ) -valued ( R42 * ) -valued ( R42 * ) -valued ( R42 * ) -valued Relation;
reconsider D406 = ( {} ) as ( R42 * ) -valued FinSequence by L1275;
defpred S16[ Nat ] means (for B158 being ( $1 + 1 ) -element ( R42 * ) -valued FinSequence holds (( D402 . B158 ) is R43 -valued implies B158 is ( R43 * ) -valued));
L1276: S16[ ( 0 ) ]
proof
let C276 being ( ( 0 ) + 1 ) -element ( R42 * ) -valued FinSequence;
reconsider D407 = C276 as ( 1 + ( 0 ) ) -element ( R42 * ) -valued FinSequence;
L1277: ( { ( D407 . 1 ) } \ ( R42 * ) ) = ( {} );
reconsider D408 = ( C276 . 1 ) as (Element of ( R42 * )) by L1277 , ZFMISC_1:60;
L1278: ( len C276 ) = 1 by CARD_1:def 7;
L1279: C276 = ( ( {} ) ^ <* ( C276 . 1 ) *> ) by L1278 , FINSEQ_1:40;
L1280: ( D402 . C276 ) = ( ( D402 . D406 ) ^ D408 ) by L1279 , L1125
.= ( ( {} ) ^ ( C276 . 1 ) )
.= ( C276 . 1 );
L1281: C276 is 1 -element 1 -element 1 -element 1 -element (FinSequence of ( R42 * )) by L8;
reconsider D409 = C276 as 1 -element (Element of ( ( R42 * ) * )) by L1281 , FINSEQ_1:def 11;
assume L1282: ( D402 . C276 ) is R43 -valued;
reconsider D410 = ( D402 . D409 ) as (FinSequence of R43) by L1282 , L8;
L1283: D410 = ( C276 . 1 ) by L1280;
reconsider D411 = ( C276 . 1 ) as (Element of ( R43 * )) by L1283 , FINSEQ_1:def 11;
L1284: <* D411 *> is (FinSequence of ( R43 * ));
thus L1285: thesis by L1284 , L1278 , FINSEQ_1:40;
end;
L1286: (for R56 being Nat holds (S16[ R56 ] implies S16[ ( R56 + 1 ) ]))
proof
let R56 being Nat;
reconsider D412 = ( R56 + 1 ) as non  zero (Element of ( NAT )) by ORDINAL1:def 12;
assume L1287: S16[ R56 ];
let C277 being ( ( R56 + 1 ) + 1 ) -element ( R42 * ) -valued FinSequence;
assume L1288: ( D402 . C277 ) is R43 -valued;
reconsider D413 = ( C277 null C277 ) as ( R56 + 2 ) -element ( R42 * ) -valued FinSequence;
reconsider D414 = D413 as ( D412 + 1 ) -element ( R42 * ) -valued FinSequence;
reconsider D415 = D414 as ( ( D412 + 1 ) + ( 0 ) ) -element ( R42 * ) -valued FinSequence;
reconsider D416 = ( D414 | ( Seg D412 ) ) as D412 -element ( R42 * ) -valued FinSequence;
L1289: ( { ( D415 . ( D412 + 1 ) ) } \ ( R42 * ) ) = ( {} );
reconsider D417 = ( D414 . ( D412 + 1 ) ) as (Element of ( R42 * )) by L1289 , ZFMISC_1:60;
L1290: ( D414 \+\ ( D416 ^ <* ( D414 . ( D412 + 1 ) ) *> ) ) = ( {} );
L1291: C277 = ( D416 ^ <* D417 *> ) by L1290 , L995;
L1292: ( D402 . C277 ) = ( ( D402 . D416 ) ^ D417 ) by L1291 , L1125;
L1293: (( rng ( D402 . C277 ) ) c= R43 & ( rng ( D402 . D416 ) ) c= ( rng ( D402 . C277 ) )) by L1292 , L1288 , FINSEQ_1:29 , RELAT_1:def 19;
L1294: ( rng ( D402 . D416 ) ) c= R43 by L1293 , XBOOLE_1:1;
reconsider D418 = ( D402 . D416 ) as R43 -valued FinSequence by L1294 , RELAT_1:def 19;
L1295: D418 is R43 -valued;
reconsider D419 = D416 as D412 -element ( R43 * ) -valued FinSequence by L1295 , L1287;
L1296: (( rng D417 ) c= ( rng ( D402 . C277 ) ) & ( rng ( D402 . C277 ) ) c= R43) by L1292 , L1288 , FINSEQ_1:30 , RELAT_1:def 19;
L1297: ( rng D417 ) c= R43 by L1296 , XBOOLE_1:1;
L1298: D417 is R43 -valued by L1297 , RELAT_1:def 19;
L1299: D417 is (FinSequence of R43) by L1298 , L8;
reconsider D420 = D417 as (Element of ( R43 * )) by L1299 , FINSEQ_1:def 11;
L1300: ( D419 ^ <* D420 *> ) is ( R43 * ) -valued;
thus L1301: thesis by L1300 , L1290 , L995;
end;
L1302: (for R56 being Nat holds S16[ R56 ]) from NAT_1:sch 2(L1276 , L1286);
assume L1303: (( D402 . R35 ) is R43 -valued & R35 in ( ( R42 * ) * ));
per cases ;
suppose L1304: R35 is  empty;

reconsider D421 = R35 as  empty set by L1304;
L1305: ( D421 null ( R43 * ) ) is ( R43 * ) -valued ( R43 * ) -valued ( R43 * ) -valued ( R43 * ) -valued FinSequence;
thus L1306: thesis by L1305 , L8;
end;
suppose L1307: (not R35 is  empty);

reconsider D422 = R35 as non  empty ( R42 * ) -valued FinSequence by L1307 , L1303;
consider R55 being Nat such that L1308: ( len D422 ) = ( R55 + 1 ) by NAT_1:6;
L1309: ( D422 null ( {} ) ) is ( R55 + 1 ) -element by L1308;
reconsider D423 = D422 as ( R55 + 1 ) -element ( R42 * ) -valued FinSequence by L1309;
L1310: D423 is ( R43 * ) -valued by L1303 , L1302;
thus L1311: thesis by L1310 , L8;
end;
end;
registration
let R55 being Nat;
cluster ( R55 + 1 ) -element -> non  empty for FinSequence;
coherence
proof
let R62 being FinSequence;
set D424 = ( R55 + 1 );
assume L1313: R62 is D424 -element;
reconsider D425 = R62 as ( D424 + ( 0 ) ) -element FinSequence by L1313;
L1314: D425 is non  empty;
thus L1315: thesis by L1314;
end;
end;
registration
let R42 being non  empty set;
let R46 being (Element of R42);
cluster ( ( ( id R42 ) . R46 ) \+\ R46 ) ->  empty for set;
coherence
proof
L1317: ( { ( ( id R42 ) . R46 ) } \ { R46 } ) = ( {} );
L1318: ( ( id R42 ) . R46 ) = R46 by L1317 , ZFMISC_1:15;
thus L1319: thesis by L1318;
end;
end;
registration
let R42 being non  empty set;
let C278 being R42 -valued non  empty FinSequence;
cluster ( { ( C278 . 1 ) } \ R42 ) ->  empty for set;
coherence
proof
consider R55 being Nat such that L1321: ( len C278 ) = ( R55 + 1 ) by NAT_1:6;
reconsider D426 = C278 as ( 1 + R55 ) -element R42 -valued FinSequence by L1321 , CARD_1:def 7;
L1322: ( { ( D426 . 1 ) } \ R42 ) = ( {} );
thus L1323: thesis by L1322;
end;
end;
theorem
L1325: (for R36 being set holds (for R37 being set holds (for R39 being set holds (for R40 being set holds (for R52 being Function holds ((R36 = R37 implies ( ( R52 +* ( R36 .--> R39 ) ) +* ( R37 .--> R40 ) ) = ( R52 +* ( R37 .--> R40 ) )) & (R36 <> R37 implies ( ( R52 +* ( R36 .--> R39 ) ) +* ( R37 .--> R40 ) ) = ( ( R52 +* ( R37 .--> R40 ) ) +* ( R36 .--> R39 ) ))))))))
proof
let R36 being set;
let R37 being set;
let R39 being set;
let R40 being set;
let R52 being Function;
set D427 = ( R36 .--> R39 );
set D428 = ( R37 .--> R40 );
set D429 = ( ( R52 +* D427 ) +* D428 );
thus L1326:now
assume L1327: R36 = R37;
L1328: { R36 } = ( dom D428 ) by L1327 , FUNCOP_1:13;
L1329: ( dom D427 ) = ( dom D428 ) by L1328 , FUNCOP_1:13;
L1330: ( D427 +* D428 ) = D428 by L1329 , FUNCT_4:19;
thus L1331: D429 = ( R52 +* D428 ) by L1330 , FUNCT_4:14;
end;
assume L1332: R36 <> R37;
L1333: { R36 } misses { R37 } by L1332 , ZFMISC_1:11;
L1334: D427 tolerates D428 by L1333 , FUNCOP_1:87;
L1335: ( R52 +* ( D427 +* D428 ) ) = ( R52 +* ( D428 +* D427 ) ) by L1334 , FUNCT_4:34
.= ( ( R52 +* D428 ) +* D427 ) by FUNCT_4:14;
thus L1336: D429 = ( ( R52 +* D428 ) +* D427 ) by L1335 , FUNCT_4:14;
end;
registration
let R32 being set;
let R42 being non  empty set;
cluster R42 -valued  total for R32 -defined R32 -defined R32 -defined R32 -defined Function;
existence
proof
take the  total (PartFunc of R32 , R42);
thus L1337: thesis;
end;
end;
registration
let R32 being set;
let R42 being non  empty set;
let C279 being R42 -valued  total R32 -defined Relation;
let C280 being  total R42 -defined Relation;
cluster ( C279 * C280 ) ->  total for R32 -defined R32 -defined R32 -defined R32 -defined Relation;
coherence
proof
L1339: (( rng C279 ) c= R42 & ( dom C280 ) = R42) by PARTFUN1:def 2;
L1340: ( dom ( C279 * C280 ) ) = ( dom C279 ) by L1339 , RELAT_1:27
.= R32 by PARTFUN1:def 2;
thus L1341: thesis by L1340 , PARTFUN1:def 2;
end;
end;
theorem
L1343: (for R32 being set holds (for R62 being FinSequence holds (for R63 being FinSequence holds (for R64 being FinSequence holds (( ( R62 ^ R63 ) ^ R64 ) is R32 -valued implies (R64 is R32 -valued & R63 is R32 -valued & R62 is R32 -valued))))))
proof
let R32 being set;
let R62 being FinSequence;
let R63 being FinSequence;
let R64 being FinSequence;
set D430 = ( ( R62 ^ R63 ) ^ R64 );
assume L1344: D430 is R32 -valued;
L1345: (( rng D430 ) c= R32 & ( rng ( R62 ^ R63 ) ) c= ( rng D430 ) & ( rng R64 ) c= ( rng D430 )) by L1344 , FINSEQ_1:29 , FINSEQ_1:30 , RELAT_1:def 19;
L1346: (( rng R64 ) c= R32 & ( rng R62 ) c= ( rng ( R62 ^ R63 ) ) & ( rng R63 ) c= ( rng ( R62 ^ R63 ) ) & ( rng ( R62 ^ R63 ) ) c= R32) by L1345 , FINSEQ_1:29 , FINSEQ_1:30 , XBOOLE_1:1;
L1347: (( rng R62 ) c= R32 & ( rng R63 ) c= R32 & ( rng R64 ) c= R32) by L1346 , XBOOLE_1:1;
thus L1348: thesis by L1347 , RELAT_1:def 19;
end;
registration
let R32 being set;
let C281 being Relation;
cluster ( C281 null R32 ) -> ( R32 \/ ( rng C281 ) ) -valued for Relation;
coherence
proof
L1349: ( ( rng C281 ) null R32 ) c= ( ( rng C281 ) \/ R32 );
thus L1350: thesis by L1349 , RELAT_1:def 19;
end;
end;
registration
let C282 , C283 being  functional set;
cluster ( C282 \/ C283 ) ->  functional;
coherence
proof
L1352:
now
let R35 being set;
assume L1353: R35 in ( C282 \/ C283 );
L1354: (R35 in C282 or R35 in C283) by L1353 , XBOOLE_0:def 3;
thus L1355: R35 is Function by L1354;
end;
thus L1356: thesis by L1352 , FUNCT_1:def 13;
end;
end;
registration
cluster  FinSequence-membered ->  finite-membered for set;
coherence
proof
let R32 being set;
assume L1358: R32 is  FinSequence-membered;
L1359: (for R35 being set holds (R35 in R32 implies R35 is  finite)) by L1358;
thus L1360: thesis by L1359 , FINSET_1:def 6;
end;
end;
definition
let C284 being  functional set;
func SymbolsOf C284 equals 
( union { ( rng B159 ) where B159 is (Element of ( C284 \/ { ( {} ) } )) : B159 in C284 } );
coherence;
end;
L1363: (for B160 being  functional set holds ((B160 is  finite & B160 is  finite-membered) implies ( SymbolsOf B160 ) is  finite))
proof
let C285 being  functional set;
set D431 = ( C285 \/ { ( {} ) } );
set D432 = { ( rng B161 ) where B161 is (Element of D431) : B161 in C285 };
assume L1364: C285 is  finite;
L1365: D432 is  finite from FRAENKEL:sch 21(L1364);
reconsider D433 = D432 as  finite set by L1365;
assume L1366: C285 is  finite-membered;
reconsider D434 = D431 as  finite-membered set by L1366;
L1367:
now
let R38 being set;
assume L1368: R38 in D432;
consider C286 being (Element of D431) such that L1369: (R38 = ( rng C286 ) & C286 in C285) by L1368;
reconsider D435 = C286 as (Element of D434);
L1370: D435 is  finite;
thus L1371: R38 is  finite by L1370 , L1369;
end;
reconsider D436 = D433 as  finite-membered  finite set by L1367 , FINSET_1:def 6;
L1372: ( union D436 ) is  finite;
thus L1373: thesis by L1372;
end;
registration
cluster  trivial  FinSequence-membered non  empty for set;
existence
proof
take { the (Element of ( the non  empty set * )) };
thus L1374: thesis;
end;
end;
registration
let C287 being  functional  finite  finite-membered set;
cluster ( SymbolsOf C287 ) ->  finite;
coherence by L1363;
end;
registration
let C288 being  finite  FinSequence-membered set;
cluster ( SymbolsOf C288 ) ->  finite;
coherence;
end;
theorem
L1378: (for R52 being Function holds ( SymbolsOf { R52 } ) = ( rng R52 ))
proof
let R52 being Function;
set D437 = R52;
set D438 = { D437 };
set D439 = { ( rng B162 ) where B162 is (Element of ( D438 \/ { ( {} ) } )) : B162 in D438 };
set D440 = ( union D439 );
set D441 = ( rng D437 );
L1379: ( D438 null { ( {} ) } ) c= ( D438 \/ { ( {} ) } );
reconsider D442 = D438 as (Subset of ( D438 \/ { ( {} ) } )) by L1379;
reconsider D443 = D437 as (Element of D442) by TARSKI:def 1;
reconsider D444 = D443 as (Element of ( D438 \/ { ( {} ) } )) by TARSKI:def 3;
L1380:
now
let R38 being set;
assume L1381: R38 in D440;
consider R41 being set such that L1382: (R38 in R41 & R41 in D439) by L1381 , TARSKI:def 4;
consider C289 being (Element of ( D438 \/ { ( {} ) } )) such that L1383: (R41 = ( rng C289 ) & C289 in D438) by L1382;
thus L1384: R38 in D441 by L1382 , L1383 , TARSKI:def 1;
end;
L1385: D440 c= D441 by L1380 , TARSKI:def 3;
L1386:
now
let R38 being set;
assume L1387: R38 in D441;
L1388: (R38 in ( rng D443 ) & ( rng D444 ) in D439) by L1387;
thus L1389: R38 in D440 by L1388 , TARSKI:def 4;
end;
L1390: D441 c= D440 by L1386 , TARSKI:def 3;
thus L1391: thesis by L1390 , L1385 , XBOOLE_0:def 10;
end;
registration
let C290 being non  zero  complex number;
cluster ( abs C290 ) ->  positive for  ext-real  ext-real  ext-real  ext-real number;
coherence by COMPLEX1:47;
end;
scheme Sc1 { F1() -> set , F2() -> set , F3(set) -> set } : { F3(B163) where B163 is (Element of F1()) : B163 in F1() } = { F3(B164) where B164 is (Element of F2()) : B164 in F1() }
provided
L1393: F1() c= F2()
proof
set D445 = { F3(B165) where B165 is (Element of F1()) : B165 in F1() };
set D446 = { F3(B166) where B166 is (Element of F2()) : B166 in F1() };
L1394:
now
let R38 being set;
assume L1395: R38 in D445;
consider C291 being (Element of F1()) such that L1396: (R38 = F3(C291) & C291 in F1()) by L1395;
reconsider D447 = C291 as (Element of F2()) by L1396 , L1393;
L1397: (R38 = F3(D447) & D447 in F1()) by L1396;
thus L1398: R38 in D446 by L1397;
end;
L1399: D445 c= D446 by L1394 , TARSKI:def 3;
L1400:
now
let R38 being set;
assume L1401: R38 in D446;
consider C292 being (Element of F2()) such that L1402: (R38 = F3(C292) & C292 in F1()) by L1401;
reconsider D448 = C292 as (Element of F1()) by L1402;
thus L1403: R38 in D445 by L1402;
end;
L1404: D446 c= D445 by L1400 , TARSKI:def 3;
thus L1405: thesis by L1404 , L1399 , XBOOLE_0:def 10;
end;
definition
let C293 being  functional set;
redefine func SymbolsOf C293 equals 
( union { ( rng B167 ) where B167 is (Element of C293) : B167 in C293 } );
compatibility
proof
set D449 = { ( rng B168 ) where B168 is (Element of C293) : B168 in C293 };
set D450 = { ( rng B169 ) where B169 is (Element of ( C293 \/ { ( {} ) } )) : B169 in C293 };
L1406: ( C293 null { ( {} ) } ) c= ( C293 \/ { ( {} ) } );
L1407: C293 c= ( C293 \/ { ( {} ) } ) by L1406;
L1408: D449 = D450 from Sc1(L1407);
thus L1409: thesis by L1408;
end;
end;
L1411: (for B170 being  functional set holds (for B171 being (Subset of B170) holds { ( rng B172 ) where B172 is (Element of B171) : B172 in B171 } c= { ( rng B173 ) where B173 is (Element of B170) : B173 in B170 }))
proof
let C294 being  functional set;
let C295 being (Subset of C294);
set D451 = { ( rng B174 ) where B174 is (Element of C295) : B174 in C295 };
set D452 = { ( rng B175 ) where B175 is (Element of C294) : B175 in C294 };
L1412:
now
let R38 being set;
assume L1413: R38 in D451;
consider C296 being (Element of C295) such that L1414: (R38 = ( rng C296 ) & C296 in C295) by L1413;
reconsider D453 = C296 as (Element of C294) by L1414;
thus L1415: R38 in D452 by L1414;
end;
thus L1416: thesis by L1412 , TARSKI:def 3;
end;
theorem
L1417: (for B176 being  functional set holds (for B177 being (Subset of B176) holds ( SymbolsOf B177 ) c= ( SymbolsOf B176 ))) by L1411 , ZFMISC_1:77;
theorem
L1418: (for B178 , B179 being  functional set holds ( SymbolsOf ( B178 \/ B179 ) ) = ( ( SymbolsOf B178 ) \/ ( SymbolsOf B179 ) ))
proof
let C297 , C298 being  functional set;
set D454 = { ( rng B180 ) where B180 is (Element of C297) : B180 in C297 };
set D455 = { ( rng B181 ) where B181 is (Element of C298) : B181 in C298 };
set D456 = { ( rng B182 ) where B182 is (Element of ( C297 \/ C298 )) : B182 in ( C297 \/ C298 ) };
L1419: (( C297 null C298 ) c= ( C297 \/ C298 ) & ( C298 null C297 ) c= ( C297 \/ C298 ));
reconsider D457 = D454 , D458 = D455 as (Subset of D456) by L1419 , L1411;
L1420: ( D457 \/ D458 ) c= D456;
L1421:
now
let R38 being set;
assume L1422: R38 in ( D456 \ D455 );
L1423: (R38 in D456 & (not R38 in D455)) by L1422 , XBOOLE_0:def 5;
consider C299 being (Element of ( C297 \/ C298 )) such that L1424: (R38 = ( rng C299 ) & C299 in ( C297 \/ C298 )) by L1423;
L1425: (not C299 in C298) by L1424 , L1423;
L1426: C299 in ( C297 null { ( {} ) } ) by L1425 , L1424 , XBOOLE_0:def 3;
reconsider D459 = C299 as (Element of ( C297 \/ { ( {} ) } )) by L1426;
thus L1427: R38 in D454 by L1426 , L1424;
end;
L1428: ( D456 \ D455 ) c= D454 by L1421 , TARSKI:def 3;
L1429: ( ( D456 \ D455 ) \/ D455 ) c= ( D454 \/ D455 ) by L1428 , XBOOLE_1:9;
L1430: ( D456 null D458 ) c= ( D454 \/ D455 ) by L1429 , XBOOLE_1:39;
L1431: ( D454 \/ D455 ) = D456 by L1430 , L1420 , XBOOLE_0:def 10;
thus L1432: thesis by L1431 , ZFMISC_1:78;
end;
registration
let R32 being set;
let C300 being (Subset of ( bool R32 ));
cluster ( ( union C300 ) \ R32 ) ->  empty for set;
coherence;
end;
theorem
L1434: (for R32 being set holds (for R33 being set holds R32 = ( ( R32 \ R33 ) \/ ( R32 /\ R33 ) )))
proof
let R32 being set;
let R33 being set;
reconsider D460 = ( R32 \ R33 ) as (Subset of R32);
L1435: R32 = ( D460 \/ ( R32 \ D460 ) ) by XBOOLE_1:45
.= ( D460 \/ ( R32 /\ R33 ) ) by XBOOLE_1:48;
thus L1436: thesis by L1435;
end;
theorem
L1437: (for R29 being set holds (for R30 being set holds (for R55 being Nat holds (for R56 being Nat holds (( R55 -tuples_on R29 ) meets ( R56 -tuples_on R30 ) implies R55 = R56))))) by L41;
theorem
L1438: (for R2 being non  empty set holds (for R29 being set holds (for R30 being set holds ((R30 is R2 -prefix & R29 c= R30) implies R29 is R2 -prefix)))) by L458;
theorem
L1439: (for R52 being Function holds (for R53 being Function holds (R52 c= R53 iff (for R35 being set holds (R35 in ( dom R52 ) implies (R35 in ( dom R53 ) & ( R52 . R35 ) = ( R53 . R35 )))))))
proof
let R52 being Function;
let R53 being Function;
defpred S17[  ] means (for R35 being set holds (R35 in ( dom R52 ) implies R35 in ( dom R53 )));
defpred S18[  ] means (for R35 being set holds (R35 in ( dom R52 ) implies ( R52 . R35 ) = ( R53 . R35 )));
defpred S19[  ] means (for R35 being set holds (R35 in ( dom R52 ) implies (R35 in ( dom R53 ) & ( R52 . R35 ) = ( R53 . R35 ))));
L1440: ((S17[  ] & S18[  ]) iff (( dom R52 ) c= ( dom R53 ) & S18[  ])) by TARSKI:def 3;
thus L1441: thesis by L1440 , GRFUNC_1:2;
end;
registration
let R42 being non  empty set;
cluster non  empty -> non  empty-yielding for (Element of ( ( ( R42 * ) \ { ( {} ) } ) * ));
coherence
proof
set D461 = ( ( ( R42 * ) \ { ( {} ) } ) * );
let C301 being (Element of D461);
assume L1442: C301 is non  empty;
consider R55 being Nat such that L1443: ( R55 + 1 ) = ( len C301 ) by L1442 , NAT_1:6;
reconsider D462 = C301 as ( 1 + R55 ) -element ( ( R42 * ) \ { ( {} ) } ) -valued FinSequence by L1443 , CARD_1:def 7;
L1444: ( { ( D462 . 1 ) } \ ( ( R42 * ) \ { ( {} ) } ) ) = ( {} );
L1445: ( D462 . 1 ) in ( ( R42 * ) \ { ( {} ) } ) by L1444 , ZFMISC_1:60;
L1446: (( C301 . 1 ) in ( R42 * ) & (not ( C301 . 1 ) in { ( {} ) })) by L1445 , XBOOLE_0:def 5;
L1447: ( C301 . 1 ) <> ( {} ) by L1446 , TARSKI:def 1;
thus L1448: thesis by L1447;
end;
end;
registration
let C302 being  empty set;
cluster  ->  empty for (Element of ( C302 * ));
coherence;
end;
theorem
L1451: (for R35 being set holds (for R43 being non  empty set holds (for R44 being non  empty set holds (for R62 being FinSequence holds (((( ( R43 -multiCat ) . R35 ) <> ( {} ) & ( ( R44 -multiCat ) . R35 ) <> ( {} )) implies ( ( R43 -multiCat ) . R35 ) = ( ( R44 -multiCat ) . R35 )) & (R62 is ( ( {} ) * ) -valued implies ( ( R43 -multiCat ) . R62 ) = ( {} )) & ((( ( R43 -multiCat ) . R62 ) = ( {} ) & R62 is ( R43 * ) -valued) implies R62 is ( ( {} ) * ) -valued))))))
proof
let R35 being set;
let R43 being non  empty set;
let R44 being non  empty set;
let R62 being FinSequence;
reconsider D463 = ( {} ) as (Element of { ( {} ) }) by TARSKI:def 1;
defpred S20[ Nat ] means (for R43 being non  empty set holds (for R44 being non  empty set holds (for R62 being FinSequence holds (R62 is ( $1 + 1 ) -element implies ((R62 is ( ( {} ) * ) -valued implies ( ( R43 -multiCat ) . R62 ) = ( {} )) & ((( ( R43 -multiCat ) . R62 ) = ( {} ) & R62 is ( R43 * ) -valued) implies R62 is { ( {} ) } -valued) & ((( ( R43 -multiCat ) . R62 ) <> ( {} ) & ( ( R44 -multiCat ) . R62 ) <> ( {} )) implies ( ( R43 -multiCat ) . R62 ) = ( ( R44 -multiCat ) . R62 )))))));
L1452: S20[ ( 0 ) ]
proof
let R43 being non  empty set;
let R44 being non  empty set;
let R62 being FinSequence;
set D464 = ( R43 -multiCat );
set D465 = ( R44 -multiCat );
L1453: (( dom D464 ) = ( ( R43 * ) * ) & ( dom D465 ) = ( ( R44 * ) * )) by FUNCT_2:def 1;
L1454: ( ( {} ) /\ R43 ) = ( {} );
reconsider D466 = ( {} ) as (Subset of R43) by L1454;
L1455: ( ( {} ) /\ R44 ) = ( {} );
reconsider D467 = ( {} ) as (Subset of R44) by L1455;
reconsider D468 = ( D467 * ) as non  empty (Subset of ( R44 * ));
reconsider D469 = ( {} ) as (Element of D468) by TARSKI:def 1;
reconsider D470 = ( D466 * ) as non  empty (Subset of ( R43 * ));
reconsider D471 = ( {} ) as (Element of D470) by TARSKI:def 1;
assume L1456: R62 is ( ( 0 ) + 1 ) -element;
reconsider D472 = R62 as ( 1 + ( 0 ) ) -element FinSequence by L1456;
L1457: ( len D472 ) = 1 by CARD_1:def 7;
L1458: R62 = ( ( {} ) ^ <* ( R62 . 1 ) *> ) by L1457 , FINSEQ_1:40
.= ( D471 ^ <* ( R62 . 1 ) *> );
thus L1459:now
assume L1460: R62 is ( ( {} ) * ) -valued;
L1461: R62 = ( D471 ^ <* D471 *> ) by L1460 , L1458;
thus L1462: ( D464 . R62 ) = ( ( D464 . D471 ) ^ D471 ) by L1461 , L1125
.= ( ( {} ) ^ ( {} ) )
.= ( {} );
end;
thus L1463:now
assume L1464: (( D464 . R62 ) = ( {} ) & R62 is ( R43 * ) -valued);
reconsider D473 = D472 as non  empty ( R43 * ) -valued FinSequence by L1464;
L1465: ( { ( D473 . 1 ) } \ ( R43 * ) ) = ( {} );
reconsider D474 = ( D472 . 1 ) as (Element of ( R43 * )) by L1465 , ZFMISC_1:60;
L1466: ( D464 . R62 ) = ( ( D464 . D471 ) ^ D474 ) by L1125 , L1458
.= ( ( {} ) ^ D474 )
.= D474;
L1467: R62 = ( D471 ^ <* D471 *> ) by L1466 , L1458 , L1464;
thus L1468: R62 is { ( {} ) } -valued by L1467;
end;
thus L1469:now
assume L1470: (( D464 . R62 ) <> ( {} ) & ( D465 . R62 ) <> ( {} ));
L1471: (R62 in ( ( R43 * ) * ) & R62 in ( ( R44 * ) * )) by L1470 , L1453 , FUNCT_1:def 2;
reconsider D475 = D472 as non  empty ( R43 * ) -valued FinSequence by L1471;
reconsider D476 = D472 as non  empty ( R44 * ) -valued FinSequence by L1471;
L1472: (( { ( D475 . 1 ) } \ ( R43 * ) ) = ( {} ) & ( { ( D476 . 1 ) } \ ( R44 * ) ) = ( {} ));
reconsider D477 = ( D475 . 1 ) as (Element of ( R43 * )) by L1472 , ZFMISC_1:60;
reconsider D478 = ( D476 . 1 ) as (Element of ( R44 * )) by L1472 , ZFMISC_1:60;
L1473: ( D464 . R62 ) = ( ( D464 . D471 ) ^ D477 ) by L1458 , L1125
.= ( ( {} ) ^ D477 )
.= D477;
L1474: ( D465 . R62 ) = ( ( D465 . D469 ) ^ D478 ) by L1458 , L1125
.= ( ( {} ) ^ D477 )
.= D477;
thus L1475: ( D464 . R62 ) = ( D465 . R62 ) by L1474 , L1473;
end;
end;
L1470: (for R56 being Nat holds (S20[ R56 ] implies S20[ ( R56 + 1 ) ]))
proof
let R56 being Nat;
assume L1471: S20[ R56 ];
let R43 being non  empty set;
let R44 being non  empty set;
set D479 = ( R43 -multiCat );
set D480 = ( R44 -multiCat );
L1472: (( dom D479 ) = ( ( R43 * ) * ) & ( dom D480 ) = ( ( R44 * ) * )) by FUNCT_2:def 1;
let R62 being FinSequence;
assume L1473: R62 is ( ( R56 + 1 ) + 1 ) -element;
thus L1474: (R62 is ( ( {} ) * ) -valued implies ( D479 . R62 ) = ( {} ))
proof
L1475: ( ( {} ) /\ R43 ) = ( {} );
reconsider D481 = ( {} ) as (Subset of R43) by L1475;
reconsider D482 = ( D481 * ) as non  empty (Subset of ( R43 * ));
assume L1476: R62 is ( ( {} ) * ) -valued;
reconsider D483 = R62 as ( ( ( R56 + 1 ) + 1 ) + ( 0 ) ) -element ( ( {} ) * ) -valued FinSequence by L1476 , L1473;
reconsider D484 = ( D483 | ( Seg ( R56 + 1 ) ) ) as ( R56 + 1 ) -element D482 -valued FinSequence;
L1477: ( { ( D483 . ( ( R56 + 1 ) + 1 ) ) } \ ( ( {} ) * ) ) = ( {} );
reconsider D485 = ( D483 . ( ( R56 + 1 ) + 1 ) ) as (Element of D482) by L1477 , ZFMISC_1:60;
L1478: ( D483 \+\ ( D484 ^ <* D485 *> ) ) = ( {} );
L1479: (D483 = ( D484 ^ <* D485 *> ) & D484 is ( R43 * ) -valued) by L1478 , L995;
L1480: ( D479 . D483 ) = ( ( D479 . D484 ) ^ D485 ) by L1479 , L1125
.= ( ( D479 . D484 ) ^ ( {} ) )
.= ( {} ) by L1471;
thus L1481: thesis by L1480;
end;

thus L1482: ((( D479 . R62 ) = ( {} ) & R62 is ( R43 * ) -valued) implies R62 is { ( {} ) } -valued)
proof
assume L1483: (( D479 . R62 ) = ( {} ) & R62 is ( R43 * ) -valued);
reconsider D486 = R62 as ( ( ( R56 + 1 ) + 1 ) + ( 0 ) ) -element ( R43 * ) -valued FinSequence by L1483 , L1473;
reconsider D487 = ( D486 | ( Seg ( R56 + 1 ) ) ) as ( R56 + 1 ) -element ( R43 * ) -valued FinSequence;
L1484: ( { ( D486 . ( ( R56 + 1 ) + 1 ) ) } \ ( R43 * ) ) = ( {} );
reconsider D488 = ( D486 . ( ( R56 + 1 ) + 1 ) ) as (Element of ( R43 * )) by L1484 , ZFMISC_1:60;
L1485: ( D486 \+\ ( D487 ^ <* D488 *> ) ) = ( {} );
L1486: D486 = ( D487 ^ <* D488 *> ) by L1485 , L995;
L1487: ( ( D479 . D487 ) ^ D488 ) = ( {} ) by L1486 , L1125 , L1483;
L1488: (( D479 . D487 ) = ( {} ) & D488 = D463) by L1487;
L1489: (( D479 . D487 ) = ( {} ) & <* D488 *> = <* D463 *>) by L1488;
reconsider D489 = D487 , D490 = <* D488 *> as { ( {} ) } -valued FinSequence by L1489 , L1471;
L1490: ( D489 ^ D490 ) is { ( {} ) } -valued;
thus L1491: R62 is { ( {} ) } -valued by L1490 , L1485 , L995;
end;

assume L1492: (( D479 . R62 ) <> ( {} ) & ( D480 . R62 ) <> ( {} ));
L1493: R62 in ( ( R43 * ) * ) by L1492 , L1472 , FUNCT_1:def 2;
reconsider D491 = R62 as ( ( ( R56 + 1 ) + 1 ) + ( 0 ) ) -element ( R43 * ) -valued FinSequence by L1493 , L1473;
reconsider D492 = ( D491 | ( Seg ( R56 + 1 ) ) ) as ( R56 + 1 ) -element ( R43 * ) -valued FinSequence;
L1494: ( { ( D491 . ( ( R56 + 1 ) + 1 ) ) } \ ( R43 * ) ) = ( {} );
reconsider D493 = ( D491 . ( ( R56 + 1 ) + 1 ) ) as (Element of ( R43 * )) by L1494 , ZFMISC_1:60;
L1495: R62 in ( ( R44 * ) * ) by L1492 , L1472 , FUNCT_1:def 2;
reconsider D494 = R62 as ( ( ( R56 + 1 ) + 1 ) + ( 0 ) ) -element ( R44 * ) -valued FinSequence by L1495 , L1473;
reconsider D495 = ( D494 | ( Seg ( R56 + 1 ) ) ) as ( R56 + 1 ) -element ( R44 * ) -valued FinSequence;
L1496: ( { ( D494 . ( ( R56 + 1 ) + 1 ) ) } \ ( R44 * ) ) = ( {} );
reconsider D496 = ( D494 . ( ( R56 + 1 ) + 1 ) ) as (Element of ( R44 * )) by L1496 , ZFMISC_1:60;
L1497: (( D491 \+\ ( D492 ^ <* D493 *> ) ) = ( {} ) & ( D494 \+\ ( D495 ^ <* D496 *> ) ) = ( {} ));
L1498: (D491 = ( D492 ^ <* D493 *> ) & D494 = ( D495 ^ <* D496 *> )) by L1497 , L995;
L1499: (( D479 . D491 ) = ( ( D479 . D492 ) ^ D493 ) & ( D480 . D494 ) = ( ( D480 . D495 ) ^ D496 )) by L1498 , L1125;
assume L1500: ( D479 . R62 ) <> ( D480 . R62 );
L1501: (( D479 . D492 ) = ( {} ) or ( D480 . D495 ) = ( {} )) by L1500 , L1471 , L1499;
L1502: D492 is { ( {} ) } -valued by L1501 , L1471;
L1503: (( D479 . D492 ) = ( {} ) & ( D480 . D495 ) = ( {} )) by L1502 , L1471;
thus L1504: contradiction by L1503 , L1500 , L1499;
end;
L1505: (for R56 being Nat holds S20[ R56 ]) from NAT_1:sch 2(L1452 , L1470);
set D497 = ( R43 -multiCat );
set D498 = ( R44 -multiCat );
L1506: (( dom D497 ) = ( ( R43 * ) * ) & ( dom D498 ) = ( ( R44 * ) * )) by FUNCT_2:def 1;
thus L1507:now
assume L1508: (( D497 . R35 ) <> ( {} ) & ( D498 . R35 ) <> ( {} ));
L1509: (R35 in ( ( R43 * ) * ) & R35 <> ( {} )) by L1508 , L1506 , FUNCT_1:def 2;
reconsider D499 = R35 as non  empty FinSequence by L1509;
consider R55 being Nat such that L1510: ( len D499 ) = ( R55 + 1 ) by NAT_1:6;
reconsider D500 = D499 as ( R55 + 1 ) -element FinSequence by L1510 , CARD_1:def 7;
L1511: ((( D497 . D500 ) <> ( {} ) & ( D498 . D500 ) <> ( {} )) implies ( D497 . D500 ) = ( D498 . D500 )) by L1505;
thus L1512: ( D497 . R35 ) = ( D498 . R35 ) by L1511 , L1508;
end;
thus L1513:now
assume L1514: R62 is ( ( {} ) * ) -valued;
per cases ;
suppose L1515: R62 = ( {} );

thus L1516: ( D497 . R62 ) = ( {} ) by L1515;
end;
suppose L1517: (not R62 = ( {} ));

consider R55 being Nat such that L1518: ( R55 + 1 ) = ( len R62 ) by L1517 , NAT_1:6;
reconsider D501 = R62 as ( R55 + 1 ) -element FinSequence by L1518 , CARD_1:def 7;
L1519: ( D497 . D501 ) = ( {} ) by L1514 , L1505;
thus L1520: ( D497 . R62 ) = ( {} ) by L1519;
end;
end;
assume L1522: (( D497 . R62 ) = ( {} ) & R62 is ( R43 * ) -valued);
per cases ;
suppose L1523: R62 = ( {} );

thus L1524: R62 is ( ( {} ) * ) -valued by L1523;
end;
suppose L1525: (not R62 = ( {} ));

consider R55 being Nat such that L1526: ( R55 + 1 ) = ( len R62 ) by L1525 , NAT_1:6;
reconsider D502 = R62 as ( R55 + 1 ) -element FinSequence by L1526 , CARD_1:def 7;
L1527: D502 is ( ( {} ) * ) -valued by L1522 , L1505;
thus L1528: R62 is ( ( {} ) * ) -valued by L1527;
end;
end;
registration
let R42 being non  empty set;
let R35 being set;
cluster ( ( R42 -multiCat ) . R35 ) -> R42 -valued;
coherence
proof
L1530: ( ( R42 -multiCat ) . R35 ) in ( R42 * ) by L1240;
thus L1531: thesis by L1530;
end;
end;
definition
let R35 being set;
func R35 null equals 
R35;
coherence;
end;
registration
let C303 being  with_non-empty_elements set;
cluster non  empty -> non  empty-yielding for C303 -valued C303 -valued C303 -valued C303 -valued Relation;
coherence
proof
let C304 being C303 -valued Relation;
assume L1534: C304 is non  empty;
reconsider D503 = ( rng C304 ) as non  empty set by L1534;
set D504 = the (Element of D503);
L1535:
now
assume L1536: D503 c= { ( {} ) };
L1537: (D504 in { ( {} ) } & D504 in C303) by L1536 , TARSKI:def 3;
thus L1538: contradiction by L1537;
end;
thus L1539: thesis by L1535 , RELAT_1:def 15;
end;
end;
registration
let R32 being set;
cluster ( R32 \ { ( {} ) } ) ->  with_non-empty_elements;
coherence
proof
L1541: ( {} ) in { ( {} ) } by TARSKI:def 1;
L1542: (not ( {} ) in ( R32 \ { ( {} ) } )) by L1541 , XBOOLE_0:def 5;
thus L1543: thesis by L1542 , SETFAM_1:def 8;
end;
end;
registration
let C305 being  with_non-empty_elements set;
cluster  ->  with_non-empty_elements for (Subset of C305);
coherence
proof
let C306 being (Subset of C305);
L1545: (not ( {} ) in C306);
thus L1546: thesis by L1545 , SETFAM_1:def 8;
end;
end;
registration
let R42 being non  empty set;
cluster ( R42 * ) ->  infinite for set;
coherence
proof
L1548: ( omega ) c= ( card ( R42 * ) ) by CARD_4:14;
thus L1549: thesis by L1548;
end;
end;
registration
let R42 being non  empty set;
cluster ( R42 * ) ->  with_non-empty_element;
coherence;
end;
registration
let C307 being  with_non-empty_element set;
cluster  with_non-empty_elements non  empty for (Subset of C307);
existence
proof
take { the non  empty (Element of C307) };
thus L1552: thesis;
end;
end;
L1554: (for R33 being set holds (for R42 being non  empty set holds (for R62 being FinSequence holds ((R62 <> ( {} ) & R62 is R33 -valued & R33 c= ( R42 * ) & R33 is  with_non-empty_elements) implies ( ( R42 -multiCat ) . R62 ) <> ( {} )))))
proof
let R33 being set;
let R42 being non  empty set;
let R62 being FinSequence;
assume L1555: R62 <> ( {} );
reconsider D505 = R62 as non  empty FinSequence by L1555;
assume L1556: (R62 is R33 -valued & R33 c= ( R42 * ) & R33 is  with_non-empty_elements);
L1557: (( rng D505 ) c= R33 & R33 c= ( R42 * )) by L1556 , RELAT_1:def 19;
reconsider D506 = R33 as  with_non-empty_elements non  empty (Subset of ( R42 * )) by L1557 , L1556;
reconsider D507 = D505 as non  empty D506 -valued FinSequence by L1556;
L1558: (D507 is ( R42 * ) -valued & (not D507 is ( ( {} ) * ) -valued));
thus L1559: thesis by L1558 , L1451;
end;
theorem
L1560: (for R33 being set holds (for R43 being non  empty set holds (for R44 being non  empty set holds (for R62 being FinSequence holds ((R43 c= R44 & R33 c= ( R43 * ) & R62 is R33 -valued & R62 <> ( {} ) & R33 is  with_non-empty_elements) implies ( ( R43 -multiCat ) . R62 ) = ( ( R44 -multiCat ) . R62 ))))))
proof
let R33 being set;
let R43 being non  empty set;
let R44 being non  empty set;
let R62 being FinSequence;
assume L1561: R43 c= R44;
reconsider D508 = R43 as non  empty (Subset of R44) by L1561;
assume L1562: R33 c= ( R43 * );
reconsider D509 = R33 as (Subset of ( D508 * )) by L1562;
reconsider D510 = D509 as (Subset of ( R44 * )) by XBOOLE_1:1;
assume L1563: R62 is R33 -valued;
reconsider D511 = R62 as D509 -valued FinSequence by L1563;
reconsider D512 = D511 as D510 -valued FinSequence;
assume L1564: (R62 <> ( {} ) & R33 is  with_non-empty_elements);
L1565: (( ( R43 -multiCat ) . D511 ) <> ( {} ) & ( ( R44 -multiCat ) . D512 ) <> ( {} )) by L1564 , L1554;
thus L1566: thesis by L1565 , L1451;
end;
theorem
L1567: (for R32 being set holds (for R35 being set holds (for R42 being non  empty set holds ((ex R62 being FinSequence st (R35 = R62 & R62 is ( R32 * ) -valued)) implies ( ( R42 -multiCat ) . R35 ) is R32 -valued))))
proof
let R32 being set;
let R35 being set;
let R42 being non  empty set;
set D513 = ( R42 -multiCat );
L1568: ( dom D513 ) = ( ( R42 * ) * ) by FUNCT_2:def 1;
given R62 being FinSequence such that
L1569: (R35 = R62 & R62 is ( R32 * ) -valued);

L1570: R35 is (FinSequence of ( R32 * )) by L1569 , L8;
reconsider D514 = R35 as (Element of ( ( R32 * ) * )) by L1570 , FINSEQ_1:def 11;
per cases ;
suppose L1571: ( D513 . R62 ) <> ( {} );

L1572: (R62 in ( ( R42 * ) * ) & R62 <> ( {} )) by L1571 , L1568 , FUNCT_1:def 2;
reconsider D515 = R35 as non  empty (FinSequence of ( R42 * )) by L1572 , L8 , L1569;
L1573: (D515 is ( R32 * ) -valued & (not D515 is ( ( {} ) * ) -valued)) by L1451 , L1569 , L1571;
reconsider D516 = R32 as non  empty set by L1451 , L1569 , L1571;
set D517 = ( D516 -multiCat );
reconsider D518 = D514 as (Element of ( ( D516 * ) * ));
L1574: ( D517 . D515 ) <> ( {} ) by L1451 , L1573;
thus L1575: thesis by L1574 , L1451 , L1571 , L1569;
end;
suppose L1576: ( D513 . R62 ) = ( {} );

reconsider D519 = ( D513 . R62 ) as  empty set by L1576;
L1577: ( rng D519 ) c= R32 by XBOOLE_1:2;
thus L1578: thesis by L1577 , L1569 , RELAT_1:def 19;
end;
end;
registration
let R32 being set;
let R55 being Nat;
cluster ( ( R55 -tuples_on R32 ) \ ( R32 * ) ) ->  empty for set;
coherence
proof
reconsider D520 = R55 as (Element of ( NAT )) by ORDINAL1:def 12;
L1580: ( D520 -tuples_on R32 ) c= ( R32 * ) by FINSEQ_2:134;
thus L1581: thesis by L1580;
end;
end;
theorem
L1583: (for R29 being set holds (for R30 being set holds ( ( R29 /\ R30 ) * ) = ( ( R29 * ) /\ ( R30 * ) )))
proof
let R29 being set;
let R30 being set;
set D521 = ( R29 /\ R30 );
reconsider D522 = ( R29 /\ R30 ) as (Subset of R29);
reconsider D523 = ( R29 /\ R30 ) as (Subset of R30);
L1584: (( D522 * ) c= ( R29 * ) & ( D523 * ) c= ( R30 * ));
L1585: ( D521 * ) c= ( ( R29 * ) /\ ( R30 * ) ) by L1584 , XBOOLE_1:19;
L1586:
now
let R35 being set;
assume L1587: R35 in ( ( R29 * ) /\ ( R30 * ) );
reconsider D524 = R35 as R29 -valued FinSequence by L1587;
set D525 = ( len D524 );
set D526 = ( D525 -tuples_on R29 );
set D527 = ( D525 -tuples_on R30 );
set D528 = ( D525 -tuples_on D521 );
L1588: ( D528 \ ( D521 * ) ) = ( {} );
L1589: D528 c= ( D521 * ) by L1588 , XBOOLE_1:37;
reconsider D529 = R35 as R30 -valued FinSequence by L1587;
L1590: (D524 is D525 -element & D529 is D525 -element) by CARD_1:def 7;
L1591: (D524 in D526 & D529 in D527) by L1590 , L583;
L1592: D524 in ( D526 /\ D527 ) by L1591 , XBOOLE_0:def 4;
L1593: D524 in D528 by L1592 , L99;
thus L1594: R35 in ( D521 * ) by L1593 , L1589;
end;
L1595: ( ( R29 * ) /\ ( R30 * ) ) c= ( D521 * ) by L1586 , TARSKI:def 3;
thus L1596: thesis by L1595 , L1585 , XBOOLE_0:def 10;
end;
theorem
L1597: (for R32 being set holds (for R49 being Relation holds (for R50 being Relation holds ( ( R49 \/ R50 ) | R32 ) = ( ( R49 | R32 ) \/ ( R50 | R32 ) ))))
proof
let R32 being set;
let R49 being Relation;
let R50 being Relation;
set D530 = ( R49 | R32 );
set D531 = ( R50 | R32 );
set D532 = ( R49 \/ R50 );
set D533 = ( D532 | R32 );
set D534 = ( D530 \/ D531 );
L1598: (( ( R49 null R50 ) | R32 ) c= ( ( R49 \/ R50 ) | R32 ) & ( ( R50 null R49 ) | R32 ) c= ( ( R49 \/ R50 ) | R32 )) by RELAT_1:76;
L1599: D534 c= D533 by L1598 , XBOOLE_1:8;
L1600:
now
let R41 being set;
assume L1601: R41 in D533;
consider R35 being set, R38 being set such that L1602: R41 = [ R35 , R38 ] by L1601 , RELAT_1:def 1;
L1603: (R35 in R32 & [ R35 , R38 ] in ( R49 \/ R50 )) by L1601 , L1602 , RELAT_1:def 11;
L1604: ((R35 in R32 & [ R35 , R38 ] in R49) or (R35 in R32 & [ R35 , R38 ] in R50)) by L1603 , XBOOLE_0:def 3;
L1605: ([ R35 , R38 ] in ( R49 | R32 ) or [ R35 , R38 ] in ( R50 | R32 )) by L1604 , RELAT_1:def 11;
thus L1606: R41 in ( ( R49 | R32 ) \/ ( R50 | R32 ) ) by L1605 , L1602 , XBOOLE_0:def 3;
end;
L1607: D533 c= D534 by L1600 , TARSKI:def 3;
thus L1608: thesis by L1607 , L1599 , XBOOLE_0:def 10;
end;
registration
let R32 being set;
cluster ( ( bool R32 ) \ R32 ) -> non  empty for set;
coherence
proof
L1609: (not ( bool R32 ) c= R32) by CARD_1:25;
thus L1610: thesis by L1609 , XBOOLE_1:37;
end;
end;
registration
let R32 being set;
let C308 being Relation;
cluster ( C308 null R32 ) -> ( R32 \/ ( dom C308 ) ) -defined for Relation;
coherence
proof
L1612: ( ( dom C308 ) null R32 ) c= ( ( dom C308 ) \/ R32 );
thus L1613: thesis by L1612 , RELAT_1:def 18;
end;
end;
theorem
L1615: (for R32 being set holds (for R52 being Function holds (for R53 being Function holds ( ( R52 | R32 ) +* R53 ) = ( ( R52 | ( R32 \ ( dom R53 ) ) ) \/ R53 ))))
proof
let R32 being set;
let R52 being Function;
let R53 being Function;
set D535 = ( R52 | ( R32 \ ( dom R53 ) ) );
set D536 = R53;
L1616: (( dom D535 ) c= ( R32 \ ( dom D536 ) ) & ( R32 \ ( dom D536 ) ) misses ( dom D536 )) by XBOOLE_1:79;
L1617: D535 tolerates D536 by L1616 , PARTFUN1:56 , XBOOLE_1:63;
L1618: ( ( R52 | R32 ) +* D536 ) = ( ( R52 | ( ( R32 \ ( dom D536 ) ) \/ ( R32 /\ ( dom D536 ) ) ) ) +* D536 ) by L1434
.= ( ( D535 +* ( R52 | ( R32 /\ ( dom D536 ) ) ) ) +* D536 ) by FUNCT_4:78
.= ( D535 +* ( ( R52 | ( R32 /\ ( dom D536 ) ) ) +* ( ( D536 null ( {} ) ) null ( ( {} ) \/ ( dom D536 ) ) ) ) ) by FUNCT_4:14
.= ( D535 +* ( ( ( R52 | R32 ) | ( dom D536 ) ) +* ( D536 | ( dom D536 ) ) ) ) by RELAT_1:71
.= ( D535 +* ( ( ( R52 | R32 ) +* D536 ) | ( dom D536 ) ) ) by FUNCT_4:71
.= ( D535 +* D536 ) by FUNCT_4:23
.= ( D535 \/ D536 ) by L1617 , FUNCT_4:30;
thus L1619: thesis by L1618;
end;
registration
let R32 being set;
let C309 being R32 -defined Function;
let C310 being  total R32 -defined Function;
identify C309 +* C310 with C310 null C309;
compatibility
proof
L1620: (( dom C310 ) = R32 & ( dom C309 ) c= R32) by PARTFUN1:def 2;
thus L1621: thesis by L1620 , FUNCT_4:19;
end;
identify C310 null C309 with C309 +* C310;
compatibility;
end;
theorem
L1623: (for R29 being set holds (for R32 being set holds (for R38 being set holds ((not R38 in ( proj2 R32 )) implies [: R29 , { R38 } :] misses R32))))
proof
let R29 being set;
let R32 being set;
let R38 being set;
set D537 = ( proj2 R32 );
set D538 = [: R29 , { R38 } :];
set D539 = ( R32 /\ D538 );
assume L1624: (not R38 in D537);
assume L1625: D538 meets R32;
L1626: D539 <> ( {} ) by L1625 , XBOOLE_0:def 7;
consider R41 being set such that L1627: R41 in D539 by L1626 , XBOOLE_0:def 1;
set D540 = ( R41 `1 );
set D541 = ( R41 `2 );
L1628: (D540 in R29 & D541 in { R38 } & R41 = [ D540 , D541 ] & R41 in R32) by L1627 , MCART_1:10 , MCART_1:21;
L1629: (D541 = R38 & D541 in D537) by L1628 , TARSKI:def 1 , XTUPLE_0:def 13;
thus L1630: contradiction by L1629 , L1624;
end;
definition
let R32 being set;
func R32 -freeCountableSet equals 
[: ( NAT ) , { the (Element of ( ( bool ( proj2 R32 ) ) \ ( proj2 R32 ) )) } :];
coherence;
end;
theorem
L1632: (for R32 being set holds (( ( R32 -freeCountableSet ) /\ R32 ) = ( {} ) & ( R32 -freeCountableSet ) is  infinite))
proof
let R32 being set;
set D542 = ( proj2 R32 );
set D543 = ( ( bool D542 ) \ D542 );
set D544 = the (Element of D543);
set D545 = ( R32 -freeCountableSet );
L1633: (not D544 in D542) by XBOOLE_0:def 5;
L1634: D545 misses R32 by L1633 , L1623;
thus L1635: ( D545 /\ R32 ) = ( {} ) by L1634 , XBOOLE_0:def 7;
thus L1636: thesis;
end;
registration
let R32 being set;
cluster ( R32 -freeCountableSet ) ->  infinite for set;
coherence;
end;
registration
let R32 being set;
cluster ( ( R32 -freeCountableSet ) /\ R32 ) ->  empty;
coherence by L1632;
end;
registration
let R32 being set;
cluster ( R32 -freeCountableSet ) ->  countable for set;
coherence by CARD_4:7;
end;
registration
cluster ( ( NAT ) \ ( INT ) ) ->  empty;
coherence by NUMBERS:17;
end;
registration
let R35 being set;
let R62 being FinSequence;
cluster ( ( ( <* R35 *> ^ R62 ) . 1 ) \+\ R35 ) ->  empty for set;
coherence
proof
L1641: ( ( <* R35 *> ^ R62 ) . 1 ) = R35 by FINSEQ_1:41;
thus L1642: thesis by L1641;
end;
end;
registration
let R55 being Nat;
let C311 being  zero number;
let C312 being R55 -element FinSequence;
cluster ( C312 null C311 ) ->  total for ( Seg ( R55 + C311 ) ) -defined ( Seg ( R55 + C311 ) ) -defined ( Seg ( R55 + C311 ) ) -defined ( Seg ( R55 + C311 ) ) -defined Relation;
coherence
proof
let C313 being ( Seg ( R55 + C311 ) ) -defined Relation;
assume L1644: C313 = ( C312 null C311 );
L1645: ( dom C313 ) = ( Seg ( R55 + C311 ) ) by L1644 , FINSEQ_1:89;
thus L1646: thesis by L1645 , PARTFUN1:def 2;
end;
end;
registration
let R42 being non  empty set;
let R66 being R42 -valued FinSequence;
let R67 being R42 -valued FinSequence;
cluster ( ( ( R42 -multiCat ) . <* R66 , R67 *> ) \+\ ( R66 ^ R67 ) ) ->  empty for set;
coherence
proof
reconsider D546 = ( R42 -concatenation ) as (BinOp of ( R42 * ));
L1648: R66 is (FinSequence of R42) by L8;
reconsider D547 = R66 as (Element of ( R42 * )) by L1648 , FINSEQ_1:def 11;
set D548 = ( MultPlace D546 );
set D549 = <* D547 *>;
set D550 = ( R42 -multiCat );
L1649: ( D550 . <* R66 , R67 *> ) = ( ( D550 . D549 ) ^ R67 ) by L1125
.= ( ( D548 . D549 ) ^ R67 ) by L1118
.= ( R66 ^ R67 ) by L245;
thus L1650: thesis by L1649;
end;
end;
