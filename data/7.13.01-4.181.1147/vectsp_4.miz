:: Subspaces and Cosets of Subspaces in Vector Space
::  by Wojciech A. Trybulec
::
:: Received July 27, 1990
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies RLVECT_1, ALGSTR_0, BINOP_1, VECTSP_1, LATTICES, XBOOLE_0,
      SUBSET_1, ARYTM_1, RELAT_1, ARYTM_3, RLSUB_1, SUPINF_2, GROUP_1,
      STRUCT_0, TARSKI, REALSET1, ZFMISC_1, FUNCT_1, MESFUNC1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, REALSET1, FUNCT_1,
      FUNCT_2, STRUCT_0, ALGSTR_0, DOMAIN_1, BINOP_1, RLVECT_1, GROUP_1,
      VECTSP_1;
 constructors PARTFUN1, BINOP_1, REALSET1, VECTSP_1, RLVECT_1, RELSET_1;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, REALSET1, STRUCT_0, VECTSP_1,
      RELAT_1, ALGSTR_0;
 requirements SUBSET, BOOLE;
 definitions TARSKI, RLVECT_1, XBOOLE_0, BINOP_1, REALSET1, STRUCT_0, ALGSTR_0,
      VECTSP_1;
 theorems FUNCT_1, FUNCT_2, TARSKI, VECTSP_1, ZFMISC_1, RLVECT_1, RELAT_1,
      VECTSP_2, RELSET_1, XBOOLE_0, XBOOLE_1, STRUCT_0, ALGSTR_0;
 schemes XBOOLE_0;

begin
L1: (for B1 being  add-associative  right_zeroed  right_complementable  Abelian  commutative  associative  well-unital  distributive non  empty doubleLoopStr holds (for B2 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B1 holds (for B3 , B4 being (Element of B1) holds (for B5 being (Element of B2) holds ( ( B3 - B4 ) * B5 ) = ( ( B3 * B5 ) - ( B4 * B5 ) )))))
proof
let C1 being  add-associative  right_zeroed  right_complementable  Abelian  commutative  associative  well-unital  distributive non  empty doubleLoopStr;
let C2 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C1;
let C3 , C4 being (Element of C1);
let C5 being (Element of C2);
thus L2: ( ( C3 - C4 ) * C5 ) = ( ( C3 * C5 ) + ( ( - C4 ) * C5 ) ) by VECTSP_1:def 15
.= ( ( C3 * C5 ) - ( C4 * C5 ) ) by VECTSP_1:21;
end;
definition
let C6 being non  empty multMagma;
let C7 being non  empty VectSpStr over C6;
let C8 being (Subset of C7);
attr C8 is  linearly-closed
means
:L3: ((for B6 , B7 being (Element of C7) holds ((B6 in C8 & B7 in C8) implies ( B6 + B7 ) in C8)) & (for B8 being (Element of C6) holds (for B9 being (Element of C7) holds (B9 in C8 implies ( B8 * B9 ) in C8))));
end;
theorem
L5: (for B10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B10 holds (for B12 being (Subset of B11) holds ((B12 <> ( {} ) & B12 is  linearly-closed) implies ( 0. B11 ) in B12))))
proof
let C9 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C10 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C9;
let C11 being (Subset of C10);
assume that
L6: C11 <> ( {} )
and
L7: C11 is  linearly-closed;
set D1 = the (Element of C11);
reconsider D2 = D1 as (Element of C10) by L6 , TARSKI:def 3;
L8: ( ( 0. C9 ) * D2 ) in C11 by L6 , L7 , L3;
thus L9: thesis by L8 , VECTSP_1:14;
end;
theorem
L10: (for B13 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B14 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B13 holds (for B15 being (Subset of B14) holds (B15 is  linearly-closed implies (for B16 being (Element of B14) holds (B16 in B15 implies ( - B16 ) in B15))))))
proof
let C12 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C13 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C12;
let C14 being (Subset of C13);
assume L11: C14 is  linearly-closed;
let C15 being (Element of C13);
assume L12: C15 in C14;
L13: ( ( - ( 1_ C12 ) ) * C15 ) in C14 by L12 , L11 , L3;
thus L14: thesis by L13 , VECTSP_1:14;
end;
theorem
L15: (for B17 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B18 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B17 holds (for B19 being (Subset of B18) holds (B19 is  linearly-closed implies (for B20 , B21 being (Element of B18) holds ((B20 in B19 & B21 in B19) implies ( B20 - B21 ) in B19))))))
proof
let C16 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C17 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C16;
let C18 being (Subset of C17);
assume L16: C18 is  linearly-closed;
let C19 , C20 being (Element of C17);
assume that
L17: C19 in C18
and
L18: C20 in C18;
L19: ( - C20 ) in C18 by L16 , L18 , L10;
thus L20: thesis by L19 , L16 , L17 , L3;
end;
theorem
L21: (for B22 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B23 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B22 holds { ( 0. B23 ) } is  linearly-closed))
proof
let C21 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C22 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C21;
thus L22: (for B24 , B25 being (Element of C22) holds ((B24 in { ( 0. C22 ) } & B25 in { ( 0. C22 ) }) implies ( B24 + B25 ) in { ( 0. C22 ) }))
proof
let C23 , C24 being (Element of C22);
assume L23: (C23 in { ( 0. C22 ) } & C24 in { ( 0. C22 ) });
L24: (C23 = ( 0. C22 ) & C24 = ( 0. C22 )) by L23 , TARSKI:def 1;
L25: ( C23 + C24 ) = ( 0. C22 ) by L24 , RLVECT_1:4;
thus L26: thesis by L25 , TARSKI:def 1;
end;

let C25 being (Element of C21);
let C26 being (Element of C22);
assume L27: C26 in { ( 0. C22 ) };
L28: C26 = ( 0. C22 ) by L27 , TARSKI:def 1;
thus L29: thesis by L28 , L27 , VECTSP_1:14;
end;
theorem
L30: (for B26 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B27 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B26 holds (for B28 being (Subset of B27) holds ((the carrier of B27) = B28 implies B28 is  linearly-closed))))
proof
let C27 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C28 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C27;
let C29 being (Subset of C28);
assume L31: (the carrier of C28) = C29;
thus L32: (for B29 , B30 being (Element of C28) holds ((B29 in C29 & B30 in C29) implies ( B29 + B30 ) in C29)) by L31;
let C30 being (Element of C27);
let C31 being (Element of C28);
assume L33: C31 in C29;
thus L34: thesis by L31;
end;
theorem
L35: (for B31 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B32 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B31 holds (for B33 , B34 , B35 being (Subset of B32) holds ((B33 is  linearly-closed & B34 is  linearly-closed & B35 = { ( B36 + B37 ) where B36 is (Element of B32) , B37 is (Element of B32) : (B36 in B33 & B37 in B34) }) implies B35 is  linearly-closed))))
proof
let C32 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C33 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C32;
let C34 , C35 , C36 being (Subset of C33);
assume that
L36: (C34 is  linearly-closed & C35 is  linearly-closed)
and
L37: C36 = { ( B38 + B39 ) where B38 is (Element of C33) , B39 is (Element of C33) : (B38 in C34 & B39 in C35) };
thus L38: (for B40 , B41 being (Element of C33) holds ((B40 in C36 & B41 in C36) implies ( B40 + B41 ) in C36))
proof
let C37 , C38 being (Element of C33);
assume that
L39: C37 in C36
and
L40: C38 in C36;
consider C39 , C40 being (Element of C33) such that L41: C37 = ( C39 + C40 ) and L42: (C39 in C34 & C40 in C35) by L37 , L39;
consider C41 , C42 being (Element of C33) such that L43: C38 = ( C41 + C42 ) and L44: (C41 in C34 & C42 in C35) by L37 , L40;
L45: ( C37 + C38 ) = ( ( ( C39 + C40 ) + C41 ) + C42 ) by L41 , L43 , RLVECT_1:def 3
.= ( ( ( C39 + C41 ) + C40 ) + C42 ) by RLVECT_1:def 3
.= ( ( C39 + C41 ) + ( C40 + C42 ) ) by RLVECT_1:def 3;
L46: (( C39 + C41 ) in C34 & ( C40 + C42 ) in C35) by L36 , L42 , L44 , L3;
thus L47: thesis by L46 , L37 , L45;
end;

let C43 being (Element of C32);
let C44 being (Element of C33);
assume L48: C44 in C36;
consider C45 , C46 being (Element of C33) such that L49: C44 = ( C45 + C46 ) and L50: (C45 in C34 & C46 in C35) by L48 , L37;
L51: ( C43 * C44 ) = ( ( C43 * C45 ) + ( C43 * C46 ) ) by L49 , VECTSP_1:def 14;
L52: (( C43 * C45 ) in C34 & ( C43 * C46 ) in C35) by L36 , L50 , L3;
thus L53: thesis by L52 , L37 , L51;
end;
theorem
L54: (for B42 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B43 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B42 holds (for B44 , B45 being (Subset of B43) holds ((B44 is  linearly-closed & B45 is  linearly-closed) implies ( B44 /\ B45 ) is  linearly-closed))))
proof
let C47 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C48 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C47;
let C49 , C50 being (Subset of C48);
assume that
L55: C49 is  linearly-closed
and
L56: C50 is  linearly-closed;
thus L57: (for B46 , B47 being (Element of C48) holds ((B46 in ( C49 /\ C50 ) & B47 in ( C49 /\ C50 )) implies ( B46 + B47 ) in ( C49 /\ C50 )))
proof
let C51 , C52 being (Element of C48);
assume L58: (C51 in ( C49 /\ C50 ) & C52 in ( C49 /\ C50 ));
L59: (C51 in C50 & C52 in C50) by L58 , XBOOLE_0:def 4;
L60: ( C51 + C52 ) in C50 by L59 , L56 , L3;
L61: (C51 in C49 & C52 in C49) by L58 , XBOOLE_0:def 4;
L62: ( C51 + C52 ) in C49 by L61 , L55 , L3;
thus L63: thesis by L62 , L60 , XBOOLE_0:def 4;
end;

let C53 being (Element of C47);
let C54 being (Element of C48);
assume L64: C54 in ( C49 /\ C50 );
L65: C54 in C50 by L64 , XBOOLE_0:def 4;
L66: ( C53 * C54 ) in C50 by L65 , L56 , L3;
L67: C54 in C49 by L64 , XBOOLE_0:def 4;
L68: ( C53 * C54 ) in C49 by L67 , L55 , L3;
thus L69: thesis by L68 , L66 , XBOOLE_0:def 4;
end;
definition
let C55 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C56 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C55;
mode Subspace of C56
 ->  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C55
means :L70: ((the carrier of it) c= (the carrier of C56) & ( 0. it ) = ( 0. C56 ) & (the addF of it) = ( (the addF of C56) || (the carrier of it) ) & (the lmult of it) = ( (the lmult of C56) | ([: (the carrier of C55) , (the carrier of it) :] qua set) ));
existence
proof
take C56;
thus L71: ((the carrier of C56) c= (the carrier of C56) & ( 0. C56 ) = ( 0. C56 ));
thus L72: thesis by RELSET_1:19;
end;
end;
theorem
L74: (for R1 being set holds (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R17 being (Subspace of R6) holds (for R18 being (Subspace of R6) holds ((R1 in R17 & R17 is (Subspace of R18)) implies R1 in R18))))))
proof
let R1 being set;
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R17 being (Subspace of R6);
let R18 being (Subspace of R6);
assume L75: (R1 in R17 & R17 is (Subspace of R18));
L76: (R1 in (the carrier of R17) & (the carrier of R17) c= (the carrier of R18)) by L75 , L70 , STRUCT_0:def 5;
thus L77: thesis by L76 , STRUCT_0:def 5;
end;
theorem
L78: (for R1 being set holds (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R16 being (Subspace of R6) holds (R1 in R16 implies R1 in R6)))))
proof
let R1 being set;
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R16 being (Subspace of R6);
assume L79: R1 in R16;
L80: R1 in (the carrier of R16) by L79 , STRUCT_0:def 5;
L81: (the carrier of R16) c= (the carrier of R6) by L70;
thus L82: thesis by L81 , L80 , STRUCT_0:def 5;
end;
theorem
L83: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R16 being (Subspace of R6) holds (for R20 being (Element of R16) holds R20 is (Element of R6)))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R16 being (Subspace of R6);
let R20 being (Element of R16);
L84: R20 in R6 by L78 , RLVECT_1:1;
thus L85: thesis by L84 , STRUCT_0:def 5;
end;
theorem
L86: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R16 being (Subspace of R6) holds ( 0. R16 ) = ( 0. R6 )))) by L70;
theorem
L87: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R17 being (Subspace of R6) holds (for R18 being (Subspace of R6) holds ( 0. R17 ) = ( 0. R18 )))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R17 being (Subspace of R6);
let R18 being (Subspace of R6);
thus L88: ( 0. R17 ) = ( 0. R6 ) by L70
.= ( 0. R18 ) by L70;
end;
theorem
L89: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (for R21 being (Element of R16) holds (for R22 being (Element of R16) holds ((R21 = R13 & R22 = R10) implies ( R21 + R22 ) = ( R13 + R10 )))))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
let R21 being (Element of R16);
let R22 being (Element of R16);
assume L90: (R13 = R21 & R10 = R22);
L91: ( R21 + R22 ) = ( ( (the addF of R6) || (the carrier of R16) ) . [ R21 , R22 ] ) by L70;
thus L92: thesis by L91 , L90 , FUNCT_1:49;
end;
theorem
L93: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R9 being (Element of R5) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (for R20 being (Element of R16) holds (R20 = R13 implies ( R9 * R20 ) = ( R9 * R13 ))))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R9 being (Element of R5);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
let R20 being (Element of R16);
assume L94: R20 = R13;
L95: ( R9 * R20 ) = ( ( (the lmult of R6) | ([: (the carrier of R5) , (the carrier of R16) :] qua set) ) . [ R9 , R20 ] ) by L70;
thus L96: thesis by L95 , L94 , FUNCT_1:49;
end;
theorem
L97: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (for R20 being (Element of R16) holds (R20 = R13 implies ( - R13 ) = ( - R20 )))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R13 being (Element of R6);
let R16 being (Subspace of R6);
let R20 being (Element of R16);
L98: (( - R13 ) = ( ( - ( 1_ R5 ) ) * R13 ) & ( - R20 ) = ( ( - ( 1_ R5 ) ) * R20 )) by VECTSP_1:14;
assume L99: R20 = R13;
thus L100: thesis by L99 , L98 , L93;
end;
theorem
L101: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (for R21 being (Element of R16) holds (for R22 being (Element of R16) holds ((R21 = R13 & R22 = R10) implies ( R21 - R22 ) = ( R13 - R10 )))))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
let R21 being (Element of R16);
let R22 being (Element of R16);
assume that
L102: R21 = R13
and
L103: R22 = R10;
L104: ( - R22 ) = ( - R10 ) by L103 , L97;
thus L105: thesis by L104 , L102 , L89;
end;
L106: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R16 being (Subspace of R6) holds (for R19 being (Subset of R6) holds ((the carrier of R16) = R19 implies R19 is  linearly-closed)))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R16 being (Subspace of R6);
let R19 being (Subset of R6);
set D3 = (the carrier of R16);
reconsider D4 = R16 as  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
assume L107: (the carrier of R16) = R19;
thus L108: (for R13 being (Element of R6) holds (for R10 being (Element of R6) holds ((R13 in R19 & R10 in R19) implies ( R13 + R10 ) in R19)))
proof
let R13 being (Element of R6);
let R10 being (Element of R6);
assume L109: (R13 in R19 & R10 in R19);
reconsider D5 = R13 , D6 = R10 as (Element of D4) by L109 , L107;
reconsider D7 = ( D5 + D6 ) as (Element of D3);
L110: D7 in R19 by L107;
thus L111: thesis by L110 , L89;
end;

let R9 being (Element of R5);
let R13 being (Element of R6);
assume L112: R13 in R19;
reconsider D8 = R13 as (Element of D4) by L112 , L107;
reconsider D9 = ( R9 * D8 ) as (Element of D3);
L113: D9 in R19 by L107;
thus L114: thesis by L113 , L93;
end;
theorem
L115: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R16 being (Subspace of R6) holds ( 0. R6 ) in R16)))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R16 being (Subspace of R6);
L116: ( 0. R16 ) in R16 by RLVECT_1:1;
thus L117: thesis by L116 , L70;
end;
theorem
L118: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R17 being (Subspace of R6) holds (for R18 being (Subspace of R6) holds ( 0. R17 ) in R18))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R17 being (Subspace of R6);
let R18 being (Subspace of R6);
L119: ( 0. R17 ) = ( 0. R6 ) by L70;
thus L120: thesis by L119 , L115;
end;
theorem
L121: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R16 being (Subspace of R6) holds ( 0. R16 ) in R6))) by L78 , RLVECT_1:1;
theorem
L122: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds ((R10 in R16 & R13 in R16) implies ( R10 + R13 ) in R16))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
reconsider D10 = (the carrier of R16) as (Subset of R6) by L70;
assume L123: (R10 in R16 & R13 in R16);
L124: (R10 in (the carrier of R16) & R13 in (the carrier of R16)) by L123 , STRUCT_0:def 5;
L125: D10 is  linearly-closed by L106;
L126: ( R10 + R13 ) in (the carrier of R16) by L125 , L124 , L3;
thus L127: thesis by L126 , STRUCT_0:def 5;
end;
theorem
L128: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R9 being (Element of R5) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (R13 in R16 implies ( R9 * R13 ) in R16))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R9 being (Element of R5);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
reconsider D11 = (the carrier of R16) as (Subset of R6) by L70;
assume L129: R13 in R16;
L130: R13 in (the carrier of R16) by L129 , STRUCT_0:def 5;
L131: D11 is  linearly-closed by L106;
L132: ( R9 * R13 ) in (the carrier of R16) by L131 , L130 , L3;
thus L133: thesis by L132 , STRUCT_0:def 5;
end;
theorem
L134: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (R13 in R16 implies ( - R13 ) in R16)))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R13 being (Element of R6);
let R16 being (Subspace of R6);
assume L135: R13 in R16;
L136: ( ( - ( 1_ R5 ) ) * R13 ) in R16 by L135 , L128;
thus L137: thesis by L136 , VECTSP_1:14;
end;
theorem
L138: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds ((R10 in R16 & R13 in R16) implies ( R10 - R13 ) in R16))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
assume that
L139: R10 in R16
and
L140: R13 in R16;
L141: ( - R13 ) in R16 by L140 , L134;
thus L142: thesis by L141 , L139 , L122;
end;
theorem
L143: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds R6 is (Subspace of R6)))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
L144: (the lmult of R6) = ( (the lmult of R6) | ([: (the carrier of R5) , (the carrier of R6) :] qua set) ) by RELSET_1:19;
L145: (( 0. R6 ) = ( 0. R6 ) & (the addF of R6) = ( (the addF of R6) || (the carrier of R6) )) by RELSET_1:19;
thus L146: thesis by L145 , L144 , L70;
end;
theorem
L147: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B48 , B49 being  strict  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds ((B49 is (Subspace of B48) & B48 is (Subspace of B49)) implies B49 = B48)))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C57 , C58 being  strict  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
assume that
L148: C58 is (Subspace of C57)
and
L149: C57 is (Subspace of C58);
set D12 = (the carrier of C57);
set D13 = (the carrier of C58);
L150: (D13 c= D12 & D12 c= D13) by L148 , L149 , L70;
L151: D13 = D12 by L150 , XBOOLE_0:def 10;
set D14 = (the addF of C57);
set D15 = (the addF of C58);
L152: (D15 = ( D14 || D13 ) & D14 = ( D15 || D12 )) by L148 , L149 , L70;
L153: D15 = D14 by L152 , L151 , RELAT_1:72;
set D16 = (the lmult of C57);
set D17 = (the lmult of C58);
L154: D16 = ( D17 | ([: (the carrier of R5) , D12 :] qua set) ) by L149 , L70;
L155: (( 0. C58 ) = ( 0. C57 ) & D17 = ( D16 | ([: (the carrier of R5) , D13 :] qua set) )) by L148 , L70;
thus L156: thesis by L155 , L151 , L153 , L154 , RELAT_1:72;
end;
theorem
L157: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R7 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R8 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds ((R6 is (Subspace of R7) & R7 is (Subspace of R8)) implies R6 is (Subspace of R8))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R7 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R8 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
assume that
L158: R6 is (Subspace of R7)
and
L159: R7 is (Subspace of R8);
L160: ((the carrier of R6) c= (the carrier of R7) & (the carrier of R7) c= (the carrier of R8)) by L158 , L159 , L70;
L161: (the carrier of R6) c= (the carrier of R8) by L160 , XBOOLE_1:1;
L162: (the addF of R6) = ( (the addF of R8) || (the carrier of R6) )
proof
set D18 = (the addF of R8);
set D19 = (the carrier of R7);
set D20 = (the addF of R7);
set D21 = (the carrier of R6);
set D22 = (the addF of R6);
L163: D21 c= D19 by L158 , L70;
L164: [: D21 , D21 :] c= [: D19 , D19 :] by L163 , ZFMISC_1:96;
L165: D22 = ( D20 || D21 ) by L158 , L70;
L166: D22 = ( ( D18 || D19 ) || D21 ) by L165 , L159 , L70;
thus L167: thesis by L166 , L164 , FUNCT_1:51;
end;
set D23 = (the lmult of R8);
set D24 = (the lmult of R7);
set D25 = (the lmult of R6);
set D26 = (the carrier of R7);
set D27 = (the carrier of R6);
L168: D27 c= D26 by L158 , L70;
L169: [: (the carrier of R5) , D27 :] c= [: (the carrier of R5) , (the carrier of R7) :] by L168 , ZFMISC_1:95;
L170: D25 = ( D24 | ([: (the carrier of R5) , D27 :] qua set) ) by L158 , L70;
L171: D25 = ( ( D23 | ([: (the carrier of R5) , D26 :] qua set) ) | ([: (the carrier of R5) , D27 :] qua set) ) by L170 , L159 , L70;
L172: D25 = ( D23 | ([: (the carrier of R5) , D27 :] qua set) ) by L171 , L169 , FUNCT_1:51;
L173: ( 0. R6 ) = ( 0. R7 ) by L158 , L70;
L174: ( 0. R6 ) = ( 0. R8 ) by L173 , L159 , L70;
thus L175: thesis by L174 , L161 , L162 , L172 , L70;
end;
theorem
L176: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R17 being (Subspace of R6) holds (for R18 being (Subspace of R6) holds ((the carrier of R17) c= (the carrier of R18) implies R17 is (Subspace of R18))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R17 being (Subspace of R6);
let R18 being (Subspace of R6);
set D28 = (the carrier of R17);
set D29 = (the carrier of R18);
set D30 = (the lmult of R17);
set D31 = (the lmult of R18);
set D32 = (the addF of R6);
set D33 = (the lmult of R6);
L177: ((the addF of R17) = ( D32 || D28 ) & (the addF of R18) = ( D32 || D29 )) by L70;
assume L178: (the carrier of R17) c= (the carrier of R18);
L179: [: D28 , D28 :] c= [: D29 , D29 :] by L178 , ZFMISC_1:96;
L180: (the addF of R17) = ( (the addF of R18) || (the carrier of R17) ) by L179 , L177 , FUNCT_1:51;
L181: (D30 = ( D33 | ([: (the carrier of R5) , D28 :] qua set) ) & D31 = ( D33 | ([: (the carrier of R5) , D29 :] qua set) )) by L70;
L182: [: (the carrier of R5) , D28 :] c= [: (the carrier of R5) , D29 :] by L178 , ZFMISC_1:95;
L183: D30 = ( D31 | ([: (the carrier of R5) , D28 :] qua set) ) by L182 , L181 , FUNCT_1:51;
L184: (( 0. R17 ) = ( 0. R6 ) & ( 0. R18 ) = ( 0. R6 )) by L70;
thus L185: thesis by L184 , L178 , L180 , L183 , L70;
end;
theorem
L186: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R17 being (Subspace of R6) holds (for R18 being (Subspace of R6) holds ((for R13 being (Element of R6) holds (R13 in R17 implies R13 in R18)) implies R17 is (Subspace of R18))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R17 being (Subspace of R6);
let R18 being (Subspace of R6);
assume L187: (for R13 being (Element of R6) holds (R13 in R17 implies R13 in R18));
L188: (the carrier of R17) c= (the carrier of R18)
proof
let C59 being set;
assume L189: C59 in (the carrier of R17);
L190: (the carrier of R17) c= (the carrier of R6) by L70;
reconsider D34 = C59 as (Element of R6) by L190 , L189;
L191: D34 in R17 by L189 , STRUCT_0:def 5;
L192: D34 in R18 by L191 , L187;
thus L193: thesis by L192 , STRUCT_0:def 5;
end;
thus L194: thesis by L188 , L176;
end;
registration
let C60 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C61 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C60;
cluster  strict for (Subspace of C61);
existence
proof
set D35 = (the lmult of C61);
set D36 = VectSpStr (# (the carrier of C61) , (the addF of C61) , ( 0. C61 ) , D35 #);
L195: D36 is  vector-distributive
proof
let C62 being (Element of C60);
let C63 , C64 being (Element of D36);
reconsider D37 = C63 , D38 = C64 as (Element of C61);
thus L196: ( C62 * ( C63 + C64 ) ) = ( C62 * ( D37 + D38 ) )
.= ( ( C62 * D37 ) + ( C62 * D38 ) ) by VECTSP_1:def 14
.= ( ( C62 * C63 ) + ( C62 * C64 ) );
end;
L197: D36 is  scalar-distributive
proof
let C65 , C66 being (Element of C60);
let C67 being (Element of D36);
reconsider D39 = C67 as (Element of C61);
thus L198: ( ( C65 + C66 ) * C67 ) = ( ( C65 + C66 ) * D39 )
.= ( ( C65 * D39 ) + ( C66 * D39 ) ) by VECTSP_1:def 15
.= ( ( C65 * C67 ) + ( C66 * C67 ) );
end;
L199: D36 is  scalar-associative
proof
let C68 , C69 being (Element of C60);
let C70 being (Element of D36);
reconsider D40 = C70 as (Element of C61);
thus L200: ( ( C68 * C69 ) * C70 ) = ( ( C68 * C69 ) * D40 )
.= ( C68 * ( C69 * D40 ) ) by VECTSP_1:def 16
.= ( C68 * ( C69 * C70 ) );
end;
L201: D36 is  scalar-unital
proof
let C71 being (Element of D36);
reconsider D41 = C71 as (Element of C61);
thus L202: ( ( 1. C60 ) * C71 ) = ( ( 1_ C60 ) * D41 )
.= C71 by VECTSP_1:def 17;
end;
L203: (for B50 , B51 being (Element of D36) holds (for B52 , B53 being (Element of C61) holds ((B52 = B50 & B51 = B53) implies ( B50 + B51 ) = ( B52 + B53 ))));
L204: D36 is  Abelian  add-associative  right_zeroed  right_complementable
proof
thus L205: D36 is  Abelian
proof
let C72 , C73 being (Element of D36);
reconsider D42 = C72 , D43 = C73 as (Element of C61);
thus L206: ( C72 + C73 ) = ( D43 + D42 ) by L203
.= ( C73 + C72 );
end;

thus L207:now
let C74 , C75 , C76 being (Element of D36);
reconsider D44 = C74 , D45 = C75 , D46 = C76 as (Element of C61);
thus L208: ( ( C74 + C75 ) + C76 ) = ( ( D44 + D45 ) + D46 )
.= ( D44 + ( D45 + D46 ) ) by RLVECT_1:def 3
.= ( C74 + ( C75 + C76 ) );
end;
thus L209:now
let C77 being (Element of D36);
reconsider D47 = C77 as (Element of C61);
thus L210: ( C77 + ( 0. D36 ) ) = ( D47 + ( 0. C61 ) )
.= C77 by RLVECT_1:4;
end;
let C78 being (Element of D36);
reconsider D48 = C78 as (Element of C61);
reconsider D49 = ( ( comp C61 ) . D48 ) as (Element of D36);
take D49;
thus L211: ( C78 + D49 ) = ( D48 + ( - D48 ) ) by VECTSP_1:def 13
.= ( 0. D36 ) by RLVECT_1:5;
end;
reconsider D50 = D36 as  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C60 by L204 , L195 , L197 , L199 , L201;
L212: (( 0. D50 ) = ( 0. C61 ) & (the addF of D50) = ( (the addF of C61) || (the carrier of D50) )) by RELSET_1:19;
L213: (the lmult of D50) = ( (the lmult of C61) | ([: (the carrier of C60) , (the carrier of D50) :] qua set) ) by RELSET_1:19;
reconsider D51 = D50 as (Subspace of C61) by L213 , L212 , L70;
take D51;
thus L214: thesis;
end;
end;
theorem
L216: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for B54 , B55 being  strict (Subspace of R6) holds ((the carrier of B54) = (the carrier of B55) implies B54 = B55))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let C79 , C80 being  strict (Subspace of R6);
assume L217: (the carrier of C79) = (the carrier of C80);
L218: (C79 is (Subspace of C80) & C80 is (Subspace of C79)) by L217 , L176;
thus L219: thesis by L218 , L147;
end;
theorem
L220: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for B56 , B57 being  strict (Subspace of R6) holds ((for R13 being (Element of R6) holds (R13 in B56 iff R13 in B57)) implies B56 = B57))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let C81 , C82 being  strict (Subspace of R6);
assume L221: (for R13 being (Element of R6) holds (R13 in C81 iff R13 in C82));
L222: (for R1 being set holds (R1 in (the carrier of C81) iff R1 in (the carrier of C82)))
proof
let R1 being set;
thus L223: (R1 in (the carrier of C81) implies R1 in (the carrier of C82))
proof
assume L224: R1 in (the carrier of C81);
L225: (the carrier of C81) c= (the carrier of R6) by L70;
reconsider D52 = R1 as (Element of R6) by L225 , L224;
L226: D52 in C81 by L224 , STRUCT_0:def 5;
L227: D52 in C82 by L226 , L221;
thus L228: thesis by L227 , STRUCT_0:def 5;
end;

assume L229: R1 in (the carrier of C82);
L230: (the carrier of C82) c= (the carrier of R6) by L70;
reconsider D53 = R1 as (Element of R6) by L230 , L229;
L231: D53 in C82 by L229 , STRUCT_0:def 5;
L232: D53 in C81 by L231 , L221;
thus L233: thesis by L232 , STRUCT_0:def 5;
end;
L234: (the carrier of C81) = (the carrier of C82) by L222 , TARSKI:1;
thus L235: thesis by L234 , L216;
end;
theorem
L236: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B58 being  strict  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for B59 being  strict (Subspace of B58) holds ((the carrier of B59) = (the carrier of B58) implies B59 = B58))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C83 being  strict  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let C84 being  strict (Subspace of C83);
assume L237: (the carrier of C84) = (the carrier of C83);
L238: C83 is (Subspace of C83) by L143;
thus L239: thesis by L238 , L237 , L216;
end;
theorem
L240: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B60 being  strict  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for B61 being  strict (Subspace of B60) holds ((for B62 being (Element of B60) holds B62 in B61) implies B61 = B60))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C85 being  strict  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let C86 being  strict (Subspace of C85);
assume L241: (for B63 being (Element of C85) holds B63 in C86);
L242: (for B64 being (Element of C85) holds (B64 in C86 iff B64 in C85)) by L241 , RLVECT_1:1;
L243: C85 is (Subspace of C85) by L143;
thus L244: thesis by L243 , L242 , L220;
end;
theorem
L245: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R16 being (Subspace of R6) holds (for R19 being (Subset of R6) holds ((the carrier of R16) = R19 implies R19 is  linearly-closed))))) by L106;
theorem
L246: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R19 being (Subset of R6) holds ((R19 <> ( {} ) & R19 is  linearly-closed) implies (ex B65 being  strict (Subspace of R6) st R19 = (the carrier of B65))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R19 being (Subset of R6);
assume that
L247: R19 <> ( {} )
and
L248: R19 is  linearly-closed;
reconsider D54 = R19 as non  empty set by L247;
reconsider D55 = ( 0. R6 ) as (Element of D54) by L248 , L5;
set D56 = (the carrier of R6);
set D57 = ( ( comp R6 ) | D54 );
L249: ( dom ( comp R6 ) ) = D56 by FUNCT_2:def 1;
L250: ( dom D57 ) = D54 by L249 , RELAT_1:62;
L251: ( rng D57 ) c= D54
proof
let R1 being set;
assume L252: R1 in ( rng D57 );
consider R2 being set such that L253: R2 in ( dom D57 ) and L254: ( D57 . R2 ) = R1 by L252 , FUNCT_1:def 3;
reconsider D58 = R2 as (Element of R6) by L250 , L253;
L255: R1 = ( ( comp R6 ) . D58 ) by L253 , L254 , FUNCT_1:47
.= ( - D58 ) by VECTSP_1:def 13;
thus L256: thesis by L255 , L248 , L250 , L253 , L10;
end;
set D59 = ( (the lmult of R6) | ([: (the carrier of R5) , D54 :] qua set) );
L257: ( dom (the lmult of R6) ) = [: (the carrier of R5) , D56 :] by FUNCT_2:def 1;
L258: ( dom D59 ) = [: (the carrier of R5) , D54 :] by L257 , RELAT_1:62 , ZFMISC_1:96;
L259: ( rng D59 ) c= D54
proof
let R1 being set;
assume L260: R1 in ( rng D59 );
consider R2 being set such that L261: R2 in ( dom D59 ) and L262: ( D59 . R2 ) = R1 by L260 , FUNCT_1:def 3;
consider R3 being set, R4 being set such that L263: [ R3 , R4 ] = R2 by L258 , L261 , RELAT_1:def 1;
reconsider D60 = R3 as (Element of R5) by L258 , L261 , L263 , ZFMISC_1:87;
L264: R4 in R19 by L258 , L261 , L263 , ZFMISC_1:87;
reconsider D61 = R4 as (Element of R6) by L264;
L265: R1 = ( D60 * D61 ) by L261 , L262 , L263 , FUNCT_1:47;
thus L266: thesis by L265 , L248 , L264 , L3;
end;
set D62 = ( (the addF of R6) || D54 );
L267: ( dom (the addF of R6) ) = [: D56 , D56 :] by FUNCT_2:def 1;
L268: ( dom D62 ) = [: D54 , D54 :] by L267 , RELAT_1:62 , ZFMISC_1:96;
L269: ( rng D62 ) c= D54
proof
let R1 being set;
assume L270: R1 in ( rng D62 );
consider R2 being set such that L271: R2 in ( dom D62 ) and L272: ( D62 . R2 ) = R1 by L270 , FUNCT_1:def 3;
consider R3 being set, R4 being set such that L273: [ R3 , R4 ] = R2 by L268 , L271 , RELAT_1:def 1;
L274: (R3 in D54 & R4 in D54) by L268 , L271 , L273 , ZFMISC_1:87;
reconsider D63 = R3 , D64 = R4 as (Element of R6) by L274;
L275: R1 = ( D63 + D64 ) by L271 , L272 , L273 , FUNCT_1:47;
thus L276: thesis by L275 , L248 , L274 , L3;
end;
reconsider D65 = D59 as (Function of [: (the carrier of R5) , D54 :] , D54) by L258 , L259 , FUNCT_2:def 1 , RELSET_1:4;
reconsider D66 = D57 as (UnOp of D54) by L250 , L251 , FUNCT_2:def 1 , RELSET_1:4;
reconsider D67 = D62 as (BinOp of D54) by L268 , L269 , FUNCT_2:def 1 , RELSET_1:4;
set D68 = VectSpStr (# D54 , D67 , D55 , D65 #);
L277: (for B66 , B67 being (Element of D68) holds (for B68 , B69 being (Element of R6) holds ((B68 = B66 & B67 = B69) implies ( B66 + B67 ) = ( B68 + B69 ))))
proof
let C87 , C88 being (Element of D68);
let C89 , C90 being (Element of R6);
assume that
L278: (C89 = C87 & C88 = C90);
thus L279: ( C87 + C88 ) = ( D67 . [ C87 , C88 ] )
.= ( C89 + C90 ) by L268 , L278 , FUNCT_1:47;
end;
L280: D68 is  Abelian  add-associative  right_zeroed  right_complementable
proof
thus L281: D68 is  Abelian
proof
let C91 , C92 being (Element of D68);
reconsider D69 = C91 , D70 = C92 as (Element of R6) by TARSKI:def 3;
thus L282: ( C91 + C92 ) = ( D70 + D69 ) by L277
.= ( C92 + C91 ) by L277;
end;

thus L283:now
let C93 , C94 , C95 being (Element of D68);
reconsider D71 = C93 , D72 = C94 , D73 = C95 as (Element of R6) by TARSKI:def 3;
L284: ( C94 + C95 ) = ( D72 + D73 ) by L277;
L285: ( C93 + C94 ) = ( D71 + D72 ) by L277;
thus L286: ( ( C93 + C94 ) + C95 ) = ( ( D71 + D72 ) + D73 ) by L285 , L277
.= ( D71 + ( D72 + D73 ) ) by RLVECT_1:def 3
.= ( C93 + ( C94 + C95 ) ) by L277 , L284;
end;
thus L287:now
let C96 being (Element of D68);
reconsider D74 = C96 as (Element of R6) by TARSKI:def 3;
thus L288: ( C96 + ( 0. D68 ) ) = ( D74 + ( 0. R6 ) ) by L277
.= C96 by RLVECT_1:4;
end;
let C97 being (Element of D68);
reconsider D75 = C97 as (Element of R6) by TARSKI:def 3;
reconsider D76 = C97 as (Element of D54);
reconsider D77 = ( D66 . D76 ) as (Element of D54);
reconsider D78 = D77 as (Element of D68);
take D78;
thus L289: ( C97 + D78 ) = ( D75 + ( ( comp R6 ) . D75 ) ) by L250 , L277 , FUNCT_1:47
.= ( D75 + ( - D75 ) ) by VECTSP_1:def 13
.= ( 0. D68 ) by RLVECT_1:5;
end;
L290: D68 is  vector-distributive
proof
let C98 being (Element of R5);
let C99 , C100 being (Element of D68);
reconsider D79 = C99 , D80 = C100 as (Element of R6) by TARSKI:def 3;
L291:
now
let C101 being (Element of R5);
let C102 being (Element of D68);
let C103 being (Element of R6);
assume L292: C103 = C102;
L293: [ C101 , C102 ] in ( dom D65 ) by L258;
thus L294: ( C101 * C102 ) = ( C101 * C103 ) by L293 , L292 , FUNCT_1:47;
end;
L295: ( C98 * C99 ) = ( C98 * D79 ) by L291;
L296: ( C98 * C100 ) = ( C98 * D80 ) by L291;
L297: ( C99 + C100 ) = ( D79 + D80 ) by L277;
thus L298: ( C98 * ( C99 + C100 ) ) = ( C98 * ( D79 + D80 ) ) by L297 , L291
.= ( ( C98 * D79 ) + ( C98 * D80 ) ) by VECTSP_1:def 14
.= ( ( C98 * C99 ) + ( C98 * C100 ) ) by L277 , L295 , L296;
end;
L299: D68 is  scalar-distributive
proof
let C104 , C105 being (Element of R5);
let C106 being (Element of D68);
reconsider D81 = C106 as (Element of R6) by TARSKI:def 3;
L300:
now
let C107 being (Element of R5);
let C108 being (Element of D68);
let C109 being (Element of R6);
assume L301: C109 = C108;
L302: [ C107 , C108 ] in ( dom D65 ) by L258;
thus L303: ( C107 * C108 ) = ( C107 * C109 ) by L302 , L301 , FUNCT_1:47;
end;
L304: ( C104 * C106 ) = ( C104 * D81 ) by L300;
L305: ( C105 * C106 ) = ( C105 * D81 ) by L300;
thus L306: ( ( C104 + C105 ) * C106 ) = ( ( C104 + C105 ) * D81 ) by L300
.= ( ( C104 * D81 ) + ( C105 * D81 ) ) by VECTSP_1:def 15
.= ( ( C104 * C106 ) + ( C105 * C106 ) ) by L277 , L305 , L304;
end;
L307: D68 is  scalar-associative
proof
let C110 , C111 being (Element of R5);
let C112 being (Element of D68);
reconsider D82 = C112 as (Element of R6) by TARSKI:def 3;
L308:
now
let C113 being (Element of R5);
let C114 being (Element of D68);
let C115 being (Element of R6);
assume L309: C115 = C114;
L310: [ C113 , C114 ] in ( dom D65 ) by L258;
thus L311: ( C113 * C114 ) = ( C113 * C115 ) by L310 , L309 , FUNCT_1:47;
end;
L312: ( C111 * C112 ) = ( C111 * D82 ) by L308;
thus L313: ( ( C110 * C111 ) * C112 ) = ( ( C110 * C111 ) * D82 ) by L308
.= ( C110 * ( C111 * D82 ) ) by VECTSP_1:def 16
.= ( C110 * ( C111 * C112 ) ) by L308 , L312;
end;
L314: D68 is  scalar-unital
proof
let C116 being (Element of D68);
reconsider D83 = C116 as (Element of R6) by TARSKI:def 3;
L315:
now
let C117 being (Element of R5);
let C118 being (Element of D68);
let C119 being (Element of R6);
assume L316: C119 = C118;
L317: [ C117 , C118 ] in ( dom D65 ) by L258;
thus L318: ( C117 * C118 ) = ( C117 * C119 ) by L317 , L316 , FUNCT_1:47;
end;
thus L319: ( ( 1. R5 ) * C116 ) = ( ( 1_ R5 ) * D83 ) by L315
.= C116 by VECTSP_1:def 17;
end;
reconsider D84 = D68 as  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 by L314 , L280 , L290 , L299 , L307;
L320: ( 0. D84 ) = ( 0. R6 );
reconsider D85 = D84 as  strict (Subspace of R6) by L320 , L70;
take D85;
thus L321: thesis;
end;
definition
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
func (0). R6 ->  strict (Subspace of R6) means 
:L322: (the carrier of it) = { ( 0. R6 ) };
correctness by L21 , L216 , L246;
end;
definition
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
func (Omega). R6 ->  strict (Subspace of R6) equals 
( the VectSpStr of R6 );
coherence
proof
set D86 = ( the VectSpStr of R6 );
L324: D86 is  vector-distributive
proof
let C120 being (Element of R5);
let C121 , C122 being (Element of D86);
reconsider D87 = C121 , D88 = C122 as (Element of R6);
thus L325: ( C120 * ( C121 + C122 ) ) = ( C120 * ( D87 + D88 ) )
.= ( ( C120 * D87 ) + ( C120 * D88 ) ) by VECTSP_1:def 14
.= ( ( C120 * C121 ) + ( C120 * C122 ) );
end;
L326: D86 is  scalar-distributive
proof
let C123 , C124 being (Element of R5);
let C125 being (Element of D86);
reconsider D89 = C125 as (Element of R6);
thus L327: ( ( C123 + C124 ) * C125 ) = ( ( C123 + C124 ) * D89 )
.= ( ( C123 * D89 ) + ( C124 * D89 ) ) by VECTSP_1:def 15
.= ( ( C123 * C125 ) + ( C124 * C125 ) );
end;
L328: D86 is  scalar-associative
proof
let C126 , C127 being (Element of R5);
let C128 being (Element of D86);
reconsider D90 = C128 as (Element of R6);
thus L329: ( ( C126 * C127 ) * C128 ) = ( ( C126 * C127 ) * D90 )
.= ( C126 * ( C127 * D90 ) ) by VECTSP_1:def 16
.= ( C126 * ( C127 * C128 ) );
end;
L330: D86 is  scalar-unital
proof
let C129 being (Element of D86);
reconsider D91 = C129 as (Element of R6);
thus L331: ( ( 1. R5 ) * C129 ) = ( ( 1_ R5 ) * D91 )
.= C129 by VECTSP_1:def 17;
end;
L332: (for R9 being (Element of R5) holds (for B70 , B71 being (Element of D86) holds (for B72 , B73 being (Element of R6) holds ((B70 = B72 & B71 = B73) implies (( B70 + B71 ) = ( B72 + B73 ) & ( R9 * B70 ) = ( R9 * B72 ))))));
L333: D86 is  Abelian  add-associative  right_zeroed  right_complementable
proof
thus L334: D86 is  Abelian
proof
let C130 , C131 being (Element of D86);
reconsider D92 = C130 , D93 = C131 as (Element of R6);
thus L335: ( C130 + C131 ) = ( D93 + D92 ) by L332
.= ( C131 + C130 );
end;

thus L336:now
let C132 , C133 , C134 being (Element of D86);
reconsider D94 = C132 , D95 = C133 , D96 = C134 as (Element of R6);
thus L337: ( ( C132 + C133 ) + C134 ) = ( ( D94 + D95 ) + D96 )
.= ( D94 + ( D95 + D96 ) ) by RLVECT_1:def 3
.= ( C132 + ( C133 + C134 ) );
end;
thus L338:now
let C135 being (Element of D86);
reconsider D97 = C135 as (Element of R6);
thus L339: ( C135 + ( 0. D86 ) ) = ( D97 + ( 0. R6 ) )
.= C135 by RLVECT_1:4;
end;
let C136 being (Element of D86);
reconsider D98 = C136 as (Element of R6);
consider C137 being (Element of R6) such that L340: ( D98 + C137 ) = ( 0. R6 ) by ALGSTR_0:def 11;
reconsider D99 = C137 as (Element of D86);
take D99;
thus L341: thesis by L340;
end;
reconsider D100 = D86 as  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 by L333 , L330 , L324 , L326 , L328;
L342: (the lmult of D100) = ( (the lmult of R6) | ([: (the carrier of R5) , (the carrier of D100) :] qua set) ) by RELSET_1:19;
L343: (( 0. D100 ) = ( 0. R6 ) & (the addF of D100) = ( (the addF of R6) || (the carrier of D100) )) by RELSET_1:19;
thus L344: thesis by L343 , L342 , L70;
end;
end;
theorem
L346: (for R1 being set holds (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (R1 in ( (0). R6 ) iff R1 = ( 0. R6 )))))
proof
let R1 being set;
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
thus L347: (R1 in ( (0). R6 ) implies R1 = ( 0. R6 ))
proof
assume L348: R1 in ( (0). R6 );
L349: R1 in (the carrier of ( (0). R6 )) by L348 , STRUCT_0:def 5;
L350: R1 in { ( 0. R6 ) } by L349 , L322;
thus L351: thesis by L350 , TARSKI:def 1;
end;

thus L352: thesis by L115;
end;
theorem
L353: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R16 being (Subspace of R6) holds ( (0). R16 ) = ( (0). R6 ))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R16 being (Subspace of R6);
L354: ((the carrier of ( (0). R16 )) = { ( 0. R16 ) } & (the carrier of ( (0). R6 )) = { ( 0. R6 ) }) by L322;
L355: (the carrier of ( (0). R16 )) = (the carrier of ( (0). R6 )) by L354 , L70;
L356: ( (0). R16 ) is (Subspace of R6) by L157;
thus L357: thesis by L356 , L355 , L216;
end;
theorem
L358: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R17 being (Subspace of R6) holds (for R18 being (Subspace of R6) holds ( (0). R17 ) = ( (0). R18 )))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R17 being (Subspace of R6);
let R18 being (Subspace of R6);
L359: ( (0). R17 ) = ( (0). R6 ) by L353;
thus L360: thesis by L359 , L353;
end;
theorem
L361: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R16 being (Subspace of R6) holds ( (0). R16 ) is (Subspace of R6)))) by L157;
theorem
L362: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R16 being (Subspace of R6) holds ( (0). R6 ) is (Subspace of R16))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R16 being (Subspace of R6);
L363: ( (0). R16 ) = ( (0). R6 ) by L353;
thus L364: thesis by L363;
end;
theorem
L365: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R17 being (Subspace of R6) holds (for R18 being (Subspace of R6) holds ( (0). R17 ) is (Subspace of R18)))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R17 being (Subspace of R6);
let R18 being (Subspace of R6);
L366: ( (0). R17 ) = ( (0). R18 ) by L358;
thus L367: thesis by L366;
end;
theorem
L368: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B74 being  strict  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds B74 is (Subspace of ( (Omega). B74 ))));
definition
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R13 being (Element of R6);
let R16 being (Subspace of R6);
func R13 + R16 -> (Subset of R6) equals 
{ ( R13 + R10 ) where R10 is (Element of R6) : R10 in R16 };
coherence
proof
set D101 = { ( R13 + R10 ) where R10 is (Element of R6) : R10 in R16 };
defpred S1[ set ] means (ex R10 being (Element of R6) st ($1 = ( R13 + R10 ) & R10 in R16));
consider C138 being set such that L369: (for B75 being set holds (B75 in C138 iff (B75 in (the carrier of R6) & S1[ B75 ]))) from XBOOLE_0:sch 1;
L370: C138 c= (the carrier of R6)
proof
let C139 being set;
assume L371: C139 in C138;
thus L372: thesis by L371 , L369;
end;
reconsider D102 = C138 as (Subset of R6) by L370;
L373: D101 c= D102
proof
let C140 being set;
assume L374: C140 in D101;
L375: (ex R10 being (Element of R6) st (C140 = ( R13 + R10 ) & R10 in R16)) by L374;
thus L376: thesis by L375 , L369;
end;
L377: D102 c= D101
proof
let C141 being set;
assume L378: C141 in D102;
L379: (ex R10 being (Element of R6) st (C141 = ( R13 + R10 ) & R10 in R16)) by L378 , L369;
thus L380: thesis by L379;
end;
thus L381: thesis by L377 , L373 , XBOOLE_0:def 10;
end;
end;
L383: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R16 being (Subspace of R6) holds ( ( 0. R6 ) + R16 ) = (the carrier of R16))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R16 being (Subspace of R6);
set D103 = { ( ( 0. R6 ) + R10 ) where R10 is (Element of R6) : R10 in R16 };
L384: (the carrier of R16) c= D103
proof
let C142 being set;
assume L385: C142 in (the carrier of R16);
L386: C142 in R16 by L385 , STRUCT_0:def 5;
L387: C142 in R6 by L386 , L78;
reconsider D104 = C142 as (Element of R6) by L387 , STRUCT_0:def 5;
L388: ( ( 0. R6 ) + D104 ) = C142 by RLVECT_1:4;
thus L389: thesis by L388 , L386;
end;
L390: D103 c= (the carrier of R16)
proof
let C143 being set;
assume L391: C143 in D103;
consider R10 being (Element of R6) such that L392: C143 = ( ( 0. R6 ) + R10 ) and L393: R10 in R16 by L391;
L394: C143 = R10 by L392 , RLVECT_1:4;
thus L395: thesis by L394 , L393 , STRUCT_0:def 5;
end;
thus L396: thesis by L390 , L384 , XBOOLE_0:def 10;
end;
definition
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R16 being (Subspace of R6);
mode Coset of R16
 -> (Subset of R6)
means :L397: (ex R13 being (Element of R6) st it = ( R13 + R16 ));
existence
proof
reconsider D105 = (the carrier of R16) as (Subset of R6) by L70;
take D105;
take ( 0. R6 );
thus L398: thesis by L383;
end;
end;
theorem
L400: (for R1 being set holds (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (R1 in ( R13 + R16 ) iff (ex R10 being (Element of R6) st (R10 in R16 & R1 = ( R13 + R10 )))))))))
proof
let R1 being set;
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R13 being (Element of R6);
let R16 being (Subspace of R6);
thus L401: (R1 in ( R13 + R16 ) implies (ex R10 being (Element of R6) st (R10 in R16 & R1 = ( R13 + R10 ))))
proof
assume L402: R1 in ( R13 + R16 );
consider R10 being (Element of R6) such that L403: (R1 = ( R13 + R10 ) & R10 in R16) by L402;
take R10;
thus L404: thesis by L403;
end;

given R10 being (Element of R6) such that
L405: (R10 in R16 & R1 = ( R13 + R10 ));

thus L406: thesis by L405;
end;
theorem
L407: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (( 0. R6 ) in ( R13 + R16 ) iff R13 in R16)))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R13 being (Element of R6);
let R16 being (Subspace of R6);
thus L408: (( 0. R6 ) in ( R13 + R16 ) implies R13 in R16)
proof
assume L409: ( 0. R6 ) in ( R13 + R16 );
consider R10 being (Element of R6) such that L410: ( 0. R6 ) = ( R13 + R10 ) and L411: R10 in R16 by L409;
L412: R13 = ( - R10 ) by L410 , VECTSP_1:16;
thus L413: thesis by L412 , L411 , L134;
end;

assume L414: R13 in R16;
L415: ( - R13 ) in R16 by L414 , L134;
L416: ( 0. R6 ) = ( R13 + ( - R13 ) ) by VECTSP_1:19;
thus L417: thesis by L416 , L415;
end;
theorem
L418: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds R13 in ( R13 + R16 )))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R13 being (Element of R6);
let R16 being (Subspace of R6);
L419: (( R13 + ( 0. R6 ) ) = R13 & ( 0. R6 ) in R16) by L115 , RLVECT_1:4;
thus L420: thesis by L419;
end;
theorem
L421: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R16 being (Subspace of R6) holds ( ( 0. R6 ) + R16 ) = (the carrier of R16)))) by L383;
theorem
L422: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R13 being (Element of R6) holds ( R13 + ( (0). R6 ) ) = { R13 })))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R13 being (Element of R6);
thus L423: ( R13 + ( (0). R6 ) ) c= { R13 }
proof
let C144 being set;
assume L424: C144 in ( R13 + ( (0). R6 ) );
consider R10 being (Element of R6) such that L425: C144 = ( R13 + R10 ) and L426: R10 in ( (0). R6 ) by L424;
L427: (the carrier of ( (0). R6 )) = { ( 0. R6 ) } by L322;
L428: R10 in (the carrier of ( (0). R6 )) by L426 , STRUCT_0:def 5;
L429: R10 = ( 0. R6 ) by L428 , L427 , TARSKI:def 1;
L430: C144 = R13 by L429 , L425 , RLVECT_1:4;
thus L431: thesis by L430 , TARSKI:def 1;
end;

let C145 being set;
assume L432: C145 in { R13 };
L433: C145 = R13 by L432 , TARSKI:def 1;
L434: (( 0. R6 ) in ( (0). R6 ) & R13 = ( R13 + ( 0. R6 ) )) by L115 , RLVECT_1:4;
thus L435: thesis by L434 , L433;
end;
L436: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (R13 in R16 iff ( R13 + R16 ) = (the carrier of R16))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R13 being (Element of R6);
let R16 being (Subspace of R6);
L437: (( 0. R6 ) in R16 & ( R13 + ( 0. R6 ) ) = R13) by L115 , RLVECT_1:4;
L438: R13 in { ( R13 + R10 ) where R10 is (Element of R6) : R10 in R16 } by L437;
thus L439: (R13 in R16 implies ( R13 + R16 ) = (the carrier of R16))
proof
assume L440: R13 in R16;
thus L441: ( R13 + R16 ) c= (the carrier of R16)
proof
let C146 being set;
assume L442: C146 in ( R13 + R16 );
consider R10 being (Element of R6) such that L443: C146 = ( R13 + R10 ) and L444: R10 in R16 by L442;
L445: ( R13 + R10 ) in R16 by L440 , L444 , L122;
thus L446: thesis by L445 , L443 , STRUCT_0:def 5;
end;

let C147 being set;
assume L447: C147 in (the carrier of R16);
reconsider D106 = C147 , D107 = R13 as (Element of R16) by L447 , L440 , STRUCT_0:def 5;
reconsider D108 = D106 , D109 = D107 as (Element of R6) by L83;
L448: ( D107 + ( D106 - D107 ) ) = ( D106 + ( D107 + ( - D107 ) ) ) by RLVECT_1:def 3
.= ( D106 + ( 0. R16 ) ) by VECTSP_1:19
.= C147 by RLVECT_1:4;
L449: ( D106 - D107 ) in R16 by STRUCT_0:def 5;
L450: ( D108 - D109 ) in R16 by L449 , L101;
L451: ( D106 - D107 ) = ( D108 - D109 ) by L101;
L452: ( D109 + ( D108 - D109 ) ) = C147 by L451 , L448 , L89;
thus L453: thesis by L452 , L450;
end;

assume L454: ( R13 + R16 ) = (the carrier of R16);
assume L455: (not R13 in R16);
thus L456: thesis by L455 , L454 , L438 , STRUCT_0:def 5;
end;
theorem
L457: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R13 being (Element of R6) holds ( R13 + ( (Omega). R6 ) ) = (the carrier of R6))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R13 being (Element of R6);
L458: R13 in ( (Omega). R6 ) by RLVECT_1:1;
thus L459: thesis by L458 , L436;
end;
theorem
L460: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (( 0. R6 ) in ( R13 + R16 ) iff ( R13 + R16 ) = (the carrier of R16))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R13 being (Element of R6);
let R16 being (Subspace of R6);
L461: (( 0. R6 ) in ( R13 + R16 ) iff R13 in R16) by L407;
thus L462: thesis by L461 , L436;
end;
theorem
L463: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (R13 in R16 iff ( R13 + R16 ) = (the carrier of R16)))))) by L436;
theorem
L464: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R9 being (Element of R5) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (R13 in R16 implies ( ( R9 * R13 ) + R16 ) = (the carrier of R16)))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R9 being (Element of R5);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
assume L465: R13 in R16;
L466: ( R9 * R13 ) in R16 by L465 , L128;
thus L467: thesis by L466 , L436;
end;
theorem
L468: (for B76 being Field holds (for B77 being (VectSp of B76) holds (for B78 being (Element of B76) holds (for B79 being (Element of B77) holds (for B80 being (Subspace of B77) holds ((B78 <> ( 0. B76 ) & ( ( B78 * B79 ) + B80 ) = (the carrier of B80)) implies B79 in B80))))))
proof
let C148 being Field;
let C149 being (VectSp of C148);
let C150 being (Element of C148);
let C151 being (Element of C149);
let C152 being (Subspace of C149);
assume that
L469: C150 <> ( 0. C148 )
and
L470: ( ( C150 * C151 ) + C152 ) = (the carrier of C152);
assume L471: (not C151 in C152);
L472: (not ( ( 1_ C148 ) * C151 ) in C152) by L471 , VECTSP_1:def 17;
L473: (not ( ( ( C150 " ) * C150 ) * C151 ) in C152) by L472 , L469 , VECTSP_1:def 10;
L474: (not ( ( C150 " ) * ( C150 * C151 ) ) in C152) by L473 , VECTSP_1:def 16;
L475: (not ( C150 * C151 ) in C152) by L474 , L128;
L476: (( 0. C149 ) in C152 & ( ( C150 * C151 ) + ( 0. C149 ) ) = ( C150 * C151 )) by L115 , RLVECT_1:4;
L477: ( C150 * C151 ) in { ( ( C150 * C151 ) + B81 ) where B81 is (Vector of C149) : B81 in C152 } by L476;
thus L478: contradiction by L477 , L470 , L475 , STRUCT_0:def 5;
end;
theorem
L479: (for B82 being Field holds (for B83 being (VectSp of B82) holds (for B84 being (Element of B83) holds (for B85 being (Subspace of B83) holds (B84 in B85 iff ( ( - B84 ) + B85 ) = (the carrier of B85))))))
proof
let C153 being Field;
let C154 being (VectSp of C153);
let C155 being (Element of C154);
let C156 being (Subspace of C154);
L480: ( - ( 1_ C153 ) ) <> ( 0. C153 ) by VECTSP_2:3;
L481: (C155 in C156 iff ( ( ( - ( 1_ C153 ) ) * C155 ) + C156 ) = (the carrier of C156)) by L480 , L464 , L468;
thus L482: thesis by L481 , VECTSP_1:14;
end;
theorem
L483: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (R10 in R16 iff ( R13 + R16 ) = ( ( R13 + R10 ) + R16 )))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
thus L484: (R10 in R16 implies ( R13 + R16 ) = ( ( R13 + R10 ) + R16 ))
proof
assume L485: R10 in R16;
thus L486: ( R13 + R16 ) c= ( ( R13 + R10 ) + R16 )
proof
let C157 being set;
assume L487: C157 in ( R13 + R16 );
consider R14 being (Element of R6) such that L488: C157 = ( R13 + R14 ) and L489: R14 in R16 by L487;
L490: ( ( R13 + R10 ) + ( R14 - R10 ) ) = ( R13 + ( R10 + ( R14 - R10 ) ) ) by RLVECT_1:def 3
.= ( R13 + ( ( R14 + R10 ) - R10 ) ) by RLVECT_1:def 3
.= ( R13 + ( R14 + ( R10 - R10 ) ) ) by RLVECT_1:def 3
.= ( R13 + ( R14 + ( 0. R6 ) ) ) by VECTSP_1:19
.= C157 by L488 , RLVECT_1:4;
L491: ( R14 - R10 ) in R16 by L485 , L489 , L138;
thus L492: thesis by L491 , L490;
end;

let C158 being set;
assume L493: C158 in ( ( R13 + R10 ) + R16 );
consider R15 being (Element of R6) such that L494: C158 = ( ( R13 + R10 ) + R15 ) and L495: R15 in R16 by L493;
L496: C158 = ( R13 + ( R10 + R15 ) ) by L494 , RLVECT_1:def 3;
L497: ( R10 + R15 ) in R16 by L485 , L495 , L122;
thus L498: thesis by L497 , L496;
end;

assume L499: ( R13 + R16 ) = ( ( R13 + R10 ) + R16 );
L500: (( 0. R6 ) in R16 & ( R13 + ( 0. R6 ) ) = R13) by L115 , RLVECT_1:4;
L501: R13 in ( ( R13 + R10 ) + R16 ) by L500 , L499;
consider R11 being (Element of R6) such that L502: R13 = ( ( R13 + R10 ) + R11 ) and L503: R11 in R16 by L501;
L504: R13 = ( R13 + ( R10 + R11 ) ) by L502 , RLVECT_1:def 3;
L505: ( R10 + R11 ) = ( 0. R6 ) by L504 , RLVECT_1:9;
L506: R10 = ( - R11 ) by L505 , VECTSP_1:16;
thus L507: thesis by L506 , L503 , L134;
end;
theorem
L508: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (R10 in R16 iff ( R13 + R16 ) = ( ( R13 - R10 ) + R16 )))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
L509: (( - R10 ) in R16 implies R10 in R16)
proof
assume L510: ( - R10 ) in R16;
L511: ( - ( - R10 ) ) in R16 by L510 , L134;
thus L512: thesis by L511 , RLVECT_1:17;
end;
L513: (( - R10 ) in R16 iff ( R13 + R16 ) = ( ( R13 + ( - R10 ) ) + R16 )) by L483;
thus L514: thesis by L513 , L509 , L134;
end;
theorem
L515: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (R13 in ( R10 + R16 ) iff ( R10 + R16 ) = ( R13 + R16 )))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
thus L516: (R13 in ( R10 + R16 ) implies ( R10 + R16 ) = ( R13 + R16 ))
proof
assume L517: R13 in ( R10 + R16 );
consider C159 being (Element of R6) such that L518: R13 = ( R10 + C159 ) and L519: C159 in R16 by L517;
thus L520: ( R10 + R16 ) c= ( R13 + R16 )
proof
let C160 being set;
assume L521: C160 in ( R10 + R16 );
consider R14 being (Element of R6) such that L522: C160 = ( R10 + R14 ) and L523: R14 in R16 by L521;
L524: ( R13 - C159 ) = ( R10 + ( C159 - C159 ) ) by L518 , RLVECT_1:def 3
.= ( R10 + ( 0. R6 ) ) by VECTSP_1:19
.= R10 by RLVECT_1:4;
L525: C160 = ( R13 + ( R14 + ( - C159 ) ) ) by L524 , L522 , RLVECT_1:def 3
.= ( R13 + ( R14 - C159 ) );
L526: ( R14 - C159 ) in R16 by L519 , L523 , L138;
thus L527: thesis by L526 , L525;
end;

let C161 being set;
assume L528: C161 in ( R13 + R16 );
consider R15 being (Element of R6) such that L529: (C161 = ( R13 + R15 ) & R15 in R16) by L528;
L530: (( C159 + R15 ) in R16 & C161 = ( R10 + ( C159 + R15 ) )) by L518 , L519 , L529 , L122 , RLVECT_1:def 3;
thus L531: thesis by L530;
end;

thus L532: thesis by L418;
end;
theorem
L533: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R14 being (Element of R6) holds (for R15 being (Element of R6) holds (for R16 being (Subspace of R6) holds ((R10 in ( R14 + R16 ) & R10 in ( R15 + R16 )) implies ( R14 + R16 ) = ( R15 + R16 ))))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R14 being (Element of R6);
let R15 being (Element of R6);
let R16 being (Subspace of R6);
assume that
L534: R10 in ( R14 + R16 )
and
L535: R10 in ( R15 + R16 );
thus L536: ( R14 + R16 ) = ( R10 + R16 ) by L534 , L515
.= ( R15 + R16 ) by L535 , L515;
end;
theorem
L537: (for B86 being Field holds (for B87 being (VectSp of B86) holds (for B88 being (Element of B86) holds (for B89 being (Element of B87) holds (for B90 being (Subspace of B87) holds ((B88 <> ( 1_ B86 ) & ( B88 * B89 ) in ( B89 + B90 )) implies B89 in B90))))))
proof
let C162 being Field;
let C163 being (VectSp of C162);
let C164 being (Element of C162);
let C165 being (Element of C163);
let C166 being (Subspace of C163);
assume that
L538: C164 <> ( 1_ C162 )
and
L539: ( C164 * C165 ) in ( C165 + C166 );
L540: ( C164 - ( 1_ C162 ) ) <> ( 0. C162 ) by L538 , RLVECT_1:21;
consider C167 being (Element of C163) such that L541: ( C164 * C165 ) = ( C165 + C167 ) and L542: C167 in C166 by L539;
L543: C167 = ( C167 + ( 0. C163 ) ) by RLVECT_1:4
.= ( C167 + ( C165 - C165 ) ) by VECTSP_1:19
.= ( ( C164 * C165 ) - C165 ) by L541 , RLVECT_1:def 3
.= ( ( C164 * C165 ) - ( ( 1_ C162 ) * C165 ) ) by VECTSP_1:def 17
.= ( ( C164 - ( 1_ C162 ) ) * C165 ) by L1;
L544: ( ( ( C164 - ( 1_ C162 ) ) " ) * C167 ) = ( ( ( ( C164 - ( 1_ C162 ) ) " ) * ( C164 - ( 1_ C162 ) ) ) * C165 ) by L543 , VECTSP_1:def 16;
L545: ( ( 1_ C162 ) * C165 ) = ( ( ( C164 - ( 1_ C162 ) ) " ) * C167 ) by L544 , L540 , VECTSP_1:def 10;
L546: C165 = ( ( ( C164 - ( 1_ C162 ) ) " ) * C167 ) by L545 , VECTSP_1:def 17;
thus L547: thesis by L546 , L542 , L128;
end;
theorem
L548: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R9 being (Element of R5) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (R13 in R16 implies ( R9 * R13 ) in ( R13 + R16 )))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R9 being (Element of R5);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
assume L549: R13 in R16;
L550: (( R13 + R16 ) = (the carrier of R16) & ( R9 * R13 ) in R16) by L549 , L436 , L128;
thus L551: thesis by L550 , STRUCT_0:def 5;
end;
theorem
L552: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (R13 in R16 implies ( - R13 ) in ( R13 + R16 ))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R13 being (Element of R6);
let R16 being (Subspace of R6);
assume L553: R13 in R16;
L554: ( ( - ( 1_ R5 ) ) * R13 ) in ( R13 + R16 ) by L553 , L548;
thus L555: thesis by L554 , VECTSP_1:14;
end;
theorem
L556: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (( R10 + R13 ) in ( R13 + R16 ) iff R10 in R16))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
thus L557: (( R10 + R13 ) in ( R13 + R16 ) implies R10 in R16)
proof
assume L558: ( R10 + R13 ) in ( R13 + R16 );
L559: (ex R14 being (Element of R6) st (( R10 + R13 ) = ( R13 + R14 ) & R14 in R16)) by L558;
thus L560: thesis by L559 , RLVECT_1:8;
end;

assume L561: R10 in R16;
thus L562: thesis by L561;
end;
theorem
L563: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (( R13 - R10 ) in ( R13 + R16 ) iff R10 in R16))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
L564: ( R13 - R10 ) = ( ( - R10 ) + R13 );
L565: (( - R10 ) in R16 implies ( - ( - R10 ) ) in R16) by L134;
L566: (R10 in R16 implies ( - R10 ) in R16) by L134;
thus L567: thesis by L566 , L564 , L565 , L556 , RLVECT_1:17;
end;
theorem
L568: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (R10 in ( R13 + R16 ) iff (ex R14 being (Element of R6) st (R14 in R16 & R10 = ( R13 - R14 )))))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
thus L569: (R10 in ( R13 + R16 ) implies (ex R14 being (Element of R6) st (R14 in R16 & R10 = ( R13 - R14 ))))
proof
assume L570: R10 in ( R13 + R16 );
consider R14 being (Element of R6) such that L571: R10 = ( R13 + R14 ) and L572: R14 in R16 by L570;
take D110 = ( - R14 );
thus L573: D110 in R16 by L572 , L134;
thus L574: thesis by L571 , RLVECT_1:17;
end;

given R14 being (Element of R6) such that
L575: R14 in R16
and
L576: R10 = ( R13 - R14 );

L577: ( - R14 ) in R16 by L575 , L134;
thus L578: thesis by L577 , L576;
end;
theorem
L579: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R14 being (Element of R6) holds (for R15 being (Element of R6) holds (for R16 being (Subspace of R6) holds ((ex R13 being (Element of R6) st (R14 in ( R13 + R16 ) & R15 in ( R13 + R16 ))) iff ( R14 - R15 ) in R16))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R14 being (Element of R6);
let R15 being (Element of R6);
let R16 being (Subspace of R6);
thus L580: ((ex R13 being (Element of R6) st (R14 in ( R13 + R16 ) & R15 in ( R13 + R16 ))) implies ( R14 - R15 ) in R16)
proof
given R13 being (Element of R6) such that
L581: R14 in ( R13 + R16 )
and
L582: R15 in ( R13 + R16 );

consider R12 being (Element of R6) such that L583: R12 in R16 and L584: R15 = ( R13 + R12 ) by L582 , L400;
consider R11 being (Element of R6) such that L585: R11 in R16 and L586: R14 = ( R13 + R11 ) by L581 , L400;
L587: ( R14 - R15 ) = ( ( R11 + R13 ) + ( ( - R13 ) - R12 ) ) by L586 , L584 , VECTSP_1:17
.= ( ( ( R11 + R13 ) + ( - R13 ) ) - R12 ) by RLVECT_1:def 3
.= ( ( R11 + ( R13 + ( - R13 ) ) ) - R12 ) by RLVECT_1:def 3
.= ( ( R11 + ( 0. R6 ) ) - R12 ) by RLVECT_1:5
.= ( R11 - R12 ) by RLVECT_1:4;
thus L588: thesis by L587 , L585 , L583 , L138;
end;

assume L589: ( R14 - R15 ) in R16;
L590: ( - ( R14 - R15 ) ) in R16 by L589 , L134;
take R14;
thus L591: R14 in ( R14 + R16 ) by L418;
L592: ( R14 + ( - ( R14 - R15 ) ) ) = ( R14 + ( ( - R14 ) + R15 ) ) by VECTSP_1:17
.= ( ( R14 + ( - R14 ) ) + R15 ) by RLVECT_1:def 3
.= ( ( 0. R6 ) + R15 ) by RLVECT_1:5
.= R15 by RLVECT_1:4;
thus L593: thesis by L592 , L590;
end;
theorem
L594: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (( R13 + R16 ) = ( R10 + R16 ) implies (ex R14 being (Element of R6) st (R14 in R16 & ( R13 + R14 ) = R10))))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
assume L595: ( R13 + R16 ) = ( R10 + R16 );
L596: R13 in ( R10 + R16 ) by L595 , L418;
consider R11 being (Element of R6) such that L597: R13 = ( R10 + R11 ) and L598: R11 in R16 by L596;
take D111 = ( R10 - R13 );
L599: ( 0. R6 ) = ( ( R10 + R11 ) - R13 ) by L597 , VECTSP_1:19
.= ( R11 + ( R10 - R13 ) ) by RLVECT_1:def 3;
L600: D111 = ( - R11 ) by L599 , VECTSP_1:16;
thus L601: D111 in R16 by L600 , L598 , L134;
thus L602: ( R13 + D111 ) = ( ( R10 + R13 ) - R13 ) by RLVECT_1:def 3
.= ( R10 + ( R13 - R13 ) ) by RLVECT_1:def 3
.= ( R10 + ( 0. R6 ) ) by VECTSP_1:19
.= R10 by RLVECT_1:4;
end;
theorem
L603: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (( R13 + R16 ) = ( R10 + R16 ) implies (ex R14 being (Element of R6) st (R14 in R16 & ( R13 - R14 ) = R10))))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
assume L604: ( R13 + R16 ) = ( R10 + R16 );
L605: R10 in ( R13 + R16 ) by L604 , L418;
consider R11 being (Element of R6) such that L606: R10 = ( R13 + R11 ) and L607: R11 in R16 by L605;
take D112 = ( R13 - R10 );
L608: ( 0. R6 ) = ( ( R13 + R11 ) - R10 ) by L606 , VECTSP_1:19
.= ( R11 + ( R13 - R10 ) ) by RLVECT_1:def 3;
L609: D112 = ( - R11 ) by L608 , VECTSP_1:16;
thus L610: D112 in R16 by L609 , L607 , L134;
thus L611: ( R13 - D112 ) = ( ( R13 - R13 ) + R10 ) by RLVECT_1:29
.= ( ( 0. R6 ) + R10 ) by VECTSP_1:19
.= R10 by RLVECT_1:4;
end;
theorem
L612: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R13 being (Element of R6) holds (for B91 , B92 being  strict (Subspace of R6) holds (( R13 + B91 ) = ( R13 + B92 ) iff B91 = B92)))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R13 being (Element of R6);
let C168 , C169 being  strict (Subspace of R6);
thus L613: (( R13 + C168 ) = ( R13 + C169 ) implies C168 = C169)
proof
assume L614: ( R13 + C168 ) = ( R13 + C169 );
L615: (the carrier of C168) = (the carrier of C169)
proof
L616: (the carrier of C168) c= (the carrier of R6) by L70;
thus L617: (the carrier of C168) c= (the carrier of C169)
proof
let C170 being set;
assume L618: C170 in (the carrier of C168);
reconsider D113 = C170 as (Element of R6) by L618 , L616;
set D114 = ( R13 + D113 );
L619: C170 in C168 by L618 , STRUCT_0:def 5;
L620: D114 in ( R13 + C169 ) by L619 , L614;
consider R10 being (Element of R6) such that L621: D114 = ( R13 + R10 ) and L622: R10 in C169 by L620;
L623: D113 = R10 by L621 , RLVECT_1:8;
thus L624: thesis by L623 , L622 , STRUCT_0:def 5;
end;

let C171 being set;
assume L625: C171 in (the carrier of C169);
L626: (the carrier of C169) c= (the carrier of R6) by L70;
reconsider D115 = C171 as (Element of R6) by L626 , L625;
set D116 = ( R13 + D115 );
L627: C171 in C169 by L625 , STRUCT_0:def 5;
L628: D116 in ( R13 + C168 ) by L627 , L614;
consider R10 being (Element of R6) such that L629: D116 = ( R13 + R10 ) and L630: R10 in C168 by L628;
L631: D115 = R10 by L629 , RLVECT_1:8;
thus L632: thesis by L631 , L630 , STRUCT_0:def 5;
end;
thus L633: thesis by L615 , L216;
end;

thus L634: thesis;
end;
theorem
L635: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R13 being (Element of R6) holds (for B93 , B94 being  strict (Subspace of R6) holds (( R13 + B93 ) = ( R10 + B94 ) implies B93 = B94))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R13 being (Element of R6);
let C172 , C173 being  strict (Subspace of R6);
assume L636: ( R13 + C172 ) = ( R10 + C173 );
set D117 = (the carrier of C173);
set D118 = (the carrier of C172);
assume L637: C172 <> C173;
L638:
now
set D119 = the (Element of ( D118 \ D117 ));
assume L639: ( D118 \ D117 ) <> ( {} );
L640: D119 in D118 by L639 , XBOOLE_0:def 5;
L641: D119 in C172 by L640 , STRUCT_0:def 5;
L642: D119 in R6 by L641 , L78;
reconsider D120 = D119 as (Element of R6) by L642 , STRUCT_0:def 5;
set D121 = ( R13 + D120 );
L643: D121 in ( R10 + C173 ) by L636 , L641;
consider R11 being (Element of R6) such that L644: D121 = ( R10 + R11 ) and L645: R11 in C173 by L643;
L646: D120 = ( ( 0. R6 ) + D120 ) by RLVECT_1:4
.= ( ( R13 + ( - R13 ) ) + D120 ) by VECTSP_1:19
.= ( ( - R13 ) + ( R10 + R11 ) ) by L644 , RLVECT_1:def 3;
L647: ( ( R13 + ( ( - R13 ) + ( R10 + R11 ) ) ) + C172 ) = ( R13 + C172 ) by L646 , L641 , L483;
L648: ( R13 + ( ( - R13 ) + ( R10 + R11 ) ) ) = ( ( R13 + ( - R13 ) ) + ( R10 + R11 ) ) by RLVECT_1:def 3
.= ( ( 0. R6 ) + ( R10 + R11 ) ) by VECTSP_1:19
.= ( R10 + R11 ) by RLVECT_1:4;
L649: ( ( R10 + R11 ) + C173 ) = ( ( R10 + R11 ) + C172 ) by L648 , L636 , L645 , L647 , L483;
thus L650: thesis by L649 , L637 , L612;
end;
L651:
now
set D122 = the (Element of ( D117 \ D118 ));
assume L652: ( D117 \ D118 ) <> ( {} );
L653: D122 in D117 by L652 , XBOOLE_0:def 5;
L654: D122 in C173 by L653 , STRUCT_0:def 5;
L655: D122 in R6 by L654 , L78;
reconsider D123 = D122 as (Element of R6) by L655 , STRUCT_0:def 5;
set D124 = ( R10 + D123 );
L656: D124 in ( R13 + C172 ) by L636 , L654;
consider R11 being (Element of R6) such that L657: D124 = ( R13 + R11 ) and L658: R11 in C172 by L656;
L659: D123 = ( ( 0. R6 ) + D123 ) by RLVECT_1:4
.= ( ( R10 + ( - R10 ) ) + D123 ) by VECTSP_1:19
.= ( ( - R10 ) + ( R13 + R11 ) ) by L657 , RLVECT_1:def 3;
L660: ( ( R10 + ( ( - R10 ) + ( R13 + R11 ) ) ) + C173 ) = ( R10 + C173 ) by L659 , L654 , L483;
L661: ( R10 + ( ( - R10 ) + ( R13 + R11 ) ) ) = ( ( R10 + ( - R10 ) ) + ( R13 + R11 ) ) by RLVECT_1:def 3
.= ( ( 0. R6 ) + ( R13 + R11 ) ) by VECTSP_1:19
.= ( R13 + R11 ) by RLVECT_1:4;
L662: ( ( R13 + R11 ) + C172 ) = ( ( R13 + R11 ) + C173 ) by L661 , L636 , L658 , L660 , L483;
thus L663: thesis by L662 , L637 , L612;
end;
L664: D118 <> D117 by L637 , L216;
L665: ((not D118 c= D117) or (not D117 c= D118)) by L664 , XBOOLE_0:def 10;
thus L666: thesis by L665 , L638 , L651 , XBOOLE_1:37;
end;
theorem
L667: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (ex R24 being (Coset of R16) st R13 in R24)))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R13 being (Element of R6);
let R16 being (Subspace of R6);
reconsider D125 = ( R13 + R16 ) as (Coset of R16) by L397;
take D125;
thus L668: thesis by L418;
end;
theorem
L669: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R16 being (Subspace of R6) holds (for R24 being (Coset of R16) holds (R24 is  linearly-closed iff R24 = (the carrier of R16))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R16 being (Subspace of R6);
let R24 being (Coset of R16);
thus L670: (R24 is  linearly-closed implies R24 = (the carrier of R16))
proof
assume L671: R24 is  linearly-closed;
consider R13 being (Element of R6) such that L672: R24 = ( R13 + R16 ) by L397;
L673: R24 <> ( {} ) by L672 , L418;
L674: ( 0. R6 ) in ( R13 + R16 ) by L673 , L671 , L672 , L5;
thus L675: thesis by L674 , L672 , L460;
end;

thus L676: thesis by L106;
end;
theorem
L677: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for B95 , B96 being  strict (Subspace of R6) holds (for B97 being (Coset of B95) holds (for B98 being (Coset of B96) holds (B97 = B98 implies B95 = B96))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let C174 , C175 being  strict (Subspace of R6);
let C176 being (Coset of C174);
let C177 being (Coset of C175);
L678: ((ex R14 being (Element of R6) st C176 = ( R14 + C174 )) & (ex R15 being (Element of R6) st C177 = ( R15 + C175 ))) by L397;
thus L679: thesis by L678 , L635;
end;
theorem
L680: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R13 being (Element of R6) holds { R13 } is (Coset of ( (0). R6 )))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R13 being (Element of R6);
L681: ( R13 + ( (0). R6 ) ) = { R13 } by L422;
thus L682: thesis by L681 , L397;
end;
theorem
L683: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R19 being (Subset of R6) holds (R19 is (Coset of ( (0). R6 )) implies (ex R13 being (Element of R6) st R19 = { R13 })))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R19 being (Subset of R6);
assume L684: R19 is (Coset of ( (0). R6 ));
consider R13 being (Element of R6) such that L685: R19 = ( R13 + ( (0). R6 ) ) by L684 , L397;
take R13;
thus L686: thesis by L685 , L422;
end;
theorem
L687: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R16 being (Subspace of R6) holds (the carrier of R16) is (Coset of R16))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R16 being (Subspace of R6);
L688: (the carrier of R16) = ( ( 0. R6 ) + R16 ) by L383;
thus L689: thesis by L688 , L397;
end;
theorem
L690: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (the carrier of R6) is (Coset of ( (Omega). R6 ))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
set D126 = the (Element of R6);
L691: (the carrier of R6) c= (the carrier of R6);
reconsider D127 = (the carrier of R6) as (Subset of R6) by L691;
L692: D127 = ( D126 + ( (Omega). R6 ) ) by L457;
thus L693: thesis by L692 , L397;
end;
theorem
L694: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R19 being (Subset of R6) holds (R19 is (Coset of ( (Omega). R6 )) implies R19 = (the carrier of R6)))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R19 being (Subset of R6);
assume L695: R19 is (Coset of ( (Omega). R6 ));
L696: (ex R13 being (Element of R6) st R19 = ( R13 + ( (Omega). R6 ) )) by L695 , L397;
thus L697: thesis by L696 , L457;
end;
theorem
L698: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R16 being (Subspace of R6) holds (for R24 being (Coset of R16) holds (( 0. R6 ) in R24 iff R24 = (the carrier of R16))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R16 being (Subspace of R6);
let R24 being (Coset of R16);
L699: (ex R13 being (Element of R6) st R24 = ( R13 + R16 )) by L397;
thus L700: thesis by L699 , L460;
end;
theorem
L701: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R16 being (Subspace of R6) holds (for R24 being (Coset of R16) holds (R10 in R24 iff R24 = ( R10 + R16 )))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R16 being (Subspace of R6);
let R24 being (Coset of R16);
thus L702: (R10 in R24 implies R24 = ( R10 + R16 ))
proof
assume L703: R10 in R24;
L704: (ex R13 being (Element of R6) st R24 = ( R13 + R16 )) by L397;
thus L705: thesis by L704 , L703 , L515;
end;

thus L706: thesis by L418;
end;
theorem
L707: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (for R24 being (Coset of R16) holds ((R10 in R24 & R13 in R24) implies (ex R14 being (Element of R6) st (R14 in R16 & ( R10 + R14 ) = R13)))))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
let R24 being (Coset of R16);
assume L708: (R10 in R24 & R13 in R24);
L709: (R24 = ( R10 + R16 ) & R24 = ( R13 + R16 )) by L708 , L701;
thus L710: thesis by L709 , L594;
end;
theorem
L711: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R13 being (Element of R6) holds (for R16 being (Subspace of R6) holds (for R24 being (Coset of R16) holds ((R10 in R24 & R13 in R24) implies (ex R14 being (Element of R6) st (R14 in R16 & ( R10 - R14 ) = R13)))))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R13 being (Element of R6);
let R16 being (Subspace of R6);
let R24 being (Coset of R16);
assume L712: (R10 in R24 & R13 in R24);
L713: (R24 = ( R10 + R16 ) & R24 = ( R13 + R16 )) by L712 , L701;
thus L714: thesis by L713 , L603;
end;
theorem
L715: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R14 being (Element of R6) holds (for R15 being (Element of R6) holds (for R16 being (Subspace of R6) holds ((ex R24 being (Coset of R16) st (R14 in R24 & R15 in R24)) iff ( R14 - R15 ) in R16))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R14 being (Element of R6);
let R15 being (Element of R6);
let R16 being (Subspace of R6);
thus L716: ((ex R24 being (Coset of R16) st (R14 in R24 & R15 in R24)) implies ( R14 - R15 ) in R16)
proof
given R24 being (Coset of R16) such that
L717: (R14 in R24 & R15 in R24);

L718: (ex R13 being (Element of R6) st R24 = ( R13 + R16 )) by L397;
thus L719: thesis by L718 , L717 , L579;
end;

assume L720: ( R14 - R15 ) in R16;
consider R13 being (Element of R6) such that L721: (R14 in ( R13 + R16 ) & R15 in ( R13 + R16 )) by L720 , L579;
reconsider D128 = ( R13 + R16 ) as (Coset of R16) by L397;
take D128;
thus L722: thesis by L721;
end;
theorem
L723: (for R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5 holds (for R10 being (Element of R6) holds (for R16 being (Subspace of R6) holds (for R23 being (Coset of R16) holds (for R24 being (Coset of R16) holds ((R10 in R23 & R10 in R24) implies R23 = R24)))))))
proof
let R5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R6 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R5;
let R10 being (Element of R6);
let R16 being (Subspace of R6);
let R23 being (Coset of R16);
let R24 being (Coset of R16);
assume L724: (R10 in R23 & R10 in R24);
L725: ((ex R14 being (Element of R6) st R23 = ( R14 + R16 )) & (ex R15 being (Element of R6) st R24 = ( R15 + R16 ))) by L397;
thus L726: thesis by L725 , L724 , L533;
end;
theorem
L727: (for B99 being  add-associative  right_zeroed  right_complementable  Abelian  commutative  associative  well-unital  distributive non  empty doubleLoopStr holds (for B100 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B99 holds (for B101 , B102 being (Element of B99) holds (for B103 being (Element of B100) holds ( ( B101 - B102 ) * B103 ) = ( ( B101 * B103 ) - ( B102 * B103 ) ))))) by L1;
