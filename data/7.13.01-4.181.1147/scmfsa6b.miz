:: On the compositions of macro instructions, Part II
::  by Noriko Asamoto , Yatsuka Nakamura , Piotr Rudnicki and Andrzej Trybulec
::
:: Received July 22, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMFSA_2, FSM_1, CARD_1, TARSKI,
      SCMFSA6A, FUNCT_4, RELAT_1, XBOOLE_0, FUNCT_1, INT_1, MSUALG_1, CIRCUIT2,
      AMI_3, ARYTM_3, XXREAL_0, NAT_1, SF_MASTR, GRAPHSP, AMISTD_2, TURING_1,
      STRUCT_0, VALUED_1, FUNCOP_1, SCMFSA6B, PARTFUN1, EXTPRO_1, RELOC,
      SCMFSA6C, COMPOS_1, GOBRD13, MEMSTR_0, SCMPDS_4;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, CARD_1, NUMBERS, XCMPLX_0,
      XXREAL_0, ORDINAL1, NAT_1, FUNCT_7, INT_1, RELAT_1, FUNCT_1, PARTFUN1,
      PBOOLE, FINSEQ_1, FUNCOP_1, FUNCT_4, VALUED_1, STRUCT_0, MEMSTR_0,
      COMPOS_0, COMPOS_1, EXTPRO_1, SCMFSA_2, AMISTD_1, AMISTD_2, SCMFSA6A,
      SF_MASTR, SCMFSA_M;
 constructors XXREAL_0, SCMFSA6A, SF_MASTR, AMISTD_1, AMISTD_2, MEMSTR_0,
      RELSET_1, PRE_POLY, AMISTD_5, DOMAIN_1, PBOOLE, AMI_3, FUNCT_7,
      SCMFSA_1, SCMFSA_M;
 registrations SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, SCMFSA_2, SCMFSA6A, SF_MASTR, XBOOLE_0,
      FINSET_1, AMISTD_2, SCMFSA10, COMPOS_1, EXTPRO_1, SCMFSA_4, PBOOLE,
      PRE_POLY, FUNCT_7, FUNCT_4, STRUCT_0, MEMSTR_0, FINSEQ_1, AMI_3,
      COMPOS_0, SCMFSA_M;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions AMISTD_2, FUNCOP_1, SCMFSA6A, COMPOS_1, EXTPRO_1, MEMSTR_0,
      AMISTD_1, SCMFSA_2,
      COMPOS_0, SCMFSA_M;
 theorems RELAT_1, FUNCT_7, FUNCT_4, FUNCT_1, SCMFSA_3, INT_1, FUNCOP_1,
      TARSKI, NAT_1, SCMFSA_2, MEMSTR_0, GRFUNC_1, SCMFSA6A, SF_MASTR,
      XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, XXREAL_0, VALUED_1, PBOOLE,
      PARTFUN1, AFINSQ_1, FINSEQ_4, COMPOS_1, EXTPRO_1, AMISTD_2, AMISTD_5,
      AMISTD_1, STRUCT_0, AMI_2,
      COMPOS_0, SCMFSA_M;
 schemes NAT_1;

begin
set D1 = ( Start-At (( 0 ) , ( SCM+FSA )) );
definition
let C1 being (Program of ( SCM+FSA ));
let C2 being (State of ( SCM+FSA ));
let C3 being (Instruction-Sequence of ( SCM+FSA ));
func IExec (C1 , C3 , C2) -> (State of ( SCM+FSA )) equals 
( Result (( C3 +* C1 ) , ( Initialized C2 )) );
coherence;
end;
definition
let C4 being (Program of ( SCM+FSA ));
canceled 2;
attr C4 is  keeping_0
means
:L2: (for B1 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B2 being (Instruction-Sequence of ( SCM+FSA )) holds (C4 c= B2 implies (for B3 being (Element of ( NAT )) holds ( ( Comput (B2 , B1 , B3) ) . ( intloc ( 0 ) ) ) = ( B1 . ( intloc ( 0 ) ) )))));
end;
registration
cluster  parahalting  keeping_0 for (Program of ( SCM+FSA ));
existence
proof
take ( Macro ( halt ( SCM+FSA ) ) );
thus L4: ( Macro ( halt ( SCM+FSA ) ) ) is  parahalting
proof
let C5 being ( 0 ) -started (State of ( SCM+FSA ));
set D2 = ( Macro ( halt ( SCM+FSA ) ) );
L5: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C5 by MEMSTR_0:29;
let C6 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L6: D2 c= C6;
L7: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L8: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L7 , TARSKI:def 1;
take ( 0 );
L9: ( dom D2 ) = { ( 0 ) , 1 } by COMPOS_1:61;
L10: ( 0 ) in ( dom D2 ) by L9 , TARSKI:def 2;
L11: ( dom C6 ) = ( NAT ) by PARTFUN1:def 2;
thus L12: ( IC ( Comput (C6 , C5 , ( 0 )) ) ) in ( dom C6 ) by L11;
L13: ( dom C6 ) = ( NAT ) by PARTFUN1:def 2;
L14: ( CurInstr (C6 , ( Comput (C6 , C5 , ( 0 )) )) ) = ( C6 . ( IC C5 ) ) by L13 , PARTFUN1:def 6
.= ( C6 . ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) ) by L5 , L8 , GRFUNC_1:2
.= ( C6 . ( 0 ) ) by FUNCOP_1:72
.= ( D2 . ( 0 ) ) by L6 , L10 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by COMPOS_1:58;
thus L15: ( CurInstr (C6 , ( Comput (C6 , C5 , ( 0 )) )) ) = ( halt ( SCM+FSA ) ) by L14;
end;

set D3 = ( Macro ( halt ( SCM+FSA ) ) );
L16: ( dom D3 ) = { ( 0 ) , 1 } by COMPOS_1:61;
L17: ( 0 ) in ( dom D3 ) by L16 , TARSKI:def 2;
let C7 being ( 0 ) -started (State of ( SCM+FSA ));
L18: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C7 by MEMSTR_0:29;
let R13 being (Instruction-Sequence of ( SCM+FSA ));
assume L19: D3 c= R13;
let C8 being (Element of ( NAT ));
L20: C7 = ( Comput (R13 , C7 , ( 0 )) );
L21: ( dom R13 ) = ( NAT ) by PARTFUN1:def 2;
L22: ( R13 /. ( IC C7 ) ) = ( R13 . ( IC C7 ) ) by L21 , PARTFUN1:def 6;
L23: ( CurInstr (R13 , C7) ) = ( R13 . ( 0 ) ) by L18 , L22 , MEMSTR_0:39
.= ( D3 . ( 0 ) ) by L17 , L19 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by COMPOS_1:58;
thus L24: ( ( Comput (R13 , C7 , C8) ) . ( intloc ( 0 ) ) ) = ( C7 . ( intloc ( 0 ) ) ) by L23 , L20 , EXTPRO_1:5;
end;
end;
theorem
L26: (for B4 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B5 being  parahalting (Program of ( SCM+FSA )) holds (for B6 being (Instruction-Sequence of ( SCM+FSA )) holds (B5 c= B6 implies B6 halts_on B4)))) by AMISTD_1:def 11;
theorem
L27: (for B7 being (State of ( SCM+FSA )) holds (for B8 being  parahalting (Program of ( SCM+FSA )) holds (( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= B7 implies (for B9 being (Instruction-Sequence of ( SCM+FSA )) holds (B8 c= B9 implies B9 halts_on B7)))))
proof
let C9 being (State of ( SCM+FSA ));
let C10 being  parahalting (Program of ( SCM+FSA ));
L28: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCT_4:25;
assume L29: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= C9;
let C11 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L30: C10 c= C11;
L31: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C9 by L29 , L28 , XBOOLE_1:1;
L32: C9 is ( 0 ) -started by L31 , MEMSTR_0:29;
thus L33: thesis by L32 , L30 , AMISTD_1:def 11;
end;
L34: (for R10 being (State of ( SCM+FSA )) holds (for B10 being (Instruction-Sequence of ( SCM+FSA )) holds (not ( B10 +* (( IC R10 ) , ( goto ( IC R10 ) )) ) halts_on R10)))
proof
let R10 being (State of ( SCM+FSA ));
let C12 being (Instruction-Sequence of ( SCM+FSA ));
set D4 = ( C12 +* (( IC R10 ) , ( goto ( IC R10 ) )) );
defpred S1[ Nat ] means ( IC ( Comput (D4 , R10 , $1) ) ) = ( IC R10 );
L35: ( dom C12 ) = ( NAT ) by PARTFUN1:def 2;
L36: ( dom C12 ) = ( dom D4 ) by FUNCT_7:30;
L37:
now
let R2 being (Element of ( NAT ));
assume L38: S1[ R2 ];
L39: ( CurInstr (D4 , ( Comput (D4 , R10 , R2) )) ) = ( D4 . ( IC R10 ) ) by L38 , L36 , L35 , PARTFUN1:def 6
.= ( goto ( IC R10 ) ) by L35 , FUNCT_7:31;
L40: ( IC ( Comput (D4 , R10 , ( R2 + 1 )) ) ) = ( IC ( Following (D4 , ( Comput (D4 , R10 , R2) )) ) ) by EXTPRO_1:3
.= ( IC R10 ) by L39 , SCMFSA_2:69;
thus L41: S1[ ( R2 + 1 ) ] by L40;
end;
let C13 being Nat;
L42: S1[ ( 0 ) ];
assume L43: ( IC ( Comput (D4 , R10 , C13) ) ) in ( dom D4 );
reconsider D5 = C13 as (Element of ( NAT )) by ORDINAL1:def 12;
L44: (for R2 being (Element of ( NAT )) holds S1[ R2 ]) from NAT_1:sch 1(L42 , L37);
L45: ( CurInstr (D4 , ( Comput (D4 , R10 , D5) )) ) = ( D4 . ( IC ( Comput (D4 , R10 , D5) ) ) ) by L43 , PARTFUN1:def 6
.= ( D4 . ( IC R10 ) ) by L44
.= ( goto ( IC R10 ) ) by L35 , FUNCT_7:31;
thus L46: thesis by L45;
end;
registration
cluster  parahalting ->  paraclosed for (Program of ( SCM+FSA ));
coherence
proof
let C14 being (Program of ( SCM+FSA ));
assume L47: C14 is  parahalting;
let C15 being ( 0 ) -started (State of ( SCM+FSA ));
let C16 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L48: C14 c= C16;
let C17 being (Element of ( NAT ));
defpred S2[ Nat ] means (not ( IC ( Comput (C16 , C15 , $1) ) ) in ( dom C14 ));
assume L49: (not ( IC ( Comput (C16 , C15 , C17) ) ) in ( dom C14 ));
L50: (ex B11 being Nat st S2[ B11 ]) by L49;
consider C18 being Nat such that L51: S2[ C18 ] and L52: (for B12 being Nat holds (S2[ B12 ] implies C18 <= B12)) from NAT_1:sch 5(L50);
reconsider D6 = C18 as (Element of ( NAT )) by ORDINAL1:def 12;
L53: (for R1 being (Element of ( NAT )) holds (R1 < D6 implies ( IC ( Comput (C16 , C15 , R1) ) ) in ( dom C14 ))) by L52;
set D7 = ( Comput (C16 , C15 , D6) );
set D8 = C15;
set D9 = D7;
set D10 = ( C16 +* (( IC D7 ) , ( goto ( IC D7 ) )) );
L54: C14 c= D10 by L51 , L48 , FUNCT_7:89;
L55: ( Comput (D10 , D8 , D6) ) = D7 by L54 , L53 , L48 , AMISTD_2:10;
L56: (not D10 halts_on ( Comput (D10 , D8 , D6) )) by L55 , L34;
L57: D10 halts_on C15 by L54 , L47 , AMISTD_1:def 11;
thus L58: contradiction by L57 , L56 , EXTPRO_1:22;
end;
cluster  keeping_0 ->  paraclosed for (Program of ( SCM+FSA ));
coherence
proof
let C19 being (Program of ( SCM+FSA ));
assume L59: C19 is  keeping_0;
set D11 = ( FirstNotUsed C19 );
let C20 being ( 0 ) -started (State of ( SCM+FSA ));
let C21 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L60: C19 c= C21;
let C22 being (Element of ( NAT ));
L61: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C20 by MEMSTR_0:29;
defpred S3[ Nat ] means (not ( IC ( Comput (C21 , C20 , $1) ) ) in ( dom C19 ));
assume L62: (not ( IC ( Comput (C21 , C20 , C22) ) ) in ( dom C19 ));
L63: (ex B13 being Nat st S3[ B13 ]) by L62;
consider C23 being Nat such that L64: S3[ C23 ] and L65: (for B14 being Nat holds (S3[ B14 ] implies C23 <= B14)) from NAT_1:sch 5(L63);
reconsider D12 = C23 as (Element of ( NAT )) by ORDINAL1:def 12;
set D13 = ( Comput (C21 , C20 , D12) );
set D14 = C20;
reconsider D15 = ( C20 +* (D11 , ( ( C20 . ( intloc ( 0 ) ) ) + 1 )) ) as (State of ( SCM+FSA ));
set D16 = ( C21 +* (( IC D13 ) , ( ( intloc ( 0 ) ) := D11 )) );
L66: ( dom D16 ) = ( NAT ) by PARTFUN1:def 2;
L67: (not C19 is  keeping_0)
proof
L68: (not D11 in ( UsedInt*Loc C19 ))
proof
assume L69: (not thesis);
L70: D11 in ( FinSeq-Locations ) by L69;
L71: D11 is FinSeq-Location by L70 , SCMFSA_2:def 5;
thus L72: contradiction by L71 , SCMFSA_2:58;
end;
L73: ( D15 | ( UsedInt*Loc C19 ) ) = ( C20 | ( UsedInt*Loc C19 ) ) by L68 , FUNCT_7:92;
L74: ( C20 . ( intloc ( 0 ) ) ) < ( ( C20 . ( intloc ( 0 ) ) ) + 1 ) by XREAL_1:29;
L75: ( dom C21 ) = ( NAT ) by PARTFUN1:def 2;
L76: ( D16 . ( IC D13 ) ) = ( ( intloc ( 0 ) ) := D11 ) by L75 , FUNCT_7:31;
L77: ( D15 . ( intloc ( 0 ) ) ) = ( C20 . ( intloc ( 0 ) ) ) by FUNCT_7:32;
L78: D11 in ( dom D14 ) by SCMFSA_2:42;
L79: ( D15 . D11 ) = ( ( C20 . ( intloc ( 0 ) ) ) + 1 ) by L78 , FUNCT_7:31;
set D17 = ( Comput (D16 , D15 , D12) );
L80: D11 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L81: (not D11 in { ( IC ( SCM+FSA ) ) }) by L80 , TARSKI:def 1;
L82: (not D11 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L81 , FUNCOP_1:13;
L83: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= D15 by L82 , L61 , FUNCT_7:89;
reconsider D18 = D15 as ( 0 ) -started (State of ( SCM+FSA )) by L83 , MEMSTR_0:29;
take D18;
L84: C19 c= D16 by L60 , L64 , FUNCT_7:138;
take D16;
thus L85: C19 c= D16 by L60 , L64 , FUNCT_7:138;
take D19 = ( D12 + 1 );
L86: ( D18 | ( UsedIntLoc C19 ) ) = ( C20 | ( UsedIntLoc C19 ) ) by FUNCT_7:92 , SF_MASTR:50;
L87: (for R1 being (Element of ( NAT )) holds (R1 < D12 implies ( IC ( Comput (C21 , C20 , R1) ) ) in ( dom C19 ))) by L65;
L88: ((not D11 in ( UsedIntLoc C19 )) & (for R1 being (Element of ( NAT )) holds (R1 < D12 implies ( IC ( Comput (D16 , D18 , R1) ) ) in ( dom C19 )))) by L87 , L86 , L73 , L60 , L84 , L61 , L83 , SF_MASTR:50 , SF_MASTR:65;
L89: ( D17 . D11 ) = ( ( C20 . ( intloc ( 0 ) ) ) + 1 ) by L79 , L88 , L84 , SF_MASTR:61;
L90: ( Comput (D16 , D18 , D19) ) = ( Following (D16 , D17) ) by EXTPRO_1:3
.= ( Exec (( D16 . ( IC D17 ) ) , D17) ) by L66 , PARTFUN1:def 6
.= ( Exec (( ( intloc ( 0 ) ) := D11 ) , D17) ) by L86 , L73 , L60 , L84 , L87 , L76 , L61 , L83 , SF_MASTR:65;
thus L91: thesis by L90 , L89 , L77 , L74 , SCMFSA_2:63;
end;
thus L92: contradiction by L67 , L59;
end;
end;
theorem
L94: (for R10 being (State of ( SCM+FSA )) holds (for R13 being (Instruction-Sequence of ( SCM+FSA )) holds (for B15 being  parahalting (Program of ( SCM+FSA )) holds (for B16 being  read-write Int-Location holds ((not B16 in ( UsedIntLoc B15 )) implies ( ( IExec (B15 , R13 , R10) ) . B16 ) = ( R10 . B16 ))))))
proof
let R10 being (State of ( SCM+FSA ));
let R13 being (Instruction-Sequence of ( SCM+FSA ));
let C24 being  parahalting (Program of ( SCM+FSA ));
let C25 being  read-write Int-Location;
assume L95: (not C25 in ( UsedIntLoc C24 ));
L96: C24 c= ( R13 +* C24 ) by FUNCT_4:25;
L97: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by FUNCT_4:25;
L98: ( R13 +* C24 ) halts_on ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L97 , L27 , L96;
consider R2 being (Element of ( NAT )) such that L99: ( Result (( R13 +* C24 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) = ( Comput (( R13 +* C24 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) , R2) ) and L100: ( CurInstr (( R13 +* C24 ) , ( Result (( R13 +* C24 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) )) ) = ( halt ( SCM+FSA ) ) by L98 , EXTPRO_1:def 9;
L101: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) \/ ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) ) by FUNCT_4:def 1;
L102: (not C25 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L103: (not C25 in { ( intloc ( 0 ) ) }) by TARSKI:def 1;
L104: (not C25 in ( dom ( ( intloc ( 0 ) ) .--> 1 ) )) by L103 , FUNCOP_1:13;
L105: (not C25 in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) by L104 , L101 , L102 , XBOOLE_0:def 3;
L106: (for R1 being (Element of ( NAT )) holds (R1 < R2 implies ( IC ( Comput (( R13 +* C24 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) , R1) ) ) in ( dom C24 ))) by L96 , AMISTD_1:def 10;
thus L107: ( ( IExec (C24 , R13 , R10) ) . C25 ) = ( ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) . C25 ) by L106 , L95 , L99 , FUNCT_4:25 , SF_MASTR:61
.= ( R10 . C25 ) by L105 , FUNCT_4:11;
end;
theorem
L108: (for R7 being FinSeq-Location holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being (Instruction-Sequence of ( SCM+FSA )) holds (for B17 being  parahalting (Program of ( SCM+FSA )) holds ((not R7 in ( UsedInt*Loc B17 )) implies ( ( IExec (B17 , R13 , R10) ) . R7 ) = ( R10 . R7 ))))))
proof
let R7 being FinSeq-Location;
let R10 being (State of ( SCM+FSA ));
let R13 being (Instruction-Sequence of ( SCM+FSA ));
let C26 being  parahalting (Program of ( SCM+FSA ));
assume L109: (not R7 in ( UsedInt*Loc C26 ));
L110: C26 c= ( R13 +* C26 ) by FUNCT_4:25;
L111: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by FUNCT_4:25;
L112: ( R13 +* C26 ) halts_on ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L111 , L27 , L110;
consider R2 being (Element of ( NAT )) such that L113: ( Result (( R13 +* C26 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) = ( Comput (( R13 +* C26 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) , R2) ) and L114: ( CurInstr (( R13 +* C26 ) , ( Result (( R13 +* C26 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) )) ) = ( halt ( SCM+FSA ) ) by L112 , EXTPRO_1:def 9;
L115: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) \/ ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) ) by FUNCT_4:def 1;
L116: (not R7 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:103;
L117: R7 <> ( intloc ( 0 ) ) by SCMFSA_2:58;
L118: (not R7 in { ( intloc ( 0 ) ) }) by L117 , TARSKI:def 1;
L119: (not R7 in ( dom ( ( intloc ( 0 ) ) .--> 1 ) )) by L118 , FUNCOP_1:13;
L120: (not R7 in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) by L119 , L115 , L116 , XBOOLE_0:def 3;
L121: (for R1 being (Element of ( NAT )) holds (R1 < R2 implies ( IC ( Comput (( R13 +* C26 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) , R1) ) ) in ( dom C26 ))) by L110 , AMISTD_1:def 10;
thus L122: ( ( IExec (C26 , R13 , R10) ) . R7 ) = ( ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) . R7 ) by L121 , L109 , L113 , FUNCT_4:25 , SF_MASTR:63
.= ( R10 . R7 ) by L120 , FUNCT_4:11;
end;
theorem
L123: (for R8 being (Element of ( NAT )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being (Instruction-Sequence of ( SCM+FSA )) holds ((( IC R10 ) = R8 & ( R13 . R8 ) = ( goto R8 )) implies (not R13 halts_on R10)))))
proof
let R8 being (Element of ( NAT ));
let R10 being (State of ( SCM+FSA ));
let R13 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L124: ( IC R10 ) = R8
and
L125: ( R13 . R8 ) = ( goto R8 );
L126: ( R13 /. ( IC R10 ) ) = ( R13 . ( IC R10 ) ) by PBOOLE:143;
defpred S4[ Nat ] means ( Comput (R13 , R10 , $1) ) = R10;
L127: (for R1 being (Element of ( NAT )) holds (S4[ R1 ] implies S4[ ( R1 + 1 ) ]))
proof
let R1 being (Element of ( NAT ));
L128: (for B18 being FinSeq-Location holds ( ( Exec (( goto R8 ) , R10) ) . B18 ) = ( R10 . B18 )) by SCMFSA_2:69;
L129: (( IC ( Exec (( goto R8 ) , R10) ) ) = ( IC R10 ) & (for B19 being Int-Location holds ( ( Exec (( goto R8 ) , R10) ) . B19 ) = ( R10 . B19 ))) by L124 , SCMFSA_2:69;
assume L130: ( Comput (R13 , R10 , R1) ) = R10;
thus L131: ( Comput (R13 , R10 , ( R1 + 1 )) ) = ( Following (R13 , R10) ) by L130 , EXTPRO_1:3
.= R10 by L124 , L125 , L129 , L128 , L126 , SCMFSA_2:104;
end;
let C27 being Nat;
reconsider D20 = C27 as (Element of ( NAT )) by ORDINAL1:def 12;
L132: S4[ ( 0 ) ];
L133: (for R1 being (Element of ( NAT )) holds S4[ R1 ]) from NAT_1:sch 1(L132 , L127);
L134: S4[ D20 ] by L133;
assume L135: ( IC ( Comput (R13 , R10 , C27) ) ) in ( dom R13 );
thus L136: ( CurInstr (R13 , ( Comput (R13 , R10 , C27) )) ) <> ( halt ( SCM+FSA ) ) by L124 , L125 , L134 , PBOOLE:143;
end;
registration
cluster  parahalting -> non  empty for (Program of ( SCM+FSA ));
coherence;
end;
theorem
L138: (for R12 being (State of ( SCM+FSA )) holds (for B20 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B21 , B22 being (Instruction-Sequence of ( SCM+FSA )) holds (for B23 being  parahalting (Program of ( SCM+FSA )) holds (B23 c= B21 implies (for B24 being (Element of ( NAT )) holds ((( Reloc (B23 , B24) ) c= B22 & ( IC R12 ) = B24 & ( DataPart B20 ) = ( DataPart R12 )) implies (for B25 being (Element of ( NAT )) holds (( ( IC ( Comput (B21 , B20 , B25) ) ) + B24 ) = ( IC ( Comput (B22 , R12 , B25) ) ) & ( IncAddr (( CurInstr (B21 , ( Comput (B21 , B20 , B25) )) ) , B24) ) = ( CurInstr (B22 , ( Comput (B22 , R12 , B25) )) ) & ( DataPart ( Comput (B21 , B20 , B25) ) ) = ( DataPart ( Comput (B22 , R12 , B25) ) ))))))))))
proof
let R12 being (State of ( SCM+FSA ));
let C28 being ( 0 ) -started (State of ( SCM+FSA ));
let C29 , C30 being (Instruction-Sequence of ( SCM+FSA ));
let C31 being  parahalting (Program of ( SCM+FSA ));
L139: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C28 by MEMSTR_0:29;
assume that
L140: C31 c= C29;
set D21 = ( Start-At (( 0 ) , ( SCM+FSA )) );
L141: ( 0 ) in ( dom C31 ) by AFINSQ_1:65;
L142: ( IC ( SCM+FSA ) ) in ( dom D21 ) by MEMSTR_0:15;
L143: ( C29 . ( IC C28 ) ) = ( C29 . ( IC D21 ) ) by L142 , L139 , GRFUNC_1:2
.= ( C29 . ( 0 ) ) by FUNCOP_1:72
.= ( C31 . ( 0 ) ) by L141 , L140 , GRFUNC_1:2;
L144: ( IC ( Comput (C29 , C28 , ( 0 )) ) ) = ( IC C28 )
.= ( IC D21 ) by L139 , L142 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L145: ( 0 ) in ( dom C31 ) by AFINSQ_1:65;
let C32 being (Element of ( NAT ));
assume that
L146: ( Reloc (C31 , C32) ) c= C30
and
L147: ( IC R12 ) = C32
and
L148: ( DataPart C28 ) = ( DataPart R12 );
L149: ( DataPart ( Comput (C29 , C28 , ( 0 )) ) ) = ( DataPart R12 ) by L148
.= ( DataPart ( Comput (C30 , R12 , ( 0 )) ) );
defpred S5[ Nat ] means (( ( IC ( Comput (C29 , C28 , $1) ) ) + C32 ) = ( IC ( Comput (C30 , R12 , $1) ) ) & ( IncAddr (( CurInstr (C29 , ( Comput (C29 , C28 , $1) )) ) , C32) ) = ( CurInstr (C30 , ( Comput (C30 , R12 , $1) )) ) & ( DataPart ( Comput (C29 , C28 , $1) ) ) = ( DataPart ( Comput (C30 , R12 , $1) ) ));
L150: (for B26 being (Element of ( NAT )) holds (S5[ B26 ] implies S5[ ( B26 + 1 ) ]))
proof
let C33 being (Element of ( NAT ));
L151: ( Comput (C29 , C28 , ( C33 + 1 )) ) = ( Following (C29 , ( Comput (C29 , C28 , C33) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C29 , ( Comput (C29 , C28 , C33) )) ) , ( Comput (C29 , C28 , C33) )) );
reconsider D22 = ( IC ( Comput (C29 , C28 , ( C33 + 1 )) ) ) as (Element of ( NAT ));
reconsider D23 = ( CurInstr (C29 , ( Comput (C29 , C28 , ( C33 + 1 )) )) ) as (Instruction of ( SCM+FSA ));
L152: ( Comput (C30 , R12 , ( C33 + 1 )) ) = ( Following (C30 , ( Comput (C30 , R12 , C33) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C30 , ( Comput (C30 , R12 , C33) )) ) , ( Comput (C30 , R12 , C33) )) );
L153: ( IC ( Comput (C29 , C28 , ( C33 + 1 )) ) ) in ( dom C31 ) by L140 , AMISTD_1:def 10;
assume L154: S5[ C33 ];
thus L155: ( ( IC ( Comput (C29 , C28 , ( C33 + 1 )) ) ) + C32 ) = ( IC ( Comput (C30 , R12 , ( C33 + 1 )) ) ) by L154 , L151 , L152 , SCMFSA6A:8;
L156: ( IC ( Comput (C30 , R12 , ( C33 + 1 )) ) ) in ( dom ( Reloc (C31 , C32) ) ) by L155 , L153 , COMPOS_1:46;
L157: D22 in ( dom C31 ) by L140 , AMISTD_1:def 10;
L158: ( dom C29 ) = ( NAT ) by PARTFUN1:def 2;
L159: ( dom C30 ) = ( NAT ) by PARTFUN1:def 2;
L160: D23 = ( C29 . ( IC ( Comput (C29 , C28 , ( C33 + 1 )) ) ) ) by L158 , PARTFUN1:def 6
.= ( C31 . D22 ) by L153 , L140 , GRFUNC_1:2;
thus L161: ( IncAddr (( CurInstr (C29 , ( Comput (C29 , C28 , ( C33 + 1 )) )) ) , C32) ) = ( ( Reloc (C31 , C32) ) . ( D22 + C32 ) ) by L160 , L157 , COMPOS_1:35
.= ( ( Reloc (C31 , C32) ) . ( IC ( Comput (C30 , R12 , ( C33 + 1 )) ) ) ) by L154 , L151 , L152 , SCMFSA6A:8
.= ( C30 . ( IC ( Comput (C30 , R12 , ( C33 + 1 )) ) ) ) by L156 , L146 , GRFUNC_1:2
.= ( CurInstr (C30 , ( Comput (C30 , R12 , ( C33 + 1 )) )) ) by L159 , PARTFUN1:def 6;
thus L162: thesis by L154 , L151 , L152 , SCMFSA6A:8;
end;
let C34 being (Element of ( NAT ));
L163: ( 0 ) in ( dom C31 ) by AFINSQ_1:65;
L164: ( ( 0 ) + C32 ) in ( dom ( Reloc (C31 , C32) ) ) by L163 , COMPOS_1:46;
L165: ( dom C30 ) = ( NAT ) by PARTFUN1:def 2;
L166: ( dom C29 ) = ( NAT ) by PARTFUN1:def 2;
L167: ( IncAddr (( CurInstr (C29 , ( Comput (C29 , C28 , ( 0 )) )) ) , C32) ) = ( ( Reloc (C31 , C32) ) . ( ( 0 ) + C32 ) ) by L166 , L143 , L145 , COMPOS_1:35 , PARTFUN1:def 6
.= ( C30 . ( IC ( Comput (C30 , R12 , ( 0 )) ) ) ) by L147 , L164 , L146 , GRFUNC_1:2
.= ( CurInstr (C30 , ( Comput (C30 , R12 , ( 0 )) )) ) by L165 , PARTFUN1:def 6;
L168: S5[ ( 0 ) ] by L167 , L147 , L144 , L149;
L169: (for B27 being (Element of ( NAT )) holds S5[ B27 ]) from NAT_1:sch 1(L168 , L150);
thus L170: thesis by L169;
end;
theorem
L171: (for R14 being (Instruction-Sequence of ( SCM+FSA )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds (for B28 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B29 being  parahalting (Program of ( SCM+FSA )) holds ((B29 c= R14 & B29 c= R15) implies (for B30 being (Element of ( NAT )) holds (( Comput (R14 , B28 , B30) ) = ( Comput (R15 , B28 , B30) ) & ( CurInstr (R14 , ( Comput (R14 , B28 , B30) )) ) = ( CurInstr (R15 , ( Comput (R15 , B28 , B30) )) ))))))))
proof
let R14 being (Instruction-Sequence of ( SCM+FSA ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
let C35 being ( 0 ) -started (State of ( SCM+FSA ));
let C36 being  parahalting (Program of ( SCM+FSA ));
assume that
L172: C36 c= R14
and
L173: C36 c= R15;
thus L174:now
let C37 being (Element of ( NAT ));
L175: ( IC ( Comput (R14 , C35 , C37) ) ) in ( dom C36 ) by L172 , AMISTD_1:def 10;
L176: ( IC ( Comput (R15 , C35 , C37) ) ) in ( dom C36 ) by L173 , AMISTD_1:def 10;
L177: (for B31 being (Element of ( NAT )) holds (B31 < C37 implies ( IC ( Comput (R15 , C35 , B31) ) ) in ( dom C36 ))) by L173 , AMISTD_1:def 10;
thus L178: ( Comput (R14 , C35 , C37) ) = ( Comput (R15 , C35 , C37) ) by L177 , L172 , L173 , AMISTD_2:10;
thus L179: ( CurInstr (R15 , ( Comput (R15 , C35 , C37) )) ) = ( R15 . ( IC ( Comput (R15 , C35 , C37) ) ) ) by PBOOLE:143
.= ( C36 . ( IC ( Comput (R15 , C35 , C37) ) ) ) by L176 , L173 , GRFUNC_1:2
.= ( R14 . ( IC ( Comput (R14 , C35 , C37) ) ) ) by L178 , L175 , L172 , GRFUNC_1:2
.= ( CurInstr (R14 , ( Comput (R14 , C35 , C37) )) ) by PBOOLE:143;
end;
end;
theorem
L175: (for R14 being (Instruction-Sequence of ( SCM+FSA )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds (for B32 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B33 being  parahalting (Program of ( SCM+FSA )) holds ((B33 c= R14 & B33 c= R15) implies (( LifeSpan (R14 , B32) ) = ( LifeSpan (R15 , B32) ) & ( Result (R14 , B32) ) = ( Result (R15 , B32) )))))))
proof
let R14 being (Instruction-Sequence of ( SCM+FSA ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
let C38 being ( 0 ) -started (State of ( SCM+FSA ));
let C39 being  parahalting (Program of ( SCM+FSA ));
assume that
L176: C39 c= R14
and
L177: C39 c= R15;
L178: R15 halts_on C38 by L177 , AMISTD_1:def 11;
L179: R14 halts_on C38 by L176 , AMISTD_1:def 11;
L180:
now
let C40 being (Element of ( NAT ));
assume L181: ( CurInstr (R15 , ( Comput (R15 , C38 , C40) )) ) = ( halt ( SCM+FSA ) );
L182: ( CurInstr (R14 , ( Comput (R14 , C38 , C40) )) ) = ( CurInstr (R15 , ( Comput (R15 , C38 , C40) )) ) by L171 , L176 , L177;
thus L183: ( LifeSpan (R14 , C38) ) <= C40 by L182 , L179 , L181 , EXTPRO_1:def 15;
end;
L184: ( CurInstr (R15 , ( Comput (R15 , C38 , ( LifeSpan (R14 , C38) )) )) ) = ( CurInstr (R14 , ( Comput (R14 , C38 , ( LifeSpan (R14 , C38) )) )) ) by L171 , L176 , L177
.= ( halt ( SCM+FSA ) ) by L179 , EXTPRO_1:def 15;
thus L185: ( LifeSpan (R14 , C38) ) = ( LifeSpan (R15 , C38) ) by L184 , L180 , L178 , EXTPRO_1:def 15;
L186: ( Result (R15 , C38) ) = ( Comput (R15 , C38 , ( LifeSpan (R14 , C38) )) ) by L185 , L26 , L177 , EXTPRO_1:23;
L187: ( Result (R14 , C38) ) = ( Comput (R14 , C38 , ( LifeSpan (R14 , C38) )) ) by L26 , L176 , EXTPRO_1:23;
thus L188: thesis by L187 , L186 , L171 , L176 , L177;
end;
canceled 2;
theorem
L189: (for R10 being (State of ( SCM+FSA )) holds (for R13 being (Instruction-Sequence of ( SCM+FSA )) holds (for B34 being  keeping_0  parahalting (Program of ( SCM+FSA )) holds ( ( IExec (B34 , R13 , R10) ) . ( intloc ( 0 ) ) ) = 1)))
proof
let R10 being (State of ( SCM+FSA ));
let R13 being (Instruction-Sequence of ( SCM+FSA ));
let C41 being  keeping_0  parahalting (Program of ( SCM+FSA ));
L190: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by FUNCT_4:25;
L191: C41 c= ( R13 +* C41 ) by FUNCT_4:25;
L192: ( R13 +* C41 ) halts_on ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L27 , L191 , L190;
L193: (ex R2 being (Element of ( NAT )) st (( Result (( R13 +* C41 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) = ( Comput (( R13 +* C41 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) , R2) ) & ( CurInstr (( R13 +* C41 ) , ( Result (( R13 +* C41 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) )) ) = ( halt ( SCM+FSA ) ))) by L192 , EXTPRO_1:def 9;
thus L194: ( ( IExec (C41 , R13 , R10) ) . ( intloc ( 0 ) ) ) = ( ( Initialized R10 ) . ( intloc ( 0 ) ) ) by L193 , L2 , L191
.= 1 by SCMFSA_M:9;
end;
begin
registration
cluster  paraclosed for (Program of ( SCM+FSA ));
existence
proof
take the  parahalting (Program of ( SCM+FSA ));
thus L195: thesis;
end;
end;
theorem
L197: (for B35 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B36 being  paraclosed (Program of ( SCM+FSA )) holds (for B37 being (Program of ( SCM+FSA )) holds (for B38 being (Instruction-Sequence of ( SCM+FSA )) holds ((B36 c= B38 & B38 halts_on B35) implies (for R1 being (Element of ( NAT )) holds (R1 <= ( LifeSpan (B38 , B35) ) implies ( Comput (B38 , B35 , R1) ) = ( Comput (( B38 +* ( B36 ";" B37 ) ) , B35 , R1) ))))))))
proof
let C42 being ( 0 ) -started (State of ( SCM+FSA ));
let C43 being  paraclosed (Program of ( SCM+FSA ));
let C44 being (Program of ( SCM+FSA ));
let C45 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L198: C43 c= C45;
assume that
L199: C45 halts_on C42;
defpred S6[ Nat ] means ($1 <= ( LifeSpan (C45 , C42) ) implies ( Comput (C45 , C42 , $1) ) = ( Comput (( C45 +* ( C43 ";" C44 ) ) , C42 , $1) ));
L200: (for R1 being (Element of ( NAT )) holds (S6[ R1 ] implies S6[ ( R1 + 1 ) ]))
proof
let R1 being (Element of ( NAT ));
assume L201: (R1 <= ( LifeSpan (C45 , C42) ) implies ( Comput (C45 , C42 , R1) ) = ( Comput (( C45 +* ( C43 ";" C44 ) ) , C42 , R1) ));
L202: ( dom ( C43 ";" C44 ) ) = ( ( dom ( Directed C43 ) ) \/ ( dom ( Reloc (C44 , ( card C43 )) ) ) ) by FUNCT_4:def 1
.= ( ( dom C43 ) \/ ( dom ( Reloc (C44 , ( card C43 )) ) ) ) by FUNCT_4:99;
L203: (( {} ) c= ( Comput (( C45 +* ( C43 ";" C44 ) ) , C42 , R1) ) & ( dom C43 ) c= ( dom ( C43 ";" C44 ) )) by L202 , XBOOLE_1:2 , XBOOLE_1:7;
L204: ( Comput (C45 , C42 , ( R1 + 1 )) ) = ( Following (C45 , ( Comput (C45 , C42 , R1) )) ) by EXTPRO_1:3;
L205: ( Comput (( C45 +* ( C43 ";" C44 ) ) , C42 , ( R1 + 1 )) ) = ( Following (( C45 +* ( C43 ";" C44 ) ) , ( Comput (( C45 +* ( C43 ";" C44 ) ) , C42 , R1) )) ) by EXTPRO_1:3;
L206: ( IC ( Comput (C45 , C42 , R1) ) ) in ( dom C43 ) by L198 , AMISTD_1:def 10;
L207: ( dom C45 ) = ( NAT ) by PARTFUN1:def 2;
L208: ( CurInstr (C45 , ( Comput (C45 , C42 , R1) )) ) = ( C45 . ( IC ( Comput (C45 , C42 , R1) ) ) ) by L207 , PARTFUN1:def 6
.= ( C43 . ( IC ( Comput (C45 , C42 , R1) ) ) ) by L206 , L198 , GRFUNC_1:2;
assume L209: ( R1 + 1 ) <= ( LifeSpan (C45 , C42) );
L210: ( C43 ";" C44 ) c= ( C45 +* ( C43 ";" C44 ) ) by FUNCT_4:25;
L211: ( dom ( C45 +* ( C43 ";" C44 ) ) ) = ( NAT ) by PARTFUN1:def 2;
L212: R1 < ( LifeSpan (C45 , C42) ) by L209 , NAT_1:13;
L213: ( C43 . ( IC ( Comput (C45 , C42 , R1) ) ) ) <> ( halt ( SCM+FSA ) ) by L212 , L199 , L208 , EXTPRO_1:def 15;
L214: ( CurInstr (C45 , ( Comput (C45 , C42 , R1) )) ) = ( ( C43 ";" C44 ) . ( IC ( Comput (C45 , C42 , R1) ) ) ) by L213 , L206 , L208 , SCMFSA6A:15
.= ( ( C45 +* ( C43 ";" C44 ) ) . ( IC ( Comput (C45 , C42 , R1) ) ) ) by L206 , L203 , L210 , GRFUNC_1:2
.= ( CurInstr (( C45 +* ( C43 ";" C44 ) ) , ( Comput (( C45 +* ( C43 ";" C44 ) ) , C42 , R1) )) ) by L211 , L209 , L201 , NAT_1:13 , PARTFUN1:def 6;
thus L215: ( Comput (C45 , C42 , ( R1 + 1 )) ) = ( Comput (( C45 +* ( C43 ";" C44 ) ) , C42 , ( R1 + 1 )) ) by L214 , L204 , L205 , L201 , L209 , NAT_1:13;
end;
L216: S6[ ( 0 ) ];
thus L217: (for R1 being (Element of ( NAT )) holds S6[ R1 ]) from NAT_1:sch 1(L216 , L200);
end;
theorem
L218: (for B39 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B40 being (Instruction-Sequence of ( SCM+FSA )) holds (for B41 being  paraclosed (Program of ( SCM+FSA )) holds ((( B40 +* B41 ) halts_on B39 & ( Directed B41 ) c= B40) implies ( IC ( Comput (B40 , B39 , ( ( LifeSpan (( B40 +* B41 ) , B39) ) + 1 )) ) ) = ( card B41 )))))
proof
let C46 being ( 0 ) -started (State of ( SCM+FSA ));
let C47 being (Instruction-Sequence of ( SCM+FSA ));
let C48 being  paraclosed (Program of ( SCM+FSA ));
assume that
L219: ( C47 +* C48 ) halts_on C46
and
L220: ( Directed C48 ) c= C47;
L221: C48 c= ( C47 +* C48 ) by FUNCT_4:25;
set D24 = C46;
set D25 = ( LifeSpan (( C47 +* C48 ) , C46) );
set D26 = ( IC ( Comput (( C47 +* C48 ) , C46 , D25) ) );
L222: C48 c= ( C47 +* C48 ) by FUNCT_4:25;
L223: D26 in ( dom C48 ) by L222 , AMISTD_1:def 10;
set D27 = C46;
L224: ( C47 +* ( C48 ";" C48 ) ) = ( C47 +* ( C48 +* ( C48 ";" C48 ) ) ) by SCMFSA6A:18
.= ( ( C47 +* C48 ) +* ( C48 ";" C48 ) ) by FUNCT_4:14;
L225:
now
let C49 being (Element of ( NAT ));
defpred S7[ Nat ] means ($1 <= C49 implies ( Comput (( C47 +* ( C48 ";" C48 ) ) , D27 , $1) ) = ( Comput (( C47 +* ( Directed C48 ) ) , D24 , $1) ));
assume L226: C49 <= D25;
L227: (for B42 being (Element of ( NAT )) holds (S7[ B42 ] implies S7[ ( B42 + 1 ) ]))
proof
let C50 being (Element of ( NAT ));
assume L228: (C50 <= C49 implies ( Comput (( C47 +* ( C48 ";" C48 ) ) , D27 , C50) ) = ( Comput (( C47 +* ( Directed C48 ) ) , D24 , C50) ));
L229: ( Comput (( C47 +* ( Directed C48 ) ) , D24 , ( C50 + 1 )) ) = ( Following (( C47 +* ( Directed C48 ) ) , ( Comput (( C47 +* ( Directed C48 ) ) , D24 , C50) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( C47 +* ( Directed C48 ) ) , ( Comput (( C47 +* ( Directed C48 ) ) , D24 , C50) )) ) , ( Comput (( C47 +* ( Directed C48 ) ) , D24 , C50) )) );
L230: ( Comput (( C47 +* ( C48 ";" C48 ) ) , D27 , ( C50 + 1 )) ) = ( Following (( C47 +* ( C48 ";" C48 ) ) , ( Comput (( C47 +* ( C48 ";" C48 ) ) , D27 , C50) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( C47 +* ( C48 ";" C48 ) ) , ( Comput (( C47 +* ( C48 ";" C48 ) ) , D27 , C50) )) ) , ( Comput (( C47 +* ( C48 ";" C48 ) ) , D27 , C50) )) );
L231: C50 <= ( C50 + 1 ) by NAT_1:12;
assume L232: ( C50 + 1 ) <= C49;
L233: C50 <= C49 by L232 , L231 , XXREAL_0:2;
L234: ( Comput (( C47 +* C48 ) , C46 , C50) ) = ( Comput (( C47 +* ( C48 ";" C48 ) ) , C46 , C50) ) by L233 , L221 , L197 , L224 , L219 , L226 , XXREAL_0:2;
L235: ( IC ( Comput (( C47 +* ( C48 ";" C48 ) ) , D27 , C50) ) ) in ( dom C48 ) by L234 , L221 , AMISTD_1:def 10;
L236: ( IC ( Comput (( C47 +* ( Directed C48 ) ) , D24 , C50) ) ) in ( dom ( Directed C48 ) ) by L235 , L232 , L228 , L231 , FUNCT_4:99 , XXREAL_0:2;
L237: ( dom ( C47 +* ( Directed C48 ) ) ) = ( NAT ) by PARTFUN1:def 2;
L238: ( ( C47 +* ( Directed C48 ) ) /. ( IC ( Comput (( C47 +* ( Directed C48 ) ) , D24 , C50) ) ) ) = ( ( C47 +* ( Directed C48 ) ) . ( IC ( Comput (( C47 +* ( Directed C48 ) ) , D24 , C50) ) ) ) by L237 , PARTFUN1:def 6;
L239: ( dom ( C47 +* ( C48 ";" C48 ) ) ) = ( NAT ) by PARTFUN1:def 2;
L240: ( Directed C48 ) c= ( C47 +* ( Directed C48 ) ) by FUNCT_4:25;
L241: ( CurInstr (( C47 +* ( Directed C48 ) ) , ( Comput (( C47 +* ( Directed C48 ) ) , D24 , C50) )) ) = ( ( Directed C48 ) . ( IC ( Comput (( C47 +* ( Directed C48 ) ) , D24 , C50) ) ) ) by L240 , L236 , L238 , GRFUNC_1:2;
L242: (( dom C48 ) c= ( dom ( C48 ";" C48 ) ) & ( CurInstr (( C47 +* ( C48 ";" C48 ) ) , ( Comput (( C47 +* ( C48 ";" C48 ) ) , D27 , C50) )) ) = ( ( C47 +* ( C48 ";" C48 ) ) . ( IC ( Comput (( C47 +* ( C48 ";" C48 ) ) , D27 , C50) ) ) )) by L239 , PARTFUN1:def 6 , SCMFSA6A:17;
L243: ( Directed C48 ) c= ( C48 ";" C48 ) by SCMFSA6A:16;
L244: ( C48 ";" C48 ) c= ( C47 +* ( C48 ";" C48 ) ) by FUNCT_4:25;
L245: ( Directed C48 ) c= ( C47 +* ( C48 ";" C48 ) ) by L244 , L243 , XBOOLE_1:1;
thus L246: thesis by L245 , L228 , L232 , L231 , L241 , L230 , L229 , L236 , L242 , GRFUNC_1:2 , XXREAL_0:2;
end;
L247: S7[ ( 0 ) ];
L248: (for B43 being (Element of ( NAT )) holds S7[ B43 ]) from NAT_1:sch 1(L247 , L227);
L249: ( Comput (( C47 +* ( C48 ";" C48 ) ) , D27 , C49) ) = ( Comput (( C47 +* ( Directed C48 ) ) , D24 , C49) ) by L248;
thus L250: ( Comput (( C47 +* C48 ) , C46 , C49) ) = ( Comput (( C47 +* ( Directed C48 ) ) , D24 , C49) ) by L249 , L226 , L197 , L224 , L219 , FUNCT_4:25;
end;
L251: ( Comput (( C47 +* C48 ) , C46 , D25) ) = ( Comput (( C47 +* ( Directed C48 ) ) , D24 , D25) ) by L225;
L252: ( dom ( C47 +* C48 ) ) = ( NAT ) by PARTFUN1:def 2;
L253: C48 c= ( C47 +* C48 ) by FUNCT_4:25;
L254: ( C48 . D26 ) = ( ( C47 +* C48 ) . ( IC ( Comput (( C47 +* C48 ) , C46 , D25) ) ) ) by L253 , L223 , GRFUNC_1:2
.= ( CurInstr (( C47 +* C48 ) , ( Comput (( C47 +* C48 ) , C46 , D25) )) ) by L252 , PARTFUN1:def 6
.= ( halt ( SCM+FSA ) ) by L219 , EXTPRO_1:def 15;
L255: ( IC ( Comput (( C47 +* ( Directed C48 ) ) , D24 , D25) ) ) in ( dom ( Directed C48 ) ) by L223 , L251 , FUNCT_4:99;
L256: ( ( C47 +* ( Directed C48 ) ) . D26 ) = ( ( Directed C48 ) . D26 ) by L255 , L251 , FUNCT_4:13
.= ( goto ( card C48 ) ) by L223 , L254 , FUNCT_4:106;
L257: ( C47 +* ( Directed C48 ) ) = C47 by L220 , FUNCT_4:98;
L258: ( dom ( C47 +* ( Directed C48 ) ) ) = ( NAT ) by PARTFUN1:def 2;
L259: ( Comput (( C47 +* ( Directed C48 ) ) , D24 , ( D25 + 1 )) ) = ( Following (( C47 +* ( Directed C48 ) ) , ( Comput (( C47 +* ( Directed C48 ) ) , D24 , D25) )) ) by EXTPRO_1:3
.= ( Exec (( goto ( card C48 ) ) , ( Comput (( C47 +* ( Directed C48 ) ) , D24 , D25) )) ) by L258 , L251 , L256 , PARTFUN1:def 6;
thus L260: ( IC ( Comput (C47 , C46 , ( ( LifeSpan (( C47 +* C48 ) , C46) ) + 1 )) ) ) = ( card C48 ) by L259 , L257 , SCMFSA_2:69;
end;
theorem
L261: (for B44 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B45 being (Instruction-Sequence of ( SCM+FSA )) holds (for B46 being  paraclosed (Program of ( SCM+FSA )) holds ((( B45 +* B46 ) halts_on B44 & ( Directed B46 ) c= B45) implies ( DataPart ( Comput (B45 , B44 , ( LifeSpan (( B45 +* B46 ) , B44) )) ) ) = ( DataPart ( Comput (B45 , B44 , ( ( LifeSpan (( B45 +* B46 ) , B44) ) + 1 )) ) )))))
proof
let C51 being ( 0 ) -started (State of ( SCM+FSA ));
let C52 being (Instruction-Sequence of ( SCM+FSA ));
let C53 being  paraclosed (Program of ( SCM+FSA ));
assume that
L262: ( C52 +* C53 ) halts_on C51
and
L263: ( Directed C53 ) c= C52;
L264: C53 c= ( C52 +* C53 ) by FUNCT_4:25;
set D28 = ( LifeSpan (( C52 +* C53 ) , C51) );
set D29 = ( IC ( Comput (( C52 +* C53 ) , C51 , D28) ) );
L265: D29 in ( dom C53 ) by L264 , AMISTD_1:def 10;
L266:
now
let C54 being (Element of ( NAT ));
defpred S8[ Nat ] means ($1 <= C54 implies ( Comput (( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) , C51 , $1) ) = ( Comput (C52 , C51 , $1) ));
assume L267: C54 <= D28;
L268: (for B47 being (Element of ( NAT )) holds (S8[ B47 ] implies S8[ ( B47 + 1 ) ]))
proof
L269: ( Directed C53 ) c= ( C53 ";" C53 ) by SCMFSA6A:16;
let C55 being (Element of ( NAT ));
L270: ( dom C53 ) c= ( dom ( C53 ";" C53 ) ) by SCMFSA6A:17;
assume L271: (C55 <= C54 implies ( Comput (( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) , C51 , C55) ) = ( Comput (C52 , C51 , C55) ));
L272: ( Comput (C52 , C51 , ( C55 + 1 )) ) = ( Following (C52 , ( Comput (C52 , C51 , C55) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C52 , ( Comput (C52 , C51 , C55) )) ) , ( Comput (C52 , C51 , C55) )) );
L273: ( Comput (( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) , C51 , ( C55 + 1 )) ) = ( Following (( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) , ( Comput (( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) , C51 , C55) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) , ( Comput (( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) , C51 , C55) )) ) , ( Comput (( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) , C51 , C55) )) );
L274: C55 <= ( C55 + 1 ) by NAT_1:12;
assume L275: ( C55 + 1 ) <= C54;
L276: C55 <= C54 by L275 , L274 , XXREAL_0:2;
L277: ( Comput (( C52 +* C53 ) , C51 , C55) ) = ( Comput (( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) , C51 , C55) ) by L276 , L197 , L267 , L264 , L262 , XXREAL_0:2;
L278: ( IC ( Comput (( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) , C51 , C55) ) ) in ( dom C53 ) by L277 , L264 , AMISTD_1:def 10;
L279: ( IC ( Comput (C52 , C51 , C55) ) ) in ( dom ( Directed C53 ) ) by L278 , L275 , L271 , L274 , FUNCT_4:99 , XXREAL_0:2;
L280: ( dom C52 ) = ( NAT ) by PARTFUN1:def 2;
L281: ( CurInstr (C52 , ( Comput (C52 , C51 , C55) )) ) = ( C52 . ( IC ( Comput (C52 , C51 , C55) ) ) ) by L280 , PARTFUN1:def 6
.= ( ( Directed C53 ) . ( IC ( Comput (C52 , C51 , C55) ) ) ) by L279 , L263 , GRFUNC_1:2;
L282: ( dom ( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) ) = ( NAT ) by PARTFUN1:def 2;
L283: ( CurInstr (( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) , ( Comput (( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) , C51 , C55) )) ) = ( ( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) . ( IC ( Comput (( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) , C51 , C55) ) ) ) by L282 , PARTFUN1:def 6
.= ( ( C53 ";" C53 ) . ( IC ( Comput (( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) , C51 , C55) ) ) ) by L270 , L278 , FUNCT_4:13
.= ( ( Directed C53 ) . ( IC ( Comput (( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) , C51 , C55) ) ) ) by L269 , L275 , L279 , L271 , L274 , GRFUNC_1:2 , XXREAL_0:2;
thus L284: thesis by L283 , L271 , L275 , L274 , L281 , L273 , L272 , XXREAL_0:2;
end;
L285: S8[ ( 0 ) ];
L286: (for B48 being (Element of ( NAT )) holds S8[ B48 ]) from NAT_1:sch 1(L285 , L268);
L287: ( Comput (( ( C52 +* C53 ) +* ( C53 ";" C53 ) ) , C51 , C54) ) = ( Comput (C52 , C51 , C54) ) by L286;
thus L288: ( Comput (( C52 +* C53 ) , C51 , C54) ) = ( Comput (C52 , C51 , C54) ) by L287 , L267 , L262 , L197 , FUNCT_4:25;
end;
L289: ( Comput (( C52 +* C53 ) , C51 , D28) ) = ( Comput (C52 , C51 , D28) ) by L266;
L290: ( dom ( C52 +* C53 ) ) = ( NAT ) by PARTFUN1:def 2;
L291: C53 c= ( C52 +* C53 ) by FUNCT_4:25;
L292: ( C53 . D29 ) = ( ( C52 +* C53 ) . ( IC ( Comput (( C52 +* C53 ) , C51 , D28) ) ) ) by L291 , L265 , GRFUNC_1:2
.= ( CurInstr (( C52 +* C53 ) , ( Comput (( C52 +* C53 ) , C51 , D28) )) ) by L290 , PARTFUN1:def 6
.= ( halt ( SCM+FSA ) ) by L262 , EXTPRO_1:def 15;
L293: ( IC ( Comput (C52 , C51 , D28) ) ) in ( dom ( Directed C53 ) ) by L265 , L289 , FUNCT_4:99;
L294: ( C52 . D29 ) = ( ( Directed C53 ) . D29 ) by L293 , L289 , L263 , GRFUNC_1:2
.= ( goto ( card C53 ) ) by L265 , L292 , FUNCT_4:106;
L295: ( dom C52 ) = ( NAT ) by PARTFUN1:def 2;
L296: ( Comput (C52 , C51 , ( D28 + 1 )) ) = ( Following (C52 , ( Comput (C52 , C51 , D28) )) ) by EXTPRO_1:3
.= ( Exec (( goto ( card C53 ) ) , ( Comput (C52 , C51 , D28) )) ) by L289 , L294 , L295 , PARTFUN1:def 6;
L297: ((for B49 being Int-Location holds ( ( Comput (C52 , C51 , ( D28 + 1 )) ) . B49 ) = ( ( Comput (C52 , C51 , D28) ) . B49 )) & (for B50 being FinSeq-Location holds ( ( Comput (C52 , C51 , ( D28 + 1 )) ) . B50 ) = ( ( Comput (C52 , C51 , D28) ) . B50 ))) by L296 , SCMFSA_2:69;
thus L298: thesis by L297 , SCMFSA_M:2;
end;
theorem
L299: (for R10 being (State of ( SCM+FSA )) holds (for R13 being (Instruction-Sequence of ( SCM+FSA )) holds (for B51 being  parahalting (Program of ( SCM+FSA )) holds ((B51 c= R13 & ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= R10) implies (for B52 being (Element of ( NAT )) holds (B52 <= ( LifeSpan (R13 , R10) ) implies ( CurInstr (( R13 +* ( Directed B51 ) ) , ( Comput (( R13 +* ( Directed B51 ) ) , R10 , B52) )) ) <> ( halt ( SCM+FSA ) )))))))
proof
let R10 being (State of ( SCM+FSA ));
let R13 being (Instruction-Sequence of ( SCM+FSA ));
let C56 being  parahalting (Program of ( SCM+FSA ));
set D30 = ( LifeSpan (R13 , R10) );
assume that
L300: C56 c= R13
and
L301: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= R10;
L302: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= R10 by L301 , MEMSTR_0:50;
L303: R10 is ( 0 ) -started by L302 , MEMSTR_0:29;
L304: R13 halts_on R10 by L303 , L300 , AMISTD_1:def 11;
reconsider D31 = R10 as ( 0 ) -started (State of ( SCM+FSA )) by L302 , MEMSTR_0:29;
L305:
now
let C57 being (Element of ( NAT ));
defpred S9[ Nat ] means ($1 <= C57 implies ( Comput (( R13 +* ( C56 ";" C56 ) ) , D31 , $1) ) = ( Comput (( R13 +* ( Directed C56 ) ) , R10 , $1) ));
assume L306: C57 <= D30;
L307: (for B53 being (Element of ( NAT )) holds (S9[ B53 ] implies S9[ ( B53 + 1 ) ]))
proof
L308: ( Directed C56 ) c= ( C56 ";" C56 ) by SCMFSA6A:16;
let C58 being (Element of ( NAT ));
L309: ( dom C56 ) c= ( dom ( C56 ";" C56 ) ) by SCMFSA6A:17;
assume L310: (C58 <= C57 implies ( Comput (( R13 +* ( C56 ";" C56 ) ) , D31 , C58) ) = ( Comput (( R13 +* ( Directed C56 ) ) , R10 , C58) ));
L311: ( Comput (( R13 +* ( Directed C56 ) ) , R10 , ( C58 + 1 )) ) = ( Following (( R13 +* ( Directed C56 ) ) , ( Comput (( R13 +* ( Directed C56 ) ) , R10 , C58) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( R13 +* ( Directed C56 ) ) , ( Comput (( R13 +* ( Directed C56 ) ) , R10 , C58) )) ) , ( Comput (( R13 +* ( Directed C56 ) ) , R10 , C58) )) );
L312: ( Comput (( R13 +* ( C56 ";" C56 ) ) , D31 , ( C58 + 1 )) ) = ( Following (( R13 +* ( C56 ";" C56 ) ) , ( Comput (( R13 +* ( C56 ";" C56 ) ) , D31 , C58) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( R13 +* ( C56 ";" C56 ) ) , ( Comput (( R13 +* ( C56 ";" C56 ) ) , D31 , C58) )) ) , ( Comput (( R13 +* ( C56 ";" C56 ) ) , D31 , C58) )) );
L313: C58 <= ( C58 + 1 ) by NAT_1:12;
assume L314: ( C58 + 1 ) <= C57;
L315: C58 <= C57 by L314 , L313 , XXREAL_0:2;
L316: ( Comput (R13 , R10 , C58) ) = ( Comput (( R13 +* ( C56 ";" C56 ) ) , D31 , C58) ) by L315 , L304 , L300 , L197 , L306 , XXREAL_0:2;
L317: ( IC ( Comput (( R13 +* ( C56 ";" C56 ) ) , D31 , C58) ) ) in ( dom C56 ) by L316 , L300 , AMISTD_1:def 10;
L318: ( IC ( Comput (( R13 +* ( Directed C56 ) ) , R10 , C58) ) ) in ( dom ( Directed C56 ) ) by L317 , L314 , L310 , L313 , FUNCT_4:99 , XXREAL_0:2;
L319: ( dom ( R13 +* ( Directed C56 ) ) ) = ( NAT ) by PARTFUN1:def 2;
L320: ( CurInstr (( R13 +* ( Directed C56 ) ) , ( Comput (( R13 +* ( Directed C56 ) ) , R10 , C58) )) ) = ( ( R13 +* ( Directed C56 ) ) . ( IC ( Comput (( R13 +* ( Directed C56 ) ) , R10 , C58) ) ) ) by L319 , PARTFUN1:def 6
.= ( ( Directed C56 ) . ( IC ( Comput (( R13 +* ( Directed C56 ) ) , R10 , C58) ) ) ) by L318 , FUNCT_4:13;
L321: ( dom ( R13 +* ( C56 ";" C56 ) ) ) = ( NAT ) by PARTFUN1:def 2;
L322: ( CurInstr (( R13 +* ( C56 ";" C56 ) ) , ( Comput (( R13 +* ( C56 ";" C56 ) ) , D31 , C58) )) ) = ( ( R13 +* ( C56 ";" C56 ) ) . ( IC ( Comput (( R13 +* ( C56 ";" C56 ) ) , D31 , C58) ) ) ) by L321 , PARTFUN1:def 6
.= ( ( C56 ";" C56 ) . ( IC ( Comput (( R13 +* ( C56 ";" C56 ) ) , D31 , C58) ) ) ) by L309 , L317 , FUNCT_4:13
.= ( ( Directed C56 ) . ( IC ( Comput (( R13 +* ( C56 ";" C56 ) ) , D31 , C58) ) ) ) by L308 , L314 , L310 , L313 , L318 , GRFUNC_1:2 , XXREAL_0:2;
thus L323: thesis by L322 , L310 , L314 , L313 , L320 , L312 , L311 , XXREAL_0:2;
end;
L324: S9[ ( 0 ) ];
L325: (for B54 being (Element of ( NAT )) holds S9[ B54 ]) from NAT_1:sch 1(L324 , L307);
L326: ( Comput (( R13 +* ( C56 ";" C56 ) ) , D31 , C57) ) = ( Comput (( R13 +* ( Directed C56 ) ) , R10 , C57) ) by L325;
thus L327: ( Comput (R13 , R10 , C57) ) = ( Comput (( R13 +* ( Directed C56 ) ) , R10 , C57) ) by L326 , L304 , L306 , L197 , L300;
end;
thus L328:now
let C59 being (Element of ( NAT ));
set D32 = ( IC ( Comput (R13 , R10 , C59) ) );
L329: ( dom C56 ) = ( dom ( Directed C56 ) ) by FUNCT_4:99;
L330: ( IC ( Comput (R13 , D31 , C59) ) ) in ( dom C56 ) by L300 , AMISTD_1:def 10;
L331: ( ( Directed C56 ) . D32 ) in ( rng ( Directed C56 ) ) by L330 , L329 , FUNCT_1:def 3;
L332: ( dom ( R13 +* ( Directed C56 ) ) ) = ( NAT ) by PARTFUN1:def 2;
assume L333: C59 <= ( LifeSpan (R13 , R10) );
L334: D32 = ( IC ( Comput (( R13 +* ( Directed C56 ) ) , R10 , C59) ) ) by L333 , L305;
L335: ( CurInstr (( R13 +* ( Directed C56 ) ) , ( Comput (( R13 +* ( Directed C56 ) ) , R10 , C59) )) ) = ( ( R13 +* ( Directed C56 ) ) . D32 ) by L334 , L332 , PARTFUN1:def 6
.= ( ( Directed C56 ) . D32 ) by L329 , L330 , FUNCT_4:13;
thus L336: ( CurInstr (( R13 +* ( Directed C56 ) ) , ( Comput (( R13 +* ( Directed C56 ) ) , R10 , C59) )) ) <> ( halt ( SCM+FSA ) ) by L335 , L331 , SCMFSA6A:1;
end;
end;
theorem
L329: (for B55 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B56 being (Instruction-Sequence of ( SCM+FSA )) holds (for B57 being  paraclosed (Program of ( SCM+FSA )) holds (( B56 +* B57 ) halts_on B55 implies (for B58 being (Program of ( SCM+FSA )) holds (for B59 being (Element of ( NAT )) holds (B59 <= ( LifeSpan (( B56 +* B57 ) , B55) ) implies ( Comput (( B56 +* B57 ) , B55 , B59) ) = ( Comput (( B56 +* ( B57 ";" B58 ) ) , B55 , B59) ))))))))
proof
let C60 being ( 0 ) -started (State of ( SCM+FSA ));
let C61 being (Instruction-Sequence of ( SCM+FSA ));
let C62 being  paraclosed (Program of ( SCM+FSA ));
assume L330: ( C61 +* C62 ) halts_on C60;
let C63 being (Program of ( SCM+FSA ));
L331: C62 c= ( C61 +* C62 ) by FUNCT_4:25;
defpred S10[ Nat ] means ($1 <= ( LifeSpan (( C61 +* C62 ) , C60) ) implies ( Comput (( C61 +* C62 ) , C60 , $1) ) = ( Comput (( C61 +* ( C62 ";" C63 ) ) , C60 , $1) ));
L332: (for R1 being (Element of ( NAT )) holds (S10[ R1 ] implies S10[ ( R1 + 1 ) ]))
proof
L333: ( dom ( C62 ";" C63 ) ) = ( ( dom ( Directed C62 ) ) \/ ( dom ( Reloc (C63 , ( card C62 )) ) ) ) by FUNCT_4:def 1
.= ( ( dom C62 ) \/ ( dom ( Reloc (C63 , ( card C62 )) ) ) ) by FUNCT_4:99;
L334: ( dom C62 ) c= ( dom ( C62 ";" C63 ) ) by L333 , XBOOLE_1:7;
let R1 being (Element of ( NAT ));
assume L335: (R1 <= ( LifeSpan (( C61 +* C62 ) , C60) ) implies ( Comput (( C61 +* C62 ) , C60 , R1) ) = ( Comput (( C61 +* ( C62 ";" C63 ) ) , C60 , R1) ));
L336: ( Comput (( C61 +* C62 ) , C60 , ( R1 + 1 )) ) = ( Following (( C61 +* C62 ) , ( Comput (( C61 +* C62 ) , C60 , R1) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( C61 +* C62 ) , ( Comput (( C61 +* C62 ) , C60 , R1) )) ) , ( Comput (( C61 +* C62 ) , C60 , R1) )) );
L337: ( Comput (( C61 +* ( C62 ";" C63 ) ) , C60 , ( R1 + 1 )) ) = ( Following (( C61 +* ( C62 ";" C63 ) ) , ( Comput (( C61 +* ( C62 ";" C63 ) ) , C60 , R1) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( C61 +* ( C62 ";" C63 ) ) , ( Comput (( C61 +* ( C62 ";" C63 ) ) , C60 , R1) )) ) , ( Comput (( C61 +* ( C62 ";" C63 ) ) , C60 , R1) )) );
L338: ( IC ( Comput (( C61 +* C62 ) , C60 , R1) ) ) in ( dom C62 ) by L331 , AMISTD_1:def 10;
L339: C62 c= ( C61 +* C62 ) by FUNCT_4:25;
L340: ( dom ( C61 +* C62 ) ) = ( NAT ) by PARTFUN1:def 2;
L341: ( CurInstr (( C61 +* C62 ) , ( Comput (( C61 +* C62 ) , C60 , R1) )) ) = ( ( C61 +* C62 ) . ( IC ( Comput (( C61 +* C62 ) , C60 , R1) ) ) ) by L340 , PARTFUN1:def 6
.= ( C62 . ( IC ( Comput (( C61 +* C62 ) , C60 , R1) ) ) ) by L338 , L339 , GRFUNC_1:2;
assume L342: ( R1 + 1 ) <= ( LifeSpan (( C61 +* C62 ) , C60) );
L343: ( C62 ";" C63 ) c= ( C61 +* ( C62 ";" C63 ) ) by FUNCT_4:25;
L344: ( dom ( C61 +* ( C62 ";" C63 ) ) ) = ( NAT ) by PARTFUN1:def 2;
L345: R1 < ( LifeSpan (( C61 +* C62 ) , C60) ) by L342 , NAT_1:13;
L346: ( C62 . ( IC ( Comput (( C61 +* C62 ) , C60 , R1) ) ) ) <> ( halt ( SCM+FSA ) ) by L345 , L330 , L341 , EXTPRO_1:def 15;
L347: ( CurInstr (( C61 +* C62 ) , ( Comput (( C61 +* C62 ) , C60 , R1) )) ) = ( ( C62 ";" C63 ) . ( IC ( Comput (( C61 +* C62 ) , C60 , R1) ) ) ) by L346 , L338 , L341 , SCMFSA6A:15
.= ( ( C61 +* ( C62 ";" C63 ) ) . ( IC ( Comput (( C61 +* ( C62 ";" C63 ) ) , C60 , R1) ) ) ) by L342 , L338 , L334 , L343 , L335 , GRFUNC_1:2 , NAT_1:13
.= ( CurInstr (( C61 +* ( C62 ";" C63 ) ) , ( Comput (( C61 +* ( C62 ";" C63 ) ) , C60 , R1) )) ) by L344 , PARTFUN1:def 6;
thus L348: thesis by L347 , L336 , L337 , L335 , L342 , NAT_1:13;
end;
L349: S10[ ( 0 ) ];
thus L350: (for B60 being (Element of ( NAT )) holds S10[ B60 ]) from NAT_1:sch 1(L349 , L332);
end;
L351: (for R13 being (Instruction-Sequence of ( SCM+FSA )) holds (for B61 being  keeping_0  parahalting (Program of ( SCM+FSA )) holds (for B62 being  parahalting (Program of ( SCM+FSA )) holds (for B63 being (State of ( SCM+FSA )) holds ((( B61 ";" B62 ) c= R13 & ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= B63) implies (( IC ( Comput (R13 , B63 , ( ( LifeSpan (( R13 +* B61 ) , B63) ) + 1 )) ) ) = ( card B61 ) & ( DataPart ( Comput (R13 , B63 , ( ( LifeSpan (( R13 +* B61 ) , B63) ) + 1 )) ) ) = ( DataPart ( ( Comput (( R13 +* B61 ) , B63 , ( LifeSpan (( R13 +* B61 ) , B63) )) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) & ( Reloc (B62 , ( card B61 )) ) c= R13 & ( ( Comput (R13 , B63 , ( ( LifeSpan (( R13 +* B61 ) , B63) ) + 1 )) ) . ( intloc ( 0 ) ) ) = 1 & R13 halts_on B63 & ( LifeSpan (R13 , B63) ) = ( ( ( LifeSpan (( R13 +* B61 ) , B63) ) + 1 ) + ( LifeSpan (( ( R13 +* B61 ) +* B62 ) , ( ( Result (( R13 +* B61 ) , B63) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) ) & (B62 is  keeping_0 implies ( ( Result (R13 , B63) ) . ( intloc ( 0 ) ) ) = 1)))))))
proof
let R13 being (Instruction-Sequence of ( SCM+FSA ));
set D33 = ( Data-Locations ( SCM+FSA ) );
let C64 being  keeping_0  parahalting (Program of ( SCM+FSA ));
let C65 being  parahalting (Program of ( SCM+FSA ));
let C66 being (State of ( SCM+FSA ));
set D34 = ( ( Comput (( R13 +* C64 ) , C66 , ( LifeSpan (( R13 +* C64 ) , C66) )) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) );
set D35 = ( LifeSpan (( R13 +* C64 ) , C66) );
set D36 = ( LifeSpan (( ( R13 +* C64 ) +* C65 ) , D34) );
L352: ( dom ( Directed C64 ) ) = ( dom C64 ) by FUNCT_4:99;
assume that
L353: ( C64 ";" C65 ) c= R13
and
L354: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= C66;
L355: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCT_4:25;
L356: D1 c= C66 by L355 , L354 , XBOOLE_1:1;
L357: ( Directed C64 ) c= ( C64 ";" C65 ) by SCMFSA6A:16;
L358: ( R13 +* ( Directed C64 ) ) = R13 by L357 , L353 , FUNCT_4:98 , XBOOLE_1:1;
L359: R13 = ( R13 +* ( C64 ";" C65 ) ) by L353 , FUNCT_4:98;
L360: C66 is ( 0 ) -started ( 0 ) -started ( 0 ) -started ( 0 ) -started (State of ( SCM+FSA )) by L356 , MEMSTR_0:29;
L361: ( R13 +* C64 ) halts_on C66 by L360 , L26 , FUNCT_4:25;
thus L362: ( IC ( Comput (R13 , C66 , ( ( LifeSpan (( R13 +* C64 ) , C66) ) + 1 )) ) ) = ( card C64 ) by L361 , L218 , L357 , L353 , L360 , XBOOLE_1:1;
L363:
now
let C67 being set;
L364: ( dom ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) c= ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by RELAT_1:60;
assume L365: C67 in ( dom ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) );
L366: C67 in D33 by L365 , RELAT_1:57;
L367: C64 c= ( R13 +* C64 ) by FUNCT_4:25;
per cases  by L365 , L364 , SCMFSA_M:11 , TARSKI:def 2;
suppose L368: C67 = ( intloc ( 0 ) );

L369: C67 in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L368 , SCMFSA_M:11 , TARSKI:def 2;
thus L370: ( ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) . C67 ) = 1 by L368 , L366 , FUNCT_1:49 , SCMFSA_M:12
.= ( C66 . C67 ) by L354 , L369 , L368 , GRFUNC_1:2 , SCMFSA_M:12
.= ( ( Comput (( R13 +* C64 ) , C66 , D35) ) . C67 ) by L368 , L2 , L367 , L360
.= ( ( DataPart ( Comput (( R13 +* C64 ) , C66 , D35) ) ) . C67 ) by L366 , FUNCT_1:49;
end;
suppose L371: C67 = ( IC ( SCM+FSA ) );

L372: (not C67 in ( Data-Locations ( SCM+FSA ) )) by L371 , STRUCT_0:3;
thus L373: ( ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) . C67 ) = ( ( DataPart ( Comput (( R13 +* C64 ) , C66 , D35) ) ) . C67 ) by L372 , L365 , RELAT_1:57;
end;
end;
set D37 = ( Comput (R13 , C66 , ( D35 + 1 )) );
reconsider D38 = ( ( D35 + 1 ) + D36 ) as (Element of ( NAT ));
L375: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= D34 by FUNCT_4:25;
L376: C65 c= ( ( R13 +* C64 ) +* C65 ) by FUNCT_4:25;
L377: ( ( R13 +* C64 ) +* C65 ) halts_on D34 by L376 , L375 , L27;
L378: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) c= (the carrier of ( SCM+FSA )) by RELAT_1:def 18;
L379: ( dom ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) = ( ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) /\ D33 ) by RELAT_1:61;
L380: ( dom ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) c= ( (the carrier of ( SCM+FSA )) /\ D33 ) by L379 , L378 , XBOOLE_1:26;
L381: ( dom ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) c= ( ( dom ( Comput (( R13 +* C64 ) , C66 , D35) ) ) /\ D33 ) by L380 , PARTFUN1:def 2;
L382: ( dom ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) c= ( dom ( DataPart ( Comput (( R13 +* C64 ) , C66 , D35) ) ) ) by L381 , RELAT_1:61;
L383: (( DataPart D34 ) = ( ( DataPart ( Comput (( R13 +* C64 ) , C66 , D35) ) ) +* ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) & ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) c= ( DataPart ( Comput (( R13 +* C64 ) , C66 , D35) ) )) by L382 , L363 , FUNCT_4:71 , GRFUNC_1:2;
L384: ( DataPart ( Comput (( R13 +* C64 ) , C66 , D35) ) ) = ( DataPart D34 ) by L383 , FUNCT_4:98;
L385: C66 = ( C66 +* D1 ) by L355 , L354 , FUNCT_4:98 , XBOOLE_1:1;
L386: ( DataPart ( Comput (R13 , C66 , D35) ) ) = ( DataPart D34 ) by L385 , L384 , L359 , L329 , L361;
thus L387: ( DataPart ( Comput (R13 , C66 , ( D35 + 1 )) ) ) = ( DataPart D34 ) by L386 , L361 , L261 , L357 , L353 , L360 , XBOOLE_1:1;
L388: ( Reloc (C65 , ( card C64 )) ) c= ( C64 ";" C65 ) by FUNCT_4:25;
thus L389: ( Reloc (C65 , ( card C64 )) ) c= R13 by L388 , L353 , XBOOLE_1:1;
L390: ( intloc ( 0 ) ) in ( Int-Locations ) by AMI_2:def 16;
L391: ( intloc ( 0 ) ) in D33 by L390 , SCMFSA_2:100 , XBOOLE_0:def 3;
thus L392: ( D37 . ( intloc ( 0 ) ) ) = ( ( DataPart D34 ) . ( intloc ( 0 ) ) ) by L391 , L387 , FUNCT_1:49
.= ( D34 . ( intloc ( 0 ) ) ) by L391 , FUNCT_1:49
.= 1 by FUNCT_4:13 , SCMFSA_M:10 , SCMFSA_M:12;
L393: ( Comput (R13 , C66 , ( ( D35 + 1 ) + D36 )) ) = ( Comput (R13 , ( Comput (R13 , C66 , ( D35 + 1 )) ) , D36) ) by EXTPRO_1:4;
L394: C65 c= ( ( R13 +* C64 ) +* C65 ) by FUNCT_4:25;
L395: ( IncAddr (( CurInstr (( ( R13 +* C64 ) +* C65 ) , ( Comput (( ( R13 +* C64 ) +* C65 ) , D34 , D36) )) ) , ( card C64 )) ) = ( CurInstr (R13 , ( Comput (R13 , D37 , D36) )) ) by L394 , L362 , L387 , L138 , L389;
L396: ( CurInstr (R13 , ( Comput (R13 , C66 , D38) )) ) = ( IncAddr (( halt ( SCM+FSA ) ) , ( card C64 )) ) by L395 , L377 , L393 , EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
thus L397: R13 halts_on C66 by L396 , EXTPRO_1:29;
L398:
now
let C68 being (Element of ( NAT ));
assume L399: ( ( D35 + 1 ) + C68 ) < D38;
L400: C68 < D36 by L399 , XREAL_1:6;
assume L401: ( CurInstr (R13 , ( Comput (R13 , C66 , ( ( D35 + 1 ) + C68 )) )) ) = ( halt ( SCM+FSA ) );
L402: ( InsCode ( halt ( SCM+FSA ) ) ) = ( 0 ) by COMPOS_1:70;
L403: ( IncAddr (( CurInstr (( ( R13 +* C64 ) +* C65 ) , ( Comput (( ( R13 +* C64 ) +* C65 ) , D34 , C68) )) ) , ( card C64 )) ) = ( CurInstr (R13 , ( Comput (R13 , D37 , C68) )) ) by L362 , L387 , L138 , L394 , L389
.= ( halt ( SCM+FSA ) ) by L401 , EXTPRO_1:4;
L404: ( InsCode ( CurInstr (( ( R13 +* C64 ) +* C65 ) , ( Comput (( ( R13 +* C64 ) +* C65 ) , D34 , C68) )) ) ) = ( 0 ) by L403 , COMPOS_0:def 9 , L402;
L405: ( CurInstr (( ( R13 +* C64 ) +* C65 ) , ( Comput (( ( R13 +* C64 ) +* C65 ) , D34 , C68) )) ) = ( halt ( SCM+FSA ) ) by L404 , SCMFSA_2:95;
thus L406: contradiction by L405 , L377 , L400 , EXTPRO_1:def 15;
end;
L407:
now
let C69 being (Element of ( NAT ));
assume L408: C69 < D38;
per cases ;
suppose L409: C69 <= D35;

L410: ( ( R13 +* C64 ) +* ( Directed C64 ) ) = ( R13 +* ( Directed C64 ) ) by L352 , FUNCT_4:74;
thus L411: ( CurInstr (R13 , ( Comput (R13 , C66 , C69) )) ) <> ( halt ( SCM+FSA ) ) by L410 , L354 , L299 , L409 , L358 , FUNCT_4:25;
end;
suppose L412: D35 < C69;

L413: ( D35 + 1 ) <= C69 by L412 , NAT_1:13;
consider C70 being Nat such that L414: ( ( D35 + 1 ) + C70 ) = C69 by L413 , NAT_1:10;
L415: C70 in ( NAT ) by ORDINAL1:def 12;
thus L416: ( CurInstr (R13 , ( Comput (R13 , C66 , C69) )) ) <> ( halt ( SCM+FSA ) ) by L415 , L398 , L408 , L414;
end;
end;
L418: (for B64 being (Element of ( NAT )) holds (( CurInstr (R13 , ( Comput (R13 , C66 , B64) )) ) = ( halt ( SCM+FSA ) ) implies D38 <= B64)) by L407;
L419: ( LifeSpan (R13 , C66) ) = D38 by L418 , L396 , L397 , EXTPRO_1:def 15;
L420: ( R13 +* C64 ) halts_on C66 by L27 , L354 , FUNCT_4:25;
L421: ( Comput (( R13 +* C64 ) , C66 , ( LifeSpan (( R13 +* C64 ) , C66) )) ) = ( Result (( R13 +* C64 ) , C66) ) by L420 , EXTPRO_1:23;
thus L422: ( LifeSpan (R13 , C66) ) = ( ( ( LifeSpan (( R13 +* C64 ) , C66) ) + 1 ) + ( LifeSpan (( ( R13 +* C64 ) +* C65 ) , ( ( Result (( R13 +* C64 ) , C66) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) ) by L421 , L418 , L396 , L397 , EXTPRO_1:def 15;
thus L423:now
L424: ( DataPart ( Comput (( ( R13 +* C64 ) +* C65 ) , D34 , D36) ) ) = ( DataPart ( Comput (R13 , D37 , D36) ) ) by L362 , L387 , L138 , L394 , L389;
L425: C65 c= ( ( R13 +* C64 ) +* C65 ) by FUNCT_4:25;
assume L426: C65 is  keeping_0;
thus L427: ( ( Result (R13 , C66) ) . ( intloc ( 0 ) ) ) = ( ( Comput (R13 , C66 , D38) ) . ( intloc ( 0 ) ) ) by L397 , L419 , EXTPRO_1:23
.= ( ( Comput (R13 , D37 , D36) ) . ( intloc ( 0 ) ) ) by EXTPRO_1:4
.= ( ( Comput (( ( R13 +* C64 ) +* C65 ) , D34 , D36) ) . ( intloc ( 0 ) ) ) by L424 , SCMFSA_M:2
.= ( D34 . ( intloc ( 0 ) ) ) by L426 , L2 , L425
.= 1 by L375 , GRFUNC_1:2 , SCMFSA_M:10 , SCMFSA_M:12;
end;
end;
registration
let C71 , C72 being  parahalting (Program of ( SCM+FSA ));
cluster ( C71 ";" C72 ) ->  parahalting;
coherence
proof
set D39 = ( Data-Locations ( SCM+FSA ) );
let C73 being ( 0 ) -started (State of ( SCM+FSA ));
let C74 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L424: ( C71 ";" C72 ) c= C74;
set D40 = ( Start-At (( 0 ) , ( SCM+FSA )) );
set D41 = ( Initialize ( Comput (( C74 +* C71 ) , C73 , ( LifeSpan (( C74 +* C71 ) , C73) )) ) );
set D42 = ( LifeSpan (( C74 +* C71 ) , C73) );
set D43 = ( LifeSpan (( ( C74 +* C71 ) +* C72 ) , D41) );
reconsider D44 = ( DataPart D40 ) as Function;
L425:
now
let C75 being set;
assume L426: C75 in ( dom ( DataPart D40 ) );
L427: C75 in ( ( dom D40 ) /\ D39 ) by L426 , RELAT_1:61;
L428: C75 in ( dom D40 ) by L427 , XBOOLE_0:def 4;
L429: C75 in { ( IC ( SCM+FSA ) ) } by L428 , FUNCOP_1:13;
L430: C75 = ( IC ( SCM+FSA ) ) by L429 , TARSKI:def 1;
L431: (not C75 in ( Data-Locations ( SCM+FSA ) )) by L430 , STRUCT_0:3;
thus L432: ( D44 . C75 ) = ( ( DataPart ( Comput (( C74 +* C71 ) , C73 , D42) ) ) . C75 ) by L431 , L427 , XBOOLE_0:def 4;
end;
L433: D40 c= D41 by FUNCT_4:25;
L434: ( dom D40 ) c= ( dom D41 ) by L433 , GRFUNC_1:2;
L435: ( dom D40 ) c= (the carrier of ( SCM+FSA )) by L434 , PARTFUN1:def 2;
L436: ( dom ( DataPart D40 ) ) = ( ( dom D40 ) /\ D39 ) by RELAT_1:61;
L437: ( dom ( DataPart D40 ) ) c= ( (the carrier of ( SCM+FSA )) /\ D39 ) by L436 , L435 , XBOOLE_1:26;
L438: ( dom ( DataPart D40 ) ) c= ( ( dom ( Comput (( C74 +* C71 ) , C73 , D42) ) ) /\ D39 ) by L437 , PARTFUN1:def 2;
L439: ( dom ( DataPart D40 ) ) c= ( dom ( DataPart ( Comput (( C74 +* C71 ) , C73 , D42) ) ) ) by L438 , RELAT_1:61;
L440: (( D41 | D39 ) = ( ( DataPart ( Comput (( C74 +* C71 ) , C73 , D42) ) ) +* D44 ) & ( DataPart D40 ) c= ( DataPart ( Comput (( C74 +* C71 ) , C73 , D42) ) )) by L439 , L425 , FUNCT_4:71 , GRFUNC_1:2;
L441: ( DataPart ( Comput (( C74 +* C71 ) , C73 , D42) ) ) = ( DataPart D41 ) by L440 , FUNCT_4:98;
reconsider D45 = ( ( D42 + 1 ) + D43 ) as (Element of ( NAT ));
L442: ( Reloc (C72 , ( card C71 )) ) c= ( C71 ";" C72 ) by FUNCT_4:25;
take D45;
set D46 = ( Comput (C74 , C73 , ( D42 + 1 )) );
L443: ( Directed C71 ) c= ( C71 ";" C72 ) by SCMFSA6A:16;
L444: ( C74 +* C71 ) halts_on C73 by L26 , FUNCT_4:25;
L445: ( IC ( Comput (C74 , C73 , ( ( LifeSpan (( C74 +* C71 ) , C73) ) + 1 )) ) ) = ( card C71 ) by L444 , L218 , L443 , L424 , XBOOLE_1:1;
L446: ( C74 +* ( C71 ";" C72 ) ) = C74 by L424 , FUNCT_4:98;
L447: ( DataPart ( Comput (C74 , C73 , D42) ) ) = ( DataPart D41 ) by L441 , L446 , L329 , L444;
L448: ( Comput (C74 , C73 , ( ( D42 + 1 ) + D43 )) ) = ( Comput (C74 , ( Comput (C74 , C73 , ( D42 + 1 )) ) , D43) ) by EXTPRO_1:4;
L449: ( DataPart ( Comput (C74 , C73 , ( D42 + 1 )) ) ) = ( DataPart D41 ) by L447 , L261 , L443 , L444 , L424 , XBOOLE_1:1;
L450: C72 c= ( ( C74 +* C71 ) +* C72 ) by FUNCT_4:25;
L451: ( Reloc (C72 , ( card C71 )) ) c= C74 by L442 , L424 , XBOOLE_1:1;
L452: ( IncAddr (( CurInstr (( ( C74 +* C71 ) +* C72 ) , ( Comput (( ( C74 +* C71 ) +* C72 ) , D41 , D43) )) ) , ( card C71 )) ) = ( CurInstr (C74 , ( Comput (C74 , D46 , D43) )) ) by L138 , L450 , L449 , L445 , L451;
L453: ( dom C74 ) = ( NAT ) by PARTFUN1:def 2;
thus L454: ( IC ( Comput (C74 , C73 , D45) ) ) in ( dom C74 ) by L453;
L455: C72 c= ( ( C74 +* C71 ) +* C72 ) by FUNCT_4:25;
L456: ( ( C74 +* C71 ) +* C72 ) halts_on D41 by L455 , AMISTD_1:def 11;
L457: ( CurInstr (C74 , ( Comput (C74 , C73 , D45) )) ) = ( IncAddr (( halt ( SCM+FSA ) ) , ( card C71 )) ) by L456 , L452 , L448 , EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
thus L458: ( CurInstr (C74 , ( Comput (C74 , C73 , D45) )) ) = ( halt ( SCM+FSA ) ) by L457;
end;
end;
theorem
L460: (for R13 being (Instruction-Sequence of ( SCM+FSA )) holds (for B65 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B66 being  keeping_0 (Program of ( SCM+FSA )) holds ((not ( R13 +* B66 ) halts_on B65) implies (for B67 being (Program of ( SCM+FSA )) holds (for B68 being (Element of ( NAT )) holds ( Comput (( R13 +* B66 ) , B65 , B68) ) = ( Comput (( R13 +* ( B66 ";" B67 ) ) , B65 , B68) )))))))
proof
let R13 being (Instruction-Sequence of ( SCM+FSA ));
let C76 being ( 0 ) -started (State of ( SCM+FSA ));
let C77 being  keeping_0 (Program of ( SCM+FSA ));
assume L461: (not ( R13 +* C77 ) halts_on C76);
let C78 being (Program of ( SCM+FSA ));
defpred S11[ Nat ] means ( Comput (( R13 +* C77 ) , C76 , $1) ) = ( Comput (( R13 +* ( C77 ";" C78 ) ) , C76 , $1) );
L462: (for R1 being (Element of ( NAT )) holds (S11[ R1 ] implies S11[ ( R1 + 1 ) ]))
proof
L463: ( dom ( C77 ";" C78 ) ) = ( ( dom ( Directed C77 ) ) \/ ( dom ( Reloc (C78 , ( card C77 )) ) ) ) by FUNCT_4:def 1
.= ( ( dom C77 ) \/ ( dom ( Reloc (C78 , ( card C77 )) ) ) ) by FUNCT_4:99;
L464: ( dom C77 ) c= ( dom ( C77 ";" C78 ) ) by L463 , XBOOLE_1:7;
let R1 being (Element of ( NAT ));
L465: ( Comput (( R13 +* C77 ) , C76 , ( R1 + 1 )) ) = ( Following (( R13 +* C77 ) , ( Comput (( R13 +* C77 ) , C76 , R1) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( R13 +* C77 ) , ( Comput (( R13 +* C77 ) , C76 , R1) )) ) , ( Comput (( R13 +* C77 ) , C76 , R1) )) );
L466: ( Comput (( R13 +* ( C77 ";" C78 ) ) , C76 , ( R1 + 1 )) ) = ( Following (( R13 +* ( C77 ";" C78 ) ) , ( Comput (( R13 +* ( C77 ";" C78 ) ) , C76 , R1) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( R13 +* ( C77 ";" C78 ) ) , ( Comput (( R13 +* ( C77 ";" C78 ) ) , C76 , R1) )) ) , ( Comput (( R13 +* ( C77 ";" C78 ) ) , C76 , R1) )) );
L467: C77 c= ( R13 +* C77 ) by FUNCT_4:25;
L468: ( IC ( Comput (( R13 +* C77 ) , C76 , R1) ) ) in ( dom C77 ) by L467 , AMISTD_1:def 10;
assume L469: ( Comput (( R13 +* C77 ) , C76 , R1) ) = ( Comput (( R13 +* ( C77 ";" C78 ) ) , C76 , R1) );
L470: ( dom ( R13 +* C77 ) ) = ( NAT ) by PARTFUN1:def 2;
L471: ( ( R13 +* C77 ) /. ( IC ( Comput (( R13 +* C77 ) , C76 , R1) ) ) ) = ( ( R13 +* C77 ) . ( IC ( Comput (( R13 +* C77 ) , C76 , R1) ) ) ) by L470 , PARTFUN1:def 6;
L472: ( dom ( R13 +* ( C77 ";" C78 ) ) ) = ( NAT ) by PARTFUN1:def 2;
L473: ( ( R13 +* ( C77 ";" C78 ) ) /. ( IC ( Comput (( R13 +* ( C77 ";" C78 ) ) , C76 , R1) ) ) ) = ( ( R13 +* ( C77 ";" C78 ) ) . ( IC ( Comput (( R13 +* ( C77 ";" C78 ) ) , C76 , R1) ) ) ) by L472 , PARTFUN1:def 6;
L474: ( C77 ";" C78 ) c= ( R13 +* ( C77 ";" C78 ) ) by FUNCT_4:25;
L475: ( CurInstr (( R13 +* C77 ) , ( Comput (( R13 +* C77 ) , C76 , R1) )) ) = ( C77 . ( IC ( Comput (( R13 +* C77 ) , C76 , R1) ) ) ) by L468 , L471 , L467 , GRFUNC_1:2;
L476: ( C77 . ( IC ( Comput (( R13 +* C77 ) , C76 , R1) ) ) ) <> ( halt ( SCM+FSA ) ) by L475 , L461 , EXTPRO_1:29;
L477: ( CurInstr (( R13 +* C77 ) , ( Comput (( R13 +* C77 ) , C76 , R1) )) ) = ( ( C77 ";" C78 ) . ( IC ( Comput (( R13 +* C77 ) , C76 , R1) ) ) ) by L476 , L468 , L475 , SCMFSA6A:15
.= ( CurInstr (( R13 +* ( C77 ";" C78 ) ) , ( Comput (( R13 +* ( C77 ";" C78 ) ) , C76 , R1) )) ) by L469 , L468 , L464 , L473 , L474 , GRFUNC_1:2;
thus L478: thesis by L477 , L469 , L465 , L466;
end;
L479: S11[ ( 0 ) ];
thus L480: (for B69 being (Element of ( NAT )) holds S11[ B69 ]) from NAT_1:sch 1(L479 , L462);
end;
theorem
L481: (for R13 being (Instruction-Sequence of ( SCM+FSA )) holds (for B70 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B71 being  keeping_0 (Program of ( SCM+FSA )) holds (( R13 +* B71 ) halts_on B70 implies (for B72 being  paraclosed (Program of ( SCM+FSA )) holds (( B71 ";" B72 ) c= R13 implies (for B73 being (Element of ( NAT )) holds ( IncIC (( Comput (( ( R13 +* B71 ) +* B72 ) , ( Initialize ( Result (( R13 +* B71 ) , B70) ) ) , B73) ) , ( card B71 )) ) = ( Comput (( R13 +* ( B71 ";" B72 ) ) , B70 , ( ( ( LifeSpan (( R13 +* B71 ) , B70) ) + 1 ) + B73 )) ))))))))
proof
let R13 being (Instruction-Sequence of ( SCM+FSA ));
let C79 being ( 0 ) -started (State of ( SCM+FSA ));
let C80 being  keeping_0 (Program of ( SCM+FSA ));
assume L482: ( R13 +* C80 ) halts_on C79;
let C81 being  paraclosed (Program of ( SCM+FSA ));
set D47 = ( Result (( R13 +* C80 ) , C79) );
set D48 = ( Start-At (( 0 ) , ( SCM+FSA )) );
set D49 = ( D47 +* D48 );
defpred S12[ Nat ] means ( IncIC (( Comput (( ( R13 +* C80 ) +* C81 ) , D49 , $1) ) , ( card C80 )) ) = ( Comput (( R13 +* ( C80 ";" C81 ) ) , C79 , ( ( ( LifeSpan (( R13 +* C80 ) , C79) ) + 1 ) + $1 )) );
assume L483: ( C80 ";" C81 ) c= R13;
L484: ( R13 +* ( C80 ";" C81 ) ) = R13 by L483 , FUNCT_4:98;
L485: (for B74 being (Element of ( NAT )) holds (S12[ B74 ] implies S12[ ( B74 + 1 ) ]))
proof
let C82 being (Element of ( NAT ));
set D50 = ( C82 + 1 );
set D51 = ( Comput (( ( R13 +* C80 ) +* C81 ) , D49 , C82) );
set D52 = ( IncIC (D51 , ( card C80 )) );
set D53 = ( Comput (( R13 +* ( C80 ";" C81 ) ) , C79 , ( ( ( LifeSpan (( R13 +* C80 ) , C79) ) + 1 ) + C82 )) );
set D54 = ( Comput (( ( R13 +* C80 ) +* C81 ) , D49 , D50) );
set D55 = ( IncIC (D54 , ( card C80 )) );
set D56 = ( Comput (( R13 +* ( C80 ";" C81 ) ) , C79 , ( ( ( LifeSpan (( R13 +* C80 ) , C79) ) + 1 ) + D50 )) );
assume L486: ( IncIC (( Comput (( ( R13 +* C80 ) +* C81 ) , D49 , C82) ) , ( card C80 )) ) = ( Comput (( R13 +* ( C80 ";" C81 ) ) , C79 , ( ( ( LifeSpan (( R13 +* C80 ) , C79) ) + 1 ) + C82 )) );
L487: ( IncAddr (( CurInstr (( ( R13 +* C80 ) +* C81 ) , D51) ) , ( card C80 )) ) = ( CurInstr (( R13 +* ( C80 ";" C81 ) ) , D53) )
proof
L488: ( C80 ";" C81 ) c= ( R13 +* ( C80 ";" C81 ) ) by FUNCT_4:25;
L489: ( Reloc (C81 , ( card C80 )) ) c= ( C80 ";" C81 ) by FUNCT_4:25;
L490: ( Reloc (C81 , ( card C80 )) ) c= ( R13 +* ( C80 ";" C81 ) ) by L489 , L488 , XBOOLE_1:1;
L491: ( dom ( R13 +* ( C80 ";" C81 ) ) ) = ( NAT ) by PARTFUN1:def 2;
L492: ( CurInstr (( R13 +* ( C80 ";" C81 ) ) , D53) ) = ( ( R13 +* ( C80 ";" C81 ) ) . ( IC D52 ) ) by L486 , L491 , PARTFUN1:def 6
.= ( ( R13 +* ( C80 ";" C81 ) ) . ( ( IC D51 ) + ( card C80 ) ) ) by FUNCT_4:113;
reconsider D57 = ( IC D51 ) as (Element of ( NAT ));
L493: C81 c= ( ( R13 +* C80 ) +* C81 ) by FUNCT_4:25;
L494: ( IC D51 ) in ( dom C81 ) by L493 , AMISTD_1:def 10;
L495: ( IC D51 ) in ( dom ( IncAddr (C81 , ( card C80 )) ) ) by L494 , COMPOS_1:def 21;
L496: ( ( Shift (( IncAddr (C81 , ( card C80 )) ) , ( card C80 )) ) . ( ( IC D51 ) + ( card C80 ) ) ) = ( ( IncAddr (C81 , ( card C80 )) ) . D57 ) by L495 , VALUED_1:def 12
.= ( IncAddr (( C81 /. D57 ) , ( card C80 )) ) by L494 , COMPOS_1:def 21;
L497: ( dom ( Shift (( IncAddr (C81 , ( card C80 )) ) , ( card C80 )) ) ) = { ( B75 + ( card C80 ) ) where B75 is (Element of ( NAT )) : B75 in ( dom ( IncAddr (C81 , ( card C80 )) ) ) } by VALUED_1:def 12;
L498: ( D57 + ( card C80 ) ) in ( dom ( Shift (( IncAddr (C81 , ( card C80 )) ) , ( card C80 )) ) ) by L497 , L495;
L499: C81 c= ( ( R13 +* C80 ) +* C81 ) by FUNCT_4:25;
L500: ( C81 /. D57 ) = ( C81 . D57 ) by L494 , PARTFUN1:def 6;
thus L501: ( IncAddr (( CurInstr (( ( R13 +* C80 ) +* C81 ) , D51) ) , ( card C80 )) ) = ( IncAddr (( ( ( R13 +* C80 ) +* C81 ) . ( IC D51 ) ) , ( card C80 )) ) by PBOOLE:143
.= ( ( Reloc (C81 , ( card C80 )) ) . ( ( IC D51 ) + ( card C80 ) ) ) by L496 , L499 , L500 , L494 , GRFUNC_1:2
.= ( CurInstr (( R13 +* ( C80 ";" C81 ) ) , D53) ) by L492 , L490 , L498 , GRFUNC_1:2;
end;
L502: ( Exec (( CurInstr (( R13 +* ( C80 ";" C81 ) ) , D53) ) , D53) ) = ( IncIC (( Following (( ( R13 +* C80 ) +* C81 ) , D51) ) , ( card C80 )) ) by L487 , L486 , AMISTD_5:4;
L503: D56 = ( Comput (( R13 +* ( C80 ";" C81 ) ) , C79 , ( ( ( ( LifeSpan (( R13 +* C80 ) , C79) ) + 1 ) + C82 ) + 1 )) );
L504: D56 = ( Following (( R13 +* ( C80 ";" C81 ) ) , D53) ) by L503 , EXTPRO_1:3;
L505: (for B76 being Int-Location holds ( D55 . B76 ) = ( D56 . B76 )) by L504 , L502 , EXTPRO_1:3;
L506: (for B77 being FinSeq-Location holds ( D55 . B77 ) = ( D56 . B77 )) by L504 , L502 , EXTPRO_1:3;
L507: ( IC D55 ) = ( ( IC D54 ) + ( card C80 ) ) by FUNCT_4:113
.= ( ( IC ( Following (( ( R13 +* C80 ) +* C81 ) , D51) ) ) + ( card C80 ) ) by EXTPRO_1:3;
L508: ( IC D55 ) = ( IC D56 ) by L507 , L504 , L502 , FUNCT_4:113;
thus L509: thesis by L508 , L505 , L506 , SCMFSA_2:61;
end;
L510: ( Directed C80 ) c= ( C80 ";" C81 ) by SCMFSA6A:16;
L511:
now
set D58 = ( Comput (( R13 +* ( C80 ";" C81 ) ) , C79 , ( ( ( LifeSpan (( R13 +* C80 ) , C79) ) + 1 ) + ( 0 ) )) );
set D59 = ( IncIC (D49 , ( card C80 )) );
thus L512: ( IC D59 ) = ( ( IC D49 ) + ( card C80 ) ) by FUNCT_4:113
.= ( ( 0 ) + ( card C80 ) ) by FUNCT_4:113
.= ( IC D58 ) by L482 , L510 , L218 , L484 , L483 , XBOOLE_1:1;
L513: ( DataPart ( Comput (R13 , C79 , ( LifeSpan (( R13 +* C80 ) , C79) )) ) ) = ( DataPart ( Comput (R13 , C79 , ( ( LifeSpan (( R13 +* C80 ) , C79) ) + 1 )) ) ) by L482 , L510 , L261 , L483 , XBOOLE_1:1;
set D60 = ( LifeSpan (( R13 +* C80 ) , C79) );
thus L514:now
let C83 being Int-Location;
L515: (not C83 in ( dom D48 )) by SCMFSA_2:102;
L516: (not C83 in ( dom ( Start-At (( ( IC D49 ) + ( card C80 ) ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
thus L517: ( D59 . C83 ) = ( D49 . C83 ) by L516 , FUNCT_4:11
.= ( D47 . C83 ) by L515 , FUNCT_4:11
.= ( ( Comput (( R13 +* C80 ) , C79 , ( LifeSpan (( R13 +* C80 ) , C79) )) ) . C83 ) by L482 , EXTPRO_1:23
.= ( ( Comput (( R13 +* ( C80 ";" C81 ) ) , C79 , ( LifeSpan (( R13 +* C80 ) , C79) )) ) . C83 ) by L329 , L482
.= ( D58 . C83 ) by L513 , L484 , SCMFSA_M:2;
end;
let C84 being FinSeq-Location;
L518: (not C84 in ( dom D48 )) by SCMFSA_2:103;
L519: (not C84 in ( dom ( Start-At (( ( IC D49 ) + ( card C80 ) ) , ( SCM+FSA )) ) )) by SCMFSA_2:103;
thus L520: ( D59 . C84 ) = ( D49 . C84 ) by L519 , FUNCT_4:11
.= ( D47 . C84 ) by L518 , FUNCT_4:11
.= ( ( Comput (( R13 +* C80 ) , C79 , ( LifeSpan (( R13 +* C80 ) , C79) )) ) . C84 ) by L482 , EXTPRO_1:23
.= ( ( Comput (( R13 +* ( C80 ";" C81 ) ) , C79 , ( LifeSpan (( R13 +* C80 ) , C79) )) ) . C84 ) by L329 , L482
.= ( D58 . C84 ) by L513 , L484 , SCMFSA_M:2;
end;
L521: S12[ ( 0 ) ] by L511 , SCMFSA_2:61;
L522: (for B78 being (Element of ( NAT )) holds S12[ B78 ]) from NAT_1:sch 1(L521 , L485);
thus L523: thesis by L522;
end;
registration
let C85 , C86 being  keeping_0 (Program of ( SCM+FSA ));
cluster ( C85 ";" C86 ) ->  keeping_0;
coherence
proof
let C87 being ( 0 ) -started (State of ( SCM+FSA ));
let R13 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L524: ( C85 ";" C86 ) c= R13;
L525: C85 c= ( R13 +* C85 ) by FUNCT_4:25;
L526: R13 = ( R13 +* ( C85 ";" C86 ) ) by L524 , FUNCT_4:98;
per cases ;
suppose L527: ( R13 +* C85 ) halts_on C87;

let C88 being (Element of ( NAT ));
thus L528:now
per cases ;
suppose L529: C88 <= ( LifeSpan (( R13 +* C85 ) , C87) );

L530: ( ( Comput (( R13 +* C85 ) , C87 , C88) ) . ( intloc ( 0 ) ) ) = ( C87 . ( intloc ( 0 ) ) ) by L2 , L525;
thus L531: thesis by L530 , L526 , L329 , L527 , L529;
end;
suppose L532: C88 > ( LifeSpan (( R13 +* C85 ) , C87) );

set D61 = ( LifeSpan (( R13 +* C85 ) , C87) );
consider C89 being (Element of ( NAT )) such that L533: C88 = ( D61 + C89 ) and L534: 1 <= C89 by L532 , FINSEQ_4:84;
consider C90 being Nat such that L535: C89 = ( 1 + C90 ) by L534 , NAT_1:10;
L536: (( dom D1 ) = { ( IC ( SCM+FSA ) ) } & ( intloc ( 0 ) ) <> ( IC ( SCM+FSA ) )) by FUNCOP_1:13 , SCMFSA_2:56;
L537: (not ( intloc ( 0 ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L536 , TARSKI:def 1;
reconsider D62 = C90 as (Element of ( NAT )) by ORDINAL1:def 12;
L538: (( dom ( Start-At (( ( IC ( Comput (( ( R13 +* C85 ) +* C86 ) , ( Initialize ( Result (( R13 +* C85 ) , C87) ) ) , D62) ) ) + ( card C85 ) ) , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } & ( intloc ( 0 ) ) <> ( IC ( SCM+FSA ) )) by FUNCOP_1:13 , SCMFSA_2:56;
L539: (not ( intloc ( 0 ) ) in ( dom ( Start-At (( ( IC ( Comput (( ( R13 +* C85 ) +* C86 ) , ( Initialize ( Result (( R13 +* C85 ) , C87) ) ) , D62) ) ) + ( card C85 ) ) , ( SCM+FSA )) ) )) by L538 , TARSKI:def 1;
L540: ( IncIC (( Comput (( ( R13 +* C85 ) +* C86 ) , ( Initialize ( Result (( R13 +* C85 ) , C87) ) ) , D62) ) , ( card C85 )) ) = ( Comput (( R13 +* ( C85 ";" C86 ) ) , C87 , ( ( D61 + 1 ) + D62 )) ) by L527 , L481 , L524;
L541: C86 c= ( ( R13 +* C85 ) +* C86 ) by FUNCT_4:25;
L542: ( ( Comput (( ( R13 +* C85 ) +* C86 ) , ( Initialize ( Result (( R13 +* C85 ) , C87) ) ) , D62) ) . ( intloc ( 0 ) ) ) = ( ( Initialize ( Result (( R13 +* C85 ) , C87) ) ) . ( intloc ( 0 ) ) ) by L2 , L541
.= ( ( Result (( R13 +* C85 ) , C87) ) . ( intloc ( 0 ) ) ) by L537 , FUNCT_4:11
.= ( ( Comput (( R13 +* C85 ) , C87 , ( LifeSpan (( R13 +* C85 ) , C87) )) ) . ( intloc ( 0 ) ) ) by L527 , EXTPRO_1:23
.= ( C87 . ( intloc ( 0 ) ) ) by L2 , L525;
thus L543: thesis by L542 , L533 , L535 , L540 , L526 , L539 , FUNCT_4:11;
end;
end;
end;
suppose L529: (not ( R13 +* C85 ) halts_on C87);

let C91 being (Element of ( NAT ));
L530: ( ( Comput (( R13 +* C85 ) , C87 , C91) ) . ( intloc ( 0 ) ) ) = ( C87 . ( intloc ( 0 ) ) ) by L2 , L525;
thus L531: thesis by L530 , L526 , L529 , L460;
end;
end;
end;
theorem
L534: (for R10 being (State of ( SCM+FSA )) holds (for R13 being (Instruction-Sequence of ( SCM+FSA )) holds (for B79 being  keeping_0  parahalting (Program of ( SCM+FSA )) holds (for B80 being  parahalting (Program of ( SCM+FSA )) holds ( LifeSpan (( R13 +* ( B79 ";" B80 ) ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) = ( ( ( LifeSpan (( R13 +* B79 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) + 1 ) + ( LifeSpan (( ( R13 +* B79 ) +* B80 ) , ( ( Result (( R13 +* B79 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) )))))
proof
let R10 being (State of ( SCM+FSA ));
let R13 being (Instruction-Sequence of ( SCM+FSA ));
let C92 being  keeping_0  parahalting (Program of ( SCM+FSA ));
let C93 being  parahalting (Program of ( SCM+FSA ));
L535: ( C92 ";" C93 ) c= ( R13 +* ( C92 ";" C93 ) ) by FUNCT_4:25;
L536: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by FUNCT_4:25;
L537: ( LifeSpan (( R13 +* ( C92 ";" C93 ) ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) = ( ( ( LifeSpan (( ( R13 +* ( C92 ";" C93 ) ) +* C92 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) + 1 ) + ( LifeSpan (( ( ( R13 +* ( C92 ";" C93 ) ) +* C92 ) +* C93 ) , ( ( Result (( ( R13 +* ( C92 ";" C93 ) ) +* C92 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) ) by L536 , L351 , L535;
L538: C93 c= ( ( ( R13 +* ( C92 ";" C93 ) ) +* C92 ) +* C93 ) by FUNCT_4:25;
L539: C93 c= ( ( R13 +* C92 ) +* C93 ) by FUNCT_4:25;
L540: C92 c= ( ( R13 +* ( C92 ";" C93 ) ) +* C92 ) by FUNCT_4:25;
L541: C92 c= ( R13 +* C92 ) by FUNCT_4:25;
L542: ( ( Result (( ( R13 +* ( C92 ";" C93 ) ) +* C92 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( ( Result (( R13 +* C92 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L175 , L540 , L541;
L543: ( LifeSpan (( R13 +* C92 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) = ( LifeSpan (( ( R13 +* ( C92 ";" C93 ) ) +* C92 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) by L175 , L540 , L541;
thus L544: thesis by L542 , L175 , L538 , L539 , L537 , L543;
end;
theorem
L545: (for R10 being (State of ( SCM+FSA )) holds (for R13 being (Instruction-Sequence of ( SCM+FSA )) holds (for B81 being  keeping_0  parahalting (Program of ( SCM+FSA )) holds (for B82 being  parahalting (Program of ( SCM+FSA )) holds ( IExec (( B81 ";" B82 ) , R13 , R10) ) = ( IncIC (( IExec (B82 , R13 , ( IExec (B81 , R13 , R10) )) ) , ( card B81 )) )))))
proof
let R10 being (State of ( SCM+FSA ));
let R13 being (Instruction-Sequence of ( SCM+FSA ));
set D63 = ( ( Int-Locations ) \/ ( FinSeq-Locations ) );
set D64 = ( NAT );
let C94 being  keeping_0  parahalting (Program of ( SCM+FSA ));
let C95 being  parahalting (Program of ( SCM+FSA ));
set D65 = ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) );
set D66 = ( R13 +* C94 );
L546: C94 c= ( R13 +* C94 ) by FUNCT_4:25;
set D67 = ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) );
set D68 = ( R13 +* ( C94 ";" C95 ) );
set D69 = ( ( Comput (D66 , D65 , ( LifeSpan (D66 , D65) )) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) );
set D70 = ( D66 +* C95 );
set D71 = ( LifeSpan (D66 , D65) );
set D72 = ( LifeSpan (D70 , D69) );
L547: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= D67 by FUNCT_4:25;
L548: C94 c= ( D68 +* C94 ) by FUNCT_4:25;
L549: ( C94 ";" C95 ) c= ( R13 +* ( C94 ";" C95 ) ) by FUNCT_4:25;
L550: ( LifeSpan (( D68 +* C94 ) , D67) ) = D71 by L175 , L546 , L548;
L551: ( Reloc (C95 , ( card C94 )) ) c= ( R13 +* ( C94 ";" C95 ) ) by L547 , L351 , L549;
L552: C94 c= D66 by FUNCT_4:25;
L553: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= D65 by FUNCT_4:25;
L554: D69 = ( ( Result (D66 , D65) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L27 , L552 , L553 , EXTPRO_1:23;
L555: ( ( ( R13 +* ( C94 ";" C95 ) ) +* C94 ) +* ( C94 ";" C95 ) ) = ( ( R13 +* ( C94 ";" C95 ) ) +* ( C94 +* ( C94 ";" C95 ) ) ) by FUNCT_4:14
.= ( R13 +* ( ( C94 ";" C95 ) +* ( C94 +* ( C94 ";" C95 ) ) ) ) by FUNCT_4:14
.= ( R13 +* ( ( C94 ";" C95 ) +* ( C94 ";" C95 ) ) ) by SCMFSA6A:18;
L556: ( ( R13 +* C94 ) +* ( C94 ";" C95 ) ) = ( R13 +* ( C94 +* ( C94 ";" C95 ) ) ) by FUNCT_4:14
.= ( R13 +* ( ( C94 ";" C95 ) +* ( C94 ";" C95 ) ) ) by SCMFSA6A:18;
L557: ( ( R13 +* ( C94 ";" C95 ) ) +* C94 ) halts_on D67 by L26 , FUNCT_4:25;
L558: ( DataPart ( Comput (( ( R13 +* ( C94 ";" C95 ) ) +* C94 ) , D67 , D71) ) ) = ( DataPart ( Comput (( R13 +* ( ( C94 ";" C95 ) +* ( C94 ";" C95 ) ) ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) , D71) ) ) by L555 , L557 , L197 , L550 , FUNCT_4:25
.= ( DataPart ( Comput (( R13 +* C94 ) , D65 , D71) ) ) by L556 , L552 , L553 , L197 , L27;
L559: ( DataPart ( ( Comput (( D68 +* C94 ) , D67 , D71) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) = ( ( DataPart ( Comput (D66 , D65 , D71) ) ) +* ( DataPart ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) by L558 , FUNCT_4:71
.= ( DataPart D69 ) by FUNCT_4:71;
L560: C95 c= ( ( R13 +* C94 ) +* C95 ) by FUNCT_4:25;
L561: ( IC ( Comput (D68 , D67 , ( D71 + 1 )) ) ) = ( card C94 ) by L547 , L550 , L351 , L549;
L562: ( DataPart ( Comput (D68 , D67 , ( D71 + 1 )) ) ) = ( DataPart D69 ) by L559 , L547 , L550 , L351 , L549;
L563: ( DataPart ( Comput (( R13 +* ( C94 ";" C95 ) ) , ( Comput (( R13 +* ( C94 ";" C95 ) ) , D67 , ( D71 + 1 )) ) , D72) ) ) = ( DataPart ( Comput (( ( R13 +* C94 ) +* C95 ) , D69 , D72) ) ) by L562 , L138 , L560 , L551 , L561;
L564: ( IC ( Comput (( R13 +* ( C94 ";" C95 ) ) , ( Comput (( R13 +* ( C94 ";" C95 ) ) , D67 , ( D71 + 1 )) ) , D72) ) ) = ( ( IC ( Comput (( ( R13 +* C94 ) +* C95 ) , D69 , D72) ) ) + ( card C94 ) ) by L561 , L138 , L551 , L560 , L562;
L565: C95 c= D70 by FUNCT_4:25;
L566: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= D69 by FUNCT_4:25;
L567: C95 c= ( D66 +* C95 ) by FUNCT_4:25;
L568: C95 c= ( R13 +* C95 ) by FUNCT_4:25;
L569: ( Result (( R13 +* C95 ) , ( ( IExec (C94 , R13 , R10) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) = ( Result (D70 , D69) ) by L175 , L568 , L565 , L554;
L570: ( C94 ";" C95 ) c= D68 by FUNCT_4:25;
L571: ( IExec (( C94 ";" C95 ) , R13 , R10) ) = ( Comput (D68 , D67 , ( LifeSpan (D68 , D67) )) ) by L570 , L547 , L27 , EXTPRO_1:23
.= ( Comput (D68 , D67 , ( ( D71 + 1 ) + D72 )) ) by L554 , L534;
L572: ( DataPart ( IExec (( C94 ";" C95 ) , R13 , R10) ) ) = ( DataPart ( Comput (D70 , D69 , D72) ) ) by L571 , L563 , EXTPRO_1:4
.= ( DataPart ( IExec (C95 , R13 , ( IExec (C94 , R13 , R10) )) ) ) by L566 , L569 , L27 , L565 , EXTPRO_1:23;
L573: ( IC ( IExec (( C94 ";" C95 ) , R13 , R10) ) ) = ( IC ( Comput (D68 , D67 , ( LifeSpan (D68 , D67) )) ) ) by L570 , L547 , L27 , EXTPRO_1:23
.= ( IC ( Comput (D68 , D67 , ( ( D71 + 1 ) + D72 )) ) ) by L554 , L534
.= ( ( IC ( Comput (D70 , D69 , D72) ) ) + ( card C94 ) ) by L564 , EXTPRO_1:4
.= ( ( IC ( Result (D70 , D69) ) ) + ( card C94 ) ) by L566 , L27 , L565 , EXTPRO_1:23
.= ( ( IC ( Result (( D66 +* C95 ) , ( ( Result (D66 , D65) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) ) + ( card C94 ) ) by L553 , L27 , L552 , EXTPRO_1:23
.= ( ( IC ( IExec (C95 , R13 , ( IExec (C94 , R13 , R10) )) ) ) + ( card C94 ) ) by L567 , L568 , L175;
thus L574:now
reconsider D73 = ( ( IC ( IExec (C95 , R13 , ( IExec (C94 , R13 , R10) )) ) ) + ( card C94 ) ) as (Element of ( NAT ));
L575: ( dom ( Start-At (D73 , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L576:
now
let C96 being set;
assume L577: C96 in ( dom ( IExec (( C94 ";" C95 ) , R13 , R10) ) );
per cases  by L577 , SCMFSA_M:1;
suppose L578: C96 is Int-Location;

L579: C96 <> ( IC ( SCM+FSA ) ) by L578 , SCMFSA_2:56;
L580: (not C96 in ( dom ( Start-At (D73 , ( SCM+FSA )) ) )) by L579 , L575 , TARSKI:def 1;
L581: ( ( IExec (( C94 ";" C95 ) , R13 , R10) ) . C96 ) = ( ( IExec (C95 , R13 , ( IExec (C94 , R13 , R10) )) ) . C96 ) by L572 , L578 , SCMFSA_M:2;
thus L582: ( ( IExec (( C94 ";" C95 ) , R13 , R10) ) . C96 ) = ( ( ( IExec (C95 , R13 , ( IExec (C94 , R13 , R10) )) ) +* ( Start-At (( ( IC ( IExec (C95 , R13 , ( IExec (C94 , R13 , R10) )) ) ) + ( card C94 ) ) , ( SCM+FSA )) ) ) . C96 ) by L581 , L580 , FUNCT_4:11;
end;
suppose L583: C96 is FinSeq-Location;

L584: C96 <> ( IC ( SCM+FSA ) ) by L583 , SCMFSA_2:57;
L585: (not C96 in ( dom ( Start-At (D73 , ( SCM+FSA )) ) )) by L584 , L575 , TARSKI:def 1;
L586: ( ( IExec (( C94 ";" C95 ) , R13 , R10) ) . C96 ) = ( ( IExec (C95 , R13 , ( IExec (C94 , R13 , R10) )) ) . C96 ) by L572 , L583 , SCMFSA_M:2;
thus L587: ( ( IExec (( C94 ";" C95 ) , R13 , R10) ) . C96 ) = ( ( ( IExec (C95 , R13 , ( IExec (C94 , R13 , R10) )) ) +* ( Start-At (( ( IC ( IExec (C95 , R13 , ( IExec (C94 , R13 , R10) )) ) ) + ( card C94 ) ) , ( SCM+FSA )) ) ) . C96 ) by L586 , L585 , FUNCT_4:11;
end;
suppose L588: C96 = ( IC ( SCM+FSA ) );

L589: C96 in { ( IC ( SCM+FSA ) ) } by L588 , TARSKI:def 1;
L590: C96 in ( dom ( Start-At (D73 , ( SCM+FSA )) ) ) by L589 , FUNCOP_1:13;
thus L591: ( ( IExec (( C94 ";" C95 ) , R13 , R10) ) . C96 ) = ( ( Start-At (D73 , ( SCM+FSA )) ) . ( IC ( SCM+FSA ) ) ) by L573 , L588 , FUNCOP_1:72
.= ( ( ( IExec (C95 , R13 , ( IExec (C94 , R13 , R10) )) ) +* ( Start-At (( ( IC ( IExec (C95 , R13 , ( IExec (C94 , R13 , R10) )) ) ) + ( card C94 ) ) , ( SCM+FSA )) ) ) . C96 ) by L588 , L590 , FUNCT_4:13;
end;
end;
L593: ( dom ( IExec (( C94 ";" C95 ) , R13 , R10) ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2
.= ( dom ( ( IExec (C95 , R13 , ( IExec (C94 , R13 , R10) )) ) +* ( Start-At (( ( IC ( IExec (C95 , R13 , ( IExec (C94 , R13 , R10) )) ) ) + ( card C94 ) ) , ( SCM+FSA )) ) ) ) by PARTFUN1:def 2;
thus L594: thesis by L593 , L576 , FUNCT_1:2;
end;
end;
theorem
L575: (for R10 being (State of ( SCM+FSA )) holds (for B83 being (Instruction-Sequence of ( SCM+FSA )) holds (not ( B83 +* (( IC R10 ) , ( goto ( IC R10 ) )) ) halts_on R10))) by L34;
