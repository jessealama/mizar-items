:: Closure Operators and Subalgebras
::  by Grzegorz Bancerek
::
:: Received January 15, 1997
:: Copyright (c) 1997-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, ORDERS_2, CAT_1, STRUCT_0, YELLOW_0, SUBSET_1, TARSKI,
      XXREAL_0, RELAT_1, ARYTM_0, WELLORD1, FUNCOP_1, WAYBEL_3, RELAT_2,
      SEQM_3, FUNCT_1, WAYBEL_1, BINOP_1, WAYBEL_0, ORDINAL2, GROUP_6,
      YELLOW_1, FUNCT_2, NEWTON, CARD_3, RLVECT_2, REWRITE1, UNIALG_2,
      ZFMISC_1, LATTICE3, LATTICES, EQREL_1, WAYBEL10;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1, RELSET_1,
      FUNCT_2, CARD_3, FUNCOP_1, STRUCT_0, TMAP_1, QUANTAL1, PRALG_1, WELLORD1,
      ORDERS_2, LATTICE3, ORDERS_3, YELLOW_0, WAYBEL_0, YELLOW_1, YELLOW_2,
      WAYBEL_1, WAYBEL_3, YELLOW_7;
 constructors TOLER_1, BORSUK_1, PRALG_1, QUANTAL1, ORDERS_3, WAYBEL_1,
      WAYBEL_3, TMAP_1;
 registrations FUNCT_1, FUNCT_2, FUNCOP_1, STRUCT_0, LATTICE3, YELLOW_0,
      WAYBEL_0, YELLOW_1, YELLOW_2, WAYBEL_1, RELSET_1;
 requirements SUBSET, BOOLE;
 definitions TARSKI, XBOOLE_0, RELAT_1, QUANTAL1, ORDERS_2, ORDERS_3, LATTICE3,
      YELLOW_0, WAYBEL_0, YELLOW_2, WAYBEL_1, WAYBEL_3, STRUCT_0;
 theorems FUNCT_1, FUNCT_2, YELLOW_0, YELLOW_1, WAYBEL_1, FUNCOP_1, RELSET_1,
      SYSREL, ORDERS_2, LATTICE3, YELLOW_2, WAYBEL_0, ZFMISC_1, TARSKI,
      YELLOW_7, RELAT_1, XBOOLE_0, XBOOLE_1, ORDERS_1, TMAP_1;
 schemes YELLOW_0, FUNCT_2, XBOOLE_0;

begin
scheme SubrelstrEx { F1() -> non  empty RelStr , P1[set] , F2() -> set } : (ex B1 being non  empty  full  strict (SubRelStr of F1()) st (for B2 being (Element of F1()) holds (B2 is (Element of B1) iff P1[ B2 ])))
provided
L1: P1[ F2() ]
and
L2: F2() in (the carrier of F1())
proof
consider C1 being set such that L3: (for B3 being set holds (B3 in C1 iff (B3 in (the carrier of F1()) & P1[ B3 ]))) from XBOOLE_0:sch 1;
L4: C1 c= (the carrier of F1())
proof
let C2 being set;
thus L5: thesis by L3;
end;
reconsider D1 = C1 as non  empty (Subset of F1()) by L4 , L1 , L2 , L3;
set D2 = ( subrelstr D1 );
take D2;
let C3 being (Element of F1());
L6: (the carrier of D2) = D1 by YELLOW_0:def 15;
thus L7: (C3 is (Element of D2) implies P1[ C3 ]) by L6 , L3;
assume L8: P1[ C3 ];
thus L9: thesis by L8 , L3 , L6;
end;
scheme RelstrEq { F3 , F4() -> non  empty RelStr , P2[set] , P3[set , set] } : ( the RelStr of F3() ) = ( the RelStr of F4() )
provided
L10: (for B4 being set holds (B4 is (Element of F3()) iff P2[ B4 ]))
and
L11: (for B5 being set holds (B5 is (Element of F4()) iff P2[ B5 ]))
and
L12: (for B6 , B7 being (Element of F3()) holds (B6 <= B7 iff P3[ B6 , B7 ]))
and
L13: (for B8 , B9 being (Element of F4()) holds (B8 <= B9 iff P3[ B8 , B9 ]))
proof
set D3 = F3();
set D4 = F4();
L14: (the carrier of F3()) = (the carrier of F4())
proof
thus L15:now
let C4 being set;
assume L16: C4 in (the carrier of D3);
reconsider D5 = C4 as (Element of D3) by L16;
L17: P2[ D5 ] by L10;
L18: C4 is (Element of D4) by L17 , L11;
thus L19: C4 in (the carrier of D4) by L18;
end;
let C5 being set;
assume L20: C5 in (the carrier of D4);
reconsider D6 = C5 as (Element of D4) by L20;
L21: P2[ D6 ] by L11;
L22: C5 is (Element of D3) by L21 , L10;
thus L23: thesis by L22;
end;
L24: (the InternalRel of F3()) = (the InternalRel of F4())
proof
let C6 , C7 being set;
thus L25:now
assume L26: [ C6 , C7 ] in (the InternalRel of D3);
reconsider D7 = C6 , D8 = C7 as (Element of D3) by L26 , ZFMISC_1:87;
reconsider D9 = D7 , D10 = D8 as (Element of D4) by L14;
L27: D7 <= D8 by L26 , ORDERS_2:def 5;
L28: P3[ D7 , D8 ] by L27 , L12;
L29: D9 <= D10 by L28 , L13;
thus L30: [ C6 , C7 ] in (the InternalRel of D4) by L29 , ORDERS_2:def 5;
end;
assume L31: [ C6 , C7 ] in (the InternalRel of D4);
reconsider D11 = C6 , D12 = C7 as (Element of D4) by L31 , ZFMISC_1:87;
reconsider D13 = D11 , D14 = D12 as (Element of D3) by L14;
L32: D11 <= D12 by L31 , ORDERS_2:def 5;
L33: P3[ D11 , D12 ] by L32 , L13;
L34: D13 <= D14 by L33 , L12;
thus L35: thesis by L34 , ORDERS_2:def 5;
end;
thus L36: thesis by L24 , L14;
end;
scheme SubrelstrEq1 { F5() -> non  empty RelStr , F6 , F7() -> non  empty  full (SubRelStr of F5()) , P4[set] } : ( the RelStr of F6() ) = ( the RelStr of F7() )
provided
L37: (for B10 being set holds (B10 is (Element of F6()) iff P4[ B10 ]))
and
L38: (for B11 being set holds (B11 is (Element of F7()) iff P4[ B11 ]))
proof
L39: (for B12 being set holds (B12 is (Element of F7()) iff P4[ B12 ])) by L38;
defpred S1[ set , set ] means [ $1 , $2 ] in (the InternalRel of F5());
L40:
now
let C8 , C9 being (Element of F6());
reconsider D15 = C8 , D16 = C9 as (Element of F5()) by YELLOW_0:58;
L41: (D15 <= D16 iff [ D15 , D16 ] in (the InternalRel of F5())) by ORDERS_2:def 5;
thus L42: (C8 <= C9 iff S1[ C8 , C9 ]) by L41 , YELLOW_0:59 , YELLOW_0:60;
end;
L43:
now
let C10 , C11 being (Element of F7());
reconsider D17 = C10 , D18 = C11 as (Element of F5()) by YELLOW_0:58;
L44: (D17 <= D18 iff [ D17 , D18 ] in (the InternalRel of F5())) by ORDERS_2:def 5;
thus L45: (C10 <= C11 iff S1[ C10 , C11 ]) by L44 , YELLOW_0:59 , YELLOW_0:60;
end;
L46: (for B13 being set holds (B13 is (Element of F6()) iff P4[ B13 ])) by L37;
thus L47: thesis from RelstrEq(L46 , L39 , L40 , L43);
end;
scheme SubrelstrEq2 { F8() -> non  empty RelStr , F9 , F10() -> non  empty  full (SubRelStr of F8()) , P5[set] } : ( the RelStr of F9() ) = ( the RelStr of F10() )
provided
L48: (for B14 being (Element of F8()) holds (B14 is (Element of F9()) iff P5[ B14 ]))
and
L49: (for B15 being (Element of F8()) holds (B15 is (Element of F10()) iff P5[ B15 ]))
proof
defpred S2[ set ] means (P5[ $1 ] & $1 is (Element of F8()));
L50:
now
let C12 being set;
L51: (C12 is (Element of F10()) implies C12 is (Element of F8())) by YELLOW_0:58;
thus L52: (C12 is (Element of F10()) iff S2[ C12 ]) by L51 , L49;
end;
L53:
now
let C13 being set;
L54: (C13 is (Element of F9()) implies C13 is (Element of F8())) by YELLOW_0:58;
thus L55: (C13 is (Element of F9()) iff S2[ C13 ]) by L54 , L48;
end;
thus L56: thesis from SubrelstrEq1(L53 , L50);
end;
theorem
L57: (for B16 , B17 being Relation holds ((B16 c= B17 iff ( B16 ~ ) c= ( B17 ~ )) & (( B16 ~ ) c= B17 iff B16 c= ( B17 ~ ))))
proof
let C14 , C15 being Relation;
L58: ( ( C15 ~ ) ~ ) = C15;
L59: ( ( C14 ~ ) ~ ) = C14;
thus L60: thesis by L59 , L58 , SYSREL:11;
end;
theorem
L61: (for B18 , B19 being RelStr holds ((B19 is (SubRelStr of B18) iff ( B19 opp ) is (SubRelStr of ( B18 opp ))) & (( B19 opp ) is (SubRelStr of B18) iff B19 is (SubRelStr of ( B18 opp )))))
proof
let C16 , C17 being RelStr;
thus L62: (C17 is (SubRelStr of C16) implies ( C17 opp ) is (SubRelStr of ( C16 opp )))
proof
assume that
L63: (the carrier of C17) c= (the carrier of C16)
and
L64: (the InternalRel of C17) c= (the InternalRel of C16);
thus L65: ((the carrier of ( C17 opp )) c= (the carrier of ( C16 opp )) & (the InternalRel of ( C17 opp )) c= (the InternalRel of ( C16 opp ))) by L63 , L64 , L57;
end;

thus L66: (( C17 opp ) is (SubRelStr of ( C16 opp )) implies C17 is (SubRelStr of C16))
proof
assume that
L67: (the carrier of ( C17 opp )) c= (the carrier of ( C16 opp ))
and
L68: (the InternalRel of ( C17 opp )) c= (the InternalRel of ( C16 opp ));
thus L69: ((the carrier of C17) c= (the carrier of C16) & (the InternalRel of C17) c= (the InternalRel of C16)) by L67 , L68 , L57;
end;

thus L70: (( C17 opp ) is (SubRelStr of C16) implies C17 is (SubRelStr of ( C16 opp )))
proof
assume that
L71: (the carrier of ( C17 opp )) c= (the carrier of C16)
and
L72: (the InternalRel of ( C17 opp )) c= (the InternalRel of C16);
thus L73: ((the carrier of C17) c= (the carrier of ( C16 opp )) & (the InternalRel of C17) c= (the InternalRel of ( C16 opp ))) by L71 , L72 , L57;
end;

assume that
L74: (the carrier of C17) c= (the carrier of ( C16 opp ))
and
L75: (the InternalRel of C17) c= (the InternalRel of ( C16 opp ));
thus L76: ((the carrier of ( C17 opp )) c= (the carrier of C16) & (the InternalRel of ( C17 opp )) c= (the InternalRel of C16)) by L74 , L75 , L57;
end;
theorem
L77: (for B20 , B21 being RelStr holds ((B21 is  full  full  full  full (SubRelStr of B20) iff ( B21 opp ) is  full  full  full  full (SubRelStr of ( B20 opp ))) & (( B21 opp ) is  full  full  full  full (SubRelStr of B20) iff B21 is  full  full  full  full (SubRelStr of ( B20 opp )))))
proof
let C18 , C19 being RelStr;
L78: ( ( (the InternalRel of C18) |_2 (the carrier of C19) ) ~ ) = ( ( (the InternalRel of C18) ~ ) |_2 (the carrier of C19) ) by ORDERS_1:83;
thus L79:now
assume L80: C19 is  full  full  full  full (SubRelStr of C18);
L81: (the InternalRel of C19) = ( (the InternalRel of C18) |_2 (the carrier of C19) ) by L80 , YELLOW_0:def 14;
thus L82: ( C19 opp ) is  full  full  full  full (SubRelStr of ( C18 opp )) by L81 , L78 , L80 , L61 , YELLOW_0:def 14;
end;
L83: ( ( ( (the InternalRel of C18) ~ ) |_2 (the carrier of C19) ) ~ ) = ( ( ( (the InternalRel of C18) ~ ) ~ ) |_2 (the carrier of C19) ) by ORDERS_1:83;
thus L84:now
assume L85: ( C19 opp ) is  full  full  full  full (SubRelStr of ( C18 opp ));
L86: (the InternalRel of ( C19 opp )) = ( (the InternalRel of ( C18 opp )) |_2 (the carrier of C19) ) by L85 , YELLOW_0:def 14;
thus L87: C19 is  full  full  full  full (SubRelStr of C18) by L86 , L83 , L85 , L61 , YELLOW_0:def 14;
end;
thus L88:now
assume L89: ( C19 opp ) is  full  full  full  full (SubRelStr of C18);
L90: (the InternalRel of ( C19 opp )) = ( (the InternalRel of C18) |_2 (the carrier of C19) ) by L89 , YELLOW_0:def 14;
thus L91: C19 is  full  full  full  full (SubRelStr of ( C18 opp )) by L90 , L78 , L89 , L61 , YELLOW_0:def 14;
end;
assume L92: C19 is  full  full  full  full (SubRelStr of ( C18 opp ));
L93: (the InternalRel of C19) = ( (the InternalRel of ( C18 opp )) |_2 (the carrier of C19) ) by L92 , YELLOW_0:def 14;
thus L94: thesis by L93 , L78 , L92 , L61 , YELLOW_0:def 14;
end;
definition
let C20 being RelStr;
let C21 being  full (SubRelStr of C20);
redefine func C21 opp ->  strict  full (SubRelStr of ( C20 opp ));

coherence by L77;
end;
registration
let C22 being set;
let C23 being non  empty RelStr;
cluster ( C22 --> C23 ) ->  non-Empty;
coherence
proof
let C24 being 1-sorted;
assume L96: C24 in ( rng ( C22 --> C23 ) );
thus L97: thesis by L96 , TARSKI:def 1;
end;
end;
registration
let C25 being RelStr;
let C26 being non  empty  reflexive RelStr;
cluster  monotone for (Function of C25 , C26);
existence
proof
set D19 = the (Element of C26);
take D20 = ( C25 --> D19 );
let C27 , C28 being (Element of C25);
assume L99: [ C27 , C28 ] in (the InternalRel of C25);
L100: C27 in (the carrier of C25) by L99 , ZFMISC_1:87;
let C29 , C30 being (Element of C26);
assume that
L101: C29 = ( D20 . C27 )
and
L102: C30 = ( D20 . C28 );
L103: C29 = D19 by L100 , L101 , FUNCOP_1:7;
thus L104: C29 <= C30 by L103 , L100 , L102 , FUNCOP_1:7;
end;
end;
registration
let C31 being non  empty RelStr;
cluster  projection ->  monotone  idempotent for (Function of C31 , C31);
coherence by WAYBEL_1:def 13;
end;
registration
let C32 , C33 being non  empty  reflexive RelStr;
let C34 being  monotone (Function of C32 , C33);
cluster ( corestr C34 ) ->  monotone;
coherence
proof
let C35 , C36 being (Element of C32);
L107: ( C34 . C36 ) = ( ( corestr C34 ) . C36 ) by WAYBEL_1:30;
assume L108: C35 <= C36;
L109: ( C34 . C35 ) <= ( C34 . C36 ) by L108 , WAYBEL_1:def 2;
L110: ( C34 . C35 ) = ( ( corestr C34 ) . C35 ) by WAYBEL_1:30;
thus L111: thesis by L110 , L109 , L107 , YELLOW_0:60;
end;
end;
registration
let C37 being non  empty  reflexive RelStr;
cluster ( id C37 ) ->  sups-preserving  infs-preserving;
coherence
proof
thus L113: ( id C37 ) is  sups-preserving
proof
let C38 being (Subset of C37);
L114: ( ( id C37 ) . ( sup C38 ) ) = ( sup C38 ) by FUNCT_1:18;
assume L115:  ex_sup_of C38 , C37;
thus L116: thesis by L115 , L114 , FUNCT_1:92;
end;

let C39 being (Subset of C37);
L117: ( ( id C37 ) . ( inf C39 ) ) = ( inf C39 ) by FUNCT_1:18;
assume L118:  ex_inf_of C39 , C37;
thus L119: thesis by L118 , L117 , FUNCT_1:92;
end;
end;
theorem
L121: (for B22 being RelStr holds (for B23 being (Subset of B22) holds (( id B23 ) is (Function of ( subrelstr B23 ) , B22) & (for B24 being (Function of ( subrelstr B23 ) , B22) holds (B24 = ( id B23 ) implies B24 is  monotone)))))
proof
let C40 being RelStr;
let C41 being (Subset of C40);
L122: (the carrier of ( subrelstr C41 )) = C41 by YELLOW_0:def 15;
L123: ( rng ( id C41 ) ) = C41 by RELAT_1:45;
L124: ( dom ( id C41 ) ) = C41 by RELAT_1:45;
thus L125: ( id C41 ) is (Function of ( subrelstr C41 ) , C40) by L124 , L122 , L123 , FUNCT_2:2;
let C42 being (Function of ( subrelstr C41 ) , C40);
assume L126: C42 = ( id C41 );
let C43 , C44 being (Element of ( subrelstr C41 ));
assume L127: [ C43 , C44 ] in (the InternalRel of ( subrelstr C41 ));
let C45 , C46 being (Element of C40);
assume that
L128: C45 = ( C42 . C43 )
and
L129: C46 = ( C42 . C44 );
L130: C43 in C41 by L122 , L127 , ZFMISC_1:87;
L131: C45 = C43 by L130 , L126 , L128 , FUNCT_1:17;
L132: C44 in C41 by L122 , L127 , ZFMISC_1:87;
L133: C46 = C44 by L132 , L126 , L129 , FUNCT_1:17;
L134: (the InternalRel of ( subrelstr C41 )) c= (the InternalRel of C40) by YELLOW_0:def 13;
thus L135: [ C45 , C46 ] in (the InternalRel of C40) by L134 , L127 , L131 , L133;
end;
registration
let C47 being non  empty  reflexive RelStr;
cluster  sups-preserving  infs-preserving  closure  kernel  one-to-one for (Function of C47 , C47);
existence
proof
take ( id C47 );
thus L136: thesis;
end;
end;
theorem
L138: (for B25 being non  empty  reflexive RelStr holds (for B26 being  closure (Function of B25 , B25) holds (for B27 being (Element of B25) holds ( B26 . B27 ) >= B27)))
proof
let C48 being non  empty  reflexive RelStr;
let C49 being  closure (Function of C48 , C48);
let C50 being (Element of C48);
L139: C49 >= ( id C48 ) by WAYBEL_1:def 14;
L140: ( C49 . C50 ) >= ( ( id C48 ) . C50 ) by L139 , YELLOW_2:9;
thus L141: thesis by L140 , FUNCT_1:18;
end;
theorem
L142: (for B28 , B29 being RelStr holds (for B30 being (SubRelStr of B28) holds (for B31 being (Function of (the carrier of B28) , (the carrier of B29)) holds (( B31 | B30 ) = ( B31 | (the carrier of B30) ) & (for B32 being set holds (B32 in (the carrier of B30) implies ( ( B31 | B30 ) . B32 ) = ( B31 . B32 )))))))
proof
let C51 , C52 being RelStr;
let C53 being (SubRelStr of C51);
let C54 being (Function of (the carrier of C51) , (the carrier of C52));
L143: (the carrier of C53) c= (the carrier of C51) by YELLOW_0:def 13;
thus L144: ( C54 | C53 ) = ( C54 | (the carrier of C53) ) by L143 , TMAP_1:def 3;
thus L145: thesis by L144 , FUNCT_1:49;
end;
theorem
L146: (for B33 , B34 being RelStr holds (for B35 being (Function of B33 , B34) holds (B35 is  one-to-one implies (for B36 being (SubRelStr of B33) holds ( B35 | B36 ) is  one-to-one))))
proof
let C55 , C56 being RelStr;
let C57 being (Function of C55 , C56);
assume that
L147: C57 is  one-to-one;
let C58 being (SubRelStr of C55);
L148: ( C57 | C58 ) = ( C57 | (the carrier of C58) ) by L142;
thus L149: thesis by L148 , L147 , FUNCT_1:52;
end;
registration
let C59 , C60 being non  empty  reflexive RelStr;
let C61 being  monotone (Function of C59 , C60);
let C62 being (SubRelStr of C59);
cluster ( C61 | C62 ) ->  monotone;
coherence
proof
let C63 , C64 being (Element of C62);
L150: (the carrier of C62) c= (the carrier of C59) by YELLOW_0:def 13;
assume L151: C63 <= C64;
L152: [ C63 , C64 ] in (the InternalRel of C62) by L151 , ORDERS_2:def 5;
L153: C63 in (the carrier of C62) by L152 , ZFMISC_1:87;
L154: C64 in (the carrier of C62) by L152 , ZFMISC_1:87;
reconsider D21 = C63 , D22 = C64 as (Element of C59) by L154 , L153 , L150;
L155: D21 <= D22 by L151 , YELLOW_0:59;
L156: ( C61 . D22 ) = ( ( C61 | C62 ) . C64 ) by L153 , L142;
L157: ( C61 . D21 ) = ( ( C61 | C62 ) . C63 ) by L153 , L142;
thus L158: thesis by L157 , L155 , L156 , WAYBEL_1:def 2;
end;
end;
theorem
L160: (for B37 , B38 being non  empty RelStr holds (for B39 being non  empty (SubRelStr of B37) holds (for B40 being (Function of B37 , B38) holds (for B41 being (Function of B38 , B37) holds ((B40 is  one-to-one & B41 = ( B40 " )) implies (( B41 | ( Image ( B40 | B39 ) ) ) is (Function of ( Image ( B40 | B39 ) ) , B39) & ( B41 | ( Image ( B40 | B39 ) ) ) = ( ( B40 | B39 ) " )))))))
proof
let C65 , C66 being non  empty RelStr;
let C67 being non  empty (SubRelStr of C65);
let C68 being (Function of C65 , C66);
let C69 being (Function of C66 , C65);
assume that
L161: C68 is  one-to-one
and
L162: C69 = ( C68 " );
set D23 = ( C69 | ( Image ( C68 | C67 ) ) );
L163: ( dom C68 ) = (the carrier of C65) by FUNCT_2:def 1;
L164: ( dom D23 ) = (the carrier of ( Image ( C68 | C67 ) )) by FUNCT_2:def 1;
L165: (the carrier of C67) c= (the carrier of C65) by YELLOW_0:def 13;
L166: ( rng D23 ) c= (the carrier of C67)
proof
let C70 being set;
assume L167: C70 in ( rng D23 );
consider C71 being set such that L168: C71 in ( dom D23 ) and L169: C70 = ( D23 . C71 ) by L167 , FUNCT_1:def 3;
reconsider D24 = C71 as (Element of ( Image ( C68 | C67 ) )) by L168;
consider C72 being (Element of C67) such that L170: ( ( C68 | C67 ) . C72 ) = D24 by YELLOW_2:10;
L171: ( C68 . C72 ) = D24 by L170 , L142;
L172: C72 in (the carrier of C67);
L173: C70 = ( C69 . D24 ) by L169 , L142;
thus L174: thesis by L173 , L161 , L162 , L165 , L163 , L172 , L171 , FUNCT_1:32;
end;
thus L175: D23 is (Function of ( Image ( C68 | C67 ) ) , C67) by L166 , L164 , RELSET_1:4;
L176: ( rng ( C68 | C67 ) ) = (the carrier of ( Image ( C68 | C67 ) )) by YELLOW_0:def 15;
L177: ( C68 | C67 ) is  one-to-one by L161 , L146;
L178:
now
let C73 being set;
L179: ( dom ( C68 | C67 ) ) = (the carrier of C67) by FUNCT_2:def 1;
assume L180: C73 in (the carrier of ( Image ( C68 | C67 ) ));
consider C74 being set such that L181: C74 in ( dom ( C68 | C67 ) ) and L182: C73 = ( ( C68 | C67 ) . C74 ) by L180 , L176 , FUNCT_1:def 3;
L183: C74 = ( ( ( C68 | C67 ) " ) . C73 ) by L177 , L181 , L182 , FUNCT_1:32;
L184: C73 = ( C68 . C74 ) by L181 , L182 , L142;
L185: C74 = ( C69 . C73 ) by L184 , L161 , L162 , L165 , L163 , L181 , L179 , FUNCT_1:32;
thus L186: ( D23 . C73 ) = ( ( ( C68 | C67 ) " ) . C73 ) by L185 , L180 , L183 , L142;
end;
L187: ( dom ( ( C68 | C67 ) " ) ) = ( rng ( C68 | C67 ) ) by L177 , FUNCT_1:33;
thus L188: thesis by L187 , L164 , L176 , L178 , FUNCT_1:2;
end;
begin
registration
let C75 being RelStr;
let C76 being non  empty  reflexive RelStr;
cluster ( MonMaps (C75 , C76) ) -> non  empty;
coherence
proof
set D25 = the  monotone (Function of C75 , C76);
L189: D25 in ( Funcs ((the carrier of C75) , (the carrier of C76)) ) by FUNCT_2:8;
thus L190: thesis by L189 , YELLOW_1:def 6;
end;
end;
theorem
L192: (for B42 being RelStr holds (for B43 being non  empty  reflexive RelStr holds (for B44 being set holds (B44 is (Element of ( MonMaps (B42 , B43) )) iff B44 is  monotone  monotone  monotone  monotone (Function of B42 , B43)))))
proof
let C77 being RelStr;
let C78 being non  empty  reflexive RelStr;
let C79 being set;
thus L193:now
assume L194: C79 is (Element of ( MonMaps (C77 , C78) ));
reconsider D26 = C79 as (Element of ( MonMaps (C77 , C78) )) by L194;
L195: D26 is (Element of ( C78 |^ (the carrier of C77) )) by YELLOW_0:58;
L196: D26 in (the carrier of ( C78 |^ (the carrier of C77) )) by L195;
L197: D26 in ( Funcs ((the carrier of C77) , (the carrier of C78)) ) by L196 , YELLOW_1:28;
reconsider D27 = D26 as (Function of C77 , C78) by L197 , FUNCT_2:66;
L198: D27 in (the carrier of ( MonMaps (C77 , C78) ));
thus L199: C79 is  monotone  monotone  monotone  monotone (Function of C77 , C78) by L198 , YELLOW_1:def 6;
end;
assume L200: C79 is  monotone  monotone  monotone  monotone (Function of C77 , C78);
reconsider D28 = C79 as  monotone (Function of C77 , C78) by L200;
L201: D28 in ( Funcs ((the carrier of C77) , (the carrier of C78)) ) by FUNCT_2:8;
thus L202: thesis by L201 , YELLOW_1:def 6;
end;
definition
let C80 being non  empty  reflexive RelStr;
func ClOpers C80 -> non  empty  full  strict (SubRelStr of ( MonMaps (C80 , C80) )) means 
:L203: (for B45 being (Function of C80 , C80) holds (B45 is (Element of it) iff B45 is  closure));
existence
proof
defpred S3[ set ] means $1 is  closure  closure  closure  closure (Function of C80 , C80);
set D29 = the  closure (Function of C80 , C80);
L204: D29 in ( Funcs ((the carrier of C80) , (the carrier of C80)) ) by FUNCT_2:9;
L205: D29 in (the carrier of ( MonMaps (C80 , C80) )) by L204 , YELLOW_1:def 6;
L206: S3[ D29 ];
consider C81 being non  empty  full  strict (SubRelStr of ( MonMaps (C80 , C80) )) such that L207: (for B46 being (Element of ( MonMaps (C80 , C80) )) holds (B46 is (Element of C81) iff S3[ B46 ])) from SubrelstrEx(L206 , L205);
take C81;
let C82 being (Function of C80 , C80);
thus L208:now
assume L209: C82 is (Element of C81);
L210: C82 is (Element of ( MonMaps (C80 , C80) )) by L209 , YELLOW_0:58;
thus L211: C82 is  closure by L210 , L207 , L209;
end;
assume L212: C82 is  closure;
L213: C82 in ( Funcs ((the carrier of C80) , (the carrier of C80)) ) by FUNCT_2:9;
L214: C82 in (the carrier of ( MonMaps (C80 , C80) )) by L213 , L212 , YELLOW_1:def 6;
thus L215: thesis by L214 , L207 , L212;
end;
correctness
proof
let C83 , C84 being non  empty  full  strict (SubRelStr of ( MonMaps (C80 , C80) ));
assume that
L216: (for B47 being (Function of C80 , C80) holds (B47 is (Element of C83) iff B47 is  closure))
and
L217: (for B48 being (Function of C80 , C80) holds (B48 is (Element of C84) iff B48 is  closure));
L218: (the carrier of C83) = (the carrier of C84)
proof
thus L219:now
let C85 being set;
assume L220: C85 in (the carrier of C83);
reconsider D30 = C85 as (Element of C83) by L220;
L221: D30 is (Element of ( MonMaps (C80 , C80) )) by YELLOW_0:58;
reconsider D31 = D30 as (Function of C80 , C80) by L221 , L192;
L222: D31 is  closure by L216;
L223: D31 is (Element of C84) by L222 , L217;
thus L224: C85 in (the carrier of C84) by L223;
end;
let C86 being set;
assume L225: C86 in (the carrier of C84);
reconsider D32 = C86 as (Element of C84) by L225;
L226: D32 is (Element of ( MonMaps (C80 , C80) )) by YELLOW_0:58;
reconsider D33 = D32 as (Function of C80 , C80) by L226 , L192;
L227: D33 is  closure by L217;
L228: D33 is (Element of C83) by L227 , L216;
thus L229: thesis by L228;
end;
thus L230: thesis by L218 , YELLOW_0:57;
end;
end;
theorem
L232: (for B49 being non  empty  reflexive RelStr holds (for B50 being set holds (B50 is (Element of ( ClOpers B49 )) iff B50 is  closure  closure  closure  closure (Function of B49 , B49))))
proof
let C87 being non  empty  reflexive RelStr;
let C88 being set;
L233: (C88 is (Element of ( ClOpers C87 )) implies C88 is (Element of ( MonMaps (C87 , C87) ))) by YELLOW_0:58;
thus L234: thesis by L233 , L203 , L192;
end;
theorem
L235: (for B51 being set holds (for B52 being non  empty RelStr holds (for B53 , B54 being (Function of B51 , (the carrier of B52)) holds (for B55 , B56 being (Element of ( B52 |^ B51 )) holds ((B55 = B53 & B56 = B54) implies (B55 <= B56 iff B53 <= B54))))))
proof
let C89 being set;
let C90 being non  empty RelStr;
let C91 , C92 being (Function of C89 , (the carrier of C90));
let C93 , C94 being (Element of ( C90 |^ C89 ));
assume that
L236: C93 = C91
and
L237: C94 = C92;
set D34 = ( C89 --> C90 );
L238: ( C90 |^ C89 ) = ( product D34 ) by YELLOW_1:def 5;
L239: (the carrier of ( product D34 )) = ( product ( Carrier D34 ) ) by YELLOW_1:def 4;
L240: (C93 <= C94 iff (ex B57 , B58 being Function st (B57 = C93 & B58 = C94 & (for B59 being set holds (B59 in C89 implies (ex B60 being RelStr st (ex B61 , B62 being (Element of B60) st (B60 = ( D34 . B59 ) & B61 = ( B57 . B59 ) & B62 = ( B58 . B59 ) & B61 <= B62)))))))) by L239 , L238 , YELLOW_1:def 4;
thus L241:now
assume L242: C93 <= C94;
thus L243: C91 <= C92
proof
let C95 being set;
assume L244: C95 in C89;
L245: ( D34 . C95 ) = C90 by L244 , FUNCOP_1:7;
L246: (ex B63 being RelStr st (ex B64 , B65 being (Element of B63) st (B63 = ( D34 . C95 ) & B64 = ( C91 . C95 ) & B65 = ( C92 . C95 ) & B64 <= B65))) by L236 , L237 , L240 , L242 , L244;
thus L247: thesis by L246 , L245;
end;

end;
assume L244: (for B66 being set holds (B66 in C89 implies (ex B67 , B68 being (Element of C90) st (B67 = ( C91 . B66 ) & B68 = ( C92 . B66 ) & B67 <= B68))));
L245:
now
reconsider D35 = C91 , D36 = C92 as Function;
take D37 = D35;
take D38 = D36;
thus L246: (D37 = C93 & D38 = C94) by L236 , L237;
let C96 being set;
assume L247: C96 in C89;
L248: ( D34 . C96 ) = C90 by L247 , FUNCOP_1:7;
L249: (ex B69 , B70 being (Element of C90) st (B69 = ( C91 . C96 ) & B70 = ( C92 . C96 ) & B69 <= B70)) by L244 , L247;
thus L250: (ex B71 being RelStr st (ex B72 , B73 being (Element of B71) st (B71 = ( D34 . C96 ) & B72 = ( D37 . C96 ) & B73 = ( D38 . C96 ) & B72 <= B73))) by L249 , L248;
end;
thus L251: thesis by L245 , L239 , L238 , YELLOW_1:def 4;
end;
theorem
L252: (for B74 being  complete LATTICE holds (for B75 , B76 being (Function of B74 , B74) holds (for B77 , B78 being (Element of ( ClOpers B74 )) holds ((B77 = B75 & B78 = B76) implies (B77 <= B78 iff B75 <= B76)))))
proof
let C97 being  complete LATTICE;
let C98 , C99 being (Function of C97 , C97);
let C100 , C101 being (Element of ( ClOpers C97 ));
assume that
L253: C100 = C98
and
L254: C101 = C99;
reconsider D39 = C100 , D40 = C101 as (Element of ( MonMaps (C97 , C97) )) by YELLOW_0:58;
reconsider D41 = D39 , D42 = D40 as (Element of ( C97 |^ (the carrier of C97) )) by YELLOW_0:58;
L255: (D41 <= D42 iff D39 <= D40) by YELLOW_0:59 , YELLOW_0:60;
thus L256: thesis by L255 , L253 , L254 , L235 , YELLOW_0:59 , YELLOW_0:60;
end;
theorem
L257: (for B79 being  reflexive RelStr holds (for B80 , B81 being  full (SubRelStr of B79) holds ((the carrier of B80) c= (the carrier of B81) implies B80 is (SubRelStr of B81))))
proof
let C102 being  reflexive RelStr;
let C103 , C104 being  full (SubRelStr of C102);
assume L258: (the carrier of C103) c= (the carrier of C104);
thus L259: (the carrier of C103) c= (the carrier of C104) by L258;
let C105 , C106 being set;
assume L260: [ C105 , C106 ] in (the InternalRel of C103);
L261: C105 in (the carrier of C103) by L260 , ZFMISC_1:87;
L262: C106 in (the carrier of C103) by L260 , ZFMISC_1:87;
reconsider D43 = C105 , D44 = C106 as (Element of C103) by L260 , ZFMISC_1:87;
L263: (the carrier of C103) c= (the carrier of C102) by YELLOW_0:def 13;
reconsider D45 = D43 , D46 = D44 as (Element of C102) by L263 , L261 , L262;
reconsider D47 = D43 , D48 = D44 as (Element of C104) by L258 , L261 , L262;
L264: D43 <= D44 by L260 , ORDERS_2:def 5;
L265: D45 <= D46 by L264 , YELLOW_0:59;
L266: D47 <= D48 by L265 , L258 , L261 , YELLOW_0:60;
thus L267: thesis by L266 , ORDERS_2:def 5;
end;
theorem
L268: (for B82 being  complete LATTICE holds (for B83 , B84 being  closure (Function of B82 , B82) holds (B83 <= B84 iff ( Image B84 ) is (SubRelStr of ( Image B83 )))))
proof
let C107 being  complete LATTICE;
let C108 , C109 being  closure (Function of C107 , C107);
thus L269:now
assume L270: C108 <= C109;
L271: (the carrier of ( Image C109 )) c= (the carrier of ( Image C108 ))
proof
let C110 being set;
assume L272: C110 in (the carrier of ( Image C109 ));
consider C111 being (Element of C107) such that L273: ( C109 . C111 ) = C110 by L272 , YELLOW_2:10;
L274: ( C109 . ( C109 . C111 ) ) = ( C109 . C111 ) by YELLOW_2:18;
L275: ( C108 . ( C109 . C111 ) ) <= ( C109 . ( C109 . C111 ) ) by L270 , YELLOW_2:9;
L276: ( C109 . C111 ) <= ( C108 . ( C109 . C111 ) ) by L138;
L277: ( C108 . ( C109 . C111 ) ) = C110 by L276 , L273 , L275 , L274 , ORDERS_2:2;
L278: C110 in ( rng C108 ) by L277 , FUNCT_2:4;
thus L279: thesis by L278 , YELLOW_0:def 15;
end;
thus L280: ( Image C109 ) is (SubRelStr of ( Image C108 )) by L271 , L257;
end;
assume that
L281: (the carrier of ( Image C109 )) c= (the carrier of ( Image C108 ))
and
L282: (the InternalRel of ( Image C109 )) c= (the InternalRel of ( Image C108 ));
L283:
now
let C112 being (Element of C107);
L284: ( C109 . C112 ) in ( rng C109 ) by FUNCT_2:4;
L285: ( C109 . C112 ) in (the carrier of ( Image C109 )) by L284 , YELLOW_0:def 15;
L286: (ex B85 being (Element of C107) st ( C108 . B85 ) = ( C109 . C112 )) by L285 , L281 , YELLOW_2:10;
L287: ( C108 . ( C109 . C112 ) ) = ( C109 . C112 ) by L286 , YELLOW_2:18;
L288: C112 <= ( C109 . C112 ) by L138;
thus L289: ( C108 . C112 ) <= ( C109 . C112 ) by L288 , L287 , WAYBEL_1:def 2;
end;
thus L290: thesis by L283 , YELLOW_2:9;
end;
begin
definition
let C113 being RelStr;
func Sub C113 ->  strict non  empty RelStr means 
:L291: ((for B86 being set holds (B86 is (Element of it) iff B86 is  strict  strict  strict  strict (SubRelStr of C113))) & (for B87 , B88 being (Element of it) holds (B87 <= B88 iff (ex B89 being RelStr st (B88 = B89 & B87 is (SubRelStr of B89))))));
existence
proof
set D49 = { RelStr (# B90 , B91 #) where B90 is (Subset of C113) , B91 is (Relation of B90 , B90) : B91 c= (the InternalRel of C113) };
L292: (the InternalRel of ( subrelstr ( {} C113 ) )) c= (the InternalRel of C113) by YELLOW_0:def 13;
L293: (the carrier of ( subrelstr ( {} C113 ) )) = ( {} C113 ) by YELLOW_0:def 15;
L294: ( subrelstr ( {} C113 ) ) in D49 by L293 , L292;
reconsider D50 = D49 as non  empty set by L294;
defpred S4[ set , set ] means (ex B92 being RelStr st ($2 = B92 & $1 is (SubRelStr of B92)));
consider C114 being  strict non  empty RelStr such that L295: (the carrier of C114) = D50 and L296: (for B93 , B94 being (Element of C114) holds (B93 <= B94 iff S4[ B93 , B94 ])) from YELLOW_0:sch 1;
take C114;
thus L297:now
let C115 being set;
thus L298:now
assume L299: C115 is (Element of C114);
L300: C115 in D50 by L299 , L295;
L301: (ex B95 being (Subset of C113) st (ex B96 being (Relation of B95 , B95) st (C115 = RelStr (# B95 , B96 #) & B96 c= (the InternalRel of C113)))) by L300;
thus L302: C115 is  strict  strict  strict  strict (SubRelStr of C113) by L301 , YELLOW_0:def 13;
end;
assume L303: C115 is  strict  strict  strict  strict (SubRelStr of C113);
reconsider D51 = C115 as  strict (SubRelStr of C113) by L303;
L304: (the InternalRel of D51) c= (the InternalRel of C113) by YELLOW_0:def 13;
L305: (the carrier of D51) c= (the carrier of C113) by YELLOW_0:def 13;
L306: D51 in D50 by L305 , L304;
thus L307: C115 is (Element of C114) by L306 , L295;
end;
thus L308: thesis by L296;
end;
correctness
proof
defpred S5[ set , set ] means (ex B97 being RelStr st ($2 = B97 & $1 is (SubRelStr of B97)));
defpred S6[ set ] means $1 is  strict  strict  strict  strict (SubRelStr of C113);
let C116 , C117 being non  empty  strict RelStr;
assume that
L309: (for B98 being set holds (B98 is (Element of C116) iff S6[ B98 ]))
and
L310: (for B99 , B100 being (Element of C116) holds (B99 <= B100 iff S5[ B99 , B100 ]))
and
L311: (for B101 being set holds (B101 is (Element of C117) iff S6[ B101 ]))
and
L312: (for B102 , B103 being (Element of C117) holds (B102 <= B103 iff S5[ B102 , B103 ]));
L313: ( the RelStr of C116 ) = ( the RelStr of C117 ) from RelstrEq(L309 , L311 , L310 , L312);
thus L314: thesis by L313;
end;
end;
theorem
L316: (for B104 , B105 being RelStr holds (for B106 , B107 being (Element of ( Sub B104 )) holds (B107 = B105 implies (B106 <= B107 iff B106 is (SubRelStr of B105)))))
proof
let C118 , C119 being RelStr;
let C120 , C121 being (Element of ( Sub C118 ));
L317: (C120 <= C121 iff (ex B108 being RelStr st (C121 = B108 & C120 is (SubRelStr of B108)))) by L291;
thus L318: thesis by L317;
end;
registration
let C122 being RelStr;
cluster ( Sub C122 ) ->  reflexive  antisymmetric  transitive;
coherence
proof
set D52 = ( Sub C122 );
thus L319: D52 is  reflexive
proof
let C123 being (Element of D52);
reconsider D53 = C123 as  strict (SubRelStr of C122) by L291;
L320: D53 is (SubRelStr of D53) by YELLOW_0:def 13;
thus L321: thesis by L320 , L316;
end;

thus L322: D52 is  antisymmetric
proof
let C124 , C125 being (Element of D52);
reconsider D54 = C124 , D55 = C125 as  strict (SubRelStr of C122) by L291;
assume that
L323: C124 <= C125
and
L324: C125 <= C124;
L325: D55 is (SubRelStr of D54) by L324 , L316;
L326: (the carrier of D55) c= (the carrier of D54) by L325 , YELLOW_0:def 13;
L327: D54 is (SubRelStr of D55) by L323 , L316;
L328: (the carrier of D54) c= (the carrier of D55) by L327 , YELLOW_0:def 13;
L329: (the carrier of D54) = (the carrier of D55) by L328 , L326 , XBOOLE_0:def 10;
L330: (the InternalRel of D55) c= (the InternalRel of D54) by L325 , YELLOW_0:def 13;
L331: (the InternalRel of D54) c= (the InternalRel of D55) by L327 , YELLOW_0:def 13;
thus L332: thesis by L331 , L330 , L329 , XBOOLE_0:def 10;
end;

thus L333: D52 is  transitive
proof
let C126 , C127 , C128 being (Element of D52);
reconsider D56 = C126 , D57 = C127 , D58 = C128 as  strict (SubRelStr of C122) by L291;
assume that
L334: C126 <= C127
and
L335: C127 <= C128;
L336: D57 is (SubRelStr of D58) by L335 , L316;
L337: (the carrier of D57) c= (the carrier of D58) by L336 , YELLOW_0:def 13;
L338: (the InternalRel of D57) c= (the InternalRel of D58) by L336 , YELLOW_0:def 13;
L339: D56 is (SubRelStr of D57) by L334 , L316;
L340: (the InternalRel of D56) c= (the InternalRel of D57) by L339 , YELLOW_0:def 13;
L341: (the InternalRel of D56) c= (the InternalRel of D58) by L340 , L338 , XBOOLE_1:1;
L342: (the carrier of D56) c= (the carrier of D57) by L339 , YELLOW_0:def 13;
L343: (the carrier of D56) c= (the carrier of D58) by L342 , L337 , XBOOLE_1:1;
L344: D56 is (SubRelStr of D58) by L343 , L341 , YELLOW_0:def 13;
thus L345: thesis by L344 , L316;
end;

end;
end;
registration
let C129 being RelStr;
cluster ( Sub C129 ) ->  complete;
coherence
proof
L335:
now
let C130 being (Subset of ( Sub C129 ));
L336:
now
defpred S7[ set ] means (ex B109 being RelStr st (B109 in C130 & $1 in (the InternalRel of B109)));
defpred S8[ set ] means (ex B110 being RelStr st (B110 in C130 & $1 in (the carrier of B110)));
consider C131 being set such that L337: (for B111 being set holds (B111 in C131 iff (B111 in (the carrier of C129) & S8[ B111 ]))) from XBOOLE_0:sch 1;
consider C132 being set such that L338: (for B112 being set holds (B112 in C132 iff (B112 in (the InternalRel of C129) & S7[ B112 ]))) from XBOOLE_0:sch 1;
L339: C132 c= [: C131 , C131 :]
proof
let C133 being set;
assume L340: C133 in C132;
consider C134 being RelStr such that L341: C134 in C130 and L342: C133 in (the InternalRel of C134) by L340 , L338;
L343: (the carrier of C134) c= C131
proof
let C135 being set;
L344: C134 is (SubRelStr of C129) by L341 , L291;
L345: (the carrier of C134) c= (the carrier of C129) by L344 , YELLOW_0:def 13;
assume L346: C135 in (the carrier of C134);
thus L347: thesis by L346 , L337 , L341 , L345;
end;
L348: [: (the carrier of C134) , (the carrier of C134) :] c= [: C131 , C131 :] by L343 , ZFMISC_1:96;
L349: C133 in [: (the carrier of C134) , (the carrier of C134) :] by L342;
thus L350: thesis by L349 , L348;
end;
L351: C132 c= (the InternalRel of C129)
proof
let C136 being set;
thus L352: thesis by L338;
end;
reconsider D59 = C132 as (Relation of C131) by L339;
L353: C131 c= (the carrier of C129)
proof
let C137 being set;
thus L354: thesis by L337;
end;
reconsider D60 = RelStr (# C131 , D59 #) as (SubRelStr of C129) by L353 , L351 , YELLOW_0:def 13;
reconsider D61 = D60 as (Element of ( Sub C129 )) by L291;
take D62 = D61;
thus L355: C130 is_<=_than D62
proof
let C138 being (Element of ( Sub C129 ));
reconsider D63 = C138 as  strict (SubRelStr of C129) by L291;
assume L356: C138 in C130;
L357: (the InternalRel of D63) c= D59
proof
let C139 , C140 being set;
L358: (the InternalRel of D63) c= (the InternalRel of C129) by YELLOW_0:def 13;
assume L359: [ C139 , C140 ] in (the InternalRel of D63);
thus L360: thesis by L359 , L338 , L356 , L358;
end;
L361: (the carrier of D63) c= C131
proof
let C141 being set;
L362: (the carrier of D63) c= (the carrier of C129) by YELLOW_0:def 13;
assume L363: C141 in (the carrier of D63);
thus L364: thesis by L363 , L337 , L356 , L362;
end;
L365: D63 is (SubRelStr of D60) by L361 , L357 , YELLOW_0:def 13;
thus L366: C138 <= D62 by L365 , L316;
end;

let C142 being (Element of ( Sub C129 ));
reconsider D64 = C142 as  strict (SubRelStr of C129) by L291;
assume L367: C130 is_<=_than C142;
L368: D59 c= (the InternalRel of D64)
proof
let C143 , C144 being set;
assume L369: [ C143 , C144 ] in D59;
consider C145 being RelStr such that L370: C145 in C130 and L371: [ C143 , C144 ] in (the InternalRel of C145) by L369 , L338;
reconsider D65 = C145 as (Element of ( Sub C129 )) by L370;
L372: D65 <= C142 by L367 , L370 , LATTICE3:def 9;
L373: C145 is (SubRelStr of D64) by L372 , L316;
L374: (the InternalRel of C145) c= (the InternalRel of D64) by L373 , YELLOW_0:def 13;
thus L375: thesis by L374 , L371;
end;
L376: C131 c= (the carrier of D64)
proof
let C146 being set;
assume L377: C146 in C131;
consider C147 being RelStr such that L378: C147 in C130 and L379: C146 in (the carrier of C147) by L377 , L337;
reconsider D66 = C147 as (Element of ( Sub C129 )) by L378;
L380: D66 <= C142 by L367 , L378 , LATTICE3:def 9;
L381: C147 is (SubRelStr of D64) by L380 , L316;
L382: (the carrier of C147) c= (the carrier of D64) by L381 , YELLOW_0:def 13;
thus L383: thesis by L382 , L379;
end;
L384: D62 is (SubRelStr of D64) by L376 , L368 , YELLOW_0:def 13;
thus L385: D62 <= C142 by L384 , L316;
end;
thus L386:  ex_sup_of C130 , ( Sub C129 ) by L336 , YELLOW_0:15;
end;
thus L387: thesis by L335 , YELLOW_0:53;
end;
end;
registration
let C148 being  complete LATTICE;
cluster  infs-inheriting -> non  empty for (SubRelStr of C148);
coherence
proof
let C149 being (SubRelStr of C148);
assume that
L389: C149 is  infs-inheriting;
L390:  ex_inf_of ( {} C149 ) , C148 by YELLOW_0:17;
thus L391: thesis by L390 , L389 , YELLOW_0:def 18;
end;
cluster  sups-inheriting -> non  empty for (SubRelStr of C148);
coherence
proof
let C150 being (SubRelStr of C148);
assume that
L392: C150 is  sups-inheriting;
L393:  ex_sup_of ( {} C150 ) , C148 by YELLOW_0:17;
thus L394: thesis by L393 , L392 , YELLOW_0:def 19;
end;
end;
definition
let C151 being RelStr;
mode System of C151
 is  full (SubRelStr of C151);
end;
notation
let C152 being non  empty RelStr;
let C153 being (System of C152);
synonym C153 is  closure for C153 is  infs-inheriting;
end;
registration
let C154 being non  empty RelStr;
cluster ( subrelstr ( [#] C154 ) ) ->  infs-inheriting  sups-inheriting;
coherence
proof
set D67 = ( subrelstr ( [#] C154 ) );
L398: (the carrier of D67) = (the carrier of C154) by YELLOW_0:def 15;
thus L399: D67 is  infs-inheriting
proof
let C155 being (Subset of D67);
thus L400: thesis by L398;
end;

let C156 being (Subset of D67);
thus L401: thesis by L398;
end;
end;
definition
let C157 being non  empty RelStr;
func ClosureSystems C157 ->  full  strict non  empty (SubRelStr of ( Sub C157 )) means 
:L403: (for B113 being  strict (SubRelStr of C157) holds (B113 is (Element of it) iff B113 is  infs-inheriting  full));
existence
proof
defpred S9[ set ] means $1 is  infs-inheriting  full  infs-inheriting  full  infs-inheriting  full  infs-inheriting  full (SubRelStr of C157);
set D68 = ( subrelstr ( [#] C157 ) );
L404: D68 is (Element of ( Sub C157 )) by L291;
L405: D68 in (the carrier of ( Sub C157 )) by L404;
L406: S9[ D68 ];
consider C158 being non  empty  full  strict (SubRelStr of ( Sub C157 )) such that L407: (for B114 being (Element of ( Sub C157 )) holds (B114 is (Element of C158) iff S9[ B114 ])) from SubrelstrEx(L406 , L405);
take C158;
let C159 being  strict (SubRelStr of C157);
L408: C159 is (Element of ( Sub C157 )) by L291;
thus L409: thesis by L408 , L407;
end;
correctness
proof
defpred S10[ set ] means $1 is  infs-inheriting  full  strict  infs-inheriting  full  strict  infs-inheriting  full  strict  infs-inheriting  full  strict (SubRelStr of C157);
let C160 , C161 being  full  strict non  empty (SubRelStr of ( Sub C157 ));
assume that
L410: (for B115 being  strict (SubRelStr of C157) holds (B115 is (Element of C160) iff B115 is  infs-inheriting  full))
and
L411: (for B116 being  strict (SubRelStr of C157) holds (B116 is (Element of C161) iff B116 is  infs-inheriting  full));
L412:
now
let C162 being set;
L413: (C162 is (Element of C161) implies C162 is (Element of ( Sub C157 ))) by YELLOW_0:58;
L414: (C162 is (Element of C161) implies C162 is  strict  strict  strict  strict (SubRelStr of C157)) by L413 , L291;
thus L415: (C162 is (Element of C161) iff S10[ C162 ]) by L414 , L411;
end;
L416:
now
let C163 being set;
L417: (C163 is (Element of C160) implies C163 is (Element of ( Sub C157 ))) by YELLOW_0:58;
L418: (C163 is (Element of C160) implies C163 is  strict  strict  strict  strict (SubRelStr of C157)) by L417 , L291;
thus L419: (C163 is (Element of C160) iff S10[ C163 ]) by L418 , L410;
end;
L420: ( the RelStr of C160 ) = ( the RelStr of C161 ) from SubrelstrEq1(L416 , L412);
thus L421: thesis by L420;
end;
end;
theorem
L423: (for B117 being non  empty RelStr holds (for B118 being set holds (B118 is (Element of ( ClosureSystems B117 )) iff B118 is  strict  closure  strict  closure  strict  closure  strict  closure (System of B117))))
proof
let C164 being non  empty RelStr;
let C165 being set;
L424: (C165 is (Element of ( ClosureSystems C164 )) implies C165 is (Element of ( Sub C164 ))) by YELLOW_0:58;
L425: (C165 is (Element of ( ClosureSystems C164 )) implies C165 is  strict  strict  strict  strict (SubRelStr of C164)) by L424 , L291;
thus L426: thesis by L425 , L403;
end;
theorem
L427: (for B119 being non  empty RelStr holds (for B120 being RelStr holds (for B121 , B122 being (Element of ( ClosureSystems B119 )) holds (B122 = B120 implies (B121 <= B122 iff B121 is (SubRelStr of B120))))))
proof
let C166 being non  empty RelStr;
let C167 being RelStr;
let C168 , C169 being (Element of ( ClosureSystems C166 ));
reconsider D69 = C168 , D70 = C169 as (Element of ( Sub C166 )) by YELLOW_0:58;
L428: (C168 <= C169 iff D69 <= D70) by YELLOW_0:59 , YELLOW_0:60;
thus L429: thesis by L428 , L316;
end;
begin
registration
let C170 being non  empty Poset;
let C171 being  closure (Function of C170 , C170);
cluster ( Image C171 ) ->  infs-inheriting;
coherence by WAYBEL_1:53;
end;
definition
let C172 being non  empty Poset;
func ClImageMap C172 -> (Function of ( ClOpers C172 ) , ( ( ClosureSystems C172 ) opp )) means 
:L431: (for B123 being  closure (Function of C172 , C172) holds ( it . B123 ) = ( Image B123 ));
existence
proof
defpred S11[ set , set ] means (ex B124 being  closure (Function of C172 , C172) st (B124 = $1 & $2 = ( Image B124 )));
L432:
now
let C173 being (Element of ( ClOpers C172 ));
reconsider D71 = C173 as  closure (Function of C172 , C172) by L232;
reconsider D72 = ( Image D71 ) as (Element of ( ClosureSystems C172 )) by L423;
take D73 = ( D72 ~ );
thus L433: S11[ C173 , D73 ];
end;
consider C174 being (Function of ( ClOpers C172 ) , ( ( ClosureSystems C172 ) opp )) such that L434: (for B125 being (Element of ( ClOpers C172 )) holds S11[ B125 , ( C174 . B125 ) ]) from FUNCT_2:sch 3(L432);
take C174;
let C175 being  closure (Function of C172 , C172);
L435: C175 is (Element of ( ClOpers C172 )) by L232;
L436: (ex B126 being  closure (Function of C172 , C172) st (B126 = C175 & ( C174 . C175 ) = ( Image B126 ))) by L435 , L434;
thus L437: thesis by L436;
end;
correctness
proof
let C176 , C177 being (Function of ( ClOpers C172 ) , ( ( ClosureSystems C172 ) opp ));
assume that
L438: (for B127 being  closure (Function of C172 , C172) holds ( C176 . B127 ) = ( Image B127 ))
and
L439: (for B128 being  closure (Function of C172 , C172) holds ( C177 . B128 ) = ( Image B128 ));
L440:
now
let C178 being (Element of ( ClOpers C172 ));
reconsider D74 = C178 as  closure (Function of C172 , C172) by L232;
thus L441: ( C176 . C178 ) = ( Image D74 ) by L438
.= ( C177 . C178 ) by L439;
end;
thus L442: thesis by L440 , FUNCT_2:63;
end;
end;
definition
let C179 being non  empty RelStr;
let C180 being (SubRelStr of C179);
func closure_op C180 -> (Function of C179 , C179) means 
:L444: (for B129 being (Element of C179) holds ( it . B129 ) = ( "/\" (( ( uparrow B129 ) /\ (the carrier of C180) ) , C179) ));
existence
proof
deffunc H1((Element of C179)) = ( "/\" (( ( uparrow $1 ) /\ (the carrier of C180) ) , C179) );
thus L445: (ex B130 being (Function of C179 , C179) st (for B131 being (Element of C179) holds ( B130 . B131 ) = H1(B131))) from FUNCT_2:sch 4;
end;
uniqueness
proof
let C181 , C182 being (Function of C179 , C179);
assume that
L446: (for B132 being (Element of C179) holds ( C181 . B132 ) = ( "/\" (( ( uparrow B132 ) /\ (the carrier of C180) ) , C179) ))
and
L447: (for B133 being (Element of C179) holds ( C182 . B133 ) = ( "/\" (( ( uparrow B133 ) /\ (the carrier of C180) ) , C179) ));
L448:
now
let C183 being (Element of C179);
thus L449: ( C181 . C183 ) = ( "/\" (( ( uparrow C183 ) /\ (the carrier of C180) ) , C179) ) by L446
.= ( C182 . C183 ) by L447;
end;
thus L450: thesis by L448 , FUNCT_2:63;
end;
end;
registration
let C184 being  complete LATTICE;
let C185 being  closure (System of C184);
cluster ( closure_op C185 ) ->  closure;
coherence
proof
set D75 = ( closure_op C185 );
reconsider D76 = ( D75 * D75 ) as (Function of C184 , C184);
L452:
now
let C186 being (Element of C184);
thus L453: ( ( id C184 ) . C186 ) = C186 by FUNCT_1:18;
L454: ( ( uparrow C186 ) /\ (the carrier of C185) ) c= ( uparrow C186 ) by XBOOLE_1:17;
L455: C186 is_<=_than ( ( uparrow C186 ) /\ (the carrier of C185) ) by L454 , YELLOW_2:2;
L456: ( D75 . C186 ) = ( "/\" (( ( uparrow C186 ) /\ (the carrier of C185) ) , C184) ) by L444;
thus L457: ( ( id C184 ) . C186 ) <= ( D75 . C186 ) by L456 , L453 , L455 , YELLOW_0:33;
end;
L458:
now
let C187 being (Element of C184);
set D77 = ( D75 . C187 );
set D78 = ( ( uparrow C187 ) /\ (the carrier of C185) );
reconsider D79 = D78 as (Subset of C185) by XBOOLE_1:17;
L459: ( D75 . D77 ) = ( "/\" (( ( uparrow D77 ) /\ (the carrier of C185) ) , C184) ) by L444;
L460: D77 <= D77;
L461: D77 in ( uparrow D77 ) by L460 , WAYBEL_0:18;
L462:  ex_inf_of D79 , C184 by YELLOW_0:17;
L463: ( "/\" (D79 , C184) ) in (the carrier of C185) by L462 , YELLOW_0:def 18;
L464: D77 = ( "/\" (( ( uparrow C187 ) /\ (the carrier of C185) ) , C184) ) by L444;
L465: D77 in ( ( uparrow D77 ) /\ (the carrier of C185) ) by L464 , L463 , L461 , XBOOLE_0:def 4;
L466: ( D75 . D77 ) <= D77 by L465 , L459 , YELLOW_2:22;
L467: ( D75 . D77 ) >= ( ( id C184 ) . D77 ) by L452;
L468: ( ( id C184 ) . D77 ) = D77 by L452;
thus L469: ( D76 . C187 ) = ( D75 . D77 ) by FUNCT_2:15
.= ( D75 . C187 ) by L466 , L467 , L468 , ORDERS_2:2;
end;
thus L470: ( D75 * D75 ) = D75 by L458 , FUNCT_2:63;
thus L471:now
let C188 , C189 being (Element of C184);
L472:  ex_inf_of ( ( uparrow C188 ) /\ (the carrier of C185) ) , C184 by YELLOW_0:17;
L473:  ex_inf_of ( ( uparrow C189 ) /\ (the carrier of C185) ) , C184 by YELLOW_0:17;
assume L474: C188 <= C189;
L475: ( ( uparrow C189 ) /\ (the carrier of C185) ) c= ( ( uparrow C188 ) /\ (the carrier of C185) ) by L474 , WAYBEL_0:22 , XBOOLE_1:26;
L476: ( D75 . C189 ) = ( "/\" (( ( uparrow C189 ) /\ (the carrier of C185) ) , C184) ) by L444;
L477: ( D75 . C188 ) = ( "/\" (( ( uparrow C188 ) /\ (the carrier of C185) ) , C184) ) by L444;
thus L478: ( D75 . C188 ) <= ( D75 . C189 ) by L477 , L475 , L472 , L473 , L476 , YELLOW_0:35;
end;
let C190 being set;
assume L479: C190 in (the carrier of C184);
reconsider D80 = C190 as (Element of C184) by L479;
L480: ( ( id C184 ) . D80 ) <= ( D75 . D80 ) by L452;
thus L481: thesis by L480;
end;
end;
theorem
L483: (for B134 being  complete LATTICE holds (for B135 being  closure (System of B134) holds ( Image ( closure_op B135 ) ) = ( the RelStr of B135 )))
proof
let C191 being  complete LATTICE;
let C192 being  infs-inheriting  full non  empty (SubRelStr of C191);
L484: (the carrier of ( Image ( closure_op C192 ) )) = (the carrier of C192)
proof
thus L485:now
let C193 being set;
assume L486: C193 in (the carrier of ( Image ( closure_op C192 ) ));
reconsider D81 = C193 as (Element of ( Image ( closure_op C192 ) )) by L486;
consider C194 being (Element of C191) such that L487: D81 = ( ( closure_op C192 ) . C194 ) by YELLOW_2:10;
set D82 = ( ( uparrow C194 ) /\ (the carrier of C192) );
reconsider D83 = D82 as (Subset of C192) by XBOOLE_1:17;
L488:  ex_inf_of D83 , C191 by YELLOW_0:17;
L489: D81 = ( "/\" (D83 , C191) ) by L487 , L444;
thus L490: C193 in (the carrier of C192) by L489 , L488 , YELLOW_0:def 18;
end;
set D84 = ( closure_op C192 );
let C195 being set;
assume L491: C195 in (the carrier of C192);
reconsider D85 = C195 as (Element of C192) by L491;
reconsider D86 = D85 as (Element of C191) by YELLOW_0:58;
set D87 = ( ( uparrow D86 ) /\ (the carrier of C192) );
L492: ( ( id C191 ) . D86 ) = D86 by FUNCT_1:18;
L493: D86 <= D86;
L494: D86 in ( uparrow D86 ) by L493 , WAYBEL_0:18;
L495: D86 in D87 by L494 , XBOOLE_0:def 4;
L496: ( D84 . D86 ) = ( "/\" (D87 , C191) ) by L444;
L497: ( D84 . D86 ) <= D86 by L496 , L495 , YELLOW_2:22;
L498: ( id C191 ) <= D84 by WAYBEL_1:def 14;
L499: D86 <= ( D84 . D86 ) by L498 , L492 , YELLOW_2:9;
L500: D86 = ( D84 . D86 ) by L499 , L497 , ORDERS_2:2;
L501: ( dom D84 ) = (the carrier of C191) by FUNCT_2:def 1;
L502: D86 in ( rng ( closure_op C192 ) ) by L501 , L500 , FUNCT_1:def 3;
thus L503: thesis by L502 , YELLOW_0:def 15;
end;
thus L504: thesis by L484 , YELLOW_0:57;
end;
theorem
L505: (for B136 being  complete LATTICE holds (for B137 being  closure (Function of B136 , B136) holds ( closure_op ( Image B137 ) ) = B137))
proof
let C196 being  complete LATTICE;
let C197 being  closure (Function of C196 , C196);
L506:
now
let C198 being (Element of C196);
L507: ( id C196 ) <= C197 by WAYBEL_1:def 14;
L508: C198 = ( ( id C196 ) . C198 ) by FUNCT_1:18;
L509: C198 <= ( C197 . C198 ) by L508 , L507 , YELLOW_2:9;
L510: ( C197 . C198 ) in ( uparrow C198 ) by L509 , WAYBEL_0:18;
L511: ( dom C197 ) = (the carrier of C196) by FUNCT_2:def 1;
L512: ( C197 . C198 ) in ( rng C197 ) by L511 , FUNCT_1:def 3;
L513: ( C197 . C198 ) in ( ( uparrow C198 ) /\ ( rng C197 ) ) by L512 , L510 , XBOOLE_0:def 4;
L514: ( C197 . C198 ) >= ( "/\" (( ( uparrow C198 ) /\ ( rng C197 ) ) , C196) ) by L513 , YELLOW_2:22;
L515: ( C197 . C198 ) is_<=_than ( ( uparrow C198 ) /\ ( rng C197 ) )
proof
let C199 being (Element of C196);
assume L516: C199 in ( ( uparrow C198 ) /\ ( rng C197 ) );
L517: C199 in ( rng C197 ) by L516 , XBOOLE_0:def 4;
consider C200 being set such that L518: C200 in ( dom C197 ) and L519: C199 = ( C197 . C200 ) by L517 , FUNCT_1:def 3;
reconsider D88 = C200 as (Element of C196) by L518;
L520: C199 in ( uparrow C198 ) by L516 , XBOOLE_0:def 4;
L521: C198 <= ( C197 . D88 ) by L520 , L519 , WAYBEL_0:18;
L522: ( C197 . C198 ) <= ( C197 . ( C197 . D88 ) ) by L521 , WAYBEL_1:def 2;
thus L523: thesis by L522 , L519 , YELLOW_2:18;
end;
L524: ( C197 . C198 ) <= ( "/\" (( ( uparrow C198 ) /\ ( rng C197 ) ) , C196) ) by L515 , YELLOW_0:33;
L525: ( rng C197 ) = (the carrier of ( Image C197 )) by YELLOW_0:def 15;
thus L526: ( ( closure_op ( Image C197 ) ) . C198 ) = ( "/\" (( ( uparrow C198 ) /\ ( rng C197 ) ) , C196) ) by L525 , L444
.= ( C197 . C198 ) by L514 , L524 , ORDERS_2:2;
end;
thus L527: thesis by L506 , FUNCT_2:63;
end;
registration
let C201 being  complete LATTICE;
cluster ( ClImageMap C201 ) ->  one-to-one;
coherence
proof
let C202 , C203 being (Element of ( ClOpers C201 ));
reconsider D89 = C202 , D90 = C203 as  closure (Function of C201 , C201) by L232;
set D91 = ( ClImageMap C201 );
assume L528: ( D91 . C202 ) = ( D91 . C203 );
L529: ( Image D89 ) = ( D91 . C203 ) by L528 , L431
.= ( Image D90 ) by L431;
thus L530: C202 = ( closure_op ( Image D90 ) ) by L529 , L505
.= C203 by L505;
end;
end;
theorem
L532: (for B138 being  complete LATTICE holds ( ( ClImageMap B138 ) " ) is (Function of ( ( ClosureSystems B138 ) opp ) , ( ClOpers B138 )))
proof
let C204 being  complete LATTICE;
set D92 = ( ClImageMap C204 );
L533: ( rng ( D92 " ) ) = ( dom D92 ) by FUNCT_1:33;
L534: ( dom D92 ) = (the carrier of ( ClOpers C204 )) by FUNCT_2:def 1;
L535: (the carrier of ( ( ClosureSystems C204 ) opp )) c= ( rng D92 )
proof
let C205 being set;
assume L536: C205 in (the carrier of ( ( ClosureSystems C204 ) opp ));
reconsider D93 = C205 as (Element of ( ( ClosureSystems C204 ) opp )) by L536;
reconsider D94 = D93 as  infs-inheriting  full  strict (SubRelStr of C204) by L423;
L537: ( closure_op D94 ) is (Element of ( ClOpers C204 )) by L232;
L538: ( D92 . ( closure_op D94 ) ) = ( Image ( closure_op D94 ) ) by L431
.= D94 by L483;
thus L539: thesis by L538 , L534 , L537 , FUNCT_1:def 3;
end;
L540: (the carrier of ( ( ClosureSystems C204 ) opp )) = ( rng D92 ) by L535 , XBOOLE_0:def 10;
L541: ( dom ( D92 " ) ) = ( rng D92 ) by FUNCT_1:33;
thus L542: thesis by L541 , L533 , L540 , FUNCT_2:def 1 , RELSET_1:4;
end;
theorem
L543: (for B139 being  complete LATTICE holds (for B140 being  strict  closure (System of B139) holds ( ( ( ClImageMap B139 ) " ) . B140 ) = ( closure_op B140 )))
proof
let C206 being  complete LATTICE;
let C207 being  infs-inheriting  full  strict (SubRelStr of C206);
L544: ( closure_op C207 ) is (Element of ( ClOpers C206 )) by L232;
L545: ( ( ClImageMap C206 ) . ( closure_op C207 ) ) = ( Image ( closure_op C207 ) ) by L431
.= C207 by L483;
thus L546: thesis by L545 , L544 , FUNCT_2:26;
end;
registration
let C208 being  complete LATTICE;
cluster ( ClImageMap C208 ) ->  isomorphic;
correctness
proof
set D95 = ( ClImageMap C208 );
set D96 = ( ClOpers C208 );
set D97 = ( ( ClosureSystems C208 ) opp );
reconsider D98 = ( D95 " ) as (Function of D97 , D96) by L532;
per cases ;
case L547: (D96 is non  empty & D97 is non  empty);
thus L548: D95 is  one-to-one;
thus L549: D95 is  monotone
proof
let C209 , C210 being (Element of D96);
reconsider D99 = C209 , D100 = C210 as  closure (Function of C208 , C208) by L232;
L550: ( D95 . C210 ) = ( Image D100 ) by L431;
assume L551: C209 <= C210;
L552: D99 <= D100 by L551 , L252;
L553: ( Image D100 ) is (SubRelStr of ( Image D99 )) by L552 , L268;
L554: ( D95 . C209 ) = ( Image D99 ) by L431;
L555: ( ~ ( D95 . C209 ) ) >= ( ~ ( D95 . C210 ) ) by L554 , L553 , L550 , L427;
thus L556: ( D95 . C209 ) <= ( D95 . C210 ) by L555 , YELLOW_7:1;
end;

take D98;
thus L557: D98 = ( D95 " );
thus L558: D98 is  monotone
proof
let C211 , C212 being (Element of D97);
reconsider D101 = ( ~ C211 ) , D102 = ( ~ C212 ) as  infs-inheriting  full  strict (SubRelStr of C208) by L423;
L559: D102 = ( Image ( closure_op D102 ) ) by L483;
L560: ( D98 . D101 ) = ( closure_op D101 ) by L543;
assume L561: C211 <= C212;
L562: ( ~ C212 ) <= ( ~ C211 ) by L561 , YELLOW_7:1;
L563: D102 is (SubRelStr of D101) by L562 , L427;
L564: ( D98 . D102 ) = ( closure_op D102 ) by L543;
L565: D101 = ( Image ( closure_op D101 ) ) by L483;
L566: ( closure_op D101 ) <= ( closure_op D102 ) by L565 , L563 , L559 , L268;
thus L567: ( D98 . C211 ) <= ( D98 . C212 ) by L566 , L560 , L564 , L252;
end;

end;
case L559: (D96 is  empty or D97 is  empty);
thus L560: thesis by L559;
end;
end;
end;
theorem
L563: (for B141 being  complete LATTICE holds ( ClOpers B141 ) , ( ( ClosureSystems B141 ) opp ) are_isomorphic )
proof
let C213 being  complete LATTICE;
take ( ClImageMap C213 );
thus L564: thesis;
end;
begin
theorem
L565: (for B142 being RelStr holds (for B143 being  full (SubRelStr of B142) holds (for B144 being (Subset of B143) holds ((B144 is  directed  directed  directed  directed (Subset of B142) implies B144 is  directed) & (B144 is  filtered  filtered  filtered  filtered (Subset of B142) implies B144 is  filtered)))))
proof
let C214 being RelStr;
let C215 being  full (SubRelStr of C214);
let C216 being (Subset of C215);
thus L566:now
assume L567: C216 is  directed  directed  directed  directed (Subset of C214);
thus L568: C216 is  directed
proof
L569: (the carrier of C215) c= (the carrier of C214) by YELLOW_0:def 13;
let C217 , C218 being (Element of C215);
assume that
L570: C217 in C216
and
L571: C218 in C216;
L572: C218 in (the carrier of C215) by L570;
L573: C217 in (the carrier of C215) by L570;
reconsider D103 = C217 , D104 = C218 as (Element of C214) by L573 , L572 , L569;
consider C219 being (Element of C214) such that L574: C219 in C216 and L575: C219 >= D103 and L576: C219 >= D104 by L567 , L570 , L571 , WAYBEL_0:def 1;
reconsider D105 = C219 as (Element of C215) by L574;
take D105;
thus L577: thesis by L574 , L575 , L576 , YELLOW_0:60;
end;

end;
assume L569: C216 is  filtered  filtered  filtered  filtered (Subset of C214);
L570: (the carrier of C215) c= (the carrier of C214) by YELLOW_0:def 13;
let C220 , C221 being (Element of C215);
assume that
L571: C220 in C216
and
L572: C221 in C216;
L573: C221 in (the carrier of C215) by L571;
L574: C220 in (the carrier of C215) by L571;
reconsider D106 = C220 , D107 = C221 as (Element of C214) by L574 , L573 , L570;
consider C222 being (Element of C214) such that L575: C222 in C216 and L576: C222 <= D106 and L577: C222 <= D107 by L569 , L571 , L572 , WAYBEL_0:def 2;
reconsider D108 = C222 as (Element of C215) by L575;
take D108;
thus L578: thesis by L575 , L576 , L577 , YELLOW_0:60;
end;
theorem
L579: (for B145 being  complete LATTICE holds (for B146 being  closure (System of B145) holds (( closure_op B146 ) is  directed-sups-preserving iff B146 is  directed-sups-inheriting)))
proof
let C223 being  complete LATTICE;
let C224 being  closure (System of C223);
set D109 = ( closure_op C224 );
L580: ( Image D109 ) = ( the RelStr of C224 ) by L483;
thus L581:now
set D110 = { B147 where B147 is (Element of C223) : ( D109 . B147 ) <= B147 };
set D111 = the (Element of C223);
L582: D110 c= (the carrier of C223)
proof
let C225 being set;
assume L583: C225 in D110;
L584: (ex B148 being (Element of C223) st (C225 = B148 & ( D109 . B148 ) <= B148)) by L583;
thus L585: thesis by L584;
end;
L586: ( D109 . ( D109 . D111 ) ) = ( D109 . D111 ) by YELLOW_2:18;
L587: ( D109 . D111 ) in D110 by L586;
assume L588: ( closure_op C224 ) is  directed-sups-preserving;
L589: ( Image D109 ) is  directed-sups-inheriting by L588 , L587 , L582 , WAYBEL_1:52;
thus L590: C224 is  directed-sups-inheriting
proof
let C226 being  directed (Subset of C224);
assume that
L591: C226 <> ( {} )
and
L592:  ex_sup_of C226 , C223;
reconsider D112 = C226 as (Subset of ( Image D109 )) by L580;
L593: D112 is  directed by L580 , WAYBEL_0:3;
thus L594: thesis by L593 , L580 , L589 , L591 , L592 , WAYBEL_0:def 4;
end;

end;
assume L591: (for B149 being  directed (Subset of C224) holds ((B149 <> ( {} ) &  ex_sup_of B149 , C223) implies ( "\/" (B149 , C223) ) in (the carrier of C224)));
let C227 being (Subset of C223);
assume that
L592: C227 is non  empty  directed;
L593: ( rng D109 ) = (the carrier of C224) by L580 , YELLOW_0:def 15;
reconsider D113 = ( D109 .: C227 ) as (Subset of C224) by L593 , RELAT_1:111;
assume L594:  ex_sup_of C227 , C223;
thus L595:  ex_sup_of ( D109 .: C227 ) , C223 by YELLOW_0:17;
L596: ( D109 .: C227 ) is_<=_than ( D109 . ( sup C227 ) )
proof
let C228 being (Element of C223);
assume L597: C228 in ( D109 .: C227 );
consider C229 being set such that L598: C229 in (the carrier of C223) and L599: C229 in C227 and L600: C228 = ( D109 . C229 ) by L597 , FUNCT_2:64;
reconsider D114 = C229 as (Element of C223) by L598;
L601: D114 <= ( sup C227 ) by L599 , YELLOW_2:22;
thus L602: thesis by L601 , L600 , WAYBEL_1:def 2;
end;
L603: ( sup ( D109 .: C227 ) ) <= ( D109 . ( sup C227 ) ) by L596 , YELLOW_0:32;
L604: C227 is_<=_than ( sup ( D109 .: C227 ) )
proof
let C230 being (Element of C223);
assume L605: C230 in C227;
L606: ( D109 . C230 ) in ( D109 .: C227 ) by L605 , FUNCT_2:35;
L607: ( D109 . C230 ) <= ( sup ( D109 .: C227 ) ) by L606 , YELLOW_2:22;
L608: C230 <= ( D109 . C230 ) by L138;
thus L609: thesis by L608 , L607 , ORDERS_2:3;
end;
L610: ( sup C227 ) <= ( sup ( D109 .: C227 ) ) by L604 , YELLOW_0:32;
set D115 = the (Element of C227);
L611: D115 in C227 by L592;
L612: ( D109 . D115 ) in ( D109 .: C227 ) by L611 , FUNCT_2:35;
L613: D113 is  directed by L592 , L565 , YELLOW_2:15;
L614: ( sup ( D109 .: C227 ) ) in (the carrier of C224) by L613 , L591 , L612 , YELLOW_0:17;
L615: (ex B150 being (Element of C223) st ( D109 . B150 ) = ( sup ( D109 .: C227 ) )) by L614 , L580 , YELLOW_2:10;
L616: ( D109 . ( sup ( D109 .: C227 ) ) ) = ( sup ( D109 .: C227 ) ) by L615 , YELLOW_2:18;
L617: ( D109 . ( sup C227 ) ) <= ( sup ( D109 .: C227 ) ) by L616 , L610 , WAYBEL_1:def 2;
thus L618: thesis by L617 , L603 , ORDERS_2:2;
end;
theorem
L619: (for B151 being  complete LATTICE holds (for B152 being  closure (Function of B151 , B151) holds (B152 is  directed-sups-preserving iff ( Image B152 ) is  directed-sups-inheriting)))
proof
let C231 being  complete LATTICE;
let C232 being  closure (Function of C231 , C231);
L620: ( closure_op ( Image C232 ) ) = C232 by L505;
thus L621: thesis by L620 , L579;
end;
registration
let C233 being  complete LATTICE;
let C234 being  directed-sups-inheriting  closure (System of C233);
cluster ( closure_op C234 ) ->  directed-sups-preserving;
coherence by L579;
end;
registration
let C235 being  complete LATTICE;
let C236 being  directed-sups-preserving  closure (Function of C235 , C235);
cluster ( Image C236 ) ->  directed-sups-inheriting;
coherence
proof
L623: C236 = ( closure_op ( Image C236 ) ) by L505;
thus L624: thesis by L623 , L579;
end;
end;
definition
let C237 being non  empty  reflexive RelStr;
func DsupClOpers C237 -> non  empty  full  strict (SubRelStr of ( ClOpers C237 )) means 
:L626: (for B153 being  closure (Function of C237 , C237) holds (B153 is (Element of it) iff B153 is  directed-sups-preserving));
existence
proof
defpred S12[ set ] means $1 is  directed-sups-preserving  directed-sups-preserving  directed-sups-preserving  directed-sups-preserving (Function of C237 , C237);
set D116 = the  directed-sups-preserving  closure (Function of C237 , C237);
L627: D116 is (Element of ( ClOpers C237 )) by L203;
L628: D116 in (the carrier of ( ClOpers C237 )) by L627;
L629: S12[ D116 ];
consider C238 being non  empty  full  strict (SubRelStr of ( ClOpers C237 )) such that L630: (for B154 being (Element of ( ClOpers C237 )) holds (B154 is (Element of C238) iff S12[ B154 ])) from SubrelstrEx(L629 , L628);
take C238;
let C239 being  closure (Function of C237 , C237);
thus L631:now
assume L632: C239 is (Element of C238);
L633: C239 is (Element of ( ClOpers C237 )) by L632 , YELLOW_0:58;
thus L634: C239 is  directed-sups-preserving by L633 , L630 , L632;
end;
assume L635: C239 is  directed-sups-preserving;
L636: C239 is (Element of ( ClOpers C237 )) by L203;
thus L637: thesis by L636 , L630 , L635;
end;
correctness
proof
defpred S13[ set ] means $1 is  directed-sups-preserving  closure  directed-sups-preserving  closure  directed-sups-preserving  closure  directed-sups-preserving  closure (Function of C237 , C237);
let C240 , C241 being non  empty  full  strict (SubRelStr of ( ClOpers C237 ));
assume that
L638: (for B155 being  closure (Function of C237 , C237) holds (B155 is (Element of C240) iff B155 is  directed-sups-preserving))
and
L639: (for B156 being  closure (Function of C237 , C237) holds (B156 is (Element of C241) iff B156 is  directed-sups-preserving));
L640:
now
let C242 being set;
L641: (C242 is (Element of C241) implies C242 is (Element of ( ClOpers C237 ))) by YELLOW_0:58;
L642: (C242 is (Element of C241) implies C242 is  closure  closure  closure  closure (Function of C237 , C237)) by L641 , L232;
thus L643: (C242 is (Element of C241) iff S13[ C242 ]) by L642 , L639;
end;
L644:
now
let C243 being set;
L645: (C243 is (Element of C240) implies C243 is (Element of ( ClOpers C237 ))) by YELLOW_0:58;
L646: (C243 is (Element of C240) implies C243 is  closure  closure  closure  closure (Function of C237 , C237)) by L645 , L232;
thus L647: (C243 is (Element of C240) iff S13[ C243 ]) by L646 , L638;
end;
L648: ( the RelStr of C240 ) = ( the RelStr of C241 ) from SubrelstrEq1(L644 , L640);
thus L649: thesis by L648;
end;
end;
theorem
L651: (for B157 being non  empty  reflexive RelStr holds (for B158 being set holds (B158 is (Element of ( DsupClOpers B157 )) iff B158 is  directed-sups-preserving  closure  directed-sups-preserving  closure  directed-sups-preserving  closure  directed-sups-preserving  closure (Function of B157 , B157))))
proof
let C244 being non  empty  reflexive RelStr;
let C245 being set;
L652: (C245 is (Element of ( ClOpers C244 )) iff C245 is  closure  closure  closure  closure (Function of C244 , C244)) by L232;
thus L653: thesis by L652 , L626 , YELLOW_0:58;
end;
definition
let C246 being non  empty RelStr;
func Subalgebras C246 ->  full  strict non  empty (SubRelStr of ( ClosureSystems C246 )) means 
:L654: (for B159 being  strict  closure (System of C246) holds (B159 is (Element of it) iff B159 is  directed-sups-inheriting));
existence
proof
defpred S14[ set ] means $1 is  directed-sups-inheriting  directed-sups-inheriting  directed-sups-inheriting  directed-sups-inheriting (SubRelStr of C246);
set D117 = ( subrelstr ( [#] C246 ) );
L655: D117 is (Element of ( ClosureSystems C246 )) by L403;
L656: D117 in (the carrier of ( ClosureSystems C246 )) by L655;
L657: S14[ D117 ];
consider C247 being non  empty  full  strict (SubRelStr of ( ClosureSystems C246 )) such that L658: (for B160 being (Element of ( ClosureSystems C246 )) holds (B160 is (Element of C247) iff S14[ B160 ])) from SubrelstrEx(L657 , L656);
take C247;
let C248 being  strict  closure (System of C246);
L659: C248 is (Element of ( ClosureSystems C246 )) by L403;
thus L660: thesis by L659 , L658;
end;
correctness
proof
defpred S15[ set ] means $1 is  directed-sups-inheriting  strict  closure  directed-sups-inheriting  strict  closure  directed-sups-inheriting  strict  closure  directed-sups-inheriting  strict  closure (System of C246);
let C249 , C250 being  full  strict non  empty (SubRelStr of ( ClosureSystems C246 ));
assume that
L661: (for B161 being  strict  closure (System of C246) holds (B161 is (Element of C249) iff B161 is  directed-sups-inheriting))
and
L662: (for B162 being  strict  closure (System of C246) holds (B162 is (Element of C250) iff B162 is  directed-sups-inheriting));
L663:
now
let C251 being set;
L664: (C251 is (Element of C250) implies C251 is (Element of ( ClosureSystems C246 ))) by YELLOW_0:58;
L665: (C251 is (Element of C250) implies C251 is  strict  closure  strict  closure  strict  closure  strict  closure (System of C246)) by L664 , L423;
thus L666: (C251 is (Element of C250) iff S15[ C251 ]) by L665 , L662;
end;
L667:
now
let C252 being set;
L668: (C252 is (Element of C249) implies C252 is (Element of ( ClosureSystems C246 ))) by YELLOW_0:58;
L669: (C252 is (Element of C249) implies C252 is  strict  closure  strict  closure  strict  closure  strict  closure (System of C246)) by L668 , L423;
thus L670: (C252 is (Element of C249) iff S15[ C252 ]) by L669 , L661;
end;
L671: ( the RelStr of C249 ) = ( the RelStr of C250 ) from SubrelstrEq1(L667 , L663);
thus L672: thesis by L671;
end;
end;
theorem
L674: (for B163 being non  empty RelStr holds (for B164 being set holds (B164 is (Element of ( Subalgebras B163 )) iff B164 is  strict  directed-sups-inheriting  closure  strict  directed-sups-inheriting  closure  strict  directed-sups-inheriting  closure  strict  directed-sups-inheriting  closure (System of B163))))
proof
let C253 being non  empty RelStr;
let C254 being set;
L675: (C254 is (Element of ( ClosureSystems C253 )) iff C254 is  strict  closure  strict  closure  strict  closure  strict  closure (System of C253)) by L423;
thus L676: thesis by L675 , L654 , YELLOW_0:58;
end;
theorem
L677: (for B165 being  complete LATTICE holds ( Image ( ( ClImageMap B165 ) | ( DsupClOpers B165 ) ) ) = ( ( Subalgebras B165 ) opp ))
proof
let C255 being  complete LATTICE;
defpred S16[ set ] means $1 is  directed-sups-inheriting  closure  strict  directed-sups-inheriting  closure  strict  directed-sups-inheriting  closure  strict  directed-sups-inheriting  closure  strict (System of C255);
L678:
now
let C256 being set;
thus L679:now
assume L680: C256 is (Element of ( Image ( ( ClImageMap C255 ) | ( DsupClOpers C255 ) ) ));
consider C257 being (Element of ( DsupClOpers C255 )) such that L681: ( ( ( ClImageMap C255 ) | ( DsupClOpers C255 ) ) . C257 ) = C256 by L680 , YELLOW_2:10;
reconsider D118 = C257 as  directed-sups-preserving  closure (Function of C255 , C255) by L651;
L682: C256 = ( ( ClImageMap C255 ) . D118 ) by L681 , L142
.= ( Image D118 ) by L431;
thus L683: S16[ C256 ] by L682;
end;
assume L684: S16[ C256 ];
reconsider D119 = C256 as  directed-sups-inheriting  closure  strict (System of C255) by L684;
reconsider D120 = ( closure_op D119 ) as (Element of ( DsupClOpers C255 )) by L651;
L685: D119 = ( Image ( closure_op D119 ) ) by L483
.= ( ( ClImageMap C255 ) . ( closure_op D119 ) ) by L431
.= ( ( ( ClImageMap C255 ) | ( DsupClOpers C255 ) ) . D120 ) by L142;
L686: D119 in ( rng ( ( ClImageMap C255 ) | ( DsupClOpers C255 ) ) ) by L685 , FUNCT_2:4;
thus L687: C256 is (Element of ( Image ( ( ClImageMap C255 ) | ( DsupClOpers C255 ) ) )) by L686 , YELLOW_0:def 15;
end;
L688: (for B166 being set holds (B166 is (Element of ( ( Subalgebras C255 ) opp )) iff S16[ B166 ])) by L674;
L689: ( the RelStr of ( Image ( ( ClImageMap C255 ) | ( DsupClOpers C255 ) ) ) ) = ( the RelStr of ( ( Subalgebras C255 ) opp ) ) from SubrelstrEq1(L678 , L688);
thus L690: thesis by L689;
end;
registration
let C258 being  complete LATTICE;
cluster ( corestr ( ( ClImageMap C258 ) | ( DsupClOpers C258 ) ) ) ->  isomorphic;
coherence
proof
set D121 = ( ClImageMap C258 );
set D122 = ( DsupClOpers C258 );
set D123 = ( corestr ( D121 | D122 ) );
per cases ;
case L691: (( DsupClOpers C258 ) is non  empty & ( Image ( D121 | D122 ) ) is non  empty);
L692: ( D121 | D122 ) is  one-to-one by L146;
thus L693: D123 is  one-to-one  monotone by L692 , WAYBEL_1:30;
consider C259 being (Function of ( ( ClosureSystems C258 ) opp ) , ( ClOpers C258 )) such that L694: C259 = ( D121 " ) and L695: C259 is  monotone by WAYBEL_0:def 38;
reconsider D124 = ( C259 | ( Image ( D121 | D122 ) ) ) as (Function of ( Image ( D121 | D122 ) ) , D122) by L694 , L160;
take D124;
thus L696: D124 = ( ( D121 | D122 ) " ) by L694 , L160
.= ( D123 " ) by WAYBEL_1:30;
let C260 , C261 being (Element of ( Image ( D121 | D122 ) ));
reconsider D125 = C260 , D126 = C261 as (Element of ( ( ClosureSystems C258 ) opp )) by YELLOW_0:58;
reconsider D127 = ( ~ D125 ) , D128 = ( ~ D126 ) as  strict  closure (System of C258) by L423;
reconsider D129 = ( closure_op D127 ) , D130 = ( closure_op D128 ) as (Element of ( ClOpers C258 )) by L232;
L697: ( C259 . C261 ) = D130 by L694 , L543;
L698: ( D124 . C261 ) = D130 by L697 , L142;
assume L699: C260 <= C261;
L700: D125 <= D126 by L699 , YELLOW_0:59;
L701: ( ~ D125 ) >= ( ~ D126 ) by L700 , YELLOW_7:1;
L702: D128 is (SubRelStr of D127) by L701 , L427;
L703: D128 = ( Image ( closure_op D128 ) ) by L483;
L704: D127 = ( Image ( closure_op D127 ) ) by L483;
L705: ( closure_op D127 ) <= ( closure_op D128 ) by L704 , L702 , L703 , L268;
L706: D129 <= D130 by L705 , L252;
L707: ( C259 . C260 ) = D129 by L694 , L543;
L708: ( D124 . C260 ) = D129 by L707 , L142;
thus L709: ( D124 . C260 ) <= ( D124 . C261 ) by L708 , L698 , L706 , YELLOW_0:60;
end;
case L710: (( DsupClOpers C258 ) is  empty or ( Image ( D121 | D122 ) ) is  empty);
thus L711: thesis by L710;
end;
end;
end;
theorem
L714: (for B167 being  complete LATTICE holds ( DsupClOpers B167 ) , ( ( Subalgebras B167 ) opp ) are_isomorphic )
proof
let C262 being  complete LATTICE;
set D131 = ( ( ClImageMap C262 ) | ( DsupClOpers C262 ) );
reconsider D132 = ( corestr D131 ) as (Function of ( DsupClOpers C262 ) , ( ( Subalgebras C262 ) opp )) by L677;
take D132;
L715: ( Image D131 ) = ( ( Subalgebras C262 ) opp ) by L677;
thus L716: thesis by L715;
end;
