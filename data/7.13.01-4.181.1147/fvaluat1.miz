:: Valuation Theory, Part {I}
::  by Grzegorz Bancerek , Hidetsune Kobayashi and Artur Korni{\l}owicz
::
:: Received April 7, 2011
:: Copyright (c) 2011-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies INT_1, VECTSP_1, FUNCT_1, ARYTM_3, ZFMISC_1, RELAT_1, RLVECT_1,
      FUNCOP_1, ARYTM_1, BINOP_1, FUNCSDOM, REALSET1, LATTICES, GROUP_1,
      ORDINAL2, IDEAL_1, FINSEQ_1, SUBSET_1, VECTSP_2, FUNCT_3, NUMBERS,
      GROUP_4, STRUCT_0, RLSUB_1, XXREAL_2, ALGSTR_0, XCMPLX_0, ORDINAL1,
      REALSET2, NAT_1, REAL_1, INT_2, XXREAL_0, TARSKI, XREAL_0, XBOOLE_0,
      NEWTON, CARD_FIL, RMOD_2, CARD_1, SUPINF_2, MESFUNC1, PARTFUN1, COMPLEX1,
      MEMBERED, MSSUBFAM, FVALUAT1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, ORDINAL1, DOMAIN_1,
      RELAT_1, FUNCT_1, RELSET_1, PARTFUN1, FUNCT_2, FUNCOP_1, XXREAL_0,
      XREAL_0, XXREAL_2, XXREAL_3, XCMPLX_0, REAL_1, INT_1, MEMBERED, SUPINF_2,
      EXTREAL1, INT_2, MESFUNC1, FINSEQ_1, FINSEQ_4, REALSET1, BINOP_1,
      STRUCT_0, ALGSTR_0, RLVECT_1, GRCAT_1, GROUP_1, YELLOW_9, VECTSP_1,
      VECTSP_2, FUNCSDOM, REALSET2, RMOD_2, IDEAL_1, RING_1;
 constructors REAL_1, FINSEQ_4, SUPINF_2, EXTREAL1, MESFUNC1, RMOD_2, YELLOW_9,
      RING_1, BINOM, FUNCOP_1, REALSET2, RELSET_1, GRCAT_1;
 registrations RELSET_1, VECTSP_1, INT_1, XREAL_0, ALGSTR_1, VECTSP_2,
      STRUCT_0, NAT_1, SUBSET_1, WAYBEL_2, XBOOLE_0, RMOD_2, XCMPLX_0, IDEAL_1,
      RING_1, XXREAL_0, NUMBERS, MEMBERED, ORDINAL1, ALGSTR_0, XXREAL_3,
      REALSET2, FINSEQ_1;
 requirements NUMERALS, ARITHM, REAL, BOOLE, SUBSET;
 definitions TARSKI, XBOOLE_0, SUBSET_1, FUNCT_2, BINOP_1, XREAL_0, XCMPLX_0,
      XXREAL_2, XXREAL_3, REALSET1, RING_1, MESFUNC1, STRUCT_0, ALGSTR_0,
      RLVECT_1, GROUP_1, GRCAT_1, VECTSP_1, VECTSP_2, IDEAL_1, RMOD_2;
 theorems VECTSP_1, FUNCOP_1, TARSKI, FUNCT_1, INT_1, RLVECT_1, XREAL_0,
      VECTSP_2, XBOOLE_0, FUNCT_2, ABSVALUE, NAT_1, ZFMISC_1, REALSET1,
      FINSEQ_1, FINSEQ_3, XBOOLE_1, TOPREALA, FINSEQ_5, GROUP_1, IDEAL_1,
      RMOD_2, YELLOW_9, RELAT_1, RING_1, XXREAL_0, ORDINAL1, XXREAL_3,
      PARTFUN1, ALGSTR_0, XXREAL_2, SUBSET_1, CARD_1;
 schemes NAT_1, INT_1, RECDEF_1, FUNCT_2;

begin
theorem
L1: (for R1 being  ext-real number holds (R1 = ( - R1 ) implies R1 = ( 0 )))
proof
let R1 being  ext-real number;
per cases  by XXREAL_0:14;
suppose L2: (R1 = ( +infty ) or R1 = ( -infty ));

thus L3: thesis by L2;
end;
suppose L4: R1 in ( REAL );

reconsider D1 = R1 as (Element of ( REAL )) by L4;
L5: ( - R1 ) = ( - D1 ) by XXREAL_3:def 3;
thus L6: thesis by L5;
end;
end;
theorem
L8: (for R1 being  ext-real number holds (( R1 + R1 ) = ( 0 ) implies R1 = ( 0 )))
proof
let R1 being  ext-real number;
assume L9: ( R1 + R1 ) = ( 0 );
L10: R1 = ( - R1 ) by L9 , XXREAL_3:8;
thus L11: thesis by L10 , L1;
end;
theorem
L12: (for R1 being  ext-real number holds (for R2 being  ext-real number holds (for R3 being  ext-real number holds (for R4 being  ext-real number holds ((( 0 ) <= R1 & R1 <= R2 & ( 0 ) <= R4 & R4 <= R3) implies ( R1 * R4 ) <= ( R2 * R3 ))))))
proof
let R1 being  ext-real number;
let R2 being  ext-real number;
let R3 being  ext-real number;
let R4 being  ext-real number;
assume that
L13: ( 0 ) <= R1
and
L14: R1 <= R2
and
L15: ( 0 ) <= R4
and
L16: R4 <= R3;
L17: ( R1 * R4 ) <= ( R2 * R4 ) by L14 , L15 , XXREAL_3:71;
L18: ( R2 * R4 ) <= ( R2 * R3 ) by L13 , L14 , L16 , XXREAL_3:71;
thus L19: thesis by L18 , L17 , XXREAL_0:2;
end;
L20:
now
let C1 , C2 being  real number;
let C3 , C4 being  ext-real number;
assume L21: (C1 = C3 & C2 = C4);
L22: ( - C2 ) = ( - C4 ) by L21 , XXREAL_3:def 3;
thus L23: ( C1 - C2 ) = ( C3 - C4 ) by L22 , L21 , XXREAL_3:def 2;
end;
L24:
now
let C5 , C6 being  real number;
let C7 , C8 being  ext-real number;
assume L25: (C5 = C7 & C6 = C8);
L26: ( C6 " ) = ( C8 " ) by L25 , XXREAL_3:def 6;
thus L27: ( C5 / C6 ) = ( C7 / C8 ) by L26 , L25 , XXREAL_3:def 5;
end;
theorem
L28: (for R1 being  ext-real number holds (for R2 being  ext-real number holds ((R2 <> ( +infty ) & ( 0 ) < R1 & ( 0 ) < R2) implies ( 0 ) < ( R1 / R2 ))))
proof
let R1 being  ext-real number;
let R2 being  ext-real number;
assume that
L29: R2 <> ( +infty )
and
L30: ( 0 ) < R1
and
L31: ( 0 ) < R2;
per cases  by XXREAL_0:14;
suppose L32: R1 in ( REAL );

reconsider D2 = R1 as Real by L32;
reconsider D3 = R2 as Real by L29 , L31 , XXREAL_0:14;
L33: ( R1 / R2 ) = ( D2 / D3 ) by L24;
thus L34: thesis by L33 , L30 , L31;
end;
suppose L35: R1 = ( +infty );

thus L36: thesis by L35 , L29 , L31 , XXREAL_3:83;
end;
suppose L37: R1 = ( -infty );

thus L38: thesis by L37 , L30;
end;
end;
theorem
L40: (for R1 being  ext-real number holds (for R2 being  ext-real number holds ((R2 <> ( +infty ) & R1 < ( 0 ) & ( 0 ) < R2) implies ( R1 / R2 ) < ( 0 ))))
proof
let R1 being  ext-real number;
let R2 being  ext-real number;
assume that
L41: R2 <> ( +infty )
and
L42: R1 < ( 0 )
and
L43: ( 0 ) < R2;
reconsider D4 = R2 as Real by L43 , L41 , XXREAL_0:14;
per cases  by XXREAL_0:14;
suppose L44: R1 in ( REAL );

reconsider D5 = R1 as Real by L44;
L45: ( R1 / R2 ) = ( D5 / D4 ) by L24;
thus L46: thesis by L45 , L42 , L43;
end;
suppose L47: R1 = ( +infty );

thus L48: thesis by L47 , L42;
end;
suppose L49: R1 = ( -infty );

thus L50: thesis by L49 , L41 , L43 , XXREAL_3:86;
end;
end;
theorem
L52: (for R1 being  ext-real number holds (for R2 being  ext-real number holds ((R2 <> ( -infty ) & ( 0 ) < R1 & R2 < ( 0 )) implies ( R1 / R2 ) < ( 0 ))))
proof
let R1 being  ext-real number;
let R2 being  ext-real number;
assume that
L53: R2 <> ( -infty )
and
L54: ( 0 ) < R1
and
L55: R2 < ( 0 );
reconsider D6 = R2 as Real by L53 , L55 , XXREAL_0:14;
per cases  by XXREAL_0:14;
suppose L56: R1 in ( REAL );

reconsider D7 = R1 as Real by L56;
L57: ( R1 / R2 ) = ( D7 / D6 ) by L24;
thus L58: thesis by L57 , L54 , L55;
end;
suppose L59: R1 = ( +infty );

thus L60: thesis by L59 , L53 , L55 , XXREAL_3:85;
end;
suppose L61: R1 = ( -infty );

thus L62: thesis by L61 , L54;
end;
end;
theorem
L64: (for R1 being  ext-real number holds (for R2 being  ext-real number holds (for R3 being  ext-real number holds (((R1 in ( REAL ) & R2 in ( REAL )) or R3 in ( REAL )) implies ( ( R1 + R2 ) / R3 ) = ( ( R1 / R3 ) + ( R2 / R3 ) )))))
proof
let R1 being  ext-real number;
let R2 being  ext-real number;
let R3 being  ext-real number;
assume L65: ((R1 in ( REAL ) & R2 in ( REAL )) or R3 in ( REAL ));
per cases  by L65;
suppose L66: (R1 in ( REAL ) & R2 in ( REAL ));

reconsider D8 = R1 , D9 = R2 as Real by L66;
per cases  by XXREAL_0:14;
suppose L67: R3 in ( REAL );

thus L68: thesis by L67 , XXREAL_3:95;
end;
suppose L69: (R3 = ( +infty ) or R3 = ( -infty ));

thus L70: ( ( R1 + R2 ) / R3 ) = ( ( 0 ) + ( 0 ) ) by L69
.= ( ( R1 / R3 ) + ( R2 / R3 ) ) by L69;
end;
end;
suppose L72: R3 in ( REAL );

thus L73: thesis by L72 , XXREAL_3:95;
end;
end;
theorem
L75: (for R1 being  ext-real number holds (for R2 being  ext-real number holds ((R2 <> ( +infty ) & R2 <> ( -infty ) & R2 <> ( 0 )) implies ( ( R1 / R2 ) * R2 ) = R1)))
proof
let R1 being  ext-real number;
let R2 being  ext-real number;
assume that
L76: (R2 <> ( +infty ) & R2 <> ( -infty ))
and
L77: R2 <> ( 0 );
thus L78: ( ( R1 / R2 ) * R2 ) = ( ( R1 * ( 1 / R2 ) ) * R2 ) by XXREAL_3:81
.= ( R1 * ( ( 1 / R2 ) * R2 ) ) by XXREAL_3:66
.= ( R1 * 1 ) by L76 , L77 , XXREAL_3:87
.= R1 by XXREAL_3:81;
end;
theorem
L79: (for R1 being  ext-real number holds (for R2 being  ext-real number holds ((R2 <> ( -infty ) & R2 <> ( +infty ) & R1 <> ( 0 ) & R2 <> ( 0 )) implies ( R1 / R2 ) <> ( 0 ))))
proof
let R1 being  ext-real number;
let R2 being  ext-real number;
assume that
L80: (R2 <> ( -infty ) & R2 <> ( +infty ))
and
L81: R1 <> ( 0 )
and
L82: R2 <> ( 0 );
assume L83: ( R1 / R2 ) = ( 0 );
L84: ( R2 " ) = ( 0 ) by L83 , L81;
thus L85: thesis by L84 , L80 , L82 , XXREAL_3:82;
end;
definition
let C9 being number;
attr C9 is  ext-integer
means
:L86: (C9 is  integer or C9 = ( +infty ));
end;
registration
cluster  ext-integer ->  ext-real for number;
coherence
proof
let C10 being number;
assume L88: (C10 is  integer or C10 = ( +infty ));
thus L89: thesis by L88;
end;
end;
registration
cluster ( +infty ) ->  ext-integer;
coherence by L86;
cluster ( -infty ) -> non  ext-integer;
coherence
proof
thus L91: ((not ( -infty ) is  integer) & ( -infty ) <> ( +infty ));
end;
cluster ( 1. ) ->  ext-integer  positive  real;
coherence by L86;
cluster  integer ->  ext-integer for number;
coherence by L86;
cluster  real  ext-integer ->  integer for number;
coherence
proof
let C11 being number;
assume L92: (C11 in ( REAL ) & (C11 is  integer or C11 = ( +infty )));
thus L93: thesis by L92;
end;
end;
registration
cluster  real  ext-integer  positive for (Element of ( ExtREAL ));
existence
proof
take ( 1. );
thus L95: thesis;
end;
cluster  positive for  ext-integer  ext-integer  ext-integer  ext-integer number;
existence
proof
take ( +infty );
thus L96: thesis;
end;
end;
definition
mode ExtInt
 is  ext-integer number;
end;
theorem
L99: (for R9 being ExtInt holds (for R10 being ExtInt holds (R9 < R10 implies ( R9 + 1 ) <= R10)))
proof
let R9 being ExtInt;
let R10 being ExtInt;
assume L100: R9 < R10;
per cases ;
suppose L101: (R9 in ( REAL ) & R10 in ( REAL ));

reconsider D10 = R9 , D11 = R10 as Real by L101;
L102: (ex B1 , B2 being Real st (B1 = ( R9 + ( 1. ) ) & B2 = R10 & B1 <= B2))
proof
take ( D10 + 1 );
take D11;
thus L103: ( D10 + 1 ) = ( R9 + ( 1. ) ) by XXREAL_3:def 2;
thus L104: D11 = R10;
thus L105: ( D10 + 1 ) <= D11 by L100 , INT_1:7;
end;
thus L106: thesis by L102;
end;
suppose L107: ((not R9 in ( REAL )) or (not R10 in ( REAL )));

L108: (R9 = ( +infty ) or R9 = ( -infty ) or R10 = ( +infty ) or R10 = ( -infty )) by L107 , XXREAL_0:14;
thus L109: thesis by L108 , L100 , XXREAL_0:3;
end;
end;
theorem
L111: (for R9 being ExtInt holds ( -infty ) < R9)
proof
let R9 being ExtInt;
L112: (R9 is Integer or R9 = ( +infty )) by L86;
L113: (R9 in ( REAL ) or R9 = ( +infty )) by L112 , XREAL_0:def 1;
thus L114: thesis by L113 , XXREAL_0:12;
end;
definition
let C12 being  ext-real-membered set;
given C13 being  positive ExtInt such that
L115: C13 in C12;

func least-positive C12 ->  positive ExtInt means 
:L116: (it in C12 & (for B3 being  positive ExtInt holds (B3 in C12 implies it <= B3)));
existence
proof
defpred S1[ Integer ] means ($1 in C12 & $1 is  positive);
per cases ;
suppose L117: (ex B4 being  positive Integer st B4 in C12);

L118: (ex B5 being Integer st S1[ B5 ]) by L117;
L119: (for B6 being Integer holds (S1[ B6 ] implies ( 0 ) <= B6));
consider C14 being Integer such that L120: S1[ C14 ] and L121: (for B7 being Integer holds (S1[ B7 ] implies C14 <= B7)) from INT_1:sch 5(L119 , L118);
reconsider D12 = C14 as  positive ExtInt by L120;
take D12;
thus L122: D12 in C12 by L120;
let C15 being  positive ExtInt;
assume L123: C15 in C12;
per cases ;
suppose L124: C15 is Integer;

reconsider D13 = C15 as Integer by L124;
L125: C14 <= D13 by L123 , L121;
thus L126: D12 <= C15 by L125;
end;
suppose L127: (not C15 is Integer);

L128: C15 = ( +infty ) by L127 , L86;
thus L129: thesis by L128 , XXREAL_0:3;
end;
end;
suppose L131: (not (ex B8 being  positive Integer st B8 in C12));

take C13;
thus L132: C13 in C12 by L115;
let C16 being  positive ExtInt;
assume L133: C16 in C12;
L134: ((not C16 is  positive  positive  positive  positive Integer) & ( +infty ) <= ( +infty )) by L133 , L131;
L135: C16 = ( +infty ) by L134 , L86;
thus L136: C13 <= C16 by L135 , XXREAL_0:3;
end;
end;
uniqueness
proof
let C17 , C18 being  positive ExtInt;
assume L138: (C17 in C12 & (for B9 being  positive ExtInt holds (B9 in C12 implies C17 <= B9)) & C18 in C12 & (for B10 being  positive ExtInt holds (B10 in C12 implies C18 <= B10)));
L139: (C17 <= C18 & C18 <= C17) by L138;
thus L140: thesis by L139 , XXREAL_0:1;
end;
end;
definition
let C19 being Relation;
attr C19 is  e.i.-valued
means
:L142: (for B11 being set holds (B11 in ( rng C19 ) implies B11 is  ext-integer));
end;
registration
cluster  e.i.-valued for Function;
existence
proof
take D14 = ( ( 0 ) --> ( 0. ) );
let C20 being set;
L144: ( rng D14 ) c= { ( 0 ) } by FUNCOP_1:13;
thus L145: thesis by L144;
end;
end;
registration
let C21 being set;
cluster  e.i.-valued for (Function of C21 , ( ExtREAL ));
existence
proof
take D15 = ( C21 --> ( 0. ) );
let C22 being set;
L147: ( rng D15 ) c= { ( 0 ) } by FUNCOP_1:13;
thus L148: thesis by L147;
end;
end;
registration
let C23 being  e.i.-valued Function;
let C24 being set;
cluster ( C23 . C24 ) ->  ext-integer;
coherence
proof
per cases ;
suppose L150: C24 in ( dom C23 );

L151: ( C23 . C24 ) in ( rng C23 ) by L150 , FUNCT_1:def 3;
thus L152: thesis by L151 , L142;
end;
suppose L153: (not C24 in ( dom C23 ));

thus L154: thesis by L153 , FUNCT_1:def 2;
end;
end;
end;
begin
theorem
L157: (for B12 being  distributive  left_unital  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds ( ( - ( 1. B12 ) ) * ( - ( 1. B12 ) ) ) = ( 1. B12 ))
proof
let C25 being  distributive  left_unital  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
thus L158: ( ( - ( 1. C25 ) ) * ( - ( 1. C25 ) ) ) = ( ( 1. C25 ) * ( 1. C25 ) ) by VECTSP_1:10
.= ( 1. C25 ) by VECTSP_1:def 8;
end;
definition
let C26 being non  empty doubleLoopStr;
let C27 being (Subset of C26);
let C28 being Nat;
func C27 |^ C28 -> (Subset of C26) means 
:L159: it = (the carrier of C26) if C28 = ( 0 ) otherwise (ex B13 being (FinSequence of ( bool (the carrier of C26) )) st (it = ( B13 . ( len B13 ) ) & ( len B13 ) = C28 & ( B13 . 1 ) = C27 & (for B14 being Nat holds ((B14 in ( dom B13 ) & ( B14 + 1 ) in ( dom B13 )) implies ( B13 . ( B14 + 1 ) ) = ( C27 *' ( B13 /. B14 ) )))));
consistency;
existence
proof
thus L160:now
assume L161: C28 = ( 0 );
take D16 = ( [#] C26 );
thus L162: D16 = (the carrier of C26);
end;
assume L163: C28 <> ( 0 );
set D17 = ( bool (the carrier of C26) );
reconsider D18 = C28 as (Element of ( NAT )) by ORDINAL1:def 12;
defpred S2[ set , set , set ] means (ex B15 being (Subset of C26) st (B15 = $2 & $3 = ( C27 *' B15 )));
L164: (for B16 being (Element of ( NAT )) holds ((1 <= B16 & B16 < D18) implies (for B17 being (Element of D17) holds (ex B18 being (Element of D17) st S2[ B16 , B17 , B18 ]))))
proof
let C29 being (Element of ( NAT ));
assume that
L165: (1 <= C29 & C29 < D18);
let C30 being (Element of D17);
take ( C27 *' C30 );
thus L166: thesis;
end;
consider C31 being (FinSequence of D17) such that L167: ( len C31 ) = D18 and L168: (( C31 . 1 ) = C27 or D18 = ( 0 )) and L169: (for B19 being (Element of ( NAT )) holds ((1 <= B19 & B19 < D18) implies S2[ B19 , ( C31 . B19 ) , ( C31 . ( B19 + 1 ) ) ])) from RECDEF_1:sch 4(L164);
take ( C31 /. ( len C31 ) );
take C31;
L170: ( len C31 ) in ( dom C31 ) by L163 , L167 , CARD_1:27 , FINSEQ_5:6;
thus L171: ( C31 /. ( len C31 ) ) = ( C31 . ( len C31 ) ) by L170 , PARTFUN1:def 6;
thus L172: ( len C31 ) = C28 by L167;
thus L173: ( C31 . 1 ) = C27 by L163 , L168;
let C32 being Nat;
assume that
L174: C32 in ( dom C31 );
assume L175: ( C32 + 1 ) in ( dom C31 );
L176: ( C32 + 1 ) <= D18 by L175 , L167 , FINSEQ_3:25;
L177: C32 < D18 by L176 , NAT_1:13;
L178: C32 is (Element of ( NAT )) by ORDINAL1:def 12;
L179: 1 <= C32 by L174 , FINSEQ_3:25;
L180: S2[ C32 , ( C31 . C32 ) , ( C31 . ( C32 + 1 ) ) ] by L179 , L169 , L178 , L177;
thus L181: thesis by L180 , L174 , PARTFUN1:def 6;
end;
uniqueness
proof
let C33 , C34 being (Subset of C26);
thus L182: ((C28 = ( 0 ) & C33 = (the carrier of C26) & C34 = (the carrier of C26)) implies C33 = C34);
assume L183: C28 <> ( 0 );
given C35 being (FinSequence of ( bool (the carrier of C26) )) such that
L184: C33 = ( C35 . ( len C35 ) )
and
L185: ( len C35 ) = C28
and
L186: ( C35 . 1 ) = C27
and
L187: (for B20 being Nat holds ((B20 in ( dom C35 ) & ( B20 + 1 ) in ( dom C35 )) implies ( C35 . ( B20 + 1 ) ) = ( C27 *' ( C35 /. B20 ) )));

given C36 being (FinSequence of ( bool (the carrier of C26) )) such that
L188: C34 = ( C36 . ( len C36 ) )
and
L189: ( len C36 ) = C28
and
L190: ( C36 . 1 ) = C27
and
L191: (for B21 being Nat holds ((B21 in ( dom C36 ) & ( B21 + 1 ) in ( dom C36 )) implies ( C36 . ( B21 + 1 ) ) = ( C27 *' ( C36 /. B21 ) )));

L192: ( dom C35 ) = ( dom C36 ) by L185 , L189 , FINSEQ_3:29;
L193: (for B22 being Nat holds (B22 in ( dom C35 ) implies ( C35 . B22 ) = ( C36 . B22 )))
proof
let C37 being Nat;
defpred S3[ Nat ] means ($1 in ( dom C35 ) implies ( C35 . $1 ) = ( C36 . $1 ));
L194: S3[ ( 0 ) ] by FINSEQ_3:24;
L195: (for B23 being Nat holds (S3[ B23 ] implies S3[ ( B23 + 1 ) ]))
proof
let C38 being Nat;
assume that
L196: S3[ C38 ]
and
L197: ( C38 + 1 ) in ( dom C35 );
per cases ;
suppose L198: C38 in ( dom C35 );

L199: ( C35 /. C38 ) = ( C35 . C38 ) by L198 , PARTFUN1:def 6
.= ( C36 /. C38 ) by L192 , L196 , L198 , PARTFUN1:def 6;
thus L200: ( C35 . ( C38 + 1 ) ) = ( C27 *' ( C35 /. C38 ) ) by L187 , L197 , L198
.= ( C36 . ( C38 + 1 ) ) by L191 , L192 , L197 , L198 , L199;
end;
suppose L201: (not C38 in ( dom C35 ));

L202: C38 = ( 0 ) by L201 , L197 , TOPREALA:2;
thus L203: thesis by L202 , L186 , L190;
end;
end;
L205: (for B24 being Nat holds S3[ B24 ]) from NAT_1:sch 2(L194 , L195);
thus L206: thesis by L205;
end;
thus L207: C33 = C34 by L193 , L184 , L188 , L185 , L189 , L192 , FINSEQ_1:13;
end;
end;
theorem
L209: (for R13 being non  empty doubleLoopStr holds (for R14 being (Subset of R13) holds ( R14 |^ 1 ) = R14))
proof
let R13 being non  empty doubleLoopStr;
let R14 being (Subset of R13);
set D19 = <* R14 *>;
L210: (( len D19 ) = 1 & ( D19 . 1 ) = R14) by FINSEQ_1:40;
L211:
now
let C39 being Nat;
assume that
L212: (C39 in ( dom D19 ) & ( C39 + 1 ) in ( dom D19 ));
L213: ( dom D19 ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
L214: (C39 = 1 & ( C39 + 1 ) = 1) by L213 , L212 , TARSKI:def 1;
thus L215: ( D19 . ( C39 + 1 ) ) = ( R14 *' ( D19 /. C39 ) ) by L214;
end;
thus L216: thesis by L211 , L210 , L159;
end;
theorem
L217: (for R13 being non  empty doubleLoopStr holds (for R14 being (Subset of R13) holds ( R14 |^ 2 ) = ( R14 *' R14 )))
proof
let R13 being non  empty doubleLoopStr;
let R14 being (Subset of R13);
set D20 = <* R14 , ( R14 *' R14 ) *>;
L218: ( len D20 ) = 2 by FINSEQ_1:44;
L219: ( D20 . 1 ) = R14 by FINSEQ_1:44;
L220: ( D20 . 2 ) = ( R14 *' R14 ) by FINSEQ_1:44;
L221:
now
let C40 being Nat;
assume that
L222: C40 in ( dom D20 )
and
L223: ( C40 + 1 ) in ( dom D20 );
L224: ( dom D20 ) = { 1 , 2 } by FINSEQ_1:2 , FINSEQ_1:89;
L225: ((C40 = 1 or C40 = 2) & (( C40 + 1 ) = 1 or ( C40 + 1 ) = 2)) by L224 , L222 , L223 , TARSKI:def 2;
thus L226: ( D20 . ( C40 + 1 ) ) = ( R14 *' ( D20 /. C40 ) ) by L225 , L219 , L220 , L222 , PARTFUN1:def 6;
end;
thus L227: thesis by L221 , L218 , L219 , L220 , L159;
end;
registration
let C41 being Ring;
let C42 being (Ideal of C41);
let C43 being Nat;
cluster ( C42 |^ C43 ) -> non  empty  add-closed  left-ideal  right-ideal;
coherence
proof
per cases  by NAT_1:6;
suppose L228: C43 = ( 0 );

L229: ( C42 |^ ( 0 ) ) = (the carrier of C41) by L159;
thus L230: ( C42 |^ C43 ) is non  empty by L228 , L159;
thus L231: ( C42 |^ C43 ) is  add-closed
proof
let C44 , C45 being (Element of C41);
thus L232: thesis by L229 , L228;
end;

thus L233: ( C42 |^ C43 ) is  left-ideal
proof
let C46 , C47 being (Element of C41);
thus L234: thesis by L229 , L228;
end;

let C48 , C49 being (Element of C41);
thus L235: thesis by L229 , L228;
end;
suppose L236: (ex B25 being Nat st C43 = ( B25 + 1 ));

consider C50 being (FinSequence of ( bool (the carrier of C41) )) such that L237: (( C42 |^ C43 ) = ( C50 . ( len C50 ) ) & ( len C50 ) = C43 & ( C50 . 1 ) = C42) and L238: (for B26 being Nat holds ((B26 in ( dom C50 ) & ( B26 + 1 ) in ( dom C50 )) implies ( C50 . ( B26 + 1 ) ) = ( C42 *' ( C50 /. B26 ) ))) by L236 , L159;
defpred S4[ Nat ] means ($1 in ( dom C50 ) implies ( C50 . $1 ) is (Ideal of C41));
L239: S4[ ( 0 ) ] by FINSEQ_3:24;
L240: (for R8 being Nat holds (S4[ R8 ] implies S4[ ( R8 + 1 ) ]))
proof
let R8 being Nat;
assume that
L241: S4[ R8 ]
and
L242: ( R8 + 1 ) in ( dom C50 );
per cases  by L242 , TOPREALA:2;
suppose L243: R8 = ( 0 );

thus L244: thesis by L243 , L237;
end;
suppose L245: R8 in ( dom C50 );

L246: ( C50 /. R8 ) = ( C50 . R8 ) by L245 , PARTFUN1:def 6;
L247: ( C50 . ( R8 + 1 ) ) = ( C42 *' ( C50 /. R8 ) ) by L238 , L242 , L245;
thus L248: thesis by L247 , L245 , L241 , L246;
end;
end;
L250: (for R8 being Nat holds S4[ R8 ]) from NAT_1:sch 2(L239 , L240);
L251: ( ( 0 ) + 1 ) <= ( len C50 ) by L236 , L237 , NAT_1:13;
L252: ( len C50 ) in ( dom C50 ) by L251 , FINSEQ_3:25;
thus L253: thesis by L252 , L237 , L250;
end;
end;
end;
definition
let C51 being non  empty doubleLoopStr;
let C52 being (Element of C51);
let C53 being Integer;
func C52 |^ C53 -> (Element of C51) equals 
:L256: ( ( power C51 ) . (C52 , ( abs C53 )) ) if ( 0 ) <= C53 otherwise ( ( ( power C51 ) . (C52 , ( abs C53 )) ) " );
correctness;
end;
definition
let C54 being non  empty doubleLoopStr;
let C55 being (Element of C54);
let C56 being Nat;
redefine func C55 |^ C56 equals 
( ( power C54 ) . (C55 , C56) );
compatibility
proof
let C57 being (Element of C54);
L258: ( abs C56 ) = C56 by ABSVALUE:def 1;
thus L259: thesis by L258 , L256;
end;
end;
L261: (for R7 being Nat holds (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds ( R16 |^ ( R7 + 1 ) ) = ( ( R16 |^ R7 ) * R16 ))))
proof
let R7 being Nat;
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
reconsider D21 = R7 as (Element of ( NAT )) by ORDINAL1:def 12;
thus L262: ( R16 |^ ( R7 + 1 ) ) = ( ( ( power R15 ) . (R16 , D21) ) * R16 ) by GROUP_1:def 7
.= ( ( R16 |^ R7 ) * R16 );
end;
theorem
L263: (for R7 being Nat holds (for R8 being Nat holds (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds ( R16 |^ ( R7 + R8 ) ) = ( ( R16 |^ R7 ) * ( R16 |^ R8 ) )))))
proof
let R7 being Nat;
let R8 being Nat;
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
defpred S5[ Nat ] means (for R7 being Nat holds ( R16 |^ ( R7 + $1 ) ) = ( ( R16 |^ R7 ) * ( R16 |^ $1 ) ));
L264: S5[ ( 0 ) ]
proof
let R7 being Nat;
thus L265: ( R16 |^ ( R7 + ( 0 ) ) ) = ( ( R16 |^ R7 ) * ( 1_ R15 ) ) by VECTSP_1:def 4
.= ( ( R16 |^ R7 ) * ( R16 |^ ( 0 ) ) ) by GROUP_1:def 7;
end;
L266: (for R8 being Nat holds (S5[ R8 ] implies S5[ ( R8 + 1 ) ]))
proof
let R8 being Nat;
assume L267: (for R7 being Nat holds ( R16 |^ ( R7 + R8 ) ) = ( ( R16 |^ R7 ) * ( R16 |^ R8 ) ));
let R7 being Nat;
thus L268: ( R16 |^ ( R7 + ( R8 + 1 ) ) ) = ( R16 |^ ( ( R7 + R8 ) + 1 ) )
.= ( ( R16 |^ ( R7 + R8 ) ) * R16 ) by L261
.= ( ( ( R16 |^ R7 ) * ( R16 |^ R8 ) ) * R16 ) by L267
.= ( ( R16 |^ R7 ) * ( ( R16 |^ R8 ) * R16 ) ) by GROUP_1:def 3
.= ( ( R16 |^ R7 ) * ( R16 |^ ( R8 + 1 ) ) ) by L261;
end;
L269: (for R8 being Nat holds S5[ R8 ]) from NAT_1:sch 2(L264 , L266);
thus L270: thesis by L269;
end;
L271: (for R7 being Nat holds (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (R16 <> ( 0. R15 ) implies ( R16 |^ R7 ) <> ( 0. R15 )))))
proof
let R7 being Nat;
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
assume L272: R16 <> ( 0. R15 );
defpred S6[ Nat ] means ( R16 |^ $1 ) <> ( 0. R15 );
L273: ( R16 |^ ( 0 ) ) = ( 1_ R15 ) by GROUP_1:def 7;
L274: S6[ ( 0 ) ] by L273;
L275: (for R7 being Nat holds (S6[ R7 ] implies S6[ ( R7 + 1 ) ]))
proof
let R7 being Nat;
assume L276: S6[ R7 ];
L277: ( R16 |^ ( R7 + 1 ) ) = ( ( R16 |^ R7 ) * R16 ) by L261;
thus L278: ( R16 |^ ( R7 + 1 ) ) <> ( 0. R15 ) by L277 , L276 , L272 , VECTSP_1:12;
end;
L279: (for R7 being Nat holds S6[ R7 ]) from NAT_1:sch 2(L274 , L275);
thus L280: thesis by L279;
end;
theorem
L281: (for R5 being Integer holds (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (R16 <> ( 0. R15 ) implies ( R16 |^ R5 ) <> ( 0. R15 )))))
proof
let R5 being Integer;
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
assume L282: R16 <> ( 0. R15 );
per cases ;
suppose L283: ( 0 ) <= R5;

reconsider D22 = R5 as (Element of ( NAT )) by L283 , INT_1:3;
L284: ( R16 |^ R5 ) = ( R16 |^ D22 );
thus L285: ( R16 |^ R5 ) <> ( 0. R15 ) by L284 , L282 , L271;
end;
suppose L286: R5 < ( 0 );

reconsider D23 = ( - R5 ) as (Element of ( NAT )) by L286 , INT_1:3;
L287: ( R16 |^ R5 ) = ( ( ( power R15 ) . (R16 , ( abs R5 )) ) " ) by L286 , L256
.= ( ( R16 |^ D23 ) " ) by L286 , ABSVALUE:def 1;
L288: ( R16 |^ D23 ) <> ( 0. R15 ) by L282 , L271;
thus L289: ( R16 |^ R5 ) <> ( 0. R15 ) by L288 , L287 , VECTSP_2:13;
end;
end;
begin
definition
let C58 being doubleLoopStr;
attr C58 is  having_valuation
means
:L291: (ex B27 being  e.i.-valued (Function of C58 , ( ExtREAL )) st (( B27 . ( 0. C58 ) ) = ( +infty ) & (for B28 being (Element of C58) holds (B28 <> ( 0. C58 ) implies ( B27 . B28 ) in ( INT ))) & (for B29 , B30 being (Element of C58) holds ( B27 . ( B29 * B30 ) ) = ( ( B27 . B29 ) + ( B27 . B30 ) )) & (for B31 being (Element of C58) holds (( 0 ) <= ( B27 . B31 ) implies ( 0 ) <= ( B27 . ( ( 1. C58 ) + B31 ) ))) & (ex B32 being (Element of C58) st (( B27 . B32 ) <> ( 0 ) & ( B27 . B32 ) <> ( +infty )))));
end;
definition
let C59 being doubleLoopStr;
assume that
L293: C59 is  having_valuation;
mode Valuation of C59
 ->  e.i.-valued (Function of C59 , ( ExtREAL ))
means :L294: (( it . ( 0. C59 ) ) = ( +infty ) & (for B33 being (Element of C59) holds (B33 <> ( 0. C59 ) implies ( it . B33 ) in ( INT ))) & (for B34 , B35 being (Element of C59) holds ( it . ( B34 * B35 ) ) = ( ( it . B34 ) + ( it . B35 ) )) & (for B36 being (Element of C59) holds (( 0 ) <= ( it . B36 ) implies ( 0 ) <= ( it . ( ( 1. C59 ) + B36 ) ))) & (ex B37 being (Element of C59) st (( it . B37 ) <> ( 0 ) & ( it . B37 ) <> ( +infty ))));
existence by L293 , L291;
end;
theorem
L296: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( R19 . ( 1. R15 ) ) = ( 0 ))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L297: R15 is  having_valuation;
L298: ( R19 . ( 1. R15 ) ) = ( R19 . ( ( 1. R15 ) * ( 1. R15 ) ) ) by VECTSP_1:def 8
.= ( ( R19 . ( 1. R15 ) ) + ( R19 . ( 1. R15 ) ) ) by L297 , L294;
L299: ( 1. R15 ) <> ( 0. R15 );
L300: ( R19 . ( 1. R15 ) ) in ( INT ) by L299 , L297 , L294;
reconsider D24 = ( R19 . ( 1. R15 ) ) as (Element of ( REAL )) by L300 , XREAL_0:def 1;
L301: ( D24 + ( 0 ) ) = ( D24 + D24 ) by L298 , XXREAL_3:def 2;
thus L302: thesis by L301;
end;
theorem
L303: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & R16 <> ( 0. R15 )) implies ( R19 . R16 ) <> ( +infty )))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
assume L304: (R15 is  having_valuation & R16 <> ( 0. R15 ));
L305: ( R19 . R16 ) in ( INT ) by L304 , L294;
thus L306: thesis by L305;
end;
theorem
L307: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( R19 . ( - ( 1. R15 ) ) ) = ( 0 ))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L308: R15 is  having_valuation;
L309: ( ( - ( 1. R15 ) ) * ( - ( 1. R15 ) ) ) = ( 1. R15 ) by L157;
L310: ( ( R19 . ( - ( 1. R15 ) ) ) + ( R19 . ( - ( 1. R15 ) ) ) ) = ( R19 . ( 1. R15 ) ) by L309 , L308 , L294
.= ( 0 ) by L308 , L296;
thus L311: thesis by L310 , L8;
end;
theorem
L312: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( R19 . ( - R16 ) ) = ( R19 . R16 )))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
assume L313: R15 is  having_valuation;
L314: ( ( - ( 1. R15 ) ) * R16 ) = ( - R16 ) by VECTSP_2:29;
thus L315: ( R19 . ( - R16 ) ) = ( ( R19 . ( - ( 1. R15 ) ) ) + ( R19 . R16 ) ) by L314 , L313 , L294
.= ( ( 0 ) + ( R19 . R16 ) ) by L313 , L307
.= ( R19 . R16 ) by XXREAL_3:4;
end;
theorem
L316: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & R16 <> ( 0. R15 )) implies ( R19 . ( R16 " ) ) = ( - ( R19 . R16 ) )))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
assume that
L317: R15 is  having_valuation
and
L318: R16 <> ( 0. R15 );
L319: ( R16 * ( R16 " ) ) = ( 1. R15 ) by L318 , VECTSP_2:def 2;
L320: ( ( R19 . R16 ) + ( R19 . ( R16 " ) ) ) = ( R19 . ( 1. R15 ) ) by L319 , L317 , L294
.= ( 0 ) by L317 , L296;
L321:
now
assume L322: ( R16 " ) = ( 0. R15 );
L323: ( 1. R15 ) = ( R16 * ( 0. R15 ) ) by L322 , L318 , VECTSP_2:def 2
.= ( 0. R15 ) by VECTSP_1:6;
thus L324: contradiction by L323;
end;
L325: (( R19 . R16 ) in ( INT ) & ( R19 . ( R16 " ) ) in ( INT )) by L321 , L317 , L318 , L294;
reconsider D25 = ( R19 . R16 ) , D26 = ( R19 . ( R16 " ) ) as (Element of ( REAL )) by L325 , XREAL_0:def 1;
L326: ( D25 + D26 ) = ( 0 ) by L320 , XXREAL_3:def 2;
L327: ( - D25 ) = D26 by L326;
thus L328: thesis by L327 , XXREAL_3:def 3;
end;
theorem
L329: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R17 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & R17 <> ( 0. R15 )) implies ( R19 . ( R16 / R17 ) ) = ( ( R19 . R16 ) - ( R19 . R17 ) ))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R17 being (Element of R15);
let R19 being (Valuation of R15);
assume L330: R15 is  having_valuation;
assume L331: R17 <> ( 0. R15 );
thus L332: ( R19 . ( R16 / R17 ) ) = ( ( R19 . R16 ) + ( R19 . ( R17 " ) ) ) by L330 , L294
.= ( ( R19 . R16 ) - ( R19 . R17 ) ) by L330 , L331 , L316;
end;
theorem
L333: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R17 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & R16 <> ( 0. R15 ) & R17 <> ( 0. R15 )) implies ( R19 . ( R16 / R17 ) ) = ( - ( R19 . ( R17 / R16 ) ) ))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R17 being (Element of R15);
let R19 being (Valuation of R15);
assume L334: R15 is  having_valuation;
assume L335: R16 <> ( 0. R15 );
assume L336: R17 <> ( 0. R15 );
thus L337: ( R19 . ( R16 / R17 ) ) = ( ( R19 . R16 ) - ( R19 . R17 ) ) by L336 , L334 , L329
.= ( - ( ( R19 . R17 ) - ( R19 . R16 ) ) ) by XXREAL_3:26
.= ( - ( R19 . ( R17 / R16 ) ) ) by L334 , L335 , L329;
end;
theorem
L338: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R17 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & R17 <> ( 0. R15 ) & ( 0 ) <= ( R19 . ( R16 / R17 ) )) implies ( R19 . R17 ) <= ( R19 . R16 ))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R17 being (Element of R15);
let R19 being (Valuation of R15);
assume that
L339: R15 is  having_valuation
and
L340: R17 <> ( 0. R15 )
and
L341: ( 0 ) <= ( R19 . ( R16 / R17 ) );
L342: ( R19 . ( R16 / R17 ) ) = ( ( R19 . R16 ) - ( R19 . R17 ) ) by L339 , L340 , L329;
per cases ;
suppose L343: R16 = ( 0. R15 );

L344: ( R19 . R16 ) = ( +infty ) by L343 , L339 , L294;
thus L345: ( R19 . R17 ) <= ( R19 . R16 ) by L344 , XXREAL_0:3;
end;
suppose L346: R16 <> ( 0. R15 );

L347: (( R19 . R16 ) in ( INT ) & ( R19 . R17 ) in ( INT )) by L346 , L339 , L340 , L294;
reconsider D27 = ( R19 . R16 ) , D28 = ( R19 . R17 ) as (Element of ( REAL )) by L347 , XREAL_0:def 1;
L348: ( ( D27 - D28 ) + D28 ) = D27;
L349: ( D27 - D28 ) = ( ( R19 . R16 ) - ( R19 . R17 ) ) by L20;
L350: ( ( R19 . ( R16 / R17 ) ) + ( R19 . R17 ) ) = ( R19 . R16 ) by L349 , L342 , L348 , XXREAL_3:def 2;
L351: ( ( 0 ) + ( R19 . R17 ) ) <= ( ( R19 . ( R16 / R17 ) ) + ( R19 . R17 ) ) by L341 , XXREAL_3:35;
thus L352: ( R19 . R17 ) <= ( R19 . R16 ) by L351 , L350 , XXREAL_3:4;
end;
end;
theorem
L354: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R17 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & R16 <> ( 0. R15 ) & R17 <> ( 0. R15 ) & ( R19 . ( R16 / R17 ) ) <= ( 0 )) implies ( 0 ) <= ( R19 . ( R17 / R16 ) ))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R17 being (Element of R15);
let R19 being (Valuation of R15);
assume L355: (R15 is  having_valuation & R16 <> ( 0. R15 ) & R17 <> ( 0. R15 ));
L356: ( R19 . ( R16 / R17 ) ) = ( - ( R19 . ( R17 / R16 ) ) ) by L355 , L333;
thus L357: thesis by L356;
end;
theorem
L358: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R17 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & R17 <> ( 0. R15 ) & ( R19 . ( R16 / R17 ) ) <= ( 0 )) implies ( R19 . R16 ) <= ( R19 . R17 ))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R17 being (Element of R15);
let R19 being (Valuation of R15);
assume that
L359: R15 is  having_valuation
and
L360: R17 <> ( 0. R15 )
and
L361: ( R19 . ( R16 / R17 ) ) <= ( 0 );
L362:
now
assume L363: R16 = ( 0. R15 );
L364: ( R16 / R17 ) = ( R16 * ( R17 " ) )
.= ( 0. R15 ) by L363 , VECTSP_1:6;
thus L365: contradiction by L364 , L359 , L294 , L361;
end;
L366: ( 0 ) <= ( R19 . ( R17 / R16 ) ) by L362 , L359 , L360 , L361 , L354;
thus L367: ( R19 . R16 ) <= ( R19 . R17 ) by L366 , L359 , L362 , L338;
end;
theorem
L368: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R17 being (Element of R15) holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( min (( R19 . R16 ) , ( R19 . R17 )) ) <= ( R19 . ( R16 + R17 ) ))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R17 being (Element of R15);
let R19 being (Valuation of R15);
assume L369: R15 is  having_valuation;
per cases ;
suppose L370: R16 = ( 0. R15 );

L371: ( R19 . R16 ) = ( +infty ) by L370 , L369 , L294;
L372: ( min (( R19 . R16 ) , ( R19 . R17 )) ) = ( R19 . R17 ) by L371 , XXREAL_0:42;
thus L373: ( min (( R19 . R16 ) , ( R19 . R17 )) ) <= ( R19 . ( R16 + R17 ) ) by L372 , L370 , RLVECT_1:def 4;
end;
suppose L374: R17 = ( 0. R15 );

L375: ( R19 . R17 ) = ( +infty ) by L374 , L369 , L294;
L376: ( min (( R19 . R16 ) , ( R19 . R17 )) ) = ( R19 . R16 ) by L375 , XXREAL_0:42;
thus L377: ( min (( R19 . R16 ) , ( R19 . R17 )) ) <= ( R19 . ( R16 + R17 ) ) by L376 , L374 , RLVECT_1:def 4;
end;
suppose that L378: R16 <> ( 0. R15 )
and
L379: ( 0 ) <= ( R19 . ( R17 / R16 ) );
L380: ( R19 . R16 ) <= ( R19 . R17 ) by L369 , L378 , L379 , L338;
L381: ( min (( R19 . R16 ) , ( R19 . R17 )) ) = ( R19 . R16 ) by L380 , XXREAL_0:def 9;
L382: ( 0 ) <= ( R19 . ( ( 1. R15 ) + ( R17 / R16 ) ) ) by L379 , L369 , L294;
L383: ( ( 0 ) + ( R19 . R16 ) ) <= ( ( R19 . ( ( 1. R15 ) + ( R17 / R16 ) ) ) + ( R19 . R16 ) ) by L382 , XXREAL_3:36;
L384: ( ( R19 . ( ( 1. R15 ) + ( R17 / R16 ) ) ) + ( R19 . R16 ) ) = ( R19 . ( ( ( 1. R15 ) + ( R17 / R16 ) ) * R16 ) ) by L369 , L294
.= ( R19 . ( ( ( 1. R15 ) * R16 ) + ( ( R17 / R16 ) * R16 ) ) ) by VECTSP_1:def 3
.= ( R19 . ( R16 + ( ( R17 / R16 ) * R16 ) ) ) by VECTSP_1:def 8
.= ( R19 . ( R16 + R17 ) ) by L378 , VECTSP_2:22;
thus L385: ( min (( R19 . R16 ) , ( R19 . R17 )) ) <= ( R19 . ( R16 + R17 ) ) by L384 , L381 , L383 , XXREAL_3:4;
end;
suppose that L386: R16 <> ( 0. R15 )
and
L387: R17 <> ( 0. R15 )
and
L388: ( R19 . ( R17 / R16 ) ) <= ( 0 );
L389: ( 0 ) <= ( R19 . ( R16 / R17 ) ) by L369 , L386 , L387 , L388 , L354;
L390: ( R19 . R17 ) <= ( R19 . R16 ) by L369 , L386 , L388 , L358;
L391: ( min (( R19 . R16 ) , ( R19 . R17 )) ) = ( R19 . R17 ) by L390 , XXREAL_0:def 9;
L392: ( 0 ) <= ( R19 . ( ( 1. R15 ) + ( R16 / R17 ) ) ) by L389 , L369 , L294;
L393: ( ( 0 ) + ( R19 . R17 ) ) <= ( ( R19 . ( ( 1. R15 ) + ( R16 / R17 ) ) ) + ( R19 . R17 ) ) by L392 , XXREAL_3:36;
L394: ( ( R19 . ( ( 1. R15 ) + ( R16 / R17 ) ) ) + ( R19 . R17 ) ) = ( R19 . ( ( ( 1. R15 ) + ( R16 / R17 ) ) * R17 ) ) by L369 , L294
.= ( R19 . ( ( ( 1. R15 ) * R17 ) + ( ( R16 / R17 ) * R17 ) ) ) by VECTSP_1:def 3
.= ( R19 . ( R17 + ( ( R16 / R17 ) * R17 ) ) ) by VECTSP_1:def 8
.= ( R19 . ( R17 + R16 ) ) by L387 , VECTSP_2:22;
thus L395: ( min (( R19 . R16 ) , ( R19 . R17 )) ) <= ( R19 . ( R16 + R17 ) ) by L394 , L391 , L393 , XXREAL_3:4;
end;
end;
theorem
L397: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R17 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & ( R19 . R16 ) < ( R19 . R17 )) implies ( R19 . R16 ) = ( R19 . ( R16 + R17 ) ))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R17 being (Element of R15);
let R19 being (Valuation of R15);
assume L398: (R15 is  having_valuation & ( R19 . R16 ) < ( R19 . R17 ));
L399: ( min (( R19 . R16 ) , ( R19 . R17 )) ) = ( R19 . R16 ) by L398 , XXREAL_0:def 9;
L400: ( R19 . R16 ) <= ( R19 . ( R16 + R17 ) ) by L399 , L398 , L368;
L401: R16 = ( R16 + ( 0. R15 ) ) by RLVECT_1:def 4;
L402: ( 0. R15 ) = ( R17 - R17 ) by RLVECT_1:15;
L403: R16 = ( ( R16 + R17 ) - R17 ) by L401 , L402 , RLVECT_1:28
.= ( ( R16 + R17 ) + ( - R17 ) );
L404: ( R19 . ( - R17 ) ) = ( R19 . R17 ) by L398 , L312;
L405: ( min (( R19 . ( R16 + R17 ) ) , ( R19 . R17 )) ) <= ( R19 . R16 ) by L403 , L404 , L398 , L368;
L406: ( min (( R19 . ( R16 + R17 ) ) , ( R19 . R17 )) ) = ( R19 . ( R16 + R17 ) ) by L405 , L398 , XXREAL_0:def 9;
thus L407: thesis by L406 , L400 , L405 , XXREAL_0:1;
end;
theorem
L408: (for R5 being Integer holds (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & R16 <> ( 0. R15 )) implies ( R19 . ( R16 |^ R5 ) ) = ( R5 * ( R19 . R16 ) ))))))
proof
let R5 being Integer;
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
assume that
L409: R15 is  having_valuation
and
L410: R16 <> ( 0. R15 );
defpred S7[ Nat ] means ( R19 . ( R16 |^ $1 ) ) = ( $1 * ( R19 . R16 ) );
L411: ( R16 |^ ( 0 ) ) = ( 1_ R15 ) by GROUP_1:def 7;
L412: S7[ ( 0 ) ] by L411 , L409 , L296;
L413: (for R7 being Nat holds (S7[ R7 ] implies S7[ ( R7 + 1 ) ]))
proof
let R7 being Nat;
assume L414: S7[ R7 ];
L415: ( R19 . R16 ) in ( REAL ) by L409 , L410 , L303 , XXREAL_0:14;
reconsider D29 = R7 as  ext-real number;
thus L416: ( R19 . ( R16 |^ ( R7 + 1 ) ) ) = ( R19 . ( ( R16 |^ R7 ) * R16 ) ) by L261
.= ( ( R7 * ( R19 . R16 ) ) + ( R19 . R16 ) ) by L414 , L409 , L294
.= ( ( R7 * ( R19 . R16 ) ) + ( ( 1. ) * ( R19 . R16 ) ) ) by XXREAL_3:81
.= ( ( R19 . R16 ) * ( D29 + ( 1. ) ) ) by L415 , XXREAL_3:95
.= ( ( R7 + 1 ) * ( R19 . R16 ) ) by XXREAL_3:def 2;
end;
L417: (for R7 being Nat holds S7[ R7 ]) from NAT_1:sch 2(L412 , L413);
per cases ;
suppose L418: R5 >= ( 0 );

reconsider D30 = R5 as (Element of ( NAT )) by L418 , INT_1:3;
L419: S7[ D30 ] by L417;
thus L420: thesis by L419;
end;
suppose L421: R5 < ( 0 );

reconsider D31 = ( - R5 ) as (Element of ( NAT )) by L421 , INT_1:3;
reconsider D32 = R5 as  ext-real number;
L422: ( R19 . ( R16 |^ R5 ) ) = ( R19 . ( ( ( power R15 ) . (R16 , ( abs R5 )) ) " ) ) by L421 , L256
.= ( R19 . ( ( R16 |^ D31 ) " ) ) by L421 , ABSVALUE:def 1;
L423: ( R19 . ( ( R16 |^ D31 ) " ) ) = ( - ( R19 . ( R16 |^ D31 ) ) ) by L409 , L410 , L316 , L271
.= ( - ( D31 * ( R19 . R16 ) ) ) by L417
.= ( - ( ( - D32 ) * ( R19 . R16 ) ) ) by XXREAL_3:def 3
.= ( - ( - ( R5 * ( R19 . R16 ) ) ) ) by XXREAL_3:92;
thus L424: thesis by L423 , L422;
end;
end;
theorem
L426: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & ( 0 ) <= ( R19 . ( ( 1. R15 ) + R16 ) )) implies ( 0 ) <= ( R19 . R16 )))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
assume that
L427: (R15 is  having_valuation & ( 0 ) <= ( R19 . ( ( 1. R15 ) + R16 ) ))
and
L428: ( R19 . R16 ) < ( 0 );
L429: ( 0 ) = ( R19 . ( 1. R15 ) ) by L427 , L296;
thus L430: contradiction by L429 , L427 , L428 , L397;
end;
theorem
L431: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & ( 0 ) <= ( R19 . ( ( 1. R15 ) - R16 ) )) implies ( 0 ) <= ( R19 . R16 )))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
assume that
L432: R15 is  having_valuation
and
L433: ( 0 ) <= ( R19 . ( ( 1. R15 ) - R16 ) );
L434: (( ( 1. R15 ) - R16 ) = ( ( 1. R15 ) + ( - R16 ) ) & ( R19 . ( - R16 ) ) = ( R19 . R16 )) by L432 , L312;
thus L435: thesis by L434 , L432 , L433 , L426;
end;
L436: (for B38 , B39 being ExtInt holds (B38 <= B39 implies ( 0 ) <= ( B39 - B38 )))
proof
let C60 , C61 being ExtInt;
assume L437: C60 <= C61;
L438: ( C60 + ( - C60 ) ) <= ( C61 + ( - C60 ) ) by L437 , XXREAL_3:36;
thus L439: thesis by L438 , XXREAL_3:7;
end;
theorem
L440: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R17 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & R16 <> ( 0. R15 ) & ( R19 . R16 ) <= ( R19 . R17 )) implies ( 0 ) <= ( R19 . ( R17 / R16 ) ))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R17 being (Element of R15);
let R19 being (Valuation of R15);
assume that
L441: R15 is  having_valuation
and
L442: R16 <> ( 0. R15 );
assume L443: ( R19 . R16 ) <= ( R19 . R17 );
L444: ( 0 ) <= ( ( R19 . R17 ) - ( R19 . R16 ) ) by L443 , L436;
thus L445: thesis by L444 , L441 , L442 , L329;
end;
theorem
L446: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( +infty ) in ( rng R19 ))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L447: R15 is  having_valuation;
L448: ( R19 . ( 0. R15 ) ) = ( +infty ) by L447 , L294;
L449: ( dom R19 ) = (the carrier of R15) by FUNCT_2:def 1;
thus L450: thesis by L449 , L448 , FUNCT_1:def 3;
end;
L451: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( least-positive ( rng R19 ) ) in ( rng R19 ))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L452: R15 is  having_valuation;
L453: ( +infty ) in ( rng R19 ) by L452 , L446;
thus L454: thesis by L453 , L116;
end;
theorem
L455: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds (( R19 . R16 ) = 1 implies ( least-positive ( rng R19 ) ) = 1))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
assume L456: ( R19 . R16 ) = 1;
L457: ( dom R19 ) = (the carrier of R15) by FUNCT_2:def 1;
L458: ( R19 . R16 ) in ( rng R19 ) by L457 , FUNCT_1:def 3;
L459:
now
let C62 being  positive ExtInt;
assume L460: C62 in ( rng R19 );
per cases  by XXREAL_3:1;
suppose L461: C62 is  positive  real  positive  real  positive  real  positive  real number;

reconsider D33 = C62 as  positive  real number by L461;
L462: (ex B40 , B41 being Real st (B40 = ( 1. ) & B41 = C62 & B40 <= B41))
proof
reconsider D34 = D33 as Real by XREAL_0:def 1;
take 1;
take D34;
L463: ( ( 0 ) + 1 ) <= D34 by INT_1:7;
thus L464: thesis by L463;
end;
thus L465: ( 1. ) <= C62 by L462;
end;
suppose L466: C62 = ( +infty );

thus L467: ( 1. ) <= C62 by L466 , XXREAL_0:3;
end;
end;
thus L469: thesis by L459 , L456 , L458 , L116;
end;
theorem
L470: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( least-positive ( rng R19 ) ) is  integer)))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
set D35 = ( least-positive ( rng R19 ) );
assume L471: R15 is  having_valuation;
consider R16 being (Element of R15) such that L472: ( R19 . R16 ) <> ( 0 ) and L473: ( R19 . R16 ) <> ( +infty ) by L471 , L294;
L474: ( dom R19 ) = (the carrier of R15) by FUNCT_2:def 1;
L475: ( R19 . R16 ) in ( rng R19 ) by L474 , FUNCT_1:def 3;
assume L476: (not thesis);
L477: D35 = ( +infty ) by L476 , L86;
L478: R16 <> ( 0. R15 ) by L471 , L473 , L294;
L479: ( R19 . R16 ) in ( INT ) by L478 , L471 , L294;
reconsider D36 = ( R19 . R16 ) as Real by L479 , XREAL_0:def 1;
per cases ;
suppose L480: D36 is  positive;

L481: D35 <= ( R19 . R16 ) by L480 , L475 , L116;
thus L482: contradiction by L481 , L473 , L477 , XXREAL_0:4;
end;
suppose L483: (not D36 is  positive);

reconsider D37 = D36 as non  positive  real number by L483;
reconsider D38 = D37 as  negative  real number by L472;
set D39 = ( R16 " );
L484: D39 <> ( 0. R15 ) by L478 , VECTSP_2:13;
L485: ( R19 . D39 ) in ( INT ) by L484 , L471 , L294;
L486: ( R19 . D39 ) in ( rng R19 ) by L474 , FUNCT_1:def 3;
L487: ( R19 . D39 ) = ( - ( R19 . R16 ) ) by L471 , L478 , L316
.= ( - D38 ) by XXREAL_3:def 3;
L488: D35 <= ( R19 . D39 ) by L487 , L486 , L116;
thus L489: contradiction by L488 , L485 , L477 , XXREAL_0:4;
end;
end;
L491: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( least-positive ( rng R19 ) ) in ( REAL ))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L492: R15 is  having_valuation;
L493: ( least-positive ( rng R19 ) ) is  integer by L492 , L470;
L494: ( least-positive ( rng R19 ) ) in ( INT ) by L493 , INT_1:def 2;
thus L495: thesis by L494 , XREAL_0:def 1;
end;
theorem
L496: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (for B42 being (Element of R15) holds (B42 <> ( 0. R15 ) implies (ex B43 being Integer st ( R19 . B42 ) = ( B43 * ( least-positive ( rng R19 ) ) )))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L497: R15 is  having_valuation;
let C63 being (Element of R15);
assume that
L498: C63 <> ( 0. R15 );
reconsider D40 = ( R19 . C63 ) as (Element of ( INT )) by L497 , L498 , L294;
reconsider D41 = ( least-positive ( rng R19 ) ) as Integer by L497 , L470;
L499: ( R19 . C63 ) = ( ( ( D40 div D41 ) * D41 ) + ( D40 mod D41 ) ) by INT_1:59;
per cases ;
suppose L500: ( D40 mod D41 ) = ( 0 );

take ( D40 div D41 );
thus L501: thesis by L499 , L500 , XXREAL_3:def 5;
end;
suppose L502: ( D40 mod D41 ) <> ( 0 );

consider C64 being (Element of R15) such that L503: D41 = ( R19 . C64 ) by L497 , L451 , FUNCT_2:113;
set D42 = ( D40 div D41 );
set D43 = ( C64 |^ D42 );
set D44 = ( D43 " );
L504: C64 <> ( 0. R15 ) by L497 , L503 , L294;
L505: ( D42 * ( R19 . C64 ) ) = ( R19 . D43 ) by L504 , L497 , L408;
L506: ( - ( R19 . D43 ) ) = ( R19 . D44 ) by L497 , L504 , L281 , L316;
L507: ( D42 * D41 ) = ( D42 * ( R19 . C64 ) ) by L503 , XXREAL_3:def 5;
L508: ( R19 . ( C63 * D44 ) ) = ( ( R19 . C63 ) - ( D42 * D41 ) ) by L505 , L506 , L507 , L497 , L294
.= ( D40 - ( D42 * D41 ) ) by L20
.= ( D40 mod D41 ) by L499;
L509: ( 0 ) <= ( R19 . ( C63 * D44 ) ) by L508 , INT_1:57;
L510: ( R19 . ( C63 * D44 ) ) < D41 by L508 , INT_1:58;
L511: ( R19 . ( C63 * D44 ) ) in ( rng R19 ) by FUNCT_2:4;
thus L512: thesis by L511 , L509 , L502 , L508 , L510 , L116;
end;
end;
definition
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L514: R15 is  having_valuation;
func Pgenerator R19 -> (Element of R15) equals 
:L515: the (Element of ( R19 " { ( least-positive ( rng R19 ) ) } ));
coherence
proof
set D45 = ( least-positive ( rng R19 ) );
L516: D45 in ( rng R19 ) by L514 , L451;
L517: { D45 } c= ( rng R19 ) by L516 , ZFMISC_1:31;
L518: ( R19 " { D45 } ) is non  empty by L517 , RELAT_1:139;
L519: the (Element of ( R19 " { D45 } )) in ( R19 " { D45 } ) by L518;
thus L520: thesis by L519;
end;
end;
definition
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L522: R15 is  having_valuation;
func normal-valuation R19 -> (Valuation of R15) means 
:L523: (for R16 being (Element of R15) holds ( R19 . R16 ) = ( ( it . R16 ) * ( least-positive ( rng R19 ) ) ));
existence
proof
set D46 = ( least-positive ( rng R19 ) );
reconsider D47 = D46 as (Element of ( ExtREAL )) by XXREAL_0:def 1;
reconsider D48 = D46 as Integer by L522 , L470;
L524: D48 in ( REAL ) by XREAL_0:def 1;
deffunc H1((Element of R15)) = ( ( R19 . $1 ) / D47 );
consider C65 being (Function of R15 , ( ExtREAL )) such that L525: (for B44 being (Element of R15) holds ( C65 . B44 ) = H1(B44)) from FUNCT_2:sch 4;
L526: (for B45 being set holds (B45 in ( rng C65 ) implies B45 is  ext-integer))
proof
let C66 being set;
assume L527: C66 in ( rng C65 );
consider C67 being set such that L528: C67 in ( dom C65 ) and L529: ( C65 . C67 ) = C66 by L527 , FUNCT_1:def 3;
reconsider D49 = C67 as (Element of R15) by L528;
L530: ( C65 . D49 ) = ( ( R19 . D49 ) / D46 ) by L525;
per cases  by L86;
suppose L531: ( R19 . D49 ) is  integer;

L532: D49 <> ( 0. R15 ) by L531 , L522 , L294;
consider C68 being Integer such that L533: ( R19 . D49 ) = ( C68 * D46 ) by L532 , L522 , L496;
L534: ( ( R19 . D49 ) / D46 ) = C68 by L524 , L533 , XXREAL_3:88;
thus L535: thesis by L534 , L529 , L525;
end;
suppose L536: ( R19 . D49 ) = ( +infty );

thus L537: thesis by L536 , L529 , L530 , L524 , XXREAL_3:83;
end;
end;
reconsider D50 = C65 as  e.i.-valued (Function of R15 , ( ExtREAL )) by L526 , L142;
L539: D50 is (Valuation of R15)
proof
thus L540: R15 is  having_valuation by L522;
thus L541: ( D50 . ( 0. R15 ) ) = ( ( R19 . ( 0. R15 ) ) / D46 ) by L525
.= ( ( +infty ) / D46 ) by L522 , L294
.= ( +infty ) by L524 , XXREAL_3:83;
thus L542: (for R16 being (Element of R15) holds (R16 <> ( 0. R15 ) implies ( D50 . R16 ) in ( INT )))
proof
let R16 being (Element of R15);
assume L543: R16 <> ( 0. R15 );
L544: ( R19 . R16 ) in ( INT ) by L543 , L522 , L294;
reconsider D51 = ( R19 . R16 ) as Integer by L544;
L545: ( D50 . R16 ) = ( ( R19 . R16 ) / D46 ) by L525
.= ( D51 / D48 ) by L24;
thus L546: thesis by L545 , INT_1:def 2;
end;

thus L547: (for R16 being (Element of R15) holds (for R17 being (Element of R15) holds ( D50 . ( R16 * R17 ) ) = ( ( D50 . R16 ) + ( D50 . R17 ) )))
proof
let R16 being (Element of R15);
let R17 being (Element of R15);
thus L548: ( D50 . ( R16 * R17 ) ) = ( ( R19 . ( R16 * R17 ) ) / D46 ) by L525
.= ( ( ( R19 . R16 ) + ( R19 . R17 ) ) / D46 ) by L522 , L294
.= ( ( ( R19 . R16 ) / D46 ) + ( ( R19 . R17 ) / D46 ) ) by L524 , L64
.= ( ( D50 . R16 ) + ( ( R19 . R17 ) / D46 ) ) by L525
.= ( ( D50 . R16 ) + ( D50 . R17 ) ) by L525;
end;

thus L549: (for R16 being (Element of R15) holds (( 0 ) <= ( D50 . R16 ) implies ( 0 ) <= ( D50 . ( ( 1. R15 ) + R16 ) )))
proof
let R16 being (Element of R15);
assume that
L550: ( 0 ) <= ( D50 . R16 );
L551: ( D50 . ( ( 1. R15 ) + R16 ) ) = ( ( R19 . ( ( 1. R15 ) + R16 ) ) / D46 ) by L525;
L552: ( D50 . R16 ) = ( ( R19 . R16 ) / D46 ) by L525;
L553: ( 0 ) <= ( R19 . R16 ) by L552 , L524 , L550 , L40;
L554: ( 0 ) <= ( R19 . ( ( 1. R15 ) + R16 ) ) by L553 , L522 , L294;
thus L555: thesis by L554 , L551;
end;

consider R16 being (Element of R15) such that L556: ( R19 . R16 ) <> ( 0 ) and L557: ( R19 . R16 ) <> ( +infty ) by L522 , L294;
take R16;
L558: ( D50 . R16 ) = ( ( R19 . R16 ) / D46 ) by L525;
thus L559: ( D50 . R16 ) <> ( 0 ) by L558 , L524 , L556 , L79;
reconsider D52 = ( R19 . R16 ) as Integer by L557 , L86;
L560: D52 in ( REAL ) by XREAL_0:def 1;
L561: D46 in ( REAL ) by L522 , L491;
thus L562: ( D50 . R16 ) <> ( +infty ) by L561 , L558 , L560;
end;
reconsider D53 = D50 as (Valuation of R15) by L539;
take D53;
let R16 being (Element of R15);
thus L563: ( R19 . R16 ) = ( ( ( R19 . R16 ) / D46 ) * D46 ) by L524 , L75
.= ( ( D53 . R16 ) * D46 ) by L525;
end;
uniqueness
proof
let C69 , C70 being (Valuation of R15);
assume that
L564: (for R16 being (Element of R15) holds ( R19 . R16 ) = ( ( C69 . R16 ) * ( least-positive ( rng R19 ) ) ))
and
L565: (for R16 being (Element of R15) holds ( R19 . R16 ) = ( ( C70 . R16 ) * ( least-positive ( rng R19 ) ) ));
L566: ( least-positive ( rng R19 ) ) in ( REAL ) by L522 , L491;
let C71 being (Element of R15);
L567: ( ( C69 . C71 ) * ( least-positive ( rng R19 ) ) ) = ( R19 . C71 ) by L564
.= ( ( C70 . C71 ) * ( least-positive ( rng R19 ) ) ) by L565;
thus L568: thesis by L567 , L566 , XXREAL_3:68;
end;
end;
theorem
L570: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (( R19 . R16 ) = ( 0 ) iff ( ( normal-valuation R19 ) . R16 ) = ( 0 ))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
assume L571: R15 is  having_valuation;
L572: ( R19 . R16 ) = ( ( ( normal-valuation R19 ) . R16 ) * ( least-positive ( rng R19 ) ) ) by L571 , L523;
thus L573: thesis by L572;
end;
theorem
L574: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (( R19 . R16 ) = ( +infty ) iff ( ( normal-valuation R19 ) . R16 ) = ( +infty ))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
assume L575: R15 is  having_valuation;
set D54 = ( normal-valuation R19 );
set D55 = ( least-positive ( rng R19 ) );
L576: ( R19 . R16 ) = ( ( D54 . R16 ) * D55 ) by L575 , L523;
L577: D55 is  integer by L575 , L470;
thus L578: (( R19 . R16 ) = ( +infty ) implies ( D54 . R16 ) = ( +infty )) by L577 , L576 , XXREAL_3:69;
thus L579: thesis by L576 , XXREAL_3:def 5;
end;
theorem
L580: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R17 being (Element of R15) holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (( R19 . R16 ) = ( R19 . R17 ) iff ( ( normal-valuation R19 ) . R16 ) = ( ( normal-valuation R19 ) . R17 )))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R17 being (Element of R15);
let R19 being (Valuation of R15);
set D56 = ( normal-valuation R19 );
set D57 = ( least-positive ( rng R19 ) );
assume L581: R15 is  having_valuation;
L582: D57 in ( REAL ) by L581 , L491;
L583: (( R19 . R16 ) = ( ( D56 . R16 ) * D57 ) & ( R19 . R17 ) = ( ( D56 . R17 ) * D57 )) by L581 , L523;
thus L584: thesis by L583 , L582 , XXREAL_3:68;
end;
theorem
L585: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (( R19 . R16 ) is  positive iff ( ( normal-valuation R19 ) . R16 ) is  positive)))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
set D58 = ( normal-valuation R19 );
set D59 = ( least-positive ( rng R19 ) );
assume L586: R15 is  having_valuation;
L587: ( R19 . R16 ) = ( ( D58 . R16 ) * D59 ) by L586 , L523;
reconsider D60 = D59 as Real by L586 , L491;
thus L588:now
assume L589: ( R19 . R16 ) is  positive;
per cases  by L589 , XXREAL_3:1;
suppose L590: ( R19 . R16 ) is  positive  real  positive  real  positive  real  positive  real number;

reconsider D61 = ( R19 . R16 ) as  positive  real number by L590;
L591: D61 in ( REAL ) by XREAL_0:def 1;
L592: ( D58 . R16 ) in ( REAL ) by L591 , L587 , XXREAL_3:73;
consider C72 , C73 being  complex number such that L593: (( D58 . R16 ) = C72 & D60 = C73 & ( ( D58 . R16 ) * D60 ) = ( C72 * C73 )) by L592 , XXREAL_3:def 5;
reconsider D62 = C72 as Real by L591 , L593 , L587 , XXREAL_3:73;
L594: D61 = ( D62 * C73 ) by L586 , L523 , L593;
thus L595: ( D58 . R16 ) is  positive by L594 , L593;
end;
suppose L596: ( R19 . R16 ) = ( +infty );

thus L597: ( D58 . R16 ) is  positive by L596 , L586 , L574;
end;
end;
assume L599: ( D58 . R16 ) is  positive;
per cases  by L599 , XXREAL_3:1;
suppose L600: ( D58 . R16 ) is  positive  real  positive  real  positive  real  positive  real number;

reconsider D63 = ( D58 . R16 ) as  positive  real number by L600;
L601: ( R19 . R16 ) = ( D63 * D60 ) by L587 , XXREAL_3:def 5;
thus L602: ( R19 . R16 ) is  positive by L601;
end;
suppose L603: ( D58 . R16 ) = ( +infty );

thus L604: ( R19 . R16 ) is  positive by L603 , L586 , L574;
end;
end;
theorem
L606: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (( 0 ) <= ( R19 . R16 ) iff ( 0 ) <= ( ( normal-valuation R19 ) . R16 ))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
set D64 = ( normal-valuation R19 );
assume L607: R15 is  having_valuation;
thus L608:now
assume L609: ( 0 ) <= ( R19 . R16 );
L610: (( R19 . R16 ) is  positive or ( 0 ) = ( R19 . R16 )) by L609;
thus L611: ( 0 ) <= ( D64 . R16 ) by L610 , L607 , L585 , L570;
end;
assume L612: ( 0 ) <= ( D64 . R16 );
L613: (( D64 . R16 ) is  positive or ( 0 ) = ( D64 . R16 )) by L612;
thus L614: thesis by L613 , L607 , L585 , L570;
end;
theorem
L615: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (( R19 . R16 ) is non  negative iff ( ( normal-valuation R19 ) . R16 ) is non  negative)))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
set D65 = ( normal-valuation R19 );
set D66 = ( least-positive ( rng R19 ) );
assume L616: R15 is  having_valuation;
L617: ( R19 . R16 ) = ( ( D65 . R16 ) * D66 ) by L616 , L523;
per cases ;
suppose L618: (( R19 . R16 ) is  empty or ( D65 . R16 ) is  empty);

thus L619: thesis by L617;
end;
suppose that L620: ( R19 . R16 ) is non  empty
and
L621: ( D65 . R16 ) is non  empty;
thus L622: (( R19 . R16 ) is non  negative implies ( D65 . R16 ) is non  negative) by L616 , L620 , L585;
thus L623: thesis by L621 , L616 , L585;
end;
end;
theorem
L625: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( ( normal-valuation R19 ) . ( Pgenerator R19 ) ) = 1)))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
set D67 = ( normal-valuation R19 );
set D68 = ( Pgenerator R19 );
set D69 = ( least-positive ( rng R19 ) );
assume L626: R15 is  having_valuation;
L627: ( R19 . D68 ) = ( ( D67 . D68 ) * D69 ) by L626 , L523;
L628: D69 is Real by L626 , L491;
L629: D69 in ( rng R19 ) by L626 , L451;
L630: { D69 } c= ( rng R19 ) by L629 , ZFMISC_1:31;
L631: ( R19 " { D69 } ) is non  empty by L630 , RELAT_1:139;
L632: D68 = the (Element of ( R19 " { D69 } )) by L626 , L515;
L633: ( R19 . D68 ) in { D69 } by L632 , L631 , FUNCT_1:def 7;
L634: ( R19 . D68 ) = D69 by L633 , TARSKI:def 1
.= ( 1 * D69 ) by XXREAL_3:81;
thus L635: ( D67 . D68 ) = 1 by L634 , L627 , L628 , XXREAL_3:68;
end;
theorem
L636: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & ( 0 ) <= ( R19 . R16 )) implies ( ( normal-valuation R19 ) . R16 ) <= ( R19 . R16 )))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
set D70 = ( normal-valuation R19 );
set D71 = ( least-positive ( rng R19 ) );
assume L637: R15 is  having_valuation;
L638: ( R19 . R16 ) = ( ( D70 . R16 ) * D71 ) by L637 , L523;
assume L639: ( 0 ) <= ( R19 . R16 );
L640: ( 0 ) <= ( D70 . R16 ) by L639 , L637 , L606;
L641: ( (( 0. ) qua ExtInt) + 1 ) <= D71 by L99;
L642: ( ( D70 . R16 ) * 1 ) <= ( ( D70 . R16 ) * D71 ) by L641 , L640 , L12;
thus L643: thesis by L642 , L638 , XXREAL_3:81;
end;
theorem
L644: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & ( R19 . R16 ) = 1) implies ( normal-valuation R19 ) = R19))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
set D72 = ( normal-valuation R19 );
assume that
L645: R15 is  having_valuation
and
L646: ( R19 . R16 ) = 1;
let C74 being (Element of R15);
thus L647: ( R19 . C74 ) = ( ( D72 . C74 ) * ( least-positive ( rng R19 ) ) ) by L645 , L523
.= ( ( D72 . C74 ) * 1 ) by L646 , L455
.= ( D72 . C74 ) by XXREAL_3:81;
end;
theorem
L648: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( normal-valuation ( normal-valuation R19 ) ) = ( normal-valuation R19 ))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L649: R15 is  having_valuation;
set D73 = ( normal-valuation R19 );
set D74 = ( normal-valuation D73 );
let C75 being (Element of R15);
set D75 = ( least-positive ( rng D73 ) );
L650: ( D73 . C75 ) = ( ( D74 . C75 ) * D75 ) by L649 , L523;
L651: ( D73 . ( Pgenerator R19 ) ) = 1 by L649 , L625;
L652: D75 = 1 by L651 , L455;
thus L653: thesis by L652 , L650 , XXREAL_3:81;
end;
begin
definition
let C76 being non  empty doubleLoopStr;
let C77 being (Valuation of C76);
func NonNegElements C77 equals 
{ B46 where B46 is (Element of C76) : ( 0 ) <= ( C77 . B46 ) };
coherence;
end;
theorem
L655: (for B47 being non  empty doubleLoopStr holds (for B48 being (Valuation of B47) holds (for B49 being (Element of B47) holds (B49 in ( NonNegElements B48 ) iff ( 0 ) <= ( B48 . B49 )))))
proof
let C78 being non  empty doubleLoopStr;
let C79 being (Valuation of C78);
let C80 being (Element of C78);
thus L656:now
assume L657: C80 in ( NonNegElements C79 );
L658: (ex B50 being (Element of C78) st (C80 = B50 & ( 0 ) <= ( C79 . B50 ))) by L657;
thus L659: ( 0 ) <= ( C79 . C80 ) by L658;
end;
thus L660: thesis;
end;
theorem
L661: (for B51 being non  empty doubleLoopStr holds (for B52 being (Valuation of B51) holds ( NonNegElements B52 ) c= (the carrier of B51)))
proof
let C81 being non  empty doubleLoopStr;
let C82 being (Valuation of C81);
let C83 being set;
assume L662: C83 in ( NonNegElements C82 );
L663: (ex B53 being (Element of C81) st (C83 = B53 & ( 0 ) <= ( C82 . B53 ))) by L662;
thus L664: thesis by L663;
end;
theorem
L665: (for B54 being non  empty doubleLoopStr holds (for B55 being (Valuation of B54) holds (B54 is  having_valuation implies ( 0. B54 ) in ( NonNegElements B55 ))))
proof
let C84 being non  empty doubleLoopStr;
let C85 being (Valuation of C84);
assume L666: C84 is  having_valuation;
L667: ( C85 . ( 0. C84 ) ) = ( +infty ) by L666 , L294;
thus L668: thesis by L667;
end;
theorem
L669: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( 1. R15 ) in ( NonNegElements R19 ))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L670: R15 is  having_valuation;
L671: ( R19 . ( 1. R15 ) ) = ( 0 ) by L670 , L296;
thus L672: thesis by L671;
end;
definition
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume that
L673: R15 is  having_valuation;
func ValuatRing R19 ->  strict  commutative non  degenerated Ring means 
:L674: ((the carrier of it) = ( NonNegElements R19 ) & (the addF of it) = ( (the addF of R15) | [: ( NonNegElements R19 ) , ( NonNegElements R19 ) :] ) & (the multF of it) = ( (the multF of R15) | [: ( NonNegElements R19 ) , ( NonNegElements R19 ) :] ) & (the ZeroF of it) = ( 0. R15 ) & (the OneF of it) = ( 1. R15 ));
existence
proof
set D76 = ( NonNegElements R19 );
set D77 = ( (the addF of R15) | [: D76 , D76 :] );
set D78 = ( (the multF of R15) | [: D76 , D76 :] );
set D79 = ( 1. R15 );
set D80 = ( 0. R15 );
L675: D76 c= (the carrier of R15) by L661;
L676:
now
let C86 being set;
assume that
L677: C86 in [: D76 , D76 :];
set D81 = ( (the addF of R15) . C86 );
consider C87 , C88 being set such that L678: C87 in D76 and L679: C88 in D76 and L680: C86 = [ C87 , C88 ] by L677 , ZFMISC_1:def 2;
consider C89 being (Element of R15) such that L681: C89 = C87 and L682: ( 0 ) <= ( R19 . C89 ) by L678;
consider C90 being (Element of R15) such that L683: C90 = C88 and L684: ( 0 ) <= ( R19 . C90 ) by L679;
L685: ( min (( R19 . C89 ) , ( R19 . C90 )) ) <= ( R19 . ( C89 + C90 ) ) by L673 , L368;
L686: ( 0 ) <= ( min (( R19 . C89 ) , ( R19 . C90 )) ) by L682 , L684 , XXREAL_0:20;
thus L687: D81 in D76 by L686 , L680 , L681 , L685 , L683;
end;
reconsider D82 = D76 as (Preserv of (the addF of R15)) by L676 , L675 , REALSET1:def 1;
L688: ( (the addF of R15) || D82 ) is (BinOp of D76);
reconsider D83 = D77 as (BinOp of D76) by L688;
L689:
now
let C91 being set;
assume that
L690: C91 in [: D76 , D76 :];
set D84 = ( (the multF of R15) . C91 );
consider C92 , C93 being set such that L691: C92 in D76 and L692: C93 in D76 and L693: C91 = [ C92 , C93 ] by L690 , ZFMISC_1:def 2;
consider C94 being (Element of R15) such that L694: C94 = C92 and L695: ( 0 ) <= ( R19 . C94 ) by L691;
consider C95 being (Element of R15) such that L696: C95 = C93 and L697: ( 0 ) <= ( R19 . C95 ) by L692;
L698: ( ( 0 ) + ( 0 ) ) <= ( ( R19 . C94 ) + ( R19 . C95 ) ) by L695 , L697;
L699: ( 0 ) <= ( R19 . ( C94 * C95 ) ) by L698 , L673 , L294;
thus L700: D84 in D76 by L699 , L693 , L694 , L696;
end;
reconsider D85 = D76 as (Preserv of (the multF of R15)) by L689 , L675 , REALSET1:def 1;
L701: ( (the multF of R15) || D85 ) is (BinOp of D76);
reconsider D86 = D78 as (BinOp of D76) by L701;
L702: ( R19 . D80 ) = ( +infty ) by L673 , L294;
reconsider D87 = D79 , D88 = D80 as (Element of D76) by L673 , L665 , L669;
set D89 = doubleLoopStr (# D76 , D83 , D86 , D87 , D88 #);
L703: D88 in D76 by L702;
reconsider D90 = D89 as non  empty doubleLoopStr by L703;
L704:
now
let C96 , C97 being (Element of D90);
let C98 , C99 being (Element of R15);
assume that
L705: (C96 = C98 & C97 = C99);
L706: [ C96 , C97 ] in [: D76 , D76 :];
thus L707: ( C96 + C97 ) = ( C98 + C99 ) by L706 , L705 , FUNCT_1:49;
end;
L708:
now
let C100 , C101 being (Element of D90);
let C102 , C103 being (Element of R15);
assume that
L709: (C100 = C102 & C101 = C103);
L710: [ C100 , C101 ] in [: D76 , D76 :];
thus L711: ( C100 * C101 ) = ( C102 * C103 ) by L710 , L709 , FUNCT_1:49;
end;
L712:
now
let C104 , C105 being (Element of D90);
assume L713: C105 = D87;
L714: (C104 in D76 & C105 in D76);
reconsider D91 = C104 , D92 = C105 as (Element of R15) by L714 , L675;
thus L715: ( C104 * C105 ) = ( D91 * D92 ) by L708
.= C104 by L713 , VECTSP_1:def 4;
thus L716: ( C105 * C104 ) = ( D92 * D91 ) by L708
.= C104 by L713 , VECTSP_1:def 4;
end;
L717: D90 is  well-unital
proof
let C106 being (Element of D90);
thus L718: (( C106 * ( 1. D90 ) ) = C106 & ( ( 1. D90 ) * C106 ) = C106) by L712;
end;
reconsider D93 = D90 as  well-unital non  empty doubleLoopStr by L717;
L719: D93 is  Abelian  add-associative  right_zeroed  right_complementable  commutative  associative  distributive non  degenerated
proof
thus L720:now
let C107 , C108 being (Element of D93);
L721: (C107 in D76 & C108 in D76);
reconsider D94 = C107 , D95 = C108 as (Element of R15) by L721 , L675;
thus L722: ( C107 + C108 ) = ( D94 + D95 ) by L704
.= ( C108 + C107 ) by L704;
end;
thus L723:now
let C109 , C110 , C111 being (Element of D93);
L724: (C109 in D76 & C110 in D76 & C111 in D76);
reconsider D96 = C109 , D97 = C110 , D98 = C111 as (Element of R15) by L724 , L675;
L725: ( C110 + C111 ) = ( D97 + D98 ) by L704;
L726: ( C109 + C110 ) = ( D96 + D97 ) by L704;
thus L727: ( ( C109 + C110 ) + C111 ) = ( ( D96 + D97 ) + D98 ) by L726 , L704
.= ( D96 + ( D97 + D98 ) ) by RLVECT_1:def 3
.= ( C109 + ( C110 + C111 ) ) by L725 , L704;
end;
thus L728:now
let C112 being (Element of D93);
L729: C112 in D76;
reconsider D99 = C112 as (Element of R15) by L729 , L675;
thus L730: ( C112 + ( 0. D93 ) ) = ( D99 + ( 0. R15 ) ) by L704
.= C112 by RLVECT_1:def 4;
end;
thus L731: D93 is  right_complementable
proof
let C113 being (Element of D93);
L732: C113 in D76;
reconsider D100 = C113 as (Element of R15) by L732 , L675;
consider C114 being (Element of R15) such that L733: ( D100 + C114 ) = ( 0. R15 ) by ALGSTR_0:def 11;
L734: ( R19 . ( D100 + C114 ) ) = ( +infty ) by L673 , L733 , L294;
per cases ;
suppose L735: ( R19 . C114 ) < ( R19 . D100 );

L736: ( R19 . C114 ) = ( R19 . ( C114 + D100 ) ) by L735 , L673 , L397;
reconsider D101 = C114 as (Element of D93) by L736 , L734 , L655;
take D101;
thus L737: ( C113 + D101 ) = ( 0. D93 ) by L733 , L704;
end;
suppose L738: ( R19 . D100 ) <= ( R19 . C114 );

L739: ( 0 ) <= ( R19 . D100 ) by L655;
reconsider D102 = C114 as (Element of D93) by L739 , L738 , L655;
take D102;
thus L740: ( C113 + D102 ) = ( 0. D93 ) by L733 , L704;
end;
end;

thus L742:now
let C115 , C116 being (Element of D93);
L743: (C115 in D76 & C116 in D76);
reconsider D103 = C115 , D104 = C116 as (Element of R15) by L743 , L675;
thus L744: ( C115 * C116 ) = ( D103 * D104 ) by L708
.= ( C116 * C115 ) by L708;
end;
thus L745:now
let C117 , C118 , C119 being (Element of D93);
L746: (C117 in D76 & C118 in D76 & C119 in D76);
reconsider D105 = C117 , D106 = C118 , D107 = C119 as (Element of R15) by L746 , L675;
L747: ( C118 * C119 ) = ( D106 * D107 ) by L708;
L748: ( C117 * C118 ) = ( D105 * D106 ) by L708;
thus L749: ( ( C117 * C118 ) * C119 ) = ( ( D105 * D106 ) * D107 ) by L748 , L708
.= ( D105 * ( D106 * D107 ) ) by GROUP_1:def 3
.= ( C117 * ( C118 * C119 ) ) by L747 , L708;
end;
thus L750:now
let C120 , C121 , C122 being (Element of D93);
L751: (C120 in D76 & C121 in D76 & C122 in D76);
reconsider D108 = C120 , D109 = C121 , D110 = C122 as (Element of R15) by L751 , L675;
L752: ( C121 + C122 ) = ( D109 + D110 ) by L704;
L753: ( C120 * C121 ) = ( D108 * D109 ) by L708;
L754: ( C120 * C122 ) = ( D108 * D110 ) by L708;
L755: ( C121 * C120 ) = ( D109 * D108 ) by L708;
L756: ( C122 * C120 ) = ( D110 * D108 ) by L708;
thus L757: ( C120 * ( C121 + C122 ) ) = ( D108 * ( D109 + D110 ) ) by L752 , L708
.= ( ( D108 * D109 ) + ( D108 * D110 ) ) by VECTSP_1:def 2
.= ( ( C120 * C121 ) + ( C120 * C122 ) ) by L704 , L753 , L754;
thus L758: ( ( C121 + C122 ) * C120 ) = ( ( D109 + D110 ) * D108 ) by L752 , L708
.= ( ( D109 * D108 ) + ( D110 * D108 ) ) by VECTSP_1:def 2
.= ( ( C121 * C120 ) + ( C122 * C120 ) ) by L704 , L755 , L756;
end;
thus L759: ( 0. D93 ) <> ( 1. D93 );
end;
thus L760: thesis by L719;
end;
uniqueness;
end;
theorem
L762: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (for B56 being (Element of ( ValuatRing R19 )) holds B56 is (Element of R15)))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L763: R15 is  having_valuation;
let C123 being (Element of ( ValuatRing R19 ));
L764: (the carrier of ( ValuatRing R19 )) = ( NonNegElements R19 ) by L763 , L674;
L765: (C123 in ( NonNegElements R19 ) & ( NonNegElements R19 ) c= (the carrier of R15)) by L764 , L661;
thus L766: thesis by L765;
end;
theorem
L767: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (( 0 ) <= ( R19 . R16 ) iff R16 is (Element of ( ValuatRing R19 )))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
assume L768: R15 is  having_valuation;
L769: (the carrier of ( ValuatRing R19 )) = ( NonNegElements R19 ) by L768 , L674;
thus L770: thesis by L769 , L655;
end;
theorem
L771: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (for B57 being (Subset of ( ValuatRing R19 )) holds ( 0 ) is (LowerBound of ( R19 .: B57 ))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L772: R15 is  having_valuation;
let C124 being (Subset of ( ValuatRing R19 ));
let C125 being  ext-real number;
assume L773: C125 in ( R19 .: C124 );
L774: (ex B58 being (Element of R15) st (B58 in C124 & C125 = ( R19 . B58 ))) by L773 , FUNCT_2:65;
L775: (the carrier of ( ValuatRing R19 )) = ( NonNegElements R19 ) by L772 , L674;
thus L776: thesis by L775 , L774 , L655;
end;
theorem
L777: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (for B59 , B60 being (Element of R15) holds (for B61 , B62 being (Element of ( ValuatRing R19 )) holds ((B59 = B61 & B60 = B62) implies ( B59 + B60 ) = ( B61 + B62 )))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
set D111 = ( ValuatRing R19 );
set D112 = ( NonNegElements R19 );
assume L778: R15 is  having_valuation;
let C126 , C127 being (Element of R15);
let C128 , C129 being (Element of D111);
assume that
L779: (C126 = C128 & C127 = C129);
L780: D112 = (the carrier of D111) by L778 , L674;
L781: (the addF of D111) = ( (the addF of R15) | [: D112 , D112 :] ) by L778 , L674;
thus L782: ( C128 + C129 ) = ( (the addF of D111) . [ C128 , C129 ] )
.= ( C126 + C127 ) by L780 , L781 , L779 , FUNCT_1:49;
end;
theorem
L783: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (for B63 , B64 being (Element of R15) holds (for B65 , B66 being (Element of ( ValuatRing R19 )) holds ((B63 = B65 & B64 = B66) implies ( B63 * B64 ) = ( B65 * B66 )))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
set D113 = ( ValuatRing R19 );
set D114 = ( NonNegElements R19 );
assume L784: R15 is  having_valuation;
let C130 , C131 being (Element of R15);
let C132 , C133 being (Element of D113);
assume that
L785: (C130 = C132 & C131 = C133);
L786: D114 = (the carrier of D113) by L784 , L674;
L787: (the multF of D113) = ( (the multF of R15) | [: D114 , D114 :] ) by L784 , L674;
thus L788: ( C132 * C133 ) = ( (the multF of D113) . [ C132 , C133 ] )
.= ( C130 * C131 ) by L786 , L787 , L785 , FUNCT_1:49;
end;
theorem
L789: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( 0. ( ValuatRing R19 ) ) = ( 0. R15 )))) by L674;
theorem
L790: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( 1. ( ValuatRing R19 ) ) = ( 1. R15 )))) by L674;
theorem
L791: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (for B67 being (Element of R15) holds (for B68 being (Element of ( ValuatRing R19 )) holds (B67 = B68 implies ( - B67 ) = ( - B68 )))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
set D115 = ( ValuatRing R19 );
set D116 = ( NonNegElements R19 );
assume L792: R15 is  having_valuation;
let C134 being (Element of R15);
let C135 being (Element of D115);
assume that
L793: C134 = C135;
L794: ( 0 ) <= ( R19 . C135 ) by L792 , L793 , L767;
L795: ( R19 . ( - C134 ) ) = ( R19 . C134 ) by L792 , L312;
reconsider D117 = ( - C134 ) as (Element of D115) by L795 , L792 , L793 , L794 , L767;
L796: ( C134 + ( - C134 ) ) = ( 0. R15 ) by RLVECT_1:def 10;
L797: ( C135 + D117 ) = ( 0. R15 ) by L796 , L793 , L792 , L777
.= ( 0. ( ValuatRing R19 ) ) by L792 , L674;
thus L798: thesis by L797 , RLVECT_1:def 10;
end;
L799: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R17 being (Element of R15) holds (R16 <> ( 0. R15 ) implies ( ( R16 " ) * ( R16 * R17 ) ) = R17))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R17 being (Element of R15);
assume L800: R16 <> ( 0. R15 );
thus L801: ( ( R16 " ) * ( R16 * R17 ) ) = ( ( ( R16 " ) * R16 ) * R17 ) by GROUP_1:def 3
.= ( ( 1. R15 ) * R17 ) by L800 , VECTSP_2:def 2
.= R17 by VECTSP_1:def 8;
end;
L802: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for B69 , B70 being (Element of R15) holds (B69 <> ( 0. R15 ) implies ( B69 * ( ( B69 " ) * B70 ) ) = B70)))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let C136 , C137 being (Element of R15);
assume that
L803: C136 <> ( 0. R15 );
thus L804: ( C136 * ( ( C136 " ) * C137 ) ) = ( ( C136 * ( C136 " ) ) * C137 ) by GROUP_1:def 3
.= ( ( 1. R15 ) * C137 ) by L803 , VECTSP_2:def 2
.= C137 by VECTSP_1:def 8;
end;
theorem
L805: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( ValuatRing R19 ) is  domRing-like)))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
set D118 = ( ValuatRing R19 );
assume L806: R15 is  having_valuation;
let C138 , C139 being (Element of D118);
assume that
L807: ( C138 * C139 ) = ( 0. D118 )
and
L808: C138 <> ( 0. D118 );
reconsider D119 = C138 , D120 = C139 as (Element of R15) by L806 , L762;
L809: ( 0. D118 ) = ( 0. R15 ) by L806 , L674;
L810: ( D119 * D120 ) = ( C138 * C139 ) by L806 , L783;
L811: D120 = ( ( D119 " ) * ( D119 * D120 ) ) by L808 , L809 , L799
.= ( 0. R15 ) by L807 , L809 , L810 , VECTSP_1:6;
thus L812: thesis by L811 , L806 , L674;
end;
theorem
L813: (for R7 being Nat holds (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (for B71 being (Element of ( ValuatRing R19 )) holds ( ( power R15 ) . (B71 , R7) ) = ( ( power ( ValuatRing R19 ) ) . (B71 , R7) ))))))
proof
let R7 being Nat;
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
set D121 = ( ValuatRing R19 );
assume L814: R15 is  having_valuation;
let C140 being (Element of D121);
defpred S8[ Nat ] means ( ( power R15 ) . (C140 , $1) ) = ( ( power ( ValuatRing R19 ) ) . (C140 , $1) );
reconsider D122 = C140 as (Element of R15) by L814 , L762;
L815: (( ( power R15 ) . (D122 , ( 0 )) ) = ( 1_ R15 ) & ( ( power D121 ) . (C140 , ( 0 )) ) = ( 1_ D121 )) by GROUP_1:def 7;
L816: S8[ ( 0 ) ] by L815 , L814 , L674;
L817: (for B72 being Nat holds (S8[ B72 ] implies S8[ ( B72 + 1 ) ]))
proof
let C141 being Nat;
assume L818: S8[ C141 ];
reconsider D123 = C141 as (Element of ( NAT )) by ORDINAL1:def 12;
L819: (( ( power R15 ) . (C140 , ( C141 + 1 )) ) = ( ( ( power R15 ) . (D122 , D123) ) * D122 ) & ( ( power ( ValuatRing R19 ) ) . (C140 , ( C141 + 1 )) ) = ( ( ( power ( ValuatRing R19 ) ) . (C140 , D123) ) * C140 )) by GROUP_1:def 7;
thus L820: S8[ ( C141 + 1 ) ] by L819 , L814 , L818 , L783;
end;
L821: (for B73 being Nat holds S8[ B73 ]) from NAT_1:sch 2(L816 , L817);
thus L822: thesis by L821;
end;
L823:
now
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L824: R15 is  having_valuation;
L825: ( R19 . ( 0. R15 ) ) = ( +infty ) by L824 , L294;
thus L826: ( 0. R15 ) in { B74 where B74 is (Element of R15) : ( 0 ) < ( R19 . B74 ) } by L825;
end;
definition
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L827: R15 is  having_valuation;
func PosElements R19 -> (Ideal of ( ValuatRing R19 )) equals 
:L828: { B75 where B75 is (Element of R15) : ( 0 ) < ( R19 . B75 ) };
coherence
proof
set D124 = ( ValuatRing R19 );
set D125 = { B76 where B76 is (Element of R15) : ( 0 ) < ( R19 . B76 ) };
L829: (the carrier of D124) = ( NonNegElements R19 ) by L827 , L674;
L830: D125 c= (the carrier of D124)
proof
let C142 being set;
assume L831: C142 in D125;
L832: (ex B77 being (Element of R15) st (C142 = B77 & ( 0 ) < ( R19 . B77 ))) by L831;
thus L833: thesis by L832 , L829;
end;
reconsider D126 = D125 as non  empty (Subset of D124) by L830 , L827 , L823;
L834: (the carrier of D124) c= (the carrier of R15) by L829 , L661;
L835: D126 is  add-closed  left-ideal  right-ideal
proof
thus L836:now
let C143 , C144 being (Element of D124);
assume L837: C143 in D126;
consider C145 being (Element of R15) such that L838: C145 = C143 and L839: ( 0 ) < ( R19 . C145 ) by L837;
assume L840: C144 in D126;
consider C146 being (Element of R15) such that L841: C146 = C144 and L842: ( 0 ) < ( R19 . C146 ) by L840;
L843: ( C143 + C144 ) = ( C145 + C146 ) by L827 , L838 , L841 , L777;
L844: ( min (( R19 . C145 ) , ( R19 . C146 )) ) <= ( R19 . ( C145 + C146 ) ) by L827 , L368;
L845: ( 0 ) < ( min (( R19 . C145 ) , ( R19 . C146 )) ) by L839 , L842 , XXREAL_0:21;
thus L846: ( C143 + C144 ) in D126 by L845 , L843 , L844;
end;
thus L847:now
let C147 , C148 being (Element of D124);
assume L848: C148 in D126;
consider C149 being (Element of R15) such that L849: C149 = C148 and L850: ( 0 ) < ( R19 . C149 ) by L848;
L851: C147 in (the carrier of D124);
reconsider D127 = C147 as (Element of R15) by L851 , L834;
L852: ( C147 * C148 ) = ( D127 * C149 ) by L827 , L849 , L783;
L853: ( R19 . ( D127 * C149 ) ) = ( ( R19 . D127 ) + ( R19 . C149 ) ) by L827 , L294;
L854: ( 0 ) <= ( R19 . D127 ) by L829 , L655;
thus L855: ( C147 * C148 ) in D126 by L854 , L850 , L852 , L853;
end;
let C150 , C151 being (Element of D124);
assume L856: C151 in D126;
consider C152 being (Element of R15) such that L857: C152 = C151 and L858: ( 0 ) < ( R19 . C152 ) by L856;
L859: C150 in (the carrier of D124);
reconsider D128 = C150 as (Element of R15) by L859 , L834;
L860: ( C150 * C151 ) = ( D128 * C152 ) by L827 , L857 , L783;
L861: ( R19 . ( D128 * C152 ) ) = ( ( R19 . D128 ) + ( R19 . C152 ) ) by L827 , L294;
L862: ( 0 ) <= ( R19 . D128 ) by L829 , L655;
thus L863: ( C151 * C150 ) in D126 by L862 , L858 , L860 , L861;
end;
thus L864: thesis by L835;
end;
end;
notation
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
synonym vp R19 for PosElements R19;
end;
theorem
L867: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (R16 in ( vp R19 ) iff ( 0 ) < ( R19 . R16 ))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
assume L868: R15 is  having_valuation;
L869: ( vp R19 ) = { B78 where B78 is (Element of R15) : ( 0 ) < ( R19 . B78 ) } by L868 , L828;
thus L870:now
assume L871: R16 in ( vp R19 );
L872: (ex B79 being (Element of R15) st (B79 = R16 & ( 0 ) < ( R19 . B79 ))) by L871 , L869;
thus L873: ( 0 ) < ( R19 . R16 ) by L872;
end;
thus L874: thesis by L869;
end;
theorem
L875: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( 0. R15 ) in ( vp R19 ))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L876: R15 is  having_valuation;
L877: ( vp R19 ) = { B80 where B80 is (Element of R15) : ( 0 ) < ( R19 . B80 ) } by L876 , L828;
thus L878: thesis by L877 , L876 , L823;
end;
theorem
L879: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (not ( 1. R15 ) in ( vp R19 )))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L880: R15 is  having_valuation;
L881: ( vp R19 ) = { B81 where B81 is (Element of R15) : ( 0 ) < ( R19 . B81 ) } by L880 , L828;
assume L882: ( 1. R15 ) in ( vp R19 );
L883: (ex B82 being (Element of R15) st (B82 = ( 1. R15 ) & ( 0 ) < ( R19 . B82 ))) by L882 , L881;
thus L884: thesis by L883 , L880 , L296;
end;
definition
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
let C153 being non  empty (Subset of R15);
assume that
L885: R15 is  having_valuation
and
L886: C153 is (Subset of ( ValuatRing R19 ));
func min (C153 , R19) -> (Subset of ( ValuatRing R19 )) equals 
:L887: ( ( R19 " { ( inf ( R19 .: C153 ) ) } ) /\ C153 );
coherence
proof
L888: ( ( R19 " { ( inf ( R19 .: C153 ) ) } ) /\ C153 ) c= ( NonNegElements R19 )
proof
let C154 being set;
assume L889: C154 in ( ( R19 " { ( inf ( R19 .: C153 ) ) } ) /\ C153 );
L890: C154 in ( R19 " { ( inf ( R19 .: C153 ) ) } ) by L889 , XBOOLE_0:def 4;
reconsider D129 = C154 as (Element of R15) by L889;
reconsider D130 = ( R19 .: C153 ) as non  empty (Subset of ( ExtREAL ));
L891: ( R19 . D129 ) in { ( inf ( R19 .: C153 ) ) } by L890 , FUNCT_2:38;
L892: ( R19 . D129 ) = ( inf D130 ) by L891 , TARSKI:def 1;
L893: ( 0 ) is (LowerBound of D130) by L885 , L886 , L771;
L894: ( 0 ) <= ( inf D130 ) by L893 , XXREAL_2:def 4;
thus L895: thesis by L894 , L892;
end;
thus L896: thesis by L888 , L885 , L674;
end;
end;
theorem
L898: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (for B83 being non  empty (Subset of R15) holds ((R15 is  having_valuation & B83 is (Subset of ( ValuatRing R19 ))) implies ( min (B83 , R19) ) c= B83))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
let C155 being non  empty (Subset of R15);
assume L899: (R15 is  having_valuation & C155 is (Subset of ( ValuatRing R19 )));
L900: ( min (C155 , R19) ) = ( ( R19 " { ( inf ( R19 .: C155 ) ) } ) /\ C155 ) by L899 , L887;
thus L901: ( min (C155 , R19) ) c= C155 by L900 , XBOOLE_1:17;
end;
theorem
L902: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (for B84 being non  empty (Subset of R15) holds ((R15 is  having_valuation & B84 is (Subset of ( ValuatRing R19 ))) implies (for B85 being (Element of R15) holds (B85 in ( min (B84 , R19) ) iff (B85 in B84 & (for B86 being (Element of R15) holds (B86 in B84 implies ( R19 . B85 ) <= ( R19 . B86 ))))))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
let C156 being non  empty (Subset of R15);
assume L903: R15 is  having_valuation;
assume L904: C156 is (Subset of ( ValuatRing R19 ));
L905: ( min (C156 , R19) ) = ( ( R19 " { ( inf ( R19 .: C156 ) ) } ) /\ C156 ) by L903 , L904 , L887;
L906: ( inf ( R19 .: C156 ) ) is (LowerBound of ( R19 .: C156 )) by XXREAL_2:def 4;
let C157 being (Element of R15);
thus L907:now
assume L908: C157 in ( min (C156 , R19) );
L909: C157 in ( R19 " { ( inf ( R19 .: C156 ) ) } ) by L908 , L905 , XBOOLE_0:def 4;
L910: ( R19 . C157 ) in { ( inf ( R19 .: C156 ) ) } by L909 , FUNCT_2:38;
L911: ( R19 . C157 ) = ( inf ( R19 .: C156 ) ) by L910 , TARSKI:def 1;
L912: ( min (C156 , R19) ) c= C156 by L903 , L904 , L898;
thus L913: C157 in C156 by L912 , L908;
let C158 being (Element of R15);
assume L914: C158 in C156;
thus L915: ( R19 . C157 ) <= ( R19 . C158 ) by L914 , L911 , L906 , FUNCT_2:35 , XXREAL_2:def 2;
end;
assume that
L916: C157 in C156
and
L917: (for B87 being (Element of R15) holds (B87 in C156 implies ( R19 . C157 ) <= ( R19 . B87 )));
L918: ( R19 . C157 ) is (LowerBound of ( R19 .: C156 ))
proof
let C159 being  ext-real number;
assume L919: C159 in ( R19 .: C156 );
L920: (ex B88 being (Element of R15) st (B88 in C156 & C159 = ( R19 . B88 ))) by L919 , FUNCT_2:65;
thus L921: ( R19 . C157 ) <= C159 by L920 , L917;
end;
L922: (for B89 being (LowerBound of ( R19 .: C156 )) holds B89 <= ( R19 . C157 )) by L916 , FUNCT_2:35 , XXREAL_2:def 2;
L923: ( R19 . C157 ) = ( inf ( R19 .: C156 ) ) by L922 , L918 , XXREAL_2:def 4;
L924: ( R19 . C157 ) in { ( inf ( R19 .: C156 ) ) } by L923 , TARSKI:def 1;
L925: C157 in ( R19 " { ( inf ( R19 .: C156 ) ) } ) by L924 , FUNCT_2:38;
thus L926: C157 in ( min (C156 , R19) ) by L925 , L916 , L905;
end;
theorem
L927: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (for B90 being non  empty (Subset of R15) holds (for B91 being (Element of ( ValuatRing R19 )) holds ((B90 is (Ideal of ( ValuatRing R19 )) & B91 in ( min (B90 , R19) )) implies B90 = ( { B91 } -Ideal )))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L928: R15 is  having_valuation;
let C160 being non  empty (Subset of R15);
let C161 being (Element of ( ValuatRing R19 ));
assume L929: C160 is (Ideal of ( ValuatRing R19 ));
assume L930: C161 in ( min (C160 , R19) );
L931: ( min (C160 , R19) ) c= C160 by L928 , L929 , L898;
thus L932: C160 c= ( { C161 } -Ideal )
proof
let C162 being set;
assume L933: C162 in C160;
reconsider D131 = C162 as (Element of ( ValuatRing R19 )) by L933 , L929;
reconsider D132 = C161 , D133 = D131 as (Element of R15) by L928 , L762;
per cases  by L928 , L674;
suppose L934: C161 <> ( 0. R15 );

set D134 = ( D133 / D132 );
L935: ( R19 . D132 ) <= ( R19 . D133 ) by L928 , L929 , L930 , L933 , L902;
L936: ( 0 ) <= ( ( R19 . D133 ) - ( R19 . D132 ) ) by L935 , L436;
L937: ( 0 ) <= ( R19 . D134 ) by L936 , L934 , L928 , L329;
reconsider D135 = D134 as (Element of ( ValuatRing R19 )) by L937 , L928 , L767;
L938: ( D132 * D134 ) = ( D133 * ( ( D132 " ) * D132 ) ) by GROUP_1:def 3
.= ( D133 * ( 1_ R15 ) ) by L934 , VECTSP_2:9
.= D133 by GROUP_1:def 4;
L939: D131 = ( C161 * D135 ) by L938 , L928 , L783;
L940: ( { C161 } -Ideal ) = { ( C161 * B92 ) where B92 is (Element of ( ValuatRing R19 )) : (not contradiction) } by IDEAL_1:64;
thus L941: C162 in ( { C161 } -Ideal ) by L940 , L939;
end;
suppose L942: C161 = ( 0. ( ValuatRing R19 ) );

L943: ( { C161 } -Ideal ) = { ( 0. ( ValuatRing R19 ) ) } by L942 , IDEAL_1:47;
L944: ( 0. ( ValuatRing R19 ) ) = ( 0. R15 ) by L928 , L674;
L945: ( R19 . D132 ) = ( +infty ) by L944 , L928 , L942 , L294;
L946: ( R19 . D132 ) <= ( R19 . D133 ) by L928 , L933 , L929 , L930 , L902;
L947: D131 = ( 0. ( ValuatRing R19 ) ) by L946 , L928 , L944 , L303 , L945 , XXREAL_0:4;
thus L948: C162 in ( { C161 } -Ideal ) by L947 , L943 , TARSKI:def 1;
end;
end;

L950: { C161 } c= C160 by L931 , L930 , ZFMISC_1:31;
thus L951: ( { C161 } -Ideal ) c= C160 by L950 , L929 , IDEAL_1:def 14;
end;
theorem
L952: (for B93 being non  empty doubleLoopStr holds (for B94 being  add-closed non  empty (Subset of B93) holds B94 is (Preserv of (the addF of B93))))
proof
let C163 being non  empty doubleLoopStr;
let C164 being  add-closed non  empty (Subset of C163);
let C165 being set;
assume L953: C165 in [: C164 , C164 :];
consider C166 , C167 being set such that L954: (C166 in C164 & C167 in C164) and L955: C165 = [ C166 , C167 ] by L953 , ZFMISC_1:def 2;
reconsider D136 = C166 , D137 = C167 as (Element of C164) by L954;
L956: ( (the addF of C163) . C165 ) = ( D136 + D137 ) by L955;
thus L957: ( (the addF of C163) . C165 ) in C164 by L956 , IDEAL_1:def 1;
end;
L958:
now
let C168 being Ring;
let C169 being (RightIdeal of C168);
thus L959: (ex B95 being  strict (Submodule of ( RightModule C168 )) st (the carrier of B95) = C169)
proof
reconsider D138 = C169 as (Subset of ( RightModule C168 ));
L960: D138 is  linearly-closed
proof
thus L961:now
let C170 , C171 being (Vector of ( RightModule C168 ));
assume that
L962: (C170 in D138 & C171 in D138);
reconsider D139 = C170 , D140 = C171 as (Element of C168);
L963: ( D139 + D140 ) = ( C170 + C171 );
thus L964: ( C170 + C171 ) in D138 by L963 , L962 , IDEAL_1:def 1;
end;
let C172 being (Scalar of C168);
let C173 being (Vector of ( RightModule C168 ));
assume that
L965: C173 in D138;
reconsider D141 = C173 as (Element of C168);
L966: ( D141 * C172 ) = ( C173 * C172 );
thus L967: ( C173 * C172 ) in D138 by L966 , L965 , IDEAL_1:def 3;
end;
thus L968: thesis by L960 , RMOD_2:34;
end;

end;
definition
let C174 being Ring;
let C175 being (RightIdeal of C174);
mode Submodule of C175
 -> (Submodule of ( RightModule C174 ))
means :L960: (the carrier of it) = C175;
existence
proof
L961: (ex B96 being  strict (Submodule of ( RightModule C174 )) st (the carrier of B96) = C175) by L958;
thus L962: thesis by L961;
end;
end;
registration
let C176 being Ring;
let C177 being (RightIdeal of C176);
cluster  strict for (Submodule of C177);
existence
proof
consider C178 being  strict (Submodule of ( RightModule C176 )) such that L964: (the carrier of C178) = C177 by L958;
reconsider D142 = ( the RightModStr of C178 ) as (Submodule of C177) by L964 , L960;
take D142;
thus L965: thesis;
end;
end;
theorem
L967: (for B97 being Ring holds (for B98 being (Ideal of B97) holds (for B99 being (Submodule of B98) holds (for B100 being (BinOp of B98) holds (for B101 being (Element of B98) holds (for B102 being (Function of [: B98 , (the carrier of B97) :] , B98) holds ((B100 = ( (the addF of B97) | [: B98 , B98 :] ) & B102 = ( (the multF of B97) | [: B98 , (the carrier of B97) :] ) & B101 = (the ZeroF of B97)) implies ( the RightModStr of B99 ) = RightModStr (# B98 , B100 , B101 , B102 #))))))))
proof
let C179 being Ring;
let C180 being (Ideal of C179);
let C181 being (Submodule of C180);
L968: (the carrier of C181) = C180 by L960;
set D143 = ( RightModule C179 );
L969: (( 0. C181 ) = ( 0. D143 ) & (the addF of C181) = ( (the addF of D143) | [: C180 , C180 :] ) & (the rmult of C181) = ( (the rmult of D143) | [: C180 , (the carrier of C179) :] )) by L968 , RMOD_2:def 2;
thus L970: thesis by L969 , L960;
end;
definition
let C182 being Ring;
let C183 , C184 being (RightMod of C182);
let C185 being (Function of C183 , C184);
attr C185 is  scalar-linear
means
(for B103 being (Element of C183) holds (for B104 being (Element of C182) holds ( C185 . ( B103 * B104 ) ) = ( ( C185 . B103 ) * B104 )));
end;
registration
let C186 being Ring;
let C187 being (RightMod of C186);
let C188 being (Submodule of C187);
cluster ( incl (C188 , C187) ) ->  additive  scalar-linear;
coherence
proof
set D144 = ( incl (C188 , C187) );
L972: (the carrier of C188) c= (the carrier of C187) by RMOD_2:def 2;
L973: D144 = ( id (the carrier of C188) ) by L972 , YELLOW_9:def 1;
thus L974: ( incl (C188 , C187) ) is  additive
proof
let C189 , C190 being (Element of C188);
L975: (( D144 . C189 ) = C189 & ( D144 . C190 ) = C190 & ( D144 . ( C189 + C190 ) ) = ( C189 + C190 )) by L973 , FUNCT_1:17;
thus L976: thesis by L975 , RMOD_2:13;
end;

let C191 being (Element of C188);
let C192 being (Element of C186);
L977: (( D144 . C191 ) = C191 & ( D144 . ( C191 * C192 ) ) = ( C191 * C192 )) by L973 , FUNCT_1:17;
thus L978: thesis by L977 , RMOD_2:14;
end;
end;
theorem
L980: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R17 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & R17 is (Element of ( ValuatRing R19 ))) implies ( R19 . R16 ) <= ( ( R19 . R16 ) + ( R19 . R17 ) ))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R17 being (Element of R15);
let R19 being (Valuation of R15);
assume L981: R15 is  having_valuation;
assume L982: R17 is (Element of ( ValuatRing R19 ));
L983: ( 0 ) <= ( R19 . R17 ) by L982 , L981 , L767;
L984: ( ( R19 . R16 ) + ( 0 ) ) <= ( ( R19 . R16 ) + ( R19 . R17 ) ) by L983 , XXREAL_3:35;
thus L985: thesis by L984 , XXREAL_3:4;
end;
theorem
L986: (for R7 being Nat holds (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & R16 is (Element of ( ValuatRing R19 ))) implies ( ( power R15 ) . (R16 , R7) ) is (Element of ( ValuatRing R19 )))))))
proof
let R7 being Nat;
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
assume L987: R15 is  having_valuation;
assume L988: R16 is (Element of ( ValuatRing R19 ));
reconsider D145 = R16 as (Element of ( ValuatRing R19 )) by L988;
reconsider D146 = R7 as (Element of ( NAT )) by ORDINAL1:def 12;
L989: ( ( power ( ValuatRing R19 ) ) . (D145 , D146) ) is (Element of ( ValuatRing R19 ));
thus L990: thesis by L989 , L987 , L813;
end;
theorem
L991: (for R7 being Nat holds (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (for B105 being (Element of ( ValuatRing R19 )) holds (B105 <> ( 0. R15 ) implies ( ( power R15 ) . (B105 , R7) ) <> ( 0. R15 )))))))
proof
let R7 being Nat;
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L992: R15 is  having_valuation;
let C193 being (Element of ( ValuatRing R19 ));
reconsider D147 = C193 as (Element of R15) by L992 , L762;
L993: ( ( power R15 ) . (D147 , R7) ) = ( D147 |^ R7 );
thus L994: thesis by L993 , L281;
end;
theorem
L995: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & ( R19 . R16 ) = ( 0 )) implies (R16 is (Element of ( ValuatRing R19 )) & ( R16 " ) is (Element of ( ValuatRing R19 )))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
assume L996: R15 is  having_valuation;
assume L997: ( R19 . R16 ) = ( 0 );
thus L998: R16 is (Element of ( ValuatRing R19 )) by L996 , L997 , L767;
L999: R16 <> ( 0. R15 ) by L996 , L997 , L294;
L1000: ( R19 . ( R16 " ) ) = ( - ( R19 . R16 ) ) by L999 , L996 , L316;
thus L1001: thesis by L1000 , L996 , L997 , L767;
end;
theorem
L1002: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & R16 <> ( 0. R15 ) & R16 is (Element of ( ValuatRing R19 )) & ( R16 " ) is (Element of ( ValuatRing R19 ))) implies ( R19 . R16 ) = ( 0 )))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
assume L1003: R15 is  having_valuation;
assume that
L1004: R16 <> ( 0. R15 )
and
L1005: R16 is (Element of ( ValuatRing R19 ));
assume L1006: ( R16 " ) is (Element of ( ValuatRing R19 ));
L1007: ( 0 ) <= ( R19 . ( R16 " ) ) by L1006 , L1003 , L767;
L1008: ( - ( - ( R19 . R16 ) ) ) <= ( - ( 0 ) ) by L1007 , L1003 , L1004 , L316;
thus L1009: thesis by L1008 , L1005 , L1003 , L767;
end;
theorem
L1010: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R16 being (Element of R15) holds (for R19 being (Valuation of R15) holds ((R15 is  having_valuation & ( R19 . R16 ) = ( 0 )) implies (for B106 being (Ideal of ( ValuatRing R19 )) holds (R16 in B106 iff B106 = (the carrier of ( ValuatRing R19 ))))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R16 being (Element of R15);
let R19 being (Valuation of R15);
assume L1011: R15 is  having_valuation;
assume L1012: ( R19 . R16 ) = ( 0 );
let C194 being (Ideal of ( ValuatRing R19 ));
thus L1013: (R16 in C194 implies C194 = (the carrier of ( ValuatRing R19 )))
proof
assume L1014: R16 in C194;
thus L1015: C194 c= (the carrier of ( ValuatRing R19 ));
let C195 being set;
assume L1016: C195 in (the carrier of ( ValuatRing R19 ));
reconsider D148 = C195 as (Element of ( ValuatRing R19 )) by L1016;
reconsider D149 = D148 as (Element of R15) by L1011 , L762;
L1017: R16 <> ( 0. R15 ) by L1011 , L1012 , L294;
reconsider D150 = R16 , D151 = ( R16 " ) as (Element of ( ValuatRing R19 )) by L1011 , L1012 , L995;
L1018: ( D150 * ( D151 * D148 ) ) in C194 by L1014 , IDEAL_1:def 2;
reconsider D152 = ( D151 * D148 ) as (Element of R15) by L1011 , L762;
L1019: ( D151 * D148 ) = ( ( R16 " ) * D149 ) by L1011 , L783;
L1020: ( D150 * ( D151 * D148 ) ) = ( R16 * ( ( R16 " ) * D149 ) ) by L1019 , L1011 , L783;
thus L1021: thesis by L1020 , L1018 , L1017 , L802;
end;

L1022: (the carrier of ( ValuatRing R19 )) = ( NonNegElements R19 ) by L1011 , L674;
thus L1023: thesis by L1022 , L1012;
end;
theorem
L1024: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( Pgenerator R19 ) is (Element of ( ValuatRing R19 )))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
set D153 = ( Pgenerator R19 );
set D154 = ( least-positive ( rng R19 ) );
assume L1025: R15 is  having_valuation;
L1026: D153 = the (Element of ( R19 " { D154 } )) by L1025 , L515;
L1027: D154 in ( rng R19 ) by L1025 , L451;
L1028: { D154 } c= ( rng R19 ) by L1027 , ZFMISC_1:31;
L1029: ( R19 " { D154 } ) is non  empty by L1028 , RELAT_1:139;
L1030: ( R19 . D153 ) in { D154 } by L1029 , L1026 , FUNCT_1:def 7;
L1031: ( R19 . D153 ) = D154 by L1030 , TARSKI:def 1;
thus L1032: thesis by L1031 , L1025 , L767;
end;
theorem
L1033: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( vp R19 ) is  proper)))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L1034: R15 is  having_valuation;
L1035: ( 1. R15 ) is (Element of ( ValuatRing R19 )) by L1034 , L674;
thus L1036: ( vp R19 ) <> (the carrier of ( ValuatRing R19 )) by L1035 , L1034 , L879;
end;
theorem
L1037: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (for B107 being (Element of ( ValuatRing R19 )) holds ((not B107 in ( vp R19 )) implies ( R19 . B107 ) = ( 0 ))))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L1038: R15 is  having_valuation;
let C196 being (Element of ( ValuatRing R19 ));
reconsider D155 = C196 as (Element of R15) by L1038 , L762;
assume L1039: (not C196 in ( vp R19 ));
L1040: ( R19 . D155 ) <= ( 0 ) by L1039 , L1038 , L867;
thus L1041: thesis by L1040 , L1038 , L767;
end;
theorem
L1042: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( vp R19 ) is  prime)))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L1043: R15 is  having_valuation;
thus L1044: ( vp R19 ) is  proper by L1043 , L1033;
let C197 , C198 being (Element of ( ValuatRing R19 ));
assume that
L1045: ( C197 * C198 ) in ( vp R19 );
assume L1046: (not C197 in ( vp R19 ));
L1047: ( R19 . C197 ) = ( 0 ) by L1046 , L1043 , L1037;
assume L1048: (not C198 in ( vp R19 ));
reconsider D156 = C197 , D157 = C198 as (Element of R15) by L1043 , L762;
L1049: ( C197 * C198 ) = ( D156 * D157 ) by L1043 , L783;
L1050: ( R19 . D157 ) = ( 0 ) by L1043 , L1048 , L1037;
L1051: ( R19 . ( D156 * D157 ) ) = ( ( R19 . D156 ) + ( R19 . D157 ) ) by L1043 , L294
.= ( 0 ) by L1047 , L1050;
thus L1052: thesis by L1051 , L1043 , L1045 , L1049 , L867;
end;
theorem
L1053: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (for B108 being  proper (Ideal of ( ValuatRing R19 )) holds B108 c= ( vp R19 )))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L1054: R15 is  having_valuation;
let C199 being  proper (Ideal of ( ValuatRing R19 ));
L1055: C199 <> (the carrier of ( ValuatRing R19 )) by SUBSET_1:def 6;
assume L1056: (not C199 c= ( vp R19 ));
consider C200 being set such that L1057: C200 in C199 and L1058: (not C200 in ( vp R19 )) by L1056 , TARSKI:def 3;
L1059: C200 is (Element of R15) by L1054 , L1057 , L762;
L1060: ( R19 . C200 ) = ( 0 ) by L1054 , L1058 , L1057 , L1037;
thus L1061: thesis by L1060 , L1054 , L1055 , L1057 , L1059 , L1010;
end;
theorem
L1062: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( vp R19 ) is  maximal)))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L1063: R15 is  having_valuation;
thus L1064: ( vp R19 ) is  proper
proof
L1065: ( 1. ( ValuatRing R19 ) ) = ( 1. R15 ) by L1063 , L674;
thus L1066: ( vp R19 ) <> (the carrier of ( ValuatRing R19 )) by L1065 , L1063 , L879;
end;

let C201 being (Ideal of ( ValuatRing R19 ));
assume L1067: ( vp R19 ) c= C201;
L1068: (C201 is non  proper or C201 = ( vp R19 ))
proof
assume L1069: C201 is  proper;
L1070: C201 c= ( vp R19 ) by L1069 , L1063 , L1053;
thus L1071: C201 = ( vp R19 ) by L1070 , L1067 , XBOOLE_0:def 10;
end;
thus L1072: thesis by L1068;
end;
theorem
L1073: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies (for B109 being  maximal (Ideal of ( ValuatRing R19 )) holds B109 = ( vp R19 )))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L1074: R15 is  having_valuation;
let C202 being  maximal (Ideal of ( ValuatRing R19 ));
assume L1075: (not thesis);
per cases ;
suppose L1076: (not C202 c= ( vp R19 ));

thus L1077: contradiction by L1076 , L1074 , L1053;
end;
suppose L1078: C202 c= ( vp R19 );

L1079: (( vp R19 ) is non  proper or C202 = ( vp R19 )) by L1078 , RING_1:def 3;
L1080: (( vp R19 ) = (the carrier of ( ValuatRing R19 )) or C202 = ( vp R19 )) by L1079 , SUBSET_1:def 6;
L1081: ( 1. ( ValuatRing R19 ) ) = ( 1. R15 ) by L1074 , L674;
thus L1082: contradiction by L1081 , L1080 , L1074 , L1075 , L879;
end;
end;
theorem
L1084: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( NonNegElements ( normal-valuation R19 ) ) = ( NonNegElements R19 ))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L1085: R15 is  having_valuation;
set D158 = ( normal-valuation R19 );
thus L1086: ( NonNegElements D158 ) c= ( NonNegElements R19 )
proof
let C203 being set;
assume L1087: C203 in ( NonNegElements D158 );
consider C204 being (Element of R15) such that L1088: C203 = C204 and L1089: ( 0 ) <= ( D158 . C204 ) by L1087;
L1090: ( 0 ) <= ( R19 . C204 ) by L1085 , L1089 , L606;
thus L1091: thesis by L1090 , L1088;
end;

let C205 being set;
assume L1092: C205 in ( NonNegElements R19 );
consider C206 being (Element of R15) such that L1093: C205 = C206 and L1094: ( 0 ) <= ( R19 . C206 ) by L1092;
L1095: ( 0 ) <= ( D158 . C206 ) by L1085 , L1094 , L606;
thus L1096: thesis by L1095 , L1093;
end;
theorem
L1097: (for R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr holds (for R19 being (Valuation of R15) holds (R15 is  having_valuation implies ( ValuatRing ( normal-valuation R19 ) ) = ( ValuatRing R19 ))))
proof
let R15 being  Field-like non  degenerated  associative  add-associative  right_zeroed  right_complementable  distributive  Abelian non  empty doubleLoopStr;
let R19 being (Valuation of R15);
assume L1098: R15 is  having_valuation;
set D159 = ( normal-valuation R19 );
set D160 = ( ValuatRing R19 );
set D161 = ( ValuatRing D159 );
L1099: (the carrier of D161) = ( NonNegElements D159 ) by L1098 , L674;
L1100: ( NonNegElements D159 ) = ( NonNegElements R19 ) by L1098 , L1084;
L1101: (the addF of D160) = ( (the addF of R15) | [: ( NonNegElements R19 ) , ( NonNegElements R19 ) :] ) by L1098 , L674
.= (the addF of D161) by L1098 , L1100 , L674;
L1102: (the multF of D160) = ( (the multF of R15) | [: ( NonNegElements R19 ) , ( NonNegElements R19 ) :] ) by L1098 , L674
.= (the multF of D161) by L1098 , L1100 , L674;
L1103: (the ZeroF of D160) = ( 0. R15 ) by L1098 , L674
.= (the ZeroF of D161) by L1098 , L674;
L1104: (the OneF of D160) = ( 1. R15 ) by L1098 , L674
.= (the OneF of D161) by L1098 , L674;
thus L1105: thesis by L1104 , L1100 , L1099 , L1101 , L1102 , L1103 , L1098 , L674;
end;
