:: Circuit Generated by Terms and Circuit Calculating Terms
::  by Grzegorz Bancerek
::
:: Received April 10, 2001
:: Copyright (c) 2001-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, STRUCT_0, MSUALG_1, RELAT_1, MSATERM, SUBSET_1,
      FUNCT_1, TREES_4, MSAFREE, PBOOLE, TREES_9, ZFMISC_1, FUNCT_3, CIRCCOMB,
      GLIB_000, TREES_1, FINSEQ_1, NUMBERS, ORDINAL4, MARGREL1, TREES_3,
      FINSET_1, TREES_2, PARTFUN1, FUNCT_4, MSAFREE2, MCART_1, TARSKI,
      FUNCOP_1, CARD_3, QC_LANG1, FSM_1, CIRCUIT2, FACIRC_1, FUNCT_6, TREES_A,
      ARYTM_3, XXREAL_0, NAT_1, CARD_1, PUA2MSS1, REWRITE1, CQC_SIM1, CIRCUIT1,
      CIRCTRM1;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, NUMBERS, ORDINAL1, NAT_1,
      RELAT_1, FUNCT_1, FUNCT_2, FINSEQ_1, FINSET_1, PARTFUN1, MCART_1,
      FINSEQ_2, FUNCT_4, CARD_3, FUNCOP_1, FUNCT_3, STRUCT_0, PBOOLE, MSUALG_1,
      MSAFREE2, CIRCUIT1, CIRCUIT2, CIRCCOMB, FACIRC_1, TREES_1, TREES_2,
      TREES_3, TREES_4, TREES_9, MSATERM, PUA2MSS1, XXREAL_0;
 constructors TREES_9, MSUALG_3, MSATERM, CIRCUIT1, CIRCUIT2, FACIRC_1,
      PUA2MSS1, INSTALG1, NAT_1, XREAL_0, RELSET_1, XTUPLE_0;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, FUNCOP_1, XREAL_0, FINSEQ_1, CARD_3,
      PBOOLE, TREES_2, TREES_3, TREES_9, STRUCT_0, MSUALG_1, MSUALG_2, MSAFREE,
      MSATERM, CIRCCOMB, INSTALG1, ORDINAL1, FINSET_1, CARD_1, RELSET_1,
      XTUPLE_0;
 requirements NUMERALS, BOOLE, SUBSET;
 definitions TARSKI, PARTFUN1, FUNCOP_1, PBOOLE, MSUALG_1, MSAFREE2, CIRCUIT2,
      CIRCCOMB, PUA2MSS1, FINSET_1, FACIRC_1, XBOOLE_0, XTUPLE_0;
 theorems MSUALG_1, TARSKI, ZFMISC_1, NAT_1, RELAT_1, FUNCT_1, FUNCT_2,
      FINSEQ_1, PARTFUN1, FUNCT_4, FUNCT_6, MCART_1, PBOOLE, MSAFREE2, CARD_3,
      TREES_1, TREES_2, TREES_3, TREES_4, TREES_9, MSAFREE, MSATERM, CIRCUIT1,
      CIRCUIT2, CIRCCOMB, FACIRC_1, PUA2MSS1, INSTALG1, XBOOLE_0, FINSET_1,
      ORDINAL1, FINSEQ_2;
 schemes NAT_1, FINSEQ_1, CLASSES1, PBOOLE, MSATERM, FUNCT_1;

begin
theorem
L1: (for B1 being non  empty non  void ManySortedSign holds (for B2 being  non-empty MSAlgebra over B1 holds (for B3 being (Variables of B2) holds (for B4 being (Term of B1 , B3) holds (for B5 being (c-Term of B2 , B3) holds (B5 = B4 implies ( the_sort_of B5 ) = ( the_sort_of B4 )))))))
proof
let C1 being non  empty non  void ManySortedSign;
let C2 being  non-empty MSAlgebra over C1;
let C3 being (Variables of C2);
defpred S1[ set ] means (for B6 being (Term of C1 , C3) holds (for B7 being (c-Term of C2 , C3) holds ((B6 = $1 & B7 = B6) implies ( the_sort_of B7 ) = ( the_sort_of B6 ))));
L2: (for B8 being (SortSymbol of C1) holds (for B9 being (Element of ( C3 . B8 )) holds S1[ ( root-tree [ B9 , B8 ] ) ]))
proof
let C4 being (SortSymbol of C1);
let C5 being (Element of ( C3 . C4 ));
let C6 being (Term of C1 , C3);
let C7 being (c-Term of C2 , C3);
assume that
L3: C6 = ( root-tree [ C5 , C4 ] )
and
L4: C7 = C6;
L5: ( the_sort_of C6 ) = C4 by L3 , MSATERM:14;
thus L6: thesis by L5 , L3 , L4 , MSATERM:16;
end;
L7: (for B10 being (OperSymbol of C1) holds (for B11 being (ArgumentSeq of ( Sym (B10 , C3) )) holds ((for B12 being (Term of C1 , C3) holds (B12 in ( rng B11 ) implies S1[ B12 ])) implies S1[ ( [ B10 , (the carrier of C1) ] -tree B11 ) ])))
proof
let C8 being (OperSymbol of C1);
let C9 being (ArgumentSeq of ( Sym (C8 , C3) ));
assume L8: (for B13 being (Term of C1 , C3) holds (B13 in ( rng C9 ) implies (for B14 being (Term of C1 , C3) holds (for B15 being (c-Term of C2 , C3) holds ((B14 = B13 & B15 = B14) implies ( the_sort_of B15 ) = ( the_sort_of B14 ))))));
let C10 being (Term of C1 , C3);
let C11 being (c-Term of C2 , C3);
assume L9: C10 = ( [ C8 , (the carrier of C1) ] -tree C9 );
L10: ( C10 . ( {} ) ) = [ C8 , (the carrier of C1) ] by L9 , TREES_4:def 4;
L11: ( the_sort_of C10 ) = ( the_result_sort_of C8 ) by L10 , MSATERM:17;
thus L12: thesis by L11 , L10 , MSATERM:17;
end;
L13: (for B16 being (Term of C1 , C3) holds S1[ B16 ]) from MSATERM:sch 1(L2 , L7);
thus L14: thesis by L13;
end;
definition
let C12 being non  empty non  void ManySortedSign;
let C13 being  non-empty (ManySortedSet of (the carrier of C12));
let C14 being non  empty (Subset of ( C12 -Terms C13 ));
func C14 -CircuitStr -> non  empty  strict ManySortedSign equals 
ManySortedSign (# ( Subtrees C14 ) , ( [: (the carrier' of C12) , { (the carrier of C12) } :] -Subtrees C14 ) , ( [: (the carrier' of C12) , { (the carrier of C12) } :] -ImmediateSubtrees C14 ) , ( incl ( [: (the carrier' of C12) , { (the carrier of C12) } :] -Subtrees C14 ) ) #);
correctness;
end;
registration
let C15 being non  empty non  void ManySortedSign;
let C16 being  non-empty (ManySortedSet of (the carrier of C15));
let C17 being non  empty (Subset of ( C15 -Terms C16 ));
cluster ( C17 -CircuitStr ) ->  unsplit;
coherence
proof
thus L16: (the ResultSort of ( C17 -CircuitStr )) = ( id (the carrier' of ( C17 -CircuitStr )) );
end;
end;
theorem
L18: (for R1 being non  empty non  void ManySortedSign holds (for R2 being  non-empty (ManySortedSet of (the carrier of R1)) holds (for R4 being non  empty (Subset of ( R1 -Terms R2 )) holds (( R4 -CircuitStr ) is  void iff (for B17 being (Element of R4) holds (B17 is  root & (not ( B17 . ( {} ) ) in [: (the carrier' of R1) , { (the carrier of R1) } :]))))))) by TREES_9:25;
theorem
L19: (for R1 being non  empty non  void ManySortedSign holds (for R2 being  non-empty (ManySortedSet of (the carrier of R1)) holds (for R4 being non  empty (Subset of ( R1 -Terms R2 )) holds (R4 is (SetWithCompoundTerm of R1 , R2) iff ( R4 -CircuitStr ) is non  void))))
proof
let R1 being non  empty non  void ManySortedSign;
let R2 being  non-empty (ManySortedSet of (the carrier of R1));
let R4 being non  empty (Subset of ( R1 -Terms R2 ));
thus L20:now
assume L21: R4 is (SetWithCompoundTerm of R1 , R2);
consider C18 being (CompoundTerm of R1 , R2) such that L22: C18 in R4 by L21 , MSATERM:def 7;
L23: ( C18 . ( {} ) ) in [: (the carrier' of R1) , { (the carrier of R1) } :] by MSATERM:def 6;
thus L24: ( R4 -CircuitStr ) is non  void by L23 , L22 , TREES_9:25;
end;
assume L25: ( R4 -CircuitStr ) is non  void;
consider R5 being (Element of R4) such that L26: ((not R5 is  root) or ( R5 . ( {} ) ) in [: (the carrier' of R1) , { (the carrier of R1) } :]) by L25 , TREES_9:25;
L27: R5 is (CompoundTerm of R1 , R2) by L26 , MSATERM:28 , MSATERM:def 6;
thus L28: thesis by L27 , MSATERM:def 7;
end;
registration
let C19 being non  empty non  void ManySortedSign;
let C20 being  non-empty (ManySortedSet of (the carrier of C19));
let C21 being (SetWithCompoundTerm of C19 , C20);
cluster ( C21 -CircuitStr ) -> non  void;
coherence by L19;
end;
theorem
L30: (for R1 being non  empty non  void ManySortedSign holds (for R2 being  non-empty (ManySortedSet of (the carrier of R1)) holds (for R4 being non  empty (Subset of ( R1 -Terms R2 )) holds ((for B18 being (Vertex of ( R4 -CircuitStr )) holds B18 is (Term of R1 , R2)) & (for B19 being set holds (B19 in (the carrier' of ( R4 -CircuitStr )) implies B19 is (CompoundTerm of R1 , R2)))))))
proof
let R1 being non  empty non  void ManySortedSign;
let R2 being  non-empty (ManySortedSet of (the carrier of R1));
let R4 being non  empty (Subset of ( R1 -Terms R2 ));
set D1 = [: (the carrier' of R1) , { (the carrier of R1) } :];
thus L31:now
let C22 being (Vertex of ( R4 -CircuitStr ));
consider C23 being (Element of R4), C24 being (Node of C23) such that L32: C22 = ( C23 | C24 ) by TREES_9:19;
thus L33: C22 is (Term of R1 , R2) by L32;
end;
let C25 being set;
assume L34: C25 in (the carrier' of ( R4 -CircuitStr ));
consider C26 being (Element of R4), C27 being (Node of C26) such that L35: C25 = ( C26 | C27 ) and L36: ((not C27 in ( Leaves ( dom C26 ) )) or ( C26 . C27 ) in D1) by L34 , TREES_9:24;
reconsider D2 = C25 as (Term of R1 , R2) by L35;
reconsider D3 = ( {} ) as (Node of ( C26 | C27 )) by TREES_1:22;
L37: ( dom ( C26 | C27 ) ) = ( (( dom C26 ) qua Tree) | (C27 qua (FinSequence of ( NAT ))) ) by TREES_2:def 10;
L38: C27 = ( C27 ^ D3 ) by FINSEQ_1:34;
L39: ( C26 . C27 ) = ( D2 . D3 ) by L38 , L35 , L37 , TREES_2:def 10;
L40: (C27 in ( Leaves ( dom C26 ) ) iff D2 is  root) by L35 , TREES_9:6;
thus L41: thesis by L40 , L36 , L39 , MSATERM:28 , MSATERM:def 6;
end;
theorem
L42: (for R1 being non  empty non  void ManySortedSign holds (for R2 being  non-empty (ManySortedSet of (the carrier of R1)) holds (for R4 being non  empty (Subset of ( R1 -Terms R2 )) holds (for B20 being (Vertex of ( R4 -CircuitStr )) holds (B20 in (the carrier' of ( R4 -CircuitStr )) iff B20 is (CompoundTerm of R1 , R2))))))
proof
let R1 being non  empty non  void ManySortedSign;
let R2 being  non-empty (ManySortedSet of (the carrier of R1));
let R4 being non  empty (Subset of ( R1 -Terms R2 ));
let C28 being (Vertex of ( R4 -CircuitStr ));
thus L43: (C28 in (the carrier' of ( R4 -CircuitStr )) implies C28 is (CompoundTerm of R1 , R2)) by L30;
set D4 = [: (the carrier' of R1) , { (the carrier of R1) } :];
consider C29 being (Element of R4), C30 being (Node of C29) such that L44: C28 = ( C29 | C30 ) by TREES_9:19;
assume L45: C28 is (CompoundTerm of R1 , R2);
reconsider D5 = C28 as (CompoundTerm of R1 , R2) by L45;
L46: ( D5 . ( {} ) ) in D4 by MSATERM:def 6;
L47: ( C30 ^ ( <*> ( NAT ) ) ) = C30 by FINSEQ_1:34;
L48: ( {} ) in ( ( dom C29 ) | C30 ) by TREES_1:22;
L49: ( C29 . C30 ) in D4 by L48 , L44 , L46 , L47 , TREES_2:def 10;
thus L50: thesis by L49 , L44 , TREES_9:24;
end;
registration
let R1 being non  empty non  void ManySortedSign;
let R2 being  non-empty (ManySortedSet of (the carrier of R1));
let C31 being (SetWithCompoundTerm of R1 , R2);
let C32 being (Gate of ( C31 -CircuitStr ));
cluster ( the_arity_of C32 ) ->  DTree-yielding;
coherence;
end;
registration
let C33 being non  empty non  void ManySortedSign;
let C34 being  non-empty (ManySortedSet of (the carrier of C33));
let C35 being non  empty (Subset of ( C33 -Terms C34 ));
cluster  ->  finite  Function-like  Relation-like for (Vertex of ( C35 -CircuitStr ));
coherence by L30;
end;
registration
let C36 being non  empty non  void ManySortedSign;
let C37 being  non-empty (ManySortedSet of (the carrier of C36));
let C38 being non  empty (Subset of ( C36 -Terms C37 ));
cluster  ->  DecoratedTree-like for (Vertex of ( C38 -CircuitStr ));
coherence;
end;
registration
let C39 being non  empty non  void ManySortedSign;
let C40 being  non-empty (ManySortedSet of (the carrier of C39));
let C41 being (SetWithCompoundTerm of C39 , C40);
cluster  ->  finite  Function-like  Relation-like for (Gate of ( C41 -CircuitStr ));
coherence by L30;
end;
registration
let C42 being non  empty non  void ManySortedSign;
let C43 being  non-empty (ManySortedSet of (the carrier of C42));
let C44 being (SetWithCompoundTerm of C42 , C43);
cluster  ->  DecoratedTree-like for (Gate of ( C44 -CircuitStr ));
coherence;
end;
theorem
L56: (for R1 being non  empty non  void ManySortedSign holds (for R2 being  non-empty (ManySortedSet of (the carrier of R1)) holds (for B21 , B22 being non  empty (Subset of ( R1 -Terms R2 )) holds ((the Arity of ( B21 -CircuitStr )) tolerates (the Arity of ( B22 -CircuitStr )) & (the ResultSort of ( B21 -CircuitStr )) tolerates (the ResultSort of ( B22 -CircuitStr ))))))
proof
let R1 being non  empty non  void ManySortedSign;
let R2 being  non-empty (ManySortedSet of (the carrier of R1));
let C45 , C46 being non  empty (Subset of ( R1 -Terms R2 ));
set D6 = [: (the carrier' of R1) , { (the carrier of R1) } :];
L57: ( dom ( D6 -ImmediateSubtrees C45 ) ) = ( D6 -Subtrees C45 ) by FUNCT_2:def 1;
L58: ( dom ( id ( D6 -Subtrees C45 ) ) ) = ( D6 -Subtrees C45 );
L59: ( dom ( D6 -ImmediateSubtrees C46 ) ) = ( D6 -Subtrees C46 ) by FUNCT_2:def 1;
L60: ( dom ( id ( D6 -Subtrees C46 ) ) ) = ( D6 -Subtrees C46 );
thus L61:now
let C47 being set;
assume L62: C47 in ( ( dom (the Arity of ( C45 -CircuitStr )) ) /\ ( dom (the Arity of ( C46 -CircuitStr )) ) );
L63: C47 in ( dom (the Arity of ( C45 -CircuitStr )) ) by L62 , XBOOLE_0:def 4;
L64: C47 in ( dom (the Arity of ( C46 -CircuitStr )) ) by L62 , XBOOLE_0:def 4;
reconsider D7 = C47 as (Element of ( Subtrees C45 )) by L57 , L63;
L65: ( ( D6 -ImmediateSubtrees C45 ) . C47 ) in ( ( Subtrees C45 ) * ) by L57 , L63 , FUNCT_2:5;
reconsider D8 = ( (the Arity of ( C45 -CircuitStr )) . C47 ) as (FinSequence of ( Subtrees C45 )) by L65 , FINSEQ_1:def 11;
L66: ( (the Arity of ( C46 -CircuitStr )) . C47 ) in ( ( Subtrees C46 ) * ) by L59 , L64 , FUNCT_2:5;
reconsider D9 = ( (the Arity of ( C46 -CircuitStr )) . C47 ) as (FinSequence of ( Subtrees C46 )) by L66 , FINSEQ_1:def 11;
L67: ((for B23 being (Element of C45) holds B23 is  finite) & (for B24 being (Element of C46) holds B24 is  finite));
L68: D7 = ( ( D7 . ( {} ) ) -tree D8 ) by L67 , L57 , L63 , TREES_9:def 13;
L69: D7 = ( ( D7 . ( {} ) ) -tree D9 ) by L59 , L64 , L67 , TREES_9:def 13;
thus L70: ( (the Arity of ( C45 -CircuitStr )) . C47 ) = ( (the Arity of ( C46 -CircuitStr )) . C47 ) by L69 , L68 , TREES_4:15;
end;
let C48 being set;
assume L71: C48 in ( ( dom (the ResultSort of ( C45 -CircuitStr )) ) /\ ( dom (the ResultSort of ( C46 -CircuitStr )) ) );
L72: C48 in ( dom (the ResultSort of ( C45 -CircuitStr )) ) by L71 , XBOOLE_0:def 4;
L73: C48 in ( dom (the ResultSort of ( C46 -CircuitStr )) ) by L71 , XBOOLE_0:def 4;
thus L74: ( (the ResultSort of ( C45 -CircuitStr )) . C48 ) = C48 by L58 , L72 , FUNCT_1:18
.= ( (the ResultSort of ( C46 -CircuitStr )) . C48 ) by L60 , L73 , FUNCT_1:18;
end;
registration
let C49 , C50 being  constituted-DTrees set;
cluster ( C49 \/ C50 ) ->  constituted-DTrees;
coherence by TREES_3:9;
end;
theorem
L76: (for B25 , B26 being  constituted-DTrees non  empty set holds ( Subtrees ( B25 \/ B26 ) ) = ( ( Subtrees B25 ) \/ ( Subtrees B26 ) ))
proof
let C51 , C52 being  constituted-DTrees non  empty set;
thus L77:now
let C53 being set;
assume L78: C53 in ( Subtrees ( C51 \/ C52 ) );
consider C54 being (Element of ( C51 \/ C52 )), C55 being (Node of C54) such that L79: C53 = ( C54 | C55 ) by L78 , TREES_9:19;
L80: (C54 in C51 or C54 in C52) by XBOOLE_0:def 3;
L81: (C53 in ( Subtrees C51 ) or C53 in ( Subtrees C52 )) by L80 , L79 , TREES_9:19;
thus L82: C53 in ( ( Subtrees C51 ) \/ ( Subtrees C52 ) ) by L81 , XBOOLE_0:def 3;
end;
let C56 being set;
assume L83: C56 in ( ( Subtrees C51 ) \/ ( Subtrees C52 ) );
per cases  by L83 , XBOOLE_0:def 3;
suppose L84: C56 in ( Subtrees C51 );

consider C57 being (Element of C51), C58 being (Node of C57) such that L85: C56 = ( C57 | C58 ) by L84 , TREES_9:19;
L86: C57 is (Element of ( C51 \/ C52 )) by XBOOLE_0:def 3;
thus L87: thesis by L86 , L85 , TREES_9:19;
end;
suppose L88: C56 in ( Subtrees C52 );

consider C59 being (Element of C52), C60 being (Node of C59) such that L89: C56 = ( C59 | C60 ) by L88 , TREES_9:19;
L90: C59 is (Element of ( C51 \/ C52 )) by XBOOLE_0:def 3;
thus L91: thesis by L90 , L89 , TREES_9:19;
end;
end;
theorem
L93: (for B27 , B28 being  constituted-DTrees non  empty set holds (for B29 being set holds ( B29 -Subtrees ( B27 \/ B28 ) ) = ( ( B29 -Subtrees B27 ) \/ ( B29 -Subtrees B28 ) )))
proof
let C61 , C62 being  constituted-DTrees non  empty set;
let C63 being set;
thus L94:now
let C64 being set;
assume L95: C64 in ( C63 -Subtrees ( C61 \/ C62 ) );
consider C65 being (Element of ( C61 \/ C62 )), C66 being (Node of C65) such that L96: C64 = ( C65 | C66 ) and L97: ((not C66 in ( Leaves ( dom C65 ) )) or ( C65 . C66 ) in C63) by L95 , TREES_9:24;
L98: (C65 in C61 or C65 in C62) by XBOOLE_0:def 3;
L99: (C64 in ( C63 -Subtrees C61 ) or C64 in ( C63 -Subtrees C62 )) by L98 , L96 , L97 , TREES_9:24;
thus L100: C64 in ( ( C63 -Subtrees C61 ) \/ ( C63 -Subtrees C62 ) ) by L99 , XBOOLE_0:def 3;
end;
let C67 being set;
assume L101: C67 in ( ( C63 -Subtrees C61 ) \/ ( C63 -Subtrees C62 ) );
per cases  by L101 , XBOOLE_0:def 3;
suppose L102: C67 in ( C63 -Subtrees C61 );

consider C68 being (Element of C61), C69 being (Node of C68) such that L103: C67 = ( C68 | C69 ) and L104: ((not C69 in ( Leaves ( dom C68 ) )) or ( C68 . C69 ) in C63) by L102 , TREES_9:24;
L105: C68 is (Element of ( C61 \/ C62 )) by XBOOLE_0:def 3;
thus L106: thesis by L105 , L103 , L104 , TREES_9:24;
end;
suppose L107: C67 in ( C63 -Subtrees C62 );

consider C70 being (Element of C62), C71 being (Node of C70) such that L108: C67 = ( C70 | C71 ) and L109: ((not C71 in ( Leaves ( dom C70 ) )) or ( C70 . C71 ) in C63) by L107 , TREES_9:24;
L110: C70 is (Element of ( C61 \/ C62 )) by XBOOLE_0:def 3;
thus L111: thesis by L110 , L108 , L109 , TREES_9:24;
end;
end;
theorem
L113: (for B30 , B31 being  constituted-DTrees non  empty set holds (((for B32 being (Element of B30) holds B32 is  finite) & (for B33 being (Element of B31) holds B33 is  finite)) implies (for B34 being set holds ( B34 -ImmediateSubtrees ( B30 \/ B31 ) ) = ( ( B34 -ImmediateSubtrees B30 ) +* ( B34 -ImmediateSubtrees B31 ) ))))
proof
let C72 , C73 being  constituted-DTrees non  empty set;
assume that
L114: (for B35 being (Element of C72) holds B35 is  finite)
and
L115: (for B36 being (Element of C73) holds B36 is  finite);
L116:
now
let C74 being (Element of ( C72 \/ C73 ));
L117: (C74 in C72 or C74 in C73) by XBOOLE_0:def 3;
thus L118: C74 is  finite by L117 , L114 , L115;
end;
let C75 being set;
set D10 = ( C72 \/ C73 );
set D11 = ( C75 -ImmediateSubtrees ( C72 \/ C73 ) );
set D12 = ( C75 -ImmediateSubtrees C72 );
set D13 = ( C75 -ImmediateSubtrees C73 );
L119: ( dom D11 ) = ( C75 -Subtrees D10 ) by FUNCT_2:def 1;
L120: ( dom D12 ) = ( C75 -Subtrees C72 ) by FUNCT_2:def 1;
L121: ( dom D13 ) = ( C75 -Subtrees C73 ) by FUNCT_2:def 1;
L122: ( C75 -Subtrees D10 ) = ( ( C75 -Subtrees C72 ) \/ ( C75 -Subtrees C73 ) ) by L93;
L123:
now
let C76 being set;
assume L124: C76 in ( ( dom D12 ) \/ ( dom D13 ) );
reconsider D14 = C76 as (Element of ( Subtrees D10 )) by L124 , L120 , L121 , L122;
L125: ( D11 . C76 ) in ( ( Subtrees D10 ) * ) by L120 , L121 , L122 , L124 , FUNCT_2:5;
reconsider D15 = ( D11 . C76 ) as (FinSequence of ( Subtrees D10 )) by L125 , FINSEQ_1:def 11;
thus L126:now
assume L127: C76 in ( dom D13 );
L128: ( D13 . C76 ) in ( ( Subtrees C73 ) * ) by L127 , L121 , FUNCT_2:5;
reconsider D16 = ( D13 . C76 ) as (FinSequence of ( Subtrees C73 )) by L128 , FINSEQ_1:def 11;
L129: D14 = ( ( D14 . ( {} ) ) -tree D15 ) by L116 , L120 , L121 , L122 , L124 , TREES_9:def 13;
L130: D14 = ( ( D14 . ( {} ) ) -tree D16 ) by L115 , L121 , L127 , TREES_9:def 13;
thus L131: ( D11 . C76 ) = ( D13 . C76 ) by L130 , L129 , TREES_4:15;
end;
assume L132: (not C76 in ( dom D13 ));
L133: C76 in ( dom D12 ) by L132 , L124 , XBOOLE_0:def 3;
L134: ( D12 . C76 ) in ( ( Subtrees C72 ) * ) by L133 , L120 , FUNCT_2:5;
reconsider D17 = ( D12 . C76 ) as (FinSequence of ( Subtrees C72 )) by L134 , FINSEQ_1:def 11;
L135: D14 = ( ( D14 . ( {} ) ) -tree D15 ) by L116 , L120 , L121 , L122 , L124 , TREES_9:def 13;
L136: D14 = ( ( D14 . ( {} ) ) -tree D17 ) by L114 , L120 , L133 , TREES_9:def 13;
thus L137: ( D11 . C76 ) = ( D12 . C76 ) by L136 , L135 , TREES_4:15;
end;
thus L138: thesis by L123 , L119 , L120 , L121 , L122 , FUNCT_4:def 1;
end;
theorem
L139: (for R1 being non  empty non  void ManySortedSign holds (for R2 being  non-empty (ManySortedSet of (the carrier of R1)) holds (for B37 , B38 being non  empty (Subset of ( R1 -Terms R2 )) holds ( ( B37 \/ B38 ) -CircuitStr ) = ( ( B37 -CircuitStr ) +* ( B38 -CircuitStr ) ))))
proof
let R1 being non  empty non  void ManySortedSign;
let R2 being  non-empty (ManySortedSet of (the carrier of R1));
let C77 , C78 being non  empty (Subset of ( R1 -Terms R2 ));
set D18 = ( C77 \/ C78 );
set D19 = [: (the carrier' of R1) , { (the carrier of R1) } :];
L140: ( Subtrees D18 ) = ( ( Subtrees C77 ) \/ ( Subtrees C78 ) ) by L76;
L141: ( D19 -Subtrees D18 ) = ( ( D19 -Subtrees C77 ) \/ ( D19 -Subtrees C78 ) ) by L93;
L142: ((for B39 being (Element of C77) holds B39 is  finite) & (for B40 being (Element of C78) holds B40 is  finite));
L143: ( D19 -ImmediateSubtrees D18 ) = ( ( D19 -ImmediateSubtrees C77 ) +* ( D19 -ImmediateSubtrees C78 ) ) by L142 , L113;
L144: ( id ( D19 -Subtrees D18 ) ) = ( ( id ( D19 -Subtrees C77 ) ) +* ( id ( D19 -Subtrees C78 ) ) ) by L141 , FUNCT_4:22;
thus L145: thesis by L144 , L140 , L141 , L143 , CIRCCOMB:def 2;
end;
theorem
L146: (for R1 being non  empty non  void ManySortedSign holds (for R2 being  non-empty (ManySortedSet of (the carrier of R1)) holds (for R4 being non  empty (Subset of ( R1 -Terms R2 )) holds (for B41 being set holds (B41 in ( InputVertices ( R4 -CircuitStr ) ) iff (B41 in ( Subtrees R4 ) & (ex B42 being (SortSymbol of R1) st (ex B43 being (Element of ( R2 . B42 )) st B41 = ( root-tree [ B43 , B42 ] )))))))))
proof
let R1 being non  empty non  void ManySortedSign;
let R2 being  non-empty (ManySortedSet of (the carrier of R1));
let R4 being non  empty (Subset of ( R1 -Terms R2 ));
set D20 = ( R4 -CircuitStr );
L147: ( rng (the ResultSort of D20) ) = (the carrier' of D20) by RELAT_1:45;
let C79 being set;
thus L148:now
assume L149: C79 in ( InputVertices ( R4 -CircuitStr ) );
L150: (not C79 in (the carrier' of D20)) by L149 , L147 , XBOOLE_0:def 5;
thus L151: C79 in ( Subtrees R4 ) by L149;
reconsider D21 = C79 as (Term of R1 , R2) by L149 , L30;
L152: ((ex B44 being (SortSymbol of R1) st (ex B45 being (Element of ( R2 . B44 )) st ( D21 . ( {} ) ) = [ B45 , B44 ])) or ( D21 . ( {} ) ) in [: (the carrier' of R1) , { (the carrier of R1) } :]) by MSATERM:2;
L153: ((ex B46 being (SortSymbol of R1) st (ex B47 being (Element of ( R2 . B46 )) st ( D21 . ( {} ) ) = [ B47 , B46 ])) or D21 is (CompoundTerm of R1 , R2)) by L152 , MSATERM:def 6;
consider C80 being (SortSymbol of R1), C81 being (Element of ( R2 . C80 )) such that L154: ( D21 . ( {} ) ) = [ C81 , C80 ] by L153 , L149 , L150 , L42;
take D22 = C80;
reconsider D23 = C81 as (Element of ( R2 . D22 ));
take D24 = D23;
thus L155: C79 = ( root-tree [ D24 , D22 ] ) by L154 , MSATERM:5;
end;
assume L156: C79 in ( Subtrees R4 );
given C82 being (SortSymbol of R1) , C83 being (Element of ( R2 . C82 )) such that
L157: C79 = ( root-tree [ C83 , C82 ] );

assume L158: (not thesis);
L159: C79 in (the carrier' of D20) by L158 , L147 , L156 , XBOOLE_0:def 5;
reconsider D25 = C79 as (CompoundTerm of R1 , R2) by L159 , L30;
L160: ( D25 . ( {} ) ) = [ C83 , C82 ] by L157 , TREES_4:3;
L161: [ C83 , C82 ] in [: (the carrier' of R1) , { (the carrier of R1) } :] by L160 , MSATERM:def 6;
L162: C82 = (the carrier of R1) by L161 , ZFMISC_1:106;
L163: C82 in C82 by L162;
thus L164: contradiction by L163;
end;
theorem
L165: (for R1 being non  empty non  void ManySortedSign holds (for R2 being  non-empty (ManySortedSet of (the carrier of R1)) holds (for B48 being (SetWithCompoundTerm of R1 , R2) holds (for B49 being (Gate of ( B48 -CircuitStr )) holds B49 = ( ( B49 . ( {} ) ) -tree ( the_arity_of B49 ) )))))
proof
let R1 being non  empty non  void ManySortedSign;
let R2 being  non-empty (ManySortedSet of (the carrier of R1));
let C84 being (SetWithCompoundTerm of R1 , R2);
let C85 being (Gate of ( C84 -CircuitStr ));
L166: (for B50 being (Element of C84) holds B50 is  finite);
thus L167: thesis by L166 , TREES_9:def 13;
end;
begin
definition
let C86 being non  empty non  void ManySortedSign;
let C87 being  non-empty (ManySortedSet of (the carrier of C86));
let C88 being non  empty (Subset of ( C86 -Terms C87 ));
let C89 being (Vertex of ( C88 -CircuitStr ));
let C90 being MSAlgebra over C86;
func the_sort_of (C89 , C90) means 
:L168: (for B51 being (Term of C86 , C87) holds (B51 = C89 implies it = ( (the Sorts of C90) . ( the_sort_of B51 ) )));
uniqueness
proof
let C91 , C92 being set;
reconsider D26 = C89 as (Term of C86 , C87) by L30;
assume L169: (not thesis);
L170: C91 = ( (the Sorts of C90) . ( the_sort_of D26 ) ) by L169;
thus L171: thesis by L170 , L169;
end;
existence
proof
reconsider D27 = C89 as (Term of C86 , C87) by L30;
take ( (the Sorts of C90) . ( the_sort_of D27 ) );
thus L172: thesis;
end;
end;
registration
let C93 being non  empty non  void ManySortedSign;
let C94 being  non-empty (ManySortedSet of (the carrier of C93));
let C95 being non  empty (Subset of ( C93 -Terms C94 ));
let C96 being (Vertex of ( C95 -CircuitStr ));
let C97 being  non-empty MSAlgebra over C93;
cluster ( the_sort_of (C96 , C97) ) -> non  empty;
coherence
proof
reconsider D28 = C96 as (Term of C93 , C94) by L30;
L174: ( the_sort_of (C96 , C97) ) = ( (the Sorts of C97) . ( the_sort_of D28 ) ) by L168;
thus L175: thesis by L174;
end;
end;
definition
let C98 being non  empty non  void ManySortedSign;
let C99 being  non-empty (ManySortedSet of (the carrier of C98));
let C100 being non  empty (Subset of ( C98 -Terms C99 ));
assume L177: C100 is (SetWithCompoundTerm of C98 , C99);
let C101 being (Gate of ( C100 -CircuitStr ));
let C102 being MSAlgebra over C98;
func the_action_of (C101 , C102) -> Function means 
:L178: (for B52 being (SetWithCompoundTerm of C98 , C99) holds (B52 = C100 implies (for B53 being (Gate of ( B52 -CircuitStr )) holds (B53 = C101 implies it = ( (the Charact of C102) . ( ( B53 . ( {} ) ) `1 ) )))));
uniqueness
proof
let C103 , C104 being Function;
reconsider D29 = C100 as (SetWithCompoundTerm of C98 , C99) by L177;
reconsider D30 = C101 as (Gate of ( D29 -CircuitStr ));
assume L179: (not thesis);
L180: C103 = ( (the Charact of C102) . ( ( D30 . ( {} ) ) `1 ) ) by L179;
thus L181: thesis by L180 , L179;
end;
existence
proof
reconsider D31 = C100 as (SetWithCompoundTerm of C98 , C99) by L177;
reconsider D32 = C101 as (Gate of ( D31 -CircuitStr ));
take ( (the Charact of C102) . ( ( D32 . ( {} ) ) `1 ) );
thus L182: thesis;
end;
end;
scheme MSFuncEx { F1() -> non  empty set , F2 , F3() ->  non-empty (ManySortedSet of F1()) , P1[set , set , set] } : (ex B54 being (ManySortedFunction of F2() , F3()) st (for B55 being (Element of F1()) holds (for B56 being (Element of ( F2() . B55 )) holds P1[ B55 , B56 , ( ( B54 . B55 ) . B56 ) ])))
provided
L184: (for B57 being (Element of F1()) holds (for B58 being (Element of ( F2() . B57 )) holds (ex B59 being (Element of ( F3() . B57 )) st P1[ B57 , B58 , B59 ])))
proof
defpred S2[ set , set ] means (ex B60 being (Function of ( F2() . $1 ) , ( F3() . $1 )) st ($2 = B60 & (for B61 being set holds (B61 in ( F2() . $1 ) implies P1[ $1 , B61 , ( B60 . B61 ) ]))));
L185: (for B62 being set holds (B62 in F1() implies (ex B63 being set st S2[ B62 , B63 ])))
proof
let C105 being set;
assume L186: C105 in F1();
reconsider D33 = C105 as (Element of F1()) by L186;
defpred S3[ set , set ] means P1[ D33 , $1 , $2 ];
L187: (for B64 being set holds (B64 in ( F2() . D33 ) implies (ex B65 being set st (B65 in ( F3() . D33 ) & S3[ B64 , B65 ]))))
proof
let C106 being set;
assume L188: C106 in ( F2() . D33 );
L189: (ex B66 being (Element of ( F3() . D33 )) st P1[ D33 , C106 , B66 ]) by L188 , L184;
thus L190: thesis by L189;
end;
consider C107 being Function such that L191: (( dom C107 ) = ( F2() . D33 ) & ( rng C107 ) c= ( F3() . D33 )) and L192: (for B67 being set holds (B67 in ( F2() . D33 ) implies S3[ B67 , ( C107 . B67 ) ])) from FUNCT_1:sch 5(L187);
take C107;
L193: C107 is (Function of ( F2() . D33 ) , ( F3() . D33 )) by L191 , FUNCT_2:2;
thus L194: thesis by L193 , L192;
end;
consider C108 being Function such that L195: ( dom C108 ) = F1() and L196: (for B68 being set holds (B68 in F1() implies S2[ B68 , ( C108 . B68 ) ])) from CLASSES1:sch 1(L185);
reconsider D34 = C108 as (ManySortedSet of F1()) by L195 , PARTFUN1:def 2 , RELAT_1:def 18;
L197: D34 is (ManySortedFunction of F2() , F3())
proof
let C109 being set;
assume L198: C109 in F1();
L199: (ex B69 being (Function of ( F2() . C109 ) , ( F3() . C109 )) st (( D34 . C109 ) = B69 & (for B70 being set holds (B70 in ( F2() . C109 ) implies P1[ C109 , B70 , ( B69 . B70 ) ])))) by L198 , L196;
thus L200: thesis by L199;
end;
reconsider D35 = D34 as (ManySortedFunction of F2() , F3()) by L197;
take D35;
let C110 being (Element of F1());
let C111 being (Element of ( F2() . C110 ));
L201: (ex B71 being (Function of ( F2() . C110 ) , ( F3() . C110 )) st (( D35 . C110 ) = B71 & (for B72 being set holds (B72 in ( F2() . C110 ) implies P1[ C110 , B72 , ( B71 . B72 ) ])))) by L196;
thus L202: thesis by L201;
end;
definition
let C112 being non  empty non  void ManySortedSign;
let C113 being  non-empty (ManySortedSet of (the carrier of C112));
let C114 being non  empty (Subset of ( C112 -Terms C113 ));
let C115 being MSAlgebra over C112;
func C114 -CircuitSorts C115 -> (ManySortedSet of (the carrier of ( C114 -CircuitStr ))) means 
:L203: (for B73 being (Vertex of ( C114 -CircuitStr )) holds ( it . B73 ) = ( the_sort_of (B73 , C115) ));
uniqueness
proof
let C116 , C117 being (ManySortedSet of (the carrier of ( C114 -CircuitStr )));
assume that
L204: (for B74 being (Vertex of ( C114 -CircuitStr )) holds ( C116 . B74 ) = ( the_sort_of (B74 , C115) ))
and
L205: (for B75 being (Vertex of ( C114 -CircuitStr )) holds ( C117 . B75 ) = ( the_sort_of (B75 , C115) ));
L206:
now
let C118 being set;
assume L207: C118 in (the carrier of ( C114 -CircuitStr ));
reconsider D36 = C118 as (Vertex of ( C114 -CircuitStr )) by L207;
thus L208: ( C116 . C118 ) = ( the_sort_of (D36 , C115) ) by L204
.= ( C117 . C118 ) by L205;
end;
thus L209: thesis by L206 , PBOOLE:3;
end;
existence
proof
deffunc H1((Vertex of ( C114 -CircuitStr ))) = ( the_sort_of ($1 , C115) );
thus L210: (ex B76 being (ManySortedSet of (the carrier of ( C114 -CircuitStr ))) st (for B77 being (Element of ( C114 -CircuitStr )) holds ( B76 . B77 ) = H1(B77))) from PBOOLE:sch 5;
end;
end;
registration
let C119 being non  empty non  void ManySortedSign;
let C120 being  non-empty (ManySortedSet of (the carrier of C119));
let C121 being non  empty (Subset of ( C119 -Terms C120 ));
let C122 being  non-empty MSAlgebra over C119;
cluster ( C121 -CircuitSorts C122 ) ->  non-empty;
coherence
proof
let C123 being set;
assume L212: C123 in (the carrier of ( C121 -CircuitStr ));
reconsider D37 = C123 as (Vertex of ( C121 -CircuitStr )) by L212;
L213: ( ( C121 -CircuitSorts C122 ) . D37 ) = ( the_sort_of (D37 , C122) ) by L203;
thus L214: thesis by L213;
end;
end;
theorem
L216: (for R1 being non  empty non  void ManySortedSign holds (for R2 being  non-empty (ManySortedSet of (the carrier of R1)) holds (for R3 being  non-empty MSAlgebra over R1 holds (for B78 being (SetWithCompoundTerm of R1 , R2) holds (for B79 being (Gate of ( B78 -CircuitStr )) holds (for B80 being (OperSymbol of R1) holds (( B79 . ( {} ) ) = [ B80 , (the carrier of R1) ] implies ( ( B78 -CircuitSorts R3 ) * ( the_arity_of B79 ) ) = ( (the Sorts of R3) * ( the_arity_of B80 ) ))))))))
proof
let R1 being non  empty non  void ManySortedSign;
let R2 being  non-empty (ManySortedSet of (the carrier of R1));
let R3 being  non-empty MSAlgebra over R1;
let C124 being (SetWithCompoundTerm of R1 , R2);
let C125 being (Gate of ( C124 -CircuitStr ));
set D38 = C124;
reconsider D39 = C125 as (CompoundTerm of R1 , R2) by L30;
reconsider D40 = ( the_arity_of C125 ) as (FinSequence of ( Subtrees C124 ));
L217: C125 = ( ( D39 . ( {} ) ) -tree D40 ) by L165;
let C126 being (OperSymbol of R1);
assume L218: ( C125 . ( {} ) ) = [ C126 , (the carrier of R1) ];
consider C127 being (ArgumentSeq of ( Sym (C126 , R2) )) such that L219: D39 = ( [ C126 , (the carrier of R1) ] -tree C127 ) by L218 , MSATERM:10;
L220: ( len C127 ) = ( len ( the_arity_of C126 ) ) by MSATERM:22;
L221: C127 = D40 by L217 , L219 , TREES_4:15;
L222: ( dom ( the_arity_of C126 ) ) = ( Seg ( len C127 ) ) by L220 , FINSEQ_1:def 3;
L223: ( dom ( the_arity_of C125 ) ) = ( Seg ( len C127 ) ) by L221 , FINSEQ_1:def 3;
L224: ( rng ( the_arity_of C125 ) ) c= (the carrier of ( C124 -CircuitStr )) by FINSEQ_1:def 4;
L225: ( rng ( the_arity_of C126 ) ) c= (the carrier of R1) by FINSEQ_1:def 4;
L226: ( dom ( D38 -CircuitSorts R3 ) ) = (the carrier of ( D38 -CircuitStr )) by PARTFUN1:def 2;
L227: ( dom (the Sorts of R3) ) = (the carrier of R1) by PARTFUN1:def 2;
L228: ( dom ( ( D38 -CircuitSorts R3 ) * ( the_arity_of C125 ) ) ) = ( Seg ( len C127 ) ) by L223 , L224 , L226 , RELAT_1:27;
L229: ( dom ( (the Sorts of R3) * ( the_arity_of C126 ) ) ) = ( Seg ( len C127 ) ) by L222 , L225 , L227 , RELAT_1:27;
L230:
now
let C128 being set;
assume L231: C128 in ( Seg ( len C127 ) );
reconsider D41 = C128 as (Element of ( NAT )) by L231;
L232: ( D40 . C128 ) in ( rng ( the_arity_of C125 ) ) by L223 , L231 , FUNCT_1:def 3;
reconsider D42 = ( D40 . D41 ) as (Vertex of ( C124 -CircuitStr )) by L232 , L224;
L233: ( ( the_arity_of C126 ) . C128 ) in ( rng ( the_arity_of C126 ) ) by L222 , L231 , FUNCT_1:def 3;
reconsider D43 = ( ( the_arity_of C126 ) . D41 ) as (SortSymbol of R1) by L233 , L225;
reconsider D44 = D42 as (Term of R1 , R2) by L221 , L223 , L231 , MSATERM:22;
L234: ( the_sort_of D44 ) = D43 by L221 , L223 , L231 , MSATERM:23;
L235: ( ( ( C124 -CircuitSorts R3 ) * ( the_arity_of C125 ) ) . C128 ) = ( ( C124 -CircuitSorts R3 ) . D42 ) by L228 , L231 , FUNCT_1:12;
L236: ( ( (the Sorts of R3) * ( the_arity_of C126 ) ) . C128 ) = ( (the Sorts of R3) . D43 ) by L229 , L231 , FUNCT_1:12;
thus L237: ( ( ( C124 -CircuitSorts R3 ) * ( the_arity_of C125 ) ) . C128 ) = ( the_sort_of (D42 , R3) ) by L235 , L203
.= ( ( (the Sorts of R3) * ( the_arity_of C126 ) ) . C128 ) by L234 , L236 , L168;
end;
thus L238: thesis by L230 , L228 , L229 , FUNCT_1:2;
end;
definition
let C129 being non  empty non  void ManySortedSign;
let C130 being  non-empty (ManySortedSet of (the carrier of C129));
let C131 being non  empty (Subset of ( C129 -Terms C130 ));
let C132 being  non-empty MSAlgebra over C129;
func C131 -CircuitCharact C132 -> (ManySortedFunction of ( ( ( C131 -CircuitSorts C132 ) # ) * (the Arity of ( C131 -CircuitStr )) ) , ( ( C131 -CircuitSorts C132 ) * (the ResultSort of ( C131 -CircuitStr )) )) means 
:L239: (for B81 being (Gate of ( C131 -CircuitStr )) holds (B81 in (the carrier' of ( C131 -CircuitStr )) implies ( it . B81 ) = ( the_action_of (B81 , C132) )));
uniqueness
proof
let C133 , C134 being (ManySortedFunction of ( ( ( C131 -CircuitSorts C132 ) # ) * (the Arity of ( C131 -CircuitStr )) ) , ( ( C131 -CircuitSorts C132 ) * (the ResultSort of ( C131 -CircuitStr )) ));
assume that
L240: (for B82 being (Gate of ( C131 -CircuitStr )) holds (B82 in (the carrier' of ( C131 -CircuitStr )) implies ( C133 . B82 ) = ( the_action_of (B82 , C132) )))
and
L241: (for B83 being (Gate of ( C131 -CircuitStr )) holds (B83 in (the carrier' of ( C131 -CircuitStr )) implies ( C134 . B83 ) = ( the_action_of (B83 , C132) )));
L242:
now
let C135 being set;
assume L243: C135 in (the carrier' of ( C131 -CircuitStr ));
reconsider D45 = C135 as (Gate of ( C131 -CircuitStr )) by L243;
L244: ( C133 . D45 ) = ( the_action_of (D45 , C132) ) by L240 , L243;
thus L245: ( C133 . C135 ) = ( C134 . C135 ) by L244 , L241 , L243;
end;
thus L246: thesis by L242 , PBOOLE:3;
end;
existence
proof
defpred S4[ set , set ] means (ex B84 being (Gate of ( C131 -CircuitStr )) st (B84 = $1 & $2 = ( the_action_of (B84 , C132) )));
L247:
now
let C136 being set;
assume L248: C136 in (the carrier' of ( C131 -CircuitStr ));
reconsider D46 = C136 as (Gate of ( C131 -CircuitStr )) by L248;
reconsider D47 = ( the_action_of (D46 , C132) ) as set;
take D48 = D47;
thus L249: S4[ C136 , D48 ];
end;
consider C137 being (ManySortedSet of (the carrier' of ( C131 -CircuitStr ))) such that L250: (for B85 being set holds (B85 in (the carrier' of ( C131 -CircuitStr )) implies S4[ B85 , ( C137 . B85 ) ])) from PBOOLE:sch 3(L247);
L251: ( dom C137 ) = (the carrier' of ( C131 -CircuitStr )) by PARTFUN1:def 2;
L252: C137 is  Function-yielding
proof
let C138 being set;
assume L253: C138 in ( dom C137 );
L254: (ex B86 being (Gate of ( C131 -CircuitStr )) st (B86 = C138 & ( C137 . C138 ) = ( the_action_of (B86 , C132) ))) by L253 , L250 , L251;
thus L255: thesis by L254;
end;
reconsider D49 = C137 as (ManySortedFunction of (the carrier' of ( C131 -CircuitStr ))) by L252;
L256: D49 is (ManySortedFunction of ( ( ( C131 -CircuitSorts C132 ) # ) * (the Arity of ( C131 -CircuitStr )) ) , ( ( C131 -CircuitSorts C132 ) * (the ResultSort of ( C131 -CircuitStr )) ))
proof
let C139 being set;
assume L257: C139 in (the carrier' of ( C131 -CircuitStr ));
L258: (not ( C131 -CircuitStr ) is  void) by L257;
reconsider D50 = C131 as (SetWithCompoundTerm of C129 , C130) by L258 , L19;
reconsider D51 = C139 as (Gate of ( D50 -CircuitStr )) by L257;
L259: ( the_result_sort_of D51 ) = D51 by FUNCT_1:18;
reconsider D52 = D51 as (Vertex of ( D50 -CircuitStr )) by L259;
reconsider D53 = C139 as (CompoundTerm of C129 , C130) by L257 , L30;
L260: ( D53 . ( {} ) ) in [: (the carrier' of C129) , { (the carrier of C129) } :] by MSATERM:def 6;
consider C140 , C141 being set such that L261: C140 in (the carrier' of C129) and L262: C141 in { (the carrier of C129) } and L263: ( D53 . ( {} ) ) = [ C140 , C141 ] by L260 , ZFMISC_1:84;
reconsider D54 = C140 as (OperSymbol of C129) by L261;
L264: D54 = ( ( D53 . ( {} ) ) `1 ) by L263 , MCART_1:7;
L265: C141 = (the carrier of C129) by L262 , TARSKI:def 1;
L266: (ex B87 being (Gate of ( C131 -CircuitStr )) st (B87 = C139 & ( D49 . C139 ) = ( the_action_of (B87 , C132) ))) by L250 , L257;
L267: ( D49 . C139 ) = ( the_action_of (D51 , C132) ) by L266
.= ( (the Charact of C132) . D54 ) by L264 , L178;
L268: ( ( (the Sorts of C132) * (the ResultSort of C129) ) . D54 ) = ( (the Sorts of C132) . ( the_result_sort_of D54 ) ) by FUNCT_2:15
.= ( (the Sorts of C132) . ( the_sort_of D53 ) ) by L263 , L265 , MSATERM:17;
L269: ( ( ( C131 -CircuitSorts C132 ) * (the ResultSort of ( C131 -CircuitStr )) ) . D51 ) = ( ( C131 -CircuitSorts C132 ) . ( the_result_sort_of D51 ) ) by FUNCT_2:15
.= ( the_sort_of (D52 , C132) ) by L259 , L203
.= ( (the Sorts of C132) . ( the_sort_of D53 ) ) by L168;
L270: ( ( ( ( C131 -CircuitSorts C132 ) # ) * (the Arity of ( C131 -CircuitStr )) ) . D51 ) = ( ( ( C131 -CircuitSorts C132 ) # ) . ( the_arity_of D51 ) ) by FUNCT_2:15
.= ( product ( ( D50 -CircuitSorts C132 ) * ( the_arity_of D51 ) ) ) by FINSEQ_2:def 5
.= ( product ( (the Sorts of C132) * ( the_arity_of D54 ) ) ) by L263 , L265 , L216;
L271: ( ( ( (the Sorts of C132) # ) * (the Arity of C129) ) . D54 ) = ( ( (the Sorts of C132) # ) . ( the_arity_of D54 ) ) by FUNCT_2:15
.= ( product ( (the Sorts of C132) * ( the_arity_of D54 ) ) ) by FINSEQ_2:def 5;
thus L272: thesis by L271 , L267 , L268 , L269 , L270 , PBOOLE:def 15;
end;
reconsider D55 = D49 as (ManySortedFunction of ( ( ( C131 -CircuitSorts C132 ) # ) * (the Arity of ( C131 -CircuitStr )) ) , ( ( C131 -CircuitSorts C132 ) * (the ResultSort of ( C131 -CircuitStr )) )) by L256;
take D55;
let C142 being (Gate of ( C131 -CircuitStr ));
assume L273: C142 in (the carrier' of ( C131 -CircuitStr ));
L274: (ex B88 being (Gate of ( C131 -CircuitStr )) st (B88 = C142 & ( D55 . C142 ) = ( the_action_of (B88 , C132) ))) by L273 , L250;
thus L275: thesis by L274;
end;
end;
definition
let C143 being non  empty non  void ManySortedSign;
let C144 being  non-empty (ManySortedSet of (the carrier of C143));
let C145 being non  empty (Subset of ( C143 -Terms C144 ));
let C146 being  non-empty MSAlgebra over C143;
func C145 -Circuit C146 ->  non-empty  strict MSAlgebra over ( C145 -CircuitStr ) equals 
MSAlgebra (# ( C145 -CircuitSorts C146 ) , ( C145 -CircuitCharact C146 ) #);
correctness by MSUALG_1:def 3;
end;
theorem
L278: (for R1 being non  empty non  void ManySortedSign holds (for R2 being  non-empty (ManySortedSet of (the carrier of R1)) holds (for R3 being  non-empty MSAlgebra over R1 holds (for R4 being non  empty (Subset of ( R1 -Terms R2 )) holds (for B89 being (Vertex of ( R4 -CircuitStr )) holds ( (the Sorts of ( R4 -Circuit R3 )) . B89 ) = ( the_sort_of (B89 , R3) )))))) by L203;
theorem
L279: (for R1 being non  empty non  void ManySortedSign holds (for R2 being  non-empty (ManySortedSet of (the carrier of R1)) holds (for B90 being  finite-yielding  non-empty MSAlgebra over R1 holds (for B91 being (SetWithCompoundTerm of R1 , R2) holds (for B92 being (OperSymbol of ( B91 -CircuitStr )) holds ( Den (B92 , ( B91 -Circuit B90 )) ) = ( the_action_of (B92 , B90) )))))) by L239;
theorem
L280: (for R1 being non  empty non  void ManySortedSign holds (for R2 being  non-empty (ManySortedSet of (the carrier of R1)) holds (for B93 being  finite-yielding  non-empty MSAlgebra over R1 holds (for B94 being (SetWithCompoundTerm of R1 , R2) holds (for B95 being (OperSymbol of ( B94 -CircuitStr )) holds (for B96 being (OperSymbol of R1) holds (( B95 . ( {} ) ) = [ B96 , (the carrier of R1) ] implies ( Den (B95 , ( B94 -Circuit B93 )) ) = ( Den (B96 , B93) ))))))))
proof
let R1 being non  empty non  void ManySortedSign;
let R2 being  non-empty (ManySortedSet of (the carrier of R1));
let C147 being  finite-yielding  non-empty MSAlgebra over R1;
let C148 being (SetWithCompoundTerm of R1 , R2);
let C149 being (OperSymbol of ( C148 -CircuitStr ));
let C150 being (OperSymbol of R1);
L281: ( Den (C149 , ( C148 -Circuit C147 )) ) = ( the_action_of (C149 , C147) ) by L239
.= ( (the Charact of C147) . ( ( C149 . ( {} ) ) `1 ) ) by L178;
thus L282: thesis by L281 , MCART_1:7;
end;
theorem
L283: (for R1 being non  empty non  void ManySortedSign holds (for R2 being  non-empty (ManySortedSet of (the carrier of R1)) holds (for B97 being  finite-yielding  non-empty MSAlgebra over R1 holds (for B98 being non  empty (Subset of ( R1 -Terms R2 )) holds ( B98 -Circuit B97 ) is  finite-yielding))))
proof
let R1 being non  empty non  void ManySortedSign;
let R2 being  non-empty (ManySortedSet of (the carrier of R1));
let C151 being  finite-yielding  non-empty MSAlgebra over R1;
let C152 being non  empty (Subset of ( R1 -Terms R2 ));
let C153 being set;
assume L284: C153 in (the carrier of ( C152 -CircuitStr ));
reconsider D56 = C153 as (Vertex of ( C152 -CircuitStr )) by L284;
reconsider D57 = D56 as (Term of R1 , R2) by L30;
L285: (the Sorts of C151) is  finite-yielding by MSAFREE2:def 11;
L286: ( (the Sorts of ( C152 -Circuit C151 )) . D56 ) = ( the_sort_of (D56 , C151) ) by L203
.= ( (the Sorts of C151) . ( the_sort_of D57 ) ) by L168;
thus L287: thesis by L286 , L285;
end;
registration
let C154 being non  empty non  void ManySortedSign;
let C155 being  non-empty (ManySortedSet of (the carrier of C154));
let C156 being (SetWithCompoundTerm of C154 , C155);
let C157 being  finite-yielding  non-empty MSAlgebra over C154;
cluster ( C156 -Circuit C157 ) ->  finite-yielding;
coherence by L283;
end;
theorem
L289: (for B99 being non  empty non  void ManySortedSign holds (for B100 being  non-empty (ManySortedSet of (the carrier of B99)) holds (for B101 , B102 being (SetWithCompoundTerm of B99 , B100) holds (for B103 being  non-empty MSAlgebra over B99 holds ( B101 -Circuit B103 ) tolerates ( B102 -Circuit B103 )))))
proof
let C158 being non  empty non  void ManySortedSign;
let C159 being  non-empty (ManySortedSet of (the carrier of C158));
let C160 , C161 being (SetWithCompoundTerm of C158 , C159);
let C162 being  non-empty MSAlgebra over C158;
thus L290: ((the Arity of ( C160 -CircuitStr )) tolerates (the Arity of ( C161 -CircuitStr )) & (the ResultSort of ( C160 -CircuitStr )) tolerates (the ResultSort of ( C161 -CircuitStr ))) by L56;
thus L291: (the Sorts of ( C160 -Circuit C162 )) tolerates (the Sorts of ( C161 -Circuit C162 ))
proof
let C163 being set;
assume L292: C163 in ( ( dom (the Sorts of ( C160 -Circuit C162 )) ) /\ ( dom (the Sorts of ( C161 -Circuit C162 )) ) );
L293: C163 in ( dom (the Sorts of ( C160 -Circuit C162 )) ) by L292 , XBOOLE_0:def 4;
L294: C163 in ( dom (the Sorts of ( C161 -Circuit C162 )) ) by L292 , XBOOLE_0:def 4;
L295: C163 in (the carrier of ( C160 -CircuitStr )) by L293 , PARTFUN1:def 2;
reconsider D58 = C163 as (Vertex of ( C160 -CircuitStr )) by L293 , PARTFUN1:def 2;
reconsider D59 = C163 as (Vertex of ( C161 -CircuitStr )) by L294 , PARTFUN1:def 2;
reconsider D60 = C163 as (Term of C158 , C159) by L295 , L30;
thus L296: ( (the Sorts of ( C160 -Circuit C162 )) . C163 ) = ( the_sort_of (D58 , C162) ) by L203
.= ( (the Sorts of C162) . ( the_sort_of D60 ) ) by L168
.= ( the_sort_of (D59 , C162) ) by L168
.= ( (the Sorts of ( C161 -Circuit C162 )) . C163 ) by L203;
end;

let C164 being set;
assume L297: C164 in ( ( dom (the Charact of ( C160 -Circuit C162 )) ) /\ ( dom (the Charact of ( C161 -Circuit C162 )) ) );
L298: C164 in ( dom (the Charact of ( C160 -Circuit C162 )) ) by L297 , XBOOLE_0:def 4;
L299: C164 in ( dom (the Charact of ( C161 -Circuit C162 )) ) by L297 , XBOOLE_0:def 4;
reconsider D61 = C164 as (Gate of ( C160 -CircuitStr )) by L298 , PARTFUN1:def 2;
reconsider D62 = C164 as (Gate of ( C161 -CircuitStr )) by L299 , PARTFUN1:def 2;
thus L300: ( (the Charact of ( C160 -Circuit C162 )) . C164 ) = ( the_action_of (D61 , C162) ) by L239
.= ( (the Charact of C162) . ( ( D61 . ( {} ) ) `1 ) ) by L178
.= ( the_action_of (D62 , C162) ) by L178
.= ( (the Charact of ( C161 -Circuit C162 )) . C164 ) by L239;
end;
theorem
L301: (for B104 being non  empty non  void ManySortedSign holds (for B105 being  non-empty (ManySortedSet of (the carrier of B104)) holds (for B106 , B107 being (SetWithCompoundTerm of B104 , B105) holds (for B108 being  non-empty MSAlgebra over B104 holds ( ( B106 \/ B107 ) -Circuit B108 ) = ( ( B106 -Circuit B108 ) +* ( B107 -Circuit B108 ) )))))
proof
let C165 being non  empty non  void ManySortedSign;
let C166 being  non-empty (ManySortedSet of (the carrier of C165));
let C167 , C168 being (SetWithCompoundTerm of C165 , C166);
consider C169 being (CompoundTerm of C165 , C166) such that L302: C169 in C167 by MSATERM:def 7;
L303: C169 in ( C167 \/ C168 ) by L302 , XBOOLE_0:def 3;
reconsider D63 = ( C167 \/ C168 ) as (SetWithCompoundTerm of C165 , C166) by L303 , MSATERM:def 7;
let C170 being  non-empty MSAlgebra over C165;
set D64 = ( C167 -Circuit C170 );
set D65 = ( C168 -Circuit C170 );
set D66 = ( D63 -Circuit C170 );
L304: D64 tolerates D65 by L289;
L305: (the Sorts of D64) tolerates (the Sorts of D65) by L304 , CIRCCOMB:def 3;
L306: (the Charact of D64) tolerates (the Charact of D65) by L304 , CIRCCOMB:def 3;
L307: (the Sorts of ( D64 +* D65 )) = ( (the Sorts of D64) +* (the Sorts of D65) ) by L305 , CIRCCOMB:def 4;
L308: (the Charact of ( D64 +* D65 )) = ( (the Charact of D64) +* (the Charact of D65) ) by L305 , CIRCCOMB:def 4;
L309: ( D63 -CircuitStr ) = ( ( C167 -CircuitStr ) +* ( C168 -CircuitStr ) ) by L139;
L310: D64 tolerates D66 by L289;
L311: D65 tolerates D66 by L289;
L312: (the Sorts of D64) tolerates (the Sorts of D66) by L310 , CIRCCOMB:def 3;
L313: (the Sorts of D65) tolerates (the Sorts of D66) by L311 , CIRCCOMB:def 3;
L314: (the Charact of D64) tolerates (the Charact of D66) by L310 , CIRCCOMB:def 3;
L315: (the Charact of D65) tolerates (the Charact of D66) by L311 , CIRCCOMB:def 3;
L316: ( dom (the Sorts of ( D64 +* D65 )) ) = (the carrier of ( D63 -CircuitStr )) by L309 , PARTFUN1:def 2;
L317: ( dom (the Charact of ( D64 +* D65 )) ) = (the carrier' of ( D63 -CircuitStr )) by L309 , PARTFUN1:def 2;
L318: ( dom (the Charact of ( D64 +* D65 )) ) = ( dom (the Charact of D66) ) by L317 , PARTFUN1:def 2;
L319: ( dom (the Sorts of ( D64 +* D65 )) ) = ( dom (the Sorts of D66) ) by L316 , PARTFUN1:def 2;
L320: (the Charact of ( D64 +* D65 )) = (the Charact of D66) by L306 , L308 , L314 , L315 , L318 , FUNCT_4:125 , PARTFUN1:55;
L321: (the Sorts of ( D64 +* D65 )) = (the Sorts of D66) by L305 , L307 , L312 , L313 , L319 , FUNCT_4:125 , PARTFUN1:55;
thus L322: thesis by L321 , L320;
end;
begin
definition
let C171 being non  empty non  void ManySortedSign;
let C172 being  non-empty MSAlgebra over C171;
let C173 being (Variables of C172);
let C174 being DecoratedTree;
assume that
L323: C174 is (Term of C171 , C173);
let C175 being (ManySortedFunction of C173 , (the Sorts of C172));
func C174 @ (C175 , C172) means 
:L324: (ex B109 being (c-Term of C172 , C173) st (B109 = C174 & it = ( B109 @ C175 )));
correctness
proof
reconsider D67 = C174 as (c-Term of C172 , C173) by L323 , MSATERM:27;
L325: ( D67 @ C175 ) = ( D67 @ C175 );
thus L326: thesis by L325;
end;
end;
definition
let C176 being non  empty non  void ManySortedSign;
let C177 being  non-empty (ManySortedSet of (the carrier of C176));
let C178 being (SetWithCompoundTerm of C176 , C177);
let C179 being  non-empty  finite-yielding MSAlgebra over C176;
let C180 being (State of ( C178 -Circuit C179 ));
defpred S5[ set , set , set ] means (( root-tree [ $2 , $1 ] ) in ( Subtrees C178 ) implies $3 = ( C180 . ( root-tree [ $2 , $1 ] ) ));
L328: (for B110 being (Vertex of C176) holds (for B111 being (Element of ( C177 . B110 )) holds (ex B112 being (Element of ( (the Sorts of C179) . B110 )) st S5[ B110 , B111 , B112 ])))
proof
let C181 being (Vertex of C176);
let C182 being (Element of ( C177 . C181 ));
per cases ;
suppose L329: (not ( root-tree [ C182 , C181 ] ) in ( Subtrees C178 ));

thus L330: thesis by L329;
end;
suppose L331: ( root-tree [ C182 , C181 ] ) in ( Subtrees C178 );

reconsider D68 = ( root-tree [ C182 , C181 ] ) as (Vertex of ( C178 -CircuitStr )) by L331;
reconsider D69 = D68 as (Term of C176 , C177) by MSATERM:4;
L332: ( the_sort_of D69 ) = C181 by MSATERM:14;
L333: ( the_sort_of (D68 , C179) ) = ( (the Sorts of C179) . ( the_sort_of D69 ) ) by L168;
L334: ( ( C178 -CircuitSorts C179 ) . D68 ) = ( the_sort_of (D68 , C179) ) by L203;
reconsider D70 = ( C180 . D68 ) as (Element of ( (the Sorts of C179) . C181 )) by L334 , L332 , L333 , CIRCUIT1:4;
take D70;
thus L335: thesis;
end;
end;
mode CompatibleValuation of C180
 -> (ManySortedFunction of C177 , (the Sorts of C179))
means :L337: (for B113 being (Vertex of C176) holds (for B114 being (Element of ( C177 . B113 )) holds (( root-tree [ B114 , B113 ] ) in ( Subtrees C178 ) implies ( ( it . B113 ) . B114 ) = ( C180 . ( root-tree [ B114 , B113 ] ) ))));
existence
proof
thus L338: (ex B115 being (ManySortedFunction of C177 , (the Sorts of C179)) st (for B116 being (Element of C176) holds (for B117 being (Element of ( C177 . B116 )) holds S5[ B116 , B117 , ( ( B115 . B116 ) . B117 ) ]))) from MSFuncEx(L328);
end;
end;
theorem
L340: (for R6 being non  empty non  void ManySortedSign holds (for R7 being  non-empty  finite-yielding MSAlgebra over R6 holds (for R8 being (Variables of R7) holds (for R9 being (SetWithCompoundTerm of R6 , R8) holds (for B118 being (State of ( R9 -Circuit R7 )) holds (for B119 being (CompatibleValuation of B118) holds (for B120 being (Element of ( NAT )) holds B119 is (CompatibleValuation of ( Following (B118 , B120) )))))))))
proof
let R6 being non  empty non  void ManySortedSign;
let R7 being  non-empty  finite-yielding MSAlgebra over R6;
let R8 being (Variables of R7);
let R9 being (SetWithCompoundTerm of R6 , R8);
let C183 being (State of ( R9 -Circuit R7 ));
let C184 being (CompatibleValuation of C183);
let C185 being (Element of ( NAT ));
let C186 being (Vertex of R6);
let C187 being (Element of ( R8 . C186 ));
assume L341: ( root-tree [ C187 , C186 ] ) in ( Subtrees R9 );
L342: ( root-tree [ C187 , C186 ] ) in ( InputVertices ( R9 -CircuitStr ) ) by L341 , L146;
L343: C183 is_stable_at ( root-tree [ C187 , C186 ] ) by L342 , FACIRC_1:18;
L344: ( ( Following (C183 , C185) ) . ( root-tree [ C187 , C186 ] ) ) = ( C183 . ( root-tree [ C187 , C186 ] ) ) by L343 , FACIRC_1:def 9;
thus L345: thesis by L344 , L341 , L337;
end;
registration
let C188 being set;
let C189 being non  empty non  void ManySortedSign;
let C190 being  non-empty (ManySortedSet of (the carrier of C189));
let C191 being (FinSequence of ( C189 -Terms C190 ));
cluster ( C188 -tree C191 ) ->  finite;
coherence
proof
reconsider D71 = ( doms C191 ) as  FinTree-yielding FinSequence;
L346: ( dom ( C188 -tree C191 ) ) = ( tree D71 ) by TREES_4:10;
thus L347: thesis by L346 , FINSET_1:10;
end;
end;
theorem
L349: (for R6 being non  empty non  void ManySortedSign holds (for R7 being  non-empty  finite-yielding MSAlgebra over R6 holds (for R8 being (Variables of R7) holds (for R9 being (SetWithCompoundTerm of R6 , R8) holds (for B121 being (State of ( R9 -Circuit R7 )) holds (for B122 being (CompatibleValuation of B121) holds (for B123 being (Term of R6 , R8) holds (B123 in ( Subtrees R9 ) implies (( Following (B121 , ( 1 + ( height ( dom B123 ) ) )) ) is_stable_at B123 & ( ( Following (B121 , ( 1 + ( height ( dom B123 ) ) )) ) . B123 ) = ( B123 @ (B122 , R7) ))))))))))
proof
let R6 being non  empty non  void ManySortedSign;
let R7 being  non-empty  finite-yielding MSAlgebra over R6;
let R8 being (Variables of R7);
let R9 being (SetWithCompoundTerm of R6 , R8);
let C192 being (State of ( R9 -Circuit R7 ));
let C193 being (CompatibleValuation of C192);
L350: ( R9 -CircuitStr ) = ManySortedSign (# ( Subtrees R9 ) , ( [: (the carrier' of R6) , { (the carrier of R6) } :] -Subtrees R9 ) , ( [: (the carrier' of R6) , { (the carrier of R6) } :] -ImmediateSubtrees R9 ) , ( incl ( [: (the carrier' of R6) , { (the carrier of R6) } :] -Subtrees R9 ) ) #);
defpred S6[  finite DecoratedTree ] means ($1 in ( Subtrees R9 ) implies (( Following (C192 , ( 1 + ( height ( dom $1 ) ) )) ) is_stable_at $1 & ( ( Following (C192 , ( 1 + ( height ( dom $1 ) ) )) ) . $1 ) = ( $1 @ (C193 , R7) )));
L351: (for B124 being (SortSymbol of R6) holds (for B125 being (Element of ( R8 . B124 )) holds S6[ ( root-tree [ B125 , B124 ] ) ]))
proof
let C194 being (SortSymbol of R6);
let C195 being (Element of ( R8 . C194 ));
assume L352: ( root-tree [ C195 , C194 ] ) in ( Subtrees R9 );
L353: ( root-tree [ C195 , C194 ] ) in ( InputVertices ( R9 -CircuitStr ) ) by L352 , L146;
thus L354: ( Following (C192 , ( 1 + ( height ( dom ( root-tree [ C195 , C194 ] ) ) ) )) ) is_stable_at ( root-tree [ C195 , C194 ] ) by L353 , FACIRC_1:18;
reconsider D72 = ( root-tree [ C195 , C194 ] ) as (c-Term of R7 , R8) by MSATERM:8;
L355: D72 is (Term of R6 , R8) by MSATERM:4;
L356: C192 is_stable_at ( root-tree [ C195 , C194 ] ) by L353 , FACIRC_1:18;
thus L357: ( ( Following (C192 , ( 1 + ( height ( dom ( root-tree [ C195 , C194 ] ) ) ) )) ) . ( root-tree [ C195 , C194 ] ) ) = ( C192 . ( root-tree [ C195 , C194 ] ) ) by L356 , FACIRC_1:def 9
.= ( ( C193 . C194 ) . C195 ) by L352 , L337
.= ( ( C195 -term R7 ) @ C193 ) by MSATERM:42
.= ( D72 @ C193 ) by MSATERM:def 4
.= ( ( root-tree [ C195 , C194 ] ) @ (C193 , R7) ) by L355 , L324;
end;
L358: (for B126 being (OperSymbol of R6) holds (for B127 being (ArgumentSeq of ( Sym (B126 , R8) )) holds ((for B128 being (Term of R6 , R8) holds (B128 in ( rng B127 ) implies S6[ B128 ])) implies S6[ ( [ B126 , (the carrier of R6) ] -tree B127 ) ])))
proof
let C196 being (OperSymbol of R6);
let C197 being (ArgumentSeq of ( Sym (C196 , R8) ));
assume that
L359: (for B129 being (Term of R6 , R8) holds ((B129 in ( rng C197 ) & B129 in ( Subtrees R9 )) implies (( Following (C192 , ( 1 + ( height ( dom B129 ) ) )) ) is_stable_at B129 & ( ( Following (C192 , ( 1 + ( height ( dom B129 ) ) )) ) . B129 ) = ( B129 @ (C193 , R7) ))))
and
L360: ( [ C196 , (the carrier of R6) ] -tree C197 ) in ( Subtrees R9 );
consider C198 being (Element of R9), C199 being (Node of C198) such that L361: ( [ C196 , (the carrier of R6) ] -tree C197 ) = ( C198 | C199 ) by L360 , TREES_9:19;
L362: ( <*> ( NAT ) ) in ( ( dom C198 ) | C199 ) by TREES_1:22;
L363: ( C199 ^ ( {} ) ) = C199 by FINSEQ_1:34;
L364: ( C198 . C199 ) = ( ( C198 | C199 ) . ( {} ) ) by L363 , L362 , TREES_2:def 10
.= [ C196 , (the carrier of R6) ] by L361 , TREES_4:def 4;
L365: ( C198 . C199 ) in [: (the carrier' of R6) , { (the carrier of R6) } :] by L364 , ZFMISC_1:106;
reconsider D73 = ( [ C196 , (the carrier of R6) ] -tree C197 ) as (Gate of ( R9 -CircuitStr )) by L365 , L361 , TREES_9:24;
L366: ( the_result_sort_of D73 ) = D73 by FUNCT_1:17;
L367: ( D73 . ( {} ) ) = [ C196 , (the carrier of R6) ] by TREES_4:def 4;
L368: D73 = ( ( D73 . ( {} ) ) -tree ( the_arity_of D73 ) ) by L165;
L369: ( the_arity_of D73 ) = C197 by L368 , TREES_4:15;
L370: ( rng ( the_arity_of D73 ) ) c= ( Subtrees R9 ) by FINSEQ_1:def 4;
L371: ( dom ( [ C196 , (the carrier of R6) ] -tree C197 ) ) = ( tree ( doms C197 ) ) by TREES_4:10;
L372:
now
let C200 being set;
assume L373: C200 in ( rng ( the_arity_of D73 ) );
reconsider D74 = C200 as (Element of ( Subtrees R9 )) by L373 , L370;
reconsider D75 = D74 as (Term of R6 , R8) by L350 , L30;
consider C201 being set such that L374: C201 in ( dom C197 ) and L375: D75 = ( C197 . C201 ) by L369 , L373 , FUNCT_1:def 3;
L376: C201 in ( dom ( doms C197 ) ) by L374 , L375 , FUNCT_6:22;
L377: ( ( doms C197 ) . C201 ) = ( dom D75 ) by L374 , L375 , FUNCT_6:22;
L378: ( dom D75 ) in ( rng ( doms C197 ) ) by L377 , L376 , FUNCT_1:def 3;
L379: ( height ( dom D75 ) ) < ( height ( tree ( doms C197 ) ) ) by L378 , TREES_3:78;
L380: ( 1 + ( height ( dom D75 ) ) ) <= ( height ( tree ( doms C197 ) ) ) by L379 , NAT_1:13;
consider C202 being Nat such that L381: ( height ( tree ( doms C197 ) ) ) = ( ( 1 + ( height ( dom D75 ) ) ) + C202 ) by L380 , NAT_1:10;
reconsider D76 = C202 as (Element of ( NAT )) by ORDINAL1:def 12;
L382: ( Following (C192 , ( height ( dom ( [ C196 , (the carrier of R6) ] -tree C197 ) ) )) ) = ( Following (( Following (C192 , ( 1 + ( height ( dom D75 ) ) )) ) , D76) ) by L371 , L381 , FACIRC_1:13;
thus L383: ( Following (C192 , ( height ( dom ( [ C196 , (the carrier of R6) ] -tree C197 ) ) )) ) is_stable_at C200 by L382 , L359 , L369 , L373 , FACIRC_1:17;
end;
L384: ( Following ( Following (C192 , ( height ( dom ( [ C196 , (the carrier of R6) ] -tree C197 ) ) )) ) ) is_stable_at ( [ C196 , (the carrier of R6) ] -tree C197 ) by L372 , L366 , FACIRC_1:19;
thus L385: ( Following (C192 , ( 1 + ( height ( dom ( [ C196 , (the carrier of R6) ] -tree C197 ) ) ) )) ) is_stable_at ( [ C196 , (the carrier of R6) ] -tree C197 ) by L384 , FACIRC_1:12;
reconsider D77 = ( ( Sym (C196 , R8) ) -tree C197 ) as (c-Term of R7 , R8) by MSATERM:27;
L386: ( Sym (C196 , ( (the Sorts of R7) \/ R8 )) ) = [ C196 , (the carrier of R6) ] by MSAFREE:def 9;
L387: ( Sym (C196 , R8) ) = [ C196 , (the carrier of R6) ] by MSAFREE:def 9;
L388: D77 = ( [ C196 , (the carrier of R6) ] -tree C197 ) by MSAFREE:def 9;
deffunc H2(set) = ( ( Following (C192 , ( height ( dom D77 ) )) ) . ( C197 . $1 ) );
consider C203 being FinSequence such that L389: ( len C203 ) = ( len C197 ) and L390: (for B130 being Nat holds (B130 in ( dom C203 ) implies ( C203 . B130 ) = H2(B130))) from FINSEQ_1:sch 2;
L391: ( dom C203 ) = ( Seg ( len C197 ) ) by L389 , FINSEQ_1:def 3;
L392: ( dom C197 ) = ( Seg ( len C197 ) ) by FINSEQ_1:def 3;
L393: ( dom C197 ) = ( dom ( the_arity_of C196 ) ) by MSATERM:22;
L394:
now
let C204 being Nat;
assume L395: C204 in ( dom C197 );
reconsider D78 = ( C197 . C204 ) as (Term of R6 , R8) by L395 , MSATERM:22;
reconsider D79 = D78 as (c-Term of R7 , R8) by MSATERM:27;
take D80 = D79;
L396: ( the_sort_of D78 ) = ( the_sort_of D80 ) by L1;
thus L397: (D80 = ( C197 . C204 ) & ( the_sort_of D80 ) = ( ( the_arity_of C196 ) . C204 )) by L396 , L395 , MSATERM:23;
end;
reconsider D81 = C197 as (ArgumentSeq of C196 , R7 , R8) by L394 , L393 , MSATERM:24;
L398:
now
let C205 being Nat;
assume L399: C205 in ( dom C197 );
let C206 being (c-Term of R7 , R8);
assume L400: C206 = ( C197 . C205 );
L401: C206 in ( rng C197 ) by L400 , L399 , FUNCT_1:def 3;
reconsider D82 = C206 as (Element of ( Subtrees R9 )) by L401 , L369 , L370;
reconsider D83 = D82 as (Term of R6 , R8) by L350 , L30;
L402: ( Following (C192 , ( 1 + ( height ( dom C206 ) ) )) ) is_stable_at D83 by L359 , L401;
L403: ( ( Following (C192 , ( 1 + ( height ( dom C206 ) ) )) ) . D83 ) = ( D83 @ (C193 , R7) ) by L359 , L401;
L404: ( C203 . C205 ) = ( ( Following (C192 , ( height ( dom ( [ C196 , (the carrier of R6) ] -tree C197 ) ) )) ) . C206 ) by L388 , L390 , L391 , L392 , L399 , L400;
L405: C205 in ( dom ( doms C197 ) ) by L399 , L400 , FUNCT_6:22;
L406: ( ( doms C197 ) . C205 ) = ( dom C206 ) by L399 , L400 , FUNCT_6:22;
L407: ( dom C206 ) in ( rng ( doms C197 ) ) by L406 , L405 , FUNCT_1:def 3;
L408: ( height ( dom C206 ) ) < ( height ( tree ( doms C197 ) ) ) by L407 , TREES_3:78;
L409: ( 1 + ( height ( dom C206 ) ) ) <= ( height ( tree ( doms C197 ) ) ) by L408 , NAT_1:13;
consider C207 being Nat such that L410: ( height ( tree ( doms C197 ) ) ) = ( ( 1 + ( height ( dom C206 ) ) ) + C207 ) by L409 , NAT_1:10;
reconsider D84 = C207 as (Element of ( NAT )) by ORDINAL1:def 12;
L411: ( Following (C192 , ( height ( dom ( [ C196 , (the carrier of R6) ] -tree C197 ) ) )) ) = ( Following (( Following (C192 , ( 1 + ( height ( dom C206 ) ) )) ) , D84) ) by L371 , L410 , FACIRC_1:13;
L412: ( ( Following (C192 , ( height ( dom ( [ C196 , (the carrier of R6) ] -tree C197 ) ) )) ) . C206 ) = ( ( Following (C192 , ( 1 + ( height ( dom C206 ) ) )) ) . C206 ) by L411 , L402 , FACIRC_1:def 9;
thus L413: ( C203 . C205 ) = ( C206 @ C193 ) by L412 , L403 , L404 , L324;
end;
L414: ( (( ( Sym (C196 , ( (the Sorts of R7) \/ R8 )) ) -tree D81 ) qua (c-Term of R7 , R8)) @ C193 ) = ( ( Den (C196 , R7) ) . C203 ) by L398 , L389 , MSATERM:43;
L415:
now
L416: ( rng C197 ) c= (the carrier of ( R9 -CircuitStr )) by L369 , FINSEQ_1:def 4;
L417: ( dom ( Following (C192 , ( height ( dom D77 ) )) ) ) = (the carrier of ( R9 -CircuitStr )) by CIRCUIT1:3;
thus L418: ( dom ( ( Following (C192 , ( height ( dom D77 ) )) ) * C197 ) ) = ( dom C197 ) by L417 , L416 , RELAT_1:27;
let C208 being set;
assume L419: C208 in ( Seg ( len C197 ) );
reconsider D85 = C208 as (Element of ( NAT )) by L419;
L420: ( C203 . D85 ) = ( ( Following (C192 , ( height ( dom D77 ) )) ) . ( C197 . D85 ) ) by L390 , L391 , L419;
thus L421: ( C203 . C208 ) = ( ( ( Following (C192 , ( height ( dom D77 ) )) ) * C197 ) . C208 ) by L420 , L392 , L419 , FUNCT_1:13;
end;
L422: C203 = ( ( Following (C192 , ( height ( dom D77 ) )) ) * ( the_arity_of D73 ) ) by L415 , L369 , L391 , L392 , FUNCT_1:2;
L423: ( Den (D73 , ( R9 -Circuit R7 )) ) = ( Den (C196 , R7) ) by L367 , L280;
L424: ( ( Den (C196 , R7) ) . C203 ) = ( ( Following ( Following (C192 , ( height ( dom D77 ) )) ) ) . D77 ) by L423 , L366 , L388 , L422 , FACIRC_1:10;
thus L425: ( ( Following (C192 , ( 1 + ( height ( dom ( [ C196 , (the carrier of R6) ] -tree C197 ) ) ) )) ) . ( [ C196 , (the carrier of R6) ] -tree C197 ) ) = ( D77 @ C193 ) by L424 , L386 , L387 , L414 , FACIRC_1:12
.= ( ( [ C196 , (the carrier of R6) ] -tree C197 ) @ (C193 , R7) ) by L387 , L324;
end;
thus L426: (for B131 being (Term of R6 , R8) holds S6[ B131 ]) from MSATERM:sch 1(L351 , L358);
end;
theorem
L427: (for R6 being non  empty non  void ManySortedSign holds (for R7 being  non-empty  finite-yielding MSAlgebra over R6 holds (for R8 being (Variables of R7) holds (for R9 being (SetWithCompoundTerm of R6 , R8) holds ((not (ex B132 being (Term of R6 , R8) st (ex B133 being (OperSymbol of R6) st (B132 in ( Subtrees R9 ) & ( B132 . ( {} ) ) = [ B133 , (the carrier of R6) ] & ( the_arity_of B133 ) = ( {} ))))) implies (for B134 being (State of ( R9 -Circuit R7 )) holds (for B135 being (CompatibleValuation of B134) holds (for B136 being (Term of R6 , R8) holds (B136 in ( Subtrees R9 ) implies (( Following (B134 , ( height ( dom B136 ) )) ) is_stable_at B136 & ( ( Following (B134 , ( height ( dom B136 ) )) ) . B136 ) = ( B136 @ (B135 , R7) )))))))))))
proof
let R6 being non  empty non  void ManySortedSign;
let R7 being  non-empty  finite-yielding MSAlgebra over R6;
let R8 being (Variables of R7);
let R9 being (SetWithCompoundTerm of R6 , R8);
assume L428: (not (ex B137 being (Term of R6 , R8) st (ex B138 being (OperSymbol of R6) st (B137 in ( Subtrees R9 ) & ( B137 . ( {} ) ) = [ B138 , (the carrier of R6) ] & ( the_arity_of B138 ) = ( {} )))));
let C209 being (State of ( R9 -Circuit R7 ));
let C210 being (CompatibleValuation of C209);
L429: ( R9 -CircuitStr ) = ManySortedSign (# ( Subtrees R9 ) , ( [: (the carrier' of R6) , { (the carrier of R6) } :] -Subtrees R9 ) , ( [: (the carrier' of R6) , { (the carrier of R6) } :] -ImmediateSubtrees R9 ) , ( incl ( [: (the carrier' of R6) , { (the carrier of R6) } :] -Subtrees R9 ) ) #);
defpred S7[  finite DecoratedTree ] means ($1 in ( Subtrees R9 ) implies (( Following (C209 , ( height ( dom $1 ) )) ) is_stable_at $1 & ( ( Following (C209 , ( height ( dom $1 ) )) ) . $1 ) = ( $1 @ (C210 , R7) )));
L430: (for B139 being (SortSymbol of R6) holds (for B140 being (Element of ( R8 . B139 )) holds S7[ ( root-tree [ B140 , B139 ] ) ]))
proof
let C211 being (SortSymbol of R6);
let C212 being (Element of ( R8 . C211 ));
assume L431: ( root-tree [ C212 , C211 ] ) in ( Subtrees R9 );
L432: ( root-tree [ C212 , C211 ] ) in ( InputVertices ( R9 -CircuitStr ) ) by L431 , L146;
thus L433: ( Following (C209 , ( height ( dom ( root-tree [ C212 , C211 ] ) ) )) ) is_stable_at ( root-tree [ C212 , C211 ] ) by L432 , FACIRC_1:18;
reconsider D86 = ( root-tree [ C212 , C211 ] ) as (c-Term of R7 , R8) by MSATERM:8;
L434: D86 is (Term of R6 , R8) by MSATERM:4;
L435: ( dom ( root-tree [ C212 , C211 ] ) ) = ( elementary_tree ( 0 ) ) by TREES_4:3;
thus L436: ( ( Following (C209 , ( height ( dom ( root-tree [ C212 , C211 ] ) ) )) ) . ( root-tree [ C212 , C211 ] ) ) = ( C209 . ( root-tree [ C212 , C211 ] ) ) by L435 , FACIRC_1:11 , TREES_1:42
.= ( ( C210 . C211 ) . C212 ) by L431 , L337
.= ( ( C212 -term R7 ) @ C210 ) by MSATERM:42
.= ( D86 @ C210 ) by MSATERM:def 4
.= ( ( root-tree [ C212 , C211 ] ) @ (C210 , R7) ) by L434 , L324;
end;
L437: (for B141 being (OperSymbol of R6) holds (for B142 being (ArgumentSeq of ( Sym (B141 , R8) )) holds ((for B143 being (Term of R6 , R8) holds (B143 in ( rng B142 ) implies S7[ B143 ])) implies S7[ ( [ B141 , (the carrier of R6) ] -tree B142 ) ])))
proof
let C213 being (OperSymbol of R6);
let C214 being (ArgumentSeq of ( Sym (C213 , R8) ));
assume that
L438: (for B144 being (Term of R6 , R8) holds ((B144 in ( rng C214 ) & B144 in ( Subtrees R9 )) implies (( Following (C209 , ( height ( dom B144 ) )) ) is_stable_at B144 & ( ( Following (C209 , ( height ( dom B144 ) )) ) . B144 ) = ( B144 @ (C210 , R7) ))))
and
L439: ( [ C213 , (the carrier of R6) ] -tree C214 ) in ( Subtrees R9 );
consider C215 being (Element of R9), C216 being (Node of C215) such that L440: ( [ C213 , (the carrier of R6) ] -tree C214 ) = ( C215 | C216 ) by L439 , TREES_9:19;
L441: ( <*> ( NAT ) ) in ( ( dom C215 ) | C216 ) by TREES_1:22;
L442: ( C216 ^ ( {} ) ) = C216 by FINSEQ_1:34;
L443: ( C215 . C216 ) = ( ( C215 | C216 ) . ( {} ) ) by L442 , L441 , TREES_2:def 10
.= [ C213 , (the carrier of R6) ] by L440 , TREES_4:def 4;
L444: ( C215 . C216 ) in [: (the carrier' of R6) , { (the carrier of R6) } :] by L443 , ZFMISC_1:106;
reconsider D87 = ( [ C213 , (the carrier of R6) ] -tree C214 ) as (Gate of ( R9 -CircuitStr )) by L444 , L440 , TREES_9:24;
L445: ( the_result_sort_of D87 ) = D87 by FUNCT_1:17;
L446: ( D87 . ( {} ) ) = [ C213 , (the carrier of R6) ] by TREES_4:def 4;
L447: D87 = ( ( D87 . ( {} ) ) -tree ( the_arity_of D87 ) ) by L165;
L448: ( the_arity_of D87 ) = C214 by L447 , TREES_4:15;
L449: ( rng ( the_arity_of D87 ) ) c= ( Subtrees R9 ) by FINSEQ_1:def 4;
L450: ( dom ( [ C213 , (the carrier of R6) ] -tree C214 ) ) = ( tree ( doms C214 ) ) by TREES_4:10;
L451:
now
assume L452: ( height ( dom ( [ C213 , (the carrier of R6) ] -tree C214 ) ) ) = ( 0 );
L453: ( [ C213 , (the carrier of R6) ] -tree C214 ) = ( root-tree [ C213 , (the carrier of R6) ] ) by L452 , L446 , TREES_1:43 , TREES_4:5;
L454: C214 = ( {} ) by L453 , TREES_4:17;
L455: ( len C214 ) = ( 0 ) by L454;
L456: ( len ( the_arity_of C213 ) ) = ( 0 ) by L455 , MSATERM:22;
L457: ( the_arity_of C213 ) = ( {} ) by L456;
L458: D87 is (Term of R6 , R8) by L30;
thus L459: contradiction by L458 , L428 , L439 , L446 , L457;
end;
consider C217 being Nat such that L460: ( height ( dom ( [ C213 , (the carrier of R6) ] -tree C214 ) ) ) = ( C217 + 1 ) by L451 , NAT_1:6;
reconsider D88 = C217 as (Element of ( NAT )) by ORDINAL1:def 12;
L461:
now
let C218 being set;
assume L462: C218 in ( rng ( the_arity_of D87 ) );
reconsider D89 = C218 as (Element of ( Subtrees R9 )) by L462 , L449;
reconsider D90 = D89 as (Term of R6 , R8) by L429 , L30;
consider C219 being set such that L463: C219 in ( dom C214 ) and L464: D90 = ( C214 . C219 ) by L448 , L462 , FUNCT_1:def 3;
L465: C219 in ( dom ( doms C214 ) ) by L463 , L464 , FUNCT_6:22;
L466: ( ( doms C214 ) . C219 ) = ( dom D90 ) by L463 , L464 , FUNCT_6:22;
L467: ( dom D90 ) in ( rng ( doms C214 ) ) by L466 , L465 , FUNCT_1:def 3;
L468: ( height ( dom D90 ) ) < ( height ( tree ( doms C214 ) ) ) by L467 , TREES_3:78;
L469: ( height ( dom D90 ) ) <= D88 by L468 , L450 , L460 , NAT_1:13;
consider C220 being Nat such that L470: D88 = ( ( height ( dom D90 ) ) + C220 ) by L469 , NAT_1:10;
reconsider D91 = C220 as (Element of ( NAT )) by ORDINAL1:def 12;
L471: ( Following (C209 , D88) ) = ( Following (( Following (C209 , ( height ( dom D90 ) )) ) , D91) ) by L470 , FACIRC_1:13;
thus L472: ( Following (C209 , D88) ) is_stable_at C218 by L471 , L438 , L448 , L462 , FACIRC_1:17;
end;
L473: ( Following ( Following (C209 , D88) ) ) is_stable_at ( [ C213 , (the carrier of R6) ] -tree C214 ) by L461 , L445 , FACIRC_1:19;
thus L474: ( Following (C209 , ( height ( dom ( [ C213 , (the carrier of R6) ] -tree C214 ) ) )) ) is_stable_at ( [ C213 , (the carrier of R6) ] -tree C214 ) by L473 , L460 , FACIRC_1:12;
reconsider D92 = ( ( Sym (C213 , R8) ) -tree C214 ) as (c-Term of R7 , R8) by MSATERM:27;
L475: ( Sym (C213 , ( (the Sorts of R7) \/ R8 )) ) = [ C213 , (the carrier of R6) ] by MSAFREE:def 9;
L476: ( Sym (C213 , R8) ) = [ C213 , (the carrier of R6) ] by MSAFREE:def 9;
L477: D92 = ( [ C213 , (the carrier of R6) ] -tree C214 ) by MSAFREE:def 9;
deffunc H3(set) = ( ( Following (C209 , D88) ) . ( C214 . $1 ) );
consider C221 being FinSequence such that L478: ( len C221 ) = ( len C214 ) and L479: (for B145 being Nat holds (B145 in ( dom C221 ) implies ( C221 . B145 ) = H3(B145))) from FINSEQ_1:sch 2;
L480: ( dom C221 ) = ( Seg ( len C214 ) ) by L478 , FINSEQ_1:def 3;
L481: ( dom C214 ) = ( Seg ( len C214 ) ) by FINSEQ_1:def 3;
L482: ( dom C214 ) = ( dom ( the_arity_of C213 ) ) by MSATERM:22;
L483:
now
let C222 being Nat;
assume L484: C222 in ( dom C214 );
reconsider D93 = ( C214 . C222 ) as (Term of R6 , R8) by L484 , MSATERM:22;
reconsider D94 = D93 as (c-Term of R7 , R8) by MSATERM:27;
take D95 = D94;
L485: ( the_sort_of D93 ) = ( the_sort_of D95 ) by L1;
thus L486: (D95 = ( C214 . C222 ) & ( the_sort_of D95 ) = ( ( the_arity_of C213 ) . C222 )) by L485 , L484 , MSATERM:23;
end;
reconsider D96 = C214 as (ArgumentSeq of C213 , R7 , R8) by L483 , L482 , MSATERM:24;
L487:
now
let C223 being Nat;
assume L488: C223 in ( dom C214 );
let C224 being (c-Term of R7 , R8);
assume L489: C224 = ( C214 . C223 );
L490: C224 in ( rng C214 ) by L489 , L488 , FUNCT_1:def 3;
reconsider D97 = C224 as (Element of ( Subtrees R9 )) by L490 , L448 , L449;
reconsider D98 = D97 as (Term of R6 , R8) by L429 , L30;
L491: ( Following (C209 , ( height ( dom C224 ) )) ) is_stable_at D98 by L438 , L490;
L492: ( ( Following (C209 , ( height ( dom C224 ) )) ) . D98 ) = ( D98 @ (C210 , R7) ) by L438 , L490;
L493: ( C221 . C223 ) = ( ( Following (C209 , D88) ) . C224 ) by L479 , L480 , L481 , L488 , L489;
L494: C223 in ( dom ( doms C214 ) ) by L488 , L489 , FUNCT_6:22;
L495: ( ( doms C214 ) . C223 ) = ( dom C224 ) by L488 , L489 , FUNCT_6:22;
L496: ( dom C224 ) in ( rng ( doms C214 ) ) by L495 , L494 , FUNCT_1:def 3;
L497: ( height ( dom C224 ) ) < ( height ( tree ( doms C214 ) ) ) by L496 , TREES_3:78;
L498: ( height ( dom C224 ) ) <= D88 by L497 , L450 , L460 , NAT_1:13;
consider C225 being Nat such that L499: D88 = ( ( height ( dom C224 ) ) + C225 ) by L498 , NAT_1:10;
reconsider D99 = C225 as (Element of ( NAT )) by ORDINAL1:def 12;
L500: ( Following (C209 , D88) ) = ( Following (( Following (C209 , ( height ( dom C224 ) )) ) , D99) ) by L499 , FACIRC_1:13;
L501: ( ( Following (C209 , D88) ) . C224 ) = ( ( Following (C209 , ( height ( dom C224 ) )) ) . C224 ) by L500 , L491 , FACIRC_1:def 9;
thus L502: ( C221 . C223 ) = ( C224 @ C210 ) by L501 , L492 , L493 , L324;
end;
L503: ( (( ( Sym (C213 , ( (the Sorts of R7) \/ R8 )) ) -tree D96 ) qua (c-Term of R7 , R8)) @ C210 ) = ( ( Den (C213 , R7) ) . C221 ) by L487 , L478 , MSATERM:43;
L504:
now
L505: ( rng C214 ) c= (the carrier of ( R9 -CircuitStr )) by L448 , FINSEQ_1:def 4;
L506: ( dom ( Following (C209 , D88) ) ) = (the carrier of ( R9 -CircuitStr )) by CIRCUIT1:3;
thus L507: ( dom ( ( Following (C209 , D88) ) * C214 ) ) = ( dom C214 ) by L506 , L505 , RELAT_1:27;
let C226 being set;
assume L508: C226 in ( Seg ( len C214 ) );
reconsider D100 = C226 as (Element of ( NAT )) by L508;
L509: ( C221 . D100 ) = ( ( Following (C209 , D88) ) . ( C214 . D100 ) ) by L479 , L480 , L508;
thus L510: ( C221 . C226 ) = ( ( ( Following (C209 , D88) ) * C214 ) . C226 ) by L509 , L481 , L508 , FUNCT_1:13;
end;
L511: C221 = ( ( Following (C209 , D88) ) * ( the_arity_of D87 ) ) by L504 , L448 , L480 , L481 , FUNCT_1:2;
L512: ( Den (D87 , ( R9 -Circuit R7 )) ) = ( Den (C213 , R7) ) by L446 , L280;
L513: ( ( Den (C213 , R7) ) . C221 ) = ( ( Following ( Following (C209 , D88) ) ) . D92 ) by L512 , L445 , L477 , L511 , FACIRC_1:10;
thus L514: ( ( Following (C209 , ( height ( dom ( [ C213 , (the carrier of R6) ] -tree C214 ) ) )) ) . ( [ C213 , (the carrier of R6) ] -tree C214 ) ) = ( D92 @ C210 ) by L513 , L460 , L475 , L476 , L503 , FACIRC_1:12
.= ( ( [ C213 , (the carrier of R6) ] -tree C214 ) @ (C210 , R7) ) by L476 , L324;
end;
thus L515: (for B146 being (Term of R6 , R8) holds S7[ B146 ]) from MSATERM:sch 1(L430 , L437);
end;
begin
definition
let C227 , C228 being non  empty ManySortedSign;
let C229 , C230 being Function;
pred C227 , C228 are_equivalent_wrt C229 , C230
means
:L516: (C229 is  one-to-one & C230 is  one-to-one & C229 , C230 form_morphism_between C227 , C228 & ( C229 " ) , ( C230 " ) form_morphism_between C228 , C227)
;end;
theorem
L518: (for B147 , B148 being non  empty ManySortedSign holds (for B149 , B150 being Function holds (B147 , B148 are_equivalent_wrt B149 , B150 implies ((the carrier of B148) = ( B149 .: (the carrier of B147) ) & (the carrier' of B148) = ( B150 .: (the carrier' of B147) )))))
proof
let C231 , C232 being non  empty ManySortedSign;
let C233 , C234 being Function;
assume that
L519: C233 is  one-to-one
and
L520: C234 is  one-to-one
and
L521: C233 , C234 form_morphism_between C231 , C232
and
L522: ( C233 " ) , ( C234 " ) form_morphism_between C232 , C231;
thus L523: (the carrier of C232) = ( dom ( C233 " ) ) by L522 , PUA2MSS1:def 12
.= ( rng C233 ) by L519 , FUNCT_1:33
.= ( C233 .: ( dom C233 ) ) by RELAT_1:113
.= ( C233 .: (the carrier of C231) ) by L521 , PUA2MSS1:def 12;
thus L524: (the carrier' of C232) = ( dom ( C234 " ) ) by L522 , PUA2MSS1:def 12
.= ( rng C234 ) by L520 , FUNCT_1:33
.= ( C234 .: ( dom C234 ) ) by RELAT_1:113
.= ( C234 .: (the carrier' of C231) ) by L521 , PUA2MSS1:def 12;
end;
theorem
L525: (for B151 , B152 being non  empty ManySortedSign holds (for B153 , B154 being Function holds (B151 , B152 are_equivalent_wrt B153 , B154 implies (( rng B153 ) = (the carrier of B152) & ( rng B154 ) = (the carrier' of B152)))))
proof
let C235 , C236 being non  empty ManySortedSign;
let C237 , C238 being Function;
assume that
L526: C237 is  one-to-one
and
L527: C238 is  one-to-one
and
L528: C237 , C238 form_morphism_between C235 , C236
and
L529: ( C237 " ) , ( C238 " ) form_morphism_between C236 , C235;
thus L530: ( rng C237 ) = ( dom ( C237 " ) ) by L526 , FUNCT_1:33
.= (the carrier of C236) by L529 , PUA2MSS1:def 12;
thus L531: ( rng C238 ) = ( dom ( C238 " ) ) by L527 , FUNCT_1:33
.= (the carrier' of C236) by L529 , PUA2MSS1:def 12;
end;
theorem
L532: (for B155 being non  empty ManySortedSign holds B155 , B155 are_equivalent_wrt ( id (the carrier of B155) ) , ( id (the carrier' of B155) ))
proof
let C239 being non  empty ManySortedSign;
set D101 = ( id (the carrier of C239) );
set D102 = ( id (the carrier' of C239) );
thus L533: D101 is  one-to-one;
L534: ( D101 " ) = D101 by FUNCT_1:45;
L535: ( D102 " ) = D102 by FUNCT_1:45;
thus L536: thesis by L535 , L534 , INSTALG1:8;
end;
theorem
L537: (for B156 , B157 being non  empty ManySortedSign holds (for B158 , B159 being Function holds (B156 , B157 are_equivalent_wrt B158 , B159 implies B157 , B156 are_equivalent_wrt ( B158 " ) , ( B159 " ))))
proof
let C240 , C241 being non  empty ManySortedSign;
let C242 , C243 being Function;
assume that
L538: C242 is  one-to-one
and
L539: C243 is  one-to-one
and
L540: C242 , C243 form_morphism_between C240 , C241
and
L541: ( C242 " ) , ( C243 " ) form_morphism_between C241 , C240;
thus L542: (( C242 " ) is  one-to-one & ( C243 " ) is  one-to-one) by L538 , L539;
L543: ( ( C242 " ) " ) = C242 by L538 , FUNCT_1:43;
thus L544: thesis by L543 , L539 , L540 , L541 , FUNCT_1:43;
end;
theorem
L545: (for B160 , B161 , B162 being non  empty ManySortedSign holds (for B163 , B164 , B165 , B166 being Function holds ((B160 , B161 are_equivalent_wrt B163 , B164 & B161 , B162 are_equivalent_wrt B165 , B166) implies B160 , B162 are_equivalent_wrt ( B165 * B163 ) , ( B166 * B164 ))))
proof
let C244 , C245 , C246 being non  empty ManySortedSign;
let C247 , C248 , C249 , C250 being Function;
assume that
L546: C247 is  one-to-one
and
L547: C248 is  one-to-one
and
L548: C247 , C248 form_morphism_between C244 , C245
and
L549: ( C247 " ) , ( C248 " ) form_morphism_between C245 , C244
and
L550: C249 is  one-to-one
and
L551: C250 is  one-to-one
and
L552: C249 , C250 form_morphism_between C245 , C246
and
L553: ( C249 " ) , ( C250 " ) form_morphism_between C246 , C245;
thus L554: (( C249 * C247 ) is  one-to-one & ( C250 * C248 ) is  one-to-one) by L546 , L547 , L550 , L551;
L555: ( ( C249 * C247 ) " ) = ( ( C247 " ) * ( C249 " ) ) by L546 , L550 , FUNCT_1:44;
L556: ( ( C250 * C248 ) " ) = ( ( C248 " ) * ( C250 " ) ) by L547 , L551 , FUNCT_1:44;
thus L557: thesis by L556 , L548 , L549 , L552 , L553 , L555 , PUA2MSS1:29;
end;
theorem
L558: (for B167 , B168 being non  empty ManySortedSign holds (for B169 , B170 being Function holds (B167 , B168 are_equivalent_wrt B169 , B170 implies (( B169 .: ( InputVertices B167 ) ) = ( InputVertices B168 ) & ( B169 .: ( InnerVertices B167 ) ) = ( InnerVertices B168 )))))
proof
let C251 , C252 being non  empty ManySortedSign;
let C253 , C254 being Function;
assume that
L559: C251 , C252 are_equivalent_wrt C253 , C254;
L560: C253 is  one-to-one by L559 , L516;
L561: C253 , C254 form_morphism_between C251 , C252 by L559 , L516;
L562: ( rng C254 ) = (the carrier' of C252) by L559 , L525;
L563: ( dom (the ResultSort of C252) ) = (the carrier' of C252) by FUNCT_2:def 1;
L564: ( C253 .: ( rng (the ResultSort of C251) ) ) = ( rng ( C253 * (the ResultSort of C251) ) ) by RELAT_1:127
.= ( rng ( (the ResultSort of C252) * C254 ) ) by L561 , PUA2MSS1:def 12
.= ( rng (the ResultSort of C252) ) by L562 , L563 , RELAT_1:28;
thus L565: ( C253 .: ( InputVertices C251 ) ) = ( ( C253 .: (the carrier of C251) ) \ ( C253 .: ( rng (the ResultSort of C251) ) ) ) by L560 , FUNCT_1:64
.= ( InputVertices C252 ) by L559 , L564 , L518;
thus L566: thesis by L564;
end;
definition
let C255 , C256 being non  empty ManySortedSign;
pred C255 , C256 are_equivalent 
means
(ex B171 , B172 being  one-to-one Function st C255 , C256 are_equivalent_wrt B171 , B172)
;reflexivity
proof
let C257 being non  empty ManySortedSign;
take ( id (the carrier of C257) );
take ( id (the carrier' of C257) );
thus L567: thesis by L532;
end;
symmetry
proof
let C258 , C259 being non  empty ManySortedSign;
given C260 , C261 being  one-to-one Function such that
L568: C258 , C259 are_equivalent_wrt C260 , C261;

take ( C260 " );
take ( C261 " );
thus L569: thesis by L568 , L537;
end;
end;
theorem
L571: (for B173 , B174 , B175 being non  empty ManySortedSign holds ((B173 , B174 are_equivalent  & B174 , B175 are_equivalent ) implies B173 , B175 are_equivalent ))
proof
let C262 , C263 , C264 being non  empty ManySortedSign;
given C265 , C266 being  one-to-one Function such that
L572: C262 , C263 are_equivalent_wrt C265 , C266;

given C267 , C268 being  one-to-one Function such that
L573: C263 , C264 are_equivalent_wrt C267 , C268;

take ( C267 * C265 );
take ( C268 * C266 );
thus L574: thesis by L572 , L573 , L545;
end;
definition
let C269 , C270 being non  empty ManySortedSign;
let C271 being Function;
pred C271 preserves_inputs_of C269 , C270
means
( C271 .: ( InputVertices C269 ) ) c= ( InputVertices C270 )
;end;
theorem
L576: (for B176 , B177 being non  empty ManySortedSign holds (for B178 , B179 being Function holds (B178 , B179 form_morphism_between B176 , B177 implies (for B180 being (Vertex of B176) holds ( B178 . B180 ) is (Vertex of B177)))))
proof
let C272 , C273 being non  empty ManySortedSign;
let C274 , C275 being Function;
assume that
L577: ( dom C274 ) = (the carrier of C272)
and
L578: ( dom C275 ) = (the carrier' of C272)
and
L579: ( rng C274 ) c= (the carrier of C273);
L580:
now
let C276 being (Vertex of C272);
L581: ( C274 . C276 ) in ( rng C274 ) by L577 , FUNCT_1:def 3;
thus L582: ( C274 . C276 ) in (the carrier of C273) by L581 , L579;
end;
thus L583: thesis by L580;
end;
theorem
L584: (for B181 , B182 being non  empty non  void ManySortedSign holds (for B183 , B184 being Function holds (B183 , B184 form_morphism_between B181 , B182 implies (for B185 being (Gate of B181) holds ( B184 . B185 ) is (Gate of B182)))))
proof
let C277 , C278 being non  empty non  void ManySortedSign;
let C279 , C280 being Function;
assume that
L585: ( dom C279 ) = (the carrier of C277)
and
L586: ( dom C280 ) = (the carrier' of C277)
and
L587: ( rng C279 ) c= (the carrier of C278)
and
L588: ( rng C280 ) c= (the carrier' of C278);
L589:
now
let C281 being (Gate of C277);
L590: ( C280 . C281 ) in ( rng C280 ) by L586 , FUNCT_1:def 3;
thus L591: ( C280 . C281 ) in (the carrier' of C278) by L590 , L588;
end;
thus L592: thesis by L589;
end;
theorem
L593: (for B186 , B187 being non  empty ManySortedSign holds (for B188 , B189 being Function holds (B188 , B189 form_morphism_between B186 , B187 implies ( B188 .: ( InnerVertices B186 ) ) c= ( InnerVertices B187 ))))
proof
let C282 , C283 being non  empty ManySortedSign;
let C284 , C285 being Function;
assume L594: C284 , C285 form_morphism_between C282 , C283;
L595: ( C284 * (the ResultSort of C282) ) = ( (the ResultSort of C283) * C285 ) by L594 , PUA2MSS1:def 12;
L596: ( C284 .: ( InnerVertices C282 ) ) = ( rng ( (the ResultSort of C283) * C285 ) ) by L595 , RELAT_1:127;
thus L597: thesis by L596 , RELAT_1:26;
end;
theorem
L598: (for B190 , B191 being  Circuit-like non  void non  empty ManySortedSign holds (for B192 , B193 being Function holds (B192 , B193 form_morphism_between B190 , B191 implies (for B194 being (Vertex of B190) holds (B194 in ( InnerVertices B190 ) implies (for B195 being (Vertex of B191) holds (B195 = ( B192 . B194 ) implies ( action_at B195 ) = ( B193 . ( action_at B194 ) ))))))))
proof
let C286 , C287 being  Circuit-like non  void non  empty ManySortedSign;
let C288 , C289 being Function;
assume that
L599: C288 , C289 form_morphism_between C286 , C287;
let C290 being (Vertex of C286);
assume that
L600: C290 in ( InnerVertices C286 );
let C291 being (Vertex of C287);
assume that
L601: C291 = ( C288 . C290 );
reconsider D103 = ( C289 . ( action_at C290 ) ) as (Gate of C287) by L599 , L584;
L602: ( dom C289 ) = (the carrier' of C286) by L599 , PUA2MSS1:def 12;
L603: ( dom C288 ) = (the carrier of C286) by L599 , PUA2MSS1:def 12;
L604: ( dom (the ResultSort of C286) ) = (the carrier' of C286) by FUNCT_2:def 1;
L605: ( C288 .: ( InnerVertices C286 ) ) c= ( InnerVertices C287 ) by L599 , L593;
L606: C291 in ( C288 .: ( InnerVertices C286 ) ) by L600 , L601 , L603 , FUNCT_1:def 6;
L607: ( the_result_sort_of D103 ) = ( ( (the ResultSort of C287) * C289 ) . ( action_at C290 ) ) by L602 , FUNCT_1:13
.= ( ( C288 * (the ResultSort of C286) ) . ( action_at C290 ) ) by L599 , PUA2MSS1:def 12
.= ( C288 . ( the_result_sort_of ( action_at C290 ) ) ) by L604 , FUNCT_1:13
.= C291 by L600 , L601 , MSAFREE2:def 7;
thus L608: thesis by L607 , L605 , L606 , MSAFREE2:def 7;
end;
definition
let C292 , C293 being non  empty ManySortedSign;
let C294 , C295 being Function;
let C296 being  non-empty MSAlgebra over C292;
let C297 being  non-empty MSAlgebra over C293;
pred C294 , C295 form_embedding_of C296 , C297
means
:L609: (C294 is  one-to-one & C295 is  one-to-one & C294 , C295 form_morphism_between C292 , C293 & (the Sorts of C296) = ( (the Sorts of C297) * C294 ) & (the Charact of C296) = ( (the Charact of C297) * C295 ))
;end;
theorem
L611: (for B196 being non  empty ManySortedSign holds (for B197 being  non-empty MSAlgebra over B196 holds ( id (the carrier of B196) ) , ( id (the carrier' of B196) ) form_embedding_of B197 , B197))
proof
let C298 being non  empty ManySortedSign;
let C299 being  non-empty MSAlgebra over C298;
thus L612: ( id (the carrier of C298) ) is  one-to-one;
L613: ( dom (the Sorts of C299) ) = (the carrier of C298) by PARTFUN1:def 2;
L614: ( dom (the Charact of C299) ) = (the carrier' of C298) by PARTFUN1:def 2;
thus L615: thesis by L614 , L613 , INSTALG1:8 , RELAT_1:52;
end;
theorem
L616: (for B198 , B199 , B200 being non  empty ManySortedSign holds (for B201 , B202 , B203 , B204 being Function holds (for B205 being  non-empty MSAlgebra over B198 holds (for B206 being  non-empty MSAlgebra over B199 holds (for B207 being  non-empty MSAlgebra over B200 holds ((B201 , B202 form_embedding_of B205 , B206 & B203 , B204 form_embedding_of B206 , B207) implies ( B203 * B201 ) , ( B204 * B202 ) form_embedding_of B205 , B207))))))
proof
let C300 , C301 , C302 being non  empty ManySortedSign;
let C303 , C304 , C305 , C306 being Function;
let C307 being  non-empty MSAlgebra over C300;
let C308 being  non-empty MSAlgebra over C301;
let C309 being  non-empty MSAlgebra over C302;
assume that
L617: C303 is  one-to-one
and
L618: C304 is  one-to-one
and
L619: C303 , C304 form_morphism_between C300 , C301
and
L620: (the Sorts of C307) = ( (the Sorts of C308) * C303 )
and
L621: (the Charact of C307) = ( (the Charact of C308) * C304 )
and
L622: C305 is  one-to-one
and
L623: C306 is  one-to-one
and
L624: C305 , C306 form_morphism_between C301 , C302
and
L625: (the Sorts of C308) = ( (the Sorts of C309) * C305 )
and
L626: (the Charact of C308) = ( (the Charact of C309) * C306 );
thus L627: (( C305 * C303 ) is  one-to-one & ( C306 * C304 ) is  one-to-one) by L617 , L618 , L622 , L623;
thus L628: ( C305 * C303 ) , ( C306 * C304 ) form_morphism_between C300 , C302 by L619 , L624 , PUA2MSS1:29;
thus L629: thesis by L620 , L621 , L625 , L626 , RELAT_1:36;
end;
definition
let C310 , C311 being non  empty ManySortedSign;
let C312 , C313 being Function;
let C314 being  non-empty MSAlgebra over C310;
let C315 being  non-empty MSAlgebra over C311;
pred C314 , C315 are_similar_wrt C312 , C313
means
:L630: (C312 , C313 form_embedding_of C314 , C315 & ( C312 " ) , ( C313 " ) form_embedding_of C315 , C314)
;end;
theorem
L632: (for B208 , B209 being non  empty ManySortedSign holds (for B210 , B211 being Function holds (for B212 being  non-empty MSAlgebra over B208 holds (for B213 being  non-empty MSAlgebra over B209 holds (B212 , B213 are_similar_wrt B210 , B211 implies B208 , B209 are_equivalent_wrt B210 , B211)))))
proof
let C316 , C317 being non  empty ManySortedSign;
let C318 , C319 being Function;
let C320 being  non-empty MSAlgebra over C316;
let C321 being  non-empty MSAlgebra over C317;
assume that
L633: C318 is  one-to-one
and
L634: C319 is  one-to-one
and
L635: C318 , C319 form_morphism_between C316 , C317
and
L636: (the Sorts of C320) = ( (the Sorts of C321) * C318 )
and
L637: (the Charact of C320) = ( (the Charact of C321) * C319 )
and
L638: ( C318 " ) is  one-to-one
and
L639: ( C319 " ) is  one-to-one
and
L640: ( C318 " ) , ( C319 " ) form_morphism_between C317 , C316;
thus L641: thesis by L633 , L634 , L635 , L640 , L516;
end;
theorem
L642: (for B214 , B215 being non  empty ManySortedSign holds (for B216 , B217 being Function holds (for B218 being  non-empty MSAlgebra over B214 holds (for B219 being  non-empty MSAlgebra over B215 holds (B218 , B219 are_similar_wrt B216 , B217 iff (B214 , B215 are_equivalent_wrt B216 , B217 & (the Sorts of B218) = ( (the Sorts of B219) * B216 ) & (the Charact of B218) = ( (the Charact of B219) * B217 )))))))
proof
let C322 , C323 being non  empty ManySortedSign;
let C324 , C325 being Function;
let C326 being  non-empty MSAlgebra over C322;
let C327 being  non-empty MSAlgebra over C323;
thus L643:now
assume L644: C326 , C327 are_similar_wrt C324 , C325;
thus L645: C322 , C323 are_equivalent_wrt C324 , C325 by L644 , L632;
L646: C324 , C325 form_embedding_of C326 , C327 by L644 , L630;
thus L647: ((the Sorts of C326) = ( (the Sorts of C327) * C324 ) & (the Charact of C326) = ( (the Charact of C327) * C325 )) by L646 , L609;
end;
assume that
L648: C324 is  one-to-one
and
L649: C325 is  one-to-one
and
L650: C324 , C325 form_morphism_between C322 , C323
and
L651: ( C324 " ) , ( C325 " ) form_morphism_between C323 , C322
and
L652: (the Sorts of C326) = ( (the Sorts of C327) * C324 )
and
L653: (the Charact of C326) = ( (the Charact of C327) * C325 );
thus L654: (C324 is  one-to-one & C325 is  one-to-one & C324 , C325 form_morphism_between C322 , C323 & (the Sorts of C326) = ( (the Sorts of C327) * C324 ) & (the Charact of C326) = ( (the Charact of C327) * C325 )) by L648 , L649 , L650 , L652 , L653;
thus L655: (( C324 " ) is  one-to-one & ( C325 " ) is  one-to-one) by L648 , L649;
thus L656: ( C324 " ) , ( C325 " ) form_morphism_between C323 , C322 by L651;
L657: ( dom ( C324 " ) ) = (the carrier of C323) by L651 , PUA2MSS1:def 12;
L658: ( rng C324 ) = (the carrier of C323) by L657 , L648 , FUNCT_1:33;
L659: ( C324 * ( C324 " ) ) = ( id (the carrier of C323) ) by L658 , L648 , FUNCT_1:39
.= ( id ( dom (the Sorts of C327) ) ) by PARTFUN1:def 2;
thus L660: (the Sorts of C327) = ( (the Sorts of C327) * ( C324 * ( C324 " ) ) ) by L659 , RELAT_1:52
.= ( (the Sorts of C326) * ( C324 " ) ) by L652 , RELAT_1:36;
L661: ( dom ( C325 " ) ) = (the carrier' of C323) by L651 , PUA2MSS1:def 12;
L662: ( rng C325 ) = (the carrier' of C323) by L661 , L649 , FUNCT_1:33;
L663: ( C325 * ( C325 " ) ) = ( id (the carrier' of C323) ) by L662 , L649 , FUNCT_1:39
.= ( id ( dom (the Charact of C327) ) ) by PARTFUN1:def 2;
thus L664: (the Charact of C327) = ( (the Charact of C327) * ( C325 * ( C325 " ) ) ) by L663 , RELAT_1:52
.= ( (the Charact of C326) * ( C325 " ) ) by L653 , RELAT_1:36;
end;
theorem
L665: (for B220 being non  empty ManySortedSign holds (for B221 being  non-empty MSAlgebra over B220 holds B221 , B221 are_similar_wrt ( id (the carrier of B220) ) , ( id (the carrier' of B220) )))
proof
let C328 being non  empty ManySortedSign;
let C329 being  non-empty MSAlgebra over C328;
set D104 = ( id (the carrier of C328) );
set D105 = ( id (the carrier' of C328) );
L666: ( D104 " ) = D104 by FUNCT_1:45;
L667: ( D105 " ) = D105 by FUNCT_1:45;
thus L668: (D104 , D105 form_embedding_of C329 , C329 & ( D104 " ) , ( D105 " ) form_embedding_of C329 , C329) by L667 , L666 , L611;
end;
theorem
L669: (for B222 , B223 being non  empty ManySortedSign holds (for B224 , B225 being Function holds (for B226 being  non-empty MSAlgebra over B222 holds (for B227 being  non-empty MSAlgebra over B223 holds (B226 , B227 are_similar_wrt B224 , B225 implies B227 , B226 are_similar_wrt ( B224 " ) , ( B225 " ))))))
proof
let C330 , C331 being non  empty ManySortedSign;
let C332 , C333 being Function;
let C334 being  non-empty MSAlgebra over C330;
let C335 being  non-empty MSAlgebra over C331;
assume that
L670: C332 , C333 form_embedding_of C334 , C335
and
L671: ( C332 " ) , ( C333 " ) form_embedding_of C335 , C334;
L672: C332 is  one-to-one by L670 , L609;
L673: C333 is  one-to-one by L670 , L609;
L674: ( ( C332 " ) " ) = C332 by L672 , FUNCT_1:43;
thus L675: (( C332 " ) , ( C333 " ) form_embedding_of C335 , C334 & ( ( C332 " ) " ) , ( ( C333 " ) " ) form_embedding_of C334 , C335) by L674 , L670 , L671 , L673 , FUNCT_1:43;
end;
theorem
L676: (for B228 , B229 , B230 being non  empty ManySortedSign holds (for B231 , B232 , B233 , B234 being Function holds (for B235 being  non-empty MSAlgebra over B228 holds (for B236 being  non-empty MSAlgebra over B229 holds (for B237 being  non-empty MSAlgebra over B230 holds ((B235 , B236 are_similar_wrt B231 , B232 & B236 , B237 are_similar_wrt B233 , B234) implies B235 , B237 are_similar_wrt ( B233 * B231 ) , ( B234 * B232 )))))))
proof
let C336 , C337 , C338 being non  empty ManySortedSign;
let C339 , C340 , C341 , C342 being Function;
let C343 being  non-empty MSAlgebra over C336;
let C344 being  non-empty MSAlgebra over C337;
let C345 being  non-empty MSAlgebra over C338;
assume that
L677: C339 , C340 form_embedding_of C343 , C344
and
L678: ( C339 " ) , ( C340 " ) form_embedding_of C344 , C343
and
L679: C341 , C342 form_embedding_of C344 , C345
and
L680: ( C341 " ) , ( C342 " ) form_embedding_of C345 , C344;
thus L681: ( C341 * C339 ) , ( C342 * C340 ) form_embedding_of C343 , C345 by L677 , L679 , L616;
L682: C339 is  one-to-one by L677 , L609;
L683: C340 is  one-to-one by L677 , L609;
L684: C341 is  one-to-one by L679 , L609;
L685: C342 is  one-to-one by L679 , L609;
L686: ( ( C341 * C339 ) " ) = ( ( C339 " ) * ( C341 " ) ) by L682 , L684 , FUNCT_1:44;
L687: ( ( C342 * C340 ) " ) = ( ( C340 " ) * ( C342 " ) ) by L683 , L685 , FUNCT_1:44;
thus L688: thesis by L687 , L678 , L680 , L686 , L616;
end;
definition
let C346 , C347 being non  empty ManySortedSign;
let C348 being  non-empty MSAlgebra over C346;
let C349 being  non-empty MSAlgebra over C347;
pred C348 , C349 are_similar 
means
(ex B238 , B239 being Function st C348 , C349 are_similar_wrt B238 , B239)
;end;
theorem
L690: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds (R12 , R13 form_embedding_of R14 , R15 implies (( dom R12 ) = (the carrier of R10) & ( rng R12 ) c= (the carrier of R11) & ( dom R13 ) = (the carrier' of R10) & ( rng R13 ) c= (the carrier' of R11)))))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
assume that
L691: R12 is  one-to-one
and
L692: R13 is  one-to-one
and
L693: ( dom R12 ) = (the carrier of R10)
and
L694: ( dom R13 ) = (the carrier' of R10)
and
L695: ( rng R12 ) c= (the carrier of R11)
and
L696: ( rng R13 ) c= (the carrier' of R11);
thus L697: thesis by L693 , L694 , L695 , L696;
end;
theorem
L698: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds (R12 , R13 form_embedding_of R14 , R15 implies (for B240 being (Gate of R10) holds (for B241 being (Gate of R11) holds (B241 = ( R13 . B240 ) implies ( Den (B241 , R15) ) = ( Den (B240 , R14) )))))))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
assume that
L699: R12 is  one-to-one
and
L700: R13 is  one-to-one
and
L701: R12 , R13 form_morphism_between R10 , R11
and
L702: (the Sorts of R14) = ( (the Sorts of R15) * R12 )
and
L703: (the Charact of R14) = ( (the Charact of R15) * R13 );
let C350 being (Gate of R10);
let C351 being (Gate of R11);
assume that
L704: C351 = ( R13 . C350 );
L705: ( dom R13 ) = (the carrier' of R10) by L701 , PUA2MSS1:def 12;
thus L706: thesis by L705 , L703 , L704 , FUNCT_1:13;
end;
theorem
L707: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds (R12 , R13 form_embedding_of R14 , R15 implies (for B242 being (Gate of R10) holds (for B243 being (Gate of R11) holds (B243 = ( R13 . B242 ) implies (for B244 being (State of R14) holds (for B245 being (State of R15) holds (B244 = ( B245 * R12 ) implies ( B243 depends_on_in B245 ) = ( B242 depends_on_in B244 ))))))))))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
assume that
L708: R12 is  one-to-one
and
L709: R13 is  one-to-one
and
L710: R12 , R13 form_morphism_between R10 , R11
and
L711: (the Sorts of R14) = ( (the Sorts of R15) * R12 )
and
L712: (the Charact of R14) = ( (the Charact of R15) * R13 );
let C352 being (Gate of R10);
let C353 being (Gate of R11);
assume that
L713: C353 = ( R13 . C352 );
let C354 being (State of R14);
let C355 being (State of R15);
assume that
L714: C354 = ( C355 * R12 );
thus L715: ( C353 depends_on_in C355 ) = ( C355 * ( the_arity_of C353 ) ) by CIRCUIT1:def 3
.= ( C355 * ( R12 * ( the_arity_of C352 ) ) ) by L710 , L713 , PUA2MSS1:def 12
.= ( C354 * ( the_arity_of C352 ) ) by L714 , RELAT_1:36
.= ( C352 depends_on_in C354 ) by CIRCUIT1:def 3;
end;
theorem
L716: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds (R12 , R13 form_embedding_of R14 , R15 implies (for B246 being (State of R15) holds ( B246 * R12 ) is (State of R14)))))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
set D106 = R10;
set D107 = R11;
assume that
L717: R12 is  one-to-one
and
L718: R13 is  one-to-one
and
L719: R12 , R13 form_morphism_between D106 , D107
and
L720: (the Sorts of R14) = ( (the Sorts of R15) * R12 )
and
L721: (the Charact of R14) = ( (the Charact of R15) * R13 );
let C356 being (State of R15);
L722: ( dom (the Sorts of R15) ) = (the carrier of D107) by PARTFUN1:def 2;
L723: ( dom (the Sorts of R14) ) = (the carrier of D106) by PARTFUN1:def 2;
L724: ( dom C356 ) = ( dom (the Sorts of R15) ) by CARD_3:9;
L725: ( rng R12 ) c= (the carrier of D107) by L719 , PUA2MSS1:def 12;
L726: ( dom R12 ) = (the carrier of D106) by L719 , PUA2MSS1:def 12;
L727: ( dom ( C356 * R12 ) ) = (the carrier of D106) by L726 , L722 , L724 , L725 , RELAT_1:27;
L728:
now
let C357 being set;
assume L729: C357 in (the carrier of D106);
L730: ( R12 . C357 ) in ( rng R12 ) by L729 , L726 , FUNCT_1:def 3;
L731: ( ( C356 * R12 ) . C357 ) = ( C356 . ( R12 . C357 ) ) by L726 , L729 , FUNCT_1:13;
L732: ( ( C356 * R12 ) . C357 ) in ( (the Sorts of R15) . ( R12 . C357 ) ) by L731 , L722 , L725 , L730 , CARD_3:9;
thus L733: ( ( C356 * R12 ) . C357 ) in ( (the Sorts of R14) . C357 ) by L732 , L720 , L726 , L729 , FUNCT_1:13;
end;
thus L734: thesis by L728 , L723 , L727 , CARD_3:9;
end;
theorem
L735: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds (R12 , R13 form_embedding_of R14 , R15 implies (for B247 being (State of R15) holds (for B248 being (State of R14) holds ((B248 = ( B247 * R12 ) & (for B249 being (Vertex of R10) holds (B249 in ( InputVertices R10 ) implies B247 is_stable_at ( R12 . B249 )))) implies ( Following B248 ) = ( ( Following B247 ) * R12 )))))))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
assume L736: R12 , R13 form_embedding_of R14 , R15;
L737: R12 , R13 form_morphism_between R10 , R11 by L736 , L609;
let C358 being (State of R15);
let C359 being (State of R14);
assume that
L738: C359 = ( C358 * R12 )
and
L739: (for B250 being (Vertex of R10) holds (B250 in ( InputVertices R10 ) implies C358 is_stable_at ( R12 . B250 )));
reconsider D108 = ( ( Following C358 ) * R12 ) as (State of R14) by L736 , L716;
L740: ( dom R12 ) = (the carrier of R10) by L737 , PUA2MSS1:def 12;
L741:
now
let C360 being (Vertex of R10);
L742: ( D108 . C360 ) = ( ( Following C358 ) . ( R12 . C360 ) ) by L740 , FUNCT_1:13;
reconsider D109 = ( R12 . C360 ) as (Vertex of R11) by L737 , L576;
thus L743:now
assume L744: C360 in ( InputVertices R10 );
L745: C358 is_stable_at ( R12 . C360 ) by L744 , L739;
L746: ( Following (C358 , 1) ) = ( Following C358 ) by FACIRC_1:14;
thus L747: ( D108 . C360 ) = ( C358 . ( R12 . C360 ) ) by L746 , L742 , L745 , FACIRC_1:def 9
.= ( C359 . C360 ) by L738 , L740 , FUNCT_1:13;
end;
L748: ( R12 .: ( InnerVertices R10 ) ) c= ( InnerVertices R11 ) by L737 , L593;
assume L749: C360 in ( InnerVertices R10 );
L750: D109 in ( R12 .: ( InnerVertices R10 ) ) by L749 , L740 , FUNCT_1:def 6;
L751: ( action_at D109 ) = ( R13 . ( action_at C360 ) ) by L737 , L749 , L598;
thus L752: ( D108 . C360 ) = ( ( Den (( action_at D109 ) , R15) ) . ( ( action_at D109 ) depends_on_in C358 ) ) by L742 , L748 , L750 , CIRCUIT2:def 5
.= ( ( Den (( action_at C360 ) , R14) ) . ( ( action_at D109 ) depends_on_in C358 ) ) by L736 , L751 , L698
.= ( ( Den (( action_at C360 ) , R14) ) . ( ( action_at C360 ) depends_on_in C359 ) ) by L736 , L738 , L751 , L707;
end;
thus L753: thesis by L741 , CIRCUIT2:def 5;
end;
theorem
L754: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds ((R12 , R13 form_embedding_of R14 , R15 & R12 preserves_inputs_of R10 , R11) implies (for B251 being (State of R15) holds (for B252 being (State of R14) holds (B252 = ( B251 * R12 ) implies ( Following B252 ) = ( ( Following B251 ) * R12 )))))))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
assume that
L755: R12 , R13 form_embedding_of R14 , R15
and
L756: ( R12 .: ( InputVertices R10 ) ) c= ( InputVertices R11 );
let C361 being (State of R15);
let C362 being (State of R14);
assume that
L757: C362 = ( C361 * R12 );
L758: ( dom R12 ) = (the carrier of R10) by L755 , L690;
L759:
now
let C363 being (Vertex of R10);
assume L760: C363 in ( InputVertices R10 );
L761: ( R12 . C363 ) in ( R12 .: ( InputVertices R10 ) ) by L760 , L758 , FUNCT_1:def 6;
thus L762: C361 is_stable_at ( R12 . C363 ) by L761 , L756 , FACIRC_1:18;
end;
thus L763: thesis by L759 , L755 , L757 , L735;
end;
theorem
L764: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds ((R12 , R13 form_embedding_of R14 , R15 & R12 preserves_inputs_of R10 , R11) implies (for B253 being (State of R15) holds (for B254 being (State of R14) holds (B254 = ( B253 * R12 ) implies (for B255 being (Element of ( NAT )) holds ( Following (B254 , B255) ) = ( ( Following (B253 , B255) ) * R12 ))))))))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
assume that
L765: R12 , R13 form_embedding_of R14 , R15
and
L766: R12 preserves_inputs_of R10 , R11;
let C364 being (State of R15);
let C365 being (State of R14);
assume that
L767: C365 = ( C364 * R12 );
defpred S8[ (Element of ( NAT )) ] means ( Following (C365 , $1) ) = ( ( Following (C364 , $1) ) * R12 );
L768: ( Following (C365 , ( 0 )) ) = C365 by FACIRC_1:11;
L769: S8[ ( 0 ) ] by L768 , L767 , FACIRC_1:11;
L770:
now
let C366 being (Element of ( NAT ));
assume L771: S8[ C366 ];
L772: ( Following ( Following (C365 , C366) ) ) = ( ( Following ( Following (C364 , C366) ) ) * R12 ) by L771 , L765 , L766 , L754;
L773: ( Following (C365 , ( C366 + 1 )) ) = ( ( Following ( Following (C364 , C366) ) ) * R12 ) by L772 , FACIRC_1:12
.= ( ( Following (C364 , ( C366 + 1 )) ) * R12 ) by FACIRC_1:12;
thus L774: S8[ ( C366 + 1 ) ] by L773;
end;
thus L775: (for B256 being (Element of ( NAT )) holds S8[ B256 ]) from NAT_1:sch 1(L769 , L770);
end;
theorem
L776: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds ((R12 , R13 form_embedding_of R14 , R15 & R12 preserves_inputs_of R10 , R11) implies (for B257 being (State of R15) holds (for B258 being (State of R14) holds (B258 = ( B257 * R12 ) implies (B257 is  stable implies B258 is  stable)))))))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
assume that
L777: R12 , R13 form_embedding_of R14 , R15
and
L778: R12 preserves_inputs_of R10 , R11;
let C367 being (State of R15);
let C368 being (State of R14);
assume that
L779: C368 = ( C367 * R12 );
assume L780: C367 = ( Following C367 );
thus L781: C368 = ( Following C368 ) by L780 , L777 , L778 , L779 , L754;
end;
theorem
L782: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds ((R12 , R13 form_embedding_of R14 , R15 & R12 preserves_inputs_of R10 , R11) implies (for B259 being (State of R15) holds (for B260 being (State of R14) holds (B260 = ( B259 * R12 ) implies (for B261 being (Vertex of R10) holds (B260 is_stable_at B261 iff B259 is_stable_at ( R12 . B261 )))))))))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
assume that
L783: R12 , R13 form_embedding_of R14 , R15
and
L784: R12 preserves_inputs_of R10 , R11;
let C369 being (State of R15);
let C370 being (State of R14);
assume that
L785: C370 = ( C369 * R12 );
let C371 being (Vertex of R10);
L786: R12 , R13 form_morphism_between R10 , R11 by L783 , L609;
L787: ( dom R12 ) = (the carrier of R10) by L786 , PUA2MSS1:def 12;
reconsider D110 = ( R12 . C371 ) as (Vertex of R11) by L786 , L576;
thus L788: (C370 is_stable_at C371 implies C369 is_stable_at ( R12 . C371 ))
proof
assume L789: (for B262 being Nat holds ( ( Following (C370 , B262) ) . C371 ) = ( C370 . C371 ));
let C372 being Nat;
L790: C372 in ( NAT ) by ORDINAL1:def 12;
L791: ( Following (C370 , C372) ) = ( ( Following (C369 , C372) ) * R12 ) by L790 , L783 , L784 , L785 , L764;
thus L792: ( ( Following (C369 , C372) ) . ( R12 . C371 ) ) = ( ( Following (C370 , C372) ) . C371 ) by L791 , L787 , FUNCT_1:13
.= ( C370 . C371 ) by L789
.= ( C369 . ( R12 . C371 ) ) by L785 , L787 , FUNCT_1:13;
end;

assume L793: (for B263 being Nat holds ( ( Following (C369 , B263) ) . ( R12 . C371 ) ) = ( C369 . ( R12 . C371 ) ));
let C373 being Nat;
L794: C373 in ( NAT ) by ORDINAL1:def 12;
L795: ( Following (C370 , C373) ) = ( ( Following (C369 , C373) ) * R12 ) by L794 , L783 , L784 , L785 , L764;
thus L796: ( ( Following (C370 , C373) ) . C371 ) = ( ( Following (C369 , C373) ) . D110 ) by L795 , L787 , FUNCT_1:13
.= ( C369 . D110 ) by L793
.= ( C370 . C371 ) by L785 , L787 , FUNCT_1:13;
end;
theorem
L797: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds (R14 , R15 are_similar_wrt R12 , R13 implies (for B264 being (State of R15) holds ( B264 * R12 ) is (State of R14)))))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
assume L798: R12 , R13 form_embedding_of R14 , R15;
thus L799: thesis by L798 , L716;
end;
theorem
L800: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds (R14 , R15 are_similar_wrt R12 , R13 implies (for B265 being (State of R14) holds (for B266 being (State of R15) holds (B265 = ( B266 * R12 ) iff B266 = ( B265 * ( R12 " ) )))))))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
assume that
L801: R12 , R13 form_embedding_of R14 , R15
and
L802: ( R12 " ) , ( R13 " ) form_embedding_of R15 , R14;
L803: R12 is  one-to-one by L801 , L609;
let C374 being (State of R14);
let C375 being (State of R15);
L804: R12 , R13 form_morphism_between R10 , R11 by L801 , L609;
L805: ( dom R12 ) = (the carrier of R10) by L804 , PUA2MSS1:def 12;
L806: ( dom C374 ) = (the carrier of R10) by CIRCUIT1:3;
L807: ( ( C374 * ( R12 " ) ) * R12 ) = ( C374 * ( ( R12 " ) * R12 ) ) by RELAT_1:36
.= ( C374 * ( id ( dom R12 ) ) ) by L803 , FUNCT_1:39
.= C374 by L805 , L806 , RELAT_1:52;
L808: ( R12 " ) , ( R13 " ) form_morphism_between R11 , R10 by L802 , L609;
L809: ( dom ( R12 " ) ) = (the carrier of R11) by L808 , PUA2MSS1:def 12;
L810: ( dom C375 ) = (the carrier of R11) by CIRCUIT1:3;
L811: ( ( C375 * R12 ) * ( R12 " ) ) = ( C375 * ( R12 * ( R12 " ) ) ) by RELAT_1:36
.= ( C375 * ( ( ( R12 " ) " ) * ( R12 " ) ) ) by L803 , FUNCT_1:43
.= ( C375 * ( id ( dom ( R12 " ) ) ) ) by L803 , FUNCT_1:39;
thus L812: thesis by L811 , L807 , L809 , L810 , RELAT_1:52;
end;
theorem
L813: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds (R14 , R15 are_similar_wrt R12 , R13 implies (( R12 .: ( InputVertices R10 ) ) = ( InputVertices R11 ) & ( R12 .: ( InnerVertices R10 ) ) = ( InnerVertices R11 )))))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
assume L814: R14 , R15 are_similar_wrt R12 , R13;
L815: R10 , R11 are_equivalent_wrt R12 , R13 by L814 , L632;
thus L816: thesis by L815 , L558;
end;
theorem
L817: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds (R14 , R15 are_similar_wrt R12 , R13 implies R12 preserves_inputs_of R10 , R11)))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
assume L818: R14 , R15 are_similar_wrt R12 , R13;
thus L819: ( R12 .: ( InputVertices R10 ) ) c= ( InputVertices R11 ) by L818 , L813;
end;
theorem
L820: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds (R14 , R15 are_similar_wrt R12 , R13 implies (for B267 being (State of R14) holds (for B268 being (State of R15) holds (B267 = ( B268 * R12 ) implies ( Following B267 ) = ( ( Following B268 ) * R12 )))))))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
assume L821: R14 , R15 are_similar_wrt R12 , R13;
L822: R12 , R13 form_embedding_of R14 , R15 by L821 , L630;
thus L823: thesis by L822 , L821 , L754 , L817;
end;
theorem
L824: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds (R14 , R15 are_similar_wrt R12 , R13 implies (for B269 being (State of R14) holds (for B270 being (State of R15) holds (B269 = ( B270 * R12 ) implies (for B271 being (Element of ( NAT )) holds ( Following (B269 , B271) ) = ( ( Following (B270 , B271) ) * R12 ))))))))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
assume L825: R14 , R15 are_similar_wrt R12 , R13;
L826: R12 , R13 form_embedding_of R14 , R15 by L825 , L630;
thus L827: thesis by L826 , L825 , L764 , L817;
end;
theorem
L828: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds (R14 , R15 are_similar_wrt R12 , R13 implies (for B272 being (State of R14) holds (for B273 being (State of R15) holds (B272 = ( B273 * R12 ) implies (B272 is  stable iff B273 is  stable)))))))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
assume L829: R14 , R15 are_similar_wrt R12 , R13;
L830: R15 , R14 are_similar_wrt ( R12 " ) , ( R13 " ) by L829 , L669;
let C376 being (State of R14);
let C377 being (State of R15);
assume that
L831: C376 = ( C377 * R12 );
L832: C377 = ( C376 * ( R12 " ) ) by L829 , L831 , L800;
thus L833: (C376 is  stable implies C377 is  stable)
proof
assume L834: C376 = ( Following C376 );
thus L835: C377 = ( Following C377 ) by L834 , L830 , L832 , L820;
end;

assume L836: C377 = ( Following C377 );
thus L837: C376 = ( Following C376 ) by L836 , L829 , L831 , L820;
end;
theorem
L838: (for R10 being  Circuit-like non  void non  empty ManySortedSign holds (for R11 being  Circuit-like non  void non  empty ManySortedSign holds (for R12 being Function holds (for R13 being Function holds (for R14 being  non-empty (Circuit of R10) holds (for R15 being  non-empty (Circuit of R11) holds (R14 , R15 are_similar_wrt R12 , R13 implies (for B274 being (State of R14) holds (for B275 being (State of R15) holds (B274 = ( B275 * R12 ) implies (for B276 being (Vertex of R10) holds (B274 is_stable_at B276 iff B275 is_stable_at ( R12 . B276 )))))))))))))
proof
let R10 being  Circuit-like non  void non  empty ManySortedSign;
let R11 being  Circuit-like non  void non  empty ManySortedSign;
let R12 being Function;
let R13 being Function;
let R14 being  non-empty (Circuit of R10);
let R15 being  non-empty (Circuit of R11);
assume L839: R14 , R15 are_similar_wrt R12 , R13;
L840: R15 , R14 are_similar_wrt ( R12 " ) , ( R13 " ) by L839 , L669;
let C378 being (State of R14);
let C379 being (State of R15);
assume that
L841: C378 = ( C379 * R12 );
let C380 being (Vertex of R10);
L842: R10 , R11 are_equivalent_wrt R12 , R13 by L839 , L642;
L843: R12 , R13 form_morphism_between R10 , R11 by L842 , L516;
L844: ( R12 " ) , ( R13 " ) form_morphism_between R11 , R10 by L842 , L516;
L845: ( dom R12 ) = (the carrier of R10) by L843 , PUA2MSS1:def 12;
L846: ( dom ( R12 " ) ) = (the carrier of R11) by L844 , PUA2MSS1:def 12;
reconsider D111 = ( R12 . C380 ) as (Vertex of R11) by L843 , L576;
L847: R12 is  one-to-one by L842 , L516;
L848: C380 = ( ( R12 " ) . D111 ) by L847 , L845 , FUNCT_1:34;
thus L849: (C378 is_stable_at C380 implies C379 is_stable_at ( R12 . C380 ))
proof
assume L850: (for B277 being Nat holds ( ( Following (C378 , B277) ) . C380 ) = ( C378 . C380 ));
let C381 being Nat;
L851: C381 in ( NAT ) by ORDINAL1:def 12;
L852: ( Following (C378 , C381) ) = ( ( Following (C379 , C381) ) * R12 ) by L851 , L839 , L841 , L824;
thus L853: ( ( Following (C379 , C381) ) . ( R12 . C380 ) ) = ( ( Following (C378 , C381) ) . C380 ) by L852 , L845 , FUNCT_1:13
.= ( C378 . C380 ) by L850
.= ( C379 . ( R12 . C380 ) ) by L841 , L845 , FUNCT_1:13;
end;

assume L854: (for B278 being Nat holds ( ( Following (C379 , B278) ) . ( R12 . C380 ) ) = ( C379 . ( R12 . C380 ) ));
let C382 being Nat;
L855: C382 in ( NAT ) by ORDINAL1:def 12;
L856: C379 = ( C378 * ( R12 " ) ) by L839 , L841 , L800;
L857: ( Following (C379 , C382) ) = ( ( Following (C378 , C382) ) * ( R12 " ) ) by L856 , L840 , L855 , L824;
thus L858: ( ( Following (C378 , C382) ) . C380 ) = ( ( Following (C379 , C382) ) . D111 ) by L857 , L846 , L848 , FUNCT_1:13
.= ( C379 . D111 ) by L854
.= ( C378 . C380 ) by L841 , L845 , FUNCT_1:13;
end;
begin
definition
let C383 being non  empty non  void ManySortedSign;
let C384 being  non-empty MSAlgebra over C383;
let C385 being  non-empty (ManySortedSet of (the carrier of C383));
let C386 being non  empty (Subset of ( C383 -Terms C385 ));
let C387 being  Circuit-like non  void non  empty ManySortedSign;
let C388 being  non-empty (Circuit of C387);
pred C388 calculates C386 , C384
means
:L859: (ex R12 being Function st (ex R13 being Function st (R12 , R13 form_embedding_of ( C386 -Circuit C384 ) , C388 & R12 preserves_inputs_of ( C386 -CircuitStr ) , C387)))
;pred C386 , C384 specifies C388
means
C388 , ( C386 -Circuit C384 ) are_similar 
;end;
definition
let C389 being non  empty non  void ManySortedSign;
let C390 being  non-empty (ManySortedSet of (the carrier of C389));
let C391 being  non-empty MSAlgebra over C389;
let C392 being non  empty (Subset of ( C389 -Terms C390 ));
let C393 being  Circuit-like non  void non  empty ManySortedSign;
let C394 being  non-empty (Circuit of C393);
assume L861: C394 calculates C392 , C391;
consider R12 being Function, R13 being Function such that L862: R12 , R13 form_embedding_of ( C392 -Circuit C391 ) , C394 and L863: R12 preserves_inputs_of ( C392 -CircuitStr ) , C393 by L861 , L859;
L864: R12 is  one-to-one by L862 , L609;
mode SortMap of C392 , C391 , C394
 ->  one-to-one Function
means :L865: (it preserves_inputs_of ( C392 -CircuitStr ) , C393 & (ex R13 being Function st it , R13 form_embedding_of ( C392 -Circuit C391 ) , C394));
existence by L862 , L863 , L864;
end;
definition
let C395 being non  empty non  void ManySortedSign;
let C396 being  non-empty (ManySortedSet of (the carrier of C395));
let C397 being  non-empty MSAlgebra over C395;
let C398 being non  empty (Subset of ( C395 -Terms C396 ));
let C399 being  Circuit-like non  void non  empty ManySortedSign;
let C400 being  non-empty (Circuit of C399);
assume that
L867: C400 calculates C398 , C397;
let C401 being (SortMap of C398 , C397 , C400);
consider R13 being Function such that L868: C401 , R13 form_embedding_of ( C398 -Circuit C397 ) , C400 by L867 , L865;
L869: R13 is  one-to-one by L868 , L609;
mode OperMap of C398 , C397 , C400 , C401
 ->  one-to-one Function
means C401 , it form_embedding_of ( C398 -Circuit C397 ) , C400;
existence by L868 , L869;
end;
theorem
L871: (for R6 being non  empty non  void ManySortedSign holds (for R7 being  non-empty  finite-yielding MSAlgebra over R6 holds (for R8 being (Variables of R7) holds (for R9 being (SetWithCompoundTerm of R6 , R8) holds (for B279 being  Circuit-like non  void non  empty ManySortedSign holds (for B280 being  non-empty (Circuit of B279) holds (R9 , R7 specifies B280 implies B280 calculates R9 , R7)))))))
proof
let R6 being non  empty non  void ManySortedSign;
let R7 being  non-empty  finite-yielding MSAlgebra over R6;
let R8 being (Variables of R7);
let R9 being (SetWithCompoundTerm of R6 , R8);
let C402 being  Circuit-like non  void non  empty ManySortedSign;
let C403 being  non-empty (Circuit of C402);
given C404 , C405 being Function such that
L872: C403 , ( R9 -Circuit R7 ) are_similar_wrt C404 , C405;

take ( C404 " );
take ( C405 " );
thus L873: ( C404 " ) , ( C405 " ) form_embedding_of ( R9 -Circuit R7 ) , C403 by L872 , L630;
L874: ( R9 -Circuit R7 ) , C403 are_similar_wrt ( C404 " ) , ( C405 " ) by L872 , L669;
thus L875: thesis by L874 , L817;
end;
theorem
L876: (for R6 being non  empty non  void ManySortedSign holds (for R7 being  non-empty  finite-yielding MSAlgebra over R6 holds (for R8 being (Variables of R7) holds (for R9 being (SetWithCompoundTerm of R6 , R8) holds (for B281 being  Circuit-like non  void non  empty ManySortedSign holds (for B282 being  non-empty (Circuit of B281) holds (B282 calculates R9 , R7 implies (for B283 being (SortMap of R9 , R7 , B282) holds (for B284 being (Term of R6 , R8) holds (B284 in ( Subtrees R9 ) implies (for B285 being (State of B282) holds (( Following (B285 , ( 1 + ( height ( dom B284 ) ) )) ) is_stable_at ( B283 . B284 ) & (for B286 being (State of ( R9 -Circuit R7 )) holds (B286 = ( B285 * B283 ) implies (for B287 being (CompatibleValuation of B286) holds ( ( Following (B285 , ( 1 + ( height ( dom B284 ) ) )) ) . ( B283 . B284 ) ) = ( B284 @ (B287 , R7) ))))))))))))))))
proof
let R6 being non  empty non  void ManySortedSign;
let R7 being  non-empty  finite-yielding MSAlgebra over R6;
let R8 being (Variables of R7);
let R9 being (SetWithCompoundTerm of R6 , R8);
let C406 being  Circuit-like non  void non  empty ManySortedSign;
let C407 being  non-empty (Circuit of C406);
assume that
L877: C407 calculates R9 , R7;
let C408 being (SortMap of R9 , R7 , C407);
consider R13 being Function such that L878: C408 , R13 form_embedding_of ( R9 -Circuit R7 ) , C407 by L877 , L865;
L879: C408 preserves_inputs_of ( R9 -CircuitStr ) , C406 by L877 , L865;
L880: C408 , R13 form_morphism_between ( R9 -CircuitStr ) , C406 by L878 , L609;
let C409 being (Term of R6 , R8);
assume that
L881: C409 in ( Subtrees R9 );
let C410 being (State of C407);
reconsider D112 = ( C410 * C408 ) as (State of ( R9 -Circuit R7 )) by L878 , L716;
reconsider D113 = C409 as (Vertex of ( R9 -CircuitStr )) by L881;
L882: ( Following (D112 , ( 1 + ( height ( dom C409 ) ) )) ) is_stable_at D113 by L349;
L883: ( Following (D112 , ( 1 + ( height ( dom C409 ) ) )) ) = ( ( Following (C410 , ( 1 + ( height ( dom C409 ) ) )) ) * C408 ) by L878 , L879 , L764;
thus L884: ( Following (C410 , ( 1 + ( height ( dom C409 ) ) )) ) is_stable_at ( C408 . C409 ) by L883 , L878 , L879 , L882 , L782;
let C411 being (State of ( R9 -Circuit R7 ));
assume that
L885: C411 = ( C410 * C408 );
let C412 being (CompatibleValuation of C411);
L886: ( dom C408 ) = (the carrier of ( R9 -CircuitStr )) by L880 , PUA2MSS1:def 12;
L887: ( ( Following (C411 , ( 1 + ( height ( dom C409 ) ) )) ) . D113 ) = ( C409 @ (C412 , R7) ) by L349;
thus L888: thesis by L887 , L883 , L885 , L886 , FUNCT_1:13;
end;
theorem
L889: (for R6 being non  empty non  void ManySortedSign holds (for R7 being  non-empty  finite-yielding MSAlgebra over R6 holds (for R8 being (Variables of R7) holds (for R9 being (SetWithCompoundTerm of R6 , R8) holds (for B288 being  Circuit-like non  void non  empty ManySortedSign holds (for B289 being  non-empty (Circuit of B288) holds (B289 calculates R9 , R7 implies (for B290 being (Term of R6 , R8) holds (B290 in ( Subtrees R9 ) implies (ex B291 being (Vertex of B288) st (for B292 being (State of B289) holds (( Following (B292 , ( 1 + ( height ( dom B290 ) ) )) ) is_stable_at B291 & (ex B293 being (SortMap of R9 , R7 , B289) st (for B294 being (State of ( R9 -Circuit R7 )) holds (B294 = ( B292 * B293 ) implies (for B295 being (CompatibleValuation of B294) holds ( ( Following (B292 , ( 1 + ( height ( dom B290 ) ) )) ) . B291 ) = ( B290 @ (B295 , R7) )))))))))))))))))
proof
let R6 being non  empty non  void ManySortedSign;
let R7 being  non-empty  finite-yielding MSAlgebra over R6;
let R8 being (Variables of R7);
let R9 being (SetWithCompoundTerm of R6 , R8);
let C413 being  Circuit-like non  void non  empty ManySortedSign;
let C414 being  non-empty (Circuit of C413);
assume L890: C414 calculates R9 , R7;
consider R12 being Function, R13 being Function such that L891: R12 , R13 form_embedding_of ( R9 -Circuit R7 ) , C414 and L892: R12 preserves_inputs_of ( R9 -CircuitStr ) , C413 by L890 , L859;
L893: R12 is  one-to-one by L891 , L609;
reconsider D114 = R12 as (SortMap of R9 , R7 , C414) by L893 , L890 , L891 , L892 , L865;
let C415 being (Term of R6 , R8);
assume that
L894: C415 in ( Subtrees R9 );
L895: D114 , R13 form_morphism_between ( R9 -CircuitStr ) , C413 by L891 , L609;
reconsider D115 = C415 as (Vertex of ( R9 -CircuitStr )) by L894;
reconsider D116 = ( D114 . D115 ) as (Vertex of C413) by L895 , L576;
take D116;
let C416 being (State of C414);
thus L896: ( Following (C416 , ( 1 + ( height ( dom C415 ) ) )) ) is_stable_at D116 by L890 , L876;
take D114;
thus L897: thesis by L890 , L876;
end;
theorem
L898: (for R6 being non  empty non  void ManySortedSign holds (for R7 being  non-empty  finite-yielding MSAlgebra over R6 holds (for R8 being (Variables of R7) holds (for R9 being (SetWithCompoundTerm of R6 , R8) holds (for B296 being  Circuit-like non  void non  empty ManySortedSign holds (for B297 being  non-empty (Circuit of B296) holds (R9 , R7 specifies B297 implies (for B298 being (SortMap of R9 , R7 , B297) holds (for B299 being (State of B297) holds (for B300 being (Term of R6 , R8) holds (B300 in ( Subtrees R9 ) implies (( Following (B299 , ( 1 + ( height ( dom B300 ) ) )) ) is_stable_at ( B298 . B300 ) & (for B301 being (State of ( R9 -Circuit R7 )) holds (B301 = ( B299 * B298 ) implies (for B302 being (CompatibleValuation of B301) holds ( ( Following (B299 , ( 1 + ( height ( dom B300 ) ) )) ) . ( B298 . B300 ) ) = ( B300 @ (B302 , R7) ))))))))))))))))
proof
let R6 being non  empty non  void ManySortedSign;
let R7 being  non-empty  finite-yielding MSAlgebra over R6;
let R8 being (Variables of R7);
let R9 being (SetWithCompoundTerm of R6 , R8);
let C417 being  Circuit-like non  void non  empty ManySortedSign;
let C418 being  non-empty (Circuit of C417);
assume L899: R9 , R7 specifies C418;
L900: C418 calculates R9 , R7 by L899 , L871;
thus L901: thesis by L900 , L876;
end;
theorem
L902: (for R6 being non  empty non  void ManySortedSign holds (for R7 being  non-empty  finite-yielding MSAlgebra over R6 holds (for R8 being (Variables of R7) holds (for R9 being (SetWithCompoundTerm of R6 , R8) holds (for B303 being  Circuit-like non  void non  empty ManySortedSign holds (for B304 being  non-empty (Circuit of B303) holds (R9 , R7 specifies B304 implies (for B305 being (Term of R6 , R8) holds (B305 in ( Subtrees R9 ) implies (ex B306 being (Vertex of B303) st (for B307 being (State of B304) holds (( Following (B307 , ( 1 + ( height ( dom B305 ) ) )) ) is_stable_at B306 & (ex B308 being (SortMap of R9 , R7 , B304) st (for B309 being (State of ( R9 -Circuit R7 )) holds (B309 = ( B307 * B308 ) implies (for B310 being (CompatibleValuation of B309) holds ( ( Following (B307 , ( 1 + ( height ( dom B305 ) ) )) ) . B306 ) = ( B305 @ (B310 , R7) ))))))))))))))))) by L871 , L889;
