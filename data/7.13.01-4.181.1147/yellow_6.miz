:: Moore-Smith Convergence
::  by Andrzej Trybulec
::
:: Received November 12, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies CLASSES2, CLASSES1, ORDINAL1, XBOOLE_0, FUNCT_1, RELAT_1, TARSKI,
      CARD_3, CARD_1, FUNCT_2, PRALG_1, PBOOLE, SUBSET_1, RLVECT_2, STRUCT_0,
      FUNCOP_1, WAYBEL_3, YELLOW_1, ORDERS_2, WAYBEL_0, XXREAL_0, EQREL_1,
      RELAT_2, ZFMISC_1, CAT_1, YELLOW_0, WELLORD1, PRE_TOPC, RCOMP_1,
      CONNSP_2, COMPTS_1, MCART_1, TOPS_1, SEQ_2, ORDINAL2, SETFAM_1, YELLOW_6;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, SETFAM_1, MCART_1, RELAT_1,
      FUNCT_1, PBOOLE, RELSET_1, PARTFUN1, FUNCT_2, BINOP_1, CARD_1, CARD_3,
      FUNCOP_1, ORDINAL1, CLASSES1, CLASSES2, TOLER_1, STRUCT_0, TOPS_1,
      COMPTS_1, CONNSP_2, PRALG_1, ORDERS_2, LATTICE3, PRE_TOPC, YELLOW_0,
      WAYBEL_0, YELLOW_1, YELLOW_3, WAYBEL_3;
 constructors BINOP_1, CLASSES1, TOLER_1, CLASSES2, REALSET1, TOPS_1, COMPTS_1,
      CONNSP_2, LATTICE3, PRALG_1, YELLOW_3, WAYBEL_3, RELSET_1, PBOOLE,
      XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, ORDINAL1, FUNCT_2, FUNCOP_1,
      CARD_1, CLASSES1, CARD_3, CLASSES2, PBOOLE, STRUCT_0, ORDERS_2, PCOMPS_1,
      LATTICE3, YELLOW_0, WAYBEL_0, PARTFUN1, YELLOW_1, YELLOW_3, WAYBEL_3,
      RELSET_1, TOPS_1, RELAT_1, XTUPLE_0;
 requirements BOOLE, SUBSET;
 definitions TARSKI, STRUCT_0, WAYBEL_0, PRALG_1, YELLOW_1, COMPTS_1, YELLOW_0,
      RELAT_1, PRE_TOPC, WAYBEL_3, BINOP_1, SUBSET_1, WELLORD1, XTUPLE_0;
 theorems CONNSP_2, TOPS_1, FUNCOP_1, WAYBEL_0, PRE_TOPC, ORDERS_2, RELAT_1,
      FUNCT_2, ZFMISC_1, FUNCT_1, TARSKI, PBOOLE, YELLOW_1, CARD_3, PRALG_1,
      YELLOW_3, RELSET_1, DOMAIN_1, YELLOW_0, CLASSES2, CLASSES1, CARD_2,
      FUNCT_6, LATTICE3, MCART_1, SUBSET_1, WAYBEL_3, XBOOLE_0, XBOOLE_1,
      ORDINAL1, PARTFUN1;
 schemes PBOOLE, FUNCT_7, SUBSET_1, RELSET_1, DOMAIN_1, MSSUBFAM, FUNCT_2,
      XBOOLE_0;

begin
definition
let R4 being set;
func the_universe_of R4 equals 
( Tarski-Class ( the_transitive-closure_of R4 ) );
correctness;
end;
registration
let R4 being set;
cluster ( the_universe_of R4 ) ->  epsilon-transitive  Tarski;
coherence;
end;
registration
let R4 being set;
cluster ( the_universe_of R4 ) ->  universal non  empty;
coherence;
end;
theorem
L4: (for R5 being Universe holds (for B1 being Function holds ((( dom B1 ) in R5 & ( rng B1 ) c= R5) implies ( product B1 ) in R5)))
proof
let R5 being Universe;
let C1 being Function;
assume that
L5: ( dom C1 ) in R5
and
L6: ( rng C1 ) c= R5;
L7: ( card ( dom C1 ) ) in ( card R5 ) by L5 , CLASSES2:1;
L8: ( card ( rng C1 ) ) in ( card R5 ) by L7 , CARD_2:61 , ORDINAL1:12;
L9: ( rng C1 ) in R5 by L8 , L6 , CLASSES1:1;
L10: ( union ( rng C1 ) ) in R5 by L9 , CLASSES2:59;
L11: ( Union C1 ) in R5 by L10 , CARD_3:def 4;
L12: (( product C1 ) c= ( Funcs (( dom C1 ) , ( Union C1 )) ) & ( Funcs (( dom C1 ) , ( Union C1 )) ) in R5) by L11 , L5 , CLASSES2:61 , FUNCT_6:1;
thus L13: thesis by L12 , CLASSES1:def 1;
end;
begin
begin
theorem
L14: (for B2 being non  empty set holds (for B3 being  1-sorted-yielding (ManySortedSet of B2) holds (for B4 being (Element of B2) holds ( ( Carrier B3 ) . B4 ) = (the carrier of ( B3 . B4 )))))
proof
let C2 being non  empty set;
let C3 being  1-sorted-yielding (ManySortedSet of C2);
let C4 being (Element of C2);
L15: (ex B5 being 1-sorted st (B5 = ( C3 . C4 ) & ( ( Carrier C3 ) . C4 ) = (the carrier of B5))) by PRALG_1:def 13;
thus L16: thesis by L15;
end;
registration
cluster non  empty  constant  1-sorted-yielding for Function;
existence
proof
set D1 = the 1-sorted;
take D2 = ( { ( {} ) } --> D1 );
thus L17: D2 is non  empty;
thus L18: D2 is  constant;
let C5 being set;
assume L19: C5 in ( dom D2 );
thus L20: thesis by L19 , FUNCOP_1:7;
end;
end;
notation
let C6 being  1-sorted-yielding Function;
synonym C6 is  yielding_non-empty_carriers for C6 is  non-Empty;
end;
definition
let C7 being  1-sorted-yielding Function;
redefine attr C7 is  yielding_non-empty_carriers
means
:L23: (for B6 being set holds (B6 in ( rng C7 ) implies B6 is non  empty non  empty non  empty non  empty 1-sorted));
compatibility
proof
thus L24:now
assume L25: C7 is  non-Empty;
let C8 being set;
assume L26: C8 in ( rng C7 );
L27: (ex B7 being set st (B7 in ( dom C7 ) & C8 = ( C7 . B7 ))) by L26 , FUNCT_1:def 3;
thus L28: C8 is non  empty non  empty non  empty non  empty 1-sorted by L27 , L25 , L26 , PRALG_1:def 11 , WAYBEL_3:def 7;
end;
assume L29: (for B8 being set holds (B8 in ( rng C7 ) implies B8 is non  empty non  empty non  empty non  empty 1-sorted));
let C9 being 1-sorted;
thus L30: thesis by L29;
end;
end;
registration
let C10 being set;
let C11 being 1-sorted;
cluster ( C10 --> C11 ) ->  1-sorted-yielding;
coherence
proof
let C12 being set;
set D3 = ( C10 --> C11 );
assume L32: C12 in ( dom D3 );
L33: ( D3 . C12 ) in ( rng D3 ) by L32 , FUNCT_1:def 3;
thus L34: thesis by L33 , TARSKI:def 1;
end;
end;
registration
let C13 being set;
cluster  yielding_non-empty_carriers for  1-sorted-yielding  1-sorted-yielding  1-sorted-yielding  1-sorted-yielding (ManySortedSet of C13);
existence
proof
set D4 = the non  empty 1-sorted;
take ( C13 --> D4 );
let C14 being set;
assume L36: C14 in ( rng ( C13 --> D4 ) );
thus L37: thesis by L36 , TARSKI:def 1;
end;
end;
registration
let C15 being non  empty set;
let C16 being  RelStr-yielding (ManySortedSet of C15);
cluster (the carrier of ( product C16 )) ->  functional;
coherence
proof
L39: ( product ( Carrier C16 ) ) is  functional;
thus L40: thesis by L39 , YELLOW_1:def 4;
end;
end;
registration
let C17 being set;
let C18 being  yielding_non-empty_carriers  1-sorted-yielding (ManySortedSet of C17);
cluster ( Carrier C18 ) ->  non-empty;
coherence
proof
assume L42: ( {} ) in ( rng ( Carrier C18 ) );
consider C19 being set such that L43: C19 in ( dom ( Carrier C18 ) ) and L44: ( ( Carrier C18 ) . C19 ) = ( {} ) by L42 , FUNCT_1:def 3;
L45: C19 in C17 by L43;
consider C20 being 1-sorted such that L46: C20 = ( C18 . C19 ) and L47: ( ( Carrier C18 ) . C19 ) = (the carrier of C20) by L45 , PRALG_1:def 13;
L48: C20 is  empty by L44 , L47;
L49: C19 in ( dom C18 ) by L45 , PARTFUN1:def 2;
L50: C20 in ( rng C18 ) by L49 , L46 , FUNCT_1:def 3;
thus L51: contradiction by L50 , L48 , L23;
end;
end;
begin
registration
let C21 being non  empty RelStr;
let C22 being  lower (Subset of C21);
cluster ( C22 ` ) ->  upper;
coherence
proof
let C23 , C24 being (Element of C21);
assume that
L53: C23 in ( C22 ` )
and
L54: C23 <= C24;
L55: (not C23 in C22) by L53 , XBOOLE_0:def 5;
L56: (not C24 in C22) by L55 , L54 , WAYBEL_0:def 19;
thus L57: thesis by L56 , XBOOLE_0:def 5;
end;
end;
registration
let C25 being non  empty RelStr;
let C26 being  upper (Subset of C25);
cluster ( C26 ` ) ->  lower;
coherence
proof
let C27 , C28 being (Element of C25);
assume that
L59: C27 in ( C26 ` )
and
L60: C28 <= C27;
L61: (not C27 in C26) by L59 , XBOOLE_0:def 5;
L62: (not C28 in C26) by L61 , L60 , WAYBEL_0:def 20;
thus L63: thesis by L62 , XBOOLE_0:def 5;
end;
end;
definition
let C29 being non  empty RelStr;
redefine attr C29 is  directed
means
:L65: (for B9 , B10 being (Element of C29) holds (ex B11 being (Element of C29) st (B9 <= B11 & B10 <= B11)));
compatibility
proof
thus L66:now
assume L67: C29 is  directed;
let C30 , C31 being (Element of C29);
L68: ( [#] C29 ) is  directed by L67 , WAYBEL_0:def 6;
L69: (ex B12 being (Element of C29) st (B12 in ( [#] C29 ) & C30 <= B12 & C31 <= B12)) by L68 , WAYBEL_0:def 1;
thus L70: (ex B13 being (Element of C29) st (C30 <= B13 & C31 <= B13)) by L69;
end;
assume L71: (for B14 , B15 being (Element of C29) holds (ex B16 being (Element of C29) st (B14 <= B16 & B15 <= B16)));
let C32 , C33 being (Element of C29);
assume that
L72: C32 in ( [#] C29 )
and
L73: C33 in ( [#] C29 );
consider C34 being (Element of C29) such that L74: (C32 <= C34 & C33 <= C34) by L71;
take C34;
thus L75: C34 in ( [#] C29 );
thus L76: thesis by L74;
end;
end;
registration
let C35 being set;
cluster ( BoolePoset C35 ) ->  directed;
coherence
proof
let C36 , C37 being (Element of ( BoolePoset C35 ));
take ( C36 "\/" C37 );
L78: C37 c= ( C36 \/ C37 ) by XBOOLE_1:7;
L79: (( C36 "\/" C37 ) = ( C36 \/ C37 ) & C36 c= ( C36 \/ C37 )) by XBOOLE_1:7 , YELLOW_1:17;
thus L80: (C36 <= ( C36 "\/" C37 ) & C37 <= ( C36 "\/" C37 )) by L79 , L78 , YELLOW_1:2;
end;
end;
registration
cluster non  empty  directed  transitive  strict for RelStr;
existence
proof
take ( BoolePoset ( {} ) );
thus L82: thesis;
end;
end;
L84: (for B17 being non  empty RelStr holds (B17 is  directed iff ( the RelStr of B17 ) is  directed))
proof
let C38 being non  empty RelStr;
thus L85: (C38 is  directed implies ( the RelStr of C38 ) is  directed)
proof
assume L86: C38 is  directed;
let C39 , C40 being (Element of ( the RelStr of C38 ));
reconsider D5 = C39 , D6 = C40 as (Element of C38);
consider C41 being (Element of C38) such that L87: (D5 <= C41 & D6 <= C41) by L86 , L65;
reconsider D7 = C41 as (Element of ( the RelStr of C38 ));
take D7;
L88: ([ C39 , D7 ] in (the InternalRel of C38) & [ C40 , D7 ] in (the InternalRel of C38)) by L87 , ORDERS_2:def 5;
thus L89: thesis by L88 , ORDERS_2:def 5;
end;

assume L90: ( the RelStr of C38 ) is  directed;
let C42 , C43 being (Element of C38);
reconsider D8 = C42 , D9 = C43 as (Element of ( the RelStr of C38 ));
consider C44 being (Element of ( the RelStr of C38 )) such that L91: (D8 <= C44 & D9 <= C44) by L90 , L65;
reconsider D10 = C44 as (Element of C38);
take D10;
L92: ([ D8 , C44 ] in (the InternalRel of ( the RelStr of C38 )) & [ D9 , C44 ] in (the InternalRel of ( the RelStr of C38 ))) by L91 , ORDERS_2:def 5;
thus L93: thesis by L92 , ORDERS_2:def 5;
end;
L94: (for B18 being non  empty RelStr holds (B18 is  transitive iff ( the RelStr of B18 ) is  transitive))
proof
let C45 being non  empty RelStr;
thus L95: (C45 is  transitive implies ( the RelStr of C45 ) is  transitive)
proof
assume L96: C45 is  transitive;
let C46 , C47 , C48 being (Element of ( the RelStr of C45 ));
assume that
L97: C46 <= C47
and
L98: C47 <= C48;
reconsider D11 = C46 , D12 = C47 , D13 = C48 as (Element of C45);
L99: [ C47 , C48 ] in (the InternalRel of ( the RelStr of C45 )) by L98 , ORDERS_2:def 5;
L100: D12 <= D13 by L99 , ORDERS_2:def 5;
L101: [ C46 , C47 ] in (the InternalRel of ( the RelStr of C45 )) by L97 , ORDERS_2:def 5;
L102: D11 <= D12 by L101 , ORDERS_2:def 5;
L103: D11 <= D13 by L102 , L96 , L100 , YELLOW_0:def 2;
L104: [ D11 , D13 ] in (the InternalRel of C45) by L103 , ORDERS_2:def 5;
thus L105: thesis by L104 , ORDERS_2:def 5;
end;

assume L106: ( the RelStr of C45 ) is  transitive;
let C49 , C50 , C51 being (Element of C45);
assume that
L107: C49 <= C50
and
L108: C50 <= C51;
reconsider D14 = C49 , D15 = C50 , D16 = C51 as (Element of ( the RelStr of C45 ));
L109: [ D15 , D16 ] in (the InternalRel of ( the RelStr of C45 )) by L108 , ORDERS_2:def 5;
L110: D15 <= D16 by L109 , ORDERS_2:def 5;
L111: [ D14 , D15 ] in (the InternalRel of ( the RelStr of C45 )) by L107 , ORDERS_2:def 5;
L112: D14 <= D15 by L111 , ORDERS_2:def 5;
L113: D14 <= D16 by L112 , L106 , L110 , YELLOW_0:def 2;
L114: [ C49 , C51 ] in (the InternalRel of C45) by L113 , ORDERS_2:def 5;
thus L115: thesis by L114 , ORDERS_2:def 5;
end;
definition
let C52 being non  empty set;
let C53 being non  empty RelStr;
let C54 being (Function of C52 , (the carrier of C53));
let C55 being (Element of C52);
redefine func C54 . C55 -> (Element of C53);

coherence
proof
L116: ( C54 . C55 ) is (Element of C53);
thus L117: thesis by L116;
end;
end;
registration
let C56 being set;
cluster  yielding_non-empty_carriers for  RelStr-yielding  RelStr-yielding  RelStr-yielding  RelStr-yielding (ManySortedSet of C56);
existence
proof
set D17 = the non  empty RelStr;
take ( C56 --> D17 );
let C57 being set;
assume L119: C57 in ( rng ( C56 --> D17 ) );
thus L120: thesis by L119 , TARSKI:def 1;
end;
end;
registration
let C58 being non  empty set;
let C59 being  yielding_non-empty_carriers  RelStr-yielding (ManySortedSet of C58);
cluster ( product C59 ) -> non  empty;
coherence;
end;
registration
let C60 , C61 being  directed RelStr;
cluster [: C60 , C61 :] ->  directed;
coherence
proof
reconsider D18 = ( [#] C61 ) as  directed (Subset of C61) by WAYBEL_0:def 6;
reconsider D19 = ( [#] C60 ) as  directed (Subset of C60) by WAYBEL_0:def 6;
L123: [: D19 , D18 :] is  directed;
L124: ( [#] [: C60 , C61 :] ) is  directed by L123 , YELLOW_3:def 2;
thus L125: thesis by L124 , WAYBEL_0:def 6;
end;
end;
theorem
L127: (for B19 being RelStr holds (the carrier of B19) = (the carrier of ( B19 ~ )))
proof
let C62 being RelStr;
L128: ( C62 ~ ) = RelStr (# (the carrier of C62) , ( (the InternalRel of C62) ~ ) #) by LATTICE3:def 5;
thus L129: thesis by L128;
end;
L130: (for B20 , B21 being RelStr holds (for B22 , B23 being (Element of B20) holds (for B24 , B25 being (Element of B21) holds ((B22 = B24 & B23 = B25 & ( the RelStr of B20 ) = ( the RelStr of B21 )) implies (B22 <= B23 implies B24 <= B25)))))
proof
let C63 , C64 being RelStr;
let C65 , C66 being (Element of C63);
let C67 , C68 being (Element of C64);
assume that
L131: (C65 = C67 & C66 = C68 & ( the RelStr of C63 ) = ( the RelStr of C64 ));
assume L132: C65 <= C66;
L133: [ C67 , C68 ] in (the InternalRel of C64) by L132 , L131 , ORDERS_2:def 5;
thus L134: thesis by L133 , ORDERS_2:def 5;
end;
definition
let C69 being 1-sorted;
let C70 being NetStr over C69;
attr C70 is  constant
means
:L135: (the mapping of C70) is  constant;
end;
definition
let C71 being RelStr;
let C72 being non  empty 1-sorted;
let C73 being (Element of C72);
func ConstantNet (C71 , C73) ->  strict NetStr over C72 means 
:L137: (( the RelStr of it ) = ( the RelStr of C71 ) & (the mapping of it) = ( (the carrier of it) --> C73 ));
existence
proof
reconsider D20 = ( (the carrier of C71) --> C73 ) as (Function of (the carrier of C71) , (the carrier of C72));
take NetStr (# (the carrier of C71) , (the InternalRel of C71) , D20 #);
thus L138: thesis;
end;
correctness;
end;
registration
let C74 being RelStr;
let C75 being non  empty 1-sorted;
let C76 being (Element of C75);
cluster ( ConstantNet (C74 , C76) ) ->  constant;
coherence
proof
L140: ( (the carrier of ( ConstantNet (C74 , C76) )) --> C76 ) is  constant;
thus L141: (the mapping of ( ConstantNet (C74 , C76) )) is  constant by L140 , L137;
end;
end;
registration
let C77 being non  empty RelStr;
let C78 being non  empty 1-sorted;
let C79 being (Element of C78);
cluster ( ConstantNet (C77 , C79) ) -> non  empty;
coherence
proof
L143: ( the RelStr of ( ConstantNet (C77 , C79) ) ) = ( the RelStr of C77 ) by L137;
thus L144: (the carrier of ( ConstantNet (C77 , C79) )) is non  empty by L143;
end;
end;
registration
let C80 being non  empty  directed RelStr;
let C81 being non  empty 1-sorted;
let C82 being (Element of C81);
cluster ( ConstantNet (C80 , C82) ) ->  directed;
coherence
proof
L146: (( the RelStr of ( ConstantNet (C80 , C82) ) ) = ( the RelStr of C80 ) & ( the RelStr of C80 ) is  directed) by L137 , L84;
thus L147: thesis by L146 , L84;
end;
end;
registration
let C83 being non  empty  transitive RelStr;
let C84 being non  empty 1-sorted;
let C85 being (Element of C84);
cluster ( ConstantNet (C83 , C85) ) ->  transitive;
coherence
proof
L149: (( the RelStr of ( ConstantNet (C83 , C85) ) ) = ( the RelStr of C83 ) & ( the RelStr of C83 ) is  transitive) by L137 , L94;
thus L150: thesis by L149 , L94;
end;
end;
theorem
L152: (for B26 being RelStr holds (for B27 being non  empty 1-sorted holds (for B28 being (Element of B27) holds (the carrier of ( ConstantNet (B26 , B28) )) = (the carrier of B26))))
proof
let C86 being RelStr;
let C87 being non  empty 1-sorted;
let C88 being (Element of C87);
L153: ( the RelStr of ( ConstantNet (C86 , C88) ) ) = ( the RelStr of C86 ) by L137;
thus L154: thesis by L153;
end;
theorem
L155: (for B29 being non  empty RelStr holds (for B30 being non  empty 1-sorted holds (for B31 being (Element of B30) holds (for B32 being (Element of ( ConstantNet (B29 , B31) )) holds ( ( ConstantNet (B29 , B31) ) . B32 ) = B31))))
proof
let C89 being non  empty RelStr;
let C90 being non  empty 1-sorted;
let C91 being (Element of C90);
let C92 being (Element of ( ConstantNet (C89 , C91) ));
thus L156: ( ( ConstantNet (C89 , C91) ) . C92 ) = ( ( (the carrier of ( ConstantNet (C89 , C91) )) --> C91 ) . C92 ) by L137
.= C91 by FUNCOP_1:7;
end;
registration
let C93 being non  empty 1-sorted;
let C94 being non  empty NetStr over C93;
cluster (the mapping of C94) -> non  empty;
coherence;
end;
begin
theorem
L158: (for B33 being RelStr holds B33 is  full  full  full  full (SubRelStr of B33))
proof
let C95 being RelStr;
L159: (the InternalRel of C95) c= (the InternalRel of C95);
reconsider D21 = C95 as (SubRelStr of C95) by L159 , YELLOW_0:def 13;
L160: (the InternalRel of D21) = ( (the InternalRel of C95) |_2 (the carrier of D21) ) by XBOOLE_1:28;
thus L161: thesis by L160 , YELLOW_0:def 14;
end;
theorem
L162: (for B34 being RelStr holds (for B35 being (SubRelStr of B34) holds (for B36 being (SubRelStr of B35) holds B36 is (SubRelStr of B34))))
proof
let C96 being RelStr;
let C97 being (SubRelStr of C96);
let C98 being (SubRelStr of C97);
L163: ((the InternalRel of C97) c= (the InternalRel of C96) & (the InternalRel of C98) c= (the InternalRel of C97)) by YELLOW_0:def 13;
L164: (the InternalRel of C98) c= (the InternalRel of C96) by L163 , XBOOLE_1:1;
L165: ((the carrier of C97) c= (the carrier of C96) & (the carrier of C98) c= (the carrier of C97)) by YELLOW_0:def 13;
L166: (the carrier of C98) c= (the carrier of C96) by L165 , XBOOLE_1:1;
thus L167: thesis by L166 , L164 , YELLOW_0:def 13;
end;
definition
let C99 being 1-sorted;
let C100 being NetStr over C99;
mode SubNetStr of C100
 -> NetStr over C99
means :L168: (it is (SubRelStr of C100) & (the mapping of it) = ( (the mapping of C100) | (the carrier of it) ));
existence
proof
take C100;
thus L169: C100 is (SubRelStr of C100) by L158;
thus L170: (the mapping of C100) = ( (the mapping of C100) | (the carrier of C100) );
end;
end;
theorem
L172: (for B37 being 1-sorted holds (for B38 being NetStr over B37 holds B38 is (SubNetStr of B38)))
proof
let C101 being 1-sorted;
let C102 being NetStr over C101;
L173: (C102 is (SubRelStr of C102) & (the mapping of C102) = ( (the mapping of C102) | (the carrier of C102) )) by L158;
thus L174: thesis by L173 , L168;
end;
theorem
L175: (for B39 being 1-sorted holds (for B40 being NetStr over B39 holds (for B41 being (SubNetStr of B40) holds (for B42 being (SubNetStr of B41) holds B42 is (SubNetStr of B40)))))
proof
let C103 being 1-sorted;
let C104 being NetStr over C103;
let C105 being (SubNetStr of C104);
let C106 being (SubNetStr of C105);
L176: C106 is (SubRelStr of C105) by L168;
L177: (the carrier of C106) c= (the carrier of C105) by L176 , YELLOW_0:def 13;
L178: (the mapping of C106) = ( (the mapping of C105) | (the carrier of C106) ) by L168
.= ( ( (the mapping of C104) | (the carrier of C105) ) | (the carrier of C106) ) by L168
.= ( (the mapping of C104) | ( (the carrier of C105) /\ (the carrier of C106) ) ) by RELAT_1:71
.= ( (the mapping of C104) | (the carrier of C106) ) by L177 , XBOOLE_1:28;
L179: C105 is (SubRelStr of C104) by L168;
L180: C106 is (SubRelStr of C104) by L179 , L176 , L162;
thus L181: thesis by L180 , L178 , L168;
end;
L182: (for B43 being 1-sorted holds (for B44 being NetStr over B43 holds ( the NetStr of B44 ) is (SubNetStr of B44)))
proof
let C107 being 1-sorted;
let C108 being NetStr over C107;
L183: (( the NetStr of C108 ) is (SubRelStr of C108) & (the mapping of ( the NetStr of C108 )) = ( (the mapping of C108) | (the carrier of ( the NetStr of C108 )) )) by RELSET_1:19 , YELLOW_0:def 13;
thus L184: thesis by L183 , L168;
end;
definition
let C109 being 1-sorted;
let C110 being NetStr over C109;
let C111 being (SubNetStr of C110);
attr C111 is  full
means
:L185: C111 is  full  full  full  full (SubRelStr of C110);
end;
L187: (for B45 being 1-sorted holds (for B46 being NetStr over B45 holds ( the NetStr of B46 ) is  full  full  full  full (SubRelStr of B46)))
proof
let C112 being 1-sorted;
let C113 being NetStr over C112;
reconsider D22 = ( the NetStr of C113 ) as (SubRelStr of C113) by YELLOW_0:def 13;
L188: (the InternalRel of D22) = ( (the InternalRel of C113) |_2 (the carrier of D22) ) by XBOOLE_1:28;
thus L189: thesis by L188 , YELLOW_0:def 14;
end;
registration
let C114 being 1-sorted;
let C115 being NetStr over C114;
cluster  full  strict for (SubNetStr of C115);
existence
proof
reconsider D23 = ( the NetStr of C115 ) as (SubNetStr of C115) by L182;
take D23;
thus L190: D23 is  full  full  full  full (SubRelStr of C115) by L187;
thus L191: thesis;
end;
end;
registration
let C116 being 1-sorted;
let C117 being non  empty NetStr over C116;
cluster  full non  empty  strict for (SubNetStr of C117);
existence
proof
reconsider D24 = ( the NetStr of C117 ) as (SubNetStr of C117) by L182;
take D24;
thus L193: D24 is  full  full  full  full (SubRelStr of C117) by L187;
thus L194: thesis;
end;
end;
theorem
L196: (for B47 being 1-sorted holds (for B48 being NetStr over B47 holds (for B49 being (SubNetStr of B48) holds (the carrier of B49) c= (the carrier of B48))))
proof
let C118 being 1-sorted;
let C119 being NetStr over C118;
let C120 being (SubNetStr of C119);
L197: C120 is (SubRelStr of C119) by L168;
thus L198: thesis by L197 , YELLOW_0:def 13;
end;
theorem
L199: (for B50 being 1-sorted holds (for B51 being NetStr over B50 holds (for B52 being (SubNetStr of B51) holds (for B53 , B54 being (Element of B51) holds (for B55 , B56 being (Element of B52) holds ((B53 = B55 & B54 = B56 & B55 <= B56) implies B53 <= B54))))))
proof
let C121 being 1-sorted;
let C122 being NetStr over C121;
let C123 being (SubNetStr of C122);
let C124 , C125 being (Element of C122);
let C126 , C127 being (Element of C123);
assume that
L200: (C124 = C126 & C125 = C127)
and
L201: C126 <= C127;
reconsider D25 = C123 as (SubRelStr of C122) by L168;
reconsider D26 = C126 , D27 = C127 as (Element of D25);
L202: D26 <= D27 by L201;
thus L203: thesis by L202 , L200 , YELLOW_0:59;
end;
theorem
L204: (for B57 being 1-sorted holds (for B58 being non  empty NetStr over B57 holds (for B59 being non  empty  full (SubNetStr of B58) holds (for B60 , B61 being (Element of B58) holds (for B62 , B63 being (Element of B59) holds ((B60 = B62 & B61 = B63 & B60 <= B61) implies B62 <= B63))))))
proof
let C128 being 1-sorted;
let C129 being non  empty NetStr over C128;
let C130 being non  empty  full (SubNetStr of C129);
let C131 , C132 being (Element of C129);
let C133 , C134 being (Element of C130);
assume that
L205: (C131 = C133 & C132 = C134 & C131 <= C132);
reconsider D28 = C130 as  full non  empty (SubRelStr of C129) by L185;
reconsider D29 = C133 , D30 = C134 as (Element of D28);
L206: D29 <= D30 by L205 , YELLOW_0:60;
thus L207: thesis by L206;
end;
begin
registration
let C135 being non  empty 1-sorted;
cluster  constant  strict for (net of C135);
existence
proof
set D31 = the non  empty  directed  transitive RelStr;
set D32 = the (Element of C135);
take ( ConstantNet (D31 , D32) );
thus L208: thesis;
end;
end;
registration
let C136 being non  empty 1-sorted;
let C137 being  constant NetStr over C136;
cluster (the mapping of C137) ->  constant;
coherence by L135;
end;
definition
let C138 being non  empty 1-sorted;
let C139 being NetStr over C138;
assume L211: C139 is  constant non  empty;
func the_value_of C139 -> (Element of C138) equals 
:L212: ( the_value_of (the mapping of C139) );
coherence
proof
reconsider D33 = C139 as  constant non  empty NetStr over C138 by L211;
set D34 = (the mapping of D33);
L213: (ex B64 being set st (B64 in ( dom D34 ) & ( the_value_of D34 ) = ( D34 . B64 ))) by FUNCT_1:def 12;
L214: ( the_value_of D34 ) in ( rng D34 ) by L213 , FUNCT_1:def 3;
thus L215: thesis by L214;
end;
end;
theorem
L217: (for B65 being non  empty RelStr holds (for B66 being non  empty 1-sorted holds (for B67 being (Element of B66) holds ( the_value_of ( ConstantNet (B65 , B67) ) ) = B67)))
proof
let C140 being non  empty RelStr;
let C141 being non  empty 1-sorted;
let C142 being (Element of C141);
thus L218: ( the_value_of ( ConstantNet (C140 , C142) ) ) = ( the_value_of (the mapping of ( ConstantNet (C140 , C142) )) ) by L212
.= ( the_value_of ( (the carrier of ( ConstantNet (C140 , C142) )) --> C142 ) ) by L137
.= C142 by FUNCOP_1:79;
end;
definition
let C143 being non  empty 1-sorted;
let C144 being (net of C143);
mode subnet of C144
 -> (net of C143)
means :L219: (ex B68 being (Function of it , C144) st ((the mapping of it) = ( (the mapping of C144) * B68 ) & (for B69 being (Element of C144) holds (ex B70 being (Element of it) st (for B71 being (Element of it) holds (B70 <= B71 implies B69 <= ( B68 . B71 )))))));
existence
proof
take C144;
take ( id C144 );
thus L220: (the mapping of C144) = ( (the mapping of C144) * ( id C144 ) ) by FUNCT_2:17;
let C145 being (Element of C144);
take D35 = C145;
let C146 being (Element of C144);
assume L221: D35 <= C146;
thus L222: thesis by L221 , FUNCT_1:18;
end;
end;
theorem
L224: (for B72 being non  empty 1-sorted holds (for B73 being (net of B72) holds B73 is (subnet of B73)))
proof
let C147 being non  empty 1-sorted;
let C148 being (net of C147);
take ( id C148 );
thus L225: (the mapping of C148) = ( (the mapping of C148) * ( id C148 ) ) by FUNCT_2:17;
let C149 being (Element of C148);
take D36 = C149;
let C150 being (Element of C148);
assume L226: D36 <= C150;
thus L227: thesis by L226 , FUNCT_1:18;
end;
theorem
L228: (for B74 being non  empty 1-sorted holds (for B75 , B76 , B77 being (net of B74) holds ((B75 is (subnet of B76) & B76 is (subnet of B77)) implies B75 is (subnet of B77))))
proof
let C151 being non  empty 1-sorted;
let C152 , C153 , C154 being (net of C151);
given C155 being (Function of C152 , C153) such that
L229: (the mapping of C152) = ( (the mapping of C153) * C155 )
and
L230: (for B78 being (Element of C153) holds (ex B79 being (Element of C152) st (for B80 being (Element of C152) holds (B79 <= B80 implies B78 <= ( C155 . B80 )))));

given C156 being (Function of C153 , C154) such that
L231: (the mapping of C153) = ( (the mapping of C154) * C156 )
and
L232: (for B81 being (Element of C154) holds (ex B82 being (Element of C153) st (for B83 being (Element of C153) holds (B82 <= B83 implies B81 <= ( C156 . B83 )))));

take ( C156 * C155 );
thus L233: (the mapping of C152) = ( (the mapping of C154) * ( C156 * C155 ) ) by L229 , L231 , RELAT_1:36;
let C157 being (Element of C154);
consider C158 being (Element of C153) such that L234: (for B84 being (Element of C153) holds (C158 <= B84 implies C157 <= ( C156 . B84 ))) by L232;
consider C159 being (Element of C152) such that L235: (for B85 being (Element of C152) holds (C159 <= B85 implies C158 <= ( C155 . B85 ))) by L230;
take C159;
let C160 being (Element of C152);
assume L236: C159 <= C160;
L237: C157 <= ( C156 . ( C155 . C160 ) ) by L236 , L234 , L235;
thus L238: thesis by L237 , FUNCT_2:15;
end;
theorem
L239: (for B86 being non  empty 1-sorted holds (for B87 being  constant (net of B86) holds (for B88 being (Element of B87) holds ( B87 . B88 ) = ( the_value_of B87 ))))
proof
let C161 being non  empty 1-sorted;
let C162 being  constant (net of C161);
let C163 being (Element of C162);
L240: ( dom (the mapping of C162) ) = (the carrier of C162) by FUNCT_2:def 1;
thus L241: ( C162 . C163 ) = ( the_value_of (the mapping of C162) ) by L240 , FUNCT_1:def 12
.= ( the_value_of C162 ) by L212;
end;
theorem
L242: (for B89 being non  empty 1-sorted holds (for B90 being (net of B89) holds (for B91 , B92 being set holds ((B90 is_eventually_in B91 & B90 is_eventually_in B92) implies B91 meets B92))))
proof
let C164 being non  empty 1-sorted;
let C165 being (net of C164);
let C166 , C167 being set;
assume L243: C165 is_eventually_in C166;
consider C168 being (Element of C165) such that L244: (for B93 being (Element of C165) holds (C168 <= B93 implies ( C165 . B93 ) in C166)) by L243 , WAYBEL_0:def 11;
assume L245: C165 is_eventually_in C167;
consider C169 being (Element of C165) such that L246: (for B94 being (Element of C165) holds (C169 <= B94 implies ( C165 . B94 ) in C167)) by L245 , WAYBEL_0:def 11;
consider C170 being (Element of C165) such that L247: C168 <= C170 and L248: C169 <= C170 by L65;
L249: ( C165 . C170 ) in C167 by L246 , L248;
L250: ( C165 . C170 ) in C166 by L244 , L247;
thus L251: thesis by L250 , L249 , XBOOLE_0:3;
end;
theorem
L252: (for B95 being non  empty 1-sorted holds (for B96 being (net of B95) holds (for B97 being (subnet of B96) holds (for R4 being set holds (B97 is_often_in R4 implies B96 is_often_in R4)))))
proof
let C171 being non  empty 1-sorted;
let C172 being (net of C171);
let C173 being (subnet of C172);
let R4 being set;
assume that
L253: C173 is_often_in R4;
let C174 being (Element of C172);
consider C175 being (Function of C173 , C172) such that L254: (the mapping of C173) = ( (the mapping of C172) * C175 ) and L255: (for B98 being (Element of C172) holds (ex B99 being (Element of C173) st (for B100 being (Element of C173) holds (B99 <= B100 implies B98 <= ( C175 . B100 ))))) by L219;
consider C176 being (Element of C173) such that L256: (for B101 being (Element of C173) holds (C176 <= B101 implies C174 <= ( C175 . B101 ))) by L255;
consider C177 being (Element of C173) such that L257: C176 <= C177 and L258: ( C173 . C177 ) in R4 by L253 , WAYBEL_0:def 12;
take ( C175 . C177 );
thus L259: C174 <= ( C175 . C177 ) by L256 , L257;
thus L260: thesis by L254 , L258 , FUNCT_2:15;
end;
theorem
L261: (for B102 being non  empty 1-sorted holds (for B103 being (net of B102) holds (for R4 being set holds (B103 is_eventually_in R4 implies B103 is_often_in R4))))
proof
let C178 being non  empty 1-sorted;
let C179 being (net of C178);
let R4 being set;
given C180 being (Element of C179) such that
L262: (for B104 being (Element of C179) holds (C180 <= B104 implies ( C179 . B104 ) in R4));

let C181 being (Element of C179);
consider C182 being (Element of C179) such that L263: (C180 <= C182 & C181 <= C182) by L65;
take C182;
thus L264: thesis by L262 , L263;
end;
theorem
L265: (for B105 being non  empty 1-sorted holds (for B106 being (net of B105) holds B106 is_eventually_in (the carrier of B105)))
proof
let C183 being non  empty 1-sorted;
let C184 being (net of C183);
set D37 = the (Element of C184);
take D37;
let C185 being (Element of C184);
assume L266: D37 <= C185;
thus L267: thesis;
end;
begin
definition
let C186 being 1-sorted;
let C187 being NetStr over C186;
let R4 being set;
func C187 " R4 ->  strict (SubNetStr of C187) means 
:L268: (it is  full  full  full  full (SubRelStr of C187) & (the carrier of it) = ( (the mapping of C187) " R4 ));
existence
proof
set D38 = ( (the mapping of C187) " R4 );
reconsider D39 = ( (the InternalRel of C187) |_2 D38 ) as (Relation of D38 , D38);
per cases ;
suppose L269: C186 is non  empty;

reconsider D40 = C186 as non  empty 1-sorted by L269;
set D41 = ( (the mapping of C187) " R4 );
reconsider D42 = ( (the mapping of C187) | D41 ) as (Function of D41 , (the carrier of D40)) by FUNCT_2:32;
set D43 = NetStr (# D41 , D39 , D42 #);
L270: D39 c= (the InternalRel of C187) by XBOOLE_1:17;
L271: D43 is (SubRelStr of C187) by L270 , YELLOW_0:def 13;
reconsider D44 = D43 as  strict (SubNetStr of C187) by L271 , L168;
take D44;
thus L272: thesis by L270 , YELLOW_0:def 13 , YELLOW_0:def 14;
end;
suppose L273: C186 is  empty;

L274: (the mapping of C187) = ( {} ) by L273;
L275: D38 = ( {} ) by L274;
reconsider D45 = ( {} ) as (Function of D38 , (the carrier of C186)) by L275 , RELSET_1:12;
set D46 = NetStr (# D38 , D39 , D45 #);
L276: (the mapping of D46) = ( (the mapping of C187) | (the carrier of D46) ) by L273;
L277: D39 c= (the InternalRel of C187) by XBOOLE_1:17;
L278: D46 is (SubRelStr of C187) by L277 , YELLOW_0:def 13;
reconsider D47 = D46 as  strict (SubNetStr of C187) by L278 , L276 , L168;
take D47;
thus L279: thesis by L277 , YELLOW_0:def 13 , YELLOW_0:def 14;
end;
end;
uniqueness
proof
let C188 , C189 being  strict (SubNetStr of C187);
assume that
L281: C188 is  full  full  full  full (SubRelStr of C187)
and
L282: (the carrier of C188) = ( (the mapping of C187) " R4 )
and
L283: C189 is  full  full  full  full (SubRelStr of C187)
and
L284: (the carrier of C189) = ( (the mapping of C187) " R4 );
L285: (the mapping of C188) = ( (the mapping of C187) | (the carrier of C189) ) by L282 , L284 , L168
.= (the mapping of C189) by L168;
L286: ( the RelStr of C188 ) = ( the RelStr of C189 ) by L281 , L282 , L283 , L284 , YELLOW_0:57;
thus L287: thesis by L286 , L285;
end;
end;
registration
let C190 being 1-sorted;
let C191 being  transitive NetStr over C190;
let R4 being set;
cluster ( C191 " R4 ) ->  transitive  full;
coherence
proof
reconsider D48 = ( C191 " R4 ) as  full (SubRelStr of C191) by L268;
L289: D48 is  transitive;
thus L290: thesis by L289 , L185;
end;
end;
theorem
L292: (for B107 being non  empty 1-sorted holds (for B108 being (net of B107) holds (for R4 being set holds (B108 is_often_in R4 implies ( B108 " R4 ) is non  empty  directed))))
proof
let C192 being non  empty 1-sorted;
let C193 being (net of C192);
let R4 being set;
assume that
L293: C193 is_often_in R4;
set D49 = the (Element of C193);
consider C194 being (Element of C193) such that L294: D49 <= C194 and L295: ( C193 . C194 ) in R4 by L293 , WAYBEL_0:def 12;
L296: C194 in ( (the mapping of C193) " R4 ) by L295 , FUNCT_2:38;
thus L297: (the carrier of ( C193 " R4 )) is non  empty by L296 , L268;
reconsider D50 = ( C193 " R4 ) as non  empty  full (SubNetStr of C193) by L296 , L268;
L298: D50 is  directed
proof
let C195 , C196 being (Element of D50);
L299: (C195 in (the carrier of D50) & C196 in (the carrier of D50));
L300: (the carrier of D50) c= (the carrier of C193) by L196;
reconsider D51 = C195 , D52 = C196 as (Element of C193) by L300 , L299;
consider C197 being (Element of C193) such that L301: (D51 <= C197 & D52 <= C197) by L65;
consider C198 being (Element of C193) such that L302: C197 <= C198 and L303: ( C193 . C198 ) in R4 by L293 , WAYBEL_0:def 12;
L304: C198 in ( (the mapping of C193) " R4 ) by L303 , FUNCT_2:38;
reconsider D53 = C198 as (Element of D50) by L304 , L268;
take D53;
L305: (D51 <= C198 & D52 <= C198) by L301 , L302 , YELLOW_0:def 2;
thus L306: thesis by L305 , L204;
end;
thus L307: thesis by L298;
end;
theorem
L308: (for B109 being non  empty 1-sorted holds (for B110 being (net of B109) holds (for R4 being set holds (B110 is_often_in R4 implies ( B110 " R4 ) is (subnet of B110)))))
proof
let C199 being non  empty 1-sorted;
let C200 being (net of C199);
let R4 being set;
assume L309: C200 is_often_in R4;
reconsider D54 = ( C200 " R4 ) as (net of C199) by L309 , L292;
L310: D54 is (subnet of C200)
proof
set D55 = ( id D54 );
L311: (the carrier of D54) c= (the carrier of C200) by L196;
reconsider D56 = D55 as (Function of D54 , C200) by L311 , FUNCT_2:7;
take D56;
L312: (the mapping of D54) = ( (the mapping of C200) | (the carrier of D54) ) by L168;
thus L313: (the mapping of D54) = ( (the mapping of C200) * D56 ) by L312 , RELAT_1:65;
let C201 being (Element of C200);
consider C202 being (Element of C200) such that L314: C201 <= C202 and L315: ( C200 . C202 ) in R4 by L309 , WAYBEL_0:def 12;
L316: C202 in ( (the mapping of C200) " R4 ) by L315 , FUNCT_2:38;
reconsider D57 = C202 as (Element of D54) by L316 , L268;
take D57;
let C203 being (Element of D54);
assume that
L317: D57 <= C203;
L318: ( D56 . C203 ) = C203 by FUNCT_1:18;
L319: C202 <= ( D56 . C203 ) by L318 , L317 , L199;
thus L320: thesis by L319 , L314 , YELLOW_0:def 2;
end;
thus L321: thesis by L310;
end;
theorem
L322: (for B111 being non  empty 1-sorted holds (for B112 being (net of B111) holds (for R4 being set holds (for B113 being (subnet of B112) holds (B113 = ( B112 " R4 ) implies B113 is_eventually_in R4)))))
proof
let C204 being non  empty 1-sorted;
let C205 being (net of C204);
let R4 being set;
let C206 being (subnet of C205);
assume that
L323: C206 = ( C205 " R4 );
set D58 = the (Element of C206);
take D58;
let C207 being (Element of C206);
assume that
L324: D58 <= C207;
L325: C207 in (the carrier of C206);
L326: C207 in ( (the mapping of C205) " R4 ) by L325 , L323 , L268;
L327: ( (the mapping of C205) . C207 ) in R4 by L326 , FUNCT_1:def 7;
L328: (the mapping of C206) = ( (the mapping of C205) | (the carrier of C206) ) by L323 , L168;
thus L329: thesis by L328 , L327 , FUNCT_1:49;
end;
begin
definition
let C208 being non  empty 1-sorted;
func NetUniv C208 means 
:L330: (for R1 being set holds (R1 in it iff (ex B114 being  strict (net of C208) st (B114 = R1 & (the carrier of B114) in ( the_universe_of (the carrier of C208) )))));
existence
proof
deffunc H1(set) = { NetStr (# $1 , B115 , B116 #) where B115 is (Relation of $1 , $1) , B116 is (Element of ( Funcs ($1 , (the carrier of C208)) )) : NetStr (# $1 , B115 , B116 #) is (net of C208) };
set D59 = ( the_universe_of (the carrier of C208) );
consider C209 being (ManySortedSet of D59) such that L331: (for B117 being set holds (B117 in D59 implies ( C209 . B117 ) = H1(B117))) from PBOOLE:sch 4;
take D60 = ( Union C209 );
let R1 being set;
L332: ( Union C209 ) = ( union ( rng C209 ) ) by CARD_3:def 4;
thus L333:now
assume L334: R1 in D60;
consider R2 being set such that L335: R1 in R2 and L336: R2 in ( rng C209 ) by L334 , L332 , TARSKI:def 4;
consider R3 being set such that L337: R3 in ( dom C209 ) and L338: ( C209 . R3 ) = R2 by L336 , FUNCT_1:def 3;
L339: R3 in D59 by L337;
L340: R2 = { NetStr (# R3 , B118 , B119 #) where B118 is (Relation of R3 , R3) , B119 is (Element of ( Funcs (R3 , (the carrier of C208)) )) : NetStr (# R3 , B118 , B119 #) is (net of C208) } by L339 , L331 , L338;
consider C210 being (Relation of R3 , R3), C211 being (Element of ( Funcs (R3 , (the carrier of C208)) )) such that L341: R1 = NetStr (# R3 , C210 , C211 #) and L342: NetStr (# R3 , C210 , C211 #) is (net of C208) by L340 , L335;
reconsider D61 = NetStr (# R3 , C210 , C211 #) as  strict (net of C208) by L342;
take D62 = D61;
thus L343: D62 = R1 by L341;
thus L344: (the carrier of D62) in ( the_universe_of (the carrier of C208) ) by L337;
end;
given C212 being  strict (net of C208) such that
L345: C212 = R1
and
L346: (the carrier of C212) in ( the_universe_of (the carrier of C208) );

set D63 = (the carrier of C212);
L347: D63 in ( dom C209 ) by L346 , PARTFUN1:def 2;
L348: ( C209 . D63 ) in ( rng C209 ) by L347 , FUNCT_1:def 3;
L349: (the mapping of C212) in ( Funcs (D63 , (the carrier of C208)) ) by FUNCT_2:8;
L350: ( C209 . D63 ) = { NetStr (# D63 , B120 , B121 #) where B120 is (Relation of D63 , D63) , B121 is (Element of ( Funcs (D63 , (the carrier of C208)) )) : NetStr (# D63 , B120 , B121 #) is (net of C208) } by L331 , L346;
L351: C212 in ( C209 . D63 ) by L350 , L349;
thus L352: thesis by L351 , L332 , L345 , L348 , TARSKI:def 4;
end;
uniqueness
proof
defpred S1[ set ] means (ex B122 being  strict (net of C208) st (B122 = $1 & (the carrier of B122) in ( the_universe_of (the carrier of C208) )));
thus L353: (for B123 , B124 being set holds (((for B125 being set holds (B125 in B123 iff S1[ B125 ])) & (for B126 being set holds (B126 in B124 iff S1[ B126 ]))) implies B123 = B124)) from XBOOLE_0:sch 3;
end;
end;
registration
let C213 being non  empty 1-sorted;
cluster ( NetUniv C213 ) -> non  empty;
coherence
proof
L355: ( {} ) in { ( {} ) } by TARSKI:def 1;
reconsider D64 = { [ ( {} ) , ( {} ) ] } as (Relation of { ( {} ) }) by L355 , RELSET_1:3;
set D65 = RelStr (# { ( {} ) } , D64 #);
L356:
now
let C214 , C215 being (Element of D65);
L357: (C214 = ( {} ) & C215 = ( {} )) by TARSKI:def 1;
L358: [ C214 , C215 ] in { [ ( {} ) , ( {} ) ] } by L357 , TARSKI:def 1;
thus L359: C214 <= C215 by L358 , ORDERS_2:def 5;
end;
L360: D65 is  transitive
proof
let C216 , C217 , C218 being (Element of D65);
thus L361: thesis by L356;
end;
L362: D65 is  directed
proof
let C219 , C220 being (Element of D65);
take C219;
thus L363: thesis by L356;
end;
reconsider D66 = D65 as  transitive  directed non  empty RelStr by L362 , L360;
set D67 = ( the_universe_of (the carrier of C213) );
set D68 = the (Element of C213);
set D69 = ( ConstantNet (D66 , D68) );
L364: (( the RelStr of D69 ) = ( the RelStr of D66 ) & ( {} ) in D67) by L137 , CLASSES2:56;
L365: (the carrier of D69) in D67 by L364 , CLASSES2:2;
thus L366: thesis by L365 , L330;
end;
end;
L368: (for B127 , B128 being non  empty 1-sorted holds ((the carrier of B127) = (the carrier of B128) implies (for B129 being  constant (net of B127) holds B129 is  constant  constant  constant  constant (net of B128))))
proof
let C221 , C222 being non  empty 1-sorted;
assume that
L369: (the carrier of C221) = (the carrier of C222);
let C223 being  constant (net of C221);
reconsider D70 = C223 as (net of C222) by L369;
L370: (the mapping of C223) is  constant;
L371: (the mapping of D70) is  constant by L370;
thus L372: thesis by L371 , L135;
end;
L373: (for B130 , B131 being non  empty 1-sorted holds ((the carrier of B130) = (the carrier of B131) implies ( NetUniv B130 ) = ( NetUniv B131 )))
proof
let C224 , C225 being non  empty 1-sorted;
defpred S2[ set ] means (ex B132 being  strict (net of C225) st (B132 = $1 & (the carrier of B132) in ( the_universe_of (the carrier of C225) )));
assume L374: (the carrier of C224) = (the carrier of C225);
L375:
now
let R1 being set;
thus L376:now
assume L377: R1 in ( NetUniv C224 );
consider C226 being  strict (net of C224) such that L378: (C226 = R1 & (the carrier of C226) in ( the_universe_of (the carrier of C224) )) by L377 , L330;
reconsider D71 = C226 as  strict (net of C225) by L374;
thus L379: S2[ R1 ]
proof
take D71;
thus L380: thesis by L374 , L378;
end;

end;
assume L380: S2[ R1 ];
consider C227 being  strict (net of C225) such that L381: (C227 = R1 & (the carrier of C227) in ( the_universe_of (the carrier of C225) )) by L380;
reconsider D72 = C227 as  strict (net of C224) by L374;
L382:
now
take D73 = D72;
thus L383: (D73 = R1 & (the carrier of D73) in ( the_universe_of (the carrier of C224) )) by L374 , L381;
end;
thus L384: R1 in ( NetUniv C224 ) by L382 , L330;
end;
L385: (for R1 being set holds (R1 in ( NetUniv C225 ) iff S2[ R1 ])) by L330;
thus L386: ( NetUniv C224 ) = ( NetUniv C225 ) from XBOOLE_0:sch 2(L375 , L385);
end;
begin
definition
let C228 being set;
let C229 being 1-sorted;
mode net_set of C228 , C229
 -> (ManySortedSet of C228)
means :L387: (for B133 being set holds (B133 in ( rng it ) implies B133 is (net of C229)));
existence
proof
set D74 = the (net of C229);
take ( C228 --> D74 );
let C230 being set;
assume L388: C230 in ( rng ( C228 --> D74 ) );
thus L389: thesis by L388 , TARSKI:def 1;
end;
end;
theorem
L391: (for B134 being set holds (for B135 being 1-sorted holds (for B136 being (ManySortedSet of B134) holds (B136 is (net_set of B134 , B135) iff (for B137 being set holds (B137 in B134 implies ( B136 . B137 ) is (net of B135)))))))
proof
let C231 being set;
let C232 being 1-sorted;
let C233 being (ManySortedSet of C231);
thus L392:now
assume L393: C233 is (net_set of C231 , C232);
let C234 being set;
assume L394: C234 in C231;
L395: C234 in ( dom C233 ) by L394 , PARTFUN1:def 2;
L396: ( C233 . C234 ) in ( rng C233 ) by L395 , FUNCT_1:def 3;
thus L397: ( C233 . C234 ) is (net of C232) by L396 , L393 , L387;
end;
assume L398: (for B138 being set holds (B138 in C231 implies ( C233 . B138 ) is (net of C232)));
let C235 being set;
assume L399: C235 in ( rng C233 );
L400: (ex B139 being set st (B139 in ( dom C233 ) & C235 = ( C233 . B139 ))) by L399 , FUNCT_1:def 3;
thus L401: thesis by L400 , L398;
end;
definition
let C236 being non  empty set;
let C237 being 1-sorted;
let C238 being (net_set of C236 , C237);
let C239 being (Element of C236);
redefine func C238 . C239 -> (net of C237);

coherence by L391;
end;
registration
let C240 being set;
let C241 being 1-sorted;
cluster  ->  RelStr-yielding for (net_set of C240 , C241);
coherence
proof
let C242 being (net_set of C240 , C241);
let C243 being set;
assume L403: C243 in ( rng C242 );
thus L404: thesis by L403 , L387;
end;
end;
registration
let C244 being 1-sorted;
let C245 being (net of C244);
cluster  ->  yielding_non-empty_carriers for (net_set of (the carrier of C245) , C244);
coherence
proof
let C246 being (net_set of (the carrier of C245) , C244);
let C247 being set;
assume L406: C247 in ( rng C246 );
thus L407: thesis by L406 , L387;
end;
end;
registration
let C248 being non  empty 1-sorted;
let C249 being (net of C248);
let C250 being (net_set of (the carrier of C249) , C248);
cluster ( product C250 ) ->  directed  transitive;
coherence
proof
L409: (the carrier of ( product C250 )) = ( product ( Carrier C250 ) ) by YELLOW_1:def 4;
thus L410: ( product C250 ) is  directed
proof
let C251 , C252 being (Element of ( product C250 ));
defpred S3[ (Element of C249) , set ] means ([ ( C251 . $1 ) , $2 ] in (the InternalRel of ( C250 . $1 )) & [ ( C252 . $1 ) , $2 ] in (the InternalRel of ( C250 . $1 )));
L411:
now
let C253 being (Element of C249);
consider C254 being (Element of ( C250 . C253 )) such that L412: (( C251 . C253 ) <= C254 & ( C252 . C253 ) <= C254) by L65;
reconsider D75 = C254 as set;
take D76 = D75;
thus L413: S3[ C253 , D76 ] by L412 , ORDERS_2:def 5;
end;
consider C255 being (ManySortedSet of (the carrier of C249)) such that L414: (for B140 being (Element of C249) holds S3[ B140 , ( C255 . B140 ) ]) from PBOOLE:sch 6(L411);
L415:
now
let C256 being set;
assume L416: C256 in ( dom ( Carrier C250 ) );
reconsider D77 = C256 as (Element of C249) by L416;
L417: [ ( C251 . D77 ) , ( C255 . D77 ) ] in (the InternalRel of ( C250 . D77 )) by L414;
L418: ( C255 . D77 ) in (the carrier of ( C250 . D77 )) by L417 , ZFMISC_1:87;
thus L419: ( C255 . C256 ) in ( ( Carrier C250 ) . C256 ) by L418 , L14;
end;
L420: ( dom C255 ) = (the carrier of C249) by PARTFUN1:def 2
.= ( dom ( Carrier C250 ) ) by PARTFUN1:def 2;
reconsider D78 = C255 as (Element of ( product C250 )) by L420 , L409 , L415 , CARD_3:9;
take D78;
L421: (for B141 being set holds (B141 in (the carrier of C249) implies (ex B142 being RelStr st (ex B143 , B144 being (Element of B142) st (B142 = ( C250 . B141 ) & B143 = ( C251 . B141 ) & B144 = ( D78 . B141 ) & B143 <= B144)))))
proof
let C257 being set;
assume L422: C257 in (the carrier of C249);
reconsider D79 = C257 as (Element of C249) by L422;
reconsider D80 = ( C251 . D79 ) , D81 = ( D78 . D79 ) as (Element of ( C250 . D79 ));
take ( C250 . D79 );
take D80;
take D81;
thus L423: (( C250 . D79 ) = ( C250 . C257 ) & D80 = ( C251 . C257 ) & D81 = ( D78 . C257 ));
L424: [ D80 , D81 ] in (the InternalRel of ( C250 . D79 )) by L414;
thus L425: thesis by L424 , ORDERS_2:def 5;
end;
thus L426: C251 <= D78 by L421 , L409 , YELLOW_1:def 4;
L427: (for B145 being set holds (B145 in (the carrier of C249) implies (ex B146 being RelStr st (ex B147 , B148 being (Element of B146) st (B146 = ( C250 . B145 ) & B147 = ( C252 . B145 ) & B148 = ( D78 . B145 ) & B147 <= B148)))))
proof
let C258 being set;
assume L428: C258 in (the carrier of C249);
reconsider D82 = C258 as (Element of C249) by L428;
reconsider D83 = ( C252 . D82 ) , D84 = ( D78 . D82 ) as (Element of ( C250 . D82 ));
take ( C250 . D82 );
take D83;
take D84;
thus L429: (( C250 . D82 ) = ( C250 . C258 ) & D83 = ( C252 . C258 ) & D84 = ( D78 . C258 ));
L430: [ D83 , D84 ] in (the InternalRel of ( C250 . D82 )) by L414;
thus L431: thesis by L430 , ORDERS_2:def 5;
end;
thus L432: thesis by L427 , L409 , YELLOW_1:def 4;
end;

let C259 , C260 , C261 being (Element of ( product C250 ));
assume that
L433: C259 <= C260
and
L434: C260 <= C261;
L435: (ex B149 , B150 being Function st (B149 = C260 & B150 = C261 & (for B151 being set holds (B151 in (the carrier of C249) implies (ex B152 being RelStr st (ex B153 , B154 being (Element of B152) st (B152 = ( C250 . B151 ) & B153 = ( B149 . B151 ) & B154 = ( B150 . B151 ) & B153 <= B154))))))) by L409 , L434 , YELLOW_1:def 4;
L436: (ex B155 , B156 being Function st (B155 = C259 & B156 = C260 & (for B157 being set holds (B157 in (the carrier of C249) implies (ex B158 being RelStr st (ex B159 , B160 being (Element of B158) st (B158 = ( C250 . B157 ) & B159 = ( B155 . B157 ) & B160 = ( B156 . B157 ) & B159 <= B160))))))) by L409 , L433 , YELLOW_1:def 4;
L437: (for B161 being set holds (B161 in (the carrier of C249) implies (ex B162 being RelStr st (ex B163 , B164 being (Element of B162) st (B162 = ( C250 . B161 ) & B163 = ( C259 . B161 ) & B164 = ( C261 . B161 ) & B163 <= B164)))))
proof
let C262 being set;
assume L438: C262 in (the carrier of C249);
reconsider D85 = C262 as (Element of C249) by L438;
consider C263 being RelStr, C264 , C265 being (Element of C263) such that L439: C263 = ( C250 . C262 ) and L440: C264 = ( C259 . C262 ) and L441: (C265 = ( C260 . C262 ) & C264 <= C265) by L436 , L438;
consider C266 being RelStr, C267 , C268 being (Element of C266) such that L442: C266 = ( C250 . C262 ) and L443: C267 = ( C260 . C262 ) and L444: C268 = ( C261 . C262 ) and L445: C267 <= C268 by L435 , L438;
reconsider D86 = C264 , D87 = C268 as (Element of ( C250 . D85 )) by L439 , L442;
take ( C250 . D85 );
take D86;
take D87;
thus L446: (( C250 . D85 ) = ( C250 . C262 ) & D86 = ( C259 . C262 ) & D87 = ( C261 . C262 )) by L440 , L444;
thus L447: thesis by L439 , L441 , L442 , L443 , L445 , YELLOW_0:def 2;
end;
thus L448: thesis by L437 , L409 , YELLOW_1:def 4;
end;
end;
registration
let C269 being set;
let C270 being 1-sorted;
cluster  ->  yielding_non-empty_carriers for (net_set of C269 , C270);
coherence
proof
let C271 being (net_set of C269 , C270);
let C272 being set;
assume L450: C272 in ( rng C271 );
thus L451: thesis by L450 , L387;
end;
end;
registration
let C273 being set;
let C274 being 1-sorted;
cluster  yielding_non-empty_carriers for (net_set of C273 , C274);
existence
proof
set D88 = the (net_set of C273 , C274);
take D88;
thus L453: thesis;
end;
end;
definition
let C275 being non  empty 1-sorted;
let C276 being (net of C275);
let C277 being (net_set of (the carrier of C276) , C275);
func Iterated C277 ->  strict (net of C275) means 
:L455: (( the RelStr of it ) = [: C276 , ( product C277 ) :] & (for B165 being (Element of C276) holds (for B166 being Function holds ((B165 in (the carrier of C276) & B166 in (the carrier of ( product C277 ))) implies ( (the mapping of it) . (B165 , B166) ) = ( (the mapping of ( C277 . B165 )) . ( B166 . B165 ) )))));
existence
proof
deffunc H2((Element of C276) , (Element of ( product C277 ))) = ( (the mapping of ( C277 . $1 )) . ( $2 . $1 ) );
set D89 = [: C276 , ( product C277 ) :];
L456: (for B167 being (Element of C276) holds (for B168 being (Element of ( product C277 )) holds H2(B167 , B168) in (the carrier of C275)));
consider C278 being (Function of [: (the carrier of C276) , (the carrier of ( product C277 )) :] , (the carrier of C275)) such that L457: (for B169 being (Element of C276) holds (for B170 being (Element of ( product C277 )) holds ( C278 . (B169 , B170) ) = H2(B169 , B170))) from FUNCT_7:sch 1(L456);
L458: (the carrier of D89) = [: (the carrier of C276) , (the carrier of ( product C277 )) :] by YELLOW_3:def 2;
reconsider D90 = C278 as (Function of (the carrier of D89) , (the carrier of C275)) by L458;
reconsider D91 = NetStr (# (the carrier of D89) , (the InternalRel of D89) , D90 #) as  strict (net of C275) by L84 , L94;
take D91;
thus L459: ( the RelStr of D91 ) = [: C276 , ( product C277 ) :];
let C279 being (Element of C276);
let C280 being Function;
assume that
L460: C279 in (the carrier of C276)
and
L461: C280 in (the carrier of ( product C277 ));
thus L462: thesis by L457 , L461;
end;
uniqueness
proof
let C281 , C282 being  strict (net of C275);
assume that
L463: ( the RelStr of C281 ) = [: C276 , ( product C277 ) :]
and
L464: (for B171 being (Element of C276) holds (for B172 being Function holds ((B171 in (the carrier of C276) & B172 in (the carrier of ( product C277 ))) implies ( (the mapping of C281) . (B171 , B172) ) = ( (the mapping of ( C277 . B171 )) . ( B172 . B171 ) ))))
and
L465: ( the RelStr of C282 ) = [: C276 , ( product C277 ) :]
and
L466: (for B173 being (Element of C276) holds (for B174 being Function holds ((B173 in (the carrier of C276) & B174 in (the carrier of ( product C277 ))) implies ( (the mapping of C282) . (B173 , B174) ) = ( (the mapping of ( C277 . B173 )) . ( B174 . B173 ) ))));
L467: (the carrier of ( the RelStr of C282 )) = [: (the carrier of C276) , (the carrier of ( product C277 )) :] by L465 , YELLOW_3:def 2;
reconsider D92 = (the mapping of C281) , D93 = (the mapping of C282) as (Function of [: (the carrier of C276) , (the carrier of ( product C277 )) :] , (the carrier of C275)) by L467 , L463 , L465;
L468:
now
let C283 being (Element of [: (the carrier of C276) , (the carrier of ( product C277 )) :]);
consider C284 being (Element of C276), C285 being (Element of ( product C277 )) such that L469: C283 = [ C284 , C285 ] by DOMAIN_1:1;
reconsider D94 = C285 as (Element of ( product ( Carrier C277 ) )) by YELLOW_1:def 4;
thus L470: ( D92 . C283 ) = ( D92 . (C284 , D94) ) by L469
.= ( (the mapping of ( C277 . C284 )) . ( D94 . C284 ) ) by L464
.= ( D93 . (C284 , D94) ) by L466
.= ( D93 . C283 ) by L469;
end;
thus L471: thesis by L468 , L463 , L465 , FUNCT_2:63;
end;
end;
theorem
L473: (for B175 being non  empty 1-sorted holds (for B176 being (net of B175) holds (for B177 being (net_set of (the carrier of B176) , B175) holds ((B176 in ( NetUniv B175 ) & (for B178 being (Element of B176) holds ( B177 . B178 ) in ( NetUniv B175 ))) implies ( Iterated B177 ) in ( NetUniv B175 )))))
proof
let C286 being non  empty 1-sorted;
let C287 being (net of C286);
let C288 being (net_set of (the carrier of C287) , C286);
assume that
L474: C287 in ( NetUniv C286 )
and
L475: (for B179 being (Element of C287) holds ( C288 . B179 ) in ( NetUniv C286 ));
L476: ( rng ( Carrier C288 ) ) c= ( the_universe_of (the carrier of C286) )
proof
let R1 being set;
assume L477: R1 in ( rng ( Carrier C288 ) );
consider R2 being set such that L478: R2 in ( dom ( Carrier C288 ) ) and L479: ( ( Carrier C288 ) . R2 ) = R1 by L477 , FUNCT_1:def 3;
reconsider D95 = R2 as (Element of C287) by L478;
L480: ( C288 . D95 ) in ( NetUniv C286 ) by L475;
L481: (ex B180 being  strict (net of C286) st (B180 = ( C288 . D95 ) & (the carrier of B180) in ( the_universe_of (the carrier of C286) ))) by L480 , L330;
thus L482: thesis by L481 , L479 , L14;
end;
L483: ( the RelStr of ( Iterated C288 ) ) = [: C287 , ( product C288 ) :] by L455;
L484: (the carrier of ( Iterated C288 )) = [: (the carrier of C287) , (the carrier of ( product C288 )) :] by L483 , YELLOW_3:def 2;
L485: (ex B181 being  strict (net of C286) st (B181 = C287 & (the carrier of B181) in ( the_universe_of (the carrier of C286) ))) by L474 , L330;
L486: ( dom ( Carrier C288 ) ) in ( the_universe_of (the carrier of C286) ) by L485 , PARTFUN1:def 2;
L487: ( product ( Carrier C288 ) ) in ( the_universe_of (the carrier of C286) ) by L486 , L476 , L4;
L488: (the carrier of ( product C288 )) in ( the_universe_of (the carrier of C286) ) by L487 , YELLOW_1:def 4;
L489: (the carrier of ( Iterated C288 )) in ( the_universe_of (the carrier of C286) ) by L488 , L484 , L485 , CLASSES2:61;
thus L490: thesis by L489 , L330;
end;
theorem
L491: (for B182 being non  empty 1-sorted holds (for B183 being (net of B182) holds (for B184 being (net_set of (the carrier of B183) , B182) holds (the carrier of ( Iterated B184 )) = [: (the carrier of B183) , ( product ( Carrier B184 ) ) :])))
proof
let C289 being non  empty 1-sorted;
let C290 being (net of C289);
let C291 being (net_set of (the carrier of C290) , C289);
L492: ( the RelStr of ( Iterated C291 ) ) = [: C290 , ( product C291 ) :] by L455;
thus L493: (the carrier of ( Iterated C291 )) = [: (the carrier of C290) , (the carrier of ( product C291 )) :] by L492 , YELLOW_3:def 2
.= [: (the carrier of C290) , ( product ( Carrier C291 ) ) :] by YELLOW_1:def 4;
end;
theorem
L494: (for B185 being non  empty 1-sorted holds (for B186 being (net of B185) holds (for B187 being (net_set of (the carrier of B186) , B185) holds (for B188 being (Element of B186) holds (for B189 being (Element of ( product B187 )) holds (for B190 being (Element of ( Iterated B187 )) holds (B190 = [ B188 , B189 ] implies ( ( Iterated B187 ) . B190 ) = ( (the mapping of ( B187 . B188 )) . ( B189 . B188 ) ))))))))
proof
let C292 being non  empty 1-sorted;
let C293 being (net of C292);
let C294 being (net_set of (the carrier of C293) , C292);
let C295 being (Element of C293);
let C296 being (Element of ( product C294 ));
let C297 being (Element of ( Iterated C294 ));
assume L495: C297 = [ C295 , C296 ];
thus L496: ( ( Iterated C294 ) . C297 ) = ( (the mapping of ( Iterated C294 )) . (C295 , C296) ) by L495
.= ( (the mapping of ( C294 . C295 )) . ( C296 . C295 ) ) by L455;
end;
theorem
L497: (for B191 being non  empty 1-sorted holds (for B192 being (net of B191) holds (for B193 being (net_set of (the carrier of B192) , B191) holds ( rng (the mapping of ( Iterated B193 )) ) c= ( union { ( rng (the mapping of ( B193 . B194 )) ) where B194 is (Element of B192) : (not contradiction) } ))))
proof
let C298 being non  empty 1-sorted;
let C299 being (net of C298);
let C300 being (net_set of (the carrier of C299) , C298);
let C301 being set;
set D96 = { ( rng (the mapping of ( C300 . B195 )) ) where B195 is (Element of C299) : (not contradiction) };
assume L498: C301 in ( rng (the mapping of ( Iterated C300 )) );
consider C302 being set such that L499: C302 in ( dom (the mapping of ( Iterated C300 )) ) and L500: ( (the mapping of ( Iterated C300 )) . C302 ) = C301 by L498 , FUNCT_1:def 3;
L501: C302 in (the carrier of ( Iterated C300 )) by L499;
L502: C302 in [: (the carrier of C299) , ( product ( Carrier C300 ) ) :] by L501 , L491;
consider C303 being (Element of C299), C304 being (Element of ( product ( Carrier C300 ) )) such that L503: C302 = [ C303 , C304 ] by L502 , DOMAIN_1:1;
L504: C303 in (the carrier of C299);
L505: C303 in ( dom ( Carrier C300 ) ) by L504 , PARTFUN1:def 2;
L506: ( C304 . C303 ) in ( ( Carrier C300 ) . C303 ) by L505 , CARD_3:9;
L507: ( C304 . C303 ) in (the carrier of ( C300 . C303 )) by L506 , L14;
L508: ( C304 . C303 ) in ( dom (the mapping of ( C300 . C303 )) ) by L507 , FUNCT_2:def 1;
L509: C304 in ( product ( Carrier C300 ) );
L510: C304 in (the carrier of ( product C300 )) by L509 , YELLOW_1:def 4;
L511: C301 = ( (the mapping of ( Iterated C300 )) . (C303 , C304) ) by L500 , L503
.= ( (the mapping of ( C300 . C303 )) . ( C304 . C303 ) ) by L510 , L455;
L512: C301 in ( rng (the mapping of ( C300 . C303 )) ) by L511 , L508 , FUNCT_1:def 3;
reconsider D97 = C303 as (Element of C299);
L513: ( rng (the mapping of ( C300 . D97 )) ) in D96;
thus L514: thesis by L513 , L512 , TARSKI:def 4;
end;
begin
definition
let C305 being non  empty TopSpace;
let C306 being (Point of C305);
func OpenNeighborhoods C306 -> RelStr equals 
( ( InclPoset { B196 where B196 is (Subset of C305) : (C306 in B196 & B196 is  open) } ) ~ );
correctness;
end;
registration
let C307 being non  empty TopSpace;
let C308 being (Point of C307);
cluster ( OpenNeighborhoods C308 ) -> non  empty;
coherence
proof
set D98 = { B197 where B197 is (Subset of C307) : (C308 in B197 & B197 is  open) };
L516: ( [#] C307 ) in (the carrier of ( InclPoset D98 ));
thus L517: (the carrier of ( OpenNeighborhoods C308 )) is non  empty by L516;
end;
end;
theorem
L519: (for B198 being non  empty TopSpace holds (for B199 being (Point of B198) holds (for B200 being (Element of ( OpenNeighborhoods B199 )) holds (ex B201 being (Subset of B198) st (B201 = B200 & B199 in B201 & B201 is  open)))))
proof
let C309 being non  empty TopSpace;
let C310 being (Point of C309);
let C311 being (Element of ( OpenNeighborhoods C310 ));
set D99 = { B202 where B202 is (Subset of C309) : (C310 in B202 & B202 is  open) };
L520: C311 in (the carrier of ( ( InclPoset D99 ) ~ ));
L521: C311 in (the carrier of ( InclPoset D99 )) by L520 , L127;
thus L522: thesis by L521;
end;
theorem
L523: (for B203 being non  empty TopSpace holds (for B204 being (Point of B203) holds (for B205 being (Subset of B203) holds (B205 in (the carrier of ( OpenNeighborhoods B204 )) iff (B204 in B205 & B205 is  open)))))
proof
let C312 being non  empty TopSpace;
let C313 being (Point of C312);
let C314 being (Subset of C312);
set D100 = { B206 where B206 is (Subset of C312) : (C313 in B206 & B206 is  open) };
reconsider D101 = C314 as (Subset of C312);
thus L524: (C314 in (the carrier of ( OpenNeighborhoods C313 )) implies (C313 in C314 & C314 is  open))
proof
assume L525: C314 in (the carrier of ( OpenNeighborhoods C313 ));
L526: (ex B207 being (Subset of C312) st (D101 = B207 & C313 in B207 & B207 is  open)) by L525 , L519;
thus L527: thesis by L526;
end;

assume L528: (C313 in C314 & C314 is  open);
L529: C314 in (the carrier of ( InclPoset D100 )) by L528;
thus L530: thesis by L529 , L127;
end;
theorem
L531: (for B208 being non  empty TopSpace holds (for B209 being (Point of B208) holds (for B210 , B211 being (Element of ( OpenNeighborhoods B209 )) holds (B210 <= B211 iff B211 c= B210))))
proof
let C315 being non  empty TopSpace;
let C316 being (Point of C315);
set D102 = { B212 where B212 is (Subset of C315) : (C316 in B212 & B212 is  open) };
L532: ( [#] C315 ) in D102;
reconsider D103 = D102 as non  empty set by L532;
let C317 , C318 being (Element of ( OpenNeighborhoods C316 ));
L533: ( ( InclPoset D103 ) ~ ) = RelStr (# (the carrier of ( InclPoset D103 )) , ( (the InternalRel of ( InclPoset D103 )) ~ ) #) by LATTICE3:def 5;
reconsider D104 = C317 , D105 = C318 as (Element of ( InclPoset D103 )) by L533;
L534: (D105 <= D104 iff C318 c= C317) by YELLOW_1:3;
L535: (C317 = ( D104 ~ ) & C318 = ( D105 ~ )) by LATTICE3:def 6;
thus L536: thesis by L535 , L534 , LATTICE3:9;
end;
registration
let C319 being non  empty TopSpace;
let C320 being (Point of C319);
cluster ( OpenNeighborhoods C320 ) ->  transitive  directed;
coherence
proof
thus L537: ( OpenNeighborhoods C320 ) is  transitive;
let C321 , C322 being (Element of ( OpenNeighborhoods C320 ));
set D106 = { B213 where B213 is (Subset of C319) : (C320 in B213 & B213 is  open) };
consider C323 being (Subset of C319) such that L538: C321 = C323 and L539: (C320 in C323 & C323 is  open) by L519;
consider C324 being (Subset of C319) such that L540: C322 = C324 and L541: (C320 in C324 & C324 is  open) by L519;
set D107 = ( C323 /\ C324 );
L542: (C320 in D107 & D107 is  open) by L539 , L541 , XBOOLE_0:def 4;
L543: D107 in D106 by L542;
reconsider D108 = D107 as (Element of ( OpenNeighborhoods C320 )) by L543 , L127;
L544: D108 c= C322 by L540 , XBOOLE_1:17;
take D108;
L545: D108 c= C321 by L538 , XBOOLE_1:17;
thus L546: thesis by L545 , L544 , L531;
end;
end;
begin
definition
let C325 being non  empty TopSpace;
let C326 being (net of C325);
defpred S4[ (Point of C325) ] means (for B214 being (a_neighborhood of $1) holds C326 is_eventually_in B214);
func Lim C326 -> (Subset of C325) means 
:L548: (for B215 being (Point of C325) holds (B215 in it iff (for B216 being (a_neighborhood of B215) holds C326 is_eventually_in B216)));
existence
proof
consider C327 being (Subset of C325) such that L549: (for B217 being (Point of C325) holds (B217 in C327 iff S4[ B217 ])) from SUBSET_1:sch 3;
take C327;
let C328 being (Point of C325);
thus L550: thesis by L549;
end;
uniqueness
proof
let C329 , C330 being (Subset of C325);
assume that
L551: (for B218 being (Point of C325) holds (B218 in C329 iff S4[ B218 ]))
and
L552: (for B219 being (Point of C325) holds (B219 in C330 iff S4[ B219 ]));
thus L553: thesis from SUBSET_1:sch 4(L551 , L552);
end;
end;
theorem
L555: (for B220 being non  empty TopSpace holds (for B221 being (net of B220) holds (for B222 being (subnet of B221) holds ( Lim B221 ) c= ( Lim B222 ))))
proof
let C331 being non  empty TopSpace;
let C332 being (net of C331);
let C333 being (subnet of C332);
let R1 being set;
consider C334 being (Function of C333 , C332) such that L556: (the mapping of C333) = ( (the mapping of C332) * C334 ) and L557: (for B223 being (Element of C332) holds (ex B224 being (Element of C333) st (for B225 being (Element of C333) holds (B224 <= B225 implies B223 <= ( C334 . B225 ))))) by L219;
assume L558: R1 in ( Lim C332 );
reconsider D109 = R1 as (Point of C331) by L558;
L559: (for B226 being (a_neighborhood of D109) holds C333 is_eventually_in B226)
proof
let C335 being (a_neighborhood of D109);
L560: C332 is_eventually_in C335 by L558 , L548;
consider C336 being (Element of C332) such that L561: (for B227 being (Element of C332) holds (C336 <= B227 implies ( C332 . B227 ) in C335)) by L560 , WAYBEL_0:def 11;
consider C337 being (Element of C333) such that L562: (for B228 being (Element of C333) holds (C337 <= B228 implies C336 <= ( C334 . B228 ))) by L557;
take C337;
let C338 being (Element of C333);
assume L563: C337 <= C338;
L564: ( C332 . ( C334 . C338 ) ) = ( C333 . C338 ) by L556 , FUNCT_2:15;
thus L565: thesis by L564 , L561 , L562 , L563;
end;
thus L566: thesis by L559 , L548;
end;
theorem
L567: (for B229 being non  empty TopSpace holds (for B230 being  constant (net of B229) holds ( the_value_of B230 ) in ( Lim B230 )))
proof
let C339 being non  empty TopSpace;
let C340 being  constant (net of C339);
set D110 = ( the_value_of C340 );
L568: (for B231 being (a_neighborhood of D110) holds C340 is_eventually_in B231)
proof
set D111 = the (Element of C340);
let C341 being (a_neighborhood of D110);
take D111;
let C342 being (Element of C340);
assume that
L569: D111 <= C342;
L570: ( C340 . C342 ) = D110 by L239;
thus L571: thesis by L570 , CONNSP_2:4;
end;
thus L572: thesis by L568 , L548;
end;
theorem
L573: (for B232 being non  empty TopSpace holds (for B233 being (net of B232) holds (for B234 being (Point of B232) holds (B234 in ( Lim B233 ) implies (for B235 being (Element of B233) holds (ex B236 being (Subset of B232) st (B236 = { ( B233 . B237 ) where B237 is (Element of B233) : B235 <= B237 } & B234 in ( Cl B236 ))))))))
proof
let C343 being non  empty TopSpace;
let C344 being (net of C343);
let C345 being (Point of C343);
assume that
L574: C345 in ( Lim C344 );
let C346 being (Element of C344);
L575: { ( C344 . B238 ) where B238 is (Element of C344) : C346 <= B238 } c= (the carrier of C343)
proof
let C347 being set;
assume L576: C347 in { ( C344 . B239 ) where B239 is (Element of C344) : C346 <= B239 };
L577: (ex B240 being (Element of C344) st (C347 = ( C344 . B240 ) & C346 <= B240)) by L576;
thus L578: thesis by L577;
end;
reconsider D112 = { ( C344 . B241 ) where B241 is (Element of C344) : C346 <= B241 } as (Subset of C343) by L575;
take D112;
thus L579: D112 = { ( C344 . B242 ) where B242 is (Element of C344) : C346 <= B242 };
L580:
now
let C348 being (a_neighborhood of C345);
L581: C344 is_eventually_in C348 by L574 , L548;
consider C349 being (Element of C344) such that L582: (for B243 being (Element of C344) holds (C349 <= B243 implies ( C344 . B243 ) in C348)) by L581 , WAYBEL_0:def 11;
consider C350 being (Element of C344) such that L583: C346 <= C350 and L584: C349 <= C350 by L65;
L585: ( C344 . C350 ) in D112 by L583;
L586: ( C344 . C350 ) in C348 by L582 , L584;
thus L587: C348 meets D112 by L586 , L585 , XBOOLE_0:3;
end;
thus L588: thesis by L580 , CONNSP_2:27;
end;
theorem
L589: (for B244 being non  empty TopSpace holds (B244 is  Hausdorff iff (for B245 being (net of B244) holds (for B246 , B247 being (Point of B244) holds ((B246 in ( Lim B245 ) & B247 in ( Lim B245 )) implies B246 = B247)))))
proof
let C351 being non  empty TopSpace;
thus L590: (C351 is  Hausdorff implies (for B248 being (net of C351) holds (for B249 , B250 being (Point of C351) holds ((B249 in ( Lim B248 ) & B250 in ( Lim B248 )) implies B249 = B250))))
proof
assume L591: C351 is  Hausdorff;
let C352 being (net of C351);
given C353 , C354 being (Point of C351) such that
L592: C353 in ( Lim C352 )
and
L593: C354 in ( Lim C352 )
and
L594: C353 <> C354;

consider C355 , C356 being (Subset of C351) such that L595: C355 is  open and L596: C356 is  open and L597: C353 in C355 and L598: C354 in C356 and L599: C355 misses C356 by L591 , L594 , PRE_TOPC:def 10;
L600: C356 is (a_neighborhood of C354) by L596 , L598 , CONNSP_2:3;
L601: C352 is_eventually_in C356 by L600 , L593 , L548;
L602: C355 is (a_neighborhood of C353) by L595 , L597 , CONNSP_2:3;
L603: C352 is_eventually_in C355 by L602 , L592 , L548;
thus L604: contradiction by L603 , L599 , L601 , L242;
end;

assume L605: (for B251 being (net of C351) holds (for B252 , B253 being (Point of C351) holds ((B252 in ( Lim B251 ) & B253 in ( Lim B251 )) implies B252 = B253)));
given C357 , C358 being (Point of C351) such that
L606: C357 <> C358
and
L607: (for B254 , B255 being (Subset of C351) holds ((B254 is  open & B255 is  open & C357 in B254 & C358 in B255) implies B254 meets B255));

set D113 = [: ( OpenNeighborhoods C357 ) , ( OpenNeighborhoods C358 ) :];
set D114 = (the carrier of C351);
set D115 = (the carrier of D113);
deffunc H3((Element of D115)) = ( ( $1 `1 ) /\ ( $1 `2 ) );
L608: (for B256 being (Element of D115) holds D114 meets H3(B256))
proof
let C359 being (Element of D115);
consider C360 being (Subset of C351) such that L609: C360 = ( C359 `1 ) and L610: (C357 in C360 & C360 is  open) by L519;
consider C361 being (Subset of C351) such that L611: C361 = ( C359 `2 ) and L612: (C358 in C361 & C361 is  open) by L519;
L613: ( C359 `1 ) meets ( C359 `2 ) by L607 , L609 , L610 , L611 , L612;
L614: (( C360 /\ C361 ) c= D114 & ( ( C359 `1 ) /\ ( C359 `2 ) ) <> ( {} )) by L613 , XBOOLE_0:def 7;
L615: ( D114 /\ ( ( C359 `1 ) /\ ( C359 `2 ) ) ) <> ( {} ) by L614 , L609 , L611 , XBOOLE_1:28;
thus L616: thesis by L615 , XBOOLE_0:def 7;
end;
consider C362 being (Function of D115 , D114) such that L617: (for B257 being (Element of D115) holds ( C362 . B257 ) in H3(B257)) from FUNCT_2:sch 10(L608);
reconsider D116 = NetStr (# (the carrier of D113) , (the InternalRel of D113) , C362 #) as (net of C351) by L84 , L94;
L618: D115 = [: (the carrier of ( OpenNeighborhoods C357 )) , (the carrier of ( OpenNeighborhoods C358 )) :] by YELLOW_3:def 2;
L619:
now
let C363 being (a_neighborhood of C358);
L620: D116 is_eventually_in ( Int C363 )
proof
L621: ( [#] C351 ) in (the carrier of ( OpenNeighborhoods C357 )) by L523;
L622: (C358 in ( Int C363 ) & ( Int C363 ) is  open) by CONNSP_2:def 1;
L623: ( Int C363 ) in (the carrier of ( OpenNeighborhoods C358 )) by L622 , L523;
reconsider D117 = [ ( [#] C351 ) , ( Int C363 ) ] as (Element of D116) by L623 , L618 , L621 , ZFMISC_1:87;
take D117;
let C364 being (Element of D116);
reconsider D118 = C364 , D119 = D117 as (Element of D113);
consider C365 being (Element of ( OpenNeighborhoods C357 )), C366 being (Element of ( OpenNeighborhoods C358 )) such that L624: C364 = [ C365 , C366 ] by L618 , DOMAIN_1:1;
L625: ( C364 `2 ) = C366 by L624 , MCART_1:7;
consider C367 being (Subset of C351) such that L626: C365 = C367 and L627: C357 in C367 and L628: C367 is  open by L519;
consider C368 being (Subset of C351) such that L629: C366 = C368 and L630: C358 in C368 and L631: C368 is  open by L519;
assume L632: D117 <= C364;
L633: [ D117 , C364 ] in (the InternalRel of D113) by L632 , ORDERS_2:def 5;
L634: D119 <= D118 by L633 , ORDERS_2:def 5;
L635: (( D119 `2 ) = ( Int C363 ) & ( D119 `2 ) <= ( D118 `2 )) by L634 , MCART_1:7 , YELLOW_3:12;
L636: C368 c= ( Int C363 ) by L635 , L625 , L629 , L531;
L637: ( C367 /\ C368 ) c= ( ( Int C363 ) /\ ( [#] C351 ) ) by L636 , XBOOLE_1:27;
L638: ( C364 `1 ) = C365 by L624 , MCART_1:7;
L639: ( C362 . C364 ) in ( C367 /\ C368 ) by L638 , L617 , L625 , L626 , L629;
L640: ( C362 . C364 ) in ( ( Int C363 ) /\ ( [#] C351 ) ) by L639 , L637;
thus L641: thesis by L640 , XBOOLE_1:28;
end;
L642: ( Int C363 ) c= C363 by TOPS_1:16;
thus L643: D116 is_eventually_in C363 by L642 , L620 , WAYBEL_0:8;
end;
L644: C358 in ( Lim D116 ) by L619 , L548;
L645:
now
let C369 being (a_neighborhood of C357);
L646: D116 is_eventually_in ( Int C369 )
proof
L647: ( [#] C351 ) in (the carrier of ( OpenNeighborhoods C358 )) by L523;
L648: (C357 in ( Int C369 ) & ( Int C369 ) is  open) by CONNSP_2:def 1;
L649: ( Int C369 ) in (the carrier of ( OpenNeighborhoods C357 )) by L648 , L523;
reconsider D120 = [ ( Int C369 ) , ( [#] C351 ) ] as (Element of D116) by L649 , L618 , L647 , ZFMISC_1:87;
take D120;
let C370 being (Element of D116);
reconsider D121 = C370 , D122 = D120 as (Element of D113);
consider C371 being (Element of ( OpenNeighborhoods C357 )), C372 being (Element of ( OpenNeighborhoods C358 )) such that L650: C370 = [ C371 , C372 ] by L618 , DOMAIN_1:1;
L651: ( C370 `1 ) = C371 by L650 , MCART_1:7;
consider C373 being (Subset of C351) such that L652: C372 = C373 and L653: C358 in C373 and L654: C373 is  open by L519;
consider C374 being (Subset of C351) such that L655: C371 = C374 and L656: C357 in C374 and L657: C374 is  open by L519;
assume L658: D120 <= C370;
L659: [ D120 , C370 ] in (the InternalRel of D113) by L658 , ORDERS_2:def 5;
L660: D122 <= D121 by L659 , ORDERS_2:def 5;
L661: (( D122 `1 ) = ( Int C369 ) & ( D122 `1 ) <= ( D121 `1 )) by L660 , MCART_1:7 , YELLOW_3:12;
L662: C374 c= ( Int C369 ) by L661 , L651 , L655 , L531;
L663: ( C374 /\ C373 ) c= ( ( Int C369 ) /\ ( [#] C351 ) ) by L662 , XBOOLE_1:27;
L664: ( C370 `2 ) = C372 by L650 , MCART_1:7;
L665: ( C362 . C370 ) in ( C374 /\ C373 ) by L664 , L617 , L651 , L655 , L652;
L666: ( C362 . C370 ) in ( ( Int C369 ) /\ ( [#] C351 ) ) by L665 , L663;
thus L667: thesis by L666 , XBOOLE_1:28;
end;
L668: ( Int C369 ) c= C369 by TOPS_1:16;
thus L669: D116 is_eventually_in C369 by L668 , L646 , WAYBEL_0:8;
end;
L670: C357 in ( Lim D116 ) by L645 , L548;
thus L671: contradiction by L670 , L605 , L606 , L644;
end;
registration
let C375 being  Hausdorff non  empty TopSpace;
let C376 being (net of C375);
cluster ( Lim C376 ) ->  trivial;
coherence
proof
L672: (for B258 , B259 being (Point of C375) holds ((B258 in ( Lim C376 ) & B259 in ( Lim C376 )) implies B258 = B259)) by L589;
thus L673: thesis by L672 , SUBSET_1:45;
end;
end;
definition
let C377 being non  empty TopSpace;
let C378 being (net of C377);
attr C378 is  convergent
means
:L675: ( Lim C378 ) <> ( {} );
end;
registration
let C379 being non  empty TopSpace;
cluster  constant ->  convergent for (net of C379);
coherence
proof
let C380 being (net of C379);
assume L677: C380 is  constant;
thus L678: ( Lim C380 ) <> ( {} ) by L677 , L567;
end;
end;
registration
let C381 being non  empty TopSpace;
cluster  convergent  strict for (net of C381);
existence
proof
set D123 = the non  empty  transitive  directed RelStr;
set D124 = the (Point of C381);
take ( ConstantNet (D123 , D124) );
thus L680: thesis;
end;
end;
definition
let C382 being  Hausdorff non  empty TopSpace;
let C383 being  convergent (net of C382);
func lim C383 -> (Element of C382) means 
:L682: it in ( Lim C383 );
existence
proof
L683: ( Lim C383 ) <> ( {} ) by L675;
consider C384 being (Point of C382) such that L684: C384 in ( Lim C383 ) by L683 , SUBSET_1:4;
take C384;
thus L685: thesis by L684;
end;
correctness by ZFMISC_1:def 10;
end;
theorem
L687: (for B260 being  Hausdorff non  empty TopSpace holds (for B261 being  constant (net of B260) holds ( lim B261 ) = ( the_value_of B261 )))
proof
let C385 being  Hausdorff non  empty TopSpace;
let C386 being  constant (net of C385);
L688: ( the_value_of C386 ) in ( Lim C386 ) by L567;
thus L689: thesis by L688 , L682;
end;
theorem
L690: (for B262 being non  empty TopSpace holds (for B263 being (net of B262) holds (for B264 being (Point of B262) holds ((not B264 in ( Lim B263 )) implies (ex B265 being (subnet of B263) st (not (ex B266 being (subnet of B265) st B264 in ( Lim B266 ))))))))
proof
let C387 being non  empty TopSpace;
let C388 being (net of C387);
let C389 being (Point of C387);
assume L691: (not C389 in ( Lim C388 ));
consider C390 being (a_neighborhood of C389) such that L692: (not C388 is_eventually_in C390) by L691 , L548;
L693: C388 is_often_in ( (the carrier of C387) \ C390 ) by L692 , WAYBEL_0:9;
reconsider D125 = ( C388 " ( (the carrier of C387) \ C390 ) ) as (subnet of C388) by L693 , L308;
take D125;
let C391 being (subnet of D125);
assume L694: C389 in ( Lim C391 );
L695: C391 is_eventually_in C390 by L694 , L548;
L696: D125 is_often_in C390 by L695 , L252 , L261;
L697: D125 is_eventually_in ( (the carrier of C387) \ C390 ) by L322;
thus L698: contradiction by L697 , L696 , WAYBEL_0:10;
end;
theorem
L699: (for B267 being non  empty TopSpace holds (for B268 being (net of B267) holds (B268 in ( NetUniv B267 ) implies (for B269 being (Point of B267) holds ((not B269 in ( Lim B268 )) implies (ex B270 being (subnet of B268) st (B270 in ( NetUniv B267 ) & (not (ex B271 being (subnet of B270) st B269 in ( Lim B271 ))))))))))
proof
let C392 being non  empty TopSpace;
let C393 being (net of C392);
assume L700: C393 in ( NetUniv C392 );
L701: (ex B272 being  strict (net of C392) st (B272 = C393 & (the carrier of B272) in ( the_universe_of (the carrier of C392) ))) by L700 , L330;
let C394 being (Point of C392);
assume L702: (not C394 in ( Lim C393 ));
consider C395 being (a_neighborhood of C394) such that L703: (not C393 is_eventually_in C395) by L702 , L548;
L704: C393 is_often_in ( (the carrier of C392) \ C395 ) by L703 , WAYBEL_0:9;
reconsider D126 = ( C393 " ( (the carrier of C392) \ C395 ) ) as (subnet of C393) by L704 , L308;
take D126;
L705: (the carrier of D126) = ( (the mapping of C393) " ( (the carrier of C392) \ C395 ) ) by L268;
L706: (the carrier of D126) in ( the_universe_of (the carrier of C392) ) by L705 , L701 , CLASSES1:def 1;
thus L707: D126 in ( NetUniv C392 ) by L706 , L330;
let C396 being (subnet of D126);
assume L708: C394 in ( Lim C396 );
L709: C396 is_eventually_in C395 by L708 , L548;
L710: D126 is_often_in C395 by L709 , L252 , L261;
L711: D126 is_eventually_in ( (the carrier of C392) \ C395 ) by L322;
thus L712: contradiction by L711 , L710 , WAYBEL_0:10;
end;
theorem
L713: (for B273 being non  empty TopSpace holds (for B274 being (net of B273) holds (for B275 being (Point of B273) holds (B275 in ( Lim B274 ) implies (for B276 being (net_set of (the carrier of B274) , B273) holds ((for B277 being (Element of B274) holds ( B274 . B277 ) in ( Lim ( B276 . B277 ) )) implies B275 in ( Lim ( Iterated B276 ) )))))))
proof
let C397 being non  empty TopSpace;
let C398 being (net of C397);
let C399 being (Point of C397);
assume that
L714: C399 in ( Lim C398 );
let C400 being (net_set of (the carrier of C398) , C397);
assume that
L715: (for B278 being (Element of C398) holds ( C398 . B278 ) in ( Lim ( C400 . B278 ) ));
L716: (for B279 being (a_neighborhood of C399) holds ( Iterated C400 ) is_eventually_in B279)
proof
let C401 being (a_neighborhood of C399);
L717: C399 in ( Int ( Int C401 ) ) by CONNSP_2:def 1;
reconsider D127 = ( Int C401 ) as (a_neighborhood of C399) by L717 , CONNSP_2:def 1;
L718: C398 is_eventually_in D127 by L714 , L548;
consider C402 being (Element of C398) such that L719: (for B280 being (Element of C398) holds (C402 <= B280 implies ( C398 . B280 ) in D127)) by L718 , WAYBEL_0:def 11;
defpred S5[ (Element of C398) , set ] means (ex B281 being (Element of ( C400 . $1 )) st (B281 = $2 & (C402 <= $1 implies (for B282 being (Element of ( C400 . $1 )) holds (B281 <= B282 implies ( ( C400 . $1 ) . B282 ) in D127)))));
L720: ( Int C401 ) = ( Int ( Int C401 ) );
L721: (for B283 being (Element of C398) holds (ex B284 being set st S5[ B283 , B284 ]))
proof
let C403 being (Element of C398);
reconsider D128 = C403 as (Element of C398);
per cases ;
suppose L722: C402 <= C403;

L723: ( C398 . D128 ) in D127 by L722 , L719;
L724: D127 is (a_neighborhood of ( C398 . C403 )) by L723 , L720 , CONNSP_2:def 1;
L725: ( C398 . C403 ) in ( Lim ( C400 . C403 ) ) by L715;
L726: ( C400 . C403 ) is_eventually_in D127 by L725 , L724 , L548;
consider C404 being (Element of ( C400 . C403 )) such that L727: (for B285 being (Element of ( C400 . C403 )) holds (C404 <= B285 implies ( ( C400 . C403 ) . B285 ) in D127)) by L726 , WAYBEL_0:def 11;
take C404;
take C404;
thus L728: C404 = C404;
assume L729: C402 <= C403;
thus L730: thesis by L727;
end;
suppose L731: (not C402 <= C403);

set D129 = the (Element of ( C400 . C403 ));
take D129;
take D129;
thus L732: thesis by L731;
end;
end;
consider C405 being (ManySortedSet of (the carrier of C398)) such that L734: (for B286 being (Element of C398) holds S5[ B286 , ( C405 . B286 ) ]) from PBOOLE:sch 6(L721);
L735: (for R1 being set holds (R1 in ( dom ( Carrier C400 ) ) implies ( C405 . R1 ) in ( ( Carrier C400 ) . R1 )))
proof
let R1 being set;
assume L736: R1 in ( dom ( Carrier C400 ) );
reconsider D130 = R1 as (Element of C398) by L736;
L737: (ex B287 being (Element of ( C400 . D130 )) st (B287 = ( C405 . D130 ) & (C402 <= D130 implies (for B288 being (Element of ( C400 . D130 )) holds (B287 <= B288 implies ( ( C400 . D130 ) . B288 ) in D127))))) by L734;
L738: ( C405 . R1 ) in (the carrier of ( C400 . D130 )) by L737;
thus L739: thesis by L738 , L14;
end;
L740: ( dom ( Carrier C400 ) ) = (the carrier of C398) by PARTFUN1:def 2;
L741: ( dom C405 ) = ( dom ( Carrier C400 ) ) by L740 , PARTFUN1:def 2;
L742: C405 in ( product ( Carrier C400 ) ) by L741 , L735 , CARD_3:9;
L743: (the carrier of ( Iterated C400 )) = [: (the carrier of C398) , ( product ( Carrier C400 ) ) :] by L491;
reconsider D131 = [ C402 , C405 ] as (Element of ( Iterated C400 )) by L743 , L742 , ZFMISC_1:87;
take D131;
let C406 being (Element of ( Iterated C400 ));
assume that
L744: D131 <= C406;
consider C407 being (Element of C398), C408 being (Element of ( product ( Carrier C400 ) )) such that L745: C406 = [ C407 , C408 ] by L743 , DOMAIN_1:1;
reconsider D132 = C408 , D133 = C405 as (Element of ( product C400 )) by L742 , YELLOW_1:def 4;
reconsider D134 = C402 , D135 = C407 as (Element of C398);
L746: D133 in (the carrier of ( product C400 ));
L747: D133 in ( product ( Carrier C400 ) ) by L746 , YELLOW_1:def 4;
L748: ( the RelStr of ( Iterated C400 ) ) = [: C398 , ( product C400 ) :] by L455;
L749: [ D134 , D133 ] <= [ D135 , D132 ] by L748 , L744 , L745 , YELLOW_0:1;
L750: D133 <= D132 by L749 , YELLOW_3:11;
L751: (ex B289 , B290 being Function st (B289 = D133 & B290 = D132 & (for B291 being set holds (B291 in (the carrier of C398) implies (ex B292 being RelStr st (ex B293 , B294 being (Element of B292) st (B292 = ( C400 . B291 ) & B293 = ( B289 . B291 ) & B294 = ( B290 . B291 ) & B293 <= B294))))))) by L750 , L747 , YELLOW_1:def 4;
L752: (ex B295 being RelStr st (ex B296 , B297 being (Element of B295) st (B295 = ( C400 . D135 ) & B296 = ( D133 . D135 ) & B297 = ( D132 . D135 ) & B296 <= B297))) by L751;
L753: (ex B298 being (Element of ( C400 . D135 )) st (B298 = ( C405 . D135 ) & (C402 <= D135 implies (for B299 being (Element of ( C400 . D135 )) holds (B298 <= B299 implies ( ( C400 . D135 ) . B299 ) in D127))))) by L734;
L754: ( ( C400 . D135 ) . ( D132 . D135 ) ) in D127 by L753 , L749 , L752 , YELLOW_3:11;
L755: ( ( Iterated C400 ) . C406 ) in D127 by L754 , L745 , L494;
L756: D127 c= C401 by TOPS_1:16;
thus L757: thesis by L756 , L755;
end;
thus L758: thesis by L716 , L548;
end;
begin
definition
let C409 being non  empty 1-sorted;
mode Convergence-Class of C409
means :L759: it c= [: ( NetUniv C409 ) , (the carrier of C409) :];
existence;
end;
registration
let C410 being non  empty 1-sorted;
cluster  ->  Relation-like for (Convergence-Class of C410);
coherence
proof
let C411 being (Convergence-Class of C410);
L761: C411 is (Subset of [: ( NetUniv C410 ) , (the carrier of C410) :]) by L759;
thus L762: thesis by L761;
end;
end;
definition
let C412 being non  empty TopSpace;
func Convergence C412 -> (Convergence-Class of C412) means 
:L764: (for B300 being (net of C412) holds (for B301 being (Point of C412) holds ([ B300 , B301 ] in it iff (B300 in ( NetUniv C412 ) & B301 in ( Lim B300 )))));
existence
proof
defpred S6[ set , set ] means (ex B302 being (net of C412) st (ex B303 being (Point of C412) st (B302 = $1 & B303 = $2 & B303 in ( Lim B302 ))));
consider C413 being (Relation of ( NetUniv C412 ) , (the carrier of C412)) such that L765: (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in C413 iff (R1 in ( NetUniv C412 ) & R2 in (the carrier of C412) & S6[ R1 , R2 ])))) from RELSET_1:sch 1;
reconsider D136 = C413 as (Convergence-Class of C412) by L759;
take D136;
let C414 being (net of C412);
let C415 being (Point of C412);
thus L766:now
assume L767: [ C414 , C415 ] in D136;
thus L768: C414 in ( NetUniv C412 ) by L767 , L765;
L769: (ex B304 being (net of C412) st (ex B305 being (Point of C412) st (B304 = C414 & B305 = C415 & B305 in ( Lim B304 )))) by L765 , L767;
thus L770: C415 in ( Lim C414 ) by L769;
end;
thus L771: thesis by L765;
end;
uniqueness
proof
let C416 , C417 being (Convergence-Class of C412);
assume that
L772: (for B306 being (net of C412) holds (for B307 being (Point of C412) holds ([ B306 , B307 ] in C416 iff (B306 in ( NetUniv C412 ) & B307 in ( Lim B306 )))))
and
L773: (for B308 being (net of C412) holds (for B309 being (Point of C412) holds ([ B308 , B309 ] in C417 iff (B308 in ( NetUniv C412 ) & B309 in ( Lim B308 )))));
let R1 being set;
let R2 being set;
L774: C416 c= [: ( NetUniv C412 ) , (the carrier of C412) :] by L759;
thus L775: ([ R1 , R2 ] in C416 implies [ R1 , R2 ] in C417)
proof
assume L776: [ R1 , R2 ] in C416;
reconsider D137 = R2 as (Point of C412) by L776 , L774 , ZFMISC_1:87;
L777: R1 in ( NetUniv C412 ) by L774 , L776 , ZFMISC_1:87;
consider C418 being  strict (net of C412) such that L778: C418 = R1 and L779: (the carrier of C418) in ( the_universe_of (the carrier of C412) ) by L777 , L330;
L780: [ C418 , D137 ] in C416 by L776 , L778;
L781: C418 in ( NetUniv C412 ) by L780 , L772;
L782: D137 in ( Lim C418 ) by L772 , L776 , L778;
thus L783: thesis by L782 , L773 , L778 , L781;
end;

assume L784: [ R1 , R2 ] in C417;
L785: C417 c= [: ( NetUniv C412 ) , (the carrier of C412) :] by L759;
reconsider D138 = R2 as (Point of C412) by L785 , L784 , ZFMISC_1:87;
L786: R1 in ( NetUniv C412 ) by L785 , L784 , ZFMISC_1:87;
consider C419 being  strict (net of C412) such that L787: C419 = R1 and L788: (the carrier of C419) in ( the_universe_of (the carrier of C412) ) by L786 , L330;
L789: [ C419 , D138 ] in C417 by L784 , L787;
L790: C419 in ( NetUniv C412 ) by L789 , L773;
L791: D138 in ( Lim C419 ) by L773 , L784 , L787;
thus L792: thesis by L791 , L772 , L787 , L790;
end;
end;
definition
let C420 being non  empty 1-sorted;
let C421 being (Convergence-Class of C420);
attr C421 is  (CONSTANTS)
means
:L794: (for B310 being  constant (net of C420) holds (B310 in ( NetUniv C420 ) implies [ B310 , ( the_value_of B310 ) ] in C421));
attr C421 is  (SUBNETS)
means
:L795: (for B311 being (net of C420) holds (for B312 being (subnet of B311) holds (B312 in ( NetUniv C420 ) implies (for B313 being (Element of C420) holds ([ B311 , B313 ] in C421 implies [ B312 , B313 ] in C421)))));
attr C421 is  (DIVERGENCE)
means
:L796: (for B314 being (net of C420) holds (for B315 being (Element of C420) holds ((B314 in ( NetUniv C420 ) & (not [ B314 , B315 ] in C421)) implies (ex B316 being (subnet of B314) st (B316 in ( NetUniv C420 ) & (not (ex B317 being (subnet of B316) st [ B317 , B315 ] in C421)))))));
attr C421 is  (ITERATED_LIMITS)
means
:L797: (for B318 being (net of C420) holds (for B319 being (Element of C420) holds ([ B318 , B319 ] in C421 implies (for B320 being (net_set of (the carrier of B318) , C420) holds ((for B321 being (Element of B318) holds [ ( B320 . B321 ) , ( B318 . B321 ) ] in C421) implies [ ( Iterated B320 ) , B319 ] in C421)))));
end;
registration
let C422 being non  empty TopSpace;
cluster ( Convergence C422 ) ->  (CONSTANTS)  (SUBNETS)  (DIVERGENCE)  (ITERATED_LIMITS);
coherence
proof
set D139 = ( Convergence C422 );
thus L799: D139 is  (CONSTANTS)
proof
let C423 being  constant (net of C422);
assume that
L800: C423 in ( NetUniv C422 );
L801: ( the_value_of C423 ) in ( Lim C423 ) by L567;
thus L802: thesis by L801 , L800 , L764;
end;

thus L803: D139 is  (SUBNETS)
proof
let C424 being (net of C422);
let C425 being (subnet of C424);
assume that
L804: C425 in ( NetUniv C422 );
let C426 being (Element of C422);
assume L805: [ C424 , C426 ] in D139;
L806: C426 in ( Lim C424 ) by L805 , L764;
L807: ( Lim C424 ) c= ( Lim C425 ) by L555;
thus L808: thesis by L807 , L804 , L806 , L764;
end;

thus L809: D139 is  (DIVERGENCE)
proof
let C427 being (net of C422);
let C428 being (Element of C422);
assume that
L810: C427 in ( NetUniv C422 );
assume L811: (not [ C427 , C428 ] in D139);
L812: (not C428 in ( Lim C427 )) by L811 , L810 , L764;
consider C429 being (subnet of C427) such that L813: C429 in ( NetUniv C422 ) and L814: (not (ex B322 being (subnet of C429) st C428 in ( Lim B322 ))) by L812 , L810 , L699;
take C429;
thus L815: C429 in ( NetUniv C422 ) by L813;
let C430 being (subnet of C429);
L816: (not C428 in ( Lim C430 )) by L814;
thus L817: thesis by L816 , L764;
end;

let C431 being (net of C422);
let C432 being (Element of C422);
assume L818: [ C431 , C432 ] in D139;
let C433 being (net_set of (the carrier of C431) , C422);
assume that
L819: (for B323 being (Element of C431) holds [ ( C433 . B323 ) , ( C431 . B323 ) ] in D139);
L820:
now
let C434 being (Element of C431);
L821: [ ( C433 . C434 ) , ( C431 . C434 ) ] in D139 by L819;
thus L822: (( C431 . C434 ) in ( Lim ( C433 . C434 ) ) & ( C433 . C434 ) in ( NetUniv C422 )) by L821 , L764;
end;
L823: C431 in ( NetUniv C422 ) by L818 , L764;
L824: ( Iterated C433 ) in ( NetUniv C422 ) by L823 , L820 , L473;
L825: C432 in ( Lim C431 ) by L818 , L764;
L826: C432 in ( Lim ( Iterated C433 ) ) by L825 , L820 , L713;
thus L827: thesis by L826 , L824 , L764;
end;
end;
definition
let C435 being non  empty 1-sorted;
let C436 being (Convergence-Class of C435);
func ConvergenceSpace C436 ->  strict TopStruct means 
:L829: ((the carrier of it) = (the carrier of C435) & (the topology of it) = { B324 where B324 is (Subset of C435) : (for B325 being (Element of C435) holds (B325 in B324 implies (for B326 being (net of C435) holds ([ B326 , B325 ] in C436 implies B326 is_eventually_in B324)))) });
existence
proof
defpred S7[ set ] means (for B327 being (Element of C435) holds (B327 in $1 implies (for B328 being (net of C435) holds ([ B328 , B327 ] in C436 implies B328 is_eventually_in $1))));
reconsider D140 = { B329 where B329 is (Subset of C435) : S7[ B329 ] } as (Subset-Family of C435) from DOMAIN_1:sch 7;
take TopStruct (# (the carrier of C435) , D140 #);
thus L830: thesis;
end;
correctness;
end;
registration
let C437 being non  empty 1-sorted;
let C438 being (Convergence-Class of C437);
cluster ( ConvergenceSpace C438 ) -> non  empty;
coherence
proof
L832: (the carrier of ( ConvergenceSpace C438 )) = (the carrier of C437) by L829;
thus L833: (the carrier of ( ConvergenceSpace C438 )) is non  empty by L832;
end;
end;
registration
let C439 being non  empty 1-sorted;
let C440 being (Convergence-Class of C439);
cluster ( ConvergenceSpace C440 ) ->  TopSpace-like;
coherence
proof
set D141 = ( ConvergenceSpace C440 );
L835: (the topology of D141) = { B330 where B330 is (Subset of C439) : (for B331 being (Element of C439) holds (B331 in B330 implies (for B332 being (net of C439) holds ([ B332 , B331 ] in C440 implies B332 is_eventually_in B330)))) } by L829;
reconsider D142 = ( [#] D141 ) as (Subset of C439) by L829;
L836: D142 = (the carrier of C439) by L829;
L837: (for B333 being (Element of C439) holds (B333 in D142 implies (for B334 being (net of C439) holds ([ B334 , B333 ] in C440 implies B334 is_eventually_in D142)))) by L836 , L265;
thus L838: (the carrier of D141) in (the topology of D141) by L837 , L835;
thus L839:now
let C441 being (Subset-Family of D141);
assume that
L840: C441 c= (the topology of D141);
reconsider D143 = ( union C441 ) as (Subset of C439) by L829;
L841:
now
let C442 being (Element of C439);
assume L842: C442 in D143;
consider R4 being set such that L843: C442 in R4 and L844: R4 in C441 by L842 , TARSKI:def 4;
L845: R4 c= D143 by L844 , ZFMISC_1:74;
L846: R4 in (the topology of D141) by L840 , L844;
L847: (ex B335 being (Subset of C439) st (R4 = B335 & (for B336 being (Element of C439) holds (B336 in B335 implies (for B337 being (net of C439) holds ([ B337 , B336 ] in C440 implies B337 is_eventually_in B335)))))) by L846 , L835;
let C443 being (net of C439);
assume L848: [ C443 , C442 ] in C440;
thus L849: C443 is_eventually_in D143 by L848 , L843 , L847 , L845 , WAYBEL_0:8;
end;
thus L850: ( union C441 ) in (the topology of D141) by L841 , L835;
end;
let C444 , C445 being (Subset of D141);
assume L851: C444 in (the topology of D141);
consider C446 being (Subset of C439) such that L852: C444 = C446 and L853: (for B338 being (Element of C439) holds (B338 in C446 implies (for B339 being (net of C439) holds ([ B339 , B338 ] in C440 implies B339 is_eventually_in C446)))) by L851 , L835;
reconsider D144 = ( C444 /\ C445 ) as (Subset of C439) by L829;
assume L854: C445 in (the topology of D141);
consider C447 being (Subset of C439) such that L855: C445 = C447 and L856: (for B340 being (Element of C439) holds (B340 in C447 implies (for B341 being (net of C439) holds ([ B341 , B340 ] in C440 implies B341 is_eventually_in C447)))) by L854 , L835;
L857:
now
let C448 being (Element of C439);
assume that
L858: C448 in D144;
let C449 being (net of C439);
assume L859: [ C449 , C448 ] in C440;
L860: C448 in C445 by L858 , XBOOLE_0:def 4;
L861: C449 is_eventually_in C447 by L860 , L855 , L856 , L859;
consider C450 being (Element of C449) such that L862: (for B342 being (Element of C449) holds (C450 <= B342 implies ( C449 . B342 ) in C447)) by L861 , WAYBEL_0:def 11;
L863: C448 in C444 by L858 , XBOOLE_0:def 4;
L864: C449 is_eventually_in C446 by L863 , L852 , L853 , L859;
consider C451 being (Element of C449) such that L865: (for B343 being (Element of C449) holds (C451 <= B343 implies ( C449 . B343 ) in C446)) by L864 , WAYBEL_0:def 11;
consider C452 being (Element of C449) such that L866: C451 <= C452 and L867: C450 <= C452 by L65;
thus L868: C449 is_eventually_in D144
proof
take C452;
let C453 being (Element of C449);
assume L869: C452 <= C453;
L870: C450 <= C453 by L869 , L867 , YELLOW_0:def 2;
L871: ( C449 . C453 ) in C447 by L870 , L862;
L872: C451 <= C453 by L866 , L869 , YELLOW_0:def 2;
L873: ( C449 . C453 ) in C446 by L872 , L865;
thus L874: thesis by L873 , L852 , L855 , L871 , XBOOLE_0:def 4;
end;

end;
thus L869: thesis by L857 , L835;
end;
end;
theorem
L871: (for B344 being non  empty 1-sorted holds (for B345 being (Convergence-Class of B344) holds B345 c= ( Convergence ( ConvergenceSpace B345 ) )))
proof
let C454 being non  empty 1-sorted;
let C455 being (Convergence-Class of C454);
set D145 = ( ConvergenceSpace C455 );
let R1 being set;
let R2 being set;
assume L872: [ R1 , R2 ] in C455;
L873: C455 c= [: ( NetUniv C454 ) , (the carrier of C454) :] by L759;
consider C456 being (Element of ( NetUniv C454 )), C457 being (Element of C454) such that L874: [ R1 , R2 ] = [ C456 , C457 ] by L873 , L872 , DOMAIN_1:1;
reconsider D146 = C457 as (Point of D145) by L829;
L875: ((the carrier of C454) = (the carrier of D145) & C456 in ( NetUniv C454 )) by L829;
L876: (ex B346 being  strict (net of C454) st (B346 = C456 & (the carrier of B346) in ( the_universe_of (the carrier of C454) ))) by L330;
reconsider D147 = C456 as (net of C454) by L876;
reconsider D148 = D147 as (net of D145) by L829;
L877: (the topology of D145) = { B347 where B347 is (Subset of C454) : (for B348 being (Element of C454) holds (B348 in B347 implies (for B349 being (net of C454) holds ([ B349 , B348 ] in C455 implies B349 is_eventually_in B347)))) } by L829;
L878:
now
let C458 being (a_neighborhood of D146);
L879: ( Int C458 ) in (the topology of D145) by PRE_TOPC:def 2;
L880: (C457 in ( Int C458 ) & (ex B350 being (Subset of C454) st (B350 = ( Int C458 ) & (for B351 being (Element of C454) holds (B351 in B350 implies (for B352 being (net of C454) holds ([ B352 , B351 ] in C455 implies B352 is_eventually_in B350))))))) by L879 , L877 , CONNSP_2:def 1;
L881: D147 is_eventually_in ( Int C458 ) by L880 , L872 , L874;
consider C459 being (Element of D147) such that L882: (for B353 being (Element of D147) holds (C459 <= B353 implies ( D147 . B353 ) in ( Int C458 ))) by L881 , WAYBEL_0:def 11;
reconsider D149 = C459 as (Element of D148);
L883:
now
let C460 being (Element of D148);
assume that
L884: D149 <= C460;
reconsider D150 = C460 as (Element of D147);
L885: ( D147 . D150 ) = ( D148 . C460 );
thus L886: ( D148 . C460 ) in ( Int C458 ) by L885 , L882 , L884;
end;
L887: (( Int C458 ) c= C458 & D148 is_eventually_in ( Int C458 )) by L883 , TOPS_1:16 , WAYBEL_0:def 11;
thus L888: D148 is_eventually_in C458 by L887 , WAYBEL_0:8;
end;
L889: C457 in ( Lim D148 ) by L878 , L548;
L890: D148 in ( NetUniv D145 ) by L875 , L373;
thus L891: thesis by L890 , L874 , L889 , L764;
end;
definition
let C461 being non  empty 1-sorted;
let C462 being (Convergence-Class of C461);
attr C462 is  topological
means
:L892: C462 is  (CONSTANTS)  (SUBNETS)  (DIVERGENCE)  (ITERATED_LIMITS);
end;
registration
let C463 being non  empty 1-sorted;
cluster non  empty  topological for (Convergence-Class of C463);
existence
proof
reconsider D151 = [: ( NetUniv C463 ) , (the carrier of C463) :] as (Convergence-Class of C463) by L759;
take D151;
thus L894: D151 is non  empty;
thus L895: D151 is  topological
proof
thus L896: D151 is  (CONSTANTS)
proof
let C464 being  constant (net of C463);
thus L897: thesis by ZFMISC_1:87;
end;

thus L898: D151 is  (SUBNETS)
proof
let C465 being (net of C463);
let C466 being (subnet of C465);
thus L899: thesis by ZFMISC_1:87;
end;

thus L900: D151 is  (DIVERGENCE)
proof
let C467 being (net of C463);
let C468 being (Element of C463);
thus L901: thesis by ZFMISC_1:87;
end;

let C469 being (net of C463);
let C470 being (Element of C463);
assume L902: [ C469 , C470 ] in D151;
L903: C469 in ( NetUniv C463 ) by L902 , ZFMISC_1:87;
let C471 being (net_set of (the carrier of C469) , C463);
assume that
L904: (for B354 being (Element of C469) holds [ ( C471 . B354 ) , ( C469 . B354 ) ] in D151);
L905:
now
let C472 being (Element of C469);
L906: [ ( C471 . C472 ) , ( C469 . C472 ) ] in D151 by L904;
thus L907: ( C471 . C472 ) in ( NetUniv C463 ) by L906 , ZFMISC_1:87;
end;
L908: ( Iterated C471 ) in ( NetUniv C463 ) by L905 , L903 , L473;
thus L909: thesis by L908 , ZFMISC_1:87;
end;

end;
end;
registration
let C473 being non  empty 1-sorted;
cluster  topological ->  (CONSTANTS)  (SUBNETS)  (DIVERGENCE)  (ITERATED_LIMITS) for (Convergence-Class of C473);
coherence by L892;
cluster  (CONSTANTS)  (SUBNETS)  (DIVERGENCE)  (ITERATED_LIMITS) ->  topological for (Convergence-Class of C473);
coherence by L892;
end;
theorem
L898: (for B355 being non  empty 1-sorted holds (for B356 being  topological (Convergence-Class of B355) holds (for B357 being (Subset of (( ConvergenceSpace B356 ) qua non  empty TopSpace)) holds (B357 is  open iff (for B358 being (Element of B355) holds (B358 in B357 implies (for B359 being (net of B355) holds ([ B359 , B358 ] in B356 implies B359 is_eventually_in B357))))))))
proof
let C474 being non  empty 1-sorted;
let C475 being  topological (Convergence-Class of C474);
let C476 being (Subset of ( ConvergenceSpace C475 ));
L899: (the topology of ( ConvergenceSpace C475 )) = { B360 where B360 is (Subset of C474) : (for B361 being (Element of C474) holds (B361 in B360 implies (for B362 being (net of C474) holds ([ B362 , B361 ] in C475 implies B362 is_eventually_in B360)))) } by L829;
L900: (C476 in (the topology of ( ConvergenceSpace C475 )) implies (ex B363 being (Subset of C474) st (C476 = B363 & (for B364 being (Element of C474) holds (B364 in B363 implies (for B365 being (net of C474) holds ([ B365 , B364 ] in C475 implies B365 is_eventually_in B363))))))) by L899;
L901: (the carrier of ( ConvergenceSpace C475 )) = (the carrier of C474) by L829;
L902: ((for B366 being (Element of C474) holds (B366 in C476 implies (for B367 being (net of C474) holds ([ B367 , B366 ] in C475 implies B367 is_eventually_in C476)))) implies C476 in (the topology of ( ConvergenceSpace C475 ))) by L901 , L899;
thus L903: thesis by L902 , L900 , PRE_TOPC:def 2;
end;
theorem
L904: (for B368 being non  empty 1-sorted holds (for B369 being  topological (Convergence-Class of B368) holds (for B370 being (Subset of (( ConvergenceSpace B369 ) qua non  empty TopSpace)) holds (B370 is  closed iff (for B371 being (Element of B368) holds (for B372 being (net of B368) holds (([ B372 , B371 ] in B369 & B372 is_often_in B370) implies B371 in B370)))))))
proof
let C477 being non  empty 1-sorted;
let C478 being  topological (Convergence-Class of C477);
let C479 being (Subset of ( ConvergenceSpace C478 ));
set D152 = ( ConvergenceSpace C478 );
L905: (the carrier of C477) = (the carrier of D152) by L829;
thus L906:now
assume L907: C479 is  closed;
L908: ( C479 ` ) is  open by L907;
let C480 being (Element of C477);
let C481 being (net of C477);
assume that
L909: [ C481 , C480 ] in C478;
assume L910: C481 is_often_in C479;
L911: (not C481 is_eventually_in ( ( [#] D152 ) \ C479 )) by L910 , L905 , WAYBEL_0:10;
L912: (not C480 in ( C479 ` )) by L911 , L909 , L908 , L898;
thus L913: C480 in C479 by L912 , L905 , XBOOLE_0:def 5;
end;
assume L914: (for B373 being (Element of C477) holds (for B374 being (net of C477) holds (([ B374 , B373 ] in C478 & B374 is_often_in C479) implies B373 in C479)));
L915:
now
let C482 being (Element of C477);
assume L916: C482 in ( C479 ` );
L917: (not C482 in C479) by L916 , XBOOLE_0:def 5;
let C483 being (net of C477);
assume L918: [ C483 , C482 ] in C478;
L919: (not C483 is_often_in C479) by L918 , L914 , L917;
thus L920: C483 is_eventually_in ( C479 ` ) by L919 , L905 , WAYBEL_0:10;
end;
L921: ( C479 ` ) is  open by L915 , L898;
thus L922: thesis by L921 , TOPS_1:3;
end;
theorem
L923: (for B375 being non  empty 1-sorted holds (for B376 being  topological (Convergence-Class of B375) holds (for B377 being (Subset of ( ConvergenceSpace B376 )) holds (for B378 being (Point of ( ConvergenceSpace B376 )) holds (B378 in ( Cl B377 ) implies (ex B379 being (net of ( ConvergenceSpace B376 )) st ([ B379 , B378 ] in B376 & ( rng (the mapping of B379) ) c= B377 & B378 in ( Lim B379 ))))))))
proof
let C484 being non  empty 1-sorted;
let C485 being  topological (Convergence-Class of C484);
let C486 being (Subset of (( ConvergenceSpace C485 ) qua non  empty TopSpace));
let C487 being (Point of ( ConvergenceSpace C485 ));
assume that
L924: C487 in ( Cl C486 );
set D153 = ( ConvergenceSpace C485 );
defpred S8[ (Point of D153) ] means (ex B380 being (net of ( ConvergenceSpace C485 )) st ([ B380 , $1 ] in C485 & ( rng (the mapping of B380) ) c= C486 & $1 in ( Lim B380 )));
set D154 = { B381 where B381 is (Point of D153) : S8[ B381 ] };
L925: D154 is (Subset of D153) from DOMAIN_1:sch 7;
reconsider D155 = D154 as (Subset of D153) by L925;
L926: (for B382 being (Element of C484) holds (for B383 being (net of C484) holds (([ B383 , B382 ] in C485 & B383 is_often_in D155) implies B382 in D155)))
proof
let C488 being (Element of C484);
reconsider D156 = C488 as (Point of D153) by L829;
let C489 being (net of C484);
assume that
L927: [ C489 , C488 ] in C485
and
L928: C489 is_often_in D155;
L929: C485 c= [: ( NetUniv C484 ) , (the carrier of C484) :] by L759;
L930: C489 in ( NetUniv C484 ) by L929 , L927 , ZFMISC_1:87;
L931: (ex B384 being  strict (net of C484) st (B384 = C489 & (the carrier of B384) in ( the_universe_of (the carrier of C484) ))) by L930 , L330;
reconsider D157 = ( C489 " D155 ) as (subnet of C489) by L928 , L308;
defpred S9[ (Element of D157) , set ] means ([ $2 , ( D157 . $1 ) ] in C485 & (ex B385 being (net of C484) st (B385 = $2 & ( rng (the mapping of B385) ) c= C486)));
L932:
now
let C490 being (Element of D157);
L933: C490 in (the carrier of D157);
L934: C490 in ( (the mapping of C489) " D155 ) by L933 , L268;
L935: ( (the mapping of C489) . C490 ) in D155 by L934 , FUNCT_2:38;
L936: (the mapping of D157) = ( (the mapping of C489) | (the carrier of D157) ) by L168;
L937: ( (the mapping of D157) . C490 ) in D155 by L936 , L935 , FUNCT_1:49;
consider C491 being (Point of D153) such that L938: ( D157 . C490 ) = C491 and L939: (ex B386 being (net of ( ConvergenceSpace C485 )) st ([ B386 , C491 ] in C485 & ( rng (the mapping of B386) ) c= C486 & C491 in ( Lim B386 ))) by L937;
consider C492 being (net of D153) such that L940: [ C492 , C491 ] in C485 and L941: ( rng (the mapping of C492) ) c= C486 and L942: C491 in ( Lim C492 ) by L939;
reconsider D158 = C492 as set;
take D159 = D158;
thus L943: S9[ C490 , D159 ]
proof
thus L944: [ D159 , ( D157 . C490 ) ] in C485 by L938 , L940;
reconsider D160 = C492 as (net of C484) by L829;
take D160;
thus L945: D160 = D159;
thus L946: thesis by L941;
end;

end;
consider C493 being (ManySortedSet of (the carrier of D157)) such that L944: (for B387 being (Element of D157) holds S9[ B387 , ( C493 . B387 ) ]) from PBOOLE:sch 6(L932);
L945: (for B388 being set holds (B388 in (the carrier of D157) implies ( C493 . B388 ) is (net of C484)))
proof
let C494 being set;
assume L946: C494 in (the carrier of D157);
L947: (ex B389 being (net of C484) st (B389 = ( C493 . C494 ) & ( rng (the mapping of B389) ) c= C486)) by L946 , L944;
thus L948: thesis by L947;
end;
reconsider D161 = C493 as (net_set of (the carrier of D157) , C484) by L945 , L391;
set D162 = { ( rng (the mapping of ( D161 . B390 )) ) where B390 is (Element of D157) : (not contradiction) };
L949: (for B391 being (Element of D157) holds ([ ( D161 . B391 ) , ( D157 . B391 ) ] in C485 & ( rng (the mapping of ( D161 . B391 )) ) c= C486))
proof
let C495 being (Element of D157);
thus L950: [ ( D161 . C495 ) , ( D157 . C495 ) ] in C485 by L944;
L951: (ex B392 being (net of C484) st (B392 = ( D161 . C495 ) & ( rng (the mapping of B392) ) c= C486)) by L944;
thus L952: thesis by L951;
end;
L953: (for R1 being set holds (R1 in D162 implies R1 c= C486))
proof
let R1 being set;
assume L954: R1 in D162;
L955: (ex B393 being (Element of D157) st R1 = ( rng (the mapping of ( D161 . B393 )) )) by L954;
thus L956: thesis by L955 , L949;
end;
L957: ( union D162 ) c= C486 by L953 , ZFMISC_1:76;
reconsider D163 = ( Iterated D161 ) as (net of D153) by L829;
L958: ( rng (the mapping of D163) ) c= ( union D162 ) by L497;
L959: ( rng (the mapping of D163) ) c= C486 by L958 , L957 , XBOOLE_1:1;
L960: (the carrier of D157) = ( (the mapping of C489) " D155 ) by L268;
L961: (the carrier of D157) in ( the_universe_of (the carrier of C484) ) by L960 , L931 , CLASSES1:def 1;
L962: D157 in ( NetUniv C484 ) by L961 , L330;
L963: [ D157 , C488 ] in C485 by L962 , L927 , L795;
L964: [ D163 , C488 ] in C485 by L963 , L949 , L797;
L965: C485 c= ( Convergence D153 ) by L871;
L966: D156 in ( Lim D163 ) by L965 , L964 , L764;
thus L967: thesis by L966 , L964 , L959;
end;
L968: D155 is  closed by L926 , L904;
L969: C486 c= D155
proof
L970: ( {} ) in { ( {} ) } by TARSKI:def 1;
reconsider D164 = { [ ( {} ) , ( {} ) ] } as (Relation of { ( {} ) }) by L970 , RELSET_1:3;
set D165 = RelStr (# { ( {} ) } , D164 #);
L971:
now
let C496 , C497 being (Element of D165);
L972: (C496 = ( {} ) & C497 = ( {} )) by TARSKI:def 1;
L973: [ C496 , C497 ] in { [ ( {} ) , ( {} ) ] } by L972 , TARSKI:def 1;
thus L974: C496 <= C497 by L973 , ORDERS_2:def 5;
end;
L975: D165 is  transitive
proof
let C498 , C499 , C500 being (Element of D165);
thus L976: thesis by L971;
end;
L977: D165 is  directed
proof
let C501 , C502 being (Element of D165);
take C501;
thus L978: thesis by L971;
end;
reconsider D166 = D165 as  transitive  directed non  empty RelStr by L977 , L975;
let R1 being set;
set D167 = ( the_universe_of (the carrier of C484) );
assume L979: R1 in C486;
reconsider D168 = R1 as (Point of D153) by L979;
set D169 = ( ConstantNet (D166 , D168) );
L980: (the mapping of D169) = ( (the carrier of D169) --> D168 ) by L137;
L981: ( rng (the mapping of D169) ) = { D168 } by L980 , FUNCOP_1:8;
L982: ( rng (the mapping of D169) ) c= C486 by L981 , L979 , ZFMISC_1:31;
L983: ( {} ) in D167 by CLASSES2:56;
L984: (the carrier of D166) in D167 by L983 , CLASSES2:2;
L985: (the carrier of D153) = (the carrier of C484) by L829;
reconsider D170 = D169 as  constant  strict (net of C484) by L985 , L368;
L986: ( the_value_of D169 ) = D168 by L217;
L987: ( the_value_of (the mapping of D170) ) = D168 by L986 , L212;
L988: ( the_value_of D170 ) = D168 by L987 , L212;
L989: ( the RelStr of D169 ) = ( the RelStr of D166 ) by L137;
L990: D170 in ( NetUniv C484 ) by L989 , L984 , L330;
L991: [ D170 , D168 ] in C485 by L990 , L988 , L794;
L992: D168 in ( Lim D169 ) by L986 , L567;
thus L993: thesis by L992 , L991 , L982;
end;
L994: ( Cl C486 ) c= D155 by L969 , L968 , TOPS_1:5;
L995: C487 in D155 by L994 , L924;
L996: (ex B394 being (Point of D153) st (C487 = B394 & (ex B395 being (net of ( ConvergenceSpace C485 )) st ([ B395 , B394 ] in C485 & ( rng (the mapping of B395) ) c= C486 & B394 in ( Lim B395 ))))) by L995;
thus L997: thesis by L996;
end;
theorem
L998: (for B396 being non  empty 1-sorted holds (for B397 being (Convergence-Class of B396) holds (( Convergence ( ConvergenceSpace B397 ) ) = B397 iff B397 is  topological)))
proof
let C503 being non  empty 1-sorted;
let C504 being (Convergence-Class of C503);
set D171 = ( ConvergenceSpace C504 );
set D172 = ( Convergence ( ConvergenceSpace C504 ) );
L999: (the carrier of ( ConvergenceSpace C504 )) = (the carrier of C503) by L829;
L1000: (for B398 being (net of C503) holds (for B399 being (net of D171) holds (B398 = B399 implies (for B400 being (subnet of B399) holds B400 is (subnet of B398)))))
proof
let C505 being (net of C503);
let C506 being (net of D171);
assume that
L1001: C505 = C506;
let C507 being (subnet of C506);
reconsider D173 = C507 as (net of C503) by L829;
consider C508 being (Function of C507 , C506) such that L1002: (the mapping of C507) = ( (the mapping of C506) * C508 ) and L1003: (for B401 being (Element of C506) holds (ex B402 being (Element of C507) st (for B403 being (Element of C507) holds (B402 <= B403 implies B401 <= ( C508 . B403 ))))) by L219;
reconsider D174 = C508 as (Function of D173 , C505) by L1001;
L1004: (the mapping of D173) = ( (the mapping of C505) * D174 ) by L1001 , L1002;
thus L1005: thesis by L1004 , L1001 , L1003 , L219;
end;
L1006: (for B404 being (net of C503) holds (for B405 being (net of D171) holds (B404 = B405 implies (for B406 being (subnet of B404) holds B406 is (subnet of B405)))))
proof
let C509 being (net of C503);
let C510 being (net of D171);
assume that
L1007: C509 = C510;
let C511 being (subnet of C509);
reconsider D175 = C511 as (net of D171) by L829;
consider C512 being (Function of C511 , C509) such that L1008: (the mapping of C511) = ( (the mapping of C509) * C512 ) and L1009: (for B407 being (Element of C509) holds (ex B408 being (Element of C511) st (for B409 being (Element of C511) holds (B408 <= B409 implies B407 <= ( C512 . B409 ))))) by L219;
reconsider D176 = C512 as (Function of D175 , C510) by L1007;
L1010: (the mapping of D175) = ( (the mapping of C510) * D176 ) by L1007 , L1008;
thus L1011: thesis by L1010 , L1007 , L1009 , L219;
end;
L1012: (for B410 being (net of C503) holds B410 is (net of D171)) by L829;
thus L1013:now
assume L1014: D172 = C504;
L1015: C504 is  (SUBNETS)
proof
let C513 being (net of C503);
let C514 being (subnet of C513);
reconsider D177 = C513 as (net of D171) by L829;
reconsider D178 = C514 as (subnet of D177) by L1006;
assume L1016: C514 in ( NetUniv C503 );
L1017: D178 in ( NetUniv D171 ) by L1016 , L999 , L373;
let C515 being (Element of C503);
reconsider D179 = C515 as (Element of D171) by L829;
assume L1018: [ C513 , C515 ] in C504;
L1019: [ D177 , D179 ] in D172 by L1018 , L1014;
thus L1020: thesis by L1019 , L1014 , L1017 , L795;
end;
L1021: C504 is  (ITERATED_LIMITS)
proof
let C516 being (net of C503);
let C517 being (Element of C503);
reconsider D180 = C517 as (Element of D171) by L829;
reconsider D181 = C516 as (net of D171) by L829;
assume L1022: [ C516 , C517 ] in C504;
let C518 being (net_set of (the carrier of C516) , C503);
reconsider D182 = C518 as (ManySortedSet of (the carrier of D181));
L1023: D182 is (net_set of (the carrier of D181) , D171)
proof
let C519 being set;
assume L1024: C519 in ( rng D182 );
L1025: C519 is (net of C503) by L1024 , L387;
thus L1026: thesis by L1025 , L1012;
end;
reconsider D183 = C518 as (net_set of (the carrier of D181) , D171) by L1023;
assume L1027: (for B411 being (Element of C516) holds [ ( C518 . B411 ) , ( C516 . B411 ) ] in C504);
L1028:
now
let C520 being (Element of D181);
reconsider D184 = C520 as (Element of C516);
L1029: ( C516 . D184 ) = ( D181 . C520 );
thus L1030: [ ( D183 . C520 ) , ( D181 . C520 ) ] in D172 by L1029 , L1014 , L1027;
end;
L1031: [ ( Iterated D183 ) , D180 ] in D172 by L1028 , L1014 , L1022 , L797;
L1032: ( the RelStr of ( Iterated D183 ) ) = [: C516 , ( product C518 ) :] by L455
.= ( the RelStr of ( Iterated C518 ) ) by L455;
L1033:
now
let C521 being set;
assume L1034: C521 in ( dom (the mapping of ( Iterated D183 )) );
reconsider D185 = C521 as (Element of ( Iterated D183 )) by L1034;
L1035: (the carrier of ( Iterated D183 )) = [: (the carrier of D181) , ( product ( Carrier D183 ) ) :] by L491;
consider C522 being (Element of D181), C523 being (Element of ( product ( Carrier D183 ) )) such that L1036: D185 = [ C522 , C523 ] by L1035 , DOMAIN_1:1;
reconsider D186 = C522 as (Element of C516);
reconsider D187 = C523 as (Element of ( product D183 )) by YELLOW_1:def 4;
set D188 = D187;
L1037: (the carrier of ( Iterated C518 )) = [: (the carrier of C516) , ( product ( Carrier C518 ) ) :] by L491;
reconsider D189 = [ D186 , D188 ] as (Element of ( Iterated C518 )) by L1037 , ZFMISC_1:87;
thus L1038: ( (the mapping of ( Iterated D183 )) . C521 ) = ( ( Iterated D183 ) . D185 )
.= ( (the mapping of ( D183 . C522 )) . ( D187 . C522 ) ) by L1036 , L494
.= ( (the mapping of ( C518 . D186 )) . ( D188 . D186 ) )
.= ( ( Iterated C518 ) . D189 ) by L494
.= ( (the mapping of ( Iterated C518 )) . C521 ) by L1036;
end;
L1039: ( dom (the mapping of ( Iterated D183 )) ) = (the carrier of ( Iterated D183 )) by FUNCT_2:def 1;
L1040: ( dom (the mapping of ( Iterated D183 )) ) = ( dom (the mapping of ( Iterated C518 )) ) by L1039 , L1032 , FUNCT_2:def 1;
L1041: (the mapping of ( Iterated D183 )) = (the mapping of ( Iterated C518 )) by L1040 , L1033 , FUNCT_1:2;
thus L1042: thesis by L1041 , L1014 , L1031 , L1032;
end;
L1043: C504 is  (DIVERGENCE)
proof
let C524 being (net of C503);
let C525 being (Element of C503);
reconsider D190 = C525 as (Element of D171) by L829;
reconsider D191 = C524 as (net of D171) by L829;
assume L1044: C524 in ( NetUniv C503 );
L1045: D191 in ( NetUniv D171 ) by L1044 , L999 , L373;
assume L1046: (not [ C524 , C525 ] in C504);
consider C526 being (subnet of D191) such that L1047: C526 in ( NetUniv D171 ) and L1048: (not (ex B412 being (subnet of C526) st [ B412 , D190 ] in D172)) by L1046 , L1014 , L1045 , L796;
reconsider D192 = C526 as (subnet of C524) by L1000;
take D192;
thus L1049: D192 in ( NetUniv C503 ) by L999 , L1047 , L373;
let C527 being (subnet of D192);
reconsider D193 = C527 as (subnet of C526) by L1006;
L1050: (not [ D193 , D190 ] in D172) by L1048;
thus L1051: thesis by L1050 , L1014;
end;
L1052: C504 is  (CONSTANTS)
proof
let C528 being  constant (net of C503);
reconsider D194 = C528 as (net of D171) by L829;
L1053: (the mapping of C528) is  constant;
L1054: (the mapping of D194) is  constant by L1053;
reconsider D195 = D194 as  constant (net of D171) by L1054 , L135;
assume L1055: C528 in ( NetUniv C503 );
L1056: D195 in ( NetUniv D171 ) by L1055 , L999 , L373;
L1057: ( the_value_of D195 ) = ( the_value_of (the mapping of D195) ) by L212
.= ( the_value_of (the mapping of C528) )
.= ( the_value_of C528 ) by L212;
thus L1058: thesis by L1057 , L1014 , L1056 , L794;
end;
thus L1059: C504 is  topological by L1052 , L1015 , L1043 , L1021;
end;
assume L1060: C504 is  (CONSTANTS)  (SUBNETS)  (DIVERGENCE)  (ITERATED_LIMITS);
reconsider D196 = C504 as  topological (Convergence-Class of C503) by L1060;
L1061: ( Convergence ( ConvergenceSpace C504 ) ) c= C504
proof
let R1 being set;
let R2 being set;
assume L1062: [ R1 , R2 ] in ( Convergence D171 );
L1063: ( Convergence D171 ) c= [: ( NetUniv D171 ) , (the carrier of D171) :] by L759;
consider C529 being (Element of ( NetUniv D171 )), C530 being (Element of D171) such that L1064: [ R1 , R2 ] = [ C529 , C530 ] by L1063 , L1062 , DOMAIN_1:1;
reconsider D197 = C530 as (Point of C503) by L829;
L1065: C529 in ( NetUniv D171 );
L1066: (ex B413 being  strict (net of D171) st (B413 = C529 & (the carrier of B413) in ( the_universe_of (the carrier of D171) ))) by L330;
assume L1067: (not [ R1 , R2 ] in C504);
reconsider D198 = C529 as (net of D171) by L1066;
reconsider D199 = D198 as (net of C503) by L829;
L1068: D199 in ( NetUniv C503 ) by L999 , L1065 , L373;
consider C531 being (subnet of D199) such that L1069: C531 in ( NetUniv C503 ) and L1070: (not (ex B414 being (subnet of C531) st [ B414 , D197 ] in C504)) by L1068 , L1060 , L1064 , L1067 , L796;
reconsider D200 = C531 as (subnet of D198) by L1006;
reconsider D201 = ( the RelStr of C531 ) as  transitive  directed non  empty RelStr by L84 , L94;
set D202 = ( ConstantNet (D201 , D197) );
defpred S10[ set , set ] means (ex B415 being (Element of C531) st (ex B416 being (net of C503) st ($1 = B415 & B416 = $2 & [ B416 , C530 ] in C504 & ( rng (the mapping of B416) ) c= { ( C531 . B417 ) where B417 is (Element of C531) : B415 <= B417 })));
L1071: ( the RelStr of D202 ) = D201 by L137;
reconsider D203 = D202 as  constant non  empty  strict (net of C503);
L1072: C530 in ( Lim D198 ) by L1062 , L1064 , L764;
L1073: (for B418 being set holds (B418 in (the carrier of D203) implies (ex B419 being set st S10[ B418 , B419 ])))
proof
let C532 being set;
assume L1074: C532 in (the carrier of D203);
reconsider D204 = C532 as (Element of D200) by L1074 , L152;
reconsider D205 = D204 as (Element of C531);
L1075: ( Lim D198 ) c= ( Lim D200 ) by L555;
consider C533 being (Subset of D171) such that L1076: C533 = { ( D200 . B420 ) where B420 is (Element of D200) : D204 <= B420 } and L1077: C530 in ( Cl C533 ) by L1075 , L1072 , L573;
consider C534 being (net of ( ConvergenceSpace D196 )) such that L1078: [ C534 , C530 ] in D196 and L1079: ( rng (the mapping of C534) ) c= C533 and L1080: C530 in ( Lim C534 ) by L1077 , L923;
reconsider D206 = C534 as (net of C503) by L829;
take D206;
take D205;
take D206;
thus L1081: (C532 = D205 & D206 = D206 & [ D206 , C530 ] in C504) by L1078;
let C535 being set;
assume L1082: C535 in ( rng (the mapping of D206) );
L1083: C535 in C533 by L1082 , L1079;
consider C536 being (Element of D200) such that L1084: C535 = ( D200 . C536 ) and L1085: D204 <= C536 by L1083 , L1076;
reconsider D207 = C536 as (Element of C531);
L1086: C535 = ( C531 . D207 ) by L1084;
thus L1087: thesis by L1086 , L1085;
end;
consider C537 being (ManySortedSet of (the carrier of D203)) such that L1088: (for B421 being set holds (B421 in (the carrier of D203) implies S10[ B421 , ( C537 . B421 ) ])) from PBOOLE:sch 3(L1073);
L1089:
now
let C538 being set;
assume L1090: C538 in (the carrier of D203);
L1091: (ex B422 being (Element of C531) st (ex B423 being (net of C503) st (C538 = B422 & B423 = ( C537 . C538 ) & [ B423 , C530 ] in C504 & ( rng (the mapping of B423) ) c= { ( C531 . B424 ) where B424 is (Element of C531) : B422 <= B424 }))) by L1090 , L1088;
thus L1092: ( C537 . C538 ) is (net of C503) by L1091;
end;
reconsider D208 = C537 as  yielding_non-empty_carriers (net_set of (the carrier of D203) , C503) by L1089 , L391;
reconsider D209 = D203 as (net of D171) by L829;
L1093: (the mapping of D209) is  constant;
L1094: (for B425 being (Element of D203) holds [ ( D208 . B425 ) , ( D203 . B425 ) ] in C504)
proof
let C539 being (Element of D203);
L1095: (ex B426 being (Element of C531) st (ex B427 being (net of C503) st (C539 = B426 & B427 = ( D208 . C539 ) & [ B427 , C530 ] in C504 & ( rng (the mapping of B427) ) c= { ( C531 . B428 ) where B428 is (Element of C531) : B426 <= B428 }))) by L1088;
thus L1096: thesis by L1095 , L155;
end;
L1097: ( the_value_of D203 ) = D197 by L217;
reconsider D210 = D209 as  constant (net of D171) by L1093 , L135;
L1098: ( the RelStr of ( Iterated D208 ) ) = [: D203 , ( product D208 ) :] by L455;
L1099: (the carrier of ( Iterated D208 )) = [: (the carrier of D203) , (the carrier of ( product D208 )) :] by L1098 , YELLOW_3:def 2;
L1100: ( Iterated D208 ) is (subnet of C531)
proof
set D211 = the (Element of ( product D208 ));
set D212 = (the mapping of ( Iterated D208 ));
set D213 = (the mapping of D200);
defpred S11[ set , set , set ] means (ex B429 being Function st (ex B430 being (Element of D203) st (( B429 . $2 ) = $1 & B430 = $3 & ( (the mapping of ( D208 . B430 )) . $2 ) = ( (the mapping of C531) . $1 ))));
deffunc H4((Element of C531)) = { B431 where B431 is (Element of C531) : $1 <= B431 };
consider C540 being (ManySortedSet of (the carrier of C531)) such that L1101: (for B432 being (Element of C531) holds ( C540 . B432 ) = H4(B432)) from PBOOLE:sch 5;
L1102:
now
assume L1103: ( {} ) in ( rng C540 );
consider C541 being set such that L1104: C541 in ( dom C540 ) and L1105: ( C540 . C541 ) = ( {} ) by L1103 , FUNCT_1:def 3;
reconsider D214 = C541 as (Element of C531) by L1104;
consider C542 being (Element of C531) such that L1106: D214 <= C542 and L1107: D214 <= C542 by L65;
L1108: C542 in { B433 where B433 is (Element of C531) : D214 <= B433 } by L1106;
thus L1109: contradiction by L1108 , L1101 , L1105;
end;
reconsider D215 = C540 as  non-empty (ManySortedSet of (the carrier of C531)) by L1102 , RELAT_1:def 9;
deffunc H5((Element of D203)) = (the carrier of ( D208 . $1 ));
consider C543 being (ManySortedSet of (the carrier of D203)) such that L1110: (for B434 being (Element of D203) holds ( C543 . B434 ) = H5(B434)) from PBOOLE:sch 5;
reconsider D216 = D215 as  non-empty (ManySortedSet of (the carrier of D203)) by L1071;
L1111: (for B435 being set holds (B435 in (the carrier of D203) implies (for B436 being set holds (B436 in ( C543 . B435 ) implies (ex B437 being set st (B437 in ( D216 . B435 ) & S11[ B437 , B436 , B435 ]))))))
proof
let C544 being set;
assume that
L1112: C544 in (the carrier of D203);
consider C545 being (Element of C531), C546 being (net of C503) such that L1113: C544 = C545 and L1114: C546 = ( D208 . C544 ) and L1115: [ C546 , C530 ] in C504 and L1116: ( rng (the mapping of C546) ) c= { ( C531 . B438 ) where B438 is (Element of C531) : C545 <= B438 } by L1088 , L1112;
reconsider D217 = C544 as (Element of D203) by L1112;
defpred S12[ set , set ] means ( (the mapping of C546) . $1 ) = ( (the mapping of C531) . $2 );
L1117: (for B439 being (Element of C546) holds (ex B440 being (Element of ( D216 . D217 )) st S12[ B439 , B440 ]))
proof
let C547 being (Element of C546);
L1118: C547 in (the carrier of C546);
L1119: C547 in ( dom (the mapping of C546) ) by L1118 , FUNCT_2:def 1;
L1120: ( (the mapping of C546) . C547 ) in ( rng (the mapping of C546) ) by L1119 , FUNCT_1:def 3;
L1121: ( (the mapping of C546) . C547 ) in { ( C531 . B441 ) where B441 is (Element of C531) : C545 <= B441 } by L1120 , L1116;
consider C548 being (Element of C531) such that L1122: ( (the mapping of C546) . C547 ) = ( C531 . C548 ) and L1123: C545 <= C548 by L1121;
L1124: C548 in { B442 where B442 is (Element of C531) : C545 <= B442 } by L1123;
reconsider D218 = C548 as (Element of ( D216 . D217 )) by L1124 , L1101 , L1113;
take D218;
thus L1125: ( (the mapping of C546) . C547 ) = ( (the mapping of C531) . D218 ) by L1122;
end;
consider C549 being (Function of (the carrier of C546) , ( D216 . D217 )) such that L1126: (for B443 being (Element of C546) holds S12[ B443 , ( C549 . B443 ) ]) from FUNCT_2:sch 3(L1117);
let C550 being set;
assume L1127: C550 in ( C543 . C544 );
reconsider D219 = C550 as (Element of C546) by L1127 , L1110 , L1112 , L1114;
reconsider D220 = C549 as (Function of (the carrier of C546) , ( D215 . C544 ));
take ( D220 . C550 );
L1128: ( D220 . D219 ) in ( D215 . C544 );
thus L1129: ( D220 . C550 ) in ( D216 . C544 ) by L1128;
take D220;
take D217;
thus L1130: (( D220 . C550 ) = ( D220 . C550 ) & D217 = C544);
thus L1131: ( (the mapping of ( D208 . D217 )) . C550 ) = ( (the mapping of C546) . D219 ) by L1114
.= ( (the mapping of C531) . ( D220 . C550 ) ) by L1126;
end;
consider C551 being (ManySortedFunction of C543 , D216) such that L1132: (for B444 being set holds (B444 in (the carrier of D203) implies (ex B445 being (Function of ( C543 . B444 ) , ( D216 . B444 )) st (B445 = ( C551 . B444 ) & (for B446 being set holds (B446 in ( C543 . B444 ) implies S11[ ( B445 . B446 ) , B446 , B444 ])))))) from MSSUBFAM:sch 1(L1111);
deffunc H6((Element of D203) , (Element of ( product D208 ))) = ( ( C551 . $1 ) . ( $2 . $1 ) );
L1133: (for B447 being (Element of D203) holds (for B448 being (Element of ( product D208 )) holds H6(B447 , B448) in (the carrier of C531)))
proof
let C552 being (Element of D203);
let C553 being (Element of ( product D208 ));
reconsider D221 = C552 as (Element of D210);
reconsider D222 = C552 as (Element of C531) by L1071;
defpred S13[ (Element of C531) ] means D222 <= $1;
set D223 = { B449 where B449 is (Element of C531) : S13[ B449 ] };
L1134: D223 is (Subset of C531) from DOMAIN_1:sch 7;
L1135: D221 in (the carrier of D210);
L1136: D221 in ( dom ( Carrier D208 ) ) by L1135 , PARTFUN1:def 2;
L1137: C553 in (the carrier of ( product D208 ));
L1138: C553 in ( product ( Carrier D208 ) ) by L1137 , YELLOW_1:def 4;
L1139: ( C553 . D221 ) in ( ( Carrier D208 ) . D221 ) by L1138 , L1136 , CARD_3:9;
L1140: ( C553 . D221 ) in (the carrier of ( D208 . C552 )) by L1139 , L14;
L1141: (( C551 . D222 ) is (Function of ( C543 . D222 ) , ( D215 . D222 )) & ( C553 . C552 ) in ( C543 . D222 )) by L1140 , L1110 , PBOOLE:def 15;
L1142: ( ( C551 . D222 ) . ( C553 . C552 ) ) in ( D215 . D222 ) by L1141 , FUNCT_2:5;
L1143: ( D215 . D222 ) = D223 by L1101;
thus L1144: thesis by L1143 , L1134 , L1142;
end;
consider C554 being (Function of [: (the carrier of D203) , (the carrier of ( product D208 )) :] , (the carrier of C531)) such that L1145: (for B450 being (Element of D203) holds (for B451 being (Element of ( product D208 )) holds ( C554 . (B450 , B451) ) = H6(B450 , B451))) from FUNCT_7:sch 1(L1133);
reconsider D224 = C554 as (Function of ( Iterated D208 ) , C531) by L1099;
L1146: (for B452 being (Element of D203) holds (for B453 being (Element of ( C543 . B452 )) holds ( (the mapping of ( D208 . B452 )) . B453 ) = ( (the mapping of C531) . ( ( C551 . B452 ) . B453 ) )))
proof
let C555 being (Element of D203);
let C556 being (Element of ( C543 . C555 ));
consider C557 being (Function of ( C543 . C555 ) , ( D216 . C555 )) such that L1147: C557 = ( C551 . C555 ) and L1148: (for B454 being set holds (B454 in ( C543 . C555 ) implies S11[ ( C557 . B454 ) , B454 , C555 ])) by L1132;
L1149: ( C543 . C555 ) = (the carrier of ( D208 . C555 )) by L1110;
L1150: S11[ ( C557 . C556 ) , C556 , C555 ] by L1149 , L1148;
thus L1151: thesis by L1150 , L1147;
end;
L1152: (for R1 being set holds (R1 in ( dom D212 ) implies ( D212 . R1 ) = ( D213 . ( D224 . R1 ) )))
proof
let R1 being set;
assume L1153: R1 in ( dom D212 );
L1154: R1 in (the carrier of ( Iterated D208 )) by L1153;
L1155: R1 in [: (the carrier of D210) , ( product ( Carrier D208 ) ) :] by L1154 , L491;
L1156: R1 in [: (the carrier of D210) , (the carrier of ( product D208 )) :] by L1155 , YELLOW_1:def 4;
consider C558 being (Element of D210), C559 being (Element of ( product D208 )) such that L1157: R1 = [ C558 , C559 ] by L1156 , DOMAIN_1:1;
reconsider D225 = C558 as (Element of D203);
L1158: C559 in (the carrier of ( product D208 ));
L1159: C559 in ( product ( Carrier D208 ) ) by L1158 , YELLOW_1:def 4;
L1160: (( dom ( Carrier D208 ) ) = (the carrier of D210) & (the carrier of ( D208 . D225 )) = ( ( Carrier D208 ) . C558 )) by L14 , PARTFUN1:def 2;
L1161: ( C559 . C558 ) in (the carrier of ( D208 . D225 )) by L1160 , L1159 , CARD_3:9;
reconsider D226 = ( C559 . C558 ) as (Element of ( C543 . D225 )) by L1161 , L1110;
thus L1162: ( D212 . R1 ) = ( D212 . (C558 , C559) ) by L1157
.= ( (the mapping of ( D208 . D225 )) . ( C559 . C558 ) ) by L455
.= ( D213 . ( ( C551 . D225 ) . D226 ) ) by L1146
.= ( D213 . ( D224 . (C558 , C559) ) ) by L1145
.= ( D213 . ( D224 . R1 ) ) by L1157;
end;
take D224;
L1163: (for R1 being set holds (R1 in ( dom D212 ) iff (R1 in ( dom D224 ) & ( D224 . R1 ) in ( dom D213 ))))
proof
let R1 being set;
thus L1164:now
assume L1165: R1 in ( dom D212 );
L1166: R1 in (the carrier of ( Iterated D208 )) by L1165;
L1167: R1 in [: (the carrier of D210) , ( product ( Carrier D208 ) ) :] by L1166 , L491;
L1168: R1 in [: (the carrier of D210) , (the carrier of ( product D208 )) :] by L1167 , YELLOW_1:def 4;
thus L1169: R1 in ( dom D224 ) by L1168 , FUNCT_2:def 1;
L1170: ( D224 . R1 ) in (the carrier of C531) by L1168 , FUNCT_2:5;
thus L1171: ( D224 . R1 ) in ( dom D213 ) by L1170 , FUNCT_2:def 1;
end;
assume that
L1172: R1 in ( dom D224 )
and
L1173: ( D224 . R1 ) in ( dom D213 );
L1174: R1 in [: (the carrier of D210) , (the carrier of ( product D208 )) :] by L1172 , FUNCT_2:def 1;
L1175: R1 in [: (the carrier of D210) , ( product ( Carrier D208 ) ) :] by L1174 , YELLOW_1:def 4;
L1176: R1 in (the carrier of ( Iterated D208 )) by L1175 , L491;
thus L1177: thesis by L1176 , FUNCT_2:def 1;
end;
thus L1178: (the mapping of ( Iterated D208 )) = ( (the mapping of C531) * D224 ) by L1163 , L1152 , FUNCT_1:10;
let C560 being (Element of C531);
reconsider D227 = [ C560 , D211 ] as (Element of ( Iterated D208 )) by L1071 , L1099 , ZFMISC_1:87;
take D227;
let C561 being (Element of ( Iterated D208 ));
consider C562 being (Element of D203), C563 being (Element of ( product D208 )) such that L1179: C561 = [ C562 , C563 ] by L1099 , DOMAIN_1:1;
reconsider D228 = C560 as (Element of D203) by L1071;
reconsider D229 = D211 as (Element of ( product D208 ));
L1180: C563 in (the carrier of ( product D208 ));
L1181: (( dom ( Carrier D208 ) ) = (the carrier of D210) & C563 in ( product ( Carrier D208 ) )) by L1180 , PARTFUN1:def 2 , YELLOW_1:def 4;
reconsider D230 = C562 as (Element of C531) by L1071;
L1182: ( D224 . (C562 , C563) ) = ( ( C551 . D230 ) . ( C563 . D230 ) ) by L1145;
reconsider D231 = C562 as (Element of D210);
L1183: ( C551 . D230 ) is (Function of ( C543 . D230 ) , ( D215 . D230 )) by PBOOLE:def 15;
L1184: ( rng ( C551 . D230 ) ) c= ( D215 . D230 ) by L1183 , RELAT_1:def 19;
L1185: ( dom ( C551 . D230 ) ) = ( C543 . D230 ) by L1183 , FUNCT_2:def 1
.= (the carrier of ( D208 . C562 )) by L1110
.= ( ( Carrier D208 ) . D231 ) by L14;
L1186: ( C563 . D231 ) in ( dom ( C551 . D230 ) ) by L1185 , L1181 , CARD_3:9;
reconsider D232 = D230 as (Element of D203);
reconsider D233 = C563 as (Element of ( product D208 ));
assume L1187: D227 <= C561;
L1188: [ D228 , D229 ] <= [ D232 , D233 ] by L1187 , L1098 , L1179 , L130;
L1189: D228 <= D232 by L1188 , YELLOW_3:11;
L1190: C560 <= D230 by L1189 , L1071 , L130;
L1191: ( D224 . C561 ) in ( rng ( C551 . D230 ) ) by L1179 , L1182 , L1186 , FUNCT_1:def 3;
L1192: ( D224 . C561 ) in ( D215 . D230 ) by L1191 , L1184;
L1193: ( D224 . C561 ) in { B455 where B455 is (Element of C531) : D230 <= B455 } by L1192 , L1101;
L1194: (ex B456 being (Element of C531) st (B456 = ( D224 . C561 ) & D230 <= B456)) by L1193;
thus L1195: thesis by L1194 , L1190 , YELLOW_0:def 2;
end;
L1196: ( the RelStr of D203 ) = ( the RelStr of C531 ) by L137;
L1197: (ex B457 being  strict (net of C503) st (B457 = C531 & (the carrier of B457) in ( the_universe_of (the carrier of C503) ))) by L1069 , L330;
L1198: D203 in ( NetUniv C503 ) by L1197 , L1196 , L330;
L1199: [ D203 , D197 ] in C504 by L1198 , L1060 , L1097 , L794;
L1200: [ ( Iterated D208 ) , D197 ] in C504 by L1199 , L1060 , L1094 , L797;
thus L1201: contradiction by L1200 , L1070 , L1100;
end;
L1202: C504 c= ( Convergence ( ConvergenceSpace C504 ) ) by L871;
thus L1203: thesis by L1202 , L1061 , XBOOLE_0:def 10;
end;
