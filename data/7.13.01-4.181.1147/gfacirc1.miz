:: Generalized Full Adder Circuits (GFAs). {P}art {I}
::  by Shin'nosuke Yamaguchi , Katsumi Wasaki and Nobuhiro Shimoi
::
:: Received December 7, 2005
:: Copyright (c) 2005-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, MARGREL1, FUNCT_1, FINSEQ_2, FINSEQ_1,
      XBOOLEAN, TWOSCOMP, CARD_1, RELAT_1, ORDINAL4, TARSKI, XBOOLE_0,
      CLASSES1, FSM_1, FACIRC_1, CIRCUIT2, MSAFREE2, CIRCCOMB, STRUCT_0,
      GLIB_000, MSUALG_1, FUNCT_4, LATTICES, CIRCUIT1, PARTFUN1, ARYTM_3,
      GFACIRC1;
 notations TARSKI, XBOOLE_0, ENUMSET1,
      XTUPLE_0, SUBSET_1, NAT_1, RELAT_1, NUMBERS,
      STRUCT_0, FUNCT_1, FUNCT_2, FINSEQ_1, FINSEQ_2, MARGREL1, CLASSES1,
      BINARITH, MSUALG_1, MSAFREE2, CIRCUIT1, CIRCUIT2, CIRCCOMB, FACIRC_1,
      TWOSCOMP;
 constructors ENUMSET1, CLASSES1, BINARITH, CIRCUIT1, CIRCUIT2, FACIRC_1,
      TWOSCOMP, NAT_1, RELSET_1, XTUPLE_0;
 registrations RELAT_1, MARGREL1, FINSEQ_2, CARD_3, STRUCT_0, CIRCCOMB,
      FACIRC_1, ORDINAL1, FINSEQ_1, FUNCT_1, MSAFREE2, XTUPLE_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, XBOOLE_0, CIRCUIT2, FACIRC_1, MSAFREE2, XBOOLEAN,
      XTUPLE_0;
 theorems TARSKI, XBOOLE_0, XBOOLE_1, ZFMISC_1, ENUMSET1,
      FUNCT_1, FUNCT_2, FINSEQ_1, FINSEQ_2, FINSEQ_6, BINARITH, CIRCUIT1,
      CIRCUIT2, CIRCCOMB, FACIRC_1, TWOSCOMP, CIRCCMB2, FACIRC_2, XBOOLEAN,
      CLASSES1, XTUPLE_0, XREGULAR;
 schemes FUNCT_2, FACIRC_1;

begin
scheme 1AryBooleEx { F1(set) -> (Element of ( BOOLEAN )) } : (ex B1 being (Function of ( 1 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B2 being (Element of ( BOOLEAN )) holds ( B1 . <* B2 *> ) = F1(B2)))
proof
deffunc H1((Tuple of 1 , ( BOOLEAN ))) = F1(( $1 . 1 ));
consider C1 being (Function of ( 1 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) such that L1: (for B3 being (Element of ( 1 -tuples_on ( BOOLEAN ) )) holds ( C1 . B3 ) = H1(B3)) from FUNCT_2:sch 4;
thus L2:now
take D1 = C1;
let C2 being (Element of ( BOOLEAN ));
reconsider D2 = <* C2 *> as (Element of ( 1 -tuples_on ( BOOLEAN ) )) by FINSEQ_2:98;
thus L3: ( D1 . <* C2 *> ) = F1(( D2 . 1 )) by L1
.= F1(C2) by FINSEQ_1:def 8;
end;
end;
scheme 1AryBooleUniq { F2(set) -> (Element of ( BOOLEAN )) } : (for B4 , B5 being (Function of ( 1 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B6 being (Element of ( BOOLEAN )) holds ( B4 . <* B6 *> ) = F2(B6)) & (for B7 being (Element of ( BOOLEAN )) holds ( B5 . <* B7 *> ) = F2(B7))) implies B4 = B5))
proof
let C3 , C4 being (Function of ( 1 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
assume that
L3: (for B8 being (Element of ( BOOLEAN )) holds ( C3 . <* B8 *> ) = F2(B8))
and
L4: (for B9 being (Element of ( BOOLEAN )) holds ( C4 . <* B9 *> ) = F2(B9));
L5:
now
let C5 being (Tuple of 1 , ( BOOLEAN ));
consider C6 being (Element of ( BOOLEAN )) such that L6: C5 = <* C6 *> by FINSEQ_2:97;
thus L7: ( C3 . C5 ) = F2(C6) by L3 , L6
.= ( C4 . C5 ) by L4 , L6;
end;
thus L8: thesis by L5 , FUNCT_2:63;
end;
scheme 1AryBooleDef { F3(set) -> (Element of ( BOOLEAN )) } : ((ex B10 being (Function of ( 1 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B11 being (Element of ( BOOLEAN )) holds ( B10 . <* B11 *> ) = F3(B11))) & (for B12 , B13 being (Function of ( 1 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B14 being (Element of ( BOOLEAN )) holds ( B12 . <* B14 *> ) = F3(B14)) & (for B15 being (Element of ( BOOLEAN )) holds ( B13 . <* B15 *> ) = F3(B15))) implies B12 = B13)))
proof
deffunc H2((Tuple of 1 , ( BOOLEAN ))) = F3(( $1 . 1 ));
consider C7 being (Function of ( 1 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) such that L9: (for B16 being (Tuple of 1 , ( BOOLEAN )) holds ( C7 . B16 ) = H2(B16)) from FUNCT_2:sch 4;
thus L10:now
take D3 = C7;
let C8 being (Element of ( BOOLEAN ));
reconsider D4 = <* C8 *> as (Element of ( 1 -tuples_on ( BOOLEAN ) )) by FINSEQ_2:98;
thus L11: ( D3 . <* C8 *> ) = F3(( D4 . 1 )) by L9
.= F3(C8) by FINSEQ_1:def 8;
end;
let C9 , C10 being (Function of ( 1 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
assume that
L12: (for B17 being (Element of ( BOOLEAN )) holds ( C9 . <* B17 *> ) = F3(B17))
and
L13: (for B18 being (Element of ( BOOLEAN )) holds ( C10 . <* B18 *> ) = F3(B18));
L14:
now
let C11 being (Tuple of 1 , ( BOOLEAN ));
consider C12 being (Element of ( BOOLEAN )) such that L15: C11 = <* C12 *> by FINSEQ_2:97;
thus L16: ( C9 . C11 ) = F3(C12) by L12 , L15
.= ( C10 . C11 ) by L13 , L15;
end;
thus L17: thesis by L14 , FUNCT_2:63;
end;
definition
func inv1 -> (Function of ( 1 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L18: (for B19 being (Element of ( BOOLEAN )) holds ( it . <* B19 *> ) = ( 'not' B19 ));
existence
proof
deffunc H3((Element of ( BOOLEAN ))) = ( 'not' $1 );
thus L19: (ex B20 being (Function of ( 1 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B21 being (Element of ( BOOLEAN )) holds ( B20 . <* B21 *> ) = H3(B21))) from 1AryBooleEx;
end;
uniqueness
proof
deffunc H4((Element of ( BOOLEAN ))) = ( 'not' $1 );
thus L20: (for B22 , B23 being (Function of ( 1 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B24 being (Element of ( BOOLEAN )) holds ( B22 . <* B24 *> ) = H4(B24)) & (for B25 being (Element of ( BOOLEAN )) holds ( B23 . <* B25 *> ) = H4(B25))) implies B22 = B23)) from 1AryBooleUniq;
end;
end;
theorem
L22: (for B26 being (Element of ( BOOLEAN )) holds (( ( inv1 ) . <* B26 *> ) = ( 'not' B26 ) & ( ( inv1 ) . <* B26 *> ) = ( ( nand2 ) . <* B26 , B26 *> ) & ( ( inv1 ) . <* ( 0 ) *> ) = 1 & ( ( inv1 ) . <* 1 *> ) = ( 0 )))
proof
let C13 being (Element of ( BOOLEAN ));
thus L23: ( ( inv1 ) . <* C13 *> ) = ( 'not' C13 ) by L18;
thus L24: ( ( inv1 ) . <* C13 *> ) = ( 'not' ( C13 '&' C13 ) ) by L18
.= ( ( nand2 ) . <* C13 , C13 *> ) by TWOSCOMP:def 4;
thus L25: ( ( inv1 ) . <* ( 0 ) *> ) = ( 'not' ( FALSE ) ) by L18
.= 1;
thus L26: ( ( inv1 ) . <* 1 *> ) = ( 'not' ( TRUE ) ) by L18
.= ( 0 );
end;
definition
func buf1 -> (Function of ( 1 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L27: (for B27 being (Element of ( BOOLEAN )) holds ( it . <* B27 *> ) = B27);
existence
proof
deffunc H5((Element of ( BOOLEAN ))) = $1;
thus L28: (ex B28 being (Function of ( 1 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B29 being (Element of ( BOOLEAN )) holds ( B28 . <* B29 *> ) = H5(B29))) from 1AryBooleEx;
end;
uniqueness
proof
deffunc H6((Element of ( BOOLEAN ))) = $1;
thus L29: (for B30 , B31 being (Function of ( 1 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B32 being (Element of ( BOOLEAN )) holds ( B30 . <* B32 *> ) = H6(B32)) & (for B33 being (Element of ( BOOLEAN )) holds ( B31 . <* B33 *> ) = H6(B33))) implies B30 = B31)) from 1AryBooleUniq;
end;
end;
theorem
L31: (for B34 being (Element of ( BOOLEAN )) holds (( ( buf1 ) . <* B34 *> ) = B34 & ( ( buf1 ) . <* B34 *> ) = ( ( and2 ) . <* B34 , B34 *> ) & ( ( buf1 ) . <* ( 0 ) *> ) = ( 0 ) & ( ( buf1 ) . <* 1 *> ) = 1))
proof
let C14 being (Element of ( BOOLEAN ));
thus L32: ( ( buf1 ) . <* C14 *> ) = C14 by L27;
thus L33: ( ( buf1 ) . <* C14 *> ) = ( C14 '&' C14 ) by L27
.= ( ( and2 ) . <* C14 , C14 *> ) by TWOSCOMP:def 1;
thus L34: ( ( buf1 ) . <* ( 0 ) *> ) = ( FALSE ) by L27
.= ( 0 );
thus L35: ( ( buf1 ) . <* 1 *> ) = ( TRUE ) by L27
.= 1;
end;
definition
func and2c -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L36: (for B35 , B36 being (Element of ( BOOLEAN )) holds ( it . <* B35 , B36 *> ) = ( B35 '&' ( 'not' B36 ) ));
existence
proof
deffunc H7((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( $1 '&' ( 'not' $2 ) );
thus L37: (ex B37 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B38 , B39 being (Element of ( BOOLEAN )) holds ( B37 . <* B38 , B39 *> ) = H7(B38 , B39))) from FACIRC_1:sch 1;
end;
uniqueness
proof
deffunc H8((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( $1 '&' ( 'not' $2 ) );
thus L38: (for B40 , B41 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B42 , B43 being (Element of ( BOOLEAN )) holds ( B40 . <* B42 , B43 *> ) = H8(B42 , B43)) & (for B44 , B45 being (Element of ( BOOLEAN )) holds ( B41 . <* B44 , B45 *> ) = H8(B44 , B45))) implies B40 = B41)) from FACIRC_1:sch 2;
end;
end;
theorem
L40: (for B46 , B47 being (Element of ( BOOLEAN )) holds (( ( and2c ) . <* B46 , B47 *> ) = ( B46 '&' ( 'not' B47 ) ) & ( ( and2c ) . <* B46 , B47 *> ) = ( ( and2a ) . <* B47 , B46 *> ) & ( ( and2c ) . <* B46 , B47 *> ) = ( ( nor2a ) . <* B46 , B47 *> ) & ( ( and2c ) . <* ( 0 ) , ( 0 ) *> ) = ( 0 ) & ( ( and2c ) . <* ( 0 ) , 1 *> ) = ( 0 ) & ( ( and2c ) . <* 1 , ( 0 ) *> ) = 1 & ( ( and2c ) . <* 1 , 1 *> ) = ( 0 )))
proof
let C15 , C16 being (Element of ( BOOLEAN ));
thus L41: ( ( and2c ) . <* C15 , C16 *> ) = ( C15 '&' ( 'not' C16 ) ) by L36;
thus L42: ( ( and2c ) . <* C15 , C16 *> ) = ( C15 '&' ( 'not' C16 ) ) by L36
.= ( ( and2a ) . <* C16 , C15 *> ) by TWOSCOMP:def 2;
thus L43: ( ( and2c ) . <* C15 , C16 *> ) = ( 'not' ( ( 'not' C15 ) 'or' ( 'not' ( 'not' C16 ) ) ) ) by L36
.= ( ( nor2a ) . <* C15 , C16 *> ) by TWOSCOMP:def 11;
thus L44: ( ( and2c ) . <* ( 0 ) , ( 0 ) *> ) = ( ( FALSE ) '&' ( 'not' ( FALSE ) ) ) by L36
.= ( 0 );
thus L45: ( ( and2c ) . <* ( 0 ) , 1 *> ) = ( ( FALSE ) '&' ( 'not' ( TRUE ) ) ) by L36
.= ( 0 );
thus L46: ( ( and2c ) . <* 1 , ( 0 ) *> ) = ( ( TRUE ) '&' ( 'not' ( FALSE ) ) ) by L36
.= 1;
thus L47: ( ( and2c ) . <* 1 , 1 *> ) = ( ( TRUE ) '&' ( 'not' ( TRUE ) ) ) by L36
.= ( 0 );
end;
definition
func xor2c -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L48: (for B48 , B49 being (Element of ( BOOLEAN )) holds ( it . <* B48 , B49 *> ) = ( B48 'xor' ( 'not' B49 ) ));
existence
proof
deffunc H9((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( $1 'xor' ( 'not' $2 ) );
thus L49: (ex B50 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B51 , B52 being (Element of ( BOOLEAN )) holds ( B50 . <* B51 , B52 *> ) = H9(B51 , B52))) from FACIRC_1:sch 1;
end;
uniqueness
proof
deffunc H10((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( $1 'xor' ( 'not' $2 ) );
thus L50: (for B53 , B54 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B55 , B56 being (Element of ( BOOLEAN )) holds ( B53 . <* B55 , B56 *> ) = H10(B55 , B56)) & (for B57 , B58 being (Element of ( BOOLEAN )) holds ( B54 . <* B57 , B58 *> ) = H10(B57 , B58))) implies B53 = B54)) from FACIRC_1:sch 2;
end;
end;
theorem
L52: (for B59 , B60 being (Element of ( BOOLEAN )) holds (( ( xor2c ) . <* B59 , B60 *> ) = ( B59 'xor' ( 'not' B60 ) ) & ( ( xor2c ) . <* B59 , B60 *> ) = ( ( xor2a ) . <* B59 , B60 *> ) & ( ( xor2c ) . <* B59 , B60 *> ) = ( ( or2 ) . <* ( ( and2b ) . <* B59 , B60 *> ) , ( ( and2 ) . <* B59 , B60 *> ) *> ) & ( ( xor2c ) . <* ( 0 ) , ( 0 ) *> ) = 1 & ( ( xor2c ) . <* ( 0 ) , 1 *> ) = ( 0 ) & ( ( xor2c ) . <* 1 , ( 0 ) *> ) = ( 0 ) & ( ( xor2c ) . <* 1 , 1 *> ) = 1))
proof
let C17 , C18 being (Element of ( BOOLEAN ));
thus L53: ( ( xor2c ) . <* C17 , C18 *> ) = ( C17 'xor' ( 'not' C18 ) ) by L48;
thus L54: ( ( xor2c ) . <* C17 , C18 *> ) = ( C17 'xor' ( 'not' C18 ) ) by L48
.= ( ( 'not' C17 ) 'xor' C18 )
.= ( ( xor2a ) . <* C17 , C18 *> ) by TWOSCOMP:def 14;
thus L55: ( ( xor2c ) . <* C17 , C18 *> ) = ( C17 'xor' ( 'not' C18 ) ) by L48
.= ( ( ( 'not' C17 ) '&' ( 'not' C18 ) ) 'or' ( C17 '&' ( 'not' ( 'not' C18 ) ) ) )
.= ( ( or2 ) . <* ( ( 'not' C17 ) '&' ( 'not' C18 ) ) , ( C17 '&' C18 ) *> ) by TWOSCOMP:def 7
.= ( ( or2 ) . <* ( ( and2b ) . <* C17 , C18 *> ) , ( C17 '&' C18 ) *> ) by TWOSCOMP:def 3
.= ( ( or2 ) . <* ( ( and2b ) . <* C17 , C18 *> ) , ( ( and2 ) . <* C17 , C18 *> ) *> ) by TWOSCOMP:def 1;
thus L56: ( ( xor2c ) . <* ( 0 ) , ( 0 ) *> ) = ( ( FALSE ) 'xor' ( 'not' ( FALSE ) ) ) by L48
.= 1 by XBOOLEAN:102;
thus L57: ( ( xor2c ) . <* ( 0 ) , 1 *> ) = ( ( FALSE ) 'xor' ( 'not' ( TRUE ) ) ) by L48
.= ( 0 );
thus L58: ( ( xor2c ) . <* 1 , ( 0 ) *> ) = ( ( TRUE ) 'xor' ( 'not' ( FALSE ) ) ) by L48
.= ( 0 );
thus L59: ( ( xor2c ) . <* 1 , 1 *> ) = ( ( TRUE ) 'xor' ( 'not' ( TRUE ) ) ) by L48
.= 1 by BINARITH:7;
end;
theorem
L60: (for B61 , B62 being (Element of ( BOOLEAN )) holds (( ( inv1 ) . <* ( ( xor2 ) . <* B61 , B62 *> ) *> ) = ( ( xor2a ) . <* B61 , B62 *> ) & ( ( inv1 ) . <* ( ( xor2 ) . <* B61 , B62 *> ) *> ) = ( ( xor2c ) . <* B61 , B62 *> ) & ( ( xor2 ) . <* ( ( inv1 ) . <* B61 *> ) , ( ( inv1 ) . <* B62 *> ) *> ) = ( ( xor2 ) . <* B61 , B62 *> )))
proof
let C19 , C20 being (Element of ( BOOLEAN ));
thus L61: ( ( inv1 ) . <* ( ( xor2 ) . <* C19 , C20 *> ) *> ) = ( ( inv1 ) . <* ( C19 'xor' C20 ) *> ) by TWOSCOMP:def 13
.= ( 'not' ( C19 'xor' C20 ) ) by L18
.= ( ( 'not' C19 ) 'xor' C20 ) by XBOOLEAN:74
.= ( ( xor2a ) . <* C19 , C20 *> ) by TWOSCOMP:def 14;
thus L62: ( ( inv1 ) . <* ( ( xor2 ) . <* C19 , C20 *> ) *> ) = ( ( xor2c ) . <* C19 , C20 *> ) by L61 , L52;
thus L63: ( ( xor2 ) . <* ( ( inv1 ) . <* C19 *> ) , ( ( inv1 ) . <* C20 *> ) *> ) = ( ( xor2 ) . <* ( 'not' C19 ) , ( ( inv1 ) . <* C20 *> ) *> ) by L22
.= ( ( xor2 ) . <* ( 'not' C19 ) , ( 'not' C20 ) *> ) by L22
.= ( ( 'not' C19 ) 'xor' ( 'not' C20 ) ) by TWOSCOMP:def 13
.= ( C19 'xor' C20 )
.= ( ( xor2 ) . <* C19 , C20 *> ) by TWOSCOMP:def 13;
end;
theorem
L64: (for B63 , B64 , B65 being (Element of ( BOOLEAN )) holds ( ( inv1 ) . <* ( ( xor2 ) . <* ( ( xor2c ) . <* B63 , B64 *> ) , B65 *> ) *> ) = ( ( xor2c ) . <* ( ( xor2c ) . <* B63 , B64 *> ) , B65 *> ))
proof
let C21 , C22 , C23 being (Element of ( BOOLEAN ));
thus L65: ( ( inv1 ) . <* ( ( xor2 ) . <* ( ( xor2c ) . <* C21 , C22 *> ) , C23 *> ) *> ) = ( ( inv1 ) . <* ( ( xor2 ) . <* ( C21 'xor' ( 'not' C22 ) ) , C23 *> ) *> ) by L48
.= ( ( inv1 ) . <* ( ( C21 'xor' ( 'not' C22 ) ) 'xor' C23 ) *> ) by TWOSCOMP:def 13
.= ( 'not' ( ( C21 'xor' ( 'not' C22 ) ) 'xor' C23 ) ) by L18
.= ( ( C21 'xor' ( 'not' C22 ) ) 'xor' ( 'not' C23 ) ) by XBOOLEAN:74
.= ( ( xor2c ) . <* ( C21 'xor' ( 'not' C22 ) ) , C23 *> ) by L48
.= ( ( xor2c ) . <* ( ( xor2c ) . <* C21 , C22 *> ) , C23 *> ) by L48;
end;
theorem
L66: (for B66 , B67 , B68 being (Element of ( BOOLEAN )) holds ( ( ( 'not' B66 ) 'xor' B67 ) 'xor' ( 'not' B68 ) ) = ( ( B66 'xor' ( 'not' B67 ) ) 'xor' ( 'not' B68 ) ));
theorem
L67: (for B69 , B70 , B71 being (Element of ( BOOLEAN )) holds ( ( xor2c ) . <* ( ( xor2a ) . <* B69 , B70 *> ) , B71 *> ) = ( ( xor2c ) . <* ( ( xor2c ) . <* B69 , B70 *> ) , B71 *> )) by L52;
theorem
L68: (for B72 , B73 , B74 being (Element of ( BOOLEAN )) holds ( ( inv1 ) . <* ( ( xor2c ) . <* ( ( xor2b ) . <* B72 , B73 *> ) , B74 *> ) *> ) = ( ( xor2 ) . <* ( ( xor2 ) . <* B72 , B73 *> ) , B74 *> ))
proof
let C24 , C25 , C26 being (Element of ( BOOLEAN ));
thus L69: ( ( inv1 ) . <* ( ( xor2c ) . <* ( ( xor2b ) . <* C24 , C25 *> ) , C26 *> ) *> ) = ( ( inv1 ) . <* ( ( xor2c ) . <* ( ( 'not' C24 ) 'xor' ( 'not' C25 ) ) , C26 *> ) *> ) by TWOSCOMP:def 15
.= ( ( inv1 ) . <* ( ( ( 'not' C24 ) 'xor' ( 'not' C25 ) ) 'xor' ( 'not' C26 ) ) *> ) by L48
.= ( 'not' ( ( ( 'not' C24 ) 'xor' ( 'not' C25 ) ) 'xor' ( 'not' C26 ) ) ) by L18
.= ( ( C24 'xor' C25 ) 'xor' C26 ) by XBOOLEAN:74
.= ( ( xor2 ) . <* ( C24 'xor' C25 ) , C26 *> ) by TWOSCOMP:def 13
.= ( ( xor2 ) . <* ( ( xor2 ) . <* C24 , C25 *> ) , C26 *> ) by TWOSCOMP:def 13;
end;
L70: (for B75 , B76 , B77 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (for B78 , B79 , B80 being set holds ((B78 <> [ <* B79 , B80 *> , B76 ] & B79 <> [ <* B80 , B78 *> , B77 ] & B80 <> [ <* B78 , B79 *> , B75 ]) implies ((not [ <* B78 , B79 *> , B75 ] in { B79 , B80 }) & (not B80 in { [ <* B78 , B79 *> , B75 ] , [ <* B79 , B80 *> , B76 ] }) & (not B78 in { [ <* B78 , B79 *> , B75 ] , [ <* B79 , B80 *> , B76 ] }) & (not [ <* B80 , B78 *> , B77 ] in { B78 , B79 , B80 })))))
proof
let C27 , C28 , C29 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
let C30 , C31 , C32 being set;
set D5 = [ <* C30 , C31 *> , C27 ];
set D6 = [ <* C31 , C32 *> , C28 ];
set D7 = [ <* C32 , C30 *> , C29 ];
assume that
L71: C30 <> D6
and
L72: C31 <> D7
and
L73: C32 <> D5;
L74: (<* C30 , C31 *> in { <* C30 , C31 *> } & { <* C30 , C31 *> } in D5) by TARSKI:def 1 , TARSKI:def 2;
L75: ( dom <* C30 , C31 *> ) = ( Seg 2 ) by FINSEQ_1:89;
L76: 2 in ( dom <* C30 , C31 *> ) by L75 , FINSEQ_1:1;
L77: ( <* C30 , C31 *> . 2 ) = C31 by FINSEQ_1:44;
L78: [ 2 , C31 ] in <* C30 , C31 *> by L77 , L76 , FUNCT_1:1;
L79: (C31 in { 2 , C31 } & { 2 , C31 } in [ 2 , C31 ]) by TARSKI:def 2;
L80: C31 <> D5 by L79 , L78 , L74 , XREGULAR:9;
thus L81: (not D5 in { C31 , C32 }) by L80 , L73 , TARSKI:def 2;
L82: (C32 in { 2 , C32 } & { 2 , C32 } in [ 2 , C32 ]) by TARSKI:def 2;
L83: (<* C30 , C31 *> in { <* C30 , C31 *> } & { <* C30 , C31 *> } in D5) by TARSKI:def 1 , TARSKI:def 2;
L84: <* C32 *> = { [ 1 , C32 ] } by FINSEQ_1:def 5;
L85: [ 1 , C32 ] in <* C32 *> by L84 , TARSKI:def 1;
L86: <* C30 *> = { [ 1 , C30 ] } by FINSEQ_1:def 5;
L87: [ 1 , C30 ] in <* C30 *> by L86 , TARSKI:def 1;
L88: ( dom <* C32 , C30 *> ) = ( Seg 2 ) by FINSEQ_1:89;
L89: 2 in ( dom <* C32 , C30 *> ) by L88 , FINSEQ_1:1;
L90: ( <* C32 , C30 *> . 2 ) = C30 by FINSEQ_1:44;
L91: [ 2 , C30 ] in <* C32 , C30 *> by L90 , L89 , FUNCT_1:1;
L92: <* C32 , C30 *> = ( <* C32 *> ^ <* C30 *> ) by FINSEQ_1:def 9;
L93: <* C32 *> c= <* C32 , C30 *> by L92 , FINSEQ_6:10;
L94: ( dom <* C31 , C32 *> ) = ( Seg 2 ) by FINSEQ_1:89;
L95: 2 in ( dom <* C31 , C32 *> ) by L94 , FINSEQ_1:1;
L96: ( <* C31 , C32 *> . 2 ) = C32 by FINSEQ_1:44;
L97: [ 2 , C32 ] in <* C31 , C32 *> by L96 , L95 , FUNCT_1:1;
L98: <* C30 , C31 *> = ( <* C30 *> ^ <* C31 *> ) by FINSEQ_1:def 9;
L99: <* C30 *> c= <* C30 , C31 *> by L98 , FINSEQ_6:10;
L100: (<* C31 , C32 *> in { <* C31 , C32 *> } & { <* C31 , C32 *> } in D6) by TARSKI:def 1 , TARSKI:def 2;
L101: C32 <> D6 by L100 , L82 , L97 , XREGULAR:9;
L102: (C30 in { 1 , C30 } & { 1 , C30 } in [ 1 , C30 ]) by TARSKI:def 2;
L103: C30 <> D5 by L102 , L99 , L87 , L83 , XREGULAR:9;
thus L104: ((not C32 in { D5 , D6 }) & (not C30 in { D5 , D6 })) by L103 , L71 , L73 , L101 , TARSKI:def 2;
L105: (<* C32 , C30 *> in { <* C32 , C30 *> } & { <* C32 , C30 *> } in D7) by TARSKI:def 1 , TARSKI:def 2;
L106: (<* C32 , C30 *> in { <* C32 , C30 *> } & { <* C32 , C30 *> } in D7) by TARSKI:def 1 , TARSKI:def 2;
L107: (C30 in { 2 , C30 } & { 2 , C30 } in [ 2 , C30 ]) by TARSKI:def 2;
L108: C30 <> D7 by L107 , L91 , L105 , XREGULAR:9;
L109: (C32 in { 1 , C32 } & { 1 , C32 } in [ 1 , C32 ]) by TARSKI:def 2;
L110: C32 <> D7 by L109 , L93 , L85 , L106 , XREGULAR:9;
thus L111: thesis by L110 , L72 , L108 , ENUMSET1:def 1;
end;
L112: (for B81 , B82 , B83 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (for B84 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (for B85 , B86 , B87 being set holds ( { B85 , B86 , B87 } \ { [ <* [ <* B85 , B86 *> , B81 ] , [ <* B86 , B87 *> , B82 ] , [ <* B87 , B85 *> , B83 ] *> , B84 ] } ) = { B85 , B86 , B87 })))
proof
let C33 , C34 , C35 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
let C36 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
let C37 , C38 , C39 being set;
set D8 = [ <* C37 , C38 *> , C33 ];
set D9 = [ <* C38 , C39 *> , C34 ];
set D10 = [ <* C39 , C37 *> , C35 ];
set D11 = [ <* D8 , D9 , D10 *> , C36 ];
L113: ( <* D8 , D9 , D10 *> . 3 ) = D10 by FINSEQ_1:45;
L114: ( len <* D8 , D9 , D10 *> ) = 3 by FINSEQ_1:45;
L115: ( Seg 3 ) = ( dom <* D8 , D9 , D10 *> ) by L114 , FINSEQ_1:def 3;
L116: 3 in ( dom <* D8 , D9 , D10 *> ) by L115 , FINSEQ_1:1;
L117: [ 3 , D10 ] in <* D8 , D9 , D10 *> by L116 , L113 , FUNCT_1:1;
L118: D10 in ( rng <* D8 , D9 , D10 *> ) by L117 , XTUPLE_0:def 13;
L119: ( the_rank_of D10 ) in ( the_rank_of D11 ) by L118 , CLASSES1:82;
L120: ( rng <* C38 , C39 *> ) = { C38 , C39 } by FINSEQ_2:127;
L121: C39 in ( rng <* C38 , C39 *> ) by L120 , TARSKI:def 2;
thus L122: ( { C37 , C38 , C39 } \ { D11 } ) c= { C37 , C38 , C39 };
L123: ( <* D8 , D9 , D10 *> . 2 ) = D9 by FINSEQ_1:45;
let C40 being set;
L124: ( <* D8 , D9 , D10 *> . 1 ) = D8 by FINSEQ_1:45;
L125: 1 in ( dom <* D8 , D9 , D10 *> ) by L115 , FINSEQ_1:1;
L126: [ 1 , D8 ] in <* D8 , D9 , D10 *> by L125 , L124 , FUNCT_1:1;
L127: D8 in ( rng <* D8 , D9 , D10 *> ) by L126 , XTUPLE_0:def 13;
L128: ( the_rank_of D8 ) in ( the_rank_of D11 ) by L127 , CLASSES1:82;
L129: ( rng <* C39 , C37 *> ) = { C39 , C37 } by FINSEQ_2:127;
L130: C37 in ( rng <* C39 , C37 *> ) by L129 , TARSKI:def 2;
L131: 2 in ( dom <* D8 , D9 , D10 *> ) by L115 , FINSEQ_1:1;
L132: [ 2 , D9 ] in <* D8 , D9 , D10 *> by L131 , L123 , FUNCT_1:1;
L133: D9 in ( rng <* D8 , D9 , D10 *> ) by L132 , XTUPLE_0:def 13;
L134: ( the_rank_of D9 ) in ( the_rank_of D11 ) by L133 , CLASSES1:82;
L135: ( rng <* C37 , C38 *> ) = { C37 , C38 } by FINSEQ_2:127;
L136: C38 in ( rng <* C37 , C38 *> ) by L135 , TARSKI:def 2;
assume L137: C40 in { C37 , C38 , C39 };
L138: (C40 = C37 or C40 = C38 or C40 = C39) by L137 , ENUMSET1:def 1;
L139: C40 <> D11 by L138 , L130 , L119 , L136 , L128 , L121 , L134 , CLASSES1:82;
L140: (not C40 in { D11 }) by L139 , TARSKI:def 1;
thus L141: thesis by L140 , L137 , XBOOLE_0:def 5;
end;
L142: (for B88 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (for B89 , B90 , B91 being set holds (B91 <> [ <* B89 , B90 *> , B88 ] implies (for B92 being (State of ( 2GatesCircuit (B89 , B90 , B91 , B88) )) holds (( ( Following B92 ) . ( 2GatesCircOutput (B89 , B90 , B91 , B88) ) ) = ( B88 . <* ( B92 . [ <* B89 , B90 *> , B88 ] ) , ( B92 . B91 ) *> ) & ( ( Following B92 ) . [ <* B89 , B90 *> , B88 ] ) = ( B88 . <* ( B92 . B89 ) , ( B92 . B90 ) *> ) & ( ( Following B92 ) . B89 ) = ( B92 . B89 ) & ( ( Following B92 ) . B90 ) = ( B92 . B90 ) & ( ( Following B92 ) . B91 ) = ( B92 . B91 ))))))
proof
let C41 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
let C42 , C43 , C44 being set;
assume that
L143: C44 <> [ <* C42 , C43 *> , C41 ];
set D12 = ( 2GatesCircStr (C42 , C43 , C44 , C41) );
L144: ( InputVertices D12 ) = { C42 , C43 , C44 } by L143 , FACIRC_1:57;
L145: C44 in ( InputVertices D12 ) by L144 , ENUMSET1:def 1;
set D13 = [ <* C42 , C43 *> , C41 ];
set D14 = <* D13 , C44 *>;
set D15 = ( 1GateCircStr (D14 , C41) );
set D16 = ( 1GateCircuit (D13 , C44 , C41) );
L146: ( InnerVertices D12 ) = { D13 , ( 2GatesCircOutput (C42 , C43 , C44 , C41) ) } by FACIRC_1:56;
reconsider D17 = D13 as (Element of ( InnerVertices D12 )) by L146 , TARSKI:def 2;
set D18 = ( 2GatesCircuit (C42 , C43 , C44 , C41) );
let C45 being (State of D18);
set D19 = ( 1GateCircStr (<* C42 , C43 *> , C41) );
set D20 = ( 1GateCircuit (C42 , C43 , C41) );
reconsider D21 = ( C45 | (the carrier of D19) ) as (State of D20) by FACIRC_1:26;
reconsider D22 = ( C45 | (the carrier of D15) ) as (State of D16) by FACIRC_1:26;
L147: ( dom D22 ) = (the carrier of D15) by CIRCUIT1:3;
L148: ( rng D14 ) = { D17 , C44 } by FINSEQ_2:127;
L149: C44 in ( rng D14 ) by L148 , TARSKI:def 2;
L150: C44 in ( InputVertices D15 ) by L149 , CIRCCOMB:42;
L151: D17 in ( rng D14 ) by L148 , TARSKI:def 2;
L152: D17 in ( InputVertices D15 ) by L151 , CIRCCOMB:42;
reconsider D23 = D17 , D24 = C44 as (Vertex of D15) by L152 , L150;
reconsider D25 = [ D14 , C41 ] as (Element of ( InnerVertices D15 )) by FACIRC_1:47;
reconsider D26 = D17 as (Element of ( InnerVertices D19 )) by FACIRC_1:47;
reconsider D27 = C42 , D28 = C43 as (Vertex of D19) by FACIRC_1:43;
L153: ( dom D21 ) = (the carrier of D19) by CIRCUIT1:3;
thus L154: ( ( Following C45 ) . ( 2GatesCircOutput (C42 , C43 , C44 , C41) ) ) = ( ( Following D22 ) . D25 ) by CIRCCOMB:64
.= ( C41 . <* ( D22 . D23 ) , ( D22 . D24 ) *> ) by FACIRC_1:50
.= ( C41 . <* ( C45 . [ <* C42 , C43 *> , C41 ] ) , ( D22 . D24 ) *> ) by L147 , FUNCT_1:47
.= ( C41 . <* ( C45 . [ <* C42 , C43 *> , C41 ] ) , ( C45 . C44 ) *> ) by L147 , FUNCT_1:47;
thus L155: ( ( Following C45 ) . [ <* C42 , C43 *> , C41 ] ) = ( ( Following D21 ) . D26 ) by CIRCCOMB:64
.= ( C41 . <* ( D21 . D27 ) , ( D21 . D28 ) *> ) by FACIRC_1:50
.= ( C41 . <* ( C45 . C42 ) , ( D21 . D28 ) *> ) by L153 , FUNCT_1:47
.= ( C41 . <* ( C45 . C42 ) , ( C45 . C43 ) *> ) by L153 , FUNCT_1:47;
L156: (C42 in ( InputVertices D12 ) & C43 in ( InputVertices D12 )) by L144 , ENUMSET1:def 1;
thus L157: thesis by L156 , L145 , CIRCUIT2:def 5;
end;
begin
definition
let C46 , C47 , C48 being set;
func GFA0CarryIStr (C46 , C47 , C48) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( ( 1GateCircStr (<* C46 , C47 *> , ( and2 )) ) +* ( 1GateCircStr (<* C47 , C48 *> , ( and2 )) ) ) +* ( 1GateCircStr (<* C48 , C46 *> , ( and2 )) ) );
coherence;
end;
definition
let C49 , C50 , C51 being set;
func GFA0CarryICirc (C49 , C50 , C51) ->  strict  Boolean  gate`2=den (Circuit of ( GFA0CarryIStr (C49 , C50 , C51) )) equals 
( ( ( 1GateCircuit (C49 , C50 , ( and2 )) ) +* ( 1GateCircuit (C50 , C51 , ( and2 )) ) ) +* ( 1GateCircuit (C51 , C49 , ( and2 )) ) );
coherence;
end;
definition
let C52 , C53 , C54 being set;
func GFA0CarryStr (C52 , C53 , C54) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( GFA0CarryIStr (C52 , C53 , C54) ) +* ( 1GateCircStr (<* [ <* C52 , C53 *> , ( and2 ) ] , [ <* C53 , C54 *> , ( and2 ) ] , [ <* C54 , C52 *> , ( and2 ) ] *> , ( or3 )) ) );
coherence;
end;
definition
let C55 , C56 , C57 being set;
func GFA0CarryCirc (C55 , C56 , C57) ->  strict  Boolean  gate`2=den (Circuit of ( GFA0CarryStr (C55 , C56 , C57) )) equals 
( ( GFA0CarryICirc (C55 , C56 , C57) ) +* ( 1GateCircuit ([ <* C55 , C56 *> , ( and2 ) ] , [ <* C56 , C57 *> , ( and2 ) ] , [ <* C57 , C55 *> , ( and2 ) ] , ( or3 )) ) );
coherence;
end;
definition
let C58 , C59 , C60 being set;
func GFA0CarryOutput (C58 , C59 , C60) -> (Element of ( InnerVertices ( GFA0CarryStr (C58 , C59 , C60) ) )) equals 
[ <* [ <* C58 , C59 *> , ( and2 ) ] , [ <* C59 , C60 *> , ( and2 ) ] , [ <* C60 , C58 *> , ( and2 ) ] *> , ( or3 ) ];
coherence
proof
L162: [ <* [ <* C58 , C59 *> , ( and2 ) ] , [ <* C59 , C60 *> , ( and2 ) ] , [ <* C60 , C58 *> , ( and2 ) ] *> , ( or3 ) ] in ( InnerVertices ( 1GateCircStr (<* [ <* C58 , C59 *> , ( and2 ) ] , [ <* C59 , C60 *> , ( and2 ) ] , [ <* C60 , C58 *> , ( and2 ) ] *> , ( or3 )) ) ) by FACIRC_1:47;
thus L163: thesis by L162 , FACIRC_1:21;
end;
end;
theorem
L165: (for B93 , B94 , B95 being set holds ( InnerVertices ( GFA0CarryIStr (B93 , B94 , B95) ) ) = { [ <* B93 , B94 *> , ( and2 ) ] , [ <* B94 , B95 *> , ( and2 ) ] , [ <* B95 , B93 *> , ( and2 ) ] })
proof
let C61 , C62 , C63 being set;
set D29 = ( and2 );
set D30 = ( and2 );
set D31 = ( and2 );
set D32 = [ <* C61 , C62 *> , D29 ];
set D33 = [ <* C62 , C63 *> , D30 ];
set D34 = [ <* C63 , C61 *> , D31 ];
set D35 = ( 1GateCircStr (<* C61 , C62 *> , D29) );
set D36 = ( 1GateCircStr (<* C62 , C63 *> , D30) );
set D37 = ( 1GateCircStr (<* C63 , C61 *> , D31) );
L166: D35 tolerates D36 by CIRCCOMB:47;
L167: ( D35 +* D36 ) tolerates D37 by CIRCCOMB:47;
L168: ( InnerVertices ( GFA0CarryIStr (C61 , C62 , C63) ) ) = ( ( InnerVertices ( D35 +* D36 ) ) \/ ( InnerVertices D37 ) ) by L167 , CIRCCOMB:11
.= ( ( ( InnerVertices D35 ) \/ ( InnerVertices D36 ) ) \/ ( InnerVertices D37 ) ) by L166 , CIRCCOMB:11
.= ( ( { D32 } \/ ( InnerVertices D36 ) ) \/ ( InnerVertices D37 ) ) by CIRCCOMB:42
.= ( ( { D32 } \/ { D33 } ) \/ ( InnerVertices D37 ) ) by CIRCCOMB:42
.= ( ( { D32 } \/ { D33 } ) \/ { D34 } ) by CIRCCOMB:42
.= ( { D32 , D33 } \/ { D34 } ) by ENUMSET1:1
.= { D32 , D33 , D34 } by ENUMSET1:3;
thus L169: thesis by L168;
end;
theorem
L170: (for B96 , B97 , B98 being set holds ( InnerVertices ( GFA0CarryStr (B96 , B97 , B98) ) ) = ( { [ <* B96 , B97 *> , ( and2 ) ] , [ <* B97 , B98 *> , ( and2 ) ] , [ <* B98 , B96 *> , ( and2 ) ] } \/ { ( GFA0CarryOutput (B96 , B97 , B98) ) } ))
proof
let C64 , C65 , C66 being set;
set D38 = ( and2 );
set D39 = ( and2 );
set D40 = ( and2 );
set D41 = ( or3 );
set D42 = [ <* C64 , C65 *> , D38 ];
set D43 = [ <* C65 , C66 *> , D39 ];
set D44 = [ <* C66 , C64 *> , D40 ];
set D45 = ( 1GateCircStr (<* C64 , C65 *> , D38) );
set D46 = ( 1GateCircStr (<* C65 , C66 *> , D39) );
set D47 = ( 1GateCircStr (<* C66 , C64 *> , D40) );
set D48 = ( 1GateCircStr (<* D42 , D43 , D44 *> , D41) );
L171: D45 tolerates ( ( D46 +* D47 ) +* D48 ) by CIRCCOMB:47;
L172: D46 tolerates ( D47 +* D48 ) by CIRCCOMB:47;
L173: ( InnerVertices ( D46 +* ( D47 +* D48 ) ) ) = ( ( InnerVertices D46 ) \/ ( InnerVertices ( D47 +* D48 ) ) ) by L172 , CIRCCOMB:11;
L174: D47 tolerates D48 by CIRCCOMB:47;
L175: ( InnerVertices ( D47 +* D48 ) ) = ( ( InnerVertices D47 ) \/ ( InnerVertices D48 ) ) by L174 , CIRCCOMB:11;
thus L176: ( InnerVertices ( GFA0CarryStr (C64 , C65 , C66) ) ) = ( InnerVertices ( ( D45 +* ( D46 +* D47 ) ) +* D48 ) ) by CIRCCOMB:6
.= ( InnerVertices ( D45 +* ( ( D46 +* D47 ) +* D48 ) ) ) by CIRCCOMB:6
.= ( ( InnerVertices D45 ) \/ ( InnerVertices ( ( D46 +* D47 ) +* D48 ) ) ) by L171 , CIRCCOMB:11
.= ( ( InnerVertices D45 ) \/ ( InnerVertices ( D46 +* ( D47 +* D48 ) ) ) ) by CIRCCOMB:6
.= ( ( ( InnerVertices D45 ) \/ ( InnerVertices D46 ) ) \/ ( ( InnerVertices D47 ) \/ ( InnerVertices D48 ) ) ) by L173 , L175 , XBOOLE_1:4
.= ( ( ( ( InnerVertices D45 ) \/ ( InnerVertices D46 ) ) \/ ( InnerVertices D47 ) ) \/ ( InnerVertices D48 ) ) by XBOOLE_1:4
.= ( ( ( { D42 } \/ ( InnerVertices D46 ) ) \/ ( InnerVertices D47 ) ) \/ ( InnerVertices D48 ) ) by CIRCCOMB:42
.= ( ( ( { D42 } \/ { D43 } ) \/ ( InnerVertices D47 ) ) \/ ( InnerVertices D48 ) ) by CIRCCOMB:42
.= ( ( ( { D42 } \/ { D43 } ) \/ { D44 } ) \/ ( InnerVertices D48 ) ) by CIRCCOMB:42
.= ( ( { D42 , D43 } \/ { D44 } ) \/ ( InnerVertices D48 ) ) by ENUMSET1:1
.= ( { D42 , D43 , D44 } \/ ( InnerVertices D48 ) ) by ENUMSET1:3
.= ( { D42 , D43 , D44 } \/ { ( GFA0CarryOutput (C64 , C65 , C66) ) } ) by CIRCCOMB:42;
end;
theorem
L177: (for B99 , B100 , B101 being set holds ( InnerVertices ( GFA0CarryStr (B99 , B100 , B101) ) ) is Relation)
proof
let C67 , C68 , C69 being set;
set D49 = ( and2 );
set D50 = ( and2 );
set D51 = ( and2 );
set D52 = ( or3 );
set D53 = [ <* C67 , C68 *> , D49 ];
set D54 = [ <* C68 , C69 *> , D50 ];
set D55 = [ <* C69 , C67 *> , D51 ];
set D56 = ( 1GateCircStr (<* C67 , C68 *> , D49) );
set D57 = ( 1GateCircStr (<* C68 , C69 *> , D50) );
set D58 = ( 1GateCircStr (<* C69 , C67 *> , D51) );
set D59 = ( 1GateCircStr (<* D53 , D54 , D55 *> , D52) );
L178: (( InnerVertices D56 ) is Relation & ( InnerVertices D57 ) is Relation) by FACIRC_1:38;
L179: (( InnerVertices D58 ) is Relation & ( InnerVertices ( D56 +* D57 ) ) is Relation) by L178 , FACIRC_1:3 , FACIRC_1:38;
L180: (( InnerVertices D59 ) is Relation & ( InnerVertices ( GFA0CarryIStr (C67 , C68 , C69) ) ) is Relation) by L179 , FACIRC_1:3 , FACIRC_1:38;
thus L181: thesis by L180 , FACIRC_1:3;
end;
theorem
L182: (for B102 , B103 , B104 being set holds ((B102 <> [ <* B103 , B104 *> , ( and2 ) ] & B103 <> [ <* B104 , B102 *> , ( and2 ) ] & B104 <> [ <* B102 , B103 *> , ( and2 ) ]) implies ( InputVertices ( GFA0CarryIStr (B102 , B103 , B104) ) ) = { B102 , B103 , B104 }))
proof
let C70 , C71 , C72 being set;
set D60 = ( and2 );
set D61 = ( and2 );
set D62 = ( and2 );
set D63 = [ <* C70 , C71 *> , D60 ];
set D64 = [ <* C71 , C72 *> , D61 ];
set D65 = [ <* C72 , C70 *> , D62 ];
set D66 = ( 1GateCircStr (<* C70 , C71 *> , D60) );
set D67 = ( 1GateCircStr (<* C71 , C72 *> , D61) );
set D68 = ( 1GateCircStr (<* C72 , C70 *> , D62) );
assume that
L183: C70 <> D64
and
L184: (C71 <> D65 & C72 <> D63);
L185: (not D63 in { C71 , C72 }) by L183 , L184 , L70;
L186: (not D65 in { C70 , C71 , C72 }) by L183 , L184 , L70;
L187: C71 <> [ <* C71 , C72 *> , D61 ] by FACIRC_2:2;
L188: ((not C72 in { D63 , D64 }) & (not C70 in { D63 , D64 })) by L183 , L184 , L70;
L189: D66 tolerates D67 by CIRCCOMB:47;
L190: ( InputVertices ( GFA0CarryIStr (C70 , C71 , C72) ) ) = ( ( ( InputVertices ( D66 +* D67 ) ) \ ( InnerVertices D68 ) ) \/ ( ( InputVertices D68 ) \ ( InnerVertices ( D66 +* D67 ) ) ) ) by CIRCCMB2:5 , CIRCCOMB:47
.= ( ( ( ( ( InputVertices D66 ) \ ( InnerVertices D67 ) ) \/ ( ( InputVertices D67 ) \ ( InnerVertices D66 ) ) ) \ ( InnerVertices D68 ) ) \/ ( ( InputVertices D68 ) \ ( InnerVertices ( D66 +* D67 ) ) ) ) by CIRCCMB2:5 , CIRCCOMB:47
.= ( ( ( ( ( InputVertices D66 ) \ ( InnerVertices D67 ) ) \/ ( ( InputVertices D67 ) \ ( InnerVertices D66 ) ) ) \ ( InnerVertices D68 ) ) \/ ( ( InputVertices D68 ) \ ( ( InnerVertices D66 ) \/ ( InnerVertices D67 ) ) ) ) by L189 , CIRCCOMB:11
.= ( ( ( ( ( InputVertices D66 ) \ { D64 } ) \/ ( ( InputVertices D67 ) \ ( InnerVertices D66 ) ) ) \ ( InnerVertices D68 ) ) \/ ( ( InputVertices D68 ) \ ( ( InnerVertices D66 ) \/ ( InnerVertices D67 ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices D66 ) \ { D64 } ) \/ ( ( InputVertices D67 ) \ { D63 } ) ) \ ( InnerVertices D68 ) ) \/ ( ( InputVertices D68 ) \ ( ( InnerVertices D66 ) \/ ( InnerVertices D67 ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices D66 ) \ { D64 } ) \/ ( ( InputVertices D67 ) \ { D63 } ) ) \ { D65 } ) \/ ( ( InputVertices D68 ) \ ( ( InnerVertices D66 ) \/ ( InnerVertices D67 ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices D66 ) \ { D64 } ) \/ ( ( InputVertices D67 ) \ { D63 } ) ) \ { D65 } ) \/ ( ( InputVertices D68 ) \ ( { D63 } \/ ( InnerVertices D67 ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices D66 ) \ { D64 } ) \/ ( ( InputVertices D67 ) \ { D63 } ) ) \ { D65 } ) \/ ( ( InputVertices D68 ) \ ( { D63 } \/ { D64 } ) ) ) by CIRCCOMB:42
.= ( ( ( ( { C70 , C71 } \ { D64 } ) \/ ( ( InputVertices D67 ) \ { D63 } ) ) \ { D65 } ) \/ ( ( InputVertices D68 ) \ ( { D63 } \/ { D64 } ) ) ) by FACIRC_1:40
.= ( ( ( ( { C70 , C71 } \ { D64 } ) \/ ( { C71 , C72 } \ { D63 } ) ) \ { D65 } ) \/ ( ( InputVertices D68 ) \ ( { D63 } \/ { D64 } ) ) ) by FACIRC_1:40
.= ( ( ( ( { C70 , C71 } \ { D64 } ) \/ ( { C71 , C72 } \ { D63 } ) ) \ { D65 } ) \/ ( { C72 , C70 } \ ( { D63 } \/ { D64 } ) ) ) by FACIRC_1:40
.= ( ( ( ( { C70 , C71 } \ { D64 } ) \/ ( { C71 , C72 } \ { D63 } ) ) \ { D65 } ) \/ ( { C72 , C70 } \ { D63 , D64 } ) ) by ENUMSET1:1
.= ( ( ( { C70 , C71 } \/ ( { C71 , C72 } \ { D63 } ) ) \ { D65 } ) \/ ( { C72 , C70 } \ { D63 , D64 } ) ) by L183 , L187 , FACIRC_2:1
.= ( ( ( { C70 , C71 } \/ { C71 , C72 } ) \ { D65 } ) \/ ( { C72 , C70 } \ { D63 , D64 } ) ) by L185 , ZFMISC_1:57
.= ( ( ( { C70 , C71 } \/ { C71 , C72 } ) \ { D65 } ) \/ { C72 , C70 } ) by L188 , ZFMISC_1:63
.= ( ( { C70 , C71 , C71 , C72 } \ { D65 } ) \/ { C72 , C70 } ) by ENUMSET1:5
.= ( ( { C71 , C71 , C70 , C72 } \ { D65 } ) \/ { C72 , C70 } ) by ENUMSET1:67
.= ( ( { C71 , C70 , C72 } \ { D65 } ) \/ { C72 , C70 } ) by ENUMSET1:31
.= ( ( { C70 , C71 , C72 } \ { D65 } ) \/ { C72 , C70 } ) by ENUMSET1:58
.= ( { C70 , C71 , C72 } \/ { C72 , C70 } ) by L186 , ZFMISC_1:57
.= { C70 , C71 , C72 , C72 , C70 } by ENUMSET1:9
.= ( { C70 , C71 , C72 , C72 } \/ { C70 } ) by ENUMSET1:10
.= ( { C72 , C72 , C70 , C71 } \/ { C70 } ) by ENUMSET1:73
.= ( { C72 , C70 , C71 } \/ { C70 } ) by ENUMSET1:31
.= { C72 , C70 , C71 , C70 } by ENUMSET1:6
.= { C70 , C70 , C71 , C72 } by ENUMSET1:70
.= { C70 , C71 , C72 } by ENUMSET1:31;
thus L191: thesis by L190;
end;
theorem
L192: (for B105 , B106 , B107 being set holds ((B105 <> [ <* B106 , B107 *> , ( and2 ) ] & B106 <> [ <* B107 , B105 *> , ( and2 ) ] & B107 <> [ <* B105 , B106 *> , ( and2 ) ]) implies ( InputVertices ( GFA0CarryStr (B105 , B106 , B107) ) ) = { B105 , B106 , B107 }))
proof
let C73 , C74 , C75 being set;
set D69 = ( and2 );
set D70 = ( and2 );
set D71 = ( and2 );
set D72 = ( or3 );
set D73 = [ <* C73 , C74 *> , D69 ];
set D74 = [ <* C74 , C75 *> , D70 ];
set D75 = [ <* C75 , C73 *> , D71 ];
set D76 = [ <* D73 , D74 , D75 *> , D72 ];
set D77 = ( 1GateCircStr (<* D73 , D74 , D75 *> , D72) );
set D78 = ( GFA0CarryIStr (C73 , C74 , C75) );
assume L193: (C73 <> D74 & C74 <> D75 & C75 <> D73);
L194: ( InputVertices D77 ) = ( rng <* D73 , D74 , D75 *> ) by CIRCCOMB:42
.= { D73 , D74 , D75 } by FINSEQ_2:128;
L195: (( InnerVertices D77 ) = { D76 } & ( { C73 , C74 , C75 } \ { D76 } ) = { C73 , C74 , C75 }) by L112 , CIRCCOMB:42;
L196: ( { D73 , D74 , D75 } \ { D73 , D74 , D75 } ) = ( {} ) by XBOOLE_1:37;
thus L197: ( InputVertices ( GFA0CarryStr (C73 , C74 , C75) ) ) = ( ( ( InputVertices D78 ) \ ( InnerVertices D77 ) ) \/ ( ( InputVertices D77 ) \ ( InnerVertices D78 ) ) ) by CIRCCMB2:5 , CIRCCOMB:47
.= ( { C73 , C74 , C75 } \/ ( { D73 , D74 , D75 } \ ( InnerVertices D78 ) ) ) by L193 , L194 , L195 , L182
.= ( { C73 , C74 , C75 } \/ ( {} ) ) by L196 , L165
.= { C73 , C74 , C75 };
end;
theorem
L198: (for B108 , B109 , B110 being non  pair set holds ( InputVertices ( GFA0CarryStr (B108 , B109 , B110) ) ) is  without_pairs)
proof
let C76 , C77 , C78 being non  pair set;
set D79 = ( and2 );
set D80 = ( and2 );
set D81 = ( and2 );
set D82 = ( or3 );
set D83 = [ <* C76 , C77 *> , D79 ];
set D84 = [ <* C77 , C78 *> , D80 ];
set D85 = [ <* C78 , C76 *> , D81 ];
set D86 = ( 1GateCircStr (<* C76 , C77 *> , D79) );
set D87 = ( 1GateCircStr (<* C77 , C78 *> , D80) );
set D88 = ( 1GateCircStr (<* C78 , C76 *> , D81) );
set D89 = ( 1GateCircStr (<* D83 , D84 , D85 *> , D82) );
set D90 = ( GFA0CarryStr (C76 , C77 , C78) );
set D91 = ( GFA0CarryIStr (C76 , C77 , C78) );
given C79 being  pair set such that
L199: C79 in ( InputVertices D90 );

L200: D86 tolerates D87 by CIRCCOMB:47;
L201: (( InnerVertices D88 ) = { D85 } & ( D86 +* D87 ) tolerates D88) by CIRCCOMB:42 , CIRCCOMB:47;
L202: (( InnerVertices D86 ) = { D83 } & ( InnerVertices D87 ) = { D84 }) by CIRCCOMB:42;
L203: ( InnerVertices ( D86 +* D87 ) ) = ( { D83 } \/ { D84 } ) by L202 , L200 , CIRCCOMB:11;
L204: ( InnerVertices D91 ) = ( ( { D83 } \/ { D84 } ) \/ { D85 } ) by L203 , L201 , CIRCCOMB:11
.= ( { D83 , D84 } \/ { D85 } ) by ENUMSET1:1
.= { D83 , D84 , D85 } by ENUMSET1:3;
L205: ( InputVertices D89 ) = { D83 , D84 , D85 } by FACIRC_1:42;
L206: ( ( InputVertices D89 ) \ ( InnerVertices D91 ) ) = ( {} ) by L205 , L204 , XBOOLE_1:37;
L207: (( InputVertices D86 ) is  without_pairs & ( InputVertices D87 ) is  without_pairs) by FACIRC_1:41;
L208: (( InputVertices D88 ) is  without_pairs & ( InputVertices ( D86 +* D87 ) ) is  without_pairs) by L207 , FACIRC_1:9 , FACIRC_1:41;
L209: ( InputVertices D91 ) is  without_pairs by L208 , FACIRC_1:9;
L210: ( InnerVertices D89 ) is Relation by FACIRC_1:38;
L211: ( InputVertices D90 ) = ( ( InputVertices D91 ) \/ ( ( InputVertices D89 ) \ ( InnerVertices D91 ) ) ) by L210 , L209 , FACIRC_1:6;
thus L212: thesis by L211 , L209 , L199 , L206 , FACIRC_1:def 2;
end;
theorem
L213: (for B111 , B112 , B113 being set holds (B111 in (the carrier of ( GFA0CarryStr (B111 , B112 , B113) )) & B112 in (the carrier of ( GFA0CarryStr (B111 , B112 , B113) )) & B113 in (the carrier of ( GFA0CarryStr (B111 , B112 , B113) )) & [ <* B111 , B112 *> , ( and2 ) ] in (the carrier of ( GFA0CarryStr (B111 , B112 , B113) )) & [ <* B112 , B113 *> , ( and2 ) ] in (the carrier of ( GFA0CarryStr (B111 , B112 , B113) )) & [ <* B113 , B111 *> , ( and2 ) ] in (the carrier of ( GFA0CarryStr (B111 , B112 , B113) )) & [ <* [ <* B111 , B112 *> , ( and2 ) ] , [ <* B112 , B113 *> , ( and2 ) ] , [ <* B113 , B111 *> , ( and2 ) ] *> , ( or3 ) ] in (the carrier of ( GFA0CarryStr (B111 , B112 , B113) ))))
proof
let C80 , C81 , C82 being set;
set D92 = ( and2 );
set D93 = ( and2 );
set D94 = ( and2 );
set D95 = ( or3 );
set D96 = [ <* C80 , C81 *> , D92 ];
set D97 = [ <* C81 , C82 *> , D93 ];
set D98 = [ <* C82 , C80 *> , D94 ];
set D99 = [ <* D96 , D97 , D98 *> , D95 ];
set D100 = ( 1GateCircStr (<* C80 , C81 *> , D92) );
set D101 = ( 1GateCircStr (<* C81 , C82 *> , D93) );
set D102 = ( 1GateCircStr (<* C82 , C80 *> , D94) );
set D103 = ( 1GateCircStr (<* D96 , D97 , D98 *> , D95) );
set D104 = <* D96 , D97 , D98 *>;
L214: C82 in (the carrier of D102) by FACIRC_1:43;
L215: C82 in (the carrier of ( GFA0CarryIStr (C80 , C81 , C82) )) by L214 , FACIRC_1:20;
L216: D98 in (the carrier of D102) by FACIRC_1:43;
L217: D98 in (the carrier of ( GFA0CarryIStr (C80 , C81 , C82) )) by L216 , FACIRC_1:20;
L218: C81 in (the carrier of D100) by FACIRC_1:43;
L219: C81 in (the carrier of ( D100 +* D101 )) by L218 , FACIRC_1:20;
L220: C81 in (the carrier of ( GFA0CarryIStr (C80 , C81 , C82) )) by L219 , FACIRC_1:20;
L221: ((the carrier of D103) = ( ( rng D104 ) \/ { D99 } ) & [ D104 , D95 ] in { [ D104 , D95 ] }) by CIRCCOMB:def 6 , TARSKI:def 1;
L222: D99 in (the carrier of D103) by L221 , XBOOLE_0:def 3;
L223: D97 in (the carrier of D101) by FACIRC_1:43;
L224: D97 in (the carrier of ( D100 +* D101 )) by L223 , FACIRC_1:20;
L225: D97 in (the carrier of ( GFA0CarryIStr (C80 , C81 , C82) )) by L224 , FACIRC_1:20;
L226: D96 in (the carrier of D100) by FACIRC_1:43;
L227: D96 in (the carrier of ( D100 +* D101 )) by L226 , FACIRC_1:20;
L228: D96 in (the carrier of ( GFA0CarryIStr (C80 , C81 , C82) )) by L227 , FACIRC_1:20;
L229: C80 in (the carrier of D102) by FACIRC_1:43;
L230: C80 in (the carrier of ( GFA0CarryIStr (C80 , C81 , C82) )) by L229 , FACIRC_1:20;
thus L231: thesis by L230 , L220 , L215 , L228 , L225 , L217 , L222 , FACIRC_1:20;
end;
theorem
L232: (for B114 , B115 , B116 being set holds ([ <* B114 , B115 *> , ( and2 ) ] in ( InnerVertices ( GFA0CarryStr (B114 , B115 , B116) ) ) & [ <* B115 , B116 *> , ( and2 ) ] in ( InnerVertices ( GFA0CarryStr (B114 , B115 , B116) ) ) & [ <* B116 , B114 *> , ( and2 ) ] in ( InnerVertices ( GFA0CarryStr (B114 , B115 , B116) ) ) & ( GFA0CarryOutput (B114 , B115 , B116) ) in ( InnerVertices ( GFA0CarryStr (B114 , B115 , B116) ) )))
proof
let C83 , C84 , C85 being set;
set D105 = ( and2 );
set D106 = ( and2 );
set D107 = ( and2 );
set D108 = [ <* C83 , C84 *> , D105 ];
set D109 = [ <* C84 , C85 *> , D106 ];
set D110 = [ <* C85 , C83 *> , D107 ];
L233: ( InnerVertices ( GFA0CarryStr (C83 , C84 , C85) ) ) = ( { D108 , D109 , D110 } \/ { ( GFA0CarryOutput (C83 , C84 , C85) ) } ) by L170
.= { D108 , D109 , D110 , ( GFA0CarryOutput (C83 , C84 , C85) ) } by ENUMSET1:6;
thus L234: thesis by L233 , ENUMSET1:def 2;
end;
theorem
L235: (for B117 , B118 , B119 being set holds ((B117 <> [ <* B118 , B119 *> , ( and2 ) ] & B118 <> [ <* B119 , B117 *> , ( and2 ) ] & B119 <> [ <* B117 , B118 *> , ( and2 ) ]) implies (B117 in ( InputVertices ( GFA0CarryStr (B117 , B118 , B119) ) ) & B118 in ( InputVertices ( GFA0CarryStr (B117 , B118 , B119) ) ) & B119 in ( InputVertices ( GFA0CarryStr (B117 , B118 , B119) ) ))))
proof
set D111 = ( and2 );
set D112 = ( and2 );
set D113 = ( and2 );
let C86 , C87 , C88 being set;
assume L236: (C86 <> [ <* C87 , C88 *> , D112 ] & C87 <> [ <* C88 , C86 *> , D113 ] & C88 <> [ <* C86 , C87 *> , D111 ]);
L237: ( InputVertices ( GFA0CarryStr (C86 , C87 , C88) ) ) = { C86 , C87 , C88 } by L236 , L192;
thus L238: thesis by L237 , ENUMSET1:def 1;
end;
theorem
L239: (for B120 , B121 , B122 being non  pair set holds ( InputVertices ( GFA0CarryStr (B120 , B121 , B122) ) ) = { B120 , B121 , B122 })
proof
let C89 , C90 , C91 being non  pair set;
set D114 = ( and2 );
set D115 = ( and2 );
set D116 = ( and2 );
set D117 = ( or3 );
set D118 = [ <* C89 , C90 *> , D114 ];
set D119 = [ <* C90 , C91 *> , D115 ];
set D120 = [ <* C91 , C89 *> , D116 ];
set D121 = ( 1GateCircStr (<* C89 , C90 *> , D114) );
set D122 = ( 1GateCircStr (<* C90 , C91 *> , D115) );
set D123 = ( 1GateCircStr (<* C91 , C89 *> , D116) );
set D124 = ( GFA0CarryStr (C89 , C90 , C91) );
set D125 = ( GFA0CarryIStr (C89 , C90 , C91) );
set D126 = ( 1GateCircStr (<* D118 , D119 , D120 *> , D117) );
L240: (( InputVertices D121 ) = { C89 , C90 } & ( InputVertices D122 ) = { C90 , C91 }) by FACIRC_1:40;
L241: ( InputVertices D123 ) = { C91 , C89 } by FACIRC_1:40;
L242: ( InputVertices D126 ) = { D118 , D119 , D120 } by FACIRC_1:42;
L243: ( InnerVertices D126 ) is Relation by FACIRC_1:38;
L244: (( InnerVertices D121 ) = { D118 } & ( InnerVertices D122 ) = { D119 }) by CIRCCOMB:42;
L245: D121 tolerates D122 by CIRCCOMB:47;
L246: (( InnerVertices D123 ) = { D120 } & ( InnerVertices ( D121 +* D122 ) ) = ( { D118 } \/ { D119 } )) by L245 , L244 , CIRCCOMB:11 , CIRCCOMB:42;
L247: ( D121 +* D122 ) tolerates D123 by CIRCCOMB:47;
L248: ( InnerVertices D125 ) = ( ( { D118 } \/ { D119 } ) \/ { D120 } ) by L247 , L246 , CIRCCOMB:11
.= ( { D118 , D119 } \/ { D120 } ) by ENUMSET1:1
.= { D118 , D119 , D120 } by ENUMSET1:3;
L249: ( ( InputVertices D126 ) \ ( InnerVertices D125 ) ) = ( {} ) by L248 , L242 , XBOOLE_1:37;
L250: (( InputVertices D121 ) is  without_pairs & ( InputVertices D122 ) is  without_pairs) by FACIRC_1:41;
L251: (( InputVertices D123 ) is  without_pairs & ( InputVertices ( D121 +* D122 ) ) is  without_pairs) by L250 , FACIRC_1:9 , FACIRC_1:41;
L252: ( InputVertices D125 ) is  without_pairs by L251 , FACIRC_1:9;
L253: ( InputVertices D124 ) = ( ( InputVertices D125 ) \/ ( ( InputVertices D126 ) \ ( InnerVertices D125 ) ) ) by L252 , L243 , FACIRC_1:6;
thus L254: ( InputVertices D124 ) = ( ( InputVertices ( D121 +* D122 ) ) \/ ( InputVertices D123 ) ) by L253 , L251 , L246 , L249 , FACIRC_1:7
.= ( ( ( InputVertices D121 ) \/ ( InputVertices D122 ) ) \/ ( InputVertices D123 ) ) by L250 , L244 , FACIRC_1:7
.= ( { C89 , C90 , C90 , C91 } \/ { C91 , C89 } ) by L240 , L241 , ENUMSET1:5
.= ( { C90 , C90 , C89 , C91 } \/ { C91 , C89 } ) by ENUMSET1:67
.= ( { C90 , C89 , C91 } \/ { C91 , C89 } ) by ENUMSET1:31
.= ( { C89 , C90 , C91 } \/ { C91 , C89 } ) by ENUMSET1:58
.= ( { C89 , C90 , C91 } \/ ( { C91 } \/ { C89 } ) ) by ENUMSET1:1
.= ( ( { C89 , C90 , C91 } \/ { C91 } ) \/ { C89 } ) by XBOOLE_1:4
.= ( ( { C91 , C89 , C90 } \/ { C91 } ) \/ { C89 } ) by ENUMSET1:59
.= ( { C91 , C91 , C89 , C90 } \/ { C89 } ) by ENUMSET1:4
.= ( { C91 , C89 , C90 } \/ { C89 } ) by ENUMSET1:31
.= ( { C89 , C90 , C91 } \/ { C89 } ) by ENUMSET1:59
.= { C89 , C89 , C90 , C91 } by ENUMSET1:4
.= { C89 , C90 , C91 } by ENUMSET1:31;
end;
theorem
L255: (for B123 , B124 , B125 being set holds (for B126 being (State of ( GFA0CarryCirc (B123 , B124 , B125) )) holds (for B127 , B128 , B129 being (Element of ( BOOLEAN )) holds ((B127 = ( B126 . B123 ) & B128 = ( B126 . B124 ) & B129 = ( B126 . B125 )) implies (( ( Following B126 ) . [ <* B123 , B124 *> , ( and2 ) ] ) = ( B127 '&' B128 ) & ( ( Following B126 ) . [ <* B124 , B125 *> , ( and2 ) ] ) = ( B128 '&' B129 ) & ( ( Following B126 ) . [ <* B125 , B123 *> , ( and2 ) ] ) = ( B129 '&' B127 ))))))
proof
let C92 , C93 , C94 being set;
set D127 = ( and2 );
set D128 = ( and2 );
set D129 = ( and2 );
let C95 being (State of ( GFA0CarryCirc (C92 , C93 , C94) ));
set D130 = [ <* C92 , C93 *> , D127 ];
set D131 = [ <* C93 , C94 *> , D128 ];
set D132 = [ <* C94 , C92 *> , D129 ];
let C96 , C97 , C98 being (Element of ( BOOLEAN ));
assume that
L256: C96 = ( C95 . C92 )
and
L257: C97 = ( C95 . C93 )
and
L258: C98 = ( C95 . C94 );
set D133 = ( GFA0CarryStr (C92 , C93 , C94) );
L259: ( InnerVertices D133 ) = (the carrier' of D133) by FACIRC_1:37;
L260: C93 in (the carrier of D133) by L213;
L261: C92 in (the carrier of D133) by L213;
L262: ( dom C95 ) = (the carrier of D133) by CIRCUIT1:3;
L263: D130 in ( InnerVertices ( GFA0CarryStr (C92 , C93 , C94) ) ) by L232;
thus L264: ( ( Following C95 ) . [ <* C92 , C93 *> , D127 ] ) = ( D127 . ( C95 * <* C92 , C93 *> ) ) by L263 , L259 , FACIRC_1:35
.= ( D127 . <* C96 , C97 *> ) by L256 , L257 , L262 , L261 , L260 , FINSEQ_2:125
.= ( C96 '&' C97 ) by TWOSCOMP:def 1;
L265: C94 in (the carrier of D133) by L213;
L266: D131 in ( InnerVertices ( GFA0CarryStr (C92 , C93 , C94) ) ) by L232;
thus L267: ( ( Following C95 ) . [ <* C93 , C94 *> , D128 ] ) = ( D128 . ( C95 * <* C93 , C94 *> ) ) by L266 , L259 , FACIRC_1:35
.= ( D128 . <* C97 , C98 *> ) by L257 , L258 , L262 , L260 , L265 , FINSEQ_2:125
.= ( C97 '&' C98 ) by TWOSCOMP:def 1;
L268: D132 in ( InnerVertices ( GFA0CarryStr (C92 , C93 , C94) ) ) by L232;
thus L269: ( ( Following C95 ) . [ <* C94 , C92 *> , D129 ] ) = ( D129 . ( C95 * <* C94 , C92 *> ) ) by L268 , L259 , FACIRC_1:35
.= ( D129 . <* C98 , C96 *> ) by L256 , L258 , L262 , L261 , L265 , FINSEQ_2:125
.= ( C98 '&' C96 ) by TWOSCOMP:def 1;
end;
theorem
L270: (for B130 , B131 , B132 being set holds (for B133 being (State of ( GFA0CarryCirc (B130 , B131 , B132) )) holds (for B134 , B135 , B136 being (Element of ( BOOLEAN )) holds ((B134 = ( B133 . [ <* B130 , B131 *> , ( and2 ) ] ) & B135 = ( B133 . [ <* B131 , B132 *> , ( and2 ) ] ) & B136 = ( B133 . [ <* B132 , B130 *> , ( and2 ) ] )) implies ( ( Following B133 ) . ( GFA0CarryOutput (B130 , B131 , B132) ) ) = ( ( B134 'or' B135 ) 'or' B136 )))))
proof
let C99 , C100 , C101 being set;
set D134 = ( and2 );
set D135 = ( and2 );
set D136 = ( and2 );
set D137 = ( or3 );
let C102 being (State of ( GFA0CarryCirc (C99 , C100 , C101) ));
set D138 = [ <* C99 , C100 *> , D134 ];
set D139 = [ <* C100 , C101 *> , D135 ];
set D140 = [ <* C101 , C99 *> , D136 ];
let C103 , C104 , C105 being (Element of ( BOOLEAN ));
assume that
L271: (C103 = ( C102 . D138 ) & C104 = ( C102 . D139 ) & C105 = ( C102 . D140 ));
set D141 = ( GFA0CarryStr (C99 , C100 , C101) );
reconsider D142 = D138 , D143 = D139 , D144 = D140 as (Element of ( InnerVertices D141 )) by L232;
L272: ( dom C102 ) = (the carrier of D141) by CIRCUIT1:3;
L273: ( InnerVertices D141 ) = (the carrier' of D141) by FACIRC_1:37;
thus L274: ( ( Following C102 ) . ( GFA0CarryOutput (C99 , C100 , C101) ) ) = ( D137 . ( C102 * <* D142 , D143 , D144 *> ) ) by L273 , FACIRC_1:35
.= ( D137 . <* C103 , C104 , C105 *> ) by L271 , L272 , FINSEQ_2:126
.= ( ( C103 'or' C104 ) 'or' C105 ) by TWOSCOMP:14;
end;
theorem
L275: (for B137 , B138 , B139 being set holds ((B137 <> [ <* B138 , B139 *> , ( and2 ) ] & B138 <> [ <* B139 , B137 *> , ( and2 ) ] & B139 <> [ <* B137 , B138 *> , ( and2 ) ]) implies (for B140 being (State of ( GFA0CarryCirc (B137 , B138 , B139) )) holds (for B141 , B142 , B143 being (Element of ( BOOLEAN )) holds ((B141 = ( B140 . B137 ) & B142 = ( B140 . B138 ) & B143 = ( B140 . B139 )) implies (( ( Following (B140 , 2) ) . ( GFA0CarryOutput (B137 , B138 , B139) ) ) = ( ( ( B141 '&' B142 ) 'or' ( B142 '&' B143 ) ) 'or' ( B143 '&' B141 ) ) & ( ( Following (B140 , 2) ) . [ <* B137 , B138 *> , ( and2 ) ] ) = ( B141 '&' B142 ) & ( ( Following (B140 , 2) ) . [ <* B138 , B139 *> , ( and2 ) ] ) = ( B142 '&' B143 ) & ( ( Following (B140 , 2) ) . [ <* B139 , B137 *> , ( and2 ) ] ) = ( B143 '&' B141 )))))))
proof
set D145 = ( and2 );
set D146 = ( and2 );
set D147 = ( and2 );
let C106 , C107 , C108 being set;
assume that
L276: (C106 <> [ <* C107 , C108 *> , D146 ] & C107 <> [ <* C108 , C106 *> , D147 ] & C108 <> [ <* C106 , C107 *> , D145 ]);
set D148 = ( GFA0CarryStr (C106 , C107 , C108) );
reconsider D149 = C106 , D150 = C107 , D151 = C108 as (Vertex of D148) by L213;
let C109 being (State of ( GFA0CarryCirc (C106 , C107 , C108) ));
L277: C107 in ( InputVertices D148 ) by L276 , L235;
L278: ( ( Following C109 ) . D150 ) = ( C109 . C107 ) by L277 , CIRCUIT2:def 5;
L279: C108 in ( InputVertices D148 ) by L276 , L235;
L280: ( ( Following C109 ) . D151 ) = ( C109 . C108 ) by L279 , CIRCUIT2:def 5;
set D152 = [ <* C106 , C107 *> , D145 ];
set D153 = [ <* C107 , C108 *> , D146 ];
set D154 = [ <* C108 , C106 *> , D147 ];
L281: ( Following (C109 , 2) ) = ( Following ( Following C109 ) ) by FACIRC_1:15;
let C110 , C111 , C112 being (Element of ( BOOLEAN ));
assume that
L282: (C110 = ( C109 . C106 ) & C111 = ( C109 . C107 ) & C112 = ( C109 . C108 ));
L283: ( ( Following C109 ) . D154 ) = ( C112 '&' C110 ) by L282 , L255;
L284: (( ( Following C109 ) . D152 ) = ( C110 '&' C111 ) & ( ( Following C109 ) . D153 ) = ( C111 '&' C112 )) by L282 , L255;
thus L285: ( ( Following (C109 , 2) ) . ( GFA0CarryOutput (C106 , C107 , C108) ) ) = ( ( ( C110 '&' C111 ) 'or' ( C111 '&' C112 ) ) 'or' ( C112 '&' C110 ) ) by L284 , L281 , L283 , L270;
L286: C106 in ( InputVertices D148 ) by L276 , L235;
L287: ( ( Following C109 ) . D149 ) = ( C109 . C106 ) by L286 , CIRCUIT2:def 5;
thus L288: thesis by L287 , L282 , L278 , L280 , L281 , L255;
end;
theorem
L289: (for B144 , B145 , B146 being set holds ((B144 <> [ <* B145 , B146 *> , ( and2 ) ] & B145 <> [ <* B146 , B144 *> , ( and2 ) ] & B146 <> [ <* B144 , B145 *> , ( and2 ) ]) implies (for B147 being (State of ( GFA0CarryCirc (B144 , B145 , B146) )) holds ( Following (B147 , 2) ) is  stable)))
proof
set D155 = ( and2 );
set D156 = ( and2 );
set D157 = ( and2 );
let C113 , C114 , C115 being set;
assume that
L290: (C113 <> [ <* C114 , C115 *> , D156 ] & C114 <> [ <* C115 , C113 *> , D157 ] & C115 <> [ <* C113 , C114 *> , D155 ]);
set D158 = ( GFA0CarryStr (C113 , C114 , C115) );
reconsider D159 = C113 , D160 = C114 , D161 = C115 as (Vertex of D158) by L213;
let C116 being (State of ( GFA0CarryCirc (C113 , C114 , C115) ));
set D162 = ( C116 . D159 );
set D163 = ( C116 . D160 );
set D164 = ( C116 . D161 );
set D165 = ( Following (C116 , 2) );
set D166 = ( Following D165 );
set D167 = [ <* C113 , C114 *> , D155 ];
set D168 = [ <* C114 , C115 *> , D156 ];
set D169 = [ <* C115 , C113 *> , D157 ];
L291: D165 = ( Following ( Following C116 ) ) by FACIRC_1:15;
L292: C115 in ( InputVertices D158 ) by L290 , L235;
L293: ( ( Following C116 ) . C115 ) = D164 by L292 , CIRCUIT2:def 5;
L294: ( D165 . C115 ) = D164 by L293 , L291 , L292 , CIRCUIT2:def 5;
L295: C114 in ( InputVertices D158 ) by L290 , L235;
L296: ( ( Following C116 ) . C114 ) = D163 by L295 , CIRCUIT2:def 5;
L297: ( D165 . C114 ) = D163 by L296 , L291 , L295 , CIRCUIT2:def 5;
L298: C113 in ( InputVertices D158 ) by L290 , L235;
L299: ( ( Following C116 ) . C113 ) = D162 by L298 , CIRCUIT2:def 5;
L300: ( D165 . C113 ) = D162 by L299 , L291 , L298 , CIRCUIT2:def 5;
L301: D164 = ( C116 . C115 );
L302: ( D165 . D167 ) = ( D162 '&' D163 ) by L301 , L290 , L275;
L303: D163 = ( C116 . C114 );
L304: ( D165 . D169 ) = ( D162 '&' D164 ) by L303 , L290 , L275;
L305: D162 = ( C116 . C113 );
L306: ( D165 . D168 ) = ( D163 '&' D164 ) by L305 , L290 , L275;
L307: ( D165 . ( GFA0CarryOutput (C113 , C114 , C115) ) ) = ( ( ( D162 '&' D163 ) 'or' ( D163 '&' D164 ) ) 'or' ( D164 '&' D162 ) ) by L290 , L275;
L308:
now
let C117 being set;
assume L309: C117 in (the carrier of D158);
reconsider D170 = C117 as (Vertex of D158) by L309;
L310: D170 in ( ( InputVertices D158 ) \/ ( InnerVertices D158 ) ) by L309 , XBOOLE_1:45;
thus L311: ( D165 . C117 ) = ( D166 . C117 )
proof
per cases  by L310 , XBOOLE_0:def 3;
suppose L312: D170 in ( InputVertices D158 );

thus L313: thesis by L312 , CIRCUIT2:def 5;
end;
suppose L314: D170 in ( InnerVertices D158 );

L315: D170 in ( { D167 , D168 , D169 } \/ { ( GFA0CarryOutput (C113 , C114 , C115) ) } ) by L314 , L170;
L316: (D170 in { D167 , D168 , D169 } or D170 in { ( GFA0CarryOutput (C113 , C114 , C115) ) }) by L315 , XBOOLE_0:def 3;
L317: (D170 = D167 or D170 = D168 or D170 = D169 or D170 = ( GFA0CarryOutput (C113 , C114 , C115) )) by L316 , ENUMSET1:def 1 , TARSKI:def 1;
thus L318: thesis by L317 , L307 , L302 , L306 , L304 , L300 , L297 , L294 , L255 , L270;
end;
end;

end;
L312: (( dom ( Following ( Following (C116 , 2) ) ) ) = (the carrier of D158) & ( dom ( Following (C116 , 2) ) ) = (the carrier of D158)) by CIRCUIT1:3;
thus L313: D165 = D166 by L312 , L308 , FUNCT_1:2;
end;
definition
let C118 , C119 , C120 being set;
func GFA0AdderStr (C118 , C119 , C120) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( 2GatesCircStr (C118 , C119 , C120 , ( xor2 )) );
coherence;
end;
definition
let C121 , C122 , C123 being set;
func GFA0AdderCirc (C121 , C122 , C123) ->  strict  Boolean  gate`2=den (Circuit of ( GFA0AdderStr (C121 , C122 , C123) )) equals 
( 2GatesCircuit (C121 , C122 , C123 , ( xor2 )) );
coherence;
end;
definition
let C124 , C125 , C126 being set;
func GFA0AdderOutput (C124 , C125 , C126) -> (Element of ( InnerVertices ( GFA0AdderStr (C124 , C125 , C126) ) )) equals 
( 2GatesCircOutput (C124 , C125 , C126 , ( xor2 )) );
coherence;
end;
theorem
L317: (for B148 , B149 , B150 being set holds ( InnerVertices ( GFA0AdderStr (B148 , B149 , B150) ) ) = ( { [ <* B148 , B149 *> , ( xor2 ) ] } \/ { ( GFA0AdderOutput (B148 , B149 , B150) ) } ))
proof
let C127 , C128 , C129 being set;
set D171 = ( xor2 );
set D172 = [ <* C127 , C128 *> , D171 ];
set D173 = ( GFA0AdderStr (C127 , C128 , C129) );
thus L318: ( InnerVertices D173 ) = { D172 , ( GFA0AdderOutput (C127 , C128 , C129) ) } by FACIRC_1:56
.= ( { D172 } \/ { ( GFA0AdderOutput (C127 , C128 , C129) ) } ) by ENUMSET1:1;
end;
theorem
L319: (for B151 , B152 , B153 being set holds (B151 in (the carrier of ( GFA0AdderStr (B151 , B152 , B153) )) & B152 in (the carrier of ( GFA0AdderStr (B151 , B152 , B153) )) & B153 in (the carrier of ( GFA0AdderStr (B151 , B152 , B153) )) & [ <* B151 , B152 *> , ( xor2 ) ] in (the carrier of ( GFA0AdderStr (B151 , B152 , B153) )) & [ <* [ <* B151 , B152 *> , ( xor2 ) ] , B153 *> , ( xor2 ) ] in (the carrier of ( GFA0AdderStr (B151 , B152 , B153) )))) by FACIRC_1:60 , FACIRC_1:61;
theorem
L320: (for B154 , B155 , B156 being set holds ([ <* B154 , B155 *> , ( xor2 ) ] in ( InnerVertices ( GFA0AdderStr (B154 , B155 , B156) ) ) & ( GFA0AdderOutput (B154 , B155 , B156) ) in ( InnerVertices ( GFA0AdderStr (B154 , B155 , B156) ) )))
proof
let C130 , C131 , C132 being set;
set D174 = ( xor2 );
set D175 = ( GFA0AdderStr (C130 , C131 , C132) );
L321: ( InnerVertices D175 ) = ( { [ <* C130 , C131 *> , D174 ] } \/ { ( GFA0AdderOutput (C130 , C131 , C132) ) } ) by L317
.= { [ <* C130 , C131 *> , D174 ] , ( GFA0AdderOutput (C130 , C131 , C132) ) } by ENUMSET1:1;
thus L322: thesis by L321 , TARSKI:def 2;
end;
theorem
L323: (for B157 , B158 , B159 being set holds (B159 <> [ <* B157 , B158 *> , ( xor2 ) ] implies (B157 in ( InputVertices ( GFA0AdderStr (B157 , B158 , B159) ) ) & B158 in ( InputVertices ( GFA0AdderStr (B157 , B158 , B159) ) ) & B159 in ( InputVertices ( GFA0AdderStr (B157 , B158 , B159) ) ))))
proof
set D176 = ( xor2 );
let C133 , C134 , C135 being set;
assume that
L324: C135 <> [ <* C133 , C134 *> , D176 ];
set D177 = ( GFA0AdderStr (C133 , C134 , C135) );
L325: ( InputVertices D177 ) = { C133 , C134 , C135 } by L324 , FACIRC_1:57;
thus L326: thesis by L325 , ENUMSET1:def 1;
end;
theorem
L327: (for B160 , B161 , B162 being set holds (B162 <> [ <* B160 , B161 *> , ( xor2 ) ] implies (for B163 being (State of ( GFA0AdderCirc (B160 , B161 , B162) )) holds (for B164 , B165 , B166 being (Element of ( BOOLEAN )) holds ((B164 = ( B163 . B160 ) & B165 = ( B163 . B161 ) & B166 = ( B163 . B162 )) implies (( ( Following B163 ) . [ <* B160 , B161 *> , ( xor2 ) ] ) = ( B164 'xor' B165 ) & ( ( Following B163 ) . B160 ) = B164 & ( ( Following B163 ) . B161 ) = B165 & ( ( Following B163 ) . B162 ) = B166))))))
proof
set D178 = ( xor2 );
let C136 , C137 , C138 being set;
assume that
L328: C138 <> [ <* C136 , C137 *> , D178 ];
set D179 = ( GFA0AdderCirc (C136 , C137 , C138) );
set D180 = [ <* C136 , C137 *> , D178 ];
let C139 being (State of D179);
let C140 , C141 , C142 being (Element of ( BOOLEAN ));
assume that
L329: (C140 = ( C139 . C136 ) & C141 = ( C139 . C137 ))
and
L330: C142 = ( C139 . C138 );
L331: ( ( Following C139 ) . D180 ) = ( D178 . <* C140 , C141 *> ) by L328 , L329 , L142;
thus L332: ( ( Following C139 ) . D180 ) = ( C140 'xor' C141 ) by L331 , TWOSCOMP:def 13;
thus L333: thesis by L328 , L329 , L330 , L142;
end;
theorem
L334: (for B167 , B168 , B169 being set holds (B169 <> [ <* B167 , B168 *> , ( xor2 ) ] implies (for B170 being (State of ( GFA0AdderCirc (B167 , B168 , B169) )) holds (for B171 , B172 , B173 , B174 being (Element of ( BOOLEAN )) holds ((B171 = ( B170 . [ <* B167 , B168 *> , ( xor2 ) ] ) & B174 = ( B170 . B169 )) implies ( ( Following B170 ) . ( GFA0AdderOutput (B167 , B168 , B169) ) ) = ( B171 'xor' B174 ))))))
proof
set D181 = ( xor2 );
let C143 , C144 , C145 being set;
assume that
L335: C145 <> [ <* C143 , C144 *> , D181 ];
set D182 = ( GFA0AdderCirc (C143 , C144 , C145) );
set D183 = [ <* C143 , C144 *> , D181 ];
let C146 being (State of D182);
let C147 , C148 , C149 , C150 being (Element of ( BOOLEAN ));
assume that
L336: (C147 = ( C146 . D183 ) & C150 = ( C146 . C145 ));
thus L337: ( ( Following C146 ) . ( GFA0AdderOutput (C143 , C144 , C145) ) ) = ( D181 . <* ( C146 . D183 ) , ( C146 . C145 ) *> ) by L335 , L142
.= ( C147 'xor' C150 ) by L336 , TWOSCOMP:def 13;
end;
theorem
L338: (for B175 , B176 , B177 being set holds (B177 <> [ <* B175 , B176 *> , ( xor2 ) ] implies (for B178 being (State of ( GFA0AdderCirc (B175 , B176 , B177) )) holds (for B179 , B180 , B181 being (Element of ( BOOLEAN )) holds ((B179 = ( B178 . B175 ) & B180 = ( B178 . B176 ) & B181 = ( B178 . B177 )) implies (( ( Following (B178 , 2) ) . ( GFA0AdderOutput (B175 , B176 , B177) ) ) = ( ( B179 'xor' B180 ) 'xor' B181 ) & ( ( Following (B178 , 2) ) . [ <* B175 , B176 *> , ( xor2 ) ] ) = ( B179 'xor' B180 ) & ( ( Following (B178 , 2) ) . B175 ) = B179 & ( ( Following (B178 , 2) ) . B176 ) = B180 & ( ( Following (B178 , 2) ) . B177 ) = B181))))))
proof
set D184 = ( xor2 );
let C151 , C152 , C153 being set;
assume that
L339: C153 <> [ <* C151 , C152 *> , D184 ];
set D185 = [ <* C151 , C152 *> , D184 ];
set D186 = ( GFA0AdderCirc (C151 , C152 , C153) );
let C154 being (State of D186);
let C155 , C156 , C157 being (Element of ( BOOLEAN ));
assume that
L340: (C155 = ( C154 . C151 ) & C156 = ( C154 . C152 ))
and
L341: C157 = ( C154 . C153 );
thus L342: ( ( Following (C154 , 2) ) . ( GFA0AdderOutput (C151 , C152 , C153) ) ) = ( D184 . <* ( D184 . <* C155 , C156 *> ) , C157 *> ) by L339 , L340 , L341 , FACIRC_1:62
.= ( D184 . <* ( C155 'xor' C156 ) , C157 *> ) by TWOSCOMP:def 13
.= ( ( C155 'xor' C156 ) 'xor' C157 ) by TWOSCOMP:def 13;
L343: ( ( Following (C154 , 2) ) . D185 ) = ( D184 . <* C155 , C156 *> ) by L339 , L340 , FACIRC_1:62;
thus L344: ( ( Following (C154 , 2) ) . D185 ) = ( C155 'xor' C156 ) by L343 , TWOSCOMP:def 13;
thus L345: thesis by L339 , L340 , L341 , FACIRC_1:62;
end;
definition
let C158 , C159 , C160 being set;
func BitGFA0Str (C158 , C159 , C160) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( GFA0AdderStr (C158 , C159 , C160) ) +* ( GFA0CarryStr (C158 , C159 , C160) ) );
coherence;
end;
definition
let C161 , C162 , C163 being set;
func BitGFA0Circ (C161 , C162 , C163) ->  strict  Boolean  gate`2=den (Circuit of ( BitGFA0Str (C161 , C162 , C163) )) equals 
( ( GFA0AdderCirc (C161 , C162 , C163) ) +* ( GFA0CarryCirc (C161 , C162 , C163) ) );
coherence;
end;
theorem
L348: (for B182 , B183 , B184 being set holds ( InnerVertices ( BitGFA0Str (B182 , B183 , B184) ) ) = ( ( ( { [ <* B182 , B183 *> , ( xor2 ) ] } \/ { ( GFA0AdderOutput (B182 , B183 , B184) ) } ) \/ { [ <* B182 , B183 *> , ( and2 ) ] , [ <* B183 , B184 *> , ( and2 ) ] , [ <* B184 , B182 *> , ( and2 ) ] } ) \/ { ( GFA0CarryOutput (B182 , B183 , B184) ) } ))
proof
let C164 , C165 , C166 being set;
set D187 = ( and2 );
set D188 = ( and2 );
set D189 = ( and2 );
set D190 = ( xor2 );
set D191 = [ <* C164 , C165 *> , D190 ];
set D192 = [ <* C164 , C165 *> , D187 ];
set D193 = [ <* C165 , C166 *> , D188 ];
set D194 = [ <* C166 , C164 *> , D189 ];
set D195 = ( BitGFA0Str (C164 , C165 , C166) );
set D196 = ( GFA0AdderStr (C164 , C165 , C166) );
set D197 = ( GFA0CarryStr (C164 , C165 , C166) );
set D198 = ( GFA0AdderOutput (C164 , C165 , C166) );
set D199 = ( GFA0CarryOutput (C164 , C165 , C166) );
thus L349: ( InnerVertices D195 ) = ( ( InnerVertices D196 ) \/ ( InnerVertices D197 ) ) by FACIRC_1:27
.= ( ( { D191 } \/ { D198 } ) \/ ( InnerVertices D197 ) ) by L317
.= ( ( { D191 } \/ { D198 } ) \/ ( { D192 , D193 , D194 } \/ { D199 } ) ) by L170
.= ( ( ( { D191 } \/ { D198 } ) \/ { D192 , D193 , D194 } ) \/ { D199 } ) by XBOOLE_1:4;
end;
theorem
L350: (for B185 , B186 , B187 being set holds ( InnerVertices ( BitGFA0Str (B185 , B186 , B187) ) ) is Relation)
proof
let C167 , C168 , C169 being set;
set D200 = ( GFA0AdderStr (C167 , C168 , C169) );
set D201 = ( GFA0CarryStr (C167 , C168 , C169) );
L351: (( InnerVertices D200 ) is Relation & ( InnerVertices D201 ) is Relation) by L177 , FACIRC_1:58;
thus L352: thesis by L351 , FACIRC_1:3;
end;
theorem
L353: (for B188 , B189 , B190 being set holds ((B190 <> [ <* B188 , B189 *> , ( xor2 ) ] & B188 <> [ <* B189 , B190 *> , ( and2 ) ] & B189 <> [ <* B190 , B188 *> , ( and2 ) ] & B190 <> [ <* B188 , B189 *> , ( and2 ) ]) implies ( InputVertices ( BitGFA0Str (B188 , B189 , B190) ) ) = { B188 , B189 , B190 }))
proof
set D202 = ( and2 );
set D203 = ( and2 );
set D204 = ( and2 );
set D205 = ( xor2 );
let C170 , C171 , C172 being set;
assume that
L354: (C172 <> [ <* C170 , C171 *> , D205 ] & C170 <> [ <* C171 , C172 *> , D203 ] & C171 <> [ <* C172 , C170 *> , D204 ] & C172 <> [ <* C170 , C171 *> , D202 ]);
set D206 = ( GFA0CarryStr (C170 , C171 , C172) );
set D207 = ( GFA0AdderStr (C170 , C171 , C172) );
L355: (( InputVertices D207 ) = { C170 , C171 , C172 } & ( InputVertices D206 ) = { C170 , C171 , C172 }) by L354 , L192 , FACIRC_1:57;
thus L356: thesis by L355 , CIRCCOMB:47 , FACIRC_2:21;
end;
theorem
L357: (for B191 , B192 , B193 being non  pair set holds ( InputVertices ( BitGFA0Str (B191 , B192 , B193) ) ) = { B191 , B192 , B193 })
proof
let C173 , C174 , C175 being non  pair set;
set D208 = ( BitGFA0Str (C173 , C174 , C175) );
set D209 = ( GFA0AdderStr (C173 , C174 , C175) );
set D210 = ( GFA0CarryStr (C173 , C174 , C175) );
L358: (( InputVertices D209 ) = { C173 , C174 , C175 } & ( InputVertices D210 ) = { C173 , C174 , C175 }) by L239 , FACIRC_1:57;
L359: (( InnerVertices D209 ) is Relation & ( InnerVertices D210 ) is Relation) by L177 , FACIRC_1:58;
thus L360: ( InputVertices D208 ) = ( { C173 , C174 , C175 } \/ { C173 , C174 , C175 } ) by L359 , L358 , FACIRC_1:7
.= { C173 , C174 , C175 };
end;
theorem
L361: (for B194 , B195 , B196 being non  pair set holds ( InputVertices ( BitGFA0Str (B194 , B195 , B196) ) ) is  without_pairs)
proof
let C176 , C177 , C178 being non  pair set;
L362: ( InputVertices ( BitGFA0Str (C176 , C177 , C178) ) ) = { C176 , C177 , C178 } by L357;
thus L363: thesis by L362;
end;
theorem
L364: (for B197 , B198 , B199 being set holds (B197 in (the carrier of ( BitGFA0Str (B197 , B198 , B199) )) & B198 in (the carrier of ( BitGFA0Str (B197 , B198 , B199) )) & B199 in (the carrier of ( BitGFA0Str (B197 , B198 , B199) )) & [ <* B197 , B198 *> , ( xor2 ) ] in (the carrier of ( BitGFA0Str (B197 , B198 , B199) )) & [ <* [ <* B197 , B198 *> , ( xor2 ) ] , B199 *> , ( xor2 ) ] in (the carrier of ( BitGFA0Str (B197 , B198 , B199) )) & [ <* B197 , B198 *> , ( and2 ) ] in (the carrier of ( BitGFA0Str (B197 , B198 , B199) )) & [ <* B198 , B199 *> , ( and2 ) ] in (the carrier of ( BitGFA0Str (B197 , B198 , B199) )) & [ <* B199 , B197 *> , ( and2 ) ] in (the carrier of ( BitGFA0Str (B197 , B198 , B199) )) & [ <* [ <* B197 , B198 *> , ( and2 ) ] , [ <* B198 , B199 *> , ( and2 ) ] , [ <* B199 , B197 *> , ( and2 ) ] *> , ( or3 ) ] in (the carrier of ( BitGFA0Str (B197 , B198 , B199) ))))
proof
let C179 , C180 , C181 being set;
set D211 = ( and2 );
set D212 = ( and2 );
set D213 = ( and2 );
set D214 = ( or3 );
set D215 = ( xor2 );
set D216 = [ <* C179 , C180 *> , D211 ];
set D217 = [ <* C180 , C181 *> , D212 ];
set D218 = [ <* C181 , C179 *> , D213 ];
set D219 = [ <* D216 , D217 , D218 *> , D214 ];
set D220 = ( GFA0AdderStr (C179 , C180 , C181) );
set D221 = ( GFA0CarryStr (C179 , C180 , C181) );
L365: (C179 in (the carrier of D220) & C180 in (the carrier of D220)) by FACIRC_1:60;
L366: (C181 in (the carrier of D220) & [ <* C179 , C180 *> , D215 ] in (the carrier of D220)) by FACIRC_1:60 , FACIRC_1:61;
L367: D219 in (the carrier of D221) by L213;
L368: (D217 in (the carrier of D221) & D218 in (the carrier of D221)) by L213;
L369: ([ <* [ <* C179 , C180 *> , D215 ] , C181 *> , D215 ] in (the carrier of D220) & D216 in (the carrier of D221)) by L213 , FACIRC_1:61;
thus L370: thesis by L369 , L365 , L366 , L368 , L367 , FACIRC_1:20;
end;
theorem
L371: (for B200 , B201 , B202 being set holds ([ <* B200 , B201 *> , ( xor2 ) ] in ( InnerVertices ( BitGFA0Str (B200 , B201 , B202) ) ) & ( GFA0AdderOutput (B200 , B201 , B202) ) in ( InnerVertices ( BitGFA0Str (B200 , B201 , B202) ) ) & [ <* B200 , B201 *> , ( and2 ) ] in ( InnerVertices ( BitGFA0Str (B200 , B201 , B202) ) ) & [ <* B201 , B202 *> , ( and2 ) ] in ( InnerVertices ( BitGFA0Str (B200 , B201 , B202) ) ) & [ <* B202 , B200 *> , ( and2 ) ] in ( InnerVertices ( BitGFA0Str (B200 , B201 , B202) ) ) & ( GFA0CarryOutput (B200 , B201 , B202) ) in ( InnerVertices ( BitGFA0Str (B200 , B201 , B202) ) )))
proof
let C182 , C183 , C184 being set;
set D222 = ( and2 );
set D223 = ( and2 );
set D224 = ( and2 );
set D225 = ( xor2 );
set D226 = [ <* C182 , C183 *> , D225 ];
set D227 = [ <* C182 , C183 *> , D222 ];
set D228 = [ <* C183 , C184 *> , D223 ];
set D229 = [ <* C184 , C182 *> , D224 ];
set D230 = ( BitGFA0Str (C182 , C183 , C184) );
set D231 = ( GFA0AdderOutput (C182 , C183 , C184) );
set D232 = ( GFA0CarryOutput (C182 , C183 , C184) );
L372: ( InnerVertices D230 ) = ( ( ( { D226 } \/ { D231 } ) \/ { D227 , D228 , D229 } ) \/ { D232 } ) by L348
.= ( ( { D226 , D231 } \/ { D227 , D228 , D229 } ) \/ { D232 } ) by ENUMSET1:1
.= ( { D226 , D231 , D227 , D228 , D229 } \/ { D232 } ) by ENUMSET1:8
.= { D226 , D231 , D227 , D228 , D229 , D232 } by ENUMSET1:15;
thus L373: thesis by L372 , ENUMSET1:def 4;
end;
theorem
L374: (for B203 , B204 , B205 being set holds ((B205 <> [ <* B203 , B204 *> , ( xor2 ) ] & B203 <> [ <* B204 , B205 *> , ( and2 ) ] & B204 <> [ <* B205 , B203 *> , ( and2 ) ] & B205 <> [ <* B203 , B204 *> , ( and2 ) ]) implies (B203 in ( InputVertices ( BitGFA0Str (B203 , B204 , B205) ) ) & B204 in ( InputVertices ( BitGFA0Str (B203 , B204 , B205) ) ) & B205 in ( InputVertices ( BitGFA0Str (B203 , B204 , B205) ) ))))
proof
set D233 = ( and2 );
set D234 = ( and2 );
set D235 = ( and2 );
set D236 = ( xor2 );
let C185 , C186 , C187 being set;
assume that
L375: (C187 <> [ <* C185 , C186 *> , D236 ] & C185 <> [ <* C186 , C187 *> , D234 ] & C186 <> [ <* C187 , C185 *> , D235 ] & C187 <> [ <* C185 , C186 *> , D233 ]);
set D237 = ( BitGFA0Str (C185 , C186 , C187) );
L376: ( InputVertices D237 ) = { C185 , C186 , C187 } by L375 , L353;
thus L377: thesis by L376 , ENUMSET1:def 1;
end;
definition
let C188 , C189 , C190 being set;
func BitGFA0CarryOutput (C188 , C189 , C190) -> (Element of ( InnerVertices ( BitGFA0Str (C188 , C189 , C190) ) )) equals 
[ <* [ <* C188 , C189 *> , ( and2 ) ] , [ <* C189 , C190 *> , ( and2 ) ] , [ <* C190 , C188 *> , ( and2 ) ] *> , ( or3 ) ];
coherence
proof
L378: ( GFA0CarryOutput (C188 , C189 , C190) ) in ( InnerVertices ( BitGFA0Str (C188 , C189 , C190) ) ) by L371;
thus L379: thesis by L378;
end;
end;
definition
let C191 , C192 , C193 being set;
func BitGFA0AdderOutput (C191 , C192 , C193) -> (Element of ( InnerVertices ( BitGFA0Str (C191 , C192 , C193) ) )) equals 
( 2GatesCircOutput (C191 , C192 , C193 , ( xor2 )) );
coherence
proof
L381: ( GFA0AdderOutput (C191 , C192 , C193) ) in ( InnerVertices ( BitGFA0Str (C191 , C192 , C193) ) ) by L371;
thus L382: thesis by L381;
end;
end;
theorem
L384: (for B206 , B207 , B208 being set holds ((B208 <> [ <* B206 , B207 *> , ( xor2 ) ] & B206 <> [ <* B207 , B208 *> , ( and2 ) ] & B207 <> [ <* B208 , B206 *> , ( and2 ) ] & B208 <> [ <* B206 , B207 *> , ( and2 ) ]) implies (for B209 being (State of ( BitGFA0Circ (B206 , B207 , B208) )) holds (for B210 , B211 , B212 being (Element of ( BOOLEAN )) holds ((B210 = ( B209 . B206 ) & B211 = ( B209 . B207 ) & B212 = ( B209 . B208 )) implies (( ( Following (B209 , 2) ) . ( GFA0AdderOutput (B206 , B207 , B208) ) ) = ( ( B210 'xor' B211 ) 'xor' B212 ) & ( ( Following (B209 , 2) ) . ( GFA0CarryOutput (B206 , B207 , B208) ) ) = ( ( ( B210 '&' B211 ) 'or' ( B211 '&' B212 ) ) 'or' ( B212 '&' B210 ) )))))))
proof
set D238 = ( and2 );
set D239 = ( and2 );
set D240 = ( and2 );
set D241 = ( xor2 );
let C194 , C195 , C196 being set;
assume that
L385: C196 <> [ <* C194 , C195 *> , D241 ]
and
L386: (C194 <> [ <* C195 , C196 *> , D239 ] & C195 <> [ <* C196 , C194 *> , D240 ] & C196 <> [ <* C194 , C195 *> , D238 ]);
set D242 = ( GFA0CarryStr (C194 , C195 , C196) );
set D243 = ( GFA0AdderStr (C194 , C195 , C196) );
L387: ( InputVertices D243 ) = { C194 , C195 , C196 } by L385 , FACIRC_1:57;
L388: ( InputVertices D243 ) = ( InputVertices D242 ) by L387 , L386 , L192;
set D244 = ( GFA0CarryCirc (C194 , C195 , C196) );
set D245 = ( GFA0AdderCirc (C194 , C195 , C196) );
set D246 = ( BitGFA0Circ (C194 , C195 , C196) );
let C197 being (State of D246);
let C198 , C199 , C200 being (Element of ( BOOLEAN ));
assume that
L389: C198 = ( C197 . C194 )
and
L390: C199 = ( C197 . C195 )
and
L391: C200 = ( C197 . C196 );
reconsider D247 = ( C197 | (the carrier of D243) ) as (State of D245) by FACIRC_1:26;
L392: ( dom D247 ) = (the carrier of D243) by CIRCUIT1:3;
L393: C196 in (the carrier of D243) by FACIRC_1:60;
L394: C200 = ( D247 . C196 ) by L393 , L391 , L392 , FUNCT_1:47;
L395: C195 in (the carrier of D243) by FACIRC_1:60;
L396: C199 = ( D247 . C195 ) by L395 , L390 , L392 , FUNCT_1:47;
reconsider D248 = C197 as (State of ( D245 +* D244 ));
L397: ( InnerVertices D242 ) misses ( InputVertices D242 ) by XBOOLE_1:79;
L398: ( ( Following (D248 , 2) ) . ( GFA0AdderOutput (C194 , C195 , C196) ) ) = ( ( Following (D247 , 2) ) . ( GFA0AdderOutput (C194 , C195 , C196) ) ) by L397 , L388 , FACIRC_1:32;
reconsider D249 = ( C197 | (the carrier of D242) ) as (State of D244) by FACIRC_1:26;
L399: ( dom D249 ) = (the carrier of D242) by CIRCUIT1:3;
L400: C194 in (the carrier of D243) by FACIRC_1:60;
L401: C198 = ( D247 . C194 ) by L400 , L389 , L392 , FUNCT_1:47;
thus L402: ( ( Following (C197 , 2) ) . ( GFA0AdderOutput (C194 , C195 , C196) ) ) = ( ( C198 'xor' C199 ) 'xor' C200 ) by L401 , L385 , L396 , L394 , L398 , L338;
L403: ( InnerVertices D243 ) misses ( InputVertices D243 ) by XBOOLE_1:79;
L404: ( ( Following (D248 , 2) ) . ( GFA0CarryOutput (C194 , C195 , C196) ) ) = ( ( Following (D249 , 2) ) . ( GFA0CarryOutput (C194 , C195 , C196) ) ) by L403 , L388 , FACIRC_1:33;
L405: C196 in (the carrier of D242) by L213;
L406: C200 = ( D249 . C196 ) by L405 , L391 , L399 , FUNCT_1:47;
L407: C195 in (the carrier of D242) by L213;
L408: C199 = ( D249 . C195 ) by L407 , L390 , L399 , FUNCT_1:47;
L409: C194 in (the carrier of D242) by L213;
L410: C198 = ( D249 . C194 ) by L409 , L389 , L399 , FUNCT_1:47;
thus L411: thesis by L410 , L386 , L408 , L406 , L404 , L275;
end;
theorem
L412: (for B213 , B214 , B215 being set holds ((B215 <> [ <* B213 , B214 *> , ( xor2 ) ] & B213 <> [ <* B214 , B215 *> , ( and2 ) ] & B214 <> [ <* B215 , B213 *> , ( and2 ) ] & B215 <> [ <* B213 , B214 *> , ( and2 ) ]) implies (for B216 being (State of ( BitGFA0Circ (B213 , B214 , B215) )) holds ( Following (B216 , 2) ) is  stable)))
proof
set D250 = ( and2 );
set D251 = ( and2 );
set D252 = ( and2 );
set D253 = ( xor2 );
let C201 , C202 , C203 being set;
assume that
L413: C203 <> [ <* C201 , C202 *> , D253 ]
and
L414: (C201 <> [ <* C202 , C203 *> , D251 ] & C202 <> [ <* C203 , C201 *> , D252 ] & C203 <> [ <* C201 , C202 *> , D250 ]);
set D254 = ( BitGFA0Circ (C201 , C202 , C203) );
let C204 being (State of D254);
set D255 = ( GFA0CarryStr (C201 , C202 , C203) );
set D256 = ( GFA0AdderStr (C201 , C202 , C203) );
L415: ( InputVertices D256 ) = { C201 , C202 , C203 } by L413 , FACIRC_1:57;
L416: ( InputVertices D256 ) = ( InputVertices D255 ) by L415 , L414 , L192;
set D257 = ( GFA0AdderCirc (C201 , C202 , C203) );
reconsider D258 = ( C204 | (the carrier of D256) ) as (State of D257) by FACIRC_1:26;
L417: ( Following (D258 , 2) ) is  stable by L413 , FACIRC_1:63;
L418: ( Following (D258 , 2) ) = ( Following ( Following (D258 , 2) ) ) by L417 , CIRCUIT2:def 6
.= ( Following (D258 , ( 2 + 1 )) ) by FACIRC_1:12;
set D259 = ( GFA0CarryCirc (C201 , C202 , C203) );
reconsider D260 = ( C204 | (the carrier of D255) ) as (State of D259) by FACIRC_1:26;
L419: ( Following (D260 , 2) ) is  stable by L414 , L289;
L420: ( Following (D260 , 2) ) = ( Following ( Following (D260 , 2) ) ) by L419 , CIRCUIT2:def 6
.= ( Following (D260 , ( 2 + 1 )) ) by FACIRC_1:12;
reconsider D261 = C204 as (State of ( D257 +* D259 ));
set D262 = ( BitGFA0Str (C201 , C202 , C203) );
L421: ( dom ( Following (C204 , 3) ) ) = (the carrier of D262) by CIRCUIT1:3;
L422: ( InnerVertices D255 ) misses ( InputVertices D255 ) by XBOOLE_1:79;
L423: (( Following (D258 , 2) ) = ( ( Following (D261 , 2) ) | (the carrier of D256) ) & ( Following (D258 , 3) ) = ( ( Following (D261 , 3) ) | (the carrier of D256) )) by L422 , L416 , FACIRC_1:30;
L424: ( InnerVertices D256 ) misses ( InputVertices D256 ) by XBOOLE_1:79;
L425: (( Following (D260 , 2) ) = ( ( Following (D261 , 2) ) | (the carrier of D255) ) & ( Following (D260 , 3) ) = ( ( Following (D261 , 3) ) | (the carrier of D255) )) by L424 , L416 , FACIRC_1:31;
L426: (the carrier of D262) = ( (the carrier of D256) \/ (the carrier of D255) ) by CIRCCOMB:def 2;
L427: (( dom ( Following (D258 , 2) ) ) = (the carrier of D256) & ( dom ( Following (D260 , 2) ) ) = (the carrier of D255)) by CIRCUIT1:3;
L428:
now
let C205 being set;
assume L429: C205 in (the carrier of D262);
L430: (C205 in (the carrier of D256) or C205 in (the carrier of D255)) by L429 , L426 , XBOOLE_0:def 3;
L431: ((( ( Following (C204 , 2) ) . C205 ) = ( ( Following (D258 , 2) ) . C205 ) & ( ( Following (C204 , 3) ) . C205 ) = ( ( Following (D258 , 3) ) . C205 )) or (( ( Following (C204 , 2) ) . C205 ) = ( ( Following (D260 , 2) ) . C205 ) & ( ( Following (C204 , 3) ) . C205 ) = ( ( Following (D260 , 3) ) . C205 ))) by L430 , L423 , L425 , L418 , L420 , L427 , FUNCT_1:47;
thus L432: ( ( Following (C204 , 2) ) . C205 ) = ( ( Following ( Following (C204 , 2) ) ) . C205 ) by L431 , L418 , L420 , FACIRC_1:12;
end;
L433: (( Following (C204 , ( 2 + 1 )) ) = ( Following ( Following (C204 , 2) ) ) & ( dom ( Following (C204 , 2) ) ) = (the carrier of D262)) by CIRCUIT1:3 , FACIRC_1:12;
thus L434: ( Following (C204 , 2) ) = ( Following ( Following (C204 , 2) ) ) by L433 , L421 , L428 , FUNCT_1:2;
end;
begin
definition
let C206 , C207 , C208 being set;
func GFA1CarryIStr (C206 , C207 , C208) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( ( 1GateCircStr (<* C206 , C207 *> , ( and2c )) ) +* ( 1GateCircStr (<* C207 , C208 *> , ( and2a )) ) ) +* ( 1GateCircStr (<* C208 , C206 *> , ( and2 )) ) );
coherence;
end;
definition
let C209 , C210 , C211 being set;
func GFA1CarryICirc (C209 , C210 , C211) ->  strict  Boolean  gate`2=den (Circuit of ( GFA1CarryIStr (C209 , C210 , C211) )) equals 
( ( ( 1GateCircuit (C209 , C210 , ( and2c )) ) +* ( 1GateCircuit (C210 , C211 , ( and2a )) ) ) +* ( 1GateCircuit (C211 , C209 , ( and2 )) ) );
coherence;
end;
definition
let C212 , C213 , C214 being set;
func GFA1CarryStr (C212 , C213 , C214) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( GFA1CarryIStr (C212 , C213 , C214) ) +* ( 1GateCircStr (<* [ <* C212 , C213 *> , ( and2c ) ] , [ <* C213 , C214 *> , ( and2a ) ] , [ <* C214 , C212 *> , ( and2 ) ] *> , ( or3 )) ) );
coherence;
end;
definition
let C215 , C216 , C217 being set;
func GFA1CarryCirc (C215 , C216 , C217) ->  strict  Boolean  gate`2=den (Circuit of ( GFA1CarryStr (C215 , C216 , C217) )) equals 
( ( GFA1CarryICirc (C215 , C216 , C217) ) +* ( 1GateCircuit ([ <* C215 , C216 *> , ( and2c ) ] , [ <* C216 , C217 *> , ( and2a ) ] , [ <* C217 , C215 *> , ( and2 ) ] , ( or3 )) ) );
coherence;
end;
definition
let C218 , C219 , C220 being set;
func GFA1CarryOutput (C218 , C219 , C220) -> (Element of ( InnerVertices ( GFA1CarryStr (C218 , C219 , C220) ) )) equals 
[ <* [ <* C218 , C219 *> , ( and2c ) ] , [ <* C219 , C220 *> , ( and2a ) ] , [ <* C220 , C218 *> , ( and2 ) ] *> , ( or3 ) ];
coherence
proof
L439: [ <* [ <* C218 , C219 *> , ( and2c ) ] , [ <* C219 , C220 *> , ( and2a ) ] , [ <* C220 , C218 *> , ( and2 ) ] *> , ( or3 ) ] in ( InnerVertices ( 1GateCircStr (<* [ <* C218 , C219 *> , ( and2c ) ] , [ <* C219 , C220 *> , ( and2a ) ] , [ <* C220 , C218 *> , ( and2 ) ] *> , ( or3 )) ) ) by FACIRC_1:47;
thus L440: thesis by L439 , FACIRC_1:21;
end;
end;
theorem
L442: (for B217 , B218 , B219 being set holds ( InnerVertices ( GFA1CarryIStr (B217 , B218 , B219) ) ) = { [ <* B217 , B218 *> , ( and2c ) ] , [ <* B218 , B219 *> , ( and2a ) ] , [ <* B219 , B217 *> , ( and2 ) ] })
proof
let C221 , C222 , C223 being set;
set D263 = ( and2c );
set D264 = ( and2a );
set D265 = ( and2 );
set D266 = [ <* C221 , C222 *> , D263 ];
set D267 = [ <* C222 , C223 *> , D264 ];
set D268 = [ <* C223 , C221 *> , D265 ];
set D269 = ( 1GateCircStr (<* C221 , C222 *> , D263) );
set D270 = ( 1GateCircStr (<* C222 , C223 *> , D264) );
set D271 = ( 1GateCircStr (<* C223 , C221 *> , D265) );
L443: D269 tolerates D270 by CIRCCOMB:47;
L444: ( D269 +* D270 ) tolerates D271 by CIRCCOMB:47;
L445: ( InnerVertices ( GFA1CarryIStr (C221 , C222 , C223) ) ) = ( ( InnerVertices ( D269 +* D270 ) ) \/ ( InnerVertices D271 ) ) by L444 , CIRCCOMB:11
.= ( ( ( InnerVertices D269 ) \/ ( InnerVertices D270 ) ) \/ ( InnerVertices D271 ) ) by L443 , CIRCCOMB:11
.= ( ( { D266 } \/ ( InnerVertices D270 ) ) \/ ( InnerVertices D271 ) ) by CIRCCOMB:42
.= ( ( { D266 } \/ { D267 } ) \/ ( InnerVertices D271 ) ) by CIRCCOMB:42
.= ( ( { D266 } \/ { D267 } ) \/ { D268 } ) by CIRCCOMB:42
.= ( { D266 , D267 } \/ { D268 } ) by ENUMSET1:1
.= { D266 , D267 , D268 } by ENUMSET1:3;
thus L446: thesis by L445;
end;
theorem
L447: (for B220 , B221 , B222 being set holds ( InnerVertices ( GFA1CarryStr (B220 , B221 , B222) ) ) = ( { [ <* B220 , B221 *> , ( and2c ) ] , [ <* B221 , B222 *> , ( and2a ) ] , [ <* B222 , B220 *> , ( and2 ) ] } \/ { ( GFA1CarryOutput (B220 , B221 , B222) ) } ))
proof
let C224 , C225 , C226 being set;
set D272 = ( and2c );
set D273 = ( and2a );
set D274 = ( and2 );
set D275 = ( or3 );
set D276 = [ <* C224 , C225 *> , D272 ];
set D277 = [ <* C225 , C226 *> , D273 ];
set D278 = [ <* C226 , C224 *> , D274 ];
set D279 = ( 1GateCircStr (<* C224 , C225 *> , D272) );
set D280 = ( 1GateCircStr (<* C225 , C226 *> , D273) );
set D281 = ( 1GateCircStr (<* C226 , C224 *> , D274) );
set D282 = ( 1GateCircStr (<* D276 , D277 , D278 *> , D275) );
L448: D279 tolerates ( ( D280 +* D281 ) +* D282 ) by CIRCCOMB:47;
L449: D280 tolerates ( D281 +* D282 ) by CIRCCOMB:47;
L450: ( InnerVertices ( D280 +* ( D281 +* D282 ) ) ) = ( ( InnerVertices D280 ) \/ ( InnerVertices ( D281 +* D282 ) ) ) by L449 , CIRCCOMB:11;
L451: D281 tolerates D282 by CIRCCOMB:47;
L452: ( InnerVertices ( D281 +* D282 ) ) = ( ( InnerVertices D281 ) \/ ( InnerVertices D282 ) ) by L451 , CIRCCOMB:11;
thus L453: ( InnerVertices ( GFA1CarryStr (C224 , C225 , C226) ) ) = ( InnerVertices ( ( D279 +* ( D280 +* D281 ) ) +* D282 ) ) by CIRCCOMB:6
.= ( InnerVertices ( D279 +* ( ( D280 +* D281 ) +* D282 ) ) ) by CIRCCOMB:6
.= ( ( InnerVertices D279 ) \/ ( InnerVertices ( ( D280 +* D281 ) +* D282 ) ) ) by L448 , CIRCCOMB:11
.= ( ( InnerVertices D279 ) \/ ( InnerVertices ( D280 +* ( D281 +* D282 ) ) ) ) by CIRCCOMB:6
.= ( ( ( InnerVertices D279 ) \/ ( InnerVertices D280 ) ) \/ ( ( InnerVertices D281 ) \/ ( InnerVertices D282 ) ) ) by L450 , L452 , XBOOLE_1:4
.= ( ( ( ( InnerVertices D279 ) \/ ( InnerVertices D280 ) ) \/ ( InnerVertices D281 ) ) \/ ( InnerVertices D282 ) ) by XBOOLE_1:4
.= ( ( ( { D276 } \/ ( InnerVertices D280 ) ) \/ ( InnerVertices D281 ) ) \/ ( InnerVertices D282 ) ) by CIRCCOMB:42
.= ( ( ( { D276 } \/ { D277 } ) \/ ( InnerVertices D281 ) ) \/ ( InnerVertices D282 ) ) by CIRCCOMB:42
.= ( ( ( { D276 } \/ { D277 } ) \/ { D278 } ) \/ ( InnerVertices D282 ) ) by CIRCCOMB:42
.= ( ( { D276 , D277 } \/ { D278 } ) \/ ( InnerVertices D282 ) ) by ENUMSET1:1
.= ( { D276 , D277 , D278 } \/ ( InnerVertices D282 ) ) by ENUMSET1:3
.= ( { D276 , D277 , D278 } \/ { ( GFA1CarryOutput (C224 , C225 , C226) ) } ) by CIRCCOMB:42;
end;
theorem
L454: (for B223 , B224 , B225 being set holds ( InnerVertices ( GFA1CarryStr (B223 , B224 , B225) ) ) is Relation)
proof
let C227 , C228 , C229 being set;
set D283 = ( and2c );
set D284 = ( and2a );
set D285 = ( and2 );
set D286 = ( or3 );
set D287 = [ <* C227 , C228 *> , D283 ];
set D288 = [ <* C228 , C229 *> , D284 ];
set D289 = [ <* C229 , C227 *> , D285 ];
set D290 = ( 1GateCircStr (<* C227 , C228 *> , D283) );
set D291 = ( 1GateCircStr (<* C228 , C229 *> , D284) );
set D292 = ( 1GateCircStr (<* C229 , C227 *> , D285) );
set D293 = ( 1GateCircStr (<* D287 , D288 , D289 *> , D286) );
L455: (( InnerVertices D290 ) is Relation & ( InnerVertices D291 ) is Relation) by FACIRC_1:38;
L456: (( InnerVertices D292 ) is Relation & ( InnerVertices ( D290 +* D291 ) ) is Relation) by L455 , FACIRC_1:3 , FACIRC_1:38;
L457: (( InnerVertices D293 ) is Relation & ( InnerVertices ( GFA1CarryIStr (C227 , C228 , C229) ) ) is Relation) by L456 , FACIRC_1:3 , FACIRC_1:38;
thus L458: thesis by L457 , FACIRC_1:3;
end;
theorem
L459: (for B226 , B227 , B228 being set holds ((B226 <> [ <* B227 , B228 *> , ( and2a ) ] & B227 <> [ <* B228 , B226 *> , ( and2 ) ] & B228 <> [ <* B226 , B227 *> , ( and2c ) ]) implies ( InputVertices ( GFA1CarryIStr (B226 , B227 , B228) ) ) = { B226 , B227 , B228 }))
proof
let C230 , C231 , C232 being set;
set D294 = ( and2c );
set D295 = ( and2a );
set D296 = ( and2 );
set D297 = [ <* C230 , C231 *> , D294 ];
set D298 = [ <* C231 , C232 *> , D295 ];
set D299 = [ <* C232 , C230 *> , D296 ];
set D300 = ( 1GateCircStr (<* C230 , C231 *> , D294) );
set D301 = ( 1GateCircStr (<* C231 , C232 *> , D295) );
set D302 = ( 1GateCircStr (<* C232 , C230 *> , D296) );
assume that
L460: C230 <> D298
and
L461: (C231 <> D299 & C232 <> D297);
L462: (not D297 in { C231 , C232 }) by L460 , L461 , L70;
L463: (not D299 in { C230 , C231 , C232 }) by L460 , L461 , L70;
L464: C231 <> D298 by FACIRC_2:2;
L465: ((not C232 in { D297 , D298 }) & (not C230 in { D297 , D298 })) by L460 , L461 , L70;
L466: D300 tolerates D301 by CIRCCOMB:47;
L467: ( InputVertices ( GFA1CarryIStr (C230 , C231 , C232) ) ) = ( ( ( InputVertices ( D300 +* D301 ) ) \ ( InnerVertices D302 ) ) \/ ( ( InputVertices D302 ) \ ( InnerVertices ( D300 +* D301 ) ) ) ) by CIRCCMB2:5 , CIRCCOMB:47
.= ( ( ( ( ( InputVertices D300 ) \ ( InnerVertices D301 ) ) \/ ( ( InputVertices D301 ) \ ( InnerVertices D300 ) ) ) \ ( InnerVertices D302 ) ) \/ ( ( InputVertices D302 ) \ ( InnerVertices ( D300 +* D301 ) ) ) ) by CIRCCMB2:5 , CIRCCOMB:47
.= ( ( ( ( ( InputVertices D300 ) \ ( InnerVertices D301 ) ) \/ ( ( InputVertices D301 ) \ ( InnerVertices D300 ) ) ) \ ( InnerVertices D302 ) ) \/ ( ( InputVertices D302 ) \ ( ( InnerVertices D300 ) \/ ( InnerVertices D301 ) ) ) ) by L466 , CIRCCOMB:11
.= ( ( ( ( ( InputVertices D300 ) \ { D298 } ) \/ ( ( InputVertices D301 ) \ ( InnerVertices D300 ) ) ) \ ( InnerVertices D302 ) ) \/ ( ( InputVertices D302 ) \ ( ( InnerVertices D300 ) \/ ( InnerVertices D301 ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices D300 ) \ { D298 } ) \/ ( ( InputVertices D301 ) \ { D297 } ) ) \ ( InnerVertices D302 ) ) \/ ( ( InputVertices D302 ) \ ( ( InnerVertices D300 ) \/ ( InnerVertices D301 ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices D300 ) \ { D298 } ) \/ ( ( InputVertices D301 ) \ { D297 } ) ) \ { D299 } ) \/ ( ( InputVertices D302 ) \ ( ( InnerVertices D300 ) \/ ( InnerVertices D301 ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices D300 ) \ { D298 } ) \/ ( ( InputVertices D301 ) \ { D297 } ) ) \ { D299 } ) \/ ( ( InputVertices D302 ) \ ( { D297 } \/ ( InnerVertices D301 ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices D300 ) \ { D298 } ) \/ ( ( InputVertices D301 ) \ { D297 } ) ) \ { D299 } ) \/ ( ( InputVertices D302 ) \ ( { D297 } \/ { D298 } ) ) ) by CIRCCOMB:42
.= ( ( ( ( { C230 , C231 } \ { D298 } ) \/ ( ( InputVertices D301 ) \ { D297 } ) ) \ { D299 } ) \/ ( ( InputVertices D302 ) \ ( { D297 } \/ { D298 } ) ) ) by FACIRC_1:40
.= ( ( ( ( { C230 , C231 } \ { D298 } ) \/ ( { C231 , C232 } \ { D297 } ) ) \ { D299 } ) \/ ( ( InputVertices D302 ) \ ( { D297 } \/ { D298 } ) ) ) by FACIRC_1:40
.= ( ( ( ( { C230 , C231 } \ { D298 } ) \/ ( { C231 , C232 } \ { D297 } ) ) \ { D299 } ) \/ ( { C232 , C230 } \ ( { D297 } \/ { D298 } ) ) ) by FACIRC_1:40
.= ( ( ( ( { C230 , C231 } \ { D298 } ) \/ ( { C231 , C232 } \ { D297 } ) ) \ { D299 } ) \/ ( { C232 , C230 } \ { D297 , D298 } ) ) by ENUMSET1:1
.= ( ( ( { C230 , C231 } \/ ( { C231 , C232 } \ { D297 } ) ) \ { D299 } ) \/ ( { C232 , C230 } \ { D297 , D298 } ) ) by L460 , L464 , FACIRC_2:1
.= ( ( ( { C230 , C231 } \/ { C231 , C232 } ) \ { D299 } ) \/ ( { C232 , C230 } \ { D297 , D298 } ) ) by L462 , ZFMISC_1:57
.= ( ( ( { C230 , C231 } \/ { C231 , C232 } ) \ { D299 } ) \/ { C232 , C230 } ) by L465 , ZFMISC_1:63
.= ( ( { C230 , C231 , C231 , C232 } \ { D299 } ) \/ { C232 , C230 } ) by ENUMSET1:5
.= ( ( { C231 , C231 , C230 , C232 } \ { D299 } ) \/ { C232 , C230 } ) by ENUMSET1:67
.= ( ( { C231 , C230 , C232 } \ { D299 } ) \/ { C232 , C230 } ) by ENUMSET1:31
.= ( ( { C230 , C231 , C232 } \ { D299 } ) \/ { C232 , C230 } ) by ENUMSET1:58
.= ( { C230 , C231 , C232 } \/ { C232 , C230 } ) by L463 , ZFMISC_1:57
.= { C230 , C231 , C232 , C232 , C230 } by ENUMSET1:9
.= ( { C230 , C231 , C232 , C232 } \/ { C230 } ) by ENUMSET1:10
.= ( { C232 , C232 , C230 , C231 } \/ { C230 } ) by ENUMSET1:73
.= ( { C232 , C230 , C231 } \/ { C230 } ) by ENUMSET1:31
.= { C232 , C230 , C231 , C230 } by ENUMSET1:6
.= { C230 , C230 , C231 , C232 } by ENUMSET1:70
.= { C230 , C231 , C232 } by ENUMSET1:31;
thus L468: thesis by L467;
end;
theorem
L469: (for B229 , B230 , B231 being set holds ((B229 <> [ <* B230 , B231 *> , ( and2a ) ] & B230 <> [ <* B231 , B229 *> , ( and2 ) ] & B231 <> [ <* B229 , B230 *> , ( and2c ) ]) implies ( InputVertices ( GFA1CarryStr (B229 , B230 , B231) ) ) = { B229 , B230 , B231 }))
proof
let C233 , C234 , C235 being set;
set D303 = ( and2c );
set D304 = ( and2a );
set D305 = ( and2 );
set D306 = ( or3 );
set D307 = [ <* C233 , C234 *> , D303 ];
set D308 = [ <* C234 , C235 *> , D304 ];
set D309 = [ <* C235 , C233 *> , D305 ];
set D310 = [ <* D307 , D308 , D309 *> , D306 ];
set D311 = ( 1GateCircStr (<* D307 , D308 , D309 *> , D306) );
set D312 = ( GFA1CarryIStr (C233 , C234 , C235) );
L470: ( InputVertices D311 ) = ( rng <* D307 , D308 , D309 *> ) by CIRCCOMB:42
.= { D307 , D308 , D309 } by FINSEQ_2:128;
assume L471: (C233 <> D308 & C234 <> D309 & C235 <> D307);
L472: (( InnerVertices D311 ) = { D310 } & ( { C233 , C234 , C235 } \ { D310 } ) = { C233 , C234 , C235 }) by L112 , CIRCCOMB:42;
L473: ( { D307 , D308 , D309 } \ { D307 , D308 , D309 } ) = ( {} ) by XBOOLE_1:37;
thus L474: ( InputVertices ( GFA1CarryStr (C233 , C234 , C235) ) ) = ( ( ( InputVertices D312 ) \ ( InnerVertices D311 ) ) \/ ( ( InputVertices D311 ) \ ( InnerVertices D312 ) ) ) by CIRCCMB2:5 , CIRCCOMB:47
.= ( { C233 , C234 , C235 } \/ ( { D307 , D308 , D309 } \ ( InnerVertices D312 ) ) ) by L470 , L471 , L472 , L459
.= ( { C233 , C234 , C235 } \/ ( {} ) ) by L473 , L442
.= { C233 , C234 , C235 };
end;
theorem
L475: (for B232 , B233 , B234 being non  pair set holds ( InputVertices ( GFA1CarryStr (B232 , B233 , B234) ) ) is  without_pairs)
proof
let C236 , C237 , C238 being non  pair set;
set D313 = ( and2c );
set D314 = ( and2a );
set D315 = ( and2 );
set D316 = ( or3 );
set D317 = [ <* C236 , C237 *> , D313 ];
set D318 = [ <* C237 , C238 *> , D314 ];
set D319 = [ <* C238 , C236 *> , D315 ];
set D320 = ( 1GateCircStr (<* C236 , C237 *> , D313) );
set D321 = ( 1GateCircStr (<* C237 , C238 *> , D314) );
set D322 = ( 1GateCircStr (<* C238 , C236 *> , D315) );
set D323 = ( 1GateCircStr (<* D317 , D318 , D319 *> , D316) );
set D324 = ( GFA1CarryStr (C236 , C237 , C238) );
set D325 = ( GFA1CarryIStr (C236 , C237 , C238) );
given C239 being  pair set such that
L476: C239 in ( InputVertices D324 );

L477: D320 tolerates D321 by CIRCCOMB:47;
L478: (( InnerVertices D322 ) = { D319 } & ( D320 +* D321 ) tolerates D322) by CIRCCOMB:42 , CIRCCOMB:47;
L479: (( InnerVertices D320 ) = { D317 } & ( InnerVertices D321 ) = { D318 }) by CIRCCOMB:42;
L480: ( InnerVertices ( D320 +* D321 ) ) = ( { D317 } \/ { D318 } ) by L479 , L477 , CIRCCOMB:11;
L481: ( InnerVertices D325 ) = ( ( { D317 } \/ { D318 } ) \/ { D319 } ) by L480 , L478 , CIRCCOMB:11
.= ( { D317 , D318 } \/ { D319 } ) by ENUMSET1:1
.= { D317 , D318 , D319 } by ENUMSET1:3;
L482: ( InputVertices D323 ) = { D317 , D318 , D319 } by FACIRC_1:42;
L483: ( ( InputVertices D323 ) \ ( InnerVertices D325 ) ) = ( {} ) by L482 , L481 , XBOOLE_1:37;
L484: (( InputVertices D320 ) is  without_pairs & ( InputVertices D321 ) is  without_pairs) by FACIRC_1:41;
L485: (( InputVertices D322 ) is  without_pairs & ( InputVertices ( D320 +* D321 ) ) is  without_pairs) by L484 , FACIRC_1:9 , FACIRC_1:41;
L486: ( InputVertices D325 ) is  without_pairs by L485 , FACIRC_1:9;
L487: ( InnerVertices D323 ) is Relation by FACIRC_1:38;
L488: ( InputVertices D324 ) = ( ( InputVertices D325 ) \/ ( ( InputVertices D323 ) \ ( InnerVertices D325 ) ) ) by L487 , L486 , FACIRC_1:6;
thus L489: thesis by L488 , L486 , L476 , L483 , FACIRC_1:def 2;
end;
theorem
L490: (for B235 , B236 , B237 being set holds (B235 in (the carrier of ( GFA1CarryStr (B235 , B236 , B237) )) & B236 in (the carrier of ( GFA1CarryStr (B235 , B236 , B237) )) & B237 in (the carrier of ( GFA1CarryStr (B235 , B236 , B237) )) & [ <* B235 , B236 *> , ( and2c ) ] in (the carrier of ( GFA1CarryStr (B235 , B236 , B237) )) & [ <* B236 , B237 *> , ( and2a ) ] in (the carrier of ( GFA1CarryStr (B235 , B236 , B237) )) & [ <* B237 , B235 *> , ( and2 ) ] in (the carrier of ( GFA1CarryStr (B235 , B236 , B237) )) & [ <* [ <* B235 , B236 *> , ( and2c ) ] , [ <* B236 , B237 *> , ( and2a ) ] , [ <* B237 , B235 *> , ( and2 ) ] *> , ( or3 ) ] in (the carrier of ( GFA1CarryStr (B235 , B236 , B237) ))))
proof
let C240 , C241 , C242 being set;
set D326 = ( and2c );
set D327 = ( and2a );
set D328 = ( and2 );
set D329 = ( or3 );
set D330 = [ <* C240 , C241 *> , D326 ];
set D331 = [ <* C241 , C242 *> , D327 ];
set D332 = [ <* C242 , C240 *> , D328 ];
set D333 = [ <* D330 , D331 , D332 *> , D329 ];
set D334 = ( 1GateCircStr (<* C240 , C241 *> , D326) );
set D335 = ( 1GateCircStr (<* C241 , C242 *> , D327) );
set D336 = ( 1GateCircStr (<* C242 , C240 *> , D328) );
set D337 = ( 1GateCircStr (<* D330 , D331 , D332 *> , D329) );
set D338 = <* D330 , D331 , D332 *>;
L491: C242 in (the carrier of D336) by FACIRC_1:43;
L492: C242 in (the carrier of ( GFA1CarryIStr (C240 , C241 , C242) )) by L491 , FACIRC_1:20;
L493: D332 in (the carrier of D336) by FACIRC_1:43;
L494: D332 in (the carrier of ( GFA1CarryIStr (C240 , C241 , C242) )) by L493 , FACIRC_1:20;
L495: C241 in (the carrier of D334) by FACIRC_1:43;
L496: C241 in (the carrier of ( D334 +* D335 )) by L495 , FACIRC_1:20;
L497: C241 in (the carrier of ( GFA1CarryIStr (C240 , C241 , C242) )) by L496 , FACIRC_1:20;
L498: ((the carrier of D337) = ( ( rng D338 ) \/ { D333 } ) & [ D338 , D329 ] in { [ D338 , D329 ] }) by CIRCCOMB:def 6 , TARSKI:def 1;
L499: D333 in (the carrier of D337) by L498 , XBOOLE_0:def 3;
L500: D331 in (the carrier of D335) by FACIRC_1:43;
L501: D331 in (the carrier of ( D334 +* D335 )) by L500 , FACIRC_1:20;
L502: D331 in (the carrier of ( GFA1CarryIStr (C240 , C241 , C242) )) by L501 , FACIRC_1:20;
L503: D330 in (the carrier of D334) by FACIRC_1:43;
L504: D330 in (the carrier of ( D334 +* D335 )) by L503 , FACIRC_1:20;
L505: D330 in (the carrier of ( GFA1CarryIStr (C240 , C241 , C242) )) by L504 , FACIRC_1:20;
L506: C240 in (the carrier of D336) by FACIRC_1:43;
L507: C240 in (the carrier of ( GFA1CarryIStr (C240 , C241 , C242) )) by L506 , FACIRC_1:20;
thus L508: thesis by L507 , L497 , L492 , L505 , L502 , L494 , L499 , FACIRC_1:20;
end;
theorem
L509: (for B238 , B239 , B240 being set holds ([ <* B238 , B239 *> , ( and2c ) ] in ( InnerVertices ( GFA1CarryStr (B238 , B239 , B240) ) ) & [ <* B239 , B240 *> , ( and2a ) ] in ( InnerVertices ( GFA1CarryStr (B238 , B239 , B240) ) ) & [ <* B240 , B238 *> , ( and2 ) ] in ( InnerVertices ( GFA1CarryStr (B238 , B239 , B240) ) ) & ( GFA1CarryOutput (B238 , B239 , B240) ) in ( InnerVertices ( GFA1CarryStr (B238 , B239 , B240) ) )))
proof
let C243 , C244 , C245 being set;
set D339 = ( and2c );
set D340 = ( and2a );
set D341 = ( and2 );
set D342 = [ <* C243 , C244 *> , D339 ];
set D343 = [ <* C244 , C245 *> , D340 ];
set D344 = [ <* C245 , C243 *> , D341 ];
L510: ( InnerVertices ( GFA1CarryStr (C243 , C244 , C245) ) ) = ( { D342 , D343 , D344 } \/ { ( GFA1CarryOutput (C243 , C244 , C245) ) } ) by L447
.= { D342 , D343 , D344 , ( GFA1CarryOutput (C243 , C244 , C245) ) } by ENUMSET1:6;
thus L511: thesis by L510 , ENUMSET1:def 2;
end;
theorem
L512: (for B241 , B242 , B243 being set holds ((B241 <> [ <* B242 , B243 *> , ( and2a ) ] & B242 <> [ <* B243 , B241 *> , ( and2 ) ] & B243 <> [ <* B241 , B242 *> , ( and2c ) ]) implies (B241 in ( InputVertices ( GFA1CarryStr (B241 , B242 , B243) ) ) & B242 in ( InputVertices ( GFA1CarryStr (B241 , B242 , B243) ) ) & B243 in ( InputVertices ( GFA1CarryStr (B241 , B242 , B243) ) ))))
proof
set D345 = ( and2c );
set D346 = ( and2a );
set D347 = ( and2 );
let C246 , C247 , C248 being set;
assume L513: (C246 <> [ <* C247 , C248 *> , D346 ] & C247 <> [ <* C248 , C246 *> , D347 ] & C248 <> [ <* C246 , C247 *> , D345 ]);
L514: ( InputVertices ( GFA1CarryStr (C246 , C247 , C248) ) ) = { C246 , C247 , C248 } by L513 , L469;
thus L515: thesis by L514 , ENUMSET1:def 1;
end;
theorem
L516: (for B244 , B245 , B246 being non  pair set holds ( InputVertices ( GFA1CarryStr (B244 , B245 , B246) ) ) = { B244 , B245 , B246 })
proof
let C249 , C250 , C251 being non  pair set;
set D348 = ( and2c );
set D349 = ( and2a );
set D350 = ( and2 );
set D351 = ( or3 );
set D352 = [ <* C249 , C250 *> , D348 ];
set D353 = [ <* C250 , C251 *> , D349 ];
set D354 = [ <* C251 , C249 *> , D350 ];
set D355 = ( 1GateCircStr (<* C249 , C250 *> , D348) );
set D356 = ( 1GateCircStr (<* C250 , C251 *> , D349) );
set D357 = ( 1GateCircStr (<* C251 , C249 *> , D350) );
set D358 = ( GFA1CarryStr (C249 , C250 , C251) );
set D359 = ( GFA1CarryIStr (C249 , C250 , C251) );
set D360 = ( 1GateCircStr (<* D352 , D353 , D354 *> , D351) );
L517: (( InputVertices D355 ) = { C249 , C250 } & ( InputVertices D356 ) = { C250 , C251 }) by FACIRC_1:40;
L518: ( InputVertices D357 ) = { C251 , C249 } by FACIRC_1:40;
L519: ( InputVertices D360 ) = { D352 , D353 , D354 } by FACIRC_1:42;
L520: ( InnerVertices D360 ) is Relation by FACIRC_1:38;
L521: (( InnerVertices D355 ) = { D352 } & ( InnerVertices D356 ) = { D353 }) by CIRCCOMB:42;
L522: D355 tolerates D356 by CIRCCOMB:47;
L523: (( InnerVertices D357 ) = { D354 } & ( InnerVertices ( D355 +* D356 ) ) = ( { D352 } \/ { D353 } )) by L522 , L521 , CIRCCOMB:11 , CIRCCOMB:42;
L524: ( D355 +* D356 ) tolerates D357 by CIRCCOMB:47;
L525: ( InnerVertices D359 ) = ( ( { D352 } \/ { D353 } ) \/ { D354 } ) by L524 , L523 , CIRCCOMB:11
.= ( { D352 , D353 } \/ { D354 } ) by ENUMSET1:1
.= { D352 , D353 , D354 } by ENUMSET1:3;
L526: ( ( InputVertices D360 ) \ ( InnerVertices D359 ) ) = ( {} ) by L525 , L519 , XBOOLE_1:37;
L527: (( InputVertices D355 ) is  without_pairs & ( InputVertices D356 ) is  without_pairs) by FACIRC_1:41;
L528: (( InputVertices D357 ) is  without_pairs & ( InputVertices ( D355 +* D356 ) ) is  without_pairs) by L527 , FACIRC_1:9 , FACIRC_1:41;
L529: ( InputVertices D359 ) is  without_pairs by L528 , FACIRC_1:9;
L530: ( InputVertices D358 ) = ( ( InputVertices D359 ) \/ ( ( InputVertices D360 ) \ ( InnerVertices D359 ) ) ) by L529 , L520 , FACIRC_1:6;
thus L531: ( InputVertices D358 ) = ( ( InputVertices ( D355 +* D356 ) ) \/ ( InputVertices D357 ) ) by L530 , L528 , L523 , L526 , FACIRC_1:7
.= ( ( ( InputVertices D355 ) \/ ( InputVertices D356 ) ) \/ ( InputVertices D357 ) ) by L527 , L521 , FACIRC_1:7
.= ( { C249 , C250 , C250 , C251 } \/ { C251 , C249 } ) by L517 , L518 , ENUMSET1:5
.= ( { C250 , C250 , C249 , C251 } \/ { C251 , C249 } ) by ENUMSET1:67
.= ( { C250 , C249 , C251 } \/ { C251 , C249 } ) by ENUMSET1:31
.= ( { C249 , C250 , C251 } \/ { C251 , C249 } ) by ENUMSET1:58
.= ( { C249 , C250 , C251 } \/ ( { C251 } \/ { C249 } ) ) by ENUMSET1:1
.= ( ( { C249 , C250 , C251 } \/ { C251 } ) \/ { C249 } ) by XBOOLE_1:4
.= ( ( { C251 , C249 , C250 } \/ { C251 } ) \/ { C249 } ) by ENUMSET1:59
.= ( { C251 , C251 , C249 , C250 } \/ { C249 } ) by ENUMSET1:4
.= ( { C251 , C249 , C250 } \/ { C249 } ) by ENUMSET1:31
.= ( { C249 , C250 , C251 } \/ { C249 } ) by ENUMSET1:59
.= { C249 , C249 , C250 , C251 } by ENUMSET1:4
.= { C249 , C250 , C251 } by ENUMSET1:31;
end;
theorem
L532: (for B247 , B248 , B249 being set holds (for B250 being (State of ( GFA1CarryCirc (B247 , B248 , B249) )) holds (for B251 , B252 , B253 being (Element of ( BOOLEAN )) holds ((B251 = ( B250 . B247 ) & B252 = ( B250 . B248 ) & B253 = ( B250 . B249 )) implies (( ( Following B250 ) . [ <* B247 , B248 *> , ( and2c ) ] ) = ( B251 '&' ( 'not' B252 ) ) & ( ( Following B250 ) . [ <* B248 , B249 *> , ( and2a ) ] ) = ( ( 'not' B252 ) '&' B253 ) & ( ( Following B250 ) . [ <* B249 , B247 *> , ( and2 ) ] ) = ( B253 '&' B251 ))))))
proof
let C252 , C253 , C254 being set;
set D361 = ( and2c );
set D362 = ( and2a );
set D363 = ( and2 );
let C255 being (State of ( GFA1CarryCirc (C252 , C253 , C254) ));
set D364 = [ <* C252 , C253 *> , D361 ];
set D365 = [ <* C253 , C254 *> , D362 ];
set D366 = [ <* C254 , C252 *> , D363 ];
let C256 , C257 , C258 being (Element of ( BOOLEAN ));
assume that
L533: C256 = ( C255 . C252 )
and
L534: C257 = ( C255 . C253 )
and
L535: C258 = ( C255 . C254 );
set D367 = ( GFA1CarryStr (C252 , C253 , C254) );
L536: ( InnerVertices D367 ) = (the carrier' of D367) by FACIRC_1:37;
L537: C253 in (the carrier of D367) by L490;
L538: C252 in (the carrier of D367) by L490;
L539: ( dom C255 ) = (the carrier of D367) by CIRCUIT1:3;
L540: D364 in ( InnerVertices ( GFA1CarryStr (C252 , C253 , C254) ) ) by L509;
thus L541: ( ( Following C255 ) . [ <* C252 , C253 *> , D361 ] ) = ( D361 . ( C255 * <* C252 , C253 *> ) ) by L540 , L536 , FACIRC_1:35
.= ( D361 . <* C256 , C257 *> ) by L533 , L534 , L539 , L538 , L537 , FINSEQ_2:125
.= ( C256 '&' ( 'not' C257 ) ) by L36;
L542: C254 in (the carrier of D367) by L490;
L543: D365 in ( InnerVertices ( GFA1CarryStr (C252 , C253 , C254) ) ) by L509;
thus L544: ( ( Following C255 ) . [ <* C253 , C254 *> , D362 ] ) = ( D362 . ( C255 * <* C253 , C254 *> ) ) by L543 , L536 , FACIRC_1:35
.= ( D362 . <* C257 , C258 *> ) by L534 , L535 , L539 , L537 , L542 , FINSEQ_2:125
.= ( ( 'not' C257 ) '&' C258 ) by TWOSCOMP:def 2;
L545: D366 in ( InnerVertices ( GFA1CarryStr (C252 , C253 , C254) ) ) by L509;
thus L546: ( ( Following C255 ) . [ <* C254 , C252 *> , D363 ] ) = ( D363 . ( C255 * <* C254 , C252 *> ) ) by L545 , L536 , FACIRC_1:35
.= ( D363 . <* C258 , C256 *> ) by L533 , L535 , L539 , L538 , L542 , FINSEQ_2:125
.= ( C258 '&' C256 ) by TWOSCOMP:def 1;
end;
theorem
L547: (for B254 , B255 , B256 being set holds (for B257 being (State of ( GFA1CarryCirc (B254 , B255 , B256) )) holds (for B258 , B259 , B260 being (Element of ( BOOLEAN )) holds ((B258 = ( B257 . [ <* B254 , B255 *> , ( and2c ) ] ) & B259 = ( B257 . [ <* B255 , B256 *> , ( and2a ) ] ) & B260 = ( B257 . [ <* B256 , B254 *> , ( and2 ) ] )) implies ( ( Following B257 ) . ( GFA1CarryOutput (B254 , B255 , B256) ) ) = ( ( B258 'or' B259 ) 'or' B260 )))))
proof
let C259 , C260 , C261 being set;
set D368 = ( and2c );
set D369 = ( and2a );
set D370 = ( and2 );
set D371 = ( or3 );
let C262 being (State of ( GFA1CarryCirc (C259 , C260 , C261) ));
set D372 = [ <* C259 , C260 *> , D368 ];
set D373 = [ <* C260 , C261 *> , D369 ];
set D374 = [ <* C261 , C259 *> , D370 ];
let C263 , C264 , C265 being (Element of ( BOOLEAN ));
assume that
L548: (C263 = ( C262 . D372 ) & C264 = ( C262 . D373 ) & C265 = ( C262 . D374 ));
set D375 = ( GFA1CarryStr (C259 , C260 , C261) );
reconsider D376 = D372 , D377 = D373 , D378 = D374 as (Element of ( InnerVertices D375 )) by L509;
L549: ( dom C262 ) = (the carrier of D375) by CIRCUIT1:3;
L550: ( InnerVertices D375 ) = (the carrier' of D375) by FACIRC_1:37;
thus L551: ( ( Following C262 ) . ( GFA1CarryOutput (C259 , C260 , C261) ) ) = ( D371 . ( C262 * <* D376 , D377 , D378 *> ) ) by L550 , FACIRC_1:35
.= ( D371 . <* C263 , C264 , C265 *> ) by L548 , L549 , FINSEQ_2:126
.= ( ( C263 'or' C264 ) 'or' C265 ) by TWOSCOMP:14;
end;
theorem
L552: (for B261 , B262 , B263 being set holds ((B261 <> [ <* B262 , B263 *> , ( and2a ) ] & B262 <> [ <* B263 , B261 *> , ( and2 ) ] & B263 <> [ <* B261 , B262 *> , ( and2c ) ]) implies (for B264 being (State of ( GFA1CarryCirc (B261 , B262 , B263) )) holds (for B265 , B266 , B267 being (Element of ( BOOLEAN )) holds ((B265 = ( B264 . B261 ) & B266 = ( B264 . B262 ) & B267 = ( B264 . B263 )) implies (( ( Following (B264 , 2) ) . ( GFA1CarryOutput (B261 , B262 , B263) ) ) = ( ( ( B265 '&' ( 'not' B266 ) ) 'or' ( ( 'not' B266 ) '&' B267 ) ) 'or' ( B267 '&' B265 ) ) & ( ( Following (B264 , 2) ) . [ <* B261 , B262 *> , ( and2c ) ] ) = ( B265 '&' ( 'not' B266 ) ) & ( ( Following (B264 , 2) ) . [ <* B262 , B263 *> , ( and2a ) ] ) = ( ( 'not' B266 ) '&' B267 ) & ( ( Following (B264 , 2) ) . [ <* B263 , B261 *> , ( and2 ) ] ) = ( B267 '&' B265 )))))))
proof
set D379 = ( and2c );
set D380 = ( and2a );
set D381 = ( and2 );
let C266 , C267 , C268 being set;
assume that
L553: (C266 <> [ <* C267 , C268 *> , D380 ] & C267 <> [ <* C268 , C266 *> , D381 ] & C268 <> [ <* C266 , C267 *> , D379 ]);
set D382 = ( GFA1CarryStr (C266 , C267 , C268) );
reconsider D383 = C266 , D384 = C267 , D385 = C268 as (Vertex of D382) by L490;
let C269 being (State of ( GFA1CarryCirc (C266 , C267 , C268) ));
L554: C267 in ( InputVertices D382 ) by L553 , L512;
L555: ( ( Following C269 ) . D384 ) = ( C269 . C267 ) by L554 , CIRCUIT2:def 5;
L556: C268 in ( InputVertices D382 ) by L553 , L512;
L557: ( ( Following C269 ) . D385 ) = ( C269 . C268 ) by L556 , CIRCUIT2:def 5;
set D386 = [ <* C266 , C267 *> , D379 ];
set D387 = [ <* C267 , C268 *> , D380 ];
set D388 = [ <* C268 , C266 *> , D381 ];
L558: ( Following (C269 , 2) ) = ( Following ( Following C269 ) ) by FACIRC_1:15;
let C270 , C271 , C272 being (Element of ( BOOLEAN ));
assume that
L559: (C270 = ( C269 . C266 ) & C271 = ( C269 . C267 ) & C272 = ( C269 . C268 ));
L560: ( ( Following C269 ) . D388 ) = ( C272 '&' C270 ) by L559 , L532;
L561: (( ( Following C269 ) . D386 ) = ( C270 '&' ( 'not' C271 ) ) & ( ( Following C269 ) . D387 ) = ( ( 'not' C271 ) '&' C272 )) by L559 , L532;
thus L562: ( ( Following (C269 , 2) ) . ( GFA1CarryOutput (C266 , C267 , C268) ) ) = ( ( ( C270 '&' ( 'not' C271 ) ) 'or' ( ( 'not' C271 ) '&' C272 ) ) 'or' ( C272 '&' C270 ) ) by L561 , L558 , L560 , L547;
L563: C266 in ( InputVertices D382 ) by L553 , L512;
L564: ( ( Following C269 ) . D383 ) = ( C269 . C266 ) by L563 , CIRCUIT2:def 5;
thus L565: thesis by L564 , L559 , L555 , L557 , L558 , L532;
end;
theorem
L566: (for B268 , B269 , B270 being set holds ((B268 <> [ <* B269 , B270 *> , ( and2a ) ] & B269 <> [ <* B270 , B268 *> , ( and2 ) ] & B270 <> [ <* B268 , B269 *> , ( and2c ) ]) implies (for B271 being (State of ( GFA1CarryCirc (B268 , B269 , B270) )) holds ( Following (B271 , 2) ) is  stable)))
proof
set D389 = ( and2c );
set D390 = ( and2a );
set D391 = ( and2 );
let C273 , C274 , C275 being set;
assume that
L567: (C273 <> [ <* C274 , C275 *> , D390 ] & C274 <> [ <* C275 , C273 *> , D391 ] & C275 <> [ <* C273 , C274 *> , D389 ]);
set D392 = ( GFA1CarryStr (C273 , C274 , C275) );
reconsider D393 = C273 , D394 = C274 , D395 = C275 as (Vertex of D392) by L490;
let C276 being (State of ( GFA1CarryCirc (C273 , C274 , C275) ));
set D396 = ( C276 . D393 );
set D397 = ( C276 . D394 );
set D398 = ( C276 . D395 );
set D399 = ( Following (C276 , 2) );
set D400 = ( Following D399 );
set D401 = [ <* C273 , C274 *> , D389 ];
set D402 = [ <* C274 , C275 *> , D390 ];
set D403 = [ <* C275 , C273 *> , D391 ];
L568: D399 = ( Following ( Following C276 ) ) by FACIRC_1:15;
L569: C275 in ( InputVertices D392 ) by L567 , L512;
L570: ( ( Following C276 ) . C275 ) = D398 by L569 , CIRCUIT2:def 5;
L571: ( D399 . C275 ) = D398 by L570 , L568 , L569 , CIRCUIT2:def 5;
L572: C274 in ( InputVertices D392 ) by L567 , L512;
L573: ( ( Following C276 ) . C274 ) = D397 by L572 , CIRCUIT2:def 5;
L574: ( D399 . C274 ) = D397 by L573 , L568 , L572 , CIRCUIT2:def 5;
L575: C273 in ( InputVertices D392 ) by L567 , L512;
L576: ( ( Following C276 ) . C273 ) = D396 by L575 , CIRCUIT2:def 5;
L577: ( D399 . C273 ) = D396 by L576 , L568 , L575 , CIRCUIT2:def 5;
L578: D398 = ( C276 . C275 );
L579: ( D399 . D401 ) = ( D396 '&' ( 'not' D397 ) ) by L578 , L567 , L552;
L580: D397 = ( C276 . C274 );
L581: ( D399 . D403 ) = ( D396 '&' D398 ) by L580 , L567 , L552;
L582: D396 = ( C276 . C273 );
L583: ( D399 . D402 ) = ( ( 'not' D397 ) '&' D398 ) by L582 , L567 , L552;
L584: ( D399 . ( GFA1CarryOutput (C273 , C274 , C275) ) ) = ( ( ( D396 '&' ( 'not' D397 ) ) 'or' ( ( 'not' D397 ) '&' D398 ) ) 'or' ( D398 '&' D396 ) ) by L567 , L552;
L585:
now
let C277 being set;
assume L586: C277 in (the carrier of D392);
reconsider D404 = C277 as (Vertex of D392) by L586;
L587: D404 in ( ( InputVertices D392 ) \/ ( InnerVertices D392 ) ) by L586 , XBOOLE_1:45;
thus L588: ( D399 . C277 ) = ( D400 . C277 )
proof
per cases  by L587 , XBOOLE_0:def 3;
suppose L589: D404 in ( InputVertices D392 );

thus L590: thesis by L589 , CIRCUIT2:def 5;
end;
suppose L591: D404 in ( InnerVertices D392 );

L592: D404 in ( { D401 , D402 , D403 } \/ { ( GFA1CarryOutput (C273 , C274 , C275) ) } ) by L591 , L447;
L593: (D404 in { D401 , D402 , D403 } or D404 in { ( GFA1CarryOutput (C273 , C274 , C275) ) }) by L592 , XBOOLE_0:def 3;
L594: (D404 = D401 or D404 = D402 or D404 = D403 or D404 = ( GFA1CarryOutput (C273 , C274 , C275) )) by L593 , ENUMSET1:def 1 , TARSKI:def 1;
thus L595: thesis by L594 , L584 , L579 , L583 , L581 , L577 , L574 , L571 , L532 , L547;
end;
end;

end;
L589: (( dom ( Following ( Following (C276 , 2) ) ) ) = (the carrier of D392) & ( dom ( Following (C276 , 2) ) ) = (the carrier of D392)) by CIRCUIT1:3;
thus L590: D399 = D400 by L589 , L585 , FUNCT_1:2;
end;
definition
let C278 , C279 , C280 being set;
func GFA1AdderStr (C278 , C279 , C280) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( 2GatesCircStr (C278 , C279 , C280 , ( xor2c )) );
coherence;
end;
definition
let C281 , C282 , C283 being set;
func GFA1AdderCirc (C281 , C282 , C283) ->  strict  Boolean  gate`2=den (Circuit of ( GFA1AdderStr (C281 , C282 , C283) )) equals 
( 2GatesCircuit (C281 , C282 , C283 , ( xor2c )) );
coherence;
end;
definition
let C284 , C285 , C286 being set;
func GFA1AdderOutput (C284 , C285 , C286) -> (Element of ( InnerVertices ( GFA1AdderStr (C284 , C285 , C286) ) )) equals 
( 2GatesCircOutput (C284 , C285 , C286 , ( xor2c )) );
coherence;
end;
theorem
L594: (for B272 , B273 , B274 being set holds ( InnerVertices ( GFA1AdderStr (B272 , B273 , B274) ) ) = ( { [ <* B272 , B273 *> , ( xor2c ) ] } \/ { ( GFA1AdderOutput (B272 , B273 , B274) ) } ))
proof
let C287 , C288 , C289 being set;
set D405 = ( xor2c );
set D406 = [ <* C287 , C288 *> , D405 ];
set D407 = ( GFA1AdderStr (C287 , C288 , C289) );
thus L595: ( InnerVertices D407 ) = { D406 , ( GFA1AdderOutput (C287 , C288 , C289) ) } by FACIRC_1:56
.= ( { D406 } \/ { ( GFA1AdderOutput (C287 , C288 , C289) ) } ) by ENUMSET1:1;
end;
theorem
L596: (for B275 , B276 , B277 being set holds (B275 in (the carrier of ( GFA1AdderStr (B275 , B276 , B277) )) & B276 in (the carrier of ( GFA1AdderStr (B275 , B276 , B277) )) & B277 in (the carrier of ( GFA1AdderStr (B275 , B276 , B277) )) & [ <* B275 , B276 *> , ( xor2c ) ] in (the carrier of ( GFA1AdderStr (B275 , B276 , B277) )) & [ <* [ <* B275 , B276 *> , ( xor2c ) ] , B277 *> , ( xor2c ) ] in (the carrier of ( GFA1AdderStr (B275 , B276 , B277) )))) by FACIRC_1:60 , FACIRC_1:61;
theorem
L597: (for B278 , B279 , B280 being set holds ([ <* B278 , B279 *> , ( xor2c ) ] in ( InnerVertices ( GFA1AdderStr (B278 , B279 , B280) ) ) & ( GFA1AdderOutput (B278 , B279 , B280) ) in ( InnerVertices ( GFA1AdderStr (B278 , B279 , B280) ) )))
proof
let C290 , C291 , C292 being set;
set D408 = ( xor2c );
set D409 = ( GFA1AdderStr (C290 , C291 , C292) );
L598: ( InnerVertices D409 ) = ( { [ <* C290 , C291 *> , D408 ] } \/ { ( GFA1AdderOutput (C290 , C291 , C292) ) } ) by L594
.= { [ <* C290 , C291 *> , D408 ] , ( GFA1AdderOutput (C290 , C291 , C292) ) } by ENUMSET1:1;
thus L599: thesis by L598 , TARSKI:def 2;
end;
theorem
L600: (for B281 , B282 , B283 being set holds (B283 <> [ <* B281 , B282 *> , ( xor2c ) ] implies (B281 in ( InputVertices ( GFA1AdderStr (B281 , B282 , B283) ) ) & B282 in ( InputVertices ( GFA1AdderStr (B281 , B282 , B283) ) ) & B283 in ( InputVertices ( GFA1AdderStr (B281 , B282 , B283) ) ))))
proof
set D410 = ( xor2c );
let C293 , C294 , C295 being set;
assume that
L601: C295 <> [ <* C293 , C294 *> , D410 ];
set D411 = ( GFA1AdderStr (C293 , C294 , C295) );
L602: ( InputVertices D411 ) = { C293 , C294 , C295 } by L601 , FACIRC_1:57;
thus L603: thesis by L602 , ENUMSET1:def 1;
end;
theorem
L604: (for B284 , B285 , B286 being set holds (B286 <> [ <* B284 , B285 *> , ( xor2c ) ] implies (for B287 being (State of ( GFA1AdderCirc (B284 , B285 , B286) )) holds (for B288 , B289 , B290 being (Element of ( BOOLEAN )) holds ((B288 = ( B287 . B284 ) & B289 = ( B287 . B285 ) & B290 = ( B287 . B286 )) implies (( ( Following B287 ) . [ <* B284 , B285 *> , ( xor2c ) ] ) = ( B288 'xor' ( 'not' B289 ) ) & ( ( Following B287 ) . B284 ) = B288 & ( ( Following B287 ) . B285 ) = B289 & ( ( Following B287 ) . B286 ) = B290))))))
proof
set D412 = ( xor2c );
let C296 , C297 , C298 being set;
assume that
L605: C298 <> [ <* C296 , C297 *> , D412 ];
set D413 = ( GFA1AdderCirc (C296 , C297 , C298) );
set D414 = [ <* C296 , C297 *> , D412 ];
let C299 being (State of D413);
let C300 , C301 , C302 being (Element of ( BOOLEAN ));
assume that
L606: (C300 = ( C299 . C296 ) & C301 = ( C299 . C297 ))
and
L607: C302 = ( C299 . C298 );
L608: ( ( Following C299 ) . D414 ) = ( D412 . <* C300 , C301 *> ) by L605 , L606 , L142;
thus L609: ( ( Following C299 ) . D414 ) = ( C300 'xor' ( 'not' C301 ) ) by L608 , L48;
thus L610: thesis by L605 , L606 , L607 , L142;
end;
theorem
L611: (for B291 , B292 , B293 being set holds (B293 <> [ <* B291 , B292 *> , ( xor2c ) ] implies (for B294 being (State of ( GFA1AdderCirc (B291 , B292 , B293) )) holds (for B295 , B296 , B297 , B298 being (Element of ( BOOLEAN )) holds ((B295 = ( B294 . [ <* B291 , B292 *> , ( xor2c ) ] ) & B298 = ( B294 . B293 )) implies ( ( Following B294 ) . ( GFA1AdderOutput (B291 , B292 , B293) ) ) = ( B295 'xor' ( 'not' B298 ) ))))))
proof
set D415 = ( xor2c );
let C303 , C304 , C305 being set;
assume that
L612: C305 <> [ <* C303 , C304 *> , D415 ];
set D416 = ( GFA1AdderCirc (C303 , C304 , C305) );
set D417 = [ <* C303 , C304 *> , D415 ];
let C306 being (State of D416);
let C307 , C308 , C309 , C310 being (Element of ( BOOLEAN ));
assume that
L613: (C307 = ( C306 . D417 ) & C310 = ( C306 . C305 ));
thus L614: ( ( Following C306 ) . ( GFA1AdderOutput (C303 , C304 , C305) ) ) = ( D415 . <* ( C306 . D417 ) , ( C306 . C305 ) *> ) by L612 , L142
.= ( C307 'xor' ( 'not' C310 ) ) by L613 , L48;
end;
theorem
L615: (for B299 , B300 , B301 being set holds (B301 <> [ <* B299 , B300 *> , ( xor2c ) ] implies (for B302 being (State of ( GFA1AdderCirc (B299 , B300 , B301) )) holds (for B303 , B304 , B305 being (Element of ( BOOLEAN )) holds ((B303 = ( B302 . B299 ) & B304 = ( B302 . B300 ) & B305 = ( B302 . B301 )) implies (( ( Following (B302 , 2) ) . ( GFA1AdderOutput (B299 , B300 , B301) ) ) = ( ( B303 'xor' ( 'not' B304 ) ) 'xor' ( 'not' B305 ) ) & ( ( Following (B302 , 2) ) . [ <* B299 , B300 *> , ( xor2c ) ] ) = ( B303 'xor' ( 'not' B304 ) ) & ( ( Following (B302 , 2) ) . B299 ) = B303 & ( ( Following (B302 , 2) ) . B300 ) = B304 & ( ( Following (B302 , 2) ) . B301 ) = B305))))))
proof
set D418 = ( xor2c );
let C311 , C312 , C313 being set;
assume that
L616: C313 <> [ <* C311 , C312 *> , D418 ];
set D419 = [ <* C311 , C312 *> , D418 ];
set D420 = ( GFA1AdderCirc (C311 , C312 , C313) );
let C314 being (State of D420);
let C315 , C316 , C317 being (Element of ( BOOLEAN ));
assume that
L617: (C315 = ( C314 . C311 ) & C316 = ( C314 . C312 ))
and
L618: C317 = ( C314 . C313 );
thus L619: ( ( Following (C314 , 2) ) . ( GFA1AdderOutput (C311 , C312 , C313) ) ) = ( D418 . <* ( D418 . <* C315 , C316 *> ) , C317 *> ) by L616 , L617 , L618 , FACIRC_1:62
.= ( D418 . <* ( C315 'xor' ( 'not' C316 ) ) , C317 *> ) by L48
.= ( ( C315 'xor' ( 'not' C316 ) ) 'xor' ( 'not' C317 ) ) by L48;
L620: ( ( Following (C314 , 2) ) . D419 ) = ( D418 . <* C315 , C316 *> ) by L616 , L617 , FACIRC_1:62;
thus L621: ( ( Following (C314 , 2) ) . D419 ) = ( C315 'xor' ( 'not' C316 ) ) by L620 , L48;
thus L622: thesis by L616 , L617 , L618 , FACIRC_1:62;
end;
theorem
L623: (for B306 , B307 , B308 being set holds (B308 <> [ <* B306 , B307 *> , ( xor2c ) ] implies (for B309 being (State of ( GFA1AdderCirc (B306 , B307 , B308) )) holds (for B310 , B311 , B312 being (Element of ( BOOLEAN )) holds ((B310 = ( B309 . B306 ) & B311 = ( B309 . B307 ) & B312 = ( B309 . B308 )) implies ( ( Following (B309 , 2) ) . ( GFA1AdderOutput (B306 , B307 , B308) ) ) = ( 'not' ( ( B310 'xor' ( 'not' B311 ) ) 'xor' B312 ) ))))))
proof
set D421 = ( xor2c );
let C318 , C319 , C320 being set;
assume that
L624: C320 <> [ <* C318 , C319 *> , D421 ];
set D422 = ( GFA1AdderCirc (C318 , C319 , C320) );
let C321 being (State of D422);
let C322 , C323 , C324 being (Element of ( BOOLEAN ));
assume L625: (C322 = ( C321 . C318 ) & C323 = ( C321 . C319 ) & C324 = ( C321 . C320 ));
thus L626: ( ( Following (C321 , 2) ) . ( GFA1AdderOutput (C318 , C319 , C320) ) ) = ( ( C322 'xor' ( 'not' C323 ) ) 'xor' ( 'not' C324 ) ) by L625 , L624 , L615
.= ( 'not' ( ( C322 'xor' ( 'not' C323 ) ) 'xor' C324 ) ) by XBOOLEAN:74;
end;
definition
let C325 , C326 , C327 being set;
func BitGFA1Str (C325 , C326 , C327) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( GFA1AdderStr (C325 , C326 , C327) ) +* ( GFA1CarryStr (C325 , C326 , C327) ) );
coherence;
end;
definition
let C328 , C329 , C330 being set;
func BitGFA1Circ (C328 , C329 , C330) ->  strict  Boolean  gate`2=den (Circuit of ( BitGFA1Str (C328 , C329 , C330) )) equals 
( ( GFA1AdderCirc (C328 , C329 , C330) ) +* ( GFA1CarryCirc (C328 , C329 , C330) ) );
coherence;
end;
theorem
L629: (for B313 , B314 , B315 being set holds ( InnerVertices ( BitGFA1Str (B313 , B314 , B315) ) ) = ( ( ( { [ <* B313 , B314 *> , ( xor2c ) ] } \/ { ( GFA1AdderOutput (B313 , B314 , B315) ) } ) \/ { [ <* B313 , B314 *> , ( and2c ) ] , [ <* B314 , B315 *> , ( and2a ) ] , [ <* B315 , B313 *> , ( and2 ) ] } ) \/ { ( GFA1CarryOutput (B313 , B314 , B315) ) } ))
proof
let C331 , C332 , C333 being set;
set D423 = ( and2c );
set D424 = ( and2a );
set D425 = ( and2 );
set D426 = ( xor2c );
set D427 = [ <* C331 , C332 *> , D426 ];
set D428 = [ <* C331 , C332 *> , D423 ];
set D429 = [ <* C332 , C333 *> , D424 ];
set D430 = [ <* C333 , C331 *> , D425 ];
set D431 = ( BitGFA1Str (C331 , C332 , C333) );
set D432 = ( GFA1AdderStr (C331 , C332 , C333) );
set D433 = ( GFA1CarryStr (C331 , C332 , C333) );
set D434 = ( GFA1AdderOutput (C331 , C332 , C333) );
set D435 = ( GFA1CarryOutput (C331 , C332 , C333) );
thus L630: ( InnerVertices D431 ) = ( ( InnerVertices D432 ) \/ ( InnerVertices D433 ) ) by FACIRC_1:27
.= ( ( { D427 } \/ { D434 } ) \/ ( InnerVertices D433 ) ) by L594
.= ( ( { D427 } \/ { D434 } ) \/ ( { D428 , D429 , D430 } \/ { D435 } ) ) by L447
.= ( ( ( { D427 } \/ { D434 } ) \/ { D428 , D429 , D430 } ) \/ { D435 } ) by XBOOLE_1:4;
end;
theorem
L631: (for B316 , B317 , B318 being set holds ( InnerVertices ( BitGFA1Str (B316 , B317 , B318) ) ) is Relation)
proof
let C334 , C335 , C336 being set;
set D436 = ( GFA1AdderStr (C334 , C335 , C336) );
set D437 = ( GFA1CarryStr (C334 , C335 , C336) );
L632: (( InnerVertices D436 ) is Relation & ( InnerVertices D437 ) is Relation) by L454 , FACIRC_1:58;
thus L633: thesis by L632 , FACIRC_1:3;
end;
theorem
L634: (for B319 , B320 , B321 being set holds ((B321 <> [ <* B319 , B320 *> , ( xor2c ) ] & B319 <> [ <* B320 , B321 *> , ( and2a ) ] & B320 <> [ <* B321 , B319 *> , ( and2 ) ] & B321 <> [ <* B319 , B320 *> , ( and2c ) ]) implies ( InputVertices ( BitGFA1Str (B319 , B320 , B321) ) ) = { B319 , B320 , B321 }))
proof
set D438 = ( and2c );
set D439 = ( and2a );
set D440 = ( and2 );
set D441 = ( xor2c );
let C337 , C338 , C339 being set;
assume that
L635: (C339 <> [ <* C337 , C338 *> , D441 ] & C337 <> [ <* C338 , C339 *> , D439 ] & C338 <> [ <* C339 , C337 *> , D440 ] & C339 <> [ <* C337 , C338 *> , D438 ]);
set D442 = ( GFA1CarryStr (C337 , C338 , C339) );
set D443 = ( GFA1AdderStr (C337 , C338 , C339) );
L636: (( InputVertices D443 ) = { C337 , C338 , C339 } & ( InputVertices D442 ) = { C337 , C338 , C339 }) by L635 , L469 , FACIRC_1:57;
thus L637: thesis by L636 , CIRCCOMB:47 , FACIRC_2:21;
end;
theorem
L638: (for B322 , B323 , B324 being non  pair set holds ( InputVertices ( BitGFA1Str (B322 , B323 , B324) ) ) = { B322 , B323 , B324 })
proof
let C340 , C341 , C342 being non  pair set;
set D444 = ( BitGFA1Str (C340 , C341 , C342) );
set D445 = ( GFA1AdderStr (C340 , C341 , C342) );
set D446 = ( GFA1CarryStr (C340 , C341 , C342) );
L639: (( InputVertices D445 ) = { C340 , C341 , C342 } & ( InputVertices D446 ) = { C340 , C341 , C342 }) by L516 , FACIRC_1:57;
L640: (( InnerVertices D445 ) is Relation & ( InnerVertices D446 ) is Relation) by L454 , FACIRC_1:58;
thus L641: ( InputVertices D444 ) = ( { C340 , C341 , C342 } \/ { C340 , C341 , C342 } ) by L640 , L639 , FACIRC_1:7
.= { C340 , C341 , C342 };
end;
theorem
L642: (for B325 , B326 , B327 being non  pair set holds ( InputVertices ( BitGFA1Str (B325 , B326 , B327) ) ) is  without_pairs)
proof
let C343 , C344 , C345 being non  pair set;
L643: ( InputVertices ( BitGFA1Str (C343 , C344 , C345) ) ) = { C343 , C344 , C345 } by L638;
thus L644: thesis by L643;
end;
theorem
L645: (for B328 , B329 , B330 being set holds (B328 in (the carrier of ( BitGFA1Str (B328 , B329 , B330) )) & B329 in (the carrier of ( BitGFA1Str (B328 , B329 , B330) )) & B330 in (the carrier of ( BitGFA1Str (B328 , B329 , B330) )) & [ <* B328 , B329 *> , ( xor2c ) ] in (the carrier of ( BitGFA1Str (B328 , B329 , B330) )) & [ <* [ <* B328 , B329 *> , ( xor2c ) ] , B330 *> , ( xor2c ) ] in (the carrier of ( BitGFA1Str (B328 , B329 , B330) )) & [ <* B328 , B329 *> , ( and2c ) ] in (the carrier of ( BitGFA1Str (B328 , B329 , B330) )) & [ <* B329 , B330 *> , ( and2a ) ] in (the carrier of ( BitGFA1Str (B328 , B329 , B330) )) & [ <* B330 , B328 *> , ( and2 ) ] in (the carrier of ( BitGFA1Str (B328 , B329 , B330) )) & [ <* [ <* B328 , B329 *> , ( and2c ) ] , [ <* B329 , B330 *> , ( and2a ) ] , [ <* B330 , B328 *> , ( and2 ) ] *> , ( or3 ) ] in (the carrier of ( BitGFA1Str (B328 , B329 , B330) ))))
proof
let C346 , C347 , C348 being set;
set D447 = ( and2c );
set D448 = ( and2a );
set D449 = ( and2 );
set D450 = ( or3 );
set D451 = ( xor2c );
set D452 = [ <* C346 , C347 *> , D447 ];
set D453 = [ <* C347 , C348 *> , D448 ];
set D454 = [ <* C348 , C346 *> , D449 ];
set D455 = [ <* D452 , D453 , D454 *> , D450 ];
set D456 = ( GFA1AdderStr (C346 , C347 , C348) );
set D457 = ( GFA1CarryStr (C346 , C347 , C348) );
L646: (C346 in (the carrier of D456) & C347 in (the carrier of D456)) by FACIRC_1:60;
L647: (C348 in (the carrier of D456) & [ <* C346 , C347 *> , D451 ] in (the carrier of D456)) by FACIRC_1:60 , FACIRC_1:61;
L648: D455 in (the carrier of D457) by L490;
L649: (D453 in (the carrier of D457) & D454 in (the carrier of D457)) by L490;
L650: ([ <* [ <* C346 , C347 *> , D451 ] , C348 *> , D451 ] in (the carrier of D456) & D452 in (the carrier of D457)) by L490 , FACIRC_1:61;
thus L651: thesis by L650 , L646 , L647 , L649 , L648 , FACIRC_1:20;
end;
theorem
L652: (for B331 , B332 , B333 being set holds ([ <* B331 , B332 *> , ( xor2c ) ] in ( InnerVertices ( BitGFA1Str (B331 , B332 , B333) ) ) & ( GFA1AdderOutput (B331 , B332 , B333) ) in ( InnerVertices ( BitGFA1Str (B331 , B332 , B333) ) ) & [ <* B331 , B332 *> , ( and2c ) ] in ( InnerVertices ( BitGFA1Str (B331 , B332 , B333) ) ) & [ <* B332 , B333 *> , ( and2a ) ] in ( InnerVertices ( BitGFA1Str (B331 , B332 , B333) ) ) & [ <* B333 , B331 *> , ( and2 ) ] in ( InnerVertices ( BitGFA1Str (B331 , B332 , B333) ) ) & ( GFA1CarryOutput (B331 , B332 , B333) ) in ( InnerVertices ( BitGFA1Str (B331 , B332 , B333) ) )))
proof
let C349 , C350 , C351 being set;
set D458 = ( and2c );
set D459 = ( and2a );
set D460 = ( and2 );
set D461 = ( xor2c );
set D462 = [ <* C349 , C350 *> , D461 ];
set D463 = [ <* C349 , C350 *> , D458 ];
set D464 = [ <* C350 , C351 *> , D459 ];
set D465 = [ <* C351 , C349 *> , D460 ];
set D466 = ( BitGFA1Str (C349 , C350 , C351) );
set D467 = ( GFA1AdderOutput (C349 , C350 , C351) );
set D468 = ( GFA1CarryOutput (C349 , C350 , C351) );
L653: ( InnerVertices D466 ) = ( ( ( { D462 } \/ { D467 } ) \/ { D463 , D464 , D465 } ) \/ { D468 } ) by L629
.= ( ( { D462 , D467 } \/ { D463 , D464 , D465 } ) \/ { D468 } ) by ENUMSET1:1
.= ( { D462 , D467 , D463 , D464 , D465 } \/ { D468 } ) by ENUMSET1:8
.= { D462 , D467 , D463 , D464 , D465 , D468 } by ENUMSET1:15;
thus L654: thesis by L653 , ENUMSET1:def 4;
end;
theorem
L655: (for B334 , B335 , B336 being set holds ((B336 <> [ <* B334 , B335 *> , ( xor2c ) ] & B334 <> [ <* B335 , B336 *> , ( and2a ) ] & B335 <> [ <* B336 , B334 *> , ( and2 ) ] & B336 <> [ <* B334 , B335 *> , ( and2c ) ]) implies (B334 in ( InputVertices ( BitGFA1Str (B334 , B335 , B336) ) ) & B335 in ( InputVertices ( BitGFA1Str (B334 , B335 , B336) ) ) & B336 in ( InputVertices ( BitGFA1Str (B334 , B335 , B336) ) ))))
proof
set D469 = ( and2c );
set D470 = ( and2a );
set D471 = ( and2 );
set D472 = ( xor2c );
let C352 , C353 , C354 being set;
assume that
L656: (C354 <> [ <* C352 , C353 *> , D472 ] & C352 <> [ <* C353 , C354 *> , D470 ] & C353 <> [ <* C354 , C352 *> , D471 ] & C354 <> [ <* C352 , C353 *> , D469 ]);
set D473 = ( BitGFA1Str (C352 , C353 , C354) );
L657: ( InputVertices D473 ) = { C352 , C353 , C354 } by L656 , L634;
thus L658: thesis by L657 , ENUMSET1:def 1;
end;
definition
let C355 , C356 , C357 being set;
func BitGFA1CarryOutput (C355 , C356 , C357) -> (Element of ( InnerVertices ( BitGFA1Str (C355 , C356 , C357) ) )) equals 
[ <* [ <* C355 , C356 *> , ( and2c ) ] , [ <* C356 , C357 *> , ( and2a ) ] , [ <* C357 , C355 *> , ( and2 ) ] *> , ( or3 ) ];
coherence
proof
L659: ( GFA1CarryOutput (C355 , C356 , C357) ) in ( InnerVertices ( BitGFA1Str (C355 , C356 , C357) ) ) by L652;
thus L660: thesis by L659;
end;
end;
definition
let C358 , C359 , C360 being set;
func BitGFA1AdderOutput (C358 , C359 , C360) -> (Element of ( InnerVertices ( BitGFA1Str (C358 , C359 , C360) ) )) equals 
( 2GatesCircOutput (C358 , C359 , C360 , ( xor2c )) );
coherence
proof
L662: ( GFA1AdderOutput (C358 , C359 , C360) ) in ( InnerVertices ( BitGFA1Str (C358 , C359 , C360) ) ) by L652;
thus L663: thesis by L662;
end;
end;
theorem
L665: (for B337 , B338 , B339 being set holds ((B339 <> [ <* B337 , B338 *> , ( xor2c ) ] & B337 <> [ <* B338 , B339 *> , ( and2a ) ] & B338 <> [ <* B339 , B337 *> , ( and2 ) ] & B339 <> [ <* B337 , B338 *> , ( and2c ) ]) implies (for B340 being (State of ( BitGFA1Circ (B337 , B338 , B339) )) holds (for B341 , B342 , B343 being (Element of ( BOOLEAN )) holds ((B341 = ( B340 . B337 ) & B342 = ( B340 . B338 ) & B343 = ( B340 . B339 )) implies (( ( Following (B340 , 2) ) . ( GFA1AdderOutput (B337 , B338 , B339) ) ) = ( 'not' ( ( B341 'xor' ( 'not' B342 ) ) 'xor' B343 ) ) & ( ( Following (B340 , 2) ) . ( GFA1CarryOutput (B337 , B338 , B339) ) ) = ( ( ( B341 '&' ( 'not' B342 ) ) 'or' ( ( 'not' B342 ) '&' B343 ) ) 'or' ( B343 '&' B341 ) )))))))
proof
set D474 = ( and2c );
set D475 = ( and2a );
set D476 = ( and2 );
set D477 = ( xor2c );
let C361 , C362 , C363 being set;
assume that
L666: C363 <> [ <* C361 , C362 *> , D477 ]
and
L667: (C361 <> [ <* C362 , C363 *> , D475 ] & C362 <> [ <* C363 , C361 *> , D476 ] & C363 <> [ <* C361 , C362 *> , D474 ]);
set D478 = ( GFA1CarryStr (C361 , C362 , C363) );
set D479 = ( GFA1AdderStr (C361 , C362 , C363) );
L668: ( InputVertices D479 ) = { C361 , C362 , C363 } by L666 , FACIRC_1:57;
L669: ( InputVertices D479 ) = ( InputVertices D478 ) by L668 , L667 , L469;
set D480 = ( GFA1CarryCirc (C361 , C362 , C363) );
set D481 = ( GFA1AdderCirc (C361 , C362 , C363) );
set D482 = ( BitGFA1Circ (C361 , C362 , C363) );
let C364 being (State of D482);
let C365 , C366 , C367 being (Element of ( BOOLEAN ));
assume that
L670: C365 = ( C364 . C361 )
and
L671: C366 = ( C364 . C362 )
and
L672: C367 = ( C364 . C363 );
reconsider D483 = ( C364 | (the carrier of D479) ) as (State of D481) by FACIRC_1:26;
L673: ( dom D483 ) = (the carrier of D479) by CIRCUIT1:3;
L674: C363 in (the carrier of D479) by FACIRC_1:60;
L675: C367 = ( D483 . C363 ) by L674 , L672 , L673 , FUNCT_1:47;
L676: C362 in (the carrier of D479) by FACIRC_1:60;
L677: C366 = ( D483 . C362 ) by L676 , L671 , L673 , FUNCT_1:47;
reconsider D484 = C364 as (State of ( D481 +* D480 ));
L678: ( InnerVertices D478 ) misses ( InputVertices D478 ) by XBOOLE_1:79;
L679: ( ( Following (D484 , 2) ) . ( GFA1AdderOutput (C361 , C362 , C363) ) ) = ( ( Following (D483 , 2) ) . ( GFA1AdderOutput (C361 , C362 , C363) ) ) by L678 , L669 , FACIRC_1:32;
reconsider D485 = ( C364 | (the carrier of D478) ) as (State of D480) by FACIRC_1:26;
L680: ( dom D485 ) = (the carrier of D478) by CIRCUIT1:3;
L681: C361 in (the carrier of D479) by FACIRC_1:60;
L682: C365 = ( D483 . C361 ) by L681 , L670 , L673 , FUNCT_1:47;
thus L683: ( ( Following (C364 , 2) ) . ( GFA1AdderOutput (C361 , C362 , C363) ) ) = ( 'not' ( ( C365 'xor' ( 'not' C366 ) ) 'xor' C367 ) ) by L682 , L666 , L677 , L675 , L679 , L623;
L684: ( InnerVertices D479 ) misses ( InputVertices D479 ) by XBOOLE_1:79;
L685: ( ( Following (D484 , 2) ) . ( GFA1CarryOutput (C361 , C362 , C363) ) ) = ( ( Following (D485 , 2) ) . ( GFA1CarryOutput (C361 , C362 , C363) ) ) by L684 , L669 , FACIRC_1:33;
L686: C363 in (the carrier of D478) by L490;
L687: C367 = ( D485 . C363 ) by L686 , L672 , L680 , FUNCT_1:47;
L688: C362 in (the carrier of D478) by L490;
L689: C366 = ( D485 . C362 ) by L688 , L671 , L680 , FUNCT_1:47;
L690: C361 in (the carrier of D478) by L490;
L691: C365 = ( D485 . C361 ) by L690 , L670 , L680 , FUNCT_1:47;
thus L692: thesis by L691 , L667 , L689 , L687 , L685 , L552;
end;
theorem
L693: (for B344 , B345 , B346 being set holds ((B346 <> [ <* B344 , B345 *> , ( xor2c ) ] & B344 <> [ <* B345 , B346 *> , ( and2a ) ] & B345 <> [ <* B346 , B344 *> , ( and2 ) ] & B346 <> [ <* B344 , B345 *> , ( and2c ) ]) implies (for B347 being (State of ( BitGFA1Circ (B344 , B345 , B346) )) holds ( Following (B347 , 2) ) is  stable)))
proof
set D486 = ( and2c );
set D487 = ( and2a );
set D488 = ( and2 );
set D489 = ( xor2c );
let C368 , C369 , C370 being set;
assume that
L694: C370 <> [ <* C368 , C369 *> , D489 ]
and
L695: (C368 <> [ <* C369 , C370 *> , D487 ] & C369 <> [ <* C370 , C368 *> , D488 ] & C370 <> [ <* C368 , C369 *> , D486 ]);
set D490 = ( BitGFA1Circ (C368 , C369 , C370) );
let C371 being (State of D490);
set D491 = ( GFA1CarryStr (C368 , C369 , C370) );
set D492 = ( GFA1AdderStr (C368 , C369 , C370) );
L696: ( InputVertices D492 ) = { C368 , C369 , C370 } by L694 , FACIRC_1:57;
L697: ( InputVertices D492 ) = ( InputVertices D491 ) by L696 , L695 , L469;
set D493 = ( GFA1AdderCirc (C368 , C369 , C370) );
reconsider D494 = ( C371 | (the carrier of D492) ) as (State of D493) by FACIRC_1:26;
L698: ( Following (D494 , 2) ) is  stable by L694 , FACIRC_1:63;
L699: ( Following (D494 , 2) ) = ( Following ( Following (D494 , 2) ) ) by L698 , CIRCUIT2:def 6
.= ( Following (D494 , ( 2 + 1 )) ) by FACIRC_1:12;
set D495 = ( GFA1CarryCirc (C368 , C369 , C370) );
reconsider D496 = ( C371 | (the carrier of D491) ) as (State of D495) by FACIRC_1:26;
L700: ( Following (D496 , 2) ) is  stable by L695 , L566;
L701: ( Following (D496 , 2) ) = ( Following ( Following (D496 , 2) ) ) by L700 , CIRCUIT2:def 6
.= ( Following (D496 , ( 2 + 1 )) ) by FACIRC_1:12;
reconsider D497 = C371 as (State of ( D493 +* D495 ));
set D498 = ( BitGFA1Str (C368 , C369 , C370) );
L702: ( dom ( Following (C371 , 3) ) ) = (the carrier of D498) by CIRCUIT1:3;
L703: ( InnerVertices D491 ) misses ( InputVertices D491 ) by XBOOLE_1:79;
L704: (( Following (D494 , 2) ) = ( ( Following (D497 , 2) ) | (the carrier of D492) ) & ( Following (D494 , 3) ) = ( ( Following (D497 , 3) ) | (the carrier of D492) )) by L703 , L697 , FACIRC_1:30;
L705: ( InnerVertices D492 ) misses ( InputVertices D492 ) by XBOOLE_1:79;
L706: (( Following (D496 , 2) ) = ( ( Following (D497 , 2) ) | (the carrier of D491) ) & ( Following (D496 , 3) ) = ( ( Following (D497 , 3) ) | (the carrier of D491) )) by L705 , L697 , FACIRC_1:31;
L707: (the carrier of D498) = ( (the carrier of D492) \/ (the carrier of D491) ) by CIRCCOMB:def 2;
L708: (( dom ( Following (D494 , 2) ) ) = (the carrier of D492) & ( dom ( Following (D496 , 2) ) ) = (the carrier of D491)) by CIRCUIT1:3;
L709:
now
let C372 being set;
assume L710: C372 in (the carrier of D498);
L711: (C372 in (the carrier of D492) or C372 in (the carrier of D491)) by L710 , L707 , XBOOLE_0:def 3;
L712: ((( ( Following (C371 , 2) ) . C372 ) = ( ( Following (D494 , 2) ) . C372 ) & ( ( Following (C371 , 3) ) . C372 ) = ( ( Following (D494 , 3) ) . C372 )) or (( ( Following (C371 , 2) ) . C372 ) = ( ( Following (D496 , 2) ) . C372 ) & ( ( Following (C371 , 3) ) . C372 ) = ( ( Following (D496 , 3) ) . C372 ))) by L711 , L704 , L706 , L699 , L701 , L708 , FUNCT_1:47;
thus L713: ( ( Following (C371 , 2) ) . C372 ) = ( ( Following ( Following (C371 , 2) ) ) . C372 ) by L712 , L699 , L701 , FACIRC_1:12;
end;
L714: (( Following (C371 , ( 2 + 1 )) ) = ( Following ( Following (C371 , 2) ) ) & ( dom ( Following (C371 , 2) ) ) = (the carrier of D498)) by CIRCUIT1:3 , FACIRC_1:12;
thus L715: ( Following (C371 , 2) ) = ( Following ( Following (C371 , 2) ) ) by L714 , L702 , L709 , FUNCT_1:2;
end;
begin
definition
let C373 , C374 , C375 being set;
func GFA2CarryIStr (C373 , C374 , C375) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( ( 1GateCircStr (<* C373 , C374 *> , ( and2a )) ) +* ( 1GateCircStr (<* C374 , C375 *> , ( and2c )) ) ) +* ( 1GateCircStr (<* C375 , C373 *> , ( and2b )) ) );
coherence;
end;
definition
let C376 , C377 , C378 being set;
func GFA2CarryICirc (C376 , C377 , C378) ->  strict  Boolean  gate`2=den (Circuit of ( GFA2CarryIStr (C376 , C377 , C378) )) equals 
( ( ( 1GateCircuit (C376 , C377 , ( and2a )) ) +* ( 1GateCircuit (C377 , C378 , ( and2c )) ) ) +* ( 1GateCircuit (C378 , C376 , ( and2b )) ) );
coherence;
end;
definition
let C379 , C380 , C381 being set;
func GFA2CarryStr (C379 , C380 , C381) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( GFA2CarryIStr (C379 , C380 , C381) ) +* ( 1GateCircStr (<* [ <* C379 , C380 *> , ( and2a ) ] , [ <* C380 , C381 *> , ( and2c ) ] , [ <* C381 , C379 *> , ( and2b ) ] *> , ( nor3 )) ) );
coherence;
end;
definition
let C382 , C383 , C384 being set;
func GFA2CarryCirc (C382 , C383 , C384) ->  strict  Boolean  gate`2=den (Circuit of ( GFA2CarryStr (C382 , C383 , C384) )) equals 
( ( GFA2CarryICirc (C382 , C383 , C384) ) +* ( 1GateCircuit ([ <* C382 , C383 *> , ( and2a ) ] , [ <* C383 , C384 *> , ( and2c ) ] , [ <* C384 , C382 *> , ( and2b ) ] , ( nor3 )) ) );
coherence;
end;
definition
let C385 , C386 , C387 being set;
func GFA2CarryOutput (C385 , C386 , C387) -> (Element of ( InnerVertices ( GFA2CarryStr (C385 , C386 , C387) ) )) equals 
[ <* [ <* C385 , C386 *> , ( and2a ) ] , [ <* C386 , C387 *> , ( and2c ) ] , [ <* C387 , C385 *> , ( and2b ) ] *> , ( nor3 ) ];
coherence
proof
L720: [ <* [ <* C385 , C386 *> , ( and2a ) ] , [ <* C386 , C387 *> , ( and2c ) ] , [ <* C387 , C385 *> , ( and2b ) ] *> , ( nor3 ) ] in ( InnerVertices ( 1GateCircStr (<* [ <* C385 , C386 *> , ( and2a ) ] , [ <* C386 , C387 *> , ( and2c ) ] , [ <* C387 , C385 *> , ( and2b ) ] *> , ( nor3 )) ) ) by FACIRC_1:47;
thus L721: thesis by L720 , FACIRC_1:21;
end;
end;
theorem
L723: (for B348 , B349 , B350 being set holds ( InnerVertices ( GFA2CarryIStr (B348 , B349 , B350) ) ) = { [ <* B348 , B349 *> , ( and2a ) ] , [ <* B349 , B350 *> , ( and2c ) ] , [ <* B350 , B348 *> , ( and2b ) ] })
proof
let C388 , C389 , C390 being set;
set D499 = ( and2a );
set D500 = ( and2c );
set D501 = ( and2b );
set D502 = [ <* C388 , C389 *> , D499 ];
set D503 = [ <* C389 , C390 *> , D500 ];
set D504 = [ <* C390 , C388 *> , D501 ];
set D505 = ( 1GateCircStr (<* C388 , C389 *> , D499) );
set D506 = ( 1GateCircStr (<* C389 , C390 *> , D500) );
set D507 = ( 1GateCircStr (<* C390 , C388 *> , D501) );
L724: D505 tolerates D506 by CIRCCOMB:47;
L725: ( D505 +* D506 ) tolerates D507 by CIRCCOMB:47;
L726: ( InnerVertices ( GFA2CarryIStr (C388 , C389 , C390) ) ) = ( ( InnerVertices ( D505 +* D506 ) ) \/ ( InnerVertices D507 ) ) by L725 , CIRCCOMB:11
.= ( ( ( InnerVertices D505 ) \/ ( InnerVertices D506 ) ) \/ ( InnerVertices D507 ) ) by L724 , CIRCCOMB:11
.= ( ( { D502 } \/ ( InnerVertices D506 ) ) \/ ( InnerVertices D507 ) ) by CIRCCOMB:42
.= ( ( { D502 } \/ { D503 } ) \/ ( InnerVertices D507 ) ) by CIRCCOMB:42
.= ( ( { D502 } \/ { D503 } ) \/ { D504 } ) by CIRCCOMB:42
.= ( { D502 , D503 } \/ { D504 } ) by ENUMSET1:1
.= { D502 , D503 , D504 } by ENUMSET1:3;
thus L727: thesis by L726;
end;
theorem
L728: (for B351 , B352 , B353 being set holds ( InnerVertices ( GFA2CarryStr (B351 , B352 , B353) ) ) = ( { [ <* B351 , B352 *> , ( and2a ) ] , [ <* B352 , B353 *> , ( and2c ) ] , [ <* B353 , B351 *> , ( and2b ) ] } \/ { ( GFA2CarryOutput (B351 , B352 , B353) ) } ))
proof
let C391 , C392 , C393 being set;
set D508 = ( and2a );
set D509 = ( and2c );
set D510 = ( and2b );
set D511 = ( nor3 );
set D512 = [ <* C391 , C392 *> , D508 ];
set D513 = [ <* C392 , C393 *> , D509 ];
set D514 = [ <* C393 , C391 *> , D510 ];
set D515 = ( 1GateCircStr (<* C391 , C392 *> , D508) );
set D516 = ( 1GateCircStr (<* C392 , C393 *> , D509) );
set D517 = ( 1GateCircStr (<* C393 , C391 *> , D510) );
set D518 = ( 1GateCircStr (<* D512 , D513 , D514 *> , D511) );
L729: D515 tolerates ( ( D516 +* D517 ) +* D518 ) by CIRCCOMB:47;
L730: D516 tolerates ( D517 +* D518 ) by CIRCCOMB:47;
L731: ( InnerVertices ( D516 +* ( D517 +* D518 ) ) ) = ( ( InnerVertices D516 ) \/ ( InnerVertices ( D517 +* D518 ) ) ) by L730 , CIRCCOMB:11;
L732: D517 tolerates D518 by CIRCCOMB:47;
L733: ( InnerVertices ( D517 +* D518 ) ) = ( ( InnerVertices D517 ) \/ ( InnerVertices D518 ) ) by L732 , CIRCCOMB:11;
thus L734: ( InnerVertices ( GFA2CarryStr (C391 , C392 , C393) ) ) = ( InnerVertices ( ( D515 +* ( D516 +* D517 ) ) +* D518 ) ) by CIRCCOMB:6
.= ( InnerVertices ( D515 +* ( ( D516 +* D517 ) +* D518 ) ) ) by CIRCCOMB:6
.= ( ( InnerVertices D515 ) \/ ( InnerVertices ( ( D516 +* D517 ) +* D518 ) ) ) by L729 , CIRCCOMB:11
.= ( ( InnerVertices D515 ) \/ ( InnerVertices ( D516 +* ( D517 +* D518 ) ) ) ) by CIRCCOMB:6
.= ( ( ( InnerVertices D515 ) \/ ( InnerVertices D516 ) ) \/ ( ( InnerVertices D517 ) \/ ( InnerVertices D518 ) ) ) by L731 , L733 , XBOOLE_1:4
.= ( ( ( ( InnerVertices D515 ) \/ ( InnerVertices D516 ) ) \/ ( InnerVertices D517 ) ) \/ ( InnerVertices D518 ) ) by XBOOLE_1:4
.= ( ( ( { D512 } \/ ( InnerVertices D516 ) ) \/ ( InnerVertices D517 ) ) \/ ( InnerVertices D518 ) ) by CIRCCOMB:42
.= ( ( ( { D512 } \/ { D513 } ) \/ ( InnerVertices D517 ) ) \/ ( InnerVertices D518 ) ) by CIRCCOMB:42
.= ( ( ( { D512 } \/ { D513 } ) \/ { D514 } ) \/ ( InnerVertices D518 ) ) by CIRCCOMB:42
.= ( ( { D512 , D513 } \/ { D514 } ) \/ ( InnerVertices D518 ) ) by ENUMSET1:1
.= ( { D512 , D513 , D514 } \/ ( InnerVertices D518 ) ) by ENUMSET1:3
.= ( { D512 , D513 , D514 } \/ { ( GFA2CarryOutput (C391 , C392 , C393) ) } ) by CIRCCOMB:42;
end;
theorem
L735: (for B354 , B355 , B356 being set holds ( InnerVertices ( GFA2CarryStr (B354 , B355 , B356) ) ) is Relation)
proof
let C394 , C395 , C396 being set;
set D519 = ( and2a );
set D520 = ( and2c );
set D521 = ( and2b );
set D522 = ( nor3 );
set D523 = [ <* C394 , C395 *> , D519 ];
set D524 = [ <* C395 , C396 *> , D520 ];
set D525 = [ <* C396 , C394 *> , D521 ];
set D526 = ( 1GateCircStr (<* C394 , C395 *> , D519) );
set D527 = ( 1GateCircStr (<* C395 , C396 *> , D520) );
set D528 = ( 1GateCircStr (<* C396 , C394 *> , D521) );
set D529 = ( 1GateCircStr (<* D523 , D524 , D525 *> , D522) );
L736: (( InnerVertices D526 ) is Relation & ( InnerVertices D527 ) is Relation) by FACIRC_1:38;
L737: (( InnerVertices D528 ) is Relation & ( InnerVertices ( D526 +* D527 ) ) is Relation) by L736 , FACIRC_1:3 , FACIRC_1:38;
L738: (( InnerVertices D529 ) is Relation & ( InnerVertices ( GFA2CarryIStr (C394 , C395 , C396) ) ) is Relation) by L737 , FACIRC_1:3 , FACIRC_1:38;
thus L739: thesis by L738 , FACIRC_1:3;
end;
theorem
L740: (for B357 , B358 , B359 being set holds ((B357 <> [ <* B358 , B359 *> , ( and2c ) ] & B358 <> [ <* B359 , B357 *> , ( and2b ) ] & B359 <> [ <* B357 , B358 *> , ( and2a ) ]) implies ( InputVertices ( GFA2CarryIStr (B357 , B358 , B359) ) ) = { B357 , B358 , B359 }))
proof
let C397 , C398 , C399 being set;
set D530 = ( and2a );
set D531 = ( and2c );
set D532 = ( and2b );
set D533 = [ <* C397 , C398 *> , D530 ];
set D534 = [ <* C398 , C399 *> , D531 ];
set D535 = [ <* C399 , C397 *> , D532 ];
set D536 = ( 1GateCircStr (<* C397 , C398 *> , D530) );
set D537 = ( 1GateCircStr (<* C398 , C399 *> , D531) );
set D538 = ( 1GateCircStr (<* C399 , C397 *> , D532) );
assume that
L741: C397 <> D534
and
L742: (C398 <> D535 & C399 <> D533);
L743: (not D533 in { C398 , C399 }) by L741 , L742 , L70;
L744: (not D535 in { C397 , C398 , C399 }) by L741 , L742 , L70;
L745: C398 <> D534 by FACIRC_2:2;
L746: ((not C399 in { D533 , D534 }) & (not C397 in { D533 , D534 })) by L741 , L742 , L70;
L747: D536 tolerates D537 by CIRCCOMB:47;
L748: ( InputVertices ( GFA2CarryIStr (C397 , C398 , C399) ) ) = ( ( ( InputVertices ( D536 +* D537 ) ) \ ( InnerVertices D538 ) ) \/ ( ( InputVertices D538 ) \ ( InnerVertices ( D536 +* D537 ) ) ) ) by CIRCCMB2:5 , CIRCCOMB:47
.= ( ( ( ( ( InputVertices D536 ) \ ( InnerVertices D537 ) ) \/ ( ( InputVertices D537 ) \ ( InnerVertices D536 ) ) ) \ ( InnerVertices D538 ) ) \/ ( ( InputVertices D538 ) \ ( InnerVertices ( D536 +* D537 ) ) ) ) by CIRCCMB2:5 , CIRCCOMB:47
.= ( ( ( ( ( InputVertices D536 ) \ ( InnerVertices D537 ) ) \/ ( ( InputVertices D537 ) \ ( InnerVertices D536 ) ) ) \ ( InnerVertices D538 ) ) \/ ( ( InputVertices D538 ) \ ( ( InnerVertices D536 ) \/ ( InnerVertices D537 ) ) ) ) by L747 , CIRCCOMB:11
.= ( ( ( ( ( InputVertices D536 ) \ { D534 } ) \/ ( ( InputVertices D537 ) \ ( InnerVertices D536 ) ) ) \ ( InnerVertices D538 ) ) \/ ( ( InputVertices D538 ) \ ( ( InnerVertices D536 ) \/ ( InnerVertices D537 ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices D536 ) \ { D534 } ) \/ ( ( InputVertices D537 ) \ { D533 } ) ) \ ( InnerVertices D538 ) ) \/ ( ( InputVertices D538 ) \ ( ( InnerVertices D536 ) \/ ( InnerVertices D537 ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices D536 ) \ { D534 } ) \/ ( ( InputVertices D537 ) \ { D533 } ) ) \ { D535 } ) \/ ( ( InputVertices D538 ) \ ( ( InnerVertices D536 ) \/ ( InnerVertices D537 ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices D536 ) \ { D534 } ) \/ ( ( InputVertices D537 ) \ { D533 } ) ) \ { D535 } ) \/ ( ( InputVertices D538 ) \ ( { D533 } \/ ( InnerVertices D537 ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices D536 ) \ { D534 } ) \/ ( ( InputVertices D537 ) \ { D533 } ) ) \ { D535 } ) \/ ( ( InputVertices D538 ) \ ( { D533 } \/ { D534 } ) ) ) by CIRCCOMB:42
.= ( ( ( ( { C397 , C398 } \ { D534 } ) \/ ( ( InputVertices D537 ) \ { D533 } ) ) \ { D535 } ) \/ ( ( InputVertices D538 ) \ ( { D533 } \/ { D534 } ) ) ) by FACIRC_1:40
.= ( ( ( ( { C397 , C398 } \ { D534 } ) \/ ( { C398 , C399 } \ { D533 } ) ) \ { D535 } ) \/ ( ( InputVertices D538 ) \ ( { D533 } \/ { D534 } ) ) ) by FACIRC_1:40
.= ( ( ( ( { C397 , C398 } \ { D534 } ) \/ ( { C398 , C399 } \ { D533 } ) ) \ { D535 } ) \/ ( { C399 , C397 } \ ( { D533 } \/ { D534 } ) ) ) by FACIRC_1:40
.= ( ( ( ( { C397 , C398 } \ { D534 } ) \/ ( { C398 , C399 } \ { D533 } ) ) \ { D535 } ) \/ ( { C399 , C397 } \ { D533 , D534 } ) ) by ENUMSET1:1
.= ( ( ( { C397 , C398 } \/ ( { C398 , C399 } \ { D533 } ) ) \ { D535 } ) \/ ( { C399 , C397 } \ { D533 , D534 } ) ) by L741 , L745 , FACIRC_2:1
.= ( ( ( { C397 , C398 } \/ { C398 , C399 } ) \ { D535 } ) \/ ( { C399 , C397 } \ { D533 , D534 } ) ) by L743 , ZFMISC_1:57
.= ( ( ( { C397 , C398 } \/ { C398 , C399 } ) \ { D535 } ) \/ { C399 , C397 } ) by L746 , ZFMISC_1:63
.= ( ( { C397 , C398 , C398 , C399 } \ { D535 } ) \/ { C399 , C397 } ) by ENUMSET1:5
.= ( ( { C398 , C398 , C397 , C399 } \ { D535 } ) \/ { C399 , C397 } ) by ENUMSET1:67
.= ( ( { C398 , C397 , C399 } \ { D535 } ) \/ { C399 , C397 } ) by ENUMSET1:31
.= ( ( { C397 , C398 , C399 } \ { D535 } ) \/ { C399 , C397 } ) by ENUMSET1:58
.= ( { C397 , C398 , C399 } \/ { C399 , C397 } ) by L744 , ZFMISC_1:57
.= { C397 , C398 , C399 , C399 , C397 } by ENUMSET1:9
.= ( { C397 , C398 , C399 , C399 } \/ { C397 } ) by ENUMSET1:10
.= ( { C399 , C399 , C397 , C398 } \/ { C397 } ) by ENUMSET1:73
.= ( { C399 , C397 , C398 } \/ { C397 } ) by ENUMSET1:31
.= { C399 , C397 , C398 , C397 } by ENUMSET1:6
.= { C397 , C397 , C398 , C399 } by ENUMSET1:70
.= { C397 , C398 , C399 } by ENUMSET1:31;
thus L749: thesis by L748;
end;
theorem
L750: (for B360 , B361 , B362 being set holds ((B360 <> [ <* B361 , B362 *> , ( and2c ) ] & B361 <> [ <* B362 , B360 *> , ( and2b ) ] & B362 <> [ <* B360 , B361 *> , ( and2a ) ]) implies ( InputVertices ( GFA2CarryStr (B360 , B361 , B362) ) ) = { B360 , B361 , B362 }))
proof
let C400 , C401 , C402 being set;
set D539 = ( and2a );
set D540 = ( and2c );
set D541 = ( and2b );
set D542 = ( nor3 );
set D543 = [ <* C400 , C401 *> , D539 ];
set D544 = [ <* C401 , C402 *> , D540 ];
set D545 = [ <* C402 , C400 *> , D541 ];
set D546 = [ <* D543 , D544 , D545 *> , D542 ];
set D547 = ( 1GateCircStr (<* D543 , D544 , D545 *> , D542) );
set D548 = ( GFA2CarryIStr (C400 , C401 , C402) );
L751: ( InputVertices D547 ) = ( rng <* D543 , D544 , D545 *> ) by CIRCCOMB:42
.= { D543 , D544 , D545 } by FINSEQ_2:128;
assume L752: (C400 <> D544 & C401 <> D545 & C402 <> D543);
L753: (( InnerVertices D547 ) = { D546 } & ( { C400 , C401 , C402 } \ { D546 } ) = { C400 , C401 , C402 }) by L112 , CIRCCOMB:42;
L754: ( { D543 , D544 , D545 } \ { D543 , D544 , D545 } ) = ( {} ) by XBOOLE_1:37;
thus L755: ( InputVertices ( GFA2CarryStr (C400 , C401 , C402) ) ) = ( ( ( InputVertices D548 ) \ ( InnerVertices D547 ) ) \/ ( ( InputVertices D547 ) \ ( InnerVertices D548 ) ) ) by CIRCCMB2:5 , CIRCCOMB:47
.= ( { C400 , C401 , C402 } \/ ( { D543 , D544 , D545 } \ ( InnerVertices D548 ) ) ) by L751 , L752 , L753 , L740
.= ( { C400 , C401 , C402 } \/ ( {} ) ) by L754 , L723
.= { C400 , C401 , C402 };
end;
theorem
L756: (for B363 , B364 , B365 being non  pair set holds ( InputVertices ( GFA2CarryStr (B363 , B364 , B365) ) ) is  without_pairs)
proof
let C403 , C404 , C405 being non  pair set;
set D549 = ( and2a );
set D550 = ( and2c );
set D551 = ( and2b );
set D552 = ( nor3 );
set D553 = [ <* C403 , C404 *> , D549 ];
set D554 = [ <* C404 , C405 *> , D550 ];
set D555 = [ <* C405 , C403 *> , D551 ];
set D556 = ( 1GateCircStr (<* C403 , C404 *> , D549) );
set D557 = ( 1GateCircStr (<* C404 , C405 *> , D550) );
set D558 = ( 1GateCircStr (<* C405 , C403 *> , D551) );
set D559 = ( 1GateCircStr (<* D553 , D554 , D555 *> , D552) );
set D560 = ( GFA2CarryStr (C403 , C404 , C405) );
set D561 = ( GFA2CarryIStr (C403 , C404 , C405) );
given C406 being  pair set such that
L757: C406 in ( InputVertices D560 );

L758: D556 tolerates D557 by CIRCCOMB:47;
L759: (( InnerVertices D558 ) = { D555 } & ( D556 +* D557 ) tolerates D558) by CIRCCOMB:42 , CIRCCOMB:47;
L760: (( InnerVertices D556 ) = { D553 } & ( InnerVertices D557 ) = { D554 }) by CIRCCOMB:42;
L761: ( InnerVertices ( D556 +* D557 ) ) = ( { D553 } \/ { D554 } ) by L760 , L758 , CIRCCOMB:11;
L762: ( InnerVertices D561 ) = ( ( { D553 } \/ { D554 } ) \/ { D555 } ) by L761 , L759 , CIRCCOMB:11
.= ( { D553 , D554 } \/ { D555 } ) by ENUMSET1:1
.= { D553 , D554 , D555 } by ENUMSET1:3;
L763: ( InputVertices D559 ) = { D553 , D554 , D555 } by FACIRC_1:42;
L764: ( ( InputVertices D559 ) \ ( InnerVertices D561 ) ) = ( {} ) by L763 , L762 , XBOOLE_1:37;
L765: (( InputVertices D556 ) is  without_pairs & ( InputVertices D557 ) is  without_pairs) by FACIRC_1:41;
L766: (( InputVertices D558 ) is  without_pairs & ( InputVertices ( D556 +* D557 ) ) is  without_pairs) by L765 , FACIRC_1:9 , FACIRC_1:41;
L767: ( InputVertices D561 ) is  without_pairs by L766 , FACIRC_1:9;
L768: ( InnerVertices D559 ) is Relation by FACIRC_1:38;
L769: ( InputVertices D560 ) = ( ( InputVertices D561 ) \/ ( ( InputVertices D559 ) \ ( InnerVertices D561 ) ) ) by L768 , L767 , FACIRC_1:6;
thus L770: thesis by L769 , L767 , L757 , L764 , FACIRC_1:def 2;
end;
theorem
L771: (for B366 , B367 , B368 being set holds (B366 in (the carrier of ( GFA2CarryStr (B366 , B367 , B368) )) & B367 in (the carrier of ( GFA2CarryStr (B366 , B367 , B368) )) & B368 in (the carrier of ( GFA2CarryStr (B366 , B367 , B368) )) & [ <* B366 , B367 *> , ( and2a ) ] in (the carrier of ( GFA2CarryStr (B366 , B367 , B368) )) & [ <* B367 , B368 *> , ( and2c ) ] in (the carrier of ( GFA2CarryStr (B366 , B367 , B368) )) & [ <* B368 , B366 *> , ( and2b ) ] in (the carrier of ( GFA2CarryStr (B366 , B367 , B368) )) & [ <* [ <* B366 , B367 *> , ( and2a ) ] , [ <* B367 , B368 *> , ( and2c ) ] , [ <* B368 , B366 *> , ( and2b ) ] *> , ( nor3 ) ] in (the carrier of ( GFA2CarryStr (B366 , B367 , B368) ))))
proof
let C407 , C408 , C409 being set;
set D562 = ( and2a );
set D563 = ( and2c );
set D564 = ( and2b );
set D565 = ( nor3 );
set D566 = [ <* C407 , C408 *> , D562 ];
set D567 = [ <* C408 , C409 *> , D563 ];
set D568 = [ <* C409 , C407 *> , D564 ];
set D569 = [ <* D566 , D567 , D568 *> , D565 ];
set D570 = ( 1GateCircStr (<* C407 , C408 *> , D562) );
set D571 = ( 1GateCircStr (<* C408 , C409 *> , D563) );
set D572 = ( 1GateCircStr (<* C409 , C407 *> , D564) );
set D573 = ( 1GateCircStr (<* D566 , D567 , D568 *> , D565) );
set D574 = <* D566 , D567 , D568 *>;
L772: C409 in (the carrier of D572) by FACIRC_1:43;
L773: C409 in (the carrier of ( GFA2CarryIStr (C407 , C408 , C409) )) by L772 , FACIRC_1:20;
L774: D568 in (the carrier of D572) by FACIRC_1:43;
L775: D568 in (the carrier of ( GFA2CarryIStr (C407 , C408 , C409) )) by L774 , FACIRC_1:20;
L776: C408 in (the carrier of D570) by FACIRC_1:43;
L777: C408 in (the carrier of ( D570 +* D571 )) by L776 , FACIRC_1:20;
L778: C408 in (the carrier of ( GFA2CarryIStr (C407 , C408 , C409) )) by L777 , FACIRC_1:20;
L779: ((the carrier of D573) = ( ( rng D574 ) \/ { D569 } ) & [ D574 , D565 ] in { [ D574 , D565 ] }) by CIRCCOMB:def 6 , TARSKI:def 1;
L780: D569 in (the carrier of D573) by L779 , XBOOLE_0:def 3;
L781: D567 in (the carrier of D571) by FACIRC_1:43;
L782: D567 in (the carrier of ( D570 +* D571 )) by L781 , FACIRC_1:20;
L783: D567 in (the carrier of ( GFA2CarryIStr (C407 , C408 , C409) )) by L782 , FACIRC_1:20;
L784: D566 in (the carrier of D570) by FACIRC_1:43;
L785: D566 in (the carrier of ( D570 +* D571 )) by L784 , FACIRC_1:20;
L786: D566 in (the carrier of ( GFA2CarryIStr (C407 , C408 , C409) )) by L785 , FACIRC_1:20;
L787: C407 in (the carrier of D572) by FACIRC_1:43;
L788: C407 in (the carrier of ( GFA2CarryIStr (C407 , C408 , C409) )) by L787 , FACIRC_1:20;
thus L789: thesis by L788 , L778 , L773 , L786 , L783 , L775 , L780 , FACIRC_1:20;
end;
theorem
L790: (for B369 , B370 , B371 being set holds ([ <* B369 , B370 *> , ( and2a ) ] in ( InnerVertices ( GFA2CarryStr (B369 , B370 , B371) ) ) & [ <* B370 , B371 *> , ( and2c ) ] in ( InnerVertices ( GFA2CarryStr (B369 , B370 , B371) ) ) & [ <* B371 , B369 *> , ( and2b ) ] in ( InnerVertices ( GFA2CarryStr (B369 , B370 , B371) ) ) & ( GFA2CarryOutput (B369 , B370 , B371) ) in ( InnerVertices ( GFA2CarryStr (B369 , B370 , B371) ) )))
proof
let C410 , C411 , C412 being set;
set D575 = ( and2a );
set D576 = ( and2c );
set D577 = ( and2b );
set D578 = [ <* C410 , C411 *> , D575 ];
set D579 = [ <* C411 , C412 *> , D576 ];
set D580 = [ <* C412 , C410 *> , D577 ];
L791: ( InnerVertices ( GFA2CarryStr (C410 , C411 , C412) ) ) = ( { D578 , D579 , D580 } \/ { ( GFA2CarryOutput (C410 , C411 , C412) ) } ) by L728
.= { D578 , D579 , D580 , ( GFA2CarryOutput (C410 , C411 , C412) ) } by ENUMSET1:6;
thus L792: thesis by L791 , ENUMSET1:def 2;
end;
theorem
L793: (for B372 , B373 , B374 being set holds ((B372 <> [ <* B373 , B374 *> , ( and2c ) ] & B373 <> [ <* B374 , B372 *> , ( and2b ) ] & B374 <> [ <* B372 , B373 *> , ( and2a ) ]) implies (B372 in ( InputVertices ( GFA2CarryStr (B372 , B373 , B374) ) ) & B373 in ( InputVertices ( GFA2CarryStr (B372 , B373 , B374) ) ) & B374 in ( InputVertices ( GFA2CarryStr (B372 , B373 , B374) ) ))))
proof
set D581 = ( and2a );
set D582 = ( and2c );
set D583 = ( and2b );
let C413 , C414 , C415 being set;
assume L794: (C413 <> [ <* C414 , C415 *> , D582 ] & C414 <> [ <* C415 , C413 *> , D583 ] & C415 <> [ <* C413 , C414 *> , D581 ]);
L795: ( InputVertices ( GFA2CarryStr (C413 , C414 , C415) ) ) = { C413 , C414 , C415 } by L794 , L750;
thus L796: thesis by L795 , ENUMSET1:def 1;
end;
theorem
L797: (for B375 , B376 , B377 being non  pair set holds ( InputVertices ( GFA2CarryStr (B375 , B376 , B377) ) ) = { B375 , B376 , B377 })
proof
let C416 , C417 , C418 being non  pair set;
set D584 = ( and2a );
set D585 = ( and2c );
set D586 = ( and2b );
set D587 = ( nor3 );
set D588 = [ <* C416 , C417 *> , D584 ];
set D589 = [ <* C417 , C418 *> , D585 ];
set D590 = [ <* C418 , C416 *> , D586 ];
set D591 = ( 1GateCircStr (<* C416 , C417 *> , D584) );
set D592 = ( 1GateCircStr (<* C417 , C418 *> , D585) );
set D593 = ( 1GateCircStr (<* C418 , C416 *> , D586) );
set D594 = ( GFA2CarryStr (C416 , C417 , C418) );
set D595 = ( GFA2CarryIStr (C416 , C417 , C418) );
set D596 = ( 1GateCircStr (<* D588 , D589 , D590 *> , D587) );
L798: (( InputVertices D591 ) = { C416 , C417 } & ( InputVertices D592 ) = { C417 , C418 }) by FACIRC_1:40;
L799: ( InputVertices D593 ) = { C418 , C416 } by FACIRC_1:40;
L800: ( InputVertices D596 ) = { D588 , D589 , D590 } by FACIRC_1:42;
L801: ( InnerVertices D596 ) is Relation by FACIRC_1:38;
L802: (( InnerVertices D591 ) = { D588 } & ( InnerVertices D592 ) = { D589 }) by CIRCCOMB:42;
L803: D591 tolerates D592 by CIRCCOMB:47;
L804: (( InnerVertices D593 ) = { D590 } & ( InnerVertices ( D591 +* D592 ) ) = ( { D588 } \/ { D589 } )) by L803 , L802 , CIRCCOMB:11 , CIRCCOMB:42;
L805: ( D591 +* D592 ) tolerates D593 by CIRCCOMB:47;
L806: ( InnerVertices D595 ) = ( ( { D588 } \/ { D589 } ) \/ { D590 } ) by L805 , L804 , CIRCCOMB:11
.= ( { D588 , D589 } \/ { D590 } ) by ENUMSET1:1
.= { D588 , D589 , D590 } by ENUMSET1:3;
L807: ( ( InputVertices D596 ) \ ( InnerVertices D595 ) ) = ( {} ) by L806 , L800 , XBOOLE_1:37;
L808: (( InputVertices D591 ) is  without_pairs & ( InputVertices D592 ) is  without_pairs) by FACIRC_1:41;
L809: (( InputVertices D593 ) is  without_pairs & ( InputVertices ( D591 +* D592 ) ) is  without_pairs) by L808 , FACIRC_1:9 , FACIRC_1:41;
L810: ( InputVertices D595 ) is  without_pairs by L809 , FACIRC_1:9;
L811: ( InputVertices D594 ) = ( ( InputVertices D595 ) \/ ( ( InputVertices D596 ) \ ( InnerVertices D595 ) ) ) by L810 , L801 , FACIRC_1:6;
thus L812: ( InputVertices D594 ) = ( ( InputVertices ( D591 +* D592 ) ) \/ ( InputVertices D593 ) ) by L811 , L809 , L804 , L807 , FACIRC_1:7
.= ( ( ( InputVertices D591 ) \/ ( InputVertices D592 ) ) \/ ( InputVertices D593 ) ) by L808 , L802 , FACIRC_1:7
.= ( { C416 , C417 , C417 , C418 } \/ { C418 , C416 } ) by L798 , L799 , ENUMSET1:5
.= ( { C417 , C417 , C416 , C418 } \/ { C418 , C416 } ) by ENUMSET1:67
.= ( { C417 , C416 , C418 } \/ { C418 , C416 } ) by ENUMSET1:31
.= ( { C416 , C417 , C418 } \/ { C418 , C416 } ) by ENUMSET1:58
.= ( { C416 , C417 , C418 } \/ ( { C418 } \/ { C416 } ) ) by ENUMSET1:1
.= ( ( { C416 , C417 , C418 } \/ { C418 } ) \/ { C416 } ) by XBOOLE_1:4
.= ( ( { C418 , C416 , C417 } \/ { C418 } ) \/ { C416 } ) by ENUMSET1:59
.= ( { C418 , C418 , C416 , C417 } \/ { C416 } ) by ENUMSET1:4
.= ( { C418 , C416 , C417 } \/ { C416 } ) by ENUMSET1:31
.= ( { C416 , C417 , C418 } \/ { C416 } ) by ENUMSET1:59
.= { C416 , C416 , C417 , C418 } by ENUMSET1:4
.= { C416 , C417 , C418 } by ENUMSET1:31;
end;
theorem
L813: (for B378 , B379 , B380 being set holds (for B381 being (State of ( GFA2CarryCirc (B378 , B379 , B380) )) holds (for B382 , B383 , B384 being (Element of ( BOOLEAN )) holds ((B382 = ( B381 . B378 ) & B383 = ( B381 . B379 ) & B384 = ( B381 . B380 )) implies (( ( Following B381 ) . [ <* B378 , B379 *> , ( and2a ) ] ) = ( ( 'not' B382 ) '&' B383 ) & ( ( Following B381 ) . [ <* B379 , B380 *> , ( and2c ) ] ) = ( B383 '&' ( 'not' B384 ) ) & ( ( Following B381 ) . [ <* B380 , B378 *> , ( and2b ) ] ) = ( ( 'not' B384 ) '&' ( 'not' B382 ) ))))))
proof
let C419 , C420 , C421 being set;
set D597 = ( and2a );
set D598 = ( and2c );
set D599 = ( and2b );
let C422 being (State of ( GFA2CarryCirc (C419 , C420 , C421) ));
set D600 = [ <* C419 , C420 *> , D597 ];
set D601 = [ <* C420 , C421 *> , D598 ];
set D602 = [ <* C421 , C419 *> , D599 ];
let C423 , C424 , C425 being (Element of ( BOOLEAN ));
assume that
L814: C423 = ( C422 . C419 )
and
L815: C424 = ( C422 . C420 )
and
L816: C425 = ( C422 . C421 );
set D603 = ( GFA2CarryStr (C419 , C420 , C421) );
L817: ( InnerVertices D603 ) = (the carrier' of D603) by FACIRC_1:37;
L818: C420 in (the carrier of D603) by L771;
L819: C419 in (the carrier of D603) by L771;
L820: ( dom C422 ) = (the carrier of D603) by CIRCUIT1:3;
L821: D600 in ( InnerVertices ( GFA2CarryStr (C419 , C420 , C421) ) ) by L790;
thus L822: ( ( Following C422 ) . [ <* C419 , C420 *> , D597 ] ) = ( D597 . ( C422 * <* C419 , C420 *> ) ) by L821 , L817 , FACIRC_1:35
.= ( D597 . <* C423 , C424 *> ) by L814 , L815 , L820 , L819 , L818 , FINSEQ_2:125
.= ( ( 'not' C423 ) '&' C424 ) by TWOSCOMP:def 2;
L823: C421 in (the carrier of D603) by L771;
L824: D601 in ( InnerVertices ( GFA2CarryStr (C419 , C420 , C421) ) ) by L790;
thus L825: ( ( Following C422 ) . [ <* C420 , C421 *> , D598 ] ) = ( D598 . ( C422 * <* C420 , C421 *> ) ) by L824 , L817 , FACIRC_1:35
.= ( D598 . <* C424 , C425 *> ) by L815 , L816 , L820 , L818 , L823 , FINSEQ_2:125
.= ( C424 '&' ( 'not' C425 ) ) by L36;
L826: D602 in ( InnerVertices ( GFA2CarryStr (C419 , C420 , C421) ) ) by L790;
thus L827: ( ( Following C422 ) . [ <* C421 , C419 *> , D599 ] ) = ( D599 . ( C422 * <* C421 , C419 *> ) ) by L826 , L817 , FACIRC_1:35
.= ( D599 . <* C425 , C423 *> ) by L814 , L816 , L820 , L819 , L823 , FINSEQ_2:125
.= ( ( 'not' C425 ) '&' ( 'not' C423 ) ) by TWOSCOMP:def 3;
end;
theorem
L828: (for B385 , B386 , B387 being set holds (for B388 being (State of ( GFA2CarryCirc (B385 , B386 , B387) )) holds (for B389 , B390 , B391 being (Element of ( BOOLEAN )) holds ((B389 = ( B388 . [ <* B385 , B386 *> , ( and2a ) ] ) & B390 = ( B388 . [ <* B386 , B387 *> , ( and2c ) ] ) & B391 = ( B388 . [ <* B387 , B385 *> , ( and2b ) ] )) implies ( ( Following B388 ) . ( GFA2CarryOutput (B385 , B386 , B387) ) ) = ( 'not' ( ( B389 'or' B390 ) 'or' B391 ) )))))
proof
let C426 , C427 , C428 being set;
set D604 = ( and2a );
set D605 = ( and2c );
set D606 = ( and2b );
set D607 = ( nor3 );
let C429 being (State of ( GFA2CarryCirc (C426 , C427 , C428) ));
set D608 = [ <* C426 , C427 *> , D604 ];
set D609 = [ <* C427 , C428 *> , D605 ];
set D610 = [ <* C428 , C426 *> , D606 ];
let C430 , C431 , C432 being (Element of ( BOOLEAN ));
assume that
L829: (C430 = ( C429 . D608 ) & C431 = ( C429 . D609 ) & C432 = ( C429 . D610 ));
set D611 = ( GFA2CarryStr (C426 , C427 , C428) );
reconsider D612 = D608 , D613 = D609 , D614 = D610 as (Element of ( InnerVertices D611 )) by L790;
L830: ( dom C429 ) = (the carrier of D611) by CIRCUIT1:3;
L831: ( InnerVertices D611 ) = (the carrier' of D611) by FACIRC_1:37;
thus L832: ( ( Following C429 ) . ( GFA2CarryOutput (C426 , C427 , C428) ) ) = ( D607 . ( C429 * <* D612 , D613 , D614 *> ) ) by L831 , FACIRC_1:35
.= ( D607 . <* C430 , C431 , C432 *> ) by L829 , L830 , FINSEQ_2:126
.= ( 'not' ( ( C430 'or' C431 ) 'or' C432 ) ) by TWOSCOMP:def 28;
end;
theorem
L833: (for B392 , B393 , B394 being set holds ((B392 <> [ <* B393 , B394 *> , ( and2c ) ] & B393 <> [ <* B394 , B392 *> , ( and2b ) ] & B394 <> [ <* B392 , B393 *> , ( and2a ) ]) implies (for B395 being (State of ( GFA2CarryCirc (B392 , B393 , B394) )) holds (for B396 , B397 , B398 being (Element of ( BOOLEAN )) holds ((B396 = ( B395 . B392 ) & B397 = ( B395 . B393 ) & B398 = ( B395 . B394 )) implies (( ( Following (B395 , 2) ) . ( GFA2CarryOutput (B392 , B393 , B394) ) ) = ( 'not' ( ( ( ( 'not' B396 ) '&' B397 ) 'or' ( B397 '&' ( 'not' B398 ) ) ) 'or' ( ( 'not' B398 ) '&' ( 'not' B396 ) ) ) ) & ( ( Following (B395 , 2) ) . [ <* B392 , B393 *> , ( and2a ) ] ) = ( ( 'not' B396 ) '&' B397 ) & ( ( Following (B395 , 2) ) . [ <* B393 , B394 *> , ( and2c ) ] ) = ( B397 '&' ( 'not' B398 ) ) & ( ( Following (B395 , 2) ) . [ <* B394 , B392 *> , ( and2b ) ] ) = ( ( 'not' B398 ) '&' ( 'not' B396 ) )))))))
proof
set D615 = ( and2a );
set D616 = ( and2c );
set D617 = ( and2b );
let C433 , C434 , C435 being set;
assume that
L834: (C433 <> [ <* C434 , C435 *> , D616 ] & C434 <> [ <* C435 , C433 *> , D617 ] & C435 <> [ <* C433 , C434 *> , D615 ]);
set D618 = ( GFA2CarryStr (C433 , C434 , C435) );
reconsider D619 = C433 , D620 = C434 , D621 = C435 as (Vertex of D618) by L771;
let C436 being (State of ( GFA2CarryCirc (C433 , C434 , C435) ));
L835: C434 in ( InputVertices D618 ) by L834 , L793;
L836: ( ( Following C436 ) . D620 ) = ( C436 . C434 ) by L835 , CIRCUIT2:def 5;
L837: C435 in ( InputVertices D618 ) by L834 , L793;
L838: ( ( Following C436 ) . D621 ) = ( C436 . C435 ) by L837 , CIRCUIT2:def 5;
set D622 = [ <* C433 , C434 *> , D615 ];
set D623 = [ <* C434 , C435 *> , D616 ];
set D624 = [ <* C435 , C433 *> , D617 ];
L839: ( Following (C436 , 2) ) = ( Following ( Following C436 ) ) by FACIRC_1:15;
let C437 , C438 , C439 being (Element of ( BOOLEAN ));
assume that
L840: (C437 = ( C436 . C433 ) & C438 = ( C436 . C434 ) & C439 = ( C436 . C435 ));
L841: ( ( Following C436 ) . D624 ) = ( ( 'not' C439 ) '&' ( 'not' C437 ) ) by L840 , L813;
L842: (( ( Following C436 ) . D622 ) = ( ( 'not' C437 ) '&' C438 ) & ( ( Following C436 ) . D623 ) = ( C438 '&' ( 'not' C439 ) )) by L840 , L813;
thus L843: ( ( Following (C436 , 2) ) . ( GFA2CarryOutput (C433 , C434 , C435) ) ) = ( 'not' ( ( ( ( 'not' C437 ) '&' C438 ) 'or' ( C438 '&' ( 'not' C439 ) ) ) 'or' ( ( 'not' C439 ) '&' ( 'not' C437 ) ) ) ) by L842 , L839 , L841 , L828;
L844: C433 in ( InputVertices D618 ) by L834 , L793;
L845: ( ( Following C436 ) . D619 ) = ( C436 . C433 ) by L844 , CIRCUIT2:def 5;
thus L846: thesis by L845 , L840 , L836 , L838 , L839 , L813;
end;
theorem
L847: (for B399 , B400 , B401 being set holds ((B399 <> [ <* B400 , B401 *> , ( and2c ) ] & B400 <> [ <* B401 , B399 *> , ( and2b ) ] & B401 <> [ <* B399 , B400 *> , ( and2a ) ]) implies (for B402 being (State of ( GFA2CarryCirc (B399 , B400 , B401) )) holds ( Following (B402 , 2) ) is  stable)))
proof
set D625 = ( and2a );
set D626 = ( and2c );
set D627 = ( and2b );
let C440 , C441 , C442 being set;
assume that
L848: (C440 <> [ <* C441 , C442 *> , D626 ] & C441 <> [ <* C442 , C440 *> , D627 ] & C442 <> [ <* C440 , C441 *> , D625 ]);
set D628 = ( GFA2CarryStr (C440 , C441 , C442) );
reconsider D629 = C440 , D630 = C441 , D631 = C442 as (Vertex of D628) by L771;
let C443 being (State of ( GFA2CarryCirc (C440 , C441 , C442) ));
set D632 = ( C443 . D629 );
set D633 = ( C443 . D630 );
set D634 = ( C443 . D631 );
set D635 = ( Following (C443 , 2) );
set D636 = ( Following D635 );
set D637 = [ <* C440 , C441 *> , D625 ];
set D638 = [ <* C441 , C442 *> , D626 ];
set D639 = [ <* C442 , C440 *> , D627 ];
L849: D635 = ( Following ( Following C443 ) ) by FACIRC_1:15;
L850: C442 in ( InputVertices D628 ) by L848 , L793;
L851: ( ( Following C443 ) . C442 ) = D634 by L850 , CIRCUIT2:def 5;
L852: ( D635 . C442 ) = D634 by L851 , L849 , L850 , CIRCUIT2:def 5;
L853: C441 in ( InputVertices D628 ) by L848 , L793;
L854: ( ( Following C443 ) . C441 ) = D633 by L853 , CIRCUIT2:def 5;
L855: ( D635 . C441 ) = D633 by L854 , L849 , L853 , CIRCUIT2:def 5;
L856: C440 in ( InputVertices D628 ) by L848 , L793;
L857: ( ( Following C443 ) . C440 ) = D632 by L856 , CIRCUIT2:def 5;
L858: ( D635 . C440 ) = D632 by L857 , L849 , L856 , CIRCUIT2:def 5;
L859: D634 = ( C443 . C442 );
L860: ( D635 . D637 ) = ( ( 'not' D632 ) '&' D633 ) by L859 , L848 , L833;
L861: D633 = ( C443 . C441 );
L862: ( D635 . D639 ) = ( ( 'not' D632 ) '&' ( 'not' D634 ) ) by L861 , L848 , L833;
L863: D632 = ( C443 . C440 );
L864: ( D635 . D638 ) = ( D633 '&' ( 'not' D634 ) ) by L863 , L848 , L833;
L865: ( D635 . ( GFA2CarryOutput (C440 , C441 , C442) ) ) = ( 'not' ( ( ( ( 'not' D632 ) '&' D633 ) 'or' ( D633 '&' ( 'not' D634 ) ) ) 'or' ( ( 'not' D634 ) '&' ( 'not' D632 ) ) ) ) by L848 , L833;
L866:
now
let C444 being set;
assume L867: C444 in (the carrier of D628);
reconsider D640 = C444 as (Vertex of D628) by L867;
L868: D640 in ( ( InputVertices D628 ) \/ ( InnerVertices D628 ) ) by L867 , XBOOLE_1:45;
thus L869: ( D635 . C444 ) = ( D636 . C444 )
proof
per cases  by L868 , XBOOLE_0:def 3;
suppose L870: D640 in ( InputVertices D628 );

thus L871: thesis by L870 , CIRCUIT2:def 5;
end;
suppose L872: D640 in ( InnerVertices D628 );

L873: D640 in ( { D637 , D638 , D639 } \/ { ( GFA2CarryOutput (C440 , C441 , C442) ) } ) by L872 , L728;
L874: (D640 in { D637 , D638 , D639 } or D640 in { ( GFA2CarryOutput (C440 , C441 , C442) ) }) by L873 , XBOOLE_0:def 3;
L875: (D640 = D637 or D640 = D638 or D640 = D639 or D640 = ( GFA2CarryOutput (C440 , C441 , C442) )) by L874 , ENUMSET1:def 1 , TARSKI:def 1;
thus L876: thesis by L875 , L865 , L860 , L864 , L862 , L858 , L855 , L852 , L813 , L828;
end;
end;

end;
L870: (( dom ( Following ( Following (C443 , 2) ) ) ) = (the carrier of D628) & ( dom ( Following (C443 , 2) ) ) = (the carrier of D628)) by CIRCUIT1:3;
thus L871: D635 = D636 by L870 , L866 , FUNCT_1:2;
end;
definition
let C445 , C446 , C447 being set;
func GFA2AdderStr (C445 , C446 , C447) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( 2GatesCircStr (C445 , C446 , C447 , ( xor2c )) );
coherence;
end;
definition
let C448 , C449 , C450 being set;
func GFA2AdderCirc (C448 , C449 , C450) ->  strict  Boolean  gate`2=den (Circuit of ( GFA2AdderStr (C448 , C449 , C450) )) equals 
( 2GatesCircuit (C448 , C449 , C450 , ( xor2c )) );
coherence;
end;
definition
let C451 , C452 , C453 being set;
func GFA2AdderOutput (C451 , C452 , C453) -> (Element of ( InnerVertices ( GFA2AdderStr (C451 , C452 , C453) ) )) equals 
( 2GatesCircOutput (C451 , C452 , C453 , ( xor2c )) );
coherence;
end;
theorem
L875: (for B403 , B404 , B405 being set holds ( InnerVertices ( GFA2AdderStr (B403 , B404 , B405) ) ) = ( { [ <* B403 , B404 *> , ( xor2c ) ] } \/ { ( GFA2AdderOutput (B403 , B404 , B405) ) } ))
proof
let C454 , C455 , C456 being set;
L876: ( GFA2AdderOutput (C454 , C455 , C456) ) = ( GFA1AdderOutput (C454 , C455 , C456) );
thus L877: thesis by L876 , L594;
end;
theorem
L878: (for B406 , B407 , B408 being set holds (B406 in (the carrier of ( GFA2AdderStr (B406 , B407 , B408) )) & B407 in (the carrier of ( GFA2AdderStr (B406 , B407 , B408) )) & B408 in (the carrier of ( GFA2AdderStr (B406 , B407 , B408) )) & [ <* B406 , B407 *> , ( xor2c ) ] in (the carrier of ( GFA2AdderStr (B406 , B407 , B408) )) & [ <* [ <* B406 , B407 *> , ( xor2c ) ] , B408 *> , ( xor2c ) ] in (the carrier of ( GFA2AdderStr (B406 , B407 , B408) )))) by FACIRC_1:60 , FACIRC_1:61;
theorem
L879: (for B409 , B410 , B411 being set holds ([ <* B409 , B410 *> , ( xor2c ) ] in ( InnerVertices ( GFA2AdderStr (B409 , B410 , B411) ) ) & ( GFA2AdderOutput (B409 , B410 , B411) ) in ( InnerVertices ( GFA2AdderStr (B409 , B410 , B411) ) )))
proof
let C457 , C458 , C459 being set;
set D641 = ( GFA1AdderStr (C457 , C458 , C459) );
L880: ( GFA2AdderStr (C457 , C458 , C459) ) = D641;
thus L881: thesis by L880 , L597;
end;
theorem
L882: (for B412 , B413 , B414 being set holds (B414 <> [ <* B412 , B413 *> , ( xor2c ) ] implies (B412 in ( InputVertices ( GFA2AdderStr (B412 , B413 , B414) ) ) & B413 in ( InputVertices ( GFA2AdderStr (B412 , B413 , B414) ) ) & B414 in ( InputVertices ( GFA2AdderStr (B412 , B413 , B414) ) ))))
proof
set D642 = ( xor2c );
let C460 , C461 , C462 being set;
assume that
L883: C462 <> [ <* C460 , C461 *> , D642 ];
set D643 = ( GFA1AdderStr (C460 , C461 , C462) );
L884: ( GFA2AdderStr (C460 , C461 , C462) ) = D643;
thus L885: thesis by L884 , L883 , L600;
end;
theorem
L886: (for B415 , B416 , B417 being set holds (B417 <> [ <* B415 , B416 *> , ( xor2c ) ] implies (for B418 being (State of ( GFA2AdderCirc (B415 , B416 , B417) )) holds (for B419 , B420 , B421 being (Element of ( BOOLEAN )) holds ((B419 = ( B418 . B415 ) & B420 = ( B418 . B416 ) & B421 = ( B418 . B417 )) implies (( ( Following B418 ) . [ <* B415 , B416 *> , ( xor2c ) ] ) = ( B419 'xor' ( 'not' B420 ) ) & ( ( Following B418 ) . B415 ) = B419 & ( ( Following B418 ) . B416 ) = B420 & ( ( Following B418 ) . B417 ) = B421))))))
proof
set D644 = ( xor2c );
let C463 , C464 , C465 being set;
assume that
L887: C465 <> [ <* C463 , C464 *> , D644 ];
set D645 = ( GFA1AdderCirc (C463 , C464 , C465) );
L888: ( GFA2AdderCirc (C463 , C464 , C465) ) = D645;
thus L889: thesis by L888 , L887 , L604;
end;
theorem
L890: (for B422 , B423 , B424 being set holds (B424 <> [ <* B422 , B423 *> , ( xor2c ) ] implies (for B425 being (State of ( GFA2AdderCirc (B422 , B423 , B424) )) holds (for B426 , B427 , B428 , B429 being (Element of ( BOOLEAN )) holds ((B426 = ( B425 . [ <* B422 , B423 *> , ( xor2c ) ] ) & B427 = ( B425 . B422 ) & B428 = ( B425 . B423 ) & B429 = ( B425 . B424 )) implies ( ( Following B425 ) . ( GFA2AdderOutput (B422 , B423 , B424) ) ) = ( B426 'xor' ( 'not' B429 ) ))))))
proof
set D646 = ( xor2c );
let C466 , C467 , C468 being set;
assume that
L891: C468 <> [ <* C466 , C467 *> , D646 ];
set D647 = ( GFA1AdderOutput (C466 , C467 , C468) );
set D648 = ( GFA2AdderOutput (C466 , C467 , C468) );
set D649 = ( GFA1AdderCirc (C466 , C467 , C468) );
set D650 = ( GFA2AdderCirc (C466 , C467 , C468) );
L892: (D650 = D649 & D648 = D647);
thus L893: thesis by L892 , L891 , L611;
end;
theorem
L894: (for B430 , B431 , B432 being set holds (B432 <> [ <* B430 , B431 *> , ( xor2c ) ] implies (for B433 being (State of ( GFA2AdderCirc (B430 , B431 , B432) )) holds (for B434 , B435 , B436 being (Element of ( BOOLEAN )) holds ((B434 = ( B433 . B430 ) & B435 = ( B433 . B431 ) & B436 = ( B433 . B432 )) implies (( ( Following (B433 , 2) ) . ( GFA2AdderOutput (B430 , B431 , B432) ) ) = ( ( B434 'xor' ( 'not' B435 ) ) 'xor' ( 'not' B436 ) ) & ( ( Following (B433 , 2) ) . [ <* B430 , B431 *> , ( xor2c ) ] ) = ( B434 'xor' ( 'not' B435 ) ) & ( ( Following (B433 , 2) ) . B430 ) = B434 & ( ( Following (B433 , 2) ) . B431 ) = B435 & ( ( Following (B433 , 2) ) . B432 ) = B436))))))
proof
set D651 = ( xor2c );
let C469 , C470 , C471 being set;
assume that
L895: C471 <> [ <* C469 , C470 *> , D651 ];
set D652 = ( GFA1AdderOutput (C469 , C470 , C471) );
set D653 = ( GFA2AdderOutput (C469 , C470 , C471) );
set D654 = ( GFA1AdderCirc (C469 , C470 , C471) );
set D655 = ( GFA2AdderCirc (C469 , C470 , C471) );
L896: (D655 = D654 & D653 = D652);
thus L897: thesis by L896 , L895 , L615;
end;
theorem
L898: (for B437 , B438 , B439 being set holds (B439 <> [ <* B437 , B438 *> , ( xor2c ) ] implies (for B440 being (State of ( GFA2AdderCirc (B437 , B438 , B439) )) holds (for B441 , B442 , B443 being (Element of ( BOOLEAN )) holds ((B441 = ( B440 . B437 ) & B442 = ( B440 . B438 ) & B443 = ( B440 . B439 )) implies ( ( Following (B440 , 2) ) . ( GFA2AdderOutput (B437 , B438 , B439) ) ) = ( ( ( 'not' B441 ) 'xor' B442 ) 'xor' ( 'not' B443 ) ))))))
proof
set D656 = ( xor2c );
let C472 , C473 , C474 being set;
assume that
L899: C474 <> [ <* C472 , C473 *> , D656 ];
set D657 = ( GFA2AdderCirc (C472 , C473 , C474) );
let C475 being (State of D657);
let C476 , C477 , C478 being (Element of ( BOOLEAN ));
assume L900: (C476 = ( C475 . C472 ) & C477 = ( C475 . C473 ) & C478 = ( C475 . C474 ));
thus L901: ( ( Following (C475 , 2) ) . ( GFA2AdderOutput (C472 , C473 , C474) ) ) = ( ( C476 'xor' ( 'not' C477 ) ) 'xor' ( 'not' C478 ) ) by L900 , L899 , L894
.= ( ( ( 'not' C476 ) 'xor' C477 ) 'xor' ( 'not' C478 ) );
end;
definition
let C479 , C480 , C481 being set;
func BitGFA2Str (C479 , C480 , C481) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( GFA2AdderStr (C479 , C480 , C481) ) +* ( GFA2CarryStr (C479 , C480 , C481) ) );
coherence;
end;
definition
let C482 , C483 , C484 being set;
func BitGFA2Circ (C482 , C483 , C484) ->  strict  Boolean  gate`2=den (Circuit of ( BitGFA2Str (C482 , C483 , C484) )) equals 
( ( GFA2AdderCirc (C482 , C483 , C484) ) +* ( GFA2CarryCirc (C482 , C483 , C484) ) );
coherence;
end;
theorem
L904: (for B444 , B445 , B446 being set holds ( InnerVertices ( BitGFA2Str (B444 , B445 , B446) ) ) = ( ( ( { [ <* B444 , B445 *> , ( xor2c ) ] } \/ { ( GFA2AdderOutput (B444 , B445 , B446) ) } ) \/ { [ <* B444 , B445 *> , ( and2a ) ] , [ <* B445 , B446 *> , ( and2c ) ] , [ <* B446 , B444 *> , ( and2b ) ] } ) \/ { ( GFA2CarryOutput (B444 , B445 , B446) ) } ))
proof
let C485 , C486 , C487 being set;
set D658 = ( and2a );
set D659 = ( and2c );
set D660 = ( and2b );
set D661 = ( xor2c );
set D662 = [ <* C485 , C486 *> , D661 ];
set D663 = [ <* C485 , C486 *> , D658 ];
set D664 = [ <* C486 , C487 *> , D659 ];
set D665 = [ <* C487 , C485 *> , D660 ];
set D666 = ( BitGFA2Str (C485 , C486 , C487) );
set D667 = ( GFA2AdderStr (C485 , C486 , C487) );
set D668 = ( GFA2CarryStr (C485 , C486 , C487) );
set D669 = ( GFA2AdderOutput (C485 , C486 , C487) );
set D670 = ( GFA2CarryOutput (C485 , C486 , C487) );
thus L905: ( InnerVertices D666 ) = ( ( InnerVertices D667 ) \/ ( InnerVertices D668 ) ) by FACIRC_1:27
.= ( ( { D662 } \/ { D669 } ) \/ ( InnerVertices D668 ) ) by L875
.= ( ( { D662 } \/ { D669 } ) \/ ( { D663 , D664 , D665 } \/ { D670 } ) ) by L728
.= ( ( ( { D662 } \/ { D669 } ) \/ { D663 , D664 , D665 } ) \/ { D670 } ) by XBOOLE_1:4;
end;
theorem
L906: (for B447 , B448 , B449 being set holds ( InnerVertices ( BitGFA2Str (B447 , B448 , B449) ) ) is Relation)
proof
let C488 , C489 , C490 being set;
set D671 = ( GFA2AdderStr (C488 , C489 , C490) );
set D672 = ( GFA2CarryStr (C488 , C489 , C490) );
L907: (( InnerVertices D671 ) is Relation & ( InnerVertices D672 ) is Relation) by L735 , FACIRC_1:58;
thus L908: thesis by L907 , FACIRC_1:3;
end;
theorem
L909: (for B450 , B451 , B452 being set holds ((B452 <> [ <* B450 , B451 *> , ( xor2c ) ] & B450 <> [ <* B451 , B452 *> , ( and2c ) ] & B451 <> [ <* B452 , B450 *> , ( and2b ) ] & B452 <> [ <* B450 , B451 *> , ( and2a ) ]) implies ( InputVertices ( BitGFA2Str (B450 , B451 , B452) ) ) = { B450 , B451 , B452 }))
proof
set D673 = ( and2a );
set D674 = ( and2c );
set D675 = ( and2b );
set D676 = ( xor2c );
let C491 , C492 , C493 being set;
assume that
L910: (C493 <> [ <* C491 , C492 *> , D676 ] & C491 <> [ <* C492 , C493 *> , D674 ] & C492 <> [ <* C493 , C491 *> , D675 ] & C493 <> [ <* C491 , C492 *> , D673 ]);
set D677 = ( GFA2CarryStr (C491 , C492 , C493) );
set D678 = ( GFA2AdderStr (C491 , C492 , C493) );
L911: (( InputVertices D678 ) = { C491 , C492 , C493 } & ( InputVertices D677 ) = { C491 , C492 , C493 }) by L910 , L750 , FACIRC_1:57;
thus L912: thesis by L911 , CIRCCOMB:47 , FACIRC_2:21;
end;
theorem
L913: (for B453 , B454 , B455 being non  pair set holds ( InputVertices ( BitGFA2Str (B453 , B454 , B455) ) ) = { B453 , B454 , B455 })
proof
let C494 , C495 , C496 being non  pair set;
set D679 = ( BitGFA2Str (C494 , C495 , C496) );
set D680 = ( GFA2AdderStr (C494 , C495 , C496) );
set D681 = ( GFA2CarryStr (C494 , C495 , C496) );
L914: (( InputVertices D680 ) = { C494 , C495 , C496 } & ( InputVertices D681 ) = { C494 , C495 , C496 }) by L797 , FACIRC_1:57;
L915: (( InnerVertices D680 ) is Relation & ( InnerVertices D681 ) is Relation) by L735 , FACIRC_1:58;
thus L916: ( InputVertices D679 ) = ( { C494 , C495 , C496 } \/ { C494 , C495 , C496 } ) by L915 , L914 , FACIRC_1:7
.= { C494 , C495 , C496 };
end;
theorem
L917: (for B456 , B457 , B458 being non  pair set holds ( InputVertices ( BitGFA2Str (B456 , B457 , B458) ) ) is  without_pairs)
proof
let C497 , C498 , C499 being non  pair set;
L918: ( InputVertices ( BitGFA2Str (C497 , C498 , C499) ) ) = { C497 , C498 , C499 } by L913;
thus L919: thesis by L918;
end;
theorem
L920: (for B459 , B460 , B461 being set holds (B459 in (the carrier of ( BitGFA2Str (B459 , B460 , B461) )) & B460 in (the carrier of ( BitGFA2Str (B459 , B460 , B461) )) & B461 in (the carrier of ( BitGFA2Str (B459 , B460 , B461) )) & [ <* B459 , B460 *> , ( xor2c ) ] in (the carrier of ( BitGFA2Str (B459 , B460 , B461) )) & [ <* [ <* B459 , B460 *> , ( xor2c ) ] , B461 *> , ( xor2c ) ] in (the carrier of ( BitGFA2Str (B459 , B460 , B461) )) & [ <* B459 , B460 *> , ( and2a ) ] in (the carrier of ( BitGFA2Str (B459 , B460 , B461) )) & [ <* B460 , B461 *> , ( and2c ) ] in (the carrier of ( BitGFA2Str (B459 , B460 , B461) )) & [ <* B461 , B459 *> , ( and2b ) ] in (the carrier of ( BitGFA2Str (B459 , B460 , B461) )) & [ <* [ <* B459 , B460 *> , ( and2a ) ] , [ <* B460 , B461 *> , ( and2c ) ] , [ <* B461 , B459 *> , ( and2b ) ] *> , ( nor3 ) ] in (the carrier of ( BitGFA2Str (B459 , B460 , B461) ))))
proof
let C500 , C501 , C502 being set;
set D682 = ( and2a );
set D683 = ( and2c );
set D684 = ( and2b );
set D685 = ( nor3 );
set D686 = ( xor2c );
set D687 = [ <* C500 , C501 *> , D682 ];
set D688 = [ <* C501 , C502 *> , D683 ];
set D689 = [ <* C502 , C500 *> , D684 ];
set D690 = [ <* D687 , D688 , D689 *> , D685 ];
set D691 = ( GFA2AdderStr (C500 , C501 , C502) );
set D692 = ( GFA2CarryStr (C500 , C501 , C502) );
L921: (C500 in (the carrier of D691) & C501 in (the carrier of D691)) by FACIRC_1:60;
L922: (C502 in (the carrier of D691) & [ <* C500 , C501 *> , D686 ] in (the carrier of D691)) by FACIRC_1:60 , FACIRC_1:61;
L923: D690 in (the carrier of D692) by L771;
L924: (D688 in (the carrier of D692) & D689 in (the carrier of D692)) by L771;
L925: ([ <* [ <* C500 , C501 *> , D686 ] , C502 *> , D686 ] in (the carrier of D691) & D687 in (the carrier of D692)) by L771 , FACIRC_1:61;
thus L926: thesis by L925 , L921 , L922 , L924 , L923 , FACIRC_1:20;
end;
theorem
L927: (for B462 , B463 , B464 being set holds ([ <* B462 , B463 *> , ( xor2c ) ] in ( InnerVertices ( BitGFA2Str (B462 , B463 , B464) ) ) & ( GFA2AdderOutput (B462 , B463 , B464) ) in ( InnerVertices ( BitGFA2Str (B462 , B463 , B464) ) ) & [ <* B462 , B463 *> , ( and2a ) ] in ( InnerVertices ( BitGFA2Str (B462 , B463 , B464) ) ) & [ <* B463 , B464 *> , ( and2c ) ] in ( InnerVertices ( BitGFA2Str (B462 , B463 , B464) ) ) & [ <* B464 , B462 *> , ( and2b ) ] in ( InnerVertices ( BitGFA2Str (B462 , B463 , B464) ) ) & ( GFA2CarryOutput (B462 , B463 , B464) ) in ( InnerVertices ( BitGFA2Str (B462 , B463 , B464) ) )))
proof
let C503 , C504 , C505 being set;
set D693 = ( and2a );
set D694 = ( and2c );
set D695 = ( and2b );
set D696 = ( xor2c );
set D697 = [ <* C503 , C504 *> , D696 ];
set D698 = [ <* C503 , C504 *> , D693 ];
set D699 = [ <* C504 , C505 *> , D694 ];
set D700 = [ <* C505 , C503 *> , D695 ];
set D701 = ( BitGFA2Str (C503 , C504 , C505) );
set D702 = ( GFA2AdderOutput (C503 , C504 , C505) );
set D703 = ( GFA2CarryOutput (C503 , C504 , C505) );
L928: ( InnerVertices D701 ) = ( ( ( { D697 } \/ { D702 } ) \/ { D698 , D699 , D700 } ) \/ { D703 } ) by L904
.= ( ( { D697 , D702 } \/ { D698 , D699 , D700 } ) \/ { D703 } ) by ENUMSET1:1
.= ( { D697 , D702 , D698 , D699 , D700 } \/ { D703 } ) by ENUMSET1:8
.= { D697 , D702 , D698 , D699 , D700 , D703 } by ENUMSET1:15;
thus L929: thesis by L928 , ENUMSET1:def 4;
end;
theorem
L930: (for B465 , B466 , B467 being set holds ((B467 <> [ <* B465 , B466 *> , ( xor2c ) ] & B465 <> [ <* B466 , B467 *> , ( and2c ) ] & B466 <> [ <* B467 , B465 *> , ( and2b ) ] & B467 <> [ <* B465 , B466 *> , ( and2a ) ]) implies (B465 in ( InputVertices ( BitGFA2Str (B465 , B466 , B467) ) ) & B466 in ( InputVertices ( BitGFA2Str (B465 , B466 , B467) ) ) & B467 in ( InputVertices ( BitGFA2Str (B465 , B466 , B467) ) ))))
proof
set D704 = ( and2a );
set D705 = ( and2c );
set D706 = ( and2b );
set D707 = ( xor2c );
let C506 , C507 , C508 being set;
assume that
L931: (C508 <> [ <* C506 , C507 *> , D707 ] & C506 <> [ <* C507 , C508 *> , D705 ] & C507 <> [ <* C508 , C506 *> , D706 ] & C508 <> [ <* C506 , C507 *> , D704 ]);
set D708 = ( BitGFA2Str (C506 , C507 , C508) );
L932: ( InputVertices D708 ) = { C506 , C507 , C508 } by L931 , L909;
thus L933: thesis by L932 , ENUMSET1:def 1;
end;
definition
let C509 , C510 , C511 being set;
func BitGFA2CarryOutput (C509 , C510 , C511) -> (Element of ( InnerVertices ( BitGFA2Str (C509 , C510 , C511) ) )) equals 
[ <* [ <* C509 , C510 *> , ( and2a ) ] , [ <* C510 , C511 *> , ( and2c ) ] , [ <* C511 , C509 *> , ( and2b ) ] *> , ( nor3 ) ];
coherence
proof
L934: ( GFA2CarryOutput (C509 , C510 , C511) ) in ( InnerVertices ( BitGFA2Str (C509 , C510 , C511) ) ) by L927;
thus L935: thesis by L934;
end;
end;
definition
let C512 , C513 , C514 being set;
func BitGFA2AdderOutput (C512 , C513 , C514) -> (Element of ( InnerVertices ( BitGFA2Str (C512 , C513 , C514) ) )) equals 
( 2GatesCircOutput (C512 , C513 , C514 , ( xor2c )) );
coherence
proof
L937: ( GFA2AdderOutput (C512 , C513 , C514) ) in ( InnerVertices ( BitGFA2Str (C512 , C513 , C514) ) ) by L927;
thus L938: thesis by L937;
end;
end;
theorem
L940: (for B468 , B469 , B470 being set holds ((B470 <> [ <* B468 , B469 *> , ( xor2c ) ] & B468 <> [ <* B469 , B470 *> , ( and2c ) ] & B469 <> [ <* B470 , B468 *> , ( and2b ) ] & B470 <> [ <* B468 , B469 *> , ( and2a ) ]) implies (for B471 being (State of ( BitGFA2Circ (B468 , B469 , B470) )) holds (for B472 , B473 , B474 being (Element of ( BOOLEAN )) holds ((B472 = ( B471 . B468 ) & B473 = ( B471 . B469 ) & B474 = ( B471 . B470 )) implies (( ( Following (B471 , 2) ) . ( GFA2AdderOutput (B468 , B469 , B470) ) ) = ( ( ( 'not' B472 ) 'xor' B473 ) 'xor' ( 'not' B474 ) ) & ( ( Following (B471 , 2) ) . ( GFA2CarryOutput (B468 , B469 , B470) ) ) = ( 'not' ( ( ( ( 'not' B472 ) '&' B473 ) 'or' ( B473 '&' ( 'not' B474 ) ) ) 'or' ( ( 'not' B474 ) '&' ( 'not' B472 ) ) ) )))))))
proof
set D709 = ( and2a );
set D710 = ( and2c );
set D711 = ( and2b );
set D712 = ( xor2c );
let C515 , C516 , C517 being set;
assume that
L941: C517 <> [ <* C515 , C516 *> , D712 ]
and
L942: (C515 <> [ <* C516 , C517 *> , D710 ] & C516 <> [ <* C517 , C515 *> , D711 ] & C517 <> [ <* C515 , C516 *> , D709 ]);
set D713 = ( GFA2CarryStr (C515 , C516 , C517) );
set D714 = ( GFA2AdderStr (C515 , C516 , C517) );
L943: ( InputVertices D714 ) = { C515 , C516 , C517 } by L941 , FACIRC_1:57;
L944: ( InputVertices D714 ) = ( InputVertices D713 ) by L943 , L942 , L750;
set D715 = ( GFA2CarryCirc (C515 , C516 , C517) );
set D716 = ( GFA2AdderCirc (C515 , C516 , C517) );
set D717 = ( BitGFA2Circ (C515 , C516 , C517) );
let C518 being (State of D717);
let C519 , C520 , C521 being (Element of ( BOOLEAN ));
assume that
L945: C519 = ( C518 . C515 )
and
L946: C520 = ( C518 . C516 )
and
L947: C521 = ( C518 . C517 );
reconsider D718 = ( C518 | (the carrier of D714) ) as (State of D716) by FACIRC_1:26;
L948: ( dom D718 ) = (the carrier of D714) by CIRCUIT1:3;
L949: C517 in (the carrier of D714) by FACIRC_1:60;
L950: C521 = ( D718 . C517 ) by L949 , L947 , L948 , FUNCT_1:47;
L951: C516 in (the carrier of D714) by FACIRC_1:60;
L952: C520 = ( D718 . C516 ) by L951 , L946 , L948 , FUNCT_1:47;
reconsider D719 = C518 as (State of ( D716 +* D715 ));
L953: ( InnerVertices D713 ) misses ( InputVertices D713 ) by XBOOLE_1:79;
L954: ( ( Following (D719 , 2) ) . ( GFA2AdderOutput (C515 , C516 , C517) ) ) = ( ( Following (D718 , 2) ) . ( GFA2AdderOutput (C515 , C516 , C517) ) ) by L953 , L944 , FACIRC_1:32;
reconsider D720 = ( C518 | (the carrier of D713) ) as (State of D715) by FACIRC_1:26;
L955: ( dom D720 ) = (the carrier of D713) by CIRCUIT1:3;
L956: C515 in (the carrier of D714) by FACIRC_1:60;
L957: C519 = ( D718 . C515 ) by L956 , L945 , L948 , FUNCT_1:47;
thus L958: ( ( Following (C518 , 2) ) . ( GFA2AdderOutput (C515 , C516 , C517) ) ) = ( ( ( 'not' C519 ) 'xor' C520 ) 'xor' ( 'not' C521 ) ) by L957 , L941 , L952 , L950 , L954 , L898;
L959: ( InnerVertices D714 ) misses ( InputVertices D714 ) by XBOOLE_1:79;
L960: ( ( Following (D719 , 2) ) . ( GFA2CarryOutput (C515 , C516 , C517) ) ) = ( ( Following (D720 , 2) ) . ( GFA2CarryOutput (C515 , C516 , C517) ) ) by L959 , L944 , FACIRC_1:33;
L961: C517 in (the carrier of D713) by L771;
L962: C521 = ( D720 . C517 ) by L961 , L947 , L955 , FUNCT_1:47;
L963: C516 in (the carrier of D713) by L771;
L964: C520 = ( D720 . C516 ) by L963 , L946 , L955 , FUNCT_1:47;
L965: C515 in (the carrier of D713) by L771;
L966: C519 = ( D720 . C515 ) by L965 , L945 , L955 , FUNCT_1:47;
thus L967: thesis by L966 , L942 , L964 , L962 , L960 , L833;
end;
theorem
L968: (for B475 , B476 , B477 being set holds ((B477 <> [ <* B475 , B476 *> , ( xor2c ) ] & B475 <> [ <* B476 , B477 *> , ( and2c ) ] & B476 <> [ <* B477 , B475 *> , ( and2b ) ] & B477 <> [ <* B475 , B476 *> , ( and2a ) ]) implies (for B478 being (State of ( BitGFA2Circ (B475 , B476 , B477) )) holds ( Following (B478 , 2) ) is  stable)))
proof
set D721 = ( and2a );
set D722 = ( and2c );
set D723 = ( and2b );
set D724 = ( xor2c );
let C522 , C523 , C524 being set;
assume that
L969: C524 <> [ <* C522 , C523 *> , D724 ]
and
L970: (C522 <> [ <* C523 , C524 *> , D722 ] & C523 <> [ <* C524 , C522 *> , D723 ] & C524 <> [ <* C522 , C523 *> , D721 ]);
set D725 = ( BitGFA2Circ (C522 , C523 , C524) );
let C525 being (State of D725);
set D726 = ( GFA2CarryStr (C522 , C523 , C524) );
set D727 = ( GFA2AdderStr (C522 , C523 , C524) );
L971: ( InputVertices D727 ) = { C522 , C523 , C524 } by L969 , FACIRC_1:57;
L972: ( InputVertices D727 ) = ( InputVertices D726 ) by L971 , L970 , L750;
set D728 = ( GFA2AdderCirc (C522 , C523 , C524) );
reconsider D729 = ( C525 | (the carrier of D727) ) as (State of D728) by FACIRC_1:26;
L973: ( Following (D729 , 2) ) is  stable by L969 , FACIRC_1:63;
L974: ( Following (D729 , 2) ) = ( Following ( Following (D729 , 2) ) ) by L973 , CIRCUIT2:def 6
.= ( Following (D729 , ( 2 + 1 )) ) by FACIRC_1:12;
set D730 = ( GFA2CarryCirc (C522 , C523 , C524) );
reconsider D731 = ( C525 | (the carrier of D726) ) as (State of D730) by FACIRC_1:26;
L975: ( Following (D731 , 2) ) is  stable by L970 , L847;
L976: ( Following (D731 , 2) ) = ( Following ( Following (D731 , 2) ) ) by L975 , CIRCUIT2:def 6
.= ( Following (D731 , ( 2 + 1 )) ) by FACIRC_1:12;
reconsider D732 = C525 as (State of ( D728 +* D730 ));
set D733 = ( BitGFA2Str (C522 , C523 , C524) );
L977: ( dom ( Following (C525 , 3) ) ) = (the carrier of D733) by CIRCUIT1:3;
L978: ( InnerVertices D726 ) misses ( InputVertices D726 ) by XBOOLE_1:79;
L979: (( Following (D729 , 2) ) = ( ( Following (D732 , 2) ) | (the carrier of D727) ) & ( Following (D729 , 3) ) = ( ( Following (D732 , 3) ) | (the carrier of D727) )) by L978 , L972 , FACIRC_1:30;
L980: ( InnerVertices D727 ) misses ( InputVertices D727 ) by XBOOLE_1:79;
L981: (( Following (D731 , 2) ) = ( ( Following (D732 , 2) ) | (the carrier of D726) ) & ( Following (D731 , 3) ) = ( ( Following (D732 , 3) ) | (the carrier of D726) )) by L980 , L972 , FACIRC_1:31;
L982: (the carrier of D733) = ( (the carrier of D727) \/ (the carrier of D726) ) by CIRCCOMB:def 2;
L983: (( dom ( Following (D729 , 2) ) ) = (the carrier of D727) & ( dom ( Following (D731 , 2) ) ) = (the carrier of D726)) by CIRCUIT1:3;
L984:
now
let C526 being set;
assume L985: C526 in (the carrier of D733);
L986: (C526 in (the carrier of D727) or C526 in (the carrier of D726)) by L985 , L982 , XBOOLE_0:def 3;
L987: ((( ( Following (C525 , 2) ) . C526 ) = ( ( Following (D729 , 2) ) . C526 ) & ( ( Following (C525 , 3) ) . C526 ) = ( ( Following (D729 , 3) ) . C526 )) or (( ( Following (C525 , 2) ) . C526 ) = ( ( Following (D731 , 2) ) . C526 ) & ( ( Following (C525 , 3) ) . C526 ) = ( ( Following (D731 , 3) ) . C526 ))) by L986 , L979 , L981 , L974 , L976 , L983 , FUNCT_1:47;
thus L988: ( ( Following (C525 , 2) ) . C526 ) = ( ( Following ( Following (C525 , 2) ) ) . C526 ) by L987 , L974 , L976 , FACIRC_1:12;
end;
L989: (( Following (C525 , ( 2 + 1 )) ) = ( Following ( Following (C525 , 2) ) ) & ( dom ( Following (C525 , 2) ) ) = (the carrier of D733)) by CIRCUIT1:3 , FACIRC_1:12;
thus L990: ( Following (C525 , 2) ) = ( Following ( Following (C525 , 2) ) ) by L989 , L977 , L984 , FUNCT_1:2;
end;
begin
definition
let C527 , C528 , C529 being set;
func GFA3CarryIStr (C527 , C528 , C529) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( ( 1GateCircStr (<* C527 , C528 *> , ( and2b )) ) +* ( 1GateCircStr (<* C528 , C529 *> , ( and2b )) ) ) +* ( 1GateCircStr (<* C529 , C527 *> , ( and2b )) ) );
coherence;
end;
definition
let C530 , C531 , C532 being set;
func GFA3CarryICirc (C530 , C531 , C532) ->  strict  Boolean  gate`2=den (Circuit of ( GFA3CarryIStr (C530 , C531 , C532) )) equals 
( ( ( 1GateCircuit (C530 , C531 , ( and2b )) ) +* ( 1GateCircuit (C531 , C532 , ( and2b )) ) ) +* ( 1GateCircuit (C532 , C530 , ( and2b )) ) );
coherence;
end;
definition
let C533 , C534 , C535 being set;
func GFA3CarryStr (C533 , C534 , C535) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( GFA3CarryIStr (C533 , C534 , C535) ) +* ( 1GateCircStr (<* [ <* C533 , C534 *> , ( and2b ) ] , [ <* C534 , C535 *> , ( and2b ) ] , [ <* C535 , C533 *> , ( and2b ) ] *> , ( nor3 )) ) );
coherence;
end;
definition
let C536 , C537 , C538 being set;
func GFA3CarryCirc (C536 , C537 , C538) ->  strict  Boolean  gate`2=den (Circuit of ( GFA3CarryStr (C536 , C537 , C538) )) equals 
( ( GFA3CarryICirc (C536 , C537 , C538) ) +* ( 1GateCircuit ([ <* C536 , C537 *> , ( and2b ) ] , [ <* C537 , C538 *> , ( and2b ) ] , [ <* C538 , C536 *> , ( and2b ) ] , ( nor3 )) ) );
coherence;
end;
definition
let C539 , C540 , C541 being set;
func GFA3CarryOutput (C539 , C540 , C541) -> (Element of ( InnerVertices ( GFA3CarryStr (C539 , C540 , C541) ) )) equals 
[ <* [ <* C539 , C540 *> , ( and2b ) ] , [ <* C540 , C541 *> , ( and2b ) ] , [ <* C541 , C539 *> , ( and2b ) ] *> , ( nor3 ) ];
coherence
proof
L995: [ <* [ <* C539 , C540 *> , ( and2b ) ] , [ <* C540 , C541 *> , ( and2b ) ] , [ <* C541 , C539 *> , ( and2b ) ] *> , ( nor3 ) ] in ( InnerVertices ( 1GateCircStr (<* [ <* C539 , C540 *> , ( and2b ) ] , [ <* C540 , C541 *> , ( and2b ) ] , [ <* C541 , C539 *> , ( and2b ) ] *> , ( nor3 )) ) ) by FACIRC_1:47;
thus L996: thesis by L995 , FACIRC_1:21;
end;
end;
theorem
L998: (for B479 , B480 , B481 being set holds ( InnerVertices ( GFA3CarryIStr (B479 , B480 , B481) ) ) = { [ <* B479 , B480 *> , ( and2b ) ] , [ <* B480 , B481 *> , ( and2b ) ] , [ <* B481 , B479 *> , ( and2b ) ] })
proof
let C542 , C543 , C544 being set;
set D734 = ( and2b );
set D735 = ( and2b );
set D736 = ( and2b );
set D737 = [ <* C542 , C543 *> , D734 ];
set D738 = [ <* C543 , C544 *> , D735 ];
set D739 = [ <* C544 , C542 *> , D736 ];
set D740 = ( 1GateCircStr (<* C542 , C543 *> , D734) );
set D741 = ( 1GateCircStr (<* C543 , C544 *> , D735) );
set D742 = ( 1GateCircStr (<* C544 , C542 *> , D736) );
L999: D740 tolerates D741 by CIRCCOMB:47;
L1000: ( D740 +* D741 ) tolerates D742 by CIRCCOMB:47;
L1001: ( InnerVertices ( GFA3CarryIStr (C542 , C543 , C544) ) ) = ( ( InnerVertices ( D740 +* D741 ) ) \/ ( InnerVertices D742 ) ) by L1000 , CIRCCOMB:11
.= ( ( ( InnerVertices D740 ) \/ ( InnerVertices D741 ) ) \/ ( InnerVertices D742 ) ) by L999 , CIRCCOMB:11
.= ( ( { D737 } \/ ( InnerVertices D741 ) ) \/ ( InnerVertices D742 ) ) by CIRCCOMB:42
.= ( ( { D737 } \/ { D738 } ) \/ ( InnerVertices D742 ) ) by CIRCCOMB:42
.= ( ( { D737 } \/ { D738 } ) \/ { D739 } ) by CIRCCOMB:42
.= ( { D737 , D738 } \/ { D739 } ) by ENUMSET1:1
.= { D737 , D738 , D739 } by ENUMSET1:3;
thus L1002: thesis by L1001;
end;
theorem
L1003: (for B482 , B483 , B484 being set holds ( InnerVertices ( GFA3CarryStr (B482 , B483 , B484) ) ) = ( { [ <* B482 , B483 *> , ( and2b ) ] , [ <* B483 , B484 *> , ( and2b ) ] , [ <* B484 , B482 *> , ( and2b ) ] } \/ { ( GFA3CarryOutput (B482 , B483 , B484) ) } ))
proof
let C545 , C546 , C547 being set;
set D743 = ( and2b );
set D744 = ( and2b );
set D745 = ( and2b );
set D746 = ( nor3 );
set D747 = [ <* C545 , C546 *> , D743 ];
set D748 = [ <* C546 , C547 *> , D744 ];
set D749 = [ <* C547 , C545 *> , D745 ];
set D750 = ( 1GateCircStr (<* C545 , C546 *> , D743) );
set D751 = ( 1GateCircStr (<* C546 , C547 *> , D744) );
set D752 = ( 1GateCircStr (<* C547 , C545 *> , D745) );
set D753 = ( 1GateCircStr (<* D747 , D748 , D749 *> , D746) );
L1004: D750 tolerates ( ( D751 +* D752 ) +* D753 ) by CIRCCOMB:47;
L1005: D751 tolerates ( D752 +* D753 ) by CIRCCOMB:47;
L1006: ( InnerVertices ( D751 +* ( D752 +* D753 ) ) ) = ( ( InnerVertices D751 ) \/ ( InnerVertices ( D752 +* D753 ) ) ) by L1005 , CIRCCOMB:11;
L1007: D752 tolerates D753 by CIRCCOMB:47;
L1008: ( InnerVertices ( D752 +* D753 ) ) = ( ( InnerVertices D752 ) \/ ( InnerVertices D753 ) ) by L1007 , CIRCCOMB:11;
thus L1009: ( InnerVertices ( GFA3CarryStr (C545 , C546 , C547) ) ) = ( InnerVertices ( ( D750 +* ( D751 +* D752 ) ) +* D753 ) ) by CIRCCOMB:6
.= ( InnerVertices ( D750 +* ( ( D751 +* D752 ) +* D753 ) ) ) by CIRCCOMB:6
.= ( ( InnerVertices D750 ) \/ ( InnerVertices ( ( D751 +* D752 ) +* D753 ) ) ) by L1004 , CIRCCOMB:11
.= ( ( InnerVertices D750 ) \/ ( InnerVertices ( D751 +* ( D752 +* D753 ) ) ) ) by CIRCCOMB:6
.= ( ( ( InnerVertices D750 ) \/ ( InnerVertices D751 ) ) \/ ( ( InnerVertices D752 ) \/ ( InnerVertices D753 ) ) ) by L1006 , L1008 , XBOOLE_1:4
.= ( ( ( ( InnerVertices D750 ) \/ ( InnerVertices D751 ) ) \/ ( InnerVertices D752 ) ) \/ ( InnerVertices D753 ) ) by XBOOLE_1:4
.= ( ( ( { D747 } \/ ( InnerVertices D751 ) ) \/ ( InnerVertices D752 ) ) \/ ( InnerVertices D753 ) ) by CIRCCOMB:42
.= ( ( ( { D747 } \/ { D748 } ) \/ ( InnerVertices D752 ) ) \/ ( InnerVertices D753 ) ) by CIRCCOMB:42
.= ( ( ( { D747 } \/ { D748 } ) \/ { D749 } ) \/ ( InnerVertices D753 ) ) by CIRCCOMB:42
.= ( ( { D747 , D748 } \/ { D749 } ) \/ ( InnerVertices D753 ) ) by ENUMSET1:1
.= ( { D747 , D748 , D749 } \/ ( InnerVertices D753 ) ) by ENUMSET1:3
.= ( { D747 , D748 , D749 } \/ { ( GFA3CarryOutput (C545 , C546 , C547) ) } ) by CIRCCOMB:42;
end;
theorem
L1010: (for B485 , B486 , B487 being set holds ( InnerVertices ( GFA3CarryStr (B485 , B486 , B487) ) ) is Relation)
proof
let C548 , C549 , C550 being set;
set D754 = ( and2b );
set D755 = ( and2b );
set D756 = ( and2b );
set D757 = ( nor3 );
set D758 = [ <* C548 , C549 *> , D754 ];
set D759 = [ <* C549 , C550 *> , D755 ];
set D760 = [ <* C550 , C548 *> , D756 ];
set D761 = ( 1GateCircStr (<* C548 , C549 *> , D754) );
set D762 = ( 1GateCircStr (<* C549 , C550 *> , D755) );
set D763 = ( 1GateCircStr (<* C550 , C548 *> , D756) );
set D764 = ( 1GateCircStr (<* D758 , D759 , D760 *> , D757) );
L1011: (( InnerVertices D761 ) is Relation & ( InnerVertices D762 ) is Relation) by FACIRC_1:38;
L1012: (( InnerVertices D763 ) is Relation & ( InnerVertices ( D761 +* D762 ) ) is Relation) by L1011 , FACIRC_1:3 , FACIRC_1:38;
L1013: (( InnerVertices D764 ) is Relation & ( InnerVertices ( GFA3CarryIStr (C548 , C549 , C550) ) ) is Relation) by L1012 , FACIRC_1:3 , FACIRC_1:38;
thus L1014: thesis by L1013 , FACIRC_1:3;
end;
theorem
L1015: (for B488 , B489 , B490 being set holds ((B488 <> [ <* B489 , B490 *> , ( and2b ) ] & B489 <> [ <* B490 , B488 *> , ( and2b ) ] & B490 <> [ <* B488 , B489 *> , ( and2b ) ]) implies ( InputVertices ( GFA3CarryIStr (B488 , B489 , B490) ) ) = { B488 , B489 , B490 }))
proof
let C551 , C552 , C553 being set;
set D765 = ( and2b );
set D766 = ( and2b );
set D767 = ( and2b );
set D768 = [ <* C551 , C552 *> , D765 ];
set D769 = [ <* C552 , C553 *> , D766 ];
set D770 = [ <* C553 , C551 *> , D767 ];
set D771 = ( 1GateCircStr (<* C551 , C552 *> , D765) );
set D772 = ( 1GateCircStr (<* C552 , C553 *> , D766) );
set D773 = ( 1GateCircStr (<* C553 , C551 *> , D767) );
assume that
L1016: C551 <> D769
and
L1017: (C552 <> D770 & C553 <> D768);
L1018: (not D768 in { C552 , C553 }) by L1016 , L1017 , L70;
L1019: (not D770 in { C551 , C552 , C553 }) by L1016 , L1017 , L70;
L1020: C552 <> D769 by FACIRC_2:2;
L1021: ((not C553 in { D768 , D769 }) & (not C551 in { D768 , D769 })) by L1016 , L1017 , L70;
L1022: D771 tolerates D772 by CIRCCOMB:47;
L1023: ( InputVertices ( GFA3CarryIStr (C551 , C552 , C553) ) ) = ( ( ( InputVertices ( D771 +* D772 ) ) \ ( InnerVertices D773 ) ) \/ ( ( InputVertices D773 ) \ ( InnerVertices ( D771 +* D772 ) ) ) ) by CIRCCMB2:5 , CIRCCOMB:47
.= ( ( ( ( ( InputVertices D771 ) \ ( InnerVertices D772 ) ) \/ ( ( InputVertices D772 ) \ ( InnerVertices D771 ) ) ) \ ( InnerVertices D773 ) ) \/ ( ( InputVertices D773 ) \ ( InnerVertices ( D771 +* D772 ) ) ) ) by CIRCCMB2:5 , CIRCCOMB:47
.= ( ( ( ( ( InputVertices D771 ) \ ( InnerVertices D772 ) ) \/ ( ( InputVertices D772 ) \ ( InnerVertices D771 ) ) ) \ ( InnerVertices D773 ) ) \/ ( ( InputVertices D773 ) \ ( ( InnerVertices D771 ) \/ ( InnerVertices D772 ) ) ) ) by L1022 , CIRCCOMB:11
.= ( ( ( ( ( InputVertices D771 ) \ { D769 } ) \/ ( ( InputVertices D772 ) \ ( InnerVertices D771 ) ) ) \ ( InnerVertices D773 ) ) \/ ( ( InputVertices D773 ) \ ( ( InnerVertices D771 ) \/ ( InnerVertices D772 ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices D771 ) \ { D769 } ) \/ ( ( InputVertices D772 ) \ { D768 } ) ) \ ( InnerVertices D773 ) ) \/ ( ( InputVertices D773 ) \ ( ( InnerVertices D771 ) \/ ( InnerVertices D772 ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices D771 ) \ { D769 } ) \/ ( ( InputVertices D772 ) \ { D768 } ) ) \ { D770 } ) \/ ( ( InputVertices D773 ) \ ( ( InnerVertices D771 ) \/ ( InnerVertices D772 ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices D771 ) \ { D769 } ) \/ ( ( InputVertices D772 ) \ { D768 } ) ) \ { D770 } ) \/ ( ( InputVertices D773 ) \ ( { D768 } \/ ( InnerVertices D772 ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices D771 ) \ { D769 } ) \/ ( ( InputVertices D772 ) \ { D768 } ) ) \ { D770 } ) \/ ( ( InputVertices D773 ) \ ( { D768 } \/ { D769 } ) ) ) by CIRCCOMB:42
.= ( ( ( ( { C551 , C552 } \ { D769 } ) \/ ( ( InputVertices D772 ) \ { D768 } ) ) \ { D770 } ) \/ ( ( InputVertices D773 ) \ ( { D768 } \/ { D769 } ) ) ) by FACIRC_1:40
.= ( ( ( ( { C551 , C552 } \ { D769 } ) \/ ( { C552 , C553 } \ { D768 } ) ) \ { D770 } ) \/ ( ( InputVertices D773 ) \ ( { D768 } \/ { D769 } ) ) ) by FACIRC_1:40
.= ( ( ( ( { C551 , C552 } \ { D769 } ) \/ ( { C552 , C553 } \ { D768 } ) ) \ { D770 } ) \/ ( { C553 , C551 } \ ( { D768 } \/ { D769 } ) ) ) by FACIRC_1:40
.= ( ( ( ( { C551 , C552 } \ { D769 } ) \/ ( { C552 , C553 } \ { D768 } ) ) \ { D770 } ) \/ ( { C553 , C551 } \ { D768 , D769 } ) ) by ENUMSET1:1
.= ( ( ( { C551 , C552 } \/ ( { C552 , C553 } \ { D768 } ) ) \ { D770 } ) \/ ( { C553 , C551 } \ { D768 , D769 } ) ) by L1016 , L1020 , FACIRC_2:1
.= ( ( ( { C551 , C552 } \/ { C552 , C553 } ) \ { D770 } ) \/ ( { C553 , C551 } \ { D768 , D769 } ) ) by L1018 , ZFMISC_1:57
.= ( ( ( { C551 , C552 } \/ { C552 , C553 } ) \ { D770 } ) \/ { C553 , C551 } ) by L1021 , ZFMISC_1:63
.= ( ( { C551 , C552 , C552 , C553 } \ { D770 } ) \/ { C553 , C551 } ) by ENUMSET1:5
.= ( ( { C552 , C552 , C551 , C553 } \ { D770 } ) \/ { C553 , C551 } ) by ENUMSET1:67
.= ( ( { C552 , C551 , C553 } \ { D770 } ) \/ { C553 , C551 } ) by ENUMSET1:31
.= ( ( { C551 , C552 , C553 } \ { D770 } ) \/ { C553 , C551 } ) by ENUMSET1:58
.= ( { C551 , C552 , C553 } \/ { C553 , C551 } ) by L1019 , ZFMISC_1:57
.= { C551 , C552 , C553 , C553 , C551 } by ENUMSET1:9
.= ( { C551 , C552 , C553 , C553 } \/ { C551 } ) by ENUMSET1:10
.= ( { C553 , C553 , C551 , C552 } \/ { C551 } ) by ENUMSET1:73
.= ( { C553 , C551 , C552 } \/ { C551 } ) by ENUMSET1:31
.= { C553 , C551 , C552 , C551 } by ENUMSET1:6
.= { C551 , C551 , C552 , C553 } by ENUMSET1:70
.= { C551 , C552 , C553 } by ENUMSET1:31;
thus L1024: thesis by L1023;
end;
theorem
L1025: (for B491 , B492 , B493 being set holds ((B491 <> [ <* B492 , B493 *> , ( and2b ) ] & B492 <> [ <* B493 , B491 *> , ( and2b ) ] & B493 <> [ <* B491 , B492 *> , ( and2b ) ]) implies ( InputVertices ( GFA3CarryStr (B491 , B492 , B493) ) ) = { B491 , B492 , B493 }))
proof
let C554 , C555 , C556 being set;
set D774 = ( and2b );
set D775 = ( and2b );
set D776 = ( and2b );
set D777 = ( nor3 );
set D778 = [ <* C554 , C555 *> , D774 ];
set D779 = [ <* C555 , C556 *> , D775 ];
set D780 = [ <* C556 , C554 *> , D776 ];
set D781 = [ <* D778 , D779 , D780 *> , D777 ];
set D782 = ( 1GateCircStr (<* D778 , D779 , D780 *> , D777) );
set D783 = ( GFA3CarryIStr (C554 , C555 , C556) );
L1026: ( InputVertices D782 ) = ( rng <* D778 , D779 , D780 *> ) by CIRCCOMB:42
.= { D778 , D779 , D780 } by FINSEQ_2:128;
assume L1027: (C554 <> D779 & C555 <> D780 & C556 <> D778);
L1028: (( InnerVertices D782 ) = { D781 } & ( { C554 , C555 , C556 } \ { D781 } ) = { C554 , C555 , C556 }) by L112 , CIRCCOMB:42;
L1029: ( { D778 , D779 , D780 } \ { D778 , D779 , D780 } ) = ( {} ) by XBOOLE_1:37;
thus L1030: ( InputVertices ( GFA3CarryStr (C554 , C555 , C556) ) ) = ( ( ( InputVertices D783 ) \ ( InnerVertices D782 ) ) \/ ( ( InputVertices D782 ) \ ( InnerVertices D783 ) ) ) by CIRCCMB2:5 , CIRCCOMB:47
.= ( { C554 , C555 , C556 } \/ ( { D778 , D779 , D780 } \ ( InnerVertices D783 ) ) ) by L1026 , L1027 , L1028 , L1015
.= ( { C554 , C555 , C556 } \/ ( {} ) ) by L1029 , L998
.= { C554 , C555 , C556 };
end;
theorem
L1031: (for B494 , B495 , B496 being non  pair set holds ( InputVertices ( GFA3CarryStr (B494 , B495 , B496) ) ) is  without_pairs)
proof
let C557 , C558 , C559 being non  pair set;
set D784 = ( and2b );
set D785 = ( and2b );
set D786 = ( and2b );
set D787 = ( nor3 );
set D788 = [ <* C557 , C558 *> , D784 ];
set D789 = [ <* C558 , C559 *> , D785 ];
set D790 = [ <* C559 , C557 *> , D786 ];
set D791 = ( 1GateCircStr (<* C557 , C558 *> , D784) );
set D792 = ( 1GateCircStr (<* C558 , C559 *> , D785) );
set D793 = ( 1GateCircStr (<* C559 , C557 *> , D786) );
set D794 = ( 1GateCircStr (<* D788 , D789 , D790 *> , D787) );
set D795 = ( GFA3CarryStr (C557 , C558 , C559) );
set D796 = ( GFA3CarryIStr (C557 , C558 , C559) );
given C560 being  pair set such that
L1032: C560 in ( InputVertices D795 );

L1033: D791 tolerates D792 by CIRCCOMB:47;
L1034: (( InnerVertices D793 ) = { D790 } & ( D791 +* D792 ) tolerates D793) by CIRCCOMB:42 , CIRCCOMB:47;
L1035: (( InnerVertices D791 ) = { D788 } & ( InnerVertices D792 ) = { D789 }) by CIRCCOMB:42;
L1036: ( InnerVertices ( D791 +* D792 ) ) = ( { D788 } \/ { D789 } ) by L1035 , L1033 , CIRCCOMB:11;
L1037: ( InnerVertices D796 ) = ( ( { D788 } \/ { D789 } ) \/ { D790 } ) by L1036 , L1034 , CIRCCOMB:11
.= ( { D788 , D789 } \/ { D790 } ) by ENUMSET1:1
.= { D788 , D789 , D790 } by ENUMSET1:3;
L1038: ( InputVertices D794 ) = { D788 , D789 , D790 } by FACIRC_1:42;
L1039: ( ( InputVertices D794 ) \ ( InnerVertices D796 ) ) = ( {} ) by L1038 , L1037 , XBOOLE_1:37;
L1040: (( InputVertices D791 ) is  without_pairs & ( InputVertices D792 ) is  without_pairs) by FACIRC_1:41;
L1041: (( InputVertices D793 ) is  without_pairs & ( InputVertices ( D791 +* D792 ) ) is  without_pairs) by L1040 , FACIRC_1:9 , FACIRC_1:41;
L1042: ( InputVertices D796 ) is  without_pairs by L1041 , FACIRC_1:9;
L1043: ( InnerVertices D794 ) is Relation by FACIRC_1:38;
L1044: ( InputVertices D795 ) = ( ( InputVertices D796 ) \/ ( ( InputVertices D794 ) \ ( InnerVertices D796 ) ) ) by L1043 , L1042 , FACIRC_1:6;
thus L1045: thesis by L1044 , L1042 , L1032 , L1039 , FACIRC_1:def 2;
end;
theorem
L1046: (for B497 , B498 , B499 being set holds (B497 in (the carrier of ( GFA3CarryStr (B497 , B498 , B499) )) & B498 in (the carrier of ( GFA3CarryStr (B497 , B498 , B499) )) & B499 in (the carrier of ( GFA3CarryStr (B497 , B498 , B499) )) & [ <* B497 , B498 *> , ( and2b ) ] in (the carrier of ( GFA3CarryStr (B497 , B498 , B499) )) & [ <* B498 , B499 *> , ( and2b ) ] in (the carrier of ( GFA3CarryStr (B497 , B498 , B499) )) & [ <* B499 , B497 *> , ( and2b ) ] in (the carrier of ( GFA3CarryStr (B497 , B498 , B499) )) & [ <* [ <* B497 , B498 *> , ( and2b ) ] , [ <* B498 , B499 *> , ( and2b ) ] , [ <* B499 , B497 *> , ( and2b ) ] *> , ( nor3 ) ] in (the carrier of ( GFA3CarryStr (B497 , B498 , B499) ))))
proof
let C561 , C562 , C563 being set;
set D797 = ( and2b );
set D798 = ( and2b );
set D799 = ( and2b );
set D800 = ( nor3 );
set D801 = [ <* C561 , C562 *> , D797 ];
set D802 = [ <* C562 , C563 *> , D798 ];
set D803 = [ <* C563 , C561 *> , D799 ];
set D804 = [ <* D801 , D802 , D803 *> , D800 ];
set D805 = ( 1GateCircStr (<* C561 , C562 *> , D797) );
set D806 = ( 1GateCircStr (<* C562 , C563 *> , D798) );
set D807 = ( 1GateCircStr (<* C563 , C561 *> , D799) );
set D808 = ( 1GateCircStr (<* D801 , D802 , D803 *> , D800) );
set D809 = <* D801 , D802 , D803 *>;
L1047: C563 in (the carrier of D807) by FACIRC_1:43;
L1048: C563 in (the carrier of ( GFA3CarryIStr (C561 , C562 , C563) )) by L1047 , FACIRC_1:20;
L1049: D803 in (the carrier of D807) by FACIRC_1:43;
L1050: D803 in (the carrier of ( GFA3CarryIStr (C561 , C562 , C563) )) by L1049 , FACIRC_1:20;
L1051: C562 in (the carrier of D805) by FACIRC_1:43;
L1052: C562 in (the carrier of ( D805 +* D806 )) by L1051 , FACIRC_1:20;
L1053: C562 in (the carrier of ( GFA3CarryIStr (C561 , C562 , C563) )) by L1052 , FACIRC_1:20;
L1054: ((the carrier of D808) = ( ( rng D809 ) \/ { D804 } ) & [ D809 , D800 ] in { [ D809 , D800 ] }) by CIRCCOMB:def 6 , TARSKI:def 1;
L1055: D804 in (the carrier of D808) by L1054 , XBOOLE_0:def 3;
L1056: D802 in (the carrier of D806) by FACIRC_1:43;
L1057: D802 in (the carrier of ( D805 +* D806 )) by L1056 , FACIRC_1:20;
L1058: D802 in (the carrier of ( GFA3CarryIStr (C561 , C562 , C563) )) by L1057 , FACIRC_1:20;
L1059: D801 in (the carrier of D805) by FACIRC_1:43;
L1060: D801 in (the carrier of ( D805 +* D806 )) by L1059 , FACIRC_1:20;
L1061: D801 in (the carrier of ( GFA3CarryIStr (C561 , C562 , C563) )) by L1060 , FACIRC_1:20;
L1062: C561 in (the carrier of D807) by FACIRC_1:43;
L1063: C561 in (the carrier of ( GFA3CarryIStr (C561 , C562 , C563) )) by L1062 , FACIRC_1:20;
thus L1064: thesis by L1063 , L1053 , L1048 , L1061 , L1058 , L1050 , L1055 , FACIRC_1:20;
end;
theorem
L1065: (for B500 , B501 , B502 being set holds ([ <* B500 , B501 *> , ( and2b ) ] in ( InnerVertices ( GFA3CarryStr (B500 , B501 , B502) ) ) & [ <* B501 , B502 *> , ( and2b ) ] in ( InnerVertices ( GFA3CarryStr (B500 , B501 , B502) ) ) & [ <* B502 , B500 *> , ( and2b ) ] in ( InnerVertices ( GFA3CarryStr (B500 , B501 , B502) ) ) & ( GFA3CarryOutput (B500 , B501 , B502) ) in ( InnerVertices ( GFA3CarryStr (B500 , B501 , B502) ) )))
proof
let C564 , C565 , C566 being set;
set D810 = ( and2b );
set D811 = ( and2b );
set D812 = ( and2b );
set D813 = [ <* C564 , C565 *> , D810 ];
set D814 = [ <* C565 , C566 *> , D811 ];
set D815 = [ <* C566 , C564 *> , D812 ];
L1066: ( InnerVertices ( GFA3CarryStr (C564 , C565 , C566) ) ) = ( { D813 , D814 , D815 } \/ { ( GFA3CarryOutput (C564 , C565 , C566) ) } ) by L1003
.= { D813 , D814 , D815 , ( GFA3CarryOutput (C564 , C565 , C566) ) } by ENUMSET1:6;
thus L1067: thesis by L1066 , ENUMSET1:def 2;
end;
theorem
L1068: (for B503 , B504 , B505 being set holds ((B503 <> [ <* B504 , B505 *> , ( and2b ) ] & B504 <> [ <* B505 , B503 *> , ( and2b ) ] & B505 <> [ <* B503 , B504 *> , ( and2b ) ]) implies (B503 in ( InputVertices ( GFA3CarryStr (B503 , B504 , B505) ) ) & B504 in ( InputVertices ( GFA3CarryStr (B503 , B504 , B505) ) ) & B505 in ( InputVertices ( GFA3CarryStr (B503 , B504 , B505) ) ))))
proof
set D816 = ( and2b );
set D817 = ( and2b );
set D818 = ( and2b );
let C567 , C568 , C569 being set;
assume L1069: (C567 <> [ <* C568 , C569 *> , D817 ] & C568 <> [ <* C569 , C567 *> , D818 ] & C569 <> [ <* C567 , C568 *> , D816 ]);
L1070: ( InputVertices ( GFA3CarryStr (C567 , C568 , C569) ) ) = { C567 , C568 , C569 } by L1069 , L1025;
thus L1071: thesis by L1070 , ENUMSET1:def 1;
end;
theorem
L1072: (for B506 , B507 , B508 being non  pair set holds ( InputVertices ( GFA3CarryStr (B506 , B507 , B508) ) ) = { B506 , B507 , B508 })
proof
let C570 , C571 , C572 being non  pair set;
set D819 = ( and2b );
set D820 = ( and2b );
set D821 = ( and2b );
set D822 = ( nor3 );
set D823 = [ <* C570 , C571 *> , D819 ];
set D824 = [ <* C571 , C572 *> , D820 ];
set D825 = [ <* C572 , C570 *> , D821 ];
set D826 = ( 1GateCircStr (<* C570 , C571 *> , D819) );
set D827 = ( 1GateCircStr (<* C571 , C572 *> , D820) );
set D828 = ( 1GateCircStr (<* C572 , C570 *> , D821) );
set D829 = ( GFA3CarryStr (C570 , C571 , C572) );
set D830 = ( GFA3CarryIStr (C570 , C571 , C572) );
set D831 = ( 1GateCircStr (<* D823 , D824 , D825 *> , D822) );
L1073: (( InputVertices D826 ) = { C570 , C571 } & ( InputVertices D827 ) = { C571 , C572 }) by FACIRC_1:40;
L1074: ( InputVertices D828 ) = { C572 , C570 } by FACIRC_1:40;
L1075: ( InputVertices D831 ) = { D823 , D824 , D825 } by FACIRC_1:42;
L1076: ( InnerVertices D831 ) is Relation by FACIRC_1:38;
L1077: (( InnerVertices D826 ) = { D823 } & ( InnerVertices D827 ) = { D824 }) by CIRCCOMB:42;
L1078: D826 tolerates D827 by CIRCCOMB:47;
L1079: (( InnerVertices D828 ) = { D825 } & ( InnerVertices ( D826 +* D827 ) ) = ( { D823 } \/ { D824 } )) by L1078 , L1077 , CIRCCOMB:11 , CIRCCOMB:42;
L1080: ( D826 +* D827 ) tolerates D828 by CIRCCOMB:47;
L1081: ( InnerVertices D830 ) = ( ( { D823 } \/ { D824 } ) \/ { D825 } ) by L1080 , L1079 , CIRCCOMB:11
.= ( { D823 , D824 } \/ { D825 } ) by ENUMSET1:1
.= { D823 , D824 , D825 } by ENUMSET1:3;
L1082: ( ( InputVertices D831 ) \ ( InnerVertices D830 ) ) = ( {} ) by L1081 , L1075 , XBOOLE_1:37;
L1083: (( InputVertices D826 ) is  without_pairs & ( InputVertices D827 ) is  without_pairs) by FACIRC_1:41;
L1084: (( InputVertices D828 ) is  without_pairs & ( InputVertices ( D826 +* D827 ) ) is  without_pairs) by L1083 , FACIRC_1:9 , FACIRC_1:41;
L1085: ( InputVertices D830 ) is  without_pairs by L1084 , FACIRC_1:9;
L1086: ( InputVertices D829 ) = ( ( InputVertices D830 ) \/ ( ( InputVertices D831 ) \ ( InnerVertices D830 ) ) ) by L1085 , L1076 , FACIRC_1:6;
thus L1087: ( InputVertices D829 ) = ( ( InputVertices ( D826 +* D827 ) ) \/ ( InputVertices D828 ) ) by L1086 , L1084 , L1079 , L1082 , FACIRC_1:7
.= ( ( ( InputVertices D826 ) \/ ( InputVertices D827 ) ) \/ ( InputVertices D828 ) ) by L1083 , L1077 , FACIRC_1:7
.= ( { C570 , C571 , C571 , C572 } \/ { C572 , C570 } ) by L1073 , L1074 , ENUMSET1:5
.= ( { C571 , C571 , C570 , C572 } \/ { C572 , C570 } ) by ENUMSET1:67
.= ( { C571 , C570 , C572 } \/ { C572 , C570 } ) by ENUMSET1:31
.= ( { C570 , C571 , C572 } \/ { C572 , C570 } ) by ENUMSET1:58
.= ( { C570 , C571 , C572 } \/ ( { C572 } \/ { C570 } ) ) by ENUMSET1:1
.= ( ( { C570 , C571 , C572 } \/ { C572 } ) \/ { C570 } ) by XBOOLE_1:4
.= ( ( { C572 , C570 , C571 } \/ { C572 } ) \/ { C570 } ) by ENUMSET1:59
.= ( { C572 , C572 , C570 , C571 } \/ { C570 } ) by ENUMSET1:4
.= ( { C572 , C570 , C571 } \/ { C570 } ) by ENUMSET1:31
.= ( { C570 , C571 , C572 } \/ { C570 } ) by ENUMSET1:59
.= { C570 , C570 , C571 , C572 } by ENUMSET1:4
.= { C570 , C571 , C572 } by ENUMSET1:31;
end;
theorem
L1088: (for B509 , B510 , B511 being set holds (for B512 being (State of ( GFA3CarryCirc (B509 , B510 , B511) )) holds (for B513 , B514 , B515 being (Element of ( BOOLEAN )) holds ((B513 = ( B512 . B509 ) & B514 = ( B512 . B510 ) & B515 = ( B512 . B511 )) implies (( ( Following B512 ) . [ <* B509 , B510 *> , ( and2b ) ] ) = ( ( 'not' B513 ) '&' ( 'not' B514 ) ) & ( ( Following B512 ) . [ <* B510 , B511 *> , ( and2b ) ] ) = ( ( 'not' B514 ) '&' ( 'not' B515 ) ) & ( ( Following B512 ) . [ <* B511 , B509 *> , ( and2b ) ] ) = ( ( 'not' B515 ) '&' ( 'not' B513 ) ))))))
proof
let C573 , C574 , C575 being set;
set D832 = ( and2b );
set D833 = ( and2b );
set D834 = ( and2b );
let C576 being (State of ( GFA3CarryCirc (C573 , C574 , C575) ));
set D835 = [ <* C573 , C574 *> , D832 ];
set D836 = [ <* C574 , C575 *> , D833 ];
set D837 = [ <* C575 , C573 *> , D834 ];
let C577 , C578 , C579 being (Element of ( BOOLEAN ));
assume that
L1089: C577 = ( C576 . C573 )
and
L1090: C578 = ( C576 . C574 )
and
L1091: C579 = ( C576 . C575 );
set D838 = ( GFA3CarryStr (C573 , C574 , C575) );
L1092: ( InnerVertices D838 ) = (the carrier' of D838) by FACIRC_1:37;
L1093: C574 in (the carrier of D838) by L1046;
L1094: C573 in (the carrier of D838) by L1046;
L1095: ( dom C576 ) = (the carrier of D838) by CIRCUIT1:3;
L1096: D835 in ( InnerVertices ( GFA3CarryStr (C573 , C574 , C575) ) ) by L1065;
thus L1097: ( ( Following C576 ) . [ <* C573 , C574 *> , D832 ] ) = ( D832 . ( C576 * <* C573 , C574 *> ) ) by L1096 , L1092 , FACIRC_1:35
.= ( D832 . <* C577 , C578 *> ) by L1089 , L1090 , L1095 , L1094 , L1093 , FINSEQ_2:125
.= ( ( 'not' C577 ) '&' ( 'not' C578 ) ) by TWOSCOMP:def 3;
L1098: C575 in (the carrier of D838) by L1046;
L1099: D836 in ( InnerVertices ( GFA3CarryStr (C573 , C574 , C575) ) ) by L1065;
thus L1100: ( ( Following C576 ) . [ <* C574 , C575 *> , D833 ] ) = ( D833 . ( C576 * <* C574 , C575 *> ) ) by L1099 , L1092 , FACIRC_1:35
.= ( D833 . <* C578 , C579 *> ) by L1090 , L1091 , L1095 , L1093 , L1098 , FINSEQ_2:125
.= ( ( 'not' C578 ) '&' ( 'not' C579 ) ) by TWOSCOMP:def 3;
L1101: D837 in ( InnerVertices ( GFA3CarryStr (C573 , C574 , C575) ) ) by L1065;
thus L1102: ( ( Following C576 ) . [ <* C575 , C573 *> , D834 ] ) = ( D834 . ( C576 * <* C575 , C573 *> ) ) by L1101 , L1092 , FACIRC_1:35
.= ( D834 . <* C579 , C577 *> ) by L1089 , L1091 , L1095 , L1094 , L1098 , FINSEQ_2:125
.= ( ( 'not' C579 ) '&' ( 'not' C577 ) ) by TWOSCOMP:def 3;
end;
theorem
L1103: (for B516 , B517 , B518 being set holds (for B519 being (State of ( GFA3CarryCirc (B516 , B517 , B518) )) holds (for B520 , B521 , B522 being (Element of ( BOOLEAN )) holds ((B520 = ( B519 . [ <* B516 , B517 *> , ( and2b ) ] ) & B521 = ( B519 . [ <* B517 , B518 *> , ( and2b ) ] ) & B522 = ( B519 . [ <* B518 , B516 *> , ( and2b ) ] )) implies ( ( Following B519 ) . ( GFA3CarryOutput (B516 , B517 , B518) ) ) = ( 'not' ( ( B520 'or' B521 ) 'or' B522 ) )))))
proof
let C580 , C581 , C582 being set;
set D839 = ( and2b );
set D840 = ( and2b );
set D841 = ( and2b );
set D842 = ( nor3 );
let C583 being (State of ( GFA3CarryCirc (C580 , C581 , C582) ));
set D843 = [ <* C580 , C581 *> , D839 ];
set D844 = [ <* C581 , C582 *> , D840 ];
set D845 = [ <* C582 , C580 *> , D841 ];
let C584 , C585 , C586 being (Element of ( BOOLEAN ));
assume that
L1104: (C584 = ( C583 . D843 ) & C585 = ( C583 . D844 ) & C586 = ( C583 . D845 ));
set D846 = ( GFA3CarryStr (C580 , C581 , C582) );
reconsider D847 = D843 , D848 = D844 , D849 = D845 as (Element of ( InnerVertices D846 )) by L1065;
L1105: ( dom C583 ) = (the carrier of D846) by CIRCUIT1:3;
L1106: ( InnerVertices D846 ) = (the carrier' of D846) by FACIRC_1:37;
thus L1107: ( ( Following C583 ) . ( GFA3CarryOutput (C580 , C581 , C582) ) ) = ( D842 . ( C583 * <* D847 , D848 , D849 *> ) ) by L1106 , FACIRC_1:35
.= ( D842 . <* C584 , C585 , C586 *> ) by L1104 , L1105 , FINSEQ_2:126
.= ( 'not' ( ( C584 'or' C585 ) 'or' C586 ) ) by TWOSCOMP:def 28;
end;
theorem
L1108: (for B523 , B524 , B525 being set holds ((B523 <> [ <* B524 , B525 *> , ( and2b ) ] & B524 <> [ <* B525 , B523 *> , ( and2b ) ] & B525 <> [ <* B523 , B524 *> , ( and2b ) ]) implies (for B526 being (State of ( GFA3CarryCirc (B523 , B524 , B525) )) holds (for B527 , B528 , B529 being (Element of ( BOOLEAN )) holds ((B527 = ( B526 . B523 ) & B528 = ( B526 . B524 ) & B529 = ( B526 . B525 )) implies (( ( Following (B526 , 2) ) . ( GFA3CarryOutput (B523 , B524 , B525) ) ) = ( 'not' ( ( ( ( 'not' B527 ) '&' ( 'not' B528 ) ) 'or' ( ( 'not' B528 ) '&' ( 'not' B529 ) ) ) 'or' ( ( 'not' B529 ) '&' ( 'not' B527 ) ) ) ) & ( ( Following (B526 , 2) ) . [ <* B523 , B524 *> , ( and2b ) ] ) = ( ( 'not' B527 ) '&' ( 'not' B528 ) ) & ( ( Following (B526 , 2) ) . [ <* B524 , B525 *> , ( and2b ) ] ) = ( ( 'not' B528 ) '&' ( 'not' B529 ) ) & ( ( Following (B526 , 2) ) . [ <* B525 , B523 *> , ( and2b ) ] ) = ( ( 'not' B529 ) '&' ( 'not' B527 ) )))))))
proof
set D850 = ( and2b );
set D851 = ( and2b );
set D852 = ( and2b );
let C587 , C588 , C589 being set;
assume that
L1109: (C587 <> [ <* C588 , C589 *> , D851 ] & C588 <> [ <* C589 , C587 *> , D852 ] & C589 <> [ <* C587 , C588 *> , D850 ]);
set D853 = ( GFA3CarryStr (C587 , C588 , C589) );
reconsider D854 = C587 , D855 = C588 , D856 = C589 as (Vertex of D853) by L1046;
let C590 being (State of ( GFA3CarryCirc (C587 , C588 , C589) ));
L1110: C588 in ( InputVertices D853 ) by L1109 , L1068;
L1111: ( ( Following C590 ) . D855 ) = ( C590 . C588 ) by L1110 , CIRCUIT2:def 5;
L1112: C589 in ( InputVertices D853 ) by L1109 , L1068;
L1113: ( ( Following C590 ) . D856 ) = ( C590 . C589 ) by L1112 , CIRCUIT2:def 5;
set D857 = [ <* C587 , C588 *> , D850 ];
set D858 = [ <* C588 , C589 *> , D851 ];
set D859 = [ <* C589 , C587 *> , D852 ];
L1114: ( Following (C590 , 2) ) = ( Following ( Following C590 ) ) by FACIRC_1:15;
let C591 , C592 , C593 being (Element of ( BOOLEAN ));
assume that
L1115: (C591 = ( C590 . C587 ) & C592 = ( C590 . C588 ) & C593 = ( C590 . C589 ));
L1116: ( ( Following C590 ) . D859 ) = ( ( 'not' C593 ) '&' ( 'not' C591 ) ) by L1115 , L1088;
L1117: (( ( Following C590 ) . D857 ) = ( ( 'not' C591 ) '&' ( 'not' C592 ) ) & ( ( Following C590 ) . D858 ) = ( ( 'not' C592 ) '&' ( 'not' C593 ) )) by L1115 , L1088;
thus L1118: ( ( Following (C590 , 2) ) . ( GFA3CarryOutput (C587 , C588 , C589) ) ) = ( 'not' ( ( ( ( 'not' C591 ) '&' ( 'not' C592 ) ) 'or' ( ( 'not' C592 ) '&' ( 'not' C593 ) ) ) 'or' ( ( 'not' C593 ) '&' ( 'not' C591 ) ) ) ) by L1117 , L1114 , L1116 , L1103;
L1119: C587 in ( InputVertices D853 ) by L1109 , L1068;
L1120: ( ( Following C590 ) . D854 ) = ( C590 . C587 ) by L1119 , CIRCUIT2:def 5;
thus L1121: thesis by L1120 , L1115 , L1111 , L1113 , L1114 , L1088;
end;
theorem
L1122: (for B530 , B531 , B532 being set holds ((B530 <> [ <* B531 , B532 *> , ( and2b ) ] & B531 <> [ <* B532 , B530 *> , ( and2b ) ] & B532 <> [ <* B530 , B531 *> , ( and2b ) ]) implies (for B533 being (State of ( GFA3CarryCirc (B530 , B531 , B532) )) holds ( Following (B533 , 2) ) is  stable)))
proof
set D860 = ( and2b );
set D861 = ( and2b );
set D862 = ( and2b );
let C594 , C595 , C596 being set;
assume that
L1123: (C594 <> [ <* C595 , C596 *> , D861 ] & C595 <> [ <* C596 , C594 *> , D862 ] & C596 <> [ <* C594 , C595 *> , D860 ]);
set D863 = ( GFA3CarryStr (C594 , C595 , C596) );
reconsider D864 = C594 , D865 = C595 , D866 = C596 as (Vertex of D863) by L1046;
let C597 being (State of ( GFA3CarryCirc (C594 , C595 , C596) ));
set D867 = ( C597 . D864 );
set D868 = ( C597 . D865 );
set D869 = ( C597 . D866 );
set D870 = ( Following (C597 , 2) );
set D871 = ( Following D870 );
set D872 = [ <* C594 , C595 *> , D860 ];
set D873 = [ <* C595 , C596 *> , D861 ];
set D874 = [ <* C596 , C594 *> , D862 ];
L1124: D870 = ( Following ( Following C597 ) ) by FACIRC_1:15;
L1125: C596 in ( InputVertices D863 ) by L1123 , L1068;
L1126: ( ( Following C597 ) . C596 ) = D869 by L1125 , CIRCUIT2:def 5;
L1127: ( D870 . C596 ) = D869 by L1126 , L1124 , L1125 , CIRCUIT2:def 5;
L1128: C595 in ( InputVertices D863 ) by L1123 , L1068;
L1129: ( ( Following C597 ) . C595 ) = D868 by L1128 , CIRCUIT2:def 5;
L1130: ( D870 . C595 ) = D868 by L1129 , L1124 , L1128 , CIRCUIT2:def 5;
L1131: C594 in ( InputVertices D863 ) by L1123 , L1068;
L1132: ( ( Following C597 ) . C594 ) = D867 by L1131 , CIRCUIT2:def 5;
L1133: ( D870 . C594 ) = D867 by L1132 , L1124 , L1131 , CIRCUIT2:def 5;
L1134: D869 = ( C597 . C596 );
L1135: ( D870 . D872 ) = ( ( 'not' D867 ) '&' ( 'not' D868 ) ) by L1134 , L1123 , L1108;
L1136: D868 = ( C597 . C595 );
L1137: ( D870 . D874 ) = ( ( 'not' D867 ) '&' ( 'not' D869 ) ) by L1136 , L1123 , L1108;
L1138: D867 = ( C597 . C594 );
L1139: ( D870 . D873 ) = ( ( 'not' D868 ) '&' ( 'not' D869 ) ) by L1138 , L1123 , L1108;
L1140: ( D870 . ( GFA3CarryOutput (C594 , C595 , C596) ) ) = ( 'not' ( ( ( ( 'not' D867 ) '&' ( 'not' D868 ) ) 'or' ( ( 'not' D868 ) '&' ( 'not' D869 ) ) ) 'or' ( ( 'not' D869 ) '&' ( 'not' D867 ) ) ) ) by L1123 , L1108;
L1141:
now
let C598 being set;
assume L1142: C598 in (the carrier of D863);
reconsider D875 = C598 as (Vertex of D863) by L1142;
L1143: D875 in ( ( InputVertices D863 ) \/ ( InnerVertices D863 ) ) by L1142 , XBOOLE_1:45;
thus L1144: ( D870 . C598 ) = ( D871 . C598 )
proof
per cases  by L1143 , XBOOLE_0:def 3;
suppose L1145: D875 in ( InputVertices D863 );

thus L1146: thesis by L1145 , CIRCUIT2:def 5;
end;
suppose L1147: D875 in ( InnerVertices D863 );

L1148: D875 in ( { D872 , D873 , D874 } \/ { ( GFA3CarryOutput (C594 , C595 , C596) ) } ) by L1147 , L1003;
L1149: (D875 in { D872 , D873 , D874 } or D875 in { ( GFA3CarryOutput (C594 , C595 , C596) ) }) by L1148 , XBOOLE_0:def 3;
L1150: (D875 = D872 or D875 = D873 or D875 = D874 or D875 = ( GFA3CarryOutput (C594 , C595 , C596) )) by L1149 , ENUMSET1:def 1 , TARSKI:def 1;
thus L1151: thesis by L1150 , L1140 , L1135 , L1139 , L1137 , L1133 , L1130 , L1127 , L1088 , L1103;
end;
end;

end;
L1145: (( dom ( Following ( Following (C597 , 2) ) ) ) = (the carrier of D863) & ( dom ( Following (C597 , 2) ) ) = (the carrier of D863)) by CIRCUIT1:3;
thus L1146: D870 = D871 by L1145 , L1141 , FUNCT_1:2;
end;
definition
let C599 , C600 , C601 being set;
func GFA3AdderStr (C599 , C600 , C601) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( 2GatesCircStr (C599 , C600 , C601 , ( xor2 )) );
coherence;
end;
definition
let C602 , C603 , C604 being set;
func GFA3AdderCirc (C602 , C603 , C604) ->  strict  Boolean  gate`2=den (Circuit of ( GFA3AdderStr (C602 , C603 , C604) )) equals 
( 2GatesCircuit (C602 , C603 , C604 , ( xor2 )) );
coherence;
end;
definition
let C605 , C606 , C607 being set;
func GFA3AdderOutput (C605 , C606 , C607) -> (Element of ( InnerVertices ( GFA3AdderStr (C605 , C606 , C607) ) )) equals 
( 2GatesCircOutput (C605 , C606 , C607 , ( xor2 )) );
coherence;
end;
theorem
L1150: (for B534 , B535 , B536 being set holds ( InnerVertices ( GFA3AdderStr (B534 , B535 , B536) ) ) = ( { [ <* B534 , B535 *> , ( xor2 ) ] } \/ { ( GFA3AdderOutput (B534 , B535 , B536) ) } ))
proof
let C608 , C609 , C610 being set;
L1151: ( GFA3AdderOutput (C608 , C609 , C610) ) = ( GFA0AdderOutput (C608 , C609 , C610) );
thus L1152: thesis by L1151 , L317;
end;
theorem
L1153: (for B537 , B538 , B539 being set holds (B537 in (the carrier of ( GFA3AdderStr (B537 , B538 , B539) )) & B538 in (the carrier of ( GFA3AdderStr (B537 , B538 , B539) )) & B539 in (the carrier of ( GFA3AdderStr (B537 , B538 , B539) )) & [ <* B537 , B538 *> , ( xor2 ) ] in (the carrier of ( GFA3AdderStr (B537 , B538 , B539) )) & [ <* [ <* B537 , B538 *> , ( xor2 ) ] , B539 *> , ( xor2 ) ] in (the carrier of ( GFA3AdderStr (B537 , B538 , B539) )))) by FACIRC_1:60 , FACIRC_1:61;
theorem
L1154: (for B540 , B541 , B542 being set holds ([ <* B540 , B541 *> , ( xor2 ) ] in ( InnerVertices ( GFA3AdderStr (B540 , B541 , B542) ) ) & ( GFA3AdderOutput (B540 , B541 , B542) ) in ( InnerVertices ( GFA3AdderStr (B540 , B541 , B542) ) )))
proof
let C611 , C612 , C613 being set;
set D876 = ( GFA0AdderStr (C611 , C612 , C613) );
L1155: ( GFA3AdderStr (C611 , C612 , C613) ) = D876;
thus L1156: thesis by L1155 , L320;
end;
theorem
L1157: (for B543 , B544 , B545 being set holds (B545 <> [ <* B543 , B544 *> , ( xor2 ) ] implies (B543 in ( InputVertices ( GFA3AdderStr (B543 , B544 , B545) ) ) & B544 in ( InputVertices ( GFA3AdderStr (B543 , B544 , B545) ) ) & B545 in ( InputVertices ( GFA3AdderStr (B543 , B544 , B545) ) ))))
proof
let C614 , C615 , C616 being set;
assume that
L1158: C616 <> [ <* C614 , C615 *> , ( xor2 ) ];
set D877 = ( GFA0AdderStr (C614 , C615 , C616) );
L1159: ( GFA3AdderStr (C614 , C615 , C616) ) = D877;
thus L1160: thesis by L1159 , L1158 , L323;
end;
theorem
L1161: (for B546 , B547 , B548 being set holds (B548 <> [ <* B546 , B547 *> , ( xor2 ) ] implies (for B549 being (State of ( GFA3AdderCirc (B546 , B547 , B548) )) holds (for B550 , B551 , B552 being (Element of ( BOOLEAN )) holds ((B550 = ( B549 . B546 ) & B551 = ( B549 . B547 ) & B552 = ( B549 . B548 )) implies (( ( Following B549 ) . [ <* B546 , B547 *> , ( xor2 ) ] ) = ( B550 'xor' B551 ) & ( ( Following B549 ) . B546 ) = B550 & ( ( Following B549 ) . B547 ) = B551 & ( ( Following B549 ) . B548 ) = B552))))))
proof
set D878 = ( xor2 );
let C617 , C618 , C619 being set;
assume that
L1162: C619 <> [ <* C617 , C618 *> , D878 ];
set D879 = ( GFA0AdderCirc (C617 , C618 , C619) );
set D880 = ( GFA3AdderCirc (C617 , C618 , C619) );
L1163: D880 = D879;
thus L1164: thesis by L1163 , L1162 , L327;
end;
theorem
L1165: (for B553 , B554 , B555 being set holds (B555 <> [ <* B553 , B554 *> , ( xor2 ) ] implies (for B556 being (State of ( GFA3AdderCirc (B553 , B554 , B555) )) holds (for B557 , B558 , B559 , B560 being (Element of ( BOOLEAN )) holds ((B557 = ( B556 . [ <* B553 , B554 *> , ( xor2 ) ] ) & B558 = ( B556 . B553 ) & B559 = ( B556 . B554 ) & B560 = ( B556 . B555 )) implies ( ( Following B556 ) . ( GFA3AdderOutput (B553 , B554 , B555) ) ) = ( B557 'xor' B560 ))))))
proof
set D881 = ( xor2 );
let C620 , C621 , C622 being set;
assume that
L1166: C622 <> [ <* C620 , C621 *> , D881 ];
set D882 = ( GFA0AdderOutput (C620 , C621 , C622) );
set D883 = ( GFA3AdderOutput (C620 , C621 , C622) );
set D884 = ( GFA0AdderCirc (C620 , C621 , C622) );
set D885 = ( GFA3AdderCirc (C620 , C621 , C622) );
L1167: (D885 = D884 & D883 = D882);
thus L1168: thesis by L1167 , L1166 , L334;
end;
theorem
L1169: (for B561 , B562 , B563 being set holds (B563 <> [ <* B561 , B562 *> , ( xor2 ) ] implies (for B564 being (State of ( GFA3AdderCirc (B561 , B562 , B563) )) holds (for B565 , B566 , B567 being (Element of ( BOOLEAN )) holds ((B565 = ( B564 . B561 ) & B566 = ( B564 . B562 ) & B567 = ( B564 . B563 )) implies (( ( Following (B564 , 2) ) . ( GFA3AdderOutput (B561 , B562 , B563) ) ) = ( ( B565 'xor' B566 ) 'xor' B567 ) & ( ( Following (B564 , 2) ) . [ <* B561 , B562 *> , ( xor2 ) ] ) = ( B565 'xor' B566 ) & ( ( Following (B564 , 2) ) . B561 ) = B565 & ( ( Following (B564 , 2) ) . B562 ) = B566 & ( ( Following (B564 , 2) ) . B563 ) = B567))))))
proof
set D886 = ( xor2 );
let C623 , C624 , C625 being set;
assume that
L1170: C625 <> [ <* C623 , C624 *> , D886 ];
set D887 = ( GFA0AdderOutput (C623 , C624 , C625) );
set D888 = ( GFA3AdderOutput (C623 , C624 , C625) );
set D889 = ( GFA0AdderCirc (C623 , C624 , C625) );
set D890 = ( GFA3AdderCirc (C623 , C624 , C625) );
L1171: (D890 = D889 & D888 = D887);
thus L1172: thesis by L1171 , L1170 , L338;
end;
theorem
L1173: (for B568 , B569 , B570 being set holds (B570 <> [ <* B568 , B569 *> , ( xor2 ) ] implies (for B571 being (State of ( GFA3AdderCirc (B568 , B569 , B570) )) holds (for B572 , B573 , B574 being (Element of ( BOOLEAN )) holds ((B572 = ( B571 . B568 ) & B573 = ( B571 . B569 ) & B574 = ( B571 . B570 )) implies ( ( Following (B571 , 2) ) . ( GFA3AdderOutput (B568 , B569 , B570) ) ) = ( 'not' ( ( ( 'not' B572 ) 'xor' ( 'not' B573 ) ) 'xor' ( 'not' B574 ) ) ))))))
proof
set D891 = ( xor2 );
let C626 , C627 , C628 being set;
assume that
L1174: C628 <> [ <* C626 , C627 *> , D891 ];
set D892 = ( GFA3AdderCirc (C626 , C627 , C628) );
let C629 being (State of D892);
let C630 , C631 , C632 being (Element of ( BOOLEAN ));
assume L1175: (C630 = ( C629 . C626 ) & C631 = ( C629 . C627 ) & C632 = ( C629 . C628 ));
thus L1176: ( ( Following (C629 , 2) ) . ( GFA3AdderOutput (C626 , C627 , C628) ) ) = ( ( C630 'xor' C631 ) 'xor' C632 ) by L1175 , L1174 , L1169
.= ( 'not' ( ( ( 'not' C630 ) 'xor' ( 'not' C631 ) ) 'xor' ( 'not' C632 ) ) ) by XBOOLEAN:74;
end;
definition
let C633 , C634 , C635 being set;
func BitGFA3Str (C633 , C634 , C635) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( GFA3AdderStr (C633 , C634 , C635) ) +* ( GFA3CarryStr (C633 , C634 , C635) ) );
coherence;
end;
definition
let C636 , C637 , C638 being set;
func BitGFA3Circ (C636 , C637 , C638) ->  strict  Boolean  gate`2=den (Circuit of ( BitGFA3Str (C636 , C637 , C638) )) equals 
( ( GFA3AdderCirc (C636 , C637 , C638) ) +* ( GFA3CarryCirc (C636 , C637 , C638) ) );
coherence;
end;
theorem
L1179: (for B575 , B576 , B577 being set holds ( InnerVertices ( BitGFA3Str (B575 , B576 , B577) ) ) = ( ( ( { [ <* B575 , B576 *> , ( xor2 ) ] } \/ { ( GFA3AdderOutput (B575 , B576 , B577) ) } ) \/ { [ <* B575 , B576 *> , ( and2b ) ] , [ <* B576 , B577 *> , ( and2b ) ] , [ <* B577 , B575 *> , ( and2b ) ] } ) \/ { ( GFA3CarryOutput (B575 , B576 , B577) ) } ))
proof
let C639 , C640 , C641 being set;
set D893 = ( and2b );
set D894 = ( and2b );
set D895 = ( and2b );
set D896 = ( xor2 );
set D897 = [ <* C639 , C640 *> , D896 ];
set D898 = [ <* C639 , C640 *> , D893 ];
set D899 = [ <* C640 , C641 *> , D894 ];
set D900 = [ <* C641 , C639 *> , D895 ];
set D901 = ( BitGFA3Str (C639 , C640 , C641) );
set D902 = ( GFA3AdderStr (C639 , C640 , C641) );
set D903 = ( GFA3CarryStr (C639 , C640 , C641) );
set D904 = ( GFA3AdderOutput (C639 , C640 , C641) );
set D905 = ( GFA3CarryOutput (C639 , C640 , C641) );
thus L1180: ( InnerVertices D901 ) = ( ( InnerVertices D902 ) \/ ( InnerVertices D903 ) ) by FACIRC_1:27
.= ( ( { D897 } \/ { D904 } ) \/ ( InnerVertices D903 ) ) by L1150
.= ( ( { D897 } \/ { D904 } ) \/ ( { D898 , D899 , D900 } \/ { D905 } ) ) by L1003
.= ( ( ( { D897 } \/ { D904 } ) \/ { D898 , D899 , D900 } ) \/ { D905 } ) by XBOOLE_1:4;
end;
theorem
L1181: (for B578 , B579 , B580 being set holds ( InnerVertices ( BitGFA3Str (B578 , B579 , B580) ) ) is Relation)
proof
let C642 , C643 , C644 being set;
set D906 = ( GFA3AdderStr (C642 , C643 , C644) );
set D907 = ( GFA3CarryStr (C642 , C643 , C644) );
L1182: (( InnerVertices D906 ) is Relation & ( InnerVertices D907 ) is Relation) by L1010 , FACIRC_1:58;
thus L1183: thesis by L1182 , FACIRC_1:3;
end;
theorem
L1184: (for B581 , B582 , B583 being set holds ((B583 <> [ <* B581 , B582 *> , ( xor2 ) ] & B581 <> [ <* B582 , B583 *> , ( and2b ) ] & B582 <> [ <* B583 , B581 *> , ( and2b ) ] & B583 <> [ <* B581 , B582 *> , ( and2b ) ]) implies ( InputVertices ( BitGFA3Str (B581 , B582 , B583) ) ) = { B581 , B582 , B583 }))
proof
set D908 = ( and2b );
set D909 = ( and2b );
set D910 = ( and2b );
set D911 = ( xor2 );
let C645 , C646 , C647 being set;
assume that
L1185: (C647 <> [ <* C645 , C646 *> , D911 ] & C645 <> [ <* C646 , C647 *> , D909 ] & C646 <> [ <* C647 , C645 *> , D910 ] & C647 <> [ <* C645 , C646 *> , D908 ]);
set D912 = ( GFA3CarryStr (C645 , C646 , C647) );
set D913 = ( GFA3AdderStr (C645 , C646 , C647) );
L1186: (( InputVertices D913 ) = { C645 , C646 , C647 } & ( InputVertices D912 ) = { C645 , C646 , C647 }) by L1185 , L1025 , FACIRC_1:57;
thus L1187: thesis by L1186 , CIRCCOMB:47 , FACIRC_2:21;
end;
theorem
L1188: (for B584 , B585 , B586 being non  pair set holds ( InputVertices ( BitGFA3Str (B584 , B585 , B586) ) ) = { B584 , B585 , B586 })
proof
let C648 , C649 , C650 being non  pair set;
set D914 = ( BitGFA3Str (C648 , C649 , C650) );
set D915 = ( GFA3AdderStr (C648 , C649 , C650) );
set D916 = ( GFA3CarryStr (C648 , C649 , C650) );
L1189: (( InputVertices D915 ) = { C648 , C649 , C650 } & ( InputVertices D916 ) = { C648 , C649 , C650 }) by L1072 , FACIRC_1:57;
L1190: (( InnerVertices D915 ) is Relation & ( InnerVertices D916 ) is Relation) by L1010 , FACIRC_1:58;
thus L1191: ( InputVertices D914 ) = ( { C648 , C649 , C650 } \/ { C648 , C649 , C650 } ) by L1190 , L1189 , FACIRC_1:7
.= { C648 , C649 , C650 };
end;
theorem
L1192: (for B587 , B588 , B589 being non  pair set holds ( InputVertices ( BitGFA3Str (B587 , B588 , B589) ) ) is  without_pairs)
proof
let C651 , C652 , C653 being non  pair set;
L1193: ( InputVertices ( BitGFA3Str (C651 , C652 , C653) ) ) = { C651 , C652 , C653 } by L1188;
thus L1194: thesis by L1193;
end;
theorem
L1195: (for B590 , B591 , B592 being set holds (B590 in (the carrier of ( BitGFA3Str (B590 , B591 , B592) )) & B591 in (the carrier of ( BitGFA3Str (B590 , B591 , B592) )) & B592 in (the carrier of ( BitGFA3Str (B590 , B591 , B592) )) & [ <* B590 , B591 *> , ( xor2 ) ] in (the carrier of ( BitGFA3Str (B590 , B591 , B592) )) & [ <* [ <* B590 , B591 *> , ( xor2 ) ] , B592 *> , ( xor2 ) ] in (the carrier of ( BitGFA3Str (B590 , B591 , B592) )) & [ <* B590 , B591 *> , ( and2b ) ] in (the carrier of ( BitGFA3Str (B590 , B591 , B592) )) & [ <* B591 , B592 *> , ( and2b ) ] in (the carrier of ( BitGFA3Str (B590 , B591 , B592) )) & [ <* B592 , B590 *> , ( and2b ) ] in (the carrier of ( BitGFA3Str (B590 , B591 , B592) )) & [ <* [ <* B590 , B591 *> , ( and2b ) ] , [ <* B591 , B592 *> , ( and2b ) ] , [ <* B592 , B590 *> , ( and2b ) ] *> , ( nor3 ) ] in (the carrier of ( BitGFA3Str (B590 , B591 , B592) ))))
proof
let C654 , C655 , C656 being set;
set D917 = ( and2b );
set D918 = ( and2b );
set D919 = ( and2b );
set D920 = ( nor3 );
set D921 = ( xor2 );
set D922 = [ <* C654 , C655 *> , D917 ];
set D923 = [ <* C655 , C656 *> , D918 ];
set D924 = [ <* C656 , C654 *> , D919 ];
set D925 = [ <* D922 , D923 , D924 *> , D920 ];
set D926 = ( GFA3AdderStr (C654 , C655 , C656) );
set D927 = ( GFA3CarryStr (C654 , C655 , C656) );
L1196: (C654 in (the carrier of D926) & C655 in (the carrier of D926)) by FACIRC_1:60;
L1197: (C656 in (the carrier of D926) & [ <* C654 , C655 *> , D921 ] in (the carrier of D926)) by FACIRC_1:60 , FACIRC_1:61;
L1198: D925 in (the carrier of D927) by L1046;
L1199: (D923 in (the carrier of D927) & D924 in (the carrier of D927)) by L1046;
L1200: ([ <* [ <* C654 , C655 *> , D921 ] , C656 *> , D921 ] in (the carrier of D926) & D922 in (the carrier of D927)) by L1046 , FACIRC_1:61;
thus L1201: thesis by L1200 , L1196 , L1197 , L1199 , L1198 , FACIRC_1:20;
end;
theorem
L1202: (for B593 , B594 , B595 being set holds ([ <* B593 , B594 *> , ( xor2 ) ] in ( InnerVertices ( BitGFA3Str (B593 , B594 , B595) ) ) & ( GFA3AdderOutput (B593 , B594 , B595) ) in ( InnerVertices ( BitGFA3Str (B593 , B594 , B595) ) ) & [ <* B593 , B594 *> , ( and2b ) ] in ( InnerVertices ( BitGFA3Str (B593 , B594 , B595) ) ) & [ <* B594 , B595 *> , ( and2b ) ] in ( InnerVertices ( BitGFA3Str (B593 , B594 , B595) ) ) & [ <* B595 , B593 *> , ( and2b ) ] in ( InnerVertices ( BitGFA3Str (B593 , B594 , B595) ) ) & ( GFA3CarryOutput (B593 , B594 , B595) ) in ( InnerVertices ( BitGFA3Str (B593 , B594 , B595) ) )))
proof
let C657 , C658 , C659 being set;
set D928 = ( and2b );
set D929 = ( and2b );
set D930 = ( and2b );
set D931 = ( xor2 );
set D932 = [ <* C657 , C658 *> , D931 ];
set D933 = [ <* C657 , C658 *> , D928 ];
set D934 = [ <* C658 , C659 *> , D929 ];
set D935 = [ <* C659 , C657 *> , D930 ];
set D936 = ( BitGFA3Str (C657 , C658 , C659) );
set D937 = ( GFA3AdderOutput (C657 , C658 , C659) );
set D938 = ( GFA3CarryOutput (C657 , C658 , C659) );
L1203: ( InnerVertices D936 ) = ( ( ( { D932 } \/ { D937 } ) \/ { D933 , D934 , D935 } ) \/ { D938 } ) by L1179
.= ( ( { D932 , D937 } \/ { D933 , D934 , D935 } ) \/ { D938 } ) by ENUMSET1:1
.= ( { D932 , D937 , D933 , D934 , D935 } \/ { D938 } ) by ENUMSET1:8
.= { D932 , D937 , D933 , D934 , D935 , D938 } by ENUMSET1:15;
thus L1204: thesis by L1203 , ENUMSET1:def 4;
end;
theorem
L1205: (for B596 , B597 , B598 being set holds ((B598 <> [ <* B596 , B597 *> , ( xor2 ) ] & B596 <> [ <* B597 , B598 *> , ( and2b ) ] & B597 <> [ <* B598 , B596 *> , ( and2b ) ] & B598 <> [ <* B596 , B597 *> , ( and2b ) ]) implies (B596 in ( InputVertices ( BitGFA3Str (B596 , B597 , B598) ) ) & B597 in ( InputVertices ( BitGFA3Str (B596 , B597 , B598) ) ) & B598 in ( InputVertices ( BitGFA3Str (B596 , B597 , B598) ) ))))
proof
set D939 = ( and2b );
set D940 = ( and2b );
set D941 = ( and2b );
set D942 = ( xor2 );
let C660 , C661 , C662 being set;
assume that
L1206: (C662 <> [ <* C660 , C661 *> , D942 ] & C660 <> [ <* C661 , C662 *> , D940 ] & C661 <> [ <* C662 , C660 *> , D941 ] & C662 <> [ <* C660 , C661 *> , D939 ]);
set D943 = ( BitGFA3Str (C660 , C661 , C662) );
L1207: ( InputVertices D943 ) = { C660 , C661 , C662 } by L1206 , L1184;
thus L1208: thesis by L1207 , ENUMSET1:def 1;
end;
definition
let C663 , C664 , C665 being set;
func BitGFA3CarryOutput (C663 , C664 , C665) -> (Element of ( InnerVertices ( BitGFA3Str (C663 , C664 , C665) ) )) equals 
[ <* [ <* C663 , C664 *> , ( and2b ) ] , [ <* C664 , C665 *> , ( and2b ) ] , [ <* C665 , C663 *> , ( and2b ) ] *> , ( nor3 ) ];
coherence
proof
L1209: ( GFA3CarryOutput (C663 , C664 , C665) ) in ( InnerVertices ( BitGFA3Str (C663 , C664 , C665) ) ) by L1202;
thus L1210: thesis by L1209;
end;
end;
definition
let C666 , C667 , C668 being set;
func BitGFA3AdderOutput (C666 , C667 , C668) -> (Element of ( InnerVertices ( BitGFA3Str (C666 , C667 , C668) ) )) equals 
( 2GatesCircOutput (C666 , C667 , C668 , ( xor2 )) );
coherence
proof
L1212: ( GFA3AdderOutput (C666 , C667 , C668) ) in ( InnerVertices ( BitGFA3Str (C666 , C667 , C668) ) ) by L1202;
thus L1213: thesis by L1212;
end;
end;
theorem
L1215: (for B599 , B600 , B601 being set holds ((B601 <> [ <* B599 , B600 *> , ( xor2 ) ] & B599 <> [ <* B600 , B601 *> , ( and2b ) ] & B600 <> [ <* B601 , B599 *> , ( and2b ) ] & B601 <> [ <* B599 , B600 *> , ( and2b ) ]) implies (for B602 being (State of ( BitGFA3Circ (B599 , B600 , B601) )) holds (for B603 , B604 , B605 being (Element of ( BOOLEAN )) holds ((B603 = ( B602 . B599 ) & B604 = ( B602 . B600 ) & B605 = ( B602 . B601 )) implies (( ( Following (B602 , 2) ) . ( GFA3AdderOutput (B599 , B600 , B601) ) ) = ( 'not' ( ( ( 'not' B603 ) 'xor' ( 'not' B604 ) ) 'xor' ( 'not' B605 ) ) ) & ( ( Following (B602 , 2) ) . ( GFA3CarryOutput (B599 , B600 , B601) ) ) = ( 'not' ( ( ( ( 'not' B603 ) '&' ( 'not' B604 ) ) 'or' ( ( 'not' B604 ) '&' ( 'not' B605 ) ) ) 'or' ( ( 'not' B605 ) '&' ( 'not' B603 ) ) ) )))))))
proof
set D944 = ( and2b );
set D945 = ( and2b );
set D946 = ( and2b );
set D947 = ( xor2 );
let C669 , C670 , C671 being set;
assume that
L1216: C671 <> [ <* C669 , C670 *> , D947 ]
and
L1217: (C669 <> [ <* C670 , C671 *> , D945 ] & C670 <> [ <* C671 , C669 *> , D946 ] & C671 <> [ <* C669 , C670 *> , D944 ]);
set D948 = ( GFA3CarryStr (C669 , C670 , C671) );
set D949 = ( GFA3AdderStr (C669 , C670 , C671) );
L1218: ( InputVertices D949 ) = { C669 , C670 , C671 } by L1216 , FACIRC_1:57;
L1219: ( InputVertices D949 ) = ( InputVertices D948 ) by L1218 , L1217 , L1025;
set D950 = ( GFA3CarryCirc (C669 , C670 , C671) );
set D951 = ( GFA3AdderCirc (C669 , C670 , C671) );
set D952 = ( BitGFA3Circ (C669 , C670 , C671) );
let C672 being (State of D952);
let C673 , C674 , C675 being (Element of ( BOOLEAN ));
assume that
L1220: C673 = ( C672 . C669 )
and
L1221: C674 = ( C672 . C670 )
and
L1222: C675 = ( C672 . C671 );
reconsider D953 = ( C672 | (the carrier of D949) ) as (State of D951) by FACIRC_1:26;
L1223: ( dom D953 ) = (the carrier of D949) by CIRCUIT1:3;
L1224: C671 in (the carrier of D949) by FACIRC_1:60;
L1225: C675 = ( D953 . C671 ) by L1224 , L1222 , L1223 , FUNCT_1:47;
L1226: C670 in (the carrier of D949) by FACIRC_1:60;
L1227: C674 = ( D953 . C670 ) by L1226 , L1221 , L1223 , FUNCT_1:47;
reconsider D954 = C672 as (State of ( D951 +* D950 ));
L1228: ( InnerVertices D948 ) misses ( InputVertices D948 ) by XBOOLE_1:79;
L1229: ( ( Following (D954 , 2) ) . ( GFA3AdderOutput (C669 , C670 , C671) ) ) = ( ( Following (D953 , 2) ) . ( GFA3AdderOutput (C669 , C670 , C671) ) ) by L1228 , L1219 , FACIRC_1:32;
reconsider D955 = ( C672 | (the carrier of D948) ) as (State of D950) by FACIRC_1:26;
L1230: ( dom D955 ) = (the carrier of D948) by CIRCUIT1:3;
L1231: C669 in (the carrier of D949) by FACIRC_1:60;
L1232: C673 = ( D953 . C669 ) by L1231 , L1220 , L1223 , FUNCT_1:47;
thus L1233: ( ( Following (C672 , 2) ) . ( GFA3AdderOutput (C669 , C670 , C671) ) ) = ( 'not' ( ( ( 'not' C673 ) 'xor' ( 'not' C674 ) ) 'xor' ( 'not' C675 ) ) ) by L1232 , L1216 , L1227 , L1225 , L1229 , L1173;
L1234: ( InnerVertices D949 ) misses ( InputVertices D949 ) by XBOOLE_1:79;
L1235: ( ( Following (D954 , 2) ) . ( GFA3CarryOutput (C669 , C670 , C671) ) ) = ( ( Following (D955 , 2) ) . ( GFA3CarryOutput (C669 , C670 , C671) ) ) by L1234 , L1219 , FACIRC_1:33;
L1236: C671 in (the carrier of D948) by L1046;
L1237: C675 = ( D955 . C671 ) by L1236 , L1222 , L1230 , FUNCT_1:47;
L1238: C670 in (the carrier of D948) by L1046;
L1239: C674 = ( D955 . C670 ) by L1238 , L1221 , L1230 , FUNCT_1:47;
L1240: C669 in (the carrier of D948) by L1046;
L1241: C673 = ( D955 . C669 ) by L1240 , L1220 , L1230 , FUNCT_1:47;
thus L1242: thesis by L1241 , L1217 , L1239 , L1237 , L1235 , L1108;
end;
theorem
L1243: (for B606 , B607 , B608 being set holds ((B608 <> [ <* B606 , B607 *> , ( xor2 ) ] & B606 <> [ <* B607 , B608 *> , ( and2b ) ] & B607 <> [ <* B608 , B606 *> , ( and2b ) ] & B608 <> [ <* B606 , B607 *> , ( and2b ) ]) implies (for B609 being (State of ( BitGFA3Circ (B606 , B607 , B608) )) holds ( Following (B609 , 2) ) is  stable)))
proof
set D956 = ( and2b );
set D957 = ( and2b );
set D958 = ( and2b );
set D959 = ( xor2 );
let C676 , C677 , C678 being set;
assume that
L1244: C678 <> [ <* C676 , C677 *> , D959 ]
and
L1245: (C676 <> [ <* C677 , C678 *> , D957 ] & C677 <> [ <* C678 , C676 *> , D958 ] & C678 <> [ <* C676 , C677 *> , D956 ]);
set D960 = ( BitGFA3Circ (C676 , C677 , C678) );
let C679 being (State of D960);
set D961 = ( GFA3CarryStr (C676 , C677 , C678) );
set D962 = ( GFA3AdderStr (C676 , C677 , C678) );
L1246: ( InputVertices D962 ) = { C676 , C677 , C678 } by L1244 , FACIRC_1:57;
L1247: ( InputVertices D962 ) = ( InputVertices D961 ) by L1246 , L1245 , L1025;
set D963 = ( GFA3AdderCirc (C676 , C677 , C678) );
reconsider D964 = ( C679 | (the carrier of D962) ) as (State of D963) by FACIRC_1:26;
L1248: ( Following (D964 , 2) ) is  stable by L1244 , FACIRC_1:63;
L1249: ( Following (D964 , 2) ) = ( Following ( Following (D964 , 2) ) ) by L1248 , CIRCUIT2:def 6
.= ( Following (D964 , ( 2 + 1 )) ) by FACIRC_1:12;
set D965 = ( GFA3CarryCirc (C676 , C677 , C678) );
reconsider D966 = ( C679 | (the carrier of D961) ) as (State of D965) by FACIRC_1:26;
L1250: ( Following (D966 , 2) ) is  stable by L1245 , L1122;
L1251: ( Following (D966 , 2) ) = ( Following ( Following (D966 , 2) ) ) by L1250 , CIRCUIT2:def 6
.= ( Following (D966 , ( 2 + 1 )) ) by FACIRC_1:12;
reconsider D967 = C679 as (State of ( D963 +* D965 ));
set D968 = ( BitGFA3Str (C676 , C677 , C678) );
L1252: ( dom ( Following (C679 , 3) ) ) = (the carrier of D968) by CIRCUIT1:3;
L1253: ( InnerVertices D961 ) misses ( InputVertices D961 ) by XBOOLE_1:79;
L1254: (( Following (D964 , 2) ) = ( ( Following (D967 , 2) ) | (the carrier of D962) ) & ( Following (D964 , 3) ) = ( ( Following (D967 , 3) ) | (the carrier of D962) )) by L1253 , L1247 , FACIRC_1:30;
L1255: ( InnerVertices D962 ) misses ( InputVertices D962 ) by XBOOLE_1:79;
L1256: (( Following (D966 , 2) ) = ( ( Following (D967 , 2) ) | (the carrier of D961) ) & ( Following (D966 , 3) ) = ( ( Following (D967 , 3) ) | (the carrier of D961) )) by L1255 , L1247 , FACIRC_1:31;
L1257: (the carrier of D968) = ( (the carrier of D962) \/ (the carrier of D961) ) by CIRCCOMB:def 2;
L1258: (( dom ( Following (D964 , 2) ) ) = (the carrier of D962) & ( dom ( Following (D966 , 2) ) ) = (the carrier of D961)) by CIRCUIT1:3;
L1259:
now
let C680 being set;
assume L1260: C680 in (the carrier of D968);
L1261: (C680 in (the carrier of D962) or C680 in (the carrier of D961)) by L1260 , L1257 , XBOOLE_0:def 3;
L1262: ((( ( Following (C679 , 2) ) . C680 ) = ( ( Following (D964 , 2) ) . C680 ) & ( ( Following (C679 , 3) ) . C680 ) = ( ( Following (D964 , 3) ) . C680 )) or (( ( Following (C679 , 2) ) . C680 ) = ( ( Following (D966 , 2) ) . C680 ) & ( ( Following (C679 , 3) ) . C680 ) = ( ( Following (D966 , 3) ) . C680 ))) by L1261 , L1254 , L1256 , L1249 , L1251 , L1258 , FUNCT_1:47;
thus L1263: ( ( Following (C679 , 2) ) . C680 ) = ( ( Following ( Following (C679 , 2) ) ) . C680 ) by L1262 , L1249 , L1251 , FACIRC_1:12;
end;
L1264: (( Following (C679 , ( 2 + 1 )) ) = ( Following ( Following (C679 , 2) ) ) & ( dom ( Following (C679 , 2) ) ) = (the carrier of D968)) by CIRCUIT1:3 , FACIRC_1:12;
thus L1265: ( Following (C679 , 2) ) = ( Following ( Following (C679 , 2) ) ) by L1264 , L1252 , L1259 , FUNCT_1:2;
end;
