:: Initialization Halting Concepts and Their Basic Properties of SCM+FSA
::  by JingChao Chen and Yatsuka Nakamura
::
:: Received June 17, 1998
:: Copyright (c) 1998-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMFSA_2, FSM_1, SCMFSA6A, TARSKI,
      CIRCUIT2, RELAT_1, FUNCT_1, CARD_1, FUNCOP_1, FUNCT_4, XBOOLE_0,
      SCMFSA6B, NAT_1, XXREAL_0, ARYTM_3, AMI_3, SF_MASTR, GRAPHSP, MSUALG_1,
      AMISTD_2, TURING_1, STRUCT_0, VALUED_1, SCMFSA6C, SCMFSA7B, UNIALG_2,
      SCMFSA8B, ARYTM_1, SCMFSA8C, SCMFSA8A, SCM_HALT, PARTFUN1, EXTPRO_1,
      RELOC, COMPOS_1, SCMPDS_4;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      ORDINAL1, NAT_1, RELAT_1, FINSEQ_1, FUNCT_1, PARTFUN1, FUNCT_4, FUNCT_7,
      PBOOLE, VALUED_1, STRUCT_0, MEMSTR_0, COMPOS_0,
      COMPOS_1, EXTPRO_1, AMISTD_1,
      AMISTD_2, SCMFSA_2, FUNCOP_1, SCMFSA6B, SCMFSA6A, SF_MASTR, SCMFSA8A,
      SCMFSA8B, SFMASTR1, SCMFSA8C, SCMFSA7B, NAT_D, SCMFSA_3, SCMFSA6C,
      XXREAL_0, SCMFSA_M;
 constructors SFMASTR1, DOMAIN_1, XXREAL_0, REAL_1, SCM_1, SCMFSA_3, SCMFSA6A,
      SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMFSA8C, AMISTD_1,
      AMISTD_2, NAT_D, RELSET_1, VALUED_1, SCMFSA7B, SCMFSA_9, AMISTD_5,
      PBOOLE, PRE_POLY, MEMSTR_0, SCMFSA_1, SCMFSA_M, FUNCT_7;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B,
      SCMFSA8A, SCMFSA8C, SCMFSA_9, ORDINAL1, RELAT_1, SCMFSA10, AMISTD_2,
      COMPOS_1, SFMASTR1, EXTPRO_1, SCMFSA_4, PBOOLE, FUNCT_4, FUNCT_7,
      PRE_POLY, STRUCT_0, FUNCOP_1, MEMSTR_0, FINSEQ_1, AMI_3, COMPOS_0,
      SCMFSA_M;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, XBOOLE_0, SCMFSA_2, SCMFSA8C,
      SCMFSA6A, AMISTD_2, SCMFSA7B, MEMSTR_0, COMPOS_0, SCMFSA_M;
 theorems SF_MASTR, FUNCT_1, FUNCT_7, FUNCOP_1, RELAT_1, SCMFSA6A, FUNCT_4,
      ENUMSET1, AMI_3, NAT_1, TARSKI, INT_1, GRFUNC_1, SCMFSA_2, SCMFSA6B,
      SCMFSA7B, SCMFSA8B, SCMFSA8A, SCMFSA8C, SCMFSA_3, SCMFSA6C, CARD_1,
      XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, XXREAL_0, VALUED_1, XREAL_0,
      PBOOLE, PARTFUN1, AFINSQ_1, FINSEQ_4, COMPOS_1, SFMASTR1, EXTPRO_1,
      AMISTD_2, AMISTD_5, ZFMISC_1, MEMSTR_0, AMISTD_1, STRUCT_0, AMI_2,
      COMPOS_0, SCMFSA_M;
 schemes NAT_1;

begin
set D1 = ( Start-At (( 0 ) , ( SCM+FSA )) );
set D2 = ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) );
reconsider D3 = ( {} ) as (PartState of ( SCM+FSA )) by FUNCT_1:104 , RELAT_1:171;
L1: ( IC D2 ) = ( 0 ) by MEMSTR_0:def 11;
L2: D1 c= D2 by FUNCT_4:25;
L3: ( dom D2 ) = ( ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) \/ ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) ) by FUNCT_4:def 1
.= ( { ( intloc ( 0 ) ) } \/ ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) ) by FUNCOP_1:13
.= ( { ( intloc ( 0 ) ) } \/ { ( IC ( SCM+FSA ) ) } ) by FUNCOP_1:13;
definition
let C1 being (Program of ( SCM+FSA ));
attr C1 is  InitClosed
means
:L4: (for B1 being (State of ( SCM+FSA )) holds (for B2 being (Instruction-Sequence of ( SCM+FSA )) holds (C1 c= B2 implies (for B3 being (Element of ( NAT )) holds (( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= B1 implies ( IC ( Comput (B2 , B1 , B3) ) ) in ( dom C1 ))))));
attr C1 is  InitHalting
means
:L5: (for B4 being (State of ( SCM+FSA )) holds (( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= B4 implies (for B5 being (Instruction-Sequence of ( SCM+FSA )) holds (C1 c= B5 implies B5 halts_on B4))));
attr C1 is  keepInt0_1
means
:L6: (for B6 being (State of ( SCM+FSA )) holds (( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= B6 implies (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (C1 c= R9 implies (for B7 being (Element of ( NAT )) holds ( ( Comput (R9 , B6 , B7) ) . ( intloc ( 0 ) ) ) = 1)))));
end;
canceled 1;
theorem
L8: ( Macro ( halt ( SCM+FSA ) ) ) is  InitHalting
proof
let C2 being (State of ( SCM+FSA ));
set D4 = ( Macro ( halt ( SCM+FSA ) ) );
set D5 = D4;
assume L9: D2 c= C2;
let C3 being (Instruction-Sequence of ( SCM+FSA ));
assume L10: D4 c= C3;
L11: ( IC ( SCM+FSA ) ) in ( dom D2 ) by MEMSTR_0:48;
take ( 0 );
L12: ( IC ( Comput (C3 , C2 , ( 0 )) ) ) in ( NAT );
thus L13: ( IC ( Comput (C3 , C2 , ( 0 )) ) ) in ( dom C3 ) by L12 , PARTFUN1:def 2;
L14: ( D4 . ( 0 ) ) = ( halt ( SCM+FSA ) ) by COMPOS_1:58;
L15: ( dom D4 ) = { ( 0 ) , 1 } by COMPOS_1:61;
L16: ( 0 ) in ( dom D4 ) by L15 , TARSKI:def 2;
L17: ( C3 /. ( IC C2 ) ) = ( C3 . ( IC C2 ) ) by PBOOLE:143;
L18: ( CurInstr (C3 , ( Comput (C3 , C2 , ( 0 )) )) ) = ( CurInstr (C3 , C2) )
.= ( C3 . ( 0 ) ) by L1 , L9 , L17 , L11 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by L14 , L10 , L16 , GRFUNC_1:2;
thus L19: thesis by L18;
end;
registration
cluster  InitHalting for (Program of ( SCM+FSA ));
existence by L8;
end;
registration
cluster  paraclosed ->  InitClosed for (Program of ( SCM+FSA ));
coherence
proof
let C4 being (Program of ( SCM+FSA ));
assume L21: C4 is  paraclosed;
let C5 being (State of ( SCM+FSA ));
let C6 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L22: C4 c= C6;
let C7 being (Element of ( NAT ));
assume that
L23: D2 c= C5;
L24: D1 c= D2 by FUNCT_4:25;
L25: D1 c= C5 by L24 , L23 , XBOOLE_1:1;
L26: C5 is ( 0 ) -started by L25 , MEMSTR_0:29;
thus L27: ( IC ( Comput (C6 , C5 , C7) ) ) in ( dom C4 ) by L26 , L21 , L22 , AMISTD_1:def 10;
end;
end;
registration
cluster  parahalting ->  InitHalting for (Program of ( SCM+FSA ));
coherence
proof
let C8 being (Program of ( SCM+FSA ));
assume L29: C8 is  parahalting;
let C9 being (State of ( SCM+FSA ));
assume that
L30: D2 c= C9;
let C10 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L31: C8 c= C10;
L32: D1 c= D2 by FUNCT_4:25;
L33: D1 c= C9 by L32 , L30 , XBOOLE_1:1;
L34: C9 is ( 0 ) -started by L33 , MEMSTR_0:29;
thus L35: C10 halts_on C9 by L34 , L29 , L31 , AMISTD_1:def 11;
end;
end;
registration
cluster  InitHalting ->  InitClosed for (Program of ( SCM+FSA ));
coherence
proof
let C11 being (Program of ( SCM+FSA ));
assume L37: C11 is  InitHalting;
let C12 being (State of ( SCM+FSA ));
let C13 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L38: C11 c= C13;
let C14 being (Element of ( NAT ));
assume L39: D2 c= C12;
defpred S1[ Nat ] means (not ( IC ( Comput (C13 , C12 , $1) ) ) in ( dom C11 ));
assume L40: (not ( IC ( Comput (C13 , C12 , C14) ) ) in ( dom C11 ));
L41: (ex B8 being Nat st S1[ B8 ]) by L40;
consider C15 being Nat such that L42: S1[ C15 ] and L43: (for B9 being Nat holds (S1[ B9 ] implies C15 <= B9)) from NAT_1:sch 5(L41);
reconsider D6 = C15 as (Element of ( NAT )) by ORDINAL1:def 12;
L44: (for R1 being (Element of ( NAT )) holds (R1 < D6 implies ( IC ( Comput (C13 , C12 , R1) ) ) in ( dom C11 ))) by L43;
set D7 = ( Comput (C13 , C12 , D6) );
set D8 = C13;
set D9 = C12;
set D10 = ( C13 +* (( IC D7 ) , ( goto ( IC D7 ) )) );
set D11 = D7;
set D12 = ( C13 +* (( IC D7 ) , ( goto ( IC D7 ) )) );
L45: C11 c= D10 by L38 , L42 , FUNCT_7:89;
L46: ( Comput (D10 , D9 , D6) ) = D7 by L45 , L44 , L38 , AMISTD_2:10;
L47: D10 halts_on D9 by L37 , L5 , L39 , L45;
L48: D10 halts_on ( Comput (D10 , D9 , D6) ) by L47 , EXTPRO_1:22;
thus L49: contradiction by L48 , L46 , SCMFSA6B:21;
end;
cluster  keepInt0_1 ->  InitClosed for (Program of ( SCM+FSA ));
coherence
proof
let C16 being (Program of ( SCM+FSA ));
assume L50: C16 is  keepInt0_1;
set D13 = ( FirstNotUsed C16 );
let C17 being (State of ( SCM+FSA ));
let C18 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L51: C16 c= C18;
let C19 being (Element of ( NAT ));
assume L52: D2 c= C17;
L53: D1 c= C17 by L52 , L2 , XBOOLE_1:1;
defpred S2[ Nat ] means (not ( IC ( Comput (C18 , C17 , $1) ) ) in ( dom C16 ));
assume L54: (not ( IC ( Comput (C18 , C17 , C19) ) ) in ( dom C16 ));
L55: (ex B10 being Nat st S2[ B10 ]) by L54;
consider C20 being Nat such that L56: S2[ C20 ] and L57: (for B11 being Nat holds (S2[ B11 ] implies C20 <= B11)) from NAT_1:sch 5(L55);
reconsider D14 = C20 as (Element of ( NAT )) by ORDINAL1:def 12;
set D15 = ( Comput (C18 , C17 , D14) );
set D16 = ( C18 +* (( IC D15 ) , ( ( intloc ( 0 ) ) := D13 )) );
set D17 = ( C17 +* (D13 , ( ( C17 . ( intloc ( 0 ) ) ) + 1 )) );
reconsider D18 = C17 as (State of ( SCM+FSA ));
reconsider D19 = D17 as (State of ( SCM+FSA ));
L58: (not C16 is  keepInt0_1)
proof
L59: D13 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L60: (not D13 in { ( IC ( SCM+FSA ) ) }) by L59 , TARSKI:def 1;
set D20 = ( Comput (D16 , D19 , D14) );
set D21 = ( { ( intloc ( 0 ) ) } \/ { ( IC ( SCM+FSA ) ) } );
take D19;
L61: D13 in ( dom D18 ) by SCMFSA_2:42;
L62: ( D19 . D13 ) = ( ( D18 . ( intloc ( 0 ) ) ) + 1 ) by L61 , FUNCT_7:31;
L63: ( D18 . ( intloc ( 0 ) ) ) = 1 by L52 , SCMFSA_M:30;
L64: (not D13 in ( UsedIntLoc C16 )) by SF_MASTR:50;
L65: (not D13 in { ( intloc ( 0 ) ) }) by TARSKI:def 1;
L66: (not D13 in ( dom D2 )) by L65 , L3 , L60 , XBOOLE_0:def 3;
thus L67: D2 c= D19 by L66 , L52 , FUNCT_7:89;
L68: D1 c= D19 by L67 , L2 , XBOOLE_1:1;
take D16;
thus L69: C16 c= D16 by L51 , L56 , FUNCT_7:89;
L70: (not D13 in ( UsedInt*Loc C16 ))
proof
assume L71: (not thesis);
L72: D13 is FinSeq-Location by L71 , SCMFSA_2:def 5;
thus L73: contradiction by L72 , SCMFSA_2:58;
end;
L74: ( D19 | ( UsedInt*Loc C16 ) ) = ( D18 | ( UsedInt*Loc C16 ) ) by L70 , FUNCT_7:92;
L75: ( D19 | ( UsedIntLoc C16 ) ) = ( D18 | ( UsedIntLoc C16 ) ) by FUNCT_7:92 , SF_MASTR:50;
L76: (for R1 being (Element of ( NAT )) holds (R1 < D14 implies ( IC ( Comput (C18 , D18 , R1) ) ) in ( dom C16 ))) by L57;
L77: ( IC D20 ) = ( IC D15 ) by L75 , L74 , L51 , L69 , L68 , L76 , L53 , SF_MASTR:65;
take D22 = ( D14 + 1 );
L78: ( IC D15 ) in ( NAT );
L79: ( IC D15 ) in ( dom C18 ) by L78 , PARTFUN1:def 2;
L80: ( D16 . ( IC D15 ) ) = ( ( intloc ( 0 ) ) := D13 ) by L79 , FUNCT_7:31;
L81: ( Comput (D16 , D19 , D22) ) = ( Following (D16 , D20) ) by EXTPRO_1:3
.= ( Exec (( ( intloc ( 0 ) ) := D13 ) , D20) ) by L77 , L80 , PBOOLE:143;
L82: (for R1 being (Element of ( NAT )) holds (R1 < D14 implies ( IC ( Comput (D16 , D19 , R1) ) ) in ( dom C16 ))) by L76 , L75 , L74 , L51 , L69 , L68 , L53 , SF_MASTR:65;
L83: ( D20 . D13 ) = ( 1 + 1 ) by L82 , L64 , L62 , L51 , L56 , L63 , FUNCT_7:89 , SF_MASTR:61;
thus L84: thesis by L83 , L81 , SCMFSA_2:63;
end;
thus L85: contradiction by L58 , L50;
end;
cluster  keeping_0 ->  keepInt0_1 for (Program of ( SCM+FSA ));
coherence
proof
let C21 being (Program of ( SCM+FSA ));
assume L86: C21 is  keeping_0;
let C22 being (State of ( SCM+FSA ));
assume L87: D2 c= C22;
let R9 being (Instruction-Sequence of ( SCM+FSA ));
assume L88: C21 c= R9;
let C23 being (Element of ( NAT ));
L89: D1 c= D2 by FUNCT_4:25;
L90: D1 c= C22 by L89 , L87 , XBOOLE_1:1;
L91: C22 is ( 0 ) -started by L90 , MEMSTR_0:29;
L92: ( C22 . ( intloc ( 0 ) ) ) = 1 by L87 , SCMFSA_M:30;
thus L93: ( ( Comput (R9 , C22 , C23) ) . ( intloc ( 0 ) ) ) = 1 by L92 , L86 , L88 , L91 , SCMFSA6B:def 4;
end;
end;
canceled 1;
theorem
L95: (for R4 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B12 being  InitHalting (Program of ( SCM+FSA )) holds (for B13 being  read-write Int-Location holds ((not B13 in ( UsedIntLoc B12 )) implies ( ( IExec (B12 , R9 , R4) ) . B13 ) = ( R4 . B13 ))))))
proof
let R4 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C24 being  InitHalting (Program of ( SCM+FSA ));
let C25 being  read-write Int-Location;
L96: (C25 <> ( intloc ( 0 ) ) & C25 <> ( IC ( SCM+FSA ) )) by SCMFSA_2:56;
L97: (not C25 in ( dom D2 )) by L96 , SCMFSA_M:11 , TARSKI:def 2;
L98: ( ( IExec (C24 , R9 , R4) ) . C25 ) = ( ( Result (( R9 +* C24 ) , ( Initialized R4 )) ) . C25 ) by SCMFSA6B:def 1;
L99: D2 c= ( Initialized R4 ) by FUNCT_4:25;
L100: C24 c= ( R9 +* C24 ) by FUNCT_4:25;
L101: ( R9 +* C24 ) halts_on ( Initialized R4 ) by L100 , L5 , L99;
consider R2 being (Element of ( NAT )) such that L102: ( Result (( R9 +* C24 ) , ( Initialized R4 )) ) = ( Comput (( R9 +* C24 ) , ( R4 +* D2 ) , R2) ) and L103: ( CurInstr (( R9 +* C24 ) , ( Result (( R9 +* C24 ) , ( Initialized R4 )) )) ) = ( halt ( SCM+FSA ) ) by L101 , EXTPRO_1:def 9;
L104: C24 c= ( R9 +* C24 ) by FUNCT_4:25;
L105: (for R1 being (Element of ( NAT )) holds (R1 < R2 implies ( IC ( Comput (( R9 +* C24 ) , ( Initialized R4 ) , R1) ) ) in ( dom C24 ))) by L4 , L104 , L99;
assume L106: (not C25 in ( UsedIntLoc C24 ));
thus L107: ( ( IExec (C24 , R9 , R4) ) . C25 ) = ( ( Initialized R4 ) . C25 ) by L106 , L98 , L102 , L105 , FUNCT_4:25 , SF_MASTR:61
.= ( R4 . C25 ) by L97 , FUNCT_4:11;
end;
theorem
L108: (for R4 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B14 being  InitHalting (Program of ( SCM+FSA )) holds (for B15 being FinSeq-Location holds ((not B15 in ( UsedInt*Loc B14 )) implies ( ( IExec (B14 , R9 , R4) ) . B15 ) = ( R4 . B15 ))))))
proof
let R4 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C26 being  InitHalting (Program of ( SCM+FSA ));
let C27 being FinSeq-Location;
L109: (C27 <> ( intloc ( 0 ) ) & C27 <> ( IC ( SCM+FSA ) )) by SCMFSA_2:57 , SCMFSA_2:58;
L110: (not C27 in ( dom D2 )) by L109 , SCMFSA_M:11 , TARSKI:def 2;
L111: ( ( IExec (C26 , R9 , R4) ) . C27 ) = ( ( Result (( R9 +* C26 ) , ( Initialized R4 )) ) . C27 ) by SCMFSA6B:def 1;
L112: D2 c= ( Initialized R4 ) by FUNCT_4:25;
L113: C26 c= ( R9 +* C26 ) by FUNCT_4:25;
L114: ( R9 +* C26 ) halts_on ( Initialized R4 ) by L113 , L5 , L112;
consider R2 being (Element of ( NAT )) such that L115: ( Result (( R9 +* C26 ) , ( Initialized R4 )) ) = ( Comput (( R9 +* C26 ) , ( Initialized R4 ) , R2) ) and L116: ( CurInstr (( R9 +* C26 ) , ( Result (( R9 +* C26 ) , ( Initialized R4 )) )) ) = ( halt ( SCM+FSA ) ) by L114 , EXTPRO_1:def 9;
L117: C26 c= ( R9 +* C26 ) by FUNCT_4:25;
L118: (for R1 being (Element of ( NAT )) holds (R1 < R2 implies ( IC ( Comput (( R9 +* C26 ) , ( Initialized R4 ) , R1) ) ) in ( dom C26 ))) by L4 , L117 , L112;
assume L119: (not C27 in ( UsedInt*Loc C26 ));
thus L120: ( ( IExec (C26 , R9 , R4) ) . C27 ) = ( ( Initialized R4 ) . C27 ) by L119 , L111 , L115 , L118 , FUNCT_4:25 , SF_MASTR:63
.= ( R4 . C27 ) by L110 , FUNCT_4:11;
end;
registration
cluster  InitHalting -> non  empty for (Program of ( SCM+FSA ));
coherence;
end;
theorem
L122: (for R5 being (State of ( SCM+FSA )) holds (for R6 being (State of ( SCM+FSA )) holds (for R10 being (Instruction-Sequence of ( SCM+FSA )) holds (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds (for B16 being  InitHalting (Program of ( SCM+FSA )) holds ((( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= R5 & B16 c= R10) implies (for B17 being (Element of ( NAT )) holds ((( Reloc (B16 , B17) ) c= R11 & ( IC R6 ) = B17 & ( DataPart R5 ) = ( DataPart R6 )) implies (for B18 being (Element of ( NAT )) holds (( ( IC ( Comput (R10 , R5 , B18) ) ) + B17 ) = ( IC ( Comput (R11 , R6 , B18) ) ) & ( IncAddr (( CurInstr (R10 , ( Comput (R10 , R5 , B18) )) ) , B17) ) = ( CurInstr (R11 , ( Comput (R11 , R6 , B18) )) ) & ( DataPart ( Comput (R10 , R5 , B18) ) ) = ( DataPart ( Comput (R11 , R6 , B18) ) )))))))))))
proof
let R5 being (State of ( SCM+FSA ));
let R6 being (State of ( SCM+FSA ));
let R10 being (Instruction-Sequence of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
let C28 being  InitHalting (Program of ( SCM+FSA ));
assume that
L123: D2 c= R5
and
L124: C28 c= R10;
let C29 being (Element of ( NAT ));
assume that
L125: ( Reloc (C28 , C29) ) c= R11
and
L126: ( IC R6 ) = C29
and
L127: ( DataPart R5 ) = ( DataPart R6 );
L128: ( DataPart ( Comput (R10 , R5 , ( 0 )) ) ) = ( DataPart R6 ) by L127
.= ( DataPart ( Comput (R11 , R6 , ( 0 )) ) );
defpred S3[ Nat ] means (( ( IC ( Comput (R10 , R5 , $1) ) ) + C29 ) = ( IC ( Comput (R11 , R6 , $1) ) ) & ( IncAddr (( CurInstr (R10 , ( Comput (R10 , R5 , $1) )) ) , C29) ) = ( CurInstr (R11 , ( Comput (R11 , R6 , $1) )) ) & ( DataPart ( Comput (R10 , R5 , $1) ) ) = ( DataPart ( Comput (R11 , R6 , $1) ) ));
L129: (for B19 being (Element of ( NAT )) holds (S3[ B19 ] implies S3[ ( B19 + 1 ) ]))
proof
let C30 being (Element of ( NAT ));
L130: ( Comput (R10 , R5 , ( C30 + 1 )) ) = ( Following (R10 , ( Comput (R10 , R5 , C30) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R10 , ( Comput (R10 , R5 , C30) )) ) , ( Comput (R10 , R5 , C30) )) );
reconsider D23 = ( IC ( Comput (R10 , R5 , ( C30 + 1 )) ) ) as (Element of ( NAT ));
reconsider D24 = ( CurInstr (R10 , ( Comput (R10 , R5 , ( C30 + 1 )) )) ) as (Instruction of ( SCM+FSA ));
L131: ( Comput (R11 , R6 , ( C30 + 1 )) ) = ( Following (R11 , ( Comput (R11 , R6 , C30) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R11 , ( Comput (R11 , R6 , C30) )) ) , ( Comput (R11 , R6 , C30) )) );
L132: ( IC ( Comput (R10 , R5 , ( C30 + 1 )) ) ) in ( dom C28 ) by L123 , L4 , L124;
assume L133: S3[ C30 ];
thus L134: ( ( IC ( Comput (R10 , R5 , ( C30 + 1 )) ) ) + C29 ) = ( IC ( Comput (R11 , R6 , ( C30 + 1 )) ) ) by L133 , L130 , L131 , SCMFSA6A:8;
L135: ( IC ( Comput (R11 , R6 , ( C30 + 1 )) ) ) in ( dom ( Reloc (C28 , C29) ) ) by L134 , L132 , COMPOS_1:46;
L136: D23 in ( dom C28 ) by L123 , L4 , L124;
L137: D24 = ( R10 . ( IC ( Comput (R10 , R5 , ( C30 + 1 )) ) ) ) by PBOOLE:143
.= ( C28 . D23 ) by L132 , L124 , GRFUNC_1:2;
thus L138: ( IncAddr (( CurInstr (R10 , ( Comput (R10 , R5 , ( C30 + 1 )) )) ) , C29) ) = ( ( Reloc (C28 , C29) ) . ( D23 + C29 ) ) by L137 , L136 , COMPOS_1:35
.= ( ( Reloc (C28 , C29) ) . ( IC ( Comput (R11 , R6 , ( C30 + 1 )) ) ) ) by L133 , L130 , L131 , SCMFSA6A:8
.= ( R11 . ( IC ( Comput (R11 , R6 , ( C30 + 1 )) ) ) ) by L135 , L125 , GRFUNC_1:2
.= ( CurInstr (R11 , ( Comput (R11 , R6 , ( C30 + 1 )) )) ) by PBOOLE:143;
thus L139: thesis by L133 , L130 , L131 , SCMFSA6A:8;
end;
L140: ( 0 ) in ( dom C28 ) by AFINSQ_1:65;
L141: ( 0 ) in ( dom C28 ) by AFINSQ_1:65;
L142: ( IC ( SCM+FSA ) ) in ( dom D2 ) by MEMSTR_0:48;
L143: ( R10 . ( IC R5 ) ) = ( R10 . ( IC D2 ) ) by L142 , L123 , GRFUNC_1:2
.= ( C28 . ( 0 ) ) by L141 , L124 , L1 , GRFUNC_1:2;
let C31 being (Element of ( NAT ));
L144: ( 0 ) in ( dom C28 ) by AFINSQ_1:65;
L145: ( ( 0 ) + C29 ) in ( dom ( Reloc (C28 , C29) ) ) by L144 , COMPOS_1:46;
L146: ( IC ( Comput (R10 , R5 , ( 0 )) ) ) = ( R5 . ( IC ( SCM+FSA ) ) )
.= ( 0 ) by L1 , L123 , L142 , GRFUNC_1:2;
L147: ( R11 /. ( IC R6 ) ) = ( R11 . ( IC R6 ) ) by PBOOLE:143;
L148: ( R10 /. ( IC R5 ) ) = ( R10 . ( IC R5 ) ) by PBOOLE:143;
L149: ( IncAddr (( CurInstr (R10 , ( Comput (R10 , R5 , ( 0 )) )) ) , C29) ) = ( IncAddr (( CurInstr (R10 , R5) ) , C29) )
.= ( ( Reloc (C28 , C29) ) . ( ( 0 ) + C29 ) ) by L143 , L140 , L148 , COMPOS_1:35
.= ( CurInstr (R11 , R6) ) by L126 , L145 , L147 , L125 , GRFUNC_1:2
.= ( CurInstr (R11 , ( Comput (R11 , R6 , ( 0 )) )) );
L150: S3[ ( 0 ) ] by L149 , L126 , L146 , L128;
L151: (for B20 being (Element of ( NAT )) holds S3[ B20 ]) from NAT_1:sch 1(L150 , L129);
thus L152: thesis by L151;
end;
theorem
L153: (for R5 being (State of ( SCM+FSA )) holds (for R6 being (State of ( SCM+FSA )) holds (for R10 being (Instruction-Sequence of ( SCM+FSA )) holds (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds (for B21 being  InitHalting (Program of ( SCM+FSA )) holds ((( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= R5 & ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= R6 & B21 c= R10 & B21 c= R11 & R5 = R6) implies (for B22 being (Element of ( NAT )) holds (( Comput (R10 , R5 , B22) ) = ( Comput (R11 , R6 , B22) ) & ( CurInstr (R10 , ( Comput (R10 , R5 , B22) )) ) = ( CurInstr (R11 , ( Comput (R11 , R6 , B22) )) )))))))))
proof
let R5 being (State of ( SCM+FSA ));
let R6 being (State of ( SCM+FSA ));
let R10 being (Instruction-Sequence of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
let C32 being  InitHalting (Program of ( SCM+FSA ));
assume that
L154: D2 c= R5
and
L155: D2 c= R6
and
L156: C32 c= R10
and
L157: C32 c= R11
and
L158: R5 = R6;
let C33 being (Element of ( NAT ));
L159: ( IC ( Comput (R10 , R5 , C33) ) ) in ( dom C32 ) by L154 , L4 , L156;
L160: ( IC ( Comput (R11 , R6 , C33) ) ) in ( dom C32 ) by L155 , L4 , L157;
L161: (for B23 being (Element of ( NAT )) holds (B23 < C33 implies ( IC ( Comput (R11 , R6 , B23) ) ) in ( dom C32 ))) by L155 , L4 , L157;
thus L162: ( Comput (R10 , R5 , C33) ) = ( Comput (R11 , R6 , C33) ) by L161 , L158 , L156 , L157 , AMISTD_2:10;
thus L163: ( CurInstr (R11 , ( Comput (R11 , R6 , C33) )) ) = ( R11 . ( IC ( Comput (R11 , R6 , C33) ) ) ) by PBOOLE:143
.= ( C32 . ( IC ( Comput (R11 , R6 , C33) ) ) ) by L160 , L157 , GRFUNC_1:2
.= ( R10 . ( IC ( Comput (R10 , R5 , C33) ) ) ) by L162 , L159 , L156 , GRFUNC_1:2
.= ( CurInstr (R10 , ( Comput (R10 , R5 , C33) )) ) by PBOOLE:143;
end;
theorem
L164: (for R5 being (State of ( SCM+FSA )) holds (for R6 being (State of ( SCM+FSA )) holds (for R10 being (Instruction-Sequence of ( SCM+FSA )) holds (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds (for B24 being  InitHalting (Program of ( SCM+FSA )) holds ((( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= R5 & ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= R6 & B24 c= R10 & B24 c= R11 & R5 = R6) implies (( LifeSpan (R10 , R5) ) = ( LifeSpan (R11 , R6) ) & ( Result (R10 , R5) ) = ( Result (R11 , R6) ))))))))
proof
let R5 being (State of ( SCM+FSA ));
let R6 being (State of ( SCM+FSA ));
let R10 being (Instruction-Sequence of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
let C34 being  InitHalting (Program of ( SCM+FSA ));
assume that
L165: D2 c= R5
and
L166: D2 c= R6
and
L167: C34 c= R10
and
L168: C34 c= R11
and
L169: R5 = R6;
L170: R11 halts_on R6 by L166 , L5 , L168;
L171: R10 halts_on R5 by L165 , L5 , L167;
L172:
now
let C35 being (Element of ( NAT ));
assume L173: ( CurInstr (R11 , ( Comput (R11 , R6 , C35) )) ) = ( halt ( SCM+FSA ) );
L174: ( CurInstr (R10 , ( Comput (R10 , R5 , C35) )) ) = ( CurInstr (R11 , ( Comput (R11 , R6 , C35) )) ) by L165 , L169 , L153 , L167 , L168;
thus L175: ( LifeSpan (R10 , R5) ) <= C35 by L174 , L171 , L173 , EXTPRO_1:def 15;
end;
L176: ( CurInstr (R11 , ( Comput (R11 , R6 , ( LifeSpan (R10 , R5) )) )) ) = ( CurInstr (R10 , ( Comput (R10 , R5 , ( LifeSpan (R10 , R5) )) )) ) by L165 , L169 , L153 , L167 , L168
.= ( halt ( SCM+FSA ) ) by L171 , EXTPRO_1:def 15;
thus L177: ( LifeSpan (R10 , R5) ) = ( LifeSpan (R11 , R6) ) by L176 , L172 , L170 , EXTPRO_1:def 15;
L178: R11 halts_on R6 by L166 , L5 , L168;
L179: ( Result (R11 , R6) ) = ( Comput (R11 , R6 , ( LifeSpan (R10 , R5) )) ) by L178 , L177 , EXTPRO_1:23;
L180: R10 halts_on R5 by L165 , L5 , L167;
L181: ( Result (R10 , R5) ) = ( Comput (R10 , R5 , ( LifeSpan (R10 , R5) )) ) by L180 , EXTPRO_1:23;
thus L182: thesis by L181 , L165 , L169 , L179 , L153 , L167 , L168;
end;
registration
cluster  keeping_0  InitHalting for (Program of ( SCM+FSA ));
existence
proof
take ( Macro ( halt ( SCM+FSA ) ) );
thus L183: thesis;
end;
end;
registration
cluster  keepInt0_1  InitHalting for (Program of ( SCM+FSA ));
existence
proof
take ( Macro ( halt ( SCM+FSA ) ) );
thus L185: thesis;
end;
end;
theorem
L187: (for R4 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B25 being  keepInt0_1  InitHalting (Program of ( SCM+FSA )) holds ( ( IExec (B25 , R9 , R4) ) . ( intloc ( 0 ) ) ) = 1)))
proof
let R4 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C36 being  keepInt0_1  InitHalting (Program of ( SCM+FSA ));
L188: D2 c= ( Initialized R4 ) by FUNCT_4:25;
L189: C36 c= ( R9 +* C36 ) by FUNCT_4:25;
L190: ( R9 +* C36 ) halts_on ( Initialized R4 ) by L189 , L5 , L188;
L191: (D2 c= ( Initialized R4 ) & (ex R2 being (Element of ( NAT )) st (( Result (( R9 +* C36 ) , ( Initialized R4 )) ) = ( Comput (( R9 +* C36 ) , ( Initialized R4 ) , R2) ) & ( CurInstr (( R9 +* C36 ) , ( Result (( R9 +* C36 ) , ( Initialized R4 )) )) ) = ( halt ( SCM+FSA ) )))) by L190 , EXTPRO_1:def 9 , FUNCT_4:25;
thus L192: ( ( IExec (C36 , R9 , R4) ) . ( intloc ( 0 ) ) ) = ( ( Result (( R9 +* C36 ) , ( Initialized R4 )) ) . ( intloc ( 0 ) ) ) by SCMFSA6B:def 1
.= 1 by L191 , L189 , L6;
end;
registration
cluster  InitClosed for (Program of ( SCM+FSA ));
existence
proof
take the  paraclosed (Program of ( SCM+FSA ));
thus L193: thesis;
end;
end;
theorem
L195: (for R4 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B26 being  InitClosed (Program of ( SCM+FSA )) holds (for B27 being (Program of ( SCM+FSA )) holds ((( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= R4 & B26 c= R9 & R9 halts_on R4) implies (for R1 being (Element of ( NAT )) holds (R1 <= ( LifeSpan (R9 , R4) ) implies ( Comput (R9 , R4 , R1) ) = ( Comput (( R9 +* ( B26 ";" B27 ) ) , R4 , R1) ))))))))
proof
let R4 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C37 being  InitClosed (Program of ( SCM+FSA ));
let C38 being (Program of ( SCM+FSA ));
assume that
L196: D2 c= R4
and
L197: C37 c= R9
and
L198: R9 halts_on R4;
defpred S4[ Nat ] means ($1 <= ( LifeSpan (R9 , R4) ) implies ( Comput (R9 , R4 , $1) ) = ( Comput (( R9 +* ( C37 ";" C38 ) ) , R4 , $1) ));
L199: (for R1 being (Element of ( NAT )) holds (S4[ R1 ] implies S4[ ( R1 + 1 ) ]))
proof
set D25 = ( R9 +* ( C37 ";" C38 ) );
let R1 being (Element of ( NAT ));
L200: ( C37 ";" C38 ) c= D25 by FUNCT_4:25;
assume L201: (R1 <= ( LifeSpan (R9 , R4) ) implies ( Comput (R9 , R4 , R1) ) = ( Comput (( R9 +* ( C37 ";" C38 ) ) , R4 , R1) ));
L202: ( dom ( C37 ";" C38 ) ) = ( ( dom ( Directed C37 ) ) \/ ( dom ( Reloc (C38 , ( card C37 )) ) ) ) by FUNCT_4:def 1
.= ( ( dom C37 ) \/ ( dom ( Reloc (C38 , ( card C37 )) ) ) ) by FUNCT_4:99;
L203: (( {} ) c= ( Comput (D25 , R4 , R1) ) & ( dom C37 ) c= ( dom ( C37 ";" C38 ) )) by L202 , XBOOLE_1:2 , XBOOLE_1:7;
L204: ( Comput (R9 , R4 , ( R1 + 1 )) ) = ( Following (R9 , ( Comput (R9 , R4 , R1) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R9 , ( Comput (R9 , R4 , R1) )) ) , ( Comput (R9 , R4 , R1) )) );
L205: ( Comput (D25 , R4 , ( R1 + 1 )) ) = ( Following (D25 , ( Comput (D25 , R4 , R1) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D25 , ( Comput (D25 , R4 , R1) )) ) , ( Comput (D25 , R4 , R1) )) );
L206: ( IC ( Comput (R9 , R4 , R1) ) ) in ( dom C37 ) by L196 , L4 , L197;
L207: ( R9 /. ( IC ( Comput (R9 , R4 , R1) ) ) ) = ( R9 . ( IC ( Comput (R9 , R4 , R1) ) ) ) by PBOOLE:143;
L208: ( CurInstr (R9 , ( Comput (R9 , R4 , R1) )) ) = ( C37 . ( IC ( Comput (R9 , R4 , R1) ) ) ) by L206 , L207 , L197 , GRFUNC_1:2;
assume L209: ( R1 + 1 ) <= ( LifeSpan (R9 , R4) );
L210: ( D25 /. ( IC ( Comput (D25 , R4 , R1) ) ) ) = ( D25 . ( IC ( Comput (D25 , R4 , R1) ) ) ) by PBOOLE:143;
L211: R1 < ( LifeSpan (R9 , R4) ) by L209 , NAT_1:13;
L212: ( C37 . ( IC ( Comput (R9 , R4 , R1) ) ) ) <> ( halt ( SCM+FSA ) ) by L211 , L198 , L208 , EXTPRO_1:def 15;
L213: ( CurInstr (R9 , ( Comput (R9 , R4 , R1) )) ) = ( ( C37 ";" C38 ) . ( IC ( Comput (R9 , R4 , R1) ) ) ) by L212 , L206 , L208 , SCMFSA6A:15
.= ( CurInstr (D25 , ( Comput (D25 , R4 , R1) )) ) by L209 , L206 , L203 , L210 , L200 , L201 , GRFUNC_1:2 , NAT_1:13;
thus L214: thesis by L213 , L201 , L209 , L204 , L205 , NAT_1:13;
end;
L215: S4[ ( 0 ) ];
thus L216: (for R1 being (Element of ( NAT )) holds S4[ R1 ]) from NAT_1:sch 1(L215 , L199);
end;
theorem
L217: (for R4 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B28 being  InitClosed (Program of ( SCM+FSA )) holds ((( R9 +* B28 ) halts_on R4 & ( Directed B28 ) c= R9 & ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= R4) implies ( IC ( Comput (R9 , R4 , ( ( LifeSpan (( R9 +* B28 ) , R4) ) + 1 )) ) ) = ( card B28 )))))
proof
let R4 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
set D26 = ( NAT );
let C39 being  InitClosed (Program of ( SCM+FSA ));
assume that
L218: ( R9 +* C39 ) halts_on R4
and
L219: ( Directed C39 ) c= R9
and
L220: D2 c= R4;
set D27 = ( R4 +* D2 );
set D28 = ( R9 +* C39 );
set D29 = ( D27 +* D3 );
set D30 = ( D28 +* ( C39 ";" C39 ) );
L221: D27 = R4 by L220 , FUNCT_4:98;
L222: D29 = R4 by L221 , FUNCT_4:21;
L223: D2 c= D27 by L220 , FUNCT_4:98;
L224: C39 c= D28 by FUNCT_4:25;
reconsider D31 = D27 as (State of ( SCM+FSA ));
set D32 = ( LifeSpan (D28 , D31) );
set D33 = ( IC ( Comput (D28 , D31 , D32) ) );
L225: C39 c= D28 by FUNCT_4:25;
L226: D33 in ( dom C39 ) by L223 , L4 , L225;
set D34 = ( D31 +* D3 );
set D35 = ( D28 +* ( Directed C39 ) );
L227: ( Directed C39 ) c= D35 by FUNCT_4:25;
L228:
now
let C40 being (Element of ( NAT ));
defpred S5[ Nat ] means ($1 <= C40 implies ( Comput (D30 , D29 , $1) ) = ( Comput (D35 , D34 , $1) ));
assume L229: C40 <= D32;
L230: (for B29 being (Element of ( NAT )) holds (S5[ B29 ] implies S5[ ( B29 + 1 ) ]))
proof
let C41 being (Element of ( NAT ));
assume L231: (C41 <= C40 implies ( Comput (D30 , D29 , C41) ) = ( Comput (D35 , D34 , C41) ));
L232: ( Comput (D35 , D34 , ( C41 + 1 )) ) = ( Following (D35 , ( Comput (D35 , D34 , C41) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D35 , ( Comput (D35 , D34 , C41) )) ) , ( Comput (D35 , D34 , C41) )) );
L233: ( Comput (D30 , D29 , ( C41 + 1 )) ) = ( Following (D30 , ( Comput (D30 , D29 , C41) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D30 , ( Comput (D30 , D29 , C41) )) ) , ( Comput (D30 , D29 , C41) )) );
L234: C41 <= ( C41 + 1 ) by NAT_1:12;
assume L235: ( C41 + 1 ) <= C40;
L236: C39 c= ( R9 +* C39 ) by FUNCT_4:25;
L237: C41 <= C40 by L235 , L234 , XXREAL_0:2;
L238: ( IC ( Comput (D28 , D31 , C41) ) ) = ( IC ( Comput (D30 , D29 , C41) ) ) by L237 , L218 , L220 , L195 , L224 , L221 , L222 , L229 , XXREAL_0:2;
L239: ( IC ( Comput (D30 , D29 , C41) ) ) in ( dom C39 ) by L238 , L223 , L4 , L236;
L240: ( IC ( Comput (D35 , D34 , C41) ) ) in ( dom ( Directed C39 ) ) by L239 , L235 , L231 , L234 , FUNCT_4:99 , XXREAL_0:2;
L241: ( CurInstr (D35 , ( Comput (D35 , D34 , C41) )) ) = ( D35 . ( IC ( Comput (D35 , D34 , C41) ) ) ) by PBOOLE:143
.= ( ( Directed C39 ) . ( IC ( Comput (D35 , D34 , C41) ) ) ) by L240 , FUNCT_4:13;
L242: (( dom C39 ) c= ( dom ( C39 ";" C39 ) ) & ( CurInstr (D30 , ( Comput (D30 , D29 , C41) )) ) = ( D30 . ( IC ( Comput (D30 , D29 , C41) ) ) )) by PBOOLE:143 , SCMFSA6A:17;
L243: (( Directed C39 ) c= ( C39 ";" C39 ) & ( CurInstr (D30 , ( Comput (D30 , D29 , C41) )) ) = ( ( C39 ";" C39 ) . ( IC ( Comput (D30 , D29 , C41) ) ) )) by L242 , L239 , FUNCT_4:13 , SCMFSA6A:16;
thus L244: thesis by L243 , L231 , L235 , L234 , L241 , L233 , L232 , L240 , GRFUNC_1:2 , XXREAL_0:2;
end;
L245: S5[ ( 0 ) ];
L246: (for B30 being (Element of ( NAT )) holds S5[ B30 ]) from NAT_1:sch 1(L245 , L230);
L247: ( Comput (D30 , D29 , C40) ) = ( Comput (D35 , D34 , C40) ) by L246;
thus L248: ( Comput (D28 , D31 , C40) ) = ( Comput (D35 , D34 , C40) ) by L247 , L218 , L220 , L229 , L195 , L224 , L221 , L222;
end;
L249: ( Comput (D28 , D31 , D32) ) = ( Comput (D35 , D34 , D32) ) by L228;
L250: ( C39 . D33 ) = ( D28 . D33 ) by L226 , L224 , GRFUNC_1:2
.= ( CurInstr (D28 , ( Comput (D28 , D31 , D32) )) ) by PBOOLE:143
.= ( halt ( SCM+FSA ) ) by L218 , L221 , EXTPRO_1:def 15;
L251: ( IC ( Comput (D35 , D34 , D32) ) ) in ( dom ( Directed C39 ) ) by L226 , L249 , FUNCT_4:99;
L252: ( D35 . D33 ) = ( ( Directed C39 ) . D33 ) by L251 , L249 , L227 , GRFUNC_1:2
.= ( goto ( card C39 ) ) by L226 , L250 , FUNCT_4:106;
L253: ( Comput (D35 , D34 , ( D32 + 1 )) ) = ( Following (D35 , ( Comput (D35 , D34 , D32) )) ) by EXTPRO_1:3
.= ( Exec (( goto ( card C39 ) ) , ( Comput (D35 , D34 , D32) )) ) by L249 , L252 , PBOOLE:143;
set D36 = ( LifeSpan (D28 , D31) );
L254: ( dom ( Directed C39 ) ) = ( dom C39 ) by FUNCT_4:99;
L255: ( ( R9 +* C39 ) +* ( Directed C39 ) ) = ( R9 +* ( Directed C39 ) ) by L254 , FUNCT_4:74
.= R9 by L219 , FUNCT_4:98;
L256: D34 = D31 by FUNCT_4:21
.= R4 by L220 , FUNCT_4:98;
thus L257: ( IC ( Comput (R9 , R4 , ( ( LifeSpan (( R9 +* C39 ) , R4) ) + 1 )) ) ) = ( IC ( Comput (D35 , D34 , ( D36 + 1 )) ) ) by L256 , L255 , FUNCT_4:21
.= ( card C39 ) by L253 , SCMFSA_2:69;
end;
theorem
L258: (for R4 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B31 being  InitClosed (Program of ( SCM+FSA )) holds ((( R9 +* B31 ) halts_on R4 & ( Directed B31 ) c= R9 & ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= R4) implies ( DataPart ( Comput (R9 , R4 , ( LifeSpan (( R9 +* B31 ) , R4) )) ) ) = ( DataPart ( Comput (R9 , R4 , ( ( LifeSpan (( R9 +* B31 ) , R4) ) + 1 )) ) )))))
proof
let R4 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
set D37 = ( NAT );
let C42 being  InitClosed (Program of ( SCM+FSA ));
assume that
L259: ( R9 +* C42 ) halts_on R4
and
L260: ( Directed C42 ) c= R9
and
L261: D2 c= R4;
L262: R4 = ( R4 +* ( {} ) );
set D38 = ( R4 +* D2 );
set D39 = ( R9 +* C42 );
set D40 = ( D38 +* D3 );
set D41 = ( D39 +* ( Directed C42 ) );
L263: D2 c= D38 by FUNCT_4:25;
L264: C42 c= ( R9 +* C42 ) by FUNCT_4:25;
L265: D38 = R4 by L261 , FUNCT_4:98;
reconsider D42 = D38 as (State of ( SCM+FSA ));
set D43 = ( LifeSpan (D39 , D42) );
set D44 = ( IC ( Comput (D39 , D42 , D43) ) );
L266: D44 in ( dom C42 ) by L263 , L4 , L264;
set D45 = ( D42 +* D3 );
set D46 = ( D39 +* ( Directed C42 ) );
L267:
now
set D47 = ( D42 +* D3 );
set D48 = ( D39 +* ( C42 ";" C42 ) );
let C43 being (Element of ( NAT ));
defpred S6[ Nat ] means ($1 <= C43 implies ( Comput (D48 , D47 , $1) ) = ( Comput (D46 , D45 , $1) ));
assume L268: C43 <= D43;
L269: (for B32 being (Element of ( NAT )) holds (S6[ B32 ] implies S6[ ( B32 + 1 ) ]))
proof
L270: ( Directed C42 ) c= ( C42 ";" C42 ) by SCMFSA6A:16;
let C44 being (Element of ( NAT ));
L271: ( dom C42 ) c= ( dom ( C42 ";" C42 ) ) by SCMFSA6A:17;
assume L272: (C44 <= C43 implies ( Comput (D48 , D47 , C44) ) = ( Comput (D46 , D45 , C44) ));
L273: ( Comput (D46 , D45 , ( C44 + 1 )) ) = ( Following (D46 , ( Comput (D46 , D45 , C44) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D46 , ( Comput (D46 , D45 , C44) )) ) , ( Comput (D46 , D45 , C44) )) );
L274: ( Comput (D48 , D47 , ( C44 + 1 )) ) = ( Following (D48 , ( Comput (D48 , D47 , C44) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D48 , ( Comput (D48 , D47 , C44) )) ) , ( Comput (D48 , D47 , C44) )) );
L275: C44 <= ( C44 + 1 ) by NAT_1:12;
assume L276: ( C44 + 1 ) <= C43;
L277: C44 <= C43 by L276 , L275 , XXREAL_0:2;
L278: ( Comput (D39 , D42 , C44) ) = ( Comput (D48 , D47 , C44) ) by L277 , L259 , L263 , L195 , L264 , L262 , L265 , L268 , XXREAL_0:2;
L279: ( IC ( Comput (D48 , D47 , C44) ) ) in ( dom C42 ) by L278 , L263 , L4 , L264;
L280: ( IC ( Comput (D46 , D45 , C44) ) ) in ( dom ( Directed C42 ) ) by L279 , L276 , L272 , L275 , FUNCT_4:99 , XXREAL_0:2;
L281: ( CurInstr (D46 , ( Comput (D46 , D45 , C44) )) ) = ( D46 . ( IC ( Comput (D46 , D45 , C44) ) ) ) by PBOOLE:143
.= ( ( Directed C42 ) . ( IC ( Comput (D46 , D45 , C44) ) ) ) by L280 , FUNCT_4:13;
L282: ( CurInstr (D48 , ( Comput (D48 , D47 , C44) )) ) = ( D48 . ( IC ( Comput (D48 , D47 , C44) ) ) ) by PBOOLE:143
.= ( ( C42 ";" C42 ) . ( IC ( Comput (D48 , D47 , C44) ) ) ) by L271 , L279 , FUNCT_4:13
.= ( ( Directed C42 ) . ( IC ( Comput (D48 , D47 , C44) ) ) ) by L270 , L276 , L280 , L272 , L275 , GRFUNC_1:2 , XXREAL_0:2;
thus L283: thesis by L282 , L272 , L276 , L275 , L281 , L274 , L273 , XXREAL_0:2;
end;
L284: S6[ ( 0 ) ];
L285: (for B33 being (Element of ( NAT )) holds S6[ B33 ]) from NAT_1:sch 1(L284 , L269);
L286: ( Comput (D48 , D47 , C43) ) = ( Comput (D46 , D45 , C43) ) by L285;
thus L287: ( Comput (D39 , D42 , C43) ) = ( Comput (D46 , D45 , C43) ) by L286 , L259 , L263 , L265 , L268 , L195 , L264 , L262;
end;
L288: ( Comput (D39 , D42 , D43) ) = ( Comput (D46 , D45 , D43) ) by L267;
L289: ( C42 . D44 ) = ( D39 . D44 ) by L266 , L264 , GRFUNC_1:2
.= ( CurInstr (D39 , ( Comput (D39 , D42 , D43) )) ) by PBOOLE:143
.= ( halt ( SCM+FSA ) ) by L259 , L265 , EXTPRO_1:def 15;
L290: ( IC ( Comput (D46 , D45 , D43) ) ) in ( dom ( Directed C42 ) ) by L266 , L288 , FUNCT_4:99;
L291: ( D46 . D44 ) = ( ( Directed C42 ) . D44 ) by L290 , L288 , FUNCT_4:13
.= ( goto ( card C42 ) ) by L266 , L289 , FUNCT_4:106;
L292: ( Comput (D46 , D45 , ( D43 + 1 )) ) = ( Following (D46 , ( Comput (D46 , D45 , D43) )) ) by EXTPRO_1:3
.= ( Exec (( goto ( card C42 ) ) , ( Comput (D46 , D45 , D43) )) ) by L288 , L291 , PBOOLE:143;
L293: ((for B34 being Int-Location holds ( ( Comput (D46 , D45 , ( D43 + 1 )) ) . B34 ) = ( ( Comput (D46 , D45 , D43) ) . B34 )) & (for B35 being FinSeq-Location holds ( ( Comput (D46 , D45 , ( D43 + 1 )) ) . B35 ) = ( ( Comput (D46 , D45 , D43) ) . B35 ))) by L292 , SCMFSA_2:69;
L294: ( dom ( Directed C42 ) ) = ( dom C42 ) by FUNCT_4:99;
L295: ( ( R9 +* C42 ) +* ( Directed C42 ) ) = ( R9 +* ( Directed C42 ) ) by L294 , FUNCT_4:74
.= R9 by L260 , FUNCT_4:98;
thus L296: thesis by L295 , L265 , L293 , L262 , SCMFSA_M:2;
end;
theorem
L297: (for R4 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B36 being  InitHalting (Program of ( SCM+FSA )) holds ((( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= R4 & B36 c= R9) implies (for B37 being (Element of ( NAT )) holds (B37 <= ( LifeSpan (R9 , R4) ) implies ( CurInstr (( R9 +* ( Directed B36 ) ) , ( Comput (( R9 +* ( Directed B36 ) ) , R4 , B37) )) ) <> ( halt ( SCM+FSA ) )))))))
proof
let R4 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
set D49 = ( NAT );
let C45 being  InitHalting (Program of ( SCM+FSA ));
set D50 = ( R4 +* D3 );
set D51 = ( R9 +* ( Directed C45 ) );
set D52 = ( LifeSpan (R9 , R4) );
L298: D50 = R4 by FUNCT_4:21;
assume L299: D2 c= R4;
assume L300: C45 c= R9;
L301: R9 halts_on R4 by L300 , L299 , L5;
L302:
now
set D53 = ( R4 +* D3 );
set D54 = ( R9 +* ( C45 ";" C45 ) );
L303: R4 = D53 by FUNCT_4:21;
let C46 being (Element of ( NAT ));
defpred S7[ Nat ] means ($1 <= C46 implies ( Comput (D54 , D53 , $1) ) = ( Comput (D51 , D50 , $1) ));
assume L304: C46 <= D52;
L305: (for B38 being (Element of ( NAT )) holds (S7[ B38 ] implies S7[ ( B38 + 1 ) ]))
proof
L306: ( Directed C45 ) c= ( C45 ";" C45 ) by SCMFSA6A:16;
let C47 being (Element of ( NAT ));
L307: ( dom C45 ) c= ( dom ( C45 ";" C45 ) ) by SCMFSA6A:17;
assume L308: (C47 <= C46 implies ( Comput (D54 , D53 , C47) ) = ( Comput (D51 , D50 , C47) ));
L309: ( Comput (D51 , D50 , ( C47 + 1 )) ) = ( Following (D51 , ( Comput (D51 , D50 , C47) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D51 , ( Comput (D51 , D50 , C47) )) ) , ( Comput (D51 , D50 , C47) )) );
L310: ( Comput (D54 , D53 , ( C47 + 1 )) ) = ( Following (D54 , ( Comput (D54 , D53 , C47) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D54 , ( Comput (D54 , D53 , C47) )) ) , ( Comput (D54 , D53 , C47) )) );
L311: C47 <= ( C47 + 1 ) by NAT_1:12;
assume L312: ( C47 + 1 ) <= C46;
L313: C47 <= C46 by L312 , L311 , XXREAL_0:2;
L314: ( Comput (R9 , R4 , C47) ) = ( Comput (D54 , D53 , C47) ) by L313 , L299 , L301 , L195 , L300 , L303 , L304 , XXREAL_0:2;
L315: ( IC ( Comput (D54 , D53 , C47) ) ) in ( dom C45 ) by L314 , L299 , L4 , L300;
L316: ( IC ( Comput (D51 , D50 , C47) ) ) in ( dom ( Directed C45 ) ) by L315 , L312 , L308 , L311 , FUNCT_4:99 , XXREAL_0:2;
L317: ( CurInstr (D51 , ( Comput (D51 , D50 , C47) )) ) = ( D51 . ( IC ( Comput (D51 , D50 , C47) ) ) ) by PBOOLE:143
.= ( ( Directed C45 ) . ( IC ( Comput (D51 , D50 , C47) ) ) ) by L316 , FUNCT_4:13;
L318: ( CurInstr (D54 , ( Comput (D54 , D53 , C47) )) ) = ( D54 . ( IC ( Comput (D54 , D53 , C47) ) ) ) by PBOOLE:143
.= ( ( C45 ";" C45 ) . ( IC ( Comput (D54 , D53 , C47) ) ) ) by L307 , L315 , FUNCT_4:13
.= ( ( Directed C45 ) . ( IC ( Comput (D54 , D53 , C47) ) ) ) by L306 , L312 , L316 , L308 , L311 , GRFUNC_1:2 , XXREAL_0:2;
thus L319: thesis by L318 , L308 , L312 , L311 , L317 , L310 , L309 , XXREAL_0:2;
end;
L320: S7[ ( 0 ) ];
L321: (for B39 being (Element of ( NAT )) holds S7[ B39 ]) from NAT_1:sch 1(L320 , L305);
L322: ( Comput (D54 , D53 , C46) ) = ( Comput (D51 , D50 , C46) ) by L321;
thus L323: ( Comput (R9 , R4 , C46) ) = ( Comput (D51 , D50 , C46) ) by L322 , L299 , L301 , L304 , L195 , L300 , L303;
end;
let C48 being (Element of ( NAT ));
set D55 = ( IC ( Comput (R9 , R4 , C48) ) );
L324: (( IC ( Comput (R9 , R4 , C48) ) ) in ( dom C45 ) & ( dom C45 ) = ( dom ( Directed C45 ) )) by L299 , L300 , L4 , FUNCT_4:99;
L325: ( ( Directed C45 ) . D55 ) in ( rng ( Directed C45 ) ) by L324 , FUNCT_1:def 3;
assume L326: C48 <= ( LifeSpan (R9 , R4) );
L327: D55 = ( IC ( Comput (D51 , D50 , C48) ) ) by L326 , L302;
L328: ( CurInstr (D51 , ( Comput (D51 , D50 , C48) )) ) = ( D51 . D55 ) by L327 , PBOOLE:143
.= ( ( Directed C45 ) . D55 ) by L324 , FUNCT_4:13;
assume L329: ( CurInstr (( R9 +* ( Directed C45 ) ) , ( Comput (( R9 +* ( Directed C45 ) ) , R4 , C48) )) ) = ( halt ( SCM+FSA ) );
thus L330: contradiction by L329 , L328 , L325 , L298 , SCMFSA6A:1;
end;
theorem
L331: (for R4 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B40 being  InitClosed (Program of ( SCM+FSA )) holds (( R9 +* B40 ) halts_on ( Initialized R4 ) implies (for B41 being (Program of ( SCM+FSA )) holds (for B42 being (Element of ( NAT )) holds (B42 <= ( LifeSpan (( R9 +* B40 ) , ( Initialized R4 )) ) implies ( Comput (( R9 +* B40 ) , ( Initialized R4 ) , B42) ) = ( Comput (( R9 +* ( B40 ";" B41 ) ) , ( Initialized R4 ) , B42) ))))))))
proof
let R4 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C49 being  InitClosed (Program of ( SCM+FSA ));
assume L332: ( R9 +* C49 ) halts_on ( Initialized R4 );
set D56 = ( Initialized R4 );
set D57 = ( R9 +* C49 );
L333: C49 c= D57 by FUNCT_4:25;
let C50 being (Program of ( SCM+FSA ));
set D58 = ( Initialized R4 );
set D59 = ( R9 +* ( C49 ";" C50 ) );
defpred S8[ Nat ] means ($1 <= ( LifeSpan (D57 , D56) ) implies ( Comput (D57 , D56 , $1) ) = ( Comput (D59 , D58 , $1) ));
L334: (for R1 being (Element of ( NAT )) holds (S8[ R1 ] implies S8[ ( R1 + 1 ) ]))
proof
L335: ( dom ( C49 ";" C50 ) ) = ( ( dom ( Directed C49 ) ) \/ ( dom ( Reloc (C50 , ( card C49 )) ) ) ) by FUNCT_4:def 1
.= ( ( dom C49 ) \/ ( dom ( Reloc (C50 , ( card C49 )) ) ) ) by FUNCT_4:99;
L336: ( dom C49 ) c= ( dom ( C49 ";" C50 ) ) by L335 , XBOOLE_1:7;
set D60 = D58;
set D61 = D59;
L337: ( C49 ";" C50 ) c= D59 by FUNCT_4:25;
let R1 being (Element of ( NAT ));
assume L338: (R1 <= ( LifeSpan (D57 , D56) ) implies ( Comput (D57 , D56 , R1) ) = ( Comput (D59 , D58 , R1) ));
assume L339: ( R1 + 1 ) <= ( LifeSpan (D57 , D56) );
L340: ( Comput (D57 , D56 , ( R1 + 1 )) ) = ( Following (D57 , ( Comput (D57 , D56 , R1) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D57 , ( Comput (D57 , D56 , R1) )) ) , ( Comput (D57 , D56 , R1) )) );
L341: ( Comput (D61 , D60 , ( R1 + 1 )) ) = ( Following (D61 , ( Comput (D61 , D60 , R1) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D61 , ( Comput (D61 , D60 , R1) )) ) , ( Comput (D61 , D60 , R1) )) );
L342: D2 c= D56 by FUNCT_4:25;
L343: ( IC ( Comput (D57 , D56 , R1) ) ) in ( dom C49 ) by L342 , L4 , L333;
L344: ( D57 /. ( IC ( Comput (D57 , D56 , R1) ) ) ) = ( D57 . ( IC ( Comput (D57 , D56 , R1) ) ) ) by PBOOLE:143;
L345: ( CurInstr (D57 , ( Comput (D57 , D56 , R1) )) ) = ( C49 . ( IC ( Comput (D57 , D56 , R1) ) ) ) by L343 , L344 , L333 , GRFUNC_1:2;
L346: ( D61 /. ( IC ( Comput (D61 , D60 , R1) ) ) ) = ( D61 . ( IC ( Comput (D61 , D60 , R1) ) ) ) by PBOOLE:143;
L347: R1 < ( LifeSpan (D57 , D56) ) by L339 , NAT_1:13;
L348: ( C49 . ( IC ( Comput (D57 , D56 , R1) ) ) ) <> ( halt ( SCM+FSA ) ) by L347 , L332 , L345 , EXTPRO_1:def 15;
L349: ( CurInstr (D57 , ( Comput (D57 , D56 , R1) )) ) = ( ( C49 ";" C50 ) . ( IC ( Comput (D57 , D56 , R1) ) ) ) by L348 , L343 , L345 , SCMFSA6A:15
.= ( CurInstr (D61 , ( Comput (D61 , D60 , R1) )) ) by L346 , L339 , L343 , L336 , L337 , L338 , GRFUNC_1:2 , NAT_1:13;
thus L350: thesis by L349 , L338 , L339 , L340 , L341 , NAT_1:13;
end;
L351: S8[ ( 0 ) ];
thus L352: (for B43 being (Element of ( NAT )) holds S8[ B43 ]) from NAT_1:sch 1(L351 , L334);
end;
theorem
L353: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B44 being  keepInt0_1  InitHalting (Program of ( SCM+FSA )) holds (for B45 being  InitHalting (Program of ( SCM+FSA )) holds (for B46 being (State of ( SCM+FSA )) holds ((( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= B46 & ( B44 ";" B45 ) c= R9) implies (( IC ( Comput (R9 , B46 , ( ( LifeSpan (( R9 +* B44 ) , B46) ) + 1 )) ) ) = ( card B44 ) & ( DataPart ( Comput (R9 , B46 , ( ( LifeSpan (( R9 +* B44 ) , B46) ) + 1 )) ) ) = ( DataPart ( ( Comput (( R9 +* B44 ) , B46 , ( LifeSpan (( R9 +* B44 ) , B46) )) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) & ( Reloc (B45 , ( card B44 )) ) c= R9 & ( ( Comput (R9 , B46 , ( ( LifeSpan (( R9 +* B44 ) , B46) ) + 1 )) ) . ( intloc ( 0 ) ) ) = 1 & R9 halts_on B46 & ( LifeSpan (R9 , B46) ) = ( ( ( LifeSpan (( R9 +* B44 ) , B46) ) + 1 ) + ( LifeSpan (( ( R9 +* B44 ) +* B45 ) , ( ( Result (( R9 +* B44 ) , B46) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) ) & (B45 is  keeping_0 implies ( ( Result (R9 , B46) ) . ( intloc ( 0 ) ) ) = 1)))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
set D62 = ( Data-Locations ( SCM+FSA ) );
let C51 being  keepInt0_1  InitHalting (Program of ( SCM+FSA ));
let C52 being  InitHalting (Program of ( SCM+FSA ));
let C53 being (State of ( SCM+FSA ));
set D63 = ( C53 +* D3 );
set D64 = ( R9 +* C51 );
set D65 = ( ( Comput (D64 , C53 , ( LifeSpan (D64 , C53) )) ) +* D2 );
set D66 = ( D64 +* C52 );
set D67 = ( LifeSpan (D64 , C53) );
set D68 = ( LifeSpan (D66 , D65) );
L354: C52 c= D66 by FUNCT_4:25;
assume L355: D2 c= C53;
L356: C53 = ( Initialized C53 ) by L355 , FUNCT_4:98;
assume L357: ( C51 ";" C52 ) c= R9;
L358: ( R9 +* ( C51 ";" C52 ) ) = R9 by L357 , FUNCT_4:98;
L359: C51 c= D64 by FUNCT_4:25;
set D69 = ( Comput (R9 , C53 , ( D67 + 1 )) );
set D70 = R9;
L360: ( Directed C51 ) c= ( C51 ";" C52 ) by SCMFSA6A:16;
L361: ( Directed C51 ) c= R9 by L360 , L357 , XBOOLE_1:1;
L362: R9 = ( R9 +* ( Directed C51 ) ) by L357 , L360 , FUNCT_4:98 , XBOOLE_1:1;
reconsider D71 = ( ( D67 + 1 ) + D68 ) as (Element of ( NAT ));
L363: ( dom ( Directed C51 ) ) = ( dom C51 ) by FUNCT_4:99;
L364: ( D64 +* ( Directed C51 ) ) = ( R9 +* ( C51 +* ( Directed C51 ) ) ) by FUNCT_4:14
.= R9 by L362 , L363 , FUNCT_4:19;
L365: D2 c= D65 by FUNCT_4:25;
L366: ( dom D2 ) c= ( dom D65 ) by L365 , GRFUNC_1:2;
L367: ( dom D2 ) c= (the carrier of ( SCM+FSA )) by L366 , PARTFUN1:def 2;
L368: ( Reloc (C52 , ( card C51 )) ) c= ( C51 ";" C52 ) by FUNCT_4:25;
L369: C51 c= ( R9 +* C51 ) by FUNCT_4:25;
L370: ( R9 +* C51 ) halts_on C53 by L369 , L5 , L355;
thus L371: ( IC ( Comput (R9 , C53 , ( ( LifeSpan (( R9 +* C51 ) , C53) ) + 1 )) ) ) = ( card C51 ) by L370 , L355 , L217 , L361;
L372:
now
let C54 being set;
assume L373: C54 in ( dom ( DataPart D2 ) );
L374: C54 in ( ( dom D2 ) /\ D62 ) by L373 , RELAT_1:61;
L375: C54 in ( dom D2 ) by L374 , XBOOLE_0:def 4;
L376: C54 in { ( IC ( SCM+FSA ) ) , ( intloc ( 0 ) ) } by L375 , L3 , ENUMSET1:1;
L377: C54 in D62 by L374 , XBOOLE_0:def 4;
per cases  by L376 , TARSKI:def 2;
suppose L378: C54 = ( intloc ( 0 ) );

thus L379: ( ( DataPart D2 ) . C54 ) = 1 by L378 , L377 , FUNCT_1:49 , SCMFSA_M:12
.= ( ( Comput (D64 , C53 , D67) ) . C54 ) by L378 , L6 , L359 , L355
.= ( ( DataPart ( Comput (D64 , C53 , D67) ) ) . C54 ) by L377 , FUNCT_1:49;
end;
suppose L380: C54 = ( IC ( SCM+FSA ) );

L381: (not C54 in ( Data-Locations ( SCM+FSA ) )) by L380 , STRUCT_0:3;
thus L382: ( ( DataPart D2 ) . C54 ) = ( ( DataPart ( Comput (D64 , C53 , D67) ) ) . C54 ) by L381 , L374 , XBOOLE_0:def 4;
end;
end;
L384: D66 halts_on D65 by L5 , L354 , L365;
L385: ( dom ( DataPart D2 ) ) = ( ( dom D2 ) /\ D62 ) by RELAT_1:61;
L386: ( dom ( DataPart D2 ) ) c= ( (the carrier of ( SCM+FSA )) /\ D62 ) by L385 , L367 , XBOOLE_1:26;
L387: ( dom ( DataPart D2 ) ) c= ( ( dom ( Comput (D64 , C53 , D67) ) ) /\ D62 ) by L386 , PARTFUN1:def 2;
L388: ( dom ( DataPart D2 ) ) c= ( dom ( DataPart ( Comput (D64 , C53 , D67) ) ) ) by L387 , RELAT_1:61;
L389: ( DataPart D65 ) = ( ( DataPart ( Comput (D64 , C53 , D67) ) ) +* ( DataPart D2 ) ) by FUNCT_4:71;
L390: ( DataPart D2 ) c= ( DataPart ( Comput (D64 , C53 , D67) ) ) by L372 , L388 , GRFUNC_1:2;
L391: ( DataPart ( Comput (D64 , C53 , D67) ) ) = ( DataPart D65 ) by L390 , L389 , FUNCT_4:98;
L392: ( R9 +* C51 ) halts_on C53 by L355 , L5 , L369;
L393: ( DataPart ( Comput (R9 , C53 , D67) ) ) = ( DataPart D65 ) by L391 , L356 , L370 , L331 , L358;
thus L394: ( DataPart ( Comput (R9 , C53 , ( D67 + 1 )) ) ) = ( DataPart D65 ) by L393 , L355 , L258 , L361 , L392;
thus L395: ( Reloc (C52 , ( card C51 )) ) c= R9 by L357 , L368 , XBOOLE_1:1;
L396: ( Reloc (C52 , ( card C51 )) ) c= D70 by L368 , L357 , XBOOLE_1:1;
L397: ( intloc ( 0 ) ) in ( Int-Locations ) by AMI_2:def 16;
L398: ( intloc ( 0 ) ) in D62 by L397 , SCMFSA_2:100 , XBOOLE_0:def 3;
thus L399: ( D69 . ( intloc ( 0 ) ) ) = ( ( DataPart D65 ) . ( intloc ( 0 ) ) ) by L398 , L394 , FUNCT_1:49
.= ( D65 . ( intloc ( 0 ) ) ) by L398 , FUNCT_1:49
.= 1 by FUNCT_4:13 , SCMFSA_M:10 , SCMFSA_M:12;
L400: ( Comput (R9 , C53 , ( ( D67 + 1 ) + D68 )) ) = ( Comput (R9 , ( Comput (R9 , C53 , ( D67 + 1 )) ) , D68) ) by EXTPRO_1:4;
L401: D2 c= D65 by FUNCT_4:25;
L402: ( IncAddr (( CurInstr (D66 , ( Comput (D66 , D65 , D68) )) ) , ( card C51 )) ) = ( CurInstr (R9 , ( Comput (R9 , C53 , ( ( D67 + 1 ) + D68 )) )) ) by L401 , L400 , L371 , L394 , L122 , L354 , L396;
L403: ( CurInstr (R9 , ( Comput (R9 , C53 , D71) )) ) = ( IncAddr (( halt ( SCM+FSA ) ) , ( card C51 )) ) by L402 , L384 , EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
thus L404: R9 halts_on C53 by L403 , EXTPRO_1:29;
L405:
now
let C55 being (Element of ( NAT ));
assume L406: ( ( D67 + 1 ) + C55 ) < D71;
L407: C55 < D68 by L406 , XREAL_1:6;
assume L408: ( CurInstr (R9 , ( Comput (R9 , C53 , ( ( D67 + 1 ) + C55 )) )) ) = ( halt ( SCM+FSA ) );
L409: ( IncAddr (( CurInstr (D66 , ( Comput (D66 , D65 , C55) )) ) , ( card C51 )) ) = ( CurInstr (D70 , ( Comput (R9 , D69 , C55) )) ) by L371 , L394 , L401 , L122 , L354 , L396
.= ( halt ( SCM+FSA ) ) by L408 , EXTPRO_1:4;
L410: ( InsCode ( halt ( SCM+FSA ) ) ) = ( 0 ) by COMPOS_1:70;
L411: ( InsCode ( CurInstr (D66 , ( Comput (D66 , D65 , C55) )) ) ) = ( 0 ) by L410 , COMPOS_0:def 9 , L409;
L412: ( CurInstr (D66 , ( Comput (D66 , D65 , C55) )) ) = ( halt ( SCM+FSA ) ) by L411 , SCMFSA_2:95;
thus L413: contradiction by L412 , L384 , L407 , EXTPRO_1:def 15;
end;
L414:
now
let C56 being (Element of ( NAT ));
assume L415: C56 < D71;
per cases ;
suppose L416: C56 <= D67;

thus L417: ( CurInstr (R9 , ( Comput (R9 , C53 , C56) )) ) <> ( halt ( SCM+FSA ) ) by L416 , L297 , L364 , L355 , FUNCT_4:25;
end;
suppose L418: D67 < C56;

L419: ( D67 + 1 ) <= C56 by L418 , NAT_1:13;
consider C57 being Nat such that L420: ( ( D67 + 1 ) + C57 ) = C56 by L419 , NAT_1:10;
reconsider D72 = C57 as (Element of ( NAT )) by ORDINAL1:def 12;
L421: ( ( D67 + 1 ) + D72 ) = C56 by L420;
thus L422: ( CurInstr (R9 , ( Comput (R9 , C53 , C56) )) ) <> ( halt ( SCM+FSA ) ) by L421 , L405 , L415;
end;
end;
L424: (for B47 being (Element of ( NAT )) holds (( CurInstr (R9 , ( Comput (R9 , C53 , B47) )) ) = ( halt ( SCM+FSA ) ) implies D71 <= B47)) by L414;
L425: ( LifeSpan (R9 , C53) ) = D71 by L424 , L403 , L404 , EXTPRO_1:def 15;
L426: C51 c= ( R9 +* C51 ) by FUNCT_4:25;
L427: D64 halts_on C53 by L426 , L5 , L355;
L428: ( Comput (D64 , C53 , ( LifeSpan (D64 , C53) )) ) = ( Result (( R9 +* C51 ) , C53) ) by L427 , EXTPRO_1:23;
thus L429: ( LifeSpan (R9 , C53) ) = ( ( ( LifeSpan (( R9 +* C51 ) , C53) ) + 1 ) + ( LifeSpan (( ( R9 +* C51 ) +* C52 ) , ( ( Result (( R9 +* C51 ) , C53) ) +* D2 )) ) ) by L428 , L424 , L403 , L404 , EXTPRO_1:def 15;
L430: D2 c= D65 by FUNCT_4:25;
L431: ( DataPart ( Comput (D66 , D65 , D68) ) ) = ( DataPart ( Comput (D70 , D69 , D68) ) ) by L371 , L394 , L401 , L122 , L354 , L396;
assume L432: C52 is  keeping_0;
thus L433: ( ( Result (R9 , C53) ) . ( intloc ( 0 ) ) ) = ( ( Comput (R9 , C53 , D71) ) . ( intloc ( 0 ) ) ) by L404 , L425 , EXTPRO_1:23
.= ( ( Comput (R9 , D69 , D68) ) . ( intloc ( 0 ) ) ) by EXTPRO_1:4
.= ( ( Comput (D66 , D65 , D68) ) . ( intloc ( 0 ) ) ) by L431 , SCMFSA_M:2
.= ( D65 . ( intloc ( 0 ) ) ) by L432 , L354 , SCMFSA6B:def 4
.= 1 by L430 , GRFUNC_1:2 , SCMFSA_M:10 , SCMFSA_M:12;
end;
registration
let C58 being  keepInt0_1  InitHalting (Program of ( SCM+FSA ));
let C59 being  InitHalting (Program of ( SCM+FSA ));
cluster ( C58 ";" C59 ) ->  InitHalting;
coherence
proof
set D73 = ( Data-Locations ( SCM+FSA ) );
let C60 being (State of ( SCM+FSA ));
assume L434: D2 c= C60;
L435: C60 = ( Initialized C60 ) by L434 , FUNCT_4:98;
let R9 being (Instruction-Sequence of ( SCM+FSA ));
assume L436: ( C58 ";" C59 ) c= R9;
L437: R9 = ( R9 +* ( C58 ";" C59 ) ) by L436 , FUNCT_4:98;
set D74 = ( R9 +* C58 );
set D75 = ( ( Comput (D74 , C60 , ( LifeSpan (D74 , C60) )) ) +* D2 );
set D76 = ( D74 +* C59 );
L438: C59 c= D76 by FUNCT_4:25;
set D77 = ( LifeSpan (D74 , C60) );
set D78 = ( Comput (R9 , C60 , ( D77 + 1 )) );
L439: C58 c= D74 by FUNCT_4:25;
L440: ( Reloc (C59 , ( card C58 )) ) c= ( C58 ";" C59 ) by FUNCT_4:25;
set D79 = ( LifeSpan (D76 , D75) );
L441: ( dom ( DataPart D2 ) ) = ( ( dom D2 ) /\ D73 ) by RELAT_1:61;
reconsider D80 = ( ( D77 + 1 ) + D79 ) as (Element of ( NAT ));
L442: D2 c= ( Initialized C60 ) by FUNCT_4:25;
L443: C58 c= ( R9 +* C58 ) by FUNCT_4:25;
L444: ( R9 +* C58 ) halts_on ( Initialized C60 ) by L443 , L5 , L442;
L445:
now
let C61 being set;
L446: ( DataPart D2 ) c= D2 by RELAT_1:59;
L447: ( dom ( DataPart D2 ) ) c= ( dom D2 ) by L446 , RELAT_1:11;
assume L448: C61 in ( dom ( DataPart D2 ) );
L449: C61 in ( dom D2 ) by L448 , L447;
L450: C61 in { ( intloc ( 0 ) ) , ( IC ( SCM+FSA ) ) } by L449 , L3 , ENUMSET1:1;
per cases  by L450 , TARSKI:def 2;
suppose L451: C61 = ( intloc ( 0 ) );

L452: C61 in ( Int-Locations ) by L451 , AMI_2:def 16;
L453: C61 in D73 by L452 , SCMFSA_2:100 , XBOOLE_0:def 3;
thus L454: ( ( DataPart ( Comput (D74 , C60 , D77) ) ) . C61 ) = ( ( Comput (D74 , C60 , D77) ) . C61 ) by L453 , FUNCT_1:49
.= 1 by L434 , L451 , L6 , L439
.= ( ( DataPart D2 ) . C61 ) by L453 , L451 , FUNCT_1:49 , SCMFSA_M:12;
end;
suppose L455: C61 = ( IC ( SCM+FSA ) );

L456: ( dom ( DataPart D2 ) ) c= ( Data-Locations ( SCM+FSA ) ) by RELAT_1:58;
thus L457: ( ( DataPart D2 ) . C61 ) = ( ( DataPart ( Comput (D74 , C60 , D77) ) ) . C61 ) by L456 , L455 , L448 , STRUCT_0:3;
end;
end;
take D80;
L459: ( IC ( Comput (R9 , C60 , D80) ) ) in ( NAT );
thus L460: ( IC ( Comput (R9 , C60 , D80) ) ) in ( dom R9 ) by L459 , PARTFUN1:def 2;
L461: ( Directed C58 ) c= ( C58 ";" C59 ) by SCMFSA6A:16;
L462: ( Directed C58 ) c= R9 by L461 , L436 , XBOOLE_1:1;
L463: D2 c= D75 by FUNCT_4:25;
L464: ( dom D2 ) c= ( dom D75 ) by L463 , GRFUNC_1:2;
L465: ( dom D2 ) c= (the carrier of ( SCM+FSA )) by L464 , PARTFUN1:def 2;
L466: ( dom ( DataPart D2 ) ) c= ( (the carrier of ( SCM+FSA )) /\ D73 ) by L465 , L441 , XBOOLE_1:26;
L467: ( dom ( DataPart D2 ) ) c= ( ( dom ( Comput (D74 , C60 , D77) ) ) /\ D73 ) by L466 , PARTFUN1:def 2;
L468: ( dom ( DataPart D2 ) ) c= ( dom ( DataPart ( Comput (D74 , C60 , D77) ) ) ) by L467 , RELAT_1:61;
L469: ( DataPart D2 ) c= ( DataPart ( Comput (D74 , C60 , D77) ) ) by L468 , L445 , GRFUNC_1:2;
L470: ( DataPart ( Comput (D74 , C60 , D77) ) ) = ( ( DataPart ( Comput (D74 , C60 , ( LifeSpan (D74 , C60) )) ) ) +* ( DataPart D2 ) ) by L469 , FUNCT_4:98
.= ( DataPart D75 ) by FUNCT_4:71;
L471: ( DataPart ( Comput (R9 , C60 , D77) ) ) = ( DataPart D75 ) by L470 , L435 , L437 , L444 , L331;
L472: C58 c= ( R9 +* C58 ) by FUNCT_4:25;
L473: ( R9 +* C58 ) halts_on C60 by L472 , L434 , L5;
L474: ( DataPart ( Comput (R9 , C60 , ( D77 + 1 )) ) ) = ( DataPart D75 ) by L473 , L434 , L258 , L471 , L462;
L475: ( Comput (R9 , C60 , ( ( D77 + 1 ) + D79 )) ) = ( Comput (R9 , ( Comput (R9 , C60 , ( D77 + 1 )) ) , D79) ) by EXTPRO_1:4;
L476: ( Reloc (C59 , ( card C58 )) ) c= R9 by L440 , L436 , XBOOLE_1:1;
L477: D2 c= D75 by FUNCT_4:25;
L478: ( IC ( Comput (R9 , C60 , ( ( LifeSpan (( R9 +* C58 ) , C60) ) + 1 )) ) ) = ( card C58 ) by L473 , L462 , L217 , L434;
L479: ( IncAddr (( CurInstr (D76 , ( Comput (D76 , D75 , D79) )) ) , ( card C58 )) ) = ( CurInstr (R9 , ( Comput (R9 , C60 , ( ( D77 + 1 ) + D79 )) )) ) by L475 , L477 , L438 , L476 , L122 , L478 , L474;
L480: D76 halts_on D75 by L438 , L5 , L477;
L481: ( CurInstr (R9 , ( Comput (R9 , C60 , D80) )) ) = ( IncAddr (( halt ( SCM+FSA ) ) , ( card C58 )) ) by L480 , L479 , EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
thus L482: thesis by L481;
end;
end;
theorem
L484: (for R4 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B48 being  keepInt0_1 (Program of ( SCM+FSA )) holds (( R9 +* B48 ) halts_on R4 implies (for B49 being  InitClosed (Program of ( SCM+FSA )) holds ((( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= R4 & ( B48 ";" B49 ) c= R9) implies (for B50 being (Element of ( NAT )) holds ( ( Comput (( ( R9 +* B48 ) +* B49 ) , ( ( Result (( R9 +* B48 ) , R4) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) , B50) ) +* ( Start-At (( ( IC ( Comput (( ( R9 +* B48 ) +* B49 ) , ( ( Result (( R9 +* B48 ) , R4) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) , B50) ) ) + ( card B48 ) ) , ( SCM+FSA )) ) ) = ( Comput (( R9 +* ( B48 ";" B49 ) ) , R4 , ( ( ( LifeSpan (( R9 +* B48 ) , R4) ) + 1 ) + B50 )) ))))))))
proof
let R4 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C62 being  keepInt0_1 (Program of ( SCM+FSA ));
assume L485: ( R9 +* C62 ) halts_on R4;
let C63 being  InitClosed (Program of ( SCM+FSA ));
set D81 = ( R4 +* D2 );
set D82 = ( R9 +* C62 );
L486: C62 c= D82 by FUNCT_4:25;
L487: D2 c= D81 by FUNCT_4:25;
set D83 = ( Result (( R9 +* C62 ) , ( R4 +* D2 )) );
set D84 = ( R9 +* C62 );
set D85 = ( D83 +* D2 );
set D86 = ( D84 +* C63 );
set D87 = ( Initialized R4 );
set D88 = ( R9 +* ( C62 ";" C63 ) );
defpred S9[ Nat ] means ( ( Comput (D86 , D85 , $1) ) +* ( Start-At (( ( IC ( Comput (D86 , D85 , $1) ) ) + ( card C62 ) ) , ( SCM+FSA )) ) ) = ( Comput (D88 , D87 , ( ( ( LifeSpan (D82 , D81) ) + 1 ) + $1 )) );
assume L488: D2 c= R4;
L489: R4 = D87 by L488 , FUNCT_4:98;
assume L490: ( C62 ";" C63 ) c= R9;
L491: D88 = R9 by L490 , FUNCT_4:98;
L492: (for B51 being (Element of ( NAT )) holds (S9[ B51 ] implies S9[ ( B51 + 1 ) ]))
proof
let C64 being (Element of ( NAT ));
set D89 = ( C64 + 1 );
set D90 = ( Comput (D86 , D85 , C64) );
set D91 = ( IncIC (D90 , ( card C62 )) );
set D92 = ( Comput (D88 , D87 , ( ( ( LifeSpan (D82 , D81) ) + 1 ) + C64 )) );
set D93 = ( Comput (D86 , D85 , D89) );
set D94 = ( D93 +* ( Start-At (( ( IC D93 ) + ( card C62 ) ) , ( SCM+FSA )) ) );
set D95 = ( Comput (D88 , D87 , ( ( ( LifeSpan (D82 , D81) ) + 1 ) + D89 )) );
assume L493: ( ( Comput (D86 , D85 , C64) ) +* ( Start-At (( ( IC ( Comput (D86 , D85 , C64) ) ) + ( card C62 ) ) , ( SCM+FSA )) ) ) = ( Comput (D88 , D87 , ( ( ( LifeSpan (D82 , D81) ) + 1 ) + C64 )) );
L494: ( IncAddr (( CurInstr (D86 , D90) ) , ( card C62 )) ) = ( CurInstr (D88 , D92) )
proof
L495: C63 c= D86 by FUNCT_4:25;
L496: D2 c= D85 by FUNCT_4:25;
L497: ( Reloc (C63 , ( card C62 )) ) c= ( C62 ";" C63 ) by FUNCT_4:25;
L498: ( C62 ";" C63 ) c= D88 by FUNCT_4:25;
L499: ( Reloc (C63 , ( card C62 )) ) c= D88 by L498 , L497 , XBOOLE_1:1;
L500: ( D88 /. ( IC D92 ) ) = ( D88 . ( IC D92 ) ) by PBOOLE:143;
L501: ( CurInstr (D88 , D92) ) = ( D88 . ( ( IC D90 ) + ( card C62 ) ) ) by L493 , L500 , FUNCT_4:113;
reconsider D96 = ( IC D90 ) as (Element of ( NAT ));
L502: ( IC D90 ) in ( dom C63 ) by L4 , L495 , L496;
L503: D96 in ( dom ( IncAddr (C63 , ( card C62 )) ) ) by L502 , COMPOS_1:def 21;
L504: ( ( Shift (( IncAddr (C63 , ( card C62 )) ) , ( card C62 )) ) . ( ( IC D90 ) + ( card C62 ) ) ) = ( ( IncAddr (C63 , ( card C62 )) ) . D96 ) by L503 , VALUED_1:def 12
.= ( IncAddr (( C63 /. D96 ) , ( card C62 )) ) by L502 , COMPOS_1:def 21;
L505: ( dom ( Shift (( IncAddr (C63 , ( card C62 )) ) , ( card C62 )) ) ) = { ( B52 + ( card C62 ) ) where B52 is (Element of ( NAT )) : B52 in ( dom ( IncAddr (C63 , ( card C62 )) ) ) } by VALUED_1:def 12;
L506: ( ( IC D90 ) + ( card C62 ) ) in ( dom ( Shift (( IncAddr (C63 , ( card C62 )) ) , ( card C62 )) ) ) by L505 , L503;
L507: ( C63 /. D96 ) = ( C63 . ( IC D90 ) ) by L502 , PARTFUN1:def 6
.= ( D86 . ( IC D90 ) ) by L502 , L495 , GRFUNC_1:2;
L508: ( CurInstr (D86 , D90) ) = ( D86 . ( IC D90 ) ) by PBOOLE:143;
thus L509: ( IncAddr (( CurInstr (D86 , D90) ) , ( card C62 )) ) = ( CurInstr (D88 , D92) ) by L508 , L501 , L504 , L506 , L507 , L499 , GRFUNC_1:2;
end;
L510: ( Exec (( CurInstr (D88 , D92) ) , D92) ) = ( Exec (( IncAddr (( CurInstr (D86 , D90) ) , ( card C62 )) ) , D91) ) by L493 , L494;
L511: ( Exec (( CurInstr (D88 , D92) ) , D92) ) = ( IncIC (( Following (D86 , D90) ) , ( card C62 )) ) by L510 , AMISTD_5:4;
L512: D95 = ( Comput (D88 , D87 , ( ( ( ( LifeSpan (D82 , D81) ) + 1 ) + C64 ) + 1 )) );
L513: D95 = ( Following (D88 , D92) ) by L512 , EXTPRO_1:3;
L514:
now
let C65 being Int-Location;
thus L515: ( D94 . C65 ) = ( D93 . C65 ) by SCMFSA_3:3
.= ( ( Following (D86 , D90) ) . C65 ) by EXTPRO_1:3
.= ( D95 . C65 ) by L513 , L511 , SCMFSA_3:3;
end;
L516:
now
let C66 being FinSeq-Location;
thus L517: ( D94 . C66 ) = ( D93 . C66 ) by SCMFSA_3:4
.= ( ( Following (D86 , D90) ) . C66 ) by EXTPRO_1:3
.= ( ( IncIC (( Following (D86 , D90) ) , ( card C62 )) ) . C66 ) by SCMFSA_3:4
.= ( D95 . C66 ) by L513 , L510 , AMISTD_5:4;
end;
L518: ( IC D94 ) = ( ( IC D93 ) + ( card C62 ) ) by FUNCT_4:113
.= ( ( IC ( Following (D86 , D90) ) ) + ( card C62 ) ) by EXTPRO_1:3;
L519: ( IC D94 ) = ( IC ( IncIC (( Following (D86 , D90) ) , ( card C62 )) ) ) by L518 , FUNCT_4:113
.= ( IC D95 ) by L513 , L510 , AMISTD_5:4;
thus L520: thesis by L519 , L514 , L516 , SCMFSA_2:61;
end;
L521: D81 = R4 by L488 , FUNCT_4:98;
L522: ( Directed C62 ) c= ( C62 ";" C63 ) by SCMFSA6A:16;
L523: ( Directed C62 ) c= R9 by L522 , L490 , XBOOLE_1:1;
L524:
now
set D97 = ( Comput (D88 , D87 , ( ( ( LifeSpan (D82 , D81) ) + 1 ) + ( 0 ) )) );
set D98 = ( IncIC (D85 , ( card C62 )) );
reconsider D99 = ( D83 +* ( ( intloc ( 0 ) ) .--> 1 ) ) as (State of ( SCM+FSA ));
L525: D85 = ( Initialize D99 ) by FUNCT_4:14;
thus L526: ( IC D98 ) = ( ( IC D85 ) + ( card C62 ) ) by FUNCT_4:113
.= ( ( 0 ) + ( card C62 ) ) by L525 , FUNCT_4:113
.= ( IC D97 ) by L485 , L521 , L217 , L523 , L491 , FUNCT_4:25;
L527: ( DataPart ( Comput (R9 , R4 , ( LifeSpan (D82 , D81) )) ) ) = ( DataPart ( Comput (R9 , R4 , ( ( LifeSpan (D82 , D81) ) + 1 )) ) ) by L485 , L489 , L258 , L523 , FUNCT_4:25;
thus L528:now
let C67 being Int-Location;
L529: (not C67 in ( dom ( Start-At (( ( IC D85 ) + ( card C62 ) ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L530: ( D98 . C67 ) = ( D85 . C67 ) by L529 , FUNCT_4:11;
L531: ( ( Comput (D82 , D81 , ( LifeSpan (D82 , D81) )) ) . C67 ) = ( ( Comput (D88 , D87 , ( LifeSpan (D82 , D81) )) ) . C67 ) by L485 , L521 , L331
.= ( D97 . C67 ) by L489 , L527 , L491 , SCMFSA_M:2;
per cases ;
suppose L532: C67 <> ( intloc ( 0 ) );

L533: C67 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L534: (not C67 in ( dom D2 )) by L533 , L532 , SCMFSA_M:11 , TARSKI:def 2;
thus L535: ( D98 . C67 ) = ( D83 . C67 ) by L534 , L530 , FUNCT_4:11
.= ( D97 . C67 ) by L485 , L521 , L531 , EXTPRO_1:23;
end;
suppose L536: C67 = ( intloc ( 0 ) );

L537: C67 in ( dom D2 ) by L536 , SCMFSA_M:11 , TARSKI:def 2;
thus L538: ( D98 . C67 ) = 1 by L537 , L536 , L530 , FUNCT_4:13 , SCMFSA_M:12
.= ( D97 . C67 ) by L531 , L536 , L6 , L486 , L487;
end;
end;
let C68 being FinSeq-Location;
L540: (C68 <> ( intloc ( 0 ) ) & C68 <> ( IC ( SCM+FSA ) )) by SCMFSA_2:57 , SCMFSA_2:58;
L541: (not C68 in ( dom D2 )) by L540 , SCMFSA_M:11 , TARSKI:def 2;
L542: (not C68 in ( dom ( Start-At (( ( IC D85 ) + ( card C62 ) ) , ( SCM+FSA )) ) )) by SCMFSA_2:103;
thus L543: ( D98 . C68 ) = ( D85 . C68 ) by L542 , FUNCT_4:11
.= ( D83 . C68 ) by L541 , FUNCT_4:11
.= ( ( Comput (D82 , D81 , ( LifeSpan (D82 , D81) )) ) . C68 ) by L485 , L521 , EXTPRO_1:23
.= ( ( Comput (D88 , D87 , ( LifeSpan (D82 , D81) )) ) . C68 ) by L485 , L521 , L331
.= ( D97 . C68 ) by L489 , L527 , L491 , SCMFSA_M:2;
end;
L544: S9[ ( 0 ) ] by L524 , SCMFSA_2:61;
L545: (for B53 being (Element of ( NAT )) holds S9[ B53 ]) from NAT_1:sch 1(L544 , L492);
thus L546: thesis by L545 , L521;
end;
theorem
L547: (for R4 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B54 being  keepInt0_1 (Program of ( SCM+FSA )) holds ((not ( R9 +* B54 ) halts_on ( Initialized R4 )) implies (for B55 being (Program of ( SCM+FSA )) holds (for B56 being (Element of ( NAT )) holds ( Comput (( R9 +* B54 ) , ( Initialized R4 ) , B56) ) = ( Comput (( R9 +* ( B54 ";" B55 ) ) , ( Initialized R4 ) , B56) )))))))
proof
let R4 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C69 being  keepInt0_1 (Program of ( SCM+FSA ));
assume L548: (not ( R9 +* C69 ) halts_on ( Initialized R4 ));
set D100 = ( Initialized R4 );
set D101 = ( R9 +* C69 );
L549: C69 c= D101 by FUNCT_4:25;
L550: D2 c= D100 by FUNCT_4:25;
let C70 being (Program of ( SCM+FSA ));
set D102 = ( Initialized R4 );
set D103 = ( R9 +* ( C69 ";" C70 ) );
L551: ( C69 ";" C70 ) c= D103 by FUNCT_4:25;
defpred S10[ Nat ] means ( Comput (D101 , D100 , $1) ) = ( Comput (D103 , D102 , $1) );
L552: (for R1 being (Element of ( NAT )) holds (S10[ R1 ] implies S10[ ( R1 + 1 ) ]))
proof
L553: ( dom ( C69 ";" C70 ) ) = ( ( dom ( Directed C69 ) ) \/ ( dom ( Reloc (C70 , ( card C69 )) ) ) ) by FUNCT_4:def 1
.= ( ( dom C69 ) \/ ( dom ( Reloc (C70 , ( card C69 )) ) ) ) by FUNCT_4:99;
L554: ( dom C69 ) c= ( dom ( C69 ";" C70 ) ) by L553 , XBOOLE_1:7;
set D104 = D102;
set D105 = D103;
let R1 being (Element of ( NAT ));
L555: ( Comput (D101 , D100 , ( R1 + 1 )) ) = ( Following (D101 , ( Comput (D101 , D100 , R1) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D101 , ( Comput (D101 , D100 , R1) )) ) , ( Comput (D101 , D100 , R1) )) );
L556: ( Comput (D105 , D104 , ( R1 + 1 )) ) = ( Following (D105 , ( Comput (D105 , D104 , R1) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D105 , ( Comput (D105 , D104 , R1) )) ) , ( Comput (D105 , D104 , R1) )) );
assume L557: ( Comput (D101 , D100 , R1) ) = ( Comput (D103 , D102 , R1) );
L558: ( IC ( Comput (D101 , D100 , R1) ) ) in ( dom C69 ) by L4 , L549 , L550;
L559: ( D101 /. ( IC ( Comput (D101 , D100 , R1) ) ) ) = ( D101 . ( IC ( Comput (D101 , D100 , R1) ) ) ) by PBOOLE:143;
L560: ( D105 /. ( IC ( Comput (D105 , D104 , R1) ) ) ) = ( D105 . ( IC ( Comput (D105 , D104 , R1) ) ) ) by PBOOLE:143;
L561: ( CurInstr (D101 , ( Comput (D101 , D100 , R1) )) ) = ( C69 . ( IC ( Comput (D101 , D100 , R1) ) ) ) by L558 , L559 , L549 , GRFUNC_1:2;
L562: ( C69 . ( IC ( Comput (D101 , D100 , R1) ) ) ) <> ( halt ( SCM+FSA ) ) by L561 , L548 , EXTPRO_1:29;
L563: ( CurInstr (D101 , ( Comput (D101 , D100 , R1) )) ) = ( ( C69 ";" C70 ) . ( IC ( Comput (D101 , D100 , R1) ) ) ) by L562 , L558 , L561 , SCMFSA6A:15
.= ( CurInstr (D105 , ( Comput (D105 , D104 , R1) )) ) by L557 , L558 , L554 , L560 , L551 , GRFUNC_1:2;
thus L564: thesis by L563 , L557 , L555 , L556;
end;
L565: S10[ ( 0 ) ];
thus L566: (for B57 being (Element of ( NAT )) holds S10[ B57 ]) from NAT_1:sch 1(L565 , L552);
end;
theorem
L567: (for R4 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B58 being  keepInt0_1  InitHalting (Program of ( SCM+FSA )) holds (for B59 being  InitHalting (Program of ( SCM+FSA )) holds ( LifeSpan (( R9 +* ( B58 ";" B59 ) ) , ( Initialized R4 )) ) = ( ( ( LifeSpan (( R9 +* B58 ) , ( Initialized R4 )) ) + 1 ) + ( LifeSpan (( ( R9 +* B58 ) +* B59 ) , ( ( Result (( R9 +* B58 ) , ( Initialized R4 )) ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) )))))
proof
let R4 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C71 being  keepInt0_1  InitHalting (Program of ( SCM+FSA ));
let C72 being  InitHalting (Program of ( SCM+FSA ));
set D106 = D2;
set D107 = D2;
set D108 = D2;
L568: (D108 c= ( ( Result (( ( R9 +* ( C71 ";" C72 ) ) +* C71 ) , ( R4 +* D107 )) ) +* D108 ) & D108 c= ( ( Result (( R9 +* C71 ) , ( R4 +* D106 )) ) +* D108 )) by FUNCT_4:25;
L569: (C72 c= ( ( ( R9 +* ( C71 ";" C72 ) ) +* C71 ) +* C72 ) & C72 c= ( ( R9 +* C71 ) +* C72 )) by FUNCT_4:25;
L570: (D106 c= ( R4 +* D106 ) & D106 c= ( R4 +* D107 )) by FUNCT_4:25;
L571: (C71 c= ( R9 +* C71 ) & C71 c= ( ( R9 +* ( C71 ";" C72 ) ) +* C71 )) by FUNCT_4:25;
L572: ( ( Result (( ( R9 +* ( C71 ";" C72 ) ) +* C71 ) , ( R4 +* D107 )) ) +* D108 ) = ( ( Result (( R9 +* C71 ) , ( R4 +* D106 )) ) +* D108 ) by L571 , L164 , L570;
L573: ( C71 ";" C72 ) c= ( R9 +* ( C71 ";" C72 ) ) by FUNCT_4:25;
L574: D107 c= ( R4 +* D107 ) by FUNCT_4:25;
L575: ( LifeSpan (( R9 +* ( C71 ";" C72 ) ) , ( R4 +* D107 )) ) = ( ( ( LifeSpan (( ( R9 +* ( C71 ";" C72 ) ) +* C71 ) , ( R4 +* D107 )) ) + 1 ) + ( LifeSpan (( ( ( R9 +* ( C71 ";" C72 ) ) +* C71 ) +* C72 ) , ( ( Result (( ( R9 +* ( C71 ";" C72 ) ) +* C71 ) , ( R4 +* D107 )) ) +* D108 )) ) ) by L574 , L353 , L573;
L576: ( LifeSpan (( R9 +* C71 ) , ( R4 +* D106 )) ) = ( LifeSpan (( ( R9 +* ( C71 ";" C72 ) ) +* C71 ) , ( R4 +* D107 )) ) by L570 , L164 , L571;
thus L577: thesis by L576 , L575 , L568 , L572 , L164 , L569;
end;
theorem
L578: (for R4 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B60 being  keepInt0_1  InitHalting (Program of ( SCM+FSA )) holds (for B61 being  InitHalting (Program of ( SCM+FSA )) holds ( IExec (( B60 ";" B61 ) , R9 , R4) ) = ( IncIC (( IExec (B61 , R9 , ( IExec (B60 , R9 , R4) )) ) , ( card B60 )) )))))
proof
let R4 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
set D109 = ( Data-Locations ( SCM+FSA ) );
set D110 = ( NAT );
let C73 being  keepInt0_1  InitHalting (Program of ( SCM+FSA ));
let C74 being  InitHalting (Program of ( SCM+FSA ));
set D111 = ( Initialized R4 );
set D112 = ( R9 +* C73 );
L579: C73 c= D112 by FUNCT_4:25;
set D113 = ( R9 +* ( C73 ";" C74 ) );
L580: ( C73 ";" C74 ) c= D113 by FUNCT_4:25;
set D114 = ( Initialized ( Comput (D112 , D111 , ( LifeSpan (D112 , D111) )) ) );
set D115 = ( D112 +* C74 );
L581: D2 c= D114 by FUNCT_4:25;
L582: C74 c= D115 by FUNCT_4:25;
set D116 = ( LifeSpan (D112 , D111) );
set D117 = ( LifeSpan (D115 , D114) );
L583: D2 c= D111 by FUNCT_4:25;
L584: ( C73 ";" C74 ) c= D113 by FUNCT_4:25;
L585: D2 c= ( Initialized R4 ) by FUNCT_4:25;
L586: C73 c= ( R9 +* C73 ) by FUNCT_4:25;
L587: D112 halts_on D111 by L586 , L5 , L585;
L588: D2 c= D114 by FUNCT_4:25;
L589: (( IExec (C73 , R9 , R4) ) = ( Result (D112 , D111) ) & D2 c= ( ( Result (D112 , D111) ) +* D2 )) by FUNCT_4:25 , SCMFSA6B:def 1;
L590: C74 c= ( R9 +* C74 ) by FUNCT_4:25;
L591: (D2 c= ( Initialized ( IExec (C73 , R9 , R4) ) ) & D2 c= D114) by FUNCT_4:25;
L592: (C74 c= ( R9 +* C74 ) & C74 c= D115) by FUNCT_4:25;
L593: D2 c= D114 by FUNCT_4:25;
L594: D2 c= D111 by FUNCT_4:25;
L595: C73 c= D112 by FUNCT_4:25;
L596: D112 halts_on D111 by L594 , L5 , L595;
L597: D114 = ( Initialized ( Result (D112 , D111) ) ) by L596 , EXTPRO_1:23;
L598: ( IC ( Result (( D112 +* C74 ) , ( Initialized ( Result (D112 , D111) ) )) ) ) = ( IC ( Result (( R9 +* C74 ) , ( Initialized ( IExec (C73 , R9 , R4) ) )) ) ) by L589 , L164 , L590 , L582;
L599: D2 c= D111 by FUNCT_4:25;
L600: C73 c= ( D113 +* C73 ) by FUNCT_4:25;
L601: ( LifeSpan (( D113 +* C73 ) , D111) ) = D116 by L599 , L164 , L595 , L600;
L602: ( Reloc (C74 , ( card C73 )) ) c= ( C73 ";" C74 ) by FUNCT_4:25;
L603: ( Reloc (C74 , ( card C73 )) ) c= D113 by L602 , L580 , XBOOLE_1:1;
L604: D2 c= D111 by FUNCT_4:25;
L605: ( ( D113 +* C73 ) +* ( C73 ";" C74 ) ) = ( D113 +* ( C73 +* ( C73 ";" C74 ) ) ) by FUNCT_4:14
.= ( D113 +* ( C73 ";" C74 ) ) by SCMFSA6A:18
.= D113
.= ( R9 +* ( C73 +* ( C73 ";" C74 ) ) ) by SCMFSA6A:18
.= ( D112 +* ( C73 ";" C74 ) ) by FUNCT_4:14;
L606: C73 c= ( D113 +* C73 ) by FUNCT_4:25;
L607: ( D113 +* C73 ) halts_on D111 by L606 , L5 , L604;
L608: ( DataPart ( Comput (( D113 +* C73 ) , D111 , D116) ) ) = ( DataPart ( Comput (( ( D113 +* C73 ) +* ( C73 ";" C74 ) ) , D111 , D116) ) ) by L607 , L599 , L601 , L195 , L600
.= ( DataPart ( Comput (D112 , D111 , D116) ) ) by L594 , L587 , L195 , L579 , L605;
L609: ( DataPart ( ( Comput (( D113 +* C73 ) , D111 , D116) ) +* D2 ) ) = ( ( DataPart ( Comput (D112 , D111 , D116) ) ) +* ( DataPart D2 ) ) by L608 , FUNCT_4:71
.= ( DataPart ( ( Comput (D112 , D111 , D116) ) +* D2 ) ) by FUNCT_4:71;
L610: (( IC ( Comput (D113 , D111 , ( D116 + 1 )) ) ) = ( card C73 ) & ( DataPart ( Comput (D113 , D111 , ( D116 + 1 )) ) ) = ( DataPart ( ( Comput (( D113 +* C73 ) , D111 , D116) ) +* D2 ) )) by L583 , L601 , L353 , L584;
L611: ( DataPart ( Comput (D113 , ( Comput (D113 , D111 , ( D116 + 1 )) ) , D117) ) ) = ( DataPart ( Comput (D115 , D114 , D117) ) ) by L610 , L588 , L609 , L122 , L582 , L603;
L612: ( IC ( Comput (D113 , ( Comput (D113 , D111 , ( D116 + 1 )) ) , D117) ) ) = ( ( IC ( Comput (D115 , D114 , D117) ) ) + ( card C73 ) ) by L610 , L588 , L609 , L122 , L582 , L603;
L613: D2 c= D111 by FUNCT_4:25;
L614: ( C73 ";" C74 ) c= ( R9 +* ( C73 ";" C74 ) ) by FUNCT_4:25;
L615: D113 halts_on D111 by L614 , L5 , L613;
L616: ( IExec (( C73 ";" C74 ) , R9 , R4) ) = ( Result (( R9 +* ( C73 ";" C74 ) ) , ( Initialized R4 )) ) by SCMFSA6B:def 1
.= ( Comput (D113 , D111 , ( LifeSpan (D113 , D111) )) ) by L615 , EXTPRO_1:23
.= ( Comput (D113 , D111 , ( ( D116 + 1 ) + D117 )) ) by L597 , L567;
L617: D112 halts_on D111 by L594 , L5 , L579;
L618: ( IExec (C73 , R9 , R4) ) = ( Result (( R9 +* C73 ) , ( Initialized R4 )) ) by SCMFSA6B:def 1
.= ( Comput (D112 , D111 , D116) ) by L617 , EXTPRO_1:23;
L619: ( Result (( R9 +* C74 ) , ( ( IExec (C73 , R9 , R4) ) +* D2 )) ) = ( Result (D115 , D114) ) by L618 , L591 , L164 , L592;
L620: D115 halts_on D114 by L5 , L581 , L582;
L621: ( IExec (C74 , R9 , ( IExec (C73 , R9 , R4) )) ) = ( Result (( R9 +* C74 ) , ( Initialized ( IExec (C73 , R9 , R4) ) )) ) by SCMFSA6B:def 1
.= ( Comput (D115 , D114 , D117) ) by L619 , L620 , EXTPRO_1:23;
L622: ( DataPart ( IExec (( C73 ";" C74 ) , R9 , R4) ) ) = ( DataPart ( IExec (C74 , R9 , ( IExec (C73 , R9 , R4) )) ) ) by L621 , L611 , L616 , EXTPRO_1:4;
L623: D115 halts_on D114 by L593 , L5 , L582;
L624: D113 halts_on D111 by L583 , L5 , L580;
L625: D112 halts_on D111 by L594 , L5 , L579;
L626: D114 = ( Initialized ( Result (D112 , D111) ) ) by L625 , EXTPRO_1:23;
L627: ( IC ( IExec (( C73 ";" C74 ) , R9 , R4) ) ) = ( IC ( Result (( R9 +* ( C73 ";" C74 ) ) , ( Initialized R4 )) ) ) by SCMFSA6B:def 1
.= ( IC ( Comput (D113 , D111 , ( LifeSpan (D113 , D111) )) ) ) by L624 , EXTPRO_1:23
.= ( IC ( Comput (D113 , D111 , ( ( D116 + 1 ) + D117 )) ) ) by L597 , L567
.= ( ( IC ( Comput (D115 , D114 , D117) ) ) + ( card C73 ) ) by L612 , EXTPRO_1:4
.= ( ( IC ( Result (D115 , D114) ) ) + ( card C73 ) ) by L623 , EXTPRO_1:23
.= ( ( IC ( IExec (C74 , R9 , ( IExec (C73 , R9 , R4) )) ) ) + ( card C73 ) ) by L598 , L626 , SCMFSA6B:def 1;
thus L628:now
reconsider D118 = ( ( IC ( IExec (C74 , R9 , ( IExec (C73 , R9 , R4) )) ) ) + ( card C73 ) ) as (Element of ( NAT ));
L629: ( dom ( Start-At (D118 , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L630:
now
let C75 being set;
assume L631: C75 in ( dom ( IExec (( C73 ";" C74 ) , R9 , R4) ) );
per cases  by L631 , SCMFSA_M:1;
suppose L632: C75 is Int-Location;

L633: C75 <> ( IC ( SCM+FSA ) ) by L632 , SCMFSA_2:56;
L634: (not C75 in ( dom ( Start-At (D118 , ( SCM+FSA )) ) )) by L633 , L629 , TARSKI:def 1;
L635: ( ( IExec (( C73 ";" C74 ) , R9 , R4) ) . C75 ) = ( ( IExec (C74 , R9 , ( IExec (C73 , R9 , R4) )) ) . C75 ) by L622 , L632 , SCMFSA_M:2;
thus L636: ( ( IExec (( C73 ";" C74 ) , R9 , R4) ) . C75 ) = ( ( IncIC (( IExec (C74 , R9 , ( IExec (C73 , R9 , R4) )) ) , ( card C73 )) ) . C75 ) by L635 , L634 , FUNCT_4:11;
end;
suppose L637: C75 is FinSeq-Location;

L638: C75 <> ( IC ( SCM+FSA ) ) by L637 , SCMFSA_2:57;
L639: (not C75 in ( dom ( Start-At (D118 , ( SCM+FSA )) ) )) by L638 , L629 , TARSKI:def 1;
L640: ( ( IExec (( C73 ";" C74 ) , R9 , R4) ) . C75 ) = ( ( IExec (C74 , R9 , ( IExec (C73 , R9 , R4) )) ) . C75 ) by L622 , L637 , SCMFSA_M:2;
thus L641: ( ( IExec (( C73 ";" C74 ) , R9 , R4) ) . C75 ) = ( ( IncIC (( IExec (C74 , R9 , ( IExec (C73 , R9 , R4) )) ) , ( card C73 )) ) . C75 ) by L640 , L639 , FUNCT_4:11;
end;
suppose L642: C75 = ( IC ( SCM+FSA ) );

L643: C75 in { ( IC ( SCM+FSA ) ) } by L642 , TARSKI:def 1;
L644: C75 in ( dom ( Start-At (D118 , ( SCM+FSA )) ) ) by L643 , FUNCOP_1:13;
thus L645: ( ( IExec (( C73 ";" C74 ) , R9 , R4) ) . C75 ) = ( ( Start-At (D118 , ( SCM+FSA )) ) . ( IC ( SCM+FSA ) ) ) by L627 , L642 , FUNCOP_1:72
.= ( ( IncIC (( IExec (C74 , R9 , ( IExec (C73 , R9 , R4) )) ) , ( card C73 )) ) . C75 ) by L642 , L644 , FUNCT_4:13;
end;
end;
L647: ( dom ( IExec (( C73 ";" C74 ) , R9 , R4) ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2
.= ( dom ( IncIC (( IExec (C74 , R9 , ( IExec (C73 , R9 , R4) )) ) , ( card C73 )) ) ) by PARTFUN1:def 2;
thus L648: thesis by L647 , L630 , FUNCT_1:2;
end;
end;
registration
let C76 being  parahalting (Instruction of ( SCM+FSA ));
cluster ( Macro C76 ) ->  InitHalting;
coherence;
end;
registration
let C77 being  parahalting (Instruction of ( SCM+FSA ));
let C78 being  parahalting (Program of ( SCM+FSA ));
cluster ( C77 ";" C78 ) ->  InitHalting;
coherence;
end;
registration
let C79 being  keeping_0  parahalting (Instruction of ( SCM+FSA ));
let C80 being  InitHalting (Program of ( SCM+FSA ));
cluster ( C79 ";" C80 ) ->  InitHalting;
coherence;
end;
registration
let C81 , C82 being  keepInt0_1 (Program of ( SCM+FSA ));
cluster ( C81 ";" C82 ) ->  keepInt0_1;
coherence
proof
let C83 being (State of ( SCM+FSA ));
assume L632: D2 c= C83;
L633: ( Initialized C83 ) = C83 by L632 , FUNCT_4:98;
let R9 being (Instruction-Sequence of ( SCM+FSA ));
assume L634: ( C81 ";" C82 ) c= R9;
L635: ( R9 +* ( C81 ";" C82 ) ) = R9 by L634 , FUNCT_4:98;
L636: C81 c= ( R9 +* C81 ) by FUNCT_4:25;
L637: D2 c= ( Initialized C83 ) by FUNCT_4:25;
per cases ;
suppose L638: ( R9 +* C81 ) halts_on ( Initialized C83 );

let C84 being (Element of ( NAT ));
L639: ( Initialized C83 ) = C83 by L632 , FUNCT_4:98;
per cases ;
suppose L640: C84 <= ( LifeSpan (( R9 +* C81 ) , ( Initialized C83 )) );

L641: ( ( Comput (( R9 +* C81 ) , ( Initialized C83 ) , C84) ) . ( intloc ( 0 ) ) ) = 1 by L6 , L636 , L637;
thus L642: ( ( Comput (R9 , C83 , C84) ) . ( intloc ( 0 ) ) ) = 1 by L641 , L633 , L638 , L640 , L331 , L635;
end;
suppose L643: C84 > ( LifeSpan (( R9 +* C81 ) , ( Initialized C83 )) );

set D119 = ( LifeSpan (( R9 +* C81 ) , ( Initialized C83 )) );
consider C85 being (Element of ( NAT )) such that L644: C84 = ( D119 + C85 ) and L645: 1 <= C85 by L643 , FINSEQ_4:84;
consider C86 being Nat such that L646: C85 = ( 1 + C86 ) by L645 , NAT_1:10;
reconsider D120 = C86 as (Element of ( NAT )) by ORDINAL1:def 12;
set D121 = ( Comput (( ( R9 +* C81 ) +* C82 ) , ( ( Result (( R9 +* C81 ) , C83) ) +* D2 ) , D120) );
set D122 = ( Start-At (( ( IC ( Comput (( ( R9 +* C81 ) +* C82 ) , ( ( Result (( R9 +* C81 ) , C83) ) +* D2 ) , D120) ) ) + ( card C81 ) ) , ( SCM+FSA )) );
L647: D2 c= ( ( Result (( R9 +* C81 ) , C83) ) +* D2 ) by FUNCT_4:25;
L648: C82 c= ( ( R9 +* C81 ) +* C82 ) by FUNCT_4:25;
L649: ( ( Comput (( ( R9 +* C81 ) +* C82 ) , ( ( Result (( R9 +* C81 ) , C83) ) +* D2 ) , D120) ) . ( intloc ( 0 ) ) ) = 1 by L648 , L6 , L647;
L650: (( dom D122 ) = { ( IC ( SCM+FSA ) ) } & ( intloc ( 0 ) ) <> ( IC ( SCM+FSA ) )) by FUNCOP_1:13 , SCMFSA_2:56;
L651: (not ( intloc ( 0 ) ) in ( dom D122 )) by L650 , TARSKI:def 1;
L652: ( D121 +* D122 ) = ( Comput (( R9 +* ( C81 ";" C82 ) ) , C83 , ( ( D119 + 1 ) + D120 )) ) by L632 , L638 , L639 , L484 , L634;
thus L653: thesis by L652 , L644 , L646 , L649 , L651 , L635 , FUNCT_4:11;
end;
end;
suppose L655: (not ( R9 +* C81 ) halts_on ( Initialized C83 ));

let C87 being (Element of ( NAT ));
L656: ( ( Comput (( R9 +* C81 ) , ( Initialized C83 ) , C87) ) . ( intloc ( 0 ) ) ) = 1 by L6 , L636 , L637;
thus L657: thesis by L656 , L633 , L635 , L655 , L547;
end;
end;
end;
registration
let C88 being  keeping_0  parahalting (Instruction of ( SCM+FSA ));
let C89 being  keepInt0_1  InitHalting (Program of ( SCM+FSA ));
cluster ( C89 ";" C88 ) ->  InitHalting  keepInt0_1;
coherence;
end;
registration
let C90 being  keeping_0  parahalting (Instruction of ( SCM+FSA ));
let C91 being  keepInt0_1  InitHalting (Program of ( SCM+FSA ));
cluster ( C90 ";" C91 ) ->  InitHalting  keepInt0_1;
coherence;
end;
registration
let C92 being  parahalting (Instruction of ( SCM+FSA ));
let C93 being  parahalting (Program of ( SCM+FSA ));
cluster ( C93 ";" C92 ) ->  InitHalting;
coherence;
end;
registration
let C94 , C95 being  parahalting (Instruction of ( SCM+FSA ));
cluster ( C94 ";" C95 ) ->  InitHalting;
coherence;
end;
theorem
L664: (for R4 being (State of ( SCM+FSA )) holds (for R7 being Int-Location holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B62 being  keepInt0_1  InitHalting (Program of ( SCM+FSA )) holds (for B63 being  InitHalting (Program of ( SCM+FSA )) holds ( ( IExec (( B62 ";" B63 ) , R9 , R4) ) . R7 ) = ( ( IExec (B63 , R9 , ( IExec (B62 , R9 , R4) )) ) . R7 ))))))
proof
let R4 being (State of ( SCM+FSA ));
let R7 being Int-Location;
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C96 being  keepInt0_1  InitHalting (Program of ( SCM+FSA ));
let C97 being  InitHalting (Program of ( SCM+FSA ));
L665: (( IExec (( C96 ";" C97 ) , R9 , R4) ) = ( IncIC (( IExec (C97 , R9 , ( IExec (C96 , R9 , R4) )) ) , ( card C96 )) ) & (not R7 in ( dom ( Start-At (( ( IC ( IExec (C97 , R9 , ( IExec (C96 , R9 , R4) )) ) ) + ( card C96 ) ) , ( SCM+FSA )) ) ))) by L578 , SCMFSA_2:102;
thus L666: thesis by L665 , FUNCT_4:11;
end;
theorem
L667: (for R4 being (State of ( SCM+FSA )) holds (for R8 being FinSeq-Location holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B64 being  keepInt0_1  InitHalting (Program of ( SCM+FSA )) holds (for B65 being  InitHalting (Program of ( SCM+FSA )) holds ( ( IExec (( B64 ";" B65 ) , R9 , R4) ) . R8 ) = ( ( IExec (B65 , R9 , ( IExec (B64 , R9 , R4) )) ) . R8 ))))))
proof
let R4 being (State of ( SCM+FSA ));
let R8 being FinSeq-Location;
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C98 being  keepInt0_1  InitHalting (Program of ( SCM+FSA ));
let C99 being  InitHalting (Program of ( SCM+FSA ));
L668: (( IExec (( C98 ";" C99 ) , R9 , R4) ) = ( IncIC (( IExec (C99 , R9 , ( IExec (C98 , R9 , R4) )) ) , ( card C98 )) ) & (not R8 in ( dom ( Start-At (( ( IC ( IExec (C99 , R9 , ( IExec (C98 , R9 , R4) )) ) ) + ( card C98 ) ) , ( SCM+FSA )) ) ))) by L578 , SCMFSA_2:103;
thus L669: thesis by L668 , FUNCT_4:11;
end;
theorem
L670: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B66 being  keepInt0_1  InitHalting (Program of ( SCM+FSA )) holds (for B67 being (State of ( SCM+FSA )) holds ( DataPart ( Initialized ( IExec (B66 , R9 , B67) ) ) ) = ( DataPart ( IExec (B66 , R9 , B67) ) ))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
set D123 = ( Data-Locations ( SCM+FSA ) );
let C100 being  keepInt0_1  InitHalting (Program of ( SCM+FSA ));
let C101 being (State of ( SCM+FSA ));
set D124 = ( IExec (C100 , R9 , C101) );
L671:
now
L672: ( dom ( Initialized D124 ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2;
L673: ( dom ( Initialized D124 ) ) = ( ( Data-Locations ( SCM+FSA ) ) \/ { ( IC ( SCM+FSA ) ) } ) by MEMSTR_0:13;
L674: ( dom D124 ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2;
thus L675: ( dom ( DataPart ( Initialized D124 ) ) ) = ( ( dom D124 ) /\ D123 ) by L674 , L672 , RELAT_1:61;
L676: ( dom ( DataPart ( Initialized D124 ) ) ) = ( Data-Locations ( SCM+FSA ) ) by L675 , L672 , L674 , L673 , XBOOLE_1:21;
let C102 being set;
assume L677: C102 in ( dom ( DataPart ( Initialized D124 ) ) );
per cases  by L677 , L676 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L678: C102 in ( Int-Locations );

reconsider D125 = C102 as Int-Location by L678 , AMI_2:def 16;
thus L679:now
per cases ;
suppose L680: D125 is  read-write;

thus L681: ( ( DataPart ( Initialized D124 ) ) . C102 ) = ( ( Initialized D124 ) . C102 ) by L677 , L676 , FUNCT_1:49
.= ( D124 . C102 ) by L680 , SCMFSA_M:37;
end;
suppose L682: D125 is  read-only;

L683: D125 = ( intloc ( 0 ) ) by L682 , SCMFSA_M:def 2;
thus L684: ( ( DataPart ( Initialized D124 ) ) . C102 ) = ( ( Initialized D124 ) . D125 ) by L677 , L676 , FUNCT_1:49
.= 1 by L683 , SCMFSA_M:9
.= ( D124 . C102 ) by L683 , L187;
end;
end;
end;
suppose L680: C102 in ( FinSeq-Locations );

reconsider D126 = C102 as FinSeq-Location by L680 , SCMFSA_2:def 5;
thus L681: ( ( DataPart ( Initialized D124 ) ) . C102 ) = ( ( Initialized D124 ) . D126 ) by L677 , L676 , FUNCT_1:49
.= ( D124 . C102 ) by SCMFSA_M:37;
end;
end;
thus L683: thesis by L671 , FUNCT_1:46;
end;
theorem
L684: (for R4 being (State of ( SCM+FSA )) holds (for R7 being Int-Location holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B68 being  keepInt0_1  InitHalting (Program of ( SCM+FSA )) holds (for B69 being  parahalting (Instruction of ( SCM+FSA )) holds ( ( IExec (( B68 ";" B69 ) , R9 , R4) ) . R7 ) = ( ( Exec (B69 , ( IExec (B68 , R9 , R4) )) ) . R7 ))))))
proof
let R4 being (State of ( SCM+FSA ));
let R7 being Int-Location;
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C103 being  keepInt0_1  InitHalting (Program of ( SCM+FSA ));
let C104 being  parahalting (Instruction of ( SCM+FSA ));
set D127 = ( Macro C104 );
set D128 = ( Start-At (( ( IC ( IExec (D127 , R9 , ( IExec (C103 , R9 , R4) )) ) ) + ( card C103 ) ) , ( SCM+FSA )) );
L685: (not R7 in ( dom D128 )) by SCMFSA_2:102;
L686: ( DataPart ( Initialized ( IExec (C103 , R9 , R4) ) ) ) = ( DataPart ( IExec (C103 , R9 , R4) ) ) by L670;
L687: R7 in ( Int-Locations ) by AMI_2:def 16;
L688: R7 in ( Data-Locations ( SCM+FSA ) ) by L687 , SCMFSA_2:100 , XBOOLE_0:def 3;
thus L689: ( ( IExec (( C103 ";" C104 ) , R9 , R4) ) . R7 ) = ( ( IncIC (( IExec (D127 , R9 , ( IExec (C103 , R9 , R4) )) ) , ( card C103 )) ) . R7 ) by L578
.= ( ( IExec (D127 , R9 , ( IExec (C103 , R9 , R4) )) ) . R7 ) by L685 , FUNCT_4:11
.= ( ( Exec (C104 , ( Initialized ( IExec (C103 , R9 , R4) ) )) ) . R7 ) by SCMFSA6C:5
.= ( ( DataPart ( Exec (C104 , ( Initialized ( IExec (C103 , R9 , R4) ) )) ) ) . R7 ) by L688 , FUNCT_1:49
.= ( ( DataPart ( Exec (C104 , ( IExec (C103 , R9 , R4) )) ) ) . R7 ) by L686 , SCMFSA6C:4
.= ( ( Exec (C104 , ( IExec (C103 , R9 , R4) )) ) . R7 ) by L688 , FUNCT_1:49;
end;
theorem
L690: (for R4 being (State of ( SCM+FSA )) holds (for R8 being FinSeq-Location holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B70 being  keepInt0_1  InitHalting (Program of ( SCM+FSA )) holds (for B71 being  parahalting (Instruction of ( SCM+FSA )) holds ( ( IExec (( B70 ";" B71 ) , R9 , R4) ) . R8 ) = ( ( Exec (B71 , ( IExec (B70 , R9 , R4) )) ) . R8 ))))))
proof
let R4 being (State of ( SCM+FSA ));
let R8 being FinSeq-Location;
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C105 being  keepInt0_1  InitHalting (Program of ( SCM+FSA ));
let C106 being  parahalting (Instruction of ( SCM+FSA ));
set D129 = ( Macro C106 );
set D130 = ( Start-At (( ( IC ( IExec (D129 , R9 , ( IExec (C105 , R9 , R4) )) ) ) + ( card C105 ) ) , ( SCM+FSA )) );
L691: (not R8 in ( dom D130 )) by SCMFSA_2:103;
L692: ( DataPart ( Initialized ( IExec (C105 , R9 , R4) ) ) ) = ( DataPart ( IExec (C105 , R9 , R4) ) ) by L670;
L693: R8 in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L694: R8 in ( Data-Locations ( SCM+FSA ) ) by L693 , SCMFSA_2:100 , XBOOLE_0:def 3;
thus L695: ( ( IExec (( C105 ";" C106 ) , R9 , R4) ) . R8 ) = ( ( IncIC (( IExec (D129 , R9 , ( IExec (C105 , R9 , R4) )) ) , ( card C105 )) ) . R8 ) by L578
.= ( ( IExec (D129 , R9 , ( IExec (C105 , R9 , R4) )) ) . R8 ) by L691 , FUNCT_4:11
.= ( ( Exec (C106 , ( Initialized ( IExec (C105 , R9 , R4) ) )) ) . R8 ) by SCMFSA6C:5
.= ( ( DataPart ( Exec (C106 , ( Initialized ( IExec (C105 , R9 , R4) ) )) ) ) . R8 ) by L694 , FUNCT_1:49
.= ( ( DataPart ( Exec (C106 , ( IExec (C105 , R9 , R4) )) ) ) . R8 ) by L692 , SCMFSA6C:4
.= ( ( Exec (C106 , ( IExec (C105 , R9 , R4) )) ) . R8 ) by L694 , FUNCT_1:49;
end;
definition
let C107 being (Program of ( SCM+FSA ));
let C108 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
pred C107 is_closed_onInit C108 , R9
means
:L696: (for B72 being (Element of ( NAT )) holds ( IC ( Comput (( R9 +* C107 ) , ( Initialized C108 ) , B72) ) ) in ( dom C107 ))
;pred C107 is_halting_onInit C108 , R9
means
:L697: ( R9 +* C107 ) halts_on ( Initialized C108 )
;end;
theorem
L699: (for B73 being (Program of ( SCM+FSA )) holds (B73 is  InitClosed iff (for B74 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds B73 is_closed_onInit B74 , R9))))
proof
let C109 being (Program of ( SCM+FSA ));
thus L700:now
assume L701: C109 is  InitClosed;
let C110 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
L702: C109 c= ( R9 +* C109 ) by FUNCT_4:25;
L703: D2 c= ( Initialized C110 ) by FUNCT_4:25;
L704: (for B75 being (Element of ( NAT )) holds ( IC ( Comput (( R9 +* C109 ) , ( Initialized C110 ) , B75) ) ) in ( dom C109 )) by L701 , L4 , L702 , L703;
thus L705: C109 is_closed_onInit C110 , R9 by L704 , L696;
end;
assume L706: (for B76 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds C109 is_closed_onInit B76 , R9));
L707:
now
let C111 being (State of ( SCM+FSA ));
let C112 being (Instruction-Sequence of ( SCM+FSA ));
assume L708: C109 c= C112;
L709: ( C112 +* C109 ) = C112 by L708 , FUNCT_4:98;
let C113 being (Element of ( NAT ));
assume L710: D2 c= C111;
L711: C111 = ( Initialized C111 ) by L710 , FUNCT_4:98;
L712: C109 is_closed_onInit C111 , C112 by L706;
thus L713: ( IC ( Comput (C112 , C111 , C113) ) ) in ( dom C109 ) by L712 , L711 , L696 , L709;
end;
thus L714: thesis by L707 , L4;
end;
theorem
L715: (for B77 being (Program of ( SCM+FSA )) holds (B77 is  InitHalting iff (for B78 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds B77 is_halting_onInit B78 , R9))))
proof
let C114 being (Program of ( SCM+FSA ));
thus L716:now
assume L717: C114 is  InitHalting;
let C115 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
L718: C114 c= ( R9 +* C114 ) by FUNCT_4:25;
L719: D2 c= ( Initialized C115 ) by FUNCT_4:25;
L720: ( R9 +* C114 ) halts_on ( Initialized C115 ) by L719 , L718 , L5 , L717;
thus L721: C114 is_halting_onInit C115 , R9 by L720 , L697;
end;
assume L722: (for B79 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds C114 is_halting_onInit B79 , R9));
L723:
now
let C116 being (State of ( SCM+FSA ));
assume L724: D2 c= C116;
L725: C116 = ( Initialized C116 ) by L724 , FUNCT_4:98;
let R9 being (Instruction-Sequence of ( SCM+FSA ));
assume L726: C114 c= R9;
L727: ( R9 +* C114 ) = R9 by L726 , FUNCT_4:98;
L728: C114 is_halting_onInit C116 , R9 by L722;
thus L729: R9 halts_on C116 by L728 , L725 , L697 , L727;
end;
thus L730: thesis by L723 , L5;
end;
theorem
L731: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B80 being (State of ( SCM+FSA )) holds (for B81 being (Program of ( SCM+FSA )) holds (for B82 being Int-Location holds (((not B81 destroy B82) & B81 is_closed_onInit B80 , R9 & ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= B80 & B81 c= R9) implies (for B83 being (Element of ( NAT )) holds ( ( Comput (R9 , B80 , B83) ) . B82 ) = ( B80 . B82 )))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C117 being (State of ( SCM+FSA ));
let C118 being (Program of ( SCM+FSA ));
let C119 being Int-Location;
assume L732: (not C118 destroy C119);
defpred S11[ Nat ] means ( ( Comput (R9 , C117 , $1) ) . C119 ) = ( C117 . C119 );
assume L733: C118 is_closed_onInit C117 , R9;
assume L734: D2 c= C117;
L735: ( Initialized C117 ) = C117 by L734 , FUNCT_4:98;
assume L736: C118 c= R9;
L737: ( R9 +* C118 ) = R9 by L736 , FUNCT_4:98;
L738:
now
let C120 being (Element of ( NAT ));
assume L739: S11[ C120 ];
set D131 = ( IC ( Comput (R9 , C117 , C120) ) );
L740: D131 in ( dom C118 ) by L733 , L735 , L696 , L737;
L741: ( R9 . D131 ) = ( C118 . D131 ) by L740 , L736 , GRFUNC_1:2;
L742: ( R9 . D131 ) in ( rng C118 ) by L741 , L740 , FUNCT_1:def 3;
L743: (not ( R9 . D131 ) destroy C119) by L742 , L732 , SCMFSA7B:def 4;
L744: ( ( Comput (R9 , C117 , ( C120 + 1 )) ) . C119 ) = ( ( Following (R9 , ( Comput (R9 , C117 , C120) )) ) . C119 ) by EXTPRO_1:3
.= ( ( Exec (( R9 . D131 ) , ( Comput (R9 , C117 , C120) )) ) . C119 ) by PBOOLE:143
.= ( C117 . C119 ) by L739 , L743 , SCMFSA7B:20;
thus L745: S11[ ( C120 + 1 ) ] by L744;
end;
L746: S11[ ( 0 ) ];
thus L747: (for B84 being (Element of ( NAT )) holds S11[ B84 ]) from NAT_1:sch 1(L746 , L738);
end;
registration
cluster  InitHalting  good for (Program of ( SCM+FSA ));
existence
proof
take ( Stop ( SCM+FSA ) );
thus L748: thesis;
end;
end;
registration
cluster  InitClosed  good ->  keepInt0_1 for (Program of ( SCM+FSA ));
correctness
proof
let C121 being (Program of ( SCM+FSA ));
assume L750: C121 is  InitClosed  good;
L751: (not C121 destroy ( intloc ( 0 ) )) by L750 , SCMFSA7B:def 5;
L752:
now
let C122 being (State of ( SCM+FSA ));
assume L753: D2 c= C122;
let R9 being (Instruction-Sequence of ( SCM+FSA ));
assume L754: C121 c= R9;
let C123 being (Element of ( NAT ));
L755: C121 is_closed_onInit C122 , R9 by L750 , L699;
thus L756: ( ( Comput (R9 , C122 , C123) ) . ( intloc ( 0 ) ) ) = ( C122 . ( intloc ( 0 ) ) ) by L755 , L751 , L753 , L731 , L754
.= 1 by L753 , SCMFSA_M:30;
end;
thus L757: thesis by L752 , L6;
end;
end;
registration
cluster ( Stop ( SCM+FSA ) ) ->  InitHalting  good;
coherence;
end;
theorem
L760: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B85 being (State of ( SCM+FSA )) holds (for B86 being  keeping_0  parahalting (Instruction of ( SCM+FSA )) holds (for B87 being  InitHalting (Program of ( SCM+FSA )) holds (for B88 being Int-Location holds ( ( IExec (( B86 ";" B87 ) , R9 , B85) ) . B88 ) = ( ( IExec (B87 , R9 , ( Exec (B86 , ( Initialized B85 )) )) ) . B88 ))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C124 being (State of ( SCM+FSA ));
let C125 being  keeping_0  parahalting (Instruction of ( SCM+FSA ));
let C126 being  InitHalting (Program of ( SCM+FSA ));
let C127 being Int-Location;
thus L761: ( ( IExec (( C125 ";" C126 ) , R9 , C124) ) . C127 ) = ( ( IExec (C126 , R9 , ( IExec (( Macro C125 ) , R9 , C124) )) ) . C127 ) by L664
.= ( ( IExec (C126 , R9 , ( Exec (C125 , ( Initialized C124 )) )) ) . C127 ) by SCMFSA6C:5;
end;
theorem
L762: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B89 being (State of ( SCM+FSA )) holds (for B90 being  keeping_0  parahalting (Instruction of ( SCM+FSA )) holds (for B91 being  InitHalting (Program of ( SCM+FSA )) holds (for B92 being FinSeq-Location holds ( ( IExec (( B90 ";" B91 ) , R9 , B89) ) . B92 ) = ( ( IExec (B91 , R9 , ( Exec (B90 , ( Initialized B89 )) )) ) . B92 ))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C128 being (State of ( SCM+FSA ));
let C129 being  keeping_0  parahalting (Instruction of ( SCM+FSA ));
let C130 being  InitHalting (Program of ( SCM+FSA ));
let C131 being FinSeq-Location;
thus L763: ( ( IExec (( C129 ";" C130 ) , R9 , C128) ) . C131 ) = ( ( IExec (C130 , R9 , ( IExec (( Macro C129 ) , R9 , C128) )) ) . C131 ) by L667
.= ( ( IExec (C130 , R9 , ( Exec (C129 , ( Initialized C128 )) )) ) . C131 ) by SCMFSA6C:5;
end;
theorem
L764: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B93 being (State of ( SCM+FSA )) holds (for B94 being (Program of ( SCM+FSA )) holds (B94 is_closed_onInit B93 , R9 iff B94 is_closed_on ( Initialized B93 ) , R9))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C132 being (State of ( SCM+FSA ));
let C133 being (Program of ( SCM+FSA ));
L765: ( Initialized C132 ) = ( C132 +* ( Initialize D2 ) )
.= ( Initialize ( Initialized C132 ) ) by FUNCT_4:14;
thus L766:now
assume L767: C133 is_closed_onInit C132 , R9;
thus L768: C133 is_closed_on ( Initialized C132 ) , R9
proof
let C134 being (Element of ( NAT ));
thus L769: ( IC ( Comput (( R9 +* C133 ) , ( Initialize ( Initialized C132 ) ) , C134) ) ) in ( dom C133 ) by L765 , L767 , L696;
end;

end;
assume L769: C133 is_closed_on ( Initialized C132 ) , R9;
let C135 being (Element of ( NAT ));
thus L770: ( IC ( Comput (( R9 +* C133 ) , ( Initialized C132 ) , C135) ) ) in ( dom C133 ) by L765 , L769 , SCMFSA7B:def 6;
end;
theorem
L771: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B95 being (State of ( SCM+FSA )) holds (for B96 being (Program of ( SCM+FSA )) holds (B96 is_halting_onInit B95 , R9 iff B96 is_halting_on ( Initialized B95 ) , R9))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C136 being (State of ( SCM+FSA ));
let C137 being (Program of ( SCM+FSA ));
set D132 = ( Initialized C136 );
set D133 = ( R9 +* C137 );
L772: ( Initialized C136 ) = ( Initialize ( Initialized C136 ) ) by MEMSTR_0:44;
L773: (C137 is_halting_onInit C136 , R9 iff D133 halts_on D132) by L697;
thus L774: thesis by L773 , L772 , SCMFSA7B:def 7;
end;
theorem
L775: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B97 being (Program of ( SCM+FSA )) holds (for B98 being (State of ( SCM+FSA )) holds ( IExec (B97 , R9 , B98) ) = ( IExec (B97 , R9 , ( Initialized B98 )) ))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C138 being (Program of ( SCM+FSA ));
let C139 being (State of ( SCM+FSA ));
set D134 = ( C139 | ( NAT ) );
thus L776: ( IExec (C138 , R9 , C139) ) = ( Result (( R9 +* C138 ) , ( Initialized ( Initialized C139 ) )) ) by SCMFSA6B:def 1
.= ( IExec (C138 , R9 , ( Initialized C139 )) ) by SCMFSA6B:def 1;
end;
theorem
L777: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B99 being (State of ( SCM+FSA )) holds (for B100 , B101 being (Program of ( SCM+FSA )) holds (for B102 being  read-write Int-Location holds ((( B99 . B102 ) = ( 0 ) & B100 is_closed_onInit B99 , R9 & B100 is_halting_onInit B99 , R9) implies (( if=0 (B102 , B100 , B101) ) is_closed_onInit B99 , R9 & ( if=0 (B102 , B100 , B101) ) is_halting_onInit B99 , R9))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C140 being (State of ( SCM+FSA ));
let C141 , C142 being (Program of ( SCM+FSA ));
let C143 being  read-write Int-Location;
set D135 = ( Initialized C140 );
assume L778: ( C140 . C143 ) = ( 0 );
L779: ( D135 . C143 ) = ( 0 ) by L778 , SCMFSA_M:37;
assume L780: C141 is_closed_onInit C140 , R9;
L781: C141 is_closed_on D135 , R9 by L780 , L764;
assume L782: C141 is_halting_onInit C140 , R9;
L783: C141 is_halting_on D135 , R9 by L782 , L771;
L784: (( if=0 (C143 , C141 , C142) ) is_closed_on D135 , R9 & ( if=0 (C143 , C141 , C142) ) is_halting_on D135 , R9) by L783 , L779 , L781 , SCMFSA8B:13;
thus L785: thesis by L784 , L764 , L771;
end;
theorem
L786: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B103 being (State of ( SCM+FSA )) holds (for B104 , B105 being (Program of ( SCM+FSA )) holds (for B106 being  read-write Int-Location holds ((( B103 . B106 ) = ( 0 ) & B104 is_closed_onInit B103 , R9 & B104 is_halting_onInit B103 , R9) implies ( IExec (( if=0 (B106 , B104 , B105) ) , R9 , B103) ) = ( ( IExec (B104 , R9 , B103) ) +* ( Start-At (( ( ( card B104 ) + ( card B105 ) ) + 3 ) , ( SCM+FSA )) ) ))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C144 being (State of ( SCM+FSA ));
let C145 , C146 being (Program of ( SCM+FSA ));
let C147 being  read-write Int-Location;
assume L787: ( C144 . C147 ) = ( 0 );
set D136 = ( Initialized C144 );
assume L788: C145 is_closed_onInit C144 , R9;
L789: C145 is_closed_on D136 , R9 by L788 , L764;
assume L790: C145 is_halting_onInit C144 , R9;
L791: C145 is_halting_on D136 , R9 by L790 , L771;
thus L792: thesis by L791 , L787 , L789 , SCMFSA8B:14;
end;
theorem
L793: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B107 being (State of ( SCM+FSA )) holds (for B108 , B109 being (Program of ( SCM+FSA )) holds (for B110 being  read-write Int-Location holds ((( B107 . B110 ) <> ( 0 ) & B109 is_closed_onInit B107 , R9 & B109 is_halting_onInit B107 , R9) implies (( if=0 (B110 , B108 , B109) ) is_closed_onInit B107 , R9 & ( if=0 (B110 , B108 , B109) ) is_halting_onInit B107 , R9))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C148 being (State of ( SCM+FSA ));
let C149 , C150 being (Program of ( SCM+FSA ));
let C151 being  read-write Int-Location;
set D137 = ( Initialized C148 );
assume L794: ( C148 . C151 ) <> ( 0 );
L795: ( D137 . C151 ) <> ( 0 ) by L794 , SCMFSA_M:37;
assume L796: C150 is_closed_onInit C148 , R9;
L797: C150 is_closed_on D137 , R9 by L796 , L764;
assume L798: C150 is_halting_onInit C148 , R9;
L799: C150 is_halting_on D137 , R9 by L798 , L771;
L800: (( if=0 (C151 , C149 , C150) ) is_closed_on D137 , R9 & ( if=0 (C151 , C149 , C150) ) is_halting_on D137 , R9) by L799 , L795 , L797 , SCMFSA8B:15;
thus L801: thesis by L800 , L764 , L771;
end;
theorem
L802: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B111 , B112 being (Program of ( SCM+FSA )) holds (for B113 being  read-write Int-Location holds (for B114 being (State of ( SCM+FSA )) holds ((( B114 . B113 ) <> ( 0 ) & B112 is_closed_onInit B114 , R9 & B112 is_halting_onInit B114 , R9) implies ( IExec (( if=0 (B113 , B111 , B112) ) , R9 , B114) ) = ( ( IExec (B112 , R9 , B114) ) +* ( Start-At (( ( ( card B111 ) + ( card B112 ) ) + 3 ) , ( SCM+FSA )) ) ))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C152 , C153 being (Program of ( SCM+FSA ));
let C154 being  read-write Int-Location;
let C155 being (State of ( SCM+FSA ));
assume L803: ( C155 . C154 ) <> ( 0 );
set D138 = ( Initialized C155 );
assume L804: C153 is_closed_onInit C155 , R9;
L805: C153 is_closed_on D138 , R9 by L804 , L764;
assume L806: C153 is_halting_onInit C155 , R9;
L807: C153 is_halting_on D138 , R9 by L806 , L771;
thus L808: thesis by L807 , L803 , L805 , SCMFSA8B:16;
end;
theorem
L809: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B115 being (State of ( SCM+FSA )) holds (for B116 , B117 being  InitHalting (Program of ( SCM+FSA )) holds (for B118 being  read-write Int-Location holds (( if=0 (B118 , B116 , B117) ) is  InitHalting & (( B115 . B118 ) = ( 0 ) implies ( IExec (( if=0 (B118 , B116 , B117) ) , R9 , B115) ) = ( ( IExec (B116 , R9 , B115) ) +* ( Start-At (( ( ( card B116 ) + ( card B117 ) ) + 3 ) , ( SCM+FSA )) ) )) & (( B115 . B118 ) <> ( 0 ) implies ( IExec (( if=0 (B118 , B116 , B117) ) , R9 , B115) ) = ( ( IExec (B117 , R9 , B115) ) +* ( Start-At (( ( ( card B116 ) + ( card B117 ) ) + 3 ) , ( SCM+FSA )) ) )))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C156 being (State of ( SCM+FSA ));
let C157 , C158 being  InitHalting (Program of ( SCM+FSA ));
let C159 being  read-write Int-Location;
L810:
now
let C160 being (State of ( SCM+FSA ));
assume L811: D2 c= C160;
L812: C160 = ( Initialized C160 ) by L811 , FUNCT_4:98;
let R9 being (Instruction-Sequence of ( SCM+FSA ));
assume L813: ( if=0 (C159 , C157 , C158) ) c= R9;
L814: R9 = ( R9 +* ( if=0 (C159 , C157 , C158) ) ) by L813 , FUNCT_4:98;
L815: (C158 is_closed_onInit C160 , R9 & C158 is_halting_onInit C160 , R9) by L699 , L715;
L816: (C157 is_closed_onInit C160 , R9 & C157 is_halting_onInit C160 , R9) by L699 , L715;
per cases ;
suppose L817: ( C160 . C159 ) = ( 0 );

L818: ( if=0 (C159 , C157 , C158) ) is_halting_onInit C160 , R9 by L817 , L816 , L777;
thus L819: R9 halts_on C160 by L818 , L812 , L697 , L814;
end;
suppose L820: ( C160 . C159 ) <> ( 0 );

L821: ( if=0 (C159 , C157 , C158) ) is_halting_onInit C160 , R9 by L820 , L815 , L793;
thus L822: R9 halts_on C160 by L821 , L812 , L697 , L814;
end;
end;
thus L824: ( if=0 (C159 , C157 , C158) ) is  InitHalting by L810 , L5;
L825: (C157 is_closed_onInit C156 , R9 & C157 is_halting_onInit C156 , R9) by L699 , L715;
thus L826: (( C156 . C159 ) = ( 0 ) implies ( IExec (( if=0 (C159 , C157 , C158) ) , R9 , C156) ) = ( ( IExec (C157 , R9 , C156) ) +* ( Start-At (( ( ( card C157 ) + ( card C158 ) ) + 3 ) , ( SCM+FSA )) ) )) by L825 , L786;
L827: (C158 is_closed_onInit C156 , R9 & C158 is_halting_onInit C156 , R9) by L699 , L715;
thus L828: thesis by L827 , L802;
end;
theorem
L829: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B119 being (State of ( SCM+FSA )) holds (for B120 , B121 being  InitHalting (Program of ( SCM+FSA )) holds (for B122 being  read-write Int-Location holds (( IC ( IExec (( if=0 (B122 , B120 , B121) ) , R9 , B119) ) ) = ( ( ( card B120 ) + ( card B121 ) ) + 3 ) & (( B119 . B122 ) = ( 0 ) implies ((for B123 being Int-Location holds ( ( IExec (( if=0 (B122 , B120 , B121) ) , R9 , B119) ) . B123 ) = ( ( IExec (B120 , R9 , B119) ) . B123 )) & (for B124 being FinSeq-Location holds ( ( IExec (( if=0 (B122 , B120 , B121) ) , R9 , B119) ) . B124 ) = ( ( IExec (B120 , R9 , B119) ) . B124 )))) & (( B119 . B122 ) <> ( 0 ) implies ((for B125 being Int-Location holds ( ( IExec (( if=0 (B122 , B120 , B121) ) , R9 , B119) ) . B125 ) = ( ( IExec (B121 , R9 , B119) ) . B125 )) & (for B126 being FinSeq-Location holds ( ( IExec (( if=0 (B122 , B120 , B121) ) , R9 , B119) ) . B126 ) = ( ( IExec (B121 , R9 , B119) ) . B126 )))))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C161 being (State of ( SCM+FSA ));
let C162 , C163 being  InitHalting (Program of ( SCM+FSA ));
let C164 being  read-write Int-Location;
thus L830:now
per cases ;
suppose L831: ( C161 . C164 ) = ( 0 );

L832: ( IExec (( if=0 (C164 , C162 , C163) ) , R9 , C161) ) = ( ( IExec (C162 , R9 , C161) ) +* ( Start-At (( ( ( card C162 ) + ( card C163 ) ) + 3 ) , ( SCM+FSA )) ) ) by L831 , L809;
thus L833: ( IC ( IExec (( if=0 (C164 , C162 , C163) ) , R9 , C161) ) ) = ( ( ( card C162 ) + ( card C163 ) ) + 3 ) by L832 , FUNCT_4:113;
end;
suppose L834: ( C161 . C164 ) <> ( 0 );

L835: ( IExec (( if=0 (C164 , C162 , C163) ) , R9 , C161) ) = ( ( IExec (C163 , R9 , C161) ) +* ( Start-At (( ( ( card C162 ) + ( card C163 ) ) + 3 ) , ( SCM+FSA )) ) ) by L834 , L809;
thus L836: ( IC ( IExec (( if=0 (C164 , C162 , C163) ) , R9 , C161) ) ) = ( ( ( card C162 ) + ( card C163 ) ) + 3 ) by L835 , FUNCT_4:113;
end;
end;
thus L838:now
assume L839: ( C161 . C164 ) = ( 0 );
L840: ( IExec (( if=0 (C164 , C162 , C163) ) , R9 , C161) ) = ( ( IExec (C162 , R9 , C161) ) +* ( Start-At (( ( ( card C162 ) + ( card C163 ) ) + 3 ) , ( SCM+FSA )) ) ) by L839 , L809;
thus L841:now
let C165 being Int-Location;
L842: (not C165 in ( dom ( Start-At (( ( ( card C162 ) + ( card C163 ) ) + 3 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
thus L843: ( ( IExec (( if=0 (C164 , C162 , C163) ) , R9 , C161) ) . C165 ) = ( ( IExec (C162 , R9 , C161) ) . C165 ) by L842 , L840 , FUNCT_4:11;
end;
let C166 being FinSeq-Location;
L844: (not C166 in ( dom ( Start-At (( ( ( card C162 ) + ( card C163 ) ) + 3 ) , ( SCM+FSA )) ) )) by SCMFSA_2:103;
thus L845: ( ( IExec (( if=0 (C164 , C162 , C163) ) , R9 , C161) ) . C166 ) = ( ( IExec (C162 , R9 , C161) ) . C166 ) by L844 , L840 , FUNCT_4:11;
end;
assume L846: ( C161 . C164 ) <> ( 0 );
L847: ( IExec (( if=0 (C164 , C162 , C163) ) , R9 , C161) ) = ( ( IExec (C163 , R9 , C161) ) +* ( Start-At (( ( ( card C162 ) + ( card C163 ) ) + 3 ) , ( SCM+FSA )) ) ) by L846 , L809;
thus L848:now
let C167 being Int-Location;
L849: (not C167 in ( dom ( Start-At (( ( ( card C162 ) + ( card C163 ) ) + 3 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
thus L850: ( ( IExec (( if=0 (C164 , C162 , C163) ) , R9 , C161) ) . C167 ) = ( ( IExec (C163 , R9 , C161) ) . C167 ) by L849 , L847 , FUNCT_4:11;
end;
let C168 being FinSeq-Location;
L851: (not C168 in ( dom ( Start-At (( ( ( card C162 ) + ( card C163 ) ) + 3 ) , ( SCM+FSA )) ) )) by SCMFSA_2:103;
thus L852: thesis by L851 , L847 , FUNCT_4:11;
end;
theorem
L853: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B127 being (State of ( SCM+FSA )) holds (for B128 , B129 being (Program of ( SCM+FSA )) holds (for B130 being  read-write Int-Location holds ((( B127 . B130 ) > ( 0 ) & B128 is_closed_onInit B127 , R9 & B128 is_halting_onInit B127 , R9) implies (( if>0 (B130 , B128 , B129) ) is_closed_onInit B127 , R9 & ( if>0 (B130 , B128 , B129) ) is_halting_onInit B127 , R9))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C169 being (State of ( SCM+FSA ));
let C170 , C171 being (Program of ( SCM+FSA ));
let C172 being  read-write Int-Location;
set D139 = ( Initialized C169 );
assume L854: ( C169 . C172 ) > ( 0 );
L855: ( D139 . C172 ) > ( 0 ) by L854 , SCMFSA_M:37;
assume L856: C170 is_closed_onInit C169 , R9;
L857: C170 is_closed_on D139 , R9 by L856 , L764;
assume L858: C170 is_halting_onInit C169 , R9;
L859: C170 is_halting_on D139 , R9 by L858 , L771;
L860: (( if>0 (C172 , C170 , C171) ) is_closed_on D139 , R9 & ( if>0 (C172 , C170 , C171) ) is_halting_on D139 , R9) by L859 , L855 , L857 , SCMFSA8B:19;
thus L861: thesis by L860 , L764 , L771;
end;
theorem
L862: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B131 being (State of ( SCM+FSA )) holds (for B132 , B133 being (Program of ( SCM+FSA )) holds (for B134 being  read-write Int-Location holds ((( B131 . B134 ) > ( 0 ) & B132 is_closed_onInit B131 , R9 & B132 is_halting_onInit B131 , R9) implies ( IExec (( if>0 (B134 , B132 , B133) ) , R9 , B131) ) = ( ( IExec (B132 , R9 , B131) ) +* ( Start-At (( ( ( card B132 ) + ( card B133 ) ) + 3 ) , ( SCM+FSA )) ) ))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C173 being (State of ( SCM+FSA ));
let C174 , C175 being (Program of ( SCM+FSA ));
let C176 being  read-write Int-Location;
assume L863: ( C173 . C176 ) > ( 0 );
set D140 = ( Initialized C173 );
assume L864: C174 is_closed_onInit C173 , R9;
L865: C174 is_closed_on D140 , R9 by L864 , L764;
assume L866: C174 is_halting_onInit C173 , R9;
L867: C174 is_halting_on D140 , R9 by L866 , L771;
thus L868: thesis by L867 , L863 , L865 , SCMFSA8B:20;
end;
theorem
L869: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B135 being (State of ( SCM+FSA )) holds (for B136 , B137 being (Program of ( SCM+FSA )) holds (for B138 being  read-write Int-Location holds ((( B135 . B138 ) <= ( 0 ) & B137 is_closed_onInit B135 , R9 & B137 is_halting_onInit B135 , R9) implies (( if>0 (B138 , B136 , B137) ) is_closed_onInit B135 , R9 & ( if>0 (B138 , B136 , B137) ) is_halting_onInit B135 , R9))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C177 being (State of ( SCM+FSA ));
let C178 , C179 being (Program of ( SCM+FSA ));
let C180 being  read-write Int-Location;
set D141 = ( Initialized C177 );
assume L870: ( C177 . C180 ) <= ( 0 );
L871: ( D141 . C180 ) <= ( 0 ) by L870 , SCMFSA_M:37;
assume L872: C179 is_closed_onInit C177 , R9;
L873: C179 is_closed_on D141 , R9 by L872 , L764;
assume L874: C179 is_halting_onInit C177 , R9;
L875: C179 is_halting_on D141 , R9 by L874 , L771;
L876: (( if>0 (C180 , C178 , C179) ) is_closed_on D141 , R9 & ( if>0 (C180 , C178 , C179) ) is_halting_on D141 , R9) by L875 , L871 , L873 , SCMFSA8B:21;
thus L877: thesis by L876 , L764 , L771;
end;
theorem
L878: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B139 , B140 being (Program of ( SCM+FSA )) holds (for B141 being  read-write Int-Location holds (for B142 being (State of ( SCM+FSA )) holds ((( B142 . B141 ) <= ( 0 ) & B140 is_closed_onInit B142 , R9 & B140 is_halting_onInit B142 , R9) implies ( IExec (( if>0 (B141 , B139 , B140) ) , R9 , B142) ) = ( ( IExec (B140 , R9 , B142) ) +* ( Start-At (( ( ( card B139 ) + ( card B140 ) ) + 3 ) , ( SCM+FSA )) ) ))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C181 , C182 being (Program of ( SCM+FSA ));
let C183 being  read-write Int-Location;
let C184 being (State of ( SCM+FSA ));
assume L879: ( C184 . C183 ) <= ( 0 );
set D142 = ( Initialized C184 );
assume L880: C182 is_closed_onInit C184 , R9;
L881: C182 is_closed_on D142 , R9 by L880 , L764;
assume L882: C182 is_halting_onInit C184 , R9;
L883: C182 is_halting_on D142 , R9 by L882 , L771;
thus L884: thesis by L883 , L879 , L881 , SCMFSA8B:22;
end;
theorem
L885: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B143 being (State of ( SCM+FSA )) holds (for B144 , B145 being  InitHalting (Program of ( SCM+FSA )) holds (for B146 being  read-write Int-Location holds (( if>0 (B146 , B144 , B145) ) is  InitHalting & (( B143 . B146 ) > ( 0 ) implies ( IExec (( if>0 (B146 , B144 , B145) ) , R9 , B143) ) = ( ( IExec (B144 , R9 , B143) ) +* ( Start-At (( ( ( card B144 ) + ( card B145 ) ) + 3 ) , ( SCM+FSA )) ) )) & (( B143 . B146 ) <= ( 0 ) implies ( IExec (( if>0 (B146 , B144 , B145) ) , R9 , B143) ) = ( ( IExec (B145 , R9 , B143) ) +* ( Start-At (( ( ( card B144 ) + ( card B145 ) ) + 3 ) , ( SCM+FSA )) ) )))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C185 being (State of ( SCM+FSA ));
let C186 , C187 being  InitHalting (Program of ( SCM+FSA ));
let C188 being  read-write Int-Location;
L886:
now
let C189 being (State of ( SCM+FSA ));
assume L887: D2 c= C189;
L888: C189 = ( Initialized C189 ) by L887 , FUNCT_4:98;
let R9 being (Instruction-Sequence of ( SCM+FSA ));
assume L889: ( if>0 (C188 , C186 , C187) ) c= R9;
L890: R9 = ( R9 +* ( if>0 (C188 , C186 , C187) ) ) by L889 , FUNCT_4:98;
L891: (C187 is_closed_onInit C189 , R9 & C187 is_halting_onInit C189 , R9) by L699 , L715;
L892: (C186 is_closed_onInit C189 , R9 & C186 is_halting_onInit C189 , R9) by L699 , L715;
per cases ;
suppose L893: ( C189 . C188 ) > ( 0 );

L894: ( if>0 (C188 , C186 , C187) ) is_halting_onInit C189 , R9 by L893 , L892 , L853;
thus L895: R9 halts_on C189 by L894 , L888 , L697 , L890;
end;
suppose L896: ( C189 . C188 ) <= ( 0 );

L897: ( if>0 (C188 , C186 , C187) ) is_halting_onInit C189 , R9 by L896 , L891 , L869;
thus L898: R9 halts_on C189 by L897 , L888 , L697 , L890;
end;
end;
thus L900: ( if>0 (C188 , C186 , C187) ) is  InitHalting by L886 , L5;
L901: (C186 is_closed_onInit C185 , R9 & C186 is_halting_onInit C185 , R9) by L699 , L715;
thus L902: (( C185 . C188 ) > ( 0 ) implies ( IExec (( if>0 (C188 , C186 , C187) ) , R9 , C185) ) = ( ( IExec (C186 , R9 , C185) ) +* ( Start-At (( ( ( card C186 ) + ( card C187 ) ) + 3 ) , ( SCM+FSA )) ) )) by L901 , L862;
L903: (C187 is_closed_onInit C185 , R9 & C187 is_halting_onInit C185 , R9) by L699 , L715;
thus L904: thesis by L903 , L878;
end;
theorem
L905: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B147 being (State of ( SCM+FSA )) holds (for B148 , B149 being  InitHalting (Program of ( SCM+FSA )) holds (for B150 being  read-write Int-Location holds (( IC ( IExec (( if>0 (B150 , B148 , B149) ) , R9 , B147) ) ) = ( ( ( card B148 ) + ( card B149 ) ) + 3 ) & (( B147 . B150 ) > ( 0 ) implies ((for B151 being Int-Location holds ( ( IExec (( if>0 (B150 , B148 , B149) ) , R9 , B147) ) . B151 ) = ( ( IExec (B148 , R9 , B147) ) . B151 )) & (for B152 being FinSeq-Location holds ( ( IExec (( if>0 (B150 , B148 , B149) ) , R9 , B147) ) . B152 ) = ( ( IExec (B148 , R9 , B147) ) . B152 )))) & (( B147 . B150 ) <= ( 0 ) implies ((for B153 being Int-Location holds ( ( IExec (( if>0 (B150 , B148 , B149) ) , R9 , B147) ) . B153 ) = ( ( IExec (B149 , R9 , B147) ) . B153 )) & (for B154 being FinSeq-Location holds ( ( IExec (( if>0 (B150 , B148 , B149) ) , R9 , B147) ) . B154 ) = ( ( IExec (B149 , R9 , B147) ) . B154 )))))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C190 being (State of ( SCM+FSA ));
let C191 , C192 being  InitHalting (Program of ( SCM+FSA ));
let C193 being  read-write Int-Location;
thus L906:now
per cases ;
suppose L907: ( C190 . C193 ) > ( 0 );

L908: ( IExec (( if>0 (C193 , C191 , C192) ) , R9 , C190) ) = ( ( IExec (C191 , R9 , C190) ) +* ( Start-At (( ( ( card C191 ) + ( card C192 ) ) + 3 ) , ( SCM+FSA )) ) ) by L907 , L885;
thus L909: ( IC ( IExec (( if>0 (C193 , C191 , C192) ) , R9 , C190) ) ) = ( ( ( card C191 ) + ( card C192 ) ) + 3 ) by L908 , FUNCT_4:113;
end;
suppose L910: ( C190 . C193 ) <= ( 0 );

L911: ( IExec (( if>0 (C193 , C191 , C192) ) , R9 , C190) ) = ( ( IExec (C192 , R9 , C190) ) +* ( Start-At (( ( ( card C191 ) + ( card C192 ) ) + 3 ) , ( SCM+FSA )) ) ) by L910 , L885;
thus L912: ( IC ( IExec (( if>0 (C193 , C191 , C192) ) , R9 , C190) ) ) = ( ( ( card C191 ) + ( card C192 ) ) + 3 ) by L911 , FUNCT_4:113;
end;
end;
thus L914:now
assume L915: ( C190 . C193 ) > ( 0 );
L916: ( IExec (( if>0 (C193 , C191 , C192) ) , R9 , C190) ) = ( ( IExec (C191 , R9 , C190) ) +* ( Start-At (( ( ( card C191 ) + ( card C192 ) ) + 3 ) , ( SCM+FSA )) ) ) by L915 , L885;
thus L917:now
let C194 being Int-Location;
L918: (not C194 in ( dom ( Start-At (( ( ( card C191 ) + ( card C192 ) ) + 3 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
thus L919: ( ( IExec (( if>0 (C193 , C191 , C192) ) , R9 , C190) ) . C194 ) = ( ( IExec (C191 , R9 , C190) ) . C194 ) by L918 , L916 , FUNCT_4:11;
end;
let C195 being FinSeq-Location;
L920: (not C195 in ( dom ( Start-At (( ( ( card C191 ) + ( card C192 ) ) + 3 ) , ( SCM+FSA )) ) )) by SCMFSA_2:103;
thus L921: ( ( IExec (( if>0 (C193 , C191 , C192) ) , R9 , C190) ) . C195 ) = ( ( IExec (C191 , R9 , C190) ) . C195 ) by L920 , L916 , FUNCT_4:11;
end;
assume L922: ( C190 . C193 ) <= ( 0 );
L923: ( IExec (( if>0 (C193 , C191 , C192) ) , R9 , C190) ) = ( ( IExec (C192 , R9 , C190) ) +* ( Start-At (( ( ( card C191 ) + ( card C192 ) ) + 3 ) , ( SCM+FSA )) ) ) by L922 , L885;
thus L924:now
let C196 being Int-Location;
L925: (not C196 in ( dom ( Start-At (( ( ( card C191 ) + ( card C192 ) ) + 3 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
thus L926: ( ( IExec (( if>0 (C193 , C191 , C192) ) , R9 , C190) ) . C196 ) = ( ( IExec (C192 , R9 , C190) ) . C196 ) by L925 , L923 , FUNCT_4:11;
end;
let C197 being FinSeq-Location;
L927: (not C197 in ( dom ( Start-At (( ( ( card C191 ) + ( card C192 ) ) + 3 ) , ( SCM+FSA )) ) )) by SCMFSA_2:103;
thus L928: thesis by L927 , L923 , FUNCT_4:11;
end;
theorem
L929: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B155 being (State of ( SCM+FSA )) holds (for B156 , B157 being (Program of ( SCM+FSA )) holds (for B158 being  read-write Int-Location holds ((( B155 . B158 ) < ( 0 ) & B156 is_closed_onInit B155 , R9 & B156 is_halting_onInit B155 , R9) implies ( IExec (( if<0 (B158 , B156 , B157) ) , R9 , B155) ) = ( ( IExec (B156 , R9 , B155) ) +* ( Start-At (( ( ( ( card B156 ) + ( card B157 ) ) + ( card B157 ) ) + 7 ) , ( SCM+FSA )) ) ))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C198 being (State of ( SCM+FSA ));
let C199 , C200 being (Program of ( SCM+FSA ));
let C201 being  read-write Int-Location;
assume L930: ( C198 . C201 ) < ( 0 );
set D143 = ( Initialized C198 );
assume L931: C199 is_closed_onInit C198 , R9;
L932: C199 is_closed_on D143 , R9 by L931 , L764;
assume L933: C199 is_halting_onInit C198 , R9;
L934: C199 is_halting_on D143 , R9 by L933 , L771;
thus L935: thesis by L934 , L930 , L932 , SCMFSA8B:26;
end;
theorem
L936: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B159 being (State of ( SCM+FSA )) holds (for B160 , B161 being (Program of ( SCM+FSA )) holds (for B162 being  read-write Int-Location holds ((( B159 . B162 ) = ( 0 ) & B161 is_closed_onInit B159 , R9 & B161 is_halting_onInit B159 , R9) implies ( IExec (( if<0 (B162 , B160 , B161) ) , R9 , B159) ) = ( ( IExec (B161 , R9 , B159) ) +* ( Start-At (( ( ( ( card B160 ) + ( card B161 ) ) + ( card B161 ) ) + 7 ) , ( SCM+FSA )) ) ))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C202 being (State of ( SCM+FSA ));
let C203 , C204 being (Program of ( SCM+FSA ));
let C205 being  read-write Int-Location;
assume L937: ( C202 . C205 ) = ( 0 );
set D144 = ( Initialized C202 );
assume L938: C204 is_closed_onInit C202 , R9;
L939: C204 is_closed_on D144 , R9 by L938 , L764;
assume L940: C204 is_halting_onInit C202 , R9;
L941: C204 is_halting_on D144 , R9 by L940 , L771;
thus L942: thesis by L941 , L937 , L939 , SCMFSA8B:28;
end;
theorem
L943: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B163 being (State of ( SCM+FSA )) holds (for B164 , B165 being (Program of ( SCM+FSA )) holds (for B166 being  read-write Int-Location holds ((( B163 . B166 ) > ( 0 ) & B165 is_closed_onInit B163 , R9 & B165 is_halting_onInit B163 , R9) implies ( IExec (( if<0 (B166 , B164 , B165) ) , R9 , B163) ) = ( ( IExec (B165 , R9 , B163) ) +* ( Start-At (( ( ( ( card B164 ) + ( card B165 ) ) + ( card B165 ) ) + 7 ) , ( SCM+FSA )) ) ))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C206 being (State of ( SCM+FSA ));
let C207 , C208 being (Program of ( SCM+FSA ));
let C209 being  read-write Int-Location;
assume L944: ( C206 . C209 ) > ( 0 );
set D145 = ( Initialized C206 );
assume L945: C208 is_closed_onInit C206 , R9;
L946: C208 is_closed_on D145 , R9 by L945 , L764;
assume L947: C208 is_halting_onInit C206 , R9;
L948: C208 is_halting_on D145 , R9 by L947 , L771;
thus L949: thesis by L948 , L944 , L946 , SCMFSA8B:30;
end;
theorem
L950: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B167 being (State of ( SCM+FSA )) holds (for B168 , B169 being  InitHalting (Program of ( SCM+FSA )) holds (for B170 being  read-write Int-Location holds (( if<0 (B170 , B168 , B169) ) is  InitHalting & (( B167 . B170 ) < ( 0 ) implies ( IExec (( if<0 (B170 , B168 , B169) ) , R9 , B167) ) = ( ( IExec (B168 , R9 , B167) ) +* ( Start-At (( ( ( ( card B168 ) + ( card B169 ) ) + ( card B169 ) ) + 7 ) , ( SCM+FSA )) ) )) & (( B167 . B170 ) >= ( 0 ) implies ( IExec (( if<0 (B170 , B168 , B169) ) , R9 , B167) ) = ( ( IExec (B169 , R9 , B167) ) +* ( Start-At (( ( ( ( card B168 ) + ( card B169 ) ) + ( card B169 ) ) + 7 ) , ( SCM+FSA )) ) )))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C210 being (State of ( SCM+FSA ));
let C211 , C212 being  InitHalting (Program of ( SCM+FSA ));
let C213 being  read-write Int-Location;
L951: (( if<0 (C213 , C211 , C212) ) = ( if=0 (C213 , C212 , ( if>0 (C213 , C212 , C211) )) ) & ( if>0 (C213 , C212 , C211) ) is  InitHalting) by L885 , SCMFSA8B:def 3;
thus L952: ( if<0 (C213 , C211 , C212) ) is  InitHalting by L951 , L809;
L953: (C211 is_closed_onInit C210 , R9 & C211 is_halting_onInit C210 , R9) by L699 , L715;
thus L954: (( C210 . C213 ) < ( 0 ) implies ( IExec (( if<0 (C213 , C211 , C212) ) , R9 , C210) ) = ( ( IExec (C211 , R9 , C210) ) +* ( Start-At (( ( ( ( card C211 ) + ( card C212 ) ) + ( card C212 ) ) + 7 ) , ( SCM+FSA )) ) )) by L953 , L929;
L955: (C212 is_closed_onInit C210 , R9 & C212 is_halting_onInit C210 , R9) by L699 , L715;
thus L956:now
assume L957: ( C210 . C213 ) >= ( 0 );
per cases ;
suppose L958: ( C210 . C213 ) = ( 0 );

thus L959: ( IExec (( if<0 (C213 , C211 , C212) ) , R9 , C210) ) = ( ( IExec (C212 , R9 , C210) ) +* ( Start-At (( ( ( ( card C211 ) + ( card C212 ) ) + ( card C212 ) ) + 7 ) , ( SCM+FSA )) ) ) by L958 , L955 , L936;
end;
suppose L960: ( C210 . C213 ) <> ( 0 );

thus L961: ( IExec (( if<0 (C213 , C211 , C212) ) , R9 , C210) ) = ( ( IExec (C212 , R9 , C210) ) +* ( Start-At (( ( ( ( card C211 ) + ( card C212 ) ) + ( card C212 ) ) + 7 ) , ( SCM+FSA )) ) ) by L960 , L955 , L957 , L943;
end;
end;
end;
registration
let C214 , C215 being  InitHalting (Program of ( SCM+FSA ));
let C216 being  read-write Int-Location;
cluster ( if=0 (C216 , C214 , C215) ) ->  InitHalting;
correctness by L809;
cluster ( if>0 (C216 , C214 , C215) ) ->  InitHalting;
correctness by L885;
cluster ( if<0 (C216 , C214 , C215) ) ->  InitHalting;
correctness by L950;
end;
theorem
L958: (for B171 being (Program of ( SCM+FSA )) holds (B171 is  InitHalting iff (for B172 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds B171 is_halting_on ( Initialized B172 ) , R9))))
proof
let C217 being (Program of ( SCM+FSA ));
thus L959:now
assume L960: C217 is  InitHalting;
let C218 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
L961: C217 is_halting_onInit C218 , R9 by L960 , L715;
thus L962: C217 is_halting_on ( Initialized C218 ) , R9 by L961 , L771;
end;
assume L963: (for B173 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds C217 is_halting_on ( Initialized B173 ) , R9));
L964:
now
let C219 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
L965: C217 is_halting_on ( Initialized C219 ) , R9 by L963;
thus L966: C217 is_halting_onInit C219 , R9 by L965 , L771;
end;
thus L967: thesis by L964 , L715;
end;
theorem
L968: (for B174 being (Program of ( SCM+FSA )) holds (B174 is  InitClosed iff (for B175 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds B174 is_closed_on ( Initialized B175 ) , R9))))
proof
let C220 being (Program of ( SCM+FSA ));
thus L969:now
assume L970: C220 is  InitClosed;
let C221 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
L971: C220 is_closed_onInit C221 , R9 by L970 , L699;
thus L972: C220 is_closed_on ( Initialized C221 ) , R9 by L971 , L764;
end;
assume L973: (for B176 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds C220 is_closed_on ( Initialized B176 ) , R9));
L974:
now
let C222 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
L975: C220 is_closed_on ( Initialized C222 ) , R9 by L973;
thus L976: C220 is_closed_onInit C222 , R9 by L975 , L764;
end;
thus L977: thesis by L974 , L699;
end;
theorem
L978: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B177 being (State of ( SCM+FSA )) holds (for B178 being  InitHalting (Program of ( SCM+FSA )) holds (for B179 being  read-write Int-Location holds ( ( IExec (B178 , R9 , B177) ) . B179 ) = ( ( Comput (( R9 +* B178 ) , ( Initialize ( Initialized B177 ) ) , ( LifeSpan (( R9 +* B178 ) , ( Initialize ( Initialized B177 ) )) )) ) . B179 )))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C223 being (State of ( SCM+FSA ));
let C224 being  InitHalting (Program of ( SCM+FSA ));
let C225 being  read-write Int-Location;
L979: C224 is_halting_on ( Initialized C223 ) , R9 by L958;
thus L980: thesis by L979 , SCMFSA8C:58;
end;
theorem
L981: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B180 being (State of ( SCM+FSA )) holds (for B181 being  InitHalting (Program of ( SCM+FSA )) holds (for B182 being Int-Location holds (for B183 being (Element of ( NAT )) holds ((not B181 destroy B182) implies ( ( IExec (B181 , R9 , B180) ) . B182 ) = ( ( Comput (( R9 +* B181 ) , ( Initialize ( Initialized B180 ) ) , B183) ) . B182 )))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C226 being (State of ( SCM+FSA ));
let C227 being  InitHalting (Program of ( SCM+FSA ));
let C228 being Int-Location;
let C229 being (Element of ( NAT ));
assume L982: (not C227 destroy C228);
L983: (C227 is_halting_on ( Initialized C226 ) , R9 & C227 is_closed_on ( Initialized C226 ) , R9) by L958 , L968;
thus L984: thesis by L983 , L982 , SCMFSA8C:60;
end;
set D146 = ( NAT );
set D147 = ( Data-Locations ( SCM+FSA ) );
theorem
L985: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B184 being (State of ( SCM+FSA )) holds (for B185 being  InitHalting (Program of ( SCM+FSA )) holds (for B186 being Int-Location holds ((not B185 destroy B186) implies ( ( IExec (B185 , R9 , B184) ) . B186 ) = ( ( Initialized B184 ) . B186 ))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C230 being (State of ( SCM+FSA ));
let C231 being  InitHalting (Program of ( SCM+FSA ));
let C232 being Int-Location;
L986: ( Initialized C230 ) = ( C230 +* ( ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) +* D1 ) ) by FUNCT_4:93
.= ( ( Initialized C230 ) +* D1 ) by FUNCT_4:14;
assume L987: (not C231 destroy C232);
thus L988: ( ( IExec (C231 , R9 , C230) ) . C232 ) = ( ( Comput (( R9 +* C231 ) , ( Initialize ( Initialized C230 ) ) , ( 0 )) ) . C232 ) by L987 , L981
.= ( ( Initialized C230 ) . C232 ) by L986;
end;
theorem
L989: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B187 being (State of ( SCM+FSA )) holds (for B188 being  keepInt0_1  InitHalting (Program of ( SCM+FSA )) holds (for B189 being  read-write Int-Location holds ((not B188 destroy B189) implies ( ( Comput (( R9 +* ( B188 ";" ( SubFrom (B189 , ( intloc ( 0 ) )) ) ) ) , ( Initialize ( Initialized B187 ) ) , ( LifeSpan (( R9 +* ( B188 ";" ( SubFrom (B189 , ( intloc ( 0 ) )) ) ) ) , ( Initialize ( Initialized B187 ) )) )) ) . B189 ) = ( ( B187 . B189 ) - 1 ))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C233 being (State of ( SCM+FSA ));
let C234 being  keepInt0_1  InitHalting (Program of ( SCM+FSA ));
let C235 being  read-write Int-Location;
assume L990: (not C234 destroy C235);
set D148 = ( Initialized C233 );
set D149 = R9;
set D150 = ( Initialize D148 );
set D151 = ( D149 +* ( C234 ";" ( SubFrom (C235 , ( intloc ( 0 ) )) ) ) );
L991: C235 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L992: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L993: (not C235 in ( dom D1 )) by L992 , L991 , TARSKI:def 1;
L994: ( ( IExec (( C234 ";" ( SubFrom (C235 , ( intloc ( 0 ) )) ) ) , R9 , C233) ) . C235 ) = ( ( Exec (( SubFrom (C235 , ( intloc ( 0 ) )) ) , ( IExec (C234 , R9 , C233) )) ) . C235 ) by L684
.= ( ( ( IExec (C234 , R9 , C233) ) . C235 ) - ( ( IExec (C234 , R9 , C233) ) . ( intloc ( 0 ) ) ) ) by SCMFSA_2:65
.= ( ( ( IExec (C234 , R9 , C233) ) . C235 ) - 1 ) by L187
.= ( ( ( Comput (( D149 +* C234 ) , ( Initialize D148 ) , ( 0 )) ) . C235 ) - 1 ) by L990 , L981
.= ( ( ( Initialize D148 ) . C235 ) - 1 )
.= ( ( D148 . C235 ) - 1 ) by L993 , FUNCT_4:11;
thus L995: ( ( Comput (D151 , D150 , ( LifeSpan (D151 , D150) )) ) . C235 ) = ( ( D148 . C235 ) - 1 ) by L994 , L978
.= ( ( C233 . C235 ) - 1 ) by SCMFSA_M:37;
end;
theorem
L996: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B190 being (State of ( SCM+FSA )) holds (for B191 being  InitClosed (Program of ( SCM+FSA )) holds ((( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= B190 & B191 c= R9 & R9 halts_on B190) implies (for B192 being (Element of ( NAT )) holds (B192 <= ( LifeSpan (R9 , B190) ) implies ( Comput (R9 , B190 , B192) ) = ( Comput (( R9 +* ( loop B191 ) ) , B190 , B192) )))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C236 being (State of ( SCM+FSA ));
let C237 being  InitClosed (Program of ( SCM+FSA ));
assume that
L997: D2 c= C236
and
L998: C237 c= R9;
defpred S12[ Nat ] means ($1 <= ( LifeSpan (R9 , C236) ) implies ( Comput (R9 , C236 , $1) ) = ( Comput (( R9 +* ( loop C237 ) ) , C236 , $1) ));
assume L999: R9 halts_on C236;
L1000: (for R1 being (Element of ( NAT )) holds (S12[ R1 ] implies S12[ ( R1 + 1 ) ]))
proof
set D152 = C236;
set D153 = ( R9 +* ( loop C237 ) );
L1001: ( loop C237 ) c= D153 by FUNCT_4:25;
let R1 being (Element of ( NAT ));
assume L1002: (R1 <= ( LifeSpan (R9 , C236) ) implies ( Comput (R9 , C236 , R1) ) = ( Comput (( R9 +* ( loop C237 ) ) , C236 , R1) ));
L1003: ( Comput (D153 , D152 , ( R1 + 1 )) ) = ( Following (D153 , ( Comput (D153 , D152 , R1) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D153 , ( Comput (D153 , D152 , R1) )) ) , ( Comput (D153 , D152 , R1) )) );
L1004: ( Comput (R9 , C236 , ( R1 + 1 )) ) = ( Following (R9 , ( Comput (R9 , C236 , R1) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R9 , ( Comput (R9 , C236 , R1) )) ) , ( Comput (R9 , C236 , R1) )) );
L1005: ( IC ( Comput (R9 , C236 , R1) ) ) in ( dom C237 ) by L997 , L4 , L998;
L1006: ( IC ( Comput (R9 , C236 , R1) ) ) in ( dom ( loop C237 ) ) by L1005 , FUNCT_4:99;
L1007: ( R9 /. ( IC ( Comput (R9 , C236 , R1) ) ) ) = ( R9 . ( IC ( Comput (R9 , C236 , R1) ) ) ) by PBOOLE:143;
L1008: ( CurInstr (R9 , ( Comput (R9 , C236 , R1) )) ) = ( C237 . ( IC ( Comput (R9 , C236 , R1) ) ) ) by L1005 , L1007 , L998 , GRFUNC_1:2;
assume L1009: ( R1 + 1 ) <= ( LifeSpan (R9 , C236) );
L1010: ( D153 /. ( IC ( Comput (D153 , D152 , R1) ) ) ) = ( D153 . ( IC ( Comput (D153 , D152 , R1) ) ) ) by PBOOLE:143;
L1011: R1 < ( LifeSpan (R9 , C236) ) by L1009 , NAT_1:13;
L1012: ( C237 . ( IC ( Comput (R9 , C236 , R1) ) ) ) <> ( halt ( SCM+FSA ) ) by L1011 , L999 , L1008 , EXTPRO_1:def 15;
L1013: ( CurInstr (R9 , ( Comput (R9 , C236 , R1) )) ) = ( ( loop C237 ) . ( IC ( Comput (R9 , C236 , R1) ) ) ) by L1012 , L1008 , FUNCT_4:105
.= ( CurInstr (D153 , ( Comput (D153 , D152 , R1) )) ) by L1009 , L1006 , L1010 , L1001 , L1002 , GRFUNC_1:2 , NAT_1:13;
thus L1014: thesis by L1013 , L1002 , L1009 , L1004 , L1003 , NAT_1:13;
end;
L1015: S12[ ( 0 ) ];
thus L1016: (for B193 being (Element of ( NAT )) holds S12[ B193 ]) from NAT_1:sch 1(L1015 , L1000);
end;
theorem
L1017: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B194 being (State of ( SCM+FSA )) holds (for B195 being  InitHalting (Program of ( SCM+FSA )) holds ((( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= B194 & B195 c= R9) implies (for B196 being (Element of ( NAT )) holds (B196 <= ( LifeSpan (R9 , B194) ) implies ( CurInstr (( R9 +* ( loop B195 ) ) , ( Comput (( R9 +* ( loop B195 ) ) , B194 , B196) )) ) <> ( halt ( SCM+FSA ) )))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C238 being (State of ( SCM+FSA ));
let C239 being  InitHalting (Program of ( SCM+FSA ));
set D154 = C238;
set D155 = ( R9 +* ( loop C239 ) );
assume L1018: D2 c= C238;
assume L1019: C239 c= R9;
L1020: R9 halts_on C238 by L5 , L1018 , L1019;
thus L1021:now
let C240 being (Element of ( NAT ));
set D156 = ( IC ( Comput (R9 , C238 , C240) ) );
L1022: (( IC ( Comput (R9 , C238 , C240) ) ) in ( dom C239 ) & ( dom C239 ) = ( dom ( loop C239 ) )) by L1018 , L4 , L1019 , FUNCT_4:99;
L1023: ( ( loop C239 ) . D156 ) in ( rng ( loop C239 ) ) by L1022 , FUNCT_1:def 3;
assume L1024: C240 <= ( LifeSpan (R9 , C238) );
L1025: D156 = ( IC ( Comput (D155 , D154 , C240) ) ) by L1024 , L1018 , L1020 , L996 , L1019;
L1026: ( CurInstr (D155 , ( Comput (D155 , D154 , C240) )) ) = ( D155 . D156 ) by L1025 , PBOOLE:143
.= ( ( loop C239 ) . D156 ) by L1022 , FUNCT_4:13;
assume L1027: ( CurInstr (( R9 +* ( loop C239 ) ) , ( Comput (( R9 +* ( loop C239 ) ) , C238 , C240) )) ) = ( halt ( SCM+FSA ) );
thus L1028: contradiction by L1027 , L1026 , L1023 , SCMFSA8C:75;
end;
end;
theorem
L1022: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B197 being (State of ( SCM+FSA )) holds (for B198 being (Program of ( SCM+FSA )) holds ((B198 is_closed_onInit B197 , R9 & B198 is_halting_onInit B197 , R9) implies (for B199 being (Element of ( NAT )) holds (B199 <= ( LifeSpan (( R9 +* B198 ) , ( Initialized B197 )) ) implies ( Comput (( R9 +* B198 ) , ( Initialized B197 ) , B199) ) = ( Comput (( R9 +* ( loop B198 ) ) , ( Initialized B197 ) , B199) )))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C241 being (State of ( SCM+FSA ));
let C242 being (Program of ( SCM+FSA ));
set D157 = ( Initialized C241 );
set D158 = ( R9 +* C242 );
L1023: C242 c= D158 by FUNCT_4:25;
set D159 = ( Initialized C241 );
set D160 = ( R9 +* ( loop C242 ) );
L1024: ( loop C242 ) c= D160 by FUNCT_4:25;
assume L1025: C242 is_closed_onInit C241 , R9;
defpred S13[ Nat ] means ($1 <= ( LifeSpan (D158 , D157) ) implies ( Comput (D158 , D157 , $1) ) = ( Comput (D160 , D159 , $1) ));
assume L1026: C242 is_halting_onInit C241 , R9;
L1027: D158 halts_on D157 by L1026 , L697;
L1028: (for B200 being (Element of ( NAT )) holds (S13[ B200 ] implies S13[ ( B200 + 1 ) ]))
proof
let C243 being (Element of ( NAT ));
assume L1029: (C243 <= ( LifeSpan (D158 , D157) ) implies ( Comput (D158 , D157 , C243) ) = ( Comput (D160 , D159 , C243) ));
L1030: ( IC ( Comput (D158 , D157 , C243) ) ) in ( dom C242 ) by L1025 , L696;
L1031: ( IC ( Comput (D158 , D157 , C243) ) ) in ( dom ( loop C242 ) ) by L1030 , FUNCT_4:99;
L1032: ( D158 /. ( IC ( Comput (D158 , D157 , C243) ) ) ) = ( D158 . ( IC ( Comput (D158 , D157 , C243) ) ) ) by PBOOLE:143;
L1033: ( CurInstr (D158 , ( Comput (D158 , D157 , C243) )) ) = ( C242 . ( IC ( Comput (D158 , D157 , C243) ) ) ) by L1030 , L1032 , L1023 , GRFUNC_1:2;
L1034: ( Comput (D160 , D159 , ( C243 + 1 )) ) = ( Following (D160 , ( Comput (D160 , D159 , C243) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D160 , ( Comput (D160 , D159 , C243) )) ) , ( Comput (D160 , D159 , C243) )) );
L1035: ( Comput (D158 , D157 , ( C243 + 1 )) ) = ( Following (D158 , ( Comput (D158 , D157 , C243) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D158 , ( Comput (D158 , D157 , C243) )) ) , ( Comput (D158 , D157 , C243) )) );
assume L1036: ( C243 + 1 ) <= ( LifeSpan (D158 , D157) );
L1037: C243 < ( LifeSpan (D158 , D157) ) by L1036 , NAT_1:13;
L1038: ( C242 . ( IC ( Comput (D158 , D157 , C243) ) ) ) <> ( halt ( SCM+FSA ) ) by L1037 , L1027 , L1033 , EXTPRO_1:def 15;
L1039: ( C242 . ( IC ( Comput (D158 , D157 , C243) ) ) ) = ( ( loop C242 ) . ( IC ( Comput (D158 , D157 , C243) ) ) ) by L1038 , FUNCT_4:105;
L1040: ( D160 /. ( IC ( Comput (D160 , D159 , C243) ) ) ) = ( D160 . ( IC ( Comput (D160 , D159 , C243) ) ) ) by PBOOLE:143;
thus L1041: thesis by L1029 , L1036 , L1035 , L1034 , L1031 , L1033 , L1040 , L1039 , L1024 , GRFUNC_1:2 , NAT_1:13;
end;
L1042: S13[ ( 0 ) ]
proof
assume L1043: ( 0 ) <= ( LifeSpan (D158 , D157) );
thus L1044: thesis;
end;
thus L1045: (for B201 being (Element of ( NAT )) holds S13[ B201 ]) from NAT_1:sch 1(L1042 , L1028);
end;
theorem
L1046: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B202 being (State of ( SCM+FSA )) holds (for B203 being (Program of ( SCM+FSA )) holds ((B203 is_closed_onInit B202 , R9 & B203 is_halting_onInit B202 , R9) implies (for B204 being (Element of ( NAT )) holds (B204 < ( LifeSpan (( R9 +* B203 ) , ( Initialized B202 )) ) implies ( CurInstr (( R9 +* B203 ) , ( Comput (( R9 +* B203 ) , ( Initialized B202 ) , B204) )) ) = ( CurInstr (( R9 +* ( loop B203 ) ) , ( Comput (( R9 +* ( loop B203 ) ) , ( Initialized B202 ) , B204) )) )))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C244 being (State of ( SCM+FSA ));
let C245 being (Program of ( SCM+FSA ));
set D161 = ( Initialized C244 );
set D162 = ( R9 +* C245 );
L1047: C245 c= D162 by FUNCT_4:25;
set D163 = ( Initialized C244 );
set D164 = ( R9 +* ( loop C245 ) );
L1048: ( loop C245 ) c= D164 by FUNCT_4:25;
assume that
L1049: C245 is_closed_onInit C244 , R9
and
L1050: C245 is_halting_onInit C244 , R9;
let C246 being (Element of ( NAT ));
L1051: ( IC ( Comput (D162 , D161 , C246) ) ) in ( dom C245 ) by L1049 , L696;
L1052: ( IC ( Comput (D162 , D161 , C246) ) ) in ( dom ( loop C245 ) ) by L1051 , FUNCT_4:99;
L1053: ( D162 /. ( IC ( Comput (D162 , D161 , C246) ) ) ) = ( D162 . ( IC ( Comput (D162 , D161 , C246) ) ) ) by PBOOLE:143;
L1054: ( CurInstr (D162 , ( Comput (D162 , D161 , C246) )) ) = ( C245 . ( IC ( Comput (D162 , D161 , C246) ) ) ) by L1051 , L1053 , L1047 , GRFUNC_1:2;
assume L1055: C246 < ( LifeSpan (( R9 +* C245 ) , ( Initialized C244 )) );
L1056: ( D164 /. ( IC ( Comput (D164 , D163 , C246) ) ) ) = ( D164 . ( IC ( Comput (D164 , D163 , C246) ) ) ) by PBOOLE:143;
L1057: D162 halts_on D161 by L1050 , L697;
L1058: ( C245 . ( IC ( Comput (D162 , D161 , C246) ) ) ) <> ( halt ( SCM+FSA ) ) by L1057 , L1055 , L1054 , EXTPRO_1:def 15;
L1059: ( C245 . ( IC ( Comput (D162 , D161 , C246) ) ) ) = ( ( loop C245 ) . ( IC ( Comput (D162 , D161 , C246) ) ) ) by L1058 , FUNCT_4:105;
L1060: ( Comput (D162 , D161 , C246) ) = ( Comput (D164 , D163 , C246) ) by L1049 , L1050 , L1055 , L1022;
thus L1061: thesis by L1060 , L1052 , L1054 , L1059 , L1056 , L1048 , GRFUNC_1:2;
end;
theorem
L1062: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B205 being (State of ( SCM+FSA )) holds (for B206 being (Program of ( SCM+FSA )) holds ((B206 is_closed_onInit B205 , R9 & B206 is_halting_onInit B205 , R9) implies (( CurInstr (( R9 +* ( loop B206 ) ) , ( Comput (( R9 +* ( loop B206 ) ) , ( Initialized B205 ) , ( LifeSpan (( R9 +* B206 ) , ( Initialized B205 )) )) )) ) = ( goto ( 0 ) ) & (for B207 being (Element of ( NAT )) holds (B207 <= ( LifeSpan (( R9 +* B206 ) , ( Initialized B205 )) ) implies ( CurInstr (( R9 +* ( loop B206 ) ) , ( Comput (( R9 +* ( loop B206 ) ) , ( Initialized B205 ) , B207) )) ) <> ( halt ( SCM+FSA ) ))))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
L1063: ( dom ( id (the InstructionsF of ( SCM+FSA )) ) ) = (the InstructionsF of ( SCM+FSA ));
let C247 being (State of ( SCM+FSA ));
let C248 being (Program of ( SCM+FSA ));
set D165 = ( Initialized C247 );
set D166 = ( R9 +* C248 );
set D167 = ( Initialized C247 );
set D168 = ( R9 +* ( loop C248 ) );
L1064: ( loop C248 ) c= D168 by FUNCT_4:25;
assume that
L1065: C248 is_closed_onInit C247 , R9
and
L1066: C248 is_halting_onInit C247 , R9;
set D169 = ( LifeSpan (D166 , D165) );
L1067: ( rng C248 ) c= (the InstructionsF of ( SCM+FSA )) by RELAT_1:def 19;
L1068: ( IC ( Comput (D166 , D165 , D169) ) ) in ( dom C248 ) by L1065 , L696;
L1069: ( dom ( loop C248 ) ) = ( dom C248 ) by FUNCT_4:99;
L1070: ( CurInstr (D166 , ( Comput (D166 , D165 , D169) )) ) = ( D166 . ( IC ( Comput (D166 , D165 , D169) ) ) ) by PBOOLE:143
.= ( C248 . ( IC ( Comput (D166 , D165 , D169) ) ) ) by L1068 , FUNCT_4:13;
L1071: D166 halts_on D165 by L1066 , L697;
L1072: ( CurInstr (D166 , ( Comput (D166 , D165 , D169) )) ) = ( halt ( SCM+FSA ) ) by L1071 , EXTPRO_1:def 15;
L1073: ( IC ( Comput (D166 , D165 , D169) ) ) = ( IC ( Comput (D168 , D167 , D169) ) ) by L1065 , L1066 , L1022;
thus L1074: ( CurInstr (D168 , ( Comput (D168 , D167 , ( LifeSpan (D166 , D165) )) )) ) = ( D168 . ( IC ( Comput (D166 , D165 , D169) ) ) ) by L1073 , PBOOLE:143
.= ( ( loop C248 ) . ( IC ( Comput (D166 , D165 , D169) ) ) ) by L1064 , L1068 , L1069 , GRFUNC_1:2
.= ( ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* (( halt ( SCM+FSA ) ) , ( goto ( 0 ) )) ) * C248 ) . ( IC ( Comput (D166 , D165 , D169) ) ) ) by L1067 , FUNCT_7:116
.= ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* (( halt ( SCM+FSA ) ) , ( goto ( 0 ) )) ) . ( halt ( SCM+FSA ) ) ) by L1072 , L1068 , L1070 , FUNCT_1:13
.= ( goto ( 0 ) ) by L1063 , FUNCT_7:31;
let C249 being (Element of ( NAT ));
assume L1075: C249 <= ( LifeSpan (D166 , D165) );
per cases  by L1075 , XXREAL_0:1;
suppose L1076: C249 < ( LifeSpan (D166 , D165) );

L1077: ( CurInstr (D166 , ( Comput (D166 , D165 , C249) )) ) <> ( halt ( SCM+FSA ) ) by L1076 , L1071 , EXTPRO_1:def 15;
thus L1078: thesis by L1077 , L1065 , L1066 , L1076 , L1046;
end;
suppose L1079: C249 = ( LifeSpan (D166 , D165) );

thus L1080: thesis by L1079 , L1074;
end;
end;
theorem
L1082: (for B208 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B209 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B210 being  read-write Int-Location holds (((not B209 destroy B210) & ( B208 . ( intloc ( 0 ) ) ) = 1 & ( B208 . B210 ) > ( 0 )) implies ( loop ( if=0 (B210 , ( Goto 2 ) , ( B209 ";" ( SubFrom (B210 , ( intloc ( 0 ) )) ) )) ) ) is_pseudo-closed_on B208 , R9)))))
proof
let C250 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C251 being  good  InitHalting (Program of ( SCM+FSA ));
let C252 being  read-write Int-Location;
set D170 = ( if=0 (C252 , ( Goto 2 ) , ( C251 ";" ( SubFrom (C252 , ( intloc ( 0 ) )) ) )) );
reconsider D171 = ( C251 ";" ( SubFrom (C252 , ( intloc ( 0 ) )) ) ) as  InitHalting (Program of ( SCM+FSA ));
set D172 = ( C252 =0_goto ( ( card D171 ) + 3 ) );
defpred S14[ Nat ] means (for B211 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds ((( B211 . ( intloc ( 0 ) ) ) = 1 & ( B211 . C252 ) = $1 & ( B211 . C252 ) > ( 0 )) implies (( ( Comput (( R9 +* ( loop D170 ) ) , ( Initialized B211 ) , ( ( LifeSpan (( R9 +* D170 ) , ( Initialized B211 )) ) + 1 )) ) . C252 ) = ( ( B211 . C252 ) - 1 ) & ( ( Comput (( R9 +* ( loop D170 ) ) , ( Initialized B211 ) , ( ( LifeSpan (( R9 +* D170 ) , ( Initialized B211 )) ) + 1 )) ) . ( intloc ( 0 ) ) ) = 1 & (ex B212 being (Element of ( NAT )) st (( IC ( Comput (( R9 +* ( loop D170 ) ) , ( Initialized B211 ) , B212) ) ) = ( card ( loop D170 ) ) & (for B213 being (Element of ( NAT )) holds (B213 < B212 implies ( IC ( Comput (( R9 +* ( loop D170 ) ) , ( Initialized B211 ) , B213) ) ) in ( dom ( loop D170 ) )))))))));
assume L1083: (not C251 destroy C252);
L1084: (for B214 being (Element of ( NAT )) holds (S14[ B214 ] implies S14[ ( B214 + 1 ) ]))
proof
L1085:
now
L1086: (( 0 ) in ( dom ( Macro D172 ) ) & ( ( Macro D172 ) . ( 0 ) ) <> ( halt ( SCM+FSA ) )) by COMPOS_1:58 , COMPOS_1:60;
L1087: D170 = ( ( ( ( D172 ";" D171 ) ";" ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ";" ( Goto 2 ) ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1
.= ( ( ( D172 ";" ( D171 ";" ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ) ";" ( Goto 2 ) ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA6A:29
.= ( ( D172 ";" ( ( D171 ";" ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ";" ( Goto 2 ) ) ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA6A:29
.= ( D172 ";" ( ( ( D171 ";" ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ";" ( Goto 2 ) ) ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:29
.= ( ( Macro D172 ) ";" ( ( ( D171 ";" ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ";" ( Goto 2 ) ) ";" ( Stop ( SCM+FSA ) ) ) );
thus L1088: ( D170 . ( 0 ) ) = ( ( Macro D172 ) . ( 0 ) ) by L1087 , L1086 , SCMFSA6A:15
.= D172 by COMPOS_1:58;
thus L1089: ( D170 . ( 0 ) ) <> ( halt ( SCM+FSA ) ) by L1088;
L1090: ( card D170 ) = ( ( ( card ( Goto 2 ) ) + ( card D171 ) ) + 4 ) by SCMFSA8B:11
.= ( ( ( card D171 ) + 1 ) + 4 ) by SCMFSA8A:15
.= ( ( ( card D171 ) + 3 ) + 2 );
thus L1091: ( 0 ) in ( dom D170 ) by L1090 , AFINSQ_1:66;
L1092: ( card ( loop D170 ) ) = ( card ( dom ( loop D170 ) ) ) by CARD_1:62
.= ( card ( dom D170 ) ) by FUNCT_4:99
.= ( card D170 ) by CARD_1:62;
L1093: ( card ( loop D170 ) ) = ( ( card D171 ) + ( 3 + 2 ) ) by L1092 , L1090;
thus L1094: ( D170 . ( ( card D171 ) + 3 ) ) = ( goto ( card ( loop D170 ) ) ) by L1093 , SCMFSA8C:83;
thus L1095: ( D170 . ( ( card D171 ) + 3 ) ) <> ( halt ( SCM+FSA ) ) by L1094;
thus L1096:now
L1097: ( ( ( card D171 ) + 3 ) + ( 0 ) ) < ( card D170 ) by L1090 , XREAL_1:6;
thus L1098: ( ( card D171 ) + 3 ) in ( dom D170 ) by L1097 , AFINSQ_1:66;
end;
end;
let C253 being (Element of ( NAT ));
assume L1097: S14[ C253 ];
let C254 being (State of ( SCM+FSA ));
let C255 being (Instruction-Sequence of ( SCM+FSA ));
assume L1098: ( C254 . ( intloc ( 0 ) ) ) = 1;
set D173 = ( Initialized C254 );
set D174 = ( C255 +* ( loop D170 ) );
L1099: ( loop D170 ) c= D174 by FUNCT_4:25;
set D175 = ( Initialized C254 );
set D176 = ( C255 +* D170 );
assume L1100: ( C254 . C252 ) = ( C253 + 1 );
L1101: ( Comput (D174 , D173 , ( ( LifeSpan (D176 , D175) ) + 1 )) ) = ( Following (D174 , ( Comput (D174 , D173 , ( LifeSpan (D176 , D175) )) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D174 , ( Comput (D174 , D173 , ( LifeSpan (D176 , D175) )) )) ) , ( Comput (D174 , D173 , ( LifeSpan (D176 , D175) )) )) );
set D177 = ( Comput (D174 , D173 , ( ( LifeSpan (D176 , D175) ) + 1 )) );
set D178 = D174;
assume L1102: ( C254 . C252 ) > ( 0 );
L1103: (D171 is_closed_onInit C254 , C255 & D171 is_halting_onInit C254 , C255) by L699 , L715;
L1104: D170 is_halting_onInit C254 , C255 by L1103 , L1102 , L793;
L1105: D170 is_closed_onInit C254 , C255 by L1102 , L1103 , L793;
L1106: ( Comput (D174 , D173 , ( ( LifeSpan (D176 , D175) ) + 1 )) ) = ( Exec (( goto ( 0 ) ) , ( Comput (D174 , D173 , ( LifeSpan (D176 , D175) )) )) ) by L1105 , L1104 , L1101 , L1062;
L1107: D170 is_closed_onInit C254 , C255 by L1102 , L1103 , L793;
L1108: ( card D170 ) = ( ( ( card ( Goto 2 ) ) + ( card D171 ) ) + 4 ) by SCMFSA8B:11
.= ( ( ( card D171 ) + 1 ) + 4 ) by SCMFSA8A:15
.= ( ( ( card D171 ) + 3 ) + 2 );
L1109: ( card ( loop D170 ) ) = ( card ( dom ( loop D170 ) ) ) by CARD_1:62
.= ( card ( dom D170 ) ) by FUNCT_4:99
.= ( card D170 ) by CARD_1:62;
L1110:
now
L1111: D171 is_halting_onInit C254 , C255 by L715;
L1112: D171 is_halting_on ( Initialized C254 ) , C255 by L1111 , L771;
L1113: D171 is_closed_onInit C254 , C255 by L699;
L1114: ( IExec (D170 , C255 , C254) ) = ( ( IExec (D171 , C255 , C254) ) +* ( Start-At (( ( ( card ( Goto 2 ) ) + ( card D171 ) ) + 3 ) , ( SCM+FSA )) ) ) by L1113 , L1102 , L1111 , L802;
L1115: ( ( IExec (D170 , C255 , C254) ) . C252 ) = ( ( IExec (D171 , C255 , C254) ) . C252 ) by L1114 , SCMFSA_3:3;
thus L1116:now
thus L1117: ( 0 ) in ( dom ( loop D170 ) ) by L1109 , L1108 , AFINSQ_1:66;
L1118: ( ( ( card D171 ) + 3 ) + ( 1 + 1 ) ) = ( ( ( ( card D171 ) + 3 ) + 1 ) + 1 );
L1119: ( ( ( card D171 ) + 3 ) + 1 ) < ( card D170 ) by L1118 , L1108 , NAT_1:13;
L1120: ( ( card D171 ) + 3 ) < ( card ( loop D170 ) ) by L1119 , L1109 , NAT_1:13;
thus L1121: ( ( card D171 ) + 3 ) in ( dom ( loop D170 ) ) by L1120 , AFINSQ_1:66;
end;
consider C256 being (State of ( SCM+FSA )) such that L1122: C256 = ( Initialized ( Initialized C254 ) );
L1123: C256 = ( ( Initialized C254 ) +* ( ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) +* D1 ) ) by L1122 , FUNCT_4:93
.= ( ( ( Initialized C254 ) +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) +* D1 ) by FUNCT_4:14
.= ( Initialize ( Initialized C254 ) ) by FUNCT_4:93;
L1124: D171 is_closed_onInit C254 , C255 by L699;
L1125: D171 is_closed_on ( Initialized C254 ) , C255 by L1124 , L764;
L1126: D171 is_halting_onInit C254 , C255 by L715;
L1127: D171 is_halting_on ( Initialized C254 ) , C255 by L1126 , L771;
L1128: ( ( Initialized C254 ) . C252 ) > ( 0 ) by L1102 , SCMFSA_M:37;
L1129: D170 is_halting_on ( Initialized C254 ) , C255 by L1128 , L1125 , L1127 , SCMFSA8B:15;
thus L1130: ( Initialized ( Initialized C254 ) ) = ( Initialized C254 );
L1131:
now
let C257 being Int-Location;
L1132: ( ( Comput (D174 , D173 , ( ( LifeSpan (D176 , D175) ) + 1 )) ) . C257 ) = ( ( Comput (D174 , D173 , ( LifeSpan (D176 , D175) )) ) . C257 ) by L1106 , SCMFSA_2:69;
thus L1133: ( ( Comput (D174 , D173 , ( ( LifeSpan (D176 , D175) ) + 1 )) ) . C257 ) = ( ( Comput (( C255 +* D170 ) , C256 , ( LifeSpan (( C255 +* D170 ) , C256) )) ) . C257 ) by L1132 , L1122 , L1104 , L1107 , L1022;
end;
L1134: ( ( Comput (D174 , D173 , ( ( LifeSpan (D176 , D175) ) + 1 )) ) . C252 ) = ( ( Comput (( C255 +* D170 ) , C256 , ( LifeSpan (( C255 +* D170 ) , C256) )) ) . C252 ) by L1131
.= ( ( IExec (D170 , C255 , C254) ) . C252 ) by L1129 , L1123 , SCMFSA8C:58;
thus L1135: ( ( Comput (D174 , D173 , ( ( LifeSpan (D176 , D175) ) + 1 )) ) . C252 ) = ( ( Comput (( C255 +* D171 ) , ( Initialize ( Initialized C254 ) ) , ( LifeSpan (( C255 +* D171 ) , ( Initialize ( Initialized C254 ) )) )) ) . C252 ) by L1134 , L1112 , L1115 , SCMFSA8C:58
.= ( ( C254 . C252 ) - 1 ) by L1083 , L989;
L1136: D170 is_closed_on ( Initialized C254 ) , C255 by L1128 , L1125 , L1127 , SCMFSA8B:15;
L1137: ( ( Comput (D174 , D173 , ( ( LifeSpan (D176 , D175) ) + 1 )) ) . ( intloc ( 0 ) ) ) = ( ( Comput (( C255 +* D170 ) , C256 , ( LifeSpan (( C255 +* D170 ) , C256) )) ) . ( intloc ( 0 ) ) ) by L1131
.= 1 by L1129 , L1136 , L1123 , SCMFSA8C:67;
thus L1138: ( ( Comput (D174 , D173 , ( ( LifeSpan (D176 , D175) ) + 1 )) ) . ( intloc ( 0 ) ) ) = 1 by L1137;
end;
thus L1139: (( D177 . C252 ) = ( ( C254 . C252 ) - 1 ) & ( D177 . ( intloc ( 0 ) ) ) = 1) by L1110;
L1140: ( IC ( Comput (D174 , D173 , ( ( LifeSpan (D176 , D175) ) + 1 )) ) ) = ( 0 ) by L1106 , SCMFSA_2:69;
per cases ;
suppose L1141: C253 = ( 0 );

take D179 = ( ( ( ( LifeSpan (D176 , D175) ) + 1 ) + 1 ) + 1 );
L1142: ( CurInstr (D174 , ( Comput (D174 , D173 , ( ( LifeSpan (D176 , D175) ) + 1 )) )) ) = ( D174 . ( 0 ) ) by L1140 , PBOOLE:143
.= ( ( loop D170 ) . ( 0 ) ) by L1110 , L1099 , GRFUNC_1:2
.= D172 by L1085 , FUNCT_4:105;
L1143: ( Comput (D174 , D173 , ( ( ( LifeSpan (D176 , D175) ) + 1 ) + 1 )) ) = ( Following (D174 , ( Comput (D174 , D173 , ( ( LifeSpan (D176 , D175) ) + 1 )) )) ) by EXTPRO_1:3
.= ( Exec (D172 , ( Comput (D174 , D173 , ( ( LifeSpan (D176 , D175) ) + 1 )) )) ) by L1142;
L1144: ( IC ( Comput (D174 , D173 , ( ( ( LifeSpan (D176 , D175) ) + 1 ) + 1 )) ) ) = ( ( card D171 ) + 3 ) by L1143 , L1100 , L1110 , L1141 , SCMFSA_2:70;
L1145: ( CurInstr (D174 , ( Comput (D174 , D173 , ( ( ( LifeSpan (D176 , D175) ) + 1 ) + 1 )) )) ) = ( D174 . ( ( card D171 ) + 3 ) ) by L1144 , PBOOLE:143
.= ( ( loop D170 ) . ( ( card D171 ) + 3 ) ) by L1110 , L1099 , GRFUNC_1:2
.= ( goto ( card ( loop D170 ) ) ) by L1085 , FUNCT_4:105;
L1146: ( Comput (D174 , D173 , D179) ) = ( Following (D174 , ( Comput (D174 , D173 , ( ( ( LifeSpan (D176 , D175) ) + 1 ) + 1 )) )) ) by EXTPRO_1:3
.= ( Exec (( goto ( card ( loop D170 ) ) ) , ( Comput (D174 , D173 , ( ( ( LifeSpan (D176 , D175) ) + 1 ) + 1 )) )) ) by L1145;
thus L1147: ( IC ( Comput (D174 , D173 , D179) ) ) = ( card ( loop D170 ) ) by L1146 , SCMFSA_2:69;
thus L1148:now
let C258 being (Element of ( NAT ));
assume L1149: C258 < D179;
L1150: C258 <= ( ( ( LifeSpan (D176 , D175) ) + 1 ) + 1 ) by L1149 , NAT_1:13;
L1151: (C258 <= ( ( LifeSpan (D176 , D175) ) + 1 ) or C258 = ( ( ( LifeSpan (D176 , D175) ) + 1 ) + 1 )) by L1150 , NAT_1:8;
per cases  by L1151 , NAT_1:8;
suppose L1152: C258 <= ( LifeSpan (D176 , D175) );

L1153: (D171 is_closed_onInit C254 , C255 & D171 is_halting_onInit C254 , C255) by L699 , L715;
L1154: D170 is_closed_onInit C254 , C255 by L1153 , L1102 , L793;
L1155: D170 is_halting_onInit C254 , C255 by L1102 , L1153 , L793;
L1156: ( IC ( Comput (D174 , D173 , C258) ) ) = ( IC ( Comput (D176 , D175 , C258) ) ) by L1155 , L1152 , L1154 , L1022;
L1157: ( IC ( Comput (D176 , D175 , C258) ) ) in ( dom D170 ) by L1154 , L696;
thus L1158: ( IC ( Comput (D174 , D173 , C258) ) ) in ( dom ( loop D170 ) ) by L1157 , L1156 , FUNCT_4:99;
end;
suppose L1159: C258 = ( ( LifeSpan (D176 , D175) ) + 1 );

thus L1160: ( IC ( Comput (D174 , D173 , C258) ) ) in ( dom ( loop D170 ) ) by L1159 , L1106 , L1110 , SCMFSA_2:69;
end;
suppose L1161: C258 = ( ( ( LifeSpan (D176 , D175) ) + 1 ) + 1 );

thus L1162: ( IC ( Comput (D174 , D173 , C258) ) ) in ( dom ( loop D170 ) ) by L1161 , L1100 , L1110 , L1141 , L1143 , SCMFSA_2:70;
end;
end;
end;
suppose L1149: C253 > ( 0 );

consider C259 being (State of ( SCM+FSA )) such that L1150: C259 = ( Initialized D177 );
consider C260 being (Element of ( NAT )) such that L1151: ( IC ( Comput (( D178 +* ( loop D170 ) ) , ( C259 +* D2 ) , C260) ) ) = ( card ( loop D170 ) ) and L1152: (for B215 being (Element of ( NAT )) holds (B215 < C260 implies ( IC ( Comput (( D178 +* ( loop D170 ) ) , ( Initialized C259 ) , B215) ) ) in ( dom ( loop D170 ) ))) by L1097 , L1149 , L1100 , L1110 , L1150;
take D180 = ( ( ( LifeSpan (D176 , D175) ) + 1 ) + C260 );
L1153: ( Initialized ( Initialized D177 ) ) = D177 by L1140 , L1110 , SCMFSA_M:8;
thus L1154: ( IC ( Comput (D174 , D173 , D180) ) ) = ( card ( loop D170 ) ) by L1150 , L1151 , L1153 , EXTPRO_1:4;
thus L1155:now
let C261 being (Element of ( NAT ));
assume L1156: C261 < D180;
L1157: (D171 is_closed_onInit C254 , C255 & D171 is_halting_onInit C254 , C255) by L699 , L715;
L1158: D170 is_closed_onInit C254 , C255 by L1157 , L1102 , L793;
L1159: D170 is_halting_onInit C254 , C255 by L1102 , L1157 , L793;
per cases  by NAT_1:13;
suppose L1160: C261 <= ( LifeSpan (D176 , D175) );

L1161: ( IC ( Comput (D174 , D173 , C261) ) ) = ( IC ( Comput (D176 , D175 , C261) ) ) by L1160 , L1158 , L1159 , L1022;
L1162: ( IC ( Comput (D176 , D175 , C261) ) ) in ( dom D170 ) by L1158 , L696;
thus L1163: ( IC ( Comput (D174 , D173 , C261) ) ) in ( dom ( loop D170 ) ) by L1162 , L1161 , FUNCT_4:99;
end;
suppose L1164: ( ( LifeSpan (D176 , D175) ) + 1 ) <= C261;

consider C262 being (Element of ( NAT )) such that L1165: C262 = ( C261 -' ( ( LifeSpan (D176 , D175) ) + 1 ) );
L1166: ( C261 - ( ( LifeSpan (D176 , D175) ) + 1 ) ) >= ( 0 ) by L1164 , XREAL_1:48;
L1167: C262 = ( C261 - ( ( LifeSpan (D176 , D175) ) + 1 ) ) by L1166 , L1165 , XREAL_0:def 2;
L1168: ( C262 + ( ( LifeSpan (D176 , D175) ) + 1 ) ) = C261 by L1164 , L1165 , XREAL_1:235;
L1169: ( IC ( Comput (D174 , D173 , C261) ) ) = ( IC ( Comput (D174 , D177 , C262) ) ) by L1168 , EXTPRO_1:4;
L1170: C260 = ( D180 - ( ( LifeSpan (D176 , D175) ) + 1 ) );
L1171: C262 < C260 by L1170 , L1156 , L1167 , XREAL_1:9;
thus L1172: ( IC ( Comput (D174 , D173 , C261) ) ) in ( dom ( loop D170 ) ) by L1171 , L1150 , L1152 , L1153 , L1169;
end;
end;
end;
end;
assume L1157: ( C250 . ( intloc ( 0 ) ) ) = 1;
assume L1158: ( C250 . C252 ) > ( 0 );
reconsider D181 = ( C250 . C252 ) as (Element of ( NAT )) by L1158 , INT_1:3;
L1159: S14[ ( 0 ) ];
L1160: (for B216 being (Element of ( NAT )) holds S14[ B216 ]) from NAT_1:sch 1(L1159 , L1084);
L1161: S14[ D181 ] by L1160;
L1162: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L1163: ( IC ( SCM+FSA ) ) <> ( intloc ( 0 ) ) by SCMFSA_2:56;
L1164: (not ( intloc ( 0 ) ) in ( dom D1 )) by L1163 , L1162 , TARSKI:def 1;
L1165: ( ( Initialize C250 ) . ( intloc ( 0 ) ) ) = 1 by L1164 , L1157 , FUNCT_4:11;
L1166: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L1162 , TARSKI:def 1;
L1167: ( IC ( Initialize C250 ) ) = ( IC D1 ) by L1166 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L1168: ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) = { ( intloc ( 0 ) ) } by FUNCOP_1:13;
L1169: ( dom D1 ) misses ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) by L1168 , L1162 , SCMFSA_2:56 , ZFMISC_1:11;
L1170: ( Initialized C250 ) = ( C250 +* ( D1 +* ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L1169 , FUNCT_4:35
.= ( ( Initialize C250 ) +* ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCT_4:14
.= ( ( ( Initialize C250 ) +* ( ( intloc ( 0 ) ) .--> 1 ) ) +* D1 ) by L1169 , FUNCT_4:115
.= ( Initialized ( Initialize C250 ) ) by FUNCT_4:14
.= ( Initialize C250 ) by L1165 , L1167 , SCMFSA_M:8;
L1171: (ex B217 being (Element of ( NAT )) st (( IC ( Comput (( R9 +* ( loop D170 ) ) , ( Initialize C250 ) , B217) ) ) = ( card ( loop D170 ) ) & (for B218 being (Element of ( NAT )) holds (B218 < B217 implies ( IC ( Comput (( R9 +* ( loop D170 ) ) , ( Initialize C250 ) , B218) ) ) in ( dom ( loop D170 ) ))))) by L1170 , L1161 , L1157 , L1158;
thus L1172: ( loop D170 ) is_pseudo-closed_on C250 , R9 by L1171 , SCMFSA8A:def 2;
end;
theorem
L1173: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B219 being (State of ( SCM+FSA )) holds (for B220 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B221 being  read-write Int-Location holds (((not B220 destroy B221) & ( B219 . B221 ) > ( 0 )) implies ( loop ( if=0 (B221 , ( Goto 2 ) , ( B220 ";" ( SubFrom (B221 , ( intloc ( 0 ) )) ) )) ) ) is_pseudo-closed_on ( Initialized B219 ) , R9)))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C263 being (State of ( SCM+FSA ));
let C264 being  good  InitHalting (Program of ( SCM+FSA ));
let C265 being  read-write Int-Location;
assume L1174: (not C264 destroy C265);
L1175: (( ( Initialized C263 ) . C265 ) = ( C263 . C265 ) & ( ( Initialized C263 ) . ( intloc ( 0 ) ) ) = 1) by SCMFSA_M:9 , SCMFSA_M:37;
assume L1176: ( C263 . C265 ) > ( 0 );
thus L1177: thesis by L1176 , L1174 , L1175 , L1082;
end;
theorem
L1178: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B222 being (State of ( SCM+FSA )) holds (for B223 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B224 being  read-write Int-Location holds (((not B223 destroy B224) & ( B222 . ( intloc ( 0 ) ) ) = 1) implies (( Times (B224 , B223) ) is_closed_on B222 , R9 & ( Times (B224 , B223) ) is_halting_on B222 , R9))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C266 being (State of ( SCM+FSA ));
let C267 being  good  InitHalting (Program of ( SCM+FSA ));
let C268 being  read-write Int-Location;
assume L1179: (not C267 destroy C268);
assume L1180: ( C266 . ( intloc ( 0 ) ) ) = 1;
per cases ;
suppose L1181: ( C266 . C268 ) > ( 0 );

L1182: ( Directed ( loop ( if=0 (C268 , ( Goto 2 ) , ( C267 ";" ( SubFrom (C268 , ( intloc ( 0 ) )) ) )) ) ) ) = ( loop ( if=0 (C268 , ( Goto 2 ) , ( C267 ";" ( SubFrom (C268 , ( intloc ( 0 ) )) ) )) ) ) by SCMFSA6A:22;
L1183: ( Directed ( loop ( if=0 (C268 , ( Goto 2 ) , ( C267 ";" ( SubFrom (C268 , ( intloc ( 0 ) )) ) )) ) ) ) is_pseudo-closed_on C266 , R9 by L1182 , L1179 , L1180 , L1181 , L1082;
thus L1184: thesis by L1183 , L1181 , SCMFSA8C:39;
end;
suppose L1185: ( C266 . C268 ) <= ( 0 );

L1186: (( Stop ( SCM+FSA ) ) is_closed_on C266 , R9 & ( Stop ( SCM+FSA ) ) is_halting_on C266 , R9) by SCMFSA7B:18 , SCMFSA7B:19;
thus L1187: thesis by L1186 , L1185 , SCMFSA8B:21;
end;
end;
theorem
L1189: (for B225 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B226 being  read-write Int-Location holds ((not B225 destroy B226) implies ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) is ( Times (B226 , B225) ) -halted)))
proof
let C269 being  good  InitHalting (Program of ( SCM+FSA ));
let C270 being  read-write Int-Location;
assume L1190: (not C269 destroy C270);
L1191:
now
let C271 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
per cases ;
suppose L1192: ( C271 . C270 ) > ( 0 );

L1193: ( ( Initialized C271 ) . C270 ) > ( 0 ) by L1192 , SCMFSA_M:37;
L1194: (( ( Initialized C271 ) . ( intloc ( 0 ) ) ) = 1 & ( Directed ( loop ( if=0 (C270 , ( Goto 2 ) , ( C269 ";" ( SubFrom (C270 , ( intloc ( 0 ) )) ) )) ) ) ) = ( loop ( if=0 (C270 , ( Goto 2 ) , ( C269 ";" ( SubFrom (C270 , ( intloc ( 0 ) )) ) )) ) )) by SCMFSA6A:22 , SCMFSA_M:9;
L1195: ( Directed ( loop ( if=0 (C270 , ( Goto 2 ) , ( C269 ";" ( SubFrom (C270 , ( intloc ( 0 ) )) ) )) ) ) ) is_pseudo-closed_on ( Initialized C271 ) , R9 by L1194 , L1190 , L1193 , L1082;
thus L1196: ( Times (C270 , C269) ) is_halting_on ( Initialized C271 ) , R9 by L1195 , L1193 , SCMFSA8C:39;
end;
suppose L1197: ( C271 . C270 ) <= ( 0 );

L1198: (( Stop ( SCM+FSA ) ) is_closed_on ( Initialized C271 ) , R9 & ( Stop ( SCM+FSA ) ) is_halting_on ( Initialized C271 ) , R9) by SCMFSA7B:18 , SCMFSA7B:19;
L1199: ( ( Initialized C271 ) . C270 ) <= ( 0 ) by L1197 , SCMFSA_M:37;
thus L1200: ( Times (C270 , C269) ) is_halting_on ( Initialized C271 ) , R9 by L1199 , L1198 , SCMFSA8B:21;
end;
end;
thus L1202: thesis by L1191 , SCMFSA8C:6;
end;
registration
let C272 being  read-write Int-Location;
let C273 being  good (Program of ( SCM+FSA ));
cluster ( Times (C272 , C273) ) ->  good;
coherence;
end;
theorem
L1204: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B227 being (State of ( SCM+FSA )) holds (for B228 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B229 being  read-write Int-Location holds (((not B228 destroy B229) & ( B227 . B229 ) > ( 0 )) implies (ex B230 being (State of ( SCM+FSA )) st (ex B231 being (Instruction-Sequence of ( SCM+FSA )) st (ex B232 being (Element of ( NAT )) st (B230 = ( Initialized B227 ) & B231 = ( R9 +* ( loop ( if=0 (B229 , ( Goto 2 ) , ( B228 ";" ( SubFrom (B229 , ( intloc ( 0 ) )) ) )) ) ) ) & B232 = ( ( LifeSpan (( R9 +* ( if=0 (B229 , ( Goto 2 ) , ( B228 ";" ( SubFrom (B229 , ( intloc ( 0 ) )) ) )) ) ) , ( Initialized B227 )) ) + 1 ) & ( ( Comput (B231 , B230 , B232) ) . B229 ) = ( ( B227 . B229 ) - 1 ) & ( ( Comput (B231 , B230 , B232) ) . ( intloc ( 0 ) ) ) = 1 & (for B233 being  read-write Int-Location holds (B233 <> B229 implies ( ( Comput (B231 , B230 , B232) ) . B233 ) = ( ( IExec (B228 , R9 , B227) ) . B233 ))) & (for B234 being FinSeq-Location holds ( ( Comput (B231 , B230 , B232) ) . B234 ) = ( ( IExec (B228 , R9 , B227) ) . B234 )) & ( IC ( Comput (B231 , B230 , B232) ) ) = ( 0 ) & (for B235 being (Element of ( NAT )) holds (B235 <= B232 implies ( IC ( Comput (B231 , B230 , B235) ) ) in ( dom ( loop ( if=0 (B229 , ( Goto 2 ) , ( B228 ";" ( SubFrom (B229 , ( intloc ( 0 ) )) ) )) ) ) ))))))))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C274 being (State of ( SCM+FSA ));
let C275 being  good  InitHalting (Program of ( SCM+FSA ));
let C276 being  read-write Int-Location;
assume L1205: (not C275 destroy C276);
reconsider D182 = ( C275 ";" ( SubFrom (C276 , ( intloc ( 0 ) )) ) ) as  InitHalting (Program of ( SCM+FSA ));
set D183 = ( if=0 (C276 , ( Goto 2 ) , ( C275 ";" ( SubFrom (C276 , ( intloc ( 0 ) )) ) )) );
assume L1206: ( C274 . C276 ) > ( 0 );
set D184 = ( Initialized ( Initialized C274 ) );
take D185 = ( Initialized C274 );
take D186 = ( R9 +* ( loop D183 ) );
set D187 = ( Initialized C274 );
set D188 = ( R9 +* D183 );
take D189 = ( ( LifeSpan (D188 , D187) ) + 1 );
thus L1207: (D185 = ( Initialized C274 ) & D186 = ( R9 +* ( loop D183 ) ) & D189 = ( ( LifeSpan (( R9 +* ( if=0 (C276 , ( Goto 2 ) , ( C275 ";" ( SubFrom (C276 , ( intloc ( 0 ) )) ) )) ) ) , ( Initialized C274 )) ) + 1 ));
L1208: D184 = ( C274 +* ( ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) +* D1 ) ) by FUNCT_4:93
.= ( Initialize ( Initialized C274 ) ) by FUNCT_4:14;
L1209: D182 is_halting_onInit C274 , R9 by L715;
L1210: D182 is_halting_on ( Initialized C274 ) , R9 by L1209 , L771;
L1211: D182 is_closed_onInit C274 , R9 by L699;
L1212: ( IExec (D183 , R9 , C274) ) = ( ( IExec (D182 , R9 , C274) ) +* ( Start-At (( ( ( card ( Goto 2 ) ) + ( card D182 ) ) + 3 ) , ( SCM+FSA )) ) ) by L1211 , L1206 , L1209 , L802;
L1213: ( ( IExec (D183 , R9 , C274) ) . C276 ) = ( ( IExec (D182 , R9 , C274) ) . C276 ) by L1212 , SCMFSA_3:3;
L1214: (D182 is_closed_onInit C274 , R9 & D182 is_halting_onInit C274 , R9) by L699 , L715;
L1215: (D183 is_closed_onInit C274 , R9 & D183 is_halting_onInit C274 , R9) by L1214 , L1206 , L793;
L1216: ( Comput (D186 , D185 , ( ( LifeSpan (D188 , D187) ) + 1 )) ) = ( Following (D186 , ( Comput (D186 , D185 , ( LifeSpan (D188 , D187) )) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D186 , ( Comput (D186 , D185 , ( LifeSpan (D188 , D187) )) )) ) , ( Comput (D186 , D185 , ( LifeSpan (D188 , D187) )) )) );
L1217: ( Comput (D186 , D185 , ( ( LifeSpan (D188 , D187) ) + 1 )) ) = ( Exec (( goto ( 0 ) ) , ( Comput (D186 , D185 , ( LifeSpan (D188 , D187) )) )) ) by L1216 , L1215 , L1062;
L1218: (D182 is_closed_onInit C274 , R9 & D182 is_halting_onInit C274 , R9) by L699 , L715;
L1219: D183 is_closed_onInit C274 , R9 by L1218 , L1206 , L793;
L1220: D183 is_closed_on ( Initialized C274 ) , R9 by L1219 , L764;
L1221: D183 is_halting_onInit C274 , R9 by L1206 , L1218 , L793;
L1222: D183 is_halting_on ( Initialized C274 ) , R9 by L1221 , L771;
L1223: ( Comput (( R9 +* D183 ) , D184 , ( LifeSpan (( R9 +* D183 ) , D184) )) ) = ( Comput (( R9 +* ( loop D183 ) ) , D184 , ( LifeSpan (( R9 +* D183 ) , D184) )) ) by L1215 , L1022;
L1224: ( ( Comput (D186 , D185 , ( ( LifeSpan (D188 , D187) ) + 1 )) ) . C276 ) = ( ( Comput (( R9 +* D183 ) , D184 , ( LifeSpan (( R9 +* D183 ) , D184) )) ) . C276 ) by L1223 , L1217 , SCMFSA_2:69
.= ( ( IExec (D183 , R9 , C274) ) . C276 ) by L1208 , L1222 , SCMFSA8C:58;
thus L1225: ( ( Comput (D186 , D185 , D189) ) . C276 ) = ( ( Comput (( R9 +* D182 ) , ( Initialize ( Initialized C274 ) ) , ( LifeSpan (( R9 +* D182 ) , ( Initialize ( Initialized C274 ) )) )) ) . C276 ) by L1224 , L1210 , L1213 , SCMFSA8C:58
.= ( ( C274 . C276 ) - 1 ) by L1205 , L989;
L1226: ( ( Comput (D186 , D185 , ( ( LifeSpan (D188 , D187) ) + 1 )) ) . ( intloc ( 0 ) ) ) = ( ( Comput (( R9 +* D183 ) , D184 , ( LifeSpan (( R9 +* D183 ) , D184) )) ) . ( intloc ( 0 ) ) ) by L1223 , L1217 , SCMFSA_2:69
.= 1 by L1222 , L1220 , L1208 , SCMFSA8C:67;
thus L1227: ( ( Comput (D186 , D185 , D189) ) . ( intloc ( 0 ) ) ) = 1 by L1226;
thus L1228:now
let C277 being  read-write Int-Location;
assume L1229: C277 <> C276;
thus L1230: ( ( Comput (D186 , D185 , D189) ) . C277 ) = ( ( Comput (( R9 +* D183 ) , D184 , ( LifeSpan (( R9 +* D183 ) , D184) )) ) . C277 ) by L1223 , L1217 , SCMFSA_2:69
.= ( ( IExec (D183 , R9 , C274) ) . C277 ) by L1208 , L1222 , SCMFSA8C:58
.= ( ( IExec (D182 , R9 , C274) ) . C277 ) by L1212 , SCMFSA_3:3
.= ( ( Exec (( SubFrom (C276 , ( intloc ( 0 ) )) ) , ( IExec (C275 , R9 , C274) )) ) . C277 ) by L684
.= ( ( IExec (C275 , R9 , C274) ) . C277 ) by L1229 , SCMFSA_2:65;
end;
thus L1231:now
let C278 being FinSeq-Location;
thus L1232: ( ( Comput (D186 , D185 , D189) ) . C278 ) = ( ( Comput (( R9 +* D183 ) , D184 , ( LifeSpan (( R9 +* D183 ) , D184) )) ) . C278 ) by L1223 , L1217 , SCMFSA_2:69
.= ( ( IExec (D183 , R9 , C274) ) . C278 ) by L1208 , L1222 , SCMFSA8C:58
.= ( ( IExec (D182 , R9 , C274) ) . C278 ) by L1212 , SCMFSA_3:4
.= ( ( Exec (( SubFrom (C276 , ( intloc ( 0 ) )) ) , ( IExec (C275 , R9 , C274) )) ) . C278 ) by L690
.= ( ( IExec (C275 , R9 , C274) ) . C278 ) by SCMFSA_2:65;
end;
thus L1233: ( IC ( Comput (D186 , D185 , D189) ) ) = ( 0 ) by L1217 , SCMFSA_2:69;
L1234: ( IC ( Comput (D186 , D185 , ( ( LifeSpan (D188 , D187) ) + 1 )) ) ) = ( 0 ) by L1217 , SCMFSA_2:69;
thus L1235:now
let C279 being (Element of ( NAT ));
assume L1236: C279 <= D189;
per cases  by L1236 , NAT_1:8;
suppose L1237: C279 <= ( LifeSpan (D188 , D187) );

L1238: (D182 is_closed_onInit C274 , R9 & D182 is_halting_onInit C274 , R9) by L699 , L715;
L1239: D183 is_closed_onInit C274 , R9 by L1238 , L1206 , L793;
L1240: D183 is_halting_onInit C274 , R9 by L1206 , L1238 , L793;
L1241: ( IC ( Comput (D186 , D185 , C279) ) ) = ( IC ( Comput (D188 , D187 , C279) ) ) by L1240 , L1237 , L1239 , L1022;
L1242: ( IC ( Comput (D188 , D187 , C279) ) ) in ( dom D183 ) by L1239 , L696;
thus L1243: ( IC ( Comput (D186 , D185 , C279) ) ) in ( dom ( loop D183 ) ) by L1242 , L1241 , FUNCT_4:99;
end;
suppose L1244: C279 = ( ( LifeSpan (D188 , D187) ) + 1 );

L1245: ( card D183 ) = ( ( ( card ( Goto 2 ) ) + ( card D182 ) ) + 4 ) by SCMFSA8B:11
.= ( ( ( card D182 ) + 1 ) + 4 ) by SCMFSA8A:15
.= ( ( ( card D182 ) + 3 ) + 2 );
L1246: ( card ( loop D183 ) ) = ( card ( dom ( loop D183 ) ) ) by CARD_1:62
.= ( card ( dom D183 ) ) by FUNCT_4:99
.= ( card D183 ) by CARD_1:62;
thus L1247: ( IC ( Comput (D186 , D185 , C279) ) ) in ( dom ( loop D183 ) ) by L1246 , L1234 , L1244 , L1245 , AFINSQ_1:66;
end;
end;
end;
theorem
L1236: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B236 being (State of ( SCM+FSA )) holds (for B237 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B238 being  read-write Int-Location holds ((( B236 . ( intloc ( 0 ) ) ) = 1 & ( B236 . B238 ) <= ( 0 )) implies ( DataPart ( IExec (( Times (B238 , B237) ) , R9 , B236) ) ) = ( DataPart B236 ))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C280 being (State of ( SCM+FSA ));
let C281 being  good  InitHalting (Program of ( SCM+FSA ));
let C282 being  read-write Int-Location;
assume L1237: ( C280 . ( intloc ( 0 ) ) ) = 1;
set D190 = ( Initialized C280 );
set D191 = R9;
L1238: (( Stop ( SCM+FSA ) ) is_closed_on D190 , D191 & ( Stop ( SCM+FSA ) ) is_halting_on D190 , D191) by SCMFSA7B:18 , SCMFSA7B:19;
L1239: ((for B239 being  read-write Int-Location holds ( D190 . B239 ) = ( C280 . B239 )) & (for B240 being FinSeq-Location holds ( D190 . B240 ) = ( C280 . B240 ))) by SCMFSA_M:37;
L1240: ( D190 . ( intloc ( 0 ) ) ) = 1 by SCMFSA_M:9;
assume L1241: ( C280 . C282 ) <= ( 0 );
L1242: ( ( Initialized C280 ) . C282 ) <= ( 0 ) by L1241 , SCMFSA_M:37;
L1243: ( IExec (( ( Stop ( SCM+FSA ) ) ";" ( Stop ( SCM+FSA ) ) ) , D191 , D190) ) = ( IncIC (( IExec (( Stop ( SCM+FSA ) ) , D191 , ( IExec (( Stop ( SCM+FSA ) ) , D191 , D190) )) ) , ( card ( Stop ( SCM+FSA ) ) )) ) by SCMFSA6B:20;
L1244: ( DataPart ( IExec (( Stop ( SCM+FSA ) ) , D191 , D190) ) ) = ( DataPart ( Initialized D190 ) ) by SCMFSA8C:14
.= ( DataPart D190 );
L1245: (( Stop ( SCM+FSA ) ) is_closed_on ( Initialized C280 ) , R9 & ( Stop ( SCM+FSA ) ) is_halting_on ( Initialized C280 ) , R9) by SCMFSA7B:18 , SCMFSA7B:19;
L1246: (( Times (C282 , C281) ) is_closed_on ( Initialized C280 ) , R9 & ( Times (C282 , C281) ) is_halting_on ( Initialized C280 ) , R9) by L1245 , L1242 , SCMFSA8B:21;
L1247: ( DataPart ( IExec (( Times (C282 , C281) ) , R9 , C280) ) ) = ( DataPart ( IExec (( Times (C282 , C281) ) , D191 , D190) ) ) by L1246 , L1240 , L1239 , SCMFSA8C:19
.= ( DataPart ( IExec (( ( Stop ( SCM+FSA ) ) ";" ( Stop ( SCM+FSA ) ) ) , D191 , D190) ) ) by L1242 , L1238 , L1240 , SCMFSA8A:23 , SCMFSA8C:44;
thus L1248: ( DataPart ( IExec (( Times (C282 , C281) ) , R9 , C280) ) ) = ( DataPart ( IExec (( Stop ( SCM+FSA ) ) , D191 , ( IExec (( Stop ( SCM+FSA ) ) , D191 , D190) )) ) ) by L1247 , L1243 , MEMSTR_0:79
.= ( DataPart ( IExec (( Stop ( SCM+FSA ) ) , D191 , D190) ) ) by L1245 , L1240 , L1244 , SCMFSA8C:20
.= ( DataPart C280 ) by L1237 , L1244 , SCMFSA_M:19;
end;
theorem
L1249: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B241 being (State of ( SCM+FSA )) holds (for B242 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B243 being  read-write Int-Location holds (((not B242 destroy B243) & ( B241 . B243 ) > ( 0 )) implies (( ( IExec (( B242 ";" ( SubFrom (B243 , ( intloc ( 0 ) )) ) ) , R9 , B241) ) . B243 ) = ( ( B241 . B243 ) - 1 ) & ( DataPart ( IExec (( Times (B243 , B242) ) , R9 , B241) ) ) = ( DataPart ( IExec (( Times (B243 , B242) ) , R9 , ( IExec (( B242 ";" ( SubFrom (B243 , ( intloc ( 0 ) )) ) ) , R9 , B241) )) ) )))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let C283 being (State of ( SCM+FSA ));
let C284 being  good  InitHalting (Program of ( SCM+FSA ));
let C285 being  read-write Int-Location;
assume L1250: (not C284 destroy C285);
reconsider D192 = ( Macro ( SubFrom (C285 , ( intloc ( 0 ) )) ) ) as  good (Program of ( SCM+FSA ));
set D193 = ( C284 ";" ( SubFrom (C285 , ( intloc ( 0 ) )) ) );
set D194 = ( IExec (D193 , R9 , C283) );
set D195 = R9;
L1251: D193 is_closed_onInit C283 , R9 by L699;
L1252: D193 is_closed_on ( Initialized C283 ) , R9 by L1251 , L764;
L1253: D193 is_halting_onInit C283 , R9 by L715;
L1254: (D193 = ( C284 ";" D192 ) & D193 is_halting_on ( Initialized C283 ) , R9) by L1253 , L771;
L1255: ( D194 . ( intloc ( 0 ) ) ) = 1 by L1254 , L1252 , SCMFSA8C:67;
set D196 = ( if=0 (C285 , ( Goto 2 ) , ( C284 ";" ( SubFrom (C285 , ( intloc ( 0 ) )) ) )) );
set D197 = ( Initialized C283 );
set D198 = R9;
assume L1256: ( C283 . C285 ) > ( 0 );
L1257: ( D197 . C285 ) > ( 0 ) by L1256 , SCMFSA_M:37;
consider C286 being (State of ( SCM+FSA )), C287 being (Instruction-Sequence of ( SCM+FSA )), C288 being (Element of ( NAT )) such that L1258: C286 = ( Initialized D197 ) and L1259: C287 = ( D198 +* ( loop D196 ) ) and L1260: C288 = ( ( LifeSpan (( D198 +* D196 ) , ( D197 +* D2 )) ) + 1 ) and L1261: ( ( Comput (C287 , C286 , C288) ) . C285 ) = ( ( D197 . C285 ) - 1 ) and L1262: ( ( Comput (C287 , C286 , C288) ) . ( intloc ( 0 ) ) ) = 1 and L1263: (for B244 being  read-write Int-Location holds (B244 <> C285 implies ( ( Comput (C287 , C286 , C288) ) . B244 ) = ( ( IExec (C284 , D198 , D197) ) . B244 ))) and L1264: (for B245 being FinSeq-Location holds ( ( Comput (C287 , C286 , C288) ) . B245 ) = ( ( IExec (C284 , D198 , D197) ) . B245 )) and L1265: ( IC ( Comput (C287 , C286 , C288) ) ) = ( 0 ) and L1266: (for B246 being (Element of ( NAT )) holds (B246 <= C288 implies ( IC ( Comput (C287 , C286 , B246) ) ) in ( dom ( loop D196 ) ))) by L1257 , L1250 , L1204;
L1267: ( loop D196 ) c= C287 by L1259 , FUNCT_4:25;
L1268:
now
let C289 being FinSeq-Location;
thus L1269: ( ( Comput (C287 , C286 , C288) ) . C289 ) = ( ( IExec (C284 , D198 , D197) ) . C289 ) by L1264
.= ( ( Exec (( SubFrom (C285 , ( intloc ( 0 ) )) ) , ( IExec (C284 , D198 , D197) )) ) . C289 ) by SCMFSA_2:65
.= ( ( IExec (D193 , D198 , D197) ) . C289 ) by L690
.= ( ( IExec (D193 , R9 , C283) ) . C289 ) by SCMFSA8C:3;
end;
L1270: ( Initialize D197 ) = ( ( D197 +* D2 ) +* D1 ) by FUNCT_4:93
.= ( D197 +* ( D2 +* D1 ) ) by FUNCT_4:14
.= C286 by L1258 , FUNCT_4:93;
thus L1271: ( D194 . C285 ) = ( ( Exec (( SubFrom (C285 , ( intloc ( 0 ) )) ) , ( IExec (C284 , R9 , C283) )) ) . C285 ) by L684
.= ( ( ( IExec (C284 , R9 , C283) ) . C285 ) - ( ( IExec (C284 , R9 , C283) ) . ( intloc ( 0 ) ) ) ) by SCMFSA_2:65
.= ( ( ( IExec (C284 , R9 , C283) ) . C285 ) - 1 ) by L187
.= ( ( D197 . C285 ) - 1 ) by L1250 , L985
.= ( ( C283 . C285 ) - 1 ) by SCMFSA_M:37;
L1272:
now
let C290 being Int-Location;
per cases ;
suppose L1273: C290 = ( intloc ( 0 ) );

thus L1274: ( ( Comput (C287 , C286 , C288) ) . C290 ) = ( ( IExec (D193 , R9 , C283) ) . C290 ) by L1273 , L1262 , L1254 , L1252 , SCMFSA8C:67;
end;
suppose L1275: C290 = C285;

thus L1276: ( ( Comput (C287 , C286 , C288) ) . C290 ) = ( ( IExec (D193 , R9 , C283) ) . C290 ) by L1275 , L1261 , L1271 , SCMFSA_M:37;
end;
suppose L1277: (C290 <> C285 & C290 <> ( intloc ( 0 ) ));

reconsider D199 = C290 as  read-write Int-Location by L1277 , SCMFSA_M:def 2;
thus L1278: ( ( Comput (C287 , C286 , C288) ) . C290 ) = ( ( IExec (C284 , D198 , D197) ) . D199 ) by L1263 , L1277
.= ( ( Exec (( SubFrom (C285 , ( intloc ( 0 ) )) ) , ( IExec (C284 , D198 , D197) )) ) . C290 ) by L1277 , SCMFSA_2:65
.= ( ( IExec (D193 , D198 , D197) ) . C290 ) by L684
.= ( ( IExec (D193 , R9 , C283) ) . C290 ) by SCMFSA8C:3;
end;
end;
L1280: ( DataPart ( Comput (C287 , C286 , C288) ) ) = ( DataPart D194 ) by L1272 , L1268 , SCMFSA_M:2;
set D200 = ( Initialize D197 );
set D201 = ( D198 +* ( ( loop D196 ) ";" ( Stop ( SCM+FSA ) ) ) );
set D202 = ( Initialized D194 );
set D203 = ( Initialize D202 );
set D204 = ( D195 +* ( ( loop D196 ) ";" ( Stop ( SCM+FSA ) ) ) );
L1281: ( 0 ) in ( dom D196 ) by SCMFSA8C:25;
L1282: ( 0 ) in ( dom ( loop D196 ) ) by L1281 , FUNCT_4:99;
L1283: ( D197 . ( intloc ( 0 ) ) ) = 1 by SCMFSA_M:9;
L1284: ( loop D196 ) is_pseudo-closed_on D197 , D198 by L1283 , L1250 , L1257 , L1082;
L1285: ( Directed ( loop D196 ) ) = ( loop D196 ) by SCMFSA6A:22;
L1286: ( Directed ( loop D196 ) ) is_pseudo-closed_on D197 , D198 by L1285 , L1250 , L1283 , L1257 , L1082;
L1287: ( DataPart ( IExec (( Times (C285 , C284) ) , D198 , D197) ) ) = ( DataPart ( IExec (( ( loop D196 ) ";" ( Stop ( SCM+FSA ) ) ) , D198 , D197) ) ) by L1250 , L1283 , L1257 , L1285 , L1082 , SCMFSA8C:40;
per cases ;
suppose L1288: ( D194 . C285 ) = ( 0 );

L1289: ( D196 . ( ( card D193 ) + 3 ) ) = ( goto ( ( card D193 ) + 5 ) ) by SCMFSA8C:36;
L1290: ( ( card D193 ) + ( 3 + 2 ) ) = ( ( ( card D193 ) + 1 ) + 4 )
.= ( ( ( card ( Goto 2 ) ) + ( card D193 ) ) + 4 ) by SCMFSA8A:15
.= ( card D196 ) by SCMFSA8B:11
.= ( card ( dom D196 ) ) by CARD_1:62
.= ( card ( dom ( loop D196 ) ) ) by FUNCT_4:99
.= ( card ( loop D196 ) ) by CARD_1:62;
L1291: ( ( ( card D193 ) + 3 ) + ( 0 ) ) < ( card ( loop D196 ) ) by L1290 , XREAL_1:6;
L1292: ( ( card D193 ) + 3 ) in ( dom ( loop D196 ) ) by L1291 , AFINSQ_1:66;
L1293: ( C287 . ( ( card D193 ) + 3 ) ) = ( ( loop D196 ) . ( ( card D193 ) + 3 ) ) by L1292 , L1267 , GRFUNC_1:2;
L1294: ( C287 . ( ( card D193 ) + 3 ) ) = ( goto ( ( card D193 ) + 5 ) ) by L1293 , L1289 , FUNCT_4:105;
L1295: ( C287 . ( 0 ) ) = ( ( loop D196 ) . ( 0 ) ) by L1282 , L1267 , GRFUNC_1:2;
L1296: ( Comput (C287 , C286 , ( C288 + 1 )) ) = ( Following (C287 , ( Comput (C287 , C286 , C288) )) ) by EXTPRO_1:3
.= ( Exec (( C287 . ( 0 ) ) , ( Comput (C287 , C286 , C288) )) ) by L1265 , PBOOLE:143;
L1297: ( D196 . ( 0 ) ) = ( C285 =0_goto ( ( card D193 ) + 3 ) ) by SCMFSA8C:26;
L1298: ( C287 . ( 0 ) ) = ( C285 =0_goto ( ( card D193 ) + 3 ) ) by L1295 , L1297 , FUNCT_4:105;
L1299: ( InsCode ( C287 . ( 0 ) ) ) = 7 by L1298 , SCMFSA_2:24;
L1300: ( InsCode ( C287 . ( 0 ) ) ) in { ( 0 ) , 6 , 7 , 8 } by L1299 , ENUMSET1:def 2;
L1301: ( DataPart ( Comput (C287 , C286 , C288) ) ) = ( DataPart ( Comput (C287 , C286 , ( C288 + 1 )) ) ) by L1300 , L1296 , SCMFSA8C:12;
L1302: ( ( Comput (C287 , C286 , C288) ) . C285 ) = ( 0 ) by L1261 , L1271 , L1288 , SCMFSA_M:37;
L1303: ( IC ( Comput (C287 , C286 , ( C288 + 1 )) ) ) = ( ( card D193 ) + 3 ) by L1302 , L1296 , L1298 , SCMFSA_2:70;
L1304:
now
let C291 being (Element of ( NAT ));
assume L1305: (not ( IC ( Comput (C287 , C286 , C291) ) ) in ( dom ( loop D196 ) ));
L1306: C288 < C291 by L1305 , L1266;
L1307: ( C288 + 1 ) <= C291 by L1306 , INT_1:7;
L1308: ( C288 + 1 ) < C291 by L1307 , L1303 , L1292 , L1305 , XXREAL_0:1;
L1309: ( ( C288 + 1 ) + 1 ) <= C291 by L1308 , INT_1:7;
thus L1310: ( C288 + ( 1 + 1 ) ) <= C291 by L1309;
end;
L1311: ( C287 /. ( IC ( Comput (C287 , C286 , ( C288 + 1 )) ) ) ) = ( C287 . ( IC ( Comput (C287 , C286 , ( C288 + 1 )) ) ) ) by PBOOLE:143;
L1312: ( Comput (C287 , C286 , ( C288 + ( 1 + 1 ) )) ) = ( Comput (C287 , C286 , ( ( C288 + 1 ) + 1 )) )
.= ( Following (C287 , ( Comput (C287 , C286 , ( C288 + 1 )) )) ) by EXTPRO_1:3
.= ( Exec (( C287 . ( ( card D193 ) + 3 ) ) , ( Comput (C287 , C286 , ( C288 + 1 )) )) ) by L1302 , L1296 , L1298 , L1311 , SCMFSA_2:70;
L1313: ( IC ( Comput (( D198 +* ( loop D196 ) ) , ( Initialize D197 ) , ( C288 + 2 )) ) ) = ( card ( loop D196 ) ) by L1312 , L1259 , L1270 , L1290 , L1294 , SCMFSA_2:69;
L1314: ( C288 + 2 ) = ( pseudo-LifeSpan (D197 , D198 , ( loop D196 )) ) by L1313 , L1259 , L1270 , L1284 , L1304 , SCMFSA8A:def 4;
L1315: ( InsCode ( C287 . ( ( card D193 ) + 3 ) ) ) = 6 by L1294 , SCMFSA_2:23;
L1316: ( InsCode ( C287 . ( ( card D193 ) + 3 ) ) ) in { ( 0 ) , 6 , 7 , 8 } by L1315 , ENUMSET1:def 2;
L1317: ( DataPart ( Comput (C287 , C286 , C288) ) ) = ( DataPart ( Comput (C287 , C286 , ( C288 + 2 )) ) ) by L1316 , L1301 , L1312 , SCMFSA8C:12;
L1318: D200 = ( C283 +* ( D2 +* D1 ) ) by FUNCT_4:14
.= ( Initialized C283 ) by FUNCT_4:93;
L1319: C286 = ( D197 +* ( D2 +* D1 ) ) by L1258 , FUNCT_4:93
.= ( ( D197 +* D2 ) +* D1 ) by FUNCT_4:14
.= ( D197 +* D1 ) by FUNCT_4:93;
thus L1320: ( DataPart ( IExec (( Times (C285 , C284) ) , R9 , C283) ) ) = ( DataPart ( IExec (( Times (C285 , C284) ) , D198 , D197) ) ) by SCMFSA8C:3
.= ( DataPart ( IExec (( ( loop D196 ) ";" ( Stop ( SCM+FSA ) ) ) , R9 , C283) ) ) by L1287 , SCMFSA8C:3
.= ( DataPart ( Result (D201 , D200) ) ) by L1318 , SCMFSA6B:def 1
.= ( DataPart ( IExec (D193 , R9 , C283) ) ) by L1280 , L1317 , L1319 , L1285 , L1250 , L1283 , L1257 , L1082 , L1259 , L1314 , SCMFSA8C:30
.= ( DataPart ( IExec (( Times (C285 , C284) ) , R9 , ( IExec (D193 , R9 , C283) )) ) ) by L1255 , L1288 , L1236;
end;
suppose L1321: ( D194 . C285 ) <> ( 0 );

L1322: ( C283 . C285 ) >= ( ( 0 ) + 1 ) by L1256 , INT_1:7;
L1323: ( D194 . C285 ) > ( 0 ) by L1322 , L1271 , L1321 , XREAL_1:19;
L1324: C288 < ( pseudo-LifeSpan (D197 , D198 , ( loop D196 )) ) by L1266 , L1259 , L1283 , L1270 , L1250 , L1257 , L1082 , SCMFSA8C:1;
L1325: ( DataPart ( Comput (D201 , D200 , C288) ) ) = ( DataPart D194 ) by L1324 , L1285 , L1286 , L1280 , L1270 , L1259 , SCMFSA8C:29;
L1326:
now
L1327: ( DataPart D202 ) = ( ( DataPart D202 ) +* ( {} ) )
.= ( ( DataPart D202 ) +* ( DataPart D1 ) ) by MEMSTR_0:20
.= ( DataPart D203 ) by FUNCT_4:71;
thus L1328:now
let C292 being Int-Location;
per cases ;
suppose L1329: C292 = ( intloc ( 0 ) );

thus L1330: ( ( Comput (D201 , D200 , C288) ) . C292 ) = ( D194 . C292 ) by L1325 , SCMFSA_M:2
.= 1 by L1329 , L187
.= ( D202 . C292 ) by L1329 , SCMFSA_M:9
.= ( D203 . C292 ) by L1327 , SCMFSA_M:2;
end;
suppose L1331: C292 <> ( intloc ( 0 ) );

L1332: C292 is  read-write  read-write  read-write  read-write Int-Location by L1331 , SCMFSA_M:def 2;
thus L1333: ( ( Comput (D201 , D200 , C288) ) . C292 ) = ( D194 . C292 ) by L1325 , SCMFSA_M:2
.= ( D202 . C292 ) by L1332 , SCMFSA_M:37
.= ( D203 . C292 ) by L1327 , SCMFSA_M:2;
end;
end;
let C293 being FinSeq-Location;
thus L1335: ( ( Comput (D201 , D200 , C288) ) . C293 ) = ( D194 . C293 ) by L1325 , SCMFSA_M:2
.= ( D202 . C293 ) by SCMFSA_M:37
.= ( D203 . C293 ) by L1327 , SCMFSA_M:2;
end;
L1336: ( IC ( Comput (D201 , D200 , C288) ) ) = ( IC ( Comput (C287 , C286 , C288) ) ) by L1285 , L1286 , L1324 , L1259 , L1270 , SCMFSA8C:29
.= ( IC D203 ) by L1265 , FUNCT_4:113;
L1337: ( D194 . ( intloc ( 0 ) ) ) = 1 by L1254 , L1252 , SCMFSA8C:67;
L1338: ( DataPart D197 ) = ( ( DataPart D197 ) +* ( {} ) )
.= ( ( DataPart D197 ) +* ( DataPart D1 ) ) by MEMSTR_0:20
.= ( DataPart D200 ) by FUNCT_4:71;
L1339: ( Directed ( loop D196 ) ) = ( loop D196 ) by SCMFSA6A:22;
L1340: ( Directed ( loop D196 ) ) is_pseudo-closed_on D200 , D201 by L1339 , L1250 , L1283 , L1257 , L1082 , L1338 , SCMFSA8C:23;
L1341: (( ( loop D196 ) ";" ( Stop ( SCM+FSA ) ) ) is_closed_on D200 , D201 & ( ( loop D196 ) ";" ( Stop ( SCM+FSA ) ) ) is_halting_on D200 , D201) by L1340 , SCMFSA8C:29;
L1342: D200 = ( C283 +* ( D2 +* D1 ) ) by FUNCT_4:14
.= ( Initialized C283 ) by FUNCT_4:93;
L1343: D203 = ( D194 +* ( D2 +* D1 ) ) by FUNCT_4:14
.= ( Initialized D194 ) by FUNCT_4:93;
L1344: (( ( loop D196 ) ";" ( Stop ( SCM+FSA ) ) ) c= D201 & ( ( loop D196 ) ";" ( Stop ( SCM+FSA ) ) ) c= D204) by FUNCT_4:25;
L1345: ( Result (D201 , D200) ) = ( Result (D204 , D203) ) by L1341 , L1336 , L1344 , L1326 , SCMFSA8C:73 , SCMFSA_2:61;
L1346: ( DataPart ( IExec (( ( loop D196 ) ";" ( Stop ( SCM+FSA ) ) ) , D198 , D197) ) ) = ( DataPart ( IExec (( ( loop D196 ) ";" ( Stop ( SCM+FSA ) ) ) , R9 , C283) ) ) by SCMFSA8C:3
.= ( DataPart ( Result (D201 , D200) ) ) by L1342 , SCMFSA6B:def 1
.= ( DataPart ( Result (D204 , D203) ) ) by L1345
.= ( DataPart ( IExec (( ( loop D196 ) ";" ( Stop ( SCM+FSA ) ) ) , R9 , ( IExec (D193 , R9 , C283) )) ) ) by L1343 , SCMFSA6B:def 1
.= ( DataPart ( IExec (( Times (C285 , C284) ) , R9 , ( IExec (D193 , R9 , C283) )) ) ) by L1250 , L1285 , L1337 , L1323 , L1082 , SCMFSA8C:40;
thus L1347: thesis by L1346 , L1287 , SCMFSA8C:3;
end;
end;
theorem
L1349: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B247 being (State of ( SCM+FSA )) holds (for B248 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B249 being FinSeq-Location holds (for B250 being  read-write Int-Location holds (( B247 . B250 ) <= ( 0 ) implies ( ( IExec (( Times (B250 , B248) ) , R9 , B247) ) . B249 ) = ( B247 . B249 )))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
set D205 = ( Data-Locations ( SCM+FSA ) );
let C294 being (State of ( SCM+FSA ));
let C295 being  good  InitHalting (Program of ( SCM+FSA ));
let C296 being FinSeq-Location;
let C297 being  read-write Int-Location;
assume L1350: ( C294 . C297 ) <= ( 0 );
set D206 = ( Initialized C294 );
set D207 = R9;
L1351: (( D206 . C297 ) = ( C294 . C297 ) & ( D206 . ( intloc ( 0 ) ) ) = 1) by SCMFSA_M:9 , SCMFSA_M:37;
L1352: C296 in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L1353: C296 in D205 by L1352 , SCMFSA_2:100 , XBOOLE_0:def 3;
L1354: ( DataPart ( IExec (( Times (C297 , C295) ) , R9 , C294) ) ) = ( DataPart ( IExec (( Times (C297 , C295) ) , D207 , D206) ) ) by SCMFSA8C:3
.= ( DataPart D206 ) by L1350 , L1351 , L1236;
thus L1355: ( ( IExec (( Times (C297 , C295) ) , R9 , C294) ) . C296 ) = ( ( DataPart D206 ) . C296 ) by L1354 , L1353 , FUNCT_1:49
.= ( D206 . C296 ) by L1353 , FUNCT_1:49
.= ( C294 . C296 ) by SCMFSA_M:37;
end;
theorem
L1356: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B251 being (State of ( SCM+FSA )) holds (for B252 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B253 being Int-Location holds (for B254 being  read-write Int-Location holds (( B251 . B254 ) <= ( 0 ) implies ( ( IExec (( Times (B254 , B252) ) , R9 , B251) ) . B253 ) = ( ( Initialized B251 ) . B253 )))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
set D208 = ( Data-Locations ( SCM+FSA ) );
let C298 being (State of ( SCM+FSA ));
let C299 being  good  InitHalting (Program of ( SCM+FSA ));
let C300 being Int-Location;
let C301 being  read-write Int-Location;
assume L1357: ( C298 . C301 ) <= ( 0 );
set D209 = ( Initialized C298 );
set D210 = R9;
L1358: (( D209 . C301 ) = ( C298 . C301 ) & ( D209 . ( intloc ( 0 ) ) ) = 1) by SCMFSA_M:9 , SCMFSA_M:37;
L1359: C300 in ( Int-Locations ) by AMI_2:def 16;
L1360: C300 in D208 by L1359 , SCMFSA_2:100 , XBOOLE_0:def 3;
L1361: ( DataPart ( IExec (( Times (C301 , C299) ) , R9 , C298) ) ) = ( DataPart ( IExec (( Times (C301 , C299) ) , D210 , D209) ) ) by SCMFSA8C:3
.= ( DataPart D209 ) by L1357 , L1358 , L1236;
thus L1362: ( ( IExec (( Times (C301 , C299) ) , R9 , C298) ) . C300 ) = ( ( DataPart D209 ) . C300 ) by L1361 , L1360 , FUNCT_1:49
.= ( D209 . C300 ) by L1360 , FUNCT_1:49;
end;
theorem
L1363: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B255 being (State of ( SCM+FSA )) holds (for B256 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B257 being FinSeq-Location holds (for B258 being  read-write Int-Location holds (((not B256 destroy B258) & ( B255 . B258 ) > ( 0 )) implies ( ( IExec (( Times (B258 , B256) ) , R9 , B255) ) . B257 ) = ( ( IExec (( Times (B258 , B256) ) , R9 , ( IExec (( B256 ";" ( SubFrom (B258 , ( intloc ( 0 ) )) ) ) , R9 , B255) )) ) . B257 )))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
set D211 = ( Data-Locations ( SCM+FSA ) );
let C302 being (State of ( SCM+FSA ));
let C303 being  good  InitHalting (Program of ( SCM+FSA ));
let C304 being FinSeq-Location;
let C305 being  read-write Int-Location;
assume L1364: ((not C303 destroy C305) & ( C302 . C305 ) > ( 0 ));
set D212 = ( IExec (( Times (C305 , C303) ) , R9 , ( IExec (( C303 ";" ( SubFrom (C305 , ( intloc ( 0 ) )) ) ) , R9 , C302) )) );
L1365: C304 in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L1366: C304 in D211 by L1365 , SCMFSA_2:100 , XBOOLE_0:def 3;
thus L1367: ( ( IExec (( Times (C305 , C303) ) , R9 , C302) ) . C304 ) = ( ( DataPart ( IExec (( Times (C305 , C303) ) , R9 , C302) ) ) . C304 ) by L1366 , FUNCT_1:49
.= ( ( DataPart D212 ) . C304 ) by L1364 , L1249
.= ( D212 . C304 ) by L1366 , FUNCT_1:49;
end;
theorem
L1368: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for B259 being (State of ( SCM+FSA )) holds (for B260 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B261 being Int-Location holds (for B262 being  read-write Int-Location holds (((not B260 destroy B262) & ( B259 . B262 ) > ( 0 )) implies ( ( IExec (( Times (B262 , B260) ) , R9 , B259) ) . B261 ) = ( ( IExec (( Times (B262 , B260) ) , R9 , ( IExec (( B260 ";" ( SubFrom (B262 , ( intloc ( 0 ) )) ) ) , R9 , B259) )) ) . B261 )))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
set D213 = ( Data-Locations ( SCM+FSA ) );
let C306 being (State of ( SCM+FSA ));
let C307 being  good  InitHalting (Program of ( SCM+FSA ));
let C308 being Int-Location;
let C309 being  read-write Int-Location;
assume L1369: ((not C307 destroy C309) & ( C306 . C309 ) > ( 0 ));
set D214 = ( IExec (( Times (C309 , C307) ) , R9 , ( IExec (( C307 ";" ( SubFrom (C309 , ( intloc ( 0 ) )) ) ) , R9 , C306) )) );
L1370: C308 in ( Int-Locations ) by AMI_2:def 16;
L1371: C308 in D213 by L1370 , SCMFSA_2:100 , XBOOLE_0:def 3;
thus L1372: ( ( IExec (( Times (C309 , C307) ) , R9 , C306) ) . C308 ) = ( ( DataPart ( IExec (( Times (C309 , C307) ) , R9 , C306) ) ) . C308 ) by L1371 , FUNCT_1:49
.= ( ( DataPart D214 ) . C308 ) by L1369 , L1249
.= ( D214 . C308 ) by L1371 , FUNCT_1:49;
end;
definition
let C310 being (Instruction of ( SCM+FSA ));
redefine attr C310 is  good
means
(not C310 destroy ( intloc ( 0 ) ));
compatibility
proof
L1373: ( rng ( Macro C310 ) ) = { C310 , ( halt ( SCM+FSA ) ) } by COMPOS_1:67;
L1374: C310 in ( rng ( Macro C310 ) ) by L1373 , TARSKI:def 2;
L1375: ((not ( Macro C310 ) destroy ( intloc ( 0 ) )) implies (not C310 destroy ( intloc ( 0 ) ))) by L1374 , SCMFSA7B:def 4;
L1376: ((not C310 destroy ( intloc ( 0 ) )) implies (not ( Macro C310 ) destroy ( intloc ( 0 ) ))) by SCMFSA8C:48;
L1377: (( Macro C310 ) is  good iff C310 is  good) by SFMASTR1:def 1;
thus L1378: (C310 is  good iff (not C310 destroy ( intloc ( 0 ) ))) by L1377 , L1376 , L1375 , SCMFSA7B:def 5;
end;
end;
