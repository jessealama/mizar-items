:: From Double Loops to Fields
::  by Wojciech Skaba and Micha{\l} Muzalewski
::
:: Received September 27, 1990
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, ALGSTR_0, CARD_1, SUPINF_2, VECTSP_1, SUBSET_1,
      RELAT_1, REAL_1, ALGSTR_1, ARYTM_1, ARYTM_3, STRUCT_0, RLVECT_1, BINOP_1,
      LATTICES, MESFUNC1, GROUP_1, ALGSTR_2;
 notations NUMBERS, REAL_1, BINOP_2, STRUCT_0, ALGSTR_0, RLVECT_1, GROUP_1,
      VECTSP_1, ALGSTR_1;
 constructors BINOP_2, ALGSTR_1, RLVECT_1, VECTSP_1, MEMBERED;
 registrations VECTSP_1, ALGSTR_1, ALGSTR_0, REAL_1, MEMBERED;
 theorems VECTSP_1, ALGSTR_1, RLVECT_1, GROUP_1, STRUCT_0, ALGSTR_0;

begin
L1: ( 0 ) = ( 0. ( F_Real ) ) by STRUCT_0:def 6 , VECTSP_1:def 5;
L2: (for B1 , B2 being (Element of ( F_Real )) holds (B1 <> ( 0. ( F_Real ) ) implies (ex B3 being (Element of ( F_Real )) st ( B1 * B3 ) = B2)))
proof
let C1 , C2 being (Element of ( F_Real ));
assume that
L3: C1 <> ( 0. ( F_Real ) );
reconsider D1 = C1 , D2 = C2 as Real by VECTSP_1:def 5;
consider C3 being Real such that L4: ( D1 * C3 ) = D2 by L3 , L1 , ALGSTR_1:14;
reconsider D3 = C3 as (Element of ( F_Real )) by VECTSP_1:def 5;
L5: ( C1 * D3 ) = C2 by L4;
thus L6: thesis by L5;
end;
L7: (for B4 , B5 being (Element of ( F_Real )) holds (B4 <> ( 0. ( F_Real ) ) implies (ex B6 being (Element of ( F_Real )) st ( B6 * B4 ) = B5)))
proof
let C4 , C5 being (Element of ( F_Real ));
assume L8: C4 <> ( 0. ( F_Real ) );
L9: (ex B7 being (Element of ( F_Real )) st ( C4 * B7 ) = C5) by L8 , L2;
thus L10: thesis by L9;
end;
L11: ((for B8 , B9 , B10 being (Element of ( F_Real )) holds (B8 <> ( 0. ( F_Real ) ) implies (( B8 * B9 ) = ( B8 * B10 ) implies B9 = B10))) & (for B11 , B12 , B13 being (Element of ( F_Real )) holds (B11 <> ( 0. ( F_Real ) ) implies (( B12 * B11 ) = ( B13 * B11 ) implies B12 = B13)))) by VECTSP_1:5;
L12: ((for B14 being (Element of ( F_Real )) holds ( B14 * ( 0. ( F_Real ) ) ) = ( 0. ( F_Real ) )) & (for B15 being (Element of ( F_Real )) holds ( ( 0. ( F_Real ) ) * B15 ) = ( 0. ( F_Real ) ))) by VECTSP_1:12;
registration
cluster ( F_Real ) ->  multLoop_0-like;
coherence by L2 , L7 , L11 , L12 , ALGSTR_1:16;
end;
definition
let C6 being  left_add-cancelable  add-right-invertible non  empty addLoopStr;
let C7 being (Element of C6);
func - C7 -> (Element of C6) means 
:L14: ( C7 + it ) = ( 0. C6 );
existence by ALGSTR_1:def 4;
uniqueness by ALGSTR_0:def 3;
end;
definition
let C8 being  left_add-cancelable  add-right-invertible non  empty addLoopStr;
let C9 , C10 being (Element of C8);
func C9 - C10 -> (Element of C8) equals 
( C9 + ( - C10 ) );
correctness;
end;
registration
cluster  strict  Abelian  add-associative  commutative  associative  distributive non  degenerated  left_zeroed  right_zeroed  Loop-like  well-unital  multLoop_0-like for non  empty non  empty non  empty non  empty doubleLoopStr;
existence
proof
take ( F_Real );
thus L17: thesis;
end;
end;
definition
mode doubleLoop
 is  left_zeroed  right_zeroed  Loop-like  well-unital  multLoop_0-like non  empty doubleLoopStr;
end;
definition
mode leftQuasi-Field
 is  Abelian  add-associative  right-distributive non  degenerated doubleLoop;
end;
theorem
L21: (for R1 being non  empty doubleLoopStr holds (R1 is leftQuasi-Field iff ((for R2 being (Element of R1) holds ( R2 + ( 0. R1 ) ) = R2) & (for R2 being (Element of R1) holds (ex R5 being (Element of R1) st ( R2 + R5 ) = ( 0. R1 ))) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( ( R2 + R3 ) + R4 ) = ( R2 + ( R3 + R4 ) )))) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( R2 + R3 ) = ( R3 + R2 ))) & ( 0. R1 ) <> ( 1. R1 ) & (for R2 being (Element of R1) holds ( R2 * ( 1. R1 ) ) = R2) & (for R2 being (Element of R1) holds ( ( 1. R1 ) * R2 ) = R2) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (ex R5 being (Element of R1) st ( R2 * R5 ) = R3)))) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (ex R5 being (Element of R1) st ( R5 * R2 ) = R3)))) & (for R2 being (Element of R1) holds (for R5 being (Element of R1) holds (for R6 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (( R2 * R5 ) = ( R2 * R6 ) implies R5 = R6))))) & (for R2 being (Element of R1) holds (for R5 being (Element of R1) holds (for R6 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (( R5 * R2 ) = ( R6 * R2 ) implies R5 = R6))))) & (for R2 being (Element of R1) holds ( R2 * ( 0. R1 ) ) = ( 0. R1 )) & (for R2 being (Element of R1) holds ( ( 0. R1 ) * R2 ) = ( 0. R1 )) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( R2 * ( R3 + R4 ) ) = ( ( R2 * R3 ) + ( R2 * R4 ) )))))))
proof
let R1 being non  empty doubleLoopStr;
thus L22: (R1 is leftQuasi-Field implies ((for R2 being (Element of R1) holds ( R2 + ( 0. R1 ) ) = R2) & (for R2 being (Element of R1) holds (ex R5 being (Element of R1) st ( R2 + R5 ) = ( 0. R1 ))) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( ( R2 + R3 ) + R4 ) = ( R2 + ( R3 + R4 ) )))) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( R2 + R3 ) = ( R3 + R2 ))) & ( 0. R1 ) <> ( 1. R1 ) & (for R2 being (Element of R1) holds ( R2 * ( 1. R1 ) ) = R2) & (for R2 being (Element of R1) holds ( ( 1. R1 ) * R2 ) = R2) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (ex R5 being (Element of R1) st ( R2 * R5 ) = R3)))) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (ex R5 being (Element of R1) st ( R5 * R2 ) = R3)))) & (for R2 being (Element of R1) holds (for R5 being (Element of R1) holds (for R6 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (( R2 * R5 ) = ( R2 * R6 ) implies R5 = R6))))) & (for R2 being (Element of R1) holds (for R5 being (Element of R1) holds (for R6 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (( R5 * R2 ) = ( R6 * R2 ) implies R5 = R6))))) & (for R2 being (Element of R1) holds ( R2 * ( 0. R1 ) ) = ( 0. R1 )) & (for R2 being (Element of R1) holds ( ( 0. R1 ) * R2 ) = ( 0. R1 )) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( R2 * ( R3 + R4 ) ) = ( ( R2 * R3 ) + ( R2 * R4 ) )))))) by ALGSTR_1:6 , ALGSTR_1:16 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4 , STRUCT_0:def 8 , VECTSP_1:def 2 , VECTSP_1:def 6;
assume that
L23: (for R2 being (Element of R1) holds ( R2 + ( 0. R1 ) ) = R2)
and
L24: (for R2 being (Element of R1) holds (ex R5 being (Element of R1) st ( R2 + R5 ) = ( 0. R1 )))
and
L25: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( ( R2 + R3 ) + R4 ) = ( R2 + ( R3 + R4 ) ))))
and
L26: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( R2 + R3 ) = ( R3 + R2 )))
and
L27: (( 0. R1 ) <> ( 1. R1 ) & (for R2 being (Element of R1) holds ( R2 * ( 1. R1 ) ) = R2) & (for R2 being (Element of R1) holds ( ( 1. R1 ) * R2 ) = R2) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (ex R5 being (Element of R1) st ( R2 * R5 ) = R3)))) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (ex R5 being (Element of R1) st ( R5 * R2 ) = R3)))) & (for R2 being (Element of R1) holds (for R5 being (Element of R1) holds (for R6 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (( R2 * R5 ) = ( R2 * R6 ) implies R5 = R6))))) & (for R2 being (Element of R1) holds (for R5 being (Element of R1) holds (for R6 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (( R5 * R2 ) = ( R6 * R2 ) implies R5 = R6))))) & (for R2 being (Element of R1) holds ( R2 * ( 0. R1 ) ) = ( 0. R1 )) & (for R2 being (Element of R1) holds ( ( 0. R1 ) * R2 ) = ( 0. R1 )) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( R2 * ( R3 + R4 ) ) = ( ( R2 * R3 ) + ( R2 * R4 ) )))));
L28: (for R2 being (Element of R1) holds ( ( 0. R1 ) + R2 ) = R2)
proof
let R2 being (Element of R1);
thus L29: ( ( 0. R1 ) + R2 ) = ( R2 + ( 0. R1 ) ) by L26
.= R2 by L23;
end;
L30: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (ex R5 being (Element of R1) st ( R2 + R5 ) = R3)))
proof
let R2 being (Element of R1);
let R3 being (Element of R1);
consider R6 being (Element of R1) such that L31: ( R2 + R6 ) = ( 0. R1 ) by L24;
take D4 = ( R6 + R3 );
thus L32: ( R2 + D4 ) = ( ( 0. R1 ) + R3 ) by L25 , L31
.= R3 by L28;
end;
L33: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (ex R5 being (Element of R1) st ( R5 + R2 ) = R3)))
proof
let R2 being (Element of R1);
let R3 being (Element of R1);
consider R5 being (Element of R1) such that L34: ( R2 + R5 ) = R3 by L30;
take R5;
thus L35: thesis by L26 , L34;
end;
L36: (for R2 being (Element of R1) holds (for R5 being (Element of R1) holds (for R6 being (Element of R1) holds (( R2 + R5 ) = ( R2 + R6 ) implies R5 = R6))))
proof
let R2 being (Element of R1);
let R5 being (Element of R1);
let R6 being (Element of R1);
consider R7 being (Element of R1) such that L37: ( R7 + R2 ) = ( 0. R1 ) by L23 , L24 , L25 , ALGSTR_1:3;
assume L38: ( R2 + R5 ) = ( R2 + R6 );
L39: ( ( R7 + R2 ) + R5 ) = ( R7 + ( R2 + R6 ) ) by L38 , L25
.= ( ( R7 + R2 ) + R6 ) by L25;
thus L40: R5 = ( ( 0. R1 ) + R6 ) by L39 , L28 , L37
.= R6 by L28;
end;
L41: (for R2 being (Element of R1) holds (for R5 being (Element of R1) holds (for R6 being (Element of R1) holds (( R5 + R2 ) = ( R6 + R2 ) implies R5 = R6))))
proof
let R2 being (Element of R1);
let R5 being (Element of R1);
let R6 being (Element of R1);
assume L42: ( R5 + R2 ) = ( R6 + R2 );
L43: ( R2 + R5 ) = ( R6 + R2 ) by L42 , L26
.= ( R2 + R6 ) by L26;
thus L44: thesis by L43 , L36;
end;
thus L45: thesis by L41 , L23 , L25 , L26 , L27 , L28 , L30 , L33 , L36 , ALGSTR_1:6 , ALGSTR_1:16 , ALGSTR_1:def 2 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4 , STRUCT_0:def 8 , VECTSP_1:def 2 , VECTSP_1:def 6;
end;
theorem
L46: (for B16 being  Abelian  right-distributive doubleLoop holds (for B17 , B18 being (Element of B16) holds ( B17 * ( - B18 ) ) = ( - ( B17 * B18 ) )))
proof
let C11 being  Abelian  right-distributive doubleLoop;
let C12 , C13 being (Element of C11);
L47: ( ( C12 * C13 ) + ( C12 * ( - C13 ) ) ) = ( C12 * ( C13 + ( - C13 ) ) ) by VECTSP_1:def 2
.= ( C12 * ( 0. C11 ) ) by L14
.= ( 0. C11 ) by ALGSTR_1:16;
thus L48: thesis by L47 , L14;
end;
theorem
L49: (for B19 being  Abelian  left_add-cancelable  add-right-invertible non  empty addLoopStr holds (for B20 being (Element of B19) holds ( - ( - B20 ) ) = B20))
proof
let C14 being  Abelian  left_add-cancelable  add-right-invertible non  empty addLoopStr;
let C15 being (Element of C14);
L50: ( ( - C15 ) + C15 ) = ( 0. C14 ) by L14;
thus L51: thesis by L50 , L14;
end;
theorem
L52: (for B21 being  Abelian  right-distributive doubleLoop holds ( ( - ( 1. B21 ) ) * ( - ( 1. B21 ) ) ) = ( 1. B21 ))
proof
let C16 being  Abelian  right-distributive doubleLoop;
thus L53: ( ( - ( 1. C16 ) ) * ( - ( 1. C16 ) ) ) = ( - ( ( - ( 1. C16 ) ) * ( 1_ C16 ) ) ) by L46
.= ( - ( - ( 1. C16 ) ) ) by VECTSP_1:def 4
.= ( 1. C16 ) by L49;
end;
theorem
L54: (for B22 being  Abelian  right-distributive doubleLoop holds (for B23 , B24 , B25 being (Element of B22) holds ( B23 * ( B24 - B25 ) ) = ( ( B23 * B24 ) - ( B23 * B25 ) )))
proof
let C17 being  Abelian  right-distributive doubleLoop;
let C18 , C19 , C20 being (Element of C17);
thus L55: ( C18 * ( C19 - C20 ) ) = ( ( C18 * C19 ) + ( C18 * ( - C20 ) ) ) by VECTSP_1:def 2
.= ( ( C18 * C19 ) - ( C18 * C20 ) ) by L46;
end;
definition
mode rightQuasi-Field
 is  Abelian  add-associative  left-distributive non  degenerated doubleLoop;
end;
theorem
L57: (for R1 being non  empty doubleLoopStr holds (R1 is rightQuasi-Field iff ((for R2 being (Element of R1) holds ( R2 + ( 0. R1 ) ) = R2) & (for R2 being (Element of R1) holds (ex R5 being (Element of R1) st ( R2 + R5 ) = ( 0. R1 ))) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( ( R2 + R3 ) + R4 ) = ( R2 + ( R3 + R4 ) )))) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( R2 + R3 ) = ( R3 + R2 ))) & ( 0. R1 ) <> ( 1. R1 ) & (for R2 being (Element of R1) holds ( R2 * ( 1. R1 ) ) = R2) & (for R2 being (Element of R1) holds ( ( 1. R1 ) * R2 ) = R2) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (ex R5 being (Element of R1) st ( R2 * R5 ) = R3)))) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (ex R5 being (Element of R1) st ( R5 * R2 ) = R3)))) & (for R2 being (Element of R1) holds (for R5 being (Element of R1) holds (for R6 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (( R2 * R5 ) = ( R2 * R6 ) implies R5 = R6))))) & (for R2 being (Element of R1) holds (for R5 being (Element of R1) holds (for R6 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (( R5 * R2 ) = ( R6 * R2 ) implies R5 = R6))))) & (for R2 being (Element of R1) holds ( R2 * ( 0. R1 ) ) = ( 0. R1 )) & (for R2 being (Element of R1) holds ( ( 0. R1 ) * R2 ) = ( 0. R1 )) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( ( R3 + R4 ) * R2 ) = ( ( R3 * R2 ) + ( R4 * R2 ) )))))))
proof
let R1 being non  empty doubleLoopStr;
thus L58: (R1 is rightQuasi-Field implies ((for R2 being (Element of R1) holds ( R2 + ( 0. R1 ) ) = R2) & (for R2 being (Element of R1) holds (ex R5 being (Element of R1) st ( R2 + R5 ) = ( 0. R1 ))) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( ( R2 + R3 ) + R4 ) = ( R2 + ( R3 + R4 ) )))) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( R2 + R3 ) = ( R3 + R2 ))) & ( 0. R1 ) <> ( 1. R1 ) & (for R2 being (Element of R1) holds ( R2 * ( 1. R1 ) ) = R2) & (for R2 being (Element of R1) holds ( ( 1. R1 ) * R2 ) = R2) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (ex R5 being (Element of R1) st ( R2 * R5 ) = R3)))) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (ex R5 being (Element of R1) st ( R5 * R2 ) = R3)))) & (for R2 being (Element of R1) holds (for R5 being (Element of R1) holds (for R6 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (( R2 * R5 ) = ( R2 * R6 ) implies R5 = R6))))) & (for R2 being (Element of R1) holds (for R5 being (Element of R1) holds (for R6 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (( R5 * R2 ) = ( R6 * R2 ) implies R5 = R6))))) & (for R2 being (Element of R1) holds ( R2 * ( 0. R1 ) ) = ( 0. R1 )) & (for R2 being (Element of R1) holds ( ( 0. R1 ) * R2 ) = ( 0. R1 )) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( ( R3 + R4 ) * R2 ) = ( ( R3 * R2 ) + ( R4 * R2 ) )))))) by ALGSTR_1:6 , ALGSTR_1:16 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4 , STRUCT_0:def 8 , VECTSP_1:def 3 , VECTSP_1:def 6;
assume that
L59: (for R2 being (Element of R1) holds ( R2 + ( 0. R1 ) ) = R2)
and
L60: (for R2 being (Element of R1) holds (ex R5 being (Element of R1) st ( R2 + R5 ) = ( 0. R1 )))
and
L61: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( ( R2 + R3 ) + R4 ) = ( R2 + ( R3 + R4 ) ))))
and
L62: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( R2 + R3 ) = ( R3 + R2 )))
and
L63: (( 0. R1 ) <> ( 1. R1 ) & (for R2 being (Element of R1) holds ( R2 * ( 1. R1 ) ) = R2) & (for R2 being (Element of R1) holds ( ( 1. R1 ) * R2 ) = R2) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (ex R5 being (Element of R1) st ( R2 * R5 ) = R3)))) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (ex R5 being (Element of R1) st ( R5 * R2 ) = R3)))) & (for R2 being (Element of R1) holds (for R5 being (Element of R1) holds (for R6 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (( R2 * R5 ) = ( R2 * R6 ) implies R5 = R6))))) & (for R2 being (Element of R1) holds (for R5 being (Element of R1) holds (for R6 being (Element of R1) holds (R2 <> ( 0. R1 ) implies (( R5 * R2 ) = ( R6 * R2 ) implies R5 = R6))))) & (for R2 being (Element of R1) holds ( R2 * ( 0. R1 ) ) = ( 0. R1 )) & (for R2 being (Element of R1) holds ( ( 0. R1 ) * R2 ) = ( 0. R1 )) & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( ( R3 + R4 ) * R2 ) = ( ( R3 * R2 ) + ( R4 * R2 ) )))));
L64: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (ex R5 being (Element of R1) st ( R5 + R2 ) = R3)))
proof
let R2 being (Element of R1);
let R3 being (Element of R1);
consider R6 being (Element of R1) such that L65: ( R6 + R2 ) = ( 0. R1 ) by L59 , L60 , L61 , ALGSTR_1:3;
take D5 = ( R3 + R6 );
thus L66: ( D5 + R2 ) = ( R3 + ( 0. R1 ) ) by L61 , L65
.= R3 by L59;
end;
L67: (for R2 being (Element of R1) holds ( ( 0. R1 ) + R2 ) = R2)
proof
let R2 being (Element of R1);
thus L68: ( ( 0. R1 ) + R2 ) = ( R2 + ( 0. R1 ) ) by L62
.= R2 by L59;
end;
L69: (for R2 being (Element of R1) holds (for R5 being (Element of R1) holds (for R6 being (Element of R1) holds (( R2 + R5 ) = ( R2 + R6 ) implies R5 = R6))))
proof
let R2 being (Element of R1);
let R5 being (Element of R1);
let R6 being (Element of R1);
consider R7 being (Element of R1) such that L70: ( R7 + R2 ) = ( 0. R1 ) by L59 , L60 , L61 , ALGSTR_1:3;
assume L71: ( R2 + R5 ) = ( R2 + R6 );
L72: ( ( R7 + R2 ) + R5 ) = ( R7 + ( R2 + R6 ) ) by L71 , L61
.= ( ( R7 + R2 ) + R6 ) by L61;
thus L73: R5 = ( ( 0. R1 ) + R6 ) by L72 , L67 , L70
.= R6 by L67;
end;
L74: (for R2 being (Element of R1) holds (for R5 being (Element of R1) holds (for R6 being (Element of R1) holds (( R5 + R2 ) = ( R6 + R2 ) implies R5 = R6))))
proof
let R2 being (Element of R1);
let R5 being (Element of R1);
let R6 being (Element of R1);
consider R7 being (Element of R1) such that L75: ( R2 + R7 ) = ( 0. R1 ) by L60;
assume L76: ( R5 + R2 ) = ( R6 + R2 );
L77: ( R5 + ( R2 + R7 ) ) = ( ( R6 + R2 ) + R7 ) by L76 , L61
.= ( R6 + ( R2 + R7 ) ) by L61;
thus L78: R5 = ( R6 + ( 0. R1 ) ) by L77 , L59 , L75
.= R6 by L59;
end;
L79: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (ex R5 being (Element of R1) st ( R2 + R5 ) = R3)))
proof
let R2 being (Element of R1);
let R3 being (Element of R1);
consider R6 being (Element of R1) such that L80: ( R2 + R6 ) = ( 0. R1 ) by L60;
take D6 = ( R6 + R3 );
thus L81: ( R2 + D6 ) = ( ( 0. R1 ) + R3 ) by L61 , L80
.= R3 by L67;
end;
thus L82: thesis by L79 , L59 , L61 , L62 , L63 , L67 , L64 , L69 , L74 , ALGSTR_1:6 , ALGSTR_1:16 , ALGSTR_1:def 2 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4 , STRUCT_0:def 8 , VECTSP_1:def 3 , VECTSP_1:def 6;
end;
theorem
L83: (for R8 being  left-distributive doubleLoop holds (for R9 being (Element of R8) holds (for R10 being (Element of R8) holds ( ( - R10 ) * R9 ) = ( - ( R10 * R9 ) ))))
proof
let R8 being  left-distributive doubleLoop;
let R9 being (Element of R8);
let R10 being (Element of R8);
L84: ( ( R10 * R9 ) + ( ( - R10 ) * R9 ) ) = ( ( R10 + ( - R10 ) ) * R9 ) by VECTSP_1:def 3
.= ( ( 0. R8 ) * R9 ) by L14
.= ( 0. R8 ) by ALGSTR_1:16;
thus L85: thesis by L84 , L14;
end;
theorem
L86: (for B26 being  Abelian  left-distributive doubleLoop holds ( ( - ( 1. B26 ) ) * ( - ( 1. B26 ) ) ) = ( 1. B26 ))
proof
let C21 being  Abelian  left-distributive doubleLoop;
thus L87: ( ( - ( 1. C21 ) ) * ( - ( 1. C21 ) ) ) = ( - ( ( 1_ C21 ) * ( - ( 1. C21 ) ) ) ) by L83
.= ( - ( - ( 1. C21 ) ) ) by VECTSP_1:def 8
.= ( 1. C21 ) by L49;
end;
theorem
L88: (for R8 being  left-distributive doubleLoop holds (for R9 being (Element of R8) holds (for R11 being (Element of R8) holds (for R12 being (Element of R8) holds ( ( R11 - R12 ) * R9 ) = ( ( R11 * R9 ) - ( R12 * R9 ) )))))
proof
let R8 being  left-distributive doubleLoop;
let R9 being (Element of R8);
let R11 being (Element of R8);
let R12 being (Element of R8);
thus L89: ( ( R11 - R12 ) * R9 ) = ( ( R11 * R9 ) + ( ( - R12 ) * R9 ) ) by VECTSP_1:def 3
.= ( ( R11 * R9 ) - ( R12 * R9 ) ) by L83;
end;
definition
mode doublesidedQuasi-Field
 is  Abelian  add-associative  distributive non  degenerated doubleLoop;
end;
theorem
L91: (for R1 being non  empty doubleLoopStr holds (R1 is doublesidedQuasi-Field iff ((for R13 being (Element of R1) holds ( R13 + ( 0. R1 ) ) = R13) & (for R13 being (Element of R1) holds (ex R16 being (Element of R1) st ( R13 + R16 ) = ( 0. R1 ))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 + R14 ) + R15 ) = ( R13 + ( R14 + R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds ( R13 + R14 ) = ( R14 + R13 ))) & ( 0. R1 ) <> ( 1. R1 ) & (for R13 being (Element of R1) holds ( R13 * ( 1. R1 ) ) = R13) & (for R13 being (Element of R1) holds ( ( 1. R1 ) * R13 ) = R13) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R13 * R16 ) = R14)))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R16 * R13 ) = R14)))) & (for R13 being (Element of R1) holds (for R16 being (Element of R1) holds (for R17 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (( R13 * R16 ) = ( R13 * R17 ) implies R16 = R17))))) & (for R13 being (Element of R1) holds (for R16 being (Element of R1) holds (for R17 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (( R16 * R13 ) = ( R17 * R13 ) implies R16 = R17))))) & (for R13 being (Element of R1) holds ( R13 * ( 0. R1 ) ) = ( 0. R1 )) & (for R13 being (Element of R1) holds ( ( 0. R1 ) * R13 ) = ( 0. R1 )) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( R13 * ( R14 + R15 ) ) = ( ( R13 * R14 ) + ( R13 * R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R14 + R15 ) * R13 ) = ( ( R14 * R13 ) + ( R15 * R13 ) )))))))
proof
let R1 being non  empty doubleLoopStr;
thus L92: (R1 is doublesidedQuasi-Field implies ((for R13 being (Element of R1) holds ( R13 + ( 0. R1 ) ) = R13) & (for R13 being (Element of R1) holds (ex R16 being (Element of R1) st ( R13 + R16 ) = ( 0. R1 ))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 + R14 ) + R15 ) = ( R13 + ( R14 + R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds ( R13 + R14 ) = ( R14 + R13 ))) & ( 0. R1 ) <> ( 1. R1 ) & (for R13 being (Element of R1) holds ( R13 * ( 1. R1 ) ) = R13) & (for R13 being (Element of R1) holds ( ( 1. R1 ) * R13 ) = R13) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R13 * R16 ) = R14)))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R16 * R13 ) = R14)))) & (for R13 being (Element of R1) holds (for R16 being (Element of R1) holds (for R17 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (( R13 * R16 ) = ( R13 * R17 ) implies R16 = R17))))) & (for R13 being (Element of R1) holds (for R16 being (Element of R1) holds (for R17 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (( R16 * R13 ) = ( R17 * R13 ) implies R16 = R17))))) & (for R13 being (Element of R1) holds ( R13 * ( 0. R1 ) ) = ( 0. R1 )) & (for R13 being (Element of R1) holds ( ( 0. R1 ) * R13 ) = ( 0. R1 )) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( R13 * ( R14 + R15 ) ) = ( ( R13 * R14 ) + ( R13 * R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R14 + R15 ) * R13 ) = ( ( R14 * R13 ) + ( R15 * R13 ) )))))) by ALGSTR_1:6 , ALGSTR_1:16 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4 , STRUCT_0:def 8 , VECTSP_1:def 6 , VECTSP_1:def 7;
assume that
L93: (for R13 being (Element of R1) holds ( R13 + ( 0. R1 ) ) = R13)
and
L94: (for R13 being (Element of R1) holds (ex R16 being (Element of R1) st ( R13 + R16 ) = ( 0. R1 )))
and
L95: (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 + R14 ) + R15 ) = ( R13 + ( R14 + R15 ) ))))
and
L96: (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds ( R13 + R14 ) = ( R14 + R13 )))
and
L97: (( 0. R1 ) <> ( 1. R1 ) & (for R13 being (Element of R1) holds ( R13 * ( 1. R1 ) ) = R13) & (for R13 being (Element of R1) holds ( ( 1. R1 ) * R13 ) = R13) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R13 * R16 ) = R14)))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R16 * R13 ) = R14)))) & (for R13 being (Element of R1) holds (for R16 being (Element of R1) holds (for R17 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (( R13 * R16 ) = ( R13 * R17 ) implies R16 = R17))))) & (for R13 being (Element of R1) holds (for R16 being (Element of R1) holds (for R17 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (( R16 * R13 ) = ( R17 * R13 ) implies R16 = R17))))) & (for R13 being (Element of R1) holds ( R13 * ( 0. R1 ) ) = ( 0. R1 )) & (for R13 being (Element of R1) holds ( ( 0. R1 ) * R13 ) = ( 0. R1 )) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( R13 * ( R14 + R15 ) ) = ( ( R13 * R14 ) + ( R13 * R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R14 + R15 ) * R13 ) = ( ( R14 * R13 ) + ( R15 * R13 ) )))));
L98: (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (ex R16 being (Element of R1) st ( R16 + R13 ) = R14)))
proof
let R13 being (Element of R1);
let R14 being (Element of R1);
consider R17 being (Element of R1) such that L99: ( R17 + R13 ) = ( 0. R1 ) by L93 , L94 , L95 , ALGSTR_1:3;
take D7 = ( R14 + R17 );
thus L100: ( D7 + R13 ) = ( R14 + ( 0. R1 ) ) by L95 , L99
.= R14 by L93;
end;
L101: (for R13 being (Element of R1) holds ( ( 0. R1 ) + R13 ) = R13)
proof
let R13 being (Element of R1);
thus L102: ( ( 0. R1 ) + R13 ) = ( R13 + ( 0. R1 ) ) by L96
.= R13 by L93;
end;
L103: (for R13 being (Element of R1) holds (for R16 being (Element of R1) holds (for R17 being (Element of R1) holds (( R13 + R16 ) = ( R13 + R17 ) implies R16 = R17))))
proof
let R13 being (Element of R1);
let R16 being (Element of R1);
let R17 being (Element of R1);
consider R18 being (Element of R1) such that L104: ( R18 + R13 ) = ( 0. R1 ) by L93 , L94 , L95 , ALGSTR_1:3;
assume L105: ( R13 + R16 ) = ( R13 + R17 );
L106: ( ( R18 + R13 ) + R16 ) = ( R18 + ( R13 + R17 ) ) by L105 , L95
.= ( ( R18 + R13 ) + R17 ) by L95;
thus L107: R16 = ( ( 0. R1 ) + R17 ) by L106 , L101 , L104
.= R17 by L101;
end;
L108: (for R13 being (Element of R1) holds (for R16 being (Element of R1) holds (for R17 being (Element of R1) holds (( R16 + R13 ) = ( R17 + R13 ) implies R16 = R17))))
proof
let R13 being (Element of R1);
let R16 being (Element of R1);
let R17 being (Element of R1);
consider R18 being (Element of R1) such that L109: ( R13 + R18 ) = ( 0. R1 ) by L94;
assume L110: ( R16 + R13 ) = ( R17 + R13 );
L111: ( R16 + ( R13 + R18 ) ) = ( ( R17 + R13 ) + R18 ) by L110 , L95
.= ( R17 + ( R13 + R18 ) ) by L95;
thus L112: R16 = ( R17 + ( 0. R1 ) ) by L111 , L93 , L109
.= R17 by L93;
end;
L113: (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (ex R16 being (Element of R1) st ( R13 + R16 ) = R14)))
proof
let R13 being (Element of R1);
let R14 being (Element of R1);
consider R17 being (Element of R1) such that L114: ( R13 + R17 ) = ( 0. R1 ) by L94;
take D8 = ( R17 + R14 );
thus L115: ( R13 + D8 ) = ( ( 0. R1 ) + R14 ) by L95 , L114
.= R14 by L101;
end;
thus L116: thesis by L113 , L93 , L95 , L96 , L97 , L101 , L98 , L103 , L108 , ALGSTR_1:6 , ALGSTR_1:16 , ALGSTR_1:def 2 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4 , STRUCT_0:def 8 , VECTSP_1:def 6 , VECTSP_1:def 7;
end;
definition
mode _Skew-Field
 is  associative doublesidedQuasi-Field;
end;
L118: (for R1 being non  empty doubleLoopStr holds (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds ((( 0. R1 ) <> ( 1. R1 ) & (for R13 being (Element of R1) holds ( R13 * ( 1. R1 ) ) = R13) & (for R13 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R13 * R16 ) = ( 1. R1 )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 * R14 ) * R15 ) = ( R13 * ( R14 * R15 ) )))) & (for R13 being (Element of R1) holds ( R13 * ( 0. R1 ) ) = ( 0. R1 ))) implies (( R13 * R14 ) = ( 1. R1 ) implies ( R14 * R13 ) = ( 1. R1 ))))))
proof
let R1 being non  empty doubleLoopStr;
let R13 being (Element of R1);
let R14 being (Element of R1);
assume that
L119: ( 0. R1 ) <> ( 1. R1 )
and
L120: (for R13 being (Element of R1) holds ( R13 * ( 1. R1 ) ) = R13)
and
L121: (for R13 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R13 * R16 ) = ( 1. R1 ))))
and
L122: (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 * R14 ) * R15 ) = ( R13 * ( R14 * R15 ) ))))
and
L123: (for R13 being (Element of R1) holds ( R13 * ( 0. R1 ) ) = ( 0. R1 ));
thus L124: (( R13 * R14 ) = ( 1. R1 ) implies ( R14 * R13 ) = ( 1. R1 ))
proof
assume L125: ( R13 * R14 ) = ( 1. R1 );
L126: R14 <> ( 0. R1 ) by L125 , L119 , L123;
consider R16 being (Element of R1) such that L127: ( R14 * R16 ) = ( 1. R1 ) by L126 , L121;
thus L128: ( R14 * R13 ) = ( ( R14 * R13 ) * ( R14 * R16 ) ) by L120 , L127
.= ( ( ( R14 * R13 ) * R14 ) * R16 ) by L122
.= ( ( R14 * ( 1. R1 ) ) * R16 ) by L122 , L125
.= ( 1. R1 ) by L120 , L127;
end;

end;
L125: (for R1 being non  empty doubleLoopStr holds (for R13 being (Element of R1) holds ((( 0. R1 ) <> ( 1. R1 ) & (for R13 being (Element of R1) holds ( R13 * ( 1. R1 ) ) = R13) & (for R13 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R13 * R16 ) = ( 1. R1 )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 * R14 ) * R15 ) = ( R13 * ( R14 * R15 ) )))) & (for R13 being (Element of R1) holds ( R13 * ( 0. R1 ) ) = ( 0. R1 ))) implies ( ( 1. R1 ) * R13 ) = ( R13 * ( 1. R1 ) ))))
proof
let R1 being non  empty doubleLoopStr;
let R13 being (Element of R1);
assume that
L126: ( 0. R1 ) <> ( 1. R1 )
and
L127: (for R13 being (Element of R1) holds ( R13 * ( 1. R1 ) ) = R13)
and
L128: (for R13 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R13 * R16 ) = ( 1. R1 ))))
and
L129: (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 * R14 ) * R15 ) = ( R13 * ( R14 * R15 ) ))))
and
L130: (for R13 being (Element of R1) holds ( R13 * ( 0. R1 ) ) = ( 0. R1 ));
L131: (R13 <> ( 0. R1 ) implies ( ( 1. R1 ) * R13 ) = ( R13 * ( 1. R1 ) ))
proof
assume L132: R13 <> ( 0. R1 );
consider R16 being (Element of R1) such that L133: ( R13 * R16 ) = ( 1. R1 ) by L132 , L128;
thus L134: ( ( 1. R1 ) * R13 ) = ( R13 * ( R16 * R13 ) ) by L129 , L133
.= ( R13 * ( 1. R1 ) ) by L126 , L127 , L128 , L129 , L130 , L133 , L118;
end;
L135: (R13 = ( 0. R1 ) implies ( ( 1. R1 ) * R13 ) = ( R13 * ( 1. R1 ) ))
proof
assume L136: R13 = ( 0. R1 );
thus L137: ( ( 1. R1 ) * R13 ) = ( 0. R1 ) by L136 , L130
.= ( R13 * ( 1. R1 ) ) by L127 , L136;
end;
thus L138: thesis by L135 , L131;
end;
L139: (for R1 being non  empty doubleLoopStr holds ((( 0. R1 ) <> ( 1. R1 ) & (for R13 being (Element of R1) holds ( R13 * ( 1. R1 ) ) = R13) & (for R13 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R13 * R16 ) = ( 1. R1 )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 * R14 ) * R15 ) = ( R13 * ( R14 * R15 ) )))) & (for R13 being (Element of R1) holds ( R13 * ( 0. R1 ) ) = ( 0. R1 ))) implies (for R13 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R16 * R13 ) = ( 1. R1 ))))))
proof
let R1 being non  empty doubleLoopStr;
assume that
L140: (( 0. R1 ) <> ( 1. R1 ) & (for R13 being (Element of R1) holds ( R13 * ( 1. R1 ) ) = R13))
and
L141: (for R13 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R13 * R16 ) = ( 1. R1 ))))
and
L142: ((for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 * R14 ) * R15 ) = ( R13 * ( R14 * R15 ) )))) & (for R13 being (Element of R1) holds ( R13 * ( 0. R1 ) ) = ( 0. R1 )));
let R13 being (Element of R1);
assume L143: R13 <> ( 0. R1 );
consider R16 being (Element of R1) such that L144: ( R13 * R16 ) = ( 1. R1 ) by L143 , L141;
L145: ( R16 * R13 ) = ( 1. R1 ) by L140 , L141 , L142 , L144 , L118;
thus L146: thesis by L145;
end;
theorem
L147: (for R1 being non  empty doubleLoopStr holds (R1 is _Skew-Field iff ((for R13 being (Element of R1) holds ( R13 + ( 0. R1 ) ) = R13) & (for R13 being (Element of R1) holds (ex R16 being (Element of R1) st ( R13 + R16 ) = ( 0. R1 ))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 + R14 ) + R15 ) = ( R13 + ( R14 + R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds ( R13 + R14 ) = ( R14 + R13 ))) & ( 0. R1 ) <> ( 1. R1 ) & (for R13 being (Element of R1) holds ( R13 * ( 1. R1 ) ) = R13) & (for R13 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R13 * R16 ) = ( 1. R1 )))) & (for R13 being (Element of R1) holds ( R13 * ( 0. R1 ) ) = ( 0. R1 )) & (for R13 being (Element of R1) holds ( ( 0. R1 ) * R13 ) = ( 0. R1 )) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 * R14 ) * R15 ) = ( R13 * ( R14 * R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( R13 * ( R14 + R15 ) ) = ( ( R13 * R14 ) + ( R13 * R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R14 + R15 ) * R13 ) = ( ( R14 * R13 ) + ( R15 * R13 ) )))))))
proof
let R1 being non  empty doubleLoopStr;
thus L148: (R1 is _Skew-Field implies ((for R13 being (Element of R1) holds ( R13 + ( 0. R1 ) ) = R13) & (for R13 being (Element of R1) holds (ex R16 being (Element of R1) st ( R13 + R16 ) = ( 0. R1 ))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 + R14 ) + R15 ) = ( R13 + ( R14 + R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds ( R13 + R14 ) = ( R14 + R13 ))) & ( 0. R1 ) <> ( 1. R1 ) & (for R13 being (Element of R1) holds ( R13 * ( 1. R1 ) ) = R13) & (for R13 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R13 * R16 ) = ( 1. R1 )))) & (for R13 being (Element of R1) holds ( R13 * ( 0. R1 ) ) = ( 0. R1 )) & (for R13 being (Element of R1) holds ( ( 0. R1 ) * R13 ) = ( 0. R1 )) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 * R14 ) * R15 ) = ( R13 * ( R14 * R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( R13 * ( R14 + R15 ) ) = ( ( R13 * R14 ) + ( R13 * R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R14 + R15 ) * R13 ) = ( ( R14 * R13 ) + ( R15 * R13 ) )))))) by ALGSTR_1:6 , ALGSTR_1:16 , GROUP_1:def 3 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4 , STRUCT_0:def 8 , VECTSP_1:def 6 , VECTSP_1:def 7;
assume L149: ((for R13 being (Element of R1) holds ( R13 + ( 0. R1 ) ) = R13) & (for R13 being (Element of R1) holds (ex R16 being (Element of R1) st ( R13 + R16 ) = ( 0. R1 ))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 + R14 ) + R15 ) = ( R13 + ( R14 + R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds ( R13 + R14 ) = ( R14 + R13 ))) & ( 0. R1 ) <> ( 1. R1 ) & (for R13 being (Element of R1) holds ( R13 * ( 1. R1 ) ) = R13) & (for R13 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R13 * R16 ) = ( 1. R1 )))) & (for R13 being (Element of R1) holds ( R13 * ( 0. R1 ) ) = ( 0. R1 )) & (for R13 being (Element of R1) holds ( ( 0. R1 ) * R13 ) = ( 0. R1 )) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 * R14 ) * R15 ) = ( R13 * ( R14 * R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( R13 * ( R14 + R15 ) ) = ( ( R13 * R14 ) + ( R13 * R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R14 + R15 ) * R13 ) = ( ( R14 * R13 ) + ( R15 * R13 ) )))));
L150:
now
thus L151: (for R13 being (Element of R1) holds ( ( 0. R1 ) + R13 ) = R13)
proof
let R13 being (Element of R1);
thus L152: ( ( 0. R1 ) + R13 ) = ( R13 + ( 0. R1 ) ) by L149
.= R13 by L149;
end;

thus L153: (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (ex R16 being (Element of R1) st ( R13 + R16 ) = R14)))
proof
let R13 being (Element of R1);
let R14 being (Element of R1);
consider R17 being (Element of R1) such that L154: ( R13 + R17 ) = ( 0. R1 ) by L149;
take D9 = ( R17 + R14 );
thus L155: ( R13 + D9 ) = ( ( 0. R1 ) + R14 ) by L149 , L154
.= R14 by L151;
end;

thus L156: (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (ex R16 being (Element of R1) st ( R16 + R13 ) = R14)))
proof
let R13 being (Element of R1);
let R14 being (Element of R1);
consider R17 being (Element of R1) such that L157: ( R17 + R13 ) = ( 0. R1 ) by L149 , ALGSTR_1:3;
take D10 = ( R14 + R17 );
thus L158: ( D10 + R13 ) = ( R14 + ( 0. R1 ) ) by L149 , L157
.= R14 by L149;
end;

thus L159: (for R13 being (Element of R1) holds (for R16 being (Element of R1) holds (for R17 being (Element of R1) holds (( R13 + R16 ) = ( R13 + R17 ) implies R16 = R17))))
proof
let R13 being (Element of R1);
let R16 being (Element of R1);
let R17 being (Element of R1);
consider R18 being (Element of R1) such that L160: ( R18 + R13 ) = ( 0. R1 ) by L149 , ALGSTR_1:3;
assume L161: ( R13 + R16 ) = ( R13 + R17 );
L162: ( ( R18 + R13 ) + R16 ) = ( R18 + ( R13 + R17 ) ) by L161 , L149
.= ( ( R18 + R13 ) + R17 ) by L149;
thus L163: R16 = ( ( 0. R1 ) + R17 ) by L162 , L151 , L160
.= R17 by L151;
end;

thus L164: (for R13 being (Element of R1) holds (for R16 being (Element of R1) holds (for R17 being (Element of R1) holds (( R16 + R13 ) = ( R17 + R13 ) implies R16 = R17))))
proof
let R13 being (Element of R1);
let R16 being (Element of R1);
let R17 being (Element of R1);
consider R18 being (Element of R1) such that L165: ( R13 + R18 ) = ( 0. R1 ) by L149;
assume L166: ( R16 + R13 ) = ( R17 + R13 );
L167: ( R16 + ( R13 + R18 ) ) = ( ( R17 + R13 ) + R18 ) by L166 , L149
.= ( R17 + ( R13 + R18 ) ) by L149;
thus L168: R16 = ( R17 + ( 0. R1 ) ) by L167 , L149 , L165
.= R17 by L149;
end;

thus L169: (for R13 being (Element of R1) holds ( ( 1. R1 ) * R13 ) = R13)
proof
let R13 being (Element of R1);
thus L170: ( ( 1. R1 ) * R13 ) = ( R13 * ( 1. R1 ) ) by L149 , L125
.= R13 by L149;
end;

thus L171: (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R13 * R16 ) = R14))))
proof
let R13 being (Element of R1);
let R14 being (Element of R1);
assume L172: R13 <> ( 0. R1 );
consider R17 being (Element of R1) such that L173: ( R13 * R17 ) = ( 1. R1 ) by L172 , L149;
take D11 = ( R17 * R14 );
thus L174: ( R13 * D11 ) = ( ( 1. R1 ) * R14 ) by L149 , L173
.= R14 by L169;
end;

thus L175: (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R16 * R13 ) = R14))))
proof
let R13 being (Element of R1);
let R14 being (Element of R1);
assume L176: R13 <> ( 0. R1 );
consider R17 being (Element of R1) such that L177: ( R17 * R13 ) = ( 1. R1 ) by L176 , L149 , L139;
take D12 = ( R14 * R17 );
thus L178: ( D12 * R13 ) = ( R14 * ( 1. R1 ) ) by L149 , L177
.= R14 by L149;
end;

thus L179: (for R13 being (Element of R1) holds (for R16 being (Element of R1) holds (for R17 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (( R13 * R16 ) = ( R13 * R17 ) implies R16 = R17)))))
proof
let R13 being (Element of R1);
let R16 being (Element of R1);
let R17 being (Element of R1);
assume L180: R13 <> ( 0. R1 );
consider R18 being (Element of R1) such that L181: ( R18 * R13 ) = ( 1. R1 ) by L180 , L149 , L139;
assume L182: ( R13 * R16 ) = ( R13 * R17 );
L183: ( ( R18 * R13 ) * R16 ) = ( R18 * ( R13 * R17 ) ) by L182 , L149
.= ( ( R18 * R13 ) * R17 ) by L149;
thus L184: R16 = ( ( 1. R1 ) * R17 ) by L183 , L169 , L181
.= R17 by L169;
end;

thus L185: (for R13 being (Element of R1) holds (for R16 being (Element of R1) holds (for R17 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (( R16 * R13 ) = ( R17 * R13 ) implies R16 = R17)))))
proof
let R13 being (Element of R1);
let R16 being (Element of R1);
let R17 being (Element of R1);
assume L186: R13 <> ( 0. R1 );
consider R18 being (Element of R1) such that L187: ( R13 * R18 ) = ( 1. R1 ) by L186 , L149;
assume L188: ( R16 * R13 ) = ( R17 * R13 );
L189: ( R16 * ( R13 * R18 ) ) = ( ( R17 * R13 ) * R18 ) by L188 , L149
.= ( R17 * ( R13 * R18 ) ) by L149;
thus L190: R16 = ( R17 * ( 1. R1 ) ) by L189 , L149 , L187
.= R17 by L149;
end;

end;
thus L186: thesis by L150 , L149 , ALGSTR_1:6 , ALGSTR_1:16 , ALGSTR_1:def 2 , GROUP_1:def 3 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4 , STRUCT_0:def 8 , VECTSP_1:def 6 , VECTSP_1:def 7;
end;
definition
mode _Field
 is  commutative _Skew-Field;
end;
theorem
L188: (for R1 being non  empty doubleLoopStr holds (R1 is _Field iff ((for R13 being (Element of R1) holds ( R13 + ( 0. R1 ) ) = R13) & (for R13 being (Element of R1) holds (ex R16 being (Element of R1) st ( R13 + R16 ) = ( 0. R1 ))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 + R14 ) + R15 ) = ( R13 + ( R14 + R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds ( R13 + R14 ) = ( R14 + R13 ))) & ( 0. R1 ) <> ( 1. R1 ) & (for R13 being (Element of R1) holds ( R13 * ( 1. R1 ) ) = R13) & (for R13 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R13 * R16 ) = ( 1. R1 )))) & (for R13 being (Element of R1) holds ( R13 * ( 0. R1 ) ) = ( 0. R1 )) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 * R14 ) * R15 ) = ( R13 * ( R14 * R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( R13 * ( R14 + R15 ) ) = ( ( R13 * R14 ) + ( R13 * R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds ( R13 * R14 ) = ( R14 * R13 ))))))
proof
let R1 being non  empty doubleLoopStr;
thus L189: (R1 is _Field implies ((for R13 being (Element of R1) holds ( R13 + ( 0. R1 ) ) = R13) & (for R13 being (Element of R1) holds (ex R16 being (Element of R1) st ( R13 + R16 ) = ( 0. R1 ))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 + R14 ) + R15 ) = ( R13 + ( R14 + R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds ( R13 + R14 ) = ( R14 + R13 ))) & ( 0. R1 ) <> ( 1. R1 ) & (for R13 being (Element of R1) holds ( R13 * ( 1. R1 ) ) = R13) & (for R13 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R13 * R16 ) = ( 1. R1 )))) & (for R13 being (Element of R1) holds ( R13 * ( 0. R1 ) ) = ( 0. R1 )) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 * R14 ) * R15 ) = ( R13 * ( R14 * R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( R13 * ( R14 + R15 ) ) = ( ( R13 * R14 ) + ( R13 * R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds ( R13 * R14 ) = ( R14 * R13 ))))) by L147 , GROUP_1:def 12;
assume that
L190: ((for R13 being (Element of R1) holds ( R13 + ( 0. R1 ) ) = R13) & (for R13 being (Element of R1) holds (ex R16 being (Element of R1) st ( R13 + R16 ) = ( 0. R1 ))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 + R14 ) + R15 ) = ( R13 + ( R14 + R15 ) )))) & (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds ( R13 + R14 ) = ( R14 + R13 ))) & ( 0. R1 ) <> ( 1. R1 ) & (for R13 being (Element of R1) holds ( R13 * ( 1. R1 ) ) = R13) & (for R13 being (Element of R1) holds (R13 <> ( 0. R1 ) implies (ex R16 being (Element of R1) st ( R13 * R16 ) = ( 1. R1 )))))
and
L191: (for R13 being (Element of R1) holds ( R13 * ( 0. R1 ) ) = ( 0. R1 ))
and
L192: (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R13 * R14 ) * R15 ) = ( R13 * ( R14 * R15 ) ))))
and
L193: (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( R13 * ( R14 + R15 ) ) = ( ( R13 * R14 ) + ( R13 * R15 ) ))))
and
L194: (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds ( R13 * R14 ) = ( R14 * R13 )));
L195: (for R13 being (Element of R1) holds ( ( 0. R1 ) * R13 ) = ( 0. R1 ))
proof
let R13 being (Element of R1);
thus L196: ( ( 0. R1 ) * R13 ) = ( R13 * ( 0. R1 ) ) by L194
.= ( 0. R1 ) by L191;
end;
L197: (for R13 being (Element of R1) holds (for R14 being (Element of R1) holds (for R15 being (Element of R1) holds ( ( R14 + R15 ) * R13 ) = ( ( R14 * R13 ) + ( R15 * R13 ) ))))
proof
let R13 being (Element of R1);
let R14 being (Element of R1);
let R15 being (Element of R1);
thus L198: ( ( R14 + R15 ) * R13 ) = ( R13 * ( R14 + R15 ) ) by L194
.= ( ( R13 * R14 ) + ( R13 * R15 ) ) by L193
.= ( ( R14 * R13 ) + ( R13 * R15 ) ) by L194
.= ( ( R14 * R13 ) + ( R15 * R13 ) ) by L194;
end;
thus L199: thesis by L197 , L190 , L191 , L192 , L193 , L194 , L195 , L147 , GROUP_1:def 12;
end;
