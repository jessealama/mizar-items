:: The Correspondence Between Monotonic Many Sorted Signatures
:: and Well-Founded Graphs. {P}art {I}
::  by Czes{\l}aw Byli\'nski and Piotr Rudnicki
::
:: Received February 14, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FINSET_1, FUNCT_1, RELAT_1, CARD_3, GRAPH_1, SUBSET_1,
      TREES_2, FINSEQ_1, STRUCT_0, GRAPH_2, ARYTM_3, XXREAL_0, NAT_1, PARTFUN1,
      TARSKI, ORDINAL4, XBOOLE_0, CARD_1, WAYBEL_0, GLIB_000, RELAT_2,
      FUNCOP_1, ARYTM_1, TREES_4, TREES_1, MSUALG_1, PBOOLE, MSATERM, TREES_9,
      ZFMISC_1, MSAFREE, MSUALG_2, MSAFREE2, MSUALG_3, PRELAMB, REALSET1,
      GROUP_6, FUNCT_6, MARGREL1, UNIALG_2, DTCONSTR, TDGROUP, TREES_3,
      TREES_A, MSSCYC_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, XCMPLX_0, CARD_1, NUMBERS,
      ORDINAL1, NAT_1, FINSEQ_2, STRUCT_0, CARD_3, RELAT_1, FUNCT_1, PARTFUN1,
      FUNCT_2, FINSET_1, FUNCOP_1, FINSEQ_1, GRAPH_1, GRAPH_2, TREES_1,
      TREES_2, TREES_3, FUNCT_6, TREES_4, LANG1, DTCONSTR, PBOOLE, MSUALG_1,
      MSUALG_2, MSUALG_3, MSAFREE, MSAFREE2, TREES_9, MSATERM, XXREAL_0,
      PRE_POLY;
 constructors WELLORD2, FINSEQ_4, MSUALG_3, MSATERM, MSAFREE2, GRAPH_2,
      RELSET_1, PRE_POLY, XTUPLE_0;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, FINSET_1, XXREAL_0, XREAL_0, NAT_1,
      INT_1, FINSEQ_1, PBOOLE, TREES_2, TREES_3, PRE_CIRC, TREES_9, STRUCT_0,
      MSUALG_1, MSAFREE, MSAFREE2, EXTENS_1, ORDINAL1, CARD_1, GRAPH_1,
      RELSET_1, TREES_1, MSATERM, XTUPLE_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, GRAPH_1, GRAPH_2, MSAFREE, PBOOLE, FINSET_1, MSUALG_3,
      STRUCT_0, XTUPLE_0;
 theorems TARSKI, NAT_1, ZFMISC_1, FINSET_1, GRAPH_1, GRAPH_2, FUNCOP_1,
      FUNCT_1, FUNCT_2, FUNCT_6, FINSEQ_1, FINSEQ_2, FINSEQ_3, FINSEQ_4,
      FINSEQ_5, CARD_1, CARD_3, TREES_1, TREES_3, TREES_4, PBOOLE, MSUALG_1,
      MSUALG_2, MSUALG_3, MSAFREE, MSAFREE2, MSATERM, EXTENS_1, INT_1,
      XBOOLE_0, XBOOLE_1, XREAL_1, XXREAL_0, ORDINAL1, PARTFUN1, RELAT_1,
      RELSET_1, XTUPLE_0;
 schemes NAT_1, FRAENKEL, PBOOLE, DOMAIN_1;

begin
definition
let C1 being Graph;
redefine mode Chain of C1
means :L1: (it is (FinSequence of (the carrier' of C1)) & (ex B1 being (FinSequence of (the carrier of C1)) st B1 is_vertex_seq_of it));
compatibility
proof
let C2 being FinSequence;
thus L2:now
assume L3: C2 is (Chain of C1);
consider C3 being FinSequence such that L4: ( len C3 ) = ( ( len C2 ) + 1 ) and L5: (for R4 being (Element of ( NAT )) holds ((1 <= R4 & R4 <= ( len C3 )) implies ( C3 . R4 ) in (the carrier of C1))) and L6: (for R4 being (Element of ( NAT )) holds ((1 <= R4 & R4 <= ( len C2 )) implies (ex B2 , B3 being (Element of (the carrier of C1)) st (B2 = ( C3 . R4 ) & B3 = ( C3 . ( R4 + 1 ) ) & ( C2 . R4 ) joins B2 , B3)))) by L3 , GRAPH_1:def 14;
thus L7: C2 is (FinSequence of (the carrier' of C1)) by L3;
L8:
now
let C4 being Nat;
assume L9: C4 in ( dom C3 );
L10: (1 <= C4 & C4 <= ( len C3 )) by L9 , FINSEQ_3:25;
L11: C4 in ( NAT ) by ORDINAL1:def 12;
thus L12: ( C3 . C4 ) in (the carrier of C1) by L11 , L5 , L10;
end;
reconsider D1 = C3 as (FinSequence of (the carrier of C1)) by L8 , FINSEQ_2:12;
take D2 = D1;
thus L13: D2 is_vertex_seq_of C2
proof
thus L14: ( len D2 ) = ( ( len C2 ) + 1 ) by L4;
let R4 being (Element of ( NAT ));
assume that
L15: 1 <= R4
and
L16: R4 <= ( len C2 );
L17: ( R4 + 1 ) <= ( len D2 ) by L4 , L16 , XREAL_1:6;
L18: ( D2 /. ( R4 + 1 ) ) = ( D2 . ( R4 + 1 ) ) by L17 , FINSEQ_4:15 , NAT_1:12;
L19: (R4 <= ( len D2 ) & (ex B4 , B5 being (Element of (the carrier of C1)) st (B4 = ( D2 . R4 ) & B5 = ( D2 . ( R4 + 1 ) ) & ( C2 . R4 ) joins B4 , B5))) by L4 , L6 , L15 , L16 , NAT_1:12;
thus L20: thesis by L19 , L15 , L18 , FINSEQ_4:15;
end;

end;
assume L14: C2 is (FinSequence of (the carrier' of C1));
given C5 being (FinSequence of (the carrier of C1)) such that
L15: C5 is_vertex_seq_of C2;

thus L16:now
let R4 being (Element of ( NAT ));
assume L17: (1 <= R4 & R4 <= ( len C2 ));
L18: R4 in ( dom C2 ) by L17 , FINSEQ_3:25;
L19: ( C2 . R4 ) in ( rng C2 ) by L18 , FUNCT_1:def 3;
L20: ( rng C2 ) c= (the carrier' of C1) by L14 , FINSEQ_1:def 4;
thus L21: ( C2 . R4 ) in (the carrier' of C1) by L20 , L19;
end;
take C5;
thus L22: ( len C5 ) = ( ( len C2 ) + 1 ) by L15 , GRAPH_2:def 6;
thus L23:now
let R4 being (Element of ( NAT ));
assume L24: (1 <= R4 & R4 <= ( len C5 ));
L25: R4 in ( dom C5 ) by L24 , FINSEQ_3:25;
L26: ( C5 . R4 ) in ( rng C5 ) by L25 , FUNCT_1:def 3;
L27: ( rng C5 ) c= (the carrier of C1) by FINSEQ_1:def 4;
thus L28: ( C5 . R4 ) in (the carrier of C1) by L27 , L26;
end;
let R4 being (Element of ( NAT ));
assume that
L29: 1 <= R4
and
L30: R4 <= ( len C2 );
take D3 = ( C5 /. R4 );
take D4 = ( C5 /. ( R4 + 1 ) );
L31: (R4 <= ( len C5 ) & ( R4 + 1 ) <= ( len C5 )) by L22 , L30 , NAT_1:12 , XREAL_1:6;
thus L32: (D3 = ( C5 . R4 ) & D4 = ( C5 . ( R4 + 1 ) )) by L31 , L29 , FINSEQ_4:15 , NAT_1:12;
thus L33: thesis by L15 , L29 , L30 , GRAPH_2:def 6;
end;
end;
canceled 1;
theorem
L35: (for R4 being (Element of ( NAT )) holds (for B6 , B7 being FinSequence holds (R4 <= ( len B6 ) implies ( (1 , R4) -cut B6 ) = ( (1 , R4) -cut ( B6 ^ B7 ) ))))
proof
let R4 being (Element of ( NAT ));
let C6 , C7 being FinSequence;
assume L36: R4 <= ( len C6 );
per cases ;
suppose L37: R4 < 1;

L38: ( (1 , R4) -cut C6 ) = ( {} ) by L37 , GRAPH_2:def 1;
thus L39: thesis by L38 , L37 , GRAPH_2:def 1;
end;
suppose L40: 1 <= R4;

set D5 = ( (1 , R4) -cut C6 );
set D6 = ( (1 , R4) -cut ( C6 ^ C7 ) );
L41:
now
L42: ( ( len D5 ) + 1 ) = ( R4 + 1 ) by L36 , L40 , GRAPH_2:def 1;
L43: ( len ( C6 ^ C7 ) ) = ( ( len C6 ) + ( len C7 ) ) by FINSEQ_1:22;
L44: R4 <= ( len ( C6 ^ C7 ) ) by L43 , L36 , NAT_1:12;
L45: ( ( len D6 ) + 1 ) = ( R4 + 1 ) by L44 , L40 , GRAPH_2:def 1;
thus L46: ( len D5 ) = ( len D6 ) by L45 , L42;
let C8 being Nat;
assume that
L47: 1 <= C8
and
L48: C8 <= ( len D5 );
L49: C8 <= ( len C6 ) by L36 , L42 , L48 , XXREAL_0:2;
L50: C8 in ( dom C6 ) by L49 , L47 , FINSEQ_3:25;
L51: ( ( 0 ) + 1 ) = 1;
L52: (ex B8 being (Element of ( NAT )) st (( 0 ) <= B8 & B8 < ( len D5 ) & C8 = ( B8 + 1 ))) by L51 , L47 , L48 , GRAPH_2:1;
thus L53: ( D5 . C8 ) = ( C6 . C8 ) by L52 , L36 , L40 , GRAPH_2:def 1
.= ( ( C6 ^ C7 ) . C8 ) by L50 , FINSEQ_1:def 7
.= ( D6 . C8 ) by L40 , L44 , L42 , L45 , L52 , GRAPH_2:def 1;
end;
thus L54: thesis by L41 , FINSEQ_1:14;
end;
end;
notation
let C9 being Graph;
let C10 being (Chain of C9);
synonym C10 is  directed for C10 is  oriented;
end;
definition
let C11 being Graph;
let C12 being (Chain of C11);
attr C12 is  cyclic
means
:L57: (ex B9 being (FinSequence of (the carrier of C11)) st (B9 is_vertex_seq_of C12 & ( B9 . 1 ) = ( B9 . ( len B9 ) )));
end;
registration
cluster  void for Graph;
existence
proof
set D7 = { 1 };
set D8 = ( {} );
set D9 = the (Function of D8 , D7);
reconsider D10 = MultiGraphStruct (# D7 , D8 , D9 , D9 #) as Graph;
take D10;
thus L59: (the carrier' of D10) is  empty;
end;
end;
theorem
L61: (for B10 being Graph holds ( ( rng (the Source of B10) ) \/ ( rng (the Target of B10) ) ) c= (the carrier of B10))
proof
let C13 being Graph;
L62: (( rng (the Source of C13) ) c= (the carrier of C13) & ( rng (the Target of C13) ) c= (the carrier of C13)) by RELAT_1:def 19;
thus L63: thesis by L62 , XBOOLE_1:8;
end;
registration
cluster  finite  simple  connected non  void  strict for Graph;
existence
proof
set D11 = { 1 , 2 };
set D12 = { 1 };
L64: (1 in D11 & 2 in D11) by TARSKI:def 2;
reconsider D13 = ( D12 --> 1 ) , D14 = ( D12 --> 2 ) as (Function of D12 , D11) by L64 , FUNCOP_1:45;
reconsider D15 = MultiGraphStruct (# D11 , D12 , D13 , D14 #) as Graph;
take D15;
thus L65: D15 is  finite by GRAPH_1:def 11;
L66: 1 in D12 by TARSKI:def 1;
L67: ( D13 . 1 ) = 1 by L66 , FUNCOP_1:7;
thus L68: D15 is  simple
proof
given C14 being set such that
L69: C14 in (the carrier' of D15)
and
L70: ( (the Source of D15) . C14 ) = ( (the Target of D15) . C14 );

L71: C14 = 1 by L69 , TARSKI:def 1;
thus L72: contradiction by L71 , L66 , L67 , L70 , FUNCOP_1:7;
end;

L73: ( D14 . 1 ) = 2 by L66 , FUNCOP_1:7;
thus L74: D15 is  connected
proof
set D16 = ( the MultiGraphStruct of D15 );
given C15 , C16 being Graph such that
L75: (the carrier of C15) misses (the carrier of C16)
and
L76: D15 is_sum_of C15 , C16;

L77: ( the MultiGraphStruct of D15 ) = ( C15 \/ C16 ) by L76 , GRAPH_1:def 6;
set D17 = (the carrier of C15);
set D18 = (the carrier of C16);
set D19 = (the Target of C15);
set D20 = (the Target of C16);
set D21 = (the Source of C15);
set D22 = (the Source of C16);
set D23 = (the carrier' of C15);
set D24 = (the carrier' of C16);
L78: ( ( rng D21 ) \/ ( rng D19 ) ) c= D17 by L61;
L79: ( ( rng D22 ) \/ ( rng D20 ) ) c= D18 by L61;
L80: ((the Target of C15) tolerates (the Target of C16) & (the Source of C15) tolerates (the Source of C16)) by L76 , GRAPH_1:def 6;
L81: (the carrier of D16) = ( (the carrier of C15) \/ (the carrier of C16) ) by L80 , L77 , GRAPH_1:def 5;
L82: (the carrier' of D16) = ( (the carrier' of C15) \/ (the carrier' of C16) ) by L80 , L77 , GRAPH_1:def 5;
per cases  by L82 , ZFMISC_1:37;
suppose L83: (D23 = D12 & D24 = D12);

L84: ( D22 . 1 ) = ( D13 . 1 ) by L83 , L66 , L80 , L77 , GRAPH_1:def 5;
L85: 1 in ( rng D22 ) by L84 , L66 , L67 , L83 , FUNCT_2:4;
L86: 1 in ( ( rng D22 ) \/ ( rng D20 ) ) by L85 , XBOOLE_0:def 3;
L87: ( D21 . 1 ) = ( D13 . 1 ) by L66 , L80 , L77 , L83 , GRAPH_1:def 5;
L88: 1 in ( rng D21 ) by L87 , L66 , L67 , L83 , FUNCT_2:4;
L89: 1 in ( ( rng D21 ) \/ ( rng D19 ) ) by L88 , XBOOLE_0:def 3;
thus L90: contradiction by L89 , L75 , L78 , L79 , L86 , XBOOLE_0:3;
end;
suppose L91: (D23 = D12 & D24 = ( {} ));

L92: ( D19 . 1 ) = ( D14 . 1 ) by L91 , L66 , L80 , L77 , GRAPH_1:def 5;
L93: 2 in ( rng D19 ) by L92 , L66 , L73 , L91 , FUNCT_2:4;
L94: 2 in ( ( rng D21 ) \/ ( rng D19 ) ) by L93 , XBOOLE_0:def 3;
L95: D17 c= D11 by L81 , XBOOLE_1:7;
L96: ( D21 . 1 ) = ( D13 . 1 ) by L66 , L80 , L77 , L91 , GRAPH_1:def 5;
L97: 1 in ( rng D21 ) by L96 , L66 , L67 , L91 , FUNCT_2:4;
L98: 1 in ( ( rng D21 ) \/ ( rng D19 ) ) by L97 , XBOOLE_0:def 3;
L99: D11 c= D17 by L98 , L78 , L94 , ZFMISC_1:32;
L100: D11 = D17 by L99 , L95 , XBOOLE_0:def 10;
L101: D18 c= D17 by L100 , L81 , XBOOLE_1:7;
thus L102: contradiction by L101 , L75 , XBOOLE_1:67;
end;
suppose L103: (D23 = ( {} ) & D24 = D12);

L104: ( D20 . 1 ) = ( D14 . 1 ) by L103 , L66 , L80 , L77 , GRAPH_1:def 5;
L105: 2 in ( rng D20 ) by L104 , L66 , L73 , L103 , FUNCT_2:4;
L106: 2 in ( ( rng D22 ) \/ ( rng D20 ) ) by L105 , XBOOLE_0:def 3;
L107: D18 c= D11 by L81 , XBOOLE_1:7;
L108: ( D22 . 1 ) = ( D13 . 1 ) by L66 , L80 , L77 , L103 , GRAPH_1:def 5;
L109: 1 in ( rng D22 ) by L108 , L66 , L67 , L103 , FUNCT_2:4;
L110: 1 in ( ( rng D22 ) \/ ( rng D20 ) ) by L109 , XBOOLE_0:def 3;
L111: D11 c= D18 by L110 , L79 , L106 , ZFMISC_1:32;
L112: D11 = D18 by L111 , L107 , XBOOLE_0:def 10;
L113: D17 c= D18 by L112 , L81 , XBOOLE_1:7;
thus L114: contradiction by L113 , L75 , XBOOLE_1:67;
end;
end;

thus L116: D15 is non  void;
thus L117: thesis;
end;
end;
theorem
L119: (for R1 being Graph holds (for B11 being set holds (for B12 , B13 being (Element of (the carrier of R1)) holds ((B12 = ( (the Source of R1) . B11 ) & B13 = ( (the Target of R1) . B11 )) implies <* B12 , B13 *> is_vertex_seq_of <* B11 *>))))
proof
let R1 being Graph;
let C17 being set;
let C18 , C19 being (Element of (the carrier of R1));
assume L120: (C18 = ( (the Source of R1) . C17 ) & C19 = ( (the Target of R1) . C17 ));
set D25 = <* C17 *>;
set D26 = <* C18 , C19 *>;
L121: ( D26 /. ( 1 + 1 ) ) = C19 by FINSEQ_4:17;
L122: ( len D25 ) = 1 by FINSEQ_1:39;
thus L123: ( len D26 ) = ( ( len D25 ) + 1 ) by L122 , FINSEQ_1:44;
let C20 being (Element of ( NAT ));
assume L124: (1 <= C20 & C20 <= ( len D25 ));
L125: C20 = 1 by L124 , L122 , XXREAL_0:1;
L126: (( D25 . 1 ) = C17 & ( D26 /. 1 ) = C18) by FINSEQ_1:40 , FINSEQ_4:17;
thus L127: thesis by L126 , L120 , L125 , L121 , GRAPH_1:def 12;
end;
theorem
L128: (for R1 being Graph holds (for B14 being set holds (B14 in (the carrier' of R1) implies <* B14 *> is  directed  directed  directed  directed (Chain of R1))))
proof
let R1 being Graph;
let C21 being set;
assume L129: C21 in (the carrier' of R1);
reconsider D27 = ( (the Source of R1) . C21 ) , D28 = ( (the Target of R1) . C21 ) as (Element of (the carrier of R1)) by L129 , FUNCT_2:5;
reconsider D29 = (the carrier' of R1) as non  empty set by L129;
reconsider D30 = C21 as (Element of D29) by L129;
L130: <* D27 , D28 *> is_vertex_seq_of <* D30 *> by L119;
reconsider D31 = <* D30 *> as (Chain of R1) by L130 , L1;
L131: D31 is  directed
proof
let C22 being (Element of ( NAT ));
assume L132: (1 <= C22 & C22 < ( len D31 ));
thus L133: thesis by L132 , FINSEQ_1:39;
end;
thus L134: thesis by L131;
end;
registration
let R5 being non  void Graph;
cluster  directed non  empty  one-to-one for (Chain of R5);
existence
proof
set D32 = the (Element of (the carrier' of R5));
reconsider D33 = <* D32 *> as  directed (Chain of R5) by L128;
take D33;
thus L135: D33 is  directed;
thus L136: D33 is non  empty;
let C23 , C24 being (Element of ( NAT ));
assume that
L137: (1 <= C23 & C23 < C24)
and
L138: C24 <= ( len D33 );
L139: 1 < C24 by L137 , XXREAL_0:2;
thus L140: thesis by L139 , L138 , FINSEQ_1:39;
end;
end;
L142: (for B15 being non  empty Graph holds (for B16 being (Chain of B15) holds (for B17 being (FinSequence of (the carrier of B15)) holds ((B16 is  cyclic & B17 is_vertex_seq_of B16) implies ( B17 . 1 ) = ( B17 . ( len B17 ) )))))
proof
let C25 being non  empty Graph;
let C26 being (Chain of C25);
let C27 being (FinSequence of (the carrier of C25));
assume that
L143: C26 is  cyclic
and
L144: C27 is_vertex_seq_of C26;
consider C28 being (FinSequence of (the carrier of C25)) such that L145: C28 is_vertex_seq_of C26 and L146: ( C28 . 1 ) = ( C28 . ( len C28 ) ) by L143 , L57;
per cases ;
suppose L147: (( card (the carrier of C25) ) = 1 or (C26 <> ( {} ) & (not C26 alternates_vertices_in C25)));

L148: (C28 = ( vertex-seq C26 ) & C27 = ( vertex-seq C26 )) by L147 , L144 , L145 , GRAPH_2:def 8;
thus L149: thesis by L148 , L146;
end;
suppose L150: (not (( card (the carrier of C25) ) = 1 or (C26 <> ( {} ) & (not C26 alternates_vertices_in C25))));

L151: ( len C27 ) = ( ( len C26 ) + 1 ) by L144 , GRAPH_2:def 6;
L152: ( len C28 ) = ( ( len C26 ) + 1 ) by L145 , GRAPH_2:def 6;
L153:
now
per cases  by L150;
suppose L154: (( card (the carrier of C25) ) <> 1 & C26 = ( {} ));

L155: ( len C26 ) = ( 0 ) by L154;
thus L156: thesis by L155 , L151;
end;
suppose L157: (( card (the carrier of C25) ) <> 1 & C26 alternates_vertices_in C25);

L158: (C27 is  TwoValued  Alternating & C28 is  TwoValued  Alternating) by L157 , L144 , L145 , GRAPH_2:37;
L159:
now
set D34 = (the Source of C25);
set D35 = (the Target of C25);
assume L160: C27 <> C28;
L161: ( rng C27 ) = { ( D34 . ( C26 . 1 ) ) , ( D35 . ( C26 . 1 ) ) } by L144 , L157 , GRAPH_2:36;
L162: 1 <= ( len C27 ) by L151 , NAT_1:11;
L163: ( len C27 ) in ( dom C27 ) by L162 , FINSEQ_3:25;
L164: ( C27 . ( len C27 ) ) in ( rng C27 ) by L163 , FUNCT_1:def 3;
L165: (( C27 . ( len C27 ) ) = ( D34 . ( C26 . 1 ) ) or ( C27 . ( len C27 ) ) = ( D35 . ( C26 . 1 ) )) by L164 , L161 , TARSKI:def 2;
L166: ( rng C28 ) = { ( D34 . ( C26 . 1 ) ) , ( D35 . ( C26 . 1 ) ) } by L145 , L157 , GRAPH_2:36;
L167: 1 in ( dom C28 ) by L151 , L152 , L162 , FINSEQ_3:25;
L168: ( C28 . 1 ) in ( rng C27 ) by L167 , L161 , L166 , FUNCT_1:def 3;
L169: (( C28 . 1 ) = ( D34 . ( C26 . 1 ) ) or ( C28 . 1 ) = ( D35 . ( C26 . 1 ) )) by L168 , L161 , TARSKI:def 2;
L170: 1 in ( dom C27 ) by L162 , FINSEQ_3:25;
L171: ( C27 . 1 ) in ( rng C27 ) by L170 , FUNCT_1:def 3;
L172: (( C27 . 1 ) = ( D34 . ( C26 . 1 ) ) or ( C27 . 1 ) = ( D35 . ( C26 . 1 ) )) by L171 , L161 , TARSKI:def 2;
thus L173: thesis by L172 , L146 , L151 , L152 , L158 , L161 , L166 , L162 , L165 , L169 , GRAPH_2:21;
end;
thus L174: thesis by L159 , L146;
end;
end;
thus L176: thesis by L153;
end;
end;
theorem
L178: (for B18 being Graph holds (for B19 being (Chain of B18) holds (for B20 being (FinSequence of (the carrier of B18)) holds ((B19 is  cyclic & B20 is_vertex_seq_of B19) implies ( B20 . 1 ) = ( B20 . ( len B20 ) ))))) by L142;
theorem
L179: (for B21 being Graph holds (for B22 being set holds (B22 in (the carrier' of B21) implies (for B23 being  directed (Chain of B21) holds (B23 = <* B22 *> implies ( vertex-seq B23 ) = <* ( (the Source of B21) . B22 ) , ( (the Target of B21) . B22 ) *>)))))
proof
let C29 being Graph;
let C30 being set;
assume L180: C30 in (the carrier' of C29);
reconsider D36 = ( (the Source of C29) . C30 ) , D37 = ( (the Target of C29) . C30 ) as (Element of (the carrier of C29)) by L180 , FUNCT_2:5;
reconsider D38 = <* D36 , D37 *> as (FinSequence of (the carrier of C29));
let C31 being  directed (Chain of C29);
assume L181: C31 = <* C30 *>;
L182: ( len C31 ) = 1 by L181 , FINSEQ_1:39;
L183: D38 is_vertex_seq_of C31
proof
thus L184: ( len D38 ) = ( ( len C31 ) + 1 ) by L182 , FINSEQ_1:44;
let R4 being (Element of ( NAT ));
L185: ( D38 /. 2 ) = D37 by FINSEQ_4:17;
assume L186: (1 <= R4 & R4 <= ( len C31 ));
L187: R4 = 1 by L186 , L182 , XXREAL_0:1;
L188: (C30 joins D36 , D37 & ( D38 /. 1 ) = D36) by FINSEQ_4:17 , GRAPH_1:def 12;
thus L189: thesis by L188 , L181 , L187 , L185 , FINSEQ_1:40;
end;
L190: C30 = ( C31 . 1 ) by L181 , FINSEQ_1:40;
L191: ( D38 . 1 ) = ( (the Source of C29) . ( C31 . 1 ) ) by L190 , FINSEQ_1:44;
thus L192: thesis by L191 , L181 , L183 , GRAPH_2:def 10;
end;
theorem
L193: (for R3 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds (for B24 being FinSequence holds ( len ( (R3 , R4) -cut B24 ) ) <= ( len B24 ))))
proof
let R3 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
let C32 being FinSequence;
set D39 = ( len ( (R3 , R4) -cut C32 ) );
set D40 = ( len C32 );
per cases ;
suppose L194: (1 <= R3 & R3 <= R4 & R4 <= ( len C32 ));

L195: ( D39 + R3 ) = ( R4 + 1 ) by L194 , GRAPH_2:def 1;
L196: ( R4 + ( D39 + R3 ) ) <= ( ( R4 + 1 ) + D40 ) by L195 , L194 , XREAL_1:6;
L197: ( R4 + ( D39 + R3 ) ) <= ( R4 + ( 1 + D40 ) ) by L196;
L198: ( D39 + R3 ) <= ( 1 + D40 ) by L197 , XREAL_1:6;
L199: ( ( D39 + R3 ) + 1 ) <= ( R3 + ( 1 + D40 ) ) by L198 , L194 , XREAL_1:7;
L200: ( D39 + ( R3 + 1 ) ) <= ( ( R3 + 1 ) + D40 ) by L199;
thus L201: thesis by L200 , XREAL_1:6;
end;
suppose L202: (not (1 <= R3 & R3 <= R4 & R4 <= ( len C32 )));

L203: ( (R3 , R4) -cut C32 ) is  empty by L202 , GRAPH_2:def 1;
thus L204: thesis by L203;
end;
end;
theorem
L206: (for R3 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds (for R5 being non  void Graph holds (for B25 being  directed (Chain of R5) holds ((1 <= R3 & R3 <= R4 & R4 <= ( len B25 )) implies ( (R3 , R4) -cut B25 ) is  directed  directed  directed  directed (Chain of R5))))))
proof
let R3 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
let R5 being non  void Graph;
let C33 being  directed (Chain of R5);
assume that
L207: 1 <= R3
and
L208: R3 <= R4
and
L209: R4 <= ( len C33 );
reconsider D41 = ( (R3 , R4) -cut C33 ) as (Chain of R5) by L207 , L208 , L209 , GRAPH_2:41;
L210: ( ( len D41 ) + R3 ) = ( R4 + 1 ) by L207 , L208 , L209 , GRAPH_2:def 1;
L211:
now
L212: ( ( len D41 ) + R3 ) <= ( ( len C33 ) + 1 ) by L209 , L210 , XREAL_1:6;
let R2 being (Element of ( NAT ));
assume that
L213: 1 <= R2
and
L214: R2 < ( len D41 );
L215: ( ( 0 ) + 1 ) <= R2 by L213;
consider C34 being (Element of ( NAT )) such that L216: ( 0 ) <= C34 and L217: C34 < ( len D41 ) and L218: R2 = ( C34 + 1 ) by L215 , L214 , GRAPH_2:1;
L219: 1 <= ( R3 + C34 ) by L207 , NAT_1:12;
L220: ( R3 + ( C34 + 1 ) ) < ( ( len D41 ) + R3 ) by L214 , L218 , XREAL_1:6;
L221: ( ( R3 + C34 ) + 1 ) < ( ( len C33 ) + 1 ) by L220 , L212 , XXREAL_0:2;
L222: ( R3 + C34 ) < ( len C33 ) by L221 , XREAL_1:6;
L223: ( D41 . ( R2 + 1 ) ) = ( C33 . ( R3 + R2 ) ) by L207 , L208 , L209 , L214 , GRAPH_2:def 1;
L224: (( D41 . ( C34 + 1 ) ) = ( C33 . ( R3 + C34 ) ) & ( R3 + R2 ) = ( ( R3 + C34 ) + 1 )) by L207 , L208 , L209 , L217 , L218 , GRAPH_2:def 1;
thus L225: ( (the Source of R5) . ( D41 . ( R2 + 1 ) ) ) = ( (the Target of R5) . ( D41 . R2 ) ) by L224 , L223 , L219 , L222 , GRAPH_1:def 15;
end;
thus L226: thesis by L211 , GRAPH_1:def 15;
end;
theorem
L227: (for R5 being non  void Graph holds (for B26 being non  empty  directed (Chain of R5) holds ( len ( vertex-seq B26 ) ) = ( ( len B26 ) + 1 )))
proof
let R5 being non  void Graph;
let C35 being non  empty  directed (Chain of R5);
L228: ( vertex-seq C35 ) is_vertex_seq_of C35 by GRAPH_2:def 10;
thus L229: thesis by L228 , GRAPH_2:def 6;
end;
registration
let R5 being non  void Graph;
let C36 being  directed non  empty (Chain of R5);
cluster ( vertex-seq C36 ) -> non  empty;
coherence
proof
L230: ( len ( vertex-seq C36 ) ) = ( ( len C36 ) + 1 ) by L227;
thus L231: thesis by L230;
end;
end;
theorem
L233: (for R5 being non  void Graph holds (for B27 being  directed non  empty (Chain of R5) holds (for R4 being (Element of ( NAT )) holds ((1 <= R4 & R4 <= ( len B27 )) implies (( ( vertex-seq B27 ) . R4 ) = ( (the Source of R5) . ( B27 . R4 ) ) & ( ( vertex-seq B27 ) . ( R4 + 1 ) ) = ( (the Target of R5) . ( B27 . R4 ) ))))))
proof
let R5 being non  void Graph;
let C37 being  directed non  empty (Chain of R5);
set D42 = ( vertex-seq C37 );
set D43 = (the Source of R5);
set D44 = (the Target of R5);
defpred S1[ (Element of ( NAT )) ] means ((1 <= $1 & $1 <= ( len C37 )) implies (( D42 . $1 ) = ( D43 . ( C37 . $1 ) ) & ( D42 . ( $1 + 1 ) ) = ( D44 . ( C37 . $1 ) )));
L234: (for B28 being (Element of ( NAT )) holds (S1[ B28 ] implies S1[ ( B28 + 1 ) ]))
proof
let R4 being (Element of ( NAT ));
assume L235: ((1 <= R4 & R4 <= ( len C37 )) implies (( D42 . R4 ) = ( D43 . ( C37 . R4 ) ) & ( D42 . ( R4 + 1 ) ) = ( D44 . ( C37 . R4 ) )));
L236: D42 is_vertex_seq_of C37 by GRAPH_2:def 10;
assume that
L237: 1 <= ( R4 + 1 )
and
L238: ( R4 + 1 ) <= ( len C37 );
per cases ;
suppose L239: R4 = ( 0 );

thus L240: ( D42 . ( R4 + 1 ) ) = ( D43 . ( C37 . ( R4 + 1 ) ) ) by L239 , GRAPH_2:def 10;
L241: (( D42 /. 1 ) = ( D42 /. ( 1 + 1 ) ) or ( D42 /. 1 ) <> ( D42 /. ( 1 + 1 ) ));
L242: 1 in ( dom D42 ) by FINSEQ_5:6;
L243: ( D42 /. 1 ) = ( D42 . 1 ) by L242 , PARTFUN1:def 6;
L244: 1 <= ( len C37 ) by L237 , L238 , XXREAL_0:2;
L245: ( len D42 ) = ( ( len C37 ) + 1 ) by L227;
L246: ( 1 + 1 ) <= ( len D42 ) by L245 , L244 , XREAL_1:6;
L247: ( 1 + 1 ) in ( dom D42 ) by L246 , FINSEQ_3:25;
L248: ( D42 /. ( 1 + 1 ) ) = ( D42 . ( 1 + 1 ) ) by L247 , PARTFUN1:def 6;
L249: ( C37 . 1 ) joins ( D42 /. 1 ) , ( D42 /. ( 1 + 1 ) ) by L236 , L244 , GRAPH_2:def 6;
thus L250: thesis by L249 , L239 , L240 , L241 , L243 , L248 , GRAPH_1:def 12;
end;
suppose L251: R4 <> ( 0 );

L252: R4 < ( len C37 ) by L238 , NAT_1:13;
L253: 1 <= R4 by L251 , NAT_1:14;
thus L254: ( D42 . ( R4 + 1 ) ) = ( D43 . ( C37 . ( R4 + 1 ) ) ) by L253 , L235 , L252 , GRAPH_1:def 15;
L255: (( D42 /. ( R4 + 1 ) ) = ( D42 /. ( ( R4 + 1 ) + 1 ) ) or ( D42 /. ( R4 + 1 ) ) <> ( D42 /. ( ( R4 + 1 ) + 1 ) ));
L256: ( len D42 ) = ( ( len C37 ) + 1 ) by L227;
L257: (1 <= ( ( R4 + 1 ) + 1 ) & ( ( R4 + 1 ) + 1 ) <= ( len D42 )) by L256 , L238 , NAT_1:11 , XREAL_1:6;
L258: ( ( R4 + 1 ) + 1 ) in ( dom D42 ) by L257 , FINSEQ_3:25;
L259: ( D42 /. ( ( R4 + 1 ) + 1 ) ) = ( D42 . ( ( R4 + 1 ) + 1 ) ) by L258 , PARTFUN1:def 6;
L260: R4 <= ( R4 + 1 ) by NAT_1:11;
L261: R4 <= ( len C37 ) by L260 , L238 , XXREAL_0:2;
L262: ( R4 + 1 ) <= ( len D42 ) by L261 , L256 , XREAL_1:6;
L263: ( R4 + 1 ) in ( dom D42 ) by L262 , L237 , FINSEQ_3:25;
L264: ( D42 /. ( R4 + 1 ) ) = ( D42 . ( R4 + 1 ) ) by L263 , PARTFUN1:def 6;
L265: ( C37 . ( R4 + 1 ) ) joins ( D42 /. ( R4 + 1 ) ) , ( D42 /. ( ( R4 + 1 ) + 1 ) ) by L237 , L238 , L236 , GRAPH_2:def 6;
thus L266: thesis by L265 , L254 , L255 , L264 , L259 , GRAPH_1:def 12;
end;
end;
L268: S1[ ( 0 ) ];
thus L269: (for R4 being (Element of ( NAT )) holds S1[ R4 ]) from NAT_1:sch 1(L268 , L234);
end;
theorem
L270: (for R3 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds (for B29 being non  empty FinSequence holds ((1 <= R3 & R3 <= R4 & R4 <= ( len B29 )) implies ( (R3 , R4) -cut B29 ) is non  empty))))
proof
let R3 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
let C38 being non  empty FinSequence;
set D45 = ( len ( (R3 , R4) -cut C38 ) );
assume L271: (1 <= R3 & R3 <= R4 & R4 <= ( len C38 ));
L272: (R3 < ( R4 + 1 ) & ( D45 + R3 ) = ( R4 + 1 )) by L271 , GRAPH_2:def 1 , NAT_1:13;
L273: ( R3 - ( D45 + R3 ) ) < ( ( R4 + 1 ) - ( R4 + 1 ) ) by L272 , XREAL_1:9;
L274: ( - ( - D45 ) ) > ( 0 ) by L273;
thus L275: thesis by L274;
end;
theorem
L276: (for R3 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds (for R5 being non  void Graph holds (for B30 , B31 being  directed (Chain of R5) holds ((1 <= R3 & R3 <= R4 & R4 <= ( len B30 ) & B31 = ( (R3 , R4) -cut B30 )) implies ( vertex-seq B31 ) = ( (R3 , ( R4 + 1 )) -cut ( vertex-seq B30 ) ))))))
proof
let R3 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
let R5 being non  void Graph;
let C39 , C40 being  directed (Chain of R5);
assume that
L277: 1 <= R3
and
L278: R3 <= R4
and
L279: R4 <= ( len C39 )
and
L280: C40 = ( (R3 , R4) -cut C39 );
set D46 = ( (R3 , ( R4 + 1 )) -cut ( vertex-seq C39 ) );
L281: C39 is non  empty by L277 , L278 , L279;
L282: ( vertex-seq C39 ) is_vertex_seq_of C39 by L281 , GRAPH_2:def 10;
L283: D46 is_vertex_seq_of C40 by L282 , L277 , L278 , L279 , L280 , GRAPH_2:42;
set D47 = ( vertex-seq C39 );
L284: R3 <= ( R4 + 1 ) by L278 , NAT_1:12;
L285: ( len D47 ) = ( ( len C39 ) + 1 ) by L282 , GRAPH_2:def 6;
L286: ( R4 + 1 ) <= ( len D47 ) by L285 , L279 , XREAL_1:6;
L287: C40 is non  empty by L277 , L278 , L279 , L280 , L281 , L270;
L288: ( 0 ) < ( len C40 ) by L287;
L289: ( C40 . ( ( 0 ) + 1 ) ) = ( C39 . ( R3 + ( 0 ) ) ) by L288 , L277 , L278 , L279 , L280 , GRAPH_2:def 1;
L290: R3 <= ( R4 + 1 ) by L278 , NAT_1:12;
L291: D47 is non  empty by L285;
L292: D46 is non  empty by L291 , L277 , L284 , L286 , L270;
L293: ( 0 ) < ( len D46 ) by L292;
L294: ( D47 . ( R3 + ( 0 ) ) ) = ( D46 . ( ( 0 ) + 1 ) ) by L293 , L277 , L286 , L290 , GRAPH_2:def 1;
L295: R3 <= ( len C39 ) by L278 , L279 , XXREAL_0:2;
L296: ( D46 . 1 ) = ( (the Source of R5) . ( C40 . 1 ) ) by L295 , L277 , L281 , L289 , L294 , L233;
thus L297: thesis by L296 , L283 , L287 , GRAPH_2:def 10;
end;
theorem
L298: (for R5 being non  void Graph holds (for B32 being  directed non  empty (Chain of R5) holds ( ( vertex-seq B32 ) . ( ( len B32 ) + 1 ) ) = ( (the Target of R5) . ( B32 . ( len B32 ) ) )))
proof
let R5 being non  void Graph;
let C41 being  directed non  empty (Chain of R5);
L299: 1 in ( dom C41 ) by FINSEQ_5:6;
L300: 1 <= ( len C41 ) by L299 , FINSEQ_3:25;
thus L301: thesis by L300 , L233;
end;
theorem
L302: (for R5 being non  void Graph holds (for B33 , B34 being  directed non  empty (Chain of R5) holds (( ( vertex-seq B33 ) . ( ( len B33 ) + 1 ) ) = ( ( vertex-seq B34 ) . 1 ) iff ( B33 ^ B34 ) is  directed non  empty  directed non  empty  directed non  empty  directed non  empty (Chain of R5))))
proof
let R5 being non  void Graph;
let C42 , C43 being  directed non  empty (Chain of R5);
set D48 = ( vertex-seq C42 );
set D49 = ( vertex-seq C43 );
L303: ( len ( C42 ^ C43 ) ) = ( ( len C42 ) + ( len C43 ) ) by FINSEQ_1:22;
L304: D48 is_vertex_seq_of C42 by GRAPH_2:def 10;
L305: (D49 is_vertex_seq_of C43 & ( len D48 ) = ( ( len C42 ) + 1 )) by L304 , GRAPH_2:def 6 , GRAPH_2:def 10;
thus L306:now
assume L307: ( ( vertex-seq C42 ) . ( ( len C42 ) + 1 ) ) = ( ( vertex-seq C43 ) . 1 );
reconsider D50 = ( C42 ^ C43 ) as (Chain of R5) by L307 , L304 , L305 , GRAPH_2:43;
L308: D50 is  directed
proof
let R4 being (Element of ( NAT ));
assume that
L309: 1 <= R4
and
L310: R4 < ( len D50 );
per cases  by XXREAL_0:1;
suppose L311: R4 < ( len C42 );

L312: (1 <= ( R4 + 1 ) & ( R4 + 1 ) <= ( len C42 )) by L311 , NAT_1:11 , NAT_1:13;
L313: ( R4 + 1 ) in ( dom C42 ) by L312 , FINSEQ_3:25;
L314: ( D50 . ( R4 + 1 ) ) = ( C42 . ( R4 + 1 ) ) by L313 , FINSEQ_1:def 7;
L315: R4 in ( dom C42 ) by L309 , L311 , FINSEQ_3:25;
L316: ( D50 . R4 ) = ( C42 . R4 ) by L315 , FINSEQ_1:def 7;
thus L317: thesis by L316 , L309 , L311 , L314 , GRAPH_1:def 15;
end;
suppose L318: R4 = ( len C42 );

L319: R4 in ( dom C42 ) by L318 , FINSEQ_5:6;
L320: ( D50 . R4 ) = ( C42 . R4 ) by L319 , FINSEQ_1:def 7;
L321: 1 in ( dom C43 ) by FINSEQ_5:6;
L322: ( D50 . ( R4 + 1 ) ) = ( C43 . 1 ) by L321 , L318 , FINSEQ_1:def 7;
L323: ( D48 . ( ( len C42 ) + 1 ) ) = ( (the Target of R5) . ( C42 . ( len C42 ) ) ) by L298;
thus L324: thesis by L323 , L307 , L318 , L322 , L320 , GRAPH_2:def 10;
end;
suppose L325: R4 > ( len C42 );

reconsider D51 = ( R4 - ( len C42 ) ) as (Element of ( NAT )) by L325 , INT_1:5;
L326: R4 = ( ( len C42 ) + D51 );
L327: ( R4 + 1 ) = ( ( len C42 ) + ( D51 + 1 ) );
L328: D51 < ( len C43 ) by L303 , L310 , XREAL_1:19;
L329: (1 <= ( D51 + 1 ) & ( D51 + 1 ) <= ( len C43 )) by L328 , NAT_1:11 , NAT_1:13;
L330: ( D51 + 1 ) in ( dom C43 ) by L329 , FINSEQ_3:25;
L331: ( D50 . ( R4 + 1 ) ) = ( C43 . ( D51 + 1 ) ) by L330 , L327 , FINSEQ_1:def 7;
L332: R4 >= ( ( len C42 ) + 1 ) by L325 , NAT_1:13;
L333: 1 <= D51 by L332 , XREAL_1:19;
L334: D51 in ( dom C43 ) by L333 , L328 , FINSEQ_3:25;
L335: ( D50 . R4 ) = ( C43 . D51 ) by L334 , L326 , FINSEQ_1:def 7;
thus L336: thesis by L335 , L333 , L328 , L331 , GRAPH_1:def 15;
end;
end;
thus L338: ( C42 ^ C43 ) is  directed non  empty  directed non  empty  directed non  empty  directed non  empty (Chain of R5) by L308;
end;
set D52 = ( len C42 );
assume L339: ( C42 ^ C43 ) is  directed non  empty  directed non  empty  directed non  empty  directed non  empty (Chain of R5);
reconsider D53 = ( C42 ^ C43 ) as  directed non  empty (Chain of R5) by L339;
L340: D52 < ( len D53 ) by L303 , XREAL_1:29;
L341: D52 in ( dom C42 ) by FINSEQ_5:6;
L342: ( D53 . D52 ) = ( C42 . D52 ) by L341 , FINSEQ_1:def 7;
L343: 1 <= D52 by L341 , FINSEQ_3:25;
L344: ( (the Source of R5) . ( D53 . ( D52 + 1 ) ) ) = ( (the Target of R5) . ( D53 . D52 ) ) by L343 , L340 , GRAPH_1:def 15;
L345: 1 in ( dom C43 ) by FINSEQ_5:6;
L346: ( D53 . ( D52 + 1 ) ) = ( C43 . 1 ) by L345 , FINSEQ_1:def 7;
L347: ( D48 . ( ( len C42 ) + 1 ) ) = ( (the Target of R5) . ( C42 . ( len C42 ) ) ) by L298;
thus L348: thesis by L347 , L344 , L346 , L342 , GRAPH_2:def 10;
end;
theorem
L349: (for R5 being non  void Graph holds (for B35 , B36 , B37 being  directed non  empty (Chain of R5) holds (B35 = ( B36 ^ B37 ) implies (( ( vertex-seq B35 ) . 1 ) = ( ( vertex-seq B36 ) . 1 ) & ( ( vertex-seq B35 ) . ( ( len B35 ) + 1 ) ) = ( ( vertex-seq B37 ) . ( ( len B37 ) + 1 ) )))))
proof
let R5 being non  void Graph;
let C44 , C45 , C46 being  directed non  empty (Chain of R5);
L350: 1 in ( dom C44 ) by FINSEQ_5:6;
L351: 1 <= ( len C44 ) by L350 , FINSEQ_3:25;
L352: (( ( vertex-seq C44 ) . 1 ) = ( (the Source of R5) . ( C44 . 1 ) ) & ( ( vertex-seq C44 ) . ( ( len C44 ) + 1 ) ) = ( (the Target of R5) . ( C44 . ( len C44 ) ) )) by L351 , L233;
L353: 1 in ( dom C45 ) by FINSEQ_5:6;
L354: 1 <= ( len C45 ) by L353 , FINSEQ_3:25;
L355: ( ( vertex-seq C45 ) . 1 ) = ( (the Source of R5) . ( C45 . 1 ) ) by L354 , L233;
L356: 1 in ( dom C46 ) by FINSEQ_5:6;
L357: 1 <= ( len C46 ) by L356 , FINSEQ_3:25;
L358: ( ( vertex-seq C46 ) . ( ( len C46 ) + 1 ) ) = ( (the Target of R5) . ( C46 . ( len C46 ) ) ) by L357 , L233;
assume L359: C44 = ( C45 ^ C46 );
L360: (( len C46 ) in ( dom C46 ) & ( len C44 ) = ( ( len C45 ) + ( len C46 ) )) by L359 , FINSEQ_1:22 , FINSEQ_5:6;
thus L361: thesis by L360 , L359 , L353 , L355 , L352 , L358 , FINSEQ_1:def 7;
end;
theorem
L362: (for R5 being non  void Graph holds (for B38 being  directed non  empty (Chain of R5) holds (B38 is  cyclic implies ( ( vertex-seq B38 ) . 1 ) = ( ( vertex-seq B38 ) . ( ( len B38 ) + 1 ) ))))
proof
let R5 being non  void Graph;
let C47 being  directed non  empty (Chain of R5);
assume L363: C47 is  cyclic;
set D54 = ( vertex-seq C47 );
L364: D54 is_vertex_seq_of C47 by GRAPH_2:def 10;
L365: ( len D54 ) = ( ( len C47 ) + 1 ) by L364 , GRAPH_2:def 6;
thus L366: thesis by L365 , L363 , L364 , L178;
end;
theorem
L367: (for R5 being non  void Graph holds (for B39 being  directed non  empty (Chain of R5) holds (B39 is  cyclic implies (for R4 being (Element of ( NAT )) holds (ex B40 being  directed (Chain of R5) st (( len B40 ) = R4 & ( B40 ^ B39 ) is  directed non  empty  directed non  empty  directed non  empty  directed non  empty (Chain of R5)))))))
proof
let R5 being non  void Graph;
let C48 being  directed non  empty (Chain of R5);
defpred S2[ (Element of ( NAT )) ] means (ex B41 being  directed (Chain of R5) st (( rng B41 ) c= ( rng C48 ) & ( len B41 ) = $1 & ( B41 ^ C48 ) is  directed non  empty  directed non  empty  directed non  empty  directed non  empty (Chain of R5)));
L368: C48 is (FinSequence of (the carrier' of R5)) by L1;
L369: ( rng C48 ) c= (the carrier' of R5) by L368 , FINSEQ_1:def 4;
assume L370: C48 is  cyclic;
L371: (for B42 being (Element of ( NAT )) holds (S2[ B42 ] implies S2[ ( B42 + 1 ) ]))
proof
L372: ( len C48 ) in ( dom C48 ) by FINSEQ_5:6;
L373: ( C48 . ( len C48 ) ) in ( rng C48 ) by L372 , FUNCT_1:def 3;
reconsider D55 = ( C48 . ( len C48 ) ) as (Element of (the carrier' of R5)) by L373 , L369;
reconsider D56 = <* D55 *> as  directed (Chain of R5) by L128;
L374: ( rng D56 ) = { ( C48 . ( len C48 ) ) } by FINSEQ_1:38;
L375: ( rng D56 ) c= ( rng C48 ) by L374 , L373 , ZFMISC_1:31;
L376: ( len D56 ) = 1 by FINSEQ_1:39;
let C49 being (Element of ( NAT ));
given C50 being  directed (Chain of R5) such that
L377: ( rng C50 ) c= ( rng C48 )
and
L378: ( len C50 ) = C49
and
L379: ( C50 ^ C48 ) is  directed non  empty  directed non  empty  directed non  empty  directed non  empty (Chain of R5);

per cases ;
suppose L380: C49 = ( 0 );

take D56;
thus L381: ( rng D56 ) c= ( rng C48 ) by L373 , L374 , ZFMISC_1:31;
thus L382: ( len D56 ) = ( C49 + 1 ) by L380 , FINSEQ_1:39;
set D57 = ( vertex-seq D56 );
L383: D57 = <* ( (the Source of R5) . D55 ) , ( (the Target of R5) . D55 ) *> by L179;
L384: ( D57 . ( ( len D56 ) + 1 ) ) = ( (the Target of R5) . D55 ) by L383 , L376 , FINSEQ_1:44
.= ( ( vertex-seq C48 ) . ( ( len C48 ) + 1 ) ) by L298
.= ( ( vertex-seq C48 ) . 1 ) by L370 , L362;
thus L385: thesis by L384 , L302;
end;
suppose L386: C49 <> ( 0 );

L387: C50 is non  empty by L386 , L378;
L388: 1 in ( dom C50 ) by L387 , FINSEQ_5:6;
L389: ( C50 . 1 ) in ( rng C50 ) by L388 , FUNCT_1:def 3;
consider C51 being Nat such that L390: C51 in ( dom C48 ) and L391: ( C48 . C51 ) = ( C50 . 1 ) by L389 , L377 , FINSEQ_2:10;
L392: C51 <= ( len C48 ) by L390 , FINSEQ_3:25;
L393: 1 <= C51 by L390 , FINSEQ_3:25;
L394:
now
per cases ;
suppose L395: C51 = 1;

set D58 = ( vertex-seq D56 );
L396: D58 = <* ( (the Source of R5) . D55 ) , ( (the Target of R5) . D55 ) *> by L179;
L397: ( D58 . ( ( len D56 ) + 1 ) ) = ( (the Target of R5) . D55 ) by L396 , L376 , FINSEQ_1:44
.= ( ( vertex-seq C48 ) . ( ( len C48 ) + 1 ) ) by L298
.= ( ( vertex-seq C48 ) . 1 ) by L370 , L362
.= ( (the Source of R5) . ( C50 . 1 ) ) by L391 , L395 , GRAPH_2:def 10
.= ( ( vertex-seq C50 ) . 1 ) by L387 , GRAPH_2:def 10;
reconsider D59 = ( D56 ^ C50 ) as  directed (Chain of R5) by L397 , L387 , L302;
take D60 = D59;
L398: ( rng D60 ) = ( ( rng D56 ) \/ ( rng C50 ) ) by FINSEQ_1:31;
thus L399: ( rng D60 ) c= ( rng C48 ) by L398 , L377 , L375 , XBOOLE_1:8;
thus L400: ( len D60 ) = ( C49 + 1 ) by L378 , L376 , FINSEQ_1:22;
L401: ( ( vertex-seq D60 ) . ( ( len D60 ) + 1 ) ) = ( ( vertex-seq C50 ) . ( ( len C50 ) + 1 ) ) by L387 , L349
.= ( ( vertex-seq C48 ) . 1 ) by L379 , L387 , L302;
thus L402: ( D60 ^ C48 ) is  directed non  empty  directed non  empty  directed non  empty  directed non  empty (Chain of R5) by L401 , L302;
end;
suppose L403: C51 <> 1;

L404: 1 < C51 by L403 , L393 , XXREAL_0:1;
L405: ( 1 + 1 ) <= C51 by L404 , NAT_1:13;
consider C52 being (Element of ( NAT )) such that L406: (1 <= C52 & C52 < ( len C48 )) and L407: C51 = ( C52 + 1 ) by L405 , L392 , GRAPH_2:1;
L408: C52 in ( dom C48 ) by L406 , FINSEQ_3:25;
L409: ( C48 . C52 ) in ( rng C48 ) by L408 , FUNCT_1:def 3;
reconsider D61 = ( C48 . C52 ) as (Element of (the carrier' of R5)) by L409 , L369;
reconsider D62 = <* D61 *> as  directed (Chain of R5) by L128;
set D63 = ( vertex-seq D62 );
L410: ( len D62 ) = 1 by FINSEQ_1:39;
L411: D63 = <* ( (the Source of R5) . D61 ) , ( (the Target of R5) . D61 ) *> by L179;
L412: ( D63 . ( ( len D62 ) + 1 ) ) = ( (the Target of R5) . D61 ) by L411 , L410 , FINSEQ_1:44
.= ( (the Source of R5) . ( C50 . 1 ) ) by L391 , L406 , L407 , GRAPH_1:def 15
.= ( ( vertex-seq C50 ) . 1 ) by L387 , GRAPH_2:def 10;
reconsider D64 = ( D62 ^ C50 ) as  directed (Chain of R5) by L412 , L387 , L302;
take D65 = D64;
L413: ( rng D62 ) = { ( C48 . C52 ) } by FINSEQ_1:38;
L414: ( rng D62 ) c= ( rng C48 ) by L413 , L409 , ZFMISC_1:31;
L415: ( rng D65 ) = ( ( rng D62 ) \/ ( rng C50 ) ) by FINSEQ_1:31;
thus L416: ( rng D65 ) c= ( rng C48 ) by L415 , L377 , L414 , XBOOLE_1:8;
thus L417: ( len D65 ) = ( C49 + 1 ) by L378 , L410 , FINSEQ_1:22;
L418: ( ( vertex-seq D65 ) . ( ( len D65 ) + 1 ) ) = ( ( vertex-seq C50 ) . ( ( len C50 ) + 1 ) ) by L387 , L349
.= ( ( vertex-seq C48 ) . 1 ) by L379 , L387 , L302;
thus L419: ( D65 ^ C48 ) is  directed non  empty  directed non  empty  directed non  empty  directed non  empty (Chain of R5) by L418 , L302;
end;
end;
thus L421: thesis by L394;
end;
end;
let C53 being (Element of ( NAT ));
L423: S2[ ( 0 ) ]
proof
reconsider D66 = ( {} ) as  empty (Chain of R5) by GRAPH_1:14;
reconsider D67 = D66 as  directed (Chain of R5);
take D67;
L424: ( rng D67 ) = ( {} );
thus L425: ( rng D67 ) c= ( rng C48 ) by L424 , XBOOLE_1:2;
thus L426: ( len D67 ) = ( 0 );
thus L427: thesis by FINSEQ_1:34;
end;
L428: (for B43 being (Element of ( NAT )) holds S2[ B43 ]) from NAT_1:sch 1(L423 , L371);
L429: (ex B44 being  directed (Chain of R5) st (( rng B44 ) c= ( rng C48 ) & ( len B44 ) = C53 & ( B44 ^ C48 ) is  directed non  empty  directed non  empty  directed non  empty  directed non  empty (Chain of R5))) by L428;
thus L430: thesis by L429;
end;
definition
let C54 being Graph;
attr C54 is  directed_cycle-less
means
:L431: (for B45 being  directed (Chain of C54) holds (B45 is non  empty implies B45 is non  cyclic));
end;
notation
let C55 being Graph;
antonym C55 is  with_directed_cycle for C55 is  directed_cycle-less;
end;
registration
cluster  void ->  directed_cycle-less for Graph;
coherence
proof
let C56 being Graph;
assume L434: C56 is  void;
let C57 being  directed (Chain of C56);
assume L435: C57 is non  empty;
L436: C57 is (FinSequence of (the carrier' of C56)) by L1;
thus L437: thesis by L436 , L434 , L435;
end;
end;
definition
let C58 being Graph;
attr C58 is  well-founded
means
:L439: (for B46 being (Element of (the carrier of C58)) holds (ex R4 being (Element of ( NAT )) st (for B47 being  directed (Chain of C58) holds ((B47 is non  empty & ( ( vertex-seq B47 ) . ( ( len B47 ) + 1 ) ) = B46) implies ( len B47 ) <= R4))));
end;
registration
let C59 being  void Graph;
cluster  ->  empty for (Chain of C59);
coherence
proof
let C60 being (Chain of C59);
assume L441: C60 is non  empty;
L442: C60 is (FinSequence of (the carrier' of C59)) by L1;
thus L443: thesis by L442 , L441;
end;
end;
registration
cluster  void ->  well-founded for Graph;
coherence
proof
let C61 being Graph;
assume L445: C61 is  void;
reconsider D68 = C61 as  void Graph by L445;
let C62 being (Element of (the carrier of C61));
take ( 0 );
let C63 being  directed (Chain of C61);
reconsider D69 = C63 as (Chain of D68);
L446: D69 is  empty;
thus L447: thesis by L446;
end;
end;
registration
cluster non  well-founded -> non  void for Graph;
coherence;
end;
registration
cluster  well-founded for Graph;
existence
proof
set D70 = the  void Graph;
L450: D70 is  well-founded;
thus L451: thesis by L450;
end;
end;
registration
cluster  well-founded ->  directed_cycle-less for Graph;
coherence
proof
let C64 being Graph;
per cases ;
suppose L453: C64 is  void;

reconsider D71 = C64 as  void Graph by L453;
L454: D71 is  directed_cycle-less;
thus L455: thesis by L454;
end;
suppose L456: C64 is non  void;

reconsider D72 = C64 as non  void Graph by L456;
assume that
L457: C64 is  well-founded
and
L458: C64 is non  directed_cycle-less;
consider C65 being  directed (Chain of D72) such that L459: C65 is non  empty and L460: C65 is  cyclic by L458 , L431;
set D73 = ( vertex-seq C65 );
L461: ( len D73 ) = ( ( len C65 ) + 1 ) by L459 , L227;
L462: 1 <= ( len D73 ) by L461 , NAT_1:11;
L463: 1 in ( dom D73 ) by L462 , FINSEQ_3:25;
reconsider D74 = ( D73 . 1 ) as (Element of (the carrier of C64)) by L463 , FINSEQ_2:11;
consider R4 being (Element of ( NAT )) such that L464: (for B48 being  directed (Chain of D72) holds ((B48 is non  empty & ( ( vertex-seq B48 ) . ( ( len B48 ) + 1 ) ) = D74) implies ( len B48 ) <= R4)) by L457 , L439;
consider C66 being  directed (Chain of D72) such that L465: ( len C66 ) = ( R4 + 1 ) and L466: ( C66 ^ C65 ) is  directed non  empty  directed non  empty  directed non  empty  directed non  empty (Chain of D72) by L459 , L460 , L367;
reconsider D75 = C66 as  directed non  empty (Chain of D72) by L465;
reconsider D76 = ( D75 ^ C65 ) as  directed non  empty (Chain of D72) by L466;
L467: ( ( vertex-seq C65 ) . 1 ) = ( ( vertex-seq C65 ) . ( ( len C65 ) + 1 ) ) by L459 , L460 , L362;
L468: ( ( vertex-seq D76 ) . ( ( len D76 ) + 1 ) ) = D74 by L467 , L459 , L349;
L469: ( len D76 ) <= R4 by L468 , L464;
L470: ( len D76 ) = ( ( R4 + 1 ) + ( len C65 ) ) by L465 , FINSEQ_1:22;
L471: ( R4 + 1 ) <= ( len D76 ) by L470 , NAT_1:11;
thus L472: contradiction by L471 , L469 , NAT_1:13;
end;
end;
end;
registration
cluster non  well-founded for Graph;
existence
proof
set D77 = { 1 };
set D78 = { 1 };
reconsider D79 = 1 as (Element of D77) by TARSKI:def 1;
reconsider D80 = ( D78 --> D79 ) , D81 = ( D78 --> D79 ) as (Function of D78 , D77);
reconsider D82 = MultiGraphStruct (# D77 , D78 , D80 , D81 #) as Graph;
reconsider D83 = 1 as (Element of (the carrier of D82));
take D82;
L475: ( D80 . 1 ) = 1 by FUNCOP_1:7;
L476: D82 is  with_directed_cycle
proof
reconsider D84 = <* 1 *> as  directed (Chain of D82) by L128;
take D84;
thus L477: D84 is non  empty;
L478: (( <* D83 , D83 *> . 2 ) = D83 & ( len <* D83 , D83 *> ) = 2) by FINSEQ_1:44;
L479: (<* D83 , D83 *> is_vertex_seq_of D84 & ( <* D83 , D83 *> . 1 ) = D83) by L475 , L119 , FINSEQ_1:44;
thus L480: thesis by L479 , L478 , L57;
end;
assume L481: D82 is  well-founded;
reconsider D85 = D82 as  well-founded Graph by L481;
L482: D85 is  directed_cycle-less;
thus L483: contradiction by L482 , L476;
end;
end;
registration
cluster  directed_cycle-less for Graph;
existence
proof
set D86 = the  well-founded Graph;
L485: D86 is  directed_cycle-less;
thus L486: thesis by L485;
end;
end;
theorem
L488: (for B49 being DecoratedTree holds (for B50 being (Node of B49) holds (for B51 being (Element of ( NAT )) holds ( B50 | B51 ) is (Node of B49))))
proof
let C67 being DecoratedTree;
let C68 being (Node of C67);
let C69 being (Element of ( NAT ));
L489: ( C68 | C69 ) = ( C68 | ( Seg C69 ) ) by FINSEQ_1:def 15;
L490: ( C68 | C69 ) is_a_prefix_of C68 by L489 , TREES_1:def 1;
thus L491: thesis by L490 , TREES_1:20;
end;
begin
theorem
L492: (for B52 being non  void non  empty ManySortedSign holds (for B53 being  non-empty (ManySortedSet of (the carrier of B52)) holds (for B54 being (Term of B52 , B53) holds ((not B54 is  root) implies (ex B55 being (OperSymbol of B52) st ( B54 . ( {} ) ) = [ B55 , (the carrier of B52) ])))))
proof
let C70 being non  void non  empty ManySortedSign;
let C71 being  non-empty (ManySortedSet of (the carrier of C70));
let C72 being (Term of C70 , C71);
assume L493: (not C72 is  root);
per cases  by MSATERM:2;
suppose L494: (ex B56 being (SortSymbol of C70) st (ex B57 being (Element of ( C71 . B56 )) st ( C72 . ( {} ) ) = [ B57 , B56 ]));

consider C73 being (SortSymbol of C70), C74 being (Element of ( C71 . C73 )) such that L495: ( C72 . ( {} ) ) = [ C74 , C73 ] by L494;
L496: C72 = ( root-tree [ C74 , C73 ] ) by L495 , MSATERM:5;
thus L497: thesis by L496 , L493;
end;
suppose L498: ( C72 . ( {} ) ) in [: (the carrier' of C70) , { (the carrier of C70) } :];

consider C75 , C76 being set such that L499: C75 in (the carrier' of C70) and L500: (C76 in { (the carrier of C70) } & ( C72 . ( {} ) ) = [ C75 , C76 ]) by L498 , ZFMISC_1:def 2;
reconsider D87 = C75 as (OperSymbol of C70) by L499;
take D87;
thus L501: thesis by L500 , TARSKI:def 1;
end;
end;
theorem
L503: (for B58 being non  void non  empty ManySortedSign holds (for B59 being MSAlgebra over B58 holds (for B60 being (GeneratorSet of B59) holds (for B61 being (MSSubset of B59) holds (B60 c= B61 implies B61 is (GeneratorSet of B59))))))
proof
let C77 being non  void non  empty ManySortedSign;
let C78 being MSAlgebra over C77;
let C79 being (GeneratorSet of C78);
let C80 being (MSSubset of C78);
L504: C80 is (MSSubset of ( GenMSAlg C80 )) by MSUALG_2:def 17;
L505: C80 c= (the Sorts of ( GenMSAlg C80 )) by L504 , PBOOLE:def 18;
assume L506: C79 c= C80;
L507: C79 c= (the Sorts of ( GenMSAlg C80 )) by L506 , L505 , PBOOLE:13;
L508: C79 is (MSSubset of ( GenMSAlg C80 )) by L507 , PBOOLE:def 18;
L509: ( GenMSAlg C79 ) is (MSSubAlgebra of ( GenMSAlg C80 )) by L508 , MSUALG_2:def 17;
L510: (the Sorts of ( GenMSAlg C79 )) is (MSSubset of ( GenMSAlg C80 )) by L509 , MSUALG_2:def 9;
L511: (the Sorts of ( GenMSAlg C79 )) c= (the Sorts of ( GenMSAlg C80 )) by L510 , PBOOLE:def 18;
L512: (the Sorts of ( GenMSAlg C79 )) = (the Sorts of C78) by MSAFREE:def 4;
L513: (the Sorts of ( GenMSAlg C80 )) is (MSSubset of ( GenMSAlg C79 )) by L512 , MSUALG_2:def 9;
L514: (the Sorts of ( GenMSAlg C80 )) c= (the Sorts of ( GenMSAlg C79 )) by L513 , PBOOLE:def 18;
thus L515: (the Sorts of ( GenMSAlg C80 )) = (the Sorts of C78) by L514 , L512 , L511 , PBOOLE:146;
end;
registration
let C81 being non  void non  empty ManySortedSign;
let C82 being  finitely-generated  non-empty MSAlgebra over C81;
cluster  non-empty  finite-yielding for (GeneratorSet of C82);
existence
proof
consider C83 being (GeneratorSet of C82) such that L516: C83 is  finite-yielding by MSAFREE2:def 10;
consider C84 being (ManySortedSet of (the carrier of C81)) such that L517: C84 in (the Sorts of C82) by PBOOLE:134;
deffunc H1(set) = { ( C84 . $1 ) };
consider C85 being (ManySortedSet of (the carrier of C81)) such that L518: (for B62 being set holds (B62 in (the carrier of C81) implies ( C85 . B62 ) = H1(B62))) from PBOOLE:sch 4;
set D88 = ( C83 \/ C85 );
L519:
now
let C86 being set;
assume L520: C86 in (the carrier of C81);
L521: ( C84 . C86 ) in ( (the Sorts of C82) . C86 ) by L520 , L517 , PBOOLE:def 1;
L522: { ( C84 . C86 ) } c= ( (the Sorts of C82) . C86 ) by L521 , ZFMISC_1:31;
thus L523: ( C85 . C86 ) c= ( (the Sorts of C82) . C86 ) by L522 , L518 , L520;
end;
L524: (C83 c= (the Sorts of C82) & C85 c= (the Sorts of C82)) by L519 , PBOOLE:def 2 , PBOOLE:def 18;
L525: (C85 c= D88 & ( C83 \/ C85 ) c= (the Sorts of C82)) by L524 , PBOOLE:14 , PBOOLE:16;
L526:
now
let C87 being set;
assume L527: C87 in (the carrier of C81);
L528: ( C85 . C87 ) = { ( C84 . C87 ) } by L527 , L518;
thus L529: ( C85 . C87 ) is non  empty by L528;
end;
L530: C85 is  non-empty by L526 , PBOOLE:def 13;
reconsider D89 = D88 as  non-empty (MSSubset of C82) by L530 , L525 , PBOOLE:131 , PBOOLE:def 18;
L531: C83 c= D89 by PBOOLE:14;
reconsider D90 = D89 as (GeneratorSet of C82) by L531 , L503;
take D90;
thus L532: D90 is  non-empty;
let C88 being set;
assume L533: C88 in (the carrier of C81);
L534: ( C85 . C88 ) = { ( C84 . C88 ) } by L533 , L518;
L535: ( D90 . C88 ) = ( ( C83 . C88 ) \/ ( C85 . C88 ) ) by L533 , PBOOLE:def 4;
L536: ( C83 . C88 ) is  finite by L516;
thus L537: thesis by L536 , L534 , L535;
end;
end;
theorem
L539: (for B63 being non  void non  empty ManySortedSign holds (for B64 being  non-empty MSAlgebra over B63 holds (for B65 being  non-empty (GeneratorSet of B64) holds (ex B66 being (ManySortedFunction of ( FreeMSA B65 ) , B64) st B66 is_epimorphism ( FreeMSA B65 ) , B64))))
proof
let C89 being non  void non  empty ManySortedSign;
let C90 being  non-empty MSAlgebra over C89;
let C91 being  non-empty (GeneratorSet of C90);
reconsider D91 = C91 as (MSSubset of C90);
L540:
now
let C92 being set;
assume that
L541: C92 in (the carrier of C89);
L542: ( ( Reverse C91 ) . C92 ) is (Function of ( ( FreeGen C91 ) . C92 ) , ( C91 . C92 )) by L541 , PBOOLE:def 15;
L543: C91 c= (the Sorts of C90) by PBOOLE:def 18;
L544: ( C91 . C92 ) c= ( (the Sorts of C90) . C92 ) by L543 , L541 , PBOOLE:def 2;
thus L545: ( ( Reverse C91 ) . C92 ) is (Function of ( ( FreeGen C91 ) . C92 ) , ( (the Sorts of C90) . C92 )) by L544 , L541 , L542 , FUNCT_2:7;
end;
reconsider D92 = ( Reverse C91 ) as (ManySortedFunction of ( FreeGen C91 ) , (the Sorts of C90)) by L540 , PBOOLE:def 15;
L546: ( FreeGen C91 ) is  free by MSAFREE:16;
consider C93 being (ManySortedFunction of ( FreeMSA C91 ) , C90) such that L547: C93 is_homomorphism ( FreeMSA C91 ) , C90 and L548: ( C93 || ( FreeGen C91 ) ) = D92 by L546 , MSAFREE:def 5;
take C93;
thus L549: C93 is_homomorphism ( FreeMSA C91 ) , C90 by L547;
let C94 being set;
assume L550: C94 in (the carrier of C89);
reconsider D93 = C94 as (SortSymbol of C89) by L550;
set D94 = ( C93 . D93 );
consider C95 being (ManySortedFunction of ( FreeMSA C91 ) , ( Image C93 )) such that L551: C93 = C95 and L552: C95 is_epimorphism ( FreeMSA C91 ) , ( Image C93 ) by L547 , MSUALG_3:21;
L553: C95 is_homomorphism ( FreeMSA C91 ) , ( Image C93 ) by L552 , MSUALG_3:def 8;
L554: ( Image C95 ) = ( Image C93 ) by L553 , L552 , MSUALG_3:19;
L555: C91 is (MSSubset of ( Image C93 ))
proof
let C96 being set;
assume L556: C96 in (the carrier of C89);
reconsider D95 = C96 as (SortSymbol of C89) by L556;
L557: D95 in ( dom ( Reverse C91 ) ) by L556 , PARTFUN1:def 2;
L558: (( rngs ( Reverse C91 ) ) = C91 & ( ( rngs ( Reverse C91 ) ) . D95 ) = ( rng ( ( Reverse C91 ) . D95 ) )) by L557 , EXTENS_1:10 , FUNCT_6:22;
reconsider D96 = ( C93 . D95 ) as (Function of ( (the Sorts of ( FreeMSA C91 )) . D95 ) , ( (the Sorts of C90) . D95 ));
let C97 being set;
L559: ( FreeGen C91 ) c= (the Sorts of ( FreeMSA C91 )) by PBOOLE:def 18;
L560: ( ( FreeGen C91 ) . D95 ) c= ( (the Sorts of ( FreeMSA C91 )) . D95 ) by L559 , PBOOLE:def 2;
L561: (the Sorts of ( Image C93 )) = ( C93 .:.: (the Sorts of ( FreeMSA C91 )) ) by L547 , MSUALG_3:def 12;
L562: ( (the Sorts of ( Image C93 )) . D95 ) = ( D96 .: ( (the Sorts of ( FreeMSA C91 )) . D95 ) ) by L561 , PBOOLE:def 20;
assume L563: C97 in ( C91 . C96 );
consider C98 being set such that L564: C98 in ( dom ( D92 . D95 ) ) and L565: C97 = ( ( D92 . D95 ) . C98 ) by L563 , L558 , FUNCT_1:def 3;
L566: ( D92 . D95 ) = ( D96 | ( ( FreeGen C91 ) . D95 ) ) by L548 , MSAFREE:def 1;
L567: ( dom ( D92 . D95 ) ) = ( ( dom D96 ) /\ ( ( FreeGen C91 ) . D95 ) ) by L566 , RELAT_1:61;
L568: (C98 in ( ( FreeGen C91 ) . D95 ) & C98 in ( dom D96 )) by L567 , L564 , XBOOLE_0:def 4;
L569: C97 = ( D96 . C98 ) by L566 , L564 , L565 , FUNCT_1:47;
thus L570: thesis by L569 , L562 , L560 , L568 , FUNCT_1:def 6;
end;
L571: ( GenMSAlg D91 ) is (MSSubAlgebra of ( Image C93 )) by L555 , MSUALG_2:def 17;
L572: (the Sorts of ( GenMSAlg D91 )) is (MSSubset of ( Image C93 )) by L571 , MSUALG_2:def 9;
L573: (the Sorts of ( GenMSAlg D91 )) c= (the Sorts of ( Image C93 )) by L572 , PBOOLE:def 18;
L574: (the Sorts of ( Image C95 )) = ( C93 .:.: (the Sorts of ( FreeMSA C91 )) ) by L551 , L553 , MSUALG_3:def 12;
L575: ( (the Sorts of ( Image C95 )) . C94 ) = ( D94 .: ( (the Sorts of ( FreeMSA C91 )) . C94 ) ) by L574 , PBOOLE:def 20;
L576: (the Sorts of ( Image C93 )) is (MSSubset of C90) by MSUALG_2:def 9;
L577: ((the Sorts of ( GenMSAlg D91 )) = (the Sorts of C90) & (the Sorts of ( Image C93 )) c= (the Sorts of C90)) by L576 , MSAFREE:def 4 , PBOOLE:def 18;
L578: (the Sorts of ( Image C93 )) = (the Sorts of C90) by L577 , L573 , PBOOLE:146;
thus L579: thesis by L578 , L575 , L554 , RELSET_1:22;
end;
theorem
L580: (for B67 being non  void non  empty ManySortedSign holds (for B68 being  non-empty MSAlgebra over B67 holds (for B69 being  non-empty (GeneratorSet of B68) holds (B68 is non  finite-yielding implies ( FreeMSA B69 ) is non  finite-yielding))))
proof
let C99 being non  void non  empty ManySortedSign;
let C100 being  non-empty MSAlgebra over C99;
let C101 being  non-empty (GeneratorSet of C100);
assume that
L581: C100 is non  finite-yielding
and
L582: ( FreeMSA C101 ) is  finite-yielding;
L583: (the Sorts of C100) is non  finite-yielding by L581 , MSAFREE2:def 11;
consider C102 being set such that L584: C102 in (the carrier of C99) and L585: ( (the Sorts of C100) . C102 ) is  infinite by L583 , FINSET_1:def 5;
L586: (the Sorts of ( FreeMSA C101 )) is  finite-yielding by L582 , MSAFREE2:def 11;
L587: ( (the Sorts of ( FreeMSA C101 )) . C102 ) is  finite by L586;
reconsider D97 = ( (the Sorts of ( FreeMSA C101 )) . C102 ) as non  empty set by L584;
reconsider D98 = ( (the Sorts of C100) . C102 ) as non  empty set by L584;
consider C103 being (ManySortedFunction of ( FreeMSA C101 ) , C100) such that L588: C103 is_epimorphism ( FreeMSA C101 ) , C100 by L539;
reconsider D99 = C102 as (Element of C99) by L584;
reconsider D100 = ( C103 . D99 ) as (Function of D97 , D98);
L589: C103 is  "onto" by L588 , MSUALG_3:def 8;
L590: ( rng D100 ) = D98 by L589 , MSUALG_3:def 3;
thus L591: contradiction by L590 , L585 , L587;
end;
registration
let C104 being non  void non  empty ManySortedSign;
let C105 being  non-empty  finite-yielding (ManySortedSet of (the carrier of C104));
let C106 being (SortSymbol of C104);
cluster ( FreeGen (C106 , C105) ) ->  finite;
coherence
proof
L592: ( C105 . C106 ) , ( FreeGen (C106 , C105) ) are_equipotent 
proof
set D101 = { [ B70 , ( root-tree [ B70 , C106 ] ) ] where B70 is (Element of ( C105 . C106 )) : (not contradiction) };
take D101;
thus L593:now
let C107 being set;
assume that
L594: C107 in ( C105 . C106 );
reconsider D102 = ( root-tree [ C107 , C106 ] ) as set;
take D103 = D102;
thus L595: D103 in ( FreeGen (C106 , C105) ) by L594 , MSAFREE:def 15;
thus L596: [ C107 , D103 ] in D101 by L594;
end;
thus L597:now
let C108 being set;
assume L598: C108 in ( FreeGen (C106 , C105) );
consider C109 being set such that L599: C109 in ( C105 . C106 ) and L600: C108 = ( root-tree [ C109 , C106 ] ) by L598 , MSAFREE:def 15;
take D104 = C109;
thus L601: D104 in ( C105 . C106 ) by L599;
thus L602: [ D104 , C108 ] in D101 by L599 , L600;
end;
let C110 , C111 , C112 , C113 being set;
assume that
L603: [ C110 , C111 ] in D101
and
L604: [ C112 , C113 ] in D101;
consider C114 being (Element of ( C105 . C106 )) such that L605: [ C110 , C111 ] = [ C114 , ( root-tree [ C114 , C106 ] ) ] by L603;
consider C115 being (Element of ( C105 . C106 )) such that L606: [ C112 , C113 ] = [ C115 , ( root-tree [ C115 , C106 ] ) ] by L604;
L607: C112 = C115 by L606 , XTUPLE_0:1;
L608: C110 = C114 by L605 , XTUPLE_0:1;
thus L609: (C110 = C112 implies C111 = C113) by L608 , L605 , L606 , L607 , XTUPLE_0:1;
L610: C111 = ( root-tree [ C114 , C106 ] ) by L605 , XTUPLE_0:1;
L611: C113 = ( root-tree [ C115 , C106 ] ) by L606 , XTUPLE_0:1;
assume L612: C111 = C113;
L613: [ C114 , C106 ] = [ C115 , C106 ] by L612 , L610 , L611 , TREES_4:4;
thus L614: thesis by L613 , L608 , L607 , XTUPLE_0:1;
end;
thus L615: thesis by L592 , CARD_1:38;
end;
end;
theorem
L617: (for B71 being non  void non  empty ManySortedSign holds (for B72 being  non-empty MSAlgebra over B71 holds (for B73 being (OperSymbol of B71) holds (( (the Arity of B71) . B73 ) = ( {} ) implies ( dom ( Den (B73 , B72) ) ) = { ( {} ) }))))
proof
L618: (( dom ( {} ) ) = ( {} ) & ( rng ( {} ) ) = ( {} ));
reconsider D105 = ( {} ) as (Function of ( {} ) , ( {} )) by L618 , FUNCT_2:1;
let C116 being non  void non  empty ManySortedSign;
let C117 being  non-empty MSAlgebra over C116;
let C118 being (OperSymbol of C116);
assume that
L619: ( (the Arity of C116) . C118 ) = ( {} );
L620: ( dom (the Arity of C116) ) = (the carrier' of C116) by FUNCT_2:def 1;
L621: (( dom (( (the Sorts of C117) # ) qua (ManySortedSet of ( (the carrier of C116) * ))) ) = ( (the carrier of C116) * ) & ( (the Arity of C116) . C118 ) in ( rng (the Arity of C116) )) by L620 , FUNCT_1:def 3 , PARTFUN1:def 2;
L622: C118 in ( dom ( ( (the Sorts of C117) # ) * (the Arity of C116) ) ) by L621 , L620 , FUNCT_1:11;
thus L623: ( dom ( Den (C118 , C117) ) ) = ( Args (C118 , C117) ) by FUNCT_2:def 1
.= ( ( ( (the Sorts of C117) # ) * (the Arity of C116) ) . C118 ) by MSUALG_1:def 4
.= ( ( (the Sorts of C117) # ) . ( (the Arity of C116) . C118 ) ) by L622 , FUNCT_1:12
.= ( ( (the Sorts of C117) # ) . ( the_arity_of C118 ) ) by MSUALG_1:def 1
.= ( product (( (the Sorts of C117) * ( the_arity_of C118 ) ) qua Function) ) by FINSEQ_2:def 5
.= ( product ( (the Sorts of C117) * D105 ) ) by L619 , MSUALG_1:def 1
.= { ( {} ) } by CARD_3:10;
end;
definition
let C119 being non  void non  empty ManySortedSign;
attr C119 is  finitely_operated
means
:L624: (for B74 being (SortSymbol of C119) holds { B75 where B75 is (OperSymbol of C119) : ( the_result_sort_of B75 ) = B74 } is  finite);
end;
theorem
L626: (for B76 being non  void non  empty ManySortedSign holds (for B77 being  non-empty MSAlgebra over B76 holds (for B78 being (SortSymbol of B76) holds (B76 is  finitely_operated implies ( Constants (B77 , B78) ) is  finite))))
proof
let C120 being non  void non  empty ManySortedSign;
let C121 being  non-empty MSAlgebra over C120;
let C122 being (SortSymbol of C120);
assume that
L627: C120 is  finitely_operated;
set D106 = { B79 where B79 is (OperSymbol of C120) : ( the_result_sort_of B79 ) = C122 };
consider C123 being non  empty set such that L628: C123 = ( (the Sorts of C121) . C122 ) and L629: ( Constants (C121 , C122) ) = { B80 where B80 is (Element of C123) : (ex B81 being (OperSymbol of C120) st (( (the Arity of C120) . B81 ) = ( {} ) & ( (the ResultSort of C120) . B81 ) = C122 & B80 in ( rng ( Den (B81 , C121) ) ))) } by MSUALG_2:def 3;
L630: D106 is  finite by L627 , L624;
L631:
now
assume L632: D106 is non  empty;
reconsider D107 = D106 as non  empty set by L632;
deffunc H2((Element of (the carrier' of C120))) = ( ( Den ($1 , C121) ) . ( {} ) );
defpred S3[ (Element of D107) ] means ( (the Arity of C120) . $1 ) = ( {} );
set D108 = { B82 where B82 is (Element of D107) : S3[ B82 ] };
set D109 = { H2(B83) where B83 is (Element of (the carrier' of C120)) : B83 in D108 };
L633: ( Constants (C121 , C122) ) c= D109
proof
let C124 being set;
assume L634: C124 in ( Constants (C121 , C122) );
consider C125 being (Element of C123) such that L635: C125 = C124 and L636: (ex B84 being (OperSymbol of C120) st (( (the Arity of C120) . B84 ) = ( {} ) & ( (the ResultSort of C120) . B84 ) = C122 & C125 in ( rng ( Den (B84 , C121) ) ))) by L634 , L629;
consider C126 being (OperSymbol of C120) such that L637: ( (the Arity of C120) . C126 ) = ( {} ) and L638: ( (the ResultSort of C120) . C126 ) = C122 and L639: C125 in ( rng ( Den (C126 , C121) ) ) by L636;
L640: ( the_result_sort_of C126 ) = ( (the ResultSort of C120) . C126 ) by MSUALG_1:def 2;
L641: C126 in D107 by L640 , L638;
reconsider D110 = C126 as (Element of D107) by L641;
L642: D110 in D108 by L637;
set D111 = ( Den (C126 , C121) );
consider C127 being set such that L643: C127 in ( dom D111 ) and L644: C125 = ( D111 . C127 ) by L639 , FUNCT_1:def 3;
L645: ( dom D111 ) = { ( {} ) } by L637 , L617;
L646: C127 = ( {} ) by L645 , L643 , TARSKI:def 1;
thus L647: thesis by L646 , L635 , L642 , L644;
end;
L648: D108 is (Subset of D107) from DOMAIN_1:sch 7;
L649: D108 is  finite by L648 , L630;
L650: D109 is  finite from FRAENKEL:sch 21(L649);
thus L651: thesis by L650 , L633;
end;
L652:
now
assume L653: D106 is  empty;
L654:
now
assume L655: ( Constants (C121 , C122) ) is non  empty;
consider C128 being set such that L656: C128 in ( Constants (C121 , C122) ) by L655 , XBOOLE_0:def 1;
consider C129 being (Element of C123) such that L657: C129 = C128 and L658: (ex B85 being (OperSymbol of C120) st (( (the Arity of C120) . B85 ) = ( {} ) & ( (the ResultSort of C120) . B85 ) = C122 & C129 in ( rng ( Den (B85 , C121) ) ))) by L629 , L656;
consider C130 being (OperSymbol of C120) such that L659: ( (the Arity of C120) . C130 ) = ( {} ) and L660: ( (the ResultSort of C120) . C130 ) = C122 and L661: C129 in ( rng ( Den (C130 , C121) ) ) by L658;
L662: ( the_result_sort_of C130 ) = ( (the ResultSort of C120) . C130 ) by MSUALG_1:def 2;
L663: C130 in D106 by L662 , L660;
thus L664: contradiction by L663 , L653;
end;
thus L665: thesis by L654;
end;
thus L666: thesis by L652 , L631;
end;
theorem
L667: (for B86 being non  void non  empty ManySortedSign holds (for B87 being  non-empty (ManySortedSet of (the carrier of B86)) holds (for B88 being (SortSymbol of B86) holds { B89 where B89 is (Element of ( (the Sorts of ( FreeMSA B87 )) . B88 )) : ( depth B89 ) = ( 0 ) } = ( ( FreeGen (B88 , B87) ) \/ ( Constants (( FreeMSA B87 ) , B88) ) ))))
proof
let C131 being non  void non  empty ManySortedSign;
let C132 being  non-empty (ManySortedSet of (the carrier of C131));
let C133 being (SortSymbol of C131);
set D112 = (the Sorts of ( FreeMSA C132 ));
set D113 = { B90 where B90 is (Element of ( D112 . C133 )) : ( depth B90 ) = ( 0 ) };
L668: D113 c= ( ( FreeGen (C133 , C132) ) \/ ( Constants (( FreeMSA C132 ) , C133) ) )
proof
let C134 being set;
assume L669: C134 in D113;
consider C135 being (Element of ( D112 . C133 )) such that L670: C134 = C135 and L671: ( depth C135 ) = ( 0 ) by L669;
L672: C135 in ( D112 . C133 );
L673: C135 in ( FreeSort (C132 , C133) ) by L672 , MSAFREE:def 11;
consider C136 being (Element of ( TS ( DTConMSA C132 ) )) such that L674: C135 = C136 and L675: ((ex B91 being set st (B91 in ( C132 . C133 ) & C136 = ( root-tree [ B91 , C133 ] ))) or (ex B92 being (OperSymbol of C131) st ([ B92 , (the carrier of C131) ] = ( C136 . ( {} ) ) & ( the_result_sort_of B92 ) = C133))) by L673;
consider C137 being  finite DecoratedTree, C138 being  finite Tree such that L676: C137 = C135 and L677: (C138 = ( dom C137 ) & ( depth C135 ) = ( height C138 )) by MSAFREE2:def 14;
per cases  by L675;
suppose L678: (ex B93 being set st (B93 in ( C132 . C133 ) & C136 = ( root-tree [ B93 , C133 ] )));

L679: C135 in ( FreeGen (C133 , C132) ) by L678 , L674 , MSAFREE:def 15;
thus L680: thesis by L679 , L670 , XBOOLE_0:def 3;
end;
suppose L681: (ex B94 being (OperSymbol of C131) st ([ B94 , (the carrier of C131) ] = ( C136 . ( {} ) ) & ( the_result_sort_of B94 ) = C133));

consider C139 being (OperSymbol of C131) such that L682: [ C139 , (the carrier of C131) ] = ( C136 . ( {} ) ) and L683: ( the_result_sort_of C139 ) = C133 by L681;
L684: ( (the ResultSort of C131) . C139 ) = C133 by L683 , MSUALG_1:def 2;
set D114 = ( <*> ( TS ( DTConMSA C132 ) ) );
reconsider D115 = C135 as (Term of C131 , C132) by L674 , MSATERM:def 1;
L685: (ex B95 being non  empty set st (B95 = ( D112 . C133 ) & ( Constants (( FreeMSA C132 ) , C133) ) = { B96 where B96 is (Element of B95) : (ex B97 being (OperSymbol of C131) st (( (the Arity of C131) . B97 ) = ( {} ) & ( (the ResultSort of C131) . B97 ) = C133 & B96 in ( rng ( Den (B97 , ( FreeMSA C132 )) ) ))) })) by MSUALG_2:def 3;
consider C140 being (ArgumentSeq of ( Sym (C139 , C132) )) such that L686: D115 = ( [ C139 , (the carrier of C131) ] -tree C140 ) by L674 , L682 , MSATERM:10;
L687: C137 = ( root-tree ( C137 . ( {} ) ) ) by L671 , L677 , TREES_1:43 , TREES_4:5;
L688: C140 = ( {} ) by L687 , L676 , L686 , TREES_4:17;
L689: ( 0 ) = ( len C140 ) by L688
.= ( len ( the_arity_of C139 ) ) by MSATERM:22;
L690: ( the_arity_of C139 ) = ( {} ) by L689;
L691: ( (the Arity of C131) . C139 ) = ( {} ) by L690 , MSUALG_1:def 1;
L692: ( dom ( Den (C139 , ( FreeMSA C132 )) ) ) = { ( {} ) } by L691 , L617;
L693: ( {} ) in ( dom ( Den (C139 , ( FreeMSA C132 )) ) ) by L692 , TARSKI:def 1;
L694: ( Sym (C139 , C132) ) ==> ( roots C140 ) by MSATERM:21;
L695: ( ( DenOp (C139 , C132) ) . D114 ) = C135 by L694 , L686 , L688 , MSAFREE:def 12;
L696: ( Den (C139 , ( FreeMSA C132 )) ) = ( ( FreeOper C132 ) . C139 ) by MSUALG_1:def 6
.= ( DenOp (C139 , C132) ) by MSAFREE:def 13;
L697: C135 in ( rng ( Den (C139 , ( FreeMSA C132 )) ) ) by L696 , L695 , L693 , FUNCT_1:def 3;
L698: C135 in ( Constants (( FreeMSA C132 ) , C133) ) by L697 , L691 , L684 , L685;
thus L699: thesis by L698 , L670 , XBOOLE_0:def 3;
end;
end;
L701: ( Constants (( FreeMSA C132 ) , C133) ) c= D113
proof
set D116 = ( <*> ( TS ( DTConMSA C132 ) ) );
let C141 being set;
consider C142 being non  empty set such that L702: C142 = ( (the Sorts of ( FreeMSA C132 )) . C133 ) and L703: ( Constants (( FreeMSA C132 ) , C133) ) = { B98 where B98 is (Element of C142) : (ex B99 being (OperSymbol of C131) st (( (the Arity of C131) . B99 ) = ( {} ) & ( (the ResultSort of C131) . B99 ) = C133 & B98 in ( rng ( Den (B99 , ( FreeMSA C132 )) ) ))) } by MSUALG_2:def 3;
assume L704: C141 in ( Constants (( FreeMSA C132 ) , C133) );
consider C143 being (Element of C142) such that L705: C141 = C143 and L706: (ex B100 being (OperSymbol of C131) st (( (the Arity of C131) . B100 ) = ( {} ) & ( (the ResultSort of C131) . B100 ) = C133 & C143 in ( rng ( Den (B100 , ( FreeMSA C132 )) ) ))) by L704 , L703;
consider C144 being (OperSymbol of C131) such that L707: ( (the Arity of C131) . C144 ) = ( {} ) and L708: ( (the ResultSort of C131) . C144 ) = C133 and L709: C143 in ( rng ( Den (C144 , ( FreeMSA C132 )) ) ) by L706;
L710: ( dom ( Den (C144 , ( FreeMSA C132 )) ) ) = { ( {} ) } by L707 , L617;
L711: ( ( ( ( FreeSort C132 ) # ) * (the Arity of C131) ) . C144 ) = ( Args (C144 , ( FreeMSA C132 )) ) by MSUALG_1:def 4
.= ( dom ( Den (C144 , ( FreeMSA C132 )) ) ) by FUNCT_2:def 1;
L712: D116 in ( ( ( ( FreeSort C132 ) # ) * (the Arity of C131) ) . C144 ) by L711 , L710 , TARSKI:def 1;
L713: ( Sym (C144 , C132) ) ==> ( roots D116 ) by L712 , MSAFREE:10;
L714: ( ( DenOp (C144 , C132) ) . D116 ) = ( ( Sym (C144 , C132) ) -tree D116 ) by L713 , MSAFREE:def 12;
reconsider D117 = C143 as (Element of ( (the Sorts of ( FreeMSA C132 )) . C133 )) by L702;
consider C145 being set such that L715: C145 in ( dom ( Den (C144 , ( FreeMSA C132 )) ) ) and L716: D117 = ( ( Den (C144 , ( FreeMSA C132 )) ) . C145 ) by L709 , FUNCT_1:def 3;
consider C146 being  finite DecoratedTree, C147 being  finite Tree such that L717: (C146 = D117 & C147 = ( dom C146 )) and L718: ( depth D117 ) = ( height C147 ) by MSAFREE2:def 14;
L719: ( Den (C144 , ( FreeMSA C132 )) ) = ( ( FreeOper C132 ) . C144 ) by MSUALG_1:def 6
.= ( DenOp (C144 , C132) ) by MSAFREE:def 13;
L720: C145 = ( {} ) by L710 , L715 , TARSKI:def 1;
L721: D117 = ( root-tree ( Sym (C144 , C132) ) ) by L720 , L716 , L719 , L714 , TREES_4:20;
L722: ( height C147 ) = ( 0 ) by L721 , L717 , TREES_1:42 , TREES_4:3;
thus L723: thesis by L722 , L705 , L718;
end;
L724: ( FreeGen (C133 , C132) ) c= D113
proof
let C148 being set;
assume L725: C148 in ( FreeGen (C133 , C132) );
reconsider D118 = C148 as (Element of ( D112 . C133 )) by L725;
consider C149 being  finite DecoratedTree, C150 being  finite Tree such that L726: (C149 = D118 & C150 = ( dom C149 )) and L727: ( depth D118 ) = ( height C150 ) by MSAFREE2:def 14;
L728: (ex B101 being set st (B101 in ( C132 . C133 ) & C148 = ( root-tree [ B101 , C133 ] ))) by L725 , MSAFREE:def 15;
L729: ( height C150 ) = ( 0 ) by L728 , L726 , TREES_1:42 , TREES_4:3;
thus L730: thesis by L729 , L727;
end;
L731: ( ( FreeGen (C133 , C132) ) \/ ( Constants (( FreeMSA C132 ) , C133) ) ) c= D113 by L724 , L701 , XBOOLE_1:8;
thus L732: thesis by L731 , L668 , XBOOLE_0:def 10;
end;
theorem
L733: (for B102 being non  void non  empty ManySortedSign holds (for B103 being  non-empty (ManySortedSet of (the carrier of B102)) holds (for B104 , B105 being (SortSymbol of B102) holds (for B106 being (OperSymbol of B102) holds (for B107 being (Element of ( (the Sorts of ( FreeMSA B103 )) . B104 )) holds (for B108 being (ArgumentSeq of ( Sym (B106 , B103) )) holds (for B109 being (Element of ( NAT )) holds (for B110 being (Element of ( (the Sorts of ( FreeMSA B103 )) . B105 )) holds ((B107 = ( [ B106 , (the carrier of B102) ] -tree B108 ) & B109 in ( dom B108 ) & B110 = ( B108 . B109 )) implies ( depth B110 ) < ( depth B107 ))))))))))
proof
let C151 being non  void non  empty ManySortedSign;
let C152 being  non-empty (ManySortedSet of (the carrier of C151));
let C153 , C154 being (SortSymbol of C151);
let C155 being (OperSymbol of C151);
let C156 being (Element of ( (the Sorts of ( FreeMSA C152 )) . C153 ));
let C157 being (ArgumentSeq of ( Sym (C155 , C152) ));
let C158 being (Element of ( NAT ));
let C159 being (Element of ( (the Sorts of ( FreeMSA C152 )) . C154 ));
assume that
L734: C156 = ( [ C155 , (the carrier of C151) ] -tree C157 )
and
L735: C158 in ( dom C157 )
and
L736: C159 = ( C157 . C158 );
reconsider D119 = C157 as  DTree-yielding FinSequence;
L737: ((ex B111 being  finite DecoratedTree st (ex B112 being  finite Tree st (B111 = C156 & B112 = ( dom B111 ) & ( depth C156 ) = ( height B112 )))) & (ex B113 being  DTree-yielding FinSequence st (D119 = B113 & ( dom C156 ) = ( tree ( doms B113 ) )))) by L734 , MSAFREE2:def 14 , TREES_4:def 4;
reconsider D120 = ( doms C157 ) as  FinTree-yielding FinSequence;
consider C160 being  finite DecoratedTree, C161 being  finite Tree such that L738: (C160 = C159 & C161 = ( dom C160 )) and L739: ( depth C159 ) = ( height C161 ) by MSAFREE2:def 14;
L740: (( dom ( doms D119 ) ) = ( dom D119 ) & C161 = ( D120 . C158 )) by L735 , L736 , L738 , FUNCT_6:22 , TREES_3:37;
L741: C161 in ( rng D120 ) by L740 , L735 , FUNCT_1:def 3;
thus L742: thesis by L741 , L739 , L737 , TREES_3:78;
end;
