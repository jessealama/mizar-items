:: On the concept of the triangulation
::  by Beata Madras
::
:: Received October 28, 1995
:: Copyright (c) 1995-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, XBOOLE_0, ORDERS_1, ORDERS_2, WELLORD1,
      FINSET_1, XXREAL_0, TARSKI, STRUCT_0, FINSUB_1, SETFAM_1, RELAT_2,
      RELAT_1, CARD_1, PRE_POLY, FINSEQ_1, PROB_1, PBOOLE, NAT_1, FUNCT_1,
      ARYTM_3, FUNCOP_1, FUNCT_2, QC_LANG1, ORDINAL2, FINSEQ_2, PARTFUN1,
      TRIANG_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, RELAT_1, RELAT_2,
      SETFAM_1, ORDERS_1, DOMAIN_1, ORDINAL1, NAT_1, FUNCT_1, PARTFUN1,
      FUNCT_2, FINSET_1, FINSEQ_1, FINSEQ_2, FINSUB_1, STRUCT_0, WELLORD1,
      SEQM_3, PBOOLE, ORDERS_2, FINSEQOP, FUNCOP_1, XXREAL_0, PRE_POLY;
 constructors SETFAM_1, DOMAIN_1, FINSEQOP, PBOOLE, ORDERS_2, SEQ_1, RELSET_1,
      PRE_POLY;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FINSET_1, FINSUB_1, XXREAL_0,
      NAT_1, FINSEQ_1, STRUCT_0, ORDERS_2, MEMBERED, VALUED_0, CARD_1,
      RELSET_1, FUNCT_1, FUNCT_2, PRE_POLY;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions RELAT_2, TARSKI, FUNCT_1, WELLORD1, ORDERS_2, FINSEQ_2, SUBSET_1,
      XBOOLE_0, PBOOLE;
 theorems RELAT_1, ORDERS_2, RELAT_2, ZFMISC_1, TARSKI, SUBSET_1, ORDERS_1,
      FINSUB_1, NAT_1, FUNCT_2, PBOOLE, FUNCT_1, FINSEQ_1, CARD_2, FINSEQ_4,
      FINSEQ_2, FUNCOP_1, SEQM_3, SETFAM_1, XBOOLE_0, XBOOLE_1, XXREAL_0,
      ORDINAL1, PARTFUN1, PRE_POLY;
 schemes PBOOLE, CLASSES1, MSSUBFAM, PRE_POLY;

begin
registration
let C1 being non  empty set;
let C2 being (Order of C1);
cluster RelStr (# C1 , C2 #) -> non  empty;
coherence;
end;
theorem
L2: (for R1 being set holds ( ( {} ) |_2 R1 ) = ( {} ));
theorem
L3: (for B1 being non  empty Poset holds (for B2 being (Subset of B1) holds ((B2 is  finite & B2 <> ( {} ) & (for B3 , B4 being (Element of B1) holds ((B3 in B2 & B4 in B2) implies (B3 <= B4 or B4 <= B3)))) implies (ex B5 being (Element of B1) st (B5 in B2 & (for B6 being (Element of B1) holds (B6 in B2 implies B5 <= B6)))))))
proof
let C3 being non  empty Poset;
defpred S1[ set ] means ($1 <> ( {} ) implies (ex B7 being (Element of C3) st (B7 in $1 & (for B8 being (Element of C3) holds (B8 in $1 implies B7 <= B8)))));
let C4 being (Subset of C3);
assume that
L4: C4 is  finite
and
L5: C4 <> ( {} )
and
L6: (for B9 , B10 being (Element of C3) holds ((B9 in C4 & B10 in C4) implies (B9 <= B10 or B10 <= B9)));
L7:
now
let C5 being (Element of C3);
let C6 being (Subset of C3);
assume that
L8: C5 in C4
and
L9: C6 c= C4
and
L10: S1[ C6 ];
reconsider D1 = C5 as (Element of C3);
L11:
now
per cases ;
suppose L12: (not (ex B11 being (Element of C3) st (B11 in C6 & B11 <= D1)));

assume L13: ( C6 \/ { C5 } ) <> ( {} );
take D2 = D1;
L14: C5 in { C5 } by TARSKI:def 1;
thus L15: D2 in ( C6 \/ { C5 } ) by L14 , XBOOLE_0:def 3;
let C7 being (Element of C3);
assume L16: C7 in ( C6 \/ { C5 } );
L17: (C7 in C6 or C7 in { C5 }) by L16 , XBOOLE_0:def 3;
L18: ((not C7 <= D1) or C7 = C5) by L17 , L12 , TARSKI:def 1;
thus L19: D2 <= C7 by L18 , L6 , L8 , L9 , L17 , TARSKI:def 1;
end;
suppose L20: (ex B12 being (Element of C3) st (B12 in C6 & B12 <= D1));

assume L21: ( C6 \/ { C5 } ) <> ( {} );
consider C8 being (Element of C3) such that L22: C8 in C6 and L23: C8 <= D1 by L20;
consider C9 being (Element of C3) such that L24: C9 in C6 and L25: (for B13 being (Element of C3) holds (B13 in C6 implies C9 <= B13)) by L10 , L22;
take D3 = C9;
thus L26: D3 in ( C6 \/ { C5 } ) by L24 , XBOOLE_0:def 3;
let C10 being (Element of C3);
assume L27: C10 in ( C6 \/ { C5 } );
L28: (C10 in C6 or C10 in { C5 }) by L27 , XBOOLE_0:def 3;
L29: D3 <= C8 by L22 , L25;
L30: D3 <= D1 by L29 , L23 , ORDERS_2:3;
thus L31: D3 <= C10 by L30 , L25 , L28 , TARSKI:def 1;
end;
end;
thus L33: S1[ ( C6 \/ { C5 } ) ] by L11;
end;
L34: S1[ ( {} (the carrier of C3) ) ];
L35: S1[ C4 ] from PRE_POLY:sch 2(L4 , L34 , L7);
thus L36: thesis by L35 , L5;
end;
registration
let C11 being non  empty Poset;
let C12 being non  empty  finite (Subset of C11);
let C13 being (Element of C11);
cluster ( InitSegm (C12 , C13) ) ->  finite;
coherence;
end;
begin
definition
let C14 being non  empty Poset;
func symplexes C14 -> (Subset of ( Fin (the carrier of C14) )) equals 
{ B14 where B14 is (Element of ( Fin (the carrier of C14) )) : (the InternalRel of C14) linearly_orders B14 };
coherence
proof
set D4 = { B15 where B15 is (Element of ( Fin (the carrier of C14) )) : (the InternalRel of C14) linearly_orders B15 };
L38: D4 c= ( Fin (the carrier of C14) )
proof
let R2 being set;
assume L39: R2 in D4;
L40: (ex B16 being (Element of ( Fin (the carrier of C14) )) st (R2 = B16 & (the InternalRel of C14) linearly_orders B16)) by L39;
thus L41: thesis by L40;
end;
thus L42: thesis by L38;
end;
end;
registration
let C15 being non  empty Poset;
cluster ( symplexes C15 ) ->  with_non-empty_element;
coherence
proof
set D5 = the (Element of C15);
reconsider D6 = { D5 } as (Element of ( Fin (the carrier of C15) )) by FINSUB_1:def 5;
L44: (the InternalRel of C15) is_connected_in D6
proof
let C16 , C17 being set;
assume that
L45: C16 in D6
and
L46: C17 in D6
and
L47: C16 <> C17;
L48: C16 = D5 by L45 , TARSKI:def 1;
thus L49: thesis by L48 , L46 , L47 , TARSKI:def 1;
end;
L50: ( field (the InternalRel of C15) ) = (the carrier of C15) by ORDERS_1:12;
L51: (the InternalRel of C15) is_antisymmetric_in (the carrier of C15) by L50 , RELAT_2:def 12;
L52: (the InternalRel of C15) is_antisymmetric_in D6 by L51 , ORDERS_1:9;
L53: (the InternalRel of C15) is_transitive_in (the carrier of C15) by L50 , RELAT_2:def 16;
L54: (the InternalRel of C15) is_transitive_in D6 by L53 , ORDERS_1:10;
L55: (the InternalRel of C15) is_reflexive_in (the carrier of C15) by L50 , RELAT_2:def 9;
L56: (the InternalRel of C15) is_reflexive_in D6 by L55 , ORDERS_1:8;
L57: (the InternalRel of C15) linearly_orders D6 by L56 , L52 , L54 , L44 , ORDERS_1:def 8;
L58: D6 in { B17 where B17 is (Element of ( Fin (the carrier of C15) )) : (the InternalRel of C15) linearly_orders B17 } by L57;
thus L59: thesis by L58 , SETFAM_1:def 10;
end;
end;
theorem
L61: (for R8 being non  empty Poset holds (for B18 being (Element of R8) holds { B18 } in ( symplexes R8 )))
proof
let R8 being non  empty Poset;
let C18 being (Element of R8);
reconsider D7 = { C18 } as (Element of ( Fin (the carrier of R8) )) by FINSUB_1:def 5;
L62: (the InternalRel of R8) is_connected_in D7
proof
let C19 , C20 being set;
assume that
L63: C19 in D7
and
L64: C20 in D7
and
L65: C19 <> C20;
L66: C19 = C18 by L63 , TARSKI:def 1;
thus L67: thesis by L66 , L64 , L65 , TARSKI:def 1;
end;
L68: ( field (the InternalRel of R8) ) = (the carrier of R8) by ORDERS_1:12;
L69: (the InternalRel of R8) is_antisymmetric_in (the carrier of R8) by L68 , RELAT_2:def 12;
L70: (the InternalRel of R8) is_antisymmetric_in D7 by L69 , ORDERS_1:9;
L71: (the InternalRel of R8) is_transitive_in (the carrier of R8) by L68 , RELAT_2:def 16;
L72: (the InternalRel of R8) is_transitive_in D7 by L71 , ORDERS_1:10;
L73: (the InternalRel of R8) is_reflexive_in (the carrier of R8) by L68 , RELAT_2:def 9;
L74: (the InternalRel of R8) is_reflexive_in D7 by L73 , ORDERS_1:8;
L75: (the InternalRel of R8) linearly_orders D7 by L74 , L70 , L72 , L62 , ORDERS_1:def 8;
thus L76: thesis by L75;
end;
theorem
L77: (for R8 being non  empty Poset holds ( {} ) in ( symplexes R8 ))
proof
let R8 being non  empty Poset;
L78: ( {} ) is (Subset of R8) by SUBSET_1:1;
reconsider D8 = ( {} ) as (Element of ( Fin (the carrier of R8) )) by L78 , FINSUB_1:def 5;
L79: ( field (the InternalRel of R8) ) = (the carrier of R8) by ORDERS_1:12;
L80: (the InternalRel of R8) is_antisymmetric_in (the carrier of R8) by L79 , RELAT_2:def 12;
L81: (the InternalRel of R8) is_antisymmetric_in D8 by L80 , L78 , ORDERS_1:9;
L82: (the InternalRel of R8) is_connected_in D8
proof
let C21 , C22 being set;
assume that
L83: C21 in D8
and
L84: C22 in D8
and
L85: C21 <> C22;
thus L86: thesis by L83;
end;
L87: (the InternalRel of R8) is_transitive_in (the carrier of R8) by L79 , RELAT_2:def 16;
L88: (the InternalRel of R8) is_transitive_in D8 by L87 , L78 , ORDERS_1:10;
L89: (the InternalRel of R8) is_reflexive_in (the carrier of R8) by L79 , RELAT_2:def 9;
L90: (the InternalRel of R8) is_reflexive_in D8 by L89 , L78 , ORDERS_1:8;
L91: (the InternalRel of R8) linearly_orders D8 by L90 , L81 , L88 , L82 , ORDERS_1:def 8;
thus L92: thesis by L91;
end;
theorem
L93: (for R8 being non  empty Poset holds (for B19 , B20 being set holds ((B19 c= B20 & B20 in ( symplexes R8 )) implies B19 in ( symplexes R8 ))))
proof
let R8 being non  empty Poset;
let C23 , C24 being set;
assume that
L94: C23 c= C24
and
L95: C24 in ( symplexes R8 );
consider C25 being (Element of ( Fin (the carrier of R8) )) such that L96: C25 = C24 and L97: (the InternalRel of R8) linearly_orders C25 by L95;
L98: C25 c= (the carrier of R8) by FINSUB_1:def 5;
L99: C23 c= (the carrier of R8) by L98 , L94 , L96 , XBOOLE_1:1;
reconsider D9 = C23 as (Element of ( Fin (the carrier of R8) )) by L99 , L94 , L95 , FINSUB_1:def 5;
L100: (the InternalRel of R8) linearly_orders C23 by L94 , L96 , L97 , ORDERS_1:38;
L101: D9 in { B21 where B21 is (Element of ( Fin (the carrier of R8) )) : (the InternalRel of R8) linearly_orders B21 } by L100;
thus L102: thesis by L101;
end;
theorem
L103: (for R7 being (Element of ( NAT )) holds (for B22 being non  empty Poset holds (for B23 being non  empty (Element of ( symplexes B22 )) holds (( card B23 ) = R7 implies ( dom ( SgmX ((the InternalRel of B22) , B23) ) ) = ( Seg R7 )))))
proof
let R7 being (Element of ( NAT ));
let C26 being non  empty Poset;
let C27 being non  empty (Element of ( symplexes C26 ));
set D10 = ( SgmX ((the InternalRel of C26) , C27) );
L104: C27 in { B24 where B24 is (Element of ( Fin (the carrier of C26) )) : (the InternalRel of C26) linearly_orders B24 };
L105: (ex B25 being (Element of ( Fin (the carrier of C26) )) st (B25 = C27 & (the InternalRel of C26) linearly_orders B25)) by L104;
assume L106: ( card C27 ) = R7;
L107: ( len D10 ) = R7 by L106 , L105 , PRE_POLY:11;
thus L108: thesis by L107 , FINSEQ_1:def 3;
end;
registration
let C28 being non  empty Poset;
cluster non  empty for (Element of ( symplexes C28 ));
existence
proof
set D11 = the (Element of C28);
L109: { D11 } in ( symplexes C28 ) by L61;
thus L110: thesis by L109;
end;
end;
begin
definition
mode SetSequence
 is (ManySortedSet of ( NAT ));
end;
definition
let C29 being SetSequence;
attr C29 is  lower_non-empty
means
:L113: (for B26 being Nat holds (( C29 . B26 ) is non  empty implies (for B27 being Nat holds (B27 < B26 implies ( C29 . B27 ) is non  empty))));
end;
registration
cluster  lower_non-empty for SetSequence;
existence
proof
set D12 = ( ( NAT ) --> 1 );
reconsider D13 = D12 as (ManySortedSet of ( NAT ));
take D13;
L115: (for B28 being Nat holds (( D13 . B28 ) is non  empty implies (for B29 being Nat holds (B29 < B28 implies ( D13 . B29 ) is non  empty))))
proof
let C30 being Nat;
assume L116: ( D13 . C30 ) is non  empty;
let C31 being Nat;
assume L117: C31 < C30;
L118: C31 in ( NAT ) by ORDINAL1:def 12;
thus L119: thesis by L118 , FUNCOP_1:7;
end;
thus L120: thesis by L115 , L113;
end;
end;
definition
let C32 being SetSequence;
func FuncsSeq C32 -> SetSequence means 
:L122: (for B30 being Nat holds ( it . B30 ) = ( Funcs (( C32 . ( B30 + 1 ) ) , ( C32 . B30 )) ));
existence
proof
deffunc H1((Element of ( NAT ))) = ( Funcs (( C32 . ( $1 + 1 ) ) , ( C32 . $1 )) );
consider C33 being (ManySortedSet of ( NAT )) such that L123: (for B31 being (Element of ( NAT )) holds ( C33 . B31 ) = H1(B31)) from PBOOLE:sch 5;
reconsider D14 = C33 as SetSequence;
take D14;
let C34 being Nat;
L124: C34 in ( NAT ) by ORDINAL1:def 12;
thus L125: thesis by L124 , L123;
end;
uniqueness
proof
let C35 , C36 being SetSequence;
assume that
L126: (for B32 being Nat holds ( C35 . B32 ) = ( Funcs (( C32 . ( B32 + 1 ) ) , ( C32 . B32 )) ))
and
L127: (for B33 being Nat holds ( C36 . B33 ) = ( Funcs (( C32 . ( B33 + 1 ) ) , ( C32 . B33 )) ));
let C37 being (Element of ( NAT ));
L128: ( C35 . C37 ) = ( Funcs (( C32 . ( C37 + 1 ) ) , ( C32 . C37 )) ) by L126;
thus L129: ( C35 . C37 ) c= ( C36 . C37 ) by L128 , L127;
L130: ( C35 . C37 ) = ( Funcs (( C32 . ( C37 + 1 ) ) , ( C32 . C37 )) ) by L126;
thus L131: ( C36 . C37 ) c= ( C35 . C37 ) by L130 , L127;
end;
end;
registration
let C38 being  lower_non-empty SetSequence;
let C39 being Nat;
cluster ( ( FuncsSeq C38 ) . C39 ) -> non  empty;
coherence
proof
L133: C39 < ( C39 + 1 ) by NAT_1:13;
L134: (( C38 . ( C39 + 1 ) ) = ( {} ) or ( C38 . C39 ) <> ( {} )) by L133 , L113;
L135: ( ( FuncsSeq C38 ) . C39 ) = ( Funcs (( C38 . ( C39 + 1 ) ) , ( C38 . C39 )) ) by L122;
thus L136: thesis by L135 , L134 , FUNCT_2:8;
end;
end;
definition
let C40 being Nat;
let C41 being (Element of ( Funcs (( Seg C40 ) , ( Seg ( C40 + 1 ) )) ));
func @ C41 -> (FinSequence of ( REAL )) equals 
C41;
coherence
proof
consider C42 being Function such that L138: C42 = C41 and L139: ( dom C42 ) = ( Seg C40 ) and L140: ( rng C42 ) c= ( Seg ( C40 + 1 ) ) by FUNCT_2:def 2;
reconsider D15 = C42 as (FinSequence of ( Seg ( C40 + 1 ) )) by L138 , FINSEQ_2:25;
L141: ( Seg ( C40 + 1 ) ) c= ( REAL ) by XBOOLE_1:1;
L142: D15 is (FinSequence of ( REAL )) by L141 , FINSEQ_2:24;
thus L143: thesis by L142 , L138;
end;
end;
definition
func NatEmbSeq -> SetSequence means 
:L145: (for B34 being Nat holds ( it . B34 ) = { B35 where B35 is (Element of ( Funcs (( Seg B34 ) , ( Seg ( B34 + 1 ) )) )) : ( @ B35 ) is  increasing });
existence
proof
deffunc H2((Element of ( NAT ))) = { B36 where B36 is (Element of ( Funcs (( Seg $1 ) , ( Seg ( $1 + 1 ) )) )) : ( @ B36 ) is  increasing };
consider C43 being (ManySortedSet of ( NAT )) such that L146: (for B37 being (Element of ( NAT )) holds ( C43 . B37 ) = H2(B37)) from PBOOLE:sch 5;
reconsider D16 = C43 as SetSequence;
take D16;
let C44 being Nat;
L147: C44 in ( NAT ) by ORDINAL1:def 12;
thus L148: thesis by L147 , L146;
end;
uniqueness
proof
let C45 , C46 being SetSequence;
assume that
L149: (for B38 being Nat holds ( C45 . B38 ) = { B39 where B39 is (Element of ( Funcs (( Seg B38 ) , ( Seg ( B38 + 1 ) )) )) : ( @ B39 ) is  increasing })
and
L150: (for B40 being Nat holds ( C46 . B40 ) = { B41 where B41 is (Element of ( Funcs (( Seg B40 ) , ( Seg ( B40 + 1 ) )) )) : ( @ B41 ) is  increasing });
let C47 being (Element of ( NAT ));
L151: ( C45 . C47 ) = { B42 where B42 is (Element of ( Funcs (( Seg C47 ) , ( Seg ( C47 + 1 ) )) )) : ( @ B42 ) is  increasing } by L149;
thus L152: ( C45 . C47 ) c= ( C46 . C47 ) by L151 , L150;
L153: ( C45 . C47 ) = { B43 where B43 is (Element of ( Funcs (( Seg C47 ) , ( Seg ( C47 + 1 ) )) )) : ( @ B43 ) is  increasing } by L149;
thus L154: ( C46 . C47 ) c= ( C45 . C47 ) by L153 , L150;
end;
end;
registration
let C48 being Nat;
cluster ( ( NatEmbSeq ) . C48 ) -> non  empty;
coherence
proof
L156: C48 <= ( C48 + 1 ) by NAT_1:11;
L157: ( Seg C48 ) c= ( Seg ( C48 + 1 ) ) by L156 , FINSEQ_1:5;
L158: ( rng ( id ( Seg C48 ) ) ) = ( Seg C48 );
L159: ( dom ( id ( Seg C48 ) ) ) = ( Seg C48 );
reconsider D17 = ( idseq C48 ) as (Element of ( Funcs (( Seg C48 ) , ( Seg ( C48 + 1 ) )) )) by L159 , L157 , L158 , FUNCT_2:def 2;
L160: ( @ D17 ) is  increasing;
L161: D17 in { B44 where B44 is (Element of ( Funcs (( Seg C48 ) , ( Seg ( C48 + 1 ) )) )) : ( @ B44 ) is  increasing } by L160;
thus L162: thesis by L161 , L145;
end;
end;
registration
let C49 being Nat;
cluster  ->  Function-like  Relation-like for (Element of ( ( NatEmbSeq ) . C49 ));
coherence
proof
reconsider D18 = C49 as (Element of ( NAT )) by ORDINAL1:def 12;
let C50 being (Element of ( ( NatEmbSeq ) . C49 ));
L164: C50 in ( ( NatEmbSeq ) . D18 );
L165: ( ( NatEmbSeq ) . C49 ) = { B45 where B45 is (Element of ( Funcs (( Seg C49 ) , ( Seg ( C49 + 1 ) )) )) : ( @ B45 ) is  increasing } by L145;
L166: (ex B46 being (Element of ( Funcs (( Seg C49 ) , ( Seg ( C49 + 1 ) )) )) st (C50 = B46 & ( @ B46 ) is  increasing)) by L165 , L164;
thus L167: thesis by L166;
end;
end;
definition
let C51 being SetSequence;
mode triangulation of C51
 is (ManySortedFunction of ( NatEmbSeq ) , ( FuncsSeq C51 ));
end;
definition
struct TriangStr(# SkeletonSeq -> SetSequence , FacesAssign -> (ManySortedFunction of ( NatEmbSeq ) , ( FuncsSeq the SkeletonSeq )) #);
end;
definition
let C52 being TriangStr;
attr C52 is  lower_non-empty
means
:L171: (the SkeletonSeq of C52) is  lower_non-empty;
end;
registration
cluster  lower_non-empty  strict for TriangStr;
existence
proof
set D19 = ( ( NAT ) --> ( {} ) );
reconsider D20 = D19 as (ManySortedSet of ( NAT ));
set D21 = the (ManySortedFunction of ( NatEmbSeq ) , ( FuncsSeq D20 ));
take TriangStr (# D20 , D21 #);
L173: (for B47 being Nat holds (( D20 . B47 ) is non  empty implies (for B48 being Nat holds (B48 < B47 implies ( D20 . B48 ) is non  empty))))
proof
let C53 being Nat;
assume L174: ( D20 . C53 ) is non  empty;
L175: C53 in ( NAT ) by ORDINAL1:def 12;
thus L176: thesis by L175 , L174 , FUNCOP_1:7;
end;
L177: D20 is  lower_non-empty by L173 , L113;
thus L178: thesis by L177 , L171;
end;
end;
registration
let C54 being  lower_non-empty TriangStr;
cluster (the SkeletonSeq of C54) ->  lower_non-empty;
coherence by L171;
end;
registration
let C55 being  lower_non-empty SetSequence;
let C56 being (ManySortedFunction of ( NatEmbSeq ) , ( FuncsSeq C55 ));
cluster TriangStr (# C55 , C56 #) ->  lower_non-empty;
coherence by L171;
end;
begin
definition
let C57 being TriangStr;
let C58 being Nat;
mode Symplex of C57 , C58
 is (Element of ( (the SkeletonSeq of C57) . C58 ));
end;
definition
let C59 being Nat;
mode Face of C59
 is (Element of ( ( NatEmbSeq ) . C59 ));
end;
definition
let C60 being  lower_non-empty TriangStr;
let C61 being Nat;
let C62 being (Symplex of C60 , ( C61 + 1 ));
let C63 being (Face of C61);
assume L184: ( (the SkeletonSeq of C60) . ( C61 + 1 ) ) <> ( {} );
func face (C62 , C63) -> (Symplex of C60 , C61) means 
:L185: (for B49 , B50 being Function holds ((B49 = ( (the FacesAssign of C60) . C61 ) & B50 = ( B49 . C63 )) implies it = ( B50 . C62 )));
existence
proof
reconsider D22 = C61 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D23 = ( (the FacesAssign of C60) . D22 ) as (Function of ( ( NatEmbSeq ) . D22 ) , ( ( FuncsSeq (the SkeletonSeq of C60) ) . D22 )) by PBOOLE:def 15;
L186: ( D23 . C63 ) in ( ( FuncsSeq (the SkeletonSeq of C60) ) . D22 ) by FUNCT_2:5;
L187: ( D23 . C63 ) in ( Funcs (( (the SkeletonSeq of C60) . ( C61 + 1 ) ) , ( (the SkeletonSeq of C60) . C61 )) ) by L186 , L122;
consider C64 being Function such that L188: C64 = ( D23 . C63 ) and L189: ( dom C64 ) = ( (the SkeletonSeq of C60) . ( C61 + 1 ) ) and L190: ( rng C64 ) c= ( (the SkeletonSeq of C60) . C61 ) by L187 , FUNCT_2:def 2;
L191: ( C64 . C62 ) in ( rng C64 ) by L184 , L189 , FUNCT_1:def 3;
reconsider D24 = ( C64 . C62 ) as (Symplex of C60 , C61) by L191 , L190;
take D24;
let C65 , C66 being Function;
assume that
L192: C65 = ( (the FacesAssign of C60) . C61 )
and
L193: C66 = ( C65 . C63 );
thus L194: thesis by L188 , L192 , L193;
end;
uniqueness
proof
reconsider D25 = C61 as (Element of ( NAT )) by ORDINAL1:def 12;
let C67 , C68 being (Symplex of C60 , C61);
assume that
L195: (for B51 , B52 being Function holds ((B51 = ( (the FacesAssign of C60) . C61 ) & B52 = ( B51 . C63 )) implies C67 = ( B52 . C62 )))
and
L196: (for B53 , B54 being Function holds ((B53 = ( (the FacesAssign of C60) . C61 ) & B54 = ( B53 . C63 )) implies C68 = ( B54 . C62 )));
reconsider D26 = ( (the FacesAssign of C60) . D25 ) as (Function of ( ( NatEmbSeq ) . D25 ) , ( ( FuncsSeq (the SkeletonSeq of C60) ) . D25 )) by PBOOLE:def 15;
L197: ( D26 . C63 ) in ( ( FuncsSeq (the SkeletonSeq of C60) ) . D25 ) by FUNCT_2:5;
L198: ( D26 . C63 ) in ( Funcs (( (the SkeletonSeq of C60) . ( C61 + 1 ) ) , ( (the SkeletonSeq of C60) . C61 )) ) by L197 , L122;
consider C69 being Function such that L199: C69 = ( D26 . C63 ) and L200: ( dom C69 ) = ( (the SkeletonSeq of C60) . ( C61 + 1 ) ) and L201: ( rng C69 ) c= ( (the SkeletonSeq of C60) . C61 ) by L198 , FUNCT_2:def 2;
L202: C67 = ( C69 . C62 ) by L195 , L199;
thus L203: thesis by L202 , L196 , L199;
end;
end;
definition
let C70 being non  empty Poset;
func Triang C70 ->  lower_non-empty  strict TriangStr means 
(( (the SkeletonSeq of it) . ( 0 ) ) = { ( {} ) } & (for B55 being Nat holds (B55 > ( 0 ) implies ( (the SkeletonSeq of it) . B55 ) = { ( SgmX ((the InternalRel of C70) , B56) ) where B56 is non  empty (Element of ( symplexes C70 )) : ( card B56 ) = B55 })) & (for B57 being Nat holds (for B58 being (Face of B57) holds (for B59 being (Element of ( (the SkeletonSeq of it) . ( B57 + 1 ) )) holds (B59 in ( (the SkeletonSeq of it) . ( B57 + 1 ) ) implies (for B60 being non  empty (Element of ( symplexes C70 )) holds (( SgmX ((the InternalRel of C70) , B60) ) = B59 implies ( face (B59 , B58) ) = ( ( SgmX ((the InternalRel of C70) , B60) ) * B58 ))))))));
existence
proof
deffunc H3((Element of ( NAT ))) = ( IFEQ ($1 , ( 0 ) , { ( {} ) } , { ( SgmX ((the InternalRel of C70) , B61) ) where B61 is non  empty (Element of ( symplexes C70 )) : ( card B61 ) = $1 }) );
consider C71 being SetSequence such that L205: (for R7 being (Element of ( NAT )) holds ( C71 . R7 ) = H3(R7)) from PBOOLE:sch 5;
L206:
now
let C72 being Nat;
assume L207: C72 <> ( 0 );
L208: C72 in ( NAT ) by ORDINAL1:def 12;
thus L209: ( C71 . C72 ) = ( IFEQ (C72 , ( 0 ) , { ( {} ) } , { ( SgmX ((the InternalRel of C70) , B62) ) where B62 is non  empty (Element of ( symplexes C70 )) : ( card B62 ) = C72 }) ) by L208 , L205
.= { ( SgmX ((the InternalRel of C70) , B63) ) where B63 is non  empty (Element of ( symplexes C70 )) : ( card B63 ) = C72 } by L207 , FUNCOP_1:def 8;
end;
L210: ( C71 . ( 0 ) ) = ( IFEQ (( 0 ) , ( 0 ) , { ( {} ) } , { ( SgmX ((the InternalRel of C70) , B64) ) where B64 is non  empty (Element of ( symplexes C70 )) : ( card B64 ) = ( 0 ) }) ) by L205
.= { ( {} ) } by FUNCOP_1:def 8;
L211: C71 is  lower_non-empty
proof
defpred S2[ Nat ] means ( C71 . $1 ) is non  empty;
let C73 being Nat;
L212: (for R6 being (Element of ( NAT )) holds ((R6 < C73 & S2[ ( R6 + 1 ) ]) implies S2[ R6 ]))
proof
let R6 being (Element of ( NAT ));
assume that
L213: R6 < C73
and
L214: ( C71 . ( R6 + 1 ) ) is non  empty;
consider C74 being set such that L215: C74 in ( C71 . ( R6 + 1 ) ) by L214 , XBOOLE_0:def 1;
L216: ( C71 . ( R6 + 1 ) ) = { ( SgmX ((the InternalRel of C70) , B65) ) where B65 is non  empty (Element of ( symplexes C70 )) : ( card B65 ) = ( R6 + 1 ) } by L206;
consider C75 being non  empty (Element of ( symplexes C70 )) such that L217: C74 = ( SgmX ((the InternalRel of C70) , C75) ) and L218: ( card C75 ) = ( R6 + 1 ) by L216 , L215;
set D27 = the (Element of C75);
reconsider D28 = ( C75 \ { D27 } ) as  finite set;
L219: ( D28 \/ { D27 } ) = ( C75 \/ { D27 } ) by XBOOLE_1:39;
L220: ( D28 \/ { D27 } ) = C75 by L219 , XBOOLE_1:12;
L221: (not D27 in D28) by ZFMISC_1:56;
L222: ( R6 + 1 ) = ( ( card D28 ) + 1 ) by L221 , L218 , L220 , CARD_2:41;
per cases ;
suppose L223: R6 = ( 0 );

thus L224: thesis by L223 , L210;
end;
suppose L225: R6 <> ( 0 );

reconsider D29 = D28 as non  empty (Element of ( symplexes C70 )) by L225 , L222 , L93 , XBOOLE_1:36;
L226: ( SgmX ((the InternalRel of C70) , D29) ) in { ( SgmX ((the InternalRel of C70) , B66) ) where B66 is non  empty (Element of ( symplexes C70 )) : ( card B66 ) = R6 } by L222;
thus L227: thesis by L226 , L206 , L225;
end;
end;
assume L229: S2[ C73 ];
L230: (for B67 being (Element of ( NAT )) holds (B67 <= C73 implies S2[ B67 ])) from PRE_POLY:sch 1(L229 , L212);
let C76 being Nat;
assume L231: C76 < C73;
L232: C76 in ( NAT ) by ORDINAL1:def 12;
thus L233: thesis by L232 , L230 , L231;
end;
reconsider D30 = C71 as  lower_non-empty SetSequence by L211;
defpred S3[ set , set , set ] means (ex B68 being Nat st (ex B69 being (Face of B68) st ($2 = B69 & $3 = B68 & (for B70 being (Element of ( D30 . ( B68 + 1 ) )) holds (B70 in ( D30 . ( B68 + 1 ) ) implies (for B71 being non  empty (Element of ( symplexes C70 )) holds (( SgmX ((the InternalRel of C70) , B71) ) = B70 implies (for B72 being Function holds (B72 = $1 implies ( B72 . B70 ) = ( ( SgmX ((the InternalRel of C70) , B71) ) * B69 ))))))))));
L234: (for B73 being set holds (B73 in ( NAT ) implies (for B74 being set holds (B74 in ( ( NatEmbSeq ) . B73 ) implies (ex B75 being set st (B75 in ( ( FuncsSeq D30 ) . B73 ) & S3[ B75 , B74 , B73 ]))))))
proof
let C77 being set;
assume L235: C77 in ( NAT );
reconsider D31 = C77 as (Element of ( NAT )) by L235;
let C78 being set;
assume L236: C78 in ( ( NatEmbSeq ) . C77 );
reconsider D32 = C78 as (Face of D31) by L236;
reconsider D33 = D32 as Function;
L237: C78 in { B76 where B76 is (Element of ( Funcs (( Seg D31 ) , ( Seg ( D31 + 1 ) )) )) : ( @ B76 ) is  increasing } by L236 , L145;
L238: (ex B77 being (Element of ( Funcs (( Seg D31 ) , ( Seg ( D31 + 1 ) )) )) st (B77 = C78 & ( @ B77 ) is  increasing)) by L237;
consider C79 being Function such that L239: C79 = D33 and L240: ( dom C79 ) = ( Seg D31 ) and L241: ( rng C79 ) c= ( Seg ( D31 + 1 ) ) by L238 , FUNCT_2:def 2;
reconsider D34 = C79 as FinSequence by L240 , FINSEQ_1:def 2;
L242: ( len D34 ) = D31 by L240 , FINSEQ_1:def 3;
defpred S4[ set , set ] means (ex B78 being Function st (B78 = $1 & $2 = ( B78 * D33 )));
L243: (for B79 being set holds (B79 in ( D30 . ( D31 + 1 ) ) implies (ex R5 being set st S4[ B79 , R5 ])))
proof
let C80 being set;
assume L244: C80 in ( D30 . ( D31 + 1 ) );
L245: C80 in { ( SgmX ((the InternalRel of C70) , B80) ) where B80 is non  empty (Element of ( symplexes C70 )) : ( card B80 ) = ( D31 + 1 ) } by L244 , L206;
consider C81 being non  empty (Element of ( symplexes C70 )) such that L246: ( SgmX ((the InternalRel of C70) , C81) ) = C80 and L247: ( card C81 ) = ( D31 + 1 ) by L245;
reconsider D35 = ( ( SgmX ((the InternalRel of C70) , C81) ) * D32 ) as set;
consider C82 being Function such that L248: C82 = C80 by L246;
take D35;
take C82;
thus L249: thesis by L246 , L248;
end;
consider C83 being Function such that L250: ( dom C83 ) = ( D30 . ( D31 + 1 ) ) and L251: (for B81 being set holds (B81 in ( D30 . ( D31 + 1 ) ) implies S4[ B81 , ( C83 . B81 ) ])) from CLASSES1:sch 1(L243);
reconsider D36 = D34 as (FinSequence of ( Seg ( D31 + 1 ) )) by L241 , FINSEQ_1:def 4;
reconsider D37 = C83 as set;
take D37;
L252: D36 is  one-to-one
proof
let C84 , C85 being set;
assume that
L253: C84 in ( dom D36 )
and
L254: C85 in ( dom D36 )
and
L255: ( D36 . C84 ) = ( D36 . C85 );
reconsider D38 = C84 , D39 = C85 as (Element of ( NAT )) by L253 , L254;
L256:
now
assume L257: D38 <> D39;
per cases  by L257 , XXREAL_0:1;
suppose L258: D38 < D39;

thus L259: contradiction by L258 , L238 , L239 , L253 , L254 , L255 , SEQM_3:def 1;
end;
suppose L260: D39 < D38;

thus L261: contradiction by L260 , L238 , L239 , L253 , L254 , L255 , SEQM_3:def 1;
end;
end;
thus L263: thesis by L256;
end;
L264: ( rng C83 ) c= ( D30 . D31 )
proof
reconsider D40 = ( symplexes C70 ) as  with_non-empty_element (Subset of ( Fin (the carrier of C70) ));
let R4 being set;
assume L265: R4 in ( rng C83 );
consider C86 being set such that L266: C86 in ( dom C83 ) and L267: R4 = ( C83 . C86 ) by L265 , FUNCT_1:def 3;
consider C87 being Function such that L268: C87 = C86 and L269: ( C83 . C86 ) = ( C87 * D36 ) by L239 , L250 , L251 , L266;
per cases ;
suppose L270: D31 = ( 0 );

L271: ( Seg D31 ) = ( {} ) by L270;
L272: ( dom ( C87 * D33 ) ) = ( {} ) by L271 , L239 , L240 , RELAT_1:25 , XBOOLE_1:3;
L273: R4 = ( {} ) by L272 , L239 , L267 , L269;
thus L274: thesis by L273 , L210 , L270 , TARSKI:def 1;
end;
suppose L275: D31 <> ( 0 );

L276: C87 in { ( SgmX ((the InternalRel of C70) , B82) ) where B82 is non  empty (Element of ( symplexes C70 )) : ( card B82 ) = ( D31 + 1 ) } by L206 , L250 , L266 , L268;
consider C88 being non  empty (Element of ( symplexes C70 )) such that L277: ( SgmX ((the InternalRel of C70) , C88) ) = C87 and L278: ( card C88 ) = ( D31 + 1 ) by L276;
L279: C88 in { B83 where B83 is (Element of ( Fin (the carrier of C70) )) : (the InternalRel of C70) linearly_orders B83 };
L280: (ex B84 being (Element of ( Fin (the carrier of C70) )) st (B84 = C88 & (the InternalRel of C70) linearly_orders B84)) by L279;
L281: ( rng C87 ) = C88 by L280 , L277 , PRE_POLY:def 2;
reconsider D41 = C87 as (FinSequence of C88) by L281 , L277 , FINSEQ_1:def 4;
reconsider D42 = D41 as (FinSequence of RelStr (# C88 , ( (the InternalRel of C70) |_2 C88 ) #));
L282: D42 is  one-to-one by L277 , L280 , PRE_POLY:10;
L283: ( dom D42 ) = ( Seg ( D31 + 1 ) ) by L277 , L278 , L103;
L284: D42 is (Function of ( dom D42 ) , C88) by FINSEQ_2:26;
L285: D42 is (Function of ( Seg ( D31 + 1 ) ) , (the carrier of C70)) by L284 , L283 , FUNCT_2:7;
reconsider D43 = R4 as (FinSequence of RelStr (# (the carrier of C70) , (the InternalRel of C70) #)) by L285 , L267 , L269 , FINSEQ_2:32;
reconsider D44 = D42 as (Function of ( Seg ( D31 + 1 ) ) , (the carrier of C70)) by L283 , L284 , FUNCT_2:7;
L286: ( dom ( D44 * D36 ) ) = ( Seg D31 ) by L240 , L241 , L283 , RELAT_1:27;
L287: ( rng ( D44 * D36 ) ) c= (the carrier of C70) by FINSEQ_1:def 4;
reconsider D45 = ( rng ( D44 * D36 ) ) as (Element of ( Fin (the carrier of C70) )) by L287 , FINSUB_1:def 5;
L288: ( rng ( D44 * D36 ) ) c= C88 by RELAT_1:def 19;
reconsider D46 = D45 as non  empty (Element of D40) by L288 , L275 , L286 , L93 , RELAT_1:42;
L289: (for B85 , B86 being Nat holds ((B85 in ( dom D43 ) & B86 in ( dom D43 ) & B85 < B86) implies (( D43 /. B85 ) <> ( D43 /. B86 ) & [ ( D43 /. B85 ) , ( D43 /. B86 ) ] in (the InternalRel of C70))))
proof
let C89 , C90 being Nat;
assume that
L290: C89 in ( dom D43 )
and
L291: C90 in ( dom D43 )
and
L292: C89 < C90;
L293: ( D36 . C90 ) in ( Seg ( D31 + 1 ) ) by L240 , L267 , L269 , L286 , L291 , FINSEQ_2:11;
reconsider D47 = ( D36 . C90 ) as (Element of ( NAT )) by L293;
L294: ( D36 . C89 ) in ( Seg ( D31 + 1 ) ) by L240 , L267 , L269 , L286 , L290 , FINSEQ_2:11;
reconsider D48 = ( D36 . C89 ) as (Element of ( NAT )) by L294;
L295: D48 < D47 by L238 , L239 , L240 , L267 , L269 , L286 , L290 , L291 , L292 , SEQM_3:def 1;
L296: D47 in ( rng D36 ) by L240 , L267 , L269 , L286 , L291 , FUNCT_1:def 3;
reconsider D49 = ( D44 . D47 ) as (Element of RelStr (# C88 , ( (the InternalRel of C70) |_2 C88 ) #)) by L296 , L241 , L283 , FINSEQ_2:11;
L297: D49 = ( D44 /. D47 ) by L241 , L283 , L296 , PARTFUN1:def 6;
L298: ( D43 . C90 ) = D49 by L267 , L269 , L291 , FUNCT_1:12;
reconsider D50 = ( D43 . C90 ) as (Element of RelStr (# C88 , ( (the InternalRel of C70) |_2 C88 ) #)) by L298;
L299: D50 = ( D43 /. C90 ) by L291 , PARTFUN1:def 6;
L300: ( D43 . C90 ) = ( D44 . ( D36 . C90 ) ) by L267 , L269 , L291 , FUNCT_1:12;
L301: ( D43 . C89 ) = ( D44 . ( D36 . C89 ) ) by L267 , L269 , L290 , FUNCT_1:12;
L302: D48 in ( rng D36 ) by L240 , L267 , L269 , L286 , L290 , FUNCT_1:def 3;
reconsider D51 = ( D44 . D48 ) as (Element of RelStr (# C88 , ( (the InternalRel of C70) |_2 C88 ) #)) by L302 , L241 , L283 , FINSEQ_2:11;
L303: ( D43 . C89 ) = D51 by L267 , L269 , L290 , FUNCT_1:12;
reconsider D52 = ( D43 . C89 ) as (Element of RelStr (# C88 , ( (the InternalRel of C70) |_2 C88 ) #)) by L303;
L304: D52 = ( D43 /. C89 ) by L290 , PARTFUN1:def 6;
L305: D51 = ( D44 /. D48 ) by L241 , L283 , L302 , PARTFUN1:def 6;
thus L306: thesis by L305 , L241 , L277 , L280 , L283 , L301 , L300 , L295 , L302 , L296 , L297 , L304 , L299 , PRE_POLY:def 2;
end;
L307: D43 = ( SgmX ((the InternalRel of C70) , D46) ) by L289 , L267 , L269 , PRE_POLY:9;
L308: ( len ( D44 * D36 ) ) = D31 by L241 , L242 , L283 , FINSEQ_2:29;
L309: ( card D46 ) = D31 by L308 , L252 , L282 , FINSEQ_4:62;
L310: R4 in { ( SgmX ((the InternalRel of C70) , B87) ) where B87 is non  empty (Element of ( symplexes C70 )) : ( card B87 ) = D31 } by L309 , L307;
thus L311: thesis by L310 , L206 , L275;
end;
end;
L313: D37 in ( Funcs (( D30 . ( D31 + 1 ) ) , ( D30 . D31 )) ) by L264 , L250 , FUNCT_2:def 2;
thus L314: D37 in ( ( FuncsSeq D30 ) . C77 ) by L313 , L122;
reconsider D53 = C78 as (Face of D31) by L236;
take D31;
take D53;
thus L315: (C78 = D53 & C77 = D31);
let C91 being (Element of ( D30 . ( D31 + 1 ) ));
assume L316: C91 in ( D30 . ( D31 + 1 ) );
L317: (ex B88 being Function st (B88 = C91 & ( C83 . C91 ) = ( B88 * D33 ))) by L316 , L251;
let C92 being non  empty (Element of ( symplexes C70 ));
assume that
L318: ( SgmX ((the InternalRel of C70) , C92) ) = C91;
let C93 being Function;
assume L319: C93 = D37;
thus L320: thesis by L319 , L318 , L317;
end;
consider C94 being (ManySortedFunction of ( NatEmbSeq ) , ( FuncsSeq D30 )) such that L321: (for B89 being set holds (B89 in ( NAT ) implies (ex B90 being (Function of ( ( NatEmbSeq ) . B89 ) , ( ( FuncsSeq D30 ) . B89 )) st (B90 = ( C94 . B89 ) & (for B91 being set holds (B91 in ( ( NatEmbSeq ) . B89 ) implies S3[ ( B90 . B91 ) , B91 , B89 ])))))) from MSSUBFAM:sch 1(L234);
take TriangStr (# D30 , C94 #);
thus L322: ( (the SkeletonSeq of TriangStr (# D30 , C94 #)) . ( 0 ) ) = { ( {} ) } by L210;
thus L323: (for B92 being Nat holds (B92 > ( 0 ) implies ( (the SkeletonSeq of TriangStr (# D30 , C94 #)) . B92 ) = { ( SgmX ((the InternalRel of C70) , B93) ) where B93 is non  empty (Element of ( symplexes C70 )) : ( card B93 ) = B92 })) by L206;
let C95 being Nat;
L324: C95 in ( NAT ) by ORDINAL1:def 12;
consider C96 being (Function of ( ( NatEmbSeq ) . C95 ) , ( ( FuncsSeq D30 ) . C95 )) such that L325: C96 = ( C94 . C95 ) and L326: (for B94 being set holds (B94 in ( ( NatEmbSeq ) . C95 ) implies (ex B95 being Nat st (ex B96 being (Face of B95) st (B94 = B96 & C95 = B95 & (for B97 being (Element of ( D30 . ( B95 + 1 ) )) holds (B97 in ( D30 . ( B95 + 1 ) ) implies (for B98 being non  empty (Element of ( symplexes C70 )) holds (( SgmX ((the InternalRel of C70) , B98) ) = B97 implies (for B99 being Function holds (B99 = ( C96 . B94 ) implies ( B99 . B97 ) = ( ( SgmX ((the InternalRel of C70) , B98) ) * B96 )))))))))))) by L324 , L321;
let C97 being (Face of C95);
let C98 being (Element of ( (the SkeletonSeq of TriangStr (# D30 , C94 #)) . ( C95 + 1 ) ));
assume L327: C98 in ( (the SkeletonSeq of TriangStr (# D30 , C94 #)) . ( C95 + 1 ) );
let C99 being non  empty (Element of ( symplexes C70 ));
assume L328: ( SgmX ((the InternalRel of C70) , C99) ) = C98;
L329: (ex B100 being Nat st (ex B101 being (Face of B100) st (C97 = B101 & C95 = B100 & (for B102 being (Element of ( D30 . ( B100 + 1 ) )) holds (B102 in ( D30 . ( B100 + 1 ) ) implies (for B103 being non  empty (Element of ( symplexes C70 )) holds (( SgmX ((the InternalRel of C70) , B103) ) = B102 implies (for B104 being Function holds (B104 = ( C96 . C97 ) implies ( B104 . B102 ) = ( ( SgmX ((the InternalRel of C70) , B103) ) * B101 )))))))))) by L326;
L330: ( C96 . C97 ) in ( ( FuncsSeq D30 ) . C95 );
L331: ( C96 . C97 ) in ( Funcs (( D30 . ( C95 + 1 ) ) , ( D30 . C95 )) ) by L330 , L122;
consider C100 being Function such that L332: ( C96 . C97 ) = C100 and L333: ( dom C100 ) = ( D30 . ( C95 + 1 ) ) and L334: ( rng C100 ) c= ( D30 . C95 ) by L331 , FUNCT_2:def 2;
L335: ( face (C98 , C97) ) = ( C100 . C98 ) by L325 , L327 , L332 , L185;
thus L336: thesis by L335 , L327 , L328 , L329 , L332;
end;
uniqueness
proof
let C101 , C102 being  lower_non-empty  strict TriangStr;
assume that
L337: ( (the SkeletonSeq of C101) . ( 0 ) ) = { ( {} ) }
and
L338: (for B105 being Nat holds (B105 > ( 0 ) implies ( (the SkeletonSeq of C101) . B105 ) = { ( SgmX ((the InternalRel of C70) , B106) ) where B106 is non  empty (Element of ( symplexes C70 )) : ( card B106 ) = B105 }))
and
L339: (for B107 being Nat holds (for B108 being (Face of B107) holds (for B109 being (Element of ( (the SkeletonSeq of C101) . ( B107 + 1 ) )) holds (B109 in ( (the SkeletonSeq of C101) . ( B107 + 1 ) ) implies (for B110 being non  empty (Element of ( symplexes C70 )) holds (( SgmX ((the InternalRel of C70) , B110) ) = B109 implies ( face (B109 , B108) ) = ( ( SgmX ((the InternalRel of C70) , B110) ) * B108 )))))))
and
L340: ( (the SkeletonSeq of C102) . ( 0 ) ) = { ( {} ) }
and
L341: (for B111 being Nat holds (B111 > ( 0 ) implies ( (the SkeletonSeq of C102) . B111 ) = { ( SgmX ((the InternalRel of C70) , B112) ) where B112 is non  empty (Element of ( symplexes C70 )) : ( card B112 ) = B111 }))
and
L342: (for B113 being Nat holds (for B114 being (Face of B113) holds (for B115 being (Element of ( (the SkeletonSeq of C102) . ( B113 + 1 ) )) holds (B115 in ( (the SkeletonSeq of C102) . ( B113 + 1 ) ) implies (for B116 being non  empty (Element of ( symplexes C70 )) holds (( SgmX ((the InternalRel of C70) , B116) ) = B115 implies ( face (B115 , B114) ) = ( ( SgmX ((the InternalRel of C70) , B116) ) * B114 )))))));
L343: (for B117 being set holds (B117 in ( NAT ) implies ( (the SkeletonSeq of C101) . B117 ) = ( (the SkeletonSeq of C102) . B117 )))
proof
let C103 being set;
assume L344: C103 in ( NAT );
reconsider D54 = C103 as (Element of ( NAT )) by L344;
L345:
now
per cases ;
suppose L346: D54 = ( 0 );

thus L347: ( (the SkeletonSeq of C101) . D54 ) = ( (the SkeletonSeq of C102) . D54 ) by L346 , L337 , L340;
end;
suppose L348: D54 <> ( 0 );

L349: ( (the SkeletonSeq of C101) . D54 ) = { ( SgmX ((the InternalRel of C70) , B118) ) where B118 is non  empty (Element of ( symplexes C70 )) : ( card B118 ) = D54 } by L348 , L338;
thus L350: ( (the SkeletonSeq of C101) . D54 ) = ( (the SkeletonSeq of C102) . D54 ) by L349 , L341 , L348;
end;
end;
thus L352: thesis by L345;
end;
L353: (the SkeletonSeq of C101) = (the SkeletonSeq of C102) by L343 , PBOOLE:3;
L354:
now
let C104 being set;
assume L355: C104 in ( NAT );
reconsider D55 = C104 as (Element of ( NAT )) by L355;
reconsider D56 = ( (the FacesAssign of C101) . D55 ) , D57 = ( (the FacesAssign of C102) . D55 ) as (Function of ( ( NatEmbSeq ) . D55 ) , ( ( FuncsSeq (the SkeletonSeq of C101) ) . D55 )) by L353 , PBOOLE:def 15;
L356: ( dom D57 ) = ( ( NatEmbSeq ) . D55 ) by FUNCT_2:def 1;
L357:
now
let R2 being set;
assume L358: R2 in ( ( NatEmbSeq ) . D55 );
reconsider D58 = R2 as (Face of D55) by L358;
L359: ( D56 . D58 ) in ( ( FuncsSeq (the SkeletonSeq of C101) ) . D55 );
L360: ( D56 . D58 ) in ( Funcs (( (the SkeletonSeq of C101) . ( D55 + 1 ) ) , ( (the SkeletonSeq of C101) . D55 )) ) by L359 , L122;
consider C105 being Function such that L361: C105 = ( D56 . D58 ) and L362: ( dom C105 ) = ( (the SkeletonSeq of C101) . ( D55 + 1 ) ) and L363: ( rng C105 ) c= ( (the SkeletonSeq of C101) . D55 ) by L360 , FUNCT_2:def 2;
L364: ( D57 . D58 ) in ( ( FuncsSeq (the SkeletonSeq of C101) ) . D55 );
L365: ( D57 . D58 ) in ( Funcs (( (the SkeletonSeq of C101) . ( D55 + 1 ) ) , ( (the SkeletonSeq of C101) . D55 )) ) by L364 , L122;
consider C106 being Function such that L366: C106 = ( D57 . D58 ) and L367: ( dom C106 ) = ( (the SkeletonSeq of C101) . ( D55 + 1 ) ) and L368: ( rng C106 ) c= ( (the SkeletonSeq of C101) . D55 ) by L365 , FUNCT_2:def 2;
L369:
now
let R3 being set;
assume L370: R3 in ( (the SkeletonSeq of C101) . ( D55 + 1 ) );
reconsider D59 = R3 as (Symplex of C101 , ( D55 + 1 )) by L370;
L371: ( C105 . D59 ) = ( face (D59 , D58) ) by L361 , L370 , L185;
reconsider D60 = R3 as (Symplex of C102 , ( D55 + 1 )) by L343 , L370;
L372: ( C106 . D60 ) = ( face (D60 , D58) ) by L353 , L366 , L370 , L185;
L373: D59 in { ( SgmX ((the InternalRel of C70) , B119) ) where B119 is non  empty (Element of ( symplexes C70 )) : ( card B119 ) = ( D55 + 1 ) } by L338 , L370;
consider C107 being non  empty (Element of ( symplexes C70 )) such that L374: ( SgmX ((the InternalRel of C70) , C107) ) = D59 and L375: ( card C107 ) = ( D55 + 1 ) by L373;
L376: ( face (D59 , D58) ) = ( ( SgmX ((the InternalRel of C70) , C107) ) * D58 ) by L339 , L370 , L374;
thus L377: ( C105 . R3 ) = ( C106 . R3 ) by L376 , L342 , L353 , L370 , L371 , L372 , L374;
end;
thus L378: ( D56 . R2 ) = ( D57 . R2 ) by L369 , L361 , L362 , L366 , L367 , FUNCT_1:2;
end;
L379: ( dom D56 ) = ( ( NatEmbSeq ) . D55 ) by FUNCT_2:def 1;
thus L380: ( (the FacesAssign of C101) . C104 ) = ( (the FacesAssign of C102) . C104 ) by L379 , L356 , L357 , FUNCT_1:2;
end;
thus L381: thesis by L354 , L353 , PBOOLE:3;
end;
end;
