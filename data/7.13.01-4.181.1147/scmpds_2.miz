:: The SCMPDS Computer and the Basic Semantics of Its Instructions
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, STRUCT_0, AMI_1, AMI_2, FUNCT_7, SCMPDS_1,
      RELAT_1, FINSEQ_1, CARD_1, XBOOLE_0, TARSKI, FSM_1, CAT_1, AMI_3, INT_1,
      XXREAL_0, FUNCT_1, COMPLEX1, ARYTM_3, GRAPHSP, ORDINAL1, ARYTM_1, NAT_1,
      FUNCOP_1, FUNCT_4, GLIB_000, SCMPDS_2, MEMSTR_0, GOBRD13;
 notations TARSKI, XBOOLE_0, ENUMSET1,
      XTUPLE_0, SUBSET_1, XCMPLX_0, RELAT_1, FUNCT_1,
      FUNCT_2, INT_1, ORDINAL1, NAT_1, FUNCOP_1, CARD_1, STRUCT_0,
      FUNCT_4, FUNCT_7, FINSEQ_1, FINSEQ_4, NUMBERS, MEMSTR_0, COMPOS_0,
      COMPOS_1, EXTPRO_1, AMI_2, AMI_3, INT_2, XXREAL_0, SCMPDS_I, SCMPDS_1;
 constructors DOMAIN_1, REAL_1, FINSEQ_4, AMI_3, SCMPDS_1, RELSET_1, FUNCT_7,
      NAT_D, VALUED_0;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, ORDINAL1, FUNCOP_1, XREAL_0, INT_1,
      CARD_3, AMI_2, XXREAL_0, FUNCT_1, FUNCT_2, RELSET_1, EXTPRO_1, AMI_3,
      MEASURE6, PBOOLE, COMPOS_0, SCM_INST, SCMPDS_I, XTUPLE_0;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, COMPOS_1, EXTPRO_1, FUNCOP_1, AMI_2, CARD_1, SCMPDS_1,
      NAT_1, MEMSTR_0, STRUCT_0, COMPOS_0, SCMPDS_I, XTUPLE_0;
 theorems NAT_1, FUNCT_1, TARSKI, ZFMISC_1, ENUMSET1, AMI_2, FUNCOP_1, FUNCT_4,
      CARD_3, FUNCT_2, INT_1, SCMPDS_1, AMI_3, ABSVALUE, STRUCT_0, XBOOLE_0,
      XBOOLE_1, RELAT_1, XREAL_1, FUNCT_7, NUMBERS, XXREAL_0, PARTFUN1,
      RECDEF_2, EXTPRO_1, MEMSTR_0, SCMPDS_I;

begin
definition
func SCMPDS ->  strict AMI-Struct over 2 equals 
AMI-Struct (# ( SCM-Memory ) , ( In (( NAT ) , ( SCM-Memory )) ) , ( SCMPDS-Instr ) , ( SCM-OK ) , ( SCM-VAL ) , ( SCMPDS-Exec ) #);
correctness;
end;
registration
cluster ( SCMPDS ) -> non  empty;
coherence by STRUCT_0:def 1;
end;
registration
cluster ( SCMPDS ) ->  with_non-empty_values  IC-Ins-separated;
coherence
proof
thus L3: ( the_Values_of ( SCMPDS ) ) is  non-empty;
L4: ( IC ( SCMPDS ) ) = ( NAT ) by AMI_2:22 , FUNCT_7:def 1;
L5: ( Values ( IC ( SCMPDS ) ) ) = ( NAT ) by L4 , AMI_2:6;
thus L6: thesis by L5 , MEMSTR_0:def 6;
end;
end;
canceled 1;
theorem
L8: ( IC ( SCMPDS ) ) = ( NAT ) by AMI_2:22 , FUNCT_7:def 1;
begin
registration
cluster  Int-like for (Object of ( SCMPDS ));
existence
proof
reconsider D1 = the (Element of ( SCM-Data-Loc )) as (Object of ( SCMPDS ));
take D1;
thus L9: thesis by AMI_2:def 16;
end;
end;
definition
mode Int_position
 is  Int-like (Object of ( SCMPDS ));
canceled 1;
end;
canceled 2;
theorem
L12: (for B1 being Int_position holds ( Values B1 ) = ( INT ))
proof
let C1 being Int_position;
L13: C1 in ( SCM-Data-Loc ) by AMI_2:def 16;
thus L14: thesis by L13 , AMI_2:8;
end;
begin
set D2 = { [ 14 , ( {} ) , <* B2 *> ] where B2 is (Element of ( INT )) : (not contradiction) };
set D3 = { [ 1 , ( {} ) , <* R4 *> ] where R4 is (Element of ( SCM-Data-Loc )) : (not contradiction) };
set D4 = { [ B3 , ( {} ) , <* B4 , B5 *> ] where B3 is (Element of ( Segm 15 )) , B4 is (Element of ( SCM-Data-Loc )) , B5 is (Element of ( INT )) : B3 in { 2 , 3 } };
set D5 = { [ B6 , ( {} ) , <* B7 , B8 , B9 *> ] where B6 is (Element of ( Segm 15 )) , B7 is (Element of ( SCM-Data-Loc )) , B8 , B9 is (Element of ( INT )) : B6 in { 4 , 5 , 6 , 7 , 8 } };
set D6 = { [ B10 , ( {} ) , <* B11 , B12 , B13 , B14 *> ] where B10 is (Element of ( Segm 15 )) , B11 , B12 is (Element of ( SCM-Data-Loc )) , B13 , B14 is (Element of ( INT )) : B10 in { 9 , 10 , 11 , 12 , 13 } };
L15: (for R15 being (Instruction of ( SCMPDS )) holds (R15 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or R15 in D2 or R15 in D3 or R15 in D4 or R15 in D5 or R15 in D6))
proof
let R15 being (Instruction of ( SCMPDS ));
L16: (R15 in ( ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D2 ) \/ D3 ) \/ D4 ) \/ D5 ) or R15 in D6) by XBOOLE_0:def 3;
L17: (R15 in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D2 ) \/ D3 ) \/ D4 ) or R15 in D5 or R15 in D6) by L16 , XBOOLE_0:def 3;
L18: (R15 in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D2 ) \/ D3 ) or R15 in D4 or R15 in D5 or R15 in D6) by L17 , XBOOLE_0:def 3;
L19: (R15 in ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D2 ) or R15 in D3 or R15 in D4 or R15 in D5 or R15 in D6) by L18 , XBOOLE_0:def 3;
thus L20: thesis by L19 , XBOOLE_0:def 3;
end;
theorem
L21: (for B15 being (Instruction of ( SCMPDS )) holds ( InsCode B15 ) <= 14)
proof
let C2 being (Instruction of ( SCMPDS ));
L22: (( InsCode C2 ) = ( 0 ) or ( InsCode C2 ) = 1 or ( InsCode C2 ) = 2 or ( InsCode C2 ) = 3 or ( InsCode C2 ) = 4 or ( InsCode C2 ) = 5 or ( InsCode C2 ) = 6 or ( InsCode C2 ) = 7 or ( InsCode C2 ) = 8 or ( InsCode C2 ) = 9 or ( InsCode C2 ) = 10 or ( InsCode C2 ) = 11 or ( InsCode C2 ) = 12 or ( InsCode C2 ) = 13 or ( InsCode C2 ) = 14) by SCMPDS_I:8;
thus L23: thesis by L22;
end;
registration
let C3 being (State of ( SCMPDS ));
let C4 being Int_position;
cluster ( C3 . C4 ) ->  integer;
coherence
proof
reconsider D7 = C4 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D8 = C3 as SCM-State by CARD_3:107;
L24: ( D8 . D7 ) = ( C3 . C4 );
thus L25: thesis by L24;
end;
end;
definition
let C5 , C6 being Integer;
func DataLoc (C5 , C6) -> Int_position equals 
[ 1 , ( abs ( C5 + C6 ) ) ];
coherence
proof
L27: [ 1 , ( abs ( C5 + C6 ) ) ] in ( SCM-Data-Loc ) by AMI_2:24;
thus L28: thesis by L27 , AMI_2:def 16;
end;
end;
theorem
L30: (for R9 being Integer holds [ 14 , ( {} ) , <* R9 *> ] in ( SCMPDS-Instr ))
proof
let R9 being Integer;
L31: R9 is (Element of ( INT )) by INT_1:def 2;
L32: [ 14 , ( {} ) , <* R9 *> ] in D2 by L31;
L33: [ 14 , ( {} ) , <* R9 *> ] in ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D2 ) by L32 , XBOOLE_0:def 3;
L34: [ 14 , ( {} ) , <* R9 *> ] in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D2 ) \/ D3 ) by L33 , XBOOLE_0:def 3;
L35: [ 14 , ( {} ) , <* R9 *> ] in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D2 ) \/ D3 ) \/ D4 ) by L34 , XBOOLE_0:def 3;
L36: [ 14 , ( {} ) , <* R9 *> ] in ( ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D2 ) \/ D3 ) \/ D4 ) \/ D5 ) by L35 , XBOOLE_0:def 3;
thus L37: thesis by L36 , XBOOLE_0:def 3;
end;
theorem
L38: (for R4 being (Element of ( SCM-Data-Loc )) holds [ 1 , ( {} ) , <* R4 *> ] in ( SCMPDS-Instr ))
proof
let R4 being (Element of ( SCM-Data-Loc ));
L39: [ 1 , ( {} ) , <* R4 *> ] in D3;
L40: [ 1 , ( {} ) , <* R4 *> ] in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D2 ) \/ D3 ) by L39 , XBOOLE_0:def 3;
L41: [ 1 , ( {} ) , <* R4 *> ] in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D2 ) \/ D3 ) \/ D4 ) by L40 , XBOOLE_0:def 3;
L42: [ 1 , ( {} ) , <* R4 *> ] in ( ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D2 ) \/ D3 ) \/ D4 ) \/ D5 ) by L41 , XBOOLE_0:def 3;
thus L43: thesis by L42 , XBOOLE_0:def 3;
end;
theorem
L44: (for R1 being set holds (for R5 being (Element of ( SCM-Data-Loc )) holds (for R10 being Integer holds (R1 in { 2 , 3 } implies [ R1 , ( {} ) , <* R5 , R10 *> ] in ( SCMPDS-Instr )))))
proof
let R1 being set;
let R5 being (Element of ( SCM-Data-Loc ));
let R10 being Integer;
assume L45: R1 in { 2 , 3 };
L46: (R1 = 2 or R1 = 3) by L45 , TARSKI:def 2;
reconsider D9 = R1 as (Element of ( Segm 15 )) by L46 , NAT_1:44;
L47: R10 is (Element of ( INT )) by INT_1:def 2;
L48: [ D9 , ( {} ) , <* R5 , R10 *> ] in D4 by L47 , L45;
L49: [ D9 , ( {} ) , <* R5 , R10 *> ] in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D2 ) \/ D3 ) \/ D4 ) by L48 , XBOOLE_0:def 3;
L50: [ D9 , ( {} ) , <* R5 , R10 *> ] in ( ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D2 ) \/ D3 ) \/ D4 ) \/ D5 ) by L49 , XBOOLE_0:def 3;
thus L51: thesis by L50 , XBOOLE_0:def 3;
end;
theorem
L52: (for R1 being set holds (for R5 being (Element of ( SCM-Data-Loc )) holds (for R11 being Integer holds (for R12 being Integer holds (R1 in { 4 , 5 , 6 , 7 , 8 } implies [ R1 , ( {} ) , <* R5 , R11 , R12 *> ] in ( SCMPDS-Instr ))))))
proof
let R1 being set;
let R5 being (Element of ( SCM-Data-Loc ));
let R11 being Integer;
let R12 being Integer;
assume L53: R1 in { 4 , 5 , 6 , 7 , 8 };
L54: (R1 = 4 or R1 = 5 or R1 = 6 or R1 = 7 or R1 = 8) by L53 , ENUMSET1:def 3;
reconsider D10 = R1 as (Element of ( Segm 15 )) by L54 , NAT_1:44;
L55: (R11 is (Element of ( INT )) & R12 is (Element of ( INT ))) by INT_1:def 2;
L56: [ D10 , ( {} ) , <* R5 , R11 , R12 *> ] in D5 by L55 , L53;
L57: [ D10 , ( {} ) , <* R5 , R11 , R12 *> ] in ( ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D2 ) \/ D3 ) \/ D4 ) \/ D5 ) by L56 , XBOOLE_0:def 3;
thus L58: thesis by L57 , XBOOLE_0:def 3;
end;
theorem
L59: (for R1 being set holds (for R7 being (Element of ( SCM-Data-Loc )) holds (for R8 being (Element of ( SCM-Data-Loc )) holds (for R13 being Integer holds (for R14 being Integer holds (R1 in { 9 , 10 , 11 , 12 , 13 } implies [ R1 , ( {} ) , <* R7 , R8 , R13 , R14 *> ] in ( SCMPDS-Instr )))))))
proof
let R1 being set;
let R7 being (Element of ( SCM-Data-Loc ));
let R8 being (Element of ( SCM-Data-Loc ));
let R13 being Integer;
let R14 being Integer;
assume L60: R1 in { 9 , 10 , 11 , 12 , 13 };
L61: (R1 = 9 or R1 = 10 or R1 = 11 or R1 = 12 or R1 = 13) by L60 , ENUMSET1:def 3;
reconsider D11 = R1 as (Element of ( Segm 15 )) by L61 , NAT_1:44;
L62: (R13 is (Element of ( INT )) & R14 is (Element of ( INT ))) by INT_1:def 2;
L63: [ D11 , ( {} ) , <* R7 , R8 , R13 , R14 *> ] in D6 by L62 , L60;
thus L64: thesis by L63 , XBOOLE_0:def 3;
end;
definition
let R9 being Integer;
func goto R9 -> (Instruction of ( SCMPDS )) equals 
[ 14 , ( {} ) , <* R9 *> ];
correctness by L30;
end;
definition
let R16 being Int_position;
func return R16 -> (Instruction of ( SCMPDS )) equals 
[ 1 , ( {} ) , <* R16 *> ];
correctness
proof
reconsider D12 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
L66: [ 1 , ( {} ) , <* D12 *> ] in ( SCMPDS-Instr ) by L38;
thus L67: thesis by L66;
end;
end;
definition
let R16 being Int_position;
let R9 being Integer;
func R16 := R9 -> (Instruction of ( SCMPDS )) equals 
[ 2 , ( {} ) , <* R16 , R9 *> ];
correctness
proof
reconsider D13 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
L69: 2 in { 2 , 3 } by TARSKI:def 2;
L70: [ 2 , ( {} ) , <* D13 , R9 *> ] in ( SCMPDS-Instr ) by L69 , L44;
thus L71: thesis by L70;
end;
func saveIC (R16 , R9) -> (Instruction of ( SCMPDS )) equals 
[ 3 , ( {} ) , <* R16 , R9 *> ];
correctness
proof
reconsider D14 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
L72: 3 in { 2 , 3 } by TARSKI:def 2;
L73: [ 3 , ( {} ) , <* D14 , R9 *> ] in ( SCMPDS-Instr ) by L72 , L44;
thus L74: thesis by L73;
end;
end;
definition
let R16 being Int_position;
let R9 being Integer;
let R10 being Integer;
func (R16 , R9) <>0_goto R10 -> (Instruction of ( SCMPDS )) equals 
[ 4 , ( {} ) , <* R16 , R9 , R10 *> ];
correctness
proof
reconsider D15 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
L76: 4 in { 4 , 5 , 6 , 7 , 8 } by ENUMSET1:def 3;
L77: [ 4 , ( {} ) , <* D15 , R9 , R10 *> ] in ( SCMPDS-Instr ) by L76 , L52;
thus L78: thesis by L77;
end;
func (R16 , R9) <=0_goto R10 -> (Instruction of ( SCMPDS )) equals 
[ 5 , ( {} ) , <* R16 , R9 , R10 *> ];
correctness
proof
reconsider D16 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
L79: 5 in { 4 , 5 , 6 , 7 , 8 } by ENUMSET1:def 3;
L80: [ 5 , ( {} ) , <* D16 , R9 , R10 *> ] in ( SCMPDS-Instr ) by L79 , L52;
thus L81: thesis by L80;
end;
func (R16 , R9) >=0_goto R10 -> (Instruction of ( SCMPDS )) equals 
[ 6 , ( {} ) , <* R16 , R9 , R10 *> ];
correctness
proof
reconsider D17 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
L82: 6 in { 4 , 5 , 6 , 7 , 8 } by ENUMSET1:def 3;
L83: [ 6 , ( {} ) , <* D17 , R9 , R10 *> ] in ( SCMPDS-Instr ) by L82 , L52;
thus L84: thesis by L83;
end;
func (R16 , R9) := R10 -> (Instruction of ( SCMPDS )) equals 
[ 7 , ( {} ) , <* R16 , R9 , R10 *> ];
correctness
proof
reconsider D18 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
L85: 7 in { 4 , 5 , 6 , 7 , 8 } by ENUMSET1:def 3;
L86: [ 7 , ( {} ) , <* D18 , R9 , R10 *> ] in ( SCMPDS-Instr ) by L85 , L52;
thus L87: thesis by L86;
end;
func AddTo (R16 , R9 , R10) -> (Instruction of ( SCMPDS )) equals 
[ 8 , ( {} ) , <* R16 , R9 , R10 *> ];
correctness
proof
reconsider D19 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
L88: 8 in { 4 , 5 , 6 , 7 , 8 } by ENUMSET1:def 3;
L89: [ 8 , ( {} ) , <* D19 , R9 , R10 *> ] in ( SCMPDS-Instr ) by L88 , L52;
thus L90: thesis by L89;
end;
end;
definition
let R16 being Int_position;
let R17 being Int_position;
let R9 being Integer;
let R10 being Integer;
func AddTo (R16 , R9 , R17 , R10) -> (Instruction of ( SCMPDS )) equals 
[ 9 , ( {} ) , <* R16 , R17 , R9 , R10 *> ];
correctness
proof
reconsider D20 = R16 , D21 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
L92: 9 in { 9 , 10 , 11 , 12 , 13 } by ENUMSET1:def 3;
L93: [ 9 , ( {} ) , <* D20 , D21 , R9 , R10 *> ] in ( SCMPDS-Instr ) by L92 , L59;
thus L94: thesis by L93;
end;
func SubFrom (R16 , R9 , R17 , R10) -> (Instruction of ( SCMPDS )) equals 
[ 10 , ( {} ) , <* R16 , R17 , R9 , R10 *> ];
correctness
proof
reconsider D22 = R16 , D23 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
L95: 10 in { 9 , 10 , 11 , 12 , 13 } by ENUMSET1:def 3;
L96: [ 10 , ( {} ) , <* D22 , D23 , R9 , R10 *> ] in ( SCMPDS-Instr ) by L95 , L59;
thus L97: thesis by L96;
end;
func MultBy (R16 , R9 , R17 , R10) -> (Instruction of ( SCMPDS )) equals 
[ 11 , ( {} ) , <* R16 , R17 , R9 , R10 *> ];
correctness
proof
reconsider D24 = R16 , D25 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
L98: 11 in { 9 , 10 , 11 , 12 , 13 } by ENUMSET1:def 3;
L99: [ 11 , ( {} ) , <* D24 , D25 , R9 , R10 *> ] in ( SCMPDS-Instr ) by L98 , L59;
thus L100: thesis by L99;
end;
func Divide (R16 , R9 , R17 , R10) -> (Instruction of ( SCMPDS )) equals 
[ 12 , ( {} ) , <* R16 , R17 , R9 , R10 *> ];
correctness
proof
reconsider D26 = R16 , D27 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
L101: 12 in { 9 , 10 , 11 , 12 , 13 } by ENUMSET1:def 3;
L102: [ 12 , ( {} ) , <* D26 , D27 , R9 , R10 *> ] in ( SCMPDS-Instr ) by L101 , L59;
thus L103: thesis by L102;
end;
func (R16 , R9) := (R17 , R10) -> (Instruction of ( SCMPDS )) equals 
[ 13 , ( {} ) , <* R16 , R17 , R9 , R10 *> ];
correctness
proof
reconsider D28 = R16 , D29 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
L104: 13 in { 9 , 10 , 11 , 12 , 13 } by ENUMSET1:def 3;
L105: [ 13 , ( {} ) , <* D28 , D29 , R9 , R10 *> ] in ( SCMPDS-Instr ) by L104 , L59;
thus L106: thesis by L105;
end;
end;
theorem
L108: (for R9 being Integer holds ( InsCode ( goto R9 ) ) = 14) by RECDEF_2:def 1;
theorem
L109: (for R16 being Int_position holds ( InsCode ( return R16 ) ) = 1) by RECDEF_2:def 1;
theorem
L110: (for R9 being Integer holds (for R16 being Int_position holds ( InsCode ( R16 := R9 ) ) = 2)) by RECDEF_2:def 1;
theorem
L111: (for R9 being Integer holds (for R16 being Int_position holds ( InsCode ( saveIC (R16 , R9) ) ) = 3)) by RECDEF_2:def 1;
theorem
L112: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds ( InsCode ( (R16 , R9) <>0_goto R10 ) ) = 4))) by RECDEF_2:def 1;
theorem
L113: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds ( InsCode ( (R16 , R9) <=0_goto R10 ) ) = 5))) by RECDEF_2:def 1;
theorem
L114: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds ( InsCode ( (R16 , R9) >=0_goto R10 ) ) = 6))) by RECDEF_2:def 1;
theorem
L115: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds ( InsCode ( (R16 , R9) := R10 ) ) = 7))) by RECDEF_2:def 1;
theorem
L116: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds ( InsCode ( AddTo (R16 , R9 , R10) ) ) = 8))) by RECDEF_2:def 1;
theorem
L117: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds ( InsCode ( AddTo (R16 , R9 , R17 , R10) ) ) = 9)))) by RECDEF_2:def 1;
theorem
L118: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds ( InsCode ( SubFrom (R16 , R9 , R17 , R10) ) ) = 10)))) by RECDEF_2:def 1;
theorem
L119: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds ( InsCode ( MultBy (R16 , R9 , R17 , R10) ) ) = 11)))) by RECDEF_2:def 1;
theorem
L120: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds ( InsCode ( Divide (R16 , R9 , R17 , R10) ) ) = 12)))) by RECDEF_2:def 1;
theorem
L121: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds ( InsCode ( (R16 , R9) := (R17 , R10) ) ) = 13)))) by RECDEF_2:def 1;
L122: (for R15 being (Instruction of ( SCMPDS )) holds (R15 in { [ 14 , ( {} ) , <* B16 *> ] where B16 is (Element of ( INT )) : (not contradiction) } implies ( InsCode R15 ) = 14))
proof
let R15 being (Instruction of ( SCMPDS ));
assume L123: R15 in { [ 14 , ( {} ) , <* B17 *> ] where B17 is (Element of ( INT )) : (not contradiction) };
L124: (ex B18 being (Element of ( INT )) st R15 = [ 14 , ( {} ) , <* B18 *> ]) by L123;
thus L125: thesis by L124 , RECDEF_2:def 1;
end;
L126: (for R15 being (Instruction of ( SCMPDS )) holds (R15 in { [ 1 , ( {} ) , <* R4 *> ] where R4 is (Element of ( SCM-Data-Loc )) : (not contradiction) } implies ( InsCode R15 ) = 1))
proof
let R15 being (Instruction of ( SCMPDS ));
assume L127: R15 in { [ 1 , ( {} ) , <* R4 *> ] where R4 is (Element of ( SCM-Data-Loc )) : (not contradiction) };
L128: (ex R4 being (Element of ( SCM-Data-Loc )) st R15 = [ 1 , ( {} ) , <* R4 *> ]) by L127;
thus L129: thesis by L128 , RECDEF_2:def 1;
end;
L130: (for R15 being (Instruction of ( SCMPDS )) holds (R15 in { [ B19 , ( {} ) , <* B20 , B21 *> ] where B19 is (Element of ( Segm 15 )) , B20 is (Element of ( SCM-Data-Loc )) , B21 is (Element of ( INT )) : B19 in { 2 , 3 } } implies (( InsCode R15 ) = 2 or ( InsCode R15 ) = 3)))
proof
let R15 being (Instruction of ( SCMPDS ));
assume L131: R15 in { [ B22 , ( {} ) , <* B23 , B24 *> ] where B22 is (Element of ( Segm 15 )) , B23 is (Element of ( SCM-Data-Loc )) , B24 is (Element of ( INT )) : B22 in { 2 , 3 } };
consider C7 being (Element of ( Segm 15 )), C8 being (Element of ( SCM-Data-Loc )), C9 being (Element of ( INT )) such that L132: R15 = [ C7 , ( {} ) , <* C8 , C9 *> ] and L133: C7 in { 2 , 3 } by L131;
L134: (C7 = 2 or C7 = 3) by L133 , TARSKI:def 2;
thus L135: thesis by L134 , L132 , RECDEF_2:def 1;
end;
L136: (for R15 being (Instruction of ( SCMPDS )) holds (R15 in { [ B25 , ( {} ) , <* B26 , B27 , B28 *> ] where B25 is (Element of ( Segm 15 )) , B26 is (Element of ( SCM-Data-Loc )) , B27 , B28 is (Element of ( INT )) : B25 in { 4 , 5 , 6 , 7 , 8 } } implies (( InsCode R15 ) = 4 or ( InsCode R15 ) = 5 or ( InsCode R15 ) = 6 or ( InsCode R15 ) = 7 or ( InsCode R15 ) = 8)))
proof
let R15 being (Instruction of ( SCMPDS ));
assume L137: R15 in { [ B29 , ( {} ) , <* B30 , B31 , B32 *> ] where B29 is (Element of ( Segm 15 )) , B30 is (Element of ( SCM-Data-Loc )) , B31 , B32 is (Element of ( INT )) : B29 in { 4 , 5 , 6 , 7 , 8 } };
consider C10 being (Element of ( Segm 15 )), C11 being (Element of ( SCM-Data-Loc )), C12 , C13 being (Element of ( INT )) such that L138: R15 = [ C10 , ( {} ) , <* C11 , C12 , C13 *> ] and L139: C10 in { 4 , 5 , 6 , 7 , 8 } by L137;
L140: (C10 = 4 or C10 = 5 or C10 = 6 or C10 = 7 or C10 = 8) by L139 , ENUMSET1:def 3;
thus L141: thesis by L140 , L138 , RECDEF_2:def 1;
end;
L142: (for R15 being (Instruction of ( SCMPDS )) holds (R15 in { [ B33 , ( {} ) , <* B34 , B35 , B36 , B37 *> ] where B33 is (Element of ( Segm 15 )) , B34 , B35 is (Element of ( SCM-Data-Loc )) , B36 , B37 is (Element of ( INT )) : B33 in { 9 , 10 , 11 , 12 , 13 } } implies (( InsCode R15 ) = 9 or ( InsCode R15 ) = 10 or ( InsCode R15 ) = 11 or ( InsCode R15 ) = 12 or ( InsCode R15 ) = 13)))
proof
let R15 being (Instruction of ( SCMPDS ));
assume L143: R15 in { [ B38 , ( {} ) , <* B39 , B40 , B41 , B42 *> ] where B38 is (Element of ( Segm 15 )) , B39 , B40 is (Element of ( SCM-Data-Loc )) , B41 , B42 is (Element of ( INT )) : B38 in { 9 , 10 , 11 , 12 , 13 } };
consider C14 being (Element of ( Segm 15 )), C15 , C16 being (Element of ( SCM-Data-Loc )), C17 , C18 being (Element of ( INT )) such that L144: R15 = [ C14 , ( {} ) , <* C15 , C16 , C17 , C18 *> ] and L145: C14 in { 9 , 10 , 11 , 12 , 13 } by L143;
L146: (C14 = 9 or C14 = 10 or C14 = 11 or C14 = 12 or C14 = 13) by L145 , ENUMSET1:def 3;
thus L147: thesis by L146 , L144 , RECDEF_2:def 1;
end;
L148: (for R15 being (Instruction of ( SCMPDS )) holds (R15 in { [ ( 0 ) , ( {} ) , ( {} ) ] } implies ( InsCode R15 ) = ( 0 )))
proof
let R15 being (Instruction of ( SCMPDS ));
assume L149: R15 in { [ ( 0 ) , ( {} ) , ( {} ) ] };
L150: R15 = [ ( 0 ) , ( {} ) , ( {} ) ] by L149 , TARSKI:def 1;
thus L151: thesis by L150 , RECDEF_2:def 1;
end;
theorem
L152: (for B43 being (Instruction of ( SCMPDS )) holds (( InsCode B43 ) = 14 implies (ex R9 being Integer st B43 = ( goto R9 ))))
proof
let C19 being (Instruction of ( SCMPDS ));
assume that
L153: ( InsCode C19 ) = 14;
L154: (C19 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or C19 in D2 or C19 in D3 or C19 in D4 or C19 in D5 or C19 in D6) by L15;
consider C20 being (Element of ( INT )) such that L155: C19 = [ 14 , ( {} ) , <* C20 *> ] by L154 , L153 , L126 , L130 , L136 , L142 , L148;
take C20;
thus L156: thesis by L155;
end;
theorem
L157: (for B44 being (Instruction of ( SCMPDS )) holds (( InsCode B44 ) = 1 implies (ex R16 being Int_position st B44 = ( return R16 ))))
proof
let C21 being (Instruction of ( SCMPDS ));
assume that
L158: ( InsCode C21 ) = 1;
L159: (C21 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or C21 in D2 or C21 in D3 or C21 in D4 or C21 in D5 or C21 in D6) by L15;
consider R4 being (Element of ( SCM-Data-Loc )) such that L160: C21 = [ 1 , ( {} ) , <* R4 *> ] by L159 , L158 , L122 , L130 , L136 , L142 , L148;
reconsider D30 = R4 as Int_position by AMI_2:def 16;
take D30;
thus L161: thesis by L160;
end;
theorem
L162: (for B45 being (Instruction of ( SCMPDS )) holds (( InsCode B45 ) = 2 implies (ex R16 being Int_position st (ex R9 being Integer st B45 = ( R16 := R9 )))))
proof
let C22 being (Instruction of ( SCMPDS ));
assume that
L163: ( InsCode C22 ) = 2;
L164: (C22 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or C22 in D2 or C22 in D3 or C22 in D4 or C22 in D5 or C22 in D6) by L15;
consider C23 being (Element of ( Segm 15 )), C24 being (Element of ( SCM-Data-Loc )), C25 being (Element of ( INT )) such that L165: C22 = [ C23 , ( {} ) , <* C24 , C25 *> ] and L166: C23 in { 2 , 3 } by L164 , L163 , L122 , L126 , L136 , L142 , L148;
L167: (C23 = 2 or C23 = 3) by L166 , TARSKI:def 2;
consider R4 being (Element of ( SCM-Data-Loc )), R9 being Integer such that L168: C22 = [ 2 , ( {} ) , <* R4 , R9 *> ] by L167 , L163 , L165 , RECDEF_2:def 1;
reconsider D31 = R4 as Int_position by AMI_2:def 16;
take D31;
take R9;
thus L169: thesis by L168;
end;
theorem
L170: (for B46 being (Instruction of ( SCMPDS )) holds (( InsCode B46 ) = 3 implies (ex R16 being Int_position st (ex R9 being Integer st B46 = ( saveIC (R16 , R9) )))))
proof
let C26 being (Instruction of ( SCMPDS ));
assume that
L171: ( InsCode C26 ) = 3;
L172: (C26 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or C26 in D2 or C26 in D3 or C26 in D4 or C26 in D5 or C26 in D6) by L15;
consider C27 being (Element of ( Segm 15 )), C28 being (Element of ( SCM-Data-Loc )), C29 being (Element of ( INT )) such that L173: C26 = [ C27 , ( {} ) , <* C28 , C29 *> ] and L174: C27 in { 2 , 3 } by L172 , L171 , L122 , L126 , L136 , L142 , L148;
L175: (C27 = 2 or C27 = 3) by L174 , TARSKI:def 2;
consider R4 being (Element of ( SCM-Data-Loc )), R9 being Integer such that L176: C26 = [ 3 , ( {} ) , <* R4 , R9 *> ] by L175 , L171 , L173 , RECDEF_2:def 1;
reconsider D32 = R4 as Int_position by AMI_2:def 16;
take D32;
take R9;
thus L177: thesis by L176;
end;
L178: (for R15 being (Instruction of ( SCMPDS )) holds ((R15 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or R15 in D2 or R15 in D3 or R15 in D4 or R15 in D6) implies (( InsCode R15 ) = ( 0 ) or ( InsCode R15 ) = 14 or ( InsCode R15 ) = 1 or ( InsCode R15 ) = 2 or ( InsCode R15 ) = 3 or ( InsCode R15 ) = 9 or ( InsCode R15 ) = 10 or ( InsCode R15 ) = 11 or ( InsCode R15 ) = 12 or ( InsCode R15 ) = 13))) by L122 , L126 , L130 , L142 , L148;
theorem
L179: (for B47 being (Instruction of ( SCMPDS )) holds (( InsCode B47 ) = 4 implies (ex R16 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B47 = ( (R16 , R9) <>0_goto R10 ))))))
proof
let C30 being (Instruction of ( SCMPDS ));
assume that
L180: ( InsCode C30 ) = 4;
L181: (C30 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or C30 in D2 or C30 in D3 or C30 in D4 or C30 in D5 or C30 in D6) by L15;
consider C31 being (Element of ( Segm 15 )), C32 being (Element of ( SCM-Data-Loc )), C33 , C34 being (Element of ( INT )) such that L182: C30 = [ C31 , ( {} ) , <* C32 , C33 , C34 *> ] and L183: C31 in { 4 , 5 , 6 , 7 , 8 } by L181 , L180 , L178;
L184: (C31 = 4 or C31 = 5 or C31 = 6 or C31 = 7 or C31 = 8) by L183 , ENUMSET1:def 3;
consider R4 being (Element of ( SCM-Data-Loc )), R9 being Integer, R10 being Integer such that L185: C30 = [ 4 , ( {} ) , <* R4 , R9 , R10 *> ] by L184 , L180 , L182 , RECDEF_2:def 1;
reconsider D33 = R4 as Int_position by AMI_2:def 16;
take D33;
take R9;
take R10;
thus L186: thesis by L185;
end;
theorem
L187: (for B48 being (Instruction of ( SCMPDS )) holds (( InsCode B48 ) = 5 implies (ex R16 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B48 = ( (R16 , R9) <=0_goto R10 ))))))
proof
let C35 being (Instruction of ( SCMPDS ));
assume that
L188: ( InsCode C35 ) = 5;
L189: (C35 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or C35 in D2 or C35 in D3 or C35 in D4 or C35 in D5 or C35 in D6) by L15;
consider C36 being (Element of ( Segm 15 )), C37 being (Element of ( SCM-Data-Loc )), C38 , C39 being (Element of ( INT )) such that L190: C35 = [ C36 , ( {} ) , <* C37 , C38 , C39 *> ] and L191: C36 in { 4 , 5 , 6 , 7 , 8 } by L189 , L188 , L178;
L192: (C36 = 4 or C36 = 5 or C36 = 6 or C36 = 7 or C36 = 8) by L191 , ENUMSET1:def 3;
consider R4 being (Element of ( SCM-Data-Loc )), R9 being Integer, R10 being Integer such that L193: C35 = [ 5 , ( {} ) , <* R4 , R9 , R10 *> ] by L192 , L188 , L190 , RECDEF_2:def 1;
reconsider D34 = R4 as Int_position by AMI_2:def 16;
take D34;
take R9;
take R10;
thus L194: thesis by L193;
end;
theorem
L195: (for B49 being (Instruction of ( SCMPDS )) holds (( InsCode B49 ) = 6 implies (ex R16 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B49 = ( (R16 , R9) >=0_goto R10 ))))))
proof
let C40 being (Instruction of ( SCMPDS ));
assume that
L196: ( InsCode C40 ) = 6;
L197: (C40 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or C40 in D2 or C40 in D3 or C40 in D4 or C40 in D5 or C40 in D6) by L15;
consider C41 being (Element of ( Segm 15 )), C42 being (Element of ( SCM-Data-Loc )), C43 , C44 being (Element of ( INT )) such that L198: C40 = [ C41 , ( {} ) , <* C42 , C43 , C44 *> ] and L199: C41 in { 4 , 5 , 6 , 7 , 8 } by L197 , L196 , L178;
L200: (C41 = 4 or C41 = 5 or C41 = 6 or C41 = 7 or C41 = 8) by L199 , ENUMSET1:def 3;
consider R4 being (Element of ( SCM-Data-Loc )), R9 being Integer, R10 being Integer such that L201: C40 = [ 6 , ( {} ) , <* R4 , R9 , R10 *> ] by L200 , L196 , L198 , RECDEF_2:def 1;
reconsider D35 = R4 as Int_position by AMI_2:def 16;
take D35;
take R9;
take R10;
thus L202: thesis by L201;
end;
theorem
L203: (for B50 being (Instruction of ( SCMPDS )) holds (( InsCode B50 ) = 7 implies (ex R16 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B50 = ( (R16 , R9) := R10 ))))))
proof
let C45 being (Instruction of ( SCMPDS ));
assume that
L204: ( InsCode C45 ) = 7;
L205: (C45 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or C45 in D2 or C45 in D3 or C45 in D4 or C45 in D5 or C45 in D6) by L15;
consider C46 being (Element of ( Segm 15 )), C47 being (Element of ( SCM-Data-Loc )), C48 , C49 being (Element of ( INT )) such that L206: C45 = [ C46 , ( {} ) , <* C47 , C48 , C49 *> ] and L207: C46 in { 4 , 5 , 6 , 7 , 8 } by L205 , L204 , L178;
L208: (C46 = 4 or C46 = 5 or C46 = 6 or C46 = 7 or C46 = 8) by L207 , ENUMSET1:def 3;
consider R4 being (Element of ( SCM-Data-Loc )), R9 being Integer, R10 being Integer such that L209: C45 = [ 7 , ( {} ) , <* R4 , R9 , R10 *> ] by L208 , L204 , L206 , RECDEF_2:def 1;
reconsider D36 = R4 as Int_position by AMI_2:def 16;
take D36;
take R9;
take R10;
thus L210: thesis by L209;
end;
theorem
L211: (for B51 being (Instruction of ( SCMPDS )) holds (( InsCode B51 ) = 8 implies (ex R16 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B51 = ( AddTo (R16 , R9 , R10) ))))))
proof
let C50 being (Instruction of ( SCMPDS ));
assume that
L212: ( InsCode C50 ) = 8;
L213: (C50 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or C50 in D2 or C50 in D3 or C50 in D4 or C50 in D5 or C50 in D6) by L15;
consider C51 being (Element of ( Segm 15 )), C52 being (Element of ( SCM-Data-Loc )), C53 , C54 being (Element of ( INT )) such that L214: C50 = [ C51 , ( {} ) , <* C52 , C53 , C54 *> ] and L215: C51 in { 4 , 5 , 6 , 7 , 8 } by L213 , L212 , L178;
L216: (C51 = 4 or C51 = 5 or C51 = 6 or C51 = 7 or C51 = 8) by L215 , ENUMSET1:def 3;
consider R4 being (Element of ( SCM-Data-Loc )), R9 being Integer, R10 being Integer such that L217: C50 = [ 8 , ( {} ) , <* R4 , R9 , R10 *> ] by L216 , L212 , L214 , RECDEF_2:def 1;
reconsider D37 = R4 as Int_position by AMI_2:def 16;
take D37;
take R9;
take R10;
thus L218: thesis by L217;
end;
L219: (for R15 being (Instruction of ( SCMPDS )) holds ((R15 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or R15 in D2 or R15 in D3 or R15 in D4 or R15 in D5) implies (( InsCode R15 ) = ( 0 ) or ( InsCode R15 ) = 14 or ( InsCode R15 ) = 1 or ( InsCode R15 ) = 2 or ( InsCode R15 ) = 3 or ( InsCode R15 ) = 4 or ( InsCode R15 ) = 5 or ( InsCode R15 ) = 6 or ( InsCode R15 ) = 7 or ( InsCode R15 ) = 8)))
proof
let R15 being (Instruction of ( SCMPDS ));
assume L220: (R15 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or R15 in D2 or R15 in D3 or R15 in D4 or R15 in D5);
per cases  by L220;
suppose L221: R15 in { [ ( 0 ) , ( {} ) , ( {} ) ] };

thus L222: thesis by L221 , L148;
end;
suppose L223: R15 in D2;

thus L224: thesis by L223 , L122;
end;
suppose L225: R15 in D3;

thus L226: thesis by L225 , L126;
end;
suppose L227: R15 in D4;

thus L228: thesis by L227 , L130;
end;
suppose L229: R15 in D5;

thus L230: thesis by L229 , L136;
end;
end;
theorem
L232: (for B52 being (Instruction of ( SCMPDS )) holds (( InsCode B52 ) = 9 implies (ex R16 being Int_position st (ex R17 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B52 = ( AddTo (R16 , R9 , R17 , R10) )))))))
proof
let C55 being (Instruction of ( SCMPDS ));
assume that
L233: ( InsCode C55 ) = 9;
L234: (C55 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or C55 in D2 or C55 in D3 or C55 in D4 or C55 in D5 or C55 in D6) by L15;
consider C56 being (Element of ( Segm 15 )), C57 , C58 being (Element of ( SCM-Data-Loc )), C59 , C60 being (Element of ( INT )) such that L235: C55 = [ C56 , ( {} ) , <* C57 , C58 , C59 , C60 *> ] and L236: C56 in { 9 , 10 , 11 , 12 , 13 } by L234 , L233 , L219;
L237: (C56 = 9 or C56 = 10 or C56 = 11 or C56 = 12 or C56 = 13) by L236 , ENUMSET1:def 3;
consider R4 being (Element of ( SCM-Data-Loc )), R5 being (Element of ( SCM-Data-Loc )), R9 being Integer, R10 being Integer such that L238: C55 = [ 9 , ( {} ) , <* R4 , R5 , R9 , R10 *> ] by L237 , L233 , L235 , RECDEF_2:def 1;
reconsider D38 = R4 , D39 = R5 as Int_position by AMI_2:def 16;
take D38;
take D39;
take R9;
take R10;
thus L239: thesis by L238;
end;
theorem
L240: (for B53 being (Instruction of ( SCMPDS )) holds (( InsCode B53 ) = 10 implies (ex R16 being Int_position st (ex R17 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B53 = ( SubFrom (R16 , R9 , R17 , R10) )))))))
proof
let C61 being (Instruction of ( SCMPDS ));
assume that
L241: ( InsCode C61 ) = 10;
L242: (C61 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or C61 in D2 or C61 in D3 or C61 in D4 or C61 in D5 or C61 in D6) by L15;
consider C62 being (Element of ( Segm 15 )), C63 , C64 being (Element of ( SCM-Data-Loc )), C65 , C66 being (Element of ( INT )) such that L243: C61 = [ C62 , ( {} ) , <* C63 , C64 , C65 , C66 *> ] and L244: C62 in { 9 , 10 , 11 , 12 , 13 } by L242 , L241 , L219;
L245: (C62 = 9 or C62 = 10 or C62 = 11 or C62 = 12 or C62 = 13) by L244 , ENUMSET1:def 3;
consider R4 being (Element of ( SCM-Data-Loc )), R5 being (Element of ( SCM-Data-Loc )), R9 being Integer, R10 being Integer such that L246: C61 = [ 10 , ( {} ) , <* R4 , R5 , R9 , R10 *> ] by L245 , L241 , L243 , RECDEF_2:def 1;
reconsider D40 = R4 , D41 = R5 as Int_position by AMI_2:def 16;
take D40;
take D41;
take R9;
take R10;
thus L247: thesis by L246;
end;
theorem
L248: (for B54 being (Instruction of ( SCMPDS )) holds (( InsCode B54 ) = 11 implies (ex R16 being Int_position st (ex R17 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B54 = ( MultBy (R16 , R9 , R17 , R10) )))))))
proof
let C67 being (Instruction of ( SCMPDS ));
assume that
L249: ( InsCode C67 ) = 11;
L250: (C67 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or C67 in D2 or C67 in D3 or C67 in D4 or C67 in D5 or C67 in D6) by L15;
consider C68 being (Element of ( Segm 15 )), C69 , C70 being (Element of ( SCM-Data-Loc )), C71 , C72 being (Element of ( INT )) such that L251: C67 = [ C68 , ( {} ) , <* C69 , C70 , C71 , C72 *> ] and L252: C68 in { 9 , 10 , 11 , 12 , 13 } by L250 , L249 , L219;
L253: (C68 = 9 or C68 = 10 or C68 = 11 or C68 = 12 or C68 = 13) by L252 , ENUMSET1:def 3;
consider R4 being (Element of ( SCM-Data-Loc )), R5 being (Element of ( SCM-Data-Loc )), R9 being Integer, R10 being Integer such that L254: C67 = [ 11 , ( {} ) , <* R4 , R5 , R9 , R10 *> ] by L253 , L249 , L251 , RECDEF_2:def 1;
reconsider D42 = R4 , D43 = R5 as Int_position by AMI_2:def 16;
take D42;
take D43;
take R9;
take R10;
thus L255: thesis by L254;
end;
theorem
L256: (for B55 being (Instruction of ( SCMPDS )) holds (( InsCode B55 ) = 12 implies (ex R16 being Int_position st (ex R17 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B55 = ( Divide (R16 , R9 , R17 , R10) )))))))
proof
let C73 being (Instruction of ( SCMPDS ));
assume that
L257: ( InsCode C73 ) = 12;
L258: (C73 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or C73 in D2 or C73 in D3 or C73 in D4 or C73 in D5 or C73 in D6) by L15;
consider C74 being (Element of ( Segm 15 )), C75 , C76 being (Element of ( SCM-Data-Loc )), C77 , C78 being (Element of ( INT )) such that L259: C73 = [ C74 , ( {} ) , <* C75 , C76 , C77 , C78 *> ] and L260: C74 in { 9 , 10 , 11 , 12 , 13 } by L258 , L257 , L219;
L261: (C74 = 9 or C74 = 10 or C74 = 11 or C74 = 12 or C74 = 13) by L260 , ENUMSET1:def 3;
consider R4 being (Element of ( SCM-Data-Loc )), R5 being (Element of ( SCM-Data-Loc )), R9 being Integer, R10 being Integer such that L262: C73 = [ 12 , ( {} ) , <* R4 , R5 , R9 , R10 *> ] by L261 , L257 , L259 , RECDEF_2:def 1;
reconsider D44 = R4 , D45 = R5 as Int_position by AMI_2:def 16;
take D44;
take D45;
take R9;
take R10;
thus L263: thesis by L262;
end;
theorem
L264: (for B56 being (Instruction of ( SCMPDS )) holds (( InsCode B56 ) = 13 implies (ex R16 being Int_position st (ex R17 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B56 = ( (R16 , R9) := (R17 , R10) )))))))
proof
let C79 being (Instruction of ( SCMPDS ));
assume that
L265: ( InsCode C79 ) = 13;
L266: (C79 in { [ ( 0 ) , ( {} ) , ( {} ) ] } or C79 in D2 or C79 in D3 or C79 in D4 or C79 in D5 or C79 in D6) by L15;
consider C80 being (Element of ( Segm 15 )), C81 , C82 being (Element of ( SCM-Data-Loc )), C83 , C84 being (Element of ( INT )) such that L267: C79 = [ C80 , ( {} ) , <* C81 , C82 , C83 , C84 *> ] and L268: C80 in { 9 , 10 , 11 , 12 , 13 } by L266 , L265 , L219;
L269: (C80 = 9 or C80 = 10 or C80 = 11 or C80 = 12 or C80 = 13) by L268 , ENUMSET1:def 3;
consider R4 being (Element of ( SCM-Data-Loc )), R5 being (Element of ( SCM-Data-Loc )), R9 being Integer, R10 being Integer such that L270: C79 = [ 13 , ( {} ) , <* R4 , R5 , R9 , R10 *> ] by L269 , L265 , L267 , RECDEF_2:def 1;
reconsider D46 = R4 , D47 = R5 as Int_position by AMI_2:def 16;
take D46;
take D47;
take R9;
take R10;
thus L271: thesis by L270;
end;
theorem
L272: (for B57 being (State of ( SCMPDS )) holds (for B58 being Int_position holds B58 in ( dom B57 )))
proof
let C85 being (State of ( SCMPDS ));
let C86 being Int_position;
L273: ( dom C85 ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2;
thus L274: thesis by L273;
end;
theorem
L275: (for B59 being (State of ( SCMPDS )) holds ( SCM-Data-Loc ) c= ( dom B59 ))
proof
let C87 being (State of ( SCMPDS ));
L276: ( dom C87 ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2;
thus L277: thesis by L276;
end;
L278: ( Data-Locations ( SCMPDS ) ) = ( SCM-Data-Loc )
proof
L279: ( SCM-Data-Loc ) misses { ( NAT ) } by AMI_2:20 , ZFMISC_1:50;
L280: ( SCM-Data-Loc ) misses { ( NAT ) } by L279;
thus L281: ( Data-Locations ( SCMPDS ) ) = ( ( { ( NAT ) } \/ ( SCM-Data-Loc ) ) \ { ( NAT ) } ) by AMI_2:22 , FUNCT_7:def 1
.= ( ( ( SCM-Data-Loc ) \/ { ( NAT ) } ) \ { ( NAT ) } )
.= ( ( SCM-Data-Loc ) \ { ( NAT ) } ) by XBOOLE_1:40
.= ( SCM-Data-Loc ) by L280 , XBOOLE_1:83;
end;
theorem
L282: (for B60 being (State of ( SCMPDS )) holds ( dom ( DataPart B60 ) ) = ( SCM-Data-Loc ))
proof
let C88 being (State of ( SCMPDS ));
L283: ( SCM-Data-Loc ) c= ( dom C88 ) by L275;
thus L284: thesis by L283 , L278 , RELAT_1:62;
end;
theorem
L285: (for B61 being Int_position holds B61 <> ( IC ( SCMPDS ) ))
proof
let C89 being Int_position;
L286: ( Values C89 ) = ( INT ) by L12;
thus L287: thesis by L286 , MEMSTR_0:def 6 , NUMBERS:27;
end;
theorem
L288: (for B62 , B63 being (State of ( SCMPDS )) holds ((( IC B62 ) = ( IC B63 ) & (for B64 being Int_position holds ( B62 . B64 ) = ( B63 . B64 ))) implies B62 = B63))
proof
let C90 , C91 being (State of ( SCMPDS ));
assume that
L289: ( IC C90 ) = ( IC C91 )
and
L290: (for B65 being Int_position holds ( C90 . B65 ) = ( C91 . B65 ));
L291: ( dom C90 ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2;
L292: ( dom C91 ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2;
L293:
now
let C92 being set;
assume L294: C92 in ( SCM-Memory );
L295: C92 in ( { ( IC ( SCMPDS ) ) } \/ ( SCM-Data-Loc ) ) by L294 , L8;
per cases  by L295 , XBOOLE_0:def 3;
suppose L296: C92 in { ( IC ( SCMPDS ) ) };

L297: C92 = ( IC ( SCMPDS ) ) by L296 , TARSKI:def 1;
thus L298: ( C90 . C92 ) = ( C91 . C92 ) by L297 , L289;
end;
suppose L299: C92 in ( SCM-Data-Loc );

L300: C92 is Int_position by L299 , AMI_2:def 16;
thus L301: ( C90 . C92 ) = ( C91 . C92 ) by L300 , L290;
end;
end;
L303: ( SCM-Memory ) = ( dom C90 ) by L291;
thus L304: thesis by L303 , L292 , L293 , FUNCT_1:2;
end;
begin
theorem
L305: (for R3 being (State of ( SCMPDS )) holds (for R9 being Integer holds (for R16 being Int_position holds (( ( Exec (( R16 := R9 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) & ( ( Exec (( R16 := R9 ) , R3) ) . R16 ) = R9 & (for R17 being Int_position holds (R17 <> R16 implies ( ( Exec (( R16 := R9 ) , R3) ) . R17 ) = ( R3 . R17 )))))))
proof
let R3 being (State of ( SCMPDS ));
let R9 being Integer;
let R16 being Int_position;
reconsider D48 = R3 as SCM-State by CARD_3:107;
reconsider D49 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D50 = ( R16 := R9 ) as (Element of ( SCMPDS-Instr ));
set D51 = ( SCM-Chg (D48 , ( D50 P21address ) , ( D50 P22const )) );
reconsider D52 = 2 as (Element of ( Segm 15 )) by NAT_1:44;
L306: D50 = [ D52 , ( {} ) , <* D49 , R9 *> ];
L307: ( D50 P21address ) = D49 by L306 , SCMPDS_I:5;
L308: ( D50 P22const ) = R9 by L306 , SCMPDS_I:5;
L309: ( InsCode D50 ) = 2 by RECDEF_2:def 1;
L310: ( Exec (( R16 := R9 ) , R3) ) = ( SCM-Exec-Res (D50 , D48) ) by SCMPDS_1:def 23
.= ( SCM-Chg (D51 , ( succ ( IC D48 ) )) ) by L309 , SCMPDS_1:def 22;
thus L311: ( ( Exec (( R16 := R9 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) by L310 , L8 , AMI_2:11;
thus L312: ( ( Exec (( R16 := R9 ) , R3) ) . R16 ) = ( D51 . D49 ) by L310 , AMI_2:12
.= R9 by L307 , L308 , AMI_2:15;
let R17 being Int_position;
reconsider D53 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
assume L313: R17 <> R16;
thus L314: ( ( Exec (( R16 := R9 ) , R3) ) . R17 ) = ( D51 . D53 ) by L310 , AMI_2:12
.= ( R3 . R17 ) by L307 , L313 , AMI_2:16;
end;
theorem
L315: (for R3 being (State of ( SCMPDS )) holds (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (( ( Exec (( (R16 , R9) := R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) & ( ( Exec (( (R16 , R9) := R10 ) , R3) ) . ( DataLoc (( R3 . R16 ) , R9) ) ) = R10 & (for R17 being Int_position holds (R17 <> ( DataLoc (( R3 . R16 ) , R9) ) implies ( ( Exec (( (R16 , R9) := R10 ) , R3) ) . R17 ) = ( R3 . R17 ))))))))
proof
let R3 being (State of ( SCMPDS ));
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
reconsider D54 = R3 as SCM-State by CARD_3:107;
reconsider D55 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D56 = ( (R16 , R9) := R10 ) as (Element of ( SCMPDS-Instr ));
set D57 = ( Address_Add (D54 , ( D56 P31address ) , ( D56 P32const )) );
set D58 = ( SCM-Chg (D54 , D57 , ( D56 P33const )) );
reconsider D59 = 7 as (Element of ( Segm 15 )) by NAT_1:44;
L316: D56 = [ D59 , ( {} ) , <* D55 , R9 , R10 *> ];
L317: ( D56 P33const ) = R10 by L316 , SCMPDS_I:6;
L318: ( InsCode D56 ) = 7 by RECDEF_2:def 1;
L319: ( Exec (( (R16 , R9) := R10 ) , R3) ) = ( SCM-Exec-Res (D56 , D54) ) by SCMPDS_1:def 23
.= ( SCM-Chg (D58 , ( succ ( IC D54 ) )) ) by L318 , SCMPDS_1:def 22;
thus L320: ( ( Exec (( (R16 , R9) := R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) by L319 , L8 , AMI_2:11;
L321: (( D56 P31address ) = D55 & ( D56 P32const ) = R9) by L316 , SCMPDS_I:6;
thus L322: ( ( Exec (( (R16 , R9) := R10 ) , R3) ) . ( DataLoc (( R3 . R16 ) , R9) ) ) = ( D58 . D57 ) by L321 , L319 , AMI_2:12
.= R10 by L317 , AMI_2:15;
let R17 being Int_position;
reconsider D60 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
assume L323: R17 <> ( DataLoc (( R3 . R16 ) , R9) );
thus L324: ( ( Exec (( (R16 , R9) := R10 ) , R3) ) . R17 ) = ( D58 . D60 ) by L319 , AMI_2:12
.= ( R3 . R17 ) by L321 , L323 , AMI_2:16;
end;
theorem
L325: (for R3 being (State of ( SCMPDS )) holds (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds (( ( Exec (( (R16 , R9) := (R17 , R10) ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) & ( ( Exec (( (R16 , R9) := (R17 , R10) ) , R3) ) . ( DataLoc (( R3 . R16 ) , R9) ) ) = ( R3 . ( DataLoc (( R3 . R17 ) , R10) ) ) & (for R18 being Int_position holds (R18 <> ( DataLoc (( R3 . R16 ) , R9) ) implies ( ( Exec (( (R16 , R9) := (R17 , R10) ) , R3) ) . R18 ) = ( R3 . R18 )))))))))
proof
let R3 being (State of ( SCMPDS ));
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
let R17 being Int_position;
reconsider D61 = R3 as SCM-State by CARD_3:107;
reconsider D62 = R16 , D63 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D64 = ( (R16 , R9) := (R17 , R10) ) as (Element of ( SCMPDS-Instr ));
set D65 = ( Address_Add (D61 , ( D64 P41address ) , ( D64 P43const )) );
set D66 = ( Address_Add (D61 , ( D64 P42address ) , ( D64 P44const )) );
set D67 = ( SCM-Chg (D61 , D65 , ( D61 . D66 )) );
reconsider D68 = 13 as (Element of ( Segm 15 )) by NAT_1:44;
L326: D64 = [ D68 , ( {} ) , <* D62 , D63 , R9 , R10 *> ];
L327: (( D64 P42address ) = D63 & ( D64 P44const ) = R10) by L326 , SCMPDS_I:7;
L328: ( InsCode D64 ) = 13 by RECDEF_2:def 1;
L329: ( Exec (( (R16 , R9) := (R17 , R10) ) , R3) ) = ( SCM-Exec-Res (D64 , D61) ) by SCMPDS_1:def 23
.= ( SCM-Chg (D67 , ( succ ( IC D61 ) )) ) by L328 , SCMPDS_1:def 22;
thus L330: ( ( Exec (( (R16 , R9) := (R17 , R10) ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) by L329 , L8 , AMI_2:11;
L331: (( D64 P41address ) = D62 & ( D64 P43const ) = R9) by L326 , SCMPDS_I:7;
thus L332: ( ( Exec (( (R16 , R9) := (R17 , R10) ) , R3) ) . ( DataLoc (( R3 . R16 ) , R9) ) ) = ( D67 . D65 ) by L331 , L329 , AMI_2:12
.= ( R3 . ( DataLoc (( R3 . R17 ) , R10) ) ) by L327 , AMI_2:15;
let R18 being Int_position;
reconsider D69 = R18 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
assume L333: R18 <> ( DataLoc (( R3 . R16 ) , R9) );
thus L334: ( ( Exec (( (R16 , R9) := (R17 , R10) ) , R3) ) . R18 ) = ( D67 . D69 ) by L329 , AMI_2:12
.= ( R3 . R18 ) by L331 , L333 , AMI_2:16;
end;
theorem
L335: (for R3 being (State of ( SCMPDS )) holds (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (( ( Exec (( AddTo (R16 , R9 , R10) ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) & ( ( Exec (( AddTo (R16 , R9 , R10) ) , R3) ) . ( DataLoc (( R3 . R16 ) , R9) ) ) = ( ( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) + R10 ) & (for R17 being Int_position holds (R17 <> ( DataLoc (( R3 . R16 ) , R9) ) implies ( ( Exec (( AddTo (R16 , R9 , R10) ) , R3) ) . R17 ) = ( R3 . R17 ))))))))
proof
let R3 being (State of ( SCMPDS ));
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
reconsider D70 = R3 as SCM-State by CARD_3:107;
reconsider D71 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D72 = ( AddTo (R16 , R9 , R10) ) as (Element of ( SCMPDS-Instr ));
set D73 = ( Address_Add (D70 , ( D72 P31address ) , ( D72 P32const )) );
set D74 = ( SCM-Chg (D70 , D73 , ( ( D70 . D73 ) + ( D72 P33const ) )) );
reconsider D75 = 8 as (Element of ( Segm 15 )) by NAT_1:44;
L336: D72 = [ D75 , ( {} ) , <* D71 , R9 , R10 *> ];
L337: ( D72 P33const ) = R10 by L336 , SCMPDS_I:6;
L338: ( InsCode D72 ) = 8 by RECDEF_2:def 1;
L339: ( Exec (( AddTo (R16 , R9 , R10) ) , R3) ) = ( SCM-Exec-Res (D72 , D70) ) by SCMPDS_1:def 23
.= ( SCM-Chg (D74 , ( succ ( IC D70 ) )) ) by L338 , SCMPDS_1:def 22;
thus L340: ( ( Exec (( AddTo (R16 , R9 , R10) ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) by L339 , L8 , AMI_2:11;
L341: (( D72 P31address ) = D71 & ( D72 P32const ) = R9) by L336 , SCMPDS_I:6;
thus L342: ( ( Exec (( AddTo (R16 , R9 , R10) ) , R3) ) . ( DataLoc (( R3 . R16 ) , R9) ) ) = ( D74 . D73 ) by L341 , L339 , AMI_2:12
.= ( ( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) + R10 ) by L341 , L337 , AMI_2:15;
let R18 being Int_position;
reconsider D76 = R18 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
assume L343: R18 <> ( DataLoc (( R3 . R16 ) , R9) );
thus L344: ( ( Exec (( AddTo (R16 , R9 , R10) ) , R3) ) . R18 ) = ( D74 . D76 ) by L339 , AMI_2:12
.= ( R3 . R18 ) by L341 , L343 , AMI_2:16;
end;
theorem
L345: (for R3 being (State of ( SCMPDS )) holds (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds (( ( Exec (( AddTo (R16 , R9 , R17 , R10) ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) & ( ( Exec (( AddTo (R16 , R9 , R17 , R10) ) , R3) ) . ( DataLoc (( R3 . R16 ) , R9) ) ) = ( ( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) + ( R3 . ( DataLoc (( R3 . R17 ) , R10) ) ) ) & (for R18 being Int_position holds (R18 <> ( DataLoc (( R3 . R16 ) , R9) ) implies ( ( Exec (( AddTo (R16 , R9 , R17 , R10) ) , R3) ) . R18 ) = ( R3 . R18 )))))))))
proof
let R3 being (State of ( SCMPDS ));
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
let R17 being Int_position;
reconsider D77 = R3 as SCM-State by CARD_3:107;
reconsider D78 = R16 , D79 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D80 = ( AddTo (R16 , R9 , R17 , R10) ) as (Element of ( SCMPDS-Instr ));
set D81 = ( Address_Add (D77 , ( D80 P41address ) , ( D80 P43const )) );
set D82 = ( Address_Add (D77 , ( D80 P42address ) , ( D80 P44const )) );
set D83 = ( SCM-Chg (D77 , D81 , ( ( D77 . D81 ) + ( D77 . D82 ) )) );
reconsider D84 = 9 as (Element of ( Segm 15 )) by NAT_1:44;
L346: D80 = [ D84 , ( {} ) , <* D78 , D79 , R9 , R10 *> ];
L347: (( D80 P42address ) = D79 & ( D80 P44const ) = R10) by L346 , SCMPDS_I:7;
L348: ( InsCode D80 ) = 9 by RECDEF_2:def 1;
L349: ( Exec (( AddTo (R16 , R9 , R17 , R10) ) , R3) ) = ( SCM-Exec-Res (D80 , D77) ) by SCMPDS_1:def 23
.= ( SCM-Chg (D83 , ( succ ( IC D77 ) )) ) by L348 , SCMPDS_1:def 22;
thus L350: ( ( Exec (( AddTo (R16 , R9 , R17 , R10) ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) by L349 , L8 , AMI_2:11;
L351: (( D80 P41address ) = D78 & ( D80 P43const ) = R9) by L346 , SCMPDS_I:7;
thus L352: ( ( Exec (( AddTo (R16 , R9 , R17 , R10) ) , R3) ) . ( DataLoc (( R3 . R16 ) , R9) ) ) = ( D83 . D81 ) by L351 , L349 , AMI_2:12
.= ( ( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) + ( R3 . ( DataLoc (( R3 . R17 ) , R10) ) ) ) by L351 , L347 , AMI_2:15;
let R18 being Int_position;
reconsider D85 = R18 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
assume L353: R18 <> ( DataLoc (( R3 . R16 ) , R9) );
thus L354: ( ( Exec (( AddTo (R16 , R9 , R17 , R10) ) , R3) ) . R18 ) = ( D83 . D85 ) by L349 , AMI_2:12
.= ( R3 . R18 ) by L351 , L353 , AMI_2:16;
end;
theorem
L355: (for R3 being (State of ( SCMPDS )) holds (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds (( ( Exec (( SubFrom (R16 , R9 , R17 , R10) ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) & ( ( Exec (( SubFrom (R16 , R9 , R17 , R10) ) , R3) ) . ( DataLoc (( R3 . R16 ) , R9) ) ) = ( ( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) - ( R3 . ( DataLoc (( R3 . R17 ) , R10) ) ) ) & (for R18 being Int_position holds (R18 <> ( DataLoc (( R3 . R16 ) , R9) ) implies ( ( Exec (( SubFrom (R16 , R9 , R17 , R10) ) , R3) ) . R18 ) = ( R3 . R18 )))))))))
proof
let R3 being (State of ( SCMPDS ));
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
let R17 being Int_position;
reconsider D86 = R3 as SCM-State by CARD_3:107;
reconsider D87 = R16 , D88 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D89 = ( SubFrom (R16 , R9 , R17 , R10) ) as (Element of ( SCMPDS-Instr ));
set D90 = ( Address_Add (D86 , ( D89 P41address ) , ( D89 P43const )) );
set D91 = ( Address_Add (D86 , ( D89 P42address ) , ( D89 P44const )) );
set D92 = ( SCM-Chg (D86 , D90 , ( ( D86 . D90 ) - ( D86 . D91 ) )) );
reconsider D93 = 10 as (Element of ( Segm 15 )) by NAT_1:44;
L356: D89 = [ D93 , ( {} ) , <* D87 , D88 , R9 , R10 *> ];
L357: (( D89 P42address ) = D88 & ( D89 P44const ) = R10) by L356 , SCMPDS_I:7;
L358: ( InsCode D89 ) = 10 by RECDEF_2:def 1;
L359: ( Exec (( SubFrom (R16 , R9 , R17 , R10) ) , R3) ) = ( SCM-Exec-Res (D89 , D86) ) by SCMPDS_1:def 23
.= ( SCM-Chg (D92 , ( succ ( IC D86 ) )) ) by L358 , SCMPDS_1:def 22;
thus L360: ( ( Exec (( SubFrom (R16 , R9 , R17 , R10) ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) by L359 , L8 , AMI_2:11;
L361: (( D89 P41address ) = D87 & ( D89 P43const ) = R9) by L356 , SCMPDS_I:7;
thus L362: ( ( Exec (( SubFrom (R16 , R9 , R17 , R10) ) , R3) ) . ( DataLoc (( R3 . R16 ) , R9) ) ) = ( D92 . D90 ) by L361 , L359 , AMI_2:12
.= ( ( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) - ( R3 . ( DataLoc (( R3 . R17 ) , R10) ) ) ) by L361 , L357 , AMI_2:15;
let R18 being Int_position;
reconsider D94 = R18 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
assume L363: R18 <> ( DataLoc (( R3 . R16 ) , R9) );
thus L364: ( ( Exec (( SubFrom (R16 , R9 , R17 , R10) ) , R3) ) . R18 ) = ( D92 . D94 ) by L359 , AMI_2:12
.= ( R3 . R18 ) by L361 , L363 , AMI_2:16;
end;
theorem
L365: (for R3 being (State of ( SCMPDS )) holds (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds (( ( Exec (( MultBy (R16 , R9 , R17 , R10) ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) & ( ( Exec (( MultBy (R16 , R9 , R17 , R10) ) , R3) ) . ( DataLoc (( R3 . R16 ) , R9) ) ) = ( ( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) * ( R3 . ( DataLoc (( R3 . R17 ) , R10) ) ) ) & (for R18 being Int_position holds (R18 <> ( DataLoc (( R3 . R16 ) , R9) ) implies ( ( Exec (( MultBy (R16 , R9 , R17 , R10) ) , R3) ) . R18 ) = ( R3 . R18 )))))))))
proof
let R3 being (State of ( SCMPDS ));
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
let R17 being Int_position;
reconsider D95 = R3 as SCM-State by CARD_3:107;
reconsider D96 = R16 , D97 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D98 = ( MultBy (R16 , R9 , R17 , R10) ) as (Element of ( SCMPDS-Instr ));
set D99 = ( Address_Add (D95 , ( D98 P41address ) , ( D98 P43const )) );
set D100 = ( Address_Add (D95 , ( D98 P42address ) , ( D98 P44const )) );
set D101 = ( SCM-Chg (D95 , D99 , ( ( D95 . D99 ) * ( D95 . D100 ) )) );
reconsider D102 = 11 as (Element of ( Segm 15 )) by NAT_1:44;
L366: D98 = [ D102 , ( {} ) , <* D96 , D97 , R9 , R10 *> ];
L367: (( D98 P42address ) = D97 & ( D98 P44const ) = R10) by L366 , SCMPDS_I:7;
L368: ( InsCode D98 ) = 11 by RECDEF_2:def 1;
L369: ( Exec (( MultBy (R16 , R9 , R17 , R10) ) , R3) ) = ( SCM-Exec-Res (D98 , D95) ) by SCMPDS_1:def 23
.= ( SCM-Chg (D101 , ( succ ( IC D95 ) )) ) by L368 , SCMPDS_1:def 22;
thus L370: ( ( Exec (( MultBy (R16 , R9 , R17 , R10) ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) by L369 , L8 , AMI_2:11;
L371: (( D98 P41address ) = D96 & ( D98 P43const ) = R9) by L366 , SCMPDS_I:7;
thus L372: ( ( Exec (( MultBy (R16 , R9 , R17 , R10) ) , R3) ) . ( DataLoc (( R3 . R16 ) , R9) ) ) = ( D101 . D99 ) by L371 , L369 , AMI_2:12
.= ( ( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) * ( R3 . ( DataLoc (( R3 . R17 ) , R10) ) ) ) by L371 , L367 , AMI_2:15;
let R18 being Int_position;
reconsider D103 = R18 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
assume L373: R18 <> ( DataLoc (( R3 . R16 ) , R9) );
thus L374: ( ( Exec (( MultBy (R16 , R9 , R17 , R10) ) , R3) ) . R18 ) = ( D101 . D103 ) by L369 , AMI_2:12
.= ( R3 . R18 ) by L371 , L373 , AMI_2:16;
end;
theorem
L375: (for R3 being (State of ( SCMPDS )) holds (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds (( ( Exec (( Divide (R16 , R9 , R17 , R10) ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) & (( DataLoc (( R3 . R16 ) , R9) ) <> ( DataLoc (( R3 . R17 ) , R10) ) implies ( ( Exec (( Divide (R16 , R9 , R17 , R10) ) , R3) ) . ( DataLoc (( R3 . R16 ) , R9) ) ) = ( ( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) div ( R3 . ( DataLoc (( R3 . R17 ) , R10) ) ) )) & ( ( Exec (( Divide (R16 , R9 , R17 , R10) ) , R3) ) . ( DataLoc (( R3 . R17 ) , R10) ) ) = ( ( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) mod ( R3 . ( DataLoc (( R3 . R17 ) , R10) ) ) ) & (for R18 being Int_position holds ((R18 <> ( DataLoc (( R3 . R16 ) , R9) ) & R18 <> ( DataLoc (( R3 . R17 ) , R10) )) implies ( ( Exec (( Divide (R16 , R9 , R17 , R10) ) , R3) ) . R18 ) = ( R3 . R18 )))))))))
proof
let R3 being (State of ( SCMPDS ));
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
let R17 being Int_position;
reconsider D104 = R3 as SCM-State by CARD_3:107;
reconsider D105 = R16 , D106 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D107 = ( Divide (R16 , R9 , R17 , R10) ) as (Element of ( SCMPDS-Instr ));
set D108 = ( Address_Add (D104 , ( D107 P41address ) , ( D107 P43const )) );
set D109 = ( Address_Add (D104 , ( D107 P42address ) , ( D107 P44const )) );
set D110 = ( SCM-Chg (D104 , D108 , ( ( D104 . D108 ) div ( D104 . D109 ) )) );
set D111 = ( SCM-Chg (D110 , D109 , ( ( D104 . D108 ) mod ( D104 . D109 ) )) );
reconsider D112 = 12 as (Element of ( Segm 15 )) by NAT_1:44;
set D113 = ( DataLoc (( R3 . R16 ) , R9) );
set D114 = ( DataLoc (( R3 . R17 ) , R10) );
L376: D107 = [ D112 , ( {} ) , <* D105 , D106 , R9 , R10 *> ];
L377: (( D107 P41address ) = D105 & ( D107 P43const ) = R9) by L376 , SCMPDS_I:7;
L378: ( InsCode D107 ) = 12 by RECDEF_2:def 1;
L379: ( Exec (( Divide (R16 , R9 , R17 , R10) ) , R3) ) = ( SCM-Exec-Res (D107 , D104) ) by SCMPDS_1:def 23
.= ( SCM-Chg (D111 , ( succ ( IC D104 ) )) ) by L378 , SCMPDS_1:def 22;
thus L380: ( ( Exec (( Divide (R16 , R9 , R17 , R10) ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) by L379 , L8 , AMI_2:11;
L381: (( D107 P42address ) = D106 & ( D107 P44const ) = R10) by L376 , SCMPDS_I:7;
thus L382:now
reconsider D115 = D113 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
assume L383: D113 <> ( DataLoc (( R3 . R17 ) , R10) );
thus L384: ( ( Exec (( Divide (R16 , R9 , R17 , R10) ) , R3) ) . D113 ) = ( D111 . D115 ) by L379 , AMI_2:12
.= ( D110 . D108 ) by L377 , L381 , L383 , AMI_2:16
.= ( ( R3 . D113 ) div ( R3 . D114 ) ) by L377 , L381 , AMI_2:15;
end;
thus L385: ( ( Exec (( Divide (R16 , R9 , R17 , R10) ) , R3) ) . ( DataLoc (( R3 . R17 ) , R10) ) ) = ( D111 . D109 ) by L379 , L381 , AMI_2:12
.= ( ( R3 . D113 ) mod ( R3 . D114 ) ) by L377 , L381 , AMI_2:15;
let R18 being Int_position;
reconsider D116 = R18 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
assume that
L386: R18 <> D113
and
L387: R18 <> D114;
thus L388: ( ( Exec (( Divide (R16 , R9 , R17 , R10) ) , R3) ) . R18 ) = ( D111 . D116 ) by L379 , AMI_2:12
.= ( D110 . D116 ) by L381 , L387 , AMI_2:16
.= ( R3 . R18 ) by L377 , L386 , AMI_2:16;
end;
theorem
L389: (for R3 being (State of ( SCMPDS )) holds (for R9 being Integer holds (for R16 being Int_position holds (( ( Exec (( Divide (R16 , R9 , R16 , R9) ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) & ( ( Exec (( Divide (R16 , R9 , R16 , R9) ) , R3) ) . ( DataLoc (( R3 . R16 ) , R9) ) ) = ( ( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) mod ( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) ) & (for R18 being Int_position holds (R18 <> ( DataLoc (( R3 . R16 ) , R9) ) implies ( ( Exec (( Divide (R16 , R9 , R16 , R9) ) , R3) ) . R18 ) = ( R3 . R18 ))))))) by L375;
definition
let C93 being (State of ( SCMPDS ));
let C94 being Integer;
func ICplusConst (C93 , C94) -> (Element of ( NAT )) means 
:L390: (ex B66 being (Element of ( NAT )) st (B66 = ( IC C93 ) & it = ( abs ( B66 + C94 ) )));
existence
proof
reconsider D117 = ( IC C93 ) as (Element of ( NAT ));
consider C95 being (Element of ( NAT )) such that L391: D117 = C95;
reconsider D118 = ( abs ( C95 + C94 ) ) as Nat;
reconsider D119 = D118 as (Element of ( NAT ));
take D119;
thus L392: thesis by L391;
end;
correctness;
end;
theorem
L394: (for R3 being (State of ( SCMPDS )) holds (for R9 being Integer holds (( ( Exec (( goto R9 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( ICplusConst (R3 , R9) ) & (for R16 being Int_position holds ( ( Exec (( goto R9 ) , R3) ) . R16 ) = ( R3 . R16 )))))
proof
let R3 being (State of ( SCMPDS ));
let R9 being Integer;
reconsider D120 = 14 as (Element of ( Segm 15 )) by NAT_1:44;
reconsider D121 = ( goto R9 ) as (Element of ( SCMPDS-Instr ));
reconsider D122 = R3 as SCM-State by CARD_3:107;
L395: D121 = [ D120 , ( {} ) , <* R9 *> ];
L396: ( D121 const_INT ) = R9 by L395 , SCMPDS_I:4;
L397: ( InsCode D121 ) = 14 by RECDEF_2:def 1;
L398: ( Exec (( goto R9 ) , R3) ) = ( SCM-Exec-Res (D121 , D122) ) by SCMPDS_1:def 23
.= ( SCM-Chg (D122 , ( jump_address (D122 , ( D121 const_INT )) )) ) by L397 , SCMPDS_1:def 22;
L399: (ex B67 being (Element of ( NAT )) st (B67 = ( IC R3 ) & ( ICplusConst (R3 , R9) ) = ( abs ( B67 + R9 ) ))) by L390;
thus L400: ( ( Exec (( goto R9 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( ICplusConst (R3 , R9) ) by L399 , L398 , L396 , L8 , AMI_2:11;
let R16 being Int_position;
reconsider D123 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
thus L401: ( ( Exec (( goto R9 ) , R3) ) . R16 ) = ( D122 . D123 ) by L398 , AMI_2:12
.= ( R3 . R16 );
end;
theorem
L402: (for R3 being (State of ( SCMPDS )) holds (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds ((( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) <> ( 0 ) implies ( ( Exec (( (R16 , R9) <>0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( ICplusConst (R3 , R10) )) & (( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) = ( 0 ) implies ( ( Exec (( (R16 , R9) <>0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) )) & ( ( Exec (( (R16 , R9) <>0_goto R10 ) , R3) ) . R17 ) = ( R3 . R17 )))))))
proof
let R3 being (State of ( SCMPDS ));
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
let R17 being Int_position;
reconsider D124 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D125 = R3 as SCM-State by CARD_3:107;
L403: (ex B68 being (Element of ( NAT )) st (B68 = ( IC R3 ) & ( ICplusConst (R3 , R10) ) = ( abs ( B68 + R10 ) ))) by L390;
reconsider D126 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D127 = ( (R16 , R9) <>0_goto R10 ) as (Element of ( SCMPDS-Instr ));
set D128 = ( Address_Add (D125 , ( D127 P31address ) , ( D127 P32const )) );
set D129 = ( jump_address (D125 , ( D127 P33const )) );
set D130 = ( IFEQ (( D125 . D128 ) , ( 0 ) , ( succ ( IC D125 ) ) , D129) );
set D131 = ( DataLoc (( R3 . R16 ) , R9) );
reconsider D132 = 4 as (Element of ( Segm 15 )) by NAT_1:44;
L404: D127 = [ D132 , ( {} ) , <* D126 , R9 , R10 *> ];
L405: (( D127 P31address ) = D126 & ( D127 P32const ) = R9) by L404 , SCMPDS_I:6;
L406: ( InsCode D127 ) = 4 by RECDEF_2:def 1;
L407: ( Exec (( (R16 , R9) <>0_goto R10 ) , R3) ) = ( SCM-Exec-Res (D127 , D125) ) by SCMPDS_1:def 23
.= ( SCM-Chg (D125 , D130) ) by L406 , SCMPDS_1:def 22;
L408: ( D127 P33const ) = R10 by L404 , SCMPDS_I:6;
thus L409: (( R3 . D131 ) <> ( 0 ) implies ( ( Exec (( (R16 , R9) <>0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( ICplusConst (R3 , R10) ))
proof
assume L410: ( R3 . D131 ) <> ( 0 );
thus L411: ( ( Exec (( (R16 , R9) <>0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = D130 by L407 , L8 , AMI_2:11
.= ( ICplusConst (R3 , R10) ) by L405 , L408 , L403 , L410 , L8 , FUNCOP_1:def 8;
end;

thus L412: (( R3 . D131 ) = ( 0 ) implies ( ( Exec (( (R16 , R9) <>0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ))
proof
assume L413: ( R3 . D131 ) = ( 0 );
thus L414: ( ( Exec (( (R16 , R9) <>0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = D130 by L407 , L8 , AMI_2:11
.= ( succ ( IC D125 ) ) by L405 , L413 , FUNCOP_1:def 8
.= ( succ ( IC R3 ) ) by AMI_2:22 , FUNCT_7:def 1;
end;

thus L415: ( ( Exec (( (R16 , R9) <>0_goto R10 ) , R3) ) . R17 ) = ( D125 . D124 ) by L407 , AMI_2:12
.= ( R3 . R17 );
end;
theorem
L416: (for R3 being (State of ( SCMPDS )) holds (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds ((( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) <= ( 0 ) implies ( ( Exec (( (R16 , R9) <=0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( ICplusConst (R3 , R10) )) & (( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) > ( 0 ) implies ( ( Exec (( (R16 , R9) <=0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) )) & ( ( Exec (( (R16 , R9) <=0_goto R10 ) , R3) ) . R17 ) = ( R3 . R17 )))))))
proof
let R3 being (State of ( SCMPDS ));
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
let R17 being Int_position;
reconsider D133 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D134 = R3 as SCM-State by CARD_3:107;
L417: (ex B69 being (Element of ( NAT )) st (B69 = ( IC R3 ) & ( ICplusConst (R3 , R10) ) = ( abs ( B69 + R10 ) ))) by L390;
reconsider D135 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D136 = ( (R16 , R9) <=0_goto R10 ) as (Element of ( SCMPDS-Instr ));
set D137 = ( Address_Add (D134 , ( D136 P31address ) , ( D136 P32const )) );
set D138 = ( jump_address (D134 , ( D136 P33const )) );
set D139 = ( IFGT (( D134 . D137 ) , ( 0 ) , ( succ ( IC D134 ) ) , D138) );
set D140 = ( DataLoc (( R3 . R16 ) , R9) );
reconsider D141 = 5 as (Element of ( Segm 15 )) by NAT_1:44;
L418: D136 = [ D141 , ( {} ) , <* D135 , R9 , R10 *> ];
L419: (( D136 P31address ) = D135 & ( D136 P32const ) = R9) by L418 , SCMPDS_I:6;
L420: ( InsCode D136 ) = 5 by RECDEF_2:def 1;
L421: ( Exec (( (R16 , R9) <=0_goto R10 ) , R3) ) = ( SCM-Exec-Res (D136 , D134) ) by SCMPDS_1:def 23
.= ( SCM-Chg (D134 , D139) ) by L420 , SCMPDS_1:def 22;
L422: ( D136 P33const ) = R10 by L418 , SCMPDS_I:6;
thus L423: (( R3 . D140 ) <= ( 0 ) implies ( ( Exec (( (R16 , R9) <=0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( ICplusConst (R3 , R10) ))
proof
assume L424: ( R3 . D140 ) <= ( 0 );
thus L425: ( ( Exec (( (R16 , R9) <=0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = D139 by L421 , L8 , AMI_2:11
.= ( ICplusConst (R3 , R10) ) by L419 , L422 , L417 , L424 , L8 , XXREAL_0:def 11;
end;

thus L426: (( R3 . D140 ) > ( 0 ) implies ( ( Exec (( (R16 , R9) <=0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ))
proof
assume L427: ( R3 . D140 ) > ( 0 );
thus L428: ( ( Exec (( (R16 , R9) <=0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = D139 by L421 , L8 , AMI_2:11
.= ( succ ( IC D134 ) ) by L419 , L427 , XXREAL_0:def 11
.= ( succ ( IC R3 ) ) by AMI_2:22 , FUNCT_7:def 1;
end;

thus L429: ( ( Exec (( (R16 , R9) <=0_goto R10 ) , R3) ) . R17 ) = ( D134 . D133 ) by L421 , AMI_2:12
.= ( R3 . R17 );
end;
theorem
L430: (for R3 being (State of ( SCMPDS )) holds (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds ((( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) >= ( 0 ) implies ( ( Exec (( (R16 , R9) >=0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( ICplusConst (R3 , R10) )) & (( R3 . ( DataLoc (( R3 . R16 ) , R9) ) ) < ( 0 ) implies ( ( Exec (( (R16 , R9) >=0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) )) & ( ( Exec (( (R16 , R9) >=0_goto R10 ) , R3) ) . R17 ) = ( R3 . R17 )))))))
proof
let R3 being (State of ( SCMPDS ));
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
let R17 being Int_position;
reconsider D142 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D143 = R3 as SCM-State by CARD_3:107;
L431: (ex B70 being (Element of ( NAT )) st (B70 = ( IC R3 ) & ( ICplusConst (R3 , R10) ) = ( abs ( B70 + R10 ) ))) by L390;
reconsider D144 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D145 = ( (R16 , R9) >=0_goto R10 ) as (Element of ( SCMPDS-Instr ));
set D146 = ( Address_Add (D143 , ( D145 P31address ) , ( D145 P32const )) );
set D147 = ( jump_address (D143 , ( D145 P33const )) );
set D148 = ( IFGT (( 0 ) , ( D143 . D146 ) , ( succ ( IC D143 ) ) , D147) );
set D149 = ( DataLoc (( R3 . R16 ) , R9) );
reconsider D150 = 6 as (Element of ( Segm 15 )) by NAT_1:44;
L432: D145 = [ D150 , ( {} ) , <* D144 , R9 , R10 *> ];
L433: (( D145 P31address ) = D144 & ( D145 P32const ) = R9) by L432 , SCMPDS_I:6;
L434: ( InsCode D145 ) = 6 by RECDEF_2:def 1;
L435: ( Exec (( (R16 , R9) >=0_goto R10 ) , R3) ) = ( SCM-Exec-Res (D145 , D143) ) by SCMPDS_1:def 23
.= ( SCM-Chg (D143 , D148) ) by L434 , SCMPDS_1:def 22;
L436: ( D145 P33const ) = R10 by L432 , SCMPDS_I:6;
thus L437: (( R3 . D149 ) >= ( 0 ) implies ( ( Exec (( (R16 , R9) >=0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( ICplusConst (R3 , R10) ))
proof
assume L438: ( R3 . D149 ) >= ( 0 );
thus L439: ( ( Exec (( (R16 , R9) >=0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = D148 by L435 , L8 , AMI_2:11
.= ( ICplusConst (R3 , R10) ) by L433 , L436 , L431 , L438 , L8 , XXREAL_0:def 11;
end;

thus L440: (( R3 . D149 ) < ( 0 ) implies ( ( Exec (( (R16 , R9) >=0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ))
proof
assume L441: ( R3 . D149 ) < ( 0 );
thus L442: ( ( Exec (( (R16 , R9) >=0_goto R10 ) , R3) ) . ( IC ( SCMPDS ) ) ) = D148 by L435 , L8 , AMI_2:11
.= ( succ ( IC D143 ) ) by L433 , L441 , XXREAL_0:def 11
.= ( succ ( IC R3 ) ) by AMI_2:22 , FUNCT_7:def 1;
end;

thus L443: ( ( Exec (( (R16 , R9) >=0_goto R10 ) , R3) ) . R17 ) = ( D143 . D142 ) by L435 , AMI_2:12
.= ( R3 . R17 );
end;
theorem
L444: (for R3 being (State of ( SCMPDS )) holds (for R16 being Int_position holds (( ( Exec (( return R16 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( ( abs ( R3 . ( DataLoc (( R3 . R16 ) , ( RetIC )) ) ) ) + 2 ) & ( ( Exec (( return R16 ) , R3) ) . R16 ) = ( R3 . ( DataLoc (( R3 . R16 ) , ( RetSP )) ) ) & (for R17 being Int_position holds (R16 <> R17 implies ( ( Exec (( return R16 ) , R3) ) . R17 ) = ( R3 . R17 ))))))
proof
let R3 being (State of ( SCMPDS ));
let R16 being Int_position;
reconsider D151 = R3 as SCM-State by CARD_3:107;
reconsider D152 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D153 = ( return R16 ) as (Element of ( SCMPDS-Instr ));
set D154 = ( Address_Add (D151 , ( D153 address_1 ) , ( RetSP )) );
set D155 = ( SCM-Chg (D151 , ( D153 address_1 ) , ( D151 . D154 )) );
set D156 = ( Address_Add (D151 , ( D153 address_1 ) , ( RetIC )) );
set D157 = ( PopInstrLoc (D151 , D156) );
reconsider D158 = 1 as (Element of ( Segm 15 )) by NAT_1:44;
L445: D153 = [ D158 , ( {} ) , <* D152 *> ];
L446: ( D153 address_1 ) = D152 by L445 , SCMPDS_I:3;
L447: ( InsCode D153 ) = 1 by RECDEF_2:def 1;
L448: ( Exec (( return R16 ) , R3) ) = ( SCM-Exec-Res (D153 , D151) ) by SCMPDS_1:def 23
.= ( SCM-Chg (D155 , D157) ) by L447 , SCMPDS_1:def 22;
thus L449: ( ( Exec (( return R16 ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( ( abs ( R3 . ( DataLoc (( R3 . R16 ) , ( RetIC )) ) ) ) + 2 ) by L448 , L446 , L8 , AMI_2:11;
thus L450: ( ( Exec (( return R16 ) , R3) ) . R16 ) = ( D155 . D152 ) by L448 , AMI_2:12
.= ( R3 . ( DataLoc (( R3 . R16 ) , ( RetSP )) ) ) by L446 , AMI_2:15;
let R17 being Int_position;
reconsider D159 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
assume L451: R17 <> R16;
thus L452: ( ( Exec (( return R16 ) , R3) ) . R17 ) = ( D155 . D159 ) by L448 , AMI_2:12
.= ( R3 . R17 ) by L446 , L451 , AMI_2:16;
end;
theorem
L453: (for R3 being (State of ( SCMPDS )) holds (for R9 being Integer holds (for R16 being Int_position holds (( ( Exec (( saveIC (R16 , R9) ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) & ( ( Exec (( saveIC (R16 , R9) ) , R3) ) . ( DataLoc (( R3 . R16 ) , R9) ) ) = ( IC R3 ) & (for R17 being Int_position holds (( DataLoc (( R3 . R16 ) , R9) ) <> R17 implies ( ( Exec (( saveIC (R16 , R9) ) , R3) ) . R17 ) = ( R3 . R17 )))))))
proof
let R3 being (State of ( SCMPDS ));
let R9 being Integer;
let R16 being Int_position;
reconsider D160 = R3 as SCM-State by CARD_3:107;
reconsider D161 = ( IC D160 ) as (Element of ( NAT ));
reconsider D162 = R16 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
reconsider D163 = ( saveIC (R16 , R9) ) as (Element of ( SCMPDS-Instr ));
set D164 = ( Address_Add (D160 , ( D163 P21address ) , ( D163 P22const )) );
set D165 = ( SCM-Chg (D160 , D164 , D161) );
reconsider D166 = 3 as (Element of ( Segm 15 )) by NAT_1:44;
set D167 = ( DataLoc (( R3 . R16 ) , R9) );
L454: D163 = [ D166 , ( {} ) , <* D162 , R9 *> ];
L455: (( D163 P21address ) = D162 & ( D163 P22const ) = R9) by L454 , SCMPDS_I:5;
L456: ( InsCode D163 ) = 3 by RECDEF_2:def 1;
L457: ( Exec (( saveIC (R16 , R9) ) , R3) ) = ( SCM-Exec-Res (D163 , D160) ) by SCMPDS_1:def 23
.= ( SCM-Chg (D165 , ( succ ( IC D160 ) )) ) by L456 , SCMPDS_1:def 22;
thus L458: ( ( Exec (( saveIC (R16 , R9) ) , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) ) by L457 , L8 , AMI_2:11;
thus L459: ( ( Exec (( saveIC (R16 , R9) ) , R3) ) . D167 ) = ( D165 . D164 ) by L457 , L455 , AMI_2:12
.= ( IC R3 ) by L8 , AMI_2:15;
let R17 being Int_position;
reconsider D168 = R17 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
assume L460: D167 <> R17;
thus L461: ( ( Exec (( saveIC (R16 , R9) ) , R3) ) . R17 ) = ( D165 . D168 ) by L457 , AMI_2:12
.= ( R3 . R17 ) by L455 , L460 , AMI_2:16;
end;
canceled 1;
theorem
L462: (for B71 being Integer holds (ex B72 being (State of ( SCMPDS )) st (for B73 being Int_position holds ( B72 . B73 ) = B71)))
proof
set D169 = ( the_Values_of ( SCMPDS ) );
set D170 = the SCM-State;
let C96 being Integer;
L463: ( dom D170 ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2;
L464: ( dom D169 ) = ( SCM-Memory ) by PARTFUN1:def 2;
L465: C96 in ( INT ) by INT_1:def 2;
reconsider D171 = ( ( SCM-Data-Loc ) --> C96 ) as (Function of ( SCM-Data-Loc ) , ( INT )) by L465 , FUNCOP_1:45;
set D172 = ( D170 +* D171 );
L466: (for B74 being set holds (B74 in ( dom D169 ) implies ( D172 . B74 ) in ( D169 . B74 )))
proof
let C97 being set;
assume that
L467: C97 in ( dom D169 );
per cases ;
suppose L468: C97 in ( dom D171 );

L469: C97 in ( SCM-Data-Loc ) by L468 , FUNCT_2:def 1;
L470: ( D169 . C97 ) = ( INT ) by L469 , AMI_2:8;
L471: ( D172 . C97 ) = ( D171 . C97 ) by L468 , FUNCT_4:13
.= C96 by L469 , FUNCOP_1:7;
thus L472: thesis by L471 , L470 , INT_1:def 2;
end;
suppose L473: (not C97 in ( dom D171 ));

L474: ( D172 . C97 ) = ( D170 . C97 ) by L473 , FUNCT_4:11;
thus L475: thesis by L474 , L467 , CARD_3:9;
end;
end;
L477: ( dom D172 ) = ( ( dom D170 ) \/ ( dom D171 ) ) by FUNCT_4:def 1
.= ( ( SCM-Memory ) \/ ( dom D171 ) ) by L463
.= ( ( SCM-Memory ) \/ ( SCM-Data-Loc ) ) by FUNCT_2:def 1
.= ( SCM-Memory ) by XBOOLE_1:12;
reconsider D173 = D172 as (State of ( SCMPDS )) by L477 , L464 , L466 , FUNCT_1:def 14 , PARTFUN1:def 2 , RELAT_1:def 18;
take D173;
let C98 being Int_position;
reconsider D174 = C98 as (Element of ( SCM-Data-Loc )) by AMI_2:def 16;
L478: D174 in ( SCM-Data-Loc );
L479: D174 in ( dom D171 ) by L478 , FUNCT_2:def 1;
thus L480: ( D173 . C98 ) = ( D171 . D174 ) by L479 , FUNCT_4:13
.= C96 by FUNCOP_1:7;
end;
theorem
L481: (for B75 being Integer holds (for B76 being (Element of ( NAT )) holds (ex B77 being (State of ( SCMPDS )) st (( B77 . ( NAT ) ) = B76 & (for B78 being Int_position holds ( B77 . B78 ) = B75)))))
proof
set D175 = ( the_Values_of ( SCMPDS ) );
let C99 being Integer;
let C100 being (Element of ( NAT ));
L482: { ( NAT ) } c= ( SCM-Memory ) by AMI_2:22 , ZFMISC_1:31;
L483: ( dom D175 ) = ( SCM-Memory ) by PARTFUN1:def 2;
consider C101 being (State of ( SCMPDS )) such that L484: (for B79 being Int_position holds ( C101 . B79 ) = C99) by L462;
reconsider D176 = C101 as SCM-State by CARD_3:107;
set D177 = ( D176 +* ( ( NAT ) .--> C100 ) );
L485: ( dom D176 ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2;
L486: ( dom ( ( NAT ) .--> C100 ) ) = { ( NAT ) } by FUNCOP_1:13;
L487: ( NAT ) in ( dom ( ( NAT ) .--> C100 ) ) by L486 , TARSKI:def 1;
L488: ( D177 . ( NAT ) ) = ( ( ( NAT ) .--> C100 ) . ( NAT ) ) by L487 , FUNCT_4:13
.= C100 by FUNCOP_1:72;
L489: ( D177 . ( NAT ) ) in ( NAT ) by L488;
L490: (for B80 being set holds (B80 in ( dom D175 ) implies ( D177 . B80 ) in ( D175 . B80 )))
proof
let C102 being set;
assume that
L491: C102 in ( dom D175 );
per cases ;
suppose L492: C102 = ( NAT );

thus L493: thesis by L492 , L489 , AMI_2:6;
end;
suppose L494: C102 <> ( NAT );

L495: (not C102 in ( dom ( ( NAT ) .--> C100 ) )) by L494 , L486 , TARSKI:def 1;
L496: ( D177 . C102 ) = ( D176 . C102 ) by L495 , FUNCT_4:11;
thus L497: thesis by L496 , L491 , CARD_3:9;
end;
end;
L499: ( dom D177 ) = ( ( dom D176 ) \/ ( dom ( ( NAT ) .--> C100 ) ) ) by FUNCT_4:def 1
.= ( ( SCM-Memory ) \/ ( dom ( ( NAT ) .--> C100 ) ) ) by L485
.= ( ( SCM-Memory ) \/ { ( NAT ) } ) by FUNCOP_1:13
.= ( SCM-Memory ) by L482 , XBOOLE_1:12;
reconsider D178 = D177 as (State of ( SCMPDS )) by L499 , L483 , L490 , FUNCT_1:def 14 , PARTFUN1:def 2 , RELAT_1:def 18;
take D178;
thus L500: ( D178 . ( NAT ) ) = C100 by L488;
thus L501:now
let C103 being Int_position;
L502: C103 in ( SCM-Data-Loc ) by AMI_2:def 16;
L503: (ex B81 being (Element of ( NAT )) st C103 = [ 1 , B81 ]) by L502 , AMI_2:23;
L504: (not C103 in ( dom ( ( NAT ) .--> C100 ) )) by L486 , L503 , TARSKI:def 1;
thus L505: ( D178 . C103 ) = ( C101 . C103 ) by L504 , FUNCT_4:11
.= C99 by L484;
end;
end;
L502: (for R3 being (State of ( SCMPDS )) holds (for R15 being (Instruction of ( SCMPDS )) holds (( InsCode R15 ) = ( 0 ) implies ( Exec (R15 , R3) ) = R3)))
proof
let R3 being (State of ( SCMPDS ));
let R15 being (Instruction of ( SCMPDS ));
assume L503: ( InsCode R15 ) = ( 0 );
L504: (( InsCode R15 ) <> 1 & ( InsCode R15 ) <> 2 & ( InsCode R15 ) <> 3 & ( InsCode R15 ) <> 4 & ( InsCode R15 ) <> 5 & ( InsCode R15 ) <> 6 & ( InsCode R15 ) <> 7 & ( InsCode R15 ) <> 8 & ( InsCode R15 ) <> 9 & ( InsCode R15 ) <> 10 & ( InsCode R15 ) <> 11 & ( InsCode R15 ) <> 12 & ( InsCode R15 ) <> 13 & ( InsCode R15 ) <> 14) by L503;
reconsider D179 = R3 as SCM-State by CARD_3:107;
reconsider D180 = R15 as (Element of ( SCMPDS-Instr ));
thus L505: ( Exec (R15 , R3) ) = ( ( (the Execution of ( SCMPDS )) . R15 ) . R3 )
.= ( ( ( SCMPDS-Exec ) . R15 ) . R3 )
.= ( SCM-Exec-Res (D180 , D179) ) by SCMPDS_1:def 23
.= R3 by L504 , SCMPDS_1:def 22;
end;
theorem
L506: (for B82 being (Instruction of ( SCMPDS )) holds (B82 = [ ( 0 ) , ( {} ) , ( {} ) ] implies B82 is  halting))
proof
let C104 being (Instruction of ( SCMPDS ));
assume L507: C104 = [ ( 0 ) , ( {} ) , ( {} ) ];
L508: ( InsCode C104 ) = ( 0 ) by L507 , RECDEF_2:def 1;
let C105 being (State of ( SCMPDS ));
thus L509: ( Exec (C104 , C105) ) = C105 by L508 , L502;
end;
theorem
L510: (for B83 being (Instruction of ( SCMPDS )) holds ((ex R3 being (State of ( SCMPDS )) st ( ( Exec (B83 , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) )) implies B83 is non  halting))
proof
let C106 being (Instruction of ( SCMPDS ));
given R3 being (State of ( SCMPDS )) such that
L511: ( ( Exec (C106 , R3) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R3 ) );

assume L512: C106 is  halting;
L513: ( ( Exec (C106 , R3) ) . ( IC ( SCMPDS ) ) ) = ( R3 . ( NAT ) ) by L512 , L8 , EXTPRO_1:def 3;
thus L514: contradiction by L513 , L511 , L8;
L515: ( IC R3 ) = ( R3 . ( NAT ) ) by AMI_2:22 , FUNCT_7:def 1;
reconsider D181 = ( R3 . ( NAT ) ) as (Element of ( NAT )) by L515;
end;
theorem
L517: (for R9 being Integer holds (for R16 being Int_position holds ( R16 := R9 ) is non  halting))
proof
let R9 being Integer;
let R16 being Int_position;
set D182 = the (State of ( SCMPDS ));
L518: ( ( Exec (( R16 := R9 ) , D182) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC D182 ) ) by L305;
thus L519: thesis by L518 , L510;
end;
theorem
L520: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds ( (R16 , R9) := R10 ) is non  halting)))
proof
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
set D183 = the (State of ( SCMPDS ));
L521: ( ( Exec (( (R16 , R9) := R10 ) , D183) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC D183 ) ) by L315;
thus L522: thesis by L521 , L510;
end;
theorem
L523: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds ( (R16 , R9) := (R17 , R10) ) is non  halting))))
proof
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
let R17 being Int_position;
set D184 = the (State of ( SCMPDS ));
L524: ( ( Exec (( (R16 , R9) := (R17 , R10) ) , D184) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC D184 ) ) by L325;
thus L525: thesis by L524 , L510;
end;
theorem
L526: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds ( AddTo (R16 , R9 , R10) ) is non  halting)))
proof
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
set D185 = the (State of ( SCMPDS ));
L527: ( ( Exec (( AddTo (R16 , R9 , R10) ) , D185) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC D185 ) ) by L335;
thus L528: thesis by L527 , L510;
end;
theorem
L529: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds ( AddTo (R16 , R9 , R17 , R10) ) is non  halting))))
proof
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
let R17 being Int_position;
set D186 = the (State of ( SCMPDS ));
L530: ( ( Exec (( AddTo (R16 , R9 , R17 , R10) ) , D186) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC D186 ) ) by L345;
thus L531: thesis by L530 , L510;
end;
theorem
L532: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds ( SubFrom (R16 , R9 , R17 , R10) ) is non  halting))))
proof
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
let R17 being Int_position;
set D187 = the (State of ( SCMPDS ));
L533: ( ( Exec (( SubFrom (R16 , R9 , R17 , R10) ) , D187) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC D187 ) ) by L355;
thus L534: thesis by L533 , L510;
end;
theorem
L535: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds ( MultBy (R16 , R9 , R17 , R10) ) is non  halting))))
proof
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
let R17 being Int_position;
set D188 = the (State of ( SCMPDS ));
L536: ( ( Exec (( MultBy (R16 , R9 , R17 , R10) ) , D188) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC D188 ) ) by L365;
thus L537: thesis by L536 , L510;
end;
theorem
L538: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds (for R17 being Int_position holds ( Divide (R16 , R9 , R17 , R10) ) is non  halting))))
proof
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
let R17 being Int_position;
set D189 = the (State of ( SCMPDS ));
L539: ( ( Exec (( Divide (R16 , R9 , R17 , R10) ) , D189) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC D189 ) ) by L375;
thus L540: thesis by L539 , L510;
end;
theorem
L541: (for R9 being Integer holds (R9 <> ( 0 ) implies ( goto R9 ) is non  halting))
proof
let R9 being Integer;
assume L542: R9 <> ( 0 );
set D190 = ( abs R9 );
reconsider D191 = ( D190 + 1 ) as (Element of ( NAT ));
consider C107 being (State of ( SCMPDS )) such that L543: ( C107 . ( NAT ) ) = D191 and L544: (for B84 being Int_position holds ( C107 . B84 ) = ( 0 )) by L481;
L545: ( - D190 ) <= R9 by ABSVALUE:4;
L546: ( ( 0 ) - D190 ) <= R9 by L545;
L547: ( ( D190 + R9 ) * 1 ) >= ( 0 ) by L546 , XREAL_1:20;
L548: (ex B85 being (Element of ( NAT )) st (B85 = ( IC C107 ) & ( ICplusConst (C107 , R9) ) = ( abs ( B85 + R9 ) ))) by L390;
L549: ( ( Exec (( goto R9 ) , C107) ) . ( IC ( SCMPDS ) ) ) = ( abs ( ( D190 + R9 ) + 1 ) ) by L548 , L543 , L8 , L394
.= ( ( abs ( D190 + R9 ) ) + ( abs 1 ) ) by L547 , ABSVALUE:11
.= ( ( abs ( D190 + R9 ) ) + 1 ) by ABSVALUE:def 1
.= ( ( D190 + R9 ) + 1 ) by L547 , ABSVALUE:def 1
.= ( ( D190 + 1 ) + R9 );
assume L550: ( goto R9 ) is  halting;
L551: ( ( Exec (( goto R9 ) , C107) ) . ( IC ( SCMPDS ) ) ) = ( D190 + 1 ) by L550 , L543 , L8 , EXTPRO_1:def 3;
thus L552: contradiction by L551 , L542 , L549;
end;
theorem
L553: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds ( (R16 , R9) <>0_goto R10 ) is non  halting)))
proof
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
consider C108 being (State of ( SCMPDS )) such that L554: (for B86 being Int_position holds ( C108 . B86 ) = ( 0 )) by L462;
L555: ( C108 . ( DataLoc (( C108 . R16 ) , R9) ) ) = ( 0 ) by L554;
L556: ( ( Exec (( (R16 , R9) <>0_goto R10 ) , C108) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC C108 ) ) by L555 , L402;
thus L557: thesis by L556 , L510;
end;
theorem
L558: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds ( (R16 , R9) <=0_goto R10 ) is non  halting)))
proof
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
consider C109 being (State of ( SCMPDS )) such that L559: (for B87 being Int_position holds ( C109 . B87 ) = 1) by L462;
L560: ( C109 . ( DataLoc (( C109 . R16 ) , R9) ) ) = 1 by L559;
L561: ( ( Exec (( (R16 , R9) <=0_goto R10 ) , C109) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC C109 ) ) by L560 , L416;
thus L562: thesis by L561 , L510;
end;
theorem
L563: (for R9 being Integer holds (for R10 being Integer holds (for R16 being Int_position holds ( (R16 , R9) >=0_goto R10 ) is non  halting)))
proof
let R9 being Integer;
let R10 being Integer;
let R16 being Int_position;
consider C110 being (State of ( SCMPDS )) such that L564: (for B88 being Int_position holds ( C110 . B88 ) = ( - 1 )) by L462;
L565: ( C110 . ( DataLoc (( C110 . R16 ) , R9) ) ) = ( - 1 ) by L564;
L566: ( ( Exec (( (R16 , R9) >=0_goto R10 ) , C110) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC C110 ) ) by L565 , L430;
thus L567: thesis by L566 , L510;
end;
theorem
L568: (for R16 being Int_position holds ( return R16 ) is non  halting)
proof
let R16 being Int_position;
reconsider D192 = 1 as (Element of ( NAT ));
L569: ( In (( NAT ) , ( SCM-Memory )) ) = ( NAT ) by AMI_2:22 , FUNCT_7:def 1;
consider C111 being (State of ( SCMPDS )) such that L570: ( C111 . ( NAT ) ) = D192 and L571: (for B89 being Int_position holds ( C111 . B89 ) = ( 0 )) by L481;
L572: ( ( Exec (( return R16 ) , C111) ) . ( IC ( SCMPDS ) ) ) = ( ( abs ( C111 . ( DataLoc (( C111 . R16 ) , ( RetIC )) ) ) ) + 2 ) by L444
.= ( ( abs ( 0 ) ) + 2 ) by L571
.= ( ( 0 ) + 2 ) by ABSVALUE:def 1
.= ( succ ( IC C111 ) ) by L570 , L569;
thus L573: thesis by L572 , L510;
end;
theorem
L574: (for R9 being Integer holds (for R16 being Int_position holds ( saveIC (R16 , R9) ) is non  halting))
proof
let R9 being Integer;
let R16 being Int_position;
set D193 = the (State of ( SCMPDS ));
L575: ( ( Exec (( saveIC (R16 , R9) ) , D193) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC D193 ) ) by L453;
thus L576: thesis by L575 , L510;
end;
theorem
L577: (for B90 being set holds (B90 is (Instruction of ( SCMPDS )) implies (B90 = [ ( 0 ) , ( {} ) , ( {} ) ] or (ex R9 being Integer st B90 = ( goto R9 )) or (ex R16 being Int_position st B90 = ( return R16 )) or (ex R16 being Int_position st (ex R9 being Integer st B90 = ( saveIC (R16 , R9) ))) or (ex R16 being Int_position st (ex R9 being Integer st B90 = ( R16 := R9 ))) or (ex R16 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B90 = ( (R16 , R9) := R10 )))) or (ex R16 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B90 = ( (R16 , R9) <>0_goto R10 )))) or (ex R16 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B90 = ( (R16 , R9) <=0_goto R10 )))) or (ex R16 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B90 = ( (R16 , R9) >=0_goto R10 )))) or (ex R16 being Int_position st (ex R17 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B90 = ( AddTo (R16 , R9 , R10) ))))) or (ex R16 being Int_position st (ex R17 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B90 = ( AddTo (R16 , R9 , R17 , R10) ))))) or (ex R16 being Int_position st (ex R17 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B90 = ( SubFrom (R16 , R9 , R17 , R10) ))))) or (ex R16 being Int_position st (ex R17 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B90 = ( MultBy (R16 , R9 , R17 , R10) ))))) or (ex R16 being Int_position st (ex R17 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B90 = ( Divide (R16 , R9 , R17 , R10) ))))) or (ex R16 being Int_position st (ex R17 being Int_position st (ex R9 being Integer st (ex R10 being Integer st B90 = ( (R16 , R9) := (R17 , R10) ))))))))
proof
let C112 being set;
assume L578: C112 is (Instruction of ( SCMPDS ));
reconsider D194 = C112 as (Instruction of ( SCMPDS )) by L578;
per cases  by L15;
suppose L579: D194 in { [ ( 0 ) , ( {} ) , ( {} ) ] };

L580: D194 = [ ( 0 ) , ( {} ) , ( {} ) ] by L579 , TARSKI:def 1;
thus L581: thesis by L580;
end;
suppose L582: D194 in D2;

consider C113 being (Element of ( INT )) such that L583: D194 = [ 14 , ( {} ) , <* C113 *> ] by L582;
L584: D194 = ( goto C113 ) by L583;
thus L585: thesis by L584;
end;
suppose L586: D194 in D3;

consider R4 being (Element of ( SCM-Data-Loc )) such that L587: D194 = [ 1 , ( {} ) , <* R4 *> ] by L586;
reconsider D195 = R4 as Int_position by AMI_2:def 16;
L588: D194 = ( return D195 ) by L587;
thus L589: thesis by L588;
end;
suppose L590: D194 in D4;

consider C114 being (Element of ( Segm 15 )), C115 being (Element of ( SCM-Data-Loc )), C116 being (Element of ( INT )) such that L591: (D194 = [ C114 , ( {} ) , <* C115 , C116 *> ] & C114 in { 2 , 3 }) by L590;
reconsider D196 = C115 as Int_position by AMI_2:def 16;
L592: (D194 = ( saveIC (D196 , C116) ) or D194 = ( D196 := C116 )) by L591 , TARSKI:def 2;
thus L593: thesis by L592;
end;
suppose L594: D194 in D5;

consider C117 being (Element of ( Segm 15 )), C118 being (Element of ( SCM-Data-Loc )), C119 , C120 being (Element of ( INT )) such that L595: (D194 = [ C117 , ( {} ) , <* C118 , C119 , C120 *> ] & C117 in { 4 , 5 , 6 , 7 , 8 }) by L594;
reconsider D197 = C118 as Int_position by AMI_2:def 16;
L596: (D194 = ( (D197 , C119) <>0_goto C120 ) or D194 = ( (D197 , C119) <=0_goto C120 ) or D194 = ( (D197 , C119) >=0_goto C120 ) or D194 = ( (D197 , C119) := C120 ) or D194 = ( AddTo (D197 , C119 , C120) )) by L595 , ENUMSET1:def 3;
thus L597: thesis by L596;
end;
suppose L598: D194 in D6;

consider C121 being (Element of ( Segm 15 )), C122 , C123 being (Element of ( SCM-Data-Loc )), C124 , C125 being (Element of ( INT )) such that L599: (D194 = [ C121 , ( {} ) , <* C122 , C123 , C124 , C125 *> ] & C121 in { 9 , 10 , 11 , 12 , 13 }) by L598;
reconsider D198 = C122 , D199 = C123 as Int_position by AMI_2:def 16;
L600: (D194 = ( AddTo (D198 , C124 , D199 , C125) ) or D194 = ( SubFrom (D198 , C124 , D199 , C125) ) or D194 = ( MultBy (D198 , C124 , D199 , C125) ) or D194 = ( Divide (D198 , C124 , D199 , C125) ) or D194 = ( (D198 , C124) := (D199 , C125) )) by L599 , ENUMSET1:def 3;
thus L601: thesis by L600;
end;
end;
registration
cluster ( SCMPDS ) ->  halting;
coherence
proof
thus L603: ( halt ( SCMPDS ) ) is  halting by L506;
end;
end;
theorem
L605: ( halt ( SCMPDS ) ) = [ ( 0 ) , ( {} ) , ( {} ) ];
canceled 1;
theorem
L606: (for B91 being (Element of ( NAT )) holds ( IC ( SCMPDS ) ) <> ( dl. B91 ))
proof
let C126 being (Element of ( NAT ));
assume L607: ( IC ( SCMPDS ) ) = ( dl. C126 );
L608: ( NAT ) = [ 1 , C126 ] by L607 , L8 , AMI_3:def 11;
thus L609: contradiction by L608;
end;
canceled 1;
theorem
L610: ( Data-Locations ( SCMPDS ) ) = ( SCM-Data-Loc ) by L278;
canceled 1;
theorem
L611: (for R3 being (State of ( SCMPDS )) holds (for R15 being (Instruction of ( SCMPDS )) holds (( InsCode R15 ) = ( 0 ) implies ( Exec (R15 , R3) ) = R3))) by L502;
