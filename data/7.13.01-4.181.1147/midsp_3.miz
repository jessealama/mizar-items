:: Reper Algebras
::  by Micha{\l} Muzalewski
::
:: Received May 28, 1992
:: Copyright (c) 1992-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies SUBSET_1, NUMBERS, XBOOLE_0, FINSEQ_1, ARYTM_3, ORDINAL4,
      XXREAL_0, NAT_1, FUNCT_1, ARYTM_1, RELAT_1, FINSEQ_2, FUNCT_4, MIDSP_1,
      STRUCT_0, BINOP_1, QC_LANG1, PRE_TOPC, CARD_1, TARSKI, MIDSP_2, VECTSP_1,
      GROUP_4, SUPINF_2, ROBBINS1, MIDSP_3;
 notations TARSKI, XBOOLE_0, SUBSET_1, XCMPLX_0, FUNCT_1, FUNCT_2, BINOP_1,
      STRUCT_0, ALGSTR_0, PRE_TOPC, FINSEQ_1, FINSEQ_2, NUMBERS, ORDINAL1,
      NAT_1, FUNCT_7, MIDSP_1, MIDSP_2, XXREAL_0;
 constructors BINOP_1, NAT_1, FINSEQ_2, FUNCT_7, MIDSP_2, RELSET_1;
 registrations RELSET_1, XREAL_0, NAT_1, FINSEQ_2, STRUCT_0, ORDINAL1,
      XBOOLE_0;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions MIDSP_1;
 theorems FINSEQ_1, FINSEQ_2, FUNCT_1, MIDSP_1, MIDSP_2, NAT_1, ZFMISC_1,
      FINSEQ_3, XREAL_1, FUNCT_7, XBOOLE_0, TARSKI, ORDINAL1, XXREAL_0, CARD_1;
 schemes FINSEQ_2, FUNCT_2;

begin
theorem
L1: (for R3 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds (for R6 being non  empty set holds (for R9 being (FinSequence of R6) holds (( len R9 ) = ( ( R3 + 1 ) + R4 ) implies (ex R10 being (FinSequence of R6) st (ex R12 being (FinSequence of R6) st (ex R7 being (Element of R6) st (( len R10 ) = R3 & ( len R12 ) = R4 & R9 = ( ( R10 ^ <* R7 *> ) ^ R12 ))))))))))
proof
let R3 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
let R6 being non  empty set;
let R9 being (FinSequence of R6);
assume L2: ( len R9 ) = ( ( R3 + 1 ) + R4 );
consider R11 being (FinSequence of R6), R12 being (FinSequence of R6) such that L3: ( len R11 ) = ( R3 + 1 ) and L4: (( len R12 ) = R4 & R9 = ( R11 ^ R12 )) by L2 , FINSEQ_2:23;
consider R10 being (FinSequence of R6), R7 being (Element of R6) such that L5: R11 = ( R10 ^ <* R7 *> ) by L3 , FINSEQ_2:19;
take R10;
take R12;
take R7;
L6: ( len R11 ) = ( ( len R10 ) + 1 ) by L5 , FINSEQ_2:16;
thus L7: thesis by L6 , L3 , L4 , L5;
end;
theorem
L8: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (R2 in ( Seg R1 ) implies (ex R3 being (Element of ( NAT )) st (ex R4 being (Element of ( NAT )) st (R1 = ( ( R3 + 1 ) + R4 ) & R2 = ( R3 + 1 )))))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
assume L9: R2 in ( Seg R1 );
L10: 1 <= R2 by L9 , FINSEQ_1:1;
consider C1 being Nat such that L11: R2 = ( 1 + C1 ) by L10 , NAT_1:10;
reconsider D1 = C1 as (Element of ( NAT )) by ORDINAL1:def 12;
L12: R2 <= R1 by L9 , FINSEQ_1:1;
consider C2 being Nat such that L13: R1 = ( ( D1 + 1 ) + C2 ) by L12 , L11 , NAT_1:10;
reconsider D2 = C2 as (Element of ( NAT )) by ORDINAL1:def 12;
take D1;
take D2;
thus L14: thesis by L11 , L13;
end;
theorem
L15: (for R2 being (Element of ( NAT )) holds (for R6 being non  empty set holds (for R7 being (Element of R6) holds (for R9 being (FinSequence of R6) holds (for R10 being (FinSequence of R6) holds (for R12 being (FinSequence of R6) holds ((R9 = ( ( R10 ^ <* R7 *> ) ^ R12 ) & R2 = ( ( len R10 ) + 1 )) implies ((for R5 being (Element of ( NAT )) holds ((1 <= R5 & R5 <= ( len R10 )) implies ( R9 . R5 ) = ( R10 . R5 ))) & ( R9 . R2 ) = R7 & (for R5 being (Element of ( NAT )) holds ((( R2 + 1 ) <= R5 & R5 <= ( len R9 )) implies ( R9 . R5 ) = ( R12 . ( R5 - R2 ) )))))))))))
proof
let R2 being (Element of ( NAT ));
let R6 being non  empty set;
let R7 being (Element of R6);
let R9 being (FinSequence of R6);
let R10 being (FinSequence of R6);
let R12 being (FinSequence of R6);
set D3 = ( R10 ^ <* R7 *> );
assume that
L16: R9 = ( D3 ^ R12 )
and
L17: R2 = ( ( len R10 ) + 1 );
L18: R9 = ( R10 ^ ( <* R7 *> ^ R12 ) ) by L16 , FINSEQ_1:32;
thus L19: (for R5 being (Element of ( NAT )) holds ((1 <= R5 & R5 <= ( len R10 )) implies ( R9 . R5 ) = ( R10 . R5 )))
proof
let R5 being (Element of ( NAT ));
assume L20: (1 <= R5 & R5 <= ( len R10 ));
L21: R5 in ( dom R10 ) by L20 , FINSEQ_3:25;
thus L22: thesis by L21 , L18 , FINSEQ_1:def 7;
end;

L23: ( len D3 ) = R2 by L17 , FINSEQ_2:16;
L24: R2 in ( Seg R2 ) by L17 , FINSEQ_1:3;
L25: R2 in ( dom D3 ) by L24 , L23 , FINSEQ_1:def 3;
thus L26: ( R9 . R2 ) = ( D3 . R2 ) by L25 , L16 , FINSEQ_1:def 7
.= R7 by L17 , FINSEQ_1:42;
L27: ( len R9 ) = ( ( len D3 ) + ( len R12 ) ) by L16 , FINSEQ_1:22;
thus L28: thesis by L27 , L16 , L23 , FINSEQ_1:23;
end;
theorem
L29: (for R3 being (Element of ( NAT )) holds (for R5 being (Element of ( NAT )) holds (R5 <= R3 or R5 = ( R3 + 1 ) or ( R3 + 2 ) <= R5)))
proof
let R3 being (Element of ( NAT ));
let R5 being (Element of ( NAT ));
L30: ( ( R3 + 1 ) + 1 ) = ( R3 + 2 );
L31: (R5 < ( R3 + 1 ) or R5 = ( R3 + 1 ) or ( R3 + 1 ) < R5) by XXREAL_0:1;
thus L32: thesis by L31 , L30 , NAT_1:13;
end;
theorem
L33: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R3 being (Element of ( NAT )) holds (for R5 being (Element of ( NAT )) holds ((R5 in ( ( Seg R1 ) \ { R2 } ) & R2 = ( R3 + 1 )) implies ((1 <= R5 & R5 <= R3) or (( R2 + 1 ) <= R5 & R5 <= R1)))))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R3 being (Element of ( NAT ));
let R5 being (Element of ( NAT ));
assume that
L34: R5 in ( ( Seg R1 ) \ { R2 } )
and
L35: R2 = ( R3 + 1 );
L36: ( R2 + 1 ) = ( R3 + 2 ) by L35;
L37: (R5 in ( Seg R1 ) & R5 <> R2) by L34 , ZFMISC_1:56;
thus L38: thesis by L37 , L35 , L36 , L29 , FINSEQ_1:1;
end;
definition
let R6 being non  empty set;
let R1 being (Element of ( NAT ));
let C3 being (Element of ( R1 -tuples_on R6 ));
let R2 being (Element of ( NAT ));
let R8 being (Element of R6);
redefine func C3 +* (R2 , R8) -> (Element of ( R1 -tuples_on R6 ));

coherence
proof
L39: ( dom ( C3 +* (R2 , R8) ) ) = ( dom C3 ) by FUNCT_7:30;
L40: ( len ( C3 +* (R2 , R8) ) ) = ( len C3 ) by L39 , FINSEQ_3:29
.= R1 by CARD_1:def 7;
thus L41: ( C3 +* (R2 , R8) ) is (Element of ( R1 -tuples_on R6 )) by L40 , FINSEQ_2:92;
end;
end;
L43: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R6 being non  empty set holds (for R8 being (Element of R6) holds (for B1 being (Element of ( R1 -tuples_on R6 )) holds (R2 in ( Seg R1 ) implies ( ( B1 +* (R2 , R8) ) . R2 ) = R8))))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R6 being non  empty set;
let R8 being (Element of R6);
let C4 being (Element of ( R1 -tuples_on R6 ));
L44: ( Seg R1 ) = ( dom C4 ) by FINSEQ_2:124;
thus L45: thesis by L44 , FUNCT_7:31;
end;
L46: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R6 being non  empty set holds (for R8 being (Element of R6) holds (for B2 being (Element of ( R1 -tuples_on R6 )) holds (for R5 being (Element of ( NAT )) holds (R5 in ( ( dom B2 ) \ { R2 } ) implies ( ( B2 +* (R2 , R8) ) . R5 ) = ( B2 . R5 ))))))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R6 being non  empty set;
let R8 being (Element of R6);
let C5 being (Element of ( R1 -tuples_on R6 ));
let R5 being (Element of ( NAT ));
assume L47: R5 in ( ( dom C5 ) \ { R2 } );
L48: (not R5 in { R2 }) by L47 , XBOOLE_0:def 5;
L49: R5 <> R2 by L48 , TARSKI:def 1;
thus L50: thesis by L49 , FUNCT_7:32;
end;
begin
definition
let R1 being (Element of ( NAT ));
struct (MidStr) ReperAlgebraStr over R1(# carrier -> set , MIDPOINT -> (BinOp of the carrier) , reper -> (Function of ( R1 -tuples_on the carrier ) , the carrier) #);
end;
registration
let R1 being (Element of ( NAT ));
let C6 being non  empty set;
let C7 being (BinOp of C6);
let C8 being (Function of ( R1 -tuples_on C6 ) , C6);
cluster ReperAlgebraStr (# C6 , C7 , C8 #) -> non  empty;
coherence;
end;
L53:
now
let R1 being (Element of ( NAT ));
let C9 being MidSp;
let C10 being (Function of ( ( R1 + 2 ) -tuples_on (the carrier of C9) ) , (the carrier of C9));
set D4 = ReperAlgebraStr (# (the carrier of C9) , (the MIDPOINT of C9) , C10 #);
thus L54: D4 is  MidSp-like
proof
let C11 , C12 , C13 , C14 being (Element of D4);
reconsider D5 = C11 , D6 = C12 , D7 = C13 , D8 = C14 as (Element of C9);
thus L55: ( C11 @ C11 ) = ( D5 @ D5 )
.= C11 by MIDSP_1:def 3;
consider C15 being (Element of C9) such that L56: ( C15 @ D5 ) = D6 by MIDSP_1:def 3;
L57: (for B3 , B4 being (Element of D4) holds (for B5 , B6 being (Element of C9) holds ((B3 = B5 & B4 = B6) implies ( B3 @ B4 ) = ( B5 @ B6 ))));
thus L58: ( C11 @ C12 ) = ( D6 @ D5 ) by L57
.= ( C12 @ C11 );
reconsider D9 = C15 as (Element of D4);
thus L59: ( ( C11 @ C12 ) @ ( C13 @ C14 ) ) = ( ( D5 @ D6 ) @ ( D7 @ D8 ) )
.= ( ( D5 @ D7 ) @ ( D6 @ D8 ) ) by MIDSP_1:def 3
.= ( ( C11 @ C13 ) @ ( C12 @ C14 ) );
take D9;
thus L60: thesis by L56;
end;

end;
registration
let R1 being (Element of ( NAT ));
cluster non  empty for ReperAlgebraStr over R1;
existence
proof
set D10 = the non  empty set;
set D11 = the (BinOp of D10);
set D12 = the (Function of ( R1 -tuples_on D10 ) , D10);
take ReperAlgebraStr (# D10 , D11 , D12 #);
thus L55: thesis;
end;
end;
registration
let R1 being (Element of ( NAT ));
cluster  MidSp-like for non  empty non  empty non  empty non  empty ReperAlgebraStr over ( R1 + 2 );
existence
proof
set D13 = the MidSp;
set D14 = the (Function of ( ( R1 + 2 ) -tuples_on (the carrier of D13) ) , (the carrier of D13));
take ReperAlgebraStr (# (the carrier of D13) , (the MIDPOINT of D13) , D14 #);
thus L57: thesis by L53;
end;
end;
definition
let R1 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R2 being (Element of ( NAT ));
mode Tuple of R2 , R13
 is (Element of ( R2 -tuples_on (the carrier of R13) ));
end;
definition
let R1 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R14 being (Point of R13);
redefine func <*R14 *> -> (Tuple of 1 , R13);

coherence by FINSEQ_2:98;
end;
definition
let R1 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R2 being (Element of ( NAT ));
let R3 being (Element of ( NAT ));
let C16 being (Tuple of R2 , R13);
let C17 being (Tuple of R3 , R13);
redefine func C16 ^ C17 -> (Tuple of ( R2 + R3 ) , R13);

coherence
proof
reconsider D15 = C16 as (Tuple of R2 , (the carrier of R13));
reconsider D16 = C17 as (Tuple of R3 , (the carrier of R13));
L61: ( D15 ^ D16 ) is (Tuple of ( R2 + R3 ) , (the carrier of R13)) by FINSEQ_2:107;
thus L62: thesis by L61 , FINSEQ_2:131;
end;
end;
definition
let R1 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R14 being (Point of R13);
let R19 being (Tuple of ( R1 + 1 ) , R13);
func *' (R14 , R19) -> (Point of R13) equals 
( (the reper of R13) . ( <* R14 *> ^ R19 ) );
coherence
proof
reconsider D17 = ( <* R14 *> ^ R19 ) as (Tuple of ( R1 + 2 ) , R13);
L64: ( (the reper of R13) . D17 ) is (Point of R13);
thus L65: thesis by L64;
end;
end;
theorem
L67: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 ) holds (for R16 being (Point of R13) holds (for R19 being (Tuple of ( R1 + 1 ) , R13) holds (R2 in ( Seg ( R1 + 1 ) ) implies (( ( R19 +* (R2 , R16) ) . R2 ) = R16 & (for R5 being (Element of ( NAT )) holds (R5 in ( ( dom R19 ) \ { R2 } ) implies ( ( R19 +* (R2 , R16) ) . R5 ) = ( R19 . R5 )))))))))) by L43 , L46;
definition
let R1 being (Element of ( NAT ));
mode Nat of R1
 -> (Element of ( NAT ))
means :L68: (1 <= it & it <= ( R1 + 1 ));
existence
proof
take 1;
L69: ( 0 ) <= R1 by NAT_1:2;
L70: ( ( 0 ) + 1 ) <= ( R1 + 1 ) by L69 , XREAL_1:7;
thus L71: thesis by L70;
end;
end;
theorem
L73: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (R2 is (Nat of R1) iff R2 in ( Seg ( R1 + 1 ) ))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
L74: (R2 is (Nat of R1) iff (1 <= R2 & R2 <= ( R1 + 1 ))) by L68;
thus L75: thesis by L74 , FINSEQ_1:1;
end;
theorem
L76: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (R2 <= R1 implies ( R2 + 1 ) is (Nat of R1))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
assume L77: R2 <= R1;
L78: ( R2 + 1 ) <= ( R1 + 1 ) by L77 , XREAL_1:7;
L79: 1 <= ( R2 + 1 ) by NAT_1:11;
thus L80: thesis by L79 , L78 , L68;
end;
theorem
L81: (for R1 being (Element of ( NAT )) holds (for R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 ) holds (for R19 being (Tuple of ( R1 + 1 ) , R13) holds (for R20 being (Tuple of ( R1 + 1 ) , R13) holds ((for R21 being (Nat of R1) holds ( R19 . R21 ) = ( R20 . R21 )) implies R19 = R20)))))
proof
let R1 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R19 being (Tuple of ( R1 + 1 ) , R13);
let R20 being (Tuple of ( R1 + 1 ) , R13);
assume L82: (for R21 being (Nat of R1) holds ( R19 . R21 ) = ( R20 . R21 ));
L83: (for B7 being Nat holds (B7 in ( Seg ( R1 + 1 ) ) implies ( R19 . B7 ) = ( R20 . B7 )))
proof
let C18 being Nat;
assume L84: C18 in ( Seg ( R1 + 1 ) );
reconsider D18 = C18 as (Nat of R1) by L84 , L73;
L85: ( R19 . D18 ) = ( R20 . D18 ) by L82;
thus L86: thesis by L85;
end;
thus L87: thesis by L83 , FINSEQ_2:119;
end;
theorem
L88: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 ) holds (for R16 being (Point of R13) holds (for R19 being (Tuple of ( R1 + 1 ) , R13) holds (for B8 being (Nat of R1) holds (B8 = R2 implies ( ( R19 +* (R2 , R16) ) . B8 ) = R16)))))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R16 being (Point of R13);
let R19 being (Tuple of ( R1 + 1 ) , R13);
let C19 being (Nat of R1);
assume that
L89: C19 = R2;
L90: C19 in ( Seg ( R1 + 1 ) ) by L73;
thus L91: thesis by L90 , L89 , L43;
end;
definition
let R1 being (Element of ( NAT ));
let R6 being non  empty set;
let C20 being (Element of ( ( R1 + 1 ) -tuples_on R6 ));
let R21 being (Nat of R1);
redefine func C20 . R21 -> (Element of R6);

coherence
proof
reconsider D19 = ( Seg ( R1 + 1 ) ) as non  empty set by FINSEQ_1:4;
L92: (R21 in D19 & ( len C20 ) = ( R1 + 1 )) by L73 , CARD_1:def 7;
L93: R21 in ( dom C20 ) by L92 , FINSEQ_1:def 3;
L94: (( rng C20 ) c= R6 & ( C20 . R21 ) in ( rng C20 )) by L93 , FINSEQ_1:def 4 , FUNCT_1:def 3;
thus L95: thesis by L94;
end;
end;
definition
let R1 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
attr R13 is  being_invariance
means
:L97: (for R14 being (Point of R13) holds (for R15 being (Point of R13) holds (for R19 being (Tuple of ( R1 + 1 ) , R13) holds (for R20 being (Tuple of ( R1 + 1 ) , R13) holds ((for R21 being (Nat of R1) holds ( R14 @ ( R20 . R21 ) ) = ( R15 @ ( R19 . R21 ) )) implies ( R14 @ ( *' (R15 , R20) ) ) = ( R15 @ ( *' (R14 , R19) ) ))))));
end;
definition
let R1 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R19 being (Tuple of ( R1 + 1 ) , R13);
let R2 being (Element of ( NAT ));
let R14 being (Point of R13);
redefine func R19 +* (R2 , R14) -> (Tuple of ( R1 + 1 ) , R13);

coherence
proof
thus L99: ( R19 +* (R2 , R14) ) is (Tuple of ( R1 + 1 ) , R13);
end;
end;
definition
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
pred R13 has_property_of_zero_in R2
means
:L101: (for R14 being (Point of R13) holds (for R19 being (Tuple of ( R1 + 1 ) , R13) holds ( *' (R14 , ( R19 +* (R2 , R14) )) ) = R14))
;end;
definition
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
pred R13 is_semi_additive_in R2
means
:L103: (for R14 being (Point of R13) holds (for R17 being (Point of R13) holds (for R19 being (Tuple of ( R1 + 1 ) , R13) holds (( R19 . R2 ) = R17 implies ( *' (R14 , ( R19 +* (R2 , ( R14 @ R17 )) )) ) = ( R14 @ ( *' (R14 , R19) ) )))))
;end;
theorem
L105: (for R1 being (Element of ( NAT )) holds (for R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 ) holds (for R21 being (Nat of R1) holds (R13 is_semi_additive_in R21 implies (for R14 being (Point of R13) holds (for R16 being (Point of R13) holds (for R19 being (Tuple of ( R1 + 1 ) , R13) holds (for R20 being (Tuple of ( R1 + 1 ) , R13) holds (R20 = ( R19 +* (R21 , R16) ) implies ( *' (R14 , ( R19 +* (R21 , ( R14 @ R16 )) )) ) = ( R14 @ ( *' (R14 , R20) ) ))))))))))
proof
let R1 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R21 being (Nat of R1);
assume L106: R13 is_semi_additive_in R21;
let R14 being (Point of R13);
let R16 being (Point of R13);
let R19 being (Tuple of ( R1 + 1 ) , R13);
let R20 being (Tuple of ( R1 + 1 ) , R13);
set D20 = ( R20 +* (R21 , ( R14 @ R16 )) );
assume L107: R20 = ( R19 +* (R21 , R16) );
L108: D20 = ( R19 +* (R21 , ( R14 @ R16 )) )
proof
set D21 = ( R19 +* (R21 , ( R14 @ R16 )) );
L109: (for B9 being (Nat of R1) holds ( D20 . B9 ) = ( D21 . B9 ))
proof
let C21 being (Nat of R1);
L110:
now
per cases ;
suppose L111: C21 = R21;

L112: ( D21 . R21 ) = ( R14 @ R16 ) by L88;
thus L113: thesis by L112 , L111 , L88;
end;
suppose L114: C21 <> R21;

thus L115: ( D20 . C21 ) = ( R20 . C21 ) by L114 , FUNCT_7:32
.= ( R19 . C21 ) by L107 , L114 , FUNCT_7:32
.= ( D21 . C21 ) by L114 , FUNCT_7:32;
end;
end;
thus L117: thesis by L110;
end;
thus L118: thesis by L109 , L81;
end;
L119: ( R20 . R21 ) = R16 by L107 , L88;
thus L120: thesis by L119 , L106 , L108 , L103;
end;
definition
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
pred R13 is_additive_in R2
means
:L121: (for R14 being (Point of R13) holds (for R17 being (Point of R13) holds (for R18 being (Point of R13) holds (for R19 being (Tuple of ( R1 + 1 ) , R13) holds (( R19 . R2 ) = R17 implies ( *' (R14 , ( R19 +* (R2 , ( R17 @ R18 )) )) ) = ( ( *' (R14 , R19) ) @ ( *' (R14 , ( R19 +* (R2 , R18) )) ) ))))))
;end;
definition
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
pred R13 is_alternative_in R2
means
:L123: (for R14 being (Point of R13) holds (for R19 being (Tuple of ( R1 + 1 ) , R13) holds (for R17 being (Point of R13) holds (( R19 . R2 ) = R17 implies ( *' (R14 , ( R19 +* (( R2 + 1 ) , R17) )) ) = R14))))
;end;
definition
let R1 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R22 being (ATLAS of R13);
let R2 being (Element of ( NAT ));
mode Tuple of R2 , R22
 is (Element of ( R2 -tuples_on (the carrier of (the algebra of R22)) ));
end;
theorem
L126: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 ) holds (for R22 being (ATLAS of R13) holds (for R23 being (Vector of R22) holds (for R24 being (Tuple of ( R1 + 1 ) , R22) holds (R2 in ( Seg ( R1 + 1 ) ) implies (( ( R24 +* (R2 , R23) ) . R2 ) = R23 & (for R5 being (Element of ( NAT )) holds (R5 in ( ( dom R24 ) \ { R2 } ) implies ( ( R24 +* (R2 , R23) ) . R5 ) = ( R24 . R5 ))))))))))) by L43 , L46;
theorem
L127: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 ) holds (for R22 being (ATLAS of R13) holds (for R23 being (Vector of R22) holds (for R24 being (Tuple of ( R1 + 1 ) , R22) holds ((for B10 being (Nat of R1) holds (B10 = R2 implies ( ( R24 +* (R2 , R23) ) . B10 ) = R23)) & (for B11 , B12 being (Nat of R1) holds (B11 <> B12 implies ( ( R24 +* (B12 , R23) ) . B11 ) = ( R24 . B11 ))))))))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R22 being (ATLAS of R13);
let R23 being (Vector of R22);
let R24 being (Tuple of ( R1 + 1 ) , R22);
thus L128: (for B13 being (Nat of R1) holds (B13 = R2 implies ( ( R24 +* (R2 , R23) ) . B13 ) = R23))
proof
let C22 being (Nat of R1);
assume that
L129: C22 = R2;
L130: C22 in ( Seg ( R1 + 1 ) ) by L73;
thus L131: thesis by L130 , L129 , L43;
end;

thus L132: thesis by FUNCT_7:32;
end;
theorem
L133: (for R1 being (Element of ( NAT )) holds (for R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 ) holds (for R22 being (ATLAS of R13) holds (for R24 being (Tuple of ( R1 + 1 ) , R22) holds (for R25 being (Tuple of ( R1 + 1 ) , R22) holds ((for R21 being (Nat of R1) holds ( R24 . R21 ) = ( R25 . R21 )) implies R24 = R25))))))
proof
let R1 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R22 being (ATLAS of R13);
let R24 being (Tuple of ( R1 + 1 ) , R22);
let R25 being (Tuple of ( R1 + 1 ) , R22);
assume L134: (for R21 being (Nat of R1) holds ( R24 . R21 ) = ( R25 . R21 ));
L135: (for B14 being Nat holds (B14 in ( Seg ( R1 + 1 ) ) implies ( R24 . B14 ) = ( R25 . B14 )))
proof
let C23 being Nat;
assume L136: C23 in ( Seg ( R1 + 1 ) );
reconsider D22 = C23 as (Nat of R1) by L136 , L73;
L137: ( R24 . D22 ) = ( R25 . D22 ) by L134;
thus L138: thesis by L137;
end;
thus L139: thesis by L135 , FINSEQ_2:119;
end;
scheme SeqLambdaD9 { F1() -> (Element of ( NAT )) , F2() -> non  empty set , F3(set) -> (Element of F2()) } : (ex B15 being (FinSequence of F2()) st (( len B15 ) = ( F1() + 1 ) & (for B16 being (Nat of F1()) holds ( B15 . B16 ) = F3(B16))))
proof
reconsider D23 = ( Seg ( F1() + 1 ) ) as non  empty set by FINSEQ_1:4;
consider C24 being (FinSequence of F2()) such that L140: ( len C24 ) = ( F1() + 1 ) and L141: (for B17 being Nat holds (B17 in ( dom C24 ) implies ( C24 . B17 ) = F3(B17))) from FINSEQ_2:sch 1;
take C24;
L142: ( dom C24 ) = ( Seg ( F1() + 1 ) ) by L140 , FINSEQ_1:def 3;
L143: (for B18 being (Nat of F1()) holds ( C24 . B18 ) = F3(B18))
proof
let C25 being (Nat of F1());
L144: C25 in D23 by L73;
thus L145: thesis by L144 , L141 , L142;
end;
thus L146: thesis by L143 , L140;
end;
definition
let R1 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R22 being (ATLAS of R13);
let R14 being (Point of R13);
let R24 being (Tuple of ( R1 + 1 ) , R22);
func (R14 , R24) . R22 -> (Tuple of ( R1 + 1 ) , R13) means 
:L147: (for R21 being (Nat of R1) holds ( it . R21 ) = ( (R14 , ( R24 . R21 )) . R22 ));
existence
proof
deffunc H1((Nat of R1)) = ( (R14 , ( R24 . $1 )) . R22 );
consider C26 being (FinSequence of (the carrier of R13)) such that L148: ( len C26 ) = ( R1 + 1 ) and L149: (for R21 being (Nat of R1) holds ( C26 . R21 ) = H1(R21)) from SeqLambdaD9;
reconsider D24 = C26 as (Tuple of ( R1 + 1 ) , R13) by L148 , FINSEQ_2:92;
take D24;
thus L150: thesis by L149;
end;
uniqueness
proof
let R19 being (Tuple of ( R1 + 1 ) , R13);
let R20 being (Tuple of ( R1 + 1 ) , R13);
assume that
L151: (for R21 being (Nat of R1) holds ( R19 . R21 ) = ( (R14 , ( R24 . R21 )) . R22 ))
and
L152: (for R21 being (Nat of R1) holds ( R20 . R21 ) = ( (R14 , ( R24 . R21 )) . R22 ));
L153: (for R21 being (Nat of R1) holds ( R19 . R21 ) = ( R20 . R21 ))
proof
let R21 being (Nat of R1);
L154: ( R19 . R21 ) = ( (R14 , ( R24 . R21 )) . R22 ) by L151;
thus L155: thesis by L154 , L152;
end;
thus L156: thesis by L153 , L81;
end;
end;
definition
let R1 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R22 being (ATLAS of R13);
let R14 being (Point of R13);
let R19 being (Tuple of ( R1 + 1 ) , R13);
func R22 . (R14 , R19) -> (Tuple of ( R1 + 1 ) , R22) means 
:L158: (for R21 being (Nat of R1) holds ( it . R21 ) = ( R22 . (R14 , ( R19 . R21 )) ));
existence
proof
deffunc H2((Nat of R1)) = ( R22 . (R14 , ( R19 . $1 )) );
consider C27 being (FinSequence of (the carrier of (the algebra of R22))) such that L159: ( len C27 ) = ( R1 + 1 ) and L160: (for R21 being (Nat of R1) holds ( C27 . R21 ) = H2(R21)) from SeqLambdaD9;
reconsider D25 = C27 as (Tuple of ( R1 + 1 ) , R22) by L159 , FINSEQ_2:92;
take D25;
thus L161: thesis by L160;
end;
uniqueness
proof
let R24 being (Tuple of ( R1 + 1 ) , R22);
let R25 being (Tuple of ( R1 + 1 ) , R22);
assume that
L162: (for R21 being (Nat of R1) holds ( R24 . R21 ) = ( R22 . (R14 , ( R19 . R21 )) ))
and
L163: (for R21 being (Nat of R1) holds ( R25 . R21 ) = ( R22 . (R14 , ( R19 . R21 )) ));
L164: (for R21 being (Nat of R1) holds ( R24 . R21 ) = ( R25 . R21 ))
proof
let R21 being (Nat of R1);
L165: ( R22 . (R14 , ( R19 . R21 )) ) = ( R24 . R21 ) by L162;
thus L166: thesis by L165 , L163;
end;
thus L167: thesis by L164 , L133;
end;
end;
theorem
L169: (for R1 being (Element of ( NAT )) holds (for R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 ) holds (for R14 being (Point of R13) holds (for R19 being (Tuple of ( R1 + 1 ) , R13) holds (for R22 being (ATLAS of R13) holds (for R24 being (Tuple of ( R1 + 1 ) , R22) holds (( R22 . (R14 , R19) ) = R24 iff ( (R14 , R24) . R22 ) = R19)))))))
proof
let R1 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R14 being (Point of R13);
let R19 being (Tuple of ( R1 + 1 ) , R13);
let R22 being (ATLAS of R13);
let R24 being (Tuple of ( R1 + 1 ) , R22);
thus L170: (( R22 . (R14 , R19) ) = R24 implies ( (R14 , R24) . R22 ) = R19)
proof
assume L171: ( R22 . (R14 , R19) ) = R24;
L172:
now
let R21 being (Nat of R1);
L173: ( R22 . (R14 , ( R19 . R21 )) ) = ( R24 . R21 ) by L171 , L158;
thus L174: ( (R14 , ( R24 . R21 )) . R22 ) = ( R19 . R21 ) by L173 , MIDSP_2:33;
end;
thus L175: thesis by L172 , L147;
end;

thus L176: (( (R14 , R24) . R22 ) = R19 implies ( R22 . (R14 , R19) ) = R24)
proof
assume L177: ( (R14 , R24) . R22 ) = R19;
L178:
now
let R21 being (Nat of R1);
L179: ( (R14 , ( R24 . R21 )) . R22 ) = ( R19 . R21 ) by L177 , L147;
thus L180: ( R22 . (R14 , ( R19 . R21 )) ) = ( R24 . R21 ) by L179 , MIDSP_2:33;
end;
thus L181: thesis by L178 , L158;
end;

end;
theorem
L177: (for R1 being (Element of ( NAT )) holds (for R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 ) holds (for R14 being (Point of R13) holds (for R22 being (ATLAS of R13) holds (for R24 being (Tuple of ( R1 + 1 ) , R22) holds ( R22 . (R14 , ( (R14 , R24) . R22 )) ) = R24))))) by L169;
theorem
L178: (for R1 being (Element of ( NAT )) holds (for R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 ) holds (for R14 being (Point of R13) holds (for R19 being (Tuple of ( R1 + 1 ) , R13) holds (for R22 being (ATLAS of R13) holds ( (R14 , ( R22 . (R14 , R19) )) . R22 ) = R19))))) by L169;
definition
let R1 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R22 being (ATLAS of R13);
let R14 being (Point of R13);
let R24 being (Tuple of ( R1 + 1 ) , R22);
func Phi (R14 , R24) -> (Vector of R22) equals 
( R22 . (R14 , ( *' (R14 , ( (R14 , R24) . R22 )) )) );
coherence;
end;
theorem
L180: (for R1 being (Element of ( NAT )) holds (for R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 ) holds (for R14 being (Point of R13) holds (for R15 being (Point of R13) holds (for R19 being (Tuple of ( R1 + 1 ) , R13) holds (for R22 being (ATLAS of R13) holds (for R23 being (Vector of R22) holds (for R24 being (Tuple of ( R1 + 1 ) , R22) holds ((( R22 . (R14 , R19) ) = R24 & ( R22 . (R14 , R15) ) = R23) implies (( *' (R14 , R19) ) = R15 iff ( Phi (R14 , R24) ) = R23))))))))))
proof
let R1 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R14 being (Point of R13);
let R15 being (Point of R13);
let R19 being (Tuple of ( R1 + 1 ) , R13);
let R22 being (ATLAS of R13);
let R23 being (Vector of R22);
let R24 being (Tuple of ( R1 + 1 ) , R22);
assume that
L181: ( R22 . (R14 , R19) ) = R24
and
L182: ( R22 . (R14 , R15) ) = R23;
L183: ( Phi (R14 , R24) ) = ( R22 . (R14 , ( *' (R14 , R19) )) ) by L181 , L169;
thus L184: thesis by L183 , L182 , MIDSP_2:32;
end;
theorem
L185: (for R1 being (Element of ( NAT )) holds (for R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 ) holds (for R22 being (ATLAS of R13) holds (R13 is  being_invariance iff (for R14 being (Point of R13) holds (for R15 being (Point of R13) holds (for R24 being (Tuple of ( R1 + 1 ) , R22) holds ( Phi (R14 , R24) ) = ( Phi (R15 , R24) ))))))))
proof
let R1 being (Element of ( NAT ));
let R13 being  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 );
let R22 being (ATLAS of R13);
L186: ((for R14 being (Point of R13) holds (for R15 being (Point of R13) holds (for R24 being (Tuple of ( R1 + 1 ) , R22) holds ( Phi (R14 , R24) ) = ( Phi (R15 , R24) )))) implies R13 is  being_invariance)
proof
assume L187: (for R14 being (Point of R13) holds (for R15 being (Point of R13) holds (for R24 being (Tuple of ( R1 + 1 ) , R22) holds ( Phi (R14 , R24) ) = ( Phi (R15 , R24) ))));
let R14 being (Point of R13);
let R15 being (Point of R13);
let R19 being (Tuple of ( R1 + 1 ) , R13);
let R20 being (Tuple of ( R1 + 1 ) , R13);
L188: ( R22 . (R14 , ( *' (R14 , ( (R14 , ( R22 . (R14 , R19) )) . R22 )) )) ) = ( Phi (R14 , ( R22 . (R14 , R19) )) )
.= ( Phi (R15 , ( R22 . (R14 , R19) )) ) by L187
.= ( R22 . (R15 , ( *' (R15 , ( (R15 , ( R22 . (R14 , R19) )) . R22 )) )) );
assume L189: (for R21 being (Nat of R1) holds ( R14 @ ( R20 . R21 ) ) = ( R15 @ ( R19 . R21 ) ));
L190:
now
let R21 being (Nat of R1);
L191: ( R14 @ ( R20 . R21 ) ) = ( R15 @ ( R19 . R21 ) ) by L189;
L192: ( R22 . (R14 , ( R19 . R21 )) ) = ( R22 . (R15 , ( R20 . R21 )) ) by L191 , MIDSP_2:33;
thus L193: ( ( R22 . (R14 , R19) ) . R21 ) = ( R22 . (R14 , ( R19 . R21 )) ) by L158
.= ( ( R22 . (R15 , R20) ) . R21 ) by L192 , L158;
end;
L194: ( R22 . (R14 , ( *' (R14 , R19) )) ) = ( R22 . (R14 , ( *' (R14 , ( (R14 , ( R22 . (R14 , R19) )) . R22 )) )) ) by L169
.= ( R22 . (R15 , ( *' (R15 , ( (R15 , ( R22 . (R15 , R20) )) . R22 )) )) ) by L190 , L188 , L133
.= ( R22 . (R15 , ( *' (R15 , R20) )) ) by L169;
thus L195: thesis by L194 , MIDSP_2:33;
end;
L196:
now
assume L197: R13 is  being_invariance;
let R14 being (Point of R13);
let R15 being (Point of R13);
let R24 being (Tuple of ( R1 + 1 ) , R22);
set D26 = ( (R14 , R24) . R22 );
set D27 = ( (R15 , R24) . R22 );
L198: ( R22 . (R14 , D26) ) = R24 by L169
.= ( R22 . (R15 , D27) ) by L169;
L199:
now
let R21 being (Nat of R1);
L200: ( R22 . (R14 , ( D26 . R21 )) ) = ( ( R22 . (R14 , D26) ) . R21 ) by L158
.= ( R22 . (R15 , ( D27 . R21 )) ) by L198 , L158;
thus L201: ( R14 @ ( D27 . R21 ) ) = ( R15 @ ( D26 . R21 ) ) by L200 , MIDSP_2:33;
end;
L202: ( R14 @ ( *' (R15 , D27) ) ) = ( R15 @ ( *' (R14 , D26) ) ) by L199 , L197 , L97;
thus L203: ( Phi (R14 , R24) ) = ( Phi (R15 , R24) ) by L202 , MIDSP_2:33;
end;
thus L204: thesis by L196 , L186;
end;
theorem
L205: (for R1 being (Element of ( NAT )) holds 1 in ( Seg ( R1 + 1 ) ))
proof
let R1 being (Element of ( NAT ));
L206: ( 0 ) <= R1 by NAT_1:2;
L207: ( ( 0 ) + 1 ) <= ( R1 + 1 ) by L206 , XREAL_1:7;
thus L208: thesis by L207 , FINSEQ_1:1;
end;
theorem
L209: (for R1 being (Element of ( NAT )) holds 1 is (Nat of R1))
proof
let R1 being (Element of ( NAT ));
L210: 1 in ( Seg ( R1 + 1 ) ) by L205;
thus L211: thesis by L210 , L73;
end;
begin
definition
let R1 being (Element of ( NAT ));
mode ReperAlgebra of R1
 ->  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 )
means :L212: it is  being_invariance;
existence
proof
reconsider D28 = 1 as (Nat of ( R1 + 1 )) by L209;
set D29 = the MidSp;
set D30 = (the carrier of D29);
set D31 = ( ( R1 + 1 ) + 1 );
set D32 = ( D31 -tuples_on D30 );
deffunc H3((Element of D32)) = ( $1 . D28 );
consider C28 being (Function of D32 , D30) such that L213: (for B19 being (Element of D32) holds ( C28 . B19 ) = H3(B19)) from FUNCT_2:sch 4;
reconsider D33 = C28 as (Function of ( ( R1 + 2 ) -tuples_on D30 ) , D30);
reconsider D34 = ReperAlgebraStr (# (the carrier of D29) , (the MIDPOINT of D29) , D33 #) as  MidSp-like non  empty ReperAlgebraStr over ( R1 + 2 ) by L53;
take D34;
L214: (for B20 , B21 being (Point of D34) holds (for B22 , B23 being (Tuple of ( R1 + 1 ) , D34) holds ((for R21 being (Nat of R1) holds ( B20 @ ( B23 . R21 ) ) = ( B21 @ ( B22 . R21 ) )) implies ( B20 @ ( *' (B21 , B23) ) ) = ( B21 @ ( *' (B20 , B22) ) ))))
proof
let C29 , C30 being (Point of D34);
let C31 , C32 being (Tuple of ( R1 + 1 ) , D34);
assume that
L215: (for R21 being (Nat of R1) holds ( C29 @ ( C32 . R21 ) ) = ( C30 @ ( C31 . R21 ) ));
L216: ( *' (C29 , C31) ) = ( ( <* C29 *> ^ C31 ) . D28 ) by L213
.= C29 by FINSEQ_1:41;
L217: ( *' (C30 , C32) ) = ( ( <* C30 *> ^ C32 ) . D28 ) by L213
.= C30 by FINSEQ_1:41;
thus L218: thesis by L217 , L216;
end;
thus L219: thesis by L214 , L97;
end;
end;
theorem
L221: (for R1 being (Element of ( NAT )) holds (for R26 being (ReperAlgebra of R1) holds (for R27 being (Point of R26) holds (for R28 being (Point of R26) holds (for R33 being (ATLAS of R26) holds (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ( Phi (R27 , R35) ) = ( Phi (R28 , R35) )))))))
proof
let R1 being (Element of ( NAT ));
let R26 being (ReperAlgebra of R1);
let R27 being (Point of R26);
let R28 being (Point of R26);
let R33 being (ATLAS of R26);
let R35 being (Tuple of ( R1 + 1 ) , R33);
L222: R26 is  being_invariance by L212;
thus L223: thesis by L222 , L185;
end;
definition
let R1 being (Element of ( NAT ));
let R26 being (ReperAlgebra of R1);
let R33 being (ATLAS of R26);
let R35 being (Tuple of ( R1 + 1 ) , R33);
func Phi R35 -> (Vector of R33) means 
:L224: (for R27 being (Point of R26) holds it = ( Phi (R27 , R35) ));
existence
proof
set D35 = the (Point of R26);
take ( Phi (D35 , R35) );
thus L225: thesis by L221;
end;
uniqueness
proof
set D36 = the (Point of R26);
let C33 , C34 being (Vector of R33);
assume that
L226: (for R27 being (Point of R26) holds C33 = ( Phi (R27 , R35) ))
and
L227: (for R27 being (Point of R26) holds C34 = ( Phi (R27 , R35) ));
L228: C33 = ( Phi (D36 , R35) ) by L226;
thus L229: thesis by L228 , L227;
end;
end;
L231: (for R1 being (Element of ( NAT )) holds (for R26 being (ReperAlgebra of R1) holds (for R27 being (Point of R26) holds (for R32 being (Tuple of ( R1 + 1 ) , R26) holds (for R33 being (ATLAS of R26) holds (for R35 being (Tuple of ( R1 + 1 ) , R33) holds (( R33 . (R27 , R32) ) = R35 implies ( Phi R35 ) = ( R33 . (R27 , ( *' (R27 , R32) )) ))))))))
proof
let R1 being (Element of ( NAT ));
let R26 being (ReperAlgebra of R1);
let R27 being (Point of R26);
let R32 being (Tuple of ( R1 + 1 ) , R26);
let R33 being (ATLAS of R26);
let R35 being (Tuple of ( R1 + 1 ) , R33);
assume L232: ( R33 . (R27 , R32) ) = R35;
thus L233: ( Phi R35 ) = ( Phi (R27 , R35) ) by L224
.= ( R33 . (R27 , ( *' (R27 , R32) )) ) by L232 , L169;
end;
L234: (for R1 being (Element of ( NAT )) holds (for R26 being (ReperAlgebra of R1) holds (for R27 being (Point of R26) holds (for R32 being (Tuple of ( R1 + 1 ) , R26) holds (for R33 being (ATLAS of R26) holds (for R35 being (Tuple of ( R1 + 1 ) , R33) holds (( (R27 , R35) . R33 ) = R32 implies ( Phi R35 ) = ( R33 . (R27 , ( *' (R27 , R32) )) ))))))))
proof
let R1 being (Element of ( NAT ));
let R26 being (ReperAlgebra of R1);
let R27 being (Point of R26);
let R32 being (Tuple of ( R1 + 1 ) , R26);
let R33 being (ATLAS of R26);
let R35 being (Tuple of ( R1 + 1 ) , R33);
assume L235: ( (R27 , R35) . R33 ) = R32;
L236: ( R33 . (R27 , R32) ) = R35 by L235 , L169;
thus L237: thesis by L236 , L231;
end;
theorem
L238: (for R1 being (Element of ( NAT )) holds (for R26 being (ReperAlgebra of R1) holds (for R27 being (Point of R26) holds (for R28 being (Point of R26) holds (for R32 being (Tuple of ( R1 + 1 ) , R26) holds (for R33 being (ATLAS of R26) holds (for R34 being (Vector of R33) holds (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ((( R33 . (R27 , R32) ) = R35 & ( R33 . (R27 , R28) ) = R34 & ( Phi R35 ) = R34) implies ( *' (R27 , R32) ) = R28)))))))))
proof
let R1 being (Element of ( NAT ));
let R26 being (ReperAlgebra of R1);
let R27 being (Point of R26);
let R28 being (Point of R26);
let R32 being (Tuple of ( R1 + 1 ) , R26);
let R33 being (ATLAS of R26);
let R34 being (Vector of R33);
let R35 being (Tuple of ( R1 + 1 ) , R33);
assume L239: (( R33 . (R27 , R32) ) = R35 & ( R33 . (R27 , R28) ) = R34 & ( Phi R35 ) = R34);
L240: ( Phi R35 ) = ( Phi (R27 , R35) ) by L224;
thus L241: thesis by L240 , L239 , L180;
end;
theorem
L242: (for R1 being (Element of ( NAT )) holds (for R26 being (ReperAlgebra of R1) holds (for R27 being (Point of R26) holds (for R28 being (Point of R26) holds (for R32 being (Tuple of ( R1 + 1 ) , R26) holds (for R33 being (ATLAS of R26) holds (for R34 being (Vector of R33) holds (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ((( (R27 , R35) . R33 ) = R32 & ( (R27 , R34) . R33 ) = R28 & ( *' (R27 , R32) ) = R28) implies ( Phi R35 ) = R34)))))))))
proof
let R1 being (Element of ( NAT ));
let R26 being (ReperAlgebra of R1);
let R27 being (Point of R26);
let R28 being (Point of R26);
let R32 being (Tuple of ( R1 + 1 ) , R26);
let R33 being (ATLAS of R26);
let R34 being (Vector of R33);
let R35 being (Tuple of ( R1 + 1 ) , R33);
assume L243: (( (R27 , R35) . R33 ) = R32 & ( (R27 , R34) . R33 ) = R28 & ( *' (R27 , R32) ) = R28);
L244: ( Phi (R27 , R35) ) = R34 by L243 , MIDSP_2:33;
thus L245: thesis by L244 , L224;
end;
theorem
L246: (for R1 being (Element of ( NAT )) holds (for R21 being (Nat of R1) holds (for R26 being (ReperAlgebra of R1) holds (for R27 being (Point of R26) holds (for R28 being (Point of R26) holds (for R32 being (Tuple of ( R1 + 1 ) , R26) holds (for R33 being (ATLAS of R26) holds (for R34 being (Vector of R33) holds (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ((( R33 . (R27 , R32) ) = R35 & ( R33 . (R27 , R28) ) = R34) implies ( R33 . (R27 , ( R32 +* (R21 , R28) )) ) = ( R35 +* (R21 , R34) )))))))))))
proof
let R1 being (Element of ( NAT ));
let R21 being (Nat of R1);
let R26 being (ReperAlgebra of R1);
let R27 being (Point of R26);
let R28 being (Point of R26);
let R32 being (Tuple of ( R1 + 1 ) , R26);
let R33 being (ATLAS of R26);
let R34 being (Vector of R33);
let R35 being (Tuple of ( R1 + 1 ) , R33);
assume that
L247: ( R33 . (R27 , R32) ) = R35
and
L248: ( R33 . (R27 , R28) ) = R34;
set D37 = ( R32 +* (R21 , R28) );
set D38 = ( R33 . (R27 , D37) );
set D39 = ( R35 +* (R21 , R34) );
L249: (for B24 being (Nat of R1) holds ( D38 . B24 ) = ( D39 . B24 ))
proof
let C35 being (Nat of R1);
L250:
now
per cases ;
suppose L251: C35 = R21;

thus L252: ( D38 . C35 ) = ( R33 . (R27 , ( D37 . C35 )) ) by L158
.= ( R33 . (R27 , R28) ) by L251 , L88
.= ( D39 . C35 ) by L248 , L251 , L127;
end;
suppose L253: C35 <> R21;

thus L254: ( D38 . C35 ) = ( R33 . (R27 , ( D37 . C35 )) ) by L158
.= ( R33 . (R27 , ( R32 . C35 )) ) by L253 , FUNCT_7:32
.= ( R35 . C35 ) by L247 , L158
.= ( D39 . C35 ) by L253 , FUNCT_7:32;
end;
end;
thus L256: thesis by L250;
end;
thus L257: thesis by L249 , L133;
end;
theorem
L258: (for R1 being (Element of ( NAT )) holds (for R21 being (Nat of R1) holds (for R26 being (ReperAlgebra of R1) holds (for R27 being (Point of R26) holds (for R28 being (Point of R26) holds (for R32 being (Tuple of ( R1 + 1 ) , R26) holds (for R33 being (ATLAS of R26) holds (for R34 being (Vector of R33) holds (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ((( (R27 , R35) . R33 ) = R32 & ( (R27 , R34) . R33 ) = R28) implies ( (R27 , ( R35 +* (R21 , R34) )) . R33 ) = ( R32 +* (R21 , R28) )))))))))))
proof
let R1 being (Element of ( NAT ));
let R21 being (Nat of R1);
let R26 being (ReperAlgebra of R1);
let R27 being (Point of R26);
let R28 being (Point of R26);
let R32 being (Tuple of ( R1 + 1 ) , R26);
let R33 being (ATLAS of R26);
let R34 being (Vector of R33);
let R35 being (Tuple of ( R1 + 1 ) , R33);
assume L259: (( (R27 , R35) . R33 ) = R32 & ( (R27 , R34) . R33 ) = R28);
L260: (( R33 . (R27 , R32) ) = R35 & ( R33 . (R27 , R28) ) = R34) by L259 , L169 , MIDSP_2:33;
L261: ( R33 . (R27 , ( R32 +* (R21 , R28) )) ) = ( R35 +* (R21 , R34) ) by L260 , L246;
thus L262: thesis by L261 , L169;
end;
theorem
L263: (for R1 being (Element of ( NAT )) holds (for R21 being (Nat of R1) holds (for R26 being (ReperAlgebra of R1) holds (for R33 being (ATLAS of R26) holds (R26 has_property_of_zero_in R21 iff (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ( Phi ( R35 +* (R21 , ( 0. R33 )) ) ) = ( 0. R33 )))))))
proof
let R1 being (Element of ( NAT ));
let R21 being (Nat of R1);
let R26 being (ReperAlgebra of R1);
let R33 being (ATLAS of R26);
thus L264: (R26 has_property_of_zero_in R21 implies (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ( Phi ( R35 +* (R21 , ( 0. R33 )) ) ) = ( 0. R33 )))
proof
set D40 = the (Point of R26);
assume L265: R26 has_property_of_zero_in R21;
set D41 = ( (D40 , ( 0. R33 )) . R33 );
let R35 being (Tuple of ( R1 + 1 ) , R33);
set D42 = ( ( (D40 , R35) . R33 ) +* (R21 , D40) );
L266: D41 = D40 by MIDSP_2:34;
L267: ( (D40 , ( R35 +* (R21 , ( 0. R33 )) )) . R33 ) = D42 by L266 , L258;
L268: ( *' (D40 , D42) ) = D41 by L265 , L266 , L101;
thus L269: thesis by L268 , L267 , L242;
end;

thus L270: ((for R35 being (Tuple of ( R1 + 1 ) , R33) holds ( Phi ( R35 +* (R21 , ( 0. R33 )) ) ) = ( 0. R33 )) implies R26 has_property_of_zero_in R21)
proof
assume L271: (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ( Phi ( R35 +* (R21 , ( 0. R33 )) ) ) = ( 0. R33 ));
L272: (for R27 being (Point of R26) holds (for R32 being (Tuple of ( R1 + 1 ) , R26) holds ( *' (R27 , ( R32 +* (R21 , R27) )) ) = R27))
proof
let R27 being (Point of R26);
let R32 being (Tuple of ( R1 + 1 ) , R26);
set D43 = ( R33 . (R27 , R27) );
set D44 = ( ( R33 . (R27 , R32) ) +* (R21 , ( 0. R33 )) );
L273: D43 = ( 0. R33 ) by MIDSP_2:33;
L274: (( R33 . (R27 , ( R32 +* (R21 , R27) )) ) = D44 & ( Phi D44 ) = D43) by L273 , L271 , L246;
thus L275: thesis by L274 , L238;
end;
thus L276: thesis by L272 , L101;
end;

end;
theorem
L271: (for R1 being (Element of ( NAT )) holds (for R21 being (Nat of R1) holds (for R26 being (ReperAlgebra of R1) holds (for R33 being (ATLAS of R26) holds (R26 is_semi_additive_in R21 iff (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ( Phi ( R35 +* (R21 , ( Double ( R35 . R21 ) )) ) ) = ( Double ( Phi R35 ) )))))))
proof
let R1 being (Element of ( NAT ));
let R21 being (Nat of R1);
let R26 being (ReperAlgebra of R1);
let R33 being (ATLAS of R26);
thus L272: (R26 is_semi_additive_in R21 implies (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ( Phi ( R35 +* (R21 , ( Double ( R35 . R21 ) )) ) ) = ( Double ( Phi R35 ) )))
proof
set D45 = the (Point of R26);
assume L273: R26 is_semi_additive_in R21;
let R35 being (Tuple of ( R1 + 1 ) , R33);
set D46 = ( R35 +* (R21 , ( Double ( R35 . R21 ) )) );
set D47 = ( (D45 , R35) . R33 );
set D48 = ( (D45 , D46) . R33 );
set D49 = ( D48 +* (R21 , ( D45 @ ( D48 . R21 ) )) );
L274: (for B25 being (Nat of R1) holds ( D47 . B25 ) = ( D49 . B25 ))
proof
let C36 being (Nat of R1);
L275:
now
per cases ;
suppose L276: C36 = R21;

L277: ( R33 . (D45 , D47) ) = R35 by L169;
L278: ( R33 . (D45 , ( D47 . R21 )) ) = ( R35 . R21 ) by L277 , L158;
L279: ( R33 . (D45 , D48) ) = D46 by L169;
L280: ( R33 . (D45 , ( D48 . R21 )) ) = ( D46 . R21 ) by L279 , L158;
L281: ( D46 . R21 ) = ( Double ( R35 . R21 ) ) by L127;
L282: ( D47 . R21 ) = ( D45 @ ( D48 . R21 ) ) by L281 , L278 , L280 , MIDSP_2:31
.= ( D49 . R21 ) by L88;
thus L283: thesis by L282 , L276;
end;
suppose L284: C36 <> R21;

thus L285: ( D47 . C36 ) = ( (D45 , ( R35 . C36 )) . R33 ) by L147
.= ( (D45 , ( D46 . C36 )) . R33 ) by L284 , FUNCT_7:32
.= ( D48 . C36 ) by L147
.= ( D49 . C36 ) by L284 , FUNCT_7:32;
end;
end;
thus L287: thesis by L275;
end;
L288: D47 = D49 by L274 , L81;
L289: ( *' (D45 , D47) ) = ( D45 @ ( *' (D45 , D48) ) ) by L288 , L273 , L103;
L290: ( R33 . (D45 , ( *' (D45 , D48) )) ) = ( Double ( R33 . (D45 , ( *' (D45 , D47) )) ) ) by L289 , MIDSP_2:31;
L291: ( Phi D46 ) = ( R33 . (D45 , ( *' (D45 , D48) )) ) by L234;
thus L292: thesis by L291 , L290 , L234;
end;

thus L293: ((for R35 being (Tuple of ( R1 + 1 ) , R33) holds ( Phi ( R35 +* (R21 , ( Double ( R35 . R21 ) )) ) ) = ( Double ( Phi R35 ) )) implies R26 is_semi_additive_in R21)
proof
assume L294: (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ( Phi ( R35 +* (R21 , ( Double ( R35 . R21 ) )) ) ) = ( Double ( Phi R35 ) ));
let R27 being (Point of R26);
let C37 being (Point of R26);
let C38 being (Tuple of ( R1 + 1 ) , R26);
assume that
L295: ( C38 . R21 ) = C37;
set D50 = ( C38 +* (R21 , ( R27 @ ( C38 . R21 ) )) );
set D51 = ( R33 . (R27 , D50) );
set D52 = ( D51 +* (R21 , ( Double ( D51 . R21 ) )) );
L296: ( R33 . (R27 , C38) ) = D52
proof
set D53 = ( R33 . (R27 , C38) );
L297: (for B26 being (Nat of R1) holds ( D52 . B26 ) = ( D53 . B26 ))
proof
let C39 being (Nat of R1);
L298:
now
per cases ;
suppose L299: C39 = R21;

L300: (( R33 . (R27 , ( D50 . R21 )) ) = ( D51 . R21 ) & ( D50 . R21 ) = ( R27 @ ( C38 . R21 ) )) by L158 , L88;
L301: (( D52 . R21 ) = ( Double ( D51 . R21 ) ) & ( R33 . (R27 , ( C38 . R21 )) ) = ( D53 . R21 )) by L158 , L127;
thus L302: thesis by L301 , L299 , L300 , MIDSP_2:31;
end;
suppose L303: C39 <> R21;

thus L304: ( D52 . C39 ) = ( D51 . C39 ) by L303 , FUNCT_7:32
.= ( R33 . (R27 , ( D50 . C39 )) ) by L158
.= ( R33 . (R27 , ( C38 . C39 )) ) by L303 , FUNCT_7:32
.= ( D53 . C39 ) by L158;
end;
end;
thus L306: thesis by L298;
end;
thus L307: thesis by L297 , L133;
end;
L308: ( Phi D52 ) = ( R33 . (R27 , ( *' (R27 , C38) )) ) by L296 , L231;
L309: ( Phi D51 ) = ( R33 . (R27 , ( *' (R27 , D50) )) ) by L231;
L310: ( R33 . (R27 , ( *' (R27 , C38) )) ) = ( Double ( R33 . (R27 , ( *' (R27 , D50) )) ) ) by L309 , L294 , L308;
thus L311: thesis by L310 , L295 , MIDSP_2:31;
end;

end;
theorem
L294: (for R1 being (Element of ( NAT )) holds (for R21 being (Nat of R1) holds (for R26 being (ReperAlgebra of R1) holds ((R26 has_property_of_zero_in R21 & R26 is_additive_in R21) implies R26 is_semi_additive_in R21))))
proof
let R1 being (Element of ( NAT ));
let R21 being (Nat of R1);
let R26 being (ReperAlgebra of R1);
assume that
L295: R26 has_property_of_zero_in R21
and
L296: R26 is_additive_in R21;
let R27 being (Point of R26);
let R29 being (Point of R26);
let R32 being (Tuple of ( R1 + 1 ) , R26);
assume L297: ( R32 . R21 ) = R29;
L298: ( *' (R27 , ( R32 +* (R21 , ( R27 @ R29 )) )) ) = ( ( *' (R27 , R32) ) @ ( *' (R27 , ( R32 +* (R21 , R27) )) ) ) by L297 , L296 , L121
.= ( R27 @ ( *' (R27 , R32) ) ) by L295 , L101;
thus L299: thesis by L298;
end;
L300: (for R1 being (Element of ( NAT )) holds (for R21 being (Nat of R1) holds (for R26 being (ReperAlgebra of R1) holds (for R33 being (ATLAS of R26) holds (R26 is_semi_additive_in R21 implies (for R27 being (Point of R26) holds (for R30 being (Point of R26) holds (for R31 being (Point of R26) holds (for R32 being (Tuple of ( R1 + 1 ) , R26) holds (( R27 @ R31 ) = ( ( R32 . R21 ) @ R30 ) implies (( *' (R27 , ( R32 +* (R21 , ( ( R32 . R21 ) @ R30 )) )) ) = ( ( *' (R27 , R32) ) @ ( *' (R27 , ( R32 +* (R21 , R30) )) ) ) iff ( R33 . (R27 , ( *' (R27 , ( R32 +* (R21 , R31) )) )) ) = ( ( R33 . (R27 , ( *' (R27 , R32) )) ) + ( R33 . (R27 , ( *' (R27 , ( R32 +* (R21 , R30) )) )) ) ))))))))))))
proof
let R1 being (Element of ( NAT ));
let R21 being (Nat of R1);
let R26 being (ReperAlgebra of R1);
let R33 being (ATLAS of R26);
assume L301: R26 is_semi_additive_in R21;
let R27 being (Point of R26);
let R30 being (Point of R26);
let R31 being (Point of R26);
let R32 being (Tuple of ( R1 + 1 ) , R26);
assume L302: ( R27 @ R31 ) = ( ( R32 . R21 ) @ R30 );
L303: ( *' (R27 , ( R32 +* (R21 , ( ( R32 . R21 ) @ R30 )) )) ) = ( R27 @ ( *' (R27 , ( R32 +* (R21 , R31) )) ) ) by L302 , L301 , L105;
thus L304: thesis by L303 , MIDSP_2:30;
end;
L305: (for R1 being (Element of ( NAT )) holds (for R21 being (Nat of R1) holds (for R26 being (ReperAlgebra of R1) holds (for R33 being (ATLAS of R26) holds ((for R35 being (Tuple of ( R1 + 1 ) , R33) holds (for R34 being (Vector of R33) holds ( Phi ( R35 +* (R21 , ( ( R35 . R21 ) + R34 )) ) ) = ( ( Phi R35 ) + ( Phi ( R35 +* (R21 , R34) ) ) ))) implies R26 is_semi_additive_in R21)))))
proof
let R1 being (Element of ( NAT ));
let R21 being (Nat of R1);
let R26 being (ReperAlgebra of R1);
let R33 being (ATLAS of R26);
assume L306: (for R35 being (Tuple of ( R1 + 1 ) , R33) holds (for R34 being (Vector of R33) holds ( Phi ( R35 +* (R21 , ( ( R35 . R21 ) + R34 )) ) ) = ( ( Phi R35 ) + ( Phi ( R35 +* (R21 , R34) ) ) )));
L307: (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ( Phi ( R35 +* (R21 , ( Double ( R35 . R21 ) )) ) ) = ( Double ( Phi R35 ) ))
proof
let R35 being (Tuple of ( R1 + 1 ) , R33);
set D54 = ( R35 . R21 );
set D55 = ( R35 +* (R21 , D54) );
L308: (for B27 being (Nat of R1) holds ( D55 . B27 ) = ( R35 . B27 ))
proof
let C40 being (Nat of R1);
L309:
now
per cases ;
suppose L310: C40 = R21;

thus L311: thesis by L310 , L127;
end;
suppose L312: C40 <> R21;

thus L313: thesis by L312 , FUNCT_7:32;
end;
end;
thus L315: thesis by L309;
end;
L316: D55 = R35 by L308 , L133;
thus L317: ( Phi ( R35 +* (R21 , ( Double D54 )) ) ) = ( Phi ( R35 +* (R21 , ( D54 + D54 )) ) ) by MIDSP_2:def 1
.= ( ( Phi R35 ) + ( Phi ( R35 +* (R21 , D54) ) ) ) by L306
.= ( Double ( Phi R35 ) ) by L316 , MIDSP_2:def 1;
end;
thus L318: thesis by L307 , L271;
end;
theorem
L319: (for R1 being (Element of ( NAT )) holds (for R21 being (Nat of R1) holds (for R26 being (ReperAlgebra of R1) holds (for R33 being (ATLAS of R26) holds (R26 has_property_of_zero_in R21 implies (R26 is_additive_in R21 iff (for R35 being (Tuple of ( R1 + 1 ) , R33) holds (for R34 being (Vector of R33) holds ( Phi ( R35 +* (R21 , ( ( R35 . R21 ) + R34 )) ) ) = ( ( Phi R35 ) + ( Phi ( R35 +* (R21 , R34) ) ) )))))))))
proof
let R1 being (Element of ( NAT ));
let R21 being (Nat of R1);
let R26 being (ReperAlgebra of R1);
let R33 being (ATLAS of R26);
assume L320: R26 has_property_of_zero_in R21;
thus L321: (R26 is_additive_in R21 implies (for R35 being (Tuple of ( R1 + 1 ) , R33) holds (for R34 being (Vector of R33) holds ( Phi ( R35 +* (R21 , ( ( R35 . R21 ) + R34 )) ) ) = ( ( Phi R35 ) + ( Phi ( R35 +* (R21 , R34) ) ) ))))
proof
set D56 = the (Point of R26);
assume L322: R26 is_additive_in R21;
let R35 being (Tuple of ( R1 + 1 ) , R33);
let R34 being (Vector of R33);
set D57 = ( (D56 , R35) . R33 );
set D58 = ( (D56 , R34) . R33 );
consider R31 being (Point of R26) such that L323: ( R31 @ D56 ) = ( ( D57 . R21 ) @ D58 ) by MIDSP_1:def 3;
L324: (( R33 . (D56 , D57) ) = R35 & ( R33 . (D56 , D58) ) = R34) by L169 , MIDSP_2:33;
L325: ( R33 . (D56 , R31) ) = ( ( R33 . (D56 , ( D57 . R21 )) ) + ( R33 . (D56 , D58) ) ) by L323 , MIDSP_2:30
.= ( ( R35 . R21 ) + R34 ) by L324 , L158;
L326: ( D57 +* (R21 , R31) ) = ( (D56 , ( R35 +* (R21 , ( ( R35 . R21 ) + R34 )) )) . R33 )
proof
set D59 = ( D57 +* (R21 , R31) );
set D60 = ( R35 +* (R21 , ( ( R35 . R21 ) + R34 )) );
set D61 = ( (D56 , D60) . R33 );
L327: (for B28 being (Nat of R1) holds ( D59 . B28 ) = ( D61 . B28 ))
proof
let C41 being (Nat of R1);
per cases ;
suppose L328: C41 = R21;

thus L329: ( D59 . C41 ) = R31 by L328 , L88
.= ( (D56 , ( ( R35 . R21 ) + R34 )) . R33 ) by L325 , MIDSP_2:33
.= ( (D56 , ( D60 . R21 )) . R33 ) by L127
.= ( D61 . C41 ) by L328 , L147;
end;
suppose L330: C41 <> R21;

thus L331: ( D59 . C41 ) = ( D57 . C41 ) by L330 , FUNCT_7:32
.= ( (D56 , ( R35 . C41 )) . R33 ) by L147
.= ( (D56 , ( D60 . C41 )) . R33 ) by L330 , FUNCT_7:32
.= ( D61 . C41 ) by L147;
end;
end;
thus L333: thesis by L327 , L81;
end;
L334: ( Phi ( R35 +* (R21 , ( ( R35 . R21 ) + R34 )) ) ) = ( R33 . (D56 , ( *' (D56 , ( D57 +* (R21 , R31) )) )) ) by L326 , L234;
L335: ( D57 +* (R21 , D58) ) = ( (D56 , ( R35 +* (R21 , R34) )) . R33 )
proof
set D62 = ( D57 +* (R21 , D58) );
set D63 = ( (D56 , ( R35 +* (R21 , R34) )) . R33 );
L336: (for B29 being (Nat of R1) holds ( D62 . B29 ) = ( D63 . B29 ))
proof
let C42 being (Nat of R1);
per cases ;
suppose L337: C42 = R21;

thus L338: ( D62 . C42 ) = D58 by L337 , L88
.= ( (D56 , ( ( R35 +* (R21 , R34) ) . R21 )) . R33 ) by L127
.= ( D63 . C42 ) by L337 , L147;
end;
suppose L339: C42 <> R21;

thus L340: ( D62 . C42 ) = ( D57 . C42 ) by L339 , FUNCT_7:32
.= ( (D56 , ( R35 . C42 )) . R33 ) by L147
.= ( (D56 , ( ( R35 +* (R21 , R34) ) . C42 )) . R33 ) by L339 , FUNCT_7:32
.= ( D63 . C42 ) by L147;
end;
end;
thus L342: thesis by L336 , L81;
end;
L343: (R26 is_semi_additive_in R21 & ( *' (D56 , ( D57 +* (R21 , ( ( D57 . R21 ) @ D58 )) )) ) = ( ( *' (D56 , D57) ) @ ( *' (D56 , ( D57 +* (R21 , D58) )) ) )) by L320 , L322 , L121 , L294;
L344: ( R33 . (D56 , ( *' (D56 , ( D57 +* (R21 , R31) )) )) ) = ( ( R33 . (D56 , ( *' (D56 , D57) )) ) + ( R33 . (D56 , ( *' (D56 , ( D57 +* (R21 , D58) )) )) ) ) by L343 , L323 , L300;
L345: ( Phi R35 ) = ( R33 . (D56 , ( *' (D56 , D57) )) ) by L234;
thus L346: thesis by L345 , L344 , L334 , L335 , L234;
end;

thus L347: ((for R35 being (Tuple of ( R1 + 1 ) , R33) holds (for R34 being (Vector of R33) holds ( Phi ( R35 +* (R21 , ( ( R35 . R21 ) + R34 )) ) ) = ( ( Phi R35 ) + ( Phi ( R35 +* (R21 , R34) ) ) ))) implies R26 is_additive_in R21)
proof
assume L348: (for R35 being (Tuple of ( R1 + 1 ) , R33) holds (for R34 being (Vector of R33) holds ( Phi ( R35 +* (R21 , ( ( R35 . R21 ) + R34 )) ) ) = ( ( Phi R35 ) + ( Phi ( R35 +* (R21 , R34) ) ) )));
L349: R26 is_semi_additive_in R21 by L348 , L305;
L350: (for R27 being (Point of R26) holds (for R29 being (Point of R26) holds (for R30 being (Point of R26) holds (for R32 being (Tuple of ( R1 + 1 ) , R26) holds (( R32 . R21 ) = R29 implies ( *' (R27 , ( R32 +* (R21 , ( R29 @ R30 )) )) ) = ( ( *' (R27 , R32) ) @ ( *' (R27 , ( R32 +* (R21 , R30) )) ) ))))))
proof
let R27 being (Point of R26);
let R29 being (Point of R26);
let R30 being (Point of R26);
let R32 being (Tuple of ( R1 + 1 ) , R26);
assume that
L351: ( R32 . R21 ) = R29;
set D64 = ( R33 . (R27 , R32) );
set D65 = ( R33 . (R27 , R30) );
consider R31 being (Point of R26) such that L352: ( R31 @ R27 ) = ( ( R32 . R21 ) @ R30 ) by MIDSP_1:def 3;
L353: ( (R27 , D64) . R33 ) = R32 by L169;
L354: ( R33 . (R27 , R31) ) = ( ( R33 . (R27 , ( R32 . R21 )) ) + ( R33 . (R27 , R30) ) ) by L352 , MIDSP_2:30
.= ( ( D64 . R21 ) + D65 ) by L158;
L355: ( R32 +* (R21 , R31) ) = ( (R27 , ( D64 +* (R21 , ( ( D64 . R21 ) + D65 )) )) . R33 )
proof
set D66 = ( R32 +* (R21 , R31) );
set D67 = ( D64 +* (R21 , ( ( D64 . R21 ) + D65 )) );
set D68 = ( (R27 , D67) . R33 );
L356: (for B30 being (Nat of R1) holds ( D66 . B30 ) = ( D68 . B30 ))
proof
let C43 being (Nat of R1);
per cases ;
suppose L357: C43 = R21;

thus L358: ( D66 . C43 ) = R31 by L357 , L88
.= ( (R27 , ( ( D64 . R21 ) + D65 )) . R33 ) by L354 , MIDSP_2:33
.= ( (R27 , ( D67 . R21 )) . R33 ) by L127
.= ( D68 . C43 ) by L357 , L147;
end;
suppose L359: C43 <> R21;

thus L360: ( D66 . C43 ) = ( R32 . C43 ) by L359 , FUNCT_7:32
.= ( (R27 , ( D64 . C43 )) . R33 ) by L353 , L147
.= ( (R27 , ( D67 . C43 )) . R33 ) by L359 , FUNCT_7:32
.= ( D68 . C43 ) by L147;
end;
end;
thus L362: thesis by L356 , L81;
end;
L363: ( Phi ( D64 +* (R21 , ( ( D64 . R21 ) + D65 )) ) ) = ( R33 . (R27 , ( *' (R27 , ( R32 +* (R21 , R31) )) )) ) by L355 , L234;
L364: ( (R27 , D65) . R33 ) = R30 by MIDSP_2:33;
L365: ( R32 +* (R21 , R30) ) = ( (R27 , ( D64 +* (R21 , D65) )) . R33 )
proof
set D69 = ( R32 +* (R21 , R30) );
set D70 = ( (R27 , ( D64 +* (R21 , D65) )) . R33 );
L366: (for B31 being (Nat of R1) holds ( D69 . B31 ) = ( D70 . B31 ))
proof
let C44 being (Nat of R1);
per cases ;
suppose L367: C44 = R21;

thus L368: ( D69 . C44 ) = R30 by L367 , L88
.= ( (R27 , ( ( D64 +* (R21 , D65) ) . R21 )) . R33 ) by L364 , L127
.= ( D70 . C44 ) by L367 , L147;
end;
suppose L369: C44 <> R21;

thus L370: ( D69 . C44 ) = ( R32 . C44 ) by L369 , FUNCT_7:32
.= ( (R27 , ( D64 . C44 )) . R33 ) by L353 , L147
.= ( (R27 , ( ( D64 +* (R21 , D65) ) . C44 )) . R33 ) by L369 , FUNCT_7:32
.= ( D70 . C44 ) by L147;
end;
end;
thus L372: thesis by L366 , L81;
end;
L373: ( Phi ( D64 +* (R21 , D65) ) ) = ( R33 . (R27 , ( *' (R27 , ( R32 +* (R21 , R30) )) )) ) by L365 , L234;
L374: ( Phi D64 ) = ( R33 . (R27 , ( *' (R27 , R32) )) ) by L231;
L375: ( R33 . (R27 , ( *' (R27 , ( R32 +* (R21 , R31) )) )) ) = ( ( R33 . (R27 , ( *' (R27 , R32) )) ) + ( R33 . (R27 , ( *' (R27 , ( R32 +* (R21 , R30) )) )) ) ) by L374 , L348 , L363 , L373;
thus L376: thesis by L375 , L349 , L351 , L352 , L300;
end;
thus L377: thesis by L350 , L121;
end;

end;
theorem
L348: (for R1 being (Element of ( NAT )) holds (for R21 being (Nat of R1) holds (for R26 being (ReperAlgebra of R1) holds (for R27 being (Point of R26) holds (for R32 being (Tuple of ( R1 + 1 ) , R26) holds (for R33 being (ATLAS of R26) holds (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ((( R33 . (R27 , R32) ) = R35 & R21 <= R1) implies ( R33 . (R27 , ( R32 +* (( R21 + 1 ) , ( R32 . R21 )) )) ) = ( R35 +* (( R21 + 1 ) , ( R35 . R21 )) )))))))))
proof
let R1 being (Element of ( NAT ));
let R21 being (Nat of R1);
let R26 being (ReperAlgebra of R1);
let R27 being (Point of R26);
let R32 being (Tuple of ( R1 + 1 ) , R26);
let R33 being (ATLAS of R26);
let R35 being (Tuple of ( R1 + 1 ) , R33);
assume that
L349: ( R33 . (R27 , R32) ) = R35
and
L350: R21 <= R1;
reconsider D71 = ( R21 + 1 ) as (Nat of R1) by L350 , L76;
set D72 = ( R33 . (R27 , ( R32 +* (D71 , ( R32 . R21 )) )) );
set D73 = ( R35 +* (D71 , ( R35 . R21 )) );
L351: (for B32 being (Nat of R1) holds ( D72 . B32 ) = ( D73 . B32 ))
proof
let C45 being (Nat of R1);
L352:
now
per cases ;
suppose L353: C45 = D71;

thus L354: ( D72 . C45 ) = ( R33 . (R27 , ( ( R32 +* (D71 , ( R32 . R21 )) ) . C45 )) ) by L158
.= ( R33 . (R27 , ( R32 . R21 )) ) by L353 , L88
.= ( R35 . R21 ) by L349 , L158
.= ( D73 . C45 ) by L353 , L127;
end;
suppose L355: C45 <> D71;

thus L356: ( D72 . C45 ) = ( R33 . (R27 , ( ( R32 +* (D71 , ( R32 . R21 )) ) . C45 )) ) by L158
.= ( R33 . (R27 , ( R32 . C45 )) ) by L355 , FUNCT_7:32
.= ( R35 . C45 ) by L349 , L158
.= ( D73 . C45 ) by L355 , FUNCT_7:32;
end;
end;
thus L358: thesis by L352;
end;
thus L359: thesis by L351 , L133;
end;
theorem
L360: (for R1 being (Element of ( NAT )) holds (for R21 being (Nat of R1) holds (for R26 being (ReperAlgebra of R1) holds (for R27 being (Point of R26) holds (for R32 being (Tuple of ( R1 + 1 ) , R26) holds (for R33 being (ATLAS of R26) holds (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ((( (R27 , R35) . R33 ) = R32 & R21 <= R1) implies ( (R27 , ( R35 +* (( R21 + 1 ) , ( R35 . R21 )) )) . R33 ) = ( R32 +* (( R21 + 1 ) , ( R32 . R21 )) )))))))))
proof
let R1 being (Element of ( NAT ));
let R21 being (Nat of R1);
let R26 being (ReperAlgebra of R1);
let R27 being (Point of R26);
let R32 being (Tuple of ( R1 + 1 ) , R26);
let R33 being (ATLAS of R26);
let R35 being (Tuple of ( R1 + 1 ) , R33);
assume that
L361: ( (R27 , R35) . R33 ) = R32
and
L362: R21 <= R1;
L363: ( R33 . (R27 , R32) ) = R35 by L361 , L169;
L364: ( R33 . (R27 , ( R32 +* (( R21 + 1 ) , ( R32 . R21 )) )) ) = ( R35 +* (( R21 + 1 ) , ( R35 . R21 )) ) by L363 , L362 , L348;
thus L365: thesis by L364 , L169;
end;
theorem
L366: (for R1 being (Element of ( NAT )) holds (for R21 being (Nat of R1) holds (for R26 being (ReperAlgebra of R1) holds (for R33 being (ATLAS of R26) holds (R21 <= R1 implies (R26 is_alternative_in R21 iff (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ( Phi ( R35 +* (( R21 + 1 ) , ( R35 . R21 )) ) ) = ( 0. R33 ))))))))
proof
let R1 being (Element of ( NAT ));
let R21 being (Nat of R1);
let R26 being (ReperAlgebra of R1);
let R33 being (ATLAS of R26);
assume L367: R21 <= R1;
thus L368: (R26 is_alternative_in R21 implies (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ( Phi ( R35 +* (( R21 + 1 ) , ( R35 . R21 )) ) ) = ( 0. R33 )))
proof
set D74 = the (Point of R26);
assume L369: R26 is_alternative_in R21;
let R35 being (Tuple of ( R1 + 1 ) , R33);
set D75 = ( (D74 , R35) . R33 );
set D76 = ( (D74 , ( 0. R33 )) . R33 );
set D77 = ( D75 +* (( R21 + 1 ) , ( D75 . R21 )) );
L370: D76 = D74 by MIDSP_2:34;
L371: ( *' (D74 , D77) ) = D76 by L370 , L369 , L123;
L372: ( (D74 , ( R35 +* (( R21 + 1 ) , ( R35 . R21 )) )) . R33 ) = D77 by L367 , L360;
thus L373: thesis by L372 , L371 , L242;
end;

assume L374: (for R35 being (Tuple of ( R1 + 1 ) , R33) holds ( Phi ( R35 +* (( R21 + 1 ) , ( R35 . R21 )) ) ) = ( 0. R33 ));
L375: (for R27 being (Point of R26) holds (for R32 being (Tuple of ( R1 + 1 ) , R26) holds (for R29 being (Point of R26) holds (( R32 . R21 ) = R29 implies ( *' (R27 , ( R32 +* (( R21 + 1 ) , R29) )) ) = R27))))
proof
let R27 being (Point of R26);
let R32 being (Tuple of ( R1 + 1 ) , R26);
let R29 being (Point of R26);
assume that
L376: ( R32 . R21 ) = R29;
set D78 = ( R33 . (R27 , R32) );
set D79 = ( R33 . (R27 , R27) );
set D80 = ( D78 +* (( R21 + 1 ) , ( D78 . R21 )) );
L377: D79 = ( 0. R33 ) by MIDSP_2:33;
L378: ( Phi D80 ) = D79 by L377 , L374;
L379: ( R33 . (R27 , ( R32 +* (( R21 + 1 ) , ( R32 . R21 )) )) ) = D80 by L367 , L348;
thus L380: thesis by L379 , L376 , L378 , L238;
end;
thus L381: thesis by L375 , L123;
end;
