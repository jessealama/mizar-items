:: Categories without Uniqueness of { \bf cod } and { \bf dom }
::  by Andrzej Trybulec
::
:: Received February 28, 1995
:: Copyright (c) 1995-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies FUNCT_1, SUBSET_1, RELAT_1, FUNCT_2, XBOOLE_0, TARSKI, PBOOLE,
      ZFMISC_1, MCART_1, FUNCOP_1, STRUCT_0, CAT_1, RELAT_2, BINOP_1, CARD_1,
      ALTCAT_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, XTUPLE_0, MCART_1, DOMAIN_1,
      RELAT_1, CARD_1, NUMBERS, STRUCT_0, FUNCT_1, FUNCT_2, BINOP_1, MULTOP_1,
      FUNCOP_1, PBOOLE;
 constructors PARTFUN1, BINOP_1, MULTOP_1, PBOOLE, REALSET2, RELSET_1,
      XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, FUNCT_2, FUNCOP_1,
      STRUCT_0, RELSET_1, ZFMISC_1, CARD_1, ORDINAL1, XTUPLE_0;
 requirements BOOLE, SUBSET, NUMERALS;
 definitions TARSKI, STRUCT_0, XBOOLE_0, FUNCOP_1, BINOP_1, XTUPLE_0;
 theorems FUNCT_1, ZFMISC_1, PBOOLE, DOMAIN_1, MULTOP_1, MCART_1, FUNCT_2,
      TARSKI, FUNCOP_1, RELAT_1, STRUCT_0, RELSET_1, XBOOLE_0, XBOOLE_1,
      CARD_1, PARTFUN1, XTUPLE_0;
 schemes FUNCT_1;

begin
theorem
L1: (for B1 being set holds ( id B1 ) in ( Funcs (B1 , B1) ))
proof
let C1 being set;
L2: (( dom ( id C1 ) ) = C1 & ( rng ( id C1 ) ) = C1);
thus L3: thesis by L2 , FUNCT_2:def 2;
end;
theorem
L4: ( Funcs (( {} ) , ( {} )) ) = { ( id ( {} ) ) }
proof
thus L5:now
let C2 being set;
assume L6: C2 in ( Funcs (( {} ) , ( {} )) );
reconsider D1 = C2 as (Function of ( {} ) , ( {} )) by L6 , FUNCT_2:66;
L7: D1 = ( id ( {} ) );
thus L8: C2 in { ( id ( {} ) ) } by L7 , TARSKI:def 1;
end;
L9: ( id ( {} ) ) in ( Funcs (( {} ) , ( {} )) ) by L1;
thus L10: thesis by L9 , ZFMISC_1:31;
end;
theorem
L11: (for B2 , B3 , B4 being set holds (for B5 , B6 being Function holds ((B5 in ( Funcs (B2 , B3) ) & B6 in ( Funcs (B3 , B4) )) implies ( B6 * B5 ) in ( Funcs (B2 , B4) ))))
proof
let C3 , C4 , C5 being set;
let C6 , C7 being Function;
assume that
L12: C6 in ( Funcs (C3 , C4) )
and
L13: C7 in ( Funcs (C4 , C5) );
L14: (ex B7 being Function st (B7 = C7 & ( dom B7 ) = C4 & ( rng B7 ) c= C5)) by L13 , FUNCT_2:def 2;
L15: ( rng ( C7 * C6 ) ) c= ( rng C7 ) by RELAT_1:26;
L16: ( rng ( C7 * C6 ) ) c= C5 by L15 , L14 , XBOOLE_1:1;
L17: (ex B8 being Function st (B8 = C6 & ( dom B8 ) = C3 & ( rng B8 ) c= C4)) by L12 , FUNCT_2:def 2;
L18: ( dom ( C7 * C6 ) ) = C3 by L17 , L14 , RELAT_1:27;
thus L19: thesis by L18 , L16 , FUNCT_2:def 2;
end;
theorem
L20: (for B9 , B10 , B11 being set holds ((( Funcs (B9 , B10) ) <> ( {} ) & ( Funcs (B10 , B11) ) <> ( {} )) implies ( Funcs (B9 , B11) ) <> ( {} )))
proof
let C8 , C9 , C10 being set;
assume that
L21: ( Funcs (C8 , C9) ) <> ( {} )
and
L22: ( Funcs (C9 , C10) ) <> ( {} );
consider C11 being set such that L23: C11 in ( Funcs (C9 , C10) ) by L22 , XBOOLE_0:def 1;
L24: (ex B12 being set st B12 in ( Funcs (C8 , C9) )) by L21 , XBOOLE_0:def 1;
thus L25: thesis by L24 , L23 , L11;
end;
theorem
L26: (for B13 , B14 being set holds (for B15 being (ManySortedSet of [: B14 , B13 :]) holds (for B16 being (Subset of B13) holds (for B17 being (Subset of B14) holds (for B18 , B19 being set holds ((B18 in B16 & B19 in B17) implies ( B15 . (B19 , B18) ) = ( ( B15 | ([: B17 , B16 :] qua set) ) . (B19 , B18) )))))))
proof
let C12 , C13 being set;
let C14 being (ManySortedSet of [: C13 , C12 :]);
let C15 being (Subset of C12);
let C16 being (Subset of C13);
let C17 , C18 being set;
assume L27: (C17 in C15 & C18 in C16);
L28: [ C18 , C17 ] in [: C16 , C15 :] by L27 , ZFMISC_1:87;
thus L29: thesis by L28 , FUNCT_1:49;
end;
scheme MSSLambda2 { F1 , F2() -> set , F3(set , set) -> set } : (ex B20 being (ManySortedSet of [: F1() , F2() :]) st (for R1 being set holds (for R2 being set holds ((R1 in F1() & R2 in F2()) implies ( B20 . (R1 , R2) ) = F3(R1 , R2)))))
proof
deffunc H1(set) = F3(( $1 `1 ) , ( $1 `2 ));
consider C19 being Function such that L30: ( dom C19 ) = [: F1() , F2() :] and L31: (for R4 being set holds (R4 in [: F1() , F2() :] implies ( C19 . R4 ) = H1(R4))) from FUNCT_1:sch 3;
reconsider D2 = C19 as (ManySortedSet of [: F1() , F2() :]) by L30 , PARTFUN1:def 2 , RELAT_1:def 18;
take D2;
let R1 being set;
let R2 being set;
assume L32: (R1 in F1() & R2 in F2());
L33: [ R1 , R2 ] in [: F1() , F2() :] by L32 , ZFMISC_1:87;
L34: (( [ R1 , R2 ] `1 ) = R1 & ( [ R1 , R2 ] `2 ) = R2);
thus L35: thesis by L34 , L31 , L33;
end;
scheme MSSLambda2D { F4 , F5() -> non  empty set , F6(set , set) -> set } : (ex B21 being (ManySortedSet of [: F4() , F5() :]) st (for B22 being (Element of F4()) holds (for B23 being (Element of F5()) holds ( B21 . (B22 , B23) ) = F6(B22 , B23))))
proof
consider C20 being (ManySortedSet of [: F4() , F5() :]) such that L36: (for R1 being set holds (for R2 being set holds ((R1 in F4() & R2 in F5()) implies ( C20 . (R1 , R2) ) = F6(R1 , R2)))) from MSSLambda2;
take C20;
thus L37: thesis by L36;
end;
scheme MSSLambda3 { F7 , F8 , F9() -> set , F10(set , set , set) -> set } : (ex B24 being (ManySortedSet of [: F7() , F8() , F9() :]) st (for R1 being set holds (for R2 being set holds (for R3 being set holds ((R1 in F7() & R2 in F8() & R3 in F9()) implies ( B24 . (R1 , R2 , R3) ) = F10(R1 , R2 , R3))))))
proof
deffunc H2(set) = F10(( ( $1 `1 ) `1 ) , ( ( $1 `1 ) `2 ) , ( $1 `2 ));
consider C21 being Function such that L38: ( dom C21 ) = [: F7() , F8() , F9() :] and L39: (for R4 being set holds (R4 in [: F7() , F8() , F9() :] implies ( C21 . R4 ) = H2(R4))) from FUNCT_1:sch 3;
reconsider D3 = C21 as (ManySortedSet of [: F7() , F8() , F9() :]) by L38 , PARTFUN1:def 2 , RELAT_1:def 18;
take D3;
let R1 being set;
let R2 being set;
let R3 being set;
L40: (( [ [ R1 , R2 ] , R3 ] `2 ) = R3 & [ R1 , R2 , R3 ] = [ [ R1 , R2 ] , R3 ]);
L41: ( ( [ [ R1 , R2 ] , R3 ] `1 ) `2 ) = R2;
L42: ( ( [ [ R1 , R2 ] , R3 ] `1 ) `1 ) = R1;
assume L43: (R1 in F7() & R2 in F8() & R3 in F9());
L44: [ R1 , R2 , R3 ] in [: F7() , F8() , F9() :] by L43 , MCART_1:69;
thus L45: ( D3 . (R1 , R2 , R3) ) = ( D3 . [ R1 , R2 , R3 ] ) by MULTOP_1:def 1
.= F10(R1 , R2 , R3) by L39 , L44 , L42 , L41 , L40;
end;
scheme MSSLambda3D { F11 , F12 , F13() -> non  empty set , F14(set , set , set) -> set } : (ex B25 being (ManySortedSet of [: F11() , F12() , F13() :]) st (for B26 being (Element of F11()) holds (for B27 being (Element of F12()) holds (for B28 being (Element of F13()) holds ( B25 . (B26 , B27 , B28) ) = F14(B26 , B27 , B28)))))
proof
consider C22 being (ManySortedSet of [: F11() , F12() , F13() :]) such that L46: (for R1 being set holds (for R2 being set holds (for R3 being set holds ((R1 in F11() & R2 in F12() & R3 in F13()) implies ( C22 . (R1 , R2 , R3) ) = F14(R1 , R2 , R3))))) from MSSLambda3;
take C22;
thus L47: thesis by L46;
end;
theorem
L48: (for B29 , B30 being set holds (for B31 , B32 being (ManySortedSet of [: B29 , B30 :]) holds ((for R1 being set holds (for R2 being set holds ((R1 in B29 & R2 in B30) implies ( B31 . (R1 , R2) ) = ( B32 . (R1 , R2) )))) implies B32 = B31)))
proof
let C23 , C24 being set;
let C25 , C26 being (ManySortedSet of [: C23 , C24 :]);
assume L49: (for R1 being set holds (for R2 being set holds ((R1 in C23 & R2 in C24) implies ( C25 . (R1 , R2) ) = ( C26 . (R1 , R2) ))));
L50:
now
let R4 being set;
assume L51: R4 in [: C23 , C24 :];
reconsider D4 = C23 , D5 = C24 as non  empty set by L51;
consider C27 being (Element of D4), C28 being (Element of D5) such that L52: R4 = [ C27 , C28 ] by L51 , DOMAIN_1:1;
thus L53: ( C25 . R4 ) = ( C25 . (C27 , C28) ) by L52
.= ( C26 . (C27 , C28) ) by L49
.= ( C26 . R4 ) by L52;
end;
L54: (( dom C26 ) = [: C23 , C24 :] & ( dom C25 ) = [: C23 , C24 :]) by PARTFUN1:def 2;
thus L55: thesis by L54 , L50 , FUNCT_1:2;
end;
theorem
L56: (for B33 , B34 being non  empty set holds (for B35 , B36 being (ManySortedSet of [: B33 , B34 :]) holds ((for B37 being (Element of B33) holds (for B38 being (Element of B34) holds ( B35 . (B37 , B38) ) = ( B36 . (B37 , B38) ))) implies B36 = B35)))
proof
let C29 , C30 being non  empty set;
let C31 , C32 being (ManySortedSet of [: C29 , C30 :]);
assume L57: (for B39 being (Element of C29) holds (for B40 being (Element of C30) holds ( C31 . (B39 , B40) ) = ( C32 . (B39 , B40) )));
L58: (for R1 being set holds (for R2 being set holds ((R1 in C29 & R2 in C30) implies ( C31 . (R1 , R2) ) = ( C32 . (R1 , R2) )))) by L57;
thus L59: thesis by L58 , L48;
end;
theorem
L60: (for B41 being set holds (for B42 , B43 being (ManySortedSet of [: B41 , B41 , B41 :]) holds ((for R1 being set holds (for R2 being set holds (for R3 being set holds ((R1 in B41 & R2 in B41 & R3 in B41) implies ( B42 . (R1 , R2 , R3) ) = ( B43 . (R1 , R2 , R3) ))))) implies B43 = B42)))
proof
let C33 being set;
let C34 , C35 being (ManySortedSet of [: C33 , C33 , C33 :]);
assume L61: (for R1 being set holds (for R2 being set holds (for R3 being set holds ((R1 in C33 & R2 in C33 & R3 in C33) implies ( C34 . (R1 , R2 , R3) ) = ( C35 . (R1 , R2 , R3) )))));
L62:
now
let R4 being set;
assume L63: R4 in [: C33 , C33 , C33 :];
reconsider D6 = C33 as non  empty set by L63 , MCART_1:31;
consider C36 , C37 , C38 being (Element of D6) such that L64: R4 = [ C36 , C37 , C38 ] by L63 , DOMAIN_1:3;
thus L65: ( C35 . R4 ) = ( C35 . (C36 , C37 , C38) ) by L64 , MULTOP_1:def 1
.= ( C34 . (C36 , C37 , C38) ) by L61
.= ( C34 . R4 ) by L64 , MULTOP_1:def 1;
end;
L66: (( dom C35 ) = [: C33 , C33 , C33 :] & ( dom C34 ) = [: C33 , C33 , C33 :]) by PARTFUN1:def 2;
thus L67: thesis by L66 , L62 , FUNCT_1:2;
end;
theorem
L68: (for R1 being set holds (for R2 being set holds (for R3 being set holds ( (R1 , R2) :-> R3 ) = ( [ R1 , R2 ] .--> R3 ))));
theorem
L69: (for R1 being set holds (for R2 being set holds (for R3 being set holds ( ( (R1 , R2) :-> R3 ) . (R1 , R2) ) = R3)))
proof
let R1 being set;
let R2 being set;
let R3 being set;
thus L70: ( ( (R1 , R2) :-> R3 ) . (R1 , R2) ) = ( ( [ R1 , R2 ] .--> R3 ) . [ R1 , R2 ] )
.= R3 by FUNCOP_1:72;
end;
begin
definition
struct (1-sorted) AltGraph(# carrier -> set , Arrows -> (ManySortedSet of [: the carrier , the carrier :]) #);
end;
definition
let C39 being AltGraph;
mode object of C39
 is (Element of C39);
end;
definition
let C40 being AltGraph;
let C41 , C42 being (object of C40);
func <^C41 , C42 ^> equals 
( (the Arrows of C40) . (C41 , C42) );
correctness;
end;
definition
let C43 being AltGraph;
let C44 , C45 being (object of C43);
mode Morphism of C44 , C45
 is (Element of <^ C44 , C45 ^>);
end;
definition
let C46 being AltGraph;
attr C46 is  transitive
means
:L75: (for B44 , B45 , B46 being (object of C46) holds ((<^ B44 , B45 ^> <> ( {} ) & <^ B45 , B46 ^> <> ( {} )) implies <^ B44 , B46 ^> <> ( {} )));
end;
begin
definition
let C47 being set;
let C48 being (ManySortedSet of [: C47 , C47 :]);
func {|C48 |} -> (ManySortedSet of [: C47 , C47 , C47 :]) means 
:L77: (for R1 being set holds (for R2 being set holds (for R3 being set holds ((R1 in C47 & R2 in C47 & R3 in C47) implies ( it . (R1 , R2 , R3) ) = ( C48 . (R1 , R3) )))));
existence
proof
deffunc H3(set , set , set) = ( C48 . ($1 , $3) );
L78: (ex B47 being (ManySortedSet of [: C47 , C47 , C47 :]) st (for R1 being set holds (for R2 being set holds (for R3 being set holds ((R1 in C47 & R2 in C47 & R3 in C47) implies ( B47 . (R1 , R2 , R3) ) = H3(R1 , R2 , R3)))))) from MSSLambda3;
thus L79: thesis by L78;
end;
uniqueness
proof
let C49 , C50 being (ManySortedSet of [: C47 , C47 , C47 :]);
assume that
L80: (for R1 being set holds (for R2 being set holds (for R3 being set holds ((R1 in C47 & R2 in C47 & R3 in C47) implies ( C49 . (R1 , R2 , R3) ) = ( C48 . (R1 , R3) )))))
and
L81: (for R1 being set holds (for R2 being set holds (for R3 being set holds ((R1 in C47 & R2 in C47 & R3 in C47) implies ( C50 . (R1 , R2 , R3) ) = ( C48 . (R1 , R3) )))));
L82:
now
let R1 being set;
let R2 being set;
let R3 being set;
assume L83: (R1 in C47 & R2 in C47 & R3 in C47);
thus L84: ( C49 . (R1 , R2 , R3) ) = ( C48 . (R1 , R3) ) by L83 , L80
.= ( C50 . (R1 , R2 , R3) ) by L81 , L83;
end;
thus L85: C49 = C50 by L82 , L60;
end;
let C51 being (ManySortedSet of [: C47 , C47 :]);
func {|C48 , C51 |} -> (ManySortedSet of [: C47 , C47 , C47 :]) means 
:L86: (for R1 being set holds (for R2 being set holds (for R3 being set holds ((R1 in C47 & R2 in C47 & R3 in C47) implies ( it . (R1 , R2 , R3) ) = [: ( C51 . (R2 , R3) ) , ( C48 . (R1 , R2) ) :]))));
existence
proof
deffunc H4(set , set , set) = [: ( C51 . ($2 , $3) ) , ( C48 . ($1 , $2) ) :];
L87: (ex B48 being (ManySortedSet of [: C47 , C47 , C47 :]) st (for R1 being set holds (for R2 being set holds (for R3 being set holds ((R1 in C47 & R2 in C47 & R3 in C47) implies ( B48 . (R1 , R2 , R3) ) = H4(R1 , R2 , R3)))))) from MSSLambda3;
thus L88: thesis by L87;
end;
uniqueness
proof
let C52 , C53 being (ManySortedSet of [: C47 , C47 , C47 :]);
assume that
L89: (for R1 being set holds (for R2 being set holds (for R3 being set holds ((R1 in C47 & R2 in C47 & R3 in C47) implies ( C52 . (R1 , R2 , R3) ) = [: ( C51 . (R2 , R3) ) , ( C48 . (R1 , R2) ) :]))))
and
L90: (for R1 being set holds (for R2 being set holds (for R3 being set holds ((R1 in C47 & R2 in C47 & R3 in C47) implies ( C53 . (R1 , R2 , R3) ) = [: ( C51 . (R2 , R3) ) , ( C48 . (R1 , R2) ) :]))));
L91:
now
let R1 being set;
let R2 being set;
let R3 being set;
assume L92: (R1 in C47 & R2 in C47 & R3 in C47);
thus L93: ( C52 . (R1 , R2 , R3) ) = [: ( C51 . (R2 , R3) ) , ( C48 . (R1 , R2) ) :] by L92 , L89
.= ( C53 . (R1 , R2 , R3) ) by L90 , L92;
end;
thus L94: C52 = C53 by L91 , L60;
end;
end;
definition
let C54 being set;
let C55 being (ManySortedSet of [: C54 , C54 :]);
mode BinComp of C55
 is (ManySortedFunction of {| C55 , C55 |} , {| C55 |});
end;
definition
let C56 being non  empty set;
let C57 being (ManySortedSet of [: C56 , C56 :]);
let C58 being (BinComp of C57);
let C59 , C60 , C61 being (Element of C56);
redefine func C58 . (C59 , C60 , C61) -> (Function of [: ( C57 . (C60 , C61) ) , ( C57 . (C59 , C60) ) :] , ( C57 . (C59 , C61) ));

coherence
proof
L97: ( {| C57 |} . [ C59 , C60 , C61 ] ) = ( {| C57 |} . (C59 , C60 , C61) ) by MULTOP_1:def 1
.= ( C57 . (C59 , C61) ) by L77;
L98: ( C58 . [ C59 , C60 , C61 ] ) = ( C58 . (C59 , C60 , C61) ) by MULTOP_1:def 1;
L99: ( {| C57 , C57 |} . [ C59 , C60 , C61 ] ) = ( {| C57 , C57 |} . (C59 , C60 , C61) ) by MULTOP_1:def 1
.= [: ( C57 . (C60 , C61) ) , ( C57 . (C59 , C60) ) :] by L86;
thus L100: thesis by L99 , L98 , L97 , PBOOLE:def 15;
end;
end;
definition
let C62 being non  empty set;
let C63 being (ManySortedSet of [: C62 , C62 :]);
let C64 being (BinComp of C63);
attr C64 is  associative
means
:L102: (for B49 , B50 , B51 , B52 being (Element of C62) holds (for B53 , B54 , B55 being set holds ((B53 in ( C63 . (B49 , B50) ) & B54 in ( C63 . (B50 , B51) ) & B55 in ( C63 . (B51 , B52) )) implies ( ( C64 . (B49 , B51 , B52) ) . (B55 , ( ( C64 . (B49 , B50 , B51) ) . (B54 , B53) )) ) = ( ( C64 . (B49 , B50 , B52) ) . (( ( C64 . (B50 , B51 , B52) ) . (B55 , B54) ) , B53) ))));
attr C64 is  with_right_units
means
:L103: (for B56 being (Element of C62) holds (ex B57 being set st (B57 in ( C63 . (B56 , B56) ) & (for B58 being (Element of C62) holds (for B59 being set holds (B59 in ( C63 . (B56 , B58) ) implies ( ( C64 . (B56 , B56 , B58) ) . (B59 , B57) ) = B59))))));
attr C64 is  with_left_units
means
:L104: (for B60 being (Element of C62) holds (ex B61 being set st (B61 in ( C63 . (B60 , B60) ) & (for B62 being (Element of C62) holds (for B63 being set holds (B63 in ( C63 . (B62 , B60) ) implies ( ( C64 . (B62 , B60 , B60) ) . (B61 , B63) ) = B63))))));
end;
begin
definition
struct (AltGraph) AltCatStr(# carrier -> set , Arrows -> (ManySortedSet of [: the carrier , the carrier :]) , Comp -> (BinComp of the Arrows) #);
end;
registration
cluster  strict non  empty for AltCatStr;
existence
proof
set D7 = the non  empty set;
set D8 = the (ManySortedSet of [: D7 , D7 :]);
set D9 = the (BinComp of D8);
take AltCatStr (# D7 , D8 , D9 #);
thus L107: AltCatStr (# D7 , D8 , D9 #) is  strict;
thus L108: (the carrier of AltCatStr (# D7 , D8 , D9 #)) is non  empty;
end;
end;
definition
let C65 being non  empty AltCatStr;
let C66 , C67 , C68 being (object of C65);
assume that
L110: (<^ C66 , C67 ^> <> ( {} ) & <^ C67 , C68 ^> <> ( {} ));
let C69 being (Morphism of C66 , C67);
let C70 being (Morphism of C67 , C68);
func C70 * C69 -> (Morphism of C66 , C68) equals 
:L111: ( ( (the Comp of C65) . (C66 , C67 , C68) ) . (C70 , C69) );
coherence
proof
reconsider D10 = <^ C66 , C67 ^> , D11 = <^ C67 , C68 ^> as non  empty set by L110;
reconsider D12 = ( (the Comp of C65) . (C66 , C67 , C68) ) as (Function of [: D11 , D10 :] , <^ C66 , C68 ^>);
reconsider D13 = C70 as (Element of D11);
reconsider D14 = C69 as (Element of D10);
L112: ( D12 . (D13 , D14) ) is (Element of <^ C66 , C68 ^>);
thus L113: thesis by L112;
end;
correctness;
end;
definition
let C71 being Function;
attr C71 is  compositional
means
:L115: (for R4 being set holds (R4 in ( dom C71 ) implies (ex B64 , B65 being Function st (R4 = [ B65 , B64 ] & ( C71 . R4 ) = ( B65 * B64 )))));
end;
registration
let C72 , C73 being  functional set;
cluster  compositional for (ManySortedFunction of [: C72 , C73 :]);
existence
proof
per cases ;
suppose L117: (C72 = ( {} ) or C73 = ( {} ));

set D15 = ( [[0]] [: C72 , C73 :] );
L118: D15 is  Function-yielding by L117;
reconsider D16 = D15 as (ManySortedFunction of [: C72 , C73 :]) by L118;
take D16;
let R4 being set;
thus L119: thesis by L117;
end;
suppose L120: (C72 <> ( {} ) & C73 <> ( {} ));

reconsider D17 = C72 , D18 = C73 as non  empty  functional set by L120;
deffunc H5((Element of D17) , (Element of D18)) = ( $1 * $2 );
consider C74 being (ManySortedSet of [: D17 , D18 :]) such that L121: (for B66 being (Element of D17) holds (for B67 being (Element of D18) holds ( C74 . (B66 , B67) ) = H5(B66 , B67))) from MSSLambda2D;
L122: C74 is  Function-yielding
proof
let R4 being set;
assume L123: R4 in ( dom C74 );
L124: R4 in [: D17 , D18 :] by L123 , PARTFUN1:def 2;
L125: (( R4 `1 ) in D17 & ( R4 `2 ) in D18) by L124 , MCART_1:10;
reconsider D19 = ( R4 `1 ) , D20 = ( R4 `2 ) as Function by L125;
L126: ( C74 . R4 ) = ( C74 . (D19 , D20) ) by L124 , MCART_1:22
.= ( D19 * D20 ) by L121 , L125;
thus L127: thesis by L126;
end;
reconsider D21 = C74 as (ManySortedFunction of [: C72 , C73 :]) by L122;
take D21;
let R4 being set;
assume L128: R4 in ( dom D21 );
L129: R4 in [: D17 , D18 :] by L128 , PARTFUN1:def 2;
L130: (( R4 `1 ) in D17 & ( R4 `2 ) in D18) by L129 , MCART_1:10;
reconsider D22 = ( R4 `1 ) , D23 = ( R4 `2 ) as Function by L130;
take D23;
take D22;
thus L131: R4 = [ D22 , D23 ] by L129 , MCART_1:22;
thus L132: ( D21 . R4 ) = ( D21 . (D22 , D23) ) by L129 , MCART_1:22
.= ( D22 * D23 ) by L121 , L130;
end;
end;
end;
theorem
L135: (for B68 , B69 being  functional set holds (for B70 being  compositional (ManySortedSet of [: B68 , B69 :]) holds (for B71 , B72 being Function holds ((B71 in B68 & B72 in B69) implies ( B70 . (B71 , B72) ) = ( B71 * B72 )))))
proof
let C75 , C76 being  functional set;
let C77 being  compositional (ManySortedSet of [: C75 , C76 :]);
let C78 , C79 being Function;
assume that
L136: (C78 in C75 & C79 in C76);
L137: ( dom C77 ) = [: C75 , C76 :] by PARTFUN1:def 2;
L138: [ C78 , C79 ] in ( dom C77 ) by L137 , L136 , ZFMISC_1:87;
consider C80 , C81 being Function such that L139: [ C78 , C79 ] = [ C81 , C80 ] and L140: ( C77 . [ C78 , C79 ] ) = ( C81 * C80 ) by L138 , L115;
L141: C78 = C81 by L139 , XTUPLE_0:1;
thus L142: thesis by L141 , L139 , L140 , XTUPLE_0:1;
end;
definition
let C82 , C83 being  functional set;
func FuncComp (C82 , C83) ->  compositional (ManySortedFunction of [: C83 , C82 :]) means 
:L143: (not contradiction);
uniqueness
proof
let C84 , C85 being  compositional (ManySortedFunction of [: C83 , C82 :]);
L144:
now
let R1 being set;
let R2 being set;
assume L145: (R1 in C83 & R2 in C82);
L146: [ R1 , R2 ] in [: C83 , C82 :] by L145 , ZFMISC_1:87;
L147: [ R1 , R2 ] in ( dom C84 ) by L146 , PARTFUN1:def 2;
consider C86 , C87 being Function such that L148: [ R1 , R2 ] = [ C87 , C86 ] and L149: ( C84 . [ R1 , R2 ] ) = ( C87 * C86 ) by L147 , L115;
L150: [ R1 , R2 ] in ( dom C85 ) by L146 , PARTFUN1:def 2;
consider C88 , C89 being Function such that L151: [ R1 , R2 ] = [ C89 , C88 ] and L152: ( C85 . [ R1 , R2 ] ) = ( C89 * C88 ) by L150 , L115;
L153: C87 = C89 by L148 , L151 , XTUPLE_0:1;
thus L154: ( C84 . (R1 , R2) ) = ( C85 . (R1 , R2) ) by L153 , L148 , L149 , L151 , L152 , XTUPLE_0:1;
end;
thus L155: C84 = C85 by L144 , L48;
end;
correctness;
end;
theorem
L157: (for B73 , B74 , B75 being set holds ( rng ( FuncComp (( Funcs (B73 , B74) ) , ( Funcs (B74 , B75) )) ) ) c= ( Funcs (B73 , B75) ))
proof
let C90 , C91 , C92 being set;
let R1 being set;
set D24 = ( FuncComp (( Funcs (C90 , C91) ) , ( Funcs (C91 , C92) )) );
assume L158: R1 in ( rng D24 );
consider R2 being set such that L159: R2 in ( dom D24 ) and L160: R1 = ( D24 . R2 ) by L158 , FUNCT_1:def 3;
consider C93 , C94 being Function such that L161: R2 = [ C94 , C93 ] and L162: ( D24 . R2 ) = ( C94 * C93 ) by L159 , L115;
L163: ( dom D24 ) = [: ( Funcs (C91 , C92) ) , ( Funcs (C90 , C91) ) :] by PARTFUN1:def 2;
L164: (C94 in ( Funcs (C91 , C92) ) & C93 in ( Funcs (C90 , C91) )) by L163 , L159 , L161 , ZFMISC_1:87;
thus L165: thesis by L164 , L160 , L162 , L11;
end;
theorem
L166: (for B76 being set holds ( FuncComp ({ ( id B76 ) } , { ( id B76 ) }) ) = ( (( id B76 ) , ( id B76 )) :-> ( id B76 ) ))
proof
let C95 being set;
L167: ( dom ( FuncComp ({ ( id C95 ) } , { ( id C95 ) }) ) ) = [: { ( id C95 ) } , { ( id C95 ) } :] by PARTFUN1:def 2;
L168: ( rng ( FuncComp ({ ( id C95 ) } , { ( id C95 ) }) ) ) c= { ( id C95 ) }
proof
let R1 being set;
assume L169: R1 in ( rng ( FuncComp ({ ( id C95 ) } , { ( id C95 ) }) ) );
consider R2 being set such that L170: R2 in [: { ( id C95 ) } , { ( id C95 ) } :] and L171: R1 = ( ( FuncComp ({ ( id C95 ) } , { ( id C95 ) }) ) . R2 ) by L169 , L167 , FUNCT_1:def 3;
consider C96 , C97 being Function such that L172: R2 = [ C97 , C96 ] and L173: ( ( FuncComp ({ ( id C95 ) } , { ( id C95 ) }) ) . R2 ) = ( C97 * C96 ) by L167 , L170 , L115;
L174: C96 in { ( id C95 ) } by L170 , L172 , ZFMISC_1:87;
L175: C96 = ( id C95 ) by L174 , TARSKI:def 1;
L176: C97 in { ( id C95 ) } by L170 , L172 , ZFMISC_1:87;
L177: (( C95 /\ C95 ) = C95 & C97 = ( id C95 )) by L176 , TARSKI:def 1;
L178: R1 = ( id C95 ) by L177 , L171 , L173 , L175 , FUNCT_1:22;
thus L179: thesis by L178 , TARSKI:def 1;
end;
L180: ( FuncComp ({ ( id C95 ) } , { ( id C95 ) }) ) is (Function of [: { ( id C95 ) } , { ( id C95 ) } :] , { ( id C95 ) }) by L168 , L167 , RELSET_1:4;
thus L181: thesis by L180 , FUNCOP_1:def 10;
end;
theorem
L182: (for B77 , B78 being  functional set holds (for B79 being (Subset of B77) holds (for B80 being (Subset of B78) holds ( FuncComp (B79 , B80) ) = ( ( FuncComp (B77 , B78) ) | ([: B80 , B79 :] qua set) ))))
proof
let C98 , C99 being  functional set;
let C100 being (Subset of C98);
let C101 being (Subset of C99);
set D25 = ( ( FuncComp (C98 , C99) ) | ([: C101 , C100 :] qua set) );
L183: ( dom ( FuncComp (C98 , C99) ) ) = [: C99 , C98 :] by PARTFUN1:def 2;
L184: ( dom D25 ) = [: C101 , C100 :] by L183 , RELAT_1:62;
reconsider D26 = D25 as (ManySortedFunction of [: C101 , C100 :]) by L184 , PARTFUN1:def 2;
L185: D26 is  compositional
proof
let R1 being set;
assume L186: R1 in ( dom D26 );
L187: ( D26 . R1 ) = ( ( FuncComp (C98 , C99) ) . R1 ) by L186 , L184 , FUNCT_1:49;
thus L188: thesis by L187 , L183 , L184 , L186 , L115;
end;
thus L189: thesis by L185 , L143;
end;
definition
let C102 being non  empty AltCatStr;
attr C102 is  quasi-functional
means
:L190: (for B81 , B82 being (object of C102) holds <^ B81 , B82 ^> c= ( Funcs (B81 , B82) ));
attr C102 is  semi-functional
means
:L191: (for B83 , B84 , B85 being (object of C102) holds ((<^ B83 , B84 ^> <> ( {} ) & <^ B84 , B85 ^> <> ( {} ) & <^ B83 , B85 ^> <> ( {} )) implies (for B86 being (Morphism of B83 , B84) holds (for B87 being (Morphism of B84 , B85) holds (for B88 , B89 being Function holds ((B86 = B88 & B87 = B89) implies ( B87 * B86 ) = ( B89 * B88 )))))));
attr C102 is  pseudo-functional
means
:L192: (for B90 , B91 , B92 being (object of C102) holds ( (the Comp of C102) . (B90 , B91 , B92) ) = ( ( FuncComp (( Funcs (B90 , B91) ) , ( Funcs (B91 , B92) )) ) | ([: <^ B91 , B92 ^> , <^ B90 , B91 ^> :] qua set) ));
end;
registration
let C103 being non  empty set;
let C104 being (ManySortedSet of [: C103 , C103 :]);
let C105 being (BinComp of C104);
cluster AltCatStr (# C103 , C104 , C105 #) -> non  empty;
coherence;
end;
registration
cluster  strict  pseudo-functional for non  empty non  empty non  empty non  empty AltCatStr;
existence
proof
L195: { [ ( 0 ) , ( 0 ) , ( 0 ) ] } = [: 1 , 1 , 1 :] by CARD_1:49 , MCART_1:35;
reconsider D27 = ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( FuncComp (( Funcs (( 0 ) , ( 0 )) ) , ( Funcs (( 0 ) , ( 0 )) )) ) ) as (ManySortedSet of [: 1 , 1 , 1 :]) by L195;
reconsider D28 = D27 as (ManySortedFunction of [: 1 , 1 , 1 :]);
L196: ( dom ( [ ( 0 ) , ( 0 ) ] .--> ( Funcs (( 0 ) , ( 0 )) ) ) ) = { [ ( 0 ) , ( 0 ) ] } by FUNCOP_1:13
.= [: 1 , 1 :] by CARD_1:49 , ZFMISC_1:29;
reconsider D29 = ( [ ( 0 ) , ( 0 ) ] .--> ( Funcs (( 0 ) , ( 0 )) ) ) as (ManySortedSet of [: 1 , 1 :]) by L196 , PARTFUN1:def 2 , RELAT_1:def 18;
L197: ( D29 . (( 0 ) , ( 0 )) ) = ( Funcs (( 0 ) , ( 0 )) ) by FUNCOP_1:72;
L198: ( 0 ) in 1 by CARD_1:49 , TARSKI:def 1;
L199:
now
let R1 being set;
reconsider D30 = ( D28 . R1 ) as Function;
assume L200: R1 in [: 1 , 1 , 1 :];
L201: R1 = [ ( 0 ) , ( 0 ) , ( 0 ) ] by L200 , L195 , TARSKI:def 1;
L202: ( D28 . R1 ) = ( FuncComp (( Funcs (( 0 ) , ( 0 )) ) , ( Funcs (( 0 ) , ( 0 )) )) ) by L201 , FUNCOP_1:72;
L203: ( dom D30 ) = [: ( D29 . (( 0 ) , ( 0 )) ) , ( D29 . (( 0 ) , ( 0 )) ) :] by L202 , L197 , PARTFUN1:def 2
.= ( {| D29 , D29 |} . (( 0 ) , ( 0 ) , ( 0 )) ) by L198 , L86
.= ( {| D29 , D29 |} . R1 ) by L201 , MULTOP_1:def 1;
L204: ( {| D29 |} . R1 ) = ( {| D29 |} . (( 0 ) , ( 0 ) , ( 0 )) ) by L201 , MULTOP_1:def 1
.= ( D29 . (( 0 ) , ( 0 )) ) by L198 , L77;
L205: ( rng D30 ) c= ( {| D29 |} . R1 ) by L204 , L197 , L202 , L157;
thus L206: ( D28 . R1 ) is (Function of ( {| D29 , D29 |} . R1 ) , ( {| D29 |} . R1 )) by L205 , L197 , L203 , L204 , FUNCT_2:def 1 , RELSET_1:4;
end;
reconsider D31 = D28 as (BinComp of D29) by L199 , PBOOLE:def 15;
take D32 = AltCatStr (# 1 , D29 , D31 #);
thus L207: D32 is  strict;
let C106 , C107 , C108 being (object of D32);
L208: C108 = ( 0 ) by CARD_1:49 , TARSKI:def 1;
L209: (C106 = ( 0 ) & C107 = ( 0 )) by CARD_1:49 , TARSKI:def 1;
L210: ( dom ( FuncComp (( Funcs (( 0 ) , ( 0 )) ) , ( Funcs (( 0 ) , ( 0 )) )) ) ) = [: <^ C107 , C108 ^> , <^ C106 , C107 ^> :] by L209 , L197 , L208 , PARTFUN1:def 2;
thus L211: ( (the Comp of D32) . (C106 , C107 , C108) ) = ( D31 . [ C106 , C107 , C108 ] ) by MULTOP_1:def 1
.= ( FuncComp (( Funcs (( 0 ) , ( 0 )) ) , ( Funcs (( 0 ) , ( 0 )) )) ) by L209 , L208 , FUNCOP_1:72
.= ( ( FuncComp (( Funcs (C106 , C107) ) , ( Funcs (C107 , C108) )) ) | ([: <^ C107 , C108 ^> , <^ C106 , C107 ^> :] qua set) ) by L209 , L208 , L210 , RELAT_1:68;
end;
end;
theorem
L213: (for B93 being non  empty AltCatStr holds (for B94 , B95 , B96 being (object of B93) holds ( (the Comp of B93) . (B94 , B95 , B96) ) is (Function of [: <^ B95 , B96 ^> , <^ B94 , B95 ^> :] , <^ B94 , B96 ^>)));
theorem
L214: (for B97 being  pseudo-functional non  empty AltCatStr holds (for B98 , B99 , B100 being (object of B97) holds ((<^ B98 , B99 ^> <> ( {} ) & <^ B99 , B100 ^> <> ( {} ) & <^ B98 , B100 ^> <> ( {} )) implies (for B101 being (Morphism of B98 , B99) holds (for B102 being (Morphism of B99 , B100) holds (for B103 , B104 being Function holds ((B101 = B103 & B102 = B104) implies ( B102 * B101 ) = ( B104 * B103 ))))))))
proof
let C109 being  pseudo-functional non  empty AltCatStr;
let C110 , C111 , C112 being (object of C109);
assume that
L215: (<^ C110 , C111 ^> <> ( {} ) & <^ C111 , C112 ^> <> ( {} ))
and
L216: <^ C110 , C112 ^> <> ( {} );
let C113 being (Morphism of C110 , C111);
let C114 being (Morphism of C111 , C112);
let C115 , C116 being Function;
assume that
L217: (C113 = C115 & C114 = C116);
L218: [ C114 , C113 ] in [: <^ C111 , C112 ^> , <^ C110 , C111 ^> :] by L215 , ZFMISC_1:87;
L219: ( (the Comp of C109) . (C110 , C111 , C112) ) = ( ( FuncComp (( Funcs (C110 , C111) ) , ( Funcs (C111 , C112) )) ) | ([: <^ C111 , C112 ^> , <^ C110 , C111 ^> :] qua set) ) by L192;
L220: (( dom ( ( FuncComp (( Funcs (C110 , C111) ) , ( Funcs (C111 , C112) )) ) | ([: <^ C111 , C112 ^> , <^ C110 , C111 ^> :] qua set) ) ) c= ( dom ( FuncComp (( Funcs (C110 , C111) ) , ( Funcs (C111 , C112) )) ) ) & ( dom ( (the Comp of C109) . (C110 , C111 , C112) ) ) = [: <^ C111 , C112 ^> , <^ C110 , C111 ^> :]) by L216 , FUNCT_2:def 1 , RELAT_1:60;
consider C117 , C118 being Function such that L221: [ C114 , C113 ] = [ C118 , C117 ] and L222: ( ( FuncComp (( Funcs (C110 , C111) ) , ( Funcs (C111 , C112) )) ) . [ C114 , C113 ] ) = ( C118 * C117 ) by L220 , L219 , L218 , L115;
L223: (C114 = C118 & C113 = C117) by L221 , XTUPLE_0:1;
thus L224: ( C114 * C113 ) = ( ( (the Comp of C109) . (C110 , C111 , C112) ) . (C114 , C113) ) by L215 , L111
.= ( C116 * C115 ) by L219 , L217 , L218 , L222 , L223 , FUNCT_1:49;
end;
definition
let C119 being non  empty set;
func EnsCat C119 ->  strict  pseudo-functional non  empty AltCatStr means 
:L225: ((the carrier of it) = C119 & (for B105 , B106 being (object of it) holds <^ B105 , B106 ^> = ( Funcs (B105 , B106) )));
existence
proof
deffunc H6(set , set , set) = ( FuncComp (( Funcs ($1 , $2) ) , ( Funcs ($2 , $3) )) );
consider C120 being (ManySortedSet of [: C119 , C119 :]) such that L226: (for R1 being set holds (for R2 being set holds ((R1 in C119 & R2 in C119) implies ( C120 . (R1 , R2) ) = ( Funcs (R1 , R2) )))) from MSSLambda2;
consider C121 being (ManySortedSet of [: C119 , C119 , C119 :]) such that L227: (for R1 being set holds (for R2 being set holds (for R3 being set holds ((R1 in C119 & R2 in C119 & R3 in C119) implies ( C121 . (R1 , R2 , R3) ) = H6(R1 , R2 , R3))))) from MSSLambda3;
L228: C121 is  Function-yielding
proof
let R1 being set;
assume L229: R1 in ( dom C121 );
L230: R1 in [: C119 , C119 , C119 :] by L229 , PARTFUN1:def 2;
consider C122 , C123 , C124 being set such that L231: (C122 in C119 & C123 in C119 & C124 in C119) and L232: R1 = [ C122 , C123 , C124 ] by L230 , MCART_1:68;
L233: ( C121 . R1 ) = ( C121 . (C122 , C123 , C124) ) by L232 , MULTOP_1:def 1
.= ( FuncComp (( Funcs (C122 , C123) ) , ( Funcs (C123 , C124) )) ) by L227 , L231;
thus L234: thesis by L233;
end;
reconsider D33 = C121 as (ManySortedFunction of [: C119 , C119 , C119 :]) by L228;
L235:
now
let R1 being set;
reconsider D34 = ( D33 . R1 ) as Function;
assume L236: R1 in [: C119 , C119 , C119 :];
consider C125 , C126 , C127 being set such that L237: C125 in C119 and L238: C126 in C119 and L239: C127 in C119 and L240: R1 = [ C125 , C126 , C127 ] by L236 , MCART_1:68;
L241: ( {| C120 |} . R1 ) = ( {| C120 |} . (C125 , C126 , C127) ) by L240 , MULTOP_1:def 1
.= ( C120 . (C125 , C127) ) by L237 , L238 , L239 , L77;
L242: ( D33 . R1 ) = ( D33 . (C125 , C126 , C127) ) by L240 , MULTOP_1:def 1
.= ( FuncComp (( Funcs (C125 , C126) ) , ( Funcs (C126 , C127) )) ) by L227 , L237 , L238 , L239;
L243: (( C120 . (C125 , C126) ) = ( Funcs (C125 , C126) ) & ( C120 . (C126 , C127) ) = ( Funcs (C126 , C127) )) by L226 , L237 , L238 , L239;
L244: [: ( Funcs (C126 , C127) ) , ( Funcs (C125 , C126) ) :] = ( {| C120 , C120 |} . (C125 , C126 , C127) ) by L243 , L237 , L238 , L239 , L86
.= ( {| C120 , C120 |} . R1 ) by L240 , MULTOP_1:def 1;
L245: ( C120 . (C125 , C127) ) = ( Funcs (C125 , C127) ) by L226 , L237 , L239;
L246: ( rng D34 ) c= ( {| C120 |} . R1 ) by L245 , L242 , L241 , L157;
L247: ( dom D34 ) = [: ( Funcs (C126 , C127) ) , ( Funcs (C125 , C126) ) :] by L242 , PARTFUN1:def 2;
thus L248: ( D33 . R1 ) is (Function of ( {| C120 , C120 |} . R1 ) , ( {| C120 |} . R1 )) by L247 , L244 , L246 , FUNCT_2:2;
end;
reconsider D35 = D33 as (BinComp of C120) by L235 , PBOOLE:def 15;
set D36 = AltCatStr (# C119 , C120 , D35 #);
L249: D36 is  pseudo-functional
proof
let C128 , C129 , C130 being (object of D36);
L250: (<^ C128 , C129 ^> = ( Funcs (C128 , C129) ) & <^ C129 , C130 ^> = ( Funcs (C129 , C130) )) by L226;
L251: ( dom ( FuncComp (( Funcs (C128 , C129) ) , ( Funcs (C129 , C130) )) ) ) = [: <^ C129 , C130 ^> , <^ C128 , C129 ^> :] by L250 , PARTFUN1:def 2;
thus L252: ( (the Comp of D36) . (C128 , C129 , C130) ) = ( FuncComp (( Funcs (C128 , C129) ) , ( Funcs (C129 , C130) )) ) by L227
.= ( ( FuncComp (( Funcs (C128 , C129) ) , ( Funcs (C129 , C130) )) ) | ([: <^ C129 , C130 ^> , <^ C128 , C129 ^> :] qua set) ) by L251 , RELAT_1:68;
end;
reconsider D37 = D36 as  strict  pseudo-functional non  empty AltCatStr by L249;
take D37;
thus L253: (the carrier of D37) = C119;
let C131 , C132 being (object of D37);
thus L254: thesis by L226;
end;
uniqueness
proof
let C133 , C134 being  strict  pseudo-functional non  empty AltCatStr;
assume that
L255: (the carrier of C133) = C119
and
L256: (for B107 , B108 being (object of C133) holds <^ B107 , B108 ^> = ( Funcs (B107 , B108) ))
and
L257: (the carrier of C134) = C119
and
L258: (for B109 , B110 being (object of C134) holds <^ B109 , B110 ^> = ( Funcs (B109 , B110) ));
L259:
now
let R1 being set;
let R2 being set;
assume L260: (R1 in C119 & R2 in C119);
reconsider D38 = R1 , D39 = R2 as (object of C133) by L260 , L255;
reconsider D40 = R1 , D41 = R2 as (object of C134) by L257 , L260;
thus L261: ( (the Arrows of C133) . (R1 , R2) ) = <^ D38 , D39 ^>
.= ( Funcs (D38 , D39) ) by L256
.= <^ D40 , D41 ^> by L258
.= ( (the Arrows of C134) . (R1 , R2) );
end;
L262:
now
let R1 being set;
let R2 being set;
let R3 being set;
assume L263: (R1 in C119 & R2 in C119 & R3 in C119);
reconsider D42 = R1 , D43 = R2 , D44 = R3 as (object of C133) by L263 , L255;
reconsider D45 = R1 , D46 = R2 , D47 = R3 as (object of C134) by L257 , L263;
L264: (<^ D43 , D44 ^> = <^ D46 , D47 ^> & <^ D42 , D43 ^> = <^ D45 , D46 ^>) by L255 , L259;
thus L265: ( (the Comp of C133) . (R1 , R2 , R3) ) = ( ( FuncComp (( Funcs (D45 , D46) ) , ( Funcs (D46 , D47) )) ) | ([: <^ D46 , D47 ^> , <^ D45 , D46 ^> :] qua set) ) by L264 , L192
.= ( (the Comp of C134) . (R1 , R2 , R3) ) by L192;
end;
L266: (the Arrows of C133) = (the Arrows of C134) by L255 , L257 , L259 , L48;
thus L267: thesis by L266 , L255 , L257 , L262 , L60;
end;
end;
definition
let C135 being non  empty AltCatStr;
attr C135 is  associative
means
:L269: (the Comp of C135) is  associative;
attr C135 is  with_units
means
:L270: (the Comp of C135) is  with_left_units  with_right_units;
end;
L272: (for B111 being non  empty set holds ( EnsCat B111 ) is  transitive  associative  with_units)
proof
let C136 being non  empty set;
set D48 = (the Arrows of ( EnsCat C136 ));
set D49 = (the Comp of ( EnsCat C136 ));
thus L273: ( EnsCat C136 ) is  transitive
proof
let C137 , C138 , C139 being (object of ( EnsCat C136 ));
assume L274: (<^ C137 , C138 ^> <> ( {} ) & <^ C138 , C139 ^> <> ( {} ));
L275: (( Funcs (C137 , C138) ) <> ( {} ) & ( Funcs (C138 , C139) ) <> ( {} )) by L274 , L225;
L276: ( Funcs (C137 , C139) ) <> ( {} ) by L275 , L20;
thus L277: thesis by L276 , L225;
end;

thus L278: ( EnsCat C136 ) is  associative
proof
let C140 , C141 , C142 , C143 being (Element of ( EnsCat C136 ));
reconsider D50 = C140 , D51 = C141 , D52 = C142 , D53 = C143 as (object of ( EnsCat C136 ));
let C144 , C145 , C146 being set;
assume that
L279: C144 in ( D48 . (C140 , C141) )
and
L280: C145 in ( D48 . (C141 , C142) )
and
L281: C146 in ( D48 . (C142 , C143) );
reconsider D54 = C146 as (Morphism of D52 , D53) by L281;
reconsider D55 = C145 as (Morphism of D51 , D52) by L280;
L282: <^ D52 , D53 ^> = ( Funcs (C142 , C143) ) by L225;
L283: (<^ D50 , D51 ^> = ( Funcs (C140 , C141) ) & <^ D51 , D52 ^> = ( Funcs (C141 , C142) )) by L225;
reconsider D56 = C144 , D57 = C145 , D58 = C146 as Function by L283 , L279 , L280 , L281 , L282;
L284: ( D48 . (C142 , C143) ) = <^ D52 , D53 ^>;
L285: <^ D51 , D52 ^> <> ( {} ) by L280;
L286: <^ D51 , D53 ^> <> ( {} ) by L285 , L273 , L281 , L284 , L75;
L287: ( D54 * D55 ) = ( D58 * D57 ) by L286 , L280 , L281 , L214;
reconsider D59 = C144 as (Morphism of D50 , D51) by L279;
L288: ( D48 . (C140 , C141) ) = <^ D50 , D51 ^>;
L289: <^ D50 , D52 ^> <> ( {} ) by L288 , L273 , L279 , L285 , L75;
L290: ( D55 * D59 ) = ( D57 * D56 ) by L289 , L279 , L280 , L214;
L291: <^ D50 , D53 ^> <> ( {} ) by L273 , L281 , L284 , L289 , L75;
L292: ( ( D49 . (C141 , C142 , C143) ) . (C146 , C145) ) = ( D54 * D55 ) by L280 , L281 , L111;
L293: ( ( D49 . (C140 , C141 , C142) ) . (C145 , C144) ) = ( D55 * D59 ) by L279 , L280 , L111;
thus L294: ( ( D49 . (C140 , C142 , C143) ) . (C146 , ( ( D49 . (C140 , C141 , C142) ) . (C145 , C144) )) ) = ( D54 * ( D55 * D59 ) ) by L293 , L281 , L289 , L111
.= ( D58 * ( D57 * D56 ) ) by L281 , L289 , L291 , L290 , L214
.= ( ( D58 * D57 ) * D56 ) by RELAT_1:36
.= ( ( D54 * D55 ) * D59 ) by L279 , L286 , L291 , L287 , L214
.= ( ( D49 . (C140 , C141 , C143) ) . (( ( D49 . (C141 , C142 , C143) ) . (C146 , C145) ) , C144) ) by L279 , L286 , L292 , L111;
end;

thus L295: (the Comp of ( EnsCat C136 )) is  with_left_units
proof
let C147 being (Element of ( EnsCat C136 ));
reconsider D60 = C147 as (object of ( EnsCat C136 ));
take ( id C147 );
L296: <^ D60 , D60 ^> = ( Funcs (C147 , C147) ) by L225;
thus L297: ( id C147 ) in ( D48 . (C147 , C147) ) by L296 , L1;
reconsider D61 = ( id C147 ) as (Morphism of D60 , D60) by L296 , L1;
let C148 being (Element of ( EnsCat C136 ));
let C149 being set;
reconsider D62 = C148 as (object of ( EnsCat C136 ));
assume L298: C149 in ( D48 . (C148 , C147) );
reconsider D63 = C149 as (Morphism of D62 , D60) by L298;
L299: <^ D62 , D60 ^> = ( Funcs (C148 , C147) ) by L225;
reconsider D64 = C149 as (Function of C148 , C147) by L299 , L298 , FUNCT_2:66;
thus L300: ( ( D49 . (C148 , C147 , C147) ) . (( id C147 ) , C149) ) = ( D61 * D63 ) by L296 , L298 , L111
.= ( ( id C147 ) * D64 ) by L296 , L298 , L214
.= C149 by FUNCT_2:17;
end;

let C150 being (Element of ( EnsCat C136 ));
reconsider D65 = C150 as (object of ( EnsCat C136 ));
take ( id C150 );
L301: <^ D65 , D65 ^> = ( Funcs (C150 , C150) ) by L225;
thus L302: ( id C150 ) in ( D48 . (C150 , C150) ) by L301 , L1;
reconsider D66 = ( id C150 ) as (Morphism of D65 , D65) by L301 , L1;
let C151 being (Element of ( EnsCat C136 ));
let C152 being set;
reconsider D67 = C151 as (object of ( EnsCat C136 ));
assume L303: C152 in ( D48 . (C150 , C151) );
reconsider D68 = C152 as (Morphism of D65 , D67) by L303;
L304: <^ D65 , D67 ^> = ( Funcs (C150 , C151) ) by L225;
reconsider D69 = C152 as (Function of C150 , C151) by L304 , L303 , FUNCT_2:66;
thus L305: ( ( D49 . (C150 , C150 , C151) ) . (C152 , ( id C150 )) ) = ( D68 * D66 ) by L301 , L303 , L111
.= ( D69 * ( id C150 ) ) by L301 , L303 , L214
.= C152 by FUNCT_2:17;
end;
registration
cluster  transitive  associative  with_units  strict for non  empty non  empty non  empty non  empty AltCatStr;
existence
proof
take ( EnsCat { ( {} ) } );
thus L306: thesis by L272;
end;
end;
theorem
L308: (for B112 being  transitive non  empty AltCatStr holds (for B113 , B114 , B115 being (object of B112) holds (( dom ( (the Comp of B112) . (B113 , B114 , B115) ) ) = [: <^ B114 , B115 ^> , <^ B113 , B114 ^> :] & ( rng ( (the Comp of B112) . (B113 , B114 , B115) ) ) c= <^ B113 , B115 ^>)))
proof
let C153 being  transitive non  empty AltCatStr;
let C154 , C155 , C156 being (object of C153);
L309: (<^ C154 , C156 ^> = ( {} ) implies (<^ C154 , C155 ^> = ( {} ) or <^ C155 , C156 ^> = ( {} ))) by L75;
L310: (<^ C154 , C156 ^> = ( {} ) implies [: <^ C155 , C156 ^> , <^ C154 , C155 ^> :] = ( {} )) by L309;
thus L311: thesis by L310 , FUNCT_2:def 1 , RELAT_1:def 19;
end;
theorem
L312: (for B116 being  with_units non  empty AltCatStr holds (for B117 being (object of B116) holds <^ B117 , B117 ^> <> ( {} )))
proof
let C157 being  with_units non  empty AltCatStr;
let C158 being (object of C157);
L313: (the Comp of C157) is  with_left_units by L270;
L314: (ex B118 being set st (B118 in ( (the Arrows of C157) . (C158 , C158) ) & (for B119 being (Element of C157) holds (for B120 being set holds (B120 in ( (the Arrows of C157) . (B119 , C158) ) implies ( ( (the Comp of C157) . (B119 , C158 , C158) ) . (B118 , B120) ) = B120))))) by L313 , L104;
thus L315: thesis by L314;
end;
registration
let C159 being non  empty set;
cluster ( EnsCat C159 ) ->  transitive  associative  with_units;
coherence by L272;
end;
registration
cluster  quasi-functional  semi-functional  transitive ->  pseudo-functional for non  empty non  empty non  empty non  empty AltCatStr;
coherence
proof
let C160 being non  empty AltCatStr;
assume L317: C160 is  quasi-functional  semi-functional  transitive;
let C161 , C162 , C163 being (object of C160);
set D70 = ( (the Comp of C160) . (C161 , C162 , C163) );
set D71 = ( ( FuncComp (( Funcs (C161 , C162) ) , ( Funcs (C162 , C163) )) ) | ([: <^ C162 , C163 ^> , <^ C161 , C162 ^> :] qua set) );
per cases ;
suppose L318: (<^ C162 , C163 ^> = ( {} ) or <^ C161 , C162 ^> = ( {} ));

thus L319: D70 = ( {} ) by L318
.= D71 by L318;
end;
suppose L320: (<^ C162 , C163 ^> <> ( {} ) & <^ C161 , C162 ^> <> ( {} ));

L321: <^ C161 , C163 ^> <> ( {} ) by L320 , L317 , L75;
L322: ( dom D70 ) = [: <^ C162 , C163 ^> , <^ C161 , C162 ^> :] by L321 , FUNCT_2:def 1;
L323: (<^ C162 , C163 ^> c= ( Funcs (C162 , C163) ) & <^ C161 , C162 ^> c= ( Funcs (C161 , C162) )) by L317 , L190;
L324: ( dom ( FuncComp (( Funcs (C161 , C162) ) , ( Funcs (C162 , C163) )) ) ) = [: ( Funcs (C162 , C163) ) , ( Funcs (C161 , C162) ) :] by PARTFUN1:def 2;
L325: ( dom D71 ) = ( [: ( Funcs (C162 , C163) ) , ( Funcs (C161 , C162) ) :] /\ [: <^ C162 , C163 ^> , <^ C161 , C162 ^> :] ) by L324 , RELAT_1:61;
L326: ( dom D70 ) = ( dom D71 ) by L325 , L323 , L322 , XBOOLE_1:28 , ZFMISC_1:96;
L327:
now
let R1 being set;
assume L328: R1 in ( dom D70 );
consider C164 , C165 being set such that L329: C164 in <^ C162 , C163 ^> and L330: C165 in <^ C161 , C162 ^> and L331: R1 = [ C164 , C165 ] by L328 , L322 , ZFMISC_1:84;
reconsider D72 = C165 as (Morphism of C161 , C162) by L330;
reconsider D73 = C164 as (Morphism of C162 , C163) by L329;
reconsider D74 = C164 , D75 = C165 as Function by L323 , L329 , L330;
thus L332: ( D70 . R1 ) = ( ( (the Comp of C160) . (C161 , C162 , C163) ) . (D73 , D72) ) by L331
.= ( D73 * D72 ) by L320 , L111
.= ( D74 * D75 ) by L317 , L320 , L321 , L191
.= ( ( FuncComp (( Funcs (C161 , C162) ) , ( Funcs (C162 , C163) )) ) . (D74 , D75) ) by L323 , L329 , L330 , L135
.= ( D71 . R1 ) by L326 , L328 , L331 , FUNCT_1:47;
end;
thus L333: thesis by L327 , L326 , FUNCT_1:2;
end;
end;
cluster  with_units  pseudo-functional  transitive ->  quasi-functional  semi-functional for non  empty non  empty non  empty non  empty AltCatStr;
coherence
proof
let C166 being non  empty AltCatStr;
assume that
L335: C166 is  with_units  pseudo-functional  transitive;
thus L336: C166 is  quasi-functional
proof
let C167 , C168 being (object of C166);
per cases ;
suppose L337: <^ C167 , C168 ^> = ( {} );

thus L338: thesis by L337 , XBOOLE_1:2;
end;
suppose L339: <^ C167 , C168 ^> <> ( {} );

set D76 = ( (the Comp of C166) . (C167 , C167 , C168) );
set D77 = ( FuncComp (( Funcs (C167 , C167) ) , ( Funcs (C167 , C168) )) );
L340: ( dom D76 ) = [: <^ C167 , C168 ^> , <^ C167 , C167 ^> :] by L339 , FUNCT_2:def 1;
L341: (( dom D77 ) = [: ( Funcs (C167 , C168) ) , ( Funcs (C167 , C167) ) :] & D76 = ( D77 | ([: <^ C167 , C168 ^> , <^ C167 , C167 ^> :] qua set) )) by L335 , L192 , PARTFUN1:def 2;
L342: [: <^ C167 , C168 ^> , <^ C167 , C167 ^> :] c= [: ( Funcs (C167 , C168) ) , ( Funcs (C167 , C167) ) :] by L341 , L340 , RELAT_1:60;
L343: <^ C167 , C167 ^> <> ( {} ) by L335 , L312;
thus L344: thesis by L343 , L339 , L342 , ZFMISC_1:114;
end;
end;

let C169 , C170 , C171 being (object of C166);
thus L346: thesis by L335 , L214;
end;
end;
definition
mode category
 is  transitive  associative  with_units non  empty AltCatStr;
end;
begin
definition
let C172 being  with_units non  empty AltCatStr;
let C173 being (object of C172);
func idm C173 -> (Morphism of C173 , C173) means 
:L349: (for B121 being (object of C172) holds (<^ C173 , B121 ^> <> ( {} ) implies (for B122 being (Morphism of C173 , B121) holds ( B122 * it ) = B122)));
existence
proof
L350: (the Comp of C172) is  with_right_units by L270;
consider C174 being set such that L351: C174 in ( (the Arrows of C172) . (C173 , C173) ) and L352: (for B123 being (Element of C172) holds (for B124 being set holds (B124 in ( (the Arrows of C172) . (C173 , B123) ) implies ( ( (the Comp of C172) . (C173 , C173 , B123) ) . (B124 , C174) ) = B124))) by L350 , L103;
reconsider D78 = C174 as (Morphism of C173 , C173) by L351;
take D78;
let C175 being (object of C172);
assume that
L353: <^ C173 , C175 ^> <> ( {} );
let C176 being (Morphism of C173 , C175);
thus L354: ( C176 * D78 ) = ( ( (the Comp of C172) . (C173 , C173 , C175) ) . (C176 , D78) ) by L351 , L353 , L111
.= C176 by L352 , L353;
end;
uniqueness
proof
L355: (the Comp of C172) is  with_left_units by L270;
consider C177 being set such that L356: C177 in ( (the Arrows of C172) . (C173 , C173) ) and L357: (for B125 being (Element of C172) holds (for B126 being set holds (B126 in ( (the Arrows of C172) . (B125 , C173) ) implies ( ( (the Comp of C172) . (B125 , C173 , C173) ) . (C177 , B126) ) = B126))) by L355 , L104;
reconsider D79 = C177 as (Morphism of C173 , C173) by L356;
let C178 , C179 being (Morphism of C173 , C173);
assume that
L358: (for B127 being (object of C172) holds (<^ C173 , B127 ^> <> ( {} ) implies (for B128 being (Morphism of C173 , B127) holds ( B128 * C178 ) = B128)))
and
L359: (for B129 being (object of C172) holds (<^ C173 , B129 ^> <> ( {} ) implies (for B130 being (Morphism of C173 , B129) holds ( B130 * C179 ) = B130)));
L360: <^ C173 , C173 ^> <> ( {} ) by L312;
thus L361: C178 = ( ( (the Comp of C172) . (C173 , C173 , C173) ) . (D79 , C178) ) by L360 , L357
.= ( D79 * C178 ) by L360 , L111
.= D79 by L358 , L312
.= ( D79 * C179 ) by L359 , L312
.= ( ( (the Comp of C172) . (C173 , C173 , C173) ) . (D79 , C179) ) by L360 , L111
.= C179 by L357 , L360;
end;
end;
theorem
L363: (for B131 being  with_units non  empty AltCatStr holds (for B132 being (object of B131) holds ( idm B132 ) in <^ B132 , B132 ^>))
proof
let C180 being  with_units non  empty AltCatStr;
let C181 being (object of C180);
L364: <^ C181 , C181 ^> <> ( {} ) by L312;
thus L365: thesis by L364;
end;
theorem
L366: (for B133 being  with_units non  empty AltCatStr holds (for B134 , B135 being (object of B133) holds (<^ B134 , B135 ^> <> ( {} ) implies (for B136 being (Morphism of B134 , B135) holds ( ( idm B135 ) * B136 ) = B136))))
proof
let C182 being  with_units non  empty AltCatStr;
let C183 , C184 being (object of C182);
assume that
L367: <^ C183 , C184 ^> <> ( {} );
let C185 being (Morphism of C183 , C184);
L368: (the Comp of C182) is  with_left_units by L270;
consider C186 being set such that L369: C186 in ( (the Arrows of C182) . (C184 , C184) ) and L370: (for B137 being (Element of C182) holds (for B138 being set holds (B138 in ( (the Arrows of C182) . (B137 , C184) ) implies ( ( (the Comp of C182) . (B137 , C184 , C184) ) . (C186 , B138) ) = B138))) by L368 , L104;
reconsider D80 = C186 as (Morphism of C184 , C184) by L369;
L371: ( idm C184 ) in <^ C184 , C184 ^> by L363;
L372: D80 = ( D80 * ( idm C184 ) ) by L371 , L349
.= ( ( (the Comp of C182) . (C184 , C184 , C184) ) . (D80 , ( idm C184 )) ) by L369 , L111
.= ( idm C184 ) by L370 , L363;
thus L373: ( ( idm C184 ) * C185 ) = ( ( (the Comp of C182) . (C183 , C184 , C184) ) . (D80 , C185) ) by L372 , L367 , L369 , L111
.= C185 by L367 , L370;
end;
theorem
L374: (for B139 being  associative  transitive non  empty AltCatStr holds (for B140 , B141 , B142 , B143 being (object of B139) holds ((<^ B140 , B141 ^> <> ( {} ) & <^ B141 , B142 ^> <> ( {} ) & <^ B142 , B143 ^> <> ( {} )) implies (for B144 being (Morphism of B140 , B141) holds (for B145 being (Morphism of B141 , B142) holds (for B146 being (Morphism of B142 , B143) holds ( B146 * ( B145 * B144 ) ) = ( ( B146 * B145 ) * B144 )))))))
proof
let C187 being  associative  transitive non  empty AltCatStr;
let C188 , C189 , C190 , C191 being (object of C187);
assume that
L375: <^ C188 , C189 ^> <> ( {} )
and
L376: <^ C189 , C190 ^> <> ( {} )
and
L377: <^ C190 , C191 ^> <> ( {} );
let C192 being (Morphism of C188 , C189);
let C193 being (Morphism of C189 , C190);
let C194 being (Morphism of C190 , C191);
L378: (<^ C189 , C191 ^> <> ( {} ) & ( C194 * C193 ) = ( ( (the Comp of C187) . (C189 , C190 , C191) ) . (C194 , C193) )) by L376 , L377 , L75 , L111;
L379: (the Comp of C187) is  associative by L269;
L380: (<^ C188 , C190 ^> <> ( {} ) & ( C193 * C192 ) = ( ( (the Comp of C187) . (C188 , C189 , C190) ) . (C193 , C192) )) by L375 , L376 , L75 , L111;
thus L381: ( C194 * ( C193 * C192 ) ) = ( ( (the Comp of C187) . (C188 , C190 , C191) ) . (C194 , ( ( (the Comp of C187) . (C188 , C189 , C190) ) . (C193 , C192) )) ) by L380 , L377 , L111
.= ( ( (the Comp of C187) . (C188 , C189 , C191) ) . (( ( (the Comp of C187) . (C189 , C190 , C191) ) . (C194 , C193) ) , C192) ) by L375 , L376 , L377 , L379 , L102
.= ( ( C194 * C193 ) * C192 ) by L375 , L378 , L111;
end;
begin
definition
let C195 being AltCatStr;
attr C195 is  quasi-discrete
means
:L382: (for B147 , B148 being (object of C195) holds (<^ B147 , B148 ^> <> ( {} ) implies B147 = B148));
attr C195 is  pseudo-discrete
means
:L383: (for B149 being (object of C195) holds <^ B149 , B149 ^> is  trivial);
end;
theorem
L385: (for B150 being  with_units non  empty AltCatStr holds (B150 is  pseudo-discrete iff (for B151 being (object of B150) holds <^ B151 , B151 ^> = { ( idm B151 ) })))
proof
let C196 being  with_units non  empty AltCatStr;
thus L386:now
assume L387: C196 is  pseudo-discrete;
let C197 being (object of C196);
L388:
now
let R2 being set;
thus L389:now
L390: (( idm C197 ) in <^ C197 , C197 ^> & <^ C197 , C197 ^> is  trivial) by L387 , L383 , L363;
consider R1 being set such that L391: <^ C197 , C197 ^> = { R1 } by L390 , ZFMISC_1:131;
assume L392: R2 in <^ C197 , C197 ^>;
L393: R2 = R1 by L392 , L391 , TARSKI:def 1;
thus L394: R2 = ( idm C197 ) by L393 , L391 , TARSKI:def 1;
end;
thus L395: (R2 = ( idm C197 ) implies R2 in <^ C197 , C197 ^>) by L363;
end;
thus L396: <^ C197 , C197 ^> = { ( idm C197 ) } by L388 , TARSKI:def 1;
end;
assume L397: (for B152 being (object of C196) holds <^ B152 , B152 ^> = { ( idm B152 ) });
let C198 being (object of C196);
L398: <^ C198 , C198 ^> = { ( idm C198 ) } by L397;
thus L399: thesis by L398;
end;
registration
cluster 1 -element ->  quasi-discrete for AltCatStr;
coherence
proof
let C199 being AltCatStr;
assume L400: C199 is 1 -element;
let C200 , C201 being (object of C199);
assume that
L401: <^ C200 , C201 ^> <> ( {} );
thus L402: thesis by L400 , STRUCT_0:def 10;
end;
end;
theorem
L404: ( EnsCat 1 ) is  pseudo-discrete 1 -element
proof
L405: (the carrier of ( EnsCat 1 )) = { ( {} ) } by L225 , CARD_1:49;
thus L406:now
let C202 being (object of ( EnsCat 1 ));
L407: C202 = ( {} ) by L405 , TARSKI:def 1;
thus L408: <^ C202 , C202 ^> is  trivial by L407 , L225 , L4;
end;
thus L409: (the carrier of ( EnsCat 1 )) is 1 -element by L405;
end;
registration
cluster  pseudo-discrete  trivial  strict for category;
existence by L404;
end;
registration
cluster  quasi-discrete  pseudo-discrete  trivial  strict for category;
existence by L404;
end;
definition
mode discrete_category
 is  quasi-discrete  pseudo-discrete category;
end;
definition
let C203 being non  empty set;
func DiscrCat C203 ->  quasi-discrete  strict non  empty AltCatStr means 
:L413: ((the carrier of it) = C203 & (for B153 being (object of it) holds <^ B153 , B153 ^> = { ( id B153 ) }));
existence
proof
deffunc H7((Element of C203) , set , set) = ( IFEQ ($1 , $2 , ( IFEQ ($2 , $3 , ( [ ( id $1 ) , ( id $1 ) ] .--> ( id $1 ) ) , ( {} )) ) , ( {} )) );
deffunc H8((Element of C203) , set) = ( IFEQ ($1 , $2 , { ( id $1 ) } , ( {} )) );
consider C204 being (ManySortedSet of [: C203 , C203 :]) such that L414: (for B154 , B155 being (Element of C203) holds ( C204 . (B154 , B155) ) = H8(B154 , B155)) from MSSLambda2D;
consider C205 being (ManySortedSet of [: C203 , C203 , C203 :]) such that L415: (for B156 , B157 , B158 being (Element of C203) holds ( C205 . (B156 , B157 , B158) ) = H7(B156 , B157 , B158)) from MSSLambda3D;
L416:
now
let R1 being set;
assume L417: R1 in [: C203 , C203 , C203 :];
consider C206 , C207 , C208 being set such that L418: (C206 in C203 & C207 in C203 & C208 in C203) and L419: R1 = [ C206 , C207 , C208 ] by L417 , MCART_1:68;
reconsider D81 = C206 , D82 = C207 , D83 = C208 as (Element of C203) by L418;
per cases ;
suppose that L420: D81 = D82
and
L421: D82 = D83;
L422: ( C204 . (D81 , D81) ) = ( IFEQ (D81 , D81 , { ( id D81 ) } , ( {} )) ) by L414
.= { ( id D81 ) } by FUNCOP_1:def 8;
L423: ( C205 . R1 ) = ( C205 . (D81 , D82 , D83) ) by L419 , MULTOP_1:def 1
.= ( IFEQ (D81 , D82 , ( IFEQ (D82 , D83 , ( [ ( id D81 ) , ( id D81 ) ] .--> ( id D81 ) ) , ( {} )) ) , ( {} )) ) by L415
.= ( IFEQ (D82 , D83 , ( [ ( id D81 ) , ( id D81 ) ] .--> ( id D81 ) ) , ( {} )) ) by L420 , FUNCOP_1:def 8
.= ( [ ( id D81 ) , ( id D81 ) ] .--> ( id D81 ) ) by L421 , FUNCOP_1:def 8;
L424: ( {| C204 |} . R1 ) = ( {| C204 |} . (D81 , D81 , D81) ) by L419 , L420 , L421 , MULTOP_1:def 1
.= { ( id D81 ) } by L422 , L77;
L425: ( {| C204 , C204 |} . R1 ) = ( {| C204 , C204 |} . (D81 , D81 , D81) ) by L419 , L420 , L421 , MULTOP_1:def 1
.= [: { ( id D81 ) } , { ( id D81 ) } :] by L422 , L86
.= { [ ( id D81 ) , ( id D81 ) ] } by ZFMISC_1:29
.= ( dom ( [ ( id D81 ) , ( id D81 ) ] .--> ( id D81 ) ) ) by FUNCOP_1:13;
thus L426: ( C205 . R1 ) is (Function of ( {| C204 , C204 |} . R1 ) , ( {| C204 |} . R1 )) by L425 , L423 , L424 , FUNCT_2:def 1;
end;
suppose L427: (D81 <> D82 or D82 <> D83);

L428:
now
per cases  by L427;
suppose L429: D81 <> D82;

thus L430: ( C205 . R1 ) = ( C205 . (D81 , D82 , D83) ) by L419 , MULTOP_1:def 1
.= ( IFEQ (D81 , D82 , ( IFEQ (D82 , D83 , ( [ ( id D81 ) , ( id D81 ) ] .--> ( id D81 ) ) , ( {} )) ) , ( {} )) ) by L415
.= ( {} ) by L429 , FUNCOP_1:def 8;
end;
suppose that L431: D81 = D82
and
L432: D82 <> D83;
thus L433: ( C205 . R1 ) = ( C205 . (D81 , D82 , D83) ) by L419 , MULTOP_1:def 1
.= ( IFEQ (D81 , D82 , ( IFEQ (D82 , D83 , ( [ ( id D81 ) , ( id D81 ) ] .--> ( id D81 ) ) , ( {} )) ) , ( {} )) ) by L415
.= ( IFEQ (D82 , D83 , ( [ ( id D81 ) , ( id D81 ) ] .--> ( id D81 ) ) , ( {} )) ) by L431 , FUNCOP_1:def 8
.= ( {} ) by L432 , FUNCOP_1:def 8;
end;
end;
L435: (( C204 . (D81 , D82) ) = ( IFEQ (D81 , D82 , { ( id D81 ) } , ( {} )) ) & ( C204 . (D82 , D83) ) = ( IFEQ (D82 , D83 , { ( id D82 ) } , ( {} )) )) by L414;
L436: (( C204 . (D81 , D82) ) = ( {} ) or ( C204 . (D82 , D83) ) = ( {} )) by L435 , L427 , FUNCOP_1:def 8;
L437: ( {| C204 , C204 |} . R1 ) = ( {| C204 , C204 |} . (D81 , D82 , D83) ) by L419 , MULTOP_1:def 1
.= [: ( C204 . (D82 , D83) ) , ( C204 . (D81 , D82) ) :] by L86
.= ( {} ) by L436;
thus L438: ( C205 . R1 ) is (Function of ( {| C204 , C204 |} . R1 ) , ( {| C204 |} . R1 )) by L437 , L428 , FUNCT_2:2 , RELAT_1:38 , XBOOLE_1:2;
end;
end;
L440: C205 is  Function-yielding
proof
let R1 being set;
assume L441: R1 in ( dom C205 );
L442: R1 in [: C203 , C203 , C203 :] by L441 , PARTFUN1:def 2;
thus L443: thesis by L442 , L416;
end;
reconsider D84 = C205 as (ManySortedFunction of [: C203 , C203 , C203 :]) by L440;
reconsider D85 = D84 as (BinComp of C204) by L416 , PBOOLE:def 15;
set D86 = AltCatStr (# C203 , C204 , D85 #);
L444: D86 is  quasi-discrete
proof
let C209 , C210 being (object of D86);
assume that
L445: <^ C209 , C210 ^> <> ( {} )
and
L446: C209 <> C210;
L447: <^ C209 , C210 ^> = ( IFEQ (C209 , C210 , { ( id C209 ) } , ( {} )) ) by L414
.= ( {} ) by L446 , FUNCOP_1:def 8;
thus L448: contradiction by L447 , L445;
end;
reconsider D87 = AltCatStr (# C203 , C204 , D85 #) as  quasi-discrete  strict non  empty AltCatStr by L444;
take D87;
thus L449: (the carrier of D87) = C203;
let C211 being (object of D87);
thus L450: <^ C211 , C211 ^> = ( IFEQ (C211 , C211 , { ( id C211 ) } , ( {} )) ) by L414
.= { ( id C211 ) } by FUNCOP_1:def 8;
end;
correctness
proof
let C212 , C213 being  quasi-discrete  strict non  empty AltCatStr;
assume that
L451: (the carrier of C212) = C203
and
L452: (for B159 being (object of C212) holds <^ B159 , B159 ^> = { ( id B159 ) })
and
L453: (the carrier of C213) = C203
and
L454: (for B160 being (object of C213) holds <^ B160 , B160 ^> = { ( id B160 ) });
L455:
now
let R1 being set;
let R2 being set;
let R3 being set;
assume that
L456: R1 in C203
and
L457: (R2 in C203 & R3 in C203);
reconsider D88 = R1 as (object of C213) by L453 , L456;
reconsider D89 = R1 as (object of C212) by L451 , L456;
per cases ;
suppose L458: (R1 = R2 & R2 = R3);

L459: (<^ D88 , D88 ^> = { ( id D88 ) } & ( (the Comp of C213) . (D88 , D88 , D88) ) is (Function of [: <^ D88 , D88 ^> , <^ D88 , D88 ^> :] , <^ D88 , D88 ^>)) by L454;
L460: (<^ D89 , D89 ^> = { ( id D89 ) } & ( (the Comp of C212) . (D89 , D89 , D89) ) is (Function of [: <^ D89 , D89 ^> , <^ D89 , D89 ^> :] , <^ D89 , D89 ^>)) by L452;
thus L461: ( (the Comp of C212) . (R1 , R2 , R3) ) = ( (( id R1 ) , ( id R1 )) :-> ( id R1 ) ) by L460 , L458 , FUNCOP_1:def 10
.= ( (the Comp of C213) . (R1 , R2 , R3) ) by L458 , L459 , FUNCOP_1:def 10;
end;
suppose L462: (R1 <> R2 or R2 <> R3);

reconsider D90 = R2 , D91 = R3 as (object of C212) by L451 , L457;
L463: (<^ D89 , D90 ^> = ( {} ) or <^ D90 , D91 ^> = ( {} )) by L462 , L382;
reconsider D92 = R2 , D93 = R3 as (object of C213) by L453 , L457;
L464: (( (the Comp of C213) . (D88 , D92 , D93) ) is (Function of [: <^ D92 , D93 ^> , <^ D88 , D92 ^> :] , <^ D88 , D93 ^>) & ( (the Comp of C212) . (D89 , D90 , D91) ) is (Function of [: <^ D90 , D91 ^> , <^ D89 , D90 ^> :] , <^ D89 , D91 ^>));
L465: (<^ D88 , D92 ^> = ( {} ) or <^ D92 , D93 ^> = ( {} )) by L462 , L382;
thus L466: ( (the Comp of C212) . (R1 , R2 , R3) ) = ( (the Comp of C213) . (R1 , R2 , R3) ) by L465 , L463 , L464;
end;
end;
L468:
now
let C214 , C215 being (Element of C203);
reconsider D94 = C214 as (object of C213) by L453;
reconsider D95 = C214 as (object of C212) by L451;
per cases ;
suppose L469: C214 = C215;

thus L470: ( (the Arrows of C212) . (C214 , C215) ) = <^ D95 , D95 ^> by L469
.= { ( id C214 ) } by L452
.= <^ D94 , D94 ^> by L454
.= ( (the Arrows of C213) . (C214 , C215) ) by L469;
end;
suppose L471: C214 <> C215;

reconsider D96 = C215 as (object of C213) by L453;
reconsider D97 = C215 as (object of C212) by L451;
thus L472: ( (the Arrows of C212) . (C214 , C215) ) = <^ D95 , D97 ^>
.= ( {} ) by L471 , L382
.= <^ D94 , D96 ^> by L471 , L382
.= ( (the Arrows of C213) . (C214 , C215) );
end;
end;
L474: (the Arrows of C212) = (the Arrows of C213) by L468 , L451 , L453 , L56;
thus L475: thesis by L474 , L451 , L453 , L455 , L60;
end;
end;
registration
cluster  quasi-discrete ->  transitive for AltCatStr;
coherence
proof
let C216 being AltCatStr;
assume L477: C216 is  quasi-discrete;
let C217 , C218 , C219 being (object of C216);
assume L478: (<^ C217 , C218 ^> <> ( {} ) & <^ C218 , C219 ^> <> ( {} ));
thus L479: thesis by L478 , L477 , L382;
end;
end;
theorem
L481: (for B161 being non  empty set holds (for B162 , B163 , B164 being (object of ( DiscrCat B161 )) holds ((B162 <> B163 or B163 <> B164) implies ( (the Comp of ( DiscrCat B161 )) . (B162 , B163 , B164) ) = ( {} ))))
proof
let C220 being non  empty set;
let C221 , C222 , C223 being (object of ( DiscrCat C220 ));
assume L482: (C221 <> C222 or C222 <> C223);
L483: (<^ C221 , C222 ^> = ( {} ) or <^ C222 , C223 ^> = ( {} )) by L482 , L382;
thus L484: thesis by L483;
end;
theorem
L485: (for B165 being non  empty set holds (for B166 being (object of ( DiscrCat B165 )) holds ( (the Comp of ( DiscrCat B165 )) . (B166 , B166 , B166) ) = ( (( id B166 ) , ( id B166 )) :-> ( id B166 ) )))
proof
let C224 being non  empty set;
let C225 being (object of ( DiscrCat C224 ));
L486: <^ C225 , C225 ^> = { ( id C225 ) } by L413;
thus L487: thesis by L486 , FUNCOP_1:def 10;
end;
registration
let C226 being non  empty set;
cluster ( DiscrCat C226 ) ->  pseudo-functional  pseudo-discrete  with_units  associative;
coherence
proof
set D98 = ( DiscrCat C226 );
thus L488: D98 is  pseudo-functional
proof
let C227 , C228 , C229 being (object of D98);
L489: ( id C227 ) in ( Funcs (C227 , C227) ) by L1;
per cases ;
suppose L490: (C227 = C228 & C228 = C229);

L491: <^ C228 , C229 ^> = { ( id C227 ) } by L490 , L413;
L492: <^ C227 , C228 ^> c= ( Funcs (C227 , C228) ) by L491 , L489 , L490 , ZFMISC_1:31;
thus L493: ( (the Comp of D98) . (C227 , C228 , C229) ) = ( (( id C227 ) , ( id C227 )) :-> ( id C227 ) ) by L490 , L485
.= ( FuncComp ({ ( id C227 ) } , { ( id C227 ) }) ) by L166
.= ( ( FuncComp (( Funcs (C227 , C228) ) , ( Funcs (C228 , C229) )) ) | ([: <^ C228 , C229 ^> , <^ C227 , C228 ^> :] qua set) ) by L490 , L491 , L492 , L182;
end;
suppose L494: (C227 <> C228 or C228 <> C229);

L495: (<^ C228 , C229 ^> = ( {} ) or <^ C227 , C228 ^> = ( {} )) by L494 , L382;
thus L496: ( (the Comp of D98) . (C227 , C228 , C229) ) = ( {} ) by L494 , L481
.= ( ( FuncComp (( Funcs (C227 , C228) ) , ( Funcs (C228 , C229) )) ) | ([: <^ C228 , C229 ^> , <^ C227 , C228 ^> :] qua set) ) by L495;
end;
end;

thus L498: D98 is  pseudo-discrete
proof
let C230 being (object of D98);
L499: <^ C230 , C230 ^> = { ( id C230 ) } by L413;
thus L500: thesis by L499;
end;

thus L501: D98 is  with_units
proof
thus L502: (the Comp of D98) is  with_left_units
proof
let C231 being (Element of D98);
reconsider D99 = C231 as (object of D98);
take ( id D99 );
L503: ( (the Arrows of D98) . (C231 , C231) ) = <^ D99 , D99 ^>
.= { ( id D99 ) } by L413;
thus L504: ( id D99 ) in ( (the Arrows of D98) . (C231 , C231) ) by L503 , TARSKI:def 1;
let C232 being (Element of D98);
let C233 being set;
assume that
L505: C233 in ( (the Arrows of D98) . (C232 , C231) );
reconsider D100 = C232 as (object of D98);
L506: ( (the Arrows of D98) . (C232 , C231) ) = <^ D100 , D99 ^>;
L507: D100 = D99 by L506 , L505 , L382;
L508: C233 in { ( id D100 ) } by L507 , L505 , L506 , L413;
L509: C233 = ( id D100 ) by L508 , TARSKI:def 1;
thus L510: ( ( (the Comp of D98) . (C232 , C231 , C231) ) . (( id D99 ) , C233) ) = ( ( (( id D100 ) , ( id D100 )) :-> ( id D100 ) ) . (( id D99 ) , C233) ) by L507 , L485
.= C233 by L507 , L509 , L69;
end;

let C234 being (Element of D98);
reconsider D101 = C234 as (object of D98);
take ( id D101 );
L511: ( (the Arrows of D98) . (C234 , C234) ) = <^ D101 , D101 ^>
.= { ( id D101 ) } by L413;
thus L512: ( id D101 ) in ( (the Arrows of D98) . (C234 , C234) ) by L511 , TARSKI:def 1;
let C235 being (Element of D98);
let C236 being set;
assume that
L513: C236 in ( (the Arrows of D98) . (C234 , C235) );
reconsider D102 = C235 as (object of D98);
L514: ( (the Arrows of D98) . (C234 , C235) ) = <^ D101 , D102 ^>;
L515: D102 = D101 by L514 , L513 , L382;
L516: C236 in { ( id D102 ) } by L515 , L513 , L514 , L413;
L517: C236 = ( id D102 ) by L516 , TARSKI:def 1;
thus L518: ( ( (the Comp of D98) . (C234 , C234 , C235) ) . (C236 , ( id D101 )) ) = ( ( (( id D102 ) , ( id D102 )) :-> ( id D102 ) ) . (C236 , ( id D101 )) ) by L515 , L485
.= C236 by L515 , L517 , L69;
end;

thus L519: D98 is  associative
proof
let C237 , C238 , C239 , C240 being (Element of D98);
set D103 = (the Arrows of D98);
set D104 = (the Comp of D98);
reconsider D105 = C237 , D106 = C238 , D107 = C239 , D108 = C240 as (object of D98);
let C241 , C242 , C243 being set;
assume that
L520: C241 in ( D103 . (C237 , C238) )
and
L521: C242 in ( D103 . (C238 , C239) )
and
L522: C243 in ( D103 . (C239 , C240) );
L523: C241 in <^ D105 , D106 ^> by L520;
L524: D105 = D106 by L523 , L382;
L525: <^ D105 , D105 ^> = { ( id D105 ) } by L413;
L526: C241 = ( id D105 ) by L525 , L520 , L524 , TARSKI:def 1;
L527: C242 in <^ D106 , D107 ^> by L521;
L528: D106 = D107 by L527 , L382;
L529: C242 = ( id D105 ) by L528 , L521 , L524 , L525 , TARSKI:def 1;
L530: ( D104 . (D105 , D105 , D105) ) = ( (( id D105 ) , ( id D105 )) :-> ( id D105 ) ) by L485;
L531: C243 in <^ D107 , D108 ^> by L522;
L532: D107 = D108 by L531 , L382;
L533: C243 = ( id D105 ) by L532 , L522 , L524 , L528 , L525 , TARSKI:def 1;
thus L534: thesis by L533 , L524 , L528 , L532 , L526 , L529 , L530 , L69;
end;

end;
end;
