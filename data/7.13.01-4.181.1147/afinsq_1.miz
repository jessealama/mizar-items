:: Zero Based Finite Sequences
::  by Tetsuya Tsunetou , Grzegorz Bancerek and Yatsuka Nakamura
::
:: Received September 28, 2001
:: Copyright (c) 2001-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, FUNCT_1, ARYTM_3, XXREAL_0, XBOOLE_0, TARSKI,
      NAT_1, ORDINAL1, FINSEQ_1, CARD_1, FINSET_1, RELAT_1, PARTFUN1, FUNCOP_1,
      ORDINAL4, ORDINAL2, ARYTM_1, REAL_1, ZFMISC_1, FUNCT_4, VALUED_0,
      AFINSQ_1, PRGCOR_2, CAT_1, AMISTD_1, AMISTD_3, AMISTD_2, VALUED_1,
      PRE_POLY, CONNSP_3, BINOP_1, FINSOP_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, CARD_1, NUMBERS, RELAT_1,
      FUNCT_1, ORDINAL1, ORDINAL2, ORDINAL4, XCMPLX_0, REAL_1, NAT_1, PARTFUN1,
      BINOP_1, FINSOP_1, NAT_D, FINSET_1, FINSEQ_1, FUNCOP_1, FUNCT_4, FUNCT_7,
      XXREAL_0, VALUED_0, VALUED_1;
 constructors WELLORD2, FUNCT_4, XXREAL_0, ORDINAL4, FUNCT_7, ORDINAL3,
      VALUED_1, ENUMSET1, NAT_D, XXREAL_2, BINOP_1, FINSOP_1, RELSET_1, CARD_1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      XXREAL_0, XREAL_0, NAT_1, CARD_1, ORDINAL2, NUMBERS, FINSEQ_1, VALUED_1,
      XXREAL_2, MEMBERED, FINSET_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, ORDINAL1, XBOOLE_0, FUNCOP_1, RELAT_1, VALUED_1, NAT_1,
      PARTFUN1, CARD_1, FUNCT_1;
 theorems TARSKI, AXIOMS, FUNCT_1, NAT_1, ZFMISC_1, RELAT_1, RELSET_1,
      ORDINAL1, CARD_1, FINSEQ_1, FUNCT_7, ORDINAL4, CARD_2, FUNCT_4, ORDINAL3,
      XBOOLE_0, XBOOLE_1, FINSET_1, FUNCOP_1, XREAL_1, VALUED_0, ENUMSET1,
      XXREAL_0, XREAL_0, GRFUNC_1, XXREAL_2, NAT_D, VALUED_1, BINOP_1, INT_1,
      XTUPLE_0;
 schemes FUNCT_1, SUBSET_1, NAT_1, XBOOLE_0, CLASSES1, FINSEQ_1, BINOP_1;

begin
theorem
L1: (for R1 being Nat holds (for R2 being Nat holds (R1 = ( R1 /\ R2 ) implies R1 <= R2))) by NAT_1:46;
theorem
L2: (for R2 being Nat holds ( R2 \/ { R2 } ) = ( R2 + 1 ))
proof
let R2 being Nat;
L3: ( R2 + 1 ) = ( succ R2 );
thus L4: thesis by L3;
end;
theorem
L5: (for R2 being Nat holds ( Seg R2 ) c= ( R2 + 1 ))
proof
let R2 being Nat;
let R3 being set;
assume L6: R3 in ( Seg R2 );
reconsider D1 = R3 as (Element of ( NAT )) by L6;
L7: D1 <= R2 by L6 , FINSEQ_1:1;
L8: D1 < ( R2 + 1 ) by L7 , NAT_1:13;
thus L9: thesis by L8 , NAT_1:44;
end;
theorem
L10: (for R2 being Nat holds ( R2 + 1 ) = ( { ( 0 ) } \/ ( Seg R2 ) ))
proof
let R2 being Nat;
thus L11: ( R2 + 1 ) c= ( { ( 0 ) } \/ ( Seg R2 ) )
proof
let R3 being set;
assume L12: R3 in ( R2 + 1 );
L13: R3 in { B1 where B1 is (Element of ( NAT )) : B1 < ( R2 + 1 ) } by L12 , AXIOMS:4;
consider C1 being (Element of ( NAT )) such that L14: C1 = R3 and L15: C1 < ( R2 + 1 ) by L13;
L16: (C1 = ( 0 ) or (1 < ( C1 + 1 ) & C1 <= R2)) by L15 , NAT_1:13 , XREAL_1:29;
L17: (C1 = ( 0 ) or (1 <= C1 & C1 <= R2)) by L16 , NAT_1:13;
L18: (R3 in { ( 0 ) } or R3 in ( Seg R2 )) by L17 , L14 , FINSEQ_1:1 , TARSKI:def 1;
thus L19: thesis by L18 , XBOOLE_0:def 3;
end;

L20: 1 <= ( R2 + 1 ) by NAT_1:11;
L21: { ( 0 ) } c= ( R2 + 1 ) by L20 , CARD_1:49 , NAT_1:39;
L22: ( Seg R2 ) c= ( R2 + 1 ) by L5;
thus L23: thesis by L22 , L21 , XBOOLE_1:8;
end;
theorem
L24: (for B2 being Function holds (B2 is  finite  T-Sequence-like iff (ex R2 being Nat st ( dom B2 ) = R2))) by FINSET_1:10 , ORDINAL1:def 7;
definition
mode XFinSequence
 is  finite T-Sequence;
end;
registration
let R12 being XFinSequence;
cluster ( dom R12 ) ->  natural;
coherence;
end;
notation
let R12 being XFinSequence;
synonym len R12 for card R12;
end;
registration
let R12 being XFinSequence;
identify len R12 with dom R12;
compatibility
proof
thus L28: ( len R12 ) = ( card ( dom R12 ) ) by CARD_1:62
.= ( dom R12 ) by CARD_1:def 2;
end;
end;
definition
let R12 being XFinSequence;
redefine func len R12 -> (Element of ( NAT ));

coherence
proof
L30: ( card R12 ) = ( card R12 );
thus L31: thesis by L30;
end;
end;
definition
let R12 being XFinSequence;
redefine func dom R12 -> (Subset of ( NAT ));

coherence
proof
L33: { B3 where B3 is (Element of ( NAT )) : B3 < ( len R12 ) } c= ( NAT )
proof
let C2 being set;
assume L34: C2 in { B4 where B4 is (Element of ( NAT )) : B4 < ( len R12 ) };
L35: (ex B5 being (Element of ( NAT )) st (B5 = C2 & B5 < ( len R12 ))) by L34;
thus L36: thesis by L35;
end;
thus L37: thesis by L33 , AXIOMS:4;
end;
end;
theorem
L39: (for R10 being Function holds ((ex R1 being Nat st ( dom R10 ) c= R1) implies (ex R12 being XFinSequence st R10 c= R12)))
proof
let R10 being Function;
given R1 being Nat such that
L40: ( dom R10 ) c= R1;

deffunc H1(set) = ( R10 . $1 );
consider R11 being Function such that L41: (( dom R11 ) = R1 & (for R3 being set holds (R3 in R1 implies ( R11 . R3 ) = H1(R3)))) from FUNCT_1:sch 3;
reconsider D2 = R11 as XFinSequence by L41 , FINSET_1:10 , ORDINAL1:def 7;
take D2;
let R4 being set;
let R5 being set;
assume L42: [ R4 , R5 ] in R10;
L43: R4 in ( dom R10 ) by L42 , XTUPLE_0:def 12;
L44: [ R4 , ( D2 . R4 ) ] in D2 by L43 , L40 , L41 , FUNCT_1:1;
L45: ( R10 . R4 ) = R5 by L42 , L43 , FUNCT_1:def 2;
thus L46: thesis by L45 , L40 , L41 , L43 , L44;
end;
scheme XSeqEx { F1() -> Nat , P1[set , set] } : (ex R12 being XFinSequence st (( dom R12 ) = F1() & (for R1 being Nat holds (R1 in F1() implies P1[ R1 , ( R12 . R1 ) ]))))
provided
L47: (for R1 being Nat holds (R1 in F1() implies (ex R3 being set st P1[ R1 , R3 ])))
proof
L48: (for R3 being set holds (R3 in F1() implies (ex R4 being set st P1[ R3 , R4 ])))
proof
let R3 being set;
assume L49: R3 in F1();
L50: F1() = { B6 where B6 is (Element of ( NAT )) : B6 < F1() } by AXIOMS:4;
L51: (ex B7 being (Element of ( NAT )) st (B7 = R3 & B7 < F1())) by L50 , L49;
thus L52: thesis by L51 , L47 , L49;
end;
consider C3 being Function such that L53: (( dom C3 ) = F1() & (for R3 being set holds (R3 in F1() implies P1[ R3 , ( C3 . R3 ) ]))) from CLASSES1:sch 1(L48);
reconsider D3 = C3 as XFinSequence by L53 , FINSET_1:10 , ORDINAL1:def 7;
take D3;
thus L54: thesis by L53;
end;
scheme XSeqLambda { F2() -> Nat , F3(set) -> set } : (ex B8 being XFinSequence st (( len B8 ) = F2() & (for R1 being Nat holds (R1 in F2() implies ( B8 . R1 ) = F3(R1)))))
proof
consider C4 being Function such that L55: (( dom C4 ) = F2() & (for R3 being set holds (R3 in F2() implies ( C4 . R3 ) = F3(R3)))) from FUNCT_1:sch 3;
reconsider D4 = C4 as XFinSequence by L55 , FINSET_1:10 , ORDINAL1:def 7;
take D4;
thus L56: thesis by L55;
end;
theorem
L57: (for R5 being set holds (for R12 being XFinSequence holds (R5 in R12 implies (ex R1 being Nat st (R1 in ( dom R12 ) & R5 = [ R1 , ( R12 . R1 ) ])))))
proof
let R5 being set;
let R12 being XFinSequence;
assume L58: R5 in R12;
consider R3 being set, R4 being set such that L59: R5 = [ R3 , R4 ] by L58 , RELAT_1:def 1;
L60: R3 in ( dom R12 ) by L58 , L59 , FUNCT_1:1;
reconsider D5 = R3 as (Element of ( NAT )) by L60;
take D5;
thus L61: thesis by L58 , L59 , FUNCT_1:1;
end;
theorem
L62: (for R12 being XFinSequence holds (for R13 being XFinSequence holds ((( dom R12 ) = ( dom R13 ) & (for R1 being Nat holds (R1 in ( dom R12 ) implies ( R12 . R1 ) = ( R13 . R1 )))) implies R12 = R13)))
proof
let R12 being XFinSequence;
let R13 being XFinSequence;
assume that
L63: ( dom R12 ) = ( dom R13 )
and
L64: (for R1 being Nat holds (R1 in ( dom R12 ) implies ( R12 . R1 ) = ( R13 . R1 )));
L65: (for R3 being set holds (R3 in ( dom R12 ) implies ( R12 . R3 ) = ( R13 . R3 ))) by L64;
thus L66: thesis by L65 , L63 , FUNCT_1:2;
end;
theorem
L67: (for R12 being XFinSequence holds (for R13 being XFinSequence holds ((( len R12 ) = ( len R13 ) & (for R1 being Nat holds (R1 < ( len R12 ) implies ( R12 . R1 ) = ( R13 . R1 )))) implies R12 = R13)))
proof
let R12 being XFinSequence;
let R13 being XFinSequence;
assume that
L68: ( len R12 ) = ( len R13 )
and
L69: (for R1 being Nat holds (R1 < ( len R12 ) implies ( R12 . R1 ) = ( R13 . R1 )));
L70:
now
let R3 being set;
assume L71: R3 in ( dom R12 );
reconsider D6 = R3 as (Element of ( NAT )) by L71;
L72: D6 < ( len R12 ) by L71 , NAT_1:44;
thus L73: ( R12 . R3 ) = ( R13 . R3 ) by L72 , L69;
end;
thus L74: thesis by L70 , L68 , FUNCT_1:2;
end;
registration
let R12 being XFinSequence;
let R2 being Nat;
cluster ( R12 | R2 ) ->  finite;
coherence;
end;
theorem
L76: (for R10 being Function holds (for R12 being XFinSequence holds (( rng R12 ) c= ( dom R10 ) implies ( R10 * R12 ) is XFinSequence)))
proof
let R10 being Function;
let R12 being XFinSequence;
assume L77: ( rng R12 ) c= ( dom R10 );
L78: ( dom ( R10 * R12 ) ) = ( len R12 ) by L77 , RELAT_1:27;
thus L79: thesis by L78 , ORDINAL1:def 7;
end;
theorem
L80: (for R1 being Nat holds (for R12 being XFinSequence holds (R1 < ( len R12 ) implies ( dom ( R12 | R1 ) ) = R1)))
proof
let R1 being Nat;
let R12 being XFinSequence;
assume L81: R1 < ( len R12 );
L82: R1 c= ( len R12 ) by L81 , NAT_1:39;
thus L83: thesis by L82 , RELAT_1:62;
end;
registration
let C5 being set;
cluster  finite for (T-Sequence of C5);
existence
proof
L84: ( {} ) is (T-Sequence of C5) by ORDINAL1:30;
thus L85: thesis by L84;
end;
end;
definition
let C6 being set;
mode XFinSequence of C6
 is  finite (T-Sequence of C6);
end;
theorem
L88: (for B9 being set holds (for B10 being (XFinSequence of B9) holds B10 is (PartFunc of ( NAT ) , B9)))
proof
let C7 being set;
let C8 being (XFinSequence of C7);
L89: (( dom C8 ) c= ( NAT ) & ( rng C8 ) c= C7) by RELAT_1:def 19;
thus L90: thesis by L89 , RELSET_1:4;
end;
registration
cluster  empty ->  T-Sequence-like for Function;
coherence;
end;
theorem
L92: (for B11 being Nat holds (for B12 being set holds ( B11 --> B12 ) is XFinSequence));
theorem
L93: (for R1 being Nat holds (for B13 being non  empty set holds (ex B14 being (XFinSequence of B13) st ( len B14 ) = R1)))
proof
let R1 being Nat;
let C9 being non  empty set;
set D7 = the (Element of C9);
set D8 = ( R1 --> D7 );
reconsider D9 = ( R1 --> D7 ) as XFinSequence;
reconsider D10 = D9 as (XFinSequence of C9);
take D10;
thus L94: thesis by FUNCOP_1:13;
end;
theorem
L95: (for R12 being XFinSequence holds (( len R12 ) = ( 0 ) iff R12 = ( {} )));
theorem
L96: (for B15 being set holds ( {} ) is (XFinSequence of B15))
proof
let C10 being set;
L97: ( rng ( {} ) ) c= C10 by XBOOLE_1:2;
thus L98: thesis by L97 , RELAT_1:def 19;
end;
registration
let C11 being set;
cluster  empty for (XFinSequence of C11);
existence
proof
L99: ( {} ) is (XFinSequence of C11) by L96;
thus L100: thesis by L99;
end;
end;
registration
let C12 being non  empty set;
cluster non  empty for (XFinSequence of C12);
existence
proof
set D11 = 1;
consider C13 being (XFinSequence of C12) such that L102: ( len C13 ) = D11 by L93;
L103: C13 <> ( {} ) by L102;
thus L104: thesis by L103;
end;
end;
definition
let R3 being set;
func <%R3 %> -> set equals 
( ( 0 ) .--> R3 );
coherence;
end;
registration
let R3 being set;
cluster <% R3 %> -> non  empty;
coherence;
end;
definition
let C14 being set;
func <%> C14 -> (XFinSequence of C14) equals 
( {} );
coherence by L96;
end;
registration
let C15 being set;
cluster ( <%> C15 ) ->  empty;
coherence;
end;
definition
let R12 being XFinSequence;
let R13 being XFinSequence;
redefine func R12 ^ R13 means 
:L110: (( dom it ) = ( ( len R12 ) + ( len R13 ) ) & (for R1 being Nat holds (R1 in ( dom R12 ) implies ( it . R1 ) = ( R12 . R1 ))) & (for R1 being Nat holds (R1 in ( dom R13 ) implies ( it . ( ( len R12 ) + R1 ) ) = ( R13 . R1 ))));
compatibility
proof
let C16 being T-Sequence;
L111: ( ( len R12 ) +^ ( len R13 ) ) = ( ( len R12 ) + ( len R13 ) ) by CARD_2:36;
thus L112:now
assume L113: C16 = ( R12 ^ R13 );
thus L114: ( dom C16 ) = ( ( len R12 ) + ( len R13 ) ) by L113 , L111 , ORDINAL4:def 1;
thus L115: (for R1 being Nat holds (R1 in ( dom R12 ) implies ( C16 . R1 ) = ( R12 . R1 ))) by L113 , ORDINAL4:def 1;
let R1 being Nat;
assume L116: R1 in ( dom R13 );
L117: (( C16 . ( ( len R12 ) +^ R1 ) ) = ( R13 . R1 ) & R1 in ( NAT )) by L116 , L113 , ORDINAL4:def 1;
thus L118: ( C16 . ( ( len R12 ) + R1 ) ) = ( R13 . R1 ) by L117 , CARD_2:36;
end;
assume that
L119: ( dom C16 ) = ( ( len R12 ) + ( len R13 ) )
and
L120: (for R1 being Nat holds (R1 in ( dom R12 ) implies ( C16 . R1 ) = ( R12 . R1 )))
and
L121: (for R1 being Nat holds (R1 in ( dom R13 ) implies ( C16 . ( ( len R12 ) + R1 ) ) = ( R13 . R1 )));
L122:
now
let C17 being Ordinal;
assume L123: C17 in ( dom R13 );
reconsider D12 = C17 as (Element of ( NAT )) by L123;
thus L124: ( C16 . ( ( dom R12 ) +^ C17 ) ) = ( C16 . ( ( len R12 ) + D12 ) ) by CARD_2:36
.= ( R13 . C17 ) by L121 , L123;
end;
L125: (for B16 being Ordinal holds (B16 in ( dom R12 ) implies ( C16 . B16 ) = ( R12 . B16 ))) by L120;
thus L126: thesis by L125 , L111 , L119 , L122 , ORDINAL4:def 1;
end;
end;
registration
let R12 being XFinSequence;
let R13 being XFinSequence;
cluster ( R12 ^ R13 ) ->  finite;
coherence
proof
L128: ( dom ( R12 ^ R13 ) ) = ( ( dom R12 ) +^ ( dom R13 ) ) by ORDINAL4:def 1;
thus L129: thesis by L128 , FINSET_1:10;
end;
end;
theorem
L131: (for R12 being XFinSequence holds (for R13 being XFinSequence holds ( len ( R12 ^ R13 ) ) = ( ( len R12 ) + ( len R13 ) ))) by L110;
theorem
L132: (for R1 being Nat holds (for R12 being XFinSequence holds (for R13 being XFinSequence holds ((( len R12 ) <= R1 & R1 < ( ( len R12 ) + ( len R13 ) )) implies ( ( R12 ^ R13 ) . R1 ) = ( R13 . ( R1 - ( len R12 ) ) )))))
proof
let R1 being Nat;
let R12 being XFinSequence;
let R13 being XFinSequence;
assume that
L133: ( len R12 ) <= R1
and
L134: R1 < ( ( len R12 ) + ( len R13 ) );
consider C18 being Nat such that L135: ( ( len R12 ) + C18 ) = R1 by L133 , NAT_1:10;
L136: ( R1 - ( len R12 ) ) < ( ( ( len R12 ) + ( len R13 ) ) - ( len R12 ) ) by L134 , XREAL_1:14;
L137: C18 in ( dom R13 ) by L136 , L135 , NAT_1:44;
thus L138: thesis by L137 , L135 , L110;
end;
theorem
L139: (for R1 being Nat holds (for R12 being XFinSequence holds (for R13 being XFinSequence holds ((( len R12 ) <= R1 & R1 < ( len ( R12 ^ R13 ) )) implies ( ( R12 ^ R13 ) . R1 ) = ( R13 . ( R1 - ( len R12 ) ) )))))
proof
let R1 being Nat;
let R12 being XFinSequence;
let R13 being XFinSequence;
assume that
L140: ( len R12 ) <= R1
and
L141: R1 < ( len ( R12 ^ R13 ) );
L142: R1 < ( ( len R12 ) + ( len R13 ) ) by L141 , L110;
thus L143: thesis by L142 , L140 , L132;
end;
theorem
L144: (for R1 being Nat holds (for R12 being XFinSequence holds (for R13 being XFinSequence holds (R1 in ( dom ( R12 ^ R13 ) ) implies (R1 in ( dom R12 ) or (ex R2 being Nat st (R2 in ( dom R13 ) & R1 = ( ( len R12 ) + R2 ))))))))
proof
let R1 being Nat;
let R12 being XFinSequence;
let R13 being XFinSequence;
assume L145: R1 in ( dom ( R12 ^ R13 ) );
L146: R1 in ( ( len R12 ) + ( len R13 ) ) by L145 , L110;
L147: R1 < ( ( len R12 ) + ( len R13 ) ) by L146 , NAT_1:44;
L148:
now
assume L149: ( len R12 ) <= R1;
consider C19 being Nat such that L150: R1 = ( ( len R12 ) + C19 ) by L149 , NAT_1:10;
L151: ( ( C19 + ( len R12 ) ) - ( len R12 ) ) < ( ( ( len R13 ) + ( len R12 ) ) - ( len R12 ) ) by L147 , L150 , XREAL_1:14;
L152: C19 in ( len R13 ) by L151 , NAT_1:44;
thus L153: thesis by L152 , L150;
end;
thus L154: thesis by L148 , NAT_1:44;
end;
theorem
L155: (for B17 , B18 being T-Sequence holds ( dom B17 ) c= ( dom ( B17 ^ B18 ) ))
proof
let C20 , C21 being T-Sequence;
L156: ( dom ( C20 ^ C21 ) ) = ( ( dom C20 ) +^ ( dom C21 ) ) by ORDINAL4:def 1;
thus L157: thesis by L156 , ORDINAL3:24;
end;
theorem
L158: (for R3 being set holds (for R12 being XFinSequence holds (for R13 being XFinSequence holds (R3 in ( dom R13 ) implies (ex R1 being Nat st (R1 = R3 & ( ( len R12 ) + R1 ) in ( dom ( R12 ^ R13 ) )))))))
proof
let R3 being set;
let R12 being XFinSequence;
let R13 being XFinSequence;
assume L159: R3 in ( dom R13 );
reconsider D13 = R3 as (Element of ( NAT )) by L159;
take D13;
L160: D13 < ( len R13 ) by L159 , NAT_1:44;
L161: ( ( len R12 ) + D13 ) < ( ( len R12 ) + ( len R13 ) ) by L160 , XREAL_1:8;
L162: ( ( len R12 ) + D13 ) in ( ( len R12 ) + ( len R13 ) ) by L161 , NAT_1:44;
thus L163: thesis by L162 , L110;
end;
theorem
L164: (for R1 being Nat holds (for R12 being XFinSequence holds (for R13 being XFinSequence holds (R1 in ( dom R13 ) implies ( ( len R12 ) + R1 ) in ( dom ( R12 ^ R13 ) )))))
proof
let R1 being Nat;
let R12 being XFinSequence;
let R13 being XFinSequence;
assume L165: R1 in ( dom R13 );
L166: (ex R2 being Nat st (R2 = R1 & ( ( len R12 ) + R2 ) in ( dom ( R12 ^ R13 ) ))) by L165 , L158;
thus L167: thesis by L166;
end;
theorem
L168: (for R12 being XFinSequence holds (for R13 being XFinSequence holds ( rng R12 ) c= ( rng ( R12 ^ R13 ) )))
proof
let R12 being XFinSequence;
let R13 being XFinSequence;
L169:
now
L170: ( dom R12 ) c= ( dom ( R12 ^ R13 ) ) by L155;
let R3 being set;
assume L171: R3 in ( rng R12 );
consider R4 being set such that L172: R4 in ( dom R12 ) and L173: R3 = ( R12 . R4 ) by L171 , FUNCT_1:def 3;
reconsider D14 = R4 as (Element of ( NAT )) by L172;
L174: ( ( R12 ^ R13 ) . D14 ) = ( R12 . D14 ) by L172 , L110;
thus L175: R3 in ( rng ( R12 ^ R13 ) ) by L174 , L172 , L173 , L170 , FUNCT_1:3;
end;
thus L176: thesis by L169 , TARSKI:def 3;
end;
theorem
L177: (for R12 being XFinSequence holds (for R13 being XFinSequence holds ( rng R13 ) c= ( rng ( R12 ^ R13 ) )))
proof
let R12 being XFinSequence;
let R13 being XFinSequence;
L178:
now
let R3 being set;
assume L179: R3 in ( rng R13 );
consider R4 being set such that L180: R4 in ( dom R13 ) and L181: R3 = ( R13 . R4 ) by L179 , FUNCT_1:def 3;
reconsider D15 = R4 as (Element of ( NAT )) by L180;
L182: (( ( len R12 ) + D15 ) in ( dom ( R12 ^ R13 ) ) & ( ( R12 ^ R13 ) . ( ( len R12 ) + D15 ) ) = ( R13 . D15 )) by L180 , L110 , L164;
thus L183: R3 in ( rng ( R12 ^ R13 ) ) by L182 , L181 , FUNCT_1:3;
end;
thus L184: thesis by L178 , TARSKI:def 3;
end;
theorem
L185: (for R12 being XFinSequence holds (for R13 being XFinSequence holds ( rng ( R12 ^ R13 ) ) = ( ( rng R12 ) \/ ( rng R13 ) )))
proof
let R12 being XFinSequence;
let R13 being XFinSequence;
L186:
now
let R3 being set;
assume L187: R3 in ( rng ( R12 ^ R13 ) );
consider R4 being set such that L188: R4 in ( dom ( R12 ^ R13 ) ) and L189: R3 = ( ( R12 ^ R13 ) . R4 ) by L187 , FUNCT_1:def 3;
reconsider D16 = R4 as (Element of ( NAT )) by L188;
L190: R4 in ( ( len R12 ) + ( len R13 ) ) by L188 , L110;
L191: D16 < ( ( len R12 ) + ( len R13 ) ) by L190 , NAT_1:44;
L192:
now
assume L193: ( len R12 ) <= D16;
consider C22 being Nat such that L194: ( ( len R12 ) + C22 ) = D16 by L193 , NAT_1:10;
L195: ( ( C22 + ( len R12 ) ) - ( len R12 ) ) < ( ( ( len R12 ) + ( len R13 ) ) - ( len R12 ) ) by L191 , L194 , XREAL_1:14;
L196: C22 in ( len R13 ) by L195 , NAT_1:44;
L197: ( R13 . ( D16 - ( len R12 ) ) ) = R3 by L189 , L191 , L193 , L132;
thus L198: R3 in ( rng R13 ) by L197 , L194 , L196 , FUNCT_1:3;
end;
L199:
now
assume L200: (not ( len R12 ) <= D16);
L201: D16 in ( dom R12 ) by L200 , NAT_1:44;
L202: ( R12 . D16 ) = R3 by L201 , L189 , L110;
thus L203: R3 in ( rng R12 ) by L202 , L201 , FUNCT_1:3;
end;
thus L204: R3 in ( ( rng R12 ) \/ ( rng R13 ) ) by L199 , L192 , XBOOLE_0:def 3;
end;
L205: ( rng ( R12 ^ R13 ) ) c= ( ( rng R12 ) \/ ( rng R13 ) ) by L186 , TARSKI:def 3;
L206: (( rng R12 ) c= ( rng ( R12 ^ R13 ) ) & ( rng R13 ) c= ( rng ( R12 ^ R13 ) )) by L168 , L177;
L207: ( ( rng R12 ) \/ ( rng R13 ) ) c= ( rng ( R12 ^ R13 ) ) by L206 , XBOOLE_1:8;
thus L208: thesis by L207 , L205 , XBOOLE_0:def 10;
end;
theorem
L209: (for R12 being XFinSequence holds (for R13 being XFinSequence holds (for R14 being XFinSequence holds ( ( R12 ^ R13 ) ^ R14 ) = ( R12 ^ ( R13 ^ R14 ) ))))
proof
let R12 being XFinSequence;
let R13 being XFinSequence;
let R14 being XFinSequence;
L210: (for R1 being Nat holds (R1 in ( dom R12 ) implies ( ( ( R12 ^ R13 ) ^ R14 ) . R1 ) = ( R12 . R1 )))
proof
let R1 being Nat;
assume L211: R1 in ( dom R12 );
L212: ( dom R12 ) c= ( dom ( R12 ^ R13 ) ) by L155;
thus L213: ( ( ( R12 ^ R13 ) ^ R14 ) . R1 ) = ( ( R12 ^ R13 ) . R1 ) by L212 , L211 , L110
.= ( R12 . R1 ) by L211 , L110;
end;
L214: (for R1 being Nat holds (R1 in ( dom ( R13 ^ R14 ) ) implies ( ( ( R12 ^ R13 ) ^ R14 ) . ( ( len R12 ) + R1 ) ) = ( ( R13 ^ R14 ) . R1 )))
proof
let R1 being Nat;
assume L215: R1 in ( dom ( R13 ^ R14 ) );
L216:
now
assume L217: (not R1 in ( dom R13 ));
consider R2 being Nat such that L218: R2 in ( dom R14 ) and L219: R1 = ( ( len R13 ) + R2 ) by L217 , L215 , L144;
thus L220: ( ( ( R12 ^ R13 ) ^ R14 ) . ( ( len R12 ) + R1 ) ) = ( ( ( R12 ^ R13 ) ^ R14 ) . ( ( ( len R12 ) + ( len R13 ) ) + R2 ) ) by L219
.= ( ( ( R12 ^ R13 ) ^ R14 ) . ( ( len ( R12 ^ R13 ) ) + R2 ) ) by L110
.= ( R14 . R2 ) by L218 , L110
.= ( ( R13 ^ R14 ) . R1 ) by L218 , L219 , L110;
end;
L221:
now
assume L222: R1 in ( dom R13 );
L223: ( ( len R12 ) + R1 ) in ( dom ( R12 ^ R13 ) ) by L222 , L164;
thus L224: ( ( ( R12 ^ R13 ) ^ R14 ) . ( ( len R12 ) + R1 ) ) = ( ( R12 ^ R13 ) . ( ( len R12 ) + R1 ) ) by L223 , L110
.= ( R13 . R1 ) by L222 , L110
.= ( ( R13 ^ R14 ) . R1 ) by L222 , L110;
end;
thus L225: thesis by L221 , L216;
end;
L226: ( dom ( ( R12 ^ R13 ) ^ R14 ) ) = ( ( len ( R12 ^ R13 ) ) + ( len R14 ) ) by L110
.= ( ( ( len R12 ) + ( len R13 ) ) + ( len R14 ) ) by L110
.= ( ( len R12 ) + ( ( len R13 ) + ( len R14 ) ) )
.= ( ( len R12 ) + ( len ( R13 ^ R14 ) ) ) by L110;
thus L227: thesis by L226 , L210 , L214 , L110;
end;
theorem
L228: (for R12 being XFinSequence holds (for R13 being XFinSequence holds (for R14 being XFinSequence holds ((( R12 ^ R14 ) = ( R13 ^ R14 ) or ( R14 ^ R12 ) = ( R14 ^ R13 )) implies R12 = R13))))
proof
let R12 being XFinSequence;
let R13 being XFinSequence;
let R14 being XFinSequence;
L229:
now
assume L230: ( R12 ^ R14 ) = ( R13 ^ R14 );
L231: ( ( len R12 ) + ( len R14 ) ) = ( len ( R13 ^ R14 ) ) by L230 , L110;
L232: ( ( len R12 ) + ( len R14 ) ) = ( ( len R13 ) + ( len R14 ) ) by L231 , L110;
L233: (for R1 being Nat holds (R1 in ( dom R12 ) implies ( R12 . R1 ) = ( R13 . R1 )))
proof
let R1 being Nat;
assume L234: R1 in ( dom R12 );
thus L235: ( R12 . R1 ) = ( ( R13 ^ R14 ) . R1 ) by L234 , L230 , L110
.= ( R13 . R1 ) by L232 , L234 , L110;
end;
thus L236: thesis by L233 , L232 , L62;
end;
L237:
now
assume L238: ( R14 ^ R12 ) = ( R14 ^ R13 );
L239: ( ( len R14 ) + ( len R12 ) ) = ( len ( R14 ^ R13 ) ) by L238 , L110
.= ( ( len R14 ) + ( len R13 ) ) by L110;
L240: (for R1 being Nat holds (R1 in ( dom R12 ) implies ( R12 . R1 ) = ( R13 . R1 )))
proof
let R1 being Nat;
assume L241: R1 in ( dom R12 );
thus L242: ( R12 . R1 ) = ( ( R14 ^ R13 ) . ( ( len R14 ) + R1 ) ) by L241 , L238 , L110
.= ( R13 . R1 ) by L239 , L241 , L110;
end;
thus L243: thesis by L240 , L239 , L62;
end;
assume L244: (( R12 ^ R14 ) = ( R13 ^ R14 ) or ( R14 ^ R12 ) = ( R14 ^ R13 ));
thus L245: thesis by L244 , L229 , L237;
end;
registration
let R12 being XFinSequence;
reduce ( R12 ^ ( {} ) ) to R12;
reducibility
proof
L246: (for R1 being Nat holds (R1 in ( dom R12 ) implies ( R12 . R1 ) = ( ( R12 ^ ( {} ) ) . R1 ))) by L110;
L247: ( dom ( R12 ^ ( {} ) ) ) = ( ( len R12 ) + ( len ( {} ) ) ) by L110
.= ( dom R12 );
thus L248: ( R12 ^ ( {} ) ) = R12 by L247 , L246 , L62;
end;
reduce ( ( {} ) ^ R12 ) to R12;
reducibility
proof
L249: (for R1 being Nat holds (R1 in ( dom R12 ) implies ( R12 . R1 ) = ( ( ( {} ) ^ R12 ) . R1 )))
proof
let R1 being Nat;
assume L250: R1 in ( dom R12 );
thus L251: ( ( ( {} ) ^ R12 ) . R1 ) = ( ( ( {} ) ^ R12 ) . ( ( len ( {} ) ) + R1 ) )
.= ( R12 . R1 ) by L250 , L110;
end;
L252: ( dom ( ( {} ) ^ R12 ) ) = ( ( len ( {} ) ) + ( len R12 ) ) by L110
.= ( dom R12 );
thus L253: thesis by L252 , L249 , L62;
end;
end;
canceled 1;
theorem
L255: (for R12 being XFinSequence holds (for R13 being XFinSequence holds (( R12 ^ R13 ) = ( {} ) implies (R12 = ( {} ) & R13 = ( {} )))))
proof
let R12 being XFinSequence;
let R13 being XFinSequence;
assume L256: ( R12 ^ R13 ) = ( {} );
L257: ( 0 ) = ( len ( R12 ^ R13 ) ) by L256
.= ( ( len R12 ) + ( len R13 ) ) by L110;
thus L258: thesis by L257;
end;
registration
let C23 being set;
let C24 , C25 being (XFinSequence of C23);
cluster ( C24 ^ C25 ) -> C23 -valued;
coherence
proof
L259: ( rng C25 ) c= C23 by RELAT_1:def 19;
L260: (( rng ( C24 ^ C25 ) ) = ( ( rng C24 ) \/ ( rng C25 ) ) & ( rng C24 ) c= C23) by L185 , RELAT_1:def 19;
L261: ( rng ( C24 ^ C25 ) ) c= C23 by L260 , L259 , XBOOLE_1:8;
thus L262: thesis by L261 , RELAT_1:def 19;
end;
end;
L264: (for R3 being set holds (for R4 being set holds (for B19 , B20 being set holds ([ R3 , R4 ] in { [ B19 , B20 ] } implies (R3 = B19 & R4 = B20)))))
proof
let R3 being set;
let R4 being set;
let C26 , C27 being set;
assume L265: [ R3 , R4 ] in { [ C26 , C27 ] };
L266: [ R3 , R4 ] = [ C26 , C27 ] by L265 , TARSKI:def 1;
thus L267: thesis by L266 , XTUPLE_0:1;
end;
definition
let R3 being set;
redefine func <%R3 %> -> Function means 
:L268: (( dom it ) = 1 & ( it . ( 0 ) ) = R3);
coherence;
compatibility
proof
let C28 being Function;
thus L269: (C28 = <% R3 %> implies (( dom C28 ) = 1 & ( C28 . ( 0 ) ) = R3)) by CARD_1:49 , FUNCOP_1:13 , FUNCOP_1:72;
assume that
L270: ( dom C28 ) = 1
and
L271: ( C28 . ( 0 ) ) = R3;
reconsider D17 = { [ ( 0 ) , ( C28 . ( 0 ) ) ] } as Function;
L272: (for R4 being set holds (for R5 being set holds ([ R4 , R5 ] in C28 iff [ R4 , R5 ] in D17)))
proof
let R4 being set;
let R5 being set;
thus L273:now
assume L274: [ R4 , R5 ] in C28;
L275: R4 in { ( 0 ) } by L274 , L270 , CARD_1:49 , XTUPLE_0:def 12;
L276: R4 = ( 0 ) by L275 , TARSKI:def 1;
L277: ( rng C28 ) = { ( C28 . ( 0 ) ) } by L270 , CARD_1:49 , FUNCT_1:4;
L278: R5 in ( rng C28 ) by L274 , XTUPLE_0:def 13;
L279: R5 = ( C28 . ( 0 ) ) by L278 , L277 , TARSKI:def 1;
thus L280: [ R4 , R5 ] in D17 by L279 , L276 , TARSKI:def 1;
end;
assume L281: [ R4 , R5 ] in D17;
L282: (R4 = ( 0 ) & R5 = ( C28 . ( 0 ) )) by L281 , L264;
L283: ( 0 ) in ( dom C28 ) by L270 , CARD_1:49 , TARSKI:def 1;
thus L284: thesis by L283 , L282 , FUNCT_1:def 2;
end;
L285: C28 = { [ ( 0 ) , ( C28 . ( 0 ) ) ] } by L272 , RELAT_1:def 2;
thus L286: thesis by L285 , L271 , FUNCT_4:82;
end;
end;
registration
let R3 being set;
cluster <% R3 %> ->  Function-like  Relation-like;
coherence;
end;
registration
let R3 being set;
cluster <% R3 %> ->  finite  T-Sequence-like;
coherence
proof
L289: ( dom <% R3 %> ) = 1 by L268;
thus L290: thesis by L289 , ORDINAL1:def 7;
end;
end;
theorem
L292: (for R12 being XFinSequence holds (for R13 being XFinSequence holds (for R17 being set holds (( R12 ^ R13 ) is (XFinSequence of R17) implies (R12 is (XFinSequence of R17) & R13 is (XFinSequence of R17))))))
proof
let R12 being XFinSequence;
let R13 being XFinSequence;
let R17 being set;
assume L293: ( R12 ^ R13 ) is (XFinSequence of R17);
L294: ( rng ( R12 ^ R13 ) ) c= R17 by L293 , RELAT_1:def 19;
L295: ( ( rng R12 ) \/ ( rng R13 ) ) c= R17 by L294 , L185;
L296: ( rng R12 ) c= ( ( rng R12 ) \/ ( rng R13 ) ) by XBOOLE_1:7;
L297: ( rng R12 ) c= R17 by L296 , L295 , XBOOLE_1:1;
thus L298: R12 is (XFinSequence of R17) by L297 , RELAT_1:def 19;
L299: ( rng R13 ) c= ( ( rng R12 ) \/ ( rng R13 ) ) by XBOOLE_1:7;
L300: ( rng R13 ) c= R17 by L299 , L295 , XBOOLE_1:1;
thus L301: thesis by L300 , RELAT_1:def 19;
end;
definition
let R3 being set;
let R4 being set;
func <%R3 , R4 %> -> set equals 
( <% R3 %> ^ <% R4 %> );
correctness;
let R5 being set;
func <%R3 , R4 , R5 %> -> set equals 
( ( <% R3 %> ^ <% R4 %> ) ^ <% R5 %> );
correctness;
end;
registration
let R3 being set;
let R4 being set;
cluster <% R3 , R4 %> ->  Function-like  Relation-like;
coherence;
let R5 being set;
cluster <% R3 , R4 , R5 %> ->  Function-like  Relation-like;
coherence;
end;
registration
let R3 being set;
let R4 being set;
cluster <% R3 , R4 %> ->  finite  T-Sequence-like;
coherence;
let R5 being set;
cluster <% R3 , R4 , R5 %> ->  finite  T-Sequence-like;
coherence;
end;
theorem
L305: (for R3 being set holds <% R3 %> = { [ ( 0 ) , R3 ] }) by FUNCT_4:82;
theorem
L306: (for R3 being set holds (for R12 being XFinSequence holds (R12 = <% R3 %> iff (( dom R12 ) = 1 & ( rng R12 ) = { R3 }))))
proof
let R3 being set;
let R12 being XFinSequence;
thus L307: (R12 = <% R3 %> implies (( dom R12 ) = 1 & ( rng R12 ) = { R3 }))
proof
assume L308: R12 = <% R3 %>;
thus L309: ( dom R12 ) = 1 by L308 , L268;
L310: ( dom R12 ) = { ( 0 ) } by L308 , L268 , CARD_1:49;
L311: ( rng R12 ) = { ( R12 . ( 0 ) ) } by L310 , FUNCT_1:4;
thus L312: thesis by L311 , L308 , L268;
end;

assume that
L313: ( dom R12 ) = 1
and
L314: ( rng R12 ) = { R3 };
L315: 1 = ( ( 0 ) + 1 );
L316: ( R12 . ( 0 ) ) in { R3 } by L315 , L313 , L314 , FUNCT_1:3 , NAT_1:45;
L317: ( R12 . ( 0 ) ) = R3 by L316 , TARSKI:def 1;
thus L318: thesis by L317 , L313 , L268;
end;
theorem
L319: (for R3 being set holds (for R12 being XFinSequence holds (R12 = <% R3 %> iff (( len R12 ) = 1 & ( R12 . ( 0 ) ) = R3)))) by L268;
theorem
L320: (for R3 being set holds (for R12 being XFinSequence holds ( ( <% R3 %> ^ R12 ) . ( 0 ) ) = R3))
proof
let R3 being set;
let R12 being XFinSequence;
L321: ( 0 ) in 1 by CARD_1:49 , TARSKI:def 1;
L322: ( 0 ) in ( dom <% R3 %> ) by L321 , L268;
L323: ( ( <% R3 %> ^ R12 ) . ( 0 ) ) = ( <% R3 %> . ( 0 ) ) by L322 , L110;
thus L324: thesis by L323 , L268;
end;
theorem
L325: (for R3 being set holds (for R12 being XFinSequence holds ( ( R12 ^ <% R3 %> ) . ( len R12 ) ) = R3))
proof
let R3 being set;
let R12 being XFinSequence;
L326: (( dom <% R3 %> ) = 1 & 1 = ( ( 0 ) + 1 )) by L268;
L327: ( 0 ) in ( dom <% R3 %> ) by L326 , NAT_1:45;
L328: ( ( len R12 ) + ( 0 ) ) = ( len R12 );
thus L329: ( ( R12 ^ <% R3 %> ) . ( len R12 ) ) = ( <% R3 %> . ( 0 ) ) by L328 , L327 , L110
.= R3 by L268;
end;
theorem
L330: (for R3 being set holds (for R4 being set holds (for R5 being set holds (<% R3 , R4 , R5 %> = ( <% R3 %> ^ <% R4 , R5 %> ) & <% R3 , R4 , R5 %> = ( <% R3 , R4 %> ^ <% R5 %> ))))) by L209;
theorem
L331: (for R3 being set holds (for R4 being set holds (for R12 being XFinSequence holds (R12 = <% R3 , R4 %> iff (( len R12 ) = 2 & ( R12 . ( 0 ) ) = R3 & ( R12 . 1 ) = R4)))))
proof
let R3 being set;
let R4 being set;
let R12 being XFinSequence;
thus L332: (R12 = <% R3 , R4 %> implies (( len R12 ) = 2 & ( R12 . ( 0 ) ) = R3 & ( R12 . 1 ) = R4))
proof
assume L333: R12 = <% R3 , R4 %>;
thus L334: ( len R12 ) = ( ( len <% R3 %> ) + ( len <% R4 %> ) ) by L333 , L110
.= ( 1 + ( len <% R4 %> ) ) by L306
.= ( 1 + 1 ) by L306
.= 2;
L335: ( 0 ) in { ( 0 ) } by TARSKI:def 1;
L336: ( 0 ) in ( dom <% R4 %> ) by L335 , L268 , CARD_1:49;
L337: ( 0 ) in ( dom <% R3 %> ) by L335 , L268 , CARD_1:49;
thus L338: ( R12 . ( 0 ) ) = ( <% R3 %> . ( 0 ) ) by L337 , L333 , L110
.= R3 by L268;
thus L339: ( R12 . 1 ) = ( ( <% R3 %> ^ <% R4 %> ) . ( ( len <% R3 %> ) + ( 0 ) ) ) by L333 , L306
.= ( <% R4 %> . ( 0 ) ) by L336 , L110
.= R4 by L268;
end;

assume that
L340: ( len R12 ) = 2
and
L341: ( R12 . ( 0 ) ) = R3
and
L342: ( R12 . 1 ) = R4;
L343: (for R1 being Nat holds (R1 in ( dom <% R4 %> ) implies ( R12 . ( ( len <% R3 %> ) + R1 ) ) = ( <% R4 %> . R1 )))
proof
let R1 being Nat;
assume L344: R1 in ( dom <% R4 %> );
L345: R1 in { ( 0 ) } by L344 , L268 , CARD_1:49;
thus L346: ( R12 . ( ( len <% R3 %> ) + R1 ) ) = ( R12 . ( 1 + R1 ) ) by L306
.= ( R12 . ( 1 + ( 0 ) ) ) by L345 , TARSKI:def 1
.= ( <% R4 %> . ( 0 ) ) by L342 , L268
.= ( <% R4 %> . R1 ) by L345 , TARSKI:def 1;
end;
L347: (for R1 being Nat holds (R1 in ( dom <% R3 %> ) implies ( R12 . R1 ) = ( <% R3 %> . R1 )))
proof
let R1 being Nat;
assume L348: R1 in ( dom <% R3 %> );
L349: R1 in { ( 0 ) } by L348 , L268 , CARD_1:49;
L350: R1 = ( 0 ) by L349 , TARSKI:def 1;
thus L351: thesis by L350 , L341 , L268;
end;
L352: ( dom R12 ) = ( 1 + 1 ) by L340
.= ( ( len <% R3 %> ) + 1 ) by L306
.= ( ( len <% R3 %> ) + ( len <% R4 %> ) ) by L306;
thus L353: thesis by L352 , L347 , L343 , L110;
end;
theorem
L354: (for R3 being set holds (for R4 being set holds (for R5 being set holds (for R12 being XFinSequence holds (R12 = <% R3 , R4 , R5 %> iff (( len R12 ) = 3 & ( R12 . ( 0 ) ) = R3 & ( R12 . 1 ) = R4 & ( R12 . 2 ) = R5))))))
proof
let R3 being set;
let R4 being set;
let R5 being set;
let R12 being XFinSequence;
thus L355: (R12 = <% R3 , R4 , R5 %> implies (( len R12 ) = 3 & ( R12 . ( 0 ) ) = R3 & ( R12 . 1 ) = R4 & ( R12 . 2 ) = R5))
proof
L356: ( 0 ) in { ( 0 ) } by TARSKI:def 1;
L357: ( 0 ) in ( dom <% R3 %> ) by L356 , L268 , CARD_1:49;
L358: ( 0 ) in ( dom <% R5 %> ) by L356 , L268 , CARD_1:49;
assume L359: R12 = <% R3 , R4 , R5 %>;
thus L360: ( len R12 ) = ( ( len <% R3 , R4 %> ) + ( len <% R5 %> ) ) by L359 , L110
.= ( 2 + ( len <% R5 %> ) ) by L331
.= ( 2 + 1 ) by L306
.= 3;
thus L361: ( R12 . ( 0 ) ) = ( ( <% R3 %> ^ <% R4 , R5 %> ) . ( 0 ) ) by L359 , L209
.= ( <% R3 %> . ( 0 ) ) by L357 , L110
.= R3 by L268;
L362: (1 in ( 1 + 1 ) & ( len <% R3 , R4 %> ) = 2) by L331 , NAT_1:45;
thus L363: ( R12 . 1 ) = ( <% R3 , R4 %> . 1 ) by L362 , L359 , L110
.= R4 by L331;
thus L364: ( R12 . 2 ) = ( ( <% R3 , R4 %> ^ <% R5 %> ) . ( ( len <% R3 , R4 %> ) + ( 0 ) ) ) by L359 , L331
.= ( <% R5 %> . ( 0 ) ) by L358 , L110
.= R5 by L268;
end;

assume that
L365: ( len R12 ) = 3
and
L366: ( R12 . ( 0 ) ) = R3
and
L367: ( R12 . 1 ) = R4
and
L368: ( R12 . 2 ) = R5;
L369: (for R1 being Nat holds (R1 in ( dom <% R3 , R4 %> ) implies ( R12 . R1 ) = ( <% R3 , R4 %> . R1 )))
proof
L370: ( len <% R3 , R4 %> ) = 2 by L331;
let R1 being Nat;
assume that
L371: R1 in ( dom <% R3 , R4 %> );
L372: (R1 = 1 implies ( R12 . R1 ) = ( <% R3 , R4 %> . R1 )) by L367 , L331;
L373: (R1 = ( 0 ) implies ( R12 . R1 ) = ( <% R3 , R4 %> . R1 )) by L366 , L331;
thus L374: thesis by L373 , L371 , L370 , L372 , CARD_1:50 , TARSKI:def 2;
end;
L375: (for R1 being Nat holds (R1 in ( dom <% R5 %> ) implies ( R12 . ( ( len <% R3 , R4 %> ) + R1 ) ) = ( <% R5 %> . R1 )))
proof
let R1 being Nat;
assume L376: R1 in ( dom <% R5 %> );
L377: R1 in { ( 0 ) } by L376 , L268 , CARD_1:49;
L378: R1 = ( 0 ) by L377 , TARSKI:def 1;
thus L379: ( R12 . ( ( len <% R3 , R4 %> ) + R1 ) ) = ( R12 . ( 2 + ( 0 ) ) ) by L378 , L331
.= ( <% R5 %> . R1 ) by L368 , L378 , L268;
end;
L380: ( dom R12 ) = ( 2 + 1 ) by L365
.= ( ( len <% R3 , R4 %> ) + 1 ) by L331
.= ( ( len <% R3 , R4 %> ) + ( len <% R5 %> ) ) by L306;
thus L381: thesis by L380 , L369 , L375 , L110;
end;
registration
let R3 being set;
cluster <% R3 %> -> 1 -element;
coherence
proof
thus L382: ( card <% R3 %> ) = 1 by L306;
end;
let R4 being set;
cluster <% R3 , R4 %> -> 2 -element;
coherence
proof
thus L383: ( card <% R3 , R4 %> ) = 2 by L331;
end;
let R5 being set;
cluster <% R3 , R4 , R5 %> -> 3 -element;
coherence
proof
thus L384: ( card <% R3 , R4 , R5 %> ) = 3 by L354;
end;
end;
registration
let C29 being Nat;
cluster C29 -element -> C29 -defined for XFinSequence;
coherence
proof
let C30 being XFinSequence;
assume L386: ( card C30 ) = C29;
thus L387: ( dom C30 ) c= C29 by L386;
end;
end;
registration
let C31 being Nat;
let C32 being set;
cluster ( C31 --> C32 ) ->  finite  T-Sequence-like;
coherence;
end;
registration
let C33 being Nat;
cluster C33 -element for XFinSequence;
existence
proof
take ( C33 --> ( 0 ) );
thus L390: ( card ( C33 --> ( 0 ) ) ) = C33 by FUNCOP_1:13;
end;
end;
registration
let C34 being Nat;
cluster  ->  total for C34 -element C34 -defined C34 -element C34 -defined C34 -element C34 -defined C34 -element C34 -defined XFinSequence;
coherence
proof
let C35 being C34 -element XFinSequence;
L392: ( card C35 ) = C34 by CARD_1:def 7;
thus L393: ( dom C35 ) = C34 by L392;
end;
end;
theorem
L395: (for R12 being XFinSequence holds (R12 <> ( {} ) implies (ex R13 being XFinSequence st (ex R3 being set st R12 = ( R13 ^ <% R3 %> )))))
proof
let R12 being XFinSequence;
assume L396: R12 <> ( {} );
consider C36 being Nat such that L397: ( len R12 ) = ( C36 + 1 ) by L396 , NAT_1:6;
reconsider D18 = C36 as (Element of ( NAT )) by ORDINAL1:def 12;
set D19 = ( R12 | D18 );
L398: D18 <= ( len R12 ) by L397 , NAT_1:11;
L399: (( dom D19 ) = ( ( len R12 ) /\ D18 ) & D18 c= ( len R12 )) by L398 , NAT_1:39 , RELAT_1:61;
L400: ( dom D19 ) = D18 by L399 , XBOOLE_1:28;
L401: (for R3 being set holds (R3 in ( dom R12 ) implies ( R12 . R3 ) = ( ( D19 ^ <% ( R12 . ( ( len R12 ) - 1 ) ) %> ) . R3 )))
proof
let R3 being set;
assume L402: R3 in ( dom R12 );
reconsider D20 = R3 as (Element of ( NAT )) by L402;
L403:
now
assume L404: D20 in D18;
thus L405: ( R12 . D20 ) = ( D19 . D20 ) by L404 , L400 , FUNCT_1:47
.= ( ( D19 ^ <% ( R12 . ( ( len R12 ) - 1 ) ) %> ) . D20 ) by L400 , L404 , L110;
end;
L406:
now
L407: ( 0 ) in ( ( 0 ) + 1 ) by NAT_1:45;
L408: ( 0 ) in ( dom <% ( R12 . ( ( len R12 ) - 1 ) ) %> ) by L407 , L268;
assume L409: D20 in { D18 };
thus L410: ( ( D19 ^ <% ( R12 . ( ( len R12 ) - 1 ) ) %> ) . D20 ) = ( ( D19 ^ <% ( R12 . ( ( len R12 ) - 1 ) ) %> ) . ( ( len D19 ) + ( 0 ) ) ) by L409 , L400 , TARSKI:def 1
.= ( <% ( R12 . ( ( len R12 ) - 1 ) ) %> . ( 0 ) ) by L408 , L110
.= ( R12 . D18 ) by L397 , L268
.= ( R12 . D20 ) by L409 , TARSKI:def 1;
end;
L411: D20 in ( D18 \/ { D18 } ) by L397 , L402 , L2;
thus L412: thesis by L411 , L403 , L406 , XBOOLE_0:def 3;
end;
take D19;
take ( R12 . ( ( len R12 ) - 1 ) );
L413: ( dom ( D19 ^ <% ( R12 . ( ( len R12 ) - 1 ) ) %> ) ) = ( ( len D19 ) + ( len <% ( R12 . ( ( len R12 ) - 1 ) ) %> ) ) by L110
.= ( dom R12 ) by L397 , L400 , L306;
thus L414: ( D19 ^ <% ( R12 . ( ( len R12 ) - 1 ) ) %> ) = R12 by L413 , L401 , FUNCT_1:2;
end;
registration
let C37 being non  empty set;
let C38 being (Element of C37);
cluster <% C38 %> -> C37 -valued;
coherence;
let C39 being (Element of C37);
cluster <% C38 , C39 %> -> C37 -valued;
coherence;
let C40 being (Element of C37);
cluster <% C38 , C39 , C40 %> -> C37 -valued;
coherence;
end;
scheme IndXSeq { P2[XFinSequence] } : (for R12 being XFinSequence holds P2[ R12 ])
provided
L416: P2[ ( {} ) ]
and
L417: (for R12 being XFinSequence holds (for R3 being set holds (P2[ R12 ] implies P2[ ( R12 ^ <% R3 %> ) ])))
proof
defpred S1[ Real ] means (for R12 being XFinSequence holds (( len R12 ) = $1 implies P2[ R12 ]));
let R12 being XFinSequence;
consider C41 being (Subset of ( REAL )) such that L418: (for B21 being Real holds (B21 in C41 iff S1[ B21 ])) from SUBSET_1:sch 3;
L419: (for R1 being Nat holds R1 in C41)
proof
defpred S2[ Nat ] means $1 in C41;
L420: (for R12 being XFinSequence holds (( len R12 ) = ( 0 ) implies P2[ R12 ]))
proof
let R12 being XFinSequence;
assume L421: ( len R12 ) = ( 0 );
L422: R12 = ( {} ) by L421;
thus L423: thesis by L422 , L416;
end;
L424: S2[ ( 0 ) ] by L420 , L418;
L425: (for R2 being Nat holds (S2[ R2 ] implies S2[ ( R2 + 1 ) ]))
proof
let R2 being Nat;
assume L426: S2[ R2 ];
L427: S1[ ( R2 + 1 ) ]
proof
let R12 being XFinSequence;
assume L428: ( len R12 ) = ( R2 + 1 );
L429: R12 <> ( {} ) by L428;
consider C42 being XFinSequence, R3 being set such that L430: R12 = ( C42 ^ <% R3 %> ) by L429 , L395;
L431: ( len R12 ) = ( ( len C42 ) + ( len <% R3 %> ) ) by L430 , L110
.= ( ( len C42 ) + 1 ) by L268;
L432: P2[ C42 ] by L431 , L418 , L426 , L428;
thus L433: P2[ R12 ] by L432 , L430 , L417;
end;
thus L434: thesis by L427 , L418;
end;
thus L435: (for R1 being Nat holds S2[ R1 ]) from NAT_1:sch 2(L424 , L425);
end;
L436: ( len R12 ) in C41 by L419;
thus L437: thesis by L436 , L418;
end;
theorem
L438: (for B22 , B23 , B24 , B25 being XFinSequence holds ((( B22 ^ B23 ) = ( B24 ^ B25 ) & ( len B22 ) <= ( len B24 )) implies (ex B26 being XFinSequence st ( B22 ^ B26 ) = B24)))
proof
defpred S3[ XFinSequence ] means (for R12 being XFinSequence holds (for R13 being XFinSequence holds (for R15 being XFinSequence holds ((( R12 ^ R13 ) = ( $1 ^ R15 ) & ( len R12 ) <= ( len $1 )) implies (ex B27 being XFinSequence st ( R12 ^ B27 ) = $1)))));
L439: (for R14 being XFinSequence holds (for R3 being set holds (S3[ R14 ] implies S3[ ( R14 ^ <% R3 %> ) ])))
proof
let R14 being XFinSequence;
let R3 being set;
assume L440: (for R12 being XFinSequence holds (for R13 being XFinSequence holds (for R15 being XFinSequence holds ((( R12 ^ R13 ) = ( R14 ^ R15 ) & ( len R12 ) <= ( len R14 )) implies (ex R16 being XFinSequence st ( R12 ^ R16 ) = R14)))));
let R12 being XFinSequence;
let R13 being XFinSequence;
let R15 being XFinSequence;
assume that
L441: ( R12 ^ R13 ) = ( ( R14 ^ <% R3 %> ) ^ R15 )
and
L442: ( len R12 ) <= ( len ( R14 ^ <% R3 %> ) );
L443:
now
assume L444: ( len R12 ) <> ( len ( R14 ^ <% R3 %> ) );
L445: ( len R12 ) <> ( ( len R14 ) + ( len <% R3 %> ) ) by L444 , L110;
L446: ( len R12 ) <> ( ( len R14 ) + 1 ) by L445 , L306;
L447: ( len R12 ) <= ( ( len R14 ) + ( len <% R3 %> ) ) by L442 , L110;
L448: ( len R12 ) <= ( ( len R14 ) + 1 ) by L447 , L306;
L449: ( R12 ^ R13 ) = ( R14 ^ ( <% R3 %> ^ R15 ) ) by L441 , L209;
consider C43 being XFinSequence such that L450: ( R12 ^ C43 ) = R14 by L449 , L440 , L446 , L448 , NAT_1:8;
L451: ( R12 ^ ( C43 ^ <% R3 %> ) ) = ( R14 ^ <% R3 %> ) by L450 , L209;
thus L452: thesis by L451;
end;
L453:
now
assume L454: ( len R12 ) = ( len ( R14 ^ <% R3 %> ) );
L455: (for R1 being Nat holds (R1 in ( dom R12 ) implies ( R12 . R1 ) = ( ( R14 ^ <% R3 %> ) . R1 )))
proof
let R1 being Nat;
assume L456: R1 in ( dom R12 );
thus L457: ( R12 . R1 ) = ( ( ( R14 ^ <% R3 %> ) ^ R15 ) . R1 ) by L456 , L441 , L110
.= ( ( R14 ^ <% R3 %> ) . R1 ) by L454 , L456 , L110;
end;
L458: ( R12 ^ ( {} ) ) = ( R14 ^ <% R3 %> ) by L454 , L455 , L62;
thus L459: thesis by L458;
end;
thus L460: thesis by L453 , L443;
end;
L461: S3[ ( {} ) ]
proof
let R12 being XFinSequence;
let R13 being XFinSequence;
let R15 being XFinSequence;
assume that
L462: ( R12 ^ R13 ) = ( ( {} ) ^ R15 )
and
L463: ( len R12 ) <= ( len ( {} ) );
take ( {} );
thus L464: ( R12 ^ ( {} ) ) = ( {} ) by L463;
end;
L465: (for R14 being XFinSequence holds S3[ R14 ]) from IndXSeq(L461 , L439);
thus L466: thesis by L465;
end;
definition
let C44 being set;
func C44 ^omega -> set means 
:L467: (for R3 being set holds (R3 in it iff R3 is (XFinSequence of C44)));
existence
proof
defpred S4[ set ] means $1 is (XFinSequence of C44);
consider R8 being set such that L468: (for R3 being set holds (R3 in R8 iff (R3 in ( bool [: ( NAT ) , C44 :] ) & S4[ R3 ]))) from XBOOLE_0:sch 1;
take R8;
let R3 being set;
thus L469: (R3 in R8 implies R3 is (XFinSequence of C44)) by L468;
assume L470: R3 is (XFinSequence of C44);
reconsider D21 = R3 as (XFinSequence of C44) by L470;
reconsider D22 = D21 as (PartFunc of ( NAT ) , C44) by L88;
L471: D22 c= [: ( NAT ) , C44 :];
thus L472: thesis by L471 , L468;
end;
uniqueness
proof
defpred S5[ set ] means $1 is (XFinSequence of C44);
thus L473: (for B28 , B29 being set holds (((for B30 being set holds (B30 in B28 iff S5[ B30 ])) & (for B31 being set holds (B31 in B29 iff S5[ B31 ]))) implies B28 = B29)) from XBOOLE_0:sch 3;
end;
end;
registration
let C45 being set;
cluster ( C45 ^omega ) -> non  empty;
coherence
proof
set D23 = the (XFinSequence of C45);
L475: D23 in ( C45 ^omega ) by L467;
thus L476: thesis by L475;
end;
end;
theorem
L478: (for R3 being set holds (for R17 being set holds (R3 in ( R17 ^omega ) iff R3 is (XFinSequence of R17)))) by L467;
theorem
L479: (for R17 being set holds ( {} ) in ( R17 ^omega ))
proof
let R17 being set;
L480: ( {} ) = ( <%> R17 );
thus L481: thesis by L480 , L467;
end;
scheme SepXSeq { F4() -> non  empty set , P3[XFinSequence] } : (ex R8 being set st (for R3 being set holds (R3 in R8 iff (ex R12 being XFinSequence st (R12 in ( F4() ^omega ) & P3[ R12 ] & R3 = R12)))))
proof
defpred S6[ set ] means (ex R12 being XFinSequence st (P3[ R12 ] & $1 = R12));
consider R9 being set such that L482: (for R3 being set holds (R3 in R9 iff (R3 in ( F4() ^omega ) & S6[ R3 ]))) from XBOOLE_0:sch 1;
take R9;
L483: (for R3 being set holds (R3 in R9 implies (ex R12 being XFinSequence st (R12 in ( F4() ^omega ) & P3[ R12 ] & R3 = R12))))
proof
let R3 being set;
assume L484: R3 in R9;
L485: (R3 in ( F4() ^omega ) & (ex R12 being XFinSequence st (P3[ R12 ] & R3 = R12))) by L484 , L482;
thus L486: thesis by L485;
end;
thus L487: thesis by L483 , L482;
end;
notation
let C46 being XFinSequence;
let C47 , C48 being set;
synonym Replace (C46 , C47 , C48) for C46 +* (C47 , C48);
end;
registration
let C49 being XFinSequence;
let C50 , C51 being set;
cluster ( C49 +* (C50 , C51) ) ->  finite  T-Sequence-like;
coherence
proof
L489: ( dom ( C49 +* (C50 , C51) ) ) = ( dom C49 ) by FUNCT_7:30;
thus L490: thesis by L489 , FINSET_1:10 , ORDINAL1:def 7;
end;
end;
theorem
L492: (for B32 being XFinSequence holds (for B33 being (Element of ( NAT )) holds (for B34 being set holds (( len ( Replace (B32 , B33 , B34) ) ) = ( len B32 ) & (B33 < ( len B32 ) implies ( ( Replace (B32 , B33 , B34) ) . B33 ) = B34) & (for B35 being (Element of ( NAT )) holds (B35 <> B33 implies ( ( Replace (B32 , B33 , B34) ) . B35 ) = ( B32 . B35 )))))))
proof
let C52 being XFinSequence;
let C53 being (Element of ( NAT ));
let C54 being set;
set D24 = ( Replace (C52 , C53 , C54) );
thus L493: ( len D24 ) = ( len C52 ) by FUNCT_7:30;
L494: (C53 < ( len C52 ) implies (not ( dom C52 ) c= C53)) by NAT_1:39;
thus L495: (C53 < ( len C52 ) implies ( D24 . C53 ) = C54) by L494 , FUNCT_7:31 , ORDINAL1:16;
thus L496: thesis by FUNCT_7:32;
end;
registration
let C55 being non  empty set;
let C56 being (XFinSequence of C55);
let C57 being (Element of ( NAT ));
let C58 being (Element of C55);
cluster ( Replace (C56 , C57 , C58) ) -> C55 -valued;
coherence
proof
per cases ;
suppose L497: C57 in ( dom C56 );

L498: ( Replace (C56 , C57 , C58) ) = ( C56 +* ( C57 .--> C58 ) ) by L497 , FUNCT_7:def 3;
L499: ( rng ( Replace (C56 , C57 , C58) ) ) c= ( ( rng C56 ) \/ ( rng ( C57 .--> C58 ) ) ) by L498 , FUNCT_4:17;
L500: ( rng ( C57 .--> C58 ) ) = { C58 } by FUNCOP_1:8;
L501: ( rng ( C57 .--> C58 ) ) c= C55 by L500 , ZFMISC_1:31;
L502: ( rng C56 ) c= C55 by RELAT_1:def 19;
L503: ( ( rng C56 ) \/ ( rng ( C57 .--> C58 ) ) ) c= C55 by L502 , L501 , XBOOLE_1:8;
thus L504: ( rng ( Replace (C56 , C57 , C58) ) ) c= C55 by L503 , L499 , XBOOLE_1:1;
end;
suppose L505: (not C57 in ( dom C56 ));

L506: ( Replace (C56 , C57 , C58) ) = C56 by L505 , FUNCT_7:def 3;
thus L507: ( rng ( Replace (C56 , C57 , C58) ) ) c= C55 by L506 , RELAT_1:def 19;
end;
end;
end;
registration
cluster  ->  real-valued for (XFinSequence of ( REAL ));
coherence
proof
let C59 being (XFinSequence of ( REAL ));
L510: ( rng C59 ) c= ( REAL ) by RELAT_1:def 19;
thus L511: thesis by L510 , VALUED_0:def 3;
end;
end;
registration
cluster  ->  natural-valued for (XFinSequence of ( NAT ));
coherence
proof
let C60 being (XFinSequence of ( NAT ));
L513: ( rng C60 ) c= ( NAT ) by RELAT_1:def 19;
thus L514: thesis by L513 , VALUED_0:def 6;
end;
end;
theorem
L516: (for R12 being XFinSequence holds (for B36 , B37 , B38 , B39 being set holds (R12 = ( ( ( <% B36 %> ^ <% B37 %> ) ^ <% B38 %> ) ^ <% B39 %> ) implies (( len R12 ) = 4 & ( R12 . ( 0 ) ) = B36 & ( R12 . 1 ) = B37 & ( R12 . 2 ) = B38 & ( R12 . 3 ) = B39))))
proof
let R12 being XFinSequence;
let C61 , C62 , C63 , C64 being set;
assume L517: R12 = ( ( ( <% C61 %> ^ <% C62 %> ) ^ <% C63 %> ) ^ <% C64 %> );
set D25 = ( ( <% C61 %> ^ <% C62 %> ) ^ <% C63 %> );
L518: D25 = <% C61 , C62 , C63 %>;
L519: ( len D25 ) = 3 by L518 , L354;
L520: (( D25 . ( 0 ) ) = C61 & ( D25 . 1 ) = C62) by L518 , L354;
L521: ( D25 . 2 ) = C63 by L518 , L354;
thus L522: ( len R12 ) = ( ( len D25 ) + ( len <% C64 %> ) ) by L517 , L110
.= ( 3 + 1 ) by L519 , L306
.= 4;
L523: (( 0 ) in 3 & 1 in 3 & 2 in 3) by CARD_1:51 , ENUMSET1:def 1;
thus L524: (( R12 . ( 0 ) ) = C61 & ( R12 . 1 ) = C62 & ( R12 . 2 ) = C63) by L523 , L517 , L520 , L521 , L110 , L519;
thus L525: ( R12 . 3 ) = ( R12 . ( len D25 ) ) by L518 , L354
.= C64 by L517 , L325;
end;
theorem
L526: (for R12 being XFinSequence holds (for B40 , B41 , B42 , B43 , B44 being set holds (R12 = ( ( ( ( <% B40 %> ^ <% B41 %> ) ^ <% B42 %> ) ^ <% B43 %> ) ^ <% B44 %> ) implies (( len R12 ) = 5 & ( R12 . ( 0 ) ) = B40 & ( R12 . 1 ) = B41 & ( R12 . 2 ) = B42 & ( R12 . 3 ) = B43 & ( R12 . 4 ) = B44))))
proof
let R12 being XFinSequence;
let C65 , C66 , C67 , C68 , C69 being set;
assume L527: R12 = ( ( ( ( <% C65 %> ^ <% C66 %> ) ^ <% C67 %> ) ^ <% C68 %> ) ^ <% C69 %> );
set D26 = ( ( ( <% C65 %> ^ <% C66 %> ) ^ <% C67 %> ) ^ <% C68 %> );
L528: ( len D26 ) = 4 by L516;
L529: (( D26 . ( 0 ) ) = C65 & ( D26 . 1 ) = C66) by L516;
L530: (( D26 . 2 ) = C67 & ( D26 . 3 ) = C68) by L516;
thus L531: ( len R12 ) = ( ( len D26 ) + ( len <% C69 %> ) ) by L527 , L110
.= ( 4 + 1 ) by L528 , L306
.= 5;
L532: (( 0 ) in 4 & 1 in 4 & 2 in 4 & 3 in 4) by CARD_1:52 , ENUMSET1:def 2;
thus L533: (( R12 . ( 0 ) ) = C65 & ( R12 . 1 ) = C66 & ( R12 . 2 ) = C67 & ( R12 . 3 ) = C68) by L532 , L527 , L529 , L530 , L110 , L528;
thus L534: ( R12 . 4 ) = ( R12 . ( len D26 ) ) by L516
.= C69 by L527 , L325;
end;
theorem
L535: (for R12 being XFinSequence holds (for B45 , B46 , B47 , B48 , B49 , B50 being set holds (R12 = ( ( ( ( ( <% B45 %> ^ <% B46 %> ) ^ <% B47 %> ) ^ <% B48 %> ) ^ <% B49 %> ) ^ <% B50 %> ) implies (( len R12 ) = 6 & ( R12 . ( 0 ) ) = B45 & ( R12 . 1 ) = B46 & ( R12 . 2 ) = B47 & ( R12 . 3 ) = B48 & ( R12 . 4 ) = B49 & ( R12 . 5 ) = B50))))
proof
let R12 being XFinSequence;
let C70 , C71 , C72 , C73 , C74 , C75 being set;
assume L536: R12 = ( ( ( ( ( <% C70 %> ^ <% C71 %> ) ^ <% C72 %> ) ^ <% C73 %> ) ^ <% C74 %> ) ^ <% C75 %> );
set D27 = ( ( ( ( <% C70 %> ^ <% C71 %> ) ^ <% C72 %> ) ^ <% C73 %> ) ^ <% C74 %> );
L537: ( len D27 ) = 5 by L526;
L538: (( D27 . ( 0 ) ) = C70 & ( D27 . 1 ) = C71) by L526;
L539: (( D27 . 2 ) = C72 & ( D27 . 3 ) = C73) by L526;
L540: ( D27 . 4 ) = C74 by L526;
thus L541: ( len R12 ) = ( ( len D27 ) + ( len <% C75 %> ) ) by L536 , L110
.= ( 5 + 1 ) by L537 , L306
.= 6;
L542: (( 0 ) in 5 & 1 in 5 & 2 in 5 & 3 in 5 & 4 in 5) by CARD_1:53 , ENUMSET1:def 3;
thus L543: (( R12 . ( 0 ) ) = C70 & ( R12 . 1 ) = C71 & ( R12 . 2 ) = C72 & ( R12 . 3 ) = C73 & ( R12 . 4 ) = C74) by L542 , L536 , L538 , L539 , L540 , L110 , L537;
thus L544: ( R12 . 5 ) = ( R12 . ( len D27 ) ) by L526
.= C75 by L536 , L325;
end;
theorem
L545: (for R12 being XFinSequence holds (for B51 , B52 , B53 , B54 , B55 , B56 , B57 being set holds (R12 = ( ( ( ( ( ( <% B51 %> ^ <% B52 %> ) ^ <% B53 %> ) ^ <% B54 %> ) ^ <% B55 %> ) ^ <% B56 %> ) ^ <% B57 %> ) implies (( len R12 ) = 7 & ( R12 . ( 0 ) ) = B51 & ( R12 . 1 ) = B52 & ( R12 . 2 ) = B53 & ( R12 . 3 ) = B54 & ( R12 . 4 ) = B55 & ( R12 . 5 ) = B56 & ( R12 . 6 ) = B57))))
proof
let R12 being XFinSequence;
let C76 , C77 , C78 , C79 , C80 , C81 , C82 being set;
assume L546: R12 = ( ( ( ( ( ( <% C76 %> ^ <% C77 %> ) ^ <% C78 %> ) ^ <% C79 %> ) ^ <% C80 %> ) ^ <% C81 %> ) ^ <% C82 %> );
set D28 = ( ( ( ( ( <% C76 %> ^ <% C77 %> ) ^ <% C78 %> ) ^ <% C79 %> ) ^ <% C80 %> ) ^ <% C81 %> );
L547: ( len D28 ) = 6 by L535;
L548: (( D28 . ( 0 ) ) = C76 & ( D28 . 1 ) = C77) by L535;
L549: (( D28 . 2 ) = C78 & ( D28 . 3 ) = C79) by L535;
L550: (( D28 . 4 ) = C80 & ( D28 . 5 ) = C81) by L535;
thus L551: ( len R12 ) = ( ( len D28 ) + ( len <% C82 %> ) ) by L546 , L110
.= ( 6 + 1 ) by L547 , L306
.= 7;
L552: (( 0 ) in 6 & 1 in 6 & 2 in 6 & 3 in 6 & 4 in 6 & 5 in 6) by CARD_1:54 , ENUMSET1:def 4;
thus L553: (( R12 . ( 0 ) ) = C76 & ( R12 . 1 ) = C77 & ( R12 . 2 ) = C78 & ( R12 . 3 ) = C79 & ( R12 . 4 ) = C80 & ( R12 . 5 ) = C81) by L552 , L546 , L548 , L549 , L550 , L110 , L547;
thus L554: ( R12 . 6 ) = ( R12 . ( len D28 ) ) by L535
.= C82 by L546 , L325;
end;
theorem
L555: (for R12 being XFinSequence holds (for B58 , B59 , B60 , B61 , B62 , B63 , B64 , B65 being set holds (R12 = ( ( ( ( ( ( ( <% B58 %> ^ <% B59 %> ) ^ <% B60 %> ) ^ <% B61 %> ) ^ <% B62 %> ) ^ <% B63 %> ) ^ <% B64 %> ) ^ <% B65 %> ) implies (( len R12 ) = 8 & ( R12 . ( 0 ) ) = B58 & ( R12 . 1 ) = B59 & ( R12 . 2 ) = B60 & ( R12 . 3 ) = B61 & ( R12 . 4 ) = B62 & ( R12 . 5 ) = B63 & ( R12 . 6 ) = B64 & ( R12 . 7 ) = B65))))
proof
let R12 being XFinSequence;
let C83 , C84 , C85 , C86 , C87 , C88 , C89 , C90 being set;
assume L556: R12 = ( ( ( ( ( ( ( <% C83 %> ^ <% C84 %> ) ^ <% C85 %> ) ^ <% C86 %> ) ^ <% C87 %> ) ^ <% C88 %> ) ^ <% C89 %> ) ^ <% C90 %> );
set D29 = ( ( ( ( ( ( <% C83 %> ^ <% C84 %> ) ^ <% C85 %> ) ^ <% C86 %> ) ^ <% C87 %> ) ^ <% C88 %> ) ^ <% C89 %> );
L557: ( len D29 ) = 7 by L545;
L558: (( D29 . ( 0 ) ) = C83 & ( D29 . 1 ) = C84) by L545;
L559: (( D29 . 2 ) = C85 & ( D29 . 3 ) = C86) by L545;
L560: (( D29 . 4 ) = C87 & ( D29 . 5 ) = C88) by L545;
L561: ( D29 . 6 ) = C89 by L545;
thus L562: ( len R12 ) = ( ( len D29 ) + ( len <% C90 %> ) ) by L556 , L110
.= ( 7 + 1 ) by L557 , L306
.= 8;
L563: (( 0 ) in 7 & 1 in 7 & 2 in 7 & 3 in 7 & 4 in 7 & 5 in 7 & 6 in 7) by CARD_1:55 , ENUMSET1:def 5;
thus L564: (( R12 . ( 0 ) ) = C83 & ( R12 . 1 ) = C84 & ( R12 . 2 ) = C85 & ( R12 . 3 ) = C86 & ( R12 . 4 ) = C87 & ( R12 . 5 ) = C88 & ( R12 . 6 ) = C89) by L563 , L556 , L558 , L559 , L560 , L561 , L110 , L557;
thus L565: ( R12 . 7 ) = ( R12 . ( len D29 ) ) by L545
.= C90 by L556 , L325;
end;
theorem
L566: (for R12 being XFinSequence holds (for B66 , B67 , B68 , B69 , B70 , B71 , B72 , B73 , B74 being set holds (R12 = ( ( ( ( ( ( ( ( <% B66 %> ^ <% B67 %> ) ^ <% B68 %> ) ^ <% B69 %> ) ^ <% B70 %> ) ^ <% B71 %> ) ^ <% B72 %> ) ^ <% B73 %> ) ^ <% B74 %> ) implies (( len R12 ) = 9 & ( R12 . ( 0 ) ) = B66 & ( R12 . 1 ) = B67 & ( R12 . 2 ) = B68 & ( R12 . 3 ) = B69 & ( R12 . 4 ) = B70 & ( R12 . 5 ) = B71 & ( R12 . 6 ) = B72 & ( R12 . 7 ) = B73 & ( R12 . 8 ) = B74))))
proof
let R12 being XFinSequence;
let C91 , C92 , C93 , C94 , C95 , C96 , C97 , C98 , C99 being set;
assume L567: R12 = ( ( ( ( ( ( ( ( <% C91 %> ^ <% C92 %> ) ^ <% C93 %> ) ^ <% C94 %> ) ^ <% C95 %> ) ^ <% C96 %> ) ^ <% C97 %> ) ^ <% C98 %> ) ^ <% C99 %> );
set D30 = ( ( ( ( ( ( ( <% C91 %> ^ <% C92 %> ) ^ <% C93 %> ) ^ <% C94 %> ) ^ <% C95 %> ) ^ <% C96 %> ) ^ <% C97 %> ) ^ <% C98 %> );
L568: ( len D30 ) = 8 by L555;
L569: (( D30 . ( 0 ) ) = C91 & ( D30 . 1 ) = C92) by L555;
L570: (( D30 . 2 ) = C93 & ( D30 . 3 ) = C94) by L555;
L571: (( D30 . 4 ) = C95 & ( D30 . 5 ) = C96) by L555;
L572: (( D30 . 6 ) = C97 & ( D30 . 7 ) = C98) by L555;
thus L573: ( len R12 ) = ( ( len D30 ) + ( len <% C99 %> ) ) by L567 , L110
.= ( 8 + 1 ) by L568 , L306
.= 9;
L574: (( 0 ) in 8 & 1 in 8 & 2 in 8 & 3 in 8 & 4 in 8 & 5 in 8 & 6 in 8 & 7 in 8) by CARD_1:56 , ENUMSET1:def 6;
thus L575: (( R12 . ( 0 ) ) = C91 & ( R12 . 1 ) = C92 & ( R12 . 2 ) = C93 & ( R12 . 3 ) = C94 & ( R12 . 4 ) = C95 & ( R12 . 5 ) = C96 & ( R12 . 6 ) = C97 & ( R12 . 7 ) = C98) by L574 , L567 , L569 , L570 , L571 , L572 , L110 , L568;
thus L576: ( R12 . 8 ) = ( R12 . ( len D30 ) ) by L555
.= C99 by L567 , L325;
end;
theorem
L577: (for R2 being Nat holds (for R12 being XFinSequence holds (for R13 being XFinSequence holds (R2 < ( len R12 ) implies ( ( R12 ^ R13 ) . R2 ) = ( R12 . R2 )))))
proof
let R2 being Nat;
let R12 being XFinSequence;
let R13 being XFinSequence;
assume L578: R2 < ( len R12 );
L579: R2 in ( dom R12 ) by L578 , NAT_1:44;
thus L580: thesis by L579 , L110;
end;
theorem
L581: (for R2 being Nat holds (for R12 being XFinSequence holds (( len R12 ) <= R2 implies ( R12 | R2 ) = R12)))
proof
let R2 being Nat;
let R12 being XFinSequence;
assume L582: ( len R12 ) <= R2;
L583: ( ( len R12 ) /\ R2 ) = ( len R12 ) by L582 , NAT_1:46;
thus L584: thesis by L583 , RELAT_1:68 , XBOOLE_1:18;
end;
theorem
L585: (for R1 being Nat holds (for R2 being Nat holds (for R12 being XFinSequence holds ((R2 <= ( len R12 ) & R1 in R2) implies (( ( R12 | R2 ) . R1 ) = ( R12 . R1 ) & R1 in ( dom R12 ))))))
proof
let R1 being Nat;
let R2 being Nat;
let R12 being XFinSequence;
assume that
L586: R2 <= ( len R12 )
and
L587: R1 in R2;
L588: R2 c= ( dom R12 ) by L586 , NAT_1:39;
L589: R2 = ( ( dom R12 ) /\ R2 ) by L588 , XBOOLE_1:28
.= ( dom ( R12 | R2 ) ) by RELAT_1:61;
thus L590: thesis by L589 , L587 , L588 , FUNCT_1:47;
end;
theorem
L591: (for R2 being Nat holds (for R12 being XFinSequence holds (R2 <= ( len R12 ) implies ( len ( R12 | R2 ) ) = R2)))
proof
let R2 being Nat;
let R12 being XFinSequence;
assume L592: R2 <= ( len R12 );
L593: R2 c= ( len R12 ) by L592 , NAT_1:39;
thus L594: thesis by L593 , RELAT_1:62;
end;
theorem
L595: (for R2 being Nat holds (for R12 being XFinSequence holds ( len ( R12 | R2 ) ) <= R2))
proof
let R2 being Nat;
let R12 being XFinSequence;
L596: ( dom ( R12 | R2 ) ) c= R2 by RELAT_1:58;
thus L597: thesis by L596 , NAT_1:39;
end;
theorem
L598: (for R2 being Nat holds (for R12 being XFinSequence holds (( len R12 ) = ( R2 + 1 ) implies R12 = ( ( R12 | R2 ) ^ <% ( R12 . R2 ) %> ))))
proof
let R2 being Nat;
let R12 being XFinSequence;
set D31 = ( R12 | R2 );
set D32 = ( R12 . R2 );
assume L599: ( len R12 ) = ( R2 + 1 );
L600: R2 < ( len R12 ) by L599 , NAT_1:13;
L601: ( len D31 ) = R2 by L600 , L591;
L602:
now
let C100 being Nat;
assume L603: C100 in ( dom R12 );
L604: C100 < ( len R12 ) by L603 , NAT_1:44;
L605: C100 <= ( len D31 ) by L604 , L599 , L601 , NAT_1:13;
L606:
now
per cases ;
case L607: C100 = ( len D31 );
thus L608: ( R12 . C100 ) = ( ( D31 ^ <% D32 %> ) . C100 ) by L607 , L601 , L325;
end;
case L609: C100 <> ( len D31 );
L610: C100 < ( len D31 ) by L609 , L605 , XXREAL_0:1;
L611: C100 in ( dom D31 ) by L610 , NAT_1:44;
thus L612: ( ( D31 ^ <% D32 %> ) . C100 ) = ( D31 . C100 ) by L611 , L110
.= ( R12 . C100 ) by L600 , L601 , L611 , L585;
end;
end;
thus L614: ( R12 . C100 ) = ( ( D31 ^ <% D32 %> ) . C100 ) by L606;
end;
L615: ( len ( D31 ^ <% D32 %> ) ) = ( R2 + ( len <% D32 %> ) ) by L601 , L110
.= ( len R12 ) by L599 , L268;
thus L616: thesis by L615 , L602 , L62;
end;
theorem
L617: (for R12 being XFinSequence holds (for R13 being XFinSequence holds ( ( R12 ^ R13 ) | ( dom R12 ) ) = R12))
proof
let R12 being XFinSequence;
let R13 being XFinSequence;
set D33 = ( ( R12 ^ R13 ) | ( dom R12 ) );
L618:
now
let R1 being Nat;
assume that
L619: R1 < ( len R12 );
L620: R1 in ( dom R12 ) by L619 , NAT_1:44;
L621: ( ( R12 ^ R13 ) . R1 ) = ( R12 . R1 ) by L620 , L110;
L622: ( R1 + ( 0 ) ) < ( ( len R12 ) + ( len R13 ) ) by L619 , XREAL_1:8;
L623: R1 in ( ( len R12 ) + ( len R13 ) ) by L622 , NAT_1:44;
L624: R1 in ( dom ( R12 ^ R13 ) ) by L623 , L110;
L625: R1 in ( ( dom ( R12 ^ R13 ) ) /\ ( dom R12 ) ) by L624 , L620 , XBOOLE_0:def 4;
thus L626: ( D33 . R1 ) = ( R12 . R1 ) by L625 , L621 , FUNCT_1:48;
end;
L627: ( dom R12 ) c= ( dom ( R12 ^ R13 ) ) by L155;
L628: ( len D33 ) = ( len R12 ) by L627 , RELAT_1:62;
thus L629: thesis by L628 , L618 , L67;
end;
theorem
L630: (for R2 being Nat holds (for R12 being XFinSequence holds (for R13 being XFinSequence holds (R2 <= ( dom R12 ) implies ( ( R12 ^ R13 ) | R2 ) = ( R12 | R2 )))))
proof
let R2 being Nat;
let R12 being XFinSequence;
let R13 being XFinSequence;
assume L631: R2 <= ( dom R12 );
L632: R2 c= ( dom R12 ) by L631 , NAT_1:39;
L633: ( ( ( R12 ^ R13 ) | ( dom R12 ) ) | R2 ) = ( ( R12 ^ R13 ) | R2 ) by L632 , RELAT_1:74;
thus L634: thesis by L633 , L617;
end;
theorem
L635: (for R1 being Nat holds (for R2 being Nat holds (for R12 being XFinSequence holds (for R13 being XFinSequence holds (R2 = ( ( dom R12 ) + R1 ) implies ( ( R12 ^ R13 ) | R2 ) = ( R12 ^ ( R13 | R1 ) ))))))
proof
let R1 being Nat;
let R2 being Nat;
let R12 being XFinSequence;
let R13 being XFinSequence;
assume L636: R2 = ( ( dom R12 ) + R1 );
L637:
now
per cases ;
suppose L638: R2 >= ( len ( R12 ^ R13 ) );

L639: R2 >= ( ( len R12 ) + ( len R13 ) ) by L638 , L110;
L640: R1 >= ( len R13 ) by L639 , L636 , XREAL_1:8;
L641: ( dom R13 ) c= R1 by L640 , NAT_1:39;
L642: ( R13 | R1 ) = R13 by L641 , RELAT_1:68;
L643: ( dom ( R12 ^ R13 ) ) c= R2 by L638 , NAT_1:39;
thus L644: thesis by L643 , L642 , RELAT_1:68;
end;
suppose L645: R2 < ( len ( R12 ^ R13 ) );

L646: ( len ( ( R12 ^ R13 ) | R2 ) ) = R2 by L645 , L80;
L647: R2 < ( ( len R12 ) + ( len R13 ) ) by L645 , L110;
L648: R1 < ( len R13 ) by L647 , L636 , XREAL_1:6;
L649: ( len ( R13 | R1 ) ) = R1 by L648 , L80;
L650: ( len ( R12 ^ ( R13 | R1 ) ) ) = ( ( len R12 ) + R1 ) by L649 , L110;
L651:
now
let C101 being Nat;
assume that
L652: C101 in ( dom ( ( R12 ^ R13 ) | R2 ) );
L653: C101 < ( len ( ( R12 ^ R13 ) | R2 ) ) by L652 , NAT_1:44;
L654: C101 < ( len ( R12 ^ R13 ) ) by L653 , L645 , L646 , XXREAL_0:2;
L655: C101 in ( len ( R12 ^ R13 ) ) by L654 , NAT_1:44;
L656: C101 in R2 by L645 , L80 , L652;
L657: C101 in ( ( dom ( R12 ^ R13 ) ) /\ R2 ) by L656 , L655 , XBOOLE_0:def 4;
L658: ( ( ( R12 ^ R13 ) | R2 ) . C101 ) = ( ( R12 ^ R13 ) . C101 ) by L657 , FUNCT_1:48;
L659:
now
per cases ;
suppose L660: C101 < ( dom R12 );

L661: C101 in ( dom R12 ) by L660 , NAT_1:44;
L662: (( ( R12 ^ ( R13 | R1 ) ) . C101 ) = ( R12 . C101 ) & ( ( R12 ^ R13 ) . C101 ) = ( R12 . C101 )) by L661 , L110;
thus L663: ( ( ( R12 ^ R13 ) | R2 ) . C101 ) = ( ( R12 ^ ( R13 | R1 ) ) . C101 ) by L662 , L657 , FUNCT_1:48;
end;
suppose L664: C101 >= ( dom R12 );

L665: C101 < ( len ( R12 ^ R13 ) ) by L645 , L646 , L653 , XXREAL_0:2;
L666: ( R13 . ( C101 - ( len R12 ) ) ) = ( ( R12 ^ R13 ) . C101 ) by L665 , L664 , L139;
L667: ( ( C101 - ( len R12 ) ) + ( len R12 ) ) < ( len ( R12 ^ R13 ) ) by L645 , L646 , L653 , XXREAL_0:2;
L668: ( C101 - ( len R12 ) ) is Nat by L664 , NAT_1:21;
L669: ( len ( R12 ^ R13 ) ) = ( ( len R12 ) + ( len R13 ) ) by L110;
L670: ( C101 - ( len R12 ) ) < ( len R13 ) by L669 , L667 , XREAL_1:6;
L671: ( C101 - ( len R12 ) ) in ( len R13 ) by L670 , L668 , NAT_1:44;
L672: ( C101 - ( len R12 ) ) < R1 by L636 , L646 , L667 , L653 , XREAL_1:6;
L673: ( C101 - ( len R12 ) ) in R1 by L672 , L668 , NAT_1:44;
L674: ( C101 - ( len R12 ) ) in ( R1 /\ ( dom R13 ) ) by L673 , L671 , XBOOLE_0:def 4;
L675: ( ( R12 ^ ( R13 | R1 ) ) . C101 ) = ( ( R13 | R1 ) . ( C101 - ( len R12 ) ) ) by L636 , L650 , L646 , L664 , L653 , L139;
thus L676: ( ( ( R12 ^ R13 ) | R2 ) . C101 ) = ( ( R12 ^ ( R13 | R1 ) ) . C101 ) by L675 , L658 , L666 , L674 , FUNCT_1:48;
end;
end;
thus L678: ( ( ( R12 ^ R13 ) | R2 ) . C101 ) = ( ( R12 ^ ( R13 | R1 ) ) . C101 ) by L659;
end;
thus L679: thesis by L651 , L62 , L650 , L636 , L645 , L80;
end;
end;
thus L681: thesis by L637;
end;
theorem
L682: (for R2 being Nat holds (for R12 being XFinSequence holds (ex R13 being XFinSequence st R12 = ( ( R12 | R2 ) ^ R13 ))))
proof
let R2 being Nat;
let R12 being XFinSequence;
L683:
now
per cases ;
suppose L684: R2 > ( len R12 );

L685: ( len R12 ) c= R2 by L684 , NAT_1:39;
L686: ( R12 | R2 ) = R12 by L685 , RELAT_1:68;
L687: ( R12 ^ ( {} ) ) = R12;
thus L688: thesis by L687 , L686;
end;
suppose L689: R2 <= ( len R12 );

reconsider D34 = ( ( len R12 ) - R2 ) as (Element of ( NAT )) by L689 , NAT_1:21;
defpred S7[ Nat ] means (for R1 being Nat holds (R1 = ( ( len R12 ) - $1 ) implies (ex R13 being XFinSequence st R12 = ( ( R12 | R1 ) ^ R13 ))));
L690: (for B75 being Nat holds (S7[ B75 ] implies S7[ ( B75 + 1 ) ]))
proof
let C102 being Nat;
assume that
L691: S7[ C102 ];
let R1 being Nat;
assume that
L692: R1 = ( ( len R12 ) - ( C102 + 1 ) );
consider R13 being XFinSequence such that L693: R12 = ( ( R12 | ( R1 + 1 ) ) ^ R13 ) by L691 , L692;
L694: R1 <= ( R1 + 1 ) by NAT_1:11;
L695: R1 c= ( R1 + 1 ) by L694 , NAT_1:39;
L696: ( ( R12 | ( R1 + 1 ) ) | R1 ) = ( R12 | R1 ) by L695 , RELAT_1:74;
L697: ( ( len R12 ) - C102 ) <= ( ( len R12 ) - ( 0 ) ) by XREAL_1:10;
L698: ( len ( R12 | ( R1 + 1 ) ) ) = ( R1 + 1 ) by L697 , L591 , L692;
L699: ( R12 | ( R1 + 1 ) ) = ( ( ( R12 | ( R1 + 1 ) ) | R1 ) ^ <% ( ( R12 | ( R1 + 1 ) ) . R1 ) %> ) by L698 , L598;
L700: R12 = ( ( R12 | R1 ) ^ ( <% ( ( R12 | ( R1 + 1 ) ) . R1 ) %> ^ R13 ) ) by L699 , L693 , L696 , L209;
thus L701: thesis by L700;
end;
L702: (( R12 | ( ( len R12 ) - ( 0 ) ) ) = R12 & ( R12 ^ ( {} ) ) = R12) by RELAT_1:68;
L703: S7[ ( 0 ) ] by L702;
L704: (for B76 being Nat holds S7[ B76 ]) from NAT_1:sch 2(L703 , L690);
L705: R2 = ( ( len R12 ) - D34 );
thus L706: thesis by L705 , L704;
end;
end;
thus L708: thesis by L683;
end;
theorem
L709: (for R1 being Nat holds (for R2 being Nat holds (for R12 being XFinSequence holds (( len R12 ) = ( R2 + R1 ) implies (ex B77 , B78 being XFinSequence st (( len B77 ) = R2 & ( len B78 ) = R1 & R12 = ( B77 ^ B78 )))))))
proof
let R1 being Nat;
let R2 being Nat;
let R12 being XFinSequence;
defpred S8[ Nat ] means (for B79 being XFinSequence holds (for B80 , B81 being Nat holds ((( len B79 ) = $1 & ( len B79 ) = ( B80 + B81 )) implies (ex B82 , B83 being XFinSequence st (( len B82 ) = B80 & ( len B83 ) = B81 & B79 = ( B82 ^ B83 ))))));
L710:
now
let R2 being Nat;
assume L711: S8[ R2 ];
thus L712: S8[ ( R2 + 1 ) ]
proof
let C103 being XFinSequence;
let C104 , C105 being Nat;
assume that
L713: ( len C103 ) = ( R2 + 1 )
and
L714: ( len C103 ) = ( C104 + C105 );
per cases ;
suppose L715: C105 = ( 0 );

take D35 = C103;
take D36 = ( {} );
L716: ( C103 ^ ( {} ) ) = C103;
thus L717: thesis by L716 , L714 , L715;
end;
suppose L718: C105 > ( 0 );

consider R1 being Nat such that L719: C105 = ( R1 + 1 ) by L718 , NAT_1:6;
L720: C103 <> ( {} ) by L713;
consider C106 being XFinSequence, R3 being set such that L721: C103 = ( C106 ^ <% R3 %> ) by L720 , L395;
L722: ( R2 + 1 ) = ( ( len C106 ) + ( len <% R3 %> ) ) by L713 , L721 , L110
.= ( ( len C106 ) + 1 ) by L306;
L723: R2 = ( C104 + R1 ) by L713 , L714 , L719;
consider C107 , C108 being XFinSequence such that L724: ( len C107 ) = C104 and L725: ( len C108 ) = R1 and L726: C106 = ( C107 ^ C108 ) by L723 , L711 , L722;
L727: ( len ( C108 ^ <% R3 %> ) ) = ( ( len C108 ) + ( len <% R3 %> ) ) by L110
.= C105 by L719 , L725 , L306;
L728: C103 = ( C107 ^ ( C108 ^ <% R3 %> ) ) by L721 , L726 , L209;
thus L729: thesis by L728 , L724 , L727;
end;
end;

end;
L713: S8[ ( 0 ) ]
proof
let C109 being XFinSequence;
let C110 , C111 being Nat;
assume that
L714: ( len C109 ) = ( 0 )
and
L715: ( len C109 ) = ( C110 + C111 );
L716: C109 = ( {} ) by L714;
L717: C109 = ( ( {} ) ^ ( {} ) ) by L716;
L718: ( len ( {} ) ) = C110 by L714 , L715;
thus L719: thesis by L718 , L715 , L717;
end;
L720: (for R2 being Nat holds S8[ R2 ]) from NAT_1:sch 2(L713 , L710);
thus L721: thesis by L720;
end;
theorem
L722: (for R3 being set holds (for R4 being set holds (for R12 being XFinSequence holds (for R13 being XFinSequence holds (( <% R3 %> ^ R12 ) = ( <% R4 %> ^ R13 ) implies (R3 = R4 & R12 = R13))))))
proof
let R3 being set;
let R4 being set;
let R12 being XFinSequence;
let R13 being XFinSequence;
assume L723: ( <% R3 %> ^ R12 ) = ( <% R4 %> ^ R13 );
L724: ( ( <% R3 %> ^ R12 ) . ( 0 ) ) = R3 by L320;
L725: R3 = R4 by L724 , L723 , L320;
thus L726: thesis by L725 , L723 , L228;
end;
definition
let C112 being set;
let C113 being (FinSequence of C112);
func FS2XFS C113 -> (XFinSequence of C112) means 
:L727: (( len it ) = ( len C113 ) & (for B84 being Nat holds (B84 < ( len C113 ) implies ( C113 . ( B84 + 1 ) ) = ( it . B84 ))));
existence
proof
deffunc H2(Nat) = ( C113 . ( $1 + 1 ) );
L728: (ex B85 being XFinSequence st (( len B85 ) = ( len C113 ) & (for B86 being Nat holds (B86 in ( len C113 ) implies ( B85 . B86 ) = H2(B86))))) from XSeqLambda;
consider C114 being XFinSequence such that L729: ( len C114 ) = ( len C113 ) and L730: (for B87 being Nat holds (B87 in ( len C113 ) implies ( C114 . B87 ) = H2(B87))) by L728;
L731: ( rng C114 ) c= C112
proof
let C115 being set;
L732: ( rng C113 ) c= C112 by FINSEQ_1:def 4;
assume L733: C115 in ( rng C114 );
consider C116 being set such that L734: C116 in ( dom C114 ) and L735: C115 = ( C114 . C116 ) by L733 , FUNCT_1:def 3;
reconsider D37 = C116 as (Element of ( NAT )) by L734;
L736: D37 < ( len C113 ) by L729 , L734 , NAT_1:44;
L737: ( D37 + 1 ) <= ( len C113 ) by L736 , NAT_1:13;
L738: ( ( 0 ) + 1 ) <= ( D37 + 1 ) by NAT_1:13;
L739: ( D37 + 1 ) in ( Seg ( len C113 ) ) by L738 , L737 , FINSEQ_1:1;
L740: ( D37 + 1 ) in ( dom C113 ) by L739 , FINSEQ_1:def 3;
L741: ( C113 . ( D37 + 1 ) ) in ( rng C113 ) by L740 , FUNCT_1:def 3;
L742: ( C114 . D37 ) = ( C113 . ( D37 + 1 ) ) by L729 , L730 , L734;
thus L743: thesis by L742 , L735 , L741 , L732;
end;
L744: C114 is (XFinSequence of C112) by L731 , RELAT_1:def 19;
L745: (for B88 being Nat holds (B88 < ( len C113 ) implies ( C113 . ( B88 + 1 ) ) = ( C114 . B88 )))
proof
let C117 being Nat;
assume L746: C117 < ( len C113 );
L747: (C117 in ( NAT ) & C117 in ( len C113 )) by L746 , NAT_1:44 , ORDINAL1:def 12;
thus L748: thesis by L747 , L730;
end;
thus L749: thesis by L745 , L729 , L744;
end;
uniqueness
proof
thus L750: (for B89 , B90 being (XFinSequence of C112) holds ((( len B89 ) = ( len C113 ) & (for B91 being Nat holds (B91 < ( len C113 ) implies ( C113 . ( B91 + 1 ) ) = ( B89 . B91 ))) & ( len B90 ) = ( len C113 ) & (for B92 being Nat holds (B92 < ( len C113 ) implies ( C113 . ( B92 + 1 ) ) = ( B90 . B92 )))) implies B89 = B90))
proof
let C118 , C119 being (XFinSequence of C112);
assume that
L751: ( len C118 ) = ( len C113 )
and
L752: (for B93 being Nat holds (B93 < ( len C113 ) implies ( C113 . ( B93 + 1 ) ) = ( C118 . B93 )))
and
L753: ( len C119 ) = ( len C113 )
and
L754: (for B94 being Nat holds (B94 < ( len C113 ) implies ( C113 . ( B94 + 1 ) ) = ( C119 . B94 )));
L755: (for B95 being Nat holds (B95 < ( len C118 ) implies ( C118 . B95 ) = ( C119 . B95 )))
proof
let C120 being Nat;
assume L756: C120 < ( len C118 );
L757: ( C113 . ( C120 + 1 ) ) = ( C118 . C120 ) by L756 , L751 , L752;
thus L758: thesis by L757 , L751 , L754 , L756;
end;
thus L759: thesis by L755 , L751 , L753 , L67;
end;

end;
end;
definition
let C121 being set;
let C122 being (XFinSequence of C121);
func XFS2FS C122 -> (FinSequence of C121) means 
(( len it ) = ( len C122 ) & (for B96 being Nat holds ((1 <= B96 & B96 <= ( len C122 )) implies ( C122 . ( B96 -' 1 ) ) = ( it . B96 ))));
existence
proof
deffunc H3(Nat) = ( C122 . ( $1 -' 1 ) );
L752: (ex B97 being FinSequence st (( len B97 ) = ( len C122 ) & (for B98 being Nat holds (B98 in ( dom B97 ) implies ( B97 . B98 ) = H3(B98))))) from FINSEQ_1:sch 2;
consider C123 being FinSequence such that L753: ( len C123 ) = ( len C122 ) and L754: (for B99 being Nat holds (B99 in ( dom C123 ) implies ( C123 . B99 ) = H3(B99))) by L752;
L755: ( rng C123 ) c= C121
proof
let C124 being set;
L756: ( rng C122 ) c= C121 by RELAT_1:def 19;
assume L757: C124 in ( rng C123 );
consider C125 being set such that L758: C125 in ( dom C123 ) and L759: C124 = ( C123 . C125 ) by L757 , FUNCT_1:def 3;
reconsider D38 = C125 as (Element of ( NAT )) by L758;
L760: D38 in ( Seg ( len C122 ) ) by L753 , L758 , FINSEQ_1:def 3;
L761: 1 <= D38 by L760 , FINSEQ_1:1;
L762: ( D38 - 1 ) >= ( 0 ) by L761 , XREAL_1:48;
L763: ( D38 - 1 ) = ( D38 -' 1 ) by L762 , XREAL_0:def 2;
L764: ( D38 -' 1 ) < ( ( D38 -' 1 ) + 1 ) by NAT_1:13;
L765: D38 <= ( len C122 ) by L760 , FINSEQ_1:1;
L766: ( D38 -' 1 ) < ( len C122 ) by L765 , L763 , L764 , XXREAL_0:2;
L767: ( D38 -' 1 ) in ( dom C122 ) by L766 , NAT_1:44;
L768: ( C122 . ( D38 -' 1 ) ) in ( rng C122 ) by L767 , FUNCT_1:def 3;
L769: ( C123 . D38 ) = ( C122 . ( D38 -' 1 ) ) by L754 , L758;
thus L770: thesis by L769 , L759 , L768 , L756;
end;
L771: C123 is (FinSequence of C121) by L755 , FINSEQ_1:def 4;
L772: ( dom C123 ) = ( Seg ( len C122 ) ) by L753 , FINSEQ_1:def 3;
L773: (for B100 being Nat holds ((1 <= B100 & B100 <= ( len C122 )) implies ( C122 . ( B100 -' 1 ) ) = ( C123 . B100 )))
proof
let C126 being Nat;
assume L774: (1 <= C126 & C126 <= ( len C122 ));
L775: C126 in ( Seg ( len C122 ) ) by L774 , FINSEQ_1:1;
thus L776: thesis by L775 , L754 , L772;
end;
thus L777: thesis by L773 , L753 , L771;
end;
uniqueness
proof
thus L778: (for B101 , B102 being (FinSequence of C121) holds ((( len B101 ) = ( len C122 ) & (for R18 being Nat holds ((1 <= R18 & R18 <= ( len C122 )) implies ( C122 . ( R18 -' 1 ) ) = ( B101 . R18 ))) & ( len B102 ) = ( len C122 ) & (for R18 being Nat holds ((1 <= R18 & R18 <= ( len C122 )) implies ( C122 . ( R18 -' 1 ) ) = ( B102 . R18 )))) implies B101 = B102))
proof
let C127 , C128 being (FinSequence of C121);
assume that
L779: ( len C127 ) = ( len C122 )
and
L780: (for R18 being Nat holds ((1 <= R18 & R18 <= ( len C122 )) implies ( C122 . ( R18 -' 1 ) ) = ( C127 . R18 )))
and
L781: ( len C128 ) = ( len C122 )
and
L782: (for R18 being Nat holds ((1 <= R18 & R18 <= ( len C122 )) implies ( C122 . ( R18 -' 1 ) ) = ( C128 . R18 )));
L783: (for B103 being Nat holds ((1 <= B103 & B103 <= ( len C127 )) implies ( C127 . B103 ) = ( C128 . B103 )))
proof
let C129 being Nat;
assume L784: (1 <= C129 & C129 <= ( len C127 ));
L785: ( C122 . ( C129 -' 1 ) ) = ( C127 . C129 ) by L784 , L779 , L780;
thus L786: thesis by L785 , L779 , L782 , L784;
end;
thus L787: thesis by L783 , L779 , L781 , FINSEQ_1:14;
end;

end;
end;
theorem
L780: (for B104 being set holds (for B105 being Nat holds (for B106 being set holds (B106 in B104 implies ( B105 --> B106 ) is (XFinSequence of B104)))));
definition
let C130 being non  empty set;
let C131 being (FinSequence of C130);
let C132 being Nat;
assume that
L781: C132 > ( len C131 )
and
L782: ( NAT ) c= C130;
func FS2XFS* (C131 , C132) -> non  empty (XFinSequence of C130) means 
(( len C131 ) = ( it . ( 0 ) ) & ( len it ) = C132 & (for B107 being Nat holds ((1 <= B107 & B107 <= ( len C131 )) implies ( it . B107 ) = ( C131 . B107 ))) & (for B108 being Nat holds ((( len C131 ) < B108 & B108 < C132) implies ( it . B108 ) = ( 0 ))));
existence
proof
L783: ( len C131 ) in ( NAT );
reconsider D39 = ( len C131 ) as (Element of C130) by L783 , L782;
L784: ( 0 ) in ( NAT );
reconsider D40 = ( 0 ) as (Element of C130) by L784 , L782;
reconsider D41 = ( ( ( C132 -' ( len C131 ) ) -' 1 ) --> D40 ) as (XFinSequence of C130);
L785: ( <% D39 %> ^ ( FS2XFS C131 ) ) <> ( {} ) by L255;
reconsider D42 = ( ( <% D39 %> ^ ( FS2XFS C131 ) ) ^ D41 ) as non  empty (XFinSequence of C130) by L785 , L255;
L786: ( 0 ) in ( dom <% D39 %> ) by NAT_1:44;
L787: ( len <% D39 %> ) = 1 by L268;
L788: ( 0 ) in ( ( len <% D39 %> ) + ( len ( FS2XFS C131 ) ) ) by NAT_1:44;
L789: ( 0 ) in ( len ( <% D39 %> ^ ( FS2XFS C131 ) ) ) by L788 , L110;
L790: ( D42 . ( 0 ) ) = ( ( <% D39 %> ^ ( FS2XFS C131 ) ) . ( 0 ) ) by L789 , L110
.= ( <% D39 %> . ( 0 ) ) by L786 , L110
.= D39 by L268;
L791: (for R18 being Nat holds ((1 <= R18 & R18 <= ( len C131 )) implies ( D42 . R18 ) = ( C131 . R18 )))
proof
let R18 being Nat;
assume that
L792: 1 <= R18
and
L793: R18 <= ( len C131 );
L794: ( R18 - 1 ) >= ( 0 ) by L792 , XREAL_1:48;
L795: ( R18 -' 1 ) = ( R18 - 1 ) by L794 , XREAL_0:def 2;
L796: R18 < ( R18 + 1 ) by NAT_1:13;
L797: ( R18 - 1 ) < ( ( R18 + 1 ) - 1 ) by L796 , XREAL_1:9;
L798: ( R18 -' 1 ) < ( len C131 ) by L797 , L793 , L795 , XXREAL_0:2;
L799: ( R18 -' 1 ) in ( len C131 ) by L798 , NAT_1:44;
L800: ( R18 -' 1 ) in ( len ( FS2XFS C131 ) ) by L799 , L727;
L801: R18 < ( 1 + ( len C131 ) ) by L793 , NAT_1:13;
L802: R18 < ( ( len <% D39 %> ) + ( len ( FS2XFS C131 ) ) ) by L801 , L787 , L727;
L803: R18 in ( ( len <% D39 %> ) + ( len ( FS2XFS C131 ) ) ) by L802 , NAT_1:44;
L804: R18 in ( len ( <% D39 %> ^ ( FS2XFS C131 ) ) ) by L803 , L110;
L805: ( D42 . R18 ) = ( ( <% D39 %> ^ ( FS2XFS C131 ) ) . ( 1 + ( R18 -' 1 ) ) ) by L804 , L795 , L110
.= ( ( FS2XFS C131 ) . ( R18 -' 1 ) ) by L787 , L800 , L110
.= ( C131 . ( ( R18 -' 1 ) + 1 ) ) by L798 , L727
.= ( C131 . R18 ) by L795;
thus L806: thesis by L805;
end;
L807: ( C132 - ( len C131 ) ) > ( 0 ) by L781 , XREAL_1:50;
L808: ( C132 -' ( len C131 ) ) = ( C132 - ( len C131 ) ) by L807 , XREAL_0:def 2;
L809: ( C132 -' ( len C131 ) ) >= ( ( 0 ) + 1 ) by L808 , L807 , NAT_1:13;
L810: ( ( C132 -' ( len C131 ) ) - 1 ) >= ( 0 ) by L809 , XREAL_1:48;
L811: ( len D41 ) = ( ( C132 -' ( len C131 ) ) -' 1 ) by FUNCOP_1:13;
L812: (for B109 being Nat holds ((( len C131 ) < B109 & B109 < C132) implies ( D42 . B109 ) = ( 0 )))
proof
let C133 being Nat;
assume that
L813: ( len C131 ) < C133
and
L814: C133 < C132;
L815: ( len ( <% D39 %> ^ ( FS2XFS C131 ) ) ) = ( ( len <% D39 %> ) + ( len ( FS2XFS C131 ) ) ) by L110
.= ( 1 + ( len C131 ) ) by L787 , L727;
L816: ( len C131 ) < C132 by L813 , L814 , XXREAL_0:2;
L817: ( C132 - ( len C131 ) ) > ( 0 ) by L816 , XREAL_1:50;
L818: ( C132 -' ( len C131 ) ) = ( C132 - ( len C131 ) ) by L817 , XREAL_0:def 2;
L819: ( C132 - ( len C131 ) ) >= ( ( 0 ) + 1 ) by L818 , L817 , NAT_1:13;
L820: ( ( C132 -' ( len C131 ) ) - 1 ) >= ( 0 ) by L819 , L818 , XREAL_1:48;
L821: ( ( C132 -' ( len C131 ) ) -' 1 ) = ( C132 - ( ( len C131 ) + 1 ) ) by L820 , L818 , XREAL_0:def 2;
L822: ( 1 + ( len C131 ) ) <= C133 by L813 , NAT_1:13;
L823: ( C133 - ( 1 + ( len C131 ) ) ) >= ( 0 ) by L822 , XREAL_1:48;
L824: ( C133 -' ( 1 + ( len C131 ) ) ) = ( C133 - ( 1 + ( len C131 ) ) ) by L823 , XREAL_0:def 2;
L825: ( C133 - ( ( len C131 ) + 1 ) ) < ( C132 - ( ( len C131 ) + 1 ) ) by L814 , XREAL_1:9;
L826: ( C133 -' ( len ( <% D39 %> ^ ( FS2XFS C131 ) ) ) ) in ( ( C132 -' ( len C131 ) ) -' 1 ) by L825 , L815 , L824 , L821 , NAT_1:44;
L827: C133 = ( ( len ( <% D39 %> ^ ( FS2XFS C131 ) ) ) + ( C133 -' ( len ( <% D39 %> ^ ( FS2XFS C131 ) ) ) ) ) by L815 , L824;
L828: ( D42 . C133 ) = ( D41 . ( C133 -' ( len ( <% D39 %> ^ ( FS2XFS C131 ) ) ) ) ) by L827 , L811 , L826 , L110
.= ( 0 ) by L826 , FUNCOP_1:7;
thus L829: thesis by L828;
end;
L830: ( len D42 ) = ( ( len ( <% D39 %> ^ ( FS2XFS C131 ) ) ) + ( len D41 ) ) by L110
.= ( ( ( len <% D39 %> ) + ( len ( FS2XFS C131 ) ) ) + ( len D41 ) ) by L110
.= ( ( 1 + ( len ( FS2XFS C131 ) ) ) + ( len D41 ) ) by L306
.= ( ( 1 + ( len C131 ) ) + ( len D41 ) ) by L727
.= ( ( 1 + ( len C131 ) ) + ( ( C132 -' ( len C131 ) ) -' 1 ) ) by FUNCOP_1:13
.= ( ( C132 - ( ( len C131 ) + 1 ) ) + ( ( len C131 ) + 1 ) ) by L808 , L810 , XREAL_0:def 2
.= C132;
thus L831: thesis by L830 , L790 , L791 , L812;
end;
uniqueness
proof
let C134 , C135 being non  empty (XFinSequence of C130);
assume that
L832: ( len C131 ) = ( C134 . ( 0 ) )
and
L833: ( len C134 ) = C132
and
L834: (for R18 being Nat holds ((1 <= R18 & R18 <= ( len C131 )) implies ( C134 . R18 ) = ( C131 . R18 )))
and
L835: (for B110 being Nat holds ((( len C131 ) < B110 & B110 < C132) implies ( C134 . B110 ) = ( 0 )))
and
L836: ( len C131 ) = ( C135 . ( 0 ) )
and
L837: ( len C135 ) = C132
and
L838: (for R18 being Nat holds ((1 <= R18 & R18 <= ( len C131 )) implies ( C135 . R18 ) = ( C131 . R18 )))
and
L839: (for B111 being Nat holds ((( len C131 ) < B111 & B111 < C132) implies ( C135 . B111 ) = ( 0 )));
L840: (for B112 being Nat holds (B112 < C132 implies ( C134 . B112 ) = ( C135 . B112 )))
proof
let C136 being Nat;
assume L841: C136 < C132;
L842: (C136 < ( ( 0 ) + 1 ) or (1 <= C136 & C136 <= ( len C131 )) or (( len C131 ) < C136 & C136 < C132)) by L841;
L843:
now
per cases  by L842 , NAT_1:13;
case L844: C136 = ( 0 );
thus L845: thesis by L844 , L832 , L836;
end;
case L846: (1 <= C136 & C136 <= ( len C131 ));
L847: ( C134 . C136 ) = ( C131 . C136 ) by L846 , L834;
thus L848: thesis by L847 , L838 , L846;
end;
case L849: (( len C131 ) < C136 & C136 < C132);
L850: ( C134 . C136 ) = ( 0 ) by L849 , L835;
thus L851: thesis by L850 , L839 , L849;
end;
end;
thus L853: thesis by L843;
end;
thus L854: thesis by L840 , L833 , L837 , L67;
end;
end;
definition
let C137 being non  empty set;
let C138 being (XFinSequence of C137);
assume that
L856: ( C138 . ( 0 ) ) is Nat
and
L857: ( C138 . ( 0 ) ) in ( len C138 );
func XFS2FS* C138 -> (FinSequence of C137) means 
:L858: (for B113 being Nat holds (B113 = ( C138 . ( 0 ) ) implies (( len it ) = B113 & (for R18 being Nat holds ((1 <= R18 & R18 <= B113) implies ( it . R18 ) = ( C138 . R18 ))))));
existence
proof
reconsider D43 = ( C138 . ( 0 ) ) as (Element of ( NAT )) by L856 , ORDINAL1:def 12;
deffunc H4(set) = ( C138 . $1 );
L859: (ex B114 being FinSequence st (( len B114 ) = D43 & (for B115 being Nat holds (B115 in ( dom B114 ) implies ( B114 . B115 ) = H4(B115))))) from FINSEQ_1:sch 2;
consider C139 being FinSequence such that L860: ( len C139 ) = D43 and L861: (for B116 being Nat holds (B116 in ( dom C139 ) implies ( C139 . B116 ) = H4(B116))) by L859;
L862: ( rng C139 ) c= C137
proof
L863: D43 < ( len C138 ) by L857 , NAT_1:44;
let C140 being set;
assume L864: C140 in ( rng C139 );
consider C141 being set such that L865: C141 in ( dom C139 ) and L866: C140 = ( C139 . C141 ) by L864 , FUNCT_1:def 3;
reconsider D44 = C141 as (Element of ( NAT )) by L865;
L867: D44 in ( Seg D43 ) by L860 , L865 , FINSEQ_1:def 3;
L868: D44 <= D43 by L867 , FINSEQ_1:1;
L869: D44 < ( len C138 ) by L868 , L863 , XXREAL_0:2;
L870: D44 in ( dom C138 ) by L869 , NAT_1:44;
L871: C140 = ( C138 . D44 ) by L861 , L865 , L866;
L872: (( rng C138 ) c= C137 & C140 in ( rng C138 )) by L871 , L870 , FUNCT_1:def 3 , RELAT_1:def 19;
thus L873: thesis by L872;
end;
reconsider D45 = C139 as (FinSequence of C137) by L862 , FINSEQ_1:def 4;
L874: ( dom C139 ) = ( Seg D43 ) by L860 , FINSEQ_1:def 3;
L875: (for B117 being Nat holds (B117 = ( C138 . ( 0 ) ) implies (( len D45 ) = B117 & (for R18 being Nat holds ((1 <= R18 & R18 <= B117) implies ( D45 . R18 ) = ( C138 . R18 ))))))
proof
let C142 being Nat;
L876: (for R18 being Nat holds ((1 <= R18 & R18 <= D43) implies ( D45 . R18 ) = ( C138 . R18 )))
proof
let R18 being Nat;
assume L877: (1 <= R18 & R18 <= D43);
L878: R18 in ( Seg D43 ) by L877 , FINSEQ_1:1;
thus L879: thesis by L878 , L861 , L874;
end;
assume L880: C142 = ( C138 . ( 0 ) );
thus L881: thesis by L880 , L860 , L876;
end;
thus L882: thesis by L875;
end;
uniqueness
proof
reconsider D46 = ( C138 . ( 0 ) ) as Nat by L856;
let C143 , C144 being (FinSequence of C137);
assume that
L883: (for R19 being Nat holds (R19 = ( C138 . ( 0 ) ) implies (( len C143 ) = R19 & (for R18 being Nat holds ((1 <= R18 & R18 <= R19) implies ( C143 . R18 ) = ( C138 . R18 ))))))
and
L884: (for R19 being Nat holds (R19 = ( C138 . ( 0 ) ) implies (( len C144 ) = R19 & (for R18 being Nat holds ((1 <= R18 & R18 <= R19) implies ( C144 . R18 ) = ( C138 . R18 ))))));
L885: ( len C143 ) = D46 by L883;
L886: (for B118 being Nat holds ((1 <= B118 & B118 <= ( len C143 )) implies ( C143 . B118 ) = ( C144 . B118 )))
proof
let C145 being Nat;
assume L887: (1 <= C145 & C145 <= ( len C143 ));
L888: ( C143 . C145 ) = ( C138 . C145 ) by L887 , L883 , L885;
thus L889: thesis by L888 , L884 , L885 , L887;
end;
L890: ( len C144 ) = D46 by L884;
thus L891: thesis by L890 , L883 , L886 , FINSEQ_1:14;
end;
end;
theorem
L893: (for R20 being non  empty set holds (for B119 being (XFinSequence of R20) holds ((( B119 . ( 0 ) ) = ( 0 ) & ( 0 ) < ( len B119 )) implies ( XFS2FS* B119 ) = ( {} ))))
proof
let R20 being non  empty set;
let C146 being (XFinSequence of R20);
assume that
L894: ( C146 . ( 0 ) ) = ( 0 )
and
L895: ( 0 ) < ( len C146 );
set D47 = ( XFS2FS* C146 );
L896: ( 0 ) in ( len C146 ) by L895 , NAT_1:44;
L897: ( len D47 ) = ( 0 ) by L896 , L894 , L858;
thus L898: thesis by L897;
end;
definition
let C147 being Function;
attr C147 is  initial
means
:L899: (for B120 , B121 being Nat holds ((B121 in ( dom C147 ) & B120 < B121) implies B120 in ( dom C147 )));
end;
registration
cluster  empty ->  initial for Function;
coherence
proof
let C148 being Function;
assume that
L901: C148 is  empty;
let C149 being Nat;
thus L902: thesis by L901;
end;
end;
registration
cluster  ->  initial for XFinSequence;
coherence
proof
let C150 being XFinSequence;
let C151 , C152 being Nat;
assume that
L904: C152 in ( dom C150 );
assume L905: C151 < C152;
L906: C151 in C152 by L905 , NAT_1:44;
thus L907: C151 in ( dom C150 ) by L906 , L904 , ORDINAL1:10;
end;
end;
registration
cluster  -> ( NAT ) -defined for XFinSequence;
coherence
proof
let C153 being XFinSequence;
thus L909: ( dom C153 ) c= ( NAT );
end;
end;
theorem
L911: (for B122 being non  empty  initial ( NAT ) -defined Function holds ( 0 ) in ( dom B122 ))
proof
let C154 being non  empty  initial ( NAT ) -defined Function;
consider R3 being set such that L912: R3 in ( dom C154 ) by XBOOLE_0:def 1;
L913: ( dom C154 ) c= ( NAT ) by RELAT_1:def 18;
reconsider D48 = R3 as (Element of ( NAT )) by L913 , L912;
L914: (D48 = ( 0 ) or ( 0 ) < D48);
thus L915: ( 0 ) in ( dom C154 ) by L914 , L912 , L899;
end;
registration
cluster  initial  finite ( NAT ) -defined ->  T-Sequence-like for Function;
coherence
proof
let C155 being Function;
assume L916: C155 is  initial  finite ( NAT ) -defined;
L917: ( dom C155 ) c= ( NAT ) by L916 , RELAT_1:def 18;
thus L918: ( dom C155 ) is  epsilon-transitive
proof
let R3 being set;
assume L919: R3 in ( dom C155 );
reconsider D49 = R3 as Nat by L919 , L916;
let R4 being set;
assume L920: R4 in R3;
reconsider D50 = R4 as Nat by L920 , L919 , L917;
L921: D50 < D49 by L920 , NAT_1:44;
thus L922: R4 in ( dom C155 ) by L921 , L916 , L919 , L899;
end;

let R3 being set;
let R4 being set;
assume L923: (R3 in ( dom C155 ) & R4 in ( dom C155 ));
reconsider D51 = R3 , D52 = R4 as Ordinal by L923 , L916;
L924: (D51 in D52 or D51 = D52 or D52 in D51) by ORDINAL1:14;
thus L925: thesis by L924;
end;
end;
theorem
L927: (for B123 being  finite  initial ( NAT ) -defined Function holds (for B124 being Nat holds (B124 in ( dom B123 ) iff B124 < ( card B123 )))) by NAT_1:44;
theorem
L928: (for B125 being  initial ( NAT ) -defined Function holds (for B126 being ( NAT ) -defined Function holds (( dom B125 ) = ( dom B126 ) implies B126 is  initial)))
proof
let C156 being  initial ( NAT ) -defined Function;
let C157 being ( NAT ) -defined Function;
assume L929: ( dom C156 ) = ( dom C157 );
thus L930: (for B127 , B128 being Nat holds ((B128 in ( dom C157 ) & B127 < B128) implies B127 in ( dom C157 ))) by L929 , L899;
end;
theorem
L931: (for B129 being  initial ( NAT ) -defined  finite Function holds ( dom B129 ) = { B130 where B130 is (Element of ( NAT )) : B130 < ( card B129 ) })
proof
let C158 being  initial ( NAT ) -defined  finite Function;
thus L932:now
let C159 being set;
assume L933: C159 in ( dom C158 );
reconsider D53 = C159 as (Element of ( NAT )) by L933;
L934: D53 < ( card C158 ) by L933 , NAT_1:44;
thus L935: C159 in { B131 where B131 is (Element of ( NAT )) : B131 < ( card C158 ) } by L934;
end;
let C160 being set;
assume L936: C160 in { B132 where B132 is (Element of ( NAT )) : B132 < ( card C158 ) };
L937: (ex B133 being (Element of ( NAT )) st (C160 = B133 & B133 < ( card C158 ))) by L936;
thus L938: thesis by L937 , NAT_1:44;
end;
theorem
L939: (for B134 being  initial non  empty ( NAT ) -defined  finite Function holds (for B135 being non  empty ( NAT ) -defined  finite Function holds ((B134 c= B135 & ( LastLoc B134 ) = ( LastLoc B135 )) implies B134 = B135)))
proof
let C161 being  initial non  empty ( NAT ) -defined  finite Function;
let C162 being non  empty ( NAT ) -defined  finite Function;
assume that
L940: C161 c= C162
and
L941: ( LastLoc C161 ) = ( LastLoc C162 );
L942: ( dom C161 ) = ( dom C162 )
proof
thus L943: ( dom C161 ) c= ( dom C162 ) by L940 , GRFUNC_1:2;
let C163 being set;
assume L944: C163 in ( dom C162 );
L945: ( dom C162 ) c= ( NAT ) by RELAT_1:def 18;
reconsider D54 = C163 as (Element of ( NAT )) by L945 , L944;
L946: ( LastLoc C161 ) in ( dom C161 ) by VALUED_1:30;
L947: D54 <= ( LastLoc C161 ) by L941 , L944 , VALUED_1:32;
L948: (D54 < ( LastLoc C161 ) or D54 = ( LastLoc C161 )) by L947 , XXREAL_0:1;
thus L949: thesis by L948 , L946 , L899;
end;
thus L950: thesis by L942 , L940 , GRFUNC_1:3;
end;
theorem
L951: (for B136 being  initial non  empty ( NAT ) -defined  finite Function holds ( LastLoc B136 ) = ( ( card B136 ) -' 1 ))
proof
let C164 being  initial non  empty ( NAT ) -defined  finite Function;
consider C165 being Nat such that L952: ( LastLoc C164 ) = C165;
reconsider D55 = C165 as (Element of ( NAT )) by ORDINAL1:def 12;
L953: ( LastLoc C164 ) in ( dom C164 ) by VALUED_1:30;
L954: D55 < ( card C164 ) by L953 , L952 , NAT_1:44;
L955: D55 <= ( ( card C164 ) -' 1 ) by L954 , NAT_D:49;
per cases  by L955 , XXREAL_0:1;
suppose L956: D55 < ( ( card C164 ) -' 1 );

L957: ( D55 + 1 ) < ( ( ( card C164 ) -' 1 ) + 1 ) by L956 , XREAL_1:6;
L958: ( D55 + 1 ) < ( card C164 ) by L957 , NAT_1:14 , XREAL_1:235;
L959: ( D55 + 1 ) in ( dom C164 ) by L958 , NAT_1:44;
L960: ( D55 + 1 ) <= D55 by L959 , L952 , VALUED_1:32;
L961: D55 <= ( D55 + 1 ) by NAT_1:11;
L962: ( D55 + ( 0 ) ) = ( D55 + 1 ) by L961 , L960 , XXREAL_0:1;
thus L963: thesis by L962;
end;
suppose L964: D55 = ( ( card C164 ) -' 1 );

thus L965: thesis by L964 , L952;
end;
end;
theorem
L967: (for B137 being  initial non  empty ( NAT ) -defined  finite Function holds ( FirstLoc B137 ) = ( 0 )) by L911 , VALUED_1:35;
registration
let C166 being  initial non  empty ( NAT ) -defined  finite Function;
cluster ( CutLastLoc C166 ) ->  initial;
coherence
proof
set D56 = ( CutLastLoc C166 );
per cases ;
suppose L968: D56 is  empty;

reconsider D57 = D56 as  empty  finite Function by L968;
L969: D57 is  initial;
thus L970: thesis by L969;
end;
suppose L971: D56 is non  empty;

reconsider D58 = D56 as non  empty  finite Function by L971;
L972: D58 is  initial
proof
let C167 , C168 being Nat;
assume that
L973: C168 in ( dom D58 )
and
L974: C167 < C168;
set D59 = ( dom C166 );
reconsider D60 = { [ ( LastLoc C166 ) , ( C166 . ( LastLoc C166 ) ) ] } as Relation;
L975: D60 = ( ( LastLoc C166 ) .--> ( C166 . ( LastLoc C166 ) ) ) by FUNCT_4:82;
L976: ( dom D60 ) = { ( LastLoc C166 ) } by L975 , FUNCOP_1:13;
L977: ( ( dom C166 ) \ ( dom D60 ) ) = ( dom D58 ) by L976 , VALUED_1:36;
L978: C168 in ( dom C166 ) by L977 , L973 , XBOOLE_0:def 5;
L979: C167 in ( dom C166 ) by L978 , L974 , L899;
L980: C168 in D59 by L977 , L973 , XBOOLE_0:def 5;
L981: C167 <> ( LastLoc C166 ) by L980 , L974 , XXREAL_2:def 8;
L982: (not C167 in { ( LastLoc C166 ) }) by L981 , TARSKI:def 1;
thus L983: thesis by L982 , L976 , L977 , L979 , XBOOLE_0:def 5;
end;
thus L984: thesis by L972;
end;
end;
end;
theorem
L987: (for B138 being  finite  initial ( NAT ) -defined Function holds (for B139 being Function holds ( dom B138 ) misses ( dom ( Shift (B139 , ( card B138 )) ) )))
proof
let C169 being  finite  initial ( NAT ) -defined Function;
let C170 being Function;
assume L988: ( dom C169 ) meets ( dom ( Shift (C170 , ( card C169 )) ) );
L989: ( dom ( Shift (C170 , ( card C169 )) ) ) = { ( R21 + ( card C169 ) ) where R21 is (Element of ( NAT )) : R21 in ( dom C170 ) } by VALUED_1:def 12;
consider C171 being set such that L990: C171 in ( dom C169 ) and L991: C171 in { ( R21 + ( card C169 ) ) where R21 is (Element of ( NAT )) : R21 in ( dom C170 ) } by L989 , L988 , XBOOLE_0:3;
consider R21 being (Element of ( NAT )) such that L992: C171 = ( R21 + ( card C169 ) ) and L993: R21 in ( dom C170 ) by L991;
L994: ( R21 + ( card C169 ) ) < ( card C169 ) by L990 , L992 , NAT_1:44;
thus L995: contradiction by L994 , NAT_1:11;
end;
theorem
L996: (for R12 being XFinSequence holds (for R19 being Nat holds ((not R19 in ( dom R12 )) implies (not ( succ R19 ) in ( dom R12 )))))
proof
let R12 being XFinSequence;
let R19 being Nat;
assume L997: (not R19 in ( dom R12 ));
L998: R19 >= ( card R12 ) by L997 , NAT_1:44;
L999: ( R19 + 1 ) >= R19 by NAT_1:11;
L1000: ( R19 + 1 ) >= ( card R12 ) by L999 , L998 , XXREAL_0:2;
thus L1001: thesis by L1000 , NAT_1:44;
end;
registration
let C172 being set;
cluster ( C172 ^omega ) ->  functional;
coherence
proof
let C173 being set;
assume L1002: C173 in ( C172 ^omega );
thus L1003: C173 is Function by L1002 , L467;
end;
end;
registration
let C174 being set;
cluster  ->  finite  T-Sequence-like for (Element of ( C174 ^omega ));
coherence by L467;
end;
definition
let C175 being set;
let C176 being (XFinSequence of C175);
func Down C176 -> (Element of ( C175 ^omega )) equals 
C176;
coherence by L467;
end;
definition
let C177 being set;
let C178 being (XFinSequence of C177);
let C179 being (Element of ( C177 ^omega ));
redefine func C178 ^ C179 -> (Element of ( C177 ^omega ));

coherence
proof
reconsider D61 = C179 as (XFinSequence of C177) by L467;
L1007: ( C178 ^ D61 ) is (XFinSequence of C177);
thus L1008: thesis by L1007 , L467;
end;
end;
definition
let C180 being set;
let C181 , C182 being (Element of ( C180 ^omega ));
redefine func C181 ^ C182 -> (Element of ( C180 ^omega ));

coherence
proof
reconsider D62 = C181 , D63 = C182 as (XFinSequence of C180) by L467;
L1010: ( D62 ^ D63 ) is (XFinSequence of C180);
thus L1011: thesis by L1010 , L467;
end;
end;
theorem
L1013: (for R12 being XFinSequence holds (for R13 being XFinSequence holds R12 c= ( R12 ^ R13 )))
proof
let R12 being XFinSequence;
let R13 being XFinSequence;
L1014: ( dom R12 ) c= ( dom ( R12 ^ R13 ) ) by L155;
L1015: (for R3 being set holds (R3 in ( dom R12 ) implies ( ( R12 ^ R13 ) . R3 ) = ( R12 . R3 ))) by L110;
thus L1016: thesis by L1015 , L1014 , GRFUNC_1:2;
end;
theorem
L1017: (for R3 being set holds (for R12 being XFinSequence holds ( len ( R12 ^ <% R3 %> ) ) = ( ( len R12 ) + 1 )))
proof
let R3 being set;
let R12 being XFinSequence;
thus L1018: ( len ( R12 ^ <% R3 %> ) ) = ( ( len R12 ) + ( len <% R3 %> ) ) by L110
.= ( ( len R12 ) + 1 ) by L306;
end;
theorem
L1019: (for R3 being set holds (for R4 being set holds <% R3 , R4 %> = ( (( 0 ) , 1) --> (R3 , R4) )))
proof
let R3 being set;
let R4 being set;
L1020: ( dom <% R3 , R4 %> ) = ( len <% R3 , R4 %> )
.= { ( 0 ) , 1 } by L331 , CARD_1:50;
L1021: ( <% R3 , R4 %> . ( 0 ) ) = R3 by L331;
L1022: ( <% R3 , R4 %> . 1 ) = R4 by L331;
thus L1023: <% R3 , R4 %> = ( (( 0 ) , 1) --> (R3 , R4) ) by L1022 , L1020 , L1021 , FUNCT_4:66;
end;
theorem
L1024: (for R12 being XFinSequence holds (for R13 being XFinSequence holds ( R12 ^ R13 ) = ( R12 +* ( Shift (R13 , ( card R12 )) ) )))
proof
let R12 being XFinSequence;
let R13 being XFinSequence;
L1025: ( dom ( Shift (R13 , ( card R12 )) ) ) = { ( R22 + ( card R12 ) ) where R22 is (Element of ( NAT )) : R22 in ( dom R13 ) } by VALUED_1:def 12;
L1026: (for R3 being set holds (R3 in ( dom ( R12 ^ R13 ) ) iff (R3 in ( dom R12 ) or R3 in ( dom ( Shift (R13 , ( card R12 )) ) ))))
proof
let R3 being set;
thus L1027: (R3 in ( dom ( R12 ^ R13 ) ) implies (R3 in ( dom R12 ) or R3 in ( dom ( Shift (R13 , ( card R12 )) ) )))
proof
assume L1028: R3 in ( dom ( R12 ^ R13 ) );
reconsider D64 = R3 as Nat by L1028;
per cases  by L1028 , L144;
suppose L1029: D64 in ( dom R12 );

thus L1030: (R3 in ( dom R12 ) or R3 in ( dom ( Shift (R13 , ( card R12 )) ) )) by L1029;
end;
suppose L1031: (ex R2 being Nat st (R2 in ( dom R13 ) & D64 = ( ( len R12 ) + R2 )));

thus L1032: (R3 in ( dom R12 ) or R3 in ( dom ( Shift (R13 , ( card R12 )) ) )) by L1031 , L1025;
end;
end;

assume L1034: (R3 in ( dom R12 ) or R3 in ( dom ( Shift (R13 , ( card R12 )) ) ));
per cases  by L1034;
suppose L1035: R3 in ( dom R12 );

L1036: ( dom R12 ) c= ( dom ( R12 ^ R13 ) ) by L155;
thus L1037: R3 in ( dom ( R12 ^ R13 ) ) by L1036 , L1035;
end;
suppose L1038: R3 in ( dom ( Shift (R13 , ( card R12 )) ) );

L1039: (ex R22 being (Element of ( NAT )) st (R3 = ( R22 + ( card R12 ) ) & R22 in ( dom R13 ))) by L1038 , L1025;
thus L1040: R3 in ( dom ( R12 ^ R13 ) ) by L1039 , L164;
end;
end;
L1042: ( dom ( R12 ^ R13 ) ) = ( ( dom R12 ) \/ ( dom ( Shift (R13 , ( card R12 )) ) ) ) by L1026 , XBOOLE_0:def 3;
L1043: (for R3 being set holds (R3 in ( ( dom R12 ) \/ ( dom ( Shift (R13 , ( card R12 )) ) ) ) implies ((R3 in ( dom ( Shift (R13 , ( card R12 )) ) ) implies ( ( R12 ^ R13 ) . R3 ) = ( ( Shift (R13 , ( card R12 )) ) . R3 )) & ((not R3 in ( dom ( Shift (R13 , ( card R12 )) ) )) implies ( ( R12 ^ R13 ) . R3 ) = ( R12 . R3 )))))
proof
let R3 being set;
assume that
L1044: R3 in ( ( dom R12 ) \/ ( dom ( Shift (R13 , ( card R12 )) ) ) );
thus L1045:now
assume L1046: R3 in ( dom ( Shift (R13 , ( card R12 )) ) );
reconsider D65 = R3 as Nat by L1046;
consider R22 being (Element of ( NAT )) such that L1047: R3 = ( R22 + ( card R12 ) ) and L1048: R22 in ( dom R13 ) by L1046 , L1025;
set D66 = ( D65 -' ( len R12 ) );
L1049: ( ( len R12 ) + D66 ) = D65 by L1047 , NAT_D:34;
thus L1050: ( ( R12 ^ R13 ) . R3 ) = ( R13 . D66 ) by L1049 , L1047 , L1048 , L110
.= ( ( Shift (R13 , ( card R12 )) ) . R3 ) by L1047 , L1048 , L1049 , VALUED_1:def 12;
end;
assume L1051: (not R3 in ( dom ( Shift (R13 , ( card R12 )) ) ));
L1052: R3 in ( dom R12 ) by L1051 , L1044 , XBOOLE_0:def 3;
thus L1053: ( ( R12 ^ R13 ) . R3 ) = ( R12 . R3 ) by L1052 , L110;
end;
thus L1054: ( R12 ^ R13 ) = ( R12 +* ( Shift (R13 , ( card R12 )) ) ) by L1043 , L1042 , FUNCT_4:def 1;
end;
theorem
L1055: (for R12 being XFinSequence holds (for R13 being XFinSequence holds (( R12 +* ( R12 ^ R13 ) ) = ( R12 ^ R13 ) & ( ( R12 ^ R13 ) +* R12 ) = ( R12 ^ R13 ))))
proof
let R12 being XFinSequence;
let R13 being XFinSequence;
L1056: R12 c= ( R12 ^ R13 ) by L1013;
thus L1057: thesis by L1056 , FUNCT_4:97 , FUNCT_4:98;
end;
theorem
L1058: (for R24 being (Element of ( NAT )) holds (for B140 being  finite  initial ( NAT ) -defined Function holds (for B141 being Function holds ( dom ( Shift (B140 , R24) ) ) misses ( dom ( Shift (B141 , ( R24 + ( card B140 ) )) ) ))))
proof
let R24 being (Element of ( NAT ));
let C183 being  finite  initial ( NAT ) -defined Function;
let C184 being Function;
assume L1059: ( dom ( Shift (C183 , R24) ) ) meets ( dom ( Shift (C184 , ( R24 + ( card C183 ) )) ) );
L1060: ( dom ( Shift (C184 , ( R24 + ( card C183 ) )) ) ) = { ( R21 + ( R24 + ( card C183 ) ) ) where R21 is (Element of ( NAT )) : R21 in ( dom C184 ) } by VALUED_1:def 12;
consider C185 being set such that L1061: C185 in ( dom ( Shift (C183 , R24) ) ) and L1062: C185 in { ( R21 + ( R24 + ( card C183 ) ) ) where R21 is (Element of ( NAT )) : R21 in ( dom C184 ) } by L1060 , L1059 , XBOOLE_0:3;
L1063: ( dom ( Shift (C183 , R24) ) ) = { ( R23 + R24 ) where R23 is (Element of ( NAT )) : R23 in ( dom C183 ) } by VALUED_1:def 12;
consider R23 being (Element of ( NAT )) such that L1064: C185 = ( R23 + R24 ) and L1065: R23 in ( dom C183 ) by L1063 , L1061;
consider R21 being (Element of ( NAT )) such that L1066: C185 = ( R21 + ( R24 + ( card C183 ) ) ) and L1067: R21 in ( dom C184 ) by L1062;
L1068: R23 < ( card C183 ) by L1065 , NAT_1:44;
L1069: ( R21 + ( R24 + ( card C183 ) ) ) < ( R24 + ( card C183 ) ) by L1068 , L1064 , L1066 , XREAL_1:6;
thus L1070: contradiction by L1069 , NAT_1:11;
end;
theorem
L1071: (for R12 being XFinSequence holds (for R13 being XFinSequence holds (for R24 being (Element of ( NAT )) holds ( Shift (R12 , R24) ) c= ( Shift (( R12 ^ R13 ) , R24) ))))
proof
let R12 being XFinSequence;
let R13 being XFinSequence;
let R24 being (Element of ( NAT ));
L1072: ( R12 ^ R13 ) = ( R12 +* ( Shift (R13 , ( card R12 )) ) ) by L1024;
L1073: ( Shift (( R12 ^ R13 ) , R24) ) = ( ( Shift (R12 , R24) ) +* ( Shift (( Shift (R13 , ( card R12 )) ) , R24) ) ) by L1072 , VALUED_1:23;
L1074: ( Shift (( Shift (R13 , ( card R12 )) ) , R24) ) = ( Shift (R13 , ( R24 + ( card R12 ) )) ) by VALUED_1:21;
L1075: ( dom ( Shift (R12 , R24) ) ) misses ( dom ( Shift (( Shift (R13 , ( card R12 )) ) , R24) ) ) by L1074 , L1058;
thus L1076: ( Shift (R12 , R24) ) c= ( Shift (( R12 ^ R13 ) , R24) ) by L1075 , L1073 , FUNCT_4:32;
end;
theorem
L1077: (for R12 being XFinSequence holds (for R13 being XFinSequence holds (for R24 being (Element of ( NAT )) holds ( Shift (R13 , ( R24 + ( card R12 ) )) ) c= ( Shift (( R12 ^ R13 ) , R24) ))))
proof
let R12 being XFinSequence;
let R13 being XFinSequence;
let R24 being (Element of ( NAT ));
L1078: ( Shift (( Shift (R13 , ( card R12 )) ) , R24) ) = ( Shift (R13 , ( R24 + ( card R12 ) )) ) by VALUED_1:21;
L1079: ( R12 ^ R13 ) = ( R12 +* ( Shift (R13 , ( card R12 )) ) ) by L1024;
L1080: ( Shift (( R12 ^ R13 ) , R24) ) = ( ( Shift (R12 , R24) ) +* ( Shift (( Shift (R13 , ( card R12 )) ) , R24) ) ) by L1079 , VALUED_1:23;
thus L1081: thesis by L1080 , L1078 , FUNCT_4:25;
end;
theorem
L1082: (for R8 being set holds (for R12 being XFinSequence holds (for R13 being XFinSequence holds (for R24 being (Element of ( NAT )) holds (( Shift (( R12 ^ R13 ) , R24) ) c= R8 implies ( Shift (R12 , R24) ) c= R8)))))
proof
let R8 being set;
let R12 being XFinSequence;
let R13 being XFinSequence;
let R24 being (Element of ( NAT ));
assume L1083: ( Shift (( R12 ^ R13 ) , R24) ) c= R8;
L1084: ( Shift (R12 , R24) ) c= ( Shift (( R12 ^ R13 ) , R24) ) by L1071;
thus L1085: ( Shift (R12 , R24) ) c= R8 by L1084 , L1083 , XBOOLE_1:1;
end;
theorem
L1086: (for R8 being set holds (for R12 being XFinSequence holds (for R13 being XFinSequence holds (for R24 being (Element of ( NAT )) holds (( Shift (( R12 ^ R13 ) , R24) ) c= R8 implies ( Shift (R13 , ( R24 + ( card R12 ) )) ) c= R8)))))
proof
let R8 being set;
let R12 being XFinSequence;
let R13 being XFinSequence;
let R24 being (Element of ( NAT ));
assume L1087: ( Shift (( R12 ^ R13 ) , R24) ) c= R8;
L1088: ( Shift (R13 , ( R24 + ( card R12 ) )) ) c= ( Shift (( R12 ^ R13 ) , R24) ) by L1077;
thus L1089: thesis by L1088 , L1087 , XBOOLE_1:1;
end;
registration
let C186 being  initial non  empty ( NAT ) -defined  finite Function;
cluster ( CutLastLoc C186 ) ->  initial;
coherence;
end;
definition
let C187 , C188 , C189 , C190 being set;
func <%C187 , C188 , C189 , C190 %> -> set equals 
( ( ( <% C187 %> ^ <% C188 %> ) ^ <% C189 %> ) ^ <% C190 %> );
coherence;
end;
registration
let C191 , C192 , C193 , C194 being set;
cluster <% C191 , C192 , C193 , C194 %> ->  Function-like  Relation-like;
coherence;
end;
registration
let C195 , C196 , C197 , C198 being set;
cluster <% C195 , C196 , C197 , C198 %> ->  finite  T-Sequence-like;
coherence;
end;
theorem
L1094: (for R25 being set holds (for R26 being set holds (for R27 being set holds (for R28 being set holds ( len <% R25 , R26 , R27 , R28 %> ) = 4))))
proof
let R25 being set;
let R26 being set;
let R27 being set;
let R28 being set;
thus L1095: ( len <% R25 , R26 , R27 , R28 %> ) = ( ( len <% R25 , R26 , R27 %> ) + 1 ) by L1017
.= ( 3 + 1 ) by L354
.= 4;
end;
theorem
L1096: (for R25 being set holds (for R26 being set holds (for R27 being set holds (for R28 being set holds (( <% R25 , R26 , R27 , R28 %> . ( 0 ) ) = R25 & ( <% R25 , R26 , R27 , R28 %> . 1 ) = R26 & ( <% R25 , R26 , R27 , R28 %> . 2 ) = R27 & ( <% R25 , R26 , R27 , R28 %> . 3 ) = R28)))))
proof
let R25 being set;
let R26 being set;
let R27 being set;
let R28 being set;
thus L1097: ( <% R25 , R26 , R27 , R28 %> . ( 0 ) ) = ( ( ( <% R25 %> ^ <% R26 , R27 %> ) ^ <% R28 %> ) . ( 0 ) ) by L209
.= ( ( <% R25 %> ^ <% R26 , R27 , R28 %> ) . ( 0 ) ) by L209
.= R25 by L320;
L1098: ( len <% R25 , R26 , R27 %> ) = 3 by L354;
L1099: 1 in ( dom <% R25 , R26 , R27 %> ) by L1098 , NAT_1:44;
thus L1100: ( <% R25 , R26 , R27 , R28 %> . 1 ) = ( <% R25 , R26 , R27 %> . 1 ) by L1099 , L110
.= R26 by L354;
L1101: 2 in ( dom <% R25 , R26 , R27 %> ) by L1098 , NAT_1:44;
thus L1102: ( <% R25 , R26 , R27 , R28 %> . 2 ) = ( <% R25 , R26 , R27 %> . 2 ) by L1101 , L110
.= R27 by L354;
thus L1103: ( <% R25 , R26 , R27 , R28 %> . 3 ) = R28 by L1098 , L325;
end;
