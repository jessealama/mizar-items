:: Introduction to Turing Machines
::  by Jingchao Chen and Yatsuka Nakamura
::
:: Received July 27, 2001
:: Copyright (c) 2001-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, XBOOLE_0, FUNCT_1, PARTFUN1, FUNCT_4, RELAT_1,
      TARSKI, FUNCOP_1, ORDINAL1, XXREAL_0, FINSET_1, CARD_1, FINSEQ_1, NAT_1,
      CARD_3, ARYTM_3, QMAX_1, FSM_1, ZFMISC_1, ARYTM_1, FUNCT_2, LANG1, INT_1,
      MCART_1, CIRCUIT2, MSUALG_1, ORDINAL4, VALUED_2, FINSEQ_2, UNIALG_1,
      PRALG_3, TURING_1, RECDEF_2;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0,
      INT_1, FINSET_1, MCART_1, DOMAIN_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2,
      FUNCT_4, FUNCOP_1, GR_CY_1, FINSEQ_1, FINSEQ_2, FINSEQ_4, COMPUT_1,
      XXREAL_0, REAL_1, NAT_1, MARGREL1;
 constructors DOMAIN_1, REAL_1, BINOP_2, FINSEQ_4, FINSOP_1, GR_CY_1, COMPUT_1,
      RECDEF_1, RELSET_1, XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, ORDINAL1, RELSET_1, FUNCOP_1, FINSET_1,
      NUMBERS, XREAL_0, INT_1, COMPUT_1, FINSEQ_1, XTUPLE_0;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FINSEQ_1, GR_CY_1, COMPUT_1, FUNCOP_1, XTUPLE_0;
 theorems FUNCOP_1, FUNCT_4, ZFMISC_1, TARSKI, FUNCT_2, INT_1, MCART_1, NAT_1,
      RELSET_1, PARTFUN1, DOMAIN_1, CQC_THE1, ENUMSET1, FINSEQ_2, FINSEQ_1,
      FINSEQ_3, FUNCT_1, RELAT_1, FINSEQ_6, FINSEQ_7, COMPUT_1, FINSEQ_4,
      ORDINAL1, XBOOLE_0, XBOOLE_1, NUMBERS, XREAL_1, FUNCT_7, FINSOP_1,
      XXREAL_0, RVSUM_1, XTUPLE_0;
 schemes NAT_1, FUNCT_2, BINOP_2;

begin
definition
let C1 , C2 being non  empty set;
let C3 being (Function of C1 , C2);
let C4 being (PartFunc of C1 , C2);
redefine func C3 +* C4 -> (Function of C1 , C2);

coherence
proof
L1:
now
let C5 being set;
assume L2: C5 in C1;
per cases ;
suppose L3: C5 in ( dom C4 );

L4: ( ( C3 +* C4 ) . C5 ) = ( C4 . C5 ) by L3 , FUNCT_4:13;
thus L5: ( ( C3 +* C4 ) . C5 ) in C2 by L4 , L3 , PARTFUN1:4;
end;
suppose L6: (not C5 in ( dom C4 ));

L7: ( ( C3 +* C4 ) . C5 ) = ( C3 . C5 ) by L6 , FUNCT_4:11;
thus L8: ( ( C3 +* C4 ) . C5 ) in C2 by L7 , L2 , FUNCT_2:5;
end;
end;
L10: (( dom C3 ) = C1 & ( dom C4 ) c= C1) by FUNCT_2:def 1 , RELAT_1:def 18;
L11: ( dom ( C3 +* C4 ) ) = ( ( dom C3 ) \/ ( dom C4 ) ) by FUNCT_4:def 1
.= C1 by L10 , XBOOLE_1:12;
thus L12: thesis by L11 , L1 , FUNCT_2:3;
end;
end;
definition
let C6 , C7 being non  empty set;
let C8 being (Element of C6);
let C9 being (Element of C7);
redefine func C8 .--> C9 -> (PartFunc of C6 , C7);

coherence
proof
set D1 = ( C8 .--> C9 );
L14: (( dom D1 ) = { C8 } & ( rng D1 ) = { C9 }) by FUNCOP_1:8 , FUNCOP_1:13;
thus L15: thesis by L14 , RELSET_1:7;
end;
end;
notation
let C10 being Nat;
synonym SegM C10 for succ C10;
end;
definition
let C11 being Nat;
redefine func SegM C11 -> (Subset of ( NAT )) equals 
{ R4 where R4 is (Element of ( NAT )) : R4 <= C11 };
coherence
proof
L18: ( SegM C11 ) in ( NAT ) by ORDINAL1:def 12;
L19: ( SegM C11 ) c= ( NAT ) by L18 , ORDINAL1:5;
thus L20: thesis by L19;
end;
compatibility by NAT_1:54;
end;
registration
let C12 being Nat;
cluster ( SegM C12 ) ->  finite non  empty;
coherence
proof
L22: C12 is (Element of ( NAT )) by ORDINAL1:def 12;
thus L23: ( SegM C12 ) is  finite by L22 , CQC_THE1:2;
thus L24: thesis;
end;
end;
theorem
L26: (for R1 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds (R4 in ( SegM R1 ) iff R4 <= R1)))
proof
let R1 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
thus L27: (R4 in ( SegM R1 ) implies R4 <= R1)
proof
assume L28: R4 in ( SegM R1 );
L29: (ex R2 being (Element of ( NAT )) st (R4 = R2 & R2 <= R1)) by L28;
thus L30: thesis by L29;
end;

thus L31: thesis;
end;
theorem
L32: (for B1 being Function holds (for B2 , B3 , B4 , B5 , B6 being set holds (B5 <> B2 implies ( ( B1 +* ( [ B2 , B3 ] .--> B4 ) ) . [ B5 , B6 ] ) = ( B1 . [ B5 , B6 ] ))))
proof
let C13 being Function;
let C14 , C15 , C16 , C17 , C18 being set;
set D2 = ( [ C14 , C15 ] .--> C16 );
assume L33: C17 <> C14;
L34: [ C17 , C18 ] <> [ C14 , C15 ] by L33 , XTUPLE_0:1;
L35: ( dom D2 ) = { [ C14 , C15 ] } by FUNCOP_1:13;
L36: (not [ C17 , C18 ] in ( dom D2 )) by L35 , L34 , TARSKI:def 1;
thus L37: thesis by L36 , FUNCT_4:11;
end;
theorem
L38: (for B7 being Function holds (for B8 , B9 , B10 , B11 , B12 being set holds (B12 <> B9 implies ( ( B7 +* ( [ B8 , B9 ] .--> B10 ) ) . [ B11 , B12 ] ) = ( B7 . [ B11 , B12 ] ))))
proof
let C19 being Function;
let C20 , C21 , C22 , C23 , C24 being set;
set D3 = ( [ C20 , C21 ] .--> C22 );
assume L39: C24 <> C21;
L40: [ C23 , C24 ] <> [ C20 , C21 ] by L39 , XTUPLE_0:1;
L41: ( dom D3 ) = { [ C20 , C21 ] } by FUNCOP_1:13;
L42: (not [ C23 , C24 ] in ( dom D3 )) by L41 , L40 , TARSKI:def 1;
thus L43: thesis by L42 , FUNCT_4:11;
end;
notation
let C25 being Nat;
let C26 being FinSequence;
synonym Prefix (C26 , C25) for C26 | C25;
end;
definition
let C27 being (Element of ( NAT ));
let C28 being (FinSequence of ( NAT ));
redefine func Prefix (C28 , C27) -> (FinSequence of ( INT ));

coherence
proof
set D4 = ( C28 | ( Seg C27 ) );
L45:
now
let C29 being Nat;
assume L46: C29 in ( dom D4 );
L47: C29 in ( dom C28 ) by L46 , RELAT_1:57;
L48: ( C28 . C29 ) in ( NAT ) by L47 , FINSEQ_2:11;
L49: ( D4 . C29 ) = ( C28 . C29 ) by L46 , FUNCT_1:47;
thus L50: ( D4 . C29 ) in ( INT ) by L49 , L48 , NUMBERS:17;
end;
thus L51: thesis by L45 , FINSEQ_2:12;
end;
end;
theorem
L53: (for B13 , B14 being (Element of ( NAT )) holds (( Sum ( Prefix (<* B13 , B14 *> , 1) ) ) = B13 & ( Sum ( Prefix (<* B13 , B14 *> , 2) ) ) = ( B13 + B14 )))
proof
let C30 , C31 being (Element of ( NAT ));
reconsider D5 = C30 as (Element of ( INT )) by INT_1:def 2;
thus L54: ( Sum ( Prefix (<* C30 , C31 *> , 1) ) ) = ( Sum <* D5 *> ) by FINSEQ_6:3
.= C30 by FINSOP_1:11;
reconsider D6 = C31 as (Element of ( INT )) by INT_1:def 2;
L55: ( len <* C30 , C31 *> ) = 2 by FINSEQ_1:44;
thus L56: ( Sum ( Prefix (<* C30 , C31 *> , 2) ) ) = ( Sum <* D5 , D6 *> ) by L55 , FINSEQ_3:49
.= ( C30 + C31 ) by RVSUM_1:77;
end;
theorem
L57: (for B15 , B16 , B17 being (Element of ( NAT )) holds (( Sum ( Prefix (<* B15 , B16 , B17 *> , 1) ) ) = B15 & ( Sum ( Prefix (<* B15 , B16 , B17 *> , 2) ) ) = ( B15 + B16 ) & ( Sum ( Prefix (<* B15 , B16 , B17 *> , 3) ) ) = ( ( B15 + B16 ) + B17 )))
proof
let C32 , C33 , C34 being (Element of ( NAT ));
reconsider D7 = C32 as (Element of ( INT )) by INT_1:def 2;
thus L58: ( Sum ( Prefix (<* C32 , C33 , C34 *> , 1) ) ) = ( Sum <* D7 *> ) by FINSEQ_6:4
.= C32 by FINSOP_1:11;
reconsider D8 = C33 as (Element of ( INT )) by INT_1:def 2;
thus L59: ( Sum ( Prefix (<* C32 , C33 , C34 *> , 2) ) ) = ( Sum <* D7 , D8 *> ) by FINSEQ_6:5
.= ( C32 + C33 ) by RVSUM_1:77;
reconsider D9 = C34 as (Element of ( INT )) by INT_1:def 2;
L60: ( len <* C32 , C33 , C34 *> ) = 3 by FINSEQ_1:45;
thus L61: ( Sum ( Prefix (<* C32 , C33 , C34 *> , 3) ) ) = ( Sum <* D7 , D8 , D9 *> ) by L60 , FINSEQ_3:49
.= ( ( C32 + C33 ) + C34 ) by RVSUM_1:78;
end;
begin
definition
struct TuringStr(# Symbols , FStates ->  finite non  empty set , Tran -> (Function of [: the FStates , the Symbols :] , [: the FStates , the Symbols , { ( - 1 ) , ( 0 ) , 1 } :]) , InitS , AcceptS -> (Element of the FStates) #);
end;
definition
let C35 being TuringStr;
mode State of C35
 is (Element of (the FStates of C35));
mode Tape of C35
 is (Element of ( Funcs (( INT ) , (the Symbols of C35)) ));
mode Symbol of C35
 is (Element of (the Symbols of C35));
end;
definition
let C36 being TuringStr;
let C37 being (Tape of C36);
let C38 being Integer;
let C39 being (Symbol of C36);
func Tape-Chg (C37 , C38 , C39) -> (Tape of C36) equals 
( C37 +* ( C38 .--> C39 ) );
coherence
proof
set D10 = ( INT );
set D11 = (the Symbols of C36);
L64: (ex B18 being Function st (C37 = B18 & ( dom B18 ) = D10 & ( rng B18 ) c= D11)) by FUNCT_2:def 2;
L65: ( rng ( C38 .--> C39 ) ) = { C39 } by FUNCOP_1:8;
L66: (( rng ( C37 +* ( C38 .--> C39 ) ) ) c= ( ( rng C37 ) \/ ( rng ( C38 .--> C39 ) ) ) & ( ( rng C37 ) \/ ( rng ( C38 .--> C39 ) ) ) c= D11) by L65 , L64 , FUNCT_4:17 , XBOOLE_1:8;
L67: ( rng ( C37 +* ( C38 .--> C39 ) ) ) c= D11 by L66 , XBOOLE_1:1;
L68: C38 in ( INT ) by INT_1:def 2;
L69: ( dom ( C37 +* ( C38 .--> C39 ) ) ) = ( ( dom C37 ) \/ ( dom ( C38 .--> C39 ) ) ) by FUNCT_4:def 1
.= ( ( dom C37 ) \/ { C38 } ) by FUNCOP_1:13
.= D10 by L64 , L68 , ZFMISC_1:40;
thus L70: thesis by L69 , L67 , FUNCT_2:def 2;
end;
end;
definition
let C40 being TuringStr;
mode All-State of C40
 is (Element of [: (the FStates of C40) , ( INT ) , ( Funcs (( INT ) , (the Symbols of C40)) ) :]);
mode Tran-Source of C40
 is (Element of [: (the FStates of C40) , (the Symbols of C40) :]);
mode Tran-Goal of C40
 is (Element of [: (the FStates of C40) , (the Symbols of C40) , { ( - 1 ) , ( 0 ) , 1 } :]);
end;
definition
let C41 being TuringStr;
let C42 being (Tran-Goal of C41);
func offset C42 -> Integer equals 
( C42 `3_3 );
coherence by ENUMSET1:def 1;
end;
definition
let C43 being TuringStr;
let C44 being (All-State of C43);
func Head C44 -> Integer equals 
( C44 `2_3 );
coherence;
end;
definition
let C45 being TuringStr;
let C46 being (All-State of C45);
func TRAN C46 -> (Tran-Goal of C45) equals 
( (the Tran of C45) . [ ( C46 `1_3 ) , ( (( C46 `3_3 ) qua (Tape of C45)) . ( Head C46 ) ) ] );
correctness
proof
reconsider D12 = ( Head C46 ) as (Element of ( INT ));
L75: ( (the Tran of C45) . [ ( C46 `1_3 ) , ( (( C46 `3_3 ) qua (Tape of C45)) . D12 ) ] ) is (Tran-Goal of C45);
thus L76: thesis by L75;
end;
end;
definition
let C47 being TuringStr;
let C48 being (All-State of C47);
func Following C48 -> (All-State of C47) equals 
:L78: [ ( ( TRAN C48 ) `1_3 ) , ( ( Head C48 ) + ( offset ( TRAN C48 ) ) ) , ( Tape-Chg (( C48 `3_3 ) , ( Head C48 ) , ( ( TRAN C48 ) `2_3 )) ) ] if ( C48 `1_3 ) <> (the AcceptS of C47) otherwise C48;
correctness
proof
L79: ( ( Head C48 ) + ( offset ( TRAN C48 ) ) ) in ( INT ) by INT_1:def 2;
thus L80: thesis by L79 , MCART_1:69;
end;
end;
definition
let C49 being TuringStr;
let C50 being (All-State of C49);
func Computation C50 -> (Function of ( NAT ) , [: (the FStates of C49) , ( INT ) , ( Funcs (( INT ) , (the Symbols of C49)) ) :]) means 
:L82: (( it . ( 0 ) ) = C50 & (for B19 being Nat holds ( it . ( B19 + 1 ) ) = ( Following ( it . B19 ) )));
existence
proof
deffunc H1(set , (All-State of C49)) = ( Following $2 );
consider C51 being (Function of ( NAT ) , [: (the FStates of C49) , ( INT ) , ( Funcs (( INT ) , (the Symbols of C49)) ) :]) such that L83: (( C51 . ( 0 ) ) = C50 & (for B20 being Nat holds ( C51 . ( B20 + 1 ) ) = H1(B20 , ( C51 . B20 )))) from NAT_1:sch 12;
take C51;
thus L84: thesis by L83;
end;
uniqueness
proof
deffunc H2(set , (All-State of C49)) = ( Following $2 );
let C52 , C53 being (Function of ( NAT ) , [: (the FStates of C49) , ( INT ) , ( Funcs (( INT ) , (the Symbols of C49)) ) :]);
assume that
L85: ( C52 . ( 0 ) ) = C50
and
L86: (for B21 being Nat holds ( C52 . ( B21 + 1 ) ) = ( Following ( C52 . B21 ) ))
and
L87: ( C53 . ( 0 ) ) = C50
and
L88: (for B22 being Nat holds ( C53 . ( B22 + 1 ) ) = ( Following ( C53 . B22 ) ));
L89: (for B23 being Nat holds ( C52 . ( B23 + 1 ) ) = H2(B23 , ( C52 . B23 ))) by L86;
L90: (for B24 being Nat holds ( C53 . ( B24 + 1 ) ) = H2(B24 , ( C53 . B24 ))) by L88;
L91: ( C53 . ( 0 ) ) = C50 by L87;
L92: ( C52 . ( 0 ) ) = C50 by L85;
thus L93: C52 = C53 from NAT_1:sch 16(L92 , L89 , L91 , L90);
end;
end;
theorem
L95: (for B25 being TuringStr holds (for B26 being (All-State of B25) holds (( B26 `1_3 ) = (the AcceptS of B25) implies B26 = ( Following B26 )))) by L78;
theorem
L96: (for R5 being TuringStr holds (for R6 being (All-State of R5) holds ( ( Computation R6 ) . ( 0 ) ) = R6)) by L82;
theorem
L97: (for R4 being (Element of ( NAT )) holds (for R5 being TuringStr holds (for R6 being (All-State of R5) holds ( ( Computation R6 ) . ( R4 + 1 ) ) = ( Following ( ( Computation R6 ) . R4 ) )))) by L82;
theorem
L98: (for R5 being TuringStr holds (for R6 being (All-State of R5) holds ( ( Computation R6 ) . 1 ) = ( Following R6 )))
proof
let R5 being TuringStr;
let R6 being (All-State of R5);
L99: ( ( Computation R6 ) . ( ( 0 ) + 1 ) ) = ( Following ( ( Computation R6 ) . ( 0 ) ) ) by L82
.= ( Following R6 ) by L82;
thus L100: thesis by L99;
end;
theorem
L101: (for R2 being (Element of ( NAT )) holds (for R4 being (Element of ( NAT )) holds (for R5 being TuringStr holds (for R6 being (All-State of R5) holds ( ( Computation R6 ) . ( R2 + R4 ) ) = ( ( Computation ( ( Computation R6 ) . R2 ) ) . R4 )))))
proof
let R2 being (Element of ( NAT ));
let R4 being (Element of ( NAT ));
let R5 being TuringStr;
let R6 being (All-State of R5);
defpred S1[ (Element of ( NAT )) ] means ( ( Computation R6 ) . ( R2 + $1 ) ) = ( ( Computation ( ( Computation R6 ) . R2 ) ) . $1 );
L102: (for R4 being (Element of ( NAT )) holds (S1[ R4 ] implies S1[ ( R4 + 1 ) ]))
proof
let R4 being (Element of ( NAT ));
assume L103: ( ( Computation R6 ) . ( R2 + R4 ) ) = ( ( Computation ( ( Computation R6 ) . R2 ) ) . R4 );
thus L104: ( ( Computation R6 ) . ( R2 + ( R4 + 1 ) ) ) = ( ( Computation R6 ) . ( ( R2 + R4 ) + 1 ) )
.= ( Following ( ( Computation R6 ) . ( R2 + R4 ) ) ) by L82
.= ( ( Computation ( ( Computation R6 ) . R2 ) ) . ( R4 + 1 ) ) by L103 , L82;
end;
L105: S1[ ( 0 ) ] by L82;
L106: (for R4 being (Element of ( NAT )) holds S1[ R4 ]) from NAT_1:sch 1(L105 , L102);
thus L107: thesis by L106;
end;
theorem
L108: (for R2 being (Element of ( NAT )) holds (for R3 being (Element of ( NAT )) holds (for R5 being TuringStr holds (for R6 being (All-State of R5) holds ((R2 <= R3 & ( Following ( ( Computation R6 ) . R2 ) ) = ( ( Computation R6 ) . R2 )) implies ( ( Computation R6 ) . R3 ) = ( ( Computation R6 ) . R2 ))))))
proof
let R2 being (Element of ( NAT ));
let R3 being (Element of ( NAT ));
let R5 being TuringStr;
let R6 being (All-State of R5);
assume that
L109: R2 <= R3
and
L110: ( Following ( ( Computation R6 ) . R2 ) ) = ( ( Computation R6 ) . R2 );
consider C54 being Nat such that L111: R3 = ( R2 + C54 ) by L109 , NAT_1:10;
defpred S2[ (Element of ( NAT )) ] means ( ( Computation R6 ) . ( R2 + $1 ) ) = ( ( Computation R6 ) . R2 );
L112: (for R4 being (Element of ( NAT )) holds (S2[ R4 ] implies S2[ ( R4 + 1 ) ]))
proof
let R4 being (Element of ( NAT ));
assume L113: ( ( Computation R6 ) . ( R2 + R4 ) ) = ( ( Computation R6 ) . R2 );
thus L114: ( ( Computation R6 ) . ( R2 + ( R4 + 1 ) ) ) = ( ( Computation R6 ) . ( ( R2 + R4 ) + 1 ) )
.= ( ( Computation R6 ) . R2 ) by L110 , L113 , L82;
end;
L115: S2[ ( 0 ) ];
L116: (for R4 being (Element of ( NAT )) holds S2[ R4 ]) from NAT_1:sch 1(L115 , L112);
L117: C54 in ( NAT ) by ORDINAL1:def 12;
thus L118: thesis by L117 , L111 , L116;
end;
theorem
L119: (for R2 being (Element of ( NAT )) holds (for R3 being (Element of ( NAT )) holds (for R5 being TuringStr holds (for R6 being (All-State of R5) holds ((R2 <= R3 & ( ( ( Computation R6 ) . R2 ) `1_3 ) = (the AcceptS of R5)) implies ( ( Computation R6 ) . R3 ) = ( ( Computation R6 ) . R2 ))))))
proof
let R2 being (Element of ( NAT ));
let R3 being (Element of ( NAT ));
let R5 being TuringStr;
let R6 being (All-State of R5);
assume that
L120: R2 <= R3
and
L121: ( ( ( Computation R6 ) . R2 ) `1_3 ) = (the AcceptS of R5);
L122: ( Following ( ( Computation R6 ) . R2 ) ) = ( ( Computation R6 ) . R2 ) by L121 , L78;
thus L123: thesis by L122 , L120 , L108;
end;
definition
let C55 being TuringStr;
let C56 being (All-State of C55);
attr C56 is  Accept-Halt
means
:L124: (ex R4 being (Element of ( NAT )) st ( ( ( Computation C56 ) . R4 ) `1_3 ) = (the AcceptS of C55));
end;
definition
let C57 being TuringStr;
let C58 being (All-State of C57);
assume that
L126: C58 is  Accept-Halt;
func Result C58 -> (All-State of C57) means 
:L127: (ex R4 being (Element of ( NAT )) st (it = ( ( Computation C58 ) . R4 ) & ( ( ( Computation C58 ) . R4 ) `1_3 ) = (the AcceptS of C57)));
uniqueness
proof
let C59 , C60 being (All-State of C57);
given C61 being (Element of ( NAT )) such that
L128: (C59 = ( ( Computation C58 ) . C61 ) & ( ( ( Computation C58 ) . C61 ) `1_3 ) = (the AcceptS of C57));

given C62 being (Element of ( NAT )) such that
L129: (C60 = ( ( Computation C58 ) . C62 ) & ( ( ( Computation C58 ) . C62 ) `1_3 ) = (the AcceptS of C57));

L130: (C61 <= C62 or C62 <= C61);
thus L131: thesis by L130 , L128 , L129 , L119;
end;
correctness
proof
L132: (ex R4 being (Element of ( NAT )) st ( ( ( Computation C58 ) . R4 ) `1_3 ) = (the AcceptS of C57)) by L126 , L124;
thus L133: thesis by L132;
end;
end;
theorem
L135: (for B27 being TuringStr holds (for B28 being (All-State of B27) holds (B28 is  Accept-Halt implies (ex B29 being (Element of ( NAT )) st (( ( ( Computation B28 ) . B29 ) `1_3 ) = (the AcceptS of B27) & ( Result B28 ) = ( ( Computation B28 ) . B29 ) & (for B30 being (Element of ( NAT )) holds (B30 < B29 implies ( ( ( Computation B28 ) . B30 ) `1_3 ) <> (the AcceptS of B27))))))))
proof
let C63 being TuringStr;
let C64 being (All-State of C63);
defpred S3[ Nat ] means ( ( ( Computation C64 ) . $1 ) `1_3 ) = (the AcceptS of C63);
assume L136: C64 is  Accept-Halt;
L137: (ex R4 being (Element of ( NAT )) st ( ( ( Computation C64 ) . R4 ) `1_3 ) = (the AcceptS of C63)) by L136 , L124;
L138: (ex B31 being Nat st S3[ B31 ]) by L137;
consider C65 being Nat such that L139: (S3[ C65 ] & (for B32 being Nat holds (S3[ B32 ] implies C65 <= B32))) from NAT_1:sch 5(L138);
reconsider D13 = C65 as (Element of ( NAT )) by ORDINAL1:def 12;
take D13;
thus L140: S3[ D13 ] by L139;
thus L141: ( Result C64 ) = ( ( Computation C64 ) . D13 ) by L136 , L139 , L127;
thus L142: thesis by L139;
end;
definition
let C66 , C67 being non  empty set;
let C68 being set;
assume that
L143: C68 in C67;
func id (C66 , C67 , C68) -> (Function of C66 , [: C66 , C67 :]) means 
(for B33 being (Element of C66) holds ( it . B33 ) = [ B33 , C68 ]);
existence
proof
reconsider D14 = C68 as (Element of C67) by L143;
deffunc H3((Element of C66)) = [ $1 , D14 ];
consider C69 being (Function of C66 , [: C66 , C67 :]) such that L144: (for B34 being (Element of C66) holds ( C69 . B34 ) = H3(B34)) from FUNCT_2:sch 4;
take C69;
thus L145: thesis by L144;
end;
uniqueness
proof
deffunc H4((Element of C66)) = [ $1 , C68 ];
thus L146: (for B35 , B36 being (Function of C66 , [: C66 , C67 :]) holds (((for B37 being (Element of C66) holds ( B35 . B37 ) = H4(B37)) & (for B38 being (Element of C66) holds ( B36 . B38 ) = H4(B38))) implies B35 = B36)) from BINOP_2:sch 1;
end;
end;
definition
func Sum_Tran -> (Function of [: ( SegM 5 ) , { ( 0 ) , 1 } :] , [: ( SegM 5 ) , { ( 0 ) , 1 } , { ( - 1 ) , ( 0 ) , 1 } :]) equals 
( ( ( ( ( ( ( ( ( ( id ([: ( SegM 5 ) , { ( 0 ) , 1 } :] , { ( - 1 ) , ( 0 ) , 1 } , ( 0 )) ) +* ( [ ( 0 ) , ( 0 ) ] .--> [ ( 0 ) , ( 0 ) , 1 ] ) ) +* ( [ ( 0 ) , 1 ] .--> [ 1 , ( 0 ) , 1 ] ) ) +* ( [ 1 , 1 ] .--> [ 1 , 1 , 1 ] ) ) +* ( [ 1 , ( 0 ) ] .--> [ 2 , 1 , 1 ] ) ) +* ( [ 2 , 1 ] .--> [ 2 , 1 , 1 ] ) ) +* ( [ 2 , ( 0 ) ] .--> [ 3 , ( 0 ) , ( - 1 ) ] ) ) +* ( [ 3 , 1 ] .--> [ 4 , ( 0 ) , ( - 1 ) ] ) ) +* ( [ 4 , 1 ] .--> [ 4 , 1 , ( - 1 ) ] ) ) +* ( [ 4 , ( 0 ) ] .--> [ 5 , ( 0 ) , ( 0 ) ] ) );
coherence
proof
reconsider D15 = ( 0 ) , D16 = 1 , D17 = 2 , D18 = 3 , D19 = 4 , D20 = 5 as (Element of ( SegM 5 )) by L26;
set D21 = [: ( SegM 5 ) , { ( 0 ) , 1 } :];
set D22 = { ( - 1 ) , ( 0 ) , 1 };
set D23 = [: ( SegM 5 ) , { ( 0 ) , 1 } , D22 :];
reconsider D24 = ( 0 ) , D25 = 1 as (Element of { ( 0 ) , 1 }) by TARSKI:def 2;
reconsider D26 = ( - 1 ) as (Element of D22) by ENUMSET1:def 1;
reconsider D27 = ( 0 ) , D28 = 1 as (Element of { ( - 1 ) , ( 0 ) , 1 }) by ENUMSET1:def 1;
L148: D23 = [: D21 , D22 :] by ZFMISC_1:def 3;
reconsider D29 = ( id (D21 , D22 , D27) ) as (Function of D21 , D23) by L148;
L149: ( ( ( ( ( ( ( ( ( ( id (D21 , D22 , ( 0 )) ) +* ( [ ( 0 ) , ( 0 ) ] .--> [ ( 0 ) , ( 0 ) , 1 ] ) ) +* ( [ ( 0 ) , 1 ] .--> [ 1 , ( 0 ) , 1 ] ) ) +* ( [ 1 , 1 ] .--> [ 1 , 1 , 1 ] ) ) +* ( [ 1 , ( 0 ) ] .--> [ 2 , 1 , 1 ] ) ) +* ( [ 2 , 1 ] .--> [ 2 , 1 , 1 ] ) ) +* ( [ 2 , ( 0 ) ] .--> [ 3 , ( 0 ) , ( - 1 ) ] ) ) +* ( [ 3 , 1 ] .--> [ 4 , ( 0 ) , ( - 1 ) ] ) ) +* ( [ 4 , 1 ] .--> [ 4 , 1 , ( - 1 ) ] ) ) +* ( [ 4 , ( 0 ) ] .--> [ 5 , ( 0 ) , ( 0 ) ] ) ) = ( ( ( ( ( ( ( ( ( D29 +* ( [ D15 , D24 ] .--> [ D15 , D24 , D28 ] ) ) +* ( [ D15 , D25 ] .--> [ D16 , D24 , D28 ] ) ) +* ( [ D16 , D25 ] .--> [ D16 , D25 , D28 ] ) ) +* ( [ D16 , D24 ] .--> [ D17 , D25 , D28 ] ) ) +* ( [ D17 , D25 ] .--> [ D17 , D25 , D28 ] ) ) +* ( [ D17 , D24 ] .--> [ D18 , D24 , D26 ] ) ) +* ( [ D18 , D25 ] .--> [ D19 , D24 , D26 ] ) ) +* ( [ D19 , D25 ] .--> [ D19 , D25 , D26 ] ) ) +* ( [ D19 , D24 ] .--> [ D20 , D24 , D27 ] ) );
thus L150: thesis by L149;
end;
end;
theorem
L152: (( ( Sum_Tran ) . [ ( 0 ) , ( 0 ) ] ) = [ ( 0 ) , ( 0 ) , 1 ] & ( ( Sum_Tran ) . [ ( 0 ) , 1 ] ) = [ 1 , ( 0 ) , 1 ] & ( ( Sum_Tran ) . [ 1 , 1 ] ) = [ 1 , 1 , 1 ] & ( ( Sum_Tran ) . [ 1 , ( 0 ) ] ) = [ 2 , 1 , 1 ] & ( ( Sum_Tran ) . [ 2 , 1 ] ) = [ 2 , 1 , 1 ] & ( ( Sum_Tran ) . [ 2 , ( 0 ) ] ) = [ 3 , ( 0 ) , ( - 1 ) ] & ( ( Sum_Tran ) . [ 3 , 1 ] ) = [ 4 , ( 0 ) , ( - 1 ) ] & ( ( Sum_Tran ) . [ 4 , 1 ] ) = [ 4 , 1 , ( - 1 ) ] & ( ( Sum_Tran ) . [ 4 , ( 0 ) ] ) = [ 5 , ( 0 ) , ( 0 ) ])
proof
set D30 = [ ( 0 ) , 1 ];
set D31 = [ ( 0 ) , ( 0 ) ];
set D32 = ( [ ( 0 ) , ( 0 ) ] .--> [ ( 0 ) , ( 0 ) , 1 ] );
set D33 = ( [ ( 0 ) , 1 ] .--> [ 1 , ( 0 ) , 1 ] );
set D34 = ( [ 1 , 1 ] .--> [ 1 , 1 , 1 ] );
set D35 = ( [ 1 , ( 0 ) ] .--> [ 2 , 1 , 1 ] );
set D36 = ( [ 2 , 1 ] .--> [ 2 , 1 , 1 ] );
set D37 = ( [ 2 , ( 0 ) ] .--> [ 3 , ( 0 ) , ( - 1 ) ] );
set D38 = ( [ 3 , 1 ] .--> [ 4 , ( 0 ) , ( - 1 ) ] );
set D39 = ( [ 4 , 1 ] .--> [ 4 , 1 , ( - 1 ) ] );
set D40 = ( id ([: ( SegM 5 ) , { ( 0 ) , 1 } :] , { ( - 1 ) , ( 0 ) , 1 } , ( 0 )) );
thus L153: ( ( Sum_Tran ) . D31 ) = ( ( ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) +* D38 ) +* D39 ) . D31 ) by L32
.= ( ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) +* D38 ) . D31 ) by L32
.= ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) . D31 ) by L32
.= ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) . D31 ) by L32
.= ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) . D31 ) by L32
.= ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) . D31 ) by L32
.= ( ( ( D40 +* D32 ) +* D33 ) . D31 ) by L32
.= ( ( D40 +* D32 ) . D31 ) by L38
.= [ ( 0 ) , ( 0 ) , 1 ] by FUNCT_7:94;
thus L154: ( ( Sum_Tran ) . D30 ) = ( ( ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) +* D38 ) +* D39 ) . D30 ) by L32
.= ( ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) +* D38 ) . D30 ) by L32
.= ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) . D30 ) by L32
.= ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) . D30 ) by L32
.= ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) . D30 ) by L32
.= ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) . D30 ) by L32
.= ( ( ( D40 +* D32 ) +* D33 ) . D30 ) by L32
.= [ 1 , ( 0 ) , 1 ] by FUNCT_7:94;
set D41 = [ 1 , 1 ];
thus L155: ( ( Sum_Tran ) . D41 ) = ( ( ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) +* D38 ) +* D39 ) . D41 ) by L32
.= ( ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) +* D38 ) . D41 ) by L32
.= ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) . D41 ) by L32
.= ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) . D41 ) by L32
.= ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) . D41 ) by L32
.= ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) . D41 ) by L38
.= [ 1 , 1 , 1 ] by FUNCT_7:94;
set D42 = [ 1 , ( 0 ) ];
thus L156: ( ( Sum_Tran ) . D42 ) = ( ( ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) +* D38 ) +* D39 ) . D42 ) by L32
.= ( ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) +* D38 ) . D42 ) by L32
.= ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) . D42 ) by L32
.= ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) . D42 ) by L32
.= ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) . D42 ) by L32
.= [ 2 , 1 , 1 ] by FUNCT_7:94;
set D43 = [ 2 , 1 ];
thus L157: ( ( Sum_Tran ) . D43 ) = ( ( ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) +* D38 ) +* D39 ) . D43 ) by L32
.= ( ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) +* D38 ) . D43 ) by L32
.= ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) . D43 ) by L32
.= ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) . D43 ) by L38
.= [ 2 , 1 , 1 ] by FUNCT_7:94;
set D44 = [ 2 , ( 0 ) ];
thus L158: ( ( Sum_Tran ) . D44 ) = ( ( ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) +* D38 ) +* D39 ) . D44 ) by L32
.= ( ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) +* D38 ) . D44 ) by L32
.= ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) . D44 ) by L32
.= [ 3 , ( 0 ) , ( - 1 ) ] by FUNCT_7:94;
set D45 = [ 3 , 1 ];
thus L159: ( ( Sum_Tran ) . D45 ) = ( ( ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) +* D38 ) +* D39 ) . D45 ) by L32
.= ( ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) +* D38 ) . D45 ) by L32
.= [ 4 , ( 0 ) , ( - 1 ) ] by FUNCT_7:94;
set D46 = [ 4 , 1 ];
thus L160: ( ( Sum_Tran ) . D46 ) = ( ( ( ( ( ( ( ( ( D40 +* D32 ) +* D33 ) +* D34 ) +* D35 ) +* D36 ) +* D37 ) +* D38 ) +* D39 ) . D46 ) by L38
.= [ 4 , 1 , ( - 1 ) ] by FUNCT_7:94;
thus L161: thesis by FUNCT_7:94;
end;
definition
let C70 being TuringStr;
let C71 being (Tape of C70);
let C72 , C73 being Integer;
pred C71 is_1_between C72 , C73
means
:L162: (( C71 . C72 ) = ( 0 ) & ( C71 . C73 ) = ( 0 ) & (for B39 being Integer holds ((C72 < B39 & B39 < C73) implies ( C71 . B39 ) = 1)))
;end;
definition
let C74 being (FinSequence of ( NAT ));
let C75 being TuringStr;
let C76 being (Tape of C75);
pred C76 storeData C74
means
:L164: (for B40 being (Element of ( NAT )) holds ((1 <= B40 & B40 < ( len C74 )) implies C76 is_1_between ( ( Sum ( Prefix (C74 , B40) ) ) + ( 2 * ( B40 - 1 ) ) ) , ( ( Sum ( Prefix (C74 , ( B40 + 1 )) ) ) + ( 2 * B40 ) )))
;end;
theorem
L166: (for B41 being TuringStr holds (for B42 being (Tape of B41) holds (for B43 , B44 being (Element of ( NAT )) holds (B42 storeData <* B43 , B44 *> implies B42 is_1_between B43 , ( ( B43 + B44 ) + 2 )))))
proof
let C77 being TuringStr;
let C78 being (Tape of C77);
let C79 , C80 being (Element of ( NAT ));
set D47 = <* C79 , C80 *>;
assume L167: C78 storeData D47;
L168: ( len D47 ) = 2 by FINSEQ_1:44;
L169: (( ( Sum ( Prefix (D47 , 1) ) ) + ( 2 * ( 1 - 1 ) ) ) = C79 & ( ( Sum ( Prefix (D47 , ( 1 + 1 )) ) ) + ( 2 * 1 ) ) = ( ( C79 + C80 ) + 2 )) by L53;
thus L170: thesis by L169 , L167 , L168 , L164;
end;
theorem
L171: (for B45 being TuringStr holds (for B46 being (Tape of B45) holds (for B47 , B48 being (Element of ( NAT )) holds (B46 is_1_between B47 , ( ( B47 + B48 ) + 2 ) implies B46 storeData <* B47 , B48 *>))))
proof
let C81 being TuringStr;
let C82 being (Tape of C81);
let C83 , C84 being (Element of ( NAT ));
set D48 = <* C83 , C84 *>;
assume L172: C82 is_1_between C83 , ( ( C83 + C84 ) + 2 );
L173: ( ( Sum ( Prefix (D48 , ( 1 + 1 )) ) ) + ( 2 * 1 ) ) = ( ( C83 + C84 ) + 2 ) by L53;
L174:
now
let C85 being (Element of ( NAT ));
assume that
L175: 1 <= C85
and
L176: C85 < ( len D48 );
L177: ( len D48 ) = 2 by FINSEQ_1:44;
L178: ( C85 + 1 ) <= ( 1 + 1 ) by L177 , L176 , INT_1:7;
L179: C85 <= 1 by L178 , XREAL_1:6;
L180: C85 = 1 by L179 , L175 , XXREAL_0:1;
thus L181: C82 is_1_between ( ( Sum ( Prefix (D48 , C85) ) ) + ( 2 * ( C85 - 1 ) ) ) , ( ( Sum ( Prefix (D48 , ( C85 + 1 )) ) ) + ( 2 * C85 ) ) by L180 , L172 , L173 , L53;
end;
thus L182: thesis by L174 , L164;
end;
theorem
L183: (for B49 being TuringStr holds (for B50 being (Tape of B49) holds (for B51 , B52 being (Element of ( NAT )) holds (B50 storeData <* B51 , B52 *> implies (( B50 . B51 ) = ( 0 ) & ( B50 . ( ( B51 + B52 ) + 2 ) ) = ( 0 ) & (for B53 being Integer holds ((B51 < B53 & B53 < ( ( B51 + B52 ) + 2 )) implies ( B50 . B53 ) = 1)))))))
proof
let C86 being TuringStr;
let C87 being (Tape of C86);
let C88 , C89 being (Element of ( NAT ));
assume L184: C87 storeData <* C88 , C89 *>;
L185: C87 is_1_between C88 , ( ( C88 + C89 ) + 2 ) by L184 , L166;
thus L186: (( C87 . C88 ) = ( 0 ) & ( C87 . ( ( C88 + C89 ) + 2 ) ) = ( 0 )) by L185 , L162;
thus L187: thesis by L185 , L162;
end;
theorem
L188: (for B54 being TuringStr holds (for B55 being (Tape of B54) holds (for B56 , B57 , B58 being (Element of ( NAT )) holds (B55 storeData <* B56 , B57 , B58 *> implies (B55 is_1_between B56 , ( ( B56 + B57 ) + 2 ) & B55 is_1_between ( ( B56 + B57 ) + 2 ) , ( ( ( B56 + B57 ) + B58 ) + 4 ))))))
proof
let C90 being TuringStr;
let C91 being (Tape of C90);
let C92 , C93 , C94 being (Element of ( NAT ));
set D49 = <* C92 , C93 , C94 *>;
assume L189: C91 storeData D49;
L190: ( len D49 ) = 3 by FINSEQ_1:45;
L191: (( ( Sum ( Prefix (D49 , 1) ) ) + ( 2 * ( 1 - 1 ) ) ) = C92 & ( ( Sum ( Prefix (D49 , ( 1 + 1 )) ) ) + ( 2 * 1 ) ) = ( ( C92 + C93 ) + 2 )) by L57;
thus L192: C91 is_1_between C92 , ( ( C92 + C93 ) + 2 ) by L191 , L189 , L190 , L164;
L193: (( ( Sum ( Prefix (D49 , 2) ) ) + ( 2 * ( 2 - 1 ) ) ) = ( ( C92 + C93 ) + 2 ) & ( ( Sum ( Prefix (D49 , ( 2 + 1 )) ) ) + ( 2 * 2 ) ) = ( ( ( C92 + C93 ) + C94 ) + 4 )) by L57;
thus L194: thesis by L193 , L189 , L190 , L164;
end;
theorem
L195: (for B59 being TuringStr holds (for B60 being (Tape of B59) holds (for B61 , B62 , B63 being (Element of ( NAT )) holds (B60 storeData <* B61 , B62 , B63 *> implies (( B60 . B61 ) = ( 0 ) & ( B60 . ( ( B61 + B62 ) + 2 ) ) = ( 0 ) & ( B60 . ( ( ( B61 + B62 ) + B63 ) + 4 ) ) = ( 0 ) & (for B64 being Integer holds ((B61 < B64 & B64 < ( ( B61 + B62 ) + 2 )) implies ( B60 . B64 ) = 1)) & (for B65 being Integer holds ((( ( B61 + B62 ) + 2 ) < B65 & B65 < ( ( ( B61 + B62 ) + B63 ) + 4 )) implies ( B60 . B65 ) = 1)))))))
proof
let C95 being TuringStr;
let C96 being (Tape of C95);
let C97 , C98 , C99 being (Element of ( NAT ));
assume L196: C96 storeData <* C97 , C98 , C99 *>;
L197: (C96 is_1_between C97 , ( ( C97 + C98 ) + 2 ) & C96 is_1_between ( ( C97 + C98 ) + 2 ) , ( ( ( C97 + C98 ) + C99 ) + 4 )) by L196 , L188;
thus L198: (( C96 . C97 ) = ( 0 ) & ( C96 . ( ( C97 + C98 ) + 2 ) ) = ( 0 ) & ( C96 . ( ( ( C97 + C98 ) + C99 ) + 4 ) ) = ( 0 )) by L197 , L162;
thus L199: thesis by L197 , L162;
end;
theorem
L200: (for B66 being (FinSequence of ( NAT )) holds (for B67 being (Element of ( NAT )) holds (( len B66 ) >= 1 implies (( Sum ( Prefix (( <* B67 *> ^ B66 ) , 1) ) ) = B67 & ( Sum ( Prefix (( <* B67 *> ^ B66 ) , 2) ) ) = ( B67 + ( B66 /. 1 ) )))))
proof
let C100 being (FinSequence of ( NAT ));
let C101 being (Element of ( NAT ));
set D50 = <* C101 *>;
set D51 = ( D50 ^ C100 );
reconsider D52 = C101 as (Element of ( INT )) by INT_1:def 2;
reconsider D53 = ( C100 /. 1 ) as (Element of ( INT )) by INT_1:def 2;
assume L201: ( len C100 ) >= 1;
consider C102 being Nat such that L202: ( len C100 ) = ( 1 + C102 ) by L201 , NAT_1:10;
L203: ( len D50 ) = 1 by FINSEQ_1:39;
L204: ( Seg 1 ) = ( dom D50 ) by L203 , FINSEQ_1:def 3;
thus L205: ( Sum ( Prefix (D51 , 1) ) ) = ( Sum <* D52 *> ) by L204 , FINSEQ_1:21
.= C101 by FINSOP_1:11;
L206: ( len D51 ) = ( 1 + ( len C100 ) ) by L203 , FINSEQ_1:22
.= ( 2 + C102 ) by L202;
consider C103 , C104 being (FinSequence of ( NAT )) such that L207: ( len C103 ) = 2 and L208: ( len C104 ) = C102 and L209: D51 = ( C103 ^ C104 ) by L206 , FINSEQ_2:23;
L210: ( C100 /. 1 ) = ( C100 . 1 ) by L201 , FINSEQ_4:15
.= ( D51 . ( 1 + 1 ) ) by L201 , L203 , FINSEQ_7:3;
L211: ( C103 . 2 ) = ( C100 /. 1 ) by L210 , L207 , L209 , FINSEQ_1:64;
L212: ( Seg 2 ) = ( dom C103 ) by L207 , FINSEQ_1:def 3;
L213: C103 = ( Prefix (D51 , 2) ) by L212 , L209 , FINSEQ_1:21;
L214: ( D51 . 1 ) = C101 by FINSEQ_1:41;
L215: ( C103 . 1 ) = C101 by L214 , L207 , L209 , FINSEQ_1:64;
thus L216: ( Sum ( Prefix (D51 , 2) ) ) = ( Sum <* D52 , D53 *> ) by L215 , L207 , L213 , L211 , FINSEQ_1:44
.= ( C101 + ( C100 /. 1 ) ) by RVSUM_1:77;
end;
theorem
L217: (for B68 being (FinSequence of ( NAT )) holds (for B69 being (Element of ( NAT )) holds (( len B68 ) >= 3 implies (( Sum ( Prefix (( <* B69 *> ^ B68 ) , 1) ) ) = B69 & ( Sum ( Prefix (( <* B69 *> ^ B68 ) , 2) ) ) = ( B69 + ( B68 /. 1 ) ) & ( Sum ( Prefix (( <* B69 *> ^ B68 ) , 3) ) ) = ( ( B69 + ( B68 /. 1 ) ) + ( B68 /. 2 ) ) & ( Sum ( Prefix (( <* B69 *> ^ B68 ) , 4) ) ) = ( ( ( B69 + ( B68 /. 1 ) ) + ( B68 /. 2 ) ) + ( B68 /. 3 ) )))))
proof
let C105 being (FinSequence of ( NAT ));
let C106 being (Element of ( NAT ));
set D54 = <* C106 *>;
set D55 = ( D54 ^ C105 );
reconsider D56 = C106 as (Element of ( INT )) by INT_1:def 2;
reconsider D57 = ( C105 /. 1 ) as (Element of ( INT )) by INT_1:def 2;
reconsider D58 = ( C105 /. 2 ) as (Element of ( INT )) by INT_1:def 2;
reconsider D59 = ( C105 /. 3 ) as (Element of ( INT )) by INT_1:def 2;
assume L218: ( len C105 ) >= 3;
consider C107 being Nat such that L219: ( len C105 ) = ( 3 + C107 ) by L218 , NAT_1:10;
reconsider D60 = C107 as (Element of ( NAT )) by ORDINAL1:def 12;
L220: ( len D54 ) = 1 by FINSEQ_1:39;
L221: ( len D55 ) = ( 1 + ( len C105 ) ) by L220 , FINSEQ_1:22
.= ( 4 + D60 ) by L219;
consider C108 , C109 being (FinSequence of ( NAT )) such that L222: ( len C108 ) = 4 and L223: ( len C109 ) = D60 and L224: D55 = ( C108 ^ C109 ) by L221 , FINSEQ_2:23;
L225: ( C105 /. 3 ) = ( C105 . 3 ) by L218 , FINSEQ_4:15
.= ( D55 . ( 1 + 3 ) ) by L218 , L220 , FINSEQ_7:3;
L226: ( C108 . 4 ) = ( C105 /. 3 ) by L225 , L222 , L224 , FINSEQ_1:64;
L227: ( Seg 4 ) = ( dom C108 ) by L222 , FINSEQ_1:def 3;
L228: C108 = ( Prefix (D55 , 4) ) by L227 , L224 , FINSEQ_1:21;
L229: 1 <= ( len C105 ) by L218 , XXREAL_0:2;
thus L230: (( Sum ( Prefix (( <* C106 *> ^ C105 ) , 1) ) ) = C106 & ( Sum ( Prefix (( <* C106 *> ^ C105 ) , 2) ) ) = ( C106 + ( C105 /. 1 ) )) by L229 , L200;
L231: ( len D55 ) = ( 3 + ( 1 + D60 ) ) by L221;
consider C110 , C111 being (FinSequence of ( NAT )) such that L232: ( len C110 ) = 3 and L233: ( len C111 ) = ( 1 + D60 ) and L234: D55 = ( C110 ^ C111 ) by L231 , FINSEQ_2:23;
L235: ( C105 /. 1 ) = ( C105 . 1 ) by L229 , FINSEQ_4:15
.= ( D55 . ( 1 + 1 ) ) by L229 , L220 , FINSEQ_7:3;
L236: ( C108 . 2 ) = ( C105 /. 1 ) by L235 , L222 , L224 , FINSEQ_1:64;
L237: 2 <= ( len C105 ) by L218 , XXREAL_0:2;
L238: ( C105 /. 2 ) = ( C105 . 2 ) by L237 , FINSEQ_4:15
.= ( D55 . ( 1 + 2 ) ) by L220 , L237 , FINSEQ_7:3;
L239: ( C108 . 3 ) = ( C105 /. 2 ) by L238 , L222 , L224 , FINSEQ_1:64;
L240: ( C110 . 2 ) = ( C105 /. 1 ) by L235 , L232 , L234 , FINSEQ_1:64;
L241: ( Seg 3 ) = ( dom C110 ) by L232 , FINSEQ_1:def 3;
L242: C110 = ( Prefix (D55 , 3) ) by L241 , L234 , FINSEQ_1:21;
L243: ( C110 . 3 ) = ( C105 /. 2 ) by L238 , L232 , L234 , FINSEQ_1:64;
L244: ( D55 . 1 ) = C106 by FINSEQ_1:41;
L245: ( C110 . 1 ) = C106 by L244 , L232 , L234 , FINSEQ_1:64;
L246: C110 = <* C106 , ( C105 /. 1 ) , ( C105 /. 2 ) *> by L245 , L232 , L240 , L243 , FINSEQ_1:45;
thus L247: ( Sum ( Prefix (D55 , 3) ) ) = ( ( C106 + ( C105 /. 1 ) ) + ( C105 /. 2 ) ) by L246 , L242 , RVSUM_1:78;
L248: ( C108 . 1 ) = C106 by L244 , L222 , L224 , FINSEQ_1:64;
L249: C108 = <* C106 , ( C105 /. 1 ) , ( C105 /. 2 ) , ( C105 /. 3 ) *> by L248 , L222 , L236 , L239 , L226 , FINSEQ_4:76;
thus L250: ( Sum ( Prefix (D55 , 4) ) ) = ( ( ( D56 + D57 ) + D58 ) + D59 ) by L249 , L228 , RVSUM_1:142
.= ( ( ( C106 + ( C105 /. 1 ) ) + ( C105 /. 2 ) ) + ( C105 /. 3 ) );
end;
theorem
L251: (for B70 being TuringStr holds (for B71 being (Tape of B70) holds (for B72 being (Element of ( NAT )) holds (for B73 being (FinSequence of ( NAT )) holds ((( len B73 ) >= 1 & B71 storeData ( <* B72 *> ^ B73 )) implies B71 is_1_between B72 , ( ( B72 + ( B73 /. 1 ) ) + 2 ))))))
proof
let C112 being TuringStr;
let C113 being (Tape of C112);
let C114 being (Element of ( NAT ));
let C115 being (FinSequence of ( NAT ));
set D61 = ( <* C114 *> ^ C115 );
assume that
L252: ( len C115 ) >= 1
and
L253: C113 storeData D61;
L254: ( len <* C114 *> ) = 1 by FINSEQ_1:39;
L255: ( len D61 ) = ( 1 + ( len C115 ) ) by L254 , FINSEQ_1:22;
L256: ( len D61 ) >= ( 1 + 1 ) by L255 , L252 , XREAL_1:7;
L257: 1 < ( len D61 ) by L256 , XXREAL_0:2;
L258: (( ( Sum ( Prefix (D61 , 1) ) ) + ( 2 * ( 1 - 1 ) ) ) = C114 & ( ( Sum ( Prefix (D61 , ( 1 + 1 )) ) ) + ( 2 * 1 ) ) = ( ( C114 + ( C115 /. 1 ) ) + 2 )) by L252 , L200;
thus L259: thesis by L258 , L253 , L257 , L164;
end;
theorem
L260: (for B74 being TuringStr holds (for B75 being (Tape of B74) holds (for B76 being (Element of ( NAT )) holds (for B77 being (FinSequence of ( NAT )) holds ((( len B77 ) >= 3 & B75 storeData ( <* B76 *> ^ B77 )) implies (B75 is_1_between B76 , ( ( B76 + ( B77 /. 1 ) ) + 2 ) & B75 is_1_between ( ( B76 + ( B77 /. 1 ) ) + 2 ) , ( ( ( B76 + ( B77 /. 1 ) ) + ( B77 /. 2 ) ) + 4 ) & B75 is_1_between ( ( ( B76 + ( B77 /. 1 ) ) + ( B77 /. 2 ) ) + 4 ) , ( ( ( ( B76 + ( B77 /. 1 ) ) + ( B77 /. 2 ) ) + ( B77 /. 3 ) ) + 6 )))))))
proof
let C116 being TuringStr;
let C117 being (Tape of C116);
let C118 being (Element of ( NAT ));
let C119 being (FinSequence of ( NAT ));
set D62 = ( <* C118 *> ^ C119 );
assume that
L261: ( len C119 ) >= 3
and
L262: C117 storeData D62;
thus L263: C117 is_1_between C118 , ( ( C118 + ( C119 /. 1 ) ) + 2 ) by L261 , L262 , L251 , XXREAL_0:2;
L264: ( len <* C118 *> ) = 1 by FINSEQ_1:39;
L265: ( len D62 ) = ( 1 + ( len C119 ) ) by L264 , FINSEQ_1:22;
L266: ( len D62 ) >= ( 3 + 1 ) by L265 , L261 , XREAL_1:7;
L267: 2 < ( len D62 ) by L266 , XXREAL_0:2;
L268: (( ( Sum ( Prefix (D62 , 2) ) ) + ( 2 * ( 2 - 1 ) ) ) = ( ( C118 + ( C119 /. 1 ) ) + 2 ) & ( ( Sum ( Prefix (D62 , ( 2 + 1 )) ) ) + ( 2 * 2 ) ) = ( ( ( C118 + ( C119 /. 1 ) ) + ( C119 /. 2 ) ) + 4 )) by L261 , L217;
thus L269: C117 is_1_between ( ( C118 + ( C119 /. 1 ) ) + 2 ) , ( ( ( C118 + ( C119 /. 1 ) ) + ( C119 /. 2 ) ) + 4 ) by L268 , L262 , L267 , L164;
L270: 3 < ( len D62 ) by L266 , XXREAL_0:2;
L271: (( ( Sum ( Prefix (D62 , 3) ) ) + ( 2 * ( 3 - 1 ) ) ) = ( ( ( C118 + ( C119 /. 1 ) ) + ( C119 /. 2 ) ) + 4 ) & ( ( Sum ( Prefix (D62 , ( 3 + 1 )) ) ) + ( 2 * 3 ) ) = ( ( ( ( C118 + ( C119 /. 1 ) ) + ( C119 /. 2 ) ) + ( C119 /. 3 ) ) + 6 )) by L261 , L217;
thus L272: thesis by L271 , L262 , L270 , L164;
end;
begin
definition
func SumTuring ->  strict TuringStr means 
:L273: ((the Symbols of it) = { ( 0 ) , 1 } & (the FStates of it) = ( SegM 5 ) & (the Tran of it) = ( Sum_Tran ) & (the InitS of it) = ( 0 ) & (the AcceptS of it) = 5);
existence
proof
set D63 = ( SegM 5 );
reconsider D64 = ( 0 ) , D65 = 5 as (Element of D63) by L26;
set D66 = { ( 0 ) , 1 };
take TuringStr (# D66 , D63 , ( Sum_Tran ) , D64 , D65 #);
thus L274: thesis;
end;
uniqueness;
end;
L276: (for B78 being (Element of ( NAT )) holds (B78 <= 5 implies B78 is (State of ( SumTuring ))))
proof
let C120 being (Element of ( NAT ));
assume L277: C120 <= 5;
L278: (the FStates of ( SumTuring )) = ( SegM 5 ) by L273;
thus L279: thesis by L278 , L277 , L26;
end;
theorem
L280: (for B79 being TuringStr holds (for B80 being (Tape of B79) holds (for B81 being Integer holds (for B82 being (Symbol of B79) holds (( B80 . B81 ) = B82 implies ( Tape-Chg (B80 , B81 , B82) ) = B80)))))
proof
let C121 being TuringStr;
let C122 being (Tape of C121);
let C123 being Integer;
let C124 being (Symbol of C121);
L281: (ex B83 being Function st (C122 = B83 & ( dom B83 ) = ( INT ) & ( rng B83 ) c= (the Symbols of C121))) by FUNCT_2:def 2;
L282: C123 in ( dom C122 ) by L281 , INT_1:def 2;
assume L283: ( C122 . C123 ) = C124;
thus L284: thesis by L283 , L282 , FUNCT_7:96;
end;
L285: (( 0 ) in (the Symbols of ( SumTuring )) & 1 in (the Symbols of ( SumTuring )))
proof
L286: (( 0 ) in { ( 0 ) , 1 } & 1 in { ( 0 ) , 1 }) by TARSKI:def 2;
thus L287: thesis by L286 , L273;
end;
theorem
L288: (for B84 being TuringStr holds (for B85 being (All-State of B84) holds (for B86 , B87 , B88 being set holds ((B85 = [ B86 , B87 , B88 ] & B86 <> (the AcceptS of B84)) implies ( Following B85 ) = [ ( ( TRAN B85 ) `1_3 ) , ( ( Head B85 ) + ( offset ( TRAN B85 ) ) ) , ( Tape-Chg (( B85 `3_3 ) , ( Head B85 ) , ( ( TRAN B85 ) `2_3 )) ) ]))))
proof
let C125 being TuringStr;
let C126 being (All-State of C125);
let C127 , C128 , C129 being set;
assume that
L289: C126 = [ C127 , C128 , C129 ]
and
L290: C127 <> (the AcceptS of C125);
L291: ( C126 `1_3 ) = C127 by L289 , MCART_1:64;
thus L292: thesis by L291 , L290 , L78;
end;
L293: (for B89 being (All-State of ( SumTuring )) holds (for B90 , B91 , B92 being set holds ((B89 = [ B90 , B91 , B92 ] & B90 <> 5) implies ( Following B89 ) = [ ( ( TRAN B89 ) `1_3 ) , ( ( Head B89 ) + ( offset ( TRAN B89 ) ) ) , ( Tape-Chg (( B89 `3_3 ) , ( Head B89 ) , ( ( TRAN B89 ) `2_3 )) ) ])))
proof
let C130 being (All-State of ( SumTuring ));
let C131 , C132 , C133 being set;
assume L294: (C130 = [ C131 , C132 , C133 ] & C131 <> 5);
L295: 5 = (the AcceptS of ( SumTuring )) by L273;
thus L296: thesis by L295 , L294 , L288;
end;
theorem
L297: (for B93 being TuringStr holds (for B94 being (Tape of B93) holds (for B95 being Integer holds (for B96 being (Symbol of B93) holds (for B97 being set holds (( ( Tape-Chg (B94 , B95 , B96) ) . B95 ) = B96 & (B97 <> B95 implies ( ( Tape-Chg (B94 , B95 , B96) ) . B97 ) = ( B94 . B97 ))))))))
proof
let C134 being TuringStr;
let C135 being (Tape of C134);
let C136 being Integer;
let C137 being (Symbol of C134);
let C138 being set;
set D67 = ( Tape-Chg (C135 , C136 , C137) );
set D68 = ( C136 .--> C137 );
thus L298: ( D67 . C136 ) = C137 by FUNCT_7:94;
L299: ( dom D68 ) = { C136 } by FUNCOP_1:13;
assume L300: C138 <> C136;
L301: (not C138 in ( dom D68 )) by L300 , L299 , TARSKI:def 1;
thus L302: thesis by L301 , FUNCT_4:11;
end;
L303: (for B98 being TuringStr holds (for B99 being (All-State of B98) holds (for B100 being (State of B98) holds (for B101 being (Element of ( INT )) holds (for B102 being (Tape of B98) holds (for B103 , B104 being (Element of ( NAT )) holds ((B104 = B101 & 1 is (Symbol of B98) & B99 = [ B100 , B101 , B102 ] & ( (the Tran of B98) . [ B100 , 1 ] ) = [ B100 , 1 , 1 ] & B100 <> (the AcceptS of B98) & (for B105 being Integer holds ((B104 <= B105 & B105 < ( B104 + B103 )) implies ( B102 . B105 ) = 1))) implies ( ( Computation B99 ) . B103 ) = [ B100 , ( B104 + B103 ) , B102 ])))))))
proof
let C139 being TuringStr;
let C140 being (All-State of C139);
let C141 being (State of C139);
let C142 being (Element of ( INT ));
let C143 being (Tape of C139);
let C144 , C145 being (Element of ( NAT ));
assume that
L304: C145 = C142
and
L305: 1 is (Symbol of C139)
and
L306: C140 = [ C141 , C142 , C143 ]
and
L307: ( (the Tran of C139) . [ C141 , 1 ] ) = [ C141 , 1 , 1 ]
and
L308: C141 <> (the AcceptS of C139)
and
L309: (for B106 being Integer holds ((C145 <= B106 & B106 < ( C145 + C144 )) implies ( C143 . B106 ) = 1));
defpred S4[ (Element of ( NAT )) ] means ($1 <= C144 implies ( ( Computation C140 ) . $1 ) = [ C141 , ( C145 + $1 ) , C143 ]);
L310: (for B107 being (Element of ( NAT )) holds (S4[ B107 ] implies S4[ ( B107 + 1 ) ]))
proof
let C146 being (Element of ( NAT ));
assume L311: S4[ C146 ];
L312:
now
reconsider D69 = 1 as (Symbol of C139) by L305;
set D70 = ( C145 + C146 );
reconsider D71 = ( C145 + C146 ) as (Element of ( INT )) by INT_1:def 2;
set D72 = [ C141 , D71 , C143 ];
reconsider D73 = ( D72 `3_3 ) as (Tape of C139);
assume L313: ( C146 + 1 ) <= C144;
L314: C146 < C144 by L313 , NAT_1:13;
L315: D70 < ( C145 + C144 ) by L314 , XREAL_1:8;
L316: ( C143 . D71 ) = 1 by L315 , L309 , NAT_1:11;
L317: ( TRAN D72 ) = ( (the Tran of C139) . [ C141 , ( D73 . ( Head D72 ) ) ] )
.= ( (the Tran of C139) . [ C141 , ( C143 . ( Head D72 ) ) ] )
.= [ C141 , 1 , 1 ] by L307 , L316;
L318: ( offset ( TRAN D72 ) ) = 1 by L317 , MCART_1:64;
L319: ( Tape-Chg (( D72 `3_3 ) , ( Head D72 ) , ( ( TRAN D72 ) `2_3 )) ) = ( Tape-Chg (C143 , ( Head D72 ) , ( ( TRAN D72 ) `2_3 )) )
.= ( Tape-Chg (C143 , D70 , ( ( TRAN D72 ) `2_3 )) )
.= ( Tape-Chg (C143 , D70 , D69) ) by L317 , MCART_1:64
.= C143 by L316 , L280;
thus L320: ( ( Computation C140 ) . ( C146 + 1 ) ) = ( Following D72 ) by L311 , L313 , L82 , NAT_1:13
.= [ ( ( TRAN D72 ) `1_3 ) , ( ( Head D72 ) + ( offset ( TRAN D72 ) ) ) , C143 ] by L308 , L319 , L288
.= [ C141 , ( ( Head D72 ) + ( offset ( TRAN D72 ) ) ) , C143 ] by L317 , MCART_1:64
.= [ C141 , ( D70 + 1 ) , C143 ] by L318
.= [ C141 , ( C145 + ( C146 + 1 ) ) , C143 ];
end;
thus L321: thesis by L312;
end;
L322: S4[ ( 0 ) ] by L304 , L306 , L82;
L323: (for R4 being (Element of ( NAT )) holds S4[ R4 ]) from NAT_1:sch 1(L322 , L310);
thus L324: thesis by L323;
end;
theorem
L325: (for B108 being (All-State of ( SumTuring )) holds (for B109 being (Tape of ( SumTuring )) holds (for B110 , B111 , B112 being (Element of ( NAT )) holds ((B108 = [ ( 0 ) , B110 , B109 ] & B109 storeData <* B110 , B111 , B112 *>) implies (B108 is  Accept-Halt & ( ( Result B108 ) `2_3 ) = ( 1 + B110 ) & ( ( Result B108 ) `3_3 ) storeData <* ( 1 + B110 ) , ( B111 + B112 ) *>)))))
proof
reconsider D74 = ( 0 ) as (Symbol of ( SumTuring )) by L285;
let C147 being (All-State of ( SumTuring ));
let C148 being (Tape of ( SumTuring ));
let C149 , C150 , C151 being (Element of ( NAT ));
assume that
L326: C147 = [ ( 0 ) , C149 , C148 ]
and
L327: C148 storeData <* C149 , C150 , C151 *>;
L328: ( C148 . ( ( C149 + C150 ) + 2 ) ) = ( 0 ) by L327 , L195;
set D75 = ( ( ( ( C149 + C150 ) + C151 ) + 4 ) - 1 );
reconsider D76 = ( C149 + 1 ) as (Element of ( INT )) by INT_1:def 2;
L329: C149 < D76 by XREAL_1:29;
set D77 = ( Tape-Chg (C148 , D76 , D74) );
L330: ( ( ( C149 + 1 ) + 1 ) + C150 ) = ( ( C149 + C150 ) + 2 );
reconsider D78 = 4 as (State of ( SumTuring )) by L276;
reconsider D79 = D75 as (Element of ( INT )) by INT_1:def 2;
set D80 = ( D75 - 1 );
reconsider D81 = D80 as (Element of ( INT )) by INT_1:def 2;
set D82 = ( ( C150 + C151 ) + 1 );
set D83 = ( ( Computation C147 ) . ( ( ( ( ( ( C150 + 1 ) + ( C151 + 1 ) ) + 1 ) + 1 ) + ( 1 + 1 ) ) + ( D82 + 1 ) ) );
reconsider D84 = 2 as (State of ( SumTuring )) by L276;
reconsider D85 = ( D76 + 1 ) as (Element of ( INT )) by INT_1:def 2;
reconsider D86 = ( ( D76 + 1 ) + C150 ) as (Element of ( INT )) by INT_1:def 2;
set D87 = ( ( ( ( C149 + 1 ) + 1 ) + C150 ) + 1 );
reconsider D88 = D87 as (Element of ( INT )) by INT_1:def 2;
L331: ( D80 - 1 ) = ( C149 + D82 );
reconsider D89 = 1 as (Symbol of ( SumTuring )) by L285;
set D90 = ( Tape-Chg (D77 , D86 , D89) );
L332: (( D76 + 1 ) <= ( ( ( C149 + 1 ) + 1 ) + C150 ) & D76 < ( D76 + 1 )) by NAT_1:11 , XREAL_1:29;
set D91 = ( ( ( C149 + C150 ) + C151 ) + 4 );
reconsider D92 = ( 0 ) as (State of ( SumTuring )) by L276;
set D93 = [ D92 , D76 , C148 ];
L333: ( C148 . C149 ) = ( 0 ) by L327 , L195;
L334: C149 <= ( C149 + C150 ) by NAT_1:11;
L335: ( C149 + 2 ) <= ( ( C149 + C150 ) + 2 ) by L334 , XREAL_1:7;
L336: ( C148 . ( ( ( C149 + C150 ) + C151 ) + 4 ) ) = ( 0 ) by L327 , L195;
L337: C149 <= ( C149 + ( C150 + C151 ) ) by NAT_1:11;
L338: ( C149 + 4 ) <= ( ( ( C149 + C150 ) + C151 ) + 4 ) by L337 , XREAL_1:7;
L339: (D76 < ( C149 + 3 ) & ( ( C149 + 4 ) - 1 ) <= D75) by L338 , XREAL_1:8 , XREAL_1:9;
L340: D76 < ( C149 + 2 ) by XREAL_1:8;
L341: D76 < ( ( C149 + C150 ) + 2 ) by L340 , L335 , XXREAL_0:2;
L342: ( C148 . C149 ) = ( 0 ) by L327 , L195;
L343: (( D77 . C149 ) = ( 0 ) & ( D77 . ( ( C149 + C150 ) + 2 ) ) = ( 0 ) & ( D77 . ( ( ( C149 + C150 ) + C151 ) + 4 ) ) = ( 0 ) & (for B113 being Integer holds ((D76 < B113 & B113 < ( ( ( C149 + 1 ) + 1 ) + C150 )) implies ( D77 . B113 ) = 1)) & (for B114 being Integer holds ((( ( C149 + C150 ) + 2 ) < B114 & B114 < ( ( ( C149 + C150 ) + C151 ) + 4 )) implies ( D77 . B114 ) = 1)))
proof
thus L344: ( D77 . C149 ) = ( 0 ) by L342 , L329 , L297;
thus L345: ( D77 . ( ( C149 + C150 ) + 2 ) ) = ( 0 ) by L328 , L335 , L340 , L297;
L346: D76 < ( C149 + 4 ) by XREAL_1:8;
thus L347: ( D77 . ( ( ( C149 + C150 ) + C151 ) + 4 ) ) = ( 0 ) by L346 , L336 , L338 , L297;
thus L348:now
let C152 being Integer;
assume that
L349: D76 < C152
and
L350: C152 < ( ( ( C149 + 1 ) + 1 ) + C150 );
L351: C149 < C152 by L329 , L349 , XXREAL_0:2;
thus L352: ( D77 . C152 ) = ( C148 . C152 ) by L349 , L297
.= 1 by L327 , L330 , L350 , L351 , L195;
end;
thus L353:now
let C153 being Integer;
assume that
L354: ( ( C149 + C150 ) + 2 ) < C153
and
L355: C153 < ( ( ( C149 + C150 ) + C151 ) + 4 );
thus L356: ( D77 . C153 ) = ( C148 . C153 ) by L341 , L354 , L297
.= 1 by L327 , L354 , L355 , L195;
end;
end;
L354: (for B115 being Integer holds ((( ( C149 + 1 ) + 1 ) <= B115 & B115 < ( ( ( C149 + 1 ) + 1 ) + C150 )) implies ( D77 . B115 ) = 1))
proof
let C154 being Integer;
assume that
L355: ( ( C149 + 1 ) + 1 ) <= C154
and
L356: C154 < ( ( ( C149 + 1 ) + 1 ) + C150 );
L357: D76 < ( D76 + 1 ) by XREAL_1:29;
L358: D76 < C154 by L357 , L355 , XXREAL_0:2;
thus L359: thesis by L358 , L343 , L356;
end;
set D94 = ( Tape-Chg (D90 , D75 , D74) );
L360: ( D77 . D76 ) = ( 0 ) by L297;
L361: (( D90 . D76 ) = ( 0 ) & ( D90 . ( ( ( C149 + C150 ) + C151 ) + 4 ) ) = ( 0 ) & (for B116 being Integer holds ((D76 < B116 & B116 < ( ( ( C149 + C150 ) + C151 ) + 4 )) implies ( D90 . B116 ) = 1)))
proof
thus L362: ( D90 . D76 ) = ( 0 ) by L360 , L332 , L297;
L363: ( C149 + C150 ) <= ( ( C149 + C150 ) + C151 ) by NAT_1:11;
L364: ( ( ( C149 + 1 ) + 1 ) + C150 ) <= ( ( ( C149 + C150 ) + C151 ) + 2 ) by L363 , L330 , XREAL_1:7;
L365: ( ( ( C149 + C150 ) + C151 ) + 2 ) < ( ( ( C149 + C150 ) + C151 ) + 4 ) by XREAL_1:8;
thus L366: ( D90 . ( ( ( C149 + C150 ) + C151 ) + 4 ) ) = ( 0 ) by L365 , L343 , L364 , L297;
thus L367:now
let C155 being Integer;
assume that
L368: D76 < C155
and
L369: C155 < ( ( ( C149 + C150 ) + C151 ) + 4 );
per cases  by XXREAL_0:1;
suppose L370: C155 < ( ( ( C149 + 1 ) + 1 ) + C150 );

thus L371: ( D90 . C155 ) = ( D77 . C155 ) by L370 , L297
.= 1 by L343 , L368 , L370;
end;
suppose L372: C155 = ( ( ( C149 + 1 ) + 1 ) + C150 );

thus L373: ( D90 . C155 ) = 1 by L372 , L297;
end;
suppose L374: C155 > ( ( ( C149 + 1 ) + 1 ) + C150 );

thus L375: ( D90 . C155 ) = ( D77 . C155 ) by L374 , L297
.= 1 by L343 , L369 , L374;
end;
end;
end;
L368: (( D94 . D76 ) = ( 0 ) & ( D94 . D75 ) = ( 0 ) & (for B117 being Integer holds ((D76 < B117 & B117 < D75) implies ( D94 . B117 ) = 1)))
proof
thus L369: ( D94 . D76 ) = ( 0 ) by L361 , L339 , L297;
thus L370: ( D94 . D75 ) = ( 0 ) by L297;
thus L371:now
let C156 being Integer;
assume that
L372: D76 < C156
and
L373: C156 < D75;
L374: C156 < ( ( ( C149 + C150 ) + C151 ) + 4 ) by L373 , XREAL_1:146 , XXREAL_0:2;
thus L375: ( D94 . C156 ) = ( D90 . C156 ) by L373 , L297
.= 1 by L361 , L372 , L374;
end;
end;
L372: D94 is_1_between D76 , ( ( D76 + ( C150 + C151 ) ) + 2 ) by L368 , L162;
reconsider D95 = 3 as (State of ( SumTuring )) by L276;
set D96 = [ D84 , D88 , D90 ];
reconsider D97 = D91 as (Element of ( INT )) by INT_1:def 2;
set D98 = [ D84 , D97 , D90 ];
set D99 = [ D95 , D79 , D90 ];
reconsider D100 = 1 as (State of ( SumTuring )) by L276;
set D101 = [ D100 , D85 , D77 ];
set D102 = [ D100 , D86 , D77 ];
reconsider D103 = ( D102 `3_3 ) as (Tape of ( SumTuring ));
L373: ( TRAN D102 ) = ( ( Sum_Tran ) . [ ( D102 `1_3 ) , ( D103 . ( Head D102 ) ) ] ) by L273
.= ( ( Sum_Tran ) . [ D100 , ( D103 . ( Head D102 ) ) ] )
.= ( ( Sum_Tran ) . [ D100 , ( D77 . ( Head D102 ) ) ] )
.= [ 2 , 1 , 1 ] by L343 , L152;
L374: ( offset ( TRAN D102 ) ) = 1 by L373 , MCART_1:64;
reconsider D104 = ( D98 `3_3 ) as (Tape of ( SumTuring ));
L375: ( TRAN D98 ) = ( ( Sum_Tran ) . [ ( D98 `1_3 ) , ( D104 . ( Head D98 ) ) ] ) by L273
.= ( ( Sum_Tran ) . [ D84 , ( D104 . ( Head D98 ) ) ] )
.= ( ( Sum_Tran ) . [ D84 , ( D90 . ( Head D98 ) ) ] )
.= [ 3 , ( 0 ) , ( - 1 ) ] by L361 , L152;
L376: ( offset ( TRAN D98 ) ) = ( - 1 ) by L375 , MCART_1:64;
L377: ( Tape-Chg (( D98 `3_3 ) , ( Head D98 ) , ( ( TRAN D98 ) `2_3 )) ) = ( Tape-Chg (D90 , ( Head D98 ) , ( ( TRAN D98 ) `2_3 )) )
.= ( Tape-Chg (D90 , D91 , ( ( TRAN D98 ) `2_3 )) )
.= ( Tape-Chg (D90 , D91 , D74) ) by L375 , MCART_1:64
.= D90 by L361 , L280;
L378: ( Following D98 ) = [ ( ( TRAN D98 ) `1_3 ) , ( ( Head D98 ) + ( offset ( TRAN D98 ) ) ) , D90 ] by L377 , L293
.= [ 3 , ( ( Head D98 ) + ( offset ( TRAN D98 ) ) ) , D90 ] by L375 , MCART_1:64
.= [ 3 , D75 , D90 ] by L376;
L379: ( Tape-Chg (( D102 `3_3 ) , ( Head D102 ) , ( ( TRAN D102 ) `2_3 )) ) = ( Tape-Chg (D77 , ( Head D102 ) , ( ( TRAN D102 ) `2_3 )) )
.= ( Tape-Chg (D77 , D86 , ( ( TRAN D102 ) `2_3 )) )
.= D90 by L373 , MCART_1:64;
L380: ( Following D102 ) = [ ( ( TRAN D102 ) `1_3 ) , ( ( Head D102 ) + ( offset ( TRAN D102 ) ) ) , D90 ] by L379 , L293
.= [ 2 , ( ( Head D102 ) + ( offset ( TRAN D102 ) ) ) , D90 ] by L373 , MCART_1:64
.= D96 by L374;
reconsider D105 = ( C147 `3_3 ) as (Tape of ( SumTuring ));
L381: ( TRAN C147 ) = ( ( Sum_Tran ) . [ ( C147 `1_3 ) , ( D105 . ( Head C147 ) ) ] ) by L273
.= ( ( Sum_Tran ) . [ ( 0 ) , ( D105 . ( Head C147 ) ) ] ) by L326 , MCART_1:64
.= ( ( Sum_Tran ) . [ ( 0 ) , ( C148 . ( Head C147 ) ) ] ) by L326 , MCART_1:64
.= ( ( Sum_Tran ) . [ ( 0 ) , ( C148 . C149 ) ] ) by L326 , MCART_1:64
.= [ ( 0 ) , ( 0 ) , 1 ] by L327 , L152 , L195;
L382: ( offset ( TRAN C147 ) ) = 1 by L381 , MCART_1:64;
L383: D76 < ( ( D76 + 1 ) + C150 ) by L332 , XXREAL_0:2;
L384: (for B118 being Integer holds ((D87 <= B118 & B118 < ( D87 + ( C151 + 1 ) )) implies ( D90 . B118 ) = 1))
proof
let C157 being Integer;
assume that
L385: D87 <= C157
and
L386: C157 < ( D87 + ( C151 + 1 ) );
L387: D86 < D87 by XREAL_1:29;
L388: D76 < D87 by L387 , L383 , XXREAL_0:2;
L389: D76 < C157 by L388 , L385 , XXREAL_0:2;
thus L390: thesis by L389 , L361 , L386;
end;
set D106 = [ D78 , D76 , D94 ];
set D107 = [ D78 , D81 , D94 ];
defpred S5[ (Element of ( NAT )) ] means (( C149 + $1 ) < D80 implies ( ( Computation D107 ) . $1 ) = [ 4 , ( D80 - $1 ) , D94 ]);
L391: (( (the Tran of ( SumTuring )) . [ D84 , 1 ] ) = [ D84 , 1 , 1 ] & D84 <> (the AcceptS of ( SumTuring ))) by L273 , L152;
L392: ( ( Computation D96 ) . ( C151 + 1 ) ) = [ 2 , ( ( ( C149 + C150 ) + C151 ) + 4 ) , D90 ] by L391 , L384 , L303;
L393: D76 < D75 by L339 , XXREAL_0:2;
L394: ( D90 . D75 ) = 1 by L393 , L361 , XREAL_1:146;
reconsider D108 = ( D99 `3_3 ) as (Tape of ( SumTuring ));
L395: ( TRAN D99 ) = ( ( Sum_Tran ) . [ ( D99 `1_3 ) , ( D108 . ( Head D99 ) ) ] ) by L273
.= ( ( Sum_Tran ) . [ D95 , ( D108 . ( Head D99 ) ) ] )
.= ( ( Sum_Tran ) . [ D95 , ( D90 . ( Head D99 ) ) ] )
.= [ 4 , ( 0 ) , ( - 1 ) ] by L394 , L152;
L396: ( offset ( TRAN D99 ) ) = ( - 1 ) by L395 , MCART_1:64;
L397: (for B119 being (Element of ( NAT )) holds (S5[ B119 ] implies S5[ ( B119 + 1 ) ]))
proof
let C158 being (Element of ( NAT ));
assume L398: S5[ C158 ];
L399:
now
reconsider D109 = ( D80 - C158 ) as (Element of ( INT )) by INT_1:def 2;
set D110 = ( D80 - C158 );
set D111 = [ D78 , D109 , D94 ];
reconsider D112 = ( D111 `3_3 ) as (Tape of ( SumTuring ));
assume L400: ( C149 + ( C158 + 1 ) ) < D80;
L401: ( D76 + C158 ) < ( D80 + ( 0 ) ) by L400;
L402: ( D76 - ( 0 ) ) < ( D80 - C158 ) by L401 , XREAL_1:21;
L403: D76 >= ( 0 ) by NAT_1:2;
reconsider D113 = ( D80 - C158 ) as (Element of ( NAT )) by L403 , L402 , INT_1:3 , XXREAL_0:2;
L404: D80 <= ( D80 + C158 ) by INT_1:6;
L405: ( D80 - C158 ) <= D80 by L404 , XREAL_1:20;
L406: ( D80 - C158 ) < D75 by L405 , XREAL_1:146 , XXREAL_0:2;
L407: ( D94 . D113 ) = 1 by L406 , L368 , L402;
L408: ( TRAN D111 ) = ( ( Sum_Tran ) . [ ( D111 `1_3 ) , ( D112 . ( Head D111 ) ) ] ) by L273
.= ( ( Sum_Tran ) . [ D78 , ( D112 . ( Head D111 ) ) ] )
.= ( ( Sum_Tran ) . [ D78 , ( D94 . ( Head D111 ) ) ] )
.= [ 4 , 1 , ( - 1 ) ] by L407 , L152;
L409: ( offset ( TRAN D111 ) ) = ( - 1 ) by L408 , MCART_1:64;
L410: ( Tape-Chg (( D111 `3_3 ) , ( Head D111 ) , ( ( TRAN D111 ) `2_3 )) ) = ( Tape-Chg (D94 , ( Head D111 ) , ( ( TRAN D111 ) `2_3 )) )
.= ( Tape-Chg (D94 , D110 , ( ( TRAN D111 ) `2_3 )) )
.= ( Tape-Chg (D94 , D110 , D89) ) by L408 , MCART_1:64
.= D94 by L407 , L280;
L411: ( C149 + C158 ) < ( ( C149 + C158 ) + 1 ) by XREAL_1:29;
thus L412: ( ( Computation D107 ) . ( C158 + 1 ) ) = ( Following D111 ) by L411 , L398 , L400 , L82 , XXREAL_0:2
.= [ ( ( TRAN D111 ) `1_3 ) , ( ( Head D111 ) + ( offset ( TRAN D111 ) ) ) , D94 ] by L410 , L293
.= [ 4 , ( ( Head D111 ) + ( offset ( TRAN D111 ) ) ) , D94 ] by L408 , MCART_1:64
.= [ 4 , ( ( D80 - C158 ) + ( - 1 ) ) , D94 ] by L409
.= [ 4 , ( D80 - ( C158 + 1 ) ) , D94 ];
end;
thus L413: thesis by L399;
end;
L414: S5[ ( 0 ) ] by L82;
L415: (for B120 being (Element of ( NAT )) holds S5[ B120 ]) from NAT_1:sch 1(L414 , L397);
L416: ( ( Computation D107 ) . D82 ) = [ 4 , ( D80 - D82 ) , D94 ] by L415 , L331 , XREAL_1:146
.= D106;
reconsider D114 = ( D93 `3_3 ) as (Tape of ( SumTuring ));
L417: ( TRAN D93 ) = ( ( Sum_Tran ) . [ ( D93 `1_3 ) , ( D114 . ( Head D93 ) ) ] ) by L273
.= ( ( Sum_Tran ) . [ D92 , ( D114 . ( Head D93 ) ) ] )
.= ( ( Sum_Tran ) . [ D92 , ( C148 . ( Head D93 ) ) ] )
.= ( ( Sum_Tran ) . [ ( 0 ) , ( C148 . D76 ) ] )
.= [ 1 , ( 0 ) , 1 ] by L327 , L329 , L341 , L152 , L195;
L418: ( offset ( TRAN D93 ) ) = 1 by L417 , MCART_1:64;
L419: ( Tape-Chg (( D99 `3_3 ) , ( Head D99 ) , ( ( TRAN D99 ) `2_3 )) ) = ( Tape-Chg (D90 , ( Head D99 ) , ( ( TRAN D99 ) `2_3 )) )
.= ( Tape-Chg (D90 , D75 , ( ( TRAN D99 ) `2_3 )) )
.= D94 by L395 , MCART_1:64;
L420: ( Following D99 ) = [ ( ( TRAN D99 ) `1_3 ) , ( ( Head D99 ) + ( offset ( TRAN D99 ) ) ) , D94 ] by L419 , L293
.= [ 4 , ( ( Head D99 ) + ( offset ( TRAN D99 ) ) ) , D94 ] by L395 , MCART_1:64
.= D107 by L396;
L421:
now
reconsider D115 = ( D106 `3_3 ) as (Tape of ( SumTuring ));
L422: ( TRAN D106 ) = ( ( Sum_Tran ) . [ ( D106 `1_3 ) , ( D115 . ( Head D106 ) ) ] ) by L273
.= ( ( Sum_Tran ) . [ 4 , ( D115 . ( Head D106 ) ) ] )
.= ( ( Sum_Tran ) . [ 4 , ( D94 . ( Head D106 ) ) ] )
.= [ 5 , ( 0 ) , ( 0 ) ] by L368 , L152;
L423: ( offset ( TRAN D106 ) ) = ( 0 ) by L422 , MCART_1:64;
L424: ( Tape-Chg (( D106 `3_3 ) , ( Head D106 ) , ( ( TRAN D106 ) `2_3 )) ) = ( Tape-Chg (D94 , ( Head D106 ) , ( ( TRAN D106 ) `2_3 )) )
.= ( Tape-Chg (D94 , D76 , ( ( TRAN D106 ) `2_3 )) )
.= ( Tape-Chg (D94 , D76 , D74) ) by L422 , MCART_1:64
.= D94 by L368 , L280;
thus L425: ( Following D106 ) = [ ( ( TRAN D106 ) `1_3 ) , ( ( Head D106 ) + ( offset ( TRAN D106 ) ) ) , D94 ] by L424 , L293
.= [ 5 , ( ( Head D106 ) + ( offset ( TRAN D106 ) ) ) , D94 ] by L422 , MCART_1:64
.= [ 5 , ( D76 + ( 0 ) ) , D94 ] by L423;
end;
L426: ( Tape-Chg (( D93 `3_3 ) , ( Head D93 ) , ( ( TRAN D93 ) `2_3 )) ) = ( Tape-Chg (C148 , ( Head D93 ) , ( ( TRAN D93 ) `2_3 )) )
.= ( Tape-Chg (C148 , D76 , ( ( TRAN D93 ) `2_3 )) )
.= D77 by L417 , MCART_1:64;
L427: ( Following D93 ) = [ ( ( TRAN D93 ) `1_3 ) , ( ( Head D93 ) + ( offset ( TRAN D93 ) ) ) , D77 ] by L426 , L293
.= [ 1 , ( ( Head D93 ) + ( offset ( TRAN D93 ) ) ) , D77 ] by L417 , MCART_1:64
.= D101 by L418;
L428: ( Tape-Chg (( C147 `3_3 ) , ( Head C147 ) , ( ( TRAN C147 ) `2_3 )) ) = ( Tape-Chg (C148 , ( Head C147 ) , ( ( TRAN C147 ) `2_3 )) ) by L326 , MCART_1:64
.= ( Tape-Chg (C148 , C149 , ( ( TRAN C147 ) `2_3 )) ) by L326 , MCART_1:64
.= ( Tape-Chg (C148 , C149 , D74) ) by L381 , MCART_1:64
.= C148 by L333 , L280;
L429: ( Following C147 ) = [ ( ( TRAN C147 ) `1_3 ) , ( ( Head C147 ) + ( offset ( TRAN C147 ) ) ) , C148 ] by L428 , L326 , L293
.= [ ( 0 ) , ( ( Head C147 ) + ( offset ( TRAN C147 ) ) ) , C148 ] by L381 , MCART_1:64
.= D93 by L326 , L382 , MCART_1:64;
L430: ( ( Computation C147 ) . ( 1 + 1 ) ) = ( Following ( ( Computation C147 ) . 1 ) ) by L82
.= D101 by L429 , L427 , L98;
L431: ( ( Computation C147 ) . ( ( ( ( ( C150 + 1 ) + ( C151 + 1 ) ) + 1 ) + 1 ) + ( 1 + 1 ) ) ) = ( ( Computation D101 ) . ( ( ( ( C150 + 1 ) + ( C151 + 1 ) ) + 1 ) + 1 ) ) by L430 , L101;
L432: ( ( Computation C147 ) . ( ( ( ( ( C150 + 1 ) + ( C151 + 1 ) ) + 1 ) + 1 ) + ( 1 + 1 ) ) ) = ( Following ( ( Computation D101 ) . ( ( ( C150 + 1 ) + ( C151 + 1 ) ) + 1 ) ) ) by L431 , L82
.= ( Following ( Following ( ( Computation D101 ) . ( ( C150 + 1 ) + ( C151 + 1 ) ) ) ) ) by L82
.= ( Following ( Following ( ( Computation ( ( Computation D101 ) . ( C150 + 1 ) ) ) . ( C151 + 1 ) ) ) ) by L101;
L433: D83 = ( ( Computation ( Following ( Following ( ( Computation ( ( Computation D101 ) . ( C150 + 1 ) ) ) . ( C151 + 1 ) ) ) ) ) . ( D82 + 1 ) ) by L432 , L101
.= ( ( Computation ( Following ( Following ( ( Computation ( Following ( ( Computation D101 ) . C150 ) ) ) . ( C151 + 1 ) ) ) ) ) . ( D82 + 1 ) ) by L82;
L434: (( (the Tran of ( SumTuring )) . [ D100 , 1 ] ) = [ D100 , 1 , 1 ] & D100 <> (the AcceptS of ( SumTuring ))) by L273 , L152;
L435: D83 = ( ( Computation ( Following D99 ) ) . ( D82 + 1 ) ) by L434 , L354 , L380 , L392 , L378 , L433 , L303;
L436: D83 = [ 5 , D76 , D94 ] by L435 , L420 , L416 , L421 , L82;
L437: ( D83 `1_3 ) = 5 by L436 , MCART_1:64
.= (the AcceptS of ( SumTuring )) by L273;
thus L438: C147 is  Accept-Halt by L437 , L124;
L439: ( Result C147 ) = D83 by L438 , L437 , L127;
thus L440: ( ( Result C147 ) `2_3 ) = ( 1 + C149 ) by L439 , L436 , MCART_1:64;
L441: ( ( Result C147 ) `3_3 ) = D94 by L436 , L439 , MCART_1:64;
thus L442: thesis by L441 , L372 , L171;
end;
definition
let C159 being TuringStr;
let C160 being Function;
pred C159 computes C160
means
:L443: (for B121 being (All-State of C159) holds (for B122 being (Tape of C159) holds (for B123 being (Element of ( NAT )) holds (for B124 being (FinSequence of ( NAT )) holds ((B124 in ( dom C160 ) & B121 = [ (the InitS of C159) , B123 , B122 ] & B122 storeData ( <* B123 *> ^ B124 )) implies (B121 is  Accept-Halt & (ex B125 , B126 being (Element of ( NAT )) st (( ( Result B121 ) `2_3 ) = B125 & B126 = ( C160 . B124 ) & ( ( Result B121 ) `3_3 ) storeData ( <* B125 *> ^ <* B126 *> )))))))))
;end;
theorem
L445: ( dom ( [+] ) ) c= ( 2 -tuples_on ( NAT ) )
proof
L446: ( arity ( 1 proj 1 ) ) = 1 by COMPUT_1:37;
L447: ( dom ( [+] ) ) c= ( ( 1 + 1 ) -tuples_on ( NAT ) ) by L446 , COMPUT_1:56;
thus L448: thesis by L447;
end;
theorem
L449: ( SumTuring ) computes ( [+] )
proof
L450:
now
let C161 being (All-State of ( SumTuring ));
let C162 being (Tape of ( SumTuring ));
let C163 being (Element of ( NAT ));
let C164 being (FinSequence of ( NAT ));
assume that
L451: C164 in ( dom ( [+] ) )
and
L452: C161 = [ (the InitS of ( SumTuring )) , C163 , C162 ]
and
L453: C162 storeData ( <* C163 *> ^ C164 );
L454: C164 is (Tuple of 2 , ( NAT )) by L451 , L445 , FINSEQ_2:131;
consider R2 being (Element of ( NAT )), R3 being (Element of ( NAT )) such that L455: C164 = <* R2 , R3 *> by L454 , FINSEQ_2:100;
L456: C161 = [ ( 0 ) , C163 , C162 ] by L452 , L273;
L457: ( <* C163 *> ^ C164 ) = <* C163 , R2 , R3 *> by L455 , FINSEQ_1:43;
thus L458: C161 is  Accept-Halt by L457 , L453 , L456 , L325;
take D116 = ( 1 + C163 );
take D117 = ( R2 + R3 );
L459: C162 storeData <* C163 , R2 , R3 *> by L453 , L455 , FINSEQ_1:43;
thus L460: ( ( Result C161 ) `2_3 ) = D116 by L459 , L456 , L325;
thus L461: D117 = ( ( [+] ) . C164 ) by L455 , COMPUT_1:85;
L462: ( ( Result C161 ) `3_3 ) storeData <* ( 1 + C163 ) , ( R2 + R3 ) *> by L453 , L456 , L457 , L325;
thus L463: ( ( Result C161 ) `3_3 ) storeData ( <* D116 *> ^ <* D117 *> ) by L462;
end;
thus L464: thesis by L450 , L443;
end;
begin
definition
func Succ_Tran -> (Function of [: ( SegM 4 ) , { ( 0 ) , 1 } :] , [: ( SegM 4 ) , { ( 0 ) , 1 } , { ( - 1 ) , ( 0 ) , 1 } :]) equals 
( ( ( ( ( ( ( ( id ([: ( SegM 4 ) , { ( 0 ) , 1 } :] , { ( - 1 ) , ( 0 ) , 1 } , ( 0 )) ) +* ( [ ( 0 ) , ( 0 ) ] .--> [ 1 , ( 0 ) , 1 ] ) ) +* ( [ 1 , 1 ] .--> [ 1 , 1 , 1 ] ) ) +* ( [ 1 , ( 0 ) ] .--> [ 2 , 1 , 1 ] ) ) +* ( [ 2 , ( 0 ) ] .--> [ 3 , ( 0 ) , ( - 1 ) ] ) ) +* ( [ 2 , 1 ] .--> [ 3 , ( 0 ) , ( - 1 ) ] ) ) +* ( [ 3 , 1 ] .--> [ 3 , 1 , ( - 1 ) ] ) ) +* ( [ 3 , ( 0 ) ] .--> [ 4 , ( 0 ) , ( 0 ) ] ) );
coherence
proof
reconsider D118 = ( 0 ) , D119 = 1 , D120 = 2 , D121 = 3 , D122 = 4 as (Element of ( SegM 4 )) by L26;
set D123 = [: ( SegM 4 ) , { ( 0 ) , 1 } :];
set D124 = { ( - 1 ) , ( 0 ) , 1 };
set D125 = [: ( SegM 4 ) , { ( 0 ) , 1 } , D124 :];
reconsider D126 = ( 0 ) , D127 = 1 as (Element of { ( 0 ) , 1 }) by TARSKI:def 2;
reconsider D128 = ( - 1 ) as (Element of D124) by ENUMSET1:def 1;
reconsider D129 = ( 0 ) , D130 = 1 as (Element of { ( - 1 ) , ( 0 ) , 1 }) by ENUMSET1:def 1;
L465: D125 = [: D123 , D124 :] by ZFMISC_1:def 3;
reconsider D131 = ( id (D123 , D124 , D129) ) as (Function of D123 , D125) by L465;
L466: ( ( ( ( ( ( ( ( id (D123 , D124 , ( 0 )) ) +* ( [ ( 0 ) , ( 0 ) ] .--> [ 1 , ( 0 ) , 1 ] ) ) +* ( [ 1 , 1 ] .--> [ 1 , 1 , 1 ] ) ) +* ( [ 1 , ( 0 ) ] .--> [ 2 , 1 , 1 ] ) ) +* ( [ 2 , ( 0 ) ] .--> [ 3 , ( 0 ) , ( - 1 ) ] ) ) +* ( [ 2 , 1 ] .--> [ 3 , ( 0 ) , ( - 1 ) ] ) ) +* ( [ 3 , 1 ] .--> [ 3 , 1 , ( - 1 ) ] ) ) +* ( [ 3 , ( 0 ) ] .--> [ 4 , ( 0 ) , ( 0 ) ] ) ) = ( ( ( ( ( ( ( D131 +* ( [ D118 , D126 ] .--> [ D119 , D126 , D130 ] ) ) +* ( [ D119 , D127 ] .--> [ D119 , D127 , D130 ] ) ) +* ( [ D119 , D126 ] .--> [ D120 , D127 , D130 ] ) ) +* ( [ D120 , D126 ] .--> [ D121 , D126 , D128 ] ) ) +* ( [ D120 , D127 ] .--> [ D121 , D126 , D128 ] ) ) +* ( [ D121 , D127 ] .--> [ D121 , D127 , D128 ] ) ) +* ( [ D121 , D126 ] .--> [ D122 , D126 , D129 ] ) );
thus L467: thesis by L466;
end;
end;
theorem
L469: (( ( Succ_Tran ) . [ ( 0 ) , ( 0 ) ] ) = [ 1 , ( 0 ) , 1 ] & ( ( Succ_Tran ) . [ 1 , 1 ] ) = [ 1 , 1 , 1 ] & ( ( Succ_Tran ) . [ 1 , ( 0 ) ] ) = [ 2 , 1 , 1 ] & ( ( Succ_Tran ) . [ 2 , ( 0 ) ] ) = [ 3 , ( 0 ) , ( - 1 ) ] & ( ( Succ_Tran ) . [ 2 , 1 ] ) = [ 3 , ( 0 ) , ( - 1 ) ] & ( ( Succ_Tran ) . [ 3 , 1 ] ) = [ 3 , 1 , ( - 1 ) ] & ( ( Succ_Tran ) . [ 3 , ( 0 ) ] ) = [ 4 , ( 0 ) , ( 0 ) ])
proof
set D132 = [ 1 , 1 ];
set D133 = [ ( 0 ) , ( 0 ) ];
set D134 = ( [ ( 0 ) , ( 0 ) ] .--> [ 1 , ( 0 ) , 1 ] );
set D135 = ( [ 1 , 1 ] .--> [ 1 , 1 , 1 ] );
set D136 = ( [ 1 , ( 0 ) ] .--> [ 2 , 1 , 1 ] );
set D137 = ( [ 2 , ( 0 ) ] .--> [ 3 , ( 0 ) , ( - 1 ) ] );
set D138 = ( [ 2 , 1 ] .--> [ 3 , ( 0 ) , ( - 1 ) ] );
set D139 = ( [ 3 , 1 ] .--> [ 3 , 1 , ( - 1 ) ] );
set D140 = ( id ([: ( SegM 4 ) , { ( 0 ) , 1 } :] , { ( - 1 ) , ( 0 ) , 1 } , ( 0 )) );
thus L470: ( ( Succ_Tran ) . D133 ) = ( ( ( ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) +* D137 ) +* D138 ) +* D139 ) . D133 ) by L32
.= ( ( ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) +* D137 ) +* D138 ) . D133 ) by L32
.= ( ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) +* D137 ) . D133 ) by L32
.= ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) . D133 ) by L32
.= ( ( ( D140 +* D134 ) +* D135 ) . D133 ) by L32
.= ( ( D140 +* D134 ) . D133 ) by L38
.= [ 1 , ( 0 ) , 1 ] by FUNCT_7:94;
thus L471: ( ( Succ_Tran ) . D132 ) = ( ( ( ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) +* D137 ) +* D138 ) +* D139 ) . D132 ) by L32
.= ( ( ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) +* D137 ) +* D138 ) . D132 ) by L32
.= ( ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) +* D137 ) . D132 ) by L32
.= ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) . D132 ) by L32
.= ( ( ( D140 +* D134 ) +* D135 ) . D132 ) by L38
.= [ 1 , 1 , 1 ] by FUNCT_7:94;
set D141 = [ 1 , ( 0 ) ];
thus L472: ( ( Succ_Tran ) . D141 ) = ( ( ( ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) +* D137 ) +* D138 ) +* D139 ) . D141 ) by L32
.= ( ( ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) +* D137 ) +* D138 ) . D141 ) by L32
.= ( ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) +* D137 ) . D141 ) by L32
.= ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) . D141 ) by L32
.= [ 2 , 1 , 1 ] by FUNCT_7:94;
set D142 = [ 2 , ( 0 ) ];
thus L473: ( ( Succ_Tran ) . D142 ) = ( ( ( ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) +* D137 ) +* D138 ) +* D139 ) . D142 ) by L32
.= ( ( ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) +* D137 ) +* D138 ) . D142 ) by L32
.= ( ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) +* D137 ) . D142 ) by L38
.= [ 3 , ( 0 ) , ( - 1 ) ] by FUNCT_7:94;
set D143 = [ 2 , 1 ];
thus L474: ( ( Succ_Tran ) . D143 ) = ( ( ( ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) +* D137 ) +* D138 ) +* D139 ) . D143 ) by L32
.= ( ( ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) +* D137 ) +* D138 ) . D143 ) by L32
.= [ 3 , ( 0 ) , ( - 1 ) ] by FUNCT_7:94;
set D144 = [ 3 , 1 ];
thus L475: ( ( Succ_Tran ) . D144 ) = ( ( ( ( ( ( ( D140 +* D134 ) +* D135 ) +* D136 ) +* D137 ) +* D138 ) +* D139 ) . D144 ) by L38
.= [ 3 , 1 , ( - 1 ) ] by FUNCT_7:94;
thus L476: thesis by FUNCT_7:94;
end;
definition
func SuccTuring ->  strict TuringStr means 
:L477: ((the Symbols of it) = { ( 0 ) , 1 } & (the FStates of it) = ( SegM 4 ) & (the Tran of it) = ( Succ_Tran ) & (the InitS of it) = ( 0 ) & (the AcceptS of it) = 4);
existence
proof
set D145 = ( SegM 4 );
reconsider D146 = ( 0 ) , D147 = 4 as (Element of D145) by L26;
set D148 = { ( 0 ) , 1 };
take TuringStr (# D148 , D145 , ( Succ_Tran ) , D146 , D147 #);
thus L478: thesis;
end;
uniqueness;
end;
L480: (for B127 being (Element of ( NAT )) holds (B127 <= 4 implies B127 is (State of ( SuccTuring ))))
proof
let C165 being (Element of ( NAT ));
assume L481: C165 <= 4;
L482: (the FStates of ( SuccTuring )) = ( SegM 4 ) by L477;
thus L483: thesis by L482 , L481 , L26;
end;
L484: (( 0 ) in (the Symbols of ( SuccTuring )) & 1 in (the Symbols of ( SuccTuring )))
proof
L485: (( 0 ) in { ( 0 ) , 1 } & 1 in { ( 0 ) , 1 }) by TARSKI:def 2;
thus L486: thesis by L485 , L477;
end;
L487: (for B128 being (All-State of ( SuccTuring )) holds (for B129 , B130 , B131 being set holds ((B128 = [ B129 , B130 , B131 ] & B129 <> 4) implies ( Following B128 ) = [ ( ( TRAN B128 ) `1_3 ) , ( ( Head B128 ) + ( offset ( TRAN B128 ) ) ) , ( Tape-Chg (( B128 `3_3 ) , ( Head B128 ) , ( ( TRAN B128 ) `2_3 )) ) ])))
proof
let C166 being (All-State of ( SuccTuring ));
let C167 , C168 , C169 being set;
assume L488: (C166 = [ C167 , C168 , C169 ] & C167 <> 4);
L489: 4 = (the AcceptS of ( SuccTuring )) by L477;
thus L490: thesis by L489 , L488 , L288;
end;
theorem
L491: (for B132 being (All-State of ( SuccTuring )) holds (for B133 being (Tape of ( SuccTuring )) holds (for B134 , B135 being (Element of ( NAT )) holds ((B132 = [ ( 0 ) , B134 , B133 ] & B133 storeData <* B134 , B135 *>) implies (B132 is  Accept-Halt & ( ( Result B132 ) `2_3 ) = B134 & ( ( Result B132 ) `3_3 ) storeData <* B134 , ( B135 + 1 ) *>)))))
proof
reconsider D149 = ( 0 ) as (Symbol of ( SuccTuring )) by L484;
let C170 being (All-State of ( SuccTuring ));
let C171 being (Tape of ( SuccTuring ));
let C172 , C173 being (Element of ( NAT ));
assume that
L492: C170 = [ ( 0 ) , C172 , C171 ]
and
L493: C171 storeData <* C172 , C173 *>;
L494: ( C171 . C172 ) = ( 0 ) by L493 , L183;
set D150 = ( ( ( ( C172 + 1 ) + 1 ) + C173 ) + 1 );
reconsider D151 = ( C172 + 1 ) as (Element of ( INT )) by INT_1:def 2;
reconsider D152 = 1 as (State of ( SuccTuring )) by L480;
L495: ( ( D151 + 1 ) + C173 ) < D150 by XREAL_1:29;
L496: C172 <= ( C172 + C173 ) by NAT_1:11;
L497: ( C172 + 2 ) <= ( ( C172 + C173 ) + 2 ) by L496 , XREAL_1:7;
L498: D151 < ( C172 + 2 ) by XREAL_1:8;
L499: D151 < ( ( C172 + C173 ) + 2 ) by L498 , L497 , XXREAL_0:2;
reconsider D153 = 2 as (State of ( SuccTuring )) by L480;
reconsider D154 = ( D151 + 1 ) as (Element of ( INT )) by INT_1:def 2;
reconsider D155 = ( ( D151 + 1 ) + C173 ) as (Element of ( INT )) by INT_1:def 2;
reconsider D156 = C172 as (Element of ( INT )) by INT_1:def 2;
reconsider D157 = D150 as (Element of ( INT )) by INT_1:def 2;
reconsider D158 = 1 as (Symbol of ( SuccTuring )) by L484;
set D159 = ( Tape-Chg (C171 , D151 , D158) );
L500: C172 < D151 by XREAL_1:29;
L501: ( C171 . ( ( C172 + C173 ) + 2 ) ) = ( 0 ) by L493 , L183;
L502: (( D159 . C172 ) = ( 0 ) & ( D159 . ( ( C172 + C173 ) + 2 ) ) = ( 0 ) & (for B136 being Integer holds ((C172 < B136 & B136 < ( ( C172 + C173 ) + 2 )) implies ( D159 . B136 ) = 1)))
proof
thus L503: ( D159 . C172 ) = ( 0 ) by L494 , L500 , L297;
thus L504: ( D159 . ( ( C172 + C173 ) + 2 ) ) = ( 0 ) by L501 , L497 , L498 , L297;
thus L505:now
let C174 being Integer;
assume L506: (C172 < C174 & C174 < ( ( C172 + C173 ) + 2 ));
per cases ;
suppose L507: D151 = C174;

thus L508: ( D159 . C174 ) = 1 by L507 , L297;
end;
suppose L509: D151 <> C174;

thus L510: ( D159 . C174 ) = ( C171 . C174 ) by L509 , L297
.= 1 by L493 , L506 , L183;
end;
end;
end;
L506: (for B137 being Integer holds ((( ( C172 + 1 ) + 1 ) <= B137 & B137 < ( ( ( C172 + 1 ) + 1 ) + C173 )) implies ( D159 . B137 ) = 1))
proof
let C175 being Integer;
assume that
L507: ( ( C172 + 1 ) + 1 ) <= C175
and
L508: C175 < ( ( ( C172 + 1 ) + 1 ) + C173 );
L509: D151 < ( D151 + 1 ) by XREAL_1:29;
L510: D151 < C175 by L509 , L507 , XXREAL_0:2;
L511: C172 < C175 by L510 , L500 , XXREAL_0:2;
thus L512: thesis by L511 , L502 , L508;
end;
reconsider D160 = ( C170 `3_3 ) as (Tape of ( SuccTuring ));
L513: ( TRAN C170 ) = ( ( Succ_Tran ) . [ ( C170 `1_3 ) , ( D160 . ( Head C170 ) ) ] ) by L477
.= ( ( Succ_Tran ) . [ ( 0 ) , ( D160 . ( Head C170 ) ) ] ) by L492 , MCART_1:64
.= ( ( Succ_Tran ) . [ ( 0 ) , ( C171 . ( Head C170 ) ) ] ) by L492 , MCART_1:64
.= [ 1 , ( 0 ) , 1 ] by L492 , L494 , L469 , MCART_1:64;
L514: ( offset ( TRAN C170 ) ) = 1 by L513 , MCART_1:64;
set D161 = [ D152 , D151 , C171 ];
reconsider D162 = ( D161 `3_3 ) as (Tape of ( SuccTuring ));
L515: ( Tape-Chg (( C170 `3_3 ) , ( Head C170 ) , ( ( TRAN C170 ) `2_3 )) ) = ( Tape-Chg (C171 , ( Head C170 ) , ( ( TRAN C170 ) `2_3 )) ) by L492 , MCART_1:64
.= ( Tape-Chg (C171 , C172 , ( ( TRAN C170 ) `2_3 )) ) by L492 , MCART_1:64
.= ( Tape-Chg (C171 , C172 , D149) ) by L513 , MCART_1:64
.= C171 by L494 , L280;
L516: ( Following C170 ) = [ ( ( TRAN C170 ) `1_3 ) , ( ( Head C170 ) + ( offset ( TRAN C170 ) ) ) , C171 ] by L515 , L492 , L487
.= [ 1 , ( ( Head C170 ) + ( offset ( TRAN C170 ) ) ) , C171 ] by L513 , MCART_1:64
.= D161 by L492 , L514 , MCART_1:64;
L517: ( TRAN D161 ) = ( ( Succ_Tran ) . [ ( D161 `1_3 ) , ( D162 . ( Head D161 ) ) ] ) by L477
.= ( ( Succ_Tran ) . [ D152 , ( D162 . ( Head D161 ) ) ] )
.= ( ( Succ_Tran ) . [ D152 , ( C171 . ( Head D161 ) ) ] )
.= ( ( Succ_Tran ) . [ 1 , ( C171 . D151 ) ] )
.= [ 1 , 1 , 1 ] by L493 , L500 , L499 , L183 , L469;
L518: ( offset ( TRAN D161 ) ) = 1 by L517 , MCART_1:64;
reconsider D163 = 1 as (State of ( SuccTuring )) by L480;
set D164 = [ D163 , D154 , D159 ];
L519: ( Tape-Chg (( D161 `3_3 ) , ( Head D161 ) , ( ( TRAN D161 ) `2_3 )) ) = ( Tape-Chg (C171 , ( Head D161 ) , ( ( TRAN D161 ) `2_3 )) )
.= ( Tape-Chg (C171 , D151 , ( ( TRAN D161 ) `2_3 )) )
.= D159 by L517 , MCART_1:64;
L520: ( Following D161 ) = [ ( ( TRAN D161 ) `1_3 ) , ( ( Head D161 ) + ( offset ( TRAN D161 ) ) ) , D159 ] by L519 , L487
.= [ 1 , ( ( Head D161 ) + ( offset ( TRAN D161 ) ) ) , D159 ] by L517 , MCART_1:64
.= D164 by L518;
reconsider D165 = 3 as (State of ( SuccTuring )) by L480;
set D166 = [ D163 , D155 , D159 ];
set D167 = ( Tape-Chg (D159 , D155 , D158) );
set D168 = ( Tape-Chg (D167 , D157 , D149) );
L521: (( (the Tran of ( SuccTuring )) . [ D163 , 1 ] ) = [ D163 , 1 , 1 ] & D163 <> (the AcceptS of ( SuccTuring ))) by L477 , L469;
L522: ( ( Computation D164 ) . C173 ) = [ D163 , ( ( ( C172 + 1 ) + 1 ) + C173 ) , D159 ] by L521 , L506 , L303;
L523: (( D151 + 1 ) <= ( ( ( C172 + 1 ) + 1 ) + C173 ) & D151 < ( D151 + 1 )) by NAT_1:11 , XREAL_1:29;
L524: D151 < ( ( D151 + 1 ) + C173 ) by L523 , XXREAL_0:2;
L525: (( D167 . C172 ) = ( 0 ) & (for B138 being Integer holds ((C172 < B138 & B138 <= ( ( C172 + C173 ) + 2 )) implies ( D167 . B138 ) = 1)))
proof
thus L526: ( D167 . C172 ) = ( 0 ) by L500 , L502 , L524 , L297;
thus L527:now
let C176 being Integer;
assume that
L528: C172 < C176
and
L529: C176 <= ( ( C172 + C173 ) + 2 );
per cases ;
suppose L530: C176 <> ( ( C172 + C173 ) + 2 );

L531: C176 < ( ( C172 + C173 ) + 2 ) by L530 , L529 , XXREAL_0:1;
thus L532: ( D167 . C176 ) = ( D159 . C176 ) by L530 , L297
.= 1 by L502 , L528 , L531;
end;
suppose L533: C176 = ( ( C172 + C173 ) + 2 );

thus L534: ( D167 . C176 ) = 1 by L533 , L297;
end;
end;
end;
set D169 = [ D165 , D155 , D168 ];
set D170 = [ D153 , D157 , D167 ];
reconsider D171 = ( D170 `3_3 ) as (Tape of ( SuccTuring ));
L528: (the Symbols of ( SuccTuring )) = { ( 0 ) , 1 } by L477;
L529:
now
per cases  by L528 , TARSKI:def 2;
suppose L530: ( D167 . D157 ) = 1;

thus L531: ( ( Succ_Tran ) . [ 2 , ( D167 . D157 ) ] ) = [ D165 , ( 0 ) , ( - 1 ) ] by L530 , L469;
end;
suppose L532: ( D167 . D157 ) = ( 0 );

thus L533: ( ( Succ_Tran ) . [ 2 , ( D167 . D157 ) ] ) = [ D165 , ( 0 ) , ( - 1 ) ] by L532 , L469;
end;
end;
L535: ( TRAN D170 ) = ( ( Succ_Tran ) . [ ( D170 `1_3 ) , ( D171 . ( Head D170 ) ) ] ) by L477
.= ( ( Succ_Tran ) . [ 2 , ( D171 . ( Head D170 ) ) ] )
.= ( ( Succ_Tran ) . [ 2 , ( D167 . ( Head D170 ) ) ] )
.= [ D165 , ( 0 ) , ( - 1 ) ] by L529;
L536: ( offset ( TRAN D170 ) ) = ( - 1 ) by L535 , MCART_1:64;
set D172 = ( ( 1 + 1 ) + C173 );
set D173 = [ D165 , D156 , D168 ];
defpred S6[ (Element of ( NAT )) ] means (( C172 + $1 ) <= D155 implies ( ( Computation D169 ) . $1 ) = [ 3 , ( D155 - $1 ) , D168 ]);
reconsider D174 = ( D166 `3_3 ) as (Tape of ( SuccTuring ));
L537: ( C172 + D172 ) = D155;
set D175 = ( ( Computation C170 ) . ( ( 1 + 1 ) + ( ( ( C173 + 1 ) + 1 ) + ( D172 + 1 ) ) ) );
L538: ( TRAN D166 ) = ( ( Succ_Tran ) . [ ( D166 `1_3 ) , ( D174 . ( Head D166 ) ) ] ) by L477
.= ( ( Succ_Tran ) . [ D163 , ( D174 . ( Head D166 ) ) ] )
.= ( ( Succ_Tran ) . [ D163 , ( D159 . ( Head D166 ) ) ] )
.= [ 2 , 1 , 1 ] by L502 , L469;
L539: ( offset ( TRAN D166 ) ) = 1 by L538 , MCART_1:64;
L540: C172 < ( ( D151 + 1 ) + C173 ) by L500 , L524 , XXREAL_0:2;
L541: (( D168 . C172 ) = ( 0 ) & ( D168 . ( ( C172 + ( C173 + 1 ) ) + 2 ) ) = ( 0 ) & (for B139 being Integer holds ((C172 < B139 & B139 < ( ( C172 + ( C173 + 1 ) ) + 2 )) implies ( D168 . B139 ) = 1)))
proof
thus L542: ( D168 . C172 ) = ( 0 ) by L540 , L525 , L495 , L297;
thus L543: ( D168 . ( ( C172 + ( C173 + 1 ) ) + 2 ) ) = ( 0 ) by L297;
thus L544:now
let C177 being Integer;
assume that
L545: C172 < C177
and
L546: C177 < ( ( C172 + ( C173 + 1 ) ) + 2 );
L547: ( C177 + 1 ) <= ( ( C172 + ( C173 + 1 ) ) + 2 ) by L546 , INT_1:7;
L548: C177 <= ( ( ( C172 + ( C173 + 1 ) ) + 2 ) - 1 ) by L547 , XREAL_1:19;
thus L549: ( D168 . C177 ) = ( D167 . C177 ) by L546 , L297
.= 1 by L525 , L545 , L548;
end;
end;
L545: D168 is_1_between C172 , ( ( C172 + ( C173 + 1 ) ) + 2 ) by L541 , L162;
L546: ( Tape-Chg (( D170 `3_3 ) , ( Head D170 ) , ( ( TRAN D170 ) `2_3 )) ) = ( Tape-Chg (D167 , ( Head D170 ) , ( ( TRAN D170 ) `2_3 )) )
.= ( Tape-Chg (D167 , D157 , ( ( TRAN D170 ) `2_3 )) )
.= D168 by L535 , MCART_1:64;
L547: ( Following D170 ) = [ ( ( TRAN D170 ) `1_3 ) , ( ( Head D170 ) + ( offset ( TRAN D170 ) ) ) , D168 ] by L546 , L487
.= [ D165 , ( ( Head D170 ) + ( offset ( TRAN D170 ) ) ) , D168 ] by L535 , MCART_1:64
.= D169 by L536;
L548: ( Tape-Chg (( D166 `3_3 ) , ( Head D166 ) , ( ( TRAN D166 ) `2_3 )) ) = ( Tape-Chg (D159 , ( Head D166 ) , ( ( TRAN D166 ) `2_3 )) )
.= ( Tape-Chg (D159 , D155 , ( ( TRAN D166 ) `2_3 )) )
.= D167 by L538 , MCART_1:64;
L549: ( Following D166 ) = [ ( ( TRAN D166 ) `1_3 ) , ( ( Head D166 ) + ( offset ( TRAN D166 ) ) ) , D167 ] by L548 , L487
.= [ 2 , ( ( Head D166 ) + ( offset ( TRAN D166 ) ) ) , D167 ] by L538 , MCART_1:64
.= D170 by L539;
L550: (for B140 being (Element of ( NAT )) holds (S6[ B140 ] implies S6[ ( B140 + 1 ) ]))
proof
let C178 being (Element of ( NAT ));
assume L551: S6[ C178 ];
L552:
now
reconsider D176 = ( D155 - C178 ) as (Element of ( INT )) by INT_1:def 2;
set D177 = ( D155 - C178 );
L553: ( C172 + C178 ) < ( ( C172 + C178 ) + 1 ) by XREAL_1:29;
set D178 = [ D165 , D176 , D168 ];
reconsider D179 = ( D178 `3_3 ) as (Tape of ( SuccTuring ));
L554: D155 <= ( D155 + C178 ) by INT_1:6;
L555: ( D155 - C178 ) <= D155 by L554 , XREAL_1:20;
assume L556: ( C172 + ( C178 + 1 ) ) <= D155;
L557: ( C172 + C178 ) < ( D155 + ( 0 ) ) by L556 , L553 , XXREAL_0:2;
L558: ( C172 - ( 0 ) ) < ( D155 - C178 ) by L557 , XREAL_1:21;
L559: C172 >= ( 0 ) by NAT_1:2;
reconsider D180 = ( D155 - C178 ) as (Element of ( NAT )) by L559 , L558 , INT_1:3 , XXREAL_0:2;
L560: ( ( C172 + C173 ) + 2 ) < ( ( ( C172 + C173 ) + 2 ) + 1 ) by XREAL_1:29;
L561: D180 < ( ( C172 + ( C173 + 1 ) ) + 2 ) by L560 , L555 , XXREAL_0:2;
L562: ( D168 . D180 ) = 1 by L561 , L541 , L558;
L563: ( TRAN D178 ) = ( ( Succ_Tran ) . [ ( D178 `1_3 ) , ( D179 . ( Head D178 ) ) ] ) by L477
.= ( ( Succ_Tran ) . [ D165 , ( D179 . ( Head D178 ) ) ] )
.= ( ( Succ_Tran ) . [ D165 , ( D168 . ( Head D178 ) ) ] )
.= [ 3 , 1 , ( - 1 ) ] by L562 , L469;
L564: ( offset ( TRAN D178 ) ) = ( - 1 ) by L563 , MCART_1:64;
L565: ( Tape-Chg (( D178 `3_3 ) , ( Head D178 ) , ( ( TRAN D178 ) `2_3 )) ) = ( Tape-Chg (D168 , ( Head D178 ) , ( ( TRAN D178 ) `2_3 )) )
.= ( Tape-Chg (D168 , D177 , ( ( TRAN D178 ) `2_3 )) )
.= ( Tape-Chg (D168 , D177 , D158) ) by L563 , MCART_1:64
.= D168 by L562 , L280;
thus L566:now
thus L567: ( ( Computation D169 ) . ( C178 + 1 ) ) = ( Following D178 ) by L551 , L556 , L553 , L82 , XXREAL_0:2
.= [ ( ( TRAN D178 ) `1_3 ) , ( ( Head D178 ) + ( offset ( TRAN D178 ) ) ) , D168 ] by L565 , L487
.= [ 3 , ( ( Head D178 ) + ( offset ( TRAN D178 ) ) ) , D168 ] by L563 , MCART_1:64
.= [ 3 , ( ( D155 - C178 ) + ( - 1 ) ) , D168 ] by L564
.= [ 3 , ( D155 - ( C178 + 1 ) ) , D168 ];
end;
end;
thus L567: thesis by L552;
end;
L568: S6[ ( 0 ) ] by L82;
L569: (for B141 being (Element of ( NAT )) holds S6[ B141 ]) from NAT_1:sch 1(L568 , L550);
L570: ( ( Computation D169 ) . D172 ) = [ 3 , ( D155 - D172 ) , D168 ] by L569 , L537
.= D173;
L571:
now
reconsider D181 = ( D173 `3_3 ) as (Tape of ( SuccTuring ));
L572: ( TRAN D173 ) = ( ( Succ_Tran ) . [ ( D173 `1_3 ) , ( D181 . ( Head D173 ) ) ] ) by L477
.= ( ( Succ_Tran ) . [ 3 , ( D181 . ( Head D173 ) ) ] )
.= ( ( Succ_Tran ) . [ 3 , ( D168 . ( Head D173 ) ) ] )
.= [ 4 , ( 0 ) , ( 0 ) ] by L541 , L469;
L573: ( offset ( TRAN D173 ) ) = ( 0 ) by L572 , MCART_1:64;
L574: ( Tape-Chg (( D173 `3_3 ) , ( Head D173 ) , ( ( TRAN D173 ) `2_3 )) ) = ( Tape-Chg (D168 , ( Head D173 ) , ( ( TRAN D173 ) `2_3 )) )
.= ( Tape-Chg (D168 , C172 , ( ( TRAN D173 ) `2_3 )) )
.= ( Tape-Chg (D168 , C172 , D149) ) by L572 , MCART_1:64
.= D168 by L541 , L280;
thus L575: ( Following D173 ) = [ ( ( TRAN D173 ) `1_3 ) , ( ( Head D173 ) + ( offset ( TRAN D173 ) ) ) , D168 ] by L574 , L487
.= [ 4 , ( ( Head D173 ) + ( offset ( TRAN D173 ) ) ) , D168 ] by L572 , MCART_1:64
.= [ 4 , ( C172 + ( 0 ) ) , D168 ] by L573;
end;
L576: D175 = ( ( Computation ( ( Computation C170 ) . ( 1 + 1 ) ) ) . ( ( ( C173 + 1 ) + 1 ) + ( D172 + 1 ) ) ) by L101
.= ( ( Computation ( Following ( ( Computation C170 ) . 1 ) ) ) . ( ( ( C173 + 1 ) + 1 ) + ( D172 + 1 ) ) ) by L82
.= ( ( Computation ( Following D161 ) ) . ( ( ( C173 + 1 ) + 1 ) + ( D172 + 1 ) ) ) by L516 , L98
.= ( ( Computation ( ( Computation D164 ) . ( ( C173 + 1 ) + 1 ) ) ) . ( D172 + 1 ) ) by L520 , L101
.= ( ( Computation ( Following ( ( Computation D164 ) . ( C173 + 1 ) ) ) ) . ( D172 + 1 ) ) by L82;
L577: D175 = ( ( Computation D169 ) . ( D172 + 1 ) ) by L576 , L522 , L549 , L547 , L82;
L578: D175 = [ 4 , C172 , D168 ] by L577 , L570 , L571 , L82;
L579: ( D175 `1_3 ) = 4 by L578 , MCART_1:64
.= (the AcceptS of ( SuccTuring )) by L477;
thus L580: C170 is  Accept-Halt by L579 , L124;
L581: ( Result C170 ) = D175 by L580 , L579 , L127;
thus L582: ( ( Result C170 ) `2_3 ) = C172 by L581 , L578 , MCART_1:64;
L583: ( ( Result C170 ) `3_3 ) = D168 by L578 , L581 , MCART_1:64;
thus L584: thesis by L583 , L545 , L171;
end;
theorem
L585: ( SuccTuring ) computes ( 1 succ 1 )
proof
L586:
now
set D182 = ( 1 succ 1 );
let C179 being (All-State of ( SuccTuring ));
let C180 being (Tape of ( SuccTuring ));
let C181 being (Element of ( NAT ));
let C182 being (FinSequence of ( NAT ));
assume that
L587: C182 in ( dom D182 )
and
L588: C179 = [ (the InitS of ( SuccTuring )) , C181 , C180 ]
and
L589: C180 storeData ( <* C181 *> ^ C182 );
L590: C179 = [ ( 0 ) , C181 , C180 ] by L588 , L477;
L591: ( dom D182 ) = ( 1 -tuples_on ( NAT ) ) by COMPUT_1:def 7;
L592: C182 is (Tuple of 1 , ( NAT )) by L591 , L587 , FINSEQ_2:131;
consider R2 being (Element of ( NAT )) such that L593: C182 = <* R2 *> by L592 , FINSEQ_2:97;
L594: ( <* C181 *> ^ C182 ) = <* C181 , R2 *> by L593;
thus L595: C179 is  Accept-Halt by L594 , L589 , L590 , L491;
take D183 = C181;
take D184 = ( R2 + 1 );
thus L596: ( ( Result C179 ) `2_3 ) = D183 by L589 , L590 , L594 , L491;
thus L597: D184 = ( ( C182 /. 1 ) + 1 ) by L593 , FINSEQ_4:16
.= ( D182 . C182 ) by L587 , L591 , COMPUT_1:def 7;
L598: ( ( Result C179 ) `3_3 ) storeData <* D183 , ( R2 + 1 ) *> by L589 , L590 , L594 , L491;
thus L599: ( ( Result C179 ) `3_3 ) storeData ( <* D183 *> ^ <* D184 *> ) by L598;
end;
thus L600: thesis by L586 , L443;
end;
begin
definition
func Zero_Tran -> (Function of [: ( SegM 4 ) , { ( 0 ) , 1 } :] , [: ( SegM 4 ) , { ( 0 ) , 1 } , { ( - 1 ) , ( 0 ) , 1 } :]) equals 
( ( ( ( ( ( id ([: ( SegM 4 ) , { ( 0 ) , 1 } :] , { ( - 1 ) , ( 0 ) , 1 } , 1) ) +* ( [ ( 0 ) , ( 0 ) ] .--> [ 1 , ( 0 ) , 1 ] ) ) +* ( [ 1 , 1 ] .--> [ 2 , 1 , 1 ] ) ) +* ( [ 2 , ( 0 ) ] .--> [ 3 , ( 0 ) , ( - 1 ) ] ) ) +* ( [ 2 , 1 ] .--> [ 3 , ( 0 ) , ( - 1 ) ] ) ) +* ( [ 3 , 1 ] .--> [ 4 , 1 , ( - 1 ) ] ) );
coherence
proof
reconsider D185 = ( 0 ) , D186 = 1 , D187 = 2 , D188 = 3 , D189 = 4 as (Element of ( SegM 4 )) by L26;
set D190 = [: ( SegM 4 ) , { ( 0 ) , 1 } :];
set D191 = { ( - 1 ) , ( 0 ) , 1 };
set D192 = [: ( SegM 4 ) , { ( 0 ) , 1 } , D191 :];
reconsider D193 = ( 0 ) , D194 = 1 as (Element of { ( 0 ) , 1 }) by TARSKI:def 2;
reconsider D195 = ( - 1 ) as (Element of D191) by ENUMSET1:def 1;
reconsider D196 = 1 as (Element of { ( - 1 ) , ( 0 ) , 1 }) by ENUMSET1:def 1;
L601: D192 = [: D190 , D191 :] by ZFMISC_1:def 3;
reconsider D197 = ( id (D190 , D191 , D196) ) as (Function of D190 , D192) by L601;
L602: ( ( ( ( ( ( id (D190 , D191 , 1) ) +* ( [ ( 0 ) , ( 0 ) ] .--> [ 1 , ( 0 ) , 1 ] ) ) +* ( [ 1 , 1 ] .--> [ 2 , 1 , 1 ] ) ) +* ( [ 2 , ( 0 ) ] .--> [ 3 , ( 0 ) , ( - 1 ) ] ) ) +* ( [ 2 , 1 ] .--> [ 3 , ( 0 ) , ( - 1 ) ] ) ) +* ( [ 3 , 1 ] .--> [ 4 , 1 , ( - 1 ) ] ) ) = ( ( ( ( ( D197 +* ( [ D185 , D193 ] .--> [ D186 , D193 , D196 ] ) ) +* ( [ D186 , D194 ] .--> [ D187 , D194 , D196 ] ) ) +* ( [ D187 , D193 ] .--> [ D188 , D193 , D195 ] ) ) +* ( [ D187 , D194 ] .--> [ D188 , D193 , D195 ] ) ) +* ( [ D188 , D194 ] .--> [ D189 , D194 , D195 ] ) );
thus L603: thesis by L602;
end;
end;
theorem
L605: (( ( Zero_Tran ) . [ ( 0 ) , ( 0 ) ] ) = [ 1 , ( 0 ) , 1 ] & ( ( Zero_Tran ) . [ 1 , 1 ] ) = [ 2 , 1 , 1 ] & ( ( Zero_Tran ) . [ 2 , ( 0 ) ] ) = [ 3 , ( 0 ) , ( - 1 ) ] & ( ( Zero_Tran ) . [ 2 , 1 ] ) = [ 3 , ( 0 ) , ( - 1 ) ] & ( ( Zero_Tran ) . [ 3 , 1 ] ) = [ 4 , 1 , ( - 1 ) ])
proof
set D198 = [ 1 , 1 ];
set D199 = [ ( 0 ) , ( 0 ) ];
set D200 = ( [ ( 0 ) , ( 0 ) ] .--> [ 1 , ( 0 ) , 1 ] );
set D201 = ( [ 1 , 1 ] .--> [ 2 , 1 , 1 ] );
set D202 = ( [ 2 , ( 0 ) ] .--> [ 3 , ( 0 ) , ( - 1 ) ] );
set D203 = ( [ 2 , 1 ] .--> [ 3 , ( 0 ) , ( - 1 ) ] );
set D204 = ( id ([: ( SegM 4 ) , { ( 0 ) , 1 } :] , { ( - 1 ) , ( 0 ) , 1 } , 1) );
thus L606: ( ( Zero_Tran ) . D199 ) = ( ( ( ( ( D204 +* D200 ) +* D201 ) +* D202 ) +* D203 ) . D199 ) by L32
.= ( ( ( ( D204 +* D200 ) +* D201 ) +* D202 ) . D199 ) by L32
.= ( ( ( D204 +* D200 ) +* D201 ) . D199 ) by L32
.= ( ( D204 +* D200 ) . D199 ) by L38
.= [ 1 , ( 0 ) , 1 ] by FUNCT_7:94;
thus L607: ( ( Zero_Tran ) . D198 ) = ( ( ( ( ( D204 +* D200 ) +* D201 ) +* D202 ) +* D203 ) . D198 ) by L32
.= ( ( ( ( D204 +* D200 ) +* D201 ) +* D202 ) . D198 ) by L32
.= ( ( ( D204 +* D200 ) +* D201 ) . D198 ) by L38
.= [ 2 , 1 , 1 ] by FUNCT_7:94;
set D205 = [ 2 , ( 0 ) ];
thus L608: ( ( Zero_Tran ) . D205 ) = ( ( ( ( ( D204 +* D200 ) +* D201 ) +* D202 ) +* D203 ) . D205 ) by L38
.= ( ( ( ( D204 +* D200 ) +* D201 ) +* D202 ) . D205 ) by L38
.= [ 3 , ( 0 ) , ( - 1 ) ] by FUNCT_7:94;
set D206 = [ 2 , 1 ];
thus L609: ( ( Zero_Tran ) . D206 ) = ( ( ( ( ( D204 +* D200 ) +* D201 ) +* D202 ) +* D203 ) . D206 ) by L32
.= [ 3 , ( 0 ) , ( - 1 ) ] by FUNCT_7:94;
thus L610: thesis by FUNCT_7:94;
end;
definition
func ZeroTuring ->  strict TuringStr means 
:L611: ((the Symbols of it) = { ( 0 ) , 1 } & (the FStates of it) = ( SegM 4 ) & (the Tran of it) = ( Zero_Tran ) & (the InitS of it) = ( 0 ) & (the AcceptS of it) = 4);
existence
proof
set D207 = ( SegM 4 );
reconsider D208 = 4 as (Element of D207) by L26;
reconsider D209 = ( 0 ) as (Element of D207) by L26;
set D210 = { ( 0 ) , 1 };
take TuringStr (# D210 , D207 , ( Zero_Tran ) , D209 , D208 #);
thus L612: thesis;
end;
uniqueness;
end;
L614: (for B142 being (Element of ( NAT )) holds (B142 <= 4 implies B142 is (State of ( ZeroTuring ))))
proof
let C183 being (Element of ( NAT ));
assume L615: C183 <= 4;
L616: (the FStates of ( ZeroTuring )) = ( SegM 4 ) by L611;
thus L617: thesis by L616 , L615 , L26;
end;
L618: (( 0 ) in (the Symbols of ( ZeroTuring )) & 1 in (the Symbols of ( ZeroTuring )))
proof
L619: (( 0 ) in { ( 0 ) , 1 } & 1 in { ( 0 ) , 1 }) by TARSKI:def 2;
thus L620: thesis by L619 , L611;
end;
L621: (for B143 being (All-State of ( ZeroTuring )) holds (for B144 , B145 , B146 being set holds ((B143 = [ B144 , B145 , B146 ] & B144 <> 4) implies ( Following B143 ) = [ ( ( TRAN B143 ) `1_3 ) , ( ( Head B143 ) + ( offset ( TRAN B143 ) ) ) , ( Tape-Chg (( B143 `3_3 ) , ( Head B143 ) , ( ( TRAN B143 ) `2_3 )) ) ])))
proof
let C184 being (All-State of ( ZeroTuring ));
let C185 , C186 , C187 being set;
assume L622: (C184 = [ C185 , C186 , C187 ] & C185 <> 4);
L623: 4 = (the AcceptS of ( ZeroTuring )) by L611;
thus L624: thesis by L623 , L622 , L288;
end;
theorem
L625: (for B147 being (All-State of ( ZeroTuring )) holds (for B148 being (Tape of ( ZeroTuring )) holds (for B149 being (Element of ( NAT )) holds (for B150 being (FinSequence of ( NAT )) holds ((( len B150 ) >= 1 & B147 = [ ( 0 ) , B149 , B148 ] & B148 storeData ( <* B149 *> ^ B150 )) implies (B147 is  Accept-Halt & ( ( Result B147 ) `2_3 ) = B149 & ( ( Result B147 ) `3_3 ) storeData <* B149 , ( 0 ) *>))))))
proof
reconsider D211 = ( 0 ) as (Symbol of ( ZeroTuring )) by L618;
let C188 being (All-State of ( ZeroTuring ));
let C189 being (Tape of ( ZeroTuring ));
let C190 being (Element of ( NAT ));
let C191 being (FinSequence of ( NAT ));
assume that
L626: ( len C191 ) >= 1
and
L627: C188 = [ ( 0 ) , C190 , C189 ]
and
L628: C189 storeData ( <* C190 *> ^ C191 );
reconsider D212 = ( C188 `3_3 ) as (Tape of ( ZeroTuring ));
reconsider D213 = ( C190 + 1 ) as (Element of ( INT )) by INT_1:def 2;
set D214 = ( C191 /. 1 );
set D215 = ( ( C190 + ( C191 /. 1 ) ) + 2 );
L629: C190 < D213 by XREAL_1:29;
reconsider D216 = 1 as (State of ( ZeroTuring )) by L614;
set D217 = [ D216 , D213 , C189 ];
reconsider D218 = ( D213 + 1 ) as (Element of ( INT )) by INT_1:def 2;
L630: D213 < D218 by XREAL_1:29;
reconsider D219 = 1 as (Symbol of ( ZeroTuring )) by L618;
set D220 = ( Tape-Chg (C189 , D213 , D219) );
set D221 = ( Tape-Chg (D220 , D218 , D211) );
set D222 = ( Tape-Chg (D221 , D213 , D219) );
L631: C189 is_1_between C190 , D215 by L626 , L628 , L251;
L632: ( C189 . C190 ) = ( 0 ) by L631 , L162;
L633: ( D220 . C190 ) = ( 0 ) by L632 , L629 , L297;
L634: ( D221 . C190 ) = ( 0 ) by L633 , L629 , L630 , L297;
L635: ( D222 . C190 ) = ( 0 ) by L634 , L629 , L297;
L636: ( TRAN C188 ) = ( ( Zero_Tran ) . [ ( C188 `1_3 ) , ( D212 . ( Head C188 ) ) ] ) by L611
.= ( ( Zero_Tran ) . [ ( 0 ) , ( D212 . ( Head C188 ) ) ] ) by L627 , MCART_1:64
.= ( ( Zero_Tran ) . [ ( 0 ) , ( C189 . ( Head C188 ) ) ] ) by L627 , MCART_1:64
.= [ 1 , ( 0 ) , 1 ] by L627 , L632 , L605 , MCART_1:64;
L637: ( offset ( TRAN C188 ) ) = 1 by L636 , MCART_1:64;
set D223 = ( ( Computation C188 ) . ( ( ( 1 + 1 ) + 1 ) + 1 ) );
reconsider D224 = 3 as (State of ( ZeroTuring )) by L614;
L638: ( ( C190 + 1 ) + 1 ) = ( ( C190 + ( 0 ) ) + 2 );
L639: ( D222 . ( C190 + 1 ) ) = 1 by L297;
L640:
now
let C192 being Integer;
assume L641: (C190 < C192 & C192 < ( ( C190 + ( 0 ) ) + 2 ));
L642: (( C190 + 1 ) <= C192 & C192 <= ( C190 + 1 )) by L641 , L638 , INT_1:7;
thus L643: ( D222 . C192 ) = 1 by L642 , L639 , XXREAL_0:1;
end;
L644: ( D220 . ( C190 + 1 ) ) = 1 by L297;
L645: ( D221 . ( C190 + 1 ) ) = 1 by L644 , L630 , L297;
set D225 = [ D224 , D213 , D221 ];
reconsider D226 = ( D225 `3_3 ) as (Tape of ( ZeroTuring ));
L646: ( TRAN D225 ) = ( ( Zero_Tran ) . [ ( D225 `1_3 ) , ( D226 . ( Head D225 ) ) ] ) by L611
.= ( ( Zero_Tran ) . [ D224 , ( D226 . ( Head D225 ) ) ] )
.= ( ( Zero_Tran ) . [ D224 , ( D221 . ( Head D225 ) ) ] )
.= [ 4 , 1 , ( - 1 ) ] by L645 , L605;
L647: ( offset ( TRAN D225 ) ) = ( - 1 ) by L646 , MCART_1:64;
reconsider D227 = 2 as (State of ( ZeroTuring )) by L614;
reconsider D228 = ( D217 `3_3 ) as (Tape of ( ZeroTuring ));
L648: C190 <= ( C190 + D214 ) by NAT_1:11;
L649: ( C190 + 2 ) <= ( ( C190 + D214 ) + 2 ) by L648 , XREAL_1:7;
L650: D213 < ( C190 + 2 ) by XREAL_1:8;
L651: D213 < D215 by L650 , L649 , XXREAL_0:2;
L652: ( TRAN D217 ) = ( ( Zero_Tran ) . [ ( D217 `1_3 ) , ( D228 . ( Head D217 ) ) ] ) by L611
.= ( ( Zero_Tran ) . [ D216 , ( D228 . ( Head D217 ) ) ] )
.= ( ( Zero_Tran ) . [ D216 , ( C189 . ( Head D217 ) ) ] )
.= ( ( Zero_Tran ) . [ 1 , ( C189 . D213 ) ] )
.= [ 2 , 1 , 1 ] by L631 , L629 , L651 , L162 , L605;
L653: ( offset ( TRAN D217 ) ) = 1 by L652 , MCART_1:64;
L654:
now
L655: (the Symbols of ( ZeroTuring )) = { ( 0 ) , 1 } by L611;
per cases  by L655 , TARSKI:def 2;
suppose L656: ( D220 . D218 ) = 1;

thus L657: ( ( Zero_Tran ) . [ 2 , ( D220 . D218 ) ] ) = [ 3 , ( 0 ) , ( - 1 ) ] by L656 , L605;
end;
suppose L658: ( D220 . D218 ) = ( 0 );

thus L659: ( ( Zero_Tran ) . [ 2 , ( D220 . D218 ) ] ) = [ 3 , ( 0 ) , ( - 1 ) ] by L658 , L605;
end;
end;
set D229 = [ D227 , D218 , D220 ];
reconsider D230 = ( D229 `3_3 ) as (Tape of ( ZeroTuring ));
L661: ( TRAN D229 ) = ( ( Zero_Tran ) . [ ( D229 `1_3 ) , ( D230 . ( Head D229 ) ) ] ) by L611
.= ( ( Zero_Tran ) . [ D227 , ( D230 . ( Head D229 ) ) ] )
.= ( ( Zero_Tran ) . [ D227 , ( D220 . ( Head D229 ) ) ] )
.= [ 3 , ( 0 ) , ( - 1 ) ] by L654;
L662: ( offset ( TRAN D229 ) ) = ( - 1 ) by L661 , MCART_1:64;
L663: ( Tape-Chg (( D229 `3_3 ) , ( Head D229 ) , ( ( TRAN D229 ) `2_3 )) ) = ( Tape-Chg (D220 , ( Head D229 ) , ( ( TRAN D229 ) `2_3 )) )
.= ( Tape-Chg (D220 , D218 , ( ( TRAN D229 ) `2_3 )) )
.= D221 by L661 , MCART_1:64;
L664: ( Following D229 ) = [ ( ( TRAN D229 ) `1_3 ) , ( ( Head D229 ) + ( offset ( TRAN D229 ) ) ) , D221 ] by L663 , L621
.= [ 3 , ( ( Head D229 ) + ( offset ( TRAN D229 ) ) ) , D221 ] by L661 , MCART_1:64
.= D225 by L662;
reconsider D231 = 3 as (State of ( ZeroTuring )) by L614;
L665: ( Tape-Chg (( D225 `3_3 ) , ( Head D225 ) , ( ( TRAN D225 ) `2_3 )) ) = ( Tape-Chg (D221 , ( Head D225 ) , ( ( TRAN D225 ) `2_3 )) )
.= ( Tape-Chg (D221 , D213 , ( ( TRAN D225 ) `2_3 )) )
.= D222 by L646 , MCART_1:64;
set D232 = [ D231 , D213 , D221 ];
L666: ( Following D232 ) = [ ( ( TRAN D232 ) `1_3 ) , ( ( Head D232 ) + ( offset ( TRAN D232 ) ) ) , D222 ] by L665 , L621
.= [ 4 , ( ( Head D232 ) + ( offset ( TRAN D232 ) ) ) , D222 ] by L646 , MCART_1:64
.= [ 4 , C190 , D222 ] by L647;
L667: ( Tape-Chg (( C188 `3_3 ) , ( Head C188 ) , ( ( TRAN C188 ) `2_3 )) ) = ( Tape-Chg (C189 , ( Head C188 ) , ( ( TRAN C188 ) `2_3 )) ) by L627 , MCART_1:64
.= ( Tape-Chg (C189 , C190 , ( ( TRAN C188 ) `2_3 )) ) by L627 , MCART_1:64
.= ( Tape-Chg (C189 , C190 , D211) ) by L636 , MCART_1:64
.= C189 by L632 , L280;
L668: ( Following C188 ) = [ ( ( TRAN C188 ) `1_3 ) , ( ( Head C188 ) + ( offset ( TRAN C188 ) ) ) , C189 ] by L667 , L627 , L621
.= [ 1 , ( ( Head C188 ) + ( offset ( TRAN C188 ) ) ) , C189 ] by L636 , MCART_1:64
.= D217 by L627 , L637 , MCART_1:64;
L669: ( Tape-Chg (( D217 `3_3 ) , ( Head D217 ) , ( ( TRAN D217 ) `2_3 )) ) = ( Tape-Chg (C189 , ( Head D217 ) , ( ( TRAN D217 ) `2_3 )) )
.= ( Tape-Chg (C189 , D213 , ( ( TRAN D217 ) `2_3 )) )
.= D220 by L652 , MCART_1:64;
L670: ( Following D217 ) = [ ( ( TRAN D217 ) `1_3 ) , ( ( Head D217 ) + ( offset ( TRAN D217 ) ) ) , D220 ] by L669 , L621
.= [ 2 , ( ( Head D217 ) + ( offset ( TRAN D217 ) ) ) , D220 ] by L652 , MCART_1:64
.= D229 by L653;
L671: D223 = ( Following ( ( Computation C188 ) . ( ( 1 + 1 ) + 1 ) ) ) by L82
.= ( Following ( Following ( ( Computation C188 ) . ( 1 + 1 ) ) ) ) by L82
.= ( Following ( Following ( Following ( ( Computation C188 ) . 1 ) ) ) ) by L82
.= [ 4 , C190 , D222 ] by L668 , L670 , L664 , L666 , L98;
L672: ( D223 `1_3 ) = 4 by L671 , MCART_1:64
.= (the AcceptS of ( ZeroTuring )) by L611;
thus L673: C188 is  Accept-Halt by L672 , L124;
L674: ( Result C188 ) = D223 by L673 , L672 , L127;
thus L675: ( ( Result C188 ) `2_3 ) = C190 by L674 , L671 , MCART_1:64;
L676: ( ( Result C188 ) `3_3 ) = D222 by L671 , L674 , MCART_1:64;
L677: ( D221 . D218 ) = ( 0 ) by L297;
L678: ( D222 . D218 ) = ( 0 ) by L677 , L630 , L297;
L679: D222 is_1_between C190 , ( ( C190 + ( 0 ) ) + 2 ) by L678 , L635 , L640 , L162;
thus L680: thesis by L679 , L676 , L171;
end;
theorem
L681: (for R1 being (Element of ( NAT )) holds (R1 >= 1 implies ( ZeroTuring ) computes ( R1 const ( 0 ) )))
proof
let R1 being (Element of ( NAT ));
assume L682: R1 >= 1;
L683:
now
set D233 = ( R1 const ( 0 ) );
let C193 being (All-State of ( ZeroTuring ));
let C194 being (Tape of ( ZeroTuring ));
let C195 being (Element of ( NAT ));
let C196 being (FinSequence of ( NAT ));
assume that
L684: C196 in ( dom D233 )
and
L685: C193 = [ (the InitS of ( ZeroTuring )) , C195 , C194 ]
and
L686: C194 storeData ( <* C195 *> ^ C196 );
L687: ( arity D233 ) = R1 by COMPUT_1:32;
L688: ( dom D233 ) c= ( R1 -tuples_on ( NAT ) ) by L687 , COMPUT_1:21;
L689: C196 in ( R1 -tuples_on ( NAT ) ) by L688 , L684;
L690: C196 in { B151 where B151 is (Element of ( ( NAT ) * )) : ( len B151 ) = R1 } by L689 , FINSEQ_2:def 4;
L691: (ex B152 being (Element of ( ( NAT ) * )) st (C196 = B152 & ( len B152 ) = R1)) by L690;
L692: C193 = [ ( 0 ) , C195 , C194 ] by L685 , L611;
thus L693: C193 is  Accept-Halt by L692 , L682 , L686 , L691 , L625;
take D234 = C195;
take D235 = ( 0 );
thus L694: ( ( Result C193 ) `2_3 ) = D234 by L682 , L686 , L691 , L692 , L625;
thus L695: D235 = ( D233 . C196 ) by L684 , L688 , FUNCOP_1:7;
L696: ( ( Result C193 ) `3_3 ) storeData <* D234 , ( 0 ) *> by L682 , L686 , L691 , L692 , L625;
thus L697: ( ( Result C193 ) `3_3 ) storeData ( <* D234 *> ^ <* D235 *> ) by L696;
end;
thus L698: thesis by L683 , L443;
end;
begin
definition
func U3(n)Tran -> (Function of [: ( SegM 3 ) , { ( 0 ) , 1 } :] , [: ( SegM 3 ) , { ( 0 ) , 1 } , { ( - 1 ) , ( 0 ) , 1 } :]) equals 
( ( ( ( ( ( id ([: ( SegM 3 ) , { ( 0 ) , 1 } :] , { ( - 1 ) , ( 0 ) , 1 } , ( 0 )) ) +* ( [ ( 0 ) , ( 0 ) ] .--> [ 1 , ( 0 ) , 1 ] ) ) +* ( [ 1 , 1 ] .--> [ 1 , ( 0 ) , 1 ] ) ) +* ( [ 1 , ( 0 ) ] .--> [ 2 , ( 0 ) , 1 ] ) ) +* ( [ 2 , 1 ] .--> [ 2 , ( 0 ) , 1 ] ) ) +* ( [ 2 , ( 0 ) ] .--> [ 3 , ( 0 ) , ( 0 ) ] ) );
coherence
proof
reconsider D236 = ( 0 ) , D237 = 1 , D238 = 2 , D239 = 3 as (Element of ( SegM 3 )) by L26;
set D240 = [: ( SegM 3 ) , { ( 0 ) , 1 } :];
set D241 = { ( - 1 ) , ( 0 ) , 1 };
set D242 = [: ( SegM 3 ) , { ( 0 ) , 1 } , D241 :];
reconsider D243 = ( 0 ) , D244 = 1 as (Element of { ( 0 ) , 1 }) by TARSKI:def 2;
reconsider D245 = ( 0 ) , D246 = 1 as (Element of D241) by ENUMSET1:def 1;
L699: D242 = [: D240 , D241 :] by ZFMISC_1:def 3;
reconsider D247 = ( id (D240 , D241 , D245) ) as (Function of D240 , D242) by L699;
L700: ( ( ( ( ( ( id (D240 , D241 , ( 0 )) ) +* ( [ ( 0 ) , ( 0 ) ] .--> [ 1 , ( 0 ) , 1 ] ) ) +* ( [ 1 , 1 ] .--> [ 1 , ( 0 ) , 1 ] ) ) +* ( [ 1 , ( 0 ) ] .--> [ 2 , ( 0 ) , 1 ] ) ) +* ( [ 2 , 1 ] .--> [ 2 , ( 0 ) , 1 ] ) ) +* ( [ 2 , ( 0 ) ] .--> [ 3 , ( 0 ) , ( 0 ) ] ) ) = ( ( ( ( ( D247 +* ( [ D236 , D243 ] .--> [ D237 , D243 , D246 ] ) ) +* ( [ D237 , D244 ] .--> [ D237 , D243 , D246 ] ) ) +* ( [ D237 , D243 ] .--> [ D238 , D243 , D246 ] ) ) +* ( [ D238 , D244 ] .--> [ D238 , D243 , D246 ] ) ) +* ( [ D238 , D243 ] .--> [ D239 , D243 , D245 ] ) );
thus L701: thesis by L700;
end;
end;
theorem
L703: (( ( U3(n)Tran ) . [ ( 0 ) , ( 0 ) ] ) = [ 1 , ( 0 ) , 1 ] & ( ( U3(n)Tran ) . [ 1 , 1 ] ) = [ 1 , ( 0 ) , 1 ] & ( ( U3(n)Tran ) . [ 1 , ( 0 ) ] ) = [ 2 , ( 0 ) , 1 ] & ( ( U3(n)Tran ) . [ 2 , 1 ] ) = [ 2 , ( 0 ) , 1 ] & ( ( U3(n)Tran ) . [ 2 , ( 0 ) ] ) = [ 3 , ( 0 ) , ( 0 ) ])
proof
set D248 = [ 1 , 1 ];
set D249 = [ ( 0 ) , ( 0 ) ];
set D250 = ( [ ( 0 ) , ( 0 ) ] .--> [ 1 , ( 0 ) , 1 ] );
set D251 = ( [ 1 , 1 ] .--> [ 1 , ( 0 ) , 1 ] );
set D252 = ( [ 1 , ( 0 ) ] .--> [ 2 , ( 0 ) , 1 ] );
set D253 = ( [ 2 , 1 ] .--> [ 2 , ( 0 ) , 1 ] );
set D254 = ( id ([: ( SegM 3 ) , { ( 0 ) , 1 } :] , { ( - 1 ) , ( 0 ) , 1 } , ( 0 )) );
thus L704: ( ( U3(n)Tran ) . D249 ) = ( ( ( ( ( D254 +* D250 ) +* D251 ) +* D252 ) +* D253 ) . D249 ) by L32
.= ( ( ( ( D254 +* D250 ) +* D251 ) +* D252 ) . D249 ) by L32
.= ( ( ( D254 +* D250 ) +* D251 ) . D249 ) by L32
.= ( ( D254 +* D250 ) . D249 ) by L38
.= [ 1 , ( 0 ) , 1 ] by FUNCT_7:94;
thus L705: ( ( U3(n)Tran ) . D248 ) = ( ( ( ( ( D254 +* D250 ) +* D251 ) +* D252 ) +* D253 ) . D248 ) by L32
.= ( ( ( ( D254 +* D250 ) +* D251 ) +* D252 ) . D248 ) by L32
.= ( ( ( D254 +* D250 ) +* D251 ) . D248 ) by L38
.= [ 1 , ( 0 ) , 1 ] by FUNCT_7:94;
set D255 = [ 1 , ( 0 ) ];
thus L706: ( ( U3(n)Tran ) . D255 ) = ( ( ( ( ( D254 +* D250 ) +* D251 ) +* D252 ) +* D253 ) . D255 ) by L32
.= ( ( ( ( D254 +* D250 ) +* D251 ) +* D252 ) . D255 ) by L38
.= [ 2 , ( 0 ) , 1 ] by FUNCT_7:94;
set D256 = [ 2 , 1 ];
thus L707: ( ( U3(n)Tran ) . D256 ) = ( ( ( ( ( D254 +* D250 ) +* D251 ) +* D252 ) +* D253 ) . D256 ) by L38
.= [ 2 , ( 0 ) , 1 ] by FUNCT_7:94;
thus L708: thesis by FUNCT_7:94;
end;
definition
func U3(n)Turing ->  strict TuringStr means 
:L709: ((the Symbols of it) = { ( 0 ) , 1 } & (the FStates of it) = ( SegM 3 ) & (the Tran of it) = ( U3(n)Tran ) & (the InitS of it) = ( 0 ) & (the AcceptS of it) = 3);
existence
proof
set D257 = ( SegM 3 );
reconsider D258 = 3 as (Element of D257) by L26;
reconsider D259 = ( 0 ) as (Element of D257) by L26;
set D260 = { ( 0 ) , 1 };
take TuringStr (# D260 , D257 , ( U3(n)Tran ) , D259 , D258 #);
thus L710: thesis;
end;
uniqueness;
end;
L712: (for B153 being (Element of ( NAT )) holds (B153 <= 3 implies B153 is (State of ( U3(n)Turing ))))
proof
let C197 being (Element of ( NAT ));
assume L713: C197 <= 3;
L714: (the FStates of ( U3(n)Turing )) = ( SegM 3 ) by L709;
thus L715: thesis by L714 , L713 , L26;
end;
L716: (( 0 ) in (the Symbols of ( U3(n)Turing )) & 1 in (the Symbols of ( U3(n)Turing )))
proof
L717: (( 0 ) in { ( 0 ) , 1 } & 1 in { ( 0 ) , 1 }) by TARSKI:def 2;
thus L718: thesis by L717 , L709;
end;
L719: (for B154 being (All-State of ( U3(n)Turing )) holds (for B155 , B156 , B157 being set holds ((B154 = [ B155 , B156 , B157 ] & B155 <> 3) implies ( Following B154 ) = [ ( ( TRAN B154 ) `1_3 ) , ( ( Head B154 ) + ( offset ( TRAN B154 ) ) ) , ( Tape-Chg (( B154 `3_3 ) , ( Head B154 ) , ( ( TRAN B154 ) `2_3 )) ) ])))
proof
let C198 being (All-State of ( U3(n)Turing ));
let C199 , C200 , C201 being set;
assume L720: (C198 = [ C199 , C200 , C201 ] & C199 <> 3);
L721: 3 = (the AcceptS of ( U3(n)Turing )) by L709;
thus L722: thesis by L721 , L720 , L288;
end;
L723: (for B158 being TuringStr holds (for B159 being (All-State of B158) holds (for B160 being (State of B158) holds (for B161 being (Element of ( INT )) holds (for B162 being (Tape of B158) holds (for B163 , B164 being (Element of ( NAT )) holds ((B164 = B161 & ( 0 ) is (Symbol of B158) & B159 = [ B160 , B161 , B162 ] & ( (the Tran of B158) . [ B160 , 1 ] ) = [ B160 , ( 0 ) , 1 ] & B160 <> (the AcceptS of B158) & (for B165 being Integer holds ((B164 <= B165 & B165 < ( B164 + B163 )) implies ( B162 . B165 ) = 1))) implies (ex B166 being (Tape of B158) st (( ( Computation B159 ) . B163 ) = [ B160 , ( B164 + B163 ) , B166 ] & (for B167 being Integer holds ((B164 <= B167 & B167 < ( B164 + B163 )) implies ( B166 . B167 ) = ( 0 ))) & (for B168 being Integer holds ((B164 > B168 or B168 >= ( B164 + B163 )) implies ( B166 . B168 ) = ( B162 . B168 ))))))))))))
proof
let C202 being TuringStr;
let C203 being (All-State of C202);
let C204 being (State of C202);
let C205 being (Element of ( INT ));
let C206 being (Tape of C202);
let C207 , C208 being (Element of ( NAT ));
assume that
L724: C208 = C205
and
L725: ( 0 ) is (Symbol of C202)
and
L726: C203 = [ C204 , C205 , C206 ]
and
L727: ( (the Tran of C202) . [ C204 , 1 ] ) = [ C204 , ( 0 ) , 1 ]
and
L728: C204 <> (the AcceptS of C202)
and
L729: (for B169 being Integer holds ((C208 <= B169 & B169 < ( C208 + C207 )) implies ( C206 . B169 ) = 1));
defpred S7[ (Element of ( NAT )) ] means ($1 <= C207 implies (ex B170 being (Tape of C202) st (( ( Computation C203 ) . $1 ) = [ C204 , ( C208 + $1 ) , B170 ] & (for B171 being Integer holds ((C208 <= B171 & B171 < ( C208 + $1 )) implies ( B170 . B171 ) = ( 0 ))) & (for B172 being Integer holds ((C208 > B172 or B172 >= ( C208 + $1 )) implies ( B170 . B172 ) = ( C206 . B172 ))))));
L730: (for B173 being (Element of ( NAT )) holds (S7[ B173 ] implies S7[ ( B173 + 1 ) ]))
proof
let C209 being (Element of ( NAT ));
assume L731: S7[ C209 ];
L732:
now
reconsider D261 = ( 0 ) as (Symbol of C202) by L725;
set D262 = ( C208 + C209 );
reconsider D263 = ( C208 + C209 ) as (Element of ( INT )) by INT_1:def 2;
assume L733: ( C209 + 1 ) <= C207;
consider C210 being (Tape of C202) such that L734: ( ( Computation C203 ) . C209 ) = [ C204 , ( C208 + C209 ) , C210 ] and L735: (for B174 being Integer holds ((C208 <= B174 & B174 < ( C208 + C209 )) implies ( C210 . B174 ) = ( 0 ))) and L736: (for B175 being Integer holds ((C208 > B175 or B175 >= ( C208 + C209 )) implies ( C210 . B175 ) = ( C206 . B175 ))) by L733 , L731 , NAT_1:13;
L737: C209 < C207 by L733 , NAT_1:13;
L738: D262 < ( C208 + C207 ) by L737 , XREAL_1:8;
L739: ( C210 . D263 ) = ( C206 . D263 ) by L736
.= 1 by L729 , L738 , NAT_1:11;
take D264 = ( Tape-Chg (C210 , D262 , D261) );
set D265 = [ C204 , D263 , C210 ];
reconsider D266 = ( D265 `3_3 ) as (Tape of C202);
L740: ( TRAN D265 ) = ( (the Tran of C202) . [ C204 , ( D266 . ( Head D265 ) ) ] )
.= ( (the Tran of C202) . [ C204 , ( C210 . ( Head D265 ) ) ] )
.= [ C204 , ( 0 ) , 1 ] by L727 , L739;
L741: ( offset ( TRAN D265 ) ) = 1 by L740 , MCART_1:64;
L742: ( Tape-Chg (( D265 `3_3 ) , ( Head D265 ) , ( ( TRAN D265 ) `2_3 )) ) = ( Tape-Chg (C210 , ( Head D265 ) , ( ( TRAN D265 ) `2_3 )) )
.= ( Tape-Chg (C210 , D262 , ( ( TRAN D265 ) `2_3 )) )
.= D264 by L740 , MCART_1:64;
thus L743: ( ( Computation C203 ) . ( C209 + 1 ) ) = ( Following D265 ) by L734 , L82
.= [ ( ( TRAN D265 ) `1_3 ) , ( ( Head D265 ) + ( offset ( TRAN D265 ) ) ) , D264 ] by L728 , L742 , L288
.= [ C204 , ( ( Head D265 ) + ( offset ( TRAN D265 ) ) ) , D264 ] by L740 , MCART_1:64
.= [ C204 , ( D262 + 1 ) , D264 ] by L741
.= [ C204 , ( C208 + ( C209 + 1 ) ) , D264 ];
thus L744:now
let C211 being Integer;
assume that
L745: C208 <= C211
and
L746: C211 < ( C208 + ( C209 + 1 ) );
per cases ;
suppose L747: C211 = D262;

thus L748: ( D264 . C211 ) = ( 0 ) by L747 , L297;
end;
suppose L749: C211 <> D262;

L750: C211 < ( ( C208 + C209 ) + 1 ) by L746;
L751: C211 <= ( C208 + C209 ) by L750 , INT_1:7;
L752: C211 < D262 by L751 , L749 , XXREAL_0:1;
thus L753: ( D264 . C211 ) = ( C210 . C211 ) by L749 , L297
.= ( 0 ) by L735 , L745 , L752;
end;
end;
thus L755:now
let C212 being Integer;
assume L756: (C208 > C212 or C212 >= ( C208 + ( C209 + 1 ) ));
per cases  by L756;
suppose L757: C208 > C212;

L758: C208 <= ( C208 + C209 ) by NAT_1:12;
thus L759: ( D264 . C212 ) = ( C210 . C212 ) by L758 , L757 , L297
.= ( C206 . C212 ) by L736 , L757;
end;
suppose L760: C212 >= ( C208 + ( C209 + 1 ) );

L761: C209 < ( C209 + 1 ) by NAT_1:13;
L762: ( C208 + C209 ) < ( C208 + ( C209 + 1 ) ) by L761 , XREAL_1:8;
L763: C212 > ( C208 + C209 ) by L762 , L760 , XXREAL_0:2;
thus L764: ( D264 . C212 ) = ( C210 . C212 ) by L760 , L762 , L297
.= ( C206 . C212 ) by L736 , L763;
end;
end;
end;
thus L756: thesis by L732;
end;
L757: S7[ ( 0 ) ]
proof
assume L758: ( 0 ) <= C207;
take D267 = C206;
thus L759: ( ( Computation C203 ) . ( 0 ) ) = [ C204 , ( C208 + ( 0 ) ) , D267 ] by L724 , L726 , L82;
thus L760: (for B176 being Integer holds ((C208 <= B176 & B176 < ( C208 + ( 0 ) )) implies ( D267 . B176 ) = ( 0 )));
thus L761: thesis;
end;
L762: (for R4 being (Element of ( NAT )) holds S7[ R4 ]) from NAT_1:sch 1(L757 , L730);
thus L763: thesis by L762;
end;
theorem
L764: (for B177 being (All-State of ( U3(n)Turing )) holds (for B178 being (Tape of ( U3(n)Turing )) holds (for B179 being (Element of ( NAT )) holds (for B180 being (FinSequence of ( NAT )) holds ((( len B180 ) >= 3 & B177 = [ ( 0 ) , B179 , B178 ] & B178 storeData ( <* B179 *> ^ B180 )) implies (B177 is  Accept-Halt & ( ( Result B177 ) `2_3 ) = ( ( ( B179 + ( B180 /. 1 ) ) + ( B180 /. 2 ) ) + 4 ) & ( ( Result B177 ) `3_3 ) storeData <* ( ( ( B179 + ( B180 /. 1 ) ) + ( B180 /. 2 ) ) + 4 ) , ( B180 /. 3 ) *>))))))
proof
reconsider D268 = ( 0 ) as (Symbol of ( U3(n)Turing )) by L716;
let C213 being (All-State of ( U3(n)Turing ));
let C214 being (Tape of ( U3(n)Turing ));
let C215 being (Element of ( NAT ));
let C216 being (FinSequence of ( NAT ));
assume that
L765: ( len C216 ) >= 3
and
L766: C213 = [ ( 0 ) , C215 , C214 ]
and
L767: C214 storeData ( <* C215 *> ^ C216 );
set D269 = ( ( C215 + ( C216 /. 1 ) ) + 2 );
set D270 = ( ( ( C215 + ( C216 /. 1 ) ) + ( C216 /. 2 ) ) + 4 );
set D271 = ( ( ( ( C215 + ( C216 /. 1 ) ) + ( C216 /. 2 ) ) + ( C216 /. 3 ) ) + 6 );
reconsider D272 = ( C213 `3_3 ) as (Tape of ( U3(n)Turing ));
L768: C214 is_1_between C215 , D269 by L765 , L767 , L260;
L769: ( C214 . C215 ) = ( 0 ) by L768 , L162;
L770: ( TRAN C213 ) = ( ( U3(n)Tran ) . [ ( C213 `1_3 ) , ( D272 . ( Head C213 ) ) ] ) by L709
.= ( ( U3(n)Tran ) . [ ( 0 ) , ( D272 . ( Head C213 ) ) ] ) by L766 , MCART_1:64
.= ( ( U3(n)Tran ) . [ ( 0 ) , ( C214 . ( Head C213 ) ) ] ) by L766 , MCART_1:64
.= [ 1 , ( 0 ) , 1 ] by L766 , L769 , L703 , MCART_1:64;
L771: ( offset ( TRAN C213 ) ) = 1 by L770 , MCART_1:64;
reconsider D273 = 1 as (State of ( U3(n)Turing )) by L712;
set D274 = ( ( C216 /. 1 ) + 1 );
reconsider D275 = ( C215 + 1 ) as (Element of ( INT )) by INT_1:def 2;
set D276 = [ D273 , D275 , C214 ];
L772: C214 is_1_between D269 , D270 by L765 , L767 , L260;
L773: ( C214 . D270 ) = ( 0 ) by L772 , L162;
L774: ( Tape-Chg (( C213 `3_3 ) , ( Head C213 ) , ( ( TRAN C213 ) `2_3 )) ) = ( Tape-Chg (C214 , ( Head C213 ) , ( ( TRAN C213 ) `2_3 )) ) by L766 , MCART_1:64
.= ( Tape-Chg (C214 , C215 , ( ( TRAN C213 ) `2_3 )) ) by L766 , MCART_1:64
.= ( Tape-Chg (C214 , C215 , D268) ) by L770 , MCART_1:64
.= C214 by L769 , L280;
L775: ( Following C213 ) = [ ( ( TRAN C213 ) `1_3 ) , ( ( Head C213 ) + ( offset ( TRAN C213 ) ) ) , C214 ] by L774 , L766 , L719
.= [ 1 , ( ( Head C213 ) + ( offset ( TRAN C213 ) ) ) , C214 ] by L770 , MCART_1:64
.= D276 by L766 , L771 , MCART_1:64;
L776: C214 is_1_between D270 , D271 by L765 , L767 , L260;
L777: ( C214 . D271 ) = ( 0 ) by L776 , L162;
reconsider D277 = 2 as (State of ( U3(n)Turing )) by L712;
set D278 = ( ( Computation D276 ) . D274 );
reconsider D279 = ( D278 `3_3 ) as (Tape of ( U3(n)Turing ));
set D280 = ( ( ( C215 + 1 ) + D274 ) + 1 );
reconsider D281 = D280 as (Element of ( INT )) by INT_1:def 2;
set D282 = ( ( C216 /. 2 ) + 1 );
set D283 = ( ( Computation C213 ) . ( ( ( ( D282 + 1 ) + 1 ) + D274 ) + 1 ) );
set D284 = ( ( D270 + ( C216 /. 3 ) ) + 2 );
L778:
now
let C217 being Integer;
assume that
L779: ( C215 + 1 ) <= C217
and
L780: C217 < ( ( C215 + 1 ) + D274 );
L781: C215 < ( C215 + 1 ) by XREAL_1:29;
L782: C215 < C217 by L781 , L779 , XXREAL_0:2;
thus L783: ( C214 . C217 ) = 1 by L782 , L768 , L780 , L162;
end;
L784: (( (the Tran of ( U3(n)Turing )) . [ D273 , 1 ] ) = [ D273 , ( 0 ) , 1 ] & D273 <> (the AcceptS of ( U3(n)Turing ))) by L709 , L703;
consider C218 being (Tape of ( U3(n)Turing )) such that L785: D278 = [ D273 , ( ( C215 + 1 ) + D274 ) , C218 ] and L786: (for B181 being Integer holds ((( C215 + 1 ) <= B181 & B181 < ( ( C215 + 1 ) + D274 )) implies ( C218 . B181 ) = ( 0 ))) and L787: (for B182 being Integer holds ((( C215 + 1 ) > B182 or B182 >= ( ( C215 + 1 ) + D274 )) implies ( C218 . B182 ) = ( C214 . B182 ))) by L784 , L778 , L716 , L723;
L788: ( C214 . D269 ) = ( 0 ) by L768 , L162;
L789: ( C218 . ( ( C215 + 1 ) + D274 ) ) = ( 0 ) by L788 , L787;
L790: ( TRAN D278 ) = ( ( U3(n)Tran ) . [ ( D278 `1_3 ) , ( D279 . ( Head D278 ) ) ] ) by L709
.= ( ( U3(n)Tran ) . [ D273 , ( D279 . ( Head D278 ) ) ] ) by L785 , MCART_1:64
.= ( ( U3(n)Tran ) . [ 1 , ( C218 . ( Head D278 ) ) ] ) by L785 , MCART_1:64
.= [ 2 , ( 0 ) , 1 ] by L785 , L789 , L703 , MCART_1:64;
L791: ( offset ( TRAN D278 ) ) = 1 by L790 , MCART_1:64;
set D285 = [ D277 , D281 , C218 ];
L792: ( Tape-Chg (( D278 `3_3 ) , ( Head D278 ) , ( ( TRAN D278 ) `2_3 )) ) = ( Tape-Chg (C218 , ( Head D278 ) , ( ( TRAN D278 ) `2_3 )) ) by L785 , MCART_1:64
.= ( Tape-Chg (C218 , ( ( C215 + 1 ) + D274 ) , ( ( TRAN D278 ) `2_3 )) ) by L785 , MCART_1:64
.= ( Tape-Chg (C218 , ( ( C215 + 1 ) + D274 ) , D268) ) by L790 , MCART_1:64
.= C218 by L789 , L280;
L793: ( Following D278 ) = [ ( ( TRAN D278 ) `1_3 ) , ( ( Head D278 ) + ( offset ( TRAN D278 ) ) ) , C218 ] by L792 , L785 , L719
.= [ 2 , ( ( Head D278 ) + ( offset ( TRAN D278 ) ) ) , C218 ] by L790 , MCART_1:64
.= D285 by L785 , L791 , MCART_1:64;
L794:
now
let C219 being Integer;
assume that
L795: D280 <= C219
and
L796: C219 < ( D280 + D282 );
L797: ( ( C215 + 1 ) + D274 ) < D280 by XREAL_1:29;
L798: ( ( C215 + 1 ) + D274 ) < C219 by L797 , L795 , XXREAL_0:2;
thus L799: ( C218 . C219 ) = ( C214 . C219 ) by L798 , L787
.= 1 by L772 , L796 , L798 , L162;
end;
set D286 = ( ( Computation D285 ) . D282 );
reconsider D287 = ( D286 `3_3 ) as (Tape of ( U3(n)Turing ));
L800: (( (the Tran of ( U3(n)Turing )) . [ D277 , 1 ] ) = [ D277 , ( 0 ) , 1 ] & D277 <> (the AcceptS of ( U3(n)Turing ))) by L709 , L703;
consider C220 being (Tape of ( U3(n)Turing )) such that L801: D286 = [ D277 , ( D280 + D282 ) , C220 ] and L802: (for B183 being Integer holds ((D280 <= B183 & B183 < ( D280 + D282 )) implies ( C220 . B183 ) = ( 0 ))) and L803: (for B184 being Integer holds ((D280 > B184 or B184 >= ( D280 + D282 )) implies ( C220 . B184 ) = ( C218 . B184 ))) by L800 , L794 , L716 , L723;
L804: 2 <= ( ( C216 /. 2 ) + 4 ) by NAT_1:12;
L805: D269 <= ( ( C215 + ( C216 /. 1 ) ) + ( ( C216 /. 2 ) + 4 ) ) by L804 , XREAL_1:7;
L806:
now
let C221 being Integer;
assume that
L807: D270 < C221
and
L808: C221 < D284;
L809: D269 <= C221 by L805 , L807 , XXREAL_0:2;
thus L810: ( C220 . C221 ) = ( C218 . C221 ) by L803 , L807
.= ( C214 . C221 ) by L787 , L809
.= 1 by L776 , L807 , L808 , L162;
end;
L811: ( C220 . ( D280 + D282 ) ) = ( C218 . ( D280 + D282 ) ) by L803
.= ( 0 ) by L773 , L787 , L805;
L812: ( TRAN D286 ) = ( ( U3(n)Tran ) . [ ( D286 `1_3 ) , ( D287 . ( Head D286 ) ) ] ) by L709
.= ( ( U3(n)Tran ) . [ D277 , ( D287 . ( Head D286 ) ) ] ) by L801 , MCART_1:64
.= ( ( U3(n)Tran ) . [ 2 , ( C220 . ( Head D286 ) ) ] ) by L801 , MCART_1:64
.= [ 3 , ( 0 ) , ( 0 ) ] by L801 , L811 , L703 , MCART_1:64;
L813: ( offset ( TRAN D286 ) ) = ( 0 ) by L812 , MCART_1:64;
L814: ( Tape-Chg (( D286 `3_3 ) , ( Head D286 ) , ( ( TRAN D286 ) `2_3 )) ) = ( Tape-Chg (C220 , ( Head D286 ) , ( ( TRAN D286 ) `2_3 )) ) by L801 , MCART_1:64
.= ( Tape-Chg (C220 , ( D280 + D282 ) , ( ( TRAN D286 ) `2_3 )) ) by L801 , MCART_1:64
.= ( Tape-Chg (C220 , ( D280 + D282 ) , D268) ) by L812 , MCART_1:64
.= C220 by L811 , L280;
L815: ( Following D286 ) = [ ( ( TRAN D286 ) `1_3 ) , ( ( Head D286 ) + ( offset ( TRAN D286 ) ) ) , C220 ] by L814 , L801 , L719
.= [ 3 , ( ( Head D286 ) + ( offset ( TRAN D286 ) ) ) , C220 ] by L812 , MCART_1:64
.= [ 3 , ( ( D280 + D282 ) + ( 0 ) ) , C220 ] by L801 , L813 , MCART_1:64;
L816: D283 = ( ( Computation ( ( Computation C213 ) . 1 ) ) . ( ( ( D282 + 1 ) + 1 ) + D274 ) ) by L101
.= ( ( Computation D276 ) . ( ( ( D282 + 1 ) + 1 ) + D274 ) ) by L775 , L98
.= ( ( Computation D278 ) . ( ( D282 + 1 ) + 1 ) ) by L101;
L817: D283 = ( ( Computation ( ( Computation D278 ) . 1 ) ) . ( D282 + 1 ) ) by L816 , L101
.= ( ( Computation D285 ) . ( D282 + 1 ) ) by L793 , L98
.= [ 3 , ( D280 + D282 ) , C220 ] by L815 , L82;
L818: ( D283 `1_3 ) = 3 by L817 , MCART_1:64
.= (the AcceptS of ( U3(n)Turing )) by L709;
thus L819: C213 is  Accept-Halt by L818 , L124;
L820: ( Result C213 ) = D283 by L819 , L818 , L127;
thus L821: ( ( Result C213 ) `2_3 ) = D270 by L820 , L817 , MCART_1:64;
L822: ( ( Result C213 ) `3_3 ) = C220 by L817 , L820 , MCART_1:64;
L823: D270 <= ( D270 + ( ( C216 /. 3 ) + 2 ) ) by NAT_1:11;
L824: D269 <= D284 by L823 , L805 , XXREAL_0:2;
L825: ( C220 . D284 ) = ( C218 . D284 ) by L803 , L823
.= ( 0 ) by L777 , L787 , L824;
L826: C220 is_1_between D270 , ( ( D270 + ( C216 /. 3 ) ) + 2 ) by L825 , L811 , L806 , L162;
thus L827: thesis by L826 , L822 , L171;
end;
theorem
L828: (for R1 being (Element of ( NAT )) holds (R1 >= 3 implies ( U3(n)Turing ) computes ( R1 proj 3 )))
proof
let R1 being (Element of ( NAT ));
assume L829: R1 >= 3;
L830:
now
set D288 = ( R1 proj 3 );
let C222 being (All-State of ( U3(n)Turing ));
let C223 being (Tape of ( U3(n)Turing ));
let C224 being (Element of ( NAT ));
let C225 being (FinSequence of ( NAT ));
assume that
L831: C225 in ( dom D288 )
and
L832: C222 = [ (the InitS of ( U3(n)Turing )) , C224 , C223 ]
and
L833: C223 storeData ( <* C224 *> ^ C225 );
L834: ( arity D288 ) = R1 by COMPUT_1:37;
L835: ( dom D288 ) c= ( R1 -tuples_on ( NAT ) ) by L834 , COMPUT_1:21;
L836: C225 in ( R1 -tuples_on ( NAT ) ) by L835 , L831;
L837: C225 in { B185 where B185 is (Element of ( ( NAT ) * )) : ( len B185 ) = R1 } by L836 , FINSEQ_2:def 4;
L838: (ex B186 being (Element of ( ( NAT ) * )) st (C225 = B186 & ( len B186 ) = R1)) by L837;
L839: C222 = [ ( 0 ) , C224 , C223 ] by L832 , L709;
thus L840: C222 is  Accept-Halt by L839 , L829 , L833 , L838 , L764;
take D289 = ( ( ( C224 + ( C225 /. 1 ) ) + ( C225 /. 2 ) ) + 4 );
take D290 = ( C225 /. 3 );
thus L841: ( ( Result C222 ) `2_3 ) = D289 by L829 , L833 , L838 , L839 , L764;
thus L842: D290 = ( C225 . 3 ) by L829 , L838 , FINSEQ_4:15
.= ( D288 . C225 ) by L831 , L835 , COMPUT_1:38;
L843: ( ( Result C222 ) `3_3 ) storeData <* D289 , D290 *> by L829 , L833 , L838 , L839 , L764;
thus L844: ( ( Result C222 ) `3_3 ) storeData ( <* D289 *> ^ <* D290 *> ) by L843;
end;
thus L845: thesis by L830 , L443;
end;
begin
definition
let C226 , C227 being TuringStr;
func UnionSt (C226 , C227) ->  finite non  empty set equals 
( [: (the FStates of C226) , { (the InitS of C227) } :] \/ [: { (the AcceptS of C226) } , (the FStates of C227) :] );
correctness;
end;
theorem
L847: (for B187 , B188 being TuringStr holds ([ (the InitS of B187) , (the InitS of B188) ] in ( UnionSt (B187 , B188) ) & [ (the AcceptS of B187) , (the AcceptS of B188) ] in ( UnionSt (B187 , B188) )))
proof
let C228 , C229 being TuringStr;
set D291 = (the InitS of C228);
set D292 = (the InitS of C229);
set D293 = (the AcceptS of C228);
set D294 = (the AcceptS of C229);
set D295 = [: (the FStates of C228) , { D292 } :];
set D296 = [: { D293 } , (the FStates of C229) :];
reconsider D297 = D292 as (Element of { D292 }) by TARSKI:def 1;
reconsider D298 = D293 as (Element of { D293 }) by TARSKI:def 1;
L848: [ D291 , D297 ] in D295;
thus L849: [ D291 , D292 ] in ( UnionSt (C228 , C229) ) by L848 , XBOOLE_0:def 3;
L850: [ D298 , D294 ] in D296;
thus L851: thesis by L850 , XBOOLE_0:def 3;
end;
theorem
L852: (for B189 , B190 being TuringStr holds (for B191 being (State of B189) holds [ B191 , (the InitS of B190) ] in ( UnionSt (B189 , B190) )))
proof
let C230 , C231 being TuringStr;
let C232 being (State of C230);
set D299 = (the InitS of C231);
set D300 = [: (the FStates of C230) , { D299 } :];
reconsider D301 = D299 as (Element of { D299 }) by TARSKI:def 1;
L853: [ C232 , D301 ] in D300;
thus L854: thesis by L853 , XBOOLE_0:def 3;
end;
theorem
L855: (for B192 , B193 being TuringStr holds (for B194 being (State of B193) holds [ (the AcceptS of B192) , B194 ] in ( UnionSt (B192 , B193) )))
proof
let C233 , C234 being TuringStr;
let C235 being (State of C234);
set D302 = (the AcceptS of C233);
set D303 = [: { D302 } , (the FStates of C234) :];
reconsider D304 = D302 as (Element of { D302 }) by TARSKI:def 1;
L856: [ D304 , C235 ] in D303;
thus L857: thesis by L856 , XBOOLE_0:def 3;
end;
theorem
L858: (for B195 , B196 being TuringStr holds (for B197 being (Element of ( UnionSt (B195 , B196) )) holds (ex B198 being (State of B195) st (ex B199 being (State of B196) st B197 = [ B198 , B199 ]))))
proof
let C236 , C237 being TuringStr;
let C238 being (Element of ( UnionSt (C236 , C237) ));
set D305 = (the InitS of C237);
set D306 = (the AcceptS of C236);
set D307 = [: (the FStates of C236) , { D305 } :];
set D308 = [: { D306 } , (the FStates of C237) :];
per cases  by XBOOLE_0:def 3;
suppose L859: C238 in D307;

consider C239 being (State of C236), C240 being (Element of { D305 }) such that L860: C238 = [ C239 , C240 ] by L859 , DOMAIN_1:1;
take C239;
take D305;
thus L861: thesis by L860 , TARSKI:def 1;
end;
suppose L862: C238 in D308;

consider C241 being (Element of { D306 }), C242 being (State of C237) such that L863: C238 = [ C241 , C242 ] by L862 , DOMAIN_1:1;
take D306;
take C242;
thus L864: thesis by L863 , TARSKI:def 1;
end;
end;
definition
let C243 , C244 being TuringStr;
let C245 being (Tran-Goal of C243);
func FirstTuringTran (C243 , C244 , C245) -> (Element of [: ( UnionSt (C243 , C244) ) , ( (the Symbols of C243) \/ (the Symbols of C244) ) , { ( - 1 ) , ( 0 ) , 1 } :]) equals 
[ [ ( C245 `1_3 ) , (the InitS of C244) ] , ( C245 `2_3 ) , ( C245 `3_3 ) ];
coherence
proof
reconsider D309 = [ ( C245 `1_3 ) , (the InitS of C244) ] as (Element of ( UnionSt (C243 , C244) )) by L852;
set D310 = ( (the Symbols of C243) \/ (the Symbols of C244) );
reconsider D311 = ( C245 `2_3 ) as (Element of D310) by XBOOLE_0:def 3;
L866: [ D309 , D311 , ( C245 `3_3 ) ] in [: ( UnionSt (C243 , C244) ) , D310 , { ( - 1 ) , ( 0 ) , 1 } :];
thus L867: thesis by L866;
end;
end;
definition
let C246 , C247 being TuringStr;
let C248 being (Tran-Goal of C247);
func SecondTuringTran (C246 , C247 , C248) -> (Element of [: ( UnionSt (C246 , C247) ) , ( (the Symbols of C246) \/ (the Symbols of C247) ) , { ( - 1 ) , ( 0 ) , 1 } :]) equals 
[ [ (the AcceptS of C246) , ( C248 `1_3 ) ] , ( C248 `2_3 ) , ( C248 `3_3 ) ];
coherence
proof
reconsider D312 = [ (the AcceptS of C246) , ( C248 `1_3 ) ] as (Element of ( UnionSt (C246 , C247) )) by L855;
set D313 = ( (the Symbols of C246) \/ (the Symbols of C247) );
reconsider D314 = ( C248 `2_3 ) as (Element of D313) by XBOOLE_0:def 3;
L869: [ D312 , D314 , ( C248 `3_3 ) ] in [: ( UnionSt (C246 , C247) ) , D313 , { ( - 1 ) , ( 0 ) , 1 } :];
thus L870: thesis by L869;
end;
end;
definition
let C249 , C250 being TuringStr;
let C251 being (Element of ( UnionSt (C249 , C250) ));
redefine func C251 `1 -> (State of C249);

coherence
proof
consider C252 being (State of C249), C253 being (State of C250) such that L872: C251 = [ C252 , C253 ] by L858;
L873: ( [ C252 , C253 ] `1 ) = C252;
thus L874: thesis by L873 , L872;
end;
redefine func C251 `2 -> (State of C250);

coherence
proof
consider C254 being (State of C249), C255 being (State of C250) such that L875: C251 = [ C254 , C255 ] by L858;
L876: ( [ C254 , C255 ] `2 ) = C255;
thus L877: thesis by L876 , L875;
end;
end;
definition
let C256 , C257 being TuringStr;
let C258 being (Element of [: ( UnionSt (C256 , C257) ) , ( (the Symbols of C256) \/ (the Symbols of C257) ) :]);
func FirstTuringState C258 -> (State of C256) equals 
( ( C258 `1 ) `1 );
correctness;
func SecondTuringState C258 -> (State of C257) equals 
( ( C258 `1 ) `2 );
correctness;
end;
definition
let C259 , C260 , C261 being non  empty set;
let C262 being (Element of [: C259 , ( C260 \/ C261 ) :]);
given C263 being set , C264 being (Element of C260) such that
L880: C262 = [ C263 , C264 ];

L881: ( [ C263 , C264 ] `2 ) = C264;
func FirstTuringSymbol C262 -> (Element of C260) equals 
:L882: ( C262 `2 );
coherence by L880 , L881;
end;
definition
let C265 , C266 , C267 being non  empty set;
let C268 being (Element of [: C265 , ( C266 \/ C267 ) :]);
given C269 being set , C270 being (Element of C267) such that
L884: C268 = [ C269 , C270 ];

L885: ( [ C269 , C270 ] `2 ) = C270;
func SecondTuringSymbol C268 -> (Element of C267) equals 
:L886: ( C268 `2 );
coherence by L884 , L885;
end;
definition
let C271 , C272 being TuringStr;
let C273 being (Element of [: ( UnionSt (C271 , C272) ) , ( (the Symbols of C271) \/ (the Symbols of C272) ) :]);
func Uniontran (C271 , C272 , C273) -> (Element of [: ( UnionSt (C271 , C272) ) , ( (the Symbols of C271) \/ (the Symbols of C272) ) , { ( - 1 ) , ( 0 ) , 1 } :]) equals 
:L888: ( FirstTuringTran (C271 , C272 , ( (the Tran of C271) . [ ( FirstTuringState C273 ) , ( FirstTuringSymbol C273 ) ] )) ) if (ex B200 being (State of C271) st (ex B201 being (Symbol of C271) st (C273 = [ [ B200 , (the InitS of C272) ] , B201 ] & B200 <> (the AcceptS of C271)))) , ( SecondTuringTran (C271 , C272 , ( (the Tran of C272) . [ ( SecondTuringState C273 ) , ( SecondTuringSymbol C273 ) ] )) ) if (ex B202 being (State of C272) st (ex B203 being (Symbol of C272) st C273 = [ [ (the AcceptS of C271) , B202 ] , B203 ])) otherwise [ ( C273 `1 ) , ( C273 `2 ) , ( - 1 ) ];
consistency
proof
let C274 being (Element of [: ( UnionSt (C271 , C272) ) , ( (the Symbols of C271) \/ (the Symbols of C272) ) , { ( - 1 ) , ( 0 ) , 1 } :]);
thus L889: (((ex B204 being (State of C271) st (ex B205 being (Symbol of C271) st (C273 = [ [ B204 , (the InitS of C272) ] , B205 ] & B204 <> (the AcceptS of C271)))) & (ex B206 being (State of C272) st (ex B207 being (Symbol of C272) st C273 = [ [ (the AcceptS of C271) , B206 ] , B207 ]))) implies (C274 = ( FirstTuringTran (C271 , C272 , ( (the Tran of C271) . [ ( FirstTuringState C273 ) , ( FirstTuringSymbol C273 ) ] )) ) iff C274 = ( SecondTuringTran (C271 , C272 , ( (the Tran of C272) . [ ( SecondTuringState C273 ) , ( SecondTuringSymbol C273 ) ] )) )))
proof
given C275 being (State of C271) , C276 being (Symbol of C271) such that
L890: C273 = [ [ C275 , (the InitS of C272) ] , C276 ]
and
L891: C275 <> (the AcceptS of C271);

given C277 being (State of C272) , C278 being (Symbol of C272) such that
L892: C273 = [ [ (the AcceptS of C271) , C277 ] , C278 ];

L893: [ C275 , (the InitS of C272) ] = [ (the AcceptS of C271) , C277 ] by L890 , L892 , XTUPLE_0:1;
thus L894: thesis by L893 , L891 , XTUPLE_0:1;
end;

end;
coherence
proof
reconsider D315 = ( - 1 ) as (Element of { ( - 1 ) , ( 0 ) , 1 }) by ENUMSET1:def 1;
L890: [ ( C273 `1 ) , ( C273 `2 ) , D315 ] in [: ( UnionSt (C271 , C272) ) , ( (the Symbols of C271) \/ (the Symbols of C272) ) , { ( - 1 ) , ( 0 ) , 1 } :];
thus L891: thesis by L890;
end;
end;
definition
let C279 , C280 being TuringStr;
func UnionTran (C279 , C280) -> (Function of [: ( UnionSt (C279 , C280) ) , ( (the Symbols of C279) \/ (the Symbols of C280) ) :] , [: ( UnionSt (C279 , C280) ) , ( (the Symbols of C279) \/ (the Symbols of C280) ) , { ( - 1 ) , ( 0 ) , 1 } :]) means 
:L893: (for B208 being (Element of [: ( UnionSt (C279 , C280) ) , ( (the Symbols of C279) \/ (the Symbols of C280) ) :]) holds ( it . B208 ) = ( Uniontran (C279 , C280 , B208) ));
existence
proof
set D316 = ( (the Symbols of C279) \/ (the Symbols of C280) );
set D317 = [: ( UnionSt (C279 , C280) ) , D316 :];
deffunc H5((Element of D317)) = ( Uniontran (C279 , C280 , $1) );
consider C281 being (Function of D317 , [: ( UnionSt (C279 , C280) ) , D316 , { ( - 1 ) , ( 0 ) , 1 } :]) such that L894: (for B209 being (Element of D317) holds ( C281 . B209 ) = H5(B209)) from FUNCT_2:sch 4;
take C281;
thus L895: thesis by L894;
end;
uniqueness
proof
set D318 = ( (the Symbols of C279) \/ (the Symbols of C280) );
set D319 = [: ( UnionSt (C279 , C280) ) , D318 :];
let C282 , C283 being (Function of D319 , [: ( UnionSt (C279 , C280) ) , D318 , { ( - 1 ) , ( 0 ) , 1 } :]);
assume that
L896: (for B210 being (Element of D319) holds ( C282 . B210 ) = ( Uniontran (C279 , C280 , B210) ))
and
L897: (for B211 being (Element of D319) holds ( C283 . B211 ) = ( Uniontran (C279 , C280 , B211) ));
L898:
now
let C284 being (Element of D319);
thus L899: ( C282 . C284 ) = ( Uniontran (C279 , C280 , C284) ) by L896
.= ( C283 . C284 ) by L897;
end;
thus L900: thesis by L898 , FUNCT_2:63;
end;
end;
definition
let C285 , C286 being TuringStr;
func C285 ';' C286 ->  strict TuringStr means 
:L902: ((the Symbols of it) = ( (the Symbols of C285) \/ (the Symbols of C286) ) & (the FStates of it) = ( UnionSt (C285 , C286) ) & (the Tran of it) = ( UnionTran (C285 , C286) ) & (the InitS of it) = [ (the InitS of C285) , (the InitS of C286) ] & (the AcceptS of it) = [ (the AcceptS of C285) , (the AcceptS of C286) ]);
existence
proof
set D320 = ( UnionSt (C285 , C286) );
reconsider D321 = [ (the AcceptS of C285) , (the AcceptS of C286) ] as (Element of D320) by L847;
reconsider D322 = [ (the InitS of C285) , (the InitS of C286) ] as (Element of D320) by L847;
set D323 = ( (the Symbols of C285) \/ (the Symbols of C286) );
take TuringStr (# D323 , D320 , ( UnionTran (C285 , C286) ) , D322 , D321 #);
thus L903: thesis;
end;
uniqueness;
end;
theorem
L905: (for B212 , B213 being TuringStr holds (for B214 being (Tran-Goal of B212) holds (for B215 being (State of B212) holds (for B216 being (Symbol of B212) holds ((B215 <> (the AcceptS of B212) & B214 = ( (the Tran of B212) . [ B215 , B216 ] )) implies ( (the Tran of ( B212 ';' B213 )) . [ [ B215 , (the InitS of B213) ] , B216 ] ) = [ [ ( B214 `1_3 ) , (the InitS of B213) ] , ( B214 `2_3 ) , ( B214 `3_3 ) ])))))
proof
let C287 , C288 being TuringStr;
let C289 being (Tran-Goal of C287);
let C290 being (State of C287);
let C291 being (Symbol of C287);
assume that
L906: C290 <> (the AcceptS of C287)
and
L907: C289 = ( (the Tran of C287) . [ C290 , C291 ] );
set D324 = (the InitS of C288);
set D325 = [ [ C290 , D324 ] , C291 ];
L908: D324 in { D324 } by TARSKI:def 1;
L909: [ C290 , D324 ] in [: (the FStates of C287) , { D324 } :] by L908 , ZFMISC_1:def 2;
L910: [ C290 , D324 ] in ( [: (the FStates of C287) , { D324 } :] \/ [: { (the AcceptS of C287) } , (the FStates of C288) :] ) by L909 , XBOOLE_0:def 3;
L911: C291 in ( (the Symbols of C287) \/ (the Symbols of C288) ) by XBOOLE_0:def 3;
reconsider D326 = D325 as (Element of [: ( UnionSt (C287 , C288) ) , ( (the Symbols of C287) \/ (the Symbols of C288) ) :]) by L911 , L910 , ZFMISC_1:def 2;
L912: ( FirstTuringState D326 ) = ( ( [ [ C290 , D324 ] , C291 ] `1 ) `1 )
.= ( [ C290 , D324 ] `1 )
.= C290;
L913: ( FirstTuringSymbol D326 ) = ( [ [ C290 , D324 ] , C291 ] `2 ) by L882
.= C291;
thus L914: ( (the Tran of ( C287 ';' C288 )) . D325 ) = ( ( UnionTran (C287 , C288) ) . D326 ) by L902
.= ( Uniontran (C287 , C288 , D326) ) by L893
.= ( FirstTuringTran (C287 , C288 , ( (the Tran of C287) . [ C290 , C291 ] )) ) by L906 , L912 , L913 , L888
.= [ [ ( C289 `1_3 ) , D324 ] , ( C289 `2_3 ) , ( C289 `3_3 ) ] by L907;
end;
theorem
L915: (for B217 , B218 being TuringStr holds (for B219 being (Tran-Goal of B218) holds (for B220 being (State of B218) holds (for B221 being (Symbol of B218) holds (B219 = ( (the Tran of B218) . [ B220 , B221 ] ) implies ( (the Tran of ( B217 ';' B218 )) . [ [ (the AcceptS of B217) , B220 ] , B221 ] ) = [ [ (the AcceptS of B217) , ( B219 `1_3 ) ] , ( B219 `2_3 ) , ( B219 `3_3 ) ])))))
proof
let C292 , C293 being TuringStr;
let C294 being (Tran-Goal of C293);
let C295 being (State of C293);
let C296 being (Symbol of C293);
assume L916: C294 = ( (the Tran of C293) . [ C295 , C296 ] );
set D327 = (the AcceptS of C292);
set D328 = [ [ D327 , C295 ] , C296 ];
L917: D327 in { D327 } by TARSKI:def 1;
L918: [ D327 , C295 ] in [: { D327 } , (the FStates of C293) :] by L917 , ZFMISC_1:def 2;
L919: [ D327 , C295 ] in ( [: (the FStates of C292) , { (the InitS of C293) } :] \/ [: { D327 } , (the FStates of C293) :] ) by L918 , XBOOLE_0:def 3;
L920: C296 in ( (the Symbols of C292) \/ (the Symbols of C293) ) by XBOOLE_0:def 3;
reconsider D329 = D328 as (Element of [: ( UnionSt (C292 , C293) ) , ( (the Symbols of C292) \/ (the Symbols of C293) ) :]) by L920 , L919 , ZFMISC_1:def 2;
L921: ( SecondTuringState D329 ) = ( ( [ [ D327 , C295 ] , C296 ] `1 ) `2 )
.= C295;
L922: ( SecondTuringSymbol D329 ) = ( [ [ D327 , C295 ] , C296 ] `2 ) by L886
.= C296;
thus L923: ( (the Tran of ( C292 ';' C293 )) . D328 ) = ( ( UnionTran (C292 , C293) ) . D329 ) by L902
.= ( Uniontran (C292 , C293 , D329) ) by L893
.= ( SecondTuringTran (C292 , C293 , ( (the Tran of C293) . [ C295 , C296 ] )) ) by L921 , L922 , L888
.= [ [ D327 , ( C294 `1_3 ) ] , ( C294 `2_3 ) , ( C294 `3_3 ) ] by L916;
end;
theorem
L924: (for B222 , B223 being TuringStr holds (for B224 being (All-State of B222) holds (for B225 being (Element of ( NAT )) holds (for B226 being (Tape of B222) holds (for B227 being (All-State of B223) holds (for B228 being (All-State of ( B222 ';' B223 )) holds ((B224 is  Accept-Halt & B224 = [ (the InitS of B222) , B225 , B226 ] & B227 is  Accept-Halt & B227 = [ (the InitS of B223) , ( ( Result B224 ) `2_3 ) , ( ( Result B224 ) `3_3 ) ] & B228 = [ (the InitS of ( B222 ';' B223 )) , B225 , B226 ]) implies (B228 is  Accept-Halt & ( ( Result B228 ) `2_3 ) = ( ( Result B227 ) `2_3 ) & ( ( Result B228 ) `3_3 ) = ( ( Result B227 ) `3_3 )))))))))
proof
let C297 , C298 being TuringStr;
let C299 being (All-State of C297);
let C300 being (Element of ( NAT ));
let C301 being (Tape of C297);
let C302 being (All-State of C298);
let C303 being (All-State of ( C297 ';' C298 ));
set D330 = (the InitS of C297);
set D331 = (the InitS of C298);
assume that
L925: C299 is  Accept-Halt
and
L926: C299 = [ D330 , C300 , C301 ]
and
L927: C302 is  Accept-Halt
and
L928: C302 = [ D331 , ( ( Result C299 ) `2_3 ) , ( ( Result C299 ) `3_3 ) ]
and
L929: C303 = [ (the InitS of ( C297 ';' C298 )) , C300 , C301 ];
set D332 = (the AcceptS of C297);
set D333 = (the AcceptS of C298);
consider R4 being (Element of ( NAT )) such that L930: ( ( ( Computation C299 ) . R4 ) `1_3 ) = D332 and L931: ( Result C299 ) = ( ( Computation C299 ) . R4 ) and L932: (for B229 being (Element of ( NAT )) holds (B229 < R4 implies ( ( ( Computation C299 ) . B229 ) `1_3 ) <> D332)) by L925 , L135;
defpred S8[ (Element of ( NAT )) ] means ($1 <= R4 implies ([ ( ( ( Computation C299 ) . $1 ) `1_3 ) , D331 ] = ( ( ( Computation C303 ) . $1 ) `1_3 ) & ( ( ( Computation C299 ) . $1 ) `2_3 ) = ( ( ( Computation C303 ) . $1 ) `2_3 ) & ( ( ( Computation C299 ) . $1 ) `3_3 ) = ( ( ( Computation C303 ) . $1 ) `3_3 )));
L933: (for R2 being (Element of ( NAT )) holds (S8[ R2 ] implies S8[ ( R2 + 1 ) ]))
proof
let R2 being (Element of ( NAT ));
assume L934: S8[ R2 ];
L935:
now
set D334 = ( ( Computation C299 ) . ( R2 + 1 ) );
set D335 = ( ( Computation C299 ) . R2 );
set D336 = ( ( Computation C303 ) . ( R2 + 1 ) );
set D337 = ( ( Computation C303 ) . R2 );
L936: R2 < ( R2 + 1 ) by XREAL_1:29;
set D338 = ( TRAN D337 );
reconsider D339 = ( Head D335 ) as (Element of ( INT ));
reconsider D340 = ( D335 `3_3 ) as (Tape of C297);
reconsider D341 = ( D340 . D339 ) as (Symbol of C297);
reconsider D342 = ( D337 `3_3 ) as (Tape of ( C297 ';' C298 ));
set D343 = ( D335 `1_3 );
set D344 = ( TRAN D335 );
assume L937: ( R2 + 1 ) <= R4;
L938: R2 < R4 by L937 , L936 , XXREAL_0:2;
L939: D343 <> D332 by L938 , L932;
L940: ( D337 `1_3 ) <> (the AcceptS of ( C297 ';' C298 ))
proof
assume L941: ( D337 `1_3 ) = (the AcceptS of ( C297 ';' C298 ));
L942: [ D343 , D331 ] = [ D332 , D333 ] by L941 , L934 , L937 , L936 , L902 , XXREAL_0:2;
thus L943: contradiction by L942 , L939 , XTUPLE_0:1;
end;
L944: D338 = ( (the Tran of ( C297 ';' C298 )) . [ [ D343 , D331 ] , D341 ] ) by L934 , L937 , L936 , XXREAL_0:2
.= [ [ ( D344 `1_3 ) , D331 ] , ( D344 `2_3 ) , ( D344 `3_3 ) ] by L932 , L938 , L905;
L945: ( D344 `2_3 ) = ( D338 `2_3 ) by L944 , MCART_1:def 6;
L946: D336 = ( Following D337 ) by L82
.= [ ( D338 `1_3 ) , ( ( Head D337 ) + ( offset D338 ) ) , ( Tape-Chg (D342 , ( Head D337 ) , ( D338 `2_3 )) ) ] by L940 , L78;
L947: D334 = ( Following D335 ) by L82
.= [ ( D344 `1_3 ) , ( D339 + ( offset D344 ) ) , ( Tape-Chg (D340 , D339 , ( D344 `2_3 )) ) ] by L939 , L78;
thus L948: [ ( D334 `1_3 ) , D331 ] = [ ( D344 `1_3 ) , D331 ] by L947 , MCART_1:def 5
.= ( D338 `1_3 ) by L944 , MCART_1:def 5
.= ( D336 `1_3 ) by L946 , MCART_1:def 5;
L949: ( offset D344 ) = ( offset D338 ) by L944 , MCART_1:def 7;
thus L950: ( D334 `2_3 ) = ( ( Head D337 ) + ( offset D338 ) ) by L949 , L934 , L937 , L936 , L947 , MCART_1:def 6 , XXREAL_0:2
.= ( D336 `2_3 ) by L946 , MCART_1:def 6;
thus L951: ( D334 `3_3 ) = ( D342 +* ( D339 .--> ( D344 `2_3 ) ) ) by L934 , L937 , L936 , L947 , MCART_1:def 7 , XXREAL_0:2
.= ( D336 `3_3 ) by L934 , L937 , L936 , L945 , L946 , MCART_1:def 7 , XXREAL_0:2;
end;
thus L952: thesis by L935;
end;
set D345 = ( ( Computation C299 ) . R4 );
set D346 = ( ( Computation C303 ) . R4 );
L953: C303 = [ [ D330 , D331 ] , C300 , C301 ] by L929 , L902;
L954: S8[ ( 0 ) ]
proof
assume L955: ( 0 ) <= R4;
L956: ( ( ( Computation C303 ) . ( 0 ) ) `1_3 ) = ( C303 `1_3 ) by L82
.= [ D330 , D331 ] by L953 , MCART_1:64;
L957: ( ( ( Computation C299 ) . ( 0 ) ) `1_3 ) = ( C299 `1_3 ) by L82
.= D330 by L926 , MCART_1:64;
thus L958: [ ( ( ( Computation C299 ) . ( 0 ) ) `1_3 ) , D331 ] = ( ( ( Computation C303 ) . ( 0 ) ) `1_3 ) by L957 , L956;
thus L959: ( ( ( Computation C299 ) . ( 0 ) ) `2_3 ) = ( C299 `2_3 ) by L82
.= C300 by L926 , MCART_1:64
.= ( C303 `2_3 ) by L929 , MCART_1:64
.= ( ( ( Computation C303 ) . ( 0 ) ) `2_3 ) by L82;
thus L960: ( ( ( Computation C299 ) . ( 0 ) ) `3_3 ) = ( C299 `3_3 ) by L82
.= C301 by L926 , MCART_1:64
.= ( C303 `3_3 ) by L929 , MCART_1:64
.= ( ( ( Computation C303 ) . ( 0 ) ) `3_3 ) by L82;
end;
L961: (for R2 being (Element of ( NAT )) holds S8[ R2 ]) from NAT_1:sch 1(L954 , L933);
L962: ( D345 `2_3 ) = ( D346 `2_3 ) by L961;
consider C304 being (Element of ( NAT )) such that L963: ( ( ( Computation C302 ) . C304 ) `1_3 ) = D333 and L964: ( Result C302 ) = ( ( Computation C302 ) . C304 ) and L965: (for B230 being (Element of ( NAT )) holds (B230 < C304 implies ( ( ( Computation C302 ) . B230 ) `1_3 ) <> D333)) by L927 , L135;
defpred S9[ (Element of ( NAT )) ] means ($1 <= C304 implies ([ D332 , ( ( ( Computation C302 ) . $1 ) `1_3 ) ] = ( ( ( Computation D346 ) . $1 ) `1_3 ) & ( ( ( Computation C302 ) . $1 ) `2_3 ) = ( ( ( Computation D346 ) . $1 ) `2_3 ) & ( ( ( Computation C302 ) . $1 ) `3_3 ) = ( ( ( Computation D346 ) . $1 ) `3_3 )));
L966: (for R2 being (Element of ( NAT )) holds (S9[ R2 ] implies S9[ ( R2 + 1 ) ]))
proof
let R2 being (Element of ( NAT ));
assume L967: S9[ R2 ];
L968:
now
set D347 = ( ( Computation C302 ) . ( R2 + 1 ) );
set D348 = ( ( Computation C302 ) . R2 );
set D349 = ( ( Computation D346 ) . ( R2 + 1 ) );
set D350 = ( ( Computation D346 ) . R2 );
L969: R2 < ( R2 + 1 ) by XREAL_1:29;
reconsider D351 = ( D350 `3_3 ) as (Tape of ( C297 ';' C298 ));
set D352 = ( TRAN D350 );
set D353 = ( D348 `1_3 );
set D354 = ( TRAN D348 );
reconsider D355 = ( Head D348 ) as (Element of ( INT ));
reconsider D356 = ( D348 `3_3 ) as (Tape of C298);
reconsider D357 = ( D356 . D355 ) as (Symbol of C298);
assume L970: ( R2 + 1 ) <= C304;
L971: D352 = ( (the Tran of ( C297 ';' C298 )) . [ [ D332 , D353 ] , D357 ] ) by L970 , L967 , L969 , XXREAL_0:2
.= [ [ D332 , ( D354 `1_3 ) ] , ( D354 `2_3 ) , ( D354 `3_3 ) ] by L915;
L972: ( D354 `2_3 ) = ( D352 `2_3 ) by L971 , MCART_1:def 6;
L973: R2 < C304 by L970 , L969 , XXREAL_0:2;
L974: D353 <> D333 by L973 , L965;
L975: ( D350 `1_3 ) <> (the AcceptS of ( C297 ';' C298 ))
proof
assume L976: ( D350 `1_3 ) = (the AcceptS of ( C297 ';' C298 ));
L977: [ D332 , D353 ] = [ D332 , D333 ] by L976 , L967 , L970 , L969 , L902 , XXREAL_0:2;
thus L978: contradiction by L977 , L974 , XTUPLE_0:1;
end;
L979: D349 = ( Following D350 ) by L82
.= [ ( D352 `1_3 ) , ( ( Head D350 ) + ( offset D352 ) ) , ( Tape-Chg (D351 , ( Head D350 ) , ( D352 `2_3 )) ) ] by L975 , L78;
L980: D347 = ( Following D348 ) by L82
.= [ ( D354 `1_3 ) , ( D355 + ( offset D354 ) ) , ( Tape-Chg (D356 , D355 , ( D354 `2_3 )) ) ] by L974 , L78;
thus L981: [ D332 , ( D347 `1_3 ) ] = [ D332 , ( D354 `1_3 ) ] by L980 , MCART_1:def 5
.= ( D352 `1_3 ) by L971 , MCART_1:def 5
.= ( D349 `1_3 ) by L979 , MCART_1:def 5;
L982: ( offset D354 ) = ( offset D352 ) by L971 , MCART_1:def 7;
thus L983: ( D347 `2_3 ) = ( ( Head D350 ) + ( offset D352 ) ) by L982 , L967 , L970 , L969 , L980 , MCART_1:def 6 , XXREAL_0:2
.= ( D349 `2_3 ) by L979 , MCART_1:def 6;
thus L984: ( D347 `3_3 ) = ( D351 +* ( D355 .--> ( D354 `2_3 ) ) ) by L967 , L970 , L969 , L980 , MCART_1:def 7 , XXREAL_0:2
.= ( D349 `3_3 ) by L967 , L970 , L969 , L972 , L979 , MCART_1:def 7 , XXREAL_0:2;
end;
thus L985: thesis by L968;
end;
L986: ( D345 `3_3 ) = ( D346 `3_3 ) by L961;
set D358 = ( ( Computation C302 ) . C304 );
set D359 = ( ( Computation D346 ) . C304 );
L987: ( ( Computation C303 ) . ( R4 + C304 ) ) = D359 by L101;
L988: [ ( D345 `1_3 ) , D331 ] = ( D346 `1_3 ) by L961;
L989: S9[ ( 0 ) ]
proof
assume L990: ( 0 ) <= C304;
thus L991: [ D332 , ( ( ( Computation C302 ) . ( 0 ) ) `1_3 ) ] = [ D332 , ( C302 `1_3 ) ] by L82
.= [ D332 , D331 ] by L928 , MCART_1:64
.= ( ( ( Computation D346 ) . ( 0 ) ) `1_3 ) by L930 , L988 , L82;
thus L992: ( ( ( Computation C302 ) . ( 0 ) ) `2_3 ) = ( C302 `2_3 ) by L82
.= ( D346 `2_3 ) by L928 , L931 , L962 , MCART_1:64
.= ( ( ( Computation D346 ) . ( 0 ) ) `2_3 ) by L82;
thus L993: ( ( ( Computation C302 ) . ( 0 ) ) `3_3 ) = ( C302 `3_3 ) by L82
.= ( D346 `3_3 ) by L928 , L931 , L986 , MCART_1:64
.= ( ( ( Computation D346 ) . ( 0 ) ) `3_3 ) by L82;
end;
L994: (for R2 being (Element of ( NAT )) holds S9[ R2 ]) from NAT_1:sch 1(L989 , L966);
L995: [ D332 , ( D358 `1_3 ) ] = ( D359 `1_3 ) by L994;
L996: ( ( ( Computation C303 ) . ( R4 + C304 ) ) `1_3 ) = (the AcceptS of ( C297 ';' C298 )) by L995 , L963 , L987 , L902;
thus L997: C303 is  Accept-Halt by L996 , L124;
L998: (( D358 `2_3 ) = ( D359 `2_3 ) & ( D358 `3_3 ) = ( D359 `3_3 )) by L994;
thus L999: thesis by L998 , L964 , L987 , L996 , L997 , L127;
end;
theorem
L1000: (for B231 , B232 being TuringStr holds (for B233 being (Tape of B231) holds ((the Symbols of B231) = (the Symbols of B232) implies B233 is (Tape of ( B231 ';' B232 )))))
proof
let C305 , C306 being TuringStr;
let C307 being (Tape of C305);
set D360 = (the Symbols of C305);
set D361 = (the Symbols of C306);
assume L1001: D360 = D361;
L1002: (the Symbols of ( C305 ';' C306 )) = ( D360 \/ D361 ) by L902
.= D360 by L1001;
thus L1003: thesis by L1002;
end;
theorem
L1004: (for B234 , B235 being TuringStr holds (for B236 being (Tape of ( B234 ';' B235 )) holds ((the Symbols of B234) = (the Symbols of B235) implies (B236 is (Tape of B234) & B236 is (Tape of B235)))))
proof
let C308 , C309 being TuringStr;
let C310 being (Tape of ( C308 ';' C309 ));
set D362 = (the Symbols of C308);
set D363 = (the Symbols of C309);
assume L1005: D362 = D363;
L1006: (the Symbols of ( C308 ';' C309 )) = ( D362 \/ D363 ) by L902
.= D362 by L1005;
thus L1007: thesis by L1006 , L1005;
end;
theorem
L1008: (for B237 being (FinSequence of ( NAT )) holds (for B238 , B239 being TuringStr holds (for B240 being (Tape of B238) holds (for B241 being (Tape of B239) holds ((B240 = B241 & B240 storeData B237) implies B241 storeData B237)))))
proof
let C311 being (FinSequence of ( NAT ));
let C312 , C313 being TuringStr;
let C314 being (Tape of C312);
let C315 being (Tape of C313);
assume that
L1009: C314 = C315
and
L1010: C314 storeData C311;
L1011:
now
let C316 being (Element of ( NAT ));
set D364 = ( ( Sum ( Prefix (C311 , C316) ) ) + ( 2 * ( C316 - 1 ) ) );
set D365 = ( ( Sum ( Prefix (C311 , ( C316 + 1 )) ) ) + ( 2 * C316 ) );
assume L1012: (1 <= C316 & C316 < ( len C311 ));
L1013: C314 is_1_between D364 , D365 by L1012 , L1010 , L164;
L1014: (for B242 being Integer holds ((D364 < B242 & B242 < D365) implies ( C314 . B242 ) = 1)) by L1013 , L162;
L1015: (( C314 . D364 ) = ( 0 ) & ( C314 . D365 ) = ( 0 )) by L1013 , L162;
thus L1016: C315 is_1_between D364 , D365 by L1015 , L1009 , L1014 , L162;
end;
thus L1017: thesis by L1011 , L164;
end;
L1018: (for B243 being (All-State of ( ZeroTuring )) holds (for B244 being (Tape of ( ZeroTuring )) holds (for B245 , B246 being (Element of ( NAT )) holds ((B243 = [ ( 0 ) , B245 , B244 ] & B244 storeData <* B245 , B246 *>) implies (B243 is  Accept-Halt & ( ( Result B243 ) `2_3 ) = B245 & ( ( Result B243 ) `3_3 ) storeData <* B245 , ( 0 ) *>)))))
proof
let C317 being (All-State of ( ZeroTuring ));
let C318 being (Tape of ( ZeroTuring ));
let C319 , C320 being (Element of ( NAT ));
L1019: ( len <* C320 *> ) = 1 by FINSEQ_1:39;
thus L1020: thesis by L1019 , L625;
end;
theorem
L1021: (for B247 being (All-State of ( ( ZeroTuring ) ';' ( SuccTuring ) )) holds (for B248 being (Tape of ( ZeroTuring )) holds (for B249 , B250 being (Element of ( NAT )) holds ((B247 = [ [ ( 0 ) , ( 0 ) ] , B249 , B248 ] & B248 storeData <* B249 , B250 *>) implies (B247 is  Accept-Halt & ( ( Result B247 ) `2_3 ) = B249 & ( ( Result B247 ) `3_3 ) storeData <* B249 , 1 *>)))))
proof
let C321 being (All-State of ( ( ZeroTuring ) ';' ( SuccTuring ) ));
let C322 being (Tape of ( ZeroTuring ));
let C323 , C324 being (Element of ( NAT ));
assume that
L1022: C321 = [ [ ( 0 ) , ( 0 ) ] , C323 , C322 ]
and
L1023: C322 storeData <* C323 , C324 *>;
reconsider D366 = C323 as (Element of ( INT )) by INT_1:def 2;
set D367 = [ (the InitS of ( ZeroTuring )) , D366 , C322 ];
L1024: ( 0 ) = (the InitS of ( ZeroTuring )) by L611;
L1025: (D367 is  Accept-Halt & ( ( Result D367 ) `2_3 ) = C323) by L1024 , L1023 , L1018;
L1026: (the Symbols of ( ZeroTuring )) = { ( 0 ) , 1 } by L611
.= (the Symbols of ( SuccTuring )) by L477;
reconsider D368 = ( ( Result D367 ) `3_3 ) as (Tape of ( SuccTuring )) by L1026;
set D369 = [ (the InitS of ( SuccTuring )) , D366 , D368 ];
L1027: ( 0 ) = (the InitS of ( SuccTuring )) by L477;
L1028: C321 = [ (the InitS of ( ( ZeroTuring ) ';' ( SuccTuring ) )) , C323 , C322 ] by L1027 , L1022 , L1024 , L902;
L1029: ( ( Result D367 ) `3_3 ) storeData <* C323 , ( 0 ) *> by L1023 , L1024 , L1018;
L1030: D368 storeData <* C323 , ( 0 ) *> by L1029 , L1008;
L1031: ( ( Result D369 ) `3_3 ) storeData <* C323 , ( ( 0 ) + 1 ) *> by L1030 , L1027 , L491;
L1032: D369 is  Accept-Halt by L1030 , L1027 , L491;
thus L1033: C321 is  Accept-Halt by L1032 , L1025 , L1028 , L924;
L1034: ( ( Result D369 ) `2_3 ) = C323 by L1030 , L1027 , L491;
thus L1035: ( ( Result C321 ) `2_3 ) = C323 by L1034 , L1025 , L1032 , L1028 , L924;
L1036: ( ( Result C321 ) `3_3 ) = ( ( Result D369 ) `3_3 ) by L1025 , L1032 , L1028 , L924;
thus L1037: thesis by L1036 , L1031 , L1008;
end;
