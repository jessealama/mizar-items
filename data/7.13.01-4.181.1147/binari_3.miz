:: Binary Arithmetics. Binary Sequences
::  by Robert Milewski
::
:: Received February 24, 1998
:: Copyright (c) 1998-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, XBOOLE_0, NAT_1, FINSEQ_2, MARGREL1, BINARITH, ARYTM_3,
      POWER, SUBSET_1, ORDINAL4, FINSEQ_1, FUNCOP_1, XBOOLEAN, CARD_1, RELAT_1,
      REAL_1, FINSEQ_5, EUCLID, XXREAL_0, FUNCT_1, PARTFUN1, ARYTM_1, BINARI_2,
      ZFMISC_1, INT_1, ABIAN, BINARI_3;
 notations XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, REAL_1, XXREAL_0, ORDINAL1,
      NAT_D, POWER, ABIAN, SERIES_1, MARGREL1, FUNCT_1, PARTFUN1, FUNCOP_1,
      FINSEQ_1, FINSEQ_5, ZFMISC_1, FINSEQ_2, BINARITH, BINARI_2, EUCLID;
 constructors NAT_D, FINSEQOP, SERIES_1, BINARITH, FINSEQ_5, BINARI_2, ABIAN,
      EUCLID;
 registrations RELSET_1, XREAL_0, NAT_1, XBOOLEAN, MARGREL1, ZFMISC_1, NAT_2,
      ORDINAL1, XBOOLE_0, FINSEQ_2, INT_1, FINSEQ_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FINSEQ_2, EUCLID, XBOOLEAN;
 theorems TARSKI, NAT_1, NAT_2, MARGREL1, POWER, FUNCOP_1, FINSEQ_1, FINSEQ_2,
      FINSEQ_4, FINSEQ_5, BINARITH, BINARI_2, XREAL_1, XCMPLX_1, XBOOLEAN,
      NAT_D, PARTFUN1, XXREAL_0, CARD_1;
 schemes NAT_1, NAT_2, FINSEQ_2;

begin
theorem
L1: (for B1 being non  empty Nat holds (for B2 being (Tuple of B1 , ( BOOLEAN )) holds ( Absval B2 ) < ( 2 to_power B1 )))
proof
defpred S1[ non  empty Nat ] means (for B3 being (Tuple of $1 , ( BOOLEAN )) holds ( Absval B3 ) < ( 2 to_power $1 ));
L2: (for B4 being non  empty Nat holds (S1[ B4 ] implies S1[ ( B4 + 1 ) ]))
proof
let C1 being non  empty Nat;
assume L3: S1[ C1 ];
L4: C1 < ( C1 + 1 ) by NAT_1:13;
L5: ( 2 to_power C1 ) < ( 2 to_power ( C1 + 1 ) ) by L4 , POWER:39;
let C2 being (Tuple of ( C1 + 1 ) , ( BOOLEAN ));
consider C3 being (Element of ( C1 -tuples_on ( BOOLEAN ) )), C4 being (Element of ( BOOLEAN )) such that L6: C2 = ( C3 ^ <* C4 *> ) by FINSEQ_2:117;
L7: ( Absval C2 ) = ( ( Absval C3 ) + ( IFEQ (C4 , ( FALSE ) , ( 0 ) , ( 2 to_power C1 )) ) ) by L6 , BINARITH:20;
L8: ( Absval C3 ) < ( 2 to_power C1 ) by L3;
per cases  by XBOOLEAN:def 3;
suppose L9: C4 = ( FALSE );

L10: ( Absval C2 ) = ( ( Absval C3 ) + ( 0 ) ) by L9 , L7 , FUNCOP_1:def 8;
L11: ( ( Absval C2 ) + ( 2 to_power C1 ) ) < ( ( 2 to_power C1 ) + ( 2 to_power ( C1 + 1 ) ) ) by L10 , L3 , L5 , XREAL_1:8;
thus L12: thesis by L11 , XREAL_1:6;
end;
suppose L13: C4 = ( TRUE );

L14: ( Absval C2 ) = ( ( Absval C3 ) + ( 2 to_power C1 ) ) by L13 , L7 , FUNCOP_1:def 8;
L15: ( Absval C2 ) < ( ( 2 to_power C1 ) + ( 2 to_power C1 ) ) by L14 , L8 , XREAL_1:6;
L16: ( Absval C2 ) < ( ( 2 to_power C1 ) * 2 ) by L15;
L17: ( Absval C2 ) < ( ( 2 to_power C1 ) * ( 2 to_power 1 ) ) by L16 , POWER:25;
thus L18: thesis by L17 , POWER:27;
end;
end;
L20: S1[ 1 ]
proof
let C5 being (Tuple of 1 , ( BOOLEAN ));
consider C6 being (Element of ( BOOLEAN )) such that L21: C5 = <* C6 *> by FINSEQ_2:97;
L22: (C6 = ( TRUE ) or C6 = ( FALSE )) by XBOOLEAN:def 3;
L23: (( Absval C5 ) = 1 or ( Absval C5 ) = ( 0 )) by L22 , L21 , BINARITH:15 , BINARITH:16;
L24: ( Absval C5 ) < 2 by L23;
thus L25: thesis by L24 , POWER:25;
end;
thus L26: (for B5 being non  empty Nat holds S1[ B5 ]) from NAT_1:sch 10(L20 , L2);
end;
theorem
L27: (for B6 being non  empty Nat holds (for B7 , B8 being (Tuple of B6 , ( BOOLEAN )) holds (( Absval B7 ) = ( Absval B8 ) implies B7 = B8)))
proof
defpred S2[ non  empty Nat ] means (for B9 , B10 being (Tuple of $1 , ( BOOLEAN )) holds (( Absval B9 ) = ( Absval B10 ) implies B9 = B10));
L28: (for B11 being non  empty Nat holds (S2[ B11 ] implies S2[ ( B11 + 1 ) ]))
proof
let C7 being non  empty Nat;
assume L29: (for B12 , B13 being (Tuple of C7 , ( BOOLEAN )) holds (( Absval B12 ) = ( Absval B13 ) implies B12 = B13));
let C8 , C9 being (Tuple of ( C7 + 1 ) , ( BOOLEAN ));
consider C10 being (Element of ( C7 -tuples_on ( BOOLEAN ) )), C11 being (Element of ( BOOLEAN )) such that L30: C8 = ( C10 ^ <* C11 *> ) by FINSEQ_2:117;
assume L31: ( Absval C8 ) = ( Absval C9 );
consider C12 being (Element of ( C7 -tuples_on ( BOOLEAN ) )), C13 being (Element of ( BOOLEAN )) such that L32: C9 = ( C12 ^ <* C13 *> ) by FINSEQ_2:117;
L33: ( ( Absval C10 ) + ( IFEQ (C11 , ( FALSE ) , ( 0 ) , ( 2 to_power C7 )) ) ) = ( Absval C8 ) by L30 , BINARITH:20
.= ( ( Absval C12 ) + ( IFEQ (C13 , ( FALSE ) , ( 0 ) , ( 2 to_power C7 )) ) ) by L32 , L31 , BINARITH:20;
L34: C11 = C13
proof
assume L35: C11 <> C13;
per cases  by XBOOLEAN:def 3;
suppose L36: C11 = ( FALSE );

L37: ( IFEQ (C11 , ( FALSE ) , (( 0 ) qua Real) , ( 2 to_power C7 )) ) = ( 0 ) by L36 , FUNCOP_1:def 8;
L38: ( IFEQ (C13 , ( FALSE ) , (( 0 ) qua Real) , ( 2 to_power C7 )) ) = ( 2 to_power C7 ) by L35 , L36 , FUNCOP_1:def 8;
thus L39: contradiction by L38 , L33 , L37 , L1 , NAT_1:11;
end;
suppose L40: C11 = ( TRUE );

L41: C13 = ( FALSE ) by L40 , L35 , XBOOLEAN:def 3;
L42: ( IFEQ (C13 , ( FALSE ) , (( 0 ) qua Real) , ( 2 to_power C7 )) ) = ( 0 ) by L41 , FUNCOP_1:def 8;
L43: ( IFEQ (C11 , ( FALSE ) , (( 0 ) qua Real) , ( 2 to_power C7 )) ) = ( 2 to_power C7 ) by L40 , FUNCOP_1:def 8;
thus L44: contradiction by L43 , L33 , L42 , L1 , NAT_1:11;
end;
end;
thus L46: thesis by L34 , L29 , L30 , L32 , L33 , XCMPLX_1:2;
end;
L47: S2[ 1 ]
proof
let C14 , C15 being (Tuple of 1 , ( BOOLEAN ));
consider C16 being (Element of ( BOOLEAN )) such that L48: C14 = <* C16 *> by FINSEQ_2:97;
assume L49: ( Absval C14 ) = ( Absval C15 );
assume L50: C14 <> C15;
consider C17 being (Element of ( BOOLEAN )) such that L51: C15 = <* C17 *> by FINSEQ_2:97;
per cases  by XBOOLEAN:def 3;
suppose L52: C16 = ( FALSE );

L53: ( Absval C14 ) = ( 0 ) by L52 , L48 , BINARITH:15;
L54: C17 = ( TRUE ) by L48 , L51 , L50 , L52 , XBOOLEAN:def 3;
thus L55: contradiction by L54 , L51 , L49 , L53 , BINARITH:16;
end;
suppose L56: C16 = ( TRUE );

L57: ( Absval C14 ) = 1 by L56 , L48 , BINARITH:16;
L58: C17 = ( FALSE ) by L48 , L51 , L50 , L56 , XBOOLEAN:def 3;
thus L59: contradiction by L58 , L51 , L49 , L57 , BINARITH:15;
end;
end;
thus L61: (for B14 being non  empty Nat holds S2[ B14 ]) from NAT_1:sch 10(L47 , L28);
end;
theorem
L62: (for B15 , B16 being FinSequence holds (( Rev B15 ) = ( Rev B16 ) implies B15 = B16))
proof
let C18 , C19 being FinSequence;
assume L63: ( Rev C18 ) = ( Rev C19 );
thus L64: C18 = ( Rev ( Rev C18 ) )
.= C19 by L63;
end;
theorem
L65: (for B17 being Nat holds ( 0* B17 ) in ( ( BOOLEAN ) * ))
proof
let C20 being Nat;
L66: ( C20 |-> ( FALSE ) ) is (FinSequence of ( BOOLEAN ));
thus L67: thesis by L66 , FINSEQ_1:def 11;
end;
theorem
L68: (for B18 being Nat holds (for B19 being (Tuple of B18 , ( BOOLEAN )) holds (B19 = ( 0* B18 ) implies ( 'not' B19 ) = ( B18 |-> 1 ))))
proof
let C21 being Nat;
let C22 being (Tuple of C21 , ( BOOLEAN ));
assume L69: C22 = ( 0* C21 );
L70:
now
L71: ( len C22 ) = C21 by CARD_1:def 7;
let C23 being Nat;
assume that
L72: 1 <= C23
and
L73: C23 <= ( len ( 'not' C22 ) );
L74: ( len ( 'not' C22 ) ) = C21 by CARD_1:def 7;
L75: C23 in ( Seg C21 ) by L74 , L72 , L73 , FINSEQ_1:1;
L76: ( C22 . C23 ) = ( FALSE ) by L75 , L69 , FUNCOP_1:7;
thus L77: ( ( 'not' C22 ) . C23 ) = ( ( 'not' C22 ) /. C23 ) by L72 , L73 , FINSEQ_4:15
.= ( 'not' ( C22 /. C23 ) ) by L75 , BINARITH:def 1
.= ( 'not' ( FALSE ) ) by L72 , L73 , L74 , L71 , L76 , FINSEQ_4:15
.= ( ( C21 |-> 1 ) . C23 ) by L75 , FUNCOP_1:7;
end;
L78: ( len ( 'not' C22 ) ) = C21 by CARD_1:def 7
.= ( len ( C21 |-> 1 ) ) by CARD_1:def 7;
thus L79: thesis by L78 , L70 , FINSEQ_1:14;
end;
theorem
L80: (for B20 being non  empty Nat holds (for B21 being (Tuple of B20 , ( BOOLEAN )) holds (B21 = ( 0* B20 ) implies ( Absval B21 ) = ( 0 ))))
proof
defpred S3[ Nat ] means (for B22 being (Tuple of $1 , ( BOOLEAN )) holds (B22 = ( 0* $1 ) implies ( Absval B22 ) = ( 0 )));
L81: (for B23 being non  empty Nat holds (S3[ B23 ] implies S3[ ( B23 + 1 ) ]))
proof
let C24 being non  empty Nat;
assume L82: (for B24 being (Tuple of C24 , ( BOOLEAN )) holds (B24 = ( 0* C24 ) implies ( Absval B24 ) = ( 0 )));
let C25 being (Tuple of ( C24 + 1 ) , ( BOOLEAN ));
L83: ( 0* C24 ) in ( ( BOOLEAN ) * ) by L65;
L84: ( 0* C24 ) is (FinSequence of ( BOOLEAN )) by L83 , FINSEQ_1:def 11;
reconsider D1 = ( 0* C24 ) as (Tuple of C24 , ( BOOLEAN )) by L84;
assume L85: C25 = ( 0* ( C24 + 1 ) );
thus L86: ( Absval C25 ) = ( Absval ( D1 ^ <* ( FALSE ) *> ) ) by L85 , FINSEQ_2:60
.= ( ( Absval D1 ) + ( IFEQ (( FALSE ) , ( FALSE ) , ( 0 ) , ( 2 to_power C24 )) ) ) by BINARITH:20
.= ( ( 0 ) + ( IFEQ (( FALSE ) , ( FALSE ) , ( 0 ) , ( 2 to_power C24 )) ) ) by L82
.= ( 0 ) by FUNCOP_1:def 8;
end;
L87: S3[ 1 ] by BINARITH:15 , FINSEQ_2:59;
thus L88: (for B25 being non  empty Nat holds S3[ B25 ]) from NAT_1:sch 10(L87 , L81);
end;
theorem
L89: (for B26 being non  empty Nat holds (for B27 being (Tuple of B26 , ( BOOLEAN )) holds (B27 = ( 0* B26 ) implies ( Absval ( 'not' B27 ) ) = ( ( 2 to_power B26 ) - 1 ))))
proof
let C26 being non  empty Nat;
let C27 being (Tuple of C26 , ( BOOLEAN ));
assume L90: C27 = ( 0* C26 );
thus L91: ( Absval ( 'not' C27 ) ) = ( ( ( - ( Absval C27 ) ) + ( 2 to_power C26 ) ) - 1 ) by BINARI_2:13
.= ( ( ( - ( 0 ) ) + ( 2 to_power C26 ) ) - 1 ) by L90 , L80
.= ( ( 2 to_power C26 ) - 1 );
end;
theorem
L92: (for B28 being Nat holds ( Rev ( 0* B28 ) ) = ( 0* B28 ))
proof
let C28 being Nat;
L93:
now
let C29 being Nat;
assume L94: C29 in ( dom ( 0* C28 ) );
L95: C29 in ( Seg ( len ( 0* C28 ) ) ) by L94 , FINSEQ_1:def 3;
L96: C29 in ( Seg C28 ) by L95 , CARD_1:def 7;
L97: ( ( C28 - C29 ) + 1 ) in ( Seg C28 ) by L96 , FINSEQ_5:2;
L98: ( ( ( len ( 0* C28 ) ) - C29 ) + 1 ) in ( Seg C28 ) by L97 , CARD_1:def 7;
thus L99: ( ( Rev ( 0* C28 ) ) . C29 ) = ( ( 0* C28 ) . ( ( ( len ( 0* C28 ) ) - C29 ) + 1 ) ) by L94 , FINSEQ_5:58
.= ( 0 ) by L98 , FUNCOP_1:7
.= ( ( 0* C28 ) . C29 ) by L96 , FUNCOP_1:7;
end;
L100: ( dom ( Rev ( 0* C28 ) ) ) = ( Seg ( len ( Rev ( 0* C28 ) ) ) ) by FINSEQ_1:def 3
.= ( Seg ( len ( 0* C28 ) ) ) by FINSEQ_5:def 3
.= ( dom ( 0* C28 ) ) by FINSEQ_1:def 3;
thus L101: thesis by L100 , L93 , FINSEQ_1:13;
end;
theorem
L102: (for B29 being Nat holds (for B30 being (Tuple of B29 , ( BOOLEAN )) holds (B30 = ( 0* B29 ) implies ( Rev ( 'not' B30 ) ) = ( 'not' B30 ))))
proof
let C30 being Nat;
let C31 being (Tuple of C30 , ( BOOLEAN ));
assume L103: C31 = ( 0* C30 );
L104:
now
let C32 being Nat;
assume L105: C32 in ( dom ( 'not' C31 ) );
L106: C32 in ( Seg ( len ( 'not' C31 ) ) ) by L105 , FINSEQ_1:def 3;
L107: C32 in ( Seg C30 ) by L106 , CARD_1:def 7;
L108: ( ( C30 - C32 ) + 1 ) in ( Seg C30 ) by L107 , FINSEQ_5:2;
L109: ( ( ( len ( 'not' C31 ) ) - C32 ) + 1 ) in ( Seg C30 ) by L108 , CARD_1:def 7;
thus L110: ( ( Rev ( 'not' C31 ) ) . C32 ) = ( ( 'not' C31 ) . ( ( ( len ( 'not' C31 ) ) - C32 ) + 1 ) ) by L105 , FINSEQ_5:58
.= ( ( C30 |-> 1 ) . ( ( ( len ( 'not' C31 ) ) - C32 ) + 1 ) ) by L103 , L68
.= 1 by L109 , FUNCOP_1:7
.= ( ( C30 |-> 1 ) . C32 ) by L107 , FUNCOP_1:7
.= ( ( 'not' C31 ) . C32 ) by L103 , L68;
end;
L111: ( dom ( Rev ( 'not' C31 ) ) ) = ( Seg ( len ( Rev ( 'not' C31 ) ) ) ) by FINSEQ_1:def 3
.= ( Seg ( len ( 'not' C31 ) ) ) by FINSEQ_5:def 3
.= ( dom ( 'not' C31 ) ) by FINSEQ_1:def 3;
thus L112: thesis by L111 , L104 , FINSEQ_1:13;
end;
theorem
L113: ( Bin1 1 ) = <* ( TRUE ) *>
proof
L114: 1 in ( Seg 1 ) by FINSEQ_1:3;
L115: ( ( Bin1 1 ) /. 1 ) = ( TRUE ) by L114 , BINARI_2:5;
L116: (ex B31 being (Element of ( BOOLEAN )) st ( Bin1 1 ) = <* B31 *>) by FINSEQ_2:97;
thus L117: thesis by L116 , L115 , FINSEQ_4:16;
end;
theorem
L118: (for B32 being non  empty Nat holds ( Absval ( Bin1 B32 ) ) = 1)
proof
defpred S4[ Nat ] means ( Absval ( Bin1 $1 ) ) = 1;
L119: (for B33 being non  empty Nat holds (S4[ B33 ] implies S4[ ( B33 + 1 ) ]))
proof
let C33 being non  empty Nat;
assume L120: ( Absval ( Bin1 C33 ) ) = 1;
thus L121: ( Absval ( Bin1 ( C33 + 1 ) ) ) = ( Absval ( ( Bin1 C33 ) ^ <* ( FALSE ) *> ) ) by BINARI_2:7
.= ( ( Absval ( Bin1 C33 ) ) + ( IFEQ (( FALSE ) , ( FALSE ) , ( 0 ) , ( 2 to_power C33 )) ) ) by BINARITH:20
.= ( ( Absval ( Bin1 C33 ) ) + ( 0 ) ) by FUNCOP_1:def 8
.= 1 by L120;
end;
L122: S4[ 1 ] by L113 , BINARITH:16;
thus L123: (for B34 being non  empty Nat holds S4[ B34 ]) from NAT_1:sch 10(L122 , L119);
end;
theorem
L124: (for B35 , B36 being (Element of ( BOOLEAN )) holds ((( B35 'or' B36 ) = ( TRUE ) iff (B35 = ( TRUE ) or B36 = ( TRUE ))) & (( B35 'or' B36 ) = ( FALSE ) iff (B35 = ( FALSE ) & B36 = ( FALSE )))))
proof
let C34 , C35 being (Element of ( BOOLEAN ));
thus L125: (( C34 'or' C35 ) = ( TRUE ) implies (C34 = ( TRUE ) or C35 = ( TRUE )))
proof
assume L126: ( C34 'or' C35 ) = ( TRUE );
L127: (( 'not' C34 ) = ( FALSE ) or ( 'not' C35 ) = ( FALSE )) by L126 , MARGREL1:12;
thus L128: thesis by L127;
end;

thus L129: ((C34 = ( TRUE ) or C35 = ( TRUE )) implies ( C34 'or' C35 ) = ( TRUE ));
thus L130: (( C34 'or' C35 ) = ( FALSE ) implies (C34 = ( FALSE ) & C35 = ( FALSE )))
proof
assume L131: ( C34 'or' C35 ) = ( FALSE );
L132: ( 'not' C34 ) = ( TRUE ) by L131 , MARGREL1:12;
thus L133: thesis by L132 , L131;
end;

thus L134: thesis;
end;
theorem
L135: (for B37 , B38 being (Element of ( BOOLEAN )) holds (( add_ovfl (<* B37 *> , <* B38 *>) ) = ( TRUE ) iff (B37 = ( TRUE ) & B38 = ( TRUE ))))
proof
let C36 , C37 being (Element of ( BOOLEAN ));
L136: ( ( <* ( TRUE ) *> /. 1 ) '&' ( <* ( TRUE ) *> /. 1 ) ) = ( TRUE ) by FINSEQ_4:16;
thus L137: (( add_ovfl (<* C36 *> , <* C37 *>) ) = ( TRUE ) implies (C36 = ( TRUE ) & C37 = ( TRUE )))
proof
assume L138: ( add_ovfl (<* C36 *> , <* C37 *>) ) = ( TRUE );
L139: ( ( ( ( <* C36 *> /. 1 ) '&' ( <* C37 *> /. 1 ) ) 'or' ( ( <* C36 *> /. 1 ) '&' ( ( carry (<* C36 *> , <* C37 *>) ) /. 1 ) ) ) 'or' ( ( <* C37 *> /. 1 ) '&' ( ( carry (<* C36 *> , <* C37 *>) ) /. 1 ) ) ) = ( TRUE ) by L138 , BINARITH:def 6;
L140: (( ( ( <* C36 *> /. 1 ) '&' ( <* C37 *> /. 1 ) ) 'or' ( ( <* C36 *> /. 1 ) '&' ( ( carry (<* C36 *> , <* C37 *>) ) /. 1 ) ) ) = ( TRUE ) or ( ( <* C37 *> /. 1 ) '&' ( ( carry (<* C36 *> , <* C37 *>) ) /. 1 ) ) = ( TRUE )) by L139 , L124;
L141:
now
per cases  by L140 , L124;
suppose L142: ( ( <* C36 *> /. 1 ) '&' ( <* C37 *> /. 1 ) ) = ( TRUE );

L143: ( <* C36 *> /. 1 ) = ( TRUE ) by L142 , MARGREL1:12;
thus L144: thesis by L143 , L142 , FINSEQ_4:16;
end;
suppose L145: ( ( <* C36 *> /. 1 ) '&' ( ( carry (<* C36 *> , <* C37 *>) ) /. 1 ) ) = ( TRUE );

L146: ( ( carry (<* C36 *> , <* C37 *>) ) /. 1 ) = ( TRUE ) by L145 , MARGREL1:12;
thus L147: thesis by L146 , BINARITH:def 2;
end;
suppose L148: ( ( <* C37 *> /. 1 ) '&' ( ( carry (<* C36 *> , <* C37 *>) ) /. 1 ) ) = ( TRUE );

L149: ( ( carry (<* C36 *> , <* C37 *>) ) /. 1 ) = ( TRUE ) by L148 , MARGREL1:12;
thus L150: thesis by L149 , BINARITH:def 2;
end;
end;
thus L152: thesis by L141;
end;

assume that
L153: C36 = ( TRUE )
and
L154: C37 = ( TRUE );
thus L155: ( add_ovfl (<* C36 *> , <* C37 *>) ) = ( ( ( ( <* ( TRUE ) *> /. 1 ) '&' ( <* ( TRUE ) *> /. 1 ) ) 'or' ( ( <* ( TRUE ) *> /. 1 ) '&' ( ( carry (<* ( TRUE ) *> , <* ( TRUE ) *>) ) /. 1 ) ) ) 'or' ( ( <* ( TRUE ) *> /. 1 ) '&' ( ( carry (<* ( TRUE ) *> , <* ( TRUE ) *>) ) /. 1 ) ) ) by L153 , L154 , BINARITH:def 6
.= ( TRUE ) by L136;
end;
theorem
L156: ( 'not' <* ( FALSE ) *> ) = <* ( TRUE ) *>
proof
L157:
now
let C38 being Nat;
assume L158: C38 in ( Seg 1 );
L159: C38 = 1 by L158 , FINSEQ_1:2 , TARSKI:def 1;
L160: ( len <* ( FALSE ) *> ) = 1 by CARD_1:def 7;
L161: ( <* ( FALSE ) *> /. C38 ) = ( <* ( FALSE ) *> . 1 ) by L160 , L159 , FINSEQ_4:15;
L162: ( len ( 'not' <* ( FALSE ) *> ) ) = 1 by CARD_1:def 7;
thus L163: ( ( 'not' <* ( FALSE ) *> ) . C38 ) = ( ( 'not' <* ( FALSE ) *> ) /. C38 ) by L162 , L159 , FINSEQ_4:15
.= ( 'not' ( <* ( FALSE ) *> /. C38 ) ) by L158 , BINARITH:def 1
.= ( 'not' ( FALSE ) ) by L161 , FINSEQ_1:40
.= ( <* ( TRUE ) *> . C38 ) by L159 , FINSEQ_1:40;
end;
thus L164: thesis by L157 , FINSEQ_2:119;
end;
theorem
L165: ( 'not' <* ( TRUE ) *> ) = <* ( FALSE ) *>
proof
L166:
now
let C39 being Nat;
assume L167: C39 in ( Seg 1 );
L168: C39 = 1 by L167 , FINSEQ_1:2 , TARSKI:def 1;
L169: ( len <* ( TRUE ) *> ) = 1 by CARD_1:def 7;
L170: ( <* ( TRUE ) *> /. C39 ) = ( <* ( TRUE ) *> . 1 ) by L169 , L168 , FINSEQ_4:15;
L171: ( len ( 'not' <* ( TRUE ) *> ) ) = 1 by CARD_1:def 7;
thus L172: ( ( 'not' <* ( TRUE ) *> ) . C39 ) = ( ( 'not' <* ( TRUE ) *> ) /. C39 ) by L171 , L168 , FINSEQ_4:15
.= ( 'not' ( <* ( TRUE ) *> /. C39 ) ) by L167 , BINARITH:def 1
.= ( 'not' ( TRUE ) ) by L170 , FINSEQ_1:40
.= ( <* ( FALSE ) *> . C39 ) by L168 , FINSEQ_1:40;
end;
thus L173: thesis by L166 , FINSEQ_2:119;
end;
theorem
L174: ( <* ( FALSE ) *> + <* ( FALSE ) *> ) = <* ( FALSE ) *>
proof
L175: ( add_ovfl (<* ( FALSE ) *> , <* ( FALSE ) *>) ) <> ( TRUE ) by L135;
L176: ( add_ovfl (<* ( FALSE ) *> , <* ( FALSE ) *>) ) = ( FALSE ) by L175 , XBOOLEAN:def 3;
L177: <* ( FALSE ) *> , <* ( FALSE ) *> are_summable  by L176 , BINARITH:def 7;
L178: ( Absval ( <* ( FALSE ) *> + <* ( FALSE ) *> ) ) = ( ( Absval <* ( FALSE ) *> ) + ( Absval <* ( FALSE ) *> ) ) by L177 , BINARITH:22
.= ( ( Absval <* ( FALSE ) *> ) + ( 0 ) ) by BINARITH:15
.= ( Absval <* ( FALSE ) *> );
thus L179: thesis by L178 , L27;
end;
theorem
L180: (( <* ( FALSE ) *> + <* ( TRUE ) *> ) = <* ( TRUE ) *> & ( <* ( TRUE ) *> + <* ( FALSE ) *> ) = <* ( TRUE ) *>)
proof
L181: ( add_ovfl (<* ( FALSE ) *> , <* ( TRUE ) *>) ) <> ( TRUE ) by L135;
L182: ( add_ovfl (<* ( FALSE ) *> , <* ( TRUE ) *>) ) = ( FALSE ) by L181 , XBOOLEAN:def 3;
L183: <* ( FALSE ) *> , <* ( TRUE ) *> are_summable  by L182 , BINARITH:def 7;
L184: ( Absval ( <* ( FALSE ) *> + <* ( TRUE ) *> ) ) = ( ( Absval <* ( FALSE ) *> ) + ( Absval <* ( TRUE ) *> ) ) by L183 , BINARITH:22
.= ( ( Absval <* ( FALSE ) *> ) + 1 ) by BINARITH:16
.= ( ( 0 ) + 1 ) by BINARITH:15
.= ( Absval <* ( TRUE ) *> ) by BINARITH:16;
thus L185: ( <* ( FALSE ) *> + <* ( TRUE ) *> ) = <* ( TRUE ) *> by L184 , L27;
L186: ( add_ovfl (<* ( TRUE ) *> , <* ( FALSE ) *>) ) <> ( TRUE ) by L135;
L187: ( add_ovfl (<* ( TRUE ) *> , <* ( FALSE ) *>) ) = ( FALSE ) by L186 , XBOOLEAN:def 3;
L188: <* ( TRUE ) *> , <* ( FALSE ) *> are_summable  by L187 , BINARITH:def 7;
L189: ( Absval ( <* ( TRUE ) *> + <* ( FALSE ) *> ) ) = ( ( Absval <* ( TRUE ) *> ) + ( Absval <* ( FALSE ) *> ) ) by L188 , BINARITH:22
.= ( ( Absval <* ( TRUE ) *> ) + ( 0 ) ) by BINARITH:15
.= ( Absval <* ( TRUE ) *> );
thus L190: thesis by L189 , L27;
end;
theorem
L191: ( <* ( TRUE ) *> + <* ( TRUE ) *> ) = <* ( FALSE ) *>
proof
L192: ( add_ovfl (<* ( TRUE ) *> , <* ( TRUE ) *>) ) = ( TRUE ) by L135;
L193: ( Absval ( <* ( TRUE ) *> + <* ( TRUE ) *> ) ) = ( ( ( Absval ( <* ( TRUE ) *> + <* ( TRUE ) *> ) ) + 2 ) - 2 )
.= ( ( ( Absval ( <* ( TRUE ) *> + <* ( TRUE ) *> ) ) + ( 2 to_power 1 ) ) - 2 ) by POWER:25
.= ( ( ( Absval ( <* ( TRUE ) *> + <* ( TRUE ) *> ) ) + ( IFEQ (( add_ovfl (<* ( TRUE ) *> , <* ( TRUE ) *>) ) , ( FALSE ) , ( 0 ) , ( 2 to_power 1 )) ) ) - 2 ) by L192 , FUNCOP_1:def 8
.= ( ( ( Absval <* ( TRUE ) *> ) + ( Absval <* ( TRUE ) *> ) ) - 2 ) by BINARITH:21
.= ( ( ( Absval <* ( TRUE ) *> ) + 1 ) - 2 ) by BINARITH:16
.= ( ( 1 + 1 ) - 2 ) by BINARITH:16
.= ( Absval <* ( FALSE ) *> ) by BINARITH:15;
thus L194: thesis by L193 , L27;
end;
theorem
L195: (for B39 being non  empty Nat holds (for B40 , B41 being (Tuple of B39 , ( BOOLEAN )) holds ((( B40 /. B39 ) = ( TRUE ) & ( ( carry (B40 , ( Bin1 B39 )) ) /. B39 ) = ( TRUE )) implies (for B42 being non  empty Nat holds ((B42 <> 1 & B42 <= B39) implies (( B40 /. B42 ) = ( TRUE ) & ( ( carry (B40 , ( Bin1 B39 )) ) /. B42 ) = ( TRUE )))))))
proof
let C40 being non  empty Nat;
let C41 , C42 being (Tuple of C40 , ( BOOLEAN ));
assume that
L196: ( C41 /. C40 ) = ( TRUE )
and
L197: ( ( carry (C41 , ( Bin1 C40 )) ) /. C40 ) = ( TRUE );
defpred S5[ Nat ] means ($1 in ( Seg ( C40 -' 1 ) ) implies (( C41 /. ( ( C40 -' $1 ) + 1 ) ) = ( TRUE ) & ( ( carry (C41 , ( Bin1 C40 )) ) /. ( ( C40 -' $1 ) + 1 ) ) = ( TRUE )));
let C43 being non  empty Nat;
assume that
L198: C43 <> 1
and
L199: C43 <= C40;
set D2 = ( ( C40 -' C43 ) + 1 );
L200: 1 < C43 by L198 , NAT_2:19;
L201: ( 1 + 1 ) <= C43 by L200 , NAT_1:13;
L202: 1 <= ( C43 - 1 ) by L201 , XREAL_1:19;
L203: (for B43 being non  empty Nat holds (S5[ B43 ] implies S5[ ( B43 + 1 ) ]))
proof
let C44 being non  empty Nat;
assume that
L204: S5[ C44 ]
and
L205: ( C44 + 1 ) in ( Seg ( C40 -' 1 ) );
L206: ( C44 + 1 ) <= ( C40 -' 1 ) by L205 , FINSEQ_1:1;
L207: C44 < ( C40 -' 1 ) by L206 , NAT_1:13;
L208: C44 < ( C40 - 1 ) by L207 , NAT_1:14 , XREAL_1:233;
L209: ( C44 + 1 ) < C40 by L208 , XREAL_1:20;
L210: C44 < C40 by L209 , NAT_1:13;
L211: ( C44 + 1 ) <= ( C40 - 1 ) by L206 , NAT_1:14 , XREAL_1:233;
L212: 1 <= ( ( C40 - 1 ) - C44 ) by L211 , XREAL_1:19;
L213: 1 <= ( ( C40 - C44 ) - 1 ) by L212;
L214: ( 1 + 1 ) <= ( C40 - C44 ) by L213 , XREAL_1:19;
L215: ( 1 + 1 ) <= ( C40 -' C44 ) by L214 , L210 , XREAL_1:233;
L216: ( C40 -' C44 ) > 1 by L215 , NAT_1:13;
L217: 1 <= C44 by NAT_1:14;
L218: ( C40 -' C44 ) < C40 by NAT_2:9;
L219: ( C40 -' C44 ) in ( Seg C40 ) by L218 , L216 , FINSEQ_1:1;
L220: ( ( Bin1 C40 ) /. ( C40 -' C44 ) ) = ( FALSE ) by L219 , L216 , BINARI_2:6;
L221: ( ( ( Bin1 C40 ) /. ( C40 -' C44 ) ) '&' ( ( carry (C41 , ( Bin1 C40 )) ) /. ( C40 -' C44 ) ) ) = ( FALSE ) by L220;
L222: ( TRUE ) = ( ( ( C41 /. ( C40 -' C44 ) ) '&' ( ( Bin1 C40 ) /. ( C40 -' C44 ) ) ) 'or' ( ( C41 /. ( C40 -' C44 ) ) '&' ( ( carry (C41 , ( Bin1 C40 )) ) /. ( C40 -' C44 ) ) ) ) by L221 , L204 , L217 , L207 , L218 , L216 , L220 , BINARITH:def 2 , FINSEQ_1:1
.= ( ( C41 /. ( C40 -' C44 ) ) '&' ( ( carry (C41 , ( Bin1 C40 )) ) /. ( C40 -' C44 ) ) ) by L220;
L223: ( C41 /. ( C40 -' C44 ) ) = ( TRUE ) by L222 , MARGREL1:12;
thus L224: ( C41 /. ( ( C40 -' ( C44 + 1 ) ) + 1 ) ) = ( TRUE ) by L223 , L210 , NAT_2:7;
L225: ( ( carry (C41 , ( Bin1 C40 )) ) /. ( C40 -' C44 ) ) = ( TRUE ) by L222 , MARGREL1:12;
thus L226: thesis by L225 , L210 , NAT_2:7;
end;
L227: 1 <= D2 by NAT_1:11;
L228: D2 = ( ( C40 - C43 ) + 1 ) by L199 , XREAL_1:233
.= ( C40 - ( C43 - 1 ) );
L229: D2 <= ( C40 - 1 ) by L228 , L202 , XREAL_1:13;
L230: ( D2 + 1 ) <= C40 by L229 , XREAL_1:19;
L231: D2 < C40 by L230 , NAT_1:13;
L232: C43 = ( ( C40 -' D2 ) + 1 ) by L231 , L199 , NAT_2:5;
L233: D2 <= ( C40 -' 1 ) by L229 , NAT_1:14 , XREAL_1:233;
L234: D2 in ( Seg ( C40 -' 1 ) ) by L233 , L227 , FINSEQ_1:1;
L235: S5[ 1 ] by L196 , L197 , NAT_1:14 , XREAL_1:235;
L236: (for B44 being non  empty Nat holds S5[ B44 ]) from NAT_1:sch 10(L235 , L203);
thus L237: thesis by L236 , L232 , L234;
end;
theorem
L238: (for B45 being non  empty Nat holds (for B46 being (Tuple of B45 , ( BOOLEAN )) holds ((( B46 /. B45 ) = ( TRUE ) & ( ( carry (B46 , ( Bin1 B45 )) ) /. B45 ) = ( TRUE )) implies ( carry (B46 , ( Bin1 B45 )) ) = ( 'not' ( Bin1 B45 ) ))))
proof
let C45 being non  empty Nat;
let C46 being (Tuple of C45 , ( BOOLEAN ));
assume that
L239: ( C46 /. C45 ) = ( TRUE )
and
L240: ( ( carry (C46 , ( Bin1 C45 )) ) /. C45 ) = ( TRUE );
L241:
now
L242: ( len ( 'not' ( Bin1 C45 ) ) ) = C45 by CARD_1:def 7;
let C47 being Nat;
reconsider D3 = C47 as Nat;
L243: ( len ( carry (C46 , ( Bin1 C45 )) ) ) = C45 by CARD_1:def 7;
assume L244: C47 in ( Seg C45 );
L245: 1 <= C47 by L244 , FINSEQ_1:1;
L246: C47 <= C45 by L244 , FINSEQ_1:1;
per cases ;
suppose L247: C47 = 1;

thus L248: ( ( carry (C46 , ( Bin1 C45 )) ) . C47 ) = ( ( carry (C46 , ( Bin1 C45 )) ) /. D3 ) by L245 , L246 , L243 , FINSEQ_4:15
.= ( 'not' ( TRUE ) ) by L247 , BINARITH:def 2
.= ( 'not' ( ( Bin1 C45 ) /. C47 ) ) by L244 , L247 , BINARI_2:5
.= ( ( 'not' ( Bin1 C45 ) ) /. D3 ) by L244 , BINARITH:def 1
.= ( ( 'not' ( Bin1 C45 ) ) . C47 ) by L245 , L246 , L242 , FINSEQ_4:15;
end;
suppose L249: C47 <> 1;

L250: C47 is non  empty by L244 , FINSEQ_1:1;
thus L251: ( ( carry (C46 , ( Bin1 C45 )) ) . C47 ) = ( ( carry (C46 , ( Bin1 C45 )) ) /. D3 ) by L245 , L246 , L243 , FINSEQ_4:15
.= ( 'not' ( FALSE ) ) by L239 , L240 , L246 , L249 , L250 , L195
.= ( 'not' ( ( Bin1 C45 ) /. C47 ) ) by L244 , L249 , BINARI_2:6
.= ( ( 'not' ( Bin1 C45 ) ) /. D3 ) by L244 , BINARITH:def 1
.= ( ( 'not' ( Bin1 C45 ) ) . C47 ) by L245 , L246 , L242 , FINSEQ_4:15;
end;
end;
thus L253: thesis by L241 , FINSEQ_2:119;
end;
theorem
L254: (for B47 being non  empty Nat holds (for B48 , B49 being (Tuple of B47 , ( BOOLEAN )) holds ((B49 = ( 0* B47 ) & ( B48 /. B47 ) = ( TRUE ) & ( ( carry (B48 , ( Bin1 B47 )) ) /. B47 ) = ( TRUE )) implies B48 = ( 'not' B49 ))))
proof
let C48 being non  empty Nat;
let C49 , C50 being (Tuple of C48 , ( BOOLEAN ));
assume that
L255: C50 = ( 0* C48 )
and
L256: ( C49 /. C48 ) = ( TRUE )
and
L257: ( ( carry (C49 , ( Bin1 C48 )) ) /. C48 ) = ( TRUE );
L258: ( len C49 ) = C48 by CARD_1:def 7;
L259: ( len ( 'not' C50 ) ) = C48 by CARD_1:def 7;
L260: ( len C50 ) = C48 by CARD_1:def 7;
L261: ( len ( carry (C49 , ( Bin1 C48 )) ) ) = C48 by CARD_1:def 7;
L262:
now
let C51 being Nat;
reconsider D4 = C51 as Nat;
assume L263: C51 in ( Seg C48 );
L264: 1 <= C51 by L263 , FINSEQ_1:1;
L265: C51 <= C48 by L263 , FINSEQ_1:1;
L266: ( C50 . C51 ) = ( FALSE ) by L255 , L263 , FUNCOP_1:7;
L267:
now
per cases ;
suppose L268: C51 = 1;

L269: C48 >= 1 by NAT_1:14;
L270:
now
per cases  by L269 , XXREAL_0:1;
suppose L271: C48 = 1;

thus L272: ( C49 . C51 ) = ( ( 'not' C50 ) . C51 ) by L271 , L257 , BINARITH:def 2;
end;
suppose L273: C48 > 1;

L274: ( len ( 'not' ( Bin1 C48 ) ) ) = C48 by CARD_1:def 7;
L275: ( ( carry (C49 , ( Bin1 C48 )) ) /. C51 ) = ( FALSE ) by L268 , BINARITH:def 2;
L276: ( ( ( Bin1 C48 ) /. C51 ) '&' ( ( carry (C49 , ( Bin1 C48 )) ) /. C51 ) ) = ( FALSE ) by L275;
L277: ( 1 + 1 ) <= C48 by L273 , NAT_1:13;
L278: 2 in ( Seg C48 ) by L277 , FINSEQ_1:1;
L279: ( ( carry (C49 , ( Bin1 C48 )) ) . ( C51 + 1 ) ) = ( ( 'not' ( Bin1 C48 ) ) . 2 ) by L256 , L257 , L268 , L238
.= ( ( 'not' ( Bin1 C48 ) ) /. 2 ) by L277 , L274 , FINSEQ_4:15
.= ( 'not' ( ( Bin1 C48 ) /. 2 ) ) by L278 , BINARITH:def 1
.= ( 'not' ( FALSE ) ) by L278 , BINARI_2:6
.= ( TRUE );
L280: ( TRUE ) = ( ( carry (C49 , ( Bin1 C48 )) ) /. ( C51 + 1 ) ) by L279 , L261 , L268 , L277 , FINSEQ_4:15
.= ( ( ( C49 /. C51 ) '&' ( ( Bin1 C48 ) /. C51 ) ) 'or' ( ( C49 /. C51 ) '&' ( ( carry (C49 , ( Bin1 C48 )) ) /. C51 ) ) ) by L268 , L273 , L275 , L276 , BINARITH:def 2
.= ( ( C49 /. C51 ) '&' ( ( Bin1 C48 ) /. C51 ) ) by L275;
thus L281: ( C49 . C51 ) = ( C49 /. D4 ) by L258 , L264 , L265 , FINSEQ_4:15
.= ( 'not' ( FALSE ) ) by L280 , MARGREL1:12
.= ( 'not' ( C50 /. D4 ) ) by L260 , L264 , L265 , L266 , FINSEQ_4:15
.= ( ( 'not' C50 ) /. D4 ) by L263 , BINARITH:def 1
.= ( ( 'not' C50 ) . C51 ) by L259 , L264 , L265 , FINSEQ_4:15;
end;
end;
thus L283: ( C49 . C51 ) = ( ( 'not' C50 ) . C51 ) by L270;
end;
suppose L284: C51 <> 1;

L285: C51 is non  empty by L263 , FINSEQ_1:1;
thus L286: ( C49 . C51 ) = ( C49 /. D4 ) by L258 , L264 , L265 , FINSEQ_4:15
.= ( 'not' ( FALSE ) ) by L256 , L257 , L265 , L284 , L285 , L195
.= ( 'not' ( C50 /. D4 ) ) by L260 , L264 , L265 , L266 , FINSEQ_4:15
.= ( ( 'not' C50 ) /. D4 ) by L263 , BINARITH:def 1
.= ( ( 'not' C50 ) . C51 ) by L259 , L264 , L265 , FINSEQ_4:15;
end;
end;
thus L288: ( C49 . C51 ) = ( ( 'not' C50 ) . C51 ) by L267;
end;
thus L289: thesis by L262 , FINSEQ_2:119;
end;
theorem
L290: (for B50 being non  empty Nat holds (for B51 being (Tuple of B50 , ( BOOLEAN )) holds (B51 = ( 0* B50 ) implies ( carry (( 'not' B51 ) , ( Bin1 B50 )) ) = ( 'not' ( Bin1 B50 ) ))))
proof
let C52 being non  empty Nat;
let C53 being (Tuple of C52 , ( BOOLEAN ));
L291: C52 >= 1 by NAT_1:14;
L292: ( len C53 ) = C52 by CARD_1:def 7;
assume L293: C53 = ( 0* C52 );
L294: ( C53 . C52 ) = ( 0 ) by L293 , FINSEQ_1:3 , FUNCOP_1:7;
L295: C52 in ( Seg C52 ) by FINSEQ_1:3;
L296: ( ( 'not' C53 ) /. C52 ) = ( 'not' ( C53 /. C52 ) ) by L295 , BINARITH:def 1
.= ( 'not' ( FALSE ) ) by L291 , L294 , L292 , FINSEQ_4:15
.= ( TRUE );
per cases ;
suppose L297: C52 = 1;

L298:
now
let C54 being Nat;
L299: ( len ( 'not' ( Bin1 C52 ) ) ) = C52 by CARD_1:def 7;
assume L300: C54 in ( Seg C52 );
L301: C54 = 1 by L300 , L297 , FINSEQ_1:2 , TARSKI:def 1;
L302: ( len ( carry (( 'not' C53 ) , ( Bin1 C52 )) ) ) = C52 by CARD_1:def 7;
thus L303: ( ( carry (( 'not' C53 ) , ( Bin1 C52 )) ) . C54 ) = ( ( carry (( 'not' C53 ) , ( Bin1 C52 )) ) /. C54 ) by L302 , L297 , L301 , FINSEQ_4:15
.= ( 'not' ( TRUE ) ) by L301 , BINARITH:def 2
.= ( 'not' ( ( Bin1 C52 ) /. C54 ) ) by L300 , L301 , BINARI_2:5
.= ( ( 'not' ( Bin1 C52 ) ) /. C54 ) by L300 , BINARITH:def 1
.= ( ( 'not' ( Bin1 C52 ) ) . C54 ) by L297 , L301 , L299 , FINSEQ_4:15;
end;
thus L304: thesis by L298 , FINSEQ_2:119;
end;
suppose L305: C52 <> 1;

L306: C52 is non  trivial by L305 , NAT_2:def 1;
defpred S6[ Nat ] means ($1 <= C52 implies ( ( carry (( 'not' C53 ) , ( Bin1 C52 )) ) /. $1 ) = ( TRUE ));
L307: (for B52 being non  trivial Nat holds (S6[ B52 ] implies S6[ ( B52 + 1 ) ]))
proof
let C55 being non  trivial Nat;
assume that
L308: (C55 <= C52 implies ( ( carry (( 'not' C53 ) , ( Bin1 C52 )) ) /. C55 ) = ( TRUE ))
and
L309: ( C55 + 1 ) <= C52;
L310: 1 <= C55 by NAT_1:14;
L311: C55 < C52 by L309 , NAT_1:13;
L312: C55 in ( Seg C52 ) by L311 , L310 , FINSEQ_1:1;
L313: ( C53 . C55 ) = ( FALSE ) by L312 , L293 , FUNCOP_1:7;
L314: ( ( 'not' C53 ) /. C55 ) = ( 'not' ( C53 /. C55 ) ) by L312 , BINARITH:def 1
.= ( 'not' ( FALSE ) ) by L292 , L310 , L311 , L313 , FINSEQ_4:15
.= ( TRUE );
L315: C55 <> 1 by NAT_2:def 1;
L316: ( ( Bin1 C52 ) /. C55 ) = ( FALSE ) by L315 , L312 , BINARI_2:6;
L317: ( ( ( Bin1 C52 ) /. C55 ) '&' ( ( carry (( 'not' C53 ) , ( Bin1 C52 )) ) /. C55 ) ) = ( FALSE ) by L316;
thus L318: ( ( carry (( 'not' C53 ) , ( Bin1 C52 )) ) /. ( C55 + 1 ) ) = ( ( ( ( 'not' C53 ) /. C55 ) '&' ( ( Bin1 C52 ) /. C55 ) ) 'or' ( ( ( 'not' C53 ) /. C55 ) '&' ( ( carry (( 'not' C53 ) , ( Bin1 C52 )) ) /. C55 ) ) ) by L317 , L310 , L311 , L316 , BINARITH:def 2
.= ( TRUE ) by L308 , L309 , L314 , NAT_1:13;
end;
L319: S6[ 2 ]
proof
assume L320: 2 <= C52;
L321: ( 1 + 1 ) <= C52 by L320;
L322: 1 < C52 by L321 , NAT_1:13;
L323: 1 in ( Seg C52 ) by L322 , FINSEQ_1:1;
L324: ( C53 . 1 ) = ( FALSE ) by L323 , L293 , FUNCOP_1:7;
L325: ( ( 'not' C53 ) /. 1 ) = ( 'not' ( C53 /. 1 ) ) by L323 , BINARITH:def 1
.= ( 'not' ( FALSE ) ) by L292 , L322 , L324 , FINSEQ_4:15
.= ( TRUE );
L326: ( ( ( 'not' C53 ) /. 1 ) '&' ( ( Bin1 C52 ) /. 1 ) ) = ( TRUE ) by L325 , L323 , BINARI_2:5;
thus L327: ( ( carry (( 'not' C53 ) , ( Bin1 C52 )) ) /. 2 ) = ( ( carry (( 'not' C53 ) , ( Bin1 C52 )) ) /. ( 1 + 1 ) )
.= ( ( ( ( ( 'not' C53 ) /. 1 ) '&' ( ( Bin1 C52 ) /. 1 ) ) 'or' ( ( ( 'not' C53 ) /. 1 ) '&' ( ( carry (( 'not' C53 ) , ( Bin1 C52 )) ) /. 1 ) ) ) 'or' ( ( ( Bin1 C52 ) /. 1 ) '&' ( ( carry (( 'not' C53 ) , ( Bin1 C52 )) ) /. 1 ) ) ) by L322 , BINARITH:def 2
.= ( TRUE ) by L326;
end;
L328: (for B53 being non  trivial Nat holds S6[ B53 ]) from NAT_2:sch 2(L319 , L307);
L329: ( ( carry (( 'not' C53 ) , ( Bin1 C52 )) ) /. C52 ) = ( TRUE ) by L328 , L306;
thus L330: thesis by L329 , L296 , L238;
end;
end;
theorem
L332: (for B54 being non  empty Nat holds (for B55 , B56 being (Tuple of B54 , ( BOOLEAN )) holds (B56 = ( 0* B54 ) implies (( add_ovfl (B55 , ( Bin1 B54 )) ) = ( TRUE ) iff B55 = ( 'not' B56 )))))
proof
let C56 being non  empty Nat;
let C57 , C58 being (Tuple of C56 , ( BOOLEAN ));
assume L333: C58 = ( 0* C56 );
L334: C56 in ( Seg C56 ) by FINSEQ_1:3;
L335: 1 in ( Seg 1 ) by FINSEQ_1:3;
thus L336: (( add_ovfl (C57 , ( Bin1 C56 )) ) = ( TRUE ) implies C57 = ( 'not' C58 ))
proof
assume L337: ( add_ovfl (C57 , ( Bin1 C56 )) ) = ( TRUE );
L338: ( ( ( ( C57 /. C56 ) '&' ( ( Bin1 C56 ) /. C56 ) ) 'or' ( ( C57 /. C56 ) '&' ( ( carry (C57 , ( Bin1 C56 )) ) /. C56 ) ) ) 'or' ( ( ( Bin1 C56 ) /. C56 ) '&' ( ( carry (C57 , ( Bin1 C56 )) ) /. C56 ) ) ) = ( TRUE ) by L337 , BINARITH:def 6;
per cases ;
suppose L339: C56 <> 1;

L340:
now
per cases  by L338 , L124;
suppose L341: ( ( ( C57 /. C56 ) '&' ( ( Bin1 C56 ) /. C56 ) ) 'or' ( ( C57 /. C56 ) '&' ( ( carry (C57 , ( Bin1 C56 )) ) /. C56 ) ) ) = ( TRUE );

L342:
now
per cases  by L341 , L124;
suppose L343: ( ( C57 /. C56 ) '&' ( ( Bin1 C56 ) /. C56 ) ) = ( TRUE );

assume L344: C57 <> ( 'not' C58 );
L345: ( ( Bin1 C56 ) /. C56 ) = ( TRUE ) by L343 , MARGREL1:12;
thus L346: contradiction by L345 , L334 , L339 , BINARI_2:6;
end;
suppose L347: ( ( C57 /. C56 ) '&' ( ( carry (C57 , ( Bin1 C56 )) ) /. C56 ) ) = ( TRUE );

L348: ( C57 /. C56 ) = ( TRUE ) by L347 , MARGREL1:12;
thus L349: thesis by L348 , L333 , L347 , L254;
end;
end;
thus L351: thesis by L342;
end;
suppose L352: ( ( ( Bin1 C56 ) /. C56 ) '&' ( ( carry (C57 , ( Bin1 C56 )) ) /. C56 ) ) = ( TRUE );

assume L353: C57 <> ( 'not' C58 );
L354: ( ( Bin1 C56 ) /. C56 ) = ( TRUE ) by L352 , MARGREL1:12;
thus L355: contradiction by L354 , L334 , L339 , BINARI_2:6;
end;
end;
thus L357: thesis by L340;
end;
suppose L358: C56 = 1;

L359: ( len C58 ) = 1 by L358 , CARD_1:def 7;
L360: 1 in ( dom C58 ) by L359 , L335 , FINSEQ_1:def 3;
L361: ( C58 /. 1 ) = ( C58 . 1 ) by L360 , PARTFUN1:def 6
.= ( 0 ) by L333 , L358 , FINSEQ_1:3 , FUNCOP_1:7;
consider C59 being (Element of ( BOOLEAN )) such that L362: C57 = <* C59 *> by L358 , FINSEQ_2:97;
L363: C59 = ( TRUE ) by L337 , L358 , L362 , L113 , L135;
L364:
now
let C60 being Nat;
assume L365: C60 in ( Seg C56 );
L366: C60 = 1 by L365 , L358 , FINSEQ_1:2 , TARSKI:def 1;
thus L367: ( C57 /. C60 ) = ( 'not' ( C58 /. C60 ) ) by L366 , L362 , L363 , L361 , FINSEQ_4:16;
end;
thus L368: thesis by L364 , BINARITH:def 1;
end;
end;

assume L370: C57 = ( 'not' C58 );
per cases ;
suppose L371: C56 <> 1;

L372: ( ( carry (C57 , ( Bin1 C56 )) ) /. C56 ) = ( ( 'not' ( Bin1 C56 ) ) /. C56 ) by L333 , L370 , L290
.= ( 'not' ( ( Bin1 C56 ) /. C56 ) ) by L334 , BINARITH:def 1
.= ( 'not' ( FALSE ) ) by L334 , L371 , BINARI_2:6
.= ( TRUE );
L373: ( len C58 ) = C56 by CARD_1:def 7;
L374: C56 in ( dom C58 ) by L373 , L334 , FINSEQ_1:def 3;
L375: ( C58 /. C56 ) = ( C58 . C56 ) by L374 , PARTFUN1:def 6
.= ( 0 ) by L333 , FINSEQ_1:3 , FUNCOP_1:7;
L376: ( C57 /. C56 ) = ( 'not' ( C58 /. C56 ) ) by L334 , L370 , BINARITH:def 1
.= ( TRUE ) by L375;
thus L377: ( add_ovfl (C57 , ( Bin1 C56 )) ) = ( ( ( ( C57 /. C56 ) '&' ( ( Bin1 C56 ) /. C56 ) ) 'or' ( ( C57 /. C56 ) '&' ( ( carry (C57 , ( Bin1 C56 )) ) /. C56 ) ) ) 'or' ( ( ( Bin1 C56 ) /. C56 ) '&' ( ( carry (C57 , ( Bin1 C56 )) ) /. C56 ) ) ) by BINARITH:def 6
.= ( TRUE ) by L376 , L372;
end;
suppose L378: C56 = 1;

L379: ( len C58 ) = 1 by L378 , CARD_1:def 7;
L380: 1 in ( dom C58 ) by L379 , L335 , FINSEQ_1:def 3;
L381: ( C58 /. 1 ) = ( C58 . 1 ) by L380 , PARTFUN1:def 6
.= ( 0 ) by L333 , L378 , FINSEQ_1:3 , FUNCOP_1:7;
consider C61 being (Element of ( BOOLEAN )) such that L382: C57 = <* C61 *> by L378 , FINSEQ_2:97;
L383: C61 = ( ( 'not' C58 ) /. 1 ) by L370 , L382 , FINSEQ_4:16
.= ( 'not' ( C58 /. 1 ) ) by L335 , L378 , BINARITH:def 1
.= ( TRUE ) by L381;
thus L384: thesis by L383 , L378 , L382 , L113 , L135;
end;
end;
theorem
L386: (for B57 being non  empty Nat holds (for B58 being (Tuple of B57 , ( BOOLEAN )) holds (B58 = ( 0* B57 ) implies ( ( 'not' B58 ) + ( Bin1 B57 ) ) = B58)))
proof
let C62 being non  empty Nat;
let C63 being (Tuple of C62 , ( BOOLEAN ));
assume L387: C63 = ( 0* C62 );
L388: ( add_ovfl (( 'not' C63 ) , ( Bin1 C62 )) ) = ( TRUE ) by L387 , L332;
L389: ( Absval ( ( 'not' C63 ) + ( Bin1 C62 ) ) ) = ( ( ( Absval ( ( 'not' C63 ) + ( Bin1 C62 ) ) ) + ( 2 to_power C62 ) ) - ( 2 to_power C62 ) )
.= ( ( ( Absval ( ( 'not' C63 ) + ( Bin1 C62 ) ) ) + ( IFEQ (( add_ovfl (( 'not' C63 ) , ( Bin1 C62 )) ) , ( FALSE ) , ( 0 ) , ( 2 to_power C62 )) ) ) - ( 2 to_power C62 ) ) by L388 , FUNCOP_1:def 8
.= ( ( ( Absval ( 'not' C63 ) ) + ( Absval ( Bin1 C62 ) ) ) - ( 2 to_power C62 ) ) by BINARITH:21
.= ( ( ( ( ( - ( Absval C63 ) ) + ( 2 to_power C62 ) ) - 1 ) + ( Absval ( Bin1 C62 ) ) ) - ( 2 to_power C62 ) ) by BINARI_2:13
.= ( ( ( ( ( - ( Absval C63 ) ) + ( 2 to_power C62 ) ) - 1 ) + 1 ) - ( 2 to_power C62 ) ) by L118
.= ( - ( 0 ) ) by L387 , L80
.= ( Absval C63 ) by L387 , L80;
thus L390: thesis by L389 , L27;
end;
begin
definition
let C64 , C65 being Nat;
func C64 -BinarySequence C65 -> (Tuple of C64 , ( BOOLEAN )) means 
:L391: (for B59 being Nat holds (B59 in ( Seg C64 ) implies ( it /. B59 ) = ( IFEQ (( ( C65 div ( 2 to_power ( B59 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) )));
existence
proof
reconsider D5 = C64 as Nat;
deffunc H1(Nat) = ( IFEQ (( ( C65 div ( 2 to_power ( $1 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) );
consider C66 being (FinSequence of ( BOOLEAN )) such that L392: ( len C66 ) = D5 and L393: (for B60 being Nat holds (B60 in ( dom C66 ) implies ( C66 . B60 ) = H1(B60))) from FINSEQ_2:sch 1;
L394: ( dom C66 ) = ( Seg D5 ) by L392 , FINSEQ_1:def 3;
reconsider D6 = C66 as (Element of ( C64 -tuples_on ( BOOLEAN ) )) by L392 , FINSEQ_2:92;
take D6;
let C67 being Nat;
assume L395: C67 in ( Seg C64 );
L396: C67 in ( dom D6 ) by L395 , L392 , FINSEQ_1:def 3;
thus L397: ( D6 /. C67 ) = ( D6 . C67 ) by L396 , PARTFUN1:def 6
.= ( IFEQ (( ( C65 div ( 2 to_power ( C67 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L393 , L394 , L395;
end;
uniqueness
proof
let C68 , C69 being (Tuple of C64 , ( BOOLEAN ));
assume that
L398: (for B61 being Nat holds (B61 in ( Seg C64 ) implies ( C68 /. B61 ) = ( IFEQ (( ( C65 div ( 2 to_power ( B61 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) )))
and
L399: (for B62 being Nat holds (B62 in ( Seg C64 ) implies ( C69 /. B62 ) = ( IFEQ (( ( C65 div ( 2 to_power ( B62 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) )));
L400: ( len C68 ) = C64 by CARD_1:def 7;
L401: ( dom C68 ) = ( Seg C64 ) by L400 , FINSEQ_1:def 3;
L402: ( len C69 ) = C64 by CARD_1:def 7;
L403:
now
let C70 being Nat;
assume L404: C70 in ( dom C68 );
L405: C70 in ( dom C69 ) by L404 , L402 , L401 , FINSEQ_1:def 3;
thus L406: ( C68 . C70 ) = ( C68 /. C70 ) by L404 , PARTFUN1:def 6
.= ( IFEQ (( ( C65 div ( 2 to_power ( C70 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L398 , L401 , L404
.= ( C69 /. C70 ) by L399 , L401 , L404
.= ( C69 . C70 ) by L405 , PARTFUN1:def 6;
end;
thus L407: thesis by L403 , L400 , L402 , FINSEQ_2:9;
end;
end;
theorem
L409: (for B63 being Nat holds ( B63 -BinarySequence ( 0 ) ) = ( 0* B63 ))
proof
let C71 being Nat;
L410: ( 0* C71 ) in ( ( BOOLEAN ) * ) by L65;
L411: ( 0* C71 ) is (FinSequence of ( BOOLEAN )) by L410 , FINSEQ_1:def 11;
reconsider D7 = ( 0* C71 ) as (Tuple of C71 , ( BOOLEAN )) by L411;
L412:
now
let C72 being Nat;
assume L413: C72 in ( Seg C71 );
L414: ( len ( C71 -BinarySequence ( 0 ) ) ) = C71 by CARD_1:def 7;
L415: C72 in ( dom ( C71 -BinarySequence ( 0 ) ) ) by L414 , L413 , FINSEQ_1:def 3;
thus L416: ( ( C71 -BinarySequence ( 0 ) ) . C72 ) = ( ( C71 -BinarySequence ( 0 ) ) /. C72 ) by L415 , PARTFUN1:def 6
.= ( IFEQ (( ( ( 0 ) div ( 2 to_power ( C72 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L413 , L391
.= ( IFEQ (( ( 0 ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by NAT_2:2
.= ( IFEQ (( 0 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by NAT_D:26
.= ( 0 ) by FUNCOP_1:def 8
.= ( D7 . C72 ) by L413 , FUNCOP_1:7;
end;
thus L417: thesis by L412 , FINSEQ_2:119;
end;
theorem
L418: (for B64 , B65 being Nat holds (B65 < ( 2 to_power B64 ) implies ( ( ( B64 + 1 ) -BinarySequence B65 ) . ( B64 + 1 ) ) = ( FALSE )))
proof
let C73 , C74 being Nat;
L419: ( ( C73 + 1 ) -' 1 ) = ( ( C73 + 1 ) - 1 ) by NAT_D:37
.= C73;
assume L420: C74 < ( 2 to_power C73 );
L421: ( ( C74 div ( 2 to_power ( ( C73 + 1 ) -' 1 ) ) ) mod 2 ) = ( ( 0 ) mod 2 ) by L420 , L419 , NAT_D:27
.= ( 0 ) by NAT_D:26;
L422: ( C73 + 1 ) in ( Seg ( C73 + 1 ) ) by FINSEQ_1:4;
L423: ( C73 + 1 ) in ( Seg ( len ( ( C73 + 1 ) -BinarySequence C74 ) ) ) by L422 , CARD_1:def 7;
L424: ( C73 + 1 ) in ( dom ( ( C73 + 1 ) -BinarySequence C74 ) ) by L423 , FINSEQ_1:def 3;
thus L425: ( ( ( C73 + 1 ) -BinarySequence C74 ) . ( C73 + 1 ) ) = ( ( ( C73 + 1 ) -BinarySequence C74 ) /. ( C73 + 1 ) ) by L424 , PARTFUN1:def 6
.= ( IFEQ (( ( C74 div ( 2 to_power ( ( C73 + 1 ) -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L422 , L391
.= ( FALSE ) by L421 , FUNCOP_1:def 8;
end;
theorem
L426: (for B66 being non  empty Nat holds (for B67 being Nat holds (B67 < ( 2 to_power B66 ) implies ( ( B66 + 1 ) -BinarySequence B67 ) = ( ( B66 -BinarySequence B67 ) ^ <* ( FALSE ) *> ))))
proof
let C75 being non  empty Nat;
let C76 being Nat;
assume L427: C76 < ( 2 to_power C75 );
L428:
now
let C77 being Nat;
assume L429: C77 in ( Seg ( C75 + 1 ) );
L430: C77 in ( Seg ( len ( ( C75 + 1 ) -BinarySequence C76 ) ) ) by L429 , CARD_1:def 7;
L431: C77 in ( dom ( ( C75 + 1 ) -BinarySequence C76 ) ) by L430 , FINSEQ_1:def 3;
L432:
now
per cases  by L429 , FINSEQ_2:7;
suppose L433: C77 in ( Seg C75 );

L434: C77 in ( Seg ( len ( C75 -BinarySequence C76 ) ) ) by L433 , CARD_1:def 7;
L435: C77 in ( dom ( C75 -BinarySequence C76 ) ) by L434 , FINSEQ_1:def 3;
thus L436: ( ( ( C75 + 1 ) -BinarySequence C76 ) . C77 ) = ( ( ( C75 + 1 ) -BinarySequence C76 ) /. C77 ) by L431 , PARTFUN1:def 6
.= ( IFEQ (( ( C76 div ( 2 to_power ( C77 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L429 , L391
.= ( ( C75 -BinarySequence C76 ) /. C77 ) by L433 , L391
.= ( ( C75 -BinarySequence C76 ) . C77 ) by L435 , PARTFUN1:def 6
.= ( ( ( C75 -BinarySequence C76 ) ^ <* ( FALSE ) *> ) . C77 ) by L435 , FINSEQ_1:def 7;
end;
suppose L437: C77 = ( C75 + 1 );

thus L438: ( ( ( C75 + 1 ) -BinarySequence C76 ) . C77 ) = ( FALSE ) by L437 , L427 , L418
.= ( ( ( C75 -BinarySequence C76 ) ^ <* ( FALSE ) *> ) . C77 ) by L437 , FINSEQ_2:116;
end;
end;
thus L440: ( ( ( C75 + 1 ) -BinarySequence C76 ) . C77 ) = ( ( ( C75 -BinarySequence C76 ) ^ <* ( FALSE ) *> ) . C77 ) by L432;
end;
thus L441: thesis by L428 , FINSEQ_2:119;
end;
L442: (for B68 being non  empty Nat holds ( ( B68 + 1 ) -BinarySequence ( 2 to_power B68 ) ) = ( ( 0* B68 ) ^ <* ( TRUE ) *> ))
proof
let C78 being non  empty Nat;
L443: ( 0* C78 ) in ( ( BOOLEAN ) * ) by L65;
L444: ( 0* C78 ) is (FinSequence of ( BOOLEAN )) by L443 , FINSEQ_1:def 11;
reconsider D8 = ( 0* C78 ) as (Tuple of C78 , ( BOOLEAN )) by L444;
L445:
now
let C79 being Nat;
assume L446: C79 in ( Seg ( C78 + 1 ) );
L447:
now
per cases  by L446 , FINSEQ_2:7;
suppose L448: C79 in ( Seg C78 );

L449: C79 >= 1 by L448 , FINSEQ_1:1;
L450: C79 <= ( C78 + 1 ) by L446 , FINSEQ_1:1;
L451: ( C79 - 1 ) <= ( ( C78 + 1 ) - 1 ) by L450 , XREAL_1:9;
L452: ( C79 -' 1 ) <= ( ( C78 + 1 ) - 1 ) by L451 , L449 , XREAL_1:233;
L453: C78 = ( ( C78 - ( C79 -' 1 ) ) + ( C79 -' 1 ) )
.= ( ( C78 -' ( C79 -' 1 ) ) + ( C79 -' 1 ) ) by L452 , XREAL_1:233;
L454: ( 2 to_power C78 ) = ( ( 2 to_power ( C78 -' ( C79 -' 1 ) ) ) * ( 2 to_power ( C79 -' 1 ) ) ) by L453 , POWER:27;
L455: C79 in ( Seg ( len D8 ) ) by L448 , CARD_1:def 7;
L456: C79 in ( dom D8 ) by L455 , FINSEQ_1:def 3;
L457: C78 >= C79 by L448 , FINSEQ_1:1;
L458: ( C78 + 1 ) > C79 by L457 , NAT_1:13;
L459: C78 > ( C79 - 1 ) by L458 , XREAL_1:19;
L460: ( C78 - ( C79 - 1 ) ) > ( 0 ) by L459 , XREAL_1:50;
L461: ( C78 - ( C79 -' 1 ) ) > ( 0 ) by L460 , L449 , XREAL_1:233;
L462: ( C78 -' ( C79 -' 1 ) ) > ( 0 ) by L461 , L452 , XREAL_1:233;
consider C80 being Nat such that L463: ( C78 -' ( C79 -' 1 ) ) = ( C80 + 1 ) by L462 , NAT_1:6;
reconsider D9 = C80 as Nat;
L464: ( 2 to_power ( C78 -' ( C79 -' 1 ) ) ) = ( ( 2 to_power D9 ) * ( 2 to_power 1 ) ) by L463 , POWER:27
.= ( ( 2 to_power D9 ) * 2 ) by POWER:25;
L465: ( 2 to_power ( C79 -' 1 ) ) > ( 0 ) by POWER:34;
L466: ( ( ( 2 to_power C78 ) div ( 2 to_power ( C79 -' 1 ) ) ) mod 2 ) = ( ( 2 to_power ( C78 -' ( C79 -' 1 ) ) ) mod 2 ) by L465 , L454 , NAT_D:20
.= ( 0 ) by L464 , NAT_D:13;
L467: C79 in ( Seg ( len ( ( C78 + 1 ) -BinarySequence ( 2 to_power C78 ) ) ) ) by L446 , CARD_1:def 7;
L468: C79 in ( dom ( ( C78 + 1 ) -BinarySequence ( 2 to_power C78 ) ) ) by L467 , FINSEQ_1:def 3;
thus L469: ( ( ( C78 + 1 ) -BinarySequence ( 2 to_power C78 ) ) . C79 ) = ( ( ( C78 + 1 ) -BinarySequence ( 2 to_power C78 ) ) /. C79 ) by L468 , PARTFUN1:def 6
.= ( IFEQ (( ( ( 2 to_power C78 ) div ( 2 to_power ( C79 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L446 , L391
.= ( 0 ) by L466 , FUNCOP_1:def 8
.= ( D8 . C79 ) by L448 , FUNCOP_1:7
.= ( ( D8 ^ <* ( TRUE ) *> ) . C79 ) by L456 , FINSEQ_1:def 7;
end;
suppose L470: C79 = ( C78 + 1 );

L471: ( 2 to_power C78 ) > ( 0 ) by POWER:34;
L472: ( C79 -' 1 ) = ( ( C78 + 1 ) - 1 ) by L470 , NAT_D:37
.= C78;
L473: ( ( ( 2 to_power C78 ) div ( 2 to_power ( C79 -' 1 ) ) ) mod 2 ) = ( 1 mod 2 ) by L472 , L471 , NAT_2:3
.= 1 by NAT_D:14;
L474: ( C78 + 1 ) in ( Seg ( C78 + 1 ) ) by FINSEQ_1:4;
L475: ( C78 + 1 ) in ( Seg ( len ( ( C78 + 1 ) -BinarySequence ( 2 to_power C78 ) ) ) ) by L474 , CARD_1:def 7;
L476: ( C78 + 1 ) in ( dom ( ( C78 + 1 ) -BinarySequence ( 2 to_power C78 ) ) ) by L475 , FINSEQ_1:def 3;
thus L477: ( ( ( C78 + 1 ) -BinarySequence ( 2 to_power C78 ) ) . C79 ) = ( ( ( C78 + 1 ) -BinarySequence ( 2 to_power C78 ) ) /. C79 ) by L476 , L470 , PARTFUN1:def 6
.= ( IFEQ (( ( ( 2 to_power C78 ) div ( 2 to_power ( C79 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L446 , L391
.= ( TRUE ) by L473 , FUNCOP_1:def 8
.= ( ( D8 ^ <* ( TRUE ) *> ) . C79 ) by L470 , FINSEQ_2:116;
end;
end;
thus L479: ( ( ( C78 + 1 ) -BinarySequence ( 2 to_power C78 ) ) . C79 ) = ( ( D8 ^ <* ( TRUE ) *> ) . C79 ) by L447;
end;
thus L480: thesis by L445 , FINSEQ_2:119;
end;
L481: (for B69 being non  empty Nat holds (for B70 being Nat holds ((( 2 to_power B69 ) <= B70 & B70 < ( 2 to_power ( B69 + 1 ) )) implies ( ( ( B69 + 1 ) -BinarySequence B70 ) . ( B69 + 1 ) ) = ( TRUE ))))
proof
let C81 being non  empty Nat;
let C82 being Nat;
assume that
L482: ( 2 to_power C81 ) <= C82
and
L483: C82 < ( 2 to_power ( C81 + 1 ) );
L484: C82 < ( ( 2 to_power C81 ) * ( 2 to_power 1 ) ) by L483 , POWER:27;
L485: C82 < ( 2 * ( 2 to_power C81 ) ) by L484 , POWER:25;
L486: C82 < ( ( 2 to_power C81 ) + ( 2 to_power C81 ) ) by L485;
L487: ( ( C81 + 1 ) -' 1 ) = ( ( C81 + 1 ) - 1 ) by NAT_D:37
.= C81;
L488: ( ( C82 div ( 2 to_power ( ( C81 + 1 ) -' 1 ) ) ) mod 2 ) = ( 1 mod 2 ) by L487 , L482 , L486 , NAT_2:20
.= 1 by NAT_D:24;
L489: ( C81 + 1 ) in ( Seg ( C81 + 1 ) ) by FINSEQ_1:4;
L490: ( C81 + 1 ) in ( Seg ( len ( ( C81 + 1 ) -BinarySequence C82 ) ) ) by L489 , CARD_1:def 7;
L491: ( C81 + 1 ) in ( dom ( ( C81 + 1 ) -BinarySequence C82 ) ) by L490 , FINSEQ_1:def 3;
thus L492: ( ( ( C81 + 1 ) -BinarySequence C82 ) . ( C81 + 1 ) ) = ( ( ( C81 + 1 ) -BinarySequence C82 ) /. ( C81 + 1 ) ) by L491 , PARTFUN1:def 6
.= ( IFEQ (( ( C82 div ( 2 to_power ( ( C81 + 1 ) -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L489 , L391
.= ( TRUE ) by L488 , FUNCOP_1:def 8;
end;
L493: (for B71 being non  empty Nat holds (for B72 being Nat holds ((( 2 to_power B71 ) <= B72 & B72 < ( 2 to_power ( B71 + 1 ) )) implies ( ( B71 + 1 ) -BinarySequence B72 ) = ( ( B71 -BinarySequence ( B72 -' ( 2 to_power B71 ) ) ) ^ <* ( TRUE ) *> ))))
proof
let C83 being non  empty Nat;
let C84 being Nat;
assume that
L494: ( 2 to_power C83 ) <= C84
and
L495: C84 < ( 2 to_power ( C83 + 1 ) );
L496:
now
let C85 being Nat;
reconsider D10 = C85 as Nat;
assume L497: C85 in ( Seg ( C83 + 1 ) );
L498: C85 in ( Seg ( len ( ( C83 + 1 ) -BinarySequence C84 ) ) ) by L497 , CARD_1:def 7;
L499: C85 in ( dom ( ( C83 + 1 ) -BinarySequence C84 ) ) by L498 , FINSEQ_1:def 3;
L500:
now
per cases  by L497 , FINSEQ_2:7;
suppose L501: C85 in ( Seg C83 );

L502: 1 <= C85 by L501 , FINSEQ_1:1;
L503: ( 2 * ( 2 to_power ( C85 -' 1 ) ) ) = ( ( 2 to_power ( C85 -' 1 ) ) * ( 2 to_power 1 ) ) by POWER:25
.= ( 2 to_power ( ( C85 -' 1 ) + 1 ) ) by POWER:27
.= ( 2 to_power ( ( C85 - 1 ) + 1 ) ) by L502 , XREAL_1:233
.= ( 2 to_power C85 );
L504: ( 2 to_power ( C85 -' 1 ) ) > ( 0 ) by POWER:34;
L505: ( ( 0 ) + 1 ) <= ( 2 to_power ( C85 -' 1 ) ) by L504 , NAT_1:13;
L506: C85 <= C83 by L501 , FINSEQ_1:1;
L507: ( 2 * ( 2 to_power ( D10 -' 1 ) ) ) divides ( 2 to_power C83 ) by L506 , L503 , NAT_2:11;
L508:
now
per cases ;
suppose L509: ( C84 div ( 2 to_power ( C85 -' 1 ) ) ) is  even;

L510: ( ( C84 div ( 2 to_power ( C85 -' 1 ) ) ) mod 2 ) = ( 0 ) by L509 , NAT_2:21;
L511: ( ( C84 -' ( 2 to_power C83 ) ) div ( 2 to_power ( C85 -' 1 ) ) ) is  even by L494 , L505 , L507 , L509 , NAT_2:23;
thus L512: ( ( C84 div ( 2 to_power ( C85 -' 1 ) ) ) mod 2 ) = ( ( ( C84 -' ( 2 to_power C83 ) ) div ( 2 to_power ( C85 -' 1 ) ) ) mod 2 ) by L511 , L510 , NAT_2:21;
end;
suppose L513: ( C84 div ( 2 to_power ( C85 -' 1 ) ) ) is  odd;

L514: ( ( C84 div ( 2 to_power ( C85 -' 1 ) ) ) mod 2 ) = 1 by L513 , NAT_2:22;
L515: ( ( C84 -' ( 2 to_power C83 ) ) div ( 2 to_power ( C85 -' 1 ) ) ) is  odd by L494 , L505 , L507 , L513 , NAT_2:23;
thus L516: ( ( C84 div ( 2 to_power ( C85 -' 1 ) ) ) mod 2 ) = ( ( ( C84 -' ( 2 to_power C83 ) ) div ( 2 to_power ( C85 -' 1 ) ) ) mod 2 ) by L515 , L514 , NAT_2:22;
end;
end;
L518: C85 in ( Seg ( len ( C83 -BinarySequence ( C84 -' ( 2 to_power C83 ) ) ) ) ) by L501 , CARD_1:def 7;
L519: C85 in ( dom ( C83 -BinarySequence ( C84 -' ( 2 to_power C83 ) ) ) ) by L518 , FINSEQ_1:def 3;
thus L520: ( ( ( C83 + 1 ) -BinarySequence C84 ) . C85 ) = ( ( ( C83 + 1 ) -BinarySequence C84 ) /. C85 ) by L499 , PARTFUN1:def 6
.= ( IFEQ (( ( C84 div ( 2 to_power ( C85 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L497 , L391
.= ( ( C83 -BinarySequence ( C84 -' ( 2 to_power C83 ) ) ) /. C85 ) by L501 , L508 , L391
.= ( ( C83 -BinarySequence ( C84 -' ( 2 to_power C83 ) ) ) . C85 ) by L519 , PARTFUN1:def 6
.= ( ( ( C83 -BinarySequence ( C84 -' ( 2 to_power C83 ) ) ) ^ <* ( TRUE ) *> ) . C85 ) by L519 , FINSEQ_1:def 7;
end;
suppose L521: C85 = ( C83 + 1 );

thus L522: ( ( ( C83 + 1 ) -BinarySequence C84 ) . C85 ) = ( TRUE ) by L521 , L494 , L495 , L481
.= ( ( ( C83 -BinarySequence ( C84 -' ( 2 to_power C83 ) ) ) ^ <* ( TRUE ) *> ) . C85 ) by L521 , FINSEQ_2:116;
end;
end;
thus L524: ( ( ( C83 + 1 ) -BinarySequence C84 ) . C85 ) = ( ( ( C83 -BinarySequence ( C84 -' ( 2 to_power C83 ) ) ) ^ <* ( TRUE ) *> ) . C85 ) by L500;
end;
thus L525: thesis by L496 , FINSEQ_2:119;
end;
L526: (for B73 being non  empty Nat holds (for B74 being Nat holds (B74 < ( 2 to_power B73 ) implies (for B75 being (Tuple of B73 , ( BOOLEAN )) holds (B75 = ( 0* B73 ) implies (( B73 -BinarySequence B74 ) = ( 'not' B75 ) iff B74 = ( ( 2 to_power B73 ) - 1 )))))))
proof
let C86 being non  empty Nat;
let C87 being Nat;
assume L527: C87 < ( 2 to_power C86 );
let C88 being (Tuple of C86 , ( BOOLEAN ));
assume L528: C88 = ( 0* C86 );
thus L529: (( C86 -BinarySequence C87 ) = ( 'not' C88 ) implies C87 = ( ( 2 to_power C86 ) - 1 ))
proof
defpred S7[ Nat ] means (for B76 being Nat holds (B76 < ( 2 to_power $1 ) implies (for B77 being (Tuple of $1 , ( BOOLEAN )) holds (B77 = ( 0* $1 ) implies (( $1 -BinarySequence B76 ) = ( 'not' B77 ) implies B76 = ( ( 2 to_power $1 ) - 1 ))))));
assume L530: ( C86 -BinarySequence C87 ) = ( 'not' C88 );
L531: (for B78 being non  empty Nat holds (S7[ B78 ] implies S7[ ( B78 + 1 ) ]))
proof
let C89 being non  empty Nat;
assume L532: S7[ C89 ];
L533: ( C89 + 1 ) in ( Seg ( C89 + 1 ) ) by FINSEQ_1:4;
L534: ( 0 ) <= C89 by NAT_1:2;
L535: ( ( 0 ) + 1 ) <= ( C89 + 1 ) by L534 , XREAL_1:6;
L536: ( 0* C89 ) in ( ( BOOLEAN ) * ) by L65;
L537: ( 0* C89 ) is (FinSequence of ( BOOLEAN )) by L536 , FINSEQ_1:def 11;
reconsider D11 = ( 0* C89 ) as (Tuple of C89 , ( BOOLEAN )) by L537;
let C90 being Nat;
assume L538: C90 < ( 2 to_power ( C89 + 1 ) );
let C91 being (Tuple of ( C89 + 1 ) , ( BOOLEAN ));
assume that
L539: C91 = ( 0* ( C89 + 1 ) )
and
L540: ( ( C89 + 1 ) -BinarySequence C90 ) = ( 'not' C91 );
L541: ( C91 . ( C89 + 1 ) ) = ( FALSE ) by L539 , FINSEQ_1:4 , FUNCOP_1:7;
L542: C91 = ( D11 ^ <* ( 0 ) *> ) by L539 , FINSEQ_2:60;
L543: ( len C91 ) = ( C89 + 1 ) by CARD_1:def 7;
L544: ( len ( 'not' C91 ) ) = ( C89 + 1 ) by CARD_1:def 7;
L545: ( ( ( C89 + 1 ) -BinarySequence C90 ) . ( C89 + 1 ) ) = ( ( 'not' C91 ) /. ( C89 + 1 ) ) by L544 , L540 , L535 , FINSEQ_4:15
.= ( 'not' ( C91 /. ( C89 + 1 ) ) ) by L533 , BINARITH:def 1
.= ( 'not' ( FALSE ) ) by L543 , L535 , L541 , FINSEQ_4:15
.= ( TRUE );
L546: ( ( C89 + 1 ) -BinarySequence C90 ) = ( ( C89 -BinarySequence ( C90 -' ( 2 to_power C89 ) ) ) ^ <* ( TRUE ) *> ) by L545 , L538 , L493 , L418;
L547: ( ( C89 -BinarySequence ( C90 -' ( 2 to_power C89 ) ) ) ^ <* ( TRUE ) *> ) = ( ( 'not' D11 ) ^ <* ( 'not' ( FALSE ) ) *> ) by L546 , L540 , L542 , BINARI_2:9;
L548: ( C89 -BinarySequence ( C90 -' ( 2 to_power C89 ) ) ) = ( 'not' D11 ) by L547 , FINSEQ_2:17;
L549: C90 < ( ( 2 to_power C89 ) * ( 2 to_power 1 ) ) by L538 , POWER:27;
L550: C90 < ( 2 * ( 2 to_power C89 ) ) by L549 , POWER:25;
L551: C90 < ( ( 2 to_power C89 ) + ( 2 to_power C89 ) ) by L550;
L552: ( C90 - ( 2 to_power C89 ) ) < ( 2 to_power C89 ) by L551 , XREAL_1:19;
L553: ( C90 -' ( 2 to_power C89 ) ) < ( 2 to_power C89 ) by L552 , L545 , L418 , XREAL_1:233;
L554: ( C90 -' ( 2 to_power C89 ) ) = ( ( 2 to_power C89 ) - 1 ) by L553 , L532 , L548;
L555: ( C90 - ( 2 to_power C89 ) ) = ( ( 2 to_power C89 ) - 1 ) by L554 , L545 , L418 , XREAL_1:233;
thus L556: C90 = ( ( ( 2 to_power C89 ) * 2 ) - 1 ) by L555
.= ( ( ( 2 to_power C89 ) * ( 2 to_power 1 ) ) - 1 ) by POWER:25
.= ( ( 2 to_power ( C89 + 1 ) ) - 1 ) by POWER:27;
end;
L557: S7[ 1 ]
proof
let C92 being Nat;
L558: 1 <= ( len ( 1 -BinarySequence C92 ) ) by CARD_1:def 7;
assume L559: C92 < ( 2 to_power 1 );
L560: C92 < 2 by L559 , POWER:25;
let C93 being (Tuple of 1 , ( BOOLEAN ));
assume L561: C93 = ( 0* 1 );
L562: C93 = <* ( FALSE ) *> by L561 , FINSEQ_2:59;
assume L563: ( 1 -BinarySequence C92 ) = ( 'not' C93 );
L564: 1 in ( Seg 1 ) by FINSEQ_1:3;
L565: 1 = ( <* 1 *> . 1 ) by FINSEQ_1:40
.= ( ( 1 -BinarySequence C92 ) /. 1 ) by L562 , L563 , L558 , L156 , FINSEQ_4:15
.= ( IFEQ (( ( C92 div ( 2 to_power ( 1 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L564 , L391;
L566: C92 = 1
proof
assume L567: C92 <> 1;
L568: C92 = ( 0 ) by L567 , L560 , NAT_1:23;
L569: ( C92 div ( 2 to_power ( 1 -' 1 ) ) ) = ( 0 ) by L568 , NAT_D:27 , POWER:34;
L570: ( ( C92 div ( 2 to_power ( 1 -' 1 ) ) ) mod 2 ) = ( 0 ) by L569 , NAT_D:26;
thus L571: contradiction by L570 , L565 , FUNCOP_1:def 8;
end;
thus L572: C92 = ( ( 1 + 1 ) - 1 ) by L566
.= ( ( 2 to_power 1 ) - 1 ) by POWER:25;
end;
L573: (for B79 being non  empty Nat holds S7[ B79 ]) from NAT_1:sch 10(L557 , L531);
thus L574: thesis by L573 , L527 , L528 , L530;
end;

assume L575: C87 = ( ( 2 to_power C86 ) - 1 );
L576:
now
let C94 being Nat;
L577: ( len C88 ) = C86 by CARD_1:def 7;
L578: ( 2 to_power ( C94 -' 1 ) ) > ( 0 ) by POWER:34;
L579: ( 2 to_power ( C94 -' 1 ) ) >= ( ( 0 ) + 1 ) by L578 , NAT_1:13;
L580: ( len ( 'not' C88 ) ) = C86 by CARD_1:def 7;
L581: ( 2 to_power ( C86 -' ( C94 -' 1 ) ) ) > ( 0 ) by POWER:34;
L582: ( 2 to_power ( C86 -' ( C94 -' 1 ) ) ) >= ( ( 0 ) + 1 ) by L581 , NAT_1:13;
reconsider D12 = C94 as Nat;
assume L583: C94 in ( Seg C86 );
L584: 1 <= C94 by L583 , FINSEQ_1:1;
L585: C94 <= C86 by L583 , FINSEQ_1:1;
L586: C94 < ( C86 + 1 ) by L585 , NAT_1:13;
L587: ( C94 - 1 ) < ( ( C86 + 1 ) - 1 ) by L586 , XREAL_1:9;
L588: 1 <= C94 by L583 , FINSEQ_1:1;
L589: ( ( 0 ) + ( C94 -' 1 ) ) < C86 by L588 , L587 , XREAL_1:233;
L590: ( C86 - ( C94 -' 1 ) ) > ( 0 ) by L589 , XREAL_1:20;
L591: ( C86 -' ( C94 -' 1 ) ) > ( 0 ) by L590 , L589 , XREAL_1:233;
L592: ( ( 2 to_power ( C86 -' ( C94 -' 1 ) ) ) mod 2 ) = ( 0 ) by L591 , NAT_2:17;
L593: ( 2 to_power C86 ) > ( 0 ) by POWER:34;
L594: ( 2 to_power C86 ) >= ( ( 0 ) + 1 ) by L593 , NAT_1:13;
L595: ( C87 div ( 2 to_power ( C94 -' 1 ) ) ) = ( ( ( 2 to_power C86 ) -' 1 ) div ( 2 to_power ( C94 -' 1 ) ) ) by L594 , L575 , XREAL_1:233
.= ( ( ( 2 to_power C86 ) div ( 2 to_power ( C94 -' 1 ) ) ) - 1 ) by L579 , L589 , L594 , NAT_2:11 , NAT_2:15
.= ( ( 2 to_power ( C86 -' ( C94 -' 1 ) ) ) - 1 ) by L589 , NAT_2:16
.= ( ( 2 to_power ( C86 -' ( C94 -' 1 ) ) ) -' 1 ) by L582 , XREAL_1:233;
L596: ( ( C87 div ( 2 to_power ( C94 -' 1 ) ) ) mod 2 ) = 1 by L595 , L592 , L581 , NAT_2:18;
L597: ( C88 . C94 ) = ( FALSE ) by L528 , L583 , FUNCOP_1:7;
L598: C94 <= C86 by L583 , FINSEQ_1:1;
L599: C94 in ( Seg ( len ( C86 -BinarySequence C87 ) ) ) by L583 , CARD_1:def 7;
L600: C94 in ( dom ( C86 -BinarySequence C87 ) ) by L599 , FINSEQ_1:def 3;
thus L601: ( ( C86 -BinarySequence C87 ) . C94 ) = ( ( C86 -BinarySequence C87 ) /. C94 ) by L600 , PARTFUN1:def 6
.= ( IFEQ (( ( C87 div ( 2 to_power ( C94 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L583 , L391
.= ( 'not' ( FALSE ) ) by L596 , FUNCOP_1:def 8
.= ( 'not' ( C88 /. D12 ) ) by L577 , L584 , L598 , L597 , FINSEQ_4:15
.= ( ( 'not' C88 ) /. D12 ) by L583 , BINARITH:def 1
.= ( ( 'not' C88 ) . C94 ) by L580 , L584 , L598 , FINSEQ_4:15;
end;
thus L602: thesis by L576 , FINSEQ_2:119;
end;
theorem
L603: (for B80 being Nat holds ( ( B80 + 1 ) -BinarySequence ( 2 to_power B80 ) ) = ( ( 0* B80 ) ^ <* 1 *> ))
proof
deffunc H2(Nat) = ( ( $1 + 1 ) -BinarySequence ( 2 to_power $1 ) );
let C95 being Nat;
set D13 = H2(C95);
per cases  by NAT_1:3;
suppose L604: C95 = ( 0 );

L605: ( 0* C95 ) = ( 0 ) by L604;
reconsider D14 = ( C95 + 1 ) as non  empty Nat;
L606: ( 0* D14 ) = <* ( FALSE ) *> by L604 , FINSEQ_2:59;
reconsider D15 = ( 0* D14 ) as (Tuple of D14 , ( BOOLEAN )) by L606;
L607: ( 2 to_power D14 ) = 2 by L604 , POWER:25;
L608: 1 = ( ( 2 to_power D14 ) - 1 ) by L607;
L609: ( D14 -BinarySequence 1 ) = ( 'not' D15 ) by L608 , L526;
thus L610: D13 = <* ( TRUE ) *> by L609 , L604 , L606 , L156 , POWER:24
.= ( ( 0* C95 ) ^ <* 1 *> ) by L605 , FINSEQ_1:34;
end;
suppose L611: C95 > ( 0 );

reconsider D16 = C95 as non  empty Nat by L611;
L612: D13 = ( ( 0* D16 ) ^ <* 1 *> ) by L442;
thus L613: thesis by L612;
end;
end;
theorem
L615: (for B81 being non  empty Nat holds (for B82 being Nat holds ((( 2 to_power B81 ) <= B82 & B82 < ( 2 to_power ( B81 + 1 ) )) implies ( ( ( B81 + 1 ) -BinarySequence B82 ) . ( B81 + 1 ) ) = ( TRUE )))) by L481;
theorem
L616: (for B83 being non  empty Nat holds (for B84 being Nat holds ((( 2 to_power B83 ) <= B84 & B84 < ( 2 to_power ( B83 + 1 ) )) implies ( ( B83 + 1 ) -BinarySequence B84 ) = ( ( B83 -BinarySequence ( B84 -' ( 2 to_power B83 ) ) ) ^ <* ( TRUE ) *> )))) by L493;
theorem
L617: (for B85 being non  empty Nat holds (for B86 being Nat holds (B86 < ( 2 to_power B85 ) implies (for B87 being (Tuple of B85 , ( BOOLEAN )) holds (B87 = ( 0* B85 ) implies (( B85 -BinarySequence B86 ) = ( 'not' B87 ) iff B86 = ( ( 2 to_power B85 ) - 1 ))))))) by L526;
theorem
L618: (for B88 being non  empty Nat holds (for B89 being Nat holds (( B89 + 1 ) < ( 2 to_power B88 ) implies ( add_ovfl (( B88 -BinarySequence B89 ) , ( Bin1 B88 )) ) = ( FALSE ))))
proof
let C96 being non  empty Nat;
let C97 being Nat;
assume L619: ( C97 + 1 ) < ( 2 to_power C96 );
L620: C97 < ( 2 to_power C96 ) by L619 , NAT_1:13;
L621: ( 0* C96 ) in ( ( BOOLEAN ) * ) by L65;
L622: ( 0* C96 ) is (FinSequence of ( BOOLEAN )) by L621 , FINSEQ_1:def 11;
reconsider D17 = ( 0* C96 ) as (Tuple of C96 , ( BOOLEAN )) by L622;
L623: C97 < ( ( 2 to_power C96 ) - 1 ) by L619 , XREAL_1:20;
L624: ( C96 -BinarySequence C97 ) <> ( 'not' D17 ) by L623 , L620 , L526;
L625: ( add_ovfl (( C96 -BinarySequence C97 ) , ( Bin1 C96 )) ) <> ( TRUE ) by L624 , L332;
thus L626: thesis by L625 , XBOOLEAN:def 3;
end;
theorem
L627: (for B90 being non  empty Nat holds (for B91 being Nat holds (( B91 + 1 ) < ( 2 to_power B90 ) implies ( B90 -BinarySequence ( B91 + 1 ) ) = ( ( B90 -BinarySequence B91 ) + ( Bin1 B90 ) ))))
proof
defpred S8[ non  empty Nat ] means (for B92 being Nat holds (( B92 + 1 ) < ( 2 to_power $1 ) implies ( $1 -BinarySequence ( B92 + 1 ) ) = ( ( $1 -BinarySequence B92 ) + ( Bin1 $1 ) )));
L628: (for B93 being non  empty Nat holds (S8[ B93 ] implies S8[ ( B93 + 1 ) ]))
proof
let C98 being non  empty Nat;
assume L629: S8[ C98 ];
let C99 being Nat;
assume L630: ( C99 + 1 ) < ( 2 to_power ( C98 + 1 ) );
L631: C99 < ( 2 to_power ( C98 + 1 ) ) by L630 , NAT_1:13;
L632:
now
per cases  by XXREAL_0:1;
suppose L633: ( C99 + 1 ) < ( 2 to_power C98 );

L634: C99 < ( 2 to_power C98 ) by L633 , NAT_1:13;
L635: ( add_ovfl (( C98 -BinarySequence C99 ) , ( Bin1 C98 )) ) = ( FALSE ) by L633 , L618;
thus L636: ( ( C98 + 1 ) -BinarySequence ( C99 + 1 ) ) = ( ( C98 -BinarySequence ( C99 + 1 ) ) ^ <* ( FALSE ) *> ) by L633 , L426
.= ( ( ( C98 -BinarySequence C99 ) + ( Bin1 C98 ) ) ^ <* ( ( ( FALSE ) 'xor' ( FALSE ) ) 'xor' ( add_ovfl (( C98 -BinarySequence C99 ) , ( Bin1 C98 )) ) ) *> ) by L629 , L633 , L635
.= ( ( ( C98 -BinarySequence C99 ) ^ <* ( FALSE ) *> ) + ( ( Bin1 C98 ) ^ <* ( FALSE ) *> ) ) by BINARITH:19
.= ( ( ( C98 -BinarySequence C99 ) ^ <* ( FALSE ) *> ) + ( Bin1 ( C98 + 1 ) ) ) by BINARI_2:7
.= ( ( ( C98 + 1 ) -BinarySequence C99 ) + ( Bin1 ( C98 + 1 ) ) ) by L634 , L426;
end;
suppose L637: ( C99 + 1 ) > ( 2 to_power C98 );

L638: C99 >= ( 2 to_power C98 ) by L637 , NAT_1:13;
L639: ( C99 + 1 ) < ( ( 2 to_power C98 ) * ( 2 to_power 1 ) ) by L630 , POWER:27;
L640: ( C99 + 1 ) < ( ( 2 to_power C98 ) * 2 ) by L639 , POWER:25;
L641: ( C99 + 1 ) < ( ( 2 to_power C98 ) + ( 2 to_power C98 ) ) by L640;
L642: ( ( C99 + 1 ) - ( 2 to_power C98 ) ) < ( 2 to_power C98 ) by L641 , XREAL_1:19;
L643: ( ( C99 - ( 2 to_power C98 ) ) + 1 ) < ( 2 to_power C98 ) by L642;
L644: ( ( C99 -' ( 2 to_power C98 ) ) + 1 ) < ( 2 to_power C98 ) by L643 , L638 , XREAL_1:233;
L645: ( add_ovfl (( C98 -BinarySequence ( C99 -' ( 2 to_power C98 ) ) ) , ( Bin1 C98 )) ) = ( FALSE ) by L644 , L618;
thus L646: ( ( C98 + 1 ) -BinarySequence ( C99 + 1 ) ) = ( ( C98 -BinarySequence ( ( C99 + 1 ) -' ( 2 to_power C98 ) ) ) ^ <* ( TRUE ) *> ) by L630 , L637 , L493
.= ( ( C98 -BinarySequence ( ( C99 -' ( 2 to_power C98 ) ) + 1 ) ) ^ <* ( TRUE ) *> ) by L638 , NAT_D:38
.= ( ( ( C98 -BinarySequence ( C99 -' ( 2 to_power C98 ) ) ) + ( Bin1 C98 ) ) ^ <* ( ( ( TRUE ) 'xor' ( FALSE ) ) 'xor' ( add_ovfl (( C98 -BinarySequence ( C99 -' ( 2 to_power C98 ) ) ) , ( Bin1 C98 )) ) ) *> ) by L629 , L644 , L645
.= ( ( ( C98 -BinarySequence ( C99 -' ( 2 to_power C98 ) ) ) ^ <* ( TRUE ) *> ) + ( ( Bin1 C98 ) ^ <* ( FALSE ) *> ) ) by BINARITH:19
.= ( ( ( C98 -BinarySequence ( C99 -' ( 2 to_power C98 ) ) ) ^ <* ( TRUE ) *> ) + ( Bin1 ( C98 + 1 ) ) ) by BINARI_2:7
.= ( ( ( C98 + 1 ) -BinarySequence C99 ) + ( Bin1 ( C98 + 1 ) ) ) by L631 , L638 , L493;
end;
suppose L647: ( C99 + 1 ) = ( 2 to_power C98 );

L648: ( 0* C98 ) in ( ( BOOLEAN ) * ) by L65;
L649: ( 0* C98 ) is (FinSequence of ( BOOLEAN )) by L648 , FINSEQ_1:def 11;
reconsider D18 = ( 0* C98 ) as (Tuple of C98 , ( BOOLEAN )) by L649;
L650: C99 < ( 2 to_power C98 ) by L647 , NAT_1:13;
L651: C99 = ( ( 2 to_power C98 ) - 1 ) by L647;
L652: ( C98 -BinarySequence C99 ) = ( 'not' D18 ) by L651 , L650 , L526;
thus L653: ( ( C98 + 1 ) -BinarySequence ( C99 + 1 ) ) = ( ( 0* C98 ) ^ <* 1 *> ) by L647 , L603
.= ( ( ( 'not' D18 ) + ( Bin1 C98 ) ) ^ <* ( TRUE ) *> ) by L386
.= ( ( ( C98 -BinarySequence C99 ) + ( Bin1 C98 ) ) ^ <* ( ( ( FALSE ) 'xor' ( FALSE ) ) 'xor' ( add_ovfl (( C98 -BinarySequence C99 ) , ( Bin1 C98 )) ) ) *> ) by L652 , L332
.= ( ( ( C98 -BinarySequence C99 ) ^ <* ( FALSE ) *> ) + ( ( Bin1 C98 ) ^ <* ( FALSE ) *> ) ) by BINARITH:19
.= ( ( ( C98 -BinarySequence C99 ) ^ <* ( FALSE ) *> ) + ( Bin1 ( C98 + 1 ) ) ) by BINARI_2:7
.= ( ( ( C98 + 1 ) -BinarySequence C99 ) + ( Bin1 ( C98 + 1 ) ) ) by L650 , L426;
end;
end;
thus L655: thesis by L632;
end;
L656: S8[ 1 ]
proof
L657: ( 0* 1 ) in ( ( BOOLEAN ) * ) by L65;
L658: ( 0* 1 ) is (FinSequence of ( BOOLEAN )) by L657 , FINSEQ_1:def 11;
reconsider D19 = ( 0* 1 ) as (Tuple of 1 , ( BOOLEAN )) by L658;
let C100 being Nat;
L659: ( 0* 1 ) = <* ( FALSE ) *> by FINSEQ_2:59;
assume L660: ( C100 + 1 ) < ( 2 to_power 1 );
L661: ( C100 + 1 ) < ( 1 + 1 ) by L660 , POWER:25;
L662: C100 < 1 by L661 , XREAL_1:6;
L663: C100 = ( 0 ) by L662 , NAT_1:14;
L664: ( C100 + 1 ) = ( 2 - 1 ) by L663
.= ( ( 2 to_power 1 ) - 1 ) by POWER:25;
thus L665: ( 1 -BinarySequence ( C100 + 1 ) ) = ( 'not' D19 ) by L664 , L660 , L526
.= ( ( 1 -BinarySequence C100 ) + ( Bin1 1 ) ) by L663 , L659 , L113 , L156 , L180 , L409;
end;
thus L666: (for B94 being non  empty Nat holds S8[ B94 ]) from NAT_1:sch 10(L656 , L628);
end;
theorem
L667: (for B95 , B96 being Nat holds ( ( B95 + 1 ) -BinarySequence B96 ) = ( <* ( B96 mod 2 ) *> ^ ( B95 -BinarySequence ( B96 div 2 ) ) ))
proof
let C101 , C102 being Nat;
L668: ( len ( ( C101 + 1 ) -BinarySequence C102 ) ) = ( C101 + 1 ) by CARD_1:def 7;
L669: ( dom ( ( C101 + 1 ) -BinarySequence C102 ) ) = ( Seg ( C101 + 1 ) ) by L668 , FINSEQ_1:def 3;
L670: ( len ( <* ( C102 mod 2 ) *> ^ ( C101 -BinarySequence ( C102 div 2 ) ) ) ) = ( 1 + ( len ( C101 -BinarySequence ( C102 div 2 ) ) ) ) by FINSEQ_5:8
.= ( C101 + 1 ) by CARD_1:def 7;
L671:
now
let C103 being Nat;
reconsider D20 = C103 as Nat;
assume L672: C103 in ( dom ( ( C101 + 1 ) -BinarySequence C102 ) );
L673: 1 <= C103 by L672 , L669 , FINSEQ_1:1;
L674: C103 <= ( C101 + 1 ) by L669 , L672 , FINSEQ_1:1;
L675: ( len <* ( C102 mod 2 ) *> ) = 1 by FINSEQ_1:39;
L676:
now
per cases  by L673 , XXREAL_0:1;
suppose L677: C103 > 1;

L678: ( 2 to_power ( ( ( C103 -' 1 ) -' 1 ) + 1 ) ) = ( ( 2 to_power ( ( C103 -' 1 ) -' 1 ) ) * ( 2 to_power 1 ) ) by POWER:27
.= ( 2 * ( 2 to_power ( ( C103 -' 1 ) -' 1 ) ) ) by POWER:25;
L679: ( C103 - 1 ) > ( 1 - 1 ) by L677 , XREAL_1:9;
L680: ( C103 -' 1 ) > ( 0 ) by L679 , L673 , XREAL_1:233;
L681: ( C103 -' 1 ) >= ( ( 0 ) + 1 ) by L680 , NAT_1:13;
L682: ( C102 div ( 2 to_power ( C103 -' 1 ) ) ) = ( C102 div ( 2 to_power ( ( ( C103 -' 1 ) -' 1 ) + 1 ) ) ) by L681 , XREAL_1:235
.= ( ( C102 div 2 ) div ( 2 to_power ( ( C103 -' 1 ) -' 1 ) ) ) by L678 , NAT_2:27;
L683: ( C103 - 1 ) <= C101 by L674 , XREAL_1:20;
L684: ( C103 -' 1 ) <= C101 by L683 , L673 , XREAL_1:233;
L685: ( C103 -' 1 ) <= ( len ( C101 -BinarySequence ( C102 div 2 ) ) ) by L684 , CARD_1:def 7;
L686: ( C103 -' 1 ) in ( Seg C101 ) by L681 , L684 , FINSEQ_1:1;
L687: C103 <= ( len ( ( C101 + 1 ) -BinarySequence C102 ) ) by L674 , CARD_1:def 7;
thus L688: ( ( ( C101 + 1 ) -BinarySequence C102 ) . C103 ) = ( ( ( C101 + 1 ) -BinarySequence C102 ) /. D20 ) by L687 , L673 , FINSEQ_4:15
.= ( IFEQ (( ( C102 div ( 2 to_power ( C103 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L669 , L672 , L391
.= ( ( C101 -BinarySequence ( C102 div 2 ) ) /. ( C103 -' 1 ) ) by L686 , L682 , L391
.= ( ( C101 -BinarySequence ( C102 div 2 ) ) . ( C103 -' 1 ) ) by L681 , L685 , FINSEQ_4:15
.= ( ( C101 -BinarySequence ( C102 div 2 ) ) . ( C103 - 1 ) ) by L673 , XREAL_1:233
.= ( ( <* ( C102 mod 2 ) *> ^ ( C101 -BinarySequence ( C102 div 2 ) ) ) . C103 ) by L670 , L674 , L675 , L677 , FINSEQ_1:24;
end;
suppose L689: C103 = 1;

L690:
now
per cases ;
suppose L691: ( C102 mod 2 ) = ( 0 );

thus L692: ( IFEQ (( C102 mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) = ( C102 mod 2 ) by L691 , FUNCOP_1:def 8;
end;
suppose L693: ( C102 mod 2 ) <> ( 0 );

thus L694: ( IFEQ (( C102 mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) = 1 by L693 , FUNCOP_1:def 8
.= ( C102 mod 2 ) by L693 , NAT_D:12;
end;
end;
L696: ( 2 to_power ( 0 ) ) = 1 by POWER:24;
thus L697: ( ( ( C101 + 1 ) -BinarySequence C102 ) . C103 ) = ( ( ( C101 + 1 ) -BinarySequence C102 ) /. D20 ) by L668 , L673 , L674 , FINSEQ_4:15
.= ( IFEQ (( ( C102 div ( 2 to_power ( 1 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L669 , L672 , L689 , L391
.= ( IFEQ (( ( C102 div 1 ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L696 , XREAL_1:232
.= ( IFEQ (( C102 mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by NAT_2:4
.= ( ( <* ( C102 mod 2 ) *> ^ ( C101 -BinarySequence ( C102 div 2 ) ) ) . C103 ) by L689 , L690 , FINSEQ_1:41;
end;
end;
thus L699: ( ( ( C101 + 1 ) -BinarySequence C102 ) . C103 ) = ( ( <* ( C102 mod 2 ) *> ^ ( C101 -BinarySequence ( C102 div 2 ) ) ) . C103 ) by L676;
end;
thus L700: thesis by L671 , L668 , L670 , FINSEQ_2:9;
end;
theorem
L701: (for B97 being non  empty Nat holds (for B98 being Nat holds (B98 < ( 2 to_power B97 ) implies ( Absval ( B97 -BinarySequence B98 ) ) = B98)))
proof
let C104 being non  empty Nat;
defpred S9[ Nat ] means ($1 < ( 2 to_power C104 ) implies ( Absval ( C104 -BinarySequence $1 ) ) = $1);
L702: (for B99 being Nat holds (S9[ B99 ] implies S9[ ( B99 + 1 ) ]))
proof
L703: ( 0* C104 ) in ( ( BOOLEAN ) * ) by L65;
L704: ( 0* C104 ) is (FinSequence of ( BOOLEAN )) by L703 , FINSEQ_1:def 11;
reconsider D21 = ( 0* C104 ) as (Tuple of C104 , ( BOOLEAN )) by L704;
let C105 being Nat;
assume L705: (C105 < ( 2 to_power C104 ) implies ( Absval ( C104 -BinarySequence C105 ) ) = C105);
assume L706: ( C105 + 1 ) < ( 2 to_power C104 );
L707: ( ( C105 + 1 ) - 1 ) < ( ( 2 to_power C104 ) - 1 ) by L706 , XREAL_1:9;
L708: C105 < ( 2 to_power C104 ) by L706 , NAT_1:13;
L709: ( C104 -BinarySequence C105 ) <> ( 'not' D21 ) by L708 , L707 , L526;
L710: ( add_ovfl (( C104 -BinarySequence C105 ) , ( Bin1 C104 )) ) <> ( TRUE ) by L709 , L332;
L711: ( add_ovfl (( C104 -BinarySequence C105 ) , ( Bin1 C104 )) ) = ( FALSE ) by L710 , XBOOLEAN:def 3;
L712: ( C104 -BinarySequence C105 ) , ( Bin1 C104 ) are_summable  by L711 , BINARITH:def 7;
thus L713: ( Absval ( C104 -BinarySequence ( C105 + 1 ) ) ) = ( Absval ( ( C104 -BinarySequence C105 ) + ( Bin1 C104 ) ) ) by L706 , L627
.= ( ( Absval ( C104 -BinarySequence C105 ) ) + ( Absval ( Bin1 C104 ) ) ) by L712 , BINARITH:22
.= ( C105 + 1 ) by L705 , L706 , L118 , NAT_1:13;
end;
L714: S9[ ( 0 ) ]
proof
assume L715: ( 0 ) < ( 2 to_power C104 );
L716: ( C104 -BinarySequence ( 0 ) ) = ( 0* C104 ) by L409;
thus L717: thesis by L716 , L80;
end;
thus L718: (for B100 being Nat holds S9[ B100 ]) from NAT_1:sch 2(L714 , L702);
end;
theorem
L719: (for B101 being non  empty Nat holds (for B102 being (Tuple of B101 , ( BOOLEAN )) holds ( B101 -BinarySequence ( Absval B102 ) ) = B102))
proof
let C106 being non  empty Nat;
let C107 being (Tuple of C106 , ( BOOLEAN ));
L720: ( Absval C107 ) < ( 2 to_power C106 ) by L1;
L721: ( Absval ( C106 -BinarySequence ( Absval C107 ) ) ) = ( Absval C107 ) by L720 , L701;
thus L722: thesis by L721 , L27;
end;
