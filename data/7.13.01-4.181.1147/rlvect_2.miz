:: Linear Combinations in Real Linear Space
::  by Wojciech A. Trybulec
::
:: Received April 8, 1990
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FINSEQ_1, SUBSET_1, RLVECT_1, REAL_1, STRUCT_0, FUNCT_1,
      XBOOLE_0, ALGSTR_0, RELAT_1, PARTFUN1, ARYTM_3, CARD_3, ORDINAL4,
      XXREAL_0, TARSKI, CARD_1, SUPINF_2, ARYTM_1, NAT_1, FUNCT_2, FINSET_1,
      FUNCOP_1, VALUED_1, RLSUB_1, QC_LANG1, BINOP_1, ZFMISC_1, XREAL_0,
      ORDINAL1, RLVECT_2, LATTICES, VECTSP_1, PRE_POLY;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, CARD_1, ORDINAL1, NUMBERS,
      XCMPLX_0, XREAL_0, FINSET_1, FINSEQ_1, RELAT_1, FUNCT_1, RELSET_1,
      PRE_POLY, PARTFUN1, FUNCT_2, FUNCOP_1, DOMAIN_1, VALUED_1, FINSEQ_4,
      STRUCT_0, ALGSTR_0, GROUP_1, RLVECT_1, VECTSP_1, REAL_1, RLSUB_1, NAT_1,
      BINOP_1, XXREAL_0;
 constructors PARTFUN1, BINOP_1, DOMAIN_1, FUNCOP_1, XXREAL_0, REAL_1, NAT_1,
      FINSEQ_4, RLSUB_1, VALUED_1, RELSET_1, VECTSP_1, PRE_POLY, RLVECT_1;
 registrations SUBSET_1, FUNCT_1, RELSET_1, FUNCT_2, FINSET_1, NUMBERS,
      XREAL_0, STRUCT_0, RLVECT_1, RLSUB_1, VALUED_1, VALUED_0, MEMBERED,
      FINSEQ_1, CARD_1, VECTSP_1, VECTSP_2;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCT_1, RLSUB_1, TARSKI, XBOOLE_0, BINOP_1, RLVECT_1, RELAT_1,
      FUNCT_2, STRUCT_0, ALGSTR_0;
 theorems BINOP_1, CARD_1, CARD_2, ENUMSET1, FINSEQ_1, FINSEQ_2, FINSEQ_3,
      FINSEQ_4, FUNCT_1, FUNCT_2, NAT_1, RLSUB_1, RLSUB_2, RLVECT_1, TARSKI,
      ZFMISC_1, RELAT_1, RELSET_1, XBOOLE_0, XBOOLE_1, XCMPLX_1, FUNCOP_1,
      XREAL_1, XXREAL_0, ORDINAL1, STRUCT_0, PARTFUN1, VALUED_1, XREAL_0,
      VECTSP_1, PRE_POLY;
 schemes BINOP_1, FINSEQ_1, FUNCT_2, NAT_1, XBOOLE_0;

begin
definition
let C1 being 1-sorted;
let R1 being set;
assume L1: R1 in C1;
func vector (C1 , R1) -> (Element of C1) equals 
:L2: R1;
coherence by L1 , STRUCT_0:def 5;
end;
theorem
L4: (for B1 being non  empty 1-sorted holds (for B2 being (Element of B1) holds ( vector (B1 , B2) ) = B2)) by L2 , RLVECT_1:1;
theorem
L5: (for B3 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B4 , B5 , B6 being (FinSequence of (the carrier of B3)) holds ((( len B4 ) = ( len B5 ) & ( len B4 ) = ( len B6 ) & (for R7 being (Element of ( NAT )) holds (R7 in ( dom B4 ) implies ( B6 . R7 ) = ( ( B4 /. R7 ) + ( B5 /. R7 ) )))) implies ( Sum B6 ) = ( ( Sum B4 ) + ( Sum B5 ) ))))
proof
let C2 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
defpred S1[ (Element of ( NAT )) ] means (for B7 , B8 , B9 being (FinSequence of (the carrier of C2)) holds ((( len B7 ) = $1 & ( len B7 ) = ( len B8 ) & ( len B7 ) = ( len B9 ) & (for R7 being (Element of ( NAT )) holds (R7 in ( dom B7 ) implies ( B9 . R7 ) = ( ( B7 /. R7 ) + ( B8 /. R7 ) )))) implies ( Sum B9 ) = ( ( Sum B7 ) + ( Sum B8 ) )));
L6:
now
let R7 being (Element of ( NAT ));
assume L7: (for B10 , B11 , B12 being (FinSequence of (the carrier of C2)) holds ((( len B10 ) = R7 & ( len B10 ) = ( len B11 ) & ( len B10 ) = ( len B12 ) & (for R7 being (Element of ( NAT )) holds (R7 in ( dom B10 ) implies ( B12 . R7 ) = ( ( B10 /. R7 ) + ( B11 /. R7 ) )))) implies ( Sum B12 ) = ( ( Sum B10 ) + ( Sum B11 ) )));
let C3 , C4 , C5 being (FinSequence of (the carrier of C2));
assume that
L8: ( len C3 ) = ( R7 + 1 )
and
L9: ( len C3 ) = ( len C4 )
and
L10: ( len C3 ) = ( len C5 )
and
L11: (for R7 being (Element of ( NAT )) holds (R7 in ( dom C3 ) implies ( C5 . R7 ) = ( ( C3 /. R7 ) + ( C4 /. R7 ) )));
reconsider D1 = ( C3 | ( Seg R7 ) ) , D2 = ( C4 | ( Seg R7 ) ) , D3 = ( C5 | ( Seg R7 ) ) as (FinSequence of (the carrier of C2)) by FINSEQ_1:18;
L12: ( len D3 ) = R7 by L8 , L10 , FINSEQ_3:53;
L13: ( R7 + 1 ) in ( Seg ( R7 + 1 ) ) by FINSEQ_1:4;
L14: ( R7 + 1 ) in ( dom C4 ) by L13 , L8 , L9 , FINSEQ_1:def 3;
L15: ( C4 . ( R7 + 1 ) ) in ( rng C4 ) by L14 , FUNCT_1:def 3;
L16: ( R7 + 1 ) in ( dom C5 ) by L8 , L10 , L13 , FINSEQ_1:def 3;
L17: ( C5 . ( R7 + 1 ) ) in ( rng C5 ) by L16 , FUNCT_1:def 3;
L18: ( R7 + 1 ) in ( dom C3 ) by L8 , L13 , FINSEQ_1:def 3;
L19: ( C3 . ( R7 + 1 ) ) in ( rng C3 ) by L18 , FUNCT_1:def 3;
reconsider D4 = ( C3 . ( R7 + 1 ) ) , D5 = ( C4 . ( R7 + 1 ) ) , D6 = ( C5 . ( R7 + 1 ) ) as (Element of C2) by L19 , L15 , L17;
L20: D6 = ( ( C3 /. ( R7 + 1 ) ) + ( C4 /. ( R7 + 1 ) ) ) by L11 , L18
.= ( D4 + ( C4 /. ( R7 + 1 ) ) ) by L18 , PARTFUN1:def 6
.= ( D4 + D5 ) by L14 , PARTFUN1:def 6;
L21: C4 = ( D2 ^ <* D5 *> ) by L8 , L9 , FINSEQ_3:55;
L22: ( Sum C4 ) = ( ( Sum D2 ) + ( Sum <* D5 *> ) ) by L21 , RLVECT_1:41;
L23: ( Sum <* D4 *> ) = D4 by RLVECT_1:44;
L24: ( len D1 ) = R7 by L8 , FINSEQ_3:53;
L25: ( len D2 ) = R7 by L8 , L9 , FINSEQ_3:53;
L26:
now
let R6 being (Element of ( NAT ));
assume L27: R6 in ( dom D1 );
L28: ( C3 . R6 ) = ( D1 . R6 ) by L27 , FUNCT_1:47;
L29: ( len D1 ) <= ( len C3 ) by L8 , L24 , NAT_1:12;
L30: ( dom D1 ) c= ( dom C3 ) by L29 , FINSEQ_3:30;
L31: R6 in ( dom C3 ) by L30 , L27;
L32: R6 in ( dom C4 ) by L31 , L9 , FINSEQ_3:29;
L33: ( C4 /. R6 ) = ( C4 . R6 ) by L32 , PARTFUN1:def 6;
L34: R6 in ( dom D3 ) by L24 , L12 , L27 , FINSEQ_3:29;
L35: ( C5 . R6 ) = ( D3 . R6 ) by L34 , FUNCT_1:47;
L36: ( C3 /. R6 ) = ( C3 . R6 ) by L27 , L30 , PARTFUN1:def 6;
L37: ( D1 /. R6 ) = ( C3 /. R6 ) by L36 , L27 , L28 , PARTFUN1:def 6;
L38: R6 in ( dom D2 ) by L24 , L25 , L27 , FINSEQ_3:29;
L39: ( C4 . R6 ) = ( D2 . R6 ) by L38 , FUNCT_1:47;
L40: ( D2 /. R6 ) = ( C4 /. R6 ) by L39 , L38 , L33 , PARTFUN1:def 6;
thus L41: ( D3 . R6 ) = ( ( D1 /. R6 ) + ( D2 /. R6 ) ) by L40 , L11 , L27 , L35 , L30 , L37;
end;
L42: ( Sum D3 ) = ( ( Sum D1 ) + ( Sum D2 ) ) by L26 , L7 , L24 , L25 , L12;
L43: C3 = ( D1 ^ <* D4 *> ) by L8 , FINSEQ_3:55;
L44: ( Sum C3 ) = ( ( Sum D1 ) + ( Sum <* D4 *> ) ) by L43 , RLVECT_1:41;
L45: ( Sum <* D5 *> ) = D5 by RLVECT_1:44;
L46: C5 = ( D3 ^ <* D6 *> ) by L8 , L10 , FINSEQ_3:55;
thus L47: ( Sum C5 ) = ( ( Sum D3 ) + ( Sum <* D6 *> ) ) by L46 , RLVECT_1:41
.= ( ( ( Sum D1 ) + ( Sum D2 ) ) + ( D4 + D5 ) ) by L42 , L20 , RLVECT_1:44
.= ( ( ( ( Sum D1 ) + ( Sum D2 ) ) + D4 ) + D5 ) by RLVECT_1:def 3
.= ( ( ( Sum C3 ) + ( Sum D2 ) ) + D5 ) by L44 , L23 , RLVECT_1:def 3
.= ( ( Sum C3 ) + ( Sum C4 ) ) by L22 , L45 , RLVECT_1:def 3;
end;
L48: (for R7 being (Element of ( NAT )) holds (S1[ R7 ] implies S1[ ( R7 + 1 ) ])) by L6;
L49: S1[ ( 0 ) ]
proof
let C6 , C7 , C8 being (FinSequence of (the carrier of C2));
assume that
L50: ( len C6 ) = ( 0 )
and
L51: ( len C6 ) = ( len C7 )
and
L52: ( len C6 ) = ( len C8 );
L53: ( Sum C8 ) = ( 0. C2 ) by L50 , L52 , RLVECT_1:75;
L54: (( Sum C6 ) = ( 0. C2 ) & ( Sum C7 ) = ( 0. C2 )) by L50 , L51 , RLVECT_1:75;
thus L55: thesis by L54 , L53 , RLVECT_1:4;
end;
L56: (for R7 being (Element of ( NAT )) holds S1[ R7 ]) from NAT_1:sch 1(L49 , L48);
thus L57: thesis by L56;
end;
theorem
L58: (for R10 being RealLinearSpace holds (for R17 being Real holds (for R19 being (FinSequence of R10) holds (for R20 being (FinSequence of R10) holds ((( len R19 ) = ( len R20 ) & (for R7 being (Element of ( NAT )) holds (R7 in ( dom R19 ) implies ( R20 . R7 ) = ( R17 * ( R19 /. R7 ) )))) implies ( Sum R20 ) = ( R17 * ( Sum R19 ) ))))))
proof
let R10 being RealLinearSpace;
let R17 being Real;
let R19 being (FinSequence of R10);
let R20 being (FinSequence of R10);
assume that
L59: ( len R19 ) = ( len R20 )
and
L60: (for R7 being (Element of ( NAT )) holds (R7 in ( dom R19 ) implies ( R20 . R7 ) = ( R17 * ( R19 /. R7 ) )));
L61: (( dom R19 ) = ( Seg ( len R19 ) ) & ( dom R20 ) = ( Seg ( len R20 ) )) by FINSEQ_1:def 3;
L62:
now
let R7 being (Element of ( NAT ));
let R12 being (VECTOR of R10);
assume that
L63: R7 in ( dom R20 )
and
L64: R12 = ( R19 . R7 );
L65: R12 = ( R19 /. R7 ) by L59 , L61 , L63 , L64 , PARTFUN1:def 6;
thus L66: ( R20 . R7 ) = ( R17 * R12 ) by L65 , L59 , L60 , L61 , L63;
end;
thus L67: thesis by L62 , L59 , RLVECT_1:39;
end;
theorem
L68: (for B13 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B14 , B15 being (FinSequence of (the carrier of B13)) holds ((( len B14 ) = ( len B15 ) & (for R7 being (Element of ( NAT )) holds (R7 in ( dom B14 ) implies ( B15 . R7 ) = ( - ( B14 /. R7 ) )))) implies ( Sum B15 ) = ( - ( Sum B14 ) ))))
proof
let C9 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C10 , C11 being (FinSequence of (the carrier of C9));
assume that
L69: ( len C10 ) = ( len C11 )
and
L70: (for R7 being (Element of ( NAT )) holds (R7 in ( dom C10 ) implies ( C11 . R7 ) = ( - ( C10 /. R7 ) )));
L71:
now
let R7 being (Element of ( NAT ));
let C12 being (Element of C9);
assume that
L72: R7 in ( dom C11 )
and
L73: C12 = ( C10 . R7 );
L74: (( dom C11 ) = ( Seg ( len C11 ) ) & ( dom C10 ) = ( Seg ( len C10 ) )) by FINSEQ_1:def 3;
L75: C12 = ( C10 /. R7 ) by L74 , L69 , L72 , L73 , PARTFUN1:def 6;
thus L76: ( C11 . R7 ) = ( - C12 ) by L75 , L69 , L70 , L72 , L74;
end;
thus L77: thesis by L71 , L69 , RLVECT_1:40;
end;
theorem
L78: (for B16 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B17 , B18 , B19 being (FinSequence of (the carrier of B16)) holds ((( len B17 ) = ( len B18 ) & ( len B17 ) = ( len B19 ) & (for R7 being (Element of ( NAT )) holds (R7 in ( dom B17 ) implies ( B19 . R7 ) = ( ( B17 /. R7 ) - ( B18 /. R7 ) )))) implies ( Sum B19 ) = ( ( Sum B17 ) - ( Sum B18 ) ))))
proof
let C13 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C14 , C15 , C16 being (FinSequence of (the carrier of C13));
assume that
L79: ( len C14 ) = ( len C15 )
and
L80: ( len C14 ) = ( len C16 )
and
L81: (for R7 being (Element of ( NAT )) holds (R7 in ( dom C14 ) implies ( C16 . R7 ) = ( ( C14 /. R7 ) - ( C15 /. R7 ) )));
deffunc H1(set) = ( - ( C15 /. $1 ) );
consider C17 being FinSequence such that L82: ( len C17 ) = ( len C15 ) and L83: (for B20 being Nat holds (B20 in ( dom C17 ) implies ( C17 . B20 ) = H1(B20))) from FINSEQ_1:sch 2;
L84: ( dom C17 ) = ( Seg ( len C15 ) ) by L82 , FINSEQ_1:def 3;
L85: (( dom C15 ) = ( Seg ( len C15 ) ) & (for R7 being (Element of ( NAT )) holds (R7 in ( Seg ( len C15 ) ) implies ( C17 . R7 ) = H1(R7)))) by L84 , L83 , FINSEQ_1:def 3;
L86: ( rng C17 ) c= (the carrier of C13)
proof
let R1 being set;
assume L87: R1 in ( rng C17 );
consider R2 being set such that L88: R2 in ( dom C17 ) and L89: ( C17 . R2 ) = R1 by L87 , FUNCT_1:def 3;
reconsider D7 = R2 as (Element of ( NAT )) by L88;
L90: R1 = ( - ( C15 /. D7 ) ) by L83 , L88 , L89;
reconsider D8 = R1 as (Element of C13) by L90;
L91: D8 in C13 by RLVECT_1:1;
thus L92: thesis by L91;
end;
reconsider D9 = C17 as (FinSequence of (the carrier of C13)) by L86 , FINSEQ_1:def 4;
L93:
now
let R7 being (Element of ( NAT ));
assume L94: R7 in ( dom C14 );
L95: (( dom C14 ) = ( Seg ( len C14 ) ) & ( dom D9 ) = ( Seg ( len D9 ) )) by FINSEQ_1:def 3;
L96: ( D9 . R7 ) = ( D9 /. R7 ) by L95 , L79 , L82 , L94 , PARTFUN1:def 6;
thus L97: ( C16 . R7 ) = ( ( C14 /. R7 ) - ( C15 /. R7 ) ) by L81 , L94
.= ( ( C14 /. R7 ) + ( D9 /. R7 ) ) by L79 , L82 , L83 , L95 , L94 , L96;
end;
L98: ( Sum D9 ) = ( - ( Sum C15 ) ) by L82 , L85 , L68;
thus L99: thesis by L98 , L79 , L80 , L82 , L93 , L5;
end;
theorem
L100: (for B21 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B22 , B23 being (FinSequence of (the carrier of B21)) holds (for B24 being (Permutation of ( dom B22 )) holds ((( len B22 ) = ( len B23 ) & (for R6 being (Element of ( NAT )) holds (R6 in ( dom B23 ) implies ( B23 . R6 ) = ( B22 . ( B24 . R6 ) )))) implies ( Sum B22 ) = ( Sum B23 )))))
proof
let C18 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C19 , C20 being (FinSequence of (the carrier of C18));
let C21 being (Permutation of ( dom C19 ));
defpred S2[ (Element of ( NAT )) ] means (for B25 , B26 being (FinSequence of (the carrier of C18)) holds ((( len B25 ) = $1 & ( len B25 ) = ( len B26 )) implies (for B27 being (Permutation of ( dom B25 )) holds ((for R6 being (Element of ( NAT )) holds (R6 in ( dom B26 ) implies ( B26 . R6 ) = ( B25 . ( B27 . R6 ) ))) implies ( Sum B25 ) = ( Sum B26 )))));
L101:
now
let R7 being (Element of ( NAT ));
assume L102: (for B28 , B29 being (FinSequence of (the carrier of C18)) holds ((( len B28 ) = R7 & ( len B28 ) = ( len B29 )) implies (for B30 being (Permutation of ( dom B28 )) holds ((for R6 being (Element of ( NAT )) holds (R6 in ( dom B29 ) implies ( B29 . R6 ) = ( B28 . ( B30 . R6 ) ))) implies ( Sum B28 ) = ( Sum B29 )))));
let C22 , C23 being (FinSequence of (the carrier of C18));
assume that
L103: ( len C22 ) = ( R7 + 1 )
and
L104: ( len C22 ) = ( len C23 );
reconsider D10 = ( C23 | ( Seg R7 ) ) as (FinSequence of (the carrier of C18)) by FINSEQ_1:18;
let C24 being (Permutation of ( dom C22 ));
L105: ( dom C22 ) = ( Seg ( R7 + 1 ) ) by L103 , FINSEQ_1:def 3;
L106: ( rng C24 ) = ( Seg ( R7 + 1 ) ) by L105 , FUNCT_2:def 3;
L107:
now
let R9 being (Element of ( NAT ));
assume L108: R9 in ( dom C24 );
L109: ( C24 . R9 ) in ( Seg ( R7 + 1 ) ) by L108 , L106 , FUNCT_1:def 3;
thus L110: ( C24 . R9 ) is (Element of ( NAT )) by L109;
end;
L111: ( dom C23 ) = ( Seg ( R7 + 1 ) ) by L103 , L104 , FINSEQ_1:def 3;
reconsider D11 = ( C23 . ( R7 + 1 ) ) as (Element of C18) by L111 , FINSEQ_1:4 , FUNCT_1:102;
L112: ( dom D10 ) = ( Seg ( len D10 ) ) by FINSEQ_1:def 3;
L113: (( Seg ( R7 + 1 ) ) = ( {} ) implies ( Seg ( R7 + 1 ) ) = ( {} ));
L114: ( dom C24 ) = ( Seg ( R7 + 1 ) ) by L113 , L105 , FUNCT_2:def 1;
L115: ( R7 + 1 ) in ( Seg ( R7 + 1 ) ) by FINSEQ_1:4;
L116: ( C24 . ( R7 + 1 ) ) in ( Seg ( R7 + 1 ) ) by L115 , L114 , L106 , FUNCT_1:def 3;
reconsider D12 = ( C24 . ( R7 + 1 ) ) as (Element of ( NAT )) by L116;
L117: D12 <= ( R7 + 1 ) by L116 , FINSEQ_1:1;
consider C25 being Nat such that L118: ( D12 + C25 ) = ( R7 + 1 ) by L117 , NAT_1:10;
defpred S3[ Nat , set ] means $2 = ( C22 . ( D12 + $1 ) );
L119: 1 <= D12 by L116 , FINSEQ_1:1;
consider C26 being Nat such that L120: ( 1 + C26 ) = D12 by L119 , NAT_1:10;
reconsider D13 = C26 , D14 = C25 as (Element of ( NAT )) by ORDINAL1:def 12;
L121: (for B31 being Nat holds (B31 in ( Seg D14 ) implies (ex R1 being set st S3[ B31 , R1 ])));
consider C27 being FinSequence such that L122: ( dom C27 ) = ( Seg D14 ) and L123: (for B32 being Nat holds (B32 in ( Seg D14 ) implies S3[ B32 , ( C27 . B32 ) ])) from FINSEQ_1:sch 1(L121);
L124: ( rng C27 ) c= (the carrier of C18)
proof
let R1 being set;
assume L125: R1 in ( rng C27 );
consider R2 being set such that L126: R2 in ( dom C27 ) and L127: R1 = ( C27 . R2 ) by L125 , FUNCT_1:def 3;
reconsider D15 = R2 as (Element of ( NAT )) by L126;
L128: 1 <= D15 by L122 , L126 , FINSEQ_1:1;
L129: 1 <= ( D12 + D15 ) by L128 , NAT_1:12;
L130: D15 <= D14 by L122 , L126 , FINSEQ_1:1;
L131: ( D12 + D15 ) <= ( len C22 ) by L130 , L103 , L118 , XREAL_1:7;
L132: ( D12 + D15 ) in ( dom C22 ) by L131 , L129 , FINSEQ_3:25;
reconsider D16 = ( C22 . ( D12 + D15 ) ) as (Element of C18) by L132 , FUNCT_1:102;
L133: D16 in (the carrier of C18);
thus L134: thesis by L133 , L122 , L123 , L126 , L127;
end;
reconsider D17 = C27 as (FinSequence of (the carrier of C18)) by L124 , FINSEQ_1:def 4;
reconsider D18 = ( C22 | ( Seg D13 ) ) as (FinSequence of (the carrier of C18)) by FINSEQ_1:18;
defpred S4[ set , set ] means ((( C24 . $1 ) in ( dom D18 ) implies $2 = ( C24 . $1 )) & ((not ( C24 . $1 ) in ( dom D18 )) implies (for R8 being (Element of ( NAT )) holds (R8 = ( C24 . $1 ) implies $2 = ( R8 - 1 )))));
L135: R7 <= ( R7 + 1 ) by NAT_1:12;
L136: ( Seg R7 ) c= ( Seg ( R7 + 1 ) ) by L135 , FINSEQ_1:5;
L137: (for B33 being Nat holds (B33 in ( Seg R7 ) implies (ex R2 being set st S4[ B33 , R2 ])))
proof
let C28 being Nat;
assume L138: C28 in ( Seg R7 );
L139:
now
L140: ( C24 . C28 ) in ( Seg ( R7 + 1 ) ) by L114 , L106 , L136 , L138 , FUNCT_1:def 3;
reconsider D19 = ( C24 . C28 ) as (Element of ( NAT )) by L140;
assume L141: (not ( C24 . C28 ) in ( dom D18 ));
take D20 = ( D19 - 1 );
thus L142: (( C24 . C28 ) in ( dom D18 ) implies D20 = ( C24 . C28 )) by L141;
assume L143: (not ( C24 . C28 ) in ( dom D18 ));
let C29 being (Element of ( NAT ));
assume L144: C29 = ( C24 . C28 );
thus L145: D20 = ( C29 - 1 ) by L144;
end;
thus L146: thesis by L139;
end;
consider C30 being FinSequence such that L147: ( dom C30 ) = ( Seg R7 ) and L148: (for B34 being Nat holds (B34 in ( Seg R7 ) implies S4[ B34 , ( C30 . B34 ) ])) from FINSEQ_1:sch 1(L137);
L149: ( dom D10 ) = ( Seg R7 ) by L103 , L104 , L135 , FINSEQ_1:17;
L150: D13 <= D12 by L120 , NAT_1:11;
L151: D13 <= ( R7 + 1 ) by L150 , L117 , XXREAL_0:2;
L152: ( dom D18 ) = ( Seg D13 ) by L151 , L103 , FINSEQ_1:17;
L153:
now
let R6 being (Element of ( NAT ));
let R8 being (Element of ( NAT ));
assume that
L154: R8 = ( C24 . R6 )
and
L155: (not ( C24 . R6 ) in ( dom D18 ))
and
L156: R6 in ( dom C30 );
L157: (R8 < 1 or D13 < R8) by L152 , L154 , L155 , FINSEQ_1:1;
L158:
now
assume L159: ( D13 + 1 ) = R8;
L160: ( R7 + 1 ) = R6 by L159 , L115 , L114 , L120 , L136 , L147 , L154 , L156 , FUNCT_1:def 4;
L161: ( R7 + 1 ) <= ( R7 + ( 0 ) ) by L160 , L147 , L156 , FINSEQ_1:1;
thus L162: contradiction by L161 , XREAL_1:6;
end;
L163: ( C24 . R6 ) in ( rng C24 ) by L114 , L136 , L147 , L156 , FUNCT_1:def 3;
L164: ( D13 + 1 ) <= R8 by L163 , L105 , L154 , L157 , FINSEQ_1:1 , NAT_1:13;
L165: ( D13 + 1 ) < R8 by L164 , L158 , XXREAL_0:1;
L166: ( ( D13 + 1 ) + 1 ) <= R8 by L165 , NAT_1:13;
thus L167: ( D13 + 2 ) <= R8 by L166;
end;
L168: ( len D18 ) = D13 by L103 , L151 , FINSEQ_1:17;
L169:
now
let C31 being Nat;
assume L170: C31 in ( dom D17 );
L171: ( len ( D18 ^ <* D11 *> ) ) = ( D13 + ( len <* D11 *> ) ) by L168 , FINSEQ_1:22
.= D12 by L120 , FINSEQ_1:39;
thus L172: ( C22 . ( ( len ( D18 ^ <* D11 *> ) ) + C31 ) ) = ( D17 . C31 ) by L171 , L122 , L123 , L170;
end;
L173: ( 1 + R7 ) = ( 1 + ( D13 + D14 ) ) by L120 , L118;
L174: D13 <= R7 by L173 , NAT_1:11;
L175: ( rng C30 ) c= ( dom D10 )
proof
let R2 being set;
assume L176: R2 in ( rng C30 );
consider R1 being set such that L177: R1 in ( dom C30 ) and L178: ( C30 . R1 ) = R2 by L176 , FUNCT_1:def 3;
reconsider D21 = R1 as (Element of ( NAT )) by L177;
L179:
now
per cases ;
suppose L180: ( C24 . D21 ) in ( dom D18 );

L181: ( dom D18 ) c= ( dom D10 ) by L174 , L152 , L149 , FINSEQ_1:5;
L182: ( C24 . D21 ) = ( C30 . D21 ) by L147 , L148 , L177 , L180;
thus L183: thesis by L182 , L178 , L180 , L181;
end;
suppose L184: (not ( C24 . D21 ) in ( dom D18 ));

reconsider D22 = ( C24 . D21 ) as (Element of ( NAT )) by L114 , L136 , L107 , L147 , L177;
L185: ( C24 . D21 ) in ( Seg ( R7 + 1 ) ) by L114 , L106 , L136 , L147 , L177 , FUNCT_1:def 3;
L186: (D22 < 1 or D13 < D22) by L152 , L184 , FINSEQ_1:1;
reconsider D23 = ( D22 - 1 ) as (Element of ( NAT )) by L186 , L185 , FINSEQ_1:1 , NAT_1:20;
L187: D22 <= ( R7 + 1 ) by L185 , FINSEQ_1:1;
L188: D23 <= ( ( R7 + 1 ) - 1 ) by L187 , XREAL_1:9;
L189: ( D13 + 2 ) <= D22 by L153 , L177 , L184;
L190: ( ( D13 + 2 ) - 1 ) <= D23 by L189 , XREAL_1:9;
L191: 1 <= ( D13 + 1 ) by NAT_1:12;
L192: 1 <= D23 by L191 , L190 , XXREAL_0:2;
L193: ( C30 . D21 ) = ( D22 - 1 ) by L147 , L148 , L177 , L184;
thus L194: thesis by L193 , L149 , L178 , L192 , L188 , FINSEQ_1:1;
end;
end;
thus L196: thesis by L179;
end;
set D24 = ( D18 ^ D17 );
L197: ( len D17 ) = D14 by L122 , FINSEQ_1:def 3;
L198: ( len D24 ) = ( D13 + D14 ) by L197 , L168 , FINSEQ_1:22;
L199: ( dom D24 ) = ( Seg R7 ) by L198 , L120 , L118 , FINSEQ_1:def 3;
reconsider D25 = C30 as (Function of ( dom D24 ) , ( dom D24 )) by L199 , L149 , L147 , L175 , FUNCT_2:2;
L200: ( len D10 ) = R7 by L103 , L104 , L135 , FINSEQ_1:17;
L201: ( rng D25 ) = ( dom D24 )
proof
thus L202: ( rng D25 ) c= ( dom D24 );
let R2 being set;
assume L203: R2 in ( dom D24 );
reconsider D26 = R2 as (Element of ( NAT )) by L203;
consider R1 being set such that L204: R1 in ( dom C24 ) and L205: ( C24 . R1 ) = R2 by L106 , L136 , L199 , L203 , FUNCT_1:def 3;
reconsider D27 = R1 as (Element of ( NAT )) by L114 , L204;
L206:
now
per cases ;
suppose L207: D27 in ( dom D25 );

L208:
now
per cases ;
suppose L209: ( C24 . D27 ) in ( dom D18 );

L210: ( D25 . D27 ) = ( C24 . D27 ) by L209 , L147 , L148 , L207;
thus L211: thesis by L210 , L205 , L207 , FUNCT_1:def 3;
end;
suppose L212: (not ( C24 . D27 ) in ( dom D18 ));

L213: D26 <= R7 by L199 , L203 , FINSEQ_1:1;
L214: (1 <= ( D26 + 1 ) & ( D26 + 1 ) <= ( R7 + 1 )) by L213 , NAT_1:12 , XREAL_1:7;
L215: ( D26 + 1 ) in ( rng C24 ) by L214 , L106 , FINSEQ_1:1;
consider C32 being set such that L216: C32 in ( dom C24 ) and L217: ( C24 . C32 ) = ( D26 + 1 ) by L215 , FUNCT_1:def 3;
L218:
now
assume L219: (not C32 in ( dom D25 ));
L220: C32 in ( ( Seg ( R7 + 1 ) ) \ ( Seg R7 ) ) by L219 , L105 , L147 , L216 , XBOOLE_0:def 5;
L221: C32 in { ( R7 + 1 ) } by L220 , FINSEQ_3:15;
L222: ( D26 + 1 ) = ( D13 + 1 ) by L221 , L120 , L217 , TARSKI:def 1;
L223: 1 <= D26 by L199 , L203 , FINSEQ_1:1;
thus L224: contradiction by L223 , L152 , L205 , L212 , L222 , FINSEQ_1:1;
end;
L225: (D26 < 1 or D13 < D26) by L152 , L205 , L212 , FINSEQ_1:1;
L226: (not ( D26 + 1 ) <= D13) by L225 , L199 , L203 , FINSEQ_1:1 , NAT_1:13;
L227: (not ( C24 . C32 ) in ( dom D18 )) by L226 , L152 , L217 , FINSEQ_1:1;
L228: ( D25 . C32 ) = ( ( D26 + 1 ) - 1 ) by L227 , L147 , L148 , L217 , L218
.= R2;
thus L229: thesis by L228 , L218 , FUNCT_1:def 3;
end;
end;
thus L231: thesis by L208;
end;
suppose L232: (not D27 in ( dom D25 ));

L233: D26 <= R7 by L199 , L203 , FINSEQ_1:1;
L234: (1 <= ( D26 + 1 ) & ( D26 + 1 ) <= ( R7 + 1 )) by L233 , NAT_1:12 , XREAL_1:7;
L235: ( D26 + 1 ) in ( rng C24 ) by L234 , L106 , FINSEQ_1:1;
consider C33 being set such that L236: C33 in ( dom C24 ) and L237: ( C24 . C33 ) = ( D26 + 1 ) by L235 , FUNCT_1:def 3;
L238: D27 in ( ( Seg ( R7 + 1 ) ) \ ( Seg R7 ) ) by L105 , L147 , L204 , L232 , XBOOLE_0:def 5;
L239: D27 in { ( R7 + 1 ) } by L238 , FINSEQ_3:15;
L240: D27 = ( R7 + 1 ) by L239 , TARSKI:def 1;
L241:
now
assume L242: (not C33 in ( dom D25 ));
L243: C33 in ( ( Seg ( R7 + 1 ) ) \ ( Seg R7 ) ) by L242 , L105 , L147 , L236 , XBOOLE_0:def 5;
L244: C33 in { ( R7 + 1 ) } by L243 , FINSEQ_3:15;
L245: ( D26 + 1 ) = ( D26 + ( 0 ) ) by L244 , L205 , L240 , L237 , TARSKI:def 1;
thus L246: contradiction by L245;
end;
L247: D13 <= D26 by L120 , L205 , L240 , XREAL_1:29;
L248: (not ( D26 + 1 ) <= D13) by L247 , NAT_1:13;
L249: (not ( C24 . C33 ) in ( dom D18 )) by L248 , L152 , L237 , FINSEQ_1:1;
L250: ( D25 . C33 ) = ( ( D26 + 1 ) - 1 ) by L249 , L147 , L148 , L237 , L241
.= R2;
thus L251: thesis by L250 , L241 , FUNCT_1:def 3;
end;
end;
thus L253: thesis by L206;
end;
assume L254: (for R6 being (Element of ( NAT )) holds (R6 in ( dom C23 ) implies ( C23 . R6 ) = ( C22 . ( C24 . R6 ) )));
L255: ( C23 . ( R7 + 1 ) ) = ( C22 . ( C24 . ( R7 + 1 ) ) ) by L254 , L111 , FINSEQ_1:4;
L256:
now
let C34 being Nat;
assume L257: C34 in ( dom ( D18 ^ <* D11 *> ) );
L258:
now
assume L259: C34 in ( Seg D13 );
L260: C34 in ( dom D18 ) by L259 , L103 , L151 , FINSEQ_1:17;
L261: ( D18 . C34 ) = ( C22 . C34 ) by L260 , FUNCT_1:47;
thus L262: ( C22 . C34 ) = ( ( D18 ^ <* D11 *> ) . C34 ) by L261 , L260 , FINSEQ_1:def 7;
end;
L263:
now
L264: (1 in ( Seg 1 ) & ( len <* D11 *> ) = 1) by FINSEQ_1:1 , FINSEQ_1:39;
L265: 1 in ( dom <* D11 *> ) by L264 , FINSEQ_1:def 3;
L266: ( ( D18 ^ <* D11 *> ) . ( ( len D18 ) + 1 ) ) = ( <* D11 *> . 1 ) by L265 , FINSEQ_1:def 7;
assume L267: C34 in { D12 };
L268: C34 = D12 by L267 , TARSKI:def 1;
thus L269: ( ( D18 ^ <* D11 *> ) . C34 ) = ( C22 . C34 ) by L268 , L255 , L120 , L168 , L266 , FINSEQ_1:40;
end;
L270: ( len ( D18 ^ <* D11 *> ) ) = ( D13 + ( len <* D11 *> ) ) by L168 , FINSEQ_1:22
.= ( D13 + 1 ) by FINSEQ_1:40;
L271: C34 in ( Seg ( D13 + 1 ) ) by L270 , L257 , FINSEQ_1:def 3;
L272: C34 in ( ( Seg D13 ) \/ { D12 } ) by L271 , L120 , FINSEQ_1:9;
thus L273: ( C22 . C34 ) = ( ( D18 ^ <* D11 *> ) . C34 ) by L272 , L258 , L263 , XBOOLE_0:def 3;
end;
L274: D25 is  one-to-one
proof
let R3 being set;
let R4 being set;
assume that
L275: R3 in ( dom D25 )
and
L276: R4 in ( dom D25 )
and
L277: ( D25 . R3 ) = ( D25 . R4 );
reconsider D28 = R3 , D29 = R4 as (Element of ( NAT )) by L147 , L275 , L276;
L278: ( C24 . R4 ) in ( Seg ( R7 + 1 ) ) by L114 , L106 , L136 , L147 , L276 , FUNCT_1:def 3;
L279: ( C24 . R3 ) in ( Seg ( R7 + 1 ) ) by L114 , L106 , L136 , L147 , L275 , FUNCT_1:def 3;
reconsider D30 = ( C24 . R3 ) , D31 = ( C24 . R4 ) as (Element of ( NAT )) by L279 , L278;
L280:
now
per cases ;
suppose L281: (( C24 . R3 ) in ( dom D18 ) & ( C24 . R4 ) in ( dom D18 ));

L282: (( D25 . D28 ) = ( C24 . R3 ) & ( D25 . D29 ) = ( C24 . R4 )) by L281 , L147 , L148 , L275 , L276;
thus L283: thesis by L282 , L114 , L136 , L147 , L275 , L276 , L277 , FUNCT_1:def 4;
end;
suppose L284: (( C24 . R3 ) in ( dom D18 ) & (not ( C24 . R4 ) in ( dom D18 )));

L285: D30 <= D13 by L284 , L152 , FINSEQ_1:1;
L286: (( D25 . D28 ) = D30 & ( D25 . D29 ) = ( D31 - 1 )) by L147 , L148 , L275 , L276 , L284;
L287: ( ( D31 - 1 ) + 1 ) <= ( D13 + 1 ) by L286 , L277 , L285 , XREAL_1:6;
L288: 1 <= D31 by L278 , FINSEQ_1:1;
L289: D31 in ( Seg ( D13 + 1 ) ) by L288 , L287 , FINSEQ_1:1;
L290: (not D31 in ( Seg D13 )) by L103 , L151 , L284 , FINSEQ_1:17;
L291: D31 in ( ( Seg ( D13 + 1 ) ) \ ( Seg D13 ) ) by L290 , L289 , XBOOLE_0:def 5;
L292: D31 in { ( D13 + 1 ) } by L291 , FINSEQ_3:15;
L293: D31 = ( D13 + 1 ) by L292 , TARSKI:def 1;
L294: R4 = ( R7 + 1 ) by L293 , L115 , L114 , L120 , L136 , L147 , L276 , FUNCT_1:def 4;
thus L295: thesis by L294 , L147 , L276 , FINSEQ_3:8;
end;
suppose L296: ((not ( C24 . R3 ) in ( dom D18 )) & ( C24 . R4 ) in ( dom D18 ));

L297: D31 <= D13 by L296 , L152 , FINSEQ_1:1;
L298: (( D25 . D28 ) = ( D30 - 1 ) & ( D25 . D29 ) = D31) by L147 , L148 , L275 , L276 , L296;
L299: ( ( D30 - 1 ) + 1 ) <= ( D13 + 1 ) by L298 , L277 , L297 , XREAL_1:6;
L300: 1 <= D30 by L279 , FINSEQ_1:1;
L301: D30 in ( Seg ( D13 + 1 ) ) by L300 , L299 , FINSEQ_1:1;
L302: (not D30 in ( Seg D13 )) by L103 , L151 , L296 , FINSEQ_1:17;
L303: D30 in ( ( Seg ( D13 + 1 ) ) \ ( Seg D13 ) ) by L302 , L301 , XBOOLE_0:def 5;
L304: D30 in { ( D13 + 1 ) } by L303 , FINSEQ_3:15;
L305: D30 = ( D13 + 1 ) by L304 , TARSKI:def 1;
L306: R3 = ( R7 + 1 ) by L305 , L115 , L114 , L120 , L136 , L147 , L275 , FUNCT_1:def 4;
thus L307: thesis by L306 , L147 , L275 , FINSEQ_3:8;
end;
suppose L308: ((not ( C24 . R3 ) in ( dom D18 )) & (not ( C24 . R4 ) in ( dom D18 )));

L309: ( D25 . D29 ) = ( D31 - 1 ) by L308 , L147 , L148 , L276;
L310: ( D25 . R4 ) = ( D31 + ( - 1 ) ) by L309;
L311: ( D25 . D28 ) = ( D30 - 1 ) by L147 , L148 , L275 , L308;
L312: ( D25 . D28 ) = ( D30 + ( - 1 ) ) by L311;
L313: D30 = D31 by L312 , L277 , L310 , XCMPLX_1:2;
thus L314: thesis by L313 , L114 , L136 , L147 , L275 , L276 , FUNCT_1:def 4;
end;
end;
thus L316: thesis by L280;
end;
reconsider D32 = D25 as (Permutation of ( dom D24 )) by L274 , L201 , FUNCT_2:57;
L317: ( ( len ( D18 ^ <* D11 *> ) ) + ( len D17 ) ) = ( ( ( len D18 ) + ( len <* D11 *> ) ) + D14 ) by L197 , FINSEQ_1:22
.= ( R7 + 1 ) by L120 , L118 , L168 , FINSEQ_1:40;
L318: ( dom C22 ) = ( Seg ( ( len ( D18 ^ <* D11 *> ) ) + ( len D17 ) ) ) by L317 , L103 , FINSEQ_1:def 3;
L319: C22 = ( ( D18 ^ <* D11 *> ) ^ D17 ) by L318 , L256 , L169 , FINSEQ_1:def 7;
L320:
now
let R6 being (Element of ( NAT ));
assume L321: R6 in ( dom D10 );
L322: ( C24 . R6 ) in ( rng C24 ) by L321 , L114 , L136 , L149 , FUNCT_1:def 3;
reconsider D33 = ( C24 . R6 ) as (Element of ( NAT )) by L322 , L106;
L323:
now
per cases ;
suppose L324: ( C24 . R6 ) in ( dom D18 );

L325: (( C24 . R6 ) = ( D32 . R6 ) & ( C22 . D33 ) = ( D18 . D33 )) by L324 , L149 , L148 , L321 , FUNCT_1:47;
L326: (( C23 . R6 ) = ( D10 . R6 ) & ( C23 . R6 ) = ( C22 . ( C24 . R6 ) )) by L254 , L111 , L136 , L149 , L321 , FUNCT_1:47;
thus L327: ( D10 . R6 ) = ( D24 . ( D32 . R6 ) ) by L326 , L324 , L325 , FINSEQ_1:def 7;
end;
suppose L328: (not ( C24 . R6 ) in ( dom D18 ));

L329: ( D13 + 2 ) <= D33 by L328 , L149 , L147 , L153 , L321;
L330: ( ( D13 + 2 ) - 1 ) <= ( D33 - 1 ) by L329 , XREAL_1:9;
L331: D13 < ( D13 + 1 ) by XREAL_1:29;
L332: D13 < ( D33 - 1 ) by L331 , L330 , XXREAL_0:2;
L333: D13 < D33 by L332 , XREAL_1:146 , XXREAL_0:2;
reconsider D34 = ( D33 - 1 ) as (Element of ( NAT )) by L333 , NAT_1:20;
L334: (not D34 in ( dom D18 )) by L152 , L332 , FINSEQ_1:1;
L335: ( D32 . R6 ) = ( D33 - 1 ) by L149 , L148 , L321 , L328;
L336: ( D33 - 1 ) in ( dom D24 ) by L335 , L149 , L147 , L201 , L321 , FUNCT_1:def 3;
consider C35 being Nat such that L337: C35 in ( dom D17 ) and L338: D34 = ( ( len D18 ) + C35 ) by L336 , L334 , FINSEQ_1:25;
L339: ( len <* D11 *> ) = 1 by FINSEQ_1:39;
L340: (( C23 . R6 ) = ( D10 . R6 ) & ( C23 . R6 ) = ( C22 . ( C24 . R6 ) )) by L254 , L111 , L136 , L149 , L321 , FUNCT_1:47;
L341: C22 = ( D18 ^ ( <* D11 *> ^ D17 ) ) by L319 , FINSEQ_1:32;
L342: D33 in ( dom C22 ) by L105 , L114 , L106 , L136 , L149 , L321 , FUNCT_1:def 3;
consider C36 being Nat such that L343: C36 in ( dom ( <* D11 *> ^ D17 ) ) and L344: D33 = ( ( len D18 ) + C36 ) by L342 , L328 , L341 , FINSEQ_1:25;
L345: ( C22 . D33 ) = ( ( <* D11 *> ^ D17 ) . C36 ) by L341 , L343 , L344 , FINSEQ_1:def 7;
L346: C36 = ( 1 + C35 ) by L338 , L344;
L347: ( D24 . ( D33 - 1 ) ) = ( D17 . C35 ) by L337 , L338 , FINSEQ_1:def 7;
thus L348: ( D10 . R6 ) = ( D24 . ( D32 . R6 ) ) by L347 , L335 , L340 , L337 , L345 , L346 , L339 , FINSEQ_1:def 7;
end;
end;
thus L350: ( D10 . R6 ) = ( D24 . ( D32 . R6 ) ) by L323;
end;
L351: ( Sum D10 ) = ( Sum D24 ) by L320 , L102 , L120 , L118 , L200 , L198;
L352: ( Sum C23 ) = ( ( Sum D24 ) + ( Sum <* D11 *> ) ) by L351 , L103 , L104 , L200 , L112 , RLVECT_1:38 , RLVECT_1:44
.= ( ( ( Sum D18 ) + ( Sum D17 ) ) + ( Sum <* D11 *> ) ) by RLVECT_1:41
.= ( ( Sum D18 ) + ( ( Sum <* D11 *> ) + ( Sum D17 ) ) ) by RLVECT_1:def 3
.= ( ( Sum D18 ) + ( Sum ( <* D11 *> ^ D17 ) ) ) by RLVECT_1:41
.= ( Sum ( D18 ^ ( <* D11 *> ^ D17 ) ) ) by RLVECT_1:41
.= ( Sum C22 ) by L319 , FINSEQ_1:32;
thus L353: ( Sum C22 ) = ( Sum C23 ) by L352;
end;
L354: (for R7 being (Element of ( NAT )) holds (S2[ R7 ] implies S2[ ( R7 + 1 ) ])) by L101;
L355: S2[ ( 0 ) ]
proof
let C37 , C38 being (FinSequence of (the carrier of C18));
assume that
L356: ( len C37 ) = ( 0 )
and
L357: ( len C37 ) = ( len C38 );
L358: ( Sum C37 ) = ( 0. C18 ) by L356 , RLVECT_1:75;
thus L359: thesis by L358 , L356 , L357 , RLVECT_1:75;
end;
L360: (for R7 being (Element of ( NAT )) holds S2[ R7 ]) from NAT_1:sch 1(L355 , L354);
thus L361: thesis by L360;
end;
theorem
L362: (for B35 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B36 , B37 being (FinSequence of (the carrier of B35)) holds (for B38 being (Permutation of ( dom B36 )) holds (B37 = ( B36 * B38 ) implies ( Sum B36 ) = ( Sum B37 )))))
proof
let C39 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C40 , C41 being (FinSequence of (the carrier of C39));
let C42 being (Permutation of ( dom C40 ));
assume L363: C41 = ( C40 * C42 );
L364: (( len C40 ) = ( len C41 ) & (for R6 being (Element of ( NAT )) holds (R6 in ( dom C41 ) implies ( C41 . R6 ) = ( C40 . ( C42 . R6 ) )))) by L363 , FINSEQ_2:44 , FUNCT_1:12;
thus L365: thesis by L364 , L100;
end;
definition
let C43 being non  empty addLoopStr;
let C44 being  finite (Subset of C43);
assume L366: C43 is  Abelian  add-associative  right_zeroed;
func Sum C44 -> (Element of C43) means 
:L367: (ex B39 being (FinSequence of (the carrier of C43)) st (( rng B39 ) = C44 & B39 is  one-to-one & it = ( Sum B39 )));
existence
proof
consider R5 being FinSequence such that L368: ( rng R5 ) = C44 and L369: R5 is  one-to-one by FINSEQ_4:58;
reconsider D35 = R5 as (FinSequence of (the carrier of C43)) by L368 , FINSEQ_1:def 4;
take ( Sum D35 );
take D35;
thus L370: thesis by L368 , L369;
end;
uniqueness by L366 , RLVECT_1:42;
end;
theorem
L372: (for B40 being  Abelian  add-associative  right_zeroed non  empty addLoopStr holds ( Sum ( {} B40 ) ) = ( 0. B40 ))
proof
let C45 being  Abelian  add-associative  right_zeroed non  empty addLoopStr;
L373: ( Sum ( <*> (the carrier of C45) ) ) = ( 0. C45 ) by RLVECT_1:43;
thus L374: thesis by L373 , L367 , RELAT_1:38;
end;
theorem
L375: (for B41 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B42 being (Element of B41) holds ( Sum { B42 } ) = B42))
proof
let C46 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C47 being (Element of C46);
L376: ( Sum <* C47 *> ) = C47 by RLVECT_1:44;
L377: (( rng <* C47 *> ) = { C47 } & <* C47 *> is  one-to-one) by FINSEQ_1:39 , FINSEQ_3:93;
thus L378: thesis by L377 , L376 , L367;
end;
theorem
L379: (for B43 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B44 , B45 being (Element of B43) holds (B44 <> B45 implies ( Sum { B44 , B45 } ) = ( B44 + B45 ))))
proof
let C48 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C49 , C50 being (Element of C48);
assume L380: C49 <> C50;
L381: <* C49 , C50 *> is  one-to-one by L380 , FINSEQ_3:94;
L382: (( rng <* C49 , C50 *> ) = { C49 , C50 } & ( Sum <* C49 , C50 *> ) = ( C49 + C50 )) by FINSEQ_2:127 , RLVECT_1:45;
thus L383: thesis by L382 , L381 , L367;
end;
theorem
L384: (for B46 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B47 , B48 , B49 being (Element of B46) holds ((B47 <> B48 & B48 <> B49 & B47 <> B49) implies ( Sum { B47 , B48 , B49 } ) = ( ( B47 + B48 ) + B49 ))))
proof
let C51 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C52 , C53 , C54 being (Element of C51);
assume L385: (C52 <> C53 & C53 <> C54 & C52 <> C54);
L386: <* C52 , C53 , C54 *> is  one-to-one by L385 , FINSEQ_3:95;
L387: (( rng <* C52 , C53 , C54 *> ) = { C52 , C53 , C54 } & ( Sum <* C52 , C53 , C54 *> ) = ( ( C52 + C53 ) + C54 )) by FINSEQ_2:128 , RLVECT_1:46;
thus L388: thesis by L387 , L386 , L367;
end;
theorem
L389: (for B50 being  Abelian  add-associative  right_zeroed non  empty addLoopStr holds (for B51 , B52 being  finite (Subset of B50) holds (B52 misses B51 implies ( Sum ( B52 \/ B51 ) ) = ( ( Sum B52 ) + ( Sum B51 ) ))))
proof
let C55 being  Abelian  add-associative  right_zeroed non  empty addLoopStr;
let C56 , C57 being  finite (Subset of C55);
consider C58 being (FinSequence of (the carrier of C55)) such that L390: ( rng C58 ) = ( C57 \/ C56 ) and L391: (C58 is  one-to-one & ( Sum ( C57 \/ C56 ) ) = ( Sum C58 )) by L367;
consider C59 being (FinSequence of (the carrier of C55)) such that L392: ( rng C59 ) = C57 and L393: C59 is  one-to-one and L394: ( Sum C57 ) = ( Sum C59 ) by L367;
consider C60 being (FinSequence of (the carrier of C55)) such that L395: ( rng C60 ) = C56 and L396: C60 is  one-to-one and L397: ( Sum C56 ) = ( Sum C60 ) by L367;
set D36 = ( C59 ^ C60 );
assume L398: C57 misses C56;
L399: D36 is  one-to-one by L398 , L392 , L393 , L395 , L396 , FINSEQ_3:91;
L400: ( rng D36 ) = ( rng C58 ) by L390 , L392 , L395 , FINSEQ_1:31;
thus L401: ( Sum ( C57 \/ C56 ) ) = ( Sum D36 ) by L400 , L391 , L399 , RLVECT_1:42
.= ( ( Sum C57 ) + ( Sum C56 ) ) by L394 , L397 , RLVECT_1:41;
end;
theorem
L402: (for B53 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B54 , B55 being  finite (Subset of B53) holds ( Sum ( B55 \/ B54 ) ) = ( ( ( Sum B55 ) + ( Sum B54 ) ) - ( Sum ( B55 /\ B54 ) ) )))
proof
let C61 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C62 , C63 being  finite (Subset of C61);
set D37 = ( C62 \ C63 );
set D38 = ( C63 \ C62 );
set D39 = ( D37 \/ D38 );
set D40 = ( C63 /\ C62 );
L403: ( D37 \/ D40 ) = C62 by XBOOLE_1:51;
L404: ( D38 \/ D40 ) = C63 by XBOOLE_1:51;
L405: D39 = ( C63 \+\ C62 );
L406: ( D39 \/ D40 ) = ( C63 \/ C62 ) by L405 , XBOOLE_1:93;
L407: ( ( Sum ( C63 \/ C62 ) ) + ( Sum D40 ) ) = ( ( ( Sum D39 ) + ( Sum D40 ) ) + ( Sum D40 ) ) by L406 , L405 , L389 , XBOOLE_1:103
.= ( ( ( ( Sum D37 ) + ( Sum D38 ) ) + ( Sum D40 ) ) + ( Sum D40 ) ) by L389 , XBOOLE_1:82
.= ( ( ( Sum D37 ) + ( ( Sum D40 ) + ( Sum D38 ) ) ) + ( Sum D40 ) ) by RLVECT_1:def 3
.= ( ( ( Sum D37 ) + ( Sum D40 ) ) + ( ( Sum D38 ) + ( Sum D40 ) ) ) by RLVECT_1:def 3
.= ( ( Sum C62 ) + ( ( Sum D38 ) + ( Sum D40 ) ) ) by L403 , L389 , XBOOLE_1:89
.= ( ( Sum C63 ) + ( Sum C62 ) ) by L404 , L389 , XBOOLE_1:89;
thus L408: thesis by L407 , RLSUB_2:61;
end;
theorem
L409: (for B56 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B57 , B58 being  finite (Subset of B56) holds ( Sum ( B58 /\ B57 ) ) = ( ( ( Sum B58 ) + ( Sum B57 ) ) - ( Sum ( B58 \/ B57 ) ) )))
proof
let C64 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C65 , C66 being  finite (Subset of C64);
L410: ( Sum ( C66 \/ C65 ) ) = ( ( ( Sum C66 ) + ( Sum C65 ) ) - ( Sum ( C66 /\ C65 ) ) ) by L402;
L411: ( ( Sum C66 ) + ( Sum C65 ) ) = ( ( Sum ( C66 /\ C65 ) ) + ( Sum ( C66 \/ C65 ) ) ) by L410 , RLSUB_2:61;
thus L412: thesis by L411 , RLSUB_2:61;
end;
theorem
L413: (for B59 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B60 , B61 being  finite (Subset of B59) holds ( Sum ( B61 \ B60 ) ) = ( ( Sum ( B61 \/ B60 ) ) - ( Sum B60 ) )))
proof
let C67 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C68 , C69 being  finite (Subset of C67);
L414: ( C69 \ C68 ) misses C68 by XBOOLE_1:79;
L415: ( ( C69 \ C68 ) /\ C68 ) = ( {} C67 ) by L414 , XBOOLE_0:def 7;
L416: ( ( C69 \ C68 ) \/ C68 ) = ( C69 \/ C68 ) by XBOOLE_1:39;
L417: ( Sum ( C69 \/ C68 ) ) = ( ( ( Sum ( C69 \ C68 ) ) + ( Sum C68 ) ) - ( Sum ( ( C69 \ C68 ) /\ C68 ) ) ) by L416 , L402;
L418: ( Sum ( C69 \/ C68 ) ) = ( ( ( Sum ( C69 \ C68 ) ) + ( Sum C68 ) ) - ( 0. C67 ) ) by L417 , L415 , L372
.= ( ( Sum ( C69 \ C68 ) ) + ( Sum C68 ) ) by RLVECT_1:13;
thus L419: thesis by L418 , RLSUB_2:61;
end;
theorem
L420: (for B62 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B63 , B64 being  finite (Subset of B62) holds ( Sum ( B64 \ B63 ) ) = ( ( Sum B64 ) - ( Sum ( B64 /\ B63 ) ) )))
proof
let C70 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C71 , C72 being  finite (Subset of C70);
L421: ( C72 \ ( C72 /\ C71 ) ) = ( C72 \ C71 ) by XBOOLE_1:47;
L422: ( Sum ( C72 \ C71 ) ) = ( ( Sum ( C72 \/ ( C72 /\ C71 ) ) ) - ( Sum ( C72 /\ C71 ) ) ) by L421 , L413;
thus L423: thesis by L422 , XBOOLE_1:22;
end;
theorem
L424: (for B65 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B66 , B67 being  finite (Subset of B65) holds ( Sum ( B67 \+\ B66 ) ) = ( ( Sum ( B67 \/ B66 ) ) - ( Sum ( B67 /\ B66 ) ) )))
proof
let C73 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C74 , C75 being  finite (Subset of C73);
L425: ( C75 \+\ C74 ) = ( ( C75 \/ C74 ) \ ( C75 /\ C74 ) ) by XBOOLE_1:101;
thus L426: ( Sum ( C75 \+\ C74 ) ) = ( ( Sum ( C75 \/ C74 ) ) - ( Sum ( ( C75 \/ C74 ) /\ ( C75 /\ C74 ) ) ) ) by L425 , L420
.= ( ( Sum ( C75 \/ C74 ) ) - ( Sum ( ( ( C75 \/ C74 ) /\ C75 ) /\ C74 ) ) ) by XBOOLE_1:16
.= ( ( Sum ( C75 \/ C74 ) ) - ( Sum ( C75 /\ C74 ) ) ) by XBOOLE_1:21;
end;
theorem
L427: (for B68 being  Abelian  add-associative  right_zeroed non  empty addLoopStr holds (for B69 , B70 being  finite (Subset of B68) holds ( Sum ( B70 \+\ B69 ) ) = ( ( Sum ( B70 \ B69 ) ) + ( Sum ( B69 \ B70 ) ) ))) by L389 , XBOOLE_1:82;
definition
let C76 being non  empty ZeroStr;
mode Linear_Combination of C76
 -> (Element of ( Funcs ((the carrier of C76) , ( REAL )) ))
means :L428: (ex B71 being  finite (Subset of C76) st (for B72 being (Element of C76) holds ((not B72 in B71) implies ( it . B72 ) = ( 0 ))));
existence
proof
reconsider D41 = ( (the carrier of C76) --> ( 0 ) ) as (Element of ( Funcs ((the carrier of C76) , ( REAL )) )) by FUNCT_2:8;
take D41;
take ( {} C76 );
thus L429: thesis by FUNCOP_1:7;
end;
end;
notation
let C77 being non  empty addLoopStr;
let C78 being (Element of ( Funcs ((the carrier of C77) , ( REAL )) ));
synonym Carrier C78 for support C78;
end;
L432:
now
let C79 being non  empty addLoopStr;
let C80 being (Element of ( Funcs ((the carrier of C79) , ( REAL )) ));
L433: ( support C80 ) c= ( dom C80 ) by PRE_POLY:37;
thus L434: ( Carrier C80 ) c= (the carrier of C79)
proof
let C81 being set;
assume L435: C81 in ( support C80 );
L436: C81 in ( dom C80 ) by L435 , L433;
thus L437: thesis by L436;
end;

end;
definition
let C82 being non  empty addLoopStr;
let C83 being (Element of ( Funcs ((the carrier of C82) , ( REAL )) ));
redefine func Carrier C83 -> (Subset of C82) equals 
{ B73 where B73 is (Element of C82) : ( C83 . B73 ) <> ( 0 ) };
coherence by L432;
compatibility
proof
let C84 being (Subset of C82);
set D42 = ( Carrier C83 );
set D43 = { B74 where B74 is (Element of C82) : ( C83 . B74 ) <> ( 0 ) };
thus L435: (C84 = D42 implies C84 = D43)
proof
assume L436: C84 = D42;
thus L437: C84 c= D43
proof
let R1 being set;
assume L438: R1 in C84;
L439: ( C83 . R1 ) <> ( 0 ) by L438 , L436 , PRE_POLY:def 7;
thus L440: thesis by L439 , L438;
end;

let C85 being set;
assume L441: C85 in D43;
L442: (ex B75 being (Element of C82) st (C85 = B75 & ( C83 . B75 ) <> ( 0 ))) by L441;
thus L443: thesis by L442 , L436 , PRE_POLY:def 7;
end;

assume L444: C84 = D43;
thus L445: C84 c= D42
proof
let R1 being set;
assume L446: R1 in C84;
L447: (ex B76 being (Element of C82) st (R1 = B76 & ( C83 . B76 ) <> ( 0 ))) by L446 , L444;
thus L448: thesis by L447 , PRE_POLY:def 7;
end;

let R1 being set;
assume L449: R1 in D42;
L450: ( C83 . R1 ) <> ( 0 ) by L449 , PRE_POLY:def 7;
L451: ( Carrier C83 ) c= (the carrier of C82) by L432;
thus L452: thesis by L451 , L444 , L449 , L450;
end;
end;
registration
let C86 being non  empty addLoopStr;
let C87 being (Linear_Combination of C86);
cluster ( Carrier C87 ) ->  finite;
coherence
proof
set D44 = ( Carrier C87 );
consider C88 being  finite (Subset of C86) such that L454: (for B77 being (Element of C86) holds ((not B77 in C88) implies ( C87 . B77 ) = ( 0 ))) by L428;
L455: D44 c= C88
proof
let R1 being set;
assume L456: R1 in D44;
L457: (ex B78 being (Element of C86) st (R1 = B78 & ( C87 . B78 ) <> ( 0 ))) by L456;
thus L458: thesis by L457 , L454;
end;
thus L459: thesis by L455;
end;
end;
theorem
L461: (for B79 being non  empty addLoopStr holds (for B80 being (Linear_Combination of B79) holds (for B81 being (Element of B79) holds (( B80 . B81 ) = ( 0 ) iff (not B81 in ( Carrier B80 ))))))
proof
let C89 being non  empty addLoopStr;
let C90 being (Linear_Combination of C89);
let C91 being (Element of C89);
thus L462: (( C90 . C91 ) = ( 0 ) implies (not C91 in ( Carrier C90 )))
proof
assume L463: ( C90 . C91 ) = ( 0 );
assume L464: (not thesis);
L465: (ex B82 being (Element of C89) st (B82 = C91 & ( C90 . B82 ) <> ( 0 ))) by L464;
thus L466: thesis by L465 , L463;
end;

thus L467: thesis;
end;
definition
let C92 being non  empty addLoopStr;
func ZeroLC C92 -> (Linear_Combination of C92) means 
:L468: ( Carrier it ) = ( {} );
existence
proof
reconsider D45 = ( (the carrier of C92) --> ( 0 ) ) as (Function of (the carrier of C92) , ( REAL ));
reconsider D46 = D45 as (Element of ( Funcs ((the carrier of C92) , ( REAL )) )) by FUNCT_2:8;
L469: D46 is (Linear_Combination of C92)
proof
reconsider D47 = ( {} C92 ) as  empty  finite (Subset of C92);
take D47;
thus L470: thesis by FUNCOP_1:7;
end;
reconsider D48 = D46 as (Linear_Combination of C92) by L469;
take D48;
set D49 = { B83 where B83 is (Element of C92) : ( D48 . B83 ) <> ( 0 ) };
L471:
now
set D50 = the (Element of D49);
assume L472: D49 <> ( {} );
L473: D50 in D49 by L472;
L474: (ex B84 being (Element of C92) st (D50 = B84 & ( D48 . B84 ) <> ( 0 ))) by L473;
thus L475: contradiction by L474 , FUNCOP_1:7;
end;
thus L476: thesis by L471;
end;
uniqueness
proof
let C93 , C94 being (Linear_Combination of C92);
assume that
L477: ( Carrier C93 ) = ( {} )
and
L478: ( Carrier C94 ) = ( {} );
L479:
now
let R1 being set;
assume L480: R1 in (the carrier of C92);
reconsider D51 = R1 as (Element of C92) by L480;
L481:
now
assume L482: ( C94 . D51 ) <> ( 0 );
L483: D51 in { B85 where B85 is (Element of C92) : ( C94 . B85 ) <> ( 0 ) } by L482;
thus L484: contradiction by L483 , L478;
end;
L485:
now
assume L486: ( C93 . D51 ) <> ( 0 );
L487: D51 in { B86 where B86 is (Element of C92) : ( C93 . B86 ) <> ( 0 ) } by L486;
thus L488: contradiction by L487 , L477;
end;
thus L489: ( C93 . R1 ) = ( C94 . R1 ) by L485 , L481;
end;
thus L490: C93 = C94 by L479 , FUNCT_2:12;
end;
end;
theorem
L492: (for B87 being non  empty addLoopStr holds (for B88 being (Element of B87) holds ( ( ZeroLC B87 ) . B88 ) = ( 0 )))
proof
let C95 being non  empty addLoopStr;
let C96 being (Element of C95);
L493: (( Carrier ( ZeroLC C95 ) ) = ( {} ) & (not C96 in ( {} ))) by L468;
thus L494: thesis by L493;
end;
definition
let C97 being non  empty addLoopStr;
let C98 being (Subset of C97);
mode Linear_Combination of C98
 -> (Linear_Combination of C97)
means :L495: ( Carrier it ) c= C98;
existence
proof
take D52 = ( ZeroLC C97 );
L496: ( Carrier D52 ) = ( {} ) by L468;
thus L497: thesis by L496 , XBOOLE_1:2;
end;
end;
theorem
L499: (for R10 being RealLinearSpace holds (for R23 being (Subset of R10) holds (for R24 being (Subset of R10) holds (for R31 being (Linear_Combination of R23) holds (R23 c= R24 implies R31 is (Linear_Combination of R24))))))
proof
let R10 being RealLinearSpace;
let R23 being (Subset of R10);
let R24 being (Subset of R10);
let R31 being (Linear_Combination of R23);
assume L500: R23 c= R24;
L501: ( Carrier R31 ) c= R23 by L495;
L502: ( Carrier R31 ) c= R24 by L501 , L500 , XBOOLE_1:1;
thus L503: thesis by L502 , L495;
end;
theorem
L504: (for R10 being RealLinearSpace holds (for R23 being (Subset of R10) holds ( ZeroLC R10 ) is (Linear_Combination of R23)))
proof
let R10 being RealLinearSpace;
let R23 being (Subset of R10);
L505: (( Carrier ( ZeroLC R10 ) ) = ( {} ) & ( {} ) c= R23) by L468 , XBOOLE_1:2;
thus L506: thesis by L505 , L495;
end;
theorem
L507: (for R10 being RealLinearSpace holds (for B89 being (Linear_Combination of ( {} (the carrier of R10) )) holds B89 = ( ZeroLC R10 )))
proof
let R10 being RealLinearSpace;
let C99 being (Linear_Combination of ( {} (the carrier of R10) ));
L508: ( Carrier C99 ) c= ( {} ) by L495;
L509: ( Carrier C99 ) = ( {} ) by L508;
thus L510: thesis by L509 , L468;
end;
definition
let R10 being RealLinearSpace;
let R19 being (FinSequence of R10);
let R25 being (Function of (the carrier of R10) , ( REAL ));
func R25 (#) R19 -> (FinSequence of (the carrier of R10)) means 
:L511: (( len it ) = ( len R19 ) & (for R6 being (Element of ( NAT )) holds (R6 in ( dom it ) implies ( it . R6 ) = ( ( R25 . ( R19 /. R6 ) ) * ( R19 /. R6 ) ))));
existence
proof
deffunc H2(set) = ( ( R25 . ( R19 /. $1 ) ) * ( R19 /. $1 ) );
consider C100 being FinSequence such that L512: ( len C100 ) = ( len R19 ) and L513: (for B90 being Nat holds (B90 in ( dom C100 ) implies ( C100 . B90 ) = H2(B90))) from FINSEQ_1:sch 2;
L514: ( rng C100 ) c= (the carrier of R10)
proof
let R1 being set;
assume L515: R1 in ( rng C100 );
consider R2 being set such that L516: R2 in ( dom C100 ) and L517: ( C100 . R2 ) = R1 by L515 , FUNCT_1:def 3;
L518: R2 in ( Seg ( len R19 ) ) by L512 , L516 , FINSEQ_1:def 3;
reconsider D53 = R2 as (Element of ( NAT )) by L518;
L519: ( C100 . D53 ) = ( ( R25 . ( R19 /. D53 ) ) * ( R19 /. D53 ) ) by L513 , L516;
thus L520: thesis by L519 , L517;
end;
reconsider D54 = C100 as (FinSequence of (the carrier of R10)) by L514 , FINSEQ_1:def 4;
take D54;
thus L521: thesis by L512 , L513;
end;
uniqueness
proof
let R21 being (FinSequence of R10);
let R22 being (FinSequence of R10);
assume that
L522: ( len R21 ) = ( len R19 )
and
L523: (for R6 being (Element of ( NAT )) holds (R6 in ( dom R21 ) implies ( R21 . R6 ) = ( ( R25 . ( R19 /. R6 ) ) * ( R19 /. R6 ) )))
and
L524: ( len R22 ) = ( len R19 )
and
L525: (for R6 being (Element of ( NAT )) holds (R6 in ( dom R22 ) implies ( R22 . R6 ) = ( ( R25 . ( R19 /. R6 ) ) * ( R19 /. R6 ) )));
L526:
now
let C101 being Nat;
assume L527: (1 <= C101 & C101 <= ( len R21 ));
L528: C101 in ( Seg ( len R21 ) ) by L527 , FINSEQ_1:1;
L529: C101 in ( dom R21 ) by L528 , FINSEQ_1:def 3;
L530: ( R21 . C101 ) = ( ( R25 . ( R19 /. C101 ) ) * ( R19 /. C101 ) ) by L529 , L523;
L531: C101 in ( dom R22 ) by L522 , L524 , L528 , FINSEQ_1:def 3;
thus L532: ( R21 . C101 ) = ( R22 . C101 ) by L531 , L525 , L530;
end;
thus L533: thesis by L526 , L522 , L524 , FINSEQ_1:14;
end;
end;
theorem
L535: (for R6 being (Element of ( NAT )) holds (for R10 being RealLinearSpace holds (for R12 being (VECTOR of R10) holds (for R19 being (FinSequence of R10) holds (for R25 being (Function of (the carrier of R10) , ( REAL )) holds ((R6 in ( dom R19 ) & R12 = ( R19 . R6 )) implies ( ( R25 (#) R19 ) . R6 ) = ( ( R25 . R12 ) * R12 )))))))
proof
let R6 being (Element of ( NAT ));
let R10 being RealLinearSpace;
let R12 being (VECTOR of R10);
let R19 being (FinSequence of R10);
let R25 being (Function of (the carrier of R10) , ( REAL ));
assume that
L536: R6 in ( dom R19 )
and
L537: R12 = ( R19 . R6 );
L538: ( R19 /. R6 ) = ( R19 . R6 ) by L536 , PARTFUN1:def 6;
L539: ( len ( R25 (#) R19 ) ) = ( len R19 ) by L511;
L540: R6 in ( dom ( R25 (#) R19 ) ) by L539 , L536 , FINSEQ_3:29;
thus L541: thesis by L540 , L537 , L538 , L511;
end;
theorem
L542: (for R10 being RealLinearSpace holds (for R25 being (Function of (the carrier of R10) , ( REAL )) holds ( R25 (#) ( <*> (the carrier of R10) ) ) = ( <*> (the carrier of R10) )))
proof
let R10 being RealLinearSpace;
let R25 being (Function of (the carrier of R10) , ( REAL ));
L543: ( len ( R25 (#) ( <*> (the carrier of R10) ) ) ) = ( len ( <*> (the carrier of R10) ) ) by L511
.= ( 0 );
thus L544: thesis by L543;
end;
theorem
L545: (for R10 being RealLinearSpace holds (for R12 being (VECTOR of R10) holds (for R25 being (Function of (the carrier of R10) , ( REAL )) holds ( R25 (#) <* R12 *> ) = <* ( ( R25 . R12 ) * R12 ) *>)))
proof
let R10 being RealLinearSpace;
let R12 being (VECTOR of R10);
let R25 being (Function of (the carrier of R10) , ( REAL ));
L546: 1 in { 1 } by TARSKI:def 1;
L547: ( len ( R25 (#) <* R12 *> ) ) = ( len <* R12 *> ) by L511
.= 1 by FINSEQ_1:40;
L548: ( dom ( R25 (#) <* R12 *> ) ) = { 1 } by L547 , FINSEQ_1:2 , FINSEQ_1:def 3;
L549: ( ( R25 (#) <* R12 *> ) . 1 ) = ( ( R25 . ( <* R12 *> /. 1 ) ) * ( <* R12 *> /. 1 ) ) by L548 , L546 , L511
.= ( ( R25 . ( <* R12 *> /. 1 ) ) * R12 ) by FINSEQ_4:16
.= ( ( R25 . R12 ) * R12 ) by FINSEQ_4:16;
thus L550: thesis by L549 , L547 , FINSEQ_1:40;
end;
theorem
L551: (for R10 being RealLinearSpace holds (for R13 being (VECTOR of R10) holds (for R14 being (VECTOR of R10) holds (for R25 being (Function of (the carrier of R10) , ( REAL )) holds ( R25 (#) <* R13 , R14 *> ) = <* ( ( R25 . R13 ) * R13 ) , ( ( R25 . R14 ) * R14 ) *>))))
proof
let R10 being RealLinearSpace;
let R13 being (VECTOR of R10);
let R14 being (VECTOR of R10);
let R25 being (Function of (the carrier of R10) , ( REAL ));
L552: ( len ( R25 (#) <* R13 , R14 *> ) ) = ( len <* R13 , R14 *> ) by L511
.= 2 by FINSEQ_1:44;
L553: ( dom ( R25 (#) <* R13 , R14 *> ) ) = { 1 , 2 } by L552 , FINSEQ_1:2 , FINSEQ_1:def 3;
L554: 2 in { 1 , 2 } by TARSKI:def 2;
L555: ( ( R25 (#) <* R13 , R14 *> ) . 2 ) = ( ( R25 . ( <* R13 , R14 *> /. 2 ) ) * ( <* R13 , R14 *> /. 2 ) ) by L554 , L553 , L511
.= ( ( R25 . ( <* R13 , R14 *> /. 2 ) ) * R14 ) by FINSEQ_4:17
.= ( ( R25 . R14 ) * R14 ) by FINSEQ_4:17;
L556: 1 in { 1 , 2 } by TARSKI:def 2;
L557: ( ( R25 (#) <* R13 , R14 *> ) . 1 ) = ( ( R25 . ( <* R13 , R14 *> /. 1 ) ) * ( <* R13 , R14 *> /. 1 ) ) by L556 , L553 , L511
.= ( ( R25 . ( <* R13 , R14 *> /. 1 ) ) * R13 ) by FINSEQ_4:17
.= ( ( R25 . R13 ) * R13 ) by FINSEQ_4:17;
thus L558: thesis by L557 , L552 , L555 , FINSEQ_1:44;
end;
theorem
L559: (for R10 being RealLinearSpace holds (for R13 being (VECTOR of R10) holds (for R14 being (VECTOR of R10) holds (for R15 being (VECTOR of R10) holds (for R25 being (Function of (the carrier of R10) , ( REAL )) holds ( R25 (#) <* R13 , R14 , R15 *> ) = <* ( ( R25 . R13 ) * R13 ) , ( ( R25 . R14 ) * R14 ) , ( ( R25 . R15 ) * R15 ) *>)))))
proof
let R10 being RealLinearSpace;
let R13 being (VECTOR of R10);
let R14 being (VECTOR of R10);
let R15 being (VECTOR of R10);
let R25 being (Function of (the carrier of R10) , ( REAL ));
L560: ( len ( R25 (#) <* R13 , R14 , R15 *> ) ) = ( len <* R13 , R14 , R15 *> ) by L511
.= 3 by FINSEQ_1:45;
L561: ( dom ( R25 (#) <* R13 , R14 , R15 *> ) ) = { 1 , 2 , 3 } by L560 , FINSEQ_1:def 3 , FINSEQ_3:1;
L562: 3 in { 1 , 2 , 3 } by ENUMSET1:def 1;
L563: ( ( R25 (#) <* R13 , R14 , R15 *> ) . 3 ) = ( ( R25 . ( <* R13 , R14 , R15 *> /. 3 ) ) * ( <* R13 , R14 , R15 *> /. 3 ) ) by L562 , L561 , L511
.= ( ( R25 . ( <* R13 , R14 , R15 *> /. 3 ) ) * R15 ) by FINSEQ_4:18
.= ( ( R25 . R15 ) * R15 ) by FINSEQ_4:18;
L564: 2 in { 1 , 2 , 3 } by ENUMSET1:def 1;
L565: ( ( R25 (#) <* R13 , R14 , R15 *> ) . 2 ) = ( ( R25 . ( <* R13 , R14 , R15 *> /. 2 ) ) * ( <* R13 , R14 , R15 *> /. 2 ) ) by L564 , L561 , L511
.= ( ( R25 . ( <* R13 , R14 , R15 *> /. 2 ) ) * R14 ) by FINSEQ_4:18
.= ( ( R25 . R14 ) * R14 ) by FINSEQ_4:18;
L566: 1 in { 1 , 2 , 3 } by ENUMSET1:def 1;
L567: ( ( R25 (#) <* R13 , R14 , R15 *> ) . 1 ) = ( ( R25 . ( <* R13 , R14 , R15 *> /. 1 ) ) * ( <* R13 , R14 , R15 *> /. 1 ) ) by L566 , L561 , L511
.= ( ( R25 . ( <* R13 , R14 , R15 *> /. 1 ) ) * R13 ) by FINSEQ_4:18
.= ( ( R25 . R13 ) * R13 ) by FINSEQ_4:18;
thus L568: thesis by L567 , L560 , L565 , L563 , FINSEQ_1:45;
end;
definition
let R10 being RealLinearSpace;
let R27 being (Linear_Combination of R10);
func Sum R27 -> (Element of R10) means 
:L569: (ex R19 being (FinSequence of R10) st (R19 is  one-to-one & ( rng R19 ) = ( Carrier R27 ) & it = ( Sum ( R27 (#) R19 ) )));
existence
proof
consider C102 being FinSequence such that L570: ( rng C102 ) = ( Carrier R27 ) and L571: C102 is  one-to-one by FINSEQ_4:58;
reconsider D55 = C102 as (FinSequence of (the carrier of R10)) by L570 , FINSEQ_1:def 4;
take ( Sum ( R27 (#) D55 ) );
take D55;
thus L572: (D55 is  one-to-one & ( rng D55 ) = ( Carrier R27 )) by L570 , L571;
thus L573: thesis;
end;
uniqueness
proof
let C103 , C104 being (Element of R10);
given C105 being (FinSequence of (the carrier of R10)) such that
L574: C105 is  one-to-one
and
L575: ( rng C105 ) = ( Carrier R27 )
and
L576: C103 = ( Sum ( R27 (#) C105 ) );

given C106 being (FinSequence of (the carrier of R10)) such that
L577: C106 is  one-to-one
and
L578: ( rng C106 ) = ( Carrier R27 )
and
L579: C104 = ( Sum ( R27 (#) C106 ) );

defpred S5[ set , set ] means { $2 } = ( C105 " { ( C106 . $1 ) } );
L580: ( dom C106 ) = ( Seg ( len C106 ) ) by FINSEQ_1:def 3;
L581: ( dom C105 ) = ( Seg ( len C105 ) ) by FINSEQ_1:def 3;
L582: ( len C105 ) = ( len C106 ) by L574 , L575 , L577 , L578 , FINSEQ_1:48;
L583: (for R1 being set holds (R1 in ( dom C105 ) implies (ex R2 being set st (R2 in ( dom C105 ) & S5[ R1 , R2 ]))))
proof
let R1 being set;
assume L584: R1 in ( dom C105 );
L585: ( C106 . R1 ) in ( rng C105 ) by L584 , L575 , L578 , L582 , L581 , L580 , FUNCT_1:def 3;
consider R2 being set such that L586: ( C105 " { ( C106 . R1 ) } ) = { R2 } by L585 , L574 , FUNCT_1:74;
take R2;
L587: R2 in ( C105 " { ( C106 . R1 ) } ) by L586 , TARSKI:def 1;
thus L588: R2 in ( dom C105 ) by L587 , FUNCT_1:def 7;
thus L589: thesis by L586;
end;
consider C107 being (Function of ( dom C105 ) , ( dom C105 )) such that L590: (for R1 being set holds (R1 in ( dom C105 ) implies S5[ R1 , ( C107 . R1 ) ])) from FUNCT_2:sch 1(L583);
L591: C107 is  one-to-one
proof
let R3 being set;
let R4 being set;
assume that
L592: R3 in ( dom C107 )
and
L593: R4 in ( dom C107 )
and
L594: ( C107 . R3 ) = ( C107 . R4 );
L595: ( C106 . R3 ) in ( rng C105 ) by L575 , L578 , L582 , L581 , L580 , L592 , FUNCT_1:def 3;
L596: { ( C106 . R3 ) } c= ( rng C105 ) by L595 , ZFMISC_1:31;
L597: ( C106 . R4 ) in ( rng C105 ) by L575 , L578 , L582 , L581 , L580 , L593 , FUNCT_1:def 3;
L598: { ( C106 . R4 ) } c= ( rng C105 ) by L597 , ZFMISC_1:31;
L599: (( C105 " { ( C106 . R3 ) } ) = { ( C107 . R3 ) } & ( C105 " { ( C106 . R4 ) } ) = { ( C107 . R4 ) }) by L590 , L592 , L593;
L600: { ( C106 . R3 ) } = { ( C106 . R4 ) } by L599 , L594 , L596 , L598 , FUNCT_1:91;
L601: ( C106 . R3 ) = ( C106 . R4 ) by L600 , ZFMISC_1:3;
thus L602: thesis by L601 , L577 , L582 , L581 , L580 , L592 , L593 , FUNCT_1:def 4;
end;
set D56 = ( R27 (#) C105 );
L603: ( len D56 ) = ( len C105 ) by L511;
L604: ( rng C107 ) = ( dom C105 )
proof
thus L605: ( rng C107 ) c= ( dom C105 );
let R2 being set;
assume L606: R2 in ( dom C105 );
L607: ( C105 . R2 ) in ( rng C106 ) by L606 , L575 , L578 , FUNCT_1:def 3;
consider R1 being set such that L608: R1 in ( dom C106 ) and L609: ( C106 . R1 ) = ( C105 . R2 ) by L607 , FUNCT_1:def 3;
L610: ( C105 " { ( C106 . R1 ) } ) = ( C105 " ( Im (C105 , R2) ) ) by L606 , L609 , FUNCT_1:59;
L611: ( C105 " { ( C106 . R1 ) } ) c= { R2 } by L610 , L574 , FUNCT_1:82;
L612: { ( C107 . R1 ) } c= { R2 } by L611 , L582 , L581 , L580 , L590 , L608;
L613: ( C107 . R1 ) = R2 by L612 , ZFMISC_1:18;
L614: R1 in ( dom C107 ) by L582 , L581 , L580 , L608 , FUNCT_2:def 1;
thus L615: thesis by L614 , L613 , FUNCT_1:def 3;
end;
reconsider D57 = C107 as (Permutation of ( dom C105 )) by L604 , L591 , FUNCT_2:57;
L616: (( dom C105 ) = ( Seg ( len C105 ) ) & ( dom D56 ) = ( Seg ( len D56 ) )) by FINSEQ_1:def 3;
reconsider D58 = D57 as (Permutation of ( dom D56 )) by L616 , L603;
set D59 = ( R27 (#) C106 );
L617: ( dom D59 ) = ( Seg ( len D59 ) ) by FINSEQ_1:def 3;
L618: ( len D59 ) = ( len C106 ) by L511;
L619: ( dom D56 ) = ( Seg ( len D56 ) ) by FINSEQ_1:def 3;
L620:
now
let R6 being (Element of ( NAT ));
assume L621: R6 in ( dom D59 );
reconsider D60 = ( C106 . R6 ) as (VECTOR of R10) by L621 , L618 , L580 , L617 , FUNCT_1:102;
L622: (( D59 . R6 ) = ( ( R27 . ( C106 /. R6 ) ) * ( C106 /. R6 ) ) & ( C106 . R6 ) = ( C106 /. R6 )) by L618 , L580 , L617 , L621 , L511 , PARTFUN1:def 6;
L623: R6 in ( dom D58 ) by L582 , L603 , L618 , L619 , L617 , L621 , FUNCT_2:def 1;
L624: ( D58 . R6 ) in ( dom C105 ) by L623 , L604 , FUNCT_1:def 3;
reconsider D61 = ( D58 . R6 ) as (Element of ( NAT )) by L624;
reconsider D62 = ( C105 . D61 ) as (VECTOR of R10) by L624 , FUNCT_1:102;
L625: { ( C105 . ( D58 . R6 ) ) } = ( Im (C105 , ( D58 . R6 )) ) by L624 , FUNCT_1:59
.= ( C105 .: ( C105 " { ( C106 . R6 ) } ) ) by L582 , L618 , L581 , L617 , L590 , L621;
L626: D60 = D62 by L625 , FUNCT_1:75 , ZFMISC_1:18;
L627: ( C105 . D61 ) = ( C105 /. D61 ) by L624 , PARTFUN1:def 6;
thus L628: ( D59 . R6 ) = ( D56 . ( D58 . R6 ) ) by L627 , L603 , L581 , L619 , L624 , L626 , L622 , L511;
end;
thus L629: thesis by L620 , L574 , L575 , L576 , L577 , L578 , L579 , L603 , L618 , L100 , FINSEQ_1:48;
end;
end;
L631: (for R10 being RealLinearSpace holds ( Sum ( ZeroLC R10 ) ) = ( 0. R10 ))
proof
let R10 being RealLinearSpace;
consider R19 being (FinSequence of R10) such that L632: R19 is  one-to-one and L633: ( rng R19 ) = ( Carrier ( ZeroLC R10 ) ) and L634: ( Sum ( ZeroLC R10 ) ) = ( Sum ( ( ZeroLC R10 ) (#) R19 ) ) by L569;
L635: ( Carrier ( ZeroLC R10 ) ) = ( {} ) by L468;
L636: R19 = ( {} ) by L635 , L633 , RELAT_1:41;
L637: ( len R19 ) = ( 0 ) by L636;
L638: ( len ( ( ZeroLC R10 ) (#) R19 ) ) = ( 0 ) by L637 , L511;
thus L639: thesis by L638 , L634 , RLVECT_1:75;
end;
theorem
L640: (for R10 being RealLinearSpace holds (for R23 being (Subset of R10) holds ((R23 <> ( {} ) & R23 is  linearly-closed) iff (for R31 being (Linear_Combination of R23) holds ( Sum R31 ) in R23))))
proof
let R10 being RealLinearSpace;
let R23 being (Subset of R10);
thus L641: ((R23 <> ( {} ) & R23 is  linearly-closed) implies (for R31 being (Linear_Combination of R23) holds ( Sum R31 ) in R23))
proof
defpred S6[ (Element of ( NAT )) ] means (for R31 being (Linear_Combination of R23) holds (( card ( Carrier R31 ) ) = $1 implies ( Sum R31 ) in R23));
assume that
L642: R23 <> ( {} )
and
L643: R23 is  linearly-closed;
L644:
now
let R31 being (Linear_Combination of R23);
assume L645: ( card ( Carrier R31 ) ) = ( 0 );
L646: ( Carrier R31 ) = ( {} ) by L645;
L647: R31 = ( ZeroLC R10 ) by L646 , L468;
L648: ( Sum R31 ) = ( 0. R10 ) by L647 , L631;
thus L649: ( Sum R31 ) in R23 by L648 , L642 , L643 , RLSUB_1:1;
end;
L650: S6[ ( 0 ) ] by L644;
L651:
now
let R7 being (Element of ( NAT ));
assume L652: (for R31 being (Linear_Combination of R23) holds (( card ( Carrier R31 ) ) = R7 implies ( Sum R31 ) in R23));
let R31 being (Linear_Combination of R23);
deffunc H3((Element of R10)) = ( R31 . $1 );
consider R19 being (FinSequence of R10) such that L653: R19 is  one-to-one and L654: ( rng R19 ) = ( Carrier R31 ) and L655: ( Sum R31 ) = ( Sum ( R31 (#) R19 ) ) by L569;
reconsider D63 = ( R19 | ( Seg R7 ) ) as (FinSequence of (the carrier of R10)) by FINSEQ_1:18;
assume L656: ( card ( Carrier R31 ) ) = ( R7 + 1 );
L657: ( len R19 ) = ( R7 + 1 ) by L656 , L653 , L654 , FINSEQ_4:62;
L658: ( len ( R31 (#) R19 ) ) = ( R7 + 1 ) by L657 , L511;
L659: ( R7 + 1 ) in ( Seg ( R7 + 1 ) ) by FINSEQ_1:4;
L660: ( R7 + 1 ) in ( dom R19 ) by L659 , L657 , FINSEQ_1:def 3;
L661: ( R7 + 1 ) in ( dom R19 ) by L657 , L659 , FINSEQ_1:def 3;
reconsider D64 = ( R19 . ( R7 + 1 ) ) as (VECTOR of R10) by L661 , FUNCT_1:102;
consider C108 being (Function of (the carrier of R10) , ( REAL )) such that L662: ( C108 . D64 ) = ( 0 ) and L663: (for B91 being (Element of R10) holds (B91 <> D64 implies ( C108 . B91 ) = H3(B91))) from FUNCT_2:sch 6;
reconsider D65 = C108 as (Element of ( Funcs ((the carrier of R10) , ( REAL )) )) by FUNCT_2:8;
L664: D64 in ( Carrier R31 ) by L654 , L660 , FUNCT_1:def 3;
L665:
now
let R11 being (VECTOR of R10);
assume L666: (not R11 in ( Carrier R31 ));
thus L667: ( D65 . R11 ) = ( R31 . R11 ) by L666 , L664 , L663
.= ( 0 ) by L666;
end;
reconsider D66 = D65 as (Linear_Combination of R10) by L665 , L428;
L668: ( R23 \ { D64 } ) c= R23 by XBOOLE_1:36;
L669: ( Carrier R31 ) c= R23 by L495;
L670: ( ( R31 . D64 ) * D64 ) in R23 by L669 , L643 , L664 , RLSUB_1:def 1;
L671: ( Carrier D66 ) = ( ( Carrier R31 ) \ { D64 } )
proof
thus L672: ( Carrier D66 ) c= ( ( Carrier R31 ) \ { D64 } )
proof
let R1 being set;
assume L673: R1 in ( Carrier D66 );
consider R11 being (VECTOR of R10) such that L674: R11 = R1 and L675: ( D66 . R11 ) <> ( 0 ) by L673;
L676: ( D66 . R11 ) = ( R31 . R11 ) by L662 , L663 , L675;
L677: R1 in ( Carrier R31 ) by L676 , L674 , L675;
L678: (not R1 in { D64 }) by L662 , L674 , L675 , TARSKI:def 1;
thus L679: thesis by L678 , L677 , XBOOLE_0:def 5;
end;

let R1 being set;
assume L680: R1 in ( ( Carrier R31 ) \ { D64 } );
L681: R1 in ( Carrier R31 ) by L680 , XBOOLE_0:def 5;
consider R11 being (VECTOR of R10) such that L682: R1 = R11 and L683: ( R31 . R11 ) <> ( 0 ) by L681;
L684: (not R1 in { D64 }) by L680 , XBOOLE_0:def 5;
L685: R1 <> D64 by L684 , TARSKI:def 1;
L686: ( R31 . R11 ) = ( D66 . R11 ) by L685 , L663 , L682;
thus L687: thesis by L686 , L682 , L683;
end;
L688: ( Carrier D66 ) c= ( R23 \ { D64 } ) by L671 , L669 , XBOOLE_1:33;
L689: ( Carrier D66 ) c= R23 by L688 , L668 , XBOOLE_1:1;
reconsider D67 = D66 as (Linear_Combination of R23) by L689 , L495;
L690: ( len D63 ) = R7 by L657 , FINSEQ_3:53;
L691: ( len ( D67 (#) D63 ) ) = R7 by L690 , L511;
L692: ( rng D63 ) = ( Carrier D67 )
proof
thus L693: ( rng D63 ) c= ( Carrier D67 )
proof
let R1 being set;
assume L694: R1 in ( rng D63 );
consider R2 being set such that L695: R2 in ( dom D63 ) and L696: ( D63 . R2 ) = R1 by L694 , FUNCT_1:def 3;
reconsider D68 = R2 as (Element of ( NAT )) by L695;
L697: (( dom D63 ) c= ( dom R19 ) & ( D63 . D68 ) = ( R19 . D68 )) by L695 , FUNCT_1:47 , RELAT_1:60;
L698:
now
assume L699: R1 = D64;
L700: ( R7 + 1 ) = D68 by L699 , L653 , L660 , L695 , L696 , L697 , FUNCT_1:def 4;
L701: D68 <= R7 by L690 , L695 , FINSEQ_3:25;
thus L702: contradiction by L701 , L700 , XREAL_1:29;
end;
L703: (not R1 in { D64 }) by L698 , TARSKI:def 1;
L704: R1 in ( rng R19 ) by L695 , L696 , L697 , FUNCT_1:def 3;
thus L705: thesis by L704 , L654 , L671 , L703 , XBOOLE_0:def 5;
end;

let R1 being set;
assume L706: R1 in ( Carrier D67 );
L707: R1 in ( rng R19 ) by L706 , L654 , L671 , XBOOLE_0:def 5;
consider R2 being set such that L708: R2 in ( dom R19 ) and L709: ( R19 . R2 ) = R1 by L707 , FUNCT_1:def 3;
reconsider D69 = R2 as (Element of ( NAT )) by L708;
L710:
now
assume L711: (not D69 in ( Seg R7 ));
L712: D69 in ( ( dom R19 ) \ ( Seg R7 ) ) by L711 , L708 , XBOOLE_0:def 5;
L713: D69 in ( ( Seg ( R7 + 1 ) ) \ ( Seg R7 ) ) by L712 , L657 , FINSEQ_1:def 3;
L714: D69 in { ( R7 + 1 ) } by L713 , FINSEQ_3:15;
L715: D69 = ( R7 + 1 ) by L714 , TARSKI:def 1;
L716: (not D64 in { D64 }) by L715 , L671 , L706 , L709 , XBOOLE_0:def 5;
thus L717: contradiction by L716 , TARSKI:def 1;
end;
L718: D69 in ( ( dom R19 ) /\ ( Seg R7 ) ) by L710 , L708 , XBOOLE_0:def 4;
L719: D69 in ( dom D63 ) by L718 , RELAT_1:61;
L720: ( D63 . D69 ) = ( R19 . D69 ) by L719 , FUNCT_1:47;
thus L721: thesis by L720 , L709 , L719 , FUNCT_1:def 3;
end;
L722: ( ( Seg ( R7 + 1 ) ) /\ ( Seg R7 ) ) = ( Seg R7 ) by FINSEQ_1:7 , NAT_1:12
.= ( dom ( D67 (#) D63 ) ) by L691 , FINSEQ_1:def 3;
L723: ( dom ( D67 (#) D63 ) ) = ( ( dom ( R31 (#) R19 ) ) /\ ( Seg R7 ) ) by L722 , L658 , FINSEQ_1:def 3;
L724:
now
let R1 being set;
assume L725: R1 in ( dom ( D67 (#) D63 ) );
reconsider D70 = R1 as (Element of ( NAT )) by L725;
L726: D70 in ( dom ( R31 (#) R19 ) ) by L723 , L725 , XBOOLE_0:def 4;
L727: D70 in ( dom R19 ) by L726 , L657 , L658 , FINSEQ_3:29;
L728: ( R19 . D70 ) in ( rng R19 ) by L727 , FUNCT_1:def 3;
reconsider D71 = ( R19 . D70 ) as (VECTOR of R10) by L728;
L729: D70 in ( dom D63 ) by L690 , L691 , L725 , FINSEQ_3:29;
L730: ( D63 . D70 ) in ( rng D63 ) by L729 , FUNCT_1:def 3;
reconsider D72 = ( D63 . D70 ) as (VECTOR of R10) by L730;
L731: (not D72 in { D64 }) by L671 , L692 , L730 , XBOOLE_0:def 5;
L732: D72 <> D64 by L731 , TARSKI:def 1;
L733: ( ( D67 (#) D63 ) . D70 ) = ( ( D67 . D72 ) * D72 ) by L729 , L535
.= ( ( R31 . D72 ) * D72 ) by L663 , L732;
L734: D71 = D72 by L729 , FUNCT_1:47;
thus L735: ( ( D67 (#) D63 ) . R1 ) = ( ( R31 (#) R19 ) . R1 ) by L734 , L733 , L727 , L535;
end;
L736: ( D67 (#) D63 ) = ( ( R31 (#) R19 ) | ( Seg R7 ) ) by L724 , L723 , FUNCT_1:46;
L737: D64 in ( rng R19 ) by L660 , FUNCT_1:def 3;
L738: { D64 } c= ( Carrier R31 ) by L737 , L654 , ZFMISC_1:31;
L739: ( card ( Carrier D67 ) ) = ( ( R7 + 1 ) - ( card { D64 } ) ) by L738 , L656 , L671 , CARD_2:44
.= ( ( R7 + 1 ) - 1 ) by CARD_1:30
.= R7;
L740: ( Sum D67 ) in R23 by L739 , L652;
L741: D63 is  one-to-one by L653 , FUNCT_1:52;
L742: ( Sum ( D67 (#) D63 ) ) = ( Sum D67 ) by L741 , L692 , L569;
L743: (( dom ( D67 (#) D63 ) ) = ( Seg ( len ( D67 (#) D63 ) ) ) & ( ( R31 (#) R19 ) . ( len R19 ) ) = ( ( R31 . D64 ) * D64 )) by L657 , L660 , L535 , FINSEQ_1:def 3;
L744: ( Sum ( R31 (#) R19 ) ) = ( ( Sum ( D67 (#) D63 ) ) + ( ( R31 . D64 ) * D64 ) ) by L743 , L657 , L658 , L691 , L736 , RLVECT_1:38;
thus L745: ( Sum R31 ) in R23 by L744 , L643 , L655 , L670 , L742 , L740 , RLSUB_1:def 1;
end;
L746: (for R7 being (Element of ( NAT )) holds (S6[ R7 ] implies S6[ ( R7 + 1 ) ])) by L651;
let R31 being (Linear_Combination of R23);
L747: ( card ( Carrier R31 ) ) = ( card ( Carrier R31 ) );
L748: (for R7 being (Element of ( NAT )) holds S6[ R7 ]) from NAT_1:sch 1(L650 , L746);
thus L749: thesis by L748 , L747;
end;

assume L750: (for R31 being (Linear_Combination of R23) holds ( Sum R31 ) in R23);
thus L751: R23 <> ( {} ) by L750;
L752: (( ZeroLC R10 ) is (Linear_Combination of R23) & ( Sum ( ZeroLC R10 ) ) = ( 0. R10 )) by L631 , L504;
L753: ( 0. R10 ) in R23 by L752 , L750;
L754: (for R17 being Real holds (for R12 being (VECTOR of R10) holds (R12 in R23 implies ( R17 * R12 ) in R23)))
proof
let R17 being Real;
let R12 being (VECTOR of R10);
assume L755: R12 in R23;
L756:
now
per cases ;
suppose L757: R17 = ( 0 );

thus L758: thesis by L757 , L753 , RLVECT_1:10;
end;
suppose L759: R17 <> ( 0 );

deffunc H4((Element of R10)) = ( 0 );
consider R25 being (Function of (the carrier of R10) , ( REAL )) such that L760: ( R25 . R12 ) = R17 and L761: (for B92 being (Element of R10) holds (B92 <> R12 implies ( R25 . B92 ) = H4(B92))) from FUNCT_2:sch 6;
reconsider D73 = R25 as (Element of ( Funcs ((the carrier of R10) , ( REAL )) )) by FUNCT_2:8;
L762:
now
let R11 being (VECTOR of R10);
assume L763: (not R11 in { R12 });
L764: R11 <> R12 by L763 , TARSKI:def 1;
thus L765: ( D73 . R11 ) = ( 0 ) by L764 , L761;
end;
reconsider D74 = D73 as (Linear_Combination of R10) by L762 , L428;
L766: ( Carrier D74 ) = { R12 }
proof
thus L767: ( Carrier D74 ) c= { R12 }
proof
let R1 being set;
assume L768: R1 in ( Carrier D74 );
consider R11 being (VECTOR of R10) such that L769: R1 = R11 and L770: ( D74 . R11 ) <> ( 0 ) by L768;
L771: R11 = R12 by L761 , L770;
thus L772: thesis by L771 , L769 , TARSKI:def 1;
end;

let R1 being set;
assume L773: R1 in { R12 };
L774: R1 = R12 by L773 , TARSKI:def 1;
thus L775: thesis by L774 , L759 , L760;
end;
L776: { R12 } c= R23 by L755 , ZFMISC_1:31;
reconsider D75 = D74 as (Linear_Combination of R23) by L776 , L766 , L495;
consider R19 being (FinSequence of R10) such that L777: (R19 is  one-to-one & ( rng R19 ) = ( Carrier D75 )) and L778: ( Sum ( D75 (#) R19 ) ) = ( Sum D75 ) by L569;
L779: R19 = <* R12 *> by L766 , L777 , FINSEQ_3:97;
L780: ( D75 (#) R19 ) = <* ( ( D75 . R12 ) * R12 ) *> by L779 , L545;
L781: ( Sum D75 ) = ( R17 * R12 ) by L780 , L760 , L778 , RLVECT_1:44;
thus L782: thesis by L781 , L750;
end;
end;
thus L784: thesis by L756;
end;
thus L785: (for R12 being (VECTOR of R10) holds (for R11 being (VECTOR of R10) holds ((R12 in R23 & R11 in R23) implies ( R12 + R11 ) in R23)))
proof
let R12 being (VECTOR of R10);
let R11 being (VECTOR of R10);
assume that
L786: R12 in R23
and
L787: R11 in R23;
L788:
now
per cases ;
suppose L789: R11 = R12;

L790: ( R12 + R11 ) = ( ( 1 * R12 ) + R12 ) by L789 , RLVECT_1:def 8
.= ( ( 1 * R12 ) + ( 1 * R12 ) ) by RLVECT_1:def 8
.= ( ( 1 + 1 ) * R12 ) by RLVECT_1:def 6
.= ( 2 * R12 );
thus L791: thesis by L790 , L754 , L786;
end;
suppose L792: R12 <> R11;

deffunc H5((Element of R10)) = ( 0 );
consider R25 being (Function of (the carrier of R10) , ( REAL )) such that L793: (( R25 . R12 ) = 1 & ( R25 . R11 ) = 1) and L794: (for B93 being (Element of R10) holds ((B93 <> R12 & B93 <> R11) implies ( R25 . B93 ) = H5(B93))) from FUNCT_2:sch 7(L792);
reconsider D76 = R25 as (Element of ( Funcs ((the carrier of R10) , ( REAL )) )) by FUNCT_2:8;
L795:
now
let R16 being (VECTOR of R10);
assume L796: (not R16 in { R12 , R11 });
L797: (R16 <> R12 & R16 <> R11) by L796 , TARSKI:def 2;
thus L798: ( D76 . R16 ) = ( 0 ) by L797 , L794;
end;
reconsider D77 = D76 as (Linear_Combination of R10) by L795 , L428;
L799: ( Carrier D77 ) = { R12 , R11 }
proof
thus L800: ( Carrier D77 ) c= { R12 , R11 }
proof
let R1 being set;
assume L801: R1 in ( Carrier D77 );
L802: (ex R16 being (VECTOR of R10) st (R1 = R16 & ( D77 . R16 ) <> ( 0 ))) by L801;
L803: (R1 = R12 or R1 = R11) by L802 , L794;
thus L804: thesis by L803 , TARSKI:def 2;
end;

let R1 being set;
assume L805: R1 in { R12 , R11 };
L806: (R1 = R12 or R1 = R11) by L805 , TARSKI:def 2;
thus L807: thesis by L806 , L793;
end;
L808: ( Carrier D77 ) c= R23 by L799 , L786 , L787 , ZFMISC_1:32;
L809: (( 1 * R11 ) = R11 & ( 1 * R12 ) = R12) by RLVECT_1:def 8;
reconsider D78 = D77 as (Linear_Combination of R23) by L808 , L495;
consider R19 being (FinSequence of R10) such that L810: (R19 is  one-to-one & ( rng R19 ) = ( Carrier D78 )) and L811: ( Sum ( D78 (#) R19 ) ) = ( Sum D78 ) by L569;
L812: (R19 = <* R12 , R11 *> or R19 = <* R11 , R12 *>) by L792 , L799 , L810 , FINSEQ_3:99;
L813: (( D78 (#) R19 ) = <* ( 1 * R12 ) , ( 1 * R11 ) *> or ( D78 (#) R19 ) = <* ( 1 * R11 ) , ( 1 * R12 ) *>) by L812 , L793 , L551;
L814: ( Sum D78 ) = ( R12 + R11 ) by L813 , L811 , L809 , RLVECT_1:45;
thus L815: thesis by L814 , L750;
end;
end;
thus L817: thesis by L788;
end;

thus L818: thesis by L754;
end;
theorem
L819: (for R10 being RealLinearSpace holds ( Sum ( ZeroLC R10 ) ) = ( 0. R10 )) by L631;
theorem
L820: (for R10 being RealLinearSpace holds (for B94 being (Linear_Combination of ( {} (the carrier of R10) )) holds ( Sum B94 ) = ( 0. R10 )))
proof
let R10 being RealLinearSpace;
let C109 being (Linear_Combination of ( {} (the carrier of R10) ));
L821: C109 = ( ZeroLC R10 ) by L507;
thus L822: thesis by L821 , L631;
end;
theorem
L823: (for R10 being RealLinearSpace holds (for R12 being (VECTOR of R10) holds (for B95 being (Linear_Combination of { R12 }) holds ( Sum B95 ) = ( ( B95 . R12 ) * R12 ))))
proof
let R10 being RealLinearSpace;
let R12 being (VECTOR of R10);
let C110 being (Linear_Combination of { R12 });
L824: ( Carrier C110 ) c= { R12 } by L495;
L825:
now
per cases  by L824 , ZFMISC_1:33;
suppose L826: ( Carrier C110 ) = ( {} );

L827: C110 = ( ZeroLC R10 ) by L826 , L468;
thus L828: ( Sum C110 ) = ( 0. R10 ) by L827 , L631
.= ( ( 0 ) * R12 ) by RLVECT_1:10
.= ( ( C110 . R12 ) * R12 ) by L827 , L492;
end;
suppose L829: ( Carrier C110 ) = { R12 };

consider R19 being (FinSequence of R10) such that L830: (R19 is  one-to-one & ( rng R19 ) = { R12 }) and L831: ( Sum C110 ) = ( Sum ( C110 (#) R19 ) ) by L829 , L569;
L832: R19 = <* R12 *> by L830 , FINSEQ_3:97;
L833: ( C110 (#) R19 ) = <* ( ( C110 . R12 ) * R12 ) *> by L832 , L545;
thus L834: thesis by L833 , L831 , RLVECT_1:44;
end;
end;
thus L836: thesis by L825;
end;
theorem
L837: (for R10 being RealLinearSpace holds (for R13 being (VECTOR of R10) holds (for R14 being (VECTOR of R10) holds (R13 <> R14 implies (for B96 being (Linear_Combination of { R13 , R14 }) holds ( Sum B96 ) = ( ( ( B96 . R13 ) * R13 ) + ( ( B96 . R14 ) * R14 ) ))))))
proof
let R10 being RealLinearSpace;
let R13 being (VECTOR of R10);
let R14 being (VECTOR of R10);
assume L838: R13 <> R14;
let C111 being (Linear_Combination of { R13 , R14 });
L839: ( Carrier C111 ) c= { R13 , R14 } by L495;
L840:
now
per cases  by L839 , ZFMISC_1:36;
suppose L841: ( Carrier C111 ) = ( {} );

L842: C111 = ( ZeroLC R10 ) by L841 , L468;
thus L843: ( Sum C111 ) = ( 0. R10 ) by L842 , L631
.= ( ( 0. R10 ) + ( 0. R10 ) ) by RLVECT_1:4
.= ( ( ( 0 ) * R13 ) + ( 0. R10 ) ) by RLVECT_1:10
.= ( ( ( 0 ) * R13 ) + ( ( 0 ) * R14 ) ) by RLVECT_1:10
.= ( ( ( C111 . R13 ) * R13 ) + ( ( 0 ) * R14 ) ) by L842 , L492
.= ( ( ( C111 . R13 ) * R13 ) + ( ( C111 . R14 ) * R14 ) ) by L842 , L492;
end;
suppose L844: ( Carrier C111 ) = { R13 };

reconsider D79 = C111 as (Linear_Combination of { R13 }) by L844 , L495;
L845: (not R14 in ( Carrier C111 )) by L838 , L844 , TARSKI:def 1;
thus L846: ( Sum C111 ) = ( Sum D79 )
.= ( ( C111 . R13 ) * R13 ) by L823
.= ( ( ( C111 . R13 ) * R13 ) + ( 0. R10 ) ) by RLVECT_1:4
.= ( ( ( C111 . R13 ) * R13 ) + ( ( 0 ) * R14 ) ) by RLVECT_1:10
.= ( ( ( C111 . R13 ) * R13 ) + ( ( C111 . R14 ) * R14 ) ) by L845;
end;
suppose L847: ( Carrier C111 ) = { R14 };

reconsider D80 = C111 as (Linear_Combination of { R14 }) by L847 , L495;
L848: (not R13 in ( Carrier C111 )) by L838 , L847 , TARSKI:def 1;
thus L849: ( Sum C111 ) = ( Sum D80 )
.= ( ( C111 . R14 ) * R14 ) by L823
.= ( ( 0. R10 ) + ( ( C111 . R14 ) * R14 ) ) by RLVECT_1:4
.= ( ( ( 0 ) * R13 ) + ( ( C111 . R14 ) * R14 ) ) by RLVECT_1:10
.= ( ( ( C111 . R13 ) * R13 ) + ( ( C111 . R14 ) * R14 ) ) by L848;
end;
suppose L850: ( Carrier C111 ) = { R13 , R14 };

consider R19 being (FinSequence of R10) such that L851: (R19 is  one-to-one & ( rng R19 ) = { R13 , R14 }) and L852: ( Sum C111 ) = ( Sum ( C111 (#) R19 ) ) by L850 , L569;
L853: (R19 = <* R13 , R14 *> or R19 = <* R14 , R13 *>) by L838 , L851 , FINSEQ_3:99;
L854: (( C111 (#) R19 ) = <* ( ( C111 . R13 ) * R13 ) , ( ( C111 . R14 ) * R14 ) *> or ( C111 (#) R19 ) = <* ( ( C111 . R14 ) * R14 ) , ( ( C111 . R13 ) * R13 ) *>) by L853 , L551;
thus L855: thesis by L854 , L852 , RLVECT_1:45;
end;
end;
thus L857: thesis by L840;
end;
theorem
L858: (for R10 being RealLinearSpace holds (for R27 being (Linear_Combination of R10) holds (( Carrier R27 ) = ( {} ) implies ( Sum R27 ) = ( 0. R10 ))))
proof
let R10 being RealLinearSpace;
let R27 being (Linear_Combination of R10);
assume L859: ( Carrier R27 ) = ( {} );
L860: R27 = ( ZeroLC R10 ) by L859 , L468;
thus L861: thesis by L860 , L631;
end;
theorem
L862: (for R10 being RealLinearSpace holds (for R12 being (VECTOR of R10) holds (for R27 being (Linear_Combination of R10) holds (( Carrier R27 ) = { R12 } implies ( Sum R27 ) = ( ( R27 . R12 ) * R12 )))))
proof
let R10 being RealLinearSpace;
let R12 being (VECTOR of R10);
let R27 being (Linear_Combination of R10);
assume L863: ( Carrier R27 ) = { R12 };
L864: R27 is (Linear_Combination of { R12 }) by L863 , L495;
thus L865: thesis by L864 , L823;
end;
theorem
L866: (for R10 being RealLinearSpace holds (for R13 being (VECTOR of R10) holds (for R14 being (VECTOR of R10) holds (for R27 being (Linear_Combination of R10) holds ((( Carrier R27 ) = { R13 , R14 } & R13 <> R14) implies ( Sum R27 ) = ( ( ( R27 . R13 ) * R13 ) + ( ( R27 . R14 ) * R14 ) ))))))
proof
let R10 being RealLinearSpace;
let R13 being (VECTOR of R10);
let R14 being (VECTOR of R10);
let R27 being (Linear_Combination of R10);
assume that
L867: ( Carrier R27 ) = { R13 , R14 }
and
L868: R13 <> R14;
L869: R27 is (Linear_Combination of { R13 , R14 }) by L867 , L495;
thus L870: thesis by L869 , L868 , L837;
end;
definition
let C112 being non  empty addLoopStr;
let C113 , C114 being (Linear_Combination of C112);
redefine pred C113 = C114
means
(for B97 being (Element of C112) holds ( C113 . B97 ) = ( C114 . B97 ))
;compatibility by FUNCT_2:63;
end;
definition
let C115 being non  empty addLoopStr;
let C116 , C117 being (Linear_Combination of C115);
redefine func C116 + C117 -> (Linear_Combination of C115) means 
:L872: (for B98 being (Element of C115) holds ( it . B98 ) = ( ( C116 . B98 ) + ( C117 . B98 ) ));
coherence
proof
reconsider D81 = ( C116 + C117 ) as (Element of ( Funcs ((the carrier of C115) , ( REAL )) )) by FUNCT_2:8;
L873:
now
let C118 being (Element of C115);
assume L874: (not C118 in ( ( Carrier C116 ) \/ ( Carrier C117 ) ));
L875: (not C118 in ( Carrier C117 )) by L874 , XBOOLE_0:def 3;
L876: ( C117 . C118 ) = ( 0 ) by L875;
L877: (not C118 in ( Carrier C116 )) by L874 , XBOOLE_0:def 3;
L878: ( C116 . C118 ) = ( 0 ) by L877;
thus L879: ( D81 . C118 ) = ( ( 0 ) + ( 0 ) ) by L878 , L876 , VALUED_1:1
.= ( 0 );
end;
thus L880: thesis by L873 , L428;
end;
compatibility
proof
let C119 being (Linear_Combination of C115);
thus L881: (C119 = ( C116 + C117 ) implies (for B99 being (Element of C115) holds ( C119 . B99 ) = ( ( C116 . B99 ) + ( C117 . B99 ) ))) by VALUED_1:1;
assume L882: (for B100 being (Element of C115) holds ( C119 . B100 ) = ( ( C116 . B100 ) + ( C117 . B100 ) ));
thus L883: C119 = ( C116 + C117 )
proof
let C120 being (Element of (the carrier of C115));
thus L884: ( C119 . C120 ) = ( ( C116 . C120 ) + ( C117 . C120 ) ) by L882
.= ( ( C116 + C117 ) . C120 ) by VALUED_1:1;
end;

end;
end;
theorem
L885: (for R10 being RealLinearSpace holds (for R28 being (Linear_Combination of R10) holds (for R29 being (Linear_Combination of R10) holds ( Carrier ( R28 + R29 ) ) c= ( ( Carrier R28 ) \/ ( Carrier R29 ) ))))
proof
let R10 being RealLinearSpace;
let R28 being (Linear_Combination of R10);
let R29 being (Linear_Combination of R10);
let R1 being set;
assume L886: R1 in ( Carrier ( R28 + R29 ) );
consider R11 being (VECTOR of R10) such that L887: R1 = R11 and L888: ( ( R28 + R29 ) . R11 ) <> ( 0 ) by L886;
L889: ( ( R28 + R29 ) . R11 ) = ( ( R28 . R11 ) + ( R29 . R11 ) ) by L872;
L890: (( R28 . R11 ) <> ( 0 ) or ( R29 . R11 ) <> ( 0 )) by L889 , L888;
L891: (R1 in { R13 where R13 is (VECTOR of R10) : ( R28 . R13 ) <> ( 0 ) } or R1 in { R14 where R14 is (VECTOR of R10) : ( R29 . R14 ) <> ( 0 ) }) by L890 , L887;
thus L892: thesis by L891 , XBOOLE_0:def 3;
end;
theorem
L893: (for R10 being RealLinearSpace holds (for R23 being (Subset of R10) holds (for R28 being (Linear_Combination of R10) holds (for R29 being (Linear_Combination of R10) holds ((R28 is (Linear_Combination of R23) & R29 is (Linear_Combination of R23)) implies ( R28 + R29 ) is (Linear_Combination of R23))))))
proof
let R10 being RealLinearSpace;
let R23 being (Subset of R10);
let R28 being (Linear_Combination of R10);
let R29 being (Linear_Combination of R10);
assume L894: (R28 is (Linear_Combination of R23) & R29 is (Linear_Combination of R23));
L895: (( Carrier R28 ) c= R23 & ( Carrier R29 ) c= R23) by L894 , L495;
L896: ( ( Carrier R28 ) \/ ( Carrier R29 ) ) c= R23 by L895 , XBOOLE_1:8;
L897: ( Carrier ( R28 + R29 ) ) c= ( ( Carrier R28 ) \/ ( Carrier R29 ) ) by L885;
thus L898: ( Carrier ( R28 + R29 ) ) c= R23 by L897 , L896 , XBOOLE_1:1;
end;
theorem
L899: (for B101 being non  empty addLoopStr holds (for B102 , B103 being (Linear_Combination of B101) holds ( B102 + B103 ) = ( B103 + B102 )));
theorem
L900: (for R10 being RealLinearSpace holds (for R28 being (Linear_Combination of R10) holds (for R29 being (Linear_Combination of R10) holds (for R30 being (Linear_Combination of R10) holds ( R28 + ( R29 + R30 ) ) = ( ( R28 + R29 ) + R30 )))))
proof
let R10 being RealLinearSpace;
let R28 being (Linear_Combination of R10);
let R29 being (Linear_Combination of R10);
let R30 being (Linear_Combination of R10);
let R12 being (VECTOR of R10);
thus L901: ( ( R28 + ( R29 + R30 ) ) . R12 ) = ( ( R28 . R12 ) + ( ( R29 + R30 ) . R12 ) ) by L872
.= ( ( R28 . R12 ) + ( ( R29 . R12 ) + ( R30 . R12 ) ) ) by L872
.= ( ( ( R28 . R12 ) + ( R29 . R12 ) ) + ( R30 . R12 ) )
.= ( ( ( R28 + R29 ) . R12 ) + ( R30 . R12 ) ) by L872
.= ( ( ( R28 + R29 ) + R30 ) . R12 ) by L872;
end;
theorem
L902: (for R10 being RealLinearSpace holds (for R27 being (Linear_Combination of R10) holds (( R27 + ( ZeroLC R10 ) ) = R27 & ( ( ZeroLC R10 ) + R27 ) = R27)))
proof
let R10 being RealLinearSpace;
let R27 being (Linear_Combination of R10);
thus L903: ( R27 + ( ZeroLC R10 ) ) = R27
proof
let R12 being (VECTOR of R10);
thus L904: ( ( R27 + ( ZeroLC R10 ) ) . R12 ) = ( ( R27 . R12 ) + ( ( ZeroLC R10 ) . R12 ) ) by L872
.= ( ( R27 . R12 ) + ( 0 ) ) by L492
.= ( R27 . R12 );
end;

thus L905: thesis by L903;
end;
definition
let R10 being RealLinearSpace;
let R17 being Real;
let R27 being (Linear_Combination of R10);
func R17 * R27 -> (Linear_Combination of R10) means 
:L906: (for R12 being (VECTOR of R10) holds ( it . R12 ) = ( R17 * ( R27 . R12 ) ));
existence
proof
deffunc H6((Element of R10)) = ( R17 * ( R27 . $1 ) );
consider C121 being (Function of (the carrier of R10) , ( REAL )) such that L907: (for B104 being (Element of R10) holds ( C121 . B104 ) = H6(B104)) from FUNCT_2:sch 4;
reconsider D82 = C121 as (Element of ( Funcs ((the carrier of R10) , ( REAL )) )) by FUNCT_2:8;
L908:
now
let R12 being (VECTOR of R10);
assume L909: (not R12 in ( Carrier R27 ));
L910: ( R27 . R12 ) = ( 0 ) by L909;
thus L911: ( D82 . R12 ) = ( R17 * ( 0 ) ) by L910 , L907
.= ( 0 );
end;
reconsider D83 = D82 as (Linear_Combination of R10) by L908 , L428;
take D83;
let R12 being (VECTOR of R10);
thus L912: thesis by L907;
end;
uniqueness
proof
let R28 being (Linear_Combination of R10);
let R29 being (Linear_Combination of R10);
assume L913: (for R12 being (VECTOR of R10) holds ( R28 . R12 ) = ( R17 * ( R27 . R12 ) ));
assume L914: (for R12 being (VECTOR of R10) holds ( R29 . R12 ) = ( R17 * ( R27 . R12 ) ));
let R12 being (VECTOR of R10);
thus L915: ( R28 . R12 ) = ( R17 * ( R27 . R12 ) ) by L913
.= ( R29 . R12 ) by L914;
end;
end;
theorem
L917: (for R10 being RealLinearSpace holds (for R17 being Real holds (for R27 being (Linear_Combination of R10) holds (R17 <> ( 0 ) implies ( Carrier ( R17 * R27 ) ) = ( Carrier R27 )))))
proof
let R10 being RealLinearSpace;
let R17 being Real;
let R27 being (Linear_Combination of R10);
set D84 = { R11 where R11 is (VECTOR of R10) : ( ( R17 * R27 ) . R11 ) <> ( 0 ) };
set D85 = { R12 where R12 is (VECTOR of R10) : ( R27 . R12 ) <> ( 0 ) };
assume L918: R17 <> ( 0 );
L919: D84 = D85
proof
thus L920: D84 c= D85
proof
let R1 being set;
assume L921: R1 in D84;
consider R11 being (VECTOR of R10) such that L922: R1 = R11 and L923: ( ( R17 * R27 ) . R11 ) <> ( 0 ) by L921;
L924: ( ( R17 * R27 ) . R11 ) = ( R17 * ( R27 . R11 ) ) by L906;
L925: ( R27 . R11 ) <> ( 0 ) by L924 , L923;
thus L926: thesis by L925 , L922;
end;

let R1 being set;
assume L927: R1 in D85;
consider R12 being (VECTOR of R10) such that L928: R1 = R12 and L929: ( R27 . R12 ) <> ( 0 ) by L927;
L930: ( ( R17 * R27 ) . R12 ) = ( R17 * ( R27 . R12 ) ) by L906;
L931: ( ( R17 * R27 ) . R12 ) <> ( 0 ) by L930 , L918 , L929 , XCMPLX_1:6;
thus L932: thesis by L931 , L928;
end;
thus L933: thesis by L919;
end;
theorem
L934: (for R10 being RealLinearSpace holds (for R27 being (Linear_Combination of R10) holds ( ( 0 ) * R27 ) = ( ZeroLC R10 )))
proof
let R10 being RealLinearSpace;
let R27 being (Linear_Combination of R10);
let R12 being (VECTOR of R10);
thus L935: ( ( ( 0 ) * R27 ) . R12 ) = ( ( 0 ) * ( R27 . R12 ) ) by L906
.= ( ( ZeroLC R10 ) . R12 ) by L492;
end;
theorem
L936: (for R10 being RealLinearSpace holds (for R17 being Real holds (for R23 being (Subset of R10) holds (for R27 being (Linear_Combination of R10) holds (R27 is (Linear_Combination of R23) implies ( R17 * R27 ) is (Linear_Combination of R23))))))
proof
let R10 being RealLinearSpace;
let R17 being Real;
let R23 being (Subset of R10);
let R27 being (Linear_Combination of R10);
assume L937: R27 is (Linear_Combination of R23);
L938:
now
per cases ;
suppose L939: R17 = ( 0 );

L940: ( R17 * R27 ) = ( ZeroLC R10 ) by L939 , L934;
thus L941: thesis by L940 , L504;
end;
suppose L942: R17 <> ( 0 );

L943: ( Carrier ( R17 * R27 ) ) = ( Carrier R27 ) by L942 , L917;
thus L944: thesis by L943 , L937 , L495;
end;
end;
thus L946: thesis by L938;
end;
theorem
L947: (for R10 being RealLinearSpace holds (for R17 being Real holds (for R18 being Real holds (for R27 being (Linear_Combination of R10) holds ( ( R17 + R18 ) * R27 ) = ( ( R17 * R27 ) + ( R18 * R27 ) )))))
proof
let R10 being RealLinearSpace;
let R17 being Real;
let R18 being Real;
let R27 being (Linear_Combination of R10);
let R12 being (VECTOR of R10);
thus L948: ( ( ( R17 + R18 ) * R27 ) . R12 ) = ( ( R17 + R18 ) * ( R27 . R12 ) ) by L906
.= ( ( R17 * ( R27 . R12 ) ) + ( R18 * ( R27 . R12 ) ) )
.= ( ( ( R17 * R27 ) . R12 ) + ( R18 * ( R27 . R12 ) ) ) by L906
.= ( ( ( R17 * R27 ) . R12 ) + ( ( R18 * R27 ) . R12 ) ) by L906
.= ( ( ( R17 * R27 ) + ( R18 * R27 ) ) . R12 ) by L872;
end;
theorem
L949: (for R10 being RealLinearSpace holds (for R17 being Real holds (for R28 being (Linear_Combination of R10) holds (for R29 being (Linear_Combination of R10) holds ( R17 * ( R28 + R29 ) ) = ( ( R17 * R28 ) + ( R17 * R29 ) )))))
proof
let R10 being RealLinearSpace;
let R17 being Real;
let R28 being (Linear_Combination of R10);
let R29 being (Linear_Combination of R10);
let R12 being (VECTOR of R10);
thus L950: ( ( R17 * ( R28 + R29 ) ) . R12 ) = ( R17 * ( ( R28 + R29 ) . R12 ) ) by L906
.= ( R17 * ( ( R28 . R12 ) + ( R29 . R12 ) ) ) by L872
.= ( ( R17 * ( R28 . R12 ) ) + ( R17 * ( R29 . R12 ) ) )
.= ( ( ( R17 * R28 ) . R12 ) + ( R17 * ( R29 . R12 ) ) ) by L906
.= ( ( ( R17 * R28 ) . R12 ) + ( ( R17 * R29 ) . R12 ) ) by L906
.= ( ( ( R17 * R28 ) + ( R17 * R29 ) ) . R12 ) by L872;
end;
theorem
L951: (for R10 being RealLinearSpace holds (for R17 being Real holds (for R18 being Real holds (for R27 being (Linear_Combination of R10) holds ( R17 * ( R18 * R27 ) ) = ( ( R17 * R18 ) * R27 )))))
proof
let R10 being RealLinearSpace;
let R17 being Real;
let R18 being Real;
let R27 being (Linear_Combination of R10);
let R12 being (VECTOR of R10);
thus L952: ( ( R17 * ( R18 * R27 ) ) . R12 ) = ( R17 * ( ( R18 * R27 ) . R12 ) ) by L906
.= ( R17 * ( R18 * ( R27 . R12 ) ) ) by L906
.= ( ( R17 * R18 ) * ( R27 . R12 ) )
.= ( ( ( R17 * R18 ) * R27 ) . R12 ) by L906;
end;
theorem
L953: (for R10 being RealLinearSpace holds (for R27 being (Linear_Combination of R10) holds ( 1 * R27 ) = R27))
proof
let R10 being RealLinearSpace;
let R27 being (Linear_Combination of R10);
let R12 being (VECTOR of R10);
thus L954: ( ( 1 * R27 ) . R12 ) = ( 1 * ( R27 . R12 ) ) by L906
.= ( R27 . R12 );
end;
definition
let R10 being RealLinearSpace;
let R27 being (Linear_Combination of R10);
func - R27 -> (Linear_Combination of R10) equals 
( ( - 1 ) * R27 );
correctness;
end;
theorem
L956: (for R10 being RealLinearSpace holds (for R12 being (VECTOR of R10) holds (for R27 being (Linear_Combination of R10) holds ( ( - R27 ) . R12 ) = ( - ( R27 . R12 ) ))))
proof
let R10 being RealLinearSpace;
let R12 being (VECTOR of R10);
let R27 being (Linear_Combination of R10);
thus L957: ( ( - R27 ) . R12 ) = ( ( - 1 ) * ( R27 . R12 ) ) by L906
.= ( - ( R27 . R12 ) );
end;
theorem
L958: (for R10 being RealLinearSpace holds (for R28 being (Linear_Combination of R10) holds (for R29 being (Linear_Combination of R10) holds (( R28 + R29 ) = ( ZeroLC R10 ) implies R29 = ( - R28 )))))
proof
let R10 being RealLinearSpace;
let R28 being (Linear_Combination of R10);
let R29 being (Linear_Combination of R10);
assume L959: ( R28 + R29 ) = ( ZeroLC R10 );
let R12 being (VECTOR of R10);
L960: ( ( R28 . R12 ) + ( R29 . R12 ) ) = ( ( ZeroLC R10 ) . R12 ) by L959 , L872
.= ( 0 ) by L492;
thus L961: ( R29 . R12 ) = ( - ( R28 . R12 ) ) by L960
.= ( ( - R28 ) . R12 ) by L956;
end;
theorem
L962: (for R10 being RealLinearSpace holds (for R27 being (Linear_Combination of R10) holds ( Carrier ( - R27 ) ) = ( Carrier R27 ))) by L917;
theorem
L963: (for R10 being RealLinearSpace holds (for R23 being (Subset of R10) holds (for R27 being (Linear_Combination of R10) holds (R27 is (Linear_Combination of R23) implies ( - R27 ) is (Linear_Combination of R23))))) by L936;
theorem
L964: (for R10 being RealLinearSpace holds (for R27 being (Linear_Combination of R10) holds ( - ( - R27 ) ) = R27))
proof
let R10 being RealLinearSpace;
let R27 being (Linear_Combination of R10);
let R12 being (VECTOR of R10);
thus L965: ( ( - ( - R27 ) ) . R12 ) = ( ( ( ( - 1 ) * ( - 1 ) ) * R27 ) . R12 ) by L951
.= ( 1 * ( R27 . R12 ) ) by L906
.= ( R27 . R12 );
end;
definition
let R10 being RealLinearSpace;
let R28 being (Linear_Combination of R10);
let R29 being (Linear_Combination of R10);
func R28 - R29 -> (Linear_Combination of R10) equals 
( R28 + ( - R29 ) );
correctness;
end;
theorem
L967: (for R10 being RealLinearSpace holds (for R12 being (VECTOR of R10) holds (for R28 being (Linear_Combination of R10) holds (for R29 being (Linear_Combination of R10) holds ( ( R28 - R29 ) . R12 ) = ( ( R28 . R12 ) - ( R29 . R12 ) )))))
proof
let R10 being RealLinearSpace;
let R12 being (VECTOR of R10);
let R28 being (Linear_Combination of R10);
let R29 being (Linear_Combination of R10);
thus L968: ( ( R28 - R29 ) . R12 ) = ( ( R28 . R12 ) + ( ( - R29 ) . R12 ) ) by L872
.= ( ( R28 . R12 ) + ( - ( R29 . R12 ) ) ) by L956
.= ( ( R28 . R12 ) - ( R29 . R12 ) );
end;
theorem
L969: (for R10 being RealLinearSpace holds (for R28 being (Linear_Combination of R10) holds (for R29 being (Linear_Combination of R10) holds ( Carrier ( R28 - R29 ) ) c= ( ( Carrier R28 ) \/ ( Carrier R29 ) ))))
proof
let R10 being RealLinearSpace;
let R28 being (Linear_Combination of R10);
let R29 being (Linear_Combination of R10);
L970: ( Carrier ( R28 - R29 ) ) c= ( ( Carrier R28 ) \/ ( Carrier ( - R29 ) ) ) by L885;
thus L971: thesis by L970 , L917;
end;
theorem
L972: (for R10 being RealLinearSpace holds (for R23 being (Subset of R10) holds (for R28 being (Linear_Combination of R10) holds (for R29 being (Linear_Combination of R10) holds ((R28 is (Linear_Combination of R23) & R29 is (Linear_Combination of R23)) implies ( R28 - R29 ) is (Linear_Combination of R23))))))
proof
let R10 being RealLinearSpace;
let R23 being (Subset of R10);
let R28 being (Linear_Combination of R10);
let R29 being (Linear_Combination of R10);
assume that
L973: R28 is (Linear_Combination of R23)
and
L974: R29 is (Linear_Combination of R23);
L975: ( - R29 ) is (Linear_Combination of R23) by L974 , L936;
thus L976: thesis by L975 , L973 , L893;
end;
theorem
L977: (for R10 being RealLinearSpace holds (for R27 being (Linear_Combination of R10) holds ( R27 - R27 ) = ( ZeroLC R10 )))
proof
let R10 being RealLinearSpace;
let R27 being (Linear_Combination of R10);
let R12 being (VECTOR of R10);
thus L978: ( ( R27 - R27 ) . R12 ) = ( ( R27 . R12 ) - ( R27 . R12 ) ) by L967
.= ( ( ZeroLC R10 ) . R12 ) by L492;
end;
definition
let R10 being RealLinearSpace;
func LinComb R10 -> set means 
:L979: (for R1 being set holds (R1 in it iff R1 is (Linear_Combination of R10)));
existence
proof
defpred S7[ set ] means $1 is (Linear_Combination of R10);
consider C122 being set such that L980: (for R1 being set holds (R1 in C122 iff (R1 in ( Funcs ((the carrier of R10) , ( REAL )) ) & S7[ R1 ]))) from XBOOLE_0:sch 1;
take C122;
let R1 being set;
thus L981: (R1 in C122 implies R1 is (Linear_Combination of R10)) by L980;
assume L982: R1 is (Linear_Combination of R10);
thus L983: thesis by L982 , L980;
end;
uniqueness
proof
let C123 , C124 being set;
assume L984: (for R1 being set holds (R1 in C123 iff R1 is (Linear_Combination of R10)));
assume L985: (for R1 being set holds (R1 in C124 iff R1 is (Linear_Combination of R10)));
thus L986: C123 c= C124
proof
let R1 being set;
assume L987: R1 in C123;
L988: R1 is (Linear_Combination of R10) by L987 , L984;
thus L989: thesis by L988 , L985;
end;

let R1 being set;
assume L990: R1 in C124;
L991: R1 is (Linear_Combination of R10) by L990 , L985;
thus L992: thesis by L991 , L984;
end;
end;
registration
let R10 being RealLinearSpace;
cluster ( LinComb R10 ) -> non  empty;
coherence
proof
set D86 = the (Linear_Combination of R10);
L994: D86 in ( LinComb R10 ) by L979;
thus L995: thesis by L994;
end;
end;
definition
let R10 being RealLinearSpace;
let R34 being (Element of ( LinComb R10 ));
func @ R34 -> (Linear_Combination of R10) equals 
R34;
coherence by L979;
end;
definition
let R10 being RealLinearSpace;
let R27 being (Linear_Combination of R10);
func @ R27 -> (Element of ( LinComb R10 )) equals 
R27;
coherence by L979;
end;
definition
let R10 being RealLinearSpace;
func LCAdd R10 -> (BinOp of ( LinComb R10 )) means 
:L999: (for R35 being (Element of ( LinComb R10 )) holds (for R36 being (Element of ( LinComb R10 )) holds ( it . (R35 , R36) ) = ( ( @ R35 ) + ( @ R36 ) )));
existence
proof
deffunc H7((Element of ( LinComb R10 )) , (Element of ( LinComb R10 ))) = ( @ ( ( @ $1 ) + ( @ $2 ) ) );
consider C125 being (BinOp of ( LinComb R10 )) such that L1000: (for R35 being (Element of ( LinComb R10 )) holds (for R36 being (Element of ( LinComb R10 )) holds ( C125 . (R35 , R36) ) = H7(R35 , R36))) from BINOP_1:sch 4;
take C125;
let R35 being (Element of ( LinComb R10 ));
let R36 being (Element of ( LinComb R10 ));
thus L1001: ( C125 . (R35 , R36) ) = ( @ ( ( @ R35 ) + ( @ R36 ) ) ) by L1000
.= ( ( @ R35 ) + ( @ R36 ) );
end;
uniqueness
proof
let C126 , C127 being (BinOp of ( LinComb R10 ));
assume L1002: (for R35 being (Element of ( LinComb R10 )) holds (for R36 being (Element of ( LinComb R10 )) holds ( C126 . (R35 , R36) ) = ( ( @ R35 ) + ( @ R36 ) )));
assume L1003: (for R35 being (Element of ( LinComb R10 )) holds (for R36 being (Element of ( LinComb R10 )) holds ( C127 . (R35 , R36) ) = ( ( @ R35 ) + ( @ R36 ) )));
L1004:
now
let R35 being (Element of ( LinComb R10 ));
let R36 being (Element of ( LinComb R10 ));
thus L1005: ( C126 . (R35 , R36) ) = ( ( @ R35 ) + ( @ R36 ) ) by L1002
.= ( C127 . (R35 , R36) ) by L1003;
end;
thus L1006: thesis by L1004 , BINOP_1:2;
end;
end;
definition
let R10 being RealLinearSpace;
func LCMult R10 -> (Function of [: ( REAL ) , ( LinComb R10 ) :] , ( LinComb R10 )) means 
:L1008: (for R17 being Real holds (for R34 being (Element of ( LinComb R10 )) holds ( it . [ R17 , R34 ] ) = ( R17 * ( @ R34 ) )));
existence
proof
defpred S8[ (Element of ( REAL )) , (Element of ( LinComb R10 )) , set ] means (ex R17 being Real st (R17 = $1 & $3 = ( R17 * ( @ $2 ) )));
L1009: (for B105 being (Element of ( REAL )) holds (for R35 being (Element of ( LinComb R10 )) holds (ex R36 being (Element of ( LinComb R10 )) st S8[ B105 , R35 , R36 ])))
proof
let C128 being (Element of ( REAL ));
let R35 being (Element of ( LinComb R10 ));
take ( @ ( C128 * ( @ R35 ) ) );
take C128;
thus L1010: thesis;
end;
consider C129 being (Function of [: ( REAL ) , ( LinComb R10 ) :] , ( LinComb R10 )) such that L1011: (for B106 being (Element of ( REAL )) holds (for R34 being (Element of ( LinComb R10 )) holds S8[ B106 , R34 , ( C129 . (B106 , R34) ) ])) from BINOP_1:sch 3(L1009);
take C129;
let R17 being Real;
let R34 being (Element of ( LinComb R10 ));
L1012: (ex R18 being Real st (R18 = R17 & ( C129 . (R17 , R34) ) = ( R18 * ( @ R34 ) ))) by L1011;
thus L1013: thesis by L1012;
end;
uniqueness
proof
let C130 , C131 being (Function of [: ( REAL ) , ( LinComb R10 ) :] , ( LinComb R10 ));
assume L1014: (for R17 being Real holds (for R34 being (Element of ( LinComb R10 )) holds ( C130 . [ R17 , R34 ] ) = ( R17 * ( @ R34 ) )));
assume L1015: (for R17 being Real holds (for R34 being (Element of ( LinComb R10 )) holds ( C131 . [ R17 , R34 ] ) = ( R17 * ( @ R34 ) )));
L1016:
now
let C132 being (Element of ( REAL ));
let R34 being (Element of ( LinComb R10 ));
thus L1017: ( C130 . (C132 , R34) ) = ( C132 * ( @ R34 ) ) by L1014
.= ( C131 . (C132 , R34) ) by L1015;
end;
thus L1018: thesis by L1016 , BINOP_1:2;
end;
end;
definition
let R10 being RealLinearSpace;
func LC_RLSpace R10 -> RLSStruct equals 
RLSStruct (# ( LinComb R10 ) , ( @ ( ZeroLC R10 ) ) , ( LCAdd R10 ) , ( LCMult R10 ) #);
coherence;
end;
registration
let R10 being RealLinearSpace;
cluster ( LC_RLSpace R10 ) ->  strict non  empty;
coherence;
end;
registration
let R10 being RealLinearSpace;
cluster ( LC_RLSpace R10 ) ->  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital;
coherence
proof
set D87 = ( LC_RLSpace R10 );
L1022:
now
let C133 , C134 being (VECTOR of D87);
let R26 being (Linear_Combination of R10);
let R27 being (Linear_Combination of R10);
L1023: (( @ ( @ R26 ) ) = R26 & ( @ ( @ R27 ) ) = R27);
assume L1024: (C133 = R26 & C134 = R27);
thus L1025: ( C133 + C134 ) = ( R26 + R27 ) by L1024 , L1023 , L999;
end;
thus L1026: D87 is  Abelian
proof
let C135 , C136 being (Element of D87);
reconsider D88 = C135 , D89 = C136 as (Linear_Combination of R10) by L979;
thus L1027: ( C135 + C136 ) = ( D89 + D88 ) by L1022
.= ( C136 + C135 ) by L1022;
end;

thus L1028: D87 is  add-associative
proof
let C137 , C138 , C139 being (Element of D87);
reconsider D90 = C137 , D91 = C138 , D92 = C139 as (Linear_Combination of R10) by L979;
L1029: ( C138 + C139 ) = ( D91 + D92 ) by L1022;
L1030: ( C137 + C138 ) = ( D90 + D91 ) by L1022;
thus L1031: ( ( C137 + C138 ) + C139 ) = ( ( D90 + D91 ) + D92 ) by L1030 , L1022
.= ( D90 + ( D91 + D92 ) ) by L900
.= ( C137 + ( C138 + C139 ) ) by L1022 , L1029;
end;

thus L1032: D87 is  right_zeroed
proof
let C140 being (Element of D87);
reconsider D93 = C140 as (Linear_Combination of R10) by L979;
thus L1033: ( C140 + ( 0. D87 ) ) = ( D93 + ( ZeroLC R10 ) ) by L1022
.= C140 by L902;
end;

thus L1034: D87 is  right_complementable
proof
let C141 being (Element of D87);
reconsider D94 = C141 as (Linear_Combination of R10) by L979;
L1035: ( - D94 ) in (the carrier of D87) by L979;
L1036: ( - D94 ) in D87 by L1035 , STRUCT_0:def 5;
L1037: ( - D94 ) = ( vector (D87 , ( - D94 )) ) by L1036 , L2;
L1038: ( C141 + ( vector (D87 , ( - D94 )) ) ) = ( D94 - D94 ) by L1037 , L1022
.= ( 0. D87 ) by L977;
thus L1039: (ex B107 being (VECTOR of D87) st ( C141 + B107 ) = ( 0. D87 )) by L1038;
end;

L1040:
now
let C142 being (VECTOR of D87);
let R27 being (Linear_Combination of R10);
let R17 being Real;
L1041: ( @ ( @ R27 ) ) = R27;
assume L1042: C142 = R27;
thus L1043: ( R17 * C142 ) = ( R17 * R27 ) by L1042 , L1041 , L1008;
end;
thus L1044: (for B108 being  real number holds (for B109 , B110 being (VECTOR of D87) holds ( B108 * ( B109 + B110 ) ) = ( ( B108 * B109 ) + ( B108 * B110 ) )))
proof
let C143 being  real number;
let C144 , C145 being (VECTOR of D87);
reconsider D95 = C144 , D96 = C145 as (Linear_Combination of R10) by L979;
reconsider D97 = C143 as Real by XREAL_0:def 1;
L1045: (( D97 * C144 ) = ( D97 * D95 ) & ( D97 * C145 ) = ( D97 * D96 )) by L1040;
L1046: ( C144 + C145 ) = ( D95 + D96 ) by L1022;
L1047: ( D97 * ( C144 + C145 ) ) = ( D97 * ( D95 + D96 ) ) by L1046 , L1040
.= ( ( D97 * D95 ) + ( D97 * D96 ) ) by L949
.= ( ( D97 * C144 ) + ( D97 * C145 ) ) by L1022 , L1045;
thus L1048: thesis by L1047;
end;

thus L1049: (for B111 , B112 being  real number holds (for B113 being (VECTOR of D87) holds ( ( B111 + B112 ) * B113 ) = ( ( B111 * B113 ) + ( B112 * B113 ) )))
proof
let C146 , C147 being  real number;
let C148 being (VECTOR of D87);
reconsider D98 = C148 as (Linear_Combination of R10) by L979;
reconsider D99 = C146 , D100 = C147 as Real by XREAL_0:def 1;
L1050: (( D99 * C148 ) = ( D99 * D98 ) & ( D100 * C148 ) = ( D100 * D98 )) by L1040;
L1051: ( ( D99 + D100 ) * C148 ) = ( ( D99 + D100 ) * D98 ) by L1040
.= ( ( D99 * D98 ) + ( D100 * D98 ) ) by L947
.= ( ( D99 * C148 ) + ( D100 * C148 ) ) by L1022 , L1050;
thus L1052: thesis by L1051;
end;

thus L1053: (for B114 , B115 being  real number holds (for B116 being (VECTOR of D87) holds ( ( B114 * B115 ) * B116 ) = ( B114 * ( B115 * B116 ) )))
proof
let C149 , C150 being  real number;
let C151 being (VECTOR of D87);
reconsider D101 = C151 as (Linear_Combination of R10) by L979;
reconsider D102 = C149 , D103 = C150 as Real by XREAL_0:def 1;
L1054: ( D103 * C151 ) = ( D103 * D101 ) by L1040;
L1055: ( ( D102 * D103 ) * C151 ) = ( ( D102 * D103 ) * D101 ) by L1040
.= ( D102 * ( D103 * D101 ) ) by L951
.= ( D102 * ( D103 * C151 ) ) by L1040 , L1054;
thus L1056: thesis by L1055;
end;

let C152 being (VECTOR of D87);
reconsider D104 = C152 as (Linear_Combination of R10) by L979;
thus L1057: ( 1 * C152 ) = ( 1 * D104 ) by L1040
.= C152 by L953;
end;
end;
theorem
L1059: (for R10 being RealLinearSpace holds (the carrier of ( LC_RLSpace R10 )) = ( LinComb R10 ));
theorem
L1060: (for R10 being RealLinearSpace holds ( 0. ( LC_RLSpace R10 ) ) = ( ZeroLC R10 ));
theorem
L1061: (for R10 being RealLinearSpace holds (the addF of ( LC_RLSpace R10 )) = ( LCAdd R10 ));
theorem
L1062: (for R10 being RealLinearSpace holds (the Mult of ( LC_RLSpace R10 )) = ( LCMult R10 ));
theorem
L1063: (for R10 being RealLinearSpace holds (for R28 being (Linear_Combination of R10) holds (for R29 being (Linear_Combination of R10) holds ( ( vector (( LC_RLSpace R10 ) , R28) ) + ( vector (( LC_RLSpace R10 ) , R29) ) ) = ( R28 + R29 ))))
proof
let R10 being RealLinearSpace;
let R28 being (Linear_Combination of R10);
let R29 being (Linear_Combination of R10);
set D105 = ( vector (( LC_RLSpace R10 ) , R29) );
L1064: (R28 = ( @ ( @ R28 ) ) & R29 = ( @ ( @ R29 ) ));
L1065: R29 in (the carrier of ( LC_RLSpace R10 )) by L979;
L1066: R29 in ( LC_RLSpace R10 ) by L1065 , STRUCT_0:def 5;
L1067: R28 in (the carrier of ( LC_RLSpace R10 )) by L979;
L1068: R28 in ( LC_RLSpace R10 ) by L1067 , STRUCT_0:def 5;
thus L1069: ( ( vector (( LC_RLSpace R10 ) , R28) ) + ( vector (( LC_RLSpace R10 ) , R29) ) ) = ( ( LCAdd R10 ) . [ R28 , D105 ] ) by L1068 , L2
.= ( ( LCAdd R10 ) . (( @ R28 ) , ( @ R29 )) ) by L1066 , L2
.= ( R28 + R29 ) by L1064 , L999;
end;
theorem
L1070: (for R10 being RealLinearSpace holds (for R17 being Real holds (for R27 being (Linear_Combination of R10) holds ( R17 * ( vector (( LC_RLSpace R10 ) , R27) ) ) = ( R17 * R27 ))))
proof
let R10 being RealLinearSpace;
let R17 being Real;
let R27 being (Linear_Combination of R10);
L1071: ( @ ( @ R27 ) ) = R27;
L1072: R27 in (the carrier of ( LC_RLSpace R10 )) by L979;
L1073: R27 in ( LC_RLSpace R10 ) by L1072 , STRUCT_0:def 5;
thus L1074: ( R17 * ( vector (( LC_RLSpace R10 ) , R27) ) ) = ( ( LCMult R10 ) . [ R17 , ( @ R27 ) ] ) by L1073 , L2
.= ( R17 * R27 ) by L1071 , L1008;
end;
theorem
L1075: (for R10 being RealLinearSpace holds (for R27 being (Linear_Combination of R10) holds ( - ( vector (( LC_RLSpace R10 ) , R27) ) ) = ( - R27 )))
proof
let R10 being RealLinearSpace;
let R27 being (Linear_Combination of R10);
thus L1076: ( - ( vector (( LC_RLSpace R10 ) , R27) ) ) = ( ( - 1 ) * ( vector (( LC_RLSpace R10 ) , R27) ) ) by RLVECT_1:16
.= ( - R27 ) by L1070;
end;
theorem
L1077: (for R10 being RealLinearSpace holds (for R28 being (Linear_Combination of R10) holds (for R29 being (Linear_Combination of R10) holds ( ( vector (( LC_RLSpace R10 ) , R28) ) - ( vector (( LC_RLSpace R10 ) , R29) ) ) = ( R28 - R29 ))))
proof
let R10 being RealLinearSpace;
let R28 being (Linear_Combination of R10);
let R29 being (Linear_Combination of R10);
L1078: ( - R29 ) in ( LinComb R10 ) by L979;
L1079: ( - R29 ) in ( LC_RLSpace R10 ) by L1078 , STRUCT_0:def 5;
L1080: ( - ( vector (( LC_RLSpace R10 ) , R29) ) ) = ( - R29 ) by L1075
.= ( vector (( LC_RLSpace R10 ) , ( - R29 )) ) by L1079 , L2;
thus L1081: thesis by L1080 , L1063;
end;
definition
let R10 being RealLinearSpace;
let R23 being (Subset of R10);
func LC_RLSpace R23 ->  strict (Subspace of ( LC_RLSpace R10 )) means 
(the carrier of it) = { R31 where R31 is (Linear_Combination of R23) : (not contradiction) };
existence
proof
set D106 = { R31 where R31 is (Linear_Combination of R23) : (not contradiction) };
L1082: D106 c= (the carrier of ( LC_RLSpace R10 ))
proof
let R1 being set;
assume L1083: R1 in D106;
L1084: (ex R31 being (Linear_Combination of R23) st R1 = R31) by L1083;
thus L1085: thesis by L1084 , L979;
end;
reconsider D107 = D106 as (Subset of ( LC_RLSpace R10 )) by L1082;
L1086: D107 is  linearly-closed
proof
thus L1087: (for B117 , B118 being (VECTOR of ( LC_RLSpace R10 )) holds ((B117 in D107 & B118 in D107) implies ( B117 + B118 ) in D107))
proof
let C153 , C154 being (VECTOR of ( LC_RLSpace R10 ));
assume that
L1088: C153 in D107
and
L1089: C154 in D107;
consider R32 being (Linear_Combination of R23) such that L1090: C153 = R32 by L1088;
consider R33 being (Linear_Combination of R23) such that L1091: C154 = R33 by L1089;
L1092: C154 = ( vector (( LC_RLSpace R10 ) , R33) ) by L1091 , L2 , RLVECT_1:1;
L1093: C153 = ( vector (( LC_RLSpace R10 ) , R32) ) by L1090 , L2 , RLVECT_1:1;
L1094: ( C153 + C154 ) = ( R32 + R33 ) by L1093 , L1092 , L1063;
L1095: ( C153 + C154 ) is (Linear_Combination of R23) by L1094 , L893;
thus L1096: thesis by L1095;
end;

let R17 being Real;
let C155 being (VECTOR of ( LC_RLSpace R10 ));
assume L1097: C155 in D107;
consider R31 being (Linear_Combination of R23) such that L1098: C155 = R31 by L1097;
L1099: ( R17 * C155 ) = ( R17 * ( vector (( LC_RLSpace R10 ) , R31) ) ) by L1098 , L2 , RLVECT_1:1
.= ( R17 * R31 ) by L1070;
L1100: ( R17 * C155 ) is (Linear_Combination of R23) by L1099 , L936;
thus L1101: thesis by L1100;
end;
L1102: ( ZeroLC R10 ) is (Linear_Combination of R23) by L504;
L1103: ( ZeroLC R10 ) in D107 by L1102;
thus L1104: thesis by L1103 , L1086 , RLSUB_1:35;
end;
uniqueness by RLSUB_1:30;
end;
theorem
L1106: (for B119 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B120 being (Element of B119) holds (for B121 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B119 holds (for B122 , B123 being (FinSequence of B121) holds ((( len B122 ) = ( len B123 ) & (for R39 being (Element of ( NAT )) holds (for B124 being (Element of B121) holds ((R39 in ( dom B122 ) & B124 = ( B123 . R39 )) implies ( B122 . R39 ) = ( B120 * B124 ))))) implies ( Sum B122 ) = ( B120 * ( Sum B123 ) ))))))
proof
let C156 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C157 being (Element of C156);
let C158 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C156;
let C159 , C160 being (FinSequence of C158);
defpred S9[ (Element of ( NAT )) ] means (for B125 , B126 being (FinSequence of C158) holds ((( len B125 ) = ( len B126 ) & ( len B125 ) = $1 & (for R39 being (Element of ( NAT )) holds (for B127 being (Element of C158) holds ((R39 in ( dom B125 ) & B127 = ( B126 . R39 )) implies ( B125 . R39 ) = ( C157 * B127 ))))) implies ( Sum B125 ) = ( C157 * ( Sum B126 ) )));
L1107: (for R40 being (Element of ( NAT )) holds (S9[ R40 ] implies S9[ ( R40 + 1 ) ]))
proof
let R40 being (Element of ( NAT ));
assume L1108: (for B128 , B129 being (FinSequence of C158) holds ((( len B128 ) = ( len B129 ) & ( len B128 ) = R40 & (for R39 being (Element of ( NAT )) holds (for B130 being (Element of C158) holds ((R39 in ( dom B128 ) & B130 = ( B129 . R39 )) implies ( B128 . R39 ) = ( C157 * B130 ))))) implies ( Sum B128 ) = ( C157 * ( Sum B129 ) )));
let C161 , C162 being (FinSequence of C158);
assume that
L1109: ( len C161 ) = ( len C162 )
and
L1110: ( len C161 ) = ( R40 + 1 )
and
L1111: (for R39 being (Element of ( NAT )) holds (for B131 being (Element of C158) holds ((R39 in ( dom C161 ) & B131 = ( C162 . R39 )) implies ( C161 . R39 ) = ( C157 * B131 ))));
reconsider D108 = ( C161 | ( Seg R40 ) ) , D109 = ( C162 | ( Seg R40 ) ) as (FinSequence of C158) by FINSEQ_1:18;
L1112: R40 <= ( R40 + 1 ) by NAT_1:12;
L1113: D109 = ( C162 | ( dom D109 ) ) by L1112 , L1109 , L1110 , FINSEQ_1:17;
L1114: ( len D108 ) = R40 by L1110 , L1112 , FINSEQ_1:17;
L1115: ( len D109 ) = R40 by L1109 , L1110 , L1112 , FINSEQ_1:17;
L1116:
now
L1117: ( dom D108 ) c= ( dom C161 ) by L1110 , L1112 , L1114 , FINSEQ_3:30;
let R39 being (Element of ( NAT ));
let C163 being (Element of C158);
assume that
L1118: R39 in ( dom D108 )
and
L1119: C163 = ( D109 . R39 );
L1120: ( dom D109 ) = ( dom D108 ) by L1114 , L1115 , FINSEQ_3:29;
L1121: ( C162 . R39 ) = ( D109 . R39 ) by L1120 , L1118 , FUNCT_1:47;
L1122: ( C161 . R39 ) = ( C157 * C163 ) by L1121 , L1111 , L1118 , L1119 , L1117;
thus L1123: ( D108 . R39 ) = ( C157 * C163 ) by L1122 , L1118 , FUNCT_1:47;
end;
L1124: ( R40 + 1 ) in ( Seg ( R40 + 1 ) ) by FINSEQ_1:4;
L1125: ( R40 + 1 ) in ( dom C161 ) by L1124 , L1110 , FINSEQ_1:def 3;
L1126: ( dom C161 ) = ( dom C162 ) by L1109 , FINSEQ_3:29;
reconsider D110 = ( C161 . ( R40 + 1 ) ) , D111 = ( C162 . ( R40 + 1 ) ) as (Element of C158) by L1126 , L1125 , FINSEQ_2:11;
L1127: D110 = ( C157 * D111 ) by L1111 , L1125;
L1128: D108 = ( C161 | ( dom D108 ) ) by L1110 , L1112 , FINSEQ_1:17;
thus L1129: ( Sum C161 ) = ( ( Sum D108 ) + D110 ) by L1128 , L1110 , L1114 , RLVECT_1:38
.= ( ( C157 * ( Sum D109 ) ) + ( C157 * D111 ) ) by L1108 , L1114 , L1115 , L1116 , L1127
.= ( C157 * ( ( Sum D109 ) + D111 ) ) by VECTSP_1:def 14
.= ( C157 * ( Sum C162 ) ) by L1109 , L1110 , L1115 , L1113 , RLVECT_1:38;
end;
L1130: S9[ ( 0 ) ]
proof
let C164 , C165 being (FinSequence of C158);
assume that
L1131: ( len C164 ) = ( len C165 )
and
L1132: ( len C164 ) = ( 0 )
and
L1133: (for R39 being (Element of ( NAT )) holds (for B132 being (Element of C158) holds ((R39 in ( dom C164 ) & B132 = ( C165 . R39 )) implies ( C164 . R39 ) = ( C157 * B132 ))));
L1134: C164 = ( <*> (the carrier of C158) ) by L1132;
L1135: ( Sum C164 ) = ( 0. C158 ) by L1134 , RLVECT_1:43;
L1136: C165 = ( <*> (the carrier of C158) ) by L1131 , L1132;
L1137: ( Sum C165 ) = ( 0. C158 ) by L1136 , RLVECT_1:43;
thus L1138: thesis by L1137 , L1135 , VECTSP_1:14;
end;
L1139: (for R40 being (Element of ( NAT )) holds S9[ R40 ]) from NAT_1:sch 1(L1130 , L1107);
thus L1140: thesis by L1139;
end;
theorem
L1141: (for B133 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B134 being (Element of B133) holds (for B135 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B133 holds (for B136 , B137 being (FinSequence of B135) holds ((( len B136 ) = ( len B137 ) & (for R39 being (Element of ( NAT )) holds (R39 in ( dom B136 ) implies ( B137 . R39 ) = ( B134 * ( B136 /. R39 ) )))) implies ( Sum B137 ) = ( B134 * ( Sum B136 ) ))))))
proof
let C166 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C167 being (Element of C166);
let C168 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C166;
let C169 , C170 being (FinSequence of C168);
assume that
L1142: ( len C169 ) = ( len C170 )
and
L1143: (for R39 being (Element of ( NAT )) holds (R39 in ( dom C169 ) implies ( C170 . R39 ) = ( C167 * ( C169 /. R39 ) )));
L1144:
now
let R39 being (Element of ( NAT ));
let C171 being (Element of C168);
assume that
L1145: R39 in ( dom C170 )
and
L1146: C171 = ( C169 . R39 );
L1147: R39 in ( dom C169 ) by L1142 , L1145 , FINSEQ_3:29;
L1148: C171 = ( C169 /. R39 ) by L1147 , L1146 , PARTFUN1:def 6;
thus L1149: ( C170 . R39 ) = ( C167 * C171 ) by L1148 , L1143 , L1147;
end;
thus L1150: thesis by L1144 , L1142 , L1106;
end;
theorem
L1151: (for B138 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B139 being  Abelian  add-associative  right_zeroed  right_complementable non  empty VectSpStr over B138 holds (for B140 , B141 , B142 being (FinSequence of B139) holds ((( len B140 ) = ( len B141 ) & ( len B140 ) = ( len B142 ) & (for R39 being (Element of ( NAT )) holds (R39 in ( dom B140 ) implies ( B142 . R39 ) = ( ( B140 /. R39 ) - ( B141 /. R39 ) )))) implies ( Sum B142 ) = ( ( Sum B140 ) - ( Sum B141 ) )))))
proof
let C172 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C173 being  Abelian  add-associative  right_zeroed  right_complementable non  empty VectSpStr over C172;
let C174 , C175 , C176 being (FinSequence of C173);
assume that
L1152: ( len C174 ) = ( len C175 )
and
L1153: ( len C174 ) = ( len C176 )
and
L1154: (for R39 being (Element of ( NAT )) holds (R39 in ( dom C174 ) implies ( C176 . R39 ) = ( ( C174 /. R39 ) - ( C175 /. R39 ) )));
deffunc H8(Nat) = ( - ( C175 /. $1 ) );
consider C177 being FinSequence such that L1155: ( len C177 ) = ( len C175 ) and L1156: (for B143 being Nat holds (B143 in ( dom C177 ) implies ( C177 . B143 ) = H8(B143))) from FINSEQ_1:sch 2;
L1157: ( dom C177 ) = ( Seg ( len C175 ) ) by L1155 , FINSEQ_1:def 3;
L1158: (for R39 being (Element of ( NAT )) holds (R39 in ( Seg ( len C175 ) ) implies ( C177 . R39 ) = H8(R39))) by L1157 , L1156;
L1159: ( rng C177 ) c= (the carrier of C173)
proof
let R37 being set;
assume L1160: R37 in ( rng C177 );
consider R38 being set such that L1161: R38 in ( dom C177 ) and L1162: ( C177 . R38 ) = R37 by L1160 , FUNCT_1:def 3;
reconsider D112 = R38 as (Element of ( NAT )) by L1161;
L1163: R37 = ( - ( C175 /. D112 ) ) by L1156 , L1161 , L1162;
reconsider D113 = R37 as (Element of C173) by L1163;
L1164: D113 in C173 by RLVECT_1:1;
thus L1165: thesis by L1164;
end;
reconsider D114 = C177 as (FinSequence of C173) by L1159 , FINSEQ_1:def 4;
L1166: ( Seg ( len C175 ) ) = ( dom C175 ) by FINSEQ_1:def 3;
L1167:
now
let R39 being (Element of ( NAT ));
L1168: ( dom C174 ) = ( dom C175 ) by L1152 , FINSEQ_3:29;
assume L1169: R39 in ( dom C174 );
L1170: R39 in ( dom D114 ) by L1169 , L1152 , L1155 , FINSEQ_3:29;
L1171: ( D114 . R39 ) = ( D114 /. R39 ) by L1170 , PARTFUN1:def 6;
thus L1172: ( C176 . R39 ) = ( ( C174 /. R39 ) - ( C175 /. R39 ) ) by L1154 , L1169
.= ( ( C174 /. R39 ) + ( - ( C175 /. R39 ) ) )
.= ( ( C174 /. R39 ) + ( D114 /. R39 ) ) by L1156 , L1157 , L1166 , L1169 , L1171 , L1168;
end;
L1173: ( Sum C176 ) = ( ( Sum C174 ) + ( Sum D114 ) ) by L1167 , L1152 , L1153 , L1155 , L5;
L1174: ( Sum D114 ) = ( - ( Sum C175 ) ) by L1155 , L1158 , L1166 , L68;
thus L1175: thesis by L1174 , L1173;
end;
theorem
L1176: (for B144 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B145 being (Element of B144) holds (for B146 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B144 holds ( B145 * ( Sum ( <*> (the carrier of B146) ) ) ) = ( 0. B146 ))))
proof
let C178 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C179 being (Element of C178);
let C180 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C178;
thus L1177: ( C179 * ( Sum ( <*> (the carrier of C180) ) ) ) = ( C179 * ( 0. C180 ) ) by RLVECT_1:43
.= ( 0. C180 ) by VECTSP_1:14;
end;
theorem
L1178: (for B147 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B148 being (Element of B147) holds (for B149 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B147 holds (for B150 , B151 being (Element of B149) holds ( B148 * ( Sum <* B150 , B151 *> ) ) = ( ( B148 * B150 ) + ( B148 * B151 ) )))))
proof
let C181 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C182 being (Element of C181);
let C183 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C181;
let C184 , C185 being (Element of C183);
thus L1179: ( C182 * ( Sum <* C184 , C185 *> ) ) = ( C182 * ( C184 + C185 ) ) by RLVECT_1:45
.= ( ( C182 * C184 ) + ( C182 * C185 ) ) by VECTSP_1:def 14;
end;
theorem
L1180: (for B152 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B153 being (Element of B152) holds (for B154 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B152 holds (for B155 , B156 , B157 being (Element of B154) holds ( B153 * ( Sum <* B155 , B156 , B157 *> ) ) = ( ( ( B153 * B155 ) + ( B153 * B156 ) ) + ( B153 * B157 ) )))))
proof
let C186 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C187 being (Element of C186);
let C188 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C186;
let C189 , C190 , C191 being (Element of C188);
thus L1181: ( C187 * ( Sum <* C189 , C190 , C191 *> ) ) = ( C187 * ( ( C189 + C190 ) + C191 ) ) by RLVECT_1:46
.= ( ( C187 * ( C189 + C190 ) ) + ( C187 * C191 ) ) by VECTSP_1:def 14
.= ( ( ( C187 * C189 ) + ( C187 * C190 ) ) + ( C187 * C191 ) ) by VECTSP_1:def 14;
end;
