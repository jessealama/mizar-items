:: Hahn Banach Theorem in the Vector Space over the Field of
:: Complex Numbers
::  by Anna Justyna Milewska
::
:: Received May 23, 2000
:: Copyright (c) 2000-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies RLVECT_1, ALGSTR_0, VECTSP_1, XBOOLE_0, SUBSET_1, RELAT_1,
      ARYTM_1, ARYTM_3, SUPINF_2, XCMPLX_0, ORDINAL1, COMPLEX1, XREAL_0,
      NUMBERS, CARD_1, SQUARE_1, COMPLFLD, GROUP_1, REAL_1, STRUCT_0, HAHNBAN,
      FUNCT_1, FUNCOP_1, MSSUBFAM, UNIALG_1, BINOP_1, LATTICES, MESFUNC1,
      ZFMISC_1, XXREAL_0, RLSUB_1, TARSKI, REALSET1, POWER, HAHNBAN1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, REALSET1, NUMBERS,
      XCMPLX_0, XREAL_0, COMPLEX1, REAL_1, NAT_1, SQUARE_1, POWER, STRUCT_0,
      ALGSTR_0, RLVECT_1, GROUP_1, VECTSP_1, RLSUB_1, VECTSP_4, FUNCT_1,
      FUNCT_2, BINOP_1, RELSET_1, NATTRA_1, FUNCOP_1, HAHNBAN, COMPLFLD,
      XXREAL_0, GRCAT_1;
 constructors REAL_1, SQUARE_1, NAT_1, BINOP_2, POWER, REALSET1, RLSUB_1,
      COMPLFLD, VECTSP_4, NATTRA_1, BORSUK_1, HAHNBAN, SUPINF_1, FUNCOP_1,
      GRCAT_1;
 registrations XBOOLE_0, FUNCT_1, RELSET_1, NUMBERS, XCMPLX_0, XREAL_0,
      MEMBERED, STRUCT_0, RLVECT_1, VECTSP_1, COMPLFLD, HAHNBAN, ALGSTR_0;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, RLSUB_1, HAHNBAN, SQUARE_1, BINOP_1, RLVECT_1, VECTSP_1,
      COMPLEX1, STRUCT_0, ALGSTR_0, GRCAT_1;
 theorems TARSKI, ZFMISC_1, ABSVALUE, FUNCT_1, FUNCT_2, COMPLEX1, COMPLFLD,
      VECTSP_1, FUNCOP_1, RLVECT_1, BINOP_1, HAHNBAN, VECTSP_4, XBOOLE_0,
      RELAT_1, XCMPLX_1, GROUP_1, XXREAL_0, XCMPLX_0, POWER, ALGSTR_0, XREAL_0;
 schemes FUNCT_2, BINOP_1, NAT_1;

begin
L1: (for B1 being  add-associative  right_zeroed  right_complementable  Abelian  right-distributive non  empty doubleLoopStr holds (for B2 , B3 being (Element of B1) holds ( B2 * ( - B3 ) ) = ( - ( B2 * B3 ) )))
proof
let C1 being  add-associative  right_zeroed  right_complementable  Abelian  right-distributive non  empty doubleLoopStr;
let C2 , C3 being (Element of C1);
L2: ( ( C2 * C3 ) + ( C2 * ( - C3 ) ) ) = ( C2 * ( C3 + ( - C3 ) ) ) by VECTSP_1:def 2
.= ( C2 * ( 0. C1 ) ) by RLVECT_1:def 10
.= ( 0. C1 ) by VECTSP_1:6;
thus L3: thesis by L2 , RLVECT_1:def 10;
end;
canceled 1;
theorem
L4: (for B4 , B5 , B6 , B7 being  real number holds ( ( B4 + ( B5 * ( <i> ) ) ) * ( B6 + ( B7 * ( <i> ) ) ) ) = ( ( ( B4 * B6 ) - ( B5 * B7 ) ) + ( ( ( B4 * B7 ) + ( B6 * B5 ) ) * ( <i> ) ) ));
theorem
L5: (for B8 being (Element of ( COMPLEX )) holds ( |. B8 .| + ( ( 0 ) * ( <i> ) ) ) = ( ( ( B8 *' ) / ( |. B8 .| + ( ( 0 ) * ( <i> ) ) ) ) * B8 ))
proof
let C4 being (Element of ( COMPLEX ));
per cases ;
suppose L6: |. C4 .| = ( 0 );

L7: C4 = ( 0 ) by L6 , COMPLEX1:45;
thus L8: thesis by L7 , L6;
end;
suppose L9: |. C4 .| <> ( 0 );

L10: ( Im ( C4 * ( C4 *' ) ) ) = ( 0 ) by COMPLEX1:40;
L11: |. C4 .| = ( |. C4 .| + ( ( 0 ) * ( <i> ) ) );
L12: (( Re |. C4 .| ) = |. C4 .| & ( Im |. C4 .| ) = ( 0 )) by L11 , COMPLEX1:12;
L13: (( ( ( C4 *' ) / |. C4 .| ) * C4 ) = ( ( C4 * ( C4 *' ) ) / |. C4 .| ) & ( Re ( C4 * ( C4 *' ) ) ) = ( ( ( Re C4 ) ^2 ) + ( ( Im C4 ) ^2 ) )) by COMPLEX1:40 , XCMPLX_1:74;
L14: ( Im ( ( ( C4 *' ) / |. C4 .| ) * C4 ) ) = ( ( ( |. C4 .| * ( 0 ) ) - ( ( ( ( Re C4 ) ^2 ) + ( ( Im C4 ) ^2 ) ) * ( 0 ) ) ) / ( ( |. C4 .| ^2 ) + ( ( 0 ) ^2 ) ) ) by L13 , L10 , L12 , COMPLEX1:24;
L15: ( Re ( ( ( C4 *' ) / |. C4 .| ) * C4 ) ) = ( ( ( ( ( ( Re C4 ) ^2 ) + ( ( Im C4 ) ^2 ) ) * |. C4 .| ) + ( ( 0 ) * ( 0 ) ) ) / ( ( |. C4 .| ^2 ) + ( ( 0 ) ^2 ) ) ) by L13 , L10 , L12 , COMPLEX1:24
.= ( ( |. ( C4 * C4 ) .| * |. C4 .| ) / ( |. C4 .| * |. C4 .| ) ) by COMPLEX1:68
.= ( |. ( C4 * C4 ) .| / |. C4 .| ) by L9 , XCMPLX_1:91
.= ( ( |. C4 .| * |. C4 .| ) / |. C4 .| ) by COMPLEX1:65
.= |. C4 .| by L9 , XCMPLX_1:89;
thus L16: thesis by L15 , L14 , COMPLEX1:13;
end;
end;
begin
definition
let C5 , C6 being  real number;
func [**C5 , C6 **] -> (Element of ( F_Complex )) equals 
( C5 + ( C6 * ( <i> ) ) );
coherence
proof
L18: ( C5 + ( C6 * ( <i> ) ) ) in ( COMPLEX ) by XCMPLX_0:def 2;
thus L19: thesis by L18 , COMPLFLD:def 1;
end;
end;
definition
func i_FC -> (Element of ( F_Complex )) equals 
( <i> );
coherence
proof
L21: ( ( 0 ) + ( 1 * ( <i> ) ) ) = [** ( 0 ) , 1 **];
thus L22: thesis by L21;
end;
end;
theorem
L24: ( ( i_FC ) * ( i_FC ) ) = ( - ( 1_ ( F_Complex ) ) )
proof
thus L25: ( ( i_FC ) * ( i_FC ) ) = ( - ( 1r ) )
.= ( - ( 1_ ( F_Complex ) ) ) by COMPLFLD:2 , COMPLFLD:8;
end;
theorem
L26: ( ( - ( 1_ ( F_Complex ) ) ) * ( - ( 1_ ( F_Complex ) ) ) ) = ( 1_ ( F_Complex ) )
proof
L27: ( - ( 1r ) ) = ( - ( 1_ ( F_Complex ) ) ) by COMPLFLD:2 , COMPLFLD:8;
thus L28: thesis by L27 , COMPLFLD:8;
end;
theorem
L29: (for B9 , B10 , B11 , B12 being Real holds ( [** B9 , B10 **] + [** B11 , B12 **] ) = [** ( B9 + B11 ) , ( B10 + B12 ) **]);
theorem
L30: (for B13 , B14 , B15 , B16 being  real number holds ( [** B13 , B14 **] * [** B15 , B16 **] ) = [** ( ( B13 * B15 ) - ( B14 * B16 ) ) , ( ( B13 * B16 ) + ( B15 * B14 ) ) **]);
canceled 1;
theorem
L31: (for B17 being Real holds |. [** B17 , ( 0 ) **] .| = ( abs B17 ));
theorem
L32: (for B18 , B19 being (Element of ( F_Complex )) holds (( Re ( B18 + B19 ) ) = ( ( Re B18 ) + ( Re B19 ) ) & ( Im ( B18 + B19 ) ) = ( ( Im B18 ) + ( Im B19 ) ))) by COMPLEX1:8;
theorem
L33: (for B20 , B21 being (Element of ( F_Complex )) holds (( Re ( B20 * B21 ) ) = ( ( ( Re B20 ) * ( Re B21 ) ) - ( ( Im B20 ) * ( Im B21 ) ) ) & ( Im ( B20 * B21 ) ) = ( ( ( Re B20 ) * ( Im B21 ) ) + ( ( Re B21 ) * ( Im B20 ) ) ))) by COMPLEX1:9;
begin
definition
let C7 being 1-sorted;
let C8 being VectSpStr over C7;
mode Functional of C8
 is (Function of (the carrier of C8) , (the carrier of C7));
end;
definition
let C9 being non  empty addLoopStr;
let C10 being non  empty VectSpStr over C9;
let C11 , C12 being (Functional of C10);
func C11 + C12 -> (Functional of C10) means 
:L35: (for B22 being (Element of C10) holds ( it . B22 ) = ( ( C11 . B22 ) + ( C12 . B22 ) ));
existence
proof
deffunc H1((Element of C10)) = ( ( C11 . $1 ) + ( C12 . $1 ) );
consider C13 being (Function of (the carrier of C10) , (the carrier of C9)) such that L36: (for B23 being (Element of C10) holds ( C13 . B23 ) = H1(B23)) from FUNCT_2:sch 4;
reconsider D1 = C13 as (Functional of C10);
take D1;
thus L37: thesis by L36;
end;
uniqueness
proof
let C14 , C15 being (Functional of C10);
assume that
L38: (for B24 being (Element of C10) holds ( C14 . B24 ) = ( ( C11 . B24 ) + ( C12 . B24 ) ))
and
L39: (for B25 being (Element of C10) holds ( C15 . B25 ) = ( ( C11 . B25 ) + ( C12 . B25 ) ));
L40:
now
let C16 being (Element of C10);
thus L41: ( C14 . C16 ) = ( ( C11 . C16 ) + ( C12 . C16 ) ) by L38
.= ( C15 . C16 ) by L39;
end;
thus L42: C14 = C15 by L40 , FUNCT_2:63;
end;
end;
definition
let C17 being non  empty addLoopStr;
let C18 being non  empty VectSpStr over C17;
let C19 being (Functional of C18);
func - C19 -> (Functional of C18) means 
:L44: (for B26 being (Element of C18) holds ( it . B26 ) = ( - ( C19 . B26 ) ));
existence
proof
deffunc H2((Element of C18)) = ( - ( C19 . $1 ) );
consider C20 being (Function of (the carrier of C18) , (the carrier of C17)) such that L45: (for B27 being (Element of C18) holds ( C20 . B27 ) = H2(B27)) from FUNCT_2:sch 4;
reconsider D2 = C20 as (Functional of C18);
take D2;
thus L46: thesis by L45;
end;
uniqueness
proof
let C21 , C22 being (Functional of C18);
assume that
L47: (for B28 being (Element of C18) holds ( C21 . B28 ) = ( - ( C19 . B28 ) ))
and
L48: (for B29 being (Element of C18) holds ( C22 . B29 ) = ( - ( C19 . B29 ) ));
L49:
now
let C23 being (Element of C18);
thus L50: ( C21 . C23 ) = ( - ( C19 . C23 ) ) by L47
.= ( C22 . C23 ) by L48;
end;
thus L51: C21 = C22 by L49 , FUNCT_2:63;
end;
end;
definition
let C24 being non  empty addLoopStr;
let C25 being non  empty VectSpStr over C24;
let C26 , C27 being (Functional of C25);
func C26 - C27 -> (Functional of C25) equals 
( C26 + ( - C27 ) );
coherence;
end;
definition
let C28 being non  empty multMagma;
let C29 being non  empty VectSpStr over C28;
let C30 being (Element of C28);
let C31 being (Functional of C29);
func C30 * C31 -> (Functional of C29) means 
:L54: (for B30 being (Element of C29) holds ( it . B30 ) = ( C30 * ( C31 . B30 ) ));
existence
proof
deffunc H3((Element of C29)) = ( C30 * ( C31 . $1 ) );
consider C32 being (Function of (the carrier of C29) , (the carrier of C28)) such that L55: (for B31 being (Element of C29) holds ( C32 . B31 ) = H3(B31)) from FUNCT_2:sch 4;
reconsider D3 = C32 as (Functional of C29);
take D3;
thus L56: thesis by L55;
end;
uniqueness
proof
let C33 , C34 being (Functional of C29);
assume that
L57: (for B32 being (Element of C29) holds ( C33 . B32 ) = ( C30 * ( C31 . B32 ) ))
and
L58: (for B33 being (Element of C29) holds ( C34 . B33 ) = ( C30 * ( C31 . B33 ) ));
L59:
now
let C35 being (Element of C29);
thus L60: ( C33 . C35 ) = ( C30 * ( C31 . C35 ) ) by L57
.= ( C34 . C35 ) by L58;
end;
thus L61: thesis by L59 , FUNCT_2:63;
end;
end;
definition
let C36 being non  empty ZeroStr;
let C37 being VectSpStr over C36;
func 0Functional C37 -> (Functional of C37) equals 
( ( [#] C37 ) --> ( 0. C36 ) );
coherence;
end;
definition
let C38 being non  empty multMagma;
let C39 being non  empty VectSpStr over C38;
let C40 being (Functional of C39);
attr C40 is  homogeneous
means
:L64: (for B34 being (Vector of C39) holds (for B35 being (Scalar of C39) holds ( C40 . ( B35 * B34 ) ) = ( B35 * ( C40 . B34 ) )));
end;
definition
let C41 being non  empty ZeroStr;
let C42 being non  empty VectSpStr over C41;
let C43 being (Functional of C42);
attr C43 is  0-preserving
means
( C43 . ( 0. C42 ) ) = ( 0. C41 );
end;
registration
let C44 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C45 being (VectSp of C44);
cluster  homogeneous ->  0-preserving for (Functional of C45);
coherence
proof
let C46 being (Functional of C45);
assume L67: C46 is  homogeneous;
thus L68: ( C46 . ( 0. C45 ) ) = ( C46 . ( ( 0. C44 ) * ( 0. C45 ) ) ) by VECTSP_1:14
.= ( ( 0. C44 ) * ( C46 . ( 0. C45 ) ) ) by L67 , L64
.= ( 0. C44 ) by VECTSP_1:7;
end;
end;
registration
let C47 being  right_zeroed non  empty addLoopStr;
let C48 being non  empty VectSpStr over C47;
cluster ( 0Functional C48 ) ->  additive;
coherence
proof
let C49 , C50 being (Vector of C48);
L70: (( ( 0Functional C48 ) . C49 ) = ( 0. C47 ) & ( ( 0Functional C48 ) . C50 ) = ( 0. C47 )) by FUNCOP_1:7;
thus L71: ( ( 0Functional C48 ) . ( C49 + C50 ) ) = ( 0. C47 ) by FUNCOP_1:7
.= ( ( ( 0Functional C48 ) . C49 ) + ( ( 0Functional C48 ) . C50 ) ) by L70 , RLVECT_1:def 4;
end;
end;
registration
let C51 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C52 being non  empty VectSpStr over C51;
cluster ( 0Functional C52 ) ->  homogeneous;
coherence
proof
let C53 being (Vector of C52);
let C54 being (Scalar of C52);
L73: ( ( 0Functional C52 ) . C53 ) = ( 0. C51 ) by FUNCOP_1:7;
thus L74: ( ( 0Functional C52 ) . ( C54 * C53 ) ) = ( 0. C51 ) by FUNCOP_1:7
.= ( C54 * ( ( 0Functional C52 ) . C53 ) ) by L73 , VECTSP_1:6;
end;
end;
registration
let C55 being non  empty ZeroStr;
let C56 being non  empty VectSpStr over C55;
cluster ( 0Functional C56 ) ->  0-preserving;
coherence
proof
thus L76: ( ( 0Functional C56 ) . ( 0. C56 ) ) = ( 0. C55 ) by FUNCOP_1:7;
end;
end;
registration
let C57 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C58 being non  empty VectSpStr over C57;
cluster  additive  homogeneous  0-preserving for (Functional of C58);
existence
proof
take ( 0Functional C58 );
thus L78: thesis;
end;
end;
theorem
L80: (for B36 being  Abelian non  empty addLoopStr holds (for B37 being non  empty VectSpStr over B36 holds (for B38 , B39 being (Functional of B37) holds ( B38 + B39 ) = ( B39 + B38 ))))
proof
let C59 being  Abelian non  empty addLoopStr;
let C60 being non  empty VectSpStr over C59;
let C61 , C62 being (Functional of C60);
L81:
now
let C63 being (Element of C60);
thus L82: ( ( C61 + C62 ) . C63 ) = ( ( C61 . C63 ) + ( C62 . C63 ) ) by L35
.= ( ( C62 + C61 ) . C63 ) by L35;
end;
thus L83: thesis by L81 , FUNCT_2:63;
end;
theorem
L84: (for B40 being  add-associative non  empty addLoopStr holds (for B41 being non  empty VectSpStr over B40 holds (for B42 , B43 , B44 being (Functional of B41) holds ( ( B42 + B43 ) + B44 ) = ( B42 + ( B43 + B44 ) ))))
proof
let C64 being  add-associative non  empty addLoopStr;
let C65 being non  empty VectSpStr over C64;
let C66 , C67 , C68 being (Functional of C65);
L85:
now
let C69 being (Element of C65);
thus L86: ( ( ( C66 + C67 ) + C68 ) . C69 ) = ( ( ( C66 + C67 ) . C69 ) + ( C68 . C69 ) ) by L35
.= ( ( ( C66 . C69 ) + ( C67 . C69 ) ) + ( C68 . C69 ) ) by L35
.= ( ( C66 . C69 ) + ( ( C67 . C69 ) + ( C68 . C69 ) ) ) by RLVECT_1:def 3
.= ( ( C66 . C69 ) + ( ( C67 + C68 ) . C69 ) ) by L35
.= ( ( C66 + ( C67 + C68 ) ) . C69 ) by L35;
end;
thus L87: thesis by L85 , FUNCT_2:63;
end;
theorem
L88: (for B45 being non  empty ZeroStr holds (for B46 being non  empty VectSpStr over B45 holds (for B47 being (Element of B46) holds ( ( 0Functional B46 ) . B47 ) = ( 0. B45 )))) by FUNCOP_1:7;
theorem
L89: (for B48 being  right_zeroed non  empty addLoopStr holds (for B49 being non  empty VectSpStr over B48 holds (for B50 being (Functional of B49) holds ( B50 + ( 0Functional B49 ) ) = B50)))
proof
let C70 being  right_zeroed non  empty addLoopStr;
let C71 being non  empty VectSpStr over C70;
let C72 being (Functional of C71);
L90:
now
let C73 being (Element of C71);
thus L91: ( ( C72 + ( 0Functional C71 ) ) . C73 ) = ( ( C72 . C73 ) + ( ( 0Functional C71 ) . C73 ) ) by L35
.= ( ( C72 . C73 ) + ( 0. C70 ) ) by FUNCOP_1:7
.= ( C72 . C73 ) by RLVECT_1:def 4;
end;
thus L92: thesis by L90 , FUNCT_2:63;
end;
theorem
L93: (for B51 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B52 being non  empty VectSpStr over B51 holds (for B53 being (Functional of B52) holds ( B53 - B53 ) = ( 0Functional B52 ))))
proof
let C74 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C75 being non  empty VectSpStr over C74;
let C76 being (Functional of C75);
L94:
now
let C77 being (Element of C75);
thus L95: ( ( C76 - C76 ) . C77 ) = ( ( C76 . C77 ) + ( ( - C76 ) . C77 ) ) by L35
.= ( ( C76 . C77 ) + ( - ( C76 . C77 ) ) ) by L44
.= ( 0. C74 ) by RLVECT_1:5
.= ( ( 0Functional C75 ) . C77 ) by FUNCOP_1:7;
end;
thus L96: thesis by L94 , FUNCT_2:63;
end;
theorem
L97: (for B54 being  right-distributive non  empty doubleLoopStr holds (for B55 being non  empty VectSpStr over B54 holds (for B56 being (Element of B54) holds (for B57 , B58 being (Functional of B55) holds ( B56 * ( B57 + B58 ) ) = ( ( B56 * B57 ) + ( B56 * B58 ) )))))
proof
let C78 being  right-distributive non  empty doubleLoopStr;
let C79 being non  empty VectSpStr over C78;
let C80 being (Element of C78);
let C81 , C82 being (Functional of C79);
L98:
now
let C83 being (Element of C79);
thus L99: ( ( C80 * ( C81 + C82 ) ) . C83 ) = ( C80 * ( ( C81 + C82 ) . C83 ) ) by L54
.= ( C80 * ( ( C81 . C83 ) + ( C82 . C83 ) ) ) by L35
.= ( ( C80 * ( C81 . C83 ) ) + ( C80 * ( C82 . C83 ) ) ) by VECTSP_1:def 2
.= ( ( ( C80 * C81 ) . C83 ) + ( C80 * ( C82 . C83 ) ) ) by L54
.= ( ( ( C80 * C81 ) . C83 ) + ( ( C80 * C82 ) . C83 ) ) by L54
.= ( ( ( C80 * C81 ) + ( C80 * C82 ) ) . C83 ) by L35;
end;
thus L100: thesis by L98 , FUNCT_2:63;
end;
theorem
L101: (for B59 being  left-distributive non  empty doubleLoopStr holds (for B60 being non  empty VectSpStr over B59 holds (for B61 , B62 being (Element of B59) holds (for B63 being (Functional of B60) holds ( ( B61 + B62 ) * B63 ) = ( ( B61 * B63 ) + ( B62 * B63 ) )))))
proof
let C84 being  left-distributive non  empty doubleLoopStr;
let C85 being non  empty VectSpStr over C84;
let C86 , C87 being (Element of C84);
let C88 being (Functional of C85);
L102:
now
let C89 being (Element of C85);
thus L103: ( ( ( C86 + C87 ) * C88 ) . C89 ) = ( ( C86 + C87 ) * ( C88 . C89 ) ) by L54
.= ( ( C86 * ( C88 . C89 ) ) + ( C87 * ( C88 . C89 ) ) ) by VECTSP_1:def 3
.= ( ( ( C86 * C88 ) . C89 ) + ( C87 * ( C88 . C89 ) ) ) by L54
.= ( ( ( C86 * C88 ) . C89 ) + ( ( C87 * C88 ) . C89 ) ) by L54
.= ( ( ( C86 * C88 ) + ( C87 * C88 ) ) . C89 ) by L35;
end;
thus L104: thesis by L102 , FUNCT_2:63;
end;
theorem
L105: (for B64 being  associative non  empty multMagma holds (for B65 being non  empty VectSpStr over B64 holds (for B66 , B67 being (Element of B64) holds (for B68 being (Functional of B65) holds ( ( B66 * B67 ) * B68 ) = ( B66 * ( B67 * B68 ) )))))
proof
let C90 being  associative non  empty multMagma;
let C91 being non  empty VectSpStr over C90;
let C92 , C93 being (Element of C90);
let C94 being (Functional of C91);
L106:
now
let C95 being (Element of C91);
thus L107: ( ( ( C92 * C93 ) * C94 ) . C95 ) = ( ( C92 * C93 ) * ( C94 . C95 ) ) by L54
.= ( C92 * ( C93 * ( C94 . C95 ) ) ) by GROUP_1:def 3
.= ( C92 * ( ( C93 * C94 ) . C95 ) ) by L54
.= ( ( C92 * ( C93 * C94 ) ) . C95 ) by L54;
end;
thus L108: thesis by L106 , FUNCT_2:63;
end;
theorem
L109: (for B69 being  left_unital non  empty doubleLoopStr holds (for B70 being non  empty VectSpStr over B69 holds (for B71 being (Functional of B70) holds ( ( 1. B69 ) * B71 ) = B71)))
proof
let C96 being  left_unital non  empty doubleLoopStr;
let C97 being non  empty VectSpStr over C96;
let C98 being (Functional of C97);
L110:
now
let C99 being (Element of C97);
thus L111: ( ( ( 1. C96 ) * C98 ) . C99 ) = ( ( 1. C96 ) * ( C98 . C99 ) ) by L54
.= ( C98 . C99 ) by VECTSP_1:def 8;
end;
thus L112: thesis by L110 , FUNCT_2:63;
end;
registration
let C100 being  Abelian  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C101 being non  empty VectSpStr over C100;
let C102 , C103 being  additive (Functional of C101);
cluster ( C102 + C103 ) ->  additive;
coherence
proof
let C104 , C105 being (Vector of C101);
thus L113: ( ( C102 + C103 ) . ( C104 + C105 ) ) = ( ( C102 . ( C104 + C105 ) ) + ( C103 . ( C104 + C105 ) ) ) by L35
.= ( ( ( C102 . C104 ) + ( C102 . C105 ) ) + ( C103 . ( C104 + C105 ) ) ) by VECTSP_1:def 20
.= ( ( ( C102 . C104 ) + ( C102 . C105 ) ) + ( ( C103 . C104 ) + ( C103 . C105 ) ) ) by VECTSP_1:def 20
.= ( ( C102 . C104 ) + ( ( C102 . C105 ) + ( ( C103 . C104 ) + ( C103 . C105 ) ) ) ) by RLVECT_1:def 3
.= ( ( C102 . C104 ) + ( ( C103 . C104 ) + ( ( C102 . C105 ) + ( C103 . C105 ) ) ) ) by RLVECT_1:def 3
.= ( ( ( C102 . C104 ) + ( C103 . C104 ) ) + ( ( C102 . C105 ) + ( C103 . C105 ) ) ) by RLVECT_1:def 3
.= ( ( ( C102 + C103 ) . C104 ) + ( ( C102 . C105 ) + ( C103 . C105 ) ) ) by L35
.= ( ( ( C102 + C103 ) . C104 ) + ( ( C102 + C103 ) . C105 ) ) by L35;
end;
end;
registration
let C106 being  Abelian  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C107 being non  empty VectSpStr over C106;
let C108 being  additive (Functional of C107);
cluster ( - C108 ) ->  additive;
coherence
proof
let C109 , C110 being (Vector of C107);
thus L115: ( ( - C108 ) . ( C109 + C110 ) ) = ( - ( C108 . ( C109 + C110 ) ) ) by L44
.= ( - ( ( C108 . C109 ) + ( C108 . C110 ) ) ) by VECTSP_1:def 20
.= ( ( - ( C108 . C109 ) ) + ( - ( C108 . C110 ) ) ) by RLVECT_1:31
.= ( ( ( - C108 ) . C109 ) + ( - ( C108 . C110 ) ) ) by L44
.= ( ( ( - C108 ) . C109 ) + ( ( - C108 ) . C110 ) ) by L44;
end;
end;
registration
let C111 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C112 being non  empty VectSpStr over C111;
let C113 being (Element of C111);
let C114 being  additive (Functional of C112);
cluster ( C113 * C114 ) ->  additive;
coherence
proof
let C115 , C116 being (Vector of C112);
thus L117: ( ( C113 * C114 ) . ( C115 + C116 ) ) = ( C113 * ( C114 . ( C115 + C116 ) ) ) by L54
.= ( C113 * ( ( C114 . C115 ) + ( C114 . C116 ) ) ) by VECTSP_1:def 20
.= ( ( C113 * ( C114 . C115 ) ) + ( C113 * ( C114 . C116 ) ) ) by VECTSP_1:def 2
.= ( ( ( C113 * C114 ) . C115 ) + ( C113 * ( C114 . C116 ) ) ) by L54
.= ( ( ( C113 * C114 ) . C115 ) + ( ( C113 * C114 ) . C116 ) ) by L54;
end;
end;
registration
let C117 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C118 being non  empty VectSpStr over C117;
let C119 , C120 being  homogeneous (Functional of C118);
cluster ( C119 + C120 ) ->  homogeneous;
coherence
proof
let C121 being (Vector of C118);
let C122 being (Scalar of C118);
thus L119: ( ( C119 + C120 ) . ( C122 * C121 ) ) = ( ( C119 . ( C122 * C121 ) ) + ( C120 . ( C122 * C121 ) ) ) by L35
.= ( ( C122 * ( C119 . C121 ) ) + ( C120 . ( C122 * C121 ) ) ) by L64
.= ( ( C122 * ( C119 . C121 ) ) + ( C122 * ( C120 . C121 ) ) ) by L64
.= ( C122 * ( ( C119 . C121 ) + ( C120 . C121 ) ) ) by VECTSP_1:def 2
.= ( C122 * ( ( C119 + C120 ) . C121 ) ) by L35;
end;
end;
registration
let C123 being  Abelian  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C124 being non  empty VectSpStr over C123;
let C125 being  homogeneous (Functional of C124);
cluster ( - C125 ) ->  homogeneous;
coherence
proof
let C126 being (Vector of C124);
let C127 being (Scalar of C124);
thus L121: ( ( - C125 ) . ( C127 * C126 ) ) = ( - ( C125 . ( C127 * C126 ) ) ) by L44
.= ( - ( C127 * ( C125 . C126 ) ) ) by L64
.= ( C127 * ( - ( C125 . C126 ) ) ) by L1
.= ( C127 * ( ( - C125 ) . C126 ) ) by L44;
end;
end;
registration
let C128 being  add-associative  right_zeroed  right_complementable  right-distributive  associative  commutative non  empty doubleLoopStr;
let C129 being non  empty VectSpStr over C128;
let C130 being (Element of C128);
let C131 being  homogeneous (Functional of C129);
cluster ( C130 * C131 ) ->  homogeneous;
coherence
proof
let C132 being (Vector of C129);
let C133 being (Scalar of C129);
thus L123: ( ( C130 * C131 ) . ( C133 * C132 ) ) = ( C130 * ( C131 . ( C133 * C132 ) ) ) by L54
.= ( C130 * ( C133 * ( C131 . C132 ) ) ) by L64
.= ( C133 * ( C130 * ( C131 . C132 ) ) ) by GROUP_1:def 3
.= ( C133 * ( ( C130 * C131 ) . C132 ) ) by L54;
end;
end;
definition
let C134 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C135 being non  empty VectSpStr over C134;
mode linear-Functional of C135
 is  additive  homogeneous (Functional of C135);
end;
begin
definition
let C136 being  Abelian  add-associative  right_zeroed  right_complementable  right-distributive  associative  commutative non  empty doubleLoopStr;
let C137 being non  empty VectSpStr over C136;
func C137 *' -> non  empty  strict VectSpStr over C136 means 
:L126: ((for B72 being set holds (B72 in (the carrier of it) iff B72 is (linear-Functional of C137))) & (for B73 , B74 being (linear-Functional of C137) holds ( (the addF of it) . (B73 , B74) ) = ( B73 + B74 )) & ( 0. it ) = ( 0Functional C137 ) & (for B75 being (linear-Functional of C137) holds (for B76 being (Element of C136) holds ( (the lmult of it) . (B76 , B75) ) = ( B76 * B75 ))));
existence
proof
defpred S1[ set , set , set ] means (ex B77 , B78 being (Functional of C137) st ($1 = B77 & $2 = B78 & $3 = ( B77 + B78 )));
L127: ( 0Functional C137 ) in { B79 where B79 is (linear-Functional of C137) : (not contradiction) };
reconsider D4 = { B80 where B80 is (linear-Functional of C137) : (not contradiction) } as non  empty set by L127;
L128:
now
let C138 being set;
thus L129: (C138 in D4 implies C138 is (linear-Functional of C137))
proof
assume L130: C138 in D4;
L131: (ex B81 being (linear-Functional of C137) st C138 = B81) by L130;
thus L132: thesis by L131;
end;

thus L133: (C138 is (linear-Functional of C137) implies C138 in D4);
end;
reconsider D5 = ( 0Functional C137 ) as (Element of D4) by L128;
L134: (for B82 , B83 being (Element of D4) holds (ex B84 being (Element of D4) st S1[ B82 , B83 , B84 ]))
proof
let C139 , C140 being (Element of D4);
reconsider D6 = C139 , D7 = C140 as (linear-Functional of C137) by L128;
reconsider D8 = ( D6 + D7 ) as (Element of D4) by L128;
take D8;
take D6;
take D7;
thus L135: thesis;
end;
consider C141 being (Function of [: D4 , D4 :] , D4) such that L136: (for B85 , B86 being (Element of D4) holds S1[ B85 , B86 , ( C141 . (B85 , B86) ) ]) from BINOP_1:sch 3(L134);
defpred S2[ (Element of C136) , set , set ] means (ex B87 being (Functional of C137) st ($2 = B87 & $3 = ( $1 * B87 )));
L137: (for B88 being (Element of C136) holds (for B89 being (Element of D4) holds (ex B90 being (Element of D4) st S2[ B88 , B89 , B90 ])))
proof
let C142 being (Element of C136);
let C143 being (Element of D4);
reconsider D9 = C143 as (linear-Functional of C137) by L128;
reconsider D10 = ( C142 * D9 ) as (Element of D4) by L128;
take D10;
take D9;
thus L138: thesis;
end;
consider C144 being (Function of [: (the carrier of C136) , D4 :] , D4) such that L139: (for B91 being (Element of C136) holds (for B92 being (Element of D4) holds S2[ B91 , B92 , ( C144 . (B91 , B92) ) ])) from BINOP_1:sch 3(L137);
L140:
now
let C145 being (linear-Functional of C137);
reconsider D11 = C145 as (Element of D4) by L128;
let C146 being (Element of C136);
L141: (ex B93 being (Functional of C137) st (D11 = B93 & ( C144 . (C146 , D11) ) = ( C146 * B93 ))) by L139;
thus L142: ( C144 . (C146 , C145) ) = ( C146 * C145 ) by L141;
end;
reconsider D12 = VectSpStr (# D4 , C141 , D5 , C144 #) as non  empty  strict VectSpStr over C136;
take D12;
L143:
now
let C147 , C148 being (linear-Functional of C137);
reconsider D13 = C147 , D14 = C148 as (Element of D4) by L128;
L144: (ex B94 , B95 being (Functional of C137) st (D13 = B94 & D14 = B95 & ( C141 . (D13 , D14) ) = ( B94 + B95 ))) by L136;
thus L145: ( C141 . (C147 , C148) ) = ( C147 + C148 ) by L144;
end;
thus L146: thesis by L143 , L128 , L140;
end;
uniqueness
proof
let C149 , C150 being non  empty  strict VectSpStr over C136;
assume that
L147: (for B96 being set holds (B96 in (the carrier of C149) iff B96 is (linear-Functional of C137)))
and
L148: (for B97 , B98 being (linear-Functional of C137) holds ( (the addF of C149) . (B97 , B98) ) = ( B97 + B98 ))
and
L149: ( 0. C149 ) = ( 0Functional C137 )
and
L150: (for B99 being (linear-Functional of C137) holds (for B100 being (Element of C136) holds ( (the lmult of C149) . (B100 , B99) ) = ( B100 * B99 )))
and
L151: (for B101 being set holds (B101 in (the carrier of C150) iff B101 is (linear-Functional of C137)))
and
L152: (for B102 , B103 being (linear-Functional of C137) holds ( (the addF of C150) . (B102 , B103) ) = ( B102 + B103 ))
and
L153: ( 0. C150 ) = ( 0Functional C137 )
and
L154: (for B104 being (linear-Functional of C137) holds (for B105 being (Element of C136) holds ( (the lmult of C150) . (B105 , B104) ) = ( B105 * B104 )));
L155:
now
let C151 being (Element of C136);
let C152 being (Element of C149);
reconsider D15 = C152 as (linear-Functional of C137) by L147;
thus L156: ( (the lmult of C149) . (C151 , C152) ) = ( C151 * D15 ) by L150
.= ( (the lmult of C150) . (C151 , C152) ) by L154;
end;
L157:
now
let C153 being set;
thus L158: (C153 in (the carrier of C149) implies C153 in (the carrier of C150))
proof
assume L159: C153 in (the carrier of C149);
L160: C153 is (linear-Functional of C137) by L159 , L147;
thus L161: thesis by L160 , L151;
end;

assume L162: C153 in (the carrier of C150);
L163: C153 is (linear-Functional of C137) by L162 , L151;
thus L164: C153 in (the carrier of C149) by L163 , L147;
end;
L165: (the carrier of C149) = (the carrier of C150) by L157 , TARSKI:1;
L166:
now
let C154 , C155 being (Element of C149);
reconsider D16 = C154 , D17 = C155 as (linear-Functional of C137) by L147;
thus L167: ( (the addF of C149) . (C154 , C155) ) = ( D16 + D17 ) by L148
.= ( (the addF of C150) . (C154 , C155) ) by L152;
end;
L168: (the addF of C149) = (the addF of C150) by L166 , L165 , BINOP_1:2;
thus L169: thesis by L168 , L149 , L153 , L165 , L155 , BINOP_1:2;
end;
end;
registration
let C156 being  Abelian  add-associative  right_zeroed  right_complementable  right-distributive  associative  commutative non  empty doubleLoopStr;
let C157 being non  empty VectSpStr over C156;
cluster ( C157 *' ) ->  Abelian;
coherence
proof
let C158 , C159 being (Element of ( C157 *' ));
reconsider D18 = C158 , D19 = C159 as (linear-Functional of C157) by L126;
thus L171: ( C158 + C159 ) = ( D18 + D19 ) by L126
.= ( D19 + D18 ) by L80
.= ( C159 + C158 ) by L126;
end;
end;
registration
let C160 being  Abelian  add-associative  right_zeroed  right_complementable  right-distributive  associative  commutative non  empty doubleLoopStr;
let C161 being non  empty VectSpStr over C160;
cluster ( C161 *' ) ->  add-associative;
coherence
proof
let C162 , C163 , C164 being (Element of ( C161 *' ));
reconsider D20 = C162 , D21 = C163 , D22 = C164 as (linear-Functional of C161) by L126;
thus L173: ( ( C162 + C163 ) + C164 ) = ( (the addF of ( C161 *' )) . (( D20 + D21 ) , C164) ) by L126
.= ( ( D20 + D21 ) + D22 ) by L126
.= ( D20 + ( D21 + D22 ) ) by L84
.= ( (the addF of ( C161 *' )) . (C162 , ( D21 + D22 )) ) by L126
.= ( C162 + ( C163 + C164 ) ) by L126;
end;
cluster ( C161 *' ) ->  right_zeroed;
coherence
proof
let C165 being (Element of ( C161 *' ));
reconsider D23 = C165 as (linear-Functional of C161) by L126;
thus L174: ( C165 + ( 0. ( C161 *' ) ) ) = ( (the addF of ( C161 *' )) . (C165 , ( 0Functional C161 )) ) by L126
.= ( D23 + ( 0Functional C161 ) ) by L126
.= C165 by L89;
end;
cluster ( C161 *' ) ->  right_complementable;
coherence
proof
let C166 being (Element of ( C161 *' ));
reconsider D24 = C166 as (linear-Functional of C161) by L126;
reconsider D25 = ( - D24 ) as (Element of ( C161 *' )) by L126;
take D25;
thus L175: ( C166 + D25 ) = ( D24 - D24 ) by L126
.= ( 0Functional C161 ) by L93
.= ( 0. ( C161 *' ) ) by L126;
end;
end;
registration
let C167 being  Abelian  add-associative  right_zeroed  right_complementable  left_unital  distributive  associative  commutative non  empty doubleLoopStr;
let C168 being non  empty VectSpStr over C167;
cluster ( C168 *' ) ->  vector-distributive  scalar-distributive  scalar-associative  scalar-unital;
coherence
proof
L177:
now
let C169 , C170 being (Element of C167);
let C171 , C172 being (Element of ( C168 *' ));
reconsider D26 = C171 , D27 = C172 as (linear-Functional of C168) by L126;
thus L178: ( C169 * ( C171 + C172 ) ) = ( (the lmult of ( C168 *' )) . (C169 , ( D26 + D27 )) ) by L126
.= ( C169 * ( D26 + D27 ) ) by L126
.= ( ( C169 * D26 ) + ( C169 * D27 ) ) by L97
.= ( (the addF of ( C168 *' )) . (( C169 * D26 ) , ( C169 * D27 )) ) by L126
.= ( (the addF of ( C168 *' )) . (( (the lmult of ( C168 *' )) . (C169 , D26) ) , ( C169 * D27 )) ) by L126
.= ( ( C169 * C171 ) + ( C169 * C172 ) ) by L126;
thus L179: ( ( C169 + C170 ) * C171 ) = ( ( C169 + C170 ) * D26 ) by L126
.= ( ( C169 * D26 ) + ( C170 * D26 ) ) by L101
.= ( (the addF of ( C168 *' )) . (( C169 * D26 ) , ( C170 * D26 )) ) by L126
.= ( (the addF of ( C168 *' )) . (( (the lmult of ( C168 *' )) . (C169 , D26) ) , ( C170 * D26 )) ) by L126
.= ( ( C169 * C171 ) + ( C170 * C171 ) ) by L126;
thus L180: ( ( C169 * C170 ) * C171 ) = ( ( C169 * C170 ) * D26 ) by L126
.= ( C169 * ( C170 * D26 ) ) by L105
.= ( (the lmult of ( C168 *' )) . (C169 , ( C170 * D26 )) ) by L126
.= ( C169 * ( C170 * C171 ) ) by L126;
thus L181: ( ( 1. C167 ) * C171 ) = ( ( 1. C167 ) * D26 ) by L126
.= C171 by L109;
end;
thus L182: thesis by L177 , VECTSP_1:def 14 , VECTSP_1:def 15 , VECTSP_1:def 16 , VECTSP_1:def 17;
end;
end;
begin
definition
let C173 being 1-sorted;
let C174 being VectSpStr over C173;
mode RFunctional of C174
 is (Function of (the carrier of C174) , ( REAL ));
end;
definition
let C175 being 1-sorted;
let C176 being non  empty VectSpStr over C175;
let C177 being (RFunctional of C176);
attr C177 is  subadditive
means
:L185: (for B106 , B107 being (Vector of C176) holds ( C177 . ( B106 + B107 ) ) <= ( ( C177 . B106 ) + ( C177 . B107 ) ));
end;
definition
let C178 being 1-sorted;
let C179 being non  empty VectSpStr over C178;
let C180 being (RFunctional of C179);
attr C180 is  additive
means
:L187: (for B108 , B109 being (Vector of C179) holds ( C180 . ( B108 + B109 ) ) = ( ( C180 . B108 ) + ( C180 . B109 ) ));
end;
definition
let C181 being non  empty VectSpStr over ( F_Complex );
let C182 being (RFunctional of C181);
attr C182 is  Real_homogeneous
means
:L189: (for B110 being (Vector of C181) holds (for B111 being Real holds ( C182 . ( [** B111 , ( 0 ) **] * B110 ) ) = ( B111 * ( C182 . B110 ) )));
end;
theorem
L191: (for B112 being  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over ( F_Complex ) holds (for B113 being (RFunctional of B112) holds (B113 is  Real_homogeneous implies (for B114 being (Vector of B112) holds (for B115 being Real holds ( B113 . ( [** ( 0 ) , B115 **] * B114 ) ) = ( B115 * ( B113 . ( ( i_FC ) * B114 ) ) ))))))
proof
let C183 being  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over ( F_Complex );
let C184 being (RFunctional of C183);
assume L192: C184 is  Real_homogeneous;
let C185 being (Vector of C183);
let C186 being Real;
thus L193: ( C184 . ( [** ( 0 ) , C186 **] * C185 ) ) = ( C184 . ( ( [** C186 , ( 0 ) **] * ( i_FC ) ) * C185 ) )
.= ( C184 . ( [** C186 , ( 0 ) **] * ( ( i_FC ) * C185 ) ) ) by VECTSP_1:def 16
.= ( C186 * ( C184 . ( ( i_FC ) * C185 ) ) ) by L192 , L189;
end;
definition
let C187 being non  empty VectSpStr over ( F_Complex );
let C188 being (RFunctional of C187);
attr C188 is  homogeneous
means
:L194: (for B116 being (Vector of C187) holds (for B117 being (Scalar of C187) holds ( C188 . ( B117 * B116 ) ) = ( |. B117 .| * ( C188 . B116 ) )));
end;
definition
let C189 being 1-sorted;
let C190 being VectSpStr over C189;
let C191 being (RFunctional of C190);
attr C191 is  0-preserving
means
( C191 . ( 0. C190 ) ) = ( 0 );
end;
registration
let C192 being 1-sorted;
let C193 being non  empty VectSpStr over C192;
cluster  additive ->  subadditive for (RFunctional of C193);
coherence
proof
let C194 being (RFunctional of C193);
assume L197: C194 is  additive;
let C195 , C196 being (Vector of C193);
thus L198: thesis by L197 , L187;
end;
end;
registration
let C197 being (VectSp of ( F_Complex ));
cluster  Real_homogeneous ->  0-preserving for (RFunctional of C197);
coherence
proof
let C198 being (RFunctional of C197);
assume L200: C198 is  Real_homogeneous;
L201: ( 0. ( F_Complex ) ) = [** ( 0 ) , ( 0 ) **] by COMPLFLD:7;
thus L202: ( C198 . ( 0. C197 ) ) = ( C198 . ( ( 0. ( F_Complex ) ) * ( 0. C197 ) ) ) by VECTSP_1:14
.= ( ( 0 ) * ( C198 . ( 0. C197 ) ) ) by L200 , L201 , L189
.= ( 0 );
end;
end;
definition
let C199 being 1-sorted;
let C200 being VectSpStr over C199;
func 0RFunctional C200 -> (RFunctional of C200) equals 
( ( [#] C200 ) --> ( 0 ) );
coherence;
end;
registration
let C201 being 1-sorted;
let C202 being non  empty VectSpStr over C201;
cluster ( 0RFunctional C202 ) ->  additive;
coherence
proof
let C203 , C204 being (Vector of C202);
L205: (( ( 0RFunctional C202 ) . C203 ) = ( 0 ) & ( ( 0RFunctional C202 ) . C204 ) = ( 0 )) by FUNCOP_1:7;
thus L206: thesis by L205 , FUNCOP_1:7;
end;
cluster ( 0RFunctional C202 ) ->  0-preserving;
coherence
proof
thus L207: ( ( 0RFunctional C202 ) . ( 0. C202 ) ) = ( 0 ) by FUNCOP_1:7;
end;
end;
registration
let C205 being non  empty VectSpStr over ( F_Complex );
cluster ( 0RFunctional C205 ) ->  Real_homogeneous;
coherence
proof
let C206 being (Vector of C205);
let C207 being Real;
L209: ( ( 0RFunctional C205 ) . C206 ) = ( 0 ) by FUNCOP_1:7;
thus L210: thesis by L209 , FUNCOP_1:7;
end;
cluster ( 0RFunctional C205 ) ->  homogeneous;
coherence
proof
let C208 being (Vector of C205);
let C209 being (Scalar of C205);
L211: ( ( 0RFunctional C205 ) . C208 ) = ( 0 ) by FUNCOP_1:7;
thus L212: thesis by L211 , FUNCOP_1:7;
end;
end;
registration
let C210 being 1-sorted;
let C211 being non  empty VectSpStr over C210;
cluster  additive  0-preserving for (RFunctional of C211);
existence
proof
take ( 0RFunctional C211 );
thus L214: thesis;
end;
end;
registration
let C212 being non  empty VectSpStr over ( F_Complex );
cluster  additive  Real_homogeneous  homogeneous for (RFunctional of C212);
existence
proof
take ( 0RFunctional C212 );
thus L216: thesis;
end;
end;
definition
let C213 being non  empty VectSpStr over ( F_Complex );
mode Semi-Norm of C213
 is  subadditive  homogeneous (RFunctional of C213);
end;
begin
definition
let C214 being non  empty VectSpStr over ( F_Complex );
func RealVS C214 ->  strict RLSStruct means 
:L219: (( the addLoopStr of it ) = ( the addLoopStr of C214 ) & (for B118 being Real holds (for B119 being (Vector of C214) holds ( (the Mult of it) . (B118 , B119) ) = ( [** B118 , ( 0 ) **] * B119 ))));
existence
proof
deffunc H4((Element of ( REAL )) , (Element of C214)) = ( [** $1 , ( 0 ) **] * $2 );
consider C215 being (Function of [: ( REAL ) , (the carrier of C214) :] , (the carrier of C214)) such that L220: (for B120 being Real holds (for B121 being (Vector of C214) holds ( C215 . (B120 , B121) ) = H4(B120 , B121))) from BINOP_1:sch 4;
take D28 = RLSStruct (# (the carrier of C214) , ( 0. C214 ) , (the addF of C214) , C215 #);
thus L221: ( the addLoopStr of D28 ) = ( the addLoopStr of C214 );
let C216 being Real;
let C217 being (Vector of C214);
thus L222: thesis by L220;
end;
uniqueness
proof
let C218 , C219 being  strict RLSStruct;
assume that
L223: ( the addLoopStr of C218 ) = ( the addLoopStr of C214 )
and
L224: (for B122 being Real holds (for B123 being (Vector of C214) holds ( (the Mult of C218) . (B122 , B123) ) = ( [** B122 , ( 0 ) **] * B123 )))
and
L225: ( the addLoopStr of C219 ) = ( the addLoopStr of C214 )
and
L226: (for B124 being Real holds (for B125 being (Vector of C214) holds ( (the Mult of C219) . (B124 , B125) ) = ( [** B124 , ( 0 ) **] * B125 )));
L227:
now
let C220 being Real;
let C221 being (Vector of C214);
thus L228: ( (the Mult of C218) . (C220 , C221) ) = ( [** C220 , ( 0 ) **] * C221 ) by L224
.= ( (the Mult of C219) . (C220 , C221) ) by L226;
end;
thus L229: thesis by L227 , L223 , L225 , BINOP_1:2;
end;
end;
registration
let C222 being non  empty VectSpStr over ( F_Complex );
cluster ( RealVS C222 ) -> non  empty;
coherence
proof
L231: ( the addLoopStr of C222 ) = ( the addLoopStr of ( RealVS C222 ) ) by L219;
thus L232: thesis by L231;
end;
end;
registration
let C223 being  Abelian non  empty VectSpStr over ( F_Complex );
cluster ( RealVS C223 ) ->  Abelian;
coherence
proof
let C224 , C225 being (Element of ( RealVS C223 ));
L234: ( the addLoopStr of C223 ) = ( the addLoopStr of ( RealVS C223 ) ) by L219;
reconsider D29 = C224 , D30 = C225 as (Element of C223) by L234;
thus L235: ( C224 + C225 ) = ( D29 + D30 ) by L234
.= ( D30 + D29 )
.= ( C225 + C224 ) by L234;
end;
end;
registration
let C226 being  add-associative non  empty VectSpStr over ( F_Complex );
cluster ( RealVS C226 ) ->  add-associative;
coherence
proof
let C227 , C228 , C229 being (Element of ( RealVS C226 ));
L237: ( the addLoopStr of C226 ) = ( the addLoopStr of ( RealVS C226 ) ) by L219;
reconsider D31 = C227 , D32 = C228 , D33 = C229 as (Element of C226) by L237;
thus L238: ( ( C227 + C228 ) + C229 ) = ( ( D31 + D32 ) + D33 ) by L237
.= ( D31 + ( D32 + D33 ) ) by RLVECT_1:def 3
.= ( C227 + ( C228 + C229 ) ) by L237;
end;
end;
registration
let C230 being  right_zeroed non  empty VectSpStr over ( F_Complex );
cluster ( RealVS C230 ) ->  right_zeroed;
coherence
proof
let C231 being (Element of ( RealVS C230 ));
L240: ( the addLoopStr of C230 ) = ( the addLoopStr of ( RealVS C230 ) ) by L219;
reconsider D34 = C231 as (Element of C230) by L240;
thus L241: ( C231 + ( 0. ( RealVS C230 ) ) ) = ( D34 + ( 0. C230 ) ) by L240
.= C231 by RLVECT_1:def 4;
end;
end;
registration
let C232 being  right_complementable non  empty VectSpStr over ( F_Complex );
cluster ( RealVS C232 ) ->  right_complementable;
coherence
proof
let C233 being (Element of ( RealVS C232 ));
L243: ( the addLoopStr of C232 ) = ( the addLoopStr of ( RealVS C232 ) ) by L219;
reconsider D35 = C233 as (Element of C232) by L243;
consider C234 being (Element of C232) such that L244: ( D35 + C234 ) = ( 0. C232 ) by ALGSTR_0:def 11;
reconsider D36 = C234 as (Element of ( RealVS C232 )) by L243;
take D36;
thus L245: thesis by L243 , L244;
end;
end;
registration
let C235 being  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over ( F_Complex );
cluster ( RealVS C235 ) ->  vector-distributive  scalar-distributive  scalar-associative  scalar-unital;
coherence
proof
thus L247: (for B126 being  real number holds (for B127 , B128 being (Element of ( RealVS C235 )) holds ( B126 * ( B127 + B128 ) ) = ( ( B126 * B127 ) + ( B126 * B128 ) )))
proof
let C236 being  real number;
reconsider D37 = C236 as Real by XREAL_0:def 1;
let C237 , C238 being (Element of ( RealVS C235 ));
set D38 = [** D37 , ( 0 ) **];
L248: ( the addLoopStr of C235 ) = ( the addLoopStr of ( RealVS C235 ) ) by L219;
reconsider D39 = C237 , D40 = C238 as (Element of C235) by L248;
L249: ( D37 * ( C237 + C238 ) ) = ( [** D37 , ( 0 ) **] * ( D39 + D40 ) ) by L248 , L219
.= ( ( D38 * D39 ) + ( D38 * D40 ) ) by VECTSP_1:def 14
.= ( (the addF of C235) . [ ( (the Mult of ( RealVS C235 )) . (D37 , D39) ) , ( [** D37 , ( 0 ) **] * D40 ) ] ) by L219
.= ( ( D37 * C237 ) + ( D37 * C238 ) ) by L248 , L219;
thus L250: thesis by L249;
end;

thus L251: (for B129 , B130 being  real number holds (for B131 being (Element of ( RealVS C235 )) holds ( ( B129 + B130 ) * B131 ) = ( ( B129 * B131 ) + ( B130 * B131 ) )))
proof
let C239 , C240 being  real number;
reconsider D41 = C239 , D42 = C240 as Real by XREAL_0:def 1;
let C241 being (Element of ( RealVS C235 ));
set D43 = [** D41 , ( 0 ) **];
set D44 = [** D42 , ( 0 ) **];
L252: ( the addLoopStr of C235 ) = ( the addLoopStr of ( RealVS C235 ) ) by L219;
reconsider D45 = C241 as (Element of C235) by L252;
L253: ( [** D41 , ( 0 ) **] + [** D42 , ( 0 ) **] ) = [** ( D41 + D42 ) , ( 0 ) **];
L254: ( ( D41 + D42 ) * C241 ) = ( ( [** D41 , ( 0 ) **] + [** D42 , ( 0 ) **] ) * D45 ) by L253 , L219
.= ( ( D43 * D45 ) + ( D44 * D45 ) ) by VECTSP_1:def 15
.= ( (the addF of ( RealVS C235 )) . [ ( (the Mult of ( RealVS C235 )) . (D41 , C241) ) , ( [** D42 , ( 0 ) **] * D45 ) ] ) by L252 , L219
.= ( ( D41 * C241 ) + ( D42 * C241 ) ) by L219;
thus L255: thesis by L254;
end;

thus L256: (for B132 , B133 being  real number holds (for B134 being (Element of ( RealVS C235 )) holds ( ( B132 * B133 ) * B134 ) = ( B132 * ( B133 * B134 ) )))
proof
let C242 , C243 being  real number;
reconsider D46 = C242 , D47 = C243 as Real by XREAL_0:def 1;
let C244 being (Element of ( RealVS C235 ));
L257: ( the addLoopStr of C235 ) = ( the addLoopStr of ( RealVS C235 ) ) by L219;
reconsider D48 = C244 as (Element of C235) by L257;
L258: [** ( D46 * D47 ) , ( 0 ) **] = ( [** D46 , ( 0 ) **] * [** D47 , ( 0 ) **] );
L259: ( ( D46 * D47 ) * C244 ) = ( ( [** D46 , ( 0 ) **] * [** D47 , ( 0 ) **] ) * D48 ) by L258 , L219
.= ( [** D46 , ( 0 ) **] * ( [** D47 , ( 0 ) **] * D48 ) ) by VECTSP_1:def 16
.= ( (the Mult of ( RealVS C235 )) . (D46 , ( [** D47 , ( 0 ) **] * D48 )) ) by L219
.= ( D46 * ( D47 * C244 ) ) by L219;
thus L260: thesis by L259;
end;

let C245 being (Element of ( RealVS C235 ));
L261: ( the addLoopStr of C235 ) = ( the addLoopStr of ( RealVS C235 ) ) by L219;
reconsider D49 = C245 as (Element of C235) by L261;
thus L262: ( 1 * C245 ) = ( [** 1 , ( 0 ) **] * D49 ) by L219
.= C245 by COMPLFLD:8 , VECTSP_1:def 17;
end;
end;
theorem
L264: (for B135 being non  empty (VectSp of ( F_Complex )) holds (for B136 being (Subspace of B135) holds ( RealVS B136 ) is (Subspace of ( RealVS B135 ))))
proof
let C246 being non  empty (VectSp of ( F_Complex ));
let C247 being (Subspace of C246);
L265: (the carrier of C247) c= (the carrier of C246) by VECTSP_4:def 2;
L266: (the lmult of C247) = ( (the lmult of C246) | [: (the carrier of ( F_Complex )) , (the carrier of C247) :] ) by VECTSP_4:def 2;
L267: ( the addLoopStr of C247 ) = ( the addLoopStr of ( RealVS C247 ) ) by L219;
L268: ( the addLoopStr of C246 ) = ( the addLoopStr of ( RealVS C246 ) ) by L219;
thus L269: (the carrier of ( RealVS C247 )) c= (the carrier of ( RealVS C246 )) by L268 , L267 , VECTSP_4:def 2;
L270: [: ( REAL ) , (the carrier of ( RealVS C247 )) :] c= [: ( REAL ) , (the carrier of ( RealVS C246 )) :] by L269 , ZFMISC_1:95;
L271: [: ( REAL ) , (the carrier of ( RealVS C247 )) :] c= ( dom (the Mult of ( RealVS C246 )) ) by L270 , FUNCT_2:def 1;
L272: ( dom ( (the Mult of ( RealVS C246 )) | [: ( REAL ) , (the carrier of ( RealVS C247 )) :] ) ) = [: ( REAL ) , (the carrier of ( RealVS C247 )) :] by L271 , RELAT_1:62;
L273: ( rng ( (the Mult of ( RealVS C246 )) | [: ( REAL ) , (the carrier of ( RealVS C247 )) :] ) ) c= (the carrier of ( RealVS C247 ))
proof
let C248 being set;
assume L274: C248 in ( rng ( (the Mult of ( RealVS C246 )) | [: ( REAL ) , (the carrier of ( RealVS C247 )) :] ) );
consider C249 being set such that L275: C249 in ( dom ( (the Mult of ( RealVS C246 )) | [: ( REAL ) , (the carrier of ( RealVS C247 )) :] ) ) and L276: C248 = ( ( (the Mult of ( RealVS C246 )) | [: ( REAL ) , (the carrier of ( RealVS C247 )) :] ) . C249 ) by L274 , FUNCT_1:def 3;
consider C250 , C251 being set such that L277: C249 = [ C250 , C251 ] by L275 , RELAT_1:def 1;
reconsider D50 = C250 as Real by L275 , L277 , ZFMISC_1:87;
reconsider D51 = C251 as (Element of ( RealVS C247 )) by L272 , L275 , L277 , ZFMISC_1:87;
reconsider D52 = D51 as (Element of C247) by L267;
reconsider D53 = D52 as (Element of C246) by L265 , TARSKI:def 3;
L278: [ [** D50 , ( 0 ) **] , D53 ] in [: (the carrier of ( F_Complex )) , (the carrier of C246) :] by ZFMISC_1:87;
L279: ([ [** D50 , ( 0 ) **] , D52 ] in [: (the carrier of ( F_Complex )) , (the carrier of C247) :] & [ [** D50 , ( 0 ) **] , D53 ] in ( dom (the lmult of C246) )) by L278 , FUNCT_2:def 1 , ZFMISC_1:87;
L280: [ [** D50 , ( 0 ) **] , D53 ] in ( ( dom (the lmult of C246) ) /\ [: (the carrier of ( F_Complex )) , (the carrier of C247) :] ) by L279 , XBOOLE_0:def 4;
L281: [ [** D50 , ( 0 ) **] , D53 ] in ( dom ( (the lmult of C246) | [: (the carrier of ( F_Complex )) , (the carrier of C247) :] ) ) by L280 , RELAT_1:61;
L282: C248 = ( (the Mult of ( RealVS C246 )) . (D50 , D51) ) by L275 , L276 , L277 , FUNCT_1:47
.= ( [** D50 , ( 0 ) **] * D53 ) by L219
.= ( [** D50 , ( 0 ) **] * D52 ) by L266 , L281 , FUNCT_1:47
.= ( (the Mult of ( RealVS C247 )) . (D50 , D51) ) by L219;
thus L283: thesis by L282;
end;
reconsider D54 = ( (the Mult of ( RealVS C246 )) | [: ( REAL ) , (the carrier of ( RealVS C247 )) :] ) as (Function of [: ( REAL ) , (the carrier of ( RealVS C247 )) :] , (the carrier of ( RealVS C247 ))) by L273 , L272 , FUNCT_2:2;
thus L284: ( 0. ( RealVS C247 ) ) = ( 0. C247 ) by L267
.= ( 0. C246 ) by VECTSP_4:def 2
.= ( 0. ( RealVS C246 ) ) by L268;
thus L285: (the addF of ( RealVS C247 )) = ( (the addF of ( RealVS C246 )) || (the carrier of ( RealVS C247 )) ) by L267 , L268 , VECTSP_4:def 2;
L286:
now
let C252 being Real;
let C253 being (Element of ( RealVS C247 ));
reconsider D55 = C253 as (Element of C247) by L267;
reconsider D56 = D55 as (Element of C246) by L265 , TARSKI:def 3;
L287: [ [** C252 , ( 0 ) **] , D56 ] in [: (the carrier of ( F_Complex )) , (the carrier of C246) :] by ZFMISC_1:87;
L288: ([ [** C252 , ( 0 ) **] , D55 ] in [: (the carrier of ( F_Complex )) , (the carrier of C247) :] & [ [** C252 , ( 0 ) **] , D56 ] in ( dom (the lmult of C246) )) by L287 , FUNCT_2:def 1 , ZFMISC_1:87;
L289: [ [** C252 , ( 0 ) **] , D56 ] in ( ( dom (the lmult of C246) ) /\ [: (the carrier of ( F_Complex )) , (the carrier of C247) :] ) by L288 , XBOOLE_0:def 4;
L290: [ [** C252 , ( 0 ) **] , D56 ] in ( dom ( (the lmult of C246) | [: (the carrier of ( F_Complex )) , (the carrier of C247) :] ) ) by L289 , RELAT_1:61;
L291: C253 in (the carrier of ( RealVS C246 )) by L269 , TARSKI:def 3;
L292: [ C252 , C253 ] in [: ( REAL ) , (the carrier of ( RealVS C246 )) :] by L291 , ZFMISC_1:87;
L293: ([ C252 , C253 ] in [: ( REAL ) , (the carrier of ( RealVS C247 )) :] & [ C252 , C253 ] in ( dom (the Mult of ( RealVS C246 )) )) by L292 , FUNCT_2:def 1 , ZFMISC_1:87;
L294: [ C252 , C253 ] in ( ( dom (the Mult of ( RealVS C246 )) ) /\ [: ( REAL ) , (the carrier of ( RealVS C247 )) :] ) by L293 , XBOOLE_0:def 4;
L295: [ C252 , C253 ] in ( dom D54 ) by L294 , RELAT_1:61;
thus L296: ( (the Mult of ( RealVS C247 )) . (C252 , C253) ) = ( [** C252 , ( 0 ) **] * D55 ) by L219
.= ( [** C252 , ( 0 ) **] * D56 ) by L266 , L290 , FUNCT_1:47
.= ( (the Mult of ( RealVS C246 )) . (C252 , C253) ) by L219
.= ( D54 . (C252 , C253) ) by L295 , FUNCT_1:47;
end;
thus L297: (the Mult of ( RealVS C247 )) = ( (the Mult of ( RealVS C246 )) | [: ( REAL ) , (the carrier of ( RealVS C247 )) :] ) by L286 , BINOP_1:2;
end;
theorem
L298: (for B137 being non  empty VectSpStr over ( F_Complex ) holds (for B138 being (RFunctional of B137) holds B138 is (Functional of ( RealVS B137 ))))
proof
let C254 being non  empty VectSpStr over ( F_Complex );
let C255 being (RFunctional of C254);
L299: ( the addLoopStr of C254 ) = ( the addLoopStr of ( RealVS C254 ) ) by L219;
thus L300: thesis by L299;
end;
theorem
L301: (for B139 being non  empty (VectSp of ( F_Complex )) holds (for B140 being (Semi-Norm of B139) holds B140 is (Banach-Functional of ( RealVS B139 ))))
proof
let C256 being non  empty (VectSp of ( F_Complex ));
let C257 being (Semi-Norm of C256);
reconsider D57 = C257 as (Functional of ( RealVS C256 )) by L298;
L302: D57 is  positively_homogeneous
proof
let C258 being (VECTOR of ( RealVS C256 ));
let C259 being Real;
assume L303: C259 > ( 0 );
L304: ( the addLoopStr of C256 ) = ( the addLoopStr of ( RealVS C256 ) ) by L219;
reconsider D58 = C258 as (Vector of C256) by L304;
L305: ( C259 * C258 ) = ( [** C259 , ( 0 ) **] * D58 ) by L219;
thus L306: ( D57 . ( C259 * C258 ) ) = ( ( abs C259 ) * ( D57 . C258 ) ) by L305 , L194
.= ( C259 * ( D57 . C258 ) ) by L303 , ABSVALUE:def 1;
end;
L307: D57 is  subadditive
proof
let C260 , C261 being (VECTOR of ( RealVS C256 ));
L308: ( the addLoopStr of C256 ) = ( the addLoopStr of ( RealVS C256 ) ) by L219;
reconsider D59 = C260 , D60 = C261 as (Vector of C256) by L308;
L309: ( C260 + C261 ) = ( D59 + D60 ) by L308;
thus L310: thesis by L309 , L185;
end;
thus L311: thesis by L307 , L302;
end;
definition
let C262 being non  empty VectSpStr over ( F_Complex );
let C263 being (Functional of C262);
func projRe C263 -> (Functional of ( RealVS C262 )) means 
:L312: (for B141 being (Element of C262) holds ( it . B141 ) = ( Re ( C263 . B141 ) ));
existence
proof
deffunc H5((Element of C262)) = ( Re ( C263 . $1 ) );
consider C264 being (Function of (the carrier of C262) , ( REAL )) such that L313: (for B142 being (Element of C262) holds ( C264 . B142 ) = H5(B142)) from FUNCT_2:sch 4;
L314: ( the addLoopStr of C262 ) = ( the addLoopStr of ( RealVS C262 ) ) by L219;
reconsider D61 = C264 as (Functional of ( RealVS C262 )) by L314;
take D61;
thus L315: thesis by L313;
end;
uniqueness
proof
let C265 , C266 being (Functional of ( RealVS C262 ));
assume L316: (for B143 being (Element of C262) holds ( C265 . B143 ) = ( Re ( C263 . B143 ) ));
assume L317: (for B144 being (Element of C262) holds ( C266 . B144 ) = ( Re ( C263 . B144 ) ));
L318:
now
let C267 being (Element of ( RealVS C262 ));
L319: ( the addLoopStr of C262 ) = ( the addLoopStr of ( RealVS C262 ) ) by L219;
reconsider D62 = C267 as (Element of C262) by L319;
thus L320: ( C265 . C267 ) = ( Re ( C263 . D62 ) ) by L316
.= ( C266 . C267 ) by L317;
end;
thus L321: C265 = C266 by L318 , FUNCT_2:63;
end;
end;
definition
let C268 being non  empty VectSpStr over ( F_Complex );
let C269 being (Functional of C268);
func projIm C269 -> (Functional of ( RealVS C268 )) means 
:L323: (for B145 being (Element of C268) holds ( it . B145 ) = ( Im ( C269 . B145 ) ));
existence
proof
deffunc H6((Element of C268)) = ( Im ( C269 . $1 ) );
consider C270 being (Function of (the carrier of C268) , ( REAL )) such that L324: (for B146 being (Element of C268) holds ( C270 . B146 ) = H6(B146)) from FUNCT_2:sch 4;
L325: ( the addLoopStr of C268 ) = ( the addLoopStr of ( RealVS C268 ) ) by L219;
reconsider D63 = C270 as (Functional of ( RealVS C268 )) by L325;
take D63;
thus L326: thesis by L324;
end;
uniqueness
proof
let C271 , C272 being (Functional of ( RealVS C268 ));
assume L327: (for B147 being (Element of C268) holds ( C271 . B147 ) = ( Im ( C269 . B147 ) ));
assume L328: (for B148 being (Element of C268) holds ( C272 . B148 ) = ( Im ( C269 . B148 ) ));
L329:
now
let C273 being (Element of ( RealVS C268 ));
L330: ( the addLoopStr of C268 ) = ( the addLoopStr of ( RealVS C268 ) ) by L219;
reconsider D64 = C273 as (Element of C268) by L330;
thus L331: ( C271 . C273 ) = ( Im ( C269 . D64 ) ) by L327
.= ( C272 . C273 ) by L328;
end;
thus L332: C271 = C272 by L329 , FUNCT_2:63;
end;
end;
definition
let C274 being non  empty VectSpStr over ( F_Complex );
let C275 being (Functional of ( RealVS C274 ));
func RtoC C275 -> (RFunctional of C274) equals 
C275;
coherence
proof
L334: ( the addLoopStr of C274 ) = ( the addLoopStr of ( RealVS C274 ) ) by L219;
thus L335: thesis by L334;
end;
end;
definition
let C276 being non  empty VectSpStr over ( F_Complex );
let C277 being (RFunctional of C276);
func CtoR C277 -> (Functional of ( RealVS C276 )) equals 
C277;
coherence
proof
L337: ( the addLoopStr of C276 ) = ( the addLoopStr of ( RealVS C276 ) ) by L219;
thus L338: thesis by L337;
end;
end;
registration
let C278 being non  empty (VectSp of ( F_Complex ));
let C279 being  additive (Functional of ( RealVS C278 ));
cluster ( RtoC C279 ) ->  additive;
coherence
proof
let C280 , C281 being (Vector of C278);
L340: ( the addLoopStr of C278 ) = ( the addLoopStr of ( RealVS C278 ) ) by L219;
reconsider D65 = C280 , D66 = C281 as (VECTOR of ( RealVS C278 )) by L340;
L341: ( C280 + C281 ) = ( D65 + D66 ) by L340;
thus L342: ( ( RtoC C279 ) . ( C280 + C281 ) ) = ( ( ( RtoC C279 ) . C280 ) + ( ( RtoC C279 ) . C281 ) ) by L341 , HAHNBAN:def 2;
end;
end;
registration
let C282 being non  empty (VectSp of ( F_Complex ));
let C283 being  additive (RFunctional of C282);
cluster ( CtoR C283 ) ->  additive;
coherence
proof
let C284 , C285 being (VECTOR of ( RealVS C282 ));
L344: ( the addLoopStr of C282 ) = ( the addLoopStr of ( RealVS C282 ) ) by L219;
reconsider D67 = C284 , D68 = C285 as (Vector of C282) by L344;
L345: ( C284 + C285 ) = ( D67 + D68 ) by L344;
thus L346: thesis by L345 , L187;
end;
end;
registration
let C286 being non  empty (VectSp of ( F_Complex ));
let C287 being  homogeneous (Functional of ( RealVS C286 ));
cluster ( RtoC C287 ) ->  Real_homogeneous;
coherence
proof
let C288 being (Vector of C286);
let C289 being Real;
L348: ( the addLoopStr of C286 ) = ( the addLoopStr of ( RealVS C286 ) ) by L219;
reconsider D69 = C288 as (VECTOR of ( RealVS C286 )) by L348;
L349: ( [** C289 , ( 0 ) **] * C288 ) = ( C289 * D69 ) by L219;
thus L350: thesis by L349 , HAHNBAN:def 3;
end;
end;
registration
let C290 being non  empty (VectSp of ( F_Complex ));
let C291 being  Real_homogeneous (RFunctional of C290);
cluster ( CtoR C291 ) ->  homogeneous;
coherence
proof
let C292 being (VECTOR of ( RealVS C290 ));
let C293 being Real;
L352: ( the addLoopStr of C290 ) = ( the addLoopStr of ( RealVS C290 ) ) by L219;
reconsider D70 = C292 as (Vector of C290) by L352;
L353: ( [** C293 , ( 0 ) **] * D70 ) = ( C293 * C292 ) by L219;
thus L354: thesis by L353 , L189;
end;
end;
definition
let C294 being non  empty VectSpStr over ( F_Complex );
let C295 being (RFunctional of C294);
func i-shift C295 -> (RFunctional of C294) means 
:L356: (for B149 being (Element of C294) holds ( it . B149 ) = ( C295 . ( ( i_FC ) * B149 ) ));
existence
proof
deffunc H7((Element of C294)) = ( C295 . ( ( i_FC ) * $1 ) );
consider C296 being (Function of (the carrier of C294) , ( REAL )) such that L357: (for B150 being (Element of C294) holds ( C296 . B150 ) = H7(B150)) from FUNCT_2:sch 4;
reconsider D71 = C296 as (RFunctional of C294);
take D71;
thus L358: thesis by L357;
end;
uniqueness
proof
let C297 , C298 being (RFunctional of C294);
assume that
L359: (for B151 being (Element of C294) holds ( C297 . B151 ) = ( C295 . ( ( i_FC ) * B151 ) ))
and
L360: (for B152 being (Element of C294) holds ( C298 . B152 ) = ( C295 . ( ( i_FC ) * B152 ) ));
L361:
now
let C299 being (Element of C294);
thus L362: ( C297 . C299 ) = ( C295 . ( ( i_FC ) * C299 ) ) by L359
.= ( C298 . C299 ) by L360;
end;
thus L363: C297 = C298 by L361 , FUNCT_2:63;
end;
end;
definition
let C300 being non  empty VectSpStr over ( F_Complex );
let C301 being (Functional of ( RealVS C300 ));
func prodReIm C301 -> (Functional of C300) means 
:L365: (for B153 being (Element of C300) holds ( it . B153 ) = [** ( ( RtoC C301 ) . B153 ) , ( - ( ( i-shift ( RtoC C301 ) ) . B153 ) ) **]);
existence
proof
deffunc H8((Element of C300)) = [** ( ( RtoC C301 ) . $1 ) , ( - ( ( i-shift ( RtoC C301 ) ) . $1 ) ) **];
consider C302 being (Function of (the carrier of C300) , (the carrier of ( F_Complex ))) such that L366: (for B154 being (Element of C300) holds ( C302 . B154 ) = H8(B154)) from FUNCT_2:sch 4;
reconsider D72 = C302 as (Functional of C300);
take D72;
thus L367: thesis by L366;
end;
uniqueness
proof
let C303 , C304 being (Functional of C300);
assume L368: (for B155 being (Element of C300) holds ( C303 . B155 ) = [** ( ( RtoC C301 ) . B155 ) , ( - ( ( i-shift ( RtoC C301 ) ) . B155 ) ) **]);
assume L369: (for B156 being (Element of C300) holds ( C304 . B156 ) = [** ( ( RtoC C301 ) . B156 ) , ( - ( ( i-shift ( RtoC C301 ) ) . B156 ) ) **]);
L370:
now
let C305 being (Element of C300);
thus L371: ( C303 . C305 ) = [** ( ( RtoC C301 ) . C305 ) , ( - ( ( i-shift ( RtoC C301 ) ) . C305 ) ) **] by L368
.= ( C304 . C305 ) by L369;
end;
thus L372: C303 = C304 by L370 , FUNCT_2:63;
end;
end;
theorem
L374: (for B157 being non  empty (VectSp of ( F_Complex )) holds (for B158 being (linear-Functional of B157) holds ( projRe B158 ) is (linear-Functional of ( RealVS B157 ))))
proof
let C306 being non  empty (VectSp of ( F_Complex ));
let C307 being (linear-Functional of C306);
L375: ( projRe C307 ) is  homogeneous
proof
let C308 being (VECTOR of ( RealVS C306 ));
let C309 being Real;
L376: ( the addLoopStr of C306 ) = ( the addLoopStr of ( RealVS C306 ) ) by L219;
reconsider D73 = C308 as (Vector of C306) by L376;
L377: ( C309 * C308 ) = ( [** C309 , ( 0 ) **] * D73 ) by L219;
thus L378: ( ( projRe C307 ) . ( C309 * C308 ) ) = ( Re ( C307 . ( [** C309 , ( 0 ) **] * D73 ) ) ) by L377 , L312
.= ( Re ( [** C309 , ( 0 ) **] * ( C307 . D73 ) ) ) by L64
.= ( ( ( Re [** C309 , ( 0 ) **] ) * ( Re ( C307 . D73 ) ) ) - ( ( Im [** C309 , ( 0 ) **] ) * ( Im ( C307 . D73 ) ) ) ) by COMPLEX1:9
.= ( ( ( Re [** C309 , ( 0 ) **] ) * ( Re ( C307 . D73 ) ) ) - ( ( 0 ) * ( Im ( C307 . D73 ) ) ) ) by COMPLEX1:12
.= ( C309 * ( Re ( C307 . D73 ) ) ) by COMPLEX1:12
.= ( C309 * ( ( projRe C307 ) . C308 ) ) by L312;
end;
L379: ( projRe C307 ) is  additive
proof
let C310 , C311 being (VECTOR of ( RealVS C306 ));
L380: ( the addLoopStr of C306 ) = ( the addLoopStr of ( RealVS C306 ) ) by L219;
reconsider D74 = C310 , D75 = C311 as (Vector of C306) by L380;
thus L381: ( ( projRe C307 ) . ( C310 + C311 ) ) = ( Re ( C307 . ( D74 + D75 ) ) ) by L380 , L312
.= ( Re ( ( C307 . D74 ) + ( C307 . D75 ) ) ) by VECTSP_1:def 20
.= ( ( Re ( C307 . D74 ) ) + ( Re ( C307 . D75 ) ) ) by COMPLEX1:8
.= ( ( Re ( C307 . D74 ) ) + ( ( projRe C307 ) . C311 ) ) by L312
.= ( ( ( projRe C307 ) . C310 ) + ( ( projRe C307 ) . C311 ) ) by L312;
end;
thus L382: thesis by L379 , L375;
end;
theorem
L383: (for B159 being non  empty (VectSp of ( F_Complex )) holds (for B160 being (linear-Functional of B159) holds ( projIm B160 ) is (linear-Functional of ( RealVS B159 ))))
proof
let C312 being non  empty (VectSp of ( F_Complex ));
let C313 being (linear-Functional of C312);
L384: ( projIm C313 ) is  homogeneous
proof
let C314 being (VECTOR of ( RealVS C312 ));
let C315 being Real;
L385: ( the addLoopStr of C312 ) = ( the addLoopStr of ( RealVS C312 ) ) by L219;
reconsider D76 = C314 as (Vector of C312) by L385;
L386: ( C315 * C314 ) = ( [** C315 , ( 0 ) **] * D76 ) by L219;
thus L387: ( ( projIm C313 ) . ( C315 * C314 ) ) = ( Im ( C313 . ( [** C315 , ( 0 ) **] * D76 ) ) ) by L386 , L323
.= ( Im ( [** C315 , ( 0 ) **] * ( C313 . D76 ) ) ) by L64
.= ( ( ( Re [** C315 , ( 0 ) **] ) * ( Im ( C313 . D76 ) ) ) + ( ( Re ( C313 . D76 ) ) * ( Im [** C315 , ( 0 ) **] ) ) ) by COMPLEX1:9
.= ( ( ( Re [** C315 , ( 0 ) **] ) * ( Im ( C313 . D76 ) ) ) + ( ( Re ( C313 . D76 ) ) * ( 0 ) ) ) by COMPLEX1:12
.= ( C315 * ( Im ( C313 . D76 ) ) ) by COMPLEX1:12
.= ( C315 * ( ( projIm C313 ) . C314 ) ) by L323;
end;
L388: ( projIm C313 ) is  additive
proof
let C316 , C317 being (VECTOR of ( RealVS C312 ));
L389: ( the addLoopStr of C312 ) = ( the addLoopStr of ( RealVS C312 ) ) by L219;
reconsider D77 = C316 , D78 = C317 as (Vector of C312) by L389;
thus L390: ( ( projIm C313 ) . ( C316 + C317 ) ) = ( Im ( C313 . ( D77 + D78 ) ) ) by L389 , L323
.= ( Im ( ( C313 . D77 ) + ( C313 . D78 ) ) ) by VECTSP_1:def 20
.= ( ( Im ( C313 . D77 ) ) + ( Im ( C313 . D78 ) ) ) by COMPLEX1:8
.= ( ( Im ( C313 . D77 ) ) + ( ( projIm C313 ) . C317 ) ) by L323
.= ( ( ( projIm C313 ) . C316 ) + ( ( projIm C313 ) . C317 ) ) by L323;
end;
thus L391: thesis by L388 , L384;
end;
theorem
L392: (for B161 being non  empty (VectSp of ( F_Complex )) holds (for B162 being (linear-Functional of ( RealVS B161 )) holds ( prodReIm B162 ) is (linear-Functional of B161)))
proof
let C318 being non  empty (VectSp of ( F_Complex ));
let C319 being (linear-Functional of ( RealVS C318 ));
L393: ( prodReIm C319 ) is  homogeneous
proof
let C320 being (Vector of C318);
let C321 being (Scalar of C318);
reconsider D79 = C321 as (Element of ( COMPLEX )) by COMPLFLD:def 1;
set D80 = ( Re D79 );
set D81 = ( Im D79 );
L394: D79 = ( D80 + ( D81 * ( <i> ) ) ) by COMPLEX1:13;
L395: ( - ( 1_ ( F_Complex ) ) ) = [** ( - 1 ) , ( 0 ) **] by COMPLFLD:2 , COMPLFLD:8;
L396: C320 = ( ( ( i_FC ) * ( ( i_FC ) * ( - ( 1_ ( F_Complex ) ) ) ) ) * C320 ) by L24 , L26 , VECTSP_1:def 17
.= ( ( i_FC ) * ( ( ( - ( 1_ ( F_Complex ) ) ) * ( i_FC ) ) * C320 ) ) by VECTSP_1:def 16;
L397: ( ( D80 * ( - ( ( RtoC C319 ) . ( ( i_FC ) * C320 ) ) ) ) + ( ( ( RtoC C319 ) . C320 ) * D81 ) ) = ( ( - ( D80 * ( ( RtoC C319 ) . ( ( i_FC ) * C320 ) ) ) ) + ( D81 * ( ( RtoC C319 ) . ( ( i_FC ) * ( ( ( - ( 1_ ( F_Complex ) ) ) * ( i_FC ) ) * C320 ) ) ) ) ) by L396
.= ( ( - ( ( RtoC C319 ) . ( [** D80 , ( 0 ) **] * ( ( i_FC ) * C320 ) ) ) ) + ( - ( ( - D81 ) * ( ( RtoC C319 ) . ( ( i_FC ) * ( ( ( - ( 1_ ( F_Complex ) ) ) * ( i_FC ) ) * C320 ) ) ) ) ) ) by L189
.= ( ( - ( ( RtoC C319 ) . ( [** D80 , ( 0 ) **] * ( ( i_FC ) * C320 ) ) ) ) + ( - ( ( RtoC C319 ) . ( [** ( 0 ) , ( - D81 ) **] * ( ( ( - ( 1_ ( F_Complex ) ) ) * ( i_FC ) ) * C320 ) ) ) ) ) by L191
.= ( ( - ( ( RtoC C319 ) . ( [** D80 , ( 0 ) **] * ( ( i_FC ) * C320 ) ) ) ) + ( - ( ( RtoC C319 ) . ( [** ( 0 ) , ( - D81 ) **] * ( ( - ( 1_ ( F_Complex ) ) ) * ( ( i_FC ) * C320 ) ) ) ) ) ) by VECTSP_1:def 16
.= ( ( - ( ( RtoC C319 ) . ( [** D80 , ( 0 ) **] * ( ( i_FC ) * C320 ) ) ) ) + ( - ( ( RtoC C319 ) . ( ( [** ( 0 ) , ( - D81 ) **] * ( - ( 1_ ( F_Complex ) ) ) ) * ( ( i_FC ) * C320 ) ) ) ) ) by VECTSP_1:def 16
.= ( - ( ( ( RtoC C319 ) . ( [** D80 , ( 0 ) **] * ( ( i_FC ) * C320 ) ) ) + ( ( RtoC C319 ) . ( [** ( 0 ) , D81 **] * ( ( i_FC ) * C320 ) ) ) ) ) by L395
.= ( - ( ( RtoC C319 ) . ( ( [** D80 , ( 0 ) **] * ( ( i_FC ) * C320 ) ) + ( [** ( 0 ) , D81 **] * ( ( i_FC ) * C320 ) ) ) ) ) by L187
.= ( - ( ( RtoC C319 ) . ( ( [** D80 , ( 0 ) **] + [** ( 0 ) , D81 **] ) * ( ( i_FC ) * C320 ) ) ) ) by VECTSP_1:def 15
.= ( - ( ( RtoC C319 ) . ( ( ( i_FC ) * C321 ) * C320 ) ) ) by L394 , VECTSP_1:def 16;
L398: ( ( D80 * ( ( RtoC C319 ) . C320 ) ) - ( D81 * ( - ( ( RtoC C319 ) . ( ( i_FC ) * C320 ) ) ) ) ) = ( ( D80 * ( ( RtoC C319 ) . C320 ) ) + ( D81 * ( ( RtoC C319 ) . ( ( i_FC ) * C320 ) ) ) )
.= ( ( ( RtoC C319 ) . ( [** D80 , ( 0 ) **] * C320 ) ) + ( D81 * ( ( RtoC C319 ) . ( ( i_FC ) * C320 ) ) ) ) by L189
.= ( ( ( RtoC C319 ) . ( [** D80 , ( 0 ) **] * C320 ) ) + ( ( RtoC C319 ) . ( [** ( 0 ) , D81 **] * C320 ) ) ) by L191
.= ( ( RtoC C319 ) . ( ( [** D80 , ( 0 ) **] * C320 ) + ( [** ( 0 ) , D81 **] * C320 ) ) ) by L187
.= ( ( RtoC C319 ) . ( ( [** D80 , ( 0 ) **] + [** ( 0 ) , D81 **] ) * C320 ) ) by VECTSP_1:def 15
.= ( ( RtoC C319 ) . ( C321 * C320 ) ) by COMPLEX1:13;
thus L399: ( ( prodReIm C319 ) . ( C321 * C320 ) ) = [** ( ( RtoC C319 ) . ( C321 * C320 ) ) , ( - ( ( i-shift ( RtoC C319 ) ) . ( C321 * C320 ) ) ) **] by L365
.= [** ( ( RtoC C319 ) . ( C321 * C320 ) ) , ( - ( ( RtoC C319 ) . ( ( i_FC ) * ( C321 * C320 ) ) ) ) **] by L356
.= ( ( ( RtoC C319 ) . ( C321 * C320 ) ) + ( ( ( D80 * ( - ( ( RtoC C319 ) . ( ( i_FC ) * C320 ) ) ) ) + ( ( ( RtoC C319 ) . C320 ) * D81 ) ) * ( <i> ) ) ) by L397 , VECTSP_1:def 16
.= ( C321 * [** ( ( RtoC C319 ) . C320 ) , ( - ( ( RtoC C319 ) . ( ( i_FC ) * C320 ) ) ) **] ) by L394 , L398
.= ( C321 * [** ( ( RtoC C319 ) . C320 ) , ( - ( ( i-shift ( RtoC C319 ) ) . C320 ) ) **] ) by L356
.= ( C321 * ( ( prodReIm C319 ) . C320 ) ) by L365;
end;
L400: ( prodReIm C319 ) is  additive
proof
let C322 , C323 being (Vector of C318);
thus L401: ( ( prodReIm C319 ) . ( C322 + C323 ) ) = [** ( ( RtoC C319 ) . ( C322 + C323 ) ) , ( - ( ( i-shift ( RtoC C319 ) ) . ( C322 + C323 ) ) ) **] by L365
.= [** ( ( RtoC C319 ) . ( C322 + C323 ) ) , ( - ( ( RtoC C319 ) . ( ( i_FC ) * ( C322 + C323 ) ) ) ) **] by L356
.= [** ( ( ( RtoC C319 ) . C322 ) + ( ( RtoC C319 ) . C323 ) ) , ( - ( ( RtoC C319 ) . ( ( i_FC ) * ( C322 + C323 ) ) ) ) **] by L187
.= [** ( ( ( RtoC C319 ) . C322 ) + ( ( RtoC C319 ) . C323 ) ) , ( - ( ( RtoC C319 ) . ( ( ( i_FC ) * C322 ) + ( ( i_FC ) * C323 ) ) ) ) **] by VECTSP_1:def 14
.= [** ( ( ( RtoC C319 ) . C322 ) + ( ( RtoC C319 ) . C323 ) ) , ( - ( ( ( RtoC C319 ) . ( ( i_FC ) * C322 ) ) + ( ( RtoC C319 ) . ( ( i_FC ) * C323 ) ) ) ) **] by L187
.= ( [** ( ( RtoC C319 ) . C322 ) , ( - ( ( RtoC C319 ) . ( ( i_FC ) * C322 ) ) ) **] + [** ( ( RtoC C319 ) . C323 ) , ( - ( ( RtoC C319 ) . ( ( i_FC ) * C323 ) ) ) **] )
.= ( [** ( ( RtoC C319 ) . C322 ) , ( - ( ( i-shift ( RtoC C319 ) ) . C322 ) ) **] + [** ( ( RtoC C319 ) . C323 ) , ( - ( ( RtoC C319 ) . ( ( i_FC ) * C323 ) ) ) **] ) by L356
.= ( [** ( ( RtoC C319 ) . C322 ) , ( - ( ( i-shift ( RtoC C319 ) ) . C322 ) ) **] + [** ( ( RtoC C319 ) . C323 ) , ( - ( ( i-shift ( RtoC C319 ) ) . C323 ) ) **] ) by L356
.= ( ( ( prodReIm C319 ) . C322 ) + [** ( ( RtoC C319 ) . C323 ) , ( - ( ( i-shift ( RtoC C319 ) ) . C323 ) ) **] ) by L365
.= ( ( ( prodReIm C319 ) . C322 ) + ( ( prodReIm C319 ) . C323 ) ) by L365;
end;
thus L402: thesis by L400 , L393;
end;
::$N Hahn-Banach Theorem  (complex spaces)
theorem
L403: (for B163 being non  empty (VectSp of ( F_Complex )) holds (for B164 being (Semi-Norm of B163) holds (for B165 being (Subspace of B163) holds (for B166 being (linear-Functional of B165) holds ((for B167 being (Vector of B165) holds (for B168 being (Vector of B163) holds (B168 = B167 implies |. ( B166 . B167 ) .| <= ( B164 . B168 )))) implies (ex B169 being (linear-Functional of B163) st (( B169 | (the carrier of B165) ) = B166 & (for B170 being (Vector of B163) holds |. ( B169 . B170 ) .| <= ( B164 . B170 )))))))))
proof
let C324 being non  empty (VectSp of ( F_Complex ));
let C325 being (Semi-Norm of C324);
reconsider D82 = C325 as (Banach-Functional of ( RealVS C324 )) by L301;
let C326 being (Subspace of C324);
reconsider D83 = (the carrier of C326) as (Subset of C324) by VECTSP_4:def 2;
reconsider D84 = ( RealVS C326 ) as (Subspace of ( RealVS C324 )) by L264;
let C327 being (linear-Functional of C326);
reconsider D85 = ( projRe C327 ) as (linear-Functional of D84) by L374;
L404: ( the addLoopStr of C324 ) = ( the addLoopStr of ( RealVS C324 ) ) by L219;
L405: ( the addLoopStr of C326 ) = ( the addLoopStr of ( RealVS C326 ) ) by L219;
assume L406: (for B171 being (Vector of C326) holds (for B172 being (Vector of C324) holds (B172 = B171 implies |. ( C327 . B171 ) .| <= ( C325 . B172 ))));
L407: (for B173 being (VECTOR of D84) holds (for B174 being (VECTOR of ( RealVS C324 )) holds (B173 = B174 implies ( D85 . B173 ) <= ( D82 . B174 ))))
proof
let C328 being (VECTOR of D84);
reconsider D86 = C328 as (Vector of C326) by L405;
let C329 being (VECTOR of ( RealVS C324 ));
reconsider D87 = C329 as (Vector of C324) by L404;
L408: ( D85 . C328 ) = ( Re ( C327 . D86 ) ) by L312;
L409: ( D85 . C328 ) <= |. ( C327 . D86 ) .| by L408 , COMPLEX1:54;
assume L410: C328 = C329;
L411: |. ( C327 . D86 ) .| <= ( C325 . D87 ) by L410 , L406;
thus L412: thesis by L411 , L409 , XXREAL_0:2;
end;
consider C330 being (linear-Functional of ( RealVS C324 )) such that L413: ( C330 | (the carrier of D84) ) = D85 and L414: (for B175 being (VECTOR of ( RealVS C324 )) holds ( C330 . B175 ) <= ( D82 . B175 )) by L407 , HAHNBAN:22;
reconsider D88 = ( prodReIm C330 ) as (linear-Functional of C324) by L392;
take D88;
L415:
now
let C331 being (Element of C326);
L416: (the carrier of C326) c= (the carrier of C324) by VECTSP_4:def 2;
reconsider D89 = C331 as (Element of C324) by L416 , TARSKI:def 3;
reconsider D90 = D89 , D91 = ( ( i_FC ) * D89 ) as (Element of ( RealVS C324 )) by L404;
reconsider D92 = ( C327 . C331 ) as (Element of ( COMPLEX )) by COMPLFLD:def 1;
L417: D92 = ( ( Re D92 ) + ( ( Im D92 ) * ( <i> ) ) ) by COMPLEX1:13;
L418: ( ( i_FC ) * ( C327 . C331 ) ) = ( ( ( ( 0 ) * ( Re D92 ) ) - ( 1 * ( Im D92 ) ) ) + ( ( ( ( 0 ) * ( Im D92 ) ) + ( 1 * ( Re D92 ) ) ) * ( <i> ) ) ) by L417;
L419: ( ( i_FC ) * C331 ) = ( ( i_FC ) * D89 ) by VECTSP_4:14;
L420: ( C330 . D91 ) = ( ( projRe C327 ) . D91 ) by L419 , L405 , L413 , FUNCT_1:49
.= ( Re ( C327 . ( ( i_FC ) * C331 ) ) ) by L419 , L312
.= ( Re ( ( - ( Im D92 ) ) + ( ( Re D92 ) * ( <i> ) ) ) ) by L418 , L64
.= ( - ( Im ( C327 . C331 ) ) ) by COMPLEX1:12;
L421: ( C330 . D90 ) = ( ( projRe C327 ) . D90 ) by L405 , L413 , FUNCT_1:49
.= ( Re ( C327 . C331 ) ) by L312;
thus L422: ( ( D88 | D83 ) . C331 ) = ( D88 . C331 ) by FUNCT_1:49
.= [** ( ( RtoC C330 ) . D89 ) , ( - ( ( i-shift ( RtoC C330 ) ) . D89 ) ) **] by L365
.= [** ( Re ( C327 . C331 ) ) , ( - ( ( RtoC C330 ) . ( ( i_FC ) * D89 ) ) ) **] by L421 , L356
.= ( C327 . C331 ) by L420 , COMPLEX1:13;
end;
thus L423: ( D88 | (the carrier of C326) ) = C327 by L415 , FUNCT_2:63;
let C332 being (Vector of C324);
reconsider D93 = ( D88 . C332 ) as (Element of ( COMPLEX )) by COMPLFLD:def 1;
reconsider D94 = ( ( D93 *' ) / |. D93 .| ) as (Element of ( F_Complex )) by COMPLFLD:def 1;
reconsider D95 = C332 , D96 = ( D94 * C332 ) as (VECTOR of ( RealVS C324 )) by L404;
per cases ;
suppose L424: |. D93 .| <> ( 0 );

L425: |. D94 .| = ( |. ( D93 *' ) .| / |. |. D93 .| .| ) by COMPLEX1:67
.= ( |. D93 .| / |. D93 .| ) by COMPLEX1:53
.= 1 by L424 , XCMPLX_1:60;
L426: ( |. D93 .| + ( ( 0 ) * ( <i> ) ) ) = ( D94 * ( D88 . C332 ) ) by L5
.= ( D88 . ( D94 * C332 ) ) by L64
.= [** ( ( RtoC C330 ) . ( D94 * C332 ) ) , ( - ( ( i-shift ( RtoC C330 ) ) . ( D94 * C332 ) ) ) **] by L365
.= ( ( C330 . D96 ) + ( ( - ( ( i-shift ( RtoC C330 ) ) . ( D94 * C332 ) ) ) * ( <i> ) ) );
L427: ( C330 . D96 ) = |. ( D88 . C332 ) .| by L426 , COMPLEX1:77;
L428: ( D82 . D96 ) = ( |. D94 .| * ( C325 . C332 ) ) by L194
.= ( C325 . C332 ) by L425;
thus L429: thesis by L428 , L414 , L427;
end;
suppose L430: |. D93 .| = ( 0 );

L431: |. ( D88 . C332 ) .| = |. [** ( ( RtoC C330 ) . C332 ) , ( - ( ( i-shift ( RtoC C330 ) ) . C332 ) ) **] .| by L365
.= |. ( ( ( RtoC C330 ) . C332 ) + ( ( - ( ( i-shift ( RtoC C330 ) ) . C332 ) ) * ( <i> ) ) ) .|;
L432: ( ( ( RtoC C330 ) . C332 ) + ( ( - ( ( i-shift ( RtoC C330 ) ) . C332 ) ) * ( <i> ) ) ) = ( ( 0 ) + ( ( 0 ) * ( <i> ) ) ) by L431 , L430 , COMPLEX1:45;
L433: ( C330 . D95 ) = ( 0 ) by L432 , COMPLEX1:77;
thus L434: thesis by L433 , L414 , L430;
end;
end;
begin
theorem
L436: (for B176 being Real holds (B176 > ( 0 ) implies (for B177 being (Element of ( NAT )) holds ( ( power ( F_Complex ) ) . ([** B176 , ( 0 ) **] , B177) ) = [** ( B176 to_power B177 ) , ( 0 ) **])))
proof
let C333 being Real;
defpred S3[ (Element of ( NAT )) ] means ( ( power ( F_Complex ) ) . ([** C333 , ( 0 ) **] , $1) ) = [** ( C333 to_power $1 ) , ( 0 ) **];
assume L437: C333 > ( 0 );
L438:
now
let C334 being (Element of ( NAT ));
assume L439: S3[ C334 ];
L440: ( ( power ( F_Complex ) ) . ([** C333 , ( 0 ) **] , ( C334 + 1 )) ) = ( [** ( C333 to_power C334 ) , ( 0 ) **] * [** C333 , ( 0 ) **] ) by L439 , GROUP_1:def 7
.= [** ( ( C333 to_power C334 ) * ( C333 to_power 1 ) ) , ( 0 ) **] by POWER:25
.= [** ( C333 to_power ( C334 + 1 ) ) , ( 0 ) **] by L437 , POWER:27;
thus L441: S3[ ( C334 + 1 ) ] by L440;
end;
L442: ( ( power ( F_Complex ) ) . ([** C333 , ( 0 ) **] , ( 0 )) ) = ( ( 1r ) + ( ( 0 ) * ( <i> ) ) ) by COMPLFLD:8 , GROUP_1:def 7
.= [** ( C333 to_power ( 0 ) ) , ( 0 ) **] by POWER:24;
L443: S3[ ( 0 ) ] by L442;
thus L444: (for B178 being (Element of ( NAT )) holds S3[ B178 ]) from NAT_1:sch 1(L443 , L438);
end;
