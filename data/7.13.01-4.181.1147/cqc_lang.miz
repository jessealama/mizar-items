:: A Classical First Order Language
::  by Czes{\l}aw Byli\'nski
::
:: Received May 11, 1990
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies SUBSET_1, NUMBERS, QC_LANG1, FINSEQ_1, PARTFUN1, XXREAL_0,
      FUNCT_1, RELAT_1, TARSKI, FUNCOP_1, QC_LANG3, XBOOLE_0, ZF_MODEL,
      FINSEQ_2, ZF_LANG, CARD_1, REALSET1, XBOOLEAN, BVFUNC_2, MARGREL1,
      CLASSES2, FUNCT_4, CQC_LANG, ZFMISC_1, ORDINAL1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, RELAT_1,
      ORDINAL1, FUNCT_1, FUNCT_2, BINOP_1, PARTFUN1, FUNCOP_1, FUNCT_4,
      FINSEQ_1, FINSEQ_2, QC_LANG1, QC_LANG2, QC_LANG3, XXREAL_0, NAT_1,
      ZFMISC_1;
 constructors ENUMSET1, PARTFUN1, BINOP_1, FUNCOP_1, FUNCT_4, XXREAL_0,
      MEMBERED, QC_LANG2, QC_LANG3, FINSEQ_2, RELSET_1;
 registrations XBOOLE_0, RELSET_1, FUNCOP_1, FUNCT_4, MEMBERED, QC_LANG1,
      XXREAL_0, FINSEQ_2, CARD_1;
 requirements NUMERALS, SUBSET, BOOLE;
 definitions TARSKI, FUNCOP_1, FINSEQ_2, RELAT_1;
 theorems TARSKI, ZFMISC_1, FUNCT_1, FUNCT_2, FINSEQ_1, PARTFUN1, FUNCOP_1,
      QC_LANG1, QC_LANG2, QC_LANG3, FINSEQ_2, RELSET_1, FINSEQ_3, FUNCT_4,
      ORDINAL1, RELAT_1, CARD_1, XBOOLE_0, XTUPLE_0;
 schemes FINSEQ_1, QC_LANG1, QC_LANG3;

begin
L1: (for R1 being QC-alphabet holds (for B1 being (bound_QC-variable of R1) holds (not B1 in ( fixed_QC-variables R1 ))))
proof
let R1 being QC-alphabet;
let C1 being (bound_QC-variable of R1);
L2: C1 in ( bound_QC-variables R1 );
L3: C1 in [: { 4 } , ( QC-symbols R1 ) :] by L2 , QC_LANG1:def 4;
consider C2 , C3 being set such that L4: C2 in { 4 } and L5: C3 in ( QC-symbols R1 ) and L6: C1 = [ C2 , C3 ] by L3 , ZFMISC_1:def 2;
L7: C2 = 4 by L4 , TARSKI:def 1;
assume L8: C1 in ( fixed_QC-variables R1 );
L9: C1 in [: { 5 } , ( QC-symbols R1 ) :] by L8 , QC_LANG1:def 5;
consider C4 , C5 being set such that L10: C4 in { 5 } and L11: C5 in ( QC-symbols R1 ) and L12: C1 = [ C4 , C5 ] by L9 , ZFMISC_1:def 2;
L13: C4 = 5 by L10 , TARSKI:def 1;
thus L14: contradiction by L13 , L6 , L12 , L7 , XTUPLE_0:1;
end;
theorem
L15: (for R1 being QC-alphabet holds (for B2 being set holds (B2 in ( QC-variables R1 ) iff (B2 in ( fixed_QC-variables R1 ) or B2 in ( free_QC-variables R1 ) or B2 in ( bound_QC-variables R1 )))))
proof
let R1 being QC-alphabet;
let C6 being set;
thus L16: (C6 in ( QC-variables R1 ) implies (C6 in ( fixed_QC-variables R1 ) or C6 in ( free_QC-variables R1 ) or C6 in ( bound_QC-variables R1 )))
proof
assume L17: C6 in ( QC-variables R1 );
L18: C6 in ( [: { 6 } , ( NAT ) :] \/ [: { 4 , 5 } , ( QC-symbols R1 ) :] ) by L17 , QC_LANG1:def 3;
L19: (C6 in [: { 6 } , ( NAT ) :] or C6 in [: { 4 , 5 } , ( QC-symbols R1 ) :]) by L18 , XBOOLE_0:def 3;
consider C7 , C8 being set such that L20: ((C7 in { 6 } & C8 in ( NAT ) & C6 = [ C7 , C8 ]) or (C7 in { 4 , 5 } & C8 in ( QC-symbols R1 ) & C6 = [ C7 , C8 ])) by L19 , ZFMISC_1:def 2;
L21: ((C7 in { 6 } & C8 in ( NAT ) & C6 = [ C7 , C8 ]) or ((C7 = 4 or C7 = 5) & C8 in ( QC-symbols R1 ) & C6 = [ C7 , C8 ])) by L20 , TARSKI:def 2;
L22: (((C7 in { 4 } & C8 in ( QC-symbols R1 )) or (C7 in { 5 } & C8 in ( QC-symbols R1 )) or (C7 in { 6 } & C8 in ( NAT ))) & C6 = [ C7 , C8 ]) by L21 , TARSKI:def 1;
L23: (C6 in [: { 4 } , ( QC-symbols R1 ) :] or C6 in [: { 5 } , ( QC-symbols R1 ) :] or C6 in [: { 6 } , ( NAT ) :]) by L22 , ZFMISC_1:def 2;
thus L24: thesis by L23 , QC_LANG1:def 4 , QC_LANG1:def 5 , QC_LANG1:def 6;
end;

thus L25: thesis;
end;
definition
let R1 being QC-alphabet;
mode Substitution of R1
 is (PartFunc of ( free_QC-variables R1 ) , ( QC-variables R1 ));
end;
definition
let R1 being QC-alphabet;
let C9 being (FinSequence of ( QC-variables R1 ));
let R5 being (Substitution of R1);
func Subst (C9 , R5) -> (FinSequence of ( QC-variables R1 )) means 
:L27: (( len it ) = ( len C9 ) & (for R4 being (Element of ( NAT )) holds ((1 <= R4 & R4 <= ( len C9 )) implies ((( C9 . R4 ) in ( dom R5 ) implies ( it . R4 ) = ( R5 . ( C9 . R4 ) )) & ((not ( C9 . R4 ) in ( dom R5 )) implies ( it . R4 ) = ( C9 . R4 ))))));
existence
proof
defpred S1[ set , set ] means ((( C9 . $1 ) in ( dom R5 ) implies $2 = ( R5 . ( C9 . $1 ) )) & ((not ( C9 . $1 ) in ( dom R5 )) implies $2 = ( C9 . $1 )));
L28: (for B3 being  natural number holds (B3 in ( Seg ( len C9 ) ) implies (ex B4 being set st S1[ B3 , B4 ])))
proof
let C10 being  natural number;
assume L29: C10 in ( Seg ( len C9 ) );
L30: (( C9 . C10 ) in ( dom R5 ) implies thesis);
thus L31: thesis by L30;
end;
consider C11 being FinSequence such that L32: ( dom C11 ) = ( Seg ( len C9 ) ) and L33: (for B5 being  natural number holds (B5 in ( Seg ( len C9 ) ) implies S1[ B5 , ( C11 . B5 ) ])) from FINSEQ_1:sch 1(L28);
L34: ( rng C11 ) c= ( QC-variables R1 )
proof
let C12 being set;
assume L35: C12 in ( rng C11 );
consider C13 being set such that L36: C13 in ( dom C11 ) and L37: ( C11 . C13 ) = C12 by L35 , FUNCT_1:def 3;
reconsider D1 = C13 as (Element of ( NAT )) by L36;
L38:
now
per cases ;
case L39: ( C9 . D1 ) in ( dom R5 );
thus L40: (( C11 . D1 ) = ( R5 . ( C9 . D1 ) ) & ( R5 . ( C9 . D1 ) ) in ( QC-variables R1 )) by L39 , L32 , L33 , L36 , PARTFUN1:4;
end;
case L41: (not ( C9 . D1 ) in ( dom R5 ));
thus L42: ( C11 . D1 ) = ( C9 . D1 ) by L41 , L32 , L33 , L36;
end;
end;
L44: ( dom C9 ) = ( Seg ( len C9 ) ) by FINSEQ_1:def 3;
thus L45: thesis by L44 , L32 , L36 , L37 , L38 , FINSEQ_2:11;
end;
reconsider D2 = C11 as (FinSequence of ( QC-variables R1 )) by L34 , FINSEQ_1:def 4;
take D2;
thus L46: ( len D2 ) = ( len C9 ) by L32 , FINSEQ_1:def 3;
let R4 being (Element of ( NAT ));
assume L47: (1 <= R4 & R4 <= ( len C9 ));
L48: R4 in ( dom C9 ) by L47 , FINSEQ_3:25;
L49: R4 in ( Seg ( len C9 ) ) by L48 , FINSEQ_1:def 3;
thus L50: thesis by L49 , L33;
end;
uniqueness
proof
let C14 , C15 being (FinSequence of ( QC-variables R1 ));
assume that
L51: ( len C14 ) = ( len C9 )
and
L52: (for R4 being (Element of ( NAT )) holds ((1 <= R4 & R4 <= ( len C9 )) implies ((( C9 . R4 ) in ( dom R5 ) implies ( C14 . R4 ) = ( R5 . ( C9 . R4 ) )) & ((not ( C9 . R4 ) in ( dom R5 )) implies ( C14 . R4 ) = ( C9 . R4 )))))
and
L53: ( len C15 ) = ( len C9 )
and
L54: (for R4 being (Element of ( NAT )) holds ((1 <= R4 & R4 <= ( len C9 )) implies ((( C9 . R4 ) in ( dom R5 ) implies ( C15 . R4 ) = ( R5 . ( C9 . R4 ) )) & ((not ( C9 . R4 ) in ( dom R5 )) implies ( C15 . R4 ) = ( C9 . R4 )))));
L55:
now
let C16 being  natural number;
assume L56: (1 <= C16 & C16 <= ( len C9 ));
L57: C16 in ( NAT ) by ORDINAL1:def 12;
L58: ((not ( C9 . C16 ) in ( dom R5 )) implies ( C14 . C16 ) = ( C9 . C16 )) by L57 , L52 , L56;
L59: (( C9 . C16 ) in ( dom R5 ) implies ( C14 . C16 ) = ( R5 . ( C9 . C16 ) )) by L52 , L57 , L56;
thus L60: ( C14 . C16 ) = ( C15 . C16 ) by L59 , L54 , L57 , L56 , L58;
end;
thus L61: thesis by L55 , L51 , L53 , FINSEQ_1:14;
end;
end;
registration
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
let C17 being (QC-variable_list of R4 , R1);
let R5 being (Substitution of R1);
cluster ( Subst (C17 , R5) ) -> R4 -element;
coherence
proof
L63: (( len ( Subst (C17 , R5) ) ) = ( len C17 ) & ( len C17 ) = R4) by L27 , CARD_1:def 7;
thus L64: thesis by L63 , CARD_1:def 7;
end;
end;
theorem
L66: (for R1 being QC-alphabet holds (for B6 being (bound_QC-variable of R1) holds (for B7 being (free_QC-variable of R1) holds ( B7 .--> B6 ) is (Substitution of R1))))
proof
let R1 being QC-alphabet;
let C18 being (bound_QC-variable of R1);
let C19 being (free_QC-variable of R1);
set D3 = ( C19 .--> C18 );
L67: ( rng D3 ) = { C18 } by FUNCOP_1:8;
L68: ( rng D3 ) c= ( QC-variables R1 ) by L67 , ZFMISC_1:31;
L69: ( dom D3 ) = { C19 } by FUNCOP_1:13;
L70: ( dom D3 ) c= ( free_QC-variables R1 ) by L69 , ZFMISC_1:31;
thus L71: thesis by L70 , L68 , RELSET_1:4;
end;
definition
let R1 being QC-alphabet;
let C20 being (free_QC-variable of R1);
let C21 being (bound_QC-variable of R1);
redefine func C20 .--> C21 -> (Substitution of R1);

coherence by L66;
end;
theorem
L73: (for R1 being QC-alphabet holds (for R4 being (Element of ( NAT )) holds (for R5 being (Substitution of R1) holds (for B8 being (bound_QC-variable of R1) holds (for B9 being (free_QC-variable of R1) holds (for B10 , B11 being (FinSequence of ( QC-variables R1 )) holds ((R5 = ( B9 .--> B8 ) & B11 = ( Subst (B10 , R5) ) & 1 <= R4 & R4 <= ( len B10 )) implies ((( B10 . R4 ) = B9 implies ( B11 . R4 ) = B8) & (( B10 . R4 ) <> B9 implies ( B11 . R4 ) = ( B10 . R4 ))))))))))
proof
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
let R5 being (Substitution of R1);
let C22 being (bound_QC-variable of R1);
let C23 being (free_QC-variable of R1);
let C24 , C25 being (FinSequence of ( QC-variables R1 ));
set D4 = ( C23 .--> C22 );
assume L74: (R5 = ( C23 .--> C22 ) & C25 = ( Subst (C24 , R5) ) & 1 <= R4 & R4 <= ( len C24 ));
thus L75: (( C24 . R4 ) = C23 implies ( C25 . R4 ) = C22)
proof
L76: ( D4 . C23 ) = C22 by FUNCOP_1:72;
assume L77: ( C24 . R4 ) = C23;
L78: ( C24 . R4 ) in { C23 } by L77 , TARSKI:def 1;
L79: ( C24 . R4 ) in ( dom D4 ) by L78 , FUNCOP_1:13;
thus L80: thesis by L79 , L74 , L77 , L76 , L27;
end;

assume L81: ( C24 . R4 ) <> C23;
L82: (not ( C24 . R4 ) in { C23 }) by L81 , TARSKI:def 1;
L83: (not ( C24 . R4 ) in ( dom D4 )) by L82 , FUNCOP_1:13;
thus L84: thesis by L83 , L74 , L27;
end;
definition
let R1 being QC-alphabet;
func CQC-WFF R1 -> (Subset of ( QC-WFF R1 )) equals 
{ B12 where B12 is (QC-formula of R1) : (( Fixed B12 ) = ( {} ) & ( Free B12 ) = ( {} )) };
coherence
proof
set D5 = { B13 where B13 is (QC-formula of R1) : (( Fixed B13 ) = ( {} ) & ( Free B13 ) = ( {} )) };
L85: D5 c= ( QC-WFF R1 )
proof
let C26 being set;
assume L86: C26 in D5;
L87: (ex B14 being (QC-formula of R1) st (B14 = C26 & ( Fixed B14 ) = ( {} ) & ( Free B14 ) = ( {} ))) by L86;
thus L88: thesis by L87;
end;
thus L89: thesis by L85;
end;
end;
registration
let R1 being QC-alphabet;
cluster ( CQC-WFF R1 ) -> non  empty;
coherence
proof
L91: (( Fixed ( VERUM R1 ) ) = ( {} ) & ( Free ( VERUM R1 ) ) = ( {} )) by QC_LANG3:53 , QC_LANG3:63;
L92: ( VERUM R1 ) in { B15 where B15 is (QC-formula of R1) : (( Fixed B15 ) = ( {} ) & ( Free B15 ) = ( {} )) } by L91;
thus L93: thesis by L92;
end;
end;
theorem
L95: (for R1 being QC-alphabet holds (for B16 being (Element of ( QC-WFF R1 )) holds (B16 is (Element of ( CQC-WFF R1 )) iff (( Fixed B16 ) = ( {} ) & ( Free B16 ) = ( {} )))))
proof
let R1 being QC-alphabet;
let C27 being (Element of ( QC-WFF R1 ));
thus L96: (C27 is (Element of ( CQC-WFF R1 )) implies (( Fixed C27 ) = ( {} ) & ( Free C27 ) = ( {} )))
proof
assume L97: C27 is (Element of ( CQC-WFF R1 ));
L98: C27 in ( CQC-WFF R1 ) by L97;
L99: (ex B17 being (QC-formula of R1) st (B17 = C27 & ( Fixed B17 ) = ( {} ) & ( Free B17 ) = ( {} ))) by L98;
thus L100: thesis by L99;
end;

assume L101: (( Fixed C27 ) = ( {} ) & ( Free C27 ) = ( {} ));
L102: C27 in ( CQC-WFF R1 ) by L101;
thus L103: thesis by L102;
end;
registration
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
cluster ( bound_QC-variables R1 ) -valued for (QC-variable_list of R4 , R1);
existence
proof
set D6 = ( 0 );
reconsider D7 = D6 as (QC-symbol of R1) by QC_LANG1:3;
set D8 = ( R4 |-> ( x. D7 ) );
L104: ( dom D8 ) = ( Seg R4 ) by FUNCOP_1:13;
L105: ( rng D8 ) c= ( QC-variables R1 )
proof
let C28 being set;
assume L106: C28 in ( rng D8 );
consider C29 being set such that L107: C29 in ( dom D8 ) and L108: ( D8 . C29 ) = C28 by L106 , FUNCT_1:def 3;
L109: C28 = ( x. D7 ) by L104 , L107 , L108 , FINSEQ_2:57;
thus L110: thesis by L109;
end;
reconsider D9 = D8 as (QC-variable_list of R4 , R1) by L105 , FINSEQ_1:def 4;
take D9;
let C30 being set;
assume L111: C30 in ( rng D9 );
consider C31 being set such that L112: C31 in ( dom D9 ) and L113: C30 = ( D9 . C31 ) by L111 , FUNCT_1:def 3;
reconsider D10 = C31 as (Element of ( NAT )) by L112;
L114: ( D9 . D10 ) = ( x. D7 ) by L104 , L112 , FINSEQ_2:57;
thus L115: thesis by L114 , L113;
end;
end;
definition
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
mode CQC-variable_list of R4 , R1
 is ( bound_QC-variables R1 ) -valued (QC-variable_list of R4 , R1);
end;
theorem
L118: (for R1 being QC-alphabet holds (for R4 being (Element of ( NAT )) holds (for B18 being (QC-variable_list of R4 , R1) holds (B18 is (CQC-variable_list of R4 , R1) iff ({ ( B18 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len B18 ) & ( B18 . R2 ) in ( free_QC-variables R1 )) } = ( {} ) & { ( B18 . R3 ) where R3 is (Element of ( NAT )) : (1 <= R3 & R3 <= ( len B18 ) & ( B18 . R3 ) in ( fixed_QC-variables R1 )) } = ( {} ))))))
proof
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
let C32 being (QC-variable_list of R4 , R1);
set D11 = { ( C32 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len C32 ) & ( C32 . R2 ) in ( free_QC-variables R1 )) };
set D12 = { ( C32 . R3 ) where R3 is (Element of ( NAT )) : (1 <= R3 & R3 <= ( len C32 ) & ( C32 . R3 ) in ( fixed_QC-variables R1 )) };
thus L119: (C32 is (CQC-variable_list of R4 , R1) implies (D11 = ( {} ) & D12 = ( {} )))
proof
assume L120: C32 is (CQC-variable_list of R4 , R1);
reconsider D13 = C32 as (CQC-variable_list of R4 , R1) by L120;
L121:
now
set D14 = the (Element of D11);
assume L122: D11 <> ( {} );
L123: D14 in D11 by L122;
consider R2 being (Element of ( NAT )) such that L124: D14 = ( D13 . R2 ) and L125: (1 <= R2 & R2 <= ( len D13 )) and L126: ( D13 . R2 ) in ( free_QC-variables R1 ) by L123;
L127: R2 in ( dom D13 ) by L125 , FINSEQ_3:25;
L128: (( rng D13 ) c= ( bound_QC-variables R1 ) & ( D13 . R2 ) in ( rng D13 )) by L127 , FUNCT_1:def 3 , RELAT_1:def 19;
thus L129: contradiction by L128 , L126 , QC_LANG3:34;
end;
thus L130: D11 = ( {} ) by L121;
L131:
now
set D15 = the (Element of D12);
assume L132: D12 <> ( {} );
L133: D15 in D12 by L132;
consider R2 being (Element of ( NAT )) such that L134: D15 = ( D13 . R2 ) and L135: (1 <= R2 & R2 <= ( len D13 )) and L136: ( D13 . R2 ) in ( fixed_QC-variables R1 ) by L133;
L137: R2 in ( dom D13 ) by L135 , FINSEQ_3:25;
L138: (( rng D13 ) c= ( bound_QC-variables R1 ) & ( D13 . R2 ) in ( rng D13 )) by L137 , FUNCT_1:def 3 , RELAT_1:def 19;
thus L139: contradiction by L138 , L136 , QC_LANG3:33;
end;
thus L140: thesis by L131;
end;

assume that
L141: D11 = ( {} )
and
L142: D12 = ( {} );
L143: C32 is ( bound_QC-variables R1 ) -valued
proof
let C33 being set;
L144: ( rng C32 ) c= ( QC-variables R1 ) by FINSEQ_1:def 4;
assume L145: C33 in ( rng C32 );
consider C34 being set such that L146: C34 in ( dom C32 ) and L147: ( C32 . C34 ) = C33 by L145 , FUNCT_1:def 3;
reconsider D16 = C34 as (Element of ( NAT )) by L146;
L148: (1 <= D16 & D16 <= ( len C32 )) by L146 , FINSEQ_3:25;
L149:
now
assume L150: C33 in ( fixed_QC-variables R1 );
L151: C33 in D12 by L150 , L147 , L148;
thus L152: contradiction by L151 , L142;
end;
L153:
now
assume L154: C33 in ( free_QC-variables R1 );
L155: C33 in D11 by L154 , L147 , L148;
thus L156: contradiction by L155 , L141;
end;
L157: ( C32 . D16 ) in ( rng C32 ) by L146 , FUNCT_1:def 3;
thus L158: thesis by L157 , L147 , L144 , L149 , L153 , L15;
end;
thus L159: thesis by L143;
end;
theorem
L160: (for R1 being QC-alphabet holds ( VERUM R1 ) is (Element of ( CQC-WFF R1 )))
proof
let R1 being QC-alphabet;
L161: (( Fixed ( VERUM R1 ) ) = ( {} ) & ( Free ( VERUM R1 ) ) = ( {} )) by QC_LANG3:53 , QC_LANG3:63;
thus L162: thesis by L161 , L95;
end;
theorem
L163: (for R1 being QC-alphabet holds (for R4 being (Element of ( NAT )) holds (for B19 being (QC-pred_symbol of R4 , R1) holds (for B20 being (QC-variable_list of R4 , R1) holds (( B19 ! B20 ) is (Element of ( CQC-WFF R1 )) iff ({ ( B20 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len B20 ) & ( B20 . R2 ) in ( free_QC-variables R1 )) } = ( {} ) & { ( B20 . R3 ) where R3 is (Element of ( NAT )) : (1 <= R3 & R3 <= ( len B20 ) & ( B20 . R3 ) in ( fixed_QC-variables R1 )) } = ( {} )))))))
proof
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
let C35 being (QC-pred_symbol of R4 , R1);
let C36 being (QC-variable_list of R4 , R1);
L164: ( Free ( C35 ! C36 ) ) = { ( C36 . R3 ) where R3 is (Element of ( NAT )) : (1 <= R3 & R3 <= ( len C36 ) & ( C36 . R3 ) in ( free_QC-variables R1 )) } by QC_LANG3:54;
L165: ( Fixed ( C35 ! C36 ) ) = { ( C36 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len C36 ) & ( C36 . R2 ) in ( fixed_QC-variables R1 )) } by QC_LANG3:64;
thus L166: thesis by L165 , L164 , L95;
end;
definition
let R4 being (Element of ( NAT ));
let R1 being QC-alphabet;
let C37 being (QC-pred_symbol of R4 , R1);
let C38 being (CQC-variable_list of R4 , R1);
redefine func C37 ! C38 -> (Element of ( CQC-WFF R1 ));

coherence
proof
L167: { ( C38 . R3 ) where R3 is (Element of ( NAT )) : (1 <= R3 & R3 <= ( len C38 ) & ( C38 . R3 ) in ( fixed_QC-variables R1 )) } = ( {} ) by L118;
L168: { ( C38 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len C38 ) & ( C38 . R2 ) in ( free_QC-variables R1 )) } = ( {} ) by L118;
thus L169: thesis by L168 , L167 , L163;
end;
end;
theorem
L171: (for R1 being QC-alphabet holds (for B21 being (Element of ( QC-WFF R1 )) holds (( 'not' B21 ) is (Element of ( CQC-WFF R1 )) iff B21 is (Element of ( CQC-WFF R1 )))))
proof
let R1 being QC-alphabet;
let C39 being (Element of ( QC-WFF R1 ));
thus L172: (( 'not' C39 ) is (Element of ( CQC-WFF R1 )) implies C39 is (Element of ( CQC-WFF R1 )))
proof
assume L173: ( 'not' C39 ) is (Element of ( CQC-WFF R1 ));
L174: ( Free ( 'not' C39 ) ) = ( {} ) by L173 , L95;
L175: ( Free C39 ) = ( {} ) by L174 , QC_LANG3:55;
L176: ( Fixed ( 'not' C39 ) ) = ( {} ) by L173 , L95;
L177: ( Fixed C39 ) = ( {} ) by L176 , QC_LANG3:65;
thus L178: thesis by L177 , L175 , L95;
end;

assume L179: C39 is (Element of ( CQC-WFF R1 ));
reconsider D17 = C39 as (Element of ( CQC-WFF R1 )) by L179;
L180: ( Fixed D17 ) = ( {} ) by L95;
L181: ( Fixed ( 'not' D17 ) ) = ( {} ) by L180 , QC_LANG3:65;
L182: ( Free D17 ) = ( {} ) by L95;
L183: ( Free ( 'not' D17 ) ) = ( {} ) by L182 , QC_LANG3:55;
thus L184: thesis by L183 , L181 , L95;
end;
theorem
L185: (for R1 being QC-alphabet holds (for B22 , B23 being (Element of ( QC-WFF R1 )) holds (( B22 '&' B23 ) is (Element of ( CQC-WFF R1 )) iff (B22 is (Element of ( CQC-WFF R1 )) & B23 is (Element of ( CQC-WFF R1 ))))))
proof
let R1 being QC-alphabet;
let C40 , C41 being (Element of ( QC-WFF R1 ));
thus L186: (( C40 '&' C41 ) is (Element of ( CQC-WFF R1 )) implies (C40 is (Element of ( CQC-WFF R1 )) & C41 is (Element of ( CQC-WFF R1 ))))
proof
assume L187: ( C40 '&' C41 ) is (Element of ( CQC-WFF R1 ));
L188: ( Fixed ( C40 '&' C41 ) ) = ( {} ) by L187 , L95;
L189: ( ( Fixed C40 ) \/ ( Fixed C41 ) ) = ( {} ) by L188 , QC_LANG3:67;
L190: ( Fixed C40 ) = ( {} ) by L189;
L191: ( Free ( C40 '&' C41 ) ) = ( {} ) by L187 , L95;
L192: ( ( Free C40 ) \/ ( Free C41 ) ) = ( {} ) by L191 , QC_LANG3:57;
L193: ( Free C40 ) = ( {} ) by L192;
thus L194: thesis by L193 , L192 , L189 , L190 , L95;
end;

assume L195: (C40 is (Element of ( CQC-WFF R1 )) & C41 is (Element of ( CQC-WFF R1 )));
reconsider D18 = C40 , D19 = C41 as (Element of ( CQC-WFF R1 )) by L195;
L196: ( Fixed D18 ) = ( {} ) by L95;
L197: ( ( Fixed D18 ) \/ ( Fixed D19 ) ) = ( {} ) by L196 , L95;
L198: ( Fixed ( D18 '&' D19 ) ) = ( {} ) by L197 , QC_LANG3:67;
L199: ( Free D18 ) = ( {} ) by L95;
L200: ( ( Free D18 ) \/ ( Free D19 ) ) = ( {} ) by L199 , L95;
L201: ( Free ( D18 '&' D19 ) ) = ( {} ) by L200 , QC_LANG3:57;
thus L202: thesis by L201 , L198 , L95;
end;
definition
let R1 being QC-alphabet;
redefine func VERUM R1 -> (Element of ( CQC-WFF R1 ));

coherence by L160;
let C42 being (Element of ( CQC-WFF R1 ));
redefine func 'not' C42 -> (Element of ( CQC-WFF R1 ));

coherence by L171;
let C43 being (Element of ( CQC-WFF R1 ));
redefine func C42 '&' C43 -> (Element of ( CQC-WFF R1 ));

coherence by L185;
end;
theorem
L204: (for R1 being QC-alphabet holds (for B24 , B25 being (Element of ( CQC-WFF R1 )) holds ( B24 => B25 ) is (Element of ( CQC-WFF R1 ))))
proof
let R1 being QC-alphabet;
let C44 , C45 being (Element of ( CQC-WFF R1 ));
L205: ( C44 => C45 ) = ( 'not' ( C44 '&' ( 'not' C45 ) ) ) by QC_LANG2:def 2;
thus L206: thesis by L205;
end;
theorem
L207: (for R1 being QC-alphabet holds (for B26 , B27 being (Element of ( CQC-WFF R1 )) holds ( B26 'or' B27 ) is (Element of ( CQC-WFF R1 ))))
proof
let R1 being QC-alphabet;
let C46 , C47 being (Element of ( CQC-WFF R1 ));
L208: ( C46 'or' C47 ) = ( 'not' ( ( 'not' C46 ) '&' ( 'not' C47 ) ) ) by QC_LANG2:def 3;
thus L209: thesis by L208;
end;
theorem
L210: (for R1 being QC-alphabet holds (for B28 , B29 being (Element of ( CQC-WFF R1 )) holds ( B28 <=> B29 ) is (Element of ( CQC-WFF R1 ))))
proof
let R1 being QC-alphabet;
let C48 , C49 being (Element of ( CQC-WFF R1 ));
L211: ( C48 <=> C49 ) = ( ( C48 => C49 ) '&' ( C49 => C48 ) ) by QC_LANG2:def 4
.= ( ( 'not' ( C48 '&' ( 'not' C49 ) ) ) '&' ( C49 => C48 ) ) by QC_LANG2:def 2
.= ( ( 'not' ( C48 '&' ( 'not' C49 ) ) ) '&' ( 'not' ( C49 '&' ( 'not' C48 ) ) ) ) by QC_LANG2:def 2;
thus L212: thesis by L211;
end;
definition
let R1 being QC-alphabet;
let C50 , C51 being (Element of ( CQC-WFF R1 ));
redefine func C50 => C51 -> (Element of ( CQC-WFF R1 ));

coherence by L204;
redefine func C50 'or' C51 -> (Element of ( CQC-WFF R1 ));

coherence by L207;
redefine func C50 <=> C51 -> (Element of ( CQC-WFF R1 ));

coherence by L210;
end;
theorem
L214: (for R1 being QC-alphabet holds (for B30 being (bound_QC-variable of R1) holds (for B31 being (Element of ( QC-WFF R1 )) holds (( All (B30 , B31) ) is (Element of ( CQC-WFF R1 )) iff B31 is (Element of ( CQC-WFF R1 ))))))
proof
let R1 being QC-alphabet;
let C52 being (bound_QC-variable of R1);
let C53 being (Element of ( QC-WFF R1 ));
thus L215: (( All (C52 , C53) ) is (Element of ( CQC-WFF R1 )) implies C53 is (Element of ( CQC-WFF R1 )))
proof
assume L216: ( All (C52 , C53) ) is (Element of ( CQC-WFF R1 ));
L217: ( Fixed ( All (C52 , C53) ) ) = ( {} ) by L216 , L95;
L218: ( Fixed C53 ) = ( {} ) by L217 , QC_LANG3:68;
L219: ( Free ( All (C52 , C53) ) ) = ( {} ) by L216 , L95;
L220: ( Free C53 ) = ( {} ) by L219 , QC_LANG3:58;
thus L221: thesis by L220 , L218 , L95;
end;

assume L222: C53 is (Element of ( CQC-WFF R1 ));
L223: ( Fixed C53 ) = ( {} ) by L222 , L95;
L224: ( Fixed ( All (C52 , C53) ) ) = ( {} ) by L223 , QC_LANG3:68;
L225: ( Free C53 ) = ( {} ) by L222 , L95;
L226: ( Free ( All (C52 , C53) ) ) = ( {} ) by L225 , QC_LANG3:58;
thus L227: thesis by L226 , L224 , L95;
end;
definition
let R1 being QC-alphabet;
let C54 being (bound_QC-variable of R1);
let C55 being (Element of ( CQC-WFF R1 ));
redefine func All (C54 , C55) -> (Element of ( CQC-WFF R1 ));

coherence by L214;
end;
theorem
L229: (for R1 being QC-alphabet holds (for B32 being (bound_QC-variable of R1) holds (for B33 being (Element of ( CQC-WFF R1 )) holds ( Ex (B32 , B33) ) is (Element of ( CQC-WFF R1 )))))
proof
let R1 being QC-alphabet;
let C56 being (bound_QC-variable of R1);
let C57 being (Element of ( CQC-WFF R1 ));
L230: ( Ex (C56 , C57) ) = ( 'not' ( All (C56 , ( 'not' C57 )) ) ) by QC_LANG2:def 5;
thus L231: thesis by L230;
end;
definition
let R1 being QC-alphabet;
let C58 being (bound_QC-variable of R1);
let C59 being (Element of ( CQC-WFF R1 ));
redefine func Ex (C58 , C59) -> (Element of ( CQC-WFF R1 ));

coherence by L229;
end;
scheme CQCInd { F1() -> QC-alphabet , P1[set] } : (for B34 being (Element of ( CQC-WFF F1() )) holds P1[ B34 ])
provided
L233: (for B35 , B36 being (Element of ( CQC-WFF F1() )) holds (for B37 being (bound_QC-variable of F1()) holds (for R4 being (Element of ( NAT )) holds (for B38 being (CQC-variable_list of R4 , F1()) holds (for B39 being (QC-pred_symbol of R4 , F1()) holds (P1[ ( VERUM F1() ) ] & P1[ ( B39 ! B38 ) ] & (P1[ B35 ] implies P1[ ( 'not' B35 ) ]) & ((P1[ B35 ] & P1[ B36 ]) implies P1[ ( B35 '&' B36 ) ]) & (P1[ B35 ] implies P1[ ( All (B37 , B35) ) ])))))))
proof
defpred S2[ (Element of ( QC-WFF F1() )) ] means ($1 is (Element of ( CQC-WFF F1() )) implies P1[ $1 ]);
L234: (for B40 being (Element of ( QC-WFF F1() )) holds (S2[ B40 ] implies S2[ ( 'not' B40 ) ]))
proof
let C60 being (Element of ( QC-WFF F1() ));
assume L235: S2[ C60 ];
assume L236: ( 'not' C60 ) is (Element of ( CQC-WFF F1() ));
L237: C60 is (Element of ( CQC-WFF F1() )) by L236 , L171;
thus L238: thesis by L237 , L233 , L235;
end;
L239: (for B41 , B42 being (Element of ( QC-WFF F1() )) holds ((S2[ B41 ] & S2[ B42 ]) implies S2[ ( B41 '&' B42 ) ]))
proof
let C61 , C62 being (Element of ( QC-WFF F1() ));
assume L240: (S2[ C61 ] & S2[ C62 ]);
assume L241: ( C61 '&' C62 ) is (Element of ( CQC-WFF F1() ));
L242: (C61 is (Element of ( CQC-WFF F1() )) & C62 is (Element of ( CQC-WFF F1() ))) by L241 , L185;
thus L243: thesis by L242 , L233 , L240;
end;
L244: (for B43 being (Element of ( NAT )) holds (for B44 being (QC-pred_symbol of B43 , F1()) holds (for B45 being (QC-variable_list of B43 , F1()) holds S2[ ( B44 ! B45 ) ])))
proof
let C63 being (Element of ( NAT ));
let C64 being (QC-pred_symbol of C63 , F1());
let C65 being (QC-variable_list of C63 , F1());
assume L245: ( C64 ! C65 ) is (Element of ( CQC-WFF F1() ));
L246: { ( C65 . R3 ) where R3 is (Element of ( NAT )) : (1 <= R3 & R3 <= ( len C65 ) & ( C65 . R3 ) in ( fixed_QC-variables F1() )) } = ( {} ) by L245 , L163;
L247: { ( C65 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len C65 ) & ( C65 . R2 ) in ( free_QC-variables F1() )) } = ( {} ) by L245 , L163;
L248: C65 is (CQC-variable_list of C63 , F1()) by L247 , L246 , L118;
thus L249: thesis by L248 , L233;
end;
L250: (for B46 being (bound_QC-variable of F1()) holds (for B47 being (Element of ( QC-WFF F1() )) holds (S2[ B47 ] implies S2[ ( All (B46 , B47) ) ])))
proof
let C66 being (bound_QC-variable of F1());
let C67 being (Element of ( QC-WFF F1() ));
assume L251: S2[ C67 ];
assume L252: ( All (C66 , C67) ) is (Element of ( CQC-WFF F1() ));
L253: C67 is (Element of ( CQC-WFF F1() )) by L252 , L214;
thus L254: thesis by L253 , L233 , L251;
end;
L255: S2[ ( VERUM F1() ) ] by L233;
L256: (for B48 being (Element of ( QC-WFF F1() )) holds S2[ B48 ]) from QC_LANG1:sch 1(L244 , L255 , L234 , L239 , L250);
thus L257: thesis by L256;
end;
scheme CQCFuncEx { F2() -> QC-alphabet , F3() -> non  empty set , F4() -> (Element of F3()) , F5(set , set , set) -> (Element of F3()) , F6(set) -> (Element of F3()) , F7(set , set) -> (Element of F3()) , F8(set , set) -> (Element of F3()) } : (ex B49 being (Function of ( CQC-WFF F2() ) , F3()) st (( B49 . ( VERUM F2() ) ) = F4() & (for B50 , B51 being (Element of ( CQC-WFF F2() )) holds (for B52 being (bound_QC-variable of F2()) holds (for R4 being (Element of ( NAT )) holds (for B53 being (CQC-variable_list of R4 , F2()) holds (for B54 being (QC-pred_symbol of R4 , F2()) holds (( B49 . ( B54 ! B53 ) ) = F5(R4 , B54 , B53) & ( B49 . ( 'not' B50 ) ) = F6(( B49 . B50 )) & ( B49 . ( B50 '&' B51 ) ) = F7(( B49 . B50 ) , ( B49 . B51 )) & ( B49 . ( All (B52 , B50) ) ) = F8(B52 , ( B49 . B50 ))))))))))
proof
deffunc H1((Element of ( QC-WFF F2() )) , (Element of F3())) = F8(( bound_in $1 ) , $2);
deffunc H2((Element of ( QC-WFF F2() ))) = F5(( the_arity_of ( the_pred_symbol_of $1 ) ) , ( the_pred_symbol_of $1 ) , ( the_arguments_of $1 ));
consider C68 being (Function of ( QC-WFF F2() ) , F3()) such that L258: (( C68 . ( VERUM F2() ) ) = F4() & (for B55 being (Element of ( QC-WFF F2() )) holds ((B55 is  atomic implies ( C68 . B55 ) = H2(B55)) & (B55 is  negative implies ( C68 . B55 ) = F6(( C68 . ( the_argument_of B55 ) ))) & (B55 is  conjunctive implies ( C68 . B55 ) = F7(( C68 . ( the_left_argument_of B55 ) ) , ( C68 . ( the_right_argument_of B55 ) ))) & (B55 is  universal implies ( C68 . B55 ) = H1(B55 , ( C68 . ( the_scope_of B55 ) )))))) from QC_LANG1:sch 3;
reconsider D20 = ( C68 | ( CQC-WFF F2() ) ) as (Function of ( CQC-WFF F2() ) , F3()) by FUNCT_2:32;
take D20;
thus L259: ( D20 . ( VERUM F2() ) ) = F4() by L258 , FUNCT_1:49;
let C69 , C70 being (Element of ( CQC-WFF F2() ));
let C71 being (bound_QC-variable of F2());
let R4 being (Element of ( NAT ));
let C72 being (CQC-variable_list of R4 , F2());
let C73 being (QC-pred_symbol of R4 , F2());
L260: ( the_arity_of C73 ) = R4 by QC_LANG1:11;
L261: ( C73 ! C72 ) is  atomic by QC_LANG1:def 18;
L262: (( the_arguments_of ( C73 ! C72 ) ) = C72 & ( the_pred_symbol_of ( C73 ! C72 ) ) = C73) by L261 , QC_LANG1:def 22 , QC_LANG1:def 23;
thus L263: ( D20 . ( C73 ! C72 ) ) = ( C68 . ( C73 ! C72 ) ) by FUNCT_1:49
.= F5(R4 , C73 , C72) by L258 , L261 , L262 , L260;
set D21 = ( D20 . C69 );
set D22 = ( D20 . C70 );
L264: D21 = ( C68 . C69 ) by FUNCT_1:49;
L265: ( C69 '&' C70 ) is  conjunctive by QC_LANG1:def 20;
L266: (( the_left_argument_of ( C69 '&' C70 ) ) = C69 & ( the_right_argument_of ( C69 '&' C70 ) ) = C70) by L265 , QC_LANG1:def 25 , QC_LANG1:def 26;
L267: ( 'not' C69 ) is  negative by QC_LANG1:def 19;
L268: ( the_argument_of ( 'not' C69 ) ) = C69 by L267 , QC_LANG1:def 24;
thus L269: ( D20 . ( 'not' C69 ) ) = ( C68 . ( 'not' C69 ) ) by FUNCT_1:49
.= F6(D21) by L258 , L264 , L267 , L268;
L270: D22 = ( C68 . C70 ) by FUNCT_1:49;
thus L271: ( D20 . ( C69 '&' C70 ) ) = ( C68 . ( C69 '&' C70 ) ) by FUNCT_1:49
.= F7(D21 , D22) by L258 , L264 , L270 , L265 , L266;
L272: ( All (C71 , C69) ) is  universal by QC_LANG1:def 21;
L273: (( bound_in ( All (C71 , C69) ) ) = C71 & ( the_scope_of ( All (C71 , C69) ) ) = C69) by L272 , QC_LANG1:def 27 , QC_LANG1:def 28;
thus L274: ( D20 . ( All (C71 , C69) ) ) = ( C68 . ( All (C71 , C69) ) ) by FUNCT_1:49
.= F8(C71 , D21) by L258 , L264 , L272 , L273;
end;
scheme CQCFuncUniq { F9() -> QC-alphabet , F10() -> non  empty set , F11() -> (Function of ( CQC-WFF F9() ) , F10()) , F12() -> (Function of ( CQC-WFF F9() ) , F10()) , F13() -> (Element of F10()) , F14(set , set , set) -> (Element of F10()) , F15(set) -> (Element of F10()) , F16(set , set) -> (Element of F10()) , F17(set , set) -> (Element of F10()) } : F11() = F12()
provided
L275: (( F11() . ( VERUM F9() ) ) = F13() & (for B56 , B57 being (Element of ( CQC-WFF F9() )) holds (for B58 being (bound_QC-variable of F9()) holds (for R4 being (Element of ( NAT )) holds (for B59 being (CQC-variable_list of R4 , F9()) holds (for B60 being (QC-pred_symbol of R4 , F9()) holds (( F11() . ( B60 ! B59 ) ) = F14(R4 , B60 , B59) & ( F11() . ( 'not' B56 ) ) = F15(( F11() . B56 )) & ( F11() . ( B56 '&' B57 ) ) = F16(( F11() . B56 ) , ( F11() . B57 )) & ( F11() . ( All (B58 , B56) ) ) = F17(B58 , ( F11() . B56 )))))))))
and
L276: (( F12() . ( VERUM F9() ) ) = F13() & (for B61 , B62 being (Element of ( CQC-WFF F9() )) holds (for B63 being (bound_QC-variable of F9()) holds (for R4 being (Element of ( NAT )) holds (for B64 being (CQC-variable_list of R4 , F9()) holds (for B65 being (QC-pred_symbol of R4 , F9()) holds (( F12() . ( B65 ! B64 ) ) = F14(R4 , B65 , B64) & ( F12() . ( 'not' B61 ) ) = F15(( F12() . B61 )) & ( F12() . ( B61 '&' B62 ) ) = F16(( F12() . B61 ) , ( F12() . B62 )) & ( F12() . ( All (B63 , B61) ) ) = F17(B63 , ( F12() . B61 )))))))))
proof
defpred S3[ set ] means ( F11() . $1 ) = ( F12() . $1 );
L277: (for B66 , B67 being (Element of ( CQC-WFF F9() )) holds (for B68 being (bound_QC-variable of F9()) holds (for R4 being (Element of ( NAT )) holds (for B69 being (CQC-variable_list of R4 , F9()) holds (for B70 being (QC-pred_symbol of R4 , F9()) holds (S3[ ( VERUM F9() ) ] & S3[ ( B70 ! B69 ) ] & (S3[ B66 ] implies S3[ ( 'not' B66 ) ]) & ((S3[ B66 ] & S3[ B67 ]) implies S3[ ( B66 '&' B67 ) ]) & (S3[ B66 ] implies S3[ ( All (B68 , B66) ) ])))))))
proof
let C74 , C75 being (Element of ( CQC-WFF F9() ));
let C76 being (bound_QC-variable of F9());
let R4 being (Element of ( NAT ));
let C77 being (CQC-variable_list of R4 , F9());
let C78 being (QC-pred_symbol of R4 , F9());
thus L278: ( F11() . ( VERUM F9() ) ) = ( F12() . ( VERUM F9() ) ) by L275 , L276;
L279: ( F11() . ( C78 ! C77 ) ) = F14(R4 , C78 , C77) by L275;
thus L280: ( F11() . ( C78 ! C77 ) ) = ( F12() . ( C78 ! C77 ) ) by L279 , L276;
L281: ( F11() . ( 'not' C74 ) ) = F15(( F11() . C74 )) by L275;
thus L282: (( F11() . C74 ) = ( F12() . C74 ) implies ( F11() . ( 'not' C74 ) ) = ( F12() . ( 'not' C74 ) )) by L281 , L276;
L283: ( F11() . ( C74 '&' C75 ) ) = F16(( F11() . C74 ) , ( F11() . C75 )) by L275;
thus L284: ((( F11() . C74 ) = ( F12() . C74 ) & ( F11() . C75 ) = ( F12() . C75 )) implies ( F11() . ( C74 '&' C75 ) ) = ( F12() . ( C74 '&' C75 ) )) by L283 , L276;
L285: ( F11() . ( All (C76 , C74) ) ) = F17(C76 , ( F11() . C74 )) by L275;
thus L286: thesis by L285 , L276;
end;
L287: (for B71 being (Element of ( CQC-WFF F9() )) holds S3[ B71 ]) from CQCInd(L277);
thus L288: thesis by L287 , FUNCT_2:63;
end;
scheme CQCDefcorrectness { F18() -> QC-alphabet , F19() -> non  empty set , F20() -> (Element of ( CQC-WFF F18() )) , F21() -> (Element of F19()) , F22(set , set , set) -> (Element of F19()) , F23(set) -> (Element of F19()) , F24(set , set) -> (Element of F19()) , F25(set , set) -> (Element of F19()) } : ((ex B72 being (Element of F19()) st (ex B73 being (Function of ( CQC-WFF F18() ) , F19()) st (B72 = ( B73 . F20() ) & ( B73 . ( VERUM F18() ) ) = F21() & (for B74 , B75 being (Element of ( CQC-WFF F18() )) holds (for B76 being (bound_QC-variable of F18()) holds (for R4 being (Element of ( NAT )) holds (for B77 being (CQC-variable_list of R4 , F18()) holds (for B78 being (QC-pred_symbol of R4 , F18()) holds (( B73 . ( B78 ! B77 ) ) = F22(R4 , B78 , B77) & ( B73 . ( 'not' B74 ) ) = F23(( B73 . B74 )) & ( B73 . ( B74 '&' B75 ) ) = F24(( B73 . B74 ) , ( B73 . B75 )) & ( B73 . ( All (B76 , B74) ) ) = F25(B76 , ( B73 . B74 ))))))))))) & (for B79 , B80 being (Element of F19()) holds (((ex B81 being (Function of ( CQC-WFF F18() ) , F19()) st (B79 = ( B81 . F20() ) & ( B81 . ( VERUM F18() ) ) = F21() & (for B82 , B83 being (Element of ( CQC-WFF F18() )) holds (for B84 being (bound_QC-variable of F18()) holds (for R4 being (Element of ( NAT )) holds (for B85 being (CQC-variable_list of R4 , F18()) holds (for B86 being (QC-pred_symbol of R4 , F18()) holds (( B81 . ( B86 ! B85 ) ) = F22(R4 , B86 , B85) & ( B81 . ( 'not' B82 ) ) = F23(( B81 . B82 )) & ( B81 . ( B82 '&' B83 ) ) = F24(( B81 . B82 ) , ( B81 . B83 )) & ( B81 . ( All (B84 , B82) ) ) = F25(B84 , ( B81 . B82 )))))))))) & (ex B87 being (Function of ( CQC-WFF F18() ) , F19()) st (B80 = ( B87 . F20() ) & ( B87 . ( VERUM F18() ) ) = F21() & (for B88 , B89 being (Element of ( CQC-WFF F18() )) holds (for B90 being (bound_QC-variable of F18()) holds (for R4 being (Element of ( NAT )) holds (for B91 being (CQC-variable_list of R4 , F18()) holds (for B92 being (QC-pred_symbol of R4 , F18()) holds (( B87 . ( B92 ! B91 ) ) = F22(R4 , B92 , B91) & ( B87 . ( 'not' B88 ) ) = F23(( B87 . B88 )) & ( B87 . ( B88 '&' B89 ) ) = F24(( B87 . B88 ) , ( B87 . B89 )) & ( B87 . ( All (B90 , B88) ) ) = F25(B90 , ( B87 . B88 ))))))))))) implies B79 = B80)))
proof
thus L289: (ex B93 being (Element of F19()) st (ex B94 being (Function of ( CQC-WFF F18() ) , F19()) st (B93 = ( B94 . F20() ) & ( B94 . ( VERUM F18() ) ) = F21() & (for B95 , B96 being (Element of ( CQC-WFF F18() )) holds (for B97 being (bound_QC-variable of F18()) holds (for R4 being (Element of ( NAT )) holds (for B98 being (CQC-variable_list of R4 , F18()) holds (for B99 being (QC-pred_symbol of R4 , F18()) holds (( B94 . ( B99 ! B98 ) ) = F22(R4 , B99 , B98) & ( B94 . ( 'not' B95 ) ) = F23(( B94 . B95 )) & ( B94 . ( B95 '&' B96 ) ) = F24(( B94 . B95 ) , ( B94 . B96 )) & ( B94 . ( All (B97 , B95) ) ) = F25(B97 , ( B94 . B95 )))))))))))
proof
consider C79 being (Function of ( CQC-WFF F18() ) , F19()) such that L290: (( C79 . ( VERUM F18() ) ) = F21() & (for B100 , B101 being (Element of ( CQC-WFF F18() )) holds (for B102 being (bound_QC-variable of F18()) holds (for R4 being (Element of ( NAT )) holds (for B103 being (CQC-variable_list of R4 , F18()) holds (for B104 being (QC-pred_symbol of R4 , F18()) holds (( C79 . ( B104 ! B103 ) ) = F22(R4 , B104 , B103) & ( C79 . ( 'not' B100 ) ) = F23(( C79 . B100 )) & ( C79 . ( B100 '&' B101 ) ) = F24(( C79 . B100 ) , ( C79 . B101 )) & ( C79 . ( All (B102 , B100) ) ) = F25(B102 , ( C79 . B100 ))))))))) from CQCFuncEx;
take ( C79 . F20() );
take C79;
thus L291: thesis by L290;
end;

let C80 , C81 being (Element of F19());
given C82 being (Function of ( CQC-WFF F18() ) , F19()) such that
L292: C80 = ( C82 . F20() )
and
L293: (( C82 . ( VERUM F18() ) ) = F21() & (for B105 , B106 being (Element of ( CQC-WFF F18() )) holds (for B107 being (bound_QC-variable of F18()) holds (for R4 being (Element of ( NAT )) holds (for B108 being (CQC-variable_list of R4 , F18()) holds (for B109 being (QC-pred_symbol of R4 , F18()) holds (( C82 . ( B109 ! B108 ) ) = F22(R4 , B109 , B108) & ( C82 . ( 'not' B105 ) ) = F23(( C82 . B105 )) & ( C82 . ( B105 '&' B106 ) ) = F24(( C82 . B105 ) , ( C82 . B106 )) & ( C82 . ( All (B107 , B105) ) ) = F25(B107 , ( C82 . B105 )))))))));

given C83 being (Function of ( CQC-WFF F18() ) , F19()) such that
L294: C81 = ( C83 . F20() )
and
L295: (( C83 . ( VERUM F18() ) ) = F21() & (for B110 , B111 being (Element of ( CQC-WFF F18() )) holds (for B112 being (bound_QC-variable of F18()) holds (for R4 being (Element of ( NAT )) holds (for B113 being (CQC-variable_list of R4 , F18()) holds (for B114 being (QC-pred_symbol of R4 , F18()) holds (( C83 . ( B114 ! B113 ) ) = F22(R4 , B114 , B113) & ( C83 . ( 'not' B110 ) ) = F23(( C83 . B110 )) & ( C83 . ( B110 '&' B111 ) ) = F24(( C83 . B110 ) , ( C83 . B111 )) & ( C83 . ( All (B112 , B110) ) ) = F25(B112 , ( C83 . B110 )))))))));

L296: C82 = C83 from CQCFuncUniq(L293 , L295);
thus L297: thesis by L296 , L292 , L294;
end;
scheme CQCDefVERUM { F26() -> QC-alphabet , F27() -> non  empty set , F28(set) -> (Element of F27()) , F29() -> (Element of F27()) , F30(set , set , set) -> (Element of F27()) , F31(set) -> (Element of F27()) , F32(set , set) -> (Element of F27()) , F33(set , set) -> (Element of F27()) } : F28(( VERUM F26() )) = F29()
provided
L298: (for B115 being (Element of ( CQC-WFF F26() )) holds (for B116 being (Element of F27()) holds (B116 = F28(B115) iff (ex B117 being (Function of ( CQC-WFF F26() ) , F27()) st (B116 = ( B117 . B115 ) & ( B117 . ( VERUM F26() ) ) = F29() & (for B118 , B119 being (Element of ( CQC-WFF F26() )) holds (for B120 being (bound_QC-variable of F26()) holds (for R4 being (Element of ( NAT )) holds (for B121 being (CQC-variable_list of R4 , F26()) holds (for B122 being (QC-pred_symbol of R4 , F26()) holds (( B117 . ( B122 ! B121 ) ) = F30(R4 , B122 , B121) & ( B117 . ( 'not' B118 ) ) = F31(( B117 . B118 )) & ( B117 . ( B118 '&' B119 ) ) = F32(( B117 . B118 ) , ( B117 . B119 )) & ( B117 . ( All (B120 , B118) ) ) = F33(B120 , ( B117 . B118 )))))))))))))
proof
L299: (ex B123 being (Function of ( CQC-WFF F26() ) , F27()) st (( B123 . ( VERUM F26() ) ) = F29() & (for B124 , B125 being (Element of ( CQC-WFF F26() )) holds (for B126 being (bound_QC-variable of F26()) holds (for R4 being (Element of ( NAT )) holds (for B127 being (CQC-variable_list of R4 , F26()) holds (for B128 being (QC-pred_symbol of R4 , F26()) holds (( B123 . ( B128 ! B127 ) ) = F30(R4 , B128 , B127) & ( B123 . ( 'not' B124 ) ) = F31(( B123 . B124 )) & ( B123 . ( B124 '&' B125 ) ) = F32(( B123 . B124 ) , ( B123 . B125 )) & ( B123 . ( All (B126 , B124) ) ) = F33(B126 , ( B123 . B124 )))))))))) from CQCFuncEx;
thus L300: thesis by L299 , L298;
end;
scheme CQCDefatomic { F34() -> QC-alphabet , F35() -> non  empty set , F36() -> (Element of F35()) , F37(set) -> (Element of F35()) , F38(set , set , set) -> (Element of F35()) , F39() -> (Element of ( NAT )) , F40() -> (QC-pred_symbol of F39() , F34()) , F41() -> (CQC-variable_list of F39() , F34()) , F42(set) -> (Element of F35()) , F43(set , set) -> (Element of F35()) , F44(set , set) -> (Element of F35()) } : F37(( F40() ! F41() )) = F38(F39() , F40() , F41())
provided
L301: (for B129 being (Element of ( CQC-WFF F34() )) holds (for B130 being (Element of F35()) holds (B130 = F37(B129) iff (ex B131 being (Function of ( CQC-WFF F34() ) , F35()) st (B130 = ( B131 . B129 ) & ( B131 . ( VERUM F34() ) ) = F36() & (for B132 , B133 being (Element of ( CQC-WFF F34() )) holds (for B134 being (bound_QC-variable of F34()) holds (for R4 being (Element of ( NAT )) holds (for B135 being (CQC-variable_list of R4 , F34()) holds (for B136 being (QC-pred_symbol of R4 , F34()) holds (( B131 . ( B136 ! B135 ) ) = F38(R4 , B136 , B135) & ( B131 . ( 'not' B132 ) ) = F42(( B131 . B132 )) & ( B131 . ( B132 '&' B133 ) ) = F43(( B131 . B132 ) , ( B131 . B133 )) & ( B131 . ( All (B134 , B132) ) ) = F44(B134 , ( B131 . B132 )))))))))))))
proof
consider C84 being (Function of ( CQC-WFF F34() ) , F35()) such that L302: (( C84 . ( VERUM F34() ) ) = F36() & (for B137 , B138 being (Element of ( CQC-WFF F34() )) holds (for B139 being (bound_QC-variable of F34()) holds (for R4 being (Element of ( NAT )) holds (for B140 being (CQC-variable_list of R4 , F34()) holds (for B141 being (QC-pred_symbol of R4 , F34()) holds (( C84 . ( B141 ! B140 ) ) = F38(R4 , B141 , B140) & ( C84 . ( 'not' B137 ) ) = F42(( C84 . B137 )) & ( C84 . ( B137 '&' B138 ) ) = F43(( C84 . B137 ) , ( C84 . B138 )) & ( C84 . ( All (B139 , B137) ) ) = F44(B139 , ( C84 . B137 ))))))))) from CQCFuncEx;
L303: F38(F39() , F40() , F41()) = ( C84 . ( F40() ! F41() ) ) by L302;
thus L304: thesis by L303 , L301 , L302;
end;
scheme CQCDefnegative { F45() -> QC-alphabet , F46() -> non  empty set , F47(set) -> (Element of F46()) , F48() -> (Element of F46()) , F49(set , set , set) -> (Element of F46()) , F50(set) -> (Element of F46()) , F51() -> (Element of ( CQC-WFF F45() )) , F52(set , set) -> (Element of F46()) , F53(set , set) -> (Element of F46()) } : F47(( 'not' F51() )) = F50(F47(F51()))
provided
L305: (for B142 being (Element of ( CQC-WFF F45() )) holds (for B143 being (Element of F46()) holds (B143 = F47(B142) iff (ex B144 being (Function of ( CQC-WFF F45() ) , F46()) st (B143 = ( B144 . B142 ) & ( B144 . ( VERUM F45() ) ) = F48() & (for B145 , B146 being (Element of ( CQC-WFF F45() )) holds (for B147 being (bound_QC-variable of F45()) holds (for R4 being (Element of ( NAT )) holds (for B148 being (CQC-variable_list of R4 , F45()) holds (for B149 being (QC-pred_symbol of R4 , F45()) holds (( B144 . ( B149 ! B148 ) ) = F49(R4 , B149 , B148) & ( B144 . ( 'not' B145 ) ) = F50(( B144 . B145 )) & ( B144 . ( B145 '&' B146 ) ) = F52(( B144 . B145 ) , ( B144 . B146 )) & ( B144 . ( All (B147 , B145) ) ) = F53(B147 , ( B144 . B145 )))))))))))))
proof
consider C85 being (Function of ( CQC-WFF F45() ) , F46()) such that L306: F47(F51()) = ( C85 . F51() ) and L307: (( C85 . ( VERUM F45() ) ) = F48() & (for B150 , B151 being (Element of ( CQC-WFF F45() )) holds (for B152 being (bound_QC-variable of F45()) holds (for R4 being (Element of ( NAT )) holds (for B153 being (CQC-variable_list of R4 , F45()) holds (for B154 being (QC-pred_symbol of R4 , F45()) holds (( C85 . ( B154 ! B153 ) ) = F49(R4 , B154 , B153) & ( C85 . ( 'not' B150 ) ) = F50(( C85 . B150 )) & ( C85 . ( B150 '&' B151 ) ) = F52(( C85 . B150 ) , ( C85 . B151 )) & ( C85 . ( All (B152 , B150) ) ) = F53(B152 , ( C85 . B150 ))))))))) by L305;
consider C86 being (Function of ( CQC-WFF F45() ) , F46()) such that L308: (( C86 . ( VERUM F45() ) ) = F48() & (for B155 , B156 being (Element of ( CQC-WFF F45() )) holds (for B157 being (bound_QC-variable of F45()) holds (for R4 being (Element of ( NAT )) holds (for B158 being (CQC-variable_list of R4 , F45()) holds (for B159 being (QC-pred_symbol of R4 , F45()) holds (( C86 . ( B159 ! B158 ) ) = F49(R4 , B159 , B158) & ( C86 . ( 'not' B155 ) ) = F50(( C86 . B155 )) & ( C86 . ( B155 '&' B156 ) ) = F52(( C86 . B155 ) , ( C86 . B156 )) & ( C86 . ( All (B157 , B155) ) ) = F53(B157 , ( C86 . B155 ))))))))) from CQCFuncEx;
L309: ( C86 . ( 'not' F51() ) ) = F50(( C86 . F51() )) by L308;
L310: C86 = C85 from CQCFuncUniq(L308 , L307);
thus L311: thesis by L310 , L305 , L308 , L309 , L306;
end;
scheme QCDefconjunctive { F54() -> QC-alphabet , F55() -> non  empty set , F56(set) -> (Element of F55()) , F57() -> (Element of F55()) , F58(set , set , set) -> (Element of F55()) , F59(set) -> (Element of F55()) , F60(set , set) -> (Element of F55()) , F61() -> (Element of ( CQC-WFF F54() )) , F62() -> (Element of ( CQC-WFF F54() )) , F63(set , set) -> (Element of F55()) } : F56(( F61() '&' F62() )) = F60(F56(F61()) , F56(F62()))
provided
L312: (for B160 being (Element of ( CQC-WFF F54() )) holds (for B161 being (Element of F55()) holds (B161 = F56(B160) iff (ex B162 being (Function of ( CQC-WFF F54() ) , F55()) st (B161 = ( B162 . B160 ) & ( B162 . ( VERUM F54() ) ) = F57() & (for B163 , B164 being (Element of ( CQC-WFF F54() )) holds (for B165 being (bound_QC-variable of F54()) holds (for R4 being (Element of ( NAT )) holds (for B166 being (CQC-variable_list of R4 , F54()) holds (for B167 being (QC-pred_symbol of R4 , F54()) holds (( B162 . ( B167 ! B166 ) ) = F58(R4 , B167 , B166) & ( B162 . ( 'not' B163 ) ) = F59(( B162 . B163 )) & ( B162 . ( B163 '&' B164 ) ) = F60(( B162 . B163 ) , ( B162 . B164 )) & ( B162 . ( All (B165 , B163) ) ) = F63(B165 , ( B162 . B163 )))))))))))))
proof
consider C87 being (Function of ( CQC-WFF F54() ) , F55()) such that L313: F56(F62()) = ( C87 . F62() ) and L314: (( C87 . ( VERUM F54() ) ) = F57() & (for B168 , B169 being (Element of ( CQC-WFF F54() )) holds (for B170 being (bound_QC-variable of F54()) holds (for R4 being (Element of ( NAT )) holds (for B171 being (CQC-variable_list of R4 , F54()) holds (for B172 being (QC-pred_symbol of R4 , F54()) holds (( C87 . ( B172 ! B171 ) ) = F58(R4 , B172 , B171) & ( C87 . ( 'not' B168 ) ) = F59(( C87 . B168 )) & ( C87 . ( B168 '&' B169 ) ) = F60(( C87 . B168 ) , ( C87 . B169 )) & ( C87 . ( All (B170 , B168) ) ) = F63(B170 , ( C87 . B168 ))))))))) by L312;
consider C88 being (Function of ( CQC-WFF F54() ) , F55()) such that L315: F56(F61()) = ( C88 . F61() ) and L316: (( C88 . ( VERUM F54() ) ) = F57() & (for B173 , B174 being (Element of ( CQC-WFF F54() )) holds (for B175 being (bound_QC-variable of F54()) holds (for R4 being (Element of ( NAT )) holds (for B176 being (CQC-variable_list of R4 , F54()) holds (for B177 being (QC-pred_symbol of R4 , F54()) holds (( C88 . ( B177 ! B176 ) ) = F58(R4 , B177 , B176) & ( C88 . ( 'not' B173 ) ) = F59(( C88 . B173 )) & ( C88 . ( B173 '&' B174 ) ) = F60(( C88 . B173 ) , ( C88 . B174 )) & ( C88 . ( All (B175 , B173) ) ) = F63(B175 , ( C88 . B173 ))))))))) by L312;
consider C89 being (Function of ( CQC-WFF F54() ) , F55()) such that L317: (( C89 . ( VERUM F54() ) ) = F57() & (for B178 , B179 being (Element of ( CQC-WFF F54() )) holds (for B180 being (bound_QC-variable of F54()) holds (for R4 being (Element of ( NAT )) holds (for B181 being (CQC-variable_list of R4 , F54()) holds (for B182 being (QC-pred_symbol of R4 , F54()) holds (( C89 . ( B182 ! B181 ) ) = F58(R4 , B182 , B181) & ( C89 . ( 'not' B178 ) ) = F59(( C89 . B178 )) & ( C89 . ( B178 '&' B179 ) ) = F60(( C89 . B178 ) , ( C89 . B179 )) & ( C89 . ( All (B180 , B178) ) ) = F63(B180 , ( C89 . B178 ))))))))) from CQCFuncEx;
L318: ( C89 . ( F61() '&' F62() ) ) = F60(( C89 . F61() ) , ( C89 . F62() )) by L317;
L319: C89 = C87 from CQCFuncUniq(L317 , L314);
L320: C89 = C88 from CQCFuncUniq(L317 , L316);
thus L321: thesis by L320 , L312 , L317 , L318 , L315 , L313 , L319;
end;
scheme QCDefuniversal { F64() -> QC-alphabet , F65() -> non  empty set , F66(set) -> (Element of F65()) , F67() -> (Element of F65()) , F68(set , set , set) -> (Element of F65()) , F69(set) -> (Element of F65()) , F70(set , set) -> (Element of F65()) , F71(set , set) -> (Element of F65()) , F72() -> (bound_QC-variable of F64()) , F73() -> (Element of ( CQC-WFF F64() )) } : F66(( All (F72() , F73()) )) = F71(F72() , F66(F73()))
provided
L322: (for B183 being (Element of ( CQC-WFF F64() )) holds (for B184 being (Element of F65()) holds (B184 = F66(B183) iff (ex B185 being (Function of ( CQC-WFF F64() ) , F65()) st (B184 = ( B185 . B183 ) & ( B185 . ( VERUM F64() ) ) = F67() & (for B186 , B187 being (Element of ( CQC-WFF F64() )) holds (for B188 being (bound_QC-variable of F64()) holds (for R4 being (Element of ( NAT )) holds (for B189 being (CQC-variable_list of R4 , F64()) holds (for B190 being (QC-pred_symbol of R4 , F64()) holds (( B185 . ( B190 ! B189 ) ) = F68(R4 , B190 , B189) & ( B185 . ( 'not' B186 ) ) = F69(( B185 . B186 )) & ( B185 . ( B186 '&' B187 ) ) = F70(( B185 . B186 ) , ( B185 . B187 )) & ( B185 . ( All (B188 , B186) ) ) = F71(B188 , ( B185 . B186 )))))))))))))
proof
consider C90 being (Function of ( CQC-WFF F64() ) , F65()) such that L323: F66(F73()) = ( C90 . F73() ) and L324: (( C90 . ( VERUM F64() ) ) = F67() & (for B191 , B192 being (Element of ( CQC-WFF F64() )) holds (for B193 being (bound_QC-variable of F64()) holds (for R4 being (Element of ( NAT )) holds (for B194 being (CQC-variable_list of R4 , F64()) holds (for B195 being (QC-pred_symbol of R4 , F64()) holds (( C90 . ( B195 ! B194 ) ) = F68(R4 , B195 , B194) & ( C90 . ( 'not' B191 ) ) = F69(( C90 . B191 )) & ( C90 . ( B191 '&' B192 ) ) = F70(( C90 . B191 ) , ( C90 . B192 )) & ( C90 . ( All (B193 , B191) ) ) = F71(B193 , ( C90 . B191 ))))))))) by L322;
consider C91 being (Function of ( CQC-WFF F64() ) , F65()) such that L325: (( C91 . ( VERUM F64() ) ) = F67() & (for B196 , B197 being (Element of ( CQC-WFF F64() )) holds (for B198 being (bound_QC-variable of F64()) holds (for R4 being (Element of ( NAT )) holds (for B199 being (CQC-variable_list of R4 , F64()) holds (for B200 being (QC-pred_symbol of R4 , F64()) holds (( C91 . ( B200 ! B199 ) ) = F68(R4 , B200 , B199) & ( C91 . ( 'not' B196 ) ) = F69(( C91 . B196 )) & ( C91 . ( B196 '&' B197 ) ) = F70(( C91 . B196 ) , ( C91 . B197 )) & ( C91 . ( All (B198 , B196) ) ) = F71(B198 , ( C91 . B196 ))))))))) from CQCFuncEx;
L326: ( C91 . ( All (F72() , F73()) ) ) = F71(F72() , ( C91 . F73() )) by L325;
L327: C91 = C90 from CQCFuncUniq(L325 , L324);
thus L328: thesis by L327 , L322 , L325 , L326 , L323;
end;
L329: (for R1 being QC-alphabet holds (for R6 being (bound_QC-variable of R1) holds (for B201 , B202 being (Function of ( QC-WFF R1 ) , ( QC-WFF R1 )) holds (((for R10 being (Element of ( QC-WFF R1 )) holds (( B201 . ( VERUM R1 ) ) = ( VERUM R1 ) & (R10 is  atomic implies ( B201 . R10 ) = ( ( the_pred_symbol_of R10 ) ! ( Subst (( the_arguments_of R10 ) , ( ( R1 a. ( 0 ) ) .--> R6 )) ) )) & (R10 is  negative implies ( B201 . R10 ) = ( 'not' ( B201 . ( the_argument_of R10 ) ) )) & (R10 is  conjunctive implies ( B201 . R10 ) = ( ( B201 . ( the_left_argument_of R10 ) ) '&' ( B201 . ( the_right_argument_of R10 ) ) )) & (R10 is  universal implies ( B201 . R10 ) = ( IFEQ (( bound_in R10 ) , R6 , R10 , ( All (( bound_in R10 ) , ( B201 . ( the_scope_of R10 ) )) )) )))) & (for R10 being (Element of ( QC-WFF R1 )) holds (( B202 . ( VERUM R1 ) ) = ( VERUM R1 ) & (R10 is  atomic implies ( B202 . R10 ) = ( ( the_pred_symbol_of R10 ) ! ( Subst (( the_arguments_of R10 ) , ( ( R1 a. ( 0 ) ) .--> R6 )) ) )) & (R10 is  negative implies ( B202 . R10 ) = ( 'not' ( B202 . ( the_argument_of R10 ) ) )) & (R10 is  conjunctive implies ( B202 . R10 ) = ( ( B202 . ( the_left_argument_of R10 ) ) '&' ( B202 . ( the_right_argument_of R10 ) ) )) & (R10 is  universal implies ( B202 . R10 ) = ( IFEQ (( bound_in R10 ) , R6 , R10 , ( All (( bound_in R10 ) , ( B202 . ( the_scope_of R10 ) )) )) ))))) implies B201 = B202))))
proof
let R1 being QC-alphabet;
let R6 being (bound_QC-variable of R1);
deffunc H3((Element of ( QC-WFF R1 )) , (Element of ( QC-WFF R1 ))) = ( $1 '&' $2 );
deffunc H4((Element of ( QC-WFF R1 ))) = ( 'not' $1 );
let C92 , C93 being (Function of ( QC-WFF R1 ) , ( QC-WFF R1 ));
deffunc H5((Element of ( QC-WFF R1 ))) = ( ( the_pred_symbol_of $1 ) ! ( Subst (( the_arguments_of $1 ) , ( ( R1 a. ( 0 ) ) .--> R6 )) ) );
deffunc H6((Element of ( QC-WFF R1 )) , (Element of ( QC-WFF R1 ))) = ( IFEQ (( bound_in $1 ) , R6 , $1 , ( All (( bound_in $1 ) , $2) )) );
assume L330: (for R10 being (Element of ( QC-WFF R1 )) holds (( C92 . ( VERUM R1 ) ) = ( VERUM R1 ) & (R10 is  atomic implies ( C92 . R10 ) = H5(R10)) & (R10 is  negative implies ( C92 . R10 ) = ( 'not' ( C92 . ( the_argument_of R10 ) ) )) & (R10 is  conjunctive implies ( C92 . R10 ) = ( ( C92 . ( the_left_argument_of R10 ) ) '&' ( C92 . ( the_right_argument_of R10 ) ) )) & (R10 is  universal implies ( C92 . R10 ) = ( IFEQ (( bound_in R10 ) , R6 , R10 , ( All (( bound_in R10 ) , ( C92 . ( the_scope_of R10 ) )) )) ))));
L331: (for B203 being (Element of ( QC-WFF R1 )) holds (for B204 , B205 being (Element of ( QC-WFF R1 )) holds ((B203 = ( VERUM R1 ) implies ( C92 . B203 ) = ( VERUM R1 )) & (B203 is  atomic implies ( C92 . B203 ) = H5(B203)) & ((B203 is  negative & B204 = ( C92 . ( the_argument_of B203 ) )) implies ( C92 . B203 ) = H4(B204)) & ((B203 is  conjunctive & B204 = ( C92 . ( the_left_argument_of B203 ) ) & B205 = ( C92 . ( the_right_argument_of B203 ) )) implies ( C92 . B203 ) = H3(B204 , B205)) & ((B203 is  universal & B204 = ( C92 . ( the_scope_of B203 ) )) implies ( C92 . B203 ) = H6(B203 , B204))))) by L330;
assume L332: (for R10 being (Element of ( QC-WFF R1 )) holds (( C93 . ( VERUM R1 ) ) = ( VERUM R1 ) & (R10 is  atomic implies ( C93 . R10 ) = ( ( the_pred_symbol_of R10 ) ! ( Subst (( the_arguments_of R10 ) , ( ( R1 a. ( 0 ) ) .--> R6 )) ) )) & (R10 is  negative implies ( C93 . R10 ) = ( 'not' ( C93 . ( the_argument_of R10 ) ) )) & (R10 is  conjunctive implies ( C93 . R10 ) = ( ( C93 . ( the_left_argument_of R10 ) ) '&' ( C93 . ( the_right_argument_of R10 ) ) )) & (R10 is  universal implies ( C93 . R10 ) = ( IFEQ (( bound_in R10 ) , R6 , R10 , ( All (( bound_in R10 ) , ( C93 . ( the_scope_of R10 ) )) )) ))));
L333: (for B206 being (Element of ( QC-WFF R1 )) holds (for B207 , B208 being (Element of ( QC-WFF R1 )) holds ((B206 = ( VERUM R1 ) implies ( C93 . B206 ) = ( VERUM R1 )) & (B206 is  atomic implies ( C93 . B206 ) = H5(B206)) & ((B206 is  negative & B207 = ( C93 . ( the_argument_of B206 ) )) implies ( C93 . B206 ) = H4(B207)) & ((B206 is  conjunctive & B207 = ( C93 . ( the_left_argument_of B206 ) ) & B208 = ( C93 . ( the_right_argument_of B206 ) )) implies ( C93 . B206 ) = H3(B207 , B208)) & ((B206 is  universal & B207 = ( C93 . ( the_scope_of B206 ) )) implies ( C93 . B206 ) = H6(B206 , B207))))) by L332;
thus L334: C92 = C93 from QC_LANG3:sch 1(L331 , L333);
end;
definition
let R1 being QC-alphabet;
let R9 being (Element of ( QC-WFF R1 ));
let R6 being (bound_QC-variable of R1);
func R9 . R6 -> (Element of ( QC-WFF R1 )) means 
:L335: (ex B209 being (Function of ( QC-WFF R1 ) , ( QC-WFF R1 )) st (it = ( B209 . R9 ) & (for R10 being (Element of ( QC-WFF R1 )) holds (( B209 . ( VERUM R1 ) ) = ( VERUM R1 ) & (R10 is  atomic implies ( B209 . R10 ) = ( ( the_pred_symbol_of R10 ) ! ( Subst (( the_arguments_of R10 ) , ( ( R1 a. ( 0 ) ) .--> R6 )) ) )) & (R10 is  negative implies ( B209 . R10 ) = ( 'not' ( B209 . ( the_argument_of R10 ) ) )) & (R10 is  conjunctive implies ( B209 . R10 ) = ( ( B209 . ( the_left_argument_of R10 ) ) '&' ( B209 . ( the_right_argument_of R10 ) ) )) & (R10 is  universal implies ( B209 . R10 ) = ( IFEQ (( bound_in R10 ) , R6 , R10 , ( All (( bound_in R10 ) , ( B209 . ( the_scope_of R10 ) )) )) ))))));
existence
proof
deffunc H7((Element of ( QC-WFF R1 )) , (Element of ( QC-WFF R1 ))) = ( IFEQ (( bound_in $1 ) , R6 , $1 , ( All (( bound_in $1 ) , $2) )) );
deffunc H8((Element of ( QC-WFF R1 )) , (Element of ( QC-WFF R1 ))) = ( $1 '&' $2 );
deffunc H9((Element of ( QC-WFF R1 ))) = ( 'not' $1 );
deffunc H10((Element of ( QC-WFF R1 ))) = ( ( the_pred_symbol_of $1 ) ! ( Subst (( the_arguments_of $1 ) , ( ( R1 a. ( 0 ) ) .--> R6 )) ) );
consider C94 being (Function of ( QC-WFF R1 ) , ( QC-WFF R1 )) such that L336: (( C94 . ( VERUM R1 ) ) = ( VERUM R1 ) & (for B210 being (Element of ( QC-WFF R1 )) holds ((B210 is  atomic implies ( C94 . B210 ) = H10(B210)) & (B210 is  negative implies ( C94 . B210 ) = H9(( C94 . ( the_argument_of B210 ) ))) & (B210 is  conjunctive implies ( C94 . B210 ) = H8(( C94 . ( the_left_argument_of B210 ) ) , ( C94 . ( the_right_argument_of B210 ) ))) & (B210 is  universal implies ( C94 . B210 ) = H7(B210 , ( C94 . ( the_scope_of B210 ) )))))) from QC_LANG1:sch 3;
take ( C94 . R9 );
take C94;
thus L337: ( C94 . R9 ) = ( C94 . R9 );
thus L338: thesis by L336;
end;
uniqueness by L329;
end;
theorem
L340: (for R1 being QC-alphabet holds (for R6 being (bound_QC-variable of R1) holds ( ( VERUM R1 ) . R6 ) = ( VERUM R1 )))
proof
let R1 being QC-alphabet;
let R6 being (bound_QC-variable of R1);
L341: (ex B211 being (Function of ( QC-WFF R1 ) , ( QC-WFF R1 )) st (( ( VERUM R1 ) . R6 ) = ( B211 . ( VERUM R1 ) ) & (for R10 being (Element of ( QC-WFF R1 )) holds (( B211 . ( VERUM R1 ) ) = ( VERUM R1 ) & (R10 is  atomic implies ( B211 . R10 ) = ( ( the_pred_symbol_of R10 ) ! ( Subst (( the_arguments_of R10 ) , ( ( R1 a. ( 0 ) ) .--> R6 )) ) )) & (R10 is  negative implies ( B211 . R10 ) = ( 'not' ( B211 . ( the_argument_of R10 ) ) )) & (R10 is  conjunctive implies ( B211 . R10 ) = ( ( B211 . ( the_left_argument_of R10 ) ) '&' ( B211 . ( the_right_argument_of R10 ) ) )) & (R10 is  universal implies ( B211 . R10 ) = ( IFEQ (( bound_in R10 ) , R6 , R10 , ( All (( bound_in R10 ) , ( B211 . ( the_scope_of R10 ) )) )) )))))) by L335;
thus L342: thesis by L341;
end;
theorem
L343: (for R1 being QC-alphabet holds (for R6 being (bound_QC-variable of R1) holds (for R9 being (Element of ( QC-WFF R1 )) holds (R9 is  atomic implies ( R9 . R6 ) = ( ( the_pred_symbol_of R9 ) ! ( Subst (( the_arguments_of R9 ) , ( ( R1 a. ( 0 ) ) .--> R6 )) ) )))))
proof
let R1 being QC-alphabet;
let R6 being (bound_QC-variable of R1);
let R9 being (Element of ( QC-WFF R1 ));
L344: (ex B212 being (Function of ( QC-WFF R1 ) , ( QC-WFF R1 )) st (( R9 . R6 ) = ( B212 . R9 ) & (for R10 being (Element of ( QC-WFF R1 )) holds (( B212 . ( VERUM R1 ) ) = ( VERUM R1 ) & (R10 is  atomic implies ( B212 . R10 ) = ( ( the_pred_symbol_of R10 ) ! ( Subst (( the_arguments_of R10 ) , ( ( R1 a. ( 0 ) ) .--> R6 )) ) )) & (R10 is  negative implies ( B212 . R10 ) = ( 'not' ( B212 . ( the_argument_of R10 ) ) )) & (R10 is  conjunctive implies ( B212 . R10 ) = ( ( B212 . ( the_left_argument_of R10 ) ) '&' ( B212 . ( the_right_argument_of R10 ) ) )) & (R10 is  universal implies ( B212 . R10 ) = ( IFEQ (( bound_in R10 ) , R6 , R10 , ( All (( bound_in R10 ) , ( B212 . ( the_scope_of R10 ) )) )) )))))) by L335;
thus L345: thesis by L344;
end;
theorem
L346: (for R1 being QC-alphabet holds (for R4 being (Element of ( NAT )) holds (for R6 being (bound_QC-variable of R1) holds (for B213 being (QC-pred_symbol of R4 , R1) holds (for B214 being (QC-variable_list of R4 , R1) holds ( ( B213 ! B214 ) . R6 ) = ( B213 ! ( Subst (B214 , ( ( R1 a. ( 0 ) ) .--> R6 )) ) ))))))
proof
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
let R6 being (bound_QC-variable of R1);
let C95 being (QC-pred_symbol of R4 , R1);
let C96 being (QC-variable_list of R4 , R1);
reconsider D23 = C95 as (QC-pred_symbol of R1);
L347: ( C95 ! C96 ) is  atomic by QC_LANG1:def 18;
L348: (( the_arguments_of ( C95 ! C96 ) ) = C96 & ( the_pred_symbol_of ( C95 ! C96 ) ) = D23) by L347 , QC_LANG1:def 22 , QC_LANG1:def 23;
thus L349: thesis by L348 , L347 , L343;
end;
theorem
L350: (for R1 being QC-alphabet holds (for R6 being (bound_QC-variable of R1) holds (for R9 being (Element of ( QC-WFF R1 )) holds (R9 is  negative implies ( R9 . R6 ) = ( 'not' ( ( the_argument_of R9 ) . R6 ) )))))
proof
let R1 being QC-alphabet;
let R6 being (bound_QC-variable of R1);
let R9 being (Element of ( QC-WFF R1 ));
consider C97 being (Function of ( QC-WFF R1 ) , ( QC-WFF R1 )) such that L351: ( R9 . R6 ) = ( C97 . R9 ) and L352: (for R10 being (Element of ( QC-WFF R1 )) holds (( C97 . ( VERUM R1 ) ) = ( VERUM R1 ) & (R10 is  atomic implies ( C97 . R10 ) = ( ( the_pred_symbol_of R10 ) ! ( Subst (( the_arguments_of R10 ) , ( ( R1 a. ( 0 ) ) .--> R6 )) ) )) & (R10 is  negative implies ( C97 . R10 ) = ( 'not' ( C97 . ( the_argument_of R10 ) ) )) & (R10 is  conjunctive implies ( C97 . R10 ) = ( ( C97 . ( the_left_argument_of R10 ) ) '&' ( C97 . ( the_right_argument_of R10 ) ) )) & (R10 is  universal implies ( C97 . R10 ) = ( IFEQ (( bound_in R10 ) , R6 , R10 , ( All (( bound_in R10 ) , ( C97 . ( the_scope_of R10 ) )) )) )))) by L335;
consider C98 being (Function of ( QC-WFF R1 ) , ( QC-WFF R1 )) such that L353: ( ( the_argument_of R9 ) . R6 ) = ( C98 . ( the_argument_of R9 ) ) and L354: (for R10 being (Element of ( QC-WFF R1 )) holds (( C98 . ( VERUM R1 ) ) = ( VERUM R1 ) & (R10 is  atomic implies ( C98 . R10 ) = ( ( the_pred_symbol_of R10 ) ! ( Subst (( the_arguments_of R10 ) , ( ( R1 a. ( 0 ) ) .--> R6 )) ) )) & (R10 is  negative implies ( C98 . R10 ) = ( 'not' ( C98 . ( the_argument_of R10 ) ) )) & (R10 is  conjunctive implies ( C98 . R10 ) = ( ( C98 . ( the_left_argument_of R10 ) ) '&' ( C98 . ( the_right_argument_of R10 ) ) )) & (R10 is  universal implies ( C98 . R10 ) = ( IFEQ (( bound_in R10 ) , R6 , R10 , ( All (( bound_in R10 ) , ( C98 . ( the_scope_of R10 ) )) )) )))) by L335;
L355: C97 = C98 by L352 , L354 , L329;
thus L356: thesis by L355 , L351 , L352 , L353;
end;
theorem
L357: (for R1 being QC-alphabet holds (for R6 being (bound_QC-variable of R1) holds (for R9 being (Element of ( QC-WFF R1 )) holds ( ( 'not' R9 ) . R6 ) = ( 'not' ( R9 . R6 ) ))))
proof
let R1 being QC-alphabet;
let R6 being (bound_QC-variable of R1);
let R9 being (Element of ( QC-WFF R1 ));
set D24 = ( 'not' R9 );
L358: D24 is  negative by QC_LANG1:def 19;
L359: ( the_argument_of D24 ) = R9 by L358 , QC_LANG1:def 24;
thus L360: thesis by L359 , L358 , L350;
end;
theorem
L361: (for R1 being QC-alphabet holds (for R6 being (bound_QC-variable of R1) holds (for R9 being (Element of ( QC-WFF R1 )) holds (R9 is  conjunctive implies ( R9 . R6 ) = ( ( ( the_left_argument_of R9 ) . R6 ) '&' ( ( the_right_argument_of R9 ) . R6 ) )))))
proof
let R1 being QC-alphabet;
let R6 being (bound_QC-variable of R1);
let R9 being (Element of ( QC-WFF R1 ));
consider C99 being (Function of ( QC-WFF R1 ) , ( QC-WFF R1 )) such that L362: ( R9 . R6 ) = ( C99 . R9 ) and L363: (for R10 being (Element of ( QC-WFF R1 )) holds (( C99 . ( VERUM R1 ) ) = ( VERUM R1 ) & (R10 is  atomic implies ( C99 . R10 ) = ( ( the_pred_symbol_of R10 ) ! ( Subst (( the_arguments_of R10 ) , ( ( R1 a. ( 0 ) ) .--> R6 )) ) )) & (R10 is  negative implies ( C99 . R10 ) = ( 'not' ( C99 . ( the_argument_of R10 ) ) )) & (R10 is  conjunctive implies ( C99 . R10 ) = ( ( C99 . ( the_left_argument_of R10 ) ) '&' ( C99 . ( the_right_argument_of R10 ) ) )) & (R10 is  universal implies ( C99 . R10 ) = ( IFEQ (( bound_in R10 ) , R6 , R10 , ( All (( bound_in R10 ) , ( C99 . ( the_scope_of R10 ) )) )) )))) by L335;
consider C100 being (Function of ( QC-WFF R1 ) , ( QC-WFF R1 )) such that L364: ( ( the_right_argument_of R9 ) . R6 ) = ( C100 . ( the_right_argument_of R9 ) ) and L365: (for R10 being (Element of ( QC-WFF R1 )) holds (( C100 . ( VERUM R1 ) ) = ( VERUM R1 ) & (R10 is  atomic implies ( C100 . R10 ) = ( ( the_pred_symbol_of R10 ) ! ( Subst (( the_arguments_of R10 ) , ( ( R1 a. ( 0 ) ) .--> R6 )) ) )) & (R10 is  negative implies ( C100 . R10 ) = ( 'not' ( C100 . ( the_argument_of R10 ) ) )) & (R10 is  conjunctive implies ( C100 . R10 ) = ( ( C100 . ( the_left_argument_of R10 ) ) '&' ( C100 . ( the_right_argument_of R10 ) ) )) & (R10 is  universal implies ( C100 . R10 ) = ( IFEQ (( bound_in R10 ) , R6 , R10 , ( All (( bound_in R10 ) , ( C100 . ( the_scope_of R10 ) )) )) )))) by L335;
L366: C100 = C99 by L363 , L365 , L329;
consider C101 being (Function of ( QC-WFF R1 ) , ( QC-WFF R1 )) such that L367: ( ( the_left_argument_of R9 ) . R6 ) = ( C101 . ( the_left_argument_of R9 ) ) and L368: (for R10 being (Element of ( QC-WFF R1 )) holds (( C101 . ( VERUM R1 ) ) = ( VERUM R1 ) & (R10 is  atomic implies ( C101 . R10 ) = ( ( the_pred_symbol_of R10 ) ! ( Subst (( the_arguments_of R10 ) , ( ( R1 a. ( 0 ) ) .--> R6 )) ) )) & (R10 is  negative implies ( C101 . R10 ) = ( 'not' ( C101 . ( the_argument_of R10 ) ) )) & (R10 is  conjunctive implies ( C101 . R10 ) = ( ( C101 . ( the_left_argument_of R10 ) ) '&' ( C101 . ( the_right_argument_of R10 ) ) )) & (R10 is  universal implies ( C101 . R10 ) = ( IFEQ (( bound_in R10 ) , R6 , R10 , ( All (( bound_in R10 ) , ( C101 . ( the_scope_of R10 ) )) )) )))) by L335;
L369: C101 = C99 by L363 , L368 , L329;
thus L370: thesis by L369 , L362 , L363 , L367 , L364 , L366;
end;
theorem
L371: (for R1 being QC-alphabet holds (for R6 being (bound_QC-variable of R1) holds (for R9 being (Element of ( QC-WFF R1 )) holds (for R10 being (Element of ( QC-WFF R1 )) holds ( ( R9 '&' R10 ) . R6 ) = ( ( R9 . R6 ) '&' ( R10 . R6 ) )))))
proof
let R1 being QC-alphabet;
let R6 being (bound_QC-variable of R1);
let R9 being (Element of ( QC-WFF R1 ));
let R10 being (Element of ( QC-WFF R1 ));
set D25 = ( R9 '&' R10 );
L372: ( R9 '&' R10 ) is  conjunctive by QC_LANG1:def 20;
L373: (( the_left_argument_of D25 ) = R9 & ( the_right_argument_of D25 ) = R10) by L372 , QC_LANG1:def 25 , QC_LANG1:def 26;
thus L374: thesis by L373 , L372 , L361;
end;
L375: (for R1 being QC-alphabet holds (for R6 being (bound_QC-variable of R1) holds (for R9 being (Element of ( QC-WFF R1 )) holds (R9 is  universal implies ( R9 . R6 ) = ( IFEQ (( bound_in R9 ) , R6 , R9 , ( All (( bound_in R9 ) , ( ( the_scope_of R9 ) . R6 )) )) )))))
proof
let R1 being QC-alphabet;
let R6 being (bound_QC-variable of R1);
let R9 being (Element of ( QC-WFF R1 ));
consider C102 being (Function of ( QC-WFF R1 ) , ( QC-WFF R1 )) such that L376: ( R9 . R6 ) = ( C102 . R9 ) and L377: (for R10 being (Element of ( QC-WFF R1 )) holds (( C102 . ( VERUM R1 ) ) = ( VERUM R1 ) & (R10 is  atomic implies ( C102 . R10 ) = ( ( the_pred_symbol_of R10 ) ! ( Subst (( the_arguments_of R10 ) , ( ( R1 a. ( 0 ) ) .--> R6 )) ) )) & (R10 is  negative implies ( C102 . R10 ) = ( 'not' ( C102 . ( the_argument_of R10 ) ) )) & (R10 is  conjunctive implies ( C102 . R10 ) = ( ( C102 . ( the_left_argument_of R10 ) ) '&' ( C102 . ( the_right_argument_of R10 ) ) )) & (R10 is  universal implies ( C102 . R10 ) = ( IFEQ (( bound_in R10 ) , R6 , R10 , ( All (( bound_in R10 ) , ( C102 . ( the_scope_of R10 ) )) )) )))) by L335;
consider C103 being (Function of ( QC-WFF R1 ) , ( QC-WFF R1 )) such that L378: ( ( the_scope_of R9 ) . R6 ) = ( C103 . ( the_scope_of R9 ) ) and L379: (for R10 being (Element of ( QC-WFF R1 )) holds (( C103 . ( VERUM R1 ) ) = ( VERUM R1 ) & (R10 is  atomic implies ( C103 . R10 ) = ( ( the_pred_symbol_of R10 ) ! ( Subst (( the_arguments_of R10 ) , ( ( R1 a. ( 0 ) ) .--> R6 )) ) )) & (R10 is  negative implies ( C103 . R10 ) = ( 'not' ( C103 . ( the_argument_of R10 ) ) )) & (R10 is  conjunctive implies ( C103 . R10 ) = ( ( C103 . ( the_left_argument_of R10 ) ) '&' ( C103 . ( the_right_argument_of R10 ) ) )) & (R10 is  universal implies ( C103 . R10 ) = ( IFEQ (( bound_in R10 ) , R6 , R10 , ( All (( bound_in R10 ) , ( C103 . ( the_scope_of R10 ) )) )) )))) by L335;
L380: C102 = C103 by L377 , L379 , L329;
thus L381: thesis by L380 , L376 , L377 , L378;
end;
theorem
L382: (for R1 being QC-alphabet holds (for R6 being (bound_QC-variable of R1) holds (for R9 being (Element of ( QC-WFF R1 )) holds ((R9 is  universal & ( bound_in R9 ) = R6) implies ( R9 . R6 ) = R9))))
proof
let R1 being QC-alphabet;
let R6 being (bound_QC-variable of R1);
let R9 being (Element of ( QC-WFF R1 ));
assume L383: R9 is  universal;
L384: ( R9 . R6 ) = ( IFEQ (( bound_in R9 ) , R6 , R9 , ( All (( bound_in R9 ) , ( ( the_scope_of R9 ) . R6 )) )) ) by L383 , L375;
thus L385: thesis by L384 , FUNCOP_1:def 8;
end;
theorem
L386: (for R1 being QC-alphabet holds (for R6 being (bound_QC-variable of R1) holds (for R9 being (Element of ( QC-WFF R1 )) holds ((R9 is  universal & ( bound_in R9 ) <> R6) implies ( R9 . R6 ) = ( All (( bound_in R9 ) , ( ( the_scope_of R9 ) . R6 )) )))))
proof
let R1 being QC-alphabet;
let R6 being (bound_QC-variable of R1);
let R9 being (Element of ( QC-WFF R1 ));
assume L387: R9 is  universal;
L388: ( R9 . R6 ) = ( IFEQ (( bound_in R9 ) , R6 , R9 , ( All (( bound_in R9 ) , ( ( the_scope_of R9 ) . R6 )) )) ) by L387 , L375;
thus L389: thesis by L388 , FUNCOP_1:def 8;
end;
theorem
L390: (for R1 being QC-alphabet holds (for R6 being (bound_QC-variable of R1) holds (for R9 being (Element of ( QC-WFF R1 )) holds ( ( All (R6 , R9) ) . R6 ) = ( All (R6 , R9) ))))
proof
let R1 being QC-alphabet;
let R6 being (bound_QC-variable of R1);
let R9 being (Element of ( QC-WFF R1 ));
set D26 = ( All (R6 , R9) );
L391: D26 is  universal by QC_LANG1:def 21;
L392: ( bound_in D26 ) = R6 by L391 , QC_LANG1:def 27;
thus L393: thesis by L392 , L391 , L382;
end;
theorem
L394: (for R1 being QC-alphabet holds (for R6 being (bound_QC-variable of R1) holds (for R7 being (bound_QC-variable of R1) holds (for R9 being (Element of ( QC-WFF R1 )) holds (R6 <> R7 implies ( ( All (R6 , R9) ) . R7 ) = ( All (R6 , ( R9 . R7 )) ))))))
proof
let R1 being QC-alphabet;
let R6 being (bound_QC-variable of R1);
let R7 being (bound_QC-variable of R1);
let R9 being (Element of ( QC-WFF R1 ));
set D27 = ( All (R6 , R9) );
L395: D27 is  universal by QC_LANG1:def 21;
L396: (( the_scope_of D27 ) = R9 & ( bound_in D27 ) = R6) by L395 , QC_LANG1:def 27 , QC_LANG1:def 28;
thus L397: thesis by L396 , L395 , L386;
end;
theorem
L398: (for R1 being QC-alphabet holds (for R6 being (bound_QC-variable of R1) holds (for R9 being (Element of ( QC-WFF R1 )) holds (( Free R9 ) = ( {} ) implies ( R9 . R6 ) = R9))))
proof
let R1 being QC-alphabet;
let R6 being (bound_QC-variable of R1);
let R9 being (Element of ( QC-WFF R1 ));
defpred S4[ (Element of ( QC-WFF R1 )) ] means (( Free $1 ) = ( {} ) implies ( $1 . R6 ) = $1);
L399: (for R9 being (Element of ( QC-WFF R1 )) holds (S4[ R9 ] implies S4[ ( 'not' R9 ) ])) by L357 , QC_LANG3:55;
L400: (for R9 being (Element of ( QC-WFF R1 )) holds (for R10 being (Element of ( QC-WFF R1 )) holds ((S4[ R9 ] & S4[ R10 ]) implies S4[ ( R9 '&' R10 ) ])))
proof
let R9 being (Element of ( QC-WFF R1 ));
let R10 being (Element of ( QC-WFF R1 ));
assume L401: ((( Free R9 ) = ( {} ) implies ( R9 . R6 ) = R9) & (( Free R10 ) = ( {} ) implies ( R10 . R6 ) = R10));
assume L402: ( Free ( R9 '&' R10 ) ) = ( {} );
L403: ( ( Free R9 ) \/ ( Free R10 ) ) = ( {} ) by L402 , QC_LANG3:57;
thus L404: thesis by L403 , L401 , L371;
end;
L405: (for R4 being (Element of ( NAT )) holds (for B215 being (QC-pred_symbol of R4 , R1) holds (for B216 being (QC-variable_list of R4 , R1) holds S4[ ( B215 ! B216 ) ])))
proof
let R4 being (Element of ( NAT ));
let C104 being (QC-pred_symbol of R4 , R1);
let C105 being (QC-variable_list of R4 , R1);
assume L406: ( Free ( C104 ! C105 ) ) = ( {} );
L407:
now
let C106 being  natural number;
assume L408: (1 <= C106 & C106 <= ( len C105 ));
L409: C106 in ( NAT ) by ORDINAL1:def 12;
L410:
now
assume L411: ( C105 . C106 ) = ( R1 a. ( 0 ) );
L412: ( R1 a. ( 0 ) ) in { ( C105 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len C105 ) & ( C105 . R2 ) in ( free_QC-variables R1 )) } by L411 , L409 , L408;
thus L413: contradiction by L412 , L406 , QC_LANG3:54;
end;
thus L414: ( ( Subst (C105 , ( ( R1 a. ( 0 ) ) .--> R6 )) ) . C106 ) = ( C105 . C106 ) by L410 , L409 , L408 , L73;
end;
L415: ( len ( Subst (C105 , ( ( R1 a. ( 0 ) ) .--> R6 )) ) ) = ( len C105 ) by L27;
L416: ( Subst (C105 , ( ( R1 a. ( 0 ) ) .--> R6 )) ) = C105 by L415 , L407 , FINSEQ_1:14;
thus L417: thesis by L416 , L346;
end;
L418: (for R7 being (bound_QC-variable of R1) holds (for R9 being (Element of ( QC-WFF R1 )) holds (S4[ R9 ] implies S4[ ( All (R7 , R9) ) ])))
proof
let R7 being (bound_QC-variable of R1);
let R9 being (Element of ( QC-WFF R1 ));
assume L419: (( Free R9 ) = ( {} ) implies ( R9 . R6 ) = R9);
L420: (R6 = R7 implies ( ( All (R7 , R9) ) . R6 ) = ( All (R7 , R9) )) by L390;
assume L421: ( Free ( All (R7 , R9) ) ) = ( {} );
thus L422: thesis by L421 , L419 , L420 , L394 , QC_LANG3:58;
end;
L423: S4[ ( VERUM R1 ) ] by L340;
L424: (for R9 being (Element of ( QC-WFF R1 )) holds S4[ R9 ]) from QC_LANG1:sch 1(L405 , L423 , L399 , L400 , L418);
thus L425: thesis by L424;
end;
theorem
L426: (for R1 being QC-alphabet holds (for R6 being (bound_QC-variable of R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds ( R15 . R6 ) = R15)))
proof
let R1 being QC-alphabet;
let R6 being (bound_QC-variable of R1);
let R15 being (Element of ( CQC-WFF R1 ));
L427: ( Free R15 ) = ( {} ) by L95;
thus L428: thesis by L427 , L398;
end;
theorem
L429: (for R1 being QC-alphabet holds (for R6 being (bound_QC-variable of R1) holds (for R9 being (Element of ( QC-WFF R1 )) holds ( Fixed ( R9 . R6 ) ) = ( Fixed R9 ))))
proof
let R1 being QC-alphabet;
let R6 being (bound_QC-variable of R1);
let R9 being (Element of ( QC-WFF R1 ));
defpred S5[ (Element of ( QC-WFF R1 )) ] means ( Fixed ( $1 . R6 ) ) = ( Fixed $1 );
L430: (for R9 being (Element of ( QC-WFF R1 )) holds (S5[ R9 ] implies S5[ ( 'not' R9 ) ]))
proof
let R9 being (Element of ( QC-WFF R1 ));
assume that
L431: ( Fixed ( R9 . R6 ) ) = ( Fixed R9 );
thus L432: ( Fixed ( ( 'not' R9 ) . R6 ) ) = ( Fixed ( 'not' ( R9 . R6 ) ) ) by L357
.= ( Fixed R9 ) by L431 , QC_LANG3:65
.= ( Fixed ( 'not' R9 ) ) by QC_LANG3:65;
end;
L433: (for R9 being (Element of ( QC-WFF R1 )) holds (for R10 being (Element of ( QC-WFF R1 )) holds ((S5[ R9 ] & S5[ R10 ]) implies S5[ ( R9 '&' R10 ) ])))
proof
let R9 being (Element of ( QC-WFF R1 ));
let R10 being (Element of ( QC-WFF R1 ));
assume that
L434: (( Fixed ( R9 . R6 ) ) = ( Fixed R9 ) & ( Fixed ( R10 . R6 ) ) = ( Fixed R10 ));
thus L435: ( Fixed ( ( R9 '&' R10 ) . R6 ) ) = ( Fixed ( ( R9 . R6 ) '&' ( R10 . R6 ) ) ) by L371
.= ( ( Fixed R9 ) \/ ( Fixed R10 ) ) by L434 , QC_LANG3:67
.= ( Fixed ( R9 '&' R10 ) ) by QC_LANG3:67;
end;
L436: (for R4 being (Element of ( NAT )) holds (for B217 being (QC-pred_symbol of R4 , R1) holds (for B218 being (QC-variable_list of R4 , R1) holds S5[ ( B217 ! B218 ) ])))
proof
let R4 being (Element of ( NAT ));
let C107 being (QC-pred_symbol of R4 , R1);
let C108 being (QC-variable_list of R4 , R1);
set D28 = { ( C108 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len C108 ) & ( C108 . R2 ) in ( fixed_QC-variables R1 )) };
set D29 = ( Subst (C108 , ( ( R1 a. ( 0 ) ) .--> R6 )) );
set D30 = { ( D29 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len D29 ) & ( D29 . R2 ) in ( fixed_QC-variables R1 )) };
L437: ( len C108 ) = ( len D29 ) by L27;
L438:
now
let C109 being set;
thus L439: (C109 in D28 implies C109 in D30)
proof
assume L440: C109 in D28;
consider R2 being (Element of ( NAT )) such that L441: C109 = ( C108 . R2 ) and L442: (1 <= R2 & R2 <= ( len C108 )) and L443: ( C108 . R2 ) in ( fixed_QC-variables R1 ) by L440;
L444: ( C108 . R2 ) <> ( R1 a. ( 0 ) ) by L443 , QC_LANG3:32;
L445: ( D29 . R2 ) = ( C108 . R2 ) by L444 , L442 , L73;
thus L446: thesis by L445 , L437 , L441 , L442 , L443;
end;

assume L447: C109 in D30;
consider R2 being (Element of ( NAT )) such that L448: C109 = ( D29 . R2 ) and L449: (1 <= R2 & R2 <= ( len D29 )) and L450: ( D29 . R2 ) in ( fixed_QC-variables R1 ) by L447;
L451:
now
assume L452: ( C108 . R2 ) = ( R1 a. ( 0 ) );
L453: ( D29 . R2 ) = R6 by L452 , L437 , L449 , L73;
thus L454: contradiction by L453 , L450 , L1;
end;
L455: ( D29 . R2 ) = ( C108 . R2 ) by L451 , L437 , L449 , L73;
thus L456: C109 in D28 by L455 , L437 , L448 , L449 , L450;
end;
L457: D28 = D30 by L438 , TARSKI:1;
L458: (( Fixed ( C107 ! C108 ) ) = D28 & ( Fixed ( C107 ! D29 ) ) = D30) by QC_LANG3:64;
thus L459: thesis by L458 , L457 , L346;
end;
L460: (for R7 being (bound_QC-variable of R1) holds (for R9 being (Element of ( QC-WFF R1 )) holds (S5[ R9 ] implies S5[ ( All (R7 , R9) ) ])))
proof
let R7 being (bound_QC-variable of R1);
let R9 being (Element of ( QC-WFF R1 ));
assume that
L461: ( Fixed ( R9 . R6 ) ) = ( Fixed R9 );
L462:
now
assume L463: R6 <> R7;
thus L464: ( Fixed ( ( All (R7 , R9) ) . R6 ) ) = ( Fixed ( All (R7 , ( R9 . R6 )) ) ) by L463 , L394
.= ( Fixed R9 ) by L461 , QC_LANG3:68
.= ( Fixed ( All (R7 , R9) ) ) by QC_LANG3:68;
end;
thus L465: thesis by L462 , L390;
end;
L466: S5[ ( VERUM R1 ) ] by L340;
L467: (for R9 being (Element of ( QC-WFF R1 )) holds S5[ R9 ]) from QC_LANG1:sch 1(L436 , L466 , L430 , L433 , L460);
thus L468: thesis by L467;
end;
begin
theorem
L469: (for R17 being set holds (for R18 being set holds (for R19 being set holds ( (R17 , R18) :-> R19 ) = ( [ R17 , R18 ] .--> R19 ))));
theorem
L470: (for R17 being set holds (for R18 being set holds (for R19 being set holds ( ( (R17 , R18) :-> R19 ) . (R17 , R18) ) = R19))) by FUNCT_4:80;
theorem
L471: (for B219 , B220 , B221 being set holds ( (B219 , B219) --> (B220 , B221) ) = ( B219 .--> B221 )) by FUNCT_4:81;
theorem
L472: (for B222 being Function holds (for B223 , B224 , B225 being set holds (B223 <> B225 implies ( ( B222 +* ( B223 .--> B224 ) ) . B225 ) = ( B222 . B225 )))) by FUNCT_4:83;
theorem
L473: (for B226 being Function holds (for B227 , B228 , B229 , B230 being set holds (B227 <> B228 implies (( ( B226 +* ( (B227 , B228) --> (B229 , B230) ) ) . B227 ) = B229 & ( ( B226 +* ( (B227 , B228) --> (B229 , B230) ) ) . B228 ) = B230)))) by FUNCT_4:84;
