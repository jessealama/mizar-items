:: Inverse Limits of Many Sorted Algebras
::  by Adam Grabowski
::
:: Received June 11, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, ORDERS_2, SUBSET_1, STRUCT_0, MSUALG_1, PRALG_2,
      FUNCT_1, RELAT_1, CARD_3, RLVECT_2, PBOOLE, XXREAL_0, MEMBER_1, MSUALG_3,
      FUNCOP_1, RELAT_2, MCART_1, MSUALG_2, TARSKI, UNIALG_2, MARGREL1,
      FUNCT_6, FINSEQ_1, FUNCT_2, COMPLEX1, PARTFUN1, FINSEQ_4, NAT_1, FUNCT_5,
      NATTRA_1, PUA2MSS1, ZFMISC_1, MSALIMIT;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, XTUPLE_0, MCART_1,
      RELAT_1, FUNCT_1, STRUCT_0, RELAT_2, FUNCT_2, FINSEQ_1, FINSEQ_2,
      ORDERS_2, FUNCOP_1, RELSET_1, PARTFUN1, CARD_3, BINOP_1, FUNCT_5,
      FUNCT_6, PBOOLE, PRALG_1, MSUALG_1, MSUALG_2, MSUALG_3, PRALG_2,
      PUA2MSS1, ORDERS_3;
 constructors PRALG_1, PRALG_2, MSUALG_3, PUA2MSS1, ORDERS_3, RELSET_1,
      FUNCT_5, XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, FUNCT_2, FUNCOP_1, PBOOLE,
      STRUCT_0, ORDERS_2, MSUALG_1, MSUALG_2, PRALG_2, MSUALG_3, ORDERS_3,
      PRALG_3, ORDINAL1, CARD_3, RELSET_1, FINSEQ_1, XTUPLE_0;
 requirements SUBSET, BOOLE;
 definitions TARSKI, XBOOLE_0, BINOP_1, XTUPLE_0;
 theorems ALTCAT_1, CARD_3, FUNCOP_1, FINSEQ_1, FUNCT_1, FUNCT_2, FUNCT_5,
      FUNCT_7, MCART_1, MSUALG_1, MSUALG_2, MSUALG_3, MSUHOM_1, ORDERS_2,
      ORDERS_3, PARTFUN1, PBOOLE, PRALG_1, PRALG_2, PUA2MSS1, RELAT_1, RELAT_2,
      TARSKI, ZFMISC_1, RELSET_1, XBOOLE_0, XBOOLE_1, ORDERS_1, FUNCT_6,
      FINSEQ_2, XTUPLE_0;
 schemes FRAENKEL, PBOOLE, TARSKI, XBOOLE_0;

begin
registration
let C1 being non  empty set;
let R5 being non  void non  empty ManySortedSign;
let C2 being (MSAlgebra-Family of C1 , R5);
let C3 being (Element of C1);
let C4 being (OperSymbol of R5);
cluster ( ( ( OPER C2 ) . C3 ) . C4 ) ->  Function-like  Relation-like;
coherence
proof
L1: (ex B1 being MSAlgebra over R5 st (B1 = ( C2 . C3 ) & ( ( OPER C2 ) . C3 ) = (the Charact of B1))) by PRALG_2:def 11;
thus L2: thesis by L1;
end;
end;
registration
let C5 being non  empty set;
let R5 being non  void non  empty ManySortedSign;
let C6 being (MSAlgebra-Family of C5 , R5);
let C7 being (SortSymbol of R5);
cluster ( ( SORTS C6 ) . C7 ) ->  functional;
coherence
proof
L4: ( ( SORTS C6 ) . C7 ) = ( product ( Carrier (C6 , C7) ) ) by PRALG_2:def 10;
thus L5: thesis by L4;
end;
end;
definition
let R1 being non  empty Poset;
let R5 being non  void non  empty ManySortedSign;
mode OrderedAlgFam of R1 , R5
 -> (MSAlgebra-Family of (the carrier of R1) , R5)
means :L7: (ex B2 being (ManySortedFunction of (the InternalRel of R1)) st (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ((R2 >= R3 & R3 >= R4) implies (ex B3 being (ManySortedFunction of ( it . R2 ) , ( it . R3 )) st (ex B4 being (ManySortedFunction of ( it . R3 ) , ( it . R4 )) st (B3 = ( B2 . (R3 , R2) ) & B4 = ( B2 . (R4 , R3) ) & ( B2 . (R4 , R2) ) = ( B4 ** B3 ) & B3 is_homomorphism ( it . R2 ) , ( it . R3 )))))))));
existence
proof
reconsider D1 = (the InternalRel of R1) as (Relation of (the carrier of R1));
set D2 = the  non-empty MSAlgebra over R5;
reconsider D3 = ( (the carrier of R1) --> D2 ) as (ManySortedSet of (the carrier of R1));
L8: (for B5 being set holds (B5 in (the carrier of R1) implies ( D3 . B5 ) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over R5)) by FUNCOP_1:7;
reconsider D4 = D3 as (MSAlgebra-Family of (the carrier of R1) , R5) by L8 , PRALG_2:def 5;
take D4;
set D5 = ( (the InternalRel of R1) --> ( id (the Sorts of D2) ) );
reconsider D6 = D5 as (ManySortedFunction of (the InternalRel of R1));
take D6;
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
L9: ( D4 . R3 ) = D2 by FUNCOP_1:7;
L10: ( D4 . R4 ) = D2 by FUNCOP_1:7;
consider C8 being (ManySortedFunction of ( D4 . R3 ) , ( D4 . R4 )) such that L11: C8 = ( id (the Sorts of D2) ) by L10 , L9;
assume L12: (R2 >= R3 & R3 >= R4);
L13: ([ R3 , R2 ] in (the InternalRel of R1) & [ R4 , R3 ] in (the InternalRel of R1)) by L12 , ORDERS_2:def 5;
L14: ( field D1 ) = (the carrier of R1) by ORDERS_1:12;
L15: D1 is_transitive_in (the carrier of R1) by L14 , RELAT_2:def 16;
L16: [ R4 , R2 ] in D1 by L15 , L13 , RELAT_2:def 8;
L17: ( D4 . R2 ) = D2 by FUNCOP_1:7;
consider C9 being (ManySortedFunction of ( D4 . R2 ) , ( D4 . R3 )) such that L18: C9 = ( id (the Sorts of D2) ) by L17 , L9;
take C9;
take C8;
L19: ( C8 ** C9 ) = ( id (the Sorts of D2) ) by L18 , L11 , MSUALG_3:3;
thus L20: thesis by L19 , L13 , L17 , L9 , L18 , L11 , L16 , FUNCOP_1:7 , MSUALG_3:9;
end;
end;
definition
let R1 being non  empty Poset;
let R5 being non  void non  empty ManySortedSign;
let R6 being (OrderedAlgFam of R1 , R5);
mode Binding of R6
 -> (ManySortedFunction of (the InternalRel of R1))
means :L22: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ((R2 >= R3 & R3 >= R4) implies (ex B6 being (ManySortedFunction of ( R6 . R2 ) , ( R6 . R3 )) st (ex B7 being (ManySortedFunction of ( R6 . R3 ) , ( R6 . R4 )) st (B6 = ( it . (R3 , R2) ) & B7 = ( it . (R4 , R3) ) & ( it . (R4 , R2) ) = ( B7 ** B6 ) & B6 is_homomorphism ( R6 . R2 ) , ( R6 . R3 ))))))));
existence by L7;
end;
definition
let R1 being non  empty Poset;
let R5 being non  void non  empty ManySortedSign;
let R6 being (OrderedAlgFam of R1 , R5);
let C10 being (Binding of R6);
let R2 being (Element of R1);
let R3 being (Element of R1);
assume L24: R2 >= R3;
func bind (C10 , R2 , R3) -> (ManySortedFunction of ( R6 . R2 ) , ( R6 . R3 )) equals 
:L25: ( C10 . (R3 , R2) );
coherence
proof
L26: R3 >= R3 by ORDERS_2:1;
L27: (ex B8 being (ManySortedFunction of ( R6 . R2 ) , ( R6 . R3 )) st (ex B9 being (ManySortedFunction of ( R6 . R3 ) , ( R6 . R3 )) st (B8 = ( C10 . (R3 , R2) ) & B9 = ( C10 . (R3 , R3) ) & ( C10 . (R3 , R2) ) = ( B9 ** B8 ) & B8 is_homomorphism ( R6 . R2 ) , ( R6 . R3 )))) by L26 , L24 , L22;
thus L28: thesis by L27;
end;
end;
theorem
L30: (for R1 being non  empty Poset holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds (for R5 being non  void non  empty ManySortedSign holds (for R6 being (OrderedAlgFam of R1 , R5) holds (for R7 being (Binding of R6) holds ((R2 >= R3 & R3 >= R4) implies ( ( bind (R7 , R3 , R4) ) ** ( bind (R7 , R2 , R3) ) ) = ( bind (R7 , R2 , R4) )))))))))
proof
let R1 being non  empty Poset;
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
let R5 being non  void non  empty ManySortedSign;
let R6 being (OrderedAlgFam of R1 , R5);
let R7 being (Binding of R6);
assume L31: (R2 >= R3 & R3 >= R4);
L32: (ex B10 being (ManySortedFunction of ( R6 . R2 ) , ( R6 . R3 )) st (ex B11 being (ManySortedFunction of ( R6 . R3 ) , ( R6 . R4 )) st (B10 = ( R7 . (R3 , R2) ) & B11 = ( R7 . (R4 , R3) ) & ( R7 . (R4 , R2) ) = ( B11 ** B10 ) & B10 is_homomorphism ( R6 . R2 ) , ( R6 . R3 )))) by L31 , L22;
L33: (( bind (R7 , R3 , R4) ) = ( R7 . (R4 , R3) ) & ( bind (R7 , R2 , R3) ) = ( R7 . (R3 , R2) )) by L31 , L25;
thus L34: thesis by L33 , L31 , L32 , L25 , ORDERS_2:3;
end;
definition
let R1 being non  empty Poset;
let R5 being non  void non  empty ManySortedSign;
let R6 being (OrderedAlgFam of R1 , R5);
let C11 being (Binding of R6);
attr C11 is  normalized
means
:L35: (for R2 being (Element of R1) holds ( C11 . (R2 , R2) ) = ( id (the Sorts of ( R6 . R2 )) ));
end;
theorem
L37: (for R1 being non  empty Poset holds (for R5 being non  void non  empty ManySortedSign holds (for R6 being (OrderedAlgFam of R1 , R5) holds (for R7 being (Binding of R6) holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies (for B12 being (ManySortedFunction of ( R6 . R2 ) , ( R6 . R3 )) holds (B12 = ( bind (R7 , R2 , R3) ) implies B12 is_homomorphism ( R6 . R2 ) , ( R6 . R3 ))))))))))
proof
let R1 being non  empty Poset;
let R5 being non  void non  empty ManySortedSign;
let R6 being (OrderedAlgFam of R1 , R5);
let R7 being (Binding of R6);
let R2 being (Element of R1);
let R3 being (Element of R1);
assume L38: R2 >= R3;
let C12 being (ManySortedFunction of ( R6 . R2 ) , ( R6 . R3 ));
assume L39: C12 = ( bind (R7 , R2 , R3) );
L40: R3 >= R3 by ORDERS_2:1;
L41: (ex B13 being (ManySortedFunction of ( R6 . R2 ) , ( R6 . R3 )) st (ex B14 being (ManySortedFunction of ( R6 . R3 ) , ( R6 . R3 )) st (B13 = ( R7 . (R3 , R2) ) & B14 = ( R7 . (R3 , R3) ) & ( R7 . (R3 , R2) ) = ( B14 ** B13 ) & B13 is_homomorphism ( R6 . R2 ) , ( R6 . R3 )))) by L40 , L38 , L22;
thus L42: thesis by L41 , L38 , L39 , L25;
end;
definition
let R1 being non  empty Poset;
let R5 being non  void non  empty ManySortedSign;
let R6 being (OrderedAlgFam of R1 , R5);
let R7 being (Binding of R6);
func Normalized R7 -> (Binding of R6) means 
:L43: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( it . (R3 , R2) ) = ( IFEQ (R3 , R2 , ( id (the Sorts of ( R6 . R2 )) ) , ( ( bind (R7 , R2 , R3) ) ** ( id (the Sorts of ( R6 . R2 )) ) )) ))));
existence
proof
defpred S1[ set , set ] means (ex R2 being (Element of R1) st (ex R3 being (Element of R1) st ($1 = [ R3 , R2 ] & $2 = ( IFEQ (R3 , R2 , ( id (the Sorts of ( R6 . R2 )) ) , ( ( bind (R7 , R2 , R3) ) ** ( id (the Sorts of ( R6 . R2 )) ) )) ))));
L44:
now
let C13 being set;
assume L45: C13 in (the InternalRel of R1);
reconsider D7 = ( C13 `1 ) , D8 = ( C13 `2 ) as (Element of R1) by L45 , MCART_1:10;
reconsider D9 = D8 , D10 = D7 as (Element of R1);
deffunc H1(set) = ( IFEQ (D10 , D9 , ( id (the Sorts of ( R6 . D9 )) ) , ( ( bind (R7 , D9 , D10) ) ** ( id (the Sorts of ( R6 . D9 )) ) )) );
consider C14 being (ManySortedSet of (the InternalRel of R1)) such that L46: (for B15 being set holds (B15 in (the InternalRel of R1) implies ( C14 . B15 ) = H1(B15))) from PBOOLE:sch 4;
take D11 = ( C14 . C13 );
take D12 = D9;
take D13 = D10;
thus L47: (C13 = [ D13 , D12 ] & D11 = ( IFEQ (D13 , D12 , ( id (the Sorts of ( R6 . D12 )) ) , ( ( bind (R7 , D12 , D13) ) ** ( id (the Sorts of ( R6 . D12 )) ) )) )) by L45 , L46 , MCART_1:21;
end;
L48: (for B16 being set holds (B16 in (the InternalRel of R1) implies (ex B17 being set st S1[ B16 , B17 ]))) by L44;
consider C15 being (ManySortedSet of (the InternalRel of R1)) such that L49: (for B18 being set holds (B18 in (the InternalRel of R1) implies S1[ B18 , ( C15 . B18 ) ])) from PBOOLE:sch 3(L48);
L50: (for B19 being set holds (B19 in ( dom C15 ) implies ( C15 . B19 ) is Function))
proof
let C16 being set;
assume L51: C16 in ( dom C15 );
L52: C16 in (the InternalRel of R1) by L51;
consider C17 , C18 being (Element of R1) such that L53: C16 = [ C18 , C17 ] and L54: ( C15 . C16 ) = ( IFEQ (C18 , C17 , ( id (the Sorts of ( R6 . C17 )) ) , ( ( bind (R7 , C17 , C18) ) ** ( id (the Sorts of ( R6 . C17 )) ) )) ) by L52 , L49;
per cases ;
suppose L55: C17 = C18;

thus L56: thesis by L55 , L54 , FUNCOP_1:def 8;
end;
suppose L57: C17 <> C18;

thus L58: thesis by L57 , L54 , FUNCOP_1:def 8;
end;
end;
reconsider D14 = C15 as (ManySortedFunction of (the InternalRel of R1)) by L50 , FUNCOP_1:def 6;
L60:
now
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
assume that
L61: R2 >= R3
and
L62: R3 >= R4;
consider C19 being set such that L63: C19 = [ R3 , R2 ];
L64: C19 in (the InternalRel of R1) by L61 , L63 , ORDERS_2:def 5;
consider C20 , C21 being (Element of R1) such that L65: [ C21 , C20 ] = C19 and L66: ( D14 . C19 ) = ( IFEQ (C21 , C20 , ( id (the Sorts of ( R6 . C20 )) ) , ( ( bind (R7 , C20 , C21) ) ** ( id (the Sorts of ( R6 . C20 )) ) )) ) by L64 , L49;
L67: (C20 = R2 & C21 = R3) by L63 , L65 , XTUPLE_0:1;
L68: ( D14 . (R3 , R2) ) is (ManySortedFunction of ( R6 . R2 ) , ( R6 . R3 ))
proof
per cases ;
suppose L69: R2 = R3;

thus L70: thesis by L69 , L65 , L66 , L67 , FUNCOP_1:def 8;
end;
suppose L71: R2 <> R3;

thus L72: thesis by L71 , L65 , L66 , L67 , FUNCOP_1:def 8;
end;
end;
reconsider D15 = ( D14 . (R3 , R2) ) as (ManySortedFunction of ( R6 . R2 ) , ( R6 . R3 )) by L68;
consider C22 being set such that L74: C22 = [ R4 , R3 ];
L75: C22 in (the InternalRel of R1) by L62 , L74 , ORDERS_2:def 5;
consider C23 , C24 being (Element of R1) such that L76: [ C24 , C23 ] = C22 and L77: ( D14 . C22 ) = ( IFEQ (C24 , C23 , ( id (the Sorts of ( R6 . C23 )) ) , ( ( bind (R7 , C23 , C24) ) ** ( id (the Sorts of ( R6 . C23 )) ) )) ) by L75 , L49;
L78: (C24 = R4 & C23 = R3) by L74 , L76 , XTUPLE_0:1;
L79: ( D14 . (R4 , R3) ) is (ManySortedFunction of ( R6 . R3 ) , ( R6 . R4 ))
proof
per cases ;
suppose L80: R3 = R4;

thus L81: thesis by L80 , L76 , L77 , L78 , FUNCOP_1:def 8;
end;
suppose L82: R3 <> R4;

thus L83: thesis by L82 , L76 , L77 , L78 , FUNCOP_1:def 8;
end;
end;
reconsider D16 = ( D14 . (R4 , R3) ) as (ManySortedFunction of ( R6 . R3 ) , ( R6 . R4 )) by L79;
L85: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ((R2 >= R3 & R2 <> R3) implies ( D14 . (R3 , R2) ) = ( bind (R7 , R2 , R3) ))))
proof
let R2 being (Element of R1);
let R3 being (Element of R1);
assume that
L86: R2 >= R3
and
L87: R2 <> R3;
consider C25 being set such that L88: C25 = [ R3 , R2 ];
L89: C25 in (the InternalRel of R1) by L86 , L88 , ORDERS_2:def 5;
consider C26 , C27 being (Element of R1) such that L90: [ C27 , C26 ] = C25 and L91: ( D14 . C25 ) = ( IFEQ (C27 , C26 , ( id (the Sorts of ( R6 . C26 )) ) , ( ( bind (R7 , C26 , C27) ) ** ( id (the Sorts of ( R6 . C26 )) ) )) ) by L89 , L49;
L92: (C26 = R2 & C27 = R3) by L88 , L90 , XTUPLE_0:1;
L93: ( D14 . (R3 , R2) ) = ( ( bind (R7 , R2 , R3) ) ** ( id (the Sorts of ( R6 . R2 )) ) ) by L92 , L87 , L90 , L91 , FUNCOP_1:def 8;
thus L94: thesis by L93 , MSUALG_3:3;
end;
L95: ( D14 . (R4 , R2) ) = ( D16 ** D15 )
proof
per cases ;
suppose L96: (R2 = R3 & R3 = R4);

L97: D16 = ( id (the Sorts of ( R6 . R3 )) ) by L96 , L76 , L77 , L78 , FUNCOP_1:def 8;
thus L98: thesis by L97 , L96 , MSUALG_3:3;
end;
suppose L99: (R2 = R3 & R3 <> R4);

L100: D15 = ( id (the Sorts of ( R6 . R2 )) ) by L99 , L65 , L66 , L67 , FUNCOP_1:def 8;
thus L101: thesis by L100 , L99 , MSUALG_3:3;
end;
suppose L102: (R2 <> R3 & R3 = R4);

L103: D16 = ( id (the Sorts of ( R6 . R3 )) ) by L102 , L76 , L77 , L78 , FUNCOP_1:def 8;
thus L104: thesis by L103 , L102 , MSUALG_3:4;
end;
suppose L105: (R2 <> R3 & R3 <> R4);

L106: (R2 > R3 & R3 > R4) by L105 , L61 , L62 , ORDERS_2:def 6;
L107: R2 <> R4 by L106 , ORDERS_2:5;
L108: D16 = ( ( bind (R7 , R3 , R4) ) ** ( id (the Sorts of ( R6 . R3 )) ) ) by L76 , L77 , L78 , L105 , FUNCOP_1:def 8;
L109: D16 = ( bind (R7 , R3 , R4) ) by L108 , MSUALG_3:3;
L110: D15 = ( ( bind (R7 , R2 , R3) ) ** ( id (the Sorts of ( R6 . R2 )) ) ) by L65 , L66 , L67 , L105 , FUNCOP_1:def 8;
L111: D15 = ( bind (R7 , R2 , R3) ) by L110 , MSUALG_3:3;
L112: ( D16 ** D15 ) = ( bind (R7 , R2 , R4) ) by L111 , L61 , L62 , L109 , L30;
thus L113: thesis by L112 , L61 , L62 , L85 , L107 , ORDERS_2:3;
end;
end;
L115: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 = R3 implies ( D14 . (R3 , R2) ) = ( id (the Sorts of ( R6 . R2 )) ))))
proof
let R2 being (Element of R1);
let R3 being (Element of R1);
consider C28 being set such that L116: C28 = [ R3 , R2 ];
assume L117: R2 = R3;
L118: R2 >= R3 by L117 , ORDERS_2:1;
L119: C28 in (the InternalRel of R1) by L118 , L116 , ORDERS_2:def 5;
consider C29 , C30 being (Element of R1) such that L120: [ C30 , C29 ] = C28 and L121: ( D14 . C28 ) = ( IFEQ (C30 , C29 , ( id (the Sorts of ( R6 . C29 )) ) , ( ( bind (R7 , C29 , C30) ) ** ( id (the Sorts of ( R6 . C29 )) ) )) ) by L119 , L49;
L122: (C29 = R2 & C30 = R3) by L116 , L120 , XTUPLE_0:1;
thus L123: thesis by L122 , L117 , L120 , L121 , FUNCOP_1:def 8;
end;
L124: D15 is_homomorphism ( R6 . R2 ) , ( R6 . R3 )
proof
per cases ;
suppose L125: R2 = R3;

L126: ( D14 . (R2 , R3) ) = ( id (the Sorts of ( R6 . R2 )) ) by L125 , L115;
thus L127: thesis by L126 , L125 , MSUALG_3:9;
end;
suppose L128: R2 <> R3;

L129: ( D14 . (R3 , R2) ) = ( bind (R7 , R2 , R3) ) by L128 , L61 , L85;
thus L130: thesis by L129 , L61 , L37;
end;
end;
thus L132: (ex B20 being (ManySortedFunction of ( R6 . R2 ) , ( R6 . R3 )) st (ex B21 being (ManySortedFunction of ( R6 . R3 ) , ( R6 . R4 )) st (B20 = ( D14 . (R3 , R2) ) & B21 = ( D14 . (R4 , R3) ) & ( D14 . (R4 , R2) ) = ( B21 ** B20 ) & B20 is_homomorphism ( R6 . R2 ) , ( R6 . R3 )))) by L124 , L95;
end;
reconsider D17 = D14 as (Binding of R6) by L60 , L22;
take D17;
let R2 being (Element of R1);
let R3 being (Element of R1);
consider C31 being set such that L133: C31 = [ R3 , R2 ];
assume L134: R2 >= R3;
L135: C31 in (the InternalRel of R1) by L134 , L133 , ORDERS_2:def 5;
consider C32 , C33 being (Element of R1) such that L136: [ C33 , C32 ] = C31 and L137: ( D17 . C31 ) = ( IFEQ (C33 , C32 , ( id (the Sorts of ( R6 . C32 )) ) , ( ( bind (R7 , C32 , C33) ) ** ( id (the Sorts of ( R6 . C32 )) ) )) ) by L135 , L49;
L138: (C32 = R2 & C33 = R3) by L133 , L136 , XTUPLE_0:1;
thus L139: thesis by L138 , L136 , L137;
end;
uniqueness
proof
let C34 , C35 being (Binding of R6);
assume that
L140: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( C34 . (R3 , R2) ) = ( IFEQ (R3 , R2 , ( id (the Sorts of ( R6 . R2 )) ) , ( ( bind (R7 , R2 , R3) ) ** ( id (the Sorts of ( R6 . R2 )) ) )) ))))
and
L141: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( C35 . (R3 , R2) ) = ( IFEQ (R3 , R2 , ( id (the Sorts of ( R6 . R2 )) ) , ( ( bind (R7 , R2 , R3) ) ** ( id (the Sorts of ( R6 . R2 )) ) )) ))));
L142:
now
let C36 being set;
assume L143: C36 in (the InternalRel of R1);
reconsider D18 = ( C36 `1 ) , D19 = ( C36 `2 ) as (Element of R1) by L143 , MCART_1:10;
reconsider D20 = D19 , D21 = D18 as (Element of R1);
L144: ( C35 . C36 ) = ( C35 . (D21 , D20) ) by L143 , MCART_1:21;
L145: C36 = [ ( C36 `1 ) , ( C36 `2 ) ] by L143 , MCART_1:21;
L146: D21 <= D20 by L145 , L143 , ORDERS_2:def 5;
L147: ( C34 . C36 ) = ( C34 . (D21 , D20) ) by L143 , MCART_1:21;
L148: ( C34 . C36 ) = ( IFEQ (D21 , D20 , ( id (the Sorts of ( R6 . D20 )) ) , ( ( bind (R7 , D20 , D21) ) ** ( id (the Sorts of ( R6 . D20 )) ) )) ) by L147 , L140 , L146;
thus L149: ( C34 . C36 ) = ( C35 . C36 ) by L148 , L141 , L146 , L144;
end;
thus L150: C34 = C35 by L142 , PBOOLE:3;
end;
end;
theorem
L152: (for R1 being non  empty Poset holds (for R5 being non  void non  empty ManySortedSign holds (for R6 being (OrderedAlgFam of R1 , R5) holds (for R7 being (Binding of R6) holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ((R2 >= R3 & R2 <> R3) implies ( R7 . (R3 , R2) ) = ( ( Normalized R7 ) . (R3 , R2) ))))))))
proof
let R1 being non  empty Poset;
let R5 being non  void non  empty ManySortedSign;
let R6 being (OrderedAlgFam of R1 , R5);
let R7 being (Binding of R6);
let R2 being (Element of R1);
let R3 being (Element of R1);
assume that
L153: R2 >= R3
and
L154: R2 <> R3;
L155: (( ( Normalized R7 ) . (R3 , R2) ) = ( IFEQ (R3 , R2 , ( id (the Sorts of ( R6 . R2 )) ) , ( ( bind (R7 , R2 , R3) ) ** ( id (the Sorts of ( R6 . R2 )) ) )) ) & ( IFEQ (R3 , R2 , ( id (the Sorts of ( R6 . R2 )) ) , ( ( bind (R7 , R2 , R3) ) ** ( id (the Sorts of ( R6 . R2 )) ) )) ) = ( ( bind (R7 , R2 , R3) ) ** ( id (the Sorts of ( R6 . R2 )) ) )) by L153 , L154 , L43 , FUNCOP_1:def 8;
L156: ( ( Normalized R7 ) . (R3 , R2) ) = ( bind (R7 , R2 , R3) ) by L155 , MSUALG_3:3;
thus L157: thesis by L156 , L153 , L25;
end;
registration
let R1 being non  empty Poset;
let R5 being non  void non  empty ManySortedSign;
let R6 being (OrderedAlgFam of R1 , R5);
let R7 being (Binding of R6);
cluster ( Normalized R7 ) ->  normalized;
coherence
proof
let C37 being (Element of R1);
L158: C37 >= C37 by ORDERS_2:1;
L159: ( ( Normalized R7 ) . (C37 , C37) ) = ( IFEQ (C37 , C37 , ( id (the Sorts of ( R6 . C37 )) ) , ( ( bind (R7 , C37 , C37) ) ** ( id (the Sorts of ( R6 . C37 )) ) )) ) by L158 , L43;
thus L160: thesis by L159 , FUNCOP_1:def 8;
end;
end;
registration
let R1 being non  empty Poset;
let R5 being non  void non  empty ManySortedSign;
let R6 being (OrderedAlgFam of R1 , R5);
cluster  normalized for (Binding of R6);
existence
proof
set D22 = the (Binding of R6);
take ( Normalized D22 );
thus L162: thesis;
end;
end;
theorem
L164: (for R1 being non  empty Poset holds (for R5 being non  void non  empty ManySortedSign holds (for R6 being (OrderedAlgFam of R1 , R5) holds (for B22 being  normalized (Binding of R6) holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( Normalized B22 ) . (R3 , R2) ) = ( B22 . (R3 , R2) ))))))))
proof
let R1 being non  empty Poset;
let R5 being non  void non  empty ManySortedSign;
let R6 being (OrderedAlgFam of R1 , R5);
let C38 being  normalized (Binding of R6);
let R2 being (Element of R1);
let R3 being (Element of R1);
assume L165: R2 >= R3;
per cases ;
suppose L166: R2 <> R3;

thus L167: thesis by L166 , L165 , L152;
end;
suppose L168: R2 = R3;

L169: ( ( Normalized C38 ) . (R3 , R2) ) = ( IFEQ (R3 , R2 , ( id (the Sorts of ( R6 . R2 )) ) , ( ( bind (C38 , R2 , R3) ) ** ( id (the Sorts of ( R6 . R2 )) ) )) ) by L165 , L43;
L170: ( ( Normalized C38 ) . (R3 , R2) ) = ( id (the Sorts of ( R6 . R2 )) ) by L169 , L168 , FUNCOP_1:def 8;
thus L171: thesis by L170 , L168 , L35;
end;
end;
definition
let R1 being non  empty Poset;
let R5 being non  void non  empty ManySortedSign;
let R6 being (OrderedAlgFam of R1 , R5);
let C39 being (Binding of R6);
func InvLim C39 ->  strict (MSSubAlgebra of ( product R6 )) means 
:L173: (for B23 being (SortSymbol of R5) holds (for B24 being (Element of ( ( SORTS R6 ) . B23 )) holds (B24 in ( (the Sorts of it) . B23 ) iff (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . B23 ) . ( B24 . R2 ) ) = ( B24 . R3 )))))));
existence
proof
reconsider D23 = ( product R6 ) as  non-empty MSAlgebra over R5;
deffunc H2((SortSymbol of R5)) = { B25 where B25 is (Element of ( product ( Carrier (R6 , $1) ) )) : (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . $1 ) . ( B25 . R2 ) ) = ( B25 . R3 )))) };
consider C40 being (ManySortedSet of (the carrier of R5)) such that L174: (for B26 being (SortSymbol of R5) holds ( C40 . B26 ) = H2(B26)) from PBOOLE:sch 5;
L175: (for B27 being set holds (B27 in (the carrier of R5) implies ( C40 . B27 ) c= ( ( SORTS R6 ) . B27 )))
proof
let C41 being set;
assume L176: C41 in (the carrier of R5);
reconsider D24 = C41 as (SortSymbol of R5) by L176;
defpred S2[ (Element of ( product ( Carrier (R6 , D24) ) )) ] means (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . D24 ) . ( $1 . R2 ) ) = ( $1 . R3 ))));
L177: { B28 where B28 is (Element of ( product ( Carrier (R6 , D24) ) )) : S2[ B28 ] } c= ( product ( Carrier (R6 , D24) ) ) from FRAENKEL:sch 10;
L178: ( ( SORTS R6 ) . D24 ) = ( product ( Carrier (R6 , D24) ) ) by PRALG_2:def 10;
thus L179: thesis by L178 , L174 , L177;
end;
L180: C40 c= ( SORTS R6 ) by L175 , PBOOLE:def 2;
reconsider D25 = C40 as (ManySortedSubset of ( SORTS R6 )) by L180 , PBOOLE:def 18;
reconsider D26 = D25 as (MSSubset of ( product R6 )) by PRALG_2:12;
L181: (for B29 being (OperSymbol of R5) holds D26 is_closed_on B29)
proof
let C42 being (OperSymbol of R5);
L182: ( rng ( ( Den (C42 , ( product R6 )) ) | ( ( ( D26 # ) * (the Arity of R5) ) . C42 ) ) ) c= ( ( D26 * (the ResultSort of R5) ) . C42 )
proof
reconsider D27 = D26 as (ManySortedSet of (the carrier of R5));
reconsider D28 = ( ( Den (C42 , ( product R6 )) ) | ( ( ( D26 # ) * (the Arity of R5) ) . C42 ) ) as Function;
let C43 being set;
L183: ( dom (the Arity of R5) ) = (the carrier' of R5) by FUNCT_2:def 1;
assume L184: C43 in ( rng ( ( Den (C42 , ( product R6 )) ) | ( ( ( D26 # ) * (the Arity of R5) ) . C42 ) ) );
consider C44 being set such that L185: C44 in ( dom D28 ) and L186: C43 = ( D28 . C44 ) by L184 , FUNCT_1:def 3;
L187: ( dom D28 ) = ( ( dom ( Den (C42 , ( product R6 )) ) ) /\ ( ( ( D26 # ) * (the Arity of R5) ) . C42 ) ) by RELAT_1:61;
L188: C44 in ( ( ( D26 # ) * (the Arity of R5) ) . C42 ) by L187 , L185 , XBOOLE_0:def 4;
L189: C44 in ( ( D26 # ) . ( (the Arity of R5) . C42 ) ) by L188 , L183 , FUNCT_1:13;
L190: C44 in ( ( D26 # ) . ( the_arity_of C42 ) ) by L189 , MSUALG_1:def 1;
L191: C44 in ( product ( D27 * ( the_arity_of C42 ) ) ) by L190 , FINSEQ_2:def 5;
L192: C43 in ( Result (C42 , ( product R6 )) ) by L184;
L193: (( dom (the ResultSort of R5) ) = (the carrier' of R5) & C43 in ( ( (the Sorts of ( product R6 )) * (the ResultSort of R5) ) . C42 )) by L192 , FUNCT_2:def 1 , MSUALG_1:def 5;
L194: C43 in ( (the Sorts of ( product R6 )) . ( (the ResultSort of R5) . C42 ) ) by L193 , FUNCT_1:13;
L195: C43 in ( ( SORTS R6 ) . ( (the ResultSort of R5) . C42 ) ) by L194 , PRALG_2:12;
reconsider D29 = C43 as Function by L195;
L196: C43 in ( ( SORTS R6 ) . ( the_result_sort_of C42 ) ) by L195 , MSUALG_1:def 2;
L197: C43 is (Element of ( product ( Carrier (R6 , ( the_result_sort_of C42 )) ) )) by L196 , PRALG_2:def 10;
L198: C44 in ( dom ( Den (C42 , ( product R6 )) ) ) by L185 , L187 , XBOOLE_0:def 4;
L199:
now
let C45 being (SortSymbol of R5);
L200: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . ( the_result_sort_of C42 ) ) . ( D29 . R2 ) ) = ( D29 . R3 ))))
proof
reconsider D30 = ( ( OPS R6 ) . C42 ) as Function;
L201: ( Den (C42 , ( product R6 )) ) = ( (the Charact of ( product R6 )) . C42 ) by MSUALG_1:def 6
.= ( ( OPS R6 ) . C42 ) by PRALG_2:12;
reconsider D31 = C44 as Function by L191;
let R2 being (Element of R1);
let R3 being (Element of R1);
assume L202: R2 >= R3;
reconsider D32 = ( commute D31 ) as Function;
set D33 = ( ( commute D31 ) . R2 );
L203: ( dom D31 ) = ( dom ( D27 * ( the_arity_of C42 ) ) ) by L191 , CARD_3:9;
L204: ( rng ( the_arity_of C42 ) ) c= ( dom D27 )
proof
let C46 being set;
assume L205: C46 in ( rng ( the_arity_of C42 ) );
L206: C46 in (the carrier of R5) by L205;
thus L207: thesis by L206 , PARTFUN1:def 2;
end;
L208: ( dom D31 ) = ( dom ( the_arity_of C42 ) ) by L204 , L203 , RELAT_1:27;
L209: ( dom D31 ) = ( Seg ( len ( the_arity_of C42 ) ) ) by L208 , FINSEQ_1:def 3;
L210: ( rng D31 ) c= ( Funcs ((the carrier of R1) , |. R6 .|) )
proof
let C47 being set;
assume L211: C47 in ( rng D31 );
consider C48 being set such that L212: C48 in ( dom D31 ) and L213: C47 = ( D31 . C48 ) by L211 , FUNCT_1:def 3;
L214: C48 in ( dom ( D27 * ( the_arity_of C42 ) ) ) by L191 , L212 , CARD_3:9;
L215: C48 in ( dom ( the_arity_of C42 ) ) by L214 , L204 , RELAT_1:27;
L216: ( ( the_arity_of C42 ) . C48 ) = ( ( the_arity_of C42 ) /. C48 ) by L215 , PARTFUN1:def 6;
reconsider D34 = ( ( the_arity_of C42 ) . C48 ) as (SortSymbol of R5) by L216;
L217: C47 in ( ( D27 * ( the_arity_of C42 ) ) . C48 ) by L191 , L213 , L214 , CARD_3:9;
L218: C47 in ( D27 . ( ( the_arity_of C42 ) . C48 ) ) by L217 , L214 , FUNCT_1:12;
L219: C47 in { B30 where B30 is (Element of ( product ( Carrier (R6 , D34) ) )) : (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . D34 ) . ( B30 . R2 ) ) = ( B30 . R3 )))) } by L218 , L174;
L220: (ex B31 being (Element of ( product ( Carrier (R6 , D34) ) )) st (B31 = C47 & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . D34 ) . ( B31 . R2 ) ) = ( B31 . R3 )))))) by L219;
reconsider D35 = C47 as Function by L220;
L221: ( dom D35 ) = ( dom ( Carrier (R6 , D34) ) ) by L220 , CARD_3:9
.= (the carrier of R1) by PARTFUN1:def 2;
L222: ( rng D35 ) c= |. R6 .|
proof
let C49 being set;
assume L223: C49 in ( rng D35 );
consider C50 being set such that L224: C50 in ( dom D35 ) and L225: ( D35 . C50 ) = C49 by L223 , FUNCT_1:def 3;
reconsider D36 = C50 as (Element of R1) by L221 , L224;
reconsider D37 = D36 as (Element of R1);
L226: D37 in (the carrier of R1);
L227: (ex B32 being MSAlgebra over R5 st (B32 = ( R6 . C50 ) & ( ( Carrier (R6 , D34) ) . C50 ) = ( (the Sorts of B32) . D34 ))) by L226 , PRALG_2:def 9;
L228: |. ( R6 . D37 ) .| in { |. ( R6 . B33 ) .| where B33 is (Element of R1) : (not contradiction) };
L229: |. ( R6 . D37 ) .| c= ( union { |. ( R6 . B34 ) .| where B34 is (Element of R1) : (not contradiction) } ) by L228 , ZFMISC_1:74;
L230: |. ( R6 . D37 ) .| c= |. R6 .| by L229 , PRALG_2:def 7;
L231: ( dom (the Sorts of ( R6 . D37 )) ) = (the carrier of R5) by PARTFUN1:def 2;
L232: ( (the Sorts of ( R6 . D37 )) . D34 ) in ( rng (the Sorts of ( R6 . D37 )) ) by L231 , FUNCT_1:def 3;
L233: ( dom D35 ) = ( dom ( Carrier (R6 , D34) ) ) by L220 , CARD_3:9;
L234: C49 in ( ( Carrier (R6 , D34) ) . C50 ) by L233 , L220 , L224 , L225 , CARD_3:9;
L235: C49 in ( union ( rng (the Sorts of ( R6 . D37 )) ) ) by L234 , L227 , L232 , TARSKI:def 4;
L236: C49 in |. ( R6 . D37 ) .| by L235 , PRALG_2:def 6;
thus L237: thesis by L236 , L230;
end;
thus L238: thesis by L222 , L221 , FUNCT_2:def 2;
end;
L239: D31 in ( Funcs (( Seg ( len ( the_arity_of C42 ) ) ) , ( Funcs ((the carrier of R1) , |. R6 .|) )) ) by L210 , L209 , FUNCT_2:def 2;
per cases ;
suppose L240: ( the_arity_of C42 ) <> ( {} );

L241: (for B35 being set holds (B35 in ( dom ( doms ( R6 ?. C42 ) ) ) implies ( D32 . B35 ) in ( ( doms ( R6 ?. C42 ) ) . B35 )))
proof
let C51 being set;
assume L242: C51 in ( dom ( doms ( R6 ?. C42 ) ) );
reconsider D38 = C51 as (Element of R1) by L242 , PRALG_2:11;
reconsider D39 = ( D32 . D38 ) as Function;
L243: ( dom ( the_arity_of C42 ) ) <> ( {} ) by L240;
L244: ( Seg ( len ( the_arity_of C42 ) ) ) <> ( {} ) by L243 , FINSEQ_1:def 3;
L245: D32 in ( Funcs ((the carrier of R1) , ( Funcs (( Seg ( len ( the_arity_of C42 ) ) ) , |. R6 .|) )) ) by L244 , L239 , FUNCT_6:55;
L246: (ex B36 being Function st (B36 = D32 & ( dom B36 ) = (the carrier of R1) & ( rng B36 ) c= ( Funcs (( Seg ( len ( the_arity_of C42 ) ) ) , |. R6 .|) ))) by L245 , FUNCT_2:def 2;
L247: ( D32 . D38 ) in ( product ( (the Sorts of ( R6 . D38 )) * ( the_arity_of C42 ) ) )
proof
L248: ( dom ( (the Sorts of ( R6 . D38 )) * ( the_arity_of C42 ) ) ) = ( dom ( the_arity_of C42 ) ) by PRALG_2:3
.= ( Seg ( len ( the_arity_of C42 ) ) ) by FINSEQ_1:def 3;
L249: ( dom D31 ) = ( Seg ( len ( the_arity_of C42 ) ) ) by L208 , FINSEQ_1:def 3;
L250: (for B37 being set holds (B37 in ( dom ( (the Sorts of ( R6 . D38 )) * ( the_arity_of C42 ) ) ) implies ( D39 . B37 ) in ( ( (the Sorts of ( R6 . D38 )) * ( the_arity_of C42 ) ) . B37 )))
proof
L251: ( dom ( the_arity_of C42 ) ) <> ( {} ) by L240;
L252: ( Seg ( len ( the_arity_of C42 ) ) ) <> ( {} ) by L251 , FINSEQ_1:def 3;
L253: D31 = ( commute ( commute D31 ) ) by L252 , L239 , FUNCT_6:57;
let C52 being set;
reconsider D40 = ( ( the_arity_of C42 ) /. C52 ) as (SortSymbol of R5);
L254: ( dom ( Carrier (R6 , ( ( the_arity_of C42 ) /. C52 )) ) ) = (the carrier of R1) by PARTFUN1:def 2;
assume L255: C52 in ( dom ( (the Sorts of ( R6 . D38 )) * ( the_arity_of C42 ) ) );
L256: C52 in ( dom ( the_arity_of C42 ) ) by L255 , L248 , FINSEQ_1:def 3;
L257: ( D31 . C52 ) in ( ( D27 * ( the_arity_of C42 ) ) . C52 ) by L191 , L203 , L248 , L249 , L255 , CARD_3:9;
L258: ( D31 . C52 ) in ( D27 . ( ( the_arity_of C42 ) . C52 ) ) by L257 , L256 , FUNCT_1:13;
reconsider D41 = D31 as  Function-yielding Function by L253;
reconsider D42 = ( D41 . C52 ) as Function;
L259: ( D41 . C52 ) in ( D27 . ( ( the_arity_of C42 ) /. C52 ) ) by L256 , L258 , PARTFUN1:def 6;
L260: D42 in { B38 where B38 is (Element of ( product ( Carrier (R6 , D40) ) )) : (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . D40 ) . ( B38 . R2 ) ) = ( B38 . R3 )))) } by L259 , L174;
L261: (ex B39 being (Element of ( product ( Carrier (R6 , D40) ) )) st (B39 = D42 & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . D40 ) . ( B39 . R2 ) ) = ( B39 . R3 )))))) by L260;
L262: ( D42 . D38 ) in ( ( Carrier (R6 , ( ( the_arity_of C42 ) /. C52 )) ) . D38 ) by L261 , L254 , CARD_3:9;
L263: (ex B40 being MSAlgebra over R5 st (B40 = ( R6 . D38 ) & ( ( Carrier (R6 , ( ( the_arity_of C42 ) /. C52 )) ) . D38 ) = ( (the Sorts of B40) . ( ( the_arity_of C42 ) /. C52 ) ))) by PRALG_2:def 9;
L264: ( ( Carrier (R6 , ( ( the_arity_of C42 ) /. C52 )) ) . D38 ) = ( (the Sorts of ( R6 . D38 )) . ( ( the_arity_of C42 ) . C52 ) ) by L263 , L256 , PARTFUN1:def 6
.= ( ( (the Sorts of ( R6 . D38 )) * ( the_arity_of C42 ) ) . C52 ) by L256 , FUNCT_1:13;
thus L265: thesis by L264 , L239 , L248 , L255 , L262 , FUNCT_6:56;
end;
L266: ( D32 . D38 ) in ( rng D32 ) by L246 , FUNCT_1:def 3;
L267: (ex B41 being Function st (B41 = ( D32 . D38 ) & ( dom B41 ) = ( Seg ( len ( the_arity_of C42 ) ) ) & ( rng B41 ) c= |. R6 .|)) by L266 , L246 , FUNCT_2:def 2;
thus L268: thesis by L267 , L248 , L250 , CARD_3:9;
end;
L269: ( ( doms ( R6 ?. C42 ) ) . D38 ) = ( Args (C42 , ( R6 . D38 )) ) by PRALG_2:11;
thus L270: thesis by L269 , L247 , PRALG_2:3;
end;
L271: D32 in ( product ( doms ( R6 ?. C42 ) ) )
proof
L272: ( dom ( the_arity_of C42 ) ) <> ( {} ) by L240;
L273: ( Seg ( len ( the_arity_of C42 ) ) ) <> ( {} ) by L272 , FINSEQ_1:def 3;
L274: D32 in ( Funcs ((the carrier of R1) , ( Funcs (( Seg ( len ( the_arity_of C42 ) ) ) , |. R6 .|) )) ) by L273 , L239 , FUNCT_6:55;
L275: (ex B42 being Function st (B42 = D32 & ( dom B42 ) = (the carrier of R1) & ( rng B42 ) c= ( Funcs (( Seg ( len ( the_arity_of C42 ) ) ) , |. R6 .|) ))) by L274 , FUNCT_2:def 2;
L276: ( dom D32 ) = ( dom ( doms ( R6 ?. C42 ) ) ) by L275 , PRALG_2:11;
thus L277: thesis by L276 , L241 , CARD_3:9;
end;
L278: D30 = ( IFEQ (( the_arity_of C42 ) , ( {} ) , ( commute ( R6 ?. C42 ) ) , ( Commute ( Frege ( R6 ?. C42 ) ) )) ) by PRALG_2:def 13;
L279: D31 in ( dom ( Commute ( Frege ( R6 ?. C42 ) ) ) ) by L278 , L198 , L201 , L240 , FUNCOP_1:def 8;
reconsider D43 = D33 as Function;
L280: ( dom ( R6 ?. C42 ) ) = (the carrier of R1) by PARTFUN1:def 2;
L281: D29 = ( D30 . D31 ) by L185 , L186 , L201 , FUNCT_1:47
.= ( ( Commute ( Frege ( R6 ?. C42 ) ) ) . D31 ) by L240 , L278 , FUNCOP_1:def 8
.= ( ( Frege ( R6 ?. C42 ) ) . ( commute D31 ) ) by L279 , PRALG_2:def 1
.= ( ( R6 ?. C42 ) .. ( commute D31 ) ) by L271 , PRALG_2:def 2;
L282: ( D29 . R2 ) = ( ( ( R6 ?. C42 ) . R2 ) . ( ( commute D31 ) . R2 ) ) by L281 , L280 , PRALG_1:def 17
.= ( ( Den (C42 , ( R6 . R2 )) ) . D43 ) by PRALG_2:7;
L283: ( dom ( the_arity_of C42 ) ) <> ( {} ) by L240;
L284: ( Seg ( len ( the_arity_of C42 ) ) ) <> ( {} ) by L283 , FINSEQ_1:def 3;
L285: D32 in ( Funcs ((the carrier of R1) , ( Funcs (( Seg ( len ( the_arity_of C42 ) ) ) , |. R6 .|) )) ) by L284 , L239 , FUNCT_6:55;
L286: (ex B43 being Function st (B43 = D32 & ( dom B43 ) = (the carrier of R1) & ( rng B43 ) c= ( Funcs (( Seg ( len ( the_arity_of C42 ) ) ) , |. R6 .|) ))) by L285 , FUNCT_2:def 2;
L287: D43 in ( product ( (the Sorts of ( R6 . R2 )) * ( the_arity_of C42 ) ) )
proof
L288: ( dom ( (the Sorts of ( R6 . R2 )) * ( the_arity_of C42 ) ) ) = ( dom ( the_arity_of C42 ) ) by PRALG_2:3
.= ( Seg ( len ( the_arity_of C42 ) ) ) by FINSEQ_1:def 3;
L289: (for B44 being set holds (B44 in ( dom ( (the Sorts of ( R6 . R2 )) * ( the_arity_of C42 ) ) ) implies ( D43 . B44 ) in ( ( (the Sorts of ( R6 . R2 )) * ( the_arity_of C42 ) ) . B44 )))
proof
L290: ( dom ( the_arity_of C42 ) ) <> ( {} ) by L240;
L291: ( Seg ( len ( the_arity_of C42 ) ) ) <> ( {} ) by L290 , FINSEQ_1:def 3;
L292: D31 = ( commute ( commute D31 ) ) by L291 , L239 , FUNCT_6:57;
let C53 being set;
reconsider D44 = ( ( the_arity_of C42 ) /. C53 ) as (SortSymbol of R5);
L293: ( dom ( Carrier (R6 , ( ( the_arity_of C42 ) /. C53 )) ) ) = (the carrier of R1) by PARTFUN1:def 2;
assume L294: C53 in ( dom ( (the Sorts of ( R6 . R2 )) * ( the_arity_of C42 ) ) );
L295: C53 in ( dom ( the_arity_of C42 ) ) by L294 , L288 , FINSEQ_1:def 3;
L296: C53 in ( dom D31 ) by L208 , L288 , L294 , FINSEQ_1:def 3;
L297: ( D31 . C53 ) in ( ( D27 * ( the_arity_of C42 ) ) . C53 ) by L296 , L191 , L203 , CARD_3:9;
L298: ( D31 . C53 ) in ( D27 . ( ( the_arity_of C42 ) . C53 ) ) by L297 , L295 , FUNCT_1:13;
reconsider D45 = D31 as  Function-yielding Function by L292;
reconsider D46 = ( D45 . C53 ) as Function;
L299: ( D45 . C53 ) in ( D27 . ( ( the_arity_of C42 ) /. C53 ) ) by L295 , L298 , PARTFUN1:def 6;
L300: D46 in { B45 where B45 is (Element of ( product ( Carrier (R6 , D44) ) )) : (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . D44 ) . ( B45 . R2 ) ) = ( B45 . R3 )))) } by L299 , L174;
L301: (ex B46 being (Element of ( product ( Carrier (R6 , D44) ) )) st (B46 = D46 & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . D44 ) . ( B46 . R2 ) ) = ( B46 . R3 )))))) by L300;
L302: ( D46 . R2 ) in ( ( Carrier (R6 , ( ( the_arity_of C42 ) /. C53 )) ) . R2 ) by L301 , L293 , CARD_3:9;
L303: (ex B47 being MSAlgebra over R5 st (B47 = ( R6 . R2 ) & ( ( Carrier (R6 , ( ( the_arity_of C42 ) /. C53 )) ) . R2 ) = ( (the Sorts of B47) . ( ( the_arity_of C42 ) /. C53 ) ))) by PRALG_2:def 9;
L304: ( ( Carrier (R6 , ( ( the_arity_of C42 ) /. C53 )) ) . R2 ) = ( (the Sorts of ( R6 . R2 )) . ( ( the_arity_of C42 ) . C53 ) ) by L303 , L295 , PARTFUN1:def 6
.= ( ( (the Sorts of ( R6 . R2 )) * ( the_arity_of C42 ) ) . C53 ) by L295 , FUNCT_1:13;
thus L305: thesis by L304 , L239 , L288 , L294 , L302 , FUNCT_6:56;
end;
L306: ( D32 . R2 ) in ( rng D32 ) by L286 , FUNCT_1:def 3;
L307: (ex B48 being Function st (B48 = ( D32 . R2 ) & ( dom B48 ) = ( Seg ( len ( the_arity_of C42 ) ) ) & ( rng B48 ) c= |. R6 .|)) by L306 , L286 , FUNCT_2:def 2;
thus L308: thesis by L307 , L288 , L289 , CARD_3:9;
end;
reconsider D47 = D43 as (Element of ( Args (C42 , ( R6 . R2 )) )) by L287 , PRALG_2:3;
L309: ( bind (C39 , R2 , R3) ) is_homomorphism ( R6 . R2 ) , ( R6 . R3 ) by L202 , L37;
L310: ( ( bind (C39 , R2 , R3) ) # D47 ) = ( ( commute D31 ) . R3 )
proof
L311: ( dom ( ( bind (C39 , R2 , R3) ) # D47 ) ) = ( dom ( the_arity_of C42 ) ) by MSUALG_3:6
.= ( Seg ( len ( the_arity_of C42 ) ) ) by FINSEQ_1:def 3;
reconsider D48 = ( ( bind (C39 , R2 , R3) ) # D47 ) as FinSequence by L311 , FINSEQ_1:def 2;
L312: ( dom ( the_arity_of C42 ) ) <> ( {} ) by L240;
L313: ( Seg ( len ( the_arity_of C42 ) ) ) <> ( {} ) by L312 , FINSEQ_1:def 3;
L314: D31 = ( commute ( commute D31 ) ) by L313 , L239 , FUNCT_6:57;
reconsider D49 = D31 as  Function-yielding Function by L314;
reconsider D50 = ( ( commute D49 ) . R3 ) as Function;
L315: D32 in ( Funcs ((the carrier of R1) , ( Funcs (( Seg ( len ( the_arity_of C42 ) ) ) , |. R6 .|) )) ) by L239 , L313 , FUNCT_6:55;
L316: (ex B49 being Function st (B49 = D32 & ( dom B49 ) = (the carrier of R1) & ( rng B49 ) c= ( Funcs (( Seg ( len ( the_arity_of C42 ) ) ) , |. R6 .|) ))) by L315 , FUNCT_2:def 2;
L317: ( D32 . R3 ) in ( rng D32 ) by L316 , FUNCT_1:def 3;
L318: (ex B50 being Function st (B50 = ( D32 . R3 ) & ( dom B50 ) = ( Seg ( len ( the_arity_of C42 ) ) ) & ( rng B50 ) c= |. R6 .|)) by L317 , L316 , FUNCT_2:def 2;
reconsider D51 = D50 as FinSequence by L318 , FINSEQ_1:def 2;
L319: ( D32 . R2 ) in ( rng D32 ) by L316 , FUNCT_1:def 3;
L320:
now
let C54 being Nat;
reconsider D52 = ( D49 . C54 ) as Function;
reconsider D53 = ( ( the_arity_of C42 ) /. C54 ) as (SortSymbol of R5);
L321: (ex B51 being Function st (B51 = ( D32 . R2 ) & ( dom B51 ) = ( Seg ( len ( the_arity_of C42 ) ) ) & ( rng B51 ) c= |. R6 .|)) by L316 , L319 , FUNCT_2:def 2;
assume L322: C54 in ( dom D50 );
L323: ( D49 . C54 ) in ( ( D27 * ( the_arity_of C42 ) ) . C54 ) by L322 , L191 , L203 , L209 , L318 , CARD_3:9;
L324: C54 in ( dom ( the_arity_of C42 ) ) by L318 , L322 , FINSEQ_1:def 3;
L325: ( ( the_arity_of C42 ) /. C54 ) = ( ( the_arity_of C42 ) . C54 ) by L324 , PARTFUN1:def 6;
L326: D52 in ( D27 . D53 ) by L325 , L324 , L323 , FUNCT_1:13;
L327: D52 in { B52 where B52 is (Element of ( product ( Carrier (R6 , D53) ) )) : (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . D53 ) . ( B52 . R2 ) ) = ( B52 . R3 )))) } by L326 , L174;
L328: (ex B53 being (Element of ( product ( Carrier (R6 , D53) ) )) st (B53 = D52 & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . D53 ) . ( B53 . R2 ) ) = ( B53 . R3 )))))) by L327;
L329: ( D47 . C54 ) = ( D52 . R2 ) by L239 , L318 , L322 , FUNCT_6:56;
L330: ( ( ( bind (C39 , R2 , R3) ) # D47 ) . C54 ) = ( ( ( bind (C39 , R2 , R3) ) . ( ( the_arity_of C42 ) /. C54 ) ) . ( D52 . R2 ) ) by L329 , L318 , L322 , L321 , MSUALG_3:def 6
.= ( D52 . R3 ) by L202 , L328;
thus L331: ( ( ( bind (C39 , R2 , R3) ) # D47 ) . C54 ) = ( D50 . C54 ) by L330 , L239 , L318 , L322 , FUNCT_6:56;
end;
L332: (for B54 being Nat holds (B54 in ( Seg ( len ( the_arity_of C42 ) ) ) implies ( D48 . B54 ) = ( D51 . B54 ))) by L320 , L318;
thus L333: thesis by L332 , L318 , L311 , FINSEQ_1:13;
end;
L334: ( ( Den (C42 , ( R6 . R3 )) ) . ( ( bind (C39 , R2 , R3) ) # D47 ) ) = ( ( ( R6 ?. C42 ) . R3 ) . ( ( commute D31 ) . R3 ) ) by L310 , PRALG_2:7
.= ( D29 . R3 ) by L280 , L281 , PRALG_1:def 17;
thus L335: thesis by L334 , L309 , L282 , MSUALG_3:def 7;
end;
suppose L336: ( the_arity_of C42 ) = ( {} );

reconsider D54 = ( ( commute ( R6 ?. C42 ) ) . D31 ) as Function;
L337: ( D27 * ( {} ) ) = ( {} );
L338: D54 = ( ( curry' ( uncurry ( R6 ?. C42 ) ) ) . D31 ) by FUNCT_6:def 10;
L339: ( dom ( R6 ?. C42 ) ) = (the carrier of R1) by PARTFUN1:def 2;
L340: ( Den (C42 , ( product R6 )) ) = ( (the Charact of ( product R6 )) . C42 ) by MSUALG_1:def 6
.= ( ( OPS R6 ) . C42 ) by PRALG_2:12
.= ( IFEQ (( the_arity_of C42 ) , ( {} ) , ( commute ( R6 ?. C42 ) ) , ( Commute ( Frege ( R6 ?. C42 ) ) )) ) by PRALG_2:def 13
.= ( commute ( R6 ?. C42 ) ) by L336 , FUNCOP_1:def 8;
L341: (for B55 being (Element of R1) holds ( D29 . B55 ) = ( ( Den (C42 , ( R6 . B55 )) ) . ( {} ) ))
proof
reconsider D55 = ( ( curry' ( uncurry ( R6 ?. C42 ) ) ) . D31 ) as Function by L338;
let C55 being (Element of R1);
reconsider D56 = ( ( R6 ?. C42 ) . C55 ) as Function;
L342: D29 = ( ( commute ( R6 ?. C42 ) ) . D31 ) by L185 , L186 , L340 , FUNCT_1:47;
L343: D56 = ( Den (C42 , ( R6 . C55 )) ) by PRALG_2:7;
L344: ( dom D56 ) = ( Args (C42 , ( R6 . C55 )) ) by L343 , FUNCT_2:def 1
.= { ( {} ) } by L336 , PRALG_2:4;
L345: D31 in ( dom D56 ) by L344 , L191 , L336 , CARD_3:10;
L346: [ C55 , D31 ] in ( dom ( uncurry ( R6 ?. C42 ) ) ) by L345 , L339 , FUNCT_5:38;
L347: ( D54 . C55 ) = ( D55 . C55 ) by FUNCT_6:def 10
.= ( ( uncurry ( R6 ?. C42 ) ) . (C55 , D31) ) by L346 , FUNCT_5:22
.= ( D56 . D31 ) by L339 , L345 , FUNCT_5:38;
L348: ( D29 . C55 ) = ( ( Den (C42 , ( R6 . C55 )) ) . D31 ) by L347 , L342 , PRALG_2:7
.= ( ( Den (C42 , ( R6 . C55 )) ) . ( {} ) ) by L191 , L336 , L337 , CARD_3:10 , TARSKI:def 1;
thus L349: thesis by L348;
end;
L350: ( D29 . R2 ) = ( ( Den (C42 , ( R6 . R2 )) ) . ( {} ) ) by L341;
L351: ( Args (C42 , ( R6 . R2 )) ) = { ( {} ) } by L336 , PRALG_2:4;
reconsider D57 = ( {} ) as (Element of ( Args (C42 , ( R6 . R2 )) )) by L351 , TARSKI:def 1;
set D58 = ( bind (C39 , R2 , R3) );
L352: ( Args (C42 , ( R6 . R3 )) ) = { ( {} ) } by L336 , PRALG_2:4;
L353: ( bind (C39 , R2 , R3) ) is_homomorphism ( R6 . R2 ) , ( R6 . R3 ) by L202 , L37;
L354: ( ( D58 . ( the_result_sort_of C42 ) ) . ( D29 . R2 ) ) = ( ( Den (C42 , ( R6 . R3 )) ) . ( D58 # D57 ) ) by L353 , L350 , MSUALG_3:def 7;
L355: ( D29 . R3 ) = ( ( Den (C42 , ( R6 . R3 )) ) . ( {} ) ) by L341;
thus L356: thesis by L355 , L354 , L352 , TARSKI:def 1;
end;
end;
L358: C43 in { B56 where B56 is (Element of ( product ( Carrier (R6 , ( the_result_sort_of C42 )) ) )) : (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . ( the_result_sort_of C42 ) ) . ( B56 . R2 ) ) = ( B56 . R3 )))) } by L200 , L197;
thus L359: C43 in ( D26 . ( the_result_sort_of C42 ) ) by L358 , L174;
end;
L360: C43 in ( D26 . ( the_result_sort_of C42 ) ) by L199;
L361: C43 in ( D26 . ( (the ResultSort of R5) . C42 ) ) by L360 , MSUALG_1:def 2;
L362: ( dom (the ResultSort of R5) ) = (the carrier' of R5) by FUNCT_2:def 1;
thus L363: thesis by L362 , L361 , FUNCT_1:13;
end;
thus L364: thesis by L182 , MSUALG_2:def 5;
end;
L365: D26 is  opers_closed by L181 , MSUALG_2:def 6;
reconsider D59 = D26 as (MSSubset of D23);
set D60 = ( D23 | D59 );
L366: D60 = MSAlgebra (# D59 , ( Opers (D23 , D59) ) #) by L365 , MSUALG_2:def 15;
L367:
now
let C56 being (SortSymbol of R5);
let C57 being (Element of ( ( SORTS R6 ) . C56 ));
L368: C57 is (Element of ( product ( Carrier (R6 , C56) ) )) by PRALG_2:def 10;
thus L369: (C57 in ( (the Sorts of D60) . C56 ) iff (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . C56 ) . ( C57 . R2 ) ) = ( C57 . R3 )))))
proof
thus L370:now
assume L371: C57 in ( (the Sorts of D60) . C56 );
L372: C57 in { B57 where B57 is (Element of ( product ( Carrier (R6 , C56) ) )) : (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . C56 ) . ( B57 . R2 ) ) = ( B57 . R3 )))) } by L371 , L174 , L366;
L373: (ex B58 being (Element of ( product ( Carrier (R6 , C56) ) )) st (B58 = C57 & (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . C56 ) . ( B58 . R2 ) ) = ( B58 . R3 )))))) by L372;
thus L374: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . C56 ) . ( C57 . R2 ) ) = ( C57 . R3 )))) by L373;
end;
assume L375: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . C56 ) . ( C57 . R2 ) ) = ( C57 . R3 ))));
L376: C57 in { B59 where B59 is (Element of ( product ( Carrier (R6 , C56) ) )) : (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . C56 ) . ( B59 . R2 ) ) = ( B59 . R3 )))) } by L375 , L368;
thus L377: thesis by L376 , L174 , L366;
end;

end;
thus L370: thesis by L367;
end;
uniqueness
proof
let C58 , C59 being  strict (MSSubAlgebra of ( product R6 ));
assume that
L371: (for B60 being (SortSymbol of R5) holds (for B61 being (Element of ( ( SORTS R6 ) . B60 )) holds (B61 in ( (the Sorts of C58) . B60 ) iff (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . B60 ) . ( B61 . R2 ) ) = ( B61 . R3 )))))))
and
L372: (for B62 being (SortSymbol of R5) holds (for B63 being (Element of ( ( SORTS R6 ) . B62 )) holds (B63 in ( (the Sorts of C59) . B62 ) iff (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . B62 ) . ( B63 . R2 ) ) = ( B63 . R3 )))))));
L373: (for B64 being set holds (B64 in (the carrier of R5) implies ( (the Sorts of C58) . B64 ) = ( (the Sorts of C59) . B64 )))
proof
let C60 being set;
assume L374: C60 in (the carrier of R5);
reconsider D61 = C60 as (SortSymbol of R5) by L374;
thus L375: ( (the Sorts of C58) . C60 ) c= ( (the Sorts of C59) . C60 )
proof
let C61 being set;
assume L376: C61 in ( (the Sorts of C58) . C60 );
L377: (the Sorts of C58) is (MSSubset of ( product R6 )) by MSUALG_2:def 9;
L378: (the Sorts of C58) c= (the Sorts of ( product R6 )) by L377 , PBOOLE:def 18;
L379: (the Sorts of C58) c= ( SORTS R6 ) by L378 , PRALG_2:12;
L380: ( (the Sorts of C58) . D61 ) c= ( ( SORTS R6 ) . D61 ) by L379 , PBOOLE:def 2;
reconsider D62 = C61 as (Element of ( ( SORTS R6 ) . D61 )) by L380 , L376;
L381: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . D61 ) . ( D62 . R2 ) ) = ( D62 . R3 )))) by L371 , L376;
thus L382: thesis by L381 , L372;
end;

let C62 being set;
assume L383: C62 in ( (the Sorts of C59) . C60 );
L384: (the Sorts of C59) is (MSSubset of ( product R6 )) by MSUALG_2:def 9;
L385: (the Sorts of C59) c= (the Sorts of ( product R6 )) by L384 , PBOOLE:def 18;
L386: (the Sorts of C59) c= ( SORTS R6 ) by L385 , PRALG_2:12;
L387: ( (the Sorts of C59) . D61 ) c= ( ( SORTS R6 ) . D61 ) by L386 , PBOOLE:def 2;
reconsider D63 = C62 as (Element of ( ( SORTS R6 ) . D61 )) by L387 , L383;
L388: (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 >= R3 implies ( ( ( bind (C39 , R2 , R3) ) . D61 ) . ( D63 . R2 ) ) = ( D63 . R3 )))) by L372 , L383;
thus L389: thesis by L388 , L371;
end;
thus L390: thesis by L373 , MSUALG_2:9 , PBOOLE:3;
end;
end;
theorem
L392: (for B65 being  discrete non  empty Poset holds (for R5 being non  void non  empty ManySortedSign holds (for B66 being (OrderedAlgFam of B65 , R5) holds (for B67 being  normalized (Binding of B66) holds ( InvLim B67 ) = ( product B66 )))))
proof
let C63 being  discrete non  empty Poset;
let R5 being non  void non  empty ManySortedSign;
let C64 being (OrderedAlgFam of C63 , R5);
let C65 being  normalized (Binding of C64);
L393: (for B68 being set holds (B68 in (the carrier of R5) implies ( (the Sorts of ( InvLim C65 )) . B68 ) = ( (the Sorts of ( product C64 )) . B68 )))
proof
let C66 being set;
assume L394: C66 in (the carrier of R5);
reconsider D64 = C66 as (SortSymbol of R5) by L394;
thus L395: ( (the Sorts of ( InvLim C65 )) . C66 ) c= ( (the Sorts of ( product C64 )) . C66 )
proof
let C67 being set;
L396: (the Sorts of ( InvLim C65 )) is (MSSubset of ( product C64 )) by MSUALG_2:def 9;
L397: (the Sorts of ( InvLim C65 )) c= (the Sorts of ( product C64 )) by L396 , PBOOLE:def 18;
L398: ( (the Sorts of ( InvLim C65 )) . D64 ) c= ( (the Sorts of ( product C64 )) . D64 ) by L397 , PBOOLE:def 2;
assume L399: C67 in ( (the Sorts of ( InvLim C65 )) . C66 );
thus L400: thesis by L399 , L398;
end;

let C68 being set;
assume L401: C68 in ( (the Sorts of ( product C64 )) . C66 );
reconsider D65 = C68 as (Element of ( ( SORTS C64 ) . D64 )) by L401 , PRALG_2:12;
L402: (for B69 , B70 being (Element of C63) holds (B69 >= B70 implies ( ( ( bind (C65 , B69 , B70) ) . D64 ) . ( D65 . B69 ) ) = ( D65 . B70 )))
proof
let C69 , C70 being (Element of C63);
assume L403: C69 >= C70;
L404: C69 = C70 by L403 , ORDERS_3:1;
L405: D65 in ( ( SORTS C64 ) . D64 );
L406: (( dom ( Carrier (C64 , D64) ) ) = (the carrier of C63) & D65 in ( product ( Carrier (C64 , D64) ) )) by L405 , PARTFUN1:def 2 , PRALG_2:def 10;
L407: ( D65 . C69 ) in ( ( Carrier (C64 , D64) ) . C69 ) by L406 , CARD_3:9;
L408: ( bind (C65 , C69 , C69) ) = ( C65 . (C69 , C69) ) by L25 , ORDERS_2:1
.= ( id (the Sorts of ( C64 . C69 )) ) by L35;
L409: ( ( bind (C65 , C69 , C69) ) . D64 ) = ( id ( (the Sorts of ( C64 . C69 )) . D64 ) ) by L408 , MSUALG_3:def 1;
L410: (ex B71 being MSAlgebra over R5 st (B71 = ( C64 . C69 ) & ( ( Carrier (C64 , D64) ) . C69 ) = ( (the Sorts of B71) . D64 ))) by PRALG_2:def 9;
thus L411: thesis by L410 , L404 , L409 , L407 , FUNCT_1:18;
end;
thus L412: thesis by L402 , L173;
end;
L413: ( product C64 ) is (MSSubAlgebra of ( product C64 )) by MSUALG_2:5;
thus L414: thesis by L413 , L393 , MSUALG_2:9 , PBOOLE:3;
end;
begin
definition
let C71 being set;
attr C71 is  MSS-membered
means
:L415: (for R8 being set holds (R8 in C71 implies R8 is  strict non  empty non  void  strict non  empty non  void  strict non  empty non  void  strict non  empty non  void ManySortedSign));
end;
registration
cluster non  empty  MSS-membered for set;
existence
proof
set D66 = the  strict non  empty non  void ManySortedSign;
set D67 = { D66 };
L417: (for B72 being set holds (B72 in D67 implies B72 is  strict non  empty non  void  strict non  empty non  void  strict non  empty non  void  strict non  empty non  void ManySortedSign)) by TARSKI:def 1;
L418: D67 is  MSS-membered by L417 , L415;
thus L419: thesis by L418;
end;
end;
definition
func TrivialMSSign ->  strict ManySortedSign means 
:L421: it is  empty  void;
existence
proof
L422: (( dom ( ( {} ) --> ( {} ) ) ) = ( {} ) & ( rng ( ( {} ) --> ( {} ) ) ) = ( {} ));
reconsider D68 = ( ( {} ) --> ( {} ) ) as (Function of ( {} ) , ( {} )) by L422 , RELSET_1:4;
L423: ( {} ) in ( ( {} ) * ) by FINSEQ_1:49;
reconsider D69 = ( ( {} ) --> ( {} ) ) as (Function of ( {} ) , ( ( {} ) * )) by L423 , FUNCOP_1:46;
take ManySortedSign (# ( {} ) , ( {} ) , D69 , D68 #);
thus L424: thesis;
end;
uniqueness
proof
let C72 , C73 being  strict ManySortedSign;
assume that
L425: C72 is  empty  void
and
L426: C73 is  empty  void;
L427: C72 = C73
proof
L428: ((the carrier of C72) = ( {} ) & (the carrier' of C72) = ( {} )) by L425;
reconsider D70 = (the ResultSort of C72) , D71 = (the ResultSort of C73) as (Function of ( {} ) , ( {} )) by L428 , L426;
L429: ((the carrier of C73) = ( {} ) & (the carrier' of C73) = ( {} )) by L426;
L430: D71 in { ( id ( {} ) ) } by ALTCAT_1:2 , FUNCT_2:9;
L431: D70 in { ( id ( {} ) ) } by ALTCAT_1:2 , FUNCT_2:9;
L432: (the ResultSort of C72) = ( id ( {} ) ) by L431
.= (the ResultSort of C73) by L430;
thus L433: thesis by L432 , L428 , L429;
end;
thus L434: thesis by L427;
end;
end;
registration
cluster ( TrivialMSSign ) ->  empty  void;
coherence by L421;
end;
registration
cluster  strict  empty  void for ManySortedSign;
existence
proof
take ( TrivialMSSign );
thus L437: thesis;
end;
end;
L439: (for B73 being  empty  void ManySortedSign holds ( id (the carrier of B73) ) , ( id (the carrier' of B73) ) form_morphism_between B73 , B73)
proof
let C74 being  empty  void ManySortedSign;
set D72 = ( id (the carrier of C74) );
L440: (( ( {} ) * (the ResultSort of C74) ) = ( (the ResultSort of C74) * ( {} ) ) & (for B74 being set holds (for B75 being Function holds ((B74 in (the carrier' of C74) & B75 = ( (the Arity of C74) . B74 )) implies ( D72 * B75 ) = ( (the Arity of C74) . ( D72 . B74 ) )))));
thus L441: thesis by L440 , PUA2MSS1:def 12 , RELAT_1:38;
end;
L442: (for B76 being non  empty  void ManySortedSign holds ( id (the carrier of B76) ) , ( id (the carrier' of B76) ) form_morphism_between B76 , B76)
proof
let C75 being non  empty  void ManySortedSign;
set D73 = ( id (the carrier of C75) );
set D74 = ( id (the carrier' of C75) );
L443: (( rng D73 ) c= (the carrier of C75) & ( rng D74 ) c= (the carrier' of C75));
L444: (( D73 * (the ResultSort of C75) ) = ( {} ) & ( (the ResultSort of C75) * D74 ) = ( {} ));
L445: (for B77 being set holds (for B78 being Function holds ((B77 in (the carrier' of C75) & B78 = ( (the Arity of C75) . B77 )) implies ( D73 * B78 ) = ( (the Arity of C75) . ( D74 . B77 ) ))));
L446: (( dom D73 ) = (the carrier of C75) & ( dom D74 ) = (the carrier' of C75));
thus L447: thesis by L446 , L443 , L444 , L445 , PUA2MSS1:def 12;
end;
theorem
L448: (for B79 being  void ManySortedSign holds ( id (the carrier of B79) ) , ( id (the carrier' of B79) ) form_morphism_between B79 , B79)
proof
let C76 being  void ManySortedSign;
per cases ;
suppose L449: C76 is  empty;

thus L450: thesis by L449 , L439;
end;
suppose L451: C76 is non  empty;

thus L452: thesis by L451 , L442;
end;
end;
definition
let R9 being non  empty set;
func MSS_set R9 means 
:L454: (for R8 being set holds (R8 in it iff (ex B80 being  strict non  empty non  void ManySortedSign st (R8 = B80 & (the carrier of B80) c= R9 & (the carrier' of B80) c= R9))));
existence
proof
defpred S3[ set , set ] means (ex B81 being  strict non  empty non  void ManySortedSign st (B81 = $2 & $1 = [ (the carrier of B81) , (the carrier' of B81) , (the Arity of B81) , (the ResultSort of B81) ]));
L455: (for B82 , B83 , B84 being set holds ((S3[ B82 , B83 ] & S3[ B82 , B84 ]) implies B83 = B84))
proof
let C77 , C78 , C79 being set;
assume L456: (S3[ C77 , C78 ] & S3[ C77 , C79 ]);
consider C80 , C81 being  strict non  empty non  void ManySortedSign such that L457: C80 = C78 and L458: C77 = [ (the carrier of C80) , (the carrier' of C80) , (the Arity of C80) , (the ResultSort of C80) ] and L459: C81 = C79 and L460: C77 = [ (the carrier of C81) , (the carrier' of C81) , (the Arity of C81) , (the ResultSort of C81) ] and L461: (C81 is  empty implies C81 is  void) by L456;
L462: (the Arity of C80) = (the Arity of C81) by L458 , L460 , XTUPLE_0:5;
L463: ((the carrier of C80) = (the carrier of C81) & (the carrier' of C80) = (the carrier' of C81)) by L458 , L460 , XTUPLE_0:5;
thus L464: thesis by L463 , L457 , L458 , L459 , L460 , L462 , XTUPLE_0:5;
end;
consider C82 being set such that L465: (for R8 being set holds (R8 in C82 iff (ex B85 being set st (B85 in [: ( bool R9 ) , ( bool R9 ) , ( PFuncs (R9 , ( R9 * )) ) , ( PFuncs (R9 , R9) ) :] & S3[ B85 , R8 ])))) from TARSKI:sch 1(L455);
take C82;
let C83 being set;
thus L466: (C83 in C82 iff (ex B86 being  strict non  empty non  void ManySortedSign st (C83 = B86 & (the carrier of B86) c= R9 & (the carrier' of B86) c= R9)))
proof
thus L467: (C83 in C82 implies (ex B87 being  strict non  empty non  void ManySortedSign st (C83 = B87 & (the carrier of B87) c= R9 & (the carrier' of B87) c= R9)))
proof
assume L468: C83 in C82;
consider C84 being set such that L469: C84 in [: ( bool R9 ) , ( bool R9 ) , ( PFuncs (R9 , ( R9 * )) ) , ( PFuncs (R9 , R9) ) :] and L470: S3[ C84 , C83 ] by L468 , L465;
consider C85 being  strict non  empty non  void ManySortedSign such that L471: C85 = C83 and L472: C84 = [ (the carrier of C85) , (the carrier' of C85) , (the Arity of C85) , (the ResultSort of C85) ] by L470;
take C85;
L473: ((the carrier of C85) in ( bool R9 ) & (the carrier' of C85) in ( bool R9 )) by L469 , L470 , L471 , MCART_1:80;
thus L474: thesis by L473 , L471;
end;

given C86 being  strict non  empty non  void ManySortedSign such that
L475: C83 = C86
and
L476: (the carrier of C86) c= R9
and
L477: (the carrier' of C86) c= R9;

L478: (( dom (the ResultSort of C86) ) = (the carrier' of C86) & ( rng (the ResultSort of C86) ) c= R9) by L476 , FUNCT_2:def 1 , XBOOLE_1:1;
L479: (the ResultSort of C86) in ( PFuncs (R9 , R9) ) by L478 , L477 , PARTFUN1:def 3;
reconsider D75 = (the carrier of C86) as (Subset of R9) by L476;
consider C87 being set such that L480: C87 = [ (the carrier of C86) , (the carrier' of C86) , (the Arity of C86) , (the ResultSort of C86) ];
L481: ( D75 * ) c= ( R9 * ) by MSUHOM_1:2;
L482: ( rng (the Arity of C86) ) c= ( R9 * ) by L481 , XBOOLE_1:1;
L483: ( dom (the Arity of C86) ) c= R9 by L477 , FUNCT_2:def 1;
L484: (the Arity of C86) in ( PFuncs (R9 , ( R9 * )) ) by L483 , L482 , PARTFUN1:def 3;
L485: C87 in [: ( bool R9 ) , ( bool R9 ) , ( PFuncs (R9 , ( R9 * )) ) , ( PFuncs (R9 , R9) ) :] by L484 , L476 , L477 , L480 , L479 , MCART_1:80;
thus L486: thesis by L485 , L465 , L475 , L480;
end;

end;
uniqueness
proof
let C88 , C89 being set;
assume that
L467: (for R8 being set holds (R8 in C88 iff (ex B88 being  strict non  empty non  void ManySortedSign st (R8 = B88 & (the carrier of B88) c= R9 & (the carrier' of B88) c= R9))))
and
L468: (for R8 being set holds (R8 in C89 iff (ex B89 being  strict non  empty non  void ManySortedSign st (R8 = B89 & (the carrier of B89) c= R9 & (the carrier' of B89) c= R9))));
thus L469: C88 c= C89
proof
let C90 being set;
assume L470: C90 in C88;
L471: (ex B90 being  strict non  empty non  void ManySortedSign st (C90 = B90 & (the carrier of B90) c= R9 & (the carrier' of B90) c= R9)) by L470 , L467;
thus L472: thesis by L471 , L468;
end;

thus L473: C89 c= C88
proof
let C91 being set;
assume L474: C91 in C89;
L475: (ex B91 being  strict non  empty non  void ManySortedSign st (C91 = B91 & (the carrier of B91) c= R9 & (the carrier' of B91) c= R9)) by L474 , L468;
thus L476: thesis by L475 , L467;
end;

end;
end;
registration
let R9 being non  empty set;
cluster ( MSS_set R9 ) -> non  empty  MSS-membered;
coherence
proof
set D76 = ( MSS_set R9 );
set D77 = the (Element of R9);
L475: (( dom ( { D77 } --> D77 ) ) = { D77 } & ( rng ( { D77 } --> D77 ) ) c= { D77 }) by FUNCOP_1:13;
reconsider D78 = ( { D77 } --> D77 ) as (Function of { D77 } , { D77 }) by L475 , FUNCT_2:2;
L476: D77 in { D77 } by TARSKI:def 1;
L477: <* D77 *> in ( { D77 } * ) by L476 , FUNCT_7:18;
reconsider D79 = ( { D77 } --> <* D77 *> ) as (Function of { D77 } , ( { D77 } * )) by L477 , FUNCOP_1:46;
L478: { D77 } c= R9 by ZFMISC_1:31;
L479: ManySortedSign (# { D77 } , { D77 } , D79 , D78 #) in D76
proof
set D80 = ManySortedSign (# { D77 } , { D77 } , D79 , D78 #);
L480: D80 is non  void non  empty;
thus L481: thesis by L480 , L478 , L454;
end;
thus L482: D76 is non  empty by L479;
thus L483: D76 is  MSS-membered
proof
let C92 being set;
assume L484: C92 in D76;
L485: (ex B92 being  strict non  empty non  void ManySortedSign st (C92 = B92 & (the carrier of B92) c= R9 & (the carrier' of B92) c= R9)) by L484 , L454;
thus L486: thesis by L485;
end;

end;
end;
definition
let C93 being non  empty  MSS-membered set;
redefine mode Element of C93
 ->  strict non  empty non  void ManySortedSign;
coherence by L415;
end;
definition
let C94 , C95 being ManySortedSign;
func MSS_morph (C94 , C95) means 
(for R8 being set holds (R8 in it iff (ex B93 , B94 being Function st (R8 = [ B93 , B94 ] & B93 , B94 form_morphism_between C94 , C95))));
existence
proof
defpred S4[ set ] means (ex B95 , B96 being Function st ($1 = [ B95 , B96 ] & B95 , B96 form_morphism_between C94 , C95));
consider C96 being set such that L486: (for R8 being set holds (R8 in C96 iff (R8 in [: ( PFuncs ((the carrier of C94) , (the carrier of C95)) ) , ( PFuncs ((the carrier' of C94) , (the carrier' of C95)) ) :] & S4[ R8 ]))) from XBOOLE_0:sch 1;
take C96;
thus L487: (for R8 being set holds (R8 in C96 iff (ex B97 , B98 being Function st (R8 = [ B97 , B98 ] & B97 , B98 form_morphism_between C94 , C95))))
proof
let R8 being set;
thus L488: (R8 in C96 implies (ex B99 , B100 being Function st (R8 = [ B99 , B100 ] & B99 , B100 form_morphism_between C94 , C95))) by L486;
given C97 , C98 being Function such that
L489: R8 = [ C97 , C98 ]
and
L490: C97 , C98 form_morphism_between C94 , C95;

L491: (( dom C98 ) = (the carrier' of C94) & ( rng C98 ) c= (the carrier' of C95)) by L490 , PUA2MSS1:def 12;
L492: C98 in ( PFuncs ((the carrier' of C94) , (the carrier' of C95)) ) by L491 , PARTFUN1:def 3;
L493: (( dom C97 ) = (the carrier of C94) & ( rng C97 ) c= (the carrier of C95)) by L490 , PUA2MSS1:def 12;
L494: C97 in ( PFuncs ((the carrier of C94) , (the carrier of C95)) ) by L493 , PARTFUN1:def 3;
L495: R8 in [: ( PFuncs ((the carrier of C94) , (the carrier of C95)) ) , ( PFuncs ((the carrier' of C94) , (the carrier' of C95)) ) :] by L494 , L489 , L492 , ZFMISC_1:87;
thus L496: thesis by L495 , L486 , L489 , L490;
end;

end;
uniqueness
proof
let C99 , C100 being set;
assume that
L488: (for R8 being set holds (R8 in C99 iff (ex B101 , B102 being Function st (R8 = [ B101 , B102 ] & B101 , B102 form_morphism_between C94 , C95))))
and
L489: (for R8 being set holds (R8 in C100 iff (ex B103 , B104 being Function st (R8 = [ B103 , B104 ] & B103 , B104 form_morphism_between C94 , C95))));
L490: C100 c= C99
proof
let R8 being set;
assume L491: R8 in C100;
L492: (ex B105 , B106 being Function st (R8 = [ B105 , B106 ] & B105 , B106 form_morphism_between C94 , C95)) by L491 , L489;
thus L493: thesis by L492 , L488;
end;
L494: C99 c= C100
proof
let R8 being set;
assume L495: R8 in C99;
L496: (ex B107 , B108 being Function st (R8 = [ B107 , B108 ] & B107 , B108 form_morphism_between C94 , C95)) by L495 , L488;
thus L497: thesis by L496 , L489;
end;
thus L498: C99 = C100 by L494 , L490 , XBOOLE_0:def 10;
end;
end;
