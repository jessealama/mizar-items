:: Joining of Decorated Trees
::  by Grzegorz Bancerek
::
:: Received October 8, 1993
:: Copyright (c) 1993-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, TREES_2, SUBSET_1, RELAT_1, FINSEQ_1, FUNCT_1, TARSKI,
      TREES_1, XXREAL_0, ARYTM_3, CARD_1, FUNCOP_1, XBOOLE_0, TREES_3,
      ZFMISC_1, NAT_1, FINSEQ_2, TREES_A, ORDINAL4, FUNCT_6, FINSEQ_4, MCART_1,
      PARTFUN1, TREES_4;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, ORDINAL1, NAT_1,
      RELAT_1, FUNCT_1, DOMAIN_1, FUNCOP_1, FUNCT_3, FINSEQ_1, FINSEQ_2,
      TREES_1, TREES_2, FUNCT_6, TREES_3, XXREAL_0;
 constructors BINOP_1, DOMAIN_1, XXREAL_0, XREAL_0, NAT_1, FUNCT_5, FINSEQ_2,
      FUNCT_6, TREES_3, RELSET_1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, XREAL_0,
      FINSEQ_1, TREES_2, TREES_3, CARD_1, FINSEQ_2, FUNCOP_1, RELSET_1,
      TREES_1;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, FINSEQ_1, TREES_1, TREES_2, FINSEQ_2, FUNCT_6;
 theorems TARSKI, ZFMISC_1, FINSEQ_1, MCART_1, NAT_1, FUNCT_1, FUNCT_2,
      FUNCOP_1, FUNCT_6, FINSEQ_2, FINSEQ_3, TREES_1, TREES_2, TREES_3,
      RELAT_1, XBOOLE_0, XBOOLE_1, XREAL_1, XXREAL_0, FUNCT_5, ORDINAL1,
      CARD_1;
 schemes CLASSES1, FINSEQ_1, XBOOLE_0;

begin
definition
let C1 being DecoratedTree;
mode Node of C1
 is (Element of ( dom C1 ));
end;
L2:
now
let R1 being set;
let R2 being set;
let C2 being (FinSequence of R1);
assume L3: (R2 in ( dom C2 ) or R2 in ( dom C2 ));
L4: ( C2 . R2 ) in ( rng C2 ) by L3 , FUNCT_1:def 3;
L5: ( rng C2 ) c= R1 by FINSEQ_1:def 4;
thus L6: ( C2 . R2 ) in R1 by L5 , L4;
end;
definition
let C3 , C4 being DecoratedTree;
redefine pred C3 = C4
means
(( dom C3 ) = ( dom C4 ) & (for B1 being (Node of C3) holds ( C3 . B1 ) = ( C4 . B1 )))
;compatibility
proof
L7: (((for B2 being (Node of C3) holds ( C3 . B2 ) = ( C4 . B2 )) & ( dom C3 ) = ( dom C4 )) implies (for R1 being set holds (R1 in ( dom C3 ) implies ( C3 . R1 ) = ( C4 . R1 ))));
thus L8: thesis by L7 , FUNCT_1:2;
end;
end;
theorem
L10: (for B3 , B4 being (Element of ( NAT )) holds (( elementary_tree B3 ) c= ( elementary_tree B4 ) implies B3 <= B4))
proof
let C5 , C6 being (Element of ( NAT ));
assume that
L11: ( elementary_tree C5 ) c= ( elementary_tree C6 )
and
L12: C5 > C6;
L13: <* C6 *> in ( elementary_tree C5 ) by L12 , TREES_1:28;
L14: (ex R6 being (Element of ( NAT )) st (R6 < C6 & <* C6 *> = <* R6 *>)) by L13 , L11 , TREES_1:30;
L15: ( <* C6 *> . 1 ) = C6 by FINSEQ_1:40;
thus L16: thesis by L15 , L14 , FINSEQ_1:40;
end;
theorem
L17: (for B5 , B6 being (Element of ( NAT )) holds (( elementary_tree B5 ) = ( elementary_tree B6 ) implies B5 = B6))
proof
let C7 , C8 being (Element of ( NAT ));
assume L18: ( elementary_tree C7 ) = ( elementary_tree C8 );
L19: (C7 <= C8 & C7 >= C8) by L18 , L10;
thus L20: thesis by L19 , XXREAL_0:1;
end;
L21: (for R6 being (Element of ( NAT )) holds (for R7 being FinSequence holds (R6 < ( len R7 ) implies (( R6 + 1 ) in ( dom R7 ) & ( R7 . ( R6 + 1 ) ) in ( rng R7 )))))
proof
let R6 being (Element of ( NAT ));
let R7 being FinSequence;
assume L22: R6 < ( len R7 );
L23: R6 >= ( 0 ) by NAT_1:2;
L24: ( R6 + 1 ) >= ( ( 0 ) + 1 ) by L23 , XREAL_1:7;
L25: ( R6 + 1 ) <= ( len R7 ) by L22 , NAT_1:13;
L26: ( R6 + 1 ) in ( dom R7 ) by L25 , L24 , FINSEQ_3:25;
thus L27: thesis by L26 , FUNCT_1:def 3;
end;
L28:
now
let R6 being (Element of ( NAT ));
let R1 being set;
let C9 being (FinSequence of R1);
assume L29: R6 < ( len C9 );
L30: ( C9 . ( R6 + 1 ) ) in ( rng C9 ) by L29 , L21;
L31: ( rng C9 ) c= R1 by FINSEQ_1:def 4;
thus L32: ( C9 . ( R6 + 1 ) ) in R1 by L31 , L30;
end;
definition
let R1 being set;
func root-tree R1 -> DecoratedTree equals 
( ( elementary_tree ( 0 ) ) --> R1 );
correctness;
end;
definition
let C10 being non  empty set;
let C11 being (Element of C10);
redefine func root-tree C11 -> (Element of ( FinTrees C10 ));

coherence
proof
L34: ( dom ( ( elementary_tree ( 0 ) ) --> C11 ) ) = ( elementary_tree ( 0 ) ) by FUNCOP_1:13;
thus L35: thesis by L34 , TREES_3:def 8;
end;
end;
theorem
L37: (for R1 being set holds (( dom ( root-tree R1 ) ) = ( elementary_tree ( 0 ) ) & ( ( root-tree R1 ) . ( {} ) ) = R1))
proof
let R1 being set;
L38: ( {} ) in ( elementary_tree ( 0 ) ) by TARSKI:def 1 , TREES_1:29;
thus L39: thesis by L38 , FUNCOP_1:7 , FUNCOP_1:13;
end;
theorem
L40: (for R1 being set holds (for R2 being set holds (( root-tree R1 ) = ( root-tree R2 ) implies R1 = R2)))
proof
let R1 being set;
let R2 being set;
L41: ( ( root-tree R1 ) . ( {} ) ) = R1 by L37;
thus L42: thesis by L41 , L37;
end;
theorem
L43: (for B7 being DecoratedTree holds (( dom B7 ) = ( elementary_tree ( 0 ) ) implies B7 = ( root-tree ( B7 . ( {} ) ) )))
proof
let C12 being DecoratedTree;
assume L44: ( dom C12 ) = ( elementary_tree ( 0 ) );
L45: (for R1 being set holds (R1 in ( dom C12 ) implies ( C12 . R1 ) = ( C12 . ( {} ) ))) by L44 , TARSKI:def 1 , TREES_1:29;
thus L46: thesis by L45 , L44 , FUNCOP_1:11;
end;
theorem
L47: (for R1 being set holds ( root-tree R1 ) = { [ ( {} ) , R1 ] })
proof
let R1 being set;
thus L48: ( root-tree R1 ) = [: { ( {} ) } , { R1 } :] by FUNCOP_1:def 2 , TREES_1:29
.= { [ ( {} ) , R1 ] } by ZFMISC_1:29;
end;
definition
let R1 being set;
let C13 being FinSequence;
func R1 -flat_tree C13 -> DecoratedTree means 
:L49: (( dom it ) = ( elementary_tree ( len C13 ) ) & ( it . ( {} ) ) = R1 & (for R6 being (Element of ( NAT )) holds (R6 < ( len C13 ) implies ( it . <* R6 *> ) = ( C13 . ( R6 + 1 ) ))));
existence
proof
defpred S1[ set , set ] means (($1 = ( {} ) & $2 = R1) or (ex R6 being (Element of ( NAT )) st ($1 = <* R6 *> & $2 = ( C13 . ( R6 + 1 ) ))));
L50: (for R3 being set holds (R3 in ( elementary_tree ( len C13 ) ) implies (ex R2 being set st S1[ R3 , R2 ])))
proof
let R3 being set;
assume L51: R3 in ( elementary_tree ( len C13 ) );
reconsider D1 = R3 as (Element of ( elementary_tree ( len C13 ) )) by L51;
reconsider D2 = D1 as (FinSequence of ( NAT ));
L52: (D2 = ( {} ) or (ex R6 being (Element of ( NAT )) st (R6 < ( len C13 ) & D2 = <* R6 *>))) by TREES_1:30;
L53:
now
given R6 being (Element of ( NAT )) such that
L54: D2 = <* R6 *>
and
L55: R6 < ( len C13 );

take D3 = ( C13 . ( R6 + 1 ) );
take D4 = R6;
thus L56: (D2 = <* D4 *> & D3 = ( C13 . ( D4 + 1 ) )) by L54;
end;
thus L57: thesis by L53 , L52;
end;
consider C14 being Function such that L58: (( dom C14 ) = ( elementary_tree ( len C13 ) ) & (for R2 being set holds (R2 in ( elementary_tree ( len C13 ) ) implies S1[ R2 , ( C14 . R2 ) ]))) from CLASSES1:sch 1(L50);
reconsider D5 = C14 as DecoratedTree by L58 , TREES_2:def 8;
take D5;
thus L59: ( dom D5 ) = ( elementary_tree ( len C13 ) ) by L58;
L60: (( {} ) in ( dom D5 ) & (for R6 being (Element of ( NAT )) holds (( {} ) = <* R6 *> implies ( D5 . ( {} ) ) <> ( C13 . ( R6 + 1 ) )))) by TREES_1:22;
thus L61: ( D5 . ( {} ) ) = R1 by L60 , L58;
let R6 being (Element of ( NAT ));
assume L62: R6 < ( len C13 );
L63: <* R6 *> in ( dom D5 ) by L62 , L58 , TREES_1:28;
consider C15 being (Element of ( NAT )) such that L64: <* R6 *> = <* C15 *> and L65: ( D5 . <* R6 *> ) = ( C13 . ( C15 + 1 ) ) by L63 , L58;
L66: C15 = ( <* R6 *> . 1 ) by L64 , FINSEQ_1:40
.= R6 by FINSEQ_1:40;
thus L67: thesis by L66 , L65;
end;
uniqueness
proof
let C16 , C17 being DecoratedTree;
assume that
L68: ( dom C16 ) = ( elementary_tree ( len C13 ) )
and
L69: ( C16 . ( {} ) ) = R1
and
L70: (for R6 being (Element of ( NAT )) holds (R6 < ( len C13 ) implies ( C16 . <* R6 *> ) = ( C13 . ( R6 + 1 ) )))
and
L71: ( dom C17 ) = ( elementary_tree ( len C13 ) )
and
L72: ( C17 . ( {} ) ) = R1
and
L73: (for R6 being (Element of ( NAT )) holds (R6 < ( len C13 ) implies ( C17 . <* R6 *> ) = ( C13 . ( R6 + 1 ) )));
L74:
now
let R1 being set;
assume L75: R1 in ( elementary_tree ( len C13 ) );
reconsider D6 = R1 as (Element of ( elementary_tree ( len C13 ) )) by L75;
L76: (D6 = ( {} ) or (ex R6 being (Element of ( NAT )) st (R6 < ( len C13 ) & D6 = <* R6 *>))) by TREES_1:30;
L77:
now
given R6 being (Element of ( NAT )) such that
L78: (R6 < ( len C13 ) & R1 = <* R6 *>);

thus L79: ( C16 . R1 ) = ( C13 . ( R6 + 1 ) ) by L70 , L78
.= ( C17 . R1 ) by L73 , L78;
end;
thus L80: ( C16 . R1 ) = ( C17 . R1 ) by L77 , L69 , L72 , L76;
end;
thus L81: thesis by L74 , L68 , L71 , FUNCT_1:2;
end;
end;
theorem
L83: (for R1 being set holds (for R2 being set holds (for R7 being FinSequence holds (for R8 being FinSequence holds (( R1 -flat_tree R7 ) = ( R2 -flat_tree R8 ) implies (R1 = R2 & R7 = R8))))))
proof
let R1 being set;
let R2 being set;
let R7 being FinSequence;
let R8 being FinSequence;
assume L84: ( R1 -flat_tree R7 ) = ( R2 -flat_tree R8 );
L85: ( ( R1 -flat_tree R7 ) . ( {} ) ) = R1 by L49;
thus L86: R1 = R2 by L85 , L84 , L49;
L87: (( dom ( R1 -flat_tree R7 ) ) = ( elementary_tree ( len R7 ) ) & ( dom ( R2 -flat_tree R8 ) ) = ( elementary_tree ( len R8 ) )) by L49;
L88: ( len R7 ) = ( len R8 ) by L87 , L84 , L17;
L89:
now
let C18 being Nat;
assume that
L90: C18 >= 1
and
L91: C18 <= ( len R7 );
consider C19 being Nat such that L92: C18 = ( 1 + C19 ) by L90 , NAT_1:10;
L93: (C19 in ( NAT ) & C19 < ( len R7 )) by L91 , L92 , NAT_1:13 , ORDINAL1:def 12;
L94: ( R7 . C18 ) = ( ( R1 -flat_tree R7 ) . <* C19 *> ) by L93 , L92 , L49;
thus L95: ( R7 . C18 ) = ( R8 . C18 ) by L94 , L84 , L88 , L92 , L93 , L49;
end;
thus L96: thesis by L89 , L84 , L87 , L17 , FINSEQ_1:14;
end;
theorem
L97: (for R4 being (Element of ( NAT )) holds (for R5 being (Element of ( NAT )) holds (R5 < R4 implies ( ( elementary_tree R4 ) | <* R5 *> ) = ( elementary_tree ( 0 ) ))))
proof
let R4 being (Element of ( NAT ));
let R5 being (Element of ( NAT ));
set D7 = ( R4 |-> ( elementary_tree ( 0 ) ) );
set D8 = ( tree D7 );
assume L98: R5 < R4;
L99: (( 1 + R5 ) >= 1 & ( R5 + 1 ) <= R4) by L98 , NAT_1:11 , NAT_1:13;
L100: ( len D7 ) = R4 by CARD_1:def 7;
L101: (( elementary_tree R4 ) = D8 & ( D8 | <* R5 *> ) = ( D7 . ( R5 + 1 ) )) by L100 , L98 , TREES_3:49 , TREES_3:54;
L102: ( R5 + 1 ) in ( Seg R4 ) by L99;
thus L103: thesis by L102 , L101 , FUNCOP_1:7;
end;
theorem
L104: (for R1 being set holds (for R4 being (Element of ( NAT )) holds (for R7 being FinSequence holds (R4 < ( len R7 ) implies ( ( R1 -flat_tree R7 ) | <* R4 *> ) = ( root-tree ( R7 . ( R4 + 1 ) ) )))))
proof
let R1 being set;
let R4 being (Element of ( NAT ));
let R7 being FinSequence;
reconsider D9 = ( {} ) as (Element of ( ( dom ( R1 -flat_tree R7 ) ) | <* R4 *> )) by TREES_1:22;
assume L105: R4 < ( len R7 );
L106: ( ( R1 -flat_tree R7 ) . <* R4 *> ) = ( R7 . ( R4 + 1 ) ) by L105 , L49;
L107: ( dom ( R1 -flat_tree R7 ) ) = ( elementary_tree ( len R7 ) ) by L49;
L108: ( ( elementary_tree ( len R7 ) ) | <* R4 *> ) = ( elementary_tree ( 0 ) ) by L105 , L97;
L109: ( dom ( ( R1 -flat_tree R7 ) | <* R4 *> ) ) = ( elementary_tree ( 0 ) ) by L108 , L107 , TREES_2:def 10;
L110: (( <* R4 *> ^ D9 ) = <* R4 *> & ( ( ( R1 -flat_tree R7 ) | <* R4 *> ) . D9 ) = ( ( R1 -flat_tree R7 ) . ( <* R4 *> ^ D9 ) )) by FINSEQ_1:34 , TREES_2:def 10;
thus L111: thesis by L110 , L106 , L109 , L43;
end;
definition
let R1 being set;
let R7 being FinSequence;
assume that
L112: R7 is  DTree-yielding;
func R1 -tree R7 -> DecoratedTree means 
:L113: ((ex B8 being  DTree-yielding FinSequence st (R7 = B8 & ( dom it ) = ( tree ( doms B8 ) ))) & ( it . ( {} ) ) = R1 & (for R6 being (Element of ( NAT )) holds (R6 < ( len R7 ) implies ( it | <* R6 *> ) = ( R7 . ( R6 + 1 ) ))));
existence
proof
L114: ( dom ( doms R7 ) ) = ( dom R7 ) by L112 , TREES_3:37;
reconsider D10 = ( doms R7 ) as  Tree-yielding FinSequence by L112;
defpred S2[ set , set ] means (($1 = ( {} ) & $2 = R1) or ($1 <> ( {} ) & (ex R6 being (Element of ( NAT )) st (ex R9 being FinSequence st ($1 = ( <* R6 *> ^ R9 ) & $2 = ( R7 .. (( R6 + 1 ) , R9) ))))));
L115: (for R2 being set holds (R2 in ( tree D10 ) implies (ex R3 being set st S2[ R2 , R3 ])))
proof
let R2 being set;
assume L116: R2 in ( tree D10 );
reconsider D11 = R2 as (Element of ( tree D10 )) by L116;
L117:
now
assume L118: R2 <> ( {} );
consider C20 being (FinSequence of ( NAT )), C21 being (Element of ( NAT )) such that L119: D11 = ( <* C21 *> ^ C20 ) by L118 , FINSEQ_2:130;
reconsider D12 = C20 as FinSequence;
take D13 = ( R7 .. (( C21 + 1 ) , D12) );
thus L120: ((R2 = ( {} ) & D13 = R1) or (R2 <> ( {} ) & (ex R6 being (Element of ( NAT )) st (ex R9 being FinSequence st (R2 = ( <* R6 *> ^ R9 ) & D13 = ( R7 .. (( R6 + 1 ) , R9) )))))) by L119;
end;
thus L121: thesis by L117;
end;
consider C22 being Function such that L122: (( dom C22 ) = ( tree D10 ) & (for R2 being set holds (R2 in ( tree D10 ) implies S2[ R2 , ( C22 . R2 ) ]))) from CLASSES1:sch 1(L115);
reconsider D14 = C22 as DecoratedTree by L122 , TREES_2:def 8;
take D14;
thus L123: (ex B9 being  DTree-yielding FinSequence st (R7 = B9 & ( dom D14 ) = ( tree ( doms B9 ) ))) by L112 , L122;
L124: ( {} ) in ( tree D10 ) by TREES_1:22;
thus L125: ( D14 . ( {} ) ) = R1 by L124 , L122;
L126: ( len R7 ) = ( len D10 ) by L114 , FINSEQ_3:29;
let R6 being (Element of ( NAT ));
assume L127: R6 < ( len R7 );
L128: ( R6 + 1 ) in ( dom R7 ) by L127 , L21;
reconsider D15 = ( R7 . ( R6 + 1 ) ) as DecoratedTree by L128 , L112 , TREES_3:24;
L129: ( dom D15 ) = ( D10 . ( R6 + 1 ) ) by L128 , FUNCT_6:22;
L130: ( dom D15 ) = ( D10 . ( R6 + 1 ) ) by L128 , FUNCT_6:22
.= ( ( dom D14 ) | <* R6 *> ) by L122 , L126 , L127 , TREES_3:49;
L131: ( ( dom D14 ) | <* R6 *> ) = ( dom ( D14 | <* R6 *> ) ) by TREES_2:def 10;
L132:
now
let C23 being (FinSequence of ( NAT ));
assume L133: C23 in ( dom D15 );
L134: ( <* R6 *> ^ C23 ) in ( dom D14 ) by L133 , L122 , L126 , L127 , L129 , TREES_3:def 15;
consider C24 being (Element of ( NAT )), C25 being FinSequence such that L135: ( <* R6 *> ^ C23 ) = ( <* C24 *> ^ C25 ) and L136: ( D14 . ( <* R6 *> ^ C23 ) ) = ( R7 .. (( C24 + 1 ) , C25) ) by L134 , L122;
L137: (( ( <* R6 *> ^ C23 ) . 1 ) = R6 & ( ( <* C24 *> ^ C25 ) . 1 ) = C24) by FINSEQ_1:41;
L138: (( C24 + 1 ) in ( dom R7 ) & C23 = C25) by L137 , L127 , L135 , L21 , FINSEQ_1:33;
L139: ( R7 .. (( C24 + 1 ) , C25) ) = ( D15 . C23 ) by L138 , L133 , L135 , L137 , FUNCT_5:38;
thus L140: ( ( D14 | <* R6 *> ) . C23 ) = ( D15 . C23 ) by L139 , L130 , L133 , L136 , TREES_2:def 10;
end;
thus L141: thesis by L132 , L130 , L131 , TREES_2:31;
end;
uniqueness
proof
let C26 , C27 being DecoratedTree;
given C28 being  DTree-yielding FinSequence such that
L142: R7 = C28
and
L143: ( dom C26 ) = ( tree ( doms C28 ) );

assume that
L144: ( C26 . ( {} ) ) = R1
and
L145: (for R6 being (Element of ( NAT )) holds (R6 < ( len R7 ) implies ( C26 | <* R6 *> ) = ( R7 . ( R6 + 1 ) )));
given C29 being  DTree-yielding FinSequence such that
L146: (R7 = C29 & ( dom C27 ) = ( tree ( doms C29 ) ));

assume that
L147: ( C27 . ( {} ) ) = R1
and
L148: (for R6 being (Element of ( NAT )) holds (R6 < ( len R7 ) implies ( C27 | <* R6 *> ) = ( R7 . ( R6 + 1 ) )));
L149:
now
let C30 being (FinSequence of ( NAT ));
assume L150: C30 in ( dom C26 );
L151:
now
assume L152: C30 <> ( {} );
consider C31 being (FinSequence of ( NAT )), C32 being (Element of ( NAT )) such that L153: C30 = ( <* C32 *> ^ C31 ) by L152 , FINSEQ_2:130;
L154: <* C32 *> in ( dom C26 ) by L150 , L153 , TREES_1:21;
L155: C32 < ( len ( doms C28 ) ) by L143 , L150 , L153 , TREES_3:48;
L156: ( len ( doms C28 ) ) = ( len R7 ) by L142 , TREES_3:38;
L157: (( C26 | <* C32 *> ) = ( R7 . ( C32 + 1 ) ) & ( C27 | <* C32 *> ) = ( R7 . ( C32 + 1 ) )) by L156 , L145 , L148 , L155;
L158: C31 in ( ( dom C26 ) | <* C32 *> ) by L150 , L153 , L154 , TREES_1:def 6;
L159: ( C26 . C30 ) = ( ( C26 | <* C32 *> ) . C31 ) by L158 , L153 , TREES_2:def 10;
thus L160: ( C26 . C30 ) = ( C27 . C30 ) by L159 , L142 , L143 , L146 , L153 , L157 , L158 , TREES_2:def 10;
end;
thus L161: ( C26 . C30 ) = ( C27 . C30 ) by L151 , L144 , L147;
end;
thus L162: thesis by L149 , L142 , L143 , L146 , TREES_2:31;
end;
end;
definition
let R1 being set;
let C33 being DecoratedTree;
func R1 -tree C33 -> DecoratedTree equals 
( R1 -tree <* C33 *> );
correctness;
end;
definition
let R1 being set;
let C34 , C35 being DecoratedTree;
func R1 -tree (C34 , C35) -> DecoratedTree equals 
( R1 -tree <* C34 , C35 *> );
correctness;
end;
theorem
L166: (for R1 being set holds (for B10 being  DTree-yielding FinSequence holds ( dom ( R1 -tree B10 ) ) = ( tree ( doms B10 ) )))
proof
let R1 being set;
let C36 being  DTree-yielding FinSequence;
L167: (ex B11 being  DTree-yielding FinSequence st (C36 = B11 & ( dom ( R1 -tree C36 ) ) = ( tree ( doms B11 ) ))) by L113;
thus L168: thesis by L167;
end;
theorem
L169: (for R1 being set holds (for R2 being set holds (for B12 being  DTree-yielding FinSequence holds (R2 in ( dom ( R1 -tree B12 ) ) iff (R2 = ( {} ) or (ex B13 being (Element of ( NAT )) st (ex B14 being DecoratedTree st (ex B15 being (Node of B14) st (B13 < ( len B12 ) & B14 = ( B12 . ( B13 + 1 ) ) & R2 = ( <* B13 *> ^ B15 ))))))))))
proof
let R1 being set;
let R2 being set;
let C37 being  DTree-yielding FinSequence;
L170: ( dom ( R1 -tree C37 ) ) = ( tree ( doms C37 ) ) by L166;
L171:
now
given R4 being (Element of ( NAT )) , R8 being FinSequence such that
L172: R4 < ( len ( doms C37 ) )
and
L173: R8 in ( ( doms C37 ) . ( R4 + 1 ) )
and
L174: R2 = ( <* R4 *> ^ R8 );

L175: ( len ( doms C37 ) ) = ( len C37 ) by TREES_3:38;
L176: ( R4 + 1 ) in ( dom C37 ) by L175 , L172 , L21;
reconsider D16 = ( C37 . ( R4 + 1 ) ) as DecoratedTree by L176 , TREES_3:24;
take D17 = R4;
take D18 = D16;
reconsider D19 = R8 as (Node of D18) by L173 , L176 , FUNCT_6:22;
take D20 = D19;
thus L177: (D17 < ( len C37 ) & D18 = ( C37 . ( D17 + 1 ) ) & R2 = ( <* D17 *> ^ D20 )) by L172 , L174 , TREES_3:38;
end;
L178:
now
given C38 being (Element of ( NAT )) , C39 being DecoratedTree , C40 being (Node of C39) such that
L179: C38 < ( len C37 )
and
L180: C39 = ( C37 . ( C38 + 1 ) )
and
L181: R2 = ( <* C38 *> ^ C40 );

reconsider D21 = C40 as FinSequence;
take D22 = C38;
take D23 = D21;
L182: ( D22 + 1 ) in ( dom C37 ) by L179 , L21;
L183: ( ( doms C37 ) . ( D22 + 1 ) ) = ( dom C39 ) by L182 , L180 , FUNCT_6:22;
thus L184: (D22 < ( len ( doms C37 ) ) & D23 in ( ( doms C37 ) . ( D22 + 1 ) ) & R2 = ( <* D22 *> ^ D23 )) by L183 , L179 , L181 , TREES_3:38;
end;
thus L185: thesis by L178 , L170 , L171 , TREES_3:def 15;
end;
theorem
L186: (for R1 being set holds (for B16 being  DTree-yielding FinSequence holds (for B17 being (Element of ( NAT )) holds (for B18 being DecoratedTree holds (for B19 being (Node of B18) holds ((B17 < ( len B16 ) & B18 = ( B16 . ( B17 + 1 ) )) implies ( ( R1 -tree B16 ) . ( <* B17 *> ^ B19 ) ) = ( B18 . B19 )))))))
proof
let R1 being set;
let C41 being  DTree-yielding FinSequence;
let C42 being (Element of ( NAT ));
let C43 being DecoratedTree;
let C44 being (Node of C43);
assume L187: (C42 < ( len C41 ) & C43 = ( C41 . ( C42 + 1 ) ));
L188: ( <* C42 *> ^ C44 ) in ( dom ( R1 -tree C41 ) ) by L187 , L169;
L189: <* C42 *> in ( dom ( R1 -tree C41 ) ) by L188 , TREES_1:21;
L190: C44 in ( ( dom ( R1 -tree C41 ) ) | <* C42 *> ) by L189 , L188 , TREES_1:def 6;
L191: ( ( ( R1 -tree C41 ) | <* C42 *> ) . C44 ) = ( ( R1 -tree C41 ) . ( <* C42 *> ^ C44 ) ) by L190 , TREES_2:def 10;
thus L192: thesis by L191 , L187 , L113;
end;
theorem
L193: (for R1 being set holds (for B20 being DecoratedTree holds ( dom ( R1 -tree B20 ) ) = ( ^ ( dom B20 ) )))
proof
let R1 being set;
let C45 being DecoratedTree;
L194: (( dom ( R1 -tree <* C45 *> ) ) = ( tree ( doms <* C45 *> ) ) & ( doms <* C45 *> ) = <* ( dom C45 ) *>) by L166 , FINSEQ_3:132;
thus L195: thesis by L194 , TREES_3:def 16;
end;
theorem
L196: (for R1 being set holds (for B21 , B22 being DecoratedTree holds ( dom ( R1 -tree (B21 , B22) ) ) = ( tree (( dom B21 ) , ( dom B22 )) )))
proof
let R1 being set;
let C46 , C47 being DecoratedTree;
L197: (( dom ( R1 -tree <* C46 , C47 *> ) ) = ( tree ( doms <* C46 , C47 *> ) ) & ( doms <* C46 , C47 *> ) = <* ( dom C46 ) , ( dom C47 ) *>) by L166 , FINSEQ_3:133;
thus L198: thesis by L197 , TREES_3:def 17;
end;
theorem
L199: (for R1 being set holds (for R2 being set holds (for B23 , B24 being  DTree-yielding FinSequence holds (( R1 -tree B23 ) = ( R2 -tree B24 ) implies (R1 = R2 & B23 = B24)))))
proof
let R1 being set;
let R2 being set;
let C48 , C49 being  DTree-yielding FinSequence;
assume L200: ( R1 -tree C48 ) = ( R2 -tree C49 );
L201: ( ( R1 -tree C48 ) . ( {} ) ) = R1 by L113;
thus L202: R1 = R2 by L201 , L200 , L113;
L203: (( dom ( R1 -tree C48 ) ) = ( tree ( doms C48 ) ) & ( dom ( R2 -tree C49 ) ) = ( tree ( doms C49 ) )) by L166;
L204: ( doms C48 ) = ( doms C49 ) by L203 , L200 , TREES_3:50;
L205: (( dom C48 ) = ( dom ( doms C48 ) ) & ( dom ( doms C49 ) ) = ( dom C49 )) by TREES_3:37;
L206: ( len C48 ) = ( len C49 ) by L205 , L204 , FINSEQ_3:29;
L207:
now
let C50 being Nat;
assume that
L208: C50 >= 1
and
L209: C50 <= ( len C48 );
consider C51 being Nat such that L210: C50 = ( 1 + C51 ) by L208 , NAT_1:10;
reconsider D24 = C51 as (Element of ( NAT )) by ORDINAL1:def 12;
L211: D24 < ( len C48 ) by L209 , L210 , NAT_1:13;
L212: ( C48 . C50 ) = ( ( R1 -tree C48 ) | <* D24 *> ) by L211 , L210 , L113;
thus L213: ( C48 . C50 ) = ( C49 . C50 ) by L212 , L200 , L206 , L210 , L211 , L113;
end;
thus L214: thesis by L207 , L206 , FINSEQ_1:14;
end;
theorem
L215: (for R1 being set holds (for R2 being set holds (for R7 being FinSequence holds (( root-tree R1 ) = ( R2 -flat_tree R7 ) implies (R1 = R2 & R7 = ( {} ))))))
proof
let R1 being set;
let R2 being set;
let R7 being FinSequence;
assume L216: ( root-tree R1 ) = ( R2 -flat_tree R7 );
thus L217: R1 = ( ( root-tree R1 ) . ( {} ) ) by L37
.= R2 by L216 , L49;
L218: ( dom ( R2 -flat_tree R7 ) ) = ( elementary_tree ( len R7 ) ) by L49;
thus L219: thesis by L218 , L216 , L17 , L37;
end;
theorem
L220: (for R1 being set holds (for R2 being set holds (for R7 being FinSequence holds ((( root-tree R1 ) = ( R2 -tree R7 ) & R7 is  DTree-yielding) implies (R1 = R2 & R7 = ( {} ))))))
proof
let R1 being set;
let R2 being set;
let R7 being FinSequence;
assume that
L221: ( root-tree R1 ) = ( R2 -tree R7 )
and
L222: R7 is  DTree-yielding;
reconsider D25 = R7 as  DTree-yielding FinSequence by L222;
thus L223: R1 = ( ( root-tree R1 ) . ( {} ) ) by L37
.= R2 by L221 , L222 , L113;
L224: ( dom ( R2 -tree R7 ) ) = ( tree ( doms D25 ) ) by L166;
L225: ( doms R7 ) = ( {} ) by L224 , L221 , L37 , TREES_3:50 , TREES_3:52;
L226: ( dom ( doms R7 ) ) = ( dom R7 ) by L224 , TREES_3:37;
thus L227: thesis by L226 , L225;
end;
theorem
L228: (for R1 being set holds (for R2 being set holds (for R7 being FinSequence holds (for R8 being FinSequence holds ((( R1 -flat_tree R7 ) = ( R2 -tree R8 ) & R8 is  DTree-yielding) implies (R1 = R2 & ( len R7 ) = ( len R8 ) & (for R4 being (Element of ( NAT )) holds (R4 in ( dom R7 ) implies ( R8 . R4 ) = ( root-tree ( R7 . R4 ) )))))))))
proof
let R1 being set;
let R2 being set;
let R7 being FinSequence;
let R8 being FinSequence;
assume that
L229: ( R1 -flat_tree R7 ) = ( R2 -tree R8 )
and
L230: R8 is  DTree-yielding;
reconsider D26 = R8 as  DTree-yielding FinSequence by L230;
thus L231: R1 = ( ( R1 -flat_tree R7 ) . ( {} ) ) by L49
.= R2 by L229 , L230 , L113;
L232: ( tree ( ( len R7 ) |-> ( elementary_tree ( 0 ) ) ) ) = ( elementary_tree ( len R7 ) ) by TREES_3:54
.= ( dom ( R1 -flat_tree R7 ) ) by L49
.= ( tree ( doms D26 ) ) by L229 , L166;
L233: ( ( len R7 ) |-> ( elementary_tree ( 0 ) ) ) = ( doms D26 ) by L232 , TREES_3:50;
L234: ( len ( doms D26 ) ) = ( len R8 ) by TREES_3:38;
thus L235: ( len R7 ) = ( len R8 ) by L234 , L233 , CARD_1:def 7;
let R4 being (Element of ( NAT ));
assume L236: R4 in ( dom R7 );
L237: R4 >= 1 by L236 , FINSEQ_3:25;
L238: R4 <= ( len R7 ) by L236 , FINSEQ_3:25;
consider C52 being Nat such that L239: R4 = ( 1 + C52 ) by L237 , NAT_1:10;
reconsider D27 = C52 as (Element of ( NAT )) by ORDINAL1:def 12;
L240: D27 < ( len R7 ) by L238 , L239 , NAT_1:13;
L241: ( ( R1 -flat_tree R7 ) | <* D27 *> ) = ( root-tree ( R7 . R4 ) ) by L240 , L239 , L104;
thus L242: thesis by L241 , L229 , L230 , L235 , L239 , L240 , L113;
end;
theorem
L243: (for R1 being set holds (for B25 being  DTree-yielding FinSequence holds (for B26 being (Element of ( NAT )) holds (for B27 being FinSequence holds (( <* B26 *> ^ B27 ) in ( dom ( R1 -tree B25 ) ) implies ( ( R1 -tree B25 ) . ( <* B26 *> ^ B27 ) ) = ( B25 .. (( B26 + 1 ) , B27) ))))))
proof
let R1 being set;
let C53 being  DTree-yielding FinSequence;
let C54 being (Element of ( NAT ));
let C55 being FinSequence;
assume L244: ( <* C54 *> ^ C55 ) in ( dom ( R1 -tree C53 ) );
L245: ( <* C54 *> ^ C55 ) is (Node of ( R1 -tree C53 )) by L244;
reconsider D28 = C55 as (FinSequence of ( NAT )) by L245 , FINSEQ_1:36;
L246: <* C54 *> in ( dom ( R1 -tree C53 ) ) by L244 , TREES_1:21;
L247: ( <* C54 *> ^ C55 ) in ( tree ( doms C53 ) ) by L244 , L166;
L248: ( len ( doms C53 ) ) = ( len C53 ) by TREES_3:38;
L249: D28 in ( ( dom ( R1 -tree C53 ) ) | <* C54 *> ) by L244 , L246 , TREES_1:def 6;
L250: C54 < ( len C53 ) by L247 , L248 , TREES_3:48;
L251: (( dom ( ( R1 -tree C53 ) | <* C54 *> ) ) = ( ( dom ( R1 -tree C53 ) ) | <* C54 *> ) & ( ( ( R1 -tree C53 ) | <* C54 *> ) . D28 ) = ( ( R1 -tree C53 ) . ( <* C54 *> ^ C55 ) )) by L249 , TREES_2:def 10;
L252: (( C54 + 1 ) in ( dom C53 ) & ( C53 . ( C54 + 1 ) ) = ( ( R1 -tree C53 ) | <* C54 *> )) by L250 , L113 , L21;
thus L253: thesis by L252 , L249 , L251 , FUNCT_5:38;
end;
theorem
L254: (for R1 being set holds (( R1 -flat_tree ( {} ) ) = ( root-tree R1 ) & ( R1 -tree ( {} ) ) = ( root-tree R1 )))
proof
let R1 being set;
L255: ( len ( {} ) ) = ( 0 );
L256: ( dom ( R1 -flat_tree ( {} ) ) ) = ( elementary_tree ( 0 ) ) by L255 , L49;
L257:
now
let R2 being set;
assume L258: R2 in ( elementary_tree ( 0 ) );
L259: R2 = ( {} ) by L258 , TARSKI:def 1 , TREES_1:29;
thus L260: ( ( R1 -flat_tree ( {} ) ) . R2 ) = R1 by L259 , L49;
end;
thus L261: ( R1 -flat_tree ( {} ) ) = ( root-tree R1 ) by L257 , L256 , FUNCOP_1:11;
reconsider D29 = ( {} ) as  DTree-yielding FinSequence;
L262: ( dom ( R1 -tree ( {} ) ) ) = ( tree ( doms D29 ) ) by L166
.= ( elementary_tree ( 0 ) ) by FUNCT_6:23 , TREES_3:52;
L263:
now
let R2 being set;
assume L264: R2 in ( elementary_tree ( 0 ) );
L265: R2 = ( {} ) by L264 , TARSKI:def 1 , TREES_1:29;
thus L266: ( ( R1 -tree D29 ) . R2 ) = R1 by L265 , L113;
end;
thus L267: thesis by L263 , L262 , FUNCOP_1:11;
end;
theorem
L268: (for R1 being set holds (for R2 being set holds ( R1 -flat_tree <* R2 *> ) = ( ( ( elementary_tree 1 ) --> R1 ) with-replacement (<* ( 0 ) *> , ( root-tree R2 )) )))
proof
let R1 being set;
let R2 being set;
set D30 = ( ( ( elementary_tree 1 ) --> R1 ) with-replacement (<* ( 0 ) *> , ( root-tree R2 )) );
L269: ( dom ( R1 -flat_tree <* R2 *> ) ) = ( elementary_tree ( len <* R2 *> ) ) by L49
.= ( elementary_tree 1 ) by FINSEQ_1:40;
L270: ( dom ( root-tree R2 ) ) = ( elementary_tree ( 0 ) ) by FUNCOP_1:13;
L271: (( dom ( ( elementary_tree 1 ) --> R1 ) ) = ( elementary_tree 1 ) & <* ( 0 ) *> in ( elementary_tree 1 )) by FUNCOP_1:13 , TARSKI:def 2 , TREES_1:51;
L272: ( dom D30 ) = ( ( elementary_tree 1 ) with-replacement (<* ( 0 ) *> , ( elementary_tree ( 0 ) )) ) by L271 , L270 , TREES_2:def 11
.= ( elementary_tree 1 ) by TREES_3:58 , TREES_3:67;
L273:
now
let R3 being set;
assume L274: R3 in ( elementary_tree 1 );
L275: (R3 = ( {} ) or R3 = <* ( 0 ) *>) by L274 , TARSKI:def 2 , TREES_1:51;
L276: ( {} ) in ( elementary_tree 1 ) by TARSKI:def 2 , TREES_1:51;
L277: (not <* ( 0 ) *> is_a_prefix_of ( {} ));
L278: ( len <* R2 *> ) = 1 by FINSEQ_1:40;
L279: (( <* R2 *> . 1 ) = R2 & ( ( R1 -flat_tree <* R2 *> ) . ( {} ) ) = R1) by L49 , FINSEQ_1:40;
L280: ( D30 . ( {} ) ) = ( ( ( elementary_tree 1 ) --> R1 ) . ( {} ) ) by L271 , L276 , L277 , TREES_3:45;
L281: ( ( R1 -flat_tree <* R2 *> ) . <* ( 0 ) *> ) = ( <* R2 *> . ( ( 0 ) + 1 ) ) by L278 , L49;
L282: ( D30 . <* ( 0 ) *> ) = ( ( root-tree R2 ) . ( {} ) ) by L271 , TREES_3:44;
thus L283: ( D30 . R3 ) = ( ( R1 -flat_tree <* R2 *> ) . R3 ) by L282 , L275 , L276 , L279 , L280 , L281 , L37 , FUNCOP_1:7;
end;
thus L284: thesis by L273 , L269 , L272 , FUNCT_1:2;
end;
theorem
L285: (for R1 being set holds (for B28 being DecoratedTree holds ( R1 -tree <* B28 *> ) = ( ( ( elementary_tree 1 ) --> R1 ) with-replacement (<* ( 0 ) *> , B28) )))
proof
let R1 being set;
let C56 being DecoratedTree;
set D31 = ( ( ( elementary_tree 1 ) --> R1 ) with-replacement (<* ( 0 ) *> , C56) );
set D32 = ( ( elementary_tree 1 ) with-replacement (<* ( 0 ) *> , ( dom C56 )) );
L286: ( dom ( R1 -tree <* C56 *> ) ) = ( tree ( doms <* C56 *> ) ) by L166
.= ( tree <* ( dom C56 ) *> ) by FINSEQ_3:132
.= ( ^ ( dom C56 ) ) by TREES_3:def 16
.= D32 by TREES_3:58;
L287: ( dom ( ( elementary_tree 1 ) --> R1 ) ) = ( elementary_tree 1 ) by FUNCOP_1:13;
reconsider D33 = ( {} ) , D34 = <* ( 0 ) *> as (Element of ( elementary_tree 1 )) by TARSKI:def 2 , TREES_1:51;
L288: D34 = D34;
L289: ( dom D31 ) = D32 by L288 , L287 , TREES_2:def 11;
L290: ( {} ) in ( dom C56 ) by TREES_1:22;
L291:
now
let R2 being set;
assume L292: R2 in D32;
reconsider D35 = R2 as (Element of D32) by L292;
L293: (D35 in ( elementary_tree 1 ) or (ex R10 being (FinSequence of ( NAT )) st (R10 in ( dom C56 ) & D35 = ( D34 ^ R10 )))) by TREES_1:def 9;
L294: (D35 = ( {} ) or (D35 = D34 & D34 = ( D34 ^ D33 )) or (ex R10 being (FinSequence of ( NAT )) st (R10 in ( dom C56 ) & D35 = ( <* ( 0 ) *> ^ R10 )))) by L293 , FINSEQ_1:34 , TARSKI:def 2 , TREES_1:51;
L295: (not D34 is_a_prefix_of D33);
L296: ( D31 . ( {} ) ) = ( ( ( elementary_tree 1 ) --> R1 ) . D33 ) by L295 , L287 , TREES_3:45
.= R1 by FUNCOP_1:7
.= ( ( R1 -tree <* C56 *> ) . ( {} ) ) by L113;
L297:
now
given C57 being (FinSequence of ( NAT )) such that
L298: C57 in ( dom C56 )
and
L299: D35 = ( <* ( 0 ) *> ^ C57 );

reconsider D36 = C57 as (Node of C56) by L298;
L300: D35 = ( D34 ^ D36 ) by L299;
L301: ( D31 . D35 ) = ( C56 . D36 ) by L300 , L287 , TREES_3:46;
L302: (( len <* C56 *> ) = 1 & ( <* C56 *> . ( ( 0 ) + 1 ) ) = C56) by FINSEQ_1:40;
L303: ( ( R1 -tree <* C56 *> ) | D34 ) = C56 by L302 , L113;
L304: ( D32 | D34 ) = ( dom C56 ) by TREES_1:33;
thus L305: ( D31 . D35 ) = ( ( R1 -tree <* C56 *> ) . D35 ) by L304 , L286 , L299 , L301 , L303 , TREES_2:def 10;
end;
thus L306: ( D31 . R2 ) = ( ( R1 -tree <* C56 *> ) . R2 ) by L297 , L290 , L294 , L296;
end;
thus L307: thesis by L291 , L286 , L289 , FUNCT_1:2;
end;
registration
let C58 being non  empty set;
let C59 being (Element of C58);
let C60 being (FinSequence of C58);
cluster ( C59 -flat_tree C60 ) -> C58 -valued;
coherence
proof
set D37 = ( C59 -flat_tree C60 );
L308: ( rng D37 ) c= C58
proof
let R1 being set;
assume L309: R1 in ( rng D37 );
consider R2 being set such that L310: R2 in ( dom D37 ) and L311: R1 = ( D37 . R2 ) by L309 , FUNCT_1:def 3;
reconsider D38 = R2 as (Node of D37) by L310;
L312: ( dom D37 ) = ( elementary_tree ( len C60 ) ) by L49;
L313: ( D37 . ( {} ) ) = C59 by L49;
L314:
now
assume L315: D38 <> ( {} );
consider R6 being (Element of ( NAT )) such that L316: (R6 < ( len C60 ) & D38 = <* R6 *>) by L315 , L312 , TREES_1:30;
L317: (( D37 . D38 ) = ( C60 . ( R6 + 1 ) ) & ( C60 . ( R6 + 1 ) ) in ( rng C60 )) by L316 , L49 , L21;
L318: ( rng C60 ) c= C58 by FINSEQ_1:def 4;
thus L319: thesis by L318 , L311 , L317;
end;
thus L320: thesis by L314 , L311 , L313;
end;
thus L321: thesis by L308 , RELAT_1:def 19;
end;
end;
registration
let C61 being non  empty set;
let C62 being non  empty (DTree-set of C61);
let C63 being (Element of C61);
let C64 being (FinSequence of C62);
cluster ( C63 -tree C64 ) -> C61 -valued;
coherence
proof
set D39 = ( C63 -tree C64 );
L323: ( rng D39 ) c= C61
proof
let R1 being set;
assume L324: R1 in ( rng D39 );
consider R2 being set such that L325: R2 in ( dom D39 ) and L326: R1 = ( D39 . R2 ) by L324 , FUNCT_1:def 3;
reconsider D40 = R2 as (Node of D39) by L325;
L327: ( ( tree ( doms C64 ) ) -level 1 ) = { <* R6 *> where R6 is (Element of ( NAT )) : R6 < ( len ( doms C64 ) ) } by TREES_3:49;
L328: ( D39 . ( {} ) ) = C63 by L113;
L329: (( tree ( doms C64 ) ) = ( dom D39 ) & ( len ( doms C64 ) ) = ( len C64 )) by L166 , TREES_3:38;
L330:
now
assume L331: D40 <> ( {} );
consider C65 being (FinSequence of ( NAT )), C66 being (Element of ( NAT )) such that L332: D40 = ( <* C66 *> ^ C65 ) by L331 , FINSEQ_2:130;
L333: <* C66 *> in ( dom D39 ) by L332 , TREES_1:21;
L334: ( len <* C66 *> ) = 1 by FINSEQ_1:40;
L335: C65 in ( ( dom D39 ) | <* C66 *> ) by L332 , L333 , TREES_1:def 6;
L336: <* C66 *> in ( ( dom D39 ) -level 1 ) by L333 , L334;
L337: ( dom ( D39 | <* C66 *> ) ) = ( ( dom D39 ) | <* C66 *> ) by TREES_2:def 10;
consider R4 being (Element of ( NAT )) such that L338: (<* C66 *> = <* R4 *> & R4 < ( len C64 )) by L327 , L329 , L336;
L339: (( <* C66 *> . 1 ) = C66 & ( <* R4 *> . 1 ) = R4) by FINSEQ_1:40;
L340: ( D39 | <* C66 *> ) = ( C64 . ( C66 + 1 ) ) by L339 , L338 , L113;
L341: ( C64 . ( C66 + 1 ) ) in ( rng C64 ) by L338 , L339 , L21;
L342: ( rng C64 ) c= C62 by FINSEQ_1:def 4;
reconsider D41 = ( C64 . ( C66 + 1 ) ) as (Element of C62) by L342 , L341;
L343: ( D41 . C65 ) = R1 by L326 , L332 , L335 , L340 , TREES_2:def 10;
L344: ( D41 . C65 ) in ( rng D41 ) by L335 , L337 , L340 , FUNCT_1:def 3;
L345: ( rng D41 ) c= C61 by RELAT_1:def 19;
thus L346: thesis by L345 , L343 , L344;
end;
thus L347: thesis by L330 , L326 , L328;
end;
thus L348: thesis by L323 , RELAT_1:def 19;
end;
end;
registration
let C67 being non  empty set;
let C68 being (Element of C67);
let C69 being (DecoratedTree of C67);
cluster ( C68 -tree C69 ) -> C67 -valued;
coherence
proof
reconsider D42 = C69 as (Element of ( Trees C67 )) by TREES_3:def 7;
reconsider D43 = <* D42 *> as (Element of ( ( Trees C67 ) * )) by FINSEQ_1:def 11;
L350: ( C68 -tree D42 ) = ( C68 -tree D43 );
thus L351: thesis by L350;
end;
end;
registration
let C70 being non  empty set;
let C71 being (Element of C70);
let C72 , C73 being (DecoratedTree of C70);
cluster ( C71 -tree (C72 , C73) ) -> C70 -valued;
coherence
proof
reconsider D44 = C72 , D45 = C73 as (Element of ( Trees C70 )) by TREES_3:def 7;
L353: <* D44 , D45 *> = ( <* (D44 qua (Element of (( Trees C70 ) qua non  empty set))) *> ^ <* (D45 qua (Element of (( Trees C70 ) qua non  empty set))) *> );
reconsider D46 = <* D44 , D45 *> as (Element of ( ( Trees C70 ) * )) by L353 , FINSEQ_1:def 11;
L354: ( C71 -tree (D44 , D45) ) = ( C71 -tree D46 );
thus L355: thesis by L354;
end;
end;
definition
let C74 being non  empty set;
let C75 being (FinSequence of ( FinTrees C74 ));
redefine func doms C75 -> (FinSequence of ( FinTrees ));

coherence
proof
L357: ( dom ( doms C75 ) ) = ( dom C75 ) by TREES_3:37;
L358: ( rng C75 ) c= ( FinTrees C74 ) by FINSEQ_1:def 4;
thus L359: ( doms C75 ) is (FinSequence of ( FinTrees ))
proof
let R1 being set;
assume L360: R1 in ( rng ( doms C75 ) );
consider R2 being set such that L361: R2 in ( dom C75 ) and L362: R1 = ( ( doms C75 ) . R2 ) by L360 , L357 , FUNCT_1:def 3;
reconsider D47 = ( C75 . R2 ) as DecoratedTree by L361 , TREES_3:24;
L363: D47 in ( rng C75 ) by L361 , FUNCT_1:def 3;
L364: ( dom D47 ) in ( FinTrees ) by L363 , L358 , TREES_3:def 2;
thus L365: thesis by L364 , L361 , L362 , FUNCT_6:22;
end;

end;
end;
definition
let C76 being non  empty set;
let C77 being (Element of C76);
let C78 being (FinSequence of ( FinTrees C76 ));
redefine func C77 -tree C78 -> (Element of ( FinTrees C76 ));

coherence
proof
L361: ( dom ( C77 -tree C78 ) ) = ( tree ( doms C78 ) ) by L166;
thus L362: thesis by L361 , TREES_3:def 8;
end;
end;
definition
let C79 being non  empty set;
let C80 being (Subset of C79);
redefine mode FinSequence of C80
 -> (FinSequence of C79);
coherence
proof
let C81 being (FinSequence of C80);
L364: ( rng C81 ) c= C80 by FINSEQ_1:def 4;
thus L365: ( rng C81 ) c= C79 by L364 , XBOOLE_1:1;
end;
end;
registration
let C82 being non  empty  constituted-DTrees set;
let C83 being (Subset of C82);
cluster  ->  DTree-yielding for (FinSequence of C83);
coherence;
end;
begin
scheme ExpandTree { F1() -> Tree , F2() -> Tree , P1[set] } : (ex B29 being Tree st (for R7 being FinSequence holds (R7 in B29 iff (R7 in F1() or (ex B30 being (Element of F1()) st (ex B31 being (Element of F2()) st (P1[ B30 ] & R7 = ( B30 ^ B31 ))))))))
proof
defpred S3[ set ] means ($1 in F1() or (ex B32 being (Element of F1()) st (ex B33 being (Element of F2()) st (P1[ B32 ] & $1 = ( B32 ^ B33 )))));
consider C84 being set such that L368: (for R1 being set holds (R1 in C84 iff (R1 in ( ( NAT ) * ) & S3[ R1 ]))) from XBOOLE_0:sch 1;
set D48 = the (Element of F1());
L369: D48 in ( ( NAT ) * ) by FINSEQ_1:def 11;
reconsider D49 = C84 as non  empty set by L369 , L368;
L370: D49 is  Tree-like
proof
thus L371: D49 c= ( ( NAT ) * )
proof
let R1 being set;
thus L372: thesis by L368;
end;

thus L373: (for B34 being (FinSequence of ( NAT )) holds (B34 in D49 implies ( ProperPrefixes B34 ) c= D49))
proof
let C85 being (FinSequence of ( NAT ));
assume that
L374: C85 in D49;
let R1 being set;
assume L375: R1 in ( ProperPrefixes C85 );
consider R8 being FinSequence such that L376: R1 = R8 and L377: R8 is_a_proper_prefix_of C85 by L375 , TREES_1:def 2;
assume L378: (not thesis);
L379: R8 is_a_prefix_of C85 by L377 , XBOOLE_0:def 8;
consider R9 being FinSequence such that L380: C85 = ( R8 ^ R9 ) by L379 , TREES_1:1;
reconsider D50 = R8 , D51 = R9 as (FinSequence of ( NAT )) by L380 , FINSEQ_1:36;
L381: ((( D50 ^ D51 ) in F1() & D50 in ( ( NAT ) * ) & (( D50 ^ D51 ) in F1() implies D50 in F1())) or (ex B35 being (Element of F1()) st (ex B36 being (Element of F2()) st (P1[ B35 ] & C85 = ( B35 ^ B36 ))))) by L368 , L374 , L380 , FINSEQ_1:def 11 , TREES_1:21;
consider C86 being (Element of F1()), C87 being (Element of F2()) such that L382: P1[ C86 ] and L383: ( D50 ^ D51 ) = ( C86 ^ C87 ) by L381 , L368 , L376 , L378 , L380;
L384:
now
assume L385: ( len D50 ) <= ( len C86 );
L386: (ex B37 being FinSequence st ( D50 ^ B37 ) = C86) by L385 , L383 , FINSEQ_1:47;
L387: D50 in F1() by L386 , TREES_1:21;
L388: D50 in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L389: contradiction by L388 , L368 , L376 , L378 , L387;
end;
consider C88 being FinSequence such that L390: ( C86 ^ C88 ) = D50 by L384 , L383 , FINSEQ_1:47;
reconsider D52 = C88 as (FinSequence of ( NAT )) by L390 , FINSEQ_1:36;
L391: ( C86 ^ C87 ) = ( C86 ^ ( D52 ^ D51 ) ) by L383 , L390 , FINSEQ_1:32;
L392: ( D52 ^ D51 ) = C87 by L391 , FINSEQ_1:33;
L393: (D50 in ( ( NAT ) * ) & D52 is (Element of F2())) by L392 , FINSEQ_1:def 11 , TREES_1:21;
thus L394: thesis by L393 , L368 , L376 , L378 , L382 , L390;
end;

let C89 being (FinSequence of ( NAT ));
let C90 , C91 being (Element of ( NAT ));
assume that
L395: ( C89 ^ <* C90 *> ) in D49
and
L396: C91 <= C90;
L397:
now
assume L398: ( C89 ^ <* C90 *> ) in F1();
L399: ( C89 ^ <* C91 *> ) in F1() by L398 , L396 , TREES_1:def 3;
L400: ( C89 ^ <* C91 *> ) in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L401: thesis by L400 , L368 , L399;
end;
L402:
now
assume L403: (not ( C89 ^ <* C90 *> ) in F1());
consider C92 being (Element of F1()), C93 being (Element of F2()) such that L404: P1[ C92 ] and L405: ( C89 ^ <* C90 *> ) = ( C92 ^ C93 ) by L403 , L368 , L395;
L406: ( C92 ^ ( {} ) ) = C92 by FINSEQ_1:34;
L407: C93 <> ( {} ) by L406 , L403 , L405;
consider C94 being FinSequence, R3 being set such that L408: C93 = ( C94 ^ <* R3 *> ) by L407 , FINSEQ_1:46;
reconsider D53 = C94 as (FinSequence of ( NAT )) by L408 , FINSEQ_1:36;
L409: ( C89 ^ <* C90 *> ) = ( ( C92 ^ D53 ) ^ <* R3 *> ) by L405 , L408 , FINSEQ_1:32;
L410: (( ( C89 ^ <* C90 *> ) . ( ( len C89 ) + 1 ) ) = C90 & ( ( ( C92 ^ D53 ) ^ <* R3 *> ) . ( ( len ( C92 ^ D53 ) ) + 1 ) ) = R3) by FINSEQ_1:42;
L411: (( len <* C90 *> ) = 1 & ( len <* R3 *> ) = 1) by FINSEQ_1:40;
L412: (( len ( C89 ^ <* C90 *> ) ) = ( ( len C89 ) + ( len <* C90 *> ) ) & ( len ( ( C92 ^ D53 ) ^ <* R3 *> ) ) = ( ( len ( C92 ^ D53 ) ) + ( len <* R3 *> ) )) by FINSEQ_1:22;
L413: C89 = ( C92 ^ D53 ) by L412 , L409 , L410 , L411 , FINSEQ_1:33;
L414: ( D53 ^ <* C91 *> ) in F2() by L396 , L408 , L409 , L410 , L411 , L412 , TREES_1:def 3;
L415: ( C89 ^ <* C91 *> ) = ( C92 ^ ( D53 ^ <* C91 *> ) ) by L413 , FINSEQ_1:32;
L416: ( C89 ^ <* C91 *> ) in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L417: thesis by L416 , L368 , L404 , L414 , L415;
end;
thus L418: thesis by L402 , L397;
end;
reconsider D54 = D49 as Tree by L370;
take D54;
let R7 being FinSequence;
L419: ((R7 is (Element of F1()) or (ex B38 being (Element of F1()) st (ex B39 being (Element of F2()) st (P1[ B38 ] & R7 = ( B38 ^ B39 ))))) implies R7 in ( ( NAT ) * )) by FINSEQ_1:def 11;
thus L420: thesis by L419 , L368;
end;
definition
let C95 , C96 being DecoratedTree;
let C97 being set;
func (C95 , C97) <- C96 -> DecoratedTree means 
:L421: ((for R7 being FinSequence holds (R7 in ( dom it ) iff (R7 in ( dom C95 ) or (ex B40 being (Node of C95) st (ex B41 being (Node of C96) st (B40 in ( Leaves ( dom C95 ) ) & ( C95 . B40 ) = C97 & R7 = ( B40 ^ B41 ))))))) & (for B42 being (Node of C95) holds (((not B42 in ( Leaves ( dom C95 ) )) or ( C95 . B42 ) <> C97) implies ( it . B42 ) = ( C95 . B42 ))) & (for B43 being (Node of C95) holds (for B44 being (Node of C96) holds ((B43 in ( Leaves ( dom C95 ) ) & ( C95 . B43 ) = C97) implies ( it . ( B43 ^ B44 ) ) = ( C96 . B44 )))));
existence
proof
defpred S4[ set ] means ($1 in ( Leaves ( dom C95 ) ) & ( C95 . $1 ) = C97);
consider C98 being Tree such that L422: (for R7 being FinSequence holds (R7 in C98 iff (R7 in ( dom C95 ) or (ex B45 being (Node of C95) st (ex B46 being (Node of C96) st (S4[ B45 ] & R7 = ( B45 ^ B46 ))))))) from ExpandTree;
defpred S5[ set , set ] means (($1 is (Node of C95) & ((not $1 in ( Leaves ( dom C95 ) )) or ( C95 . $1 ) <> C97) & $2 = ( C95 . $1 )) or (ex B47 being (Node of C95) st (ex B48 being (Node of C96) st ($1 = ( B47 ^ B48 ) & B47 in ( Leaves ( dom C95 ) ) & ( C95 . B47 ) = C97 & $2 = ( C96 . B48 )))));
L423: (for R3 being set holds (R3 in C98 implies (ex R2 being set st S5[ R3 , R2 ])))
proof
let R3 being set;
assume L424: R3 in C98;
reconsider D55 = R3 as (Element of C98) by L424;
L425:
now
given C99 being (Node of C95) , C100 being (Node of C96) such that
L426: (C99 in ( Leaves ( dom C95 ) ) & ( C95 . C99 ) = C97 & D55 = ( C99 ^ C100 ));

take D56 = ( C96 . C100 );
take D57 = C99;
take D58 = C100;
thus L427: (R3 = ( D57 ^ D58 ) & D57 in ( Leaves ( dom C95 ) ) & ( C95 . D57 ) = C97 & D56 = ( C96 . D58 )) by L426;
end;
L428:
now
assume L429: (not (ex B49 being (Node of C95) st (ex B50 being (Node of C96) st (B49 in ( Leaves ( dom C95 ) ) & ( C95 . B49 ) = C97 & D55 = ( B49 ^ B50 )))));
take D59 = ( C95 . R3 );
thus L430: R3 is (Node of C95) by L422 , L429;
reconsider D60 = D55 as (Node of C95) by L422 , L429;
reconsider D61 = ( {} ) as (Node of C96) by TREES_1:22;
L431: ( D60 ^ D61 ) = D60 by FINSEQ_1:34;
thus L432: (((not R3 in ( Leaves ( dom C95 ) )) or ( C95 . R3 ) <> C97) & D59 = ( C95 . R3 )) by L431 , L429;
end;
thus L433: thesis by L428 , L425;
end;
consider C101 being Function such that L434: (( dom C101 ) = C98 & (for R3 being set holds (R3 in C98 implies S5[ R3 , ( C101 . R3 ) ]))) from CLASSES1:sch 1(L423);
reconsider D62 = C101 as DecoratedTree by L434 , TREES_2:def 8;
take D62;
thus L435: (for R7 being FinSequence holds (R7 in ( dom D62 ) iff (R7 in ( dom C95 ) or (ex B51 being (Node of C95) st (ex B52 being (Node of C96) st (B51 in ( Leaves ( dom C95 ) ) & ( C95 . B51 ) = C97 & R7 = ( B51 ^ B52 ))))))) by L422 , L434;
thus L436: (for B53 being (Node of C95) holds (((not B53 in ( Leaves ( dom C95 ) )) or ( C95 . B53 ) <> C97) implies ( D62 . B53 ) = ( C95 . B53 )))
proof
let C102 being (Node of C95);
assume L437: ((not C102 in ( Leaves ( dom C95 ) )) or ( C95 . C102 ) <> C97);
L438: C102 in C98 by L422;
L439:
now
given C103 being (Node of C95) , C104 being (Node of C96) such that
L440: C102 = ( C103 ^ C104 )
and
L441: C103 in ( Leaves ( dom C95 ) )
and
L442: ( C95 . C103 ) = C97
and
L443: ( D62 . C102 ) = ( C96 . C104 );

L444: (C103 is_a_prefix_of C102 & (not C103 is_a_proper_prefix_of C102)) by L440 , L441 , TREES_1:1 , TREES_1:def 5;
thus L445: contradiction by L444 , L437 , L441 , L442 , XBOOLE_0:def 8;
end;
thus L446: thesis by L439 , L434 , L438;
end;

let C105 being (Node of C95);
let C106 being (Node of C96);
assume that
L447: C105 in ( Leaves ( dom C95 ) )
and
L448: ( C95 . C105 ) = C97;
L449: ( C105 ^ C106 ) in C98 by L422 , L447 , L448;
L450:
now
assume L451: ( C105 ^ C106 ) is (Node of C95);
L452: (not C105 is_a_proper_prefix_of ( C105 ^ C106 )) by L451 , L447 , TREES_1:def 5;
L453: C105 is_a_prefix_of ( C105 ^ C106 ) by TREES_1:1;
thus L454: C105 = ( C105 ^ C106 ) by L453 , L452 , XBOOLE_0:def 8;
end;
consider C107 being (Node of C95), C108 being (Node of C96) such that L455: ( C105 ^ C106 ) = ( C107 ^ C108 ) and L456: C107 in ( Leaves ( dom C95 ) ) and L457: ( C95 . C107 ) = C97 and L458: ( D62 . ( C105 ^ C106 ) ) = ( C96 . C108 ) by L450 , L434 , L447 , L448 , L449;
L459:
now
let C109 , C110 , C111 , C112 being (FinSequence of ( NAT ));
let C113 being Tree;
assume that
L460: ( C109 ^ C111 ) = ( C110 ^ C112 )
and
L461: (C109 in ( Leaves C113 ) & C110 in ( Leaves C113 ))
and
L462: C109 <> C110;
L463:
now
assume L464: ( len C109 ) <= ( len C110 );
L465: (ex R9 being FinSequence st ( C109 ^ R9 ) = C110) by L464 , L460 , FINSEQ_1:47;
L466: C109 is_a_prefix_of C110 by L465 , TREES_1:1;
L467: C109 is_a_proper_prefix_of C110 by L466 , L462 , XBOOLE_0:def 8;
thus L468: contradiction by L467 , L461 , TREES_1:def 5;
end;
L469: (ex R9 being FinSequence st ( C110 ^ R9 ) = C109) by L463 , L460 , FINSEQ_1:47;
L470: C110 is_a_prefix_of C109 by L469 , TREES_1:1;
L471: C110 is_a_proper_prefix_of C109 by L470 , L462 , XBOOLE_0:def 8;
thus L472: contradiction by L471 , L461 , TREES_1:def 5;
end;
L473: C105 = C107 by L459 , L447 , L455 , L456;
thus L474: thesis by L473 , L455 , L458 , FINSEQ_1:33;
end;
uniqueness
proof
let C114 , C115 being DecoratedTree;
assume that
L475: (for R7 being FinSequence holds (R7 in ( dom C114 ) iff (R7 in ( dom C95 ) or (ex B54 being (Node of C95) st (ex B55 being (Node of C96) st (B54 in ( Leaves ( dom C95 ) ) & ( C95 . B54 ) = C97 & R7 = ( B54 ^ B55 )))))))
and
L476: (for B56 being (Node of C95) holds (((not B56 in ( Leaves ( dom C95 ) )) or ( C95 . B56 ) <> C97) implies ( C114 . B56 ) = ( C95 . B56 )))
and
L477: (for B57 being (Node of C95) holds (for B58 being (Node of C96) holds ((B57 in ( Leaves ( dom C95 ) ) & ( C95 . B57 ) = C97) implies ( C114 . ( B57 ^ B58 ) ) = ( C96 . B58 ))))
and
L478: (for R7 being FinSequence holds (R7 in ( dom C115 ) iff (R7 in ( dom C95 ) or (ex B59 being (Node of C95) st (ex B60 being (Node of C96) st (B59 in ( Leaves ( dom C95 ) ) & ( C95 . B59 ) = C97 & R7 = ( B59 ^ B60 )))))))
and
L479: (for B61 being (Node of C95) holds (((not B61 in ( Leaves ( dom C95 ) )) or ( C95 . B61 ) <> C97) implies ( C115 . B61 ) = ( C95 . B61 )))
and
L480: (for B62 being (Node of C95) holds (for B63 being (Node of C96) holds ((B62 in ( Leaves ( dom C95 ) ) & ( C95 . B62 ) = C97) implies ( C115 . ( B62 ^ B63 ) ) = ( C96 . B63 ))));
L481: ( dom C114 ) = ( dom C115 )
proof
let C116 being (FinSequence of ( NAT ));
L482: (C116 in ( dom C114 ) iff (C116 in ( dom C95 ) or (ex B64 being (Node of C95) st (ex B65 being (Node of C96) st (B64 in ( Leaves ( dom C95 ) ) & ( C95 . B64 ) = C97 & C116 = ( B64 ^ B65 )))))) by L475;
thus L483: thesis by L482 , L478;
end;
reconsider D63 = ( {} ) as (Node of C96) by TREES_1:22;
L484:
now
let R2 being set;
assume L485: R2 in ( dom C114 );
reconsider D64 = R2 as (Node of C114) by L485;
per cases  by L475;
suppose L486: D64 in ( dom C95 );

reconsider D65 = D64 as (Node of C95) by L486;
thus L487:now
per cases ;
suppose L488: (D65 in ( Leaves ( dom C95 ) ) & ( C95 . D65 ) = C97);

L489: ( C114 . ( D65 ^ D63 ) ) = ( C96 . D63 ) by L488 , L477;
L490: ( D65 ^ D63 ) = D65 by FINSEQ_1:34;
thus L491: ( C114 . R2 ) = ( C115 . R2 ) by L490 , L480 , L488 , L489;
end;
suppose L492: ((not D65 in ( Leaves ( dom C95 ) )) or ( C95 . D65 ) <> C97);

L493: ( C114 . D65 ) = ( C95 . D65 ) by L492 , L476;
thus L494: ( C114 . R2 ) = ( C115 . R2 ) by L493 , L479 , L492;
end;
end;
end;
suppose L488: (ex B66 being (Node of C95) st (ex B67 being (Node of C96) st (B66 in ( Leaves ( dom C95 ) ) & ( C95 . B66 ) = C97 & D64 = ( B66 ^ B67 ))));

consider C117 being (Node of C95), C118 being (Node of C96) such that L489: (C117 in ( Leaves ( dom C95 ) ) & ( C95 . C117 ) = C97 & D64 = ( C117 ^ C118 )) by L488;
thus L490: ( C114 . R2 ) = ( C96 . C118 ) by L477 , L489
.= ( C115 . R2 ) by L480 , L489;
end;
end;
thus L492: thesis by L484 , L481 , FUNCT_1:2;
end;
end;
registration
let C119 being non  empty set;
let C120 , C121 being (DecoratedTree of C119);
let C122 being set;
cluster ( (C120 , C122) <- C121 ) -> C119 -valued;
coherence
proof
L494: ( rng ( (C120 , C122) <- C121 ) ) c= C119
proof
let C123 being set;
assume L495: C123 in ( rng ( (C120 , C122) <- C121 ) );
consider C124 being set such that L496: C124 in ( dom ( (C120 , C122) <- C121 ) ) and L497: C123 = ( ( (C120 , C122) <- C121 ) . C124 ) by L495 , FUNCT_1:def 3;
reconsider D66 = C124 as (Node of ( (C120 , C122) <- C121 )) by L496;
reconsider D67 = ( {} ) as (Node of C121) by TREES_1:22;
per cases  by L421;
suppose L498: D66 in ( dom C120 );

reconsider D68 = D66 as (Node of C120) by L498;
thus L499:now
per cases ;
suppose L500: (D68 in ( Leaves ( dom C120 ) ) & ( C120 . D68 ) = C122);

L501: ( ( (C120 , C122) <- C121 ) . ( D68 ^ D67 ) ) = ( C121 . D67 ) by L500 , L421;
L502: ( D68 ^ D67 ) = D68 by FINSEQ_1:34;
thus L503: thesis by L502 , L497 , L501;
end;
suppose L504: ((not D68 in ( Leaves ( dom C120 ) )) or ( C120 . D68 ) <> C122);

L505: ( ( (C120 , C122) <- C121 ) . D68 ) = ( C120 . D68 ) by L504 , L421;
thus L506: thesis by L505 , L497;
end;
end;
end;
suppose L500: (ex B68 being (Node of C120) st (ex B69 being (Node of C121) st (B68 in ( Leaves ( dom C120 ) ) & ( C120 . B68 ) = C122 & D66 = ( B68 ^ B69 ))));

consider C125 being (Node of C120), C126 being (Node of C121) such that L501: (C125 in ( Leaves ( dom C120 ) ) & ( C120 . C125 ) = C122 & D66 = ( C125 ^ C126 )) by L500;
L502: ( ( (C120 , C122) <- C121 ) . D66 ) = ( C121 . C126 ) by L501 , L421;
thus L503: thesis by L502 , L497;
end;
end;
thus L505: thesis by L494 , RELAT_1:def 19;
end;
end;
theorem
L507: (for R11 being DecoratedTree holds (for R12 being DecoratedTree holds (for R13 being set holds (((not R13 in ( rng R11 )) or (not R13 in ( Leaves R11 ))) implies ( (R11 , R13) <- R12 ) = R11))))
proof
let R11 being DecoratedTree;
let R12 being DecoratedTree;
let R13 being set;
L508: ( Leaves R11 ) c= ( rng R11 ) by RELAT_1:111;
assume L509: ((not R13 in ( rng R11 )) or (not R13 in ( Leaves R11 )));
L510: (not R13 in ( Leaves R11 )) by L509 , L508;
thus L511: ( dom ( (R11 , R13) <- R12 ) ) = ( dom R11 )
proof
let C127 being (FinSequence of ( NAT ));
L512: (C127 in ( dom ( (R11 , R13) <- R12 ) ) iff (C127 in ( dom R11 ) or (ex B70 being (Node of R11) st (ex B71 being (Node of R12) st (B70 in ( Leaves ( dom R11 ) ) & ( R11 . B70 ) = R13 & C127 = ( B70 ^ B71 )))))) by L421;
thus L513: thesis by L512 , L510 , FUNCT_1:def 6;
end;

let C128 being (Node of ( (R11 , R13) <- R12 ));
reconsider D69 = C128 as (Node of R11) by L511;
L514: (D69 in ( Leaves ( dom R11 ) ) implies ( R11 . D69 ) in ( Leaves R11 )) by FUNCT_1:def 6;
thus L515: thesis by L514 , L510 , L421;
end;
begin
theorem
L516: (for R15 being non  empty set holds (for R16 being non  empty set holds (for R17 being (DecoratedTree of R15 , R16) holds (( dom ( R17 `1 ) ) = ( dom R17 ) & ( dom ( R17 `2 ) ) = ( dom R17 )))))
proof
let R15 being non  empty set;
let R16 being non  empty set;
let R17 being (DecoratedTree of R15 , R16);
L517: (( R17 `1 ) = ( ( pr1 (R15 , R16) ) * R17 ) & ( R17 `2 ) = ( ( pr2 (R15 , R16) ) * R17 )) by TREES_3:def 12 , TREES_3:def 13;
L518: (( rng R17 ) c= [: R15 , R16 :] & ( dom ( pr1 (R15 , R16) ) ) = [: R15 , R16 :]) by FUNCT_2:def 1 , RELAT_1:def 19;
L519: ( dom ( pr2 (R15 , R16) ) ) = [: R15 , R16 :] by FUNCT_2:def 1;
thus L520: thesis by L519 , L517 , L518 , RELAT_1:27;
end;
theorem
L521: (for R15 being non  empty set holds (for R16 being non  empty set holds (for R18 being (Element of R15) holds (for R19 being (Element of R16) holds (( ( root-tree [ R18 , R19 ] ) `1 ) = ( root-tree R18 ) & ( ( root-tree [ R18 , R19 ] ) `2 ) = ( root-tree R19 ))))))
proof
let R15 being non  empty set;
let R16 being non  empty set;
let R18 being (Element of R15);
let R19 being (Element of R16);
reconsider D70 = ( {} ) as (Node of ( root-tree [ R18 , R19 ] )) by TREES_1:22;
L522: ( dom ( ( root-tree [ R18 , R19 ] ) `1 ) ) = ( dom ( root-tree [ R18 , R19 ] ) ) by L516;
L523: ( dom ( ( root-tree [ R18 , R19 ] ) `2 ) ) = ( dom ( root-tree [ R18 , R19 ] ) ) by L516;
L524: ( ( root-tree [ R18 , R19 ] ) . D70 ) = [ R18 , R19 ] by L37;
L525: ( [ R18 , R19 ] `1 ) = R18 by MCART_1:7;
L526: ( [ R18 , R19 ] `2 ) = R19 by MCART_1:7;
thus L527: ( ( root-tree [ R18 , R19 ] ) `1 ) = ( root-tree ( ( ( root-tree [ R18 , R19 ] ) `1 ) . D70 ) ) by L522 , L37 , L43
.= ( root-tree R18 ) by L524 , L525 , TREES_3:39;
thus L528: ( ( root-tree [ R18 , R19 ] ) `2 ) = ( root-tree ( ( ( root-tree [ R18 , R19 ] ) `2 ) . D70 ) ) by L523 , L37 , L43
.= ( root-tree R19 ) by L524 , L526 , TREES_3:39;
end;
theorem
L529: (for R13 being set holds (for R14 being set holds <: ( root-tree R13 ) , ( root-tree R14 ) :> = ( root-tree [ R13 , R14 ] )))
proof
let R13 being set;
let R14 being set;
reconsider D71 = R13 as (Element of { R13 }) by TARSKI:def 1;
reconsider D72 = R14 as (Element of { R14 }) by TARSKI:def 1;
L530: (( ( root-tree [ D71 , D72 ] ) `1 ) = ( root-tree R13 ) & ( ( root-tree [ D71 , D72 ] ) `2 ) = ( root-tree R14 )) by L521;
thus L531: thesis by L530 , TREES_3:40;
end;
theorem
L532: (for R15 being non  empty set holds (for R16 being non  empty set holds (for R18 being (Element of R15) holds (for R19 being (Element of R16) holds (for R20 being non  empty (DTree-set of R15 , R16) holds (for R21 being non  empty (DTree-set of R15) holds (for B72 being (FinSequence of R20) holds (for B73 being (FinSequence of R21) holds ((( dom B73 ) = ( dom B72 ) & (for R4 being (Element of ( NAT )) holds (R4 in ( dom B72 ) implies (for R17 being (DecoratedTree of R15 , R16) holds (R17 = ( B72 . R4 ) implies ( B73 . R4 ) = ( R17 `1 )))))) implies ( ( [ R18 , R19 ] -tree B72 ) `1 ) = ( R18 -tree B73 ))))))))))
proof
let R15 being non  empty set;
let R16 being non  empty set;
let R18 being (Element of R15);
let R19 being (Element of R16);
let R20 being non  empty (DTree-set of R15 , R16);
let R21 being non  empty (DTree-set of R15);
let C129 being (FinSequence of R20);
let C130 being (FinSequence of R21);
assume that
L533: ( dom C130 ) = ( dom C129 )
and
L534: (for R4 being (Element of ( NAT )) holds (R4 in ( dom C129 ) implies (for R17 being (DecoratedTree of R15 , R16) holds (R17 = ( C129 . R4 ) implies ( C130 . R4 ) = ( R17 `1 )))));
set D73 = ( [ R18 , R19 ] -tree C129 );
set D74 = ( R18 -tree C130 );
L535: ( len ( doms C129 ) ) = ( len C129 ) by TREES_3:38;
L536: ( len ( doms C130 ) ) = ( len C130 ) by TREES_3:38;
L537: ( len C129 ) = ( len C130 ) by L533 , FINSEQ_3:29;
L538: ( dom ( doms C129 ) ) = ( dom ( doms C130 ) ) by L537 , L535 , L536 , FINSEQ_3:29;
L539: ( dom ( doms C129 ) ) = ( dom C129 ) by L535 , FINSEQ_3:29;
L540:
now
let C131 being Nat;
assume L541: C131 in ( dom C129 );
reconsider D75 = ( C129 . C131 ) as (Element of R20) by L541 , L2;
L542: ( C130 . C131 ) = ( D75 `1 ) by L534 , L541;
L543: ( ( doms C129 ) . C131 ) = ( dom D75 ) by L541 , FUNCT_6:22;
L544: ( ( doms C130 ) . C131 ) = ( dom ( D75 `1 ) ) by L533 , L541 , L542 , FUNCT_6:22;
thus L545: ( ( doms C129 ) . C131 ) = ( ( doms C130 ) . C131 ) by L544 , L543 , L516;
end;
L546: ( doms C129 ) = ( doms C130 ) by L540 , L538 , L539 , FINSEQ_1:13;
L547: ( dom ( D73 `1 ) ) = ( dom D73 ) by L516
.= ( tree ( doms C129 ) ) by L166;
thus L548: ( dom ( D73 `1 ) ) = ( dom D74 ) by L547 , L546 , L166;
let C132 being (Node of ( D73 `1 ));
reconsider D76 = C132 as (Node of D73) by L516;
L549: ( ( D73 `1 ) . C132 ) = ( ( D73 . D76 ) `1 ) by TREES_3:39;
per cases ;
suppose L550: C132 = ( {} );

L551: (( D73 . C132 ) = [ R18 , R19 ] & ( D74 . C132 ) = R18) by L550 , L113;
thus L552: thesis by L551 , L549 , MCART_1:7;
end;
suppose L553: C132 <> ( {} );

consider C133 being (Element of ( NAT )), C134 being DecoratedTree, C135 being (Node of C134) such that L554: C133 < ( len C129 ) and L555: C134 = ( C129 . ( C133 + 1 ) ) and L556: D76 = ( <* C133 *> ^ C135 ) by L553 , L169;
reconsider D77 = C134 as (Element of R20) by L554 , L555 , L28;
reconsider D78 = C135 as (Node of ( D77 `1 )) by L516;
L557: ( C130 . ( C133 + 1 ) ) = ( D77 `1 ) by L534 , L554 , L555 , L21;
L558: ( D73 . D76 ) = ( D77 . D78 ) by L554 , L555 , L556 , L186;
L559: ( D74 . D76 ) = ( ( D77 `1 ) . D78 ) by L537 , L554 , L556 , L557 , L186;
thus L560: thesis by L559 , L549 , L558 , TREES_3:39;
end;
end;
theorem
L562: (for R15 being non  empty set holds (for R16 being non  empty set holds (for R18 being (Element of R15) holds (for R19 being (Element of R16) holds (for R20 being non  empty (DTree-set of R15 , R16) holds (for R22 being non  empty (DTree-set of R16) holds (for B74 being (FinSequence of R20) holds (for B75 being (FinSequence of R22) holds ((( dom B75 ) = ( dom B74 ) & (for R4 being (Element of ( NAT )) holds (R4 in ( dom B74 ) implies (for R17 being (DecoratedTree of R15 , R16) holds (R17 = ( B74 . R4 ) implies ( B75 . R4 ) = ( R17 `2 )))))) implies ( ( [ R18 , R19 ] -tree B74 ) `2 ) = ( R19 -tree B75 ))))))))))
proof
let R15 being non  empty set;
let R16 being non  empty set;
let R18 being (Element of R15);
let R19 being (Element of R16);
let R20 being non  empty (DTree-set of R15 , R16);
let R22 being non  empty (DTree-set of R16);
let C136 being (FinSequence of R20);
let C137 being (FinSequence of R22);
assume that
L563: ( dom C137 ) = ( dom C136 )
and
L564: (for R4 being (Element of ( NAT )) holds (R4 in ( dom C136 ) implies (for R17 being (DecoratedTree of R15 , R16) holds (R17 = ( C136 . R4 ) implies ( C137 . R4 ) = ( R17 `2 )))));
set D79 = ( [ R18 , R19 ] -tree C136 );
set D80 = ( R19 -tree C137 );
L565: ( len ( doms C136 ) ) = ( len C136 ) by TREES_3:38;
L566: ( len ( doms C137 ) ) = ( len C137 ) by TREES_3:38;
L567: ( len C136 ) = ( len C137 ) by L563 , FINSEQ_3:29;
L568: ( dom ( doms C136 ) ) = ( dom ( doms C137 ) ) by L567 , L565 , L566 , FINSEQ_3:29;
L569: ( dom ( doms C136 ) ) = ( dom C136 ) by L565 , FINSEQ_3:29;
L570:
now
let C138 being Nat;
assume L571: C138 in ( dom C136 );
reconsider D81 = ( C136 . C138 ) as (Element of R20) by L571 , L2;
L572: ( C137 . C138 ) = ( D81 `2 ) by L564 , L571;
L573: ( ( doms C136 ) . C138 ) = ( dom D81 ) by L571 , FUNCT_6:22;
L574: ( ( doms C137 ) . C138 ) = ( dom ( D81 `2 ) ) by L563 , L571 , L572 , FUNCT_6:22;
thus L575: ( ( doms C136 ) . C138 ) = ( ( doms C137 ) . C138 ) by L574 , L573 , L516;
end;
L576: ( doms C136 ) = ( doms C137 ) by L570 , L568 , L569 , FINSEQ_1:13;
L577: ( dom ( D79 `2 ) ) = ( dom D79 ) by L516
.= ( tree ( doms C136 ) ) by L166;
thus L578: ( dom ( D79 `2 ) ) = ( dom D80 ) by L577 , L576 , L166;
let C139 being (Node of ( D79 `2 ));
reconsider D82 = C139 as (Node of D79) by L516;
L579: ( ( D79 `2 ) . C139 ) = ( ( D79 . D82 ) `2 ) by TREES_3:39;
per cases ;
suppose L580: C139 = ( {} );

L581: (( D79 . C139 ) = [ R18 , R19 ] & ( D80 . C139 ) = R19) by L580 , L113;
thus L582: thesis by L581 , L579 , MCART_1:7;
end;
suppose L583: C139 <> ( {} );

consider C140 being (Element of ( NAT )), C141 being DecoratedTree, C142 being (Node of C141) such that L584: C140 < ( len C136 ) and L585: C141 = ( C136 . ( C140 + 1 ) ) and L586: D82 = ( <* C140 *> ^ C142 ) by L583 , L169;
reconsider D83 = C141 as (Element of R20) by L584 , L585 , L28;
reconsider D84 = C142 as (Node of ( D83 `2 )) by L516;
L587: ( C137 . ( C140 + 1 ) ) = ( D83 `2 ) by L564 , L584 , L585 , L21;
L588: ( D79 . D82 ) = ( D83 . D84 ) by L584 , L585 , L586 , L186;
L589: ( D80 . D82 ) = ( ( D83 `2 ) . D84 ) by L567 , L584 , L586 , L587 , L186;
thus L590: thesis by L589 , L579 , L588 , TREES_3:39;
end;
end;
theorem
L592: (for R15 being non  empty set holds (for R16 being non  empty set holds (for R18 being (Element of R15) holds (for R19 being (Element of R16) holds (for R20 being non  empty (DTree-set of R15 , R16) holds (for B76 being (FinSequence of R20) holds (ex B77 being (FinSequence of ( Trees R15 )) st (( dom B77 ) = ( dom B76 ) & (for R4 being (Element of ( NAT )) holds (R4 in ( dom B76 ) implies (ex B78 being (Element of R20) st (B78 = ( B76 . R4 ) & ( B77 . R4 ) = ( B78 `1 ))))) & ( ( [ R18 , R19 ] -tree B76 ) `1 ) = ( R18 -tree B77 )))))))))
proof
let R15 being non  empty set;
let R16 being non  empty set;
let R18 being (Element of R15);
let R19 being (Element of R16);
let R20 being non  empty (DTree-set of R15 , R16);
let C143 being (FinSequence of R20);
L593: ( Seg ( len C143 ) ) = ( dom C143 ) by FINSEQ_1:def 3;
defpred S6[ set , set ] means (ex B79 being (Element of R20) st (B79 = ( C143 . $1 ) & $2 = ( B79 `1 )));
L594: (for B80 being Nat holds (B80 in ( Seg ( len C143 ) ) implies (ex B81 being (Element of ( Trees R15 )) st S6[ B80 , B81 ])))
proof
let C144 being Nat;
assume L595: C144 in ( Seg ( len C143 ) );
reconsider D85 = ( C143 . C144 ) as (Element of R20) by L595 , L593 , L2;
reconsider D86 = ( D85 `1 ) as (Element of ( Trees R15 )) by TREES_3:def 7;
take D86;
take D85;
thus L596: thesis;
end;
consider C145 being (FinSequence of ( Trees R15 )) such that L597: (( dom C145 ) = ( Seg ( len C143 ) ) & (for B82 being Nat holds (B82 in ( Seg ( len C143 ) ) implies S6[ B82 , ( C145 . B82 ) ]))) from FINSEQ_1:sch 5(L594);
take C145;
thus L598: ( dom C145 ) = ( dom C143 ) by L597 , FINSEQ_1:def 3;
thus L599: (for R4 being (Element of ( NAT )) holds (R4 in ( dom C143 ) implies (ex B83 being (Element of R20) st (B83 = ( C143 . R4 ) & ( C145 . R4 ) = ( B83 `1 ))))) by L598 , L597;
L600:
now
let R4 being (Element of ( NAT ));
assume L601: R4 in ( dom C143 );
L602: (ex B84 being (Element of R20) st (B84 = ( C143 . R4 ) & ( C145 . R4 ) = ( B84 `1 ))) by L601 , L597 , L598;
thus L603: (for R17 being (DecoratedTree of R15 , R16) holds (R17 = ( C143 . R4 ) implies ( C145 . R4 ) = ( R17 `1 ))) by L602;
end;
thus L604: thesis by L600 , L598 , L532;
end;
theorem
L605: (for R15 being non  empty set holds (for R16 being non  empty set holds (for R18 being (Element of R15) holds (for R19 being (Element of R16) holds (for R20 being non  empty (DTree-set of R15 , R16) holds (for B85 being (FinSequence of R20) holds (ex B86 being (FinSequence of ( Trees R16 )) st (( dom B86 ) = ( dom B85 ) & (for R4 being (Element of ( NAT )) holds (R4 in ( dom B85 ) implies (ex B87 being (Element of R20) st (B87 = ( B85 . R4 ) & ( B86 . R4 ) = ( B87 `2 ))))) & ( ( [ R18 , R19 ] -tree B85 ) `2 ) = ( R19 -tree B86 )))))))))
proof
let R15 being non  empty set;
let R16 being non  empty set;
let R18 being (Element of R15);
let R19 being (Element of R16);
let R20 being non  empty (DTree-set of R15 , R16);
let C146 being (FinSequence of R20);
L606: ( Seg ( len C146 ) ) = ( dom C146 ) by FINSEQ_1:def 3;
defpred S7[ Nat , set ] means (ex B88 being (Element of R20) st (B88 = ( C146 . $1 ) & $2 = ( B88 `2 )));
L607: (for B89 being Nat holds (B89 in ( Seg ( len C146 ) ) implies (ex B90 being (Element of ( Trees R16 )) st S7[ B89 , B90 ])))
proof
let C147 being Nat;
assume L608: C147 in ( Seg ( len C146 ) );
reconsider D87 = ( C146 . C147 ) as (Element of R20) by L608 , L606 , L2;
reconsider D88 = ( D87 `2 ) as (Element of ( Trees R16 )) by TREES_3:def 7;
take D88;
take D87;
thus L609: thesis;
end;
consider C148 being (FinSequence of ( Trees R16 )) such that L610: (( dom C148 ) = ( Seg ( len C146 ) ) & (for B91 being Nat holds (B91 in ( Seg ( len C146 ) ) implies S7[ B91 , ( C148 . B91 ) ]))) from FINSEQ_1:sch 5(L607);
take C148;
thus L611: ( dom C148 ) = ( dom C146 ) by L610 , FINSEQ_1:def 3;
thus L612: (for R4 being (Element of ( NAT )) holds (R4 in ( dom C146 ) implies (ex B92 being (Element of R20) st (B92 = ( C146 . R4 ) & ( C148 . R4 ) = ( B92 `2 ))))) by L611 , L610;
L613:
now
let R4 being (Element of ( NAT ));
assume L614: R4 in ( dom C146 );
L615: (ex B93 being (Element of R20) st (B93 = ( C146 . R4 ) & ( C148 . R4 ) = ( B93 `2 ))) by L614 , L610 , L611;
thus L616: (for R17 being (DecoratedTree of R15 , R16) holds (R17 = ( C146 . R4 ) implies ( C148 . R4 ) = ( R17 `2 ))) by L615;
end;
thus L617: thesis by L613 , L611 , L562;
end;
theorem
L618: (for R15 being non  empty set holds (for R16 being non  empty set holds (for R18 being (Element of R15) holds (for R19 being (Element of R16) holds (for B94 being (FinSequence of ( FinTrees [: R15 , R16 :] )) holds (ex B95 being (FinSequence of ( FinTrees R15 )) st (( dom B95 ) = ( dom B94 ) & (for R4 being (Element of ( NAT )) holds (R4 in ( dom B94 ) implies (ex B96 being (Element of ( FinTrees [: R15 , R16 :] )) st (B96 = ( B94 . R4 ) & ( B95 . R4 ) = ( B96 `1 ))))) & ( ( [ R18 , R19 ] -tree B94 ) `1 ) = ( R18 -tree B95 ))))))))
proof
let R15 being non  empty set;
let R16 being non  empty set;
let R18 being (Element of R15);
let R19 being (Element of R16);
let C149 being (FinSequence of ( FinTrees [: R15 , R16 :] ));
consider C150 being (FinSequence of ( Trees R15 )) such that L619: (( dom C150 ) = ( dom C149 ) & (for R4 being (Element of ( NAT )) holds (R4 in ( dom C149 ) implies (ex B97 being (Element of ( FinTrees [: R15 , R16 :] )) st (B97 = ( C149 . R4 ) & ( C150 . R4 ) = ( B97 `1 )))))) and L620: ( ( [ R18 , R19 ] -tree C149 ) `1 ) = ( R18 -tree C150 ) by L592;
L621: ( rng C150 ) c= ( FinTrees R15 )
proof
let R13 being set;
assume L622: R13 in ( rng C150 );
consider R14 being set such that L623: R14 in ( dom C150 ) and L624: R13 = ( C150 . R14 ) by L622 , FUNCT_1:def 3;
reconsider D89 = R14 as (Element of ( NAT )) by L623;
consider C151 being (Element of ( FinTrees [: R15 , R16 :] )) such that L625: C151 = ( C149 . D89 ) and L626: ( C150 . D89 ) = ( C151 `1 ) by L619 , L623;
L627: ( dom ( C151 `1 ) ) = ( dom C151 ) by L516;
thus L628: thesis by L627 , L624 , L626 , TREES_3:def 8;
end;
L629: C150 is (FinSequence of ( FinTrees R15 )) by L621 , FINSEQ_1:def 4;
thus L630: thesis by L629 , L619 , L620;
end;
theorem
L631: (for R15 being non  empty set holds (for R16 being non  empty set holds (for R18 being (Element of R15) holds (for R19 being (Element of R16) holds (for B98 being (FinSequence of ( FinTrees [: R15 , R16 :] )) holds (ex B99 being (FinSequence of ( FinTrees R16 )) st (( dom B99 ) = ( dom B98 ) & (for R4 being (Element of ( NAT )) holds (R4 in ( dom B98 ) implies (ex B100 being (Element of ( FinTrees [: R15 , R16 :] )) st (B100 = ( B98 . R4 ) & ( B99 . R4 ) = ( B100 `2 ))))) & ( ( [ R18 , R19 ] -tree B98 ) `2 ) = ( R19 -tree B99 ))))))))
proof
let R15 being non  empty set;
let R16 being non  empty set;
let R18 being (Element of R15);
let R19 being (Element of R16);
let C152 being (FinSequence of ( FinTrees [: R15 , R16 :] ));
consider C153 being (FinSequence of ( Trees R16 )) such that L632: (( dom C153 ) = ( dom C152 ) & (for R4 being (Element of ( NAT )) holds (R4 in ( dom C152 ) implies (ex B101 being (Element of ( FinTrees [: R15 , R16 :] )) st (B101 = ( C152 . R4 ) & ( C153 . R4 ) = ( B101 `2 )))))) and L633: ( ( [ R18 , R19 ] -tree C152 ) `2 ) = ( R19 -tree C153 ) by L605;
L634: ( rng C153 ) c= ( FinTrees R16 )
proof
let R13 being set;
assume L635: R13 in ( rng C153 );
consider R14 being set such that L636: R14 in ( dom C153 ) and L637: R13 = ( C153 . R14 ) by L635 , FUNCT_1:def 3;
reconsider D90 = R14 as (Element of ( NAT )) by L636;
consider C154 being (Element of ( FinTrees [: R15 , R16 :] )) such that L638: C154 = ( C152 . D90 ) and L639: ( C153 . D90 ) = ( C154 `2 ) by L632 , L636;
L640: ( dom ( C154 `2 ) ) = ( dom C154 ) by L516;
thus L641: thesis by L640 , L637 , L639 , TREES_3:def 8;
end;
L642: C153 is (FinSequence of ( FinTrees R16 )) by L634 , FINSEQ_1:def 4;
thus L643: thesis by L642 , L632 , L633;
end;
