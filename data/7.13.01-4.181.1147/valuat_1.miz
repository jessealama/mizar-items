:: Interpretation and Satisfiability in the First Order Logic
::  by Edmund Woronowicz
::
:: Received June 1, 1990
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies SUBSET_1, NUMBERS, XBOOLE_0, FUNCT_2, QC_LANG1, FUNCT_1, RELAT_1,
      TARSKI, MARGREL1, XBOOLEAN, CQC_LANG, ARYTM_3, FINSEQ_1, NAT_1, XXREAL_0,
      ZF_LANG, FUNCOP_1, REALSET1, BVFUNC_2, ZF_MODEL, ZF_LANG1, QC_LANG3,
      CARD_1, CLASSES2, VALUAT_1, ORDINAL1, FUNCT_7;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, RELAT_1, FUNCT_1, FUNCT_2,
      FUNCT_7, ORDINAL1, NAT_1,
      FINSEQ_1, QC_LANG1, QC_LANG3, CQC_LANG, MARGREL1, XXREAL_0;
 constructors XXREAL_0, MEMBERED, MARGREL1, QC_LANG3, CQC_LANG, RELSET_1,
      FUNCT_7;
 registrations XBOOLE_0, FUNCT_1, RELSET_1, MEMBERED, MARGREL1, QC_LANG1,
      CQC_LANG, XXREAL_0, FUNCT_2, CARD_1;
 requirements NUMERALS, SUBSET, BOOLE;
 definitions XBOOLEAN;
 theorems TARSKI, FINSEQ_1, FUNCT_1, FUNCT_2, FUNCOP_1, QC_LANG1, QC_LANG2,
      QC_LANG3, CQC_LANG, MARGREL1, RELSET_1, RELAT_1, FINSEQ_3, XBOOLE_0,
      XBOOLE_1, XBOOLEAN, ORDINAL1, CARD_1, FUNCT_7;
 schemes QC_LANG1, CQC_LANG, FUNCT_2;

begin
definition
let R1 being QC-alphabet;
let C1 being set;
func Valuations_in (R1 , C1) -> set equals 
( Funcs (( bound_QC-variables R1 ) , C1) );
coherence;
end;
registration
let R1 being QC-alphabet;
let R5 being non  empty set;
cluster ( Valuations_in (R1 , R5) ) -> non  empty  functional;
coherence;
end;
theorem
L3: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for B1 being set holds (B1 is (Element of ( Valuations_in (R1 , R5) )) implies B1 is (Function of ( bound_QC-variables R1 ) , R5)))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let C2 being set;
assume L4: C2 is (Element of ( Valuations_in (R1 , R5) ));
L5: (ex B2 being Function st (C2 = B2 & ( dom B2 ) = ( bound_QC-variables R1 ) & ( rng B2 ) c= R5)) by L4 , FUNCT_2:def 2;
thus L6: thesis by L5 , FUNCT_2:def 1 , RELSET_1:4;
end;
definition
let R1 being QC-alphabet;
let R5 being non  empty set;
redefine func Valuations_in (R1 , R5) -> (FUNCTION_DOMAIN of ( bound_QC-variables R1 ) , R5);

coherence
proof
L7: (for B3 being (Element of ( Valuations_in (R1 , R5) )) holds B3 is (Function of ( bound_QC-variables R1 ) , R5)) by L3;
thus L8: thesis by L7 , FUNCT_2:def 12;
end;
end;
definition
let R1 being QC-alphabet;
let R5 being non  empty set;
let R9 being (bound_QC-variable of R1);
let C3 being (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) ));
func FOR_ALL (R9 , C3) -> (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) )) means 
:L10: (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds ( it . R12 ) = ( ALL { ( C3 . B4 ) where B4 is (Element of ( Valuations_in (R1 , R5) )) : (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( B4 . R11 ) = ( R12 . R11 ))) } ));
existence
proof
deffunc H1(Function) = ( ALL { ( C3 . B5 ) where B5 is (Element of ( Valuations_in (R1 , R5) )) : (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( B5 . R11 ) = ( $1 . R11 ))) } );
consider C4 being (Function of ( Valuations_in (R1 , R5) ) , ( BOOLEAN )) such that L11: (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds ( C4 . R12 ) = H1(R12)) from FUNCT_2:sch 4;
L12: (( dom C4 ) = ( Valuations_in (R1 , R5) ) & ( rng C4 ) c= ( BOOLEAN )) by FUNCT_2:def 1 , RELAT_1:def 19;
reconsider D1 = C4 as (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) )) by L12 , FUNCT_2:def 2;
take D1;
thus L13: thesis by L11;
end;
uniqueness
proof
let R7 being (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) ));
let R8 being (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) ));
assume that
L14: (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds ( R7 . R12 ) = ( ALL { ( C3 . B6 ) where B6 is (Element of ( Valuations_in (R1 , R5) )) : (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( B6 . R11 ) = ( R12 . R11 ))) } ))
and
L15: (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds ( R8 . R12 ) = ( ALL { ( C3 . B7 ) where B7 is (Element of ( Valuations_in (R1 , R5) )) : (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( B7 . R11 ) = ( R12 . R11 ))) } ));
L16: (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds ( R7 . R12 ) = ( R8 . R12 ))
proof
let R12 being (Element of ( Valuations_in (R1 , R5) ));
L17: ( R7 . R12 ) = ( ALL { ( C3 . B8 ) where B8 is (Element of ( Valuations_in (R1 , R5) )) : (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( B8 . R11 ) = ( R12 . R11 ))) } ) by L14;
thus L18: thesis by L17 , L15;
end;
thus L19: thesis by L16 , FUNCT_2:63;
end;
end;
theorem
L21: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R9 being (bound_QC-variable of R1) holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for B9 being (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) )) holds (( ( FOR_ALL (R9 , B9) ) . R12 ) = ( FALSE ) iff (ex R13 being (Element of ( Valuations_in (R1 , R5) )) st (( B9 . R13 ) = ( FALSE ) & (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R13 . R11 ) = ( R12 . R11 )))))))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R9 being (bound_QC-variable of R1);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let C5 being (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) ));
L22:
now
assume L23: (ex R13 being (Element of ( Valuations_in (R1 , R5) )) st (( C5 . R13 ) = ( FALSE ) & (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R13 . R11 ) = ( R12 . R11 )))));
L24: ( FALSE ) in { ( C5 . B10 ) where B10 is (Element of ( Valuations_in (R1 , R5) )) : (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( B10 . R11 ) = ( R12 . R11 ))) } by L23;
L25: ( ALL { ( C5 . B11 ) where B11 is (Element of ( Valuations_in (R1 , R5) )) : (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( B11 . R11 ) = ( R12 . R11 ))) } ) = ( FALSE ) by L24 , MARGREL1:17;
thus L26: ( ( FOR_ALL (R9 , C5) ) . R12 ) = ( FALSE ) by L25 , L10;
end;
L27:
now
assume L28: ( ( FOR_ALL (R9 , C5) ) . R12 ) = ( FALSE );
L29: ( ALL { ( C5 . B12 ) where B12 is (Element of ( Valuations_in (R1 , R5) )) : (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( B12 . R11 ) = ( R12 . R11 ))) } ) = ( FALSE ) by L28 , L10;
L30: ( FALSE ) in { ( C5 . B13 ) where B13 is (Element of ( Valuations_in (R1 , R5) )) : (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( B13 . R11 ) = ( R12 . R11 ))) } by L29 , MARGREL1:17;
thus L31: (ex R13 being (Element of ( Valuations_in (R1 , R5) )) st (( C5 . R13 ) = ( FALSE ) & (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R13 . R11 ) = ( R12 . R11 ))))) by L30;
end;
thus L32: thesis by L27 , L22;
end;
theorem
L33: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R9 being (bound_QC-variable of R1) holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for B14 being (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) )) holds (( ( FOR_ALL (R9 , B14) ) . R12 ) = ( TRUE ) iff (for R13 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R13 . R11 ) = ( R12 . R11 ))) implies ( B14 . R13 ) = ( TRUE )))))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R9 being (bound_QC-variable of R1);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let C6 being (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) ));
L34:
now
assume L35: ( ( FOR_ALL (R9 , C6) ) . R12 ) = ( TRUE );
L36: ( ALL { ( C6 . B15 ) where B15 is (Element of ( Valuations_in (R1 , R5) )) : (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( B15 . R11 ) = ( R12 . R11 ))) } ) = ( TRUE ) by L35 , L10;
L37: (not ( FALSE ) in { ( C6 . B16 ) where B16 is (Element of ( Valuations_in (R1 , R5) )) : (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( B16 . R11 ) = ( R12 . R11 ))) }) by L36 , MARGREL1:17;
thus L38: (for R13 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R13 . R11 ) = ( R12 . R11 ))) implies ( C6 . R13 ) = ( TRUE )))
proof
let R13 being (Element of ( Valuations_in (R1 , R5) ));
assume L39: (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R13 . R11 ) = ( R12 . R11 )));
L40: (not ( C6 . R13 ) = ( FALSE )) by L39 , L37;
thus L41: thesis by L40 , XBOOLEAN:def 3;
end;

end;
L39:
now
assume L40: (for R13 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R13 . R11 ) = ( R12 . R11 ))) implies ( C6 . R13 ) = ( TRUE )));
L41: (not (ex R13 being (Element of ( Valuations_in (R1 , R5) )) st (( C6 . R13 ) = ( FALSE ) & (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R13 . R11 ) = ( R12 . R11 )))))) by L40;
L42: (not ( FALSE ) in { ( C6 . B17 ) where B17 is (Element of ( Valuations_in (R1 , R5) )) : (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( B17 . R11 ) = ( R12 . R11 ))) }) by L41;
L43: ( ALL { ( C6 . B18 ) where B18 is (Element of ( Valuations_in (R1 , R5) )) : (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( B18 . R11 ) = ( R12 . R11 ))) } ) = ( TRUE ) by L42 , MARGREL1:17;
thus L44: ( ( FOR_ALL (R9 , C6) ) . R12 ) = ( TRUE ) by L43 , L10;
end;
thus L45: thesis by L39 , L34;
end;
notation
let R1 being QC-alphabet;
let R5 being non  empty set;
let R4 being (Element of ( NAT ));
let R14 being (CQC-variable_list of R4 , R1);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
synonym R12 *' R14 for R12 * R14;
end;
definition
let R1 being QC-alphabet;
let R5 being non  empty set;
let R4 being (Element of ( NAT ));
let R14 being (CQC-variable_list of R4 , R1);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
redefine func R12 *' R14 -> (FinSequence of R5) means 
:L47: (( len it ) = R4 & (for B19 being  natural number holds ((1 <= B19 & B19 <= R4) implies ( it . B19 ) = ( R12 . ( R14 . B19 ) ))));
coherence
proof
L48: (( rng R12 ) c= R5 & ( rng ( R12 * R14 ) ) c= ( rng R12 )) by RELAT_1:26 , RELAT_1:def 19;
L49: ( rng ( R12 * R14 ) ) c= R5 by L48 , XBOOLE_1:1;
L50: ( len R14 ) = R4 by CARD_1:def 7;
L51: ( dom R12 ) = ( bound_QC-variables R1 ) by FUNCT_2:def 1;
L52: ( rng R14 ) c= ( dom R12 ) by L51 , RELAT_1:def 19;
L53: ( dom ( R12 * R14 ) ) = ( dom R14 ) by L52 , RELAT_1:27
.= ( Seg R4 ) by L50 , FINSEQ_1:def 3;
L54: ( R12 * R14 ) is  FinSequence-like by L53 , FINSEQ_1:def 2;
thus L55: thesis by L54 , L49 , FINSEQ_1:def 4;
end;
compatibility
proof
let C7 being (FinSequence of R5);
L56: ( len R14 ) = R4 by CARD_1:def 7;
L57: ( dom R12 ) = ( bound_QC-variables R1 ) by FUNCT_2:def 1;
L58: ( rng R14 ) c= ( dom R12 ) by L57 , RELAT_1:def 19;
thus L59: (C7 = ( R12 * R14 ) implies (( len C7 ) = R4 & (for B20 being  natural number holds ((1 <= B20 & B20 <= R4) implies ( C7 . B20 ) = ( R12 . ( R14 . B20 ) )))))
proof
assume L60: C7 = ( R12 * R14 );
L61: ( dom R14 ) = ( dom C7 ) by L60 , L58 , RELAT_1:27;
thus L62: ( len C7 ) = R4 by L61 , L56 , FINSEQ_3:29;
let C8 being  natural number;
assume L63: (1 <= C8 & C8 <= R4);
L64: C8 in ( dom C7 ) by L63 , L56 , L61 , FINSEQ_3:25;
thus L65: thesis by L64 , L60 , FUNCT_1:12;
end;

assume that
L66: ( len C7 ) = R4
and
L67: (for B21 being Nat holds ((1 <= B21 & B21 <= R4) implies ( C7 . B21 ) = ( R12 . ( R14 . B21 ) )));
L68: (for B22 being set holds (B22 in ( dom C7 ) iff (B22 in ( dom R14 ) & ( R14 . B22 ) in ( dom R12 ))))
proof
let C9 being set;
thus L69: (C9 in ( dom C7 ) implies (C9 in ( dom R14 ) & ( R14 . C9 ) in ( dom R12 )))
proof
assume L70: C9 in ( dom C7 );
thus L71: C9 in ( dom R14 ) by L70 , L56 , L66 , FINSEQ_3:29;
L72: ( R14 . C9 ) in ( rng R14 ) by L71 , FUNCT_1:def 3;
thus L73: thesis by L72 , L58;
end;

assume that
L74: C9 in ( dom R14 )
and
L75: ( R14 . C9 ) in ( dom R12 );
thus L76: thesis by L56 , L66 , L74 , FINSEQ_3:29;
end;
L77: (for B23 being set holds (B23 in ( dom C7 ) implies ( C7 . B23 ) = ( R12 . ( R14 . B23 ) )))
proof
let C10 being set;
assume L78: C10 in ( dom C7 );
reconsider D2 = C10 as (Element of ( NAT )) by L78;
L79: (1 <= D2 & D2 <= R4) by L66 , L78 , FINSEQ_3:25;
thus L80: thesis by L79 , L67;
end;
thus L81: thesis by L77 , L68 , FUNCT_1:10;
end;
end;
definition
let R1 being QC-alphabet;
let R5 being non  empty set;
let R4 being (Element of ( NAT ));
let R14 being (CQC-variable_list of R4 , R1);
let C11 being (Element of ( relations_on R5 ));
func R14 'in' C11 -> (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) )) means 
:L83: (for B24 being (Element of ( Valuations_in (R1 , R5) )) holds ((( B24 *' R14 ) in C11 iff ( it . B24 ) = ( TRUE )) & ((not ( B24 *' R14 ) in C11) iff ( it . B24 ) = ( FALSE ))));
existence
proof
defpred S1[ set ] means (ex B25 being (Element of ( Valuations_in (R1 , R5) )) st ($1 = B25 & ( B25 *' R14 ) in C11));
deffunc H2(set) = ( TRUE );
deffunc H3(set) = ( FALSE );
L84: (for B26 being set holds (B26 in ( Valuations_in (R1 , R5) ) implies ((S1[ B26 ] implies H2(B26) in ( BOOLEAN )) & ((not S1[ B26 ]) implies H3(B26) in ( BOOLEAN )))));
consider C12 being (Function of ( Valuations_in (R1 , R5) ) , ( BOOLEAN )) such that L85: (for B27 being set holds (B27 in ( Valuations_in (R1 , R5) ) implies ((S1[ B27 ] implies ( C12 . B27 ) = H2(B27)) & ((not S1[ B27 ]) implies ( C12 . B27 ) = H3(B27))))) from FUNCT_2:sch 5(L84);
L86: (( dom C12 ) = ( Valuations_in (R1 , R5) ) & ( rng C12 ) c= ( BOOLEAN )) by FUNCT_2:def 1 , RELAT_1:def 19;
reconsider D3 = C12 as (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) )) by L86 , FUNCT_2:def 2;
take D3;
let C13 being (Element of ( Valuations_in (R1 , R5) ));
L87: ((not (ex B28 being (Element of ( Valuations_in (R1 , R5) )) st (C13 = B28 & ( B28 *' R14 ) in C11))) implies ( D3 . C13 ) = ( FALSE )) by L85;
thus L88: thesis by L87 , L85;
end;
uniqueness
proof
let C14 , C15 being (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) ));
assume that
L89: (for B29 being (Element of ( Valuations_in (R1 , R5) )) holds ((( B29 *' R14 ) in C11 iff ( C14 . B29 ) = ( TRUE )) & ((not ( B29 *' R14 ) in C11) iff ( C14 . B29 ) = ( FALSE ))))
and
L90: (for B30 being (Element of ( Valuations_in (R1 , R5) )) holds ((( B30 *' R14 ) in C11 iff ( C15 . B30 ) = ( TRUE )) & ((not ( B30 *' R14 ) in C11) iff ( C15 . B30 ) = ( FALSE ))));
L91: (for B31 being (Element of ( Valuations_in (R1 , R5) )) holds ( C14 . B31 ) = ( C15 . B31 ))
proof
let C16 being (Element of ( Valuations_in (R1 , R5) ));
per cases ;
suppose L92: ( C16 *' R14 ) in C11;

L93: ( C14 . C16 ) = ( TRUE ) by L92 , L89;
thus L94: thesis by L93 , L90 , L92;
end;
suppose L95: (not ( C16 *' R14 ) in C11);

L96: ( C14 . C16 ) = ( FALSE ) by L95 , L89;
thus L97: thesis by L96 , L90 , L95;
end;
end;
thus L99: thesis by L91 , FUNCT_2:63;
end;
end;
definition
let R1 being QC-alphabet;
let R5 being non  empty set;
let C17 being (Function of ( CQC-WFF R1 ) , ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) ));
let C18 being (Element of ( CQC-WFF R1 ));
redefine func C17 . C18 -> (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) ));

coherence
proof
thus L101: ( C17 . C18 ) is (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) ));
end;
end;
definition
let R1 being QC-alphabet;
let R6 being non  empty set;
mode interpretation of R1 , R6
 -> (Function of ( QC-pred_symbols R1 ) , ( relations_on R6 ))
means (for B32 being (Element of ( QC-pred_symbols R1 )) holds (for B33 being (Element of ( relations_on R6 )) holds (( it . B32 ) = B33 implies (B33 = ( empty_rel R6 ) or ( the_arity_of B32 ) = ( the_arity_of B33 )))));
existence
proof
reconsider D4 = ( ( QC-pred_symbols R1 ) --> ( empty_rel R6 ) ) as (Function of ( QC-pred_symbols R1 ) , ( relations_on R6 ));
take D4;
let C19 being (Element of ( QC-pred_symbols R1 ));
thus L103: thesis by FUNCOP_1:7;
end;
end;
definition
let R1 being QC-alphabet;
let R5 being non  empty set;
let R4 being (Element of ( NAT ));
let R19 being (interpretation of R1 , R5);
let R20 being (QC-pred_symbol of R4 , R1);
redefine func R19 . R20 -> (Element of ( relations_on R5 ));

coherence by FUNCT_2:5;
end;
definition
let R1 being QC-alphabet;
let R5 being non  empty set;
let R19 being (interpretation of R1 , R5);
let R15 being (Element of ( CQC-WFF R1 ));
func Valid (R15 , R19) -> (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) )) means 
:L106: (ex B34 being (Function of ( CQC-WFF R1 ) , ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) )) st (it = ( B34 . R15 ) & ( B34 . ( VERUM R1 ) ) = ( ( Valuations_in (R1 , R5) ) --> ( TRUE ) ) & (for B35 , B36 being (Element of ( CQC-WFF R1 )) holds (for B37 being (bound_QC-variable of R1) holds (for B38 being (Element of ( NAT )) holds (for B39 being (CQC-variable_list of B38 , R1) holds (for B40 being (QC-pred_symbol of B38 , R1) holds (( B34 . ( B40 ! B39 ) ) = ( B39 'in' ( R19 . B40 ) ) & ( B34 . ( 'not' B35 ) ) = ( 'not' ( B34 . B35 ) ) & ( B34 . ( B35 '&' B36 ) ) = ( ( B34 . B35 ) '&' ( B34 . B36 ) ) & ( B34 . ( All (B37 , B35) ) ) = ( FOR_ALL (B37 , ( B34 . B35 )) )))))))));
existence
proof
deffunc H4((Element of ( NAT )) , (QC-pred_symbol of $1 , R1) , (CQC-variable_list of $1 , R1)) = ( $3 'in' ( R19 . $2 ) );
set D5 = ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) );
set D6 = ( In (( ( Valuations_in (R1 , R5) ) --> ( TRUE ) ) , D5) );
deffunc H5((Element of D5)) = ( In (( 'not' $1 ) , D5) );
deffunc H6((Element of D5) , (Element of D5)) = ( In (( $1 '&' $2 ) , D5) );
deffunc H7((bound_QC-variable of R1) , (Element of D5)) = ( In (( FOR_ALL ($1 , $2) ) , D5) );
consider C20 being (Function of ( CQC-WFF R1 ) , D5) such that L107: ( C20 . ( VERUM R1 ) ) = D6 and L108: (for B41 , B42 being (Element of ( CQC-WFF R1 )) holds (for B43 being (bound_QC-variable of R1) holds (for B44 being (Element of ( NAT )) holds (for B45 being (CQC-variable_list of B44 , R1) holds (for B46 being (QC-pred_symbol of B44 , R1) holds (( C20 . ( B46 ! B45 ) ) = H4(B44 , B46 , B45) & ( C20 . ( 'not' B41 ) ) = H5(( C20 . B41 )) & ( C20 . ( B41 '&' B42 ) ) = H6(( C20 . B41 ) , ( C20 . B42 )) & ( C20 . ( All (B43 , B41) ) ) = H7(B43 , ( C20 . B41 )))))))) from CQC_LANG:sch 2;
take ( C20 . R15 );
take C20;
thus L109: ( C20 . R15 ) = ( C20 . R15 );
L110: ( ( Valuations_in (R1 , R5) ) --> ( TRUE ) ) in D5 by FUNCT_2:8;
thus L111: ( C20 . ( VERUM R1 ) ) = ( ( Valuations_in (R1 , R5) ) --> ( TRUE ) ) by L110 , L107 , FUNCT_7:def 1;
let C21 , C22 being (Element of ( CQC-WFF R1 ));
let C23 being (bound_QC-variable of R1);
let C24 being (Element of ( NAT ));
let C25 being (CQC-variable_list of C24 , R1);
let C26 being (QC-pred_symbol of C24 , R1);
thus L112: ( C20 . ( C26 ! C25 ) ) = ( C25 'in' ( R19 . C26 ) ) by L108;
L113: ( 'not' ( C20 . C21 ) ) in D5 by FUNCT_2:8;
thus L114: ( C20 . ( 'not' C21 ) ) = H5(( C20 . C21 )) by L108
.= ( 'not' ( C20 . C21 ) ) by L113 , FUNCT_7:def 1;
L115: ( ( C20 . C21 ) '&' ( C20 . C22 ) ) in D5 by FUNCT_2:8;
thus L116: ( C20 . ( C21 '&' C22 ) ) = H6(( C20 . C21 ) , ( C20 . C22 )) by L108
.= ( ( C20 . C21 ) '&' ( C20 . C22 ) ) by L115 , FUNCT_7:def 1;
thus L117: ( C20 . ( All (C23 , C21) ) ) = H7(C23 , ( C20 . C21 )) by L108
.= ( FOR_ALL (C23 , ( C20 . C21 )) ) by FUNCT_7:def 1;
end;
uniqueness
proof
deffunc H8((Element of ( NAT )) , (QC-pred_symbol of $1 , R1) , (CQC-variable_list of $1 , R1)) = ( $3 'in' ( R19 . $2 ) );
set D7 = ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) );
set D8 = ( In (( ( Valuations_in (R1 , R5) ) --> ( TRUE ) ) , D7) );
deffunc H9((Element of D7)) = ( In (( 'not' $1 ) , D7) );
deffunc H10((Element of D7) , (Element of D7)) = ( In (( $1 '&' $2 ) , D7) );
deffunc H11((bound_QC-variable of R1) , (Element of D7)) = ( In (( FOR_ALL ($1 , $2) ) , D7) );
let C27 , C28 being (Element of D7);
given C29 being (Function of ( CQC-WFF R1 ) , D7) such that
L118: C27 = ( C29 . R15 )
and
L119: ( C29 . ( VERUM R1 ) ) = ( ( Valuations_in (R1 , R5) ) --> ( TRUE ) )
and
L120: (for B47 , B48 being (Element of ( CQC-WFF R1 )) holds (for B49 being (bound_QC-variable of R1) holds (for B50 being (Element of ( NAT )) holds (for B51 being (CQC-variable_list of B50 , R1) holds (for B52 being (QC-pred_symbol of B50 , R1) holds (( C29 . ( B52 ! B51 ) ) = H8(B50 , B52 , B51) & ( C29 . ( 'not' B47 ) ) = ( 'not' ( C29 . B47 ) ) & ( C29 . ( B47 '&' B48 ) ) = ( ( C29 . B47 ) '&' ( C29 . B48 ) ) & ( C29 . ( All (B49 , B47) ) ) = ( FOR_ALL (B49 , ( C29 . B47 )) )))))));

L121:
now
thus L122: ( C29 . ( VERUM R1 ) ) = D8 by L119 , FUNCT_7:def 1;
let C30 , C31 being (Element of ( CQC-WFF R1 ));
let C32 being (bound_QC-variable of R1);
let C33 being (Element of ( NAT ));
let C34 being (CQC-variable_list of C33 , R1);
let C35 being (QC-pred_symbol of C33 , R1);
thus L123: ( C29 . ( C35 ! C34 ) ) = H8(C33 , C35 , C34) by L120;
L124: ( 'not' ( C29 . C30 ) ) in D7 by FUNCT_2:8;
thus L125: ( C29 . ( 'not' C30 ) ) = ( 'not' ( C29 . C30 ) ) by L120
.= H9(( C29 . C30 )) by L124 , FUNCT_7:def 1;
L126: ( ( C29 . C30 ) '&' ( C29 . C31 ) ) in D7 by FUNCT_2:8;
thus L127: ( C29 . ( C30 '&' C31 ) ) = ( ( C29 . C30 ) '&' ( C29 . C31 ) ) by L120
.= H10(( C29 . C30 ) , ( C29 . C31 )) by L126 , FUNCT_7:def 1;
thus L128: ( C29 . ( All (C32 , C30) ) ) = ( FOR_ALL (C32 , ( C29 . C30 )) ) by L120
.= H11(C32 , ( C29 . C30 )) by FUNCT_7:def 1;
end;
given C36 being (Function of ( CQC-WFF R1 ) , D7) such that
L129: C28 = ( C36 . R15 )
and
L130: ( C36 . ( VERUM R1 ) ) = ( ( Valuations_in (R1 , R5) ) --> ( TRUE ) )
and
L131: (for B53 , B54 being (Element of ( CQC-WFF R1 )) holds (for B55 being (bound_QC-variable of R1) holds (for B56 being (Element of ( NAT )) holds (for B57 being (CQC-variable_list of B56 , R1) holds (for B58 being (QC-pred_symbol of B56 , R1) holds (( C36 . ( B58 ! B57 ) ) = H8(B56 , B58 , B57) & ( C36 . ( 'not' B53 ) ) = ( 'not' ( C36 . B53 ) ) & ( C36 . ( B53 '&' B54 ) ) = ( ( C36 . B53 ) '&' ( C36 . B54 ) ) & ( C36 . ( All (B55 , B53) ) ) = ( FOR_ALL (B55 , ( C36 . B53 )) )))))));

L132:
now
thus L133: ( C36 . ( VERUM R1 ) ) = D8 by L130 , FUNCT_7:def 1;
let C37 , C38 being (Element of ( CQC-WFF R1 ));
let C39 being (bound_QC-variable of R1);
let C40 being (Element of ( NAT ));
let C41 being (CQC-variable_list of C40 , R1);
let C42 being (QC-pred_symbol of C40 , R1);
thus L134: ( C36 . ( C42 ! C41 ) ) = H8(C40 , C42 , C41) by L131;
L135: ( 'not' ( C36 . C37 ) ) in D7 by FUNCT_2:8;
thus L136: ( C36 . ( 'not' C37 ) ) = ( 'not' ( C36 . C37 ) ) by L131
.= H9(( C36 . C37 )) by L135 , FUNCT_7:def 1;
L137: ( ( C36 . C37 ) '&' ( C36 . C38 ) ) in D7 by FUNCT_2:8;
thus L138: ( C36 . ( C37 '&' C38 ) ) = ( ( C36 . C37 ) '&' ( C36 . C38 ) ) by L131
.= H10(( C36 . C37 ) , ( C36 . C38 )) by L137 , FUNCT_7:def 1;
thus L139: ( C36 . ( All (C39 , C37) ) ) = ( FOR_ALL (C39 , ( C36 . C37 )) ) by L131
.= H11(C39 , ( C36 . C37 )) by FUNCT_7:def 1;
end;
L140: C29 = C36 from CQC_LANG:sch 3(L121 , L132);
thus L141: thesis by L140 , L118 , L129;
end;
end;
L143: (for R1 being QC-alphabet holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R5 being non  empty set holds (for R19 being (interpretation of R1 , R5) holds (( Valid (( VERUM R1 ) , R19) ) = ( ( Valuations_in (R1 , R5) ) --> ( TRUE ) ) & (for R4 being (Element of ( NAT )) holds (for R14 being (CQC-variable_list of R4 , R1) holds (for R20 being (QC-pred_symbol of R4 , R1) holds ( Valid (( R20 ! R14 ) , R19) ) = ( R14 'in' ( R19 . R20 ) )))) & (for R15 being (Element of ( CQC-WFF R1 )) holds ( Valid (( 'not' R15 ) , R19) ) = ( 'not' ( Valid (R15 , R19) ) )) & (for R16 being (Element of ( CQC-WFF R1 )) holds ( Valid (( R15 '&' R16 ) , R19) ) = ( ( Valid (R15 , R19) ) '&' ( Valid (R16 , R19) ) )) & (for R9 being (bound_QC-variable of R1) holds ( Valid (( All (R9 , R15) ) , R19) ) = ( FOR_ALL (R9 , ( Valid (R15 , R19) )) )))))))
proof
let R1 being QC-alphabet;
let R15 being (Element of ( CQC-WFF R1 ));
let R5 being non  empty set;
let R19 being (interpretation of R1 , R5);
set D9 = ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) );
set D10 = ( In (( ( Valuations_in (R1 , R5) ) --> ( TRUE ) ) , D9) );
deffunc H12((Element of ( NAT )) , (QC-pred_symbol of $1 , R1) , (CQC-variable_list of $1 , R1)) = ( $3 'in' ( R19 . $2 ) );
deffunc H13((Element of D9)) = ( In (( 'not' $1 ) , D9) );
deffunc H14((Element of D9) , (Element of D9)) = ( In (( $1 '&' $2 ) , D9) );
deffunc H15((bound_QC-variable of R1) , (Element of D9)) = ( In (( FOR_ALL ($1 , $2) ) , D9) );
deffunc H16((Element of ( CQC-WFF R1 ))) = ( Valid ($1 , R19) );
L144: (for R15 being (Element of ( CQC-WFF R1 )) holds (for B59 being (Element of D9) holds (B59 = H16(R15) iff (ex B60 being (Function of ( CQC-WFF R1 ) , D9) st (B59 = ( B60 . R15 ) & ( B60 . ( VERUM R1 ) ) = D10 & (for B61 , B62 being (Element of ( CQC-WFF R1 )) holds (for B63 being (bound_QC-variable of R1) holds (for B64 being (Element of ( NAT )) holds (for B65 being (CQC-variable_list of B64 , R1) holds (for B66 being (QC-pred_symbol of B64 , R1) holds (( B60 . ( B66 ! B65 ) ) = H12(B64 , B66 , B65) & ( B60 . ( 'not' B61 ) ) = H13(( B60 . B61 )) & ( B60 . ( B61 '&' B62 ) ) = H14(( B60 . B61 ) , ( B60 . B62 )) & ( B60 . ( All (B63 , B61) ) ) = H15(B63 , ( B60 . B61 )))))))))))))
proof
let R15 being (Element of ( CQC-WFF R1 ));
let C43 being (Element of D9);
thus L145: (C43 = H16(R15) implies (ex B67 being (Function of ( CQC-WFF R1 ) , D9) st (C43 = ( B67 . R15 ) & ( B67 . ( VERUM R1 ) ) = D10 & (for B68 , B69 being (Element of ( CQC-WFF R1 )) holds (for B70 being (bound_QC-variable of R1) holds (for B71 being (Element of ( NAT )) holds (for B72 being (CQC-variable_list of B71 , R1) holds (for B73 being (QC-pred_symbol of B71 , R1) holds (( B67 . ( B73 ! B72 ) ) = H12(B71 , B73 , B72) & ( B67 . ( 'not' B68 ) ) = H13(( B67 . B68 )) & ( B67 . ( B68 '&' B69 ) ) = H14(( B67 . B68 ) , ( B67 . B69 )) & ( B67 . ( All (B70 , B68) ) ) = H15(B70 , ( B67 . B68 )))))))))))
proof
assume L146: C43 = H16(R15);
consider C44 being (Function of ( CQC-WFF R1 ) , ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) )) such that L147: C43 = ( C44 . R15 ) and L148: ( C44 . ( VERUM R1 ) ) = ( ( Valuations_in (R1 , R5) ) --> ( TRUE ) ) and L149: (for B74 , B75 being (Element of ( CQC-WFF R1 )) holds (for B76 being (bound_QC-variable of R1) holds (for B77 being (Element of ( NAT )) holds (for B78 being (CQC-variable_list of B77 , R1) holds (for B79 being (QC-pred_symbol of B77 , R1) holds (( C44 . ( B79 ! B78 ) ) = ( B78 'in' ( R19 . B79 ) ) & ( C44 . ( 'not' B74 ) ) = ( 'not' ( C44 . B74 ) ) & ( C44 . ( B74 '&' B75 ) ) = ( ( C44 . B74 ) '&' ( C44 . B75 ) ) & ( C44 . ( All (B76 , B74) ) ) = ( FOR_ALL (B76 , ( C44 . B74 )) ))))))) by L146 , L106;
take C44;
thus L150: C43 = ( C44 . R15 ) by L147;
thus L151: ( C44 . ( VERUM R1 ) ) = D10 by L148 , FUNCT_7:def 1;
let C45 , C46 being (Element of ( CQC-WFF R1 ));
let C47 being (bound_QC-variable of R1);
let C48 being (Element of ( NAT ));
let C49 being (CQC-variable_list of C48 , R1);
let C50 being (QC-pred_symbol of C48 , R1);
thus L152: ( C44 . ( C50 ! C49 ) ) = H12(C48 , C50 , C49) by L149;
L153: ( 'not' ( C44 . C45 ) ) in D9 by FUNCT_2:8;
thus L154: ( C44 . ( 'not' C45 ) ) = ( 'not' ( C44 . C45 ) ) by L149
.= H13(( C44 . C45 )) by L153 , FUNCT_7:def 1;
L155: ( ( C44 . C45 ) '&' ( C44 . C46 ) ) in D9 by FUNCT_2:8;
thus L156: ( C44 . ( C45 '&' C46 ) ) = ( ( C44 . C45 ) '&' ( C44 . C46 ) ) by L149
.= H14(( C44 . C45 ) , ( C44 . C46 )) by L155 , FUNCT_7:def 1;
thus L157: ( C44 . ( All (C47 , C45) ) ) = ( FOR_ALL (C47 , ( C44 . C45 )) ) by L149
.= H15(C47 , ( C44 . C45 )) by FUNCT_7:def 1;
end;

given C51 being (Function of ( CQC-WFF R1 ) , D9) such that
L158: C43 = ( C51 . R15 )
and
L159: ( C51 . ( VERUM R1 ) ) = D10
and
L160: (for B80 , B81 being (Element of ( CQC-WFF R1 )) holds (for B82 being (bound_QC-variable of R1) holds (for B83 being (Element of ( NAT )) holds (for B84 being (CQC-variable_list of B83 , R1) holds (for B85 being (QC-pred_symbol of B83 , R1) holds (( C51 . ( B85 ! B84 ) ) = H12(B83 , B85 , B84) & ( C51 . ( 'not' B80 ) ) = H13(( C51 . B80 )) & ( C51 . ( B80 '&' B81 ) ) = H14(( C51 . B80 ) , ( C51 . B81 )) & ( C51 . ( All (B82 , B80) ) ) = H15(B82 , ( C51 . B80 ))))))));

L161: ( ( Valuations_in (R1 , R5) ) --> ( TRUE ) ) in D9 by FUNCT_2:8;
L162: ( C51 . ( VERUM R1 ) ) = ( ( Valuations_in (R1 , R5) ) --> ( TRUE ) ) by L161 , L159 , FUNCT_7:def 1;
L163: (for B86 , B87 being (Element of ( CQC-WFF R1 )) holds (for B88 being (bound_QC-variable of R1) holds (for B89 being (Element of ( NAT )) holds (for B90 being (CQC-variable_list of B89 , R1) holds (for B91 being (QC-pred_symbol of B89 , R1) holds (( C51 . ( B91 ! B90 ) ) = H12(B89 , B91 , B90) & ( C51 . ( 'not' B86 ) ) = ( 'not' ( C51 . B86 ) ) & ( C51 . ( B86 '&' B87 ) ) = ( ( C51 . B86 ) '&' ( C51 . B87 ) ) & ( C51 . ( All (B88 , B86) ) ) = ( FOR_ALL (B88 , ( C51 . B86 )) )))))))
proof
let C52 , C53 being (Element of ( CQC-WFF R1 ));
let C54 being (bound_QC-variable of R1);
let C55 being (Element of ( NAT ));
let C56 being (CQC-variable_list of C55 , R1);
let C57 being (QC-pred_symbol of C55 , R1);
thus L164: ( C51 . ( C57 ! C56 ) ) = H12(C55 , C57 , C56) by L160;
L165: ( 'not' ( C51 . C52 ) ) in D9 by FUNCT_2:8;
thus L166: ( C51 . ( 'not' C52 ) ) = H13(( C51 . C52 )) by L160
.= ( 'not' ( C51 . C52 ) ) by L165 , FUNCT_7:def 1;
L167: ( ( C51 . C52 ) '&' ( C51 . C53 ) ) in D9 by FUNCT_2:8;
thus L168: ( C51 . ( C52 '&' C53 ) ) = H14(( C51 . C52 ) , ( C51 . C53 )) by L160
.= ( ( C51 . C52 ) '&' ( C51 . C53 ) ) by L167 , FUNCT_7:def 1;
thus L169: ( C51 . ( All (C54 , C52) ) ) = H15(C54 , ( C51 . C52 )) by L160
.= ( FOR_ALL (C54 , ( C51 . C52 )) ) by FUNCT_7:def 1;
end;
thus L170: C43 = H16(R15) by L163 , L158 , L162 , L106;
end;
L171: ( ( Valuations_in (R1 , R5) ) --> ( TRUE ) ) in D9 by FUNCT_2:8;
L172: H16(( VERUM R1 )) = D10 from CQC_LANG:sch 5(L144);
thus L173: H16(( VERUM R1 )) = ( ( Valuations_in (R1 , R5) ) --> ( TRUE ) ) by L172 , L171 , FUNCT_7:def 1;
thus L174:now
let R4 being (Element of ( NAT ));
let R14 being (CQC-variable_list of R4 , R1);
let R20 being (QC-pred_symbol of R4 , R1);
thus L175: H16(( R20 ! R14 )) = H12(R4 , R20 , R14) from CQC_LANG:sch 6(L144);
end;
thus L176:now
let R15 being (Element of ( CQC-WFF R1 ));
L177: ( 'not' H16(R15) ) in D9 by FUNCT_2:8;
L178: H16(( 'not' R15 )) = H13(H16(R15)) from CQC_LANG:sch 7(L144);
thus L179: H16(( 'not' R15 )) = ( 'not' H16(R15) ) by L178 , L177 , FUNCT_7:def 1;
end;
thus L180:now
let R16 being (Element of ( CQC-WFF R1 ));
L181: ( H16(R15) '&' H16(R16) ) in D9 by FUNCT_2:8;
L182: H16(( R15 '&' R16 )) = H14(H16(R15) , H16(R16)) from CQC_LANG:sch 8(L144);
thus L183: H16(( R15 '&' R16 )) = ( H16(R15) '&' H16(R16) ) by L182 , L181 , FUNCT_7:def 1;
end;
let R9 being (bound_QC-variable of R1);
L184: H16(( All (R9 , R15) )) = H15(R9 , H16(R15)) from CQC_LANG:sch 9(L144);
thus L185: H16(( All (R9 , R15) )) = ( FOR_ALL (R9 , H16(R15)) ) by L184 , FUNCT_7:def 1;
end;
theorem
L186: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R19 being (interpretation of R1 , R5) holds ( Valid (( VERUM R1 ) , R19) ) = ( ( Valuations_in (R1 , R5) ) --> ( TRUE ) )))) by L143;
theorem
L187: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R19 being (interpretation of R1 , R5) holds ( ( Valid (( VERUM R1 ) , R19) ) . R12 ) = ( TRUE )))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R19 being (interpretation of R1 , R5);
L188: ( ( ( Valuations_in (R1 , R5) ) --> ( TRUE ) ) . R12 ) = ( TRUE ) by FUNCOP_1:7;
thus L189: thesis by L188 , L143;
end;
theorem
L190: (for R1 being QC-alphabet holds (for R4 being (Element of ( NAT )) holds (for R5 being non  empty set holds (for R14 being (CQC-variable_list of R4 , R1) holds (for R19 being (interpretation of R1 , R5) holds (for R20 being (QC-pred_symbol of R4 , R1) holds ( Valid (( R20 ! R14 ) , R19) ) = ( R14 'in' ( R19 . R20 ) ))))))) by L143;
theorem
L191: (for R1 being QC-alphabet holds (for R4 being (Element of ( NAT )) holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R14 being (CQC-variable_list of R4 , R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds (for R20 being (QC-pred_symbol of R4 , R1) holds (for R21 being (Element of ( relations_on R5 )) holds ((R15 = ( R20 ! R14 ) & R21 = ( R19 . R20 )) implies (( R12 *' R14 ) in R21 iff ( ( Valid (R15 , R19) ) . R12 ) = ( TRUE ))))))))))))
proof
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R14 being (CQC-variable_list of R4 , R1);
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
let R20 being (QC-pred_symbol of R4 , R1);
let R21 being (Element of ( relations_on R5 ));
assume that
L192: R15 = ( R20 ! R14 )
and
L193: R21 = ( R19 . R20 );
L194:
now
assume L195: ( ( Valid (R15 , R19) ) . R12 ) = ( TRUE );
L196: ( ( R14 'in' ( R19 . R20 ) ) . R12 ) <> ( FALSE ) by L195 , L192 , L143;
thus L197: ( R12 *' R14 ) in R21 by L196 , L193 , L83;
end;
L198:
now
assume L199: ( R12 *' R14 ) in R21;
L200: ( ( R14 'in' ( R19 . R20 ) ) . R12 ) = ( TRUE ) by L199 , L193 , L83;
thus L201: ( ( Valid (R15 , R19) ) . R12 ) = ( TRUE ) by L200 , L192 , L143;
end;
thus L202: thesis by L198 , L194;
end;
theorem
L203: (for R1 being QC-alphabet holds (for R4 being (Element of ( NAT )) holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R14 being (CQC-variable_list of R4 , R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds (for R20 being (QC-pred_symbol of R4 , R1) holds (for R21 being (Element of ( relations_on R5 )) holds ((R15 = ( R20 ! R14 ) & R21 = ( R19 . R20 )) implies ((not ( R12 *' R14 ) in R21) iff ( ( Valid (R15 , R19) ) . R12 ) = ( FALSE ))))))))))))
proof
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R14 being (CQC-variable_list of R4 , R1);
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
let R20 being (QC-pred_symbol of R4 , R1);
let R21 being (Element of ( relations_on R5 ));
assume that
L204: R15 = ( R20 ! R14 )
and
L205: R21 = ( R19 . R20 );
L206:
now
assume L207: ( ( Valid (R15 , R19) ) . R12 ) = ( FALSE );
L208: ( ( R14 'in' ( R19 . R20 ) ) . R12 ) <> ( TRUE ) by L207 , L204 , L143;
thus L209: (not ( R12 *' R14 ) in R21) by L208 , L205 , L83;
end;
L210:
now
assume L211: (not ( R12 *' R14 ) in R21);
L212: ( ( R14 'in' ( R19 . R20 ) ) . R12 ) = ( FALSE ) by L211 , L205 , L83;
thus L213: ( ( Valid (R15 , R19) ) . R12 ) = ( FALSE ) by L212 , L204 , L143;
end;
thus L214: thesis by L210 , L206;
end;
theorem
L215: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds ( Valid (( 'not' R15 ) , R19) ) = ( 'not' ( Valid (R15 , R19) ) ))))) by L143;
theorem
L216: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds ( ( Valid (( 'not' R15 ) , R19) ) . R12 ) = ( 'not' ( ( Valid (R15 , R19) ) . R12 ) ))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
L217: ( ( Valid (( 'not' R15 ) , R19) ) . R12 ) = ( ( 'not' ( Valid (R15 , R19) ) ) . R12 ) by L143;
thus L218: thesis by L217 , MARGREL1:def 19;
end;
theorem
L219: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds ( Valid (( R15 '&' R16 ) , R19) ) = ( ( Valid (R15 , R19) ) '&' ( Valid (R16 , R19) ) )))))) by L143;
theorem
L220: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds ( ( Valid (( R15 '&' R16 ) , R19) ) . R12 ) = ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( ( Valid (R16 , R19) ) . R12 ) )))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
L221: ( ( Valid (( R15 '&' R16 ) , R19) ) . R12 ) = ( ( ( Valid (R15 , R19) ) '&' ( Valid (R16 , R19) ) ) . R12 ) by L143;
thus L222: thesis by L221 , MARGREL1:def 20;
end;
theorem
L223: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R9 being (bound_QC-variable of R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds ( Valid (( All (R9 , R15) ) , R19) ) = ( FOR_ALL (R9 , ( Valid (R15 , R19) )) )))))) by L143;
theorem
L224: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds ( ( Valid (( R15 '&' ( 'not' R15 ) ) , R19) ) . R12 ) = ( FALSE ))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
L225:
now
assume L226: ( ( Valid (R15 , R19) ) . R12 ) = ( TRUE );
L227: ( 'not' ( ( Valid (R15 , R19) ) . R12 ) ) = ( FALSE ) by L226 , MARGREL1:11;
thus L228: ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( 'not' ( ( Valid (R15 , R19) ) . R12 ) ) ) = ( FALSE ) by L227 , MARGREL1:12;
end;
L229: (( ( Valid (R15 , R19) ) . R12 ) = ( FALSE ) implies ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( 'not' ( ( Valid (R15 , R19) ) . R12 ) ) ) = ( FALSE )) by MARGREL1:12;
L230: ( ( Valid (( R15 '&' ( 'not' R15 ) ) , R19) ) . R12 ) = ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( ( Valid (( 'not' R15 ) , R19) ) . R12 ) ) by L220
.= ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( 'not' ( ( Valid (R15 , R19) ) . R12 ) ) ) by L216;
thus L231: thesis by L230 , L225 , L229 , XBOOLEAN:def 3;
end;
theorem
L232: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds ( ( Valid (( 'not' ( R15 '&' ( 'not' R15 ) ) ) , R19) ) . R12 ) = ( TRUE ))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
L233: ( ( Valid (( 'not' ( R15 '&' ( 'not' R15 ) ) ) , R19) ) . R12 ) = ( 'not' ( ( Valid (( R15 '&' ( 'not' R15 ) ) , R19) ) . R12 ) ) by L216
.= ( 'not' ( FALSE ) ) by L224;
thus L234: thesis by L233 , MARGREL1:11;
end;
definition
let R1 being QC-alphabet;
let R5 being non  empty set;
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
pred R19 , R12 |= R15
means
:L235: ( ( Valid (R15 , R19) ) . R12 ) = ( TRUE )
;end;
theorem
L237: (for R1 being QC-alphabet holds (for R4 being (Element of ( NAT )) holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R14 being (CQC-variable_list of R4 , R1) holds (for R19 being (interpretation of R1 , R5) holds (for R20 being (QC-pred_symbol of R4 , R1) holds (R19 , R12 |= ( R20 ! R14 ) iff ( ( R14 'in' ( R19 . R20 ) ) . R12 ) = ( TRUE )))))))))
proof
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R14 being (CQC-variable_list of R4 , R1);
let R19 being (interpretation of R1 , R5);
let R20 being (QC-pred_symbol of R4 , R1);
L238:
now
assume L239: ( ( R14 'in' ( R19 . R20 ) ) . R12 ) = ( TRUE );
L240: ( ( Valid (( R20 ! R14 ) , R19) ) . R12 ) = ( TRUE ) by L239 , L143;
thus L241: R19 , R12 |= ( R20 ! R14 ) by L240 , L235;
end;
L242:
now
assume L243: R19 , R12 |= ( R20 ! R14 );
L244: ( ( Valid (( R20 ! R14 ) , R19) ) . R12 ) = ( TRUE ) by L243 , L235;
thus L245: ( ( R14 'in' ( R19 . R20 ) ) . R12 ) = ( TRUE ) by L244 , L143;
end;
thus L246: thesis by L242 , L238;
end;
theorem
L247: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds (R19 , R12 |= ( 'not' R15 ) iff (not R19 , R12 |= R15)))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
L248:
now
assume L249: (not R19 , R12 |= R15);
L250: (not ( ( Valid (R15 , R19) ) . R12 ) = ( TRUE )) by L249 , L235;
L251: ( ( Valid (R15 , R19) ) . R12 ) = ( FALSE ) by L250 , XBOOLEAN:def 3;
L252: ( 'not' ( ( Valid (R15 , R19) ) . R12 ) ) = ( TRUE ) by L251 , MARGREL1:11;
L253: ( ( 'not' ( Valid (R15 , R19) ) ) . R12 ) = ( TRUE ) by L252 , MARGREL1:def 19;
L254: ( ( Valid (( 'not' R15 ) , R19) ) . R12 ) = ( TRUE ) by L253 , L143;
thus L255: R19 , R12 |= ( 'not' R15 ) by L254 , L235;
end;
L256:
now
assume L257: R19 , R12 |= ( 'not' R15 );
L258: ( ( Valid (( 'not' R15 ) , R19) ) . R12 ) = ( TRUE ) by L257 , L235;
L259: ( ( 'not' ( Valid (R15 , R19) ) ) . R12 ) = ( TRUE ) by L258 , L143;
L260: ( 'not' ( ( Valid (R15 , R19) ) . R12 ) ) = ( TRUE ) by L259 , MARGREL1:def 19;
L261: ( ( Valid (R15 , R19) ) . R12 ) = ( FALSE ) by L260 , MARGREL1:11;
thus L262: (not R19 , R12 |= R15) by L261 , L235;
end;
thus L263: thesis by L256 , L248;
end;
theorem
L264: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds (R19 , R12 |= ( R15 '&' R16 ) iff (R19 , R12 |= R15 & R19 , R12 |= R16))))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
L265:
now
assume L266: (R19 , R12 |= R15 & R19 , R12 |= R16);
L267: (( ( Valid (R15 , R19) ) . R12 ) = ( TRUE ) & ( ( Valid (R16 , R19) ) . R12 ) = ( TRUE )) by L266 , L235;
L268: ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( ( Valid (R16 , R19) ) . R12 ) ) = ( TRUE ) by L267;
L269: ( ( ( Valid (R15 , R19) ) '&' ( Valid (R16 , R19) ) ) . R12 ) = ( TRUE ) by L268 , MARGREL1:def 20;
L270: ( ( Valid (( R15 '&' R16 ) , R19) ) . R12 ) = ( TRUE ) by L269 , L143;
thus L271: R19 , R12 |= ( R15 '&' R16 ) by L270 , L235;
end;
L272:
now
assume L273: R19 , R12 |= ( R15 '&' R16 );
L274: ( ( Valid (( R15 '&' R16 ) , R19) ) . R12 ) = ( TRUE ) by L273 , L235;
L275: ( ( ( Valid (R15 , R19) ) '&' ( Valid (R16 , R19) ) ) . R12 ) = ( TRUE ) by L274 , L143;
L276: ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( ( Valid (R16 , R19) ) . R12 ) ) = ( TRUE ) by L275 , MARGREL1:def 20;
L277: (( ( Valid (R15 , R19) ) . R12 ) = ( TRUE ) & ( ( Valid (R16 , R19) ) . R12 ) = ( TRUE )) by L276 , MARGREL1:12;
thus L278: (R19 , R12 |= R15 & R19 , R12 |= R16) by L277 , L235;
end;
thus L279: thesis by L272 , L265;
end;
theorem
L280: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R9 being (bound_QC-variable of R1) holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds (R19 , R12 |= ( All (R9 , R15) ) iff ( ( FOR_ALL (R9 , ( Valid (R15 , R19) )) ) . R12 ) = ( TRUE ))))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R9 being (bound_QC-variable of R1);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
L281:
now
assume L282: ( ( FOR_ALL (R9 , ( Valid (R15 , R19) )) ) . R12 ) = ( TRUE );
L283: ( ( Valid (( All (R9 , R15) ) , R19) ) . R12 ) = ( TRUE ) by L282 , L143;
thus L284: R19 , R12 |= ( All (R9 , R15) ) by L283 , L235;
end;
L285:
now
assume L286: R19 , R12 |= ( All (R9 , R15) );
L287: ( ( Valid (( All (R9 , R15) ) , R19) ) . R12 ) = ( TRUE ) by L286 , L235;
thus L288: ( ( FOR_ALL (R9 , ( Valid (R15 , R19) )) ) . R12 ) = ( TRUE ) by L287 , L143;
end;
thus L289: thesis by L285 , L281;
end;
theorem
L290: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R9 being (bound_QC-variable of R1) holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds (R19 , R12 |= ( All (R9 , R15) ) iff (for R13 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R13 . R11 ) = ( R12 . R11 ))) implies ( ( Valid (R15 , R19) ) . R13 ) = ( TRUE ))))))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R9 being (bound_QC-variable of R1);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
thus L291:now
assume L292: R19 , R12 |= ( All (R9 , R15) );
L293: ( ( FOR_ALL (R9 , ( Valid (R15 , R19) )) ) . R12 ) = ( TRUE ) by L292 , L280;
thus L294: (for R13 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R13 . R11 ) = ( R12 . R11 ))) implies ( ( Valid (R15 , R19) ) . R13 ) = ( TRUE ))) by L293 , L33;
end;
assume L295: (for R13 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R13 . R11 ) = ( R12 . R11 ))) implies ( ( Valid (R15 , R19) ) . R13 ) = ( TRUE )));
L296: ( ( FOR_ALL (R9 , ( Valid (R15 , R19) )) ) . R12 ) = ( TRUE ) by L295 , L33;
thus L297: thesis by L296 , L280;
end;
theorem
L298: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds ( Valid (( 'not' ( 'not' R15 ) ) , R19) ) = ( Valid (R15 , R19) )))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
L299:
now
let R12 being (Element of ( Valuations_in (R1 , R5) ));
thus L300: ( ( Valid (( 'not' ( 'not' R15 ) ) , R19) ) . R12 ) = ( 'not' ( ( Valid (( 'not' R15 ) , R19) ) . R12 ) ) by L216
.= ( 'not' ( 'not' ( ( Valid (R15 , R19) ) . R12 ) ) ) by L216
.= ( ( Valid (R15 , R19) ) . R12 );
end;
thus L301: thesis by L299 , FUNCT_2:63;
end;
theorem
L302: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds ( Valid (( R15 '&' R15 ) , R19) ) = ( Valid (R15 , R19) )))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
L303:
now
let R12 being (Element of ( Valuations_in (R1 , R5) ));
thus L304: ( ( Valid (( R15 '&' R15 ) , R19) ) . R12 ) = ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( ( Valid (R15 , R19) ) . R12 ) ) by L220
.= ( ( Valid (R15 , R19) ) . R12 );
end;
thus L305: thesis by L303 , FUNCT_2:63;
end;
theorem
L306: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds (R19 , R12 |= ( R15 => R16 ) iff (( ( Valid (R15 , R19) ) . R12 ) = ( FALSE ) or ( ( Valid (R16 , R19) ) . R12 ) = ( TRUE )))))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
L307:
now
L308:
now
assume L309: ( ( Valid (R16 , R19) ) . R12 ) = ( TRUE );
assume L310: (not R19 , R12 |= ( R15 => R16 ));
L311: ( ( Valid (( R15 => R16 ) , R19) ) . R12 ) <> ( TRUE ) by L310 , L235;
L312: ( ( Valid (( R15 => R16 ) , R19) ) . R12 ) = ( FALSE ) by L311 , XBOOLEAN:def 3;
L313: ( ( Valid (( 'not' ( R15 '&' ( 'not' R16 ) ) ) , R19) ) . R12 ) = ( FALSE ) by L312 , QC_LANG2:def 2;
L314: ( 'not' ( ( Valid (( R15 '&' ( 'not' R16 ) ) , R19) ) . R12 ) ) = ( FALSE ) by L313 , L216;
L315: ( ( Valid (( R15 '&' ( 'not' R16 ) ) , R19) ) . R12 ) = ( TRUE ) by L314 , MARGREL1:11;
L316: ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( ( Valid (( 'not' R16 ) , R19) ) . R12 ) ) = ( TRUE ) by L315 , L220;
L317: ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( 'not' ( ( Valid (R16 , R19) ) . R12 ) ) ) = ( TRUE ) by L316 , L216;
L318: ( 'not' ( ( Valid (R16 , R19) ) . R12 ) ) = ( TRUE ) by L317 , MARGREL1:12;
thus L319: contradiction by L318 , L309 , MARGREL1:11;
end;
L320:
now
assume L321: ( ( Valid (R15 , R19) ) . R12 ) = ( FALSE );
L322: ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( ( Valid (( 'not' R16 ) , R19) ) . R12 ) ) = ( FALSE ) by L321 , MARGREL1:12;
L323: ( ( Valid (( R15 '&' ( 'not' R16 ) ) , R19) ) . R12 ) = ( FALSE ) by L322 , L220;
L324: ( 'not' ( ( Valid (( R15 '&' ( 'not' R16 ) ) , R19) ) . R12 ) ) = ( TRUE ) by L323 , MARGREL1:11;
L325: ( ( Valid (( 'not' ( R15 '&' ( 'not' R16 ) ) ) , R19) ) . R12 ) = ( TRUE ) by L324 , L216;
L326: ( ( Valid (( R15 => R16 ) , R19) ) . R12 ) = ( TRUE ) by L325 , QC_LANG2:def 2;
thus L327: R19 , R12 |= ( R15 => R16 ) by L326 , L235;
end;
assume L328: (( ( Valid (R15 , R19) ) . R12 ) = ( FALSE ) or ( ( Valid (R16 , R19) ) . R12 ) = ( TRUE ));
thus L329: R19 , R12 |= ( R15 => R16 ) by L328 , L320 , L308;
end;
L330:
now
assume L331: R19 , R12 |= ( R15 => R16 );
L332: ( ( Valid (( R15 => R16 ) , R19) ) . R12 ) = ( TRUE ) by L331 , L235;
L333: ( ( Valid (( 'not' ( R15 '&' ( 'not' R16 ) ) ) , R19) ) . R12 ) = ( TRUE ) by L332 , QC_LANG2:def 2;
L334: ( 'not' ( ( Valid (( R15 '&' ( 'not' R16 ) ) , R19) ) . R12 ) ) = ( TRUE ) by L333 , L216;
L335: ( ( Valid (( R15 '&' ( 'not' R16 ) ) , R19) ) . R12 ) = ( FALSE ) by L334 , MARGREL1:11;
L336: ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( ( Valid (( 'not' R16 ) , R19) ) . R12 ) ) = ( FALSE ) by L335 , L220;
L337: ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( 'not' ( ( Valid (R16 , R19) ) . R12 ) ) ) = ( FALSE ) by L336 , L216;
L338: (( ( Valid (R15 , R19) ) . R12 ) = ( FALSE ) or ( 'not' ( ( Valid (R16 , R19) ) . R12 ) ) = ( FALSE )) by L337 , MARGREL1:12;
thus L339: (( ( Valid (R15 , R19) ) . R12 ) = ( FALSE ) or ( ( Valid (R16 , R19) ) . R12 ) = ( TRUE )) by L338 , MARGREL1:11;
end;
thus L340: thesis by L330 , L307;
end;
theorem
L341: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds (R19 , R12 |= ( R15 => R16 ) iff (R19 , R12 |= R15 implies R19 , R12 |= R16))))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
thus L342:now
assume L343: R19 , R12 |= ( R15 => R16 );
L344: (( ( Valid (R15 , R19) ) . R12 ) = ( FALSE ) or ( ( Valid (R16 , R19) ) . R12 ) = ( TRUE )) by L343 , L306;
thus L345: (R19 , R12 |= R15 implies R19 , R12 |= R16) by L344 , L235;
end;
assume L346: (R19 , R12 |= R15 implies R19 , R12 |= R16);
L347: (( ( Valid (R15 , R19) ) . R12 ) = ( TRUE ) implies ( ( Valid (R16 , R19) ) . R12 ) = ( TRUE )) by L346 , L235;
L348: (( ( Valid (R15 , R19) ) . R12 ) = ( FALSE ) or ( ( Valid (R16 , R19) ) . R12 ) = ( TRUE )) by L347 , XBOOLEAN:def 3;
thus L349: thesis by L348 , L306;
end;
theorem
L350: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R9 being (bound_QC-variable of R1) holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for B92 being (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) )) holds (( ( FOR_ALL (R9 , B92) ) . R12 ) = ( TRUE ) implies ( B92 . R12 ) = ( TRUE )))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R9 being (bound_QC-variable of R1);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let C58 being (Element of ( Funcs (( Valuations_in (R1 , R5) ) , ( BOOLEAN )) ));
L351: (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R12 . R11 ) = ( R12 . R11 )));
thus L352: thesis by L351 , L33;
end;
definition
let R1 being QC-alphabet;
let R5 being non  empty set;
let R19 being (interpretation of R1 , R5);
let R15 being (Element of ( CQC-WFF R1 ));
pred R19 |= R15
means
:L353: (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds R19 , R12 |= R15)
;end;
L355: (for R22 being (Element of ( BOOLEAN )) holds (for R23 being (Element of ( BOOLEAN )) holds (for R24 being (Element of ( BOOLEAN )) holds ( 'not' ( ( 'not' ( R22 '&' ( 'not' R23 ) ) ) '&' ( ( 'not' ( R23 '&' R24 ) ) '&' ( R22 '&' R24 ) ) ) ) = ( TRUE ))))
proof
let R22 being (Element of ( BOOLEAN ));
let R23 being (Element of ( BOOLEAN ));
let R24 being (Element of ( BOOLEAN ));
per cases  by XBOOLEAN:def 3;
suppose L356: (R24 = ( TRUE ) & R23 = ( TRUE ));

L357: ( 'not' ( R23 '&' R24 ) ) = ( FALSE ) by L356 , MARGREL1:11;
L358: ( ( 'not' ( R23 '&' R24 ) ) '&' ( R22 '&' R24 ) ) = ( FALSE ) by L357 , MARGREL1:12;
L359: ( ( 'not' ( R22 '&' ( 'not' R23 ) ) ) '&' ( ( 'not' ( R23 '&' R24 ) ) '&' ( R22 '&' R24 ) ) ) = ( FALSE ) by L358 , MARGREL1:12;
thus L360: thesis by L359 , MARGREL1:11;
end;
suppose that L361: R23 = ( FALSE )
and
L362: R22 = ( TRUE );
L363: ( 'not' R23 ) = ( TRUE ) by L361 , MARGREL1:11;
L364: ( 'not' ( R22 '&' ( 'not' R23 ) ) ) = ( FALSE ) by L363 , L362 , MARGREL1:11;
L365: ( ( 'not' ( R22 '&' ( 'not' R23 ) ) ) '&' ( ( 'not' ( R23 '&' R24 ) ) '&' ( R22 '&' R24 ) ) ) = ( FALSE ) by L364 , MARGREL1:12;
thus L366: thesis by L365 , MARGREL1:11;
end;
suppose L367: R22 = ( FALSE );

L368: ( R22 '&' R24 ) = ( FALSE ) by L367 , MARGREL1:12;
L369: ( ( 'not' ( R23 '&' R24 ) ) '&' ( R22 '&' R24 ) ) = ( FALSE ) by L368 , MARGREL1:12;
L370: ( ( 'not' ( R22 '&' ( 'not' R23 ) ) ) '&' ( ( 'not' ( R23 '&' R24 ) ) '&' ( R22 '&' R24 ) ) ) = ( FALSE ) by L369 , MARGREL1:12;
thus L371: thesis by L370 , MARGREL1:11;
end;
suppose L372: R24 = ( FALSE );

L373: ( R22 '&' R24 ) = ( FALSE ) by L372 , MARGREL1:12;
L374: ( ( 'not' ( R23 '&' R24 ) ) '&' ( R22 '&' R24 ) ) = ( FALSE ) by L373 , MARGREL1:12;
L375: ( ( 'not' ( R22 '&' ( 'not' R23 ) ) ) '&' ( ( 'not' ( R23 '&' R24 ) ) '&' ( R22 '&' R24 ) ) ) = ( FALSE ) by L374 , MARGREL1:12;
thus L376: thesis by L375 , MARGREL1:11;
end;
end;
L378:
now
let R1 being QC-alphabet;
let C59 being non  empty set;
let C60 , C61 being (bound_QC-variable of R1);
let C62 , C63 being (Element of ( Valuations_in (R1 , C59) ));
thus L379: (ex B93 being (Element of ( Valuations_in (R1 , C59) )) st ((for B94 being (bound_QC-variable of R1) holds (B94 <> C60 implies ( B93 . B94 ) = ( C62 . B94 ))) & ( B93 . C60 ) = ( C63 . C61 )))
proof
deffunc H17(set) = ( C63 . C61 );
deffunc H18(set) = ( C62 . $1 );
defpred S2[ set ] means (for R10 being (bound_QC-variable of R1) holds (R10 = $1 implies R10 <> C60));
L380: (for B95 being set holds (B95 in ( bound_QC-variables R1 ) implies ((S2[ B95 ] implies H18(B95) in C59) & ((not S2[ B95 ]) implies H17(B95) in C59)))) by FUNCT_2:5;
consider C64 being (Function of ( bound_QC-variables R1 ) , C59) such that L381: (for B96 being set holds (B96 in ( bound_QC-variables R1 ) implies ((S2[ B96 ] implies ( C64 . B96 ) = H18(B96)) & ((not S2[ B96 ]) implies ( C64 . B96 ) = H17(B96))))) from FUNCT_2:sch 5(L380);
L382: (( dom C64 ) = ( bound_QC-variables R1 ) & ( rng C64 ) c= C59) by FUNCT_2:def 1 , RELAT_1:def 19;
reconsider D11 = C64 as (Element of ( Valuations_in (R1 , C59) )) by L382 , FUNCT_2:def 2;
take D11;
L383:
now
let C65 being (bound_QC-variable of R1);
L384:
now
assume L385: C65 <> C60;
L386: ((for R10 being (bound_QC-variable of R1) holds (R10 = C65 implies R10 <> C60)) implies ( D11 . C65 ) = ( C62 . C65 )) by L381;
thus L387: ( D11 . C65 ) = ( C62 . C65 ) by L386 , L385;
end;
thus L388: (C65 <> C60 implies ( D11 . C65 ) = ( C62 . C65 )) by L384;
thus L389: (C65 = C60 implies ( D11 . C60 ) = ( C63 . C61 )) by L381;
end;
thus L390: thesis by L383;
end;

end;
theorem
L380: (for R1 being QC-alphabet holds (for B97 being non  empty set holds (for B98 , B99 being (bound_QC-variable of R1) holds (for B100 , B101 being (Element of ( Valuations_in (R1 , B97) )) holds (ex B102 being (Element of ( Valuations_in (R1 , B97) )) st ((for B103 being (bound_QC-variable of R1) holds (B103 <> B98 implies ( B102 . B103 ) = ( B100 . B103 ))) & ( B102 . B98 ) = ( B101 . B99 ))))))) by L378;
theorem
L381: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R9 being (bound_QC-variable of R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds ((not R9 in ( still_not-bound_in R15 )) implies (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R25 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 ))) implies ( ( Valid (R15 , R19) ) . R12 ) = ( ( Valid (R15 , R19) ) . R25 ))))))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R9 being (bound_QC-variable of R1);
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
defpred S3[ (Element of ( CQC-WFF R1 )) ] means ((not R9 in ( still_not-bound_in $1 )) implies (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R25 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 ))) implies ( ( Valid ($1 , R19) ) . R12 ) = ( ( Valid ($1 , R19) ) . R25 )))));
L382:
now
let R17 being (Element of ( CQC-WFF R1 ));
let R18 being (Element of ( CQC-WFF R1 ));
let R11 being (bound_QC-variable of R1);
let R4 being (Element of ( NAT ));
let R14 being (CQC-variable_list of R4 , R1);
let R20 being (QC-pred_symbol of R4 , R1);
thus L383: S3[ ( VERUM R1 ) ]
proof
assume L384: (not R9 in ( still_not-bound_in ( VERUM R1 ) ));
thus L385: (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R25 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 ))) implies ( ( Valid (( VERUM R1 ) , R19) ) . R12 ) = ( ( Valid (( VERUM R1 ) , R19) ) . R25 ))))
proof
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R25 being (Element of ( Valuations_in (R1 , R5) ));
assume that
L386: (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 )));
L387: ( ( Valid (( VERUM R1 ) , R19) ) . R12 ) = ( TRUE ) by L187;
thus L388: thesis by L387 , L187;
end;

end;

L386: ( rng R14 ) c= ( bound_QC-variables R1 ) by RELAT_1:def 19;
thus L387: S3[ ( R20 ! R14 ) ]
proof
assume L388: (not R9 in ( still_not-bound_in ( R20 ! R14 ) ));
thus L389: (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R25 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 ))) implies ( ( Valid (( R20 ! R14 ) , R19) ) . R12 ) = ( ( Valid (( R20 ! R14 ) , R19) ) . R25 ))))
proof
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R25 being (Element of ( Valuations_in (R1 , R5) ));
assume that
L390: (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 )));
L391:
now
L392: ( len ( R12 *' R14 ) ) = R4 by L47;
L393:
now
let C66 being Nat;
assume L394: (1 <= C66 & C66 <= ( len ( R12 *' R14 ) ));
L395: ( len ( R12 *' R14 ) ) = ( len R14 ) by L392 , CARD_1:def 7;
L396: C66 in ( dom R14 ) by L395 , L394 , FINSEQ_3:25;
L397: ( R14 . C66 ) in ( rng R14 ) by L396 , FUNCT_1:def 3;
reconsider D12 = ( R14 . C66 ) as (bound_QC-variable of R1) by L397 , L386;
L398: C66 in ( NAT ) by ORDINAL1:def 12;
L399: ( R14 . C66 ) <> R9
proof
reconsider D13 = ( still_not-bound_in R14 ) as set;
L400: (not R9 in D13) by L388 , QC_LANG3:5;
L401: (not R9 in ( variables_in (R14 , ( bound_QC-variables R1 )) )) by L400 , QC_LANG3:2;
L402: (not R9 in { ( R14 . B104 ) where B104 is (Element of ( NAT )) : (1 <= B104 & B104 <= ( len R14 ) & ( R14 . B104 ) in ( bound_QC-variables R1 )) }) by L401 , QC_LANG3:def 1;
thus L403: thesis by L402 , L394 , L398 , L395;
end;
L404: ( R25 . D12 ) = ( R12 . D12 ) by L399 , L390;
L405: ( ( R12 *' R14 ) . C66 ) = ( R12 . ( R14 . C66 ) ) by L392 , L394 , L47;
thus L406: ( ( R12 *' R14 ) . C66 ) = ( ( R25 *' R14 ) . C66 ) by L405 , L392 , L394 , L404 , L47;
end;
assume L407: ( ( Valid (( R20 ! R14 ) , R19) ) . R12 ) = ( TRUE );
L408: ( ( R14 'in' ( R19 . R20 ) ) . R12 ) = ( TRUE ) by L407 , L143;
L409: ( R12 *' R14 ) in ( R19 . R20 ) by L408 , L83;
L410: ( len ( R25 *' R14 ) ) = R4 by L47;
L411: ( R25 *' R14 ) in ( R19 . R20 ) by L410 , L409 , L392 , L393 , FINSEQ_1:14;
L412: ( ( R14 'in' ( R19 . R20 ) ) . R25 ) = ( TRUE ) by L411 , L83;
thus L413: thesis by L412 , L407 , L143;
end;
L414:
now
L415: ( len ( R12 *' R14 ) ) = R4 by L47;
L416:
now
let C67 being Nat;
assume L417: (1 <= C67 & C67 <= ( len ( R12 *' R14 ) ));
L418: ( len ( R12 *' R14 ) ) = ( len R14 ) by L415 , CARD_1:def 7;
L419: C67 in ( dom R14 ) by L418 , L417 , FINSEQ_3:25;
L420: ( R14 . C67 ) in ( rng R14 ) by L419 , FUNCT_1:def 3;
reconsider D14 = ( R14 . C67 ) as (bound_QC-variable of R1) by L420 , L386;
L421: ( R14 . C67 ) <> R9
proof
reconsider D15 = ( still_not-bound_in R14 ) as set;
L422: (not R9 in D15) by L388 , QC_LANG3:5;
L423: (not R9 in ( variables_in (R14 , ( bound_QC-variables R1 )) )) by L422 , QC_LANG3:2;
L424: (C67 in ( NAT ) & (not R9 in { ( R14 . B105 ) where B105 is (Element of ( NAT )) : (1 <= B105 & B105 <= ( len R14 ) & ( R14 . B105 ) in ( bound_QC-variables R1 )) })) by L423 , ORDINAL1:def 12 , QC_LANG3:def 1;
thus L425: thesis by L424 , L417 , L418;
end;
L426: ( R25 . D14 ) = ( R12 . D14 ) by L421 , L390;
L427: ( ( R12 *' R14 ) . C67 ) = ( R12 . ( R14 . C67 ) ) by L415 , L417 , L47;
thus L428: ( ( R12 *' R14 ) . C67 ) = ( ( R25 *' R14 ) . C67 ) by L427 , L415 , L417 , L426 , L47;
end;
assume L429: ( ( Valid (( R20 ! R14 ) , R19) ) . R12 ) = ( FALSE );
L430: ( ( R14 'in' ( R19 . R20 ) ) . R12 ) = ( FALSE ) by L429 , L143;
L431: (not ( R12 *' R14 ) in ( R19 . R20 )) by L430 , L83;
L432: ( len ( R25 *' R14 ) ) = R4 by L47;
L433: (not ( R25 *' R14 ) in ( R19 . R20 )) by L432 , L431 , L415 , L416 , FINSEQ_1:14;
L434: ( ( R14 'in' ( R19 . R20 ) ) . R25 ) = ( FALSE ) by L433 , L83;
thus L435: thesis by L434 , L429 , L143;
end;
thus L436: thesis by L414 , L391 , XBOOLEAN:def 3;
end;

end;

thus L390: (S3[ R17 ] implies S3[ ( 'not' R17 ) ])
proof
assume L391: (((not R9 in ( still_not-bound_in R17 )) implies (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R25 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 ))) implies ( ( Valid (R17 , R19) ) . R12 ) = ( ( Valid (R17 , R19) ) . R25 ))))) & (not R9 in ( still_not-bound_in ( 'not' R17 ) )));
thus L392: (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R25 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 ))) implies ( ( Valid (( 'not' R17 ) , R19) ) . R12 ) = ( ( Valid (( 'not' R17 ) , R19) ) . R25 ))))
proof
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R25 being (Element of ( Valuations_in (R1 , R5) ));
assume that
L393: (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 )));
L394:
now
assume L395: ( ( Valid (( 'not' R17 ) , R19) ) . R12 ) = ( FALSE );
L396: ( 'not' ( ( Valid (R17 , R19) ) . R12 ) ) = ( FALSE ) by L395 , L216;
L397: ( ( Valid (R17 , R19) ) . R12 ) = ( TRUE ) by L396 , MARGREL1:11;
L398: ( ( Valid (R17 , R19) ) . R25 ) = ( TRUE ) by L397 , L391 , L393 , QC_LANG3:7;
L399: ( 'not' ( ( Valid (R17 , R19) ) . R25 ) ) = ( FALSE ) by L398 , MARGREL1:11;
thus L400: thesis by L399 , L395 , L216;
end;
L401:
now
assume L402: ( ( Valid (( 'not' R17 ) , R19) ) . R12 ) = ( TRUE );
L403: ( 'not' ( ( Valid (R17 , R19) ) . R12 ) ) = ( TRUE ) by L402 , L216;
L404: ( ( Valid (R17 , R19) ) . R12 ) = ( FALSE ) by L403 , MARGREL1:11;
L405: ( ( Valid (R17 , R19) ) . R25 ) = ( FALSE ) by L404 , L391 , L393 , QC_LANG3:7;
L406: ( 'not' ( ( Valid (R17 , R19) ) . R25 ) ) = ( TRUE ) by L405 , MARGREL1:11;
thus L407: thesis by L406 , L402 , L216;
end;
thus L408: thesis by L401 , L394 , XBOOLEAN:def 3;
end;

end;

thus L393: ((S3[ R17 ] & S3[ R18 ]) implies S3[ ( R17 '&' R18 ) ])
proof
assume that
L394: ((not R9 in ( still_not-bound_in R17 )) implies (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R25 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 ))) implies ( ( Valid (R17 , R19) ) . R12 ) = ( ( Valid (R17 , R19) ) . R25 )))))
and
L395: ((not R9 in ( still_not-bound_in R18 )) implies (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R25 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 ))) implies ( ( Valid (R18 , R19) ) . R12 ) = ( ( Valid (R18 , R19) ) . R25 )))))
and
L396: (not R9 in ( still_not-bound_in ( R17 '&' R18 ) ));
L397: (not R9 in ( ( still_not-bound_in R17 ) \/ ( still_not-bound_in R18 ) )) by L396 , QC_LANG3:10;
thus L398: (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R25 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 ))) implies ( ( Valid (( R17 '&' R18 ) , R19) ) . R12 ) = ( ( Valid (( R17 '&' R18 ) , R19) ) . R25 ))))
proof
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R25 being (Element of ( Valuations_in (R1 , R5) ));
assume that
L399: (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 )));
L400:
now
assume L401: ( ( Valid (( R17 '&' R18 ) , R19) ) . R12 ) = ( FALSE );
L402:
now
assume L403: ( ( Valid (R17 , R19) ) . R12 ) = ( FALSE );
L404: ( ( Valid (R17 , R19) ) . R25 ) = ( FALSE ) by L403 , L394 , L397 , L399 , XBOOLE_0:def 3;
L405: ( ( ( Valid (R17 , R19) ) . R25 ) '&' ( ( Valid (R18 , R19) ) . R25 ) ) = ( FALSE ) by L404 , MARGREL1:12;
thus L406: thesis by L405 , L401 , L220;
end;
L407:
now
assume L408: ( ( Valid (R18 , R19) ) . R12 ) = ( FALSE );
L409: ( ( Valid (R18 , R19) ) . R25 ) = ( FALSE ) by L408 , L395 , L397 , L399 , XBOOLE_0:def 3;
L410: ( ( ( Valid (R17 , R19) ) . R25 ) '&' ( ( Valid (R18 , R19) ) . R25 ) ) = ( FALSE ) by L409 , MARGREL1:12;
thus L411: thesis by L410 , L401 , L220;
end;
L412: ( ( ( Valid (R17 , R19) ) . R12 ) '&' ( ( Valid (R18 , R19) ) . R12 ) ) = ( FALSE ) by L401 , L220;
thus L413: thesis by L412 , L402 , L407 , MARGREL1:12;
end;
L414:
now
assume L415: ( ( Valid (( R17 '&' R18 ) , R19) ) . R12 ) = ( TRUE );
L416: ( ( ( Valid (R17 , R19) ) . R12 ) '&' ( ( Valid (R18 , R19) ) . R12 ) ) = ( TRUE ) by L415 , L220;
L417: ( ( Valid (R18 , R19) ) . R12 ) = ( TRUE ) by L416 , MARGREL1:12;
L418: ( ( Valid (R18 , R19) ) . R25 ) = ( TRUE ) by L417 , L395 , L397 , L399 , XBOOLE_0:def 3;
L419: ( ( Valid (R17 , R19) ) . R12 ) = ( TRUE ) by L416 , MARGREL1:12;
L420: ( ( Valid (R17 , R19) ) . R25 ) = ( TRUE ) by L419 , L394 , L397 , L399 , XBOOLE_0:def 3;
L421: ( ( ( Valid (R17 , R19) ) . R25 ) '&' ( ( Valid (R18 , R19) ) . R25 ) ) = ( TRUE ) by L420 , L418;
thus L422: thesis by L421 , L415 , L220;
end;
thus L423: thesis by L414 , L400 , XBOOLEAN:def 3;
end;

end;

thus L399: (S3[ R17 ] implies S3[ ( All (R11 , R17) ) ])
proof
assume that
L400: ((not R9 in ( still_not-bound_in R17 )) implies (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R25 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 ))) implies ( ( Valid (R17 , R19) ) . R12 ) = ( ( Valid (R17 , R19) ) . R25 )))))
and
L401: (not R9 in ( still_not-bound_in ( All (R11 , R17) ) ));
L402: (not R9 in ( ( still_not-bound_in R17 ) \ { R11 } )) by L401 , QC_LANG3:12;
thus L403: (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R25 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R27 being (bound_QC-variable of R1) holds (R9 <> R27 implies ( R25 . R27 ) = ( R12 . R27 ))) implies ( ( Valid (( All (R11 , R17) ) , R19) ) . R12 ) = ( ( Valid (( All (R11 , R17) ) , R19) ) . R25 ))))
proof
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R25 being (Element of ( Valuations_in (R1 , R5) ));
assume that
L404: (for R27 being (bound_QC-variable of R1) holds (R9 <> R27 implies ( R25 . R27 ) = ( R12 . R27 )));
L405:
now
assume L406: ( ( Valid (( All (R11 , R17) ) , R19) ) . R12 ) = ( FALSE );
L407: ( ( FOR_ALL (R11 , ( Valid (R17 , R19) )) ) . R12 ) = ( FALSE ) by L406 , L143;
consider R13 being (Element of ( Valuations_in (R1 , R5) )) such that L408: ( ( Valid (R17 , R19) ) . R13 ) = ( FALSE ) and L409: (for R27 being (bound_QC-variable of R1) holds (R11 <> R27 implies ( R13 . R27 ) = ( R12 . R27 ))) by L407 , L21;
L410:
now
assume L411: (not R9 in ( still_not-bound_in R17 ));
consider R26 being (Element of ( Valuations_in (R1 , R5) )) such that L412: ((for R27 being (bound_QC-variable of R1) holds (R27 <> R11 implies ( R26 . R27 ) = ( R25 . R27 ))) & ( R26 . R11 ) = ( R13 . R11 )) by L378;
take D16 = R26;
L413: (for R27 being (bound_QC-variable of R1) holds (R9 <> R27 implies ( D16 . R27 ) = ( R13 . R27 )))
proof
let R27 being (bound_QC-variable of R1);
assume that
L414: R9 <> R27;
L415:
now
assume L416: R27 <> R11;
thus L417: ( D16 . R27 ) = ( R25 . R27 ) by L416 , L412
.= ( R12 . R27 ) by L404 , L414
.= ( R13 . R27 ) by L409 , L416;
end;
thus L418: thesis by L415 , L412;
end;
thus L419: ( ( Valid (R17 , R19) ) . D16 ) = ( FALSE ) by L413 , L400 , L408 , L411;
thus L420: (for R27 being (bound_QC-variable of R1) holds (R11 <> R27 implies ( D16 . R27 ) = ( R25 . R27 ))) by L412;
end;
L421:
now
assume L422: R9 in { R11 };
take D17 = R13;
thus L423: ( ( Valid (R17 , R19) ) . D17 ) = ( FALSE ) by L408;
L424: (for R27 being (bound_QC-variable of R1) holds (R11 <> R27 implies ( R13 . R27 ) = ( R25 . R27 )))
proof
let R27 being (bound_QC-variable of R1);
assume L425: R11 <> R27;
L426: R9 <> R27 by L425 , L422 , TARSKI:def 1;
thus L427: ( R13 . R27 ) = ( R12 . R27 ) by L409 , L425
.= ( R25 . R27 ) by L404 , L426;
end;
thus L428: (for R27 being (bound_QC-variable of R1) holds (R11 <> R27 implies ( D17 . R27 ) = ( R25 . R27 ))) by L424;
end;
L429: ( ( FOR_ALL (R11 , ( Valid (R17 , R19) )) ) . R25 ) = ( FALSE ) by L421 , L402 , L410 , L21 , XBOOLE_0:def 5;
thus L430: thesis by L429 , L406 , L143;
end;
L431:
now
assume L432: ( ( Valid (( All (R11 , R17) ) , R19) ) . R12 ) = ( TRUE );
L433: ( ( FOR_ALL (R11 , ( Valid (R17 , R19) )) ) . R12 ) = ( TRUE ) by L432 , L143;
L434: (for R13 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R27 being (bound_QC-variable of R1) holds (R11 <> R27 implies ( R13 . R27 ) = ( R25 . R27 ))) implies ( ( Valid (R17 , R19) ) . R13 ) = ( TRUE )))
proof
let R13 being (Element of ( Valuations_in (R1 , R5) ));
assume that
L435: (for R27 being (bound_QC-variable of R1) holds (R11 <> R27 implies ( R13 . R27 ) = ( R25 . R27 )));
L436:
now
assume L437: (not R9 in ( still_not-bound_in R17 ));
consider R26 being (Element of ( Valuations_in (R1 , R5) )) such that L438: ((for R27 being (bound_QC-variable of R1) holds (R27 <> R11 implies ( R26 . R27 ) = ( R12 . R27 ))) & ( R26 . R11 ) = ( R13 . R11 )) by L378;
L439: (for R27 being (bound_QC-variable of R1) holds (R9 <> R27 implies ( R26 . R27 ) = ( R13 . R27 )))
proof
let R27 being (bound_QC-variable of R1);
assume that
L440: R9 <> R27;
L441:
now
assume L442: R27 <> R11;
thus L443: ( R26 . R27 ) = ( R12 . R27 ) by L442 , L438
.= ( R25 . R27 ) by L404 , L440
.= ( R13 . R27 ) by L435 , L442;
end;
thus L444: thesis by L441 , L438;
end;
L445: ( ( Valid (R17 , R19) ) . R26 ) = ( TRUE ) by L433 , L438 , L33;
thus L446: thesis by L445 , L400 , L437 , L439;
end;
L447:
now
assume L448: R9 in { R11 };
L449: R9 = R11 by L448 , TARSKI:def 1;
L450: (for R27 being (bound_QC-variable of R1) holds (R11 <> R27 implies ( R13 . R27 ) = ( R12 . R27 )))
proof
let R27 being (bound_QC-variable of R1);
assume L451: R11 <> R27;
thus L452: ( R12 . R27 ) = ( R25 . R27 ) by L451 , L404 , L449
.= ( R13 . R27 ) by L435 , L451;
end;
thus L453: thesis by L450 , L433 , L33;
end;
thus L454: thesis by L447 , L402 , L436 , XBOOLE_0:def 5;
end;
L455: ( ( FOR_ALL (R11 , ( Valid (R17 , R19) )) ) . R25 ) = ( TRUE ) by L434 , L33;
thus L456: thesis by L455 , L432 , L143;
end;
thus L457: thesis by L431 , L405 , XBOOLEAN:def 3;
end;

end;

end;
L400: (for R17 being (Element of ( CQC-WFF R1 )) holds S3[ R17 ]) from CQC_LANG:sch 1(L382);
thus L401: thesis by L400;
end;
theorem
L402: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R9 being (bound_QC-variable of R1) holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds ((R19 , R12 |= R15 & (not R9 in ( still_not-bound_in R15 ))) implies (for R25 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 ))) implies R19 , R25 |= R15)))))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R9 being (bound_QC-variable of R1);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
assume that
L403: R19 , R12 |= R15
and
L404: (not R9 in ( still_not-bound_in R15 ));
L405:
now
let R25 being (Element of ( Valuations_in (R1 , R5) ));
assume L406: (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 )));
L407: ( ( Valid (R15 , R19) ) . R12 ) = ( TRUE ) by L403 , L235;
L408: ( ( Valid (R15 , R19) ) . R25 ) = ( TRUE ) by L407 , L404 , L406 , L381;
thus L409: R19 , R25 |= R15 by L408 , L235;
end;
thus L410: thesis by L405;
end;
theorem
L411: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R9 being (bound_QC-variable of R1) holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds (R19 , R12 |= ( All (R9 , R15) ) iff (for R25 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 ))) implies R19 , R25 |= R15)))))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R9 being (bound_QC-variable of R1);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
L412:
now
assume L413: (for R25 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 ))) implies R19 , R25 |= R15));
L414: (for R25 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 ))) implies ( ( Valid (R15 , R19) ) . R25 ) = ( TRUE )))
proof
let R25 being (Element of ( Valuations_in (R1 , R5) ));
assume L415: (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 )));
L416: R19 , R25 |= R15 by L415 , L413;
thus L417: thesis by L416 , L235;
end;
thus L418: R19 , R12 |= ( All (R9 , R15) ) by L414 , L290;
end;
L419:
now
assume L420: R19 , R12 |= ( All (R9 , R15) );
let R25 being (Element of ( Valuations_in (R1 , R5) ));
assume L421: (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R25 . R11 ) = ( R12 . R11 )));
L422: ( ( Valid (R15 , R19) ) . R25 ) = ( TRUE ) by L421 , L420 , L290;
thus L423: R19 , R25 |= R15 by L422 , L235;
end;
thus L424: thesis by L419 , L412;
end;
theorem
L425: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R9 being (bound_QC-variable of R1) holds (for R11 being (bound_QC-variable of R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds (for R30 being (QC-formula of R1) holds ((R9 <> R11 & R15 = ( R30 . R9 ) & R16 = ( R30 . R11 )) implies (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (( R12 . R9 ) = ( R12 . R11 ) implies ( ( Valid (R15 , R19) ) . R12 ) = ( ( Valid (R16 , R19) ) . R12 ))))))))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R9 being (bound_QC-variable of R1);
let R11 being (bound_QC-variable of R1);
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
let R30 being (QC-formula of R1);
defpred S4[ (Element of ( QC-WFF R1 )) ] means (for R9 being (bound_QC-variable of R1) holds (for R11 being (bound_QC-variable of R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds ((R9 <> R11 & R15 = ( $1 . R9 ) & R16 = ( $1 . R11 )) implies (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (( R12 . R9 ) = ( R12 . R11 ) implies ( ( Valid (R15 , R19) ) . R12 ) = ( ( Valid (R16 , R19) ) . R12 ))))))));
L426:
now
let C68 being (Element of ( QC-WFF R1 ));
thus L427: (C68 is  atomic implies S4[ C68 ])
proof
assume L428: C68 is  atomic;
thus L429: (for R9 being (bound_QC-variable of R1) holds (for R11 being (bound_QC-variable of R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds ((R9 <> R11 & R15 = ( C68 . R9 ) & R16 = ( C68 . R11 )) implies (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (( R12 . R9 ) = ( R12 . R11 ) implies ( ( Valid (R15 , R19) ) . R12 ) = ( ( Valid (R16 , R19) ) . R12 ))))))))
proof
consider C69 being (Element of ( NAT )), C70 being (QC-pred_symbol of C69 , R1), C71 being (QC-variable_list of C69 , R1) such that L430: C68 = ( C70 ! C71 ) by L428 , QC_LANG1:def 18;
let R9 being (bound_QC-variable of R1);
let R11 being (bound_QC-variable of R1);
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
assume that
L431: R9 <> R11
and
L432: R15 = ( C68 . R9 )
and
L433: R16 = ( C68 . R11 );
set D18 = ( Subst (C71 , ( ( R1 a. ( 0 ) ) .--> R9 )) );
set D19 = ( Subst (C71 , ( ( R1 a. ( 0 ) ) .--> R11 )) );
let R12 being (Element of ( Valuations_in (R1 , R5) ));
assume that
L434: ( R12 . R9 ) = ( R12 . R11 );
L435: R15 = ( C70 ! ( Subst (C71 , ( ( R1 a. ( 0 ) ) .--> R9 )) ) ) by L432 , L430 , CQC_LANG:17;
L436: { ( D18 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len D18 ) & ( D18 . R2 ) in ( free_QC-variables R1 )) } = ( {} ) by L435 , CQC_LANG:7;
L437: R16 = ( C70 ! ( Subst (C71 , ( ( R1 a. ( 0 ) ) .--> R11 )) ) ) by L433 , L430 , CQC_LANG:17;
L438: { ( D19 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len D19 ) & ( D19 . R2 ) in ( free_QC-variables R1 )) } = ( {} ) by L437 , CQC_LANG:7;
L439: { ( D19 . R3 ) where R3 is (Element of ( NAT )) : (1 <= R3 & R3 <= ( len D19 ) & ( D19 . R3 ) in ( fixed_QC-variables R1 )) } = ( {} ) by L437 , CQC_LANG:7;
L440: { ( D18 . R3 ) where R3 is (Element of ( NAT )) : (1 <= R3 & R3 <= ( len D18 ) & ( D18 . R3 ) in ( fixed_QC-variables R1 )) } = ( {} ) by L435 , CQC_LANG:7;
reconsider D20 = D18 , D21 = D19 as (CQC-variable_list of C69 , R1) by L440 , L436 , L438 , L439 , CQC_LANG:5;
L441: ( len ( R12 *' D20 ) ) = C69 by L47;
L442:
now
let C72 being Nat;
assume that
L443: 1 <= C72
and
L444: C72 <= ( len ( R12 *' D20 ) );
L445: C72 in ( NAT ) by ORDINAL1:def 12;
L446: C72 <= ( len C71 ) by L441 , L444 , CARD_1:def 7;
L447:
now
assume L448: ( C71 . C72 ) <> ( R1 a. ( 0 ) );
L449: (( D20 . C72 ) = ( C71 . C72 ) & ( D21 . C72 ) = ( C71 . C72 )) by L448 , L443 , L446 , L445 , CQC_LANG:3;
L450: ( R12 . ( D20 . C72 ) ) = ( ( R12 *' D20 ) . C72 ) by L441 , L443 , L444 , L47;
thus L451: ( ( R12 *' D20 ) . C72 ) = ( ( R12 *' D21 ) . C72 ) by L450 , L441 , L443 , L444 , L449 , L47;
end;
L452:
now
assume L453: ( C71 . C72 ) = ( R1 a. ( 0 ) );
L454: (( D20 . C72 ) = R9 & ( D21 . C72 ) = R11) by L453 , L443 , L446 , L445 , CQC_LANG:3;
L455: ( R12 . ( D20 . C72 ) ) = ( ( R12 *' D20 ) . C72 ) by L441 , L443 , L444 , L47;
thus L456: ( ( R12 *' D20 ) . C72 ) = ( ( R12 *' D21 ) . C72 ) by L455 , L434 , L441 , L443 , L444 , L454 , L47;
end;
thus L457: ( ( R12 *' D20 ) . C72 ) = ( ( R12 *' D21 ) . C72 ) by L452 , L447;
end;
L458: ( len ( R12 *' D21 ) ) = C69 by L47;
L459: ( R12 *' D20 ) = ( R12 *' D21 ) by L458 , L441 , L442 , FINSEQ_1:14;
L460:
now
assume L461: ( ( Valid (R15 , R19) ) . R12 ) = ( FALSE );
L462: (not ( R12 *' D20 ) in ( R19 . C70 )) by L461 , L435 , L203;
thus L463: ( ( Valid (R16 , R19) ) . R12 ) = ( FALSE ) by L462 , L437 , L459 , L203;
end;
L464:
now
assume L465: ( ( Valid (R15 , R19) ) . R12 ) = ( TRUE );
L466: ( R12 *' D20 ) in ( R19 . C70 ) by L465 , L435 , L191;
thus L467: ( ( Valid (R16 , R19) ) . R12 ) = ( TRUE ) by L466 , L437 , L459 , L191;
end;
thus L468: thesis by L464 , L460 , XBOOLEAN:def 3;
end;

end;

thus L430: S4[ ( VERUM R1 ) ]
proof
let R9 being (bound_QC-variable of R1);
let R11 being (bound_QC-variable of R1);
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
assume that
L431: R9 <> R11
and
L432: R15 = ( ( VERUM R1 ) . R9 )
and
L433: R16 = ( ( VERUM R1 ) . R11 );
let R12 being (Element of ( Valuations_in (R1 , R5) ));
assume that
L434: ( R12 . R9 ) = ( R12 . R11 );
L435: R15 = ( VERUM R1 ) by L432 , CQC_LANG:15;
thus L436: thesis by L435 , L433 , CQC_LANG:15;
end;

thus L437: ((C68 is  negative & S4[ ( the_argument_of C68 ) ]) implies S4[ C68 ])
proof
assume that
L438: C68 is  negative
and
L439: (for R9 being (bound_QC-variable of R1) holds (for R11 being (bound_QC-variable of R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds ((R9 <> R11 & R15 = ( ( the_argument_of C68 ) . R9 ) & R16 = ( ( the_argument_of C68 ) . R11 )) implies (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (( R12 . R9 ) = ( R12 . R11 ) implies ( ( Valid (R15 , R19) ) . R12 ) = ( ( Valid (R16 , R19) ) . R12 ))))))));
thus L440: (for R9 being (bound_QC-variable of R1) holds (for R11 being (bound_QC-variable of R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds ((R9 <> R11 & R15 = ( C68 . R9 ) & R16 = ( C68 . R11 )) implies (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (( R12 . R9 ) = ( R12 . R11 ) implies ( ( Valid (R15 , R19) ) . R12 ) = ( ( Valid (R16 , R19) ) . R12 ))))))))
proof
let R9 being (bound_QC-variable of R1);
let R11 being (bound_QC-variable of R1);
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
assume that
L441: R9 <> R11
and
L442: R15 = ( C68 . R9 )
and
L443: R16 = ( C68 . R11 );
L444: ( C68 . R11 ) = ( 'not' ( ( the_argument_of C68 ) . R11 ) ) by L438 , CQC_LANG:18;
reconsider D22 = ( ( the_argument_of C68 ) . R11 ) as (Element of ( CQC-WFF R1 )) by L444 , L443 , CQC_LANG:8;
L445: ( C68 . R9 ) = ( 'not' ( ( the_argument_of C68 ) . R9 ) ) by L438 , CQC_LANG:18;
reconsider D23 = ( ( the_argument_of C68 ) . R9 ) as (Element of ( CQC-WFF R1 )) by L445 , L442 , CQC_LANG:8;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
assume that
L446: ( R12 . R9 ) = ( R12 . R11 );
L447:
now
assume L448: ( ( Valid (R15 , R19) ) . R12 ) = ( FALSE );
L449: ( 'not' ( ( Valid (D23 , R19) ) . R12 ) ) = ( FALSE ) by L448 , L442 , L445 , L216;
L450: ( ( Valid (D23 , R19) ) . R12 ) = ( TRUE ) by L449 , MARGREL1:11;
L451: ( ( Valid (D22 , R19) ) . R12 ) = ( TRUE ) by L450 , L439 , L446;
L452: ( 'not' ( ( Valid (D22 , R19) ) . R12 ) ) = ( FALSE ) by L451 , MARGREL1:11;
thus L453: ( ( Valid (R16 , R19) ) . R12 ) = ( FALSE ) by L452 , L443 , L444 , L216;
end;
L454:
now
assume L455: ( ( Valid (R15 , R19) ) . R12 ) = ( TRUE );
L456: ( 'not' ( ( Valid (D23 , R19) ) . R12 ) ) = ( TRUE ) by L455 , L442 , L445 , L216;
L457: ( ( Valid (D23 , R19) ) . R12 ) = ( FALSE ) by L456 , MARGREL1:11;
L458: ( ( Valid (D22 , R19) ) . R12 ) = ( FALSE ) by L457 , L439 , L446;
L459: ( 'not' ( ( Valid (D22 , R19) ) . R12 ) ) = ( TRUE ) by L458 , MARGREL1:11;
thus L460: ( ( Valid (R16 , R19) ) . R12 ) = ( TRUE ) by L459 , L443 , L444 , L216;
end;
thus L461: thesis by L454 , L447 , XBOOLEAN:def 3;
end;

end;

thus L441: ((C68 is  conjunctive & S4[ ( the_left_argument_of C68 ) ] & S4[ ( the_right_argument_of C68 ) ]) implies S4[ C68 ])
proof
assume that
L442: C68 is  conjunctive
and
L443: (for R9 being (bound_QC-variable of R1) holds (for R11 being (bound_QC-variable of R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds ((R9 <> R11 & R15 = ( ( the_left_argument_of C68 ) . R9 ) & R16 = ( ( the_left_argument_of C68 ) . R11 )) implies (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (( R12 . R9 ) = ( R12 . R11 ) implies ( ( Valid (R15 , R19) ) . R12 ) = ( ( Valid (R16 , R19) ) . R12 ))))))))
and
L444: (for R9 being (bound_QC-variable of R1) holds (for R11 being (bound_QC-variable of R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds ((R9 <> R11 & R15 = ( ( the_right_argument_of C68 ) . R9 ) & R16 = ( ( the_right_argument_of C68 ) . R11 )) implies (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (( R12 . R9 ) = ( R12 . R11 ) implies ( ( Valid (R15 , R19) ) . R12 ) = ( ( Valid (R16 , R19) ) . R12 ))))))));
thus L445: (for R9 being (bound_QC-variable of R1) holds (for R11 being (bound_QC-variable of R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds ((R9 <> R11 & R15 = ( C68 . R9 ) & R16 = ( C68 . R11 )) implies (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (( R12 . R9 ) = ( R12 . R11 ) implies ( ( Valid (R15 , R19) ) . R12 ) = ( ( Valid (R16 , R19) ) . R12 ))))))))
proof
let R9 being (bound_QC-variable of R1);
let R11 being (bound_QC-variable of R1);
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
assume that
L446: R9 <> R11
and
L447: R15 = ( C68 . R9 )
and
L448: R16 = ( C68 . R11 );
L449: ( C68 . R9 ) = ( ( ( the_left_argument_of C68 ) . R9 ) '&' ( ( the_right_argument_of C68 ) . R9 ) ) by L442 , CQC_LANG:20;
reconsider D24 = ( ( the_left_argument_of C68 ) . R9 ) , D25 = ( ( the_right_argument_of C68 ) . R9 ) as (Element of ( CQC-WFF R1 )) by L449 , L447 , CQC_LANG:9;
L450: ( C68 . R11 ) = ( ( ( the_left_argument_of C68 ) . R11 ) '&' ( ( the_right_argument_of C68 ) . R11 ) ) by L442 , CQC_LANG:20;
reconsider D26 = ( ( the_left_argument_of C68 ) . R11 ) , D27 = ( ( the_right_argument_of C68 ) . R11 ) as (Element of ( CQC-WFF R1 )) by L450 , L448 , CQC_LANG:9;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
assume that
L451: ( R12 . R9 ) = ( R12 . R11 );
L452:
now
assume L453: ( ( Valid (R15 , R19) ) . R12 ) = ( FALSE );
L454:
now
assume L455: ( ( Valid (D24 , R19) ) . R12 ) = ( FALSE );
L456: ( ( Valid (D26 , R19) ) . R12 ) = ( FALSE ) by L455 , L443 , L451;
L457: ( ( ( Valid (D26 , R19) ) . R12 ) '&' ( ( Valid (D27 , R19) ) . R12 ) ) = ( FALSE ) by L456 , MARGREL1:12;
thus L458: thesis by L457 , L448 , L450 , L453 , L220;
end;
L459:
now
assume L460: ( ( Valid (D25 , R19) ) . R12 ) = ( FALSE );
L461: ( ( Valid (D27 , R19) ) . R12 ) = ( FALSE ) by L460 , L444 , L451;
L462: ( ( ( Valid (D26 , R19) ) . R12 ) '&' ( ( Valid (D27 , R19) ) . R12 ) ) = ( FALSE ) by L461 , MARGREL1:12;
thus L463: thesis by L462 , L448 , L450 , L453 , L220;
end;
L464: ( ( ( Valid (D24 , R19) ) . R12 ) '&' ( ( Valid (D25 , R19) ) . R12 ) ) = ( FALSE ) by L447 , L449 , L453 , L220;
thus L465: thesis by L464 , L454 , L459 , MARGREL1:12;
end;
L466:
now
assume L467: ( ( Valid (R15 , R19) ) . R12 ) = ( TRUE );
L468: ( ( ( Valid (D24 , R19) ) . R12 ) '&' ( ( Valid (D25 , R19) ) . R12 ) ) = ( TRUE ) by L467 , L447 , L449 , L220;
L469: ( ( Valid (D25 , R19) ) . R12 ) = ( TRUE ) by L468 , MARGREL1:12;
L470: ( ( Valid (D27 , R19) ) . R12 ) = ( TRUE ) by L469 , L444 , L451;
L471: ( ( Valid (D24 , R19) ) . R12 ) = ( TRUE ) by L468 , MARGREL1:12;
L472: ( ( Valid (D26 , R19) ) . R12 ) = ( TRUE ) by L471 , L443 , L451;
L473: ( ( ( Valid (D26 , R19) ) . R12 ) '&' ( ( Valid (D27 , R19) ) . R12 ) ) = ( TRUE ) by L472 , L470;
thus L474: ( ( Valid (R16 , R19) ) . R12 ) = ( TRUE ) by L473 , L448 , L450 , L220;
end;
thus L475: thesis by L466 , L452 , XBOOLEAN:def 3;
end;

end;

thus L446: ((C68 is  universal & S4[ ( the_scope_of C68 ) ]) implies S4[ C68 ])
proof
assume that
L447: C68 is  universal
and
L448: (for R9 being (bound_QC-variable of R1) holds (for R11 being (bound_QC-variable of R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds ((R9 <> R11 & R15 = ( ( the_scope_of C68 ) . R9 ) & R16 = ( ( the_scope_of C68 ) . R11 )) implies (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (( R12 . R9 ) = ( R12 . R11 ) implies ( ( Valid (R15 , R19) ) . R12 ) = ( ( Valid (R16 , R19) ) . R12 ))))))));
consider C73 being (bound_QC-variable of R1), C74 being (Element of ( QC-WFF R1 )) such that L449: C68 = ( All (C73 , C74) ) by L447 , QC_LANG1:def 21;
L450: C73 = ( bound_in C68 ) by L447 , L449 , QC_LANG1:def 27;
thus L451: (for R9 being (bound_QC-variable of R1) holds (for R11 being (bound_QC-variable of R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds ((R9 <> R11 & R15 = ( C68 . R9 ) & R16 = ( C68 . R11 )) implies (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (( R12 . R9 ) = ( R12 . R11 ) implies ( ( Valid (R15 , R19) ) . R12 ) = ( ( Valid (R16 , R19) ) . R12 ))))))))
proof
let R9 being (bound_QC-variable of R1);
let R11 being (bound_QC-variable of R1);
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
assume that
L452: R9 <> R11
and
L453: R15 = ( C68 . R9 )
and
L454: R16 = ( C68 . R11 );
let R12 being (Element of ( Valuations_in (R1 , R5) ));
assume that
L455: ( R12 . R9 ) = ( R12 . R11 );
L456:
now
assume L457: R9 <> ( bound_in C68 );
L458: ( C68 . R9 ) = ( All (( bound_in C68 ) , ( ( the_scope_of C68 ) . R9 )) ) by L457 , L447 , CQC_LANG:23;
reconsider D28 = ( ( the_scope_of C68 ) . R9 ) as (Element of ( CQC-WFF R1 )) by L458 , L453 , CQC_LANG:13;
L459: ( All (( bound_in C68 ) , D28) ) = R15 by L447 , L453 , L457 , CQC_LANG:23;
L460:
now
assume L461: R11 <> ( bound_in C68 );
L462: ( C68 . R11 ) = ( All (( bound_in C68 ) , ( ( the_scope_of C68 ) . R11 )) ) by L461 , L447 , CQC_LANG:23;
reconsider D29 = ( ( the_scope_of C68 ) . R11 ) as (Element of ( CQC-WFF R1 )) by L462 , L454 , CQC_LANG:13;
L463: ( Valid (( All (( bound_in C68 ) , D29) ) , R19) ) = ( FOR_ALL (( bound_in C68 ) , ( Valid (D29 , R19) )) ) by L143;
L464: ( Valid (( All (( bound_in C68 ) , D28) ) , R19) ) = ( FOR_ALL (( bound_in C68 ) , ( Valid (D28 , R19) )) ) by L143;
L465: ( All (( bound_in C68 ) , D29) ) = R16 by L447 , L454 , L461 , CQC_LANG:23;
L466:
now
assume L467: ( ( Valid (R15 , R19) ) . R12 ) = ( TRUE );
L468: (for R13 being (Element of ( Valuations_in (R1 , R5) )) holds ((for R11 being (bound_QC-variable of R1) holds (( bound_in C68 ) <> R11 implies ( R13 . R11 ) = ( R12 . R11 ))) implies ( ( Valid (D29 , R19) ) . R13 ) = ( TRUE )))
proof
let R13 being (Element of ( Valuations_in (R1 , R5) ));
assume L469: (for R11 being (bound_QC-variable of R1) holds (( bound_in C68 ) <> R11 implies ( R13 . R11 ) = ( R12 . R11 )));
L470: (( R13 . R9 ) = ( R12 . R9 ) & ( R13 . R11 ) = ( R12 . R11 )) by L469 , L457 , L461;
L471: ( ( Valid (D28 , R19) ) . R13 ) = ( TRUE ) by L459 , L464 , L467 , L469 , L33;
thus L472: thesis by L471 , L448 , L455 , L470;
end;
thus L473: ( ( Valid (R16 , R19) ) . R12 ) = ( TRUE ) by L468 , L465 , L463 , L33;
end;
L474:
now
assume L475: ( ( Valid (R15 , R19) ) . R12 ) = ( FALSE );
L476: (ex R13 being (Element of ( Valuations_in (R1 , R5) )) st (( ( Valid (D29 , R19) ) . R13 ) = ( FALSE ) & (for R11 being (bound_QC-variable of R1) holds (( bound_in C68 ) <> R11 implies ( R13 . R11 ) = ( R12 . R11 )))))
proof
consider R13 being (Element of ( Valuations_in (R1 , R5) )) such that L477: ( ( Valid (D28 , R19) ) . R13 ) = ( FALSE ) and L478: (for R11 being (bound_QC-variable of R1) holds (( bound_in C68 ) <> R11 implies ( R13 . R11 ) = ( R12 . R11 ))) by L459 , L464 , L475 , L21;
L479: (( R13 . R9 ) = ( R12 . R9 ) & ( R13 . R11 ) = ( R12 . R11 )) by L457 , L461 , L478;
L480: ( ( Valid (D29 , R19) ) . R13 ) = ( FALSE ) by L479 , L448 , L455 , L477;
thus L481: thesis by L480 , L478;
end;
thus L482: ( ( Valid (R16 , R19) ) . R12 ) = ( FALSE ) by L476 , L465 , L463 , L21;
end;
thus L483: thesis by L474 , L466 , XBOOLEAN:def 3;
end;
L484:
now
assume L485: R11 = ( bound_in C68 );
L486: R16 = ( All (R11 , C74) ) by L485 , L449 , L450 , L454 , CQC_LANG:24;
thus L487: thesis by L486 , L449 , L450 , L453 , L485 , CQC_LANG:27;
end;
thus L488: thesis by L484 , L460;
end;
L489:
now
assume L490: R9 = ( bound_in C68 );
L491: R15 = ( All (R9 , C74) ) by L490 , L449 , L450 , L453 , CQC_LANG:24;
thus L492: thesis by L491 , L449 , L450 , L454 , L490 , CQC_LANG:27;
end;
thus L493: thesis by L489 , L456;
end;

end;

end;
L447: (for B106 being (Element of ( QC-WFF R1 )) holds S4[ B106 ]) from QC_LANG1:sch 2(L426);
thus L448: thesis by L447;
end;
theorem
L449: (for R1 being QC-alphabet holds (for R9 being (bound_QC-variable of R1) holds (for R11 being (bound_QC-variable of R1) holds (for R30 being (QC-formula of R1) holds ((R9 <> R11 & (not R9 in ( still_not-bound_in R30 ))) implies (not R9 in ( still_not-bound_in ( R30 . R11 ) )))))))
proof
let R1 being QC-alphabet;
let R9 being (bound_QC-variable of R1);
let R11 being (bound_QC-variable of R1);
let R30 being (QC-formula of R1);
defpred S5[ (Element of ( QC-WFF R1 )) ] means ((R9 <> R11 & (not R9 in ( still_not-bound_in $1 ))) implies (not R9 in ( still_not-bound_in ( $1 . R11 ) )));
L450:
now
let C75 being (Element of ( QC-WFF R1 ));
thus L451: (C75 is  atomic implies S5[ C75 ])
proof
assume that
L452: C75 is  atomic
and
L453: R9 <> R11
and
L454: (not R9 in ( still_not-bound_in C75 ));
thus L455: (not R9 in ( still_not-bound_in ( C75 . R11 ) ))
proof
set D30 = ( the_arguments_of C75 );
set D31 = ( Subst (D30 , ( ( R1 a. ( 0 ) ) .--> R11 )) );
L456: ( still_not-bound_in C75 ) = ( still_not-bound_in D30 ) by L452 , QC_LANG3:4
.= ( variables_in (D30 , ( bound_QC-variables R1 )) ) by QC_LANG3:2
.= { ( D30 . R4 ) where R4 is (Element of ( NAT )) : (1 <= R4 & R4 <= ( len D30 ) & ( D30 . R4 ) in ( bound_QC-variables R1 )) } by QC_LANG3:def 1;
L457: (R9 in { ( D31 . R4 ) where R4 is (Element of ( NAT )) : (1 <= R4 & R4 <= ( len D31 ) & ( D31 . R4 ) in ( bound_QC-variables R1 )) } implies R9 in { ( D30 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len D30 ) & ( D30 . R2 ) in ( bound_QC-variables R1 )) })
proof
assume L458: R9 in { ( D31 . R4 ) where R4 is (Element of ( NAT )) : (1 <= R4 & R4 <= ( len D31 ) & ( D31 . R4 ) in ( bound_QC-variables R1 )) };
consider R4 being (Element of ( NAT )) such that L459: R9 = ( D31 . R4 ) and L460: 1 <= R4 and L461: R4 <= ( len D31 ) and L462: ( D31 . R4 ) in ( bound_QC-variables R1 ) by L458;
L463: R4 <= ( len D30 ) by L461 , CQC_LANG:def 1;
L464: R9 = ( D30 . R4 ) by L463 , L453 , L459 , L460 , CQC_LANG:3;
thus L465: thesis by L464 , L460 , L463;
end;
L466: ( C75 . R11 ) = ( ( the_pred_symbol_of C75 ) ! ( Subst (D30 , ( ( R1 a. ( 0 ) ) .--> R11 )) ) ) by L452 , CQC_LANG:16;
L467: (( C75 . R11 ) is  atomic & ( the_arguments_of ( C75 . R11 ) ) = D31)
proof
consider C76 being (Element of ( NAT )), C77 being (QC-pred_symbol of C76 , R1), C78 being (QC-variable_list of C76 , R1) such that L468: C75 = ( C77 ! C78 ) by L452 , QC_LANG1:def 18;
L469: C78 = D30 by L452 , L468 , QC_LANG1:def 23;
reconsider D32 = ( Subst (D30 , ( ( R1 a. ( 0 ) ) .--> R11 )) ) as (QC-variable_list of C76 , R1) by L469;
L470: ( C75 . R11 ) = ( C77 ! D32 ) by L452 , L466 , L468 , QC_LANG1:def 22;
thus L471: ( C75 . R11 ) is  atomic by L470 , QC_LANG1:def 18;
thus L472: thesis by L471 , L470 , QC_LANG1:def 23;
end;
L473: ( still_not-bound_in ( the_arguments_of ( C75 . R11 ) ) ) = ( variables_in (D31 , ( bound_QC-variables R1 )) ) by L467 , QC_LANG3:2
.= { ( D31 . R4 ) where R4 is (Element of ( NAT )) : (1 <= R4 & R4 <= ( len D31 ) & ( D31 . R4 ) in ( bound_QC-variables R1 )) } by QC_LANG3:def 1;
thus L474: thesis by L473 , L454 , L456 , L467 , L457 , QC_LANG3:4;
end;

end;

thus L456: S5[ ( VERUM R1 ) ] by CQC_LANG:15;
thus L457: ((C75 is  negative & S5[ ( the_argument_of C75 ) ]) implies S5[ C75 ])
proof
assume that
L458: C75 is  negative
and
L459: (((R9 <> R11 & (not R9 in ( still_not-bound_in ( the_argument_of C75 ) ))) implies (not R9 in ( still_not-bound_in ( ( the_argument_of C75 ) . R11 ) ))) & R9 <> R11 & (not R9 in ( still_not-bound_in C75 )));
L460: (not R9 in ( still_not-bound_in ( 'not' ( ( the_argument_of C75 ) . R11 ) ) )) by L458 , L459 , QC_LANG3:6 , QC_LANG3:7;
thus L461: thesis by L460 , L458 , CQC_LANG:18;
end;

thus L462: ((C75 is  conjunctive & S5[ ( the_left_argument_of C75 ) ] & S5[ ( the_right_argument_of C75 ) ]) implies S5[ C75 ])
proof
assume that
L463: C75 is  conjunctive
and
L464: (((R9 <> R11 & (not R9 in ( still_not-bound_in ( the_left_argument_of C75 ) ))) implies (not R9 in ( still_not-bound_in ( ( the_left_argument_of C75 ) . R11 ) ))) & ((R9 <> R11 & (not R9 in ( still_not-bound_in ( the_right_argument_of C75 ) ))) implies (not R9 in ( still_not-bound_in ( ( the_right_argument_of C75 ) . R11 ) ))) & R9 <> R11 & (not R9 in ( still_not-bound_in C75 )));
L465: ( still_not-bound_in C75 ) = ( ( still_not-bound_in ( the_left_argument_of C75 ) ) \/ ( still_not-bound_in ( the_right_argument_of C75 ) ) ) by L463 , QC_LANG3:9;
L466: (not R9 in ( ( still_not-bound_in ( ( the_left_argument_of C75 ) . R11 ) ) \/ ( still_not-bound_in ( ( the_right_argument_of C75 ) . R11 ) ) )) by L465 , L464 , XBOOLE_0:def 3;
L467: (not R9 in ( still_not-bound_in ( ( ( the_left_argument_of C75 ) . R11 ) '&' ( ( the_right_argument_of C75 ) . R11 ) ) )) by L466 , QC_LANG3:10;
thus L468: thesis by L467 , L463 , CQC_LANG:20;
end;

thus L469: ((C75 is  universal & S5[ ( the_scope_of C75 ) ]) implies S5[ C75 ])
proof
assume that
L470: C75 is  universal
and
L471: ((R9 <> R11 & (not R9 in ( still_not-bound_in ( the_scope_of C75 ) ))) implies (not R9 in ( still_not-bound_in ( ( the_scope_of C75 ) . R11 ) )))
and
L472: R9 <> R11
and
L473: (not R9 in ( still_not-bound_in C75 ));
L474: ( still_not-bound_in C75 ) = ( ( still_not-bound_in ( the_scope_of C75 ) ) \ { ( bound_in C75 ) } ) by L470 , QC_LANG3:11;
thus L475: (not R9 in ( still_not-bound_in ( C75 . R11 ) ))
proof
L476:
now
L477: ( still_not-bound_in ( All (R9 , ( ( the_scope_of C75 ) . R11 )) ) ) = ( ( still_not-bound_in ( ( the_scope_of C75 ) . R11 ) ) \ { R9 } ) by QC_LANG3:12;
L478: ((not R9 in ( still_not-bound_in ( All (R9 , ( ( the_scope_of C75 ) . R11 )) ) )) iff ((not R9 in ( still_not-bound_in ( ( the_scope_of C75 ) . R11 ) )) or R9 in { R9 })) by L477 , XBOOLE_0:def 5;
assume L479: R9 in { ( bound_in C75 ) };
L480: R9 = ( bound_in C75 ) by L479 , TARSKI:def 1;
thus L481: thesis by L480 , L470 , L472 , L478 , CQC_LANG:23 , TARSKI:def 1;
end;
L482:
now
assume L483: (not R9 in ( still_not-bound_in ( the_scope_of C75 ) ));
L484: (not R9 in ( ( still_not-bound_in ( ( the_scope_of C75 ) . R11 ) ) \ { ( bound_in C75 ) } )) by L483 , L471 , L472 , XBOOLE_0:def 5;
L485: (not R9 in ( still_not-bound_in ( All (( bound_in C75 ) , ( ( the_scope_of C75 ) . R11 )) ) )) by L484 , QC_LANG3:12;
thus L486: thesis by L485 , L470 , L473 , CQC_LANG:22 , CQC_LANG:23;
end;
thus L487: thesis by L482 , L473 , L474 , L476 , XBOOLE_0:def 5;
end;

end;

end;
L470: (for B107 being (Element of ( QC-WFF R1 )) holds S5[ B107 ]) from QC_LANG1:sch 2(L450);
thus L471: thesis by L470;
end;
theorem
L472: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R19 being (interpretation of R1 , R5) holds R19 , R12 |= ( VERUM R1 )))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R19 being (interpretation of R1 , R5);
L473: ( ( ( Valuations_in (R1 , R5) ) --> ( TRUE ) ) . R12 ) = ( TRUE ) by FUNCOP_1:7;
L474: ( ( Valid (( VERUM R1 ) , R19) ) . R12 ) = ( TRUE ) by L473 , L143;
thus L475: thesis by L474 , L235;
end;
theorem
L476: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds R19 , R12 |= ( ( R15 '&' R16 ) => ( R16 '&' R15 ) )))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
thus L477: ( ( Valid (( ( R15 '&' R16 ) => ( R16 '&' R15 ) ) , R19) ) . R12 ) = ( TRUE )
proof
assume L478: (not ( ( Valid (( ( R15 '&' R16 ) => ( R16 '&' R15 ) ) , R19) ) . R12 ) = ( TRUE ));
L479: ( ( Valid (( ( R15 '&' R16 ) => ( R16 '&' R15 ) ) , R19) ) . R12 ) = ( FALSE ) by L478 , XBOOLEAN:def 3;
L480: ( ( Valid (( ( R15 '&' R16 ) => ( R16 '&' R15 ) ) , R19) ) . R12 ) = ( ( Valid (( 'not' ( ( R15 '&' R16 ) '&' ( 'not' ( R16 '&' R15 ) ) ) ) , R19) ) . R12 ) by QC_LANG2:def 2
.= ( 'not' ( ( Valid (( ( R15 '&' R16 ) '&' ( 'not' ( R16 '&' R15 ) ) ) , R19) ) . R12 ) ) by L216
.= ( 'not' ( ( ( Valid (( R15 '&' R16 ) , R19) ) . R12 ) '&' ( ( Valid (( 'not' ( R16 '&' R15 ) ) , R19) ) . R12 ) ) ) by L220
.= ( 'not' ( ( ( Valid (( R15 '&' R16 ) , R19) ) . R12 ) '&' ( 'not' ( ( Valid (( R16 '&' R15 ) , R19) ) . R12 ) ) ) ) by L216;
L481: ( ( ( Valid (( R15 '&' R16 ) , R19) ) . R12 ) '&' ( 'not' ( ( Valid (( R16 '&' R15 ) , R19) ) . R12 ) ) ) = ( TRUE ) by L480 , L479 , MARGREL1:11;
L482: ( 'not' ( ( Valid (( R16 '&' R15 ) , R19) ) . R12 ) ) = ( TRUE ) by L481 , MARGREL1:12;
L483: ( ( Valid (( R16 '&' R15 ) , R19) ) . R12 ) = ( FALSE ) by L482 , MARGREL1:11;
L484: ( ( Valid (( R15 '&' R16 ) , R19) ) . R12 ) = ( TRUE ) by L481 , MARGREL1:12;
L485: ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( ( Valid (R16 , R19) ) . R12 ) ) = ( TRUE ) by L484 , L220;
thus L486: thesis by L485 , L483 , L220;
end;

end;
theorem
L478: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds R19 , R12 |= ( ( ( 'not' R15 ) => R15 ) => R15 ))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
L479: ( ( 'not' R15 ) => R15 ) = ( 'not' ( ( 'not' R15 ) '&' ( 'not' R15 ) ) ) by QC_LANG2:def 2;
L480: ( ( Valid (( ( ( 'not' R15 ) => R15 ) => R15 ) , R19) ) . R12 ) = ( ( Valid (( 'not' ( ( 'not' ( ( 'not' R15 ) '&' ( 'not' R15 ) ) ) '&' ( 'not' R15 ) ) ) , R19) ) . R12 ) by L479 , QC_LANG2:def 2
.= ( 'not' ( ( Valid (( ( 'not' ( ( 'not' R15 ) '&' ( 'not' R15 ) ) ) '&' ( 'not' R15 ) ) , R19) ) . R12 ) ) by L216
.= ( 'not' ( ( ( Valid (( 'not' ( ( 'not' R15 ) '&' ( 'not' R15 ) ) ) , R19) ) . R12 ) '&' ( ( Valid (( 'not' R15 ) , R19) ) . R12 ) ) ) by L220;
L481: ( ( Valid (( 'not' ( ( 'not' R15 ) '&' ( 'not' R15 ) ) ) , R19) ) . R12 ) = ( 'not' ( ( Valid (( ( 'not' R15 ) '&' ( 'not' R15 ) ) , R19) ) . R12 ) ) by L216
.= ( 'not' ( ( Valid (( 'not' R15 ) , R19) ) . R12 ) ) by L302
.= ( 'not' ( 'not' ( ( Valid (R15 , R19) ) . R12 ) ) ) by L216
.= ( ( Valid (R15 , R19) ) . R12 );
L482: ( ( Valid (( ( ( 'not' R15 ) => R15 ) => R15 ) , R19) ) . R12 ) = ( 'not' ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( 'not' ( ( Valid (R15 , R19) ) . R12 ) ) ) ) by L481 , L480 , L216
.= ( TRUE ) by XBOOLEAN:102;
thus L483: ( ( Valid (( ( ( 'not' R15 ) => R15 ) => R15 ) , R19) ) . R12 ) = ( TRUE ) by L482;
end;
theorem
L484: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds R19 , R12 |= ( R15 => ( ( 'not' R15 ) => R16 ) )))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
L485: ( ( 'not' R15 ) => R16 ) = ( 'not' ( ( 'not' R15 ) '&' ( 'not' R16 ) ) ) by QC_LANG2:def 2;
L486: ( ( Valid (( R15 => ( ( 'not' R15 ) => R16 ) ) , R19) ) . R12 ) = ( ( Valid (( 'not' ( R15 '&' ( 'not' ( 'not' ( ( 'not' R15 ) '&' ( 'not' R16 ) ) ) ) ) ) , R19) ) . R12 ) by L485 , QC_LANG2:def 2
.= ( 'not' ( ( Valid (( R15 '&' ( 'not' ( 'not' ( ( 'not' R15 ) '&' ( 'not' R16 ) ) ) ) ) , R19) ) . R12 ) ) by L216
.= ( 'not' ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( ( Valid (( 'not' ( 'not' ( ( 'not' R15 ) '&' ( 'not' R16 ) ) ) ) , R19) ) . R12 ) ) ) by L220;
L487: ( ( Valid (( 'not' ( 'not' ( ( 'not' R15 ) '&' ( 'not' R16 ) ) ) ) , R19) ) . R12 ) = ( 'not' ( ( Valid (( 'not' ( ( 'not' R15 ) '&' ( 'not' R16 ) ) ) , R19) ) . R12 ) ) by L216
.= ( 'not' ( 'not' ( ( Valid (( ( 'not' R15 ) '&' ( 'not' R16 ) ) , R19) ) . R12 ) ) ) by L216
.= ( ( ( Valid (( 'not' R15 ) , R19) ) . R12 ) '&' ( ( Valid (( 'not' R16 ) , R19) ) . R12 ) ) by L220
.= ( ( 'not' ( ( Valid (R15 , R19) ) . R12 ) ) '&' ( ( Valid (( 'not' R16 ) , R19) ) . R12 ) ) by L216
.= ( ( 'not' ( ( Valid (R15 , R19) ) . R12 ) ) '&' ( 'not' ( ( Valid (R16 , R19) ) . R12 ) ) ) by L216;
L488: ( ( Valid (( R15 => ( ( 'not' R15 ) => R16 ) ) , R19) ) . R12 ) = ( 'not' ( ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( 'not' ( ( Valid (R15 , R19) ) . R12 ) ) ) '&' ( 'not' ( ( Valid (R16 , R19) ) . R12 ) ) ) ) by L487 , L486 , MARGREL1:16
.= ( 'not' ( ( FALSE ) '&' ( 'not' ( ( Valid (R16 , R19) ) . R12 ) ) ) ) by XBOOLEAN:138;
L489: ( ( FALSE ) '&' ( 'not' ( ( Valid (R16 , R19) ) . R12 ) ) ) = ( FALSE ) by MARGREL1:13;
thus L490: ( ( Valid (( R15 => ( ( 'not' R15 ) => R16 ) ) , R19) ) . R12 ) = ( TRUE ) by L489 , L488 , MARGREL1:11;
end;
theorem
L491: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R18 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds R19 , R12 |= ( ( R15 => R16 ) => ( ( 'not' ( R16 '&' R18 ) ) => ( 'not' ( R15 '&' R18 ) ) ) ))))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
let R18 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
L492: (( R15 => R16 ) = ( 'not' ( R15 '&' ( 'not' R16 ) ) ) & ( ( 'not' ( R16 '&' R18 ) ) => ( 'not' ( R15 '&' R18 ) ) ) = ( 'not' ( ( 'not' ( R16 '&' R18 ) ) '&' ( 'not' ( 'not' ( R15 '&' R18 ) ) ) ) )) by QC_LANG2:def 2;
L493: ( ( Valid (( ( R15 => R16 ) => ( ( 'not' ( R16 '&' R18 ) ) => ( 'not' ( R15 '&' R18 ) ) ) ) , R19) ) . R12 ) = ( ( Valid (( 'not' ( ( 'not' ( R15 '&' ( 'not' R16 ) ) ) '&' ( 'not' ( 'not' ( ( 'not' ( R16 '&' R18 ) ) '&' ( 'not' ( 'not' ( R15 '&' R18 ) ) ) ) ) ) ) ) , R19) ) . R12 ) by L492 , QC_LANG2:def 2
.= ( 'not' ( ( Valid (( ( 'not' ( R15 '&' ( 'not' R16 ) ) ) '&' ( 'not' ( 'not' ( ( 'not' ( R16 '&' R18 ) ) '&' ( 'not' ( 'not' ( R15 '&' R18 ) ) ) ) ) ) ) , R19) ) . R12 ) ) by L216
.= ( 'not' ( ( ( Valid (( 'not' ( R15 '&' ( 'not' R16 ) ) ) , R19) ) . R12 ) '&' ( ( Valid (( 'not' ( 'not' ( ( 'not' ( R16 '&' R18 ) ) '&' ( 'not' ( 'not' ( R15 '&' R18 ) ) ) ) ) ) , R19) ) . R12 ) ) ) by L220;
L494: ( ( Valid (( 'not' ( R15 '&' ( 'not' R16 ) ) ) , R19) ) . R12 ) = ( 'not' ( ( Valid (( R15 '&' ( 'not' R16 ) ) , R19) ) . R12 ) ) by L216
.= ( 'not' ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( ( Valid (( 'not' R16 ) , R19) ) . R12 ) ) ) by L220
.= ( 'not' ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( 'not' ( ( Valid (R16 , R19) ) . R12 ) ) ) ) by L216;
L495: ( ( Valid (( 'not' ( 'not' ( ( 'not' ( R16 '&' R18 ) ) '&' ( 'not' ( 'not' ( R15 '&' R18 ) ) ) ) ) ) , R19) ) . R12 ) = ( 'not' ( ( Valid (( 'not' ( ( 'not' ( R16 '&' R18 ) ) '&' ( 'not' ( 'not' ( R15 '&' R18 ) ) ) ) ) , R19) ) . R12 ) ) by L216
.= ( 'not' ( 'not' ( ( Valid (( ( 'not' ( R16 '&' R18 ) ) '&' ( 'not' ( 'not' ( R15 '&' R18 ) ) ) ) , R19) ) . R12 ) ) ) by L216
.= ( ( ( Valid (( 'not' ( R16 '&' R18 ) ) , R19) ) . R12 ) '&' ( ( Valid (( 'not' ( 'not' ( R15 '&' R18 ) ) ) , R19) ) . R12 ) ) by L220
.= ( ( 'not' ( ( Valid (( R16 '&' R18 ) , R19) ) . R12 ) ) '&' ( ( Valid (( 'not' ( 'not' ( R15 '&' R18 ) ) ) , R19) ) . R12 ) ) by L216
.= ( ( 'not' ( ( Valid (( R16 '&' R18 ) , R19) ) . R12 ) ) '&' ( 'not' ( ( Valid (( 'not' ( R15 '&' R18 ) ) , R19) ) . R12 ) ) ) by L216
.= ( ( 'not' ( ( Valid (( R16 '&' R18 ) , R19) ) . R12 ) ) '&' ( 'not' ( 'not' ( ( Valid (( R15 '&' R18 ) , R19) ) . R12 ) ) ) ) by L216
.= ( ( 'not' ( ( ( Valid (R16 , R19) ) . R12 ) '&' ( ( Valid (R18 , R19) ) . R12 ) ) ) '&' ( ( Valid (( R15 '&' R18 ) , R19) ) . R12 ) ) by L220
.= ( ( 'not' ( ( ( Valid (R16 , R19) ) . R12 ) '&' ( ( Valid (R18 , R19) ) . R12 ) ) ) '&' ( ( ( Valid (R15 , R19) ) . R12 ) '&' ( ( Valid (R18 , R19) ) . R12 ) ) ) by L220;
thus L496: ( ( Valid (( ( R15 => R16 ) => ( ( 'not' ( R16 '&' R18 ) ) => ( 'not' ( R15 '&' R18 ) ) ) ) , R19) ) . R12 ) = ( TRUE ) by L495 , L493 , L494 , L355;
end;
theorem
L497: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds ((R19 , R12 |= R15 & R19 , R12 |= ( R15 => R16 )) implies R19 , R12 |= R16))))))) by L341;
theorem
L498: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R9 being (bound_QC-variable of R1) holds (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds R19 , R12 |= ( ( All (R9 , R15) ) => R15 )))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R9 being (bound_QC-variable of R1);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
thus L499: ( ( Valid (( ( All (R9 , R15) ) => R15 ) , R19) ) . R12 ) = ( TRUE )
proof
assume L500: (not ( ( Valid (( ( All (R9 , R15) ) => R15 ) , R19) ) . R12 ) = ( TRUE ));
L501: ( ( Valid (( ( All (R9 , R15) ) => R15 ) , R19) ) . R12 ) = ( FALSE ) by L500 , XBOOLEAN:def 3;
L502: ( ( Valid (( ( All (R9 , R15) ) => R15 ) , R19) ) . R12 ) = ( ( Valid (( 'not' ( ( All (R9 , R15) ) '&' ( 'not' R15 ) ) ) , R19) ) . R12 ) by QC_LANG2:def 2
.= ( 'not' ( ( Valid (( ( All (R9 , R15) ) '&' ( 'not' R15 ) ) , R19) ) . R12 ) ) by L216
.= ( 'not' ( ( ( Valid (( All (R9 , R15) ) , R19) ) . R12 ) '&' ( ( Valid (( 'not' R15 ) , R19) ) . R12 ) ) ) by L220
.= ( 'not' ( ( ( Valid (( All (R9 , R15) ) , R19) ) . R12 ) '&' ( 'not' ( ( Valid (R15 , R19) ) . R12 ) ) ) ) by L216;
L503: ( ( ( Valid (( All (R9 , R15) ) , R19) ) . R12 ) '&' ( 'not' ( ( Valid (R15 , R19) ) . R12 ) ) ) = ( TRUE ) by L502 , L501 , MARGREL1:11;
L504: ( 'not' ( ( Valid (R15 , R19) ) . R12 ) ) = ( TRUE ) by L503 , MARGREL1:12;
L505: ( ( Valid (R15 , R19) ) . R12 ) = ( FALSE ) by L504 , MARGREL1:11;
L506: ( ( Valid (( All (R9 , R15) ) , R19) ) . R12 ) = ( TRUE ) by L503 , MARGREL1:12;
L507: ( ( FOR_ALL (R9 , ( Valid (R15 , R19) )) ) . R12 ) = ( TRUE ) by L506 , L143;
thus L508: thesis by L507 , L505 , L350;
end;

end;
theorem
L500: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R19 being (interpretation of R1 , R5) holds R19 |= ( VERUM R1 ))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R19 being (interpretation of R1 , R5);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
thus L501: thesis by L472;
end;
theorem
L502: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds R19 |= ( ( R15 '&' R16 ) => ( R16 '&' R15 ) ))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
thus L503: thesis by L476;
end;
theorem
L504: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds R19 |= ( ( ( 'not' R15 ) => R15 ) => R15 )))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
thus L505: thesis by L478;
end;
theorem
L506: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds R19 |= ( R15 => ( ( 'not' R15 ) => R16 ) ))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
thus L507: thesis by L484;
end;
theorem
L508: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R18 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds R19 |= ( ( R15 => R16 ) => ( ( 'not' ( R16 '&' R18 ) ) => ( 'not' ( R15 '&' R18 ) ) ) )))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
let R18 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
thus L509: thesis by L491;
end;
theorem
L510: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds ((R19 |= R15 & R19 |= ( R15 => R16 )) implies R19 |= R16))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
assume L511: (R19 |= R15 & R19 |= ( R15 => R16 ));
L512:
now
let R12 being (Element of ( Valuations_in (R1 , R5) ));
L513: (R19 , R12 |= R15 & R19 , R12 |= ( R15 => R16 )) by L511 , L353;
thus L514: R19 , R12 |= R16 by L513 , L341;
end;
thus L515: thesis by L512 , L353;
end;
theorem
L516: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R9 being (bound_QC-variable of R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds R19 |= ( ( All (R9 , R15) ) => R15 ))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R9 being (bound_QC-variable of R1);
let R15 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
let R12 being (Element of ( Valuations_in (R1 , R5) ));
thus L517: thesis by L498;
end;
theorem
L518: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R9 being (bound_QC-variable of R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds ((R19 |= ( R15 => R16 ) & (not R9 in ( still_not-bound_in R15 ))) implies R19 |= ( R15 => ( All (R9 , R16) ) ))))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R9 being (bound_QC-variable of R1);
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
assume that
L519: (for R12 being (Element of ( Valuations_in (R1 , R5) )) holds R19 , R12 |= ( R15 => R16 ))
and
L520: (not R9 in ( still_not-bound_in R15 ));
let R28 being (Element of ( Valuations_in (R1 , R5) ));
L521:
now
assume L522: R19 , R28 |= R15;
L523:
now
let R29 being (Element of ( Valuations_in (R1 , R5) ));
assume L524: (for R11 being (bound_QC-variable of R1) holds (R9 <> R11 implies ( R29 . R11 ) = ( R28 . R11 )));
L525: R19 , R29 |= R15 by L524 , L520 , L522 , L402;
L526: R19 , R29 |= ( R15 => R16 ) by L519;
thus L527: R19 , R29 |= R16 by L526 , L525 , L341;
end;
thus L528: R19 , R28 |= ( All (R9 , R16) ) by L523 , L411;
end;
thus L529: thesis by L521 , L341;
end;
theorem
L530: (for R1 being QC-alphabet holds (for R5 being non  empty set holds (for R9 being (bound_QC-variable of R1) holds (for R11 being (bound_QC-variable of R1) holds (for R15 being (Element of ( CQC-WFF R1 )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R19 being (interpretation of R1 , R5) holds (for B108 being (QC-formula of R1) holds ((R15 = ( B108 . R9 ) & R16 = ( B108 . R11 ) & (not R9 in ( still_not-bound_in B108 )) & R19 |= R15) implies R19 |= R16)))))))))
proof
let R1 being QC-alphabet;
let R5 being non  empty set;
let R9 being (bound_QC-variable of R1);
let R11 being (bound_QC-variable of R1);
let R15 being (Element of ( CQC-WFF R1 ));
let R16 being (Element of ( CQC-WFF R1 ));
let R19 being (interpretation of R1 , R5);
let C79 being (QC-formula of R1);
assume that
L531: R15 = ( C79 . R9 )
and
L532: R16 = ( C79 . R11 )
and
L533: (not R9 in ( still_not-bound_in C79 ))
and
L534: R19 |= R15;
L535:
now
assume L536: R9 <> R11;
L537:
now
let R28 being (Element of ( Valuations_in (R1 , R5) ));
consider C80 being (Element of ( Valuations_in (R1 , R5) )) such that L538: ((for B109 being (bound_QC-variable of R1) holds (B109 <> R9 implies ( C80 . B109 ) = ( R28 . B109 ))) & ( C80 . R9 ) = ( R28 . R11 )) by L378;
L539: ( C80 . R9 ) = ( C80 . R11 ) by L538;
L540: ( ( Valid (R15 , R19) ) . C80 ) = ( ( Valid (R16 , R19) ) . C80 ) by L539 , L531 , L532 , L425;
L541: R19 , C80 |= R15 by L534 , L353;
L542: ( ( Valid (R15 , R19) ) . C80 ) = ( TRUE ) by L541 , L235;
L543: (not R9 in ( still_not-bound_in R16 )) by L532 , L533 , L536 , L449;
thus L544: ( ( Valid (R16 , R19) ) . R28 ) = ( TRUE ) by L543 , L538 , L540 , L542 , L381;
end;
L545:
now
let R12 being (Element of ( Valuations_in (R1 , R5) ));
L546: ( ( Valid (R16 , R19) ) . R12 ) = ( TRUE ) by L537;
thus L547: R19 , R12 |= R16 by L546 , L235;
end;
thus L548: thesis by L545 , L353;
end;
thus L549: thesis by L535 , L531 , L532 , L534;
end;
