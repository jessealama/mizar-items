:: While Macro Instructions of SCM+FSA
::  by Jing-Chao Chen
::
:: Received December 10, 1997
:: Copyright (c) 1997-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, AMI_1, SCMFSA_2, CARD_1, SCMFSA8B, TURING_1, SCMFSA8A,
      AMISTD_2, ARYTM_3, SUBSET_1, FUNCT_4, FUNCOP_1, AMI_3, RELAT_1, TARSKI,
      XBOOLE_0, CAT_1, NAT_1, SCMFSA6A, FUNCT_1, XXREAL_0, VALUED_1, CARD_3,
      ARYTM_1, FSM_1, SF_MASTR, SCMFSA7B, UNIALG_2, CIRCUIT2, GRAPHSP,
      SCMFSA6B, SCMFSA_9, PBOOLE, ORDINAL1, PARTFUN1, EXTPRO_1, RELOC,
      SCMFSA6C, COMPOS_1, MEMSTR_0, SCMPDS_4;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, RELAT_1,
      FUNCT_1, FUNCT_2, PARTFUN1, AFINSQ_1, FUNCOP_1, FUNCT_4, CARD_3,
      MEMSTR_0, COMPOS_0,
      COMPOS_1, EXTPRO_1, VALUED_1, PBOOLE, ORDINAL1, NAT_1,
      AMISTD_1, AMISTD_2, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA7B,
      SCMFSA8A, SCMFSA8B, XXREAL_0, SCMFSA_M;
 constructors XXREAL_0, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA8A, FUNCT_4,
      SCMFSA8B, AMISTD_2, RELSET_1, PRE_POLY, PBOOLE, SCMFSA7B, DOMAIN_1,
      AMISTD_1, MEMSTR_0, SCMFSA_M;
 registrations SETFAM_1, FUNCT_1, RELSET_1, NUMBERS, XREAL_0, NAT_1, INT_1,
      CARD_3, SCMFSA_2, SF_MASTR, SCMFSA6B, SCMFSA7B, SCMFSA8A, ORDINAL1,
      XBOOLE_0, FINSET_1, VALUED_1, FUNCT_4, FUNCT_2, XXREAL_0, VALUED_0,
      AFINSQ_1, FUNCOP_1, SCMFSA10, AMISTD_2, COMPOS_1, EXTPRO_1, PBOOLE,
      RELAT_1, MEMSTR_0, FINSEQ_1, AMI_3, COMPOS_0, SCMFSA_M;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions SCMFSA6A, FUNCOP_1, PBOOLE, AFINSQ_1, COMPOS_1, EXTPRO_1,
      AMISTD_2, MEMSTR_0, CARD_3, COMPOS_0, SCMFSA_M;
 theorems TARSKI, NAT_1, FUNCT_1, FUNCT_4, SCMFSA_2, SCMFSA_4, SCMFSA6A,
      GRFUNC_1, SCMFSA6B, SCMFSA7B, SCMFSA8A, SCMFSA8B, ZFMISC_1, XBOOLE_0,
      XBOOLE_1, XREAL_1, ORDINAL1, XXREAL_0, VALUED_1, FUNCOP_1, PBOOLE,
      AFINSQ_1, PARTFUN1, RELAT_1, COMPOS_1, EXTPRO_1, MEMSTR_0, CARD_3,
      COMPOS_0, SCMFSA_M;
 schemes NAT_1;

begin
L1: ( card ( Stop ( SCM+FSA ) ) ) = 1 by AFINSQ_1:33;
L2: ( ( Stop ( SCM+FSA ) ) . ( 0 ) ) = ( halt ( SCM+FSA ) ) by AFINSQ_1:34;
L3: ( 0 ) in ( dom ( Stop ( SCM+FSA ) ) ) by COMPOS_1:3;
set D1 = ( Start-At (( 0 ) , ( SCM+FSA )) );
theorem
L4: (for B1 being (Program of ( SCM+FSA )) holds (for B2 being Int-Location holds ( card ( if=0 (B2 , ( B1 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) ) = ( ( card B1 ) + 6 )))
proof
let C1 being (Program of ( SCM+FSA ));
let C2 being Int-Location;
thus L5: ( card ( if=0 (C2 , ( C1 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) ) = ( ( ( card ( C1 ";" ( Goto ( 0 ) ) ) ) + 1 ) + 4 ) by L1 , SCMFSA8B:11
.= ( ( ( ( card C1 ) + ( card ( Goto ( 0 ) ) ) ) + 1 ) + 4 ) by SCMFSA6A:21
.= ( ( ( ( card C1 ) + 1 ) + 1 ) + 4 ) by SCMFSA8A:15
.= ( ( card C1 ) + 6 );
end;
theorem
L6: (for B3 being (Program of ( SCM+FSA )) holds (for B4 being Int-Location holds ( card ( if>0 (B4 , ( B3 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) ) = ( ( card B3 ) + 6 )))
proof
let C3 being (Program of ( SCM+FSA ));
let C4 being Int-Location;
thus L7: ( card ( if>0 (C4 , ( C3 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) ) = ( ( ( card ( C3 ";" ( Goto ( 0 ) ) ) ) + 1 ) + 4 ) by L1 , SCMFSA8B:12
.= ( ( ( ( card C3 ) + ( card ( Goto ( 0 ) ) ) ) + 1 ) + 4 ) by SCMFSA6A:21
.= ( ( ( ( card C3 ) + 1 ) + 1 ) + 4 ) by SCMFSA8A:15
.= ( ( card C3 ) + 6 );
end;
definition
let C5 being Int-Location;
let C6 being (Program of ( SCM+FSA ));
func while=0 (C5 , C6) -> (Program of ( SCM+FSA )) equals 
( ( if=0 (C5 , ( C6 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) +* ( ( ( card C6 ) + 4 ) .--> ( goto ( 0 ) ) ) );
correctness
proof
set D2 = ( if=0 (C5 , ( C6 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) );
set D3 = ( ( ( card C6 ) + 4 ) .--> ( goto ( 0 ) ) );
set D4 = ( D2 +* D3 );
L8: (( card D2 ) = ( ( card C6 ) + 6 ) & ( ( card C6 ) + 4 ) < ( ( card C6 ) + 6 )) by L4 , XREAL_1:6;
L9: ( ( card C6 ) + 4 ) in ( dom D2 ) by L8 , AFINSQ_1:66;
L10: { ( ( card C6 ) + 4 ) } c= ( dom D2 ) by L9 , ZFMISC_1:31;
L11: ( dom D4 ) = ( ( dom D2 ) \/ ( dom D3 ) ) by FUNCT_4:def 1
.= ( ( dom D2 ) \/ { ( ( card C6 ) + 4 ) } ) by FUNCOP_1:13
.= ( dom D2 ) by L10 , XBOOLE_1:12;
L12: D4 is  initial
proof
let C7 , C8 being Nat;
thus L13: thesis by L11 , AFINSQ_1:def 12;
end;
thus L14: thesis by L12;
end;
func while>0 (C5 , C6) -> (Program of ( SCM+FSA )) equals 
( ( if>0 (C5 , ( C6 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) +* ( ( ( card C6 ) + 4 ) .--> ( goto ( 0 ) ) ) );
correctness
proof
set D5 = ( if>0 (C5 , ( C6 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) );
set D6 = ( ( ( card C6 ) + 4 ) .--> ( goto ( 0 ) ) );
set D7 = ( D5 +* D6 );
L15: (( card D5 ) = ( ( card C6 ) + 6 ) & ( ( card C6 ) + 4 ) < ( ( card C6 ) + 6 )) by L6 , XREAL_1:6;
L16: ( ( card C6 ) + 4 ) in ( dom D5 ) by L15 , AFINSQ_1:66;
L17: { ( ( card C6 ) + 4 ) } c= ( dom D5 ) by L16 , ZFMISC_1:31;
L18: ( dom D7 ) = ( ( dom D5 ) \/ ( dom D6 ) ) by FUNCT_4:def 1
.= ( ( dom D5 ) \/ { ( ( card C6 ) + 4 ) } ) by FUNCOP_1:13
.= ( dom D5 ) by L17 , XBOOLE_1:12;
L19: D7 is  initial
proof
let C9 , C10 being Nat;
thus L20: thesis by L18 , AFINSQ_1:def 12;
end;
thus L21: thesis by L19;
end;
end;
theorem
L23: (for B5 being (Program of ( SCM+FSA )) holds (for B6 being Int-Location holds ( card ( if=0 (B6 , ( Stop ( SCM+FSA ) ) , ( if>0 (B6 , ( Stop ( SCM+FSA ) ) , ( B5 ";" ( Goto ( 0 ) ) )) )) ) ) = ( ( card B5 ) + 11 )))
proof
let C11 being (Program of ( SCM+FSA ));
let C12 being Int-Location;
thus L24: ( card ( if=0 (C12 , ( Stop ( SCM+FSA ) ) , ( if>0 (C12 , ( Stop ( SCM+FSA ) ) , ( C11 ";" ( Goto ( 0 ) ) )) )) ) ) = ( ( 1 + ( card ( if>0 (C12 , ( Stop ( SCM+FSA ) ) , ( C11 ";" ( Goto ( 0 ) ) )) ) ) ) + 4 ) by L1 , SCMFSA8B:11
.= ( ( ( ( ( card ( C11 ";" ( Goto ( 0 ) ) ) ) + 1 ) + 4 ) + 1 ) + 4 ) by L1 , SCMFSA8B:12
.= ( ( ( ( ( ( card C11 ) + ( card ( Goto ( 0 ) ) ) ) + 1 ) + 4 ) + 1 ) + 4 ) by SCMFSA6A:21
.= ( ( ( ( ( ( card C11 ) + 1 ) + 1 ) + 4 ) + 1 ) + 4 ) by SCMFSA8A:15
.= ( ( card C11 ) + 11 );
end;
definition
let C13 being Int-Location;
let C14 being (Program of ( SCM+FSA ));
func while<0 (C13 , C14) -> (Program of ( SCM+FSA )) equals 
( ( if=0 (C13 , ( Stop ( SCM+FSA ) ) , ( if>0 (C13 , ( Stop ( SCM+FSA ) ) , ( C14 ";" ( Goto ( 0 ) ) )) )) ) +* ( ( ( card C14 ) + 4 ) .--> ( goto ( 0 ) ) ) );
correctness
proof
set D8 = ( if=0 (C13 , ( Stop ( SCM+FSA ) ) , ( if>0 (C13 , ( Stop ( SCM+FSA ) ) , ( C14 ";" ( Goto ( 0 ) ) )) )) );
set D9 = ( ( ( card C14 ) + 4 ) .--> ( goto ( 0 ) ) );
set D10 = ( D8 +* D9 );
L25: (( card D8 ) = ( ( card C14 ) + 11 ) & ( ( card C14 ) + 4 ) < ( ( card C14 ) + 11 )) by L23 , XREAL_1:6;
L26: ( ( card C14 ) + 4 ) in ( dom D8 ) by L25 , AFINSQ_1:66;
L27: { ( ( card C14 ) + 4 ) } c= ( dom D8 ) by L26 , ZFMISC_1:31;
L28: ( dom D10 ) = ( ( dom D8 ) \/ ( dom D9 ) ) by FUNCT_4:def 1
.= ( ( dom D8 ) \/ { ( ( card C14 ) + 4 ) } ) by FUNCOP_1:13
.= ( dom D8 ) by L27 , XBOOLE_1:12;
L29: D10 is  initial
proof
let C15 , C16 being Nat;
thus L30: thesis by L28 , AFINSQ_1:def 12;
end;
thus L31: thesis by L29;
end;
end;
theorem
L33: (for B7 being (Program of ( SCM+FSA )) holds (for B8 being Int-Location holds ( card ( while=0 (B8 , B7) ) ) = ( ( card B7 ) + 6 )))
proof
let C17 being (Program of ( SCM+FSA ));
let C18 being Int-Location;
set D11 = ( ( ( card C17 ) + 4 ) .--> ( goto ( 0 ) ) );
set D12 = ( if=0 (C18 , ( C17 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) );
set D13 = ( D12 +* D11 );
L34: ( card D12 ) = ( ( card C17 ) + 6 ) by L4;
L35: ( ( card C17 ) + 4 ) < ( ( card C17 ) + 6 ) by XREAL_1:6;
L36: ( ( card C17 ) + 4 ) in ( dom D12 ) by L35 , L34 , AFINSQ_1:66;
L37: { ( ( card C17 ) + 4 ) } c= ( dom D12 ) by L36 , ZFMISC_1:31;
L38: ( dom D13 ) = ( ( dom D12 ) \/ ( dom D11 ) ) by FUNCT_4:def 1
.= ( ( dom D12 ) \/ { ( ( card C17 ) + 4 ) } ) by FUNCOP_1:13
.= ( dom D12 ) by L37 , XBOOLE_1:12;
thus L39: ( card ( while=0 (C18 , C17) ) ) = ( ( card C17 ) + 6 ) by L38 , L34;
end;
theorem
L40: (for B9 being (Program of ( SCM+FSA )) holds (for B10 being Int-Location holds ( card ( while>0 (B10 , B9) ) ) = ( ( card B9 ) + 6 )))
proof
let C19 being (Program of ( SCM+FSA ));
let C20 being Int-Location;
set D14 = ( ( ( card C19 ) + 4 ) .--> ( goto ( 0 ) ) );
set D15 = ( if>0 (C20 , ( C19 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) );
set D16 = ( D15 +* D14 );
L41: ( card D15 ) = ( ( card C19 ) + 6 ) by L6;
L42: ( ( card C19 ) + 4 ) < ( ( card C19 ) + 6 ) by XREAL_1:6;
L43: ( ( card C19 ) + 4 ) in ( dom D15 ) by L42 , L41 , AFINSQ_1:66;
L44: { ( ( card C19 ) + 4 ) } c= ( dom D15 ) by L43 , ZFMISC_1:31;
L45: ( dom D16 ) = ( ( dom D15 ) \/ ( dom D14 ) ) by FUNCT_4:def 1
.= ( ( dom D15 ) \/ { ( ( card C19 ) + 4 ) } ) by FUNCOP_1:13
.= ( dom D15 ) by L44 , XBOOLE_1:12;
thus L46: ( card ( while>0 (C20 , C19) ) ) = ( ( card C19 ) + 6 ) by L45 , L41;
end;
theorem
L47: (for B11 being (Program of ( SCM+FSA )) holds (for B12 being Int-Location holds ( card ( while<0 (B12 , B11) ) ) = ( ( card B11 ) + 11 )))
proof
let C21 being (Program of ( SCM+FSA ));
let C22 being Int-Location;
set D17 = ( ( ( card C21 ) + 4 ) .--> ( goto ( 0 ) ) );
set D18 = ( if=0 (C22 , ( Stop ( SCM+FSA ) ) , ( if>0 (C22 , ( Stop ( SCM+FSA ) ) , ( C21 ";" ( Goto ( 0 ) ) )) )) );
set D19 = ( D18 +* D17 );
L48: ( card D18 ) = ( ( card C21 ) + 11 ) by L23;
L49: ( ( card C21 ) + 4 ) < ( ( card C21 ) + 11 ) by XREAL_1:6;
L50: ( ( card C21 ) + 4 ) in ( dom D18 ) by L49 , L48 , AFINSQ_1:66;
L51: { ( ( card C21 ) + 4 ) } c= ( dom D18 ) by L50 , ZFMISC_1:31;
L52: ( dom D19 ) = ( ( dom D18 ) \/ ( dom D17 ) ) by FUNCT_4:def 1
.= ( ( dom D18 ) \/ { ( ( card C21 ) + 4 ) } ) by FUNCOP_1:13
.= ( dom D18 ) by L51 , XBOOLE_1:12;
thus L53: ( card ( while<0 (C22 , C21) ) ) = ( ( card C21 ) + 11 ) by L52 , L48;
end;
canceled 3;
theorem
L54: (for B13 being Int-Location holds (for B14 being (Program of ( SCM+FSA )) holds (( 0 ) in ( dom ( while=0 (B13 , B14) ) ) & 1 in ( dom ( while=0 (B13 , B14) ) ) & ( 0 ) in ( dom ( while>0 (B13 , B14) ) ) & 1 in ( dom ( while>0 (B13 , B14) ) ))))
proof
set D20 = ( Stop ( SCM+FSA ) );
let C23 being Int-Location;
let C24 being (Program of ( SCM+FSA ));
set D21 = ( C24 ";" ( Goto ( 0 ) ) );
set D22 = ( ( ( card C24 ) + 4 ) .--> ( goto ( 0 ) ) );
set D23 = ( C23 =0_goto ( ( card D20 ) + 3 ) );
L55: ( if=0 (C23 , D21 , D20) ) = ( ( ( ( D23 ";" D20 ) ";" ( Goto ( ( card D21 ) + 1 ) ) ) ";" D21 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1
.= ( ( ( D23 ";" D20 ) ";" ( Goto ( ( card D21 ) + 1 ) ) ) ";" ( D21 ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:25
.= ( ( D23 ";" D20 ) ";" ( ( Goto ( ( card D21 ) + 1 ) ) ";" ( D21 ";" ( Stop ( SCM+FSA ) ) ) ) ) by SCMFSA6A:25
.= ( D23 ";" ( D20 ";" ( ( Goto ( ( card D21 ) + 1 ) ) ";" ( D21 ";" ( Stop ( SCM+FSA ) ) ) ) ) ) by SCMFSA6A:29
.= ( ( Macro D23 ) ";" ( D20 ";" ( ( Goto ( ( card D21 ) + 1 ) ) ";" ( D21 ";" ( Stop ( SCM+FSA ) ) ) ) ) );
L56: ( dom ( Macro D23 ) ) c= ( dom ( if=0 (C23 , D21 , D20) ) ) by L55 , SCMFSA6A:17;
L57: ( dom ( Macro D23 ) ) = { ( 0 ) , 1 } by COMPOS_1:61;
L58: (( 0 ) in ( dom ( Macro D23 ) ) & 1 in ( dom ( Macro D23 ) )) by L57 , TARSKI:def 2;
L59: ( dom ( while=0 (C23 , C24) ) ) = ( ( dom ( if=0 (C23 , D21 , D20) ) ) \/ ( dom D22 ) ) by FUNCT_4:def 1;
L60: ( dom ( if=0 (C23 , D21 , D20) ) ) c= ( dom ( while=0 (C23 , C24) ) ) by L59 , XBOOLE_1:7;
L61: ( dom ( Macro D23 ) ) c= ( dom ( while=0 (C23 , C24) ) ) by L60 , L56 , XBOOLE_1:1;
thus L62: (( 0 ) in ( dom ( while=0 (C23 , C24) ) ) & 1 in ( dom ( while=0 (C23 , C24) ) )) by L61 , L58;
set D24 = ( C23 >0_goto ( ( card D20 ) + 3 ) );
L63: ( if>0 (C23 , D21 , D20) ) = ( ( ( ( D24 ";" D20 ) ";" ( Goto ( ( card D21 ) + 1 ) ) ) ";" D21 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2
.= ( ( ( D24 ";" D20 ) ";" ( Goto ( ( card D21 ) + 1 ) ) ) ";" ( D21 ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:25
.= ( ( D24 ";" D20 ) ";" ( ( Goto ( ( card D21 ) + 1 ) ) ";" ( D21 ";" ( Stop ( SCM+FSA ) ) ) ) ) by SCMFSA6A:25
.= ( D24 ";" ( D20 ";" ( ( Goto ( ( card D21 ) + 1 ) ) ";" ( D21 ";" ( Stop ( SCM+FSA ) ) ) ) ) ) by SCMFSA6A:29
.= ( ( Macro D24 ) ";" ( D20 ";" ( ( Goto ( ( card D21 ) + 1 ) ) ";" ( D21 ";" ( Stop ( SCM+FSA ) ) ) ) ) );
L64: ( dom ( Macro D24 ) ) c= ( dom ( if>0 (C23 , D21 , D20) ) ) by L63 , SCMFSA6A:17;
L65: ( dom ( Macro D24 ) ) = { ( 0 ) , 1 } by COMPOS_1:61;
L66: (( 0 ) in ( dom ( Macro D24 ) ) & 1 in ( dom ( Macro D24 ) )) by L65 , TARSKI:def 2;
L67: ( dom ( while>0 (C23 , C24) ) ) = ( ( dom ( if>0 (C23 , D21 , D20) ) ) \/ ( dom D22 ) ) by FUNCT_4:def 1;
L68: ( dom ( if>0 (C23 , D21 , D20) ) ) c= ( dom ( while>0 (C23 , C24) ) ) by L67 , XBOOLE_1:7;
L69: ( dom ( Macro D24 ) ) c= ( dom ( while>0 (C23 , C24) ) ) by L68 , L64 , XBOOLE_1:1;
thus L70: thesis by L69 , L66;
end;
theorem
L71: (for B15 being Int-Location holds (for B16 being (Program of ( SCM+FSA )) holds (( ( while=0 (B15 , B16) ) . ( 0 ) ) = ( B15 =0_goto 4 ) & ( ( while=0 (B15 , B16) ) . 1 ) = ( goto 2 ) & ( ( while>0 (B15 , B16) ) . ( 0 ) ) = ( B15 >0_goto 4 ) & ( ( while>0 (B15 , B16) ) . 1 ) = ( goto 2 ))))
proof
set D25 = ( Stop ( SCM+FSA ) );
let C25 being Int-Location;
let C26 being (Program of ( SCM+FSA ));
set D26 = ( C26 ";" ( Goto ( 0 ) ) );
set D27 = ( ( ( card C26 ) + 4 ) .--> ( goto ( 0 ) ) );
set D28 = ( C25 =0_goto ( ( card D25 ) + 3 ) );
L72: ( dom ( while=0 (C25 , C26) ) ) = ( ( dom ( if=0 (C25 , D26 , D25) ) ) \/ ( dom D27 ) ) by FUNCT_4:def 1;
L73: ( dom D27 ) = { ( ( card C26 ) + 4 ) } by FUNCOP_1:13;
L74: (not ( 0 ) in ( dom D27 )) by L73;
L75: ( dom ( Macro D28 ) ) = { ( 0 ) , 1 } by COMPOS_1:61;
L76: ( 0 ) in ( dom ( Macro D28 ) ) by L75 , TARSKI:def 2;
L77: 1 in ( dom ( Macro D28 ) ) by L75 , TARSKI:def 2;
L78: ( if=0 (C25 , D26 , D25) ) = ( ( ( ( D28 ";" D25 ) ";" ( Goto ( ( card D26 ) + 1 ) ) ) ";" D26 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1
.= ( ( ( D28 ";" D25 ) ";" ( Goto ( ( card D26 ) + 1 ) ) ) ";" ( D26 ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:25
.= ( ( D28 ";" D25 ) ";" ( ( Goto ( ( card D26 ) + 1 ) ) ";" ( D26 ";" ( Stop ( SCM+FSA ) ) ) ) ) by SCMFSA6A:25
.= ( D28 ";" ( D25 ";" ( ( Goto ( ( card D26 ) + 1 ) ) ";" ( D26 ";" ( Stop ( SCM+FSA ) ) ) ) ) ) by SCMFSA6A:29
.= ( ( Macro D28 ) ";" ( D25 ";" ( ( Goto ( ( card D26 ) + 1 ) ) ";" ( D26 ";" ( Stop ( SCM+FSA ) ) ) ) ) );
L79: 1 <> ( ( card C26 ) + 4 ) by NAT_1:11;
L80: (not 1 in ( dom D27 )) by L79 , L73 , TARSKI:def 1;
L81: ( 0 ) in ( dom ( while=0 (C25 , C26) ) ) by L54;
thus L82: ( ( while=0 (C25 , C26) ) . ( 0 ) ) = ( ( if=0 (C25 , D26 , D25) ) . ( 0 ) ) by L81 , L74 , L72 , FUNCT_4:def 1
.= ( ( Directed ( Macro D28 ) ) . ( 0 ) ) by L78 , L76 , SCMFSA8A:14
.= ( C25 =0_goto 4 ) by L1 , SCMFSA7B:1;
L83: ( dom ( while>0 (C25 , C26) ) ) = ( ( dom ( if>0 (C25 , D26 , D25) ) ) \/ ( dom D27 ) ) by FUNCT_4:def 1;
L84: 1 in ( dom ( while=0 (C25 , C26) ) ) by L54;
thus L85: ( ( while=0 (C25 , C26) ) . 1 ) = ( ( if=0 (C25 , D26 , D25) ) . 1 ) by L84 , L72 , L80 , FUNCT_4:def 1
.= ( ( Directed ( Macro D28 ) ) . 1 ) by L78 , L77 , SCMFSA8A:14
.= ( goto 2 ) by SCMFSA7B:2;
set D29 = ( C25 >0_goto ( ( card D25 ) + 3 ) );
L86: ( if>0 (C25 , D26 , D25) ) = ( ( ( ( D29 ";" D25 ) ";" ( Goto ( ( card D26 ) + 1 ) ) ) ";" D26 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2
.= ( ( ( D29 ";" D25 ) ";" ( Goto ( ( card D26 ) + 1 ) ) ) ";" ( D26 ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:25
.= ( ( D29 ";" D25 ) ";" ( ( Goto ( ( card D26 ) + 1 ) ) ";" ( D26 ";" ( Stop ( SCM+FSA ) ) ) ) ) by SCMFSA6A:25
.= ( D29 ";" ( D25 ";" ( ( Goto ( ( card D26 ) + 1 ) ) ";" ( D26 ";" ( Stop ( SCM+FSA ) ) ) ) ) ) by SCMFSA6A:29
.= ( ( Macro D29 ) ";" ( D25 ";" ( ( Goto ( ( card D26 ) + 1 ) ) ";" ( D26 ";" ( Stop ( SCM+FSA ) ) ) ) ) );
L87: ( dom ( Macro D29 ) ) = { ( 0 ) , 1 } by COMPOS_1:61;
L88: ( 0 ) in ( dom ( Macro D29 ) ) by L87 , TARSKI:def 2;
L89: 1 in ( dom ( Macro D29 ) ) by L87 , TARSKI:def 2;
L90: ( 0 ) in ( dom ( while>0 (C25 , C26) ) ) by L54;
thus L91: ( ( while>0 (C25 , C26) ) . ( 0 ) ) = ( ( if>0 (C25 , D26 , D25) ) . ( 0 ) ) by L90 , L74 , L83 , FUNCT_4:def 1
.= ( ( Directed ( Macro D29 ) ) . ( 0 ) ) by L86 , L88 , SCMFSA8A:14
.= ( C25 >0_goto 4 ) by L1 , SCMFSA7B:1;
L92: 1 in ( dom ( while>0 (C25 , C26) ) ) by L54;
thus L93: ( ( while>0 (C25 , C26) ) . 1 ) = ( ( if>0 (C25 , D26 , D25) ) . 1 ) by L92 , L80 , L83 , FUNCT_4:def 1
.= ( ( Directed ( Macro D29 ) ) . 1 ) by L86 , L89 , SCMFSA8A:14
.= ( goto 2 ) by SCMFSA7B:2;
end;
theorem
L94: (for B17 being Int-Location holds (for B18 being (Program of ( SCM+FSA )) holds (for B19 being (Element of ( NAT )) holds (B19 < 6 implies B19 in ( dom ( while=0 (B17 , B18) ) )))))
proof
let C27 being Int-Location;
let C28 being (Program of ( SCM+FSA ));
let C29 being (Element of ( NAT ));
L95: 6 <= ( ( card C28 ) + 6 ) by NAT_1:11;
L96: ( card ( while=0 (C27 , C28) ) ) = ( ( card C28 ) + 6 ) by L33;
assume L97: C29 < 6;
L98: C29 < ( ( card C28 ) + 6 ) by L97 , L95 , XXREAL_0:2;
thus L99: thesis by L98 , L96 , AFINSQ_1:66;
end;
theorem
L100: (for B20 being Int-Location holds (for B21 being (Program of ( SCM+FSA )) holds (for B22 being (Element of ( NAT )) holds (B22 < 6 implies ( ( card B21 ) + B22 ) in ( dom ( while=0 (B20 , B21) ) )))))
proof
let C30 being Int-Location;
let C31 being (Program of ( SCM+FSA ));
let C32 being (Element of ( NAT ));
assume L101: C32 < 6;
L102: ( ( card C31 ) + C32 ) < ( ( card C31 ) + 6 ) by L101 , XREAL_1:6;
L103: ( card ( while=0 (C30 , C31) ) ) = ( ( card C31 ) + 6 ) by L33;
thus L104: thesis by L103 , L102 , AFINSQ_1:66;
end;
theorem
L105: (for B23 being Int-Location holds (for B24 being (Program of ( SCM+FSA )) holds ( ( while=0 (B23 , B24) ) . ( ( card B24 ) + 5 ) ) = ( halt ( SCM+FSA ) )))
proof
set D30 = ( Stop ( SCM+FSA ) );
set D31 = ( Stop ( SCM+FSA ) );
let C33 being Int-Location;
let C34 being (Program of ( SCM+FSA ));
set D32 = ( C34 ";" ( Goto ( 0 ) ) );
set D33 = ( ( ( card C34 ) + 4 ) .--> ( goto ( 0 ) ) );
set D34 = ( C33 =0_goto ( ( card D31 ) + 3 ) );
set D35 = ( ( card C34 ) + 5 );
set D36 = D35;
set D37 = ( ( ( ( Macro D34 ) ";" D31 ) ";" ( Goto ( ( card D32 ) + 1 ) ) ) ";" D32 );
L106: (( dom D33 ) = { ( ( card C34 ) + 4 ) } & D36 <> ( ( card C34 ) + 4 )) by FUNCOP_1:13;
L107: (not D36 in ( dom D33 )) by L106 , TARSKI:def 1;
L108: ( ( 0 ) + D35 ) in { ( B25 + D35 ) where B25 is (Element of ( NAT )) : B25 in ( dom D30 ) } by L3;
L109: D35 in ( dom ( Shift (D30 , D35) ) ) by L108 , VALUED_1:def 12;
L110: ( ( Shift (D30 , D35) ) /. D36 ) = ( ( Shift (D30 , D35) ) . ( ( 0 ) + D35 ) ) by L109 , PARTFUN1:def 6
.= ( halt ( SCM+FSA ) ) by L2 , L3 , VALUED_1:def 12;
L111: (D36 in ( dom ( while=0 (C33 , C34) ) ) & ( dom ( while=0 (C33 , C34) ) ) = ( ( dom ( if=0 (C33 , D32 , D31) ) ) \/ ( dom D33 ) )) by L100 , FUNCT_4:def 1;
L112: D36 in ( dom ( if=0 (C33 , D32 , D31) ) ) by L111 , L107 , XBOOLE_0:def 3;
L113: ( if=0 (C33 , D32 , D31) ) = ( ( ( ( D34 ";" D31 ) ";" ( Goto ( ( card D32 ) + 1 ) ) ) ";" D32 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1
.= ( D37 ";" D30 );
L114: ( card ( if=0 (C33 , D32 , D31) ) ) = ( ( card D37 ) + ( card D30 ) ) by L113 , SCMFSA6A:21;
L115: ( card D37 ) = ( ( card ( if=0 (C33 , D32 , D31) ) ) - ( card D30 ) ) by L114
.= ( ( ( card C34 ) + 6 ) - 1 ) by L4 , L1
.= D35;
L116: (not D36 in ( dom D37 )) by L115;
L117: ( dom ( if=0 (C33 , D32 , D31) ) ) = ( ( dom ( Directed D37 ) ) \/ ( dom ( Reloc (D31 , D35) ) ) ) by L113 , L115 , FUNCT_4:def 1;
L118: ( dom ( if=0 (C33 , D32 , D31) ) ) = ( ( dom D37 ) \/ ( dom ( Reloc (D31 , D35) ) ) ) by L117 , FUNCT_4:99;
L119: D36 in ( dom ( Reloc (D31 , D35) ) ) by L118 , L112 , L116 , XBOOLE_0:def 3;
L120: ( Reloc (D31 , D35) ) = ( IncAddr (( Shift (D31 , D35) ) , D35) ) by COMPOS_1:34;
thus L121: ( ( while=0 (C33 , C34) ) . D36 ) = ( ( ( Directed D37 ) +* ( Reloc (D31 , D35) ) ) . D36 ) by L107 , L111 , L113 , L115 , FUNCT_4:def 1
.= ( ( Reloc (D31 , D35) ) . D36 ) by L112 , L117 , L119 , FUNCT_4:def 1
.= ( IncAddr (( halt ( SCM+FSA ) ) , D35) ) by L109 , L110 , L120 , COMPOS_1:def 21
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
end;
theorem
L122: (for B26 being Int-Location holds (for B27 being (Program of ( SCM+FSA )) holds ( ( while=0 (B26 , B27) ) . 3 ) = ( goto ( ( card B27 ) + 5 ) )))
proof
set D38 = ( Stop ( SCM+FSA ) );
let C35 being Int-Location;
let C36 being (Program of ( SCM+FSA ));
set D39 = ( C36 ";" ( Goto ( 0 ) ) );
set D40 = ( ( ( card C36 ) + 4 ) .--> ( goto ( 0 ) ) );
set D41 = ( C35 =0_goto ( ( card D38 ) + 3 ) );
set D42 = ( ( Macro D41 ) ";" D38 );
set D43 = ( Goto ( ( card D39 ) + 1 ) );
set D44 = ( D39 ";" ( Stop ( SCM+FSA ) ) );
set D45 = ( D43 ";" D44 );
L123: ( 0 ) in ( dom D43 ) by SCMFSA8A:31;
L124: ( D43 . ( 0 ) ) = ( goto ( ( card D39 ) + 1 ) ) by SCMFSA8A:31
.= ( goto ( ( ( card C36 ) + ( card ( Goto ( 0 ) ) ) ) + 1 ) ) by SCMFSA6A:21
.= ( goto ( ( ( card C36 ) + 1 ) + 1 ) ) by SCMFSA8A:15
.= ( goto ( ( card C36 ) + ( 1 + 1 ) ) );
L125: ( dom D45 ) = ( ( dom ( Directed D43 ) ) \/ ( dom ( Reloc (D44 , ( card D43 )) ) ) ) by FUNCT_4:def 1
.= ( ( dom D43 ) \/ ( dom ( Reloc (D44 , ( card D43 )) ) ) ) by FUNCT_4:99;
L126: ( 0 ) in ( dom D45 ) by L125 , L123 , XBOOLE_0:def 3;
L127: ( ( 0 ) + 3 ) in { ( B28 + 3 ) where B28 is (Element of ( NAT )) : B28 in ( dom D45 ) } by L126;
L128: 3 in ( dom ( Shift (D45 , 3) ) ) by L127 , VALUED_1:def 12;
L129: ( ( Shift (D45 , 3) ) /. 3 ) = ( ( Shift (D45 , 3) ) . ( ( 0 ) + 3 ) ) by L128 , PARTFUN1:def 6
.= ( D45 . ( 0 ) ) by L126 , VALUED_1:def 12
.= ( ( Directed D43 ) . ( 0 ) ) by L123 , SCMFSA8A:14
.= ( goto ( ( card C36 ) + 2 ) ) by L123 , L124 , SCMFSA8A:16;
L130: (( dom D40 ) = { ( ( card C36 ) + 4 ) } & 3 <> ( ( card C36 ) + 4 )) by FUNCOP_1:13 , NAT_1:11;
L131: (not 3 in ( dom D40 )) by L130 , TARSKI:def 1;
L132: ( card D42 ) = ( ( card ( Macro D41 ) ) + ( card D38 ) ) by SCMFSA6A:21
.= ( 2 + 1 ) by L1 , COMPOS_1:56;
L133: (not 3 in ( dom D42 )) by L132;
L134: (3 in ( dom ( while=0 (C35 , C36) ) ) & ( dom ( while=0 (C35 , C36) ) ) = ( ( dom ( if=0 (C35 , D39 , D38) ) ) \/ ( dom D40 ) )) by L94 , FUNCT_4:def 1;
L135: 3 in ( dom ( if=0 (C35 , D39 , D38) ) ) by L134 , L131 , XBOOLE_0:def 3;
L136: ( CutLastLoc ( stop D42 ) ) = D42;
L137: ( if=0 (C35 , D39 , D38) ) = ( ( ( ( D41 ";" D38 ) ";" ( Goto ( ( card D39 ) + 1 ) ) ) ";" D39 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1
.= ( ( ( D41 ";" D38 ) ";" ( Goto ( ( card D39 ) + 1 ) ) ) ";" ( D39 ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:25
.= ( D42 ";" D45 ) by SCMFSA6A:25
.= ( ( Directed D42 ) +* ( Reloc (D45 , 3) ) ) by L132 , L136;
L138: ( dom ( if=0 (C35 , D39 , D38) ) ) = ( ( dom ( Directed D42 ) ) \/ ( dom ( Reloc (D45 , 3) ) ) ) by L137 , FUNCT_4:def 1;
L139: ( dom ( if=0 (C35 , D39 , D38) ) ) = ( ( dom D42 ) \/ ( dom ( Reloc (D45 , 3) ) ) ) by L138 , FUNCT_4:99;
L140: 3 in ( dom ( Reloc (D45 , 3) ) ) by L139 , L135 , L133 , XBOOLE_0:def 3;
L141: ( Reloc (D45 , 3) ) = ( IncAddr (( Shift (D45 , 3) ) , 3) ) by COMPOS_1:34;
thus L142: ( ( while=0 (C35 , C36) ) . 3 ) = ( ( ( Directed D42 ) +* ( Reloc (D45 , 3) ) ) . 3 ) by L131 , L134 , L137 , FUNCT_4:def 1
.= ( ( Reloc (D45 , 3) ) . 3 ) by L135 , L138 , L140 , FUNCT_4:def 1
.= ( IncAddr (( goto ( ( card C36 ) + 2 ) ) , 3) ) by L128 , L129 , L141 , COMPOS_1:def 21
.= ( goto ( ( ( card C36 ) + 2 ) + 3 ) ) by SCMFSA_4:1
.= ( goto ( ( card C36 ) + 5 ) );
end;
theorem
L143: (for B29 being Int-Location holds (for B30 being (Program of ( SCM+FSA )) holds ( ( while=0 (B29 , B30) ) . 2 ) = ( goto 3 )))
proof
set D46 = ( Stop ( SCM+FSA ) );
let C37 being Int-Location;
let C38 being (Program of ( SCM+FSA ));
set D47 = ( C38 ";" ( Goto ( 0 ) ) );
set D48 = ( ( ( card C38 ) + 4 ) .--> ( goto ( 0 ) ) );
set D49 = ( C37 =0_goto ( ( card D46 ) + 3 ) );
set D50 = ( Macro D49 );
set D51 = ( ( Goto ( ( card D47 ) + 1 ) ) ";" ( D47 ";" ( Stop ( SCM+FSA ) ) ) );
set D52 = ( D46 ";" D51 );
L144: (( dom D48 ) = { ( ( card C38 ) + 4 ) } & 2 <> ( ( card C38 ) + 4 )) by FUNCOP_1:13 , NAT_1:11;
L145: (not 2 in ( dom D48 )) by L144 , TARSKI:def 1;
L146: ( dom D52 ) = ( ( dom ( Directed D46 ) ) \/ ( dom ( Reloc (D51 , ( card D46 )) ) ) ) by FUNCT_4:def 1
.= ( ( dom D46 ) \/ ( dom ( Reloc (D51 , ( card D46 )) ) ) ) by FUNCT_4:99;
L147: ( 0 ) in ( dom D52 ) by L146 , L3 , XBOOLE_0:def 3;
L148: ( ( 0 ) + 2 ) in { ( B31 + 2 ) where B31 is (Element of ( NAT )) : B31 in ( dom D52 ) } by L147;
L149: 2 in ( dom ( Shift (D52 , 2) ) ) by L148 , VALUED_1:def 12;
L150: ( ( Shift (D52 , 2) ) /. 2 ) = ( ( Shift (D52 , 2) ) . ( ( 0 ) + 2 ) ) by L149 , PARTFUN1:def 6
.= ( D52 . ( 0 ) ) by L147 , VALUED_1:def 12
.= ( ( Directed D46 ) . ( 0 ) ) by L3 , SCMFSA8A:14
.= ( goto ( card D46 ) ) by L2 , L3 , SCMFSA8A:16;
L151: ( card D50 ) = 2 by COMPOS_1:56;
L152: (not 2 in ( dom D50 )) by L151;
L153: (2 in ( dom ( while=0 (C37 , C38) ) ) & ( dom ( while=0 (C37 , C38) ) ) = ( ( dom ( if=0 (C37 , D47 , D46) ) ) \/ ( dom D48 ) )) by L94 , FUNCT_4:def 1;
L154: 2 in ( dom ( if=0 (C37 , D47 , D46) ) ) by L153 , L145 , XBOOLE_0:def 3;
L155: ( if=0 (C37 , D47 , D46) ) = ( ( ( ( D49 ";" D46 ) ";" ( Goto ( ( card D47 ) + 1 ) ) ) ";" D47 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1
.= ( ( ( D49 ";" D46 ) ";" ( Goto ( ( card D47 ) + 1 ) ) ) ";" ( D47 ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:25
.= ( ( D49 ";" D46 ) ";" ( ( Goto ( ( card D47 ) + 1 ) ) ";" ( D47 ";" ( Stop ( SCM+FSA ) ) ) ) ) by SCMFSA6A:25
.= ( D49 ";" D52 ) by SCMFSA6A:29
.= ( ( Directed D50 ) +* ( Reloc (D52 , 2) ) ) by COMPOS_1:56;
L156: ( dom ( if=0 (C37 , D47 , D46) ) ) = ( ( dom ( Directed D50 ) ) \/ ( dom ( Reloc (D52 , 2) ) ) ) by L155 , FUNCT_4:def 1;
L157: ( dom ( if=0 (C37 , D47 , D46) ) ) = ( ( dom D50 ) \/ ( dom ( Reloc (D52 , 2) ) ) ) by L156 , FUNCT_4:99;
L158: 2 in ( dom ( Reloc (D52 , 2) ) ) by L157 , L154 , L152 , XBOOLE_0:def 3;
L159: ( Reloc (D52 , 2) ) = ( IncAddr (( Shift (D52 , 2) ) , 2) ) by COMPOS_1:34;
thus L160: ( ( while=0 (C37 , C38) ) . 2 ) = ( ( ( Directed D50 ) +* ( Reloc (D52 , 2) ) ) . 2 ) by L145 , L153 , L155 , FUNCT_4:def 1
.= ( ( Reloc (D52 , 2) ) . 2 ) by L154 , L156 , L158 , FUNCT_4:def 1
.= ( IncAddr (( goto ( card D46 ) ) , 2) ) by L149 , L150 , L159 , COMPOS_1:def 21
.= ( goto ( 1 + 2 ) ) by L1 , SCMFSA_4:1
.= ( goto 3 );
end;
theorem
L161: (for B32 being Int-Location holds (for B33 being (Program of ( SCM+FSA )) holds (for B34 being (Element of ( NAT )) holds (B34 < ( ( card B33 ) + 6 ) implies B34 in ( dom ( while=0 (B32 , B33) ) )))))
proof
let C39 being Int-Location;
let C40 being (Program of ( SCM+FSA ));
let C41 being (Element of ( NAT ));
assume L162: C41 < ( ( card C40 ) + 6 );
L163: ( card ( while=0 (C39 , C40) ) ) = ( ( card C40 ) + 6 ) by L33;
thus L164: thesis by L163 , L162 , AFINSQ_1:66;
end;
theorem
L165: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B35 being (State of ( SCM+FSA )) holds (for B36 being (Program of ( SCM+FSA )) holds (for B37 being  read-write Int-Location holds (( B35 . B37 ) <> ( 0 ) implies (( while=0 (B37 , B36) ) is_halting_on B35 , R1 & ( while=0 (B37 , B36) ) is_closed_on B35 , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C42 being (State of ( SCM+FSA ));
let C43 being (Program of ( SCM+FSA ));
let C44 being  read-write Int-Location;
assume L166: ( C42 . C44 ) <> ( 0 );
set D53 = ( C44 =0_goto 4 );
set D54 = ( Initialize C42 );
set D55 = ( R1 +* ( while=0 (C44 , C43) ) );
L167: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L168: ( IC D54 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L167 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
set D56 = ( ( card C43 ) + 5 );
set D57 = ( Comput (D55 , D54 , 4) );
set D58 = ( Comput (D55 , D54 , 3) );
set D59 = ( Comput (D55 , D54 , 2) );
set D60 = ( Comput (D55 , D54 , 1) );
L169: 1 in ( dom ( while=0 (C44 , C43) ) ) by L54;
L170: 2 in ( dom ( while=0 (C44 , C43) ) ) by L94;
L171: (not C44 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L172: ( D54 . C44 ) = ( C42 . C44 ) by L171 , FUNCT_4:11;
L173: ( D55 /. ( IC D54 ) ) = ( D55 . ( IC D54 ) ) by PBOOLE:143;
L174: ( 0 ) in ( dom ( while=0 (C44 , C43) ) ) by L54;
L175: ( D55 . ( 0 ) ) = ( ( while=0 (C44 , C43) ) . ( 0 ) ) by L174 , FUNCT_4:13
.= D53 by L71;
L176: ( CurInstr (D55 , D54) ) = D53 by L175 , L168 , L173;
L177: ( Comput (D55 , D54 , ( ( 0 ) + 1 )) ) = ( Following (D55 , ( Comput (D55 , D54 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D55 , D54) )
.= ( Exec (D53 , D54) ) by L176;
L178: ( IC ( Comput (D55 , D54 , 1) ) ) = ( succ ( 0 ) ) by L166 , L168 , L177 , L172 , SCMFSA_2:70
.= ( ( 0 ) + 1 );
L179: ( D55 /. ( IC ( Comput (D55 , D54 , 1) ) ) ) = ( D55 . ( IC ( Comput (D55 , D54 , 1) ) ) ) by PBOOLE:143;
L180: ( D55 . 1 ) = ( ( while=0 (C44 , C43) ) . 1 ) by L169 , FUNCT_4:13
.= ( goto 2 ) by L71;
L181: ( CurInstr (D55 , ( Comput (D55 , D54 , 1) )) ) = ( goto 2 ) by L180 , L178 , L179;
L182: ( Comput (D55 , D54 , ( 1 + 1 )) ) = ( Following (D55 , D60) ) by EXTPRO_1:3
.= ( Exec (( goto 2 ) , D60) ) by L181;
L183: ( IC D59 ) = 2 by L182 , SCMFSA_2:69;
L184: ( D55 /. ( IC D59 ) ) = ( D55 . ( IC D59 ) ) by PBOOLE:143;
L185: ( D55 . 2 ) = ( ( while=0 (C44 , C43) ) . 2 ) by L170 , FUNCT_4:13
.= ( goto 3 ) by L143;
L186: ( CurInstr (D55 , D59) ) = ( goto 3 ) by L185 , L183 , L184;
L187: ( Comput (D55 , D54 , ( 2 + 1 )) ) = ( Following (D55 , D59) ) by EXTPRO_1:3
.= ( Exec (( goto 3 ) , D59) ) by L186;
L188: ( IC D58 ) = 3 by L187 , SCMFSA_2:69;
L189: 3 in ( dom ( while=0 (C44 , C43) ) ) by L94;
L190: D56 in ( dom ( while=0 (C44 , C43) ) ) by L100;
L191: ( D55 /. ( IC D58 ) ) = ( D55 . ( IC D58 ) ) by PBOOLE:143;
L192: ( D55 . 3 ) = ( ( while=0 (C44 , C43) ) . 3 ) by L189 , FUNCT_4:13
.= ( goto D56 ) by L122;
L193: ( CurInstr (D55 , D58) ) = ( goto D56 ) by L192 , L188 , L191;
L194: ( Comput (D55 , D54 , ( 3 + 1 )) ) = ( Following (D55 , D58) ) by EXTPRO_1:3
.= ( Exec (( goto D56 ) , D58) ) by L193;
L195: ( IC D57 ) = D56 by L194 , SCMFSA_2:69;
L196: ( D55 /. ( IC D57 ) ) = ( D55 . ( IC D57 ) ) by PBOOLE:143;
L197: ( D55 . D56 ) = ( ( while=0 (C44 , C43) ) . D56 ) by L190 , FUNCT_4:13
.= ( halt ( SCM+FSA ) ) by L105;
L198: ( CurInstr (D55 , D57) ) = ( halt ( SCM+FSA ) ) by L197 , L195 , L196;
L199: D55 halts_on D54 by L198 , EXTPRO_1:29;
thus L200: ( while=0 (C44 , C43) ) is_halting_on C42 , R1 by L199 , SCMFSA7B:def 7;
L201:
now
let C45 being (Element of ( NAT ));
L202: (C45 <= 3 or C45 >= ( 3 + 1 )) by NAT_1:13;
per cases  by L202 , NAT_1:27;
suppose L203: C45 = ( 0 );

thus L204: ( IC ( Comput (D55 , D54 , C45) ) ) in ( dom ( while=0 (C44 , C43) ) ) by L203 , L174 , L168 , EXTPRO_1:2;
end;
suppose L205: C45 = 1;

thus L206: ( IC ( Comput (D55 , D54 , C45) ) ) in ( dom ( while=0 (C44 , C43) ) ) by L205 , L178 , L54;
end;
suppose L207: C45 = 2;

thus L208: ( IC ( Comput (D55 , D54 , C45) ) ) in ( dom ( while=0 (C44 , C43) ) ) by L207 , L183 , L94;
end;
suppose L209: C45 = 3;

thus L210: ( IC ( Comput (D55 , D54 , C45) ) ) in ( dom ( while=0 (C44 , C43) ) ) by L209 , L188 , L94;
end;
suppose L211: C45 >= 4;

thus L212: ( IC ( Comput (D55 , D54 , C45) ) ) in ( dom ( while=0 (C44 , C43) ) ) by L211 , L190 , L195 , L198 , EXTPRO_1:5;
end;
end;
thus L214: thesis by L201 , SCMFSA7B:def 6;
end;
theorem
L215: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B38 being Int-Location holds (for B39 being (Program of ( SCM+FSA )) holds (for B40 being (State of ( SCM+FSA )) holds (for B41 being (Element of ( NAT )) holds ((B39 is_closed_on B40 , R1 & B39 is_halting_on B40 , R1 & B41 < ( LifeSpan (( R1 +* B39 ) , ( Initialize B40 )) ) & ( IC ( Comput (( R1 +* ( while=0 (B38 , B39) ) ) , ( Initialize B40 ) , ( 1 + B41 )) ) ) = ( ( IC ( Comput (( R1 +* B39 ) , ( Initialize B40 ) , B41) ) ) + 4 ) & ( DataPart ( Comput (( R1 +* ( while=0 (B38 , B39) ) ) , ( Initialize B40 ) , ( 1 + B41 )) ) ) = ( DataPart ( Comput (( R1 +* B39 ) , ( Initialize B40 ) , B41) ) )) implies (( IC ( Comput (( R1 +* ( while=0 (B38 , B39) ) ) , ( Initialize B40 ) , ( ( 1 + B41 ) + 1 )) ) ) = ( ( IC ( Comput (( R1 +* B39 ) , ( Initialize B40 ) , ( B41 + 1 )) ) ) + 4 ) & ( DataPart ( Comput (( R1 +* ( while=0 (B38 , B39) ) ) , ( Initialize B40 ) , ( ( 1 + B41 ) + 1 )) ) ) = ( DataPart ( Comput (( R1 +* B39 ) , ( Initialize B40 ) , ( B41 + 1 )) ) ))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
set D61 = ( ( Goto ( 0 ) ) ";" ( Stop ( SCM+FSA ) ) );
set D62 = ( Stop ( SCM+FSA ) );
let C46 being Int-Location;
set D63 = ( ( Int-Locations ) \/ ( FinSeq-Locations ) );
let C47 being (Program of ( SCM+FSA ));
let C48 being (State of ( SCM+FSA ));
let C49 being (Element of ( NAT ));
set D64 = ( Initialize C48 );
set D65 = ( R1 +* ( while=0 (C46 , C47) ) );
set D66 = ( Initialize C48 );
set D67 = ( R1 +* C47 );
L216: C47 c= D67 by FUNCT_4:25;
set D68 = ( Comput (D65 , D64 , ( 1 + C49 )) );
set D69 = ( Comput (D67 , D66 , C49) );
set D70 = ( IC ( Comput (D67 , D66 , C49) ) );
set D71 = ( C47 ";" ( Goto ( 0 ) ) );
set D72 = ( C46 =0_goto ( ( card D62 ) + 3 ) );
reconsider D73 = D70 as (Element of ( NAT ));
set D74 = ( ( D72 ";" D62 ) ";" ( Goto ( ( card D71 ) + 1 ) ) );
set D75 = ( D71 ";" ( Stop ( SCM+FSA ) ) );
L217: ( rng C47 ) c= (the InstructionsF of ( SCM+FSA )) by RELAT_1:def 19;
assume L218: C47 is_closed_on C48 , R1;
L219: D73 in ( dom C47 ) by L218 , SCMFSA7B:def 6;
L220: D73 < ( card C47 ) by L219 , AFINSQ_1:66;
L221: ( D73 + 4 ) < ( ( card C47 ) + 6 ) by L220 , XREAL_1:8;
L222: ( D67 /. ( IC D69 ) ) = ( D67 . ( IC D69 ) ) by PBOOLE:143;
L223: ( CurInstr (D67 , D69) ) = ( D67 . D73 ) by L222
.= ( C47 . D73 ) by L219 , L216 , GRFUNC_1:2;
assume L224: C47 is_halting_on C48 , R1;
L225: D67 halts_on D66 by L224 , SCMFSA7B:def 7;
assume L226: C49 < ( LifeSpan (D67 , D66) );
L227: ( C47 . D73 ) <> ( halt ( SCM+FSA ) ) by L226 , L223 , L225 , EXTPRO_1:def 15;
L228: D75 = ( C47 ";" D61 ) by SCMFSA6A:25;
L229: ( dom D75 ) = ( ( dom ( Directed C47 ) ) \/ ( dom ( Reloc (D61 , ( card C47 )) ) ) ) by L228 , FUNCT_4:def 1
.= ( ( dom C47 ) \/ ( dom ( Reloc (D61 , ( card C47 )) ) ) ) by FUNCT_4:99;
L230: D73 in ( dom D75 ) by L229 , L219 , XBOOLE_0:def 3;
L231: ( D73 + 4 ) in { ( B42 + 4 ) where B42 is (Element of ( NAT )) : B42 in ( dom D75 ) } by L230;
L232: ( D73 + 4 ) in ( dom ( Shift (D75 , 4) ) ) by L231 , VALUED_1:def 12;
L233: ( ( Shift (D75 , 4) ) /. ( D73 + 4 ) ) = ( ( Shift (D75 , 4) ) . ( D73 + 4 ) ) by L232 , PARTFUN1:def 6
.= ( D75 . D73 ) by L230 , VALUED_1:def 12
.= ( ( Directed C47 ) . D73 ) by L219 , L228 , SCMFSA8A:14
.= ( C47 . D73 ) by L219 , L227 , SCMFSA8A:16;
L234: ( card ( while=0 (C46 , C47) ) ) = ( ( card C47 ) + 6 ) by L33;
L235: ( D73 + 4 ) in ( dom ( while=0 (C46 , C47) ) ) by L234 , L221 , AFINSQ_1:66;
L236: ( C47 . D73 ) in ( rng C47 ) by L219 , FUNCT_1:def 3;
reconsider D76 = ( C47 . D73 ) as (Instruction of ( SCM+FSA )) by L236 , L217;
L237: ( card D74 ) = ( ( card ( D72 ";" D62 ) ) + ( card ( Goto ( ( card D71 ) + 1 ) ) ) ) by SCMFSA6A:21
.= ( ( card ( D72 ";" D62 ) ) + 1 ) by SCMFSA8A:15
.= ( ( ( card ( Macro D72 ) ) + ( card D62 ) ) + 1 ) by SCMFSA6A:21
.= ( ( 2 + 1 ) + 1 ) by L1 , COMPOS_1:56
.= ( 3 + 1 );
L238: ( D73 + 4 ) >= ( card D74 ) by L237 , NAT_1:11;
L239: (not ( D73 + 4 ) in ( dom D74 )) by L238 , AFINSQ_1:66;
L240: ( Comput (D67 , D66 , ( C49 + 1 )) ) = ( Following (D67 , D69) ) by EXTPRO_1:3
.= ( Exec (D76 , D69) ) by L223;
set D77 = ( ( ( card C47 ) + 4 ) .--> ( goto ( 0 ) ) );
assume L241: ( IC ( Comput (D65 , D64 , ( 1 + C49 )) ) ) = ( D70 + 4 );
L242: (( dom D77 ) = { ( ( card C47 ) + 4 ) } & ( D73 + 4 ) <> ( ( card C47 ) + 4 )) by L219 , FUNCOP_1:13;
L243: (not ( D73 + 4 ) in ( dom D77 )) by L242 , TARSKI:def 1;
L244: ( dom ( while=0 (C46 , C47) ) ) = ( ( dom ( if=0 (C46 , D71 , D62) ) ) \/ ( dom D77 ) ) by FUNCT_4:def 1;
L245: ( D73 + 4 ) in ( dom ( if=0 (C46 , D71 , D62) ) ) by L244 , L243 , L235 , XBOOLE_0:def 3;
L246: ( CutLastLoc ( stop D74 ) ) = D74;
L247: ( if=0 (C46 , D71 , D62) ) = ( ( D74 ";" D71 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1
.= ( D74 ";" D75 ) by SCMFSA6A:25
.= ( ( Directed D74 ) +* ( Reloc (D75 , 4) ) ) by L237 , L246;
L248: ( dom ( if=0 (C46 , D71 , D62) ) ) = ( ( dom ( Directed D74 ) ) \/ ( dom ( Reloc (D75 , 4) ) ) ) by L247 , FUNCT_4:def 1;
L249: ( dom ( if=0 (C46 , D71 , D62) ) ) = ( ( dom D74 ) \/ ( dom ( Reloc (D75 , 4) ) ) ) by L248 , FUNCT_4:99;
L250: ( D73 + 4 ) in ( dom ( Reloc (D75 , 4) ) ) by L249 , L245 , L239 , XBOOLE_0:def 3;
L251: ( D65 /. ( IC D68 ) ) = ( D65 . ( IC D68 ) ) by PBOOLE:143;
L252: ( Reloc (D75 , 4) ) = ( IncAddr (( Shift (D75 , 4) ) , 4) ) by COMPOS_1:34;
L253: ( D65 . ( D73 + 4 ) ) = ( ( while=0 (C46 , C47) ) . ( D73 + 4 ) ) by L235 , FUNCT_4:13
.= ( ( ( Directed D74 ) +* ( Reloc (D75 , 4) ) ) . ( D73 + 4 ) ) by L243 , L235 , L244 , L247 , FUNCT_4:def 1
.= ( ( Reloc (D75 , 4) ) . ( D73 + 4 ) ) by L245 , L248 , L250 , FUNCT_4:def 1
.= ( IncAddr (D76 , 4) ) by L232 , L233 , L252 , COMPOS_1:def 21;
L254: ( CurInstr (D65 , D68) ) = ( IncAddr (D76 , 4) ) by L253 , L241 , L251;
assume L255: ( DataPart D68 ) = ( DataPart D69 );
L256: ( Comput (D65 , D64 , ( ( 1 + C49 ) + 1 )) ) = ( Following (D65 , D68) ) by EXTPRO_1:3
.= ( Exec (( IncAddr (D76 , 4) ) , D68) ) by L254;
thus L257: thesis by L256 , L241 , L255 , L240 , SCMFSA6A:8;
end;
theorem
L258: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B43 being Int-Location holds (for B44 being (Program of ( SCM+FSA )) holds (for B45 being (State of ( SCM+FSA )) holds ((B44 is_closed_on B45 , R1 & B44 is_halting_on B45 , R1 & ( IC ( Comput (( R1 +* ( while=0 (B43 , B44) ) ) , ( Initialize B45 ) , ( 1 + ( LifeSpan (( R1 +* B44 ) , ( Initialize B45 )) ) )) ) ) = ( ( IC ( Comput (( R1 +* B44 ) , ( Initialize B45 ) , ( LifeSpan (( R1 +* B44 ) , ( Initialize B45 )) )) ) ) + 4 )) implies ( CurInstr (( R1 +* ( while=0 (B43 , B44) ) ) , ( Comput (( R1 +* ( while=0 (B43 , B44) ) ) , ( Initialize B45 ) , ( 1 + ( LifeSpan (( R1 +* B44 ) , ( Initialize B45 )) ) )) )) ) = ( goto ( ( card B44 ) + 4 ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
set D78 = ( ( Goto ( 0 ) ) ";" ( Stop ( SCM+FSA ) ) );
set D79 = ( Stop ( SCM+FSA ) );
let C50 being Int-Location;
let C51 being (Program of ( SCM+FSA ));
let C52 being (State of ( SCM+FSA ));
set D80 = ( Initialize C52 );
set D81 = ( R1 +* ( while=0 (C50 , C51) ) );
set D82 = ( Initialize C52 );
set D83 = ( R1 +* C51 );
L259: C51 c= D83 by FUNCT_4:25;
set D84 = ( LifeSpan (( R1 +* C51 ) , ( Initialize C52 )) );
set D85 = ( Comput (D81 , D80 , ( 1 + D84 )) );
set D86 = ( Comput (D83 , D82 , D84) );
set D87 = ( C51 ";" ( Goto ( 0 ) ) );
set D88 = ( C50 =0_goto ( ( card D79 ) + 3 ) );
reconsider D89 = ( IC D86 ) as (Element of ( NAT ));
set D90 = ( ( D88 ";" D79 ) ";" ( Goto ( ( card D87 ) + 1 ) ) );
set D91 = ( D87 ";" ( Stop ( SCM+FSA ) ) );
assume L260: C51 is_closed_on C52 , R1;
L261: D89 in ( dom C51 ) by L260 , SCMFSA7B:def 6;
L262: D89 < ( card C51 ) by L261 , AFINSQ_1:66;
L263: ( D89 + 4 ) < ( ( card C51 ) + 6 ) by L262 , XREAL_1:8;
assume L264: C51 is_halting_on C52 , R1;
L265: D83 halts_on D82 by L264 , SCMFSA7B:def 7;
L266: ( D83 /. ( IC D86 ) ) = ( D83 . ( IC D86 ) ) by PBOOLE:143;
L267: ( D81 /. ( IC D85 ) ) = ( D81 . ( IC D85 ) ) by PBOOLE:143;
L268: ( CurInstr (D83 , D86) ) = ( D83 . D89 ) by L266
.= ( C51 . D89 ) by L261 , L259 , GRFUNC_1:2;
L269: ( C51 . D89 ) = ( halt ( SCM+FSA ) ) by L268 , L265 , EXTPRO_1:def 15;
L270: D91 = ( C51 ";" D78 ) by SCMFSA6A:25;
L271: ( dom D91 ) = ( ( dom ( Directed C51 ) ) \/ ( dom ( Reloc (D78 , ( card C51 )) ) ) ) by L270 , FUNCT_4:def 1
.= ( ( dom C51 ) \/ ( dom ( Reloc (D78 , ( card C51 )) ) ) ) by FUNCT_4:99;
L272: D89 in ( dom D91 ) by L271 , L261 , XBOOLE_0:def 3;
L273: ( D89 + 4 ) in { ( B46 + 4 ) where B46 is (Element of ( NAT )) : B46 in ( dom D91 ) } by L272;
L274: ( D89 + 4 ) in ( dom ( Shift (D91 , 4) ) ) by L273 , VALUED_1:def 12;
L275: ( ( Shift (D91 , 4) ) /. ( D89 + 4 ) ) = ( ( Shift (D91 , 4) ) . ( D89 + 4 ) ) by L274 , PARTFUN1:def 6
.= ( D91 . D89 ) by L272 , VALUED_1:def 12
.= ( ( Directed C51 ) . D89 ) by L261 , L270 , SCMFSA8A:14
.= ( goto ( card C51 ) ) by L261 , L269 , SCMFSA8A:16;
set D92 = ( ( ( card C51 ) + 4 ) .--> ( goto ( 0 ) ) );
assume L276: ( IC D85 ) = ( ( IC D86 ) + 4 );
L277: (( dom D92 ) = { ( ( card C51 ) + 4 ) } & ( D89 + 4 ) <> ( ( card C51 ) + 4 )) by L261 , FUNCOP_1:13;
L278: (not ( D89 + 4 ) in ( dom D92 )) by L277 , TARSKI:def 1;
L279: ( card D90 ) = ( ( card ( D88 ";" D79 ) ) + ( card ( Goto ( ( card D87 ) + 1 ) ) ) ) by SCMFSA6A:21
.= ( ( card ( D88 ";" D79 ) ) + 1 ) by SCMFSA8A:15
.= ( ( ( card ( Macro D88 ) ) + ( card D79 ) ) + 1 ) by SCMFSA6A:21
.= ( ( 2 + 1 ) + 1 ) by L1 , COMPOS_1:56
.= ( 3 + 1 );
L280: ( D89 + 4 ) >= ( card D90 ) by L279 , NAT_1:11;
L281: (not ( D89 + 4 ) in ( dom D90 )) by L280 , AFINSQ_1:66;
L282: ( card ( while=0 (C50 , C51) ) ) = ( ( card C51 ) + 6 ) by L33;
L283: ( D89 + 4 ) in ( dom ( while=0 (C50 , C51) ) ) by L282 , L263 , AFINSQ_1:66;
L284: ( dom ( while=0 (C50 , C51) ) ) = ( ( dom ( if=0 (C50 , D87 , D79) ) ) \/ ( dom D92 ) ) by FUNCT_4:def 1;
L285: ( D89 + 4 ) in ( dom ( if=0 (C50 , D87 , D79) ) ) by L284 , L278 , L283 , XBOOLE_0:def 3;
L286: ( CutLastLoc ( stop D90 ) ) = D90;
L287: ( if=0 (C50 , D87 , D79) ) = ( ( D90 ";" D87 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1
.= ( D90 ";" D91 ) by SCMFSA6A:25
.= ( ( Directed D90 ) +* ( Reloc (D91 , 4) ) ) by L279 , L286;
L288: ( dom ( if=0 (C50 , D87 , D79) ) ) = ( ( dom ( Directed D90 ) ) \/ ( dom ( Reloc (D91 , 4) ) ) ) by L287 , FUNCT_4:def 1;
L289: ( dom ( if=0 (C50 , D87 , D79) ) ) = ( ( dom D90 ) \/ ( dom ( Reloc (D91 , 4) ) ) ) by L288 , FUNCT_4:99;
L290: ( D89 + 4 ) in ( dom ( Reloc (D91 , 4) ) ) by L289 , L285 , L281 , XBOOLE_0:def 3;
L291: ( Reloc (D91 , 4) ) = ( IncAddr (( Shift (D91 , 4) ) , 4) ) by COMPOS_1:34;
L292: ( D81 . ( D89 + 4 ) ) = ( ( while=0 (C50 , C51) ) . ( D89 + 4 ) ) by L283 , FUNCT_4:13
.= ( ( ( Directed D90 ) +* ( Reloc (D91 , 4) ) ) . ( D89 + 4 ) ) by L278 , L283 , L284 , L287 , FUNCT_4:def 1
.= ( ( Reloc (D91 , 4) ) . ( D89 + 4 ) ) by L285 , L288 , L290 , FUNCT_4:def 1
.= ( IncAddr (( goto ( card C51 ) ) , 4) ) by L274 , L275 , L291 , COMPOS_1:def 21
.= ( goto ( ( card C51 ) + 4 ) ) by SCMFSA_4:1;
thus L293: thesis by L292 , L276 , L267;
end;
theorem
L294: (for B47 being Int-Location holds (for B48 being (Program of ( SCM+FSA )) holds ( ( while=0 (B47 , B48) ) . ( ( card B48 ) + 4 ) ) = ( goto ( 0 ) )))
proof
set D93 = ( Stop ( SCM+FSA ) );
let C53 being Int-Location;
let C54 being (Program of ( SCM+FSA ));
set D94 = ( C54 ";" ( Goto ( 0 ) ) );
set D95 = ( ( ( card C54 ) + 4 ) .--> ( goto ( 0 ) ) );
set D96 = ( ( card C54 ) + 4 );
L295: ( dom D95 ) = { D96 } by FUNCOP_1:13;
L296: D96 in ( dom D95 ) by L295 , TARSKI:def 1;
L297: (D96 in ( dom ( while=0 (C53 , C54) ) ) & ( dom ( while=0 (C53 , C54) ) ) = ( ( dom ( if=0 (C53 , D94 , D93) ) ) \/ ( dom D95 ) )) by L100 , FUNCT_4:def 1;
thus L298: ( ( while=0 (C53 , C54) ) . D96 ) = ( D95 . D96 ) by L297 , L296 , FUNCT_4:def 1
.= ( goto ( 0 ) ) by FUNCOP_1:72;
end;
theorem
L299: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B49 being (State of ( SCM+FSA )) holds (for B50 being (Program of ( SCM+FSA )) holds (for B51 being  read-write Int-Location holds ((B50 is_closed_on B49 , R1 & B50 is_halting_on B49 , R1 & ( B49 . B51 ) = ( 0 )) implies (( IC ( Comput (( R1 +* ( while=0 (B51 , B50) ) ) , ( Initialize B49 ) , ( ( LifeSpan (( R1 +* B50 ) , ( Initialize B49 )) ) + 3 )) ) ) = ( 0 ) & (for B52 being (Element of ( NAT )) holds (B52 <= ( ( LifeSpan (( R1 +* B50 ) , ( Initialize B49 )) ) + 3 ) implies ( IC ( Comput (( R1 +* ( while=0 (B51 , B50) ) ) , ( Initialize B49 ) , B52) ) ) in ( dom ( while=0 (B51 , B50) ) )))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
set D97 = ( ( Int-Locations ) \/ ( FinSeq-Locations ) );
let C55 being (State of ( SCM+FSA ));
let C56 being (Program of ( SCM+FSA ));
let C57 being  read-write Int-Location;
assume L300: C56 is_closed_on C55 , R1;
set D98 = ( Initialize C55 );
set D99 = ( R1 +* C56 );
set D100 = ( Initialize C55 );
set D101 = ( R1 +* ( while=0 (C57 , C56) ) );
defpred S1[ Nat ] means ($1 <= ( LifeSpan (D99 , D98) ) implies (( IC ( Comput (D101 , D100 , ( 1 + $1 )) ) ) = ( ( IC ( Comput (D99 , D98 , $1) ) ) + 4 ) & ( DataPart ( Comput (D101 , D100 , ( 1 + $1 )) ) ) = ( DataPart ( Comput (D99 , D98 , $1) ) )));
assume L301: C56 is_halting_on C55 , R1;
L302:
now
let C58 being (Element of ( NAT ));
assume L303: S1[ C58 ];
L304:
now
L305: ( C58 + ( 0 ) ) < ( C58 + 1 ) by XREAL_1:6;
assume L306: ( C58 + 1 ) <= ( LifeSpan (D99 , D98) );
L307: C58 < ( LifeSpan (D99 , D98) ) by L306 , L305 , XXREAL_0:2;
thus L308: (( IC ( Comput (D101 , D100 , ( ( 1 + C58 ) + 1 )) ) ) = ( ( IC ( Comput (D99 , D98 , ( C58 + 1 )) ) ) + 4 ) & ( DataPart ( Comput (D101 , D100 , ( ( 1 + C58 ) + 1 )) ) ) = ( DataPart ( Comput (D99 , D98 , ( C58 + 1 )) ) )) by L307 , L300 , L301 , L303 , L215;
end;
thus L309: S1[ ( C58 + 1 ) ] by L304;
end;
reconsider D102 = ( LifeSpan (D99 , D98) ) as (Element of ( NAT ));
set D103 = ( ( card C56 ) + 4 );
set D104 = ( C57 =0_goto 4 );
set D105 = ( Comput (D101 , D100 , 1) );
L310: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L311: ( IC D100 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L310 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L312: (not C57 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L313: ( D100 . C57 ) = ( C55 . C57 ) by L312 , FUNCT_4:11;
assume L314: ( C55 . C57 ) = ( 0 );
L315: ( 0 ) in ( dom ( while=0 (C57 , C56) ) ) by L54;
L316: ( D101 /. ( IC D100 ) ) = ( D101 . ( IC D100 ) ) by PBOOLE:143;
L317: ( D101 . ( 0 ) ) = ( ( while=0 (C57 , C56) ) . ( 0 ) ) by L315 , FUNCT_4:13
.= D104 by L71;
L318: ( CurInstr (D101 , D100) ) = D104 by L317 , L311 , L316;
L319: ( Comput (D101 , D100 , ( ( 0 ) + 1 )) ) = ( Following (D101 , ( Comput (D101 , D100 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D101 , D100) )
.= ( Exec (D104 , D100) ) by L318;
L320: ((for R6 being Int-Location holds ( D105 . R6 ) = ( D100 . R6 )) & (for R5 being FinSeq-Location holds ( D105 . R5 ) = ( D100 . R5 ))) by L319 , SCMFSA_2:70;
L321: ( DataPart D105 ) = ( DataPart D100 ) by L320 , SCMFSA_M:2
.= ( DataPart D98 );
L322: ( IC D105 ) = 4 by L314 , L319 , L313 , SCMFSA_2:70;
L323: S1[ ( 0 ) ]
proof
assume L324: ( 0 ) <= ( LifeSpan (D99 , D98) );
L325: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L326: ( IC ( Comput (D99 , D98 , ( 0 )) ) ) = ( IC D98 )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L325 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
thus L327: thesis by L326 , L322 , L321;
end;
L328: (for B53 being (Element of ( NAT )) holds S1[ B53 ]) from NAT_1:sch 1(L323 , L302);
set D106 = ( Comput (D101 , D100 , ( ( ( 1 + ( LifeSpan (D99 , D98) ) ) + 1 ) + 1 )) );
set D107 = ( Comput (D101 , D100 , ( ( 1 + ( LifeSpan (D99 , D98) ) ) + 1 )) );
L329: D103 in ( dom ( while=0 (C57 , C56) ) ) by L100;
set D108 = ( Comput (D101 , D100 , ( 1 + ( LifeSpan (D99 , D98) ) )) );
L330: S1[ D102 ] by L328;
L331: ( CurInstr (D101 , D108) ) = ( goto D103 ) by L330 , L300 , L301 , L258;
L332: D107 = ( Following (D101 , D108) ) by EXTPRO_1:3
.= ( Exec (( goto D103 ) , D108) ) by L331;
L333: ( IC D107 ) = D103 by L332 , SCMFSA_2:69;
L334: ( D101 /. ( IC D107 ) ) = ( D101 . ( IC D107 ) ) by PBOOLE:143;
L335: ( D101 . D103 ) = ( ( while=0 (C57 , C56) ) . D103 ) by L329 , FUNCT_4:13
.= ( goto ( 0 ) ) by L294;
L336: ( CurInstr (D101 , D107) ) = ( goto ( 0 ) ) by L335 , L333 , L334;
L337: D106 = ( Following (D101 , D107) ) by EXTPRO_1:3
.= ( Exec (( goto ( 0 ) ) , D107) ) by L336;
L338: ( IC D106 ) = ( 0 ) by L337 , SCMFSA_2:69;
thus L339: ( IC ( Comput (D101 , D100 , ( ( LifeSpan (D99 , D98) ) + 3 )) ) ) = ( 0 ) by L338;
L340: ( ( ( ( LifeSpan (D99 , D98) ) + 1 ) + 1 ) + 1 ) = ( ( LifeSpan (D99 , D98) ) + ( 2 + 1 ) );
L341:
now
let C59 being (Element of ( NAT ));
assume L342: C59 <= ( ( LifeSpan (D99 , D98) ) + 3 );
assume L343: C59 <> ( 0 );
consider C60 being Nat such that L344: C59 = ( C60 + 1 ) by L343 , NAT_1:6;
L345: (C59 <= ( ( LifeSpan (D99 , D98) ) + 1 ) or C59 >= ( ( ( LifeSpan (D99 , D98) ) + 1 ) + 1 )) by NAT_1:13;
L346: (C59 <= ( ( LifeSpan (D99 , D98) ) + 1 ) or C59 = ( ( ( LifeSpan (D99 , D98) ) + 1 ) + 1 ) or C59 > ( ( ( LifeSpan (D99 , D98) ) + 1 ) + 1 )) by L345 , XXREAL_0:1;
reconsider D109 = C60 as (Element of ( NAT )) by ORDINAL1:def 12;
per cases  by L340 , L346 , NAT_1:13;
suppose L347: C59 <= ( ( LifeSpan (D99 , D98) ) + 1 );

L348: D109 <= ( LifeSpan (D99 , D98) ) by L347 , L344 , XREAL_1:6;
L349: ( IC ( Comput (D101 , D100 , ( 1 + D109 )) ) ) = ( ( IC ( Comput (D99 , D98 , D109) ) ) + 4 ) by L348 , L328;
reconsider D110 = ( IC ( Comput (D99 , D98 , D109) ) ) as (Element of ( NAT ));
L350: D110 in ( dom C56 ) by L300 , SCMFSA7B:def 6;
L351: D110 < ( card C56 ) by L350 , AFINSQ_1:66;
L352: ( D110 + 4 ) < ( ( card C56 ) + 6 ) by L351 , XREAL_1:8;
L353: ( card ( while=0 (C57 , C56) ) ) = ( ( card C56 ) + 6 ) by L33;
thus L354: ( IC ( Comput (D101 , D100 , C59) ) ) in ( dom ( while=0 (C57 , C56) ) ) by L353 , L344 , L349 , L352 , AFINSQ_1:66;
end;
suppose L355: C59 = ( ( ( LifeSpan (D99 , D98) ) + 1 ) + 1 );

thus L356: ( IC ( Comput (D101 , D100 , C59) ) ) in ( dom ( while=0 (C57 , C56) ) ) by L355 , L333 , L100;
end;
suppose L357: C59 >= ( ( LifeSpan (D99 , D98) ) + 3 );

L358: C59 = ( ( LifeSpan (D99 , D98) ) + 3 ) by L357 , L342 , XXREAL_0:1;
thus L359: ( IC ( Comput (D101 , D100 , C59) ) ) in ( dom ( while=0 (C57 , C56) ) ) by L358 , L338 , L54;
end;
end;
L361:
now
let C61 being (Element of ( NAT ));
assume L362: C61 <= ( ( LifeSpan (D99 , D98) ) + 3 );
per cases ;
suppose L363: C61 = ( 0 );

thus L364: ( IC ( Comput (D101 , D100 , C61) ) ) in ( dom ( while=0 (C57 , C56) ) ) by L363 , L315 , L311 , EXTPRO_1:2;
end;
suppose L365: C61 <> ( 0 );

thus L366: ( IC ( Comput (D101 , D100 , C61) ) ) in ( dom ( while=0 (C57 , C56) ) ) by L365 , L341 , L362;
end;
end;
thus L368: thesis by L361;
end;
definition
let R7 being (State of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
let R9 being  read-write Int-Location;
let R1 being (Instruction-Sequence of ( SCM+FSA ));
deffunc H1(Nat , (State of ( SCM+FSA ))) = ( Comput (( R1 +* ( while=0 (R9 , R8) ) ) , ( $2 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) , ( ( LifeSpan (( ( R1 +* ( while=0 (R9 , R8) ) ) +* R8 ) , ( $2 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) )) ) + 3 )) );
deffunc H2(Nat , (State of ( SCM+FSA ))) = ( down H1($1 , $2) );
func StepWhile=0 (R9 , R8 , R1 , R7) -> (Function of ( NAT ) , ( product ( the_Values_of ( SCM+FSA ) ) )) means 
:L369: (( it . ( 0 ) ) = R7 & (for B54 being Nat holds ( it . ( B54 + 1 ) ) = ( Comput (( R1 +* ( while=0 (R9 , R8) ) ) , ( ( it . B54 ) +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) , ( ( LifeSpan (( ( R1 +* ( while=0 (R9 , R8) ) ) +* R8 ) , ( ( it . B54 ) +* ( Start-At (( 0 ) , ( SCM+FSA )) ) )) ) + 3 )) )));
existence
proof
reconsider D111 = R7 as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
consider C62 being (Function of ( NAT ) , ( product ( the_Values_of ( SCM+FSA ) ) )) such that L370: ( C62 . ( 0 ) ) = D111 and L371: (for B55 being Nat holds ( C62 . ( B55 + 1 ) ) = H2(B55 , ( C62 . B55 ))) from NAT_1:sch 12;
take C62;
thus L372: ( C62 . ( 0 ) ) = R7 by L370;
let C63 being Nat;
L373: ( C62 . ( C63 + 1 ) ) = H2(C63 , ( C62 . C63 )) by L371;
thus L374: thesis by L373;
end;
uniqueness
proof
let C64 , C65 being (Function of ( NAT ) , ( product ( the_Values_of ( SCM+FSA ) ) ));
assume that
L375: ( C64 . ( 0 ) ) = R7
and
L376: (for B56 being Nat holds ( C64 . ( B56 + 1 ) ) = H1(B56 , ( C64 . B56 )))
and
L377: ( C65 . ( 0 ) ) = R7
and
L378: (for B57 being Nat holds ( C65 . ( B57 + 1 ) ) = H1(B57 , ( C65 . B57 )));
reconsider D112 = R7 as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
L379: ( C64 . ( 0 ) ) = D112 by L375;
L380: (for B58 being Nat holds ( C64 . ( B58 + 1 ) ) = H2(B58 , ( C64 . B58 ))) by L376;
L381: ( C65 . ( 0 ) ) = D112 by L377;
L382: (for B59 being Nat holds ( C65 . ( B59 + 1 ) ) = H2(B59 , ( C65 . B59 ))) by L378;
thus L383: C64 = C65 from NAT_1:sch 16(L379 , L380 , L381 , L382);
end;
end;
theorem
L385: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R7 being (State of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds (for R9 being  read-write Int-Location holds (for R11 being (Element of ( NAT )) holds ( ( StepWhile=0 (R9 , R8 , R1 , R7) ) . ( R11 + 1 ) ) = ( ( StepWhile=0 (R9 , R8 , R1 , ( ( StepWhile=0 (R9 , R8 , R1 , R7) ) . R11 )) ) . 1 ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R7 being (State of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
let R9 being  read-write Int-Location;
let R11 being (Element of ( NAT ));
set D113 = ( ( StepWhile=0 (R9 , R8 , R1 , R7) ) . R11 );
set D114 = ( ( StepWhile=0 (R9 , R8 , R1 , D113) ) . ( 0 ) );
L386: D114 = D113 by L369;
thus L387: ( ( StepWhile=0 (R9 , R8 , R1 , R7) ) . ( R11 + 1 ) ) = ( Comput (( R1 +* ( while=0 (R9 , R8) ) ) , ( D114 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) , ( ( LifeSpan (( ( R1 +* ( while=0 (R9 , R8) ) ) +* R8 ) , ( D114 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) )) ) + 3 )) ) by L386 , L369
.= ( ( StepWhile=0 (R9 , R8 , R1 , D113) ) . ( ( 0 ) + 1 ) ) by L369
.= ( ( StepWhile=0 (R9 , R8 , R1 , D113) ) . 1 );
end;
canceled 1;
theorem
L388: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B60 being (Program of ( SCM+FSA )) holds (for B61 being  read-write Int-Location holds (for B62 being (State of ( SCM+FSA )) holds ( ( StepWhile=0 (B61 , B60 , R1 , B62) ) . ( ( 0 ) + 1 ) ) = ( Comput (( R1 +* ( while=0 (B61 , B60) ) ) , ( Initialize B62 ) , ( ( LifeSpan (( ( R1 +* ( while=0 (B61 , B60) ) ) +* B60 ) , ( Initialize B62 )) ) + 3 )) )))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C66 being (Program of ( SCM+FSA ));
let C67 being  read-write Int-Location;
let C68 being (State of ( SCM+FSA ));
L389: ( ( StepWhile=0 (C67 , C66 , R1 , C68) ) . ( 0 ) ) = C68 by L369;
thus L390: ( ( StepWhile=0 (C67 , C66 , R1 , C68) ) . ( ( 0 ) + 1 ) ) = ( Comput (( R1 +* ( while=0 (C67 , C66) ) ) , ( Initialize C68 ) , ( ( LifeSpan (( ( R1 +* ( while=0 (C67 , C66) ) ) +* C66 ) , ( Initialize C68 )) ) + 3 )) ) by L389 , L369;
end;
theorem
L391: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B63 being (Program of ( SCM+FSA )) holds (for B64 being  read-write Int-Location holds (for B65 being (State of ( SCM+FSA )) holds (for B66 , B67 being (Element of ( NAT )) holds ((( IC ( ( StepWhile=0 (B64 , B63 , R1 , B65) ) . B66 ) ) = ( 0 ) & ( ( StepWhile=0 (B64 , B63 , R1 , B65) ) . B66 ) = ( Comput (( R1 +* ( while=0 (B64 , B63) ) ) , ( Initialize B65 ) , B67) )) implies (( ( StepWhile=0 (B64 , B63 , R1 , B65) ) . B66 ) = ( Initialize ( ( StepWhile=0 (B64 , B63 , R1 , B65) ) . B66 ) ) & ( ( StepWhile=0 (B64 , B63 , R1 , B65) ) . ( B66 + 1 ) ) = ( Comput (( R1 +* ( while=0 (B64 , B63) ) ) , ( Initialize B65 ) , ( B67 + ( ( LifeSpan (( ( R1 +* ( while=0 (B64 , B63) ) ) +* B63 ) , ( Initialize ( ( StepWhile=0 (B64 , B63 , R1 , B65) ) . B66 ) )) ) + 3 ) )) ))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
set D115 = ( ( Int-Locations ) \/ ( FinSeq-Locations ) );
let C69 being (Program of ( SCM+FSA ));
let C70 being  read-write Int-Location;
let C71 being (State of ( SCM+FSA ));
let C72 , C73 being (Element of ( NAT ));
set D116 = ( Initialize C71 );
set D117 = ( R1 +* ( while=0 (C70 , C69) ) );
set D118 = ( ( StepWhile=0 (C70 , C69 , R1 , C71) ) . C72 );
set D119 = ( Initialize D118 );
assume L392: ( IC D118 ) = ( 0 );
assume L393: D118 = ( Comput (D117 , D116 , C73) );
L394: D118 is ( 0 ) -started by L392 , MEMSTR_0:def 12;
L395: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= D118 by L394 , MEMSTR_0:29;
thus L396: D119 = D118 by L395 , FUNCT_4:98;
thus L397: ( ( StepWhile=0 (C70 , C69 , R1 , C71) ) . ( C72 + 1 ) ) = ( Comput (D117 , D118 , ( ( LifeSpan (( ( R1 +* ( while=0 (C70 , C69) ) ) +* C69 ) , ( Initialize D118 )) ) + 3 )) ) by L396 , L369
.= ( Comput (D117 , D116 , ( C73 + ( ( LifeSpan (( ( R1 +* ( while=0 (C70 , C69) ) ) +* C69 ) , ( Initialize D118 )) ) + 3 ) )) ) by L393 , EXTPRO_1:4;
end;
theorem
L398: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B68 being (Program of ( SCM+FSA )) holds (for B69 being  read-write Int-Location holds (for B70 being (State of ( SCM+FSA )) holds (((for B71 being Nat holds (B68 is_closed_on ( ( StepWhile=0 (B69 , B68 , R1 , B70) ) . B71 ) , ( R1 +* ( while=0 (B69 , B68) ) ) & B68 is_halting_on ( ( StepWhile=0 (B69 , B68 , R1 , B70) ) . B71 ) , ( R1 +* ( while=0 (B69 , B68) ) ))) & (ex B72 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) st (for B73 being Nat holds ((( B72 . ( ( StepWhile=0 (B69 , B68 , R1 , B70) ) . ( B73 + 1 ) ) ) < ( B72 . ( ( StepWhile=0 (B69 , B68 , R1 , B70) ) . B73 ) ) or ( B72 . ( ( StepWhile=0 (B69 , B68 , R1 , B70) ) . B73 ) ) = ( 0 )) & (( B72 . ( ( StepWhile=0 (B69 , B68 , R1 , B70) ) . B73 ) ) = ( 0 ) iff ( ( ( StepWhile=0 (B69 , B68 , R1 , B70) ) . B73 ) . B69 ) <> ( 0 )))))) implies (( while=0 (B69 , B68) ) is_halting_on B70 , R1 & ( while=0 (B69 , B68) ) is_closed_on B70 , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C74 being (Program of ( SCM+FSA ));
let C75 being  read-write Int-Location;
let C76 being (State of ( SCM+FSA ));
assume L399: (for B74 being Nat holds (C74 is_closed_on ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . B74 ) , ( R1 +* ( while=0 (C75 , C74) ) ) & C74 is_halting_on ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . B74 ) , ( R1 +* ( while=0 (C75 , C74) ) )));
set D120 = ( Initialize C76 );
set D121 = ( R1 +* ( while=0 (C75 , C74) ) );
L400: ( D121 +* ( while=0 (C75 , C74) ) ) = D121;
given C77 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that
L401: (for B75 being Nat holds ((( C77 . ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . ( B75 + 1 ) ) ) < ( C77 . ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . B75 ) ) or ( C77 . ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . B75 ) ) = ( 0 )) & (( C77 . ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . B75 ) ) = ( 0 ) iff ( ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . B75 ) . C75 ) <> ( 0 ))));

deffunc H3(Nat) = ( C77 . ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . $1 ) );
L402: (for B76 being Nat holds (H3(( B76 + 1 )) < H3(B76) or H3(B76) = ( 0 ))) by L401;
consider C78 being Nat such that L403: H3(C78) = ( 0 ) and L404: (for B77 being Nat holds (H3(B77) = ( 0 ) implies C78 <= B77)) from NAT_1:sch 17(L402);
defpred S2[ Nat ] means (( $1 + 1 ) <= C78 implies (ex R11 being (Element of ( NAT )) st ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . ( $1 + 1 ) ) = ( Comput (D121 , D120 , R11) )));
L405:
now
let C79 being (Element of ( NAT ));
assume L406: S2[ C79 ];
L407:
now
set D122 = ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . ( C79 + 1 ) );
set D123 = ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . C79 );
assume L408: ( ( C79 + 1 ) + 1 ) <= C78;
L409: ( C79 + ( 0 ) ) < ( C79 + ( 1 + 1 ) ) by XREAL_1:6;
L410: C79 < C78 by L409 , L408 , XXREAL_0:2;
L411: H3(C79) <> ( 0 ) by L410 , L404;
L412: ( D123 . C75 ) = ( 0 ) by L411 , L401;
L413: C74 is_halting_on D123 , ( R1 +* ( while=0 (C75 , C74) ) ) by L399;
L414: ( ( C79 + 1 ) + ( 0 ) ) < ( ( C79 + 1 ) + 1 ) by XREAL_1:6;
consider C80 being (Element of ( NAT )) such that L415: D122 = ( Comput (D121 , D120 , C80) ) by L414 , L406 , L408 , XXREAL_0:2;
take D124 = ( C80 + ( ( LifeSpan (( ( R1 +* ( while=0 (C75 , C74) ) ) +* C74 ) , ( Initialize D122 )) ) + 3 ) );
L416: ( ( R1 +* ( while=0 (C75 , C74) ) ) +* ( while=0 (C75 , C74) ) ) = ( R1 +* ( while=0 (C75 , C74) ) );
L417: (D122 = ( Comput (( R1 +* ( while=0 (C75 , C74) ) ) , ( Initialize D123 ) , ( ( LifeSpan (( ( R1 +* ( while=0 (C75 , C74) ) ) +* C74 ) , ( Initialize D123 )) ) + 3 )) ) & C74 is_closed_on D123 , ( R1 +* ( while=0 (C75 , C74) ) )) by L399 , L369;
L418: ( IC D122 ) = ( 0 ) by L417 , L413 , L412 , L299 , L416;
thus L419: ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . ( ( C79 + 1 ) + 1 ) ) = ( Comput (D121 , D120 , D124) ) by L418 , L415 , L391;
end;
thus L420: S2[ ( C79 + 1 ) ] by L407;
end;
L421: S2[ ( 0 ) ]
proof
assume L422: ( ( 0 ) + 1 ) <= C78;
take D125 = ( ( LifeSpan (( ( R1 +* ( while=0 (C75 , C74) ) ) +* C74 ) , ( Initialize C76 )) ) + 3 );
thus L423: thesis by L388;
end;
L424: (for B78 being (Element of ( NAT )) holds S2[ B78 ]) from NAT_1:sch 1(L421 , L405);
L425:
now
per cases ;
suppose L426: C78 = ( 0 );

L427: ( ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . ( 0 ) ) . C75 ) <> ( 0 ) by L426 , L401 , L403;
L428: ( C76 . C75 ) <> ( 0 ) by L427 , L369;
thus L429: thesis by L428 , L165;
end;
suppose L430: C78 <> ( 0 );

consider C81 being Nat such that L431: C78 = ( C81 + 1 ) by L430 , NAT_1:6;
reconsider D126 = C78 , D127 = C81 as (Element of ( NAT )) by ORDINAL1:def 12;
set D128 = ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . D126 );
set D129 = ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . D127 );
L432: D127 < D126 by L431 , NAT_1:13;
L433: H3(D127) <> ( 0 ) by L432 , L404;
L434: ( D129 . C75 ) = ( 0 ) by L433 , L401;
L435: (C74 is_closed_on D129 , ( R1 +* ( while=0 (C75 , C74) ) ) & C74 is_halting_on D129 , ( R1 +* ( while=0 (C75 , C74) ) )) by L399;
L436: ( IC ( SCM+FSA ) ) in ( dom D128 ) by MEMSTR_0:2;
L437: D128 = ( Comput (( R1 +* ( while=0 (C75 , C74) ) ) , ( Initialize D129 ) , ( ( LifeSpan (( ( R1 +* ( while=0 (C75 , C74) ) ) +* C74 ) , ( Initialize D129 )) ) + 3 )) ) by L431 , L369;
L438: ( IC D128 ) = ( 0 ) by L437 , L435 , L434 , L299 , L400;
L439: D128 is ( 0 ) -started by L438 , L436 , MEMSTR_0:def 11;
L440: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= D128 by L439 , MEMSTR_0:29;
set D130 = ( ( LifeSpan (( ( R1 +* ( while=0 (C75 , C74) ) ) +* C74 ) , ( Initialize C76 )) ) + 3 );
set D131 = ( Initialize D128 );
L441: D126 = ( D127 + 1 ) by L431;
consider C82 being (Element of ( NAT )) such that L442: D128 = ( Comput (D121 , D120 , C82) ) by L441 , L424;
reconsider D132 = C82 as (Element of ( NAT ));
L443: D131 = D128 by L440 , FUNCT_4:98;
L444: ( D128 . C75 ) <> ( 0 ) by L401 , L403;
L445: ( while=0 (C75 , C74) ) is_halting_on D128 , R1 by L444 , L165;
L446: ( R1 +* ( while=0 (C75 , C74) ) ) halts_on ( Initialize D128 ) by L445 , SCMFSA7B:def 7;
L447: ( R1 +* ( while=0 (C75 , C74) ) ) halts_on ( Initialize D128 ) by L446;
L448: D121 halts_on D131 by L447;
consider C83 being (Element of ( NAT )) such that L449: ( CurInstr (D121 , ( Comput (D121 , D128 , C83) )) ) = ( halt ( SCM+FSA ) ) by L448 , L443 , EXTPRO_1:29;
L450: ( Comput (D121 , D120 , ( D132 + C83 )) ) = ( Comput (D121 , ( Comput (D121 , D120 , D132) ) , C83) ) by EXTPRO_1:4;
L451: ( CurInstr (D121 , ( Comput (D121 , D120 , ( D132 + C83 )) )) ) = ( halt ( SCM+FSA ) ) by L442 , L449 , L450;
L452: D121 halts_on D120 by L451 , EXTPRO_1:29;
thus L453: ( while=0 (C75 , C74) ) is_halting_on C76 , R1 by L452 , SCMFSA7B:def 7;
L454:
now
let C84 being (Element of ( NAT ));
L455: ( 0 ) < D126 by L430;
per cases ;
suppose L456: C84 <= D130;

L457: ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . ( 0 ) ) = C76 by L369;
L458: (C74 is_closed_on C76 , ( R1 +* ( while=0 (C75 , C74) ) ) & C74 is_halting_on C76 , ( R1 +* ( while=0 (C75 , C74) ) )) by L457 , L399;
L459: H3(( 0 )) <> ( 0 ) by L404 , L455;
L460: ( C76 . C75 ) = ( 0 ) by L459 , L401 , L457;
thus L461: ( IC ( Comput (D121 , D120 , C84) ) ) in ( dom ( while=0 (C75 , C74) ) ) by L460 , L456 , L458 , L299 , L400;
end;
suppose L462: C84 > D130;

L463:
now
take D133 = D130;
thus L464: (( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . 1 ) = ( Comput (D121 , D120 , D133) ) & D133 <= C84) by L462 , L388;
end;
defpred S3[ Nat ] means ($1 <= D126 & $1 <> ( 0 ) & (ex R11 being (Element of ( NAT )) st (( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . $1 ) = ( Comput (D121 , D120 , R11) ) & R11 <= C84)));
L465: (for B79 being Nat holds (S3[ B79 ] implies B79 <= D126));
L466: ( ( 0 ) + 1 ) < ( D126 + 1 ) by L455 , XREAL_1:6;
L467: 1 <= D126 by L466 , NAT_1:13;
L468: (ex B80 being Nat st S3[ B80 ]) by L467 , L463;
consider C85 being Nat such that L469: (S3[ C85 ] & (for B81 being Nat holds (S3[ B81 ] implies B81 <= C85))) from NAT_1:sch 6(L465 , L468);
reconsider D134 = C85 as (Element of ( NAT )) by ORDINAL1:def 12;
L470:
now
per cases ;
suppose L471: D134 = D126;

consider C86 being (Element of ( NAT )) such that L472: D128 = ( Comput (D121 , D120 , C86) ) and L473: C86 <= C84 by L471 , L469;
consider C87 being Nat such that L474: C84 = ( C86 + C87 ) by L473 , NAT_1:10;
L475: ( while=0 (C75 , C74) ) is_closed_on D128 , R1 by L444 , L165;
reconsider D135 = C87 as (Element of ( NAT )) by ORDINAL1:def 12;
L476: ( Comput (D121 , D120 , C84) ) = ( Comput (D121 , D131 , D135) ) by L443 , L472 , L474 , EXTPRO_1:4;
thus L477: ( IC ( Comput (D121 , D120 , C84) ) ) in ( dom ( while=0 (C75 , C74) ) ) by L476 , L475 , SCMFSA7B:def 6;
end;
suppose L478: D134 <> D126;

set D136 = ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . D134 );
L479: D134 < D126 by L469 , L478 , XXREAL_0:1;
L480: H3(D134) <> ( 0 ) by L479 , L404;
L481: ( D136 . C75 ) = ( 0 ) by L480 , L401;
consider C88 being (Element of ( NAT )) such that L482: ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . D134 ) = ( Comput (D121 , D120 , C88) ) and L483: C88 <= C84 by L469;
set D137 = ( C88 + ( ( LifeSpan (( ( R1 +* ( while=0 (C75 , C74) ) ) +* C74 ) , ( Initialize D136 )) ) + 3 ) );
consider C89 being Nat such that L484: C84 = ( C88 + C89 ) by L483 , NAT_1:10;
L485: (C74 is_closed_on D136 , ( R1 +* ( while=0 (C75 , C74) ) ) & C74 is_halting_on D136 , ( R1 +* ( while=0 (C75 , C74) ) )) by L399;
consider C90 being Nat such that L486: D134 = ( C90 + 1 ) by L469 , NAT_1:6;
reconsider D138 = C90 as (Element of ( NAT )) by ORDINAL1:def 12;
set D139 = ( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . D138 );
L487: ( D138 + ( 0 ) ) < D134 by L486 , XREAL_1:6;
L488: D138 < D126 by L487 , L469 , XXREAL_0:2;
L489: H3(D138) <> ( 0 ) by L488 , L404;
L490: ( D139 . C75 ) = ( 0 ) by L489 , L401;
L491: (C74 is_closed_on D139 , ( R1 +* ( while=0 (C75 , C74) ) ) & C74 is_halting_on D139 , ( R1 +* ( while=0 (C75 , C74) ) )) by L399;
reconsider D140 = C89 as (Element of ( NAT )) by ORDINAL1:def 12;
L492: D136 = ( Comput (( R1 +* ( while=0 (C75 , C74) ) ) , ( Initialize D139 ) , ( ( LifeSpan (( ( R1 +* ( while=0 (C75 , C74) ) ) +* C74 ) , ( Initialize D139 )) ) + 3 )) ) by L486 , L369;
L493: ( IC D136 ) = ( 0 ) by L492 , L491 , L490 , L299 , L400;
L494:
now
assume L495: D137 <= C84;
L496:
now
take D141 = D137;
thus L497: (( ( StepWhile=0 (C75 , C74 , R1 , C76) ) . ( D134 + 1 ) ) = ( Comput (D121 , D120 , D141) ) & D141 <= C84) by L482 , L493 , L495 , L391;
end;
L498: ( D134 + 1 ) <= D126 by L479 , NAT_1:13;
thus L499: contradiction by L498 , L469 , L496 , XREAL_1:29;
end;
L500: D140 < ( ( LifeSpan (( ( R1 +* ( while=0 (C75 , C74) ) ) +* C74 ) , ( Initialize D136 )) ) + 3 ) by L494 , L484 , XREAL_1:6;
L501: D136 = ( Initialize D136 ) by L482 , L493 , L391;
L502: ( Comput (D121 , D120 , C84) ) = ( Comput (( R1 +* ( while=0 (C75 , C74) ) ) , ( D136 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) , D140) ) by L501 , L482 , L484 , EXTPRO_1:4;
thus L503: ( IC ( Comput (D121 , D120 , C84) ) ) in ( dom ( while=0 (C75 , C74) ) ) by L502 , L500 , L485 , L481 , L299 , L400;
end;
end;
thus L505: ( IC ( Comput (D121 , D120 , C84) ) ) in ( dom ( while=0 (C75 , C74) ) ) by L470;
end;
end;
thus L507: ( while=0 (C75 , C74) ) is_closed_on C76 , R1 by L454 , SCMFSA7B:def 6;
end;
end;
thus L509: thesis by L425;
end;
theorem
L510: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B82 being  parahalting (Program of ( SCM+FSA )) holds (for B83 being  read-write Int-Location holds (for B84 being (State of ( SCM+FSA )) holds ((ex B85 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) st (for B86 being Nat holds ((( B85 . ( ( StepWhile=0 (B83 , B82 , R1 , B84) ) . ( B86 + 1 ) ) ) < ( B85 . ( ( StepWhile=0 (B83 , B82 , R1 , B84) ) . B86 ) ) or ( B85 . ( ( StepWhile=0 (B83 , B82 , R1 , B84) ) . B86 ) ) = ( 0 )) & (( B85 . ( ( StepWhile=0 (B83 , B82 , R1 , B84) ) . B86 ) ) = ( 0 ) iff ( ( ( StepWhile=0 (B83 , B82 , R1 , B84) ) . B86 ) . B83 ) <> ( 0 ))))) implies (( while=0 (B83 , B82) ) is_halting_on B84 , R1 & ( while=0 (B83 , B82) ) is_closed_on B84 , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C91 being  parahalting (Program of ( SCM+FSA ));
let C92 being  read-write Int-Location;
let C93 being (State of ( SCM+FSA ));
L511: (for B87 being Nat holds (C91 is_closed_on ( ( StepWhile=0 (C92 , C91 , R1 , C93) ) . B87 ) , ( R1 +* ( while=0 (C92 , C91) ) ) & C91 is_halting_on ( ( StepWhile=0 (C92 , C91 , R1 , C93) ) . B87 ) , ( R1 +* ( while=0 (C92 , C91) ) ))) by SCMFSA7B:18 , SCMFSA7B:19;
assume L512: (ex B88 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) st (for B89 being Nat holds ((( B88 . ( ( StepWhile=0 (C92 , C91 , R1 , C93) ) . ( B89 + 1 ) ) ) < ( B88 . ( ( StepWhile=0 (C92 , C91 , R1 , C93) ) . B89 ) ) or ( B88 . ( ( StepWhile=0 (C92 , C91 , R1 , C93) ) . B89 ) ) = ( 0 )) & (( B88 . ( ( StepWhile=0 (C92 , C91 , R1 , C93) ) . B89 ) ) = ( 0 ) iff ( ( ( StepWhile=0 (C92 , C91 , R1 , C93) ) . B89 ) . C92 ) <> ( 0 )))));
thus L513: thesis by L512 , L511 , L398;
end;
theorem
L514: (for B90 being  parahalting (Program of ( SCM+FSA )) holds (for B91 being  read-write Int-Location holds ((ex B92 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) st (for B93 being (State of ( SCM+FSA )) holds (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds ((( B92 . ( ( StepWhile=0 (B91 , B90 , R1 , B93) ) . 1 ) ) < ( B92 . B93 ) or ( B92 . B93 ) = ( 0 )) & (( B92 . B93 ) = ( 0 ) iff ( B93 . B91 ) <> ( 0 )))))) implies ( while=0 (B91 , B90) ) is  parahalting)))
proof
let C94 being  parahalting (Program of ( SCM+FSA ));
let C95 being  read-write Int-Location;
given C96 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that
L515: (for B94 being (State of ( SCM+FSA )) holds (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds ((( C96 . ( ( StepWhile=0 (C95 , C94 , R1 , B94) ) . 1 ) ) < ( C96 . B94 ) or ( C96 . B94 ) = ( 0 )) & (( C96 . B94 ) = ( 0 ) iff ( B94 . C95 ) <> ( 0 )))));

L516:
now
let C97 being (State of ( SCM+FSA ));
let R2 being (Instruction-Sequence of ( SCM+FSA ));
L517:
now
let C98 being Nat;
L518: C98 in ( NAT ) by ORDINAL1:def 12;
L519: (( C96 . ( ( StepWhile=0 (C95 , C94 , R2 , ( ( StepWhile=0 (C95 , C94 , R2 , C97) ) . C98 )) ) . 1 ) ) < ( C96 . ( ( StepWhile=0 (C95 , C94 , R2 , C97) ) . C98 ) ) or ( C96 . ( ( StepWhile=0 (C95 , C94 , R2 , C97) ) . C98 ) ) = ( 0 )) by L515;
thus L520: ((( C96 . ( ( StepWhile=0 (C95 , C94 , R2 , C97) ) . ( C98 + 1 ) ) ) < ( C96 . ( ( StepWhile=0 (C95 , C94 , R2 , C97) ) . C98 ) ) or ( C96 . ( ( StepWhile=0 (C95 , C94 , R2 , C97) ) . C98 ) ) = ( 0 )) & (( C96 . ( ( StepWhile=0 (C95 , C94 , R2 , C97) ) . C98 ) ) = ( 0 ) iff ( ( ( StepWhile=0 (C95 , C94 , R2 , C97) ) . C98 ) . C95 ) <> ( 0 ))) by L519 , L515 , L518 , L385;
end;
thus L521: ( while=0 (C95 , C94) ) is_halting_on C97 , R2 by L517 , L510;
end;
thus L522: thesis by L516 , SCMFSA7B:19;
end;
theorem
L523: (for B95 , B96 being (Element of ( NAT )) holds (for B97 being Int-Location holds (not ( B95 .--> ( goto B96 ) ) destroy B97)))
proof
let C99 , C100 being (Element of ( NAT ));
let C101 being Int-Location;
set D142 = ( C99 .--> ( goto C100 ) );
L524: ( rng D142 ) = { ( goto C100 ) } by FUNCOP_1:8;
L525:
now
let C102 being (Instruction of ( SCM+FSA ));
assume L526: C102 in ( rng D142 );
L527: C102 = ( goto C100 ) by L526 , L524 , TARSKI:def 1;
thus L528: (not C102 destroy C101) by L527 , SCMFSA7B:11;
end;
thus L529: thesis by L525 , SCMFSA7B:def 4;
end;
theorem
L530: (for B98 being (Instruction of ( SCM+FSA )) holds ((not B98 destroy ( intloc ( 0 ) )) implies ( Macro B98 ) is  good))
proof
let C103 being (Instruction of ( SCM+FSA ));
set D143 = ( Macro C103 );
L531: ( rng D143 ) = { C103 , ( halt ( SCM+FSA ) ) } by COMPOS_1:67;
assume L532: (not C103 destroy ( intloc ( 0 ) ));
L533:
now
let C104 being (Instruction of ( SCM+FSA ));
assume L534: C104 in ( rng D143 );
per cases  by L531 , L534 , TARSKI:def 2;
suppose L535: C104 = C103;

thus L536: (not C104 destroy ( intloc ( 0 ) )) by L535 , L532;
end;
suppose L537: C104 = ( halt ( SCM+FSA ) );

thus L538: (not C104 destroy ( intloc ( 0 ) )) by L537 , SCMFSA7B:5;
end;
end;
L540: (not D143 destroy ( intloc ( 0 ) )) by L533 , SCMFSA7B:def 4;
thus L541: thesis by L540 , SCMFSA7B:def 5;
end;
registration
let C105 , C106 being  good (Program of ( SCM+FSA ));
let C107 being Int-Location;
cluster ( if=0 (C107 , C105 , C106) ) ->  good;
correctness
proof
set D144 = ( C107 =0_goto ( ( card C106 ) + 3 ) );
reconsider D145 = ( Macro D144 ) as  good (Program of ( SCM+FSA )) by L530 , SCMFSA7B:12;
L542: ( if=0 (C107 , C105 , C106) ) = ( ( ( ( D144 ";" C106 ) ";" ( Goto ( ( card C105 ) + 1 ) ) ) ";" C105 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1
.= ( ( ( ( D145 ";" C106 ) ";" ( Goto ( ( card C105 ) + 1 ) ) ) ";" C105 ) ";" ( Stop ( SCM+FSA ) ) );
thus L543: thesis by L542;
end;
end;
registration
let C108 being  good (Program of ( SCM+FSA ));
let C109 being Int-Location;
cluster ( while=0 (C109 , C108) ) ->  good;
correctness
proof
set D146 = ( if=0 (C109 , ( C108 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) );
set D147 = ( ( ( card C108 ) + 4 ) .--> ( goto ( 0 ) ) );
L545: ((not D147 destroy ( intloc ( 0 ) )) & (not D146 destroy ( intloc ( 0 ) ))) by L523 , SCMFSA7B:def 5;
L546: (not ( while=0 (C109 , C108) ) destroy ( intloc ( 0 ) )) by L545 , SCMFSA8A:11;
thus L547: thesis by L546 , SCMFSA7B:def 5;
end;
end;
theorem
L549: (for B99 being Int-Location holds (for B100 being (Program of ( SCM+FSA )) holds (for B101 being (Element of ( NAT )) holds (B101 < 6 implies B101 in ( dom ( while>0 (B99 , B100) ) )))))
proof
let C110 being Int-Location;
let C111 being (Program of ( SCM+FSA ));
let C112 being (Element of ( NAT ));
L550: 6 <= ( ( card C111 ) + 6 ) by NAT_1:11;
L551: ( card ( while>0 (C110 , C111) ) ) = ( ( card C111 ) + 6 ) by L40;
assume L552: C112 < 6;
L553: C112 < ( ( card C111 ) + 6 ) by L552 , L550 , XXREAL_0:2;
thus L554: thesis by L553 , L551 , AFINSQ_1:66;
end;
theorem
L555: (for B102 being Int-Location holds (for B103 being (Program of ( SCM+FSA )) holds (for B104 being (Element of ( NAT )) holds (B104 < 6 implies ( ( card B103 ) + B104 ) in ( dom ( while>0 (B102 , B103) ) )))))
proof
let C113 being Int-Location;
let C114 being (Program of ( SCM+FSA ));
let C115 being (Element of ( NAT ));
assume L556: C115 < 6;
L557: ( ( card C114 ) + C115 ) < ( ( card C114 ) + 6 ) by L556 , XREAL_1:6;
L558: ( card ( while>0 (C113 , C114) ) ) = ( ( card C114 ) + 6 ) by L40;
thus L559: thesis by L558 , L557 , AFINSQ_1:66;
end;
theorem
L560: (for B105 being Int-Location holds (for B106 being (Program of ( SCM+FSA )) holds ( ( while>0 (B105 , B106) ) . ( ( card B106 ) + 5 ) ) = ( halt ( SCM+FSA ) )))
proof
set D148 = ( Stop ( SCM+FSA ) );
set D149 = ( Stop ( SCM+FSA ) );
let C116 being Int-Location;
let C117 being (Program of ( SCM+FSA ));
set D150 = ( C117 ";" ( Goto ( 0 ) ) );
set D151 = ( ( ( card C117 ) + 4 ) .--> ( goto ( 0 ) ) );
set D152 = ( C116 >0_goto ( ( card D149 ) + 3 ) );
set D153 = ( ( card C117 ) + 5 );
set D154 = D153;
set D155 = ( ( ( ( Macro D152 ) ";" D149 ) ";" ( Goto ( ( card D150 ) + 1 ) ) ) ";" D150 );
L561: (( dom D151 ) = { ( ( card C117 ) + 4 ) } & D154 <> ( ( card C117 ) + 4 )) by FUNCOP_1:13;
L562: (not D154 in ( dom D151 )) by L561 , TARSKI:def 1;
L563: ( ( 0 ) + D153 ) in { ( B107 + D153 ) where B107 is (Element of ( NAT )) : B107 in ( dom D148 ) } by L3;
L564: D153 in ( dom ( Shift (D148 , D153) ) ) by L563 , VALUED_1:def 12;
L565: ( ( Shift (D148 , D153) ) /. D154 ) = ( ( Shift (D148 , D153) ) . ( ( 0 ) + D153 ) ) by L564 , PARTFUN1:def 6
.= ( halt ( SCM+FSA ) ) by L2 , L3 , VALUED_1:def 12;
L566: (D154 in ( dom ( while>0 (C116 , C117) ) ) & ( dom ( while>0 (C116 , C117) ) ) = ( ( dom ( if>0 (C116 , D150 , D149) ) ) \/ ( dom D151 ) )) by L555 , FUNCT_4:def 1;
L567: D154 in ( dom ( if>0 (C116 , D150 , D149) ) ) by L566 , L562 , XBOOLE_0:def 3;
L568: ( if>0 (C116 , D150 , D149) ) = ( ( ( ( D152 ";" D149 ) ";" ( Goto ( ( card D150 ) + 1 ) ) ) ";" D150 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2
.= ( D155 ";" D148 );
L569: ( card ( if>0 (C116 , D150 , D149) ) ) = ( ( card D155 ) + ( card D148 ) ) by L568 , SCMFSA6A:21;
L570: ( card D155 ) = ( ( card ( if>0 (C116 , D150 , D149) ) ) - ( card D148 ) ) by L569
.= ( ( ( card C117 ) + 6 ) - 1 ) by L6 , L1
.= D153;
L571: (not D154 in ( dom D155 )) by L570;
L572: ( dom ( if>0 (C116 , D150 , D149) ) ) = ( ( dom ( Directed D155 ) ) \/ ( dom ( Reloc (D148 , D153) ) ) ) by L568 , L570 , FUNCT_4:def 1;
L573: ( dom ( if>0 (C116 , D150 , D149) ) ) = ( ( dom D155 ) \/ ( dom ( Reloc (D148 , D153) ) ) ) by L572 , FUNCT_4:99;
L574: D154 in ( dom ( Reloc (D148 , D153) ) ) by L573 , L567 , L571 , XBOOLE_0:def 3;
L575: ( Reloc (D148 , D153) ) = ( IncAddr (( Shift (D148 , D153) ) , D153) ) by COMPOS_1:34;
thus L576: ( ( while>0 (C116 , C117) ) . D154 ) = ( ( ( Directed D155 ) +* ( Reloc (D148 , D153) ) ) . D154 ) by L562 , L566 , L568 , L570 , FUNCT_4:def 1
.= ( ( Reloc (D148 , D153) ) . D154 ) by L567 , L572 , L574 , FUNCT_4:def 1
.= ( IncAddr (( halt ( SCM+FSA ) ) , D153) ) by L564 , L565 , L575 , COMPOS_1:def 21
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
end;
theorem
L577: (for B108 being Int-Location holds (for B109 being (Program of ( SCM+FSA )) holds ( ( while>0 (B108 , B109) ) . 3 ) = ( goto ( ( card B109 ) + 5 ) )))
proof
set D156 = ( Stop ( SCM+FSA ) );
let C118 being Int-Location;
let C119 being (Program of ( SCM+FSA ));
set D157 = ( C119 ";" ( Goto ( 0 ) ) );
set D158 = ( ( ( card C119 ) + 4 ) .--> ( goto ( 0 ) ) );
set D159 = ( C118 >0_goto ( ( card D156 ) + 3 ) );
set D160 = ( ( Macro D159 ) ";" D156 );
set D161 = ( Goto ( ( card D157 ) + 1 ) );
set D162 = ( D157 ";" ( Stop ( SCM+FSA ) ) );
set D163 = ( D161 ";" D162 );
L578: ( 0 ) in ( dom D161 ) by SCMFSA8A:31;
L579: ( D161 . ( 0 ) ) = ( goto ( ( card D157 ) + 1 ) ) by SCMFSA8A:31
.= ( goto ( ( ( card C119 ) + ( card ( Goto ( 0 ) ) ) ) + 1 ) ) by SCMFSA6A:21
.= ( goto ( ( ( card C119 ) + 1 ) + 1 ) ) by SCMFSA8A:15
.= ( goto ( ( card C119 ) + ( 1 + 1 ) ) );
L580: ( dom D163 ) = ( ( dom ( Directed D161 ) ) \/ ( dom ( Reloc (D162 , ( card D161 )) ) ) ) by FUNCT_4:def 1
.= ( ( dom D161 ) \/ ( dom ( Reloc (D162 , ( card D161 )) ) ) ) by FUNCT_4:99;
L581: ( 0 ) in ( dom D163 ) by L580 , L578 , XBOOLE_0:def 3;
L582: ( ( 0 ) + 3 ) in { ( B110 + 3 ) where B110 is (Element of ( NAT )) : B110 in ( dom D163 ) } by L581;
L583: 3 in ( dom ( Shift (D163 , 3) ) ) by L582 , VALUED_1:def 12;
L584: ( ( Shift (D163 , 3) ) /. 3 ) = ( ( Shift (D163 , 3) ) . ( ( 0 ) + 3 ) ) by L583 , PARTFUN1:def 6
.= ( D163 . ( 0 ) ) by L581 , VALUED_1:def 12
.= ( ( Directed D161 ) . ( 0 ) ) by L578 , SCMFSA8A:14
.= ( goto ( ( card C119 ) + 2 ) ) by L578 , L579 , SCMFSA8A:16;
L585: (( dom D158 ) = { ( ( card C119 ) + 4 ) } & 3 <> ( ( card C119 ) + 4 )) by FUNCOP_1:13 , NAT_1:11;
L586: (not 3 in ( dom D158 )) by L585 , TARSKI:def 1;
L587: ( card D160 ) = ( ( card ( Macro D159 ) ) + ( card D156 ) ) by SCMFSA6A:21
.= ( 2 + 1 ) by L1 , COMPOS_1:56;
L588: (not 3 in ( dom D160 )) by L587;
L589: (3 in ( dom ( while>0 (C118 , C119) ) ) & ( dom ( while>0 (C118 , C119) ) ) = ( ( dom ( if>0 (C118 , D157 , D156) ) ) \/ ( dom D158 ) )) by L549 , FUNCT_4:def 1;
L590: 3 in ( dom ( if>0 (C118 , D157 , D156) ) ) by L589 , L586 , XBOOLE_0:def 3;
L591: ( CutLastLoc ( stop D160 ) ) = D160;
L592: ( if>0 (C118 , D157 , D156) ) = ( ( ( ( D159 ";" D156 ) ";" ( Goto ( ( card D157 ) + 1 ) ) ) ";" D157 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2
.= ( ( ( D159 ";" D156 ) ";" ( Goto ( ( card D157 ) + 1 ) ) ) ";" ( D157 ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:25
.= ( D160 ";" D163 ) by SCMFSA6A:25
.= ( ( Directed D160 ) +* ( Reloc (D163 , 3) ) ) by L587 , L591;
L593: ( dom ( if>0 (C118 , D157 , D156) ) ) = ( ( dom ( Directed D160 ) ) \/ ( dom ( Reloc (D163 , 3) ) ) ) by L592 , FUNCT_4:def 1;
L594: ( dom ( if>0 (C118 , D157 , D156) ) ) = ( ( dom D160 ) \/ ( dom ( Reloc (D163 , 3) ) ) ) by L593 , FUNCT_4:99;
L595: 3 in ( dom ( Reloc (D163 , 3) ) ) by L594 , L590 , L588 , XBOOLE_0:def 3;
L596: ( Reloc (D163 , 3) ) = ( IncAddr (( Shift (D163 , 3) ) , 3) ) by COMPOS_1:34;
thus L597: ( ( while>0 (C118 , C119) ) . 3 ) = ( ( ( Directed D160 ) +* ( Reloc (D163 , 3) ) ) . 3 ) by L586 , L589 , L592 , FUNCT_4:def 1
.= ( ( Reloc (D163 , 3) ) . 3 ) by L590 , L593 , L595 , FUNCT_4:def 1
.= ( IncAddr (( goto ( ( card C119 ) + 2 ) ) , 3) ) by L583 , L584 , L596 , COMPOS_1:def 21
.= ( goto ( ( ( card C119 ) + 2 ) + 3 ) ) by SCMFSA_4:1
.= ( goto ( ( card C119 ) + 5 ) );
end;
theorem
L598: (for B111 being Int-Location holds (for B112 being (Program of ( SCM+FSA )) holds ( ( while>0 (B111 , B112) ) . 2 ) = ( goto 3 )))
proof
set D164 = ( Stop ( SCM+FSA ) );
let C120 being Int-Location;
let C121 being (Program of ( SCM+FSA ));
set D165 = ( C121 ";" ( Goto ( 0 ) ) );
set D166 = ( ( ( card C121 ) + 4 ) .--> ( goto ( 0 ) ) );
set D167 = ( C120 >0_goto ( ( card D164 ) + 3 ) );
set D168 = ( Macro D167 );
set D169 = ( ( Goto ( ( card D165 ) + 1 ) ) ";" ( D165 ";" ( Stop ( SCM+FSA ) ) ) );
set D170 = ( D164 ";" D169 );
L599: (( dom D166 ) = { ( ( card C121 ) + 4 ) } & 2 <> ( ( card C121 ) + 4 )) by FUNCOP_1:13 , NAT_1:11;
L600: (not 2 in ( dom D166 )) by L599 , TARSKI:def 1;
L601: ( dom D170 ) = ( ( dom ( Directed D164 ) ) \/ ( dom ( Reloc (D169 , ( card D164 )) ) ) ) by FUNCT_4:def 1
.= ( ( dom D164 ) \/ ( dom ( Reloc (D169 , ( card D164 )) ) ) ) by FUNCT_4:99;
L602: ( 0 ) in ( dom D170 ) by L601 , L3 , XBOOLE_0:def 3;
L603: ( ( 0 ) + 2 ) in { ( B113 + 2 ) where B113 is (Element of ( NAT )) : B113 in ( dom D170 ) } by L602;
L604: 2 in ( dom ( Shift (D170 , 2) ) ) by L603 , VALUED_1:def 12;
L605: ( ( Shift (D170 , 2) ) /. 2 ) = ( ( Shift (D170 , 2) ) . ( ( 0 ) + 2 ) ) by L604 , PARTFUN1:def 6
.= ( D170 . ( 0 ) ) by L602 , VALUED_1:def 12
.= ( ( Directed D164 ) . ( 0 ) ) by L3 , SCMFSA8A:14
.= ( goto ( card D164 ) ) by L2 , L3 , SCMFSA8A:16;
L606: ( card D168 ) = 2 by COMPOS_1:56;
L607: (not 2 in ( dom D168 )) by L606;
L608: (2 in ( dom ( while>0 (C120 , C121) ) ) & ( dom ( while>0 (C120 , C121) ) ) = ( ( dom ( if>0 (C120 , D165 , D164) ) ) \/ ( dom D166 ) )) by L549 , FUNCT_4:def 1;
L609: 2 in ( dom ( if>0 (C120 , D165 , D164) ) ) by L608 , L600 , XBOOLE_0:def 3;
L610: ( if>0 (C120 , D165 , D164) ) = ( ( ( ( D167 ";" D164 ) ";" ( Goto ( ( card D165 ) + 1 ) ) ) ";" D165 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2
.= ( ( ( D167 ";" D164 ) ";" ( Goto ( ( card D165 ) + 1 ) ) ) ";" ( D165 ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:25
.= ( ( D167 ";" D164 ) ";" ( ( Goto ( ( card D165 ) + 1 ) ) ";" ( D165 ";" ( Stop ( SCM+FSA ) ) ) ) ) by SCMFSA6A:25
.= ( D167 ";" D170 ) by SCMFSA6A:29
.= ( ( Directed D168 ) +* ( Reloc (D170 , 2) ) ) by COMPOS_1:56;
L611: ( dom ( if>0 (C120 , D165 , D164) ) ) = ( ( dom ( Directed D168 ) ) \/ ( dom ( Reloc (D170 , 2) ) ) ) by L610 , FUNCT_4:def 1;
L612: ( dom ( if>0 (C120 , D165 , D164) ) ) = ( ( dom D168 ) \/ ( dom ( Reloc (D170 , 2) ) ) ) by L611 , FUNCT_4:99;
L613: 2 in ( dom ( Reloc (D170 , 2) ) ) by L612 , L609 , L607 , XBOOLE_0:def 3;
L614: ( Reloc (D170 , 2) ) = ( IncAddr (( Shift (D170 , 2) ) , 2) ) by COMPOS_1:34;
thus L615: ( ( while>0 (C120 , C121) ) . 2 ) = ( ( ( Directed D168 ) +* ( Reloc (D170 , 2) ) ) . 2 ) by L600 , L608 , L610 , FUNCT_4:def 1
.= ( ( Reloc (D170 , 2) ) . 2 ) by L609 , L611 , L613 , FUNCT_4:def 1
.= ( IncAddr (( goto ( card D164 ) ) , 2) ) by L604 , L605 , L614 , COMPOS_1:def 21
.= ( goto ( 1 + 2 ) ) by L1 , SCMFSA_4:1
.= ( goto 3 );
end;
theorem
L616: (for B114 being Int-Location holds (for B115 being (Program of ( SCM+FSA )) holds (for B116 being (Element of ( NAT )) holds (B116 < ( ( card B115 ) + 6 ) implies B116 in ( dom ( while>0 (B114 , B115) ) )))))
proof
let C122 being Int-Location;
let C123 being (Program of ( SCM+FSA ));
let C124 being (Element of ( NAT ));
assume L617: C124 < ( ( card C123 ) + 6 );
L618: ( card ( while>0 (C122 , C123) ) ) = ( ( card C123 ) + 6 ) by L40;
thus L619: thesis by L618 , L617 , AFINSQ_1:66;
end;
theorem
L620: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B117 being (State of ( SCM+FSA )) holds (for B118 being (Program of ( SCM+FSA )) holds (for B119 being  read-write Int-Location holds (( B117 . B119 ) <= ( 0 ) implies (( while>0 (B119 , B118) ) is_halting_on B117 , R1 & ( while>0 (B119 , B118) ) is_closed_on B117 , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C125 being (State of ( SCM+FSA ));
let C126 being (Program of ( SCM+FSA ));
let C127 being  read-write Int-Location;
assume L621: ( C125 . C127 ) <= ( 0 );
set D171 = ( C127 >0_goto 4 );
set D172 = ( Initialize C125 );
set D173 = ( R1 +* ( while>0 (C127 , C126) ) );
L622: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L623: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L622;
L624: ( IC D172 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L623 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
set D174 = ( ( card C126 ) + 5 );
set D175 = ( Comput (D173 , D172 , 4) );
set D176 = ( Comput (D173 , D172 , 3) );
set D177 = ( Comput (D173 , D172 , 2) );
set D178 = ( Comput (D173 , D172 , 1) );
L625: 1 in ( dom ( while>0 (C127 , C126) ) ) by L54;
L626: 2 in ( dom ( while>0 (C127 , C126) ) ) by L549;
L627: (not C127 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L628: ( D172 . C127 ) = ( C125 . C127 ) by L627 , FUNCT_4:11;
L629: ( D173 /. ( IC D172 ) ) = ( D173 . ( IC D172 ) ) by PBOOLE:143;
L630: ( 0 ) in ( dom ( while>0 (C127 , C126) ) ) by L54;
L631: ( D173 . ( 0 ) ) = ( ( while>0 (C127 , C126) ) . ( 0 ) ) by L630 , FUNCT_4:13
.= D171 by L71;
L632: ( CurInstr (D173 , D172) ) = D171 by L631 , L624 , L629;
L633: ( Comput (D173 , D172 , ( ( 0 ) + 1 )) ) = ( Following (D173 , ( Comput (D173 , D172 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D173 , D172) )
.= ( Exec (D171 , D172) ) by L632;
L634: ( IC ( Comput (D173 , D172 , 1) ) ) = ( succ ( 0 ) ) by L621 , L624 , L633 , L628 , SCMFSA_2:71
.= ( ( 0 ) + 1 );
L635: ( D173 /. ( IC ( Comput (D173 , D172 , 1) ) ) ) = ( D173 . ( IC ( Comput (D173 , D172 , 1) ) ) ) by PBOOLE:143;
L636: ( D173 . 1 ) = ( ( while>0 (C127 , C126) ) . 1 ) by L625 , FUNCT_4:13
.= ( goto 2 ) by L71;
L637: ( CurInstr (D173 , ( Comput (D173 , D172 , 1) )) ) = ( goto 2 ) by L636 , L634 , L635;
L638: ( Comput (D173 , D172 , ( 1 + 1 )) ) = ( Following (D173 , D178) ) by EXTPRO_1:3
.= ( Exec (( goto 2 ) , D178) ) by L637;
L639: ( IC D177 ) = 2 by L638 , SCMFSA_2:69;
L640: ( D173 /. ( IC D177 ) ) = ( D173 . ( IC D177 ) ) by PBOOLE:143;
L641: ( D173 . 2 ) = ( ( while>0 (C127 , C126) ) . 2 ) by L626 , FUNCT_4:13
.= ( goto 3 ) by L598;
L642: ( CurInstr (D173 , D177) ) = ( goto 3 ) by L641 , L639 , L640;
L643: ( Comput (D173 , D172 , ( 2 + 1 )) ) = ( Following (D173 , D177) ) by EXTPRO_1:3
.= ( Exec (( goto 3 ) , D177) ) by L642;
L644: ( IC D176 ) = 3 by L643 , SCMFSA_2:69;
L645: 3 in ( dom ( while>0 (C127 , C126) ) ) by L549;
L646: D174 in ( dom ( while>0 (C127 , C126) ) ) by L555;
L647: ( D173 /. ( IC D176 ) ) = ( D173 . ( IC D176 ) ) by PBOOLE:143;
L648: ( D173 . 3 ) = ( ( while>0 (C127 , C126) ) . 3 ) by L645 , FUNCT_4:13
.= ( goto D174 ) by L577;
L649: ( CurInstr (D173 , D176) ) = ( goto D174 ) by L648 , L644 , L647;
L650: ( Comput (D173 , D172 , ( 3 + 1 )) ) = ( Following (D173 , D176) ) by EXTPRO_1:3
.= ( Exec (( goto D174 ) , D176) ) by L649;
L651: ( IC D175 ) = D174 by L650 , SCMFSA_2:69;
L652: ( D173 /. ( IC D175 ) ) = ( D173 . ( IC D175 ) ) by PBOOLE:143;
L653: ( D173 . D174 ) = ( ( while>0 (C127 , C126) ) . D174 ) by L646 , FUNCT_4:13
.= ( halt ( SCM+FSA ) ) by L560;
L654: ( CurInstr (D173 , D175) ) = ( halt ( SCM+FSA ) ) by L653 , L651 , L652;
L655: D173 halts_on D172 by L654 , EXTPRO_1:29;
thus L656: ( while>0 (C127 , C126) ) is_halting_on C125 , R1 by L655 , SCMFSA7B:def 7;
L657:
now
let C128 being (Element of ( NAT ));
L658: (C128 <= 3 or C128 >= ( 3 + 1 )) by NAT_1:13;
per cases  by L658 , NAT_1:27;
suppose L659: C128 = ( 0 );

thus L660: ( IC ( Comput (D173 , D172 , C128) ) ) in ( dom ( while>0 (C127 , C126) ) ) by L659 , L630 , L624 , EXTPRO_1:2;
end;
suppose L661: C128 = 1;

thus L662: ( IC ( Comput (D173 , D172 , C128) ) ) in ( dom ( while>0 (C127 , C126) ) ) by L661 , L634 , L54;
end;
suppose L663: C128 = 2;

thus L664: ( IC ( Comput (D173 , D172 , C128) ) ) in ( dom ( while>0 (C127 , C126) ) ) by L663 , L639 , L549;
end;
suppose L665: C128 = 3;

thus L666: ( IC ( Comput (D173 , D172 , C128) ) ) in ( dom ( while>0 (C127 , C126) ) ) by L665 , L644 , L549;
end;
suppose L667: C128 >= 4;

thus L668: ( IC ( Comput (D173 , D172 , C128) ) ) in ( dom ( while>0 (C127 , C126) ) ) by L667 , L646 , L651 , L654 , EXTPRO_1:5;
end;
end;
thus L670: thesis by L657 , SCMFSA7B:def 6;
end;
theorem
L671: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B120 being Int-Location holds (for B121 being (Program of ( SCM+FSA )) holds (for B122 being (State of ( SCM+FSA )) holds (for B123 being (Element of ( NAT )) holds ((B121 is_closed_on B122 , R1 & B121 is_halting_on B122 , R1 & B123 < ( LifeSpan (( R1 +* B121 ) , ( Initialize B122 )) ) & ( IC ( Comput (( R1 +* ( while>0 (B120 , B121) ) ) , ( Initialize B122 ) , ( 1 + B123 )) ) ) = ( ( IC ( Comput (( R1 +* B121 ) , ( Initialize B122 ) , B123) ) ) + 4 ) & ( DataPart ( Comput (( R1 +* ( while>0 (B120 , B121) ) ) , ( Initialize B122 ) , ( 1 + B123 )) ) ) = ( DataPart ( Comput (( R1 +* B121 ) , ( Initialize B122 ) , B123) ) )) implies (( IC ( Comput (( R1 +* ( while>0 (B120 , B121) ) ) , ( Initialize B122 ) , ( ( 1 + B123 ) + 1 )) ) ) = ( ( IC ( Comput (( R1 +* B121 ) , ( Initialize B122 ) , ( B123 + 1 )) ) ) + 4 ) & ( DataPart ( Comput (( R1 +* ( while>0 (B120 , B121) ) ) , ( Initialize B122 ) , ( ( 1 + B123 ) + 1 )) ) ) = ( DataPart ( Comput (( R1 +* B121 ) , ( B122 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) , ( B123 + 1 )) ) ))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
set D179 = ( ( Goto ( 0 ) ) ";" ( Stop ( SCM+FSA ) ) );
set D180 = ( Stop ( SCM+FSA ) );
let C129 being Int-Location;
set D181 = ( ( Int-Locations ) \/ ( FinSeq-Locations ) );
let C130 being (Program of ( SCM+FSA ));
let C131 being (State of ( SCM+FSA ));
let C132 being (Element of ( NAT ));
set D182 = ( Initialize C131 );
set D183 = ( R1 +* ( while>0 (C129 , C130) ) );
set D184 = ( Initialize C131 );
set D185 = ( R1 +* C130 );
L672: C130 c= D185 by FUNCT_4:25;
set D186 = ( Comput (D183 , D182 , ( 1 + C132 )) );
set D187 = ( Comput (D185 , D184 , C132) );
set D188 = ( IC ( Comput (D185 , D184 , C132) ) );
set D189 = ( C130 ";" ( Goto ( 0 ) ) );
set D190 = ( C129 >0_goto ( ( card D180 ) + 3 ) );
reconsider D191 = D188 as (Element of ( NAT ));
set D192 = ( ( D190 ";" D180 ) ";" ( Goto ( ( card D189 ) + 1 ) ) );
set D193 = ( D189 ";" ( Stop ( SCM+FSA ) ) );
L673: ( rng C130 ) c= (the InstructionsF of ( SCM+FSA )) by RELAT_1:def 19;
assume L674: C130 is_closed_on C131 , R1;
L675: D191 in ( dom C130 ) by L674 , SCMFSA7B:def 6;
L676: D191 < ( card C130 ) by L675 , AFINSQ_1:66;
L677: ( D191 + 4 ) < ( ( card C130 ) + 6 ) by L676 , XREAL_1:8;
L678: ( D185 /. ( IC D187 ) ) = ( D185 . ( IC D187 ) ) by PBOOLE:143;
L679: ( CurInstr (D185 , D187) ) = ( D185 . D191 ) by L678
.= ( C130 . D191 ) by L675 , L672 , GRFUNC_1:2;
assume L680: C130 is_halting_on C131 , R1;
L681: D185 halts_on D184 by L680 , SCMFSA7B:def 7;
assume L682: C132 < ( LifeSpan (D185 , D184) );
L683: ( C130 . D191 ) <> ( halt ( SCM+FSA ) ) by L682 , L679 , L681 , EXTPRO_1:def 15;
L684: D193 = ( C130 ";" D179 ) by SCMFSA6A:25;
L685: ( dom D193 ) = ( ( dom ( Directed C130 ) ) \/ ( dom ( Reloc (D179 , ( card C130 )) ) ) ) by L684 , FUNCT_4:def 1
.= ( ( dom C130 ) \/ ( dom ( Reloc (D179 , ( card C130 )) ) ) ) by FUNCT_4:99;
L686: D191 in ( dom D193 ) by L685 , L675 , XBOOLE_0:def 3;
L687: ( D191 + 4 ) in { ( B124 + 4 ) where B124 is (Element of ( NAT )) : B124 in ( dom D193 ) } by L686;
L688: ( D191 + 4 ) in ( dom ( Shift (D193 , 4) ) ) by L687 , VALUED_1:def 12;
L689: ( ( Shift (D193 , 4) ) /. ( D191 + 4 ) ) = ( ( Shift (D193 , 4) ) . ( D191 + 4 ) ) by L688 , PARTFUN1:def 6
.= ( D193 . D191 ) by L686 , VALUED_1:def 12
.= ( ( Directed C130 ) . D191 ) by L675 , L684 , SCMFSA8A:14
.= ( C130 . D191 ) by L675 , L683 , SCMFSA8A:16;
L690: ( card ( while>0 (C129 , C130) ) ) = ( ( card C130 ) + 6 ) by L40;
L691: ( D191 + 4 ) in ( dom ( while>0 (C129 , C130) ) ) by L690 , L677 , AFINSQ_1:66;
L692: ( C130 . D191 ) in ( rng C130 ) by L675 , FUNCT_1:def 3;
reconsider D194 = ( C130 . D191 ) as (Instruction of ( SCM+FSA )) by L692 , L673;
L693: ( card D192 ) = ( ( card ( D190 ";" D180 ) ) + ( card ( Goto ( ( card D189 ) + 1 ) ) ) ) by SCMFSA6A:21
.= ( ( card ( D190 ";" D180 ) ) + 1 ) by SCMFSA8A:15
.= ( ( ( card ( Macro D190 ) ) + ( card D180 ) ) + 1 ) by SCMFSA6A:21
.= ( ( 2 + 1 ) + 1 ) by L1 , COMPOS_1:56
.= ( 3 + 1 );
L694: ( D191 + 4 ) >= ( card D192 ) by L693 , NAT_1:11;
L695: (not ( D191 + 4 ) in ( dom D192 )) by L694 , AFINSQ_1:66;
L696: ( Comput (D185 , D184 , ( C132 + 1 )) ) = ( Following (D185 , D187) ) by EXTPRO_1:3
.= ( Exec (D194 , D187) ) by L679;
set D195 = ( ( ( card C130 ) + 4 ) .--> ( goto ( 0 ) ) );
assume L697: ( IC ( Comput (D183 , D182 , ( 1 + C132 )) ) ) = ( D188 + 4 );
L698: (( dom D195 ) = { ( ( card C130 ) + 4 ) } & ( D191 + 4 ) <> ( ( card C130 ) + 4 )) by L675 , FUNCOP_1:13;
L699: (not ( D191 + 4 ) in ( dom D195 )) by L698 , TARSKI:def 1;
L700: ( dom ( while>0 (C129 , C130) ) ) = ( ( dom ( if>0 (C129 , D189 , D180) ) ) \/ ( dom D195 ) ) by FUNCT_4:def 1;
L701: ( D191 + 4 ) in ( dom ( if>0 (C129 , D189 , D180) ) ) by L700 , L699 , L691 , XBOOLE_0:def 3;
L702: ( CutLastLoc ( stop D192 ) ) = D192;
L703: ( if>0 (C129 , D189 , D180) ) = ( ( D192 ";" D189 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2
.= ( D192 ";" D193 ) by SCMFSA6A:25
.= ( ( Directed D192 ) +* ( Reloc (D193 , 4) ) ) by L693 , L702;
L704: ( dom ( if>0 (C129 , D189 , D180) ) ) = ( ( dom ( Directed D192 ) ) \/ ( dom ( Reloc (D193 , 4) ) ) ) by L703 , FUNCT_4:def 1;
L705: ( dom ( if>0 (C129 , D189 , D180) ) ) = ( ( dom D192 ) \/ ( dom ( Reloc (D193 , 4) ) ) ) by L704 , FUNCT_4:99;
L706: ( D191 + 4 ) in ( dom ( Reloc (D193 , 4) ) ) by L705 , L701 , L695 , XBOOLE_0:def 3;
L707: ( D183 /. ( IC D186 ) ) = ( D183 . ( IC D186 ) ) by PBOOLE:143;
L708: ( Reloc (D193 , 4) ) = ( IncAddr (( Shift (D193 , 4) ) , 4) ) by COMPOS_1:34;
L709: ( D183 . ( D191 + 4 ) ) = ( ( while>0 (C129 , C130) ) . ( D191 + 4 ) ) by L691 , FUNCT_4:13
.= ( ( ( Directed D192 ) +* ( Reloc (D193 , 4) ) ) . ( D191 + 4 ) ) by L699 , L691 , L700 , L703 , FUNCT_4:def 1
.= ( ( Reloc (D193 , 4) ) . ( D191 + 4 ) ) by L701 , L704 , L706 , FUNCT_4:def 1
.= ( IncAddr (D194 , 4) ) by L688 , L689 , L708 , COMPOS_1:def 21;
L710: ( CurInstr (D183 , D186) ) = ( IncAddr (D194 , 4) ) by L709 , L697 , L707;
assume L711: ( DataPart D186 ) = ( DataPart D187 );
L712: ( Comput (D183 , D182 , ( ( 1 + C132 ) + 1 )) ) = ( Following (D183 , D186) ) by EXTPRO_1:3
.= ( Exec (( IncAddr (D194 , 4) ) , D186) ) by L710;
thus L713: thesis by L712 , L697 , L711 , L696 , SCMFSA6A:8;
end;
theorem
L714: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B125 being Int-Location holds (for B126 being (Program of ( SCM+FSA )) holds (for B127 being (State of ( SCM+FSA )) holds ((B126 is_closed_on B127 , R1 & B126 is_halting_on B127 , R1 & ( IC ( Comput (( R1 +* ( while>0 (B125 , B126) ) ) , ( Initialize B127 ) , ( 1 + ( LifeSpan (( R1 +* B126 ) , ( Initialize B127 )) ) )) ) ) = ( ( IC ( Comput (( R1 +* B126 ) , ( Initialize B127 ) , ( LifeSpan (( R1 +* B126 ) , ( Initialize B127 )) )) ) ) + 4 )) implies ( CurInstr (( R1 +* ( while>0 (B125 , B126) ) ) , ( Comput (( R1 +* ( while>0 (B125 , B126) ) ) , ( Initialize B127 ) , ( 1 + ( LifeSpan (( R1 +* B126 ) , ( Initialize B127 )) ) )) )) ) = ( goto ( ( card B126 ) + 4 ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
set D196 = ( ( Goto ( 0 ) ) ";" ( Stop ( SCM+FSA ) ) );
set D197 = ( Stop ( SCM+FSA ) );
let C133 being Int-Location;
let C134 being (Program of ( SCM+FSA ));
let C135 being (State of ( SCM+FSA ));
set D198 = ( Initialize C135 );
set D199 = ( R1 +* ( while>0 (C133 , C134) ) );
L715: ( while>0 (C133 , C134) ) c= D199 by FUNCT_4:25;
set D200 = ( Initialize C135 );
set D201 = ( R1 +* C134 );
L716: C134 c= D201 by FUNCT_4:25;
set D202 = ( LifeSpan (( R1 +* C134 ) , ( Initialize C135 )) );
set D203 = ( Comput (D199 , D198 , ( 1 + D202 )) );
set D204 = ( Comput (D201 , D200 , D202) );
set D205 = ( C134 ";" ( Goto ( 0 ) ) );
set D206 = ( C133 >0_goto ( ( card D197 ) + 3 ) );
reconsider D207 = ( IC D204 ) as (Element of ( NAT ));
set D208 = ( ( D206 ";" D197 ) ";" ( Goto ( ( card D205 ) + 1 ) ) );
set D209 = ( D205 ";" ( Stop ( SCM+FSA ) ) );
assume L717: C134 is_closed_on C135 , R1;
L718: D207 in ( dom C134 ) by L717 , SCMFSA7B:def 6;
L719: D207 < ( card C134 ) by L718 , AFINSQ_1:66;
L720: ( D207 + 4 ) < ( ( card C134 ) + 6 ) by L719 , XREAL_1:8;
L721: ( D201 /. ( IC D204 ) ) = ( D201 . ( IC D204 ) ) by PBOOLE:143;
assume L722: C134 is_halting_on C135 , R1;
L723: D201 halts_on D200 by L722 , SCMFSA7B:def 7;
L724: ( CurInstr (D201 , D204) ) = ( C134 . D207 ) by L718 , L716 , L721 , GRFUNC_1:2;
L725: ( C134 . D207 ) = ( halt ( SCM+FSA ) ) by L724 , L723 , EXTPRO_1:def 15;
L726: D209 = ( C134 ";" D196 ) by SCMFSA6A:25;
L727: ( dom D209 ) = ( ( dom ( Directed C134 ) ) \/ ( dom ( Reloc (D196 , ( card C134 )) ) ) ) by L726 , FUNCT_4:def 1
.= ( ( dom C134 ) \/ ( dom ( Reloc (D196 , ( card C134 )) ) ) ) by FUNCT_4:99;
L728: D207 in ( dom D209 ) by L727 , L718 , XBOOLE_0:def 3;
L729: ( D207 + 4 ) in { ( B128 + 4 ) where B128 is (Element of ( NAT )) : B128 in ( dom D209 ) } by L728;
L730: ( D207 + 4 ) in ( dom ( Shift (D209 , 4) ) ) by L729 , VALUED_1:def 12;
L731: ( ( Shift (D209 , 4) ) /. ( D207 + 4 ) ) = ( ( Shift (D209 , 4) ) . ( D207 + 4 ) ) by L730 , PARTFUN1:def 6
.= ( D209 . D207 ) by L728 , VALUED_1:def 12
.= ( ( Directed C134 ) . D207 ) by L718 , L726 , SCMFSA8A:14
.= ( goto ( card C134 ) ) by L718 , L725 , SCMFSA8A:16;
set D210 = ( ( ( card C134 ) + 4 ) .--> ( goto ( 0 ) ) );
assume L732: ( IC D203 ) = ( ( IC D204 ) + 4 );
L733: (( dom D210 ) = { ( ( card C134 ) + 4 ) } & ( D207 + 4 ) <> ( ( card C134 ) + 4 )) by L718 , FUNCOP_1:13;
L734: (not ( D207 + 4 ) in ( dom D210 )) by L733 , TARSKI:def 1;
L735: ( card D208 ) = ( ( card ( D206 ";" D197 ) ) + ( card ( Goto ( ( card D205 ) + 1 ) ) ) ) by SCMFSA6A:21
.= ( ( card ( D206 ";" D197 ) ) + 1 ) by SCMFSA8A:15
.= ( ( ( card ( Macro D206 ) ) + ( card D197 ) ) + 1 ) by SCMFSA6A:21
.= ( ( 2 + 1 ) + 1 ) by L1 , COMPOS_1:56
.= ( 3 + 1 );
L736: ( D207 + 4 ) >= ( card D208 ) by L735 , NAT_1:11;
L737: (not ( D207 + 4 ) in ( dom D208 )) by L736 , AFINSQ_1:66;
L738: ( card ( while>0 (C133 , C134) ) ) = ( ( card C134 ) + 6 ) by L40;
L739: ( D207 + 4 ) in ( dom ( while>0 (C133 , C134) ) ) by L738 , L720 , AFINSQ_1:66;
L740: ( dom ( while>0 (C133 , C134) ) ) = ( ( dom ( if>0 (C133 , D205 , D197) ) ) \/ ( dom D210 ) ) by FUNCT_4:def 1;
L741: ( D207 + 4 ) in ( dom ( if>0 (C133 , D205 , D197) ) ) by L740 , L734 , L739 , XBOOLE_0:def 3;
L742: ( CutLastLoc ( stop D208 ) ) = D208;
L743: ( if>0 (C133 , D205 , D197) ) = ( ( D208 ";" D205 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2
.= ( D208 ";" D209 ) by SCMFSA6A:25
.= ( ( Directed D208 ) +* ( Reloc (D209 , 4) ) ) by L735 , L742;
L744: ( dom ( if>0 (C133 , D205 , D197) ) ) = ( ( dom ( Directed D208 ) ) \/ ( dom ( Reloc (D209 , 4) ) ) ) by L743 , FUNCT_4:def 1;
L745: ( dom ( if>0 (C133 , D205 , D197) ) ) = ( ( dom D208 ) \/ ( dom ( Reloc (D209 , 4) ) ) ) by L744 , FUNCT_4:99;
L746: ( D207 + 4 ) in ( dom ( Reloc (D209 , 4) ) ) by L745 , L741 , L737 , XBOOLE_0:def 3;
L747: ( D199 /. ( IC D203 ) ) = ( D199 . ( IC D203 ) ) by PBOOLE:143;
L748: ( Reloc (D209 , 4) ) = ( IncAddr (( Shift (D209 , 4) ) , 4) ) by COMPOS_1:34;
L749: ( D199 . ( D207 + 4 ) ) = ( ( ( if>0 (C133 , D205 , D197) ) +* D210 ) . ( D207 + 4 ) ) by L739 , L715 , GRFUNC_1:2
.= ( ( ( Directed D208 ) +* ( Reloc (D209 , 4) ) ) . ( D207 + 4 ) ) by L734 , L739 , L740 , L743 , FUNCT_4:def 1
.= ( ( Reloc (D209 , 4) ) . ( D207 + 4 ) ) by L741 , L744 , L746 , FUNCT_4:def 1
.= ( IncAddr (( goto ( card C134 ) ) , 4) ) by L730 , L731 , L748 , COMPOS_1:def 21
.= ( goto ( ( card C134 ) + 4 ) ) by SCMFSA_4:1;
thus L750: thesis by L749 , L732 , L747;
end;
theorem
L751: (for B129 being Int-Location holds (for B130 being (Program of ( SCM+FSA )) holds ( ( while>0 (B129 , B130) ) . ( ( card B130 ) + 4 ) ) = ( goto ( 0 ) )))
proof
set D211 = ( Stop ( SCM+FSA ) );
let C136 being Int-Location;
let C137 being (Program of ( SCM+FSA ));
set D212 = ( C137 ";" ( Goto ( 0 ) ) );
set D213 = ( ( ( card C137 ) + 4 ) .--> ( goto ( 0 ) ) );
set D214 = ( ( card C137 ) + 4 );
L752: ( dom D213 ) = { D214 } by FUNCOP_1:13;
L753: D214 in ( dom D213 ) by L752 , TARSKI:def 1;
L754: (D214 in ( dom ( while>0 (C136 , C137) ) ) & ( dom ( while>0 (C136 , C137) ) ) = ( ( dom ( if>0 (C136 , D212 , D211) ) ) \/ ( dom D213 ) )) by L555 , FUNCT_4:def 1;
thus L755: ( ( while>0 (C136 , C137) ) . D214 ) = ( D213 . D214 ) by L754 , L753 , FUNCT_4:def 1
.= ( goto ( 0 ) ) by FUNCOP_1:72;
end;
theorem
L756: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B131 being (State of ( SCM+FSA )) holds (for B132 being (Program of ( SCM+FSA )) holds (for B133 being  read-write Int-Location holds ((B132 is_closed_on B131 , R1 & B132 is_halting_on B131 , R1 & ( B131 . B133 ) > ( 0 )) implies (( IC ( Comput (( R1 +* ( while>0 (B133 , B132) ) ) , ( Initialize B131 ) , ( ( LifeSpan (( R1 +* B132 ) , ( Initialize B131 )) ) + 3 )) ) ) = ( 0 ) & (for B134 being (Element of ( NAT )) holds (B134 <= ( ( LifeSpan (( R1 +* B132 ) , ( Initialize B131 )) ) + 3 ) implies ( IC ( Comput (( R1 +* ( while>0 (B133 , B132) ) ) , ( Initialize B131 ) , B134) ) ) in ( dom ( while>0 (B133 , B132) ) )))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C138 being (State of ( SCM+FSA ));
set D215 = ( ( Int-Locations ) \/ ( FinSeq-Locations ) );
let C139 being (Program of ( SCM+FSA ));
let C140 being  read-write Int-Location;
assume L757: C139 is_closed_on C138 , R1;
set D216 = ( Initialize C138 );
set D217 = ( R1 +* C139 );
set D218 = ( Initialize C138 );
set D219 = ( R1 +* ( while>0 (C140 , C139) ) );
L758: ( while>0 (C140 , C139) ) c= D219 by FUNCT_4:25;
defpred S4[ Nat ] means ($1 <= ( LifeSpan (D217 , D216) ) implies (( IC ( Comput (D219 , D218 , ( 1 + $1 )) ) ) = ( ( IC ( Comput (D217 , D216 , $1) ) ) + 4 ) & ( DataPart ( Comput (D219 , D218 , ( 1 + $1 )) ) ) = ( DataPart ( Comput (D217 , D216 , $1) ) )));
assume L759: C139 is_halting_on C138 , R1;
L760:
now
let C141 being (Element of ( NAT ));
assume L761: S4[ C141 ];
L762:
now
L763: ( C141 + ( 0 ) ) < ( C141 + 1 ) by XREAL_1:6;
assume L764: ( C141 + 1 ) <= ( LifeSpan (D217 , D216) );
L765: C141 < ( LifeSpan (D217 , D216) ) by L764 , L763 , XXREAL_0:2;
thus L766: (( IC ( Comput (D219 , D218 , ( ( 1 + C141 ) + 1 )) ) ) = ( ( IC ( Comput (D217 , D216 , ( C141 + 1 )) ) ) + 4 ) & ( DataPart ( Comput (D219 , D218 , ( ( 1 + C141 ) + 1 )) ) ) = ( DataPart ( Comput (D217 , D216 , ( C141 + 1 )) ) )) by L765 , L757 , L759 , L761 , L671;
end;
thus L767: S4[ ( C141 + 1 ) ] by L762;
end;
reconsider D220 = ( LifeSpan (D217 , D216) ) as (Element of ( NAT ));
set D221 = ( ( card C139 ) + 4 );
set D222 = ( C140 >0_goto 4 );
set D223 = ( Comput (D219 , D218 , 1) );
L768: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L769: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L768;
L770: ( IC D218 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L769 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L771: (not C140 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L772: ( D218 . C140 ) = ( C138 . C140 ) by L771 , FUNCT_4:11;
assume L773: ( C138 . C140 ) > ( 0 );
L774: ( 0 ) in ( dom ( while>0 (C140 , C139) ) ) by L54;
L775: ( D219 /. ( IC D218 ) ) = ( D219 . ( IC D218 ) ) by PBOOLE:143;
L776: ( D219 . ( 0 ) ) = ( ( while>0 (C140 , C139) ) . ( 0 ) ) by L774 , FUNCT_4:13
.= D222 by L71;
L777: ( CurInstr (D219 , D218) ) = D222 by L776 , L770 , L775;
L778: ( Comput (D219 , D218 , ( ( 0 ) + 1 )) ) = ( Following (D219 , ( Comput (D219 , D218 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D219 , D218) )
.= ( Exec (D222 , D218) ) by L777;
L779: ((for R6 being Int-Location holds ( D223 . R6 ) = ( D218 . R6 )) & (for R5 being FinSeq-Location holds ( D223 . R5 ) = ( D218 . R5 ))) by L778 , SCMFSA_2:71;
L780: ( DataPart D223 ) = ( DataPart D218 ) by L779 , SCMFSA_M:2
.= ( DataPart D216 );
L781: ( IC D223 ) = 4 by L773 , L778 , L772 , SCMFSA_2:71;
L782: S4[ ( 0 ) ]
proof
assume L783: ( 0 ) <= ( LifeSpan (D217 , D216) );
L784: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L785: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L784;
L786: ( IC ( Comput (D217 , D216 , ( 0 )) ) ) = ( IC D216 )
.= ( IC D1 ) by L785 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
thus L787: thesis by L786 , L781 , L780;
end;
L788: (for B135 being (Element of ( NAT )) holds S4[ B135 ]) from NAT_1:sch 1(L782 , L760);
set D224 = ( Comput (D219 , D218 , ( ( ( 1 + ( LifeSpan (D217 , D216) ) ) + 1 ) + 1 )) );
set D225 = ( Comput (D219 , D218 , ( ( 1 + ( LifeSpan (D217 , D216) ) ) + 1 )) );
L789: D221 in ( dom ( while>0 (C140 , C139) ) ) by L555;
set D226 = ( Comput (D219 , D218 , ( 1 + ( LifeSpan (D217 , D216) ) )) );
L790: S4[ D220 ] by L788;
L791: ( CurInstr (D219 , D226) ) = ( goto D221 ) by L790 , L757 , L759 , L714;
L792: D225 = ( Following (D219 , D226) ) by EXTPRO_1:3
.= ( Exec (( goto D221 ) , D226) ) by L791;
L793: ( IC D225 ) = D221 by L792 , SCMFSA_2:69;
L794: ( D219 /. ( IC D225 ) ) = ( D219 . ( IC D225 ) ) by PBOOLE:143;
L795: ( D219 . D221 ) = ( ( while>0 (C140 , C139) ) . D221 ) by L789 , L758 , GRFUNC_1:2
.= ( goto ( 0 ) ) by L751;
L796: ( CurInstr (D219 , D225) ) = ( goto ( 0 ) ) by L795 , L793 , L794;
L797: D224 = ( Following (D219 , D225) ) by EXTPRO_1:3
.= ( Exec (( goto ( 0 ) ) , D225) ) by L796;
L798: ( IC D224 ) = ( 0 ) by L797 , SCMFSA_2:69;
thus L799: ( IC ( Comput (D219 , D218 , ( ( LifeSpan (D217 , D216) ) + 3 )) ) ) = ( 0 ) by L798;
L800: ( ( ( ( LifeSpan (D217 , D216) ) + 1 ) + 1 ) + 1 ) = ( ( LifeSpan (D217 , D216) ) + ( 2 + 1 ) );
L801:
now
let C142 being (Element of ( NAT ));
assume L802: C142 <= ( ( LifeSpan (D217 , D216) ) + 3 );
assume L803: C142 <> ( 0 );
consider C143 being Nat such that L804: C142 = ( C143 + 1 ) by L803 , NAT_1:6;
L805: (C142 <= ( ( LifeSpan (D217 , D216) ) + 1 ) or C142 >= ( ( ( LifeSpan (D217 , D216) ) + 1 ) + 1 )) by NAT_1:13;
L806: (C142 <= ( ( LifeSpan (D217 , D216) ) + 1 ) or C142 = ( ( ( LifeSpan (D217 , D216) ) + 1 ) + 1 ) or C142 > ( ( ( LifeSpan (D217 , D216) ) + 1 ) + 1 )) by L805 , XXREAL_0:1;
reconsider D227 = C143 as (Element of ( NAT )) by ORDINAL1:def 12;
per cases  by L800 , L806 , NAT_1:13;
suppose L807: C142 <= ( ( LifeSpan (D217 , D216) ) + 1 );

L808: D227 <= ( LifeSpan (D217 , D216) ) by L807 , L804 , XREAL_1:6;
L809: ( IC ( Comput (D219 , D218 , ( 1 + D227 )) ) ) = ( ( IC ( Comput (D217 , D216 , D227) ) ) + 4 ) by L808 , L788;
reconsider D228 = ( IC ( Comput (D217 , D216 , D227) ) ) as (Element of ( NAT ));
L810: D228 in ( dom C139 ) by L757 , SCMFSA7B:def 6;
L811: D228 < ( card C139 ) by L810 , AFINSQ_1:66;
L812: ( D228 + 4 ) < ( ( card C139 ) + 6 ) by L811 , XREAL_1:8;
L813: ( card ( while>0 (C140 , C139) ) ) = ( ( card C139 ) + 6 ) by L40;
thus L814: ( IC ( Comput (D219 , D218 , C142) ) ) in ( dom ( while>0 (C140 , C139) ) ) by L813 , L804 , L809 , L812 , AFINSQ_1:66;
end;
suppose L815: C142 = ( ( ( LifeSpan (D217 , D216) ) + 1 ) + 1 );

thus L816: ( IC ( Comput (D219 , D218 , C142) ) ) in ( dom ( while>0 (C140 , C139) ) ) by L815 , L793 , L555;
end;
suppose L817: C142 >= ( ( LifeSpan (D217 , D216) ) + 3 );

L818: C142 = ( ( LifeSpan (D217 , D216) ) + 3 ) by L817 , L802 , XXREAL_0:1;
thus L819: ( IC ( Comput (D219 , D218 , C142) ) ) in ( dom ( while>0 (C140 , C139) ) ) by L818 , L798 , L54;
end;
end;
L821:
now
let C144 being (Element of ( NAT ));
assume L822: C144 <= ( ( LifeSpan (D217 , D216) ) + 3 );
per cases ;
suppose L823: C144 = ( 0 );

thus L824: ( IC ( Comput (D219 , D218 , C144) ) ) in ( dom ( while>0 (C140 , C139) ) ) by L823 , L774 , L770 , EXTPRO_1:2;
end;
suppose L825: C144 <> ( 0 );

thus L826: ( IC ( Comput (D219 , D218 , C144) ) ) in ( dom ( while>0 (C140 , C139) ) ) by L825 , L801 , L822;
end;
end;
thus L828: thesis by L821;
end;
definition
let R14 being (State of ( SCM+FSA ));
let R15 being (Program of ( SCM+FSA ));
let R16 being  read-write Int-Location;
let R1 being (Instruction-Sequence of ( SCM+FSA ));
deffunc H4(Nat , (State of ( SCM+FSA ))) = ( Comput (( R1 +* ( while>0 (R16 , R15) ) ) , ( $2 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) , ( ( LifeSpan (( ( R1 +* ( while>0 (R16 , R15) ) ) +* R15 ) , ( $2 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) )) ) + 3 )) );
deffunc H5(Nat , (State of ( SCM+FSA ))) = ( down H4($1 , $2) );
func StepWhile>0 (R16 , R15 , R1 , R14) -> (Function of ( NAT ) , ( product ( the_Values_of ( SCM+FSA ) ) )) means 
:L829: (( it . ( 0 ) ) = R14 & (for B136 being Nat holds ( it . ( B136 + 1 ) ) = ( Comput (( R1 +* ( while>0 (R16 , R15) ) ) , ( ( it . B136 ) +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) , ( ( LifeSpan (( ( R1 +* ( while>0 (R16 , R15) ) ) +* R15 ) , ( ( it . B136 ) +* ( Start-At (( 0 ) , ( SCM+FSA )) ) )) ) + 3 )) )));
existence
proof
reconsider D229 = R14 as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
consider C145 being (Function of ( NAT ) , ( product ( the_Values_of ( SCM+FSA ) ) )) such that L830: ( C145 . ( 0 ) ) = D229 and L831: (for B137 being Nat holds ( C145 . ( B137 + 1 ) ) = H5(B137 , ( C145 . B137 ))) from NAT_1:sch 12;
take C145;
thus L832: ( C145 . ( 0 ) ) = R14 by L830;
let C146 being Nat;
L833: ( C145 . ( C146 + 1 ) ) = H5(C146 , ( C145 . C146 )) by L831;
thus L834: thesis by L833;
end;
uniqueness
proof
let C147 , C148 being (Function of ( NAT ) , ( product ( the_Values_of ( SCM+FSA ) ) ));
assume that
L835: ( C147 . ( 0 ) ) = R14
and
L836: (for B138 being Nat holds ( C147 . ( B138 + 1 ) ) = H4(B138 , ( C147 . B138 )))
and
L837: ( C148 . ( 0 ) ) = R14
and
L838: (for B139 being Nat holds ( C148 . ( B139 + 1 ) ) = H4(B139 , ( C148 . B139 )));
reconsider D230 = R14 as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
L839: ( C147 . ( 0 ) ) = D230 by L835;
L840: (for B140 being Nat holds ( C147 . ( B140 + 1 ) ) = H5(B140 , ( C147 . B140 ))) by L836;
L841: ( C148 . ( 0 ) ) = D230 by L837;
L842: (for B141 being Nat holds ( C148 . ( B141 + 1 ) ) = H5(B141 , ( C148 . B141 ))) by L838;
L843: C147 = C148 from NAT_1:sch 16(L839 , L840 , L841 , L842);
thus L844: thesis by L843;
end;
end;
theorem
L846: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R11 being (Element of ( NAT )) holds (for R14 being (State of ( SCM+FSA )) holds (for R15 being (Program of ( SCM+FSA )) holds (for R16 being  read-write Int-Location holds ( ( StepWhile>0 (R16 , R15 , R1 , R14) ) . ( R11 + 1 ) ) = ( ( StepWhile>0 (R16 , R15 , R1 , ( ( StepWhile>0 (R16 , R15 , R1 , R14) ) . R11 )) ) . 1 ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R11 being (Element of ( NAT ));
let R14 being (State of ( SCM+FSA ));
let R15 being (Program of ( SCM+FSA ));
let R16 being  read-write Int-Location;
set D231 = ( ( StepWhile>0 (R16 , R15 , R1 , R14) ) . R11 );
set D232 = ( ( StepWhile>0 (R16 , R15 , R1 , D231) ) . ( 0 ) );
L847: D232 = D231 by L829;
thus L848: ( ( StepWhile>0 (R16 , R15 , R1 , R14) ) . ( R11 + 1 ) ) = ( Comput (( R1 +* ( while>0 (R16 , R15) ) ) , ( D232 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) , ( ( LifeSpan (( ( R1 +* ( while>0 (R16 , R15) ) ) +* R15 ) , ( D232 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) )) ) + 3 )) ) by L847 , L829
.= ( ( StepWhile>0 (R16 , R15 , R1 , D231) ) . ( ( 0 ) + 1 ) ) by L829
.= ( ( StepWhile>0 (R16 , R15 , R1 , D231) ) . 1 );
end;
theorem
L849: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B142 being (Program of ( SCM+FSA )) holds (for B143 being  read-write Int-Location holds (for B144 being (State of ( SCM+FSA )) holds ( ( StepWhile>0 (B143 , B142 , R1 , B144) ) . ( ( 0 ) + 1 ) ) = ( Comput (( R1 +* ( while>0 (B143 , B142) ) ) , ( Initialize B144 ) , ( ( LifeSpan (( ( R1 +* ( while>0 (B143 , B142) ) ) +* B142 ) , ( Initialize B144 )) ) + 3 )) )))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C149 being (Program of ( SCM+FSA ));
let C150 being  read-write Int-Location;
let C151 being (State of ( SCM+FSA ));
L850: ( ( StepWhile>0 (C150 , C149 , R1 , C151) ) . ( 0 ) ) = C151 by L829;
thus L851: ( ( StepWhile>0 (C150 , C149 , R1 , C151) ) . ( ( 0 ) + 1 ) ) = ( Comput (( R1 +* ( while>0 (C150 , C149) ) ) , ( Initialize C151 ) , ( ( LifeSpan (( ( R1 +* ( while>0 (C150 , C149) ) ) +* C149 ) , ( Initialize C151 )) ) + 3 )) ) by L850 , L829;
end;
theorem
L852: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B145 being (Program of ( SCM+FSA )) holds (for B146 being  read-write Int-Location holds (for B147 being (State of ( SCM+FSA )) holds (for B148 , B149 being (Element of ( NAT )) holds ((( IC ( ( StepWhile>0 (B146 , B145 , R1 , B147) ) . B148 ) ) = ( 0 ) & ( ( StepWhile>0 (B146 , B145 , R1 , B147) ) . B148 ) = ( Comput (( R1 +* ( while>0 (B146 , B145) ) ) , ( Initialize B147 ) , B149) )) implies (( ( StepWhile>0 (B146 , B145 , R1 , B147) ) . B148 ) = ( Initialize ( ( StepWhile>0 (B146 , B145 , R1 , B147) ) . B148 ) ) & ( ( StepWhile>0 (B146 , B145 , R1 , B147) ) . ( B148 + 1 ) ) = ( Comput (( R1 +* ( while>0 (B146 , B145) ) ) , ( Initialize B147 ) , ( B149 + ( ( LifeSpan (( ( R1 +* ( while>0 (B146 , B145) ) ) +* B145 ) , ( Initialize ( ( StepWhile>0 (B146 , B145 , R1 , B147) ) . B148 ) )) ) + 3 ) )) ))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C152 being (Program of ( SCM+FSA ));
let C153 being  read-write Int-Location;
let C154 being (State of ( SCM+FSA ));
let C155 , C156 being (Element of ( NAT ));
set D233 = ( ( Int-Locations ) \/ ( FinSeq-Locations ) );
set D234 = ( Initialize C154 );
set D235 = ( R1 +* ( while>0 (C153 , C152) ) );
set D236 = ( ( StepWhile>0 (C153 , C152 , R1 , C154) ) . C155 );
set D237 = ( Initialize D236 );
assume L853: ( IC D236 ) = ( 0 );
assume L854: D236 = ( Comput (D235 , D234 , C156) );
L855: D236 is ( 0 ) -started by L853 , MEMSTR_0:def 12;
L856: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= D236 by L855 , MEMSTR_0:29;
thus L857: D237 = D236 by L856 , FUNCT_4:98;
thus L858: ( ( StepWhile>0 (C153 , C152 , R1 , C154) ) . ( C155 + 1 ) ) = ( Comput (D235 , D236 , ( ( LifeSpan (( ( R1 +* ( while>0 (C153 , C152) ) ) +* C152 ) , ( Initialize D236 )) ) + 3 )) ) by L857 , L829
.= ( Comput (D235 , D234 , ( C156 + ( ( LifeSpan (( ( R1 +* ( while>0 (C153 , C152) ) ) +* C152 ) , ( Initialize D236 )) ) + 3 ) )) ) by L854 , EXTPRO_1:4;
end;
theorem
L859: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B150 being (Program of ( SCM+FSA )) holds (for B151 being  read-write Int-Location holds (for B152 being (State of ( SCM+FSA )) holds (((for B153 being Nat holds (B150 is_closed_on ( ( StepWhile>0 (B151 , B150 , R1 , B152) ) . B153 ) , ( R1 +* ( while>0 (B151 , B150) ) ) & B150 is_halting_on ( ( StepWhile>0 (B151 , B150 , R1 , B152) ) . B153 ) , ( R1 +* ( while>0 (B151 , B150) ) ))) & (ex B154 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) st (for B155 being Nat holds ((( B154 . ( ( StepWhile>0 (B151 , B150 , R1 , B152) ) . ( B155 + 1 ) ) ) < ( B154 . ( ( StepWhile>0 (B151 , B150 , R1 , B152) ) . B155 ) ) or ( B154 . ( ( StepWhile>0 (B151 , B150 , R1 , B152) ) . B155 ) ) = ( 0 )) & (( B154 . ( ( StepWhile>0 (B151 , B150 , R1 , B152) ) . B155 ) ) = ( 0 ) iff ( ( ( StepWhile>0 (B151 , B150 , R1 , B152) ) . B155 ) . B151 ) <= ( 0 )))))) implies (( while>0 (B151 , B150) ) is_halting_on B152 , R1 & ( while>0 (B151 , B150) ) is_closed_on B152 , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C157 being (Program of ( SCM+FSA ));
let C158 being  read-write Int-Location;
let C159 being (State of ( SCM+FSA ));
set D238 = ( ( Int-Locations ) \/ ( FinSeq-Locations ) );
assume L860: (for B156 being Nat holds (C157 is_closed_on ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . B156 ) , ( R1 +* ( while>0 (C158 , C157) ) ) & C157 is_halting_on ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . B156 ) , ( R1 +* ( while>0 (C158 , C157) ) )));
set D239 = ( Initialize C159 );
set D240 = ( R1 +* ( while>0 (C158 , C157) ) );
L861: ( D240 +* ( while>0 (C158 , C157) ) ) = D240;
L862: ( D240 +* ( while>0 (C158 , C157) ) ) = D240;
given C160 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that
L863: (for B157 being Nat holds ((( C160 . ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . ( B157 + 1 ) ) ) < ( C160 . ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . B157 ) ) or ( C160 . ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . B157 ) ) = ( 0 )) & (( C160 . ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . B157 ) ) = ( 0 ) iff ( ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . B157 ) . C158 ) <= ( 0 ))));

deffunc H6(Nat) = ( C160 . ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . $1 ) );
L864: (for B158 being Nat holds (H6(( B158 + 1 )) < H6(B158) or H6(B158) = ( 0 ))) by L863;
consider C161 being Nat such that L865: H6(C161) = ( 0 ) and L866: (for B159 being Nat holds (H6(B159) = ( 0 ) implies C161 <= B159)) from NAT_1:sch 17(L864);
defpred S5[ Nat ] means (( $1 + 1 ) <= C161 implies (ex R11 being (Element of ( NAT )) st ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . ( $1 + 1 ) ) = ( Comput (D240 , D239 , R11) )));
L867:
now
let C162 being (Element of ( NAT ));
assume L868: S5[ C162 ];
L869:
now
set D241 = ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . ( C162 + 1 ) );
set D242 = ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . C162 );
assume L870: ( ( C162 + 1 ) + 1 ) <= C161;
L871: ( C162 + ( 0 ) ) < ( C162 + ( 1 + 1 ) ) by XREAL_1:6;
L872: C162 < C161 by L871 , L870 , XXREAL_0:2;
L873: H6(C162) <> ( 0 ) by L872 , L866;
L874: ( D242 . C158 ) > ( 0 ) by L873 , L863;
L875: C157 is_halting_on D242 , ( R1 +* ( while>0 (C158 , C157) ) ) by L860;
L876: ( ( C162 + 1 ) + ( 0 ) ) < ( ( C162 + 1 ) + 1 ) by XREAL_1:6;
consider C163 being (Element of ( NAT )) such that L877: D241 = ( Comput (D240 , D239 , C163) ) by L876 , L868 , L870 , XXREAL_0:2;
take D243 = ( C163 + ( ( LifeSpan (( ( R1 +* ( while>0 (C158 , C157) ) ) +* C157 ) , ( Initialize D241 )) ) + 3 ) );
L878: (D241 = ( Comput (( R1 +* ( while>0 (C158 , C157) ) ) , ( Initialize D242 ) , ( ( LifeSpan (( ( R1 +* ( while>0 (C158 , C157) ) ) +* C157 ) , ( Initialize D242 )) ) + 3 )) ) & C157 is_closed_on D242 , ( R1 +* ( while>0 (C158 , C157) ) )) by L860 , L829;
L879: ( IC D241 ) = ( 0 ) by L878 , L875 , L874 , L756 , L861;
thus L880: ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . ( ( C162 + 1 ) + 1 ) ) = ( Comput (D240 , D239 , D243) ) by L879 , L877 , L852;
end;
thus L881: S5[ ( C162 + 1 ) ] by L869;
end;
L882: S5[ ( 0 ) ]
proof
assume L883: ( ( 0 ) + 1 ) <= C161;
take D244 = ( ( LifeSpan (( ( R1 +* ( while>0 (C158 , C157) ) ) +* C157 ) , ( Initialize C159 )) ) + 3 );
thus L884: thesis by L849;
end;
L885: (for B160 being (Element of ( NAT )) holds S5[ B160 ]) from NAT_1:sch 1(L882 , L867);
L886:
now
per cases ;
suppose L887: C161 = ( 0 );

L888: ( ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . ( 0 ) ) . C158 ) <= ( 0 ) by L887 , L863 , L865;
L889: ( C159 . C158 ) <= ( 0 ) by L888 , L829;
thus L890: thesis by L889 , L620;
end;
suppose L891: C161 <> ( 0 );

set D245 = ( ( LifeSpan (( ( R1 +* ( while>0 (C158 , C157) ) ) +* C157 ) , ( Initialize C159 )) ) + 3 );
set D246 = ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . C161 );
set D247 = ( Initialize D246 );
consider C164 being Nat such that L892: C161 = ( C164 + 1 ) by L891 , NAT_1:6;
reconsider D248 = C164 as (Element of ( NAT )) by ORDINAL1:def 12;
L893: C161 = ( D248 + 1 ) by L892;
consider C165 being (Element of ( NAT )) such that L894: D246 = ( Comput (D240 , D239 , C165) ) by L893 , L885;
set D249 = ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . D248 );
L895: D248 < C161 by L892 , NAT_1:13;
L896: H6(D248) <> ( 0 ) by L895 , L866;
L897: ( D249 . C158 ) > ( 0 ) by L896 , L863;
L898: (C157 is_closed_on D249 , ( R1 +* ( while>0 (C158 , C157) ) ) & C157 is_halting_on D249 , ( R1 +* ( while>0 (C158 , C157) ) )) by L860;
L899: D246 = ( Comput (( R1 +* ( while>0 (C158 , C157) ) ) , ( Initialize D249 ) , ( ( LifeSpan (( ( R1 +* ( while>0 (C158 , C157) ) ) +* C157 ) , ( Initialize D249 )) ) + 3 )) ) by L892 , L829;
L900: ( IC D246 ) = ( 0 ) by L899 , L898 , L897 , L756 , L861;
L901: D246 is ( 0 ) -started by L900 , MEMSTR_0:def 12;
L902: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= D246 by L901 , MEMSTR_0:29;
L903: D247 = D246 by L902 , FUNCT_4:98;
L904: ( D246 . C158 ) <= ( 0 ) by L863 , L865;
L905: ( while>0 (C158 , C157) ) is_halting_on D246 , D240 by L904 , L620;
L906: ( D240 +* ( while>0 (C158 , C157) ) ) halts_on ( Initialize D246 ) by L905 , SCMFSA7B:def 7;
L907: D240 halts_on D247 by L906;
consider C166 being (Element of ( NAT )) such that L908: ( CurInstr (D240 , ( Comput (D240 , D246 , C166) )) ) = ( halt ( SCM+FSA ) ) by L907 , L903 , EXTPRO_1:29;
L909: ( Comput (D240 , D239 , ( C165 + C166 )) ) = ( Comput (D240 , ( Comput (D240 , D239 , C165) ) , C166) ) by EXTPRO_1:4;
L910: ( CurInstr (D240 , ( Comput (D240 , D239 , ( C165 + C166 )) )) ) = ( halt ( SCM+FSA ) ) by L894 , L908 , L909;
L911: D240 halts_on D239 by L910 , EXTPRO_1:29;
thus L912: ( while>0 (C158 , C157) ) is_halting_on C159 , R1 by L911 , SCMFSA7B:def 7;
L913:
now
let C167 being (Element of ( NAT ));
L914: ( 0 ) < C161 by L891;
per cases ;
suppose L915: C167 <= D245;

L916: ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . ( 0 ) ) = C159 by L829;
L917: (C157 is_closed_on C159 , ( R1 +* ( while>0 (C158 , C157) ) ) & C157 is_halting_on C159 , ( R1 +* ( while>0 (C158 , C157) ) )) by L916 , L860;
L918: H6(( 0 )) <> ( 0 ) by L866 , L914;
L919: ( C159 . C158 ) > ( 0 ) by L918 , L863 , L916;
thus L920: ( IC ( Comput (D240 , D239 , C167) ) ) in ( dom ( while>0 (C158 , C157) ) ) by L919 , L915 , L917 , L756 , L861;
end;
suppose L921: C167 > D245;

L922:
now
take D250 = D245;
thus L923: (( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . 1 ) = ( Comput (D240 , D239 , D250) ) & D250 <= C167) by L921 , L849;
end;
defpred S6[ Nat ] means ($1 <= C161 & $1 <> ( 0 ) & (ex R11 being (Element of ( NAT )) st (( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . $1 ) = ( Comput (D240 , D239 , R11) ) & R11 <= C167)));
L924: (for B161 being Nat holds (S6[ B161 ] implies B161 <= C161));
L925: ( ( 0 ) + 1 ) < ( C161 + 1 ) by L914 , XREAL_1:6;
L926: 1 <= C161 by L925 , NAT_1:13;
L927: (ex B162 being Nat st S6[ B162 ]) by L926 , L922;
consider C168 being Nat such that L928: (S6[ C168 ] & (for B163 being Nat holds (S6[ B163 ] implies B163 <= C168))) from NAT_1:sch 6(L924 , L927);
reconsider D251 = C168 as (Element of ( NAT )) by ORDINAL1:def 12;
L929:
now
per cases ;
suppose L930: D251 = C161;

consider C169 being (Element of ( NAT )) such that L931: D246 = ( Comput (D240 , D239 , C169) ) and L932: C169 <= C167 by L930 , L928;
consider C170 being Nat such that L933: C167 = ( C169 + C170 ) by L932 , NAT_1:10;
L934: ( while>0 (C158 , C157) ) is_closed_on D246 , D240 by L904 , L620;
reconsider D252 = C170 as (Element of ( NAT )) by ORDINAL1:def 12;
L935: ( Comput (D240 , D239 , C167) ) = ( Comput (D240 , D247 , D252) ) by L903 , L931 , L933 , EXTPRO_1:4;
thus L936: ( IC ( Comput (D240 , D239 , C167) ) ) in ( dom ( while>0 (C158 , C157) ) ) by L934 , L935 , L862 , SCMFSA7B:def 6;
end;
suppose L937: D251 <> C161;

set D253 = ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . D251 );
L938: D251 < C161 by L928 , L937 , XXREAL_0:1;
L939: H6(D251) <> ( 0 ) by L938 , L866;
L940: ( D253 . C158 ) > ( 0 ) by L939 , L863;
consider C171 being (Element of ( NAT )) such that L941: ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . D251 ) = ( Comput (D240 , D239 , C171) ) and L942: C171 <= C167 by L928;
set D254 = ( C171 + ( ( LifeSpan (( ( R1 +* ( while>0 (C158 , C157) ) ) +* C157 ) , ( Initialize D253 )) ) + 3 ) );
consider C172 being Nat such that L943: C167 = ( C171 + C172 ) by L942 , NAT_1:10;
L944: (C157 is_closed_on D253 , ( R1 +* ( while>0 (C158 , C157) ) ) & C157 is_halting_on D253 , ( R1 +* ( while>0 (C158 , C157) ) )) by L860;
consider C173 being Nat such that L945: D251 = ( C173 + 1 ) by L928 , NAT_1:6;
reconsider D255 = C173 as (Element of ( NAT )) by ORDINAL1:def 12;
set D256 = ( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . D255 );
L946: ( D255 + ( 0 ) ) < D251 by L945 , XREAL_1:6;
L947: D255 < C161 by L946 , L928 , XXREAL_0:2;
L948: H6(D255) <> ( 0 ) by L947 , L866;
L949: ( D256 . C158 ) > ( 0 ) by L948 , L863;
L950: (C157 is_closed_on D256 , ( R1 +* ( while>0 (C158 , C157) ) ) & C157 is_halting_on D256 , ( R1 +* ( while>0 (C158 , C157) ) )) by L860;
reconsider D257 = C172 as (Element of ( NAT )) by ORDINAL1:def 12;
L951: D253 = ( Comput (( R1 +* ( while>0 (C158 , C157) ) ) , ( Initialize D256 ) , ( ( LifeSpan (( ( R1 +* ( while>0 (C158 , C157) ) ) +* C157 ) , ( Initialize D256 )) ) + 3 )) ) by L945 , L829;
L952: ( IC D253 ) = ( 0 ) by L951 , L950 , L949 , L756 , L861;
L953:
now
assume L954: D254 <= C167;
L955:
now
take D258 = D254;
thus L956: (( ( StepWhile>0 (C158 , C157 , R1 , C159) ) . ( D251 + 1 ) ) = ( Comput (D240 , D239 , D258) ) & D258 <= C167) by L941 , L952 , L954 , L852;
end;
L957: ( D251 + 1 ) <= C161 by L938 , NAT_1:13;
thus L958: contradiction by L957 , L928 , L955 , XREAL_1:29;
end;
L959: D257 < ( ( LifeSpan (( ( R1 +* ( while>0 (C158 , C157) ) ) +* C157 ) , ( Initialize D253 )) ) + 3 ) by L953 , L943 , XREAL_1:6;
L960: ( Initialize D253 ) = D253 by L941 , L952 , L852;
L961: ( Comput (D240 , D239 , C167) ) = ( Comput (( R1 +* ( while>0 (C158 , C157) ) ) , ( Initialize D253 ) , D257) ) by L960 , L941 , L943 , EXTPRO_1:4;
thus L962: ( IC ( Comput (D240 , D239 , C167) ) ) in ( dom ( while>0 (C158 , C157) ) ) by L961 , L959 , L944 , L940 , L756 , L861;
end;
end;
thus L964: ( IC ( Comput (D240 , D239 , C167) ) ) in ( dom ( while>0 (C158 , C157) ) ) by L929;
end;
end;
thus L966: ( while>0 (C158 , C157) ) is_closed_on C159 , R1 by L913 , SCMFSA7B:def 6;
end;
end;
thus L968: thesis by L886;
end;
theorem
L969: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B164 being  parahalting (Program of ( SCM+FSA )) holds (for B165 being  read-write Int-Location holds (for B166 being (State of ( SCM+FSA )) holds ((ex B167 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) st (for B168 being Nat holds ((( B167 . ( ( StepWhile>0 (B165 , B164 , R1 , B166) ) . ( B168 + 1 ) ) ) < ( B167 . ( ( StepWhile>0 (B165 , B164 , R1 , B166) ) . B168 ) ) or ( B167 . ( ( StepWhile>0 (B165 , B164 , R1 , B166) ) . B168 ) ) = ( 0 )) & (( B167 . ( ( StepWhile>0 (B165 , B164 , R1 , B166) ) . B168 ) ) = ( 0 ) iff ( ( ( StepWhile>0 (B165 , B164 , R1 , B166) ) . B168 ) . B165 ) <= ( 0 ))))) implies (( while>0 (B165 , B164) ) is_halting_on B166 , R1 & ( while>0 (B165 , B164) ) is_closed_on B166 , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C174 being  parahalting (Program of ( SCM+FSA ));
let C175 being  read-write Int-Location;
let C176 being (State of ( SCM+FSA ));
L970: (for B169 being Nat holds (C174 is_closed_on ( ( StepWhile>0 (C175 , C174 , R1 , C176) ) . B169 ) , ( R1 +* ( while>0 (C175 , C174) ) ) & C174 is_halting_on ( ( StepWhile>0 (C175 , C174 , R1 , C176) ) . B169 ) , ( R1 +* ( while>0 (C175 , C174) ) ))) by SCMFSA7B:18 , SCMFSA7B:19;
assume L971: (ex B170 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) st (for B171 being Nat holds ((( B170 . ( ( StepWhile>0 (C175 , C174 , R1 , C176) ) . ( B171 + 1 ) ) ) < ( B170 . ( ( StepWhile>0 (C175 , C174 , R1 , C176) ) . B171 ) ) or ( B170 . ( ( StepWhile>0 (C175 , C174 , R1 , C176) ) . B171 ) ) = ( 0 )) & (( B170 . ( ( StepWhile>0 (C175 , C174 , R1 , C176) ) . B171 ) ) = ( 0 ) iff ( ( ( StepWhile>0 (C175 , C174 , R1 , C176) ) . B171 ) . C175 ) <= ( 0 )))));
thus L972: thesis by L971 , L970 , L859;
end;
theorem
L973: (for B172 being  parahalting (Program of ( SCM+FSA )) holds (for B173 being  read-write Int-Location holds ((ex B174 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) st (for B175 being (State of ( SCM+FSA )) holds (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds ((( B174 . ( ( StepWhile>0 (B173 , B172 , R1 , B175) ) . 1 ) ) < ( B174 . B175 ) or ( B174 . B175 ) = ( 0 )) & (( B174 . B175 ) = ( 0 ) iff ( B175 . B173 ) <= ( 0 )))))) implies ( while>0 (B173 , B172) ) is  parahalting)))
proof
let C177 being  parahalting (Program of ( SCM+FSA ));
let C178 being  read-write Int-Location;
given C179 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that
L974: (for B176 being (State of ( SCM+FSA )) holds (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds ((( C179 . ( ( StepWhile>0 (C178 , C177 , R1 , B176) ) . 1 ) ) < ( C179 . B176 ) or ( C179 . B176 ) = ( 0 )) & (( C179 . B176 ) = ( 0 ) iff ( B176 . C178 ) <= ( 0 )))));

L975:
now
let C180 being (State of ( SCM+FSA ));
let R2 being (Instruction-Sequence of ( SCM+FSA ));
L976:
now
let C181 being Nat;
L977: C181 in ( NAT ) by ORDINAL1:def 12;
L978: (( C179 . ( ( StepWhile>0 (C178 , C177 , R2 , ( ( StepWhile>0 (C178 , C177 , R2 , C180) ) . C181 )) ) . 1 ) ) < ( C179 . ( ( StepWhile>0 (C178 , C177 , R2 , C180) ) . C181 ) ) or ( C179 . ( ( StepWhile>0 (C178 , C177 , R2 , C180) ) . C181 ) ) = ( 0 )) by L974;
thus L979: ((( C179 . ( ( StepWhile>0 (C178 , C177 , R2 , C180) ) . ( C181 + 1 ) ) ) < ( C179 . ( ( StepWhile>0 (C178 , C177 , R2 , C180) ) . C181 ) ) or ( C179 . ( ( StepWhile>0 (C178 , C177 , R2 , C180) ) . C181 ) ) = ( 0 )) & (( C179 . ( ( StepWhile>0 (C178 , C177 , R2 , C180) ) . C181 ) ) = ( 0 ) iff ( ( ( StepWhile>0 (C178 , C177 , R2 , C180) ) . C181 ) . C178 ) <= ( 0 ))) by L978 , L974 , L977 , L846;
end;
thus L980: ( while>0 (C178 , C177) ) is_halting_on C180 , R2 by L976 , L969;
end;
thus L981: thesis by L975 , SCMFSA7B:19;
end;
registration
let C182 , C183 being  good (Program of ( SCM+FSA ));
let C184 being Int-Location;
cluster ( if>0 (C184 , C182 , C183) ) ->  good;
coherence
proof
set D259 = ( C184 >0_goto ( ( card C183 ) + 3 ) );
reconsider D260 = ( Macro D259 ) as  good (Program of ( SCM+FSA )) by L530 , SCMFSA7B:13;
L982: ( if>0 (C184 , C182 , C183) ) = ( ( ( ( D259 ";" C183 ) ";" ( Goto ( ( card C182 ) + 1 ) ) ) ";" C182 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2
.= ( ( ( ( D260 ";" C183 ) ";" ( Goto ( ( card C182 ) + 1 ) ) ) ";" C182 ) ";" ( Stop ( SCM+FSA ) ) );
thus L983: thesis by L982;
end;
end;
registration
let C185 being  good (Program of ( SCM+FSA ));
let C186 being Int-Location;
cluster ( while>0 (C186 , C185) ) ->  good;
correctness
proof
set D261 = ( if>0 (C186 , ( C185 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) );
set D262 = ( ( ( card C185 ) + 4 ) .--> ( goto ( 0 ) ) );
L985: ((not D262 destroy ( intloc ( 0 ) )) & (not D261 destroy ( intloc ( 0 ) ))) by L523 , SCMFSA7B:def 5;
L986: (not ( while>0 (C186 , C185) ) destroy ( intloc ( 0 ) )) by L985 , SCMFSA8A:11;
thus L987: thesis by L986 , SCMFSA7B:def 5;
end;
end;
