:: The { \bf for } (going up) Macro Instruction
::  by Piotr Rudnicki
::
:: Received June 4, 1998
:: Copyright (c) 1998-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FSM_1, SCMFSA_2, SF_MASTR, AMI_1, SCMFSA7B, SUBSET_1,
      UNIALG_2, SCMFSA6C, SCMFSA6B, FUNCT_1, XBOOLE_0, FUNCT_4, CARD_1,
      AMISTD_2, RELAT_1, GRAPHSP, AMI_3, PARTFUN1, COMPLEX1, SCMFSA8B,
      TURING_1, SCMFSA_9, ARYTM_3, FUNCOP_1, SCMFSA8A, CARD_3, SFMASTR1,
      ARYTM_1, XXREAL_0, SCMFSA6A, TARSKI, SCMFSA9A, FINSEQ_1, GRAPH_2,
      AOFA_I00, FUNCT_2, FINSEQ_2, SFMASTR3, NAT_1, PBOOLE, COMPOS_1,
      MEMSTR_0, EXTPRO_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, CARD_3,
      INT_2, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_4, FUNCT_7, PBOOLE,
      FUNCOP_1, GRAPH_2, FINSEQ_1, FINSEQ_2, MEMSTR_0, COMPOS_0, COMPOS_1,
      EXTPRO_1, AMISTD_1, SCMFSA_2, SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C,
      SCMFSA7B, SCMFSA8A, SCMFSA8B, SCMFSA_9, SFMASTR1, SCMFSA9A, XXREAL_0,
      ORDINAL1, NAT_1, SCMFSA_M;
 constructors SETWISEO, REAL_1, INT_2, MESFUNC1, SCMFSA6A, SCMFSA6B, SCMFSA6C,
      SCMFSA8A, SCMFSA8B, SCMFSA_9, SFMASTR1, SCMFSA9A, RELSET_1, FUNCT_4,
      PBOOLE, GRAPH_2, SCMFSA7B, MEMSTR_0, AMISTD_1, FINSEQ_2, SCMFSA_M,
      SF_MASTR, FUNCT_7;
 registrations SUBSET_1, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCT_2,
      FINSET_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, SCMFSA_2,
      SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B, SCMFSA_9,
      SFMASTR1, XBOOLE_0, VALUED_0, AFINSQ_1, FUNCOP_1, COMPOS_1, EXTPRO_1,
      PBOOLE, FUNCT_4, MEMSTR_0, SCMFSA6A, FINSEQ_1, AMI_3, COMPOS_0,
      SCMFSA_M, PRE_POLY;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, SCMFSA7B, SCMFSA9A, GRAPH_2, SCMFSA6A, COMPOS_1, EXTPRO_1,
      MEMSTR_0, SCMFSA_M;
 theorems TARSKI, ZFMISC_1, ENUMSET1, ABSVALUE, NAT_1, INT_1, RELAT_1, FUNCT_7,
      FINSEQ_1, FINSEQ_2, FINSEQ_3, FINSEQ_4, GRAPH_2, SCMFSA_2, MEMSTR_0,
      SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B,
      SCMFSA8C, SCMFSA_9, SFMASTR1, SCMFSA9A, SFMASTR2, XBOOLE_0, XBOOLE_1,
      XREAL_1, XXREAL_0, PARTFUN1, AFINSQ_1, PBOOLE, EXTPRO_1, CARD_3,
      SCMFSA_M;
 schemes FUNCT_2, NAT_1;

begin
theorem
L1: (for R1 being (State of ( SCM+FSA )) holds (for R4 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds ((R10 is_closed_on ( Initialized R1 ) , R15 & R10 is_halting_on ( Initialized R1 ) , R15 & (not R10 destroy R4)) implies ( ( IExec (R10 , R15 , R1) ) . R4 ) = ( ( Initialized R1 ) . R4 ))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
set D1 = R4;
L2: ( DataPart ( Initialized R1 ) ) = ( DataPart ( Initialize ( Initialized R1 ) ) ) by MEMSTR_0:79;
assume L3: (R10 is_closed_on ( Initialized R1 ) , R15 & R10 is_halting_on ( Initialized R1 ) , R15 & (not R10 destroy D1));
thus L4: ( ( IExec (R10 , R15 , R1) ) . D1 ) = ( ( Comput (( R15 +* R10 ) , ( Initialize ( Initialized R1 ) ) , ( 0 )) ) . D1 ) by L3 , SCMFSA8C:60
.= ( ( Initialize ( Initialized R1 ) ) . D1 )
.= ( ( Initialized R1 ) . D1 ) by L2 , SCMFSA_M:2;
end;
theorem
L5: (for R1 being (State of ( SCM+FSA )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds (( R1 . ( intloc ( 0 ) ) ) = 1 implies ( DataPart ( IExec (( Stop ( SCM+FSA ) ) , R15 , R1) ) ) = ( DataPart R1 ))))
proof
let R1 being (State of ( SCM+FSA ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
assume L6: ( R1 . ( intloc ( 0 ) ) ) = 1;
thus L7: ( DataPart ( IExec (( Stop ( SCM+FSA ) ) , R15 , R1) ) ) = ( DataPart ( Initialized R1 ) ) by SCMFSA8C:14
.= ( DataPart R1 ) by L6 , SCMFSA_M:19;
end;
theorem
L8: (for R4 being Int-Location holds (not ( Stop ( SCM+FSA ) ) refer R4))
proof
let R4 being Int-Location;
L9: ( rng ( Stop ( SCM+FSA ) ) ) = { ( halt ( SCM+FSA ) ) } by AFINSQ_1:33;
let C1 being (Instruction of ( SCM+FSA ));
assume L10: C1 in ( rng ( Stop ( SCM+FSA ) ) );
L11: C1 = ( halt ( SCM+FSA ) ) by L10 , L9 , TARSKI:def 1;
thus L12: thesis by L11 , SCMFSA8C:49;
end;
theorem
L13: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (R4 <> R5 implies (not ( R6 := R5 ) refer R4)))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
assume L14: R4 <> R5;
L15:
now
let C2 being Int-Location;
let C3 being (Element of ( NAT ));
let C4 being FinSeq-Location;
thus L16: ( C2 := R4 ) <> ( R6 := R5 ) by L14 , SF_MASTR:1;
L17: ( InsCode ( R6 := R5 ) ) = 1 by SCMFSA_2:18;
thus L18: ( AddTo (C2 , R4) ) <> ( R6 := R5 ) by L17 , SCMFSA_2:19;
thus L19: ( SubFrom (C2 , R4) ) <> ( R6 := R5 ) by L17 , SCMFSA_2:20;
thus L20: ( MultBy (C2 , R4) ) <> ( R6 := R5 ) by L17 , SCMFSA_2:21;
thus L21: (( Divide (R4 , C2) ) <> ( R6 := R5 ) & ( Divide (C2 , R4) ) <> ( R6 := R5 )) by L17 , SCMFSA_2:22;
thus L22: ( R4 =0_goto C3 ) <> ( R6 := R5 ) by L17 , SCMFSA_2:24;
thus L23: ( R4 >0_goto C3 ) <> ( R6 := R5 ) by L17 , SCMFSA_2:25;
thus L24: ( C2 := (C4 , R4) ) <> ( R6 := R5 ) by L17 , SCMFSA_2:26;
thus L25: (( (C4 , C2) := R4 ) <> ( R6 := R5 ) & ( (C4 , R4) := C2 ) <> ( R6 := R5 )) by L17 , SCMFSA_2:27;
thus L26: ( C4 :=<0,...,0> R4 ) <> ( R6 := R5 ) by L17 , SCMFSA_2:29;
end;
thus L27: thesis by L15 , SCMFSA7B:def 1;
end;
theorem
L28: (for R1 being (State of ( SCM+FSA )) holds (for R2 being  read-write Int-Location holds (for R5 being Int-Location holds (for R9 being FinSeq-Location holds ( ( Exec (( R2 := (R9 , R5) ) , R1) ) . R2 ) = ( ( R1 . R9 ) /. ( abs ( R1 . R5 ) ) )))))
proof
let R1 being (State of ( SCM+FSA ));
let R2 being  read-write Int-Location;
let R5 being Int-Location;
let R9 being FinSeq-Location;
L29: (ex B1 being (Element of ( NAT )) st (B1 = ( abs ( R1 . R5 ) ) & ( ( Exec (( R2 := (R9 , R5) ) , R1) ) . R2 ) = ( ( R1 . R9 ) /. B1 ))) by SCMFSA_2:72;
thus L30: thesis by L29;
end;
theorem
L31: (for R1 being (State of ( SCM+FSA )) holds (for R4 being Int-Location holds (for R5 being Int-Location holds (for R9 being FinSeq-Location holds ( ( Exec (( (R9 , R4) := R5 ) , R1) ) . R9 ) = ( ( R1 . R9 ) +* (( abs ( R1 . R4 ) ) , ( R1 . R5 )) )))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being Int-Location;
let R5 being Int-Location;
let R9 being FinSeq-Location;
L32: (ex B2 being (Element of ( NAT )) st (B2 = ( abs ( R1 . R4 ) ) & ( ( Exec (( (R9 , R4) := R5 ) , R1) ) . R9 ) = ( ( R1 . R9 ) +* (B2 , ( R1 . R5 )) ))) by SCMFSA_2:73;
thus L33: thesis by L32;
end;
registration
let C5 being  read-write Int-Location;
let C6 being Int-Location;
let C7 , C8 being  good (Program of ( SCM+FSA ));
cluster ( if>0 (C5 , C6 , C7 , C8) ) ->  good;
coherence
proof
L34: ( if>0 (C5 , C6 , C7 , C8) ) = ( ( SubFrom (C5 , C6) ) ";" ( if>0 (C5 , C7 , C8) ) ) by SCMFSA8B:def 5;
thus L35: thesis by L34;
end;
end;
theorem
L37: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds (for R11 being (Program of ( SCM+FSA )) holds ( UsedIntLoc ( if>0 (R4 , R5 , R10 , R11) ) ) = ( ( { R4 , R5 } \/ ( UsedIntLoc R10 ) ) \/ ( UsedIntLoc R11 ) )))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
let R11 being (Program of ( SCM+FSA ));
set D2 = R4;
thus L38: ( UsedIntLoc ( if>0 (D2 , R5 , R10 , R11) ) ) = ( UsedIntLoc ( ( SubFrom (D2 , R5) ) ";" ( if>0 (D2 , R10 , R11) ) ) ) by SCMFSA8B:def 5
.= ( ( UsedIntLoc ( SubFrom (D2 , R5) ) ) \/ ( UsedIntLoc ( if>0 (D2 , R10 , R11) ) ) ) by SF_MASTR:29
.= ( { D2 , R5 } \/ ( UsedIntLoc ( if>0 (D2 , R10 , R11) ) ) ) by SF_MASTR:14
.= ( { D2 , R5 } \/ ( ( { D2 } \/ ( UsedIntLoc R10 ) ) \/ ( UsedIntLoc R11 ) ) ) by SCMFSA9A:9
.= ( { D2 , R5 } \/ ( { D2 } \/ ( ( UsedIntLoc R10 ) \/ ( UsedIntLoc R11 ) ) ) ) by XBOOLE_1:4
.= ( ( { D2 , R5 } \/ { D2 } ) \/ ( ( UsedIntLoc R10 ) \/ ( UsedIntLoc R11 ) ) ) by XBOOLE_1:4
.= ( { D2 , R5 } \/ ( ( UsedIntLoc R10 ) \/ ( UsedIntLoc R11 ) ) ) by ZFMISC_1:9
.= ( ( { D2 , R5 } \/ ( UsedIntLoc R10 ) ) \/ ( UsedIntLoc R11 ) ) by XBOOLE_1:4;
end;
theorem
L39: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds ((not R10 destroy R4) implies (not ( while>0 (R5 , R10) ) destroy R4)))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
set D3 = ( ( ( card R10 ) + 4 ) .--> ( goto ( 0 ) ) );
set D4 = ( if>0 (R5 , ( R10 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) );
L40: (not ( Goto ( 0 ) ) destroy R4) by SCMFSA8C:57;
L41: (not ( Stop ( SCM+FSA ) ) destroy R4) by SCMFSA8C:56;
assume L42: (not R10 destroy R4);
L43: (not ( R10 ";" ( Goto ( 0 ) ) ) destroy R4) by L42 , L40 , SCMFSA8C:52;
L44: (not D4 destroy R4) by L43 , L41 , SCMFSA8C:88;
L45: ((not D3 destroy R4) & ( while>0 (R5 , R10) ) = ( D4 +* D3 )) by SCMFSA_9:30 , SCMFSA_9:def 2;
thus L46: thesis by L45 , L44 , SCMFSA8A:11;
end;
theorem
L47: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds (for R11 being (Program of ( SCM+FSA )) holds ((R6 <> R4 & (not R10 destroy R6) & (not R11 destroy R6)) implies (not ( if>0 (R4 , R5 , R10 , R11) ) destroy R6)))))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
let R11 being (Program of ( SCM+FSA ));
assume that
L48: R6 <> R4
and
L49: ((not R10 destroy R6) & (not R11 destroy R6));
L50: (( if>0 (R4 , R5 , R10 , R11) ) = ( ( SubFrom (R4 , R5) ) ";" ( if>0 (R4 , R10 , R11) ) ) & (not ( if>0 (R4 , R10 , R11) ) destroy R6)) by L49 , SCMFSA8B:def 5 , SCMFSA8C:88;
thus L51: thesis by L50 , L48 , SCMFSA7B:8 , SCMFSA8C:53;
end;
begin
definition
let R15 being (Instruction-Sequence of ( SCM+FSA ));
let C9 , C10 , C11 being Int-Location;
let C12 being (Program of ( SCM+FSA ));
let C13 being (State of ( SCM+FSA ));
func StepForUp (C9 , C10 , C11 , C12 , R15 , C13) -> (Function of ( NAT ) , ( product ( the_Values_of ( SCM+FSA ) ) )) equals 
( StepWhile>0 (( 1 -stRWNotIn ( { C9 , C10 , C11 } \/ ( UsedIntLoc C12 ) ) ) , ( ( C12 ";" ( AddTo (C9 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { C9 , C10 , C11 } \/ ( UsedIntLoc C12 ) ) ) , ( intloc ( 0 ) )) ) ) , R15 , ( ( C13 +* (( 1 -stRWNotIn ( { C9 , C10 , C11 } \/ ( UsedIntLoc C12 ) ) ) , ( ( ( C13 . C11 ) - ( C13 . C10 ) ) + 1 )) ) +* (C9 , ( C13 . C10 )) )) );
coherence;
end;
theorem
L53: (for R1 being (State of ( SCM+FSA )) holds (for R2 being  read-write Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds (( R1 . ( intloc ( 0 ) ) ) = 1 implies ( ( ( StepForUp (R2 , R5 , R6 , R10 , R15 , R1) ) . ( 0 ) ) . ( intloc ( 0 ) ) ) = 1)))))))
proof
let R1 being (State of ( SCM+FSA ));
let R2 being  read-write Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
set D5 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) );
set D6 = ( ( R1 +* (D5 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) +* (R2 , ( R1 . R5 )) );
L54: ( D6 . ( intloc ( 0 ) ) ) = ( ( R1 +* (D5 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) . ( intloc ( 0 ) ) ) by FUNCT_7:32
.= ( R1 . ( intloc ( 0 ) ) ) by FUNCT_7:32;
assume L55: ( R1 . ( intloc ( 0 ) ) ) = 1;
thus L56: thesis by L55 , L54 , SCMFSA_9:def 5;
end;
theorem
L57: (for R1 being (State of ( SCM+FSA )) holds (for R2 being  read-write Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds ( ( ( StepForUp (R2 , R5 , R6 , R10 , R15 , R1) ) . ( 0 ) ) . R2 ) = ( R1 . R5 )))))))
proof
let R1 being (State of ( SCM+FSA ));
let R2 being  read-write Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
set D7 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) );
set D8 = ( ( R1 +* (D7 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) +* (R2 , ( R1 . R5 )) );
L58: (( ( StepWhile>0 (D7 , ( ( R10 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (D7 , ( intloc ( 0 ) )) ) ) , R15 , D8) ) . ( 0 ) ) = D8 & R2 in ( dom ( R1 +* (D7 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) )) by SCMFSA_2:42 , SCMFSA_9:def 5;
thus L59: thesis by L58 , FUNCT_7:31;
end;
theorem
L60: (for R1 being (State of ( SCM+FSA )) holds (for R2 being  read-write Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds (R2 <> R5 implies ( ( ( StepForUp (R2 , R5 , R6 , R10 , R15 , R1) ) . ( 0 ) ) . R5 ) = ( R1 . R5 ))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R2 being  read-write Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
set D9 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) );
set D10 = ( ( R1 +* (D9 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) +* (R2 , ( R1 . R5 )) );
L61: R5 in { R2 , R5 , R6 } by ENUMSET1:def 1;
L62: R5 in ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) by L61 , XBOOLE_0:def 3;
L63: R5 <> D9 by L62 , SCMFSA_M:25;
assume L64: R2 <> R5;
L65: ( D10 . R5 ) = ( ( R1 +* (D9 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) . R5 ) by L64 , FUNCT_7:32
.= ( R1 . R5 ) by L63 , FUNCT_7:32;
thus L66: thesis by L65 , SCMFSA_9:def 5;
end;
theorem
L67: (for R1 being (State of ( SCM+FSA )) holds (for R2 being  read-write Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds (R2 <> R6 implies ( ( ( StepForUp (R2 , R5 , R6 , R10 , R15 , R1) ) . ( 0 ) ) . R6 ) = ( R1 . R6 ))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R2 being  read-write Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
set D11 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) );
set D12 = ( ( R1 +* (D11 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) +* (R2 , ( R1 . R5 )) );
L68: R6 in { R2 , R5 , R6 } by ENUMSET1:def 1;
L69: R6 in ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) by L68 , XBOOLE_0:def 3;
L70: R6 <> D11 by L69 , SCMFSA_M:25;
assume L71: R2 <> R6;
L72: ( D12 . R6 ) = ( ( R1 +* (D11 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) . R6 ) by L71 , FUNCT_7:32
.= ( R1 . R6 ) by L70 , FUNCT_7:32;
thus L73: thesis by L72 , SCMFSA_9:def 5;
end;
theorem
L74: (for R1 being (State of ( SCM+FSA )) holds (for R2 being  read-write Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R7 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds ((R2 <> R7 & R7 in ( UsedIntLoc R10 )) implies ( ( ( StepForUp (R2 , R5 , R6 , R10 , R15 , R1) ) . ( 0 ) ) . R7 ) = ( R1 . R7 )))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R2 being  read-write Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R7 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L75: R2 <> R7
and
L76: R7 in ( UsedIntLoc R10 );
set D13 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) );
L77: R7 in ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) by L76 , XBOOLE_0:def 3;
L78: R7 <> D13 by L77 , SCMFSA_M:25;
set D14 = ( ( R1 +* (D13 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) +* (R2 , ( R1 . R5 )) );
L79: ( D14 . R7 ) = ( ( R1 +* (D13 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) . R7 ) by L75 , FUNCT_7:32
.= ( R1 . R7 ) by L78 , FUNCT_7:32;
thus L80: thesis by L79 , SCMFSA_9:def 5;
end;
theorem
L81: (for R1 being (State of ( SCM+FSA )) holds (for R2 being  read-write Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R9 being FinSeq-Location holds (for R10 being (Program of ( SCM+FSA )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds ( ( ( StepForUp (R2 , R5 , R6 , R10 , R15 , R1) ) . ( 0 ) ) . R9 ) = ( R1 . R9 ))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R2 being  read-write Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R9 being FinSeq-Location;
let R10 being (Program of ( SCM+FSA ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
set D15 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) );
set D16 = ( ( R1 +* (D15 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) +* (R2 , ( R1 . R5 )) );
L82: ( D16 . R9 ) = ( ( R1 +* (D15 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) . R9 ) by FUNCT_7:32 , SCMFSA_2:58
.= ( R1 . R9 ) by FUNCT_7:32 , SCMFSA_2:58;
thus L83: thesis by L82 , SCMFSA_9:def 5;
end;
theorem
L84: (for R1 being (State of ( SCM+FSA )) holds (for R2 being  read-write Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds (( R1 . ( intloc ( 0 ) ) ) = 1 implies (for B3 being  read-write Int-Location holds (B3 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) ) implies ( DataPart ( IExec (( ( ( ( B3 := R6 ) ";" ( SubFrom (B3 , R5) ) ) ";" ( AddTo (B3 , ( intloc ( 0 ) )) ) ) ";" ( R2 := R5 ) ) , R15 , R1) ) ) = ( DataPart ( ( R1 +* (B3 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) +* (R2 , ( R1 . R5 )) ) ))))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R2 being  read-write Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
assume L85: ( R1 . ( intloc ( 0 ) ) ) = 1;
L86: (R6 = ( intloc ( 0 ) ) or R6 is  read-write) by SCMFSA_M:def 2;
L87: ( ( Initialized R1 ) . R6 ) = ( R1 . R6 ) by L86 , L85 , SCMFSA_M:9 , SCMFSA_M:37;
set D17 = ( R2 := R5 );
let C14 being  read-write Int-Location;
assume that
L88: C14 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) );
L89: R5 in { R2 , R5 , R6 } by ENUMSET1:def 1;
L90: R5 in ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) by L89 , XBOOLE_0:def 3;
L91: R5 <> C14 by L90 , L88 , SCMFSA_M:25;
set D18 = ( ( R1 +* (C14 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) +* (R2 , ( R1 . R5 )) );
L92: C14 in ( dom R1 ) by SCMFSA_2:42;
L93: R2 in { R2 , R5 , R6 } by ENUMSET1:def 1;
L94: R2 in ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) by L93 , XBOOLE_0:def 3;
L95: R2 <> C14 by L94 , L88 , SCMFSA_M:25;
L96: ( D18 . C14 ) = ( ( R1 +* (C14 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) . C14 ) by L95 , FUNCT_7:32
.= ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 ) by L92 , FUNCT_7:31;
set D19 = ( AddTo (C14 , ( intloc ( 0 ) )) );
set D20 = ( SubFrom (C14 , R5) );
set D21 = ( C14 := R6 );
set D22 = ( IExec (( ( ( D21 ";" D20 ) ";" D19 ) ";" D17 ) , R15 , R1) );
L97: ( ( IExec (( D21 ";" D20 ) , R15 , R1) ) . ( intloc ( 0 ) ) ) = ( ( Exec (D20 , ( Exec (D21 , ( Initialized R1 )) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:8
.= ( ( Exec (D21 , ( Initialized R1 )) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:65
.= ( ( Initialized R1 ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= 1 by SCMFSA_M:9;
L98: R2 in ( dom ( R1 +* (C14 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) ) by SCMFSA_2:42;
L99: (R5 = ( intloc ( 0 ) ) or R5 is  read-write) by SCMFSA_M:def 2;
L100: ( ( Initialized R1 ) . R5 ) = ( R1 . R5 ) by L99 , L85 , SCMFSA_M:9 , SCMFSA_M:37;
L101: ( D22 . R2 ) = ( ( Exec (D17 , ( IExec (( ( D21 ";" D20 ) ";" D19 ) , R15 , R1) )) ) . R2 ) by SCMFSA6C:6
.= ( ( IExec (( ( D21 ";" D20 ) ";" D19 ) , R15 , R1) ) . R5 ) by SCMFSA_2:63
.= ( ( Exec (D19 , ( IExec (( D21 ";" D20 ) , R15 , R1) )) ) . R5 ) by SCMFSA6C:6
.= ( ( IExec (( D21 ";" D20 ) , R15 , R1) ) . R5 ) by L91 , SCMFSA_2:64
.= ( ( Exec (D20 , ( Exec (D21 , ( Initialized R1 )) )) ) . R5 ) by SCMFSA6C:8
.= ( ( Exec (D21 , ( Initialized R1 )) ) . R5 ) by L91 , SCMFSA_2:65
.= ( R1 . R5 ) by L91 , L100 , SCMFSA_2:63;
L102: ( D22 . C14 ) = ( ( Exec (D17 , ( IExec (( ( D21 ";" D20 ) ";" D19 ) , R15 , R1) )) ) . C14 ) by SCMFSA6C:6
.= ( ( IExec (( ( D21 ";" D20 ) ";" D19 ) , R15 , R1) ) . C14 ) by L95 , SCMFSA_2:63
.= ( ( Exec (D19 , ( IExec (( D21 ";" D20 ) , R15 , R1) )) ) . C14 ) by SCMFSA6C:6
.= ( ( ( IExec (( D21 ";" D20 ) , R15 , R1) ) . C14 ) + 1 ) by L97 , SCMFSA_2:64
.= ( ( ( Exec (D20 , ( Exec (D21 , ( Initialized R1 )) )) ) . C14 ) + 1 ) by SCMFSA6C:8
.= ( ( ( ( Exec (D21 , ( Initialized R1 )) ) . C14 ) - ( ( Exec (D21 , ( Initialized R1 )) ) . R5 ) ) + 1 ) by SCMFSA_2:65
.= ( ( ( ( Initialized R1 ) . R6 ) - ( ( Exec (D21 , ( Initialized R1 )) ) . R5 ) ) + 1 ) by SCMFSA_2:63
.= ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 ) by L91 , L87 , L100 , SCMFSA_2:63;
L103:
now
thus L104:now
let C15 being Int-Location;
per cases ;
suppose L105: C15 = R2;

thus L106: ( D22 . C15 ) = ( D18 . C15 ) by L105 , L101 , L98 , FUNCT_7:31;
end;
suppose L107: C15 = C14;

thus L108: ( D22 . C15 ) = ( D18 . C15 ) by L107 , L102 , L96;
end;
suppose L109: (C15 <> C14 & C15 <> R2);

L110: ( D18 . C15 ) = ( ( R1 +* (C14 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) . C15 ) by L109 , FUNCT_7:32
.= ( R1 . C15 ) by L109 , FUNCT_7:32;
L111: (C15 = ( intloc ( 0 ) ) or C15 is  read-write) by SCMFSA_M:def 2;
L112: ( D22 . C15 ) = ( ( Exec (D17 , ( IExec (( ( D21 ";" D20 ) ";" D19 ) , R15 , R1) )) ) . C15 ) by SCMFSA6C:6
.= ( ( IExec (( ( D21 ";" D20 ) ";" D19 ) , R15 , R1) ) . C15 ) by L109 , SCMFSA_2:63
.= ( ( Exec (D19 , ( IExec (( D21 ";" D20 ) , R15 , R1) )) ) . C15 ) by SCMFSA6C:6
.= ( ( IExec (( D21 ";" D20 ) , R15 , R1) ) . C15 ) by L109 , SCMFSA_2:64
.= ( ( Exec (D20 , ( Exec (D21 , ( Initialized R1 )) )) ) . C15 ) by SCMFSA6C:8
.= ( ( Exec (D21 , ( Initialized R1 )) ) . C15 ) by L109 , SCMFSA_2:65
.= ( ( Initialized R1 ) . C15 ) by L109 , SCMFSA_2:63
.= ( R1 . C15 ) by L85 , L111 , SCMFSA_M:9 , SCMFSA_M:37;
thus L113: ( D22 . C15 ) = ( D18 . C15 ) by L112 , L110;
end;
end;
let C16 being FinSeq-Location;
thus L115: ( D22 . C16 ) = ( ( Exec (D17 , ( IExec (( ( D21 ";" D20 ) ";" D19 ) , R15 , R1) )) ) . C16 ) by SCMFSA6C:7
.= ( ( IExec (( ( D21 ";" D20 ) ";" D19 ) , R15 , R1) ) . C16 ) by SCMFSA_2:63
.= ( ( Exec (D19 , ( IExec (( D21 ";" D20 ) , R15 , R1) )) ) . C16 ) by SCMFSA6C:7
.= ( ( IExec (( D21 ";" D20 ) , R15 , R1) ) . C16 ) by SCMFSA_2:64
.= ( ( Exec (D20 , ( Exec (D21 , ( Initialized R1 )) )) ) . C16 ) by SCMFSA6C:9
.= ( ( Exec (D21 , ( Initialized R1 )) ) . C16 ) by SCMFSA_2:65
.= ( ( Initialized R1 ) . C16 ) by SCMFSA_2:63
.= ( R1 . C16 ) by SCMFSA_M:37
.= ( ( R1 +* (C14 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) . C16 ) by FUNCT_7:32 , SCMFSA_2:58
.= ( D18 . C16 ) by FUNCT_7:32 , SCMFSA_2:58;
end;
thus L116: thesis by L103 , SCMFSA_M:2;
end;
definition
let R15 being (Instruction-Sequence of ( SCM+FSA ));
let C17 , C18 , C19 being Int-Location;
let C20 being (Program of ( SCM+FSA ));
let C21 being (State of ( SCM+FSA ));
pred  ProperForUpBody C17 , C18 , C19 , C20 , C21 , R15
means
:L117: (for B4 being (Element of ( NAT )) holds (B4 < ( ( ( C21 . C19 ) - ( C21 . C18 ) ) + 1 ) implies (C20 is_closed_on ( ( StepForUp (C17 , C18 , C19 , C20 , R15 , C21) ) . B4 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { C17 , C18 , C19 } \/ ( UsedIntLoc C20 ) ) ) , ( ( C20 ";" ( AddTo (C17 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { C17 , C18 , C19 } \/ ( UsedIntLoc C20 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) & C20 is_halting_on ( ( StepForUp (C17 , C18 , C19 , C20 , R15 , C21) ) . B4 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { C17 , C18 , C19 } \/ ( UsedIntLoc C20 ) ) ) , ( ( C20 ";" ( AddTo (C17 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { C17 , C18 , C19 } \/ ( UsedIntLoc C20 ) ) ) , ( intloc ( 0 ) )) ) )) ) ))))
;end;
theorem
L119: (for R1 being (State of ( SCM+FSA )) holds (for R4 being Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds (for B5 being  parahalting (Program of ( SCM+FSA )) holds  ProperForUpBody R4 , R5 , R6 , B5 , R1 , R15))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R15 being (Instruction-Sequence of ( SCM+FSA ));
let C22 being  parahalting (Program of ( SCM+FSA ));
let C23 being (Element of ( NAT ));
assume that
L120: C23 < ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 );
thus L121: C22 is_closed_on ( ( StepForUp (R4 , R5 , R6 , C22 , R15 , R1) ) . C23 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R4 , R5 , R6 } \/ ( UsedIntLoc C22 ) ) ) , ( ( C22 ";" ( AddTo (R4 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R4 , R5 , R6 } \/ ( UsedIntLoc C22 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by SCMFSA7B:18;
thus L122: thesis by SCMFSA7B:19;
end;
theorem
L123: (for R1 being (State of ( SCM+FSA )) holds (for R2 being  read-write Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R12 being  good (Program of ( SCM+FSA )) holds (for R14 being (Element of ( NAT )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds ((( ( ( StepForUp (R2 , R5 , R6 , R12 , R15 , R1) ) . R14 ) . ( intloc ( 0 ) ) ) = 1 & R12 is_closed_on ( ( StepForUp (R2 , R5 , R6 , R12 , R15 , R1) ) . R14 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R12 ) ) ) , ( ( R12 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R12 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) & R12 is_halting_on ( ( StepForUp (R2 , R5 , R6 , R12 , R15 , R1) ) . R14 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R12 ) ) ) , ( ( R12 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R12 ) ) ) , ( intloc ( 0 ) )) ) )) ) )) implies ( ( ( StepForUp (R2 , R5 , R6 , R12 , R15 , R1) ) . ( R14 + 1 ) ) . ( intloc ( 0 ) ) ) = 1))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R2 being  read-write Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R12 being  good (Program of ( SCM+FSA ));
let R14 being (Element of ( NAT ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
set D23 = R12;
assume that
L124: ( ( ( StepForUp (R2 , R5 , R6 , D23 , R15 , R1) ) . R14 ) . ( intloc ( 0 ) ) ) = 1
and
L125: (D23 is_closed_on ( ( StepForUp (R2 , R5 , R6 , D23 , R15 , R1) ) . R14 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D23 ) ) ) , ( ( D23 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D23 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) & D23 is_halting_on ( ( StepForUp (R2 , R5 , R6 , D23 , R15 , R1) ) . R14 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D23 ) ) ) , ( ( D23 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D23 ) ) ) , ( intloc ( 0 ) )) ) )) ) ));
set D24 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D23 ) ) );
set D25 = ( ( D23 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (D24 , ( intloc ( 0 ) )) ) );
set D26 = ( StepWhile>0 (D24 , D25 , R15 , ( ( R1 +* (D24 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) +* (R2 , ( R1 . R5 )) )) );
L126: D25 = ( D23 ";" ( ( AddTo (R2 , ( intloc ( 0 ) )) ) ";" ( SubFrom (D24 , ( intloc ( 0 ) )) ) ) ) by SCMFSA6A:28;
per cases ;
suppose L127: ( ( D26 . R14 ) . D24 ) <= ( 0 );

L128: ( DataPart ( D26 . ( R14 + 1 ) ) ) = ( DataPart ( D26 . R14 ) ) by L127 , SCMFSA9A:31;
thus L129: thesis by L128 , L124 , SCMFSA_M:2;
end;
suppose L130: ( ( D26 . R14 ) . D24 ) > ( 0 );

L131: (D23 is_closed_on ( Initialized ( D26 . R14 ) ) , ( R15 +* ( while>0 (D24 , D25) ) ) & D23 is_halting_on ( Initialized ( D26 . R14 ) ) , ( R15 +* ( while>0 (D24 , D25) ) )) by L124 , L125 , SFMASTR2:5;
L132: ( ( AddTo (R2 , ( intloc ( 0 ) )) ) ";" ( SubFrom (D24 , ( intloc ( 0 ) )) ) ) is_closed_on ( IExec (D23 , ( R15 +* ( while>0 (D24 , D25) ) ) , ( D26 . R14 )) ) , ( R15 +* ( while>0 (D24 , D25) ) ) by SCMFSA7B:18;
L133: (( ( AddTo (R2 , ( intloc ( 0 ) )) ) ";" ( SubFrom (D24 , ( intloc ( 0 ) )) ) ) is_halting_on ( IExec (D23 , ( R15 +* ( while>0 (D24 , D25) ) ) , ( D26 . R14 )) ) , ( R15 +* ( while>0 (D24 , D25) ) ) & D25 is_closed_on ( Initialized ( D26 . R14 ) ) , ( R15 +* ( while>0 (D24 , D25) ) )) by L132 , L126 , L131 , SCMFSA7B:19 , SFMASTR1:2;
L134: ( DataPart ( D26 . ( R14 + 1 ) ) ) = ( DataPart ( IExec (D25 , ( R15 +* ( while>0 (D24 , D25) ) ) , ( D26 . R14 )) ) ) by L133 , L124 , L126 , L130 , L131 , L132 , SCMFSA9A:32 , SFMASTR1:3;
L135: ( ( IExec (D25 , ( R15 +* ( while>0 (D24 , D25) ) ) , ( D26 . R14 )) ) . ( intloc ( 0 ) ) ) = ( ( IExec (( ( AddTo (R2 , ( intloc ( 0 ) )) ) ";" ( SubFrom (D24 , ( intloc ( 0 ) )) ) ) , ( R15 +* ( while>0 (D24 , D25) ) ) , ( IExec (D23 , ( R15 +* ( while>0 (D24 , D25) ) ) , ( D26 . R14 )) )) ) . ( intloc ( 0 ) ) ) by L126 , L131 , SFMASTR1:7
.= ( ( Exec (( SubFrom (D24 , ( intloc ( 0 ) )) ) , ( Exec (( AddTo (R2 , ( intloc ( 0 ) )) ) , ( Initialized ( IExec (D23 , ( R15 +* ( while>0 (D24 , D25) ) ) , ( D26 . R14 )) ) )) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:8
.= ( ( Exec (( AddTo (R2 , ( intloc ( 0 ) )) ) , ( Initialized ( IExec (D23 , ( R15 +* ( while>0 (D24 , D25) ) ) , ( D26 . R14 )) ) )) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:65
.= ( ( Initialized ( IExec (D23 , ( R15 +* ( while>0 (D24 , D25) ) ) , ( D26 . R14 )) ) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:64
.= 1 by SCMFSA_M:9;
thus L136: thesis by L135 , L134 , SCMFSA_M:2;
end;
end;
theorem
L138: (for R1 being (State of ( SCM+FSA )) holds (for R2 being  read-write Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R12 being  good (Program of ( SCM+FSA )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds ((( R1 . ( intloc ( 0 ) ) ) = 1 &  ProperForUpBody R2 , R5 , R6 , R12 , R1 , R15) implies (for R14 being (Element of ( NAT )) holds (R14 <= ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 ) implies (( ( ( StepForUp (R2 , R5 , R6 , R12 , R15 , R1) ) . R14 ) . ( intloc ( 0 ) ) ) = 1 & ((not R12 destroy R2) implies (( ( ( StepForUp (R2 , R5 , R6 , R12 , R15 , R1) ) . R14 ) . R2 ) = ( R14 + ( R1 . R5 ) ) & ( ( ( StepForUp (R2 , R5 , R6 , R12 , R15 , R1) ) . R14 ) . R2 ) <= ( ( R1 . R6 ) + 1 ))) & ( ( ( ( StepForUp (R2 , R5 , R6 , R12 , R15 , R1) ) . R14 ) . ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R12 ) ) ) ) + R14 ) = ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )))))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R2 being  read-write Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R12 being  good (Program of ( SCM+FSA ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
set D27 = R12;
assume that
L139: ( R1 . ( intloc ( 0 ) ) ) = 1
and
L140:  ProperForUpBody R2 , R5 , R6 , D27 , R1 , R15;
set D28 = ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 );
set D29 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D27 ) ) );
set D30 = ( StepForUp (R2 , R5 , R6 , D27 , R15 , R1) );
set D31 = ( ( D27 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (D29 , ( intloc ( 0 ) )) ) );
set D32 = ( ( R1 +* (D29 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) +* (R2 , ( R1 . R5 )) );
set D33 = R15;
set D34 = ( StepWhile>0 (D29 , D31 , D33 , D32) );
L141: D31 = ( D27 ";" ( ( AddTo (R2 , ( intloc ( 0 ) )) ) ";" ( SubFrom (D29 , ( intloc ( 0 ) )) ) ) ) by SCMFSA6A:28;
defpred S1[ Nat ] means ($1 <= D28 implies (( ( D30 . $1 ) . ( intloc ( 0 ) ) ) = 1 & ((not D27 destroy R2) implies (( ( D30 . $1 ) . R2 ) = ( $1 + ( R1 . R5 ) ) & ( ( D30 . $1 ) . R2 ) <= ( ( R1 . R6 ) + 1 ))) & ( ( ( D30 . $1 ) . D29 ) + $1 ) = D28));
L142: R2 in { R2 , R5 , R6 } by ENUMSET1:def 1;
L143: R2 in ( { R2 , R5 , R6 } \/ ( UsedIntLoc D27 ) ) by L142 , XBOOLE_0:def 3;
L144: D29 <> R2 by L143 , SCMFSA_M:25;
L145: (for R14 being (Element of ( NAT )) holds (S1[ R14 ] implies S1[ ( R14 + 1 ) ]))
proof
let R14 being (Element of ( NAT ));
assume that
L146: S1[ R14 ];
thus L147: S1[ ( R14 + 1 ) ]
proof
L148: (not D29 in ( UsedIntLoc D27 ))
proof
assume L149: (not thesis);
L150: D29 in ( { R2 , R5 , R6 } \/ ( UsedIntLoc D27 ) ) by L149 , XBOOLE_0:def 3;
thus L151: contradiction by L150 , SCMFSA_M:25;
end;
set D35 = ( R14 + 1 );
assume L152: ( R14 + 1 ) <= D28;
L153: R14 < ( R14 + 1 ) by XREAL_1:29;
L154: ( ( D34 . R14 ) . D29 ) > ( 0 ) by L153 , L146 , L152 , XREAL_1:8 , XXREAL_0:2;
L155: R14 < D28 by L152 , L153 , XXREAL_0:2;
L156: D27 is_closed_on ( D30 . R14 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D27 ) ) ) , ( ( D27 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D27 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L155 , L140 , L117;
L157: D27 is_closed_on ( Initialized ( D34 . R14 ) ) , ( R15 +* ( while>0 (D29 , D31) ) ) by L156 , L146 , L152 , L153 , SFMASTR2:4 , XXREAL_0:2;
L158: D27 is_halting_on ( D30 . R14 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D27 ) ) ) , ( ( D27 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D27 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L140 , L155 , L117;
L159: D27 is_halting_on ( Initialized ( D34 . R14 ) ) , ( R15 +* ( while>0 (D29 , D31) ) ) by L158 , L146 , L152 , L153 , L156 , SFMASTR2:5 , XXREAL_0:2;
thus L160: ( ( D30 . D35 ) . ( intloc ( 0 ) ) ) = 1 by L146 , L152 , L153 , L156 , L158 , L123 , XXREAL_0:2;
L161: ( ( AddTo (R2 , ( intloc ( 0 ) )) ) ";" ( SubFrom (D29 , ( intloc ( 0 ) )) ) ) is_closed_on ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) , ( R15 +* ( while>0 (D29 , D31) ) ) by SCMFSA7B:18;
L162: D31 is_closed_on ( Initialized ( D34 . R14 ) ) , ( R15 +* ( while>0 (D29 , D31) ) ) by L161 , L141 , L157 , L159 , SFMASTR1:2;
L163: ( ( AddTo (R2 , ( intloc ( 0 ) )) ) ";" ( SubFrom (D29 , ( intloc ( 0 ) )) ) ) is_halting_on ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) , ( R15 +* ( while>0 (D29 , D31) ) ) by SCMFSA7B:19;
L164: D31 is_halting_on ( Initialized ( D34 . R14 ) ) , ( R15 +* ( while>0 (D29 , D31) ) ) by L163 , L141 , L157 , L159 , L161 , SFMASTR1:3;
L165: ( DataPart ( D34 . ( R14 + 1 ) ) ) = ( DataPart ( IExec (D31 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) ) by L164 , L146 , L152 , L153 , L154 , L162 , SCMFSA9A:32 , XXREAL_0:2;
thus L166:now
assume L167: (not D27 destroy R2);
L168: ( ( IExec (D31 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) . R2 ) = ( ( IExec (( ( AddTo (R2 , ( intloc ( 0 ) )) ) ";" ( SubFrom (D29 , ( intloc ( 0 ) )) ) ) , ( R15 +* ( while>0 (D29 , D31) ) ) , ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) )) ) . R2 ) by L141 , L157 , L159 , SFMASTR1:7
.= ( ( Exec (( SubFrom (D29 , ( intloc ( 0 ) )) ) , ( Exec (( AddTo (R2 , ( intloc ( 0 ) )) ) , ( Initialized ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) )) )) ) . R2 ) by SCMFSA6C:8
.= ( ( Exec (( AddTo (R2 , ( intloc ( 0 ) )) ) , ( Initialized ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) )) ) . R2 ) by L144 , SCMFSA_2:65
.= ( ( ( Initialized ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) ) . R2 ) + ( ( Initialized ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) ) . ( intloc ( 0 ) ) ) ) by SCMFSA_2:64
.= ( ( ( Initialized ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) ) . R2 ) + 1 ) by SCMFSA_M:9
.= ( ( ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) . R2 ) + 1 ) by SCMFSA_M:37
.= ( ( ( Initialized ( D34 . R14 ) ) . R2 ) + 1 ) by L157 , L159 , L167 , L1
.= ( ( ( D34 . R14 ) . R2 ) + 1 ) by SCMFSA_M:37;
thus L169: ( ( D30 . D35 ) . R2 ) = ( D35 + ( R1 . R5 ) ) by L168 , L146 , L152 , L153 , L165 , L167 , SCMFSA_M:2 , XXREAL_0:2;
L170: ( D35 + ( R1 . R5 ) ) <= ( ( ( ( R1 . R6 ) + 1 ) - ( R1 . R5 ) ) + ( R1 . R5 ) ) by L152 , XREAL_1:6;
thus L171: ( ( D30 . D35 ) . R2 ) <= ( ( R1 . R6 ) + 1 ) by L170 , L146 , L152 , L153 , L165 , L167 , L168 , SCMFSA_M:2 , XXREAL_0:2;
end;
L172: ( ( IExec (D31 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) . D29 ) = ( ( IExec (( ( AddTo (R2 , ( intloc ( 0 ) )) ) ";" ( SubFrom (D29 , ( intloc ( 0 ) )) ) ) , ( R15 +* ( while>0 (D29 , D31) ) ) , ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) )) ) . D29 ) by L141 , L157 , L159 , SFMASTR1:7
.= ( ( Exec (( SubFrom (D29 , ( intloc ( 0 ) )) ) , ( Exec (( AddTo (R2 , ( intloc ( 0 ) )) ) , ( Initialized ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) )) )) ) . D29 ) by SCMFSA6C:8
.= ( ( ( Exec (( AddTo (R2 , ( intloc ( 0 ) )) ) , ( Initialized ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) )) ) . D29 ) - ( ( Exec (( AddTo (R2 , ( intloc ( 0 ) )) ) , ( Initialized ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) )) ) . ( intloc ( 0 ) ) ) ) by SCMFSA_2:65
.= ( ( ( Exec (( AddTo (R2 , ( intloc ( 0 ) )) ) , ( Initialized ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) )) ) . D29 ) - ( ( Initialized ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) ) . ( intloc ( 0 ) ) ) ) by SCMFSA_2:64
.= ( ( ( Exec (( AddTo (R2 , ( intloc ( 0 ) )) ) , ( Initialized ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) )) ) . D29 ) - 1 ) by SCMFSA_M:9
.= ( ( ( Initialized ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) ) . D29 ) - 1 ) by L144 , SCMFSA_2:64
.= ( ( ( IExec (D27 , ( R15 +* ( while>0 (D29 , D31) ) ) , ( D34 . R14 )) ) . D29 ) - 1 ) by SCMFSA_M:37
.= ( ( ( Initialized ( D34 . R14 ) ) . D29 ) - 1 ) by L157 , L159 , L148 , L1 , SFMASTR1:1
.= ( ( ( D34 . R14 ) . D29 ) - 1 ) by SCMFSA_M:37;
thus L173: ( ( ( D30 . D35 ) . D29 ) + D35 ) = ( ( ( ( D34 . R14 ) . D29 ) - 1 ) + D35 ) by L172 , L165 , SCMFSA_M:2
.= D28 by L146 , L152 , L153 , XXREAL_0:2;
end;

end;
L148: R2 in ( dom ( R1 +* (D29 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) ) by SCMFSA_2:42;
L149: D29 in ( dom R1 ) by SCMFSA_2:42;
L150: S1[ ( 0 ) ]
proof
assume L151: ( 0 ) <= D28;
L152: ( D34 . ( 0 ) ) = D32 by SCMFSA_9:def 5;
thus L153: ( ( D30 . ( 0 ) ) . ( intloc ( 0 ) ) ) = ( ( R1 +* (D29 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) . ( intloc ( 0 ) ) ) by L152 , FUNCT_7:32
.= 1 by L139 , FUNCT_7:32;
thus L154:now
assume L155: (not D27 destroy R2);
thus L156: ( ( D30 . ( 0 ) ) . R2 ) = ( ( 0 ) + ( R1 . R5 ) ) by L148 , L152 , FUNCT_7:31;
L157: ( ( 0 ) + ( R1 . R5 ) ) <= ( ( ( ( R1 . R6 ) + 1 ) - ( R1 . R5 ) ) + ( R1 . R5 ) ) by L151 , XREAL_1:6;
thus L158: ( ( D30 . ( 0 ) ) . R2 ) <= ( ( R1 . R6 ) + 1 ) by L157 , L148 , L152 , FUNCT_7:31;
end;
thus L159: ( ( ( D30 . ( 0 ) ) . D29 ) + ( 0 ) ) = ( ( R1 +* (D29 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) . D29 ) by L144 , L152 , FUNCT_7:32
.= D28 by L149 , FUNCT_7:31;
end;
thus L160: (for R14 being (Element of ( NAT )) holds S1[ R14 ]) from NAT_1:sch 1(L150 , L145);
end;
theorem
L161: (for R1 being (State of ( SCM+FSA )) holds (for R2 being  read-write Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R12 being  good (Program of ( SCM+FSA )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds ((( R1 . ( intloc ( 0 ) ) ) = 1 &  ProperForUpBody R2 , R5 , R6 , R12 , R1 , R15) implies (for R14 being (Element of ( NAT )) holds (( ( ( StepForUp (R2 , R5 , R6 , R12 , R15 , R1) ) . R14 ) . ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R12 ) ) ) ) > ( 0 ) iff R14 < ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 ))))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R2 being  read-write Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R12 being  good (Program of ( SCM+FSA ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
set D36 = R12;
set D37 = ( StepForUp (R2 , R5 , R6 , D36 , R15 , R1) );
set D38 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D36 ) ) );
set D39 = ( ( R1 +* (D38 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) +* (R2 , ( R1 . R5 )) );
set D40 = R15;
set D41 = ( ( D36 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (D38 , ( intloc ( 0 ) )) ) );
set D42 = ( StepWhile>0 (D38 , D41 , D40 , D39) );
set D43 = ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 );
defpred S2[ Nat ] means (( ( D37 . $1 ) . D38 ) > ( 0 ) implies $1 < D43);
assume L162: (( R1 . ( intloc ( 0 ) ) ) = 1 &  ProperForUpBody R2 , R5 , R6 , D36 , R1 , R15);
L163: (for R14 being (Element of ( NAT )) holds (S2[ R14 ] implies S2[ ( R14 + 1 ) ]))
proof
let R14 being (Element of ( NAT ));
assume that
L164: S2[ R14 ]
and
L165: ( ( D37 . ( R14 + 1 ) ) . D38 ) > ( 0 );
L166: ( ( D37 . R14 ) . D38 ) > ( 0 )
proof
assume L167: ( ( D37 . R14 ) . D38 ) <= ( 0 );
L168: ( DataPart ( D37 . ( R14 + 1 ) ) ) = ( DataPart ( D37 . R14 ) ) by L167 , SCMFSA9A:31;
thus L169: contradiction by L168 , L165 , L167 , SCMFSA_M:2;
end;
reconsider D44 = D43 as (Element of ( NAT )) by L166 , L164 , INT_1:3;
assume L170: ( R14 + 1 ) >= ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 );
L171: ( ( ( D37 . ( R14 + 1 ) ) . D38 ) + ( R14 + 1 ) ) > ( ( 0 ) + D44 ) by L170 , L165 , XREAL_1:8;
L172: ( R14 + 1 ) <= D44 by L164 , L166 , NAT_1:13;
thus L173: contradiction by L172 , L162 , L171 , L138;
end;
let R14 being (Element of ( NAT ));
L174: R2 in { R2 , R5 , R6 } by ENUMSET1:def 1;
L175: R2 in ( { R2 , R5 , R6 } \/ ( UsedIntLoc D36 ) ) by L174 , XBOOLE_0:def 3;
L176: D38 <> R2 by L175 , SCMFSA_M:25;
L177: D38 in ( dom R1 ) by SCMFSA_2:42;
L178: S2[ ( 0 ) ]
proof
L179: ( D42 . ( 0 ) ) = D39 by SCMFSA_9:def 5;
L180: ( ( D37 . ( 0 ) ) . D38 ) = ( ( R1 +* (D38 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) . D38 ) by L179 , L176 , FUNCT_7:32
.= D43 by L177 , FUNCT_7:31;
assume L181: ( ( D37 . ( 0 ) ) . D38 ) > ( 0 );
thus L182: thesis by L181 , L180;
end;
L183: (for R14 being (Element of ( NAT )) holds S2[ R14 ]) from NAT_1:sch 1(L178 , L163);
thus L184: S2[ R14 ] by L183;
assume L185: R14 < D43;
L186: ( R14 - R14 ) < ( D43 - R14 ) by L185 , XREAL_1:9;
L187: ( ( ( D37 . R14 ) . D38 ) + R14 ) = D43 by L162 , L185 , L138;
thus L188: thesis by L187 , L186;
end;
theorem
L189: (for R1 being (State of ( SCM+FSA )) holds (for R2 being  read-write Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R12 being  good (Program of ( SCM+FSA )) holds (for R14 being (Element of ( NAT )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds ((( R1 . ( intloc ( 0 ) ) ) = 1 &  ProperForUpBody R2 , R5 , R6 , R12 , R1 , R15 & R14 < ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) implies ( ( ( StepForUp (R2 , R5 , R6 , R12 , R15 , R1) ) . ( R14 + 1 ) ) | ( ( { R2 , R5 , R6 } \/ ( UsedIntLoc R12 ) ) \/ ( FinSeq-Locations ) ) ) = ( ( IExec (( R12 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R12 ) ) ) , ( ( R12 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R12 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( ( StepForUp (R2 , R5 , R6 , R12 , R15 , R1) ) . R14 )) ) | ( ( { R2 , R5 , R6 } \/ ( UsedIntLoc R12 ) ) \/ ( FinSeq-Locations ) ) )))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R2 being  read-write Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R12 being  good (Program of ( SCM+FSA ));
let R14 being (Element of ( NAT ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L190: ( R1 . ( intloc ( 0 ) ) ) = 1
and
L191:  ProperForUpBody R2 , R5 , R6 , R12 , R1 , R15
and
L192: R14 < ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 );
set D45 = ( FinSeq-Locations );
set D46 = R12;
set D47 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D46 ) ) );
set D48 = ( StepForUp (R2 , R5 , R6 , D46 , R15 , R1) );
set D49 = ( ( D46 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (D47 , ( intloc ( 0 ) )) ) );
set D50 = ( ( R1 +* (D47 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) +* (R2 , ( R1 . R5 )) );
set D51 = R15;
set D52 = ( StepWhile>0 (D47 , D49 , D51 , D50) );
L193: D48 = D52;
L194: ( ( D52 . R14 ) . ( intloc ( 0 ) ) ) = 1 by L193 , L190 , L191 , L192 , L138;
set D53 = ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 );
L195: ( ( ( D48 . R14 ) . D47 ) + R14 ) = D53 by L190 , L191 , L192 , L138;
L196: ( ( D52 . R14 ) . D47 ) > ( 0 )
proof
assume L197: ( ( D52 . R14 ) . D47 ) <= ( 0 );
L198: ( ( ( D52 . R14 ) . D47 ) + R14 ) < ( ( 0 ) + D53 ) by L197 , L192 , XREAL_1:8;
thus L199: contradiction by L198 , L195;
end;
set D54 = ( IExec (D49 , ( R15 +* ( while>0 (D47 , D49) ) ) , ( D52 . R14 )) );
set D55 = ( D46 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) );
set D56 = ( { R2 , R5 , R6 } \/ ( UsedIntLoc D46 ) );
set D57 = ( IExec (D55 , ( R15 +* ( while>0 (D47 , D49) ) ) , ( D52 . R14 )) );
L200: ( Macro ( AddTo (R2 , ( intloc ( 0 ) )) ) ) is_closed_on ( IExec (D46 , ( R15 +* ( while>0 (D47 , D49) ) ) , ( D52 . R14 )) ) , ( R15 +* ( while>0 (D47 , D49) ) ) by SCMFSA7B:18;
L201: D46 is_closed_on ( D48 . R14 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D46 ) ) ) , ( ( D46 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D46 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L191 , L192 , L117;
L202: D46 is_closed_on ( Initialized ( D52 . R14 ) ) , ( R15 +* ( while>0 (D47 , D49) ) ) by L201 , L194 , SFMASTR2:4;
L203: D46 is_halting_on ( D48 . R14 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D46 ) ) ) , ( ( D46 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D46 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L191 , L192 , L117;
L204: D46 is_halting_on ( Initialized ( D52 . R14 ) ) , ( R15 +* ( while>0 (D47 , D49) ) ) by L203 , L201 , L194 , SFMASTR2:5;
L205: ( Macro ( AddTo (R2 , ( intloc ( 0 ) )) ) ) is_halting_on ( IExec (D46 , ( R15 +* ( while>0 (D47 , D49) ) ) , ( D52 . R14 )) ) , ( R15 +* ( while>0 (D47 , D49) ) ) by SCMFSA7B:19;
L206: D55 is_halting_on ( Initialized ( D52 . R14 ) ) , ( R15 +* ( while>0 (D47 , D49) ) ) by L205 , L202 , L204 , L200 , SFMASTR1:3;
L207:
now
thus L208:now
let C24 being Int-Location;
assume L209: C24 in D56;
L210: C24 <> D47 by L209 , SCMFSA_M:25;
L211: ( D54 . C24 ) = ( ( Exec (( SubFrom (D47 , ( intloc ( 0 ) )) ) , D57) ) . C24 ) by L202 , L204 , L200 , L206 , SFMASTR1:2 , SFMASTR1:11
.= ( D57 . C24 ) by L210 , SCMFSA_2:65;
thus L212: ( D57 . C24 ) = ( D54 . C24 ) by L211;
end;
let C25 being FinSeq-Location;
L213: ( D54 . C25 ) = ( ( Exec (( SubFrom (D47 , ( intloc ( 0 ) )) ) , D57) ) . C25 ) by L202 , L204 , L200 , L206 , SFMASTR1:2 , SFMASTR1:12
.= ( D57 . C25 ) by SCMFSA_2:65;
thus L214: ( D57 . C25 ) = ( D54 . C25 ) by L213;
end;
L215: ( D57 | ( D56 \/ D45 ) ) = ( ( IExec (D49 , ( R15 +* ( while>0 (D47 , D49) ) ) , ( D52 . R14 )) ) | ( D56 \/ D45 ) ) by L207 , SCMFSA_M:28;
L216: (D49 = ( D46 ";" ( ( AddTo (R2 , ( intloc ( 0 ) )) ) ";" ( SubFrom (D47 , ( intloc ( 0 ) )) ) ) ) & ( ( AddTo (R2 , ( intloc ( 0 ) )) ) ";" ( SubFrom (D47 , ( intloc ( 0 ) )) ) ) is_closed_on ( IExec (D46 , ( R15 +* ( while>0 (D47 , D49) ) ) , ( D52 . R14 )) ) , ( R15 +* ( while>0 (D47 , D49) ) )) by SCMFSA6A:28 , SCMFSA7B:18;
L217: (( ( AddTo (R2 , ( intloc ( 0 ) )) ) ";" ( SubFrom (D47 , ( intloc ( 0 ) )) ) ) is_halting_on ( IExec (D46 , ( R15 +* ( while>0 (D47 , D49) ) ) , ( D52 . R14 )) ) , ( R15 +* ( while>0 (D47 , D49) ) ) & D49 is_closed_on ( Initialized ( D52 . R14 ) ) , ( R15 +* ( while>0 (D47 , D49) ) )) by L216 , L202 , L204 , SCMFSA7B:19 , SFMASTR1:2;
L218: ( DataPart ( D52 . ( R14 + 1 ) ) ) = ( DataPart ( IExec (D49 , ( R15 +* ( while>0 (D47 , D49) ) ) , ( D52 . R14 )) ) ) by L217 , L194 , L196 , L202 , L204 , L216 , SCMFSA9A:32 , SFMASTR1:3;
thus L219: thesis by L218 , L215 , RELAT_1:153 , SCMFSA_2:100 , XBOOLE_1:9;
end;
definition
let C26 , C27 , C28 being Int-Location;
let C29 being (Program of ( SCM+FSA ));
func for-up (C26 , C27 , C28 , C29) -> (Program of ( SCM+FSA )) equals 
( ( ( ( ( ( 1 -stRWNotIn ( { C26 , C27 , C28 } \/ ( UsedIntLoc C29 ) ) ) := C28 ) ";" ( SubFrom (( 1 -stRWNotIn ( { C26 , C27 , C28 } \/ ( UsedIntLoc C29 ) ) ) , C27) ) ) ";" ( AddTo (( 1 -stRWNotIn ( { C26 , C27 , C28 } \/ ( UsedIntLoc C29 ) ) ) , ( intloc ( 0 ) )) ) ) ";" ( C26 := C27 ) ) ";" ( while>0 (( 1 -stRWNotIn ( { C26 , C27 , C28 } \/ ( UsedIntLoc C29 ) ) ) , ( ( C29 ";" ( AddTo (C26 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { C26 , C27 , C28 } \/ ( UsedIntLoc C29 ) ) ) , ( intloc ( 0 ) )) ) )) ) );
coherence;
end;
theorem
L221: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds ( { R4 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) c= ( UsedIntLoc ( for-up (R4 , R5 , R6 , R10) ) )))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
set D58 = ( 1 -stRWNotIn ( { R4 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) );
set D59 = ( D58 := R6 );
set D60 = ( SubFrom (D58 , R5) );
set D61 = ( AddTo (D58 , ( intloc ( 0 ) )) );
set D62 = ( R4 := R5 );
set D63 = ( while>0 (D58 , ( ( R10 ";" ( AddTo (R4 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (D58 , ( intloc ( 0 ) )) ) )) );
L222: ( UsedIntLoc ( ( ( D59 ";" D60 ) ";" D61 ) ";" D62 ) ) = ( ( UsedIntLoc ( ( D59 ";" D60 ) ";" D61 ) ) \/ ( UsedIntLoc D62 ) ) by SF_MASTR:30
.= ( ( ( UsedIntLoc ( D59 ";" D60 ) ) \/ ( UsedIntLoc D61 ) ) \/ ( UsedIntLoc D62 ) ) by SF_MASTR:30
.= ( ( ( ( UsedIntLoc D59 ) \/ ( UsedIntLoc D60 ) ) \/ ( UsedIntLoc D61 ) ) \/ ( UsedIntLoc D62 ) ) by SF_MASTR:31
.= ( ( ( { D58 , R6 } \/ ( UsedIntLoc D60 ) ) \/ ( UsedIntLoc D61 ) ) \/ ( UsedIntLoc D62 ) ) by SF_MASTR:14
.= ( ( ( { D58 , R6 } \/ { D58 , R5 } ) \/ ( UsedIntLoc D61 ) ) \/ ( UsedIntLoc D62 ) ) by SF_MASTR:14
.= ( ( ( { D58 , R6 } \/ { D58 , R5 } ) \/ { D58 , ( intloc ( 0 ) ) } ) \/ ( UsedIntLoc D62 ) ) by SF_MASTR:14
.= ( ( ( { D58 , R6 } \/ { D58 , R5 } ) \/ { D58 , ( intloc ( 0 ) ) } ) \/ { R4 , R5 } ) by SF_MASTR:14;
let C30 being set;
L223: ( UsedIntLoc D63 ) = ( { D58 } \/ ( UsedIntLoc ( ( R10 ";" ( AddTo (R4 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (D58 , ( intloc ( 0 ) )) ) ) ) ) by SCMFSA9A:24
.= ( { D58 } \/ ( ( UsedIntLoc ( R10 ";" ( AddTo (R4 , ( intloc ( 0 ) )) ) ) ) \/ ( UsedIntLoc ( SubFrom (D58 , ( intloc ( 0 ) )) ) ) ) ) by SF_MASTR:30
.= ( { D58 } \/ ( ( ( UsedIntLoc R10 ) \/ ( UsedIntLoc ( AddTo (R4 , ( intloc ( 0 ) )) ) ) ) \/ ( UsedIntLoc ( SubFrom (D58 , ( intloc ( 0 ) )) ) ) ) ) by SF_MASTR:30
.= ( { D58 } \/ ( ( UsedIntLoc R10 ) \/ ( ( UsedIntLoc ( AddTo (R4 , ( intloc ( 0 ) )) ) ) \/ ( UsedIntLoc ( SubFrom (D58 , ( intloc ( 0 ) )) ) ) ) ) ) by XBOOLE_1:4
.= ( ( UsedIntLoc R10 ) \/ ( { D58 } \/ ( ( UsedIntLoc ( AddTo (R4 , ( intloc ( 0 ) )) ) ) \/ ( UsedIntLoc ( SubFrom (D58 , ( intloc ( 0 ) )) ) ) ) ) ) by XBOOLE_1:4;
assume L224: C30 in ( { R4 , R5 , R6 } \/ ( UsedIntLoc R10 ) );
L225: (C30 in { R4 , R5 , R6 } or C30 in ( UsedIntLoc R10 )) by L224 , XBOOLE_0:def 3;
L226: ( UsedIntLoc ( for-up (R4 , R5 , R6 , R10) ) ) = ( ( UsedIntLoc ( ( ( D59 ";" D60 ) ";" D61 ) ";" D62 ) ) \/ ( UsedIntLoc D63 ) ) by SF_MASTR:27;
per cases  by L225 , ENUMSET1:def 1;
suppose L227: C30 = R4;

L228: C30 in { R4 , R5 } by L227 , TARSKI:def 2;
L229: C30 in ( UsedIntLoc ( ( ( D59 ";" D60 ) ";" D61 ) ";" D62 ) ) by L228 , L222 , XBOOLE_0:def 3;
thus L230: thesis by L229 , L226 , XBOOLE_0:def 3;
end;
suppose L231: C30 = R5;

L232: C30 in { R4 , R5 } by L231 , TARSKI:def 2;
L233: C30 in ( UsedIntLoc ( ( ( D59 ";" D60 ) ";" D61 ) ";" D62 ) ) by L232 , L222 , XBOOLE_0:def 3;
thus L234: thesis by L233 , L226 , XBOOLE_0:def 3;
end;
suppose L235: C30 = R6;

L236: C30 in { D58 , R6 } by L235 , TARSKI:def 2;
L237: C30 in ( { D58 , R6 } \/ { D58 , R5 } ) by L236 , XBOOLE_0:def 3;
L238: C30 in ( ( { D58 , R6 } \/ { D58 , R5 } ) \/ { D58 , ( intloc ( 0 ) ) } ) by L237 , XBOOLE_0:def 3;
L239: C30 in ( ( ( { D58 , R6 } \/ { D58 , R5 } ) \/ { D58 , ( intloc ( 0 ) ) } ) \/ { R4 , R5 } ) by L238 , XBOOLE_0:def 3;
thus L240: thesis by L239 , L222 , L226 , XBOOLE_0:def 3;
end;
suppose L241: C30 in ( UsedIntLoc R10 );

L242: C30 in ( UsedIntLoc D63 ) by L241 , L223 , XBOOLE_0:def 3;
thus L243: thesis by L242 , L226 , XBOOLE_0:def 3;
end;
end;
registration
let C31 being  read-write Int-Location;
let C32 , C33 being Int-Location;
let C34 being  good (Program of ( SCM+FSA ));
cluster ( for-up (C31 , C32 , C33 , C34) ) ->  good;
coherence;
end;
theorem
L246: (for R2 being  read-write Int-Location holds (for R4 being Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds ((R2 <> R4 & R4 <> ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) ) & (not R10 destroy R4)) implies (not ( for-up (R2 , R5 , R6 , R10) ) destroy R4)))))))
proof
let R2 being  read-write Int-Location;
let R4 being Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
assume that
L247: R2 <> R4
and
L248: R4 <> ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) )
and
L249: (not R10 destroy R4);
set D64 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) );
set D65 = ( AddTo (D64 , ( intloc ( 0 ) )) );
L250: (not D65 destroy R4) by L248 , SCMFSA7B:7;
set D66 = ( R2 := R5 );
set D67 = ( SubFrom (D64 , R5) );
set D68 = ( D64 := R6 );
set D69 = ( ( ( D68 ";" D67 ) ";" D65 ) ";" D66 );
L251: ((not D68 destroy R4) & (not D67 destroy R4)) by L248 , SCMFSA7B:6 , SCMFSA7B:8;
L252: (not ( ( D68 ";" D67 ) ";" D65 ) destroy R4) by L251 , L250 , SCMFSA8C:54 , SCMFSA8C:55;
L253: (not D69 destroy R4) by L252 , L247 , SCMFSA7B:6 , SCMFSA8C:54;
set D70 = ( ( R10 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (D64 , ( intloc ( 0 ) )) ) );
set D71 = ( while>0 (D64 , D70) );
L254: (not ( R10 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) destroy R4) by L247 , L249 , SCMFSA7B:7 , SCMFSA8C:54;
L255: (not D70 destroy R4) by L254 , L248 , SCMFSA7B:8 , SCMFSA8C:54;
L256: (not D71 destroy R4) by L255 , L39;
thus L257: thesis by L256 , L253 , SCMFSA8C:52;
end;
theorem
L258: (for R1 being (State of ( SCM+FSA )) holds (for R2 being  read-write Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds ((( R1 . ( intloc ( 0 ) ) ) = 1 & ( R1 . R5 ) > ( R1 . R6 )) implies ((for R8 being Int-Location holds ((R8 <> R2 & R8 in ( { R5 , R6 } \/ ( UsedIntLoc R10 ) )) implies ( ( IExec (( for-up (R2 , R5 , R6 , R10) ) , R15 , R1) ) . R8 ) = ( R1 . R8 ))) & (for R9 being FinSeq-Location holds ( ( IExec (( for-up (R2 , R5 , R6 , R10) ) , R15 , R1) ) . R9 ) = ( R1 . R9 ))))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R2 being  read-write Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L259: ( R1 . ( intloc ( 0 ) ) ) = 1
and
L260: ( R1 . R5 ) > ( R1 . R6 );
L261: (R6 = ( intloc ( 0 ) ) or R6 is  read-write) by SCMFSA_M:def 2;
L262: ( ( Initialized R1 ) . R6 ) = ( R1 . R6 ) by L261 , L259 , SCMFSA_M:9 , SCMFSA_M:37;
set D72 = ( for-up (R2 , R5 , R6 , R10) );
set D73 = ( R2 := R5 );
set D74 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) );
set D75 = ( D74 := R6 );
set D76 = ( SubFrom (D74 , R5) );
set D77 = ( AddTo (D74 , ( intloc ( 0 ) )) );
set D78 = ( ( R10 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (D74 , ( intloc ( 0 ) )) ) );
set D79 = ( while>0 (D74 , D78) );
set D80 = ( ( ( D75 ";" D76 ) ";" D77 ) ";" D73 );
set D81 = ( IExec (D80 , R15 , R1) );
set D82 = R15;
set D83 = ( ( R1 +* (D74 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) +* (R2 , ( R1 . R5 )) );
L263: ( ( IExec (( D75 ";" D76 ) , R15 , R1) ) . ( intloc ( 0 ) ) ) = ( ( Exec (D76 , ( Exec (D75 , ( Initialized R1 )) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:8
.= ( ( Exec (D75 , ( Initialized R1 )) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:65
.= ( ( Initialized R1 ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= 1 by SCMFSA_M:9;
L264: (R5 = ( intloc ( 0 ) ) or R5 is  read-write) by SCMFSA_M:def 2;
L265: ( ( Initialized R1 ) . R5 ) = ( R1 . R5 ) by L264 , L259 , SCMFSA_M:9 , SCMFSA_M:37;
L266: ( D81 . ( intloc ( 0 ) ) ) = ( ( Exec (D73 , ( IExec (( ( D75 ";" D76 ) ";" D77 ) , R15 , R1) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:6
.= ( ( IExec (( ( D75 ";" D76 ) ";" D77 ) , R15 , R1) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= ( ( Exec (D77 , ( IExec (( D75 ";" D76 ) , R15 , R1) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:6
.= 1 by L263 , SCMFSA_2:64;
L267: ( ( R1 . R5 ) - ( R1 . R5 ) ) > ( ( R1 . R6 ) - ( R1 . R5 ) ) by L260 , XREAL_1:9;
L268: ( ( R1 . R6 ) - ( R1 . R5 ) ) <= ( - 1 ) by L267 , INT_1:8;
L269: ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 ) <= ( ( - 1 ) + 1 ) by L268 , XREAL_1:6;
set D84 = ( IExec (D72 , R15 , R1) );
L270: R2 in { R2 , R5 , R6 } by ENUMSET1:def 1;
L271: R2 in ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) by L270 , XBOOLE_0:def 3;
L272: R2 <> D74 by L271 , SCMFSA_M:25;
L273: R5 in { R2 , R5 , R6 } by ENUMSET1:def 1;
L274: R5 in ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) ) by L273 , XBOOLE_0:def 3;
L275: R5 <> D74 by L274 , SCMFSA_M:25;
L276: ( D81 . D74 ) = ( ( Exec (D73 , ( IExec (( ( D75 ";" D76 ) ";" D77 ) , R15 , R1) )) ) . D74 ) by SCMFSA6C:6
.= ( ( IExec (( ( D75 ";" D76 ) ";" D77 ) , R15 , R1) ) . D74 ) by L272 , SCMFSA_2:63
.= ( ( Exec (D77 , ( IExec (( D75 ";" D76 ) , R15 , R1) )) ) . D74 ) by SCMFSA6C:6
.= ( ( ( IExec (( D75 ";" D76 ) , R15 , R1) ) . D74 ) + 1 ) by L263 , SCMFSA_2:64
.= ( ( ( Exec (D76 , ( Exec (D75 , ( Initialized R1 )) )) ) . D74 ) + 1 ) by SCMFSA6C:8
.= ( ( ( ( Exec (D75 , ( Initialized R1 )) ) . D74 ) - ( ( Exec (D75 , ( Initialized R1 )) ) . R5 ) ) + 1 ) by SCMFSA_2:65
.= ( ( ( ( Initialized R1 ) . R6 ) - ( ( Exec (D75 , ( Initialized R1 )) ) . R5 ) ) + 1 ) by SCMFSA_2:63
.= ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 ) by L275 , L262 , L265 , SCMFSA_2:63;
L277: (D79 is_halting_on D81 , D82 & D79 is_closed_on D81 , D82) by L276 , L269 , SCMFSA_9:38;
L278: ( DataPart ( IExec (D72 , R15 , R1) ) ) = ( DataPart ( IExec (D79 , D82 , D81) ) ) by L277 , SFMASTR1:9
.= ( DataPart D81 ) by L276 , L269 , L266 , SCMFSA9A:35
.= ( DataPart D83 ) by L259 , L84;
thus L279:now
let C35 being Int-Location;
assume that
L280: C35 <> R2
and
L281: C35 in ( { R5 , R6 } \/ ( UsedIntLoc R10 ) );
L282: C35 in ( { R2 , R5 , R6 } \/ ( UsedIntLoc R10 ) )
proof
per cases  by L281 , XBOOLE_0:def 3;
suppose L283: C35 in { R5 , R6 };

L284: (C35 = R5 or C35 = R6) by L283 , TARSKI:def 2;
L285: C35 in { R2 , R5 , R6 } by L284 , ENUMSET1:def 1;
thus L286: thesis by L285 , XBOOLE_0:def 3;
end;
suppose L287: C35 in ( UsedIntLoc R10 );

thus L288: thesis by L287 , XBOOLE_0:def 3;
end;
end;
L290: C35 <> D74 by L282 , SCMFSA_M:25;
thus L291: ( D84 . C35 ) = ( D83 . C35 ) by L278 , SCMFSA_M:2
.= ( ( R1 +* (D74 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) . C35 ) by L280 , FUNCT_7:32
.= ( R1 . C35 ) by L290 , FUNCT_7:32;
end;
let C36 being FinSeq-Location;
thus L292: ( D84 . C36 ) = ( D83 . C36 ) by L278 , SCMFSA_M:2
.= ( ( R1 +* (D74 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) . C36 ) by FUNCT_7:32 , SCMFSA_2:58
.= ( R1 . C36 ) by FUNCT_7:32 , SCMFSA_2:58;
end;
L293:
now
let R1 being (State of ( SCM+FSA ));
let R2 being  read-write Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R15 being (Instruction-Sequence of ( SCM+FSA ));
let C37 being  good (Program of ( SCM+FSA ));
assume that
L294: ( R1 . ( intloc ( 0 ) ) ) = 1
and
L295: ( ProperForUpBody R2 , R5 , R6 , C37 , R1 , R15 or C37 is  parahalting);
L296:  ProperForUpBody R2 , R5 , R6 , C37 , R1 , R15 by L295 , L119;
set D85 = ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 );
set D86 = ( StepForUp (R2 , R5 , R6 , C37 , R15 , R1) );
set D87 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) );
set D88 = ( ( C37 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (D87 , ( intloc ( 0 ) )) ) );
set D89 = ( ( R1 +* (D87 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) +* (R2 , ( R1 . R5 )) );
set D90 = R15;
set D91 = ( ( AddTo (R2 , ( intloc ( 0 ) )) ) ";" ( SubFrom (D87 , ( intloc ( 0 ) )) ) );
set D92 = ( StepWhile>0 (D87 , D88 , D90 , D89) );
L297: D86 = D92;
L298: D88 = ( C37 ";" ( ( AddTo (R2 , ( intloc ( 0 ) )) ) ";" ( SubFrom (D87 , ( intloc ( 0 ) )) ) ) ) by SCMFSA6A:28;
L299:  ProperBodyWhile>0 D87 , D88 , D89 , D90
proof
let C38 being (Element of ( NAT ));
L300: D91 is_closed_on ( IExec (C37 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( ( C37 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D86 . C38 )) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( ( C37 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by SCMFSA7B:18;
assume L301: ( ( ( StepWhile>0 (D87 , D88 , D90 , D89) ) . C38 ) . D87 ) > ( 0 );
L302: C38 < D85 by L301 , L294 , L296 , L297 , L161;
L303: C37 is_closed_on ( D86 . C38 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( ( C37 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L302 , L296 , L117;
L304: ( ( D86 . C38 ) . ( intloc ( 0 ) ) ) = 1 by L294 , L296 , L302 , L138;
L305: C37 is_halting_on ( D86 . C38 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( ( C37 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L296 , L302 , L117;
L306: C37 is_halting_on ( Initialized ( D86 . C38 ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( ( C37 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L305 , L304 , L303 , SFMASTR2:5;
L307: C37 is_closed_on ( Initialized ( D86 . C38 ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( ( C37 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L304 , L303 , SFMASTR2:4;
L308: D88 is_closed_on ( Initialized ( D86 . C38 ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( ( C37 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L307 , L298 , L306 , L300 , SFMASTR1:2;
thus L309: D88 is_closed_on ( D92 . C38 ) , ( D90 +* ( while>0 (D87 , D88) ) ) by L308 , L304 , SFMASTR2:4;
L310: D91 is_halting_on ( IExec (C37 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( ( C37 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D86 . C38 )) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( ( C37 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by SCMFSA7B:19;
L311: D88 is_halting_on ( Initialized ( D86 . C38 ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( ( C37 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc C37 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L310 , L298 , L307 , L306 , L300 , SFMASTR1:3;
thus L312: thesis by L311 , L304 , L308 , SFMASTR2:5;
end;
set D93 = ( R2 := R5 );
set D94 = ( AddTo (D87 , ( intloc ( 0 ) )) );
set D95 = ( SubFrom (D87 , R5) );
set D96 = ( D87 := R6 );
set D97 = ( IExec (( ( ( D96 ";" D95 ) ";" D94 ) ";" D93 ) , R15 , R1) );
set D98 = R15;
set D99 = ( StepWhile>0 (D87 , D88 , D98 , D97) );
deffunc H1((State of ( SCM+FSA ))) = ( abs ( $1 . D87 ) );
consider C39 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that L313: (for B6 being (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) holds ( C39 . B6 ) = H1(B6)) from FUNCT_2:sch 4;
L314: (for B7 being (State of ( SCM+FSA )) holds ( C39 . B7 ) = H1(B7))
proof
let C40 being (State of ( SCM+FSA ));
reconsider D100 = C40 as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
L315: ( C39 . D100 ) = H1(D100) by L313;
thus L316: thesis by L315;
end;
L317: ( DataPart D97 ) = ( DataPart D89 ) by L294 , L84;
thus L318:  ProperBodyWhile>0 D87 , D88 , D97 , D98
proof
let C41 being (Element of ( NAT ));
assume L319: ( ( ( StepWhile>0 (D87 , D88 , D98 , D97) ) . C41 ) . D87 ) > ( 0 );
L320: ( DataPart ( D92 . C41 ) ) = ( DataPart ( D99 . C41 ) ) by L317 , L299 , SCMFSA9A:34;
L321: ( ( D99 . C41 ) . D87 ) = ( ( D92 . C41 ) . D87 ) by L320 , SCMFSA_M:2;
L322: D88 is_closed_on ( D92 . C41 ) , ( D90 +* ( while>0 (D87 , D88) ) ) by L321 , L299 , L319 , SCMFSA9A:def 4;
thus L323: D88 is_closed_on ( D99 . C41 ) , ( D90 +* ( while>0 (D87 , D88) ) ) by L322 , L320 , SCMFSA8B:3;
L324: D88 is_halting_on ( D92 . C41 ) , ( D90 +* ( while>0 (D87 , D88) ) ) by L299 , L319 , L321 , SCMFSA9A:def 4;
thus L325: thesis by L324 , L320 , L322 , SCMFSA8B:5;
end;

L326: (for B8 being (Element of ( NAT )) holds (( C39 . ( D99 . ( B8 + 1 ) ) ) < ( C39 . ( D99 . B8 ) ) or ( ( D99 . B8 ) . D87 ) <= ( 0 )))
proof
let C42 being (Element of ( NAT ));
L327: ( DataPart ( D99 . C42 ) ) = ( DataPart ( D92 . C42 ) ) by L317 , L299 , SCMFSA9A:34;
L328: ( ( D99 . C42 ) . D87 ) = ( ( D92 . C42 ) . D87 ) by L327 , SCMFSA_M:2;
L329: ( DataPart ( D92 . ( C42 + 1 ) ) ) = ( DataPart ( D99 . ( C42 + 1 ) ) ) by L317 , L299 , SCMFSA9A:34;
L330: ( ( D99 . ( C42 + 1 ) ) . D87 ) = ( ( D92 . ( C42 + 1 ) ) . D87 ) by L329 , SCMFSA_M:2;
L331:
now
assume L332: ( ( D99 . C42 ) . D87 ) > ( 0 );
L333: C42 < D85 by L332 , L294 , L296 , L297 , L328 , L161;
L334: C42 < D85 by L294 , L296 , L297 , L328 , L332 , L161;
L335: ( ( ( D92 . C42 ) . D87 ) + C42 ) = ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 ) by L334 , L294 , L296 , L297 , L138;
reconsider D101 = D85 as (Element of ( NAT )) by L333 , INT_1:3;
L336: ( C42 + 1 ) <= D101 by L333 , NAT_1:13;
L337: ( ( ( D92 . ( C42 + 1 ) ) . D87 ) + ( C42 + 1 ) ) = ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 ) by L336 , L294 , L296 , L297 , L138;
L338: ( C39 . ( D99 . C42 ) ) = ( abs ( ( D99 . C42 ) . D87 ) ) by L314
.= ( ( D92 . C42 ) . D87 ) by L328 , L332 , ABSVALUE:def 1;
per cases ;
suppose L339: ( ( D99 . ( C42 + 1 ) ) . D87 ) > ( 0 );

L340: ( C39 . ( D99 . ( C42 + 1 ) ) ) = ( abs ( ( D99 . ( C42 + 1 ) ) . D87 ) ) by L314
.= ( ( D101 - C42 ) - 1 ) by L330 , L337 , L339 , ABSVALUE:def 1;
thus L341: ( C39 . ( D99 . ( C42 + 1 ) ) ) < ( C39 . ( D99 . C42 ) ) by L340 , L338 , L335 , XREAL_1:146;
end;
suppose L342: ( ( D99 . ( C42 + 1 ) ) . D87 ) <= ( 0 );

L343: ( ( D92 . ( C42 + 1 ) ) . D87 ) = ( D101 - ( C42 + 1 ) ) by L337;
L344: ( ( D99 . ( C42 + 1 ) ) . D87 ) = ( 0 ) by L343 , L330 , L336 , L342 , XREAL_1:48;
L345: ( C39 . ( D99 . ( C42 + 1 ) ) ) = ( abs ( ( D99 . ( C42 + 1 ) ) . D87 ) ) by L314
.= ( 0 ) by L344 , ABSVALUE:def 1;
thus L346: ( C39 . ( D99 . ( C42 + 1 ) ) ) < ( C39 . ( D99 . C42 ) ) by L345 , L327 , L332 , L338 , SCMFSA_M:2;
end;
end;
thus L348: thesis by L331;
end;
thus L349:  WithVariantWhile>0 D87 , D88 , D97 , D98
proof
take C39;
thus L350: thesis by L326;
end;

end;
theorem
L350: (for R1 being (State of ( SCM+FSA )) holds (for R2 being  read-write Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R12 being  good (Program of ( SCM+FSA )) holds (for R14 being (Element of ( NAT )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds ((( R1 . ( intloc ( 0 ) ) ) = 1 & R14 = ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 ) & ( ProperForUpBody R2 , R5 , R6 , R12 , R1 , R15 or R12 is  parahalting)) implies ( DataPart ( IExec (( for-up (R2 , R5 , R6 , R12) ) , R15 , R1) ) ) = ( DataPart ( ( StepForUp (R2 , R5 , R6 , R12 , R15 , R1) ) . R14 ) )))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R2 being  read-write Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R12 being  good (Program of ( SCM+FSA ));
let R14 being (Element of ( NAT ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
set D102 = R12;
assume that
L351: ( R1 . ( intloc ( 0 ) ) ) = 1
and
L352: R14 = ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )
and
L353: ( ProperForUpBody R2 , R5 , R6 , D102 , R1 , R15 or D102 is  parahalting);
set D103 = ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 );
set D104 = ( StepForUp (R2 , R5 , R6 , D102 , R15 , R1) );
L354:  ProperForUpBody R2 , R5 , R6 , D102 , R1 , R15 by L353 , L119;
set D105 = ( R2 := R5 );
set D106 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D102 ) ) );
set D107 = ( D106 := R6 );
set D108 = ( SubFrom (D106 , R5) );
set D109 = ( AddTo (D106 , ( intloc ( 0 ) )) );
set D110 = ( ( D102 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (D106 , ( intloc ( 0 ) )) ) );
set D111 = ( ( ( D107 ";" D108 ) ";" D109 ) ";" D105 );
set D112 = ( IExec (D111 , R15 , R1) );
set D113 = R15;
L355: ( D112 . ( intloc ( 0 ) ) ) = ( ( Exec (D105 , ( IExec (( ( D107 ";" D108 ) ";" D109 ) , R15 , R1) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:6
.= ( ( IExec (( ( D107 ";" D108 ) ";" D109 ) , R15 , R1) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= ( ( Exec (D109 , ( IExec (( D107 ";" D108 ) , R15 , R1) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:6
.= ( ( IExec (( D107 ";" D108 ) , R15 , R1) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:64
.= ( ( Exec (D108 , ( Exec (D107 , ( Initialized R1 )) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:8
.= ( ( Exec (D107 , ( Initialized R1 )) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:65
.= ( ( Initialized R1 ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= 1 by SCMFSA_M:9;
L356: ( DataPart ( Initialized D112 ) ) = ( DataPart D112 ) by L355 , SCMFSA_M:19;
set D114 = ( ExitsAtWhile>0 (D106 , D110 , D113 , ( Initialized D112 )) );
set D115 = ( StepWhile>0 (D106 , D110 , D113 , ( Initialized D112 )) );
L357:  ProperBodyWhile>0 D106 , D110 , D112 , D113 by L351 , L353 , L293;
L358:  ProperBodyWhile>0 D106 , D110 , ( Initialized D112 ) , D113 by L357 , L356 , SCMFSA9A:38;
set D116 = ( ( R1 +* (D106 , ( ( ( R1 . R6 ) - ( R1 . R5 ) ) + 1 )) ) +* (R2 , ( R1 . R5 )) );
set D117 = R15;
set D118 = ( StepWhile>0 (D106 , D110 , D117 , D116) );
L359: ( DataPart D112 ) = ( DataPart D116 ) by L351 , L84;
L360: ( DataPart ( D115 . R14 ) ) = ( DataPart ( D118 . R14 ) ) by L359 , L356 , L358 , SCMFSA9A:34;
L361: ( ( D115 . R14 ) . D106 ) = ( ( D118 . R14 ) . D106 ) by L360 , SCMFSA_M:2;
L362:  WithVariantWhile>0 D106 , D110 , D112 , D113 by L351 , L353 , L293;
L363:  WithVariantWhile>0 D106 , D110 , ( Initialized D112 ) , D113 by L362 , L355 , L356 , L357 , SCMFSA9A:41;
consider C43 being (Element of ( NAT )) such that L364: ( ExitsAtWhile>0 (D106 , D110 , D113 , ( Initialized D112 )) ) = C43 and L365: ( ( ( StepWhile>0 (D106 , D110 , D113 , ( Initialized D112 )) ) . C43 ) . D106 ) <= ( 0 ) and L366: ((for B9 being (Element of ( NAT )) holds (( ( ( StepWhile>0 (D106 , D110 , D113 , ( Initialized D112 )) ) . B9 ) . D106 ) <= ( 0 ) implies C43 <= B9)) & ( DataPart ( Comput (( D113 +* ( while>0 (D106 , D110) ) ) , ( Initialize ( Initialized D112 ) ) , ( LifeSpan (( D113 +* ( while>0 (D106 , D110) ) ) , ( Initialize ( Initialized D112 ) )) )) ) ) = ( DataPart ( ( StepWhile>0 (D106 , D110 , D113 , ( Initialized D112 )) ) . C43 ) )) by L363 , L358 , SCMFSA9A:def 6;
L367: ( DataPart ( D115 . C43 ) ) = ( DataPart ( D118 . C43 ) ) by L356 , L358 , L359 , SCMFSA9A:34;
L368: ( ( D115 . C43 ) . D106 ) = ( ( D118 . C43 ) . D106 ) by L367 , SCMFSA_M:2;
L369:
now
assume L370: C43 < D103;
L371: ( ( ( D104 . C43 ) . D106 ) + C43 ) < ( ( 0 ) + D103 ) by L370 , L365 , L368 , XREAL_1:8;
thus L372: contradiction by L371 , L351 , L354 , L370 , L138;
end;
L373: ( ( ( D104 . R14 ) . D106 ) + R14 ) = D103 by L351 , L352 , L354 , L138;
L374: C43 <= R14 by L373 , L352 , L366 , L361;
L375: D114 = R14 by L374 , L352 , L364 , L369 , XXREAL_0:1;
set D119 = ( for-up (R2 , R5 , R6 , D102) );
set D120 = ( while>0 (D106 , D110) );
L376: (D120 is_halting_on D112 , D113 & D120 is_closed_on D112 , D113) by L357 , L362 , SCMFSA9A:27;
thus L377: ( DataPart ( IExec (D119 , R15 , R1) ) ) = ( DataPart ( IExec (D120 , D113 , D112) ) ) by L376 , SFMASTR1:9
.= ( DataPart ( D115 . D114 ) ) by L358 , L363 , SCMFSA9A:36
.= ( DataPart ( ( StepForUp (R2 , R5 , R6 , D102 , R15 , R1) ) . R14 ) ) by L356 , L358 , L359 , L375 , SCMFSA9A:34;
end;
theorem
L378: (for R1 being (State of ( SCM+FSA )) holds (for R2 being  read-write Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R12 being  good (Program of ( SCM+FSA )) holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds ((( R1 . ( intloc ( 0 ) ) ) = 1 & ( ProperForUpBody R2 , R5 , R6 , R12 , R1 , R15 or R12 is  parahalting)) implies (( for-up (R2 , R5 , R6 , R12) ) is_closed_on R1 , R15 & ( for-up (R2 , R5 , R6 , R12) ) is_halting_on R1 , R15))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R2 being  read-write Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R12 being  good (Program of ( SCM+FSA ));
let R15 being (Instruction-Sequence of ( SCM+FSA ));
set D121 = R12;
assume that
L379: ( R1 . ( intloc ( 0 ) ) ) = 1
and
L380: ( ProperForUpBody R2 , R5 , R6 , D121 , R1 , R15 or D121 is  parahalting);
set D122 = ( R2 := R5 );
set D123 = ( 1 -stRWNotIn ( { R2 , R5 , R6 } \/ ( UsedIntLoc D121 ) ) );
set D124 = ( D123 := R6 );
set D125 = ( SubFrom (D123 , R5) );
set D126 = ( AddTo (D123 , ( intloc ( 0 ) )) );
set D127 = ( ( D121 ";" ( AddTo (R2 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (D123 , ( intloc ( 0 ) )) ) );
set D128 = ( while>0 (D123 , D127) );
set D129 = ( ( ( D124 ";" D125 ) ";" D126 ) ";" D122 );
set D130 = ( IExec (D129 , R15 , R1) );
set D131 = R15;
L381: ( ProperBodyWhile>0 D123 , D127 , D130 , D131 &  WithVariantWhile>0 D123 , D127 , D130 , D131) by L379 , L380 , L293;
L382: D128 is_closed_on D130 , D131 by L381 , SCMFSA9A:27;
reconsider D132 = D129 as  parahalting (Program of ( SCM+FSA ));
set D133 = ( for-up (R2 , R5 , R6 , D121) );
L383: (D132 is_closed_on ( Initialized R1 ) , R15 & D132 is_halting_on ( Initialized R1 ) , R15) by SCMFSA7B:18 , SCMFSA7B:19;
L384: D133 is_closed_on ( Initialized R1 ) , R15 by L383 , L382 , SFMASTR1:2;
thus L385: D133 is_closed_on R1 , R15 by L384 , L379 , SFMASTR2:4;
L386: D128 is_halting_on D130 , D131 by L381 , SCMFSA9A:27;
L387: D133 is_halting_on ( Initialized R1 ) , R15 by L386 , L383 , L382 , SFMASTR1:3;
thus L388: thesis by L387 , L379 , L384 , SFMASTR2:5;
end;
begin
definition
let C44 , C45 , C46 being Int-Location;
let C47 being FinSeq-Location;
func FinSeqMin (C47 , C44 , C45 , C46) -> (Program of ( SCM+FSA )) equals 
( ( C46 := C44 ) ";" ( for-up (( 3 -rdRWNotIn { C44 , C45 , C46 } ) , C44 , C45 , ( ( ( ( 1 -stRWNotIn { C44 , C45 , C46 } ) := (C47 , ( 3 -rdRWNotIn { C44 , C45 , C46 } )) ) ";" ( ( 2 -ndRWNotIn { C44 , C45 , C46 } ) := (C47 , C46) ) ) ";" ( if>0 (( 2 -ndRWNotIn { C44 , C45 , C46 } ) , ( 1 -stRWNotIn { C44 , C45 , C46 } ) , ( Macro ( C46 := ( 3 -rdRWNotIn { C44 , C45 , C46 } ) ) ) , ( Stop ( SCM+FSA ) )) ) )) ) );
coherence;
end;
registration
let C48 , C49 being Int-Location;
let C50 being  read-write Int-Location;
let C51 being FinSeq-Location;
cluster ( FinSeqMin (C51 , C48 , C49 , C50) ) ->  good;
coherence;
end;
theorem
L391: (for R3 being  read-write Int-Location holds (for R4 being Int-Location holds (for R5 being Int-Location holds (for R9 being FinSeq-Location holds (R3 <> R4 implies (not ( FinSeqMin (R9 , R4 , R5 , R3) ) destroy R4))))))
proof
let R3 being  read-write Int-Location;
let R4 being Int-Location;
let R5 being Int-Location;
let R9 being FinSeq-Location;
set D134 = R4;
set D135 = R5;
set D136 = ( 1 -stRWNotIn { D134 , D135 , R3 } );
set D137 = ( 2 -ndRWNotIn { D134 , D135 , R3 } );
set D138 = ( 3 -rdRWNotIn { D134 , D135 , R3 } );
set D139 = ( D136 := (R9 , D138) );
set D140 = ( D137 := (R9 , R3) );
set D141 = ( if>0 (D137 , D136 , ( Macro ( R3 := D138 ) ) , ( Stop ( SCM+FSA ) )) );
set D142 = ( ( D139 ";" D140 ) ";" D141 );
set D143 = ( for-up (D138 , D134 , D135 , D142) );
L392: (not ( Stop ( SCM+FSA ) ) destroy D134) by SCMFSA8C:56;
L393: D134 in { D134 , D135 , R3 } by ENUMSET1:def 1;
L394: D136 <> D134 by L393 , SCMFSA_M:25;
L395: (not D139 destroy D134) by L394 , SCMFSA7B:14;
L396: D137 <> D134 by L393 , SCMFSA_M:25;
L397: (not D140 destroy D134) by L396 , SCMFSA7B:14;
L398: (not ( D139 ";" D140 ) destroy D134) by L397 , L395 , SCMFSA8C:55;
assume L399: R3 <> R4;
L400: (not ( Macro ( R3 := D138 ) ) destroy D134) by L399 , SCMFSA7B:6 , SCMFSA8C:48;
L401: (not D141 destroy D134) by L400 , L396 , L392 , L47;
L402: (not D142 destroy D134) by L401 , L398 , SCMFSA8C:52;
L403: D134 in { D138 , D134 , D135 } by ENUMSET1:def 1;
L404: D134 in ( { D138 , D134 , D135 } \/ ( UsedIntLoc D142 ) ) by L403 , XBOOLE_0:def 3;
L405: D134 <> ( 1 -stRWNotIn ( { D138 , D134 , D135 } \/ ( UsedIntLoc D142 ) ) ) by L404 , SCMFSA_M:25;
L406: D138 <> D134 by L393 , SCMFSA_M:25;
L407: (not D143 destroy D134) by L406 , L402 , L405 , L246;
thus L408: thesis by L407 , L399 , SCMFSA7B:6 , SCMFSA8C:53;
end;
theorem
L409: (for R3 being  read-write Int-Location holds (for R4 being Int-Location holds (for R5 being Int-Location holds (for R9 being FinSeq-Location holds { R4 , R5 , R3 } c= ( UsedIntLoc ( FinSeqMin (R9 , R4 , R5 , R3) ) )))))
proof
let R3 being  read-write Int-Location;
let R4 being Int-Location;
let R5 being Int-Location;
let R9 being FinSeq-Location;
set D144 = R4;
set D145 = R5;
set D146 = ( 1 -stRWNotIn { D144 , D145 , R3 } );
set D147 = ( 2 -ndRWNotIn { D144 , D145 , R3 } );
set D148 = ( 3 -rdRWNotIn { D144 , D145 , R3 } );
set D149 = ( R3 := D144 );
set D150 = ( D146 := (R9 , D148) );
set D151 = ( D147 := (R9 , R3) );
set D152 = ( if>0 (D147 , D146 , ( Macro ( R3 := D148 ) ) , ( Stop ( SCM+FSA ) )) );
set D153 = ( ( D150 ";" D151 ) ";" D152 );
set D154 = ( for-up (D148 , D144 , D145 , D153) );
L410: ( UsedIntLoc ( D149 ";" D154 ) ) = ( ( UsedIntLoc D149 ) \/ ( UsedIntLoc D154 ) ) by SF_MASTR:29;
L411: ( { D148 , D144 , D145 } \/ ( UsedIntLoc D153 ) ) c= ( UsedIntLoc D154 ) by L221;
let C52 being set;
L412: ( UsedIntLoc D149 ) = { R3 , D144 } by SF_MASTR:14;
assume L413: C52 in { D144 , D145 , R3 };
per cases  by L413 , ENUMSET1:def 1;
suppose L414: C52 = D144;

L415: C52 in { R3 , D144 } by L414 , TARSKI:def 2;
thus L416: thesis by L415 , L410 , L412 , XBOOLE_0:def 3;
end;
suppose L417: C52 = D145;

L418: C52 in { D148 , D144 , D145 } by L417 , ENUMSET1:def 1;
L419: C52 in ( { D148 , D144 , D145 } \/ ( UsedIntLoc D153 ) ) by L418 , XBOOLE_0:def 3;
thus L420: thesis by L419 , L410 , L411 , XBOOLE_0:def 3;
end;
suppose L421: C52 = R3;

L422: C52 in { R3 , D144 } by L421 , TARSKI:def 2;
thus L423: thesis by L422 , L410 , L412 , XBOOLE_0:def 3;
end;
end;
theorem
L425: (for R1 being (State of ( SCM+FSA )) holds (for R3 being  read-write Int-Location holds (for R4 being Int-Location holds (for R5 being Int-Location holds (for R9 being FinSeq-Location holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds (( R1 . ( intloc ( 0 ) ) ) = 1 implies (( FinSeqMin (R9 , R4 , R5 , R3) ) is_closed_on R1 , R15 & ( FinSeqMin (R9 , R4 , R5 , R3) ) is_halting_on R1 , R15))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R3 being  read-write Int-Location;
let R4 being Int-Location;
let R5 being Int-Location;
let R9 being FinSeq-Location;
let R15 being (Instruction-Sequence of ( SCM+FSA ));
assume L426: ( R1 . ( intloc ( 0 ) ) ) = 1;
set D155 = R4;
set D156 = R5;
set D157 = ( 1 -stRWNotIn { D155 , D156 , R3 } );
set D158 = ( 2 -ndRWNotIn { D155 , D156 , R3 } );
set D159 = ( 3 -rdRWNotIn { D155 , D156 , R3 } );
set D160 = ( R3 := D155 );
set D161 = ( D157 := (R9 , D159) );
set D162 = ( D158 := (R9 , R3) );
set D163 = ( if>0 (D158 , D157 , ( Macro ( R3 := D159 ) ) , ( Stop ( SCM+FSA ) )) );
set D164 = ( ( D161 ";" D162 ) ";" D163 );
set D165 = ( for-up (D159 , D155 , D156 , D164) );
set D166 = ( IExec (( Macro D160 ) , R15 , R1) );
set D167 = R15;
L427: ( D166 . ( intloc ( 0 ) ) ) = ( D166 . ( intloc ( 0 ) ) )
.= ( ( Exec (D160 , ( Initialized R1 )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:5
.= ( ( Exec (D160 , ( Initialized R1 )) ) . ( intloc ( 0 ) ) )
.= ( ( Initialized R1 ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= 1 by SCMFSA_M:9;
L428: D165 is_closed_on D166 , D167 by L427 , L378;
L429: (( Macro D160 ) is_closed_on ( Initialized R1 ) , R15 & ( Macro D160 ) is_halting_on ( Initialized R1 ) , R15) by SCMFSA7B:18 , SCMFSA7B:19;
L430: ( FinSeqMin (R9 , R4 , R5 , R3) ) is_closed_on ( Initialized R1 ) , R15 by L429 , L428 , SFMASTR1:2;
thus L431: ( FinSeqMin (R9 , R4 , R5 , R3) ) is_closed_on R1 , R15 by L430 , L426 , SFMASTR2:4;
L432: D165 is_halting_on D166 , D167 by L427 , L378;
L433: ( FinSeqMin (R9 , R4 , R5 , R3) ) is_halting_on ( Initialized R1 ) , R15 by L432 , L428 , L429 , SFMASTR1:3;
thus L434: thesis by L433 , L426 , L430 , SFMASTR2:5;
end;
theorem
L435: (for R1 being (State of ( SCM+FSA )) holds (for R3 being  read-write Int-Location holds (for R4 being Int-Location holds (for R5 being Int-Location holds (for R9 being FinSeq-Location holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds ((R4 <> R3 & R5 <> R3 & ( R1 . ( intloc ( 0 ) ) ) = 1) implies (( ( IExec (( FinSeqMin (R9 , R4 , R5 , R3) ) , R15 , R1) ) . R9 ) = ( R1 . R9 ) & ( ( IExec (( FinSeqMin (R9 , R4 , R5 , R3) ) , R15 , R1) ) . R4 ) = ( R1 . R4 ) & ( ( IExec (( FinSeqMin (R9 , R4 , R5 , R3) ) , R15 , R1) ) . R5 ) = ( R1 . R5 )))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R3 being  read-write Int-Location;
let R4 being Int-Location;
let R5 being Int-Location;
let R9 being FinSeq-Location;
let R15 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L436: R4 <> R3
and
L437: R5 <> R3
and
L438: ( R1 . ( intloc ( 0 ) ) ) = 1;
set D168 = R4;
set D169 = R5;
set D170 = ( R3 := D168 );
set D171 = ( Exec (D170 , ( Initialized R1 )) );
set D172 = R15;
L439: (D168 = ( intloc ( 0 ) ) or D168 is  read-write) by SCMFSA_M:def 2;
L440: (D169 = ( intloc ( 0 ) ) or D169 is  read-write) by SCMFSA_M:def 2;
L441: ( D171 . D169 ) = ( ( Initialized R1 ) . D169 ) by L437 , SCMFSA_2:63
.= ( R1 . D169 ) by L438 , L440 , SCMFSA_M:9 , SCMFSA_M:37;
set D173 = ( 3 -rdRWNotIn { D168 , D169 , R3 } );
set D174 = ( 2 -ndRWNotIn { D168 , D169 , R3 } );
set D175 = ( 1 -stRWNotIn { D168 , D169 , R3 } );
set D176 = ( D175 := (R9 , D173) );
set D177 = ( D174 := (R9 , R3) );
set D178 = ( if>0 (D174 , D175 , ( Macro ( R3 := D173 ) ) , ( Stop ( SCM+FSA ) )) );
set D179 = ( ( D176 ";" D177 ) ";" D178 );
set D180 = ( for-up (D173 , D168 , D169 , D179) );
L442: D174 <> D173 by SCMFSA_M:26;
L443: D173 in { D173 , D168 , D169 } by ENUMSET1:def 1;
L444: D173 in ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) by L443 , XBOOLE_0:def 3;
L445: D175 <> D173 by SCMFSA_M:26;
L446: D169 in { D168 , D169 , R3 } by ENUMSET1:def 1;
L447: D173 <> D169 by L446 , SCMFSA_M:25;
L448: D175 <> D169 by L446 , SCMFSA_M:25;
L449: D174 <> D169 by L446 , SCMFSA_M:25;
L450: ( D171 . D168 ) = ( ( Initialized R1 ) . D168 ) by L436 , SCMFSA_2:63
.= ( R1 . D168 ) by L438 , L439 , SCMFSA_M:9 , SCMFSA_M:37;
L451: D169 in { D173 , D168 , D169 } by ENUMSET1:def 1;
L452: D169 in ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) by L451 , XBOOLE_0:def 3;
L453: D168 in { D168 , D169 , R3 } by ENUMSET1:def 1;
L454: D173 <> D168 by L453 , SCMFSA_M:25;
L455: D175 <> D168 by L453 , SCMFSA_M:25;
L456: D174 <> D168 by L453 , SCMFSA_M:25;
L457: ( D171 . R9 ) = ( ( Initialized R1 ) . R9 ) by SCMFSA_2:63
.= ( R1 . R9 ) by SCMFSA_M:37;
L458: D168 in { D173 , D168 , D169 } by ENUMSET1:def 1;
L459: D168 in ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) by L458 , XBOOLE_0:def 3;
L460: R3 in { D168 , D169 , R3 } by ENUMSET1:def 1;
L461: D173 <> R3 by L460 , SCMFSA_M:25;
L462: ( D171 . ( intloc ( 0 ) ) ) = ( ( Initialized R1 ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= 1 by SCMFSA_M:9;
L463: (D180 is_closed_on D171 , D172 & D180 is_halting_on D171 , D172) by L462 , L378;
per cases ;
suppose L464: ( R1 . R4 ) > ( R1 . R5 );

thus L465: ( ( IExec (( FinSeqMin (R9 , R4 , R5 , R3) ) , R15 , R1) ) . R9 ) = ( ( IExec (D180 , D172 , D171) ) . R9 ) by L463 , SFMASTR1:15
.= ( R1 . R9 ) by L462 , L450 , L441 , L457 , L464 , L258;
L466: D168 in { D168 , D169 } by TARSKI:def 2;
L467: D168 in ( { D168 , D169 } \/ ( UsedIntLoc D179 ) ) by L466 , XBOOLE_0:def 3;
thus L468: ( ( IExec (( FinSeqMin (R9 , R4 , R5 , R3) ) , R15 , R1) ) . R4 ) = ( ( IExec (D180 , D172 , D171) ) . R4 ) by L463 , SFMASTR1:14
.= ( R1 . R4 ) by L454 , L462 , L450 , L441 , L464 , L467 , L258;
L469: D169 in { D168 , D169 } by TARSKI:def 2;
L470: D169 in ( { D168 , D169 } \/ ( UsedIntLoc D179 ) ) by L469 , XBOOLE_0:def 3;
thus L471: ( ( IExec (( FinSeqMin (R9 , R4 , R5 , R3) ) , R15 , R1) ) . R5 ) = ( ( IExec (D180 , D172 , D171) ) . R5 ) by L463 , SFMASTR1:14
.= ( R1 . R5 ) by L447 , L462 , L450 , L441 , L464 , L470 , L258;
end;
suppose L472: ( R1 . R4 ) <= ( R1 . R5 );

set D181 = ( StepForUp (D173 , D168 , D169 , D179 , D172 , D171) );
L473: ( ( R1 . D168 ) - ( R1 . D168 ) ) <= ( ( R1 . D169 ) - ( R1 . D168 ) ) by L472 , XREAL_1:9;
reconsider D182 = ( ( ( R1 . D169 ) - ( R1 . D168 ) ) + 1 ) as (Element of ( NAT )) by L473 , INT_1:3;
defpred S3[ Nat ] means ((( 0 ) < $1 & $1 <= D182) implies (( ( D181 . $1 ) . ( intloc ( 0 ) ) ) = 1 & ( ( D181 . $1 ) . D173 ) = ( $1 + ( D171 . D168 ) ) & ( ( D181 . $1 ) . R9 ) = ( D171 . R9 ) & ( ( D181 . $1 ) . D168 ) = ( D171 . D168 ) & ( ( D181 . $1 ) . D169 ) = ( D171 . D169 )));
L474:  ProperForUpBody D173 , D168 , D169 , D179 , D171 , D172 by L119;
L475: (for B10 being (Element of ( NAT )) holds (S3[ B10 ] implies S3[ ( B10 + 1 ) ]))
proof
let C53 being (Element of ( NAT ));
assume that
L476: S3[ C53 ]
and
L477: ( 0 ) < ( C53 + 1 )
and
L478: ( C53 + 1 ) <= D182;
L479: (( ( D181 . C53 ) . ( intloc ( 0 ) ) ) = 1 & ( ( D181 . C53 ) . D173 ) = ( C53 + ( D171 . D168 ) ) & ( ( D181 . C53 ) . D173 ) <= ( D171 . D169 ))
proof
per cases ;
suppose L480: ( 0 ) = C53;

thus L481: ( ( D181 . C53 ) . ( intloc ( 0 ) ) ) = 1 by L480 , L462 , L53;
thus L482: ( ( D181 . C53 ) . D173 ) = ( C53 + ( D171 . D168 ) ) by L480 , L57;
thus L483: thesis by L450 , L441 , L472 , L480 , L57;
end;
suppose L484: ( 0 ) < C53;

thus L485: ( ( D181 . C53 ) . ( intloc ( 0 ) ) ) = 1 by L484 , L476 , L478 , NAT_1:13;
thus L486: ( ( D181 . C53 ) . D173 ) = ( C53 + ( D171 . D168 ) ) by L476 , L478 , L484 , NAT_1:13;
L487: ( ( C53 + 1 ) - 1 ) <= ( ( ( ( R1 . D169 ) - ( R1 . D168 ) ) + 1 ) - 1 ) by L478 , XREAL_1:9;
thus L488: thesis by L487 , L450 , L441 , L476 , L478 , L484 , NAT_1:13 , XREAL_1:19;
end;
end;
L490: C53 < ( C53 + 1 ) by XREAL_1:29;
L491: C53 < D182 by L490 , L478 , XXREAL_0:2;
L492: ( ( D181 . ( C53 + 1 ) ) | ( ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) \/ ( FinSeq-Locations ) ) ) = ( ( IExec (( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) | ( ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) \/ ( FinSeq-Locations ) ) ) by L491 , L462 , L450 , L441 , L474 , L189;
L493: ( ( D181 . ( C53 + 1 ) ) . R9 ) = ( ( IExec (( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . R9 ) by L492 , SCMFSA_M:28
.= ( ( Exec (( AddTo (D173 , ( intloc ( 0 ) )) ) , ( IExec (D179 , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . R9 ) by SFMASTR1:12
.= ( ( IExec (D179 , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . R9 ) by SCMFSA_2:64
.= ( ( IExec (D178 , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . R9 ) by SFMASTR1:8;
L494: ( ( D181 . ( C53 + 1 ) ) . D169 ) = ( ( IExec (( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . D169 ) by L452 , L492 , SCMFSA_M:28
.= ( ( Exec (( AddTo (D173 , ( intloc ( 0 ) )) ) , ( IExec (D179 , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D169 ) by SFMASTR1:11
.= ( ( IExec (D179 , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . D169 ) by L447 , SCMFSA_2:64
.= ( ( IExec (D178 , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D169 ) by SFMASTR1:7;
L495: ( ( D181 . ( C53 + 1 ) ) . D168 ) = ( ( IExec (( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . D168 ) by L459 , L492 , SCMFSA_M:28
.= ( ( Exec (( AddTo (D173 , ( intloc ( 0 ) )) ) , ( IExec (D179 , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D168 ) by SFMASTR1:11
.= ( ( IExec (D179 , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . D168 ) by L454 , SCMFSA_2:64
.= ( ( IExec (D178 , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D168 ) by SFMASTR1:7;
L496: ( ( D181 . ( C53 + 1 ) ) . D173 ) = ( ( IExec (( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . D173 ) by L444 , L492 , SCMFSA_M:28
.= ( ( Exec (( AddTo (D173 , ( intloc ( 0 ) )) ) , ( IExec (D179 , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D173 ) by SFMASTR1:11
.= ( ( ( IExec (D179 , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . D173 ) + ( ( IExec (D179 , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . ( intloc ( 0 ) ) ) ) by SCMFSA_2:64
.= ( ( ( IExec (D179 , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . D173 ) + 1 ) by SCMFSA6B:11
.= ( ( ( IExec (D178 , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D173 ) + 1 ) by SFMASTR1:7;
set D183 = ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) );
set D184 = ( Initialized ( D181 . C53 ) );
set D185 = ( Exec (D176 , D184) );
set D186 = ( Exec (D177 , ( Exec (D176 , D184) )) );
L497: ( ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . R9 ) = ( D186 . R9 ) by SCMFSA6C:9
.= ( D185 . R9 ) by SCMFSA_2:72
.= ( D184 . R9 ) by SCMFSA_2:72;
L498: ( ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . ( intloc ( 0 ) ) ) = ( D186 . ( intloc ( 0 ) ) ) by SCMFSA6C:8
.= ( D185 . ( intloc ( 0 ) ) ) by SCMFSA_2:72
.= ( D184 . ( intloc ( 0 ) ) ) by SCMFSA_2:72
.= 1 by SCMFSA_M:9;
L499: ( DataPart ( IExec (( Stop ( SCM+FSA ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) ) = ( DataPart ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) ) by L498 , L5;
L500: ( ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . D169 ) = ( D186 . D169 ) by SCMFSA6C:8
.= ( D185 . D169 ) by L449 , SCMFSA_2:72
.= ( D184 . D169 ) by L448 , SCMFSA_2:72;
L501: ( ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . D168 ) = ( D186 . D168 ) by SCMFSA6C:8
.= ( D185 . D168 ) by L456 , SCMFSA_2:72
.= ( D184 . D168 ) by L455 , SCMFSA_2:72;
L502: ( ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . D173 ) = ( D186 . D173 ) by SCMFSA6C:8
.= ( D185 . D173 ) by L442 , SCMFSA_2:72
.= ( D184 . D173 ) by L445 , SCMFSA_2:72;
L503: ((not ( Macro ( R3 := D173 ) ) refer D174) & (not ( Stop ( SCM+FSA ) ) refer D174)) by L442 , L8 , L13 , SCMFSA8C:51;
per cases ;
suppose L504: ( 0 ) = C53;

thus L505: thesis
proof
thus L506: ( ( D181 . ( C53 + 1 ) ) . ( intloc ( 0 ) ) ) = 1 by L462 , L450 , L441 , L474 , L478 , L138;
L507: ( D184 . R9 ) = ( ( D181 . ( 0 ) ) . R9 ) by L504 , SCMFSA_M:37
.= ( R1 . R9 ) by L457 , L81;
L508: ( D184 . D173 ) = ( ( D181 . ( 0 ) ) . D173 ) by L504 , SCMFSA_M:37
.= ( R1 . D168 ) by L450 , L57;
L509: ( D184 . D169 ) = ( ( D181 . ( 0 ) ) . D169 ) by L440 , L479 , L504 , SCMFSA_M:9 , SCMFSA_M:37
.= ( D171 . D169 ) by L447 , L67;
L510: ( D184 . D168 ) = ( ( D181 . ( 0 ) ) . D168 ) by L439 , L479 , L504 , SCMFSA_M:9 , SCMFSA_M:37
.= ( D171 . D168 ) by L454 , L60;
thus L511: thesis
proof
per cases ;
suppose L512: ( D183 . D174 ) <= ( D183 . D175 );

thus L513: ( ( D181 . ( C53 + 1 ) ) . D173 ) = ( ( ( IExec (( Stop ( SCM+FSA ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D173 ) + 1 ) by L512 , L442 , L503 , L496 , SCMFSA8B:40
.= ( ( C53 + 1 ) + ( D171 . D168 ) ) by L450 , L499 , L502 , L504 , L508 , SCMFSA_M:2;
thus L514: ( ( D181 . ( C53 + 1 ) ) . R9 ) = ( ( IExec (( Stop ( SCM+FSA ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . R9 ) by L503 , L493 , L512 , SCMFSA8B:40
.= ( D171 . R9 ) by L457 , L499 , L497 , L507 , SCMFSA_M:2;
thus L515: ( ( D181 . ( C53 + 1 ) ) . D168 ) = ( ( IExec (( Stop ( SCM+FSA ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D168 ) by L456 , L503 , L495 , L512 , SCMFSA8B:40
.= ( D171 . D168 ) by L499 , L501 , L510 , SCMFSA_M:2;
thus L516: ( ( D181 . ( C53 + 1 ) ) . D169 ) = ( ( IExec (( Stop ( SCM+FSA ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D169 ) by L449 , L503 , L494 , L512 , SCMFSA8B:40
.= ( D171 . D169 ) by L499 , L500 , L509 , SCMFSA_M:2;
end;
suppose L517: ( D183 . D174 ) > ( D183 . D175 );

L518: ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D173 ) = ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D173 )
.= ( ( Exec (( R3 := D173 ) , ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) )) ) . D173 ) by SCMFSA6C:5
.= ( ( Exec (( R3 := D173 ) , ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) )) ) . D173 )
.= ( ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) ) . D173 ) by L461 , SCMFSA_2:63;
thus L519: ( ( D181 . ( C53 + 1 ) ) . D173 ) = ( ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D173 ) + 1 ) by L442 , L503 , L496 , L517 , SCMFSA8B:40
.= ( ( ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) ) . D173 ) + 1 ) by L518
.= ( ( C53 + 1 ) + ( D171 . D168 ) ) by L450 , L502 , L504 , L508 , SCMFSA_M:37;
thus L520: ( ( D181 . ( C53 + 1 ) ) . R9 ) = ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . R9 ) by L503 , L493 , L517 , SCMFSA8B:40
.= ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . R9 )
.= ( ( Exec (( R3 := D173 ) , ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) )) ) . R9 ) by SCMFSA6C:5
.= ( ( Exec (( R3 := D173 ) , ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) )) ) . R9 )
.= ( ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) ) . R9 ) by SCMFSA_2:63
.= ( D171 . R9 ) by L457 , L497 , L507 , SCMFSA_M:37;
thus L521: ( ( D181 . ( C53 + 1 ) ) . D168 ) = ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D168 ) by L456 , L503 , L495 , L517 , SCMFSA8B:40
.= ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D168 )
.= ( ( Exec (( R3 := D173 ) , ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) )) ) . D168 ) by SCMFSA6C:5
.= ( ( Exec (( R3 := D173 ) , ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) )) ) . D168 )
.= ( ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) ) . D168 ) by L436 , SCMFSA_2:63
.= ( D171 . D168 ) by L439 , L498 , L501 , L510 , SCMFSA_M:9 , SCMFSA_M:37;
thus L522: ( ( D181 . ( C53 + 1 ) ) . D169 ) = ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D169 ) by L449 , L503 , L494 , L517 , SCMFSA8B:40
.= ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D169 )
.= ( ( Exec (( R3 := D173 ) , ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) )) ) . D169 ) by SCMFSA6C:5
.= ( ( Exec (( R3 := D173 ) , ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) )) ) . D169 )
.= ( ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) ) . D169 ) by L437 , SCMFSA_2:63
.= ( D171 . D169 ) by L440 , L498 , L500 , L509 , SCMFSA_M:9 , SCMFSA_M:37;
end;
end;

end;

end;
suppose L506: ( 0 ) < C53;

thus L507: thesis
proof
thus L508: ( ( D181 . ( C53 + 1 ) ) . ( intloc ( 0 ) ) ) = 1 by L462 , L450 , L441 , L474 , L478 , L138;
L509: ( D184 . D173 ) = ( ( D181 . C53 ) . D173 ) by SCMFSA_M:37;
L510: ( D184 . D168 ) = ( D171 . D168 ) by L439 , L476 , L478 , L506 , NAT_1:13 , SCMFSA_M:9 , SCMFSA_M:37;
L511: ( D184 . D169 ) = ( D171 . D169 ) by L440 , L476 , L478 , L506 , NAT_1:13 , SCMFSA_M:9 , SCMFSA_M:37;
L512: ( D184 . R9 ) = ( R1 . R9 ) by L457 , L476 , L478 , L506 , NAT_1:13 , SCMFSA_M:37;
thus L513: thesis
proof
per cases ;
suppose L514: ( D183 . D174 ) <= ( D183 . D175 );

thus L515: ( ( D181 . ( C53 + 1 ) ) . D173 ) = ( ( ( IExec (( Stop ( SCM+FSA ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D173 ) + 1 ) by L514 , L442 , L503 , L496 , SCMFSA8B:40
.= ( ( ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . D173 ) + 1 ) by L499 , SCMFSA_M:2
.= ( ( C53 + 1 ) + ( D171 . D168 ) ) by L479 , L502 , L509;
thus L516: ( ( D181 . ( C53 + 1 ) ) . R9 ) = ( ( IExec (( Stop ( SCM+FSA ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . R9 ) by L503 , L493 , L514 , SCMFSA8B:40
.= ( D171 . R9 ) by L457 , L499 , L497 , L512 , SCMFSA_M:2;
thus L517: ( ( D181 . ( C53 + 1 ) ) . D168 ) = ( ( IExec (( Stop ( SCM+FSA ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D168 ) by L456 , L503 , L495 , L514 , SCMFSA8B:40
.= ( D171 . D168 ) by L499 , L501 , L510 , SCMFSA_M:2;
thus L518: ( ( D181 . ( C53 + 1 ) ) . D169 ) = ( ( IExec (( Stop ( SCM+FSA ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D169 ) by L449 , L503 , L494 , L514 , SCMFSA8B:40
.= ( D171 . D169 ) by L499 , L500 , L511 , SCMFSA_M:2;
end;
suppose L519: ( D183 . D174 ) > ( D183 . D175 );

L520: ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D173 ) = ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D173 )
.= ( ( Exec (( R3 := D173 ) , ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) )) ) . D173 ) by SCMFSA6C:5
.= ( ( Exec (( R3 := D173 ) , ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) )) ) . D173 )
.= ( ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) ) . D173 ) by L461 , SCMFSA_2:63
.= ( ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . D173 ) by SCMFSA_M:37;
thus L521: ( ( D181 . ( C53 + 1 ) ) . D173 ) = ( ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D173 ) + 1 ) by L442 , L503 , L496 , L519 , SCMFSA8B:40
.= ( ( ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) . D173 ) + 1 ) by L520
.= ( ( C53 + 1 ) + ( D171 . D168 ) ) by L479 , L502 , L509;
thus L522: ( ( D181 . ( C53 + 1 ) ) . R9 ) = ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . R9 ) by L503 , L493 , L519 , SCMFSA8B:40
.= ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . R9 )
.= ( ( Exec (( R3 := D173 ) , ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) )) ) . R9 ) by SCMFSA6C:5
.= ( ( Exec (( R3 := D173 ) , ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) )) ) . R9 )
.= ( ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) ) . R9 ) by SCMFSA_2:63
.= ( D171 . R9 ) by L457 , L497 , L512 , SCMFSA_M:37;
thus L523: ( ( D181 . ( C53 + 1 ) ) . D168 ) = ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D168 ) by L456 , L503 , L495 , L519 , SCMFSA8B:40
.= ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D168 )
.= ( ( Exec (( R3 := D173 ) , ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) )) ) . D168 ) by SCMFSA6C:5
.= ( ( Exec (( R3 := D173 ) , ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) )) ) . D168 )
.= ( ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) ) . D168 ) by L436 , SCMFSA_2:63
.= ( D171 . D168 ) by L439 , L498 , L501 , L510 , SCMFSA_M:9 , SCMFSA_M:37;
thus L524: ( ( D181 . ( C53 + 1 ) ) . D169 ) = ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D169 ) by L449 , L503 , L494 , L519 , SCMFSA8B:40
.= ( ( IExec (( Macro ( R3 := D173 ) ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) )) ) . D169 )
.= ( ( Exec (( R3 := D173 ) , ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) )) ) . D169 ) by SCMFSA6C:5
.= ( ( Exec (( R3 := D173 ) , ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) )) ) . D169 )
.= ( ( Initialized ( IExec (( D176 ";" D177 ) , ( D172 +* ( while>0 (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( ( D179 ";" ( AddTo (D173 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D173 , D168 , D169 } \/ ( UsedIntLoc D179 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D181 . C53 )) ) ) . D169 ) by L437 , SCMFSA_2:63
.= ( D171 . D169 ) by L440 , L498 , L500 , L511 , SCMFSA_M:9 , SCMFSA_M:37;
end;
end;

end;

end;
end;
L509: S3[ ( 0 ) ];
L510: (for B11 being (Element of ( NAT )) holds S3[ B11 ]) from NAT_1:sch 1(L509 , L475);
L511: ( DataPart ( IExec (D180 , D172 , D171) ) ) = ( DataPart ( D181 . D182 ) ) by L462 , L450 , L441 , L350;
thus L512: ( ( IExec (( FinSeqMin (R9 , R4 , R5 , R3) ) , R15 , R1) ) . R9 ) = ( ( IExec (D180 , D172 , D171) ) . R9 ) by L463 , SFMASTR1:15
.= ( ( D181 . D182 ) . R9 ) by L511 , SCMFSA_M:2
.= ( R1 . R9 ) by L457 , L473 , L510;
thus L513: ( ( IExec (( FinSeqMin (R9 , R4 , R5 , R3) ) , R15 , R1) ) . R4 ) = ( ( IExec (D180 , D172 , D171) ) . D168 ) by L463 , SFMASTR1:14
.= ( ( D181 . D182 ) . D168 ) by L511 , SCMFSA_M:2
.= ( R1 . R4 ) by L450 , L473 , L510;
thus L514: ( ( IExec (( FinSeqMin (R9 , R4 , R5 , R3) ) , R15 , R1) ) . R5 ) = ( ( IExec (D180 , D172 , D171) ) . D169 ) by L463 , SFMASTR1:14
.= ( ( D181 . D182 ) . D169 ) by L511 , SCMFSA_M:2
.= ( R1 . R5 ) by L441 , L473 , L510;
end;
end;
theorem
L516: (for R1 being (State of ( SCM+FSA )) holds (for R3 being  read-write Int-Location holds (for R4 being Int-Location holds (for R5 being Int-Location holds (for R9 being FinSeq-Location holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds ((1 <= ( R1 . R4 ) & ( R1 . R4 ) <= ( R1 . R5 ) & ( R1 . R5 ) <= ( len ( R1 . R9 ) ) & R4 <> R3 & R5 <> R3 & ( R1 . ( intloc ( 0 ) ) ) = 1) implies ( ( IExec (( FinSeqMin (R9 , R4 , R5 , R3) ) , R15 , R1) ) . R3 ) = ( min_at (( R1 . R9 ) , ( abs ( R1 . R4 ) ) , ( abs ( R1 . R5 ) )) ))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R3 being  read-write Int-Location;
let R4 being Int-Location;
let R5 being Int-Location;
let R9 being FinSeq-Location;
let R15 being (Instruction-Sequence of ( SCM+FSA ));
set D187 = R4;
set D188 = R5;
assume that
L517: 1 <= ( R1 . D187 )
and
L518: ( R1 . D187 ) <= ( R1 . D188 )
and
L519: ( R1 . D188 ) <= ( len ( R1 . R9 ) )
and
L520: D187 <> R3
and
L521: D188 <> R3
and
L522: ( R1 . ( intloc ( 0 ) ) ) = 1;
L523: (D188 = ( intloc ( 0 ) ) or D188 is  read-write) by SCMFSA_M:def 2;
set D189 = ( R3 := D187 );
set D190 = ( Exec (D189 , ( Initialized R1 )) );
set D191 = R15;
L524: (D187 = ( intloc ( 0 ) ) or D187 is  read-write) by SCMFSA_M:def 2;
reconsider D192 = ( abs ( R1 . D187 ) ) as (Element of ( NAT ));
L525: ( R1 . D187 ) = D192 by L517 , ABSVALUE:def 1;
L526: ( ( R1 . D187 ) - ( R1 . D187 ) ) <= ( ( R1 . D188 ) - ( R1 . D187 ) ) by L518 , XREAL_1:9;
reconsider D193 = ( ( R1 . D188 ) - ( R1 . D187 ) ) as (Element of ( NAT )) by L526 , INT_1:3;
L527: ( D190 . R9 ) = ( ( Initialized R1 ) . R9 ) by SCMFSA_2:63
.= ( R1 . R9 ) by SCMFSA_M:37;
set D194 = ( D193 + 1 );
set D195 = ( 3 -rdRWNotIn { D187 , D188 , R3 } );
set D196 = ( 2 -ndRWNotIn { D187 , D188 , R3 } );
set D197 = ( 1 -stRWNotIn { D187 , D188 , R3 } );
L528: D197 <> D196 by SCMFSA_M:26;
set D198 = ( if>0 (D196 , D197 , ( Macro ( R3 := D195 ) ) , ( Stop ( SCM+FSA ) )) );
set D199 = ( D197 := (R9 , D195) );
L529: D196 <> D195 by SCMFSA_M:26;
set D200 = ( D196 := (R9 , R3) );
L530: D197 <> D195 by SCMFSA_M:26;
L531: R3 in { D187 , D188 , R3 } by ENUMSET1:def 1;
L532: D195 <> R3 by L531 , SCMFSA_M:25;
set D201 = ( ( D199 ";" D200 ) ";" D198 );
set D202 = ( for-up (D195 , D187 , D188 , D201) );
set D203 = ( StepForUp (D195 , D187 , D188 , D201 , D191 , D190) );
defpred S4[ Nat ] means ((( 0 ) < $1 & $1 <= D194) implies (( ( D203 . $1 ) . ( intloc ( 0 ) ) ) = 1 & ( ( D203 . $1 ) . D195 ) = ( $1 + ( D190 . D187 ) ) & ( ( D203 . $1 ) . R9 ) = ( D190 . R9 ) & (ex B12 being (Element of ( NAT )) st (B12 = ( ( $1 + D192 ) - 1 ) & ( ( D203 . $1 ) . R3 ) = ( min_at (( R1 . R9 ) , D192 , B12) )))));
L533: D195 in { D195 , D187 , D188 } by ENUMSET1:def 1;
L534: D195 in ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) by L533 , XBOOLE_0:def 3;
L535:  ProperForUpBody D195 , D187 , D188 , D201 , D190 , D191 by L119;
L536: D197 <> R3 by L531 , SCMFSA_M:25;
L537: D196 <> R3 by L531 , SCMFSA_M:25;
L538: ( D190 . R3 ) = ( ( Initialized R1 ) . D187 ) by SCMFSA_2:63
.= ( R1 . D187 ) by L522 , L524 , SCMFSA_M:9 , SCMFSA_M:37;
L539: ( D190 . D187 ) = ( ( Initialized R1 ) . D187 ) by L520 , SCMFSA_2:63
.= ( R1 . D187 ) by L522 , L524 , SCMFSA_M:9 , SCMFSA_M:37;
L540: ( R1 . D187 ) <= ( len ( R1 . R9 ) ) by L518 , L519 , XXREAL_0:2;
L541: D192 in ( dom ( R1 . R9 ) ) by L540 , L517 , L525 , FINSEQ_3:25;
L542: ( D190 . D188 ) = ( ( Initialized R1 ) . D188 ) by L521 , SCMFSA_2:63
.= ( R1 . D188 ) by L522 , L523 , SCMFSA_M:9 , SCMFSA_M:37;
L543: ( D190 . ( intloc ( 0 ) ) ) = ( ( Initialized R1 ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= 1 by SCMFSA_M:9;
L544: ( DataPart ( IExec (D202 , D191 , D190) ) ) = ( DataPart ( D203 . D194 ) ) by L543 , L539 , L542 , L350;
L545: R3 in { R3 , D195 } by TARSKI:def 2;
L546: R3 in ( UsedIntLoc ( R3 := D195 ) ) by L545 , SF_MASTR:14;
L547: R3 in ( UsedIntLoc ( Macro ( R3 := D195 ) ) ) by L546 , SF_MASTR:28;
L548: R3 in ( { D196 , D197 } \/ ( UsedIntLoc ( Macro ( R3 := D195 ) ) ) ) by L547 , XBOOLE_0:def 3;
L549: R3 in ( ( { D196 , D197 } \/ ( UsedIntLoc ( Macro ( R3 := D195 ) ) ) ) \/ ( UsedIntLoc ( Stop ( SCM+FSA ) ) ) ) by L548 , XBOOLE_0:def 3;
L550: R3 in ( UsedIntLoc D198 ) by L549 , L37;
L551: R3 in ( ( UsedIntLoc ( D199 ";" D200 ) ) \/ ( UsedIntLoc D198 ) ) by L550 , XBOOLE_0:def 3;
L552: R3 in ( UsedIntLoc D201 ) by L551 , SF_MASTR:27;
L553: R3 in ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) by L552 , XBOOLE_0:def 3;
L554: (for B13 being (Element of ( NAT )) holds (S4[ B13 ] implies S4[ ( B13 + 1 ) ]))
proof
let C54 being (Element of ( NAT ));
assume that
L555: S4[ C54 ]
and
L556: ( 0 ) < ( C54 + 1 )
and
L557: ( C54 + 1 ) <= D194;
L558: (( ( D203 . C54 ) . ( intloc ( 0 ) ) ) = 1 & ( ( D203 . C54 ) . D195 ) = ( C54 + ( D190 . D187 ) ) & ( ( D203 . C54 ) . D195 ) <= ( D190 . D188 ))
proof
per cases ;
suppose L559: ( 0 ) = C54;

thus L560: ( ( D203 . C54 ) . ( intloc ( 0 ) ) ) = 1 by L559 , L543 , L53;
thus L561: ( ( D203 . C54 ) . D195 ) = ( C54 + ( D190 . D187 ) ) by L559 , L57;
thus L562: thesis by L518 , L539 , L542 , L559 , L57;
end;
suppose L563: ( 0 ) < C54;

thus L564: ( ( D203 . C54 ) . ( intloc ( 0 ) ) ) = 1 by L563 , L555 , L557 , NAT_1:13;
thus L565: ( ( D203 . C54 ) . D195 ) = ( C54 + ( D190 . D187 ) ) by L555 , L557 , L563 , NAT_1:13;
L566: ( ( C54 + 1 ) - 1 ) <= ( ( ( ( R1 . D188 ) - ( R1 . D187 ) ) + 1 ) - 1 ) by L557 , XREAL_1:9;
thus L567: thesis by L566 , L539 , L542 , L555 , L563 , NAT_1:13 , XREAL_1:19;
end;
end;
set D204 = ( Initialized ( D203 . C54 ) );
set D205 = ( Exec (D199 , D204) );
set D206 = ( Exec (D200 , ( Exec (D199 , D204) )) );
L569: ( ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . R9 ) = ( D206 . R9 ) by SCMFSA6C:9
.= ( D205 . R9 ) by SCMFSA_2:72
.= ( D204 . R9 ) by SCMFSA_2:72;
L570: ( ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . ( intloc ( 0 ) ) ) = ( D206 . ( intloc ( 0 ) ) ) by SCMFSA6C:8
.= ( D205 . ( intloc ( 0 ) ) ) by SCMFSA_2:72
.= ( D204 . ( intloc ( 0 ) ) ) by SCMFSA_2:72
.= 1 by SCMFSA_M:9;
L571: ( DataPart ( IExec (( Stop ( SCM+FSA ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) ) = ( DataPart ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) ) by L570 , L5;
L572: C54 < ( C54 + 1 ) by XREAL_1:29;
L573: C54 < D194 by L572 , L557 , XXREAL_0:2;
L574: ( ( D203 . ( C54 + 1 ) ) | ( ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) \/ ( FinSeq-Locations ) ) ) = ( ( IExec (( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) | ( ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) \/ ( FinSeq-Locations ) ) ) by L573 , L543 , L539 , L542 , L535 , L189;
L575: ( ( D203 . ( C54 + 1 ) ) . R9 ) = ( ( IExec (( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . R9 ) by L574 , SCMFSA_M:28
.= ( ( Exec (( AddTo (D195 , ( intloc ( 0 ) )) ) , ( IExec (D201 , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . R9 ) by SFMASTR1:12
.= ( ( IExec (D201 , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . R9 ) by SCMFSA_2:64
.= ( ( IExec (D198 , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . R9 ) by SFMASTR1:8;
L576: ( ( D203 . ( C54 + 1 ) ) . R3 ) = ( ( IExec (( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . R3 ) by L553 , L574 , SCMFSA_M:28
.= ( ( Exec (( AddTo (D195 , ( intloc ( 0 ) )) ) , ( IExec (D201 , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . R3 ) by SFMASTR1:11
.= ( ( IExec (D201 , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . R3 ) by L532 , SCMFSA_2:64
.= ( ( IExec (D198 , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . R3 ) by SFMASTR1:7;
L577: ( ( D203 . ( C54 + 1 ) ) . D195 ) = ( ( IExec (( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . D195 ) by L534 , L574 , SCMFSA_M:28
.= ( ( Exec (( AddTo (D195 , ( intloc ( 0 ) )) ) , ( IExec (D201 , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . D195 ) by SFMASTR1:11
.= ( ( ( IExec (D201 , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . D195 ) + ( ( IExec (D201 , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . ( intloc ( 0 ) ) ) ) by SCMFSA_2:64
.= ( ( ( IExec (D201 , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . D195 ) + 1 ) by SCMFSA6B:11
.= ( ( ( IExec (D198 , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . D195 ) + 1 ) by SFMASTR1:7;
L578: ((not ( Macro ( R3 := D195 ) ) refer D196) & (not ( Stop ( SCM+FSA ) ) refer D196)) by L529 , L8 , L13 , SCMFSA8C:51;
L579: ( ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . R3 ) = ( D206 . R3 ) by SCMFSA6C:8
.= ( D205 . R3 ) by L537 , SCMFSA_2:72
.= ( D204 . R3 ) by L536 , SCMFSA_2:72
.= ( ( D203 . C54 ) . R3 ) by SCMFSA_M:37;
L580: ( ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . D195 ) = ( D206 . D195 ) by SCMFSA6C:8
.= ( D205 . D195 ) by L529 , SCMFSA_2:72
.= ( D204 . D195 ) by L530 , SCMFSA_2:72;
per cases ;
suppose L581: ( 0 ) = C54;

thus L582: thesis
proof
reconsider D207 = ( ( ( C54 + 1 ) + D192 ) - 1 ) as (Element of ( NAT )) by L581;
L583: ( ( D203 . ( 0 ) ) . R3 ) = ( D190 . R3 ) by L532 , L552 , L74;
L584: ( D205 . R3 ) = ( D204 . R3 ) by L536 , SCMFSA_2:72
.= ( R1 . D187 ) by L538 , L581 , L583 , SCMFSA_M:37;
thus L585: ( ( D203 . ( C54 + 1 ) ) . ( intloc ( 0 ) ) ) = 1 by L543 , L539 , L542 , L535 , L557 , L138;
L586: ( D204 . R9 ) = ( ( D203 . ( 0 ) ) . R9 ) by L581 , SCMFSA_M:37
.= ( R1 . R9 ) by L527 , L81;
L587: ( D205 . R9 ) = ( R1 . R9 ) by L586 , SCMFSA_2:72;
L588: ( D204 . D195 ) = ( ( D203 . ( 0 ) ) . D195 ) by L581 , SCMFSA_M:37
.= ( R1 . D187 ) by L539 , L57;
reconsider D208 = ( D204 . D195 ) as (Element of ( NAT )) by L588 , L517 , INT_1:3;
L589: ( ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . D197 ) = ( D206 . D197 ) by SCMFSA6C:8
.= ( D205 . D197 ) by L528 , SCMFSA_2:72
.= ( ( D204 . R9 ) /. ( abs ( D204 . D195 ) ) ) by L28
.= ( ( R1 . R9 ) . D208 ) by L525 , L541 , L586 , L588 , PARTFUN1:def 6;
L590: ( ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . D196 ) = ( D206 . D196 ) by SCMFSA6C:8
.= ( ( D205 . R9 ) /. ( abs ( D205 . R3 ) ) ) by L28
.= ( ( R1 . R9 ) . D208 ) by L525 , L541 , L588 , L587 , L584 , PARTFUN1:def 6;
thus L591: ( ( D203 . ( C54 + 1 ) ) . D195 ) = ( ( ( IExec (( Stop ( SCM+FSA ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . D195 ) + 1 ) by L590 , L529 , L578 , L577 , L589 , SCMFSA8B:40
.= ( ( C54 + 1 ) + ( D190 . D187 ) ) by L539 , L571 , L580 , L581 , L588 , SCMFSA_M:2;
thus L592: ( ( D203 . ( C54 + 1 ) ) . R9 ) = ( ( IExec (( Stop ( SCM+FSA ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . R9 ) by L578 , L575 , L589 , L590 , SCMFSA8B:40
.= ( D190 . R9 ) by L527 , L571 , L569 , L586 , SCMFSA_M:2;
take D207;
thus L593: D207 = ( ( ( C54 + 1 ) + D192 ) - 1 );
L594: ( ( D203 . ( C54 + 1 ) ) . R3 ) = ( ( IExec (( Stop ( SCM+FSA ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . R3 ) by L537 , L578 , L576 , L589 , L590 , SCMFSA8B:40
.= ( R1 . D187 ) by L538 , L571 , L579 , L581 , L583 , SCMFSA_M:2;
thus L595: thesis by L594 , L517 , L540 , L525 , L581 , GRAPH_2:60;
end;

end;
suppose L583: ( 0 ) < C54;

thus L584: thesis
proof
L585: ( D204 . D195 ) = ( ( D203 . C54 ) . D195 ) by SCMFSA_M:37;
reconsider D209 = ( D204 . D195 ) as (Element of ( NAT )) by L585 , L517 , L539 , L558 , INT_1:3;
L586: (1 <= D209 & D209 <= ( len ( R1 . R9 ) )) by L517 , L519 , L525 , L539 , L542 , L558 , L585 , NAT_1:12 , XXREAL_0:2;
L587: D209 in ( dom ( R1 . R9 ) ) by L586 , FINSEQ_3:25;
L588: ( D204 . R9 ) = ( R1 . R9 ) by L527 , L555 , L557 , L583 , NAT_1:13 , SCMFSA_M:37;
L589: ( D205 . R9 ) = ( R1 . R9 ) by L588 , SCMFSA_2:72;
L590: ( ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . D197 ) = ( D206 . D197 ) by SCMFSA6C:8
.= ( D205 . D197 ) by L528 , SCMFSA_2:72
.= ( ( D204 . R9 ) /. ( abs ( D204 . D195 ) ) ) by L28
.= ( ( D204 . R9 ) /. D209 ) by ABSVALUE:def 1
.= ( ( R1 . R9 ) . D209 ) by L588 , L587 , PARTFUN1:def 6;
L591: ( C54 + ( R1 . D187 ) ) <= ( len ( R1 . R9 ) ) by L519 , L539 , L542 , L558 , XXREAL_0:2;
L592: ( ( C54 + ( R1 . D187 ) ) - 1 ) <= ( ( len ( R1 . R9 ) ) - 1 ) by L591 , XREAL_1:9;
L593: ( ( ( C54 + ( R1 . D187 ) ) - 1 ) + ( 0 ) ) <= ( ( ( len ( R1 . R9 ) ) - 1 ) + 1 ) by L592 , XREAL_1:7;
thus L594: ( ( D203 . ( C54 + 1 ) ) . ( intloc ( 0 ) ) ) = 1 by L543 , L539 , L542 , L535 , L557 , L138;
consider C55 being (Element of ( NAT )) such that L595: C55 = ( ( C54 + D192 ) - 1 ) and L596: ( ( D203 . C54 ) . R3 ) = ( min_at (( R1 . R9 ) , D192 , C55) ) by L555 , L557 , L583 , NAT_1:13;
reconsider D210 = ( ( D203 . C54 ) . R3 ) as (Element of ( NAT )) by L596;
L597: ( ( 0 ) + 1 ) <= C54 by L583 , NAT_1:13;
L598: ( 1 - 1 ) <= ( C54 - 1 ) by L597 , XREAL_1:9;
L599: ( ( 0 ) + ( R1 . D187 ) ) <= ( ( C54 - 1 ) + ( R1 . D187 ) ) by L598 , XREAL_1:6;
L600: D192 <= D210 by L599 , L517 , L525 , L595 , L596 , L593 , GRAPH_2:59;
L601: 1 <= D210 by L600 , L517 , L525 , XXREAL_0:2;
L602: D210 <= C55 by L517 , L525 , L595 , L596 , L599 , L593 , GRAPH_2:59;
L603: D210 <= ( len ( R1 . R9 ) ) by L602 , L525 , L595 , L593 , XXREAL_0:2;
L604: D210 in ( dom ( R1 . R9 ) ) by L603 , L601 , FINSEQ_3:25;
L605: ( ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . D196 ) = ( D206 . D196 ) by SCMFSA6C:8
.= ( ( D205 . R9 ) /. ( abs ( D205 . R3 ) ) ) by L28
.= ( ( D205 . R9 ) /. ( abs ( D204 . R3 ) ) ) by L536 , SCMFSA_2:72
.= ( ( D205 . R9 ) /. ( abs ( ( D203 . C54 ) . R3 ) ) ) by SCMFSA_M:37
.= ( ( D205 . R9 ) /. D210 ) by ABSVALUE:def 1
.= ( ( R1 . R9 ) . D210 ) by L589 , L604 , PARTFUN1:def 6;
L606: (for R13 being (Element of ( NAT )) holds ((D192 <= R13 & R13 < ( ( D203 . C54 ) . R3 )) implies ( ( R1 . R9 ) . R13 ) > ( ( R1 . R9 ) . D210 ))) by L517 , L525 , L595 , L596 , L599 , L593 , GRAPH_2:59;
thus L607: thesis
proof
L608: ( ( ( C54 + 1 ) + ( R1 . D187 ) ) - 1 ) <= ( len ( R1 . R9 ) ) by L519 , L539 , L542 , L558 , XXREAL_0:2;
L609: ( ( ( C54 + 1 ) + ( R1 . D187 ) ) - 1 ) = ( ( ( C54 + ( R1 . D187 ) ) + 1 ) - 1 )
.= ( C54 + D192 ) by L517 , ABSVALUE:def 1;
L610: ( R1 . D187 ) <= ( ( ( C54 + 1 ) + ( R1 . D187 ) ) - 1 ) by L609 , NAT_1:12;
per cases ;
suppose L611: ( ( R1 . R9 ) . D209 ) < ( ( R1 . R9 ) . D210 );

L612: ( ( IExec (( Macro ( R3 := D195 ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . D195 ) = ( ( IExec (( Macro ( R3 := D195 ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . D195 )
.= ( ( Exec (( R3 := D195 ) , ( Initialized ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) )) ) . D195 ) by SCMFSA6C:5
.= ( ( Exec (( R3 := D195 ) , ( Initialized ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) )) ) . D195 )
.= ( ( Initialized ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) ) . D195 ) by L532 , SCMFSA_2:63;
thus L613: ( ( D203 . ( C54 + 1 ) ) . D195 ) = ( ( ( IExec (( Macro ( R3 := D195 ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . D195 ) + 1 ) by L529 , L578 , L577 , L590 , L605 , L611 , SCMFSA8B:40
.= ( ( ( Initialized ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) ) . D195 ) + 1 ) by L612
.= ( ( ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . D195 ) + 1 ) by SCMFSA_M:37
.= ( ( C54 + 1 ) + ( D190 . D187 ) ) by L558 , L580 , L585;
thus L614: ( ( D203 . ( C54 + 1 ) ) . R9 ) = ( ( IExec (( Macro ( R3 := D195 ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . R9 ) by L578 , L575 , L590 , L605 , L611 , SCMFSA8B:40
.= ( ( IExec (( Macro ( R3 := D195 ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . R9 )
.= ( ( Exec (( R3 := D195 ) , ( Initialized ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) )) ) . R9 ) by SCMFSA6C:5
.= ( ( Exec (( R3 := D195 ) , ( Initialized ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) )) ) . R9 )
.= ( ( Initialized ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) ) . R9 ) by SCMFSA_2:63
.= ( D190 . R9 ) by L527 , L569 , L588 , SCMFSA_M:37;
reconsider D211 = ( ( ( C54 + 1 ) + D192 ) - 1 ) as (Element of ( NAT )) by L609;
take D211;
thus L615: D211 = ( ( ( C54 + 1 ) + D192 ) - 1 );
L616: (for R13 being (Element of ( NAT )) holds ((( R1 . D187 ) <= R13 & R13 <= ( ( ( C54 + 1 ) + ( R1 . D187 ) ) - 1 )) implies ( ( R1 . R9 ) . D209 ) <= ( ( R1 . R9 ) . R13 )))
proof
let R13 being (Element of ( NAT ));
assume that
L617: ( R1 . D187 ) <= R13
and
L618: R13 <= ( ( ( C54 + 1 ) + ( R1 . D187 ) ) - 1 );
per cases  by L618 , XXREAL_0:1;
suppose L619: R13 < ( ( ( C54 + 1 ) + ( R1 . D187 ) ) - 1 );

L620: ( R13 + 1 ) <= ( C54 + ( R1 . D187 ) ) by L619 , L609 , NAT_1:13;
L621: ( ( R13 + 1 ) - 1 ) <= ( ( C54 + ( R1 . D187 ) ) - 1 ) by L620 , XREAL_1:9;
L622: ( ( R1 . R9 ) . D210 ) <= ( ( R1 . R9 ) . R13 ) by L621 , L517 , L525 , L595 , L596 , L599 , L593 , L617 , GRAPH_2:59;
thus L623: thesis by L622 , L611 , XXREAL_0:2;
end;
suppose L624: R13 = ( ( ( C54 + 1 ) + ( R1 . D187 ) ) - 1 );

thus L625: thesis by L624 , L539 , L558 , SCMFSA_M:37;
end;
end;
L627: (for R13 being (Element of ( NAT )) holds ((( R1 . D187 ) <= R13 & R13 < D209) implies ( ( R1 . R9 ) . R13 ) > ( ( R1 . R9 ) . D209 )))
proof
let R13 being (Element of ( NAT ));
assume that
L628: ( R1 . D187 ) <= R13
and
L629: R13 < D209;
L630: ( R13 + 1 ) <= D209 by L629 , NAT_1:13;
L631: ( ( R13 + 1 ) - 1 ) <= ( D209 - 1 ) by L630 , XREAL_1:9;
L632: ( ( R1 . R9 ) . D210 ) <= ( ( R1 . R9 ) . R13 ) by L631 , L517 , L525 , L539 , L558 , L585 , L595 , L596 , L599 , L593 , L628 , GRAPH_2:59;
thus L633: thesis by L632 , L611 , XXREAL_0:2;
end;
L634: ( ( D203 . ( C54 + 1 ) ) . R3 ) = ( ( IExec (( Macro ( R3 := D195 ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . R3 ) by L537 , L578 , L576 , L590 , L605 , L611 , SCMFSA8B:40
.= ( ( IExec (( Macro ( R3 := D195 ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . R3 )
.= ( ( Exec (( R3 := D195 ) , ( Initialized ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) )) ) . R3 ) by SCMFSA6C:5
.= ( ( Exec (( R3 := D195 ) , ( Initialized ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) )) ) . R3 )
.= ( ( Initialized ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) ) . D195 ) by SCMFSA_2:63
.= D209 by L580 , SCMFSA_M:37;
thus L635: thesis by L634 , L517 , L525 , L539 , L558 , L585 , L610 , L608 , L616 , L627 , GRAPH_2:59;
end;
suppose L636: ( ( R1 . R9 ) . D210 ) <= ( ( R1 . R9 ) . D209 );

thus L637: thesis
proof
L638: (for R13 being (Element of ( NAT )) holds ((( R1 . D187 ) <= R13 & R13 <= ( ( ( C54 + 1 ) + ( R1 . D187 ) ) - 1 )) implies ( ( R1 . R9 ) . D210 ) <= ( ( R1 . R9 ) . R13 )))
proof
let R13 being (Element of ( NAT ));
assume that
L639: ( R1 . D187 ) <= R13
and
L640: R13 <= ( ( ( C54 + 1 ) + ( R1 . D187 ) ) - 1 );
per cases  by L640 , XXREAL_0:1;
suppose L641: R13 < ( ( ( C54 + 1 ) + ( R1 . D187 ) ) - 1 );

L642: ( R13 + 1 ) <= ( C54 + ( R1 . D187 ) ) by L641 , L609 , NAT_1:13;
L643: ( ( R13 + 1 ) - 1 ) <= ( ( C54 + ( R1 . D187 ) ) - 1 ) by L642 , XREAL_1:9;
thus L644: thesis by L643 , L517 , L525 , L595 , L596 , L599 , L593 , L639 , GRAPH_2:59;
end;
suppose L645: R13 = ( ( ( C54 + 1 ) + ( R1 . D187 ) ) - 1 );

thus L646: thesis by L645 , L539 , L558 , L636 , SCMFSA_M:37;
end;
end;
thus L648: ( ( D203 . ( C54 + 1 ) ) . D195 ) = ( ( ( IExec (( Stop ( SCM+FSA ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . D195 ) + 1 ) by L529 , L578 , L577 , L590 , L605 , L636 , SCMFSA8B:40
.= ( ( ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) ) . D195 ) + 1 ) by L571 , SCMFSA_M:2
.= ( ( C54 + 1 ) + ( D190 . D187 ) ) by L558 , L580 , L585;
thus L649: ( ( D203 . ( C54 + 1 ) ) . R9 ) = ( ( IExec (( Stop ( SCM+FSA ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . R9 ) by L578 , L575 , L590 , L605 , L636 , SCMFSA8B:40
.= ( D190 . R9 ) by L527 , L571 , L569 , L588 , SCMFSA_M:2;
reconsider D212 = ( ( ( C54 + 1 ) + D192 ) - 1 ) as (Element of ( NAT )) by L609;
take D212;
thus L650: D212 = ( ( ( C54 + 1 ) + D192 ) - 1 );
L651: ( ( C54 + ( R1 . D187 ) ) - 1 ) <= ( ( ( C54 + ( R1 . D187 ) ) - 1 ) + 1 ) by XREAL_1:29;
L652: D210 <= ( ( ( C54 + 1 ) + ( R1 . D187 ) ) - 1 ) by L651 , L525 , L595 , L602 , XXREAL_0:2;
L653: ( ( D203 . ( C54 + 1 ) ) . R3 ) = ( ( IExec (( Stop ( SCM+FSA ) ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (( D199 ";" D200 ) , ( D191 +* ( while>0 (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( ( D201 ";" ( AddTo (D195 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D195 , D187 , D188 } \/ ( UsedIntLoc D201 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D203 . C54 )) )) ) . R3 ) by L537 , L578 , L576 , L590 , L605 , L636 , SCMFSA8B:40
.= ( ( D203 . C54 ) . R3 ) by L571 , L579 , SCMFSA_M:2;
thus L654: thesis by L653 , L517 , L525 , L600 , L606 , L610 , L608 , L652 , L638 , GRAPH_2:59;
end;

end;
end;

end;

end;
end;
reconsider D213 = ( abs ( R1 . D188 ) ) as (Element of ( NAT ));
L586: S4[ ( 0 ) ];
L587: (for B14 being (Element of ( NAT )) holds S4[ B14 ]) from NAT_1:sch 1(L586 , L554);
consider C56 being (Element of ( NAT )) such that L588: C56 = ( ( D194 + D192 ) - 1 ) and L589: ( ( D203 . D194 ) . R3 ) = ( min_at (( R1 . R9 ) , D192 , C56) ) by L587;
L590: C56 = D213 by L525 , L588 , ABSVALUE:def 1;
L591: (D202 is_closed_on D190 , D191 & D202 is_halting_on D190 , D191) by L543 , L378;
thus L592: ( ( IExec (( FinSeqMin (R9 , D187 , D188 , R3) ) , R15 , R1) ) . R3 ) = ( ( IExec (D202 , D191 , D190) ) . R3 ) by L591 , SFMASTR1:14
.= ( min_at (( R1 . R9 ) , ( abs ( R1 . D187 ) ) , ( abs ( R1 . D188 ) )) ) by L544 , L589 , L590 , SCMFSA_M:2;
end;
begin
definition
let C57 being FinSeq-Location;
let C58 , C59 being Int-Location;
func swap (C57 , C58 , C59) -> (Program of ( SCM+FSA )) equals 
( ( ( ( ( 1 -stRWNotIn { C58 , C59 } ) := (C57 , C58) ) ";" ( ( 2 -ndRWNotIn { C58 , C59 } ) := (C57 , C59) ) ) ";" ( (C57 , C58) := ( 2 -ndRWNotIn { C58 , C59 } ) ) ) ";" ( (C57 , C59) := ( 1 -stRWNotIn { C58 , C59 } ) ) );
coherence;
end;
registration
let C60 being FinSeq-Location;
let C61 , C62 being Int-Location;
cluster ( swap (C60 , C61 , C62) ) ->  good  parahalting;
coherence;
end;
theorem
L595: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R9 being FinSeq-Location holds ((R6 <> ( 1 -stRWNotIn { R4 , R5 } ) & R6 <> ( 2 -ndRWNotIn { R4 , R5 } )) implies (not ( swap (R9 , R4 , R5) ) destroy R6))))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R9 being FinSeq-Location;
set D214 = R4;
set D215 = R5;
set D216 = ( 1 -stRWNotIn { D214 , D215 } );
set D217 = ( 2 -ndRWNotIn { D214 , D215 } );
assume L596: (R6 <> ( 1 -stRWNotIn { R4 , R5 } ) & R6 <> ( 2 -ndRWNotIn { R4 , R5 } ));
L597: ((not ( D216 := (R9 , D214) ) destroy R6) & (not ( D217 := (R9 , D215) ) destroy R6)) by L596 , SCMFSA7B:14;
L598: (not ( (R9 , D214) := D217 ) destroy R6) by SCMFSA7B:15;
L599: (not ( ( ( D216 := (R9 , D214) ) ";" ( D217 := (R9 , D215) ) ) ";" ( (R9 , D214) := D217 ) ) destroy R6) by L598 , L597 , SCMFSA8C:54 , SCMFSA8C:55;
thus L600: thesis by L599 , SCMFSA7B:15 , SCMFSA8C:54;
end;
theorem
L601: (for R1 being (State of ( SCM+FSA )) holds (for R4 being Int-Location holds (for R5 being Int-Location holds (for R9 being FinSeq-Location holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds ((1 <= ( R1 . R4 ) & ( R1 . R4 ) <= ( len ( R1 . R9 ) ) & 1 <= ( R1 . R5 ) & ( R1 . R5 ) <= ( len ( R1 . R9 ) ) & ( R1 . ( intloc ( 0 ) ) ) = 1) implies ( ( IExec (( swap (R9 , R4 , R5) ) , R15 , R1) ) . R9 ) = ( ( ( R1 . R9 ) +* (( R1 . R4 ) , ( ( R1 . R9 ) . ( R1 . R5 ) )) ) +* (( R1 . R5 ) , ( ( R1 . R9 ) . ( R1 . R4 ) )) )))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being Int-Location;
let R5 being Int-Location;
let R9 being FinSeq-Location;
let R15 being (Instruction-Sequence of ( SCM+FSA ));
set D218 = R4;
set D219 = R5;
assume that
L602: 1 <= ( R1 . D218 )
and
L603: ( R1 . D218 ) <= ( len ( R1 . R9 ) )
and
L604: 1 <= ( R1 . D219 )
and
L605: ( R1 . D219 ) <= ( len ( R1 . R9 ) )
and
L606: ( R1 . ( intloc ( 0 ) ) ) = 1;
set D220 = ( 1 -stRWNotIn { D218 , D219 } );
set D221 = ( 2 -ndRWNotIn { D218 , D219 } );
set D222 = ( D220 := (R9 , D218) );
set D223 = ( D221 := (R9 , D219) );
set D224 = ( (R9 , D218) := D221 );
set D225 = ( Initialized R1 );
set D226 = ( Exec (D222 , D225) );
set D227 = ( IExec (( D222 ";" D223 ) , R15 , R1) );
L607: (D219 = ( intloc ( 0 ) ) or D219 is  read-write) by SCMFSA_M:def 2;
reconsider D228 = ( R1 . D218 ) as (Element of ( NAT )) by L602 , INT_1:3;
set D229 = ( abs ( D225 . D218 ) );
set D230 = ( abs ( D227 . D218 ) );
L608: (D218 = ( intloc ( 0 ) ) or D218 is  read-write) by SCMFSA_M:def 2;
L609: D228 = ( abs ( R1 . D218 ) ) by ABSVALUE:def 1;
L610: (( D225 . R9 ) = ( R1 . R9 ) & D228 = D229) by L609 , L606 , L608 , SCMFSA_M:9 , SCMFSA_M:37;
reconsider D231 = ( R1 . D219 ) as (Element of ( NAT )) by L604 , INT_1:3;
L611: D231 = ( abs ( R1 . D219 ) ) by ABSVALUE:def 1;
set D232 = ( IExec (( ( D222 ";" D223 ) ";" D224 ) , R15 , R1) );
L612: D220 <> D221 by SCMFSA_M:26;
L613: ( D232 . D220 ) = ( ( Exec (D224 , D227) ) . D220 ) by SCMFSA6C:6
.= ( D227 . D220 ) by SCMFSA_2:73
.= ( ( Exec (D223 , D226) ) . D220 ) by SCMFSA6C:8
.= ( D226 . D220 ) by L612 , SCMFSA_2:72
.= ( ( D225 . R9 ) /. D229 ) by L28
.= ( ( R1 . R9 ) . D228 ) by L602 , L603 , L610 , FINSEQ_4:15;
set D233 = ( (R9 , D219) := D220 );
L614: ( D227 . R9 ) = ( ( Exec (D223 , D226) ) . R9 ) by SCMFSA6C:9
.= ( D226 . R9 ) by SCMFSA_2:72;
L615: ( D232 . R9 ) = ( ( Exec (D224 , D227) ) . R9 ) by SCMFSA6C:7
.= ( ( D227 . R9 ) +* (D230 , ( D227 . D221 )) ) by L31;
L616: D219 in { D218 , D219 } by TARSKI:def 2;
L617: D219 <> D221 by L616 , SCMFSA_M:25;
L618: D219 <> D220 by L616 , SCMFSA_M:25;
L619: ( D226 . D219 ) = ( D225 . D219 ) by L618 , SCMFSA_2:72
.= ( R1 . D219 ) by L606 , L607 , SCMFSA_M:9 , SCMFSA_M:37;
L620: D218 in { D218 , D219 } by TARSKI:def 2;
L621: D218 <> D221 by L620 , SCMFSA_M:25;
L622: D218 <> D220 by L620 , SCMFSA_M:25;
L623: ( D227 . D218 ) = ( ( Exec (D223 , D226) ) . D218 ) by SCMFSA6C:8
.= ( D226 . D218 ) by L621 , SCMFSA_2:72
.= ( D225 . D218 ) by L622 , SCMFSA_2:72;
L624: D228 = D230 by L623 , L606 , L609 , L608 , SCMFSA_M:9 , SCMFSA_M:37;
set D234 = ( abs ( D226 . D219 ) );
L625: ( D226 . R9 ) = ( D225 . R9 ) by SCMFSA_2:72
.= ( R1 . R9 ) by SCMFSA_M:37;
L626: ( D232 . D219 ) = ( ( Exec (D224 , D227) ) . D219 ) by SCMFSA6C:6
.= ( D227 . D219 ) by SCMFSA_2:73
.= ( ( Exec (D223 , D226) ) . D219 ) by SCMFSA6C:8
.= ( D226 . D219 ) by L617 , SCMFSA_2:72;
L627: ( D227 . D221 ) = ( ( Exec (D223 , D226) ) . D221 ) by SCMFSA6C:8
.= ( ( D226 . R9 ) /. D234 ) by L28
.= ( ( R1 . R9 ) . D231 ) by L604 , L605 , L611 , L625 , L619 , FINSEQ_4:15;
thus L628: ( ( IExec (( swap (R9 , D218 , D219) ) , R15 , R1) ) . R9 ) = ( ( Exec (D233 , D232) ) . R9 ) by SCMFSA6C:7
.= ( ( ( R1 . R9 ) +* (( R1 . D218 ) , ( ( R1 . R9 ) . ( R1 . D219 ) )) ) +* (( R1 . D219 ) , ( ( R1 . R9 ) . ( R1 . D218 ) )) ) by L611 , L625 , L614 , L615 , L624 , L619 , L626 , L627 , L613 , L31;
end;
theorem
L629: (for R1 being (State of ( SCM+FSA )) holds (for R4 being Int-Location holds (for R5 being Int-Location holds (for R9 being FinSeq-Location holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds ((1 <= ( R1 . R4 ) & ( R1 . R4 ) <= ( len ( R1 . R9 ) ) & 1 <= ( R1 . R5 ) & ( R1 . R5 ) <= ( len ( R1 . R9 ) ) & ( R1 . ( intloc ( 0 ) ) ) = 1) implies (( ( ( IExec (( swap (R9 , R4 , R5) ) , R15 , R1) ) . R9 ) . ( R1 . R4 ) ) = ( ( R1 . R9 ) . ( R1 . R5 ) ) & ( ( ( IExec (( swap (R9 , R4 , R5) ) , R15 , R1) ) . R9 ) . ( R1 . R5 ) ) = ( ( R1 . R9 ) . ( R1 . R4 ) ))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being Int-Location;
let R5 being Int-Location;
let R9 being FinSeq-Location;
let R15 being (Instruction-Sequence of ( SCM+FSA ));
set D235 = R4;
set D236 = R5;
assume that
L630: 1 <= ( R1 . D235 )
and
L631: ( R1 . D235 ) <= ( len ( R1 . R9 ) )
and
L632: 1 <= ( R1 . D236 )
and
L633: ( R1 . D236 ) <= ( len ( R1 . R9 ) )
and
L634: ( R1 . ( intloc ( 0 ) ) ) = 1;
L635: ( ( IExec (( swap (R9 , D235 , D236) ) , R15 , R1) ) . R9 ) = ( ( ( R1 . R9 ) +* (( R1 . D235 ) , ( ( R1 . R9 ) . ( R1 . D236 ) )) ) +* (( R1 . D236 ) , ( ( R1 . R9 ) . ( R1 . D235 ) )) ) by L630 , L631 , L632 , L633 , L634 , L601;
reconsider D237 = ( R1 . D235 ) as (Element of ( NAT )) by L630 , INT_1:3;
L636: D237 in ( dom ( R1 . R9 ) ) by L630 , L631 , FINSEQ_3:25;
L637: ( dom ( ( R1 . R9 ) +* (( R1 . D235 ) , ( ( R1 . R9 ) . ( R1 . D236 ) )) ) ) = ( dom ( R1 . R9 ) ) by FUNCT_7:30;
reconsider D238 = ( R1 . D236 ) as (Element of ( NAT )) by L632 , INT_1:3;
L638: D238 in ( dom ( R1 . R9 ) ) by L632 , L633 , FINSEQ_3:25;
per cases ;
suppose L639: D237 <> D238;

thus L640: ( ( ( IExec (( swap (R9 , D235 , D236) ) , R15 , R1) ) . R9 ) . ( R1 . D235 ) ) = ( ( ( R1 . R9 ) +* (( R1 . D235 ) , ( ( R1 . R9 ) . ( R1 . D236 ) )) ) . ( R1 . D235 ) ) by L639 , L635 , FUNCT_7:32
.= ( ( R1 . R9 ) . ( R1 . D236 ) ) by L636 , FUNCT_7:31;
thus L641: thesis by L638 , L635 , L637 , FUNCT_7:31;
end;
suppose L642: D237 = D238;

thus L643: ( ( ( IExec (( swap (R9 , D235 , D236) ) , R15 , R1) ) . R9 ) . ( R1 . D235 ) ) = ( ( R1 . R9 ) . ( R1 . D236 ) ) by L642 , L636 , L635 , L637 , FUNCT_7:31;
thus L644: thesis by L638 , L635 , L637 , FUNCT_7:31;
end;
end;
theorem
L646: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R9 being FinSeq-Location holds { R4 , R5 } c= ( UsedIntLoc ( swap (R9 , R4 , R5) ) ))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R9 being FinSeq-Location;
set D239 = R4;
set D240 = R5;
set D241 = ( 1 -stRWNotIn { D239 , D240 } );
set D242 = ( 2 -ndRWNotIn { D239 , D240 } );
set D243 = ( D241 := (R9 , D239) );
set D244 = ( D242 := (R9 , D240) );
set D245 = ( (R9 , D239) := D242 );
set D246 = ( (R9 , D240) := D241 );
L647: ( UsedIntLoc ( swap (R9 , D239 , D240) ) ) = ( ( UsedIntLoc ( ( D243 ";" D244 ) ";" D245 ) ) \/ ( UsedIntLoc D246 ) ) by SF_MASTR:30
.= ( ( ( UsedIntLoc ( D243 ";" D244 ) ) \/ ( UsedIntLoc D245 ) ) \/ ( UsedIntLoc D246 ) ) by SF_MASTR:30
.= ( ( ( ( UsedIntLoc D243 ) \/ ( UsedIntLoc D244 ) ) \/ ( UsedIntLoc D245 ) ) \/ ( UsedIntLoc D246 ) ) by SF_MASTR:31
.= ( ( ( { D241 , D239 } \/ ( UsedIntLoc D244 ) ) \/ ( UsedIntLoc D245 ) ) \/ ( UsedIntLoc D246 ) ) by SF_MASTR:17
.= ( ( ( { D241 , D239 } \/ { D242 , D240 } ) \/ ( UsedIntLoc D245 ) ) \/ ( UsedIntLoc D246 ) ) by SF_MASTR:17
.= ( ( ( { D241 , D239 } \/ { D242 , D240 } ) \/ { D242 , D239 } ) \/ ( UsedIntLoc D246 ) ) by SF_MASTR:17
.= ( ( ( { D241 , D239 } \/ { D242 , D240 } ) \/ { D242 , D239 } ) \/ { D241 , D240 } ) by SF_MASTR:17;
let C63 being set;
assume L648: C63 in { D239 , D240 };
per cases  by L648 , TARSKI:def 2;
suppose L649: C63 = D239;

L650: C63 in { D242 , D239 } by L649 , TARSKI:def 2;
L651: C63 in ( ( { D241 , D239 } \/ { D242 , D240 } ) \/ { D242 , D239 } ) by L650 , XBOOLE_0:def 3;
thus L652: thesis by L651 , L647 , XBOOLE_0:def 3;
end;
suppose L653: C63 = D240;

L654: C63 in { D241 , D240 } by L653 , TARSKI:def 2;
thus L655: thesis by L654 , L647 , XBOOLE_0:def 3;
end;
end;
theorem
L657: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R9 being FinSeq-Location holds ( UsedInt*Loc ( swap (R9 , R4 , R5) ) ) = { R9 })))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R9 being FinSeq-Location;
set D247 = R4;
set D248 = R5;
set D249 = ( 1 -stRWNotIn { D247 , D248 } );
set D250 = ( 2 -ndRWNotIn { D247 , D248 } );
thus L658: ( UsedInt*Loc ( swap (R9 , D247 , D248) ) ) = ( ( UsedInt*Loc ( ( ( D249 := (R9 , D247) ) ";" ( D250 := (R9 , D248) ) ) ";" ( (R9 , D247) := D250 ) ) ) \/ ( UsedInt*Loc ( (R9 , D248) := D249 ) ) ) by SF_MASTR:46
.= ( ( UsedInt*Loc ( ( ( D249 := (R9 , D247) ) ";" ( D250 := (R9 , D248) ) ) ";" ( (R9 , D247) := D250 ) ) ) \/ { R9 } ) by SF_MASTR:33
.= ( ( ( UsedInt*Loc ( ( D249 := (R9 , D247) ) ";" ( D250 := (R9 , D248) ) ) ) \/ ( UsedInt*Loc ( (R9 , D247) := D250 ) ) ) \/ { R9 } ) by SF_MASTR:46
.= ( ( ( UsedInt*Loc ( ( D249 := (R9 , D247) ) ";" ( D250 := (R9 , D248) ) ) ) \/ { R9 } ) \/ { R9 } ) by SF_MASTR:33
.= ( ( ( ( UsedInt*Loc ( D249 := (R9 , D247) ) ) \/ ( UsedInt*Loc ( D250 := (R9 , D248) ) ) ) \/ { R9 } ) \/ { R9 } ) by SF_MASTR:47
.= ( ( ( { R9 } \/ ( UsedInt*Loc ( D250 := (R9 , D248) ) ) ) \/ { R9 } ) \/ { R9 } ) by SF_MASTR:33
.= ( ( { R9 } \/ { R9 } ) \/ { R9 } ) by SF_MASTR:33
.= { R9 };
end;
begin
definition
let C64 being FinSeq-Location;
func Selection-sort C64 -> (Program of ( SCM+FSA )) equals 
( ( ( 1 -stNotUsed ( swap (C64 , ( 1 -stRWNotIn ( {} ( Int-Locations ) ) ) , ( 2 -ndRWNotIn ( {} ( Int-Locations ) ) )) ) ) :=len C64 ) ";" ( for-up (( 1 -stRWNotIn ( {} ( Int-Locations ) ) ) , ( intloc ( 0 ) ) , ( 1 -stNotUsed ( swap (C64 , ( 1 -stRWNotIn ( {} ( Int-Locations ) ) ) , ( 2 -ndRWNotIn ( {} ( Int-Locations ) ) )) ) ) , ( ( FinSeqMin (C64 , ( 1 -stRWNotIn ( {} ( Int-Locations ) ) ) , ( 1 -stNotUsed ( swap (C64 , ( 1 -stRWNotIn ( {} ( Int-Locations ) ) ) , ( 2 -ndRWNotIn ( {} ( Int-Locations ) ) )) ) ) , ( 2 -ndRWNotIn ( {} ( Int-Locations ) ) )) ) ";" ( swap (C64 , ( 1 -stRWNotIn ( {} ( Int-Locations ) ) ) , ( 2 -ndRWNotIn ( {} ( Int-Locations ) ) )) ) )) ) );
coherence;
end;
theorem
L660: (for R1 being (State of ( SCM+FSA )) holds (for R9 being FinSeq-Location holds (for R15 being (Instruction-Sequence of ( SCM+FSA )) holds (for B15 being (State of ( SCM+FSA )) holds (B15 = ( IExec (( Selection-sort R9 ) , R15 , R1) ) implies (( B15 . R9 ) is_non_decreasing_on 1 , ( len ( B15 . R9 ) ) & (ex B16 being (Permutation of ( dom ( R1 . R9 ) )) st ( B15 . R9 ) = ( ( R1 . R9 ) * B16 ))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R9 being FinSeq-Location;
let R15 being (Instruction-Sequence of ( SCM+FSA ));
set D251 = ( 2 -ndRWNotIn ( {} ( Int-Locations ) ) );
set D252 = ( 1 -stRWNotIn ( {} ( Int-Locations ) ) );
let C65 being (State of ( SCM+FSA ));
assume that
L661: C65 = ( IExec (( Selection-sort R9 ) , R15 , R1) );
set D253 = ( swap (R9 , D252 , D251) );
set D254 = ( 1 -stNotUsed ( swap (R9 , D252 , D251) ) );
set D255 = ( D254 :=len R9 );
set D256 = ( FinSeqMin (R9 , D252 , D254 , D251) );
set D257 = ( D256 ";" D253 );
set D258 = ( for-up (D252 , ( intloc ( 0 ) ) , D254 , D257) );
set D259 = ( Exec (D255 , ( Initialized R1 )) );
set D260 = R15;
L662: ( D259 . ( intloc ( 0 ) ) ) = ( ( Initialized R1 ) . ( intloc ( 0 ) ) ) by SCMFSA_2:74
.= 1 by SCMFSA_M:9;
L663: D252 in { D252 , D251 } by TARSKI:def 2;
L664: (D252 <> ( 1 -stRWNotIn { D252 , D251 } ) & D252 <> ( 2 -ndRWNotIn { D252 , D251 } )) by L663 , SCMFSA_M:25;
L665: (not ( swap (R9 , D252 , D251) ) destroy D252) by L664 , L595;
set D261 = ( StepForUp (D252 , ( intloc ( 0 ) ) , D254 , D257 , D260 , D259) );
L666: ( D259 . D254 ) = ( len ( ( Initialized R1 ) . R9 ) ) by SCMFSA_2:74
.= ( len ( R1 . R9 ) ) by SCMFSA_M:37;
reconsider D262 = ( ( ( D259 . D254 ) - ( D259 . ( intloc ( 0 ) ) ) ) + 1 ) as (Element of ( NAT )) by L666 , L662;
defpred S5[ (Element of ( NAT )) ] means ($1 <= D262 implies (( ( D261 . $1 ) . D252 ) = ( $1 + ( D259 . ( intloc ( 0 ) ) ) ) & ( ( D261 . $1 ) . D254 ) = ( D259 . D254 ) & ( ( D261 . $1 ) . R9 ) is_split_at $1 & ( ( D261 . $1 ) . R9 ) is_non_decreasing_on 1 , $1 & (ex B17 being (Permutation of ( dom ( R1 . R9 ) )) st ( ( D261 . $1 ) . R9 ) = ( ( R1 . R9 ) * B17 ))));
defpred S6[ Nat ] means ($1 < D262 implies (( ( D261 . $1 ) . ( intloc ( 0 ) ) ) = 1 & D257 is_closed_on ( D261 . $1 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) & D257 is_halting_on ( D261 . $1 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) )));
L667: (for B18 being (Element of ( NAT )) holds (S6[ B18 ] implies S6[ ( B18 + 1 ) ]))
proof
let C66 being (Element of ( NAT ));
assume that
L668: S6[ C66 ];
assume L669: ( C66 + 1 ) < D262;
thus L670: ( ( D261 . ( C66 + 1 ) ) . ( intloc ( 0 ) ) ) = 1 by L669 , L668 , L123 , NAT_1:13;
L671: ( ( Initialized ( D261 . ( C66 + 1 ) ) ) . ( intloc ( 0 ) ) ) = 1 by SCMFSA_M:9;
L672: (D256 is_closed_on ( Initialized ( D261 . ( C66 + 1 ) ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) & D256 is_halting_on ( Initialized ( D261 . ( C66 + 1 ) ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) )) by L671 , L425;
L673: D253 is_closed_on ( IExec (D256 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . ( C66 + 1 ) )) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by SCMFSA7B:18;
L674: D257 is_closed_on ( Initialized ( D261 . ( C66 + 1 ) ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L673 , L672 , SFMASTR1:2;
thus L675: D257 is_closed_on ( D261 . ( C66 + 1 ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L674 , L670 , SFMASTR2:4;
L676: D253 is_halting_on ( IExec (D256 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . ( C66 + 1 ) )) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by SCMFSA7B:19;
L677: D257 is_halting_on ( Initialized ( D261 . ( C66 + 1 ) ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L676 , L672 , L673 , SFMASTR1:3;
thus L678: thesis by L677 , L670 , L674 , SFMASTR2:5;
end;
L679: S6[ ( 0 ) ]
proof
L680: ( ( Initialized ( D261 . ( 0 ) ) ) . ( intloc ( 0 ) ) ) = 1 by SCMFSA_M:9;
L681: (D256 is_closed_on ( Initialized ( D261 . ( 0 ) ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) & D256 is_halting_on ( Initialized ( D261 . ( 0 ) ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) )) by L680 , L425;
assume L682: ( 0 ) < D262;
thus L683: ( ( D261 . ( 0 ) ) . ( intloc ( 0 ) ) ) = 1 by L662 , L53;
L684: D253 is_closed_on ( IExec (D256 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . ( 0 ) )) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by SCMFSA7B:18;
L685: D257 is_closed_on ( Initialized ( D261 . ( 0 ) ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L684 , L681 , SFMASTR1:2;
thus L686: D257 is_closed_on ( D261 . ( 0 ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L685 , L683 , SFMASTR2:4;
L687: D253 is_halting_on ( IExec (D256 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . ( 0 ) )) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by SCMFSA7B:19;
L688: D257 is_halting_on ( Initialized ( D261 . ( 0 ) ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L687 , L681 , L684 , SFMASTR1:3;
thus L689: thesis by L688 , L683 , L685 , SFMASTR2:5;
end;
L690: (for B19 being (Element of ( NAT )) holds S6[ B19 ]) from NAT_1:sch 1(L679 , L667);
L691:  ProperForUpBody D252 , ( intloc ( 0 ) ) , D254 , D257 , D259 , D260
proof
let C67 being (Element of ( NAT ));
thus L692: thesis by L690;
end;
L693: ( DataPart ( IExec (D258 , D260 , D259) ) ) = ( DataPart ( D261 . D262 ) ) by L691 , L662 , L350;
L694: (D258 is_halting_on D259 , D260 & D258 is_closed_on D259 , D260) by L662 , L691 , L378;
L695: ( C65 . R9 ) = ( ( IExec (D258 , D260 , D259) ) . R9 ) by L694 , L661 , SFMASTR1:15
.= ( ( D261 . D262 ) . R9 ) by L693 , SCMFSA_M:2;
L696: (not ( FinSeqMin (R9 , D252 , D254 , D251) ) destroy D252) by L391 , SCMFSA_M:26;
L697: (not D257 destroy D252) by L696 , L665 , SCMFSA8C:52;
L698: (for B20 being (Element of ( NAT )) holds (S5[ B20 ] implies S5[ ( B20 + 1 ) ]))
proof
let C68 being (Element of ( NAT ));
assume that
L699: S5[ C68 ];
L700:
now
assume L701: C68 < D262;
thus L702: ( ( D261 . C68 ) . ( intloc ( 0 ) ) ) = 1 by L701 , L690;
L703: D257 is_closed_on ( D261 . C68 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L690 , L701;
thus L704: D257 is_closed_on ( Initialized ( D261 . C68 ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L703 , L702 , SFMASTR2:4;
L705: D257 is_halting_on ( D261 . C68 ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L690 , L701;
thus L706: D257 is_halting_on ( Initialized ( D261 . C68 ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) by L705 , L702 , L703 , SFMASTR2:5;
thus L707: ( ( D261 . C68 ) . D252 ) = ( C68 + ( D259 . ( intloc ( 0 ) ) ) ) by L699 , L701;
thus L708: ( ( D261 . C68 ) . D254 ) = ( D259 . D254 ) by L699 , L701;
thus L709: ( ( D261 . C68 ) . D252 ) <= ( D259 . D254 ) by L662 , L699 , L701 , NAT_1:13;
thus L710: ( ( D261 . ( C68 + 1 ) ) | ( ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) \/ ( FinSeq-Locations ) ) ) = ( ( IExec (( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . C68 )) ) | ( ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) \/ ( FinSeq-Locations ) ) ) by L662 , L691 , L701 , L189;
end;
set D263 = ( ( D261 . C68 ) . R9 );
set D264 = ( ( D261 . ( C68 + 1 ) ) . R9 );
assume L711: ( C68 + 1 ) <= D262;
consider C69 being (Permutation of ( dom ( R1 . R9 ) )) such that L712: D263 = ( ( R1 . R9 ) * C69 ) by L711 , L699 , NAT_1:13;
thus L713: ( ( D261 . ( C68 + 1 ) ) . D252 ) = ( ( C68 + 1 ) + ( D259 . ( intloc ( 0 ) ) ) ) by L697 , L662 , L691 , L711 , L138;
L714: (D253 is_closed_on ( Initialized ( IExec (D256 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . C68 )) ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) & D253 is_halting_on ( Initialized ( IExec (D256 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . C68 )) ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) )) by SCMFSA7B:18 , SCMFSA7B:19;
L715: D254 = ( 1 -stRWNotIn ( UsedIntLoc D253 ) ) by SFMASTR1:def 4;
set D265 = ( min_at (D263 , ( C68 + 1 ) , ( len D263 )) );
L716: ( dom ( R1 . R9 ) ) = ( Seg ( len ( R1 . R9 ) ) ) by FINSEQ_1:def 3;
L717: ( len D263 ) = ( len ( R1 . R9 ) ) by L716 , L712 , FINSEQ_2:43;
L718: 1 <= ( C68 + 1 ) by NAT_1:12;
L719: ( C68 + 1 ) <= D265 by L718 , L662 , L666 , L711 , L717 , GRAPH_2:59;
L720: 1 <= D265 by L719 , L718 , XXREAL_0:2;
L721: D265 <= ( len D263 ) by L662 , L666 , L711 , L717 , L718 , GRAPH_2:59;
L722: D265 in ( dom D263 ) by L721 , L720 , FINSEQ_3:25;
L723: { D252 , D251 } c= ( UsedIntLoc D253 ) by L646;
L724: D251 in { D252 , D251 } by TARSKI:def 2;
L725: D254 <> D251 by L724 , L715 , L723 , SCMFSA_M:25;
L726: D252 in { D252 , D251 } by TARSKI:def 2;
L727: D252 <> D254 by L726 , L715 , L723 , SCMFSA_M:25;
L728: D252 <> D251 by SCMFSA_M:26;
L729: ( ( Initialized ( D261 . C68 ) ) . ( intloc ( 0 ) ) ) = 1 by SCMFSA_M:9;
L730: (D256 is_closed_on ( Initialized ( D261 . C68 ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) & D256 is_halting_on ( Initialized ( D261 . C68 ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) )) by L729 , L425;
L731: D264 = ( ( D263 +* (( C68 + 1 ) , ( D263 . D265 )) ) +* (D265 , ( D263 . ( C68 + 1 ) )) )
proof
set D266 = ( IExec (D256 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . C68 )) );
L732: ( len D263 ) = ( abs ( len D263 ) ) by ABSVALUE:def 1;
L733: (( ( D261 . C68 ) . D254 ) = ( len D263 ) & ( C68 + 1 ) = ( abs ( C68 + 1 ) )) by L666 , L700 , L711 , L712 , L716 , ABSVALUE:def 1 , FINSEQ_2:43 , NAT_1:13;
L734: ( D266 . D251 ) = D265 by L733 , L662 , L700 , L711 , L725 , L728 , L718 , L732 , L516 , NAT_1:13;
L735: 1 <= ( D266 . D251 ) by L734 , L718 , L719 , XXREAL_0:2;
L736: ( D266 . R9 ) = D263 by L700 , L711 , L725 , L728 , L435 , NAT_1:13;
L737: ( D266 . D251 ) <= ( len ( D266 . R9 ) ) by L736 , L662 , L666 , L711 , L717 , L718 , L734 , GRAPH_2:59;
L738: (( D266 . D252 ) = ( C68 + 1 ) & ( D266 . ( intloc ( 0 ) ) ) = 1) by L662 , L700 , L711 , L730 , L725 , L728 , L435 , NAT_1:13 , SCMFSA8C:67;
thus L739: D264 = ( ( IExec (( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . C68 )) ) . R9 ) by L700 , L711 , NAT_1:13 , SCMFSA_M:28
.= ( ( Exec (( AddTo (D252 , ( intloc ( 0 ) )) ) , ( IExec (D257 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . C68 )) )) ) . R9 ) by L700 , L711 , NAT_1:13 , SFMASTR1:12
.= ( ( IExec (D257 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . C68 )) ) . R9 ) by SCMFSA_2:64
.= ( ( IExec (D253 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (D256 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . C68 )) )) ) . R9 ) by L730 , SFMASTR1:8
.= ( ( D263 +* (( C68 + 1 ) , ( D263 . D265 )) ) +* (D265 , ( D263 . ( C68 + 1 ) )) ) by L662 , L666 , L711 , L717 , L718 , L736 , L734 , L735 , L737 , L738 , L601;
end;
L740: ( C68 + 1 ) in ( dom D263 ) by L662 , L666 , L711 , L717 , L718 , FINSEQ_3:25;
consider C70 being (Permutation of ( dom D263 )) such that L741: D264 = ( D263 * C70 ) by L740 , L722 , L731 , FUNCT_7:111;
L742: ({ D252 , D254 , D251 } c= ( UsedIntLoc D256 ) & D254 in { D252 , D254 , D251 }) by L409 , ENUMSET1:def 1;
L743: D254 in ( ( UsedIntLoc D256 ) \/ ( UsedIntLoc D253 ) ) by L742 , XBOOLE_0:def 3;
L744: D254 in ( UsedIntLoc D257 ) by L743 , SF_MASTR:27;
L745: D254 in ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) by L744 , XBOOLE_0:def 3;
thus L746: ( ( D261 . ( C68 + 1 ) ) . D254 ) = ( ( IExec (( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . C68 )) ) . D254 ) by L745 , L700 , L711 , NAT_1:13 , SCMFSA_M:28
.= ( ( Exec (( AddTo (D252 , ( intloc ( 0 ) )) ) , ( IExec (D257 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . C68 )) )) ) . D254 ) by L700 , L711 , NAT_1:13 , SFMASTR1:11
.= ( ( IExec (D257 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . C68 )) ) . D254 ) by L727 , SCMFSA_2:64
.= ( ( IExec (D253 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( IExec (D256 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . C68 )) )) ) . D254 ) by L730 , SFMASTR1:7
.= ( ( Initialized ( IExec (D256 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . C68 )) ) ) . D254 ) by L715 , L714 , SCMFSA_M:25 , SFMASTR2:1
.= ( ( IExec (D256 , ( R15 +* ( while>0 (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( ( D257 ";" ( AddTo (D252 , ( intloc ( 0 ) )) ) ) ";" ( SubFrom (( 1 -stRWNotIn ( { D252 , ( intloc ( 0 ) ) , D254 } \/ ( UsedIntLoc D257 ) ) ) , ( intloc ( 0 ) )) ) )) ) ) , ( D261 . C68 )) ) . D254 ) by SCMFSA_M:37
.= ( D259 . D254 ) by L700 , L711 , L725 , L728 , L435 , NAT_1:13;
thus L747: ( ( D261 . ( C68 + 1 ) ) . R9 ) is_split_at ( C68 + 1 ) by L662 , L666 , L699 , L711 , L717 , L731 , GRAPH_2:62 , NAT_1:13;
thus L748: ( ( D261 . ( C68 + 1 ) ) . R9 ) is_non_decreasing_on 1 , ( C68 + 1 ) by L662 , L666 , L699 , L711 , L717 , L731 , GRAPH_2:61 , NAT_1:13;
L749: ( dom D263 ) = ( dom ( R1 . R9 ) ) by L717 , FINSEQ_3:29;
reconsider D267 = C70 as (Permutation of ( dom ( R1 . R9 ) )) by L749;
reconsider D268 = ( C69 * D267 ) as (Permutation of ( dom ( R1 . R9 ) ));
take D268;
thus L750: thesis by L712 , L741 , RELAT_1:36;
end;
L751: ( dom ( R1 . R9 ) ) = ( Seg ( len ( R1 . R9 ) ) ) by FINSEQ_1:def 3;
L752: D252 in { D252 , D251 } by TARSKI:def 2;
L753: (D254 = ( 1 -stRWNotIn ( UsedIntLoc D253 ) ) & { D252 , D251 } c= ( UsedIntLoc D253 )) by L646 , SFMASTR1:def 4;
L754: D252 <> D254 by L753 , L752 , SCMFSA_M:25;
L755: S5[ ( 0 ) ]
proof
assume L756: ( 0 ) <= D262;
thus L757: ( ( D261 . ( 0 ) ) . D252 ) = ( ( 0 ) + ( D259 . ( intloc ( 0 ) ) ) ) by L57;
thus L758: ( ( D261 . ( 0 ) ) . D254 ) = ( D259 . D254 ) by L754 , L67;
thus L759: ( ( D261 . ( 0 ) ) . R9 ) is_split_at ( 0 )
proof
let C71 , C72 being (Element of ( NAT ));
assume that
L760: (1 <= C71 & C71 <= ( 0 ))
and
L761: ( 0 ) < C72
and
L762: C72 <= ( len ( ( D261 . ( 0 ) ) . R9 ) );
thus L763: thesis by L760;
end;

thus L764: ( ( D261 . ( 0 ) ) . R9 ) is_non_decreasing_on 1 , ( 0 )
proof
let C73 , C74 being (Element of ( NAT ));
assume that
L765: 1 <= C73
and
L766: (C73 <= C74 & C74 <= ( 0 ));
thus L767: thesis by L766;
end;

L768: ( dom ( R1 . R9 ) ) = ( Seg ( len ( R1 . R9 ) ) ) by FINSEQ_1:def 3;
reconsider D269 = ( idseq ( len ( R1 . R9 ) ) ) as (Permutation of ( dom ( R1 . R9 ) )) by L768 , FINSEQ_2:55;
take D269;
L769: ( ( D261 . ( 0 ) ) . R9 ) = ( D259 . R9 ) by L81
.= ( ( Initialized R1 ) . R9 ) by SCMFSA_2:74
.= ( R1 . R9 ) by SCMFSA_M:37;
thus L770: thesis by L769 , FINSEQ_2:54;
end;
L771: (for B21 being (Element of ( NAT )) holds S5[ B21 ]) from NAT_1:sch 1(L755 , L698);
L772: (ex B22 being (Permutation of ( dom ( R1 . R9 ) )) st ( ( D261 . D262 ) . R9 ) = ( ( R1 . R9 ) * B22 )) by L771;
L773: ( len ( C65 . R9 ) ) = D262 by L772 , L662 , L666 , L695 , L751 , FINSEQ_2:43;
thus L774: ( C65 . R9 ) is_non_decreasing_on 1 , ( len ( C65 . R9 ) ) by L773 , L771 , L695;
thus L775: thesis by L771 , L695;
end;
