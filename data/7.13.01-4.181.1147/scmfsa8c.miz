:: The {\bf loop} and {\bf Times} Macroinstruction for {\SCMFSA}
::  by Noriko Asamoto
::
:: Received October 29, 1997
:: Copyright (c) 1997-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, FSM_1, SCMFSA_2, CAT_1, AMI_1, SCMFSA8A,
      XXREAL_0, CIRCUIT2, FUNCT_4, CARD_1, RELAT_1, ARYTM_3, AMISTD_2, GRAPHSP,
      AMI_3, EXTPRO_1, TARSKI, FUNCT_1, ARYTM_1, TURING_1, SCMFSA6C, FUNCOP_1,
      SCMFSA6A, SCMFSA6B, XBOOLE_0, MSUALG_1, UNIALG_2, SCMFSA7B, SF_MASTR,
      STRUCT_0, NAT_1, SCMFSA8B, SCMFSA8C, COMPOS_1, ORDINAL1, PARTFUN1, RELOC,
      PBOOLE, SCMPDS_4;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      ORDINAL1, NAT_1, FUNCOP_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, FUNCT_7,
      PBOOLE, VALUED_1, AFINSQ_1, STRUCT_0, COMPOS_0,
      COMPOS_1, MEMSTR_0, EXTPRO_1, AMISTD_1,
      AMISTD_2, SCMFSA_2, SF_MASTR, SCMFSA6A, SCMFSA6B, SCMFSA6C, SCMFSA7B,
      SCMFSA8A, SCMFSA8B, NAT_D, XXREAL_0, SCMFSA_M;
 constructors DOMAIN_1, XXREAL_0, REAL_1, SCMFSA6A, SF_MASTR, SCMFSA6B,
      SCMFSA6C, SCMFSA8A, SCMFSA8B, AMISTD_2, NAT_D, AMI_3, RELSET_1, PRE_POLY,
      SCMFSA7B, AMISTD_1, PBOOLE, SCMFSA_7, MEMSTR_0, WELLORD2, INT_2,
      SCMFSA_2, VALUED_1, SCMFSA_M, FUNCT_7;
 registrations SETFAM_1, FUNCT_1, FUNCOP_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B,
      SCMFSA8A, SCMFSA8B, ORDINAL1, XBOOLE_0, AFINSQ_1, VALUED_1, RELAT_1,
      SCMFSA10, AMISTD_2, COMPOS_1, EXTPRO_1, PBOOLE, FUNCT_4, MEMSTR_0,
      RELSET_1, FINSET_1, STRUCT_0, FINSEQ_1, AMI_3, COMPOS_0, SCMFSA_M;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, SCMFSA8A, SCMFSA6A, AMISTD_2,
      SCMFSA6B, MEMSTR_0, COMPOS_0, SCMFSA_M;
 theorems FUNCT_4, SCMFSA_4, SCMFSA6A, SCMFSA8B, SCMFSA6C, SCMFSA7B, SCMFSA8A,
      SF_MASTR, NAT_1, SCMFSA6B, GRFUNC_1, SCMFSA_2, MEMSTR_0, FUNCT_1,
      FUNCT_7, TARSKI, ENUMSET1, FUNCOP_1, RELAT_1, SCMFSA_3, INT_1, XBOOLE_0,
      XBOOLE_1, XREAL_1, ORDINAL1, XXREAL_0, EXTPRO_1, ZFMISC_1, AFINSQ_1,
      XREAL_0, PBOOLE, PARTFUN1, SCMFSA10, COMPOS_1, AMISTD_2, AMISTD_1,
      STRUCT_0, COMPOS_0, SCMFSA_M;
 schemes NAT_1;

begin
set D1 = ( Start-At (( 0 ) , ( SCM+FSA )) );
set D2 = ( ( intloc ( 0 ) ) .--> 1 );
theorem
L1: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B1 being (State of ( SCM+FSA )) holds (for B2 being  initial (Program of ( SCM+FSA )) holds (B2 is_pseudo-closed_on B1 , R2 implies (for B3 being (Element of ( NAT )) holds ((for B4 being (Element of ( NAT )) holds (B4 <= B3 implies ( IC ( Comput (( R2 +* B2 ) , ( Initialize B1 ) , B4) ) ) in ( dom B2 ))) implies B3 < ( pseudo-LifeSpan (B1 , R2 , B2) )))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C1 being (State of ( SCM+FSA ));
let C2 being  initial (Program of ( SCM+FSA ));
assume L2: C2 is_pseudo-closed_on C1 , R2;
L3: ( IC ( Comput (( R2 +* C2 ) , ( Initialize C1 ) , ( pseudo-LifeSpan (C1 , R2 , C2) )) ) ) = ( card C2 ) by L2 , SCMFSA8A:def 4;
L4: (not ( IC ( Comput (( R2 +* C2 ) , ( Initialize C1 ) , ( pseudo-LifeSpan (C1 , R2 , C2) )) ) ) in ( dom C2 )) by L3;
let C3 being (Element of ( NAT ));
assume L5: (for B5 being (Element of ( NAT )) holds (B5 <= C3 implies ( IC ( Comput (( R2 +* C2 ) , ( Initialize C1 ) , B5) ) ) in ( dom C2 )));
thus L6: ( pseudo-LifeSpan (C1 , R2 , C2) ) > C3 by L5 , L4;
end;
theorem
L7: (for B6 , B7 being (Program of ( SCM+FSA )) holds (for B8 being (Element of ( NAT )) holds ((( card B6 ) <= B8 & B8 < ( ( card B6 ) + ( card B7 ) )) implies (for B9 being (Instruction of ( SCM+FSA )) holds (B9 = ( B7 . ( B8 -' ( card B6 ) ) ) implies ( ( B6 ";" B7 ) . B8 ) = ( IncAddr (B9 , ( card B6 )) ))))))
proof
let C4 , C5 being (Program of ( SCM+FSA ));
let C6 being (Element of ( NAT ));
assume L8: ( card C4 ) <= C6;
assume L9: C6 < ( ( card C4 ) + ( card C5 ) );
L10: ( C6 + ( 0 ) ) < ( ( card C5 ) + ( card C4 ) ) by L9;
L11: ( C6 -' ( card C4 ) ) = ( C6 - ( card C4 ) ) by L8 , XREAL_1:233;
L12: ( C6 -' ( card C4 ) ) < ( ( card C5 ) - ( 0 ) ) by L11 , L10 , XREAL_1:21;
L13: ( C6 -' ( card C4 ) ) in ( dom C5 ) by L12 , AFINSQ_1:66;
let C7 being (Instruction of ( SCM+FSA ));
assume L14: C7 = ( C5 . ( C6 -' ( card C4 ) ) );
L15: ( ( C6 -' ( card C4 ) ) + ( card C4 ) ) = ( ( C6 - ( card C4 ) ) + ( card C4 ) ) by L8 , XREAL_1:233
.= C6;
L16: C6 in { ( R1 + ( card C4 ) ) where R1 is (Element of ( NAT )) : R1 in ( dom C5 ) } by L15 , L13;
L17: C6 in ( dom ( Reloc (C5 , ( card C4 )) ) ) by L16 , COMPOS_1:33;
thus L18: ( ( C4 ";" C5 ) . C6 ) = ( ( Reloc (C5 , ( card C4 )) ) . C6 ) by L17 , FUNCT_4:13
.= ( IncAddr (C7 , ( card C4 )) ) by L14 , L13 , L15 , COMPOS_1:35;
end;
theorem
L19: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B10 being (State of ( SCM+FSA )) holds (for B11 being (Program of ( SCM+FSA )) holds ( IExec (B11 , R2 , B10) ) = ( IExec (B11 , R2 , ( Initialized B10 )) ))));
canceled 1;
theorem
L20: (for B12 being (Program of ( SCM+FSA )) holds ((for B13 being (State of ( SCM+FSA )) holds (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds B12 is_halting_on ( Initialized B13 ) , R2)) implies ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) is B12 -halted))
proof
let C8 being (Program of ( SCM+FSA ));
assume L21: (for B14 being (State of ( SCM+FSA )) holds (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds C8 is_halting_on ( Initialized B14 ) , R2));
let C9 being (State of ( SCM+FSA ));
assume L22: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= C9;
L23: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= C9 by L22;
L24: ( C9 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = C9 by L23 , FUNCT_4:98;
let C10 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L25: C8 c= C10;
L26: ( C10 +* C8 ) = C10 by L25 , FUNCT_4:98;
L27: C8 is_halting_on ( Initialized C9 ) , C10 by L21;
L28: ( C10 +* C8 ) halts_on ( Initialize ( Initialized C9 ) ) by L27 , SCMFSA7B:def 7;
thus L29: C10 halts_on C9 by L28 , L24 , L26 , MEMSTR_0:44;
end;
theorem
L30: (for B15 being (Program of ( SCM+FSA )) holds ((for B16 being (State of ( SCM+FSA )) holds (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds B15 is_halting_on ( Initialized B16 ) , R2)) implies ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) is B15 -halted)) by L20;
canceled 5;
theorem
L31: (for B17 being (State of ( SCM+FSA )) holds (for B18 being (Instruction of ( SCM+FSA )) holds (( InsCode B18 ) in { ( 0 ) , 6 , 7 , 8 } implies ( DataPart ( Exec (B18 , B17) ) ) = ( DataPart B17 ))))
proof
let C11 being (State of ( SCM+FSA ));
let C12 being (Instruction of ( SCM+FSA ));
assume L32: ( InsCode C12 ) in { ( 0 ) , 6 , 7 , 8 };
L33:
now
let C13 being Int-Location;
let C14 being FinSeq-Location;
per cases  by L32 , ENUMSET1:def 2;
suppose L34: ( InsCode C12 ) = ( 0 );

L35: C12 = ( halt ( SCM+FSA ) ) by L34 , SCMFSA_2:95;
thus L36: (( ( Exec (C12 , C11) ) . C13 ) = ( C11 . C13 ) & ( ( Exec (C12 , C11) ) . C14 ) = ( C11 . C14 )) by L35 , EXTPRO_1:def 3;
end;
suppose L37: ( InsCode C12 ) = 6;

L38: (ex B19 being (Element of ( NAT )) st C12 = ( goto B19 )) by L37 , SCMFSA_2:35;
thus L39: (( ( Exec (C12 , C11) ) . C13 ) = ( C11 . C13 ) & ( ( Exec (C12 , C11) ) . C14 ) = ( C11 . C14 )) by L38 , SCMFSA_2:69;
end;
suppose L40: ( InsCode C12 ) = 7;

L41: (ex B20 being (Element of ( NAT )) st (ex B21 being Int-Location st C12 = ( B21 =0_goto B20 ))) by L40 , SCMFSA_2:36;
thus L42: (( ( Exec (C12 , C11) ) . C13 ) = ( C11 . C13 ) & ( ( Exec (C12 , C11) ) . C14 ) = ( C11 . C14 )) by L41 , SCMFSA_2:70;
end;
suppose L43: ( InsCode C12 ) = 8;

L44: (ex B22 being (Element of ( NAT )) st (ex B23 being Int-Location st C12 = ( B23 >0_goto B22 ))) by L43 , SCMFSA_2:37;
thus L45: (( ( Exec (C12 , C11) ) . C13 ) = ( C11 . C13 ) & ( ( Exec (C12 , C11) ) . C14 ) = ( C11 . C14 )) by L44 , SCMFSA_2:71;
end;
end;
thus L47: thesis by L33 , SCMFSA_M:2;
end;
canceled 1;
theorem
L48: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B24 being (State of ( SCM+FSA )) holds ( IExec (( Stop ( SCM+FSA ) ) , R2 , B24) ) = ( Initialized B24 )))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C15 being (State of ( SCM+FSA ));
set D3 = ( Data-Locations ( SCM+FSA ) );
set D4 = ( Initialize ( Initialized C15 ) );
set D5 = ( R2 +* ( Stop ( SCM+FSA ) ) );
L49: ( Stop ( SCM+FSA ) ) c= D5 by FUNCT_4:25;
L50: D4 = ( Comput (D5 , D4 , ( 0 )) );
L51: ( D5 /. ( IC D4 ) ) = ( D5 . ( IC D4 ) ) by PBOOLE:143;
L52: ( ( Stop ( SCM+FSA ) ) . ( 0 ) ) = ( halt ( SCM+FSA ) ) by AFINSQ_1:34;
L53: ( 0 ) in ( dom ( Stop ( SCM+FSA ) ) ) by COMPOS_1:3;
L54: ( C15 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = D4 by MEMSTR_0:44;
L55: ( CurInstr (D5 , D4) ) = ( D5 . ( 0 ) ) by L51 , MEMSTR_0:28
.= ( ( Stop ( SCM+FSA ) ) . ( 0 ) ) by L53 , L49 , GRFUNC_1:2;
L56: D5 halts_on D4 by L55 , L50 , L52 , EXTPRO_1:29;
L57: ( IExec (( Stop ( SCM+FSA ) ) , R2 , C15) ) = D4 by L56 , L54 , L55 , L50 , L52 , EXTPRO_1:def 9;
L58: ( DataPart ( IExec (( Stop ( SCM+FSA ) ) , R2 , C15) ) ) = ( DataPart D4 ) by L57
.= ( DataPart ( Initialized C15 ) ) by MEMSTR_0:79;
thus L59:now
L60:
now
let C16 being set;
assume L61: C16 in ( dom ( IExec (( Stop ( SCM+FSA ) ) , R2 , C15) ) );
per cases  by L61 , SCMFSA_M:1;
suppose L62: C16 is Int-Location;

L63: ( ( IExec (( Stop ( SCM+FSA ) ) , R2 , C15) ) . C16 ) = ( ( Initialized C15 ) . C16 ) by L58 , L62 , SCMFSA_M:2;
thus L64: ( ( IExec (( Stop ( SCM+FSA ) ) , R2 , C15) ) . C16 ) = ( ( Initialized C15 ) . C16 ) by L63;
end;
suppose L65: C16 is FinSeq-Location;

L66: ( ( IExec (( Stop ( SCM+FSA ) ) , R2 , C15) ) . C16 ) = ( ( Initialized C15 ) . C16 ) by L58 , L65 , SCMFSA_M:2;
thus L67: ( ( IExec (( Stop ( SCM+FSA ) ) , R2 , C15) ) . C16 ) = ( ( Initialized C15 ) . C16 ) by L66;
end;
suppose L68: C16 = ( IC ( SCM+FSA ) );

L69: C16 in { ( IC ( SCM+FSA ) ) } by L68 , TARSKI:def 1;
L70: C16 in ( dom D1 ) by L69 , FUNCOP_1:13;
thus L71: ( ( IExec (( Stop ( SCM+FSA ) ) , R2 , C15) ) . C16 ) = ( D4 . ( IC ( SCM+FSA ) ) ) by L57 , L68
.= ( D1 . ( IC ( SCM+FSA ) ) ) by L68 , L70 , FUNCT_4:13
.= ( ( ( C15 +* ( ( intloc ( 0 ) ) .--> 1 ) ) +* D1 ) . C16 ) by L68 , L70 , FUNCT_4:13
.= ( ( C15 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) . C16 ) by FUNCT_4:14
.= ( ( Initialized C15 ) . C16 );
end;
end;
L73: ( dom ( IExec (( Stop ( SCM+FSA ) ) , R2 , C15) ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2
.= ( dom ( Initialized C15 ) ) by PARTFUN1:def 2;
thus L74: thesis by L73 , L60 , FUNCT_1:2;
end;
end;
theorem
L60: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B25 being (State of ( SCM+FSA )) holds (for B26 being (Program of ( SCM+FSA )) holds (B26 is_closed_on B25 , R2 implies ( 0 ) in ( dom B26 )))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C17 being (State of ( SCM+FSA ));
let C18 being (Program of ( SCM+FSA ));
reconsider D6 = ( IC ( Comput (( R2 +* C18 ) , ( Initialize C17 ) , ( 0 )) ) ) as (Element of ( NAT ));
assume L61: C18 is_closed_on C17 , R2;
L62: D6 in ( dom C18 ) by L61 , SCMFSA7B:def 6;
per cases ;
suppose L63: D6 = ( 0 );

thus L64: thesis by L63 , L61 , SCMFSA7B:def 6;
end;
suppose L65: ( 0 ) < D6;

thus L66: thesis by L65 , L62 , AFINSQ_1:def 12;
end;
end;
theorem
L68: (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (Instruction-Sequence of ( SCM+FSA )) holds (for B27 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B28 being (State of ( SCM+FSA )) holds (for B29 being (Program of ( SCM+FSA )) holds ((B29 is_closed_on B27 , R4 & B29 c= R4) implies (for B30 being (Element of ( NAT )) holds ((( Reloc (B29 , B30) ) c= R5 & ( IC B28 ) = B30 & ( DataPart B27 ) = ( DataPart B28 )) implies (for B31 being (Element of ( NAT )) holds (( ( IC ( Comput (R4 , B27 , B31) ) ) + B30 ) = ( IC ( Comput (R5 , B28 , B31) ) ) & ( IncAddr (( CurInstr (R4 , ( Comput (R4 , B27 , B31) )) ) , B30) ) = ( CurInstr (R5 , ( Comput (R5 , B28 , B31) )) ) & ( DataPart ( Comput (R4 , B27 , B31) ) ) = ( DataPart ( Comput (R5 , B28 , B31) ) )))))))))))
proof
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (Instruction-Sequence of ( SCM+FSA ));
let C19 being ( 0 ) -started (State of ( SCM+FSA ));
let C20 being (State of ( SCM+FSA ));
let C21 being (Program of ( SCM+FSA ));
set D7 = ( Start-At (( 0 ) , ( SCM+FSA )) );
assume L69: C21 is_closed_on C19 , R4;
L70: ( 0 ) in ( dom C21 ) by L69 , L60;
L71: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C19 by MEMSTR_0:29;
assume that
L72: C21 c= R4;
L73: D1 c= C19 by L71;
L74: ( Initialize C19 ) = C19 by L73 , FUNCT_4:98;
L75: ( IC ( SCM+FSA ) ) in ( dom D7 ) by MEMSTR_0:15;
L76: ( R4 . ( IC C19 ) ) = ( R4 . ( 0 ) ) by L74 , MEMSTR_0:16
.= ( C21 . ( 0 ) ) by L70 , L72 , GRFUNC_1:2;
L77: R4 = ( R4 +* C21 ) by L72 , FUNCT_4:98;
L78: ( IC ( Comput (R4 , C19 , ( 0 )) ) ) = ( IC C19 )
.= ( IC D7 ) by L71 , L75 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L79: ( 0 ) in ( dom C21 ) by L69 , L60;
let C22 being (Element of ( NAT ));
defpred S1[ Nat ] means (( ( IC ( Comput (R4 , C19 , $1) ) ) + C22 ) = ( IC ( Comput (R5 , C20 , $1) ) ) & ( IncAddr (( CurInstr (R4 , ( Comput (R4 , C19 , $1) )) ) , C22) ) = ( CurInstr (R5 , ( Comput (R5 , C20 , $1) )) ) & ( DataPart ( Comput (R4 , C19 , $1) ) ) = ( DataPart ( Comput (R5 , C20 , $1) ) ));
assume that
L80: ( Reloc (C21 , C22) ) c= R5
and
L81: ( IC C20 ) = C22
and
L82: ( DataPart C19 ) = ( DataPart C20 );
let C23 being (Element of ( NAT ));
L83: ( DataPart ( Comput (R4 , C19 , ( 0 )) ) ) = ( DataPart C20 ) by L82
.= ( DataPart ( Comput (R5 , C20 , ( 0 )) ) );
L84: (for B32 being (Element of ( NAT )) holds (S1[ B32 ] implies S1[ ( B32 + 1 ) ]))
proof
let C24 being (Element of ( NAT ));
L85: ( Comput (R4 , C19 , ( C24 + 1 )) ) = ( Following (R4 , ( Comput (R4 , C19 , C24) )) ) by EXTPRO_1:3;
reconsider D8 = ( IC ( Comput (R4 , C19 , ( C24 + 1 )) ) ) as (Element of ( NAT ));
reconsider D9 = ( CurInstr (R4 , ( Comput (R4 , C19 , ( C24 + 1 )) )) ) as (Instruction of ( SCM+FSA ));
L86: ( Comput (R5 , C20 , ( C24 + 1 )) ) = ( Following (R5 , ( Comput (R5 , C20 , C24) )) ) by EXTPRO_1:3;
L87: ( Initialize C19 ) = C19 by L71 , FUNCT_4:98;
L88: ( IC ( Comput (R4 , C19 , ( C24 + 1 )) ) ) in ( dom C21 ) by L87 , L69 , L77 , SCMFSA7B:def 6;
assume L89: S1[ C24 ];
thus L90: ( ( IC ( Comput (R4 , C19 , ( C24 + 1 )) ) ) + C22 ) = ( IC ( Comput (R5 , C20 , ( C24 + 1 )) ) ) by L89 , L85 , L86 , SCMFSA6A:8;
L91: ( IC ( Comput (R5 , C20 , ( C24 + 1 )) ) ) in ( dom ( Reloc (C21 , C22) ) ) by L90 , L88 , COMPOS_1:46;
L92: D8 in ( dom C21 ) by L87 , L69 , L77 , SCMFSA7B:def 6;
L93: D9 = ( R4 . ( IC ( Comput (R4 , C19 , ( C24 + 1 )) ) ) ) by PBOOLE:143
.= ( C21 . D8 ) by L88 , L72 , GRFUNC_1:2;
thus L94: ( IncAddr (( CurInstr (R4 , ( Comput (R4 , C19 , ( C24 + 1 )) )) ) , C22) ) = ( ( Reloc (C21 , C22) ) . ( D8 + C22 ) ) by L93 , L92 , COMPOS_1:35
.= ( R5 . ( IC ( Comput (R5 , C20 , ( C24 + 1 )) ) ) ) by L80 , L90 , L91 , GRFUNC_1:2
.= ( CurInstr (R5 , ( Comput (R5 , C20 , ( C24 + 1 )) )) ) by PBOOLE:143;
thus L95: thesis by L89 , L85 , L86 , SCMFSA6A:8;
end;
L96: ( 0 ) in ( dom C21 ) by L69 , L60;
L97: ( ( 0 ) + C22 ) in ( dom ( Reloc (C21 , C22) ) ) by L96 , COMPOS_1:46;
L98: ( R4 /. ( IC C19 ) ) = ( R4 . ( IC C19 ) ) by PBOOLE:143;
L99: ( R5 /. ( IC C20 ) ) = ( R5 . ( IC C20 ) ) by PBOOLE:143;
L100: ( IncAddr (( CurInstr (R4 , ( Comput (R4 , C19 , ( 0 )) )) ) , C22) ) = ( ( Reloc (C21 , C22) ) . ( ( 0 ) + C22 ) ) by L79 , L98 , L76 , COMPOS_1:35
.= ( CurInstr (R5 , ( Comput (R5 , C20 , ( 0 )) )) ) by L80 , L81 , L97 , L99 , GRFUNC_1:2;
L101: S1[ ( 0 ) ] by L100 , L81 , L78 , L83;
L102: (for B33 being (Element of ( NAT )) holds S1[ B33 ]) from NAT_1:sch 1(L101 , L84);
thus L103: thesis by L102;
end;
theorem
L104: (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (Instruction-Sequence of ( SCM+FSA )) holds (for B34 , B35 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B36 being (Program of ( SCM+FSA )) holds ((B36 is_closed_on B34 , R4 & B36 c= R4 & B36 c= R5 & ( DataPart B34 ) = ( DataPart B35 )) implies (for B37 being (Element of ( NAT )) holds (( IC ( Comput (R4 , B34 , B37) ) ) = ( IC ( Comput (R5 , B35 , B37) ) ) & ( CurInstr (R4 , ( Comput (R4 , B34 , B37) )) ) = ( CurInstr (R5 , ( Comput (R5 , B35 , B37) )) ) & ( DataPart ( Comput (R4 , B34 , B37) ) ) = ( DataPart ( Comput (R5 , B35 , B37) ) ))))))))
proof
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (Instruction-Sequence of ( SCM+FSA ));
let C25 , C26 being ( 0 ) -started (State of ( SCM+FSA ));
let C27 being (Program of ( SCM+FSA ));
assume that
L105: C27 is_closed_on C25 , R4
and
L106: C27 c= R4
and
L107: C27 c= R5
and
L108: ( DataPart C25 ) = ( DataPart C26 );
L109: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C26 by MEMSTR_0:29;
L110: ( Reloc (C27 , ( 0 )) ) = C27;
let C28 being (Element of ( NAT ));
L111: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L112: ( ( IC ( Comput (R4 , C25 , C28) ) ) + ( 0 ) ) = ( IC ( Comput (R4 , C25 , C28) ) );
L113: ( IC C26 ) = ( IC ( Initialize C26 ) ) by L109 , FUNCT_4:98
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L111 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L114: ( IncAddr (( CurInstr (R4 , ( Comput (R4 , C25 , C28) )) ) , ( 0 )) ) = ( CurInstr (R4 , ( Comput (R4 , C25 , C28) )) ) by COMPOS_0:3;
thus L115: thesis by L114 , L105 , L108 , L112 , L113 , L68 , L106 , L107 , L110;
end;
theorem
L116: (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (Instruction-Sequence of ( SCM+FSA )) holds (for B38 , B39 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B40 being (Program of ( SCM+FSA )) holds ((B40 is_closed_on B38 , R4 & B40 is_halting_on B38 , R4 & B40 c= R4 & B40 c= R5 & ( DataPart B38 ) = ( DataPart B39 )) implies ( LifeSpan (R4 , B38) ) = ( LifeSpan (R5 , B39) ))))))
proof
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (Instruction-Sequence of ( SCM+FSA ));
let C29 , C30 being ( 0 ) -started (State of ( SCM+FSA ));
let C31 being (Program of ( SCM+FSA ));
assume that
L117: C31 is_closed_on C29 , R4
and
L118: C31 is_halting_on C29 , R4
and
L119: C31 c= R4
and
L120: C31 c= R5
and
L121: ( DataPart C29 ) = ( DataPart C30 );
L122: R4 = ( R4 +* C31 ) by L119 , FUNCT_4:98;
L123: C29 = ( Initialize C29 ) by MEMSTR_0:44;
L124: R4 halts_on C29 by L123 , L118 , L122 , SCMFSA7B:def 7;
L125:
now
let C32 being (Element of ( NAT ));
assume L126: ( CurInstr (R5 , ( Comput (R5 , C30 , C32) )) ) = ( halt ( SCM+FSA ) );
L127: ( CurInstr (R4 , ( Comput (R4 , C29 , C32) )) ) = ( halt ( SCM+FSA ) ) by L126 , L117 , L121 , L104 , L119 , L120;
thus L128: ( LifeSpan (R4 , C29) ) <= C32 by L127 , L124 , EXTPRO_1:def 15;
end;
L129: ( CurInstr (R4 , ( Comput (R4 , C29 , ( LifeSpan (R4 , C29) )) )) ) = ( halt ( SCM+FSA ) ) by L124 , EXTPRO_1:def 15;
L130: ( CurInstr (R5 , ( Comput (R5 , C30 , ( LifeSpan (R4 , C29) )) )) ) = ( halt ( SCM+FSA ) ) by L129 , L117 , L121 , L104 , L119 , L120;
L131: R5 halts_on C30 by L130 , EXTPRO_1:29;
thus L132: thesis by L131 , L130 , L125 , EXTPRO_1:def 15;
end;
theorem
L133: (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (Instruction-Sequence of ( SCM+FSA )) holds (for B41 , B42 being (State of ( SCM+FSA )) holds (for B43 being (Program of ( SCM+FSA )) holds ((( B41 . ( intloc ( 0 ) ) ) = 1 & B43 is_closed_on B41 , R4 & B43 is_halting_on B41 , R4 & (for B44 being  read-write Int-Location holds ( B41 . B44 ) = ( B42 . B44 )) & (for B45 being FinSeq-Location holds ( B41 . B45 ) = ( B42 . B45 ))) implies ( DataPart ( IExec (B43 , R4 , B41) ) ) = ( DataPart ( IExec (B43 , R5 , B42) ) ))))))
proof
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (Instruction-Sequence of ( SCM+FSA ));
let C33 , C34 being (State of ( SCM+FSA ));
set D10 = ( Data-Locations ( SCM+FSA ) );
let C35 being (Program of ( SCM+FSA ));
set D11 = ( Initialized C33 );
set D12 = ( R4 +* C35 );
set D13 = ( Initialized C34 );
set D14 = ( R5 +* C35 );
assume L134: ( C33 . ( intloc ( 0 ) ) ) = 1;
L135: D11 = ( Initialize C33 ) by L134 , SCMFSA_M:18;
L136: ( DataPart D11 ) = ( DataPart C33 ) by L135 , MEMSTR_0:79;
assume that
L137: C35 is_closed_on C33 , R4
and
L138: C35 is_halting_on C33 , R4;
L139: C35 is_closed_on D11 , D12 by L137 , L138 , L136 , SCMFSA8B:5;
assume L140: (for B46 being  read-write Int-Location holds ( C33 . B46 ) = ( C34 . B46 ));
L141:
now
let C36 being  read-write Int-Location;
L142: (C36 <> ( intloc ( 0 ) ) & C36 <> ( IC ( SCM+FSA ) )) by SCMFSA_2:56;
L143: (not C36 in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) by L142 , SCMFSA_M:11 , TARSKI:def 2;
thus L144: ( D11 . C36 ) = ( C33 . C36 ) by L143 , FUNCT_4:11
.= ( C34 . C36 ) by L140
.= ( D13 . C36 ) by L143 , FUNCT_4:11;
end;
assume L145: (for B47 being FinSeq-Location holds ( C33 . B47 ) = ( C34 . B47 ));
L146:
now
let C37 being FinSeq-Location;
L147: (C37 <> ( intloc ( 0 ) ) & C37 <> ( IC ( SCM+FSA ) )) by SCMFSA_2:57 , SCMFSA_2:58;
L148: (not C37 in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) by L147 , SCMFSA_M:11 , TARSKI:def 2;
thus L149: ( D11 . C37 ) = ( C33 . C37 ) by L148 , FUNCT_4:11
.= ( C34 . C37 ) by L145
.= ( D13 . C37 ) by L148 , FUNCT_4:11;
end;
L150: ( intloc ( 0 ) ) in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by SCMFSA_M:10;
L151: ( D11 . ( intloc ( 0 ) ) ) = ( ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) . ( intloc ( 0 ) ) ) by L150 , FUNCT_4:13
.= ( D13 . ( intloc ( 0 ) ) ) by L150 , FUNCT_4:13;
L152: ( DataPart D11 ) = ( DataPart D13 ) by L151 , L141 , L146 , SCMFSA_M:20;
L153: C35 c= D14 by FUNCT_4:25;
L154: C35 c= D12 by FUNCT_4:25;
L155: D12 halts_on D11 by L138 , L135 , SCMFSA7B:def 7;
L156: ( CurInstr (D12 , ( Comput (D12 , D11 , ( LifeSpan (D12 , D11) )) )) ) = ( halt ( SCM+FSA ) ) by L155 , EXTPRO_1:def 15;
L157: ( CurInstr (D14 , ( Comput (D14 , D13 , ( LifeSpan (D12 , D11) )) )) ) = ( halt ( SCM+FSA ) ) by L156 , L139 , L152 , L104 , L154 , L153;
L158: D14 halts_on D13 by L157 , EXTPRO_1:29;
L159: C35 is_halting_on D11 , D12 by L137 , L138 , L136 , SCMFSA8B:5;
L160: ( LifeSpan (D12 , D11) ) = ( LifeSpan (D14 , D13) ) by L159 , L139 , L152 , L116 , L154 , L153;
thus L161: ( DataPart ( IExec (C35 , R4 , C33) ) ) = ( DataPart ( Result (D12 , D11) ) )
.= ( DataPart ( Comput (D12 , D11 , ( LifeSpan (D12 , D11) )) ) ) by L155 , EXTPRO_1:23
.= ( DataPart ( Comput (D14 , D13 , ( LifeSpan (D12 , D11) )) ) ) by L139 , L152 , L104 , L154 , L153
.= ( DataPart ( Result (D14 , D13) ) ) by L160 , L158 , EXTPRO_1:23
.= ( DataPart ( IExec (C35 , R5 , C34) ) );
end;
theorem
L162: (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (Instruction-Sequence of ( SCM+FSA )) holds (for B48 , B49 being (State of ( SCM+FSA )) holds (for B50 being (Program of ( SCM+FSA )) holds ((( B48 . ( intloc ( 0 ) ) ) = 1 & B50 is_closed_on B48 , R4 & B50 is_halting_on B48 , R4 & ( DataPart B48 ) = ( DataPart B49 )) implies ( DataPart ( IExec (B50 , R4 , B48) ) ) = ( DataPart ( IExec (B50 , R5 , B49) ) ))))))
proof
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (Instruction-Sequence of ( SCM+FSA ));
let C38 , C39 being (State of ( SCM+FSA ));
set D15 = ( Data-Locations ( SCM+FSA ) );
let C40 being (Program of ( SCM+FSA ));
set D16 = ( Initialized C38 );
set D17 = ( R4 +* C40 );
set D18 = ( Initialized C39 );
set D19 = ( R5 +* C40 );
L163: C40 c= D17 by FUNCT_4:25;
L164: C40 c= D19 by FUNCT_4:25;
assume that
L165: ( C38 . ( intloc ( 0 ) ) ) = 1
and
L166: C40 is_closed_on C38 , R4
and
L167: C40 is_halting_on C38 , R4
and
L168: ( DataPart C38 ) = ( DataPart C39 );
L169: D16 = ( Initialize C38 ) by L165 , SCMFSA_M:18;
L170: ( DataPart D16 ) = ( DataPart C38 ) by L169 , MEMSTR_0:79;
L171: C40 is_closed_on D16 , D17 by L170 , L166 , L167 , SCMFSA8B:5;
L172: ( C39 . ( intloc ( 0 ) ) ) = 1 by L165 , L168 , SCMFSA_M:2;
L173: D18 = ( Initialize C39 ) by L172 , SCMFSA_M:18;
L174: ( DataPart D16 ) = ( DataPart D18 ) by L173 , L168 , L170 , MEMSTR_0:79;
L175: D17 halts_on D16 by L167 , L169 , SCMFSA7B:def 7;
L176: ( CurInstr (D17 , ( Comput (D17 , D16 , ( LifeSpan (D17 , D16) )) )) ) = ( halt ( SCM+FSA ) ) by L175 , EXTPRO_1:def 15;
L177: ( CurInstr (D19 , ( Comput (D19 , D18 , ( LifeSpan (D17 , D16) )) )) ) = ( halt ( SCM+FSA ) ) by L176 , L171 , L174 , L104 , L163 , L164;
L178: D19 halts_on D18 by L177 , EXTPRO_1:29;
L179: C40 is_halting_on D16 , D17 by L166 , L167 , L170 , SCMFSA8B:5;
L180: ( LifeSpan (D17 , D16) ) = ( LifeSpan (D19 , D18) ) by L179 , L171 , L174 , L116 , L163 , L164;
thus L181: ( DataPart ( IExec (C40 , R4 , C38) ) ) = ( DataPart ( Result (D17 , D16) ) )
.= ( DataPart ( Comput (D17 , D16 , ( LifeSpan (D17 , D16) )) ) ) by L175 , EXTPRO_1:23
.= ( DataPart ( Comput (D19 , D18 , ( LifeSpan (D17 , D16) )) ) ) by L171 , L174 , L104 , L163 , L164
.= ( DataPart ( Result (D19 , D18) ) ) by L180 , L178 , EXTPRO_1:23
.= ( DataPart ( IExec (C40 , R5 , C39) ) );
end;
theorem
L182: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B51 being (State of ( SCM+FSA )) holds (for B52 being (Program of ( SCM+FSA )) holds (B52 is_pseudo-closed_on B51 , R2 implies (B52 is_pseudo-closed_on ( Initialize B51 ) , ( R2 +* B52 ) & ( pseudo-LifeSpan (B51 , R2 , B52) ) = ( pseudo-LifeSpan (( Initialize B51 ) , ( R2 +* B52 ) , B52) ))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C41 being (State of ( SCM+FSA ));
let C42 being (Program of ( SCM+FSA ));
set D20 = ( Initialize ( Initialize C41 ) );
set D21 = ( ( R2 +* C42 ) +* C42 );
assume L183: C42 is_pseudo-closed_on C41 , R2;
L184: (for B53 being (Element of ( NAT )) holds ((not ( IC ( Comput (D21 , D20 , B53) ) ) in ( dom C42 )) implies ( pseudo-LifeSpan (C41 , R2 , C42) ) <= B53)) by L183 , SCMFSA8A:def 4;
L185: (for B54 being (Element of ( NAT )) holds (B54 < ( pseudo-LifeSpan (C41 , R2 , C42) ) implies ( IC ( Comput (D21 , D20 , B54) ) ) in ( dom C42 ))) by L183 , SCMFSA8A:def 4;
L186: ( IC ( Comput (D21 , D20 , ( pseudo-LifeSpan (C41 , R2 , C42) )) ) ) = ( card C42 ) by L183 , SCMFSA8A:def 4;
thus L187: C42 is_pseudo-closed_on ( Initialize C41 ) , ( R2 +* C42 ) by L186 , L185 , SCMFSA8A:def 2;
L188: ( IC ( Comput (D21 , D20 , ( pseudo-LifeSpan (C41 , R2 , C42) )) ) ) = ( card C42 ) by L183 , SCMFSA8A:def 4;
thus L189: thesis by L188 , L184 , L187 , SCMFSA8A:def 4;
end;
theorem
L190: (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (Instruction-Sequence of ( SCM+FSA )) holds (for B55 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B56 being (State of ( SCM+FSA )) holds (for B57 being (Program of ( SCM+FSA )) holds ((B57 c= R4 & B57 is_pseudo-closed_on B55 , R4) implies (for B58 being (Element of ( NAT )) holds ((( Reloc (B57 , B58) ) c= R5 & ( IC B56 ) = B58 & ( DataPart B55 ) = ( DataPart B56 )) implies ((for B59 being (Element of ( NAT )) holds (B59 < ( pseudo-LifeSpan (B55 , R4 , B57) ) implies ( IncAddr (( CurInstr (R4 , ( Comput (R4 , B55 , B59) )) ) , B58) ) = ( CurInstr (R5 , ( Comput (R5 , B56 , B59) )) ))) & (for B60 being (Element of ( NAT )) holds (B60 <= ( pseudo-LifeSpan (B55 , R4 , B57) ) implies (( ( IC ( Comput (R4 , B55 , B60) ) ) + B58 ) = ( IC ( Comput (R5 , B56 , B60) ) ) & ( DataPart ( Comput (R4 , B55 , B60) ) ) = ( DataPart ( Comput (R5 , B56 , B60) ) )))))))))))))
proof
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (Instruction-Sequence of ( SCM+FSA ));
let C43 being ( 0 ) -started (State of ( SCM+FSA ));
let C44 being (State of ( SCM+FSA ));
let C45 being (Program of ( SCM+FSA ));
L191: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C43 by MEMSTR_0:29;
assume L192: C45 c= R4;
L193: R4 = ( R4 +* C45 ) by L192 , FUNCT_4:98;
assume L194: C45 is_pseudo-closed_on C43 , R4;
let C46 being (Element of ( NAT ));
assume L195: ( Reloc (C45 , C46) ) c= R5;
defpred S2[ Nat ] means ($1 <= ( pseudo-LifeSpan (C43 , R4 , C45) ) implies (( ( IC ( Comput (R4 , C43 , $1) ) ) + C46 ) = ( IC ( Comput (R5 , C44 , $1) ) ) & ( DataPart ( Comput (R4 , C43 , $1) ) ) = ( DataPart ( Comput (R5 , C44 , $1) ) )));
assume L196: ( IC C44 ) = C46;
assume L197: ( DataPart C43 ) = ( DataPart C44 );
thus L198:now
defpred S3[ Nat ] means ($1 < ( pseudo-LifeSpan (C43 , R4 , C45) ) implies (( ( IC ( Comput (R4 , C43 , $1) ) ) + C46 ) = ( IC ( Comput (R5 , C44 , $1) ) ) & ( IncAddr (( CurInstr (R4 , ( Comput (R4 , C43 , $1) )) ) , C46) ) = ( CurInstr (R5 , ( Comput (R5 , C44 , $1) )) ) & ( DataPart ( Comput (R4 , C43 , $1) ) ) = ( DataPart ( Comput (R5 , C44 , $1) ) )));
let C47 being (Element of ( NAT ));
assume L199: C47 < ( pseudo-LifeSpan (C43 , R4 , C45) );
L200: (for B61 being (Element of ( NAT )) holds (S3[ B61 ] implies S3[ ( B61 + 1 ) ]))
proof
let C48 being (Element of ( NAT ));
assume L201: S3[ C48 ];
reconsider D22 = ( IC ( Comput (R4 , C43 , ( C48 + 1 )) ) ) as (Element of ( NAT ));
reconsider D23 = ( CurInstr (R4 , ( Comput (R4 , C43 , ( C48 + 1 )) )) ) as (Instruction of ( SCM+FSA ));
assume L202: ( C48 + 1 ) < ( pseudo-LifeSpan (C43 , R4 , C45) );
L203: ( Comput (R4 , C43 , ( C48 + 1 )) ) = ( Following (R4 , ( Comput (R4 , C43 , C48) )) ) by EXTPRO_1:3;
L204: ( Initialize C43 ) = C43 by L191 , FUNCT_4:98;
L205: ( IC ( Comput (R4 , C43 , ( C48 + 1 )) ) ) in ( dom C45 ) by L204 , L194 , L202 , L193 , SCMFSA8A:def 4;
L206: D22 in ( dom C45 ) by L204 , L194 , L202 , L193 , SCMFSA8A:def 4;
L207: ( Comput (R5 , C44 , ( C48 + 1 )) ) = ( Following (R5 , ( Comput (R5 , C44 , C48) )) ) by EXTPRO_1:3;
L208: ( C48 + ( 0 ) ) < ( C48 + 1 ) by XREAL_1:6;
thus L209: ( ( IC ( Comput (R4 , C43 , ( C48 + 1 )) ) ) + C46 ) = ( IC ( Comput (R5 , C44 , ( C48 + 1 )) ) ) by L208 , L201 , L202 , L203 , L207 , SCMFSA6A:8 , XXREAL_0:2;
L210: ( IC ( Comput (R5 , C44 , ( C48 + 1 )) ) ) in ( dom ( Reloc (C45 , C46) ) ) by L209 , L205 , COMPOS_1:46;
L211: D23 = ( R4 . ( IC ( Comput (R4 , C43 , ( C48 + 1 )) ) ) ) by PBOOLE:143
.= ( C45 . D22 ) by L205 , L192 , GRFUNC_1:2;
thus L212: ( IncAddr (( CurInstr (R4 , ( Comput (R4 , C43 , ( C48 + 1 )) )) ) , C46) ) = ( ( Reloc (C45 , C46) ) . ( D22 + C46 ) ) by L211 , L206 , COMPOS_1:35
.= ( R5 . ( IC ( Comput (R5 , C44 , ( C48 + 1 )) ) ) ) by L210 , L209 , L195 , GRFUNC_1:2
.= ( CurInstr (R5 , ( Comput (R5 , C44 , ( C48 + 1 )) )) ) by PBOOLE:143;
thus L213: thesis by L201 , L202 , L208 , L203 , L207 , SCMFSA6A:8 , XXREAL_0:2;
end;
L214: S3[ ( 0 ) ]
proof
L215: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L216: ( IC ( Comput (( R4 +* C45 ) , ( Initialize C43 ) , ( 0 )) ) ) = ( IC ( Initialize C43 ) )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L215 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
assume L217: ( 0 ) < ( pseudo-LifeSpan (C43 , R4 , C45) );
L218: ( 0 ) in ( dom C45 ) by L217 , L194 , L216 , SCMFSA8A:def 4;
L219: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L220: ( IC ( Comput (R4 , C43 , ( 0 )) ) ) = ( C43 . ( IC ( SCM+FSA ) ) )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L191 , L219 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
thus L221: ( ( IC ( Comput (R4 , C43 , ( 0 )) ) ) + C46 ) = ( IC ( Comput (R5 , C44 , ( 0 )) ) ) by L220 , L196;
L222: ( ( 0 ) + C46 ) in ( dom ( Reloc (C45 , C46) ) ) by L218 , COMPOS_1:46;
L223: ( R4 . ( IC C43 ) ) = ( R4 . ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) ) by L191 , L219 , GRFUNC_1:2
.= ( R4 . ( 0 ) ) by FUNCOP_1:72
.= ( C45 . ( 0 ) ) by L218 , L192 , GRFUNC_1:2;
L224: ( R4 /. ( IC C43 ) ) = ( R4 . ( IC C43 ) ) by PBOOLE:143;
L225: ( R5 /. ( IC C44 ) ) = ( R5 . ( IC C44 ) ) by PBOOLE:143;
thus L226: ( IncAddr (( CurInstr (R4 , ( Comput (R4 , C43 , ( 0 )) )) ) , C46) ) = ( ( Reloc (C45 , C46) ) . ( ( 0 ) + C46 ) ) by L218 , L224 , L223 , COMPOS_1:35
.= ( CurInstr (R5 , ( Comput (R5 , C44 , ( 0 )) )) ) by L196 , L222 , L225 , L195 , GRFUNC_1:2;
thus L227: ( DataPart ( Comput (R4 , C43 , ( 0 )) ) ) = ( DataPart C44 ) by L197
.= ( DataPart ( Comput (R5 , C44 , ( 0 )) ) );
end;
L228: (for B62 being (Element of ( NAT )) holds S3[ B62 ]) from NAT_1:sch 1(L214 , L200);
thus L229: ( IncAddr (( CurInstr (R4 , ( Comput (R4 , C43 , C47) )) ) , C46) ) = ( CurInstr (R5 , ( Comput (R5 , C44 , C47) )) ) by L228 , L199;
end;
L230: (for B63 being (Element of ( NAT )) holds (S2[ B63 ] implies S2[ ( B63 + 1 ) ]))
proof
let C49 being (Element of ( NAT ));
assume L231: S2[ C49 ];
set D24 = ( CurInstr (R4 , ( Comput (R4 , C43 , C49) )) );
L232: ( Comput (R5 , C44 , ( C49 + 1 )) ) = ( Following (R5 , ( Comput (R5 , C44 , C49) )) ) by EXTPRO_1:3;
assume L233: ( C49 + 1 ) <= ( pseudo-LifeSpan (C43 , R4 , C45) );
L234: ( C49 + 1 ) <= ( ( pseudo-LifeSpan (C43 , R4 , C45) ) + 1 ) by L233 , NAT_1:12;
L235: C49 < ( pseudo-LifeSpan (C43 , R4 , C45) ) by L233 , NAT_1:13;
L236: ( Comput (R4 , C43 , ( C49 + 1 )) ) = ( Following (R4 , ( Comput (R4 , C43 , C49) )) ) by EXTPRO_1:3;
thus L237: ( ( IC ( Comput (R4 , C43 , ( C49 + 1 )) ) ) + C46 ) = ( IC ( Exec (( IncAddr (D24 , C46) ) , ( Comput (R5 , C44 , C49) )) ) ) by L236 , L231 , L234 , SCMFSA6A:8 , XREAL_1:6
.= ( IC ( Comput (R5 , C44 , ( C49 + 1 )) ) ) by L198 , L235 , L232;
thus L238: ( DataPart ( Comput (R4 , C43 , ( C49 + 1 )) ) ) = ( DataPart ( Exec (( IncAddr (D24 , C46) ) , ( Comput (R5 , C44 , C49) )) ) ) by L231 , L234 , L236 , SCMFSA6A:8 , XREAL_1:6
.= ( DataPart ( Comput (R5 , C44 , ( C49 + 1 )) ) ) by L198 , L235 , L232;
end;
let C50 being (Element of ( NAT ));
assume L239: C50 <= ( pseudo-LifeSpan (C43 , R4 , C45) );
L240: S2[ ( 0 ) ]
proof
assume L241: ( 0 ) <= ( pseudo-LifeSpan (C43 , R4 , C45) );
L242: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L243: ( IC ( Comput (R4 , C43 , ( 0 )) ) ) = ( C43 . ( IC ( SCM+FSA ) ) )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L191 , L242 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
thus L244: ( ( IC ( Comput (R4 , C43 , ( 0 )) ) ) + C46 ) = ( IC ( Comput (R5 , C44 , ( 0 )) ) ) by L243 , L196;
thus L245: ( DataPart ( Comput (R4 , C43 , ( 0 )) ) ) = ( DataPart C44 ) by L197
.= ( DataPart ( Comput (R5 , C44 , ( 0 )) ) );
end;
L246: (for B64 being (Element of ( NAT )) holds S2[ B64 ]) from NAT_1:sch 1(L240 , L230);
thus L247: thesis by L246 , L239;
end;
theorem
L248: (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (Instruction-Sequence of ( SCM+FSA )) holds (for B65 , B66 being (State of ( SCM+FSA )) holds (for B67 being (Program of ( SCM+FSA )) holds (( DataPart B65 ) = ( DataPart B66 ) implies (B67 is_pseudo-closed_on B65 , R4 implies B67 is_pseudo-closed_on B66 , R5))))))
proof
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (Instruction-Sequence of ( SCM+FSA ));
let C51 , C52 being (State of ( SCM+FSA ));
set D25 = ( Data-Locations ( SCM+FSA ) );
let C53 being (Program of ( SCM+FSA ));
set D26 = ( Initialize C51 );
set D27 = ( R4 +* C53 );
set D28 = ( Initialize C52 );
set D29 = ( R5 +* C53 );
L249: C53 c= D27 by FUNCT_4:25;
L250: ( Reloc (C53 , ( 0 )) ) = C53;
L251: ( IC ( Initialize C52 ) ) = ( IC ( C52 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) )
.= ( 0 ) by FUNCT_4:113;
L252: C53 c= D29 by FUNCT_4:25;
assume L253: ( DataPart C51 ) = ( DataPart C52 );
L254: ( DataPart D26 ) = ( DataPart C52 ) by L253 , MEMSTR_0:79
.= ( DataPart D28 ) by MEMSTR_0:79;
assume L255: C53 is_pseudo-closed_on C51 , R4;
L256: ( IC ( Comput (D27 , D26 , ( pseudo-LifeSpan (C51 , R4 , C53) )) ) ) = ( card C53 ) by L255 , SCMFSA8A:def 4;
L257: C53 is_pseudo-closed_on D26 , D27 by L255 , L182;
L258:
now
let C54 being (Element of ( NAT ));
assume L259: C54 < ( pseudo-LifeSpan (C51 , R4 , C53) );
L260: C54 <= ( pseudo-LifeSpan (( Initialize C51 ) , ( R4 +* C53 ) , C53) ) by L259 , L255 , L182;
L261: ( IC ( Comput (D29 , D28 , C54) ) ) = ( ( IC ( Comput (D27 , D26 , C54) ) ) + ( 0 ) ) by L260 , L254 , L257 , L252 , L251 , L190 , L249 , L250
.= ( IC ( Comput (D27 , D26 , C54) ) );
thus L262: ( IC ( Comput (D29 , D28 , C54) ) ) in ( dom C53 ) by L261 , L255 , L259 , SCMFSA8A:def 4;
end;
L263: ( IC ( Comput (D29 , D28 , ( pseudo-LifeSpan (C51 , R4 , C53) )) ) ) = ( IC ( Comput (D29 , D28 , ( pseudo-LifeSpan (( Initialize C51 ) , ( R4 +* C53 ) , C53) )) ) ) by L255 , L182
.= ( ( IC ( Comput (D27 , D26 , ( pseudo-LifeSpan (( Initialize C51 ) , ( R4 +* C53 ) , C53) )) ) ) + ( 0 ) ) by L254 , L257 , L252 , L251 , L190 , L249 , L250
.= ( IC ( Comput (D27 , D26 , ( pseudo-LifeSpan (C51 , R4 , C53) )) ) ) by L255 , L182;
thus L264: thesis by L263 , L256 , L258 , SCMFSA8A:def 2;
end;
theorem
L265: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B68 being (State of ( SCM+FSA )) holds (for B69 being (Program of ( SCM+FSA )) holds (( B68 . ( intloc ( 0 ) ) ) = 1 implies (B69 is_pseudo-closed_on B68 , R2 iff B69 is_pseudo-closed_on ( Initialized B68 ) , R2)))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C55 being (State of ( SCM+FSA ));
set D30 = ( Data-Locations ( SCM+FSA ) );
let C56 being (Program of ( SCM+FSA ));
assume L266: ( C55 . ( intloc ( 0 ) ) ) = 1;
L267: ( DataPart C55 ) = ( DataPart ( Initialized C55 ) ) by L266 , SCMFSA_M:19;
thus L268: thesis by L267 , L248;
end;
theorem
L269: (for B70 being Int-Location holds (for B71 , B72 being (Program of ( SCM+FSA )) holds (( 0 ) in ( dom ( if=0 (B70 , B71 , B72) ) ) & 1 in ( dom ( if=0 (B70 , B71 , B72) ) ) & ( 0 ) in ( dom ( if>0 (B70 , B71 , B72) ) ) & 1 in ( dom ( if>0 (B70 , B71 , B72) ) ))))
proof
let C57 being Int-Location;
let C58 , C59 being (Program of ( SCM+FSA ));
set D31 = ( C57 =0_goto ( ( card C59 ) + 3 ) );
L270: ( if=0 (C57 , C58 , C59) ) = ( ( ( ( D31 ";" C59 ) ";" ( Goto ( ( card C58 ) + 1 ) ) ) ";" C58 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1
.= ( ( ( D31 ";" C59 ) ";" ( Goto ( ( card C58 ) + 1 ) ) ) ";" ( C58 ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:25
.= ( ( D31 ";" C59 ) ";" ( ( Goto ( ( card C58 ) + 1 ) ) ";" ( C58 ";" ( Stop ( SCM+FSA ) ) ) ) ) by SCMFSA6A:25
.= ( D31 ";" ( C59 ";" ( ( Goto ( ( card C58 ) + 1 ) ) ";" ( C58 ";" ( Stop ( SCM+FSA ) ) ) ) ) ) by SCMFSA6A:29
.= ( ( Macro D31 ) ";" ( C59 ";" ( ( Goto ( ( card C58 ) + 1 ) ) ";" ( C58 ";" ( Stop ( SCM+FSA ) ) ) ) ) );
L271: ( dom ( Macro D31 ) ) c= ( dom ( if=0 (C57 , C58 , C59) ) ) by L270 , SCMFSA6A:17;
L272: ( dom ( Macro D31 ) ) = { ( 0 ) , 1 } by COMPOS_1:61;
L273: 1 in ( dom ( Macro D31 ) ) by L272 , TARSKI:def 2;
L274: ( 0 ) in ( dom ( Macro D31 ) ) by L272 , TARSKI:def 2;
thus L275: (( 0 ) in ( dom ( if=0 (C57 , C58 , C59) ) ) & 1 in ( dom ( if=0 (C57 , C58 , C59) ) )) by L274 , L271 , L273;
set D32 = ( C57 >0_goto ( ( card C59 ) + 3 ) );
L276: ( if>0 (C57 , C58 , C59) ) = ( ( ( ( D32 ";" C59 ) ";" ( Goto ( ( card C58 ) + 1 ) ) ) ";" C58 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2
.= ( ( ( D32 ";" C59 ) ";" ( Goto ( ( card C58 ) + 1 ) ) ) ";" ( C58 ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:25
.= ( ( D32 ";" C59 ) ";" ( ( Goto ( ( card C58 ) + 1 ) ) ";" ( C58 ";" ( Stop ( SCM+FSA ) ) ) ) ) by SCMFSA6A:25
.= ( D32 ";" ( C59 ";" ( ( Goto ( ( card C58 ) + 1 ) ) ";" ( C58 ";" ( Stop ( SCM+FSA ) ) ) ) ) ) by SCMFSA6A:29
.= ( ( Macro D32 ) ";" ( C59 ";" ( ( Goto ( ( card C58 ) + 1 ) ) ";" ( C58 ";" ( Stop ( SCM+FSA ) ) ) ) ) );
L277: ( dom ( Macro D32 ) ) c= ( dom ( if>0 (C57 , C58 , C59) ) ) by L276 , SCMFSA6A:17;
L278: ( dom ( Macro D32 ) ) = { ( 0 ) , 1 } by COMPOS_1:61;
L279: 1 in ( dom ( Macro D32 ) ) by L278 , TARSKI:def 2;
L280: ( 0 ) in ( dom ( Macro D32 ) ) by L278 , TARSKI:def 2;
thus L281: thesis by L280 , L277 , L279;
end;
theorem
L282: (for B73 being Int-Location holds (for B74 , B75 being (Program of ( SCM+FSA )) holds (( ( if=0 (B73 , B74 , B75) ) . ( 0 ) ) = ( B73 =0_goto ( ( card B75 ) + 3 ) ) & ( ( if=0 (B73 , B74 , B75) ) . 1 ) = ( goto 2 ) & ( ( if>0 (B73 , B74 , B75) ) . ( 0 ) ) = ( B73 >0_goto ( ( card B75 ) + 3 ) ) & ( ( if>0 (B73 , B74 , B75) ) . 1 ) = ( goto 2 ))))
proof
let C60 being Int-Location;
let C61 , C62 being (Program of ( SCM+FSA ));
set D33 = ( C60 =0_goto ( ( card C62 ) + 3 ) );
L283: ( if=0 (C60 , C61 , C62) ) = ( ( ( ( D33 ";" C62 ) ";" ( Goto ( ( card C61 ) + 1 ) ) ) ";" C61 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1
.= ( ( ( D33 ";" C62 ) ";" ( Goto ( ( card C61 ) + 1 ) ) ) ";" ( C61 ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:25
.= ( ( D33 ";" C62 ) ";" ( ( Goto ( ( card C61 ) + 1 ) ) ";" ( C61 ";" ( Stop ( SCM+FSA ) ) ) ) ) by SCMFSA6A:25
.= ( D33 ";" ( C62 ";" ( ( Goto ( ( card C61 ) + 1 ) ) ";" ( C61 ";" ( Stop ( SCM+FSA ) ) ) ) ) ) by SCMFSA6A:29
.= ( ( Macro D33 ) ";" ( C62 ";" ( ( Goto ( ( card C61 ) + 1 ) ) ";" ( C61 ";" ( Stop ( SCM+FSA ) ) ) ) ) );
L284: ( dom ( Macro D33 ) ) = { ( 0 ) , 1 } by COMPOS_1:61;
L285: ( 0 ) in ( dom ( Macro D33 ) ) by L284 , TARSKI:def 2;
thus L286: ( ( if=0 (C60 , C61 , C62) ) . ( 0 ) ) = ( ( Directed ( Macro D33 ) ) . ( 0 ) ) by L285 , L283 , SCMFSA8A:14
.= D33 by SCMFSA7B:1;
L287: 1 in ( dom ( Macro D33 ) ) by L284 , TARSKI:def 2;
thus L288: ( ( if=0 (C60 , C61 , C62) ) . 1 ) = ( ( Directed ( Macro D33 ) ) . 1 ) by L287 , L283 , SCMFSA8A:14
.= ( goto 2 ) by SCMFSA7B:2;
set D34 = ( C60 >0_goto ( ( card C62 ) + 3 ) );
L289: ( if>0 (C60 , C61 , C62) ) = ( ( ( ( D34 ";" C62 ) ";" ( Goto ( ( card C61 ) + 1 ) ) ) ";" C61 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2
.= ( ( ( D34 ";" C62 ) ";" ( Goto ( ( card C61 ) + 1 ) ) ) ";" ( C61 ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:25
.= ( ( D34 ";" C62 ) ";" ( ( Goto ( ( card C61 ) + 1 ) ) ";" ( C61 ";" ( Stop ( SCM+FSA ) ) ) ) ) by SCMFSA6A:25
.= ( D34 ";" ( C62 ";" ( ( Goto ( ( card C61 ) + 1 ) ) ";" ( C61 ";" ( Stop ( SCM+FSA ) ) ) ) ) ) by SCMFSA6A:29
.= ( ( Macro D34 ) ";" ( C62 ";" ( ( Goto ( ( card C61 ) + 1 ) ) ";" ( C61 ";" ( Stop ( SCM+FSA ) ) ) ) ) );
L290: ( dom ( Macro D34 ) ) = { ( 0 ) , 1 } by COMPOS_1:61;
L291: ( 0 ) in ( dom ( Macro D34 ) ) by L290 , TARSKI:def 2;
thus L292: ( ( if>0 (C60 , C61 , C62) ) . ( 0 ) ) = ( ( Directed ( Macro D34 ) ) . ( 0 ) ) by L291 , L289 , SCMFSA8A:14
.= D34 by SCMFSA7B:1;
L293: 1 in ( dom ( Macro D34 ) ) by L290 , TARSKI:def 2;
thus L294: ( ( if>0 (C60 , C61 , C62) ) . 1 ) = ( ( Directed ( Macro D34 ) ) . 1 ) by L293 , L289 , SCMFSA8A:14
.= ( goto 2 ) by SCMFSA7B:2;
end;
theorem
L295: (for B76 being Int-Location holds (for B77 , B78 being (Program of ( SCM+FSA )) holds (for B79 being (Element of ( NAT )) holds (B79 < ( ( ( card B77 ) + ( card B78 ) ) + 3 ) implies (B79 in ( dom ( if=0 (B76 , B77 , B78) ) ) & ( ( if=0 (B76 , B77 , B78) ) . B79 ) <> ( halt ( SCM+FSA ) ))))))
proof
let C63 being Int-Location;
let C64 , C65 being (Program of ( SCM+FSA ));
let C66 being (Element of ( NAT ));
set D35 = ( ( ( ( C63 =0_goto ( ( card C65 ) + 3 ) ) ";" C65 ) ";" ( Goto ( ( card C64 ) + 1 ) ) ) ";" C64 );
L296: ( card D35 ) = ( ( card ( ( ( Macro ( C63 =0_goto ( ( card C65 ) + 3 ) ) ) ";" C65 ) ";" ( Goto ( ( card C64 ) + 1 ) ) ) ) + ( card C64 ) ) by SCMFSA6A:21
.= ( ( ( card ( ( Macro ( C63 =0_goto ( ( card C65 ) + 3 ) ) ) ";" C65 ) ) + ( card ( Goto ( ( card C64 ) + 1 ) ) ) ) + ( card C64 ) ) by SCMFSA6A:21
.= ( ( ( card ( ( Macro ( C63 =0_goto ( ( card C65 ) + 3 ) ) ) ";" C65 ) ) + 1 ) + ( card C64 ) ) by SCMFSA8A:15
.= ( ( ( ( card ( Macro ( C63 =0_goto ( ( card C65 ) + 3 ) ) ) ) + ( card C65 ) ) + 1 ) + ( card C64 ) ) by SCMFSA6A:21
.= ( ( ( 2 + ( card C65 ) ) + 1 ) + ( card C64 ) ) by COMPOS_1:56
.= ( ( ( card C64 ) + ( card C65 ) ) + 3 );
assume L297: C66 < ( ( ( card C64 ) + ( card C65 ) ) + 3 );
L298: C66 in ( dom D35 ) by L297 , L296 , AFINSQ_1:66;
L299: C66 in ( dom ( Directed D35 ) ) by L298 , FUNCT_4:99;
L300: ( ( Directed D35 ) . C66 ) in ( rng ( Directed D35 ) ) by L299 , FUNCT_1:def 3;
L301: ( if=0 (C63 , C64 , C65) ) = ( ( ( ( ( C63 =0_goto ( ( card C65 ) + 3 ) ) ";" C65 ) ";" ( Goto ( ( card C64 ) + 1 ) ) ) ";" C64 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1;
L302: ( Directed D35 ) c= ( if=0 (C63 , C64 , C65) ) by L301 , SCMFSA6A:16;
L303: ( dom ( Directed D35 ) ) c= ( dom ( if=0 (C63 , C64 , C65) ) ) by L302 , GRFUNC_1:2;
thus L304: C66 in ( dom ( if=0 (C63 , C64 , C65) ) ) by L303 , L299;
L305: ( ( if=0 (C63 , C64 , C65) ) . C66 ) = ( ( Directed D35 ) . C66 ) by L299 , L302 , GRFUNC_1:2;
thus L306: thesis by L305 , L300 , COMPOS_1:def 11;
end;
theorem
L307: (for B80 being Int-Location holds (for B81 , B82 being (Program of ( SCM+FSA )) holds (for B83 being (Element of ( NAT )) holds (B83 < ( ( ( card B81 ) + ( card B82 ) ) + 3 ) implies (B83 in ( dom ( if>0 (B80 , B81 , B82) ) ) & ( ( if>0 (B80 , B81 , B82) ) . B83 ) <> ( halt ( SCM+FSA ) ))))))
proof
let C67 being Int-Location;
let C68 , C69 being (Program of ( SCM+FSA ));
let C70 being (Element of ( NAT ));
set D36 = ( ( ( ( C67 >0_goto ( ( card C69 ) + 3 ) ) ";" C69 ) ";" ( Goto ( ( card C68 ) + 1 ) ) ) ";" C68 );
L308: ( card D36 ) = ( ( card ( ( ( Macro ( C67 >0_goto ( ( card C69 ) + 3 ) ) ) ";" C69 ) ";" ( Goto ( ( card C68 ) + 1 ) ) ) ) + ( card C68 ) ) by SCMFSA6A:21
.= ( ( ( card ( ( Macro ( C67 >0_goto ( ( card C69 ) + 3 ) ) ) ";" C69 ) ) + ( card ( Goto ( ( card C68 ) + 1 ) ) ) ) + ( card C68 ) ) by SCMFSA6A:21
.= ( ( ( card ( ( Macro ( C67 >0_goto ( ( card C69 ) + 3 ) ) ) ";" C69 ) ) + 1 ) + ( card C68 ) ) by SCMFSA8A:15
.= ( ( ( ( card ( Macro ( C67 >0_goto ( ( card C69 ) + 3 ) ) ) ) + ( card C69 ) ) + 1 ) + ( card C68 ) ) by SCMFSA6A:21
.= ( ( ( 2 + ( card C69 ) ) + 1 ) + ( card C68 ) ) by COMPOS_1:56
.= ( ( ( card C68 ) + ( card C69 ) ) + 3 );
assume L309: C70 < ( ( ( card C68 ) + ( card C69 ) ) + 3 );
L310: C70 in ( dom D36 ) by L309 , L308 , AFINSQ_1:66;
L311: C70 in ( dom ( Directed D36 ) ) by L310 , FUNCT_4:99;
L312: ( ( Directed D36 ) . C70 ) in ( rng ( Directed D36 ) ) by L311 , FUNCT_1:def 3;
L313: ( if>0 (C67 , C68 , C69) ) = ( ( ( ( ( C67 >0_goto ( ( card C69 ) + 3 ) ) ";" C69 ) ";" ( Goto ( ( card C68 ) + 1 ) ) ) ";" C68 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2;
L314: ( Directed D36 ) c= ( if>0 (C67 , C68 , C69) ) by L313 , SCMFSA6A:16;
L315: ( dom ( Directed D36 ) ) c= ( dom ( if>0 (C67 , C68 , C69) ) ) by L314 , GRFUNC_1:2;
thus L316: C70 in ( dom ( if>0 (C67 , C68 , C69) ) ) by L315 , L311;
L317: ( ( if>0 (C67 , C68 , C69) ) . C70 ) = ( ( Directed D36 ) . C70 ) by L311 , L314 , GRFUNC_1:2;
thus L318: thesis by L317 , L312 , COMPOS_1:def 11;
end;
theorem
L319: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B84 being (State of ( SCM+FSA )) holds (for B85 being (Program of ( SCM+FSA )) holds (( Directed B85 ) is_pseudo-closed_on B84 , R2 implies (( B85 ";" ( Stop ( SCM+FSA ) ) ) is_closed_on B84 , R2 & ( B85 ";" ( Stop ( SCM+FSA ) ) ) is_halting_on B84 , R2 & ( LifeSpan (( R2 +* ( B85 ";" ( Stop ( SCM+FSA ) ) ) ) , ( Initialize B84 )) ) = ( pseudo-LifeSpan (B84 , R2 , ( Directed B85 )) ) & (for B86 being (Element of ( NAT )) holds (B86 < ( pseudo-LifeSpan (B84 , R2 , ( Directed B85 )) ) implies ( IC ( Comput (( R2 +* B85 ) , ( Initialize B84 ) , B86) ) ) = ( IC ( Comput (( R2 +* ( B85 ";" ( Stop ( SCM+FSA ) ) ) ) , ( Initialize B84 ) , B86) ) ))) & (for B87 being (Element of ( NAT )) holds (B87 <= ( pseudo-LifeSpan (B84 , R2 , ( Directed B85 )) ) implies ( DataPart ( Comput (( R2 +* B85 ) , ( Initialize B84 ) , B87) ) ) = ( DataPart ( Comput (( R2 +* ( B85 ";" ( Stop ( SCM+FSA ) ) ) ) , ( Initialize B84 ) , B87) ) ))))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C71 being (State of ( SCM+FSA ));
set D37 = ( Data-Locations ( SCM+FSA ) );
let C72 being (Program of ( SCM+FSA ));
set D38 = ( Directed C72 );
set D39 = ( C72 ";" ( Stop ( SCM+FSA ) ) );
set D40 = ( Initialize C71 );
set D41 = ( R2 +* D38 );
set D42 = ( Initialize C71 );
set D43 = ( R2 +* D39 );
reconsider D44 = ( pseudo-LifeSpan (D40 , D41 , D38) ) as (Element of ( NAT ));
L320: ( ( Stop ( SCM+FSA ) ) . ( 0 ) ) = ( halt ( SCM+FSA ) ) by AFINSQ_1:34;
L321: ( halt ( SCM+FSA ) ) = ( ( Stop ( SCM+FSA ) ) . ( ( card C72 ) -' ( card C72 ) ) ) by L320 , XREAL_1:232;
L322: ( DataPart D40 ) = ( DataPart D42 );
assume L323: D38 is_pseudo-closed_on C71 , R2;
L324: D38 is_pseudo-closed_on D40 , D41 by L323 , L182;
defpred S4[ Nat ] means (D44 <= $1 implies (( IC ( Comput (D43 , D42 , $1) ) ) = ( card C72 ) & ( CurInstr (D43 , ( Comput (D43 , D42 , $1) )) ) = ( halt ( SCM+FSA ) )));
L325: D39 c= D43 by FUNCT_4:25;
L326: D39 c= D43 by FUNCT_4:25;
L327: D38 c= D39 by SCMFSA6A:16;
L328: ( dom D38 ) c= ( dom D39 ) by L327 , GRFUNC_1:2;
L329: D38 c= D43 by L327 , L325 , XBOOLE_1:1;
L330: ( Reloc (D38 , ( 0 )) ) c= D39 by L327;
L331: ( Reloc (D38 , ( 0 )) ) c= D43 by L330 , L326 , XBOOLE_1:1;
L332: ( IC D42 ) = ( 0 ) by FUNCT_4:113;
L333: D38 c= D41 by FUNCT_4:25;
L334:
now
let C73 being (Element of ( NAT ));
assume L335: C73 <= ( pseudo-LifeSpan (D40 , D41 , D38) );
L336: ( ( IC ( Comput (D41 , D40 , C73) ) ) + ( 0 ) ) = ( IC ( Comput (D43 , D42 , C73) ) ) by L335 , L324 , L331 , L332 , L322 , L190 , L333;
thus L337: ( IC ( Comput (D41 , D40 , C73) ) ) = ( IC ( Comput (D43 , D42 , C73) ) ) by L336;
thus L338: ( DataPart ( Comput (D41 , D40 , C73) ) ) = ( DataPart ( Comput (D43 , D42 , C73) ) ) by L324 , L331 , L332 , L322 , L335 , L190 , L333;
end;
L339: D44 = ( pseudo-LifeSpan (C71 , R2 , D38) ) by L323 , L182;
L340: ( Initialize D40 ) = D40;
L341: ( D41 +* D38 ) = ( R2 +* ( D38 +* D38 ) )
.= D41;
L342:
now
let C74 being (Element of ( NAT ));
assume L343: C74 < ( pseudo-LifeSpan (D40 , D41 , D38) );
L344: ( IncAddr (( CurInstr (D41 , ( Comput (D41 , D40 , C74) )) ) , ( 0 )) ) = ( CurInstr (D43 , ( Comput (D43 , D42 , C74) )) ) by L343 , L324 , L331 , L332 , L322 , L190 , L333;
thus L345: ( CurInstr (D41 , ( Comput (D41 , D40 , C74) )) ) = ( CurInstr (D43 , ( Comput (D43 , D42 , C74) )) ) by L344 , COMPOS_0:3;
thus L346: ( IC ( Comput (D41 , D40 , C74) ) ) in ( dom D38 ) by L340 , L324 , L343 , L341 , SCMFSA8A:17;
thus L347: ( CurInstr (D41 , ( Comput (D41 , D40 , C74) )) ) <> ( halt ( SCM+FSA ) ) by L340 , L324 , L343 , L341 , SCMFSA8A:17;
end;
L348:
now
let C75 being (Element of ( NAT ));
assume L349: ( CurInstr (D43 , ( Comput (D43 , D42 , C75) )) ) = ( halt ( SCM+FSA ) );
reconsider D45 = ( IC ( Comput (D41 , D40 , C75) ) ) as (Element of ( NAT ));
assume L350: D44 > C75;
L351: D45 in ( dom D38 ) by L350 , L323 , L339 , SCMFSA8A:def 4;
L352: ( CurInstr (D43 , ( Comput (D43 , D42 , C75) )) ) = ( CurInstr (D41 , ( Comput (D41 , D40 , C75) )) ) by L342 , L350
.= ( D41 . D45 ) by PBOOLE:143
.= ( D38 . D45 ) by L351 , L333 , GRFUNC_1:2;
L353: ( halt ( SCM+FSA ) ) in ( rng D38 ) by L352 , L349 , L351 , FUNCT_1:def 3;
thus L354: contradiction by L353 , COMPOS_1:def 11;
end;
L355: ( card ( Stop ( SCM+FSA ) ) ) = 1 by AFINSQ_1:33;
L356: ( card D39 ) = ( ( card C72 ) + 1 ) by L355 , SCMFSA6A:21;
L357: ( card C72 ) < ( card D39 ) by L356 , NAT_1:13;
L358: ( card C72 ) in ( dom D39 ) by L357 , AFINSQ_1:66;
L359: ( card C72 ) < ( ( card C72 ) + ( card ( Stop ( SCM+FSA ) ) ) ) by L355 , NAT_1:13;
L360: ( D39 . ( card C72 ) ) = ( IncAddr (( halt ( SCM+FSA ) ) , ( card C72 )) ) by L359 , L321 , L7
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
L361: ( D43 . ( card C72 ) ) = ( halt ( SCM+FSA ) ) by L360 , L358 , L325 , GRFUNC_1:2;
L362: (for B88 being (Element of ( NAT )) holds (S4[ B88 ] implies S4[ ( B88 + 1 ) ]))
proof
let C76 being (Element of ( NAT ));
assume L363: S4[ C76 ];
assume L364: D44 <= ( C76 + 1 );
thus L365:now
per cases  by L364 , NAT_1:8;
suppose L366: D44 = ( C76 + 1 );

thus L367: ( IC ( Comput (D43 , D42 , ( C76 + 1 )) ) ) = ( IC ( Comput (D41 , D40 , D44) ) ) by L366 , L334
.= ( card D38 ) by L323 , L339 , SCMFSA8A:def 4
.= ( card C72 ) by SCMFSA8A:20;
end;
suppose L368: D44 <= C76;

L369: ( Comput (D43 , D42 , ( C76 + 1 )) ) = ( Following (D43 , ( Comput (D43 , D42 , C76) )) ) by EXTPRO_1:3;
thus L370: ( IC ( Comput (D43 , D42 , ( C76 + 1 )) ) ) = ( card C72 ) by L369 , L363 , L368 , EXTPRO_1:def 3;
end;
end;
thus L372: thesis by L365 , L361 , PBOOLE:143;
end;
L373: S4[ ( 0 ) ]
proof
assume L374: D44 <= ( 0 );
L375: D44 = ( 0 ) by L374;
thus L376: ( IC ( Comput (D43 , D42 , ( 0 )) ) ) = ( IC ( Comput (D41 , D40 , D44) ) ) by L375 , L334
.= ( card D38 ) by L323 , L339 , SCMFSA8A:def 4
.= ( card C72 ) by SCMFSA8A:20;
thus L377: ( CurInstr (D43 , ( Comput (D43 , D42 , ( 0 )) )) ) = ( D43 . ( card C72 ) ) by L376 , PBOOLE:143
.= ( halt ( SCM+FSA ) ) by L360 , L358 , L325 , GRFUNC_1:2;
end;
L378: (for B89 being (Element of ( NAT )) holds S4[ B89 ]) from NAT_1:sch 1(L373 , L362);
L379:
now
let C77 being (Element of ( NAT ));
per cases ;
suppose L380: C77 < D44;

L381: ( IC ( Comput (D41 , D40 , C77) ) ) = ( IC ( Comput (D43 , D42 , C77) ) ) by L380 , L334;
L382: ( IC ( Comput (D43 , D42 , C77) ) ) in ( dom D38 ) by L381 , L323 , L339 , L380 , SCMFSA8A:def 4;
thus L383: ( IC ( Comput (D43 , D42 , C77) ) ) in ( dom D39 ) by L382 , L328;
end;
suppose L384: D44 <= C77;

thus L385: ( IC ( Comput (D43 , D42 , C77) ) ) in ( dom D39 ) by L384 , L358 , L378;
end;
end;
thus L387: D39 is_closed_on C71 , R2 by L379 , SCMFSA7B:def 6;
set D46 = ( Initialize C71 );
set D47 = ( R2 +* C72 );
L388: C72 c= D47 by FUNCT_4:25;
L389: ( card D38 ) = ( card C72 ) by SCMFSA8A:20;
L390: S4[ D44 ] by L378;
L391: D43 halts_on D42 by L390 , EXTPRO_1:29;
thus L392: D39 is_halting_on C71 , R2 by L391 , SCMFSA7B:def 7;
L393: ( CurInstr (D43 , ( Comput (D43 , D42 , D44) )) ) = ( halt ( SCM+FSA ) ) by L378;
L394: ( LifeSpan (D43 , D42) ) = D44 by L393 , L391 , L348 , EXTPRO_1:def 15;
defpred S5[ Nat ] means ($1 < ( pseudo-LifeSpan (C71 , R2 , D38) ) implies (( IC ( Comput (D47 , D46 , $1) ) ) in ( dom C72 ) & ( IC ( Comput (D47 , D46 , $1) ) ) = ( IC ( Comput (D43 , D42 , $1) ) ) & ( DataPart ( Comput (D47 , D46 , $1) ) ) = ( DataPart ( Comput (D43 , D42 , $1) ) )));
L395: (for B90 being (Element of ( NAT )) holds (S5[ B90 ] implies S5[ ( B90 + 1 ) ]))
proof
let C78 being (Element of ( NAT ));
set D48 = ( IC ( Comput (D47 , D46 , C78) ) );
set D49 = ( IC ( Comput (D43 , D42 , C78) ) );
assume L396: S5[ C78 ];
assume L397: ( C78 + 1 ) < ( pseudo-LifeSpan (C71 , R2 , D38) );
L398: D49 in ( dom D38 ) by L397 , L396 , FUNCT_4:99 , NAT_1:12;
L399: (for B91 being FinSeq-Location holds ( ( Comput (D47 , D46 , C78) ) . B91 ) = ( ( Comput (D43 , D42 , C78) ) . B91 )) by L396 , L397 , NAT_1:12 , SCMFSA_M:2;
L400: (for B92 being Int-Location holds ( ( Comput (D47 , D46 , C78) ) . B92 ) = ( ( Comput (D43 , D42 , C78) ) . B92 )) by L396 , L397 , NAT_1:12 , SCMFSA_M:2;
L401: ( Comput (D47 , D46 , C78) ) = ( Comput (D43 , D42 , C78) ) by L400 , L396 , L397 , L399 , NAT_1:12 , SCMFSA_2:61;
L402:
now
assume L403: ( C72 . D48 ) = ( halt ( SCM+FSA ) );
L404: ( D41 /. ( IC ( Comput (D41 , D40 , C78) ) ) ) = ( D41 . ( IC ( Comput (D41 , D40 , C78) ) ) ) by PBOOLE:143;
L405: C78 < D44 by L339 , L397 , NAT_1:12;
L406: ( CurInstr (D41 , ( Comput (D41 , D40 , C78) )) ) = ( D41 . D49 ) by L405 , L334 , L404
.= ( D38 . D49 ) by L398 , L333 , GRFUNC_1:2
.= ( goto ( card C72 ) ) by L396 , L397 , L403 , NAT_1:12 , SCMFSA8A:16;
L407: ( IC ( Comput (D41 , D40 , ( C78 + 1 )) ) ) = ( IC ( Following (D41 , ( Comput (D41 , D40 , C78) )) ) ) by EXTPRO_1:3
.= ( card C72 ) by L406 , SCMFSA_2:69
.= ( card D38 ) by SCMFSA8A:20;
L408: ( IC ( Comput (D41 , D40 , ( C78 + 1 )) ) ) in ( dom D38 ) by L323 , L397 , SCMFSA8A:17;
thus L409: contradiction by L408 , L407;
end;
L410: ( CurInstr (D47 , ( Comput (D47 , D46 , C78) )) ) = ( D47 . D48 ) by PBOOLE:143
.= ( C72 . D48 ) by L388 , L396 , L397 , GRFUNC_1:2 , NAT_1:12
.= ( D38 . D49 ) by L396 , L397 , L402 , NAT_1:12 , SCMFSA8A:16
.= ( D43 . D49 ) by L398 , L329 , GRFUNC_1:2
.= ( CurInstr (D43 , ( Comput (D43 , D42 , C78) )) ) by PBOOLE:143;
L411: ( Comput (D43 , D42 , ( C78 + 1 )) ) = ( Following (D43 , ( Comput (D43 , D42 , C78) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D47 , ( Comput (D47 , D46 , C78) )) ) , ( Comput (D43 , D42 , C78) )) ) by L410;
L412: ( pseudo-LifeSpan (C71 , R2 , D38) ) = D44 by L323 , L182;
L413: ( IC ( Comput (D41 , D40 , ( C78 + 1 )) ) ) = ( IC ( Comput (D43 , D42 , ( C78 + 1 )) ) ) by L412 , L334 , L397;
L414: ( dom D38 ) = ( dom C72 ) by FUNCT_4:99;
L415: ( Comput (D47 , D46 , ( C78 + 1 )) ) = ( Following (D47 , ( Comput (D47 , D46 , C78) )) ) by EXTPRO_1:3;
L416: ( Comput (D47 , D46 , ( C78 + 1 )) ) = ( Comput (D43 , D42 , ( C78 + 1 )) ) by L415 , L411 , L401;
L417: (for B93 being FinSeq-Location holds ( ( Comput (D47 , D46 , ( C78 + 1 )) ) . B93 ) = ( ( Comput (D43 , D42 , ( C78 + 1 )) ) . B93 )) by L416;
L418: ( IC ( Comput (D41 , D40 , ( C78 + 1 )) ) ) in ( dom D38 ) by L323 , L397 , SCMFSA8A:17;
thus L419: ( IC ( Comput (D47 , D46 , ( C78 + 1 )) ) ) in ( dom C72 ) by L418 , L413 , L414 , L416;
thus L420: ( IC ( Comput (D47 , D46 , ( C78 + 1 )) ) ) = ( IC ( Comput (D43 , D42 , ( C78 + 1 )) ) ) by L416;
L421: (for B94 being Int-Location holds ( ( Comput (D47 , D46 , ( C78 + 1 )) ) . B94 ) = ( ( Comput (D43 , D42 , ( C78 + 1 )) ) . B94 )) by L416;
thus L422: thesis by L421 , L417 , SCMFSA_M:2;
end;
L423: ( IC ( Comput (D43 , D42 , D44) ) ) = ( card C72 ) by L378;
L424: ( IC ( Comput (D41 , D40 , ( LifeSpan (D43 , D42) )) ) ) = ( card C72 ) by L423 , L334 , L394;
L425: (for B95 being (Element of ( NAT )) holds ((not ( IC ( Comput (D41 , D40 , B95) ) ) in ( dom D38 )) implies ( LifeSpan (D43 , D42) ) <= B95)) by L342 , L394;
thus L426: ( LifeSpan (D43 , D42) ) = ( pseudo-LifeSpan (C71 , R2 , D38) ) by L425 , L323 , L424 , L389 , SCMFSA8A:def 4;
L427: S5[ ( 0 ) ]
proof
L428: ( IC ( Comput (D47 , D46 , ( 0 )) ) ) = ( IC D46 )
.= ( IC ( Initialize C71 ) )
.= ( 0 ) by FUNCT_4:113;
assume L429: ( 0 ) < ( pseudo-LifeSpan (C71 , R2 , D38) );
L430: ( IC ( Comput (( R2 +* D38 ) , ( Initialize C71 ) , ( 0 )) ) ) in ( dom D38 ) by L429 , L323 , SCMFSA8A:17;
L431: ( IC ( Initialize C71 ) ) in ( dom D38 ) by L430;
L432: ( 0 ) in ( dom D38 ) by L431 , MEMSTR_0:16;
thus L433: ( IC ( Comput (D47 , D46 , ( 0 )) ) ) in ( dom C72 ) by L432 , L428 , FUNCT_4:99;
thus L434: ( IC ( Comput (D47 , D46 , ( 0 )) ) ) = ( IC ( Comput (D43 , D42 , ( 0 )) ) );
thus L435: ( DataPart ( Comput (D47 , D46 , ( 0 )) ) ) = ( DataPart D46 )
.= ( DataPart D42 )
.= ( DataPart ( Comput (D43 , D42 , ( 0 )) ) );
end;
L436: (for B96 being (Element of ( NAT )) holds S5[ B96 ]) from NAT_1:sch 1(L427 , L395);
thus L437: (for B97 being (Element of ( NAT )) holds (B97 < ( pseudo-LifeSpan (C71 , R2 , D38) ) implies ( IC ( Comput (D47 , D46 , B97) ) ) = ( IC ( Comput (D43 , D42 , B97) ) ))) by L436;
let C79 being (Element of ( NAT ));
assume L438: C79 <= ( pseudo-LifeSpan (C71 , R2 , ( Directed C72 )) );
per cases  by L438 , XXREAL_0:1;
suppose L439: C79 < ( pseudo-LifeSpan (C71 , R2 , D38) );

thus L440: thesis by L439 , L436;
end;
suppose L441: C79 = ( pseudo-LifeSpan (C71 , R2 , D38) );

per cases  by NAT_1:6;
suppose L442: C79 = ( 0 );

thus L443: ( DataPart ( Comput (D47 , D46 , C79) ) ) = ( DataPart D46 ) by L442 , EXTPRO_1:2
.= ( DataPart D42 )
.= ( DataPart ( Comput (D43 , D42 , C79) ) ) by L442 , EXTPRO_1:2;
end;
suppose L444: (ex B98 being Nat st C79 = ( B98 + 1 ));

consider C80 being Nat such that L445: C79 = ( C80 + 1 ) by L444;
reconsider D50 = C80 as (Element of ( NAT )) by ORDINAL1:def 12;
L446: ( Comput (D43 , D42 , C79) ) = ( Following (D43 , ( Comput (D43 , D42 , D50) )) ) by L445 , EXTPRO_1:3;
set D51 = ( CurInstr (D47 , ( Comput (D47 , D46 , D50) )) );
L447: ( Comput (D47 , D46 , C79) ) = ( Following (D47 , ( Comput (D47 , D46 , D50) )) ) by L445 , EXTPRO_1:3;
set D52 = ( IC ( Comput (D43 , D42 , D50) ) );
set D53 = ( IC ( Comput (D47 , D46 , D50) ) );
L448: ( D50 + ( 0 ) ) < ( pseudo-LifeSpan (C71 , R2 , D38) ) by L441 , L445 , XREAL_1:6;
L449: D53 = D52 by L448 , L436;
L450: D53 in ( dom C72 ) by L436 , L448;
L451: D52 in ( dom D38 ) by L450 , L449 , FUNCT_4:99;
L452: D51 = ( D47 . D53 ) by PBOOLE:143
.= ( C72 . D53 ) by L388 , L450 , GRFUNC_1:2;
L453: D38 c= D39 by SCMFSA6A:16;
L454: ( dom D38 ) c= ( dom D39 ) by L453 , RELAT_1:11;
L455: ( D38 . D52 ) = ( D39 . D52 ) by L451 , L453 , GRFUNC_1:2
.= ( D43 . D52 ) by L325 , L454 , L451 , GRFUNC_1:2
.= ( CurInstr (D43 , ( Comput (D43 , D42 , D50) )) ) by PBOOLE:143;
L456: ( DataPart ( Comput (D47 , D46 , D50) ) ) = ( DataPart ( Comput (D43 , D42 , D50) ) ) by L436 , L448;
per cases ;
suppose L457: D51 = ( halt ( SCM+FSA ) );

L458: ( CurInstr (D43 , ( Comput (D43 , D42 , D50) )) ) = ( goto ( card C72 ) ) by L457 , L450 , L449 , L452 , L455 , SCMFSA8A:16;
L459: ( InsCode ( CurInstr (D43 , ( Comput (D43 , D42 , D50) )) ) ) = 6 by L458 , SCMFSA_2:23;
L460: ( InsCode ( CurInstr (D43 , ( Comput (D43 , D42 , D50) )) ) ) in { ( 0 ) , 6 , 7 , 8 } by L459 , ENUMSET1:def 2;
thus L461: ( DataPart ( Comput (D47 , D46 , C79) ) ) = ( DataPart ( Comput (D47 , D46 , D50) ) ) by L447 , L457 , EXTPRO_1:def 3
.= ( DataPart ( Comput (D43 , D42 , D50) ) ) by L436 , L448
.= ( DataPart ( Comput (D43 , D42 , C79) ) ) by L446 , L460 , L31;
end;
suppose L462: D51 <> ( halt ( SCM+FSA ) );

L463: ( CurInstr (D43 , ( Comput (D43 , D42 , D50) )) ) = D51 by L462 , L450 , L449 , L452 , L455 , SCMFSA8A:16;
thus L464: thesis by L463 , L447 , L446 , L456 , SCMFSA6C:4;
end;
end;
end;
end;
theorem
L468: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B99 being (State of ( SCM+FSA )) holds (for B100 being (Program of ( SCM+FSA )) holds (( Directed B100 ) is_pseudo-closed_on B99 , R2 implies ( DataPart ( Result (( R2 +* ( B100 ";" ( Stop ( SCM+FSA ) ) ) ) , ( Initialize B99 )) ) ) = ( DataPart ( Comput (( R2 +* B100 ) , ( Initialize B99 ) , ( pseudo-LifeSpan (B99 , R2 , ( Directed B100 )) )) ) )))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C81 being (State of ( SCM+FSA ));
set D54 = ( Data-Locations ( SCM+FSA ) );
let C82 being (Program of ( SCM+FSA ));
set D55 = ( Directed C82 );
set D56 = ( C82 ";" ( Stop ( SCM+FSA ) ) );
set D57 = ( Initialize C81 );
set D58 = ( R2 +* C82 );
set D59 = ( Initialize C81 );
set D60 = ( R2 +* D56 );
set D61 = ( pseudo-LifeSpan (C81 , R2 , D55) );
assume L469: D55 is_pseudo-closed_on C81 , R2;
L470: ( DataPart ( Comput (D58 , D57 , D61) ) ) = ( DataPart ( Comput (D60 , D59 , D61) ) ) by L469 , L319;
L471: D56 is_halting_on C81 , R2 by L469 , L319;
L472: D60 halts_on D59 by L471 , SCMFSA7B:def 7;
L473: ( LifeSpan (D60 , D59) ) = D61 by L469 , L319;
thus L474: thesis by L473 , L470 , L472 , EXTPRO_1:23;
end;
theorem
L475: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B101 being (State of ( SCM+FSA )) holds (for B102 being (Program of ( SCM+FSA )) holds ((( B101 . ( intloc ( 0 ) ) ) = 1 & ( Directed B102 ) is_pseudo-closed_on B101 , R2) implies ( DataPart ( IExec (( B102 ";" ( Stop ( SCM+FSA ) ) ) , R2 , B101) ) ) = ( DataPart ( Comput (( R2 +* B102 ) , ( Initialize B101 ) , ( pseudo-LifeSpan (B101 , R2 , ( Directed B102 )) )) ) )))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C83 being (State of ( SCM+FSA ));
set D62 = ( Data-Locations ( SCM+FSA ) );
let C84 being (Program of ( SCM+FSA ));
set D63 = ( Directed C84 );
set D64 = ( C84 ";" ( Stop ( SCM+FSA ) ) );
set D65 = ( Initialize C83 );
set D66 = ( R2 +* C84 );
set D67 = ( Initialize C83 );
set D68 = ( R2 +* D64 );
set D69 = ( pseudo-LifeSpan (C83 , R2 , D63) );
assume L476: ( C83 . ( intloc ( 0 ) ) ) = 1;
assume L477: D63 is_pseudo-closed_on C83 , R2;
L478: D67 = ( Initialized C83 ) by L476 , SCMFSA_M:18;
thus L479: ( DataPart ( IExec (D64 , R2 , C83) ) ) = ( DataPart ( Result (D68 , D67) ) ) by L478
.= ( DataPart ( Comput (D66 , D65 , D69) ) ) by L477 , L468;
end;
theorem
L480: (for B103 , B104 being (Program of ( SCM+FSA )) holds (for B105 being Int-Location holds ( ( if=0 (B105 , B103 , B104) ) . ( ( ( card B103 ) + ( card B104 ) ) + 3 ) ) = ( halt ( SCM+FSA ) )))
proof
let C85 , C86 being (Program of ( SCM+FSA ));
let C87 being Int-Location;
L481: ( if=0 (C87 , C85 , C86) ) = ( ( ( ( ( C87 =0_goto ( ( card C86 ) + 3 ) ) ";" C86 ) ";" ( Goto ( ( card C85 ) + 1 ) ) ) ";" C85 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1;
set D70 = ( ( ( ( C87 =0_goto ( ( card C86 ) + 3 ) ) ";" C86 ) ";" ( Goto ( ( card C85 ) + 1 ) ) ) ";" C85 );
L482: ( card D70 ) = ( ( card ( ( ( Macro ( C87 =0_goto ( ( card C86 ) + 3 ) ) ) ";" C86 ) ";" ( Goto ( ( card C85 ) + 1 ) ) ) ) + ( card C85 ) ) by SCMFSA6A:21
.= ( ( ( card ( ( Macro ( C87 =0_goto ( ( card C86 ) + 3 ) ) ) ";" C86 ) ) + ( card ( Goto ( ( card C85 ) + 1 ) ) ) ) + ( card C85 ) ) by SCMFSA6A:21
.= ( ( ( card ( ( Macro ( C87 =0_goto ( ( card C86 ) + 3 ) ) ) ";" C86 ) ) + 1 ) + ( card C85 ) ) by SCMFSA8A:15
.= ( ( ( ( card ( Macro ( C87 =0_goto ( ( card C86 ) + 3 ) ) ) ) + ( card C86 ) ) + 1 ) + ( card C85 ) ) by SCMFSA6A:21
.= ( ( ( 2 + ( card C86 ) ) + 1 ) + ( card C85 ) ) by COMPOS_1:56
.= ( ( ( card C85 ) + ( card C86 ) ) + 3 );
L483: ( ( ( ( card C85 ) + ( card C86 ) ) + 3 ) -' ( card D70 ) ) = ( 0 ) by L482 , XREAL_1:232;
L484: ( ( Stop ( SCM+FSA ) ) . ( 0 ) ) = ( halt ( SCM+FSA ) ) by AFINSQ_1:34;
L485: ( card ( Stop ( SCM+FSA ) ) ) = 1 by AFINSQ_1:33;
L486: ( ( ( card C85 ) + ( card C86 ) ) + 3 ) < ( ( card D70 ) + ( card ( Stop ( SCM+FSA ) ) ) ) by L485 , L482 , NAT_1:13;
thus L487: ( ( if=0 (C87 , C85 , C86) ) . ( ( ( card C85 ) + ( card C86 ) ) + 3 ) ) = ( IncAddr (( halt ( SCM+FSA ) ) , ( card D70 )) ) by L486 , L481 , L482 , L483 , L7 , L484
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
end;
theorem
L488: (for B106 , B107 being (Program of ( SCM+FSA )) holds (for B108 being Int-Location holds ( ( if>0 (B108 , B106 , B107) ) . ( ( ( card B106 ) + ( card B107 ) ) + 3 ) ) = ( halt ( SCM+FSA ) )))
proof
let C88 , C89 being (Program of ( SCM+FSA ));
let C90 being Int-Location;
L489: ( if>0 (C90 , C88 , C89) ) = ( ( ( ( ( C90 >0_goto ( ( card C89 ) + 3 ) ) ";" C89 ) ";" ( Goto ( ( card C88 ) + 1 ) ) ) ";" C88 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2;
set D71 = ( ( ( ( C90 >0_goto ( ( card C89 ) + 3 ) ) ";" C89 ) ";" ( Goto ( ( card C88 ) + 1 ) ) ) ";" C88 );
L490: ( card D71 ) = ( ( card ( ( ( Macro ( C90 >0_goto ( ( card C89 ) + 3 ) ) ) ";" C89 ) ";" ( Goto ( ( card C88 ) + 1 ) ) ) ) + ( card C88 ) ) by SCMFSA6A:21
.= ( ( ( card ( ( Macro ( C90 >0_goto ( ( card C89 ) + 3 ) ) ) ";" C89 ) ) + ( card ( Goto ( ( card C88 ) + 1 ) ) ) ) + ( card C88 ) ) by SCMFSA6A:21
.= ( ( ( card ( ( Macro ( C90 >0_goto ( ( card C89 ) + 3 ) ) ) ";" C89 ) ) + 1 ) + ( card C88 ) ) by SCMFSA8A:15
.= ( ( ( ( card ( Macro ( C90 >0_goto ( ( card C89 ) + 3 ) ) ) ) + ( card C89 ) ) + 1 ) + ( card C88 ) ) by SCMFSA6A:21
.= ( ( ( 2 + ( card C89 ) ) + 1 ) + ( card C88 ) ) by COMPOS_1:56
.= ( ( ( card C88 ) + ( card C89 ) ) + 3 );
L491: ( ( ( ( card C88 ) + ( card C89 ) ) + 3 ) -' ( card D71 ) ) = ( 0 ) by L490 , XREAL_1:232;
L492: ( ( Stop ( SCM+FSA ) ) . ( 0 ) ) = ( halt ( SCM+FSA ) ) by AFINSQ_1:34;
L493: ( card ( Stop ( SCM+FSA ) ) ) = 1 by AFINSQ_1:33;
L494: ( ( ( card C88 ) + ( card C89 ) ) + 3 ) < ( ( card D71 ) + ( card ( Stop ( SCM+FSA ) ) ) ) by L493 , L490 , NAT_1:13;
thus L495: ( ( if>0 (C90 , C88 , C89) ) . ( ( ( card C88 ) + ( card C89 ) ) + 3 ) ) = ( IncAddr (( halt ( SCM+FSA ) ) , ( card D71 )) ) by L494 , L489 , L490 , L491 , L7 , L492
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
end;
theorem
L496: (for B109 , B110 being (Program of ( SCM+FSA )) holds (for B111 being Int-Location holds ( ( if=0 (B111 , B109 , B110) ) . ( ( card B110 ) + 2 ) ) = ( goto ( ( ( card B109 ) + ( card B110 ) ) + 3 ) )))
proof
let C91 , C92 being (Program of ( SCM+FSA ));
let C93 being Int-Location;
set D72 = ( ( C93 =0_goto ( ( card C92 ) + 3 ) ) ";" C92 );
set D73 = ( ( ( C93 =0_goto ( ( card C92 ) + 3 ) ) ";" C92 ) ";" ( Goto ( ( card C91 ) + 1 ) ) );
L497: ( if=0 (C93 , C91 , C92) ) = ( ( ( ( ( C93 =0_goto ( ( card C92 ) + 3 ) ) ";" C92 ) ";" ( Goto ( ( card C91 ) + 1 ) ) ) ";" C91 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1;
L498: ( card D72 ) = ( ( card ( Macro ( C93 =0_goto ( ( card C92 ) + 3 ) ) ) ) + ( card C92 ) ) by SCMFSA6A:21
.= ( 2 + ( card C92 ) ) by COMPOS_1:56;
L499: ( ( ( card C92 ) + 2 ) -' ( card D72 ) ) = ( 0 ) by L498 , XREAL_1:232;
L500: ( goto ( ( card C91 ) + 1 ) ) = ( ( Goto ( ( card C91 ) + 1 ) ) . ( ( ( card C92 ) + 2 ) -' ( card D72 ) ) ) by L499 , SCMFSA8A:31;
L501: ( card ( Goto ( ( card C91 ) + 1 ) ) ) = 1 by SCMFSA8A:15;
L502: ( ( card C92 ) + 2 ) < ( ( card D72 ) + ( card ( Goto ( ( card C91 ) + 1 ) ) ) ) by L501 , L498 , NAT_1:13;
L503: ( D73 . ( ( card C92 ) + 2 ) ) = ( IncAddr (( goto ( ( card C91 ) + 1 ) ) , ( card D72 )) ) by L502 , L498 , L500 , L7
.= ( goto ( ( ( card C91 ) + 1 ) + ( ( card C92 ) + 2 ) ) ) by L498 , SCMFSA_4:1
.= ( goto ( ( ( card C91 ) + ( card C92 ) ) + ( 1 + 2 ) ) );
L504: ( card ( Goto ( ( card C91 ) + 1 ) ) ) = 1 by SCMFSA8A:15;
L505: ( card D73 ) = ( ( ( card C92 ) + 2 ) + 1 ) by L504 , L498 , SCMFSA6A:21
.= ( ( card C92 ) + ( 2 + 1 ) );
L506: ( card D73 ) = ( ( ( card C92 ) + 2 ) + 1 ) by L505;
L507: ( ( card C92 ) + 2 ) < ( card D73 ) by L506 , NAT_1:13;
L508: ( ( card C92 ) + 2 ) in ( dom D73 ) by L507 , AFINSQ_1:66;
L509: ( ( D73 ";" ( C91 ";" ( Stop ( SCM+FSA ) ) ) ) . ( ( card C92 ) + 2 ) ) = ( ( Directed D73 ) . ( ( card C92 ) + 2 ) ) by L508 , SCMFSA8A:14
.= ( goto ( ( ( card C91 ) + ( card C92 ) ) + 3 ) ) by L503 , L508 , SCMFSA8A:16;
thus L510: thesis by L509 , L497 , SCMFSA6A:25;
end;
theorem
L511: (for B112 , B113 being (Program of ( SCM+FSA )) holds (for B114 being Int-Location holds ( ( if>0 (B114 , B112 , B113) ) . ( ( card B113 ) + 2 ) ) = ( goto ( ( ( card B112 ) + ( card B113 ) ) + 3 ) )))
proof
let C94 , C95 being (Program of ( SCM+FSA ));
let C96 being Int-Location;
set D74 = ( ( C96 >0_goto ( ( card C95 ) + 3 ) ) ";" C95 );
set D75 = ( ( ( C96 >0_goto ( ( card C95 ) + 3 ) ) ";" C95 ) ";" ( Goto ( ( card C94 ) + 1 ) ) );
L512: ( if>0 (C96 , C94 , C95) ) = ( ( ( ( ( C96 >0_goto ( ( card C95 ) + 3 ) ) ";" C95 ) ";" ( Goto ( ( card C94 ) + 1 ) ) ) ";" C94 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2;
L513: ( card D74 ) = ( ( card ( Macro ( C96 >0_goto ( ( card C95 ) + 3 ) ) ) ) + ( card C95 ) ) by SCMFSA6A:21
.= ( 2 + ( card C95 ) ) by COMPOS_1:56;
L514: ( ( ( card C95 ) + 2 ) -' ( card D74 ) ) = ( 0 ) by L513 , XREAL_1:232;
L515: ( goto ( ( card C94 ) + 1 ) ) = ( ( Goto ( ( card C94 ) + 1 ) ) . ( ( ( card C95 ) + 2 ) -' ( card D74 ) ) ) by L514 , SCMFSA8A:31;
L516: ( card ( Goto ( ( card C94 ) + 1 ) ) ) = 1 by SCMFSA8A:15;
L517: ( ( card C95 ) + 2 ) < ( ( card D74 ) + ( card ( Goto ( ( card C94 ) + 1 ) ) ) ) by L516 , L513 , NAT_1:13;
L518: ( D75 . ( ( card C95 ) + 2 ) ) = ( IncAddr (( goto ( ( card C94 ) + 1 ) ) , ( card D74 )) ) by L517 , L513 , L515 , L7
.= ( goto ( ( ( card C94 ) + 1 ) + ( ( card C95 ) + 2 ) ) ) by L513 , SCMFSA_4:1
.= ( goto ( ( ( card C94 ) + ( card C95 ) ) + ( 1 + 2 ) ) );
L519: ( card ( Goto ( ( card C94 ) + 1 ) ) ) = 1 by SCMFSA8A:15;
L520: ( card D75 ) = ( ( ( card C95 ) + 2 ) + 1 ) by L519 , L513 , SCMFSA6A:21
.= ( ( card C95 ) + ( 2 + 1 ) );
L521: ( card D75 ) = ( ( ( card C95 ) + 2 ) + 1 ) by L520;
L522: ( ( card C95 ) + 2 ) < ( card D75 ) by L521 , NAT_1:13;
L523: ( ( card C95 ) + 2 ) in ( dom D75 ) by L522 , AFINSQ_1:66;
L524: ( ( D75 ";" ( C94 ";" ( Stop ( SCM+FSA ) ) ) ) . ( ( card C95 ) + 2 ) ) = ( ( Directed D75 ) . ( ( card C95 ) + 2 ) ) by L523 , SCMFSA8A:14
.= ( goto ( ( ( card C94 ) + ( card C95 ) ) + 3 ) ) by L518 , L523 , SCMFSA8A:16;
thus L525: thesis by L524 , L512 , SCMFSA6A:25;
end;
theorem
L526: (for B115 being (Program of ( SCM+FSA )) holds (for B116 being Int-Location holds ( ( if=0 (B116 , ( Goto 2 ) , B115) ) . ( ( card B115 ) + 3 ) ) = ( goto ( ( card B115 ) + 5 ) )))
proof
let C97 being (Program of ( SCM+FSA ));
let C98 being Int-Location;
set D76 = ( ( C98 =0_goto ( ( card C97 ) + 3 ) ) ";" C97 );
set D77 = ( ( ( C98 =0_goto ( ( card C97 ) + 3 ) ) ";" C97 ) ";" ( Goto 2 ) );
set D78 = ( ( ( ( C98 =0_goto ( ( card C97 ) + 3 ) ) ";" C97 ) ";" ( Goto 2 ) ) ";" ( Goto 2 ) );
L527: ( card ( Goto 2 ) ) = 1 by SCMFSA8A:15;
L528: ( card D76 ) = ( ( card ( Macro ( C98 =0_goto ( ( card C97 ) + 3 ) ) ) ) + ( card C97 ) ) by SCMFSA6A:21
.= ( 2 + ( card C97 ) ) by COMPOS_1:56;
L529: ( card D77 ) = ( ( ( card C97 ) + 2 ) + 1 ) by L528 , L527 , SCMFSA6A:21
.= ( ( card C97 ) + ( 2 + 1 ) );
L530: ( ( ( card C97 ) + 3 ) -' ( card D77 ) ) = ( 0 ) by L529 , XREAL_1:232;
L531: ( goto 2 ) = ( ( Goto 2 ) . ( ( ( card C97 ) + 3 ) -' ( card D77 ) ) ) by L530 , SCMFSA8A:31;
L532: ( card ( Goto 2 ) ) = 1 by SCMFSA8A:15;
L533: ( ( card C97 ) + 3 ) < ( ( card D77 ) + ( card ( Goto 2 ) ) ) by L532 , L529 , NAT_1:13;
L534: ( D78 . ( ( card C97 ) + 3 ) ) = ( IncAddr (( goto 2 ) , ( card D77 )) ) by L533 , L529 , L531 , L7
.= ( goto ( 2 + ( ( card C97 ) + 3 ) ) ) by L529 , SCMFSA_4:1
.= ( goto ( ( card C97 ) + ( 2 + 3 ) ) );
L535: ( card ( Goto 2 ) ) = 1 by SCMFSA8A:15;
L536: ( if=0 (C98 , ( Goto 2 ) , C97) ) = ( ( ( ( ( C98 =0_goto ( ( card C97 ) + 3 ) ) ";" C97 ) ";" ( Goto ( 1 + 1 ) ) ) ";" ( Goto 2 ) ) ";" ( Stop ( SCM+FSA ) ) ) by L535 , SCMFSA8B:def 1;
L537: ( card D78 ) = ( ( ( card C97 ) + 3 ) + 1 ) by L527 , L529 , SCMFSA6A:21
.= ( ( card C97 ) + ( 3 + 1 ) );
L538: ( card D78 ) = ( ( ( card C97 ) + 3 ) + 1 ) by L537;
L539: ( ( card C97 ) + 3 ) < ( card D78 ) by L538 , NAT_1:13;
L540: ( ( card C97 ) + 3 ) in ( dom D78 ) by L539 , AFINSQ_1:66;
L541: ( ( D78 ";" ( Stop ( SCM+FSA ) ) ) . ( ( card C97 ) + 3 ) ) = ( ( Directed D78 ) . ( ( card C97 ) + 3 ) ) by L540 , SCMFSA8A:14
.= ( goto ( ( card C97 ) + 5 ) ) by L534 , L540 , SCMFSA8A:16;
thus L542: thesis by L541 , L536;
end;
theorem
L543: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B117 being (State of ( SCM+FSA )) holds (for B118 , B119 being (Program of ( SCM+FSA )) holds (for B120 being  read-write Int-Location holds ((( B117 . B120 ) = ( 0 ) & ( Directed B118 ) is_pseudo-closed_on B117 , R2) implies (( if=0 (B120 , B118 , B119) ) is_halting_on B117 , R2 & ( if=0 (B120 , B118 , B119) ) is_closed_on B117 , R2 & ( LifeSpan (( R2 +* ( if=0 (B120 , B118 , B119) ) ) , ( Initialize B117 )) ) = ( ( LifeSpan (( R2 +* ( B118 ";" ( Stop ( SCM+FSA ) ) ) ) , ( Initialize B117 )) ) + 1 )))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C99 being (State of ( SCM+FSA ));
set D79 = ( Data-Locations ( SCM+FSA ) );
let C100 , C101 being (Program of ( SCM+FSA ));
let C102 being  read-write Int-Location;
set D80 = ( Directed C100 );
set D81 = ( C100 ";" ( Stop ( SCM+FSA ) ) );
set D82 = ( Initialize C99 );
set D83 = ( R2 +* D80 );
set D84 = ( Initialize C99 );
set D85 = ( R2 +* ( if=0 (C102 , C100 , C101) ) );
L544: ( if=0 (C102 , C100 , C101) ) c= D85 by FUNCT_4:25;
set D86 = ( Comput (D85 , D84 , 1) );
set D87 = ( C102 =0_goto ( ( card C101 ) + 3 ) );
L545: ( card ( if=0 (C102 , C100 , C101) ) ) = ( ( ( card C100 ) + ( card C101 ) ) + ( 3 + 1 ) ) by SCMFSA8B:11
.= ( ( ( ( card C100 ) + ( card C101 ) ) + 3 ) + 1 );
L546: ( ( ( card C100 ) + ( card C101 ) ) + 3 ) < ( card ( if=0 (C102 , C100 , C101) ) ) by L545 , NAT_1:13;
L547: ( ( ( card C100 ) + ( card C101 ) ) + 3 ) in ( dom ( if=0 (C102 , C100 , C101) ) ) by L546 , AFINSQ_1:66;
L548: ( if=0 (C102 , C100 , C101) ) c= D85 by FUNCT_4:25;
L549: ( 0 ) in ( dom ( if=0 (C102 , C100 , C101) ) ) by L269;
L550: ( D85 . ( 0 ) ) = ( ( if=0 (C102 , C100 , C101) ) . ( 0 ) ) by L549 , L544 , GRFUNC_1:2
.= D87 by L282;
L551: ( card ( ( D87 ";" C101 ) ";" ( Goto ( ( card C100 ) + 1 ) ) ) ) = ( ( card ( ( Macro D87 ) ";" C101 ) ) + ( card ( Goto ( ( card C100 ) + 1 ) ) ) ) by SCMFSA6A:21
.= ( ( card ( ( Macro D87 ) ";" C101 ) ) + 1 ) by SCMFSA8A:15
.= ( ( ( card ( Macro D87 ) ) + ( card C101 ) ) + 1 ) by SCMFSA6A:21
.= ( ( ( card C101 ) + 2 ) + 1 ) by COMPOS_1:56
.= ( ( card C101 ) + ( 2 + 1 ) );
L552: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L553: ( IC D84 ) = ( IC ( Initialize C99 ) )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L552 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L554: ( Comput (D85 , D84 , ( ( 0 ) + 1 )) ) = ( Following (D85 , ( Comput (D85 , D84 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D85 , D84) )
.= ( Exec (D87 , D84) ) by L553 , L550 , PBOOLE:143;
L555: ( if=0 (C102 , C100 , C101) ) = ( ( ( ( ( C102 =0_goto ( ( card C101 ) + 3 ) ) ";" C101 ) ";" ( Goto ( ( card C100 ) + 1 ) ) ) ";" C100 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1;
L556: ( if=0 (C102 , C100 , C101) ) = ( ( ( D87 ";" C101 ) ";" ( Goto ( ( card C100 ) + 1 ) ) ) ";" D81 ) by L555 , SCMFSA6A:25;
L557: ( Reloc (D81 , ( ( card C101 ) + 3 )) ) c= ( if=0 (C102 , C100 , C101) ) by L556 , L551 , FUNCT_4:25;
L558: ( Reloc (D81 , ( ( card C101 ) + 3 )) ) c= D85 by L557 , L548 , XBOOLE_1:1;
L559: ( Reloc (D80 , ( ( card C101 ) + 3 )) ) c= ( Reloc (D81 , ( ( card C101 ) + 3 )) ) by COMPOS_1:44 , SCMFSA6A:16;
L560: ( Reloc (D80 , ( ( card C101 ) + 3 )) ) c= D85 by L559 , L558 , XBOOLE_1:1;
L561: (for B121 being FinSeq-Location holds ( D82 . B121 ) = ( D86 . B121 )) by L554 , SCMFSA_2:70;
L562: (for B122 being Int-Location holds ( D82 . B122 ) = ( D86 . B122 )) by L554 , SCMFSA_2:70;
L563: ( DataPart D82 ) = ( DataPart D86 ) by L562 , L561 , SCMFSA_M:2;
L564: C102 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L565: ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L566: (not C102 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L565 , L564 , TARSKI:def 1;
L567: (not C102 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L566;
assume L568: ( C99 . C102 ) = ( 0 );
L569: ( D84 . C102 ) = ( 0 ) by L568 , L567 , FUNCT_4:11;
L570: ( IC ( Comput (D85 , D84 , 1) ) ) = ( ( card C101 ) + 3 ) by L569 , L554 , SCMFSA_2:70;
assume L571: D80 is_pseudo-closed_on C99 , R2;
L572: ( pseudo-LifeSpan (C99 , R2 , D80) ) = ( LifeSpan (( R2 +* D81 ) , ( Initialize C99 )) ) by L571 , L319;
L573: ( DataPart C99 ) = ( DataPart D82 ) by MEMSTR_0:79;
L574: D80 is_pseudo-closed_on D82 , D83 by L573 , L571 , L248;
L575: D80 c= D83 by FUNCT_4:25;
L576: ( IC ( Comput (D85 , D84 , ( ( pseudo-LifeSpan (D82 , D83 , D80) ) + 1 )) ) ) = ( IC ( Comput (D85 , D86 , ( pseudo-LifeSpan (D82 , D83 , D80) )) ) ) by EXTPRO_1:4
.= ( ( IC ( Comput (D83 , D82 , ( pseudo-LifeSpan (D82 , D83 , D80) )) ) ) + ( ( card C101 ) + 3 ) ) by L574 , L560 , L570 , L563 , L190 , L575
.= ( ( IC ( Comput (D83 , D82 , ( pseudo-LifeSpan (C99 , R2 , D80) )) ) ) + ( ( card C101 ) + 3 ) ) by L571 , L182
.= ( ( card D80 ) + ( ( card C101 ) + 3 ) ) by L571 , SCMFSA8A:def 4
.= ( ( card C100 ) + ( ( card C101 ) + 3 ) ) by SCMFSA8A:20
.= ( ( ( card C100 ) + ( card C101 ) ) + 3 );
L577: ( CurInstr (D85 , ( Comput (D85 , D84 , ( ( pseudo-LifeSpan (D82 , D83 , D80) ) + 1 )) )) ) = ( D85 . ( ( ( card C100 ) + ( card C101 ) ) + 3 ) ) by L576 , PBOOLE:143
.= ( ( if=0 (C102 , C100 , C101) ) . ( ( ( card C100 ) + ( card C101 ) ) + 3 ) ) by L547 , L544 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by L480;
L578: D85 halts_on D84 by L577 , EXTPRO_1:29;
thus L579: ( if=0 (C102 , C100 , C101) ) is_halting_on C99 , R2 by L578 , SCMFSA7B:def 7;
L580:
now
let C103 being (Element of ( NAT ));
per cases ;
suppose L581: C103 = ( 0 );

L582: ( Comput (D85 , D84 , C103) ) = D84 by L581 , EXTPRO_1:2;
L583: ( IC ( Comput (D85 , D84 , C103) ) ) = ( 0 ) by L582 , MEMSTR_0:16;
thus L584: ( IC ( Comput (D85 , D84 , C103) ) ) in ( dom ( if=0 (C102 , C100 , C101) ) ) by L583 , L269;
end;
suppose L585: (( 0 ) < C103 & C103 < ( ( pseudo-LifeSpan (D82 , D83 , D80) ) + 1 ));

L586: ( card ( if=0 (C102 , C100 , C101) ) ) = ( ( ( card C100 ) + ( card C101 ) ) + ( 3 + 1 ) ) by SCMFSA8B:11
.= ( ( ( ( card C100 ) + ( card C101 ) ) + 3 ) + 1 );
L587: ( ( ( card C100 ) + ( card C101 ) ) + 3 ) < ( card ( if=0 (C102 , C100 , C101) ) ) by L586 , XREAL_1:29;
L588: ( ( 0 ) + 1 ) <= C103 by L585 , INT_1:7;
consider C104 being Nat such that L589: ( 1 + C104 ) = C103 by L588 , NAT_1:10;
reconsider D88 = C104 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D89 = ( IC ( Comput (D83 , D82 , D88) ) ) as (Element of ( NAT ));
L590: D88 < ( pseudo-LifeSpan (D82 , D83 , D80) ) by L585 , L589 , XREAL_1:6;
L591: D88 < ( pseudo-LifeSpan (C99 , R2 , D80) ) by L590 , L571 , L182;
L592: D89 in ( dom D80 ) by L591 , L571 , SCMFSA8A:17;
L593: D89 < ( card D80 ) by L592 , AFINSQ_1:66;
L594: ( D89 + ( ( card C101 ) + 3 ) ) < ( ( card D80 ) + ( ( card C101 ) + 3 ) ) by L593 , XREAL_1:6;
L595: ( D89 + ( ( card C101 ) + 3 ) ) < ( ( card C100 ) + ( ( card C101 ) + 3 ) ) by L594 , SCMFSA8A:20;
L596: ( D89 + ( ( card C101 ) + 3 ) ) < ( card ( if=0 (C102 , C100 , C101) ) ) by L595 , L587 , XXREAL_0:2;
L597: ( IC ( Comput (D85 , D84 , C103) ) ) = ( IC ( Comput (D85 , D86 , D88) ) ) by L589 , EXTPRO_1:4
.= ( ( IC ( Comput (D83 , D82 , D88) ) ) + ( ( card C101 ) + 3 ) ) by L574 , L560 , L570 , L563 , L590 , L190 , L575;
thus L598: ( IC ( Comput (D85 , D84 , C103) ) ) in ( dom ( if=0 (C102 , C100 , C101) ) ) by L597 , L596 , AFINSQ_1:66;
end;
suppose L599: (( 0 ) < C103 & ( ( pseudo-LifeSpan (D82 , D83 , D80) ) + 1 ) <= C103);

thus L600: ( IC ( Comput (D85 , D84 , C103) ) ) in ( dom ( if=0 (C102 , C100 , C101) ) ) by L599 , L547 , L576 , L577 , EXTPRO_1:5;
end;
end;
thus L602: ( if=0 (C102 , C100 , C101) ) is_closed_on C99 , R2 by L580 , SCMFSA7B:def 6;
L603:
now
set D90 = ( ( ( ( C102 =0_goto ( ( card C101 ) + 3 ) ) ";" C101 ) ";" ( Goto ( ( card C100 ) + 1 ) ) ) ";" C100 );
let C105 being (Element of ( NAT ));
assume L604: ( CurInstr (D85 , ( Comput (D85 , D84 , C105) )) ) = ( halt ( SCM+FSA ) );
assume L605: (not ( ( pseudo-LifeSpan (D82 , D83 , D80) ) + 1 ) <= C105);
L606: C105 <= ( pseudo-LifeSpan (D82 , D83 , D80) ) by L605 , NAT_1:13;
L607: ( 0 ) in ( dom ( if=0 (C102 , C100 , C101) ) ) by L269;
L608: ( D85 /. ( IC D84 ) ) = ( D85 . ( IC D84 ) ) by PBOOLE:143;
L609: ( CurInstr (D85 , ( Comput (D85 , D84 , ( 0 )) )) ) = ( D85 . ( 0 ) ) by L608 , MEMSTR_0:16
.= ( ( if=0 (C102 , C100 , C101) ) . ( 0 ) ) by L607 , L544 , GRFUNC_1:2
.= ( C102 =0_goto ( ( card C101 ) + 3 ) ) by L282;
consider C106 being Nat such that L610: ( C106 + 1 ) = C105 by L609 , L604 , NAT_1:6;
reconsider D91 = C106 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D92 = ( IC ( Comput (D83 , D82 , D91) ) ) as (Element of ( NAT ));
L611: D91 < C105 by L610 , XREAL_1:29;
L612: D91 < ( pseudo-LifeSpan (D82 , D83 , D80) ) by L611 , L606 , XXREAL_0:2;
L613: D91 < ( pseudo-LifeSpan (C99 , R2 , D80) ) by L612 , L571 , L182;
L614: D92 in ( dom D80 ) by L613 , L571 , SCMFSA8A:17;
L615: D92 < ( card D80 ) by L614 , AFINSQ_1:66;
L616: ( D92 + ( ( card C101 ) + 3 ) ) < ( ( card D80 ) + ( ( card C101 ) + 3 ) ) by L615 , XREAL_1:6;
L617: ( D92 + ( ( card C101 ) + 3 ) ) < ( ( card C100 ) + ( ( card C101 ) + 3 ) ) by L616 , SCMFSA8A:20;
L618: ( IC ( Comput (D85 , D84 , C105) ) ) = ( IC ( Comput (D85 , D86 , D91) ) ) by L610 , EXTPRO_1:4
.= ( ( IC ( Comput (D83 , D82 , D91) ) ) + ( ( card C101 ) + 3 ) ) by L574 , L560 , L570 , L563 , L612 , L190 , L575;
L619: ( card D90 ) = ( ( card ( ( ( Macro ( C102 =0_goto ( ( card C101 ) + 3 ) ) ) ";" C101 ) ";" ( Goto ( ( card C100 ) + 1 ) ) ) ) + ( card C100 ) ) by SCMFSA6A:21
.= ( ( ( card ( ( Macro ( C102 =0_goto ( ( card C101 ) + 3 ) ) ) ";" C101 ) ) + ( card ( Goto ( ( card C100 ) + 1 ) ) ) ) + ( card C100 ) ) by SCMFSA6A:21
.= ( ( ( card ( ( Macro ( C102 =0_goto ( ( card C101 ) + 3 ) ) ) ";" C101 ) ) + 1 ) + ( card C100 ) ) by SCMFSA8A:15
.= ( ( ( ( card ( Macro ( C102 =0_goto ( ( card C101 ) + 3 ) ) ) ) + ( card C101 ) ) + 1 ) + ( card C100 ) ) by SCMFSA6A:21
.= ( ( ( 2 + ( card C101 ) ) + 1 ) + ( card C100 ) ) by COMPOS_1:56
.= ( ( ( card C100 ) + ( card C101 ) ) + 3 );
L620: ( IC ( Comput (D85 , D84 , C105) ) ) in ( dom D90 ) by L619 , L618 , L617 , AFINSQ_1:66;
L621: ( IC ( Comput (D85 , D84 , C105) ) ) in ( dom ( Directed D90 ) ) by L620 , FUNCT_4:99;
L622: ( ( Directed D90 ) . ( IC ( Comput (D85 , D84 , C105) ) ) ) in ( rng ( Directed D90 ) ) by L621 , FUNCT_1:def 3;
L623: ( card ( if=0 (C102 , C100 , C101) ) ) = ( ( ( card C100 ) + ( card C101 ) ) + ( 3 + 1 ) ) by SCMFSA8B:11
.= ( ( ( ( card C100 ) + ( card C101 ) ) + 3 ) + 1 );
L624: ( ( ( card C100 ) + ( card C101 ) ) + 3 ) < ( card ( if=0 (C102 , C100 , C101) ) ) by L623 , XREAL_1:29;
L625: ( D92 + ( ( card C101 ) + 3 ) ) < ( card ( if=0 (C102 , C100 , C101) ) ) by L624 , L617 , XXREAL_0:2;
L626: ( IC ( Comput (D85 , D84 , C105) ) ) in ( dom ( if=0 (C102 , C100 , C101) ) ) by L625 , L618 , AFINSQ_1:66;
L627: ( CurInstr (D85 , ( Comput (D85 , D84 , C105) )) ) = ( D85 . ( IC ( Comput (D85 , D84 , C105) ) ) ) by PBOOLE:143
.= ( ( if=0 (C102 , C100 , C101) ) . ( IC ( Comput (D85 , D84 , C105) ) ) ) by L626 , L544 , GRFUNC_1:2;
L628: ( Directed D90 ) c= ( if=0 (C102 , C100 , C101) ) by L555 , SCMFSA6A:16;
L629: ( ( if=0 (C102 , C100 , C101) ) . ( IC ( Comput (D85 , D84 , C105) ) ) ) = ( ( Directed D90 ) . ( IC ( Comput (D85 , D84 , C105) ) ) ) by L628 , L621 , GRFUNC_1:2;
thus L630: contradiction by L629 , L604 , L622 , L627 , COMPOS_1:def 11;
end;
L631: ( LifeSpan (D85 , D84) ) = ( ( pseudo-LifeSpan (D82 , D83 , D80) ) + 1 ) by L603 , L577 , L578 , EXTPRO_1:def 15;
thus L632: thesis by L631 , L571 , L572 , L182;
end;
theorem
L633: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B123 being (State of ( SCM+FSA )) holds (for B124 , B125 being (Program of ( SCM+FSA )) holds (for B126 being  read-write Int-Location holds ((( B123 . ( intloc ( 0 ) ) ) = 1 & ( B123 . B126 ) = ( 0 ) & ( Directed B124 ) is_pseudo-closed_on B123 , R2) implies ( DataPart ( IExec (( if=0 (B126 , B124 , B125) ) , R2 , B123) ) ) = ( DataPart ( IExec (( B124 ";" ( Stop ( SCM+FSA ) ) ) , R2 , B123) ) ))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C107 being (State of ( SCM+FSA ));
set D93 = ( Data-Locations ( SCM+FSA ) );
let C108 , C109 being (Program of ( SCM+FSA ));
let C110 being  read-write Int-Location;
set D94 = ( Directed C108 );
set D95 = ( Initialized C107 );
set D96 = ( C108 ";" ( Stop ( SCM+FSA ) ) );
set D97 = ( Initialize D95 );
set D98 = ( R2 +* D94 );
set D99 = ( Initialize D95 );
set D100 = ( R2 +* ( if=0 (C110 , C108 , C109) ) );
L634: ( if=0 (C110 , C108 , C109) ) c= D100 by FUNCT_4:25;
set D101 = ( Comput (D100 , D99 , 1) );
set D102 = ( C110 =0_goto ( ( card C109 ) + 3 ) );
L635: D94 c= D98 by FUNCT_4:25;
assume L636: ( C107 . ( intloc ( 0 ) ) ) = 1;
set D103 = ( Initialize D95 );
set D104 = ( R2 +* D96 );
assume L637: ( C107 . C110 ) = ( 0 );
L638: ( D95 . C110 ) = ( 0 ) by L637 , SCMFSA_M:37;
L639: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L640: ( IC D99 ) = ( IC ( Initialize D95 ) )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L639 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L641: ( 0 ) in ( dom ( if=0 (C110 , C108 , C109) ) ) by L269;
L642: ( D100 . ( 0 ) ) = ( ( if=0 (C110 , C108 , C109) ) . ( 0 ) ) by L641 , FUNCT_4:13
.= D102 by L282;
L643: ( Comput (D100 , D99 , ( ( 0 ) + 1 )) ) = ( Following (D100 , ( Comput (D100 , D99 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D100 , D99) )
.= ( Exec (D102 , D99) ) by L640 , L642 , PBOOLE:143;
L644: C110 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L645: ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L646: (not C110 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L645 , L644 , TARSKI:def 1;
L647: (not C110 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L646;
L648: ( D99 . C110 ) = ( 0 ) by L647 , L638 , FUNCT_4:11;
L649: ( IC ( Comput (D100 , D99 , 1) ) ) = ( ( card C109 ) + 3 ) by L648 , L643 , SCMFSA_2:70;
assume L650: D94 is_pseudo-closed_on C107 , R2;
L651: D94 is_pseudo-closed_on D95 , R2 by L650 , L636 , L265;
L652: ( LifeSpan (D104 , D103) ) = ( pseudo-LifeSpan (D95 , R2 , D94) ) by L651 , L319;
L653: ( DataPart D95 ) = ( DataPart D97 ) by MEMSTR_0:79;
L654: D94 is_pseudo-closed_on D97 , D98 by L653 , L651 , L248;
L655: (for B127 being FinSeq-Location holds ( D97 . B127 ) = ( D101 . B127 )) by L643 , SCMFSA_2:70;
L656: (for B128 being Int-Location holds ( D97 . B128 ) = ( D101 . B128 )) by L643 , SCMFSA_2:70;
L657: ( DataPart D97 ) = ( DataPart D101 ) by L656 , L655 , SCMFSA_M:2;
L658: ( card ( if=0 (C110 , C108 , C109) ) ) = ( ( ( card C108 ) + ( card C109 ) ) + ( 3 + 1 ) ) by SCMFSA8B:11
.= ( ( ( ( card C108 ) + ( card C109 ) ) + 3 ) + 1 );
L659: ( ( ( card C108 ) + ( card C109 ) ) + 3 ) < ( card ( if=0 (C110 , C108 , C109) ) ) by L658 , NAT_1:13;
L660: ( ( ( card C108 ) + ( card C109 ) ) + 3 ) in ( dom ( if=0 (C110 , C108 , C109) ) ) by L659 , AFINSQ_1:66;
L661: ( card ( ( D102 ";" C109 ) ";" ( Goto ( ( card C108 ) + 1 ) ) ) ) = ( ( card ( ( Macro D102 ) ";" C109 ) ) + ( card ( Goto ( ( card C108 ) + 1 ) ) ) ) by SCMFSA6A:21
.= ( ( card ( ( Macro D102 ) ";" C109 ) ) + 1 ) by SCMFSA8A:15
.= ( ( ( card ( Macro D102 ) ) + ( card C109 ) ) + 1 ) by SCMFSA6A:21
.= ( ( ( card C109 ) + 2 ) + 1 ) by COMPOS_1:56
.= ( ( card C109 ) + ( 2 + 1 ) );
L662: ( D95 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( Initialize ( Initialized D95 ) ) by MEMSTR_0:44;
L663: ( if=0 (C110 , C108 , C109) ) c= D100 by FUNCT_4:25;
L664: ( if=0 (C110 , C108 , C109) ) = ( ( ( ( ( C110 =0_goto ( ( card C109 ) + 3 ) ) ";" C109 ) ";" ( Goto ( ( card C108 ) + 1 ) ) ) ";" C108 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1;
L665: ( if=0 (C110 , C108 , C109) ) = ( ( ( D102 ";" C109 ) ";" ( Goto ( ( card C108 ) + 1 ) ) ) ";" D96 ) by L664 , SCMFSA6A:25;
L666: ( Reloc (D96 , ( ( card C109 ) + 3 )) ) c= ( if=0 (C110 , C108 , C109) ) by L665 , L661 , FUNCT_4:25;
L667: ( Reloc (D96 , ( ( card C109 ) + 3 )) ) c= D100 by L666 , L663 , XBOOLE_1:1;
L668: ( Reloc (D94 , ( ( card C109 ) + 3 )) ) c= ( Reloc (D96 , ( ( card C109 ) + 3 )) ) by COMPOS_1:44 , SCMFSA6A:16;
L669: ( Reloc (D94 , ( ( card C109 ) + 3 )) ) c= D100 by L668 , L667 , XBOOLE_1:1;
L670: ( IC ( Comput (D100 , D99 , ( ( pseudo-LifeSpan (D97 , D98 , D94) ) + 1 )) ) ) = ( IC ( Comput (D100 , D101 , ( pseudo-LifeSpan (D97 , D98 , D94) )) ) ) by EXTPRO_1:4
.= ( ( IC ( Comput (D98 , D97 , ( pseudo-LifeSpan (D97 , D98 , D94) )) ) ) + ( ( card C109 ) + 3 ) ) by L654 , L669 , L649 , L657 , L190 , L635
.= ( ( IC ( Comput (D98 , D97 , ( pseudo-LifeSpan (D95 , R2 , D94) )) ) ) + ( ( card C109 ) + 3 ) ) by L651 , L182
.= ( ( card D94 ) + ( ( card C109 ) + 3 ) ) by L651 , SCMFSA8A:def 4
.= ( ( card C108 ) + ( ( card C109 ) + 3 ) ) by SCMFSA8A:20
.= ( ( ( card C108 ) + ( card C109 ) ) + 3 );
L671: ( CurInstr (D100 , ( Comput (D100 , D99 , ( ( pseudo-LifeSpan (D97 , D98 , D94) ) + 1 )) )) ) = ( D100 . ( ( ( card C108 ) + ( card C109 ) ) + 3 ) ) by L670 , PBOOLE:143
.= ( ( if=0 (C110 , C108 , C109) ) . ( ( ( card C108 ) + ( card C109 ) ) + 3 ) ) by L660 , L634 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by L480;
L672: D100 halts_on D99 by L671 , EXTPRO_1:29;
L673:
now
set D105 = ( ( ( ( C110 =0_goto ( ( card C109 ) + 3 ) ) ";" C109 ) ";" ( Goto ( ( card C108 ) + 1 ) ) ) ";" C108 );
let C111 being (Element of ( NAT ));
assume L674: ( CurInstr (D100 , ( Comput (D100 , D99 , C111) )) ) = ( halt ( SCM+FSA ) );
assume L675: (not ( ( pseudo-LifeSpan (D97 , D98 , D94) ) + 1 ) <= C111);
L676: C111 <= ( pseudo-LifeSpan (D97 , D98 , D94) ) by L675 , NAT_1:13;
L677: ( 0 ) in ( dom ( if=0 (C110 , C108 , C109) ) ) by L269;
L678: ( D100 /. ( IC D99 ) ) = ( D100 . ( IC D99 ) ) by PBOOLE:143;
L679: ( CurInstr (D100 , ( Comput (D100 , D99 , ( 0 )) )) ) = ( D100 . ( 0 ) ) by L678 , MEMSTR_0:16
.= ( ( if=0 (C110 , C108 , C109) ) . ( 0 ) ) by L677 , L634 , GRFUNC_1:2
.= ( C110 =0_goto ( ( card C109 ) + 3 ) ) by L282;
consider C112 being Nat such that L680: ( C112 + 1 ) = C111 by L679 , L674 , NAT_1:6;
reconsider D106 = C112 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D107 = ( IC ( Comput (D98 , D97 , D106) ) ) as (Element of ( NAT ));
L681: D106 < C111 by L680 , XREAL_1:29;
L682: D106 < ( pseudo-LifeSpan (D97 , D98 , D94) ) by L681 , L676 , XXREAL_0:2;
L683: D106 < ( pseudo-LifeSpan (D95 , R2 , D94) ) by L682 , L651 , L182;
L684: D107 in ( dom D94 ) by L683 , L651 , SCMFSA8A:17;
L685: D107 < ( card D94 ) by L684 , AFINSQ_1:66;
L686: ( D107 + ( ( card C109 ) + 3 ) ) < ( ( card D94 ) + ( ( card C109 ) + 3 ) ) by L685 , XREAL_1:6;
L687: ( D107 + ( ( card C109 ) + 3 ) ) < ( ( card C108 ) + ( ( card C109 ) + 3 ) ) by L686 , SCMFSA8A:20;
L688: ( IC ( Comput (D100 , D99 , C111) ) ) = ( IC ( Comput (D100 , D101 , D106) ) ) by L680 , EXTPRO_1:4
.= ( ( IC ( Comput (D98 , D97 , D106) ) ) + ( ( card C109 ) + 3 ) ) by L654 , L669 , L649 , L657 , L682 , L190 , L635;
L689: ( card D105 ) = ( ( card ( ( ( Macro ( C110 =0_goto ( ( card C109 ) + 3 ) ) ) ";" C109 ) ";" ( Goto ( ( card C108 ) + 1 ) ) ) ) + ( card C108 ) ) by SCMFSA6A:21
.= ( ( ( card ( ( Macro ( C110 =0_goto ( ( card C109 ) + 3 ) ) ) ";" C109 ) ) + ( card ( Goto ( ( card C108 ) + 1 ) ) ) ) + ( card C108 ) ) by SCMFSA6A:21
.= ( ( ( card ( ( Macro ( C110 =0_goto ( ( card C109 ) + 3 ) ) ) ";" C109 ) ) + 1 ) + ( card C108 ) ) by SCMFSA8A:15
.= ( ( ( ( card ( Macro ( C110 =0_goto ( ( card C109 ) + 3 ) ) ) ) + ( card C109 ) ) + 1 ) + ( card C108 ) ) by SCMFSA6A:21
.= ( ( ( 2 + ( card C109 ) ) + 1 ) + ( card C108 ) ) by COMPOS_1:56
.= ( ( ( card C108 ) + ( card C109 ) ) + 3 );
L690: ( IC ( Comput (D100 , D99 , C111) ) ) in ( dom D105 ) by L689 , L688 , L687 , AFINSQ_1:66;
L691: ( IC ( Comput (D100 , D99 , C111) ) ) in ( dom ( Directed D105 ) ) by L690 , FUNCT_4:99;
L692: ( ( Directed D105 ) . ( IC ( Comput (D100 , D99 , C111) ) ) ) in ( rng ( Directed D105 ) ) by L691 , FUNCT_1:def 3;
L693: ( card ( if=0 (C110 , C108 , C109) ) ) = ( ( ( card C108 ) + ( card C109 ) ) + ( 3 + 1 ) ) by SCMFSA8B:11
.= ( ( ( ( card C108 ) + ( card C109 ) ) + 3 ) + 1 );
L694: ( ( ( card C108 ) + ( card C109 ) ) + 3 ) < ( card ( if=0 (C110 , C108 , C109) ) ) by L693 , XREAL_1:29;
L695: ( D107 + ( ( card C109 ) + 3 ) ) < ( card ( if=0 (C110 , C108 , C109) ) ) by L694 , L687 , XXREAL_0:2;
L696: ( IC ( Comput (D100 , D99 , C111) ) ) in ( dom ( if=0 (C110 , C108 , C109) ) ) by L695 , L688 , AFINSQ_1:66;
L697: ( CurInstr (D100 , ( Comput (D100 , D99 , C111) )) ) = ( D100 . ( IC ( Comput (D100 , D99 , C111) ) ) ) by PBOOLE:143
.= ( ( if=0 (C110 , C108 , C109) ) . ( IC ( Comput (D100 , D99 , C111) ) ) ) by L696 , L634 , GRFUNC_1:2;
L698: ( Directed D105 ) c= ( if=0 (C110 , C108 , C109) ) by L664 , SCMFSA6A:16;
L699: ( ( if=0 (C110 , C108 , C109) ) . ( IC ( Comput (D100 , D99 , C111) ) ) ) = ( ( Directed D105 ) . ( IC ( Comput (D100 , D99 , C111) ) ) ) by L698 , L691 , GRFUNC_1:2;
thus L700: contradiction by L699 , L674 , L692 , L697 , COMPOS_1:def 11;
end;
L701: ( LifeSpan (D100 , D99) ) = ( ( pseudo-LifeSpan (D97 , D98 , D94) ) + 1 ) by L673 , L671 , L672 , EXTPRO_1:def 15;
L702: ( D95 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( Initialize ( Initialized D95 ) ) by MEMSTR_0:44;
L703: ( D94 ";" ( Stop ( SCM+FSA ) ) ) = D96 by SCMFSA8A:25;
L704: ( Directed D94 ) = D94 by SCMFSA6A:22;
L705: ( DataPart ( Comput (D98 , D97 , ( pseudo-LifeSpan (D95 , R2 , D94) )) ) ) = ( DataPart ( Comput (D104 , D103 , ( pseudo-LifeSpan (D95 , R2 , D94) )) ) ) by L704 , L651 , L703 , L319;
L706: D96 is_halting_on D95 , R2 by L651 , L319;
L707: D104 halts_on D103 by L706 , SCMFSA7B:def 7;
thus L708: ( DataPart ( IExec (( if=0 (C110 , C108 , C109) ) , R2 , C107) ) ) = ( DataPart ( IExec (( if=0 (C110 , C108 , C109) ) , R2 , D95) ) )
.= ( DataPart ( Result (D100 , D99) ) ) by L662
.= ( DataPart ( Comput (D100 , D99 , ( LifeSpan (D100 , D99) )) ) ) by L672 , EXTPRO_1:23
.= ( DataPart ( Comput (D100 , D101 , ( pseudo-LifeSpan (D97 , D98 , D94) )) ) ) by L701 , EXTPRO_1:4
.= ( DataPart ( Comput (D98 , D97 , ( pseudo-LifeSpan (D97 , D98 , D94) )) ) ) by L654 , L669 , L649 , L657 , L190 , L635
.= ( DataPart ( Comput (D104 , D103 , ( LifeSpan (D104 , D103) )) ) ) by L651 , L652 , L705 , L182
.= ( DataPart ( Result (D104 , D103) ) ) by L707 , EXTPRO_1:23
.= ( DataPart ( IExec (D96 , R2 , D95) ) ) by L702
.= ( DataPart ( IExec (D96 , R2 , C107) ) );
end;
theorem
L709: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B129 being (State of ( SCM+FSA )) holds (for B130 , B131 being (Program of ( SCM+FSA )) holds (for B132 being  read-write Int-Location holds ((( B129 . B132 ) > ( 0 ) & ( Directed B130 ) is_pseudo-closed_on B129 , R2) implies (( if>0 (B132 , B130 , B131) ) is_halting_on B129 , R2 & ( if>0 (B132 , B130 , B131) ) is_closed_on B129 , R2 & ( LifeSpan (( R2 +* ( if>0 (B132 , B130 , B131) ) ) , ( Initialize B129 )) ) = ( ( LifeSpan (( R2 +* ( B130 ";" ( Stop ( SCM+FSA ) ) ) ) , ( Initialize B129 )) ) + 1 )))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C113 being (State of ( SCM+FSA ));
set D108 = ( Data-Locations ( SCM+FSA ) );
let C114 , C115 being (Program of ( SCM+FSA ));
let C116 being  read-write Int-Location;
set D109 = ( Directed C114 );
set D110 = ( C114 ";" ( Stop ( SCM+FSA ) ) );
set D111 = ( Initialize C113 );
set D112 = ( R2 +* D109 );
set D113 = ( Initialize C113 );
set D114 = ( R2 +* ( if>0 (C116 , C114 , C115) ) );
set D115 = ( Comput (D114 , D113 , 1) );
set D116 = ( C116 >0_goto ( ( card C115 ) + 3 ) );
L710: D109 c= D112 by FUNCT_4:25;
L711: ( if>0 (C116 , C114 , C115) ) c= D114 by FUNCT_4:25;
L712: ( card ( if>0 (C116 , C114 , C115) ) ) = ( ( ( card C114 ) + ( card C115 ) ) + ( 3 + 1 ) ) by SCMFSA8B:12
.= ( ( ( ( card C114 ) + ( card C115 ) ) + 3 ) + 1 );
L713: ( ( ( card C114 ) + ( card C115 ) ) + 3 ) < ( card ( if>0 (C116 , C114 , C115) ) ) by L712 , NAT_1:13;
L714: ( ( ( card C114 ) + ( card C115 ) ) + 3 ) in ( dom ( if>0 (C116 , C114 , C115) ) ) by L713 , AFINSQ_1:66;
L715: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L716: ( IC D113 ) = ( IC ( Initialize C113 ) )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L715 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L717: ( 0 ) in ( dom ( if>0 (C116 , C114 , C115) ) ) by L269;
L718: ( D114 . ( 0 ) ) = ( ( if>0 (C116 , C114 , C115) ) . ( 0 ) ) by L717 , FUNCT_4:13
.= D116 by L282;
L719: ( card ( ( D116 ";" C115 ) ";" ( Goto ( ( card C114 ) + 1 ) ) ) ) = ( ( card ( ( Macro D116 ) ";" C115 ) ) + ( card ( Goto ( ( card C114 ) + 1 ) ) ) ) by SCMFSA6A:21
.= ( ( card ( ( Macro D116 ) ";" C115 ) ) + 1 ) by SCMFSA8A:15
.= ( ( ( card ( Macro D116 ) ) + ( card C115 ) ) + 1 ) by SCMFSA6A:21
.= ( ( ( card C115 ) + 2 ) + 1 ) by COMPOS_1:56
.= ( ( card C115 ) + ( 2 + 1 ) );
L720: ( Comput (D114 , D113 , ( ( 0 ) + 1 )) ) = ( Following (D114 , ( Comput (D114 , D113 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D114 , D113) )
.= ( Exec (D116 , D113) ) by L716 , L718 , PBOOLE:143;
L721: ( if>0 (C116 , C114 , C115) ) c= D114 by FUNCT_4:25;
L722: ( if>0 (C116 , C114 , C115) ) = ( ( ( ( ( C116 >0_goto ( ( card C115 ) + 3 ) ) ";" C115 ) ";" ( Goto ( ( card C114 ) + 1 ) ) ) ";" C114 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2;
L723: ( if>0 (C116 , C114 , C115) ) = ( ( ( D116 ";" C115 ) ";" ( Goto ( ( card C114 ) + 1 ) ) ) ";" D110 ) by L722 , SCMFSA6A:25;
L724: ( Reloc (D110 , ( ( card C115 ) + 3 )) ) c= ( if>0 (C116 , C114 , C115) ) by L723 , L719 , FUNCT_4:25;
L725: ( Reloc (D110 , ( ( card C115 ) + 3 )) ) c= D114 by L724 , L721 , XBOOLE_1:1;
L726: ( Reloc (D109 , ( ( card C115 ) + 3 )) ) c= ( Reloc (D110 , ( ( card C115 ) + 3 )) ) by COMPOS_1:44 , SCMFSA6A:16;
L727: ( Reloc (D109 , ( ( card C115 ) + 3 )) ) c= D114 by L726 , L725 , XBOOLE_1:1;
L728: (for B133 being FinSeq-Location holds ( D111 . B133 ) = ( D115 . B133 )) by L720 , SCMFSA_2:71;
L729: (for B134 being Int-Location holds ( D111 . B134 ) = ( D115 . B134 )) by L720 , SCMFSA_2:71;
L730: ( DataPart D111 ) = ( DataPart D115 ) by L729 , L728 , SCMFSA_M:2;
L731: C116 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L732: ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L733: (not C116 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L732 , L731 , TARSKI:def 1;
L734: (not C116 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L733;
L735: ( D113 . C116 ) = ( C113 . C116 ) by L734 , FUNCT_4:11;
assume L736: ( C113 . C116 ) > ( 0 );
L737: ( IC ( Comput (D114 , D113 , 1) ) ) = ( ( card C115 ) + 3 ) by L736 , L720 , L735 , SCMFSA_2:71;
assume L738: D109 is_pseudo-closed_on C113 , R2;
L739: ( pseudo-LifeSpan (C113 , R2 , D109) ) = ( LifeSpan (( R2 +* D110 ) , ( Initialize C113 )) ) by L738 , L319;
L740: ( DataPart C113 ) = ( DataPart D111 ) by MEMSTR_0:79;
L741: D109 is_pseudo-closed_on D111 , D112 by L740 , L738 , L248;
L742: ( IC ( Comput (D114 , D113 , ( ( pseudo-LifeSpan (D111 , D112 , D109) ) + 1 )) ) ) = ( IC ( Comput (D114 , D115 , ( pseudo-LifeSpan (D111 , D112 , D109) )) ) ) by EXTPRO_1:4
.= ( ( IC ( Comput (D112 , D111 , ( pseudo-LifeSpan (D111 , D112 , D109) )) ) ) + ( ( card C115 ) + 3 ) ) by L741 , L727 , L737 , L730 , L190 , L710
.= ( ( IC ( Comput (D112 , D111 , ( pseudo-LifeSpan (C113 , R2 , D109) )) ) ) + ( ( card C115 ) + 3 ) ) by L738 , L182
.= ( ( card D109 ) + ( ( card C115 ) + 3 ) ) by L738 , SCMFSA8A:def 4
.= ( ( card C114 ) + ( ( card C115 ) + 3 ) ) by SCMFSA8A:20
.= ( ( ( card C114 ) + ( card C115 ) ) + 3 );
L743: ( CurInstr (D114 , ( Comput (D114 , D113 , ( ( pseudo-LifeSpan (D111 , D112 , D109) ) + 1 )) )) ) = ( D114 . ( ( ( card C114 ) + ( card C115 ) ) + 3 ) ) by L742 , PBOOLE:143
.= ( ( if>0 (C116 , C114 , C115) ) . ( ( ( card C114 ) + ( card C115 ) ) + 3 ) ) by L714 , L711 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by L488;
L744: D114 halts_on D113 by L743 , EXTPRO_1:29;
thus L745: ( if>0 (C116 , C114 , C115) ) is_halting_on C113 , R2 by L744 , SCMFSA7B:def 7;
L746:
now
let C117 being (Element of ( NAT ));
per cases ;
suppose L747: C117 = ( 0 );

L748: ( Comput (D114 , D113 , C117) ) = D113 by L747 , EXTPRO_1:2;
L749: ( IC ( Comput (D114 , D113 , C117) ) ) = ( 0 ) by L748 , MEMSTR_0:16;
thus L750: ( IC ( Comput (D114 , D113 , C117) ) ) in ( dom ( if>0 (C116 , C114 , C115) ) ) by L749 , L269;
end;
suppose L751: (( 0 ) < C117 & C117 < ( ( pseudo-LifeSpan (D111 , D112 , D109) ) + 1 ));

L752: ( card ( if>0 (C116 , C114 , C115) ) ) = ( ( ( card C114 ) + ( card C115 ) ) + ( 3 + 1 ) ) by SCMFSA8B:12
.= ( ( ( ( card C114 ) + ( card C115 ) ) + 3 ) + 1 );
L753: ( ( ( card C114 ) + ( card C115 ) ) + 3 ) < ( card ( if>0 (C116 , C114 , C115) ) ) by L752 , XREAL_1:29;
L754: ( ( 0 ) + 1 ) <= C117 by L751 , INT_1:7;
consider C118 being Nat such that L755: ( 1 + C118 ) = C117 by L754 , NAT_1:10;
reconsider D117 = C118 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D118 = ( IC ( Comput (D112 , D111 , D117) ) ) as (Element of ( NAT ));
L756: D117 < ( pseudo-LifeSpan (D111 , D112 , D109) ) by L751 , L755 , XREAL_1:6;
L757: D117 < ( pseudo-LifeSpan (C113 , R2 , D109) ) by L756 , L738 , L182;
L758: D118 in ( dom D109 ) by L757 , L738 , SCMFSA8A:17;
L759: D118 < ( card D109 ) by L758 , AFINSQ_1:66;
L760: ( D118 + ( ( card C115 ) + 3 ) ) < ( ( card D109 ) + ( ( card C115 ) + 3 ) ) by L759 , XREAL_1:6;
L761: ( D118 + ( ( card C115 ) + 3 ) ) < ( ( card C114 ) + ( ( card C115 ) + 3 ) ) by L760 , SCMFSA8A:20;
L762: ( D118 + ( ( card C115 ) + 3 ) ) < ( card ( if>0 (C116 , C114 , C115) ) ) by L761 , L753 , XXREAL_0:2;
L763: ( IC ( Comput (D114 , D113 , C117) ) ) = ( IC ( Comput (D114 , D115 , D117) ) ) by L755 , EXTPRO_1:4
.= ( ( IC ( Comput (D112 , D111 , D117) ) ) + ( ( card C115 ) + 3 ) ) by L741 , L727 , L737 , L730 , L756 , L190 , L710;
thus L764: ( IC ( Comput (D114 , D113 , C117) ) ) in ( dom ( if>0 (C116 , C114 , C115) ) ) by L763 , L762 , AFINSQ_1:66;
end;
suppose L765: (( 0 ) < C117 & ( ( pseudo-LifeSpan (D111 , D112 , D109) ) + 1 ) <= C117);

thus L766: ( IC ( Comput (D114 , D113 , C117) ) ) in ( dom ( if>0 (C116 , C114 , C115) ) ) by L765 , L714 , L742 , L743 , EXTPRO_1:5;
end;
end;
thus L768: ( if>0 (C116 , C114 , C115) ) is_closed_on C113 , R2 by L746 , SCMFSA7B:def 6;
L769:
now
set D119 = ( ( ( ( C116 >0_goto ( ( card C115 ) + 3 ) ) ";" C115 ) ";" ( Goto ( ( card C114 ) + 1 ) ) ) ";" C114 );
let C119 being (Element of ( NAT ));
assume L770: ( CurInstr (D114 , ( Comput (D114 , D113 , C119) )) ) = ( halt ( SCM+FSA ) );
assume L771: (not ( ( pseudo-LifeSpan (D111 , D112 , D109) ) + 1 ) <= C119);
L772: C119 <= ( pseudo-LifeSpan (D111 , D112 , D109) ) by L771 , NAT_1:13;
L773: ( 0 ) in ( dom ( if>0 (C116 , C114 , C115) ) ) by L269;
L774: ( D114 /. ( IC D113 ) ) = ( D114 . ( IC D113 ) ) by PBOOLE:143;
L775: ( CurInstr (D114 , ( Comput (D114 , D113 , ( 0 )) )) ) = ( D114 . ( 0 ) ) by L774 , MEMSTR_0:16
.= ( ( if>0 (C116 , C114 , C115) ) . ( 0 ) ) by L773 , L711 , GRFUNC_1:2
.= ( C116 >0_goto ( ( card C115 ) + 3 ) ) by L282;
consider C120 being Nat such that L776: ( C120 + 1 ) = C119 by L775 , L770 , NAT_1:6;
reconsider D120 = C120 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D121 = ( IC ( Comput (D112 , D111 , D120) ) ) as (Element of ( NAT ));
L777: D120 < C119 by L776 , XREAL_1:29;
L778: D120 < ( pseudo-LifeSpan (D111 , D112 , D109) ) by L777 , L772 , XXREAL_0:2;
L779: D120 < ( pseudo-LifeSpan (C113 , R2 , D109) ) by L778 , L738 , L182;
L780: D121 in ( dom D109 ) by L779 , L738 , SCMFSA8A:17;
L781: D121 < ( card D109 ) by L780 , AFINSQ_1:66;
L782: ( D121 + ( ( card C115 ) + 3 ) ) < ( ( card D109 ) + ( ( card C115 ) + 3 ) ) by L781 , XREAL_1:6;
L783: ( D121 + ( ( card C115 ) + 3 ) ) < ( ( card C114 ) + ( ( card C115 ) + 3 ) ) by L782 , SCMFSA8A:20;
L784: ( IC ( Comput (D114 , D113 , C119) ) ) = ( IC ( Comput (D114 , D115 , D120) ) ) by L776 , EXTPRO_1:4
.= ( ( IC ( Comput (D112 , D111 , D120) ) ) + ( ( card C115 ) + 3 ) ) by L741 , L727 , L737 , L730 , L778 , L190 , L710;
L785: ( card D119 ) = ( ( card ( ( ( Macro ( C116 >0_goto ( ( card C115 ) + 3 ) ) ) ";" C115 ) ";" ( Goto ( ( card C114 ) + 1 ) ) ) ) + ( card C114 ) ) by SCMFSA6A:21
.= ( ( ( card ( ( Macro ( C116 >0_goto ( ( card C115 ) + 3 ) ) ) ";" C115 ) ) + ( card ( Goto ( ( card C114 ) + 1 ) ) ) ) + ( card C114 ) ) by SCMFSA6A:21
.= ( ( ( card ( ( Macro ( C116 >0_goto ( ( card C115 ) + 3 ) ) ) ";" C115 ) ) + 1 ) + ( card C114 ) ) by SCMFSA8A:15
.= ( ( ( ( card ( Macro ( C116 >0_goto ( ( card C115 ) + 3 ) ) ) ) + ( card C115 ) ) + 1 ) + ( card C114 ) ) by SCMFSA6A:21
.= ( ( ( 2 + ( card C115 ) ) + 1 ) + ( card C114 ) ) by COMPOS_1:56
.= ( ( ( card C114 ) + ( card C115 ) ) + 3 );
L786: ( IC ( Comput (D114 , D113 , C119) ) ) in ( dom D119 ) by L785 , L784 , L783 , AFINSQ_1:66;
L787: ( IC ( Comput (D114 , D113 , C119) ) ) in ( dom ( Directed D119 ) ) by L786 , FUNCT_4:99;
L788: ( ( Directed D119 ) . ( IC ( Comput (D114 , D113 , C119) ) ) ) in ( rng ( Directed D119 ) ) by L787 , FUNCT_1:def 3;
L789: ( card ( if>0 (C116 , C114 , C115) ) ) = ( ( ( card C114 ) + ( card C115 ) ) + ( 3 + 1 ) ) by SCMFSA8B:12
.= ( ( ( ( card C114 ) + ( card C115 ) ) + 3 ) + 1 );
L790: ( ( ( card C114 ) + ( card C115 ) ) + 3 ) < ( card ( if>0 (C116 , C114 , C115) ) ) by L789 , XREAL_1:29;
L791: ( D121 + ( ( card C115 ) + 3 ) ) < ( card ( if>0 (C116 , C114 , C115) ) ) by L790 , L783 , XXREAL_0:2;
L792: ( IC ( Comput (D114 , D113 , C119) ) ) in ( dom ( if>0 (C116 , C114 , C115) ) ) by L791 , L784 , AFINSQ_1:66;
L793: ( CurInstr (D114 , ( Comput (D114 , D113 , C119) )) ) = ( D114 . ( IC ( Comput (D114 , D113 , C119) ) ) ) by PBOOLE:143
.= ( ( if>0 (C116 , C114 , C115) ) . ( IC ( Comput (D114 , D113 , C119) ) ) ) by L792 , L711 , GRFUNC_1:2;
L794: ( Directed D119 ) c= ( if>0 (C116 , C114 , C115) ) by L722 , SCMFSA6A:16;
L795: ( ( if>0 (C116 , C114 , C115) ) . ( IC ( Comput (D114 , D113 , C119) ) ) ) = ( ( Directed D119 ) . ( IC ( Comput (D114 , D113 , C119) ) ) ) by L794 , L787 , GRFUNC_1:2;
thus L796: contradiction by L795 , L770 , L788 , L793 , COMPOS_1:def 11;
end;
L797: ( LifeSpan (D114 , D113) ) = ( ( pseudo-LifeSpan (D111 , D112 , D109) ) + 1 ) by L769 , L743 , L744 , EXTPRO_1:def 15;
thus L798: thesis by L797 , L738 , L739 , L182;
end;
theorem
L799: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B135 being (State of ( SCM+FSA )) holds (for B136 , B137 being (Program of ( SCM+FSA )) holds (for B138 being  read-write Int-Location holds ((( B135 . ( intloc ( 0 ) ) ) = 1 & ( B135 . B138 ) > ( 0 ) & ( Directed B136 ) is_pseudo-closed_on B135 , R2) implies ( DataPart ( IExec (( if>0 (B138 , B136 , B137) ) , R2 , B135) ) ) = ( DataPart ( IExec (( B136 ";" ( Stop ( SCM+FSA ) ) ) , R2 , B135) ) ))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C121 being (State of ( SCM+FSA ));
set D122 = ( Data-Locations ( SCM+FSA ) );
let C122 , C123 being (Program of ( SCM+FSA ));
let C124 being  read-write Int-Location;
set D123 = ( Directed C122 );
set D124 = ( Initialized C121 );
set D125 = ( C122 ";" ( Stop ( SCM+FSA ) ) );
set D126 = ( Initialize D124 );
set D127 = ( R2 +* D123 );
set D128 = ( Initialize D124 );
set D129 = ( R2 +* ( if>0 (C124 , C122 , C123) ) );
set D130 = ( Comput (D129 , D128 , 1) );
set D131 = ( C124 >0_goto ( ( card C123 ) + 3 ) );
L800: D123 c= D127 by FUNCT_4:25;
L801: ( if>0 (C124 , C122 , C123) ) c= D129 by FUNCT_4:25;
assume L802: ( C121 . ( intloc ( 0 ) ) ) = 1;
set D132 = ( Initialize D124 );
set D133 = ( R2 +* D125 );
assume L803: ( C121 . C124 ) > ( 0 );
L804: ( D124 . C124 ) > ( 0 ) by L803 , SCMFSA_M:37;
L805: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L806: ( IC D128 ) = ( IC ( Initialize D124 ) )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L805 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L807: ( 0 ) in ( dom ( if>0 (C124 , C122 , C123) ) ) by L269;
L808: ( D129 . ( 0 ) ) = ( ( if>0 (C124 , C122 , C123) ) . ( 0 ) ) by L807 , FUNCT_4:13
.= D131 by L282;
L809: ( Comput (D129 , D128 , ( ( 0 ) + 1 )) ) = ( Following (D129 , ( Comput (D129 , D128 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D129 , D128) )
.= ( Exec (D131 , D128) ) by L806 , L808 , PBOOLE:143;
L810: C124 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L811: ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L812: (not C124 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L811 , L810 , TARSKI:def 1;
L813: (not C124 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L812;
L814: ( D128 . C124 ) = ( D124 . C124 ) by L813 , FUNCT_4:11;
L815: ( IC ( Comput (D129 , D128 , 1) ) ) = ( ( card C123 ) + 3 ) by L814 , L804 , L809 , SCMFSA_2:71;
assume L816: D123 is_pseudo-closed_on C121 , R2;
L817: D123 is_pseudo-closed_on D124 , R2 by L816 , L802 , L265;
L818: ( LifeSpan (D133 , D132) ) = ( pseudo-LifeSpan (D124 , R2 , D123) ) by L817 , L319;
L819: ( DataPart D124 ) = ( DataPart D126 ) by MEMSTR_0:79;
L820: D123 is_pseudo-closed_on D126 , D127 by L819 , L817 , L248;
L821: (for B139 being FinSeq-Location holds ( D126 . B139 ) = ( D130 . B139 )) by L809 , SCMFSA_2:71;
L822: (for B140 being Int-Location holds ( D126 . B140 ) = ( D130 . B140 )) by L809 , SCMFSA_2:71;
L823: ( DataPart D126 ) = ( DataPart D130 ) by L822 , L821 , SCMFSA_M:2;
L824: ( card ( if>0 (C124 , C122 , C123) ) ) = ( ( ( card C122 ) + ( card C123 ) ) + ( 3 + 1 ) ) by SCMFSA8B:12
.= ( ( ( ( card C122 ) + ( card C123 ) ) + 3 ) + 1 );
L825: ( ( ( card C122 ) + ( card C123 ) ) + 3 ) < ( card ( if>0 (C124 , C122 , C123) ) ) by L824 , NAT_1:13;
L826: ( ( ( card C122 ) + ( card C123 ) ) + 3 ) in ( dom ( if>0 (C124 , C122 , C123) ) ) by L825 , AFINSQ_1:66;
L827: ( card ( ( D131 ";" C123 ) ";" ( Goto ( ( card C122 ) + 1 ) ) ) ) = ( ( card ( ( Macro D131 ) ";" C123 ) ) + ( card ( Goto ( ( card C122 ) + 1 ) ) ) ) by SCMFSA6A:21
.= ( ( card ( ( Macro D131 ) ";" C123 ) ) + 1 ) by SCMFSA8A:15
.= ( ( ( card ( Macro D131 ) ) + ( card C123 ) ) + 1 ) by SCMFSA6A:21
.= ( ( ( card C123 ) + 2 ) + 1 ) by COMPOS_1:56
.= ( ( card C123 ) + ( 2 + 1 ) );
L828: ( D124 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( Initialize ( Initialized D124 ) ) by MEMSTR_0:44;
L829: ( D124 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = D128 by L828;
L830: ( if>0 (C124 , C122 , C123) ) c= D129 by FUNCT_4:25;
L831: ( if>0 (C124 , C122 , C123) ) = ( ( ( ( ( C124 >0_goto ( ( card C123 ) + 3 ) ) ";" C123 ) ";" ( Goto ( ( card C122 ) + 1 ) ) ) ";" C122 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2;
L832: ( if>0 (C124 , C122 , C123) ) = ( ( ( D131 ";" C123 ) ";" ( Goto ( ( card C122 ) + 1 ) ) ) ";" D125 ) by L831 , SCMFSA6A:25;
L833: ( Reloc (D125 , ( ( card C123 ) + 3 )) ) c= ( if>0 (C124 , C122 , C123) ) by L832 , L827 , FUNCT_4:25;
L834: ( Reloc (D125 , ( ( card C123 ) + 3 )) ) c= D129 by L833 , L830 , XBOOLE_1:1;
L835: ( Reloc (D123 , ( ( card C123 ) + 3 )) ) c= ( Reloc (D125 , ( ( card C123 ) + 3 )) ) by COMPOS_1:44 , SCMFSA6A:16;
L836: ( Reloc (D123 , ( ( card C123 ) + 3 )) ) c= D129 by L835 , L834 , XBOOLE_1:1;
L837: ( IC ( Comput (D129 , D128 , ( ( pseudo-LifeSpan (D126 , D127 , D123) ) + 1 )) ) ) = ( IC ( Comput (D129 , D130 , ( pseudo-LifeSpan (D126 , D127 , D123) )) ) ) by EXTPRO_1:4
.= ( ( IC ( Comput (D127 , D126 , ( pseudo-LifeSpan (D126 , D127 , D123) )) ) ) + ( ( card C123 ) + 3 ) ) by L820 , L836 , L815 , L823 , L190 , L800
.= ( ( IC ( Comput (D127 , D126 , ( pseudo-LifeSpan (D124 , R2 , D123) )) ) ) + ( ( card C123 ) + 3 ) ) by L817 , L182
.= ( ( card D123 ) + ( ( card C123 ) + 3 ) ) by L817 , SCMFSA8A:def 4
.= ( ( card C122 ) + ( ( card C123 ) + 3 ) ) by SCMFSA8A:20
.= ( ( ( card C122 ) + ( card C123 ) ) + 3 );
L838: ( CurInstr (D129 , ( Comput (D129 , D128 , ( ( pseudo-LifeSpan (D126 , D127 , D123) ) + 1 )) )) ) = ( D129 . ( ( ( card C122 ) + ( card C123 ) ) + 3 ) ) by L837 , PBOOLE:143
.= ( ( if>0 (C124 , C122 , C123) ) . ( ( ( card C122 ) + ( card C123 ) ) + 3 ) ) by L826 , L801 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by L488;
L839: D129 halts_on D128 by L838 , EXTPRO_1:29;
L840:
now
set D134 = ( ( ( ( C124 >0_goto ( ( card C123 ) + 3 ) ) ";" C123 ) ";" ( Goto ( ( card C122 ) + 1 ) ) ) ";" C122 );
let C125 being (Element of ( NAT ));
assume L841: ( CurInstr (D129 , ( Comput (D129 , D128 , C125) )) ) = ( halt ( SCM+FSA ) );
assume L842: (not ( ( pseudo-LifeSpan (D126 , D127 , D123) ) + 1 ) <= C125);
L843: C125 <= ( pseudo-LifeSpan (D126 , D127 , D123) ) by L842 , NAT_1:13;
L844: ( 0 ) in ( dom ( if>0 (C124 , C122 , C123) ) ) by L269;
L845: ( D129 /. ( IC D128 ) ) = ( D129 . ( IC D128 ) ) by PBOOLE:143;
L846: ( CurInstr (D129 , ( Comput (D129 , D128 , ( 0 )) )) ) = ( D129 . ( 0 ) ) by L845 , MEMSTR_0:16
.= ( ( if>0 (C124 , C122 , C123) ) . ( 0 ) ) by L844 , L801 , GRFUNC_1:2
.= ( C124 >0_goto ( ( card C123 ) + 3 ) ) by L282;
consider C126 being Nat such that L847: ( C126 + 1 ) = C125 by L846 , L841 , NAT_1:6;
reconsider D135 = C126 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D136 = ( IC ( Comput (D127 , D126 , D135) ) ) as (Element of ( NAT ));
L848: D135 < C125 by L847 , XREAL_1:29;
L849: D135 < ( pseudo-LifeSpan (D126 , D127 , D123) ) by L848 , L843 , XXREAL_0:2;
L850: D135 < ( pseudo-LifeSpan (D124 , R2 , D123) ) by L849 , L817 , L182;
L851: D136 in ( dom D123 ) by L850 , L817 , SCMFSA8A:17;
L852: D136 < ( card D123 ) by L851 , AFINSQ_1:66;
L853: ( D136 + ( ( card C123 ) + 3 ) ) < ( ( card D123 ) + ( ( card C123 ) + 3 ) ) by L852 , XREAL_1:6;
L854: ( D136 + ( ( card C123 ) + 3 ) ) < ( ( card C122 ) + ( ( card C123 ) + 3 ) ) by L853 , SCMFSA8A:20;
L855: ( IC ( Comput (D129 , D128 , C125) ) ) = ( IC ( Comput (D129 , D130 , D135) ) ) by L847 , EXTPRO_1:4
.= ( ( IC ( Comput (D127 , D126 , D135) ) ) + ( ( card C123 ) + 3 ) ) by L820 , L836 , L815 , L823 , L849 , L190 , L800;
L856: ( card D134 ) = ( ( card ( ( ( Macro ( C124 >0_goto ( ( card C123 ) + 3 ) ) ) ";" C123 ) ";" ( Goto ( ( card C122 ) + 1 ) ) ) ) + ( card C122 ) ) by SCMFSA6A:21
.= ( ( ( card ( ( Macro ( C124 >0_goto ( ( card C123 ) + 3 ) ) ) ";" C123 ) ) + ( card ( Goto ( ( card C122 ) + 1 ) ) ) ) + ( card C122 ) ) by SCMFSA6A:21
.= ( ( ( card ( ( Macro ( C124 >0_goto ( ( card C123 ) + 3 ) ) ) ";" C123 ) ) + 1 ) + ( card C122 ) ) by SCMFSA8A:15
.= ( ( ( ( card ( Macro ( C124 >0_goto ( ( card C123 ) + 3 ) ) ) ) + ( card C123 ) ) + 1 ) + ( card C122 ) ) by SCMFSA6A:21
.= ( ( ( 2 + ( card C123 ) ) + 1 ) + ( card C122 ) ) by COMPOS_1:56
.= ( ( ( card C122 ) + ( card C123 ) ) + 3 );
L857: ( IC ( Comput (D129 , D128 , C125) ) ) in ( dom D134 ) by L856 , L855 , L854 , AFINSQ_1:66;
L858: ( IC ( Comput (D129 , D128 , C125) ) ) in ( dom ( Directed D134 ) ) by L857 , FUNCT_4:99;
L859: ( ( Directed D134 ) . ( IC ( Comput (D129 , D128 , C125) ) ) ) in ( rng ( Directed D134 ) ) by L858 , FUNCT_1:def 3;
L860: ( card ( if>0 (C124 , C122 , C123) ) ) = ( ( ( card C122 ) + ( card C123 ) ) + ( 3 + 1 ) ) by SCMFSA8B:12
.= ( ( ( ( card C122 ) + ( card C123 ) ) + 3 ) + 1 );
L861: ( ( ( card C122 ) + ( card C123 ) ) + 3 ) < ( card ( if>0 (C124 , C122 , C123) ) ) by L860 , XREAL_1:29;
L862: ( D136 + ( ( card C123 ) + 3 ) ) < ( card ( if>0 (C124 , C122 , C123) ) ) by L861 , L854 , XXREAL_0:2;
L863: ( IC ( Comput (D129 , D128 , C125) ) ) in ( dom ( if>0 (C124 , C122 , C123) ) ) by L862 , L855 , AFINSQ_1:66;
L864: ( CurInstr (D129 , ( Comput (D129 , D128 , C125) )) ) = ( D129 . ( IC ( Comput (D129 , D128 , C125) ) ) ) by PBOOLE:143
.= ( ( if>0 (C124 , C122 , C123) ) . ( IC ( Comput (D129 , D128 , C125) ) ) ) by L863 , L801 , GRFUNC_1:2;
L865: ( Directed D134 ) c= ( if>0 (C124 , C122 , C123) ) by L831 , SCMFSA6A:16;
L866: ( ( if>0 (C124 , C122 , C123) ) . ( IC ( Comput (D129 , D128 , C125) ) ) ) = ( ( Directed D134 ) . ( IC ( Comput (D129 , D128 , C125) ) ) ) by L865 , L858 , GRFUNC_1:2;
thus L867: contradiction by L866 , L841 , L859 , L864 , COMPOS_1:def 11;
end;
L868: ( LifeSpan (D129 , D128) ) = ( ( pseudo-LifeSpan (D126 , D127 , D123) ) + 1 ) by L840 , L838 , L839 , EXTPRO_1:def 15;
L869: ( D124 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( Initialize ( Initialized D124 ) ) by MEMSTR_0:44;
L870: ( D123 ";" ( Stop ( SCM+FSA ) ) ) = D125 by SCMFSA8A:25;
L871: ( Directed D123 ) = D123 by SCMFSA6A:22;
L872: ( DataPart ( Comput (D127 , D126 , ( pseudo-LifeSpan (D124 , R2 , D123) )) ) ) = ( DataPart ( Comput (D133 , D132 , ( pseudo-LifeSpan (D124 , R2 , D123) )) ) ) by L871 , L817 , L870 , L319;
L873: D125 is_halting_on D124 , R2 by L817 , L319;
L874: D133 halts_on D132 by L873 , SCMFSA7B:def 7;
thus L875: ( DataPart ( IExec (( if>0 (C124 , C122 , C123) ) , R2 , C121) ) ) = ( DataPart ( IExec (( if>0 (C124 , C122 , C123) ) , R2 , D124) ) )
.= ( DataPart ( Result (D129 , D128) ) ) by L829
.= ( DataPart ( Comput (D129 , D128 , ( LifeSpan (D129 , D128) )) ) ) by L839 , EXTPRO_1:23
.= ( DataPart ( Comput (D129 , D130 , ( pseudo-LifeSpan (D126 , D127 , D123) )) ) ) by L868 , EXTPRO_1:4
.= ( DataPart ( Comput (D127 , D126 , ( pseudo-LifeSpan (D126 , D127 , D123) )) ) ) by L820 , L836 , L815 , L823 , L190 , L800
.= ( DataPart ( Comput (D133 , D132 , ( LifeSpan (D133 , D132) )) ) ) by L817 , L818 , L872 , L182
.= ( DataPart ( Result (( R2 +* D125 ) , ( D124 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) ) by L869 , L874 , EXTPRO_1:23
.= ( DataPart ( IExec (D125 , R2 , D124) ) )
.= ( DataPart ( IExec (D125 , R2 , C121) ) );
end;
theorem
L876: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B141 being (State of ( SCM+FSA )) holds (for B142 , B143 being (Program of ( SCM+FSA )) holds (for B144 being  read-write Int-Location holds ((( B141 . B144 ) <> ( 0 ) & ( Directed B143 ) is_pseudo-closed_on B141 , R2) implies (( if=0 (B144 , B142 , B143) ) is_halting_on B141 , R2 & ( if=0 (B144 , B142 , B143) ) is_closed_on B141 , R2 & ( LifeSpan (( R2 +* ( if=0 (B144 , B142 , B143) ) ) , ( Initialize B141 )) ) = ( ( LifeSpan (( R2 +* ( B143 ";" ( Stop ( SCM+FSA ) ) ) ) , ( Initialize B141 )) ) + 3 )))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C127 being (State of ( SCM+FSA ));
set D137 = ( Data-Locations ( SCM+FSA ) );
let C128 , C129 being (Program of ( SCM+FSA ));
let C130 being  read-write Int-Location;
set D138 = ( Directed C129 );
set D139 = ( Initialized C127 );
set D140 = ( C129 ";" ( ( Goto ( ( card C128 ) + 1 ) ) ";" ( C128 ";" ( Stop ( SCM+FSA ) ) ) ) );
set D141 = ( Initialize C127 );
set D142 = ( R2 +* D138 );
set D143 = ( Initialize C127 );
set D144 = ( R2 +* ( if=0 (C130 , C128 , C129) ) );
set D145 = ( Comput (D144 , D143 , 1) );
set D146 = ( Comput (D144 , D143 , 2) );
set D147 = ( C130 =0_goto ( ( card C129 ) + 3 ) );
L877: ( if=0 (C130 , C128 , C129) ) c= D144 by FUNCT_4:25;
L878: D138 c= D142 by FUNCT_4:25;
L879: ( if=0 (C130 , C128 , C129) ) = ( ( ( ( ( C130 =0_goto ( ( card C129 ) + 3 ) ) ";" C129 ) ";" ( Goto ( ( card C128 ) + 1 ) ) ) ";" C128 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1;
L880: ( if=0 (C130 , C128 , C129) ) = ( ( ( ( Macro D147 ) ";" C129 ) ";" ( Goto ( ( card C128 ) + 1 ) ) ) ";" ( C128 ";" ( Stop ( SCM+FSA ) ) ) ) by L879 , SCMFSA6A:25;
L881: ( if=0 (C130 , C128 , C129) ) = ( ( ( Macro D147 ) ";" C129 ) ";" ( ( Goto ( ( card C128 ) + 1 ) ) ";" ( C128 ";" ( Stop ( SCM+FSA ) ) ) ) ) by L880 , SCMFSA6A:25;
L882: ( if=0 (C130 , C128 , C129) ) = ( ( Macro D147 ) ";" ( C129 ";" ( ( Goto ( ( card C128 ) + 1 ) ) ";" ( C128 ";" ( Stop ( SCM+FSA ) ) ) ) ) ) by L881 , SCMFSA6A:25;
L883: ( card ( Macro D147 ) ) = 2 by COMPOS_1:56;
L884: ( Reloc (D140 , 2) ) c= ( if=0 (C130 , C128 , C129) ) by L883 , L882 , FUNCT_4:25;
L885: ( 0 ) in ( dom ( if=0 (C130 , C128 , C129) ) ) by L269;
L886: ( D144 . ( 0 ) ) = ( ( if=0 (C130 , C128 , C129) ) . ( 0 ) ) by L885 , FUNCT_4:13
.= D147 by L282;
L887: ( card ( if=0 (C130 , C128 , C129) ) ) = ( ( ( card C128 ) + ( card C129 ) ) + ( 2 + 2 ) ) by SCMFSA8B:11
.= ( ( ( card C129 ) + 2 ) + ( ( card C128 ) + 2 ) );
L888: ( ( ( card C129 ) + 2 ) + ( 0 ) ) < ( card ( if=0 (C130 , C128 , C129) ) ) by L887 , XREAL_1:8;
L889: ( ( card C129 ) + 2 ) in ( dom ( if=0 (C130 , C128 , C129) ) ) by L888 , AFINSQ_1:66;
L890: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L891: ( IC D143 ) = ( IC ( Initialize C127 ) )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L890 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
set D148 = ( Comput (D144 , D143 , ( ( pseudo-LifeSpan (D141 , D142 , D138) ) + 2 )) );
set D149 = D144;
L892: ( if=0 (C130 , C128 , C129) ) c= D144 by FUNCT_4:25;
L893: ( Reloc (D140 , 2) ) c= D144 by L892 , L884 , XBOOLE_1:1;
L894: ( Reloc (D138 , 2) ) c= ( Reloc (D140 , 2) ) by COMPOS_1:44 , SCMFSA6A:16;
L895: ( Reloc (D138 , 2) ) c= D144 by L894 , L893 , XBOOLE_1:1;
L896: ( card ( if=0 (C130 , C128 , C129) ) ) = ( ( ( card C128 ) + ( card C129 ) ) + ( 3 + 1 ) ) by SCMFSA8B:11
.= ( ( ( ( card C128 ) + ( card C129 ) ) + 3 ) + 1 );
L897: ( ( ( card C128 ) + ( card C129 ) ) + 3 ) < ( card ( if=0 (C130 , C128 , C129) ) ) by L896 , NAT_1:13;
L898: ( ( ( card C128 ) + ( card C129 ) ) + 3 ) in ( dom ( if=0 (C130 , C128 , C129) ) ) by L897 , AFINSQ_1:66;
assume L899: ( C127 . C130 ) <> ( 0 );
L900: ( D139 . C130 ) <> ( 0 ) by L899 , SCMFSA_M:37;
L901: 1 in ( dom ( if=0 (C130 , C128 , C129) ) ) by L269;
assume L902: D138 is_pseudo-closed_on C127 , R2;
L903: ( pseudo-LifeSpan (C127 , R2 , D138) ) = ( LifeSpan (( R2 +* ( C129 ";" ( Stop ( SCM+FSA ) ) ) ) , ( Initialize C127 )) ) by L902 , L319;
L904: ( D144 . 1 ) = ( ( if=0 (C130 , C128 , C129) ) . 1 ) by L901 , FUNCT_4:13
.= ( goto 2 ) by L282;
L905: ( DataPart C127 ) = ( DataPart D141 ) by MEMSTR_0:79;
L906: D138 is_pseudo-closed_on D141 , D142 by L905 , L902 , L248;
L907: ( Comput (D144 , D143 , ( ( 0 ) + 1 )) ) = ( Following (D144 , ( Comput (D144 , D143 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D144 , D143) )
.= ( Exec (D147 , D143) ) by L891 , L886 , PBOOLE:143;
L908: C130 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L909: ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L910: (not C130 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L909 , L908 , TARSKI:def 1;
L911: (not C130 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L910;
L912: ( D143 . C130 ) = ( C127 . C130 ) by L911 , FUNCT_4:11
.= ( D139 . C130 ) by SCMFSA_M:37;
L913: ( IC D145 ) = ( succ ( IC D143 ) ) by L912 , L900 , L907 , SCMFSA_2:70
.= ( ( 0 ) + 1 ) by L891;
L914: ( Comput (D144 , D143 , ( 1 + 1 )) ) = ( Following (D144 , D145) ) by EXTPRO_1:3
.= ( Exec (( goto 2 ) , D145) ) by L913 , L904 , PBOOLE:143;
L915: ( IC D146 ) = 2 by L914 , SCMFSA_2:69;
L916:
now
let C131 being FinSeq-Location;
thus L917: ( D141 . C131 ) = ( D145 . C131 ) by L907 , SCMFSA_2:70
.= ( D146 . C131 ) by L914 , SCMFSA_2:69;
end;
L918:
now
let C132 being Int-Location;
thus L919: ( D141 . C132 ) = ( D145 . C132 ) by L907 , SCMFSA_2:70
.= ( D146 . C132 ) by L914 , SCMFSA_2:69;
end;
L920: ( DataPart D141 ) = ( DataPart D146 ) by L918 , L916 , SCMFSA_M:2;
L921: ( IC D148 ) = ( IC ( Comput (D144 , D146 , ( pseudo-LifeSpan (D141 , D142 , D138) )) ) ) by EXTPRO_1:4
.= ( ( IC ( Comput (D142 , D141 , ( pseudo-LifeSpan (D141 , D142 , D138) )) ) ) + 2 ) by L906 , L895 , L915 , L920 , L190 , L878
.= ( ( IC ( Comput (D142 , D141 , ( pseudo-LifeSpan (C127 , R2 , D138) )) ) ) + 2 ) by L902 , L182
.= ( ( card D138 ) + 2 ) by L902 , SCMFSA8A:def 4
.= ( ( card C129 ) + 2 ) by SCMFSA8A:20;
L922: ( CurInstr (D144 , D148) ) = ( D144 . ( ( card C129 ) + 2 ) ) by L921 , PBOOLE:143
.= ( ( if=0 (C130 , C128 , C129) ) . ( ( card C129 ) + 2 ) ) by L889 , L877 , GRFUNC_1:2
.= ( goto ( ( ( card C128 ) + ( card C129 ) ) + 3 ) ) by L496;
L923: ( IC ( Comput (D144 , D143 , ( ( ( pseudo-LifeSpan (D141 , D142 , D138) ) + 2 ) + 1 )) ) ) = ( IC ( Following (D144 , D148) ) ) by EXTPRO_1:3
.= ( ( ( card C128 ) + ( card C129 ) ) + 3 ) by L922 , SCMFSA_2:69;
L924: ( CurInstr (D144 , ( Comput (D144 , D143 , ( ( ( pseudo-LifeSpan (D141 , D142 , D138) ) + 2 ) + 1 )) )) ) = ( D144 . ( ( ( card C128 ) + ( card C129 ) ) + 3 ) ) by L923 , PBOOLE:143
.= ( ( if=0 (C130 , C128 , C129) ) . ( ( ( card C128 ) + ( card C129 ) ) + 3 ) ) by L898 , L877 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by L480;
L925: D144 halts_on D143 by L924 , EXTPRO_1:29;
thus L926: ( if=0 (C130 , C128 , C129) ) is_halting_on C127 , R2 by L925 , SCMFSA7B:def 7;
L927:
now
let C133 being (Element of ( NAT ));
per cases ;
suppose L928: C133 = ( 0 );

L929: ( Comput (D144 , D143 , C133) ) = D143 by L928 , EXTPRO_1:2;
L930: ( IC ( Comput (D144 , D143 , C133) ) ) = ( 0 ) by L929 , MEMSTR_0:16;
thus L931: ( IC ( Comput (D144 , D143 , C133) ) ) in ( dom ( if=0 (C130 , C128 , C129) ) ) by L930 , L269;
end;
suppose L932: (( 0 ) < C133 & C133 = 1);

thus L933: ( IC ( Comput (D144 , D143 , C133) ) ) in ( dom ( if=0 (C130 , C128 , C129) ) ) by L932 , L913 , L269;
end;
suppose L934: (( 0 ) < C133 & C133 <> 1 & C133 < ( ( pseudo-LifeSpan (D141 , D142 , D138) ) + 2 ));

L935: ( ( 0 ) + 1 ) <= C133 by L934 , INT_1:7;
L936: 1 < C133 by L935 , L934 , XXREAL_0:1;
L937: ( ( 0 ) + ( 1 + 1 ) ) <= C133 by L936 , INT_1:7;
consider C134 being Nat such that L938: ( 2 + C134 ) = C133 by L937 , NAT_1:10;
L939: ( card ( if=0 (C130 , C128 , C129) ) ) = ( ( ( card C128 ) + ( card C129 ) ) + ( 2 + 2 ) ) by SCMFSA8B:11
.= ( ( ( card C129 ) + 2 ) + ( ( card C128 ) + 2 ) );
L940: ( ( card C129 ) + 2 ) <= ( card ( if=0 (C130 , C128 , C129) ) ) by L939 , NAT_1:12;
reconsider D150 = C134 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D151 = ( IC ( Comput (D142 , D141 , D150) ) ) as (Element of ( NAT ));
L941: D150 < ( pseudo-LifeSpan (D141 , D142 , D138) ) by L934 , L938 , XREAL_1:6;
L942: D150 < ( pseudo-LifeSpan (C127 , R2 , D138) ) by L941 , L902 , L182;
L943: D151 in ( dom D138 ) by L942 , L902 , SCMFSA8A:17;
L944: D151 < ( card D138 ) by L943 , AFINSQ_1:66;
L945: ( D151 + 2 ) < ( ( card D138 ) + 2 ) by L944 , XREAL_1:6;
L946: ( D151 + 2 ) < ( ( card C129 ) + 2 ) by L945 , SCMFSA8A:20;
L947: ( D151 + 2 ) < ( card ( if=0 (C130 , C128 , C129) ) ) by L946 , L940 , XXREAL_0:2;
L948: ( IC ( Comput (D144 , D143 , C133) ) ) = ( IC ( Comput (D144 , D146 , D150) ) ) by L938 , EXTPRO_1:4
.= ( ( IC ( Comput (D142 , D141 , D150) ) ) + 2 ) by L906 , L895 , L915 , L920 , L941 , L190 , L878;
thus L949: ( IC ( Comput (D144 , D143 , C133) ) ) in ( dom ( if=0 (C130 , C128 , C129) ) ) by L948 , L947 , AFINSQ_1:66;
end;
suppose L950: (( 0 ) < C133 & C133 <> 1 & ( ( pseudo-LifeSpan (D141 , D142 , D138) ) + 2 ) <= C133);

thus L951:now
per cases  by L950 , XXREAL_0:1;
suppose L952: ( ( pseudo-LifeSpan (D141 , D142 , D138) ) + 2 ) = C133;

thus L953: ( IC ( Comput (D144 , D143 , C133) ) ) in ( dom ( if=0 (C130 , C128 , C129) ) ) by L952 , L888 , L921 , AFINSQ_1:66;
end;
suppose L954: ( ( pseudo-LifeSpan (D141 , D142 , D138) ) + 2 ) < C133;

L955: ( ( ( pseudo-LifeSpan (D141 , D142 , D138) ) + 2 ) + 1 ) <= C133 by L954 , INT_1:7;
thus L956: ( IC ( Comput (D144 , D143 , C133) ) ) in ( dom ( if=0 (C130 , C128 , C129) ) ) by L955 , L898 , L923 , L924 , EXTPRO_1:5;
end;
end;
end;
end;
thus L953: ( if=0 (C130 , C128 , C129) ) is_closed_on C127 , R2 by L927 , SCMFSA7B:def 6;
L954: ( CurInstr (D144 , D143) ) = D147 by L891 , L886 , PBOOLE:143;
L955:
now
L956: ( ( 0 ) + 2 ) < ( ( ( card C128 ) + ( card C129 ) ) + 3 ) by XREAL_1:8;
L957: 2 in ( dom ( if=0 (C130 , C128 , C129) ) ) by L956 , L295;
L958: ( CurInstr (D144 , ( Comput (D144 , D143 , 2) )) ) = ( D144 . 2 ) by L915 , PBOOLE:143
.= ( ( if=0 (C130 , C128 , C129) ) . 2 ) by L957 , L877 , GRFUNC_1:2;
let C135 being (Element of ( NAT ));
assume L959: ( CurInstr (D144 , ( Comput (D144 , D143 , C135) )) ) = ( halt ( SCM+FSA ) );
L960: C135 <> ( 0 ) by L959 , L954 , EXTPRO_1:2;
L961: C135 <> 1 by L913 , L959 , L904 , PBOOLE:143;
L962: C135 <> 2 by L959 , L956 , L295 , L958;
L963: 2 < C135 by L962 , L960 , L961 , NAT_1:26;
consider C136 being Nat such that L964: ( 2 + C136 ) = C135 by L963 , NAT_1:10;
reconsider D152 = C136 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D153 = ( IC ( Comput (D142 , D141 , D152) ) ) as (Element of ( NAT ));
assume L965: (not ( ( pseudo-LifeSpan (D141 , D142 , D138) ) + ( 1 + 2 ) ) <= C135);
L966: C135 < ( ( ( pseudo-LifeSpan (D141 , D142 , D138) ) + 1 ) + 2 ) by L965;
L967: D152 < ( ( pseudo-LifeSpan (D141 , D142 , D138) ) + 1 ) by L966 , L964 , XREAL_1:6;
L968: D152 <= ( pseudo-LifeSpan (D141 , D142 , D138) ) by L967 , NAT_1:13;
L969: D152 <= ( pseudo-LifeSpan (C127 , R2 , D138) ) by L968 , L902 , L182;
L970:
now
per cases  by L969 , XXREAL_0:1;
suppose L971: D152 = ( pseudo-LifeSpan (C127 , R2 , D138) );

L972: ( ( ( card C128 ) + ( card C129 ) ) + ( 2 + 1 ) ) = ( ( ( ( card C129 ) + 2 ) + 1 ) + ( card C128 ) );
L973: ( ( ( card C129 ) + 2 ) + 1 ) <= ( ( ( card C128 ) + ( card C129 ) ) + 3 ) by L972 , NAT_1:11;
L974: ( IC ( Comput (D142 , D141 , D152) ) ) = ( card D138 ) by L902 , L971 , SCMFSA8A:def 4;
L975: D153 = ( card C129 ) by L974 , SCMFSA8A:20;
thus L976: ( D153 + 2 ) < ( ( ( card C128 ) + ( card C129 ) ) + 3 ) by L975 , L973 , NAT_1:13;
end;
suppose L977: D152 < ( pseudo-LifeSpan (C127 , R2 , D138) );

L978: D153 in ( dom D138 ) by L977 , L902 , SCMFSA8A:17;
L979: D153 < ( card D138 ) by L978 , AFINSQ_1:66;
L980: ( D153 + 2 ) < ( ( card D138 ) + 2 ) by L979 , XREAL_1:6;
L981: ( D153 + 2 ) < ( ( card C129 ) + 2 ) by L980 , SCMFSA8A:20;
L982: ( ( ( card C128 ) + ( card C129 ) ) + ( 1 + 2 ) ) = ( ( ( card C129 ) + 2 ) + ( ( card C128 ) + 1 ) );
L983: ( ( card C129 ) + 2 ) <= ( ( ( card C128 ) + ( card C129 ) ) + 3 ) by L982 , NAT_1:11;
thus L984: ( D153 + 2 ) < ( ( ( card C128 ) + ( card C129 ) ) + 3 ) by L983 , L981 , XXREAL_0:2;
end;
end;
L986: ( D153 + 2 ) in ( dom ( if=0 (C130 , C128 , C129) ) ) by L970 , L295;
L987: ( IC ( Comput (D144 , D143 , C135) ) ) = ( IC ( Comput (D144 , D146 , D152) ) ) by L964 , EXTPRO_1:4
.= ( D153 + 2 ) by L906 , L895 , L915 , L920 , L968 , L190 , L878;
L988: ( CurInstr (D144 , ( Comput (D144 , D143 , C135) )) ) = ( D144 . ( IC ( Comput (D144 , D143 , C135) ) ) ) by PBOOLE:143
.= ( ( if=0 (C130 , C128 , C129) ) . ( IC ( Comput (D144 , D143 , C135) ) ) ) by L987 , L986 , L877 , GRFUNC_1:2;
thus L989: contradiction by L988 , L959 , L987 , L970 , L295;
end;
L990: ( LifeSpan (D144 , D143) ) = ( ( pseudo-LifeSpan (D141 , D142 , D138) ) + 3 ) by L955 , L924 , L925 , EXTPRO_1:def 15;
thus L991: thesis by L990 , L902 , L903 , L182;
end;
theorem
L992: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B145 being (State of ( SCM+FSA )) holds (for B146 , B147 being (Program of ( SCM+FSA )) holds (for B148 being  read-write Int-Location holds ((( B145 . ( intloc ( 0 ) ) ) = 1 & ( B145 . B148 ) <> ( 0 ) & ( Directed B147 ) is_pseudo-closed_on B145 , R2) implies ( DataPart ( IExec (( if=0 (B148 , B146 , B147) ) , R2 , B145) ) ) = ( DataPart ( IExec (( B147 ";" ( Stop ( SCM+FSA ) ) ) , R2 , B145) ) ))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C137 being (State of ( SCM+FSA ));
set D154 = ( Data-Locations ( SCM+FSA ) );
let C138 , C139 being (Program of ( SCM+FSA ));
let C140 being  read-write Int-Location;
set D155 = ( Directed C139 );
set D156 = ( Initialized C137 );
set D157 = ( Initialized D156 );
set D158 = ( C139 ";" ( ( Goto ( ( card C138 ) + 1 ) ) ";" ( C138 ";" ( Stop ( SCM+FSA ) ) ) ) );
set D159 = ( Initialize D156 );
set D160 = ( R2 +* D155 );
set D161 = ( Initialize D156 );
set D162 = ( R2 +* ( if=0 (C140 , C138 , C139) ) );
set D163 = ( Comput (D162 , D161 , 1) );
set D164 = ( Comput (D162 , D161 , 2) );
set D165 = ( C140 =0_goto ( ( card C139 ) + 3 ) );
L993: D155 c= D160 by FUNCT_4:25;
L994: ( if=0 (C140 , C138 , C139) ) c= D162 by FUNCT_4:25;
assume L995: ( C137 . ( intloc ( 0 ) ) ) = 1;
set D166 = ( Initialize D156 );
set D167 = ( R2 +* ( C139 ";" ( Stop ( SCM+FSA ) ) ) );
assume L996: ( C137 . C140 ) <> ( 0 );
L997: ( D157 . C140 ) <> ( 0 ) by L996 , SCMFSA_M:37;
L998: ( 0 ) in ( dom ( if=0 (C140 , C138 , C139) ) ) by L269;
L999: ( D162 . ( 0 ) ) = ( ( if=0 (C140 , C138 , C139) ) . ( 0 ) ) by L998 , FUNCT_4:13
.= D165 by L282;
L1000: ( D156 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( Initialize ( Initialized D156 ) ) by MEMSTR_0:44;
L1001: ( D156 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = D161 by L1000;
L1002: ( D155 ";" ( Stop ( SCM+FSA ) ) ) = ( C139 ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8A:25;
L1003: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L1004: ( IC D161 ) = ( IC ( Initialize D156 ) )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L1003 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L1005: ( if=0 (C140 , C138 , C139) ) = ( ( ( ( ( C140 =0_goto ( ( card C139 ) + 3 ) ) ";" C139 ) ";" ( Goto ( ( card C138 ) + 1 ) ) ) ";" C138 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1;
L1006: ( if=0 (C140 , C138 , C139) ) = ( ( ( ( Macro D165 ) ";" C139 ) ";" ( Goto ( ( card C138 ) + 1 ) ) ) ";" ( C138 ";" ( Stop ( SCM+FSA ) ) ) ) by L1005 , SCMFSA6A:25;
L1007: ( if=0 (C140 , C138 , C139) ) = ( ( ( Macro D165 ) ";" C139 ) ";" ( ( Goto ( ( card C138 ) + 1 ) ) ";" ( C138 ";" ( Stop ( SCM+FSA ) ) ) ) ) by L1006 , SCMFSA6A:25;
L1008: ( if=0 (C140 , C138 , C139) ) = ( ( Macro D165 ) ";" ( C139 ";" ( ( Goto ( ( card C138 ) + 1 ) ) ";" ( C138 ";" ( Stop ( SCM+FSA ) ) ) ) ) ) by L1007 , SCMFSA6A:25;
L1009: ( card ( Macro D165 ) ) = 2 by COMPOS_1:56;
L1010: ( Reloc (D158 , 2) ) c= ( if=0 (C140 , C138 , C139) ) by L1009 , L1008 , FUNCT_4:25;
L1011: ( if=0 (C140 , C138 , C139) ) c= D162 by FUNCT_4:25;
L1012: ( Reloc (D158 , 2) ) c= D162 by L1011 , L1010 , XBOOLE_1:1;
L1013: ( Reloc (D155 , 2) ) c= ( Reloc (D158 , 2) ) by COMPOS_1:44 , SCMFSA6A:16;
L1014: ( Reloc (D155 , 2) ) c= D162 by L1013 , L1012 , XBOOLE_1:1;
L1015: ( Comput (D162 , D161 , ( ( 0 ) + 1 )) ) = ( Following (D162 , ( Comput (D162 , D161 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D162 , D161) )
.= ( Exec (D165 , D161) ) by L1004 , L999 , PBOOLE:143;
assume L1016: D155 is_pseudo-closed_on C137 , R2;
L1017: D155 is_pseudo-closed_on D156 , R2 by L1016 , L995 , L265;
L1018: ( C139 ";" ( Stop ( SCM+FSA ) ) ) is_halting_on D156 , R2 by L1017 , L319;
L1019: D167 halts_on D166 by L1018 , SCMFSA7B:def 7;
L1020: ( DataPart D156 ) = ( DataPart D159 ) by MEMSTR_0:79;
L1021: D155 is_pseudo-closed_on D159 , D160 by L1020 , L1017 , L248;
L1022: ( D156 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( Initialize ( Initialized D156 ) ) by MEMSTR_0:44;
L1023: ( D156 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = D166 by L1022;
L1024: ( Directed D155 ) = D155 by SCMFSA6A:22;
L1025: ( card ( if=0 (C140 , C138 , C139) ) ) = ( ( ( card C138 ) + ( card C139 ) ) + ( 2 + 2 ) ) by SCMFSA8B:11
.= ( ( ( card C139 ) + 2 ) + ( ( card C138 ) + 2 ) );
L1026: ( ( ( card C139 ) + 2 ) + ( 0 ) ) < ( card ( if=0 (C140 , C138 , C139) ) ) by L1025 , XREAL_1:8;
L1027: ( ( card C139 ) + 2 ) in ( dom ( if=0 (C140 , C138 , C139) ) ) by L1026 , AFINSQ_1:66;
L1028: ( card ( if=0 (C140 , C138 , C139) ) ) = ( ( ( card C138 ) + ( card C139 ) ) + ( 3 + 1 ) ) by SCMFSA8B:11
.= ( ( ( ( card C138 ) + ( card C139 ) ) + 3 ) + 1 );
L1029: ( ( ( card C138 ) + ( card C139 ) ) + 3 ) < ( card ( if=0 (C140 , C138 , C139) ) ) by L1028 , NAT_1:13;
L1030: ( ( ( card C138 ) + ( card C139 ) ) + 3 ) in ( dom ( if=0 (C140 , C138 , C139) ) ) by L1029 , AFINSQ_1:66;
set D168 = ( Comput (D162 , D161 , ( ( pseudo-LifeSpan (D159 , D160 , D155) ) + 2 )) );
L1031: ( LifeSpan (D167 , D166) ) = ( pseudo-LifeSpan (D156 , R2 , D155) ) by L1017 , L319;
L1032: ( DataPart ( Comput (D160 , D159 , ( pseudo-LifeSpan (D156 , R2 , D155) )) ) ) = ( DataPart ( Comput (D167 , D166 , ( LifeSpan (D167 , D166) )) ) ) by L1031 , L1017 , L1024 , L1002 , L319;
L1033: 1 in ( dom ( if=0 (C140 , C138 , C139) ) ) by L269;
L1034: C140 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L1035: ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L1036: (not C140 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L1035 , L1034 , TARSKI:def 1;
L1037: (not C140 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L1036;
L1038: ( D161 . C140 ) = ( D157 . C140 ) by L1037 , FUNCT_4:11;
L1039: ( IC D163 ) = ( succ ( IC D161 ) ) by L1038 , L997 , L1015 , SCMFSA_2:70
.= ( ( 0 ) + 1 ) by L1004;
L1040: ( D162 . 1 ) = ( ( if=0 (C140 , C138 , C139) ) . 1 ) by L1033 , FUNCT_4:13
.= ( goto 2 ) by L282;
L1041: ( Comput (D162 , D161 , ( 1 + 1 )) ) = ( Following (D162 , D163) ) by EXTPRO_1:3
.= ( Exec (( goto 2 ) , D163) ) by L1039 , L1040 , PBOOLE:143;
L1042: ( IC D164 ) = 2 by L1041 , SCMFSA_2:69;
L1043:
now
let C141 being FinSeq-Location;
thus L1044: ( D159 . C141 ) = ( D163 . C141 ) by L1015 , SCMFSA_2:70
.= ( D164 . C141 ) by L1041 , SCMFSA_2:69;
end;
L1045:
now
let C142 being Int-Location;
thus L1046: ( D159 . C142 ) = ( D163 . C142 ) by L1015 , SCMFSA_2:70
.= ( D164 . C142 ) by L1041 , SCMFSA_2:69;
end;
L1047: ( DataPart D159 ) = ( DataPart D164 ) by L1045 , L1043 , SCMFSA_M:2;
L1048: ( IC D168 ) = ( IC ( Comput (D162 , D164 , ( pseudo-LifeSpan (D159 , D160 , D155) )) ) ) by EXTPRO_1:4
.= ( ( IC ( Comput (D160 , D159 , ( pseudo-LifeSpan (D159 , D160 , D155) )) ) ) + 2 ) by L1021 , L1014 , L1042 , L1047 , L190 , L993
.= ( ( IC ( Comput (D160 , D159 , ( pseudo-LifeSpan (D156 , R2 , D155) )) ) ) + 2 ) by L1017 , L182
.= ( ( card D155 ) + 2 ) by L1017 , SCMFSA8A:def 4
.= ( ( card C139 ) + 2 ) by SCMFSA8A:20;
L1049: ( CurInstr (D162 , D168) ) = ( D162 . ( ( card C139 ) + 2 ) ) by L1048 , PBOOLE:143
.= ( ( if=0 (C140 , C138 , C139) ) . ( ( card C139 ) + 2 ) ) by L1027 , L994 , GRFUNC_1:2
.= ( goto ( ( ( card C138 ) + ( card C139 ) ) + 3 ) ) by L496;
L1050: ( IC ( Comput (D162 , D161 , ( ( ( pseudo-LifeSpan (D159 , D160 , D155) ) + 2 ) + 1 )) ) ) = ( IC ( Following (D162 , D168) ) ) by EXTPRO_1:3
.= ( ( ( card C138 ) + ( card C139 ) ) + 3 ) by L1049 , SCMFSA_2:69;
L1051: ( CurInstr (D162 , ( Comput (D162 , D161 , ( ( ( pseudo-LifeSpan (D159 , D160 , D155) ) + 2 ) + 1 )) )) ) = ( D162 . ( ( ( card C138 ) + ( card C139 ) ) + 3 ) ) by L1050 , PBOOLE:143
.= ( ( if=0 (C140 , C138 , C139) ) . ( ( ( card C138 ) + ( card C139 ) ) + 3 ) ) by L1030 , L994 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by L480;
L1052: D162 halts_on D161 by L1051 , EXTPRO_1:29;
L1053: ( CurInstr (D162 , D161) ) = D165 by L1004 , L999 , PBOOLE:143;
L1054:
now
L1055: ( ( 0 ) + 2 ) < ( ( ( card C138 ) + ( card C139 ) ) + 3 ) by XREAL_1:8;
L1056: 2 in ( dom ( if=0 (C140 , C138 , C139) ) ) by L1055 , L295;
L1057: ( ( if=0 (C140 , C138 , C139) ) . 2 ) <> ( halt ( SCM+FSA ) ) by L1055 , L295;
L1058: ( CurInstr (D162 , ( Comput (D162 , D161 , 2) )) ) = ( D162 . 2 ) by L1042 , PBOOLE:143
.= ( ( if=0 (C140 , C138 , C139) ) . 2 ) by L1056 , L994 , GRFUNC_1:2;
let C143 being (Element of ( NAT ));
assume L1059: ( CurInstr (D162 , ( Comput (D162 , D161 , C143) )) ) = ( halt ( SCM+FSA ) );
L1060: C143 <> ( 0 ) by L1059 , L1053 , EXTPRO_1:2;
L1061: C143 <> 1 by L1039 , L1040 , L1059 , PBOOLE:143;
L1062: 2 < C143 by L1060 , L1061 , L1059 , L1057 , L1058 , NAT_1:26;
consider C144 being Nat such that L1063: ( 2 + C144 ) = C143 by L1062 , NAT_1:10;
reconsider D169 = C144 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D170 = ( IC ( Comput (D160 , D159 , D169) ) ) as (Element of ( NAT ));
assume L1064: (not ( ( pseudo-LifeSpan (D159 , D160 , D155) ) + ( 1 + 2 ) ) <= C143);
L1065: C143 < ( ( ( pseudo-LifeSpan (D159 , D160 , D155) ) + 1 ) + 2 ) by L1064;
L1066: D169 < ( ( pseudo-LifeSpan (D159 , D160 , D155) ) + 1 ) by L1065 , L1063 , XREAL_1:6;
L1067: D169 <= ( pseudo-LifeSpan (D159 , D160 , D155) ) by L1066 , NAT_1:13;
L1068: D169 <= ( pseudo-LifeSpan (D156 , R2 , D155) ) by L1067 , L1017 , L182;
L1069:
now
per cases  by L1068 , XXREAL_0:1;
suppose L1070: D169 = ( pseudo-LifeSpan (D156 , R2 , D155) );

L1071: ( ( ( card C138 ) + ( card C139 ) ) + ( 2 + 1 ) ) = ( ( ( ( card C139 ) + 2 ) + 1 ) + ( card C138 ) );
L1072: ( ( ( card C139 ) + 2 ) + 1 ) <= ( ( ( card C138 ) + ( card C139 ) ) + 3 ) by L1071 , NAT_1:11;
L1073: ( IC ( Comput (D160 , D159 , D169) ) ) = ( card D155 ) by L1017 , L1070 , SCMFSA8A:def 4;
L1074: D170 = ( card C139 ) by L1073 , SCMFSA8A:20;
thus L1075: ( D170 + 2 ) < ( ( ( card C138 ) + ( card C139 ) ) + 3 ) by L1074 , L1072 , NAT_1:13;
end;
suppose L1076: D169 < ( pseudo-LifeSpan (D156 , R2 , D155) );

L1077: D170 in ( dom D155 ) by L1076 , L1017 , SCMFSA8A:17;
L1078: D170 < ( card D155 ) by L1077 , AFINSQ_1:66;
L1079: ( D170 + 2 ) < ( ( card D155 ) + 2 ) by L1078 , XREAL_1:6;
L1080: ( D170 + 2 ) < ( ( card C139 ) + 2 ) by L1079 , SCMFSA8A:20;
L1081: ( ( ( card C138 ) + ( card C139 ) ) + ( 1 + 2 ) ) = ( ( ( card C139 ) + 2 ) + ( ( card C138 ) + 1 ) );
L1082: ( ( card C139 ) + 2 ) <= ( ( ( card C138 ) + ( card C139 ) ) + 3 ) by L1081 , NAT_1:11;
thus L1083: ( D170 + 2 ) < ( ( ( card C138 ) + ( card C139 ) ) + 3 ) by L1082 , L1080 , XXREAL_0:2;
end;
end;
L1085: ( D170 + 2 ) in ( dom ( if=0 (C140 , C138 , C139) ) ) by L1069 , L295;
L1086: ( IC ( Comput (D162 , D161 , C143) ) ) = ( IC ( Comput (D162 , D164 , D169) ) ) by L1063 , EXTPRO_1:4
.= ( D170 + 2 ) by L1021 , L1014 , L1042 , L1047 , L1067 , L190 , L993;
L1087: ( CurInstr (D162 , ( Comput (D162 , D161 , C143) )) ) = ( D162 . ( IC ( Comput (D162 , D161 , C143) ) ) ) by PBOOLE:143
.= ( ( if=0 (C140 , C138 , C139) ) . ( IC ( Comput (D162 , D161 , C143) ) ) ) by L1086 , L1085 , L994 , GRFUNC_1:2;
thus L1088: contradiction by L1087 , L1059 , L1086 , L1069 , L295;
end;
L1089: ( LifeSpan (D162 , D161) ) = ( ( ( pseudo-LifeSpan (D159 , D160 , D155) ) + 2 ) + 1 ) by L1054 , L1051 , L1052 , EXTPRO_1:def 15;
L1090: ( CurInstr (D162 , D168) ) = ( D162 . ( ( card C139 ) + 2 ) ) by L1048 , PBOOLE:143
.= ( ( if=0 (C140 , C138 , C139) ) . ( ( card C139 ) + 2 ) ) by L1027 , L994 , GRFUNC_1:2
.= ( goto ( ( ( card C138 ) + ( card C139 ) ) + 3 ) ) by L496;
L1091: ( InsCode ( CurInstr (D162 , D168) ) ) = 6 by L1090 , SCMFSA_2:23;
L1092: ( InsCode ( CurInstr (D162 , D168) ) ) in { ( 0 ) , 6 , 7 , 8 } by L1091 , ENUMSET1:def 2;
L1093: ( DataPart D168 ) = ( DataPart ( Following (D162 , D168) ) ) by L1092 , L31;
L1094: ( DataPart D168 ) = ( DataPart ( Comput (D162 , D164 , ( pseudo-LifeSpan (D159 , D160 , D155) )) ) ) by EXTPRO_1:4
.= ( DataPart ( Comput (D160 , D159 , ( pseudo-LifeSpan (D159 , D160 , D155) )) ) ) by L1021 , L1014 , L1042 , L1047 , L190 , L993;
thus L1095: ( DataPart ( IExec (( if=0 (C140 , C138 , C139) ) , R2 , C137) ) ) = ( DataPart ( IExec (( if=0 (C140 , C138 , C139) ) , R2 , D156) ) )
.= ( DataPart ( Result (D162 , D161) ) ) by L1001
.= ( DataPart ( Comput (D162 , D161 , ( LifeSpan (D162 , D161) )) ) ) by L1052 , EXTPRO_1:23
.= ( DataPart ( Following (D162 , D168) ) ) by L1089 , EXTPRO_1:3
.= ( DataPart ( Comput (D160 , D159 , ( pseudo-LifeSpan (D156 , R2 , D155) )) ) ) by L1017 , L1094 , L1093 , L182
.= ( DataPart ( Result (D167 , D166) ) ) by L1019 , L1032 , EXTPRO_1:23
.= ( DataPart ( IExec (( C139 ";" ( Stop ( SCM+FSA ) ) ) , R2 , D156) ) ) by L1023
.= ( DataPart ( IExec (( C139 ";" ( Stop ( SCM+FSA ) ) ) , R2 , C137) ) );
end;
theorem
L1096: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B149 being (State of ( SCM+FSA )) holds (for B150 , B151 being (Program of ( SCM+FSA )) holds (for B152 being  read-write Int-Location holds ((( B149 . B152 ) <= ( 0 ) & ( Directed B151 ) is_pseudo-closed_on B149 , R2) implies (( if>0 (B152 , B150 , B151) ) is_halting_on B149 , R2 & ( if>0 (B152 , B150 , B151) ) is_closed_on B149 , R2 & ( LifeSpan (( R2 +* ( if>0 (B152 , B150 , B151) ) ) , ( B149 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) )) ) = ( ( LifeSpan (( R2 +* ( B151 ";" ( Stop ( SCM+FSA ) ) ) ) , ( Initialize B149 )) ) + 3 )))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C145 being (State of ( SCM+FSA ));
set D171 = ( Data-Locations ( SCM+FSA ) );
let C146 , C147 being (Program of ( SCM+FSA ));
let C148 being  read-write Int-Location;
set D172 = ( Directed C147 );
set D173 = ( Initialized C145 );
set D174 = ( C147 ";" ( ( Goto ( ( card C146 ) + 1 ) ) ";" ( C146 ";" ( Stop ( SCM+FSA ) ) ) ) );
set D175 = ( Initialize C145 );
set D176 = ( R2 +* D172 );
set D177 = ( Initialize C145 );
set D178 = ( R2 +* ( if>0 (C148 , C146 , C147) ) );
L1097: ( if>0 (C148 , C146 , C147) ) c= D178 by FUNCT_4:25;
set D179 = ( Comput (D178 , D177 , 1) );
set D180 = ( Comput (D178 , D177 , 2) );
set D181 = ( C148 >0_goto ( ( card C147 ) + 3 ) );
L1098: D172 c= D176 by FUNCT_4:25;
L1099: ( if>0 (C148 , C146 , C147) ) = ( ( ( ( ( C148 >0_goto ( ( card C147 ) + 3 ) ) ";" C147 ) ";" ( Goto ( ( card C146 ) + 1 ) ) ) ";" C146 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2;
L1100: ( if>0 (C148 , C146 , C147) ) = ( ( ( ( Macro D181 ) ";" C147 ) ";" ( Goto ( ( card C146 ) + 1 ) ) ) ";" ( C146 ";" ( Stop ( SCM+FSA ) ) ) ) by L1099 , SCMFSA6A:25;
L1101: ( if>0 (C148 , C146 , C147) ) = ( ( ( Macro D181 ) ";" C147 ) ";" ( ( Goto ( ( card C146 ) + 1 ) ) ";" ( C146 ";" ( Stop ( SCM+FSA ) ) ) ) ) by L1100 , SCMFSA6A:25;
L1102: ( if>0 (C148 , C146 , C147) ) = ( ( Macro D181 ) ";" ( C147 ";" ( ( Goto ( ( card C146 ) + 1 ) ) ";" ( C146 ";" ( Stop ( SCM+FSA ) ) ) ) ) ) by L1101 , SCMFSA6A:25;
L1103: ( card ( Macro D181 ) ) = 2 by COMPOS_1:56;
L1104: ( Reloc (D174 , 2) ) c= ( if>0 (C148 , C146 , C147) ) by L1103 , L1102 , FUNCT_4:25;
L1105: ( 0 ) in ( dom ( if>0 (C148 , C146 , C147) ) ) by L269;
L1106: ( D178 . ( 0 ) ) = ( ( if>0 (C148 , C146 , C147) ) . ( 0 ) ) by L1105 , FUNCT_4:13
.= D181 by L282;
L1107: ( card ( if>0 (C148 , C146 , C147) ) ) = ( ( ( card C146 ) + ( card C147 ) ) + ( 2 + 2 ) ) by SCMFSA8B:12
.= ( ( ( card C147 ) + 2 ) + ( ( card C146 ) + 2 ) );
L1108: ( ( ( card C147 ) + 2 ) + ( 0 ) ) < ( card ( if>0 (C148 , C146 , C147) ) ) by L1107 , XREAL_1:8;
L1109: ( ( card C147 ) + 2 ) in ( dom ( if>0 (C148 , C146 , C147) ) ) by L1108 , AFINSQ_1:66;
L1110: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L1111: ( IC D177 ) = ( IC ( Initialize C145 ) )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L1110 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
set D182 = ( Comput (D178 , D177 , ( ( pseudo-LifeSpan (D175 , D176 , D172) ) + 2 )) );
set D183 = D178;
L1112: ( if>0 (C148 , C146 , C147) ) c= D178 by FUNCT_4:25;
L1113: ( Reloc (D174 , 2) ) c= D178 by L1112 , L1104 , XBOOLE_1:1;
L1114: ( Reloc (D172 , 2) ) c= ( Reloc (D174 , 2) ) by COMPOS_1:44 , SCMFSA6A:16;
L1115: ( Reloc (D172 , 2) ) c= D178 by L1114 , L1113 , XBOOLE_1:1;
L1116: ( card ( if>0 (C148 , C146 , C147) ) ) = ( ( ( card C146 ) + ( card C147 ) ) + ( 3 + 1 ) ) by SCMFSA8B:12
.= ( ( ( ( card C146 ) + ( card C147 ) ) + 3 ) + 1 );
L1117: ( ( ( card C146 ) + ( card C147 ) ) + 3 ) < ( card ( if>0 (C148 , C146 , C147) ) ) by L1116 , NAT_1:13;
L1118: ( ( ( card C146 ) + ( card C147 ) ) + 3 ) in ( dom ( if>0 (C148 , C146 , C147) ) ) by L1117 , AFINSQ_1:66;
assume L1119: ( C145 . C148 ) <= ( 0 );
L1120: ( D173 . C148 ) <= ( 0 ) by L1119 , SCMFSA_M:37;
L1121: 1 in ( dom ( if>0 (C148 , C146 , C147) ) ) by L269;
assume L1122: D172 is_pseudo-closed_on C145 , R2;
L1123: ( pseudo-LifeSpan (C145 , R2 , D172) ) = ( LifeSpan (( R2 +* ( C147 ";" ( Stop ( SCM+FSA ) ) ) ) , ( Initialize C145 )) ) by L1122 , L319;
L1124: ( D178 . 1 ) = ( ( if>0 (C148 , C146 , C147) ) . 1 ) by L1121 , FUNCT_4:13
.= ( goto 2 ) by L282;
L1125: ( DataPart C145 ) = ( DataPart D175 ) by MEMSTR_0:79;
L1126: D172 is_pseudo-closed_on D175 , D176 by L1125 , L1122 , L248;
L1127: ( Comput (D178 , D177 , ( ( 0 ) + 1 )) ) = ( Following (D178 , ( Comput (D178 , D177 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D178 , D177) )
.= ( Exec (D181 , D177) ) by L1111 , L1106 , PBOOLE:143;
L1128: C148 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L1129: ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L1130: (not C148 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L1129 , L1128 , TARSKI:def 1;
L1131: (not C148 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L1130;
L1132: ( D177 . C148 ) = ( C145 . C148 ) by L1131 , FUNCT_4:11
.= ( D173 . C148 ) by SCMFSA_M:37;
L1133: ( IC D179 ) = ( succ ( IC D177 ) ) by L1132 , L1120 , L1127 , SCMFSA_2:71
.= ( ( 0 ) + 1 ) by L1111;
L1134: ( Comput (D178 , D177 , ( 1 + 1 )) ) = ( Following (D178 , D179) ) by EXTPRO_1:3
.= ( Exec (( goto 2 ) , D179) ) by L1133 , L1124 , PBOOLE:143;
L1135: ( IC D180 ) = 2 by L1134 , SCMFSA_2:69;
L1136:
now
let C149 being FinSeq-Location;
thus L1137: ( D175 . C149 ) = ( D179 . C149 ) by L1127 , SCMFSA_2:71
.= ( D180 . C149 ) by L1134 , SCMFSA_2:69;
end;
L1138:
now
let C150 being Int-Location;
thus L1139: ( D175 . C150 ) = ( D179 . C150 ) by L1127 , SCMFSA_2:71
.= ( D180 . C150 ) by L1134 , SCMFSA_2:69;
end;
L1140: ( DataPart D175 ) = ( DataPart D180 ) by L1138 , L1136 , SCMFSA_M:2;
L1141: ( IC D182 ) = ( IC ( Comput (D178 , D180 , ( pseudo-LifeSpan (D175 , D176 , D172) )) ) ) by EXTPRO_1:4
.= ( ( IC ( Comput (D176 , D175 , ( pseudo-LifeSpan (D175 , D176 , D172) )) ) ) + 2 ) by L1126 , L1115 , L1135 , L1140 , L190 , L1098
.= ( ( IC ( Comput (D176 , D175 , ( pseudo-LifeSpan (C145 , R2 , D172) )) ) ) + 2 ) by L1122 , L182
.= ( ( card D172 ) + 2 ) by L1122 , SCMFSA8A:def 4
.= ( ( card C147 ) + 2 ) by SCMFSA8A:20;
L1142: ( CurInstr (D178 , D182) ) = ( D178 . ( ( card C147 ) + 2 ) ) by L1141 , PBOOLE:143
.= ( ( if>0 (C148 , C146 , C147) ) . ( ( card C147 ) + 2 ) ) by L1109 , L1097 , GRFUNC_1:2
.= ( goto ( ( ( card C146 ) + ( card C147 ) ) + 3 ) ) by L511;
L1143: ( IC ( Comput (D178 , D177 , ( ( ( pseudo-LifeSpan (D175 , D176 , D172) ) + 2 ) + 1 )) ) ) = ( IC ( Following (D178 , D182) ) ) by EXTPRO_1:3
.= ( ( ( card C146 ) + ( card C147 ) ) + 3 ) by L1142 , SCMFSA_2:69;
L1144: ( CurInstr (D178 , ( Comput (D178 , D177 , ( ( ( pseudo-LifeSpan (D175 , D176 , D172) ) + 2 ) + 1 )) )) ) = ( D178 . ( ( ( card C146 ) + ( card C147 ) ) + 3 ) ) by L1143 , PBOOLE:143
.= ( ( if>0 (C148 , C146 , C147) ) . ( ( ( card C146 ) + ( card C147 ) ) + 3 ) ) by L1118 , L1097 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by L488;
L1145: D178 halts_on D177 by L1144 , EXTPRO_1:29;
thus L1146: ( if>0 (C148 , C146 , C147) ) is_halting_on C145 , R2 by L1145 , SCMFSA7B:def 7;
L1147:
now
let C151 being (Element of ( NAT ));
per cases ;
suppose L1148: C151 = ( 0 );

L1149: ( Comput (D178 , D177 , C151) ) = D177 by L1148 , EXTPRO_1:2;
L1150: ( IC ( Comput (D178 , D177 , C151) ) ) = ( 0 ) by L1149 , MEMSTR_0:16;
thus L1151: ( IC ( Comput (D178 , D177 , C151) ) ) in ( dom ( if>0 (C148 , C146 , C147) ) ) by L1150 , L269;
end;
suppose L1152: (( 0 ) < C151 & C151 = 1);

thus L1153: ( IC ( Comput (D178 , D177 , C151) ) ) in ( dom ( if>0 (C148 , C146 , C147) ) ) by L1152 , L1133 , L269;
end;
suppose L1154: (( 0 ) < C151 & C151 <> 1 & C151 < ( ( pseudo-LifeSpan (D175 , D176 , D172) ) + 2 ));

L1155: ( ( 0 ) + 1 ) <= C151 by L1154 , INT_1:7;
L1156: 1 < C151 by L1155 , L1154 , XXREAL_0:1;
L1157: ( ( 0 ) + ( 1 + 1 ) ) <= C151 by L1156 , INT_1:7;
consider C152 being Nat such that L1158: ( 2 + C152 ) = C151 by L1157 , NAT_1:10;
L1159: ( card ( if>0 (C148 , C146 , C147) ) ) = ( ( ( card C146 ) + ( card C147 ) ) + ( 2 + 2 ) ) by SCMFSA8B:12
.= ( ( ( card C147 ) + 2 ) + ( ( card C146 ) + 2 ) );
L1160: ( ( card C147 ) + 2 ) <= ( card ( if>0 (C148 , C146 , C147) ) ) by L1159 , NAT_1:12;
reconsider D184 = C152 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D185 = ( IC ( Comput (D176 , D175 , D184) ) ) as (Element of ( NAT ));
L1161: D184 < ( pseudo-LifeSpan (D175 , D176 , D172) ) by L1154 , L1158 , XREAL_1:6;
L1162: D184 < ( pseudo-LifeSpan (C145 , R2 , D172) ) by L1161 , L1122 , L182;
L1163: D185 in ( dom D172 ) by L1162 , L1122 , SCMFSA8A:17;
L1164: D185 < ( card D172 ) by L1163 , AFINSQ_1:66;
L1165: ( D185 + 2 ) < ( ( card D172 ) + 2 ) by L1164 , XREAL_1:6;
L1166: ( D185 + 2 ) < ( ( card C147 ) + 2 ) by L1165 , SCMFSA8A:20;
L1167: ( D185 + 2 ) < ( card ( if>0 (C148 , C146 , C147) ) ) by L1166 , L1160 , XXREAL_0:2;
L1168: ( IC ( Comput (D178 , D177 , C151) ) ) = ( IC ( Comput (D178 , D180 , D184) ) ) by L1158 , EXTPRO_1:4
.= ( ( IC ( Comput (D176 , D175 , D184) ) ) + 2 ) by L1126 , L1115 , L1135 , L1140 , L1161 , L190 , L1098;
thus L1169: ( IC ( Comput (D178 , D177 , C151) ) ) in ( dom ( if>0 (C148 , C146 , C147) ) ) by L1168 , L1167 , AFINSQ_1:66;
end;
suppose L1170: (( 0 ) < C151 & C151 <> 1 & ( ( pseudo-LifeSpan (D175 , D176 , D172) ) + 2 ) <= C151);

thus L1171:now
per cases  by L1170 , XXREAL_0:1;
suppose L1172: ( ( pseudo-LifeSpan (D175 , D176 , D172) ) + 2 ) = C151;

thus L1173: ( IC ( Comput (D178 , D177 , C151) ) ) in ( dom ( if>0 (C148 , C146 , C147) ) ) by L1172 , L1108 , L1141 , AFINSQ_1:66;
end;
suppose L1174: ( ( pseudo-LifeSpan (D175 , D176 , D172) ) + 2 ) < C151;

L1175: ( ( ( pseudo-LifeSpan (D175 , D176 , D172) ) + 2 ) + 1 ) <= C151 by L1174 , INT_1:7;
thus L1176: ( IC ( Comput (D178 , D177 , C151) ) ) in ( dom ( if>0 (C148 , C146 , C147) ) ) by L1175 , L1118 , L1143 , L1144 , EXTPRO_1:5;
end;
end;
end;
end;
thus L1173: ( if>0 (C148 , C146 , C147) ) is_closed_on C145 , R2 by L1147 , SCMFSA7B:def 6;
L1174: ( CurInstr (D178 , D177) ) = D181 by L1111 , L1106 , PBOOLE:143;
L1175:
now
L1176: ( ( 0 ) + 2 ) < ( ( ( card C146 ) + ( card C147 ) ) + 3 ) by XREAL_1:8;
L1177: 2 in ( dom ( if>0 (C148 , C146 , C147) ) ) by L1176 , L307;
L1178: ( CurInstr (D178 , ( Comput (D178 , D177 , 2) )) ) = ( D178 . 2 ) by L1135 , PBOOLE:143
.= ( ( if>0 (C148 , C146 , C147) ) . 2 ) by L1177 , L1097 , GRFUNC_1:2;
let C153 being (Element of ( NAT ));
assume L1179: ( CurInstr (D178 , ( Comput (D178 , D177 , C153) )) ) = ( halt ( SCM+FSA ) );
L1180: C153 <> ( 0 ) by L1179 , L1174 , EXTPRO_1:2;
L1181: C153 <> 1 by L1133 , L1179 , L1124 , PBOOLE:143;
L1182: 2 <> C153 by L1179 , L1176 , L307 , L1178;
L1183: 2 < C153 by L1182 , L1180 , L1181 , NAT_1:26;
consider C154 being Nat such that L1184: ( 2 + C154 ) = C153 by L1183 , NAT_1:10;
reconsider D186 = C154 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D187 = ( IC ( Comput (D176 , D175 , D186) ) ) as (Element of ( NAT ));
assume L1185: (not ( ( pseudo-LifeSpan (D175 , D176 , D172) ) + ( 1 + 2 ) ) <= C153);
L1186: C153 < ( ( ( pseudo-LifeSpan (D175 , D176 , D172) ) + 1 ) + 2 ) by L1185;
L1187: D186 < ( ( pseudo-LifeSpan (D175 , D176 , D172) ) + 1 ) by L1186 , L1184 , XREAL_1:6;
L1188: D186 <= ( pseudo-LifeSpan (D175 , D176 , D172) ) by L1187 , NAT_1:13;
L1189: D186 <= ( pseudo-LifeSpan (C145 , R2 , D172) ) by L1188 , L1122 , L182;
L1190:
now
per cases  by L1189 , XXREAL_0:1;
suppose L1191: D186 = ( pseudo-LifeSpan (C145 , R2 , D172) );

L1192: ( ( ( card C146 ) + ( card C147 ) ) + ( 2 + 1 ) ) = ( ( ( ( card C147 ) + 2 ) + 1 ) + ( card C146 ) );
L1193: ( ( ( card C147 ) + 2 ) + 1 ) <= ( ( ( card C146 ) + ( card C147 ) ) + 3 ) by L1192 , NAT_1:11;
L1194: ( IC ( Comput (D176 , D175 , D186) ) ) = ( card D172 ) by L1122 , L1191 , SCMFSA8A:def 4;
L1195: D187 = ( card C147 ) by L1194 , SCMFSA8A:20;
thus L1196: ( D187 + 2 ) < ( ( ( card C146 ) + ( card C147 ) ) + 3 ) by L1195 , L1193 , NAT_1:13;
end;
suppose L1197: D186 < ( pseudo-LifeSpan (C145 , R2 , D172) );

L1198: D187 in ( dom D172 ) by L1197 , L1122 , SCMFSA8A:17;
L1199: D187 < ( card D172 ) by L1198 , AFINSQ_1:66;
L1200: ( D187 + 2 ) < ( ( card D172 ) + 2 ) by L1199 , XREAL_1:6;
L1201: ( D187 + 2 ) < ( ( card C147 ) + 2 ) by L1200 , SCMFSA8A:20;
L1202: ( ( ( card C146 ) + ( card C147 ) ) + ( 1 + 2 ) ) = ( ( ( card C147 ) + 2 ) + ( ( card C146 ) + 1 ) );
L1203: ( ( card C147 ) + 2 ) <= ( ( ( card C146 ) + ( card C147 ) ) + 3 ) by L1202 , NAT_1:11;
thus L1204: ( D187 + 2 ) < ( ( ( card C146 ) + ( card C147 ) ) + 3 ) by L1203 , L1201 , XXREAL_0:2;
end;
end;
L1206: ( D187 + 2 ) in ( dom ( if>0 (C148 , C146 , C147) ) ) by L1190 , L307;
L1207: ( IC ( Comput (D178 , D177 , C153) ) ) = ( IC ( Comput (D178 , D180 , D186) ) ) by L1184 , EXTPRO_1:4
.= ( D187 + 2 ) by L1126 , L1115 , L1135 , L1140 , L1188 , L190 , L1098;
L1208: ( CurInstr (D178 , ( Comput (D178 , D177 , C153) )) ) = ( D178 . ( IC ( Comput (D178 , D177 , C153) ) ) ) by PBOOLE:143
.= ( ( if>0 (C148 , C146 , C147) ) . ( IC ( Comput (D178 , D177 , C153) ) ) ) by L1207 , L1206 , L1097 , GRFUNC_1:2;
thus L1209: contradiction by L1208 , L1179 , L1207 , L1190 , L307;
end;
L1210: ( LifeSpan (D178 , D177) ) = ( ( pseudo-LifeSpan (D175 , D176 , D172) ) + 3 ) by L1175 , L1144 , L1145 , EXTPRO_1:def 15;
thus L1211: thesis by L1210 , L1122 , L1123 , L182;
end;
theorem
L1212: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B153 being (State of ( SCM+FSA )) holds (for B154 , B155 being (Program of ( SCM+FSA )) holds (for B156 being  read-write Int-Location holds ((( B153 . ( intloc ( 0 ) ) ) = 1 & ( B153 . B156 ) <= ( 0 ) & ( Directed B155 ) is_pseudo-closed_on B153 , R2) implies ( DataPart ( IExec (( if>0 (B156 , B154 , B155) ) , R2 , B153) ) ) = ( DataPart ( IExec (( B155 ";" ( Stop ( SCM+FSA ) ) ) , R2 , B153) ) ))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C155 being (State of ( SCM+FSA ));
set D188 = ( Data-Locations ( SCM+FSA ) );
let C156 , C157 being (Program of ( SCM+FSA ));
let C158 being  read-write Int-Location;
set D189 = ( Directed C157 );
set D190 = ( Initialized C155 );
set D191 = ( Initialized D190 );
set D192 = ( C157 ";" ( ( Goto ( ( card C156 ) + 1 ) ) ";" ( C156 ";" ( Stop ( SCM+FSA ) ) ) ) );
set D193 = ( Initialize D190 );
set D194 = ( R2 +* D189 );
set D195 = ( Initialize D190 );
set D196 = ( R2 +* ( if>0 (C158 , C156 , C157) ) );
set D197 = ( Comput (D196 , D195 , 1) );
set D198 = ( Comput (D196 , D195 , 2) );
set D199 = ( C158 >0_goto ( ( card C157 ) + 3 ) );
L1213: ( if>0 (C158 , C156 , C157) ) c= D196 by FUNCT_4:25;
L1214: D189 c= D194 by FUNCT_4:25;
assume L1215: ( C155 . ( intloc ( 0 ) ) ) = 1;
set D200 = ( Initialize D190 );
set D201 = ( R2 +* ( C157 ";" ( Stop ( SCM+FSA ) ) ) );
assume L1216: ( C155 . C158 ) <= ( 0 );
L1217: ( D191 . C158 ) <= ( 0 ) by L1216 , SCMFSA_M:37;
L1218: ( 0 ) in ( dom ( if>0 (C158 , C156 , C157) ) ) by L269;
L1219: ( D196 . ( 0 ) ) = ( ( if>0 (C158 , C156 , C157) ) . ( 0 ) ) by L1218 , FUNCT_4:13
.= D199 by L282;
L1220: ( D190 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( Initialize ( Initialized D190 ) ) by MEMSTR_0:44;
L1221: ( D190 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = D195 by L1220;
L1222: ( D189 ";" ( Stop ( SCM+FSA ) ) ) = ( C157 ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8A:25;
L1223: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L1224: ( IC D195 ) = ( IC ( Initialize D190 ) )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L1223 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L1225: ( if>0 (C158 , C156 , C157) ) = ( ( ( ( ( C158 >0_goto ( ( card C157 ) + 3 ) ) ";" C157 ) ";" ( Goto ( ( card C156 ) + 1 ) ) ) ";" C156 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2;
L1226: ( if>0 (C158 , C156 , C157) ) = ( ( ( ( Macro D199 ) ";" C157 ) ";" ( Goto ( ( card C156 ) + 1 ) ) ) ";" ( C156 ";" ( Stop ( SCM+FSA ) ) ) ) by L1225 , SCMFSA6A:25;
L1227: ( if>0 (C158 , C156 , C157) ) = ( ( ( Macro D199 ) ";" C157 ) ";" ( ( Goto ( ( card C156 ) + 1 ) ) ";" ( C156 ";" ( Stop ( SCM+FSA ) ) ) ) ) by L1226 , SCMFSA6A:25;
L1228: ( if>0 (C158 , C156 , C157) ) = ( ( Macro D199 ) ";" ( C157 ";" ( ( Goto ( ( card C156 ) + 1 ) ) ";" ( C156 ";" ( Stop ( SCM+FSA ) ) ) ) ) ) by L1227 , SCMFSA6A:25;
L1229: ( card ( Macro D199 ) ) = 2 by COMPOS_1:56;
L1230: ( Reloc (D192 , 2) ) c= ( if>0 (C158 , C156 , C157) ) by L1229 , L1228 , FUNCT_4:25;
L1231: ( Reloc (D189 , 2) ) c= ( Reloc (D192 , 2) ) by COMPOS_1:44 , SCMFSA6A:16;
L1232: ( Reloc (D189 , 2) ) c= ( if>0 (C158 , C156 , C157) ) by L1230 , L1231 , XBOOLE_1:1;
L1233: ( Reloc (D189 , 2) ) c= D196 by L1232 , L1213 , XBOOLE_1:1;
L1234: ( Comput (D196 , D195 , ( ( 0 ) + 1 )) ) = ( Following (D196 , ( Comput (D196 , D195 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D196 , D195) )
.= ( Exec (D199 , D195) ) by L1224 , L1219 , PBOOLE:143;
assume L1235: D189 is_pseudo-closed_on C155 , R2;
L1236: D189 is_pseudo-closed_on D190 , R2 by L1235 , L1215 , L265;
L1237: ( C157 ";" ( Stop ( SCM+FSA ) ) ) is_halting_on D190 , R2 by L1236 , L319;
L1238: D201 halts_on D200 by L1237 , SCMFSA7B:def 7;
L1239: ( DataPart D190 ) = ( DataPart D193 ) by MEMSTR_0:79;
L1240: D189 is_pseudo-closed_on D193 , D194 by L1239 , L1236 , L248;
L1241: ( D190 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( Initialize ( Initialized D190 ) ) by MEMSTR_0:44;
L1242: ( D190 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = D200 by L1241;
L1243: ( Directed D189 ) = D189 by SCMFSA6A:22;
L1244: ( card ( if>0 (C158 , C156 , C157) ) ) = ( ( ( card C156 ) + ( card C157 ) ) + ( 2 + 2 ) ) by SCMFSA8B:12
.= ( ( ( card C157 ) + 2 ) + ( ( card C156 ) + 2 ) );
L1245: ( ( ( card C157 ) + 2 ) + ( 0 ) ) < ( card ( if>0 (C158 , C156 , C157) ) ) by L1244 , XREAL_1:8;
L1246: ( ( card C157 ) + 2 ) in ( dom ( if>0 (C158 , C156 , C157) ) ) by L1245 , AFINSQ_1:66;
L1247: ( card ( if>0 (C158 , C156 , C157) ) ) = ( ( ( card C156 ) + ( card C157 ) ) + ( 3 + 1 ) ) by SCMFSA8B:12
.= ( ( ( ( card C156 ) + ( card C157 ) ) + 3 ) + 1 );
L1248: ( ( ( card C156 ) + ( card C157 ) ) + 3 ) < ( card ( if>0 (C158 , C156 , C157) ) ) by L1247 , NAT_1:13;
L1249: ( ( ( card C156 ) + ( card C157 ) ) + 3 ) in ( dom ( if>0 (C158 , C156 , C157) ) ) by L1248 , AFINSQ_1:66;
set D202 = ( Comput (D196 , D195 , ( ( pseudo-LifeSpan (D193 , D194 , D189) ) + 2 )) );
L1250: ( LifeSpan (D201 , D200) ) = ( pseudo-LifeSpan (D190 , R2 , D189) ) by L1236 , L319;
L1251: ( DataPart ( Comput (D194 , D193 , ( pseudo-LifeSpan (D190 , R2 , D189) )) ) ) = ( DataPart ( Comput (D201 , D200 , ( LifeSpan (D201 , D200) )) ) ) by L1250 , L1236 , L1243 , L1222 , L319;
L1252: 1 in ( dom ( if>0 (C158 , C156 , C157) ) ) by L269;
L1253: C158 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L1254: ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L1255: (not C158 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L1254 , L1253 , TARSKI:def 1;
L1256: (not C158 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L1255;
L1257: ( D195 . C158 ) = ( D191 . C158 ) by L1256 , FUNCT_4:11;
L1258: ( IC D197 ) = ( succ ( IC D195 ) ) by L1257 , L1217 , L1234 , SCMFSA_2:71
.= ( ( 0 ) + 1 ) by L1224;
L1259: ( D196 . 1 ) = ( ( if>0 (C158 , C156 , C157) ) . 1 ) by L1252 , FUNCT_4:13
.= ( goto 2 ) by L282;
L1260: ( Comput (D196 , D195 , ( 1 + 1 )) ) = ( Following (D196 , D197) ) by EXTPRO_1:3
.= ( Exec (( goto 2 ) , D197) ) by L1258 , L1259 , PBOOLE:143;
L1261: ( IC D198 ) = 2 by L1260 , SCMFSA_2:69;
L1262:
now
let C159 being FinSeq-Location;
thus L1263: ( D193 . C159 ) = ( D197 . C159 ) by L1234 , SCMFSA_2:71
.= ( D198 . C159 ) by L1260 , SCMFSA_2:69;
end;
L1264:
now
let C160 being Int-Location;
thus L1265: ( D193 . C160 ) = ( D197 . C160 ) by L1234 , SCMFSA_2:71
.= ( D198 . C160 ) by L1260 , SCMFSA_2:69;
end;
L1266: ( DataPart D193 ) = ( DataPart D198 ) by L1264 , L1262 , SCMFSA_M:2;
L1267: ( IC D202 ) = ( IC ( Comput (D196 , D198 , ( pseudo-LifeSpan (D193 , D194 , D189) )) ) ) by EXTPRO_1:4
.= ( ( IC ( Comput (D194 , D193 , ( pseudo-LifeSpan (D193 , D194 , D189) )) ) ) + 2 ) by L1240 , L1261 , L1266 , L190 , L1214 , L1233
.= ( ( IC ( Comput (D194 , D193 , ( pseudo-LifeSpan (D190 , R2 , D189) )) ) ) + 2 ) by L1236 , L182
.= ( ( card D189 ) + 2 ) by L1236 , SCMFSA8A:def 4
.= ( ( card C157 ) + 2 ) by SCMFSA8A:20;
L1268: ( CurInstr (D196 , D202) ) = ( D196 . ( ( card C157 ) + 2 ) ) by L1267 , PBOOLE:143
.= ( ( if>0 (C158 , C156 , C157) ) . ( ( card C157 ) + 2 ) ) by L1246 , L1213 , GRFUNC_1:2
.= ( goto ( ( ( card C156 ) + ( card C157 ) ) + 3 ) ) by L511;
L1269: ( IC ( Comput (D196 , D195 , ( ( ( pseudo-LifeSpan (D193 , D194 , D189) ) + 2 ) + 1 )) ) ) = ( IC ( Following (D196 , D202) ) ) by EXTPRO_1:3
.= ( ( ( card C156 ) + ( card C157 ) ) + 3 ) by L1268 , SCMFSA_2:69;
L1270: ( CurInstr (D196 , ( Comput (D196 , D195 , ( ( ( pseudo-LifeSpan (D193 , D194 , D189) ) + 2 ) + 1 )) )) ) = ( D196 . ( ( ( card C156 ) + ( card C157 ) ) + 3 ) ) by L1269 , PBOOLE:143
.= ( ( if>0 (C158 , C156 , C157) ) . ( ( ( card C156 ) + ( card C157 ) ) + 3 ) ) by L1249 , L1213 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by L488;
L1271: D196 halts_on D195 by L1270 , EXTPRO_1:29;
L1272: ( CurInstr (D196 , D195) ) = D199 by L1224 , L1219 , PBOOLE:143;
L1273:
now
L1274: ( ( 0 ) + 2 ) < ( ( ( card C156 ) + ( card C157 ) ) + 3 ) by XREAL_1:8;
L1275: 2 in ( dom ( if>0 (C158 , C156 , C157) ) ) by L1274 , L307;
L1276: ( CurInstr (D196 , ( Comput (D196 , D195 , 2) )) ) = ( D196 . 2 ) by L1261 , PBOOLE:143
.= ( ( if>0 (C158 , C156 , C157) ) . 2 ) by L1275 , L1213 , GRFUNC_1:2;
let C161 being (Element of ( NAT ));
assume L1277: ( CurInstr (D196 , ( Comput (D196 , D195 , C161) )) ) = ( halt ( SCM+FSA ) );
L1278: C161 <> ( 0 ) by L1277 , L1272 , EXTPRO_1:2;
L1279: C161 <> 1 by L1258 , L1259 , L1277 , PBOOLE:143;
L1280: 2 <> C161 by L1277 , L1274 , L307 , L1276;
L1281: 2 < C161 by L1280 , L1278 , L1279 , NAT_1:26;
consider C162 being Nat such that L1282: ( 2 + C162 ) = C161 by L1281 , NAT_1:10;
reconsider D203 = C162 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D204 = ( IC ( Comput (D194 , D193 , D203) ) ) as (Element of ( NAT ));
assume L1283: (not ( ( pseudo-LifeSpan (D193 , D194 , D189) ) + ( 1 + 2 ) ) <= C161);
L1284: C161 < ( ( ( pseudo-LifeSpan (D193 , D194 , D189) ) + 1 ) + 2 ) by L1283;
L1285: D203 < ( ( pseudo-LifeSpan (D193 , D194 , D189) ) + 1 ) by L1284 , L1282 , XREAL_1:6;
L1286: D203 <= ( pseudo-LifeSpan (D193 , D194 , D189) ) by L1285 , NAT_1:13;
L1287: D203 <= ( pseudo-LifeSpan (D190 , R2 , D189) ) by L1286 , L1236 , L182;
L1288:
now
per cases  by L1287 , XXREAL_0:1;
suppose L1289: D203 = ( pseudo-LifeSpan (D190 , R2 , D189) );

L1290: ( ( ( card C156 ) + ( card C157 ) ) + ( 2 + 1 ) ) = ( ( ( ( card C157 ) + 2 ) + 1 ) + ( card C156 ) );
L1291: ( ( ( card C157 ) + 2 ) + 1 ) <= ( ( ( card C156 ) + ( card C157 ) ) + 3 ) by L1290 , NAT_1:11;
L1292: ( IC ( Comput (D194 , D193 , D203) ) ) = ( card D189 ) by L1236 , L1289 , SCMFSA8A:def 4;
L1293: D204 = ( card C157 ) by L1292 , SCMFSA8A:20;
thus L1294: ( D204 + 2 ) < ( ( ( card C156 ) + ( card C157 ) ) + 3 ) by L1293 , L1291 , NAT_1:13;
end;
suppose L1295: D203 < ( pseudo-LifeSpan (D190 , R2 , D189) );

L1296: D204 in ( dom D189 ) by L1295 , L1236 , SCMFSA8A:17;
L1297: D204 < ( card D189 ) by L1296 , AFINSQ_1:66;
L1298: ( D204 + 2 ) < ( ( card D189 ) + 2 ) by L1297 , XREAL_1:6;
L1299: ( D204 + 2 ) < ( ( card C157 ) + 2 ) by L1298 , SCMFSA8A:20;
L1300: ( ( ( card C156 ) + ( card C157 ) ) + ( 1 + 2 ) ) = ( ( ( card C157 ) + 2 ) + ( ( card C156 ) + 1 ) );
L1301: ( ( card C157 ) + 2 ) <= ( ( ( card C156 ) + ( card C157 ) ) + 3 ) by L1300 , NAT_1:11;
thus L1302: ( D204 + 2 ) < ( ( ( card C156 ) + ( card C157 ) ) + 3 ) by L1301 , L1299 , XXREAL_0:2;
end;
end;
L1304: ( D204 + 2 ) in ( dom ( if>0 (C158 , C156 , C157) ) ) by L1288 , L307;
L1305: ( IC ( Comput (D196 , D195 , C161) ) ) = ( IC ( Comput (D196 , D198 , D203) ) ) by L1282 , EXTPRO_1:4
.= ( D204 + 2 ) by L1240 , L1261 , L1266 , L1286 , L190 , L1214 , L1233;
L1306: ( CurInstr (D196 , ( Comput (D196 , D195 , C161) )) ) = ( D196 . ( IC ( Comput (D196 , D195 , C161) ) ) ) by PBOOLE:143
.= ( ( if>0 (C158 , C156 , C157) ) . ( IC ( Comput (D196 , D195 , C161) ) ) ) by L1305 , L1304 , L1213 , GRFUNC_1:2;
thus L1307: contradiction by L1306 , L1277 , L1305 , L1288 , L307;
end;
L1308: ( LifeSpan (D196 , D195) ) = ( ( ( pseudo-LifeSpan (D193 , D194 , D189) ) + 2 ) + 1 ) by L1273 , L1270 , L1271 , EXTPRO_1:def 15;
L1309: ( CurInstr (D196 , D202) ) = ( D196 . ( ( card C157 ) + 2 ) ) by L1267 , PBOOLE:143
.= ( ( if>0 (C158 , C156 , C157) ) . ( ( card C157 ) + 2 ) ) by L1246 , L1213 , GRFUNC_1:2
.= ( goto ( ( ( card C156 ) + ( card C157 ) ) + 3 ) ) by L511;
L1310: ( InsCode ( CurInstr (D196 , D202) ) ) = 6 by L1309 , SCMFSA_2:23;
L1311: ( InsCode ( CurInstr (D196 , D202) ) ) in { ( 0 ) , 6 , 7 , 8 } by L1310 , ENUMSET1:def 2;
L1312: ( DataPart D202 ) = ( DataPart ( Following (D196 , D202) ) ) by L1311 , L31;
L1313: ( DataPart D202 ) = ( DataPart ( Comput (D196 , D198 , ( pseudo-LifeSpan (D193 , D194 , D189) )) ) ) by EXTPRO_1:4
.= ( DataPart ( Comput (D194 , D193 , ( pseudo-LifeSpan (D193 , D194 , D189) )) ) ) by L1240 , L1261 , L1266 , L190 , L1214 , L1233;
thus L1314: ( DataPart ( IExec (( if>0 (C158 , C156 , C157) ) , R2 , C155) ) ) = ( DataPart ( IExec (( if>0 (C158 , C156 , C157) ) , R2 , D190) ) )
.= ( DataPart ( Result (D196 , D195) ) ) by L1221
.= ( DataPart ( Comput (D196 , D195 , ( LifeSpan (D196 , D195) )) ) ) by L1271 , EXTPRO_1:23
.= ( DataPart ( Following (D196 , D202) ) ) by L1308 , EXTPRO_1:3
.= ( DataPart ( Comput (D194 , D193 , ( pseudo-LifeSpan (D190 , R2 , D189) )) ) ) by L1236 , L1313 , L1312 , L182
.= ( DataPart ( Result (D201 , D200) ) ) by L1238 , L1251 , EXTPRO_1:23
.= ( DataPart ( IExec (( C157 ";" ( Stop ( SCM+FSA ) ) ) , R2 , D190) ) ) by L1242
.= ( DataPart ( IExec (( C157 ";" ( Stop ( SCM+FSA ) ) ) , R2 , C155) ) );
end;
theorem
L1315: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B157 being (State of ( SCM+FSA )) holds (for B158 , B159 being (Program of ( SCM+FSA )) holds (for B160 being  read-write Int-Location holds ((( Directed B158 ) is_pseudo-closed_on B157 , R2 & ( Directed B159 ) is_pseudo-closed_on B157 , R2) implies (( if=0 (B160 , B158 , B159) ) is_closed_on B157 , R2 & ( if=0 (B160 , B158 , B159) ) is_halting_on B157 , R2))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C163 being (State of ( SCM+FSA ));
let C164 , C165 being (Program of ( SCM+FSA ));
let C166 being  read-write Int-Location;
assume L1316: ( Directed C164 ) is_pseudo-closed_on C163 , R2;
assume L1317: ( Directed C165 ) is_pseudo-closed_on C163 , R2;
thus L1318:now
per cases ;
suppose L1319: ( C163 . C166 ) = ( 0 );

thus L1320: ( if=0 (C166 , C164 , C165) ) is_closed_on C163 , R2 by L1319 , L1316 , L543;
thus L1321: ( if=0 (C166 , C164 , C165) ) is_halting_on C163 , R2 by L1316 , L1319 , L543;
end;
suppose L1322: ( C163 . C166 ) <> ( 0 );

thus L1323: ( if=0 (C166 , C164 , C165) ) is_closed_on C163 , R2 by L1322 , L1317 , L876;
thus L1324: ( if=0 (C166 , C164 , C165) ) is_halting_on C163 , R2 by L1317 , L1322 , L876;
end;
end;
end;
theorem
L1319: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B161 being (State of ( SCM+FSA )) holds (for B162 , B163 being (Program of ( SCM+FSA )) holds (for B164 being  read-write Int-Location holds ((( Directed B162 ) is_pseudo-closed_on B161 , R2 & ( Directed B163 ) is_pseudo-closed_on B161 , R2) implies (( if>0 (B164 , B162 , B163) ) is_closed_on B161 , R2 & ( if>0 (B164 , B162 , B163) ) is_halting_on B161 , R2))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C167 being (State of ( SCM+FSA ));
let C168 , C169 being (Program of ( SCM+FSA ));
let C170 being  read-write Int-Location;
assume L1320: ( Directed C168 ) is_pseudo-closed_on C167 , R2;
assume L1321: ( Directed C169 ) is_pseudo-closed_on C167 , R2;
thus L1322:now
per cases ;
suppose L1323: ( C167 . C170 ) > ( 0 );

thus L1324: ( if>0 (C170 , C168 , C169) ) is_closed_on C167 , R2 by L1323 , L1320 , L709;
thus L1325: ( if>0 (C170 , C168 , C169) ) is_halting_on C167 , R2 by L1320 , L1323 , L709;
end;
suppose L1326: ( C167 . C170 ) <= ( 0 );

thus L1327: ( if>0 (C170 , C168 , C169) ) is_closed_on C167 , R2 by L1326 , L1321 , L1096;
thus L1328: ( if>0 (C170 , C168 , C169) ) is_halting_on C167 , R2 by L1321 , L1326 , L1096;
end;
end;
end;
theorem
L1323: (for B165 being (Program of ( SCM+FSA )) holds (for B166 being Int-Location holds ((not B165 destroy B166) implies (not ( Directed B165 ) destroy B166)))) by SCMFSA8A:13;
theorem
L1324: (for B167 being (Instruction of ( SCM+FSA )) holds (for B168 being Int-Location holds ((not B167 destroy B168) implies (not ( Macro B167 ) destroy B168))))
proof
let C171 being (Instruction of ( SCM+FSA ));
let C172 being Int-Location;
L1325: ( rng ( Macro C171 ) ) = { C171 , ( halt ( SCM+FSA ) ) } by COMPOS_1:67;
assume L1326: (not C171 destroy C172);
L1327:
now
let C173 being (Instruction of ( SCM+FSA ));
assume L1328: C173 in ( rng ( Macro C171 ) );
L1329: (C173 = C171 or C173 = ( halt ( SCM+FSA ) )) by L1328 , L1325 , TARSKI:def 2;
thus L1330: (not C173 destroy C172) by L1329 , L1326 , SCMFSA7B:5;
end;
thus L1331: thesis by L1327 , SCMFSA7B:def 4;
end;
theorem
L1332: (for B169 being Int-Location holds (not ( halt ( SCM+FSA ) ) refer B169))
proof
let C174 being Int-Location;
L1333: (for B170 being Int-Location holds (for B171 being (Element of ( NAT )) holds (for B172 being FinSeq-Location holds (( B170 := C174 ) <> ( halt ( SCM+FSA ) ) & ( AddTo (B170 , C174) ) <> ( halt ( SCM+FSA ) ) & ( SubFrom (B170 , C174) ) <> ( halt ( SCM+FSA ) ) & ( MultBy (B170 , C174) ) <> ( halt ( SCM+FSA ) ) & ( Divide (C174 , B170) ) <> ( halt ( SCM+FSA ) ) & ( Divide (B170 , C174) ) <> ( halt ( SCM+FSA ) ) & ( C174 =0_goto B171 ) <> ( halt ( SCM+FSA ) ) & ( C174 >0_goto B171 ) <> ( halt ( SCM+FSA ) ) & ( B170 := (B172 , C174) ) <> ( halt ( SCM+FSA ) ) & ( (B172 , B170) := C174 ) <> ( halt ( SCM+FSA ) ) & ( (B172 , C174) := B170 ) <> ( halt ( SCM+FSA ) ) & ( B172 :=<0,...,0> C174 ) <> ( halt ( SCM+FSA ) )))));
thus L1334: thesis by L1333 , SCMFSA7B:def 1;
end;
theorem
L1335: (for B173 , B174 , B175 being Int-Location holds (B173 <> B174 implies (not ( AddTo (B175 , B174) ) refer B173)))
proof
let C175 , C176 , C177 being Int-Location;
assume L1336: C175 <> C176;
L1337:
now
let C178 being Int-Location;
let C179 being (Element of ( NAT ));
let C180 being FinSeq-Location;
L1338: ( InsCode ( AddTo (C177 , C176) ) ) = 2 by SCMFSA_2:19;
thus L1339: ( C178 := C175 ) <> ( AddTo (C177 , C176) ) by L1338 , SCMFSA_2:18;
thus L1340: ( AddTo (C178 , C175) ) <> ( AddTo (C177 , C176) ) by L1336 , SF_MASTR:2;
thus L1341: ( SubFrom (C178 , C175) ) <> ( AddTo (C177 , C176) ) by L1338 , SCMFSA_2:20;
thus L1342: ( MultBy (C178 , C175) ) <> ( AddTo (C177 , C176) ) by L1338 , SCMFSA_2:21;
thus L1343: (( Divide (C175 , C178) ) <> ( AddTo (C177 , C176) ) & ( Divide (C178 , C175) ) <> ( AddTo (C177 , C176) )) by L1338 , SCMFSA_2:22;
thus L1344: ( C175 =0_goto C179 ) <> ( AddTo (C177 , C176) );
thus L1345: ( C175 >0_goto C179 ) <> ( AddTo (C177 , C176) );
thus L1346: ( C178 := (C180 , C175) ) <> ( AddTo (C177 , C176) ) by L1338 , SCMFSA_2:26;
thus L1347: (( (C180 , C178) := C175 ) <> ( AddTo (C177 , C176) ) & ( (C180 , C175) := C178 ) <> ( AddTo (C177 , C176) )) by L1338 , SCMFSA_2:27;
thus L1348: ( C180 :=<0,...,0> C175 ) <> ( AddTo (C177 , C176) ) by L1338 , SCMFSA_2:29;
end;
thus L1349: thesis by L1337 , SCMFSA7B:def 1;
end;
theorem
L1350: (for B176 being (Instruction of ( SCM+FSA )) holds (for B177 being Int-Location holds ((not B176 refer B177) implies (not ( Macro B176 ) refer B177))))
proof
let C181 being (Instruction of ( SCM+FSA ));
let C182 being Int-Location;
L1351: ( rng ( Macro C181 ) ) = { C181 , ( halt ( SCM+FSA ) ) } by COMPOS_1:67;
assume L1352: (not C181 refer C182);
L1353:
now
let C183 being (Instruction of ( SCM+FSA ));
assume L1354: C183 in ( rng ( Macro C181 ) );
L1355: (C183 = C181 or C183 = ( halt ( SCM+FSA ) )) by L1354 , L1351 , TARSKI:def 2;
thus L1356: (not C183 refer C182) by L1355 , L1352 , L1332;
end;
thus L1357: thesis by L1353 , SCMFSA7B:def 2;
end;
theorem
L1358: (for B178 , B179 being (Program of ( SCM+FSA )) holds (for B180 being Int-Location holds (((not B178 destroy B180) & (not B179 destroy B180)) implies (not ( B178 ";" B179 ) destroy B180))))
proof
let C184 , C185 being (Program of ( SCM+FSA ));
let C186 being Int-Location;
assume that
L1359: (not C184 destroy C186)
and
L1360: (not C185 destroy C186);
L1361: (not ( Reloc (C185 , ( card C184 )) ) destroy C186) by L1360 , SCMFSA8A:9;
L1362: (not ( Directed C184 ) destroy C186) by L1359 , SCMFSA8A:13;
thus L1363: thesis by L1362 , L1361 , SCMFSA8A:11;
end;
theorem
L1364: (for B181 being (Program of ( SCM+FSA )) holds (for B182 being (Instruction of ( SCM+FSA )) holds (for B183 being Int-Location holds (((not B182 destroy B183) & (not B181 destroy B183)) implies (not ( B182 ";" B181 ) destroy B183)))))
proof
let C187 being (Program of ( SCM+FSA ));
let C188 being (Instruction of ( SCM+FSA ));
let C189 being Int-Location;
assume that
L1365: (not C188 destroy C189)
and
L1366: (not C187 destroy C189);
L1367: (not ( Macro C188 ) destroy C189) by L1365 , L1324;
thus L1368: thesis by L1367 , L1366 , L1358;
end;
theorem
L1369: (for B184 being (Program of ( SCM+FSA )) holds (for B185 being (Instruction of ( SCM+FSA )) holds (for B186 being Int-Location holds (((not B184 destroy B186) & (not B185 destroy B186)) implies (not ( B184 ";" B185 ) destroy B186)))))
proof
let C190 being (Program of ( SCM+FSA ));
let C191 being (Instruction of ( SCM+FSA ));
let C192 being Int-Location;
assume that
L1370: (not C190 destroy C192)
and
L1371: (not C191 destroy C192);
L1372: (not ( Macro C191 ) destroy C192) by L1371 , L1324;
thus L1373: thesis by L1372 , L1370 , L1358;
end;
theorem
L1374: (for B187 , B188 being (Instruction of ( SCM+FSA )) holds (for B189 being Int-Location holds (((not B187 destroy B189) & (not B188 destroy B189)) implies (not ( B187 ";" B188 ) destroy B189))))
proof
let C193 , C194 being (Instruction of ( SCM+FSA ));
let C195 being Int-Location;
assume that
L1375: (not C193 destroy C195)
and
L1376: (not C194 destroy C195);
L1377: (not ( Macro C194 ) destroy C195) by L1376 , L1324;
L1378: (not ( Macro C193 ) destroy C195) by L1375 , L1324;
thus L1379: thesis by L1378 , L1377 , L1358;
end;
theorem
L1380: (for B190 being Int-Location holds (not ( Stop ( SCM+FSA ) ) destroy B190))
proof
let C196 being Int-Location;
L1381:
now
let C197 being (Instruction of ( SCM+FSA ));
L1382: ( rng ( Stop ( SCM+FSA ) ) ) = { ( halt ( SCM+FSA ) ) } by AFINSQ_1:33;
assume L1383: C197 in ( rng ( Stop ( SCM+FSA ) ) );
L1384: C197 = ( halt ( SCM+FSA ) ) by L1383 , L1382 , TARSKI:def 1;
thus L1385: (not C197 destroy C196) by L1384 , SCMFSA7B:5;
end;
thus L1386: thesis by L1381 , SCMFSA7B:def 4;
end;
theorem
L1387: (for B191 being Int-Location holds (for B192 being (Element of ( NAT )) holds (not ( Goto B192 ) destroy B191)))
proof
let C198 being Int-Location;
let C199 being (Element of ( NAT ));
L1388:
now
let C200 being (Instruction of ( SCM+FSA ));
L1389: ( rng ( Goto C199 ) ) = { ( goto C199 ) } by FUNCOP_1:8;
assume L1390: C200 in ( rng ( Goto C199 ) );
L1391: C200 = ( goto C199 ) by L1390 , L1389 , TARSKI:def 1;
thus L1392: (not C200 destroy C198) by L1391 , SCMFSA7B:11;
end;
thus L1393: thesis by L1388 , SCMFSA7B:def 4;
end;
theorem
L1394: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B193 being (State of ( SCM+FSA )) holds (for B194 being (Program of ( SCM+FSA )) holds (B194 is_halting_on ( Initialized B193 ) , R2 implies ((for B195 being  read-write Int-Location holds ( ( IExec (B194 , R2 , B193) ) . B195 ) = ( ( Comput (( R2 +* B194 ) , ( Initialize ( Initialized B193 ) ) , ( LifeSpan (( R2 +* B194 ) , ( Initialize ( Initialized B193 ) )) )) ) . B195 )) & (for B196 being FinSeq-Location holds ( ( IExec (B194 , R2 , B193) ) . B196 ) = ( ( Comput (( R2 +* B194 ) , ( Initialize ( Initialized B193 ) ) , ( LifeSpan (( R2 +* B194 ) , ( Initialize ( Initialized B193 ) )) )) ) . B196 )))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C201 being (State of ( SCM+FSA ));
let C202 being (Program of ( SCM+FSA ));
set D205 = ( Initialized C201 );
set D206 = ( Initialize D205 );
set D207 = ( R2 +* C202 );
assume L1395: C202 is_halting_on D205 , R2;
L1396: D207 halts_on D206 by L1395 , SCMFSA7B:def 7;
thus L1397:now
let C203 being  read-write Int-Location;
thus L1398: ( ( IExec (C202 , R2 , C201) ) . C203 ) = ( ( Result (D207 , D206) ) . C203 ) by MEMSTR_0:44
.= ( ( Result (D207 , D206) ) . C203 )
.= ( ( Comput (D207 , D206 , ( LifeSpan (D207 , D206) )) ) . C203 ) by L1396 , EXTPRO_1:23;
end;
let C204 being FinSeq-Location;
thus L1399: ( ( IExec (C202 , R2 , C201) ) . C204 ) = ( ( Result (D207 , D206) ) . C204 ) by MEMSTR_0:44
.= ( ( Result (D207 , D206) ) . C204 )
.= ( ( Comput (D207 , D206 , ( LifeSpan (D207 , D206) )) ) . C204 ) by L1396 , EXTPRO_1:23;
end;
theorem
L1400: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B197 being (State of ( SCM+FSA )) holds (for B198 being  parahalting (Program of ( SCM+FSA )) holds (for B199 being  read-write Int-Location holds ( ( IExec (B198 , R2 , B197) ) . B199 ) = ( ( Comput (( R2 +* B198 ) , ( Initialize ( Initialized B197 ) ) , ( LifeSpan (( R2 +* B198 ) , ( Initialize ( Initialized B197 ) )) )) ) . B199 )))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C205 being (State of ( SCM+FSA ));
let C206 being  parahalting (Program of ( SCM+FSA ));
let C207 being  read-write Int-Location;
L1401: C206 is_halting_on ( Initialized C205 ) , R2 by SCMFSA7B:19;
thus L1402: thesis by L1401 , L1394;
end;
theorem
L1403: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B200 being (State of ( SCM+FSA )) holds (for B201 being (Program of ( SCM+FSA )) holds (for B202 being Int-Location holds (for B203 being (Element of ( NAT )) holds ((B201 is_closed_on ( Initialized B200 ) , R2 & B201 is_halting_on ( Initialized B200 ) , R2 & (not B201 destroy B202)) implies ( ( IExec (B201 , R2 , B200) ) . B202 ) = ( ( Comput (( R2 +* B201 ) , ( Initialize ( Initialized B200 ) ) , B203) ) . B202 )))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C208 being (State of ( SCM+FSA ));
let C209 being (Program of ( SCM+FSA ));
let C210 being Int-Location;
let C211 being (Element of ( NAT ));
assume L1404: C209 is_closed_on ( Initialized C208 ) , R2;
set D208 = ( Initialized C208 );
set D209 = ( Initialize D208 );
set D210 = ( R2 +* C209 );
assume L1405: C209 is_halting_on ( Initialized C208 ) , R2;
L1406: D210 halts_on D209 by L1405 , SCMFSA7B:def 7;
assume L1407: (not C209 destroy C210);
thus L1408: ( ( IExec (C209 , R2 , C208) ) . C210 ) = ( ( Result (D210 , D209) ) . C210 ) by MEMSTR_0:44
.= ( ( Result (D210 , D209) ) . C210 )
.= ( ( Comput (D210 , D209 , ( LifeSpan (D210 , D209) )) ) . C210 ) by L1406 , EXTPRO_1:23
.= ( D208 . C210 ) by L1404 , L1407 , SCMFSA7B:21
.= ( ( Comput (( R2 +* C209 ) , ( Initialize D208 ) , C211) ) . C210 ) by L1404 , L1407 , SCMFSA7B:21;
end;
theorem
L1409: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B204 being (State of ( SCM+FSA )) holds (for B205 being  parahalting (Program of ( SCM+FSA )) holds (for B206 being Int-Location holds (for B207 being (Element of ( NAT )) holds ((not B205 destroy B206) implies ( ( IExec (B205 , R2 , B204) ) . B206 ) = ( ( Comput (( R2 +* B205 ) , ( Initialize ( Initialized B204 ) ) , B207) ) . B206 )))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C212 being (State of ( SCM+FSA ));
let C213 being  parahalting (Program of ( SCM+FSA ));
let C214 being Int-Location;
let C215 being (Element of ( NAT ));
set D211 = ( Initialized C212 );
set D212 = ( Initialize D211 );
set D213 = ( R2 +* C213 );
L1410: C213 c= D213 by FUNCT_4:25;
L1411: C213 is_closed_on D211 , R2 by SCMFSA7B:18;
L1412: D213 halts_on D212 by L1410 , SCMFSA6B:1;
L1413: C213 is_halting_on D211 , R2 by L1412 , SCMFSA7B:def 7;
thus L1414: thesis by L1413 , L1403 , L1411;
end;
theorem
L1415: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B208 being (State of ( SCM+FSA )) holds (for B209 being  parahalting (Program of ( SCM+FSA )) holds (for B210 being Int-Location holds ((not B209 destroy B210) implies ( ( IExec (B209 , R2 , B208) ) . B210 ) = ( ( Initialized B208 ) . B210 ))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C216 being (State of ( SCM+FSA ));
set D214 = ( Data-Locations ( SCM+FSA ) );
let C217 being  parahalting (Program of ( SCM+FSA ));
let C218 being Int-Location;
L1416: ( DataPart ( Initialized C216 ) ) = ( DataPart ( Initialize ( Initialized C216 ) ) ) by MEMSTR_0:79;
assume L1417: (not C217 destroy C218);
thus L1418: ( ( IExec (C217 , R2 , C216) ) . C218 ) = ( ( Comput (( R2 +* C217 ) , ( Initialize ( Initialized C216 ) ) , ( 0 )) ) . C218 ) by L1417 , L1409
.= ( ( Initialize ( Initialized C216 ) ) . C218 )
.= ( ( Initialized C216 ) . C218 ) by L1416 , SCMFSA_M:2;
end;
theorem
L1419: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B211 being (State of ( SCM+FSA )) holds (for B212 being  keeping_0 (Program of ( SCM+FSA )) holds (B212 is_halting_on ( Initialized B211 ) , R2 implies (( ( IExec (B212 , R2 , B211) ) . ( intloc ( 0 ) ) ) = 1 & (for B213 being (Element of ( NAT )) holds ( ( Comput (( R2 +* B212 ) , ( Initialize ( Initialized B211 ) ) , B213) ) . ( intloc ( 0 ) ) ) = 1))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
set D215 = ( intloc ( 0 ) );
let C219 being (State of ( SCM+FSA ));
set D216 = ( Data-Locations ( SCM+FSA ) );
let C220 being  keeping_0 (Program of ( SCM+FSA ));
set D217 = ( Initialized C219 );
set D218 = ( Initialize D217 );
set D219 = ( R2 +* C220 );
L1420: C220 c= D219 by FUNCT_4:25;
L1421: ( DataPart D217 ) = ( DataPart D218 ) by MEMSTR_0:79;
L1422:
now
let C221 being (Element of ( NAT ));
thus L1423: ( ( Comput (D219 , D218 , C221) ) . D215 ) = ( D218 . D215 ) by L1420 , SCMFSA6B:def 4
.= ( D217 . D215 ) by L1421 , SCMFSA_M:2
.= 1 by SCMFSA_M:9;
end;
assume L1424: C220 is_halting_on D217 , R2;
L1425: D219 halts_on D218 by L1424 , SCMFSA7B:def 7;
thus L1426: ( ( IExec (C220 , R2 , C219) ) . D215 ) = ( ( Result (D219 , D218) ) . D215 ) by MEMSTR_0:44
.= ( ( Result (D219 , D218) ) . D215 )
.= ( ( Comput (D219 , D218 , ( LifeSpan (D219 , D218) )) ) . D215 ) by L1425 , EXTPRO_1:23
.= 1 by L1422;
let C222 being (Element of ( NAT ));
thus L1427: thesis by L1422;
end;
theorem
L1428: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B214 being (State of ( SCM+FSA )) holds (for B215 being (Program of ( SCM+FSA )) holds (for B216 being Int-Location holds ((not B215 destroy B216) implies (for B217 being (Element of ( NAT )) holds (( IC ( Comput (( R2 +* B215 ) , ( Initialize B214 ) , B217) ) ) in ( dom B215 ) implies ( ( Comput (( R2 +* B215 ) , ( Initialize B214 ) , ( B217 + 1 )) ) . B216 ) = ( ( Comput (( R2 +* B215 ) , ( Initialize B214 ) , B217) ) . B216 ))))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C223 being (State of ( SCM+FSA ));
let C224 being (Program of ( SCM+FSA ));
let C225 being Int-Location;
assume L1429: (not C224 destroy C225);
set D220 = ( Initialize C223 );
set D221 = ( R2 +* C224 );
L1430: C224 c= D221 by FUNCT_4:25;
let C226 being (Element of ( NAT ));
assume L1431: ( IC ( Comput (( R2 +* C224 ) , ( Initialize C223 ) , C226) ) ) in ( dom C224 );
set D222 = ( IC ( Comput (D221 , D220 , C226) ) );
L1432: ( D221 . D222 ) = ( C224 . D222 ) by L1431 , L1430 , GRFUNC_1:2;
L1433: ( D221 . D222 ) in ( rng C224 ) by L1432 , L1431 , FUNCT_1:def 3;
L1434: (not ( D221 . D222 ) destroy C225) by L1433 , L1429 , SCMFSA7B:def 4;
thus L1435: ( ( Comput (D221 , D220 , ( C226 + 1 )) ) . C225 ) = ( ( Following (D221 , ( Comput (D221 , D220 , C226) )) ) . C225 ) by EXTPRO_1:3
.= ( ( Exec (( D221 . D222 ) , ( Comput (D221 , D220 , C226) )) ) . C225 ) by PBOOLE:143
.= ( ( Comput (D221 , D220 , C226) ) . C225 ) by L1434 , SCMFSA7B:20;
end;
theorem
L1436: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B218 being (State of ( SCM+FSA )) holds (for B219 being (Program of ( SCM+FSA )) holds (for B220 being Int-Location holds ((not B219 destroy B220) implies (for B221 being (Element of ( NAT )) holds ((for B222 being (Element of ( NAT )) holds (B222 < B221 implies ( IC ( Comput (( R2 +* B219 ) , ( Initialize B218 ) , B222) ) ) in ( dom B219 ))) implies (for B223 being (Element of ( NAT )) holds (B223 <= B221 implies ( ( Comput (( R2 +* B219 ) , ( Initialize B218 ) , B223) ) . B220 ) = ( B218 . B220 ))))))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C227 being (State of ( SCM+FSA ));
let C228 being (Program of ( SCM+FSA ));
let C229 being Int-Location;
assume L1437: (not C228 destroy C229);
set D223 = ( Initialize C227 );
set D224 = ( R2 +* C228 );
let C230 being (Element of ( NAT ));
defpred S6[ Nat ] means ($1 <= C230 implies ( ( Comput (D224 , D223 , $1) ) . C229 ) = ( C227 . C229 ));
assume L1438: (for B224 being (Element of ( NAT )) holds (B224 < C230 implies ( IC ( Comput (( R2 +* C228 ) , ( Initialize C227 ) , B224) ) ) in ( dom C228 )));
L1439: (for B225 being (Element of ( NAT )) holds (S6[ B225 ] implies S6[ ( B225 + 1 ) ]))
proof
let C231 being (Element of ( NAT ));
assume L1440: S6[ C231 ];
L1441: ( C231 + ( 0 ) ) < ( C231 + 1 ) by XREAL_1:6;
assume L1442: ( C231 + 1 ) <= C230;
L1443: C231 < C230 by L1442 , L1441 , XXREAL_0:2;
L1444: ( IC ( Comput (D224 , D223 , C231) ) ) in ( dom C228 ) by L1443 , L1438;
thus L1445: thesis by L1444 , L1437 , L1440 , L1442 , L1441 , L1428 , XXREAL_0:2;
end;
let C232 being (Element of ( NAT ));
assume L1446: C232 <= C230;
L1447: ( ( Comput (D224 , D223 , ( 0 )) ) . C229 ) = ( D223 . C229 )
.= ( C227 . C229 ) by SCMFSA_M:21;
L1448: S6[ ( 0 ) ] by L1447;
L1449: (for B226 being (Element of ( NAT )) holds S6[ B226 ]) from NAT_1:sch 1(L1448 , L1439);
thus L1450: thesis by L1449 , L1446;
end;
theorem
L1451: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B227 being (State of ( SCM+FSA )) holds (for B228 being  good (Program of ( SCM+FSA )) holds (for B229 being (Element of ( NAT )) holds ((for B230 being (Element of ( NAT )) holds (B230 < B229 implies ( IC ( Comput (( R2 +* B228 ) , ( Initialize B227 ) , B230) ) ) in ( dom B228 ))) implies (for B231 being (Element of ( NAT )) holds (B231 <= B229 implies ( ( Comput (( R2 +* B228 ) , ( Initialize B227 ) , B231) ) . ( intloc ( 0 ) ) ) = ( B227 . ( intloc ( 0 ) ) ))))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C233 being (State of ( SCM+FSA ));
let C234 being  good (Program of ( SCM+FSA ));
let C235 being (Element of ( NAT ));
assume L1452: (for B232 being (Element of ( NAT )) holds (B232 < C235 implies ( IC ( Comput (( R2 +* C234 ) , ( Initialize C233 ) , B232) ) ) in ( dom C234 )));
let C236 being (Element of ( NAT ));
L1453: (not C234 destroy ( intloc ( 0 ) )) by SCMFSA7B:def 5;
assume L1454: C236 <= C235;
thus L1455: thesis by L1454 , L1452 , L1453 , L1436;
end;
theorem
L1456: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B233 being (State of ( SCM+FSA )) holds (for B234 being  good (Program of ( SCM+FSA )) holds ((B234 is_halting_on ( Initialized B233 ) , R2 & B234 is_closed_on ( Initialized B233 ) , R2) implies (( ( IExec (B234 , R2 , B233) ) . ( intloc ( 0 ) ) ) = 1 & (for B235 being (Element of ( NAT )) holds ( ( Comput (( R2 +* B234 ) , ( Initialize ( Initialized B233 ) ) , B235) ) . ( intloc ( 0 ) ) ) = 1))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
set D225 = ( intloc ( 0 ) );
let C237 being (State of ( SCM+FSA ));
let C238 being  good (Program of ( SCM+FSA ));
set D226 = ( Initialized C237 );
set D227 = ( Initialize D226 );
set D228 = ( R2 +* C238 );
defpred S7[ Nat ] means (for B236 being (Element of ( NAT )) holds (B236 <= $1 implies ( ( Comput (D228 , D227 , B236) ) . ( intloc ( 0 ) ) ) = ( D226 . ( intloc ( 0 ) ) )));
assume L1457: C238 is_halting_on D226 , R2;
L1458: D228 halts_on D227 by L1457 , SCMFSA7B:def 7;
L1459: S7[ ( 0 ) ]
proof
let C239 being (Element of ( NAT ));
L1460: (for B237 being (Element of ( NAT )) holds (B237 < ( 0 ) implies ( IC ( Comput (D228 , D227 , B237) ) ) in ( dom C238 )));
assume L1461: C239 <= ( 0 );
thus L1462: thesis by L1461 , L1460 , L1451;
end;
assume L1463: C238 is_closed_on D226 , R2;
L1464: (for B238 being (Element of ( NAT )) holds (S7[ B238 ] implies S7[ ( B238 + 1 ) ]))
proof
let C240 being (Element of ( NAT ));
assume L1465: S7[ C240 ];
let C241 being (Element of ( NAT ));
assume L1466: C241 <= ( C240 + 1 );
L1467: (for B239 being (Element of ( NAT )) holds (B239 < ( C240 + 1 ) implies ( IC ( Comput (D228 , D227 , B239) ) ) in ( dom C238 ))) by L1463 , SCMFSA7B:def 6;
thus L1468: thesis by L1467 , L1466 , L1451;
end;
L1469: (for B240 being (Element of ( NAT )) holds S7[ B240 ]) from NAT_1:sch 1(L1459 , L1464);
L1470:
now
let C242 being (Element of ( NAT ));
thus L1471: ( ( Comput (D228 , D227 , C242) ) . ( intloc ( 0 ) ) ) = ( D226 . ( intloc ( 0 ) ) ) by L1469
.= 1 by SCMFSA_M:9;
end;
thus L1472: ( ( IExec (C238 , R2 , C237) ) . D225 ) = ( ( Result (D228 , D227) ) . D225 ) by MEMSTR_0:44
.= ( ( Result (D228 , D227) ) . D225 )
.= ( ( Comput (D228 , D227 , ( LifeSpan (D228 , D227) )) ) . D225 ) by L1458 , EXTPRO_1:23
.= 1 by L1470;
thus L1473: thesis by L1470;
end;
theorem
L1474: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B241 being (State of ( SCM+FSA )) holds (for B242 being  good (Program of ( SCM+FSA )) holds (B242 is_closed_on B241 , R2 implies (for B243 being (Element of ( NAT )) holds ( ( Comput (( R2 +* B242 ) , ( Initialize B241 ) , B243) ) . ( intloc ( 0 ) ) ) = ( B241 . ( intloc ( 0 ) ) ))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C243 being (State of ( SCM+FSA ));
let C244 being  good (Program of ( SCM+FSA ));
assume L1475: C244 is_closed_on C243 , R2;
let C245 being (Element of ( NAT ));
L1476: (not C244 destroy ( intloc ( 0 ) )) by SCMFSA7B:def 5;
thus L1477: thesis by L1476 , L1475 , SCMFSA7B:21;
end;
theorem
L1478: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B244 being (State of ( SCM+FSA )) holds (for B245 being  keeping_0  parahalting (Program of ( SCM+FSA )) holds (for B246 being  read-write Int-Location holds ((not B245 destroy B246) implies ( ( Comput (( R2 +* ( B245 ";" ( SubFrom (B246 , ( intloc ( 0 ) )) ) ) ) , ( Initialize ( Initialized B244 ) ) , ( LifeSpan (( R2 +* ( B245 ";" ( SubFrom (B246 , ( intloc ( 0 ) )) ) ) ) , ( Initialize ( Initialized B244 ) )) )) ) . B246 ) = ( ( B244 . B246 ) - 1 ))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C246 being (State of ( SCM+FSA ));
let C247 being  keeping_0  parahalting (Program of ( SCM+FSA ));
let C248 being  read-write Int-Location;
assume L1479: (not C247 destroy C248);
set D229 = ( Initialized C246 );
set D230 = ( Initialize D229 );
set D231 = ( R2 +* ( C247 ";" ( SubFrom (C248 , ( intloc ( 0 ) )) ) ) );
L1480: (not C248 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L1481: ( ( IExec (( C247 ";" ( SubFrom (C248 , ( intloc ( 0 ) )) ) ) , R2 , C246) ) . C248 ) = ( ( Exec (( SubFrom (C248 , ( intloc ( 0 ) )) ) , ( IExec (C247 , R2 , C246) )) ) . C248 ) by SCMFSA6C:6
.= ( ( ( IExec (C247 , R2 , C246) ) . C248 ) - ( ( IExec (C247 , R2 , C246) ) . ( intloc ( 0 ) ) ) ) by SCMFSA_2:65
.= ( ( ( IExec (C247 , R2 , C246) ) . C248 ) - 1 ) by SCMFSA6B:11
.= ( ( ( Comput (( R2 +* C247 ) , ( Initialize D229 ) , ( 0 )) ) . C248 ) - 1 ) by L1479 , L1409
.= ( ( ( Initialize D229 ) . C248 ) - 1 )
.= ( ( D229 . C248 ) - 1 ) by L1480 , FUNCT_4:11;
thus L1482: ( ( Comput (D231 , D230 , ( LifeSpan (D231 , D230) )) ) . C248 ) = ( ( D229 . C248 ) - 1 ) by L1481 , L1400
.= ( ( C246 . C248 ) - 1 ) by SCMFSA_M:37;
end;
theorem
L1483: (for B247 being (Instruction of ( SCM+FSA )) holds ((not B247 destroy ( intloc ( 0 ) )) implies ( Macro B247 ) is  good))
proof
let C249 being (Instruction of ( SCM+FSA ));
assume L1484: (not C249 destroy ( intloc ( 0 ) ));
L1485: (not ( Macro C249 ) destroy ( intloc ( 0 ) )) by L1484 , L1324;
thus L1486: thesis by L1485 , SCMFSA7B:def 5;
end;
theorem
L1487: (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (Instruction-Sequence of ( SCM+FSA )) holds (for B248 , B249 being (State of ( SCM+FSA )) holds (for B250 being (Program of ( SCM+FSA )) holds ((B250 is_closed_on B248 , R4 & B250 is_halting_on B248 , R4 & ( DataPart B248 ) = ( DataPart B249 )) implies (for B251 being (Element of ( NAT )) holds (( Comput (( R4 +* B250 ) , ( Initialize B248 ) , B251) ) = ( Comput (( R5 +* B250 ) , ( Initialize B249 ) , B251) ) & ( CurInstr (( R4 +* B250 ) , ( Comput (( R4 +* B250 ) , ( Initialize B248 ) , B251) )) ) = ( CurInstr (( R5 +* B250 ) , ( Comput (( R5 +* B250 ) , ( Initialize B249 ) , B251) )) ))))))))
proof
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (Instruction-Sequence of ( SCM+FSA ));
let C250 , C251 being (State of ( SCM+FSA ));
set D232 = ( Data-Locations ( SCM+FSA ) );
let C252 being (Program of ( SCM+FSA ));
assume L1488: C252 is_closed_on C250 , R4;
set D233 = ( Initialize C251 );
set D234 = ( R5 +* C252 );
set D235 = ( Initialize C250 );
set D236 = ( R4 +* C252 );
L1489: C252 c= ( R4 +* C252 ) by FUNCT_4:25;
L1490: C252 c= ( R5 +* C252 ) by FUNCT_4:25;
assume L1491: C252 is_halting_on C250 , R4;
assume L1492: ( DataPart C250 ) = ( DataPart C251 );
let C253 being (Element of ( NAT ));
L1493: ( IC ( Comput (D236 , D235 , C253) ) ) in ( dom C252 ) by L1488 , SCMFSA7B:def 6;
L1494: C252 is_closed_on C251 , R5 by L1488 , L1491 , L1492 , SCMFSA8B:5;
L1495: (for B252 being (Element of ( NAT )) holds (B252 < C253 implies ( IC ( Comput (D234 , D233 , B252) ) ) in ( dom C252 ))) by L1494 , SCMFSA7B:def 6;
L1496: D235 = D233 by L1492 , SCMFSA8B:4;
thus L1497: ( Comput (D236 , D235 , C253) ) = ( Comput (D234 , D233 , C253) ) by L1496 , L1495 , L1489 , L1490 , AMISTD_2:10;
L1498: ( IC ( Comput (D236 , D235 , C253) ) ) = ( IC ( Comput (D234 , D233 , C253) ) ) by L1497;
L1499: C252 is_closed_on C251 , R5 by L1488 , L1491 , L1492 , SCMFSA8B:5;
L1500: ( IC ( Comput (D234 , D233 , C253) ) ) in ( dom C252 ) by L1499 , SCMFSA7B:def 6;
thus L1501: ( CurInstr (D234 , ( Comput (D234 , D233 , C253) )) ) = ( D234 . ( IC ( Comput (D234 , D233 , C253) ) ) ) by PBOOLE:143
.= ( C252 . ( IC ( Comput (D234 , D233 , C253) ) ) ) by L1500 , L1490 , GRFUNC_1:2
.= ( D236 . ( IC ( Comput (D236 , D235 , C253) ) ) ) by L1498 , L1493 , L1489 , GRFUNC_1:2
.= ( CurInstr (D236 , ( Comput (D236 , D235 , C253) )) ) by PBOOLE:143;
end;
theorem
L1502: (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (Instruction-Sequence of ( SCM+FSA )) holds (for B253 , B254 being (State of ( SCM+FSA )) holds (for B255 being (Program of ( SCM+FSA )) holds ((B255 is_closed_on B253 , R4 & B255 is_halting_on B253 , R4 & ( DataPart B253 ) = ( DataPart B254 )) implies (( LifeSpan (( R4 +* B255 ) , ( Initialize B253 )) ) = ( LifeSpan (( R5 +* B255 ) , ( Initialize B254 )) ) & ( Result (( R4 +* B255 ) , ( Initialize B253 )) ) = ( Result (( R5 +* B255 ) , ( Initialize B254 )) )))))))
proof
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (Instruction-Sequence of ( SCM+FSA ));
let C254 , C255 being (State of ( SCM+FSA ));
set D237 = ( Data-Locations ( SCM+FSA ) );
let C256 being (Program of ( SCM+FSA ));
assume L1503: C256 is_closed_on C254 , R4;
set D238 = ( Initialize C255 );
set D239 = ( R5 +* C256 );
set D240 = ( Initialize C254 );
set D241 = ( R4 +* C256 );
assume L1504: C256 is_halting_on C254 , R4;
L1505: D241 halts_on D240 by L1504 , SCMFSA7B:def 7;
L1506: ( Result (D241 , D240) ) = ( Comput (D241 , D240 , ( LifeSpan (D241 , D240) )) ) by L1505 , EXTPRO_1:23;
assume L1507: ( DataPart C254 ) = ( DataPart C255 );
L1508: C256 is_halting_on C255 , R5 by L1507 , L1503 , L1504 , SCMFSA8B:5;
L1509: D239 halts_on D238 by L1508 , SCMFSA7B:def 7;
L1510:
now
let C257 being (Element of ( NAT ));
assume L1511: ( CurInstr (D239 , ( Comput (D239 , D238 , C257) )) ) = ( halt ( SCM+FSA ) );
L1512: ( CurInstr (D241 , ( Comput (D241 , D240 , C257) )) ) = ( CurInstr (D239 , ( Comput (D239 , D238 , C257) )) ) by L1503 , L1504 , L1507 , L1487;
thus L1513: ( LifeSpan (D241 , D240) ) <= C257 by L1512 , L1505 , L1511 , EXTPRO_1:def 15;
end;
L1514: ( CurInstr (D239 , ( Comput (D239 , D238 , ( LifeSpan (D241 , D240) )) )) ) = ( CurInstr (D241 , ( Comput (D241 , D240 , ( LifeSpan (D241 , D240) )) )) ) by L1503 , L1504 , L1507 , L1487
.= ( halt ( SCM+FSA ) ) by L1505 , EXTPRO_1:def 15;
thus L1515: ( LifeSpan (D241 , D240) ) = ( LifeSpan (D239 , D238) ) by L1514 , L1510 , L1509 , EXTPRO_1:def 15;
L1516: ( Result (D239 , D238) ) = ( Comput (D239 , D238 , ( LifeSpan (D241 , D240) )) ) by L1515 , L1509 , EXTPRO_1:23;
thus L1517: thesis by L1516 , L1503 , L1504 , L1507 , L1506 , L1487;
end;
theorem
L1518: (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R5 being (Instruction-Sequence of ( SCM+FSA )) holds (for B256 , B257 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B258 being (Program of ( SCM+FSA )) holds ((B258 is_closed_on B256 , R4 & B258 is_halting_on B256 , R4 & B258 c= R4 & B258 c= R5 & (ex B259 being (Element of ( NAT )) st ( Comput (R4 , B256 , B259) ) = B257)) implies ( Result (R4 , B256) ) = ( Result (R5 , B257) ))))))
proof
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R5 being (Instruction-Sequence of ( SCM+FSA ));
let C258 , C259 being ( 0 ) -started (State of ( SCM+FSA ));
set D242 = ( Data-Locations ( SCM+FSA ) );
let C260 being (Program of ( SCM+FSA ));
assume L1519: C260 is_closed_on C258 , R4;
assume L1520: C260 is_halting_on C258 , R4;
L1521: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C258 by MEMSTR_0:29;
L1522: C259 = ( Initialize C259 ) by MEMSTR_0:44;
assume L1523: C260 c= R4;
L1524: R4 = ( R4 +* C260 ) by L1523 , FUNCT_4:98;
assume L1525: C260 c= R5;
L1526: R5 = ( R5 +* C260 ) by L1525 , FUNCT_4:98;
L1527: C258 = ( Initialize C258 ) by L1521 , FUNCT_4:98;
L1528: R4 halts_on C258 by L1527 , L1520 , L1524 , SCMFSA7B:def 7;
consider C261 being (Element of ( NAT )) such that L1529: ( CurInstr (R4 , ( Comput (R4 , C258 , C261) )) ) = ( halt ( SCM+FSA ) ) by L1528 , EXTPRO_1:29;
given C262 being (Element of ( NAT )) such that
L1530: ( Comput (R4 , C258 , C262) ) = C259;

set D243 = ( Comput (R4 , C258 , C262) );
set D244 = R4;
L1531: ( IC ( SCM+FSA ) ) in ( dom D243 ) by MEMSTR_0:2;
L1532: ( IC D243 ) = ( IC C259 ) by L1530
.= ( IC ( Initialize C259 ) ) by L1522
.= ( 0 ) by FUNCT_4:113;
L1533: ( ( IC ( SCM+FSA ) ) .--> ( 0 ) ) c= D243 by L1532 , L1531 , FUNCOP_1:73;
L1534: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= D243 by L1533;
L1535: D243 = ( Initialize D243 ) by L1534 , FUNCT_4:98;
L1536:
now
let C263 being (Element of ( NAT ));
L1537: ( IC ( Comput (R4 , D243 , C263) ) ) = ( IC ( Comput (R4 , C258 , ( C262 + C263 )) ) ) by EXTPRO_1:4;
thus L1538: ( IC ( Comput (D244 , D243 , C263) ) ) in ( dom C260 ) by L1537 , L1519 , L1527 , L1524 , SCMFSA7B:def 6;
end;
L1539: ( Comput (R4 , C258 , ( C261 + C262 )) ) = ( Comput (R4 , ( Comput (R4 , C258 , C262) ) , C261) ) by EXTPRO_1:4;
L1540: ( Comput (R4 , C258 , ( C261 + C262 )) ) = ( Comput (R4 , C258 , C261) ) by L1529 , EXTPRO_1:5 , NAT_1:11;
L1541: D244 halts_on D243 by L1529 , L1540 , L1539 , EXTPRO_1:29;
L1542: C260 is_halting_on D243 , D244 by L1541 , L1535 , L1524 , SCMFSA7B:def 7;
L1543: ( DataPart D243 ) = ( DataPart C259 ) by L1530;
consider C264 being (Element of ( NAT )) such that L1544: ( CurInstr (R4 , ( Comput (R4 , C258 , C264) )) ) = ( halt ( SCM+FSA ) ) by L1528 , EXTPRO_1:29;
L1545: ( R4 . ( IC ( Comput (R4 , C258 , C264) ) ) ) = ( halt ( SCM+FSA ) ) by L1544 , PBOOLE:143;
L1546: C260 is_closed_on D243 , D244 by L1535 , L1536 , L1524 , SCMFSA7B:def 6;
L1547: ( Result (D244 , D243) ) = ( Result (R5 , C259) ) by L1546 , L1522 , L1543 , L1535 , L1542 , L1502 , L1524 , L1526;
thus L1548: thesis by L1547 , L1545 , EXTPRO_1:8;
end;
begin
definition
let C265 being (Program of ( SCM+FSA ));
func loop C265 ->  halt-free (Program of ( SCM+FSA )) equals 
( Directed (C265 , ( 0 )) );
coherence
proof
L1549: ( dom ( Directed (C265 , ( 0 )) ) ) = ( dom C265 ) by FUNCT_4:99;
thus L1550: thesis by L1549;
end;
end;
theorem
L1552: (for B260 being (Program of ( SCM+FSA )) holds (for B261 being Int-Location holds (( loop B260 ) destroy B261 implies B260 destroy B261))) by SCMFSA8A:13;
registration
let C266 being  good (Program of ( SCM+FSA ));
cluster ( loop C266 ) ->  good;
correctness;
end;
theorem
L1554: (for B262 being (Program of ( SCM+FSA )) holds (not ( halt ( SCM+FSA ) ) in ( rng ( loop B262 ) ))) by FUNCT_4:100;
theorem
L1555: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B263 being (State of ( SCM+FSA )) holds (for B264 being (Program of ( SCM+FSA )) holds ((B264 is_closed_on B263 , R2 & B264 is_halting_on B263 , R2) implies (for B265 being (Element of ( NAT )) holds (B265 <= ( LifeSpan (( R2 +* B264 ) , ( Initialize B263 )) ) implies ( Comput (( R2 +* B264 ) , ( Initialize B263 ) , B265) ) = ( Comput (( R2 +* ( loop B264 ) ) , ( Initialize B263 ) , B265) )))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C267 being (State of ( SCM+FSA ));
let C268 being (Program of ( SCM+FSA ));
set D245 = ( Initialize C267 );
set D246 = ( R2 +* C268 );
L1556: C268 c= D246 by FUNCT_4:25;
set D247 = ( Initialize C267 );
set D248 = ( R2 +* ( loop C268 ) );
L1557: ( loop C268 ) c= D248 by FUNCT_4:25;
assume L1558: C268 is_closed_on C267 , R2;
defpred S8[ Nat ] means ($1 <= ( LifeSpan (D246 , D245) ) implies ( Comput (D246 , D245 , $1) ) = ( Comput (D248 , D247 , $1) ));
assume L1559: C268 is_halting_on C267 , R2;
L1560: D246 halts_on D245 by L1559 , SCMFSA7B:def 7;
L1561: (for B266 being (Element of ( NAT )) holds (S8[ B266 ] implies S8[ ( B266 + 1 ) ]))
proof
let C269 being (Element of ( NAT ));
assume L1562: (C269 <= ( LifeSpan (D246 , D245) ) implies ( Comput (D246 , D245 , C269) ) = ( Comput (D248 , D247 , C269) ));
L1563: ( Comput (D246 , D245 , ( C269 + 1 )) ) = ( Following (D246 , ( Comput (D246 , D245 , C269) )) ) by EXTPRO_1:3;
L1564: ( Comput (D248 , D247 , ( C269 + 1 )) ) = ( Following (D248 , ( Comput (D248 , D247 , C269) )) ) by EXTPRO_1:3;
L1565: ( IC ( Comput (D246 , D245 , C269) ) ) in ( dom C268 ) by L1558 , SCMFSA7B:def 6;
L1566: ( D246 /. ( IC ( Comput (D246 , D245 , C269) ) ) ) = ( D246 . ( IC ( Comput (D246 , D245 , C269) ) ) ) by PBOOLE:143;
L1567: ( CurInstr (D246 , ( Comput (D246 , D245 , C269) )) ) = ( C268 . ( IC ( Comput (D246 , D245 , C269) ) ) ) by L1565 , L1566 , L1556 , GRFUNC_1:2;
assume L1568: ( C269 + 1 ) <= ( LifeSpan (D246 , D245) );
L1569: C269 < ( LifeSpan (D246 , D245) ) by L1568 , NAT_1:13;
L1570: ( C268 . ( IC ( Comput (D246 , D245 , C269) ) ) ) <> ( halt ( SCM+FSA ) ) by L1569 , L1560 , L1567 , EXTPRO_1:def 15;
L1571: ( D248 /. ( IC ( Comput (D248 , D247 , C269) ) ) ) = ( D248 . ( IC ( Comput (D248 , D247 , C269) ) ) ) by PBOOLE:143;
L1572: ( IC ( Comput (D246 , D245 , C269) ) ) in ( dom ( loop C268 ) ) by L1565 , FUNCT_4:99;
L1573: ( CurInstr (D246 , ( Comput (D246 , D245 , C269) )) ) = ( D246 . ( IC ( Comput (D246 , D245 , C269) ) ) ) by PBOOLE:143
.= ( C268 . ( IC ( Comput (D246 , D245 , C269) ) ) ) by L1556 , L1565 , GRFUNC_1:2
.= ( ( loop C268 ) . ( IC ( Comput (D246 , D245 , C269) ) ) ) by L1570 , FUNCT_4:105
.= ( D248 . ( IC ( Comput (D246 , D245 , C269) ) ) ) by L1557 , L1572 , GRFUNC_1:2
.= ( CurInstr (D248 , ( Comput (D248 , D247 , C269) )) ) by L1562 , L1568 , L1571 , NAT_1:13;
thus L1574: thesis by L1573 , L1562 , L1568 , L1563 , L1564 , NAT_1:13;
end;
L1575: S8[ ( 0 ) ];
thus L1576: (for B267 being (Element of ( NAT )) holds S8[ B267 ]) from NAT_1:sch 1(L1575 , L1561);
end;
theorem
L1577: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B268 being (State of ( SCM+FSA )) holds (for B269 being (Program of ( SCM+FSA )) holds ((B269 is_closed_on B268 , R2 & B269 is_halting_on B268 , R2) implies (for B270 being (Element of ( NAT )) holds (B270 < ( LifeSpan (( R2 +* B269 ) , ( Initialize B268 )) ) implies ( CurInstr (( R2 +* B269 ) , ( Comput (( R2 +* B269 ) , ( Initialize B268 ) , B270) )) ) = ( CurInstr (( R2 +* ( loop B269 ) ) , ( Comput (( R2 +* ( loop B269 ) ) , ( Initialize B268 ) , B270) )) )))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C270 being (State of ( SCM+FSA ));
let C271 being (Program of ( SCM+FSA ));
set D249 = ( Initialize C270 );
set D250 = ( R2 +* C271 );
set D251 = ( Initialize C270 );
set D252 = ( R2 +* ( loop C271 ) );
L1578: C271 c= D250 by FUNCT_4:25;
L1579: ( loop C271 ) c= D252 by FUNCT_4:25;
assume that
L1580: C271 is_closed_on C270 , R2
and
L1581: C271 is_halting_on C270 , R2;
let C272 being (Element of ( NAT ));
L1582: ( IC ( Comput (D250 , D249 , C272) ) ) in ( dom C271 ) by L1580 , SCMFSA7B:def 6;
L1583: ( IC ( Comput (D250 , D249 , C272) ) ) in ( dom ( loop C271 ) ) by L1582 , FUNCT_4:99;
L1584: ( D250 /. ( IC ( Comput (D250 , D249 , C272) ) ) ) = ( D250 . ( IC ( Comput (D250 , D249 , C272) ) ) ) by PBOOLE:143;
L1585: ( CurInstr (D250 , ( Comput (D250 , D249 , C272) )) ) = ( C271 . ( IC ( Comput (D250 , D249 , C272) ) ) ) by L1582 , L1584 , L1578 , GRFUNC_1:2;
assume L1586: C272 < ( LifeSpan (( R2 +* C271 ) , ( Initialize C270 )) );
L1587: ( D252 /. ( IC ( Comput (D252 , D251 , C272) ) ) ) = ( D252 . ( IC ( Comput (D252 , D251 , C272) ) ) ) by PBOOLE:143;
L1588: D250 halts_on D249 by L1581 , SCMFSA7B:def 7;
L1589: ( C271 . ( IC ( Comput (D250 , D249 , C272) ) ) ) <> ( halt ( SCM+FSA ) ) by L1588 , L1586 , L1585 , EXTPRO_1:def 15;
L1590: ( Comput (( R2 +* C271 ) , ( Initialize C270 ) , C272) ) = ( Comput (( R2 +* ( loop C271 ) ) , ( Initialize C270 ) , C272) ) by L1580 , L1581 , L1586 , L1555;
thus L1591: ( CurInstr (D250 , ( Comput (D250 , D249 , C272) )) ) = ( D250 . ( IC ( Comput (D250 , D249 , C272) ) ) ) by PBOOLE:143
.= ( C271 . ( IC ( Comput (D250 , D249 , C272) ) ) ) by L1578 , L1582 , GRFUNC_1:2
.= ( ( loop C271 ) . ( IC ( Comput (D250 , D249 , C272) ) ) ) by L1589 , FUNCT_4:105
.= ( D252 . ( IC ( Comput (D250 , D249 , C272) ) ) ) by L1583 , L1579 , GRFUNC_1:2
.= ( CurInstr (D252 , ( Comput (D252 , D251 , C272) )) ) by L1587 , L1590;
end;
L1592: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B271 being (State of ( SCM+FSA )) holds (for B272 being (Program of ( SCM+FSA )) holds ((B272 is_closed_on B271 , R2 & B272 is_halting_on B271 , R2) implies (( CurInstr (( R2 +* ( loop B272 ) ) , ( Comput (( R2 +* ( loop B272 ) ) , ( Initialize B271 ) , ( LifeSpan (( R2 +* B272 ) , ( Initialize B271 )) )) )) ) = ( goto ( 0 ) ) & (for B273 being (Element of ( NAT )) holds (B273 <= ( LifeSpan (( R2 +* B272 ) , ( Initialize B271 )) ) implies ( CurInstr (( R2 +* ( loop B272 ) ) , ( Comput (( R2 +* ( loop B272 ) ) , ( Initialize B271 ) , B273) )) ) <> ( halt ( SCM+FSA ) ))))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
L1593: ( dom ( id (the InstructionsF of ( SCM+FSA )) ) ) = (the InstructionsF of ( SCM+FSA ));
let C273 being (State of ( SCM+FSA ));
let C274 being (Program of ( SCM+FSA ));
set D253 = ( Initialize C273 );
set D254 = ( R2 +* C274 );
set D255 = ( Initialize C273 );
set D256 = ( R2 +* ( loop C274 ) );
L1594: C274 c= D254 by FUNCT_4:25;
assume that
L1595: C274 is_closed_on C273 , R2
and
L1596: C274 is_halting_on C273 , R2;
set D257 = ( LifeSpan (D254 , D253) );
L1597: ( IC ( Comput (D254 , D253 , D257) ) ) in ( dom C274 ) by L1595 , SCMFSA7B:def 6;
L1598: ( dom ( loop C274 ) ) = ( dom C274 ) by FUNCT_4:99;
L1599: D254 halts_on D253 by L1596 , SCMFSA7B:def 7;
L1600: ( CurInstr (D254 , ( Comput (D254 , D253 , D257) )) ) = ( halt ( SCM+FSA ) ) by L1599 , EXTPRO_1:def 15;
L1601: ( CurInstr (D254 , ( Comput (D254 , D253 , D257) )) ) = ( D254 . ( IC ( Comput (D254 , D253 , D257) ) ) ) by PBOOLE:143
.= ( C274 . ( IC ( Comput (D254 , D253 , D257) ) ) ) by L1594 , L1597 , GRFUNC_1:2;
L1602: ( rng C274 ) c= (the InstructionsF of ( SCM+FSA )) by RELAT_1:def 19;
L1603: ( D256 /. ( IC ( Comput (D256 , D255 , ( LifeSpan (D254 , D253) )) ) ) ) = ( D256 . ( IC ( Comput (D256 , D255 , ( LifeSpan (D254 , D253) )) ) ) ) by PBOOLE:143;
L1604: ( Comput (( R2 +* C274 ) , ( Initialize C273 ) , D257) ) = ( Comput (( R2 +* ( loop C274 ) ) , ( Initialize C273 ) , D257) ) by L1595 , L1596 , L1555;
thus L1605: ( CurInstr (D256 , ( Comput (D256 , D255 , ( LifeSpan (D254 , D253) )) )) ) = ( D256 . ( IC ( Comput (D254 , D253 , D257) ) ) ) by L1604 , L1603
.= ( ( loop C274 ) . ( IC ( Comput (D254 , D253 , D257) ) ) ) by L1597 , L1598 , FUNCT_4:13
.= ( ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* (( halt ( SCM+FSA ) ) , ( goto ( 0 ) )) ) * C274 ) . ( IC ( Comput (D254 , D253 , D257) ) ) ) by L1602 , FUNCT_7:116
.= ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* (( halt ( SCM+FSA ) ) , ( goto ( 0 ) )) ) . ( halt ( SCM+FSA ) ) ) by L1600 , L1597 , L1601 , FUNCT_1:13
.= ( goto ( 0 ) ) by L1593 , FUNCT_7:31;
let C275 being (Element of ( NAT ));
assume L1606: C275 <= ( LifeSpan (D254 , D253) );
per cases  by L1606 , XXREAL_0:1;
suppose L1607: C275 < ( LifeSpan (D254 , D253) );

L1608: ( CurInstr (D254 , ( Comput (D254 , D253 , C275) )) ) <> ( halt ( SCM+FSA ) ) by L1607 , L1599 , EXTPRO_1:def 15;
thus L1609: thesis by L1608 , L1595 , L1596 , L1607 , L1577;
end;
suppose L1610: C275 = ( LifeSpan (D254 , D253) );

thus L1611: thesis by L1610 , L1605;
end;
end;
theorem
L1613: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B274 being (State of ( SCM+FSA )) holds (for B275 being (Program of ( SCM+FSA )) holds ((B275 is_closed_on B274 , R2 & B275 is_halting_on B274 , R2) implies (for B276 being (Element of ( NAT )) holds (B276 <= ( LifeSpan (( R2 +* B275 ) , ( Initialize B274 )) ) implies ( CurInstr (( R2 +* ( loop B275 ) ) , ( Comput (( R2 +* ( loop B275 ) ) , ( Initialize B274 ) , B276) )) ) <> ( halt ( SCM+FSA ) ))))))) by L1592;
theorem
L1614: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B277 being (State of ( SCM+FSA )) holds (for B278 being (Program of ( SCM+FSA )) holds ((B278 is_closed_on B277 , R2 & B278 is_halting_on B277 , R2) implies ( CurInstr (( R2 +* ( loop B278 ) ) , ( Comput (( R2 +* ( loop B278 ) ) , ( Initialize B277 ) , ( LifeSpan (( R2 +* B278 ) , ( Initialize B277 )) )) )) ) = ( goto ( 0 ) ))))) by L1592;
theorem
L1615: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B279 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B280 being  paraclosed (Program of ( SCM+FSA )) holds ((B280 c= R2 & R2 halts_on B279) implies (for B281 being (Element of ( NAT )) holds (B281 <= ( LifeSpan (R2 , B279) ) implies ( Comput (R2 , B279 , B281) ) = ( Comput (( R2 +* ( loop B280 ) ) , B279 , B281) )))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C276 being ( 0 ) -started (State of ( SCM+FSA ));
let C277 being  paraclosed (Program of ( SCM+FSA ));
assume L1616: C277 c= R2;
defpred S9[ Nat ] means ($1 <= ( LifeSpan (R2 , C276) ) implies ( Comput (R2 , C276 , $1) ) = ( Comput (( R2 +* ( loop C277 ) ) , C276 , $1) ));
assume L1617: R2 halts_on C276;
L1618: (for R1 being (Element of ( NAT )) holds (S9[ R1 ] implies S9[ ( R1 + 1 ) ]))
proof
set D258 = C276;
set D259 = ( R2 +* ( loop C277 ) );
L1619: ( loop C277 ) c= D259 by FUNCT_4:25;
let R1 being (Element of ( NAT ));
assume L1620: (R1 <= ( LifeSpan (R2 , C276) ) implies ( Comput (R2 , C276 , R1) ) = ( Comput (( R2 +* ( loop C277 ) ) , C276 , R1) ));
L1621: ( IC ( Comput (R2 , C276 , R1) ) ) in ( dom C277 ) by L1616 , AMISTD_1:def 10;
L1622: ( IC ( Comput (R2 , C276 , R1) ) ) in ( dom ( loop C277 ) ) by L1621 , FUNCT_4:99;
L1623: ( R2 /. ( IC ( Comput (R2 , C276 , R1) ) ) ) = ( R2 . ( IC ( Comput (R2 , C276 , R1) ) ) ) by PBOOLE:143;
L1624: ( CurInstr (R2 , ( Comput (R2 , C276 , R1) )) ) = ( C277 . ( IC ( Comput (R2 , C276 , R1) ) ) ) by L1621 , L1623 , L1616 , GRFUNC_1:2;
L1625: ( Comput (D259 , D258 , ( R1 + 1 )) ) = ( Following (D259 , ( Comput (D259 , D258 , R1) )) ) by EXTPRO_1:3;
L1626: ( Comput (R2 , C276 , ( R1 + 1 )) ) = ( Following (R2 , ( Comput (R2 , C276 , R1) )) ) by EXTPRO_1:3;
L1627: ( D259 /. ( IC ( Comput (D259 , D258 , R1) ) ) ) = ( D259 . ( IC ( Comput (D259 , D258 , R1) ) ) ) by PBOOLE:143;
assume L1628: ( R1 + 1 ) <= ( LifeSpan (R2 , C276) );
L1629: R1 < ( LifeSpan (R2 , C276) ) by L1628 , NAT_1:13;
L1630: ( C277 . ( IC ( Comput (R2 , C276 , R1) ) ) ) <> ( halt ( SCM+FSA ) ) by L1629 , L1617 , L1624 , EXTPRO_1:def 15;
L1631: ( CurInstr (R2 , ( Comput (R2 , C276 , R1) )) ) = ( ( loop C277 ) . ( IC ( Comput (R2 , C276 , R1) ) ) ) by L1630 , L1624 , FUNCT_4:105
.= ( D259 . ( IC ( Comput (R2 , C276 , R1) ) ) ) by L1622 , L1619 , GRFUNC_1:2
.= ( CurInstr (D259 , ( Comput (D259 , D258 , R1) )) ) by L1620 , L1628 , L1627 , NAT_1:13;
thus L1632: thesis by L1631 , L1620 , L1628 , L1626 , L1625 , NAT_1:13;
end;
L1633: S9[ ( 0 ) ];
thus L1634: (for B282 being (Element of ( NAT )) holds S9[ B282 ]) from NAT_1:sch 1(L1633 , L1618);
end;
theorem
L1635: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B283 being (State of ( SCM+FSA )) holds (for B284 being  parahalting (Program of ( SCM+FSA )) holds ((( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= B283 & B284 c= R2) implies (for B285 being (Element of ( NAT )) holds (B285 <= ( LifeSpan (R2 , B283) ) implies ( CurInstr (( R2 +* ( loop B284 ) ) , ( Comput (( R2 +* ( loop B284 ) ) , B283 , B285) )) ) <> ( halt ( SCM+FSA ) )))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C278 being (State of ( SCM+FSA ));
let C279 being  parahalting (Program of ( SCM+FSA ));
set D260 = C278;
set D261 = ( R2 +* ( loop C279 ) );
assume L1636: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= C278;
L1637: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCT_4:25;
L1638: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C278 by L1637 , L1636 , XBOOLE_1:1;
L1639: C278 is ( 0 ) -started by L1638 , MEMSTR_0:29;
reconsider D262 = C278 as ( 0 ) -started (State of ( SCM+FSA )) by L1639;
assume L1640: C279 c= R2;
L1641: R2 halts_on C278 by L1640 , L1639 , AMISTD_1:def 11;
let C280 being (Element of ( NAT ));
assume L1642: C280 <= ( LifeSpan (R2 , C278) );
set D263 = ( IC ( Comput (R2 , C278 , C280) ) );
assume L1643: ( CurInstr (( R2 +* ( loop C279 ) ) , ( Comput (( R2 +* ( loop C279 ) ) , C278 , C280) )) ) = ( halt ( SCM+FSA ) );
L1644: ( dom C279 ) = ( dom ( loop C279 ) ) by FUNCT_4:99;
L1645: ( IC ( Comput (R2 , D262 , C280) ) ) in ( dom C279 ) by L1640 , AMISTD_1:def 10;
L1646: ( ( loop C279 ) . D263 ) in ( rng ( loop C279 ) ) by L1645 , L1644 , FUNCT_1:def 3;
L1647: ( D261 /. ( IC ( Comput (D261 , D260 , C280) ) ) ) = ( D261 . ( IC ( Comput (D261 , D260 , C280) ) ) ) by PBOOLE:143;
L1648: ( Comput (R2 , D262 , C280) ) = ( Comput (( R2 +* ( loop C279 ) ) , D262 , C280) ) by L1641 , L1642 , L1615 , L1640;
L1649: ( CurInstr (D261 , ( Comput (D261 , D260 , C280) )) ) = ( D261 . D263 ) by L1648 , L1647
.= ( ( loop C279 ) . D263 ) by L1645 , L1644 , FUNCT_4:13;
thus L1650: contradiction by L1649 , L1643 , L1646 , L1554;
end;
begin
definition
let C281 being Int-Location;
let C282 being (Program of ( SCM+FSA ));
func Times (C281 , C282) -> (Program of ( SCM+FSA )) equals 
( if>0 (C281 , ( loop ( if=0 (C281 , ( Goto 2 ) , ( C282 ";" ( SubFrom (C281 , ( intloc ( 0 ) )) ) )) ) ) , ( Stop ( SCM+FSA ) )) );
correctness;
end;
registration
let C283 being Int-Location;
let C284 being (Program of ( SCM+FSA ));
cluster ( Times (C283 , C284) ) -> non  halt-free;
coherence;
end;
theorem
L1653: (for B286 being  good (Program of ( SCM+FSA )) holds (for B287 being  read-write Int-Location holds ( if=0 (B287 , ( Goto 2 ) , ( B286 ";" ( SubFrom (B287 , ( intloc ( 0 ) )) ) )) ) is  good))
proof
let C285 being  good (Program of ( SCM+FSA ));
let C286 being  read-write Int-Location;
reconsider D264 = ( Macro ( SubFrom (C286 , ( intloc ( 0 ) )) ) ) as  good (Program of ( SCM+FSA )) by L1483 , SCMFSA7B:8;
L1654: ( C285 ";" ( SubFrom (C286 , ( intloc ( 0 ) )) ) ) = ( C285 ";" D264 );
reconsider D265 = ( C285 ";" ( SubFrom (C286 , ( intloc ( 0 ) )) ) ) as  good (Program of ( SCM+FSA )) by L1654;
reconsider D266 = ( Macro ( C286 =0_goto ( ( card D265 ) + 3 ) ) ) as  good (Program of ( SCM+FSA )) by L1483 , SCMFSA7B:12;
L1655: ( if=0 (C286 , ( Goto 2 ) , D265) ) = ( ( ( ( ( C286 =0_goto ( ( card D265 ) + 3 ) ) ";" D265 ) ";" ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ";" ( Goto 2 ) ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1
.= ( ( ( ( D266 ";" D265 ) ";" ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ";" ( Goto 2 ) ) ";" ( Stop ( SCM+FSA ) ) );
thus L1656: thesis by L1655;
end;
theorem
L1657: (for B288 , B289 being (Program of ( SCM+FSA )) holds (for B290 being Int-Location holds ( ( if=0 (B290 , ( Goto 2 ) , ( B288 ";" ( SubFrom (B290 , ( intloc ( 0 ) )) ) )) ) . ( ( card ( B288 ";" ( SubFrom (B290 , ( intloc ( 0 ) )) ) ) ) + 3 ) ) = ( goto ( ( card ( B288 ";" ( SubFrom (B290 , ( intloc ( 0 ) )) ) ) ) + 5 ) )))
proof
let C287 , C288 being (Program of ( SCM+FSA ));
let C289 being Int-Location;
set D267 = ( C287 ";" ( SubFrom (C289 , ( intloc ( 0 ) )) ) );
set D268 = ( ( ( C289 =0_goto ( ( card D267 ) + 3 ) ) ";" D267 ) ";" ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) );
set D269 = ( ( ( ( C289 =0_goto ( ( card D267 ) + 3 ) ) ";" D267 ) ";" ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ";" ( Goto 2 ) );
L1658: ( card ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) = 1 by SCMFSA8A:15;
L1659: ( card ( ( C289 =0_goto ( ( card D267 ) + 3 ) ) ";" D267 ) ) = ( ( card ( Macro ( C289 =0_goto ( ( card D267 ) + 3 ) ) ) ) + ( card D267 ) ) by SCMFSA6A:21
.= ( 2 + ( card D267 ) ) by COMPOS_1:56;
L1660: ( card D268 ) = ( ( ( card D267 ) + 2 ) + 1 ) by L1659 , L1658 , SCMFSA6A:21
.= ( ( card D267 ) + ( 2 + 1 ) );
L1661: ( ( ( card D267 ) + ( 2 + 1 ) ) -' ( card D268 ) ) = ( 0 ) by L1660 , XREAL_1:232;
L1662: ( goto 2 ) = ( ( Goto 2 ) . ( ( ( card D267 ) + ( 2 + 1 ) ) -' ( card D268 ) ) ) by L1661 , SCMFSA8A:31;
L1663: ( card ( Goto 2 ) ) = 1 by SCMFSA8A:15;
L1664: ( ( card D267 ) + ( 2 + 1 ) ) < ( ( card D268 ) + ( card ( Goto 2 ) ) ) by L1663 , L1660 , NAT_1:13;
L1665: ( D269 . ( ( card D267 ) + ( 2 + 1 ) ) ) = ( IncAddr (( goto 2 ) , ( card D268 )) ) by L1664 , L1660 , L1662 , L7
.= ( goto ( 2 + ( ( card D267 ) + ( 2 + 1 ) ) ) ) by L1660 , SCMFSA_4:1
.= ( goto ( ( card D267 ) + ( 2 + 3 ) ) );
L1666: ( card D269 ) = ( ( ( card D267 ) + ( 2 + 1 ) ) + 1 ) by L1660 , L1663 , SCMFSA6A:21
.= ( ( card D267 ) + ( ( 2 + 1 ) + 1 ) );
L1667: ( card D269 ) = ( ( ( card D267 ) + 3 ) + 1 ) by L1666;
L1668: ( ( card D267 ) + 3 ) < ( card D269 ) by L1667 , NAT_1:13;
L1669: ( ( card D267 ) + 3 ) in ( dom D269 ) by L1668 , AFINSQ_1:66;
L1670: ( ( D269 ";" ( Stop ( SCM+FSA ) ) ) . ( ( card D267 ) + 3 ) ) = ( ( Directed D269 ) . ( ( card D267 ) + 3 ) ) by L1669 , SCMFSA8A:14
.= ( goto ( ( card D267 ) + 5 ) ) by L1665 , L1669 , SCMFSA8A:16;
thus L1671: thesis by L1670 , SCMFSA8B:def 1;
end;
theorem
L1672: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B291 being (State of ( SCM+FSA )) holds (for B292 being  good  parahalting (Program of ( SCM+FSA )) holds (for B293 being  read-write Int-Location holds (((not B292 destroy B293) & ( B291 . ( intloc ( 0 ) ) ) = 1 & ( B291 . B293 ) > ( 0 )) implies ( loop ( if=0 (B293 , ( Goto 2 ) , ( B292 ";" ( SubFrom (B293 , ( intloc ( 0 ) )) ) )) ) ) is_pseudo-closed_on B291 , R2)))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C290 being (State of ( SCM+FSA ));
let C291 being  good  parahalting (Program of ( SCM+FSA ));
let C292 being  read-write Int-Location;
set D270 = ( if=0 (C292 , ( Goto 2 ) , ( C291 ";" ( SubFrom (C292 , ( intloc ( 0 ) )) ) )) );
reconsider D271 = ( C291 ";" ( SubFrom (C292 , ( intloc ( 0 ) )) ) ) as  parahalting (Program of ( SCM+FSA ));
set D272 = ( C292 =0_goto ( ( card D271 ) + 3 ) );
defpred S10[ Nat ] means (for B294 being (State of ( SCM+FSA )) holds ((( B294 . ( intloc ( 0 ) ) ) = 1 & ( B294 . C292 ) = $1 & ( B294 . C292 ) > ( 0 )) implies (( ( Comput (( R2 +* ( loop D270 ) ) , ( Initialize B294 ) , ( ( LifeSpan (( R2 +* D270 ) , ( Initialize B294 )) ) + 1 )) ) . C292 ) = ( ( B294 . C292 ) - 1 ) & ( ( Comput (( R2 +* ( loop D270 ) ) , ( Initialize B294 ) , ( ( LifeSpan (( R2 +* D270 ) , ( Initialize B294 )) ) + 1 )) ) . ( intloc ( 0 ) ) ) = 1 & (ex B295 being (Element of ( NAT )) st (( IC ( Comput (( R2 +* ( loop D270 ) ) , ( Initialize B294 ) , B295) ) ) = ( card ( loop D270 ) ) & (for B296 being (Element of ( NAT )) holds (B296 < B295 implies ( IC ( Comput (( R2 +* ( loop D270 ) ) , ( Initialize B294 ) , B296) ) ) in ( dom ( loop D270 ) ))))))));
assume L1673: (not C291 destroy C292);
L1674: (for B297 being (Element of ( NAT )) holds (S10[ B297 ] implies S10[ ( B297 + 1 ) ]))
proof
let C293 being (Element of ( NAT ));
assume L1675: S10[ C293 ];
let C294 being (State of ( SCM+FSA ));
assume L1676: ( C294 . ( intloc ( 0 ) ) ) = 1;
set D273 = ( Initialize C294 );
set D274 = ( R2 +* ( loop D270 ) );
set D275 = ( Initialize C294 );
set D276 = ( R2 +* D270 );
L1677: ( loop D270 ) c= D274 by FUNCT_4:25;
assume L1678: ( C294 . C292 ) = ( C293 + 1 );
set D277 = ( Comput (D274 , D273 , ( ( LifeSpan (D276 , D275) ) + 1 )) );
set D278 = D274;
assume L1679: ( C294 . C292 ) > ( 0 );
L1680: ( Comput (D274 , D273 , ( ( LifeSpan (D276 , D275) ) + 1 )) ) = ( Following (D274 , ( Comput (D274 , D273 , ( LifeSpan (D276 , D275) )) )) ) by EXTPRO_1:3;
L1681: D271 is_halting_on C294 , R2 by SCMFSA7B:19;
L1682: D271 is_closed_on C294 , R2 by SCMFSA7B:18;
L1683: D270 is_closed_on C294 , R2 by L1682 , L1679 , L1681 , SCMFSA8B:15;
L1684: D270 is_halting_on C294 , R2 by L1679 , L1682 , L1681 , SCMFSA8B:15;
L1685: D270 is_closed_on C294 , R2 by L1679 , L1682 , L1681 , SCMFSA8B:15;
L1686: ( IC ( Comput (D274 , D273 , ( ( LifeSpan (D276 , D275) ) + 1 )) ) ) = ( ( Exec (( goto ( 0 ) ) , ( Comput (D274 , D273 , ( LifeSpan (D276 , D275) )) )) ) . ( IC ( SCM+FSA ) ) ) by L1685 , L1684 , L1680 , L1592
.= ( 0 ) by SCMFSA_2:69;
L1687: ( Comput (D274 , D273 , ( ( LifeSpan (D276 , D275) ) + 1 )) ) = ( Exec (( goto ( 0 ) ) , ( Comput (D274 , D273 , ( LifeSpan (D276 , D275) )) )) ) by L1685 , L1684 , L1680 , L1592;
L1688:
now
L1689: D271 is_halting_on ( Initialized C294 ) , R2 by SCMFSA7B:19;
L1690: D271 is_closed_on ( Initialized C294 ) , R2 by SCMFSA7B:18;
L1691: ( IExec (D270 , R2 , C294) ) = ( ( IExec (D271 , R2 , C294) ) +* ( Start-At (( ( ( card ( Goto 2 ) ) + ( card D271 ) ) + 3 ) , ( SCM+FSA )) ) ) by L1679 , L1689 , L1690 , SCMFSA8B:16;
L1692: ( ( IExec (D270 , R2 , C294) ) . C292 ) = ( ( IExec (D271 , R2 , C294) ) . C292 ) by L1691 , SCMFSA_3:3;
L1693: ( card D270 ) = ( ( ( card ( Goto 2 ) ) + ( card D271 ) ) + 4 ) by SCMFSA8B:11
.= ( ( ( card D271 ) + 1 ) + 4 ) by SCMFSA8A:15
.= ( ( ( card D271 ) + 3 ) + 2 );
L1694: ( card ( loop D270 ) ) = ( card ( dom ( loop D270 ) ) )
.= ( card ( dom D270 ) ) by FUNCT_4:99
.= ( card D270 );
thus L1695:now
thus L1696: ( 0 ) in ( dom ( loop D270 ) ) by L1694 , AFINSQ_1:66;
L1697: ( ( ( card D271 ) + 3 ) + ( 1 + 1 ) ) = ( ( ( ( card D271 ) + 3 ) + 1 ) + 1 );
L1698: ( ( ( card D271 ) + 3 ) + 1 ) < ( card D270 ) by L1697 , L1693 , NAT_1:13;
L1699: ( ( card D271 ) + 3 ) < ( card ( loop D270 ) ) by L1698 , L1694 , NAT_1:13;
thus L1700: ( ( card D271 ) + 3 ) in ( dom ( loop D270 ) ) by L1699 , AFINSQ_1:66;
end;
thus L1701: ( intloc ( 0 ) ) in ( dom C294 ) by SCMFSA_2:42;
L1702: ( C294 +* D2 ) = C294 by L1701 , L1676 , FUNCT_7:109;
L1703: D271 is_closed_on ( Initialized C294 ) , R2 by SCMFSA7B:18;
L1704: D271 is_halting_on ( Initialized C294 ) , R2 by SCMFSA7B:19;
L1705: ( ( Initialized C294 ) . C292 ) > ( 0 ) by L1679 , SCMFSA_M:37;
L1706: D270 is_halting_on ( Initialized C294 ) , R2 by L1705 , L1703 , L1704 , SCMFSA8B:15;
L1707: D270 is_closed_on ( Initialized C294 ) , R2 by L1705 , L1703 , L1704 , SCMFSA8B:15;
consider C295 being (State of ( SCM+FSA )) such that L1708: C295 = ( Initialize ( Initialized C294 ) );
set D279 = ( R2 +* D270 );
L1709: ( Initialize ( Initialized C294 ) ) = ( Initialize ( Initialized C294 ) )
.= ( ( ( C294 +* ( ( intloc ( 0 ) ) .--> 1 ) ) +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by FUNCT_4:14
.= ( Initialize C294 ) by L1702
.= ( Initialize C294 );
L1710:
now
let C296 being Int-Location;
L1711: ( Comput (( R2 +* D270 ) , ( Initialize C294 ) , ( LifeSpan (D279 , C295) )) ) = ( Comput (( R2 +* ( loop D270 ) ) , ( Initialize C294 ) , ( LifeSpan (D279 , C295) )) ) by L1684 , L1683 , L1709 , L1708 , L1555;
L1712: ( ( Comput (D274 , D273 , ( ( LifeSpan (D276 , D275) ) + 1 )) ) . C296 ) = ( ( Comput (D274 , D273 , ( LifeSpan (D276 , D275) )) ) . C296 ) by L1687 , SCMFSA_2:69;
thus L1713: ( ( Comput (D274 , D273 , ( ( LifeSpan (D276 , D275) ) + 1 )) ) . C296 ) = ( ( Comput (D279 , C295 , ( LifeSpan (D279 , C295) )) ) . C296 ) by L1712 , L1709 , L1708 , L1711;
end;
L1714: ( ( Comput (D274 , D273 , ( ( LifeSpan (D276 , D275) ) + 1 )) ) . C292 ) = ( ( Comput (D279 , C295 , ( LifeSpan (D279 , C295) )) ) . C292 ) by L1710
.= ( ( IExec (D270 , R2 , C294) ) . C292 ) by L1708 , L1706 , L1394;
thus L1715: ( ( Comput (D274 , D273 , ( ( LifeSpan (D276 , D275) ) + 1 )) ) . C292 ) = ( ( Comput (( R2 +* D271 ) , ( ( Initialized C294 ) +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) , ( LifeSpan (( R2 +* D271 ) , ( Initialize ( Initialized C294 ) )) )) ) . C292 ) by L1714 , L1689 , L1692 , L1394
.= ( ( C294 . C292 ) - 1 ) by L1673 , L1478;
L1716: D270 is  good by L1653;
L1717: ( ( Comput (D274 , D273 , ( ( LifeSpan (D276 , D275) ) + 1 )) ) . ( intloc ( 0 ) ) ) = ( ( Comput (D279 , C295 , ( LifeSpan (D279 , C295) )) ) . ( intloc ( 0 ) ) ) by L1710
.= 1 by L1708 , L1706 , L1707 , L1716 , L1456;
thus L1718: ( ( Comput (D274 , D273 , ( ( LifeSpan (D276 , D275) ) + 1 )) ) . ( intloc ( 0 ) ) ) = 1 by L1717;
end;
thus L1719: (( D277 . C292 ) = ( ( C294 . C292 ) - 1 ) & ( D277 . ( intloc ( 0 ) ) ) = 1) by L1688;
L1720:
now
L1721: ( ( Macro D272 ) . ( 0 ) ) <> ( halt ( SCM+FSA ) ) by COMPOS_1:58;
L1722: ( 0 ) in ( dom ( Macro D272 ) ) by COMPOS_1:60;
L1723: D270 = ( ( ( ( D272 ";" D271 ) ";" ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ";" ( Goto 2 ) ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1
.= ( ( ( D272 ";" ( D271 ";" ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ) ";" ( Goto 2 ) ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA6A:29
.= ( ( D272 ";" ( ( D271 ";" ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ";" ( Goto 2 ) ) ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA6A:29
.= ( D272 ";" ( ( ( D271 ";" ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ";" ( Goto 2 ) ) ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:29
.= ( ( Macro D272 ) ";" ( ( ( D271 ";" ( Goto ( ( card ( Goto 2 ) ) + 1 ) ) ) ";" ( Goto 2 ) ) ";" ( Stop ( SCM+FSA ) ) ) );
thus L1724: ( D270 . ( 0 ) ) = ( ( Macro D272 ) . ( 0 ) ) by L1723 , L1722 , L1721 , SCMFSA6A:15
.= D272 by COMPOS_1:58;
thus L1725: ( D270 . ( 0 ) ) <> ( halt ( SCM+FSA ) ) by L1724;
L1726: ( card D270 ) = ( ( ( card ( Goto 2 ) ) + ( card D271 ) ) + 4 ) by SCMFSA8B:11
.= ( ( ( card D271 ) + 1 ) + 4 ) by SCMFSA8A:15
.= ( ( ( card D271 ) + 3 ) + 2 );
thus L1727: ( 0 ) in ( dom D270 ) by L1726 , AFINSQ_1:66;
L1728: ( card ( loop D270 ) ) = ( card ( dom ( loop D270 ) ) )
.= ( card ( dom D270 ) ) by FUNCT_4:99
.= ( card D270 );
L1729: ( card ( loop D270 ) ) = ( ( card D271 ) + ( 3 + 2 ) ) by L1728 , L1726;
thus L1730: ( D270 . ( ( card D271 ) + 3 ) ) = ( goto ( card ( loop D270 ) ) ) by L1729 , L1657;
thus L1731: ( D270 . ( ( card D271 ) + 3 ) ) <> ( halt ( SCM+FSA ) ) by L1730;
thus L1732:now
L1733: ( ( ( card D271 ) + 3 ) + ( 0 ) ) < ( card D270 ) by L1726 , XREAL_1:6;
thus L1734: ( ( card D271 ) + 3 ) in ( dom D270 ) by L1733 , AFINSQ_1:66;
end;
end;
thus L1733:now
per cases ;
suppose L1734: C293 = ( 0 );

take D280 = ( ( ( ( LifeSpan (D276 , D275) ) + 1 ) + 1 ) + 1 );
L1735: ( CurInstr (D274 , ( Comput (D274 , D273 , ( ( LifeSpan (D276 , D275) ) + 1 )) )) ) = ( D274 . ( 0 ) ) by L1686 , PBOOLE:143
.= ( ( loop D270 ) . ( 0 ) ) by L1688 , L1677 , GRFUNC_1:2
.= D272 by L1720 , FUNCT_4:105;
L1736: ( D274 /. ( IC ( Comput (D274 , D273 , ( ( ( LifeSpan (D276 , D275) ) + 1 ) + 1 )) ) ) ) = ( D274 . ( IC ( Comput (D274 , D273 , ( ( ( LifeSpan (D276 , D275) ) + 1 ) + 1 )) ) ) ) by PBOOLE:143;
L1737: ( Comput (D274 , D273 , ( ( ( LifeSpan (D276 , D275) ) + 1 ) + 1 )) ) = ( Following (D274 , ( Comput (D274 , D273 , ( ( LifeSpan (D276 , D275) ) + 1 )) )) ) by EXTPRO_1:3
.= ( Exec (D272 , ( Comput (D274 , D273 , ( ( LifeSpan (D276 , D275) ) + 1 )) )) ) by L1735;
L1738: ( CurInstr (D274 , ( Comput (D274 , D273 , ( ( ( LifeSpan (D276 , D275) ) + 1 ) + 1 )) )) ) = ( D274 . ( ( card D271 ) + 3 ) ) by L1737 , L1736 , L1678 , L1688 , L1734 , SCMFSA_2:70
.= ( ( loop D270 ) . ( ( card D271 ) + 3 ) ) by L1688 , L1677 , GRFUNC_1:2
.= ( goto ( card ( loop D270 ) ) ) by L1720 , FUNCT_4:105;
L1739: ( Comput (D274 , D273 , D280) ) = ( Following (D274 , ( Comput (D274 , D273 , ( ( ( LifeSpan (D276 , D275) ) + 1 ) + 1 )) )) ) by EXTPRO_1:3
.= ( Exec (( goto ( card ( loop D270 ) ) ) , ( Comput (D274 , D273 , ( ( ( LifeSpan (D276 , D275) ) + 1 ) + 1 )) )) ) by L1738;
thus L1740: ( IC ( Comput (D274 , D273 , D280) ) ) = ( card ( loop D270 ) ) by L1739 , SCMFSA_2:69;
thus L1741:now
let C297 being (Element of ( NAT ));
assume L1742: C297 < D280;
L1743: C297 <= ( ( ( LifeSpan (D276 , D275) ) + 1 ) + 1 ) by L1742 , NAT_1:13;
L1744: (C297 <= ( ( LifeSpan (D276 , D275) ) + 1 ) or C297 = ( ( ( LifeSpan (D276 , D275) ) + 1 ) + 1 )) by L1743 , NAT_1:8;
per cases  by L1744 , NAT_1:8;
suppose L1745: C297 <= ( LifeSpan (D276 , D275) );

L1746: D271 is_halting_on C294 , R2 by SCMFSA7B:19;
L1747: D271 is_closed_on C294 , R2 by SCMFSA7B:18;
L1748: D270 is_closed_on C294 , R2 by L1747 , L1679 , L1746 , SCMFSA8B:15;
L1749: D270 is_halting_on C294 , R2 by L1679 , L1747 , L1746 , SCMFSA8B:15;
L1750: ( Comput (D276 , D275 , C297) ) = ( Comput (D274 , D273 , C297) ) by L1749 , L1745 , L1748 , L1555;
L1751: ( IC ( Comput (D274 , D273 , C297) ) ) = ( IC ( Comput (D276 , D275 , C297) ) ) by L1750;
L1752: ( IC ( Comput (D276 , D275 , C297) ) ) in ( dom D270 ) by L1748 , SCMFSA7B:def 6;
thus L1753: ( IC ( Comput (D274 , D273 , C297) ) ) in ( dom ( loop D270 ) ) by L1752 , L1751 , FUNCT_4:99;
end;
suppose L1754: C297 = ( ( LifeSpan (D276 , D275) ) + 1 );

thus L1755: ( IC ( Comput (D274 , D273 , C297) ) ) in ( dom ( loop D270 ) ) by L1754 , L1686 , L1688;
end;
suppose L1756: C297 = ( ( ( LifeSpan (D276 , D275) ) + 1 ) + 1 );

thus L1757: ( IC ( Comput (D274 , D273 , C297) ) ) in ( dom ( loop D270 ) ) by L1756 , L1678 , L1688 , L1734 , L1737 , SCMFSA_2:70;
end;
end;
end;
suppose L1742: C293 > ( 0 );

consider C298 being (State of ( SCM+FSA )) such that L1743: C298 = ( Initialized D277 );
L1744: ( Initialize ( Initialized D277 ) ) = ( D277 +* ( ( IC ( SCM+FSA ) ) .--> ( 0 ) ) ) by L1686 , L1688 , SCMFSA_M:8;
L1745: ( C298 . ( intloc ( 0 ) ) ) = 1 by L1743 , SCMFSA_M:9;
L1746: ( C298 . C292 ) = C293 by L1678 , L1688 , L1743 , SCMFSA_M:37;
consider C299 being (Element of ( NAT )) such that L1747: ( IC ( Comput (( D278 +* ( loop D270 ) ) , ( Initialize C298 ) , C299) ) ) = ( card ( loop D270 ) ) and L1748: (for B298 being (Element of ( NAT )) holds (B298 < C299 implies ( IC ( Comput (( D278 +* ( loop D270 ) ) , ( Initialize C298 ) , B298) ) ) in ( dom ( loop D270 ) ))) by L1746 , L1675 , L1742 , L1745;
take D281 = ( ( ( LifeSpan (D276 , D275) ) + 1 ) + C299 );
L1749: ( IC ( SCM+FSA ) ) in ( dom D277 ) by MEMSTR_0:2;
L1750: ( Initialize ( Initialized D277 ) ) = ( D277 +* ( ( IC ( SCM+FSA ) ) .--> ( 0 ) ) ) by L1744
.= ( D277 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) )
.= D277 by L1686 , L1749 , FUNCT_7:109;
thus L1751: ( IC ( Comput (D274 , D273 , D281) ) ) = ( card ( loop D270 ) ) by L1743 , L1747 , L1750 , EXTPRO_1:4;
thus L1752:now
let C300 being (Element of ( NAT ));
assume L1753: C300 < D281;
L1754: D271 is_halting_on C294 , R2 by SCMFSA7B:19;
L1755: D271 is_closed_on C294 , R2 by SCMFSA7B:18;
L1756: D270 is_closed_on C294 , R2 by L1755 , L1679 , L1754 , SCMFSA8B:15;
L1757: D270 is_halting_on C294 , R2 by L1679 , L1755 , L1754 , SCMFSA8B:15;
per cases  by NAT_1:13;
suppose L1758: C300 <= ( LifeSpan (D276 , D275) );

L1759: ( Comput (D276 , D275 , C300) ) = ( Comput (D274 , D273 , C300) ) by L1758 , L1756 , L1757 , L1555;
L1760: ( IC ( Comput (D274 , D273 , C300) ) ) = ( IC ( Comput (D276 , D275 , C300) ) ) by L1759;
L1761: ( IC ( Comput (D276 , D275 , C300) ) ) in ( dom D270 ) by L1756 , SCMFSA7B:def 6;
thus L1762: ( IC ( Comput (D274 , D273 , C300) ) ) in ( dom ( loop D270 ) ) by L1761 , L1760 , FUNCT_4:99;
end;
suppose L1763: ( ( LifeSpan (D276 , D275) ) + 1 ) <= C300;

consider C301 being (Element of ( NAT )) such that L1764: C301 = ( C300 -' ( ( LifeSpan (D276 , D275) ) + 1 ) );
L1765: ( C300 - ( ( LifeSpan (D276 , D275) ) + 1 ) ) >= ( 0 ) by L1763 , XREAL_1:48;
L1766: C301 = ( C300 - ( ( LifeSpan (D276 , D275) ) + 1 ) ) by L1765 , L1764 , XREAL_0:def 2;
L1767: ( C301 + ( ( LifeSpan (D276 , D275) ) + 1 ) ) = C300 by L1763 , L1764 , XREAL_1:235;
L1768: ( IC ( Comput (D274 , D273 , C300) ) ) = ( IC ( Comput (D274 , D277 , C301) ) ) by L1767 , EXTPRO_1:4;
L1769: C299 = ( D281 - ( ( LifeSpan (D276 , D275) ) + 1 ) );
L1770: C301 < C299 by L1769 , L1753 , L1766 , XREAL_1:9;
thus L1771: ( IC ( Comput (D274 , D273 , C300) ) ) in ( dom ( loop D270 ) ) by L1770 , L1743 , L1748 , L1750 , L1768;
end;
end;
end;
end;
end;
assume L1734: ( C290 . ( intloc ( 0 ) ) ) = 1;
assume L1735: ( C290 . C292 ) > ( 0 );
reconsider D282 = ( C290 . C292 ) as (Element of ( NAT )) by L1735 , INT_1:3;
L1736: S10[ ( 0 ) ];
L1737: (for B299 being (Element of ( NAT )) holds S10[ B299 ]) from NAT_1:sch 1(L1736 , L1674);
L1738: S10[ D282 ] by L1737;
L1739: (ex B300 being (Element of ( NAT )) st (( IC ( Comput (( R2 +* ( loop D270 ) ) , ( Initialize C290 ) , B300) ) ) = ( card ( loop D270 ) ) & (for B301 being (Element of ( NAT )) holds (B301 < B300 implies ( IC ( Comput (( R2 +* ( loop D270 ) ) , ( Initialize C290 ) , B301) ) ) in ( dom ( loop D270 ) ))))) by L1738 , L1734 , L1735;
thus L1740: thesis by L1739 , SCMFSA8A:def 2;
end;
theorem
L1741: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B302 being (State of ( SCM+FSA )) holds (for B303 being  good  parahalting (Program of ( SCM+FSA )) holds (for B304 being  read-write Int-Location holds (((not B303 destroy B304) & ( B302 . B304 ) > ( 0 )) implies ( loop ( if=0 (B304 , ( Goto 2 ) , ( B303 ";" ( SubFrom (B304 , ( intloc ( 0 ) )) ) )) ) ) is_pseudo-closed_on ( Initialized B302 ) , R2)))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C302 being (State of ( SCM+FSA ));
let C303 being  good  parahalting (Program of ( SCM+FSA ));
let C304 being  read-write Int-Location;
assume L1742: (not C303 destroy C304);
L1743: ( ( Initialized C302 ) . C304 ) = ( C302 . C304 ) by SCMFSA_M:37;
L1744: ( ( Initialized C302 ) . ( intloc ( 0 ) ) ) = 1 by SCMFSA_M:9;
assume L1745: ( C302 . C304 ) > ( 0 );
thus L1746: thesis by L1745 , L1742 , L1743 , L1744 , L1672;
end;
theorem
L1747: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B305 being (State of ( SCM+FSA )) holds (for B306 being  good  parahalting (Program of ( SCM+FSA )) holds (for B307 being  read-write Int-Location holds (((not B306 destroy B307) & ( B305 . ( intloc ( 0 ) ) ) = 1) implies (( Times (B307 , B306) ) is_closed_on B305 , R2 & ( Times (B307 , B306) ) is_halting_on B305 , R2))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C305 being (State of ( SCM+FSA ));
let C306 being  good  parahalting (Program of ( SCM+FSA ));
let C307 being  read-write Int-Location;
assume L1748: (not C306 destroy C307);
assume L1749: ( C305 . ( intloc ( 0 ) ) ) = 1;
per cases ;
suppose L1750: ( C305 . C307 ) > ( 0 );

L1751: ( Directed ( loop ( if=0 (C307 , ( Goto 2 ) , ( C306 ";" ( SubFrom (C307 , ( intloc ( 0 ) )) ) )) ) ) ) = ( loop ( if=0 (C307 , ( Goto 2 ) , ( C306 ";" ( SubFrom (C307 , ( intloc ( 0 ) )) ) )) ) ) by SCMFSA6A:22;
L1752: ( Directed ( loop ( if=0 (C307 , ( Goto 2 ) , ( C306 ";" ( SubFrom (C307 , ( intloc ( 0 ) )) ) )) ) ) ) is_pseudo-closed_on C305 , R2 by L1751 , L1748 , L1749 , L1750 , L1672;
thus L1753: thesis by L1752 , L1750 , L709;
end;
suppose L1754: ( C305 . C307 ) <= ( 0 );

L1755: ( Stop ( SCM+FSA ) ) is_halting_on C305 , R2 by SCMFSA7B:19;
L1756: ( Stop ( SCM+FSA ) ) is_closed_on C305 , R2 by SCMFSA7B:18;
thus L1757: thesis by L1756 , L1754 , L1755 , SCMFSA8B:21;
end;
end;
theorem
L1759: (for B308 being  good  parahalting (Program of ( SCM+FSA )) holds (for B309 being  read-write Int-Location holds ((not B308 destroy B309) implies ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) is ( Times (B309 , B308) ) -halted)))
proof
let C308 being  good  parahalting (Program of ( SCM+FSA ));
let C309 being  read-write Int-Location;
assume L1760: (not C308 destroy C309);
L1761:
now
let C310 being (State of ( SCM+FSA ));
let C311 being (Instruction-Sequence of ( SCM+FSA ));
per cases ;
suppose L1762: ( C310 . C309 ) > ( 0 );

L1763: ( ( Initialized C310 ) . C309 ) > ( 0 ) by L1762 , SCMFSA_M:37;
L1764: ( Directed ( loop ( if=0 (C309 , ( Goto 2 ) , ( C308 ";" ( SubFrom (C309 , ( intloc ( 0 ) )) ) )) ) ) ) = ( loop ( if=0 (C309 , ( Goto 2 ) , ( C308 ";" ( SubFrom (C309 , ( intloc ( 0 ) )) ) )) ) ) by SCMFSA6A:22;
L1765: ( ( Initialized C310 ) . ( intloc ( 0 ) ) ) = 1 by SCMFSA_M:9;
L1766: ( Directed ( loop ( if=0 (C309 , ( Goto 2 ) , ( C308 ";" ( SubFrom (C309 , ( intloc ( 0 ) )) ) )) ) ) ) is_pseudo-closed_on ( Initialized C310 ) , C311 by L1765 , L1760 , L1763 , L1764 , L1672;
thus L1767: ( Times (C309 , C308) ) is_halting_on ( Initialized C310 ) , C311 by L1766 , L1763 , L709;
end;
suppose L1768: ( C310 . C309 ) <= ( 0 );

L1769: ( Stop ( SCM+FSA ) ) is_closed_on ( Initialized C310 ) , C311 by SCMFSA7B:18;
L1770: ( Stop ( SCM+FSA ) ) is_halting_on ( Initialized C310 ) , C311 by SCMFSA7B:19;
L1771: ( ( Initialized C310 ) . C309 ) <= ( 0 ) by L1768 , SCMFSA_M:37;
thus L1772: ( Times (C309 , C308) ) is_halting_on ( Initialized C310 ) , C311 by L1771 , L1769 , L1770 , SCMFSA8B:21;
end;
end;
thus L1774: thesis by L1761 , L30;
end;
theorem
L1775: (for B310 , B311 being (Program of ( SCM+FSA )) holds (for B312 , B313 being Int-Location holds (((not B310 destroy B313) & (not B311 destroy B313)) implies ((not ( if=0 (B312 , B310 , B311) ) destroy B313) & (not ( if>0 (B312 , B310 , B311) ) destroy B313)))))
proof
let C312 , C313 being (Program of ( SCM+FSA ));
let C314 , C315 being Int-Location;
assume L1776: (not C312 destroy C315);
L1777: (not ( Goto ( ( card C312 ) + 1 ) ) destroy C315) by L1387;
assume L1778: (not C313 destroy C315);
L1779: (not ( ( C314 =0_goto ( ( card C313 ) + 3 ) ) ";" C313 ) destroy C315) by L1778 , L1364 , SCMFSA7B:12;
L1780: (not ( ( ( C314 =0_goto ( ( card C313 ) + 3 ) ) ";" C313 ) ";" ( Goto ( ( card C312 ) + 1 ) ) ) destroy C315) by L1779 , L1777 , L1358;
L1781: (not ( ( ( ( C314 =0_goto ( ( card C313 ) + 3 ) ) ";" C313 ) ";" ( Goto ( ( card C312 ) + 1 ) ) ) ";" C312 ) destroy C315) by L1780 , L1776 , L1358;
L1782: (not ( Goto ( ( card C312 ) + 1 ) ) destroy C315) by L1387;
L1783: (not ( ( C314 >0_goto ( ( card C313 ) + 3 ) ) ";" C313 ) destroy C315) by L1778 , L1364 , SCMFSA7B:13;
L1784: (not ( ( ( C314 >0_goto ( ( card C313 ) + 3 ) ) ";" C313 ) ";" ( Goto ( ( card C312 ) + 1 ) ) ) destroy C315) by L1783 , L1782 , L1358;
L1785: (not ( ( ( ( C314 >0_goto ( ( card C313 ) + 3 ) ) ";" C313 ) ";" ( Goto ( ( card C312 ) + 1 ) ) ) ";" C312 ) destroy C315) by L1784 , L1776 , L1358;
L1786: ( if=0 (C314 , C312 , C313) ) = ( ( ( ( ( C314 =0_goto ( ( card C313 ) + 3 ) ) ";" C313 ) ";" ( Goto ( ( card C312 ) + 1 ) ) ) ";" C312 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 1;
L1787: (not ( Stop ( SCM+FSA ) ) destroy C315) by L1380;
thus L1788: (not ( if=0 (C314 , C312 , C313) ) destroy C315) by L1787 , L1781 , L1786 , L1358;
L1789: ( if>0 (C314 , C312 , C313) ) = ( ( ( ( ( C314 >0_goto ( ( card C313 ) + 3 ) ) ";" C313 ) ";" ( Goto ( ( card C312 ) + 1 ) ) ) ";" C312 ) ";" ( Stop ( SCM+FSA ) ) ) by SCMFSA8B:def 2;
L1790: (not ( Stop ( SCM+FSA ) ) destroy C315) by L1380;
thus L1791: thesis by L1790 , L1785 , L1789 , L1358;
end;
theorem
L1792: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B314 being (State of ( SCM+FSA )) holds (for B315 being  good  parahalting (Program of ( SCM+FSA )) holds (for B316 being  read-write Int-Location holds (((not B315 destroy B316) & ( B314 . ( intloc ( 0 ) ) ) = 1 & ( B314 . B316 ) > ( 0 )) implies (ex B317 being (State of ( SCM+FSA )) st (ex B318 being (Instruction-Sequence of ( SCM+FSA )) st (ex B319 being (Element of ( NAT )) st (B317 = ( B314 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) & B318 = ( R2 +* ( loop ( if=0 (B316 , ( Goto 2 ) , ( B315 ";" ( SubFrom (B316 , ( intloc ( 0 ) )) ) )) ) ) ) & B319 = ( ( LifeSpan (( R2 +* ( if=0 (B316 , ( Goto 2 ) , ( B315 ";" ( SubFrom (B316 , ( intloc ( 0 ) )) ) )) ) ) , ( B314 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) )) ) + 1 ) & ( ( Comput (B318 , B317 , B319) ) . B316 ) = ( ( B314 . B316 ) - 1 ) & ( ( Comput (B318 , B317 , B319) ) . ( intloc ( 0 ) ) ) = 1 & (for B320 being  read-write Int-Location holds (B320 <> B316 implies ( ( Comput (B318 , B317 , B319) ) . B320 ) = ( ( IExec (B315 , R2 , B314) ) . B320 ))) & (for B321 being FinSeq-Location holds ( ( Comput (B318 , B317 , B319) ) . B321 ) = ( ( IExec (B315 , R2 , B314) ) . B321 )) & ( IC ( Comput (B318 , B317 , B319) ) ) = ( 0 ) & (for B322 being (Element of ( NAT )) holds (B322 <= B319 implies ( IC ( Comput (B318 , B317 , B322) ) ) in ( dom ( loop ( if=0 (B316 , ( Goto 2 ) , ( B315 ";" ( SubFrom (B316 , ( intloc ( 0 ) )) ) )) ) ) ))))))))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C316 being (State of ( SCM+FSA ));
let C317 being  good  parahalting (Program of ( SCM+FSA ));
let C318 being  read-write Int-Location;
assume L1793: (not C317 destroy C318);
reconsider D283 = ( C317 ";" ( SubFrom (C318 , ( intloc ( 0 ) )) ) ) as  parahalting (Program of ( SCM+FSA ));
set D284 = ( if=0 (C318 , ( Goto 2 ) , ( C317 ";" ( SubFrom (C318 , ( intloc ( 0 ) )) ) )) );
set D285 = ( Initialize C316 );
set D286 = ( R2 +* D284 );
L1794: D283 is_halting_on C316 , R2 by SCMFSA7B:19;
set D287 = ( Initialize ( Initialized C316 ) );
set D288 = ( R2 +* D284 );
L1795: ( intloc ( 0 ) ) in ( dom C316 ) by SCMFSA_2:42;
assume L1796: ( C316 . ( intloc ( 0 ) ) ) = 1;
L1797: ( C316 +* D2 ) = C316 by L1796 , L1795 , FUNCT_7:109;
L1798: D283 is_closed_on ( Initialized C316 ) , R2 by SCMFSA7B:18;
L1799: D283 is_halting_on ( Initialized C316 ) , R2 by SCMFSA7B:19;
assume L1800: ( C316 . C318 ) > ( 0 );
L1801: ( ( Initialized C316 ) . C318 ) > ( 0 ) by L1800 , SCMFSA_M:37;
L1802: D284 is_halting_on ( Initialized C316 ) , R2 by L1801 , L1798 , L1799 , SCMFSA8B:15;
L1803: D284 is_closed_on ( Initialized C316 ) , R2 by L1801 , L1798 , L1799 , SCMFSA8B:15;
take D289 = ( Initialize C316 );
take D290 = ( R2 +* ( loop D284 ) );
reconsider D291 = ( ( LifeSpan (D286 , D285) ) + 1 ) as (Element of ( NAT ));
take D291;
thus L1804: D289 = ( C316 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) );
thus L1805: D290 = ( R2 +* ( loop ( if=0 (C318 , ( Goto 2 ) , ( C317 ";" ( SubFrom (C318 , ( intloc ( 0 ) )) ) )) ) ) );
thus L1806: D291 = ( ( LifeSpan (( R2 +* ( if=0 (C318 , ( Goto 2 ) , ( C317 ";" ( SubFrom (C318 , ( intloc ( 0 ) )) ) )) ) ) , ( C316 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) )) ) + 1 );
L1807: ( Initialize ( Initialized C316 ) ) = ( ( ( C316 +* ( ( intloc ( 0 ) ) .--> 1 ) ) +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by FUNCT_4:14
.= ( C316 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L1797;
L1808: D283 is_halting_on ( Initialized C316 ) , R2 by SCMFSA7B:19;
L1809: D283 is_closed_on ( Initialized C316 ) , R2 by SCMFSA7B:18;
L1810: ( IExec (D284 , R2 , C316) ) = ( ( IExec (D283 , R2 , C316) ) +* ( Start-At (( ( ( card ( Goto 2 ) ) + ( card D283 ) ) + 3 ) , ( SCM+FSA )) ) ) by L1800 , L1808 , L1809 , SCMFSA8B:16;
L1811: ( ( IExec (D284 , R2 , C316) ) . C318 ) = ( ( IExec (D283 , R2 , C316) ) . C318 ) by L1810 , SCMFSA_3:3;
L1812: D283 is_closed_on C316 , R2 by SCMFSA7B:18;
L1813: D284 is_closed_on C316 , R2 by L1812 , L1800 , L1794 , SCMFSA8B:15;
L1814: D284 is_halting_on C316 , R2 by L1800 , L1812 , L1794 , SCMFSA8B:15;
L1815: ( Comput (D290 , D289 , ( ( LifeSpan (D286 , D285) ) + 1 )) ) = ( Following (D290 , ( Comput (D290 , D289 , ( LifeSpan (D286 , D285) )) )) ) by EXTPRO_1:3;
L1816: ( Comput (D290 , D289 , ( ( LifeSpan (D286 , D285) ) + 1 )) ) = ( Exec (( goto ( 0 ) ) , ( Comput (D290 , D289 , ( LifeSpan (D286 , D285) )) )) ) by L1815 , L1813 , L1814 , L1592;
L1817: ( Comput (( R2 +* D284 ) , ( Initialize C316 ) , ( LifeSpan (D288 , D287) )) ) = ( Comput (( R2 +* ( loop D284 ) ) , ( Initialize C316 ) , ( LifeSpan (D288 , D287) )) ) by L1813 , L1814 , L1807 , L1555;
L1818: (for B323 being Int-Location holds ( ( Comput (D290 , D289 , ( ( LifeSpan (D286 , D285) ) + 1 )) ) . B323 ) = ( ( Comput (D288 , D287 , ( LifeSpan (D288 , D287) )) ) . B323 )) by L1807 , L1817 , L1816 , SCMFSA_2:69;
L1819: ( ( Comput (D290 , D289 , ( ( LifeSpan (D286 , D285) ) + 1 )) ) . C318 ) = ( ( Comput (D288 , D287 , ( LifeSpan (D288 , D287) )) ) . C318 ) by L1818
.= ( ( IExec (D284 , R2 , C316) ) . C318 ) by L1802 , L1394;
thus L1820: ( ( Comput (D290 , D289 , D291) ) . C318 ) = ( ( Comput (( R2 +* D283 ) , ( Initialize ( Initialized C316 ) ) , ( LifeSpan (( R2 +* D283 ) , ( Initialize ( Initialized C316 ) )) )) ) . C318 ) by L1819 , L1808 , L1811 , L1394
.= ( ( C316 . C318 ) - 1 ) by L1793 , L1478;
L1821: D284 is  good by L1653;
L1822: ( ( Comput (D290 , D289 , ( ( LifeSpan (D286 , D285) ) + 1 )) ) . ( intloc ( 0 ) ) ) = ( ( Comput (D288 , D287 , ( LifeSpan (D288 , D287) )) ) . ( intloc ( 0 ) ) ) by L1818
.= 1 by L1802 , L1803 , L1821 , L1456;
thus L1823: ( ( Comput (D290 , D289 , D291) ) . ( intloc ( 0 ) ) ) = 1 by L1822;
thus L1824:now
let C319 being  read-write Int-Location;
assume L1825: C319 <> C318;
thus L1826: ( ( Comput (D290 , D289 , D291) ) . C319 ) = ( ( Comput (D288 , D287 , ( LifeSpan (D288 , D287) )) ) . C319 ) by L1818
.= ( ( IExec (D284 , R2 , C316) ) . C319 ) by L1802 , L1394
.= ( ( IExec (D283 , R2 , C316) ) . C319 ) by L1810 , SCMFSA_3:3
.= ( ( Exec (( SubFrom (C318 , ( intloc ( 0 ) )) ) , ( IExec (C317 , R2 , C316) )) ) . C319 ) by SCMFSA6C:6
.= ( ( IExec (C317 , R2 , C316) ) . C319 ) by L1825 , SCMFSA_2:65;
end;
thus L1827:now
let C320 being FinSeq-Location;
L1828: ( ( Comput (D290 , D289 , ( ( LifeSpan (D286 , D285) ) + 1 )) ) . C320 ) = ( ( Comput (D290 , D289 , ( LifeSpan (D286 , D285) )) ) . C320 ) by L1816 , SCMFSA_2:69;
thus L1829: ( ( Comput (D290 , D289 , D291) ) . C320 ) = ( ( Comput (D288 , D287 , ( LifeSpan (D288 , D287) )) ) . C320 ) by L1828 , L1807 , L1817
.= ( ( IExec (D284 , R2 , C316) ) . C320 ) by L1802 , L1394
.= ( ( IExec (D283 , R2 , C316) ) . C320 ) by L1810 , SCMFSA_3:4
.= ( ( Exec (( SubFrom (C318 , ( intloc ( 0 ) )) ) , ( IExec (C317 , R2 , C316) )) ) . C320 ) by SCMFSA6C:7
.= ( ( IExec (C317 , R2 , C316) ) . C320 ) by SCMFSA_2:65;
end;
L1830: ( IC ( Comput (D290 , D289 , ( ( LifeSpan (D286 , D285) ) + 1 )) ) ) = ( ( Exec (( goto ( 0 ) ) , ( Comput (D290 , D289 , ( LifeSpan (D286 , D285) )) )) ) . ( IC ( SCM+FSA ) ) ) by L1813 , L1814 , L1815 , L1592
.= ( 0 ) by SCMFSA_2:69;
thus L1831: ( IC ( Comput (D290 , D289 , D291) ) ) = ( 0 ) by L1830;
let C321 being (Element of ( NAT ));
assume L1832: C321 <= D291;
per cases  by L1832 , NAT_1:8;
suppose L1833: C321 <= ( LifeSpan (D286 , D285) );

L1834: D283 is_halting_on C316 , R2 by SCMFSA7B:19;
L1835: D283 is_closed_on C316 , R2 by SCMFSA7B:18;
L1836: D284 is_closed_on C316 , R2 by L1835 , L1800 , L1834 , SCMFSA8B:15;
L1837: D284 is_halting_on C316 , R2 by L1800 , L1835 , L1834 , SCMFSA8B:15;
L1838: ( Comput (D286 , D285 , C321) ) = ( Comput (D290 , D289 , C321) ) by L1837 , L1833 , L1836 , L1555;
L1839: ( IC ( Comput (D290 , D289 , C321) ) ) = ( IC ( Comput (D286 , D285 , C321) ) ) by L1838;
L1840: ( IC ( Comput (D286 , D285 , C321) ) ) in ( dom D284 ) by L1836 , SCMFSA7B:def 6;
thus L1841: ( IC ( Comput (D290 , D289 , C321) ) ) in ( dom ( loop D284 ) ) by L1840 , L1839 , FUNCT_4:99;
end;
suppose L1842: C321 = ( ( LifeSpan (D286 , D285) ) + 1 );

L1843: ( card ( loop D284 ) ) = ( card ( dom ( loop D284 ) ) )
.= ( card ( dom D284 ) ) by FUNCT_4:99
.= ( card D284 );
thus L1844: ( IC ( Comput (D290 , D289 , C321) ) ) in ( dom ( loop D284 ) ) by L1843 , L1830 , L1842 , AFINSQ_1:66;
end;
end;
theorem
L1846: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B324 being (State of ( SCM+FSA )) holds (for B325 being  good  parahalting (Program of ( SCM+FSA )) holds (for B326 being  read-write Int-Location holds ((( B324 . ( intloc ( 0 ) ) ) = 1 & ( B324 . B326 ) <= ( 0 )) implies ( DataPart ( IExec (( Times (B326 , B325) ) , R2 , B324) ) ) = ( DataPart B324 ))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C322 being (State of ( SCM+FSA ));
set D292 = ( Data-Locations ( SCM+FSA ) );
let C323 being  good  parahalting (Program of ( SCM+FSA ));
let C324 being  read-write Int-Location;
assume L1847: ( C322 . ( intloc ( 0 ) ) ) = 1;
set D293 = ( Initialized C322 );
L1848: ( Stop ( SCM+FSA ) ) is_halting_on ( Initialized C322 ) , R2 by SCMFSA7B:19;
assume L1849: ( C322 . C324 ) <= ( 0 );
L1850: ( ( Initialized C322 ) . C324 ) <= ( 0 ) by L1849 , SCMFSA_M:37;
L1851: ( IExec (( ( Stop ( SCM+FSA ) ) ";" ( Stop ( SCM+FSA ) ) ) , R2 , D293) ) = ( IncIC (( IExec (( Stop ( SCM+FSA ) ) , R2 , ( IExec (( Stop ( SCM+FSA ) ) , R2 , D293) )) ) , ( card ( Stop ( SCM+FSA ) ) )) ) by SCMFSA6B:20;
L1852: ( D293 . ( intloc ( 0 ) ) ) = 1 by SCMFSA_M:9;
L1853: ( Stop ( SCM+FSA ) ) is_closed_on ( Initialized C322 ) , R2 by SCMFSA7B:18;
L1854: ( Stop ( SCM+FSA ) ) is_halting_on D293 , R2 by SCMFSA7B:19;
L1855: ( DataPart ( IExec (( Stop ( SCM+FSA ) ) , R2 , D293) ) ) = ( DataPart ( Initialized D293 ) ) by L48
.= ( DataPart D293 );
L1856: (for B327 being (Program of ( SCM+FSA )) holds ((B327 is_closed_on D293 , R2 & B327 is_halting_on D293 , R2) implies ( Directed B327 ) is_pseudo-closed_on D293 , R2)) by SCMFSA8A:23;
L1857: ( Directed ( Stop ( SCM+FSA ) ) ) is_pseudo-closed_on D293 , R2 by L1856 , L1853 , L1854;
L1858: ( DataPart ( IExec (( Times (C324 , C323) ) , R2 , C322) ) ) = ( DataPart ( IExec (( Times (C324 , C323) ) , R2 , D293) ) )
.= ( DataPart ( IExec (( ( Stop ( SCM+FSA ) ) ";" ( Stop ( SCM+FSA ) ) ) , R2 , D293) ) ) by L1850 , L1852 , L1212 , L1857;
thus L1859: ( DataPart ( IExec (( Times (C324 , C323) ) , R2 , C322) ) ) = ( DataPart ( IExec (( Stop ( SCM+FSA ) ) , R2 , ( IExec (( Stop ( SCM+FSA ) ) , R2 , D293) )) ) ) by L1858 , L1851 , MEMSTR_0:79
.= ( DataPart ( IExec (( Stop ( SCM+FSA ) ) , R2 , D293) ) ) by L1853 , L1848 , L1852 , L1855 , L162
.= ( DataPart C322 ) by L1847 , L1855 , SCMFSA_M:19;
end;
theorem
L1860: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B328 being (State of ( SCM+FSA )) holds (for B329 being  good  parahalting (Program of ( SCM+FSA )) holds (for B330 being  read-write Int-Location holds (((not B329 destroy B330) & ( B328 . B330 ) > ( 0 )) implies (( ( IExec (( B329 ";" ( SubFrom (B330 , ( intloc ( 0 ) )) ) ) , R2 , B328) ) . B330 ) = ( ( B328 . B330 ) - 1 ) & ( DataPart ( IExec (( Times (B330 , B329) ) , R2 , B328) ) ) = ( DataPart ( IExec (( Times (B330 , B329) ) , R2 , ( IExec (( B329 ";" ( SubFrom (B330 , ( intloc ( 0 ) )) ) ) , R2 , B328) )) ) )))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C325 being (State of ( SCM+FSA ));
let C326 being  good  parahalting (Program of ( SCM+FSA ));
let C327 being  read-write Int-Location;
set D294 = ( C326 ";" ( SubFrom (C327 , ( intloc ( 0 ) )) ) );
set D295 = ( IExec (D294 , R2 , C325) );
set D296 = R2;
set D297 = ( Initialized C325 );
set D298 = ( Initialized D295 );
set D299 = R2;
set D300 = ( if=0 (C327 , ( Goto 2 ) , ( C326 ";" ( SubFrom (C327 , ( intloc ( 0 ) )) ) )) );
set D301 = ( Initialize D297 );
set D302 = ( R2 +* ( ( loop D300 ) ";" ( Stop ( SCM+FSA ) ) ) );
set D303 = ( Initialize ( Initialized D298 ) );
set D304 = ( D299 +* ( ( loop D300 ) ";" ( Stop ( SCM+FSA ) ) ) );
L1861: ( ( loop D300 ) ";" ( Stop ( SCM+FSA ) ) ) c= D302 by FUNCT_4:25;
L1862: C326 is_halting_on D297 , R2 by SCMFSA7B:19;
L1863: D294 is_halting_on ( Initialized C325 ) , R2 by SCMFSA7B:19;
reconsider D305 = ( Macro ( SubFrom (C327 , ( intloc ( 0 ) )) ) ) as  good (Program of ( SCM+FSA )) by L1483 , SCMFSA7B:8;
set D306 = ( Data-Locations ( SCM+FSA ) );
assume L1864: (not C326 destroy C327);
L1865: ( 0 ) in ( dom D300 ) by L269;
L1866: ( 0 ) in ( dom ( loop D300 ) ) by L1865 , FUNCT_4:99;
L1867: D294 is_closed_on ( Initialized C325 ) , R2 by SCMFSA7B:18;
L1868: D294 = ( C326 ";" D305 );
L1869: ( D295 . ( intloc ( 0 ) ) ) = 1 by L1868 , L1863 , L1867 , L1456;
assume L1870: ( C325 . C327 ) > ( 0 );
L1871: ( D297 . C327 ) > ( 0 ) by L1870 , SCMFSA_M:37;
L1872: ( D297 . ( intloc ( 0 ) ) ) = 1 by SCMFSA_M:9;
L1873: ( loop D300 ) is_pseudo-closed_on D297 , R2 by L1872 , L1864 , L1871 , L1672;
L1874: ( Directed ( loop D300 ) ) = ( loop D300 ) by SCMFSA6A:22;
L1875: ( Directed ( loop D300 ) ) is_pseudo-closed_on D297 , R2 by L1874 , L1864 , L1872 , L1871 , L1672;
consider C328 being (State of ( SCM+FSA )), C329 being (Instruction-Sequence of ( SCM+FSA )), C330 being (Element of ( NAT )) such that L1876: C328 = ( Initialize D297 ) and L1877: C329 = ( R2 +* ( loop ( if=0 (C327 , ( Goto 2 ) , ( C326 ";" ( SubFrom (C327 , ( intloc ( 0 ) )) ) )) ) ) ) and L1878: C330 = ( ( LifeSpan (( R2 +* D300 ) , ( Initialize D297 )) ) + 1 ) and L1879: ( ( Comput (C329 , C328 , C330) ) . C327 ) = ( ( D297 . C327 ) - 1 ) and L1880: ( ( Comput (C329 , C328 , C330) ) . ( intloc ( 0 ) ) ) = 1 and L1881: (for B331 being  read-write Int-Location holds (B331 <> C327 implies ( ( Comput (C329 , C328 , C330) ) . B331 ) = ( ( IExec (C326 , R2 , D297) ) . B331 ))) and L1882: (for B332 being FinSeq-Location holds ( ( Comput (C329 , C328 , C330) ) . B332 ) = ( ( IExec (C326 , R2 , D297) ) . B332 )) and L1883: ( IC ( Comput (C329 , C328 , C330) ) ) = ( 0 ) and L1884: (for B333 being (Element of ( NAT )) holds (B333 <= C330 implies ( IC ( Comput (C329 , C328 , B333) ) ) in ( dom ( loop ( if=0 (C327 , ( Goto 2 ) , ( C326 ";" ( SubFrom (C327 , ( intloc ( 0 ) )) ) )) ) ) ))) by L1864 , L1872 , L1871 , L1792;
L1885:
now
let C331 being FinSeq-Location;
thus L1886: ( ( Comput (C329 , C328 , C330) ) . C331 ) = ( ( IExec (C326 , R2 , D297) ) . C331 ) by L1882
.= ( ( Exec (( SubFrom (C327 , ( intloc ( 0 ) )) ) , ( IExec (C326 , R2 , D297) )) ) . C331 ) by SCMFSA_2:65
.= ( ( IExec (D294 , R2 , D297) ) . C331 ) by SCMFSA6C:7
.= ( ( IExec (D294 , R2 , C325) ) . C331 );
end;
thus L1887: ( D295 . C327 ) = ( ( Exec (( SubFrom (C327 , ( intloc ( 0 ) )) ) , ( IExec (C326 , R2 , C325) )) ) . C327 ) by SCMFSA6C:6
.= ( ( ( IExec (C326 , R2 , C325) ) . C327 ) - ( ( IExec (C326 , R2 , C325) ) . ( intloc ( 0 ) ) ) ) by SCMFSA_2:65
.= ( ( ( IExec (C326 , R2 , C325) ) . C327 ) - 1 ) by L1862 , L1419
.= ( ( D297 . C327 ) - 1 ) by L1864 , L1415
.= ( ( C325 . C327 ) - 1 ) by SCMFSA_M:37;
L1888:
now
let C332 being Int-Location;
per cases ;
suppose L1889: C332 = ( intloc ( 0 ) );

thus L1890: ( ( Comput (C329 , C328 , C330) ) . C332 ) = ( ( IExec (D294 , R2 , C325) ) . C332 ) by L1889 , L1880 , L1868 , L1863 , L1867 , L1456;
end;
suppose L1891: C332 = C327;

thus L1892: ( ( Comput (C329 , C328 , C330) ) . C332 ) = ( ( IExec (D294 , R2 , C325) ) . C332 ) by L1891 , L1879 , L1887 , SCMFSA_M:37;
end;
suppose L1893: (C332 <> C327 & C332 <> ( intloc ( 0 ) ));

reconsider D307 = C332 as  read-write Int-Location by L1893 , SCMFSA_M:def 2;
thus L1894: ( ( Comput (C329 , C328 , C330) ) . C332 ) = ( ( IExec (C326 , R2 , D297) ) . D307 ) by L1881 , L1893
.= ( ( Exec (( SubFrom (C327 , ( intloc ( 0 ) )) ) , ( IExec (C326 , R2 , D297) )) ) . C332 ) by L1893 , SCMFSA_2:65
.= ( ( IExec (D294 , R2 , D297) ) . C332 ) by SCMFSA6C:6
.= ( ( IExec (D294 , R2 , C325) ) . C332 );
end;
end;
L1896: ( DataPart ( Comput (C329 , C328 , C330) ) ) = ( DataPart D295 ) by L1888 , L1885 , SCMFSA_M:2;
L1897: ( DataPart ( IExec (( Times (C327 , C326) ) , R2 , D297) ) ) = ( DataPart ( IExec (( ( loop D300 ) ";" ( Stop ( SCM+FSA ) ) ) , R2 , D297) ) ) by L1864 , L1872 , L1871 , L1874 , L799 , L1672;
per cases ;
suppose L1898: ( D295 . C327 ) = ( 0 );

L1899: ( D300 . ( ( card D294 ) + 3 ) ) = ( goto ( ( card D294 ) + 5 ) ) by L526;
L1900: ( ( card D294 ) + ( 3 + 2 ) ) = ( ( ( card D294 ) + 1 ) + 4 )
.= ( ( ( card ( Goto 2 ) ) + ( card D294 ) ) + 4 ) by SCMFSA8A:15
.= ( card D300 ) by SCMFSA8B:11
.= ( card ( dom D300 ) )
.= ( card ( dom ( loop D300 ) ) ) by FUNCT_4:99
.= ( card ( loop D300 ) );
L1901: ( ( ( card D294 ) + 3 ) + ( 0 ) ) < ( card ( loop D300 ) ) by L1900 , XREAL_1:6;
L1902: ( ( card D294 ) + 3 ) in ( dom ( loop D300 ) ) by L1901 , AFINSQ_1:66;
L1903: ( C329 . ( ( card D294 ) + 3 ) ) = ( ( loop D300 ) . ( ( card D294 ) + 3 ) ) by L1902 , L1877 , FUNCT_4:13
.= ( ( loop D300 ) . ( ( card D294 ) + 3 ) );
L1904: ( C329 . ( ( card D294 ) + 3 ) ) = ( goto ( ( card D294 ) + 5 ) ) by L1903 , L1899 , FUNCT_4:105;
L1905: ( InsCode ( C329 . ( ( card D294 ) + 3 ) ) ) = 6 by L1904 , SCMFSA_2:23;
L1906: ( InsCode ( C329 . ( ( card D294 ) + 3 ) ) ) in { ( 0 ) , 6 , 7 , 8 } by L1905 , ENUMSET1:def 2;
L1907: ( Comput (C329 , C328 , ( C330 + 1 )) ) = ( Following (C329 , ( Comput (C329 , C328 , C330) )) ) by EXTPRO_1:3
.= ( Exec (( C329 . ( 0 ) ) , ( Comput (C329 , C328 , C330) )) ) by L1883 , PBOOLE:143;
L1908: ( C329 . ( 0 ) ) = ( ( loop D300 ) . ( 0 ) ) by L1866 , L1877 , FUNCT_4:13
.= ( ( loop D300 ) . ( 0 ) );
L1909: ( D300 . ( 0 ) ) = ( C327 =0_goto ( ( card D294 ) + 3 ) ) by L282;
L1910: ( C329 . ( 0 ) ) = ( C327 =0_goto ( ( card D294 ) + 3 ) ) by L1908 , L1909 , FUNCT_4:105;
L1911: ( ( Comput (C329 , C328 , C330) ) . C327 ) = ( 0 ) by L1879 , L1887 , L1898 , SCMFSA_M:37;
L1912: ( IC ( Comput (C329 , C328 , ( C330 + 1 )) ) ) = ( ( card D294 ) + 3 ) by L1911 , L1907 , L1910 , SCMFSA_2:70;
L1913:
now
let C333 being (Element of ( NAT ));
assume L1914: (not ( IC ( Comput (C329 , C328 , C333) ) ) in ( dom ( loop D300 ) ));
L1915: C330 < C333 by L1914 , L1884;
L1916: ( C330 + 1 ) <= C333 by L1915 , INT_1:7;
L1917: ( C330 + 1 ) < C333 by L1916 , L1912 , L1902 , L1914 , XXREAL_0:1;
L1918: ( ( C330 + 1 ) + 1 ) <= C333 by L1917 , INT_1:7;
thus L1919: ( C330 + ( 1 + 1 ) ) <= C333 by L1918;
end;
L1920: ( C329 /. ( IC ( Comput (C329 , C328 , ( C330 + 1 )) ) ) ) = ( C329 . ( IC ( Comput (C329 , C328 , ( C330 + 1 )) ) ) ) by PBOOLE:143;
L1921: ( Comput (C329 , C328 , ( C330 + ( 1 + 1 ) )) ) = ( Comput (C329 , C328 , ( ( C330 + 1 ) + 1 )) )
.= ( Following (C329 , ( Comput (C329 , C328 , ( C330 + 1 )) )) ) by EXTPRO_1:3
.= ( Exec (( C329 . ( ( card D294 ) + 3 ) ) , ( Comput (C329 , C328 , ( C330 + 1 )) )) ) by L1911 , L1907 , L1910 , L1920 , SCMFSA_2:70;
L1922: ( IC ( Comput (C329 , C328 , ( C330 + 2 )) ) ) = ( card ( loop D300 ) ) by L1921 , L1900 , L1904 , SCMFSA_2:69;
L1923: ( C330 + 2 ) = ( pseudo-LifeSpan (D297 , R2 , ( loop D300 )) ) by L1922 , L1876 , L1873 , L1913 , L1877 , SCMFSA8A:def 4;
L1924: ( InsCode ( C329 . ( 0 ) ) ) = 7 by L1910 , SCMFSA_2:24;
L1925: ( InsCode ( C329 . ( 0 ) ) ) in { ( 0 ) , 6 , 7 , 8 } by L1924 , ENUMSET1:def 2;
L1926: ( DataPart ( Comput (C329 , C328 , C330) ) ) = ( DataPart ( Comput (C329 , C328 , ( C330 + 1 )) ) ) by L1925 , L1907 , L31;
L1927: ( DataPart ( Comput (C329 , C328 , C330) ) ) = ( DataPart ( Comput (C329 , C328 , ( C330 + 2 )) ) ) by L1926 , L1921 , L1906 , L31;
thus L1928: ( DataPart ( IExec (( Times (C327 , C326) ) , R2 , C325) ) ) = ( DataPart ( IExec (( Times (C327 , C326) ) , R2 , D297) ) )
.= ( DataPart ( IExec (( ( loop D300 ) ";" ( Stop ( SCM+FSA ) ) ) , R2 , C325) ) ) by L1897
.= ( DataPart ( Result (D302 , D301) ) ) by MEMSTR_0:44
.= ( DataPart ( Result (D302 , D301) ) )
.= ( DataPart ( IExec (D294 , R2 , C325) ) ) by L1864 , L1872 , L1871 , L1876 , L1874 , L1896 , L1923 , L1927 , L468 , L1672 , L1877
.= ( DataPart ( IExec (( Times (C327 , C326) ) , R2 , ( IExec (D294 , R2 , C325) )) ) ) by L1869 , L1898 , L1846;
end;
suppose L1929: ( D295 . C327 ) <> ( 0 );

L1930: ( C325 . C327 ) >= ( ( 0 ) + 1 ) by L1870 , INT_1:7;
L1931: ( D295 . C327 ) > ( 0 ) by L1930 , L1887 , L1929 , XREAL_1:19;
L1932: ( DataPart D297 ) = ( DataPart D301 ) by MEMSTR_0:79;
L1933: C330 < ( pseudo-LifeSpan (D297 , R2 , ( loop D300 )) ) by L1864 , L1872 , L1871 , L1876 , L1884 , L1 , L1672 , L1877;
L1934: ( DataPart ( Comput (D302 , D301 , C330) ) ) = ( DataPart D295 ) by L1933 , L1876 , L1874 , L1875 , L1896 , L319 , L1877;
L1935:
now
L1936: ( DataPart D298 ) = ( DataPart D303 ) by MEMSTR_0:79;
thus L1937:now
let C334 being Int-Location;
per cases ;
suppose L1938: C334 = ( intloc ( 0 ) );

thus L1939: ( ( Comput (D302 , D301 , C330) ) . C334 ) = ( D295 . C334 ) by L1934 , SCMFSA_M:2
.= 1 by L1938 , SCMFSA6B:11
.= ( D298 . C334 ) by L1938 , SCMFSA_M:9
.= ( D303 . C334 ) by L1936 , SCMFSA_M:2;
end;
suppose L1940: C334 <> ( intloc ( 0 ) );

L1941: C334 is  read-write  read-write  read-write  read-write Int-Location by L1940 , SCMFSA_M:def 2;
thus L1942: ( ( Comput (D302 , D301 , C330) ) . C334 ) = ( D295 . C334 ) by L1934 , SCMFSA_M:2
.= ( D298 . C334 ) by L1941 , SCMFSA_M:37
.= ( D303 . C334 ) by L1936 , SCMFSA_M:2;
end;
end;
let C335 being FinSeq-Location;
thus L1944: ( ( Comput (D302 , D301 , C330) ) . C335 ) = ( D295 . C335 ) by L1934 , SCMFSA_M:2
.= ( D298 . C335 ) by SCMFSA_M:37
.= ( D303 . C335 ) by L1936 , SCMFSA_M:2;
end;
L1945: ( IC ( Comput (D302 , D301 , C330) ) ) = ( 0 ) by L1883 , L1876 , L1874 , L1875 , L1933 , L319 , L1877
.= ( IC D303 ) by FUNCT_4:113;
L1946: ( Comput (D302 , D301 , C330) ) = D303 by L1945 , L1935 , SCMFSA_2:61;
L1947: ( Directed ( loop D300 ) ) = ( loop D300 ) by SCMFSA6A:22;
L1948: ( Directed ( loop D300 ) ) is_pseudo-closed_on D301 , D302 by L1947 , L1864 , L1872 , L1871 , L1932 , L248 , L1672;
L1949: ( ( loop D300 ) ";" ( Stop ( SCM+FSA ) ) ) is_closed_on D301 , D302 by L1948 , L319;
L1950: ( ( loop D300 ) ";" ( Stop ( SCM+FSA ) ) ) is_halting_on D301 , D302 by L1948 , L319;
L1951: ( D295 . ( intloc ( 0 ) ) ) = 1 by L1868 , L1863 , L1867 , L1456;
L1952: ( Result (D302 , D301) ) = ( Result (D304 , D303) ) by L1949 , L1950 , L1946 , L1518 , L1861;
L1953: ( DataPart ( IExec (( ( loop D300 ) ";" ( Stop ( SCM+FSA ) ) ) , R2 , D297) ) ) = ( DataPart ( IExec (( ( loop D300 ) ";" ( Stop ( SCM+FSA ) ) ) , R2 , C325) ) )
.= ( DataPart ( Result (D302 , D301) ) ) by MEMSTR_0:44
.= ( DataPart ( Result (D302 , D301) ) )
.= ( DataPart ( Result (D304 , D303) ) ) by L1952
.= ( DataPart ( Result (D304 , D303) ) )
.= ( DataPart ( IExec (( ( loop D300 ) ";" ( Stop ( SCM+FSA ) ) ) , R2 , ( IExec (D294 , R2 , C325) )) ) ) by MEMSTR_0:44
.= ( DataPart ( IExec (( Times (C327 , C326) ) , R2 , ( IExec (D294 , R2 , C325) )) ) ) by L1864 , L1874 , L1951 , L1931 , L799 , L1672;
thus L1954: thesis by L1953 , L1897;
end;
end;
begin
theorem
L1956: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for B334 being (State of ( SCM+FSA )) holds (for B335 , B336 , B337 being  read-write Int-Location holds ((B335 <> B336 & B335 <> B337 & B336 <> B337 & ( B334 . B335 ) >= ( 0 )) implies ( ( IExec (( Times (B335 , ( Macro ( AddTo (B336 , B337) ) )) ) , R2 , B334) ) . B336 ) = ( ( B334 . B336 ) + ( ( B334 . B337 ) * ( B334 . B335 ) ) )))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let C336 being (State of ( SCM+FSA ));
let C337 , C338 , C339 being  read-write Int-Location;
set D308 = ( Times (C337 , ( Macro ( AddTo (C338 , C339) ) )) );
defpred S11[ Nat ] means (for B338 being (State of ( SCM+FSA )) holds (( B338 . C337 ) = $1 implies ( ( IExec (( Times (C337 , ( Macro ( AddTo (C338 , C339) ) )) ) , R2 , B338) ) . C338 ) = ( ( B338 . C338 ) + ( ( B338 . C339 ) * ( B338 . C337 ) ) )));
reconsider D309 = ( Macro ( AddTo (C338 , C339) ) ) as  good  parahalting (Program of ( SCM+FSA )) by L1483 , SCMFSA7B:7;
set D310 = ( Data-Locations ( SCM+FSA ) );
assume that
L1957: C337 <> C338
and
L1958: C337 <> C339
and
L1959: C338 <> C339;
L1960: (for B339 being (Element of ( NAT )) holds (S11[ B339 ] implies S11[ ( B339 + 1 ) ]))
proof
let C340 being (Element of ( NAT ));
assume L1961: S11[ C340 ];
let C341 being (State of ( SCM+FSA ));
assume L1962: ( C341 . C337 ) = ( C340 + 1 );
L1963: (not D309 destroy C337) by L1957 , L1324 , SCMFSA7B:7;
L1964: ( DataPart ( IExec (( Times (C337 , D309) ) , R2 , C341) ) ) = ( DataPart ( IExec (( Times (C337 , D309) ) , R2 , ( IExec (( D309 ";" ( SubFrom (C337 , ( intloc ( 0 ) )) ) ) , R2 , C341) )) ) ) by L1963 , L1962 , L1860;
L1965: ( ( IExec (( D309 ";" ( SubFrom (C337 , ( intloc ( 0 ) )) ) ) , R2 , C341) ) . C339 ) = ( ( Exec (( SubFrom (C337 , ( intloc ( 0 ) )) ) , ( IExec (D309 , R2 , C341) )) ) . C339 ) by SCMFSA6C:6
.= ( ( IExec (D309 , R2 , C341) ) . C339 ) by L1958 , SCMFSA_2:65
.= ( ( IExec (D309 , R2 , C341) ) . C339 )
.= ( ( Exec (( AddTo (C338 , C339) ) , ( Initialized C341 )) ) . C339 ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (C338 , C339) ) , ( Initialized C341 )) ) . C339 )
.= ( ( Initialized C341 ) . C339 ) by L1959 , SCMFSA_2:64
.= ( C341 . C339 ) by SCMFSA_M:37;
L1966: ( ( IExec (( D309 ";" ( SubFrom (C337 , ( intloc ( 0 ) )) ) ) , R2 , C341) ) . C338 ) = ( ( Exec (( SubFrom (C337 , ( intloc ( 0 ) )) ) , ( IExec (D309 , R2 , C341) )) ) . C338 ) by SCMFSA6C:6
.= ( ( IExec (D309 , R2 , C341) ) . C338 ) by L1957 , SCMFSA_2:65
.= ( ( IExec (D309 , R2 , C341) ) . C338 )
.= ( ( Exec (( AddTo (C338 , C339) ) , ( Initialized C341 )) ) . C338 ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (C338 , C339) ) , ( Initialized C341 )) ) . C338 )
.= ( ( ( Initialized C341 ) . C338 ) + ( ( Initialized C341 ) . C339 ) ) by SCMFSA_2:64
.= ( ( ( Initialized C341 ) . C338 ) + ( C341 . C339 ) ) by SCMFSA_M:37
.= ( ( C341 . C338 ) + ( C341 . C339 ) ) by SCMFSA_M:37;
L1967: ( ( IExec (( D309 ";" ( SubFrom (C337 , ( intloc ( 0 ) )) ) ) , R2 , C341) ) . C337 ) = ( ( C341 . C337 ) - 1 ) by L1962 , L1963 , L1860;
L1968: ( ( IExec (( Times (C337 , D309) ) , R2 , ( IExec (( D309 ";" ( SubFrom (C337 , ( intloc ( 0 ) )) ) ) , R2 , C341) )) ) . C338 ) = ( ( ( C341 . C338 ) + ( C341 . C339 ) ) + ( ( C341 . C339 ) * ( ( C341 . C337 ) - 1 ) ) ) by L1967 , L1961 , L1962 , L1966 , L1965
.= ( ( C341 . C338 ) + ( ( C341 . C339 ) * ( C341 . C337 ) ) );
thus L1969: thesis by L1968 , L1964 , SCMFSA_M:2;
end;
assume L1970: ( C336 . C337 ) >= ( 0 );
reconsider D311 = ( C336 . C337 ) as (Element of ( NAT )) by L1970 , INT_1:3;
L1971: S11[ ( 0 ) ]
proof
let C342 being (State of ( SCM+FSA ));
set D312 = ( Initialized C342 );
L1972: ( D312 . ( intloc ( 0 ) ) ) = 1 by SCMFSA_M:9;
assume L1973: ( C342 . C337 ) = ( 0 );
L1974: ( D312 . C337 ) = ( 0 ) by L1973 , SCMFSA_M:37;
L1975: ( DataPart ( IExec (( Times (C337 , D309) ) , R2 , D312) ) ) = ( DataPart D312 ) by L1974 , L1972 , L1846;
thus L1976: ( ( IExec (D308 , R2 , C342) ) . C338 ) = ( ( IExec (D308 , R2 , D312) ) . C338 )
.= ( D312 . C338 ) by L1975 , SCMFSA_M:2
.= ( ( C342 . C338 ) + ( ( C342 . C339 ) * ( C342 . C337 ) ) ) by L1973 , SCMFSA_M:37;
end;
L1977: (for B340 being (Element of ( NAT )) holds S11[ B340 ]) from NAT_1:sch 1(L1971 , L1960);
L1978: S11[ D311 ] by L1977;
thus L1979: thesis by L1978;
end;
