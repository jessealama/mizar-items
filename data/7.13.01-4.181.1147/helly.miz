:: Helly property for subtrees
::  by Jessica Enright and Piotr Rudnicki
::
:: Received January 10, 2008
:: Copyright (c) 2008-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, XBOOLE_0, FINSEQ_1, FUNCT_1, GRAPH_2, ARYTM_3, NAT_1,
      XXREAL_0, SUBSET_1, TREES_1, TARSKI, CARD_1, ORDINAL1, FINSET_1,
      MEMBERED, RELAT_1, ORDINAL4, GLIB_000, GLIB_001, ABIAN, ZFMISC_1,
      ARYTM_1, GRAPH_1, RCOMP_1, SETFAM_1, HELLY;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, FINSET_1, CARD_1, NUMBERS,
      XCMPLX_0, XXREAL_0, SETFAM_1, FUNCT_1, FINSEQ_1, MEMBERED, NAT_1,
      TREES_1, XXREAL_2, ABIAN, GRAPH_2, GLIB_000, GLIB_001, GLIB_002;
 constructors DOMAIN_1, SETFAM_1, NAT_1, GRAPH_2, GLIB_001, GLIB_002, XXREAL_2,
      RELSET_1, RAT_1;
 registrations FINSET_1, XREAL_0, XXREAL_0, NAT_1, INT_1, RELAT_1, FINSEQ_1,
      ABIAN, MEMBERED, GLIB_000, GLIB_001, GLIB_002, XXREAL_2, CARD_1, FUNCT_1,
      XBOOLE_0;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;
 definitions TARSKI, XBOOLE_0, GLIB_001;
 theorems TARSKI, NAT_1, GRAPH_5, SETFAM_1, XBOOLE_0, XBOOLE_1, GRFUNC_1,
      FUNCT_1, ZFMISC_1, ORDINAL1, FINSEQ_1, FINSEQ_2, FINSEQ_3, INT_1,
      EULER_1, CARD_1, XREAL_1, XXREAL_0, CHORD, ABIAN, GLIB_000, GLIB_001,
      GLIB_002, MSSCYC_1, MEMBERED, GRAPH_2, XXREAL_2, FINSEQ_4;
 schemes NAT_1, FINSEQ_1;

begin
theorem
L1: (for B1 being non  empty FinSequence holds ( <* ( B1 . 1 ) *> ^' B1 ) = B1)
proof
let C1 being non  empty FinSequence;
set D1 = ( <* ( C1 . 1 ) *> ^' C1 );
L2: ( ( len D1 ) + 1 ) = ( ( len <* ( C1 . 1 ) *> ) + ( len C1 ) ) by GRAPH_2:13;
L3: ( len <* ( C1 . 1 ) *> ) = 1 by FINSEQ_1:39;
L4:
now
let C2 being Nat;
assume that
L5: 1 <= C2
and
L6: C2 <= ( len D1 );
per cases ;
suppose L7: C2 <= ( len <* ( C1 . 1 ) *> );

L8: C2 <= 1 by L7 , FINSEQ_1:39;
L9: C2 = 1 by L8 , L5 , XXREAL_0:1;
thus L10: ( D1 . C2 ) = ( <* ( C1 . 1 ) *> . 1 ) by L9 , L7 , GRAPH_2:14
.= ( C1 . C2 ) by L9 , FINSEQ_1:40;
end;
suppose L11: C2 > ( len <* ( C1 . 1 ) *> );

consider C3 being (Element of ( NAT )) such that L12: C2 = ( ( len <* ( C1 . 1 ) *> ) + C3 ) and L13: 1 <= C3 by L11 , FINSEQ_4:84;
L14: C3 < ( len C1 ) by L2 , L3 , L6 , L12 , NAT_1:13;
thus L15: ( D1 . C2 ) = ( C1 . C2 ) by L14 , L3 , L12 , L13 , GRAPH_2:15;
end;
end;
L17: ( ( len D1 ) + 1 ) = ( 1 + ( len C1 ) ) by L2 , FINSEQ_1:39;
thus L18: thesis by L17 , L4 , FINSEQ_1:14;
end;
definition
let C4 , C5 being FinSequence;
func maxPrefix (C4 , C5) -> FinSequence means 
:L19: (it is_a_prefix_of C4 & it is_a_prefix_of C5 & (for B2 being FinSequence holds ((B2 is_a_prefix_of C4 & B2 is_a_prefix_of C5) implies B2 is_a_prefix_of it)));
existence
proof
deffunc H1(set) = $1;
defpred S1[ set ] means (ex B3 being FinSequence st (B3 c= C4 & B3 c= C5 & ( len B3 ) = $1));
set D2 = { H1(B4) where B4 is (Element of ( NAT )) : (( 0 ) <= B4 & B4 <= ( len C4 ) & S1[ B4 ]) };
L20: (for B5 being set holds (B5 in D2 implies B5 is  natural))
proof
let C6 being set;
assume L21: C6 in D2;
L22: (ex B6 being (Element of ( NAT )) st (C6 = B6 & ( 0 ) <= B6 & B6 <= ( len C4 ) & S1[ B6 ])) by L21;
thus L23: thesis by L22;
end;
L24: D2 is  finite from FINSEQ_1:sch 6;
L25: (( {} ) c= C4 & ( {} ) c= C5 & ( len ( {} ) ) = ( 0 )) by XBOOLE_1:2;
L26: ( 0 ) in D2 by L25;
reconsider D3 = D2 as  finite non  empty  natural-membered set by L26 , L20 , L24 , MEMBERED:def 6;
set D4 = ( max D3 );
L27: D4 in D3 by XXREAL_2:def 8;
consider C7 being (Element of ( NAT )) such that L28: C7 = D4 and L29: ( 0 ) <= C7 and L30: C7 <= ( len C4 ) and L31: S1[ C7 ] by L27;
consider C8 being FinSequence such that L32: C8 c= C4 and L33: C8 c= C5 and L34: ( len C8 ) = C7 by L31;
take C8;
thus L35: C8 c= C4 by L32;
thus L36: C8 c= C5 by L33;
let C9 being FinSequence;
assume that
L37: C9 c= C4
and
L38: C9 c= C5;
L39: ( dom C9 ) c= ( dom C4 ) by L37 , GRFUNC_1:2;
L40: ( len C9 ) <= ( len C4 ) by L39 , FINSEQ_3:30;
L41: ( len C9 ) in D3 by L40 , L37 , L38;
L42: ( len C9 ) <= ( len C8 ) by L41 , L28 , L34 , XXREAL_2:def 8;
L43: ( dom C9 ) c= ( dom C8 ) by L42 , FINSEQ_3:30;
L44:
now
let C10 being set;
assume L45: C10 in ( dom C9 );
thus L46: ( C9 . C10 ) = ( C4 . C10 ) by L45 , L37 , GRFUNC_1:2
.= ( C8 . C10 ) by L32 , L43 , L45 , GRFUNC_1:2;
end;
thus L47: thesis by L44 , L43 , GRFUNC_1:2;
end;
uniqueness
proof
let C11 , C12 being FinSequence;
assume L48: (C11 c= C4 & C11 c= C5 & (for B7 being FinSequence holds ((B7 c= C4 & B7 c= C5) implies B7 c= C11)) & C12 c= C4 & C12 c= C5 & (for B8 being FinSequence holds ((B8 c= C4 & B8 c= C5) implies B8 c= C12)));
L49: (C11 c= C12 & C12 c= C11) by L48;
thus L50: thesis by L49 , XBOOLE_0:def 10;
end;
commutativity
;
end;
theorem
L52: (for B9 , B10 being FinSequence holds (B9 is_a_prefix_of B10 iff ( maxPrefix (B9 , B10) ) = B9))
proof
let C13 , C14 being FinSequence;
thus L53:now
assume L54: C13 c= C14;
L55: C13 c= ( maxPrefix (C13 , C14) ) by L54 , L19;
L56: ( maxPrefix (C13 , C14) ) c= C13 by L19;
thus L57: ( maxPrefix (C13 , C14) ) = C13 by L56 , L55 , XBOOLE_0:def 10;
end;
assume L58: ( maxPrefix (C13 , C14) ) = C13;
thus L59: thesis by L58 , L19;
end;
theorem
L60: (for B11 , B12 being FinSequence holds ( len ( maxPrefix (B11 , B12) ) ) <= ( len B11 ))
proof
let C15 , C16 being FinSequence;
L61: ( maxPrefix (C15 , C16) ) c= C15 by L19;
thus L62: thesis by L61 , FINSEQ_1:63;
end;
theorem
L63: (for B13 being non  empty FinSequence holds <* ( B13 . 1 ) *> is_a_prefix_of B13)
proof
let C17 being non  empty FinSequence;
L64:
now
let C18 being set;
L65: ( dom <* ( C17 . 1 ) *> ) = ( Seg 1 ) by FINSEQ_1:def 8;
assume L66: C18 in ( dom <* ( C17 . 1 ) *> );
L67: C18 = 1 by L66 , L65 , FINSEQ_1:2 , TARSKI:def 1;
thus L68: ( <* ( C17 . 1 ) *> . C18 ) = ( C17 . C18 ) by L67 , FINSEQ_1:def 8;
end;
L69: ( len C17 ) >= 1 by FINSEQ_1:20;
L70: ( len <* ( C17 . 1 ) *> ) <= ( len C17 ) by L69 , FINSEQ_1:39;
L71: ( dom <* ( C17 . 1 ) *> ) c= ( dom C17 ) by L70 , FINSEQ_3:30;
thus L72: thesis by L71 , L64 , GRFUNC_1:2;
end;
theorem
L73: (for B14 , B15 being non  empty FinSequence holds (( B14 . 1 ) = ( B15 . 1 ) implies 1 <= ( len ( maxPrefix (B14 , B15) ) )))
proof
let C19 , C20 being non  empty FinSequence;
assume that
L74: ( C19 . 1 ) = ( C20 . 1 )
and
L75: 1 > ( len ( maxPrefix (C19 , C20) ) );
L76: <* ( C19 . 1 ) *> c= C19 by L63;
L77: <* ( C19 . 1 ) *> c= C20 by L74 , L63;
L78: <* ( C19 . 1 ) *> c= ( maxPrefix (C19 , C20) ) by L77 , L76 , L19;
L79: ( len <* ( C19 . 1 ) *> ) <= ( len ( maxPrefix (C19 , C20) ) ) by L78 , FINSEQ_1:63;
thus L80: contradiction by L79 , L75 , FINSEQ_1:39;
end;
theorem
L81: (for B16 , B17 being FinSequence holds (for B18 being Nat holds (B18 <= ( len ( maxPrefix (B16 , B17) ) ) implies ( ( maxPrefix (B16 , B17) ) . B18 ) = ( B16 . B18 ))))
proof
let C21 , C22 being FinSequence;
let C23 being Nat;
assume that
L82: C23 <= ( len ( maxPrefix (C21 , C22) ) );
L83: ( maxPrefix (C21 , C22) ) c= C21 by L19;
per cases ;
suppose L84: C23 = ( 0 );

L85: (not C23 in ( dom C21 )) by L84 , FINSEQ_3:24;
L86: (not C23 in ( dom ( maxPrefix (C21 , C22) ) )) by L84 , FINSEQ_3:24;
thus L87: ( ( maxPrefix (C21 , C22) ) . C23 ) = ( 0 ) by L86 , FUNCT_1:def 2
.= ( C21 . C23 ) by L85 , FUNCT_1:def 2;
end;
suppose L88: C23 <> ( 0 );

L89: ( ( 0 ) + 1 ) <= C23 by L88 , NAT_1:13;
L90: C23 in ( dom ( maxPrefix (C21 , C22) ) ) by L89 , L82 , FINSEQ_3:25;
thus L91: thesis by L90 , L83 , GRFUNC_1:2;
end;
end;
theorem
L93: (for B19 , B20 being FinSequence holds (for B21 being Nat holds (B21 <= ( len ( maxPrefix (B19 , B20) ) ) implies ( B19 . B21 ) = ( B20 . B21 ))))
proof
let C24 , C25 being FinSequence;
let C26 being Nat;
assume that
L94: C26 <= ( len ( maxPrefix (C24 , C25) ) );
thus L95: ( C24 . C26 ) = ( ( maxPrefix (C24 , C25) ) . C26 ) by L94 , L81
.= ( C25 . C26 ) by L94 , L81;
end;
theorem
L96: (for B22 , B23 being FinSequence holds ((not B22 is_a_prefix_of B23) iff ( len ( maxPrefix (B22 , B23) ) ) < ( len B22 )))
proof
let C27 , C28 being FinSequence;
L97: ( maxPrefix (C27 , C28) ) c= C27 by L19;
thus L98:now
assume L99: (not C27 c= C28);
L100:
now
assume L101: ( len ( maxPrefix (C27 , C28) ) ) = ( len C27 );
L102: ( dom ( maxPrefix (C27 , C28) ) ) = ( dom C27 ) by L101 , FINSEQ_3:29;
L103: ( maxPrefix (C27 , C28) ) c= C27 by L19;
L104: ( maxPrefix (C27 , C28) ) = C27 by L103 , L102 , GRFUNC_1:3;
thus L105: contradiction by L104 , L99 , L19;
end;
L106: ( maxPrefix (C27 , C28) ) c= C27 by L19;
L107: ( len ( maxPrefix (C27 , C28) ) ) <= ( len C27 ) by L106 , FINSEQ_1:63;
thus L108: ( len ( maxPrefix (C27 , C28) ) ) < ( len C27 ) by L107 , L100 , XXREAL_0:1;
end;
assume that
L109: ( len ( maxPrefix (C27 , C28) ) ) < ( len C27 )
and
L110: C27 c= C28;
L111: C27 c= ( maxPrefix (C27 , C28) ) by L110 , L19;
thus L112: contradiction by L111 , L109 , L97 , XBOOLE_0:def 10;
end;
theorem
L113: (for B24 , B25 being FinSequence holds (((not B24 is_a_prefix_of B25) & (not B25 is_a_prefix_of B24)) implies ( B24 . ( ( len ( maxPrefix (B24 , B25) ) ) + 1 ) ) <> ( B25 . ( ( len ( maxPrefix (B24 , B25) ) ) + 1 ) )))
proof
let C29 , C30 being FinSequence;
assume that
L114: (not C29 c= C30)
and
L115: (not C30 c= C29)
and
L116: ( C29 . ( ( len ( maxPrefix (C29 , C30) ) ) + 1 ) ) = ( C30 . ( ( len ( maxPrefix (C29 , C30) ) ) + 1 ) );
set D5 = ( len ( maxPrefix (C29 , C30) ) );
set D6 = ( maxPrefix (C29 , C30) );
set D7 = ( D6 ^ <* ( C29 . ( D5 + 1 ) ) *> );
L117:
now
let C31 being set;
assume that
L118: C31 in ( dom D7 );
reconsider D8 = C31 as Nat by L118;
L119: 1 <= D8 by L118 , FINSEQ_3:25;
L120: D8 <= ( len D7 ) by L118 , FINSEQ_3:25;
L121: D8 <= ( ( len D6 ) + 1 ) by L120 , FINSEQ_2:16;
per cases  by L121 , NAT_1:8;
suppose L122: D8 <= D5;

L123: D8 in ( dom D6 ) by L122 , L119 , FINSEQ_3:25;
thus L124: ( D7 . C31 ) = ( D6 . C31 ) by L123 , FINSEQ_1:def 7
.= ( C30 . C31 ) by L122 , L81;
end;
suppose L125: D8 = ( D5 + 1 );

thus L126: ( D7 . C31 ) = ( C30 . C31 ) by L125 , L116 , FINSEQ_1:42;
end;
end;
L128:
now
let C32 being set;
assume that
L129: C32 in ( dom D7 );
reconsider D9 = C32 as Nat by L129;
L130: 1 <= D9 by L129 , FINSEQ_3:25;
L131: D9 <= ( len D7 ) by L129 , FINSEQ_3:25;
L132: D9 <= ( ( len D6 ) + 1 ) by L131 , FINSEQ_2:16;
per cases  by L132 , NAT_1:8;
suppose L133: D9 <= D5;

L134: D9 in ( dom D6 ) by L133 , L130 , FINSEQ_3:25;
thus L135: ( D7 . C32 ) = ( D6 . C32 ) by L134 , FINSEQ_1:def 7
.= ( C29 . C32 ) by L133 , L81;
end;
suppose L136: D9 = ( D5 + 1 );

thus L137: ( D7 . C32 ) = ( C29 . C32 ) by L136 , FINSEQ_1:42;
end;
end;
L139: ( len D7 ) = ( ( len D6 ) + 1 ) by FINSEQ_2:16;
L140: ( len D6 ) < ( len C30 ) by L115 , L96;
L141: ( len D7 ) <= ( len C30 ) by L140 , L139 , NAT_1:13;
L142: ( dom D7 ) c= ( dom C30 ) by L141 , FINSEQ_3:30;
L143: D7 c= C30 by L142 , L117 , GRFUNC_1:2;
L144: ( len D6 ) < ( len C29 ) by L114 , L96;
L145: ( len D7 ) <= ( len C29 ) by L144 , L139 , NAT_1:13;
L146: ( dom D7 ) c= ( dom C29 ) by L145 , FINSEQ_3:30;
L147: D7 c= C29 by L146 , L128 , GRFUNC_1:2;
L148: D7 c= D6 by L147 , L143 , L19;
L149: ( len D7 ) <= ( len D6 ) by L148 , FINSEQ_1:63;
L150: ( ( len D6 ) + 1 ) <= ( len D6 ) by L149 , FINSEQ_2:16;
thus L151: contradiction by L150 , NAT_1:13;
end;
begin
theorem
L152: (for B26 being _Graph holds (for B27 being (Walk of B26) holds (for B28 , B29 being Nat holds ( len ( B27 .cut (B28 , B29) ) ) <= ( len B27 ))))
proof
let C33 being _Graph;
let C34 being (Walk of C33);
let C35 , C36 being Nat;
reconsider D10 = C35 , D11 = C36 as (Element of ( NAT )) by ORDINAL1:def 12;
per cases ;
suppose L153: (C35 is  odd & C36 is  odd & C35 <= C36 & C36 <= ( len C34 ));

L154: ( C34 .cut (C35 , C36) ) = ( (C35 , C36) -cut C34 ) by L153 , GLIB_001:def 11;
L155: ( len ( C34 .cut (D10 , D11) ) ) <= ( len C34 ) by L154 , MSSCYC_1:8;
thus L156: thesis by L155;
end;
suppose L157: (not (C35 is  odd & C36 is  odd & C35 <= C36 & C36 <= ( len C34 )));

thus L158: thesis by L157 , GLIB_001:def 11;
end;
end;
theorem
L160: (for B30 being _Graph holds (for B31 being (Walk of B30) holds (for B32 , B33 being Nat holds (( B31 .cut (B32 , B33) ) is non  trivial implies B31 is non  trivial))))
proof
let C37 being _Graph;
let C38 being (Walk of C37);
let C39 , C40 being Nat;
assume that
L161: ( C38 .cut (C39 , C40) ) is non  trivial
and
L162: C38 is  trivial;
reconsider D12 = C38 as  trivial (Walk of C37) by L162;
reconsider D13 = C39 , D14 = C40 as (Element of ( NAT )) by ORDINAL1:def 12;
L163: ( D12 .cut (D13 , D14) ) is  trivial;
thus L164: thesis by L163 , L161;
end;
theorem
L165: (for B34 being _Graph holds (for B35 being (Walk of B34) holds (for B36 , B37 , B38 being  odd Nat holds ((B36 <= B37 & B37 <= ( len B35 ) & B38 <= ( len ( B35 .cut (B36 , B37) ) )) implies (ex B39 being  odd Nat st (( ( B35 .cut (B36 , B37) ) . B38 ) = ( B35 . B39 ) & B39 = ( ( B36 + B38 ) - 1 ) & B39 <= ( len B35 )))))))
proof
let C41 being _Graph;
let C42 being (Walk of C41);
let C43 , C44 , C45 being  odd Nat;
assume that
L166: C43 <= C44
and
L167: C44 <= ( len C42 )
and
L168: C45 <= ( len ( C42 .cut (C43 , C44) ) );
set D15 = ( ( C43 + C45 ) - 1 );
L169: (C43 >= 1 & C45 >= 1) by ABIAN:12;
L170: ( C43 + C45 ) >= ( 1 + 1 ) by L169 , XREAL_1:7;
L171: ( ( C43 + C45 ) - 1 ) >= ( ( 1 + 1 ) - 1 ) by L170 , XREAL_1:9;
L172: D15 is  odd  odd  odd  odd (Element of ( NAT )) by L171 , INT_1:3;
reconsider D16 = D15 as  odd Nat by L172;
take D16;
reconsider D17 = C43 , D18 = C44 as  odd (Element of ( NAT )) by ORDINAL1:def 12;
L173: C45 >= 1 by ABIAN:12;
L174: ( C45 - 1 ) >= ( 1 - 1 ) by L173 , XREAL_1:9;
reconsider D19 = ( C45 - 1 ) as (Element of ( NAT )) by L174 , INT_1:3;
L175: C45 < ( ( len ( C42 .cut (C43 , C44) ) ) + 1 ) by L168 , NAT_1:13;
L176: D19 < ( ( ( len ( C42 .cut (C43 , C44) ) ) + 1 ) - 1 ) by L175 , XREAL_1:9;
thus L177: ( ( C42 .cut (C43 , C44) ) . C45 ) = ( ( C42 .cut (D17 , D18) ) . ( D19 + 1 ) )
.= ( C42 . ( C43 + D19 ) ) by L166 , L167 , L176 , GLIB_001:36
.= ( C42 . D16 );
thus L178: D16 = ( ( C43 + C45 ) - 1 );
L179: ( C43 + C45 ) <= ( ( len ( C42 .cut (C43 , C44) ) ) + C43 ) by L168 , XREAL_1:7;
L180: ( D17 + C45 ) <= ( D18 + 1 ) by L179 , L166 , L167 , GLIB_001:36;
L181: ( ( C43 + C45 ) - 1 ) <= ( ( C44 + 1 ) - 1 ) by L180 , XREAL_1:9;
thus L182: thesis by L181 , L167 , XXREAL_0:2;
end;
registration
let C46 being _Graph;
cluster  -> non  empty for (Walk of C46);
correctness by CARD_1:27;
end;
theorem
L184: (for B40 being _Graph holds (for B41 , B42 being (Walk of B40) holds (B41 is_a_prefix_of B42 implies ( B41 .vertices() ) c= ( B42 .vertices() ))))
proof
let C47 being _Graph;
let C48 , C49 being (Walk of C47);
assume that
L185: C48 c= C49;
let C50 being set;
assume L186: C50 in ( C48 .vertices() );
consider C51 being  odd (Element of ( NAT )) such that L187: C51 <= ( len C48 ) and L188: ( C48 . C51 ) = C50 by L186 , GLIB_001:87;
L189: 1 <= C51 by ABIAN:12;
L190: C51 in ( dom C48 ) by L189 , L187 , FINSEQ_3:25;
L191: ( C49 . C51 ) = C50 by L190 , L185 , L188 , GRFUNC_1:2;
L192: ( len C48 ) <= ( len C49 ) by L185 , FINSEQ_1:63;
L193: C51 <= ( len C49 ) by L192 , L187 , XXREAL_0:2;
thus L194: thesis by L193 , L191 , GLIB_001:87;
end;
theorem
L195: (for B43 being _Graph holds (for B44 , B45 being (Walk of B43) holds (B44 is_a_prefix_of B45 implies ( B44 .edges() ) c= ( B45 .edges() ))))
proof
let C52 being _Graph;
let C53 , C54 being (Walk of C52);
assume that
L196: C53 c= C54;
let C55 being set;
assume L197: C55 in ( C53 .edges() );
consider C56 being  even (Element of ( NAT )) such that L198: 1 <= C56 and L199: C56 <= ( len C53 ) and L200: ( C53 . C56 ) = C55 by L197 , GLIB_001:99;
L201: C56 in ( dom C53 ) by L198 , L199 , FINSEQ_3:25;
L202: ( C54 . C56 ) = C55 by L201 , L196 , L200 , GRFUNC_1:2;
L203: ( len C53 ) <= ( len C54 ) by L196 , FINSEQ_1:63;
L204: C56 <= ( len C54 ) by L203 , L199 , XXREAL_0:2;
thus L205: thesis by L204 , L198 , L202 , GLIB_001:99;
end;
theorem
L206: (for B46 being _Graph holds (for B47 , B48 being (Walk of B46) holds B47 is_a_prefix_of ( B47 .append B48 )))
proof
let C57 being _Graph;
let C58 , C59 being (Walk of C57);
set D20 = ( C58 .append C59 );
per cases ;
suppose L207: ( C58 .last() ) = ( C59 .first() );

L208: ( len C58 ) <= ( len D20 ) by L207 , GLIB_001:29;
L209: ( dom C58 ) c= ( dom D20 ) by L208 , FINSEQ_3:30;
L210: (for B49 being set holds (B49 in ( dom C58 ) implies ( C58 . B49 ) = ( D20 . B49 ))) by GLIB_001:32;
thus L211: thesis by L210 , L209 , GRFUNC_1:2;
end;
suppose L212: ( C58 .last() ) <> ( C59 .first() );

thus L213: thesis by L212 , GLIB_001:def 10;
end;
end;
theorem
L215: (for B50 being _Graph holds (for B51 , B52 being (Walk of B50) holds ((B51 is  trivial & ( B51 .last() ) = ( B52 .first() )) implies ( B51 .append B52 ) = B52)))
proof
let C60 being _Graph;
let C61 , C62 being (Walk of C60);
assume that
L216: C61 is  trivial
and
L217: ( C61 .last() ) = ( C62 .first() );
L218: ( len C61 ) = 1 by L216 , GLIB_001:126;
L219: ( ( len ( C61 .append C62 ) ) + 1 ) = ( 1 + ( len C62 ) ) by L218 , L217 , GLIB_001:28;
L220:
now
let C63 being Nat;
assume that
L221: 1 <= C63
and
L222: C63 <= ( len ( C61 .append C62 ) );
L223: ( 1 - 1 ) <= ( C63 - 1 ) by L221 , XREAL_1:9;
reconsider D21 = ( C63 - 1 ) as (Element of ( NAT )) by L223 , INT_1:3;
L224: ( C63 - 1 ) < C63 by XREAL_1:44;
L225: ( C63 - 1 ) < ( len C62 ) by L224 , L219 , L222 , XXREAL_0:2;
L226: ( ( C61 .append C62 ) . ( 1 + D21 ) ) = ( C62 . ( D21 + 1 ) ) by L225 , L217 , L218 , GLIB_001:33;
thus L227: ( ( C61 .append C62 ) . C63 ) = ( C62 . C63 ) by L226;
end;
thus L228: thesis by L220 , L219 , FINSEQ_1:14;
end;
theorem
L229: (for B53 being _Graph holds (for B54 , B55 being (Trail of B53) holds ((( B54 .last() ) = ( B55 .first() ) & ( B54 .edges() ) misses ( B55 .edges() )) implies ( B54 .append B55 ) is  Trail-like)))
proof
let C64 being _Graph;
let C65 , C66 being (Trail of C64);
assume that
L230: ( C65 .last() ) = ( C66 .first() )
and
L231: ( C65 .edges() ) misses ( C66 .edges() );
set D22 = ( C65 .append C66 );
L232:
now
let C67 , C68 being  even (Element of ( NAT ));
assume that
L233: 1 <= C67
and
L234: C67 < C68
and
L235: C68 <= ( len D22 );
L236: 1 <= C68 by L233 , L234 , XXREAL_0:2;
L237: C68 in ( dom D22 ) by L236 , L235 , FINSEQ_3:25;
L238: C67 <= ( len D22 ) by L234 , L235 , XXREAL_0:2;
L239: C67 in ( dom D22 ) by L238 , L233 , FINSEQ_3:25;
per cases  by L237 , GLIB_001:34;
suppose L240: C68 in ( dom C65 );

L241: C68 <= ( len C65 ) by L240 , FINSEQ_3:25;
L242: C67 <= ( len C65 ) by L241 , L234 , XXREAL_0:2;
L243: C67 in ( dom C65 ) by L242 , L233 , FINSEQ_3:25;
L244: ( C65 . C67 ) = ( D22 . C67 ) by L243 , GLIB_001:32;
L245: ( C65 . C67 ) <> ( C65 . C68 ) by L233 , L234 , L241 , GLIB_001:138;
thus L246: ( D22 . C67 ) <> ( D22 . C68 ) by L245 , L240 , L244 , GLIB_001:32;
end;
suppose L247: (ex B56 being (Element of ( NAT )) st (B56 < ( len C66 ) & C68 = ( ( len C65 ) + B56 )));

consider C69 being (Element of ( NAT )) such that L248: C69 < ( len C66 ) and L249: C68 = ( ( len C65 ) + C69 ) by L247;
reconsider D23 = C69 as  odd (Element of ( NAT )) by L249;
L250: ( D22 . C68 ) = ( C66 . ( D23 + 1 ) ) by L230 , L248 , L249 , GLIB_001:33;
L251: ( D23 + 1 ) <= ( len C66 ) by L248 , NAT_1:13;
L252: 1 <= ( D23 + 1 ) by NAT_1:11;
L253: ( C66 . ( D23 + 1 ) ) in ( C66 .edges() ) by L252 , L251 , GLIB_001:99;
per cases  by L239 , GLIB_001:34;
suppose L254: C67 in ( dom C65 );

L255: (1 <= C67 & C67 <= ( len C65 )) by L254 , FINSEQ_3:25;
L256: ( C65 . C67 ) in ( C65 .edges() ) by L255 , GLIB_001:99;
L257: ( D22 . C67 ) = ( C65 . C67 ) by L254 , GLIB_001:32;
thus L258: ( D22 . C67 ) <> ( D22 . C68 ) by L257 , L231 , L250 , L253 , L256 , XBOOLE_0:3;
end;
suppose L259: (ex B57 being (Element of ( NAT )) st (B57 < ( len C66 ) & C67 = ( ( len C65 ) + B57 )));

consider C70 being (Element of ( NAT )) such that L260: C70 < ( len C66 ) and L261: C67 = ( ( len C65 ) + C70 ) by L259;
reconsider D24 = C70 as  odd (Element of ( NAT )) by L261;
L262: D24 < D23 by L234 , L249 , L261 , XREAL_1:6;
L263: (1 <= ( D24 + 1 ) & ( D24 + 1 ) < ( D23 + 1 )) by L262 , NAT_1:11 , XREAL_1:6;
L264: ( D22 . C67 ) = ( C66 . ( D24 + 1 ) ) by L230 , L260 , L261 , GLIB_001:33;
thus L265: ( D22 . C67 ) <> ( D22 . C68 ) by L264 , L250 , L251 , L263 , GLIB_001:138;
end;
end;
end;
thus L268: thesis by L232 , GLIB_001:138;
end;
theorem
L269: (for B58 being _Graph holds (for B59 , B60 being (Path of B58) holds ((( B59 .last() ) = ( B60 .first() ) & B59 is  open & B60 is  open & ( B59 .edges() ) misses ( B60 .edges() ) & (( B59 .first() ) in ( B60 .vertices() ) implies ( B59 .first() ) = ( B60 .last() )) & ( ( B59 .vertices() ) /\ ( B60 .vertices() ) ) c= { ( B59 .first() ) , ( B59 .last() ) }) implies ( B59 .append B60 ) is  Path-like)))
proof
let C71 being _Graph;
let C72 , C73 being (Path of C71);
assume that
L270: ( C72 .last() ) = ( C73 .first() )
and
L271: C72 is  open
and
L272: C73 is  open
and
L273: ( C72 .edges() ) misses ( C73 .edges() )
and
L274: (( C72 .first() ) in ( C73 .vertices() ) implies ( C72 .first() ) = ( C73 .last() ))
and
L275: ( ( C72 .vertices() ) /\ ( C73 .vertices() ) ) c= { ( C72 .first() ) , ( C72 .last() ) };
thus L276: ( C72 .append C73 ) is  Trail-like by L270 , L273 , L229;
set D25 = ( C72 .append C73 );
let C74 , C75 being  odd (Element of ( NAT ));
assume that
L277: C74 < C75
and
L278: C75 <= ( len D25 )
and
L279: ( D25 . C74 ) = ( D25 . C75 )
and
L280: (C74 <> 1 or C75 <> ( len D25 ));
L281: 1 <= C74 by ABIAN:12;
L282: 1 <= C75 by ABIAN:12;
L283: C75 in ( dom D25 ) by L282 , L278 , FINSEQ_3:25;
L284: C74 <= ( len D25 ) by L277 , L278 , XXREAL_0:2;
L285: C74 in ( dom D25 ) by L284 , L281 , FINSEQ_3:25;
per cases  by L283 , GLIB_001:34;
suppose L286: (ex B61 being (Element of ( NAT )) st (B61 < ( len C73 ) & C75 = ( ( len C72 ) + B61 )));

consider C76 being (Element of ( NAT )) such that L287: C76 < ( len C73 ) and L288: C75 = ( ( len C72 ) + C76 ) by L286;
L289: ( D25 . C75 ) = ( C73 . ( C76 + 1 ) ) by L270 , L287 , L288 , GLIB_001:33;
reconsider D26 = C76 as  even (Element of ( NAT )) by L288;
L290: ( D26 + 1 ) <= ( len C73 ) by L287 , NAT_1:13;
L291: ( C73 . ( D26 + 1 ) ) in ( C73 .vertices() ) by L290 , GLIB_001:87;
per cases  by L285 , GLIB_001:34;
suppose L292: (ex B62 being (Element of ( NAT )) st (B62 < ( len C73 ) & C74 = ( ( len C72 ) + B62 )));

consider C77 being (Element of ( NAT )) such that L293: C77 < ( len C73 ) and L294: C74 = ( ( len C72 ) + C77 ) by L292;
L295: ( D25 . C74 ) = ( C73 . ( C77 + 1 ) ) by L270 , L293 , L294 , GLIB_001:33;
L296: C77 < D26 by L277 , L288 , L294 , XREAL_1:6;
L297: ( C77 + 1 ) < ( D26 + 1 ) by L296 , XREAL_1:6;
reconsider D27 = C77 as  even (Element of ( NAT )) by L294;
L298: ( D27 + 1 ) is  odd;
L299: ( C73 .last() ) = ( C73 . ( D26 + 1 ) ) by L298 , L279 , L289 , L290 , L295 , L297 , GLIB_001:def 28;
L300: ( C73 .first() ) = ( C73 . ( D27 + 1 ) ) by L279 , L289 , L290 , L295 , L297 , GLIB_001:def 28;
thus L301: contradiction by L300 , L272 , L279 , L289 , L295 , L299 , GLIB_001:def 24;
end;
suppose L302: C74 in ( dom C72 );

set D28 = ( C72 . C74 );
L303: ( C72 . C74 ) = ( D25 . C74 ) by L302 , GLIB_001:32;
L304: C74 <= ( len C72 ) by L302 , FINSEQ_3:25;
L305: ( C72 . C74 ) in ( C72 .vertices() ) by L304 , GLIB_001:87;
L306: D28 in ( ( C72 .vertices() ) /\ ( C73 .vertices() ) ) by L305 , L279 , L289 , L291 , L303 , XBOOLE_0:def 4;
per cases  by L275 , L306 , TARSKI:def 2;
suppose L307: D28 = ( C72 .last() );

L308:
now
assume L309: C74 < ( len C72 );
L310: ( C72 .first() ) = ( C72 . C74 ) by L309 , L307 , GLIB_001:def 28;
thus L311: contradiction by L310 , L271 , L307 , GLIB_001:def 24;
end;
L312:
now
assume L313: ( ( 2 * ( 0 ) ) + 1 ) < ( D26 + 1 );
L314: ( C73 .first() ) = ( C73 .last() ) by L313 , L270 , L279 , L289 , L290 , L303 , L307 , GLIB_001:def 28;
thus L315: contradiction by L314 , L272 , GLIB_001:def 24;
end;
L316: 1 <= ( D26 + 1 ) by NAT_1:11;
L317: 1 = ( D26 + 1 ) by L316 , L312 , XXREAL_0:1;
thus L318: contradiction by L317 , L277 , L288 , L308;
end;
suppose L319: D28 = ( C72 .first() );

L320: D28 = ( C72 . ( ( 2 * ( 0 ) ) + 1 ) ) by L319;
L321:
now
assume L322: C74 <> 1;
L323: 1 < C74 by L322 , L281 , XXREAL_0:1;
L324: D28 = ( C72 .last() ) by L323 , L304 , L320 , GLIB_001:def 28;
thus L325: contradiction by L324 , L271 , L319 , GLIB_001:def 24;
end;
L326:
now
assume L327: ( D26 + 1 ) = ( len C73 );
L328: ( ( len D25 ) + 1 ) = ( ( len C72 ) + ( D26 + 1 ) ) by L327 , L270 , GLIB_001:28;
thus L329: contradiction by L328 , L280 , L288 , L321;
end;
L330: ( D26 + 1 ) < ( len C73 ) by L326 , L290 , XXREAL_0:1;
L331: ( C73 . ( D26 + 1 ) ) = ( C73 .last() ) by L274 , L279 , L289 , L291 , L302 , L319 , GLIB_001:32;
L332: ( C73 .first() ) = ( C73 .last() ) by L331 , L330 , GLIB_001:def 28;
thus L333: contradiction by L332 , L272 , GLIB_001:def 24;
end;
end;
end;
suppose L336: C75 in ( dom C72 );

L337: C75 <= ( len C72 ) by L336 , FINSEQ_3:25;
L338: (1 <= C74 & C74 <= ( len C72 )) by L337 , L277 , ABIAN:12 , XXREAL_0:2;
L339: C74 in ( dom C72 ) by L338 , FINSEQ_3:25;
L340: ( C72 . C74 ) = ( D25 . C74 ) by L339 , GLIB_001:32
.= ( C72 . C75 ) by L279 , L336 , GLIB_001:32;
L341: C74 = 1 by L340 , L277 , L337 , GLIB_001:def 28;
L342: ( C72 .first() ) = ( C72 .last() ) by L341 , L277 , L337 , L340 , GLIB_001:def 28;
thus L343: contradiction by L342 , L271 , GLIB_001:def 24;
end;
end;
theorem
L345: (for B63 being _Graph holds (for B64 , B65 being (Path of B63) holds ((( B64 .last() ) = ( B65 .first() ) & B64 is  open & B65 is  open & ( ( B64 .vertices() ) /\ ( B65 .vertices() ) ) = { ( B64 .last() ) }) implies ( B64 .append B65 ) is  open  Path-like)))
proof
let C78 being _Graph;
let C79 , C80 being (Path of C78);
assume that
L346: ( C79 .last() ) = ( C80 .first() )
and
L347: C79 is  open
and
L348: C80 is  open
and
L349: ( ( C79 .vertices() ) /\ ( C80 .vertices() ) ) = { ( C79 .last() ) };
set D29 = ( C79 .append C80 );
thus L350: D29 is  open
proof
assume L351: ( D29 .first() ) = ( D29 .last() );
L352: (( D29 .first() ) = ( C79 .first() ) & ( D29 .last() ) = ( C80 .last() )) by L346 , GLIB_001:30;
L353: (( C79 .first() ) in ( C79 .vertices() ) & ( C79 .first() ) in ( C80 .vertices() )) by L352 , L351 , GLIB_001:88;
L354: ( C79 .first() ) in { ( C79 .last() ) } by L353 , L349 , XBOOLE_0:def 4;
L355: ( C79 .first() ) = ( C79 .last() ) by L354 , TARSKI:def 1;
thus L356: contradiction by L355 , L347 , GLIB_001:def 24;
end;

L357:
now
L358: ( C79 .first() ) in ( C79 .vertices() ) by GLIB_001:88;
assume L359: ( C79 .first() ) in ( C80 .vertices() );
L360: ( C79 .first() ) in { ( C79 .last() ) } by L359 , L349 , L358 , XBOOLE_0:def 4;
L361: ( C79 .first() ) = ( C79 .last() ) by L360 , TARSKI:def 1;
thus L362: contradiction by L361 , L347 , GLIB_001:def 24;
end;
L363: ( C79 .edges() ) misses ( C80 .edges() )
proof
assume L364: ( ( C79 .edges() ) /\ ( C80 .edges() ) ) <> ( {} );
consider C81 being set such that L365: C81 in ( ( C79 .edges() ) /\ ( C80 .edges() ) ) by L364 , XBOOLE_0:def 1;
L366: C81 in ( C80 .edges() ) by L365 , XBOOLE_0:def 4;
consider C82 , C83 being (Vertex of C78), C84 being  odd (Element of ( NAT )) such that L367: ( C84 + 2 ) <= ( len C80 ) and L368: C82 = ( C80 . C84 ) and L369: C81 = ( C80 . ( C84 + 1 ) ) and L370: C83 = ( C80 . ( C84 + 2 ) ) and L371: C81 Joins C82 , C83 , C78 by L366 , GLIB_001:103;
L372: C81 in ( C79 .edges() ) by L365 , XBOOLE_0:def 4;
consider C85 , C86 being (Vertex of C78), C87 being  odd (Element of ( NAT )) such that L373: ( C87 + 2 ) <= ( len C79 ) and L374: C85 = ( C79 . C87 ) and L375: C81 = ( C79 . ( C87 + 1 ) ) and L376: C86 = ( C79 . ( C87 + 2 ) ) and L377: C81 Joins C85 , C86 , C78 by L372 , GLIB_001:103;
L378: ( C87 + ( 0 ) ) < ( C87 + 2 ) by XREAL_1:8;
per cases ;
suppose L379: C85 <> C86;

L380: C87 <= ( len C79 ) by L373 , L378 , XXREAL_0:2;
L381: C85 in ( C79 .vertices() ) by L380 , L374 , GLIB_001:87;
L382: C86 in ( C79 .vertices() ) by L373 , L376 , GLIB_001:87;
L383: { C85 , C86 } c= ( C79 .vertices() ) by L382 , L381 , ZFMISC_1:32;
L384: ( C84 + ( 0 ) ) < ( C84 + 2 ) by XREAL_1:8;
L385: C84 <= ( len C80 ) by L384 , L367 , XXREAL_0:2;
L386: C82 in ( C80 .vertices() ) by L385 , L368 , GLIB_001:87;
L387: C83 in ( C80 .vertices() ) by L367 , L370 , GLIB_001:87;
L388: { C82 , C83 } c= ( C80 .vertices() ) by L387 , L386 , ZFMISC_1:32;
L389: ((C85 = C82 & C86 = C83) or (C85 = C83 & C86 = C82)) by L377 , L371 , GLIB_000:15;
L390: C85 = ( C79 .last() ) by L389 , L349 , L383 , L388 , XBOOLE_1:19 , ZFMISC_1:20;
thus L391: contradiction by L390 , L349 , L379 , L389 , L383 , L388 , XBOOLE_1:19 , ZFMISC_1:20;
end;
suppose L392: C85 = C86;

L393: ( C79 .first() ) = C85 by L392 , L373 , L374 , L376 , L378 , GLIB_001:def 28
.= ( C79 .last() ) by L373 , L374 , L376 , L378 , L392 , GLIB_001:def 28;
thus L394: contradiction by L393 , L347 , GLIB_001:def 24;
end;
end;
L396: ( ( C79 .vertices() ) /\ ( C80 .vertices() ) ) c= { ( C79 .first() ) , ( C79 .last() ) } by L349 , ZFMISC_1:7;
thus L397: thesis by L396 , L346 , L347 , L348 , L363 , L357 , L269;
end;
theorem
L398: (for B66 being _Graph holds (for B67 , B68 being (Path of B66) holds ((( B67 .last() ) = ( B68 .first() ) & ( B68 .last() ) = ( B67 .first() ) & B67 is  open & B68 is  open & ( B67 .edges() ) misses ( B68 .edges() ) & ( ( B67 .vertices() ) /\ ( B68 .vertices() ) ) = { ( B67 .last() ) , ( B67 .first() ) }) implies ( B67 .append B68 ) is  Cycle-like)))
proof
let C88 being _Graph;
let C89 , C90 being (Path of C88);
assume that
L399: ( C89 .last() ) = ( C90 .first() )
and
L400: ( C90 .last() ) = ( C89 .first() )
and
L401: C89 is  open
and
L402: (C90 is  open & ( C89 .edges() ) misses ( C90 .edges() ) & ( ( C89 .vertices() ) /\ ( C90 .vertices() ) ) = { ( C89 .last() ) , ( C89 .first() ) });
set D30 = ( C89 .append C90 );
L403: (( D30 .first() ) = ( C89 .first() ) & ( D30 .last() ) = ( C90 .last() )) by L399 , GLIB_001:30;
thus L404: D30 is  closed by L403 , L400 , GLIB_001:def 24;
thus L405: D30 is  Path-like by L399 , L400 , L401 , L402 , L269;
L406: ( C89 .first() ) <> ( C89 .last() ) by L401 , GLIB_001:def 24;
L407: C89 is non  trivial by L406 , GLIB_001:127;
L408: ( len C89 ) >= 3 by L407 , GLIB_001:125;
L409: ( len D30 ) >= ( len C89 ) by L399 , GLIB_001:29;
L410: ( len D30 ) >= 3 by L409 , L408 , XXREAL_0:2;
thus L411: thesis by L410 , GLIB_001:125;
end;
theorem
L412: (for B69 being  simple _Graph holds (for B70 , B71 being (Walk of B69) holds (for B72 being  odd Nat holds ((B72 <= ( len B70 ) & B72 <= ( len B71 ) & (for B73 being  odd Nat holds (B73 <= B72 implies ( B70 . B73 ) = ( B71 . B73 )))) implies (for B74 being Nat holds ((1 <= B74 & B74 <= B72) implies ( B70 . B74 ) = ( B71 . B74 )))))))
proof
let C91 being  simple _Graph;
let C92 , C93 being (Walk of C91);
let C94 being  odd Nat;
assume that
L413: C94 <= ( len C92 )
and
L414: C94 <= ( len C93 )
and
L415: (for B75 being  odd Nat holds (B75 <= C94 implies ( C92 . B75 ) = ( C93 . B75 )));
let C95 being Nat;
assume that
L416: 1 <= C95
and
L417: C95 <= C94;
per cases ;
suppose L418: C95 is  odd;

thus L419: thesis by L418 , L415 , L417;
end;
suppose L420: C95 is  even;

reconsider D31 = C95 as  even Nat by L420;
L421: ( 1 - 1 ) <= ( C95 - 1 ) by L416 , XREAL_1:9;
reconsider D32 = ( D31 - 1 ) as  odd (Element of ( NAT )) by L421 , INT_1:3;
L422: D32 < C95 by XREAL_1:44;
L423: C95 <= ( len C92 ) by L413 , L417 , XXREAL_0:2;
L424: D32 < ( len C92 ) by L423 , L422 , XXREAL_0:2;
L425: ( C92 . ( D32 + 1 ) ) Joins ( C92 . D32 ) , ( C92 . ( D32 + 2 ) ) , C91 by L424 , GLIB_001:def 3;
L426: ( D32 + 1 ) < C94 by L417 , XXREAL_0:1;
L427: ( ( D32 + 1 ) + 1 ) <= C94 by L426 , NAT_1:13;
L428: ( C92 . ( D32 + 2 ) ) = ( C93 . ( D32 + 2 ) ) by L427 , L415;
L429: C95 <= ( len C93 ) by L414 , L417 , XXREAL_0:2;
L430: D32 < ( len C93 ) by L429 , L422 , XXREAL_0:2;
L431: ( C93 . ( D32 + 1 ) ) Joins ( C93 . D32 ) , ( C93 . ( D32 + 2 ) ) , C91 by L430 , GLIB_001:def 3;
L432: ( C92 . D32 ) = ( C93 . D32 ) by L415 , L417 , L422 , XXREAL_0:2;
thus L433: thesis by L432 , L425 , L431 , L428 , GLIB_000:def 20;
end;
end;
theorem
L435: (for B76 being _Graph holds (for B77 , B78 being (Walk of B76) holds (( B77 .first() ) = ( B78 .first() ) implies ( len ( maxPrefix (B77 , B78) ) ) is  odd)))
proof
let C96 being _Graph;
let C97 , C98 being (Walk of C96);
assume that
L436: ( C97 .first() ) = ( C98 .first() )
and
L437: ( len ( maxPrefix (C97 , C98) ) ) is  even;
set D33 = ( len ( maxPrefix (C97 , C98) ) );
reconsider D34 = ( D33 - 1 ) as  odd (Element of ( NAT )) by L436 , L437 , L73 , INT_1:5;
L438: D34 < D33 by XREAL_1:146;
set D35 = ( maxPrefix (C97 , C98) );
set D36 = ( D35 ^ <* ( C97 . ( D33 + 1 ) ) *> );
L439: ( len D36 ) = ( ( len D35 ) + 1 ) by FINSEQ_2:16;
L440:
now
let C99 being set;
assume that
L441: C99 in ( dom D36 );
reconsider D37 = C99 as Nat by L441;
L442: 1 <= D37 by L441 , FINSEQ_3:25;
L443: D37 <= ( len D36 ) by L441 , FINSEQ_3:25;
L444: D37 <= ( ( len D35 ) + 1 ) by L443 , FINSEQ_2:16;
per cases  by L444 , NAT_1:8;
suppose L445: D37 <= D33;

L446: D37 in ( dom D35 ) by L445 , L442 , FINSEQ_3:25;
thus L447: ( D36 . C99 ) = ( D35 . C99 ) by L446 , FINSEQ_1:def 7
.= ( C97 . C99 ) by L445 , L81;
end;
suppose L448: D37 = ( D33 + 1 );

thus L449: ( D36 . C99 ) = ( C97 . C99 ) by L448 , FINSEQ_1:42;
end;
end;
L451: D33 = ( D34 + 1 );
L452: D33 <= ( len C98 ) by L60;
L453: D34 < ( len C98 ) by L452 , XREAL_1:146 , XXREAL_0:2;
L454: ( C98 . D33 ) Joins ( C98 . D34 ) , ( C98 . ( D34 + 2 ) ) , C96 by L453 , L451 , GLIB_001:def 3;
L455: D33 <= ( len C97 ) by L60;
L456: D34 < ( len C97 ) by L455 , XREAL_1:146 , XXREAL_0:2;
L457: ( C97 . D33 ) Joins ( C97 . D34 ) , ( C97 . ( D34 + 2 ) ) , C96 by L456 , L451 , GLIB_001:def 3;
L458: ( C97 . D33 ) = ( C98 . D33 ) by L93;
L459: ((( C97 . D34 ) = ( C98 . D34 ) & ( C97 . ( D34 + 2 ) ) = ( C98 . ( D34 + 2 ) )) or (( C97 . D34 ) = ( C98 . ( D34 + 2 ) ) & ( C97 . ( D34 + 2 ) ) = ( C98 . D34 ))) by L458 , L457 , L454 , GLIB_000:15;
L460:
now
let C100 being set;
assume that
L461: C100 in ( dom D36 );
reconsider D38 = C100 as Nat by L461;
L462: 1 <= D38 by L461 , FINSEQ_3:25;
L463: D38 <= ( len D36 ) by L461 , FINSEQ_3:25;
L464: D38 <= ( ( len D35 ) + 1 ) by L463 , FINSEQ_2:16;
per cases  by L464 , NAT_1:8;
suppose L465: D38 <= D33;

L466: D38 in ( dom D35 ) by L465 , L462 , FINSEQ_3:25;
thus L467: ( D36 . C100 ) = ( D35 . C100 ) by L466 , FINSEQ_1:def 7
.= ( C98 . C100 ) by L465 , L81;
end;
suppose L468: D38 = ( D33 + 1 );

thus L469: ( D36 . C100 ) = ( C97 . ( D33 + 1 ) ) by L468 , FINSEQ_1:42
.= ( C98 . C100 ) by L438 , L459 , L468 , L93;
end;
end;
L471: D33 < ( len C98 ) by L437 , L452 , XXREAL_0:1;
L472: ( len D36 ) <= ( len C98 ) by L471 , L439 , NAT_1:13;
L473: ( dom D36 ) c= ( dom C98 ) by L472 , FINSEQ_3:30;
L474: D36 c= C98 by L473 , L460 , GRFUNC_1:2;
L475: D33 < ( len C97 ) by L437 , L455 , XXREAL_0:1;
L476: ( len D36 ) <= ( len C97 ) by L475 , L439 , NAT_1:13;
L477: ( dom D36 ) c= ( dom C97 ) by L476 , FINSEQ_3:30;
L478: D36 c= C97 by L477 , L440 , GRFUNC_1:2;
L479: D36 c= D35 by L478 , L474 , L19;
L480: ( len D36 ) <= ( len D35 ) by L479 , FINSEQ_1:63;
L481: ( ( len D35 ) + 1 ) <= ( len D35 ) by L480 , FINSEQ_2:16;
thus L482: contradiction by L481 , NAT_1:13;
end;
theorem
L483: (for B79 being _Graph holds (for B80 , B81 being (Walk of B79) holds ((( B80 .first() ) = ( B81 .first() ) & (not B80 is_a_prefix_of B81)) implies ( ( len ( maxPrefix (B80 , B81) ) ) + 2 ) <= ( len B80 ))))
proof
let C101 being _Graph;
let C102 , C103 being (Walk of C101);
assume L484: (( C102 .first() ) = ( C103 .first() ) & (not C102 c= C103));
L485: (( len ( maxPrefix (C102 , C103) ) ) < ( len C102 ) & ( len ( maxPrefix (C102 , C103) ) ) is  odd  odd  odd  odd Nat) by L484 , L96 , L435;
thus L486: thesis by L485 , CHORD:4;
end;
theorem
L487: (for B82 being  non-multi _Graph holds (for B83 , B84 being (Walk of B82) holds ((( B83 .first() ) = ( B84 .first() ) & (not B83 is_a_prefix_of B84) & (not B84 is_a_prefix_of B83)) implies ( B83 . ( ( len ( maxPrefix (B83 , B84) ) ) + 2 ) ) <> ( B84 . ( ( len ( maxPrefix (B83 , B84) ) ) + 2 ) ))))
proof
let C104 being  non-multi _Graph;
let C105 , C106 being (Walk of C104);
assume that
L488: ( C105 .first() ) = ( C106 .first() )
and
L489: (not C105 c= C106)
and
L490: (not C106 c= C105)
and
L491: ( C105 . ( ( len ( maxPrefix (C105 , C106) ) ) + 2 ) ) = ( C106 . ( ( len ( maxPrefix (C105 , C106) ) ) + 2 ) );
set D39 = ( len ( maxPrefix (C105 , C106) ) );
L492: D39 is  odd by L488 , L435;
L493: D39 < ( len C105 ) by L489 , L96;
L494: ( C105 . ( D39 + 1 ) ) Joins ( C105 . D39 ) , ( C105 . ( D39 + 2 ) ) , C104 by L493 , L492 , GLIB_001:def 3;
L495: ( C105 . D39 ) = ( C106 . D39 ) by L93;
L496: D39 < ( len C106 ) by L490 , L96;
L497: ( C106 . ( D39 + 1 ) ) Joins ( C106 . D39 ) , ( C106 . ( D39 + 2 ) ) , C104 by L496 , L492 , GLIB_001:def 3;
L498: ( C105 . ( D39 + 1 ) ) <> ( C106 . ( D39 + 1 ) ) by L489 , L490 , L113;
thus L499: contradiction by L498 , L491 , L495 , L494 , L497 , GLIB_000:def 20;
end;
begin
definition
mode _Tree
 is  Tree-like _Graph;
let C107 being _Graph;
mode _Subtree of C107
 is  Tree-like (Subgraph of C107);
end;
registration
let C108 being _Tree;
cluster  Trail-like ->  Path-like for (Walk of C108);
correctness
proof
let C109 being (Walk of C108);
assume that
L501: C109 is  Trail-like;
defpred S2[ Nat ] means ($1 is  odd & $1 <= ( len C109 ) & (ex B85 being  odd (Element of ( NAT )) st (B85 < $1 & ( C109 . B85 ) = ( C109 . $1 ))));
assume L502: (not C109 is  Path-like);
L503: (ex B86 , B87 being  odd (Element of ( NAT )) st (B86 < B87 & B87 <= ( len C109 ) & ( C109 . B86 ) = ( C109 . B87 ) & (B86 <> 1 or B87 <> ( len C109 )))) by L502 , L501 , GLIB_001:def 28;
L504: (ex B88 being Nat st S2[ B88 ]) by L503;
consider C110 being Nat such that L505: S2[ C110 ] and L506: (for B89 being Nat holds (S2[ B89 ] implies C110 <= B89)) from NAT_1:sch 5(L504);
reconsider D40 = C110 as (Element of ( NAT )) by ORDINAL1:def 12;
consider C111 being  odd (Element of ( NAT )) such that L507: C111 < C110 and L508: C110 <= ( len C109 ) and L509: ( C109 . C111 ) = ( C109 . C110 ) by L505;
set D41 = ( C109 .cut (C111 , D40) );
L510: ( ( len D41 ) + C111 ) = ( D40 + 1 ) by L505 , L507 , GLIB_001:36;
L511: ( len D41 ) <> 1 by L510 , L507;
L512: D41 is non  trivial by L511 , GLIB_001:126;
L513: ( D41 .last() ) = ( C109 . C110 ) by L505 , L507 , GLIB_001:37;
L514: D41 is  Path-like
proof
assume L515: (not thesis);
consider C112 , C113 being  odd (Element of ( NAT )) such that L516: C112 < C113 and L517: C113 <= ( len D41 ) and L518: ( D41 . C112 ) = ( D41 . C113 ) and L519: (C112 <> 1 or C113 <> ( len D41 )) by L515 , L501 , GLIB_001:def 28;
L520: C112 < ( len D41 ) by L516 , L517 , XXREAL_0:2;
consider C114 being  odd Nat such that L521: ( D41 . C113 ) = ( C109 . C114 ) and L522: C114 = ( ( C111 + C113 ) - 1 ) and L523: C114 <= ( len C109 ) by L505 , L507 , L517 , L165;
reconsider D42 = C114 as  odd (Element of ( NAT )) by ORDINAL1:def 12;
L524: 1 <= C112 by ABIAN:12;
L525: C112 <= ( len D41 ) by L516 , L517 , XXREAL_0:2;
consider C115 being  odd Nat such that L526: ( D41 . C112 ) = ( C109 . C115 ) and L527: C115 = ( ( C111 + C112 ) - 1 ) and L528: C115 <= ( len C109 ) by L525 , L505 , L507 , L165;
reconsider D43 = C115 as  odd (Element of ( NAT )) by ORDINAL1:def 12;
per cases  by L517 , XXREAL_0:1;
suppose L529: C113 < ( len D41 );

L530: ( C111 + C113 ) < ( C111 + ( len D41 ) ) by L529 , XREAL_1:6;
L531: ( C111 + C113 ) < ( C110 + 1 ) by L530 , L505 , L507 , GLIB_001:36;
L532: D42 < C110 by L531 , L522 , XREAL_1:19;
L533: ( C111 + C112 ) < ( C111 + C113 ) by L516 , XREAL_1:6;
L534: D43 < D42 by L533 , L527 , L522 , XREAL_1:9;
thus L535: contradiction by L534 , L506 , L518 , L526 , L521 , L523 , L532;
end;
suppose L536: C113 = ( len D41 );

L537: ( C111 + C112 ) < ( ( len D41 ) + C111 ) by L520 , XREAL_1:6;
L538: ( C111 + C112 ) < ( C110 + 1 ) by L537 , L505 , L507 , GLIB_001:36;
L539: D43 < C110 by L538 , L527 , XREAL_1:19;
L540: 1 < C112 by L519 , L524 , L536 , XXREAL_0:1;
L541: ( C111 + 1 ) < ( C111 + C112 ) by L540 , XREAL_1:6;
L542: C111 < D43 by L541 , L527 , XREAL_1:20;
thus L543: contradiction by L542 , L506 , L509 , L513 , L518 , L526 , L528 , L536 , L539;
end;
end;
L545: ( D41 .first() ) = ( C109 . C111 ) by L505 , L507 , GLIB_001:37;
L546: D41 is  closed by L545 , L509 , L513 , GLIB_001:def 24;
L547: D41 is  Cycle-like by L546 , L512 , L514 , GLIB_001:def 31;
thus L548: contradiction by L547 , GLIB_002:def 2;
end;
end;
theorem
L550: (for B90 being _Tree holds (for B91 being (Path of B90) holds (B91 is non  trivial implies B91 is  open)))
proof
let C116 being _Tree;
let C117 being (Path of C116);
assume L551: (not thesis);
L552: C117 is  Cycle-like by L551 , GLIB_001:def 31;
thus L553: contradiction by L552 , GLIB_002:def 2;
end;
registration
let C118 being _Tree;
cluster non  trivial ->  open for (Path of C118);
correctness by L550;
end;
theorem
L555: (for B92 being _Tree holds (for B93 being (Path of B92) holds (for B94 , B95 being  odd Nat holds ((B94 < B95 & B95 <= ( len B93 )) implies ( B93 . B94 ) <> ( B93 . B95 )))))
proof
let C119 being _Tree;
let C120 being (Path of C119);
let C121 , C122 being  odd Nat;
assume that
L556: C121 < C122
and
L557: C122 <= ( len C120 )
and
L558: ( C120 . C121 ) = ( C120 . C122 );
reconsider D44 = C121 , D45 = C122 as  odd (Element of ( NAT )) by ORDINAL1:def 12;
L559: D44 < D45 by L556;
L560: D44 = 1 by L559 , L557 , L558 , GLIB_001:def 28;
L561: C120 is non  trivial by L560 , L556 , L557 , GLIB_001:126;
L562: ( C120 .first() ) = ( C120 .last() ) by L557 , L558 , L559 , L560 , GLIB_001:def 28;
thus L563: contradiction by L562 , L561 , GLIB_001:def 24;
end;
theorem
L564: (for B96 being _Tree holds (for B97 , B98 being (Vertex of B96) holds (for B99 , B100 being (Path of B96) holds ((B99 is_Walk_from B97 , B98 & B100 is_Walk_from B97 , B98) implies B99 = B100))))
proof
let C123 being _Tree;
let C124 , C125 being (Vertex of C123);
let C126 , C127 being (Path of C123);
assume that
L565: C126 is_Walk_from C124 , C125
and
L566: C127 is_Walk_from C124 , C125;
set D46 = ( len ( maxPrefix (C126 , C127) ) );
L567: (( C126 .first() ) = C124 & ( C127 .first() ) = C124) by L565 , L566 , GLIB_001:def 23;
reconsider D47 = D46 as  odd (Element of ( NAT )) by L567 , L435;
defpred S3[ Nat ] means ($1 is  odd & D47 < $1 & $1 <= ( len C127 ) & ( C127 . $1 ) in ( C126 .vertices() ));
assume L568: C126 <> C127;
L569: (not C127 c= C126)
proof
assume L570: C127 c= C126;
L571: ( len C127 ) <= ( len C126 ) by L570 , FINSEQ_1:63;
L572: ( len C127 ) < ( len C126 ) by L571 , L568 , L570 , FINSEQ_2:129 , XXREAL_0:1;
L573: 1 <= ( len C127 ) by ABIAN:12;
L574: ( len C127 ) in ( dom C127 ) by L573 , FINSEQ_3:25;
L575: ( C127 . ( len C127 ) ) = ( C126 . ( len C127 ) ) by L574 , L570 , GRFUNC_1:2;
L576: ( C126 . ( len C126 ) ) = ( C126 .last() )
.= C125 by L565 , GLIB_001:def 23;
L577: ( C127 . ( len C127 ) ) = ( C127 .last() )
.= C125 by L566 , GLIB_001:def 23;
thus L578: contradiction by L577 , L572 , L575 , L576 , L555;
end;
L579: (ex B101 being Nat st S3[ B101 ])
proof
take D48 = ( len C127 );
thus L580: D48 is  odd;
L581: (( D47 + 2 ) <= ( len C127 ) & D47 < ( D47 + 2 )) by L567 , L569 , L483 , NAT_1:19;
thus L582: D47 < D48 by L581 , XXREAL_0:2;
thus L583: D48 <= ( len C127 );
L584: ( C127 . D48 ) = ( C127 .last() )
.= C125 by L566 , GLIB_001:def 23
.= ( C126 .last() ) by L565 , GLIB_001:def 23;
thus L585: thesis by L584 , GLIB_001:88;
end;
consider C128 being Nat such that L586: S3[ C128 ] and L587: (for B102 being Nat holds (S3[ B102 ] implies C128 <= B102)) from NAT_1:sch 5(L579);
reconsider D49 = C128 as  odd (Element of ( NAT )) by L586 , ORDINAL1:def 12;
set D50 = ( C127 . D49 );
set D51 = ( C126 .find D50 );
set D52 = ( C127 .cut (D47 , D49) );
set D53 = ( C126 .cut (D47 , D51) );
L588: D51 <= ( len C126 ) by L586 , GLIB_001:def 19;
set D54 = ( D53 .reverse() );
L589: ( D54 .vertices() ) = ( D53 .vertices() ) by GLIB_001:92;
set D55 = ( D52 .append D54 );
set D56 = ( C126 . D47 );
L590: ( C127 . D47 ) = ( C126 . D47 ) by L93;
L591: ( D52 .first() ) = D56 by L590 , L586 , GLIB_001:37;
L592: D50 = ( C126 . D51 ) by L586 , GLIB_001:def 19;
L593: ( len C127 ) <> 1
proof
assume L594: ( len C127 ) = 1;
L595: D47 < 1 by L594 , L586 , XXREAL_0:2;
thus L596: contradiction by L595 , ABIAN:12;
end;
L597: (not C127 is  trivial) by L593 , GLIB_001:126;
L598: D47 < D51
proof
assume L599: D47 >= D51;
L600: (( C126 . D51 ) = ( C127 . D51 ) & D49 > D51) by L599 , L586 , L93 , XXREAL_0:2;
L601: (( C127 .first() ) = D50 & ( C127 .last() ) = D50) by L600 , L586 , L592 , GLIB_001:def 28;
thus L602: contradiction by L601 , L597 , GLIB_001:def 24;
end;
L603: D53 is non  trivial by L598 , L588 , GLIB_001:131;
L604: C126 is non  trivial by L603;
L605: D51 <= ( len C126 ) by L586 , GLIB_001:def 19;
L606: ( D54 .vertices() ) c= ( C126 .vertices() ) by L605 , L598 , L589 , GLIB_001:94;
L607: ( ( D52 .vertices() ) /\ ( D54 .vertices() ) ) c= { D50 , D56 }
proof
assume L608: (not thesis);
consider C129 being set such that L609: C129 in ( ( D52 .vertices() ) /\ ( D54 .vertices() ) ) and L610: (not C129 in { D50 , D56 }) by L608 , TARSKI:def 3;
L611: C129 in ( D52 .vertices() ) by L609 , XBOOLE_0:def 4;
consider C130 being  odd (Element of ( NAT )) such that L612: C130 <= ( len D52 ) and L613: ( D52 . C130 ) = C129 by L611 , GLIB_001:87;
consider C131 being  odd Nat such that L614: ( C127 . C131 ) = ( D52 . C130 ) and L615: C131 = ( ( D47 + C130 ) - 1 ) and L616: C131 <= ( len C127 ) by L586 , L612 , L165;
reconsider D57 = C131 as  odd (Element of ( NAT )) by ORDINAL1:def 12;
L617: C130 >= 1 by ABIAN:12;
L618: D57 < D49
proof
L619: ( ( len D52 ) + D47 ) = ( D49 + 1 ) by L586 , GLIB_001:36;
assume L620: D57 >= D49;
per cases  by L620 , XXREAL_0:1;
suppose L621: D57 = D49;

L622: ( D52 . C130 ) = ( D52 .last() ) by L621 , L615 , L619
.= D50 by L586 , GLIB_001:37;
thus L623: contradiction by L622 , L610 , L613 , TARSKI:def 2;
end;
suppose L624: D57 > D49;

L625: ( D57 + 1 ) > ( D49 + 1 ) by L624 , XREAL_1:6;
thus L626: contradiction by L625 , L612 , L615 , L619 , XREAL_1:6;
end;
end;
L628: C130 <> 1 by L591 , L610 , L613 , TARSKI:def 2;
L629: C130 > 1 by L628 , L617 , XXREAL_0:1;
L630: D47 < D57
proof
assume L631: D47 >= D57;
L632: ( D47 + C130 ) > ( D57 + 1 ) by L631 , L629 , XREAL_1:8;
thus L633: contradiction by L632 , L615;
end;
L634: C129 in ( D54 .vertices() ) by L609 , XBOOLE_0:def 4;
thus L635: contradiction by L634 , L587 , L606 , L613 , L614 , L616 , L630 , L618;
end;
L636: ( D52 .last() ) = D50 by L586 , GLIB_001:37;
L637: ( D53 .first() ) = D56 by L588 , L598 , GLIB_001:37;
L638: ( D54 .last() ) = D56 by L637 , GLIB_001:22;
L639: ( D53 .last() ) = D50 by L588 , L592 , L598 , GLIB_001:37;
L640: ( D54 .first() ) = D50 by L639 , GLIB_001:22;
L641: { D50 , D56 } c= ( ( D52 .vertices() ) /\ ( D54 .vertices() ) )
proof
let C132 being set;
assume L642: C132 in { D50 , D56 };
per cases  by L642 , TARSKI:def 2;
suppose L643: C132 = D50;

L644: (C132 in ( D52 .vertices() ) & C132 in ( D54 .vertices() )) by L643 , L636 , L640 , GLIB_001:88;
thus L645: thesis by L644 , XBOOLE_0:def 4;
end;
suppose L646: C132 = D56;

L647: (C132 in ( D52 .vertices() ) & C132 in ( D54 .vertices() )) by L646 , L591 , L638 , GLIB_001:88;
thus L648: thesis by L647 , XBOOLE_0:def 4;
end;
end;
L650: ( ( D52 .vertices() ) /\ ( D54 .vertices() ) ) = { D50 , D56 } by L641 , L607 , XBOOLE_0:def 10;
L651: D52 is non  trivial by L586 , GLIB_001:131;
L652: C127 is non  trivial by L651;
L653: (not C126 c= C127)
proof
assume L654: C126 c= C127;
L655: ( len C126 ) <= ( len C127 ) by L654 , FINSEQ_1:63;
L656: ( len C126 ) < ( len C127 ) by L655 , L568 , L654 , FINSEQ_2:129 , XXREAL_0:1;
L657: 1 <= ( len C126 ) by ABIAN:12;
L658: ( len C126 ) in ( dom C126 ) by L657 , FINSEQ_3:25;
L659: ( C126 . ( len C126 ) ) = ( C127 . ( len C126 ) ) by L658 , L654 , GRFUNC_1:2;
L660: ( C127 . ( len C127 ) ) = ( C127 .last() )
.= C125 by L566 , GLIB_001:def 23;
L661: ( C126 . ( len C126 ) ) = ( C126 .last() )
.= C125 by L565 , GLIB_001:def 23;
thus L662: contradiction by L661 , L656 , L659 , L660 , L555;
end;
L663: ( D52 .edges() ) misses ( D54 .edges() )
proof
L664: ( D53 .vertices() ) = ( D54 .vertices() ) by GLIB_001:92;
L665: ( D53 .edges() ) = ( D54 .edges() ) by GLIB_001:107;
assume L666: ( ( D52 .edges() ) /\ ( D54 .edges() ) ) <> ( {} );
consider C133 being set such that L667: C133 in ( ( D52 .edges() ) /\ ( D54 .edges() ) ) by L666 , XBOOLE_0:def 1;
L668: C133 in ( D54 .edges() ) by L667 , XBOOLE_0:def 4;
consider C134 , C135 being (Vertex of C123), C136 being  odd (Element of ( NAT )) such that L669: ( C136 + 2 ) <= ( len D53 ) and L670: C134 = ( D53 . C136 ) and L671: C133 = ( D53 . ( C136 + 1 ) ) and L672: C135 = ( D53 . ( C136 + 2 ) ) and L673: C133 Joins C134 , C135 , C123 by L668 , L665 , GLIB_001:103;
L674: C133 in ( D52 .edges() ) by L667 , XBOOLE_0:def 4;
consider C137 , C138 being (Vertex of C123), C139 being  odd (Element of ( NAT )) such that L675: ( C139 + 2 ) <= ( len D52 ) and L676: C137 = ( D52 . C139 ) and L677: C133 = ( D52 . ( C139 + 1 ) ) and L678: C138 = ( D52 . ( C139 + 2 ) ) and L679: C133 Joins C137 , C138 , C123 by L674 , GLIB_001:103;
L680: ( C139 + ( 0 ) ) < ( C139 + 2 ) by XREAL_1:8;
per cases ;
suppose L681: C137 <> C138;

L682: ( C139 + 2 ) = ( ( C139 + 1 ) + 1 );
L683: ( C139 + 1 ) < ( len D52 ) by L682 , L675 , NAT_1:13;
L684: ( D52 . ( C139 + 2 ) ) = ( C127 . ( D47 + ( C139 + 1 ) ) ) by L683 , L586 , L682 , GLIB_001:36;
consider C140 being Nat such that L685: C139 = ( C140 + 1 ) by NAT_1:6;
reconsider D58 = C140 as (Element of ( NAT )) by ORDINAL1:def 12;
L686: C135 in ( D53 .vertices() ) by L669 , L672 , GLIB_001:87;
L687: ( C136 + ( 0 ) ) < ( C136 + 2 ) by XREAL_1:8;
L688: C136 <= ( len D53 ) by L687 , L669 , XXREAL_0:2;
L689: C134 in ( D53 .vertices() ) by L688 , L670 , GLIB_001:87;
L690: { C134 , C135 } c= ( D54 .vertices() ) by L689 , L664 , L686 , ZFMISC_1:32;
L691: ( C136 + 2 ) = ( ( C136 + 1 ) + 1 );
L692: ( C136 + 1 ) < ( len D53 ) by L691 , L669 , NAT_1:13;
L693: ( D53 . ( C136 + 2 ) ) = ( C126 . ( D47 + ( C136 + 1 ) ) ) by L692 , L588 , L598 , L691 , GLIB_001:36;
L694: C139 <= ( len D52 ) by L675 , L680 , XXREAL_0:2;
L695: C137 in ( D52 .vertices() ) by L694 , L676 , GLIB_001:87;
L696: C138 in ( D52 .vertices() ) by L675 , L678 , GLIB_001:87;
L697: { C137 , C138 } c= ( D52 .vertices() ) by L696 , L695 , ZFMISC_1:32;
L698: ((C137 = C134 & C138 = C135) or (C137 = C135 & C138 = C134)) by L679 , L673 , GLIB_000:15;
L699: (C137 = D50 or C137 = D56) by L698 , L650 , L697 , L690 , XBOOLE_1:19 , ZFMISC_1:22;
L700: ( C139 + ( 0 ) ) < ( C139 + 2 ) by XREAL_1:8;
L701: C139 <= ( len D52 ) by L700 , L675 , XXREAL_0:2;
L702: D58 < ( len D52 ) by L701 , L685 , NAT_1:13;
L703: ( D52 . C139 ) = ( C127 . ( D47 + D58 ) ) by L702 , L586 , L685 , GLIB_001:36;
L704: ( C127 . ( D47 + 2 ) ) = D50
proof
per cases  by L650 , L681 , L698 , L697 , L690 , L699 , XBOOLE_1:19 , ZFMISC_1:22;
suppose L705: (C137 = D50 & C138 = D56);

L706: ( D47 + ( C139 + 2 ) ) <= ( ( len D52 ) + D47 ) by L675 , XREAL_1:6;
L707: ( ( ( D47 + C139 ) + 1 ) + 1 ) <= ( D49 + 1 ) by L706 , L586 , GLIB_001:36;
L708: ( ( D47 + C139 ) + 1 ) <= D49 by L707 , XREAL_1:6;
L709: ( D47 + ( C139 + 1 ) ) <= ( len C127 ) by L708 , L586 , XXREAL_0:2;
L710: D47 <= ( D47 + C139 ) by NAT_1:11;
L711: D47 < ( ( D47 + C139 ) + 1 ) by L710 , NAT_1:13;
L712: (( C127 .first() ) = D56 & ( C127 .last() ) = D56) by L711 , L590 , L678 , L684 , L705 , L709 , GLIB_001:def 28;
thus L713: thesis by L712 , L652 , GLIB_001:def 24;
end;
suppose L714: (C137 = D56 & C138 = D50);

L715: D58 = ( 0 )
proof
L716: ( D47 + D58 ) < ( ( len D52 ) + D47 ) by L702 , XREAL_1:6;
L717: ( D47 + D58 ) < ( D49 + 1 ) by L716 , L586 , GLIB_001:36;
L718: ( D47 + D58 ) <= D49 by L717 , NAT_1:13;
L719: ( D47 + D58 ) <= ( len C127 ) by L718 , L586 , XXREAL_0:2;
assume L720: D58 <> ( 0 );
reconsider D59 = D58 as  even (Element of ( NAT )) by L685;
L721: ( D47 + ( 0 ) ) < ( D47 + D59 ) by L720 , XREAL_1:6;
L722: (( C127 .first() ) = D56 & ( C127 .last() ) = D56) by L721 , L590 , L676 , L703 , L714 , L719 , GLIB_001:def 28;
thus L723: contradiction by L722 , L652 , GLIB_001:def 24;
end;
thus L724: thesis by L715 , L586 , L678 , L685 , L683 , L714 , GLIB_001:36;
end;
end;
consider C141 being Nat such that L726: C136 = ( C141 + 1 ) by NAT_1:6;
L727: (C138 = D50 or C138 = D56) by L650 , L698 , L697 , L690 , XBOOLE_1:19 , ZFMISC_1:22;
reconsider D60 = C141 as (Element of ( NAT )) by ORDINAL1:def 12;
L728: D60 < ( len D53 ) by L688 , L726 , NAT_1:13;
L729: ( D53 . C136 ) = ( C126 . ( D47 + D60 ) ) by L728 , L588 , L598 , L726 , GLIB_001:36;
L730: ( C126 . ( D47 + 2 ) ) = D50
proof
per cases  by L679 , L673 , L681 , L699 , L727 , GLIB_000:15;
suppose L731: (C134 = D50 & C135 = D56);

L732: ( D47 + ( C136 + 2 ) ) <= ( ( len D53 ) + D47 ) by L669 , XREAL_1:6;
L733: ( ( ( D47 + C136 ) + 1 ) + 1 ) <= ( D51 + 1 ) by L732 , L588 , L598 , GLIB_001:36;
L734: ( ( D47 + C136 ) + 1 ) <= D51 by L733 , XREAL_1:6;
L735: ( D47 + ( C136 + 1 ) ) <= ( len C126 ) by L734 , L588 , XXREAL_0:2;
L736: D47 <= ( D47 + C136 ) by NAT_1:11;
L737: D47 < ( ( D47 + C136 ) + 1 ) by L736 , NAT_1:13;
L738: (( C126 .first() ) = D56 & ( C126 .last() ) = D56) by L737 , L672 , L693 , L731 , L735 , GLIB_001:def 28;
thus L739: thesis by L738 , L604 , GLIB_001:def 24;
end;
suppose L740: (C134 = D56 & C135 = D50);

L741: D60 = ( 0 )
proof
L742: ( D47 + D60 ) < ( ( len D53 ) + D47 ) by L728 , XREAL_1:6;
L743: ( D47 + D60 ) < ( D51 + 1 ) by L742 , L588 , L598 , GLIB_001:36;
L744: ( D47 + D60 ) <= D51 by L743 , NAT_1:13;
L745: ( D47 + D60 ) <= ( len C126 ) by L744 , L588 , XXREAL_0:2;
assume L746: D60 <> ( 0 );
reconsider D61 = D60 as  even (Element of ( NAT )) by L726;
L747: ( D47 + ( 0 ) ) < ( D47 + D61 ) by L746 , XREAL_1:6;
L748: (( C126 .first() ) = D56 & ( C126 .last() ) = D56) by L747 , L670 , L729 , L740 , L745 , GLIB_001:def 28;
thus L749: contradiction by L748 , L604 , GLIB_001:def 24;
end;
thus L750: thesis by L741 , L588 , L598 , L672 , L726 , L692 , L740 , GLIB_001:36;
end;
end;
thus L752: contradiction by L730 , L567 , L653 , L569 , L704 , L487;
end;
suppose L753: C137 = C138;

L754: (( D52 .first() ) = C137 & ( D52 .last() ) = C137) by L753 , L675 , L676 , L678 , L680 , GLIB_001:def 28;
thus L755: contradiction by L754 , L651 , GLIB_001:def 24;
end;
end;
L757: D54 is non  trivial by L603 , GLIB_001:129;
L758: D55 is  Cycle-like by L757 , L651 , L591 , L636 , L640 , L638 , L650 , L663 , L398;
thus L759: contradiction by L758;
end;
definition
let C142 being _Tree;
let C143 , C144 being (Vertex of C142);
func C142 .pathBetween (C143 , C144) -> (Path of C142) means 
:L760: it is_Walk_from C143 , C144;
existence
proof
consider C145 being (Walk of C142) such that L761: C145 is_Walk_from C143 , C144 by GLIB_002:def 1;
set D62 = the  Path-like (Subwalk of C145);
take D62;
L762: D62 is_Walk_from ( C145 .first() ) , ( C145 .last() ) by GLIB_001:def 32;
L763: D62 is_Walk_from C143 , ( C145 .last() ) by L762 , L761 , GLIB_001:def 23;
thus L764: thesis by L763 , L761 , GLIB_001:def 23;
end;
uniqueness by L564;
end;
theorem
L766: (for B103 being _Tree holds (for B104 , B105 being (Vertex of B103) holds (( ( B103 .pathBetween (B104 , B105) ) .first() ) = B104 & ( ( B103 .pathBetween (B104 , B105) ) .last() ) = B105)))
proof
let C146 being _Tree;
let C147 , C148 being (Vertex of C146);
L767: ( C146 .pathBetween (C147 , C148) ) is_Walk_from C147 , C148 by L760;
thus L768: ( ( C146 .pathBetween (C147 , C148) ) .first() ) = C147 by L767 , GLIB_001:def 23;
thus L769: thesis by L767 , GLIB_001:def 23;
end;
theorem
L770: (for B106 being _Tree holds (for B107 , B108 being (Vertex of B106) holds (B107 in ( ( B106 .pathBetween (B107 , B108) ) .vertices() ) & B108 in ( ( B106 .pathBetween (B107 , B108) ) .vertices() ))))
proof
let C149 being _Tree;
let C150 , C151 being (Vertex of C149);
L771: ( ( C149 .pathBetween (C150 , C151) ) .first() ) = C150 by L766;
thus L772: C150 in ( ( C149 .pathBetween (C150 , C151) ) .vertices() ) by L771 , GLIB_001:88;
L773: ( ( C149 .pathBetween (C150 , C151) ) .last() ) = C151 by L766;
thus L774: thesis by L773 , GLIB_001:88;
end;
registration
let C152 being _Tree;
let C153 being (Vertex of C152);
cluster ( C152 .pathBetween (C153 , C153) ) ->  closed;
correctness
proof
L775: ( C152 .pathBetween (C153 , C153) ) is_Walk_from C153 , C153 by L760;
thus L776: thesis by L775 , GLIB_001:119;
end;
end;
registration
let C154 being _Tree;
let C155 being (Vertex of C154);
cluster ( C154 .pathBetween (C155 , C155) ) ->  trivial;
correctness;
end;
theorem
L779: (for B109 being _Tree holds (for B110 being (Vertex of B109) holds ( ( B109 .pathBetween (B110 , B110) ) .vertices() ) = { B110 }))
proof
let C156 being _Tree;
let C157 being (Vertex of C156);
set D63 = ( C156 .pathBetween (C157 , C157) );
consider C158 being (Vertex of C156) such that L780: D63 = ( C156 .walkOf C158 ) by GLIB_001:128;
L781: (C157 = ( D63 .first() ) & ( ( C156 .walkOf C158 ) .first() ) = C158) by L766 , GLIB_001:13;
thus L782: thesis by L781 , L780 , GLIB_001:90;
end;
theorem
L783: (for B111 being _Tree holds (for B112 , B113 being (Vertex of B111) holds ( ( B111 .pathBetween (B112 , B113) ) .reverse() ) = ( B111 .pathBetween (B113 , B112) )))
proof
let C159 being _Tree;
let C160 , C161 being (Vertex of C159);
set D64 = ( C159 .pathBetween (C160 , C161) );
L784: D64 is_Walk_from C160 , C161 by L760;
L785: ( D64 .reverse() ) is_Walk_from C161 , C160 by L784 , GLIB_001:23;
thus L786: thesis by L785 , L760;
end;
theorem
L787: (for B114 being _Tree holds (for B115 , B116 being (Vertex of B114) holds ( ( B114 .pathBetween (B115 , B116) ) .vertices() ) = ( ( B114 .pathBetween (B116 , B115) ) .vertices() )))
proof
let C162 being _Tree;
let C163 , C164 being (Vertex of C162);
L788: ( ( C162 .pathBetween (C163 , C164) ) .reverse() ) = ( C162 .pathBetween (C164 , C163) ) by L783;
thus L789: thesis by L788 , GLIB_001:92;
end;
theorem
L790: (for B117 being _Tree holds (for B118 , B119 being (Vertex of B117) holds (for B120 being (_Subtree of B117) holds (for B121 , B122 being (Vertex of B120) holds ((B118 = B121 & B119 = B122) implies ( B117 .pathBetween (B118 , B119) ) = ( B120 .pathBetween (B121 , B122) ))))))
proof
let C165 being _Tree;
let C166 , C167 being (Vertex of C165);
let C168 being (_Subtree of C165);
let C169 , C170 being (Vertex of C168);
assume that
L791: C166 = C169
and
L792: C167 = C170;
set D65 = ( C168 .pathBetween (C169 , C170) );
reconsider D66 = D65 as (Walk of C165) by GLIB_001:167;
L793: D65 is_Walk_from C169 , C170 by L760;
L794: ( D66 .last() ) = ( D65 .last() )
.= C167 by L792 , L793 , GLIB_001:def 23;
L795: ( D66 .first() ) = ( D65 .first() )
.= C166 by L791 , L793 , GLIB_001:def 23;
L796: (D66 is  Path-like & D66 is_Walk_from C166 , C167) by L795 , L794 , GLIB_001:176 , GLIB_001:def 23;
thus L797: thesis by L796 , L760;
end;
theorem
L798: (for B123 being _Tree holds (for B124 , B125 being (Vertex of B123) holds (for B126 being (_Subtree of B123) holds ((B124 in ( the_Vertices_of B126 ) & B125 in ( the_Vertices_of B126 )) implies ( ( B123 .pathBetween (B124 , B125) ) .vertices() ) c= ( the_Vertices_of B126 )))))
proof
let C171 being _Tree;
let C172 , C173 being (Vertex of C171);
let C174 being (_Subtree of C171);
assume L799: (C172 in ( the_Vertices_of C174 ) & C173 in ( the_Vertices_of C174 ));
reconsider D67 = C172 , D68 = C173 as (Vertex of C174) by L799;
set D69 = ( C171 .pathBetween (C172 , C173) );
set D70 = ( C174 .pathBetween (D67 , D68) );
L800: ( D69 .vertices() ) = ( D70 .vertices() ) by L790 , GLIB_001:76;
thus L801: thesis by L800;
end;
theorem
L802: (for B127 being _Tree holds (for B128 being (Path of B127) holds (for B129 , B130 being (Vertex of B127) holds (for B131 , B132 being  odd Nat holds ((B131 <= B132 & B132 <= ( len B128 ) & ( B128 . B131 ) = B129 & ( B128 . B132 ) = B130) implies ( B127 .pathBetween (B129 , B130) ) = ( B128 .cut (B131 , B132) ))))))
proof
let C175 being _Tree;
let C176 being (Path of C175);
let C177 , C178 being (Vertex of C175);
let C179 , C180 being  odd Nat;
assume that
L803: (C179 <= C180 & C180 <= ( len C176 ) & ( C176 . C179 ) = C177 & ( C176 . C180 ) = C178);
reconsider D71 = C179 , D72 = C180 as  odd (Element of ( NAT )) by ORDINAL1:def 12;
L804: ( C176 .cut (D71 , D72) ) is_Walk_from C177 , C178 by L803 , GLIB_001:37;
thus L805: thesis by L804 , L760;
end;
theorem
L806: (for B133 being _Tree holds (for B134 , B135 , B136 being (Vertex of B133) holds (B136 in ( ( B133 .pathBetween (B134 , B135) ) .vertices() ) iff ( B133 .pathBetween (B134 , B135) ) = ( ( B133 .pathBetween (B134 , B136) ) .append ( B133 .pathBetween (B136 , B135) ) ))))
proof
let C181 being _Tree;
let C182 , C183 , C184 being (Vertex of C181);
set D73 = ( C181 .pathBetween (C182 , C183) );
set D74 = ( D73 .find C184 );
set D75 = ( C181 .pathBetween (C182 , C184) );
set D76 = ( C181 .pathBetween (C184 , C183) );
thus L807:now
L808: D73 = ( D73 .cut (1 , ( len D73 )) ) by GLIB_001:39;
L809: (1 <= D74 & 1 = ( ( 2 * ( 0 ) ) + 1 )) by ABIAN:12;
assume L810: C184 in ( D73 .vertices() );
L811: D74 <= ( len D73 ) by L810 , GLIB_001:def 19;
L812: ( D73 . D74 ) = C184 by L810 , GLIB_001:def 19;
L813: ( D73 . ( len D73 ) ) = ( D73 .last() )
.= C183 by L766;
L814: D76 = ( D73 .cut (D74 , ( len D73 )) ) by L813 , L811 , L812 , L802;
L815: ( D73 . 1 ) = ( D73 .first() )
.= C182 by L766;
L816: D75 = ( D73 .cut (1 , D74) ) by L815 , L811 , L809 , L812 , L802;
thus L817: D73 = ( ( C181 .pathBetween (C182 , C184) ) .append ( C181 .pathBetween (C184 , C183) ) ) by L816 , L811 , L809 , L814 , L808 , GLIB_001:38;
end;
assume L818: D73 = ( D75 .append D76 );
L819: ( D75 .vertices() ) c= ( D73 .vertices() ) by L818 , L184 , L206;
L820: C184 in ( D75 .vertices() ) by L770;
thus L821: thesis by L820 , L819;
end;
theorem
L822: (for B137 being _Tree holds (for B138 , B139 , B140 being (Vertex of B137) holds (B140 in ( ( B137 .pathBetween (B138 , B139) ) .vertices() ) iff ( B137 .pathBetween (B138 , B140) ) is_a_prefix_of ( B137 .pathBetween (B138 , B139) ))))
proof
let C185 being _Tree;
let C186 , C187 , C188 being (Vertex of C185);
thus L823:now
assume L824: C188 in ( ( C185 .pathBetween (C186 , C187) ) .vertices() );
L825: ( C185 .pathBetween (C186 , C187) ) = ( ( C185 .pathBetween (C186 , C188) ) .append ( C185 .pathBetween (C188 , C187) ) ) by L824 , L806;
thus L826: ( C185 .pathBetween (C186 , C188) ) c= ( C185 .pathBetween (C186 , C187) ) by L825 , L206;
end;
assume L827: ( C185 .pathBetween (C186 , C188) ) c= ( C185 .pathBetween (C186 , C187) );
L828: ( ( C185 .pathBetween (C186 , C188) ) .vertices() ) c= ( ( C185 .pathBetween (C186 , C187) ) .vertices() ) by L827 , L184;
L829: C188 in ( ( C185 .pathBetween (C186 , C188) ) .vertices() ) by L770;
thus L830: thesis by L829 , L828;
end;
theorem
L831: (for B141 being _Tree holds (for B142 , B143 being (Path of B141) holds ((( B142 .last() ) = ( B143 .first() ) & ( ( B142 .vertices() ) /\ ( B143 .vertices() ) ) = { ( B142 .last() ) }) implies ( B142 .append B143 ) is  Path-like)))
proof
let C189 being _Tree;
let C190 , C191 being (Path of C189);
assume that
L832: ( C190 .last() ) = ( C191 .first() )
and
L833: ( ( C190 .vertices() ) /\ ( C191 .vertices() ) ) = { ( C190 .last() ) };
per cases ;
suppose L834: C190 is  trivial;

thus L835: thesis by L834 , L832 , L215;
end;
suppose L836: C191 is  trivial;

thus L837: thesis by L836 , GLIB_001:130;
end;
suppose L838: (C190 is non  trivial & C191 is non  trivial);

thus L839: thesis by L838 , L832 , L833 , L345;
end;
end;
theorem
L841: (for B144 being _Tree holds (for B145 , B146 , B147 being (Vertex of B144) holds (B147 in ( ( B144 .pathBetween (B145 , B146) ) .vertices() ) iff ( ( ( B144 .pathBetween (B145 , B147) ) .vertices() ) /\ ( ( B144 .pathBetween (B147 , B146) ) .vertices() ) ) = { B147 })))
proof
let C192 being _Tree;
let C193 , C194 , C195 being (Vertex of C192);
set D77 = ( C192 .pathBetween (C193 , C195) );
set D78 = ( C192 .pathBetween (C195 , C194) );
set D79 = ( C192 .pathBetween (C193 , C194) );
L842: ( D77 .last() ) = C195 by L766
.= ( D78 .first() ) by L766;
thus L843: (C195 in ( D79 .vertices() ) implies ( ( D77 .vertices() ) /\ ( D78 .vertices() ) ) = { C195 })
proof
assume L844: C195 in ( ( C192 .pathBetween (C193 , C194) ) .vertices() );
thus L845: ( ( D77 .vertices() ) /\ ( D78 .vertices() ) ) c= { C195 }
proof
let C196 being set;
assume L846: C196 in ( ( D77 .vertices() ) /\ ( D78 .vertices() ) );
L847: C196 in ( D77 .vertices() ) by L846 , XBOOLE_0:def 4;
L848: C196 in ( D78 .vertices() ) by L846 , XBOOLE_0:def 4;
L849: ( D78 .first() ) = C195 by L766;
L850: D79 = ( D77 .append D78 ) by L844 , L806;
L851: (( D79 .first() ) = C193 & ( D79 .last() ) = C194) by L766;
L852: ( D77 .last() ) = C195 by L766;
per cases ;
suppose L853: D79 is  trivial;

L854: ( D79 .first() ) = ( D79 .last() ) by L853 , GLIB_001:127;
L855: ( D79 .vertices() ) = { C193 } by L854 , L851 , L779;
L856: C196 in ( ( D77 .vertices() ) \/ ( D78 .vertices() ) ) by L847 , XBOOLE_0:def 3;
L857: C196 in ( D79 .vertices() ) by L856 , L850 , L852 , L849 , GLIB_001:93;
thus L858: thesis by L857 , L844 , L855 , TARSKI:def 1;
end;
suppose L859: D79 is non  trivial;

consider C197 being  odd (Element of ( NAT )) such that L860: C197 <= ( len D78 ) and L861: ( D78 . C197 ) = C196 by L848 , GLIB_001:87;
L862: 1 <= C197 by ABIAN:12;
L863: ( 1 - 1 ) <= ( C197 - 1 ) by L862 , XREAL_1:9;
reconsider D80 = ( C197 - 1 ) as  even (Element of ( NAT )) by L863 , INT_1:3;
consider C198 being  odd (Element of ( NAT )) such that L864: C198 <= ( len D77 ) and L865: ( D77 . C198 ) = C196 by L847 , GLIB_001:87;
L866: C198 <= ( ( len D77 ) + D80 ) by L864 , NAT_1:12;
L867: 1 <= C198 by ABIAN:12;
L868: C198 in ( dom D77 ) by L867 , L864 , FINSEQ_3:25;
L869: ( D79 . C198 ) = C196 by L868 , L850 , L865 , GLIB_001:32;
L870: ( ( len D77 ) + ( D80 + 1 ) ) <= ( ( len D77 ) + ( len D78 ) ) by L860 , XREAL_1:6;
L871: ( ( ( ( len D77 ) + D80 ) + 1 ) - 1 ) <= ( ( ( len D77 ) + ( len D78 ) ) - 1 ) by L870 , XREAL_1:9;
L872: ( ( ( ( len D77 ) + D80 ) + 1 ) - 1 ) <= ( ( ( len D79 ) + 1 ) - 1 ) by L871 , L850 , L852 , L849 , GLIB_001:28;
L873: ( D80 + 1 ) = C197;
L874: D80 < ( len D78 ) by L873 , L860 , NAT_1:13;
L875: ( D79 . ( ( len D77 ) + D80 ) ) = C196 by L874 , L850 , L852 , L849 , L861 , L873 , GLIB_001:33;
per cases  by L866 , XXREAL_0:1;
suppose L876: C198 < ( ( len D77 ) + D80 );

L877: ( D79 .first() ) = C196 by L876 , L869 , L875 , L872 , GLIB_001:def 28
.= ( D79 .last() ) by L869 , L875 , L872 , L876 , GLIB_001:def 28;
thus L878: thesis by L877 , L859 , GLIB_001:def 24;
end;
suppose L879: C198 = ( ( len D77 ) + D80 );

L880: D80 = ( 0 ) by L879 , L864 , NAT_1:16;
thus L881: thesis by L880 , L852 , L865 , L879 , TARSKI:def 1;
end;
end;
end;

let C199 being set;
assume L884: C199 in { C195 };
L885: C199 = C195 by L884 , TARSKI:def 1;
L886: C199 = ( D78 .first() ) by L885 , L766;
L887: C199 in ( D78 .vertices() ) by L886 , GLIB_001:88;
L888: C199 = ( D77 .last() ) by L885 , L766;
L889: C199 in ( D77 .vertices() ) by L888 , GLIB_001:88;
thus L890: thesis by L889 , L887 , XBOOLE_0:def 4;
end;

L891: (( D77 .first() ) = C193 & ( D78 .last() ) = C194) by L766;
L892: ( D77 .append D78 ) is_Walk_from C193 , C194 by L891 , L842 , GLIB_001:30;
assume L893: ( ( D77 .vertices() ) /\ ( D78 .vertices() ) ) = { C195 };
L894: ( ( D77 .vertices() ) /\ ( D78 .vertices() ) ) = { ( D77 .last() ) } by L893 , L766;
L895: ( D77 .append D78 ) is  Path-like by L894 , L842 , L831;
L896: D79 = ( D77 .append D78 ) by L895 , L892 , L760;
thus L897: thesis by L896 , L806;
end;
theorem
L898: (for B148 being _Tree holds (for B149 , B150 , B151 , B152 being (Vertex of B148) holds (for B153 , B154 being (Path of B148) holds ((B153 = ( B148 .pathBetween (B149 , B150) ) & B154 = ( B148 .pathBetween (B149 , B151) ) & (not B153 is_a_prefix_of B154) & (not B154 is_a_prefix_of B153) & B152 = ( B153 . ( len ( maxPrefix (B153 , B154) ) ) )) implies ( ( ( B148 .pathBetween (B152 , B150) ) .vertices() ) /\ ( ( B148 .pathBetween (B152 , B151) ) .vertices() ) ) = { B152 }))))
proof
let C200 being _Tree;
let C201 , C202 , C203 , C204 being (Vertex of C200);
let C205 , C206 being (Path of C200);
assume that
L899: C205 = ( C200 .pathBetween (C201 , C202) )
and
L900: C206 = ( C200 .pathBetween (C201 , C203) )
and
L901: (not C205 c= C206)
and
L902: (not C206 c= C205)
and
L903: C204 = ( C205 . ( len ( maxPrefix (C205 , C206) ) ) );
set D81 = ( C200 .pathBetween (C201 , C204) );
set D82 = ( len ( maxPrefix (C205 , C206) ) );
L904: ( C205 .first() ) = C201 by L899 , L766;
L905: ( C206 .first() ) = C201 by L900 , L766;
reconsider D83 = D82 as  odd (Element of ( NAT )) by L905 , L904 , L435;
L906: D83 <= ( D83 + 2 ) by NAT_1:11;
set D84 = ( C200 .pathBetween (C204 , C202) );
L907: ( D84 .first() ) = C204 by L766;
set D85 = ( C200 .pathBetween (C204 , C203) );
L908: C204 = ( C206 . ( len ( maxPrefix (C205 , C206) ) ) ) by L903 , L93;
L909: D83 <= ( D83 + 2 ) by NAT_1:11;
L910: ( D83 + 2 ) <= ( len C206 ) by L902 , L904 , L905 , L483;
L911: D83 <= ( len C206 ) by L910 , L909 , XXREAL_0:2;
L912: C204 in ( C206 .vertices() ) by L911 , L908 , GLIB_001:87;
L913: C206 = ( D81 .append D85 ) by L912 , L900 , L806;
L914: ( D81 .last() ) = C204 by L766;
L915: ( D85 . 1 ) = ( D85 .first() )
.= C204 by L766;
L916: ( D85 .first() ) = C204 by L766;
L917: ( D83 + 2 ) <= ( len C205 ) by L901 , L904 , L905 , L483;
L918: D83 <= ( len C205 ) by L917 , L906 , XXREAL_0:2;
L919: C204 in ( C205 .vertices() ) by L918 , L903 , GLIB_001:87;
L920: C205 = ( D81 .append D84 ) by L919 , L899 , L806;
L921: 1 <= D83 by ABIAN:12;
L922: D81 = ( C205 .cut (( ( 2 * ( 0 ) ) + 1 ) , D83) ) by L921 , L903 , L904 , L918 , L802;
L923: ( ( len D81 ) + ( ( 2 * ( 0 ) ) + 1 ) ) = ( D83 + 1 ) by L922 , L918 , L921 , GLIB_001:36;
L924: ( D84 . 1 ) = ( D84 .first() )
.= C204 by L766;
thus L925: ( ( D84 .vertices() ) /\ ( D85 .vertices() ) ) = { C204 }
proof
thus L926:now
assume L927: (not ( ( D84 .vertices() ) /\ ( D85 .vertices() ) ) c= { C204 });
consider C207 being set such that L928: C207 in ( ( D84 .vertices() ) /\ ( D85 .vertices() ) ) and L929: (not C207 in { C204 }) by L927 , TARSKI:def 3;
L930: C207 in ( D84 .vertices() ) by L928 , XBOOLE_0:def 4;
L931: C207 in ( D85 .vertices() ) by L928 , XBOOLE_0:def 4;
reconsider D86 = C207 as (Vertex of C200) by L928;
consider C208 being  odd (Element of ( NAT )) such that L932: C208 <= ( len D84 ) and L933: D86 = ( D84 . C208 ) by L930 , GLIB_001:87;
set D87 = ( D84 .cut (1 , C208) );
L934: (1 <= C208 & ( ( 2 * ( 0 ) ) + 1 ) is  odd  odd  odd  odd (Element of ( NAT ))) by ABIAN:12;
L935: D87 is_Walk_from C204 , D86 by L934 , L924 , L932 , L933 , GLIB_001:37;
L936: 1 < ( len D87 )
proof
assume L937: 1 >= ( len D87 );
per cases  by L937 , NAT_1:25;
suppose L938: ( len D87 ) = ( 2 * ( 0 ) );

thus L939: contradiction by L938;
end;
suppose L940: ( len D87 ) = 1;

L941: ( D87 . 1 ) = C204 by L935 , GLIB_001:17;
L942: ( D87 . 1 ) = D86 by L935 , L940 , GLIB_001:17;
thus L943: contradiction by L942 , L929 , L941 , TARSKI:def 1;
end;
end;
L945: ( ( ( 2 * ( 0 ) ) + 1 ) + 2 ) <= ( len D87 ) by L936 , CHORD:4;
L946: 2 < ( len D87 ) by L945 , XXREAL_0:2;
consider C209 being  odd (Element of ( NAT )) such that L947: C209 <= ( len D85 ) and L948: D86 = ( D85 . C209 ) by L931 , GLIB_001:87;
set D88 = ( D85 .cut (1 , C209) );
L949: (1 <= C209 & ( ( 2 * ( 0 ) ) + 1 ) is  odd  odd  odd  odd (Element of ( NAT ))) by ABIAN:12;
L950: D88 is_Walk_from C204 , D86 by L949 , L915 , L947 , L948 , GLIB_001:37;
L951: 1 < ( len D88 )
proof
assume L952: 1 >= ( len D88 );
per cases  by L952 , NAT_1:25;
suppose L953: ( len D88 ) = ( 2 * ( 0 ) );

thus L954: contradiction by L953;
end;
suppose L955: ( len D88 ) = 1;

L956: ( D88 . 1 ) = C204 by L950 , GLIB_001:17;
L957: ( D88 . 1 ) = D86 by L950 , L955 , GLIB_001:17;
thus L958: contradiction by L957 , L929 , L956 , TARSKI:def 1;
end;
end;
L960: ( ( ( 2 * ( 0 ) ) + 1 ) + 2 ) <= ( len D88 ) by L951 , CHORD:4;
L961: 2 < ( len D88 ) by L960 , XXREAL_0:2;
L962: ( 1 + 2 ) in ( dom D87 ) by L945 , FINSEQ_3:25;
L963: ( D87 . ( 1 + 2 ) ) = ( D84 . ( 1 + 2 ) ) by L962 , L932 , GLIB_001:46;
L964: ( len D87 ) <= ( len D84 ) by L152;
L965: 2 < ( len D84 ) by L964 , L946 , XXREAL_0:2;
L966: ( C205 . ( D83 + 2 ) ) = ( D84 . ( 1 + 2 ) ) by L965 , L907 , L914 , L920 , L923 , GLIB_001:33;
L967: ( len D88 ) <= ( len D85 ) by L152;
L968: 2 < ( len D85 ) by L967 , L961 , XXREAL_0:2;
L969: ( C206 . ( D83 + 2 ) ) = ( D85 . ( 1 + 2 ) ) by L968 , L916 , L914 , L913 , L923 , GLIB_001:33;
L970: ( 1 + 2 ) in ( dom D88 ) by L960 , FINSEQ_3:25;
L971: ( D87 . ( 1 + 2 ) ) = ( D88 . ( 1 + 2 ) ) by L935 , L950 , L564;
thus L972: contradiction by L971 , L901 , L902 , L904 , L905 , L947 , L966 , L963 , L969 , L970 , L487 , GLIB_001:46;
end;
L973: (C204 in ( D84 .vertices() ) & C204 in ( D85 .vertices() )) by L907 , L916 , GLIB_001:88;
L974: C204 in ( ( D84 .vertices() ) /\ ( D85 .vertices() ) ) by L973 , XBOOLE_0:def 4;
thus L975: thesis by L974 , ZFMISC_1:31;
end;

end;
L926: (for B155 being _Tree holds (for B156 , B157 , B158 being (Vertex of B155) holds (B158 in ( ( B155 .pathBetween (B156 , B157) ) .vertices() ) implies ( ( ( ( B155 .pathBetween (B156 , B157) ) .vertices() ) /\ ( ( B155 .pathBetween (B157 , B158) ) .vertices() ) ) /\ ( ( B155 .pathBetween (B158 , B156) ) .vertices() ) ) = { B158 })))
proof
let C210 being _Tree;
let C211 , C212 , C213 being (Vertex of C210);
assume that
L927: C213 in ( ( C210 .pathBetween (C211 , C212) ) .vertices() );
set D89 = ( C210 .pathBetween (C211 , C212) );
set D90 = ( C210 .pathBetween (C212 , C213) );
set D91 = ( C210 .pathBetween (C213 , C211) );
L928: ( D89 .vertices() ) = ( ( C210 .pathBetween (C212 , C211) ) .vertices() ) by L787;
L929: ( ( D90 .vertices() ) /\ ( D91 .vertices() ) ) = { C213 } by L928 , L927 , L841;
L930: ( ( D89 .vertices() ) /\ ( ( D90 .vertices() ) /\ ( D91 .vertices() ) ) ) = { C213 } by L929 , L927 , ZFMISC_1:46;
thus L931: thesis by L930 , XBOOLE_1:16;
end;
L932: (for B159 being _Tree holds (for B160 , B161 , B162 being (Vertex of B159) holds (for B163 , B164 being (Path of B159) holds ((B163 = ( B159 .pathBetween (B160 , B161) ) & B164 = ( B159 .pathBetween (B160 , B162) ) & (not B163 c= B164) & (not B164 c= B163)) implies ( ( ( B163 .vertices() ) /\ ( ( B159 .pathBetween (B161 , B162) ) .vertices() ) ) /\ ( ( B159 .pathBetween (B162 , B160) ) .vertices() ) ) = { ( B163 . ( len ( maxPrefix (B163 , B164) ) ) ) }))))
proof
let C214 being _Tree;
let C215 , C216 , C217 being (Vertex of C214);
let C218 , C219 being (Path of C214);
assume that
L933: C218 = ( C214 .pathBetween (C215 , C216) )
and
L934: C219 = ( C214 .pathBetween (C215 , C217) )
and
L935: (not C218 c= C219)
and
L936: (not C219 c= C218);
set D92 = ( C214 .pathBetween (C217 , C215) );
L937: ( D92 .vertices() ) = ( C219 .vertices() ) by L934 , L787;
set D93 = ( len ( maxPrefix (C218 , C219) ) );
L938: ( C218 .first() ) = C215 by L933 , L766;
L939: ( C218 .first() ) = ( C219 .first() ) by L938 , L934 , L766;
reconsider D94 = D93 as  odd (Element of ( NAT )) by L939 , L435;
set D95 = ( C218 . D94 );
L940: D93 <= ( D93 + 2 ) by NAT_1:11;
L941:
now
assume L942: C216 in ( D92 .vertices() );
L943: C216 in ( C219 .vertices() ) by L942 , L934 , L787;
L944: C219 = ( ( C214 .pathBetween (C215 , C216) ) .append ( C214 .pathBetween (C216 , C217) ) ) by L943 , L934 , L806;
thus L945: contradiction by L944 , L933 , L935 , L206;
end;
L946: ( D93 + 2 ) <= ( len C219 ) by L936 , L939 , L483;
L947: D93 <= ( len C219 ) by L946 , L940 , XXREAL_0:2;
L948: ( D93 + 2 ) <= ( len C218 ) by L935 , L939 , L483;
reconsider D96 = D95 as (Vertex of C214) by L948 , L940 , GLIB_001:7 , XXREAL_0:2;
set D97 = ( C218 .cut (D94 , ( len C218 )) );
set D98 = ( D97 .reverse() );
set D99 = ( len D98 );
set D100 = ( C219 .cut (D94 , ( len C219 )) );
set D101 = ( D98 .append D100 );
L949: D93 <= ( len C218 ) by L940 , L948 , XXREAL_0:2;
L950: ( D97 .first() ) = ( C218 . D94 ) by L949 , GLIB_001:37;
L951: ( D98 .last() ) = D96 by L950 , GLIB_001:22;
L952: 1 <= D99 by CHORD:2;
L953: D99 in ( dom D98 ) by L952 , FINSEQ_3:25;
L954: ( D101 . D99 ) = D96 by L953 , L951 , GLIB_001:32;
set D102 = ( C214 .pathBetween (C216 , C217) );
L955: D96 in ( C218 .vertices() ) by L949 , GLIB_001:87;
L956: ( C218 . ( len C218 ) ) = ( C218 .last() )
.= C216 by L933 , L766;
L957: ( D97 .last() ) = C216 by L956 , L949 , GLIB_001:37;
L958: ( D98 .first() ) = C216 by L957 , GLIB_001:22;
L959: D96 = ( C219 . D94 ) by L93;
L960: D96 <> C216 by L959 , L941 , L937 , L947 , GLIB_001:87;
L961: D98 is  open by L960 , L951 , L958 , GLIB_001:def 24;
L962: ( C219 . ( len C219 ) ) = ( C219 .last() )
.= C217 by L934 , L766;
L963: D100 is_Walk_from D96 , C217 by L962 , L947 , L959 , GLIB_001:37;
L964: D100 = ( C214 .pathBetween (D96 , C217) ) by L963 , L760;
L965: ( D100 .first() ) = D96 by L964 , L766;
L966: D99 <= ( len D101 ) by L965 , L951 , GLIB_001:29;
L967: D97 is_Walk_from D96 , C216 by L949 , L956 , GLIB_001:37;
L968: D97 = ( C214 .pathBetween (D96 , C216) ) by L967 , L760;
L969: (( D98 .vertices() ) = ( D97 .vertices() ) & ( ( D97 .vertices() ) /\ ( D100 .vertices() ) ) = { D96 }) by L968 , L933 , L934 , L935 , L936 , L964 , L898 , GLIB_001:92;
L970: ( ( D98 .vertices() ) /\ ( D100 .vertices() ) ) c= { ( D98 .first() ) , ( D98 .last() ) } by L969 , L951 , ZFMISC_1:7;
L971: ( D100 .vertices() ) c= ( C219 .vertices() ) by L947 , GLIB_001:94;
L972: ( D98 .edges() ) misses ( D100 .edges() )
proof
assume L973: (not thesis);
L974: ( ( D98 .edges() ) /\ ( D100 .edges() ) ) <> ( {} ) by L973 , XBOOLE_0:def 7;
consider C220 being set such that L975: C220 in ( ( D98 .edges() ) /\ ( D100 .edges() ) ) by L974 , XBOOLE_0:def 1;
L976: C220 in ( D98 .edges() ) by L975 , XBOOLE_0:def 4;
consider C221 , C222 being (Vertex of C214), C223 being  odd (Element of ( NAT )) such that L977: ( C223 + 2 ) <= ( len D98 ) and L978: C221 = ( D98 . C223 ) and L979: C220 = ( D98 . ( C223 + 1 ) ) and L980: C222 = ( D98 . ( C223 + 2 ) ) and L981: C220 Joins C221 , C222 , C214 by L976 , GLIB_001:103;
L982: C223 <= ( C223 + 2 ) by NAT_1:11;
L983: C223 <= ( len D98 ) by L982 , L977 , XXREAL_0:2;
L984: C221 in ( D98 .vertices() ) by L983 , L978 , GLIB_001:87;
L985: C222 in ( D98 .vertices() ) by L977 , L980 , GLIB_001:87;
L986: { C221 , C222 } c= ( D98 .vertices() ) by L985 , L984 , ZFMISC_1:32;
L987: C220 in ( D100 .edges() ) by L975 , XBOOLE_0:def 4;
consider C224 , C225 being (Vertex of C214), C226 being  odd (Element of ( NAT )) such that L988: ( C226 + 2 ) <= ( len D100 ) and L989: C224 = ( D100 . C226 ) and L990: C220 = ( D100 . ( C226 + 1 ) ) and L991: C225 = ( D100 . ( C226 + 2 ) ) and L992: C220 Joins C224 , C225 , C214 by L987 , GLIB_001:103;
L993: C226 <= ( C226 + 2 ) by NAT_1:11;
L994: C226 <= ( len D100 ) by L993 , L988 , XXREAL_0:2;
L995: C224 in ( D100 .vertices() ) by L994 , L989 , GLIB_001:87;
L996: ((C221 = C224 & C222 = C225) or (C221 = C225 & C222 = C224)) by L981 , L992 , GLIB_000:15;
L997: C225 in ( D100 .vertices() ) by L988 , L991 , GLIB_001:87;
L998: { C224 , C225 } c= ( D100 .vertices() ) by L997 , L995 , ZFMISC_1:32;
L999: { C224 , C225 } c= ( ( D98 .vertices() ) /\ ( D100 .vertices() ) ) by L998 , L996 , L986 , XBOOLE_1:19;
L1000: (C225 = C216 or C225 = D96) by L999 , L951 , L958 , L970 , XBOOLE_1:1 , ZFMISC_1:22;
L1001: (C224 = C216 or C224 = D96) by L951 , L958 , L970 , L999 , XBOOLE_1:1 , ZFMISC_1:22;
thus L1002: contradiction by L1001 , L941 , L937 , L971 , L992 , L995 , L997 , L1000 , GLIB_000:18;
end;
L1003: ( D100 .last() ) = C217 by L964 , L766;
L1004: D101 is_Walk_from C216 , C217 by L1003 , L951 , L965 , L958 , GLIB_001:30;
L1005:
now
assume L1006: C217 in ( C218 .vertices() );
L1007: C218 = ( ( C214 .pathBetween (C215 , C217) ) .append ( C214 .pathBetween (C217 , C216) ) ) by L1006 , L933 , L806;
thus L1008: contradiction by L1007 , L934 , L936 , L206;
end;
L1009: D96 <> C217 by L1005 , L949 , GLIB_001:87;
L1010: D100 is  open by L1009 , L965 , L1003 , GLIB_001:def 24;
L1011: (not ( D98 .first() ) in ( D100 .vertices() )) by L941 , L937 , L971 , L958;
L1012: D101 is (Path of C214) by L1011 , L951 , L965 , L961 , L1010 , L970 , L972 , L269;
L1013: D101 = D102 by L1012 , L1004 , L760;
L1014: D96 in ( D102 .vertices() ) by L1013 , L966 , L954 , GLIB_001:87;
L1015: D96 in ( C219 .vertices() ) by L947 , L959 , GLIB_001:87;
L1016: ( ( ( C218 .vertices() ) /\ ( D102 .vertices() ) ) /\ ( D92 .vertices() ) ) c= { D96 }
proof
set D103 = ( C214 .pathBetween (C217 , D96) );
set D104 = ( C214 .pathBetween (D96 , C215) );
set D105 = ( C214 .pathBetween (C216 , D96) );
set D106 = ( C214 .pathBetween (D96 , C217) );
set D107 = ( C214 .pathBetween (C215 , D96) );
set D108 = ( C214 .pathBetween (D96 , C216) );
let C227 being set;
L1017: ( D105 .vertices() ) = ( D108 .vertices() ) by L787;
L1018: ( D103 .vertices() ) = ( D106 .vertices() ) by L787;
L1019: ( D103 .last() ) = D96 by L766
.= ( D104 .first() ) by L766;
L1020: D92 = ( D103 .append D104 ) by L937 , L1015 , L806;
L1021: ( D92 .vertices() ) = ( ( D103 .vertices() ) \/ ( D104 .vertices() ) ) by L1020 , L1019 , GLIB_001:93;
L1022: ( D105 .last() ) = D96 by L766
.= ( D106 .first() ) by L766;
L1023: D102 = ( D105 .append D106 ) by L1014 , L806;
L1024: ( D102 .vertices() ) = ( ( D105 .vertices() ) \/ ( D106 .vertices() ) ) by L1023 , L1022 , GLIB_001:93;
L1025: ( D107 .last() ) = D96 by L766
.= ( D108 .first() ) by L766;
L1026: C218 = ( D107 .append D108 ) by L933 , L955 , L806;
L1027: ( C218 .vertices() ) = ( ( D107 .vertices() ) \/ ( D108 .vertices() ) ) by L1026 , L1025 , GLIB_001:93;
assume L1028: C227 in ( ( ( C218 .vertices() ) /\ ( D102 .vertices() ) ) /\ ( D92 .vertices() ) );
L1029: C227 in ( ( C218 .vertices() ) /\ ( D102 .vertices() ) ) by L1028 , XBOOLE_0:def 4;
L1030: C227 in ( C218 .vertices() ) by L1029 , XBOOLE_0:def 4;
L1031: (C227 in ( D107 .vertices() ) or C227 in ( D108 .vertices() )) by L1030 , L1027 , XBOOLE_0:def 3;
L1032: C227 in ( D92 .vertices() ) by L1028 , XBOOLE_0:def 4;
L1033: (C227 in ( D103 .vertices() ) or C227 in ( D104 .vertices() )) by L1032 , L1021 , XBOOLE_0:def 3;
L1034: C227 in ( D102 .vertices() ) by L1029 , XBOOLE_0:def 4;
L1035: (C227 in ( D105 .vertices() ) or C227 in ( D106 .vertices() )) by L1034 , L1024 , XBOOLE_0:def 3;
per cases  by L1031 , L1035 , L1033 , L787;
suppose L1036: (C227 in ( D107 .vertices() ) & C227 in ( D105 .vertices() ));

L1037: C227 in ( ( D107 .vertices() ) /\ ( D108 .vertices() ) ) by L1036 , L1017 , XBOOLE_0:def 4;
thus L1038: thesis by L1037 , L933 , L955 , L841;
end;
suppose L1039: (C227 in ( D107 .vertices() ) & C227 in ( D103 .vertices() ));

L1040: C227 in ( ( D107 .vertices() ) /\ ( D106 .vertices() ) ) by L1039 , L1018 , XBOOLE_0:def 4;
thus L1041: thesis by L1040 , L934 , L1015 , L841;
end;
suppose L1042: (C227 in ( D105 .vertices() ) & C227 in ( D103 .vertices() ));

L1043: C227 in ( ( D105 .vertices() ) /\ ( D106 .vertices() ) ) by L1042 , L1018 , XBOOLE_0:def 4;
thus L1044: thesis by L1043 , L1014 , L841;
end;
end;
L1046: D96 in ( ( C218 .vertices() ) /\ ( D102 .vertices() ) ) by L955 , L1014 , XBOOLE_0:def 4;
L1047: D96 in ( ( ( C218 .vertices() ) /\ ( D102 .vertices() ) ) /\ ( D92 .vertices() ) ) by L1046 , L937 , L1015 , XBOOLE_0:def 4;
L1048: { D96 } c= ( ( ( C218 .vertices() ) /\ ( D102 .vertices() ) ) /\ ( D92 .vertices() ) ) by L1047 , ZFMISC_1:31;
thus L1049: thesis by L1048 , L1016 , XBOOLE_0:def 10;
end;
definition
let C228 being _Tree;
let C229 , C230 , C231 being (Vertex of C228);
func MiddleVertex (C229 , C230 , C231) -> (Vertex of C228) means 
:L1050: ( ( ( ( C228 .pathBetween (C229 , C230) ) .vertices() ) /\ ( ( C228 .pathBetween (C230 , C231) ) .vertices() ) ) /\ ( ( C228 .pathBetween (C231 , C229) ) .vertices() ) ) = { it };
existence
proof
defpred S4[ (Vertex of C228) , (Vertex of C228) , (Vertex of C228) , (Vertex of C228) ] means ( ( ( ( C228 .pathBetween ($1 , $2) ) .vertices() ) /\ ( ( C228 .pathBetween ($2 , $3) ) .vertices() ) ) /\ ( ( C228 .pathBetween ($3 , $1) ) .vertices() ) ) = { $4 };
set D109 = ( C228 .pathBetween (C231 , C229) );
set D110 = ( C228 .pathBetween (C230 , C231) );
set D111 = ( C228 .pathBetween (C229 , C230) );
per cases ;
suppose L1051: (C231 in ( D111 .vertices() ) or C229 in ( D110 .vertices() ) or C230 in ( D109 .vertices() ));

per cases  by L1051;
suppose L1052: C231 in ( D111 .vertices() );

L1053: S4[ C229 , C230 , C231 , C231 ] by L1052 , L926;
thus L1054: thesis by L1053;
end;
suppose L1055: C229 in ( D110 .vertices() );

L1056: S4[ C230 , C231 , C229 , C229 ] by L1055 , L926;
thus L1057: thesis by L1056 , XBOOLE_1:16;
end;
suppose L1058: C230 in ( D109 .vertices() );

L1059: S4[ C231 , C229 , C230 , C230 ] by L1058 , L926;
thus L1060: thesis by L1059 , XBOOLE_1:16;
end;
end;
suppose L1062: ((not C231 in ( D111 .vertices() )) & (not C229 in ( D110 .vertices() )) & (not C230 in ( D109 .vertices() )));

set D112 = ( C228 .pathBetween (C229 , C231) );
set D113 = ( len ( maxPrefix (D111 , D112) ) );
L1063: ( D111 .last() ) = C230 by L766;
L1064: C230 in ( D111 .vertices() ) by L1063 , GLIB_001:88;
L1065: ( D112 .last() ) = C231 by L766;
L1066: C231 in ( D112 .vertices() ) by L1065 , GLIB_001:88;
L1067: (not ( D112 .vertices() ) c= ( D111 .vertices() )) by L1066 , L1062;
L1068: (not D112 c= D111) by L1067 , L184;
L1069: ( D111 .first() ) = C229 by L766;
L1070: ( D111 .first() ) = ( D112 .first() ) by L1069 , L766;
reconsider D114 = D113 as  odd (Element of ( NAT )) by L1070 , L435;
set D115 = ( D111 . D114 );
L1071: ( D109 .vertices() ) = ( D112 .vertices() ) by L787;
L1072: (not ( D111 .vertices() ) c= ( D112 .vertices() )) by L1071 , L1062 , L1064;
L1073: (D113 <= ( D113 + 2 ) & ( D113 + 2 ) <= ( len D111 )) by L1072 , L1070 , L184 , L483 , NAT_1:11;
reconsider D116 = D115 as (Vertex of C228) by L1073 , GLIB_001:7 , XXREAL_0:2;
take D116;
L1074: (not D111 c= D112) by L1072 , L184;
thus L1075: thesis by L1074 , L1068 , L932;
end;
end;
uniqueness by ZFMISC_1:3;
end;
theorem
L1078: (for B165 being _Tree holds (for B166 , B167 , B168 being (Vertex of B165) holds ( MiddleVertex (B166 , B167 , B168) ) = ( MiddleVertex (B166 , B168 , B167) )))
proof
let C232 being _Tree;
let C233 , C234 , C235 being (Vertex of C232);
set D117 = ( MiddleVertex (C233 , C234 , C235) );
set D118 = ( MiddleVertex (C233 , C235 , C234) );
L1079: (( ( C232 .pathBetween (C233 , C234) ) .vertices() ) = ( ( C232 .pathBetween (C234 , C233) ) .vertices() ) & ( ( C232 .pathBetween (C234 , C235) ) .vertices() ) = ( ( C232 .pathBetween (C235 , C234) ) .vertices() )) by L787;
L1080: ( ( C232 .pathBetween (C235 , C233) ) .vertices() ) = ( ( C232 .pathBetween (C233 , C235) ) .vertices() ) by L787;
L1081: (( ( ( ( C232 .pathBetween (C233 , C234) ) .vertices() ) /\ ( ( C232 .pathBetween (C234 , C235) ) .vertices() ) ) /\ ( ( C232 .pathBetween (C235 , C233) ) .vertices() ) ) = { D117 } & ( ( ( ( C232 .pathBetween (C233 , C235) ) .vertices() ) /\ ( ( C232 .pathBetween (C235 , C234) ) .vertices() ) ) /\ ( ( C232 .pathBetween (C234 , C233) ) .vertices() ) ) = { D118 }) by L1050;
L1082: { D117 } = { D118 } by L1081 , L1079 , L1080 , XBOOLE_1:16;
thus L1083: thesis by L1082 , ZFMISC_1:3;
end;
theorem
L1084: (for B169 being _Tree holds (for B170 , B171 , B172 being (Vertex of B169) holds ( MiddleVertex (B170 , B171 , B172) ) = ( MiddleVertex (B171 , B170 , B172) )))
proof
let C236 being _Tree;
let C237 , C238 , C239 being (Vertex of C236);
set D119 = ( MiddleVertex (C237 , C238 , C239) );
set D120 = ( MiddleVertex (C238 , C237 , C239) );
L1085: (( ( C236 .pathBetween (C237 , C238) ) .vertices() ) = ( ( C236 .pathBetween (C238 , C237) ) .vertices() ) & ( ( C236 .pathBetween (C238 , C239) ) .vertices() ) = ( ( C236 .pathBetween (C239 , C238) ) .vertices() )) by L787;
L1086: ( ( C236 .pathBetween (C239 , C237) ) .vertices() ) = ( ( C236 .pathBetween (C237 , C239) ) .vertices() ) by L787;
L1087: (( ( ( ( C236 .pathBetween (C237 , C238) ) .vertices() ) /\ ( ( C236 .pathBetween (C238 , C239) ) .vertices() ) ) /\ ( ( C236 .pathBetween (C239 , C237) ) .vertices() ) ) = { D119 } & ( ( ( ( C236 .pathBetween (C238 , C237) ) .vertices() ) /\ ( ( C236 .pathBetween (C237 , C239) ) .vertices() ) ) /\ ( ( C236 .pathBetween (C239 , C238) ) .vertices() ) ) = { D120 }) by L1050;
L1088: { D119 } = { D120 } by L1087 , L1085 , L1086 , XBOOLE_1:16;
thus L1089: thesis by L1088 , ZFMISC_1:3;
end;
theorem
L1090: (for B173 being _Tree holds (for B174 , B175 , B176 being (Vertex of B173) holds ( MiddleVertex (B174 , B175 , B176) ) = ( MiddleVertex (B175 , B176 , B174) )))
proof
let C240 being _Tree;
let C241 , C242 , C243 being (Vertex of C240);
thus L1091: ( MiddleVertex (C241 , C242 , C243) ) = ( MiddleVertex (C242 , C241 , C243) ) by L1084
.= ( MiddleVertex (C242 , C243 , C241) ) by L1078;
end;
theorem
L1092: (for B177 being _Tree holds (for B178 , B179 , B180 being (Vertex of B177) holds ( MiddleVertex (B178 , B179 , B180) ) = ( MiddleVertex (B180 , B178 , B179) )))
proof
let C244 being _Tree;
let C245 , C246 , C247 being (Vertex of C244);
thus L1093: ( MiddleVertex (C245 , C246 , C247) ) = ( MiddleVertex (C245 , C247 , C246) ) by L1078
.= ( MiddleVertex (C247 , C245 , C246) ) by L1084;
end;
theorem
L1094: (for B181 being _Tree holds (for B182 , B183 , B184 being (Vertex of B181) holds ( MiddleVertex (B182 , B183 , B184) ) = ( MiddleVertex (B184 , B183 , B182) )))
proof
let C248 being _Tree;
let C249 , C250 , C251 being (Vertex of C248);
thus L1095: ( MiddleVertex (C249 , C250 , C251) ) = ( MiddleVertex (C251 , C249 , C250) ) by L1092
.= ( MiddleVertex (C251 , C250 , C249) ) by L1078;
end;
theorem
L1096: (for B185 being _Tree holds (for B186 , B187 , B188 being (Vertex of B185) holds (B188 in ( ( B185 .pathBetween (B186 , B187) ) .vertices() ) implies ( MiddleVertex (B186 , B187 , B188) ) = B188)))
proof
let C252 being _Tree;
let C253 , C254 , C255 being (Vertex of C252);
assume L1097: C255 in ( ( C252 .pathBetween (C253 , C254) ) .vertices() );
L1098: ( ( ( ( C252 .pathBetween (C253 , C254) ) .vertices() ) /\ ( ( C252 .pathBetween (C254 , C255) ) .vertices() ) ) /\ ( ( C252 .pathBetween (C255 , C253) ) .vertices() ) ) = { C255 } by L1097 , L926;
thus L1099: thesis by L1098 , L1050;
end;
theorem
L1100: (for B189 being _Tree holds (for B190 being (Vertex of B189) holds ( MiddleVertex (B190 , B190 , B190) ) = B190))
proof
let C256 being _Tree;
let C257 being (Vertex of C256);
L1101: C257 in { C257 } by TARSKI:def 1;
L1102: C257 in ( ( C256 .pathBetween (C257 , C257) ) .vertices() ) by L1101 , L779;
thus L1103: thesis by L1102 , L1096;
end;
theorem
L1104: (for B191 being _Tree holds (for B192 , B193 being (Vertex of B191) holds ( MiddleVertex (B192 , B192 , B193) ) = B192))
proof
let C258 being _Tree;
let C259 , C260 being (Vertex of C258);
L1105: ( ( C258 .pathBetween (C259 , C260) ) .first() ) = C259 by L766;
L1106: C259 in ( ( C258 .pathBetween (C259 , C260) ) .vertices() ) by L1105 , GLIB_001:88;
L1107: ( MiddleVertex (C259 , C259 , C260) ) = ( MiddleVertex (C259 , C260 , C259) ) by L1078;
thus L1108: thesis by L1107 , L1106 , L1096;
end;
theorem
L1109: (for B194 being _Tree holds (for B195 , B196 being (Vertex of B194) holds ( MiddleVertex (B195 , B196 , B195) ) = B195))
proof
let C261 being _Tree;
let C262 , C263 being (Vertex of C261);
L1110: ( MiddleVertex (C262 , C262 , C263) ) = ( MiddleVertex (C262 , C263 , C262) ) by L1078;
thus L1111: thesis by L1110 , L1104;
end;
theorem
L1112: (for B197 being _Tree holds (for B198 , B199 being (Vertex of B197) holds ( MiddleVertex (B198 , B199 , B199) ) = B199))
proof
let C264 being _Tree;
let C265 , C266 being (Vertex of C264);
L1113: ( MiddleVertex (C265 , C266 , C266) ) = ( MiddleVertex (C266 , C265 , C266) ) by L1084;
thus L1114: thesis by L1113 , L1109;
end;
theorem
L1115: (for B200 being _Tree holds (for B201 , B202 being (Path of B200) holds (for B203 , B204 , B205 being (Vertex of B200) holds ((B201 = ( B200 .pathBetween (B203 , B204) ) & B202 = ( B200 .pathBetween (B203 , B205) ) & (not B204 in ( B202 .vertices() )) & (not B205 in ( B201 .vertices() ))) implies ( MiddleVertex (B203 , B204 , B205) ) = ( B201 . ( len ( maxPrefix (B201 , B202) ) ) )))))
proof
let C267 being _Tree;
let C268 , C269 being (Path of C267);
let C270 , C271 , C272 being (Vertex of C267);
assume that
L1116: (C268 = ( C267 .pathBetween (C270 , C271) ) & C269 = ( C267 .pathBetween (C270 , C272) ))
and
L1117: ((not C271 in ( C269 .vertices() )) & (not C272 in ( C268 .vertices() )));
L1118: ((not C268 c= C269) & (not C269 c= C268)) by L1116 , L1117 , L822;
L1119: ( ( ( ( C267 .pathBetween (C270 , C271) ) .vertices() ) /\ ( ( C267 .pathBetween (C271 , C272) ) .vertices() ) ) /\ ( ( C267 .pathBetween (C272 , C270) ) .vertices() ) ) = { ( C268 . ( len ( maxPrefix (C268 , C269) ) ) ) } by L1118 , L1116 , L932;
L1120: ( ( ( ( C267 .pathBetween (C270 , C271) ) .vertices() ) /\ ( ( C267 .pathBetween (C271 , C272) ) .vertices() ) ) /\ ( ( C267 .pathBetween (C272 , C270) ) .vertices() ) ) = { ( MiddleVertex (C270 , C271 , C272) ) } by L1050;
thus L1121: thesis by L1120 , L1119 , ZFMISC_1:3;
end;
theorem
L1122: (for B206 being _Tree holds (for B207 , B208 , B209 , B210 being (Path of B206) holds (for B211 , B212 , B213 being (Vertex of B206) holds ((B207 = ( B206 .pathBetween (B211 , B212) ) & B208 = ( B206 .pathBetween (B211 , B213) ) & B209 = ( B206 .pathBetween (B212 , B211) ) & B210 = ( B206 .pathBetween (B212 , B213) ) & (not B212 in ( B208 .vertices() )) & (not B213 in ( B207 .vertices() )) & (not B211 in ( B210 .vertices() ))) implies ( B207 . ( len ( maxPrefix (B207 , B208) ) ) ) = ( B209 . ( len ( maxPrefix (B209 , B210) ) ) )))))
proof
let C273 being _Tree;
let C274 , C275 , C276 , C277 being (Path of C273);
let C278 , C279 , C280 being (Vertex of C273);
assume that
L1123: C274 = ( C273 .pathBetween (C278 , C279) )
and
L1124: C275 = ( C273 .pathBetween (C278 , C280) )
and
L1125: C276 = ( C273 .pathBetween (C279 , C278) )
and
L1126: C277 = ( C273 .pathBetween (C279 , C280) )
and
L1127: (not C279 in ( C275 .vertices() ))
and
L1128: (not C280 in ( C274 .vertices() ))
and
L1129: (not C278 in ( C277 .vertices() ));
L1130:
now
assume L1131: C277 c= C276;
L1132: ( C277 .vertices() ) c= ( C276 .vertices() ) by L1131 , L184;
L1133: C280 in ( C277 .vertices() ) by L1126 , L770;
L1134: C280 in ( C276 .vertices() ) by L1133 , L1132;
thus L1135: contradiction by L1134 , L1123 , L1125 , L1128 , L787;
end;
L1136: (not C280 in ( C276 .vertices() )) by L1130 , L1125 , L1126 , L822;
L1137: ( MiddleVertex (C279 , C278 , C280) ) = ( C276 . ( len ( maxPrefix (C276 , C277) ) ) ) by L1136 , L1125 , L1126 , L1129 , L1115;
L1138: ( MiddleVertex (C278 , C279 , C280) ) = ( C274 . ( len ( maxPrefix (C274 , C275) ) ) ) by L1123 , L1124 , L1127 , L1128 , L1115;
thus L1139: thesis by L1138 , L1137 , L1084;
end;
theorem
L1140: (for B214 being _Tree holds (for B215 , B216 , B217 being (Vertex of B214) holds (for B218 being non  empty set holds ((for B219 being set holds (B219 in B218 implies ((ex B220 being (_Subtree of B214) st B219 = ( the_Vertices_of B220 )) & ((B215 in B219 & B216 in B219) or (B215 in B219 & B217 in B219) or (B216 in B219 & B217 in B219))))) implies ( meet B218 ) <> ( {} )))))
proof
let C281 being _Tree;
let C282 , C283 , C284 being (Vertex of C281);
let C285 being non  empty set;
assume L1141: (for B221 being set holds (B221 in C285 implies ((ex B222 being (_Subtree of C281) st B221 = ( the_Vertices_of B222 )) & ((C282 in B221 & C283 in B221) or (C282 in B221 & C284 in B221) or (C283 in B221 & C284 in B221)))));
set D121 = ( MiddleVertex (C282 , C283 , C284) );
set D122 = ( C281 .pathBetween (C284 , C282) );
set D123 = ( C281 .pathBetween (C283 , C284) );
set D124 = ( C281 .pathBetween (C282 , C284) );
set D125 = ( C281 .pathBetween (C282 , C283) );
set D126 = ( D125 .vertices() );
set D127 = ( D124 .vertices() );
set D128 = ( D123 .vertices() );
set D129 = ( D122 .vertices() );
L1142: ( ( D126 /\ D128 ) /\ D129 ) = { D121 } by L1050;
L1143: D121 in ( ( D126 /\ D128 ) /\ D129 ) by L1142 , TARSKI:def 1;
L1144: D121 in ( D126 /\ D128 ) by L1143 , XBOOLE_0:def 4;
L1145: D121 in D128 by L1144 , XBOOLE_0:def 4;
L1146: D129 = D127 by L787;
L1147: D121 in D127 by L1146 , L1143 , XBOOLE_0:def 4;
L1148: D121 in D126 by L1144 , XBOOLE_0:def 4;
L1149:
now
let C286 being set;
assume L1150: C286 in C285;
L1151: (ex B223 being (_Subtree of C281) st C286 = ( the_Vertices_of B223 )) by L1150 , L1141;
per cases  by L1141 , L1150;
suppose L1152: (C282 in C286 & C283 in C286);

L1153: D126 c= C286 by L1152 , L1151 , L798;
thus L1154: D121 in C286 by L1153 , L1148;
end;
suppose L1155: (C282 in C286 & C284 in C286);

L1156: D127 c= C286 by L1155 , L1151 , L798;
thus L1157: D121 in C286 by L1156 , L1147;
end;
suppose L1158: (C283 in C286 & C284 in C286);

L1159: D128 c= C286 by L1158 , L1151 , L798;
thus L1160: D121 in C286 by L1159 , L1145;
end;
end;
thus L1162: thesis by L1149 , SETFAM_1:def 1;
end;
begin
definition
let C287 being set;
attr C287 is  with_Helly_property
means
(for B224 being non  empty set holds ((B224 c= C287 & (for B225 , B226 being set holds ((B225 in B224 & B226 in B224) implies B225 meets B226))) implies ( meet B224 ) <> ( {} )));
end;
theorem
L1164: (for B227 being _Tree holds (for B228 being  finite set holds ((for B229 being set holds (B229 in B228 implies (ex B230 being (_Subtree of B227) st B229 = ( the_Vertices_of B230 )))) implies B228 is  with_Helly_property)))
proof
let C288 being _Tree;
let C289 being  finite set;
assume that
L1165: (for B231 being set holds (B231 in C289 implies (ex B232 being (_Subtree of C288) st B231 = ( the_Vertices_of B232 ))));
defpred S5[ Nat ] means (for B233 being non  empty  finite set holds ((( card B233 ) = $1 & B233 c= C289 & (for B234 , B235 being set holds ((B234 in B233 & B235 in B233) implies B234 meets B235))) implies ( meet B233 ) <> ( {} )));
L1166: (for B236 being Nat holds ((for B237 being Nat holds (B237 < B236 implies S5[ B237 ])) implies S5[ B236 ]))
proof
let C290 being Nat;
assume that
L1167: (for B238 being Nat holds (B238 < C290 implies S5[ B238 ]));
let C291 being non  empty  finite set;
assume that
L1168: ( card C291 ) = C290
and
L1169: C291 c= C289
and
L1170: (for B239 , B240 being set holds ((B239 in C291 & B240 in C291) implies B239 meets B240));
per cases  by NAT_1:25;
suppose L1171: C290 = ( 0 );

thus L1172: thesis by L1171 , L1168;
end;
suppose L1173: C290 = 1;

consider C292 being (Element of C291) such that L1174: C291 = { C292 } by L1173 , L1168 , GRAPH_5:5;
L1175: C292 in C291;
L1176: (ex B241 being (_Subtree of C288) st C292 = ( the_Vertices_of B241 )) by L1175 , L1165 , L1169;
thus L1177: thesis by L1176 , L1174 , SETFAM_1:10;
end;
suppose L1178: C290 > 1;

set D130 = ( choose C291 );
set D131 = ( C291 \ { D130 } );
L1179: ( card D131 ) = ( ( card C291 ) - ( card { D130 } ) ) by EULER_1:4
.= ( C290 - 1 ) by L1168 , CARD_1:30;
L1180: ( C290 - 1 ) > ( 1 - 1 ) by L1178 , XREAL_1:9;
reconsider D132 = D131 as non  empty  finite set by L1180 , L1179;
L1181: D132 c= C289 by L1169 , XBOOLE_1:1;
L1182: (for B242 , B243 being set holds ((B242 in D132 & B243 in D132) implies B242 meets B243)) by L1170;
reconsider D133 = ( meet D132 ) as non  empty set by L1182 , L1167 , L1179 , L1181 , XREAL_1:44;
set D134 = ( choose D132 );
set D135 = ( C291 \ { D134 } );
L1183: D134 in D132;
L1184: ( card D135 ) = ( ( card C291 ) - ( card { D134 } ) ) by L1183 , EULER_1:4
.= ( C290 - 1 ) by L1168 , CARD_1:30;
set D136 = { D130 , D134 };
L1185: ( meet D136 ) = ( D130 /\ D134 ) by SETFAM_1:11;
L1186: D130 meets D134 by L1170 , L1183;
reconsider D137 = ( meet D136 ) as non  empty set by L1186 , L1185 , XBOOLE_0:def 7;
L1187: ( C290 - 1 ) > ( 1 - 1 ) by L1178 , XREAL_1:9;
reconsider D138 = D135 as non  empty  finite set by L1187 , L1184;
L1188: D138 c= C289 by L1169 , XBOOLE_1:1;
L1189: (for B244 , B245 being set holds ((B244 in D138 & B245 in D138) implies B244 meets B245)) by L1170;
reconsider D139 = ( meet D138 ) as non  empty set by L1189 , L1167 , L1184 , L1188 , XREAL_1:44;
set D140 = ( choose D133 );
set D141 = ( choose D139 );
set D142 = ( choose D137 );
L1190: (D142 in D137 & D137 c= ( union D136 )) by SETFAM_1:2;
consider C293 being set such that L1191: D142 in C293 and L1192: C293 in D136 by L1190 , TARSKI:def 4;
L1193: D130 in C291;
L1194: D136 c= C289 by L1193 , L1169 , L1183 , L1181 , ZFMISC_1:32;
L1195: (ex B246 being (_Subtree of C288) st C293 = ( the_Vertices_of B246 )) by L1194 , L1165 , L1192;
L1196: (D140 in D133 & D133 c= ( union D132 )) by SETFAM_1:2;
consider C294 being set such that L1197: D140 in C294 and L1198: C294 in D132 by L1196 , TARSKI:def 4;
L1199: (D141 in D139 & D139 c= ( union D138 )) by SETFAM_1:2;
consider C295 being set such that L1200: D141 in C295 and L1201: C295 in D138 by L1199 , TARSKI:def 4;
L1202: (ex B247 being (_Subtree of C288) st C295 = ( the_Vertices_of B247 )) by L1165 , L1188 , L1201;
L1203: (ex B248 being (_Subtree of C288) st C294 = ( the_Vertices_of B248 )) by L1165 , L1181 , L1198;
reconsider D143 = D140 , D144 = D141 , D145 = D142 as (Vertex of C288) by L1203 , L1197 , L1200 , L1202 , L1191 , L1195;
L1204: D134 <> D130 by ZFMISC_1:56;
L1205:
now
let C296 being set;
assume L1206: C296 in C291;
thus L1207: (ex B249 being (_Subtree of C288) st C296 = ( the_Vertices_of B249 )) by L1206 , L1165 , L1169;
thus L1208: ((D143 in C296 & D144 in C296) or (D143 in C296 & D145 in C296) or (D144 in C296 & D145 in C296))
proof
per cases ;
suppose L1209: C296 = D130;

L1210: (C296 in D136 & C296 in D138) by L1209 , L1204 , TARSKI:def 2 , ZFMISC_1:56;
thus L1211: thesis by L1210 , SETFAM_1:def 1;
end;
suppose L1212: C296 = D134;

L1213: C296 in D136 by L1212 , TARSKI:def 2;
thus L1214: thesis by L1213 , L1212 , SETFAM_1:def 1;
end;
suppose L1215: (C296 <> D130 & C296 <> D134);

L1216: (C296 in D132 & C296 in D138) by L1215 , L1206 , ZFMISC_1:56;
thus L1217: thesis by L1216 , SETFAM_1:def 1;
end;
end;

end;
thus L1209: thesis by L1205 , L1140;
end;
end;
L1211: (for B250 being Nat holds S5[ B250 ]) from NAT_1:sch 4(L1166);
let C297 being non  empty set;
assume that
L1212: C297 c= C289
and
L1213: (for B251 , B252 being set holds ((B251 in C297 & B252 in C297) implies B251 meets B252));
reconsider D146 = C297 as  finite set by L1212;
L1214: ( card D146 ) = ( card D146 );
thus L1215: thesis by L1214 , L1211 , L1212 , L1213;
end;
