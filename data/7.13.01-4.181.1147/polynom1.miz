:: Multivariate polynomials with arbitrary number of variables
::  by Piotr Rudnicki and Andrzej Trybulec
::
:: Received September 22, 1999
:: Copyright (c) 1999-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, STRUCT_0, ZFMISC_1, RLVECT_1, ALGSTR_0, VECTSP_1,
      XBOOLE_0, SUPINF_2, MESFUNC1, SUBSET_1, RELAT_1, FINSEQ_1, ARYTM_3,
      PARTFUN1, TARSKI, CARD_3, NAT_1, ORDINAL4, FUNCT_1, FVSUM_1, ALGSTR_1,
      BINOP_1, LATTICES, PRE_POLY, ALGSEQ_1, FINSET_1, ARYTM_1, FUNCOP_1,
      GROUP_1, FUNCT_4, ORDINAL1, XXREAL_0, FINSEQ_2, MEMBER_1, FUNCT_2,
      CARD_1, POLYNOM1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, RELAT_1, FUNCT_1,
      PBOOLE, RELSET_1, FINSET_1, ORDINAL1, PARTFUN1, FUNCT_2, FINSEQ_1,
      STRUCT_0, ALGSTR_0, FUNCT_3, XXREAL_0, BINOP_1, NAT_1, ALGSTR_1,
      RLVECT_1, FINSEQ_2, GROUP_1, VECTSP_1, FUNCOP_1, FUNCT_7, MATRLIN,
      VFUNCT_1, FVSUM_1, PRE_POLY, RECDEF_1;
 constructors BINOP_1, FINSEQOP, FINSEQ_4, RFUNCT_3, FUNCT_7, ALGSTR_1,
      FVSUM_1, MATRLIN, RECDEF_1, RELSET_1, PBOOLE, VFUNCT_1;
 registrations SUBSET_1, RELAT_1, FUNCT_1, FUNCOP_1, FINSET_1, XREAL_0, CARD_1,
      MEMBERED, FINSEQ_1, FINSEQ_2, STRUCT_0, VECTSP_1, ALGSTR_1, VALUED_0,
      PRE_POLY, RELSET_1, VFUNCT_1, FUNCT_2;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, XBOOLE_0, FUNCT_1, FUNCT_2, RLVECT_1, VECTSP_1, GROUP_1,
      FINSEQ_2, STRUCT_0, ALGSTR_0, FUNCOP_1;
 theorems FUNCT_1, FINSET_1, FINSEQ_3, FINSEQ_4, ZFMISC_1, FINSEQ_1, FUNCT_2,
      RLVECT_1, VECTSP_1, FUNCOP_1, TARSKI, FUNCT_7, BINOP_1, RELAT_1, MATRLIN,
      FINSEQ_2, ORDINAL1, FINSEQ_5, NAT_1, PBOOLE, SUBSET_1, FVSUM_1, FUNCT_3,
      GROUP_1, XBOOLE_0, XBOOLE_1, RLVECT_2, PARTFUN1, XREAL_1, XXREAL_0,
      PRE_POLY, VFUNCT_1;
 schemes FRAENKEL, FUNCT_2, FINSEQ_2, FINSEQ_1, FINSEQ_4, SUBSET_1, BINOP_1;

begin
registration
cluster  degenerated ->  trivial for  add-associative  right_zeroed  right_complementable  right_unital  right-distributive non  empty  add-associative  right_zeroed  right_complementable  right_unital  right-distributive non  empty  add-associative  right_zeroed  right_complementable  right_unital  right-distributive non  empty  add-associative  right_zeroed  right_complementable  right_unital  right-distributive non  empty doubleLoopStr;
coherence
proof
let C1 being  add-associative  right_zeroed  right_complementable  right_unital  right-distributive non  empty doubleLoopStr;
assume that
L1: ( 0. C1 ) = ( 1. C1 );
let C2 being (Element of C1);
thus L2: C2 = ( C2 * ( 1. C1 ) ) by VECTSP_1:def 4
.= ( 0. C1 ) by L1 , VECTSP_1:6;
end;
end;
registration
cluster non  trivial -> non  degenerated for  add-associative  right_zeroed  right_complementable  right_unital  right-distributive non  empty  add-associative  right_zeroed  right_complementable  right_unital  right-distributive non  empty  add-associative  right_zeroed  right_complementable  right_unital  right-distributive non  empty  add-associative  right_zeroed  right_complementable  right_unital  right-distributive non  empty doubleLoopStr;
coherence;
end;
theorem
L5: (for B1 being non  empty addLoopStr holds (for B2 , B3 being (FinSequence of (the carrier of B1)) holds (( dom B2 ) = ( dom B3 ) implies ( dom ( B2 + B3 ) ) = ( dom B2 ))))
proof
let C3 being non  empty addLoopStr;
let C4 , C5 being (FinSequence of (the carrier of C3));
assume L6: ( dom C4 ) = ( dom C5 );
L7: (( rng <: C4 , C5 :> ) c= [: ( rng C4 ) , ( rng C5 ) :] & [: ( rng C4 ) , ( rng C5 ) :] c= [: (the carrier of C3) , (the carrier of C3) :]) by FUNCT_3:51 , ZFMISC_1:96;
L8: [: (the carrier of C3) , (the carrier of C3) :] = ( dom (the addF of C3) ) by FUNCT_2:def 1;
thus L9: ( dom ( C4 + C5 ) ) = ( dom ( (the addF of C3) .: (C4 , C5) ) ) by FVSUM_1:def 3
.= ( dom <: C4 , C5 :> ) by L7 , L8 , RELAT_1:27 , XBOOLE_1:1
.= ( ( dom C4 ) /\ ( dom C5 ) ) by FUNCT_3:def 7
.= ( dom C4 ) by L6;
end;
theorem
L10: (for B4 being non  empty addLoopStr holds (for B5 being (FinSequence of ( (the carrier of B4) * )) holds ( dom ( Sum B5 ) ) = ( dom B5 )))
proof
let C6 being non  empty addLoopStr;
let C7 being (FinSequence of ( (the carrier of C6) * ));
L11: ( len ( Sum C7 ) ) = ( len C7 ) by MATRLIN:def 6;
thus L12: thesis by L11 , FINSEQ_3:29;
end;
theorem
L13: (for B6 being non  empty addLoopStr holds (for B7 being (FinSequence of ( (the carrier of B6) * )) holds ( Sum ( <*> ( (the carrier of B6) * ) ) ) = ( <*> (the carrier of B6) )))
proof
let C8 being non  empty addLoopStr;
let C9 being (FinSequence of ( (the carrier of C8) * ));
L14: ( dom ( Sum ( <*> ( (the carrier of C8) * ) ) ) ) = ( dom ( <*> ( (the carrier of C8) * ) ) ) by L10;
thus L15: thesis by L14;
end;
theorem
L16: (for B8 being non  empty addLoopStr holds (for B9 being (Element of ( (the carrier of B8) * )) holds <* ( Sum B9 ) *> = ( Sum <* B9 *> )))
proof
let C10 being non  empty addLoopStr;
let C11 being (Element of ( (the carrier of C10) * ));
L17:
now
let C12 being Nat;
assume L18: C12 in ( dom <* C11 *> );
L19: C12 in { 1 } by L18 , FINSEQ_1:2 , FINSEQ_1:38;
L20: C12 = 1 by L19 , TARSKI:def 1;
thus L21: ( <* ( Sum C11 ) *> /. C12 ) = ( Sum C11 ) by L20 , FINSEQ_4:16
.= ( Sum ( <* C11 *> /. C12 ) ) by L20 , FINSEQ_4:16;
end;
L22: ( dom <* ( Sum C11 ) *> ) = ( Seg 1 ) by FINSEQ_1:38
.= ( dom <* C11 *> ) by FINSEQ_1:38;
L23: ( len <* ( Sum C11 ) *> ) = ( len <* C11 *> ) by L22 , FINSEQ_3:29;
thus L24: thesis by L23 , L22 , L17 , MATRLIN:def 6;
end;
theorem
L25: (for B10 being non  empty addLoopStr holds (for B11 , B12 being (FinSequence of ( (the carrier of B10) * )) holds ( Sum ( B11 ^ B12 ) ) = ( ( Sum B11 ) ^ ( Sum B12 ) )))
proof
let C13 being non  empty addLoopStr;
let C14 , C15 being (FinSequence of ( (the carrier of C13) * ));
L26: ( dom ( Sum C14 ) ) = ( dom C14 ) by L10;
L27: ( dom ( Sum C15 ) ) = ( dom C15 ) by L10;
L28: ( len ( ( Sum C14 ) ^ ( Sum C15 ) ) ) = ( ( len ( Sum C14 ) ) + ( len ( Sum C15 ) ) ) by FINSEQ_1:22
.= ( ( len C14 ) + ( len ( Sum C15 ) ) ) by L26 , FINSEQ_3:29
.= ( ( len C14 ) + ( len C15 ) ) by L27 , FINSEQ_3:29
.= ( len ( C14 ^ C15 ) ) by FINSEQ_1:22;
L29: ( dom ( ( Sum C14 ) ^ ( Sum C15 ) ) ) = ( dom ( C14 ^ C15 ) ) by L28 , FINSEQ_3:29;
L30: ( len ( Sum C14 ) ) = ( len C14 ) by L26 , FINSEQ_3:29;
L31:
now
let C16 being Nat;
assume that
L32: C16 in ( dom ( C14 ^ C15 ) );
per cases  by L32 , FINSEQ_1:25;
suppose L33: C16 in ( dom C14 );

thus L34: ( ( ( Sum C14 ) ^ ( Sum C15 ) ) /. C16 ) = ( ( ( Sum C14 ) ^ ( Sum C15 ) ) . C16 ) by L29 , L32 , PARTFUN1:def 6
.= ( ( Sum C14 ) . C16 ) by L26 , L33 , FINSEQ_1:def 7
.= ( ( Sum C14 ) /. C16 ) by L26 , L33 , PARTFUN1:def 6
.= ( Sum ( C14 /. C16 ) ) by L26 , L33 , MATRLIN:def 6
.= ( Sum ( ( C14 ^ C15 ) /. C16 ) ) by L33 , FINSEQ_4:68;
end;
suppose L35: (ex B13 being Nat st (B13 in ( dom C15 ) & C16 = ( ( len C14 ) + B13 )));

consider C17 being Nat such that L36: C17 in ( dom C15 ) and L37: C16 = ( ( len C14 ) + C17 ) by L35;
thus L38: ( ( ( Sum C14 ) ^ ( Sum C15 ) ) /. C16 ) = ( ( ( Sum C14 ) ^ ( Sum C15 ) ) . C16 ) by L29 , L32 , PARTFUN1:def 6
.= ( ( Sum C15 ) . C17 ) by L27 , L30 , L36 , L37 , FINSEQ_1:def 7
.= ( ( Sum C15 ) /. C17 ) by L27 , L36 , PARTFUN1:def 6
.= ( Sum ( C15 /. C17 ) ) by L27 , L36 , MATRLIN:def 6
.= ( Sum ( ( C14 ^ C15 ) /. C16 ) ) by L36 , L37 , FINSEQ_4:69;
end;
end;
thus L40: thesis by L31 , L28 , L29 , MATRLIN:def 6;
end;
definition
let C18 being non  empty multMagma;
let C19 being (FinSequence of (the carrier of C18));
let C20 being (Element of C18);
redefine func C20 * C19 means 
:L41: (( dom it ) = ( dom C19 ) & (for B14 being set holds (B14 in ( dom C19 ) implies ( it /. B14 ) = ( C20 * ( C19 /. B14 ) ))));
compatibility
proof
L42:
now
set D1 = ( ( C20 multfield ) * C19 );
let C21 being (FinSequence of (the carrier of C18));
assume that
L43: ( dom C21 ) = ( dom C19 )
and
L44: (for B15 being set holds (B15 in ( dom C19 ) implies ( C21 /. B15 ) = ( C20 * ( C19 /. B15 ) )));
L45: (for B16 being set holds (B16 in ( dom C21 ) implies ( C21 . B16 ) = ( D1 . B16 )))
proof
let C22 being set;
assume L46: C22 in ( dom C21 );
L47: ( C21 . C22 ) = ( C21 /. C22 ) by L46 , PARTFUN1:def 6
.= ( C20 * ( C19 /. C22 ) ) by L43 , L44 , L46
.= ( ( C20 multfield ) . ( C19 /. C22 ) ) by FVSUM_1:49
.= ( ( C20 multfield ) . ( C19 . C22 ) ) by L43 , L46 , PARTFUN1:def 6
.= ( D1 . C22 ) by L43 , L46 , FUNCT_1:13;
thus L48: thesis by L47;
end;
L49: (( rng C19 ) c= (the carrier of C18) & ( dom ( C20 multfield ) ) = (the carrier of C18)) by FUNCT_2:def 1;
L50: ( dom C21 ) = ( dom D1 ) by L49 , L43 , RELAT_1:27;
L51: C21 = D1 by L50 , L45 , FUNCT_1:2;
thus L52: C21 = ( C20 * C19 ) by L51 , FVSUM_1:def 6;
end;
set D2 = ( C20 * C19 );
L53: ( rng C19 ) c= ( dom ( C20 multfield ) )
proof
let C23 being set;
L54: ( dom ( C20 multfield ) ) = (the carrier of C18) by FUNCT_2:def 1;
thus L55: thesis by L54;
end;
L56: D2 = ( ( C20 multfield ) * C19 ) by FVSUM_1:def 6;
L57: ( dom D2 ) = ( dom C19 ) by L56 , L53 , RELAT_1:27;
L58: (for B17 being set holds (B17 in ( dom C19 ) implies ( D2 /. B17 ) = ( C20 * ( C19 /. B17 ) )))
proof
let C24 being set;
assume L59: C24 in ( dom C19 );
L60: ( D2 . C24 ) = ( ( ( C20 multfield ) * C19 ) . C24 ) by FVSUM_1:def 6
.= ( ( C20 multfield ) . ( C19 . C24 ) ) by L59 , FUNCT_1:13
.= ( ( C20 multfield ) . ( C19 /. C24 ) ) by L59 , PARTFUN1:def 6
.= ( C20 * ( C19 /. C24 ) ) by FVSUM_1:49;
thus L61: thesis by L60 , L57 , L59 , PARTFUN1:def 6;
end;
thus L62: thesis by L58 , L56 , L53 , L42 , RELAT_1:27;
end;
end;
definition
let C25 being non  empty multMagma;
let C26 being (FinSequence of (the carrier of C25));
let C27 being (Element of C25);
func C26 * C27 -> (FinSequence of (the carrier of C25)) means 
:L64: (( dom it ) = ( dom C26 ) & (for B18 being set holds (B18 in ( dom C26 ) implies ( it /. B18 ) = ( ( C26 /. B18 ) * C27 ))));
existence
proof
deffunc H1(set) = ( ( C26 /. $1 ) * C27 );
consider C28 being (FinSequence of (the carrier of C25)) such that L65: ( len C28 ) = ( len C26 ) and L66: (for B19 being Nat holds (B19 in ( dom C28 ) implies ( C28 /. B19 ) = H1(B19))) from FINSEQ_4:sch 2;
take C28;
thus L67: ( dom C28 ) = ( dom C26 ) by L65 , FINSEQ_3:29;
let C29 being set;
assume L68: C29 in ( dom C26 );
thus L69: thesis by L68 , L66 , L67;
end;
uniqueness
proof
let C30 , C31 being (FinSequence of (the carrier of C25));
assume that
L70: ( dom C30 ) = ( dom C26 )
and
L71: (for B20 being set holds (B20 in ( dom C26 ) implies ( C30 /. B20 ) = ( ( C26 /. B20 ) * C27 )))
and
L72: ( dom C31 ) = ( dom C26 )
and
L73: (for B21 being set holds (B21 in ( dom C26 ) implies ( C31 /. B21 ) = ( ( C26 /. B21 ) * C27 )));
L74:
now
let C32 being Nat;
assume L75: C32 in ( dom C26 );
thus L76: ( C30 /. C32 ) = ( ( C26 /. C32 ) * C27 ) by L75 , L71
.= ( C31 /. C32 ) by L73 , L75;
end;
thus L77: thesis by L74 , L70 , L72 , FINSEQ_5:12;
end;
end;
theorem
L79: (for B22 being non  empty multMagma holds (for B23 being (Element of B22) holds ( B23 * ( <*> (the carrier of B22) ) ) = ( <*> (the carrier of B22) )))
proof
let C33 being non  empty multMagma;
let C34 being (Element of C33);
L80: ( dom ( C34 * ( <*> (the carrier of C33) ) ) ) = ( dom ( <*> (the carrier of C33) ) ) by L41;
thus L81: thesis by L80;
end;
theorem
L82: (for B24 being non  empty multMagma holds (for B25 being (Element of B24) holds ( ( <*> (the carrier of B24) ) * B25 ) = ( <*> (the carrier of B24) )))
proof
let C35 being non  empty multMagma;
let C36 being (Element of C35);
L83: ( dom ( ( <*> (the carrier of C35) ) * C36 ) ) = ( dom ( <*> (the carrier of C35) ) ) by L64;
thus L84: thesis by L83;
end;
theorem
L85: (for B26 being non  empty multMagma holds (for B27 , B28 being (Element of B26) holds ( B27 * <* B28 *> ) = <* ( B27 * B28 ) *>))
proof
let C37 being non  empty multMagma;
let C38 , C39 being (Element of C37);
L86: (for B29 being set holds (B29 in ( dom <* C39 *> ) implies ( <* ( C38 * C39 ) *> /. B29 ) = ( C38 * ( <* C39 *> /. B29 ) )))
proof
let C40 being set;
assume L87: C40 in ( dom <* C39 *> );
L88: C40 in { 1 } by L87 , FINSEQ_1:2 , FINSEQ_1:38;
L89: C40 = 1 by L88 , TARSKI:def 1;
thus L90: ( <* ( C38 * C39 ) *> /. C40 ) = ( C38 * C39 ) by L89 , FINSEQ_4:16
.= ( C38 * ( <* C39 *> /. C40 ) ) by L89 , FINSEQ_4:16;
end;
L91: ( dom <* ( C38 * C39 ) *> ) = ( Seg 1 ) by FINSEQ_1:38
.= ( dom <* C39 *> ) by FINSEQ_1:38;
thus L92: thesis by L91 , L86 , L41;
end;
theorem
L93: (for B30 being non  empty multMagma holds (for B31 , B32 being (Element of B30) holds ( <* B32 *> * B31 ) = <* ( B32 * B31 ) *>))
proof
let C41 being non  empty multMagma;
let C42 , C43 being (Element of C41);
L94: (for B33 being set holds (B33 in ( dom <* C43 *> ) implies ( <* ( C43 * C42 ) *> /. B33 ) = ( ( <* C43 *> /. B33 ) * C42 )))
proof
let C44 being set;
assume L95: C44 in ( dom <* C43 *> );
L96: C44 in { 1 } by L95 , FINSEQ_1:2 , FINSEQ_1:38;
L97: C44 = 1 by L96 , TARSKI:def 1;
thus L98: ( <* ( C43 * C42 ) *> /. C44 ) = ( C43 * C42 ) by L97 , FINSEQ_4:16
.= ( ( <* C43 *> /. C44 ) * C42 ) by L97 , FINSEQ_4:16;
end;
L99: ( dom <* ( C43 * C42 ) *> ) = ( Seg 1 ) by FINSEQ_1:38
.= ( dom <* C43 *> ) by FINSEQ_1:38;
thus L100: thesis by L99 , L94 , L64;
end;
theorem
L101: (for B34 being non  empty multMagma holds (for B35 being (Element of B34) holds (for B36 , B37 being (FinSequence of (the carrier of B34)) holds ( B35 * ( B36 ^ B37 ) ) = ( ( B35 * B36 ) ^ ( B35 * B37 ) ))))
proof
let C45 being non  empty multMagma;
let C46 being (Element of C45);
let C47 , C48 being (FinSequence of (the carrier of C45));
L102: ( dom ( C46 * ( C47 ^ C48 ) ) ) = ( dom ( C47 ^ C48 ) ) by L41;
L103: ( dom ( C46 * C48 ) ) = ( dom C48 ) by L41;
L104: ( len ( C46 * C48 ) ) = ( len C48 ) by L103 , FINSEQ_3:29;
L105: ( dom ( C46 * C47 ) ) = ( dom C47 ) by L41;
L106: ( len ( C46 * C47 ) ) = ( len C47 ) by L105 , FINSEQ_3:29;
L107:
now
let C49 being Nat;
assume L108: C49 in ( dom ( C46 * ( C47 ^ C48 ) ) );
per cases  by L102 , L108 , FINSEQ_1:25;
suppose L109: C49 in ( dom C47 );

thus L110: ( ( C46 * ( C47 ^ C48 ) ) /. C49 ) = ( C46 * ( ( C47 ^ C48 ) /. C49 ) ) by L102 , L108 , L41
.= ( C46 * ( C47 /. C49 ) ) by L109 , FINSEQ_4:68
.= ( ( C46 * C47 ) /. C49 ) by L109 , L41
.= ( ( ( C46 * C47 ) ^ ( C46 * C48 ) ) /. C49 ) by L105 , L109 , FINSEQ_4:68;
end;
suppose L111: (ex B38 being Nat st (B38 in ( dom C48 ) & C49 = ( ( len C47 ) + B38 )));

consider C50 being Nat such that L112: C50 in ( dom C48 ) and L113: C49 = ( ( len C47 ) + C50 ) by L111;
thus L114: ( ( C46 * ( C47 ^ C48 ) ) /. C49 ) = ( C46 * ( ( C47 ^ C48 ) /. C49 ) ) by L102 , L108 , L41
.= ( C46 * ( C48 /. C50 ) ) by L112 , L113 , FINSEQ_4:69
.= ( ( C46 * C48 ) /. C50 ) by L112 , L41
.= ( ( ( C46 * C47 ) ^ ( C46 * C48 ) ) /. C49 ) by L106 , L103 , L112 , L113 , FINSEQ_4:69;
end;
end;
L116: ( len ( ( C46 * C47 ) ^ ( C46 * C48 ) ) ) = ( ( len ( C46 * C47 ) ) + ( len ( C46 * C48 ) ) ) by FINSEQ_1:22
.= ( len ( C47 ^ C48 ) ) by L106 , L104 , FINSEQ_1:22;
L117: ( dom ( C46 * ( C47 ^ C48 ) ) ) = ( dom ( ( C46 * C47 ) ^ ( C46 * C48 ) ) ) by L116 , L102 , FINSEQ_3:29;
thus L118: thesis by L117 , L107 , FINSEQ_5:12;
end;
theorem
L119: (for B39 being non  empty multMagma holds (for B40 being (Element of B39) holds (for B41 , B42 being (FinSequence of (the carrier of B39)) holds ( ( B41 ^ B42 ) * B40 ) = ( ( B41 * B40 ) ^ ( B42 * B40 ) ))))
proof
let C51 being non  empty multMagma;
let C52 being (Element of C51);
let C53 , C54 being (FinSequence of (the carrier of C51));
L120: ( dom ( ( C53 ^ C54 ) * C52 ) ) = ( dom ( C53 ^ C54 ) ) by L64;
L121: ( dom ( C54 * C52 ) ) = ( dom C54 ) by L64;
L122: ( len ( C54 * C52 ) ) = ( len C54 ) by L121 , FINSEQ_3:29;
L123: ( dom ( C53 * C52 ) ) = ( dom C53 ) by L64;
L124: ( len ( C53 * C52 ) ) = ( len C53 ) by L123 , FINSEQ_3:29;
L125:
now
let C55 being Nat;
assume L126: C55 in ( dom ( ( C53 ^ C54 ) * C52 ) );
per cases  by L120 , L126 , FINSEQ_1:25;
suppose L127: C55 in ( dom C53 );

thus L128: ( ( ( C53 ^ C54 ) * C52 ) /. C55 ) = ( ( ( C53 ^ C54 ) /. C55 ) * C52 ) by L120 , L126 , L64
.= ( ( C53 /. C55 ) * C52 ) by L127 , FINSEQ_4:68
.= ( ( C53 * C52 ) /. C55 ) by L127 , L64
.= ( ( ( C53 * C52 ) ^ ( C54 * C52 ) ) /. C55 ) by L123 , L127 , FINSEQ_4:68;
end;
suppose L129: (ex B43 being Nat st (B43 in ( dom C54 ) & C55 = ( ( len C53 ) + B43 )));

consider C56 being Nat such that L130: C56 in ( dom C54 ) and L131: C55 = ( ( len C53 ) + C56 ) by L129;
thus L132: ( ( ( C53 ^ C54 ) * C52 ) /. C55 ) = ( ( ( C53 ^ C54 ) /. C55 ) * C52 ) by L120 , L126 , L64
.= ( ( C54 /. C56 ) * C52 ) by L130 , L131 , FINSEQ_4:69
.= ( ( C54 * C52 ) /. C56 ) by L130 , L64
.= ( ( ( C53 * C52 ) ^ ( C54 * C52 ) ) /. C55 ) by L124 , L121 , L130 , L131 , FINSEQ_4:69;
end;
end;
L134: ( len ( ( C53 * C52 ) ^ ( C54 * C52 ) ) ) = ( ( len ( C53 * C52 ) ) + ( len ( C54 * C52 ) ) ) by FINSEQ_1:22
.= ( len ( C53 ^ C54 ) ) by L124 , L122 , FINSEQ_1:22;
L135: ( dom ( ( C53 ^ C54 ) * C52 ) ) = ( dom ( ( C53 * C52 ) ^ ( C54 * C52 ) ) ) by L134 , L120 , FINSEQ_3:29;
thus L136: thesis by L135 , L125 , FINSEQ_5:12;
end;
registration
cluster  right_unital for non  empty  strict non  empty  strict non  empty  strict non  empty  strict multLoopStr_0;
existence
proof
take ( multEX_0 );
thus L137: thesis;
end;
end;
registration
cluster  strict  Abelian  add-associative  right_zeroed  right_complementable  associative  commutative  distributive  almost_left_invertible  well-unital non  trivial for non  empty non  empty non  empty non  empty doubleLoopStr;
existence
proof
take ( F_Real );
thus L139: thesis;
end;
end;
theorem
L141: (for B44 being  add-associative  right_zeroed  right_complementable  right_unital  distributive non  empty doubleLoopStr holds (for B45 being (Element of B44) holds (for B46 being (FinSequence of (the carrier of B44)) holds ( Sum ( B45 * B46 ) ) = ( B45 * ( Sum B46 ) ))))
proof
let C57 being  add-associative  right_zeroed  right_complementable  right_unital  distributive non  empty doubleLoopStr;
let C58 being (Element of C57);
set D3 = ( <*> (the carrier of C57) );
defpred S1[ (FinSequence of (the carrier of C57)) ] means ( Sum ( C58 * $1 ) ) = ( C58 * ( Sum $1 ) );
L142:
now
let C59 being (FinSequence of (the carrier of C57));
let C60 being (Element of C57);
assume that
L143: S1[ C59 ];
L144: ( Sum ( C58 * ( C59 ^ <* C60 *> ) ) ) = ( Sum ( ( C58 * C59 ) ^ ( C58 * <* C60 *> ) ) ) by L101
.= ( ( Sum ( C58 * C59 ) ) + ( Sum ( C58 * <* C60 *> ) ) ) by RLVECT_1:41
.= ( ( Sum ( C58 * C59 ) ) + ( Sum <* ( C58 * C60 ) *> ) ) by L85
.= ( ( Sum ( C58 * C59 ) ) + ( C58 * C60 ) ) by RLVECT_1:44
.= ( ( C58 * ( Sum C59 ) ) + ( C58 * ( Sum <* C60 *> ) ) ) by L143 , RLVECT_1:44
.= ( C58 * ( ( Sum C59 ) + ( Sum <* C60 *> ) ) ) by VECTSP_1:def 7
.= ( C58 * ( Sum ( C59 ^ <* C60 *> ) ) ) by RLVECT_1:41;
thus L145: S1[ ( C59 ^ <* C60 *> ) ] by L144;
end;
L146: (( Sum D3 ) = ( 0. C57 ) & ( Sum ( C58 * D3 ) ) = ( Sum D3 )) by L79 , RLVECT_1:43;
L147: S1[ D3 ] by L146 , VECTSP_1:6;
thus L148: (for B47 being (FinSequence of (the carrier of C57)) holds S1[ B47 ]) from FINSEQ_2:sch 2(L147 , L142);
end;
theorem
L149: (for B48 being  add-associative  right_zeroed  right_complementable  right_unital  distributive non  empty doubleLoopStr holds (for B49 being (Element of B48) holds (for B50 being (FinSequence of (the carrier of B48)) holds ( Sum ( B50 * B49 ) ) = ( ( Sum B50 ) * B49 ))))
proof
let C61 being  add-associative  right_zeroed  right_complementable  right_unital  distributive non  empty doubleLoopStr;
let C62 being (Element of C61);
set D4 = ( <*> (the carrier of C61) );
defpred S2[ (FinSequence of (the carrier of C61)) ] means ( Sum ( $1 * C62 ) ) = ( ( Sum $1 ) * C62 );
L150:
now
let C63 being (FinSequence of (the carrier of C61));
let C64 being (Element of C61);
assume that
L151: S2[ C63 ];
L152: ( Sum ( ( C63 ^ <* C64 *> ) * C62 ) ) = ( Sum ( ( C63 * C62 ) ^ ( <* C64 *> * C62 ) ) ) by L119
.= ( ( Sum ( C63 * C62 ) ) + ( Sum ( <* C64 *> * C62 ) ) ) by RLVECT_1:41
.= ( ( Sum ( C63 * C62 ) ) + ( Sum <* ( C64 * C62 ) *> ) ) by L93
.= ( ( Sum ( C63 * C62 ) ) + ( C64 * C62 ) ) by RLVECT_1:44
.= ( ( ( Sum C63 ) * C62 ) + ( ( Sum <* C64 *> ) * C62 ) ) by L151 , RLVECT_1:44
.= ( ( ( Sum C63 ) + ( Sum <* C64 *> ) ) * C62 ) by VECTSP_1:def 7
.= ( ( Sum ( C63 ^ <* C64 *> ) ) * C62 ) by RLVECT_1:41;
thus L153: S2[ ( C63 ^ <* C64 *> ) ] by L152;
end;
L154: (( Sum D4 ) = ( 0. C61 ) & ( Sum ( D4 * C62 ) ) = ( Sum D4 )) by L82 , RLVECT_1:43;
L155: S2[ D4 ] by L154 , VECTSP_1:7;
thus L156: (for B51 being (FinSequence of (the carrier of C61)) holds S2[ B51 ]) from FINSEQ_2:sch 2(L155 , L150);
end;
begin
theorem
L157: (for B52 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B53 being (FinSequence of ( (the carrier of B52) * )) holds ( Sum ( FlattenSeq B53 ) ) = ( Sum ( Sum B53 ) )))
proof
let C65 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
defpred S3[ (FinSequence of ( (the carrier of C65) * )) ] means ( Sum ( FlattenSeq $1 ) ) = ( Sum ( Sum $1 ) );
L158: (for B54 being (FinSequence of ( (the carrier of C65) * )) holds (for B55 being (Element of ( (the carrier of C65) * )) holds (S3[ B54 ] implies S3[ ( B54 ^ <* B55 *> ) ])))
proof
let C66 being (FinSequence of ( (the carrier of C65) * ));
let C67 being (Element of ( (the carrier of C65) * ));
assume that
L159: ( Sum ( FlattenSeq C66 ) ) = ( Sum ( Sum C66 ) );
thus L160: ( Sum ( FlattenSeq ( C66 ^ <* C67 *> ) ) ) = ( Sum ( ( FlattenSeq C66 ) ^ ( FlattenSeq <* C67 *> ) ) ) by PRE_POLY:3
.= ( Sum ( ( FlattenSeq C66 ) ^ C67 ) ) by PRE_POLY:1
.= ( ( Sum ( Sum C66 ) ) + ( Sum C67 ) ) by L159 , RLVECT_1:41
.= ( ( Sum ( Sum C66 ) ) + ( Sum <* ( Sum C67 ) *> ) ) by RLVECT_1:44
.= ( Sum ( ( Sum C66 ) ^ <* ( Sum C67 ) *> ) ) by RLVECT_1:41
.= ( Sum ( ( Sum C66 ) ^ ( Sum <* C67 *> ) ) ) by L16
.= ( Sum ( Sum ( C66 ^ <* C67 *> ) ) ) by L25;
end;
L161: ( Sum ( FlattenSeq ( <*> ( (the carrier of C65) * ) ) ) ) = ( Sum ( <*> (the carrier of C65) ) );
L162: S3[ ( <*> ( (the carrier of C65) * ) ) ] by L161 , L13;
thus L163: (for B56 being (FinSequence of ( (the carrier of C65) * )) holds S3[ B56 ]) from FINSEQ_2:sch 2(L162 , L158);
end;
definition
let C68 being non  empty set;
let C69 being ZeroStr;
let C70 being (Function of C68 , C69);
func Support C70 -> (Subset of C68) means 
:L164: (for B57 being (Element of C68) holds (B57 in it iff ( C70 . B57 ) <> ( 0. C69 )));
existence
proof
defpred S4[ set ] means ( C70 . $1 ) <> ( 0. C69 );
consider C71 being (Subset of C68) such that L165: (for B58 being (Element of C68) holds (B58 in C71 iff S4[ B58 ])) from SUBSET_1:sch 3;
take C71;
thus L166: thesis by L165;
end;
uniqueness
proof
let C72 , C73 being (Subset of C68);
assume that
L167: (for B59 being (Element of C68) holds (B59 in C72 iff ( C70 . B59 ) <> ( 0. C69 )))
and
L168: (for B60 being (Element of C68) holds (B60 in C73 iff ( C70 . B60 ) <> ( 0. C69 )));
L169:
now
let C74 being (Element of C68);
L170: (C74 in C72 iff ( C70 . C74 ) <> ( 0. C69 )) by L167;
thus L171: (C74 in C72 iff C74 in C73) by L170 , L168;
end;
thus L172: thesis by L169 , SUBSET_1:3;
end;
end;
definition
let C75 being non  empty set;
let C76 being ZeroStr;
let C77 being (Function of C75 , C76);
attr C77 is  finite-Support
means
:L174: ( Support C77 ) is  finite;
end;
definition
let C78 being set;
let C79 being non  empty 1-sorted;
let C80 being (Function of ( Bags C78 ) , C79);
let C81 being (bag of C78);
redefine func C80 . C81 -> (Element of C79);

coherence
proof
reconsider D5 = C81 as (Element of ( Bags C78 )) by PRE_POLY:def 12;
reconsider D6 = C80 as (Function of ( Bags C78 ) , (the carrier of C79));
L176: ( D6 . D5 ) is (Element of C79);
thus L177: thesis by L176;
end;
end;
begin
definition
let C82 being set;
let C83 being 1-sorted;
mode Series of C82 , C83
 is (Function of ( Bags C82 ) , C83);
end;
definition
let C84 being set;
let C85 being non  empty addLoopStr;
let C86 , C87 being (Series of C84 , C85);
func C86 + C87 -> (Series of C84 , C85) equals 
( C86 + C87 );
coherence;
end;
theorem
L181: (for B61 being set holds (for B62 being non  empty addLoopStr holds (for B63 , B64 being (Series of B61 , B62) holds (for B65 being (bag of B61) holds ( ( B63 + B64 ) . B65 ) = ( ( B63 . B65 ) + ( B64 . B65 ) )))))
proof
let C88 being set;
let C89 being non  empty addLoopStr;
let C90 , C91 being (Series of C88 , C89);
let C92 being (bag of C88);
L182: (( dom C90 ) = ( Bags C88 ) & ( dom C91 ) = ( Bags C88 )) by FUNCT_2:def 1;
L183: C92 in ( Bags C88 ) by PRE_POLY:def 12;
L184: (( C90 /. C92 ) = ( C90 . C92 ) & ( C91 /. C92 ) = ( C91 . C92 )) by L183 , L182 , PARTFUN1:def 6;
L185: ( dom ( C90 + C91 ) ) = ( ( dom C90 ) /\ ( dom C91 ) ) by VFUNCT_1:def 1;
thus L186: ( ( C90 + C91 ) . C92 ) = ( ( C90 + C91 ) /. C92 ) by L185 , L182 , L183 , PARTFUN1:def 6
.= ( ( C90 . C92 ) + ( C91 . C92 ) ) by L182 , L183 , L184 , L185 , VFUNCT_1:def 1;
end;
theorem
L187: (for B66 being set holds (for B67 being non  empty addLoopStr holds (for B68 , B69 , B70 being (Series of B66 , B67) holds ((for B71 being (bag of B66) holds ( B70 . B71 ) = ( ( B68 . B71 ) + ( B69 . B71 ) )) implies B70 = ( B68 + B69 )))))
proof
let C93 being set;
let C94 being non  empty addLoopStr;
let C95 , C96 , C97 being (Series of C93 , C94);
assume L188: (for B72 being (bag of C93) holds ( C97 . B72 ) = ( ( C95 . B72 ) + ( C96 . B72 ) ));
let C98 being (Element of ( Bags C93 ));
L189: ( dom ( C95 + C96 ) ) = ( Bags C93 ) by FUNCT_2:def 1;
L190: ( ( C95 + C96 ) /. C98 ) = ( ( C95 + C96 ) . C98 );
L191: (( C95 /. C98 ) = ( C95 . C98 ) & ( C96 /. C98 ) = ( C96 . C98 ));
thus L192: ( C97 . C98 ) = ( ( C95 . C98 ) + ( C96 . C98 ) ) by L188
.= ( ( C95 + C96 ) . C98 ) by L189 , L190 , L191 , VFUNCT_1:def 1;
end;
theorem
L193: (for B73 being set holds (for B74 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B75 being (Series of B73 , B74) holds (for B76 being (bag of B73) holds ( ( - B75 ) . B76 ) = ( - ( B75 . B76 ) )))))
proof
let C99 being set;
let C100 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C101 being (Series of C99 , C100);
let C102 being (bag of C99);
L194: ( dom C101 ) = ( Bags C99 ) by FUNCT_2:def 1;
L195: C102 in ( Bags C99 ) by PRE_POLY:def 12;
L196: ( C101 /. C102 ) = ( C101 . C102 ) by L195 , L194 , PARTFUN1:def 6;
L197: ( dom ( - C101 ) ) = ( dom C101 ) by VFUNCT_1:def 5;
thus L198: ( ( - C101 ) . C102 ) = ( ( - C101 ) /. C102 ) by L197 , L194 , L195 , PARTFUN1:def 6
.= ( - ( C101 . C102 ) ) by L194 , L195 , L196 , L197 , VFUNCT_1:def 5;
end;
theorem
L199: (for B77 being set holds (for B78 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B79 , B80 being (Series of B77 , B78) holds ((for B81 being (bag of B77) holds ( B80 . B81 ) = ( - ( B79 . B81 ) )) implies B80 = ( - B79 )))))
proof
let C103 being set;
let C104 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C105 , C106 being (Series of C103 , C104);
assume L200: (for B82 being (bag of C103) holds ( C106 . B82 ) = ( - ( C105 . B82 ) ));
let C107 being (Element of ( Bags C103 ));
L201: ( dom ( - C105 ) ) = ( Bags C103 ) by FUNCT_2:def 1;
L202: ( ( - C105 ) /. C107 ) = ( ( - C105 ) . C107 );
L203: ( C105 /. C107 ) = ( C105 . C107 );
thus L204: ( C106 . C107 ) = ( - ( C105 . C107 ) ) by L200
.= ( ( - C105 ) . C107 ) by L201 , L202 , L203 , VFUNCT_1:def 5;
end;
theorem
L205: (for B83 being set holds (for B84 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B85 being (Series of B83 , B84) holds B85 = ( - ( - B85 ) ))))
proof
let C108 being set;
let C109 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C110 being (Series of C108 , C109);
set D7 = ( - C110 );
L206: ( dom C110 ) = ( Bags C108 ) by FUNCT_2:def 1;
L207: ( dom D7 ) = ( Bags C108 ) by FUNCT_2:def 1;
L208: ( dom ( - C110 ) ) = ( dom C110 ) by VFUNCT_1:def 5;
L209: ( dom ( - D7 ) ) = ( dom D7 ) by VFUNCT_1:def 5;
L210: ( dom ( - ( - C110 ) ) ) = ( dom ( - C110 ) ) by VFUNCT_1:def 5;
L211:
now
let C111 being (Element of ( Bags C108 ));
assume L212: C111 in ( dom C110 );
L213: ( C110 . C111 ) = ( C110 /. C111 );
thus L214: ( C110 . C111 ) = ( - ( - ( C110 . C111 ) ) ) by RLVECT_1:17
.= ( - ( ( - C110 ) /. C111 ) ) by L206 , L208 , L213 , VFUNCT_1:def 5
.= ( ( - ( - C110 ) ) /. C111 ) by L206 , L208 , L210 , VFUNCT_1:def 5
.= ( ( - D7 ) . C111 );
end;
thus L215: thesis by L211 , L206 , L207 , L209 , PARTFUN1:5;
end;
theorem
L216: (for B86 being set holds (for B87 being  right_zeroed non  empty addLoopStr holds (for B88 , B89 being (Series of B86 , B87) holds ( Support ( B88 + B89 ) ) c= ( ( Support B88 ) \/ ( Support B89 ) ))))
proof
let C112 being set;
let C113 being  right_zeroed non  empty addLoopStr;
let C114 , C115 being (Series of C112 , C113);
set D8 = ( C114 + C115 );
set D9 = ( Support C114 );
set D10 = ( Support C115 );
let C116 being set;
assume L217: C116 in ( Support D8 );
reconsider D11 = C116 as (Element of ( Bags C112 )) by L217;
L218: ( D8 . D11 ) <> ( 0. C113 ) by L217 , L164;
L219: ( ( C114 . D11 ) + ( C115 . D11 ) ) <> ( 0. C113 ) by L218 , L181;
L220: (not (( C114 . D11 ) = ( 0. C113 ) & ( C115 . D11 ) = ( 0. C113 ))) by L219 , RLVECT_1:def 4;
L221: (D11 in D9 or D11 in D10) by L220 , L164;
thus L222: thesis by L221 , XBOOLE_0:def 3;
end;
definition
let C117 being set;
let C118 being  Abelian  right_zeroed non  empty addLoopStr;
let C119 , C120 being (Series of C117 , C118);
redefine func C119 + C120;

commutativity
proof
let C121 , C122 being (Series of C117 , C118);
L223:
now
let C123 being (Element of ( Bags C117 ));
thus L224: ( ( C121 + C122 ) . C123 ) = ( ( C122 . C123 ) + ( C121 . C123 ) ) by L181
.= ( ( C122 + C121 ) . C123 ) by L181;
end;
thus L225: ( C121 + C122 ) = ( C122 + C121 ) by L223 , FUNCT_2:63;
end;
end;
theorem
L227: (for B90 being set holds (for B91 being  add-associative  right_zeroed non  empty doubleLoopStr holds (for B92 , B93 , B94 being (Series of B90 , B91) holds ( ( B92 + B93 ) + B94 ) = ( B92 + ( B93 + B94 ) ))))
proof
let C124 being set;
let C125 being  add-associative  right_zeroed non  empty doubleLoopStr;
let C126 , C127 , C128 being (Series of C124 , C125);
L228:
now
let C129 being (Element of ( Bags C124 ));
thus L229: ( ( ( C126 + C127 ) + C128 ) . C129 ) = ( ( ( C126 + C127 ) . C129 ) + ( C128 . C129 ) ) by L181
.= ( ( ( C126 . C129 ) + ( C127 . C129 ) ) + ( C128 . C129 ) ) by L181
.= ( ( C126 . C129 ) + ( ( C127 . C129 ) + ( C128 . C129 ) ) ) by RLVECT_1:def 3
.= ( ( C126 . C129 ) + ( ( C127 + C128 ) . C129 ) ) by L181
.= ( ( C126 + ( C127 + C128 ) ) . C129 ) by L181;
end;
thus L230: thesis by L228 , FUNCT_2:63;
end;
definition
let C130 being set;
let C131 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C132 , C133 being (Series of C130 , C131);
func C132 - C133 -> (Series of C130 , C131) equals 
( C132 + ( - C133 ) );
coherence;
end;
definition
let C134 being set;
let C135 being non  empty ZeroStr;
func 0_ (C134 , C135) -> (Series of C134 , C135) equals 
( ( Bags C134 ) --> ( 0. C135 ) );
coherence;
end;
theorem
L233: (for B95 being set holds (for B96 being non  empty ZeroStr holds (for B97 being (bag of B95) holds ( ( 0_ (B95 , B96) ) . B97 ) = ( 0. B96 ))))
proof
let C136 being set;
let C137 being non  empty ZeroStr;
let C138 being (bag of C136);
L234: C138 in ( Bags C136 ) by PRE_POLY:def 12;
thus L235: thesis by L234 , FUNCOP_1:7;
end;
theorem
L236: (for B98 being set holds (for B99 being  right_zeroed non  empty addLoopStr holds (for B100 being (Series of B98 , B99) holds ( B100 + ( 0_ (B98 , B99) ) ) = B100)))
proof
let C139 being set;
let C140 being  right_zeroed non  empty addLoopStr;
let C141 being (Series of C139 , C140);
reconsider D12 = ( C141 + ( 0_ (C139 , C140) ) ) , D13 = C141 as (Function of ( Bags C139 ) , (the carrier of C140));
L237:
now
let C142 being (Element of ( Bags C139 ));
thus L238: ( D12 . C142 ) = ( ( C141 . C142 ) + ( ( 0_ (C139 , C140) ) . C142 ) ) by L181
.= ( ( D13 . C142 ) + ( 0. C140 ) ) by L233
.= ( D13 . C142 ) by RLVECT_1:def 4;
end;
thus L239: thesis by L237 , FUNCT_2:63;
end;
definition
let C143 being set;
let C144 being  right_unital non  empty multLoopStr_0;
func 1_ (C143 , C144) -> (Series of C143 , C144) equals 
( ( 0_ (C143 , C144) ) +* (( EmptyBag C143 ) , ( 1. C144 )) );
coherence;
end;
theorem
L241: (for B101 being set holds (for B102 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B103 being (Series of B101 , B102) holds ( B103 - B103 ) = ( 0_ (B101 , B102) ))))
proof
let C145 being set;
let C146 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C147 being (Series of C145 , C146);
reconsider D14 = ( C147 - C147 ) , D15 = ( 0_ (C145 , C146) ) as (Function of ( Bags C145 ) , (the carrier of C146));
L242:
now
let C148 being (Element of ( Bags C145 ));
thus L243: ( D14 . C148 ) = ( ( C147 . C148 ) + ( ( - C147 ) . C148 ) ) by L181
.= ( ( C147 . C148 ) + ( - ( C147 . C148 ) ) ) by L193
.= ( 0. C146 ) by RLVECT_1:def 10
.= ( D15 . C148 ) by L233;
end;
thus L244: thesis by L242 , FUNCT_2:63;
end;
theorem
L245: (for B104 being set holds (for B105 being  right_unital non  empty multLoopStr_0 holds (( ( 1_ (B104 , B105) ) . ( EmptyBag B104 ) ) = ( 1. B105 ) & (for B106 being (bag of B104) holds (B106 <> ( EmptyBag B104 ) implies ( ( 1_ (B104 , B105) ) . B106 ) = ( 0. B105 ))))))
proof
let C149 being set;
let C150 being  right_unital non  empty multLoopStr_0;
set D16 = ( 0_ (C149 , C150) );
L246: ( dom D16 ) = ( Bags C149 ) by FUNCOP_1:13;
thus L247: ( ( 1_ (C149 , C150) ) . ( EmptyBag C149 ) ) = ( 1. C150 ) by L246 , FUNCT_7:31;
let C151 being (bag of C149);
L248: C151 in ( Bags C149 ) by PRE_POLY:def 12;
assume L249: C151 <> ( EmptyBag C149 );
thus L250: ( ( 1_ (C149 , C150) ) . C151 ) = ( D16 . C151 ) by L249 , FUNCT_7:32
.= ( 0. C150 ) by L248 , FUNCOP_1:7;
end;
definition
let C152 being Ordinal;
let C153 being  add-associative  right_complementable  right_zeroed non  empty doubleLoopStr;
let C154 , C155 being (Series of C152 , C153);
func C154 *' C155 -> (Series of C152 , C153) means 
:L251: (for B107 being (bag of C152) holds (ex B108 being (FinSequence of (the carrier of C153)) st (( it . B107 ) = ( Sum B108 ) & ( len B108 ) = ( len ( decomp B107 ) ) & (for B109 being (Element of ( NAT )) holds (B109 in ( dom B108 ) implies (ex B110 , B111 being (bag of C152) st (( ( decomp B107 ) /. B109 ) = <* B110 , B111 *> & ( B108 /. B109 ) = ( ( C154 . B110 ) * ( C155 . B111 ) ))))))));
existence
proof
defpred S5[ (Element of ( Bags C152 )) , (Element of C153) ] means (ex B112 being (bag of C152) st (B112 = $1 & (ex B113 being (FinSequence of (the carrier of C153)) st ($2 = ( Sum B113 ) & ( len B113 ) = ( len ( decomp B112 ) ) & (for B114 being (Element of ( NAT )) holds (B114 in ( dom B113 ) implies (ex B115 , B116 being (bag of C152) st (( ( decomp B112 ) /. B114 ) = <* B115 , B116 *> & ( B113 /. B114 ) = ( ( C154 . B115 ) * ( C155 . B116 ) )))))))));
L252:
now
let C156 being (Element of ( Bags C152 ));
reconsider D17 = C156 as (bag of C152);
defpred S6[ Nat , set ] means (ex B117 , B118 being (bag of C152) st (( ( decomp D17 ) /. $1 ) = <* B117 , B118 *> & $2 = ( ( C154 . B117 ) * ( C155 . B118 ) )));
L253:
now
let C157 being Nat;
assume L254: C157 in ( Seg ( len ( decomp D17 ) ) );
L255: C157 in ( dom ( decomp D17 ) ) by L254 , FINSEQ_1:def 3;
consider C158 , C159 being (bag of C152) such that L256: ( ( decomp D17 ) /. C157 ) = <* C158 , C159 *> and L257: D17 = ( C158 + C159 ) by L255 , PRE_POLY:68;
reconsider D18 = ( ( C154 . C158 ) * ( C155 . C159 ) ) as (Element of C153);
take D19 = D18;
thus L258: S6[ C157 , D19 ] by L256;
end;
consider C160 being (FinSequence of (the carrier of C153)) such that L259: ( len C160 ) = ( len ( decomp D17 ) ) and L260: (for B119 being Nat holds (B119 in ( Seg ( len ( decomp D17 ) ) ) implies S6[ B119 , ( C160 /. B119 ) ])) from FINSEQ_4:sch 1(L253);
reconsider D20 = ( Sum C160 ) as (Element of C153);
take D21 = D20;
thus L261: S5[ C156 , D21 ]
proof
take D17;
thus L262: D17 = C156;
take C160;
thus L263: D21 = ( Sum C160 );
thus L264: ( len C160 ) = ( len ( decomp D17 ) ) by L259;
let C161 being (Element of ( NAT ));
assume L265: C161 in ( dom C160 );
L266: C161 in ( Seg ( len ( decomp D17 ) ) ) by L265 , L259 , FINSEQ_1:def 3;
thus L267: thesis by L266 , L260;
end;

end;
consider C162 being (Function of ( Bags C152 ) , (the carrier of C153)) such that L262: (for B120 being (Element of ( Bags C152 )) holds S5[ B120 , ( C162 . B120 ) ]) from FUNCT_2:sch 3(L252);
reconsider D22 = C162 as (Function of ( Bags C152 ) , C153);
reconsider D23 = D22 as (Series of C152 , C153);
take D23;
let C163 being (bag of C152);
reconsider D24 = C163 as (Element of ( Bags C152 )) by PRE_POLY:def 12;
L263: S5[ D24 , ( D23 . D24 ) ] by L262;
thus L264: thesis by L263;
end;
uniqueness
proof
let C164 , C165 being (Series of C152 , C153);
assume that
L265: (for B121 being (bag of C152) holds (ex B122 being (FinSequence of (the carrier of C153)) st (( C164 . B121 ) = ( Sum B122 ) & ( len B122 ) = ( len ( decomp B121 ) ) & (for B123 being (Element of ( NAT )) holds (B123 in ( dom B122 ) implies (ex B124 , B125 being (bag of C152) st (( ( decomp B121 ) /. B123 ) = <* B124 , B125 *> & ( B122 /. B123 ) = ( ( C154 . B124 ) * ( C155 . B125 ) ))))))))
and
L266: (for B126 being (bag of C152) holds (ex B127 being (FinSequence of (the carrier of C153)) st (( C165 . B126 ) = ( Sum B127 ) & ( len B127 ) = ( len ( decomp B126 ) ) & (for B128 being (Element of ( NAT )) holds (B128 in ( dom B127 ) implies (ex B129 , B130 being (bag of C152) st (( ( decomp B126 ) /. B128 ) = <* B129 , B130 *> & ( B127 /. B128 ) = ( ( C154 . B129 ) * ( C155 . B130 ) ))))))));
reconsider D25 = C164 , D26 = C165 as (Function of ( Bags C152 ) , (the carrier of C153));
L267:
now
let C166 being (Element of ( Bags C152 ));
consider C167 being (FinSequence of (the carrier of C153)) such that L268: ( D25 . C166 ) = ( Sum C167 ) and L269: ( len C167 ) = ( len ( decomp C166 ) ) and L270: (for B131 being (Element of ( NAT )) holds (B131 in ( dom C167 ) implies (ex B132 , B133 being (bag of C152) st (( ( decomp C166 ) /. B131 ) = <* B132 , B133 *> & ( C167 /. B131 ) = ( ( C154 . B132 ) * ( C155 . B133 ) ))))) by L265;
consider C168 being (FinSequence of (the carrier of C153)) such that L271: ( D26 . C166 ) = ( Sum C168 ) and L272: ( len C168 ) = ( len ( decomp C166 ) ) and L273: (for B134 being (Element of ( NAT )) holds (B134 in ( dom C168 ) implies (ex B135 , B136 being (bag of C152) st (( ( decomp C166 ) /. B134 ) = <* B135 , B136 *> & ( C168 /. B134 ) = ( ( C154 . B135 ) * ( C155 . B136 ) ))))) by L266;
L274:
now
let C169 being Nat;
assume L275: (1 <= C169 & C169 <= ( len C167 ));
L276: C169 in ( dom C167 ) by L275 , FINSEQ_3:25;
L277: ( C167 /. C169 ) = ( C167 . C169 ) by L276 , PARTFUN1:def 6;
L278: C169 in ( dom C168 ) by L269 , L272 , L275 , FINSEQ_3:25;
L279: ( C168 /. C169 ) = ( C168 . C169 ) by L278 , PARTFUN1:def 6;
consider C170 , C171 being (bag of C152) such that L280: ( ( decomp C166 ) /. C169 ) = <* C170 , C171 *> and L281: ( C167 /. C169 ) = ( ( C154 . C170 ) * ( C155 . C171 ) ) by L270 , L276;
consider C172 , C173 being (bag of C152) such that L282: ( ( decomp C166 ) /. C169 ) = <* C172 , C173 *> and L283: ( C168 /. C169 ) = ( ( C154 . C172 ) * ( C155 . C173 ) ) by L273 , L278;
L284: C170 = C172 by L280 , L282 , FINSEQ_1:77;
thus L285: ( C167 . C169 ) = ( C168 . C169 ) by L284 , L280 , L281 , L282 , L283 , L277 , L279 , FINSEQ_1:77;
end;
thus L286: ( D25 . C166 ) = ( D26 . C166 ) by L274 , L268 , L269 , L271 , L272 , FINSEQ_1:14;
end;
thus L287: C164 = C165 by L267 , FUNCT_2:63;
end;
end;
theorem
L289: (for B137 being Ordinal holds (for B138 being  Abelian  add-associative  right_zeroed  right_complementable  distributive  associative non  empty doubleLoopStr holds (for B139 , B140 , B141 being (Series of B137 , B138) holds ( B139 *' ( B140 + B141 ) ) = ( ( B139 *' B140 ) + ( B139 *' B141 ) ))))
proof
let C174 being Ordinal;
let C175 being  Abelian  add-associative  right_zeroed  right_complementable  distributive  associative non  empty doubleLoopStr;
let C176 , C177 , C178 being (Series of C174 , C175);
set D27 = (the carrier of C175);
L290:
now
let C179 being (Element of ( Bags C174 ));
consider C180 being (FinSequence of D27) such that L291: ( ( C176 *' ( C177 + C178 ) ) . C179 ) = ( Sum C180 ) and L292: ( len C180 ) = ( len ( decomp C179 ) ) and L293: (for B142 being (Element of ( NAT )) holds (B142 in ( dom C180 ) implies (ex B143 , B144 being (bag of C174) st (( ( decomp C179 ) /. B142 ) = <* B143 , B144 *> & ( C180 /. B142 ) = ( ( C176 . B143 ) * ( ( C177 + C178 ) . B144 ) ))))) by L251;
consider C181 being (FinSequence of D27) such that L294: ( ( C176 *' C178 ) . C179 ) = ( Sum C181 ) and L295: ( len C181 ) = ( len ( decomp C179 ) ) and L296: (for B145 being (Element of ( NAT )) holds (B145 in ( dom C181 ) implies (ex B146 , B147 being (bag of C174) st (( ( decomp C179 ) /. B145 ) = <* B146 , B147 *> & ( C181 /. B145 ) = ( ( C176 . B146 ) * ( C178 . B147 ) ))))) by L251;
consider C182 being (FinSequence of D27) such that L297: ( ( C176 *' C177 ) . C179 ) = ( Sum C182 ) and L298: ( len C182 ) = ( len ( decomp C179 ) ) and L299: (for B148 being (Element of ( NAT )) holds (B148 in ( dom C182 ) implies (ex B149 , B150 being (bag of C174) st (( ( decomp C179 ) /. B148 ) = <* B149 , B150 *> & ( C182 /. B148 ) = ( ( C176 . B149 ) * ( C177 . B150 ) ))))) by L251;
reconsider D28 = C182 , D29 = C181 as (Element of ( ( len C180 ) -tuples_on D27 )) by L292 , L298 , L295 , FINSEQ_2:92;
L300: ( dom D29 ) = ( dom C180 ) by L292 , L295 , FINSEQ_3:29;
L301: ( dom D28 ) = ( dom C180 ) by L292 , L298 , FINSEQ_3:29;
L302: ( dom ( D28 + D29 ) ) = ( dom C180 ) by L301 , L300 , L5;
L303:
now
let C183 being Nat;
assume L304: C183 in ( dom C180 );
consider C184 , C185 being (bag of C174) such that L305: ( ( decomp C179 ) /. C183 ) = <* C184 , C185 *> and L306: ( C180 /. C183 ) = ( ( C176 . C184 ) * ( ( C177 + C178 ) . C185 ) ) by L304 , L293;
L307: (( D28 /. C183 ) = ( D28 . C183 ) & ( D29 /. C183 ) = ( D29 . C183 )) by L301 , L300 , L304 , PARTFUN1:def 6;
consider C186 , C187 being (bag of C174) such that L308: ( ( decomp C179 ) /. C183 ) = <* C186 , C187 *> and L309: ( D29 /. C183 ) = ( ( C176 . C186 ) * ( C178 . C187 ) ) by L296 , L300 , L304;
L310: (C184 = C186 & C185 = C187) by L305 , L308 , FINSEQ_1:77;
consider C188 , C189 being (bag of C174) such that L311: ( ( decomp C179 ) /. C183 ) = <* C188 , C189 *> and L312: ( D28 /. C183 ) = ( ( C176 . C188 ) * ( C177 . C189 ) ) by L299 , L301 , L304;
L313: (C184 = C188 & C185 = C189) by L305 , L311 , FINSEQ_1:77;
L314: ( C180 /. C183 ) = ( C180 . C183 ) by L304 , PARTFUN1:def 6;
thus L315: ( C180 . C183 ) = ( ( C176 . C184 ) * ( ( C177 . C185 ) + ( C178 . C185 ) ) ) by L314 , L306 , L181
.= ( ( ( C176 . C184 ) * ( C177 . C185 ) ) + ( ( C176 . C184 ) * ( C178 . C185 ) ) ) by VECTSP_1:def 7
.= ( ( D28 + D29 ) . C183 ) by L302 , L304 , L312 , L309 , L313 , L310 , L307 , FVSUM_1:17;
end;
L316: ( len ( D28 + D29 ) ) = ( len C180 ) by L302 , FINSEQ_3:29;
L317: C180 = ( D28 + D29 ) by L316 , L303 , FINSEQ_2:9;
thus L318: ( ( C176 *' ( C177 + C178 ) ) . C179 ) = ( ( Sum D28 ) + ( Sum D29 ) ) by L317 , L291 , FVSUM_1:76
.= ( ( ( C176 *' C177 ) + ( C176 *' C178 ) ) . C179 ) by L297 , L294 , L181;
end;
thus L319: thesis by L290 , FUNCT_2:63;
end;
theorem
L320: (for B151 being Ordinal holds (for B152 being  Abelian  add-associative  right_zeroed  right_complementable  right_unital  distributive  associative non  empty doubleLoopStr holds (for B153 , B154 , B155 being (Series of B151 , B152) holds ( ( B153 *' B154 ) *' B155 ) = ( B153 *' ( B154 *' B155 ) ))))
proof
let C190 being Ordinal;
let C191 being  Abelian  add-associative  right_zeroed  right_complementable  right_unital  distributive  associative non  empty doubleLoopStr;
let C192 , C193 , C194 being (Series of C190 , C191);
set D30 = (the carrier of C191);
reconsider D31 = ( ( C192 *' C193 ) *' C194 ) , D32 = ( C192 *' ( C193 *' C194 ) ) as (Function of ( Bags C190 ) , D30);
set D33 = ( C192 *' C193 );
set D34 = ( C193 *' C194 );
L321:
now
let C195 being (Element of ( Bags C190 ));
set D35 = ( decomp C195 );
deffunc H2(Nat) = ( ( decomp (( ( D35 /. $1 ) /. 1 ) qua (Element of ( Bags C190 ))) ) ^^ ( ( len ( decomp (( ( D35 /. $1 ) /. 1 ) qua (Element of ( Bags C190 ))) ) ) |-> <* ( ( D35 /. $1 ) /. 2 ) *> ) );
consider C196 being FinSequence such that L322: ( len C196 ) = ( len D35 ) and L323: (for B156 being Nat holds (B156 in ( dom C196 ) implies ( C196 . B156 ) = H2(B156))) from FINSEQ_1:sch 2;
L324: ( rng C196 ) c= ( ( 3 -tuples_on ( Bags C190 ) ) * )
proof
let C197 being set;
assume L325: C197 in ( rng C196 );
consider C198 being set such that L326: C198 in ( dom C196 ) and L327: C197 = ( C196 . C198 ) by L325 , FUNCT_1:def 3;
set D36 = ( ( D35 /. C198 ) /. 2 );
set D37 = ( decomp (( ( D35 /. C198 ) /. 1 ) qua (Element of ( Bags C190 ))) );
reconsider D38 = C198 as Nat by L326;
set D39 = ( D37 ^^ ( ( len D37 ) |-> <* D36 *> ) );
L328: ( dom D39 ) = ( ( dom D37 ) /\ ( dom ( ( len D37 ) |-> <* D36 *> ) ) ) by PRE_POLY:def 4
.= ( ( dom D37 ) /\ ( Seg ( len D37 ) ) ) by FUNCOP_1:13
.= ( ( dom D37 ) /\ ( dom D37 ) ) by FINSEQ_1:def 3
.= ( dom D37 );
L329: ( dom D37 ) = ( Seg ( len D37 ) ) by FINSEQ_1:def 3;
L330: ( rng D39 ) c= ( 3 -tuples_on ( Bags C190 ) )
proof
reconsider D40 = <* D36 *> as (Element of ( 1 -tuples_on ( Bags C190 ) )) by FINSEQ_2:98;
let C199 being set;
assume L331: C199 in ( rng D39 );
consider C200 being set such that L332: C200 in ( dom D39 ) and L333: ( D39 . C200 ) = C199 by L331 , FUNCT_1:def 3;
L334: ( D37 . C200 ) in ( rng D37 ) by L328 , L332 , FUNCT_1:def 3;
reconsider D41 = ( D37 . C200 ) as (Element of ( 2 -tuples_on ( Bags C190 ) )) by L334;
reconsider D42 = C200 as (Element of ( NAT )) by L332;
L335: ( ( ( len D37 ) |-> <* D36 *> ) . D42 ) = <* D36 *> by L328 , L329 , L332 , FUNCOP_1:7;
L336: C199 = ( D41 ^ D40 ) by L335 , L332 , L333 , PRE_POLY:def 4;
thus L337: thesis by L336 , FINSEQ_2:131;
end;
L338: D39 is (FinSequence of ( 3 -tuples_on ( Bags C190 ) )) by L330 , FINSEQ_1:def 4;
L339: ( C196 . D38 ) = ( D37 ^^ ( ( len D37 ) |-> <* D36 *> ) ) by L323 , L326;
thus L340: thesis by L339 , L327 , L338 , FINSEQ_1:def 11;
end;
deffunc H3((Element of ( 3 -tuples_on ( Bags C190 ) ))) = ( ( ( C192 . ( $1 /. 1 ) ) * ( C193 . ( $1 /. 2 ) ) ) * ( C194 . ( $1 /. 3 ) ) );
consider C201 being (Function of ( 3 -tuples_on ( Bags C190 ) ) , D30) such that L341: (for B157 being (Element of ( 3 -tuples_on ( Bags C190 ) )) holds ( C201 . B157 ) = H3(B157)) from FUNCT_2:sch 4;
deffunc H4(Nat) = ( ( ( len ( decomp (( ( D35 /. $1 ) /. 2 ) qua (Element of ( Bags C190 ))) ) ) |-> <* ( ( D35 /. $1 ) /. 1 ) *> ) ^^ ( decomp (( ( D35 /. $1 ) /. 2 ) qua (Element of ( Bags C190 ))) ) );
consider C202 being FinSequence such that L342: ( len C202 ) = ( len D35 ) and L343: (for B158 being Nat holds (B158 in ( dom C202 ) implies ( C202 . B158 ) = H4(B158))) from FINSEQ_1:sch 2;
L344: ( rng C202 ) c= ( ( 3 -tuples_on ( Bags C190 ) ) * )
proof
let C203 being set;
assume L345: C203 in ( rng C202 );
consider C204 being set such that L346: C204 in ( dom C202 ) and L347: C203 = ( C202 . C204 ) by L345 , FUNCT_1:def 3;
reconsider D43 = C204 as Nat by L346;
set D44 = ( decomp (( ( D35 /. D43 ) /. 2 ) qua (Element of ( Bags C190 ))) );
set D45 = ( ( D35 /. D43 ) /. 1 );
set D46 = ( ( ( len D44 ) |-> <* D45 *> ) ^^ D44 );
L348: ( dom D46 ) = ( ( dom D44 ) /\ ( dom ( ( len D44 ) |-> <* D45 *> ) ) ) by PRE_POLY:def 4
.= ( ( dom D44 ) /\ ( Seg ( len D44 ) ) ) by FUNCOP_1:13
.= ( ( dom D44 ) /\ ( dom D44 ) ) by FINSEQ_1:def 3
.= ( dom D44 );
L349: ( dom D44 ) = ( Seg ( len D44 ) ) by FINSEQ_1:def 3;
L350: ( rng D46 ) c= ( 3 -tuples_on ( Bags C190 ) )
proof
reconsider D47 = <* D45 *> as (Element of ( 1 -tuples_on ( Bags C190 ) )) by FINSEQ_2:98;
let C205 being set;
assume L351: C205 in ( rng D46 );
consider C206 being set such that L352: C206 in ( dom D46 ) and L353: ( D46 . C206 ) = C205 by L351 , FUNCT_1:def 3;
L354: ( D44 . C206 ) in ( rng D44 ) by L348 , L352 , FUNCT_1:def 3;
reconsider D48 = ( D44 . C206 ) as (Element of ( 2 -tuples_on ( Bags C190 ) )) by L354;
reconsider D49 = C206 as (Element of ( NAT )) by L352;
L355: ( ( ( len D44 ) |-> <* D45 *> ) . D49 ) = <* D45 *> by L348 , L349 , L352 , FUNCOP_1:7;
L356: C205 = ( D47 ^ D48 ) by L355 , L352 , L353 , PRE_POLY:def 4;
thus L357: thesis by L356 , FINSEQ_2:131;
end;
L358: D46 is (FinSequence of ( 3 -tuples_on ( Bags C190 ) )) by L350 , FINSEQ_1:def 4;
L359: ( C202 . D43 ) = ( ( ( len D44 ) |-> <* D45 *> ) ^^ D44 ) by L343 , L346;
thus L360: thesis by L359 , L347 , L358 , FINSEQ_1:def 11;
end;
reconsider D50 = C196 , D51 = C202 as (FinSequence of ( ( 3 -tuples_on ( Bags C190 ) ) * )) by L344 , L324 , FINSEQ_1:def 4;
set D52 = ( FlattenSeq D50 );
set D53 = ( FlattenSeq D51 );
consider C207 being (FinSequence of D30) such that L361: ( D31 . C195 ) = ( Sum C207 ) and L362: ( len C207 ) = ( len ( decomp C195 ) ) and L363: (for B159 being (Element of ( NAT )) holds (B159 in ( dom C207 ) implies (ex B160 , B161 being (bag of C190) st (( D35 /. B159 ) = <* B160 , B161 *> & ( C207 /. B159 ) = ( ( D33 . B160 ) * ( C194 . B161 ) ))))) by L251;
L364: ( dom D51 ) = ( dom D35 ) by L342 , FINSEQ_3:29;
reconsider D54 = ( C201 * D52 ) , D55 = ( C201 * D53 ) as (FinSequence of D30) by FINSEQ_2:32;
consider C208 being (FinSequence of ( D30 * )) such that L365: C208 = ( ( ( dom D50 ) --> C201 ) ** D50 ) and L366: D54 = ( FlattenSeq C208 ) by PRE_POLY:32;
L367: ( dom C201 ) = ( 3 -tuples_on ( Bags C190 ) ) by FUNCT_2:def 1;
L368:
now
set D56 = ( Sum C208 );
L369: ( dom C208 ) = ( ( dom ( ( dom D50 ) --> C201 ) ) /\ ( dom D50 ) ) by L365 , PBOOLE:def 19
.= ( ( dom D50 ) /\ ( dom D50 ) ) by FUNCOP_1:13
.= ( dom D50 );
L370: ( dom D56 ) = ( dom C208 ) by L10;
thus L371: ( len ( Sum C208 ) ) = ( len C207 ) by L370 , L362 , L322 , L369 , FINSEQ_3:29;
let C209 being Nat;
assume that
L372: (1 <= C209 & C209 <= ( len C207 ));
L373: C209 in ( dom D56 ) by L362 , L322 , L370 , L369 , L372 , FINSEQ_3:25;
L374: ( D56 /. C209 ) = ( D56 . C209 ) by L373 , PARTFUN1:def 6;
L375: ( dom C207 ) = ( dom D56 ) by L362 , L322 , L370 , L369 , FINSEQ_3:29;
L376: ( C207 /. C209 ) = ( C207 . C209 ) by L375 , L373 , PARTFUN1:def 6;
consider C210 , C211 being (bag of C190) such that L377: ( D35 /. C209 ) = <* C210 , C211 *> and L378: ( C207 /. C209 ) = ( ( D33 . C210 ) * ( C194 . C211 ) ) by L363 , L375 , L373;
L379: ( len <* C210 , C211 *> ) = 2 by FINSEQ_1:44;
L380: 1 in ( dom <* C210 , C211 *> ) by L379 , FINSEQ_3:25;
L381: ( ( D35 /. C209 ) /. 1 ) = ( <* C210 , C211 *> . 1 ) by L380 , L377 , PARTFUN1:def 6
.= C210 by FINSEQ_1:44;
set D57 = ( D50 . C209 );
set D58 = ( ( D35 /. C209 ) /. 2 );
set D59 = ( decomp (( ( D35 /. C209 ) /. 1 ) qua (Element of ( Bags C190 ))) );
L382: C209 in ( dom C208 ) by L362 , L322 , L369 , L372 , FINSEQ_3:25;
L383: ( D50 . C209 ) = ( D59 ^^ ( ( len D59 ) |-> <* D58 *> ) ) by L382 , L323 , L369;
L384: ( dom D57 ) = ( ( dom D59 ) /\ ( dom ( ( len D59 ) |-> <* D58 *> ) ) ) by L383 , PRE_POLY:def 4
.= ( ( dom D59 ) /\ ( Seg ( len D59 ) ) ) by FUNCOP_1:13
.= ( ( dom D59 ) /\ ( dom D59 ) ) by FINSEQ_1:def 3
.= ( dom D59 );
set D60 = ( C201 * ( D50 . C209 ) );
L385: C209 in ( dom D50 ) by L362 , L322 , L372 , FINSEQ_3:25;
L386: D57 in ( rng D50 ) by L385 , FUNCT_1:def 3;
L387: D57 is (Element of ( ( 3 -tuples_on ( Bags C190 ) ) * )) by L386;
reconsider D61 = D57 as (FinSequence of ( 3 -tuples_on ( Bags C190 ) )) by L387;
L388: ( rng D61 ) c= ( 3 -tuples_on ( Bags C190 ) );
L389: ( dom D60 ) = ( dom D61 ) by L388 , L367 , RELAT_1:27;
L390: ( dom D60 ) = ( Seg ( len D59 ) ) by L389 , L384 , FINSEQ_1:def 3;
reconsider D62 = C211 as (Element of ( Bags C190 )) by PRE_POLY:def 12;
consider C212 being (FinSequence of (the carrier of C191)) such that L391: ( D33 . C210 ) = ( Sum C212 ) and L392: ( len C212 ) = ( len ( decomp C210 ) ) and L393: (for B162 being (Element of ( NAT )) holds (B162 in ( dom C212 ) implies (ex B163 , B164 being (bag of C190) st (( ( decomp C210 ) /. B162 ) = <* B163 , B164 *> & ( C212 /. B162 ) = ( ( C192 . B163 ) * ( C193 . B164 ) ))))) by L251;
L394: ( dom C212 ) = ( dom ( C212 * ( C194 . C211 ) ) ) by L64;
L395: 2 in ( dom <* C210 , C211 *> ) by L379 , FINSEQ_3:25;
L396: D58 = ( <* C210 , C211 *> . 2 ) by L395 , L377 , PARTFUN1:def 6
.= C211 by FINSEQ_1:44;
reconsider D63 = D60 as FinSequence by L390 , FINSEQ_1:def 2;
L397: ( Sum ( C212 * ( C194 . C211 ) ) ) = ( ( Sum C212 ) * ( C194 . C211 ) ) by L149;
L398: ( dom D59 ) = ( Seg ( len D59 ) ) by FINSEQ_1:def 3;
L399:
now
L400: ( dom C212 ) = ( dom ( C212 * ( C194 . C211 ) ) ) by L64;
thus L401: ( len D63 ) = ( len C212 ) by L392 , L381 , L384 , L389 , FINSEQ_3:29
.= ( len ( C212 * ( C194 . C211 ) ) ) by L394 , FINSEQ_3:29;
L402: ( dom D63 ) = ( dom ( C212 * ( C194 . C211 ) ) ) by L401 , FINSEQ_3:29;
let C213 being Nat;
reconsider D64 = C213 as (Element of ( NAT )) by ORDINAL1:def 12;
assume L403: (1 <= C213 & C213 <= ( len ( C212 * ( C194 . C211 ) ) ));
L404: C213 in ( dom ( C212 * ( C194 . C211 ) ) ) by L403 , FINSEQ_3:25;
consider C214 , C215 being (bag of C190) such that L405: ( ( decomp C210 ) /. C213 ) = <* C214 , C215 *> and L406: ( C212 /. C213 ) = ( ( C192 . C214 ) * ( C193 . C215 ) ) by L404 , L393 , L394;
L407: (( ( ( len D59 ) |-> <* D58 *> ) . D64 ) = <* D58 *> & ( ( decomp C210 ) /. C213 ) = ( ( decomp C210 ) . C213 )) by L381 , L384 , L398 , L389 , L402 , L404 , FUNCOP_1:7 , PARTFUN1:def 6;
L408: ( D61 . C213 ) = ( <* C214 , C215 *> ^ <* C211 *> ) by L407 , L396 , L381 , L383 , L389 , L402 , L404 , L405 , PRE_POLY:def 4
.= <* C214 , C215 , C211 *> by FINSEQ_1:43;
reconsider D65 = C214 , D66 = C215 as (Element of ( Bags C190 )) by PRE_POLY:def 12;
reconsider D67 = <* D65 , D66 , D62 *> as (Element of ( 3 -tuples_on ( Bags C190 ) )) by FINSEQ_2:104;
L409: C213 in ( dom C212 ) by L394 , L403 , FINSEQ_3:25;
thus L410: ( ( C201 * ( D50 . C209 ) ) . C213 ) = ( C201 . ( D61 . C213 ) ) by L402 , L404 , FUNCT_1:12
.= ( ( ( C192 . ( D67 /. 1 ) ) * ( C193 . ( D67 /. 2 ) ) ) * ( C194 . ( D67 /. 3 ) ) ) by L341 , L408
.= ( ( ( C192 . D65 ) * ( C193 . ( D67 /. 2 ) ) ) * ( C194 . ( D67 /. 3 ) ) ) by FINSEQ_4:18
.= ( ( ( C192 . C214 ) * ( C193 . C215 ) ) * ( C194 . ( D67 /. 3 ) ) ) by FINSEQ_4:18
.= ( ( C212 /. C213 ) * ( C194 . C211 ) ) by L406 , FINSEQ_4:18
.= ( ( C212 * ( C194 . C211 ) ) /. C213 ) by L409 , L64
.= ( ( C212 * ( C194 . C211 ) ) . C213 ) by L409 , L400 , PARTFUN1:def 6;
end;
L411: D63 = ( C212 * ( C194 . C211 ) ) by L399 , FINSEQ_1:14;
L412: ( C208 /. C209 ) = ( C208 . C209 ) by L382 , PARTFUN1:def 6
.= ( ( ( ( dom D50 ) --> C201 ) . C209 ) * ( D50 . C209 ) ) by L365 , L382 , PBOOLE:def 19
.= ( C212 * ( C194 . C211 ) ) by L369 , L382 , L411 , FUNCOP_1:7;
thus L413: ( ( Sum C208 ) . C209 ) = ( C207 . C209 ) by L412 , L373 , L378 , L391 , L397 , L376 , L374 , MATRLIN:def 6;
end;
L414: ( Sum C208 ) = C207 by L368 , FINSEQ_1:14;
consider C216 being (FinSequence of ( D30 * )) such that L415: C216 = ( ( ( dom D51 ) --> C201 ) ** D51 ) and L416: D55 = ( FlattenSeq C216 ) by PRE_POLY:32;
L417: ( Sum D55 ) = ( Sum ( Sum C216 ) ) by L416 , L157;
consider C217 being (FinSequence of D30) such that L418: ( D32 . C195 ) = ( Sum C217 ) and L419: ( len C217 ) = ( len ( decomp C195 ) ) and L420: (for B165 being (Element of ( NAT )) holds (B165 in ( dom C217 ) implies (ex B166 , B167 being (bag of C190) st (( D35 /. B165 ) = <* B166 , B167 *> & ( C217 /. B165 ) = ( ( C192 . B166 ) * ( D34 . B167 ) ))))) by L251;
L421:
now
set D68 = ( Sum C216 );
L422: ( dom C216 ) = ( ( dom ( ( dom D51 ) --> C201 ) ) /\ ( dom D51 ) ) by L415 , PBOOLE:def 19
.= ( ( dom D51 ) /\ ( dom D51 ) ) by FUNCOP_1:13
.= ( dom D51 );
L423: ( dom D68 ) = ( dom C216 ) by L10;
thus L424: ( len ( Sum C216 ) ) = ( len C217 ) by L423 , L419 , L342 , L422 , FINSEQ_3:29;
let C218 being Nat;
assume that
L425: (1 <= C218 & C218 <= ( len C217 ));
L426: C218 in ( dom D68 ) by L419 , L342 , L423 , L422 , L425 , FINSEQ_3:25;
L427: ( D68 /. C218 ) = ( D68 . C218 ) by L426 , PARTFUN1:def 6;
set D69 = ( D51 . C218 );
set D70 = ( ( D35 /. C218 ) /. 1 );
set D71 = ( decomp (( ( D35 /. C218 ) /. 2 ) qua (Element of ( Bags C190 ))) );
L428: C218 in ( dom C216 ) by L419 , L342 , L422 , L425 , FINSEQ_3:25;
L429: ( D51 . C218 ) = ( ( ( len D71 ) |-> <* D70 *> ) ^^ D71 ) by L428 , L343 , L422;
L430: ( dom D69 ) = ( ( dom D71 ) /\ ( dom ( ( len D71 ) |-> <* D70 *> ) ) ) by L429 , PRE_POLY:def 4
.= ( ( dom D71 ) /\ ( Seg ( len D71 ) ) ) by FUNCOP_1:13
.= ( ( dom D71 ) /\ ( dom D71 ) ) by FINSEQ_1:def 3
.= ( dom D71 );
L431: C218 in ( dom D51 ) by L419 , L342 , L425 , FINSEQ_3:25;
L432: D69 in ( rng D51 ) by L431 , FUNCT_1:def 3;
L433: D69 is (Element of ( ( 3 -tuples_on ( Bags C190 ) ) * )) by L432;
set D72 = ( C201 * ( D51 . C218 ) );
L434: ( dom D71 ) = ( Seg ( len D71 ) ) by FINSEQ_1:def 3;
reconsider D73 = D69 as (FinSequence of ( 3 -tuples_on ( Bags C190 ) )) by L433;
L435: ( rng D73 ) c= ( 3 -tuples_on ( Bags C190 ) );
L436: ( dom D72 ) = ( dom D73 ) by L435 , L367 , RELAT_1:27;
L437: ( dom D72 ) = ( Seg ( len D71 ) ) by L436 , L430 , FINSEQ_1:def 3;
L438: ( dom C217 ) = ( dom D68 ) by L419 , L342 , L423 , L422 , FINSEQ_3:29;
L439: ( C217 /. C218 ) = ( C217 . C218 ) by L438 , L426 , PARTFUN1:def 6;
consider C219 , C220 being (bag of C190) such that L440: ( D35 /. C218 ) = <* C219 , C220 *> and L441: ( C217 /. C218 ) = ( ( C192 . C219 ) * ( D34 . C220 ) ) by L420 , L438 , L426;
reconsider D74 = C219 as (Element of ( Bags C190 )) by PRE_POLY:def 12;
consider C221 being (FinSequence of (the carrier of C191)) such that L442: ( D34 . C220 ) = ( Sum C221 ) and L443: ( len C221 ) = ( len ( decomp C220 ) ) and L444: (for B168 being (Element of ( NAT )) holds (B168 in ( dom C221 ) implies (ex B169 , B170 being (bag of C190) st (( ( decomp C220 ) /. B168 ) = <* B169 , B170 *> & ( C221 /. B168 ) = ( ( C193 . B169 ) * ( C194 . B170 ) ))))) by L251;
L445: ( dom C221 ) = ( dom ( ( C192 . C219 ) * C221 ) ) by L41;
L446: ( len C221 ) = ( len ( ( C192 . C219 ) * C221 ) ) by L445 , FINSEQ_3:29;
L447: ( len <* C219 , C220 *> ) = 2 by FINSEQ_1:44;
L448: 1 in ( dom <* C219 , C220 *> ) by L447 , FINSEQ_3:25;
L449: D70 = ( <* C219 , C220 *> . 1 ) by L448 , L440 , PARTFUN1:def 6
.= C219 by FINSEQ_1:44;
reconsider D75 = D72 as FinSequence by L437 , FINSEQ_1:def 2;
L450: ( Sum ( ( C192 . C219 ) * C221 ) ) = ( ( C192 . C219 ) * ( Sum C221 ) ) by L141;
L451: 2 in ( dom <* C219 , C220 *> ) by L447 , FINSEQ_3:25;
L452: ( ( D35 /. C218 ) /. 2 ) = ( <* C219 , C220 *> . 2 ) by L451 , L440 , PARTFUN1:def 6
.= C220 by FINSEQ_1:44;
L453: ( dom D75 ) = ( dom ( ( C192 . C219 ) * C221 ) ) by L452 , L443 , L430 , L436 , L445 , FINSEQ_3:29;
L454:
now
let C222 being Nat;
reconsider D76 = C222 as (Element of ( NAT )) by ORDINAL1:def 12;
assume L455: (1 <= C222 & C222 <= ( len ( ( C192 . C219 ) * C221 ) ));
L456: C222 in ( dom C221 ) by L455 , L445 , FINSEQ_3:25;
L457: C222 in ( dom D73 ) by L443 , L452 , L430 , L446 , L455 , FINSEQ_3:25;
consider C223 , C224 being (bag of C190) such that L458: ( ( decomp C220 ) /. C222 ) = <* C223 , C224 *> and L459: ( C221 /. C222 ) = ( ( C193 . C223 ) * ( C194 . C224 ) ) by L457 , L444 , L436 , L445 , L453;
L460: (( ( ( len D71 ) |-> <* D70 *> ) . D76 ) = <* D70 *> & ( ( decomp C220 ) /. C222 ) = ( ( decomp C220 ) . C222 )) by L452 , L430 , L434 , L457 , FUNCOP_1:7 , PARTFUN1:def 6;
L461: ( D73 . C222 ) = ( <* C219 *> ^ <* C223 , C224 *> ) by L460 , L449 , L452 , L429 , L457 , L458 , PRE_POLY:def 4
.= <* C219 , C223 , C224 *> by FINSEQ_1:43;
reconsider D77 = C223 , D78 = C224 as (Element of ( Bags C190 )) by PRE_POLY:def 12;
reconsider D79 = <* D74 , D77 , D78 *> as (Element of ( 3 -tuples_on ( Bags C190 ) )) by FINSEQ_2:104;
thus L462: ( ( C201 * ( D51 . C218 ) ) . C222 ) = ( C201 . ( D73 . C222 ) ) by L436 , L457 , FUNCT_1:12
.= ( ( ( C192 . ( D79 /. 1 ) ) * ( C193 . ( D79 /. 2 ) ) ) * ( C194 . ( D79 /. 3 ) ) ) by L341 , L461
.= ( ( ( C192 . C219 ) * ( C193 . ( D79 /. 2 ) ) ) * ( C194 . ( D79 /. 3 ) ) ) by FINSEQ_4:18
.= ( ( ( C192 . C219 ) * ( C193 . C223 ) ) * ( C194 . ( D79 /. 3 ) ) ) by FINSEQ_4:18
.= ( ( ( C192 . C219 ) * ( C193 . C223 ) ) * ( C194 . C224 ) ) by FINSEQ_4:18
.= ( ( C192 . C219 ) * ( C221 /. C222 ) ) by L459 , GROUP_1:def 3
.= ( ( ( C192 . C219 ) * C221 ) /. C222 ) by L456 , L41
.= ( ( ( C192 . C219 ) * C221 ) . C222 ) by L445 , L456 , PARTFUN1:def 6;
end;
L463: ( len D75 ) = ( len ( ( C192 . C219 ) * C221 ) ) by L443 , L452 , L430 , L436 , L446 , FINSEQ_3:29;
L464: D75 = ( ( C192 . C219 ) * C221 ) by L463 , L454 , FINSEQ_1:14;
L465: ( C216 /. C218 ) = ( C216 . C218 ) by L428 , PARTFUN1:def 6
.= ( ( ( ( dom D51 ) --> C201 ) . C218 ) * ( D51 . C218 ) ) by L415 , L428 , PBOOLE:def 19
.= ( ( C192 . C219 ) * C221 ) by L422 , L428 , L464 , FUNCOP_1:7;
thus L466: ( ( Sum C216 ) . C218 ) = ( C217 . C218 ) by L465 , L426 , L441 , L442 , L450 , L439 , L427 , MATRLIN:def 6;
end;
L467: ( Sum C216 ) = C217 by L421 , FINSEQ_1:14;
L468: ( dom D50 ) = ( dom D35 ) by L322 , FINSEQ_3:29;
consider C225 being (Permutation of ( dom D52 )) such that L469: D53 = ( D52 * C225 ) by L468 , L323 , L343 , L364 , PRE_POLY:74;
L470: ( rng D52 ) c= ( 3 -tuples_on ( Bags C190 ) );
L471: ( dom D54 ) = ( dom D52 ) by L470 , L367 , RELAT_1:27;
reconsider D80 = C225 as (Permutation of ( dom D54 )) by L471;
L472: D55 = ( D54 * D80 ) by L469 , RELAT_1:36;
L473: ( Sum D54 ) = ( Sum ( Sum C208 ) ) by L366 , L157;
thus L474: ( D31 . C195 ) = ( D32 . C195 ) by L473 , L361 , L418 , L414 , L417 , L467 , L472 , RLVECT_2:7;
end;
thus L475: thesis by L321 , FUNCT_2:63;
end;
definition
let C226 being Ordinal;
let C227 being  Abelian  add-associative  right_zeroed  right_complementable  commutative non  empty doubleLoopStr;
let C228 , C229 being (Series of C226 , C227);
redefine func C228 *' C229;

commutativity
proof
let C230 , C231 being (Series of C226 , C227);
reconsider D81 = ( C230 *' C231 ) , D82 = ( C231 *' C230 ) as (Function of ( Bags C226 ) , (the carrier of C227));
L476:
now
let C232 being (Element of ( Bags C226 ));
defpred S7[ set , set ] means (ex B171 , B172 being (bag of C226) st (( ( decomp C232 ) . $1 ) = <* B171 , B172 *> & ( ( decomp C232 ) . $2 ) = <* B172 , B171 *>));
consider C233 being (FinSequence of (the carrier of C227)) such that L477: ( D81 . C232 ) = ( Sum C233 ) and L478: ( len C233 ) = ( len ( decomp C232 ) ) and L479: (for B173 being (Element of ( NAT )) holds (B173 in ( dom C233 ) implies (ex B174 , B175 being (bag of C226) st (( ( decomp C232 ) /. B173 ) = <* B174 , B175 *> & ( C233 /. B173 ) = ( ( C230 . B174 ) * ( C231 . B175 ) ))))) by L251;
L480: ( dom C233 ) = ( dom ( decomp C232 ) ) by L478 , FINSEQ_3:29;
reconsider D83 = ( dom C233 ) as non  empty set by L480;
L481:
now
let C234 being set;
assume L482: C234 in D83;
consider C235 , C236 being (bag of C226) such that L483: ( ( decomp C232 ) /. C234 ) = <* C235 , C236 *> and L484: C232 = ( C235 + C236 ) by L482 , L480 , PRE_POLY:68;
consider C237 being (Element of ( NAT )) such that L485: C237 in ( dom ( decomp C232 ) ) and L486: ( ( decomp C232 ) /. C237 ) = <* C236 , C235 *> by L484 , PRE_POLY:69;
reconsider D84 = C237 as set;
take D85 = D84;
thus L487: D85 in D83 by L478 , L485 , FINSEQ_3:29;
thus L488: S7[ C234 , D85 ]
proof
take C235;
take C236;
thus L489: thesis by L480 , L482 , L483 , L485 , L486 , PARTFUN1:def 6;
end;

end;
consider C238 being (Function of D83 , D83) such that L489: (for B176 being set holds (B176 in D83 implies S7[ B176 , ( C238 . B176 ) ])) from FUNCT_2:sch 1(L481);
L490: ( dom C238 ) = D83 by FUNCT_2:def 1;
L491: D83 c= ( rng C238 )
proof
let C239 being set;
assume L492: C239 in D83;
consider C240 , C241 being (bag of C226) such that L493: ( ( decomp C232 ) . C239 ) = <* C240 , C241 *> and L494: ( ( decomp C232 ) . ( C238 . C239 ) ) = <* C241 , C240 *> by L492 , L489;
L495: ( C238 . C239 ) in ( rng C238 ) by L490 , L492 , FUNCT_1:def 3;
L496: ( C238 . ( C238 . C239 ) ) in ( rng C238 ) by L495 , L490 , FUNCT_1:def 3;
consider C242 , C243 being (bag of C226) such that L497: ( ( decomp C232 ) . ( C238 . C239 ) ) = <* C242 , C243 *> and L498: ( ( decomp C232 ) . ( C238 . ( C238 . C239 ) ) ) = <* C243 , C242 *> by L489 , L495;
L499: (C242 = C241 & C243 = C240) by L494 , L497 , FINSEQ_1:77;
thus L500: thesis by L499 , L480 , L492 , L496 , L493 , L498 , FUNCT_1:def 4;
end;
L501: ( rng C238 ) = D83 by L491 , XBOOLE_0:def 10;
L502: C238 is  one-to-one
proof
let C244 , C245 being set;
assume that
L503: C244 in ( dom C238 )
and
L504: C245 in ( dom C238 )
and
L505: ( C238 . C244 ) = ( C238 . C245 );
consider C246 , C247 being (bag of C226) such that L506: ( ( decomp C232 ) . C245 ) = <* C246 , C247 *> and L507: ( ( decomp C232 ) . ( C238 . C245 ) ) = <* C247 , C246 *> by L489 , L504;
consider C248 , C249 being (bag of C226) such that L508: ( ( decomp C232 ) . C244 ) = <* C248 , C249 *> and L509: ( ( decomp C232 ) . ( C238 . C244 ) ) = <* C249 , C248 *> by L489 , L503;
L510: (C249 = C247 & C248 = C246) by L505 , L509 , L507 , FINSEQ_1:77;
thus L511: thesis by L510 , L480 , L503 , L504 , L508 , L506 , FUNCT_1:def 4;
end;
reconsider D86 = C238 as (Permutation of ( dom C233 )) by L502 , L501 , FUNCT_2:57;
consider C250 being (FinSequence of (the carrier of C227)) such that L512: ( D82 . C232 ) = ( Sum C250 ) and L513: ( len C250 ) = ( len ( decomp C232 ) ) and L514: (for B177 being (Element of ( NAT )) holds (B177 in ( dom C250 ) implies (ex B178 , B179 being (bag of C226) st (( ( decomp C232 ) /. B177 ) = <* B178 , B179 *> & ( C250 /. B177 ) = ( ( C231 . B178 ) * ( C230 . B179 ) ))))) by L251;
L515: ( dom C250 ) = ( dom ( decomp C232 ) ) by L513 , FINSEQ_3:29;
L516:
now
let C251 being (Element of ( NAT ));
reconsider D87 = ( D86 . C251 ) as (Element of ( NAT ));
L517: ( dom C233 ) = ( dom ( decomp C232 ) ) by L478 , FINSEQ_3:29;
assume L518: C251 in ( dom C250 );
consider C252 , C253 being (bag of C226) such that L519: ( ( decomp C232 ) /. C251 ) = <* C252 , C253 *> and L520: ( C250 /. C251 ) = ( ( C231 . C252 ) * ( C230 . C253 ) ) by L518 , L514;
L521: ( C250 /. C251 ) = ( C250 . C251 ) by L518 , PARTFUN1:def 6;
consider C254 , C255 being (bag of C226) such that L522: ( ( decomp C232 ) . C251 ) = <* C254 , C255 *> and L523: ( ( decomp C232 ) . ( D86 . C251 ) ) = <* C255 , C254 *> by L480 , L515 , L489 , L518;
L524: ( dom C233 ) = ( dom C250 ) by L478 , L513 , FINSEQ_3:29;
L525: ( ( decomp C232 ) /. C251 ) = ( ( decomp C232 ) . C251 ) by L524 , L518 , L517 , PARTFUN1:def 6;
L526: (C252 = C254 & C253 = C255) by L525 , L519 , L522 , FINSEQ_1:77;
L527: ( D86 . C251 ) in ( rng D86 ) by L480 , L515 , L490 , L518 , FUNCT_1:def 3;
L528: ( C233 /. D87 ) = ( C233 . D87 ) by L527 , PARTFUN1:def 6;
consider C256 , C257 being (bag of C226) such that L529: ( ( decomp C232 ) /. D87 ) = <* C256 , C257 *> and L530: ( C233 /. D87 ) = ( ( C230 . C256 ) * ( C231 . C257 ) ) by L479 , L527;
L531: ( ( decomp C232 ) /. D87 ) = ( ( decomp C232 ) . D87 ) by L527 , L517 , PARTFUN1:def 6;
L532: C256 = C255 by L531 , L529 , L523 , FINSEQ_1:77;
thus L533: ( C250 . C251 ) = ( C233 . ( D86 . C251 ) ) by L532 , L520 , L529 , L530 , L523 , L521 , L528 , L531 , L526 , FINSEQ_1:77;
end;
thus L534: ( D81 . C232 ) = ( D82 . C232 ) by L516 , L477 , L478 , L512 , L513 , RLVECT_2:6;
end;
thus L535: ( C230 *' C231 ) = ( C231 *' C230 ) by L476 , FUNCT_2:63;
end;
end;
theorem
L537: (for B180 being Ordinal holds (for B181 being  add-associative  right_complementable  right_zeroed  right_unital  distributive non  empty doubleLoopStr holds (for B182 being (Series of B180 , B181) holds ( B182 *' ( 0_ (B180 , B181) ) ) = ( 0_ (B180 , B181) ))))
proof
let C258 being Ordinal;
let C259 being  add-associative  right_complementable  right_zeroed  right_unital  distributive non  empty doubleLoopStr;
let C260 being (Series of C258 , C259);
set D88 = ( 0_ (C258 , C259) );
L538:
now
let C261 being (Element of ( Bags C258 ));
consider C262 being (FinSequence of (the carrier of C259)) such that L539: ( ( C260 *' D88 ) . C261 ) = ( Sum C262 ) and L540: ( len C262 ) = ( len ( decomp C261 ) ) and L541: (for B183 being (Element of ( NAT )) holds (B183 in ( dom C262 ) implies (ex B184 , B185 being (bag of C258) st (( ( decomp C261 ) /. B183 ) = <* B184 , B185 *> & ( C262 /. B183 ) = ( ( C260 . B184 ) * ( D88 . B185 ) ))))) by L251;
L542:
now
let C263 being Nat;
assume L543: C263 in ( dom C262 );
consider C264 , C265 being (bag of C258) such that L544: ( ( decomp C261 ) /. C263 ) = <* C264 , C265 *> and L545: ( C262 /. C263 ) = ( ( C260 . C264 ) * ( D88 . C265 ) ) by L543 , L541;
thus L546: ( C262 /. C263 ) = ( ( C260 . C264 ) * ( 0. C259 ) ) by L545 , L233
.= ( 0. C259 ) by VECTSP_1:6;
end;
L547: ( Sum C262 ) = ( 0. C259 ) by L542 , MATRLIN:11;
thus L548: ( ( C260 *' D88 ) . C261 ) = ( D88 . C261 ) by L547 , L539 , L233;
end;
thus L549: thesis by L538 , FUNCT_2:63;
end;
theorem
L550: (for B186 being Ordinal holds (for B187 being  add-associative  right_complementable  right_zeroed  distributive  right_unital non  trivial non  empty doubleLoopStr holds (for B188 being (Series of B186 , B187) holds ( B188 *' ( 1_ (B186 , B187) ) ) = B188)))
proof
let C266 being Ordinal;
let C267 being  add-associative  right_complementable  right_zeroed  distributive  right_unital non  trivial doubleLoopStr;
let C268 being (Series of C266 , C267);
set D89 = ( 1_ (C266 , C267) );
set D90 = (the carrier of C267);
L551:
now
let C269 being (Element of ( Bags C266 ));
consider C270 being (FinSequence of D90) such that L552: ( ( C268 *' D89 ) . C269 ) = ( Sum C270 ) and L553: ( len C270 ) = ( len ( decomp C269 ) ) and L554: (for B189 being (Element of ( NAT )) holds (B189 in ( dom C270 ) implies (ex B190 , B191 being (bag of C266) st (( ( decomp C269 ) /. B189 ) = <* B190 , B191 *> & ( C270 /. B189 ) = ( ( C268 . B190 ) * ( D89 . B191 ) ))))) by L251;
consider C271 being (FinSequence of D90), C272 being (Element of D90) such that L555: C270 = ( C271 ^ <* C272 *> ) by L553 , FINSEQ_2:19;
L556:
now
per cases ;
suppose L557: C271 = ( <*> D90 );

thus L558: ( Sum C271 ) = ( 0. C267 ) by L557 , RLVECT_1:43;
end;
suppose L559: C271 <> ( <*> D90 );

L560:
now
let C273 being Nat;
L561: ( len C270 ) = ( ( len C271 ) + ( len <* C272 *> ) ) by L555 , FINSEQ_1:22
.= ( ( len C271 ) + 1 ) by FINSEQ_1:39;
assume L562: C273 in ( dom C271 );
L563: ( C271 /. C273 ) = ( C271 . C273 ) by L562 , PARTFUN1:def 6
.= ( C270 . C273 ) by L555 , L562 , FINSEQ_1:def 7;
L564: C273 <= ( len C271 ) by L562 , FINSEQ_3:25;
L565: C273 < ( len C270 ) by L564 , L561 , NAT_1:13;
L566: 1 <= C273 by L562 , FINSEQ_3:25;
L567: C273 in ( dom ( decomp C269 ) ) by L566 , L553 , L565 , FINSEQ_3:25;
L568: ( dom C270 ) = ( dom ( decomp C269 ) ) by L553 , FINSEQ_3:29;
L569: ( C270 /. C273 ) = ( C270 . C273 ) by L568 , L567 , PARTFUN1:def 6;
per cases  by L566 , XXREAL_0:1;
suppose L570: 1 < C273;

consider C274 , C275 being (bag of C266) such that L571: ( ( decomp C269 ) /. C273 ) = <* C274 , C275 *> and L572: ( C270 /. C273 ) = ( ( C268 . C274 ) * ( D89 . C275 ) ) by L554 , L568 , L567;
L573: C275 <> ( EmptyBag C266 ) by L553 , L565 , L570 , L571 , PRE_POLY:72;
thus L574: ( C271 /. C273 ) = ( ( C268 . C274 ) * ( 0. C267 ) ) by L573 , L563 , L569 , L572 , L245
.= ( 0. C267 ) by VECTSP_1:6;
end;
suppose L575: C273 = 1;

L576:
now
assume L577: C269 = ( EmptyBag C266 );
L578: ( decomp C269 ) = <* <* ( EmptyBag C266 ) , ( EmptyBag C266 ) *> *> by L577 , PRE_POLY:73;
L579: ( ( len C271 ) + 1 ) = ( (( 0 ) qua Nat) + 1 ) by L578 , L553 , L561 , FINSEQ_1:39;
thus L580: contradiction by L579 , L559;
end;
consider C276 , C277 being (bag of C266) such that L581: ( ( decomp C269 ) /. C273 ) = <* C276 , C277 *> and L582: ( C270 /. C273 ) = ( ( C268 . C276 ) * ( D89 . C277 ) ) by L554 , L568 , L567;
L583: ( ( decomp C269 ) /. 1 ) = <* ( EmptyBag C266 ) , C269 *> by PRE_POLY:71;
L584: (C276 = ( EmptyBag C266 ) & C277 = C269) by L583 , L575 , L581 , FINSEQ_1:77;
L585: ( C270 . C273 ) = ( ( C268 . ( EmptyBag C266 ) ) * ( 0. C267 ) ) by L584 , L569 , L582 , L576 , L245
.= ( 0. C267 ) by VECTSP_1:6;
thus L586: ( C271 /. C273 ) = ( 0. C267 ) by L585 , L563;
end;
end;
thus L588: ( Sum C271 ) = ( 0. C267 ) by L560 , MATRLIN:11;
end;
end;
L590: ( C270 . ( len C270 ) ) = ( ( C271 ^ <* C272 *> ) . ( ( len C271 ) + 1 ) ) by L555 , FINSEQ_2:16
.= C272 by FINSEQ_1:42;
L591: ( Sum C270 ) = ( ( Sum C271 ) + ( Sum <* C272 *> ) ) by L555 , RLVECT_1:41;
L592: C270 is non  empty by L553;
L593: ( len C270 ) in ( dom C270 ) by L592 , FINSEQ_5:6;
consider C278 , C279 being (bag of C266) such that L594: ( ( decomp C269 ) /. ( len C270 ) ) = <* C278 , C279 *> and L595: ( C270 /. ( len C270 ) ) = ( ( C268 . C278 ) * ( D89 . C279 ) ) by L593 , L554;
L596: ( C270 /. ( len C270 ) ) = ( C270 . ( len C270 ) ) by L593 , PARTFUN1:def 6;
L597: ( ( decomp C269 ) /. ( len C270 ) ) = <* C269 , ( EmptyBag C266 ) *> by L553 , PRE_POLY:71;
L598: (C278 = C269 & C279 = ( EmptyBag C266 )) by L597 , L594 , FINSEQ_1:77;
L599: ( Sum <* C272 *> ) = C272 by RLVECT_1:44
.= ( ( C268 . C269 ) * ( 1. C267 ) ) by L595 , L598 , L590 , L596 , L245
.= ( C268 . C269 ) by VECTSP_1:def 4;
thus L600: ( ( C268 *' D89 ) . C269 ) = ( C268 . C269 ) by L599 , L552 , L591 , L556 , RLVECT_1:4;
end;
thus L601: thesis by L551 , FUNCT_2:63;
end;
theorem
L602: (for B192 being Ordinal holds (for B193 being  add-associative  right_complementable  right_zeroed  distributive  well-unital non  trivial non  empty doubleLoopStr holds (for B194 being (Series of B192 , B193) holds ( ( 1_ (B192 , B193) ) *' B194 ) = B194)))
proof
let C280 being Ordinal;
let C281 being  add-associative  right_complementable  right_zeroed  distributive  well-unital non  trivial doubleLoopStr;
let C282 being (Series of C280 , C281);
set D91 = ( 1_ (C280 , C281) );
set D92 = (the carrier of C281);
L603:
now
let C283 being (Element of ( Bags C280 ));
consider C284 being (FinSequence of D92) such that L604: ( ( D91 *' C282 ) . C283 ) = ( Sum C284 ) and L605: ( len C284 ) = ( len ( decomp C283 ) ) and L606: (for B195 being (Element of ( NAT )) holds (B195 in ( dom C284 ) implies (ex B196 , B197 being (bag of C280) st (( ( decomp C283 ) /. B195 ) = <* B196 , B197 *> & ( C284 /. B195 ) = ( ( D91 . B196 ) * ( C282 . B197 ) ))))) by L251;
L607: C284 is non  empty by L605;
consider C285 being (Element of D92), C286 being (FinSequence of D92) such that L608: C285 = ( C284 . 1 ) and L609: C284 = ( <* C285 *> ^ C286 ) by L607 , FINSEQ_3:102;
L610: ( Sum C284 ) = ( ( Sum <* C285 *> ) + ( Sum C286 ) ) by L609 , RLVECT_1:41;
L611:
now
per cases ;
suppose L612: C286 = ( <*> D92 );

thus L613: ( Sum C286 ) = ( 0. C281 ) by L612 , RLVECT_1:43;
end;
suppose L614: C286 <> ( <*> D92 );

L615:
now
let C287 being Nat;
L616: ( len C284 ) = ( ( len C286 ) + ( len <* C285 *> ) ) by L609 , FINSEQ_1:22
.= ( ( len C286 ) + 1 ) by FINSEQ_1:39;
assume L617: C287 in ( dom C286 );
L618: ( C286 /. C287 ) = ( C286 . C287 ) by L617 , PARTFUN1:def 6
.= ( C284 . ( C287 + 1 ) ) by L609 , L617 , FINSEQ_3:103;
L619: 1 <= C287 by L617 , FINSEQ_3:25;
L620: 1 < ( C287 + 1 ) by L619 , NAT_1:13;
L621: C287 <= ( len C286 ) by L617 , FINSEQ_3:25;
L622: ( C287 + 1 ) <= ( len C284 ) by L621 , L616 , XREAL_1:6;
L623: ( C287 + 1 ) in ( dom ( decomp C283 ) ) by L622 , L605 , L620 , FINSEQ_3:25;
L624: ( dom C284 ) = ( dom ( decomp C283 ) ) by L605 , FINSEQ_3:29;
L625: ( C284 /. ( C287 + 1 ) ) = ( C284 . ( C287 + 1 ) ) by L624 , L623 , PARTFUN1:def 6;
per cases  by L622 , XXREAL_0:1;
suppose L626: ( C287 + 1 ) < ( len C284 );

consider C288 , C289 being (bag of C280) such that L627: ( ( decomp C283 ) /. ( C287 + 1 ) ) = <* C288 , C289 *> and L628: ( C284 /. ( C287 + 1 ) ) = ( ( D91 . C288 ) * ( C282 . C289 ) ) by L606 , L624 , L623;
L629: C288 <> ( EmptyBag C280 ) by L605 , L620 , L626 , L627 , PRE_POLY:72;
thus L630: ( C286 /. C287 ) = ( ( 0. C281 ) * ( C282 . C289 ) ) by L629 , L618 , L625 , L628 , L245
.= ( 0. C281 ) by VECTSP_1:7;
end;
suppose L631: ( C287 + 1 ) = ( len C284 );

L632:
now
assume L633: C283 = ( EmptyBag C280 );
L634: ( decomp C283 ) = <* <* ( EmptyBag C280 ) , ( EmptyBag C280 ) *> *> by L633 , PRE_POLY:73;
L635: ( ( len C286 ) + 1 ) = ( (( 0 ) qua Nat) + 1 ) by L634 , L605 , L616 , FINSEQ_1:39;
thus L636: contradiction by L635 , L614;
end;
consider C290 , C291 being (bag of C280) such that L637: ( ( decomp C283 ) /. ( C287 + 1 ) ) = <* C290 , C291 *> and L638: ( C284 /. ( C287 + 1 ) ) = ( ( D91 . C290 ) * ( C282 . C291 ) ) by L606 , L624 , L623;
L639: ( ( decomp C283 ) /. ( len C284 ) ) = <* C283 , ( EmptyBag C280 ) *> by L605 , PRE_POLY:71;
L640: (C291 = ( EmptyBag C280 ) & C290 = C283) by L639 , L631 , L637 , FINSEQ_1:77;
L641: ( C284 . ( C287 + 1 ) ) = ( ( 0. C281 ) * ( C282 . ( EmptyBag C280 ) ) ) by L640 , L625 , L638 , L632 , L245
.= ( 0. C281 ) by VECTSP_1:7;
thus L642: ( C286 /. C287 ) = ( 0. C281 ) by L641 , L618;
end;
end;
thus L644: ( Sum C286 ) = ( 0. C281 ) by L615 , MATRLIN:11;
end;
end;
L646: C284 is non  empty by L605;
consider C292 , C293 being (bag of C280) such that L647: ( ( decomp C283 ) /. 1 ) = <* C292 , C293 *> and L648: ( C284 /. 1 ) = ( ( D91 . C292 ) * ( C282 . C293 ) ) by L646 , L606 , FINSEQ_5:6;
L649: 1 in ( dom C284 ) by L646 , FINSEQ_5:6;
L650: ( C284 /. 1 ) = ( C284 . 1 ) by L649 , PARTFUN1:def 6;
L651: ( ( decomp C283 ) /. 1 ) = <* ( EmptyBag C280 ) , C283 *> by PRE_POLY:71;
L652: (C293 = C283 & C292 = ( EmptyBag C280 )) by L651 , L647 , FINSEQ_1:77;
L653: ( Sum <* C285 *> ) = C285 by RLVECT_1:44
.= ( ( 1. C281 ) * ( C282 . C283 ) ) by L608 , L648 , L652 , L650 , L245
.= ( C282 . C283 ) by VECTSP_1:def 6;
thus L654: ( ( D91 *' C282 ) . C283 ) = ( C282 . C283 ) by L653 , L604 , L610 , L611 , RLVECT_1:4;
end;
thus L655: thesis by L603 , FUNCT_2:63;
end;
begin
registration
let C294 being set;
let C295 being non  empty ZeroStr;
cluster  finite-Support for (Series of C294 , C295);
existence
proof
reconsider D93 = ( ( Bags C294 ) --> ( 0. C295 ) ) as (Function of ( Bags C294 ) , (the carrier of C295));
reconsider D94 = D93 as (Function of ( Bags C294 ) , C295);
reconsider D95 = D94 as (Series of C294 , C295);
take D95;
L656: (for B198 being (Element of ( Bags C294 )) holds (B198 in ( {} ) iff ( D95 . B198 ) <> ( 0. C295 ))) by FUNCOP_1:7;
L657: ( Support D95 ) = ( {} ( Bags C294 ) ) by L656 , L164;
thus L658: ( Support D95 ) is  finite by L657;
end;
end;
definition
let C296 being Ordinal;
let C297 being non  empty ZeroStr;
mode Polynomial of C296 , C297
 is  finite-Support (Series of C296 , C297);
end;
registration
let C298 being Ordinal;
let C299 being  right_zeroed non  empty addLoopStr;
let C300 , C301 being (Polynomial of C298 , C299);
cluster ( C300 + C301 ) ->  finite-Support;
coherence
proof
set D96 = ( Support C300 );
set D97 = ( Support C301 );
L661: (( Support C300 ) is  finite & ( Support C301 ) is  finite) by L174;
L662: ( D96 \/ D97 ) is  finite by L661;
L663: ( Support ( C300 + C301 ) ) is  finite by L662 , L216 , FINSET_1:1;
thus L664: thesis by L663 , L174;
end;
end;
registration
let C302 being Ordinal;
let C303 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C304 being (Polynomial of C302 , C303);
cluster ( - C304 ) ->  finite-Support;
coherence
proof
set D98 = ( - C304 );
L666: ( Support D98 ) c= ( Support C304 )
proof
let C305 being set;
assume L667: C305 in ( Support D98 );
reconsider D99 = C305 as (Element of ( Bags C302 )) by L667;
L668: ( D98 . D99 ) <> ( 0. C303 ) by L667 , L164;
L669: ( - ( C304 . D99 ) ) <> ( 0. C303 ) by L668 , L193;
L670: ( C304 . D99 ) <> ( 0. C303 ) by L669 , RLVECT_1:12;
thus L671: thesis by L670 , L164;
end;
L672: ( Support C304 ) is  finite by L174;
thus L673: thesis by L672 , L666 , L174;
end;
end;
registration
let C306 being (Element of ( NAT ));
let C307 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C308 , C309 being (Polynomial of C306 , C307);
cluster ( C308 - C309 ) ->  finite-Support;
coherence;
end;
registration
let C310 being Ordinal;
let C311 being non  empty ZeroStr;
cluster ( 0_ (C310 , C311) ) ->  finite-Support;
coherence
proof
set D100 = ( 0_ (C310 , C311) );
L676:
now
given C312 being set such that
L677: C312 in ( Support D100 );

reconsider D101 = C312 as (Element of ( Bags C310 )) by L677;
L678: ( D100 . D101 ) = ( 0. C311 ) by FUNCOP_1:7;
thus L679: contradiction by L678 , L677 , L164;
end;
L680: ( Support D100 ) = ( {} ) by L676 , XBOOLE_0:def 1;
thus L681: thesis by L680 , L174;
end;
end;
registration
let C313 being Ordinal;
let C314 being  add-associative  right_zeroed  right_complementable  right_unital  right-distributive non  trivial doubleLoopStr;
cluster ( 1_ (C313 , C314) ) ->  finite-Support;
coherence
proof
reconsider D102 = ( ( 0_ (C313 , C314) ) +* (( EmptyBag C313 ) , ( 1. C314 )) ) as (Function of ( Bags C313 ) , (the carrier of C314));
reconsider D103 = D102 as (Function of ( Bags C313 ) , C314);
reconsider D104 = D103 as (Series of C313 , C314);
L683:
now
let C315 being set;
thus L684:now
assume L685: C315 in ( Support D104 );
reconsider D105 = C315 as (Element of ( Bags C313 )) by L685;
assume L686: C315 <> ( EmptyBag C313 );
L687: ( D104 . C315 ) = ( ( 0_ (C313 , C314) ) . D105 ) by L686 , FUNCT_7:32
.= ( 0. C314 ) by FUNCOP_1:7;
thus L688: contradiction by L687 , L685 , L164;
end;
assume L689: C315 = ( EmptyBag C313 );
L690: ( dom ( 0_ (C313 , C314) ) ) = ( Bags C313 ) by FUNCOP_1:13;
L691: ( D104 . C315 ) <> ( 0. C314 ) by L690 , L689 , FUNCT_7:31;
thus L692: C315 in ( Support D104 ) by L691 , L689 , L164;
end;
L693: ( Support D104 ) = { ( EmptyBag C313 ) } by L683 , TARSKI:def 1;
thus L694: thesis by L693 , L174;
end;
end;
registration
let C316 being Ordinal;
let C317 being  add-associative  right_complementable  right_zeroed  right_unital  distributive non  empty doubleLoopStr;
let C318 , C319 being (Polynomial of C316 , C317);
cluster ( C318 *' C319 ) ->  finite-Support;
coherence
proof
deffunc H5((Element of ( Bags C316 )) , (Element of ( Bags C316 ))) = ( $1 + $2 );
set D106 = { H5(B199 , B200) where B199 , B200 is (Element of ( Bags C316 )) : (B199 in ( Support C318 ) & B200 in ( Support C319 )) };
L696: ( Support C319 ) is  finite by L174;
L697: ( Support ( C318 *' C319 ) ) c= D106
proof
let C320 being set;
assume L698: C320 in ( Support ( C318 *' C319 ) );
reconsider D107 = C320 as (Element of ( Bags C316 )) by L698;
consider C321 being (FinSequence of (the carrier of C317)) such that L699: ( ( C318 *' C319 ) . D107 ) = ( Sum C321 ) and L700: ( len C321 ) = ( len ( decomp D107 ) ) and L701: (for B201 being (Element of ( NAT )) holds (B201 in ( dom C321 ) implies (ex B202 , B203 being (bag of C316) st (( ( decomp D107 ) /. B201 ) = <* B202 , B203 *> & ( C321 /. B201 ) = ( ( C318 . B202 ) * ( C319 . B203 ) ))))) by L251;
L702: ( ( C318 *' C319 ) . D107 ) <> ( 0. C317 ) by L698 , L164;
consider C322 being Nat such that L703: C322 in ( dom C321 ) and L704: ( C321 /. C322 ) <> ( 0. C317 ) by L702 , L699 , MATRLIN:11;
consider C323 , C324 being (bag of C316) such that L705: ( ( decomp D107 ) /. C322 ) = <* C323 , C324 *> and L706: ( C321 /. C322 ) = ( ( C318 . C323 ) * ( C319 . C324 ) ) by L701 , L703;
L707: C323 in ( Bags C316 ) by PRE_POLY:def 12;
L708: C324 in ( Bags C316 ) by PRE_POLY:def 12;
L709: ( C319 . C324 ) <> ( 0. C317 ) by L704 , L706 , VECTSP_1:6;
L710: C324 in ( Support C319 ) by L709 , L708 , L164;
L711: ( C318 . C323 ) <> ( 0. C317 ) by L704 , L706 , VECTSP_1:7;
L712: C323 in ( Support C318 ) by L711 , L707 , L164;
L713: C322 in ( dom ( decomp D107 ) ) by L700 , L703 , FINSEQ_3:29;
consider C325 , C326 being (bag of C316) such that L714: ( ( decomp D107 ) /. C322 ) = <* C325 , C326 *> and L715: D107 = ( C325 + C326 ) by L713 , PRE_POLY:68;
L716: (C325 = C323 & C326 = C324) by L705 , L714 , FINSEQ_1:77;
thus L717: thesis by L716 , L712 , L710 , L715;
end;
L718: ( Support C318 ) is  finite by L174;
L719: D106 is  finite from FRAENKEL:sch 22(L718 , L696);
thus L720: thesis by L719 , L697 , L174;
end;
end;
begin
definition
let C327 being Ordinal;
let C328 being  right_zeroed  add-associative  right_complementable  right_unital  distributive non  trivial doubleLoopStr;
func Polynom-Ring (C327 , C328) ->  strict non  empty doubleLoopStr means 
:L722: ((for B204 being set holds (B204 in (the carrier of it) iff B204 is (Polynomial of C327 , C328))) & (for B205 , B206 being (Element of it) holds (for B207 , B208 being (Polynomial of C327 , C328) holds ((B205 = B207 & B206 = B208) implies ( B205 + B206 ) = ( B207 + B208 )))) & (for B209 , B210 being (Element of it) holds (for B211 , B212 being (Polynomial of C327 , C328) holds ((B209 = B211 & B210 = B212) implies ( B209 * B210 ) = ( B211 *' B212 )))) & ( 0. it ) = ( 0_ (C327 , C328) ) & ( 1. it ) = ( 1_ (C327 , C328) ));
existence
proof
reconsider D108 = ( ( Bags C327 ) --> ( 0. C328 ) ) as (Function of ( Bags C327 ) , (the carrier of C328));
defpred S8[ set , set , set ] means (ex B213 , B214 , B215 being (Polynomial of C327 , C328) st (B213 = $1 & B214 = $2 & B215 = $3 & ( B213 *' B214 ) = B215));
defpred S9[ set , set , set ] means (ex B216 , B217 , B218 being (Polynomial of C327 , C328) st (B216 = $1 & B217 = $2 & B218 = $3 & ( B216 + B217 ) = B218));
set D109 = the  finite-Support (Series of C327 , C328);
defpred S10[ set ] means (ex B219 being (Series of C327 , C328) st (B219 = $1 & B219 is  finite-Support));
consider C329 being (Subset of ( Funcs (( Bags C327 ) , (the carrier of C328)) )) such that L723: (for B220 being (Element of ( Funcs (( Bags C327 ) , (the carrier of C328)) )) holds (B220 in C329 iff S10[ B220 ])) from SUBSET_1:sch 3;
L724: D109 in ( Funcs (( Bags C327 ) , (the carrier of C328)) ) by FUNCT_2:8;
reconsider D110 = C329 as non  empty (Subset of ( Funcs (( Bags C327 ) , (the carrier of C328)) )) by L724 , L723;
L725:
now
let C330 being (Element of D110);
let C331 being (Element of D110);
reconsider D111 = C330 , D112 = C331 as (Element of ( Funcs (( Bags C327 ) , (the carrier of C328)) ));
consider C332 being (Series of C327 , C328) such that L726: C332 = D111 and L727: C332 is  finite-Support by L723;
consider C333 being (Series of C327 , C328) such that L728: C333 = D112 and L729: C333 is  finite-Support by L723;
reconsider D113 = C332 , D114 = C333 as (Polynomial of C327 , C328) by L727 , L729;
set D115 = ( D113 + D114 );
L730: D115 in ( Funcs (( Bags C327 ) , (the carrier of C328)) ) by FUNCT_2:8;
reconsider D116 = D115 as (Element of D110) by L730 , L723;
take D117 = D116;
thus L731: S9[ C330 , C331 , D117 ] by L726 , L728;
end;
consider C334 being (Function of [: D110 , D110 :] , D110) such that L732: (for B221 being (Element of D110) holds (for B222 being (Element of D110) holds S9[ B221 , B222 , ( C334 . (B221 , B222) ) ])) from BINOP_1:sch 3(L725);
L733:
now
let C335 being (Element of D110);
let C336 being (Element of D110);
reconsider D118 = C335 , D119 = C336 as (Element of ( Funcs (( Bags C327 ) , (the carrier of C328)) ));
consider C337 being (Series of C327 , C328) such that L734: C337 = D118 and L735: C337 is  finite-Support by L723;
consider C338 being (Series of C327 , C328) such that L736: C338 = D119 and L737: C338 is  finite-Support by L723;
reconsider D120 = C337 , D121 = C338 as (Polynomial of C327 , C328) by L735 , L737;
set D122 = ( D120 *' D121 );
L738: D122 in ( Funcs (( Bags C327 ) , (the carrier of C328)) ) by FUNCT_2:8;
reconsider D123 = D122 as (Element of D110) by L738 , L723;
take D124 = D123;
thus L739: S8[ C335 , C336 , D124 ] by L734 , L736;
end;
consider C339 being (Function of [: D110 , D110 :] , D110) such that L740: (for B223 being (Element of D110) holds (for B224 being (Element of D110) holds S8[ B223 , B224 , ( C339 . (B223 , B224) ) ])) from BINOP_1:sch 3(L733);
reconsider D125 = D108 as (Element of ( Funcs (( Bags C327 ) , (the carrier of C328)) )) by FUNCT_2:8;
reconsider D126 = D108 as (Function of ( Bags C327 ) , C328);
reconsider D127 = D126 as (Series of C327 , C328);
L741:
now
given C340 being set such that
L742: C340 in ( Support D127 );

reconsider D128 = C340 as (Element of ( Bags C327 )) by L742;
L743: ( D127 . D128 ) = ( 0. C328 ) by FUNCOP_1:7;
thus L744: contradiction by L743 , L742 , L164;
end;
L745: ( Support D127 ) = ( {} ) by L741 , XBOOLE_0:def 1;
L746: D127 is  finite-Support by L745 , L174;
L747: D125 in D110 by L746 , L723;
reconsider D129 = D108 as (Element of D110) by L747;
reconsider D130 = ( D108 +* (( EmptyBag C327 ) , ( 1. C328 )) ) as (Function of ( Bags C327 ) , (the carrier of C328));
reconsider D131 = D130 as (Function of ( Bags C327 ) , C328);
reconsider D132 = D131 as (Series of C327 , C328);
reconsider D133 = D130 as (Element of ( Funcs (( Bags C327 ) , (the carrier of C328)) )) by FUNCT_2:8;
L748:
now
let C341 being set;
thus L749:now
assume L750: C341 in ( Support D132 );
reconsider D134 = C341 as (Element of ( Bags C327 )) by L750;
assume L751: C341 <> ( EmptyBag C327 );
L752: ( D132 . C341 ) = ( D108 . D134 ) by L751 , FUNCT_7:32
.= ( 0. C328 ) by FUNCOP_1:7;
thus L753: contradiction by L752 , L750 , L164;
end;
assume L754: C341 = ( EmptyBag C327 );
L755: ( dom D108 ) = ( Bags C327 ) by FUNCOP_1:13;
L756: ( D132 . C341 ) <> ( 0. C328 ) by L755 , L754 , FUNCT_7:31;
thus L757: C341 in ( Support D132 ) by L756 , L754 , L164;
end;
L758: ( Support D132 ) = { ( EmptyBag C327 ) } by L748 , TARSKI:def 1;
L759: D132 is  finite-Support by L758 , L174;
reconsider D135 = D133 as (Element of D110) by L759 , L723;
reconsider D136 = doubleLoopStr (# D110 , C334 , C339 , D135 , D129 #) as  strict non  empty doubleLoopStr;
take D136;
thus L760: (for B225 being set holds (B225 in (the carrier of D136) iff B225 is (Polynomial of C327 , C328)))
proof
let C342 being set;
thus L761:now
assume L762: C342 in (the carrier of D136);
reconsider D137 = C342 as (Element of ( Funcs (( Bags C327 ) , (the carrier of C328)) )) by L762;
L763: (ex B226 being (Series of C327 , C328) st (B226 = D137 & B226 is  finite-Support)) by L723 , L762;
thus L764: C342 is (Polynomial of C327 , C328) by L763;
end;
assume L765: C342 is (Polynomial of C327 , C328);
L766: C342 is (Element of ( Funcs (( Bags C327 ) , (the carrier of C328)) )) by L765 , FUNCT_2:8;
thus L767: thesis by L766 , L723 , L765;
end;

thus L768:now
let C343 , C344 being (Element of D136);
let C345 , C346 being (Polynomial of C327 , C328);
assume that
L769: (C343 = C345 & C344 = C346);
L770: (ex B227 , B228 , B229 being (Polynomial of C327 , C328) st (B227 = C343 & B228 = C344 & B229 = ( C334 . (C343 , C344) ) & ( B227 + B228 ) = B229)) by L732;
thus L771: ( C343 + C344 ) = ( C345 + C346 ) by L770 , L769;
end;
thus L772:now
let C347 , C348 being (Element of D136);
let C349 , C350 being (Polynomial of C327 , C328);
assume that
L773: (C347 = C349 & C348 = C350);
L774: (ex B230 , B231 , B232 being (Polynomial of C327 , C328) st (B230 = C347 & B231 = C348 & B232 = ( C339 . (C347 , C348) ) & ( B230 *' B231 ) = B232)) by L740;
thus L775: ( C347 * C348 ) = ( C349 *' C350 ) by L774 , L773;
end;
thus L776: ( 0. D136 ) = ( 0_ (C327 , C328) );
thus L777: thesis;
end;
uniqueness
proof
let C351 , C352 being  strict non  empty doubleLoopStr;
assume that
L778: (for B233 being set holds (B233 in (the carrier of C351) iff B233 is (Polynomial of C327 , C328)))
and
L779: (for B234 , B235 being (Element of C351) holds (for B236 , B237 being (Polynomial of C327 , C328) holds ((B234 = B236 & B235 = B237) implies ( B234 + B235 ) = ( B236 + B237 ))))
and
L780: (for B238 , B239 being (Element of C351) holds (for B240 , B241 being (Polynomial of C327 , C328) holds ((B238 = B240 & B239 = B241) implies ( B238 * B239 ) = ( B240 *' B241 ))))
and
L781: (( 0. C351 ) = ( 0_ (C327 , C328) ) & ( 1. C351 ) = ( 1_ (C327 , C328) ))
and
L782: (for B242 being set holds (B242 in (the carrier of C352) iff B242 is (Polynomial of C327 , C328)))
and
L783: (for B243 , B244 being (Element of C352) holds (for B245 , B246 being (Polynomial of C327 , C328) holds ((B243 = B245 & B244 = B246) implies ( B243 + B244 ) = ( B245 + B246 ))))
and
L784: (for B247 , B248 being (Element of C352) holds (for B249 , B250 being (Polynomial of C327 , C328) holds ((B247 = B249 & B248 = B250) implies ( B247 * B248 ) = ( B249 *' B250 ))))
and
L785: (( 0. C352 ) = ( 0_ (C327 , C328) ) & ( 1. C352 ) = ( 1_ (C327 , C328) ));
L786:
now
let C353 being set;
thus L787:now
assume L788: C353 in (the carrier of C351);
L789: C353 is (Polynomial of C327 , C328) by L788 , L778;
thus L790: C353 in (the carrier of C352) by L789 , L782;
end;
assume L791: C353 in (the carrier of C352);
L792: C353 is (Polynomial of C327 , C328) by L791 , L782;
thus L793: C353 in (the carrier of C351) by L792 , L778;
end;
L794: (the carrier of C351) = (the carrier of C352) by L786 , TARSKI:1;
L795:
now
let C354 , C355 being (Element of C351);
reconsider D138 = C354 , D139 = C355 as (Element of C352) by L786;
reconsider D140 = D138 , D141 = D139 as (Element of C352);
reconsider D142 = C354 , D143 = C355 as (Polynomial of C327 , C328) by L778;
reconsider D144 = C354 , D145 = C355 as (Element of C351);
thus L796: ( (the multF of C351) . (C354 , C355) ) = ( D144 * D145 )
.= ( D142 *' D143 ) by L780
.= ( D140 * D141 ) by L784
.= ( (the multF of C352) . (C354 , C355) );
end;
L797:
now
let C356 , C357 being (Element of C351);
reconsider D146 = C356 , D147 = C357 as (Element of C352) by L786;
reconsider D148 = D146 , D149 = D147 as (Element of C352);
reconsider D150 = C356 , D151 = C357 as (Polynomial of C327 , C328) by L778;
reconsider D152 = C356 , D153 = C357 as (Element of C351);
thus L798: ( (the addF of C351) . (C356 , C357) ) = ( D152 + D153 )
.= ( D150 + D151 ) by L779
.= ( D148 + D149 ) by L783
.= ( (the addF of C352) . (C356 , C357) );
end;
L799: (the addF of C351) = (the addF of C352) by L797 , L794 , BINOP_1:2;
thus L800: thesis by L799 , L781 , L785 , L794 , L795 , BINOP_1:2;
end;
end;
registration
let C358 being Ordinal;
let C359 being  Abelian  right_zeroed  add-associative  right_complementable  right_unital  distributive non  trivial doubleLoopStr;
cluster ( Polynom-Ring (C358 , C359) ) ->  Abelian;
coherence
proof
set D154 = ( Polynom-Ring (C358 , C359) );
let C360 , C361 being (Element of D154);
reconsider D155 = C360 , D156 = C361 as (Polynomial of C358 , C359) by L722;
thus L802: ( C360 + C361 ) = ( D156 + D155 ) by L722
.= ( C361 + C360 ) by L722;
end;
end;
registration
let C362 being Ordinal;
let C363 being  add-associative  right_zeroed  right_complementable  right_unital  distributive non  trivial doubleLoopStr;
cluster ( Polynom-Ring (C362 , C363) ) ->  add-associative;
coherence
proof
set D157 = ( Polynom-Ring (C362 , C363) );
let C364 , C365 , C366 being (Element of D157);
reconsider D158 = C364 , D159 = C365 , D160 = C366 as (Polynomial of C362 , C363) by L722;
L804: ( C365 + C366 ) = ( D159 + D160 ) by L722;
L805: ( C364 + C365 ) = ( D158 + D159 ) by L722;
thus L806: ( ( C364 + C365 ) + C366 ) = ( ( D158 + D159 ) + D160 ) by L805 , L722
.= ( D158 + ( D159 + D160 ) ) by L227
.= ( C364 + ( C365 + C366 ) ) by L804 , L722;
end;
end;
registration
let C367 being Ordinal;
let C368 being  right_zeroed  add-associative  right_complementable  right_unital  distributive non  trivial doubleLoopStr;
cluster ( Polynom-Ring (C367 , C368) ) ->  right_zeroed;
coherence
proof
let C369 being (Element of ( Polynom-Ring (C367 , C368) ));
reconsider D161 = C369 as (Polynomial of C367 , C368) by L722;
L808: ( 0. ( Polynom-Ring (C367 , C368) ) ) = ( 0_ (C367 , C368) ) by L722;
thus L809: ( C369 + ( 0. ( Polynom-Ring (C367 , C368) ) ) ) = ( D161 + ( 0_ (C367 , C368) ) ) by L808 , L722
.= C369 by L236;
end;
end;
registration
let C370 being Ordinal;
let C371 being  right_complementable  right_zeroed  add-associative  right_unital  distributive non  trivial doubleLoopStr;
cluster ( Polynom-Ring (C370 , C371) ) ->  right_complementable;
coherence
proof
let C372 being (Element of ( Polynom-Ring (C370 , C371) ));
reconsider D162 = C372 as (Polynomial of C370 , C371) by L722;
reconsider D163 = ( - D162 ) as (Element of ( Polynom-Ring (C370 , C371) )) by L722;
take D163;
thus L811: ( C372 + D163 ) = ( D162 - D162 ) by L722
.= ( 0_ (C370 , C371) ) by L241
.= ( 0. ( Polynom-Ring (C370 , C371) ) ) by L722;
end;
end;
registration
let C373 being Ordinal;
let C374 being  Abelian  add-associative  right_zeroed  right_complementable  commutative  right_unital  distributive non  trivial non  empty doubleLoopStr;
cluster ( Polynom-Ring (C373 , C374) ) ->  commutative;
coherence
proof
set D164 = ( Polynom-Ring (C373 , C374) );
let C375 , C376 being (Element of D164);
reconsider D165 = C375 , D166 = C376 as (Polynomial of C373 , C374) by L722;
thus L813: ( C375 * C376 ) = ( D166 *' D165 ) by L722
.= ( C376 * C375 ) by L722;
end;
end;
registration
let C377 being Ordinal;
let C378 being  Abelian  add-associative  right_zeroed  right_complementable  right_unital  distributive  associative non  trivial non  empty doubleLoopStr;
cluster ( Polynom-Ring (C377 , C378) ) ->  associative;
coherence
proof
set D167 = ( Polynom-Ring (C377 , C378) );
let C379 , C380 , C381 being (Element of D167);
reconsider D168 = C379 , D169 = C380 , D170 = C381 as (Polynomial of C377 , C378) by L722;
L815: ( C380 * C381 ) = ( D169 *' D170 ) by L722;
L816: ( C379 * C380 ) = ( D168 *' D169 ) by L722;
thus L817: ( ( C379 * C380 ) * C381 ) = ( ( D168 *' D169 ) *' D170 ) by L816 , L722
.= ( D168 *' ( D169 *' D170 ) ) by L320
.= ( C379 * ( C380 * C381 ) ) by L815 , L722;
end;
end;
L819:
now
let C382 being Ordinal;
let C383 being  right_zeroed  Abelian  add-associative  right_complementable  well-unital  distributive  associative non  trivial non  empty doubleLoopStr;
set D171 = ( Polynom-Ring (C382 , C383) );
let C384 , C385 being (Element of D171);
reconsider D172 = C384 as (Polynomial of C382 , C383) by L722;
assume L820: C385 = ( 1. D171 );
L821: ( 1. D171 ) = ( 1_ (C382 , C383) ) by L722;
thus L822: ( C384 * C385 ) = ( D172 *' ( 1_ (C382 , C383) ) ) by L821 , L820 , L722
.= C384 by L550;
thus L823: ( C385 * C384 ) = ( ( 1_ (C382 , C383) ) *' D172 ) by L820 , L821 , L722
.= C384 by L602;
end;
registration
let C386 being Ordinal;
let C387 being  right_zeroed  Abelian  add-associative  right_complementable  well-unital  distributive  associative non  trivial non  empty doubleLoopStr;
cluster ( Polynom-Ring (C386 , C387) ) ->  well-unital  right-distributive;
coherence
proof
set D173 = ( Polynom-Ring (C386 , C387) );
thus L824: D173 is  well-unital
proof
let C388 being (Element of D173);
thus L825: thesis by L819;
end;

let C389 , C390 , C391 being (Element of D173);
reconsider D174 = C389 , D175 = C390 , D176 = C391 as (Polynomial of C386 , C387) by L722;
L826: (( C389 * C390 ) = ( D174 *' D175 ) & ( C389 * C391 ) = ( D174 *' D176 )) by L722;
L827: ( C390 + C391 ) = ( D175 + D176 ) by L722;
thus L828: ( C389 * ( C390 + C391 ) ) = ( D174 *' ( D175 + D176 ) ) by L827 , L722
.= ( ( D174 *' D175 ) + ( D174 *' D176 ) ) by L289
.= ( ( C389 * C390 ) + ( C389 * C391 ) ) by L826 , L722;
end;
end;
theorem
L830: (for B251 being Ordinal holds (for B252 being  right_zeroed  Abelian  add-associative  right_complementable  right_unital  distributive  associative non  trivial non  empty doubleLoopStr holds ( 1. ( Polynom-Ring (B251 , B252) ) ) = ( 1_ (B251 , B252) ))) by L722;
