:: Fundamental {T}heorem of {A}rithmetic
::  by Artur Korni{\l}owicz and Piotr Rudnicki
::
:: Received February 13, 2004
:: Copyright (c) 2004-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, ORDINAL1, REAL_1, FINSEQ_1, VALUED_0, XBOOLE_0, NEWTON,
      ARYTM_3, RELAT_1, NAT_1, XXREAL_0, ARYTM_1, SUBSET_1, CARD_1, CARD_3,
      ORDINAL4, TARSKI, INT_2, FUNCT_1, FINSEQ_2, PRE_POLY, PBOOLE, FINSET_1,
      RVSUM_1, XCMPLX_0, UPROOTS, FUNCT_2, BINOP_2, SETWISEO, INT_1, FUNCOP_1,
      NAT_3;
 notations TARSKI, XBOOLE_0, SUBSET_1, FINSET_1, ORDINAL1, CARD_1, NUMBERS,
      XCMPLX_0, XXREAL_0, REAL_1, NAT_D, INT_2, RELAT_1, FUNCT_1, FUNCT_2,
      FINSEQ_1, FINSEQ_2,
      VALUED_0, SEQ_1, PBOOLE, RVSUM_1, NEWTON, WSIERP_1, TREES_4,
      UPROOTS, BINOP_2, FUNCOP_1, XXREAL_2, SETWOP_2, PRE_POLY, POLYNOM2;
 constructors BINOP_1, SETWISEO, NAT_D, FINSEQOP, FINSOP_1, NEWTON, WSIERP_1,
      POLYNOM2, UPROOTS, SEQ_1, BINOP_2, XXREAL_2, RELSET_1;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, FINSET_1, NUMBERS, XCMPLX_0,
      XXREAL_0, NAT_1, INT_1, BINOP_2, MEMBERED, NEWTON, VALUED_0, FINSEQ_1,
      XXREAL_2, CARD_1, UPROOTS, FUNCT_2, RELSET_1, ZFMISC_1, FINSEQ_2,
      PRE_POLY;
 requirements NUMERALS, SUBSET, ARITHM, REAL, BOOLE;
 definitions TARSKI, XBOOLE_0, INT_2, NAT_D, FINSEQ_1, FINSEQ_2, VALUED_0,
      PRE_POLY;
 theorems ORDINAL1, NEWTON, NAT_1, XCMPLX_1, INT_1, CARD_4, XREAL_0, RVSUM_1,
      INT_2, PEPIN, PBOOLE, FUNCT_1, CARD_2, PREPOWER, FINSEQ_1, TARSKI,
      XBOOLE_1, FUNCOP_1, WSIERP_1, XBOOLE_0, BAGORDER, FINSEQ_2, FINSEQ_3,
      FINSEQ_4, RELAT_1, UPROOTS, FINSOP_1, FUNCT_2, XREAL_1, XXREAL_0, NAT_D,
      VALUED_0, XXREAL_2, PARTFUN1, PRE_POLY, CARD_1;
 schemes NAT_1, PRE_CIRC, FINSEQ_1, FINSEQ_2, PBOOLE, CLASSES1;

begin
registration
cluster  natural-valued for FinSequence;
existence
proof
set D1 = the (FinSequence of ( NAT ));
take D1;
thus L1: thesis;
end;
end;
registration
let C1 being non  empty Nat;
let C2 being Nat;
cluster ( C1 |^ C2 ) -> non  empty;
coherence
proof
L3: C1 is Real by XREAL_0:def 1;
thus L4: thesis by L3 , CARD_4:3;
end;
end;
registration
cluster  -> non  empty for Prime;
coherence by INT_2:def 4;
end;
theorem
L7: (for B1 , B2 , B3 , B4 being Nat holds ((B1 divides B3 & B2 divides B4) implies ( B1 * B2 ) divides ( B3 * B4 )))
proof
let C3 , C4 , C5 , C6 being Nat;
given C7 being Nat such that
L8: C5 = ( C3 * C7 );

given C8 being Nat such that
L9: C6 = ( C4 * C8 );

take ( C7 * C8 );
thus L10: thesis by L8 , L9;
end;
theorem
L11: (for R1 being Nat holds (for R2 being Nat holds (1 < R1 implies R2 <= ( R1 |^ R2 ))))
proof
let R1 being Nat;
let R2 being Nat;
defpred S1[ Nat ] means $1 <= ( R1 |^ $1 );
assume L12: 1 < R1;
reconsider D2 = ( R1 - 1 ) as (Element of ( NAT )) by L12 , INT_1:5;
L13: (for B5 being Nat holds (S1[ B5 ] implies S1[ ( B5 + 1 ) ]))
proof
let C9 being Nat;
assume L14: S1[ C9 ];
L15: ( C9 + 1 ) <= ( ( R1 |^ C9 ) + 1 ) by L14 , XREAL_1:6;
L16:
now
set D3 = ( R1 |^ C9 );
assume L17: ( D3 + 1 ) > ( D3 * R1 );
L18: ( ( D3 * R1 ) - ( D3 + 1 ) ) < ( ( D3 + 1 ) - ( D3 + 1 ) ) by L17 , XREAL_1:14;
L19: ( ( ( D3 * D2 ) - 1 ) + 1 ) < ( ( 0 ) + 1 ) by L18 , XREAL_1:6;
L20: (D3 = ( 0 ) or D2 = ( 0 )) by L19 , NAT_1:13;
thus L21: contradiction by L20 , L12;
end;
L22: ( R1 |^ ( C9 + 1 ) ) = ( ( R1 |^ C9 ) * R1 ) by NEWTON:6;
thus L23: thesis by L22 , L15 , L16 , XXREAL_0:2;
end;
L24: S1[ ( 0 ) ];
L25: (for B6 being Nat holds S1[ B6 ]) from NAT_1:sch 2(L24 , L13);
thus L26: thesis by L25;
end;
theorem
L27: (for R1 being Nat holds (for R3 being Nat holds (R1 <> ( 0 ) implies R3 divides ( R3 |^ R1 ))))
proof
let R1 being Nat;
let R3 being Nat;
assume L28: R1 <> ( 0 );
consider C10 being Nat such that L29: R1 = ( C10 + 1 ) by L28 , NAT_1:6;
reconsider D4 = C10 as (Element of ( NAT )) by ORDINAL1:def 12;
L30: ( R3 |^ 1 ) divides ( R3 |^ ( D4 + 1 ) ) by NAT_1:12 , NEWTON:89;
thus L31: thesis by L30 , L29 , NEWTON:5;
end;
theorem
L32: (for B7 , B8 , B9 , B10 being Nat holds ((B7 < B8 & ( B9 |^ B8 ) divides B10) implies ( B9 |^ ( B7 + 1 ) ) divides B10))
proof
let C11 , C12 , C13 , C14 being Nat;
assume that
L33: C11 < C12
and
L34: ( C13 |^ C12 ) divides C14;
reconsider D5 = C11 , D6 = C12 , D7 = C13 as (Element of ( NAT )) by ORDINAL1:def 12;
L35: ( D5 + 1 ) <= D6 by L33 , NAT_1:13;
L36: ( D7 |^ ( D5 + 1 ) ) divides ( D7 |^ D6 ) by L35 , NEWTON:89;
thus L37: thesis by L36 , L34 , NAT_D:4;
end;
theorem
L38: (for R1 being Nat holds (for R2 being Nat holds (for R6 being Prime holds (R6 divides ( R1 |^ R2 ) implies R6 divides R1))))
proof
let R1 being Nat;
let R2 being Nat;
let R6 being Prime;
assume that
L39: R6 divides ( R1 |^ R2 )
and
L40: (not R6 divides R1);
reconsider D8 = R6 , D9 = R1 as (Element of ( NAT )) by ORDINAL1:def 12;
defpred S2[ Nat ] means D8 divides ( D9 |^ ( $1 + 1 ) );
L41: (for B11 being Nat holds ((B11 <> ( 0 ) & S2[ B11 ]) implies (ex B12 being Nat st (B12 < B11 & S2[ B12 ]))))
proof
let C15 being Nat;
assume that
L42: C15 <> ( 0 )
and
L43: S2[ C15 ];
L44: D8 divides ( ( D9 |^ C15 ) * D9 ) by L43 , NEWTON:6;
take ( C15 -' 1 );
L45: C15 >= ( ( 0 ) + 1 ) by L42 , NAT_1:13;
L46: ( C15 - 1 ) >= ( ( ( 0 ) + 1 ) - 1 ) by L45 , XREAL_1:13;
L47: ( C15 -' 1 ) = ( C15 - 1 ) by L46 , XREAL_0:def 2;
L48: ( C15 -' 1 ) < ( C15 - ( 0 ) ) by L47 , XREAL_1:15;
thus L49: ( C15 -' 1 ) < C15 by L48;
L50: ( ( C15 -' 1 ) + 1 ) = C15 by L45 , XREAL_1:235;
thus L51: thesis by L50 , L40 , L44 , NEWTON:80;
end;
L52:
now
assume L53: ( ( 0 ) + 1 ) > R2;
L54: R2 = ( 0 ) by L53 , NAT_1:13;
L55: D8 divides 1 by L54 , L39 , NEWTON:4;
L56: D8 = 1 by L55 , WSIERP_1:15;
thus L57: contradiction by L56 , INT_2:def 4;
end;
L58: R2 = ( ( R2 -' 1 ) + 1 ) by L52 , XREAL_1:235;
L59: (ex B13 being Nat st S2[ B13 ]) by L58 , L39;
L60: S2[ ( 0 ) ] from NAT_1:sch 7(L59 , L41);
thus L61: thesis by L60 , L40 , NEWTON:5;
end;
theorem
L62: (for R2 being Nat holds (for R6 being Prime holds (for B14 being Prime holds (B14 divides ( R6 |^ R2 ) implies B14 = R6))))
proof
let R2 being Nat;
let R6 being Prime;
let C16 being Prime;
assume L63: C16 divides ( R6 |^ R2 );
L64: (C16 <> 1 & C16 divides R6) by L63 , L38 , INT_2:def 4;
thus L65: thesis by L64 , INT_2:def 4;
end;
theorem
L66: (for R1 being Nat holds (for B15 being (FinSequence of ( NAT )) holds (R1 in ( rng B15 ) implies R1 divides ( Product B15 ))))
proof
let R1 being Nat;
defpred S3[ (FinSequence of ( NAT )) ] means (for B16 being Nat holds (B16 in ( rng $1 ) implies B16 divides ( Product $1 )));
L67: (for B17 being (FinSequence of ( NAT )) holds (for B18 being (Element of ( NAT )) holds (S3[ B17 ] implies S3[ ( B17 ^ <* B18 *> ) ])))
proof
let C17 being (FinSequence of ( NAT ));
let C18 being (Element of ( NAT ));
assume that
L68: S3[ C17 ];
set D10 = ( C17 ^ <* C18 *> );
L69: ( rng D10 ) = ( ( rng C17 ) \/ ( rng <* C18 *> ) ) by FINSEQ_1:31;
L70: ( Product D10 ) = ( ( Product C17 ) * C18 ) by RVSUM_1:96;
let C19 being Nat;
assume that
L71: C19 in ( rng D10 );
per cases  by L71 , L69 , XBOOLE_0:def 3;
suppose L72: C19 in ( rng C17 );

thus L73: thesis by L72 , L68 , L70 , NAT_D:9;
end;
suppose L74: C19 in ( rng <* C18 *> );

L75: C19 in { C18 } by L74 , FINSEQ_1:39;
L76: C19 = C18 by L75 , TARSKI:def 1;
thus L77: thesis by L76 , L70 , NAT_D:9;
end;
end;
L79: S3[ (( <*> ( NAT ) ) qua (FinSequence of ( NAT ))) ];
L80: (for B19 being (FinSequence of ( NAT )) holds S3[ B19 ]) from FINSEQ_2:sch 2(L79 , L67);
thus L81: thesis by L80;
end;
theorem
L82: (for R6 being Prime holds (for B20 being (FinSequence of ( SetPrimes )) holds (R6 divides ( Product B20 ) implies R6 in ( rng B20 ))))
proof
let R6 being Prime;
defpred S4[ (FinSequence of ( SetPrimes )) ] means (for B21 being Prime holds (B21 divides ( Product $1 ) implies B21 in ( rng $1 )));
L83:
now
let C20 being (FinSequence of ( SetPrimes ));
let C21 being (Element of ( SetPrimes ));
set D11 = ( C20 ^ <* C21 *> );
assume L84: S4[ C20 ];
thus L85: S4[ D11 ]
proof
reconsider D12 = C21 as Nat;
reconsider D13 = C20 as (FinSequence of ( NAT ));
let C22 being Prime;
assume L86: C22 divides ( Product D11 );
L87: C22 divides ( ( Product D13 ) * C21 ) by L86 , RVSUM_1:96;
per cases  by L87 , NEWTON:80;
suppose L88: C22 divides ( Product C20 );

L89: ( rng C20 ) c= ( rng D11 ) by FINSEQ_1:29;
L90: C22 in ( rng C20 ) by L84 , L88;
thus L91: thesis by L90 , L89;
end;
suppose L92: C22 divides D12;

L93: D12 is  prime by NEWTON:def 6;
L94: (C22 = 1 or C22 = C21) by L93 , L92 , INT_2:def 4;
L95: C22 in { C21 } by L94 , INT_2:def 4 , TARSKI:def 1;
L96: C22 in ( rng <* C21 *> ) by L95 , FINSEQ_1:38;
L97: ( rng <* C21 *> ) c= ( rng D11 ) by FINSEQ_1:30;
thus L98: thesis by L97 , L96;
end;
end;

end;
L86: S4[ (( <*> ( SetPrimes ) ) qua (FinSequence of ( SetPrimes ))) ]
proof
let C23 being Prime;
assume L87: C23 divides ( Product (( <*> ( SetPrimes ) ) qua (FinSequence of ( SetPrimes ))) );
L88: C23 <= 1 by L87 , NAT_D:7 , RVSUM_1:94;
thus L89: thesis by L88 , INT_2:def 4;
end;
L90: (for B22 being (FinSequence of ( SetPrimes )) holds S4[ B22 ]) from FINSEQ_2:sch 2(L86 , L83);
thus L91: thesis by L90;
end;
definition
let C24 being  real-valued FinSequence;
let C25 being Nat;
func C24 |^ C25 -> FinSequence means 
:L92: (( len it ) = ( len C24 ) & (for B23 being set holds (B23 in ( dom it ) implies ( it . B23 ) = ( ( C24 . B23 ) |^ C25 ))));
existence
proof
deffunc H1(Nat) = ( ( C24 . $1 ) |^ C25 );
consider C26 being FinSequence such that L93: ( len C26 ) = ( len C24 ) and L94: (for B24 being Nat holds (B24 in ( dom C26 ) implies ( C26 . B24 ) = H1(B24))) from FINSEQ_1:sch 2;
take C26;
thus L95: ( len C26 ) = ( len C24 ) by L93;
let C27 being set;
assume L96: C27 in ( dom C26 );
thus L97: thesis by L96 , L94;
end;
uniqueness
proof
let C28 , C29 being FinSequence;
assume that
L98: ( len C28 ) = ( len C24 )
and
L99: (for B25 being set holds (B25 in ( dom C28 ) implies ( C28 . B25 ) = ( ( C24 . B25 ) |^ C25 )))
and
L100: ( len C29 ) = ( len C24 )
and
L101: (for B26 being set holds (B26 in ( dom C29 ) implies ( C29 . B26 ) = ( ( C24 . B26 ) |^ C25 )));
L102: (( dom C28 ) = ( Seg ( len C28 ) ) & ( dom C29 ) = ( Seg ( len C29 ) )) by FINSEQ_1:def 3;
L103: (for B27 being Nat holds (B27 in ( dom C28 ) implies ( C28 . B27 ) = ( C29 . B27 )))
proof
let C30 being Nat;
assume that
L104: C30 in ( dom C28 );
thus L105: ( C28 . C30 ) = ( ( C24 . C30 ) |^ C25 ) by L99 , L104
.= ( C29 . C30 ) by L98 , L100 , L101 , L102 , L104;
end;
thus L106: thesis by L103 , L98 , L100 , L102 , FINSEQ_1:13;
end;
end;
registration
let C31 being  real-valued FinSequence;
let C32 being Nat;
cluster ( C31 |^ C32 ) ->  real-valued;
coherence
proof
let C33 being set;
set D14 = ( C31 |^ C32 );
assume L108: C33 in ( dom D14 );
L109: ( ( C31 |^ C32 ) . C33 ) = ( ( C31 . C33 ) |^ C32 ) by L108 , L92;
thus L110: thesis by L109;
end;
end;
registration
let C34 being  natural-valued FinSequence;
let C35 being Nat;
cluster ( C34 |^ C35 ) ->  natural-valued;
coherence
proof
let C36 being set;
set D15 = ( C34 |^ C35 );
assume L112: C36 in ( dom D15 );
L113: ( ( C34 |^ C35 ) . C36 ) = ( ( C34 . C36 ) |^ C35 ) by L112 , L92;
thus L114: thesis by L113;
end;
end;
definition
let C37 being (FinSequence of ( REAL ));
let C38 being Nat;
redefine func C37 |^ C38 -> (FinSequence of ( REAL ));

coherence
proof
thus L116: ( rng ( C37 |^ C38 ) ) c= ( REAL );
end;
end;
definition
let C39 being (FinSequence of ( NAT ));
let C40 being Nat;
redefine func C39 |^ C40 -> (FinSequence of ( NAT ));

coherence
proof
thus L118: ( rng ( C39 |^ C40 ) ) c= ( NAT ) by VALUED_0:def 6;
end;
end;
theorem
L120: (for R5 being (FinSequence of ( REAL )) holds ( R5 |^ ( 0 ) ) = ( ( len R5 ) |-> 1 ))
proof
let R5 being (FinSequence of ( REAL ));
L121: ( len ( R5 |^ ( 0 ) ) ) = ( len R5 ) by L92;
L122: (for B28 being Nat holds ((1 <= B28 & B28 <= ( len ( R5 |^ ( 0 ) ) )) implies ( ( R5 |^ ( 0 ) ) . B28 ) = ( ( ( len R5 ) |-> 1 ) . B28 )))
proof
let C41 being Nat;
assume L123: (1 <= C41 & C41 <= ( len ( R5 |^ ( 0 ) ) ));
L124: C41 in ( dom ( R5 |^ ( 0 ) ) ) by L123 , FINSEQ_3:25;
L125: C41 in ( Seg ( len R5 ) ) by L124 , L121 , L123;
thus L126: ( ( R5 |^ ( 0 ) ) . C41 ) = ( ( R5 . C41 ) |^ ( 0 ) ) by L124 , L92
.= 1 by NEWTON:4
.= ( ( ( len R5 ) |-> 1 ) . C41 ) by L125 , FUNCOP_1:7;
end;
L127: ( len ( ( len R5 ) |-> 1 ) ) = ( len R5 ) by CARD_1:def 7;
thus L128: thesis by L127 , L121 , L122 , FINSEQ_1:14;
end;
theorem
L129: (for R5 being (FinSequence of ( REAL )) holds ( R5 |^ 1 ) = R5)
proof
let R5 being (FinSequence of ( REAL ));
L130: (for B29 being Nat holds ((1 <= B29 & B29 <= ( len ( R5 |^ 1 ) )) implies ( ( R5 |^ 1 ) . B29 ) = ( R5 . B29 )))
proof
let C42 being Nat;
assume L131: (1 <= C42 & C42 <= ( len ( R5 |^ 1 ) ));
L132: C42 in ( dom ( R5 |^ 1 ) ) by L131 , FINSEQ_3:25;
thus L133: ( ( R5 |^ 1 ) . C42 ) = ( ( R5 . C42 ) |^ 1 ) by L132 , L92
.= ( R5 . C42 ) by NEWTON:5;
end;
L134: ( len ( R5 |^ 1 ) ) = ( len R5 ) by L92;
thus L135: thesis by L134 , L130 , FINSEQ_1:14;
end;
theorem
L136: (for R1 being Nat holds ( ( <*> ( REAL ) ) |^ R1 ) = ( <*> ( REAL ) ))
proof
let R1 being Nat;
L137: ( len ( ( <*> ( REAL ) ) |^ R1 ) ) = ( len ( <*> ( REAL ) ) ) by L92
.= ( 0 );
thus L138: thesis by L137;
end;
theorem
L139: (for R1 being Nat holds (for R4 being Real holds ( <* R4 *> |^ R1 ) = <* ( R4 |^ R1 ) *>))
proof
let R1 being Nat;
let R4 being Real;
L140: ( len ( <* R4 *> |^ R1 ) ) = ( len <* R4 *> ) by L92
.= 1 by FINSEQ_1:40;
L141: ( ( 0 ) + 1 ) in ( Seg ( ( 0 ) + 1 ) );
L142: 1 in ( dom ( <* R4 *> |^ R1 ) ) by L141 , L140 , FINSEQ_1:def 3;
L143: ( ( <* R4 *> |^ R1 ) . 1 ) = ( ( <* R4 *> . 1 ) |^ R1 ) by L142 , L92
.= ( R4 |^ R1 ) by FINSEQ_1:40;
thus L144: thesis by L143 , L140 , FINSEQ_1:40;
end;
theorem
L145: (for R1 being Nat holds (for R4 being Real holds (for R5 being (FinSequence of ( REAL )) holds ( ( R5 ^ <* R4 *> ) |^ R1 ) = ( ( R5 |^ R1 ) ^ ( <* R4 *> |^ R1 ) ))))
proof
let R1 being Nat;
let R4 being Real;
let R5 being (FinSequence of ( REAL ));
L146: ( len ( R5 |^ R1 ) ) = ( len R5 ) by L92;
L147: ( len ( ( R5 ^ <* R4 *> ) |^ R1 ) ) = ( len ( R5 ^ <* R4 *> ) ) by L92
.= ( ( len R5 ) + ( len <* R4 *> ) ) by FINSEQ_1:22
.= ( ( len R5 ) + 1 ) by FINSEQ_1:40;
L148: ( dom ( ( R5 ^ <* R4 *> ) |^ R1 ) ) = ( Seg ( ( len R5 ) + 1 ) ) by L147 , FINSEQ_1:def 3;
L149:
now
let C43 being Nat;
assume that
L150: C43 in ( dom ( ( R5 ^ <* R4 *> ) |^ R1 ) );
L151: 1 <= C43 by L148 , L150 , FINSEQ_1:1;
L152: C43 <= ( ( len R5 ) + 1 ) by L148 , L150 , FINSEQ_1:1;
per cases  by L152 , XXREAL_0:1;
suppose L153: C43 < ( ( len R5 ) + 1 );

L154: C43 <= ( len R5 ) by L153 , NAT_1:13;
L155: C43 in ( dom R5 ) by L154 , L151 , FINSEQ_3:25;
L156: C43 in ( dom ( R5 |^ R1 ) ) by L146 , L151 , L154 , FINSEQ_3:25;
thus L157: ( ( ( R5 ^ <* R4 *> ) |^ R1 ) . C43 ) = ( ( ( R5 ^ <* R4 *> ) . C43 ) |^ R1 ) by L150 , L92
.= ( ( R5 . C43 ) |^ R1 ) by L155 , FINSEQ_1:def 7
.= ( ( R5 |^ R1 ) . C43 ) by L156 , L92
.= ( ( ( R5 |^ R1 ) ^ ( <* R4 *> |^ R1 ) ) . C43 ) by L156 , FINSEQ_1:def 7;
end;
suppose L158: C43 = ( ( len R5 ) + 1 );

thus L159: ( ( ( R5 ^ <* R4 *> ) |^ R1 ) . C43 ) = ( ( ( R5 ^ <* R4 *> ) . C43 ) |^ R1 ) by L150 , L92
.= ( R4 |^ R1 ) by L158 , FINSEQ_1:42
.= ( ( ( R5 |^ R1 ) ^ <* ( R4 |^ R1 ) *> ) . C43 ) by L146 , L158 , FINSEQ_1:42
.= ( ( ( R5 |^ R1 ) ^ ( <* R4 *> |^ R1 ) ) . C43 ) by L139;
end;
end;
L161: ( len ( ( R5 |^ R1 ) ^ ( <* R4 *> |^ R1 ) ) ) = ( ( len ( R5 |^ R1 ) ) + ( len ( <* R4 *> |^ R1 ) ) ) by FINSEQ_1:22
.= ( ( len R5 ) + ( len ( <* R4 *> |^ R1 ) ) ) by L92
.= ( ( len R5 ) + ( len <* ( R4 |^ R1 ) *> ) ) by L139
.= ( ( len R5 ) + 1 ) by FINSEQ_1:40;
thus L162: thesis by L161 , L147 , L149 , FINSEQ_2:9;
end;
theorem
L163: (for R2 being Nat holds (for R5 being (FinSequence of ( REAL )) holds ( Product ( R5 |^ ( R2 + 1 ) ) ) = ( ( Product ( R5 |^ R2 ) ) * ( Product R5 ) )))
proof
let R2 being Nat;
let R5 being (FinSequence of ( REAL ));
defpred S5[ (FinSequence of ( REAL )) ] means (for B30 being Nat holds ( Product ( $1 |^ ( B30 + 1 ) ) ) = ( ( Product ( $1 |^ B30 ) ) * ( Product $1 ) ));
L164:
now
let C44 being (FinSequence of ( REAL ));
let C45 being (Element of ( REAL ));
assume that
L165: S5[ C44 ];
thus L166: S5[ ( C44 ^ <* C45 *> ) ]
proof
set D16 = ( C44 ^ <* C45 *> );
let C46 being Nat;
L167: ( D16 |^ ( C46 + 1 ) ) = ( ( C44 |^ ( C46 + 1 ) ) ^ ( <* C45 *> |^ ( C46 + 1 ) ) ) by L145;
thus L168: ( Product ( D16 |^ ( C46 + 1 ) ) ) = ( ( Product ( C44 |^ ( C46 + 1 ) ) ) * ( Product ( <* C45 *> |^ ( C46 + 1 ) ) ) ) by L167 , RVSUM_1:97
.= ( ( ( Product ( C44 |^ C46 ) ) * ( Product C44 ) ) * ( Product ( <* C45 *> |^ ( C46 + 1 ) ) ) ) by L165
.= ( ( ( Product ( C44 |^ C46 ) ) * ( Product C44 ) ) * ( Product <* ( C45 |^ ( C46 + 1 ) ) *> ) ) by L139
.= ( ( ( Product ( C44 |^ C46 ) ) * ( Product C44 ) ) * ( C45 |^ ( C46 + 1 ) ) ) by RVSUM_1:95
.= ( ( ( Product ( C44 |^ C46 ) ) * ( Product C44 ) ) * ( ( C45 |^ C46 ) * C45 ) ) by NEWTON:6
.= ( ( ( ( Product ( C44 |^ C46 ) ) * ( C45 |^ C46 ) ) * C45 ) * ( Product C44 ) )
.= ( ( ( Product ( ( C44 |^ C46 ) ^ <* ( C45 |^ C46 ) *> ) ) * C45 ) * ( Product C44 ) ) by RVSUM_1:96
.= ( ( ( Product ( ( C44 |^ C46 ) ^ ( <* C45 *> |^ C46 ) ) ) * C45 ) * ( Product C44 ) ) by L139
.= ( ( ( Product ( D16 |^ C46 ) ) * C45 ) * ( Product C44 ) ) by L145
.= ( ( Product ( D16 |^ C46 ) ) * ( ( Product C44 ) * C45 ) )
.= ( ( Product ( D16 |^ C46 ) ) * ( Product D16 ) ) by RVSUM_1:96;
end;

end;
L167: S5[ ( <*> ( REAL ) ) ]
proof
set D17 = ( <*> ( REAL ) );
let C47 being Nat;
thus L168: ( Product ( D17 |^ ( C47 + 1 ) ) ) = 1 by L136 , RVSUM_1:94
.= ( ( Product ( D17 |^ C47 ) ) * ( Product D17 ) ) by L136 , RVSUM_1:94;
end;
L169: (for B31 being (FinSequence of ( REAL )) holds S5[ B31 ]) from FINSEQ_2:sch 2(L167 , L164);
thus L170: thesis by L169;
end;
theorem
L171: (for R1 being Nat holds (for R5 being (FinSequence of ( REAL )) holds ( Product ( R5 |^ R1 ) ) = ( ( Product R5 ) |^ R1 )))
proof
let R1 being Nat;
let R5 being (FinSequence of ( REAL ));
defpred S6[ Nat ] means ( Product ( R5 |^ $1 ) ) = ( ( Product R5 ) |^ $1 );
L172: (for R2 being Nat holds (S6[ R2 ] implies S6[ ( R2 + 1 ) ]))
proof
let R2 being Nat;
assume L173: S6[ R2 ];
thus L174: ( Product ( R5 |^ ( R2 + 1 ) ) ) = ( ( Product ( R5 |^ R2 ) ) * ( Product R5 ) ) by L163
.= ( ( Product R5 ) |^ ( R2 + 1 ) ) by L173 , NEWTON:6;
end;
L175: ( Product ( R5 |^ ( 0 ) ) ) = ( Product ( ( len R5 ) |-> 1 ) ) by L120
.= 1 by RVSUM_1:102
.= ( ( Product R5 ) |^ ( 0 ) ) by NEWTON:4;
L176: S6[ ( 0 ) ] by L175;
L177: (for R2 being Nat holds S6[ R2 ]) from NAT_1:sch 2(L176 , L172);
thus L178: thesis by L177;
end;
begin
registration
let C48 being set;
cluster  natural-valued  finite-support for (ManySortedSet of C48);
existence
proof
set D18 = the  natural-valued  finite-support (ManySortedSet of C48);
L179: D18 = D18;
thus L180: thesis by L179;
end;
end;
definition
let C49 being set;
let C50 being  real-valued (ManySortedSet of C49);
let C51 being Nat;
func C51 * C50 -> (ManySortedSet of C49) means 
:L182: (for B32 being set holds ( it . B32 ) = ( C51 * ( C50 . B32 ) ));
existence
proof
deffunc H2(set) = ( C51 * ( C50 . $1 ) );
consider C52 being (ManySortedSet of C49) such that L183: (for B33 being set holds (B33 in C49 implies ( C52 . B33 ) = H2(B33))) from PBOOLE:sch 4;
take C52;
let C53 being set;
per cases ;
suppose L184: C53 in C49;

thus L185: thesis by L184 , L183;
end;
suppose L186: (not C53 in C49);

L187: ( dom C50 ) = C49 by PARTFUN1:def 2;
L188: ( dom C52 ) = C49 by PARTFUN1:def 2;
thus L189: ( C52 . C53 ) = ( C51 * ( 0 ) ) by L188 , L186 , FUNCT_1:def 2
.= ( C51 * ( C50 . C53 ) ) by L186 , L187 , FUNCT_1:def 2;
end;
end;
uniqueness
proof
let C54 , C55 being (ManySortedSet of C49);
assume that
L191: (for B34 being set holds ( C54 . B34 ) = ( C51 * ( C50 . B34 ) ))
and
L192: (for B35 being set holds ( C55 . B35 ) = ( C51 * ( C50 . B35 ) ));
L193: (for B36 being set holds (B36 in C49 implies ( C54 . B36 ) = ( C55 . B36 )))
proof
let C56 being set;
assume L194: C56 in C49;
thus L195: ( C54 . C56 ) = ( C51 * ( C50 . C56 ) ) by L191
.= ( C55 . C56 ) by L192;
end;
thus L196: thesis by L193 , PBOOLE:3;
end;
end;
registration
let C57 being set;
let C58 being  real-valued (ManySortedSet of C57);
let C59 being Nat;
cluster ( C59 * C58 ) ->  real-valued;
coherence
proof
let C60 being set;
assume L198: C60 in ( dom ( C59 * C58 ) );
L199: ( ( C59 * C58 ) . C60 ) = ( C59 * ( C58 . C60 ) ) by L182;
thus L200: thesis by L199;
end;
end;
registration
let C61 being set;
let C62 being  natural-valued (ManySortedSet of C61);
let C63 being Nat;
cluster ( C63 * C62 ) ->  natural-valued;
coherence
proof
let C64 being set;
assume L202: C64 in ( dom ( C63 * C62 ) );
L203: ( ( C63 * C62 ) . C64 ) = ( C63 * ( C62 . C64 ) ) by L182;
thus L204: thesis by L203;
end;
end;
registration
let C65 being set;
let C66 being  real-valued (ManySortedSet of C65);
cluster ( support ( ( 0 ) * C66 ) ) ->  empty;
coherence
proof
assume L206: ( support ( ( 0 ) * C66 ) ) is non  empty;
consider C67 being set such that L207: C67 in ( support ( ( 0 ) * C66 ) ) by L206 , XBOOLE_0:def 1;
L208: ( ( ( 0 ) * C66 ) . C67 ) <> ( 0 ) by L207 , PRE_POLY:def 7;
L209: ( ( 0 ) * ( C66 . C67 ) ) <> ( 0 ) by L208 , L182;
thus L210: thesis by L209;
end;
end;
theorem
L212: (for R1 being Nat holds (for B37 being set holds (for B38 being  real-valued (ManySortedSet of B37) holds (R1 <> ( 0 ) implies ( support B38 ) = ( support ( R1 * B38 ) )))))
proof
let R1 being Nat;
let C68 being set;
let C69 being  real-valued (ManySortedSet of C68);
assume that
L213: R1 <> ( 0 );
thus L214:now
let C70 being set;
assume L215: C70 in ( support C69 );
L216: ( C69 . C70 ) <> ( 0 ) by L215 , PRE_POLY:def 7;
L217: ( R1 * ( C69 . C70 ) ) <> ( 0 ) by L216 , L213;
L218: ( ( R1 * C69 ) . C70 ) <> ( 0 ) by L217 , L182;
thus L219: C70 in ( support ( R1 * C69 ) ) by L218 , PRE_POLY:def 7;
end;
let C71 being set;
assume L220: C71 in ( support ( R1 * C69 ) );
L221: ( ( R1 * C69 ) . C71 ) <> ( 0 ) by L220 , PRE_POLY:def 7;
L222: ( R1 * ( C69 . C71 ) ) <> ( 0 ) by L221 , L182;
L223: ( C69 . C71 ) <> ( 0 ) by L222;
thus L224: thesis by L223 , PRE_POLY:def 7;
end;
registration
let C72 being set;
let C73 being  real-valued  finite-support (ManySortedSet of C72);
let C74 being Nat;
cluster ( C74 * C73 ) ->  finite-support;
coherence
proof
per cases ;
suppose L225: C74 = ( 0 );

thus L226: ( support ( C74 * C73 ) ) is  finite by L225;
end;
suppose L227: C74 <> ( 0 );

L228: ( support ( C74 * C73 ) ) = ( support C73 ) by L227 , L212;
thus L229: ( support ( C74 * C73 ) ) is  finite by L228;
end;
end;
end;
definition
let C75 being set;
let C76 , C77 being  real-valued (ManySortedSet of C75);
func min (C76 , C77) -> (ManySortedSet of C75) means 
:L232: (for B39 being set holds ((( C76 . B39 ) <= ( C77 . B39 ) implies ( it . B39 ) = ( C76 . B39 )) & (( C76 . B39 ) > ( C77 . B39 ) implies ( it . B39 ) = ( C77 . B39 ))));
existence
proof
deffunc H3(set) = ( C77 . $1 );
deffunc H4(set) = ( C76 . $1 );
defpred S7[ set ] means ( C76 . $1 ) <= ( C77 . $1 );
consider C78 being (ManySortedSet of C75) such that L233: (for B40 being (Element of C75) holds (B40 in C75 implies ((S7[ B40 ] implies ( C78 . B40 ) = H4(B40)) & ((not S7[ B40 ]) implies ( C78 . B40 ) = H3(B40))))) from PRE_CIRC:sch 2;
take C78;
let C79 being set;
per cases ;
suppose L234: C79 in C75;

thus L235: thesis by L234 , L233;
end;
suppose L236: (not C79 in C75);

L237: (not C79 in ( dom C78 )) by L236 , PARTFUN1:def 2;
L238: ( C78 . C79 ) = ( 0 ) by L237 , FUNCT_1:def 2;
L239: ((not C79 in ( dom C76 )) & (not C79 in ( dom C77 ))) by L236 , PARTFUN1:def 2;
thus L240: thesis by L239 , L238 , FUNCT_1:def 2;
end;
end;
uniqueness
proof
let C80 , C81 being (ManySortedSet of C75);
assume that
L242: (for B41 being set holds ((( C76 . B41 ) <= ( C77 . B41 ) implies ( C80 . B41 ) = ( C76 . B41 )) & (( C76 . B41 ) > ( C77 . B41 ) implies ( C80 . B41 ) = ( C77 . B41 ))))
and
L243: (for B42 being set holds ((( C76 . B42 ) <= ( C77 . B42 ) implies ( C81 . B42 ) = ( C76 . B42 )) & (( C76 . B42 ) > ( C77 . B42 ) implies ( C81 . B42 ) = ( C77 . B42 ))));
L244:
now
let C82 being set;
assume L245: C82 in C75;
per cases ;
suppose L246: ( C76 . C82 ) <= ( C77 . C82 );

thus L247: ( C80 . C82 ) = ( C76 . C82 ) by L246 , L242
.= ( C81 . C82 ) by L243 , L246;
end;
suppose L248: ( C76 . C82 ) > ( C77 . C82 );

thus L249: ( C80 . C82 ) = ( C77 . C82 ) by L248 , L242
.= ( C81 . C82 ) by L243 , L248;
end;
end;
thus L251: thesis by L244 , PBOOLE:3;
end;
end;
registration
let C83 being set;
let C84 , C85 being  real-valued (ManySortedSet of C83);
cluster ( min (C84 , C85) ) ->  real-valued;
coherence
proof
let C86 being set;
set D19 = ( min (C84 , C85) );
assume L253: C86 in ( dom D19 );
L254: (( C84 . C86 ) <= ( C85 . C86 ) or ( C84 . C86 ) > ( C85 . C86 ));
thus L255: thesis by L254 , L232;
end;
end;
registration
let C87 being set;
let C88 , C89 being  natural-valued (ManySortedSet of C87);
cluster ( min (C88 , C89) ) ->  natural-valued;
coherence
proof
let C90 being set;
set D20 = ( min (C88 , C89) );
assume L257: C90 in ( dom D20 );
L258: (( C88 . C90 ) <= ( C89 . C90 ) or ( C88 . C90 ) > ( C89 . C90 ));
thus L259: thesis by L258 , L232;
end;
end;
theorem
L261: (for B43 being set holds (for B44 , B45 being  real-valued  finite-support (ManySortedSet of B43) holds ( support ( min (B44 , B45) ) ) c= ( ( support B44 ) \/ ( support B45 ) )))
proof
let C91 being set;
let C92 , C93 being  real-valued  finite-support (ManySortedSet of C91);
set D21 = ( min (C92 , C93) );
let C94 being set;
assume L262: C94 in ( support D21 );
L263: ( D21 . C94 ) <> ( 0 ) by L262 , PRE_POLY:def 7;
L264: (( D21 . C94 ) = ( C92 . C94 ) or ( D21 . C94 ) = ( C93 . C94 )) by L232;
L265: (C94 in ( support C92 ) or C94 in ( support C93 )) by L264 , L263 , PRE_POLY:def 7;
thus L266: thesis by L265 , XBOOLE_0:def 3;
end;
registration
let C95 being set;
let C96 , C97 being  real-valued  finite-support (ManySortedSet of C95);
cluster ( min (C96 , C97) ) ->  finite-support;
coherence
proof
L267: ( support ( min (C96 , C97) ) ) c= ( ( support C96 ) \/ ( support C97 ) ) by L261;
thus L268: ( support ( min (C96 , C97) ) ) is  finite by L267;
end;
end;
definition
let C98 being set;
let C99 , C100 being  real-valued (ManySortedSet of C98);
func max (C99 , C100) -> (ManySortedSet of C98) means 
:L270: (for B46 being set holds ((( C99 . B46 ) <= ( C100 . B46 ) implies ( it . B46 ) = ( C100 . B46 )) & (( C99 . B46 ) > ( C100 . B46 ) implies ( it . B46 ) = ( C99 . B46 ))));
existence
proof
deffunc H5(set) = ( C99 . $1 );
deffunc H6(set) = ( C100 . $1 );
defpred S8[ set ] means ( C99 . $1 ) <= ( C100 . $1 );
consider C101 being (ManySortedSet of C98) such that L271: (for B47 being (Element of C98) holds (B47 in C98 implies ((S8[ B47 ] implies ( C101 . B47 ) = H6(B47)) & ((not S8[ B47 ]) implies ( C101 . B47 ) = H5(B47))))) from PRE_CIRC:sch 2;
take C101;
let C102 being set;
per cases ;
suppose L272: C102 in C98;

thus L273: thesis by L272 , L271;
end;
suppose L274: (not C102 in C98);

L275: (not C102 in ( dom C101 )) by L274 , PARTFUN1:def 2;
L276: ( C101 . C102 ) = ( 0 ) by L275 , FUNCT_1:def 2;
L277: ((not C102 in ( dom C99 )) & (not C102 in ( dom C100 ))) by L274 , PARTFUN1:def 2;
thus L278: thesis by L277 , L276 , FUNCT_1:def 2;
end;
end;
uniqueness
proof
let C103 , C104 being (ManySortedSet of C98);
assume that
L280: (for B48 being set holds ((( C99 . B48 ) <= ( C100 . B48 ) implies ( C103 . B48 ) = ( C100 . B48 )) & (( C99 . B48 ) > ( C100 . B48 ) implies ( C103 . B48 ) = ( C99 . B48 ))))
and
L281: (for B49 being set holds ((( C99 . B49 ) <= ( C100 . B49 ) implies ( C104 . B49 ) = ( C100 . B49 )) & (( C99 . B49 ) > ( C100 . B49 ) implies ( C104 . B49 ) = ( C99 . B49 ))));
L282:
now
let C105 being set;
assume L283: C105 in C98;
per cases ;
suppose L284: ( C99 . C105 ) <= ( C100 . C105 );

thus L285: ( C103 . C105 ) = ( C100 . C105 ) by L284 , L280
.= ( C104 . C105 ) by L281 , L284;
end;
suppose L286: ( C99 . C105 ) > ( C100 . C105 );

thus L287: ( C103 . C105 ) = ( C99 . C105 ) by L286 , L280
.= ( C104 . C105 ) by L281 , L286;
end;
end;
thus L289: thesis by L282 , PBOOLE:3;
end;
end;
registration
let C106 being set;
let C107 , C108 being  real-valued (ManySortedSet of C106);
cluster ( max (C107 , C108) ) ->  real-valued;
coherence
proof
let C109 being set;
set D22 = ( max (C107 , C108) );
assume L291: C109 in ( dom D22 );
L292: (( C107 . C109 ) <= ( C108 . C109 ) or ( C107 . C109 ) > ( C108 . C109 ));
thus L293: thesis by L292 , L270;
end;
end;
registration
let C110 being set;
let C111 , C112 being  natural-valued (ManySortedSet of C110);
cluster ( max (C111 , C112) ) ->  natural-valued;
coherence
proof
let C113 being set;
set D23 = ( max (C111 , C112) );
assume L295: C113 in ( dom D23 );
L296: (( C111 . C113 ) <= ( C112 . C113 ) or ( C111 . C113 ) > ( C112 . C113 ));
thus L297: thesis by L296 , L270;
end;
end;
theorem
L299: (for B50 being set holds (for B51 , B52 being  real-valued  finite-support (ManySortedSet of B50) holds ( support ( max (B51 , B52) ) ) c= ( ( support B51 ) \/ ( support B52 ) )))
proof
let C114 being set;
let C115 , C116 being  real-valued  finite-support (ManySortedSet of C114);
set D24 = ( max (C115 , C116) );
let C117 being set;
assume L300: C117 in ( support D24 );
L301: ( D24 . C117 ) <> ( 0 ) by L300 , PRE_POLY:def 7;
L302: (( D24 . C117 ) = ( C115 . C117 ) or ( D24 . C117 ) = ( C116 . C117 )) by L270;
L303: (C117 in ( support C115 ) or C117 in ( support C116 )) by L302 , L301 , PRE_POLY:def 7;
thus L304: thesis by L303 , XBOOLE_0:def 3;
end;
registration
let C118 being set;
let C119 , C120 being  real-valued  finite-support (ManySortedSet of C118);
cluster ( max (C119 , C120) ) ->  finite-support;
coherence
proof
L305: ( support ( max (C119 , C120) ) ) c= ( ( support C119 ) \/ ( support C120 ) ) by L299;
thus L306: ( support ( max (C119 , C120) ) ) is  finite by L305;
end;
end;
registration
let C121 being set;
cluster  finite-support  complex-yielding for (ManySortedSet of C121);
existence
proof
set D25 = the  finite-support  natural-valued (ManySortedSet of C121);
L308: D25 is  complex-yielding;
thus L309: thesis by L308;
end;
end;
definition
let C122 being set;
let C123 being  finite-support  complex-yielding (ManySortedSet of C122);
func Product C123 ->  complex number means 
:L311: (ex B53 being (FinSequence of ( COMPLEX )) st (it = ( Product B53 ) & B53 = ( C123 * ( canFS ( support C123 ) ) )));
existence
proof
set D26 = ( canFS ( support C123 ) );
set D27 = ( C123 * D26 );
L312: ( rng D27 ) c= ( COMPLEX ) by VALUED_0:def 1;
L313: (( support C123 ) c= ( dom C123 ) & ( rng D26 ) = ( support C123 )) by FUNCT_2:def 3 , PRE_POLY:37;
L314: ( dom D27 ) = ( dom D26 ) by L313 , RELAT_1:27;
L315: ( dom D27 ) = ( Seg ( len D26 ) ) by L314 , FINSEQ_1:def 3;
L316: D27 is FinSequence by L315 , FINSEQ_1:def 2;
reconsider D28 = D27 as (FinSequence of ( COMPLEX )) by L316 , L312 , FINSEQ_1:def 4;
take ( Product D28 );
thus L317: thesis;
end;
uniqueness;
end;
definition
let C124 being set;
let C125 being (bag of C124);
redefine func Product C125 -> (Element of ( NAT ));

coherence
proof
consider C126 being (FinSequence of ( COMPLEX )) such that L319: ( Product C125 ) = ( Product C126 ) and L320: C126 = ( C125 * ( canFS ( support C125 ) ) ) by L311;
L321: (( rng C125 ) c= ( NAT ) & ( rng C126 ) c= ( rng C125 )) by L320 , RELAT_1:26 , VALUED_0:def 6;
L322: ( rng C126 ) c= ( NAT ) by L321 , XBOOLE_1:1;
reconsider D29 = C126 as (FinSequence of ( NAT )) by L322 , FINSEQ_1:def 4;
L323: ( Product D29 ) in ( NAT );
thus L324: thesis by L323 , L319;
end;
end;
theorem
L326: (for B54 being set holds (for B55 , B56 being (bag of B54) holds (( support B55 ) misses ( support B56 ) implies ( Product ( B55 + B56 ) ) = ( ( Product B55 ) * ( Product B56 ) ))))
proof
let C127 being set;
let C128 , C129 being (bag of C127);
set D30 = ( C128 + C129 );
set D31 = ( Product C128 );
set D32 = ( Product C129 );
set D33 = ( Product D30 );
set D34 = ( support ( C128 + C129 ) );
set D35 = ( support C128 );
set D36 = ( support C129 );
set D37 = ( canFS ( support C128 ) );
set D38 = ( canFS ( support C129 ) );
set D39 = ( D37 ^ D38 );
set D40 = ( canFS ( support D30 ) );
set D41 = ( ( D39 " ) * D40 );
L327: ( rng D40 ) = D34 by FUNCT_2:def 3;
assume L328: ( support C128 ) misses ( support C129 );
L329: ( ( support C128 ) /\ ( support C129 ) ) = ( {} ) by L328 , XBOOLE_0:def 7;
L330: ( rng D37 ) = D35 by FUNCT_2:def 3;
L331: D34 = ( D35 \/ D36 ) by PRE_POLY:38;
L332: ( rng D38 ) = D36 by FUNCT_2:def 3;
L333: ( rng D39 ) = D34 by L332 , L331 , L330 , FINSEQ_1:31;
L334: (( len D38 ) = ( card D36 ) & ( len D37 ) = ( card D35 )) by UPROOTS:3;
L335: ( len D39 ) = ( ( ( card D35 ) + ( card D36 ) ) - ( card ( {} ) ) ) by L334 , FINSEQ_1:22
.= ( card D34 ) by L329 , L331 , CARD_2:45;
L336: D39 is  one-to-one by L335 , L333 , FINSEQ_4:62;
L337: ( dom ( D39 " ) ) = D34 by L336 , L333 , FUNCT_1:33;
L338: ( rng D41 ) = ( rng ( D39 " ) ) by L337 , L327 , RELAT_1:28;
L339: ( dom D39 ) = ( Seg ( card D34 ) ) by L335 , FINSEQ_1:def 3;
L340: ( rng ( D39 " ) ) = ( Seg ( card D34 ) ) by L339 , L336 , FUNCT_1:33;
consider C130 being (FinSequence of ( COMPLEX )) such that L341: D31 = ( Product C130 ) and L342: C130 = ( C128 * ( canFS ( support C128 ) ) ) by L311;
consider C131 being (FinSequence of ( COMPLEX )) such that L343: D32 = ( Product C131 ) and L344: C131 = ( C129 * ( canFS ( support C129 ) ) ) by L311;
set D42 = ( C130 ^ C131 );
consider C132 being (FinSequence of ( COMPLEX )) such that L345: D33 = ( Product C132 ) and L346: C132 = ( D30 * ( canFS ( support D30 ) ) ) by L311;
L347: ( dom C128 ) = C127 by PARTFUN1:def 2;
L348: ( dom D37 ) = ( dom C130 ) by L347 , L342 , L330 , RELAT_1:27;
L349: ( len D37 ) = ( len C130 ) by L348 , FINSEQ_3:29;
L350: ( len D40 ) = ( card D34 ) by UPROOTS:3;
L351: ( dom D40 ) = ( Seg ( card D34 ) ) by L350 , FINSEQ_1:def 3;
L352: ( dom D41 ) = ( Seg ( card D34 ) ) by L351 , L327 , L337 , RELAT_1:27;
L353: ( dom D30 ) = C127 by PARTFUN1:def 2;
L354: ( dom C132 ) = ( Seg ( card D34 ) ) by L353 , L346 , L351 , L327 , RELAT_1:27;
L355: ( dom C129 ) = C127 by PARTFUN1:def 2;
L356: ( dom D38 ) = ( dom C131 ) by L355 , L344 , L332 , RELAT_1:27;
L357: ( len D38 ) = ( len C131 ) by L356 , FINSEQ_3:29;
L358: ( len D42 ) = ( ( ( card D35 ) + ( card D36 ) ) - ( card ( {} ) ) ) by L357 , L334 , L349 , FINSEQ_1:22
.= ( card D34 ) by L329 , L331 , CARD_2:45;
L359: ( dom D42 ) = ( Seg ( card D34 ) ) by L358 , FINSEQ_1:def 3;
reconsider D43 = D41 as (Function of ( dom D42 ) , ( dom D42 )) by L359 , L340 , L352 , L338 , FUNCT_2:1;
L360: D43 is  onto by L340 , L359 , L338 , FUNCT_2:def 3;
reconsider D44 = D43 as (Permutation of ( dom D42 )) by L360 , L336;
L361: ( dom ( D42 * D44 ) ) = ( Seg ( card D34 ) ) by L340 , L352 , L359 , L338 , RELAT_1:27;
L362: ( len D39 ) = ( ( len D37 ) + ( len D38 ) ) by FINSEQ_1:22;
L363:
now
let C133 being set;
set D45 = ( ( D39 " ) . ( D40 . C133 ) );
assume L364: C133 in ( dom C132 );
L365: ( ( D42 * D44 ) . C133 ) = ( D42 . ( D44 . C133 ) ) by L364 , L354 , L361 , FUNCT_1:12
.= ( D42 . D45 ) by L351 , L354 , L364 , FUNCT_1:13;
L366: ( D40 . C133 ) in D34 by L351 , L327 , L354 , L364 , FUNCT_1:3;
consider C134 being set such that L367: C134 in ( dom D39 ) and L368: ( D39 . C134 ) = ( D40 . C133 ) by L366 , L333 , FUNCT_1:def 3;
L369: D45 in ( Seg ( card D34 ) ) by L337 , L340 , L366 , FUNCT_1:3;
reconsider D46 = D45 as Nat by L369;
reconsider D47 = D46 as Nat;
L370: D46 = C134 by L336 , L367 , L368 , FUNCT_1:34;
L371: 1 <= D47 by L370 , L367 , FINSEQ_3:25;
L372: D47 <= ( ( len C130 ) + ( len C131 ) ) by L349 , L357 , L362 , L367 , L370 , FINSEQ_3:25;
per cases  by L331 , L366 , XBOOLE_0:def 3;
suppose L373: ( D40 . C133 ) in D35;

L374: (not ( D40 . C133 ) in D36) by L373 , L329 , XBOOLE_0:def 4;
L375:
now
L376: ( D46 - ( len D37 ) ) <= ( ( ( len D37 ) + ( len D38 ) ) - ( len D37 ) ) by L349 , L357 , L372 , XREAL_1:9;
assume L377: ( len C130 ) < D46;
L378: ( ( len C130 ) + 1 ) <= D46 by L377 , NAT_1:13;
L379: ( ( ( len D37 ) + 1 ) - ( len D37 ) ) <= ( D46 - ( len D37 ) ) by L378 , L349 , XREAL_1:9;
L380: ( D46 - ( len D37 ) ) is (Element of ( NAT )) by L379 , INT_1:3;
L381: ( D46 - ( len D37 ) ) in ( dom D38 ) by L380 , L379 , L376 , FINSEQ_3:25;
L382: ( D39 . D47 ) = ( D38 . ( D46 - ( len D37 ) ) ) by L349 , L357 , L372 , L378 , FINSEQ_1:23;
thus L383: contradiction by L382 , L332 , L368 , L370 , L374 , L381 , FUNCT_1:3;
end;
L384: D47 in ( dom C130 ) by L375 , L371 , FINSEQ_3:25;
L385: ( D39 . D46 ) = ( D37 . D46 ) by L384 , L348 , FINSEQ_1:def 7;
L386: ( D42 . D46 ) = ( C130 . D47 ) by L384 , FINSEQ_1:def 7
.= ( C128 . ( D40 . C133 ) ) by L342 , L348 , L368 , L370 , L384 , L385 , FUNCT_1:13;
thus L387: ( C132 . C133 ) = ( D30 . ( D40 . C133 ) ) by L346 , L364 , FUNCT_1:12
.= ( ( C128 . ( D40 . C133 ) ) + ( C129 . ( D40 . C133 ) ) ) by PRE_POLY:def 5
.= ( ( C128 . ( D40 . C133 ) ) + ( 0 ) ) by L374 , PRE_POLY:def 7
.= ( ( D42 * D44 ) . C133 ) by L365 , L386;
end;
suppose L388: ( D40 . C133 ) in D36;

L389:
now
assume L390: ( ( len C130 ) + 1 ) > D46;
L391: D46 <= ( len C130 ) by L390 , NAT_1:13;
L392: D46 in ( dom D37 ) by L391 , L348 , L371 , FINSEQ_3:25;
L393: ( D37 . D46 ) in D35 by L392 , L330 , FUNCT_1:3;
L394: ( D39 . D47 ) in D35 by L393 , L392 , FINSEQ_1:def 7;
thus L395: contradiction by L394 , L329 , L368 , L370 , L388 , XBOOLE_0:def 4;
end;
L396: ( D39 . D46 ) = ( D38 . ( D46 - ( len D37 ) ) ) by L389 , L349 , L357 , L372 , FINSEQ_1:23;
L397: ( D46 - ( len D37 ) ) <= ( ( ( len D37 ) + ( len D38 ) ) - ( len D37 ) ) by L349 , L357 , L372 , XREAL_1:9;
L398: ( ( ( len D37 ) + 1 ) - ( len D37 ) ) <= ( D46 - ( len D37 ) ) by L349 , L389 , XREAL_1:9;
L399: ( D47 - ( len D37 ) ) in ( NAT ) by L398 , INT_1:3;
L400: ( D47 - ( len D37 ) ) in ( dom D38 ) by L399 , L397 , L398 , FINSEQ_3:25;
L401: ( D42 . D46 ) = ( C131 . ( D47 - ( len C130 ) ) ) by L372 , L389 , FINSEQ_1:23
.= ( C129 . ( D40 . C133 ) ) by L344 , L349 , L368 , L370 , L396 , L400 , FUNCT_1:13;
L402: (not ( D40 . C133 ) in D35) by L329 , L388 , XBOOLE_0:def 4;
thus L403: ( C132 . C133 ) = ( D30 . ( D40 . C133 ) ) by L346 , L364 , FUNCT_1:12
.= ( ( C128 . ( D40 . C133 ) ) + ( C129 . ( D40 . C133 ) ) ) by PRE_POLY:def 5
.= ( ( 0 ) + ( C129 . ( D40 . C133 ) ) ) by L402 , PRE_POLY:def 7
.= ( ( D42 * D44 ) . C133 ) by L365 , L401;
end;
end;
L405: C132 = ( D42 * D44 ) by L363 , L346 , L351 , L327 , L353 , L361 , FUNCT_1:2 , RELAT_1:27;
thus L406: ( Product ( C128 + C129 ) ) = ( ( multcomplex ) $$ C132 ) by L345 , RVSUM_1:def 13
.= ( ( multcomplex ) $$ D42 ) by L405 , FINSOP_1:7
.= ( Product D42 ) by RVSUM_1:def 13
.= ( ( Product C128 ) * ( Product C129 ) ) by L341 , L343 , RVSUM_1:97;
end;
definition
let C135 being set;
let C136 being  real-valued (ManySortedSet of C135);
let C137 being non  empty Nat;
func C136 |^ C137 -> (ManySortedSet of C135) means 
:L407: (( support it ) = ( support C136 ) & (for B57 being set holds ( it . B57 ) = ( ( C136 . B57 ) |^ C137 )));
existence
proof
reconsider D48 = C137 as (Element of ( NAT )) by ORDINAL1:def 12;
deffunc H7((Element of C135)) = ( ( C136 . $1 ) |^ C137 );
defpred S9[ set , set ] means (ex B58 being (Element of C135) st (B58 = $1 & $2 = H7(B58)));
L408: D48 >= 1 by NAT_1:53;
L409: (for B59 being set holds (B59 in C135 implies (ex B60 being set st S9[ B59 , B60 ])))
proof
let C138 being set;
assume L410: C138 in C135;
reconsider D49 = C138 as (Element of C135) by L410;
take H7(D49);
take D49;
thus L411: thesis;
end;
consider C139 being Function such that L412: ( dom C139 ) = C135 and L413: (for B61 being set holds (B61 in C135 implies S9[ B61 , ( C139 . B61 ) ])) from CLASSES1:sch 1(L409);
reconsider D50 = C139 as (ManySortedSet of C135) by L412 , PARTFUN1:def 2 , RELAT_1:def 18;
take D50;
L414: ( dom C136 ) = C135 by PARTFUN1:def 2;
L415:
now
let C140 being set;
thus L416:now
assume L417: C140 in ( support D50 );
assume L418: (not C140 in ( support C136 ));
L419: ( C136 . C140 ) = ( 0 ) by L418 , PRE_POLY:def 7;
L420: ( ( C136 . C140 ) |^ C137 ) = ( 0 ) by L419 , L408 , NEWTON:11;
L421: ( support D50 ) c= C135 by L412 , PRE_POLY:37;
L422: S9[ C140 , ( D50 . C140 ) ] by L421 , L413 , L417;
thus L423: contradiction by L422 , L417 , L420 , PRE_POLY:def 7;
end;
L424:
now
per cases ;
suppose L425: C140 in C135;

L426: S9[ C140 , ( D50 . C140 ) ] by L425 , L413;
thus L427: ( D50 . C140 ) = ( ( C136 . C140 ) |^ D48 ) by L426;
end;
suppose L428: (not C140 in C135);

thus L429: ( D50 . C140 ) = ( 0 ) by L428 , L412 , FUNCT_1:def 2
.= ( (( 0 ) qua Nat) |^ D48 ) by L408 , NEWTON:11
.= ( ( C136 . C140 ) |^ D48 ) by L414 , L428 , FUNCT_1:def 2;
end;
end;
assume L431: C140 in ( support C136 );
L432: ( C136 . C140 ) <> ( 0 ) by L431 , PRE_POLY:def 7;
L433: ( D50 . C140 ) <> ( 0 ) by L432 , L424 , CARD_4:3;
thus L434: C140 in ( support D50 ) by L433 , PRE_POLY:def 7;
end;
thus L435: ( support D50 ) = ( support C136 ) by L415 , TARSKI:1;
let C141 being set;
per cases ;
suppose L436: C141 in C135;

L437: S9[ C141 , ( D50 . C141 ) ] by L436 , L413;
thus L438: thesis by L437;
end;
suppose L439: (not C141 in C135);

thus L440: ( D50 . C141 ) = ( 0 ) by L439 , L412 , FUNCT_1:def 2
.= ( (( 0 ) qua Nat) |^ C137 ) by L408 , NEWTON:11
.= ( ( C136 . C141 ) |^ C137 ) by L414 , L439 , FUNCT_1:def 2;
end;
end;
uniqueness
proof
let C142 , C143 being (ManySortedSet of C135);
assume that
L442: ( support C142 ) = ( support C136 )
and
L443: (for B62 being set holds ( C142 . B62 ) = ( ( C136 . B62 ) |^ C137 ))
and
L444: ( support C143 ) = ( support C136 )
and
L445: (for B63 being set holds ( C143 . B63 ) = ( ( C136 . B63 ) |^ C137 ));
L446:
now
let C144 being set;
assume that
L447: C144 in C135;
thus L448: ( C142 . C144 ) = ( ( C136 . C144 ) |^ C137 ) by L443
.= ( C143 . C144 ) by L445;
end;
thus L449: C142 = C143 by L446 , PBOOLE:3;
end;
end;
registration
let C145 being set;
let C146 being  natural-valued (ManySortedSet of C145);
let C147 being non  empty Nat;
cluster ( C146 |^ C147 ) ->  natural-valued;
coherence
proof
let C148 being set;
set D51 = ( C146 |^ C147 );
assume L451: C148 in ( dom D51 );
L452: ( D51 . C148 ) = ( ( C146 . C148 ) |^ C147 ) by L407;
thus L453: thesis by L452;
end;
end;
registration
let C149 being set;
let C150 being  real-valued  finite-support (ManySortedSet of C149);
let C151 being non  empty Nat;
cluster ( C150 |^ C151 ) ->  finite-support;
coherence
proof
L455: ( support ( C150 |^ C151 ) ) = ( support C150 ) by L407;
thus L456: ( support ( C150 |^ C151 ) ) is  finite by L455;
end;
end;
theorem
L458: (for B64 being set holds ( Product ( EmptyBag B64 ) ) = 1)
proof
let C152 being set;
set D52 = ( EmptyBag C152 );
set D53 = ( canFS ( support D52 ) );
L459: ( support D52 ) = ( {} ) by BAGORDER:18;
L460: ( D52 * D53 ) = ( <*> ( COMPLEX ) ) by L459;
thus L461: thesis by L460 , L311 , RVSUM_1:94;
end;
begin
definition
let C153 , C154 being Nat;
assume that
L462: C154 <> 1
and
L463: C153 <> ( 0 );
func C154 |-count C153 -> Nat means 
:L464: (( C154 |^ it ) divides C153 & (not ( C154 |^ ( it + 1 ) ) divides C153));
existence
proof
reconsider D54 = C153 as (Element of ( NAT )) by ORDINAL1:def 12;
per cases ;
suppose L465: C154 = ( 0 );

take ( 0 );
L466: ( (( 0 ) qua Nat) |^ ( 0 ) ) = 1 by NEWTON:4;
thus L467: ( C154 |^ ( 0 ) ) divides C153 by L466 , L465 , NAT_D:6;
L468: (not ( 0 ) divides D54) by L463 , INT_2:3;
thus L469: (not ( C154 |^ ( ( 0 ) + 1 ) ) divides C153) by L468 , L465 , NEWTON:11;
end;
suppose L470: C154 <> ( 0 );

defpred S10[ Nat ] means ( C154 |^ $1 ) divides C153;
L471: (for B65 being Nat holds (S10[ B65 ] implies B65 <= D54))
proof
let C155 being Nat;
assume L472: S10[ C155 ];
L473: ( C154 |^ C155 ) <= C153 by L472 , L463 , NAT_D:7;
L474: C155 <= ( C154 |^ C155 ) by L462 , L470 , L11 , NAT_1:25;
thus L475: thesis by L474 , L473 , XXREAL_0:2;
end;
L476: (ex B66 being Nat st S10[ B66 ])
proof
take ( 0 );
L477: ( C154 |^ ( 0 ) ) = 1 by NEWTON:4;
thus L478: thesis by L477 , NAT_D:6;
end;
consider C156 being Nat such that L479: (S10[ C156 ] & (for B67 being Nat holds (S10[ B67 ] implies B67 <= C156))) from NAT_1:sch 6(L471 , L476);
take C156;
L480: ( C156 + (( 0 ) qua Nat) ) < ( C156 + 1 ) by XREAL_1:6;
thus L481: thesis by L480 , L479;
end;
end;
uniqueness
proof
reconsider D55 = C154 as (Element of ( NAT )) by ORDINAL1:def 12;
let C157 , C158 being Nat;
assume that
L483: ( C154 |^ C157 ) divides C153
and
L484: ((not ( C154 |^ ( C157 + 1 ) ) divides C153) & ( C154 |^ C158 ) divides C153)
and
L485: (not ( C154 |^ ( C158 + 1 ) ) divides C153)
and
L486: C157 <> C158;
reconsider D56 = C157 , D57 = C158 as (Element of ( NAT )) by ORDINAL1:def 12;
per cases  by L486 , XXREAL_0:1;
suppose L487: D56 < D57;

consider C159 being Nat such that L488: ( D56 + C159 ) = D57 by L487 , NAT_1:10;
reconsider D58 = C159 as (Element of ( NAT )) by ORDINAL1:def 12;
L489:
now
assume L490: ( ( 0 ) + 1 ) > D58;
L491: D58 = ( 0 ) by L490 , NAT_1:13;
thus L492: contradiction by L491 , L487 , L488;
end;
L493: ( D56 + 1 ) <= ( D56 + D58 ) by L489 , XREAL_1:6;
L494: ( D55 |^ ( D56 + 1 ) ) divides ( D55 |^ ( D56 + D58 ) ) by L493 , NEWTON:89;
thus L495: contradiction by L494 , L484 , L488 , NAT_D:4;
end;
suppose L496: D57 < D56;

consider C160 being Nat such that L497: ( D57 + C160 ) = D56 by L496 , NAT_1:10;
reconsider D59 = C160 as (Element of ( NAT )) by ORDINAL1:def 12;
L498:
now
assume L499: ( ( 0 ) + 1 ) > D59;
L500: D59 = ( 0 ) by L499 , NAT_1:13;
thus L501: contradiction by L500 , L496 , L497;
end;
L502: ( D57 + 1 ) <= ( D57 + D59 ) by L498 , XREAL_1:6;
L503: ( D55 |^ ( D57 + 1 ) ) divides ( D55 |^ ( D57 + D59 ) ) by L502 , NEWTON:89;
thus L504: contradiction by L503 , L483 , L485 , L497 , NAT_D:4;
end;
end;
end;
definition
let C161 , C162 being Nat;
redefine func C162 |-count C161 -> (Element of ( NAT ));

coherence by ORDINAL1:def 12;
end;
theorem
L508: (for R3 being Nat holds (R3 <> 1 implies ( R3 |-count 1 ) = ( 0 )))
proof
let R3 being Nat;
assume L509: 1 <> R3;
L510:
now
assume L511: ( R3 |^ ( ( 0 ) + 1 ) ) divides 1;
L512: ( R3 |^ 1 ) <= 1 by L511 , NAT_D:7;
L513: R3 <= 1 by L512 , NEWTON:5;
L514: R3 = ( 0 ) by L513 , L509 , NAT_1:25;
L515: ( 0 ) divides 1 by L514 , L511 , NEWTON:5;
thus L516: contradiction by L515 , INT_2:3;
end;
L517: ( R3 |^ ( 0 ) ) divides 1 by NEWTON:4;
thus L518: thesis by L517 , L509 , L510 , L464;
end;
theorem
L519: (for R3 being Nat holds (1 < R3 implies ( R3 |-count R3 ) = 1))
proof
let R3 being Nat;
assume L520: 1 < R3;
L521:
now
assume L522: ( R3 |^ ( 1 + 1 ) ) divides R3;
L523: ( R3 |^ 2 ) <= R3 by L522 , L520 , NAT_D:7;
thus L524: contradiction by L523 , L520 , PREPOWER:13;
end;
L525: ( R3 |^ 1 ) divides R3 by NEWTON:5;
thus L526: thesis by L525 , L520 , L521 , L464;
end;
theorem
L527: (for R1 being Nat holds (for R2 being Nat holds ((R2 <> ( 0 ) & R2 < R1 & R1 <> 1) implies ( R1 |-count R2 ) = ( 0 ))))
proof
let R1 being Nat;
let R2 being Nat;
assume that
L528: R2 <> ( 0 )
and
L529: R2 < R1
and
L530: R1 <> 1;
L531: ( R1 |^ ( 0 ) ) = 1 by NEWTON:4;
L532: ( R1 |^ ( 0 ) ) divides R2 by L531 , NAT_D:6;
L533: ( R1 |^ 1 ) = R1 by NEWTON:5;
L534: (not ( R1 |^ ( ( 0 ) + 1 ) ) divides R2) by L533 , L528 , L529 , NAT_D:7;
thus L535: thesis by L534 , L528 , L530 , L532 , L464;
end;
theorem
L536: (for R1 being Nat holds (for R6 being Prime holds ((R1 <> 1 & R1 <> R6) implies ( R1 |-count R6 ) = ( 0 ))))
proof
let R1 being Nat;
let R6 being Prime;
assume that
L537: R1 <> 1
and
L538: R1 <> R6;
L539: ( R1 |^ ( 0 ) ) = 1 by NEWTON:4;
L540: ( R1 |^ ( 0 ) ) divides R6 by L539 , NAT_D:6;
L541: ( R1 |^ 1 ) = R1 by NEWTON:5;
L542: (not ( R1 |^ ( ( 0 ) + 1 ) ) divides R6) by L541 , L537 , L538 , INT_2:def 4;
thus L543: thesis by L542 , L537 , L540 , L464;
end;
theorem
L544: (for R1 being Nat holds (for R2 being Nat holds (1 < R2 implies ( R2 |-count ( R2 |^ R1 ) ) = R1)))
proof
let R1 being Nat;
let R2 being Nat;
reconsider D60 = R1 as (Element of ( NAT )) by ORDINAL1:def 12;
assume L545: R2 > 1;
reconsider D61 = R2 as non  empty (Element of ( NAT )) by L545 , ORDINAL1:def 12;
L546:
now
L547: ( D61 |^ D60 ) divides ( D61 |^ ( D60 + 1 ) ) by NAT_1:11 , NEWTON:89;
L548: ( D61 |^ D60 ) <= ( D61 |^ ( D60 + 1 ) ) by L547 , NAT_D:7;
assume L549: ( D61 |^ ( D60 + 1 ) ) divides ( D61 |^ D60 );
L550: ( D61 |^ ( D60 + 1 ) ) <= ( D61 |^ D60 ) by L549 , NAT_D:7;
L551: ( D61 |^ D60 ) = ( D61 |^ ( D60 + 1 ) ) by L550 , L548 , XXREAL_0:1;
L552: ( D60 + ( 0 ) ) = ( D60 + 1 ) by L551 , L545 , PEPIN:30;
thus L553: contradiction by L552;
end;
thus L554: thesis by L546 , L545 , L464;
end;
theorem
L555: (for R1 being Nat holds (for R2 being Nat holds ((R2 <> 1 & R1 <> ( 0 ) & R2 divides ( R2 |^ ( R2 |-count R1 ) )) implies R2 divides R1)))
proof
let R1 being Nat;
let R2 being Nat;
assume that
L556: (R2 <> 1 & R1 <> ( 0 ))
and
L557: R2 divides ( R2 |^ ( R2 |-count R1 ) );
L558: ( R2 |^ ( R2 |-count R1 ) ) divides R1 by L556 , L464;
thus L559: thesis by L558 , L557 , NAT_D:4;
end;
theorem
L560: (for R1 being Nat holds (for R2 being Nat holds (R2 <> 1 implies ((R1 <> ( 0 ) & ( R2 |-count R1 ) = ( 0 )) iff (not R2 divides R1)))))
proof
let R1 being Nat;
let R2 being Nat;
L561: 1 divides R1 by NAT_D:6;
L562: ( R2 |^ ( 0 ) ) divides R1 by L561 , NEWTON:4;
assume L563: R2 <> 1;
thus L564: ((R1 <> ( 0 ) & ( R2 |-count R1 ) = ( 0 )) implies (not R2 divides R1))
proof
assume that
L565: (R1 <> ( 0 ) & ( R2 |-count R1 ) = ( 0 ))
and
L566: R2 divides R1;
L567: (not ( R2 |^ ( ( 0 ) + 1 ) ) divides R1) by L563 , L565 , L464;
thus L568: contradiction by L567 , L566 , NEWTON:5;
end;

assume L569: (not R2 divides R1);
L570: ((not ( R2 |^ ( ( 0 ) + 1 ) ) divides R1) & R1 <> ( 0 )) by L569 , NAT_D:6 , NEWTON:5;
thus L571: thesis by L570 , L563 , L562 , L464;
end;
theorem
L572: (for R6 being Prime holds (for B68 , B69 being non  empty Nat holds ( R6 |-count ( B68 * B69 ) ) = ( ( R6 |-count B68 ) + ( R6 |-count B69 ) )))
proof
let R6 being Prime;
let C163 , C164 being non  empty Nat;
set D62 = ( R6 |-count C163 );
set D63 = ( R6 |-count C164 );
L573: R6 <> 1 by INT_2:def 4;
L574: ( R6 |^ D63 ) divides C164 by L573 , L464;
L575: ( R6 |^ D62 ) divides C163 by L573 , L464;
L576:
now
assume L577: ( R6 |^ ( ( D62 + D63 ) + 1 ) ) divides ( C163 * C164 );
consider C165 being Nat such that L578: ( C163 * C164 ) = ( ( R6 |^ ( ( D62 + D63 ) + 1 ) ) * C165 ) by L577 , NAT_D:def 3;
L579: ( R6 |^ ( ( D62 + D63 ) + 1 ) ) = ( ( R6 |^ ( D62 + D63 ) ) * R6 ) by NEWTON:6;
L580: ( C163 * C164 ) = ( ( R6 |^ ( D62 + D63 ) ) * ( R6 * C165 ) ) by L579 , L578;
consider C166 being Nat such that L581: C163 = ( ( R6 |^ D62 ) * C166 ) by L575 , NAT_D:def 3;
L582: (not ( R6 |^ ( D62 + 1 ) ) divides C163) by L573 , L464;
L583: (not ( R6 |^ ( D63 + 1 ) ) divides C164) by L573 , L464;
consider C167 being Nat such that L584: C164 = ( ( R6 |^ D63 ) * C167 ) by L574 , NAT_D:def 3;
L585: ( C163 * C164 ) = ( ( ( ( R6 |^ D62 ) * ( R6 |^ D63 ) ) * C166 ) * C167 ) by L581 , L584
.= ( ( ( R6 |^ ( D62 + D63 ) ) * C166 ) * C167 ) by NEWTON:8
.= ( ( R6 |^ ( D62 + D63 ) ) * ( C166 * C167 ) );
L586: ( R6 * C165 ) = ( C166 * C167 ) by L585 , L580 , XCMPLX_1:5;
L587: R6 divides ( C166 * C167 ) by L586 , NAT_D:def 3;
per cases  by L587 , NEWTON:80;
suppose L588: R6 divides C166;

consider C168 being Nat such that L589: C166 = ( R6 * C168 ) by L588 , NAT_D:def 3;
L590: C163 = ( ( ( R6 |^ D62 ) * R6 ) * C168 ) by L581 , L589
.= ( ( R6 |^ ( D62 + 1 ) ) * C168 ) by NEWTON:6;
thus L591: contradiction by L590 , L582 , NAT_D:def 3;
end;
suppose L592: R6 divides C167;

consider C169 being Nat such that L593: C167 = ( R6 * C169 ) by L592 , NAT_D:def 3;
L594: C164 = ( ( ( R6 |^ D63 ) * R6 ) * C169 ) by L584 , L593
.= ( ( R6 |^ ( D63 + 1 ) ) * C169 ) by NEWTON:6;
thus L595: contradiction by L594 , L583 , NAT_D:def 3;
end;
end;
L597: ( R6 |^ ( D62 + D63 ) ) = ( ( R6 |^ D62 ) * ( R6 |^ D63 ) ) by NEWTON:8;
L598: ( R6 |^ ( D62 + D63 ) ) divides ( C163 * C164 ) by L597 , L575 , L574 , L7;
thus L599: thesis by L598 , L573 , L576 , L464;
end;
theorem
L600: (for R6 being Prime holds (for B70 , B71 being non  empty Nat holds ( R6 |^ ( R6 |-count ( B70 * B71 ) ) ) = ( ( R6 |^ ( R6 |-count B70 ) ) * ( R6 |^ ( R6 |-count B71 ) ) )))
proof
let R6 being Prime;
let C170 , C171 being non  empty Nat;
set D64 = ( R6 |-count C170 );
set D65 = ( R6 |-count C171 );
thus L601: ( R6 |^ ( R6 |-count ( C170 * C171 ) ) ) = ( R6 |^ ( D64 + D65 ) ) by L572
.= ( ( R6 |^ D64 ) * ( R6 |^ D65 ) ) by NEWTON:8;
end;
theorem
L602: (for R6 being Prime holds (for B72 , B73 being non  empty Nat holds (B73 divides B72 implies ( R6 |-count B73 ) <= ( R6 |-count B72 ))))
proof
let R6 being Prime;
let C172 , C173 being non  empty Nat;
set D66 = ( R6 |-count C172 );
set D67 = ( R6 |-count C173 );
set D68 = ( R6 |-count ( C172 div C173 ) );
L603: ( ( 0 ) + 1 ) <= ( R6 |^ D68 ) by NAT_1:13;
L604: ( 1 * ( R6 |^ D67 ) ) <= ( ( R6 |^ D68 ) * ( R6 |^ D67 ) ) by L603 , XREAL_1:66;
assume L605: C173 divides C172;
L606: C172 = ( C173 * ( C172 div C173 ) ) by L605 , NAT_D:3;
L607: ( C172 div C173 ) <> ( 0 ) by L606;
L608: (R6 > 1 & ( R6 |^ D67 ) <= ( R6 |^ D66 )) by L607 , L606 , L604 , L600 , INT_2:def 4;
thus L609: thesis by L608 , PEPIN:66;
end;
theorem
L610: (for R6 being Prime holds (for B74 , B75 being non  empty Nat holds (B75 divides B74 implies ( R6 |-count ( B74 div B75 ) ) = ( ( R6 |-count B74 ) -' ( R6 |-count B75 ) ))))
proof
let R6 being Prime;
let C174 , C175 being non  empty Nat;
set D69 = ( R6 |-count C174 );
set D70 = ( R6 |-count C175 );
set D71 = ( R6 |-count ( C174 div C175 ) );
assume L611: C175 divides C174;
L612: C174 = ( C175 * ( C174 div C175 ) ) by L611 , NAT_D:3;
L613: ( C174 div C175 ) <> ( 0 ) by L612;
L614: ( R6 |-count ( C175 * ( C174 div C175 ) ) ) = ( D70 + D71 ) by L613 , L572;
L615: ( D71 + D70 ) = ( D69 + ( 0 ) ) by L614 , L611 , NAT_D:3;
L616: D70 <= D69 by L611 , L602;
L617: ( D70 - D70 ) <= ( D69 - D70 ) by L616 , XREAL_1:13;
thus L618: thesis by L617 , L615 , XREAL_0:def 2;
end;
theorem
L619: (for R2 being Nat holds (for R6 being Prime holds (for B76 being non  empty Nat holds ( R6 |-count ( B76 |^ R2 ) ) = ( R2 * ( R6 |-count B76 ) ))))
proof
let R2 being Nat;
let R6 being Prime;
let C176 being non  empty Nat;
L620: R6 <> 1 by INT_2:def 4;
defpred S11[ Nat ] means ( R6 |-count ( C176 |^ $1 ) ) = ( $1 * ( R6 |-count C176 ) );
L621: (for B77 being Nat holds (S11[ B77 ] implies S11[ ( B77 + 1 ) ]))
proof
let C177 being Nat;
assume that
L622: S11[ C177 ];
thus L623: ( R6 |-count ( C176 |^ ( C177 + 1 ) ) ) = ( R6 |-count ( ( C176 |^ C177 ) * C176 ) ) by NEWTON:6
.= ( ( C177 * ( R6 |-count C176 ) ) + ( 1 * ( R6 |-count C176 ) ) ) by L622 , L572
.= ( ( C177 + 1 ) * ( R6 |-count C176 ) );
end;
L624: ( R6 |-count ( C176 |^ ( 0 ) ) ) = ( R6 |-count 1 ) by NEWTON:4
.= ( ( 0 ) * ( R6 |-count C176 ) ) by L620 , L508;
L625: S11[ ( 0 ) ] by L624;
L626: (for B78 being Nat holds S11[ B78 ]) from NAT_1:sch 2(L625 , L621);
thus L627: thesis by L626;
end;
begin
definition
let C178 being Nat;
func prime_exponents C178 -> (ManySortedSet of ( SetPrimes )) means 
:L628: (for B79 being Prime holds ( it . B79 ) = ( B79 |-count C178 ));
existence
proof
deffunc H8(Nat) = ( $1 |-count C178 );
defpred S12[ set , set ] means (ex B80 being Nat st (B80 = $1 & $2 = H8(B80)));
L629: (for B81 being set holds (B81 in ( SetPrimes ) implies (ex B82 being set st S12[ B81 , B82 ])))
proof
let C179 being set;
assume L630: C179 in ( SetPrimes );
reconsider D72 = C179 as  prime (Element of ( NAT )) by L630 , NEWTON:def 6;
take H8(D72);
take D72;
thus L631: thesis;
end;
consider C180 being (ManySortedSet of ( SetPrimes )) such that L632: (for B83 being set holds (B83 in ( SetPrimes ) implies S12[ B83 , ( C180 . B83 ) ])) from PBOOLE:sch 3(L629);
take C180;
let C181 being Prime;
L633: C181 in ( SetPrimes ) by NEWTON:def 6;
L634: S12[ C181 , ( C180 . C181 ) ] by L633 , L632;
thus L635: thesis by L634;
end;
uniqueness
proof
let C182 , C183 being (ManySortedSet of ( SetPrimes ));
assume that
L636: (for B84 being Prime holds ( C182 . B84 ) = ( B84 |-count C178 ))
and
L637: (for B85 being Prime holds ( C183 . B85 ) = ( B85 |-count C178 ));
L638:
now
let C184 being set;
assume L639: C184 in ( SetPrimes );
reconsider D73 = C184 as  prime (Element of ( NAT )) by L639 , NEWTON:def 6;
thus L640: ( C182 . C184 ) = ( D73 |-count C178 ) by L636
.= ( C183 . C184 ) by L637;
end;
thus L641: thesis by L638 , PBOOLE:3;
end;
end;
notation
let C185 being Nat;
synonym pfexp C185 for prime_exponents C185;
end;
theorem
L644: (for R3 being Nat holds (for B86 being set holds (B86 in ( dom ( pfexp R3 ) ) implies B86 is Prime)))
proof
let R3 being Nat;
let C186 being set;
assume L645: C186 in ( dom ( pfexp R3 ) );
L646: C186 in ( SetPrimes ) by L645 , PARTFUN1:def 2;
thus L647: thesis by L646 , NEWTON:def 6;
end;
theorem
L648: (for R3 being Nat holds (for B87 being set holds (B87 in ( support ( pfexp R3 ) ) implies B87 is Prime)))
proof
let R3 being Nat;
let C187 being set;
set D74 = ( pfexp R3 );
L649: ( support D74 ) c= ( dom D74 ) by PRE_POLY:37;
assume L650: C187 in ( support D74 );
thus L651: thesis by L650 , L649 , L644;
end;
theorem
L652: (for R1 being Nat holds (for R3 being Nat holds ((R1 > R3 & R3 <> ( 0 )) implies ( ( pfexp R3 ) . R1 ) = ( 0 ))))
proof
let R1 being Nat;
let R3 being Nat;
assume L653: (R1 > R3 & R3 <> ( 0 ));
reconsider D75 = R1 as (Element of ( NAT )) by ORDINAL1:def 12;
per cases ;
suppose L654: (not D75 is  prime);

L655: (not D75 in ( dom ( pfexp R3 ) )) by L654 , L644;
thus L656: thesis by L655 , FUNCT_1:def 2;
end;
suppose L657: D75 is  prime;

L658: D75 <> 1 by L657 , INT_2:def 4;
L659: ( D75 |-count R3 ) = ( 0 ) by L658 , L653 , L527;
thus L660: thesis by L659 , L657 , L628;
end;
end;
registration
let C188 being Nat;
cluster ( pfexp C188 ) ->  natural-valued;
coherence
proof
let C189 being set;
set D76 = ( pfexp C188 );
assume L662: C189 in ( dom D76 );
reconsider D77 = C189 as Prime by L662 , L644;
L663: ( D76 . D77 ) = ( D77 |-count C188 ) by L628;
thus L664: thesis by L663;
end;
end;
theorem
L666: (for R1 being Nat holds (for R2 being Nat holds (R1 in ( support ( pfexp R2 ) ) implies R1 divides R2)))
proof
let R1 being Nat;
let R2 being Nat;
set D78 = ( pfexp R2 );
assume L667: R1 in ( support D78 );
reconsider D79 = R1 as Prime by L667 , L648;
L668: (D79 <> 1 & ( D78 . D79 ) = ( D79 |-count R2 )) by L628 , INT_2:def 4;
L669: ( D78 . D79 ) <> ( 0 ) by L667 , PRE_POLY:def 7;
thus L670: thesis by L669 , L668 , L560;
end;
theorem
L671: (for R1 being Nat holds (for R2 being Nat holds ((R2 is non  empty & R1 is Prime & R1 divides R2) implies R1 in ( support ( pfexp R2 ) ))))
proof
let R1 being Nat;
let R2 being Nat;
assume that
L672: R2 is non  empty
and
L673: R1 is Prime
and
L674: R1 divides R2;
L675: 1 < R1 by L673 , INT_2:def 4;
L676: ( R1 |-count R2 ) <> ( 0 ) by L675 , L672 , L674 , L560;
L677: ( ( pfexp R2 ) . R1 ) = ( R1 |-count R2 ) by L673 , L628;
thus L678: thesis by L677 , L676 , PRE_POLY:def 7;
end;
registration
let C190 being non  empty Nat;
cluster ( pfexp C190 ) ->  finite-support;
coherence
proof
defpred S13[ Nat ] means $1 is  prime;
deffunc H9(set) = $1;
set D80 = ( pfexp C190 );
reconsider D81 = C190 as (Element of ( NAT )) by ORDINAL1:def 12;
set D82 = { H9(B88) where B88 is (Element of ( NAT )) : (( 0 ) <= B88 & B88 <= D81 & S13[ B88 ]) };
L679: ( support D80 ) c= D82
proof
let C191 being set;
assume L680: C191 in ( support D80 );
reconsider D83 = C191 as Prime by L680 , L648;
L681: ( D80 . D83 ) <> ( 0 ) by L680 , PRE_POLY:def 7;
L682: (D83 is  prime  prime  prime  prime (Element of ( NAT )) & D83 <= D81) by L681 , L652 , ORDINAL1:def 12;
thus L683: thesis by L682;
end;
L684: D82 is  finite from FINSEQ_1:sch 6;
thus L685: ( support D80 ) is  finite by L684 , L679;
end;
end;
theorem
L687: (for R6 being Prime holds (for B89 being non  empty Nat holds (R6 divides B89 implies ( ( pfexp B89 ) . R6 ) <> ( 0 ))))
proof
let R6 being Prime;
let C192 being non  empty Nat;
assume L688: R6 divides C192;
L689: ( R6 |^ ( ( 0 ) + 1 ) ) divides C192 by L688 , NEWTON:5;
L690: (( ( pfexp C192 ) . R6 ) = ( R6 |-count C192 ) & R6 <> 1) by L628 , INT_2:def 4;
thus L691: thesis by L690 , L689 , L464;
end;
theorem
L692: ( pfexp 1 ) = ( EmptyBag ( SetPrimes ) )
proof
set D84 = ( pfexp 1 );
L693: (for B90 being set holds (B90 in ( dom D84 ) implies ( D84 . B90 ) = ( 0 )))
proof
let C193 being set;
assume L694: C193 in ( dom D84 );
reconsider D85 = C193 as Prime by L694 , L644;
L695: D85 <> 1 by INT_2:def 4;
L696: ( D84 . D85 ) = ( D85 |-count 1 ) by L628
.= ( 0 ) by L695 , L508;
thus L697: thesis by L696;
end;
L698: D84 = ( ( dom D84 ) --> ( 0 ) ) by L693 , FUNCOP_1:11;
thus L699: thesis by L698 , PARTFUN1:def 2;
end;
registration
cluster ( support ( pfexp 1 ) ) ->  empty;
coherence
proof
set D86 = ( pfexp 1 );
assume L700: ( support D86 ) is non  empty;
consider C194 being set such that L701: C194 in ( support D86 ) by L700 , XBOOLE_0:def 1;
L702: ( D86 . C194 ) <> ( 0 ) by L701 , PRE_POLY:def 7;
thus L703: contradiction by L702 , L692 , PRE_POLY:52;
end;
end;
theorem
L705: (for R1 being Nat holds (for R6 being Prime holds ( ( pfexp ( R6 |^ R1 ) ) . R6 ) = R1))
proof
let R1 being Nat;
let R6 being Prime;
set D87 = ( pfexp ( R6 |^ R1 ) );
L706: (R6 > 1 & ( D87 . R6 ) = ( R6 |-count ( R6 |^ R1 ) )) by L628 , INT_2:def 4;
thus L707: thesis by L706 , L544;
end;
theorem
L708: (for R6 being Prime holds ( ( pfexp R6 ) . R6 ) = 1)
proof
let R6 being Prime;
L709: R6 = ( R6 |^ 1 ) by NEWTON:5;
thus L710: thesis by L709 , L705;
end;
theorem
L711: (for R1 being Nat holds (for R6 being Prime holds (R1 <> ( 0 ) implies ( support ( pfexp ( R6 |^ R1 ) ) ) = { R6 })))
proof
let R1 being Nat;
let R6 being Prime;
set D88 = ( pfexp ( R6 |^ R1 ) );
assume L712: R1 <> ( 0 );
L713: R6 divides ( R6 |^ R1 ) by L712 , L27;
L714: ( D88 . R6 ) <> ( 0 ) by L713 , L687;
thus L715: ( support D88 ) c= { R6 }
proof
let C195 being set;
assume L716: C195 in ( support D88 );
reconsider D89 = C195 as Prime by L716 , L648;
L717: (D89 <> 1 & ( D88 . D89 ) = ( D89 |-count ( R6 |^ R1 ) )) by L628 , INT_2:def 4;
L718: ( D88 . D89 ) <> ( 0 ) by L716 , PRE_POLY:def 7;
L719: D89 divides ( R6 |^ R1 ) by L718 , L717 , L560;
L720: D89 = R6 by L719 , L62;
thus L721: thesis by L720 , TARSKI:def 1;
end;

let C196 being set;
assume L722: C196 in { R6 };
L723: C196 = R6 by L722 , TARSKI:def 1;
thus L724: thesis by L723 , L714 , PRE_POLY:def 7;
end;
theorem
L725: (for R6 being Prime holds ( support ( pfexp R6 ) ) = { R6 })
proof
let R6 being Prime;
L726: R6 = ( R6 |^ 1 ) by NEWTON:5;
thus L727: thesis by L726 , L711;
end;
registration
let C197 being Prime;
let C198 being non  empty Nat;
cluster ( support ( pfexp ( C197 |^ C198 ) ) ) -> 1 -element;
coherence
proof
L728: ( support ( pfexp ( C197 |^ C198 ) ) ) = { C197 } by L711;
thus L729: thesis by L728;
end;
end;
registration
let C199 being Prime;
cluster ( support ( pfexp C199 ) ) -> 1 -element;
coherence
proof
L731: ( support ( pfexp C199 ) ) = { C199 } by L725;
thus L732: thesis by L731;
end;
end;
theorem
L734: (for B91 , B92 being non  empty Nat holds (B91 , B92 are_relative_prime  implies ( support ( pfexp B91 ) ) misses ( support ( pfexp B92 ) )))
proof
let C200 , C201 being non  empty Nat;
set D90 = ( pfexp C200 );
set D91 = ( pfexp C201 );
assume L735: C200 , C201 are_relative_prime ;
L736: ( C200 gcd C201 ) = 1 by L735 , INT_2:def 3;
assume L737: ( support D90 ) meets ( support D91 );
consider C202 being set such that L738: C202 in ( support D90 ) and L739: C202 in ( support D91 ) by L737 , XBOOLE_0:3;
reconsider D92 = C202 as Prime by L738 , L648;
L740: ( D90 . D92 ) = ( D92 |-count C200 ) by L628;
L741: ( D91 . D92 ) = ( D92 |-count C201 ) by L628;
L742: ( D91 . D92 ) <> ( 0 ) by L739 , PRE_POLY:def 7;
L743: D92 divides ( D92 |^ ( D92 |-count C201 ) ) by L742 , L741 , L27;
L744: D92 <> 1 by INT_2:def 4;
L745: ( D92 |^ ( D92 |-count C201 ) ) divides C201 by L744 , L464;
L746: D92 divides C201 by L745 , L743 , NAT_D:4;
L747: ( D90 . D92 ) <> ( 0 ) by L738 , PRE_POLY:def 7;
L748: D92 divides ( D92 |^ ( D92 |-count C200 ) ) by L747 , L740 , L27;
L749: ( D92 |^ ( D92 |-count C200 ) ) divides C200 by L744 , L464;
L750: D92 divides C200 by L749 , L748 , NAT_D:4;
L751: D92 divides 1 by L750 , L736 , L746 , NAT_D:def 5;
thus L752: contradiction by L751 , L744 , WSIERP_1:15;
end;
theorem
L753: (for B93 , B94 being non  empty Nat holds ( support ( pfexp B93 ) ) c= ( support ( pfexp ( B93 * B94 ) ) ))
proof
let C203 , C204 being non  empty Nat;
set D93 = ( pfexp C203 );
set D94 = ( pfexp ( C203 * C204 ) );
let C205 being set;
assume L754: C205 in ( support D93 );
reconsider D95 = C205 as Prime by L754 , L648;
L755: ( D93 . D95 ) = ( D95 |-count C203 ) by L628;
L756: ( D93 . D95 ) <> ( 0 ) by L754 , PRE_POLY:def 7;
L757: D95 divides ( D95 |^ ( D95 |-count C203 ) ) by L756 , L755 , L27;
L758: D95 <> 1 by INT_2:def 4;
L759: ( D95 |^ ( D95 |-count C203 ) ) divides C203 by L758 , L464;
L760: D95 divides C203 by L759 , L757 , NAT_D:4;
L761: ( D95 |^ 1 ) divides C203 by L760 , NEWTON:5;
L762: ( D95 |^ ( ( 0 ) + 1 ) ) divides ( C203 * C204 ) by L761 , NAT_D:9;
L763: ( D94 . D95 ) = ( D95 |-count ( C203 * C204 ) ) by L628;
L764: ( D94 . D95 ) <> ( 0 ) by L763 , L758 , L762 , L464;
thus L765: thesis by L764 , PRE_POLY:def 7;
end;
theorem
L766: (for B95 , B96 being non  empty Nat holds ( support ( pfexp ( B95 * B96 ) ) ) = ( ( support ( pfexp B95 ) ) \/ ( support ( pfexp B96 ) ) ))
proof
let C206 , C207 being non  empty Nat;
set D96 = ( pfexp C206 );
set D97 = ( pfexp C207 );
set D98 = ( pfexp ( C206 * C207 ) );
thus L767: ( support D98 ) c= ( ( support D96 ) \/ ( support D97 ) )
proof
let C208 being set;
assume L768: C208 in ( support D98 );
reconsider D99 = C208 as Prime by L768 , L648;
L769: ( D98 . D99 ) <> ( 0 ) by L768 , PRE_POLY:def 7;
L770: D99 <> 1 by INT_2:def 4;
L771: (( D98 . D99 ) = ( D99 |-count ( C206 * C207 ) ) & ( D99 |^ ( D99 |-count ( C206 * C207 ) ) ) = ( ( D99 |^ ( D99 |-count C206 ) ) * ( D99 |^ ( D99 |-count C207 ) ) )) by L628 , L600;
per cases  by L769 , L771 , L27 , NEWTON:80;
suppose L772: D99 divides ( D99 |^ ( D99 |-count C206 ) );

L773: D99 divides C206 by L772 , L770 , L555;
L774: ( D96 . D99 ) <> ( 0 ) by L773 , L687;
L775: D99 in ( support D96 ) by L774 , PRE_POLY:def 7;
thus L776: thesis by L775 , XBOOLE_0:def 3;
end;
suppose L777: D99 divides ( D99 |^ ( D99 |-count C207 ) );

L778: D99 divides C207 by L777 , L770 , L555;
L779: ( D97 . D99 ) <> ( 0 ) by L778 , L687;
L780: D99 in ( support D97 ) by L779 , PRE_POLY:def 7;
thus L781: thesis by L780 , XBOOLE_0:def 3;
end;
end;

L783: (( support D96 ) c= ( support D98 ) & ( support D97 ) c= ( support D98 )) by L753;
thus L784: thesis by L783 , XBOOLE_1:8;
end;
theorem
L785: (for B97 , B98 being non  empty Nat holds (B97 , B98 are_relative_prime  implies ( card ( support ( pfexp ( B97 * B98 ) ) ) ) = ( ( card ( support ( pfexp B97 ) ) ) + ( card ( support ( pfexp B98 ) ) ) )))
proof
let C209 , C210 being non  empty Nat;
assume L786: C209 , C210 are_relative_prime ;
L787: ( support ( pfexp ( C209 * C210 ) ) ) = ( ( support ( pfexp C209 ) ) \/ ( support ( pfexp C210 ) ) ) by L766;
thus L788: thesis by L787 , L786 , L734 , CARD_2:40;
end;
theorem
L789: (for B99 , B100 being non  empty Nat holds ( support ( pfexp B99 ) ) = ( support ( pfexp ( B99 |^ B100 ) ) ))
proof
let C211 , C212 being non  empty Nat;
set D100 = ( pfexp C211 );
set D101 = ( pfexp ( C211 |^ C212 ) );
L790: ( C211 |^ C212 ) = ( ( C211 |^ ( C212 -' 1 ) ) * C211 ) by PEPIN:26;
thus L791: ( support D100 ) c= ( support D101 ) by L790 , L753;
let C213 being set;
assume L792: C213 in ( support D101 );
reconsider D102 = C213 as Prime by L792 , L648;
L793: (( D101 . D102 ) = ( D102 |-count ( C211 |^ C212 ) ) & D102 <> 1) by L628 , INT_2:def 4;
L794: ( D101 . D102 ) <> ( 0 ) by L792 , PRE_POLY:def 7;
L795: D102 divides ( C211 |^ C212 ) by L794 , L793 , L560;
L796: ( D100 . D102 ) <> ( 0 ) by L795 , L38 , L687;
thus L797: thesis by L796 , PRE_POLY:def 7;
end;
theorem
L798: (for R7 being non  empty Nat holds (for R8 being non  empty Nat holds ( pfexp ( R7 * R8 ) ) = ( ( pfexp R7 ) + ( pfexp R8 ) )))
proof
let R7 being non  empty Nat;
let R8 being non  empty Nat;
L799: (for B101 being set holds (B101 in ( SetPrimes ) implies ( ( pfexp ( R7 * R8 ) ) . B101 ) = ( ( ( pfexp R7 ) + ( pfexp R8 ) ) . B101 )))
proof
let C214 being set;
assume L800: C214 in ( SetPrimes );
reconsider D103 = C214 as  prime (Element of ( NAT )) by L800 , NEWTON:def 6;
thus L801: ( ( pfexp ( R7 * R8 ) ) . C214 ) = ( D103 |-count ( R7 * R8 ) ) by L628
.= ( ( D103 |-count R7 ) + ( D103 |-count R8 ) ) by L572
.= ( ( ( pfexp R7 ) . C214 ) + ( D103 |-count R8 ) ) by L628
.= ( ( ( pfexp R7 ) . C214 ) + ( ( pfexp R8 ) . C214 ) ) by L628
.= ( ( ( pfexp R7 ) + ( pfexp R8 ) ) . C214 ) by PRE_POLY:def 5;
end;
thus L802: thesis by L799 , PBOOLE:3;
end;
theorem
L803: (for R7 being non  empty Nat holds (for R8 being non  empty Nat holds (R8 divides R7 implies ( pfexp ( R7 div R8 ) ) = ( ( pfexp R7 ) -' ( pfexp R8 ) ))))
proof
let R7 being non  empty Nat;
let R8 being non  empty Nat;
assume L804: R8 divides R7;
L805: (for B102 being set holds (B102 in ( SetPrimes ) implies ( ( pfexp ( R7 div R8 ) ) . B102 ) = ( ( ( pfexp R7 ) -' ( pfexp R8 ) ) . B102 )))
proof
let C215 being set;
assume L806: C215 in ( SetPrimes );
reconsider D104 = C215 as  prime (Element of ( NAT )) by L806 , NEWTON:def 6;
thus L807: ( ( pfexp ( R7 div R8 ) ) . C215 ) = ( D104 |-count ( R7 div R8 ) ) by L628
.= ( ( D104 |-count R7 ) -' ( D104 |-count R8 ) ) by L804 , L610
.= ( ( ( pfexp R7 ) . C215 ) -' ( D104 |-count R8 ) ) by L628
.= ( ( ( pfexp R7 ) . C215 ) -' ( ( pfexp R8 ) . C215 ) ) by L628
.= ( ( ( pfexp R7 ) -' ( pfexp R8 ) ) . C215 ) by PRE_POLY:def 6;
end;
thus L808: thesis by L805 , PBOOLE:3;
end;
theorem
L809: (for R1 being Nat holds (for R7 being non  empty Nat holds ( pfexp ( R7 |^ R1 ) ) = ( R1 * ( pfexp R7 ) )))
proof
let R1 being Nat;
let R7 being non  empty Nat;
L810: (for B103 being set holds (B103 in ( SetPrimes ) implies ( ( pfexp ( R7 |^ R1 ) ) . B103 ) = ( ( R1 * ( pfexp R7 ) ) . B103 )))
proof
let C216 being set;
assume L811: C216 in ( SetPrimes );
reconsider D105 = C216 as  prime (Element of ( NAT )) by L811 , NEWTON:def 6;
thus L812: ( ( pfexp ( R7 |^ R1 ) ) . C216 ) = ( D105 |-count ( R7 |^ R1 ) ) by L628
.= ( R1 * ( D105 |-count R7 ) ) by L619
.= ( R1 * ( ( pfexp R7 ) . C216 ) ) by L628
.= ( ( R1 * ( pfexp R7 ) ) . C216 ) by L182;
end;
thus L813: thesis by L810 , PBOOLE:3;
end;
theorem
L814: (for R7 being non  empty Nat holds (( support ( pfexp R7 ) ) = ( {} ) implies R7 = 1))
proof
let R7 being non  empty Nat;
assume that
L815: ( support ( pfexp R7 ) ) = ( {} )
and
L816: R7 <> 1;
L817: R7 >= ( ( 0 ) + 1 ) by NAT_1:13;
L818: R7 > 1 by L817 , L816 , XXREAL_0:1;
L819: R7 >= ( 1 + 1 ) by L818 , NAT_1:13;
consider C217 being (Element of ( NAT )) such that L820: C217 is  prime and L821: C217 divides R7 by L819 , INT_2:31;
L822: C217 > 1 by L820 , INT_2:def 4;
L823: ( C217 |-count R7 ) <> ( 0 ) by L822 , L821 , L560;
L824: ( ( pfexp R7 ) . C217 ) <> ( 0 ) by L823 , L820 , L628;
thus L825: contradiction by L824 , L815 , PRE_POLY:def 7;
end;
theorem
L826: (for B104 , B105 being non  empty Nat holds ( pfexp ( B105 gcd B104 ) ) = ( min (( pfexp B105 ) , ( pfexp B104 )) ))
proof
let C218 , C219 being non  empty Nat;
L827:
now
set D106 = ( min (( pfexp C219 ) , ( pfexp C218 )) );
set D107 = ( pfexp ( C219 gcd C218 ) );
let C220 being set;
assume L828: C220 in ( SetPrimes );
reconsider D108 = C220 as  prime (Element of ( NAT )) by L828 , NEWTON:def 6;
set D109 = ( D108 |-count C219 );
set D110 = ( D108 |-count C218 );
set D111 = ( D108 |-count ( C219 gcd C218 ) );
L829: ( D107 . D108 ) = D111 by L628;
L830: D108 <> 1 by INT_2:def 4;
L831: ( D108 |^ D109 ) divides C219 by L830 , L464;
L832: ( C219 gcd C218 ) <> ( 0 ) by INT_2:5;
L833: ( D108 |^ D111 ) divides ( C219 gcd C218 ) by L832 , L830 , L464;
L834: (not ( D108 |^ ( D111 + 1 ) ) divides ( C219 gcd C218 )) by L830 , L832 , L464;
L835: (not ( D108 |^ ( D110 + 1 ) ) divides C218) by L830 , L464;
L836: ( D108 |^ D110 ) divides C218 by L830 , L464;
L837: ( C219 gcd C218 ) divides C218 by NAT_D:def 5;
L838: ( D108 |^ D111 ) divides C218 by L837 , L833 , NAT_D:4;
L839: ( ( pfexp C219 ) . D108 ) = D109 by L628;
L840: ( C219 gcd C218 ) divides C219 by NAT_D:def 5;
L841: ( D108 |^ D111 ) divides C219 by L840 , L833 , NAT_D:4;
L842: ( ( pfexp C218 ) . D108 ) = D110 by L628;
L843: (not ( D108 |^ ( D109 + 1 ) ) divides C219) by L830 , L464;
thus L844: ( D107 . C220 ) = ( D106 . C220 )
proof
per cases ;
suppose L845: ( ( pfexp C219 ) . D108 ) <= ( ( pfexp C218 ) . D108 );

L846:
now
assume L847: D111 < D109;
L848: D111 < D110 by L847 , L839 , L842 , L845 , XXREAL_0:2;
L849: ( D108 |^ ( D111 + 1 ) ) divides C218 by L848 , L836 , L32;
L850: ( D108 |^ ( D111 + 1 ) ) divides C219 by L831 , L847 , L32;
thus L851: contradiction by L850 , L834 , L849 , NAT_D:def 5;
end;
L852: D111 <= D109 by L843 , L841 , L32;
L853: ( D106 . D108 ) = D109 by L839 , L845 , L232;
thus L854: thesis by L853 , L829 , L852 , L846 , XXREAL_0:1;
end;
suppose L855: ( ( pfexp C219 ) . D108 ) > ( ( pfexp C218 ) . D108 );

L856:
now
assume L857: D111 < D110;
L858: D111 < D109 by L857 , L839 , L842 , L855 , XXREAL_0:2;
L859: ( D108 |^ ( D111 + 1 ) ) divides C219 by L858 , L831 , L32;
L860: ( D108 |^ ( D111 + 1 ) ) divides C218 by L836 , L857 , L32;
thus L861: contradiction by L860 , L834 , L859 , NAT_D:def 5;
end;
L862: D111 <= D110 by L835 , L838 , L32;
L863: ( D106 . D108 ) = D110 by L842 , L855 , L232;
thus L864: thesis by L863 , L829 , L862 , L856 , XXREAL_0:1;
end;
end;

end;
thus L845: thesis by L827 , PBOOLE:3;
end;
theorem
L846: (for B106 , B107 being non  empty Nat holds ( pfexp ( B107 lcm B106 ) ) = ( max (( pfexp B107 ) , ( pfexp B106 )) ))
proof
let C221 , C222 being non  empty Nat;
L847:
now
set D112 = ( max (( pfexp C222 ) , ( pfexp C221 )) );
set D113 = ( pfexp ( C222 lcm C221 ) );
let C223 being set;
L848: C221 divides ( C222 lcm C221 ) by NAT_D:def 4;
assume L849: C223 in ( SetPrimes );
reconsider D114 = C223 as  prime (Element of ( NAT )) by L849 , NEWTON:def 6;
set D115 = ( D114 |-count C222 );
set D116 = ( D114 |-count C221 );
set D117 = ( D114 |-count ( C222 lcm C221 ) );
L850: ( D113 . D114 ) = D117 by L628;
L851: ( ( pfexp C222 ) . D114 ) = D115 by L628;
L852: D114 > 1 by INT_2:def 4;
L853: (not ( D114 |^ ( D115 + 1 ) ) divides C222) by L852 , L464;
L854: ( C222 lcm C221 ) <> ( 0 ) by INT_2:4;
L855: ( D114 |^ D117 ) divides ( C222 lcm C221 ) by L854 , L852 , L464;
L856: (not ( D114 |^ ( D117 + 1 ) ) divides ( C222 lcm C221 )) by L852 , L854 , L464;
L857: ( ( pfexp C221 ) . D114 ) = D116 by L628;
L858: C222 divides ( C222 lcm C221 ) by NAT_D:def 4;
L859: ( D114 |^ D115 ) divides C222 by L852 , L464;
L860: ( D114 |^ D115 ) divides ( C222 lcm C221 ) by L859 , L858 , NAT_D:4;
L861: (not ( D114 |^ ( D116 + 1 ) ) divides C221) by L852 , L464;
L862: ( D114 |^ D116 ) divides C221 by L852 , L464;
L863: ( D114 |^ D116 ) divides ( C222 lcm C221 ) by L862 , L848 , NAT_D:4;
thus L864: ( D113 . C223 ) = ( D112 . C223 )
proof
per cases ;
suppose L865: ( ( pfexp C222 ) . D114 ) <= ( ( pfexp C221 ) . D114 );

L866:
now
consider C224 being Nat such that L867: D116 = ( D115 + C224 ) by L851 , L857 , L865 , NAT_1:10;
consider C225 being Nat such that L868: C222 = ( ( D114 |^ D115 ) * C225 ) by L859 , NAT_D:def 3;
L869:
now
assume L870: D114 divides C225;
consider C226 being Nat such that L871: C225 = ( D114 * C226 ) by L870 , NAT_D:def 3;
L872: C222 = ( ( ( D114 |^ D115 ) * D114 ) * C226 ) by L868 , L871
.= ( ( D114 |^ ( D115 + 1 ) ) * C226 ) by NEWTON:6;
thus L873: contradiction by L872 , L853 , NAT_D:def 3;
end;
consider C227 being Nat such that L874: ( C222 lcm C221 ) = ( C222 * C227 ) by L858 , NAT_D:def 3;
assume L875: D116 < D117;
L876: ( D114 |^ ( D116 + 1 ) ) divides ( C222 lcm C221 ) by L875 , L855 , L32;
consider C228 being Nat such that L877: ( C222 lcm C221 ) = ( ( D114 |^ ( D116 + 1 ) ) * C228 ) by L876 , NAT_D:def 3;
L878: ( C222 lcm C221 ) = ( ( ( D114 |^ D116 ) * D114 ) * C228 ) by L877 , NEWTON:6
.= ( ( D114 |^ D116 ) * ( C228 * D114 ) );
L879: ( ( D114 |^ D115 ) * ( ( D114 |^ C224 ) * ( C228 * D114 ) ) ) = ( ( ( D114 |^ D115 ) * ( D114 |^ C224 ) ) * ( C228 * D114 ) )
.= ( ( D114 |^ D115 ) * ( C225 * C227 ) ) by L878 , L868 , L874 , L867 , NEWTON:8;
L880: ( ( ( D114 |^ C224 ) * C228 ) * D114 ) = ( C225 * C227 ) by L879 , XCMPLX_1:5;
L881: D114 divides ( C225 * C227 ) by L880 , NAT_D:def 3;
L882: D114 divides C227 by L881 , L869 , NEWTON:80;
consider C229 being Nat such that L883: C227 = ( D114 * C229 ) by L882 , NAT_D:def 3;
L884: ( ( ( D114 |^ D116 ) * C228 ) * D114 ) = ( ( C222 * C229 ) * D114 ) by L878 , L874 , L883;
L885: ( ( D114 |^ D116 ) * C228 ) = ( C222 * C229 ) by L884 , XCMPLX_1:5;
L886: C222 divides ( ( D114 |^ D116 ) * C228 ) by L885 , NAT_D:def 3;
consider C230 being Nat such that L887: C221 = ( ( D114 |^ D116 ) * C230 ) by L862 , NAT_D:def 3;
L888:
now
assume L889: D114 divides C230;
consider C231 being Nat such that L890: C230 = ( D114 * C231 ) by L889 , NAT_D:def 3;
L891: C221 = ( ( ( D114 |^ D116 ) * D114 ) * C231 ) by L887 , L890
.= ( ( D114 |^ ( D116 + 1 ) ) * C231 ) by NEWTON:6;
thus L892: contradiction by L891 , L861 , NAT_D:def 3;
end;
consider C232 being Nat such that L893: ( C222 lcm C221 ) = ( C221 * C232 ) by L848 , NAT_D:def 3;
L894: ( ( D114 |^ D116 ) * ( C228 * D114 ) ) = ( ( D114 |^ D116 ) * ( C230 * C232 ) ) by L878 , L887 , L893;
L895: ( C228 * D114 ) = ( C230 * C232 ) by L894 , XCMPLX_1:5;
L896: D114 divides ( C230 * C232 ) by L895 , NAT_D:def 3;
L897: D114 divides C232 by L896 , L888 , NEWTON:80;
consider C233 being Nat such that L898: C232 = ( D114 * C233 ) by L897 , NAT_D:def 3;
L899: ( ( ( D114 |^ D116 ) * C228 ) * D114 ) = ( ( C221 * C233 ) * D114 ) by L878 , L893 , L898;
L900: ( ( D114 |^ D116 ) * C228 ) = ( C221 * C233 ) by L899 , XCMPLX_1:5;
L901: C221 divides ( ( D114 |^ D116 ) * C228 ) by L900 , NAT_D:def 3;
L902: ( C222 lcm C221 ) divides ( ( D114 |^ D116 ) * C228 ) by L901 , L886 , NAT_D:def 4;
L903: ( 0 ) <> C228 by L877 , INT_2:4;
L904: ( D114 |^ ( D116 + 1 ) ) <= ( D114 |^ D116 ) by L903 , L877 , L902 , NAT_D:7 , XREAL_1:68;
L905: ( ( D114 |^ D116 ) * D114 ) <= ( ( D114 |^ D116 ) * 1 ) by L904 , NEWTON:6;
L906: D114 <= 1 by L905 , XREAL_1:68;
thus L907: contradiction by L906 , INT_2:def 4;
end;
L908: D116 <= D117 by L856 , L863 , L32;
L909: ( D112 . D114 ) = D116 by L857 , L865 , L270;
thus L910: thesis by L909 , L850 , L908 , L866 , XXREAL_0:1;
end;
suppose L911: ( ( pfexp C222 ) . D114 ) > ( ( pfexp C221 ) . D114 );

L912:
now
consider C234 being Nat such that L913: D115 = ( D116 + C234 ) by L851 , L857 , L911 , NAT_1:10;
consider C235 being Nat such that L914: C221 = ( ( D114 |^ D116 ) * C235 ) by L862 , NAT_D:def 3;
L915:
now
assume L916: D114 divides C235;
consider C236 being Nat such that L917: C235 = ( D114 * C236 ) by L916 , NAT_D:def 3;
L918: C221 = ( ( ( D114 |^ D116 ) * D114 ) * C236 ) by L914 , L917
.= ( ( D114 |^ ( D116 + 1 ) ) * C236 ) by NEWTON:6;
thus L919: contradiction by L918 , L861 , NAT_D:def 3;
end;
consider C237 being Nat such that L920: ( C222 lcm C221 ) = ( C221 * C237 ) by L848 , NAT_D:def 3;
assume L921: D115 < D117;
L922: ( D114 |^ ( D115 + 1 ) ) divides ( C222 lcm C221 ) by L921 , L855 , L32;
consider C238 being Nat such that L923: ( C222 lcm C221 ) = ( ( D114 |^ ( D115 + 1 ) ) * C238 ) by L922 , NAT_D:def 3;
L924: ( C222 lcm C221 ) = ( ( ( D114 |^ D115 ) * D114 ) * C238 ) by L923 , NEWTON:6
.= ( ( D114 |^ D115 ) * ( C238 * D114 ) );
L925: ( ( D114 |^ D116 ) * ( ( D114 |^ C234 ) * ( C238 * D114 ) ) ) = ( ( ( D114 |^ D116 ) * ( D114 |^ C234 ) ) * ( C238 * D114 ) )
.= ( ( D114 |^ D116 ) * ( C235 * C237 ) ) by L924 , L914 , L920 , L913 , NEWTON:8;
L926: ( C235 * C237 ) = ( ( ( D114 |^ C234 ) * C238 ) * D114 ) by L925 , XCMPLX_1:5;
L927: D114 divides ( C235 * C237 ) by L926 , NAT_D:def 3;
L928: D114 divides C237 by L927 , L915 , NEWTON:80;
consider C239 being Nat such that L929: C237 = ( D114 * C239 ) by L928 , NAT_D:def 3;
L930: ( ( ( D114 |^ D115 ) * C238 ) * D114 ) = ( ( C221 * C239 ) * D114 ) by L924 , L920 , L929;
L931: ( ( D114 |^ D115 ) * C238 ) = ( C221 * C239 ) by L930 , XCMPLX_1:5;
L932: C221 divides ( ( D114 |^ D115 ) * C238 ) by L931 , NAT_D:def 3;
consider C240 being Nat such that L933: C222 = ( ( D114 |^ D115 ) * C240 ) by L859 , NAT_D:def 3;
L934:
now
assume L935: D114 divides C240;
consider C241 being Nat such that L936: C240 = ( D114 * C241 ) by L935 , NAT_D:def 3;
L937: C222 = ( ( ( D114 |^ D115 ) * D114 ) * C241 ) by L933 , L936
.= ( ( D114 |^ ( D115 + 1 ) ) * C241 ) by NEWTON:6;
thus L938: contradiction by L937 , L853 , NAT_D:def 3;
end;
consider C242 being Nat such that L939: ( C222 lcm C221 ) = ( C222 * C242 ) by L858 , NAT_D:def 3;
L940: ( ( D114 |^ D115 ) * ( C238 * D114 ) ) = ( ( D114 |^ D115 ) * ( C240 * C242 ) ) by L924 , L933 , L939;
L941: ( C238 * D114 ) = ( C240 * C242 ) by L940 , XCMPLX_1:5;
L942: D114 divides ( C240 * C242 ) by L941 , NAT_D:def 3;
L943: D114 divides C242 by L942 , L934 , NEWTON:80;
consider C243 being Nat such that L944: C242 = ( D114 * C243 ) by L943 , NAT_D:def 3;
L945: ( ( ( D114 |^ D115 ) * C238 ) * D114 ) = ( ( C222 * C243 ) * D114 ) by L924 , L939 , L944;
L946: ( ( D114 |^ D115 ) * C238 ) = ( C222 * C243 ) by L945 , XCMPLX_1:5;
L947: C222 divides ( ( D114 |^ D115 ) * C238 ) by L946 , NAT_D:def 3;
L948: ( C222 lcm C221 ) divides ( ( D114 |^ D115 ) * C238 ) by L947 , L932 , NAT_D:def 4;
L949: ( 0 ) <> C238 by L923 , INT_2:4;
L950: ( D114 |^ ( D115 + 1 ) ) <= ( D114 |^ D115 ) by L949 , L923 , L948 , NAT_D:7 , XREAL_1:68;
L951: ( ( D114 |^ D115 ) * D114 ) <= ( ( D114 |^ D115 ) * 1 ) by L950 , NEWTON:6;
L952: D114 <= 1 by L951 , XREAL_1:68;
thus L953: contradiction by L952 , INT_2:def 4;
end;
L954: D115 <= D117 by L856 , L860 , L32;
L955: ( D112 . D114 ) = D115 by L851 , L911 , L270;
thus L956: thesis by L955 , L850 , L954 , L912 , XXREAL_0:1;
end;
end;

end;
thus L865: thesis by L847 , PBOOLE:3;
end;
begin
definition
let C244 being non  empty Nat;
func prime_factorization C244 -> (ManySortedSet of ( SetPrimes )) means 
:L866: (( support it ) = ( support ( pfexp C244 ) ) & (for B108 being Nat holds (B108 in ( support ( pfexp C244 ) ) implies ( it . B108 ) = ( B108 |^ ( B108 |-count C244 ) ))));
existence
proof
defpred S14[ set , set ] means (for B109 being Prime holds ($1 = B109 implies ((B109 in ( support ( pfexp C244 ) ) implies $2 = ( B109 |^ ( B109 |-count C244 ) )) & ((not B109 in ( support ( pfexp C244 ) )) implies $2 = ( 0 )))));
L867: (for B110 being set holds (B110 in ( SetPrimes ) implies (ex B111 being set st S14[ B110 , B111 ])))
proof
let C245 being set;
assume L868: C245 in ( SetPrimes );
reconsider D118 = C245 as  prime (Element of ( NAT )) by L868 , NEWTON:def 6;
per cases ;
suppose L869: D118 in ( support ( pfexp C244 ) );

take ( D118 |^ ( D118 |-count C244 ) );
let C246 being Prime;
assume L870: C246 = C245;
thus L871: thesis by L870 , L869;
end;
suppose L872: (not D118 in ( support ( pfexp C244 ) ));

take ( 0 );
let C247 being Prime;
assume L873: C247 = C245;
thus L874: thesis by L873 , L872;
end;
end;
consider C248 being Function such that L876: ( dom C248 ) = ( SetPrimes ) and L877: (for B112 being set holds (B112 in ( SetPrimes ) implies S14[ B112 , ( C248 . B112 ) ])) from CLASSES1:sch 1(L867);
L878: ( support C248 ) c= ( SetPrimes ) by L876 , PRE_POLY:37;
L879:
now
let C249 being set;
thus L880:now
assume L881: C249 in ( support C248 );
L882: C249 in ( SetPrimes ) by L881 , L878;
reconsider D119 = C249 as  prime (Element of ( NAT )) by L882 , NEWTON:def 6;
assume L883: (not C249 in ( support ( pfexp C244 ) ));
L884: ( C248 . D119 ) = ( 0 ) by L883 , L877 , L878 , L881;
thus L885: contradiction by L884 , L881 , PRE_POLY:def 7;
end;
assume L886: C249 in ( support ( pfexp C244 ) );
L887: C249 in ( SetPrimes ) by L886;
reconsider D120 = C249 as  prime (Element of ( NAT )) by L887 , NEWTON:def 6;
L888: ( C248 . D120 ) = ( D120 |^ ( D120 |-count C244 ) ) by L877 , L886;
thus L889: C249 in ( support C248 ) by L888 , PRE_POLY:def 7;
end;
reconsider D121 = C248 as (ManySortedSet of ( SetPrimes )) by L876 , PARTFUN1:def 2 , RELAT_1:def 18;
take D121;
thus L890: ( support D121 ) = ( support ( pfexp C244 ) ) by L879 , TARSKI:1;
let C250 being Nat;
assume L891: C250 in ( support ( pfexp C244 ) );
L892: C250 is Prime by L891 , L648;
thus L893: thesis by L892 , L877 , L891;
end;
uniqueness
proof
let C251 , C252 being (ManySortedSet of ( SetPrimes ));
assume that
L894: ( support C251 ) = ( support ( pfexp C244 ) )
and
L895: (for B113 being Nat holds (B113 in ( support ( pfexp C244 ) ) implies ( C251 . B113 ) = ( B113 |^ ( B113 |-count C244 ) )))
and
L896: ( support C252 ) = ( support ( pfexp C244 ) )
and
L897: (for B114 being Nat holds (B114 in ( support ( pfexp C244 ) ) implies ( C252 . B114 ) = ( B114 |^ ( B114 |-count C244 ) )));
L898:
now
let C253 being set;
assume L899: C253 in ( SetPrimes );
reconsider D122 = C253 as  prime (Element of ( NAT )) by L899 , NEWTON:def 6;
per cases ;
suppose L900: D122 in ( support ( pfexp C244 ) );

thus L901: ( C251 . C253 ) = ( D122 |^ ( D122 |-count C244 ) ) by L900 , L895
.= ( C252 . C253 ) by L897 , L900;
end;
suppose L902: (not D122 in ( support ( pfexp C244 ) ));

thus L903: ( C251 . C253 ) = ( 0 ) by L902 , L894 , PRE_POLY:def 7
.= ( C252 . C253 ) by L896 , L902 , PRE_POLY:def 7;
end;
end;
thus L905: C251 = C252 by L898 , PBOOLE:3;
end;
end;
notation
let C254 being non  empty Nat;
synonym ppf C254 for prime_factorization C254;
end;
registration
let C255 being non  empty Nat;
cluster ( ppf C255 ) ->  natural-valued  finite-support;
coherence
proof
L908: ( rng ( ppf C255 ) ) c= ( NAT )
proof
let C256 being set;
assume L909: C256 in ( rng ( ppf C255 ) );
consider C257 being set such that L910: C257 in ( dom ( ppf C255 ) ) and L911: ( ( ppf C255 ) . C257 ) = C256 by L909 , FUNCT_1:def 3;
L912: ( dom ( ppf C255 ) ) = ( SetPrimes ) by PARTFUN1:def 2;
reconsider D123 = C257 as  prime (Element of ( NAT )) by L912 , L910 , NEWTON:def 6;
per cases ;
suppose L913: D123 in ( support ( pfexp C255 ) );

L914: ( ( ppf C255 ) . D123 ) = ( D123 |^ ( D123 |-count C255 ) ) by L913 , L866;
thus L915: thesis by L914 , L911;
end;
suppose L916: (not D123 in ( support ( pfexp C255 ) ));

L917: (not D123 in ( support ( ppf C255 ) )) by L916 , L866;
L918: ( ( ppf C255 ) . D123 ) = ( 0 ) by L917 , PRE_POLY:def 7;
thus L919: thesis by L918 , L911;
end;
end;
thus L921: ( ppf C255 ) is  natural-valued by L908 , VALUED_0:def 6;
L922: ( support ( ppf C255 ) ) = ( support ( pfexp C255 ) ) by L866;
thus L923: ( support ( ppf C255 ) ) is  finite by L922;
end;
end;
theorem
L925: (for R6 being Prime holds (for R7 being non  empty Nat holds (( R6 |-count R7 ) = ( 0 ) implies ( ( ppf R7 ) . R6 ) = ( 0 ))))
proof
let R6 being Prime;
let R7 being non  empty Nat;
assume L926: ( R6 |-count R7 ) = ( 0 );
L927: ( ( pfexp R7 ) . R6 ) = ( 0 ) by L926 , L628;
L928: (not R6 in ( support ( pfexp R7 ) )) by L927 , PRE_POLY:def 7;
L929: (not R6 in ( support ( ppf R7 ) )) by L928 , L866;
thus L930: thesis by L929 , PRE_POLY:def 7;
end;
theorem
L931: (for R6 being Prime holds (for R7 being non  empty Nat holds (( R6 |-count R7 ) <> ( 0 ) implies ( ( ppf R7 ) . R6 ) = ( R6 |^ ( R6 |-count R7 ) ))))
proof
let R6 being Prime;
let R7 being non  empty Nat;
assume L932: ( R6 |-count R7 ) <> ( 0 );
L933: ( ( pfexp R7 ) . R6 ) <> ( 0 ) by L932 , L628;
L934: R6 in ( support ( pfexp R7 ) ) by L933 , PRE_POLY:def 7;
thus L935: thesis by L934 , L866;
end;
theorem
L936: (for R7 being non  empty Nat holds (( support ( ppf R7 ) ) = ( {} ) implies R7 = 1))
proof
let R7 being non  empty Nat;
assume L937: ( support ( ppf R7 ) ) = ( {} );
L938: ( support ( pfexp R7 ) ) = ( {} ) by L937 , L866;
thus L939: thesis by L938 , L814;
end;
theorem
L940: (for B115 , B116 being non  empty Nat holds (B115 , B116 are_relative_prime  implies ( ppf ( B115 * B116 ) ) = ( ( ppf B115 ) + ( ppf B116 ) )))
proof
let C258 , C259 being non  empty Nat;
assume that
L941: C258 , C259 are_relative_prime ;
reconsider D124 = C258 , D125 = C259 as non  empty Nat;
L942:
now
L943: ( C258 gcd C259 ) = 1 by L941 , INT_2:def 3;
let C260 being set;
assume L944: C260 in ( SetPrimes );
reconsider D126 = C260 as  prime (Element of ( NAT )) by L944 , NEWTON:def 6;
L945: D126 > 1 by INT_2:def 4;
L946: ( D126 |-count ( D124 * D125 ) ) = ( ( D126 |-count C258 ) + ( D126 |-count C259 ) ) by L572;
per cases ;
suppose L947: ( D126 |-count ( C258 * C259 ) ) = ( 0 );

L948: ( D126 |-count C259 ) = ( 0 ) by L947 , L946;
L949: ( D126 |-count C258 ) = ( 0 ) by L946 , L947;
thus L950: ( ( ppf ( C258 * C259 ) ) . C260 ) = ( 0 ) by L947 , L925
.= ( ( 0 ) + ( ( ppf C259 ) . C260 ) ) by L948 , L925
.= ( ( ( ppf C258 ) . C260 ) + ( ( ppf C259 ) . C260 ) ) by L949 , L925
.= ( ( ( ppf C258 ) + ( ppf C259 ) ) . C260 ) by PRE_POLY:def 5;
end;
suppose L951: ( D126 |-count ( C258 * C259 ) ) <> ( 0 );

thus L952: ( ( ppf ( C258 * C259 ) ) . C260 ) = ( ( ( ppf C258 ) + ( ppf C259 ) ) . C260 )
proof
per cases  by L946 , L951;
suppose L953: ( D126 |-count C258 ) <> ( 0 );

L954:
now
consider C261 being Nat such that L955: ( D126 |-count C258 ) = ( C261 + 1 ) by L953 , NAT_1:6;
L956: ( D126 |^ ( D126 |-count C258 ) ) divides C258 by L945 , L464;
L957: ( D126 * ( D126 |^ C261 ) ) divides C258 by L956 , L955 , NEWTON:6;
consider C262 being Nat such that L958: C258 = ( ( D126 * ( D126 |^ C261 ) ) * C262 ) by L957 , NAT_D:def 3;
L959: C258 = ( D126 * ( ( D126 |^ C261 ) * C262 ) ) by L958;
L960: D126 divides C258 by L959 , NAT_D:def 3;
assume L961: ( D126 |-count C259 ) <> ( 0 );
consider C263 being Nat such that L962: ( D126 |-count C259 ) = ( C263 + 1 ) by L961 , NAT_1:6;
L963: ( D126 |^ ( D126 |-count C259 ) ) divides C259 by L945 , L464;
L964: ( D126 * ( D126 |^ C263 ) ) divides C259 by L963 , L962 , NEWTON:6;
consider C264 being Nat such that L965: C259 = ( ( D126 * ( D126 |^ C263 ) ) * C264 ) by L964 , NAT_D:def 3;
L966: C259 = ( D126 * ( ( D126 |^ C263 ) * C264 ) ) by L965;
L967: D126 divides C259 by L966 , NAT_D:def 3;
L968: D126 divides 1 by L967 , L943 , L960 , NAT_D:def 5;
thus L969: contradiction by L968 , L945 , NAT_D:7;
end;
thus L970: ( ( ppf ( C258 * C259 ) ) . C260 ) = ( D126 |^ ( D126 |-count C258 ) ) by L954 , L946 , L951 , L931
.= ( ( ( ppf C258 ) . D126 ) + ( 0 ) ) by L953 , L931
.= ( ( ( ppf C258 ) . D126 ) + ( ( ppf C259 ) . D126 ) ) by L954 , L925
.= ( ( ( ppf C258 ) + ( ppf C259 ) ) . C260 ) by PRE_POLY:def 5;
end;
suppose L971: ( D126 |-count C259 ) <> ( 0 );

L972:
now
assume L973: ( D126 |-count C258 ) <> ( 0 );
consider C265 being Nat such that L974: ( D126 |-count C258 ) = ( C265 + 1 ) by L973 , NAT_1:6;
L975: ( D126 |^ ( D126 |-count C258 ) ) divides C258 by L945 , L464;
L976: ( D126 * ( D126 |^ C265 ) ) divides C258 by L975 , L974 , NEWTON:6;
consider C266 being Nat such that L977: C258 = ( ( D126 * ( D126 |^ C265 ) ) * C266 ) by L976 , NAT_D:def 3;
L978: C258 = ( D126 * ( ( D126 |^ C265 ) * C266 ) ) by L977;
L979: D126 divides C258 by L978 , NAT_D:def 3;
consider C267 being Nat such that L980: ( D126 |-count C259 ) = ( C267 + 1 ) by L971 , NAT_1:6;
L981: ( D126 |^ ( D126 |-count C259 ) ) divides C259 by L945 , L464;
L982: ( D126 * ( D126 |^ C267 ) ) divides C259 by L981 , L980 , NEWTON:6;
consider C268 being Nat such that L983: C259 = ( ( D126 * ( D126 |^ C267 ) ) * C268 ) by L982 , NAT_D:def 3;
L984: C259 = ( D126 * ( ( D126 |^ C267 ) * C268 ) ) by L983;
L985: D126 divides C259 by L984 , NAT_D:def 3;
L986: D126 divides 1 by L985 , L943 , L979 , NAT_D:def 5;
thus L987: contradiction by L986 , L945 , NAT_D:7;
end;
thus L988: ( ( ppf ( C258 * C259 ) ) . C260 ) = ( D126 |^ ( D126 |-count C259 ) ) by L972 , L946 , L951 , L931
.= ( ( 0 ) + ( ( ppf C259 ) . D126 ) ) by L971 , L931
.= ( ( ( ppf C258 ) . D126 ) + ( ( ppf C259 ) . D126 ) ) by L972 , L925
.= ( ( ( ppf C258 ) + ( ppf C259 ) ) . C260 ) by PRE_POLY:def 5;
end;
end;

end;
end;
thus L954: thesis by L942 , PBOOLE:3;
end;
theorem
L955: (for R6 being Prime holds (for R7 being non  empty Nat holds ( ( ppf ( R6 |^ R7 ) ) . R6 ) = ( R6 |^ R7 )))
proof
let R6 being Prime;
let R7 being non  empty Nat;
L956: R6 > 1 by INT_2:def 4;
L957: ( R6 |-count ( R6 |^ R7 ) ) = R7 by L956 , L544;
thus L958: thesis by L957 , L931;
end;
theorem
L959: (for R7 being non  empty Nat holds (for R8 being non  empty Nat holds ( ppf ( R7 |^ R8 ) ) = ( ( ppf R7 ) |^ R8 )))
proof
let R7 being non  empty Nat;
let R8 being non  empty Nat;
L960:
now
let C269 being set;
L961: R8 >= ( ( 0 ) + 1 ) by NAT_1:13;
L962: ( ( ( ppf R7 ) |^ R8 ) . C269 ) = ( ( ( ppf R7 ) . C269 ) |^ R8 ) by L407;
assume L963: C269 in ( SetPrimes );
reconsider D127 = C269 as  prime (Element of ( NAT )) by L963 , NEWTON:def 6;
L964: ( D127 |-count ( R7 |^ R8 ) ) = ( R8 * ( D127 |-count R7 ) ) by L619;
per cases ;
suppose L965: ( D127 |-count R7 ) = ( 0 );

thus L966: ( ( ppf ( R7 |^ R8 ) ) . C269 ) = ( 0 ) by L965 , L964 , L925
.= ( (( 0 ) qua Nat) |^ R8 ) by L961 , NEWTON:11
.= ( ( ( ppf R7 ) |^ R8 ) . C269 ) by L962 , L965 , L925;
end;
suppose L967: ( D127 |-count R7 ) <> ( 0 );

thus L968: ( ( ppf ( R7 |^ R8 ) ) . C269 ) = ( D127 |^ ( D127 |-count ( R7 |^ R8 ) ) ) by L967 , L964 , L931
.= ( ( D127 |^ ( D127 |-count R7 ) ) |^ R8 ) by L964 , NEWTON:9
.= ( ( ( ppf R7 ) |^ R8 ) . C269 ) by L962 , L967 , L931;
end;
end;
thus L970: thesis by L960 , PBOOLE:3;
end;
::$N Fundamental Theorem of Arithmetic
theorem
L971: (for R7 being non  empty Nat holds ( Product ( ppf R7 ) ) = R7)
proof
let R7 being non  empty Nat;
defpred S15[ Nat ] means (for B117 being non  empty Nat holds (( support ( ppf B117 ) ) c= ( Seg $1 ) implies ( Product ( ppf B117 ) ) = B117));
L972: ( support ( ppf R7 ) ) = ( support ( pfexp R7 ) ) by L866;
L973: S15[ ( 0 ) ]
proof
let C270 being non  empty Nat;
L974: ( {} ) c= ( support ( ppf C270 ) ) by XBOOLE_1:2;
assume L975: ( support ( ppf C270 ) ) c= ( Seg ( 0 ) );
L976: ( support ( ppf C270 ) ) = ( {} ) by L975 , L974 , XBOOLE_0:def 10;
L977:
now
reconsider D128 = C270 as Nat;
assume L978: C270 <> 1;
L979: D128 > 1 by L978 , NAT_1:53;
L980: D128 >= ( 1 + 1 ) by L979 , NAT_1:13;
L981: (ex B118 being (Element of ( NAT )) st (B118 is  prime & B118 divides D128)) by L980 , INT_2:31;
L982: ( support ( pfexp C270 ) ) is non  empty by L981 , L671;
thus L983: contradiction by L982 , L976 , L866;
end;
L984: ( ppf C270 ) = ( EmptyBag ( SetPrimes ) ) by L976 , BAGORDER:19;
thus L985: thesis by L984 , L977 , L458;
end;
L986: (for B119 being Nat holds (S15[ B119 ] implies S15[ ( B119 + 1 ) ]))
proof
let C271 being Nat;
assume L987: S15[ C271 ];
let C272 being non  empty Nat;
assume that
L988: ( support ( ppf C272 ) ) c= ( Seg ( C271 + 1 ) );
L989: ( support ( ppf C272 ) ) = ( support ( pfexp C272 ) ) by L866;
per cases ;
suppose L990: (not ( support ( ppf C272 ) ) c= ( Seg C271 ));

set D129 = ( C271 + 1 );
set D130 = ( D129 |-count C272 );
set D131 = ( D129 |^ D130 );
L991:
now
assume L992: (not ( C271 + 1 ) in ( support ( ppf C272 ) ));
L993: ( support ( ppf C272 ) ) c= ( Seg C271 )
proof
let C273 being set;
assume L994: C273 in ( support ( ppf C272 ) );
reconsider D132 = C273 as Nat by L994;
L995: D132 <= ( C271 + 1 ) by L988 , L994 , FINSEQ_1:1;
L996: D132 < ( C271 + 1 ) by L995 , L992 , L994 , XXREAL_0:1;
L997: D132 <= C271 by L996 , NAT_1:13;
L998: C273 is Prime by L989 , L994 , L648;
L999: 1 <= D132 by L998 , INT_2:def 4;
thus L1000: thesis by L999 , L997 , FINSEQ_1:1;
end;
thus L1001: contradiction by L993 , L990;
end;
L1002: D129 is Prime by L991 , L989 , L648;
L1003: D129 > 1 by L1002 , INT_2:def 4;
L1004: D131 divides C272 by L1003 , L464;
consider C274 being Nat such that L1005: C272 = ( D131 * C274 ) by L1004 , NAT_D:def 3;
reconsider D133 = D131 , D134 = C274 as non  empty Nat by L1005;
L1006: ( dom ( ppf D133 ) ) = ( SetPrimes ) by PARTFUN1:def 2;
L1007: ( ( pfexp C272 ) . D129 ) = D130 by L1002 , L628;
L1008: D130 <> ( 0 ) by L1007 , L989 , L991 , PRE_POLY:def 7;
reconsider D135 = D133 , D136 = D134 as non  empty Nat;
L1009: ( support ( ppf D134 ) ) = ( support ( pfexp D134 ) ) by L866;
L1010: ( support ( ppf D134 ) ) c= ( Seg C271 )
proof
set D137 = ( D129 |-count D134 );
let C275 being set;
assume L1011: C275 in ( support ( ppf D134 ) );
reconsider D138 = C275 as Nat by L1011;
L1012: C275 in ( support ( pfexp D134 ) ) by L1011 , L866;
L1013:
now
assume L1014: D138 = D129;
L1015: ( ( pfexp D134 ) . D129 ) = D137 by L1002 , L628;
L1016: D137 <> ( 0 ) by L1015 , L1012 , L1014 , PRE_POLY:def 7;
L1017: D137 >= ( ( 0 ) + 1 ) by L1016 , NAT_1:13;
consider C276 being Nat such that L1018: D137 = ( 1 + C276 ) by L1017 , NAT_1:10;
L1019: ( D129 |^ D137 ) divides D134 by L1003 , L464;
consider C277 being Nat such that L1020: D134 = ( ( D129 |^ D137 ) * C277 ) by L1019 , NAT_D:def 3;
L1021: C272 = ( D133 * ( ( ( D129 |^ C276 ) * D129 ) * C277 ) ) by L1005 , L1018 , L1020 , NEWTON:6
.= ( ( D133 * D129 ) * ( ( D129 |^ C276 ) * C277 ) )
.= ( ( D129 |^ ( D130 + 1 ) ) * ( ( D129 |^ C276 ) * C277 ) ) by NEWTON:6;
L1022: ( D129 |^ ( D130 + 1 ) ) divides C272 by L1021 , NAT_D:def 3;
thus L1023: contradiction by L1022 , L1003 , L464;
end;
L1024: ( support ( ppf D134 ) ) c= ( support ( ppf C272 ) ) by L989 , L1005 , L1009 , L753;
L1025: D138 in ( support ( ppf C272 ) ) by L1024 , L1011;
L1026: D138 <= ( C271 + 1 ) by L1025 , L988 , FINSEQ_1:1;
L1027: D138 < D129 by L1026 , L1013 , XXREAL_0:1;
L1028: D138 <= C271 by L1027 , NAT_1:13;
L1029: C275 is Prime by L1012 , L648;
L1030: 1 <= D138 by L1029 , INT_2:def 4;
thus L1031: thesis by L1030 , L1028 , FINSEQ_1:1;
end;
L1032: D135 , D136 are_relative_prime 
proof
set D139 = ( D135 gcd D136 );
L1033: D139 divides D136 by NAT_D:def 5;
L1034: D139 <> ( 0 ) by INT_2:5;
L1035: ( ( 0 ) + 1 ) <= D139 by L1034 , NAT_1:13;
assume L1036: ( D135 gcd D136 ) <> 1;
L1037: D139 > 1 by L1036 , L1035 , XXREAL_0:1;
L1038: D139 >= ( 1 + 1 ) by L1037 , NAT_1:13;
consider C278 being (Element of ( NAT )) such that L1039: C278 is  prime and L1040: C278 divides D139 by L1038 , INT_2:31;
L1041: D139 divides D135 by NAT_D:def 5;
L1042: C278 divides D135 by L1041 , L1040 , NAT_D:4;
L1043: C278 divides D129 by L1042 , L1039 , L38;
L1044: (C278 = 1 or C278 = D129) by L1043 , L1002 , INT_2:def 4;
L1045: D129 divides D136 by L1044 , L1039 , L1040 , L1033 , INT_2:def 4 , NAT_D:4;
L1046: D129 in ( support ( pfexp D134 ) ) by L1045 , L1002 , L671;
L1047: ( C271 + 1 ) <= C271 by L1046 , L1009 , L1010 , FINSEQ_1:1;
thus L1048: contradiction by L1047 , NAT_1:13;
end;
L1049: ( ppf C272 ) = ( ( ppf D133 ) + ( ppf D134 ) ) by L1032 , L1005 , L940;
consider C279 being (FinSequence of ( COMPLEX )) such that L1050: ( Product ( ppf D133 ) ) = ( Product C279 ) and L1051: C279 = ( ( ppf D133 ) * ( canFS ( support ( ppf D133 ) ) ) ) by L311;
L1052: ( support ( ppf D133 ) ) = ( support ( pfexp D133 ) ) by L866;
L1053: ( support ( ppf D133 ) ) = { D129 } by L1052 , L1002 , L1008 , L711;
L1054: C279 = ( ( ppf D133 ) * <* D129 *> ) by L1053 , L1051 , UPROOTS:4
.= <* ( ( ppf D133 ) . D129 ) *> by L991 , L1006 , FINSEQ_2:34;
L1055: ( Product ( ppf D133 ) ) = ( ( ppf D133 ) . D129 ) by L1054 , L1050 , RVSUM_1:95
.= D133 by L1002 , L1008 , L955;
L1056:
now
assume L1057: ( ( support ( ppf D133 ) ) /\ ( support ( ppf D134 ) ) ) <> ( {} );
consider C280 being set such that L1058: C280 in ( ( support ( ppf D133 ) ) /\ ( support ( ppf D134 ) ) ) by L1057 , XBOOLE_0:def 1;
L1059: C280 in ( support ( ppf D133 ) ) by L1058 , XBOOLE_0:def 4;
L1060: C280 = D129 by L1059 , L1053 , TARSKI:def 1;
L1061: C280 in ( support ( ppf D134 ) ) by L1058 , XBOOLE_0:def 4;
L1062: D129 <= C271 by L1061 , L1010 , L1060 , FINSEQ_1:1;
thus L1063: contradiction by L1062 , NAT_1:13;
end;
L1064: ( support ( ppf D133 ) ) misses ( support ( ppf D134 ) ) by L1056 , XBOOLE_0:def 7;
L1065: ( Product ( ppf D134 ) ) = D134 by L987 , L1010;
thus L1066: thesis by L1065 , L1005 , L1064 , L1049 , L1055 , L326;
end;
suppose L1067: ( support ( ppf C272 ) ) c= ( Seg C271 );

thus L1068: thesis by L1067 , L987;
end;
end;
L1070: (for B120 being Nat holds S15[ B120 ]) from NAT_1:sch 2(L973 , L986);
per cases ;
suppose L1071: ( support ( ppf R7 ) ) is  empty;

thus L1072: thesis by L1071 , L973;
end;
suppose L1073: ( support ( ppf R7 ) ) is non  empty;

reconsider D140 = ( support ( ppf R7 ) ) as  finite non  empty (Subset of ( NAT )) by L1073 , XBOOLE_1:1;
L1074: ( support ( ppf R7 ) ) c= ( Seg ( max D140 ) )
proof
let C281 being set;
assume L1075: C281 in ( support ( ppf R7 ) );
reconsider D141 = C281 as Nat by L1075;
L1076: C281 is Prime by L972 , L1075 , L648;
L1077: 1 <= D141 by L1076 , INT_2:def 4;
L1078: D141 <= ( max D140 ) by L1075 , XXREAL_2:def 8;
thus L1079: thesis by L1078 , L1077 , FINSEQ_1:1;
end;
thus L1080: thesis by L1074 , L1070;
end;
end;
