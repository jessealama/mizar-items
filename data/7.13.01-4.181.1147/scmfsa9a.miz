:: The { \bf while } macro instructions of SCM+FSA, Part { II }
::  by Piotr Rudnicki
::
:: Received June 3, 1998
:: Copyright (c) 1998-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, INT_1, AMI_1, SCMFSA_2, SF_MASTR, FUNCOP_1,
      FUNCT_1, FINSUB_1, CARD_3, RELAT_1, TARSKI, AMISTD_2, XBOOLE_0, CARD_1,
      SCMFSA8A, AMI_3, FSM_1, SCMFSA7B, SCMFSA8B, ARYTM_3, TURING_1, SCMFSA6A,
      ARYTM_1, VALUED_1, FUNCT_4, SCMFSA_9, UNIALG_2, SCMFSA6B, XXREAL_0,
      CIRCUIT2, GRAPHSP, NAT_1, SCMFSA6C, MSUALG_1, SFMASTR1, PRE_FF, COMPLEX1,
      ABIAN, SCMFSA9A, ORDINAL1, PARTFUN1, EXTPRO_1, RELOC, PBOOLE, COMPOS_1,
      MEMSTR_0, SCMPDS_4;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, FINSUB_1,
      FUNCOP_1, INT_1, ABIAN, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, PRE_FF,
      CARD_3, FUNCT_4, PBOOLE, VALUED_1, INT_2, XXREAL_0, ORDINAL1, NAT_1,
      MEMSTR_0, COMPOS_0, COMPOS_1, EXTPRO_1, AMISTD_1, AMISTD_2, SCMFSA_2,
      SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C, SCMFSA_7, SCMFSA7B, SCMFSA8A,
      SCMFSA8B, SCMFSA_9, SFMASTR1, SCMFSA_M;
 constructors NAT_D, PRE_FF, ABIAN, SCMFSA_7, SCMFSA6A, SCMFSA6B, MEMSTR_0,
      SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMFSA_9, SFMASTR1, AMISTD_2, RELSET_1,
      PRE_POLY, XXREAL_2, PBOOLE, SCMFSA7B, SCMFSA8C, FUNCT_4, AMISTD_1, AMI_3,
      SCMFSA_M, SF_MASTR;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FINSET_1,
      FINSUB_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, ABIAN,
      SCMFSA_2, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B,
      SCMFSA_9, SFMASTR1, VALUED_1, FUNCT_2, RELAT_1, AFINSQ_1, FUNCT_4,
      FUNCOP_1, SCMFSA10, AMISTD_2, SCMFSA6A, COMPOS_1, EXTPRO_1, PBOOLE,
      STRUCT_0, MEMSTR_0, FINSEQ_1, AMI_3, COMPOS_0, SCMFSA_M;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, SCMFSA6A, AFINSQ_1, COMPOS_1, EXTPRO_1, AMISTD_2,
      MEMSTR_0, SCMFSA_M;
 theorems TARSKI, ZFMISC_1, ABSVALUE, NAT_1, INT_1, NAT_2, FUNCT_1, FUNCT_2,
      GRFUNC_1, FUNCOP_1, FUNCT_4, PRE_FF, ABIAN, SCMFSA_2, MEMSTR_0, SCMFSA_4,
      SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B,
      SCMFSA8C, SCMFSA_9, SFMASTR1, RELAT_1, XBOOLE_0, XBOOLE_1, CARD_3,
      XREAL_1, XXREAL_0, ORDINAL1, NAT_D, VALUED_1, PBOOLE, PARTFUN1, FINSEQ_4,
      COMPOS_1, EXTPRO_1, SCMFSA_M;
 schemes FUNCT_2, NAT_1;

begin
theorem
L1: (for R6 being (Element of ( NAT )) holds (for R9 being (Instruction of ( SCM+FSA )) holds ( UsedIntLoc ( R6 .--> R9 ) ) = ( UsedIntLoc R9 )))
proof
let R6 being (Element of ( NAT ));
let R9 being (Instruction of ( SCM+FSA ));
set D1 = ( R6 .--> R9 );
consider C1 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L2: (for B1 being (Instruction of ( SCM+FSA )) holds ( C1 . B1 ) = ( UsedIntLoc B1 )) and L3: ( UsedIntLoc D1 ) = ( Union ( C1 * D1 ) ) by SF_MASTR:def 2;
L4: ( dom C1 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
thus L5: ( UsedIntLoc D1 ) = ( union ( rng ( C1 * ( { R6 } --> R9 ) ) ) ) by L3 , CARD_3:def 4
.= ( union ( rng ( { R6 } --> ( C1 . R9 ) ) ) ) by L4 , FUNCOP_1:17
.= ( union { ( C1 . R9 ) } ) by FUNCOP_1:8
.= ( union { ( UsedIntLoc R9 ) } ) by L2
.= ( UsedIntLoc R9 ) by ZFMISC_1:25;
end;
theorem
L6: (for R6 being (Element of ( NAT )) holds (for R9 being (Instruction of ( SCM+FSA )) holds ( UsedInt*Loc ( R6 .--> R9 ) ) = ( UsedInt*Loc R9 )))
proof
let R6 being (Element of ( NAT ));
let R9 being (Instruction of ( SCM+FSA ));
set D2 = ( R6 .--> R9 );
consider C2 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L7: (for B2 being (Instruction of ( SCM+FSA )) holds ( C2 . B2 ) = ( UsedInt*Loc B2 )) and L8: ( UsedInt*Loc D2 ) = ( Union ( C2 * D2 ) ) by SF_MASTR:def 4;
L9: ( dom C2 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
thus L10: ( UsedInt*Loc D2 ) = ( union ( rng ( C2 * ( { R6 } --> R9 ) ) ) ) by L8 , CARD_3:def 4
.= ( union ( rng ( { R6 } --> ( C2 . R9 ) ) ) ) by L9 , FUNCOP_1:17
.= ( union { ( C2 . R9 ) } ) by FUNCOP_1:8
.= ( union { ( UsedInt*Loc R9 ) } ) by L7
.= ( UsedInt*Loc R9 ) by ZFMISC_1:25;
end;
theorem
L11: ( UsedIntLoc ( Stop ( SCM+FSA ) ) ) = ( {} ) by L1 , SF_MASTR:13;
theorem
L12: ( UsedInt*Loc ( Stop ( SCM+FSA ) ) ) = ( {} )
proof
thus L13: ( UsedInt*Loc ( Stop ( SCM+FSA ) ) ) = ( UsedInt*Loc ( halt ( SCM+FSA ) ) ) by L6
.= ( {} ) by SF_MASTR:32;
end;
theorem
L14: (for R6 being (Element of ( NAT )) holds ( UsedIntLoc ( Goto R6 ) ) = ( {} ))
proof
let R6 being (Element of ( NAT ));
L15: ( Goto R6 ) = ( ( 0 ) .--> ( goto R6 ) ) by SCMFSA8A:def 1;
thus L16: ( UsedIntLoc ( Goto R6 ) ) = ( UsedIntLoc ( goto R6 ) ) by L15 , L1
.= ( {} ) by SF_MASTR:15;
end;
theorem
L17: (for R6 being (Element of ( NAT )) holds ( UsedInt*Loc ( Goto R6 ) ) = ( {} ))
proof
let R6 being (Element of ( NAT ));
L18: ( Goto R6 ) = ( ( 0 ) .--> ( goto R6 ) ) by SCMFSA8A:def 1;
thus L19: ( UsedInt*Loc ( Goto R6 ) ) = ( UsedInt*Loc ( goto R6 ) ) by L18 , L6
.= ( {} ) by SF_MASTR:32;
end;
set D3 = ( ( Int-Locations ) \/ ( FinSeq-Locations ) );
set D4 = ( Start-At (( 0 ) , ( SCM+FSA )) );
theorem
L20: (for R14 being Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds (for R16 being (Program of ( SCM+FSA )) holds ( UsedIntLoc ( if=0 (R14 , R15 , R16) ) ) = ( ( { R14 } \/ ( UsedIntLoc R15 ) ) \/ ( UsedIntLoc R16 ) ))))
proof
let R14 being Int-Location;
let R15 being (Program of ( SCM+FSA ));
let R16 being (Program of ( SCM+FSA ));
set D5 = ( Stop ( SCM+FSA ) );
set D6 = R14;
set D7 = ( D6 =0_goto ( ( card R16 ) + 3 ) );
set D8 = ( Goto ( ( card R15 ) + 1 ) );
thus L21: ( UsedIntLoc ( if=0 (D6 , R15 , R16) ) ) = ( UsedIntLoc ( ( ( ( D7 ";" R16 ) ";" D8 ) ";" R15 ) ";" D5 ) ) by SCMFSA8B:def 1
.= ( ( UsedIntLoc ( ( ( D7 ";" R16 ) ";" D8 ) ";" R15 ) ) \/ ( {} ) ) by L11 , SF_MASTR:27
.= ( ( UsedIntLoc ( ( D7 ";" R16 ) ";" D8 ) ) \/ ( UsedIntLoc R15 ) ) by SF_MASTR:27
.= ( ( ( UsedIntLoc ( D7 ";" R16 ) ) \/ ( UsedIntLoc D8 ) ) \/ ( UsedIntLoc R15 ) ) by SF_MASTR:27
.= ( ( ( UsedIntLoc ( D7 ";" R16 ) ) \/ ( {} ) ) \/ ( UsedIntLoc R15 ) ) by L14
.= ( ( ( UsedIntLoc D7 ) \/ ( UsedIntLoc R16 ) ) \/ ( UsedIntLoc R15 ) ) by SF_MASTR:29
.= ( ( { D6 } \/ ( UsedIntLoc R16 ) ) \/ ( UsedIntLoc R15 ) ) by SF_MASTR:16
.= ( ( { D6 } \/ ( UsedIntLoc R15 ) ) \/ ( UsedIntLoc R16 ) ) by XBOOLE_1:4;
end;
theorem
L22: (for R15 being (Program of ( SCM+FSA )) holds (for R16 being (Program of ( SCM+FSA )) holds (for B3 being Int-Location holds ( UsedInt*Loc ( if=0 (B3 , R15 , R16) ) ) = ( ( UsedInt*Loc R15 ) \/ ( UsedInt*Loc R16 ) ))))
proof
let R15 being (Program of ( SCM+FSA ));
let R16 being (Program of ( SCM+FSA ));
set D9 = ( Stop ( SCM+FSA ) );
let C3 being Int-Location;
set D10 = ( C3 =0_goto ( ( card R16 ) + 3 ) );
set D11 = ( Goto ( ( card R15 ) + 1 ) );
thus L23: ( UsedInt*Loc ( if=0 (C3 , R15 , R16) ) ) = ( UsedInt*Loc ( ( ( ( D10 ";" R16 ) ";" D11 ) ";" R15 ) ";" D9 ) ) by SCMFSA8B:def 1
.= ( ( UsedInt*Loc ( ( ( D10 ";" R16 ) ";" D11 ) ";" R15 ) ) \/ ( {} ) ) by L12 , SF_MASTR:43
.= ( ( UsedInt*Loc ( ( D10 ";" R16 ) ";" D11 ) ) \/ ( UsedInt*Loc R15 ) ) by SF_MASTR:43
.= ( ( ( UsedInt*Loc ( D10 ";" R16 ) ) \/ ( UsedInt*Loc D11 ) ) \/ ( UsedInt*Loc R15 ) ) by SF_MASTR:43
.= ( ( ( UsedInt*Loc ( D10 ";" R16 ) ) \/ ( {} ) ) \/ ( UsedInt*Loc R15 ) ) by L17
.= ( ( ( UsedInt*Loc D10 ) \/ ( UsedInt*Loc R16 ) ) \/ ( UsedInt*Loc R15 ) ) by SF_MASTR:45
.= ( ( ( {} ) \/ ( UsedInt*Loc R16 ) ) \/ ( UsedInt*Loc R15 ) ) by SF_MASTR:32
.= ( ( UsedInt*Loc R15 ) \/ ( UsedInt*Loc R16 ) );
end;
theorem
L24: (for R14 being Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds (for R16 being (Program of ( SCM+FSA )) holds ( UsedIntLoc ( if>0 (R14 , R15 , R16) ) ) = ( ( { R14 } \/ ( UsedIntLoc R15 ) ) \/ ( UsedIntLoc R16 ) ))))
proof
let R14 being Int-Location;
let R15 being (Program of ( SCM+FSA ));
let R16 being (Program of ( SCM+FSA ));
set D12 = ( Stop ( SCM+FSA ) );
set D13 = R14;
set D14 = ( D13 >0_goto ( ( card R16 ) + 3 ) );
set D15 = ( Goto ( ( card R15 ) + 1 ) );
thus L25: ( UsedIntLoc ( if>0 (D13 , R15 , R16) ) ) = ( UsedIntLoc ( ( ( ( D14 ";" R16 ) ";" D15 ) ";" R15 ) ";" D12 ) ) by SCMFSA8B:def 2
.= ( ( UsedIntLoc ( ( ( D14 ";" R16 ) ";" D15 ) ";" R15 ) ) \/ ( {} ) ) by L11 , SF_MASTR:27
.= ( ( UsedIntLoc ( ( D14 ";" R16 ) ";" D15 ) ) \/ ( UsedIntLoc R15 ) ) by SF_MASTR:27
.= ( ( ( UsedIntLoc ( D14 ";" R16 ) ) \/ ( UsedIntLoc D15 ) ) \/ ( UsedIntLoc R15 ) ) by SF_MASTR:27
.= ( ( ( UsedIntLoc ( D14 ";" R16 ) ) \/ ( {} ) ) \/ ( UsedIntLoc R15 ) ) by L14
.= ( ( ( UsedIntLoc D14 ) \/ ( UsedIntLoc R16 ) ) \/ ( UsedIntLoc R15 ) ) by SF_MASTR:29
.= ( ( { D13 } \/ ( UsedIntLoc R16 ) ) \/ ( UsedIntLoc R15 ) ) by SF_MASTR:16
.= ( ( { D13 } \/ ( UsedIntLoc R15 ) ) \/ ( UsedIntLoc R16 ) ) by XBOOLE_1:4;
end;
theorem
L26: (for R14 being Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds (for R16 being (Program of ( SCM+FSA )) holds ( UsedInt*Loc ( if>0 (R14 , R15 , R16) ) ) = ( ( UsedInt*Loc R15 ) \/ ( UsedInt*Loc R16 ) ))))
proof
let R14 being Int-Location;
let R15 being (Program of ( SCM+FSA ));
let R16 being (Program of ( SCM+FSA ));
set D16 = ( Stop ( SCM+FSA ) );
set D17 = R14;
set D18 = ( D17 >0_goto ( ( card R16 ) + 3 ) );
set D19 = ( Goto ( ( card R15 ) + 1 ) );
thus L27: ( UsedInt*Loc ( if>0 (D17 , R15 , R16) ) ) = ( UsedInt*Loc ( ( ( ( D18 ";" R16 ) ";" D19 ) ";" R15 ) ";" D16 ) ) by SCMFSA8B:def 2
.= ( ( UsedInt*Loc ( ( ( D18 ";" R16 ) ";" D19 ) ";" R15 ) ) \/ ( {} ) ) by L12 , SF_MASTR:43
.= ( ( UsedInt*Loc ( ( D18 ";" R16 ) ";" D19 ) ) \/ ( UsedInt*Loc R15 ) ) by SF_MASTR:43
.= ( ( ( UsedInt*Loc ( D18 ";" R16 ) ) \/ ( UsedInt*Loc D19 ) ) \/ ( UsedInt*Loc R15 ) ) by SF_MASTR:43
.= ( ( ( UsedInt*Loc ( D18 ";" R16 ) ) \/ ( {} ) ) \/ ( UsedInt*Loc R15 ) ) by L17
.= ( ( ( UsedInt*Loc D18 ) \/ ( UsedInt*Loc R16 ) ) \/ ( UsedInt*Loc R15 ) ) by SF_MASTR:45
.= ( ( ( {} ) \/ ( UsedInt*Loc R16 ) ) \/ ( UsedInt*Loc R15 ) ) by SF_MASTR:32
.= ( ( UsedInt*Loc R15 ) \/ ( UsedInt*Loc R16 ) );
end;
begin
L28: (for B4 being Int-Location holds (for B5 being (Program of ( SCM+FSA )) holds (( ( card B5 ) + 4 ) in ( dom ( if=0 (B4 , ( B5 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) ) & ( ( if=0 (B4 , ( B5 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) . ( ( card B5 ) + 4 ) ) = ( goto ( ( 0 ) + ( ( card B5 ) + 4 ) ) ))))
proof
set D20 = ( Stop ( SCM+FSA ) );
set D21 = ( Goto ( 0 ) );
let C4 being Int-Location;
let C5 being (Program of ( SCM+FSA ));
set D22 = ( C5 ";" D21 );
set D23 = ( C4 =0_goto ( ( card D20 ) + 3 ) );
set D24 = ( ( card C5 ) + 4 );
set D25 = D24;
set D26 = ( ( ( ( Macro D23 ) ";" D20 ) ";" ( Goto ( ( card D22 ) + 1 ) ) ) ";" C5 );
L29: ( card ( Stop ( SCM+FSA ) ) ) = 1 by COMPOS_1:4;
L30: ( card ( D21 ";" D20 ) ) = ( ( card D21 ) + ( card D20 ) ) by SCMFSA6A:21
.= ( 1 + 1 ) by L29 , SCMFSA8A:15
.= 2;
L31: ( if=0 (C4 , D22 , D20) ) = ( ( ( ( D23 ";" D20 ) ";" ( Goto ( ( card D22 ) + 1 ) ) ) ";" ( C5 ";" D21 ) ) ";" D20 ) by SCMFSA8B:def 1
.= ( ( D26 ";" D21 ) ";" D20 ) by SCMFSA6A:25
.= ( D26 ";" ( D21 ";" D20 ) ) by SCMFSA6A:25;
L32: ( card ( if=0 (C4 , D22 , D20) ) ) = ( ( card D26 ) + ( card ( D21 ";" D20 ) ) ) by L31 , SCMFSA6A:21;
L33: ( card D26 ) = ( ( card ( if=0 (C4 , D22 , D20) ) ) - ( card ( D21 ";" D20 ) ) ) by L32
.= ( ( ( card C5 ) + 6 ) - 2 ) by L30 , SCMFSA_9:1
.= D24;
L34: (not D25 in ( dom D26 )) by L33;
set D27 = ( D21 ";" D20 );
L35: D21 = ( ( 0 ) .--> ( goto ( 0 ) ) ) by SCMFSA8A:def 1;
L36: ( D21 . ( 0 ) ) = ( goto ( 0 ) ) by L35 , FUNCOP_1:72;
L37: ( dom D21 ) = { ( 0 ) } by L35 , FUNCOP_1:13;
L38: ( 0 ) in ( dom D21 ) by L37 , TARSKI:def 1;
L39: ( dom D21 ) c= ( dom D27 ) by SCMFSA6A:17;
L40: ( ( 0 ) + D24 ) in { ( B6 + D24 ) where B6 is (Element of ( NAT )) : B6 in ( dom D27 ) } by L39 , L38;
L41: D24 in ( dom ( Shift (D27 , D24) ) ) by L40 , VALUED_1:def 12;
L42: ( ( Shift (D27 , D24) ) /. D25 ) = ( ( Shift (D27 , D24) ) . ( ( 0 ) + D24 ) ) by L41 , PARTFUN1:def 6
.= ( D27 . ( 0 ) ) by L38 , L39 , VALUED_1:def 12
.= ( goto ( 0 ) ) by L38 , L36 , SCMFSA6A:15;
L43: ( card ( Stop ( SCM+FSA ) ) ) = 1 by COMPOS_1:4;
L44: ( card D22 ) = ( ( card C5 ) + ( card D21 ) ) by SCMFSA6A:21
.= ( ( card C5 ) + 1 ) by SCMFSA8A:15;
L45: ( ( ( card D22 ) + ( card D20 ) ) + 3 ) = ( ( ( card C5 ) + 4 ) + 1 ) by L44 , L43;
L46: D24 < ( ( ( card D22 ) + ( card D20 ) ) + 3 ) by L45 , NAT_1:13;
thus L47: D25 in ( dom ( if=0 (C4 , D22 , D20) ) ) by L46 , SCMFSA8C:27;
L48: ( Reloc (D27 , D24) ) = ( IncAddr (( Shift (D27 , D24) ) , D24) ) by COMPOS_1:34;
L49: ( dom ( if=0 (C4 , D22 , D20) ) ) = ( ( dom ( Directed D26 ) ) \/ ( dom ( Reloc (D27 , D24) ) ) ) by L31 , L33 , FUNCT_4:def 1;
L50: ( dom ( if=0 (C4 , D22 , D20) ) ) = ( ( dom D26 ) \/ ( dom ( Reloc (D27 , D24) ) ) ) by L49 , FUNCT_4:99;
L51: D25 in ( dom ( Reloc (D27 , D24) ) ) by L50 , L47 , L34 , XBOOLE_0:def 3;
thus L52: ( ( if=0 (C4 , D22 , D20) ) . D25 ) = ( ( Reloc (D27 , D24) ) . D25 ) by L51 , L47 , L31 , L33 , L49 , FUNCT_4:def 1
.= ( IncAddr (( goto ( 0 ) ) , D24) ) by L41 , L42 , L48 , COMPOS_1:def 21
.= ( goto ( ( 0 ) + D24 ) ) by SCMFSA_4:1;
end;
L53: (for B7 being Int-Location holds (for B8 being (Program of ( SCM+FSA )) holds ( UsedIntLoc ( if=0 (B7 , ( B8 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) ) = ( UsedIntLoc ( ( if=0 (B7 , ( B8 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) +* ( ( ( card B8 ) + 4 ) .--> ( goto ( 0 ) ) ) ) )))
proof
let C6 being Int-Location;
let C7 being (Program of ( SCM+FSA ));
set D28 = ( ( card C7 ) + 4 );
set D29 = ( if=0 (C6 , ( C7 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) );
set D30 = ( ( ( card C7 ) + 4 ) .--> ( goto ( 0 ) ) );
consider C8 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L54: (for B9 being (Instruction of ( SCM+FSA )) holds ( C8 . B9 ) = ( UsedIntLoc B9 )) and L55: ( UsedIntLoc D29 ) = ( Union ( C8 * D29 ) ) by SF_MASTR:def 2;
L56: ( dom C8 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
L57:
now
thus L58: ( dom ( C8 * D29 ) ) = ( dom ( C8 * D29 ) );
L59: ( rng ( D29 +* D30 ) ) c= ( dom C8 ) by L56 , RELAT_1:def 19;
L60: ( dom D30 ) = { ( ( card C7 ) + 4 ) } by FUNCOP_1:13;
L61: D28 in ( dom D30 ) by L60 , TARSKI:def 1;
L62: ( ( card C7 ) + 4 ) in ( dom D29 ) by L28;
L63: (( dom ( D29 +* D30 ) ) = ( ( dom D29 ) \/ ( dom D30 ) ) & ( dom D30 ) c= ( dom D29 )) by L62 , L60 , FUNCT_4:def 1 , ZFMISC_1:31;
L64: ( dom D29 ) = ( dom ( D29 +* D30 ) ) by L63 , XBOOLE_1:12;
L65: ( rng D29 ) c= ( dom C8 ) by L56 , RELAT_1:def 19;
thus L66: ( dom ( C8 * D29 ) ) = ( dom D29 ) by L65 , RELAT_1:27
.= ( dom ( C8 * ( D29 +* D30 ) ) ) by L59 , L64 , RELAT_1:27;
let C9 being set;
assume L67: C9 in ( dom ( C8 * D29 ) );
per cases ;
suppose L68: C9 <> D28;

L69: (not C9 in ( dom D30 )) by L68 , L60 , TARSKI:def 1;
thus L70: ( ( C8 * D29 ) . C9 ) = ( C8 . ( D29 . C9 ) ) by L67 , FUNCT_1:12
.= ( C8 . ( ( D29 +* D30 ) . C9 ) ) by L69 , FUNCT_4:11
.= ( ( C8 * ( D29 +* D30 ) ) . C9 ) by L66 , L67 , FUNCT_1:12;
end;
suppose L71: C9 = D28;

thus L72: ( ( C8 * D29 ) . C9 ) = ( C8 . ( D29 . C9 ) ) by L67 , FUNCT_1:12
.= ( C8 . ( goto ( ( 0 ) + ( ( card C7 ) + 4 ) ) ) ) by L71 , L28
.= ( UsedIntLoc ( goto ( ( 0 ) + ( ( card C7 ) + 4 ) ) ) ) by L54
.= ( {} ) by SF_MASTR:15
.= ( UsedIntLoc ( goto ( 0 ) ) ) by SF_MASTR:15
.= ( C8 . ( goto ( 0 ) ) ) by L54
.= ( C8 . ( D30 . C9 ) ) by L71 , FUNCOP_1:72
.= ( C8 . ( ( D29 +* D30 ) . C9 ) ) by L61 , L71 , FUNCT_4:13
.= ( ( C8 * ( D29 +* D30 ) ) . C9 ) by L66 , L67 , FUNCT_1:12;
end;
end;
consider C10 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L74: (for B10 being (Instruction of ( SCM+FSA )) holds ( C10 . B10 ) = ( UsedIntLoc B10 )) and L75: ( UsedIntLoc ( D29 +* D30 ) ) = ( Union ( C10 * ( D29 +* D30 ) ) ) by SF_MASTR:def 2;
L76: (for B11 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C8 . B11 ) = ( C10 . B11 ))
proof
let C11 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D31 = C11 as (Instruction of ( SCM+FSA ));
thus L77: ( C8 . C11 ) = ( UsedIntLoc D31 ) by L54
.= ( C10 . C11 ) by L74;
end;
L78: C8 = C10 by L76 , FUNCT_2:63;
thus L79: thesis by L78 , L55 , L75 , L57 , FUNCT_1:2;
end;
L80: (for B12 being Int-Location holds (for B13 being (Program of ( SCM+FSA )) holds ( UsedInt*Loc ( if=0 (B12 , ( B13 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) ) = ( UsedInt*Loc ( ( if=0 (B12 , ( B13 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) +* ( ( ( card B13 ) + 4 ) .--> ( goto ( 0 ) ) ) ) )))
proof
let C12 being Int-Location;
let C13 being (Program of ( SCM+FSA ));
set D32 = ( ( card C13 ) + 4 );
set D33 = ( if=0 (C12 , ( C13 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) );
set D34 = ( ( ( card C13 ) + 4 ) .--> ( goto ( 0 ) ) );
consider C14 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L81: (for B14 being (Instruction of ( SCM+FSA )) holds ( C14 . B14 ) = ( UsedInt*Loc B14 )) and L82: ( UsedInt*Loc D33 ) = ( Union ( C14 * D33 ) ) by SF_MASTR:def 4;
L83: ( dom C14 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
L84:
now
thus L85: ( dom ( C14 * D33 ) ) = ( dom ( C14 * D33 ) );
L86: ( rng ( D33 +* D34 ) ) c= ( dom C14 ) by L83 , RELAT_1:def 19;
L87: ( dom D34 ) = { ( ( card C13 ) + 4 ) } by FUNCOP_1:13;
L88: D32 in ( dom D34 ) by L87 , TARSKI:def 1;
L89: ( ( card C13 ) + 4 ) in ( dom D33 ) by L28;
L90: (( dom ( D33 +* D34 ) ) = ( ( dom D33 ) \/ ( dom D34 ) ) & ( dom D34 ) c= ( dom D33 )) by L89 , L87 , FUNCT_4:def 1 , ZFMISC_1:31;
L91: ( dom D33 ) = ( dom ( D33 +* D34 ) ) by L90 , XBOOLE_1:12;
L92: ( rng D33 ) c= ( dom C14 ) by L83 , RELAT_1:def 19;
thus L93: ( dom ( C14 * D33 ) ) = ( dom D33 ) by L92 , RELAT_1:27
.= ( dom ( C14 * ( D33 +* D34 ) ) ) by L86 , L91 , RELAT_1:27;
let C15 being set;
assume L94: C15 in ( dom ( C14 * D33 ) );
per cases ;
suppose L95: C15 <> D32;

L96: (not C15 in ( dom D34 )) by L95 , L87 , TARSKI:def 1;
thus L97: ( ( C14 * D33 ) . C15 ) = ( C14 . ( D33 . C15 ) ) by L94 , FUNCT_1:12
.= ( C14 . ( ( D33 +* D34 ) . C15 ) ) by L96 , FUNCT_4:11
.= ( ( C14 * ( D33 +* D34 ) ) . C15 ) by L93 , L94 , FUNCT_1:12;
end;
suppose L98: C15 = D32;

thus L99: ( ( C14 * D33 ) . C15 ) = ( C14 . ( D33 . C15 ) ) by L94 , FUNCT_1:12
.= ( C14 . ( goto ( ( 0 ) + ( ( card C13 ) + 4 ) ) ) ) by L98 , L28
.= ( UsedInt*Loc ( goto ( ( 0 ) + ( ( card C13 ) + 4 ) ) ) ) by L81
.= ( {} ) by SF_MASTR:32
.= ( UsedInt*Loc ( goto ( 0 ) ) ) by SF_MASTR:32
.= ( C14 . ( goto ( 0 ) ) ) by L81
.= ( C14 . ( D34 . C15 ) ) by L98 , FUNCOP_1:72
.= ( C14 . ( ( D33 +* D34 ) . C15 ) ) by L88 , L98 , FUNCT_4:13
.= ( ( C14 * ( D33 +* D34 ) ) . C15 ) by L93 , L94 , FUNCT_1:12;
end;
end;
consider C16 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L101: (for B15 being (Instruction of ( SCM+FSA )) holds ( C16 . B15 ) = ( UsedInt*Loc B15 )) and L102: ( UsedInt*Loc ( D33 +* D34 ) ) = ( Union ( C16 * ( D33 +* D34 ) ) ) by SF_MASTR:def 4;
L103: (for B16 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C14 . B16 ) = ( C16 . B16 ))
proof
let C17 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D35 = C17 as (Instruction of ( SCM+FSA ));
thus L104: ( C14 . C17 ) = ( UsedInt*Loc D35 ) by L81
.= ( C16 . C17 ) by L101;
end;
L105: C14 = C16 by L103 , FUNCT_2:63;
thus L106: thesis by L105 , L82 , L102 , L84 , FUNCT_1:2;
end;
theorem
L107: (for R14 being Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds ( UsedIntLoc ( while=0 (R14 , R15) ) ) = ( { R14 } \/ ( UsedIntLoc R15 ) )))
proof
let R14 being Int-Location;
let R15 being (Program of ( SCM+FSA ));
set D36 = ( Stop ( SCM+FSA ) );
set D37 = R14;
set D38 = ( R15 ";" ( Goto ( 0 ) ) );
L108: ( while=0 (D37 , R15) ) = ( ( if=0 (D37 , D38 , D36) ) +* ( ( ( card R15 ) + 4 ) .--> ( goto ( 0 ) ) ) ) by SCMFSA_9:def 1;
thus L109: ( UsedIntLoc ( while=0 (D37 , R15) ) ) = ( UsedIntLoc ( if=0 (D37 , D38 , D36) ) ) by L108 , L53
.= ( ( { D37 } \/ ( UsedIntLoc D38 ) ) \/ ( UsedIntLoc D36 ) ) by L20
.= ( ( { D37 } \/ ( ( UsedIntLoc R15 ) \/ ( UsedIntLoc ( Goto ( 0 ) ) ) ) ) \/ ( UsedIntLoc D36 ) ) by SF_MASTR:27
.= ( ( { D37 } \/ ( ( UsedIntLoc R15 ) \/ ( {} ) ) ) \/ ( UsedIntLoc D36 ) ) by L14
.= ( { D37 } \/ ( UsedIntLoc R15 ) ) by L11;
end;
theorem
L110: (for R14 being Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds ( UsedInt*Loc ( while=0 (R14 , R15) ) ) = ( UsedInt*Loc R15 )))
proof
let R14 being Int-Location;
let R15 being (Program of ( SCM+FSA ));
set D39 = ( Stop ( SCM+FSA ) );
set D40 = R14;
set D41 = ( R15 ";" ( Goto ( 0 ) ) );
L111: ( while=0 (D40 , R15) ) = ( ( if=0 (D40 , D41 , D39) ) +* ( ( ( card R15 ) + 4 ) .--> ( goto ( 0 ) ) ) ) by SCMFSA_9:def 1;
thus L112: ( UsedInt*Loc ( while=0 (D40 , R15) ) ) = ( UsedInt*Loc ( if=0 (D40 , D41 , D39) ) ) by L111 , L80
.= ( ( UsedInt*Loc D41 ) \/ ( UsedInt*Loc D39 ) ) by L22
.= ( ( ( UsedInt*Loc R15 ) \/ ( UsedInt*Loc ( Goto ( 0 ) ) ) ) \/ ( UsedInt*Loc D39 ) ) by SF_MASTR:43
.= ( ( UsedInt*Loc R15 ) \/ ( {} ) ) by L12 , L17
.= ( UsedInt*Loc R15 );
end;
definition
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C18 being (State of ( SCM+FSA ));
let C19 being  read-write Int-Location;
let C20 being (Program of ( SCM+FSA ));
pred  ProperBodyWhile=0 C19 , C20 , C18 , R1
means
:L113: (for B17 being (Element of ( NAT )) holds (( ( ( StepWhile=0 (C19 , C20 , R1 , C18) ) . B17 ) . C19 ) = ( 0 ) implies (C20 is_closed_on ( ( StepWhile=0 (C19 , C20 , R1 , C18) ) . B17 ) , ( R1 +* ( while=0 (C19 , C20) ) ) & C20 is_halting_on ( ( StepWhile=0 (C19 , C20 , R1 , C18) ) . B17 ) , ( R1 +* ( while=0 (C19 , C20) ) ))))
;pred  WithVariantWhile=0 C19 , C20 , C18 , R1
means
:L114: (ex B18 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) st (for B19 being (Element of ( NAT )) holds (( B18 . ( ( StepWhile=0 (C19 , C20 , R1 , C18) ) . ( B19 + 1 ) ) ) < ( B18 . ( ( StepWhile=0 (C19 , C20 , R1 , C18) ) . B19 ) ) or ( ( ( StepWhile=0 (C19 , C20 , R1 , C18) ) . B19 ) . C19 ) <> ( 0 ))))
;end;
theorem
L116: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for B20 being  parahalting (Program of ( SCM+FSA )) holds  ProperBodyWhile=0 R13 , B20 , R10 , R1))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let C21 being  parahalting (Program of ( SCM+FSA ));
let C22 being (Element of ( NAT ));
assume that
L117: ( ( ( StepWhile=0 (R13 , C21 , R1 , R10) ) . C22 ) . R13 ) = ( 0 );
thus L118: C21 is_closed_on ( ( StepWhile=0 (R13 , C21 , R1 , R10) ) . C22 ) , ( R1 +* ( while=0 (R13 , C21) ) ) by SCMFSA7B:18;
thus L119: thesis by SCMFSA7B:19;
end;
theorem
L120: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds (( ProperBodyWhile=0 R13 , R15 , R10 , R1 &  WithVariantWhile=0 R13 , R15 , R10 , R1) implies (( while=0 (R13 , R15) ) is_halting_on R10 , R1 & ( while=0 (R13 , R15) ) is_closed_on R10 , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
assume L121: (for B21 being (Element of ( NAT )) holds (( ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . B21 ) . R13 ) = ( 0 ) implies (R15 is_closed_on ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . B21 ) , ( R1 +* ( while=0 (R13 , R15) ) ) & R15 is_halting_on ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . B21 ) , ( R1 +* ( while=0 (R13 , R15) ) ))));
set D42 = ( Initialize R10 );
set D43 = ( R1 +* ( while=0 (R13 , R15) ) );
L122: ( D43 +* ( while=0 (R13 , R15) ) ) = D43;
defpred S1[ (Element of ( NAT )) ] means ( ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . $1 ) . R13 ) <> ( 0 );
given C23 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that
L123: (for B22 being (Element of ( NAT )) holds (( C23 . ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . ( B22 + 1 ) ) ) < ( C23 . ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . B22 ) ) or ( ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . B22 ) . R13 ) <> ( 0 )));

deffunc H1(Nat) = ( C23 . ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . $1 ) );
L124: (for R20 being (Element of ( NAT )) holds (H1(( R20 + 1 )) < H1(R20) or S1[ R20 ])) by L123;
consider C24 being (Element of ( NAT )) such that L125: S1[ C24 ] and L126: (for R22 being (Element of ( NAT )) holds (S1[ R22 ] implies C24 <= R22)) from NAT_1:sch 18(L124);
defpred S2[ Nat ] means (( $1 + 1 ) <= C24 implies (ex R20 being (Element of ( NAT )) st ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . ( $1 + 1 ) ) = ( Comput (D43 , D42 , R20) )));
L127:
now
let C25 being (Element of ( NAT ));
assume L128: S2[ C25 ];
L129:
now
set D44 = ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . ( C25 + 1 ) );
set D45 = ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . C25 );
set D46 = ( R1 +* ( while=0 (R13 , R15) ) );
assume L130: ( ( C25 + 1 ) + 1 ) <= C24;
L131: ( C25 + ( 0 ) ) < ( C25 + ( 1 + 1 ) ) by XREAL_1:6;
L132: C25 < C24 by L131 , L130 , XXREAL_0:2;
L133: ( D45 . R13 ) = ( 0 ) by L132 , L126;
L134: ( ( C25 + 1 ) + ( 0 ) ) < ( ( C25 + 1 ) + 1 ) by XREAL_1:6;
consider C26 being (Element of ( NAT )) such that L135: D44 = ( Comput (D43 , D42 , C26) ) by L134 , L128 , L130 , XXREAL_0:2;
L136: D44 = ( Comput (( D46 +* ( while=0 (R13 , R15) ) ) , ( Initialize D45 ) , ( ( LifeSpan (( ( D46 +* ( while=0 (R13 , R15) ) ) +* R15 ) , ( Initialize D45 )) ) + 3 )) ) by SCMFSA_9:def 4;
take D47 = ( C26 + ( ( LifeSpan (( D46 +* R15 ) , ( Initialize D44 )) ) + 3 ) );
L137: (R15 is_closed_on D45 , D46 & R15 is_halting_on D45 , D46) by L121 , L133;
L138: ( IC D44 ) = ( 0 ) by L137 , L136 , L133 , SCMFSA_9:22;
L139: ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . ( ( C25 + 1 ) + 1 ) ) = ( Comput (D43 , D42 , ( C26 + ( ( LifeSpan (( D43 +* R15 ) , ( Initialize ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . ( C25 + 1 ) ) )) ) + 3 ) )) ) by L138 , L135 , SCMFSA_9:26;
thus L140: ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . ( ( C25 + 1 ) + 1 ) ) = ( Comput (D43 , D42 , D47) ) by L139;
end;
thus L141: S2[ ( C25 + 1 ) ] by L129;
end;
L142: S2[ ( 0 ) ]
proof
assume L143: ( ( 0 ) + 1 ) <= C24;
take D48 = ( ( LifeSpan (( D43 +* R15 ) , ( Initialize R10 )) ) + 3 );
thus L144: thesis by SCMFSA_9:25;
end;
L145: (for B23 being (Element of ( NAT )) holds S2[ B23 ]) from NAT_1:sch 1(L142 , L127);
per cases ;
suppose L146: C24 = ( 0 );

L147: ( R10 . R13 ) <> ( 0 ) by L146 , L125 , SCMFSA_9:def 4;
thus L148: thesis by L147 , SCMFSA_9:18;
end;
suppose L149: C24 <> ( 0 );

set D49 = ( ( LifeSpan (( ( R1 +* ( while=0 (R13 , R15) ) ) +* R15 ) , ( Initialize R10 )) ) + 3 );
set D50 = ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . C24 );
set D51 = ( R1 +* ( while=0 (R13 , R15) ) );
set D52 = ( Initialize D50 );
set D53 = ( D51 +* ( while=0 (R13 , R15) ) );
consider C27 being Nat such that L150: C24 = ( C27 + 1 ) by L149 , NAT_1:6;
reconsider D54 = C27 as (Element of ( NAT )) by ORDINAL1:def 12;
set D55 = ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . D54 );
set D56 = ( R1 +* ( while=0 (R13 , R15) ) );
L151: D50 = ( Comput (( D56 +* ( while=0 (R13 , R15) ) ) , ( Initialize D55 ) , ( ( LifeSpan (( D56 +* R15 ) , ( Initialize D55 )) ) + 3 )) ) by L150 , SCMFSA_9:def 4;
L152: C24 = ( D54 + 1 ) by L150;
consider C28 being (Element of ( NAT )) such that L153: D50 = ( Comput (D43 , D42 , C28) ) by L152 , L145;
L154: D54 < C24 by L150 , NAT_1:13;
L155: ( D55 . R13 ) = ( 0 ) by L154 , L126;
L156: (R15 is_closed_on D55 , D56 & R15 is_halting_on D55 , D56) by L155 , L121;
L157: ( IC D50 ) = ( 0 ) by L156 , L151 , L155 , SCMFSA_9:22;
L158: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= D50 by L157 , MEMSTR_0:30;
L159: D52 = D50 by L158 , FUNCT_4:98;
L160: ( while=0 (R13 , R15) ) is_halting_on D50 , D51 by L125 , SCMFSA_9:18;
L161: D53 halts_on D52 by L160 , SCMFSA7B:def 7;
consider C29 being (Element of ( NAT )) such that L162: ( CurInstr (D51 , ( Comput (D51 , D50 , C29) )) ) = ( halt ( SCM+FSA ) ) by L161 , L159 , EXTPRO_1:29;
L163: ( Comput (D43 , D42 , ( C28 + C29 )) ) = ( Comput (D43 , ( Comput (D43 , D42 , C28) ) , C29) ) by EXTPRO_1:4;
L164: ( CurInstr (D43 , ( Comput (D43 , D42 , ( C28 + C29 )) )) ) = ( halt ( SCM+FSA ) ) by L153 , L162 , L163;
L165: D43 halts_on D42 by L164 , EXTPRO_1:29;
thus L166: ( while=0 (R13 , R15) ) is_halting_on R10 , R1 by L165 , SCMFSA7B:def 7;
L167:
now
let C30 being (Element of ( NAT ));
per cases ;
suppose L168: C30 <= D49;

L169: ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . ( 0 ) ) = R10 by SCMFSA_9:def 4;
L170: ( R10 . R13 ) = ( 0 ) by L169 , L126 , L149;
L171: (R15 is_closed_on R10 , D43 & R15 is_halting_on R10 , D43) by L170 , L121 , L169;
thus L172: ( IC ( Comput (D43 , D42 , C30) ) ) in ( dom ( while=0 (R13 , R15) ) ) by L171 , L168 , L170 , L122 , SCMFSA_9:22;
end;
suppose L173: C30 > D49;

L174:
now
take D57 = D49;
thus L175: (( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . 1 ) = ( Comput (D43 , D42 , D57) ) & D57 <= C30) by L173 , SCMFSA_9:25;
end;
defpred S3[ Nat ] means ($1 <= C24 & $1 <> ( 0 ) & (ex R20 being (Element of ( NAT )) st (( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . $1 ) = ( Comput (D43 , D42 , R20) ) & R20 <= C30)));
L176: (for B24 being Nat holds (S3[ B24 ] implies B24 <= C24));
L177: ( ( 0 ) + 1 ) < ( C24 + 1 ) by L149 , XREAL_1:6;
L178: 1 <= C24 by L177 , NAT_1:13;
L179: (ex B25 being Nat st S3[ B25 ]) by L178 , L174;
consider C31 being Nat such that L180: (S3[ C31 ] & (for B26 being Nat holds (S3[ B26 ] implies B26 <= C31))) from NAT_1:sch 6(L176 , L179);
reconsider D58 = C31 as (Element of ( NAT )) by ORDINAL1:def 12;
per cases ;
suppose L181: D58 = C24;

consider C32 being (Element of ( NAT )) such that L182: D50 = ( Comput (D43 , D42 , C32) ) and L183: C32 <= C30 by L181 , L180;
consider C33 being Nat such that L184: C30 = ( C32 + C33 ) by L183 , NAT_1:10;
L185: ( while=0 (R13 , R15) ) is_closed_on D50 , D51 by L125 , SCMFSA_9:18;
reconsider D59 = C33 as (Element of ( NAT )) by ORDINAL1:def 12;
L186: ( Comput (D43 , D42 , C30) ) = ( Comput (D43 , D52 , D59) ) by L159 , L182 , L184 , EXTPRO_1:4;
thus L187: ( IC ( Comput (D43 , D42 , C30) ) ) in ( dom ( while=0 (R13 , R15) ) ) by L186 , L185 , L122 , SCMFSA7B:def 6;
end;
suppose L188: D58 <> C24;

set D60 = ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . D58 );
set D61 = ( R1 +* ( while=0 (R13 , R15) ) );
consider C34 being Nat such that L189: D58 = ( C34 + 1 ) by L180 , NAT_1:6;
reconsider D62 = C34 as (Element of ( NAT )) by ORDINAL1:def 12;
set D63 = ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . D62 );
set D64 = ( R1 +* ( while=0 (R13 , R15) ) );
L190: D60 = ( Comput (( D64 +* ( while=0 (R13 , R15) ) ) , ( Initialize D63 ) , ( ( LifeSpan (( D64 +* R15 ) , ( Initialize D63 )) ) + 3 )) ) by L189 , SCMFSA_9:def 4;
L191: ( D62 + ( 0 ) ) < D58 by L189 , XREAL_1:6;
L192: D62 < C24 by L191 , L180 , XXREAL_0:2;
L193: ( D63 . R13 ) = ( 0 ) by L192 , L126;
L194: (R15 is_closed_on D63 , D64 & R15 is_halting_on D63 , D64) by L193 , L121;
L195: ( IC D60 ) = ( 0 ) by L194 , L190 , L193 , SCMFSA_9:22;
consider C35 being (Element of ( NAT )) such that L196: ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . D58 ) = ( Comput (D43 , D42 , C35) ) and L197: C35 <= C30 by L180;
consider C36 being Nat such that L198: C30 = ( C35 + C36 ) by L197 , NAT_1:10;
reconsider D65 = C36 as (Element of ( NAT )) by ORDINAL1:def 12;
L199: D60 = ( Initialize D60 ) by L196 , L195 , SCMFSA_9:26;
L200: ( Comput (D43 , D42 , C30) ) = ( Comput (( D61 +* ( while=0 (R13 , R15) ) ) , ( Initialize D60 ) , D65) ) by L199 , L196 , L198 , EXTPRO_1:4;
set D66 = ( C35 + ( ( LifeSpan (( D61 +* R15 ) , ( Initialize D60 )) ) + 3 ) );
L201: D58 < C24 by L180 , L188 , XXREAL_0:1;
L202:
now
assume L203: D66 <= C30;
L204:
now
take D67 = D66;
thus L205: (( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . ( D58 + 1 ) ) = ( Comput (D43 , D42 , D67) ) & D67 <= C30) by L196 , L195 , L203 , SCMFSA_9:26;
end;
L206: ( D58 + 1 ) <= C24 by L201 , NAT_1:13;
thus L207: contradiction by L206 , L180 , L204 , XREAL_1:29;
end;
L208: D65 < ( ( LifeSpan (( D61 +* R15 ) , ( Initialize D60 )) ) + 3 ) by L202 , L198 , XREAL_1:6;
L209: ( D60 . R13 ) = ( 0 ) by L126 , L201;
L210: (R15 is_closed_on D60 , D61 & R15 is_halting_on D60 , D61) by L209 , L121;
thus L211: ( IC ( Comput (D43 , D42 , C30) ) ) in ( dom ( while=0 (R13 , R15) ) ) by L210 , L208 , L200 , L209 , SCMFSA_9:22;
end;
end;
end;
thus L214: ( while=0 (R13 , R15) ) is_closed_on R10 , R1 by L167 , SCMFSA7B:def 6;
end;
end;
theorem
L216: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for B27 being  parahalting (Program of ( SCM+FSA )) holds ( WithVariantWhile=0 R13 , B27 , R10 , R1 implies (( while=0 (R13 , B27) ) is_halting_on R10 , R1 & ( while=0 (R13 , B27) ) is_closed_on R10 , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let C37 being  parahalting (Program of ( SCM+FSA ));
assume that
L217:  WithVariantWhile=0 R13 , C37 , R10 , R1;
L218:  ProperBodyWhile=0 R13 , C37 , R10 , R1
proof
let C38 being (Element of ( NAT ));
assume L219: ( ( ( StepWhile=0 (R13 , C37 , R1 , R10) ) . C38 ) . R13 ) = ( 0 );
thus L220: thesis by SCMFSA7B:18 , SCMFSA7B:19;
end;
thus L221: thesis by L218 , L217 , L120;
end;
theorem
L222: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds (for B28 being ( 0 ) -started (State of ( SCM+FSA )) holds ((( while=0 (R13 , R15) ) c= R1 & ( B28 . R13 ) <> ( 0 )) implies (( LifeSpan (R1 , B28) ) = 4 & (for B29 being (Element of ( NAT )) holds ( DataPart ( Comput (R1 , B28 , B29) ) ) = ( DataPart B28 ))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
let C39 being ( 0 ) -started (State of ( SCM+FSA ));
L223: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C39 by MEMSTR_0:29;
assume that
L224: ( while=0 (R13 , R15) ) c= R1
and
L225: ( C39 . R13 ) <> ( 0 );
L226: ( R1 +* ( while=0 (R13 , R15) ) ) = R1 by L224 , FUNCT_4:98;
set D68 = ( R13 =0_goto 4 );
set D69 = ( Initialize C39 );
set D70 = ( R1 +* ( while=0 (R13 , R15) ) );
L227: ( while=0 (R13 , R15) ) c= D70 by FUNCT_4:25;
L228: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L229: (not R13 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L230: ( D69 . R13 ) = ( C39 . R13 ) by L229 , FUNCT_4:11;
L231: 1 in ( dom ( while=0 (R13 , R15) ) ) by SCMFSA_9:10;
L232: ( D70 . 1 ) = ( ( while=0 (R13 , R15) ) . 1 ) by L231 , FUNCT_4:13
.= ( goto 2 ) by SCMFSA_9:11;
L233: ( IC D69 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L228 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L234: ( D70 /. ( IC D69 ) ) = ( D70 . ( IC D69 ) ) by PBOOLE:143;
L235: ( 0 ) in ( dom ( while=0 (R13 , R15) ) ) by SCMFSA_9:10;
L236: ( D70 . ( 0 ) ) = ( ( while=0 (R13 , R15) ) . ( 0 ) ) by L235 , FUNCT_4:13
.= D68 by SCMFSA_9:11;
L237: ( CurInstr (D70 , D69) ) = D68 by L236 , L233 , L234;
L238: ( Comput (D70 , D69 , ( ( 0 ) + 1 )) ) = ( Following (D70 , ( Comput (D70 , D69 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D70 , D69) )
.= ( Exec (D68 , D69) ) by L237;
set D71 = ( ( card R15 ) + 5 );
set D72 = ( Comput (D70 , D69 , 4) );
set D73 = D70;
set D74 = ( Comput (D70 , D69 , 3) );
set D75 = D70;
set D76 = ( Comput (D70 , D69 , 2) );
set D77 = D70;
set D78 = ( Comput (D70 , D69 , 1) );
L239: 2 in ( dom ( while=0 (R13 , R15) ) ) by SCMFSA_9:12;
L240: ( D77 . 2 ) = ( ( while=0 (R13 , R15) ) . 2 ) by L239 , FUNCT_4:13
.= ( goto 3 ) by SCMFSA_9:16;
L241: 3 in ( dom ( while=0 (R13 , R15) ) ) by SCMFSA_9:12;
L242: ( D75 . 3 ) = ( ( while=0 (R13 , R15) ) . 3 ) by L241 , FUNCT_4:13
.= ( goto D71 ) by SCMFSA_9:15;
L243: D71 in ( dom ( while=0 (R13 , R15) ) ) by SCMFSA_9:13;
L244: ( D73 . D71 ) = ( ( while=0 (R13 , R15) ) . D71 ) by L243 , L227 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by SCMFSA_9:14;
L245: ((for B30 being Int-Location holds ( ( Exec (( goto D71 ) , D74) ) . B30 ) = ( D74 . B30 )) & (for B31 being FinSeq-Location holds ( ( Exec (( goto D71 ) , D74) ) . B31 ) = ( D74 . B31 ))) by SCMFSA_2:69;
L246: ((for B32 being Int-Location holds ( ( Exec (( goto 2 ) , D78) ) . B32 ) = ( D78 . B32 )) & (for B33 being FinSeq-Location holds ( ( Exec (( goto 2 ) , D78) ) . B33 ) = ( D78 . B33 ))) by SCMFSA_2:69;
L247: ( D70 /. ( IC ( Comput (D70 , D69 , 1) ) ) ) = ( D70 . ( IC ( Comput (D70 , D69 , 1) ) ) ) by PBOOLE:143;
L248: ( IC ( Comput (D70 , D69 , 1) ) ) = ( succ ( 0 ) ) by L225 , L233 , L238 , L230 , SCMFSA_2:70
.= ( ( 0 ) + 1 );
L249: ( CurInstr (D70 , ( Comput (D70 , D69 , 1) )) ) = ( goto 2 ) by L248 , L232 , L247;
L250: ( Comput (D70 , D69 , ( 1 + 1 )) ) = ( Following (D70 , D78) ) by EXTPRO_1:3
.= ( Exec (( goto 2 ) , D78) ) by L249;
L251: ( D77 /. ( IC D76 ) ) = ( D77 . ( IC D76 ) ) by PBOOLE:143;
L252: ( IC D76 ) = 2 by L250 , SCMFSA_2:69;
L253: ( CurInstr (D77 , D76) ) = ( goto 3 ) by L252 , L240 , L251;
L254: ( Comput (D70 , D69 , ( 2 + 1 )) ) = ( Following (D70 , D76) ) by EXTPRO_1:3
.= ( Exec (( goto 3 ) , D76) ) by L253;
L255: ( D75 /. ( IC D74 ) ) = ( D75 . ( IC D74 ) ) by PBOOLE:143;
L256: ( IC D74 ) = 3 by L254 , SCMFSA_2:69;
L257: ( CurInstr (D75 , D74) ) = ( goto D71 ) by L256 , L242 , L255;
L258: ( Comput (D70 , D69 , ( 3 + 1 )) ) = ( Following (D70 , D74) ) by EXTPRO_1:3
.= ( Exec (( goto D71 ) , D74) ) by L257;
L259: ( D73 /. ( IC D72 ) ) = ( D73 . ( IC D72 ) ) by PBOOLE:143;
L260: ( IC D72 ) = D71 by L258 , SCMFSA_2:69;
L261: ( CurInstr (D73 , D72) ) = ( halt ( SCM+FSA ) ) by L260 , L244 , L259;
L262: D70 halts_on D69 by L261 , EXTPRO_1:29;
L263: C39 = D69 by L223 , FUNCT_4:98;
L264:
now
let R20 being (Element of ( NAT ));
assume L265: ( CurInstr (R1 , ( Comput (R1 , C39 , R20) )) ) = ( halt ( SCM+FSA ) );
assume L266: 4 > R20;
L267: ( 3 + 1 ) > R20 by L266;
L268: R20 <= 3 by L267 , NAT_1:13;
per cases  by L268 , NAT_1:27;
suppose L269: R20 = ( 0 );

L270: ( Comput (R1 , C39 , R20) ) = C39 by L269 , EXTPRO_1:2;
thus L271: contradiction by L270 , L263 , L237 , L265 , L226;
end;
suppose L272: R20 = 1;

thus L273: contradiction by L272 , L263 , L249 , L265 , L226;
end;
suppose L274: R20 = 2;

thus L275: contradiction by L274 , L263 , L253 , L265 , L226;
end;
suppose L276: R20 = 3;

thus L277: contradiction by L276 , L263 , L257 , L265 , L226;
end;
end;
thus L279: ( LifeSpan (R1 , C39) ) = 4 by L264 , L263 , L261 , L262 , L226 , EXTPRO_1:def 15;
L280: ((for B34 being Int-Location holds ( ( Exec (D68 , D69) ) . B34 ) = ( D69 . B34 )) & (for B35 being FinSeq-Location holds ( ( Exec (D68 , D69) ) . B35 ) = ( D69 . B35 ))) by SCMFSA_2:70;
L281: ( DataPart ( Comput (R1 , C39 , 1) ) ) = ( DataPart C39 ) by L280 , L263 , L238 , L226 , SCMFSA_M:2;
L282: ( DataPart ( Comput (R1 , C39 , 2) ) ) = ( DataPart C39 ) by L281 , L263 , L250 , L246 , L226 , SCMFSA_M:2;
L283: ((for B36 being Int-Location holds ( ( Exec (( goto 3 ) , D76) ) . B36 ) = ( D76 . B36 )) & (for B37 being FinSeq-Location holds ( ( Exec (( goto 3 ) , D76) ) . B37 ) = ( D76 . B37 ))) by SCMFSA_2:69;
L284: ( DataPart ( Comput (R1 , C39 , 3) ) ) = ( DataPart C39 ) by L283 , L263 , L254 , L282 , L226 , SCMFSA_M:2;
L285: ( DataPart ( Comput (R1 , C39 , 4) ) ) = ( DataPart C39 ) by L284 , L263 , L258 , L245 , L226 , SCMFSA_M:2;
let C40 being (Element of ( NAT ));
L286: (C40 <= 3 or 3 < C40);
L287: (C40 = ( 0 ) or C40 = 1 or C40 = 2 or C40 = 3 or ( 3 + 1 ) <= C40) by L286 , NAT_1:13 , NAT_1:27;
per cases  by L287;
suppose L288: C40 = ( 0 );

thus L289: thesis by L288 , EXTPRO_1:2;
end;
suppose L290: C40 = 1;

thus L291: thesis by L290 , L263 , L238 , L280 , L226 , SCMFSA_M:2;
end;
suppose L292: C40 = 2;

thus L293: thesis by L292 , L263 , L250 , L246 , L281 , L226 , SCMFSA_M:2;
end;
suppose L294: C40 = 3;

thus L295: thesis by L294 , L263 , L254 , L283 , L282 , L226 , SCMFSA_M:2;
end;
suppose L296: 4 <= C40;

L297: ( CurInstr (R1 , ( Comput (R1 , C39 , C40) )) ) = ( halt ( SCM+FSA ) ) by L296 , L263 , L262 , L279 , L226 , EXTPRO_1:36;
thus L298: thesis by L297 , L279 , L285 , EXTPRO_1:24;
end;
end;
theorem
L300: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds ((R15 is_closed_on R10 , R1 & R15 is_halting_on R10 , R1 & ( R10 . R13 ) = ( 0 )) implies ( DataPart ( Comput (( R1 +* ( while=0 (R13 , R15) ) ) , ( Initialize R10 ) , ( ( LifeSpan (( R1 +* R15 ) , ( Initialize R10 )) ) + 3 )) ) ) = ( DataPart ( Comput (( R1 +* R15 ) , ( Initialize R10 ) , ( LifeSpan (( R1 +* R15 ) , ( Initialize R10 )) )) ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
assume that
L301: (R15 is_closed_on R10 , R1 & R15 is_halting_on R10 , R1)
and
L302: ( R10 . R13 ) = ( 0 );
set D79 = ( Initialize R10 );
set D80 = ( R1 +* R15 );
set D81 = ( Initialize R10 );
set D82 = ( R1 +* ( while=0 (R13 , R15) ) );
L303: ( while=0 (R13 , R15) ) c= D82 by FUNCT_4:25;
defpred S4[ Nat ] means ($1 <= ( LifeSpan (( R1 +* R15 ) , D79) ) implies (( IC ( Comput (D82 , D81 , ( 1 + $1 )) ) ) = ( ( IC ( Comput (( R1 +* R15 ) , D79 , $1) ) ) + 4 ) & ( DataPart ( Comput (D82 , D81 , ( 1 + $1 )) ) ) = ( DataPart ( Comput (( R1 +* R15 ) , D79 , $1) ) )));
L304:
now
let C41 being (Element of ( NAT ));
assume L305: S4[ C41 ];
L306:
now
L307: ( C41 + ( 0 ) ) < ( C41 + 1 ) by XREAL_1:6;
assume L308: ( C41 + 1 ) <= ( LifeSpan (( R1 +* R15 ) , D79) );
L309: C41 < ( LifeSpan (( R1 +* R15 ) , D79) ) by L308 , L307 , XXREAL_0:2;
thus L310: (( IC ( Comput (D82 , D81 , ( ( 1 + C41 ) + 1 )) ) ) = ( ( IC ( Comput (D80 , D79 , ( C41 + 1 )) ) ) + 4 ) & ( DataPart ( Comput (D82 , D81 , ( ( 1 + C41 ) + 1 )) ) ) = ( DataPart ( Comput (D80 , D79 , ( C41 + 1 )) ) )) by L309 , L301 , L305 , SCMFSA_9:19;
end;
thus L311: S4[ ( C41 + 1 ) ] by L306;
end;
set D83 = ( R13 =0_goto 4 );
set D84 = ( Comput (D82 , D81 , 1) );
set D85 = D82;
L312: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L313: ( IC D81 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L312 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L314: (not R13 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L315: ( D81 . R13 ) = ( R10 . R13 ) by L314 , FUNCT_4:11;
set D86 = ( ( card R15 ) + 4 );
L316: ( D82 /. ( IC D81 ) ) = ( D82 . ( IC D81 ) ) by PBOOLE:143;
L317: ( 0 ) in ( dom ( while=0 (R13 , R15) ) ) by SCMFSA_9:10;
L318: ( D82 . ( 0 ) ) = ( ( while=0 (R13 , R15) ) . ( 0 ) ) by L317 , FUNCT_4:13
.= D83 by SCMFSA_9:11;
L319: ( CurInstr (D82 , D81) ) = D83 by L318 , L313 , L316;
L320: ( Comput (D82 , D81 , ( ( 0 ) + 1 )) ) = ( Following (D82 , ( Comput (D82 , D81 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D82 , D81) )
.= ( Exec (D83 , D81) ) by L319;
L321: ((for B38 being Int-Location holds ( D84 . B38 ) = ( D81 . B38 )) & (for B39 being FinSeq-Location holds ( D84 . B39 ) = ( D81 . B39 ))) by L320 , SCMFSA_2:70;
L322: ( DataPart D84 ) = ( DataPart D81 ) by L321 , SCMFSA_M:2
.= ( DataPart D79 );
L323: ( IC D84 ) = 4 by L302 , L320 , L315 , SCMFSA_2:70;
L324: S4[ ( 0 ) ]
proof
assume L325: ( 0 ) <= ( LifeSpan (( R1 +* R15 ) , D79) );
L326: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L327: ( IC ( Comput (D80 , D79 , ( 0 )) ) ) = ( IC D79 )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L326 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
thus L328: thesis by L327 , L323 , L322;
end;
L329: (for B40 being (Element of ( NAT )) holds S4[ B40 ]) from NAT_1:sch 1(L324 , L304);
L330: S4[ (( LifeSpan (( R1 +* R15 ) , D79) ) qua (Element of ( NAT ))) ] by L329;
set D87 = ( Comput (D82 , D81 , ( ( ( 1 + ( LifeSpan (( R1 +* R15 ) , D79) ) ) + 1 ) + 1 )) );
set D88 = D82;
set D89 = ( Comput (D82 , D81 , ( ( 1 + ( LifeSpan (( R1 +* R15 ) , D79) ) ) + 1 )) );
set D90 = D82;
L331: D86 in ( dom ( while=0 (R13 , R15) ) ) by SCMFSA_9:13;
set D91 = ( Comput (D82 , D81 , ( 1 + ( LifeSpan (( R1 +* R15 ) , D79) ) )) );
L332: ( CurInstr (D85 , D91) ) = ( goto D86 ) by L301 , L330 , SCMFSA_9:20;
L333: D89 = ( Following (D82 , D91) ) by EXTPRO_1:3
.= ( Exec (( goto D86 ) , D91) ) by L332;
L334: ((for B41 being Int-Location holds ( D89 . B41 ) = ( D91 . B41 )) & (for B42 being FinSeq-Location holds ( D89 . B42 ) = ( D91 . B42 ))) by L333 , SCMFSA_2:69;
L335: ( D90 . D86 ) = ( ( while=0 (R13 , R15) ) . D86 ) by L331 , L303 , GRFUNC_1:2
.= ( goto ( 0 ) ) by SCMFSA_9:21;
L336: ( D90 /. ( IC D89 ) ) = ( D90 . ( IC D89 ) ) by PBOOLE:143;
L337: ( IC D89 ) = D86 by L333 , SCMFSA_2:69;
L338: ( CurInstr (D90 , D89) ) = ( goto ( 0 ) ) by L337 , L335 , L336;
L339: D87 = ( Following (D82 , D89) ) by EXTPRO_1:3
.= ( Exec (( goto ( 0 ) ) , D89) ) by L338;
L340: ((for B43 being Int-Location holds ( D87 . B43 ) = ( D89 . B43 )) & (for B44 being FinSeq-Location holds ( D87 . B44 ) = ( D89 . B44 ))) by L339 , SCMFSA_2:69;
thus L341: ( DataPart ( Comput (D82 , D81 , ( ( LifeSpan (( R1 +* R15 ) , D79) ) + 3 )) ) ) = ( DataPart D89 ) by L340 , SCMFSA_M:2
.= ( DataPart ( Comput (D80 , D79 , ( LifeSpan (( R1 +* R15 ) , D79) )) ) ) by L330 , L334 , SCMFSA_M:2;
end;
theorem
L342: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds (for R20 being (Element of ( NAT )) holds (( ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . R20 ) . R13 ) <> ( 0 ) implies ( DataPart ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . ( R20 + 1 ) ) ) = ( DataPart ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . R20 ) )))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
let R20 being (Element of ( NAT ));
assume L343: ( ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . R20 ) . R13 ) <> ( 0 );
set D92 = ( StepWhile=0 (R13 , R15 , R1 , R10) );
set D93 = ( R1 +* ( while=0 (R13 , R15) ) );
L344: ( while=0 (R13 , R15) ) c= D93 by FUNCT_4:25;
L345: ( DataPart ( Initialize ( D92 . R20 ) ) ) = ( DataPart ( D92 . R20 ) ) by MEMSTR_0:79;
L346: ( ( D92 . R20 ) . R13 ) = ( ( Initialize ( D92 . R20 ) ) . R13 ) by L345 , SCMFSA_M:2;
thus L347: ( DataPart ( D92 . ( R20 + 1 ) ) ) = ( DataPart ( Comput (( D93 +* ( while=0 (R13 , R15) ) ) , ( Initialize ( D92 . R20 ) ) , ( ( LifeSpan (( D93 +* R15 ) , ( Initialize ( D92 . R20 ) )) ) + 3 )) ) ) by SCMFSA_9:def 4
.= ( DataPart ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . R20 ) ) by L343 , L345 , L346 , L222 , L344;
end;
theorem
L348: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds (for R20 being (Element of ( NAT )) holds ((((R15 is_halting_on ( Initialized ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . R20 ) ) , ( R1 +* ( while=0 (R13 , R15) ) ) & R15 is_closed_on ( Initialized ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . R20 ) ) , ( R1 +* ( while=0 (R13 , R15) ) )) or R15 is  parahalting) & ( ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . R20 ) . R13 ) = ( 0 ) & ( ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . R20 ) . ( intloc ( 0 ) ) ) = 1) implies ( DataPart ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . ( R20 + 1 ) ) ) = ( DataPart ( IExec (R15 , ( R1 +* ( while=0 (R13 , R15) ) ) , ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . R20 )) ) )))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
let R20 being (Element of ( NAT ));
set D94 = ( NAT );
assume that
L349: ((R15 is_halting_on ( Initialized ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . R20 ) ) , ( R1 +* ( while=0 (R13 , R15) ) ) & R15 is_closed_on ( Initialized ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . R20 ) ) , ( R1 +* ( while=0 (R13 , R15) ) )) or R15 is  parahalting)
and
L350: ( ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . R20 ) . R13 ) = ( 0 )
and
L351: ( ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . R20 ) . ( intloc ( 0 ) ) ) = 1;
set D95 = ( Initialized ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . R20 ) );
set D96 = ( StepWhile=0 (R13 , R15 , R1 , R10) );
set D97 = ( R1 +* ( while=0 (R13 , R15) ) );
set D98 = ( Initialized ( D96 . R20 ) );
set D99 = ( ( R1 +* ( while=0 (R13 , R15) ) ) +* R15 );
L352: ( DataPart D95 ) = ( DataPart ( D96 . R20 ) ) by L351 , SCMFSA_M:19;
L353: (R15 is_closed_on ( D96 . R20 ) , D97 & R15 is_halting_on ( D96 . R20 ) , D97) by L352 , L349 , SCMFSA7B:18 , SCMFSA7B:19 , SCMFSA8B:5;
L354: R15 is_halting_on D95 , D97 by L349 , SCMFSA7B:19;
L355: R15 is_halting_on ( Initialized ( D96 . R20 ) ) , D97 by L354;
L356: ( Initialized ( D96 . R20 ) ) = ( Initialize ( Initialized ( D96 . R20 ) ) ) by MEMSTR_0:44;
L357: ( D97 +* R15 ) halts_on ( Initialized ( D96 . R20 ) ) by L356 , L355 , SCMFSA7B:def 7;
L358: D99 halts_on D98 by L357;
set D100 = ( Initialize ( D96 . R20 ) );
set D101 = ( D97 +* R15 );
L359: D98 = D100 by L351 , SCMFSA_M:18;
L360: ( D96 . ( R20 + 1 ) ) = ( Comput (( D97 +* ( while=0 (R13 , R15) ) ) , ( Initialize ( D96 . R20 ) ) , ( ( LifeSpan (D101 , D100) ) + 3 )) ) by SCMFSA_9:def 4;
L361: ( DataPart ( IExec (R15 , D97 , ( D96 . R20 )) ) ) = ( DataPart ( Result (D99 , D98) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Result (D99 , D98) ) )
.= ( DataPart ( Comput (D101 , D100 , ( LifeSpan (D101 , D100) )) ) ) by L359 , L358 , EXTPRO_1:23;
thus L362: ( DataPart ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . ( R20 + 1 ) ) ) = ( DataPart ( Comput (D101 , D100 , ( LifeSpan (D101 , D100) )) ) ) by L350 , L353 , L300 , L360
.= ( DataPart ( IExec (R15 , D97 , ( ( StepWhile=0 (R13 , R15 , R1 , R10) ) . R20 )) ) ) by L361;
end;
theorem
L363: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R17 being  good (Program of ( SCM+FSA )) holds ((( ProperBodyWhile=0 R13 , R17 , R10 , R1 or R17 is  parahalting) & ( R10 . ( intloc ( 0 ) ) ) = 1) implies (for R20 being (Element of ( NAT )) holds ( ( ( StepWhile=0 (R13 , R17 , R1 , R10) ) . R20 ) . ( intloc ( 0 ) ) ) = 1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R17 being  good (Program of ( SCM+FSA ));
set D102 = R17;
assume that
L364: ( ProperBodyWhile=0 R13 , D102 , R10 , R1 or D102 is  parahalting)
and
L365: ( R10 . ( intloc ( 0 ) ) ) = 1;
set D103 = ( StepWhile=0 (R13 , D102 , R1 , R10) );
set D104 = ( R1 +* ( while=0 (R13 , D102) ) );
defpred S5[ Nat ] means ( ( D103 . $1 ) . ( intloc ( 0 ) ) ) = 1;
L366: (for B45 being (Element of ( NAT )) holds (S5[ B45 ] implies S5[ ( B45 + 1 ) ]))
proof
let C42 being (Element of ( NAT ));
assume that
L367: ( ( D103 . C42 ) . ( intloc ( 0 ) ) ) = 1;
per cases ;
suppose L368: ( ( D103 . C42 ) . R13 ) <> ( 0 );

L369: ( DataPart ( D103 . ( C42 + 1 ) ) ) = ( DataPart ( D103 . C42 ) ) by L368 , L342;
thus L370: thesis by L369 , L367 , SCMFSA_M:2;
end;
suppose L371: ( ( D103 . C42 ) . R13 ) = ( 0 );

set D105 = ( NAT );
set D106 = ( Initialize ( D103 . C42 ) );
set D107 = ( D104 +* D102 );
set D108 = ( Initialized ( D103 . C42 ) );
set D109 = ( ( R1 +* ( while=0 (R13 , D102) ) ) +* D102 );
set D110 = ( Initialized ( ( StepWhile=0 (R13 , D102 , R1 , R10) ) . C42 ) );
L372: ( DataPart ( D103 . C42 ) ) = ( DataPart D110 ) by L367 , SCMFSA_M:19;
L373:  ProperBodyWhile=0 R13 , D102 , R10 , R1 by L364 , L116;
L374: D102 is_closed_on ( D103 . C42 ) , D104 by L373 , L371 , L113;
L375: D102 is_halting_on ( D103 . C42 ) , D104 by L371 , L373 , L113;
L376: D102 is_halting_on ( Initialized ( D103 . C42 ) ) , D104 by L375 , L374 , L372 , SCMFSA8B:5;
L377: ( Initialized ( D103 . C42 ) ) = ( Initialize ( Initialized ( D103 . C42 ) ) ) by MEMSTR_0:44;
L378: ( D104 +* D102 ) halts_on ( Initialized ( D103 . C42 ) ) by L377 , L376 , SCMFSA7B:def 7;
L379: D109 halts_on D108 by L378;
L380: D108 = D106 by L367 , SCMFSA_M:18;
L381: ( DataPart ( IExec (D102 , D104 , ( D103 . C42 )) ) ) = ( DataPart ( Result (D109 , D108) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Result (D109 , D108) ) )
.= ( DataPart ( Comput (D107 , D106 , ( LifeSpan (D107 , D106) )) ) ) by L380 , L379 , EXTPRO_1:23;
L382: D102 is_closed_on ( Initialized ( D103 . C42 ) ) , D104 by L374 , L372 , SCMFSA8B:3;
L383: ( DataPart ( D103 . ( C42 + 1 ) ) ) = ( DataPart ( IExec (D102 , D104 , ( D103 . C42 )) ) ) by L382 , L367 , L371 , L376 , L348;
thus L384: ( ( D103 . ( C42 + 1 ) ) . ( intloc ( 0 ) ) ) = ( ( Comput (D107 , D106 , ( LifeSpan (D107 , D106) )) ) . ( intloc ( 0 ) ) ) by L383 , L381 , SCMFSA_M:2
.= 1 by L367 , L374 , SCMFSA8C:68;
end;
end;
L386: S5[ ( 0 ) ] by L365 , SCMFSA_9:def 4;
thus L387: (for B46 being (Element of ( NAT )) holds S5[ B46 ]) from NAT_1:sch 1(L386 , L366);
end;
theorem
L388: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for R3 being (Instruction-Sequence of ( SCM+FSA )) holds (for R11 being (State of ( SCM+FSA )) holds (for R12 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds (( ProperBodyWhile=0 R13 , R15 , R11 , R2 & ( DataPart R11 ) = ( DataPart R12 )) implies (for R20 being (Element of ( NAT )) holds ( DataPart ( ( StepWhile=0 (R13 , R15 , R2 , R11) ) . R20 ) ) = ( DataPart ( ( StepWhile=0 (R13 , R15 , R3 , R12) ) . R20 ) )))))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let R3 being (Instruction-Sequence of ( SCM+FSA ));
let R11 being (State of ( SCM+FSA ));
let R12 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
assume that
L389:  ProperBodyWhile=0 R13 , R15 , R11 , R2
and
L390: ( DataPart R11 ) = ( DataPart R12 );
set D111 = ( while=0 (R13 , R15) );
set D112 = ( StepWhile=0 (R13 , R15 , R3 , R12) );
set D113 = ( R3 +* ( while=0 (R13 , R15) ) );
set D114 = ( StepWhile=0 (R13 , R15 , R2 , R11) );
set D115 = ( R2 +* ( while=0 (R13 , R15) ) );
defpred S6[ Nat ] means ( DataPart ( D114 . $1 ) ) = ( DataPart ( D112 . $1 ) );
L391: (for B47 being (Element of ( NAT )) holds (S6[ B47 ] implies S6[ ( B47 + 1 ) ]))
proof
let R20 being (Element of ( NAT ));
set D116 = ( Initialize ( D114 . R20 ) );
set D117 = ( D115 +* R15 );
set D118 = ( Initialize ( D112 . R20 ) );
set D119 = ( D113 +* R15 );
L392: R15 c= D117 by FUNCT_4:25;
L393: R15 c= D119 by FUNCT_4:25;
assume L394: ( DataPart ( D114 . R20 ) ) = ( DataPart ( D112 . R20 ) );
L395: ( ( D114 . R20 ) . R13 ) = ( ( D112 . R20 ) . R13 ) by L394 , SCMFSA_M:2;
per cases ;
suppose L396: ( ( D114 . R20 ) . R13 ) <> ( 0 );

thus L397: ( DataPart ( D114 . ( R20 + 1 ) ) ) = ( DataPart ( D114 . R20 ) ) by L396 , L342
.= ( DataPart ( D112 . ( R20 + 1 ) ) ) by L394 , L395 , L396 , L342;
end;
suppose L398: ( ( D114 . R20 ) . R13 ) = ( 0 );

L399: R15 is_closed_on ( D114 . R20 ) , D115 by L398 , L389 , L113;
L400: R15 is_halting_on ( D114 . R20 ) , D115 by L389 , L398 , L113;
L401: (R15 is_closed_on ( D112 . R20 ) , D113 & R15 is_halting_on ( D112 . R20 ) , D113) by L400 , L394 , L399 , SCMFSA8B:5;
L402: ( DataPart ( D114 . ( R20 + 1 ) ) ) = ( DataPart ( Comput (( D115 +* ( while=0 (R13 , R15) ) ) , ( Initialize ( D114 . R20 ) ) , ( ( LifeSpan (D117 , D116) ) + 3 )) ) ) by SCMFSA_9:def 4
.= ( DataPart ( Comput (D117 , D116 , ( LifeSpan (D117 , D116) )) ) ) by L398 , L399 , L400 , L300;
L403: ( DataPart ( D112 . ( R20 + 1 ) ) ) = ( DataPart ( Comput (( D113 +* ( while=0 (R13 , R15) ) ) , ( Initialize ( D112 . R20 ) ) , ( ( LifeSpan (D119 , D118) ) + 3 )) ) ) by SCMFSA_9:def 4
.= ( DataPart ( Comput (D119 , D118 , ( LifeSpan (D119 , D118) )) ) ) by L395 , L398 , L401 , L300;
L404: ( DataPart ( D114 . R20 ) ) = ( DataPart D116 ) by MEMSTR_0:79;
L405: R15 is_closed_on D116 , D117 by L404 , L399 , SCMFSA8B:3;
L406: ( DataPart D116 ) = ( DataPart ( D114 . R20 ) ) by MEMSTR_0:79
.= ( DataPart D118 ) by L394 , MEMSTR_0:79;
L407: R15 is_halting_on D116 , D117 by L399 , L400 , L404 , SCMFSA8B:5;
L408: ( LifeSpan (D117 , D116) ) = ( LifeSpan (D119 , D118) ) by L407 , L399 , L406 , L404 , L392 , L393 , SCMFSA8B:3 , SCMFSA8C:18;
thus L409: thesis by L408 , L402 , L403 , L406 , L405 , L392 , L393 , SCMFSA8C:17;
end;
end;
L411: ( DataPart ( D114 . ( 0 ) ) ) = ( DataPart R11 ) by SCMFSA_9:def 4
.= ( DataPart ( D112 . ( 0 ) ) ) by L390 , SCMFSA_9:def 4;
L412: S6[ ( 0 ) ] by L411;
thus L413: (for R20 being (Element of ( NAT )) holds S6[ R20 ]) from NAT_1:sch 1(L412 , L391);
end;
definition
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C43 being (State of ( SCM+FSA ));
let C44 being  read-write Int-Location;
let C45 being (Program of ( SCM+FSA ));
assume that
L414: ( ProperBodyWhile=0 C44 , C45 , C43 , R1 or C45 is  parahalting)
and
L415:  WithVariantWhile=0 C44 , C45 , C43 , R1;
func ExitsAtWhile=0 (C44 , C45 , R1 , C43) -> (Element of ( NAT )) means 
:L416: (ex B48 being (Element of ( NAT )) st (it = B48 & ( ( ( StepWhile=0 (C44 , C45 , R1 , C43) ) . B48 ) . C44 ) <> ( 0 ) & (for B49 being (Element of ( NAT )) holds (( ( ( StepWhile=0 (C44 , C45 , R1 , C43) ) . B49 ) . C44 ) <> ( 0 ) implies B48 <= B49)) & ( DataPart ( Comput (( R1 +* ( while=0 (C44 , C45) ) ) , ( Initialize C43 ) , ( LifeSpan (( R1 +* ( while=0 (C44 , C45) ) ) , ( Initialize C43 )) )) ) ) = ( DataPart ( ( StepWhile=0 (C44 , C45 , R1 , C43) ) . B48 ) )));
existence
proof
set D120 = ( Initialize C43 );
set D121 = ( R1 +* ( while=0 (C44 , C45) ) );
set D122 = ( StepWhile=0 (C44 , C45 , R1 , C43) );
set D123 = ( R1 +* ( while=0 (C44 , C45) ) );
L417: ( while=0 (C44 , C45) ) c= D123 by FUNCT_4:25;
defpred S7[ Nat ] means ( ( D122 . $1 ) . C44 ) <> ( 0 );
consider C46 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that L418: (for B50 being (Element of ( NAT )) holds (( C46 . ( D122 . ( B50 + 1 ) ) ) < ( C46 . ( D122 . B50 ) ) or S7[ B50 ])) by L415 , L114;
deffunc H2(Nat) = ( C46 . ( D122 . $1 ) );
L419: (for B51 being (Element of ( NAT )) holds (H2(( B51 + 1 )) < H2(B51) or S7[ B51 ])) by L418;
consider R21 being (Element of ( NAT )) such that L420: S7[ R21 ] and L421: (for R22 being (Element of ( NAT )) holds (S7[ R22 ] implies R21 <= R22)) from NAT_1:sch 18(L419);
take R21;
take R21;
thus L422: R21 = R21;
thus L423: ( ( D122 . R21 ) . C44 ) <> ( 0 ) by L420;
thus L424: (for R22 being (Element of ( NAT )) holds (( ( D122 . R22 ) . C44 ) <> ( 0 ) implies R21 <= R22)) by L421;
defpred S8[ Nat ] means (( $1 + 1 ) <= R21 implies (ex R20 being (Element of ( NAT )) st ( ( StepWhile=0 (C44 , C45 , R1 , C43) ) . ( $1 + 1 ) ) = ( Comput (D121 , D120 , R20) )));
L425:  ProperBodyWhile=0 C44 , C45 , C43 , R1 by L414 , L116;
L426:
now
let C47 being (Element of ( NAT ));
assume L427: S8[ C47 ];
L428:
now
set D124 = ( ( StepWhile=0 (C44 , C45 , R1 , C43) ) . ( C47 + 1 ) );
set D125 = ( ( StepWhile=0 (C44 , C45 , R1 , C43) ) . C47 );
set D126 = ( R1 +* ( while=0 (C44 , C45) ) );
assume L429: ( ( C47 + 1 ) + 1 ) <= R21;
L430: ( C47 + ( 0 ) ) < ( C47 + ( 1 + 1 ) ) by XREAL_1:6;
L431: C47 < R21 by L430 , L429 , XXREAL_0:2;
L432: ( D125 . C44 ) = ( 0 ) by L431 , L421;
L433: ( ( C47 + 1 ) + ( 0 ) ) < ( ( C47 + 1 ) + 1 ) by XREAL_1:6;
consider C48 being (Element of ( NAT )) such that L434: D124 = ( Comput (D121 , D120 , C48) ) by L433 , L427 , L429 , XXREAL_0:2;
L435: D124 = ( Comput (( D126 +* ( while=0 (C44 , C45) ) ) , ( Initialize D125 ) , ( ( LifeSpan (( D126 +* C45 ) , ( Initialize D125 )) ) + 3 )) ) by SCMFSA_9:def 4;
take D127 = ( C48 + ( ( LifeSpan (( D126 +* C45 ) , ( Initialize D124 )) ) + 3 ) );
L436: (C45 is_closed_on D125 , D126 & C45 is_halting_on D125 , D126) by L425 , L432 , L113;
L437: ( IC D124 ) = ( 0 ) by L436 , L435 , L432 , SCMFSA_9:22;
thus L438: ( ( StepWhile=0 (C44 , C45 , R1 , C43) ) . ( ( C47 + 1 ) + 1 ) ) = ( Comput (D121 , D120 , D127) ) by L437 , L434 , SCMFSA_9:26;
end;
thus L439: S8[ ( C47 + 1 ) ] by L428;
end;
L440: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L441: S8[ ( 0 ) ]
proof
assume L442: ( ( 0 ) + 1 ) <= R21;
take D128 = ( ( LifeSpan (( ( R1 +* ( while=0 (C44 , C45) ) ) +* C45 ) , ( Initialize C43 )) ) + 3 );
thus L443: thesis by SCMFSA_9:25;
end;
L444: (for B52 being (Element of ( NAT )) holds S8[ B52 ]) from NAT_1:sch 1(L441 , L426);
per cases ;
suppose L445: R21 = ( 0 );

L446: ( DataPart D120 ) = ( DataPart C43 ) by MEMSTR_0:79
.= ( DataPart ( D122 . R21 ) ) by L445 , SCMFSA_9:def 4;
L447: ( D120 . C44 ) = ( ( D122 . R21 ) . C44 ) by L446 , SCMFSA_M:2;
thus L448: thesis by L447 , L420 , L446 , L222 , L417;
end;
suppose L449: R21 <> ( 0 );

set D129 = ( ( StepWhile=0 (C44 , C45 , R1 , C43) ) . R21 );
set D130 = ( R1 +* ( while=0 (C44 , C45) ) );
set D131 = ( Initialize D129 );
set D132 = ( D130 +* ( while=0 (C44 , C45) ) );
consider C49 being Nat such that L450: R21 = ( C49 + 1 ) by L449 , NAT_1:6;
reconsider D133 = C49 as (Element of ( NAT )) by ORDINAL1:def 12;
set D134 = ( ( StepWhile=0 (C44 , C45 , R1 , C43) ) . D133 );
set D135 = ( R1 +* ( while=0 (C44 , C45) ) );
L451: D129 = ( Comput (( D135 +* ( while=0 (C44 , C45) ) ) , ( Initialize D134 ) , ( ( LifeSpan (( D135 +* C45 ) , ( Initialize D134 )) ) + 3 )) ) by L450 , SCMFSA_9:def 4;
L452: R21 = ( D133 + 1 ) by L450;
consider C50 being (Element of ( NAT )) such that L453: D129 = ( Comput (D121 , D120 , C50) ) by L452 , L444;
L454: D133 < R21 by L450 , NAT_1:13;
L455: ( D134 . C44 ) = ( 0 ) by L454 , L421;
L456: (C45 is_closed_on D134 , D135 & C45 is_halting_on D134 , D135) by L455 , L425 , L113;
L457: ( IC D129 ) = ( 0 ) by L456 , L451 , L455 , SCMFSA_9:22;
L458: ( IC D131 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L440 , FUNCT_4:13
.= ( IC D129 ) by L457 , FUNCOP_1:72;
L459: ( DataPart D131 ) = ( DataPart D129 ) by MEMSTR_0:79;
L460: D131 = D129 by L459 , L458 , MEMSTR_0:78;
L461: ( while=0 (C44 , C45) ) is_halting_on D129 , D130 by L420 , SCMFSA_9:18;
L462: D132 halts_on D131 by L461 , SCMFSA7B:def 7;
consider C51 being (Element of ( NAT )) such that L463: ( CurInstr (D130 , ( Comput (D130 , D129 , C51) )) ) = ( halt ( SCM+FSA ) ) by L462 , L460 , EXTPRO_1:29;
L464: ( Comput (D121 , D120 , ( C50 + C51 )) ) = ( Comput (D121 , ( Comput (D121 , D120 , C50) ) , C51) ) by EXTPRO_1:4;
L465: ( CurInstr (D121 , ( Comput (D121 , D120 , ( C50 + C51 )) )) ) = ( halt ( SCM+FSA ) ) by L453 , L463 , L464;
L466: ( Comput (D121 , D120 , ( LifeSpan (D121 , D120) )) ) = ( Comput (D121 , D120 , ( C50 + C51 )) ) by L465 , EXTPRO_1:24
.= ( Comput (D121 , D129 , C51) ) by L453 , EXTPRO_1:4
.= ( Comput (D130 , D129 , ( LifeSpan (D130 , D129) )) ) by L463 , EXTPRO_1:24;
L467: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= D129 by L460 , FUNCT_4:25;
L468: D129 is ( 0 ) -started by L467 , MEMSTR_0:29;
thus L469: thesis by L468 , L420 , L466 , L222 , L417;
end;
end;
uniqueness
proof
let C52 , C53 being (Element of ( NAT ));
given C54 being (Element of ( NAT )) such that
L471: C52 = C54
and
L472: (( ( ( StepWhile=0 (C44 , C45 , R1 , C43) ) . C54 ) . C44 ) <> ( 0 ) & (for B53 being (Element of ( NAT )) holds (( ( ( StepWhile=0 (C44 , C45 , R1 , C43) ) . B53 ) . C44 ) <> ( 0 ) implies C54 <= B53)))
and
L473: ( DataPart ( Comput (( R1 +* ( while=0 (C44 , C45) ) ) , ( Initialize C43 ) , ( LifeSpan (( R1 +* ( while=0 (C44 , C45) ) ) , ( Initialize C43 )) )) ) ) = ( DataPart ( ( StepWhile=0 (C44 , C45 , R1 , C43) ) . C54 ) );

given C55 being (Element of ( NAT )) such that
L474: C53 = C55
and
L475: (( ( ( StepWhile=0 (C44 , C45 , R1 , C43) ) . C55 ) . C44 ) <> ( 0 ) & (for B54 being (Element of ( NAT )) holds (( ( ( StepWhile=0 (C44 , C45 , R1 , C43) ) . B54 ) . C44 ) <> ( 0 ) implies C55 <= B54)))
and
L476: ( DataPart ( Comput (( R1 +* ( while=0 (C44 , C45) ) ) , ( Initialize C43 ) , ( LifeSpan (( R1 +* ( while=0 (C44 , C45) ) ) , ( Initialize C43 )) )) ) ) = ( DataPart ( ( StepWhile=0 (C44 , C45 , R1 , C43) ) . C55 ) );

L477: (C54 <= C55 & C55 <= C54) by L472 , L475;
thus L478: thesis by L477 , L471 , L474 , XXREAL_0:1;
end;
end;
theorem
L480: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds ((( R10 . ( intloc ( 0 ) ) ) = 1 & ( R10 . R13 ) <> ( 0 )) implies ( DataPart ( IExec (( while=0 (R13 , R15) ) , R1 , R10) ) ) = ( DataPart R10 ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
set D136 = ( NAT );
assume that
L481: ( R10 . ( intloc ( 0 ) ) ) = 1
and
L482: ( R10 . R13 ) <> ( 0 );
set D137 = ( while=0 (R13 , R15) );
set D138 = ( Initialized R10 );
set D139 = ( R1 +* D137 );
L483: ( while=0 (R13 , R15) ) c= D139 by FUNCT_4:25;
L484: D138 = ( Initialize D138 ) by MEMSTR_0:44;
L485: ( D138 . R13 ) = ( R10 . R13 ) by SCMFSA_M:37;
L486: D137 is_halting_on D138 , R1 by L485 , L482 , SCMFSA_9:18;
L487: D139 halts_on D138 by L486 , L484 , SCMFSA7B:def 7;
L488: ( D138 . R13 ) = ( D138 . R13 )
.= ( R10 . R13 ) by SCMFSA_M:37;
thus L489: ( DataPart ( IExec (D137 , R1 , R10) ) ) = ( DataPart ( Result (( R1 +* D137 ) , ( Initialized R10 )) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Comput (D139 , D138 , ( LifeSpan (D139 , D138) )) ) ) by L487 , EXTPRO_1:23
.= ( DataPart ( Initialized R10 ) ) by L482 , L488 , L222 , L483
.= ( DataPart R10 ) by L481 , SCMFSA_M:19;
end;
theorem
L490: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds ((( ProperBodyWhile=0 R13 , R15 , ( Initialized R10 ) , R1 or R15 is  parahalting) &  WithVariantWhile=0 R13 , R15 , ( Initialized R10 ) , R1) implies ( DataPart ( IExec (( while=0 (R13 , R15) ) , R1 , R10) ) ) = ( DataPart ( ( StepWhile=0 (R13 , R15 , R1 , ( Initialized R10 )) ) . ( ExitsAtWhile=0 (R13 , R15 , R1 , ( Initialized R10 )) ) ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
set D140 = ( NAT );
set D141 = ( while=0 (R13 , R15) );
set D142 = ( Initialized R10 );
set D143 = ( R1 +* D141 );
L491: D142 = ( Initialize D142 ) by MEMSTR_0:44;
assume L492: (( ProperBodyWhile=0 R13 , R15 , ( Initialized R10 ) , R1 or R15 is  parahalting) &  WithVariantWhile=0 R13 , R15 , ( Initialized R10 ) , R1);
L493: (ex B55 being (Element of ( NAT )) st (( ExitsAtWhile=0 (R13 , R15 , R1 , D142) ) = B55 & ( ( ( StepWhile=0 (R13 , R15 , R1 , D142) ) . B55 ) . R13 ) <> ( 0 ) & (for B56 being (Element of ( NAT )) holds (( ( ( StepWhile=0 (R13 , R15 , R1 , D142) ) . B56 ) . R13 ) <> ( 0 ) implies B55 <= B56)) & ( DataPart ( Comput (( R1 +* ( while=0 (R13 , R15) ) ) , ( Initialize D142 ) , ( LifeSpan (( R1 +* ( while=0 (R13 , R15) ) ) , ( Initialize D142 )) )) ) ) = ( DataPart ( ( StepWhile=0 (R13 , R15 , R1 , D142) ) . B55 ) ))) by L492 , L416;
L494: D141 is_halting_on D142 , R1 by L492 , L120 , L216;
L495: D143 halts_on D142 by L494 , L491 , SCMFSA7B:def 7;
thus L496: ( DataPart ( IExec (( while=0 (R13 , R15) ) , R1 , R10) ) ) = ( DataPart ( Result (( R1 +* D141 ) , ( Initialized R10 )) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Result (( R1 +* D141 ) , ( R10 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) ) )
.= ( DataPart ( ( StepWhile=0 (R13 , R15 , R1 , D142) ) . ( ExitsAtWhile=0 (R13 , R15 , R1 , D142) ) ) ) by L491 , L495 , L493 , EXTPRO_1:23;
end;
begin
L497: (for B57 being Int-Location holds (for B58 being (Program of ( SCM+FSA )) holds (( ( card B58 ) + 4 ) in ( dom ( if>0 (B57 , ( B58 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) ) & ( ( if>0 (B57 , ( B58 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) . ( ( card B58 ) + 4 ) ) = ( goto ( ( 0 ) + ( ( card B58 ) + 4 ) ) ))))
proof
set D144 = ( Stop ( SCM+FSA ) );
set D145 = ( Goto ( 0 ) );
let C56 being Int-Location;
let C57 being (Program of ( SCM+FSA ));
set D146 = ( C57 ";" D145 );
set D147 = ( C56 >0_goto ( ( card D144 ) + 3 ) );
set D148 = ( ( card C57 ) + 4 );
set D149 = D148;
set D150 = ( ( ( ( Macro D147 ) ";" D144 ) ";" ( Goto ( ( card D146 ) + 1 ) ) ) ";" C57 );
L498: ( card ( Stop ( SCM+FSA ) ) ) = 1 by COMPOS_1:4;
L499: ( card ( D145 ";" D144 ) ) = ( ( card D145 ) + ( card D144 ) ) by SCMFSA6A:21
.= ( 1 + 1 ) by L498 , SCMFSA8A:15
.= 2;
L500: ( if>0 (C56 , D146 , D144) ) = ( ( ( ( D147 ";" D144 ) ";" ( Goto ( ( card D146 ) + 1 ) ) ) ";" ( C57 ";" D145 ) ) ";" D144 ) by SCMFSA8B:def 2
.= ( ( D150 ";" D145 ) ";" D144 ) by SCMFSA6A:25
.= ( D150 ";" ( D145 ";" D144 ) ) by SCMFSA6A:25;
L501: ( card ( if>0 (C56 , D146 , D144) ) ) = ( ( card D150 ) + ( card ( D145 ";" D144 ) ) ) by L500 , SCMFSA6A:21;
L502: ( card D150 ) = ( ( card ( if>0 (C56 , D146 , D144) ) ) - ( card ( D145 ";" D144 ) ) ) by L501
.= ( ( ( card C57 ) + 6 ) - 2 ) by L499 , SCMFSA_9:2
.= D148;
L503: (not D149 in ( dom D150 )) by L502;
set D151 = ( D145 ";" D144 );
L504: D145 = ( ( 0 ) .--> ( goto ( 0 ) ) ) by SCMFSA8A:def 1;
L505: ( D145 . ( 0 ) ) = ( goto ( 0 ) ) by L504 , FUNCOP_1:72;
L506: ( dom D145 ) = { ( 0 ) } by L504 , FUNCOP_1:13;
L507: ( 0 ) in ( dom D145 ) by L506 , TARSKI:def 1;
L508: ( dom D145 ) c= ( dom D151 ) by SCMFSA6A:17;
L509: ( ( 0 ) + D148 ) in { ( B59 + D148 ) where B59 is (Element of ( NAT )) : B59 in ( dom D151 ) } by L508 , L507;
L510: D148 in ( dom ( Shift (D151 , D148) ) ) by L509 , VALUED_1:def 12;
L511: ( ( Shift (D151 , D148) ) /. D149 ) = ( ( Shift (D151 , D148) ) . ( ( 0 ) + D148 ) ) by L510 , PARTFUN1:def 6
.= ( D151 . ( 0 ) ) by L507 , L508 , VALUED_1:def 12
.= ( goto ( 0 ) ) by L507 , L505 , SCMFSA6A:15;
L512: ( card ( Stop ( SCM+FSA ) ) ) = 1 by COMPOS_1:4;
L513: ( card D146 ) = ( ( card C57 ) + ( card D145 ) ) by SCMFSA6A:21
.= ( ( card C57 ) + 1 ) by SCMFSA8A:15;
L514: ( ( ( card D146 ) + ( card D144 ) ) + 3 ) = ( ( ( card C57 ) + 4 ) + 1 ) by L513 , L512;
L515: D148 < ( ( ( card D146 ) + ( card D144 ) ) + 3 ) by L514 , NAT_1:13;
thus L516: D149 in ( dom ( if>0 (C56 , D146 , D144) ) ) by L515 , SCMFSA8C:28;
L517: ( Reloc (D151 , D148) ) = ( IncAddr (( Shift (D151 , D148) ) , D148) ) by COMPOS_1:34;
L518: ( dom ( if>0 (C56 , D146 , D144) ) ) = ( ( dom ( Directed D150 ) ) \/ ( dom ( Reloc (D151 , D148) ) ) ) by L500 , L502 , FUNCT_4:def 1;
L519: ( dom ( if>0 (C56 , D146 , D144) ) ) = ( ( dom D150 ) \/ ( dom ( Reloc (D151 , D148) ) ) ) by L518 , FUNCT_4:99;
L520: D149 in ( dom ( Reloc (D151 , D148) ) ) by L519 , L516 , L503 , XBOOLE_0:def 3;
thus L521: ( ( if>0 (C56 , D146 , D144) ) . D149 ) = ( ( Reloc (D151 , D148) ) . D149 ) by L520 , L516 , L500 , L502 , L518 , FUNCT_4:def 1
.= ( IncAddr (( goto ( 0 ) ) , D148) ) by L510 , L511 , L517 , COMPOS_1:def 21
.= ( goto ( ( 0 ) + D148 ) ) by SCMFSA_4:1;
end;
L522: (for B60 being Int-Location holds (for B61 being (Program of ( SCM+FSA )) holds ( UsedIntLoc ( if>0 (B60 , ( B61 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) ) = ( UsedIntLoc ( ( if>0 (B60 , ( B61 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) +* ( ( ( card B61 ) + 4 ) .--> ( goto ( 0 ) ) ) ) )))
proof
let C58 being Int-Location;
let C59 being (Program of ( SCM+FSA ));
set D152 = ( ( card C59 ) + 4 );
set D153 = ( if>0 (C58 , ( C59 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) );
set D154 = ( ( ( card C59 ) + 4 ) .--> ( goto ( 0 ) ) );
consider C60 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L523: (for B62 being (Instruction of ( SCM+FSA )) holds ( C60 . B62 ) = ( UsedIntLoc B62 )) and L524: ( UsedIntLoc D153 ) = ( Union ( C60 * D153 ) ) by SF_MASTR:def 2;
L525: ( dom C60 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
L526:
now
thus L527: ( dom ( C60 * D153 ) ) = ( dom ( C60 * D153 ) );
L528: ( rng ( D153 +* D154 ) ) c= ( dom C60 ) by L525 , RELAT_1:def 19;
L529: ( dom D154 ) = { ( ( card C59 ) + 4 ) } by FUNCOP_1:13;
L530: D152 in ( dom D154 ) by L529 , TARSKI:def 1;
L531: ( ( card C59 ) + 4 ) in ( dom D153 ) by L497;
L532: (( dom ( D153 +* D154 ) ) = ( ( dom D153 ) \/ ( dom D154 ) ) & ( dom D154 ) c= ( dom D153 )) by L531 , L529 , FUNCT_4:def 1 , ZFMISC_1:31;
L533: ( dom D153 ) = ( dom ( D153 +* D154 ) ) by L532 , XBOOLE_1:12;
L534: ( rng D153 ) c= ( dom C60 ) by L525 , RELAT_1:def 19;
thus L535: ( dom ( C60 * D153 ) ) = ( dom D153 ) by L534 , RELAT_1:27
.= ( dom ( C60 * ( D153 +* D154 ) ) ) by L528 , L533 , RELAT_1:27;
let C61 being set;
assume L536: C61 in ( dom ( C60 * D153 ) );
per cases ;
suppose L537: C61 <> D152;

L538: (not C61 in ( dom D154 )) by L537 , L529 , TARSKI:def 1;
thus L539: ( ( C60 * D153 ) . C61 ) = ( C60 . ( D153 . C61 ) ) by L536 , FUNCT_1:12
.= ( C60 . ( ( D153 +* D154 ) . C61 ) ) by L538 , FUNCT_4:11
.= ( ( C60 * ( D153 +* D154 ) ) . C61 ) by L535 , L536 , FUNCT_1:12;
end;
suppose L540: C61 = D152;

thus L541: ( ( C60 * D153 ) . C61 ) = ( C60 . ( D153 . C61 ) ) by L536 , FUNCT_1:12
.= ( C60 . ( goto ( ( 0 ) + ( ( card C59 ) + 4 ) ) ) ) by L540 , L497
.= ( UsedIntLoc ( goto ( ( 0 ) + ( ( card C59 ) + 4 ) ) ) ) by L523
.= ( {} ) by SF_MASTR:15
.= ( UsedIntLoc ( goto ( 0 ) ) ) by SF_MASTR:15
.= ( C60 . ( goto ( 0 ) ) ) by L523
.= ( C60 . ( D154 . C61 ) ) by L540 , FUNCOP_1:72
.= ( C60 . ( ( D153 +* D154 ) . C61 ) ) by L530 , L540 , FUNCT_4:13
.= ( ( C60 * ( D153 +* D154 ) ) . C61 ) by L535 , L536 , FUNCT_1:12;
end;
end;
consider C62 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L543: (for B63 being (Instruction of ( SCM+FSA )) holds ( C62 . B63 ) = ( UsedIntLoc B63 )) and L544: ( UsedIntLoc ( D153 +* D154 ) ) = ( Union ( C62 * ( D153 +* D154 ) ) ) by SF_MASTR:def 2;
L545: (for B64 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C60 . B64 ) = ( C62 . B64 ))
proof
let C63 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D155 = C63 as (Instruction of ( SCM+FSA ));
thus L546: ( C60 . C63 ) = ( UsedIntLoc D155 ) by L523
.= ( C62 . C63 ) by L543;
end;
L547: C60 = C62 by L545 , FUNCT_2:63;
thus L548: thesis by L547 , L524 , L544 , L526 , FUNCT_1:2;
end;
L549: (for B65 being Int-Location holds (for B66 being (Program of ( SCM+FSA )) holds ( UsedInt*Loc ( if>0 (B65 , ( B66 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) ) = ( UsedInt*Loc ( ( if>0 (B65 , ( B66 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) +* ( ( ( card B66 ) + 4 ) .--> ( goto ( 0 ) ) ) ) )))
proof
let C64 being Int-Location;
let C65 being (Program of ( SCM+FSA ));
set D156 = ( ( card C65 ) + 4 );
set D157 = ( if>0 (C64 , ( C65 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) );
set D158 = ( ( ( card C65 ) + 4 ) .--> ( goto ( 0 ) ) );
consider C66 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L550: (for B67 being (Instruction of ( SCM+FSA )) holds ( C66 . B67 ) = ( UsedInt*Loc B67 )) and L551: ( UsedInt*Loc D157 ) = ( Union ( C66 * D157 ) ) by SF_MASTR:def 4;
L552: ( dom C66 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
L553:
now
thus L554: ( dom ( C66 * D157 ) ) = ( dom ( C66 * D157 ) );
L555: ( rng ( D157 +* D158 ) ) c= ( dom C66 ) by L552 , RELAT_1:def 19;
L556: ( dom D158 ) = { ( ( card C65 ) + 4 ) } by FUNCOP_1:13;
L557: D156 in ( dom D158 ) by L556 , TARSKI:def 1;
L558: ( ( card C65 ) + 4 ) in ( dom D157 ) by L497;
L559: (( dom ( D157 +* D158 ) ) = ( ( dom D157 ) \/ ( dom D158 ) ) & ( dom D158 ) c= ( dom D157 )) by L558 , L556 , FUNCT_4:def 1 , ZFMISC_1:31;
L560: ( dom D157 ) = ( dom ( D157 +* D158 ) ) by L559 , XBOOLE_1:12;
L561: ( rng D157 ) c= ( dom C66 ) by L552 , RELAT_1:def 19;
thus L562: ( dom ( C66 * D157 ) ) = ( dom D157 ) by L561 , RELAT_1:27
.= ( dom ( C66 * ( D157 +* D158 ) ) ) by L555 , L560 , RELAT_1:27;
let C67 being set;
assume L563: C67 in ( dom ( C66 * D157 ) );
per cases ;
suppose L564: C67 <> D156;

L565: (not C67 in ( dom D158 )) by L564 , L556 , TARSKI:def 1;
thus L566: ( ( C66 * D157 ) . C67 ) = ( C66 . ( D157 . C67 ) ) by L563 , FUNCT_1:12
.= ( C66 . ( ( D157 +* D158 ) . C67 ) ) by L565 , FUNCT_4:11
.= ( ( C66 * ( D157 +* D158 ) ) . C67 ) by L562 , L563 , FUNCT_1:12;
end;
suppose L567: C67 = D156;

thus L568: ( ( C66 * D157 ) . C67 ) = ( C66 . ( D157 . C67 ) ) by L563 , FUNCT_1:12
.= ( C66 . ( goto ( ( 0 ) + ( ( card C65 ) + 4 ) ) ) ) by L567 , L497
.= ( UsedInt*Loc ( goto ( ( 0 ) + ( ( card C65 ) + 4 ) ) ) ) by L550
.= ( {} ) by SF_MASTR:32
.= ( UsedInt*Loc ( goto ( 0 ) ) ) by SF_MASTR:32
.= ( C66 . ( goto ( 0 ) ) ) by L550
.= ( C66 . ( D158 . C67 ) ) by L567 , FUNCOP_1:72
.= ( C66 . ( ( D157 +* D158 ) . C67 ) ) by L557 , L567 , FUNCT_4:13
.= ( ( C66 * ( D157 +* D158 ) ) . C67 ) by L562 , L563 , FUNCT_1:12;
end;
end;
consider C68 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L570: (for B68 being (Instruction of ( SCM+FSA )) holds ( C68 . B68 ) = ( UsedInt*Loc B68 )) and L571: ( UsedInt*Loc ( D157 +* D158 ) ) = ( Union ( C68 * ( D157 +* D158 ) ) ) by SF_MASTR:def 4;
L572: (for B69 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C66 . B69 ) = ( C68 . B69 ))
proof
let C69 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D159 = C69 as (Instruction of ( SCM+FSA ));
thus L573: ( C66 . C69 ) = ( UsedInt*Loc D159 ) by L550
.= ( C68 . C69 ) by L570;
end;
L574: C66 = C68 by L572 , FUNCT_2:63;
thus L575: thesis by L574 , L551 , L571 , L553 , FUNCT_1:2;
end;
theorem
L576: (for R14 being Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds ( UsedIntLoc ( while>0 (R14 , R15) ) ) = ( { R14 } \/ ( UsedIntLoc R15 ) )))
proof
let R14 being Int-Location;
let R15 being (Program of ( SCM+FSA ));
set D160 = ( Stop ( SCM+FSA ) );
set D161 = R14;
set D162 = ( R15 ";" ( Goto ( 0 ) ) );
L577: ( while>0 (D161 , R15) ) = ( ( if>0 (D161 , D162 , D160) ) +* ( ( ( card R15 ) + 4 ) .--> ( goto ( 0 ) ) ) ) by SCMFSA_9:def 2;
thus L578: ( UsedIntLoc ( while>0 (D161 , R15) ) ) = ( UsedIntLoc ( if>0 (D161 , D162 , D160) ) ) by L577 , L522
.= ( ( { D161 } \/ ( UsedIntLoc D162 ) ) \/ ( UsedIntLoc D160 ) ) by L24
.= ( ( { D161 } \/ ( ( UsedIntLoc R15 ) \/ ( UsedIntLoc ( Goto ( 0 ) ) ) ) ) \/ ( UsedIntLoc D160 ) ) by SF_MASTR:27
.= ( ( { D161 } \/ ( ( UsedIntLoc R15 ) \/ ( {} ) ) ) \/ ( UsedIntLoc D160 ) ) by L14
.= ( { D161 } \/ ( UsedIntLoc R15 ) ) by L11;
end;
theorem
L579: (for R14 being Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds ( UsedInt*Loc ( while>0 (R14 , R15) ) ) = ( UsedInt*Loc R15 )))
proof
let R14 being Int-Location;
let R15 being (Program of ( SCM+FSA ));
set D163 = ( Stop ( SCM+FSA ) );
set D164 = R14;
set D165 = ( R15 ";" ( Goto ( 0 ) ) );
L580: ( while>0 (D164 , R15) ) = ( ( if>0 (D164 , D165 , D163) ) +* ( ( ( card R15 ) + 4 ) .--> ( goto ( 0 ) ) ) ) by SCMFSA_9:def 2;
thus L581: ( UsedInt*Loc ( while>0 (D164 , R15) ) ) = ( UsedInt*Loc ( if>0 (D164 , D165 , D163) ) ) by L580 , L549
.= ( ( UsedInt*Loc D165 ) \/ ( UsedInt*Loc D163 ) ) by L26
.= ( ( ( UsedInt*Loc R15 ) \/ ( UsedInt*Loc ( Goto ( 0 ) ) ) ) \/ ( UsedInt*Loc D163 ) ) by SF_MASTR:43
.= ( ( UsedInt*Loc R15 ) \/ ( {} ) ) by L12 , L17
.= ( UsedInt*Loc R15 );
end;
definition
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C70 being (State of ( SCM+FSA ));
let C71 being  read-write Int-Location;
let C72 being (Program of ( SCM+FSA ));
pred  ProperBodyWhile>0 C71 , C72 , C70 , R1
means
:L582: (for B70 being (Element of ( NAT )) holds (( ( ( StepWhile>0 (C71 , C72 , R1 , C70) ) . B70 ) . C71 ) > ( 0 ) implies (C72 is_closed_on ( ( StepWhile>0 (C71 , C72 , R1 , C70) ) . B70 ) , ( R1 +* ( while>0 (C71 , C72) ) ) & C72 is_halting_on ( ( StepWhile>0 (C71 , C72 , R1 , C70) ) . B70 ) , ( R1 +* ( while>0 (C71 , C72) ) ))))
;pred  WithVariantWhile>0 C71 , C72 , C70 , R1
means
:L583: (ex B71 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) st (for B72 being (Element of ( NAT )) holds (( B71 . ( ( StepWhile>0 (C71 , C72 , R1 , C70) ) . ( B72 + 1 ) ) ) < ( B71 . ( ( StepWhile>0 (C71 , C72 , R1 , C70) ) . B72 ) ) or ( ( ( StepWhile>0 (C71 , C72 , R1 , C70) ) . B72 ) . C71 ) <= ( 0 ))))
;end;
theorem
L585: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for B73 being  parahalting (Program of ( SCM+FSA )) holds  ProperBodyWhile>0 R13 , B73 , R10 , R1))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let C73 being  parahalting (Program of ( SCM+FSA ));
let C74 being (Element of ( NAT ));
assume that
L586: ( ( ( StepWhile>0 (R13 , C73 , R1 , R10) ) . C74 ) . R13 ) > ( 0 );
thus L587: C73 is_closed_on ( ( StepWhile>0 (R13 , C73 , R1 , R10) ) . C74 ) , ( R1 +* ( while>0 (R13 , C73) ) ) by SCMFSA7B:18;
thus L588: thesis by SCMFSA7B:19;
end;
theorem
L589: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds (( ProperBodyWhile>0 R13 , R15 , R10 , R1 &  WithVariantWhile>0 R13 , R15 , R10 , R1) implies (( while>0 (R13 , R15) ) is_halting_on R10 , R1 & ( while>0 (R13 , R15) ) is_closed_on R10 , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
assume L590: (for B74 being (Element of ( NAT )) holds (( ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . B74 ) . R13 ) > ( 0 ) implies (R15 is_closed_on ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . B74 ) , ( R1 +* ( while>0 (R13 , R15) ) ) & R15 is_halting_on ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . B74 ) , ( R1 +* ( while>0 (R13 , R15) ) ))));
set D166 = ( Initialize R10 );
set D167 = ( R1 +* ( while>0 (R13 , R15) ) );
L591: ( D167 +* ( while>0 (R13 , R15) ) ) = D167;
defpred S9[ Nat ] means ( ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . $1 ) . R13 ) <= ( 0 );
given C75 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that
L592: (for B75 being (Element of ( NAT )) holds (( C75 . ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . ( B75 + 1 ) ) ) < ( C75 . ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . B75 ) ) or ( ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . B75 ) . R13 ) <= ( 0 )));

deffunc H3(Nat) = ( C75 . ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . $1 ) );
L593: (for R20 being (Element of ( NAT )) holds (H3(( R20 + 1 )) < H3(R20) or S9[ R20 ])) by L592;
consider C76 being (Element of ( NAT )) such that L594: S9[ C76 ] and L595: (for R22 being (Element of ( NAT )) holds (S9[ R22 ] implies C76 <= R22)) from NAT_1:sch 18(L593);
defpred S10[ Nat ] means (( $1 + 1 ) <= C76 implies (ex R20 being (Element of ( NAT )) st ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . ( $1 + 1 ) ) = ( Comput (D167 , D166 , R20) )));
L596:
now
let C77 being (Element of ( NAT ));
assume L597: S10[ C77 ];
L598:
now
set D168 = ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . ( C77 + 1 ) );
set D169 = ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . C77 );
set D170 = ( R1 +* ( while>0 (R13 , R15) ) );
assume L599: ( ( C77 + 1 ) + 1 ) <= C76;
L600: ( C77 + ( 0 ) ) < ( C77 + ( 1 + 1 ) ) by XREAL_1:6;
L601: C77 < C76 by L600 , L599 , XXREAL_0:2;
L602: ( D169 . R13 ) > ( 0 ) by L601 , L595;
L603: ( ( C77 + 1 ) + ( 0 ) ) < ( ( C77 + 1 ) + 1 ) by XREAL_1:6;
consider C78 being (Element of ( NAT )) such that L604: D168 = ( Comput (D167 , D166 , C78) ) by L603 , L597 , L599 , XXREAL_0:2;
L605: D168 = ( Comput (( D170 +* ( while>0 (R13 , R15) ) ) , ( Initialize D169 ) , ( ( LifeSpan (( D170 +* R15 ) , ( Initialize D169 )) ) + 3 )) ) by SCMFSA_9:def 5;
take D171 = ( C78 + ( ( LifeSpan (( D170 +* R15 ) , ( Initialize D168 )) ) + 3 ) );
L606: (R15 is_closed_on D169 , D170 & R15 is_halting_on D169 , D170) by L590 , L602;
L607: ( IC D168 ) = ( 0 ) by L606 , L605 , L602 , SCMFSA_9:42;
thus L608: ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . ( ( C77 + 1 ) + 1 ) ) = ( Comput (D167 , D166 , D171) ) by L607 , L604 , SCMFSA_9:45;
end;
thus L609: S10[ ( C77 + 1 ) ] by L598;
end;
L610: S10[ ( 0 ) ]
proof
assume L611: ( ( 0 ) + 1 ) <= C76;
take D172 = ( ( LifeSpan (( ( R1 +* ( while>0 (R13 , R15) ) ) +* R15 ) , ( Initialize R10 )) ) + 3 );
thus L612: thesis by SCMFSA_9:44;
end;
L613: (for B76 being (Element of ( NAT )) holds S10[ B76 ]) from NAT_1:sch 1(L610 , L596);
per cases ;
suppose L614: C76 = ( 0 );

L615: ( R10 . R13 ) <= ( 0 ) by L614 , L594 , SCMFSA_9:def 5;
thus L616: thesis by L615 , SCMFSA_9:38;
end;
suppose L617: C76 <> ( 0 );

set D173 = ( ( LifeSpan (( ( R1 +* ( while>0 (R13 , R15) ) ) +* R15 ) , ( Initialize R10 )) ) + 3 );
set D174 = ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . C76 );
set D175 = ( R1 +* ( while>0 (R13 , R15) ) );
set D176 = ( Initialize D174 );
set D177 = ( D175 +* ( while>0 (R13 , R15) ) );
consider C79 being Nat such that L618: C76 = ( C79 + 1 ) by L617 , NAT_1:6;
reconsider D178 = C79 as (Element of ( NAT )) by ORDINAL1:def 12;
set D179 = ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . D178 );
set D180 = ( R1 +* ( while>0 (R13 , R15) ) );
L619: D174 = ( Comput (( D180 +* ( while>0 (R13 , R15) ) ) , ( Initialize D179 ) , ( ( LifeSpan (( D180 +* R15 ) , ( Initialize D179 )) ) + 3 )) ) by L618 , SCMFSA_9:def 5;
L620: C76 = ( D178 + 1 ) by L618;
consider C80 being (Element of ( NAT )) such that L621: D174 = ( Comput (D167 , D166 , C80) ) by L620 , L613;
L622: D178 < C76 by L618 , NAT_1:13;
L623: ( D179 . R13 ) > ( 0 ) by L622 , L595;
L624: (R15 is_closed_on D179 , D180 & R15 is_halting_on D179 , D180) by L623 , L590;
L625: ( IC D174 ) = ( 0 ) by L624 , L619 , L623 , SCMFSA_9:42;
L626: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= D174 by L625 , MEMSTR_0:30;
L627: D176 = D174 by L626 , FUNCT_4:98;
L628: ( while>0 (R13 , R15) ) is_halting_on D174 , D175 by L594 , SCMFSA_9:38;
L629: D177 halts_on D176 by L628 , SCMFSA7B:def 7;
consider C81 being (Element of ( NAT )) such that L630: ( CurInstr (D175 , ( Comput (D175 , D174 , C81) )) ) = ( halt ( SCM+FSA ) ) by L629 , L627 , EXTPRO_1:29;
L631: ( Comput (D167 , D166 , ( C80 + C81 )) ) = ( Comput (D167 , ( Comput (D167 , D166 , C80) ) , C81) ) by EXTPRO_1:4;
L632: ( CurInstr (D167 , ( Comput (D167 , D166 , ( C80 + C81 )) )) ) = ( halt ( SCM+FSA ) ) by L621 , L630 , L631;
L633: D167 halts_on D166 by L632 , EXTPRO_1:29;
thus L634: ( while>0 (R13 , R15) ) is_halting_on R10 , R1 by L633 , SCMFSA7B:def 7;
L635:
now
let C82 being (Element of ( NAT ));
per cases ;
suppose L636: C82 <= D173;

L637: ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . ( 0 ) ) = R10 by SCMFSA_9:def 5;
L638: ( R10 . R13 ) > ( 0 ) by L637 , L595 , L617;
L639: (R15 is_closed_on R10 , D167 & R15 is_halting_on R10 , D167) by L638 , L590 , L637;
thus L640: ( IC ( Comput (D167 , D166 , C82) ) ) in ( dom ( while>0 (R13 , R15) ) ) by L639 , L636 , L638 , L591 , SCMFSA_9:42;
end;
suppose L641: C82 > D173;

L642:
now
take D181 = D173;
thus L643: (( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . 1 ) = ( Comput (D167 , D166 , D181) ) & D181 <= C82) by L641 , SCMFSA_9:44;
end;
defpred S11[ Nat ] means ($1 <= C76 & $1 <> ( 0 ) & (ex R20 being (Element of ( NAT )) st (( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . $1 ) = ( Comput (D167 , D166 , R20) ) & R20 <= C82)));
L644: (for B77 being Nat holds (S11[ B77 ] implies B77 <= C76));
L645: ( ( 0 ) + 1 ) < ( C76 + 1 ) by L617 , XREAL_1:6;
L646: 1 <= C76 by L645 , NAT_1:13;
L647: (ex B78 being Nat st S11[ B78 ]) by L646 , L642;
consider C83 being Nat such that L648: (S11[ C83 ] & (for B79 being Nat holds (S11[ B79 ] implies B79 <= C83))) from NAT_1:sch 6(L644 , L647);
reconsider D182 = C83 as (Element of ( NAT )) by ORDINAL1:def 12;
per cases ;
suppose L649: D182 = C76;

consider C84 being (Element of ( NAT )) such that L650: D174 = ( Comput (D167 , D166 , C84) ) and L651: C84 <= C82 by L649 , L648;
consider C85 being Nat such that L652: C82 = ( C84 + C85 ) by L651 , NAT_1:10;
L653: ( while>0 (R13 , R15) ) is_closed_on D174 , D175 by L594 , SCMFSA_9:38;
reconsider D183 = C85 as (Element of ( NAT )) by ORDINAL1:def 12;
L654: ( Comput (D167 , D166 , C82) ) = ( Comput (D167 , D176 , D183) ) by L627 , L650 , L652 , EXTPRO_1:4;
thus L655: ( IC ( Comput (D167 , D166 , C82) ) ) in ( dom ( while>0 (R13 , R15) ) ) by L654 , L653 , L591 , SCMFSA7B:def 6;
end;
suppose L656: D182 <> C76;

set D184 = ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . D182 );
set D185 = ( R1 +* ( while>0 (R13 , R15) ) );
consider C86 being Nat such that L657: D182 = ( C86 + 1 ) by L648 , NAT_1:6;
reconsider D186 = C86 as (Element of ( NAT )) by ORDINAL1:def 12;
set D187 = ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . D186 );
set D188 = ( R1 +* ( while>0 (R13 , R15) ) );
L658: D184 = ( Comput (( D188 +* ( while>0 (R13 , R15) ) ) , ( Initialize D187 ) , ( ( LifeSpan (( D188 +* R15 ) , ( Initialize D187 )) ) + 3 )) ) by L657 , SCMFSA_9:def 5;
L659: ( D186 + ( 0 ) ) < D182 by L657 , XREAL_1:6;
L660: D186 < C76 by L659 , L648 , XXREAL_0:2;
L661: ( D187 . R13 ) > ( 0 ) by L660 , L595;
L662: (R15 is_closed_on D187 , D188 & R15 is_halting_on D187 , D188) by L661 , L590;
L663: ( IC D184 ) = ( 0 ) by L662 , L658 , L661 , SCMFSA_9:42;
consider C87 being (Element of ( NAT )) such that L664: ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . D182 ) = ( Comput (D167 , D166 , C87) ) and L665: C87 <= C82 by L648;
consider C88 being Nat such that L666: C82 = ( C87 + C88 ) by L665 , NAT_1:10;
reconsider D189 = C88 as (Element of ( NAT )) by ORDINAL1:def 12;
L667: D184 = ( Initialize D184 ) by L664 , L663 , SCMFSA_9:45;
L668: ( Comput (D167 , D166 , C82) ) = ( Comput (( D185 +* ( while>0 (R13 , R15) ) ) , ( Initialize D184 ) , D189) ) by L667 , L664 , L666 , EXTPRO_1:4;
set D190 = ( C87 + ( ( LifeSpan (( D185 +* R15 ) , ( Initialize D184 )) ) + 3 ) );
L669: D182 < C76 by L648 , L656 , XXREAL_0:1;
L670:
now
assume L671: D190 <= C82;
L672:
now
take D191 = D190;
thus L673: (( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . ( D182 + 1 ) ) = ( Comput (D167 , D166 , D191) ) & D191 <= C82) by L664 , L663 , L671 , SCMFSA_9:45;
end;
L674: ( D182 + 1 ) <= C76 by L669 , NAT_1:13;
thus L675: contradiction by L674 , L648 , L672 , XREAL_1:29;
end;
L676: D189 < ( ( LifeSpan (( D185 +* R15 ) , ( Initialize D184 )) ) + 3 ) by L670 , L666 , XREAL_1:6;
L677: ( D184 . R13 ) > ( 0 ) by L595 , L669;
L678: (R15 is_closed_on D184 , D185 & R15 is_halting_on D184 , D185) by L677 , L590;
thus L679: ( IC ( Comput (D167 , D166 , C82) ) ) in ( dom ( while>0 (R13 , R15) ) ) by L678 , L676 , L668 , L677 , SCMFSA_9:42;
end;
end;
end;
thus L682: ( while>0 (R13 , R15) ) is_closed_on R10 , R1 by L635 , SCMFSA7B:def 6;
end;
end;
theorem
L684: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for B80 being  parahalting (Program of ( SCM+FSA )) holds ( WithVariantWhile>0 R13 , B80 , R10 , R1 implies (( while>0 (R13 , B80) ) is_halting_on R10 , R1 & ( while>0 (R13 , B80) ) is_closed_on R10 , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let C89 being  parahalting (Program of ( SCM+FSA ));
assume that
L685:  WithVariantWhile>0 R13 , C89 , R10 , R1;
L686:  ProperBodyWhile>0 R13 , C89 , R10 , R1
proof
let C90 being (Element of ( NAT ));
assume L687: ( ( ( StepWhile>0 (R13 , C89 , R1 , R10) ) . C90 ) . R13 ) > ( 0 );
thus L688: thesis by SCMFSA7B:18 , SCMFSA7B:19;
end;
thus L689: thesis by L686 , L685 , L589;
end;
theorem
L690: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds (for B81 being ( 0 ) -started (State of ( SCM+FSA )) holds ((( while>0 (R13 , R15) ) c= R1 & ( B81 . R13 ) <= ( 0 )) implies (( LifeSpan (R1 , B81) ) = 4 & (for B82 being (Element of ( NAT )) holds ( DataPart ( Comput (R1 , B81 , B82) ) ) = ( DataPart B81 ))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
let C91 being ( 0 ) -started (State of ( SCM+FSA ));
assume that
L691: ( while>0 (R13 , R15) ) c= R1
and
L692: ( C91 . R13 ) <= ( 0 );
L693: ( R1 +* ( while>0 (R13 , R15) ) ) = R1 by L691 , FUNCT_4:98;
set D192 = ( R13 >0_goto 4 );
set D193 = ( R1 +* ( while>0 (R13 , R15) ) );
L694: ( while>0 (R13 , R15) ) c= D193 by FUNCT_4:25;
L695: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L696: 1 in ( dom ( while>0 (R13 , R15) ) ) by SCMFSA_9:10;
L697: ( D193 . 1 ) = ( ( while>0 (R13 , R15) ) . 1 ) by L696 , FUNCT_4:13
.= ( goto 2 ) by SCMFSA_9:11;
L698: C91 = ( Initialize C91 ) by MEMSTR_0:44;
L699: ( IC C91 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L698 , L695 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L700: ( D193 /. ( IC C91 ) ) = ( D193 . ( IC C91 ) ) by PBOOLE:143;
L701: ( 0 ) in ( dom ( while>0 (R13 , R15) ) ) by SCMFSA_9:10;
L702: ( D193 . ( 0 ) ) = ( ( while>0 (R13 , R15) ) . ( 0 ) ) by L701 , FUNCT_4:13
.= D192 by SCMFSA_9:11;
L703: ( CurInstr (D193 , C91) ) = D192 by L702 , L699 , L700;
L704: ( Comput (D193 , C91 , ( ( 0 ) + 1 )) ) = ( Following (D193 , ( Comput (D193 , C91 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D193 , C91) )
.= ( Exec (D192 , C91) ) by L703;
set D194 = ( ( card R15 ) + 5 );
set D195 = ( Comput (D193 , C91 , 4) );
set D196 = ( Comput (D193 , C91 , 3) );
set D197 = ( Comput (D193 , C91 , 2) );
set D198 = ( Comput (D193 , C91 , 1) );
L705: 2 in ( dom ( while>0 (R13 , R15) ) ) by SCMFSA_9:32;
L706: ( D193 . 2 ) = ( ( while>0 (R13 , R15) ) . 2 ) by L705 , FUNCT_4:13
.= ( goto 3 ) by SCMFSA_9:36;
L707: 3 in ( dom ( while>0 (R13 , R15) ) ) by SCMFSA_9:32;
L708: ( D193 . 3 ) = ( ( while>0 (R13 , R15) ) . 3 ) by L707 , FUNCT_4:13
.= ( goto D194 ) by SCMFSA_9:35;
L709: D194 in ( dom ( while>0 (R13 , R15) ) ) by SCMFSA_9:33;
L710: ( D193 . D194 ) = ( ( while>0 (R13 , R15) ) . D194 ) by L709 , L694 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by SCMFSA_9:34;
L711: ((for B83 being Int-Location holds ( ( Exec (( goto D194 ) , D196) ) . B83 ) = ( D196 . B83 )) & (for B84 being FinSeq-Location holds ( ( Exec (( goto D194 ) , D196) ) . B84 ) = ( D196 . B84 ))) by SCMFSA_2:69;
L712: ((for B85 being Int-Location holds ( ( Exec (( goto 2 ) , D198) ) . B85 ) = ( D198 . B85 )) & (for B86 being FinSeq-Location holds ( ( Exec (( goto 2 ) , D198) ) . B86 ) = ( D198 . B86 ))) by SCMFSA_2:69;
L713: ( D193 /. ( IC ( Comput (D193 , C91 , 1) ) ) ) = ( D193 . ( IC ( Comput (D193 , C91 , 1) ) ) ) by PBOOLE:143;
L714: ( IC ( Comput (D193 , C91 , 1) ) ) = ( succ ( 0 ) ) by L692 , L699 , L704 , SCMFSA_2:71
.= ( ( 0 ) + 1 );
L715: ( CurInstr (D193 , ( Comput (D193 , C91 , 1) )) ) = ( goto 2 ) by L714 , L697 , L713;
L716: ( Comput (D193 , C91 , ( 1 + 1 )) ) = ( Following (D193 , D198) ) by EXTPRO_1:3
.= ( Exec (( goto 2 ) , D198) ) by L715;
L717: ( D193 /. ( IC D197 ) ) = ( D193 . ( IC D197 ) ) by PBOOLE:143;
L718: ( IC D197 ) = 2 by L716 , SCMFSA_2:69;
L719: ( CurInstr (D193 , D197) ) = ( goto 3 ) by L718 , L706 , L717;
L720: ( Comput (D193 , C91 , ( 2 + 1 )) ) = ( Following (D193 , D197) ) by EXTPRO_1:3
.= ( Exec (( goto 3 ) , D197) ) by L719;
L721: ( D193 /. ( IC D196 ) ) = ( D193 . ( IC D196 ) ) by PBOOLE:143;
L722: ( IC D196 ) = 3 by L720 , SCMFSA_2:69;
L723: ( CurInstr (D193 , D196) ) = ( goto D194 ) by L722 , L708 , L721;
L724: ( Comput (D193 , C91 , ( 3 + 1 )) ) = ( Following (D193 , D196) ) by EXTPRO_1:3
.= ( Exec (( goto D194 ) , D196) ) by L723;
L725: ( D193 /. ( IC D195 ) ) = ( D193 . ( IC D195 ) ) by PBOOLE:143;
L726: ( IC D195 ) = D194 by L724 , SCMFSA_2:69;
L727: ( CurInstr (D193 , D195) ) = ( halt ( SCM+FSA ) ) by L726 , L710 , L725;
L728: D193 halts_on C91 by L727 , EXTPRO_1:29;
L729:
now
let R20 being (Element of ( NAT ));
assume L730: ( CurInstr (R1 , ( Comput (R1 , C91 , R20) )) ) = ( halt ( SCM+FSA ) );
assume L731: 4 > R20;
L732: ( 3 + 1 ) > R20 by L731;
L733: R20 <= 3 by L732 , NAT_1:13;
per cases  by L733 , NAT_1:27;
suppose L734: R20 = ( 0 );

L735: ( Comput (R1 , C91 , R20) ) = C91 by L734 , EXTPRO_1:2;
thus L736: contradiction by L735 , L703 , L730 , L693;
end;
suppose L737: R20 = 1;

thus L738: contradiction by L737 , L715 , L730 , L693;
end;
suppose L739: R20 = 2;

thus L740: contradiction by L739 , L719 , L730 , L693;
end;
suppose L741: R20 = 3;

thus L742: contradiction by L741 , L723 , L730 , L693;
end;
end;
thus L744: ( LifeSpan (R1 , C91) ) = 4 by L729 , L727 , L728 , L693 , EXTPRO_1:def 15;
L745: ((for B87 being Int-Location holds ( ( Exec (D192 , C91) ) . B87 ) = ( C91 . B87 )) & (for B88 being FinSeq-Location holds ( ( Exec (D192 , C91) ) . B88 ) = ( C91 . B88 ))) by SCMFSA_2:71;
L746: ( DataPart ( Comput (R1 , C91 , 1) ) ) = ( DataPart C91 ) by L745 , L704 , L693 , SCMFSA_M:2;
L747: ( DataPart ( Comput (R1 , C91 , 2) ) ) = ( DataPart C91 ) by L746 , L716 , L712 , L693 , SCMFSA_M:2;
L748: ((for B89 being Int-Location holds ( ( Exec (( goto 3 ) , D197) ) . B89 ) = ( D197 . B89 )) & (for B90 being FinSeq-Location holds ( ( Exec (( goto 3 ) , D197) ) . B90 ) = ( D197 . B90 ))) by SCMFSA_2:69;
L749: ( DataPart ( Comput (R1 , C91 , 3) ) ) = ( DataPart C91 ) by L748 , L720 , L747 , L693 , SCMFSA_M:2;
L750: ( DataPart ( Comput (R1 , C91 , 4) ) ) = ( DataPart C91 ) by L749 , L724 , L711 , L693 , SCMFSA_M:2;
let C92 being (Element of ( NAT ));
L751: (C92 <= 3 or 3 < C92);
L752: (C92 = ( 0 ) or C92 = 1 or C92 = 2 or C92 = 3 or ( 3 + 1 ) <= C92) by L751 , NAT_1:13 , NAT_1:27;
per cases  by L752;
suppose L753: C92 = ( 0 );

thus L754: thesis by L753 , EXTPRO_1:2;
end;
suppose L755: C92 = 1;

thus L756: thesis by L755 , L704 , L745 , L693 , SCMFSA_M:2;
end;
suppose L757: C92 = 2;

thus L758: thesis by L757 , L716 , L712 , L746 , L693 , SCMFSA_M:2;
end;
suppose L759: C92 = 3;

thus L760: thesis by L759 , L720 , L748 , L747 , L693 , SCMFSA_M:2;
end;
suppose L761: 4 <= C92;

L762: ( CurInstr (R1 , ( Comput (R1 , C91 , C92) )) ) = ( halt ( SCM+FSA ) ) by L761 , L728 , L744 , L693 , EXTPRO_1:36;
thus L763: thesis by L762 , L744 , L750 , EXTPRO_1:24;
end;
end;
theorem
L765: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds ((R15 is_closed_on R10 , R1 & R15 is_halting_on R10 , R1 & ( R10 . R13 ) > ( 0 )) implies ( DataPart ( Comput (( R1 +* ( while>0 (R13 , R15) ) ) , ( Initialize R10 ) , ( ( LifeSpan (( R1 +* R15 ) , ( Initialize R10 )) ) + 3 )) ) ) = ( DataPart ( Comput (( R1 +* R15 ) , ( Initialize R10 ) , ( LifeSpan (( R1 +* R15 ) , ( Initialize R10 )) )) ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
assume that
L766: (R15 is_closed_on R10 , R1 & R15 is_halting_on R10 , R1)
and
L767: ( R10 . R13 ) > ( 0 );
set D199 = ( Initialize R10 );
set D200 = ( R1 +* R15 );
set D201 = ( Initialize R10 );
set D202 = ( R1 +* ( while>0 (R13 , R15) ) );
L768: ( while>0 (R13 , R15) ) c= D202 by FUNCT_4:25;
defpred S12[ Nat ] means ($1 <= ( LifeSpan (D200 , D199) ) implies (( IC ( Comput (D202 , D201 , ( 1 + $1 )) ) ) = ( ( IC ( Comput (D200 , D199 , $1) ) ) + 4 ) & ( DataPart ( Comput (D202 , D201 , ( 1 + $1 )) ) ) = ( DataPart ( Comput (D200 , D199 , $1) ) )));
L769:
now
let C93 being (Element of ( NAT ));
assume L770: S12[ C93 ];
L771:
now
L772: ( C93 + ( 0 ) ) < ( C93 + 1 ) by XREAL_1:6;
assume L773: ( C93 + 1 ) <= ( LifeSpan (D200 , D199) );
L774: C93 < ( LifeSpan (D200 , D199) ) by L773 , L772 , XXREAL_0:2;
thus L775: (( IC ( Comput (D202 , D201 , ( ( 1 + C93 ) + 1 )) ) ) = ( ( IC ( Comput (D200 , D199 , ( C93 + 1 )) ) ) + 4 ) & ( DataPart ( Comput (D202 , D201 , ( ( 1 + C93 ) + 1 )) ) ) = ( DataPart ( Comput (D200 , D199 , ( C93 + 1 )) ) )) by L774 , L766 , L770 , SCMFSA_9:39;
end;
thus L776: S12[ ( C93 + 1 ) ] by L771;
end;
set D203 = ( R13 >0_goto 4 );
set D204 = ( Comput (D202 , D201 , 1) );
set D205 = D202;
L777: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L778: ( IC D201 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L777 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L779: (not R13 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L780: ( D201 . R13 ) = ( R10 . R13 ) by L779 , FUNCT_4:11;
set D206 = ( ( card R15 ) + 4 );
L781: ( D202 /. ( IC D201 ) ) = ( D202 . ( IC D201 ) ) by PBOOLE:143;
L782: ( 0 ) in ( dom ( while>0 (R13 , R15) ) ) by SCMFSA_9:10;
L783: ( D202 . ( 0 ) ) = ( ( while>0 (R13 , R15) ) . ( 0 ) ) by L782 , FUNCT_4:13
.= D203 by SCMFSA_9:11;
L784: ( CurInstr (D202 , D201) ) = D203 by L783 , L778 , L781;
L785: ( Comput (D202 , D201 , ( ( 0 ) + 1 )) ) = ( Following (D202 , ( Comput (D202 , D201 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D202 , D201) )
.= ( Exec (D203 , D201) ) by L784;
L786: ((for B91 being Int-Location holds ( D204 . B91 ) = ( D201 . B91 )) & (for B92 being FinSeq-Location holds ( D204 . B92 ) = ( D201 . B92 ))) by L785 , SCMFSA_2:71;
L787: ( DataPart D204 ) = ( DataPart D201 ) by L786 , SCMFSA_M:2
.= ( DataPart D199 );
L788: ( IC D204 ) = 4 by L767 , L785 , L780 , SCMFSA_2:71;
L789: S12[ ( 0 ) ]
proof
assume L790: ( 0 ) <= ( LifeSpan (D200 , D199) );
L791: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L792: ( IC ( Comput (D200 , D199 , ( 0 )) ) ) = ( IC D199 )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L791 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
thus L793: thesis by L792 , L788 , L787;
end;
L794: (for B93 being (Element of ( NAT )) holds S12[ B93 ]) from NAT_1:sch 1(L789 , L769);
L795: S12[ (( LifeSpan (D200 , D199) ) qua (Element of ( NAT ))) ] by L794;
set D207 = ( Comput (D202 , D201 , ( ( ( 1 + ( LifeSpan (D200 , D199) ) ) + 1 ) + 1 )) );
set D208 = D202;
set D209 = ( Comput (D202 , D201 , ( ( 1 + ( LifeSpan (D200 , D199) ) ) + 1 )) );
set D210 = D202;
L796: D206 in ( dom ( while>0 (R13 , R15) ) ) by SCMFSA_9:33;
set D211 = ( Comput (D202 , D201 , ( 1 + ( LifeSpan (D200 , D199) ) )) );
L797: ( CurInstr (D205 , D211) ) = ( goto D206 ) by L766 , L795 , SCMFSA_9:40;
L798: D209 = ( Following (D202 , D211) ) by EXTPRO_1:3
.= ( Exec (( goto D206 ) , D211) ) by L797;
L799: ((for B94 being Int-Location holds ( D209 . B94 ) = ( D211 . B94 )) & (for B95 being FinSeq-Location holds ( D209 . B95 ) = ( D211 . B95 ))) by L798 , SCMFSA_2:69;
L800: ( D210 . D206 ) = ( ( while>0 (R13 , R15) ) . D206 ) by L796 , L768 , GRFUNC_1:2
.= ( goto ( 0 ) ) by SCMFSA_9:41;
L801: ( D210 /. ( IC D209 ) ) = ( D210 . ( IC D209 ) ) by PBOOLE:143;
L802: ( IC D209 ) = D206 by L798 , SCMFSA_2:69;
L803: ( CurInstr (D210 , D209) ) = ( goto ( 0 ) ) by L802 , L800 , L801;
L804: D207 = ( Following (D202 , D209) ) by EXTPRO_1:3
.= ( Exec (( goto ( 0 ) ) , D209) ) by L803;
L805: ((for B96 being Int-Location holds ( D207 . B96 ) = ( D209 . B96 )) & (for B97 being FinSeq-Location holds ( D207 . B97 ) = ( D209 . B97 ))) by L804 , SCMFSA_2:69;
thus L806: ( DataPart ( Comput (D202 , D201 , ( ( LifeSpan (D200 , D199) ) + 3 )) ) ) = ( DataPart D209 ) by L805 , SCMFSA_M:2
.= ( DataPart ( Comput (D200 , D199 , ( LifeSpan (D200 , D199) )) ) ) by L795 , L799 , SCMFSA_M:2;
end;
theorem
L807: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds (for R20 being (Element of ( NAT )) holds (( ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 ) . R13 ) <= ( 0 ) implies ( DataPart ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . ( R20 + 1 ) ) ) = ( DataPart ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 ) )))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
let R20 being (Element of ( NAT ));
assume L808: ( ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 ) . R13 ) <= ( 0 );
set D212 = ( StepWhile>0 (R13 , R15 , R1 , R10) );
set D213 = ( R1 +* ( while>0 (R13 , R15) ) );
L809: ( while>0 (R13 , R15) ) c= D213 by FUNCT_4:25;
L810: ( DataPart ( Initialize ( D212 . R20 ) ) ) = ( DataPart ( D212 . R20 ) ) by MEMSTR_0:79;
L811: ( ( D212 . R20 ) . R13 ) = ( ( Initialize ( D212 . R20 ) ) . R13 ) by L810 , SCMFSA_M:2;
thus L812: ( DataPart ( D212 . ( R20 + 1 ) ) ) = ( DataPart ( Comput (( D213 +* ( while>0 (R13 , R15) ) ) , ( Initialize ( D212 . R20 ) ) , ( ( LifeSpan (( D213 +* R15 ) , ( Initialize ( D212 . R20 ) )) ) + 3 )) ) ) by SCMFSA_9:def 5
.= ( DataPart ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 ) ) by L808 , L810 , L811 , L690 , L809;
end;
theorem
L813: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds (for R20 being (Element of ( NAT )) holds ((((R15 is_halting_on ( Initialized ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 ) ) , ( R1 +* ( while>0 (R13 , R15) ) ) & R15 is_closed_on ( Initialized ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 ) ) , ( R1 +* ( while>0 (R13 , R15) ) )) or R15 is  parahalting) & ( ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 ) . R13 ) > ( 0 ) & ( ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 ) . ( intloc ( 0 ) ) ) = 1) implies ( DataPart ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . ( R20 + 1 ) ) ) = ( DataPart ( IExec (R15 , ( R1 +* ( while>0 (R13 , R15) ) ) , ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 )) ) )))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
let R20 being (Element of ( NAT ));
set D214 = ( NAT );
assume that
L814: ((R15 is_halting_on ( Initialized ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 ) ) , ( R1 +* ( while>0 (R13 , R15) ) ) & R15 is_closed_on ( Initialized ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 ) ) , ( R1 +* ( while>0 (R13 , R15) ) )) or R15 is  parahalting)
and
L815: ( ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 ) . R13 ) > ( 0 )
and
L816: ( ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 ) . ( intloc ( 0 ) ) ) = 1;
set D215 = ( StepWhile>0 (R13 , R15 , R1 , R10) );
set D216 = ( R1 +* ( while>0 (R13 , R15) ) );
set D217 = ( Initialized ( D215 . R20 ) );
set D218 = ( Initialized ( D215 . R20 ) );
set D219 = ( ( R1 +* ( while>0 (R13 , R15) ) ) +* R15 );
L817: ( DataPart D217 ) = ( DataPart ( D215 . R20 ) ) by L816 , SCMFSA_M:19;
L818: (R15 is_closed_on ( D215 . R20 ) , D216 & R15 is_halting_on ( D215 . R20 ) , D216) by L817 , L814 , SCMFSA7B:18 , SCMFSA7B:19 , SCMFSA8B:5;
L819: R15 is_halting_on D217 , D216 by L814 , SCMFSA7B:19;
L820: R15 is_halting_on ( Initialized ( D215 . R20 ) ) , D216 by L819;
L821: ( Initialized ( D215 . R20 ) ) = ( Initialize ( Initialized ( D215 . R20 ) ) ) by MEMSTR_0:44;
L822: ( D216 +* R15 ) halts_on ( Initialized ( D215 . R20 ) ) by L821 , L820 , SCMFSA7B:def 7;
L823: D219 halts_on D218 by L822;
set D220 = ( Initialize ( D215 . R20 ) );
set D221 = ( D216 +* R15 );
L824: D218 = D220 by L816 , SCMFSA_M:18;
L825: ( D215 . ( R20 + 1 ) ) = ( Comput (( D216 +* ( while>0 (R13 , R15) ) ) , ( Initialize ( D215 . R20 ) ) , ( ( LifeSpan (D221 , D220) ) + 3 )) ) by SCMFSA_9:def 5;
L826: ( DataPart ( IExec (R15 , D216 , ( D215 . R20 )) ) ) = ( DataPart ( Result (D219 , D218) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Result (D219 , D218) ) )
.= ( DataPart ( Comput (D221 , D220 , ( LifeSpan (D221 , D220) )) ) ) by L824 , L823 , EXTPRO_1:23;
thus L827: ( DataPart ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . ( R20 + 1 ) ) ) = ( DataPart ( Comput (D221 , D220 , ( LifeSpan (D221 , D220) )) ) ) by L815 , L818 , L765 , L825
.= ( DataPart ( IExec (R15 , D216 , ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 )) ) ) by L826;
end;
theorem
L828: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R17 being  good (Program of ( SCM+FSA )) holds ((( ProperBodyWhile>0 R13 , R17 , R10 , R1 or R17 is  parahalting) & ( R10 . ( intloc ( 0 ) ) ) = 1) implies (for R20 being (Element of ( NAT )) holds ( ( ( StepWhile>0 (R13 , R17 , R1 , R10) ) . R20 ) . ( intloc ( 0 ) ) ) = 1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R17 being  good (Program of ( SCM+FSA ));
set D222 = R17;
assume that
L829: ( ProperBodyWhile>0 R13 , D222 , R10 , R1 or D222 is  parahalting)
and
L830: ( R10 . ( intloc ( 0 ) ) ) = 1;
set D223 = ( StepWhile>0 (R13 , D222 , R1 , R10) );
set D224 = ( R1 +* ( while>0 (R13 , D222) ) );
defpred S13[ Nat ] means ( ( D223 . $1 ) . ( intloc ( 0 ) ) ) = 1;
L831: (for B98 being (Element of ( NAT )) holds (S13[ B98 ] implies S13[ ( B98 + 1 ) ]))
proof
let C94 being (Element of ( NAT ));
assume that
L832: ( ( D223 . C94 ) . ( intloc ( 0 ) ) ) = 1;
per cases ;
suppose L833: ( ( D223 . C94 ) . R13 ) <= ( 0 );

L834: ( DataPart ( D223 . ( C94 + 1 ) ) ) = ( DataPart ( D223 . C94 ) ) by L833 , L807;
thus L835: thesis by L834 , L832 , SCMFSA_M:2;
end;
suppose L836: ( ( D223 . C94 ) . R13 ) > ( 0 );

set D225 = ( Initialized ( D223 . C94 ) );
set D226 = ( ( R1 +* ( while>0 (R13 , D222) ) ) +* D222 );
L837: ( DataPart ( D223 . C94 ) ) = ( DataPart D225 ) by L832 , SCMFSA_M:19;
set D227 = ( NAT );
set D228 = ( Initialize ( D223 . C94 ) );
set D229 = ( D224 +* D222 );
L838: D225 = D228 by L832 , SCMFSA_M:18;
L839:  ProperBodyWhile>0 R13 , D222 , R10 , R1 by L829 , L585;
L840: D222 is_closed_on ( D223 . C94 ) , D224 by L839 , L836 , L582;
L841: D222 is_halting_on ( D223 . C94 ) , D224 by L836 , L839 , L582;
L842: D222 is_halting_on ( Initialized ( D223 . C94 ) ) , D224 by L841 , L840 , L837 , SCMFSA8B:5;
L843: ( Initialized ( D223 . C94 ) ) = ( Initialize ( Initialized ( D223 . C94 ) ) ) by MEMSTR_0:44;
L844: ( D224 +* D222 ) halts_on ( Initialized ( D223 . C94 ) ) by L843 , L842 , SCMFSA7B:def 7;
L845: D226 halts_on D225 by L844;
L846: ( DataPart ( IExec (D222 , D224 , ( D223 . C94 )) ) ) = ( DataPart ( Result (D226 , D225) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Result (D226 , D225) ) )
.= ( DataPart ( Comput (D229 , D228 , ( LifeSpan (D229 , D228) )) ) ) by L838 , L845 , EXTPRO_1:23;
L847: D222 is_closed_on ( Initialized ( D223 . C94 ) ) , D224 by L840 , L837 , SCMFSA8B:3;
L848: ( DataPart ( D223 . ( C94 + 1 ) ) ) = ( DataPart ( IExec (D222 , D224 , ( D223 . C94 )) ) ) by L847 , L832 , L836 , L842 , L813;
thus L849: ( ( D223 . ( C94 + 1 ) ) . ( intloc ( 0 ) ) ) = ( ( Comput (D229 , D228 , ( LifeSpan (D229 , D228) )) ) . ( intloc ( 0 ) ) ) by L848 , L846 , SCMFSA_M:2
.= 1 by L832 , L840 , SCMFSA8C:68;
end;
end;
L851: S13[ ( 0 ) ] by L830 , SCMFSA_9:def 5;
thus L852: (for B99 being (Element of ( NAT )) holds S13[ B99 ]) from NAT_1:sch 1(L851 , L831);
end;
theorem
L853: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for R3 being (Instruction-Sequence of ( SCM+FSA )) holds (for R11 being (State of ( SCM+FSA )) holds (for R12 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds (( ProperBodyWhile>0 R13 , R15 , R11 , R2 & ( DataPart R11 ) = ( DataPart R12 )) implies (for R20 being (Element of ( NAT )) holds ( DataPart ( ( StepWhile>0 (R13 , R15 , R2 , R11) ) . R20 ) ) = ( DataPart ( ( StepWhile>0 (R13 , R15 , R3 , R12) ) . R20 ) )))))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let R3 being (Instruction-Sequence of ( SCM+FSA ));
let R11 being (State of ( SCM+FSA ));
let R12 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
assume that
L854:  ProperBodyWhile>0 R13 , R15 , R11 , R2
and
L855: ( DataPart R11 ) = ( DataPart R12 );
set D230 = ( while>0 (R13 , R15) );
set D231 = ( StepWhile>0 (R13 , R15 , R3 , R12) );
set D232 = ( R3 +* ( while>0 (R13 , R15) ) );
set D233 = ( StepWhile>0 (R13 , R15 , R2 , R11) );
set D234 = ( R2 +* ( while>0 (R13 , R15) ) );
defpred S14[ Nat ] means ( DataPart ( D233 . $1 ) ) = ( DataPart ( D231 . $1 ) );
L856: (for R20 being (Element of ( NAT )) holds (S14[ R20 ] implies S14[ ( R20 + 1 ) ]))
proof
let R20 being (Element of ( NAT ));
set D235 = ( Initialize ( D233 . R20 ) );
set D236 = ( D234 +* R15 );
set D237 = ( Initialize ( D231 . R20 ) );
set D238 = ( D232 +* R15 );
L857: R15 c= D236 by FUNCT_4:25;
L858: R15 c= D238 by FUNCT_4:25;
assume L859: ( DataPart ( D233 . R20 ) ) = ( DataPart ( D231 . R20 ) );
L860: ( ( D233 . R20 ) . R13 ) = ( ( D231 . R20 ) . R13 ) by L859 , SCMFSA_M:2;
per cases ;
suppose L861: ( ( D233 . R20 ) . R13 ) <= ( 0 );

thus L862: ( DataPart ( D233 . ( R20 + 1 ) ) ) = ( DataPart ( D233 . R20 ) ) by L861 , L807
.= ( DataPart ( D231 . ( R20 + 1 ) ) ) by L859 , L860 , L861 , L807;
end;
suppose L863: ( ( D233 . R20 ) . R13 ) > ( 0 );

L864: R15 is_closed_on ( D233 . R20 ) , D234 by L863 , L854 , L582;
L865: R15 is_halting_on ( D233 . R20 ) , D234 by L854 , L863 , L582;
L866: (R15 is_closed_on ( D231 . R20 ) , D232 & R15 is_halting_on ( D231 . R20 ) , D232) by L865 , L859 , L864 , SCMFSA8B:5;
L867: ( DataPart ( D233 . ( R20 + 1 ) ) ) = ( DataPart ( Comput (( D234 +* ( while>0 (R13 , R15) ) ) , ( Initialize ( D233 . R20 ) ) , ( ( LifeSpan (D236 , D235) ) + 3 )) ) ) by SCMFSA_9:def 5
.= ( DataPart ( Comput (D236 , D235 , ( LifeSpan (D236 , D235) )) ) ) by L863 , L864 , L865 , L765;
L868: ( DataPart ( D231 . ( R20 + 1 ) ) ) = ( DataPart ( Comput (( D232 +* ( while>0 (R13 , R15) ) ) , ( Initialize ( D231 . R20 ) ) , ( ( LifeSpan (D238 , D237) ) + 3 )) ) ) by SCMFSA_9:def 5
.= ( DataPart ( Comput (D238 , D237 , ( LifeSpan (D238 , D237) )) ) ) by L860 , L863 , L866 , L765;
L869: ( DataPart ( D233 . R20 ) ) = ( DataPart D235 ) by MEMSTR_0:79;
L870: R15 is_closed_on D235 , D236 by L869 , L864 , SCMFSA8B:3;
L871: ( DataPart D235 ) = ( DataPart ( D233 . R20 ) ) by MEMSTR_0:79
.= ( DataPart D237 ) by L859 , MEMSTR_0:79;
L872: R15 is_halting_on D235 , D236 by L864 , L865 , L869 , SCMFSA8B:5;
L873: ( LifeSpan (D236 , D235) ) = ( LifeSpan (D238 , D237) ) by L872 , L864 , L871 , L869 , L857 , L858 , SCMFSA8B:3 , SCMFSA8C:18;
thus L874: thesis by L873 , L867 , L868 , L871 , L870 , L857 , L858 , SCMFSA8C:17;
end;
end;
L876: ( DataPart ( D233 . ( 0 ) ) ) = ( DataPart R11 ) by SCMFSA_9:def 5
.= ( DataPart ( D231 . ( 0 ) ) ) by L855 , SCMFSA_9:def 5;
L877: S14[ ( 0 ) ] by L876;
thus L878: (for R20 being (Element of ( NAT )) holds S14[ R20 ]) from NAT_1:sch 1(L877 , L856);
end;
definition
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C95 being (State of ( SCM+FSA ));
let C96 being  read-write Int-Location;
let C97 being (Program of ( SCM+FSA ));
assume that
L879: ( ProperBodyWhile>0 C96 , C97 , C95 , R1 or C97 is  parahalting)
and
L880:  WithVariantWhile>0 C96 , C97 , C95 , R1;
func ExitsAtWhile>0 (C96 , C97 , R1 , C95) -> (Element of ( NAT )) means 
:L881: (ex B100 being (Element of ( NAT )) st (it = B100 & ( ( ( StepWhile>0 (C96 , C97 , R1 , C95) ) . B100 ) . C96 ) <= ( 0 ) & (for B101 being (Element of ( NAT )) holds (( ( ( StepWhile>0 (C96 , C97 , R1 , C95) ) . B101 ) . C96 ) <= ( 0 ) implies B100 <= B101)) & ( DataPart ( Comput (( R1 +* ( while>0 (C96 , C97) ) ) , ( Initialize C95 ) , ( LifeSpan (( R1 +* ( while>0 (C96 , C97) ) ) , ( Initialize C95 )) )) ) ) = ( DataPart ( ( StepWhile>0 (C96 , C97 , R1 , C95) ) . B100 ) )));
existence
proof
set D239 = ( Initialize C95 );
set D240 = ( R1 +* ( while>0 (C96 , C97) ) );
set D241 = ( StepWhile>0 (C96 , C97 , R1 , C95) );
set D242 = ( R1 +* ( while>0 (C96 , C97) ) );
L882: ( while>0 (C96 , C97) ) c= D242 by FUNCT_4:25;
defpred S15[ Nat ] means ( ( D241 . $1 ) . C96 ) <= ( 0 );
consider C98 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that L883: (for B102 being (Element of ( NAT )) holds (( C98 . ( D241 . ( B102 + 1 ) ) ) < ( C98 . ( D241 . B102 ) ) or S15[ B102 ])) by L880 , L583;
deffunc H4(Nat) = ( C98 . ( D241 . $1 ) );
L884: (for B103 being (Element of ( NAT )) holds (H4(( B103 + 1 )) < H4(B103) or S15[ B103 ])) by L883;
consider R21 being (Element of ( NAT )) such that L885: S15[ R21 ] and L886: (for R22 being (Element of ( NAT )) holds (S15[ R22 ] implies R21 <= R22)) from NAT_1:sch 18(L884);
take R21;
take R21;
thus L887: R21 = R21;
thus L888: ( ( D241 . R21 ) . C96 ) <= ( 0 ) by L885;
thus L889: (for R22 being (Element of ( NAT )) holds (( ( D241 . R22 ) . C96 ) <= ( 0 ) implies R21 <= R22)) by L886;
defpred S16[ Nat ] means (( $1 + 1 ) <= R21 implies (ex R20 being (Element of ( NAT )) st ( ( StepWhile>0 (C96 , C97 , R1 , C95) ) . ( $1 + 1 ) ) = ( Comput (D240 , D239 , R20) )));
L890:  ProperBodyWhile>0 C96 , C97 , C95 , R1 by L879 , L585;
L891:
now
let C99 being (Element of ( NAT ));
assume L892: S16[ C99 ];
L893:
now
set D243 = ( ( StepWhile>0 (C96 , C97 , R1 , C95) ) . ( C99 + 1 ) );
set D244 = ( ( StepWhile>0 (C96 , C97 , R1 , C95) ) . C99 );
set D245 = ( R1 +* ( while>0 (C96 , C97) ) );
assume L894: ( ( C99 + 1 ) + 1 ) <= R21;
L895: ( C99 + ( 0 ) ) < ( C99 + ( 1 + 1 ) ) by XREAL_1:6;
L896: C99 < R21 by L895 , L894 , XXREAL_0:2;
L897: ( D244 . C96 ) > ( 0 ) by L896 , L886;
L898: ( ( C99 + 1 ) + ( 0 ) ) < ( ( C99 + 1 ) + 1 ) by XREAL_1:6;
consider C100 being (Element of ( NAT )) such that L899: D243 = ( Comput (D240 , D239 , C100) ) by L898 , L892 , L894 , XXREAL_0:2;
L900: D243 = ( Comput (( D245 +* ( while>0 (C96 , C97) ) ) , ( Initialize D244 ) , ( ( LifeSpan (( D245 +* C97 ) , ( Initialize D244 )) ) + 3 )) ) by SCMFSA_9:def 5;
take D246 = ( C100 + ( ( LifeSpan (( D245 +* C97 ) , ( Initialize D243 )) ) + 3 ) );
L901: (C97 is_closed_on D244 , D245 & C97 is_halting_on D244 , D245) by L890 , L897 , L582;
L902: ( IC D243 ) = ( 0 ) by L901 , L900 , L897 , SCMFSA_9:42;
thus L903: ( ( StepWhile>0 (C96 , C97 , R1 , C95) ) . ( ( C99 + 1 ) + 1 ) ) = ( Comput (D240 , D239 , D246) ) by L902 , L899 , SCMFSA_9:45;
end;
thus L904: S16[ ( C99 + 1 ) ] by L893;
end;
L905: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L906: S16[ ( 0 ) ]
proof
assume L907: ( ( 0 ) + 1 ) <= R21;
take D247 = ( ( LifeSpan (( ( R1 +* ( while>0 (C96 , C97) ) ) +* C97 ) , ( Initialize C95 )) ) + 3 );
thus L908: thesis by SCMFSA_9:44;
end;
L909: (for B104 being (Element of ( NAT )) holds S16[ B104 ]) from NAT_1:sch 1(L906 , L891);
per cases ;
suppose L910: R21 = ( 0 );

L911: ( DataPart D239 ) = ( DataPart C95 ) by MEMSTR_0:79
.= ( DataPart ( D241 . R21 ) ) by L910 , SCMFSA_9:def 5;
L912: ( D239 . C96 ) = ( ( D241 . R21 ) . C96 ) by L911 , SCMFSA_M:2;
thus L913: thesis by L912 , L885 , L911 , L690 , L882;
end;
suppose L914: R21 <> ( 0 );

set D248 = ( ( StepWhile>0 (C96 , C97 , R1 , C95) ) . R21 );
set D249 = ( R1 +* ( while>0 (C96 , C97) ) );
set D250 = ( Initialize D248 );
set D251 = ( D249 +* ( while>0 (C96 , C97) ) );
consider C101 being Nat such that L915: R21 = ( C101 + 1 ) by L914 , NAT_1:6;
reconsider D252 = C101 as (Element of ( NAT )) by ORDINAL1:def 12;
set D253 = ( ( StepWhile>0 (C96 , C97 , R1 , C95) ) . D252 );
set D254 = ( R1 +* ( while>0 (C96 , C97) ) );
L916: D248 = ( Comput (( D254 +* ( while>0 (C96 , C97) ) ) , ( Initialize D253 ) , ( ( LifeSpan (( D254 +* C97 ) , ( Initialize D253 )) ) + 3 )) ) by L915 , SCMFSA_9:def 5;
L917: R21 = ( D252 + 1 ) by L915;
consider C102 being (Element of ( NAT )) such that L918: D248 = ( Comput (D240 , D239 , C102) ) by L917 , L909;
L919: D252 < R21 by L915 , NAT_1:13;
L920: ( D253 . C96 ) > ( 0 ) by L919 , L886;
L921: (C97 is_closed_on D253 , D254 & C97 is_halting_on D253 , D254) by L920 , L890 , L582;
L922: ( IC D248 ) = ( 0 ) by L921 , L916 , L920 , SCMFSA_9:42;
L923: ( IC D250 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L905 , FUNCT_4:13
.= ( IC D248 ) by L922 , FUNCOP_1:72;
L924: ( DataPart D250 ) = ( DataPart D248 ) by MEMSTR_0:79;
L925: D250 = D248 by L924 , L923 , MEMSTR_0:78;
L926: ( while>0 (C96 , C97) ) is_halting_on D248 , D249 by L885 , SCMFSA_9:38;
L927: D251 halts_on D250 by L926 , SCMFSA7B:def 7;
consider C103 being (Element of ( NAT )) such that L928: ( CurInstr (D249 , ( Comput (D249 , D248 , C103) )) ) = ( halt ( SCM+FSA ) ) by L927 , L925 , EXTPRO_1:29;
L929: ( Comput (D240 , D239 , ( C102 + C103 )) ) = ( Comput (D240 , ( Comput (D240 , D239 , C102) ) , C103) ) by EXTPRO_1:4;
L930: ( CurInstr (D240 , ( Comput (D240 , D239 , ( C102 + C103 )) )) ) = ( halt ( SCM+FSA ) ) by L918 , L928 , L929;
L931: ( Comput (D240 , D239 , ( LifeSpan (D240 , D239) )) ) = ( Comput (D240 , D239 , ( C102 + C103 )) ) by L930 , EXTPRO_1:24
.= ( Comput (D240 , D248 , C103) ) by L918 , EXTPRO_1:4
.= ( Comput (D249 , D248 , ( LifeSpan (D249 , D248) )) ) by L928 , EXTPRO_1:24;
L932: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= D248 by L925 , FUNCT_4:25;
L933: D248 is ( 0 ) -started by L932 , MEMSTR_0:29;
thus L934: thesis by L933 , L885 , L931 , L690 , L882;
end;
end;
uniqueness
proof
let C104 , C105 being (Element of ( NAT ));
given C106 being (Element of ( NAT )) such that
L936: C104 = C106
and
L937: (( ( ( StepWhile>0 (C96 , C97 , R1 , C95) ) . C106 ) . C96 ) <= ( 0 ) & (for B105 being (Element of ( NAT )) holds (( ( ( StepWhile>0 (C96 , C97 , R1 , C95) ) . B105 ) . C96 ) <= ( 0 ) implies C106 <= B105)))
and
L938: ( DataPart ( Comput (( R1 +* ( while>0 (C96 , C97) ) ) , ( Initialize C95 ) , ( LifeSpan (( R1 +* ( while>0 (C96 , C97) ) ) , ( Initialize C95 )) )) ) ) = ( DataPart ( ( StepWhile>0 (C96 , C97 , R1 , C95) ) . C106 ) );

given C107 being (Element of ( NAT )) such that
L939: C105 = C107
and
L940: (( ( ( StepWhile>0 (C96 , C97 , R1 , C95) ) . C107 ) . C96 ) <= ( 0 ) & (for B106 being (Element of ( NAT )) holds (( ( ( StepWhile>0 (C96 , C97 , R1 , C95) ) . B106 ) . C96 ) <= ( 0 ) implies C107 <= B106)))
and
L941: ( DataPart ( Comput (( R1 +* ( while>0 (C96 , C97) ) ) , ( Initialize C95 ) , ( LifeSpan (( R1 +* ( while>0 (C96 , C97) ) ) , ( Initialize C95 )) )) ) ) = ( DataPart ( ( StepWhile>0 (C96 , C97 , R1 , C95) ) . C107 ) );

L942: (C106 <= C107 & C107 <= C106) by L937 , L940;
thus L943: thesis by L942 , L936 , L939 , XXREAL_0:1;
end;
end;
theorem
L945: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds ((( R10 . ( intloc ( 0 ) ) ) = 1 & ( R10 . R13 ) <= ( 0 )) implies ( DataPart ( IExec (( while>0 (R13 , R15) ) , R1 , R10) ) ) = ( DataPart R10 ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
assume that
L946: ( R10 . ( intloc ( 0 ) ) ) = 1
and
L947: ( R10 . R13 ) <= ( 0 );
set D255 = ( while>0 (R13 , R15) );
set D256 = ( Initialized R10 );
set D257 = ( R1 +* D255 );
L948: ( while>0 (R13 , R15) ) c= D257 by FUNCT_4:25;
L949: D256 = ( Initialize D256 ) by MEMSTR_0:44;
L950: ( D256 . R13 ) = ( R10 . R13 ) by SCMFSA_M:37;
L951: D255 is_halting_on D256 , R1 by L950 , L947 , SCMFSA_9:38;
L952: D257 halts_on D256 by L951 , L949 , SCMFSA7B:def 7;
L953: ( D256 . R13 ) = ( D256 . R13 )
.= ( R10 . R13 ) by SCMFSA_M:37;
thus L954: ( DataPart ( IExec (D255 , R1 , R10) ) ) = ( DataPart ( Result (( R1 +* D255 ) , ( Initialized R10 )) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Comput (D257 , D256 , ( LifeSpan (D257 , D256) )) ) ) by L952 , EXTPRO_1:23
.= ( DataPart ( Initialized R10 ) ) by L947 , L953 , L690 , L948
.= ( DataPart R10 ) by L946 , SCMFSA_M:19;
end;
theorem
L955: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds ((( ProperBodyWhile>0 R13 , R15 , ( Initialized R10 ) , R1 or R15 is  parahalting) &  WithVariantWhile>0 R13 , R15 , ( Initialized R10 ) , R1) implies ( DataPart ( IExec (( while>0 (R13 , R15) ) , R1 , R10) ) ) = ( DataPart ( ( StepWhile>0 (R13 , R15 , R1 , ( Initialized R10 )) ) . ( ExitsAtWhile>0 (R13 , R15 , R1 , ( Initialized R10 )) ) ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
set D258 = ( NAT );
set D259 = ( while>0 (R13 , R15) );
set D260 = ( Initialized R10 );
set D261 = ( R1 +* D259 );
L956: D260 = ( Initialize D260 ) by MEMSTR_0:44;
assume L957: (( ProperBodyWhile>0 R13 , R15 , ( Initialized R10 ) , R1 or R15 is  parahalting) &  WithVariantWhile>0 R13 , R15 , ( Initialized R10 ) , R1);
L958: (ex B107 being (Element of ( NAT )) st (( ExitsAtWhile>0 (R13 , R15 , R1 , D260) ) = B107 & ( ( ( StepWhile>0 (R13 , R15 , R1 , D260) ) . B107 ) . R13 ) <= ( 0 ) & (for B108 being (Element of ( NAT )) holds (( ( ( StepWhile>0 (R13 , R15 , R1 , D260) ) . B108 ) . R13 ) <= ( 0 ) implies B107 <= B108)) & ( DataPart ( Comput (( R1 +* ( while>0 (R13 , R15) ) ) , ( Initialize D260 ) , ( LifeSpan (( R1 +* ( while>0 (R13 , R15) ) ) , ( Initialize D260 )) )) ) ) = ( DataPart ( ( StepWhile>0 (R13 , R15 , R1 , D260) ) . B107 ) ))) by L957 , L881;
L959: D259 is_halting_on D260 , R1 by L957 , L589 , L684;
L960: D261 halts_on D260 by L959 , L956 , SCMFSA7B:def 7;
thus L961: ( DataPart ( IExec (D259 , R1 , R10) ) ) = ( DataPart ( Result (( R1 +* D259 ) , ( Initialized R10 )) ) ) by SCMFSA6B:def 1
.= ( DataPart ( ( StepWhile>0 (R13 , R15 , R1 , D260) ) . ( ExitsAtWhile>0 (R13 , R15 , R1 , D260) ) ) ) by L956 , L960 , L958 , EXTPRO_1:23;
end;
theorem
L962: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds (for R20 being (Element of ( NAT )) holds (( ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 ) . R13 ) <= ( 0 ) implies (for B109 being (Element of ( NAT )) holds (R20 <= B109 implies ( DataPart ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . B109 ) ) = ( DataPart ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 ) )))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
let R20 being (Element of ( NAT ));
set D262 = ( StepWhile>0 (R13 , R15 , R1 , R10) );
set D263 = ( R1 +* ( while>0 (R13 , R15) ) );
defpred S17[ Nat ] means (R20 <= $1 implies ( DataPart ( D262 . $1 ) ) = ( DataPart ( D262 . R20 ) ));
assume L963: ( ( ( StepWhile>0 (R13 , R15 , R1 , R10) ) . R20 ) . R13 ) <= ( 0 );
L964:
now
let C108 being (Element of ( NAT ));
assume that
L965: S17[ C108 ];
thus L966: S17[ ( C108 + 1 ) ]
proof
assume L967: R20 <= ( C108 + 1 );
per cases  by L967 , NAT_1:8;
suppose L968: R20 <= C108;

L969: ( ( D262 . C108 ) . R13 ) <= ( 0 ) by L968 , L963 , L965 , SCMFSA_M:2;
thus L970: thesis by L969 , L965 , L968 , L807;
end;
suppose L971: R20 = ( C108 + 1 );

thus L972: thesis by L971;
end;
end;

end;
L967: S17[ ( 0 ) ];
thus L968: (for B110 being (Element of ( NAT )) holds S17[ B110 ]) from NAT_1:sch 1(L967 , L964);
end;
theorem
L969: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for R3 being (Instruction-Sequence of ( SCM+FSA )) holds (for R11 being (State of ( SCM+FSA )) holds (for R12 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R15 being (Program of ( SCM+FSA )) holds ((( DataPart R11 ) = ( DataPart R12 ) &  ProperBodyWhile>0 R13 , R15 , R11 , R2) implies  ProperBodyWhile>0 R13 , R15 , R12 , R3)))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let R3 being (Instruction-Sequence of ( SCM+FSA ));
let R11 being (State of ( SCM+FSA ));
let R12 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R15 being (Program of ( SCM+FSA ));
assume that
L970: ( DataPart R11 ) = ( DataPart R12 )
and
L971:  ProperBodyWhile>0 R13 , R15 , R11 , R2;
let C109 being (Element of ( NAT ));
assume that
L972: ( ( ( StepWhile>0 (R13 , R15 , R3 , R12) ) . C109 ) . R13 ) > ( 0 );
L973: ( DataPart ( ( StepWhile>0 (R13 , R15 , R3 , R12) ) . C109 ) ) = ( DataPart ( ( StepWhile>0 (R13 , R15 , R2 , R11) ) . C109 ) ) by L970 , L971 , L853;
L974: ( ( ( StepWhile>0 (R13 , R15 , R2 , R11) ) . C109 ) . R13 ) > ( 0 ) by L973 , L972 , SCMFSA_M:2;
L975: (R15 is_closed_on ( ( StepWhile>0 (R13 , R15 , R2 , R11) ) . C109 ) , ( R2 +* ( while>0 (R13 , R15) ) ) & R15 is_halting_on ( ( StepWhile>0 (R13 , R15 , R2 , R11) ) . C109 ) , ( R2 +* ( while>0 (R13 , R15) ) )) by L974 , L971 , L582;
thus L976: thesis by L975 , L973 , SCMFSA8B:5;
end;
L977: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R15 being (Program of ( SCM+FSA )) holds (( R10 . ( intloc ( 0 ) ) ) = 1 implies (R15 is_closed_on R10 , R1 iff R15 is_closed_on ( Initialized R10 ) , R1)))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R15 being (Program of ( SCM+FSA ));
assume L978: ( R10 . ( intloc ( 0 ) ) ) = 1;
L979: ( DataPart ( Initialized R10 ) ) = ( DataPart R10 ) by L978 , SCMFSA_M:19;
thus L980: thesis by L979 , SCMFSA8B:3;
end;
L981: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R15 being (Program of ( SCM+FSA )) holds (( R10 . ( intloc ( 0 ) ) ) = 1 implies ((R15 is_closed_on R10 , R1 & R15 is_halting_on R10 , R1) iff (R15 is_closed_on ( Initialized R10 ) , R1 & R15 is_halting_on ( Initialized R10 ) , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R15 being (Program of ( SCM+FSA ));
assume L982: ( R10 . ( intloc ( 0 ) ) ) = 1;
L983: ( DataPart ( Initialized R10 ) ) = ( DataPart R10 ) by L982 , SCMFSA_M:19;
thus L984: thesis by L983 , SCMFSA8B:5;
end;
theorem
L985: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R17 being  good (Program of ( SCM+FSA )) holds ((( R10 . ( intloc ( 0 ) ) ) = 1 &  ProperBodyWhile>0 R13 , R17 , R10 , R1 &  WithVariantWhile>0 R13 , R17 , R10 , R1) implies (for R18 being (Element of ( NAT )) holds (for R19 being (Element of ( NAT )) holds ((R18 <> R19 & R18 <= ( ExitsAtWhile>0 (R13 , R17 , R1 , R10) ) & R19 <= ( ExitsAtWhile>0 (R13 , R17 , R1 , R10) )) implies (( ( StepWhile>0 (R13 , R17 , R1 , R10) ) . R18 ) <> ( ( StepWhile>0 (R13 , R17 , R1 , R10) ) . R19 ) & ( DataPart ( ( StepWhile>0 (R13 , R17 , R1 , R10) ) . R18 ) ) <> ( DataPart ( ( StepWhile>0 (R13 , R17 , R1 , R10) ) . R19 ) ))))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R17 being  good (Program of ( SCM+FSA ));
set D264 = R17;
assume that
L986: ( R10 . ( intloc ( 0 ) ) ) = 1
and
L987:  ProperBodyWhile>0 R13 , D264 , R10 , R1
and
L988:  WithVariantWhile>0 R13 , D264 , R10 , R1;
set D265 = ( StepWhile>0 (R13 , D264 , R1 , R10) );
set D266 = ( R1 +* ( while>0 (R13 , D264) ) );
consider C110 being (Element of ( NAT )) such that L989: ( ExitsAtWhile>0 (R13 , D264 , R1 , R10) ) = C110 and L990: ( ( D265 . C110 ) . R13 ) <= ( 0 ) and L991: (for B111 being (Element of ( NAT )) holds (( ( D265 . B111 ) . R13 ) <= ( 0 ) implies C110 <= B111)) and L992: ( DataPart ( Comput (( R1 +* ( while>0 (R13 , D264) ) ) , ( Initialize R10 ) , ( LifeSpan (( R1 +* ( while>0 (R13 , D264) ) ) , ( R10 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) )) )) ) ) = ( DataPart ( D265 . C110 ) ) by L987 , L988 , L881;
consider C111 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that L993: (for B112 being (Element of ( NAT )) holds (( C111 . ( D265 . ( B112 + 1 ) ) ) < ( C111 . ( D265 . B112 ) ) or ( ( D265 . B112 ) . R13 ) <= ( 0 ))) by L988 , L583;
L994: (for B113 , B114 being (Element of ( NAT )) holds ((B113 < B114 & B113 <= C110 & B114 <= C110) implies ( DataPart ( D265 . B113 ) ) <> ( DataPart ( D265 . B114 ) )))
proof
let C112 , C113 being (Element of ( NAT ));
assume that
L995: C112 < C113
and
L996: C112 <= C110
and
L997: C113 <= C110;
per cases  by L997 , XXREAL_0:1;
suppose L998: C113 = C110;

assume L999: ( DataPart ( D265 . C112 ) ) = ( DataPart ( D265 . C113 ) );
L1000: ( ( D265 . C112 ) . R13 ) <= ( 0 ) by L999 , L990 , L998 , SCMFSA_M:2;
thus L1001: contradiction by L1000 , L991 , L995 , L998;
end;
suppose L1002: C113 < C110;

defpred S18[ Nat ] means (( C113 + $1 ) <= C110 implies ( DataPart ( D265 . ( C112 + $1 ) ) ) = ( DataPart ( D265 . ( C113 + $1 ) ) ));
L1003: (for B115 being (Element of ( NAT )) holds (S18[ B115 ] implies S18[ ( B115 + 1 ) ]))
proof
let C114 being (Element of ( NAT ));
assume that
L1004: (( C113 + C114 ) <= C110 implies ( DataPart ( D265 . ( C112 + C114 ) ) ) = ( DataPart ( D265 . ( C113 + C114 ) ) ))
and
L1005: ( C113 + ( C114 + 1 ) ) <= C110;
L1006: ( ( D265 . ( C113 + C114 ) ) . ( intloc ( 0 ) ) ) = 1 by L986 , L987 , L828;
L1007: ( C113 + C114 ) < ( ( C113 + C114 ) + 1 ) by XREAL_1:29;
L1008: ( C113 + C114 ) < C110 by L1007 , L1005 , XXREAL_0:2;
L1009: ( ( D265 . ( C113 + C114 ) ) . R13 ) > ( 0 ) by L1008 , L991;
L1010: D264 is_closed_on ( D265 . ( C113 + C114 ) ) , D266 by L1009 , L987 , L582;
L1011: D264 is_closed_on ( Initialized ( D265 . ( C113 + C114 ) ) ) , D266 by L1010 , L1006 , L977;
L1012: D264 is_halting_on ( D265 . ( C113 + C114 ) ) , D266 by L987 , L1009 , L582;
L1013: D264 is_halting_on ( Initialized ( D265 . ( C113 + C114 ) ) ) , D266 by L1012 , L1006 , L1010 , L981;
L1014: ( ( D265 . ( C112 + C114 ) ) . ( intloc ( 0 ) ) ) = 1 by L986 , L987 , L828;
L1015: ( ( D265 . ( C112 + C114 ) ) . R13 ) > ( 0 )
proof
assume L1016: (not thesis);
L1017: C110 <= ( C112 + C114 ) by L1016 , L991;
L1018: ( C112 + C114 ) < ( C113 + C114 ) by L995 , XREAL_1:6;
thus L1019: contradiction by L1018 , L1008 , L1017 , XXREAL_0:2;
end;
L1020: D264 is_closed_on ( D265 . ( C112 + C114 ) ) , D266 by L1015 , L987 , L582;
L1021: D264 is_closed_on ( Initialized ( D265 . ( C112 + C114 ) ) ) , D266 by L1020 , L1014 , L977;
L1022: D264 is_halting_on ( D265 . ( C112 + C114 ) ) , D266 by L987 , L1015 , L582;
L1023: D264 is_halting_on ( Initialized ( D265 . ( C112 + C114 ) ) ) , D266 by L1022 , L1014 , L1020 , L981;
thus L1024: ( DataPart ( D265 . ( C112 + ( C114 + 1 ) ) ) ) = ( DataPart ( D265 . ( ( C112 + C114 ) + 1 ) ) )
.= ( DataPart ( IExec (D264 , D266 , ( D265 . ( C112 + C114 ) )) ) ) by L1014 , L1015 , L1021 , L1023 , L813
.= ( DataPart ( IExec (D264 , D266 , ( D265 . ( C113 + C114 ) )) ) ) by L1004 , L1005 , L1007 , L1006 , L1010 , L1012 , SCMFSA8C:20 , XXREAL_0:2
.= ( DataPart ( D265 . ( ( C113 + C114 ) + 1 ) ) ) by L1006 , L1009 , L1011 , L1013 , L813
.= ( DataPart ( D265 . ( C113 + ( C114 + 1 ) ) ) );
end;
consider C115 being (Element of ( NAT )) such that L1025: C110 = ( C113 + C115 ) and L1026: 1 <= C115 by L1002 , FINSEQ_4:84;
assume L1027: ( DataPart ( D265 . C112 ) ) = ( DataPart ( D265 . C113 ) );
L1028: S18[ ( 0 ) ] by L1027;
L1029: (for B116 being (Element of ( NAT )) holds S18[ B116 ]) from NAT_1:sch 1(L1028 , L1003);
L1030: ( DataPart ( D265 . ( C112 + C115 ) ) ) = ( DataPart ( D265 . C110 ) ) by L1029 , L1025;
L1031: ( ( D265 . ( C112 + C115 ) ) . R13 ) <= ( 0 ) by L1030 , L990 , SCMFSA_M:2;
L1032: ( C112 + C115 ) < C110 by L995 , L1025 , XREAL_1:6;
thus L1033: contradiction by L1032 , L991 , L1031;
end;
end;
L1035: (for B117 , B118 being (Element of ( NAT )) holds ((B117 < B118 & B117 <= C110 & B118 <= C110) implies ( D265 . B117 ) <> ( D265 . B118 )))
proof
let C116 , C117 being (Element of ( NAT ));
assume that
L1036: C116 < C117
and
L1037: C116 <= C110
and
L1038: C117 <= C110;
defpred S19[ Nat ] means ((C116 < $1 & $1 <= C117) implies ( C111 . ( D265 . $1 ) ) < ( C111 . ( D265 . C116 ) ));
L1039: C116 < C110 by L1036 , L1038 , XXREAL_0:2;
L1040: (for B119 being (Element of ( NAT )) holds (S19[ B119 ] implies S19[ ( B119 + 1 ) ]))
proof
let C118 being (Element of ( NAT ));
assume that
L1041: ((C116 < C118 & C118 <= C117) implies ( C111 . ( D265 . C118 ) ) < ( C111 . ( D265 . C116 ) ))
and
L1042: C116 < ( C118 + 1 )
and
L1043: ( C118 + 1 ) <= C117;
L1044: C116 <= C118 by L1042 , NAT_1:13;
per cases  by L1044 , XXREAL_0:1;
suppose L1045: C116 = C118;

L1046: (not ( ( D265 . C116 ) . R13 ) <= ( 0 )) by L991 , L1039;
thus L1047: thesis by L1046 , L993 , L1045;
end;
suppose L1048: C116 < C118;

L1049: C118 < C117 by L1043 , NAT_1:13;
L1050:
now
assume L1051: ( ( D265 . C118 ) . R13 ) <= ( 0 );
L1052: C110 <= C118 by L1051 , L991;
thus L1053: contradiction by L1052 , L1038 , L1049 , XXREAL_0:2;
end;
L1054: ( C111 . ( D265 . ( C118 + 1 ) ) ) < ( C111 . ( D265 . C118 ) ) by L1050 , L993;
thus L1055: thesis by L1054 , L1041 , L1043 , L1048 , NAT_1:13 , XXREAL_0:2;
end;
end;
assume L1057: ( D265 . C116 ) = ( D265 . C117 );
L1058: S19[ ( 0 ) ];
L1059: (for B120 being (Element of ( NAT )) holds S19[ B120 ]) from NAT_1:sch 1(L1058 , L1040);
thus L1060: contradiction by L1059 , L1036 , L1057;
end;
given C119 , C120 being (Element of ( NAT )) such that
L1061: C119 <> C120
and
L1062: (C119 <= ( ExitsAtWhile>0 (R13 , D264 , R1 , R10) ) & C120 <= ( ExitsAtWhile>0 (R13 , D264 , R1 , R10) ) & (( D265 . C119 ) = ( D265 . C120 ) or ( DataPart ( D265 . C119 ) ) = ( DataPart ( D265 . C120 ) )));

L1063: (C119 < C120 or C120 < C119) by L1061 , XXREAL_0:1;
thus L1064: contradiction by L1063 , L989 , L1035 , L994 , L1062;
end;
definition
canceled 1;
end;
theorem
L1066: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R17 being  good (Program of ( SCM+FSA )) holds ((( R10 . ( intloc ( 0 ) ) ) = 1 &  ProperBodyWhile>0 R13 , R17 , R10 , R1 &  WithVariantWhile>0 R13 , R17 , R10 , R1) implies (ex B121 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) st (B121 is  on_data_only & (for B122 being (Element of ( NAT )) holds (( B121 . ( ( StepWhile>0 (R13 , R17 , R1 , R10) ) . ( B122 + 1 ) ) ) < ( B121 . ( ( StepWhile>0 (R13 , R17 , R1 , R10) ) . B122 ) ) or ( ( ( StepWhile>0 (R13 , R17 , R1 , R10) ) . B122 ) . R13 ) <= ( 0 ))))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R17 being  good (Program of ( SCM+FSA ));
set D267 = R17;
assume that
L1067: ( R10 . ( intloc ( 0 ) ) ) = 1
and
L1068:  ProperBodyWhile>0 R13 , D267 , R10 , R1
and
L1069:  WithVariantWhile>0 R13 , D267 , R10 , R1;
set D268 = ( StepWhile>0 (R13 , D267 , R1 , R10) );
set D269 = ( R1 +* ( while>0 (R13 , D267) ) );
consider C121 being (Element of ( NAT )) such that L1070: ( ExitsAtWhile>0 (R13 , D267 , R1 , R10) ) = C121 and L1071: ( ( D268 . C121 ) . R13 ) <= ( 0 ) and L1072: (for B123 being (Element of ( NAT )) holds (( ( D268 . B123 ) . R13 ) <= ( 0 ) implies C121 <= B123)) and L1073: ( DataPart ( Comput (( R1 +* ( while>0 (R13 , D267) ) ) , ( Initialize R10 ) , ( LifeSpan (( R1 +* ( while>0 (R13 , D267) ) ) , ( Initialize R10 )) )) ) ) = ( DataPart ( ( StepWhile>0 (R13 , D267 , R1 , R10) ) . C121 ) ) by L1068 , L1069 , L881;
consider C122 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that L1074: (for B124 being (Element of ( NAT )) holds (( C122 . ( D268 . ( B124 + 1 ) ) ) < ( C122 . ( D268 . B124 ) ) or ( ( D268 . B124 ) . R13 ) <= ( 0 ))) by L1069 , L583;
defpred S20[ (State of ( SCM+FSA )) , set ] means ((ex B125 being (Element of ( NAT )) st (B125 <= C121 & ( DataPart $1 ) = ( DataPart ( D268 . B125 ) ) & $2 = ( C122 . ( D268 . B125 ) ))) or ((not (ex B126 being (Element of ( NAT )) st (B126 <= C121 & ( DataPart $1 ) = ( DataPart ( D268 . B126 ) )))) & $2 = ( 0 )));
L1075: (for B127 being (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) holds (ex B128 being (Element of ( NAT )) st S20[ B127 , B128 ]))
proof
let C123 being (Element of ( product ( the_Values_of ( SCM+FSA ) ) ));
per cases ;
suppose L1076: (ex B129 being (Element of ( NAT )) st (B129 <= C121 & ( DataPart C123 ) = ( DataPart ( D268 . B129 ) )));

consider C124 being (Element of ( NAT )) such that L1077: (C124 <= C121 & ( DataPart C123 ) = ( DataPart ( D268 . C124 ) )) by L1076;
take ( C122 . ( D268 . C124 ) );
thus L1078: thesis by L1077;
end;
suppose L1079: (not (ex B130 being (Element of ( NAT )) st (B130 <= C121 & ( DataPart C123 ) = ( DataPart ( D268 . B130 ) ))));

take ( 0 );
thus L1080: thesis by L1079;
end;
end;
consider C125 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that L1082: (for B131 being (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) holds S20[ B131 , ( C125 . B131 ) ]) from FUNCT_2:sch 3(L1075);
take C125;
thus L1083:now
let R11 being (State of ( SCM+FSA ));
let R12 being (State of ( SCM+FSA ));
assume that
L1084: ( DataPart R11 ) = ( DataPart R12 );
reconsider D270 = R11 , D271 = R12 as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
L1085: (S20[ D270 , ( C125 . D270 ) ] & S20[ D271 , ( C125 . D271 ) ]) by L1082;
thus L1086: ( C125 . R11 ) = ( C125 . R12 ) by L1085 , L1067 , L1068 , L1069 , L1070 , L1084 , L985;
end;
let C126 being (Element of ( NAT ));
per cases ;
suppose L1087: C126 < C121;

L1088: ( C126 + 1 ) <= C121 by L1087 , NAT_1:13;
consider C127 being (Element of ( NAT )) such that L1089: (C127 <= C121 & ( DataPart ( D268 . ( C126 + 1 ) ) ) = ( DataPart ( D268 . C127 ) )) and L1090: ( C125 . ( D268 . ( C126 + 1 ) ) ) = ( C122 . ( D268 . C127 ) ) by L1088 , L1082;
L1091: ( C126 + 1 ) = C127 by L1067 , L1068 , L1069 , L1070 , L1088 , L1089 , L985;
consider C128 being (Element of ( NAT )) such that L1092: (C128 <= C121 & ( DataPart ( D268 . C126 ) ) = ( DataPart ( D268 . C128 ) )) and L1093: ( C125 . ( D268 . C126 ) ) = ( C122 . ( D268 . C128 ) ) by L1082 , L1087;
L1094: C126 = C128 by L1067 , L1068 , L1069 , L1070 , L1087 , L1092 , L985;
thus L1095: thesis by L1094 , L1074 , L1093 , L1090 , L1091;
end;
suppose L1096: C121 <= C126;

L1097: ( DataPart ( D268 . C121 ) ) = ( DataPart ( D268 . C126 ) ) by L1096 , L1071 , L962;
thus L1098: thesis by L1097 , L1071 , SCMFSA_M:2;
end;
end;
theorem
L1100: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for R3 being (Instruction-Sequence of ( SCM+FSA )) holds (for R11 being (State of ( SCM+FSA )) holds (for R12 being (State of ( SCM+FSA )) holds (for R13 being  read-write Int-Location holds (for R17 being  good (Program of ( SCM+FSA )) holds ((( R11 . ( intloc ( 0 ) ) ) = 1 & ( DataPart R11 ) = ( DataPart R12 ) &  ProperBodyWhile>0 R13 , R17 , R11 , R2 &  WithVariantWhile>0 R13 , R17 , R11 , R2) implies  WithVariantWhile>0 R13 , R17 , R12 , R3)))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let R3 being (Instruction-Sequence of ( SCM+FSA ));
let R11 being (State of ( SCM+FSA ));
let R12 being (State of ( SCM+FSA ));
let R13 being  read-write Int-Location;
let R17 being  good (Program of ( SCM+FSA ));
set D272 = R17;
assume that
L1101: ( R11 . ( intloc ( 0 ) ) ) = 1
and
L1102: ( DataPart R11 ) = ( DataPart R12 )
and
L1103:  ProperBodyWhile>0 R13 , D272 , R11 , R2
and
L1104:  WithVariantWhile>0 R13 , D272 , R11 , R2;
set D273 = ( StepWhile>0 (R13 , D272 , R2 , R11) );
consider C129 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that L1105: C129 is  on_data_only and L1106: (for B132 being (Element of ( NAT )) holds (( C129 . ( D273 . ( B132 + 1 ) ) ) < ( C129 . ( D273 . B132 ) ) or ( ( D273 . B132 ) . R13 ) <= ( 0 ))) by L1101 , L1103 , L1104 , L1066;
take C129;
let C130 being (Element of ( NAT ));
set D274 = ( StepWhile>0 (R13 , D272 , R3 , R12) );
L1107: ( DataPart ( D273 . ( C130 + 1 ) ) ) = ( DataPart ( D274 . ( C130 + 1 ) ) ) by L1102 , L1103 , L853;
L1108: ( C129 . ( D273 . ( C130 + 1 ) ) ) = ( C129 . ( D274 . ( C130 + 1 ) ) ) by L1107 , L1105 , MEMSTR_0:def 18;
L1109: ( DataPart ( D273 . C130 ) ) = ( DataPart ( D274 . C130 ) ) by L1102 , L1103 , L853;
L1110: ( ( D273 . C130 ) . R13 ) = ( ( D274 . C130 ) . R13 ) by L1109 , SCMFSA_M:2;
L1111: ( C129 . ( D273 . C130 ) ) = ( C129 . ( D274 . C130 ) ) by L1105 , L1109 , MEMSTR_0:def 18;
thus L1112: thesis by L1111 , L1106 , L1110 , L1108;
end;
begin
definition
let C131 , C132 being Int-Location;
func Fusc_macro (C131 , C132) -> (Program of ( SCM+FSA )) equals 
( ( ( ( SubFrom (C132 , C132) ) ";" ( ( 1 -stRWNotIn { C131 , C132 } ) := ( intloc ( 0 ) ) ) ) ";" ( ( 2 -ndRWNotIn { C131 , C132 } ) := C131 ) ) ";" ( while>0 (( 2 -ndRWNotIn { C131 , C132 } ) , ( ( ( ( 3 -rdRWNotIn { C131 , C132 } ) := 2 ) ";" ( Divide (( 2 -ndRWNotIn { C131 , C132 } ) , ( 3 -rdRWNotIn { C131 , C132 } )) ) ) ";" ( if=0 (( 3 -rdRWNotIn { C131 , C132 } ) , ( Macro ( AddTo (( 1 -stRWNotIn { C131 , C132 } ) , C132) ) ) , ( Macro ( AddTo (C132 , ( 1 -stRWNotIn { C131 , C132 } )) ) )) ) )) ) );
correctness;
end;
theorem
L1114: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (for B133 , B134 being  read-write Int-Location holds (B133 <> B134 implies (for B135 being (Element of ( NAT )) holds (B135 = ( R10 . B133 ) implies (( ( IExec (( Fusc_macro (B133 , B134) ) , R1 , R10) ) . B134 ) = ( Fusc B135 ) & ( ( IExec (( Fusc_macro (B133 , B134) ) , R1 , R10) ) . B133 ) = B135)))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
let C133 , C134 being  read-write Int-Location;
assume that
L1115: C133 <> C134;
set D275 = ( SubFrom (C134 , C134) );
set D276 = ( 3 -rdRWNotIn { C133 , C134 } );
set D277 = ( 2 -ndRWNotIn { C133 , C134 } );
set D278 = ( 1 -stRWNotIn { C133 , C134 } );
set D279 = ( D276 := 2 );
set D280 = ( Divide (D277 , D276) );
set D281 = ( Macro ( AddTo (D278 , C134) ) );
set D282 = ( Macro ( AddTo (C134 , D278) ) );
set D283 = ( if=0 (D276 , D281 , D282) );
set D284 = ( ( D279 ";" D280 ) ";" D283 );
let C135 being (Element of ( NAT ));
assume that
L1116: C135 = ( R10 . C133 );
L1117: D278 <> D276 by SCMFSA_M:26;
L1118: D277 <> D278 by SCMFSA_M:26;
set D285 = ( while>0 (D277 , D284) );
deffunc H5((Element of ( product ( the_Values_of ( SCM+FSA ) ) ))) = ( abs ( $1 . D277 ) );
set D286 = ( D277 := C133 );
set D287 = ( D278 := ( intloc ( 0 ) ) );
set D288 = ( IExec (( ( D275 ";" D287 ) ";" D286 ) , R1 , R10) );
set D289 = R1;
set D290 = ( Initialized D288 );
set D291 = ( StepWhile>0 (D277 , D284 , D289 , D290) );
set D292 = ( D289 +* ( while>0 (D277 , D284) ) );
defpred S21[ Nat ] means (ex B136 , B137 , B138 being (Element of ( NAT )) st (( ( D291 . $1 ) . D277 ) = B136 & ( ( D291 . $1 ) . D278 ) = B137 & ( ( D291 . $1 ) . C134 ) = B138 & ( ( D291 . $1 ) . C133 ) = C135 & ( Fusc C135 ) = ( ( B137 * ( Fusc B136 ) ) + ( B138 * ( Fusc ( B136 + 1 ) ) ) )));
consider C136 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that L1119: (for B139 being (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) holds ( C136 . B139 ) = H5(B139)) from FUNCT_2:sch 4;
L1120: C133 in { C133 , C134 } by TARSKI:def 2;
L1121: C133 <> D278 by L1120 , SCMFSA_M:25;
L1122: C134 in { C133 , C134 } by TARSKI:def 2;
L1123: D277 <> C134 by L1122 , SCMFSA_M:25;
L1124: C134 <> D276 by L1122 , SCMFSA_M:25;
L1125: D278 <> C134 by L1122 , SCMFSA_M:25;
L1126: C133 <> D276 by L1120 , SCMFSA_M:25;
L1127: C133 <> D277 by L1120 , SCMFSA_M:25;
L1128: D277 <> D276 by SCMFSA_M:26;
L1129: (for B140 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds ((ex B141 , B142 , B143 being (Element of ( NAT )) st (( B140 . D277 ) = B141 & ( B140 . D278 ) = B142 & ( B140 . C134 ) = B143 & ( B140 . C133 ) = C135 & ( Fusc C135 ) = ( ( B142 * ( Fusc B141 ) ) + ( B143 * ( Fusc ( B141 + 1 ) ) ) ))) implies (ex B144 , B145 , B146 being (Element of ( NAT )) st (( ( IExec (D284 , R4 , B140) ) . D277 ) = B144 & ( ( IExec (D284 , R4 , B140) ) . D278 ) = B145 & ( ( IExec (D284 , R4 , B140) ) . C134 ) = B146 & ( ( IExec (D284 , R4 , B140) ) . C133 ) = C135 & ( Fusc C135 ) = ( ( B145 * ( Fusc B144 ) ) + ( B146 * ( Fusc ( B144 + 1 ) ) ) ) & B144 = ( ( B140 . D277 ) div 2 ))))))
proof
let C137 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
given C138 , C139 , C140 being (Element of ( NAT )) such that
L1130: ( C137 . D277 ) = C138
and
L1131: ( C137 . D278 ) = C139
and
L1132: ( C137 . C134 ) = C140
and
L1133: ( C137 . C133 ) = C135
and
L1134: ( Fusc C135 ) = ( ( C139 * ( Fusc C138 ) ) + ( C140 * ( Fusc ( C138 + 1 ) ) ) );

L1135: ( ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) ) . D278 ) = ( ( IExec (( D279 ";" D280 ) , R4 , C137) ) . D278 ) by SCMFSA_M:37
.= ( ( Exec (D280 , ( IExec (D279 , R4 , C137) )) ) . D278 ) by SCMFSA6C:6
.= ( ( IExec (D279 , R4 , C137) ) . D278 ) by L1118 , L1117 , SCMFSA_2:67
.= C139 by L1131 , SCMFSA7B:3 , SCMFSA_M:26;
L1136: ( ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) ) . D277 ) = ( ( IExec (( D279 ";" D280 ) , R4 , C137) ) . D277 ) by SCMFSA_M:37
.= ( ( Exec (D280 , ( IExec (D279 , R4 , C137) )) ) . D277 ) by SCMFSA6C:6
.= ( ( ( IExec (D279 , R4 , C137) ) . D277 ) div ( ( IExec (D279 , R4 , C137) ) . D276 ) ) by L1128 , SCMFSA_2:67
.= ( ( C137 . D277 ) div ( ( IExec (D279 , R4 , C137) ) . D276 ) ) by SCMFSA7B:3 , SCMFSA_M:26
.= ( ( C137 . D277 ) div 2 ) by SCMFSA7B:3;
L1137: ( ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) ) . C134 ) = ( ( IExec (( D279 ";" D280 ) , R4 , C137) ) . C134 ) by SCMFSA_M:37
.= ( ( Exec (D280 , ( IExec (D279 , R4 , C137) )) ) . C134 ) by SCMFSA6C:6
.= ( ( IExec (D279 , R4 , C137) ) . C134 ) by L1123 , L1124 , SCMFSA_2:67
.= C140 by L1124 , L1132 , SCMFSA7B:3;
L1138: ( ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) ) . C133 ) = ( ( IExec (( D279 ";" D280 ) , R4 , C137) ) . C133 ) by SCMFSA_M:37
.= ( ( Exec (D280 , ( IExec (D279 , R4 , C137) )) ) . C133 ) by SCMFSA6C:6
.= ( ( IExec (D279 , R4 , C137) ) . C133 ) by L1126 , L1127 , SCMFSA_2:67
.= C135 by L1126 , L1133 , SCMFSA7B:3;
L1139: ( ( IExec (( D279 ";" D280 ) , R4 , C137) ) . D276 ) = ( ( Exec (D280 , ( IExec (D279 , R4 , C137) )) ) . D276 ) by SCMFSA6C:6
.= ( ( ( IExec (D279 , R4 , C137) ) . D277 ) mod ( ( IExec (D279 , R4 , C137) ) . D276 ) ) by SCMFSA_2:67
.= ( ( C137 . D277 ) mod ( ( IExec (D279 , R4 , C137) ) . D276 ) ) by SCMFSA7B:3 , SCMFSA_M:26
.= ( ( C137 . D277 ) mod 2 ) by SCMFSA7B:3;
per cases ;
suppose L1140: C138 is  even;

reconsider D293 = ( C139 + C140 ) as (Element of ( NAT ));
reconsider D294 = ( ( C137 . D277 ) div 2 ) as (Element of ( NAT )) by L1130 , INT_1:3 , INT_1:55;
take D294;
take D293;
take C140;
consider C141 being (Element of ( NAT )) such that L1141: C138 = ( 2 * C141 ) by L1140 , ABIAN:def 2;
L1142: ( ( C137 . D277 ) mod 2 ) = ( ( ( 2 * C141 ) + ( 0 ) ) mod 2 ) by L1130 , L1141
.= ( ( 0 ) mod 2 ) by NAT_D:21
.= ( 0 ) by NAT_D:26;
L1143: ( ( IExec (D284 , R4 , C137) ) . D277 ) = ( ( IExec (D283 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . D277 ) by SCMFSA6C:1
.= ( ( IExec (D281 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . D277 ) by L1139 , L1142 , SCMFSA8B:18
.= ( ( IExec (D281 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . D277 )
.= ( ( Exec (( AddTo (D278 , C134) ) , ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) )) ) . D277 ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (D278 , C134) ) , ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) )) ) . D277 )
.= ( ( C137 . D277 ) div 2 ) by L1118 , L1136 , SCMFSA_2:64;
thus L1144: ( ( IExec (D284 , R4 , C137) ) . D277 ) = D294 by L1143;
thus L1145: ( ( IExec (D284 , R4 , C137) ) . D278 ) = ( ( IExec (D283 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . D278 ) by SCMFSA6C:1
.= ( ( IExec (D281 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . D278 ) by L1139 , L1142 , SCMFSA8B:18
.= ( ( IExec (D281 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . D278 )
.= ( ( Exec (( AddTo (D278 , C134) ) , ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) )) ) . D278 ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (D278 , C134) ) , ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) )) ) . D278 )
.= D293 by L1135 , L1137 , SCMFSA_2:64;
thus L1146: ( ( IExec (D284 , R4 , C137) ) . C134 ) = ( ( IExec (D283 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . C134 ) by SCMFSA6C:1
.= ( ( IExec (D281 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . C134 ) by L1139 , L1142 , SCMFSA8B:18
.= ( ( IExec (D281 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . C134 )
.= ( ( Exec (( AddTo (D278 , C134) ) , ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) )) ) . C134 ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (D278 , C134) ) , ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) )) ) . C134 )
.= C140 by L1125 , L1137 , SCMFSA_2:64;
thus L1147: ( ( IExec (D284 , R4 , C137) ) . C133 ) = ( ( IExec (D283 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . C133 ) by SCMFSA6C:1
.= ( ( IExec (D281 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . C133 ) by L1139 , L1142 , SCMFSA8B:18
.= ( ( IExec (D281 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . C133 )
.= ( ( Exec (( AddTo (D278 , C134) ) , ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) )) ) . C133 ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (D278 , C134) ) , ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) )) ) . C133 )
.= C135 by L1121 , L1138 , SCMFSA_2:64;
L1148: D294 = C141 by L1130 , L1141 , NAT_D:20;
thus L1149: ( Fusc C135 ) = ( ( D293 * ( Fusc D294 ) ) + ( C140 * ( Fusc ( D294 + 1 ) ) ) ) by L1148 , L1134 , L1141 , PRE_FF:20;
thus L1150: thesis;
end;
suppose L1151: C138 is  odd;

reconsider D295 = ( C139 + C140 ) as (Element of ( NAT ));
reconsider D296 = ( ( C137 . D277 ) div 2 ) as (Element of ( NAT )) by L1130 , INT_1:3 , INT_1:55;
take D296;
take C139;
take D295;
consider C142 being (Element of ( NAT )) such that L1152: C138 = ( ( 2 * C142 ) + 1 ) by L1151 , ABIAN:9;
L1153: ( ( C137 . D277 ) mod 2 ) = ( 1 mod 2 ) by L1130 , L1152 , NAT_D:21
.= 1 by NAT_D:24;
L1154: ( ( IExec (D284 , R4 , C137) ) . D277 ) = ( ( IExec (D283 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . D277 ) by SCMFSA6C:1
.= ( ( IExec (D282 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . D277 ) by L1139 , L1153 , SCMFSA8B:18
.= ( ( IExec (D282 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . D277 )
.= ( ( Exec (( AddTo (C134 , D278) ) , ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) )) ) . D277 ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (C134 , D278) ) , ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) )) ) . D277 )
.= ( ( C137 . D277 ) div 2 ) by L1123 , L1136 , SCMFSA_2:64;
thus L1155: ( ( IExec (D284 , R4 , C137) ) . D277 ) = D296 by L1154;
thus L1156: ( ( IExec (D284 , R4 , C137) ) . D278 ) = ( ( IExec (D283 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . D278 ) by SCMFSA6C:1
.= ( ( IExec (D282 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . D278 ) by L1139 , L1153 , SCMFSA8B:18
.= ( ( IExec (D282 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . D278 )
.= ( ( Exec (( AddTo (C134 , D278) ) , ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) )) ) . D278 ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (C134 , D278) ) , ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) )) ) . D278 )
.= C139 by L1125 , L1135 , SCMFSA_2:64;
thus L1157: ( ( IExec (D284 , R4 , C137) ) . C134 ) = ( ( IExec (D283 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . C134 ) by SCMFSA6C:1
.= ( ( IExec (D282 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . C134 ) by L1139 , L1153 , SCMFSA8B:18
.= ( ( IExec (D282 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . C134 )
.= ( ( Exec (( AddTo (C134 , D278) ) , ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) )) ) . C134 ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (C134 , D278) ) , ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) )) ) . C134 )
.= D295 by L1135 , L1137 , SCMFSA_2:64;
thus L1158: ( ( IExec (D284 , R4 , C137) ) . C133 ) = ( ( IExec (D283 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . C133 ) by SCMFSA6C:1
.= ( ( IExec (D282 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . C133 ) by L1139 , L1153 , SCMFSA8B:18
.= ( ( IExec (D282 , R4 , ( IExec (( D279 ";" D280 ) , R4 , C137) )) ) . C133 )
.= ( ( Exec (( AddTo (C134 , D278) ) , ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) )) ) . C133 ) by SCMFSA6C:5
.= ( ( Exec (( AddTo (C134 , D278) ) , ( Initialized ( IExec (( D279 ";" D280 ) , R4 , C137) ) )) ) . C133 )
.= C135 by L1115 , L1138 , SCMFSA_2:64;
L1159: D296 = ( ( 2 * C142 ) div 2 ) by L1130 , L1152 , NAT_2:26
.= C142 by NAT_D:20;
thus L1160: ( Fusc C135 ) = ( ( C139 * ( Fusc D296 ) ) + ( D295 * ( Fusc ( D296 + 1 ) ) ) ) by L1159 , L1134 , L1152 , PRE_FF:19;
thus L1161: thesis;
end;
end;
L1163: ( D290 . ( intloc ( 0 ) ) ) = 1 by SCMFSA_M:9;
L1164: (for B147 being (Element of ( NAT )) holds (S21[ B147 ] implies S21[ ( B147 + 1 ) ]))
proof
let C143 being (Element of ( NAT ));
given C144 , C145 , C146 being (Element of ( NAT )) such that
L1165: ( ( D291 . C143 ) . D277 ) = C144
and
L1166: ( ( D291 . C143 ) . D278 ) = C145
and
L1167: ( ( D291 . C143 ) . C134 ) = C146
and
L1168: ( ( D291 . C143 ) . C133 ) = C135
and
L1169: ( Fusc C135 ) = ( ( C145 * ( Fusc C144 ) ) + ( C146 * ( Fusc ( C144 + 1 ) ) ) );

L1170: ( ( D291 . C143 ) . ( intloc ( 0 ) ) ) = 1 by L1163 , L828;
per cases ;
suppose L1171: ( ( D291 . C143 ) . D277 ) > ( 0 );

consider C147 , C148 , C149 being (Element of ( NAT )) such that L1172: ( ( IExec (D284 , D292 , ( D291 . C143 )) ) . D277 ) = C147 and L1173: ( ( IExec (D284 , D292 , ( D291 . C143 )) ) . D278 ) = C148 and L1174: ( ( IExec (D284 , D292 , ( D291 . C143 )) ) . C134 ) = C149 and L1175: ( ( IExec (D284 , D292 , ( D291 . C143 )) ) . C133 ) = C135 and L1176: ( Fusc C135 ) = ( ( C148 * ( Fusc C147 ) ) + ( C149 * ( Fusc ( C147 + 1 ) ) ) ) and L1177: C147 = ( ( ( D291 . C143 ) . D277 ) div 2 ) by L1129 , L1165 , L1166 , L1167 , L1168 , L1169;
take C147;
take C148;
take C149;
L1178: ( DataPart ( D291 . ( C143 + 1 ) ) ) = ( DataPart ( IExec (D284 , D292 , ( D291 . C143 )) ) ) by L1170 , L1171 , L813;
thus L1179: ( ( D291 . ( C143 + 1 ) ) . D277 ) = C147 by L1178 , L1172 , SCMFSA_M:2;
thus L1180: ( ( D291 . ( C143 + 1 ) ) . D278 ) = C148 by L1178 , L1173 , SCMFSA_M:2;
thus L1181: ( ( D291 . ( C143 + 1 ) ) . C134 ) = C149 by L1178 , L1174 , SCMFSA_M:2;
thus L1182: ( ( D291 . ( C143 + 1 ) ) . C133 ) = C135 by L1178 , L1175 , SCMFSA_M:2;
thus L1183: thesis by L1176;
end;
suppose L1184: ( ( D291 . C143 ) . D277 ) <= ( 0 );

take C144;
take C145;
take C146;
L1185: ( DataPart ( D291 . ( C143 + 1 ) ) ) = ( DataPart ( D291 . C143 ) ) by L1184 , L807;
thus L1186: ( ( D291 . ( C143 + 1 ) ) . D277 ) = C144 by L1185 , L1165 , SCMFSA_M:2;
thus L1187: ( ( D291 . ( C143 + 1 ) ) . D278 ) = C145 by L1166 , L1185 , SCMFSA_M:2;
thus L1188: ( ( D291 . ( C143 + 1 ) ) . C134 ) = C146 by L1167 , L1185 , SCMFSA_M:2;
thus L1189: ( ( D291 . ( C143 + 1 ) ) . C133 ) = C135 by L1168 , L1185 , SCMFSA_M:2;
thus L1190: thesis by L1169;
end;
end;
L1192: ( D288 . ( intloc ( 0 ) ) ) = 1 by SCMFSA6B:11;
L1193: ( DataPart D288 ) = ( DataPart D290 ) by L1192 , SCMFSA_M:19;
L1194: S21[ ( 0 ) ]
proof
take D297 = C135;
take D298 = 1;
take D299 = ( 0 );
L1195: ( D291 . ( 0 ) ) = D290 by SCMFSA_9:def 5;
thus L1196: ( ( D291 . ( 0 ) ) . D277 ) = ( D288 . D277 ) by L1195 , L1193 , SCMFSA_M:2
.= ( ( Exec (D286 , ( IExec (( D275 ";" D287 ) , R1 , R10) )) ) . D277 ) by SCMFSA6C:6
.= ( ( IExec (( D275 ";" D287 ) , R1 , R10) ) . C133 ) by SCMFSA_2:63
.= ( ( Exec (D287 , ( Exec (D275 , ( Initialized R10 )) )) ) . C133 ) by SCMFSA6C:8
.= ( ( Exec (D275 , ( Initialized R10 )) ) . C133 ) by L1121 , SCMFSA_2:63
.= ( ( Initialized R10 ) . C133 ) by L1115 , SCMFSA_2:65
.= D297 by L1116 , SCMFSA_M:37;
thus L1197: ( ( D291 . ( 0 ) ) . D278 ) = ( D288 . D278 ) by L1193 , L1195 , SCMFSA_M:2
.= ( ( Exec (D286 , ( IExec (( D275 ";" D287 ) , R1 , R10) )) ) . D278 ) by SCMFSA6C:6
.= ( ( IExec (( D275 ";" D287 ) , R1 , R10) ) . D278 ) by L1118 , SCMFSA_2:63
.= ( ( Exec (D287 , ( Exec (D275 , ( Initialized R10 )) )) ) . D278 ) by SCMFSA6C:8
.= ( ( Exec (D275 , ( Initialized R10 )) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= ( ( Initialized R10 ) . ( intloc ( 0 ) ) ) by SCMFSA_2:65
.= D298 by SCMFSA_M:9;
thus L1198: ( ( D291 . ( 0 ) ) . C134 ) = ( D288 . C134 ) by L1193 , L1195 , SCMFSA_M:2
.= ( ( Exec (D286 , ( IExec (( D275 ";" D287 ) , R1 , R10) )) ) . C134 ) by SCMFSA6C:6
.= ( ( IExec (( D275 ";" D287 ) , R1 , R10) ) . C134 ) by L1123 , SCMFSA_2:63
.= ( ( Exec (D287 , ( Exec (D275 , ( Initialized R10 )) )) ) . C134 ) by SCMFSA6C:8
.= ( ( Exec (D275 , ( Initialized R10 )) ) . C134 ) by L1125 , SCMFSA_2:63
.= ( ( ( Initialized R10 ) . C134 ) - ( ( Initialized R10 ) . C134 ) ) by SCMFSA_2:65
.= D299;
thus L1199: ( ( D291 . ( 0 ) ) . C133 ) = ( D288 . C133 ) by L1193 , L1195 , SCMFSA_M:2
.= ( ( Exec (D286 , ( IExec (( D275 ";" D287 ) , R1 , R10) )) ) . C133 ) by SCMFSA6C:6
.= ( ( IExec (( D275 ";" D287 ) , R1 , R10) ) . C133 ) by L1127 , SCMFSA_2:63
.= ( ( Exec (D287 , ( Exec (D275 , ( Initialized R10 )) )) ) . C133 ) by SCMFSA6C:8
.= ( ( Exec (D275 , ( Initialized R10 )) ) . C133 ) by L1121 , SCMFSA_2:63
.= ( ( Initialized R10 ) . C133 ) by L1115 , SCMFSA_2:65
.= C135 by L1116 , SCMFSA_M:37;
thus L1200: thesis;
end;
L1201: (for B148 being (Element of ( NAT )) holds S21[ B148 ]) from NAT_1:sch 1(L1194 , L1164);
L1202: (for B149 being (Element of ( NAT )) holds (( C136 . ( D291 . ( B149 + 1 ) ) ) < ( C136 . ( D291 . B149 ) ) or ( ( D291 . B149 ) . D277 ) <= ( 0 )))
proof
let C150 being (Element of ( NAT ));
consider C151 , C152 , C153 being (Element of ( NAT )) such that L1203: ( ( D291 . C150 ) . D277 ) = C151 and L1204: (( ( D291 . C150 ) . D278 ) = C152 & ( ( D291 . C150 ) . C134 ) = C153 & ( ( D291 . C150 ) . C133 ) = C135 & ( Fusc C135 ) = ( ( C152 * ( Fusc C151 ) ) + ( C153 * ( Fusc ( C151 + 1 ) ) ) )) by L1201;
L1205: ( C136 . ( D291 . C150 ) ) = ( abs ( ( D291 . C150 ) . D277 ) ) by L1119
.= C151 by L1203 , ABSVALUE:def 1;
L1206:
now
consider C154 , C155 , C156 being (Element of ( NAT )) such that L1207: ( ( IExec (D284 , D292 , ( D291 . C150 )) ) . D277 ) = C154 and L1208: ( ( IExec (D284 , D292 , ( D291 . C150 )) ) . D278 ) = C155 and L1209: ( ( IExec (D284 , D292 , ( D291 . C150 )) ) . C134 ) = C156 and L1210: ( ( IExec (D284 , D292 , ( D291 . C150 )) ) . C133 ) = C135 and L1211: ( Fusc C135 ) = ( ( C155 * ( Fusc C154 ) ) + ( C156 * ( Fusc ( C154 + 1 ) ) ) ) and L1212: C154 = ( ( ( D291 . C150 ) . D277 ) div 2 ) by L1129 , L1203 , L1204;
assume L1213: C151 > ( 0 );
L1214: ( ( D291 . C150 ) . ( intloc ( 0 ) ) ) = 1 by L1163 , L828;
L1215: ( DataPart ( D291 . ( C150 + 1 ) ) ) = ( DataPart ( IExec (D284 , D292 , ( D291 . C150 )) ) ) by L1214 , L1203 , L1213 , L813;
L1216: ( ( D291 . ( C150 + 1 ) ) . D277 ) = C154 by L1215 , L1207 , SCMFSA_M:2;
L1217: ( C136 . ( D291 . ( C150 + 1 ) ) ) = ( abs ( ( D291 . ( C150 + 1 ) ) . D277 ) ) by L1119
.= C154 by L1216 , ABSVALUE:def 1;
thus L1218: ( C136 . ( D291 . ( C150 + 1 ) ) ) < ( C136 . ( D291 . C150 ) ) by L1217 , L1203 , L1205 , L1213 , L1212 , INT_1:56;
end;
thus L1219: thesis by L1206 , L1203;
end;
L1220:  WithVariantWhile>0 D277 , D284 , D290 , D289 by L1202 , L583;
consider C157 being (Element of ( NAT )) such that L1221: ( ExitsAtWhile>0 (D277 , D284 , D289 , D290) ) = C157 and L1222: ( ( ( StepWhile>0 (D277 , D284 , D289 , D290) ) . C157 ) . D277 ) <= ( 0 ) and L1223: (for B150 being (Element of ( NAT )) holds (( ( D291 . B150 ) . D277 ) <= ( 0 ) implies C157 <= B150)) and L1224: ( DataPart ( Comput (( D289 +* ( while>0 (D277 , D284) ) ) , ( Initialize D290 ) , ( LifeSpan (( D289 +* ( while>0 (D277 , D284) ) ) , ( Initialize D290 )) )) ) ) = ( DataPart ( ( StepWhile>0 (D277 , D284 , D289 , D290) ) . C157 ) ) by L1220 , L881;
L1225: ( DataPart ( IExec (D285 , D289 , D288) ) ) = ( DataPart ( D291 . C157 ) ) by L1220 , L1221 , L955;
consider C158 , C159 , C160 being (Element of ( NAT )) such that L1226: ( ( D291 . C157 ) . D277 ) = C158 and L1227: ( ( D291 . C157 ) . D278 ) = C159 and L1228: ( ( D291 . C157 ) . C134 ) = C160 and L1229: ( ( D291 . C157 ) . C133 ) = C135 and L1230: ( Fusc C135 ) = ( ( C159 * ( Fusc C158 ) ) + ( C160 * ( Fusc ( C158 + 1 ) ) ) ) by L1201;
L1231: C158 = ( 0 ) by L1222 , L1226;
L1232: (D285 is_closed_on D290 , D289 & D285 is_halting_on D290 , D289) by L1220 , L684;
L1233: (D285 is_closed_on D288 , D289 & D285 is_halting_on D288 , D289) by L1232 , L1193 , SCMFSA8B:5;
thus L1234: ( ( IExec (( Fusc_macro (C133 , C134) ) , R1 , R10) ) . C134 ) = ( ( IExec (D285 , D289 , D288) ) . C134 ) by L1233 , SFMASTR1:7
.= ( Fusc C135 ) by L1228 , L1230 , L1231 , L1225 , PRE_FF:15 , SCMFSA_M:2;
thus L1235: ( ( IExec (( Fusc_macro (C133 , C134) ) , R1 , R10) ) . C133 ) = ( ( IExec (D285 , D289 , D288) ) . C133 ) by L1233 , SFMASTR1:7
.= C135 by L1229 , L1225 , SCMFSA_M:2;
end;
