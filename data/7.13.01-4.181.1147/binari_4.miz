:: A Representation of Integers by Binary Arithmetics
:: and Addition of Integers
::  by Hisayoshi Kunimune and Yatsuka Nakamura
::
:: Received January 30, 2003
:: Copyright (c) 2003-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, XBOOLE_0, NAT_1, INT_1, XXREAL_0, CARD_1, RELAT_1,
      ARYTM_3, POWER, EUCLID, FINSEQ_1, BINOP_2, ZFMISC_1, TARSKI, FUNCT_1,
      FINSEQ_2, MARGREL1, BINARITH, ARYTM_1, SUBSET_1, PARTFUN1, XBOOLEAN,
      BINARI_2, BINARI_3, FUNCOP_1, ORDINAL4, COMPLEX1, NEWTON, BINARI_4;
 notations INT_1, SUBSET_1, XBOOLEAN, MARGREL1, FUNCOP_1, POWER, BINARITH,
      BINARI_2, BINARI_3, SERIES_1, NUMBERS, XXREAL_0, XBOOLE_0, ORDINAL1,
      NAT_D, BINOP_2, EUCLID, TARSKI, PARTFUN1, FUNCT_1, RELAT_1, ZFMISC_1,
      INT_2, FINSEQOP, NEWTON, FINSEQ_1, FINSEQ_2;
 constructors REAL_1, NAT_D, FINSEQOP, NEWTON, SERIES_1, BINARITH, BINARI_2,
      EUCLID, BINARI_3, RVSUM_1, RELSET_1;
 registrations XBOOLE_0, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, MEMBERED,
      XBOOLEAN, MARGREL1, VALUED_0, FINSEQ_1, FINSEQ_2, RELAT_1, FUNCT_1,
      CARD_1;
 requirements REAL, BOOLE, SUBSET, NUMERALS, ARITHM;
 definitions FINSEQ_2, XBOOLEAN, EUCLID;
 theorems POWER, NAT_1, PRE_FF, ABSVALUE, BINARI_3, INT_1, BINARITH, NAT_2,
      BINARI_2, FINSEQ_1, FINSEQ_2, FINSEQ_4, FUNCOP_1, RVSUM_1, FUNCT_2,
      ZFMISC_1, EULER_2, PEPIN, PREPOWER, XREAL_1, XXREAL_0, XBOOLEAN, NAT_D,
      VALUED_1, XREAL_0, CARD_1;
 schemes NAT_1;

begin
theorem
L1: (for B1 being Nat holds (B1 > ( 0 ) implies ( B1 * 2 ) >= ( B1 + 1 )))
proof
let C1 being Nat;
assume L2: C1 > ( 0 );
L3: C1 >= ( ( 0 ) + 1 ) by L2 , INT_1:7;
L4: ( C1 * 2 ) = ( C1 + C1 );
thus L5: thesis by L4 , L3 , XREAL_1:6;
end;
theorem
L6: (for B2 being Nat holds ( 2 to_power B2 ) >= B2)
proof
defpred S1[ Nat ] means ( 2 to_power $1 ) >= $1;
L7: (for B3 being Nat holds (S1[ B3 ] implies S1[ ( B3 + 1 ) ]))
proof
let C2 being Nat;
assume that
L8: ( 2 to_power C2 ) >= C2;
per cases ;
suppose L9: C2 = ( 0 );

L10: ( 2 to_power ( C2 + 1 ) ) = 2 by L9 , POWER:25;
thus L11: thesis by L10 , L9;
end;
suppose L12: C2 > ( 0 );

reconsider D1 = ( 2 to_power C2 ) as Nat;
L13: (( D1 * 2 ) >= ( C2 * 2 ) & ( 2 to_power 1 ) = 2) by L8 , NAT_1:4 , POWER:25;
L14: ( 2 to_power ( C2 + 1 ) ) >= ( C2 * 2 ) by L13 , POWER:27;
L15: ( C2 * 2 ) >= ( C2 + 1 ) by L12 , L1;
thus L16: thesis by L15 , L14 , XXREAL_0:2;
end;
end;
L18: S1[ ( 0 ) ];
thus L19: (for B4 being Nat holds S1[ B4 ]) from NAT_1:sch 2(L18 , L7);
end;
theorem
L20: (for B5 being Nat holds ( ( 0* B5 ) + ( 0* B5 ) ) = ( 0* B5 ))
proof
let C3 being Nat;
L21: ( dom ( 0* C3 ) ) = ( Seg C3 ) by FUNCOP_1:13;
L22: (( dom ( addreal ) ) = [: ( REAL ) , ( REAL ) :] & ( rng ( 0* C3 ) ) c= ( REAL )) by FINSEQ_1:def 4 , FUNCT_2:def 1;
L23: [: ( rng ( 0* C3 ) ) , ( rng ( 0* C3 ) ) :] c= ( dom ( addreal ) ) by L22 , ZFMISC_1:96;
L24: ( dom ( ( 0* C3 ) + ( 0* C3 ) ) ) = ( dom ( ( addreal ) .: (( 0* C3 ) , ( 0* C3 )) ) ) by RVSUM_1:def 4
.= ( ( dom ( 0* C3 ) ) /\ ( dom ( 0* C3 ) ) ) by L23 , FUNCOP_1:69
.= ( Seg C3 ) by FUNCOP_1:13;
L25: (for B6 being Nat holds (B6 in ( dom ( 0* C3 ) ) implies ( ( 0* C3 ) . B6 ) = ( ( ( 0* C3 ) + ( 0* C3 ) ) . B6 )))
proof
let C4 being Nat;
assume that
L26: C4 in ( dom ( 0* C3 ) );
L27: ( ( 0* C3 ) . C4 ) = ( 0 );
L28: ( ( ( 0* C3 ) + ( 0* C3 ) ) . C4 ) = ( ( 0 ) + ( 0 ) ) by L27 , L24 , L21 , L26 , VALUED_1:def 1;
thus L29: thesis by L28;
end;
thus L30: thesis by L25 , L24 , FINSEQ_1:13 , FUNCOP_1:13;
end;
theorem
L31: (for B7 , B8 , B9 being Nat holds ((B7 <= B9 & B9 <= B8) implies (B7 = B9 or (( B7 + 1 ) <= B9 & B9 <= B8))))
proof
defpred S2[ Nat ] means (for B10 , B11 being Nat holds (($1 <= B11 & B11 <= B10) implies ($1 = B11 or (( $1 + 1 ) <= B11 & B11 <= B10))));
L32: (for B12 being Nat holds (S2[ B12 ] implies S2[ ( B12 + 1 ) ]))
proof
let C5 being Nat;
assume that
L33: S2[ C5 ];
let C6 , C7 being Nat;
assume that
L34: ( C5 + 1 ) <= C7
and
L35: C7 <= C6;
L36: (( C5 + 1 ) = C7 or ( C5 + 1 ) < C7) by L34 , XXREAL_0:1;
thus L37: thesis by L36 , L35 , NAT_1:13;
end;
L38: S2[ ( 0 ) ] by NAT_1:13;
thus L39: (for B13 being Nat holds S2[ B13 ]) from NAT_1:sch 2(L38 , L32);
end;
theorem
L40: (for B14 being non  empty Nat holds (for B15 , B16 being (Tuple of B14 , ( BOOLEAN )) holds ((B15 = ( 0* B14 ) & B16 = ( 0* B14 )) implies ( carry (B15 , B16) ) = ( 0* B14 ))))
proof
let C8 being non  empty Nat;
let C9 , C10 being (Tuple of C8 , ( BOOLEAN ));
assume that
L41: C9 = ( 0* C8 )
and
L42: C10 = ( 0* C8 );
L43: (for B17 being Nat holds ((1 < B17 & B17 <= C8) implies ( ( carry (C9 , C10) ) . B17 ) = ( 0 )))
proof
let C11 being Nat;
assume that
L44: 1 < C11
and
L45: C11 <= C8;
reconsider D2 = ( C11 - 1 ) as (Element of ( NAT )) by L44 , INT_1:5;
L46: ( D2 + 1 ) = C11;
L47: (1 <= D2 & D2 < C8) by L46 , L44 , L45 , NAT_1:13;
L48: ( len ( 0* C8 ) ) = C8 by CARD_1:def 7;
L49: ( C9 /. D2 ) = ( ( 0* C8 ) . D2 ) by L48 , L41 , L47 , FINSEQ_4:15
.= ( FALSE );
L50: C11 = ( D2 + 1 );
L51: ( len ( carry (C9 , C10) ) ) = C8 by CARD_1:def 7;
L52: ( ( carry (C9 , C10) ) . C11 ) = ( ( carry (C9 , C10) ) /. C11 ) by L51 , L44 , L45 , FINSEQ_4:15
.= ( ( ( ( FALSE ) '&' ( FALSE ) ) 'or' ( ( FALSE ) '&' ( ( carry (C9 , C10) ) /. D2 ) ) ) 'or' ( ( FALSE ) '&' ( ( carry (C9 , C10) ) /. D2 ) ) ) by L41 , L42 , L47 , L50 , L49 , BINARITH:def 2
.= ( FALSE );
thus L53: thesis by L52;
end;
L54: ( len ( carry (C9 , C10) ) ) = C8 by CARD_1:def 7;
L55: 1 <= ( len ( carry (C9 , C10) ) ) by L54 , NAT_1:14;
L56: ( ( carry (C9 , C10) ) . 1 ) = ( ( carry (C9 , C10) ) /. 1 ) by L55 , FINSEQ_4:15
.= ( 0 ) by BINARITH:def 2;
L57: (for B18 being Nat holds (B18 in ( Seg C8 ) implies ( ( carry (C9 , C10) ) . B18 ) = ( ( 0* C8 ) . B18 )))
proof
let C12 being Nat;
assume that
L58: C12 in ( Seg C8 );
L59: 1 <= C12 by L58 , FINSEQ_1:1;
L60: ( ( 0* C8 ) . C12 ) = ( 0 );
per cases  by L58 , L59 , L31 , FINSEQ_1:1;
suppose L61: C12 = 1;

thus L62: thesis by L61 , L56;
end;
suppose L63: (( 1 + 1 ) <= C12 & C12 <= C8);

L64: 1 < C12 by L63 , NAT_1:13;
thus L65: thesis by L64 , L43 , L60 , L63;
end;
end;
thus L67: thesis by L57 , L41 , FINSEQ_2:119;
end;
theorem
L68: (for B19 being non  empty Nat holds (for B20 , B21 being (Tuple of B19 , ( BOOLEAN )) holds ((B20 = ( 0* B19 ) & B21 = ( 0* B19 )) implies ( B20 + B21 ) = ( 0* B19 ))))
proof
let C13 being non  empty Nat;
let C14 , C15 being (Tuple of C13 , ( BOOLEAN ));
assume that
L69: C14 = ( 0* C13 )
and
L70: C15 = ( 0* C13 );
L71: (for B22 being Nat holds (B22 in ( Seg C13 ) implies ( ( C14 + C15 ) . B22 ) = ( ( 0* C13 ) . B22 )))
proof
let C16 being Nat;
assume that
L72: C16 in ( Seg C13 );
reconsider D3 = C16 as Nat;
L73: ( ( 0* C13 ) . D3 ) = ( FALSE );
L74: 1 <= D3 by L72 , FINSEQ_1:1;
L75: ( len C14 ) = C13 by CARD_1:def 7;
L76: D3 <= ( len C14 ) by L75 , L72 , FINSEQ_1:1;
L77: ( C15 /. D3 ) = ( FALSE ) by L76 , L69 , L70 , L73 , L74 , FINSEQ_4:15;
L78: ( len ( carry (C14 , C15) ) ) = C13 by CARD_1:def 7;
L79: D3 <= ( len ( carry (C14 , C15) ) ) by L78 , L72 , FINSEQ_1:1;
L80: ( ( carry (C14 , C15) ) /. D3 ) = ( ( carry (C14 , C15) ) . D3 ) by L79 , L74 , FINSEQ_4:15
.= ( FALSE ) by L69 , L70 , L73 , L40;
L81: ( len ( C14 + C15 ) ) = C13 by CARD_1:def 7;
L82: D3 <= ( len ( C14 + C15 ) ) by L81 , L72 , FINSEQ_1:1;
L83: ( ( C14 + C15 ) . D3 ) = ( ( C14 + C15 ) /. D3 ) by L82 , L74 , FINSEQ_4:15
.= ( ( FALSE ) 'xor' ( FALSE ) ) by L69 , L70 , L72 , L77 , L80 , BINARITH:def 5
.= ( FALSE );
thus L84: thesis by L83;
end;
thus L85: thesis by L71 , L69 , FINSEQ_2:119;
end;
theorem
L86: (for B23 being non  empty Nat holds (for B24 being (Tuple of B23 , ( BOOLEAN )) holds (B24 = ( 0* B23 ) implies ( Intval B24 ) = ( 0 ))))
proof
let C17 being non  empty Nat;
let C18 being (Tuple of C17 , ( BOOLEAN ));
assume that
L87: C18 = ( 0* C17 );
L88: 1 <= C17 by NAT_1:14;
L89: C17 <= ( len C18 ) by CARD_1:def 7;
L90: ( C18 /. C17 ) = ( C18 . C17 ) by L89 , L88 , FINSEQ_4:15
.= ( FALSE ) by L87;
L91: ( Intval C18 ) = ( Absval C18 ) by L90 , BINARI_2:def 3;
thus L92: thesis by L91 , L87 , BINARI_3:6;
end;
theorem
L93: (for R3 being Nat holds (for R4 being Nat holds (for R5 being Nat holds (( R4 + R5 ) <= ( R3 - 1 ) implies (R4 < R3 & R5 < R3)))))
proof
let R3 being Nat;
let R4 being Nat;
let R5 being Nat;
assume L94: ( R4 + R5 ) <= ( R3 - 1 );
L95: ( ( R4 + R5 ) - R5 ) <= ( ( R3 - 1 ) - R5 ) by L94 , XREAL_1:9;
L96: R3 <= ( R3 + R5 ) by NAT_1:11;
L97: ( R3 - R5 ) <= ( ( R3 + R5 ) - R5 ) by L96 , XREAL_1:9;
L98: ( ( R3 - 1 ) - R5 ) = ( ( R3 - R5 ) - 1 );
L99: ( ( R3 - 1 ) - R5 ) < R3 by L98 , L97 , XREAL_1:146 , XXREAL_0:2;
thus L100: R4 < R3 by L99 , L95 , XXREAL_0:2;
L101: R3 <= ( R3 + R4 ) by NAT_1:11;
L102: ( R3 - R4 ) <= ( ( R3 + R4 ) - R4 ) by L101 , XREAL_1:9;
L103: ( ( R5 + R4 ) - R4 ) <= ( ( R3 - 1 ) - R4 ) by L94 , XREAL_1:9;
L104: ( ( R3 - 1 ) - R4 ) = ( ( R3 - R4 ) - 1 );
L105: ( ( R3 - 1 ) - R4 ) < R3 by L104 , L102 , XREAL_1:146 , XXREAL_0:2;
thus L106: thesis by L105 , L103 , XXREAL_0:2;
end;
theorem
L107: (for R6 being Integer holds (for R7 being Integer holds (for R8 being Integer holds ((R6 <= ( R7 + R8 ) & R7 < ( 0 ) & R8 < ( 0 )) implies (R6 < R7 & R6 < R8)))))
proof
let R6 being Integer;
let R7 being Integer;
let R8 being Integer;
assume that
L108: R6 <= ( R7 + R8 )
and
L109: R7 < ( 0 )
and
L110: R8 < ( 0 );
L111: ( R6 - R8 ) <= ( ( R7 + R8 ) - R8 ) by L108 , XREAL_1:9;
L112: ( R8 + ( R6 + ( - R8 ) ) ) < ( ( 0 ) + R7 ) by L111 , L110 , XREAL_1:8;
thus L113: R6 < R7 by L112;
L114: ( R6 - R7 ) <= ( ( R8 + R7 ) - R7 ) by L108 , XREAL_1:9;
L115: ( R7 + ( R6 + ( - R7 ) ) ) < ( ( 0 ) + R8 ) by L114 , L109 , XREAL_1:8;
thus L116: thesis by L115;
end;
theorem
L117: (for R1 being non  empty Nat holds (for R4 being Nat holds (for R5 being Nat holds (( R4 + R5 ) <= ( ( 2 to_power R1 ) - 1 ) implies ( add_ovfl (( R1 -BinarySequence R4 ) , ( R1 -BinarySequence R5 )) ) = ( FALSE )))))
proof
let R1 being non  empty Nat;
let R4 being Nat;
let R5 being Nat;
set D4 = ( R1 -BinarySequence R4 );
set D5 = ( R1 -BinarySequence R5 );
L118: ( ( Absval ( D4 + D5 ) ) + ( 2 to_power R1 ) ) >= ( 2 to_power R1 ) by NAT_1:11;
assume L119: ( R4 + R5 ) <= ( ( 2 to_power R1 ) - 1 );
L120: R4 < ( 2 to_power R1 ) by L119 , L93;
assume L121: ( add_ovfl (D4 , D5) ) <> ( FALSE );
L122: ( IFEQ (( add_ovfl (D4 , D5) ) , ( FALSE ) , ( 0 ) , ( 2 to_power R1 )) ) = ( 2 to_power R1 ) by L121 , FUNCOP_1:def 8;
L123: R5 < ( 2 to_power R1 ) by L119 , L93;
L124: ( ( Absval ( D4 + D5 ) ) + ( IFEQ (( add_ovfl (D4 , D5) ) , ( FALSE ) , ( 0 ) , ( 2 to_power R1 )) ) ) = ( ( Absval D4 ) + ( Absval D5 ) ) by BINARITH:21
.= ( R4 + ( Absval D5 ) ) by L120 , BINARI_3:35
.= ( R4 + R5 ) by L123 , BINARI_3:35;
thus L125: contradiction by L124 , L119 , L122 , L118 , XREAL_1:146 , XXREAL_0:2;
end;
theorem
L126: (for B25 being non  empty Nat holds (for B26 , B27 being Nat holds (( B26 + B27 ) <= ( ( 2 to_power B25 ) - 1 ) implies ( Absval ( ( B25 -BinarySequence B26 ) + ( B25 -BinarySequence B27 ) ) ) = ( B26 + B27 ))))
proof
let C19 being non  empty Nat;
let C20 , C21 being Nat;
assume that
L127: ( C20 + C21 ) <= ( ( 2 to_power C19 ) - 1 );
L128: C20 < ( 2 to_power C19 ) by L127 , L93;
set D6 = ( C19 -BinarySequence C20 );
set D7 = ( C19 -BinarySequence C21 );
L129: ( add_ovfl (D6 , D7) ) = ( FALSE ) by L127 , L117;
L130: D6 , D7 are_summable  by L129 , BINARITH:def 7;
L131: ( Absval ( D6 + D7 ) ) = ( ( Absval D6 ) + ( Absval D7 ) ) by L130 , BINARITH:22
.= ( C20 + ( Absval D7 ) ) by L128 , BINARI_3:35;
L132: C21 < ( 2 to_power C19 ) by L127 , L93;
thus L133: thesis by L132 , L131 , BINARI_3:35;
end;
theorem
L134: (for B28 being non  empty Nat holds (for B29 being (Tuple of B28 , ( BOOLEAN )) holds (( B29 /. B28 ) = ( TRUE ) implies ( Absval B29 ) >= ( 2 to_power ( B28 -' 1 ) ))))
proof
defpred S3[ Nat ] means (for B30 being (Tuple of $1 , ( BOOLEAN )) holds (( B30 /. $1 ) = ( TRUE ) implies ( Absval B30 ) >= ( 2 to_power ( $1 -' 1 ) )));
L135: (for B31 being non  empty Nat holds (S3[ B31 ] implies S3[ ( B31 + 1 ) ]))
proof
let C22 being non  empty Nat;
assume that
L136: S3[ C22 ];
let C23 being (Tuple of ( C22 + 1 ) , ( BOOLEAN ));
assume that
L137: ( C23 /. ( C22 + 1 ) ) = ( TRUE );
consider C24 being (Element of ( C22 -tuples_on ( BOOLEAN ) )), C25 being (Element of ( BOOLEAN )) such that L138: C23 = ( C24 ^ <* C25 *> ) by FINSEQ_2:117;
L139: ( C22 + 1 ) >= 1 by NAT_1:11;
L140: ( ( C22 + 1 ) - 1 ) >= ( 1 - 1 ) by L139 , XREAL_1:9;
L141: ( ( C22 + 1 ) -' 1 ) = C22 by L140 , XREAL_0:def 2;
L142: ( len C23 ) = ( C22 + 1 ) by CARD_1:def 7;
L143: ( C23 /. ( C22 + 1 ) ) = ( ( C24 ^ <* C25 *> ) . ( C22 + 1 ) ) by L142 , L138 , L139 , FINSEQ_4:15
.= C25 by FINSEQ_2:116;
L144: ( Absval C23 ) = ( ( Absval C24 ) + ( IFEQ (C25 , ( FALSE ) , ( 0 ) , ( 2 to_power C22 )) ) ) by L138 , BINARITH:20
.= ( ( Absval C24 ) + ( 2 to_power C22 ) ) by L137 , L143 , FUNCOP_1:def 8;
thus L145: thesis by L144 , L141 , NAT_1:11;
end;
L146: S3[ 1 ]
proof
let C26 being (Tuple of 1 , ( BOOLEAN ));
assume that
L147: ( C26 /. 1 ) = ( TRUE );
L148: ( len C26 ) = 1 by CARD_1:def 7;
L149: ( C26 . 1 ) = ( C26 /. 1 ) by L148 , FINSEQ_4:15;
L150: C26 = <* ( TRUE ) *> by L149 , L147 , L148 , FINSEQ_1:40;
L151: ( Absval C26 ) = 1 by L150 , BINARITH:16;
L152: ( 2 to_power ( 1 -' 1 ) ) = ( 2 to_power ( 1 - 1 ) ) by XREAL_0:def 2;
thus L153: thesis by L152 , L151 , POWER:24;
end;
thus L154: (for B32 being non  empty Nat holds S3[ B32 ]) from NAT_1:sch 10(L146 , L135);
end;
theorem
L155: (for R1 being non  empty Nat holds (for R4 being Nat holds (for R5 being Nat holds (( R4 + R5 ) <= ( ( 2 to_power ( R1 -' 1 ) ) - 1 ) implies ( ( carry (( R1 -BinarySequence R4 ) , ( R1 -BinarySequence R5 )) ) /. R1 ) = ( FALSE )))))
proof
let R1 being non  empty Nat;
let R4 being Nat;
let R5 being Nat;
set D8 = ( R1 -BinarySequence R4 );
set D9 = ( R1 -BinarySequence R5 );
set D10 = ( FALSE );
set D11 = ( TRUE );
assume L156: ( R4 + R5 ) <= ( ( 2 to_power ( R1 -' 1 ) ) - 1 );
L157: R4 < ( 2 to_power ( R1 -' 1 ) ) by L156 , L93;
L158: R1 >= 1 by NAT_1:14;
L159: ( R1 - 1 ) >= ( 1 - 1 ) by L158 , XREAL_1:9;
L160: ( R1 -' 1 ) = ( R1 - 1 ) by L159 , XREAL_0:def 2;
L161: ( 2 to_power ( R1 -' 1 ) ) < ( 2 to_power R1 ) by L160 , POWER:39 , XREAL_1:146;
L162: ( ( 2 to_power ( R1 -' 1 ) ) - 1 ) < ( ( 2 to_power R1 ) - 1 ) by L161 , XREAL_1:14;
assume L163: (not ( ( carry (D8 , D9) ) /. R1 ) = D10);
L164: ( ( carry (D8 , D9) ) /. R1 ) = D11 by L163 , XBOOLEAN:def 3;
L165: R5 < ( 2 to_power ( R1 -' 1 ) ) by L156 , L93;
L166: 1 <= R1 by NAT_1:14;
L167: R1 in ( Seg R1 ) by L166 , FINSEQ_1:1;
L168: ( D9 /. R1 ) = ( IFEQ (( ( R5 div ( 2 to_power ( R1 -' 1 ) ) ) mod 2 ) , ( 0 ) , D10 , D11) ) by L167 , BINARI_3:def 1
.= ( IFEQ (( ( 0 ) mod 2 ) , ( 0 ) , D10 , D11) ) by L165 , NAT_D:27
.= ( IFEQ (( 0 ) , ( 0 ) , D10 , D11) ) by NAT_D:26
.= D10 by FUNCOP_1:def 8;
L169: ( D8 /. R1 ) = ( IFEQ (( ( R4 div ( 2 to_power ( R1 -' 1 ) ) ) mod 2 ) , ( 0 ) , D10 , D11) ) by L167 , BINARI_3:def 1
.= ( IFEQ (( ( 0 ) mod 2 ) , ( 0 ) , D10 , D11) ) by L157 , NAT_D:27
.= ( IFEQ (( 0 ) , ( 0 ) , D10 , D11) ) by NAT_D:26
.= D10 by FUNCOP_1:def 8;
L170: ( ( D8 + D9 ) /. R1 ) = ( ( D10 'xor' D10 ) 'xor' D11 ) by L169 , L164 , L167 , L168 , BINARITH:def 5
.= D11;
L171: ( Absval ( D8 + D9 ) ) >= ( 2 to_power ( R1 -' 1 ) ) by L170 , L134;
L172: ( R4 + R5 ) < ( 2 to_power ( R1 -' 1 ) ) by L156 , XREAL_1:146 , XXREAL_0:2;
thus L173: contradiction by L172 , L156 , L162 , L171 , L126 , XXREAL_0:2;
end;
theorem
L174: (for R4 being Nat holds (for R5 being Nat holds (for B33 being non  empty Nat holds (( R4 + R5 ) <= ( ( 2 to_power ( B33 -' 1 ) ) - 1 ) implies ( Intval ( ( B33 -BinarySequence R4 ) + ( B33 -BinarySequence R5 ) ) ) = ( R4 + R5 )))))
proof
let R4 being Nat;
let R5 being Nat;
let C27 being non  empty Nat;
assume that
L175: ( R4 + R5 ) <= ( ( 2 to_power ( C27 -' 1 ) ) - 1 );
L176: R4 < ( 2 to_power ( C27 -' 1 ) ) by L175 , L93;
set D12 = ( C27 -BinarySequence R4 );
set D13 = ( C27 -BinarySequence R5 );
set D14 = ( FALSE );
set D15 = ( TRUE );
L177: C27 >= 1 by NAT_1:14;
L178: ( C27 - 1 ) >= ( 1 - 1 ) by L177 , XREAL_1:9;
L179: ( C27 -' 1 ) = ( C27 - 1 ) by L178 , XREAL_0:def 2;
L180: ( 2 to_power ( C27 -' 1 ) ) < ( 2 to_power C27 ) by L179 , POWER:39 , XREAL_1:146;
L181: ( ( 2 to_power ( C27 -' 1 ) ) - 1 ) < ( ( 2 to_power C27 ) - 1 ) by L180 , XREAL_1:14;
L182: R5 < ( 2 to_power ( C27 -' 1 ) ) by L175 , L93;
L183: 1 <= C27 by NAT_1:14;
L184: C27 in ( Seg C27 ) by L183 , FINSEQ_1:1;
L185: ( D13 /. C27 ) = ( IFEQ (( ( R5 div ( 2 to_power ( C27 -' 1 ) ) ) mod 2 ) , ( 0 ) , D14 , D15) ) by L184 , BINARI_3:def 1
.= ( IFEQ (( ( 0 ) mod 2 ) , ( 0 ) , D14 , D15) ) by L182 , NAT_D:27
.= ( IFEQ (( 0 ) , ( 0 ) , D14 , D15) ) by NAT_D:26
.= D14 by FUNCOP_1:def 8;
L186: ( D12 /. C27 ) = ( IFEQ (( ( R4 div ( 2 to_power ( C27 -' 1 ) ) ) mod 2 ) , ( 0 ) , D14 , D15) ) by L184 , BINARI_3:def 1
.= ( IFEQ (( ( 0 ) mod 2 ) , ( 0 ) , D14 , D15) ) by L176 , NAT_D:27
.= ( IFEQ (( 0 ) , ( 0 ) , D14 , D15) ) by NAT_D:26
.= D14 by FUNCOP_1:def 8;
L187: ( ( D12 + D13 ) /. C27 ) = ( ( D14 'xor' D14 ) 'xor' ( ( carry (D12 , D13) ) /. C27 ) ) by L186 , L184 , L185 , BINARITH:def 5
.= D14 by L175 , L155;
L188: ( Intval ( D12 + D13 ) ) = ( Absval ( D12 + D13 ) ) by L187 , BINARI_2:def 3;
thus L189: thesis by L188 , L175 , L181 , L126 , XXREAL_0:2;
end;
theorem
L190: (for B34 being (Tuple of 1 , ( BOOLEAN )) holds (B34 = <* ( TRUE ) *> implies ( Intval B34 ) = ( - 1 )))
proof
let C28 being (Tuple of 1 , ( BOOLEAN ));
assume that
L191: C28 = <* ( TRUE ) *>;
L192: ( len C28 ) = 1 by CARD_1:def 7;
L193: ( C28 /. 1 ) = ( C28 . 1 ) by L192 , FINSEQ_4:15
.= ( TRUE ) by L191 , FINSEQ_1:40;
L194: ( Intval C28 ) = ( ( Absval C28 ) - ( 2 to_power 1 ) ) by L193 , BINARI_2:def 3
.= ( 1 - ( 2 to_power 1 ) ) by L191 , BINARITH:16
.= ( 1 - ( 1 + 1 ) ) by POWER:25
.= ( ( 0 ) - 1 );
thus L195: thesis by L194;
end;
theorem
L196: (for B35 being (Tuple of 1 , ( BOOLEAN )) holds (B35 = <* ( FALSE ) *> implies ( Intval B35 ) = ( 0 )))
proof
let C29 being (Tuple of 1 , ( BOOLEAN ));
assume that
L197: C29 = <* ( FALSE ) *>;
L198: ( len C29 ) = 1 by CARD_1:def 7;
L199: ( C29 /. 1 ) = ( C29 . 1 ) by L198 , FINSEQ_4:15
.= ( FALSE ) by L197 , FINSEQ_1:40;
L200: ( Intval C29 ) = ( Absval C29 ) by L199 , BINARI_2:def 3;
thus L201: thesis by L200 , L197 , BINARITH:15;
end;
theorem
L202: (for B36 being  boolean set holds ( ( TRUE ) 'or' B36 ) = ( TRUE ));
theorem
L203: (for B37 being non  empty Nat holds (( 0 ) <= ( ( 2 to_power ( B37 -' 1 ) ) - 1 ) & ( - ( 2 to_power ( B37 -' 1 ) ) ) <= ( 0 )))
proof
defpred S4[ Nat ] means (( 0 ) <= ( ( 2 to_power ( $1 -' 1 ) ) - 1 ) & ( - ( 2 to_power ( $1 -' 1 ) ) ) <= ( 0 ));
L204: (for B38 being non  empty Nat holds (S4[ B38 ] implies S4[ ( B38 + 1 ) ]))
proof
let C30 being non  empty Nat;
assume that
L205: ( 0 ) <= ( ( 2 to_power ( C30 -' 1 ) ) - 1 )
and
L206: ( - ( 2 to_power ( C30 -' 1 ) ) ) <= ( 0 );
L207: ( ( C30 + 1 ) -' 1 ) = C30 by NAT_D:34;
L208: ( 2 to_power ( C30 -' 1 ) ) < ( 2 to_power ( ( C30 + 1 ) -' 1 ) ) by L207 , NAT_2:9 , POWER:39;
thus L209: thesis by L208 , L205 , XREAL_1:9;
end;
L210: ( 1 - 1 ) = ( 0 );
L211: ( 2 to_power ( 1 -' 1 ) ) = ( 2 to_power ( 0 ) ) by L210 , XREAL_0:def 2
.= 1 by POWER:24;
L212: S4[ 1 ] by L211;
thus L213: (for B39 being non  empty Nat holds S4[ B39 ]) from NAT_1:sch 10(L212 , L204);
end;
theorem
L214: (for R1 being non  empty Nat holds (for B40 , B41 being (Tuple of R1 , ( BOOLEAN )) holds ((B40 = ( 0* R1 ) & B41 = ( 0* R1 )) implies B40 , B41 are_summable )))
proof
let R1 being non  empty Nat;
let C31 , C32 being (Tuple of R1 , ( BOOLEAN ));
assume that
L215: C31 = ( 0* R1 )
and
L216: C32 = ( 0* R1 );
L217: 1 <= R1 by NAT_1:14;
L218: ( len C31 ) = R1 by CARD_1:def 7;
L219: ( C31 /. R1 ) = ( ( 0* R1 ) . R1 ) by L218 , L215 , L217 , FINSEQ_4:15
.= ( FALSE );
L220: ( add_ovfl (C31 , C32) ) = ( ( ( ( FALSE ) '&' ( FALSE ) ) 'or' ( ( FALSE ) '&' ( ( carry (C31 , C32) ) /. R1 ) ) ) 'or' ( ( FALSE ) '&' ( ( carry (C31 , C32) ) /. R1 ) ) ) by L219 , L215 , L216 , BINARITH:def 6
.= ( FALSE );
thus L221: thesis by L220 , BINARITH:def 7;
end;
theorem
L222: (for R1 being non  empty Nat holds (for R8 being Integer holds ( ( R8 * R1 ) mod R1 ) = ( 0 )))
proof
let R1 being non  empty Nat;
let R8 being Integer;
L223: ( ( R8 * R1 ) mod R1 ) = ( ( ( R8 mod R1 ) * ( R1 mod R1 ) ) mod R1 ) by NAT_D:67
.= ( ( ( R8 mod R1 ) * ( 0 ) ) mod R1 ) by NAT_D:25
.= ( ( 0 ) mod R1 );
thus L224: thesis by L223 , NAT_D:26;
end;
begin
definition
let C33 , C34 being Nat;
func MajP (C33 , C34) -> Nat means 
:L225: (( 2 to_power it ) >= C34 & it >= C33 & (for B42 being Nat holds ((( 2 to_power B42 ) >= C34 & B42 >= C33) implies B42 >= it)));
existence
proof
per cases ;
suppose L226: ( 2 to_power C33 ) >= C34;

L227: (for B43 being Nat holds ((( 2 to_power B43 ) >= C34 & B43 >= C33) implies B43 >= C33));
thus L228: thesis by L227 , L226;
end;
suppose L229: ( 2 to_power C33 ) < C34;

defpred S5[ Nat ] means (( 2 to_power $1 ) >= C34 & $1 >= C33);
L230: ( 2 to_power C33 ) >= C33 by L6;
L231: C34 >= C33 by L230 , L229 , XXREAL_0:2;
L232: ( 2 to_power C34 ) >= C34 by L6;
L233: (ex B44 being Nat st S5[ B44 ]) by L232 , L231;
L234: (ex B45 being Nat st (S5[ B45 ] & (for B46 being Nat holds (S5[ B46 ] implies B46 >= B45)))) from NAT_1:sch 5(L233);
thus L235: thesis by L234;
end;
end;
uniqueness
proof
let C35 , C36 being Nat;
assume L237: (( 2 to_power C35 ) >= C34 & C35 >= C33 & (for B47 being Nat holds ((( 2 to_power B47 ) >= C34 & B47 >= C33) implies B47 >= C35)) & ( 2 to_power C36 ) >= C34 & C36 >= C33 & (for B48 being Nat holds ((( 2 to_power B48 ) >= C34 & B48 >= C33) implies B48 >= C36)));
L238: (C35 >= C36 & C36 >= C35) by L237;
thus L239: thesis by L238 , XXREAL_0:1;
end;
end;
theorem
L241: (for R2 being Nat holds (for R3 being Nat holds (for R5 being Nat holds (R2 >= R3 implies ( MajP (R5 , R2) ) >= ( MajP (R5 , R3) )))))
proof
let R2 being Nat;
let R3 being Nat;
let R5 being Nat;
assume L242: R2 >= R3;
L243: ( MajP (R5 , R2) ) >= R5 by L225;
L244: ( 2 to_power ( MajP (R5 , R2) ) ) >= R2 by L225;
L245: ( 2 to_power ( MajP (R5 , R2) ) ) >= R3 by L244 , L242 , XXREAL_0:2;
thus L246: thesis by L245 , L243 , L225;
end;
theorem
L247: (for R2 being Nat holds (for R4 being Nat holds (for R5 being Nat holds (R4 >= R5 implies ( MajP (R4 , R2) ) >= ( MajP (R5 , R2) )))))
proof
let R2 being Nat;
let R4 being Nat;
let R5 being Nat;
assume L248: R4 >= R5;
L249: ( 2 to_power ( MajP (R4 , R2) ) ) >= R2 by L225;
L250: ( MajP (R4 , R2) ) >= R4 by L225;
L251: ( MajP (R4 , R2) ) >= R5 by L250 , L248 , XXREAL_0:2;
thus L252: thesis by L251 , L249 , L225;
end;
theorem
L253: (for R5 being Nat holds (R5 >= 1 implies ( MajP (R5 , 1) ) = R5))
proof
let R5 being Nat;
assume L254: R5 >= 1;
L255: ( 2 to_power R5 ) >= 1 by L254 , POWER:35;
L256: (for B49 being Nat holds ((( 2 to_power B49 ) >= 1 & B49 >= R5) implies B49 >= R5));
thus L257: thesis by L256 , L255 , L225;
end;
theorem
L258: (for R2 being Nat holds (for R5 being Nat holds (R2 <= ( 2 to_power R5 ) implies ( MajP (R5 , R2) ) = R5)))
proof
let R2 being Nat;
let R5 being Nat;
L259: (for B50 being Nat holds ((( 2 to_power B50 ) >= R2 & B50 >= R5) implies B50 >= R5));
assume L260: R2 <= ( 2 to_power R5 );
thus L261: thesis by L260 , L259 , L225;
end;
theorem
L262: (for R2 being Nat holds (for R5 being Nat holds (R2 > ( 2 to_power R5 ) implies ( MajP (R5 , R2) ) > R5)))
proof
let R2 being Nat;
let R5 being Nat;
assume L263: R2 > ( 2 to_power R5 );
L264: ( 2 to_power ( MajP (R5 , R2) ) ) >= R2 by L225;
L265: ( 2 to_power ( MajP (R5 , R2) ) ) > ( 2 to_power R5 ) by L264 , L263 , XXREAL_0:2;
thus L266: thesis by L265 , PRE_FF:8;
end;
begin
definition
let C37 being Nat;
let C38 being Integer;
func 2sComplement (C37 , C38) -> (Tuple of C37 , ( BOOLEAN )) equals 
:L267: ( C37 -BinarySequence ( abs ( ( 2 to_power ( MajP (C37 , ( abs C38 )) ) ) + C38 ) ) ) if C38 < ( 0 ) otherwise ( C37 -BinarySequence ( abs C38 ) );
correctness;
end;
theorem
L269: (for B51 being Nat holds ( 2sComplement (B51 , ( 0 )) ) = ( 0* B51 ))
proof
let C39 being Nat;
L270: ( 2sComplement (C39 , ( 0 )) ) = ( C39 -BinarySequence ( abs ( 0 ) ) ) by L267
.= ( C39 -BinarySequence ( 0 ) ) by ABSVALUE:2;
thus L271: thesis by L270 , BINARI_3:25;
end;
theorem
L272: (for R1 being non  empty Nat holds (for B52 being Integer holds ((B52 <= ( ( 2 to_power ( R1 -' 1 ) ) - 1 ) & ( - ( 2 to_power ( R1 -' 1 ) ) ) <= B52) implies ( Intval ( 2sComplement (R1 , B52) ) ) = B52)))
proof
let R1 being non  empty Nat;
let R8 being Integer;
assume that
L273: R8 <= ( ( 2 to_power ( R1 -' 1 ) ) - 1 )
and
L274: ( - ( 2 to_power ( R1 -' 1 ) ) ) <= R8;
L275: R1 >= 1 by NAT_1:14;
L276:
now
per cases ;
suppose L277: R8 >= ( 0 );

reconsider D16 = R8 as (Element of ( NAT )) by L277 , INT_1:3;
L278: ( 2sComplement (R1 , D16) ) = ( R1 -BinarySequence ( abs D16 ) ) by L267
.= ( R1 -BinarySequence D16 ) by ABSVALUE:def 1;
L279: ( D16 + 1 ) <= ( ( ( 2 to_power ( R1 -' 1 ) ) - 1 ) + 1 ) by L273 , XREAL_1:6;
L280: D16 < ( 2 to_power ( R1 -' 1 ) ) by L279 , NAT_1:13;
L281: R1 >= 1 by NAT_1:14;
L282: ( R1 - 1 ) >= ( 1 - 1 ) by L281 , XREAL_1:9;
L283: ( R1 -' 1 ) = ( R1 - 1 ) by L282 , XREAL_0:def 2;
L284: ( 2 to_power ( R1 -' 1 ) ) < ( 2 to_power R1 ) by L283 , POWER:39 , XREAL_1:146;
L285: D16 < ( 2 to_power R1 ) by L284 , L280 , XXREAL_0:2;
L286: ( Absval ( R1 -BinarySequence D16 ) ) = D16 by L285 , BINARI_3:35;
L287: 1 <= R1 by NAT_1:14;
L288: R1 in ( Seg R1 ) by L287 , FINSEQ_1:1;
L289: ( ( R1 -BinarySequence D16 ) /. R1 ) = ( IFEQ (( ( D16 div ( 2 to_power ( R1 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L288 , BINARI_3:def 1
.= ( IFEQ (( ( 0 ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L280 , NAT_D:27
.= ( IFEQ (( 0 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by NAT_D:26
.= ( FALSE ) by FUNCOP_1:def 8;
thus L290: thesis by L289 , L278 , L286 , BINARI_2:def 3;
end;
suppose L291: R8 < ( 0 );

L292: ( 2 to_power R1 ) >= ( 2 to_power ( R1 -' 1 ) ) by NAT_2:9 , POWER:39;
L293: ( - ( 2 to_power R1 ) ) <= ( - ( 2 to_power ( R1 -' 1 ) ) ) by L292 , XREAL_1:24;
L294: ( - ( 2 to_power R1 ) ) <= R8 by L293 , L274 , XXREAL_0:2;
L295: ( ( - ( 2 to_power R1 ) ) - R8 ) <= ( R8 - R8 ) by L294 , XREAL_1:9;
L296: ( - ( ( 2 to_power R1 ) + R8 ) ) <= ( 0 ) by L295;
L297: ( ( 2 to_power R1 ) + R8 ) >= ( - ( 0 ) ) by L296 , XREAL_1:24;
reconsider D17 = ( ( 2 to_power R1 ) + R8 ) as (Element of ( NAT )) by L297 , INT_1:3;
L298: ( abs R8 ) = ( - R8 ) by L291 , ABSVALUE:def 1;
L299: ( abs R8 ) <= ( - ( - ( 2 to_power ( R1 -' 1 ) ) ) ) by L298 , L274 , XREAL_1:24;
L300: ( MajP (R1 , ( abs R8 )) ) = R1 by L299 , L292 , L258 , XXREAL_0:2;
L301: ( 2sComplement (R1 , R8) ) = ( R1 -BinarySequence ( abs D17 ) ) by L300 , L291 , L267
.= ( R1 -BinarySequence D17 ) by ABSVALUE:def 1;
L302: D17 < ( ( 2 to_power R1 ) + ( 0 ) ) by L291 , XREAL_1:8;
L303: D17 < ( ( 2 to_power 1 ) * ( 2 to_power ( R1 -' 1 ) ) ) by L302 , NAT_1:14 , NAT_2:10;
L304: D17 < ( 2 * ( 2 to_power ( R1 -' 1 ) ) ) by L303 , POWER:25;
L305: D17 < ( ( 2 to_power ( R1 -' 1 ) ) + ( 2 to_power ( R1 -' 1 ) ) ) by L304;
L306: ( ( 2 to_power R1 ) + R8 ) < ( ( 2 to_power R1 ) + ( 0 ) ) by L291 , XREAL_1:6;
L307: ( ( 2 to_power R1 ) + ( - ( 2 to_power ( R1 -' 1 ) ) ) ) = ( ( 2 to_power R1 ) - ( 2 to_power ( R1 -' 1 ) ) )
.= ( ( ( 2 to_power 1 ) * ( 2 to_power ( R1 -' 1 ) ) ) - ( 2 to_power ( R1 -' 1 ) ) ) by NAT_1:14 , NAT_2:10
.= ( ( 2 * ( 2 to_power ( R1 -' 1 ) ) ) - ( 2 to_power ( R1 -' 1 ) ) ) by POWER:25
.= ( 2 to_power ( R1 -' 1 ) );
L308: D17 >= ( 2 to_power ( R1 -' 1 ) ) by L307 , L274 , XREAL_1:6;
L309: R1 in ( Seg R1 ) by L275 , FINSEQ_1:1;
L310: ( ( R1 -BinarySequence D17 ) /. R1 ) = ( IFEQ (( ( D17 div ( 2 to_power ( R1 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L309 , BINARI_3:def 1
.= ( IFEQ (( 1 mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L308 , L305 , NAT_2:20
.= ( IFEQ (1 , ( 0 ) , ( FALSE ) , ( TRUE )) ) by NAT_D:14
.= ( TRUE ) by FUNCOP_1:def 8;
L311: ( Intval ( 2sComplement (R1 , R8) ) ) = ( ( Absval ( R1 -BinarySequence D17 ) ) - ( 2 to_power R1 ) ) by L310 , L301 , BINARI_2:def 3
.= ( D17 - ( 2 to_power R1 ) ) by L306 , BINARI_3:35
.= ( ( 0 ) + R8 );
thus L312: thesis by L311;
end;
end;
thus L314: thesis by L276;
end;
L315: (for R1 being non  empty Nat holds (for R3 being Nat holds (for R4 being Nat holds ((( R3 mod R1 ) = ( R4 mod R1 ) & R3 > R4) implies (ex B53 being Integer st R3 = ( R4 + ( B53 * R1 ) ))))))
proof
let R1 being non  empty Nat;
let R3 being Nat;
let R4 being Nat;
assume that
L316: ( R3 mod R1 ) = ( R4 mod R1 )
and
L317: R3 > R4;
consider C40 being Nat such that L318: R3 = ( R4 + C40 ) by L317 , NAT_1:10;
take ( C40 div R1 );
L319: (R4 = ( ( ( R4 div R1 ) * R1 ) + ( R4 mod R1 ) ) & R3 = ( ( ( R3 div R1 ) * R1 ) + ( R4 mod R1 ) )) by L316 , NAT_D:2;
L320: ( C40 mod R1 ) = ( ( ( ( R3 div R1 ) - ( R4 div R1 ) ) * R1 ) mod R1 ) by L319 , L318
.= ( 0 ) by L222;
L321: ( ( R4 + C40 ) div R1 ) = ( ( R4 div R1 ) + ( C40 div R1 ) ) by L320 , NAT_D:19;
L322: R3 = ( ( ( ( R4 div R1 ) + ( C40 div R1 ) ) * R1 ) + ( R4 mod R1 ) ) by L321 , L316 , L318 , NAT_D:2
.= ( ( ( C40 div R1 ) * R1 ) + ( ( ( R4 div R1 ) * R1 ) + ( R4 mod R1 ) ) )
.= ( ( ( C40 div R1 ) * R1 ) + R4 ) by NAT_D:2;
thus L323: thesis by L322;
end;
L324: (for R1 being non  empty Nat holds (for R3 being Nat holds (for R4 being Nat holds (( R3 mod R1 ) = ( R4 mod R1 ) implies (ex B54 being Integer st R3 = ( R4 + ( B54 * R1 ) ))))))
proof
let R1 being non  empty Nat;
let R3 being Nat;
let R4 being Nat;
assume L325: ( R3 mod R1 ) = ( R4 mod R1 );
L326:
now
per cases  by XXREAL_0:1;
suppose L327: R3 = R4;

set D18 = ( 0 );
L328: R3 = ( R4 + ( D18 * R1 ) ) by L327;
thus L329: thesis by L328;
end;
suppose L330: (R3 > R4 or R4 > R3);

L331:
now
per cases  by L330;
suppose L332: R3 > R4;

thus L333: thesis by L332 , L325 , L315;
end;
suppose L334: R3 < R4;

consider C41 being Integer such that L335: R4 = ( R3 + ( C41 * R1 ) ) by L334 , L325 , L315;
L336: R3 = ( R4 + ( ( - C41 ) * R1 ) ) by L335;
thus L337: thesis by L336;
end;
end;
thus L339: thesis by L331;
end;
end;
thus L341: thesis by L326;
end;
L342: (for R1 being non  empty Nat holds (for B55 , B56 , B57 being Nat holds ((B57 < R1 & ( B55 mod ( 2 to_power R1 ) ) = ( B56 mod ( 2 to_power R1 ) )) implies ( ( B55 div ( 2 to_power B57 ) ) mod 2 ) = ( ( B56 div ( 2 to_power B57 ) ) mod 2 ))))
proof
let R1 being non  empty Nat;
let C42 , C43 , C44 being Nat;
assume that
L343: C44 < R1
and
L344: ( C42 mod ( 2 to_power R1 ) ) = ( C43 mod ( 2 to_power R1 ) );
consider C45 being Nat such that L345: R1 = ( C44 + C45 ) by L343 , NAT_1:10;
L346: ( 2 to_power R1 ) = ( 2 |^ R1 ) by POWER:41;
L347: ( 2 to_power R1 ) is non  empty by L346 , PREPOWER:5;
consider C46 being Integer such that L348: C42 = ( C43 + ( C46 * ( 2 to_power R1 ) ) ) by L347 , L344 , L324;
reconsider D19 = C45 as Nat;
set D20 = ( 2 to_power C44 );
set D21 = ( 2 to_power D19 );
L349: ( C44 + ( - C44 ) ) < ( R1 + ( - C44 ) ) by L343 , XREAL_1:8;
L350: ( ( 0 ) + 1 ) < ( D19 + 1 ) by L349 , L345 , XREAL_1:8;
L351: 1 <= D19 by L350 , NAT_1:13;
L352: ( 2 to_power 1 ) divides ( 2 to_power D19 ) by L351 , NAT_2:11;
L353: 2 divides ( 2 to_power D19 ) by L352 , POWER:25;
L354: ( D21 mod 2 ) = ( 0 ) by L353 , PEPIN:6;
L355: ( ( C46 * D21 ) mod 2 ) = ( ( ( C46 mod 2 ) * ( 0 ) ) mod 2 ) by L354 , NAT_D:67
.= ( 0 ) by NAT_D:26;
reconsider D22 = C43 as Integer;
L356: D20 > ( 0 ) by POWER:34;
L357: ( C42 div D20 ) = ( ( C43 + ( C46 * ( D21 * D20 ) ) ) div D20 ) by L348 , L345 , POWER:27
.= ( ( C43 + ( ( C46 * D21 ) * D20 ) ) div D20 )
.= ( ( C43 div D20 ) + ( C46 * D21 ) ) by L356 , NAT_D:61;
L358: ( ( C42 div D20 ) mod 2 ) = ( ( ( ( D22 div D20 ) mod 2 ) + ( 0 ) ) mod 2 ) by L357 , L355 , NAT_D:66
.= ( ( D22 div D20 ) mod 2 ) by NAT_D:65;
thus L359: thesis by L358;
end;
L360: (for R1 being non  empty Nat holds (for B58 , B59 being Integer holds (( B58 mod ( 2 to_power R1 ) ) = ( B59 mod ( 2 to_power R1 ) ) implies ( ( ( 2 to_power ( MajP (R1 , ( abs B58 )) ) ) + B58 ) mod ( 2 to_power R1 ) ) = ( ( ( 2 to_power ( MajP (R1 , ( abs B59 )) ) ) + B59 ) mod ( 2 to_power R1 ) ))))
proof
let R1 being non  empty Nat;
let C47 , C48 being Integer;
assume that
L361: ( C47 mod ( 2 to_power R1 ) ) = ( C48 mod ( 2 to_power R1 ) );
L362: R1 <= ( MajP (R1 , ( abs C48 )) ) by L225;
consider C49 being Nat such that L363: ( MajP (R1 , ( abs C48 )) ) = ( R1 + C49 ) by L362 , NAT_1:10;
reconsider D23 = ( 2 to_power ( MajP (R1 , ( abs C48 )) ) ) as Integer;
reconsider D24 = ( 2 to_power ( MajP (R1 , ( abs C47 )) ) ) as Integer;
L364: R1 <= ( MajP (R1 , ( abs C47 )) ) by L225;
consider C50 being Nat such that L365: ( MajP (R1 , ( abs C47 )) ) = ( R1 + C50 ) by L364 , NAT_1:10;
reconsider D25 = C50 as Nat;
L366: D24 = ( ( 2 to_power R1 ) * ( 2 to_power D25 ) ) by L365 , POWER:27;
L367: ( D24 mod ( 2 to_power R1 ) ) = ( ( ( ( 2 to_power R1 ) mod ( 2 to_power R1 ) ) * ( 2 to_power D25 ) ) mod ( 2 to_power R1 ) ) by L366 , EULER_2:8
.= ( ( ( 0 ) * ( 2 to_power D25 ) ) mod ( 2 to_power R1 ) ) by NAT_D:25
.= ( 0 ) by NAT_D:26;
reconsider D26 = C49 as Nat;
L368: D23 = ( ( 2 to_power R1 ) * ( 2 to_power D26 ) ) by L363 , POWER:27;
L369: ( D23 mod ( 2 to_power R1 ) ) = ( ( ( ( 2 to_power R1 ) mod ( 2 to_power R1 ) ) * ( 2 to_power D26 ) ) mod ( 2 to_power R1 ) ) by L368 , EULER_2:8
.= ( ( ( 0 ) * ( 2 to_power D26 ) ) mod ( 2 to_power R1 ) ) by NAT_D:25
.= ( 0 ) by NAT_D:26;
L370: ( ( D23 + C48 ) mod ( 2 to_power R1 ) ) = ( ( ( D23 mod ( 2 to_power R1 ) ) + ( C48 mod ( 2 to_power R1 ) ) ) mod ( 2 to_power R1 ) ) by NAT_D:66
.= ( ( C48 mod ( 2 to_power R1 ) ) mod ( 2 to_power R1 ) ) by L369;
L371: ( ( D24 + C47 ) mod ( 2 to_power R1 ) ) = ( ( ( D24 mod ( 2 to_power R1 ) ) + ( C47 mod ( 2 to_power R1 ) ) ) mod ( 2 to_power R1 ) ) by NAT_D:66
.= ( ( C47 mod ( 2 to_power R1 ) ) mod ( 2 to_power R1 ) ) by L367;
thus L372: thesis by L371 , L361 , L370;
end;
L373: (for R1 being non  empty Nat holds (for B60 , B61 being Integer holds ((B60 >= ( 0 ) & B61 >= ( 0 ) & ( B60 mod ( 2 to_power R1 ) ) = ( B61 mod ( 2 to_power R1 ) )) implies ( 2sComplement (R1 , B60) ) = ( 2sComplement (R1 , B61) ))))
proof
let R1 being non  empty Nat;
let C51 , C52 being Integer;
assume that
L374: (C51 >= ( 0 ) & C52 >= ( 0 ))
and
L375: ( C51 mod ( 2 to_power R1 ) ) = ( C52 mod ( 2 to_power R1 ) );
L376: (for B62 being Nat holds (B62 in ( Seg R1 ) implies ( ( R1 -BinarySequence ( abs C51 ) ) . B62 ) = ( ( R1 -BinarySequence ( abs C52 ) ) . B62 )))
proof
L377: (( abs C51 ) = C51 & ( abs C52 ) = C52) by L374 , ABSVALUE:def 1;
let C53 being Nat;
assume that
L378: C53 in ( Seg R1 );
reconsider D27 = C53 as Nat;
L379: D27 <= R1 by L378 , FINSEQ_1:1;
L380: 1 <= D27 by L378 , FINSEQ_1:1;
L381: ( D27 - 1 ) >= ( 1 - 1 ) by L380 , XREAL_1:9;
L382: ( D27 -' 1 ) = ( D27 - 1 ) by L381 , XREAL_0:def 2;
L383: ( D27 -' 1 ) < R1 by L382 , L379 , XREAL_1:146 , XXREAL_0:2;
L384: ( len ( R1 -BinarySequence ( abs C52 ) ) ) = R1 by CARD_1:def 7;
L385: ( ( R1 -BinarySequence ( abs C52 ) ) . D27 ) = ( ( R1 -BinarySequence ( abs C52 ) ) /. D27 ) by L384 , L380 , L379 , FINSEQ_4:15
.= ( IFEQ (( ( ( abs C52 ) div ( 2 to_power ( D27 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L378 , BINARI_3:def 1;
L386: ( len ( R1 -BinarySequence ( abs C51 ) ) ) = R1 by CARD_1:def 7;
L387: ( ( R1 -BinarySequence ( abs C51 ) ) . D27 ) = ( ( R1 -BinarySequence ( abs C51 ) ) /. D27 ) by L386 , L380 , L379 , FINSEQ_4:15
.= ( IFEQ (( ( ( abs C51 ) div ( 2 to_power ( D27 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L378 , BINARI_3:def 1
.= ( IFEQ (( ( ( abs C52 ) div ( 2 to_power ( D27 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L375 , L383 , L377 , L342;
thus L388: thesis by L387 , L385;
end;
L389: (( 2sComplement (R1 , C51) ) = ( R1 -BinarySequence ( abs C51 ) ) & ( 2sComplement (R1 , C52) ) = ( R1 -BinarySequence ( abs C52 ) )) by L374 , L267;
thus L390: thesis by L389 , L376 , FINSEQ_2:119;
end;
L391: (for R1 being non  empty Nat holds (for B63 , B64 being Integer holds ((B63 < ( 0 ) & B64 < ( 0 ) & ( B63 mod ( 2 to_power R1 ) ) = ( B64 mod ( 2 to_power R1 ) )) implies ( 2sComplement (R1 , B63) ) = ( 2sComplement (R1 , B64) ))))
proof
let R1 being non  empty Nat;
let C54 , C55 being Integer;
assume that
L392: C54 < ( 0 )
and
L393: C55 < ( 0 )
and
L394: ( C54 mod ( 2 to_power R1 ) ) = ( C55 mod ( 2 to_power R1 ) );
L395: ( abs C55 ) = ( - C55 ) by L393 , ABSVALUE:def 1;
L396: ( 2 to_power ( MajP (R1 , ( abs C55 )) ) ) >= ( - C55 ) by L395 , L225;
L397: ( ( 2 to_power ( MajP (R1 , ( abs C55 )) ) ) + C55 ) >= ( ( - C55 ) + C55 ) by L396 , XREAL_1:6;
reconsider D28 = ( ( 2 to_power ( MajP (R1 , ( abs C55 )) ) ) + C55 ) as (Element of ( NAT )) by L397 , INT_1:3;
L398: ( abs C54 ) = ( - C54 ) by L392 , ABSVALUE:def 1;
L399: ( 2 to_power ( MajP (R1 , ( abs C54 )) ) ) >= ( - C54 ) by L398 , L225;
L400: ( ( 2 to_power ( MajP (R1 , ( abs C54 )) ) ) + C54 ) >= ( ( - C54 ) + C54 ) by L399 , XREAL_1:6;
reconsider D29 = ( ( 2 to_power ( MajP (R1 , ( abs C54 )) ) ) + C54 ) as (Element of ( NAT )) by L400 , INT_1:3;
L401: ( (D29 qua Nat) mod ( 2 to_power R1 ) ) = ( (D28 qua Nat) mod ( 2 to_power R1 ) ) by L394 , L360;
L402: (for B65 being Nat holds (B65 in ( Seg R1 ) implies ( ( R1 -BinarySequence ( abs D29 ) ) . B65 ) = ( ( R1 -BinarySequence ( abs D28 ) ) . B65 )))
proof
L403: ( len ( R1 -BinarySequence D28 ) ) = R1 by CARD_1:def 7;
let C56 being Nat;
assume that
L404: C56 in ( Seg R1 );
L405: 1 <= C56 by L404 , FINSEQ_1:1;
L406: C56 <= R1 by L404 , FINSEQ_1:1;
reconsider D30 = C56 as Nat;
L407: ( D30 - 1 ) >= ( 1 - 1 ) by L405 , XREAL_1:9;
L408: ( D30 -' 1 ) = ( D30 - 1 ) by L407 , XREAL_0:def 2;
L409: ( D30 -' 1 ) < R1 by L408 , L406 , XREAL_1:146 , XXREAL_0:2;
L410: (( len ( R1 -BinarySequence D29 ) ) = R1 & ( abs D29 ) = D29) by ABSVALUE:def 1 , CARD_1:def 7;
L411: ( ( R1 -BinarySequence ( abs D29 ) ) . D30 ) = ( ( R1 -BinarySequence D29 ) /. D30 ) by L410 , L405 , L406 , FINSEQ_4:15
.= ( IFEQ (( ( D29 div ( 2 to_power ( D30 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L404 , BINARI_3:def 1
.= ( IFEQ (( ( D28 div ( 2 to_power ( D30 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L401 , L409 , L342
.= ( ( R1 -BinarySequence D28 ) /. D30 ) by L404 , BINARI_3:def 1
.= ( ( R1 -BinarySequence D28 ) . D30 ) by L405 , L406 , L403 , FINSEQ_4:15;
thus L412: thesis by L411 , ABSVALUE:def 1;
end;
L413: (( 2sComplement (R1 , C54) ) = ( R1 -BinarySequence ( abs ( ( 2 to_power ( MajP (R1 , ( abs C54 )) ) ) + C54 ) ) ) & ( 2sComplement (R1 , C55) ) = ( R1 -BinarySequence ( abs ( ( 2 to_power ( MajP (R1 , ( abs C55 )) ) ) + C55 ) ) )) by L392 , L393 , L267;
thus L414: thesis by L413 , L402 , FINSEQ_2:119;
end;
theorem
L415: (for R1 being non  empty Nat holds (for B66 , B67 being Integer holds ((((B66 >= ( 0 ) & B67 >= ( 0 )) or (B66 < ( 0 ) & B67 < ( 0 ))) & ( B66 mod ( 2 to_power R1 ) ) = ( B67 mod ( 2 to_power R1 ) )) implies ( 2sComplement (R1 , B66) ) = ( 2sComplement (R1 , B67) )))) by L373 , L391;
theorem
L416: (for R1 being non  empty Nat holds (for B68 , B69 being Integer holds ((((B68 >= ( 0 ) & B69 >= ( 0 )) or (B68 < ( 0 ) & B69 < ( 0 ))) & B68 , B69 are_congruent_mod ( 2 to_power R1 )) implies ( 2sComplement (R1 , B68) ) = ( 2sComplement (R1 , B69) ))))
proof
let R1 being non  empty Nat;
let C57 , C58 being Integer;
assume that
L417: ((C57 >= ( 0 ) & C58 >= ( 0 )) or (C57 < ( 0 ) & C58 < ( 0 )))
and
L418: C57 , C58 are_congruent_mod ( 2 to_power R1 );
L419: ( C57 mod ( 2 to_power R1 ) ) = ( C58 mod ( 2 to_power R1 ) ) by L418 , NAT_D:64;
thus L420: thesis by L419 , L417 , L373 , L391;
end;
theorem
L421: (for R1 being non  empty Nat holds (for B70 , B71 being Nat holds (( B70 mod ( 2 to_power R1 ) ) = ( B71 mod ( 2 to_power R1 ) ) implies ( R1 -BinarySequence B70 ) = ( R1 -BinarySequence B71 ))))
proof
let R1 being non  empty Nat;
let C59 , C60 being Nat;
assume that
L422: ( C59 mod ( 2 to_power R1 ) ) = ( C60 mod ( 2 to_power R1 ) );
L423: ( abs C60 ) = C60 by ABSVALUE:def 1;
L424: ( 2sComplement (R1 , C60) ) = ( R1 -BinarySequence C60 ) by L423 , L267;
L425: ( abs C59 ) = C59 by ABSVALUE:def 1;
L426: ( 2sComplement (R1 , C59) ) = ( R1 -BinarySequence C59 ) by L425 , L267;
thus L427: thesis by L426 , L422 , L424 , L373;
end;
theorem
L428: (for R1 being non  empty Nat holds (for B72 , B73 being Nat holds (B72 , B73 are_congruent_mod ( 2 to_power R1 ) implies ( R1 -BinarySequence B72 ) = ( R1 -BinarySequence B73 ))))
proof
let R1 being non  empty Nat;
let C61 , C62 being Nat;
assume L429: C61 , C62 are_congruent_mod ( 2 to_power R1 );
L430: ( (C61 qua Integer) mod ( 2 to_power R1 ) ) = ( (C62 qua Integer) mod ( 2 to_power R1 ) ) by L429 , NAT_D:64;
thus L431: thesis by L430 , L421;
end;
theorem
L432: (for R1 being non  empty Nat holds (for R8 being Integer holds (for B74 being Nat holds ((1 <= B74 & B74 <= R1) implies ( ( 2sComplement (( R1 + 1 ) , R8) ) /. B74 ) = ( ( 2sComplement (R1 , R8) ) /. B74 )))))
proof
let R1 being non  empty Nat;
let R8 being Integer;
let C63 being Nat;
assume that
L433: 1 <= C63
and
L434: C63 <= R1;
L435: C63 in ( Seg R1 ) by L433 , L434 , FINSEQ_1:1;
L436: R1 <= ( R1 + 1 ) by NAT_1:11;
L437: C63 <= ( R1 + 1 ) by L436 , L434 , XXREAL_0:2;
L438: C63 in ( Seg ( R1 + 1 ) ) by L437 , L433 , FINSEQ_1:1;
set D31 = ( abs ( ( 2 to_power ( MajP (R1 , ( abs R8 )) ) ) + R8 ) );
set D32 = ( abs ( ( 2 to_power ( MajP (( R1 + 1 ) , ( abs R8 )) ) ) + R8 ) );
L439: (R8 < ( 0 ) implies ( ( D32 div ( 2 to_power ( C63 -' 1 ) ) ) mod 2 ) = ( ( D31 div ( 2 to_power ( C63 -' 1 ) ) ) mod 2 ))
proof
L440: ( MajP (( R1 + 1 ) , ( abs R8 )) ) >= ( MajP (R1 , ( abs R8 )) ) by L247 , NAT_1:11;
consider C64 being Nat such that L441: ( MajP (( R1 + 1 ) , ( abs R8 )) ) = ( ( MajP (R1 , ( abs R8 )) ) + C64 ) by L440 , NAT_1:10;
reconsider D33 = C64 as Nat;
set D34 = ( MajP (R1 , ( abs R8 )) );
assume L442: R8 < ( 0 );
set D35 = ( 2 to_power D34 );
L443: ( (( D35 * ( 2 to_power D33 ) ) qua Integer) mod D35 ) = ( 0 ) by NAT_D:13;
L444: ( 2 to_power ( MajP (( R1 + 1 ) , ( abs R8 )) ) ) >= ( abs R8 ) by L225;
L445: ( 2 to_power ( MajP (( R1 + 1 ) , ( abs R8 )) ) ) >= ( - R8 ) by L444 , L442 , ABSVALUE:def 1;
L446: ( ( 2 to_power ( MajP (( R1 + 1 ) , ( abs R8 )) ) ) + R8 ) >= ( ( - R8 ) + R8 ) by L445 , XREAL_1:6;
L447: D32 = ( ( 2 to_power ( D34 + D33 ) ) + R8 ) by L446 , L441 , ABSVALUE:def 1
.= ( ( D35 * ( 2 to_power D33 ) ) + R8 ) by POWER:27;
L448: ( D32 mod D35 ) = ( ( ( (( D35 * ( 2 to_power D33 ) ) qua Integer) mod D35 ) + ( R8 mod D35 ) ) mod D35 ) by L447 , NAT_D:66
.= ( ( R8 mod D35 ) mod D35 ) by L443;
L449: ( (D35 qua Integer) mod D35 ) = ( 0 ) by NAT_D:25;
L450: ( C63 + ( - 1 ) ) >= ( 1 + ( - 1 ) ) by L433 , XREAL_1:6;
L451: ( C63 -' 1 ) = ( C63 - 1 ) by L450 , XREAL_0:def 2;
L452: ( C63 -' 1 ) < R1 by L451 , L434 , XREAL_1:146 , XXREAL_0:2;
L453: D34 >= R1 by L225;
L454: ( C63 -' 1 ) < D34 by L453 , L452 , XXREAL_0:2;
L455: D35 >= ( abs R8 ) by L225;
L456: D35 >= ( - R8 ) by L455 , L442 , ABSVALUE:def 1;
L457: ( D35 + R8 ) >= ( ( - R8 ) + R8 ) by L456 , XREAL_1:6;
L458: D31 = ( D35 + R8 ) by L457 , ABSVALUE:def 1;
L459: ( D31 mod D35 ) = ( ( ( (D35 qua Integer) mod D35 ) + ( R8 mod D35 ) ) mod D35 ) by L458 , NAT_D:66
.= ( ( R8 mod D35 ) mod D35 ) by L449;
thus L460: thesis by L459 , L448 , L454 , L342;
end;
per cases ;
suppose L461: R8 >= ( 0 );

reconsider D36 = R8 as (Element of ( NAT )) by L461 , INT_1:3;
L462: ( ( 2sComplement (R1 , D36) ) /. C63 ) = ( ( R1 -BinarySequence ( abs D36 ) ) /. C63 ) by L267
.= ( ( R1 -BinarySequence D36 ) /. C63 ) by ABSVALUE:def 1
.= ( IFEQ (( ( D36 div ( 2 to_power ( C63 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L435 , BINARI_3:def 1;
L463: ( ( 2sComplement (( R1 + 1 ) , D36) ) /. C63 ) = ( ( ( R1 + 1 ) -BinarySequence ( abs D36 ) ) /. C63 ) by L267
.= ( ( ( R1 + 1 ) -BinarySequence D36 ) /. C63 ) by ABSVALUE:def 1
.= ( IFEQ (( ( D36 div ( 2 to_power ( C63 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L438 , BINARI_3:def 1;
thus L464: thesis by L463 , L462;
end;
suppose L465: R8 < ( 0 );

L466: ( ( 2sComplement (R1 , R8) ) /. C63 ) = ( ( R1 -BinarySequence D31 ) /. C63 ) by L465 , L267
.= ( IFEQ (( ( D31 div ( 2 to_power ( C63 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L435 , BINARI_3:def 1;
L467: ( ( 2sComplement (( R1 + 1 ) , R8) ) /. C63 ) = ( ( ( R1 + 1 ) -BinarySequence D32 ) /. C63 ) by L465 , L267
.= ( IFEQ (( ( D32 div ( 2 to_power ( C63 -' 1 ) ) ) mod 2 ) , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L438 , BINARI_3:def 1;
thus L468: thesis by L467 , L439 , L465 , L466;
end;
end;
theorem
L470: (for R5 being Nat holds (for R8 being Integer holds (ex B75 being (Element of ( BOOLEAN )) st ( 2sComplement (( R5 + 1 ) , R8) ) = ( ( 2sComplement (R5 , R8) ) ^ <* B75 *> ))))
proof
let R5 being Nat;
let R8 being Integer;
consider C65 being (Element of ( R5 -tuples_on ( BOOLEAN ) )), C66 being (Element of ( BOOLEAN )) such that L471: ( 2sComplement (( R5 + 1 ) , R8) ) = ( C65 ^ <* C66 *> ) by FINSEQ_2:117;
L472:
now
per cases ;
suppose L473: R5 > ( 0 );

reconsider D37 = R5 as non  empty Nat by L473;
L474: (for B76 being Nat holds (B76 in ( Seg D37 ) implies ( ( 2sComplement (D37 , R8) ) . B76 ) = ( C65 . B76 )))
proof
L475: ( len ( 2sComplement (D37 , R8) ) ) = D37 by CARD_1:def 7;
let C67 being Nat;
assume that
L476: C67 in ( Seg D37 );
reconsider D38 = C67 as Nat;
L477: 1 <= D38 by L476 , FINSEQ_1:1;
L478: ( len C65 ) = D37 by CARD_1:def 7;
L479: D38 in ( dom C65 ) by L478 , L476 , FINSEQ_1:def 3;
L480: D38 <= D37 by L476 , FINSEQ_1:1;
L481: D37 <= ( D37 + 1 ) by NAT_1:11;
L482: (( len ( 2sComplement (( D37 + 1 ) , R8) ) ) = ( D37 + 1 ) & D38 <= ( D37 + 1 )) by L481 , L480 , CARD_1:def 7 , XXREAL_0:2;
L483: ( ( 2sComplement (( D37 + 1 ) , R8) ) . D38 ) = ( ( 2sComplement (( D37 + 1 ) , R8) ) /. D38 ) by L482 , L477 , FINSEQ_4:15
.= ( ( 2sComplement (D37 , R8) ) /. D38 ) by L477 , L480 , L432
.= ( ( 2sComplement (D37 , R8) ) . D38 ) by L475 , L477 , L480 , FINSEQ_4:15;
thus L484: thesis by L483 , L471 , L479 , FINSEQ_1:def 7;
end;
L485: C65 = ( 2sComplement (D37 , R8) ) by L474 , FINSEQ_2:119;
thus L486: thesis by L485 , L471;
end;
suppose L487: R5 = ( 0 );

consider C68 being (Element of ( BOOLEAN )) such that L488: ( 2sComplement (( R5 + 1 ) , R8) ) = <* C68 *> by L487 , FINSEQ_2:97;
L489: ( 2sComplement (( R5 + 1 ) , R8) ) = ( ( {} ) ^ <* C68 *> ) by L488 , FINSEQ_1:34;
L490: ( 2sComplement (R5 , R8) ) = ( {} ) by L487;
thus L491: thesis by L490 , L489;
end;
end;
thus L493: thesis by L472;
end;
theorem
L494: (for R4 being Nat holds (for R5 being Nat holds (ex B77 being (Element of ( BOOLEAN )) st ( ( R5 + 1 ) -BinarySequence R4 ) = ( ( R5 -BinarySequence R4 ) ^ <* B77 *> ))))
proof
let R4 being Nat;
let R5 being Nat;
consider C69 being (Element of ( BOOLEAN )) such that L495: ( 2sComplement (( R5 + 1 ) , R4) ) = ( ( 2sComplement (R5 , R4) ) ^ <* C69 *> ) by L470;
L496: ( abs R4 ) = R4 by ABSVALUE:def 1;
L497: ( ( R5 + 1 ) -BinarySequence R4 ) = ( ( 2sComplement (R5 , R4) ) ^ <* C69 *> ) by L496 , L495 , L267
.= ( ( R5 -BinarySequence R4 ) ^ <* C69 *> ) by L496 , L267;
thus L498: thesis by L497;
end;
theorem
L499: (for R7 being Integer holds (for R8 being Integer holds (for B78 being non  empty Nat holds ((( - ( 2 to_power B78 ) ) <= ( R7 + R8 ) & R7 < ( 0 ) & R8 < ( 0 ) & ( - ( 2 to_power ( B78 -' 1 ) ) ) <= R7 & ( - ( 2 to_power ( B78 -' 1 ) ) ) <= R8) implies ( ( carry (( 2sComplement (( B78 + 1 ) , R7) ) , ( 2sComplement (( B78 + 1 ) , R8) )) ) /. ( B78 + 1 ) ) = ( TRUE )))))
proof
let R7 being Integer;
let R8 being Integer;
defpred S6[ Nat ] means ((( - ( 2 to_power $1 ) ) <= ( R7 + R8 ) & R7 < ( 0 ) & R8 < ( 0 ) & ( - ( 2 to_power ( $1 -' 1 ) ) ) <= R7 & ( - ( 2 to_power ( $1 -' 1 ) ) ) <= R8) implies ( ( carry (( 2sComplement (( $1 + 1 ) , R7) ) , ( 2sComplement (( $1 + 1 ) , R8) )) ) /. ( $1 + 1 ) ) = ( TRUE ));
L500: (for B79 being non  empty Nat holds (S6[ B79 ] implies S6[ ( B79 + 1 ) ]))
proof
let C70 being non  empty Nat;
assume that
L501: S6[ C70 ];
assume that
L502: ( - ( 2 to_power ( C70 + 1 ) ) ) <= ( R7 + R8 )
and
L503: R7 < ( 0 )
and
L504: R8 < ( 0 )
and
L505: ( - ( 2 to_power ( ( C70 + 1 ) -' 1 ) ) ) <= R7
and
L506: ( - ( 2 to_power ( ( C70 + 1 ) -' 1 ) ) ) <= R8;
set D39 = ( 2sComplement (( ( C70 + 1 ) + 1 ) , R7) );
set D40 = ( 2sComplement (( ( C70 + 1 ) + 1 ) , R8) );
set D41 = ( 2sComplement (( C70 + 1 ) , R7) );
set D42 = ( 2sComplement (( C70 + 1 ) , R8) );
set D43 = ( TRUE );
set D44 = ( C70 + 1 );
L507: ( D44 -' 1 ) = ( D44 - 1 ) by XREAL_0:def 2;
L508: ( 2 to_power ( D44 -' 1 ) ) < ( 2 to_power D44 ) by L507 , POWER:39 , XREAL_1:146;
L509: ( ( 2 to_power ( D44 -' 1 ) ) + ( 2 to_power ( D44 -' 1 ) ) ) = ( 2 * ( 2 to_power ( D44 -' 1 ) ) )
.= ( ( 2 to_power 1 ) * ( 2 to_power ( D44 -' 1 ) ) ) by POWER:25
.= ( 2 to_power ( ( 0 ) + D44 ) ) by L507 , POWER:27;
L510: ( ( - ( 2 to_power ( D44 -' 1 ) ) ) + ( 2 to_power D44 ) ) = ( 2 to_power ( D44 -' 1 ) ) by L509;
L511: ( 2 to_power ( D44 -' 1 ) ) <= ( ( 2 to_power D44 ) + R7 ) by L510 , L505 , XREAL_1:6;
L512: ( 2 to_power ( D44 -' 1 ) ) <= ( ( 2 to_power D44 ) + R8 ) by L506 , L510 , XREAL_1:6;
L513: ( ( 2 to_power D44 ) + R8 ) < ( ( 0 ) + ( 2 to_power D44 ) ) by L504 , XREAL_1:8;
L514: ( D44 - 1 ) = C70;
L515: ( D44 -' 1 ) = C70 by L514 , XREAL_0:def 2;
L516: (( 0 ) <= ( ( 2 to_power D44 ) + R7 ) & ( 0 ) <= ( ( 2 to_power D44 ) + R8 )) by L505 , L506 , L510 , XREAL_1:6;
reconsider D45 = ( ( 2 to_power D44 ) + R7 ) , D46 = ( ( 2 to_power D44 ) + R8 ) as (Element of ( NAT )) by L516 , INT_1:3;
L517: ( len ( D44 -BinarySequence D46 ) ) = D44 by CARD_1:def 7;
L518: 1 <= D44 by NAT_1:11;
L519: (( D39 /. D44 ) = ( D41 /. D44 ) & ( D40 /. D44 ) = ( D42 /. D44 )) by L518 , L432;
L520: ( ( 2 to_power D44 ) + R7 ) < ( ( 0 ) + ( 2 to_power D44 ) ) by L503 , XREAL_1:8;
L521: D44 < ( D44 + 1 ) by NAT_1:13;
L522: ( abs R8 ) = ( - R8 ) by L504 , ABSVALUE:def 1;
L523: ( - ( - ( 2 to_power ( D44 -' 1 ) ) ) ) >= ( abs R8 ) by L522 , L506 , XREAL_1:24;
L524: ( MajP (D44 , ( abs R8 )) ) = D44 by L523 , L508 , L258 , XXREAL_0:2;
L525: ( D42 /. D44 ) = ( ( D44 -BinarySequence ( abs D46 ) ) /. D44 ) by L524 , L504 , L267
.= ( ( D44 -BinarySequence D46 ) /. D44 ) by ABSVALUE:def 1
.= ( ( D44 -BinarySequence D46 ) . D44 ) by L518 , L517 , FINSEQ_4:15
.= D43 by L515 , L512 , L513 , BINARI_3:29;
L526: ( len ( D44 -BinarySequence D45 ) ) = D44 by CARD_1:def 7;
L527: ( abs R7 ) = ( - R7 ) by L503 , ABSVALUE:def 1;
L528: ( - ( - ( 2 to_power ( D44 -' 1 ) ) ) ) >= ( abs R7 ) by L527 , L505 , XREAL_1:24;
L529: ( MajP (D44 , ( abs R7 )) ) = D44 by L528 , L508 , L258 , XXREAL_0:2;
L530: ( D41 /. D44 ) = ( ( D44 -BinarySequence ( abs D45 ) ) /. D44 ) by L529 , L503 , L267
.= ( ( D44 -BinarySequence D45 ) /. D44 ) by ABSVALUE:def 1
.= ( ( D44 -BinarySequence D45 ) . D44 ) by L518 , L526 , FINSEQ_4:15
.= D43 by L515 , L511 , L520 , BINARI_3:29;
L531: ( ( carry (D39 , D40) ) /. ( D44 + 1 ) ) = ( ( ( D43 '&' D43 ) 'or' ( D43 '&' ( ( carry (D39 , D40) ) /. D44 ) ) ) 'or' ( D43 '&' ( ( carry (D39 , D40) ) /. D44 ) ) ) by L530 , L518 , L525 , L519 , L521 , BINARITH:def 2
.= ( D43 'or' ( ( carry (D39 , D40) ) /. D44 ) );
thus L532: thesis by L531;
end;
L533: S6[ 1 ]
proof
L534: ( 1 -' 1 ) = ( 1 - 1 ) by XREAL_0:def 2;
L535: ( 3 div ( 2 to_power ( 1 -' 1 ) ) ) = ( ( 1 + 2 ) div 1 ) by L534 , POWER:24
.= 3 by NAT_2:4;
L536: ( ( 3 div ( 2 to_power ( 1 -' 1 ) ) ) mod 2 ) = ( ( 2 + 1 ) mod 2 ) by L535
.= ( ( ( 2 mod 2 ) + 1 ) mod 2 ) by NAT_D:22
.= ( ( ( 0 ) + 1 ) mod 2 ) by NAT_D:25
.= 1 by PEPIN:5;
L537: ( ( - 2 ) + 1 ) = ( - 1 );
set D47 = ( 2sComplement (2 , R7) );
set D48 = ( 2sComplement (2 , R8) );
set D49 = ( TRUE );
assume that
L538: ( - ( 2 to_power 1 ) ) <= ( R7 + R8 )
and
L539: R7 < ( 0 )
and
L540: R8 < ( 0 )
and
L541: ( - ( 2 to_power ( 1 -' 1 ) ) ) <= R7
and
L542: ( - ( 2 to_power ( 1 -' 1 ) ) ) <= R8;
L543: R8 <= ( - 1 ) by L540 , INT_1:8;
L544: ( - ( 2 to_power 1 ) ) < R7 by L538 , L539 , L540 , L107;
L545: ( - 2 ) < R7 by L544 , POWER:25;
L546: ( - 1 ) <= R7 by L545 , L537 , INT_1:7;
L547: ( - ( 2 to_power 1 ) ) < R8 by L538 , L539 , L540 , L107;
L548: ( - 2 ) < R8 by L547 , POWER:25;
L549: ( - 1 ) <= R8 by L548 , L537 , INT_1:7;
L550: R8 = ( - 1 ) by L549 , L543 , XXREAL_0:1;
L551: 1 in ( Seg 2 ) by FINSEQ_1:1;
L552: ( 2 to_power 2 ) = ( 2 |^ ( 1 + 1 ) ) by POWER:41
.= ( ( 2 |^ 1 ) + ( 2 |^ 1 ) ) by PEPIN:29
.= ( ( 2 to_power 1 ) + ( 2 |^ 1 ) ) by POWER:41
.= ( ( 2 to_power 1 ) + ( 2 to_power 1 ) ) by POWER:41
.= ( 2 + ( 2 to_power 1 ) ) by POWER:25
.= ( 2 + 2 ) by POWER:25;
L553: ( 2 to_power 2 ) > ( 2 to_power ( 0 ) ) by POWER:39;
L554: R7 <= ( - 1 ) by L539 , INT_1:8;
L555: R7 = ( - 1 ) by L554 , L546 , XXREAL_0:1;
L556: ( abs R7 ) = ( - ( - 1 ) ) by L555 , ABSVALUE:def 1;
L557: ( 2 to_power ( 0 ) ) = ( abs R7 ) by L556 , POWER:24;
L558: ( MajP (2 , ( abs R7 )) ) = 2 by L557 , L553 , L258;
L559: ( abs ( ( 2 to_power ( MajP (2 , ( abs R7 )) ) ) + R7 ) ) = ( abs ( 4 + ( - 1 ) ) ) by L558 , L546 , L554 , L552 , XXREAL_0:1
.= 3 by ABSVALUE:def 1;
L560: ( ( 2sComplement (2 , R7) ) /. 1 ) = ( ( 2 -BinarySequence 3 ) /. 1 ) by L559 , L539 , L267
.= ( IFEQ (1 , ( 0 ) , ( FALSE ) , ( TRUE )) ) by L536 , L551 , BINARI_3:def 1
.= ( TRUE ) by FUNCOP_1:def 8;
L561: ( ( carry (D47 , D48) ) /. ( 1 + 1 ) ) = ( ( ( D49 '&' D49 ) 'or' ( D49 '&' ( ( carry (D47 , D48) ) /. 1 ) ) ) 'or' ( D49 '&' ( ( carry (D47 , D48) ) /. 1 ) ) ) by L560 , L555 , L550 , BINARITH:def 2
.= ( D49 'or' ( ( carry (D47 , D48) ) /. 1 ) );
thus L562: thesis by L561;
end;
thus L563: (for B80 being non  empty Nat holds S6[ B80 ]) from NAT_1:sch 10(L533 , L500);
end;
theorem
L564: (for R7 being Integer holds (for R8 being Integer holds (for B81 being non  empty Nat holds ((( R7 + R8 ) <= ( ( 2 to_power ( B81 -' 1 ) ) - 1 ) & R7 >= ( 0 ) & R8 >= ( 0 )) implies ( Intval ( ( 2sComplement (B81 , R7) ) + ( 2sComplement (B81 , R8) ) ) ) = ( R7 + R8 )))))
proof
let R7 being Integer;
let R8 being Integer;
let C71 being non  empty Nat;
assume that
L565: ( R7 + R8 ) <= ( ( 2 to_power ( C71 -' 1 ) ) - 1 )
and
L566: (R7 >= ( 0 ) & R8 >= ( 0 ));
reconsider D50 = R7 , D51 = R8 as (Element of ( NAT )) by L566 , INT_1:3;
L567: ( 2sComplement (C71 , D51) ) = ( C71 -BinarySequence ( abs D51 ) ) by L267
.= ( C71 -BinarySequence D51 ) by ABSVALUE:def 1;
L568: ( 2sComplement (C71 , D50) ) = ( C71 -BinarySequence ( abs D50 ) ) by L267
.= ( C71 -BinarySequence D50 ) by ABSVALUE:def 1;
thus L569: thesis by L568 , L565 , L567 , L174;
end;
theorem
L570: (for R7 being Integer holds (for R8 being Integer holds (for B82 being non  empty Nat holds ((( - ( 2 to_power ( ( B82 + 1 ) -' 1 ) ) ) <= ( R7 + R8 ) & R7 < ( 0 ) & R8 < ( 0 ) & ( - ( 2 to_power ( B82 -' 1 ) ) ) <= R7 & ( - ( 2 to_power ( B82 -' 1 ) ) ) <= R8) implies ( Intval ( ( 2sComplement (( B82 + 1 ) , R7) ) + ( 2sComplement (( B82 + 1 ) , R8) ) ) ) = ( R7 + R8 )))))
proof
let R7 being Integer;
let R8 being Integer;
let C72 being non  empty Nat;
assume that
L571: ( - ( 2 to_power ( ( C72 + 1 ) -' 1 ) ) ) <= ( R7 + R8 )
and
L572: R7 < ( 0 )
and
L573: R8 < ( 0 )
and
L574: (( - ( 2 to_power ( C72 -' 1 ) ) ) <= R7 & ( - ( 2 to_power ( C72 -' 1 ) ) ) <= R8);
L575: ( ( 2 to_power ( C72 + 1 ) ) + ( - ( 2 to_power C72 ) ) ) = ( ( - ( 2 to_power C72 ) ) + ( ( 2 to_power 1 ) * ( 2 to_power C72 ) ) ) by POWER:27
.= ( ( - ( 2 to_power C72 ) ) + ( 2 * ( 2 to_power C72 ) ) ) by POWER:25
.= ( 2 to_power C72 );
L576: ( ( C72 + 1 ) - 1 ) = C72;
L577: ( - ( 2 to_power C72 ) ) <= ( R7 + R8 ) by L576 , L571 , XREAL_0:def 2;
L578: ( - ( 2 to_power C72 ) ) < R7 by L577 , L572 , L573 , L107;
L579: ( 2 to_power C72 ) <= ( ( 2 to_power ( C72 + 1 ) ) + R7 ) by L578 , L575 , XREAL_1:6;
L580: ( - ( 2 to_power C72 ) ) < R8 by L572 , L573 , L577 , L107;
L581: ( 0 ) <= ( ( 2 to_power ( C72 + 1 ) ) + R8 ) by L580 , L575 , XREAL_1:6;
L582: ( 0 ) <= ( ( 2 to_power ( C72 + 1 ) ) + R7 ) by L578 , L575 , XREAL_1:6;
reconsider D52 = ( ( 2 to_power ( C72 + 1 ) ) + R7 ) , D53 = ( ( 2 to_power ( C72 + 1 ) ) + R8 ) as (Element of ( NAT )) by L582 , L581 , INT_1:3;
L583: 1 <= ( C72 + 1 ) by NAT_1:11;
set D54 = ( 2sComplement (C72 , R7) );
set D55 = ( 2sComplement (C72 , R8) );
set D56 = ( 2sComplement (( C72 + 1 ) , R7) );
set D57 = ( 2sComplement (( C72 + 1 ) , R8) );
set D58 = ( FALSE );
set D59 = ( TRUE );
L584: C72 < ( C72 + 1 ) by XREAL_1:29;
L585: ( 2 to_power C72 ) < ( 2 to_power ( C72 + 1 ) ) by L584 , POWER:39;
L586: ((ex B83 being (Element of ( BOOLEAN )) st D56 = ( D54 ^ <* B83 *> )) & (ex B84 being (Element of ( BOOLEAN )) st D57 = ( D55 ^ <* B84 *> ))) by L470;
L587: ( ( 2 to_power ( C72 + 1 ) ) + R7 ) < ( ( 2 to_power ( C72 + 1 ) ) + ( 0 ) ) by L572 , XREAL_1:8;
L588: ( - R7 ) < ( - ( - ( 2 to_power C72 ) ) ) by L578 , XREAL_1:24;
L589: ( abs R7 ) < ( 2 to_power C72 ) by L588 , L572 , ABSVALUE:def 1;
L590: ( MajP (( C72 + 1 ) , ( abs R7 )) ) = ( C72 + 1 ) by L589 , L585 , L258 , XXREAL_0:2;
L591: D56 = ( ( C72 + 1 ) -BinarySequence ( abs ( ( 2 to_power ( C72 + 1 ) ) + R7 ) ) ) by L590 , L572 , L267
.= ( ( C72 + 1 ) -BinarySequence D52 ) by ABSVALUE:def 1;
L592: ( len D56 ) = ( C72 + 1 ) by CARD_1:def 7;
L593: ( D56 /. ( C72 + 1 ) ) = ( D56 . ( C72 + 1 ) ) by L592 , L583 , FINSEQ_4:15
.= ( ( ( C72 + 1 ) -BinarySequence ( abs ( ( 2 to_power ( C72 + 1 ) ) + R7 ) ) ) . ( C72 + 1 ) ) by L572 , L590 , L267
.= ( ( ( C72 + 1 ) -BinarySequence D52 ) . ( C72 + 1 ) ) by ABSVALUE:def 1
.= D59 by L587 , L579 , BINARI_3:29;
L594: ( 2 to_power C72 ) <= ( ( 2 to_power ( C72 + 1 ) ) + R8 ) by L580 , L575 , XREAL_1:6;
L595: ( ( 2 to_power ( C72 + 1 ) ) + R8 ) < ( ( 2 to_power ( C72 + 1 ) ) + ( 0 ) ) by L573 , XREAL_1:8;
L596: ( - R8 ) < ( - ( - ( 2 to_power C72 ) ) ) by L580 , XREAL_1:24;
L597: ( abs R8 ) < ( 2 to_power C72 ) by L596 , L573 , ABSVALUE:def 1;
L598: ( MajP (( C72 + 1 ) , ( abs R8 )) ) = ( C72 + 1 ) by L597 , L585 , L258 , XXREAL_0:2;
L599: D57 = ( ( C72 + 1 ) -BinarySequence ( abs ( ( 2 to_power ( C72 + 1 ) ) + R8 ) ) ) by L598 , L573 , L267
.= ( ( C72 + 1 ) -BinarySequence D53 ) by ABSVALUE:def 1;
L600: ( len D57 ) = ( C72 + 1 ) by CARD_1:def 7;
L601: ( D57 /. ( C72 + 1 ) ) = ( D57 . ( C72 + 1 ) ) by L600 , L583 , FINSEQ_4:15
.= ( ( ( C72 + 1 ) -BinarySequence ( abs ( ( 2 to_power ( C72 + 1 ) ) + R8 ) ) ) . ( C72 + 1 ) ) by L573 , L598 , L267
.= ( ( ( C72 + 1 ) -BinarySequence D53 ) . ( C72 + 1 ) ) by ABSVALUE:def 1
.= D59 by L595 , L594 , BINARI_3:29;
L602: ( Intval D57 ) = ( ( Absval D57 ) - ( 2 to_power ( C72 + 1 ) ) ) by L601 , BINARI_2:def 3
.= ( D53 - ( 2 to_power ( C72 + 1 ) ) ) by L595 , L599 , BINARI_3:35
.= R8;
L603: ( ( carry (D56 , D57) ) /. ( C72 + 1 ) ) = D59 by L572 , L573 , L574 , L577 , L499;
L604: ( Int_add_ovfl (D56 , D57) ) = ( ( D58 '&' ( 'not' D59 ) ) '&' D59 ) by L603 , L593 , L601 , BINARI_2:def 4
.= D58;
L605: ( Int_add_udfl (D56 , D57) ) = ( ( D59 '&' D59 ) '&' ( 'not' D59 ) ) by L593 , L601 , L603 , BINARI_2:def 5
.= D58;
L606: ( Intval D56 ) = ( ( Absval D56 ) - ( 2 to_power ( C72 + 1 ) ) ) by L593 , BINARI_2:def 3
.= ( D52 - ( 2 to_power ( C72 + 1 ) ) ) by L587 , L591 , BINARI_3:35
.= R7;
L607: ( Intval ( D56 + D57 ) ) = ( ( ( R7 + R8 ) - ( IFEQ (D58 , D58 , ( 0 ) , ( 2 to_power ( C72 + 1 ) )) ) ) + ( IFEQ (D58 , D58 , ( 0 ) , ( 2 to_power ( C72 + 1 ) )) ) ) by L606 , L586 , L602 , L604 , L605 , BINARI_2:12
.= ( ( ( R7 + R8 ) - ( 0 ) ) + ( 0 ) );
thus L608: thesis by L607;
end;
theorem
L609: (for R7 being Integer holds (for R8 being Integer holds (for B85 being non  empty Nat holds ((( - ( 2 to_power ( B85 -' 1 ) ) ) <= R7 & R7 <= ( ( 2 to_power ( B85 -' 1 ) ) - 1 ) & ( - ( 2 to_power ( B85 -' 1 ) ) ) <= R8 & R8 <= ( ( 2 to_power ( B85 -' 1 ) ) - 1 ) & ( - ( 2 to_power ( B85 -' 1 ) ) ) <= ( R7 + R8 ) & ( R7 + R8 ) <= ( ( 2 to_power ( B85 -' 1 ) ) - 1 ) & ((R7 >= ( 0 ) & R8 < ( 0 )) or (R7 < ( 0 ) & R8 >= ( 0 )))) implies ( Intval ( ( 2sComplement (B85 , R7) ) + ( 2sComplement (B85 , R8) ) ) ) = ( R7 + R8 )))))
proof
let R7 being Integer;
let R8 being Integer;
defpred S7[ non  empty Nat ] means ((( - ( 2 to_power ( $1 -' 1 ) ) ) <= R7 & R7 <= ( ( 2 to_power ( $1 -' 1 ) ) - 1 ) & ( - ( 2 to_power ( $1 -' 1 ) ) ) <= R8 & R8 <= ( ( 2 to_power ( $1 -' 1 ) ) - 1 ) & ( - ( 2 to_power ( $1 -' 1 ) ) ) <= ( R7 + R8 ) & ( R7 + R8 ) <= ( ( 2 to_power ( $1 -' 1 ) ) - 1 ) & ((R7 >= ( 0 ) & R8 < ( 0 )) or (R7 < ( 0 ) & R8 >= ( 0 )))) implies ( Intval ( ( 2sComplement ($1 , R7) ) + ( 2sComplement ($1 , R8) ) ) ) = ( R7 + R8 ));
L610: (for B86 being non  empty Nat holds (S7[ B86 ] implies S7[ ( B86 + 1 ) ]))
proof
let C73 being non  empty Nat;
assume that
L611: ((( - ( 2 to_power ( C73 -' 1 ) ) ) <= R7 & R7 <= ( ( 2 to_power ( C73 -' 1 ) ) - 1 ) & ( - ( 2 to_power ( C73 -' 1 ) ) ) <= R8 & R8 <= ( ( 2 to_power ( C73 -' 1 ) ) - 1 ) & ( - ( 2 to_power ( C73 -' 1 ) ) ) <= ( R7 + R8 ) & ( R7 + R8 ) <= ( ( 2 to_power ( C73 -' 1 ) ) - 1 ) & ((R7 >= ( 0 ) & R8 < ( 0 )) or (R7 < ( 0 ) & R8 >= ( 0 )))) implies ( Intval ( ( 2sComplement (C73 , R7) ) + ( 2sComplement (C73 , R8) ) ) ) = ( R7 + R8 ));
assume that
L612: ( - ( 2 to_power ( ( C73 + 1 ) -' 1 ) ) ) <= R7
and
L613: R7 <= ( ( 2 to_power ( ( C73 + 1 ) -' 1 ) ) - 1 )
and
L614: ( - ( 2 to_power ( ( C73 + 1 ) -' 1 ) ) ) <= R8
and
L615: R8 <= ( ( 2 to_power ( ( C73 + 1 ) -' 1 ) ) - 1 )
and
L616: ( - ( 2 to_power ( ( C73 + 1 ) -' 1 ) ) ) <= ( R7 + R8 )
and
L617: ( R7 + R8 ) <= ( ( 2 to_power ( ( C73 + 1 ) -' 1 ) ) - 1 )
and
L618: ((R7 >= ( 0 ) & R8 < ( 0 )) or (R7 < ( 0 ) & R8 >= ( 0 )));
set D60 = ( 2sComplement (C73 , R7) );
set D61 = ( 2sComplement (C73 , R8) );
set D62 = ( 2sComplement (( C73 + 1 ) , R7) );
set D63 = ( 2sComplement (( C73 + 1 ) , R8) );
set D64 = ( 2 to_power C73 );
set D65 = ( FALSE );
set D66 = ( TRUE );
L619: ( ( C73 + 1 ) - 1 ) = C73;
L620: ( - D64 ) <= R7 by L619 , L612 , XREAL_0:def 2;
L621: R8 <= ( D64 - 1 ) by L615 , L619 , XREAL_0:def 2;
L622: ((ex B87 being (Element of ( BOOLEAN )) st D62 = ( D60 ^ <* B87 *> )) & (ex B88 being (Element of ( BOOLEAN )) st D63 = ( D61 ^ <* B88 *> ))) by L470;
L623: ( - D64 ) <= R8 by L614 , L619 , XREAL_0:def 2;
L624: R7 <= ( D64 - 1 ) by L613 , L619 , XREAL_0:def 2;
L625:
now
per cases  by L618;
suppose L626: (R7 >= ( 0 ) & R8 < ( 0 ));

L627: ( ( 2 to_power ( C73 + 1 ) ) + ( - ( 2 to_power C73 ) ) ) = ( ( - ( 2 to_power C73 ) ) + ( ( 2 to_power 1 ) * ( 2 to_power C73 ) ) ) by POWER:27
.= ( ( - ( 2 to_power C73 ) ) + ( 2 * ( 2 to_power C73 ) ) ) by POWER:25
.= ( 2 to_power C73 );
L628: ( 2 to_power C73 ) <= ( ( 2 to_power ( C73 + 1 ) ) + R8 ) by L627 , L623 , XREAL_1:6;
reconsider D67 = ( ( 2 to_power ( C73 + 1 ) ) + R8 ) as (Element of ( NAT )) by L628 , INT_1:3;
L629: C73 < ( C73 + 1 ) by XREAL_1:29;
L630: ( 2 to_power C73 ) < ( 2 to_power ( C73 + 1 ) ) by L629 , POWER:39;
L631: ( abs R8 ) = ( - R8 ) by L626 , ABSVALUE:def 1;
L632: ( abs R8 ) <= ( - ( - ( 2 to_power C73 ) ) ) by L631 , L623 , XREAL_1:24;
L633: ( MajP (( C73 + 1 ) , ( abs R8 )) ) = ( C73 + 1 ) by L632 , L630 , L258 , XXREAL_0:2;
L634: D63 = ( ( C73 + 1 ) -BinarySequence ( abs ( ( 2 to_power ( C73 + 1 ) ) + R8 ) ) ) by L633 , L626 , L267
.= ( ( C73 + 1 ) -BinarySequence D67 ) by ABSVALUE:def 1;
L635: ( ( 2 to_power ( C73 + 1 ) ) + R8 ) < ( ( 2 to_power ( C73 + 1 ) ) + ( 0 ) ) by L626 , XREAL_1:8;
reconsider D68 = R7 as (Element of ( NAT )) by L626 , INT_1:3;
L636: D68 < ( 2 to_power C73 ) by L624 , XREAL_1:146 , XXREAL_0:2;
L637: D62 = ( ( C73 + 1 ) -BinarySequence ( abs D68 ) ) by L267
.= ( ( C73 + 1 ) -BinarySequence D68 ) by ABSVALUE:def 1;
L638: ( D62 . ( C73 + 1 ) ) = D65 by L637 , L636 , BINARI_3:26;
L639: ( C73 + ( 0 ) ) < ( C73 + 1 ) by XREAL_1:8;
L640: ( 2 to_power C73 ) < ( 2 to_power ( C73 + 1 ) ) by L639 , POWER:39;
L641: D68 < ( 2 to_power ( C73 + 1 ) ) by L640 , L636 , XXREAL_0:2;
L642: 1 <= ( C73 + 1 ) by NAT_1:11;
L643: ( len D63 ) = ( C73 + 1 ) by CARD_1:def 7;
L644: ( D63 /. ( C73 + 1 ) ) = ( D63 . ( C73 + 1 ) ) by L643 , L642 , FINSEQ_4:15;
L645: ( D63 . ( C73 + 1 ) ) = ( ( ( C73 + 1 ) -BinarySequence ( abs ( ( 2 to_power ( C73 + 1 ) ) + R8 ) ) ) . ( C73 + 1 ) ) by L626 , L633 , L267
.= ( ( ( C73 + 1 ) -BinarySequence D67 ) . ( C73 + 1 ) ) by ABSVALUE:def 1
.= D66 by L635 , L628 , BINARI_3:29;
L646: ( Intval D63 ) = ( ( Absval D63 ) - ( 2 to_power ( C73 + 1 ) ) ) by L645 , L644 , BINARI_2:def 3
.= ( D67 - ( 2 to_power ( C73 + 1 ) ) ) by L635 , L634 , BINARI_3:35
.= R8;
L647: ( len D62 ) = ( C73 + 1 ) by CARD_1:def 7;
L648: ( D62 /. ( C73 + 1 ) ) = ( D62 . ( C73 + 1 ) ) by L647 , L642 , FINSEQ_4:15;
L649: ( Int_add_ovfl (D62 , D63) ) = ( ( ( 'not' D65 ) '&' ( 'not' D66 ) ) '&' ( ( carry (D62 , D63) ) /. ( C73 + 1 ) ) ) by L648 , L638 , L645 , L644 , BINARI_2:def 4
.= D65;
L650: ( Int_add_udfl (D62 , D63) ) = ( ( D65 '&' D66 ) '&' ( 'not' ( ( carry (D62 , D63) ) /. ( C73 + 1 ) ) ) ) by L638 , L645 , L648 , L644 , BINARI_2:def 5
.= D65;
L651: ( Intval D62 ) = ( Absval D62 ) by L638 , L648 , BINARI_2:def 3
.= D68 by L637 , L641 , BINARI_3:35;
L652: ( Intval ( D62 + D63 ) ) = ( ( ( D68 + R8 ) - ( IFEQ (D65 , D65 , ( 0 ) , ( 2 to_power ( C73 + 1 ) )) ) ) + ( IFEQ (D65 , D65 , ( 0 ) , ( 2 to_power ( C73 + 1 ) )) ) ) by L651 , L622 , L646 , L649 , L650 , BINARI_2:12
.= ( ( ( D68 + R8 ) - ( 0 ) ) + ( 0 ) );
thus L653: thesis by L652;
end;
suppose L654: (R7 < ( 0 ) & R8 >= ( 0 ));

L655: ( ( 2 to_power ( C73 + 1 ) ) + ( - ( 2 to_power C73 ) ) ) = ( ( - ( 2 to_power C73 ) ) + ( ( 2 to_power 1 ) * ( 2 to_power C73 ) ) ) by POWER:27
.= ( ( - ( 2 to_power C73 ) ) + ( 2 * ( 2 to_power C73 ) ) ) by POWER:25
.= ( 2 to_power C73 );
L656: ( 2 to_power C73 ) <= ( ( 2 to_power ( C73 + 1 ) ) + R7 ) by L655 , L620 , XREAL_1:6;
reconsider D69 = ( ( 2 to_power ( C73 + 1 ) ) + R7 ) as (Element of ( NAT )) by L656 , INT_1:3;
L657: C73 < ( C73 + 1 ) by XREAL_1:29;
L658: ( 2 to_power C73 ) < ( 2 to_power ( C73 + 1 ) ) by L657 , POWER:39;
L659: ( abs R7 ) = ( - R7 ) by L654 , ABSVALUE:def 1;
L660: ( abs R7 ) <= ( - ( - ( 2 to_power C73 ) ) ) by L659 , L620 , XREAL_1:24;
L661: ( MajP (( C73 + 1 ) , ( abs R7 )) ) = ( C73 + 1 ) by L660 , L658 , L258 , XXREAL_0:2;
L662: D62 = ( ( C73 + 1 ) -BinarySequence ( abs ( ( 2 to_power ( C73 + 1 ) ) + R7 ) ) ) by L661 , L654 , L267
.= ( ( C73 + 1 ) -BinarySequence D69 ) by ABSVALUE:def 1;
L663: ( ( 2 to_power ( C73 + 1 ) ) + R7 ) < ( ( 2 to_power ( C73 + 1 ) ) + ( 0 ) ) by L654 , XREAL_1:8;
reconsider D70 = R8 as (Element of ( NAT )) by L654 , INT_1:3;
L664: D70 < ( 2 to_power C73 ) by L621 , XREAL_1:146 , XXREAL_0:2;
L665: D63 = ( ( C73 + 1 ) -BinarySequence ( abs D70 ) ) by L267
.= ( ( C73 + 1 ) -BinarySequence D70 ) by ABSVALUE:def 1;
L666: ( D63 . ( C73 + 1 ) ) = D65 by L665 , L664 , BINARI_3:26;
L667: ( C73 + ( 0 ) ) < ( C73 + 1 ) by XREAL_1:8;
L668: ( 2 to_power C73 ) < ( 2 to_power ( C73 + 1 ) ) by L667 , POWER:39;
L669: D70 < ( 2 to_power ( C73 + 1 ) ) by L668 , L664 , XXREAL_0:2;
L670: 1 <= ( C73 + 1 ) by NAT_1:11;
L671: ( len D62 ) = ( C73 + 1 ) by CARD_1:def 7;
L672: ( D62 /. ( C73 + 1 ) ) = ( D62 . ( C73 + 1 ) ) by L671 , L670 , FINSEQ_4:15;
L673: ( D62 . ( C73 + 1 ) ) = ( ( ( C73 + 1 ) -BinarySequence ( abs ( ( 2 to_power ( C73 + 1 ) ) + R7 ) ) ) . ( C73 + 1 ) ) by L654 , L661 , L267
.= ( ( ( C73 + 1 ) -BinarySequence D69 ) . ( C73 + 1 ) ) by ABSVALUE:def 1
.= D66 by L663 , L656 , BINARI_3:29;
L674: ( Intval D62 ) = ( ( Absval D62 ) - ( 2 to_power ( C73 + 1 ) ) ) by L673 , L672 , BINARI_2:def 3
.= ( D69 - ( 2 to_power ( C73 + 1 ) ) ) by L663 , L662 , BINARI_3:35
.= R7;
L675: ( len D63 ) = ( C73 + 1 ) by CARD_1:def 7;
L676: ( D63 /. ( C73 + 1 ) ) = ( D63 . ( C73 + 1 ) ) by L675 , L670 , FINSEQ_4:15;
L677: ( Int_add_ovfl (D62 , D63) ) = ( ( ( 'not' D66 ) '&' ( 'not' D65 ) ) '&' ( ( carry (D62 , D63) ) /. ( C73 + 1 ) ) ) by L676 , L666 , L673 , L672 , BINARI_2:def 4
.= D65;
L678: ( Int_add_udfl (D62 , D63) ) = ( ( D66 '&' D65 ) '&' ( 'not' ( ( carry (D62 , D63) ) /. ( C73 + 1 ) ) ) ) by L666 , L673 , L676 , L672 , BINARI_2:def 5
.= D65;
L679: ( Intval D63 ) = ( Absval D63 ) by L666 , L676 , BINARI_2:def 3
.= D70 by L665 , L669 , BINARI_3:35;
L680: ( Intval ( D62 + D63 ) ) = ( ( ( R7 + D70 ) - ( IFEQ (D65 , D65 , ( 0 ) , ( 2 to_power ( C73 + 1 ) )) ) ) + ( IFEQ (D65 , D65 , ( 0 ) , ( 2 to_power ( C73 + 1 ) )) ) ) by L679 , L622 , L674 , L677 , L678 , BINARI_2:12
.= ( ( ( R7 + D70 ) - ( 0 ) ) + ( 0 ) );
thus L681: thesis by L680;
end;
end;
thus L683: thesis by L625;
end;
L684: S7[ 1 ]
proof
L685: ( abs ( - 1 ) ) = ( - ( - 1 ) ) by ABSVALUE:def 1
.= 1;
L686: (( 2 to_power 1 ) = 2 & (for B89 being Nat holds ((( 2 to_power B89 ) >= 1 & B89 >= 1) implies B89 >= 1))) by POWER:25;
L687: ( MajP (1 , ( abs ( - 1 ) )) ) = 1 by L686 , L685 , L225;
L688: ( 2sComplement (1 , ( - 1 )) ) = ( 1 -BinarySequence ( abs ( ( 2 to_power 1 ) + ( - 1 ) ) ) ) by L687 , L267
.= ( 1 -BinarySequence ( abs ( 2 + ( - 1 ) ) ) ) by POWER:25
.= ( 1 -BinarySequence 1 ) by ABSVALUE:def 1
.= ( ( ( 0 ) + 1 ) -BinarySequence ( 2 to_power ( 0 ) ) ) by POWER:24
.= ( ( 0* ( 0 ) ) ^ <* 1 *> ) by BINARI_3:28
.= <* ( TRUE ) *> by FINSEQ_1:34;
assume that
L689: ( - ( 2 to_power ( 1 -' 1 ) ) ) <= R7
and
L690: R7 <= ( ( 2 to_power ( 1 -' 1 ) ) - 1 )
and
L691: ( - ( 2 to_power ( 1 -' 1 ) ) ) <= R8
and
L692: R8 <= ( ( 2 to_power ( 1 -' 1 ) ) - 1 )
and
L693: ( - ( 2 to_power ( 1 -' 1 ) ) ) <= ( R7 + R8 )
and
L694: ( R7 + R8 ) <= ( ( 2 to_power ( 1 -' 1 ) ) - 1 )
and
L695: ((R7 >= ( 0 ) & R8 < ( 0 )) or (R7 < ( 0 ) & R8 >= ( 0 )));
L696: ( 1 -' 1 ) = ( 1 - 1 ) by XREAL_0:def 2
.= ( 0 );
L697: R7 <= ( 1 - 1 ) by L696 , L690 , POWER:24;
L698: R8 <= ( 1 - 1 ) by L692 , L696 , POWER:24;
L699: ( - 1 ) <= R8 by L691 , L696 , POWER:24;
L700: ( 2sComplement (1 , ( 0 )) ) = ( 1 -BinarySequence ( abs ( 0 ) ) ) by L267
.= ( 1 -BinarySequence ( 0 ) ) by ABSVALUE:def 1
.= ( 0* 1 ) by BINARI_3:25
.= <* ( FALSE ) *> by FINSEQ_2:59;
L701: ( - 1 ) <= R7 by L689 , L696 , POWER:24;
L702:
now
per cases  by L695;
suppose L703: (R7 >= ( 0 ) & R8 < ( 0 ));

L704: R8 <= ( - 1 ) by L703 , INT_1:8;
L705: R8 = ( - 1 ) by L704 , L699 , XXREAL_0:1;
L706: R7 = ( 0 ) by L697 , L703;
thus L707: thesis by L706 , L700 , L688 , L705 , L190 , BINARI_3:17;
end;
suppose L708: (R7 < ( 0 ) & R8 >= ( 0 ));

L709: R7 <= ( - 1 ) by L708 , INT_1:8;
L710: R7 = ( - 1 ) by L709 , L701 , XXREAL_0:1;
L711: R8 = ( 0 ) by L698 , L708;
thus L712: thesis by L711 , L700 , L688 , L710 , L190 , BINARI_3:17;
end;
end;
thus L714: thesis by L702;
end;
thus L715: (for B90 being non  empty Nat holds S7[ B90 ]) from NAT_1:sch 10(L684 , L610);
end;
