:: Full Adder Circuit. Part { I }
::  by Grzegorz Bancerek and Yatsuka Nakamura
::
:: Received August 10, 1995
:: Copyright (c) 1995-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, XBOOLE_0, CARD_1, NAT_1, SUBSET_1, ARYTM_3, RELAT_1,
      FUNCT_1, FINSEQ_1, CIRCCOMB, FINSEQ_2, MSUALG_1, PARTFUN1, MSAFREE2,
      FUNCT_4, TARSKI, STRUCT_0, MARGREL1, XBOOLEAN, CIRCUIT1, FSM_1, CIRCUIT2,
      CARD_3, GLIB_000, LATTICES, MCART_1, FINSET_1, CLASSES1, FACIRC_1;
 notations TARSKI, XBOOLE_0, ENUMSET1,
      XTUPLE_0, SUBSET_1, NUMBERS, XCMPLX_0, MCART_1,
      RELAT_1, STRUCT_0, FUNCT_1, FUNCT_2, FINSEQ_1, FINSET_1, FINSEQ_2,
      FUNCT_4, MARGREL1, BINARITH, CARD_3, CLASSES1, PARTFUN1, MSUALG_1,
      MSAFREE2, CIRCUIT1, CIRCUIT2, CIRCCOMB, XXREAL_0, ORDINAL1, NAT_1;
 constructors ENUMSET1, XXREAL_0, NAT_1, CLASSES1, BINARITH, CIRCUIT1,
      CIRCUIT2, CIRCCOMB, SEQ_1, RELSET_1, BINOP_1, WELLORD2, DOMAIN_1,
      XTUPLE_0;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, XXREAL_0, FINSEQ_1,
      FINSEQ_2, CARD_3, STRUCT_0, MSUALG_1, CIRCCOMB, NAT_1, XCMPLX_0,
      MSAFREE2, MARGREL1, FINSET_1, CARD_1, FUNCT_4, XTUPLE_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, RELAT_1, MSAFREE2, CIRCUIT2, CIRCCOMB, XBOOLE_0, MARGREL1,
      XTUPLE_0;
 theorems TARSKI, AXIOMS, ENUMSET1, MCART_1, RELAT_1, FUNCT_1, FUNCT_2,
      FUNCT_4, ORDINAL1, FINSEQ_1, FINSEQ_2, MSUALG_1, MSAFREE2, CIRCUIT1,
      CIRCUIT2, CIRCCOMB, XBOOLE_0, XBOOLE_1, CLASSES1, CARD_1, XTUPLE_0;
 schemes NAT_1, RECDEF_1, FUNCT_2;

begin
registration
cluster  pair -> non  empty for set;
coherence
proof
let C1 being set;
given C2 , C3 being set such that
L1: C1 = [ C2 , C3 ];

thus L2: thesis by L1;
end;
end;
registration
cluster non  pair for set;
existence
proof
take ( {} );
let C4 , C5 being set;
thus L4: thesis;
end;
end;
registration
cluster  -> non  pair for Nat;
coherence
proof
let C6 being Nat;
given C7 , C8 being set such that
L6: C6 = [ C7 , C8 ];

L7: C6 = { B1 where B1 is (Element of ( NAT )) : B1 < C6 } by AXIOMS:4;
L8: ( 0 ) in C6 by L7 , L6;
thus L9: contradiction by L8 , L6 , TARSKI:def 2;
end;
end;
definition
canceled 1;
let C9 being set;
attr C9 is  with_pair
means
:L11: (ex B2 being  pair set st B2 in C9);
end;
notation
let C10 being set;
antonym C10 is  without_pairs for C10 is  with_pair;
end;
registration
cluster  empty ->  without_pairs for set;
coherence
proof
let C11 being set;
assume L14: C11 is  empty;
let C12 being  pair set;
thus L15: thesis by L14;
end;
let C13 being non  pair set;
cluster { C13 } ->  without_pairs;
coherence
proof
let C14 being  pair set;
assume L16: C14 in { C13 };
thus L17: contradiction by L16 , TARSKI:def 1;
end;
let C15 being non  pair set;
cluster { C13 , C15 } ->  without_pairs;
coherence
proof
let C16 being  pair set;
assume L18: C16 in { C13 , C15 };
thus L19: contradiction by L18 , TARSKI:def 2;
end;
let C17 being non  pair set;
cluster { C13 , C15 , C17 } ->  without_pairs;
coherence
proof
let C18 being  pair set;
assume L20: C18 in { C13 , C15 , C17 };
thus L21: contradiction by L20 , ENUMSET1:def 1;
end;
end;
registration
cluster  without_pairs for non  empty non  empty non  empty non  empty set;
existence
proof
set D1 = the non  pair set;
take { D1 };
thus L23: thesis;
end;
end;
registration
let C19 , C20 being  without_pairs set;
cluster ( C19 \/ C20 ) ->  without_pairs;
coherence
proof
let C21 being  pair set;
assume L25: C21 in ( C19 \/ C20 );
L26: (C21 in C19 or C21 in C20) by L25 , XBOOLE_0:def 3;
thus L27: contradiction by L26 , L11;
end;
end;
registration
let C22 being  without_pairs set;
let C23 being set;
cluster ( C22 \ C23 ) ->  without_pairs;
coherence
proof
let C24 being  pair set;
assume L29: C24 in ( C22 \ C23 );
thus L30: contradiction by L29 , L11;
end;
cluster ( C22 /\ C23 ) ->  without_pairs;
coherence
proof
let C25 being  pair set;
assume L31: C25 in ( C22 /\ C23 );
L32: C25 in C22 by L31 , XBOOLE_0:def 4;
thus L33: contradiction by L32 , L11;
end;
cluster ( C23 /\ C22 ) ->  without_pairs;
coherence;
end;
registration
let C26 being  pair set;
cluster { C26 } ->  Relation-like;
coherence
proof
let C27 being set;
assume L35: C27 in { C26 };
L36: C27 = C26 by L35 , TARSKI:def 1;
thus L37: thesis by L36 , XTUPLE_0:def 1;
end;
let C28 being  pair set;
cluster { C26 , C28 } ->  Relation-like;
coherence
proof
let C29 being set;
assume L38: C29 in { C26 , C28 };
L39: (C29 = C26 or C29 = C28) by L38 , TARSKI:def 2;
thus L40: thesis by L39 , XTUPLE_0:def 1;
end;
let C30 being  pair set;
cluster { C26 , C28 , C30 } ->  Relation-like;
coherence
proof
let C31 being set;
assume L41: C31 in { C26 , C28 , C30 };
L42: (C31 = C26 or C31 = C28 or C31 = C30) by L41 , ENUMSET1:def 1;
thus L43: thesis by L42 , XTUPLE_0:def 1;
end;
end;
registration
cluster  without_pairs  Relation-like ->  empty for set;
coherence
proof
let C32 being set;
assume L45: (not (ex B3 being  pair set st B3 in C32));
assume L46: (for B4 being set holds (B4 in C32 implies (ex B5 , B6 being set st B4 = [ B5 , B6 ])));
assume L47: C32 is non  empty;
reconsider D2 = C32 as non  empty set by L47;
set D3 = the (Element of D2);
L48: (ex B7 , B8 being set st D3 = [ B7 , B8 ]) by L46;
thus L49: contradiction by L48 , L45;
end;
end;
definition
let C33 being Function;
attr C33 is  nonpair-yielding
means
(for B9 being set holds (B9 in ( dom C33 ) implies ( C33 . B9 ) is non  pair));
end;
registration
let C34 being non  pair set;
cluster <* C34 *> ->  nonpair-yielding;
coherence
proof
let C35 being set;
assume L52: C35 in ( dom <* C34 *> );
L53: ( <* C34 *> . C35 ) in ( rng <* C34 *> ) by L52 , FUNCT_1:def 3;
L54: ( <* C34 *> . C35 ) in { C34 } by L53 , FINSEQ_1:39;
thus L55: thesis by L54 , TARSKI:def 1;
end;
let C36 being non  pair set;
cluster <* C34 , C36 *> ->  nonpair-yielding;
coherence
proof
let C37 being set;
assume L56: C37 in ( dom <* C34 , C36 *> );
L57: ( <* C34 , C36 *> . C37 ) in ( rng <* C34 , C36 *> ) by L56 , FUNCT_1:def 3;
L58: ( <* C34 , C36 *> . C37 ) in { C34 , C36 } by L57 , FINSEQ_2:127;
thus L59: thesis by L58 , TARSKI:def 2;
end;
let C38 being non  pair set;
cluster <* C34 , C36 , C38 *> ->  nonpair-yielding;
coherence
proof
let C39 being set;
assume L60: C39 in ( dom <* C34 , C36 , C38 *> );
L61: ( <* C34 , C36 , C38 *> . C39 ) in ( rng <* C34 , C36 , C38 *> ) by L60 , FUNCT_1:def 3;
L62: ( <* C34 , C36 , C38 *> . C39 ) in { C34 , C36 , C38 } by L61 , FINSEQ_2:128;
thus L63: thesis by L62 , ENUMSET1:def 1;
end;
end;
theorem
L65: (for B10 being Function holds (B10 is  nonpair-yielding implies ( rng B10 ) is  without_pairs))
proof
let C40 being Function;
assume L66: (for B11 being set holds (B11 in ( dom C40 ) implies ( C40 . B11 ) is non  pair));
let C41 being  pair set;
assume L67: C41 in ( rng C40 );
L68: (ex B12 being set st (B12 in ( dom C40 ) & C41 = ( C40 . B12 ))) by L67 , FUNCT_1:def 3;
thus L69: thesis by L68 , L66;
end;
registration
let C42 being Nat;
cluster  one-to-one  nonpair-yielding for (FinSeqLen of C42);
existence
proof
reconsider D4 = ( id ( Seg C42 ) ) as FinSequence by FINSEQ_2:48;
L70: ( len D4 ) = ( len ( idseq C42 ) ) by FINSEQ_2:def 1
.= C42 by CARD_1:def 7;
reconsider D5 = D4 as (FinSeqLen of C42) by L70 , CARD_1:def 7;
take D5;
thus L71: D5 is  one-to-one;
let C43 being set;
assume L72: C43 in ( dom D5 );
L73: C43 in ( Seg C42 ) by L72 , RELAT_1:45;
thus L74: thesis by L73 , FUNCT_1:17;
end;
end;
registration
cluster  one-to-one  nonpair-yielding for FinSequence;
existence
proof
set D6 = the Nat;
set D7 = the  one-to-one  nonpair-yielding (FinSeqLen of D6);
take D7;
thus L76: thesis;
end;
end;
registration
let C44 being  nonpair-yielding Function;
cluster ( rng C44 ) ->  without_pairs;
coherence by L65;
end;
theorem
L79: (for B13 , B14 being non  empty ManySortedSign holds ((B13 tolerates B14 & ( InnerVertices B13 ) is Relation & ( InnerVertices B14 ) is Relation) implies ( InnerVertices ( B13 +* B14 ) ) is Relation))
proof
let C45 , C46 being non  empty ManySortedSign;
assume L80: C45 tolerates C46;
assume L81: (( InnerVertices C45 ) is Relation & ( InnerVertices C46 ) is Relation);
reconsider D8 = ( InnerVertices C45 ) , D9 = ( InnerVertices C46 ) as Relation by L81;
L82: ( D8 \/ D9 ) is Relation;
thus L83: thesis by L82 , L80 , CIRCCOMB:11;
end;
theorem
L84: (for B15 , B16 being  unsplit  gate`1=arity non  empty ManySortedSign holds ((( InnerVertices B15 ) is Relation & ( InnerVertices B16 ) is Relation) implies ( InnerVertices ( B15 +* B16 ) ) is Relation)) by L79 , CIRCCOMB:47;
theorem
L85: (for B17 , B18 being non  empty ManySortedSign holds ((B17 tolerates B18 & ( InnerVertices B18 ) misses ( InputVertices B17 )) implies (( InputVertices B17 ) c= ( InputVertices ( B17 +* B18 ) ) & ( InputVertices ( B17 +* B18 ) ) = ( ( InputVertices B17 ) \/ ( ( InputVertices B18 ) \ ( InnerVertices B17 ) ) ))))
proof
let C47 , C48 being non  empty ManySortedSign;
set D10 = ( C47 +* C48 );
set D11 = (the ResultSort of D10);
set D12 = (the ResultSort of C47);
set D13 = (the ResultSort of C48);
assume that
L86: C47 tolerates C48
and
L87: ( InnerVertices C48 ) misses ( InputVertices C47 );
L88: ( InnerVertices D10 ) = ( rng D11 );
L89: (( InnerVertices C47 ) = ( rng D12 ) & ( InnerVertices C48 ) = ( rng D13 ));
L90: ( rng D11 ) = ( ( rng D12 ) \/ ( rng D13 ) ) by L89 , L86 , L88 , CIRCCOMB:11;
L91: (the carrier of D10) = ( (the carrier of C47) \/ (the carrier of C48) ) by CIRCCOMB:def 2;
thus L92:now
let C49 being set;
assume L93: C49 in ( InputVertices C47 );
L94: ((not C49 in ( rng D12 )) & (not C49 in ( rng D13 ))) by L93 , L87 , XBOOLE_0:3 , XBOOLE_0:def 5;
L95: (not C49 in ( rng D11 )) by L94 , L90 , XBOOLE_0:def 3;
L96: C49 in (the carrier of D10) by L91 , L93 , XBOOLE_0:def 3;
thus L97: C49 in ( InputVertices D10 ) by L96 , L95 , XBOOLE_0:def 5;
end;
L98: ( InputVertices D10 ) c= ( ( InputVertices C47 ) \/ ( InputVertices C48 ) ) by L86 , CIRCCOMB:11;
thus L99:now
let C50 being set;
assume L100: C50 in ( InputVertices ( C47 +* C48 ) );
L101: (not C50 in ( rng D11 )) by L100 , XBOOLE_0:def 5;
L102: (C50 in ( InputVertices C47 ) or (C50 in ( InputVertices C48 ) & (not C50 in ( InnerVertices C47 )))) by L101 , L90 , L98 , L100 , XBOOLE_0:def 3;
L103: (C50 in ( InputVertices C47 ) or C50 in ( ( InputVertices C48 ) \ ( InnerVertices C47 ) )) by L102 , XBOOLE_0:def 5;
thus L104: C50 in ( ( InputVertices C47 ) \/ ( ( InputVertices C48 ) \ ( InnerVertices C47 ) ) ) by L103 , XBOOLE_0:def 3;
end;
let C51 being set;
assume L105: C51 in ( ( InputVertices C47 ) \/ ( ( InputVertices C48 ) \ ( InnerVertices C47 ) ) );
L106: (C51 in ( InputVertices C47 ) or C51 in ( ( InputVertices C48 ) \ ( rng D12 ) )) by L105 , XBOOLE_0:def 3;
L107: C51 in (the carrier of D10) by L106 , L91 , XBOOLE_0:def 3;
L108: ((C51 in ( InputVertices C47 ) & (not C51 in ( rng D13 ))) or (C51 in ( InputVertices C48 ) & (not C51 in ( rng D12 )))) by L87 , L106 , XBOOLE_0:3 , XBOOLE_0:def 5;
L109: (not C51 in ( rng D13 )) by L108 , XBOOLE_0:def 5;
L110: (not C51 in ( rng D12 )) by L106 , XBOOLE_0:def 5;
L111: (not C51 in ( rng D11 )) by L110 , L90 , L109 , XBOOLE_0:def 3;
thus L112: thesis by L111 , L107 , XBOOLE_0:def 5;
end;
theorem
L113: (for B19 , B20 being set holds ((B19 is  without_pairs & B20 is Relation) implies B19 misses B20))
proof
let C52 , C53 being set;
assume L114: (for B21 being  pair set holds (not B21 in C52));
assume L115: C53 is Relation;
L116:
now
let C54 being set;
assume L117: C54 in C52;
L118: (not (ex B22 , B23 being set st C54 = [ B22 , B23 ])) by L117 , L114;
thus L119: (not C54 in C53) by L118 , L115 , RELAT_1:def 1;
end;
thus L120: thesis by L116 , XBOOLE_0:3;
end;
theorem
L121: (for B24 , B25 being  unsplit  gate`1=arity non  empty ManySortedSign holds ((( InputVertices B24 ) is  without_pairs & ( InnerVertices B25 ) is Relation) implies (( InputVertices B24 ) c= ( InputVertices ( B24 +* B25 ) ) & ( InputVertices ( B24 +* B25 ) ) = ( ( InputVertices B24 ) \/ ( ( InputVertices B25 ) \ ( InnerVertices B24 ) ) ))))
proof
let C55 , C56 being  unsplit  gate`1=arity non  empty ManySortedSign;
assume L122: (( InputVertices C55 ) is  without_pairs & ( InnerVertices C56 ) is Relation);
L123: (C55 tolerates C56 & ( InnerVertices C56 ) misses ( InputVertices C55 )) by L122 , L113 , CIRCCOMB:47;
thus L124: thesis by L123 , L85;
end;
theorem
L125: (for B26 , B27 being  unsplit  gate`1=arity non  empty ManySortedSign holds ((( InputVertices B26 ) is  without_pairs & ( InnerVertices B26 ) is Relation & ( InputVertices B27 ) is  without_pairs & ( InnerVertices B27 ) is Relation) implies ( InputVertices ( B26 +* B27 ) ) = ( ( InputVertices B26 ) \/ ( InputVertices B27 ) )))
proof
let C57 , C58 being  unsplit  gate`1=arity non  empty ManySortedSign;
assume L126: (( InputVertices C57 ) is  without_pairs & ( InnerVertices C57 ) is Relation & ( InputVertices C58 ) is  without_pairs & ( InnerVertices C58 ) is Relation);
L127: (( InputVertices ( C57 +* C58 ) ) = ( ( InputVertices C57 ) \/ ( ( InputVertices C58 ) \ ( InnerVertices C57 ) ) ) & ( InnerVertices C57 ) misses ( InputVertices C58 )) by L126 , L113 , L121;
thus L128: thesis by L127 , XBOOLE_1:83;
end;
theorem
L129: (for B28 , B29 being non  empty ManySortedSign holds ((B28 tolerates B29 & ( InputVertices B28 ) is  without_pairs & ( InputVertices B29 ) is  without_pairs) implies ( InputVertices ( B28 +* B29 ) ) is  without_pairs))
proof
let C59 , C60 being non  empty ManySortedSign;
assume L130: C59 tolerates C60;
L131: ( InputVertices ( C59 +* C60 ) ) c= ( ( InputVertices C59 ) \/ ( InputVertices C60 ) ) by L130 , CIRCCOMB:11;
assume L132: (for B30 being  pair set holds (not B30 in ( InputVertices C59 )));
assume L133: (for B31 being  pair set holds (not B31 in ( InputVertices C60 )));
let C61 being  pair set;
assume L134: C61 in ( InputVertices ( C59 +* C60 ) );
L135: (C61 in ( InputVertices C59 ) or C61 in ( InputVertices C60 )) by L134 , L131 , XBOOLE_0:def 3;
thus L136: contradiction by L135 , L132 , L133;
end;
theorem
L137: (for B32 , B33 being  unsplit  gate`1=arity non  empty ManySortedSign holds ((( InputVertices B32 ) is  without_pairs & ( InputVertices B33 ) is  without_pairs) implies ( InputVertices ( B32 +* B33 ) ) is  without_pairs)) by L129 , CIRCCOMB:47;
begin
definition
let C62 being Nat;
let C63 being non  empty set;
mode Tuple of C62 , C63
 is (Element of ( C62 -tuples_on C63 ));
end;
scheme 2AryBooleEx { F1(set , set) -> (Element of ( BOOLEAN )) } : (ex B34 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B35 , B36 being (Element of ( BOOLEAN )) holds ( B34 . <* B35 , B36 *> ) = F1(B35 , B36)))
proof
deffunc H1((Tuple of 2 , ( BOOLEAN ))) = F1(( $1 . 1 ) , ( $1 . 2 ));
consider C64 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) such that L139: (for B37 being (Tuple of 2 , ( BOOLEAN )) holds ( C64 . B37 ) = H1(B37)) from FUNCT_2:sch 4;
thus L140:now
take D14 = C64;
let C65 , C66 being (Element of ( BOOLEAN ));
reconsider D15 = <* C65 , C66 *> as (Tuple of 2 , ( BOOLEAN )) by FINSEQ_2:101;
thus L141: ( D14 . <* C65 , C66 *> ) = F1(( D15 . 1 ) , ( D15 . 2 )) by L139
.= F1(C65 , ( D15 . 2 )) by FINSEQ_1:44
.= F1(C65 , C66) by FINSEQ_1:44;
end;
end;
scheme 2AryBooleUniq { F2(set , set) -> (Element of ( BOOLEAN )) } : (for B38 , B39 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B40 , B41 being (Element of ( BOOLEAN )) holds ( B38 . <* B40 , B41 *> ) = F2(B40 , B41)) & (for B42 , B43 being (Element of ( BOOLEAN )) holds ( B39 . <* B42 , B43 *> ) = F2(B42 , B43))) implies B38 = B39))
proof
let C67 , C68 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
assume that
L141: (for B44 , B45 being (Element of ( BOOLEAN )) holds ( C67 . <* B44 , B45 *> ) = F2(B44 , B45))
and
L142: (for B46 , B47 being (Element of ( BOOLEAN )) holds ( C68 . <* B46 , B47 *> ) = F2(B46 , B47));
L143:
now
let C69 being (Tuple of 2 , ( BOOLEAN ));
consider C70 , C71 being (Element of ( BOOLEAN )) such that L144: C69 = <* C70 , C71 *> by FINSEQ_2:100;
thus L145: ( C67 . C69 ) = F2(C70 , C71) by L141 , L144
.= ( C68 . C69 ) by L142 , L144;
end;
thus L146: thesis by L143 , FUNCT_2:63;
end;
scheme 2AryBooleDef { F3(set , set) -> (Element of ( BOOLEAN )) } : ((ex B48 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B49 , B50 being (Element of ( BOOLEAN )) holds ( B48 . <* B49 , B50 *> ) = F3(B49 , B50))) & (for B51 , B52 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B53 , B54 being (Element of ( BOOLEAN )) holds ( B51 . <* B53 , B54 *> ) = F3(B53 , B54)) & (for B55 , B56 being (Element of ( BOOLEAN )) holds ( B52 . <* B55 , B56 *> ) = F3(B55 , B56))) implies B51 = B52)))
proof
deffunc H2((Tuple of 2 , ( BOOLEAN ))) = F3(( $1 . 1 ) , ( $1 . 2 ));
consider C72 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) such that L147: (for B57 being (Tuple of 2 , ( BOOLEAN )) holds ( C72 . B57 ) = H2(B57)) from FUNCT_2:sch 4;
thus L148:now
take D16 = C72;
let C73 , C74 being (Element of ( BOOLEAN ));
reconsider D17 = <* C73 , C74 *> as (Tuple of 2 , ( BOOLEAN )) by FINSEQ_2:101;
thus L149: ( D16 . <* C73 , C74 *> ) = F3(( D17 . 1 ) , ( D17 . 2 )) by L147
.= F3(C73 , ( D17 . 2 )) by FINSEQ_1:44
.= F3(C73 , C74) by FINSEQ_1:44;
end;
let C75 , C76 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
assume that
L150: (for B58 , B59 being (Element of ( BOOLEAN )) holds ( C75 . <* B58 , B59 *> ) = F3(B58 , B59))
and
L151: (for B60 , B61 being (Element of ( BOOLEAN )) holds ( C76 . <* B60 , B61 *> ) = F3(B60 , B61));
L152:
now
let C77 being (Tuple of 2 , ( BOOLEAN ));
consider C78 , C79 being (Element of ( BOOLEAN )) such that L153: C77 = <* C78 , C79 *> by FINSEQ_2:100;
thus L154: ( C75 . C77 ) = F3(C78 , C79) by L150 , L153
.= ( C76 . C77 ) by L151 , L153;
end;
thus L155: thesis by L152 , FUNCT_2:63;
end;
scheme 3AryBooleEx { F4(set , set , set) -> (Element of ( BOOLEAN )) } : (ex B62 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B63 , B64 , B65 being (Element of ( BOOLEAN )) holds ( B62 . <* B63 , B64 , B65 *> ) = F4(B63 , B64 , B65)))
proof
deffunc H3((Tuple of 3 , ( BOOLEAN ))) = F4(( $1 . 1 ) , ( $1 . 2 ) , ( $1 . 3 ));
consider C80 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) such that L156: (for B66 being (Tuple of 3 , ( BOOLEAN )) holds ( C80 . B66 ) = H3(B66)) from FUNCT_2:sch 4;
thus L157:now
take D18 = C80;
let C81 , C82 , C83 being (Element of ( BOOLEAN ));
reconsider D19 = <* C81 , C82 , C83 *> as (Tuple of 3 , ( BOOLEAN )) by FINSEQ_2:104;
thus L158: ( D18 . <* C81 , C82 , C83 *> ) = F4(( D19 . 1 ) , ( D19 . 2 ) , ( D19 . 3 )) by L156
.= F4(C81 , ( D19 . 2 ) , ( D19 . 3 )) by FINSEQ_1:45
.= F4(C81 , C82 , ( D19 . 3 )) by FINSEQ_1:45
.= F4(C81 , C82 , C83) by FINSEQ_1:45;
end;
end;
scheme 3AryBooleUniq { F5(set , set , set) -> (Element of ( BOOLEAN )) } : (for B67 , B68 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B69 , B70 , B71 being (Element of ( BOOLEAN )) holds ( B67 . <* B69 , B70 , B71 *> ) = F5(B69 , B70 , B71)) & (for B72 , B73 , B74 being (Element of ( BOOLEAN )) holds ( B68 . <* B72 , B73 , B74 *> ) = F5(B72 , B73 , B74))) implies B67 = B68))
proof
let C84 , C85 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
assume that
L158: (for B75 , B76 , B77 being (Element of ( BOOLEAN )) holds ( C84 . <* B75 , B76 , B77 *> ) = F5(B75 , B76 , B77))
and
L159: (for B78 , B79 , B80 being (Element of ( BOOLEAN )) holds ( C85 . <* B78 , B79 , B80 *> ) = F5(B78 , B79 , B80));
L160:
now
let C86 being (Tuple of 3 , ( BOOLEAN ));
consider C87 , C88 , C89 being (Element of ( BOOLEAN )) such that L161: C86 = <* C87 , C88 , C89 *> by FINSEQ_2:103;
thus L162: ( C84 . C86 ) = F5(C87 , C88 , C89) by L158 , L161
.= ( C85 . C86 ) by L159 , L161;
end;
thus L163: thesis by L160 , FUNCT_2:63;
end;
scheme 3AryBooleDef { F6(set , set , set) -> (Element of ( BOOLEAN )) } : ((ex B81 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B82 , B83 , B84 being (Element of ( BOOLEAN )) holds ( B81 . <* B82 , B83 , B84 *> ) = F6(B82 , B83 , B84))) & (for B85 , B86 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B87 , B88 , B89 being (Element of ( BOOLEAN )) holds ( B85 . <* B87 , B88 , B89 *> ) = F6(B87 , B88 , B89)) & (for B90 , B91 , B92 being (Element of ( BOOLEAN )) holds ( B86 . <* B90 , B91 , B92 *> ) = F6(B90 , B91 , B92))) implies B85 = B86)))
proof
deffunc H4((Tuple of 3 , ( BOOLEAN ))) = F6(( $1 . 1 ) , ( $1 . 2 ) , ( $1 . 3 ));
consider C90 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) such that L164: (for B93 being (Tuple of 3 , ( BOOLEAN )) holds ( C90 . B93 ) = H4(B93)) from FUNCT_2:sch 4;
thus L165:now
take D20 = C90;
let C91 , C92 , C93 being (Element of ( BOOLEAN ));
reconsider D21 = <* C91 , C92 , C93 *> as (Tuple of 3 , ( BOOLEAN )) by FINSEQ_2:104;
thus L166: ( D20 . <* C91 , C92 , C93 *> ) = F6(( D21 . 1 ) , ( D21 . 2 ) , ( D21 . 3 )) by L164
.= F6(C91 , ( D21 . 2 ) , ( D21 . 3 )) by FINSEQ_1:45
.= F6(C91 , C92 , ( D21 . 3 )) by FINSEQ_1:45
.= F6(C91 , C92 , C93) by FINSEQ_1:45;
end;
let C94 , C95 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
assume that
L167: (for B94 , B95 , B96 being (Element of ( BOOLEAN )) holds ( C94 . <* B94 , B95 , B96 *> ) = F6(B94 , B95 , B96))
and
L168: (for B97 , B98 , B99 being (Element of ( BOOLEAN )) holds ( C95 . <* B97 , B98 , B99 *> ) = F6(B97 , B98 , B99));
L169:
now
let C96 being (Tuple of 3 , ( BOOLEAN ));
consider C97 , C98 , C99 being (Element of ( BOOLEAN )) such that L170: C96 = <* C97 , C98 , C99 *> by FINSEQ_2:103;
thus L171: ( C94 . C96 ) = F6(C97 , C98 , C99) by L167 , L170
.= ( C95 . C96 ) by L168 , L170;
end;
thus L172: thesis by L169 , FUNCT_2:63;
end;
definition
func 'xor' -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L173: (for B100 , B101 being (Element of ( BOOLEAN )) holds ( it . <* B100 , B101 *> ) = ( B100 'xor' B101 ));
correctness
proof
deffunc H5((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( $1 'xor' $2 );
L174: ((ex B102 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B103 , B104 being (Element of ( BOOLEAN )) holds ( B102 . <* B103 , B104 *> ) = H5(B103 , B104))) & (for B105 , B106 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B107 , B108 being (Element of ( BOOLEAN )) holds ( B105 . <* B107 , B108 *> ) = H5(B107 , B108)) & (for B109 , B110 being (Element of ( BOOLEAN )) holds ( B106 . <* B109 , B110 *> ) = H5(B109 , B110))) implies B105 = B106))) from 2AryBooleDef;
thus L175: thesis by L174;
end;
func 'or' -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L176: (for B111 , B112 being (Element of ( BOOLEAN )) holds ( it . <* B111 , B112 *> ) = ( B111 'or' B112 ));
correctness
proof
deffunc H6((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( $1 'or' $2 );
L177: ((ex B113 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B114 , B115 being (Element of ( BOOLEAN )) holds ( B113 . <* B114 , B115 *> ) = H6(B114 , B115))) & (for B116 , B117 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B118 , B119 being (Element of ( BOOLEAN )) holds ( B116 . <* B118 , B119 *> ) = H6(B118 , B119)) & (for B120 , B121 being (Element of ( BOOLEAN )) holds ( B117 . <* B120 , B121 *> ) = H6(B120 , B121))) implies B116 = B117))) from 2AryBooleDef;
thus L178: thesis by L177;
end;
func '&' -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L179: (for B122 , B123 being (Element of ( BOOLEAN )) holds ( it . <* B122 , B123 *> ) = ( B122 '&' B123 ));
correctness
proof
deffunc H7((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( $1 '&' $2 );
L180: ((ex B124 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B125 , B126 being (Element of ( BOOLEAN )) holds ( B124 . <* B125 , B126 *> ) = H7(B125 , B126))) & (for B127 , B128 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B129 , B130 being (Element of ( BOOLEAN )) holds ( B127 . <* B129 , B130 *> ) = H7(B129 , B130)) & (for B131 , B132 being (Element of ( BOOLEAN )) holds ( B128 . <* B131 , B132 *> ) = H7(B131 , B132))) implies B127 = B128))) from 2AryBooleDef;
thus L181: thesis by L180;
end;
end;
definition
func or3 -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L183: (for B133 , B134 , B135 being (Element of ( BOOLEAN )) holds ( it . <* B133 , B134 , B135 *> ) = ( ( B133 'or' B134 ) 'or' B135 ));
correctness
proof
deffunc H8((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( $1 'or' $2 ) 'or' $3 );
L184: ((ex B136 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B137 , B138 , B139 being (Element of ( BOOLEAN )) holds ( B136 . <* B137 , B138 , B139 *> ) = H8(B137 , B138 , B139))) & (for B140 , B141 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B142 , B143 , B144 being (Element of ( BOOLEAN )) holds ( B140 . <* B142 , B143 , B144 *> ) = H8(B142 , B143 , B144)) & (for B145 , B146 , B147 being (Element of ( BOOLEAN )) holds ( B141 . <* B145 , B146 , B147 *> ) = H8(B145 , B146 , B147))) implies B140 = B141))) from 3AryBooleDef;
thus L185: thesis by L184;
end;
end;
begin
theorem
L187: (for B148 being  Circuit-like non  void non  empty ManySortedSign holds (for B149 being  non-empty (Circuit of B148) holds (for B150 being (State of B149) holds (for B151 being (Gate of B148) holds ( ( Following B150 ) . ( the_result_sort_of B151 ) ) = ( ( Den (B151 , B149) ) . ( B150 * ( the_arity_of B151 ) ) )))))
proof
let C100 being  Circuit-like non  void non  empty ManySortedSign;
let C101 being  non-empty (Circuit of C100);
let C102 being (State of C101);
let C103 being (Gate of C100);
set D22 = ( the_result_sort_of C103 );
L188: ( dom (the ResultSort of C100) ) = (the carrier' of C100) by FUNCT_2:def 1;
L189: ( (the ResultSort of C100) . C103 ) in ( rng (the ResultSort of C100) ) by L188 , FUNCT_1:def 3;
L190: D22 in ( InnerVertices C100 ) by L189 , MSUALG_1:def 2;
L191: (( C103 depends_on_in C102 ) = ( C102 * ( the_arity_of C103 ) ) & ( action_at D22 ) = C103) by L190 , CIRCUIT1:def 3 , MSAFREE2:def 7;
thus L192: thesis by L191 , L190 , CIRCUIT2:def 5;
end;
definition
let C104 being non  void  Circuit-like non  empty ManySortedSign;
let C105 being  non-empty (Circuit of C104);
let C106 being (State of C105);
let C107 being Nat;
func Following (C106 , C107) -> (State of C105) means 
:L193: (ex B152 being (Function of ( NAT ) , ( product (the Sorts of C105) )) st (it = ( B152 . C107 ) & ( B152 . ( 0 ) ) = C106 & (for B153 being Nat holds ( B152 . ( B153 + 1 ) ) = ( Following ( B152 . B153 ) ))));
correctness
proof
set D23 = ( product (the Sorts of C105) );
deffunc H9(Nat , (Element of D23)) = ( Following $2 );
L194: ((ex B154 being (Element of D23) st (ex B155 being (Function of ( NAT ) , D23) st (B154 = ( B155 . C107 ) & ( B155 . ( 0 ) ) = C106 & (for B156 being Nat holds ( B155 . ( B156 + 1 ) ) = H9(B156 , ( B155 . B156 )))))) & (for B157 , B158 being (Element of D23) holds (((ex B159 being (Function of ( NAT ) , D23) st (B157 = ( B159 . C107 ) & ( B159 . ( 0 ) ) = C106 & (for B160 being Nat holds ( B159 . ( B160 + 1 ) ) = H9(B160 , ( B159 . B160 ))))) & (ex B161 being (Function of ( NAT ) , D23) st (B158 = ( B161 . C107 ) & ( B161 . ( 0 ) ) = C106 & (for B162 being Nat holds ( B161 . ( B162 + 1 ) ) = H9(B162 , ( B161 . B162 )))))) implies B157 = B158))) from RECDEF_1:sch 14;
thus L195: thesis by L194;
end;
end;
theorem
L197: (for B163 being  Circuit-like non  void non  empty ManySortedSign holds (for B164 being  non-empty (Circuit of B163) holds (for B165 being (State of B164) holds ( Following (B165 , ( 0 )) ) = B165)))
proof
let C108 being  Circuit-like non  void non  empty ManySortedSign;
let C109 being  non-empty (Circuit of C108);
let C110 being (State of C109);
L198: (ex B166 being (Function of ( NAT ) , ( product (the Sorts of C109) )) st (( Following (C110 , ( 0 )) ) = ( B166 . ( 0 ) ) & ( B166 . ( 0 ) ) = C110 & (for B167 being Nat holds ( B166 . ( B167 + 1 ) ) = ( Following ( B166 . B167 ) )))) by L193;
thus L199: thesis by L198;
end;
theorem
L200: (for B168 being  Circuit-like non  void non  empty ManySortedSign holds (for B169 being  non-empty (Circuit of B168) holds (for B170 being (State of B169) holds (for B171 being Nat holds ( Following (B170 , ( B171 + 1 )) ) = ( Following ( Following (B170 , B171) ) )))))
proof
let C111 being  Circuit-like non  void non  empty ManySortedSign;
let C112 being  non-empty (Circuit of C111);
let C113 being (State of C112);
let C114 being Nat;
consider C115 being (Function of ( NAT ) , ( product (the Sorts of C112) )) such that L201: ( Following (C113 , C114) ) = ( C115 . C114 ) and L202: ( C115 . ( 0 ) ) = C113 and L203: (for B172 being Nat holds ( C115 . ( B172 + 1 ) ) = ( Following ( C115 . B172 ) )) by L193;
thus L204: ( Following (C113 , ( C114 + 1 )) ) = ( C115 . ( C114 + 1 ) ) by L202 , L203 , L193
.= ( Following ( Following (C113 , C114) ) ) by L201 , L203;
end;
theorem
L205: (for B173 being  Circuit-like non  void non  empty ManySortedSign holds (for B174 being  non-empty (Circuit of B173) holds (for B175 being (State of B174) holds (for B176 , B177 being Nat holds ( Following (B175 , ( B176 + B177 )) ) = ( Following (( Following (B175 , B176) ) , B177) )))))
proof
let C116 being  Circuit-like non  void non  empty ManySortedSign;
let C117 being  non-empty (Circuit of C116);
let C118 being (State of C117);
let C119 being Nat;
defpred S1[ Nat ] means ( Following (C118 , ( C119 + $1 )) ) = ( Following (( Following (C118 , C119) ) , $1) );
L206: (for B178 being Nat holds (S1[ B178 ] implies S1[ ( B178 + 1 ) ]))
proof
let C120 being Nat;
assume L207: ( Following (C118 , ( C119 + C120 )) ) = ( Following (( Following (C118 , C119) ) , C120) );
thus L208: ( Following (C118 , ( C119 + ( C120 + 1 ) )) ) = ( Following (C118 , ( ( C119 + C120 ) + 1 )) )
.= ( Following ( Following (C118 , ( C119 + C120 )) ) ) by L200
.= ( Following (( Following (C118 , C119) ) , ( C120 + 1 )) ) by L207 , L200;
end;
L209: S1[ ( 0 ) ] by L197;
thus L210: (for B179 being Nat holds S1[ B179 ]) from NAT_1:sch 2(L209 , L206);
end;
theorem
L211: (for B180 being non  void  Circuit-like non  empty ManySortedSign holds (for B181 being  non-empty (Circuit of B180) holds (for B182 being (State of B181) holds ( Following (B182 , 1) ) = ( Following B182 ))))
proof
let C121 being non  void  Circuit-like non  empty ManySortedSign;
let C122 being  non-empty (Circuit of C121);
let C123 being (State of C122);
L212: ( ( 0 ) + 1 ) = 1;
thus L213: ( Following (C123 , 1) ) = ( Following ( Following (C123 , ( 0 )) ) ) by L212 , L200
.= ( Following C123 ) by L197;
end;
theorem
L214: (for B183 being non  void  Circuit-like non  empty ManySortedSign holds (for B184 being  non-empty (Circuit of B183) holds (for B185 being (State of B184) holds ( Following (B185 , 2) ) = ( Following ( Following B185 ) ))))
proof
let C124 being non  void  Circuit-like non  empty ManySortedSign;
let C125 being  non-empty (Circuit of C124);
let C126 being (State of C125);
L215: 2 = ( 1 + 1 );
thus L216: ( Following (C126 , 2) ) = ( Following ( Following (C126 , ( ( 0 ) + 1 )) ) ) by L215 , L200
.= ( Following ( Following C126 ) ) by L211;
end;
theorem
L217: (for B186 being  Circuit-like non  void non  empty ManySortedSign holds (for B187 being  non-empty (Circuit of B186) holds (for B188 being (State of B187) holds (for B189 being Nat holds ( Following (B188 , ( B189 + 1 )) ) = ( Following (( Following B188 ) , B189) )))))
proof
let C127 being  Circuit-like non  void non  empty ManySortedSign;
let C128 being  non-empty (Circuit of C127);
let C129 being (State of C128);
let C130 being Nat;
L218: ( Following (C129 , ( C130 + 1 )) ) = ( Following (( Following (C129 , 1) ) , C130) ) by L205;
thus L219: thesis by L218 , L211;
end;
definition
let C131 being non  void  Circuit-like non  empty ManySortedSign;
let C132 being  non-empty (Circuit of C131);
let C133 being (State of C132);
let C134 being set;
pred C133 is_stable_at C134
means
:L220: (for B190 being Nat holds ( ( Following (C133 , B190) ) . C134 ) = ( C133 . C134 ))
;end;
theorem
L222: (for B191 being non  void  Circuit-like non  empty ManySortedSign holds (for B192 being  non-empty (Circuit of B191) holds (for B193 being (State of B192) holds (for B194 being set holds (B193 is_stable_at B194 implies (for B195 being Nat holds ( Following (B193 , B195) ) is_stable_at B194))))))
proof
let C135 being non  void  Circuit-like non  empty ManySortedSign;
let C136 being  non-empty (Circuit of C135);
let C137 being (State of C136);
let C138 being set;
assume that
L223: (for B196 being Nat holds ( ( Following (C137 , B196) ) . C138 ) = ( C137 . C138 ));
let C139 , C140 being Nat;
thus L224: ( ( Following (( Following (C137 , C139) ) , C140) ) . C138 ) = ( ( Following (C137 , ( C139 + C140 )) ) . C138 ) by L205
.= ( C137 . C138 ) by L223
.= ( ( Following (C137 , C139) ) . C138 ) by L223;
end;
theorem
L225: (for B197 being non  void  Circuit-like non  empty ManySortedSign holds (for B198 being  non-empty (Circuit of B197) holds (for B199 being (State of B198) holds (for B200 being set holds (B200 in ( InputVertices B197 ) implies B199 is_stable_at B200)))))
proof
let C141 being non  void  Circuit-like non  empty ManySortedSign;
let C142 being  non-empty (Circuit of C141);
let C143 being (State of C142);
let C144 being set;
defpred S2[ Nat ] means ( ( Following (C143 , $1) ) . C144 ) = ( C143 . C144 );
assume L226: C144 in ( InputVertices C141 );
L227:
now
let C145 being Nat;
assume L228: S2[ C145 ];
L229: ( ( Following (C143 , ( C145 + 1 )) ) . C144 ) = ( ( Following ( Following (C143 , C145) ) ) . C144 ) by L200
.= ( C143 . C144 ) by L226 , L228 , CIRCUIT2:def 5;
thus L230: S2[ ( C145 + 1 ) ] by L229;
end;
L231: S2[ ( 0 ) ] by L197;
thus L232: (for B201 being Nat holds S2[ B201 ]) from NAT_1:sch 2(L231 , L227);
end;
theorem
L233: (for B202 being non  void  Circuit-like non  empty ManySortedSign holds (for B203 being  non-empty (Circuit of B202) holds (for B204 being (State of B203) holds (for B205 being (Gate of B202) holds ((for B206 being set holds (B206 in ( rng ( the_arity_of B205 ) ) implies B204 is_stable_at B206)) implies ( Following B204 ) is_stable_at ( the_result_sort_of B205 ))))))
proof
let C146 being non  void  Circuit-like non  empty ManySortedSign;
let C147 being  non-empty (Circuit of C146);
let C148 being (State of C147);
let C149 being (Gate of C146);
set D24 = ( the_arity_of C149 );
assume L234: (for B207 being set holds (B207 in ( rng D24 ) implies C148 is_stable_at B207));
let C150 being Nat;
L235:
now
let C151 being set;
assume L236: C151 in ( dom D24 );
L237: ( D24 . C151 ) in ( rng D24 ) by L236 , FUNCT_1:def 3;
L238: C148 is_stable_at ( D24 . C151 ) by L237 , L234;
L239: (( ( ( Following (C148 , C150) ) * D24 ) . C151 ) = ( ( Following (C148 , C150) ) . ( D24 . C151 ) ) & ( ( C148 * D24 ) . C151 ) = ( C148 . ( D24 . C151 ) )) by L236 , FUNCT_1:13;
thus L240: ( ( ( Following (C148 , C150) ) * D24 ) . C151 ) = ( ( C148 * D24 ) . C151 ) by L239 , L238 , L220;
end;
L241: ( rng D24 ) c= (the carrier of C146) by FINSEQ_1:def 4;
L242: ( dom ( Following (C148 , C150) ) ) = (the carrier of C146) by CIRCUIT1:3;
L243: ( dom ( ( Following (C148 , C150) ) * D24 ) ) = ( dom D24 ) by L242 , L241 , RELAT_1:27;
L244: ( dom C148 ) = (the carrier of C146) by CIRCUIT1:3;
L245: ( dom ( C148 * D24 ) ) = ( dom D24 ) by L244 , L241 , RELAT_1:27;
L246: ( ( Following (C148 , C150) ) * D24 ) = ( C148 * D24 ) by L245 , L243 , L235 , FUNCT_1:2;
thus L247: ( ( Following (( Following C148 ) , C150) ) . ( the_result_sort_of C149 ) ) = ( ( Following (C148 , ( C150 + 1 )) ) . ( the_result_sort_of C149 ) ) by L217
.= ( ( Following ( Following (C148 , C150) ) ) . ( the_result_sort_of C149 ) ) by L200
.= ( ( Den (C149 , C147) ) . ( ( Following (C148 , C150) ) * D24 ) ) by L187
.= ( ( Following C148 ) . ( the_result_sort_of C149 ) ) by L246 , L187;
end;
begin
theorem
L248: (for B208 , B209 being non  empty ManySortedSign holds (for B210 being (Vertex of B208) holds (B210 in (the carrier of ( B208 +* B209 )) & B210 in (the carrier of ( B209 +* B208 )))))
proof
let C152 , C153 being non  empty ManySortedSign;
let C154 being (Vertex of C152);
L249: ((the carrier of ( C152 +* C153 )) = ( (the carrier of C152) \/ (the carrier of C153) ) & (the carrier of ( C153 +* C152 )) = ( (the carrier of C153) \/ (the carrier of C152) )) by CIRCCOMB:def 2;
thus L250: thesis by L249 , XBOOLE_0:def 3;
end;
theorem
L251: (for B211 , B212 being  unsplit  gate`1=arity non  empty ManySortedSign holds (for B213 being set holds (B213 in ( InnerVertices B211 ) implies (B213 in ( InnerVertices ( B211 +* B212 ) ) & B213 in ( InnerVertices ( B212 +* B211 ) )))))
proof
let C155 , C156 being  unsplit  gate`1=arity non  empty ManySortedSign;
L252: C155 tolerates C156 by CIRCCOMB:47;
L253: (( InnerVertices ( C155 +* C156 ) ) = ( ( InnerVertices C155 ) \/ ( InnerVertices C156 ) ) & ( InnerVertices ( C156 +* C155 ) ) = ( ( InnerVertices C156 ) \/ ( InnerVertices C155 ) )) by L252 , CIRCCOMB:11;
thus L254: thesis by L253 , XBOOLE_0:def 3;
end;
theorem
L255: (for B214 , B215 being non  empty ManySortedSign holds (for B216 being set holds (B216 in ( InnerVertices B215 ) implies B216 in ( InnerVertices ( B214 +* B215 ) ))))
proof
let C157 , C158 being non  empty ManySortedSign;
set D25 = (the ResultSort of C157);
set D26 = (the ResultSort of C158);
L256: ( InnerVertices ( C157 +* C158 ) ) = ( rng ( D25 +* D26 ) ) by CIRCCOMB:def 2;
L257: ( InnerVertices C158 ) c= ( InnerVertices ( C157 +* C158 ) ) by L256 , FUNCT_4:18;
thus L258: thesis by L257;
end;
theorem
L259: (for B217 , B218 being  unsplit  gate`1=arity non  empty ManySortedSign holds ( B217 +* B218 ) = ( B218 +* B217 )) by CIRCCOMB:5 , CIRCCOMB:47;
theorem
L260: (for B219 , B220 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign holds (for B221 being  Boolean  gate`2=den (Circuit of B219) holds (for B222 being  Boolean  gate`2=den (Circuit of B220) holds ( B221 +* B222 ) = ( B222 +* B221 )))) by CIRCCOMB:22 , CIRCCOMB:60;
theorem
L261: (for B223 , B224 , B225 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign holds (for B226 being  Boolean (Circuit of B223) holds (for B227 being  Boolean (Circuit of B224) holds (for B228 being  Boolean (Circuit of B225) holds ( ( B226 +* B227 ) +* B228 ) = ( B226 +* ( B227 +* B228 ) )))))
proof
let C159 , C160 , C161 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign;
let C162 being  Boolean (Circuit of C159);
let C163 being  Boolean (Circuit of C160);
let C164 being  Boolean (Circuit of C161);
L262: (the Sorts of C164) tolerates (the Sorts of C162) by CIRCCOMB:59;
L263: ((the Sorts of C162) tolerates (the Sorts of C163) & (the Sorts of C163) tolerates (the Sorts of C164)) by CIRCCOMB:59;
thus L264: thesis by L263 , L262 , CIRCCOMB:23;
end;
theorem
L265: (for B229 , B230 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign holds (for B231 being  Boolean  gate`2=den  non-empty (Circuit of B229) holds (for B232 being  Boolean  gate`2=den  non-empty (Circuit of B230) holds (for B233 being (State of ( B231 +* B232 )) holds (( B233 | (the carrier of B229) ) is (State of B231) & ( B233 | (the carrier of B230) ) is (State of B232))))))
proof
let C165 , C166 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign;
let C167 being  Boolean  gate`2=den (Circuit of C165);
let C168 being  Boolean  gate`2=den (Circuit of C166);
let C169 being (State of ( C167 +* C168 ));
L266: (the Sorts of C167) tolerates (the Sorts of C168) by CIRCCOMB:59;
thus L267: thesis by L266 , CIRCCOMB:26;
end;
theorem
L268: (for B234 , B235 being  unsplit  gate`1=arity non  empty ManySortedSign holds ( InnerVertices ( B234 +* B235 ) ) = ( ( InnerVertices B234 ) \/ ( InnerVertices B235 ) ))
proof
let C170 , C171 being  unsplit  gate`1=arity non  empty ManySortedSign;
L269: C170 tolerates C171 by CIRCCOMB:47;
thus L270: thesis by L269 , CIRCCOMB:11;
end;
theorem
L271: (for B236 , B237 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign holds (( InnerVertices B237 ) misses ( InputVertices B236 ) implies (for B238 being  Boolean  gate`2=den (Circuit of B236) holds (for B239 being  Boolean  gate`2=den (Circuit of B237) holds (for B240 being (State of ( B238 +* B239 )) holds (for B241 being (State of B238) holds (B241 = ( B240 | (the carrier of B236) ) implies ( ( Following B240 ) | (the carrier of B236) ) = ( Following B241 ))))))))
proof
let C172 , C173 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign;
assume that
L272: ( InnerVertices C173 ) misses ( InputVertices C172 );
let C174 being  Boolean  gate`2=den (Circuit of C172);
let C175 being  Boolean  gate`2=den (Circuit of C173);
let C176 being (State of ( C174 +* C175 ));
let C177 being (State of C174);
assume that
L273: C177 = ( C176 | (the carrier of C172) );
reconsider D27 = ( C176 | (the carrier of C173) ) as (State of C175) by L265;
L274: (( dom ( Following C177 ) ) = (the carrier of C172) & ( Following C176 ) = ( ( Following D27 ) +* ( Following C177 ) )) by L272 , L273 , CIRCCOMB:33 , CIRCCOMB:60 , CIRCUIT1:3;
thus L275: thesis by L274 , FUNCT_4:23;
end;
theorem
L276: (for B242 , B243 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign holds (( InnerVertices B242 ) misses ( InputVertices B243 ) implies (for B244 being  Boolean  gate`2=den (Circuit of B242) holds (for B245 being  Boolean  gate`2=den (Circuit of B243) holds (for B246 being (State of ( B244 +* B245 )) holds (for B247 being (State of B245) holds (B247 = ( B246 | (the carrier of B243) ) implies ( ( Following B246 ) | (the carrier of B243) ) = ( Following B247 ))))))))
proof
let C178 , C179 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign;
assume that
L277: ( InnerVertices C178 ) misses ( InputVertices C179 );
let C180 being  Boolean  gate`2=den (Circuit of C178);
let C181 being  Boolean  gate`2=den (Circuit of C179);
let C182 being (State of ( C180 +* C181 ));
let C183 being (State of C181);
assume that
L278: C183 = ( C182 | (the carrier of C179) );
reconsider D28 = ( C182 | (the carrier of C178) ) as (State of C180) by L265;
L279: (( dom ( Following C183 ) ) = (the carrier of C179) & ( Following C182 ) = ( ( Following D28 ) +* ( Following C183 ) )) by L277 , L278 , CIRCCOMB:32 , CIRCCOMB:60 , CIRCUIT1:3;
thus L280: thesis by L279 , FUNCT_4:23;
end;
theorem
L281: (for B248 , B249 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign holds (( InnerVertices B249 ) misses ( InputVertices B248 ) implies (for B250 being  Boolean  gate`2=den (Circuit of B248) holds (for B251 being  Boolean  gate`2=den (Circuit of B249) holds (for B252 being (State of ( B250 +* B251 )) holds (for B253 being (State of B250) holds (B253 = ( B252 | (the carrier of B248) ) implies (for B254 being Nat holds ( ( Following (B252 , B254) ) | (the carrier of B248) ) = ( Following (B253 , B254) )))))))))
proof
let C184 , C185 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign;
assume that
L282: ( InnerVertices C185 ) misses ( InputVertices C184 );
let C186 being  Boolean  gate`2=den (Circuit of C184);
let C187 being  Boolean  gate`2=den (Circuit of C185);
let C188 being (State of ( C186 +* C187 ));
let C189 being (State of C186);
assume that
L283: C189 = ( C188 | (the carrier of C184) );
defpred S3[ Nat ] means ( ( Following (C188 , $1) ) | (the carrier of C184) ) = ( Following (C189 , $1) );
L284: (for B255 being Nat holds (S3[ B255 ] implies S3[ ( B255 + 1 ) ]))
proof
let C190 being Nat;
assume L285: ( ( Following (C188 , C190) ) | (the carrier of C184) ) = ( Following (C189 , C190) );
thus L286: ( ( Following (C188 , ( C190 + 1 )) ) | (the carrier of C184) ) = ( ( Following ( Following (C188 , C190) ) ) | (the carrier of C184) ) by L200
.= ( Following ( Following (C189 , C190) ) ) by L282 , L285 , L271
.= ( Following (C189 , ( C190 + 1 )) ) by L200;
end;
L287: ( Following (C188 , ( 0 )) ) = C188 by L197;
L288: S3[ ( 0 ) ] by L287 , L283 , L197;
thus L289: (for B256 being Nat holds S3[ B256 ]) from NAT_1:sch 2(L288 , L284);
end;
theorem
L290: (for B257 , B258 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign holds (( InnerVertices B257 ) misses ( InputVertices B258 ) implies (for B259 being  Boolean  gate`2=den (Circuit of B257) holds (for B260 being  Boolean  gate`2=den (Circuit of B258) holds (for B261 being (State of ( B259 +* B260 )) holds (for B262 being (State of B260) holds (B262 = ( B261 | (the carrier of B258) ) implies (for B263 being Nat holds ( ( Following (B261 , B263) ) | (the carrier of B258) ) = ( Following (B262 , B263) )))))))))
proof
let C191 , C192 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign;
assume that
L291: ( InnerVertices C191 ) misses ( InputVertices C192 );
let C193 being  Boolean  gate`2=den (Circuit of C191);
let C194 being  Boolean  gate`2=den (Circuit of C192);
let C195 being (State of ( C193 +* C194 ));
let C196 being (State of C194);
assume that
L292: C196 = ( C195 | (the carrier of C192) );
defpred S4[ Nat ] means ( ( Following (C195 , $1) ) | (the carrier of C192) ) = ( Following (C196 , $1) );
L293: (for B264 being Nat holds (S4[ B264 ] implies S4[ ( B264 + 1 ) ]))
proof
let C197 being Nat;
assume L294: ( ( Following (C195 , C197) ) | (the carrier of C192) ) = ( Following (C196 , C197) );
thus L295: ( ( Following (C195 , ( C197 + 1 )) ) | (the carrier of C192) ) = ( ( Following ( Following (C195 , C197) ) ) | (the carrier of C192) ) by L200
.= ( Following ( Following (C196 , C197) ) ) by L291 , L294 , L276
.= ( Following (C196 , ( C197 + 1 )) ) by L200;
end;
L296: ( Following (C195 , ( 0 )) ) = C195 by L197;
L297: S4[ ( 0 ) ] by L296 , L292 , L197;
thus L298: (for B265 being Nat holds S4[ B265 ]) from NAT_1:sch 2(L297 , L293);
end;
theorem
L299: (for B266 , B267 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign holds (( InnerVertices B267 ) misses ( InputVertices B266 ) implies (for B268 being  Boolean  gate`2=den (Circuit of B266) holds (for B269 being  Boolean  gate`2=den (Circuit of B267) holds (for B270 being (State of ( B268 +* B269 )) holds (for B271 being (State of B268) holds (B271 = ( B270 | (the carrier of B266) ) implies (for B272 being set holds (B272 in (the carrier of B266) implies (for B273 being Nat holds ( ( Following (B270 , B273) ) . B272 ) = ( ( Following (B271 , B273) ) . B272 )))))))))))
proof
let C198 , C199 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign;
assume that
L300: ( InnerVertices C199 ) misses ( InputVertices C198 );
let C200 being  Boolean  gate`2=den (Circuit of C198);
let C201 being  Boolean  gate`2=den (Circuit of C199);
let C202 being (State of ( C200 +* C201 ));
let C203 being (State of C200);
assume that
L301: C203 = ( C202 | (the carrier of C198) );
let C204 being set;
assume L302: C204 in (the carrier of C198);
let C205 being Nat;
L303: (the carrier of C198) = ( dom ( Following (C203 , C205) ) ) by CIRCUIT1:3;
L304: ( ( Following (C202 , C205) ) | (the carrier of C198) ) = ( Following (C203 , C205) ) by L300 , L301 , L281;
thus L305: thesis by L304 , L302 , L303 , FUNCT_1:47;
end;
theorem
L306: (for B274 , B275 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign holds (( InnerVertices B274 ) misses ( InputVertices B275 ) implies (for B276 being  Boolean  gate`2=den (Circuit of B274) holds (for B277 being  Boolean  gate`2=den (Circuit of B275) holds (for B278 being (State of ( B276 +* B277 )) holds (for B279 being (State of B277) holds (B279 = ( B278 | (the carrier of B275) ) implies (for B280 being set holds (B280 in (the carrier of B275) implies (for B281 being Nat holds ( ( Following (B278 , B281) ) . B280 ) = ( ( Following (B279 , B281) ) . B280 )))))))))))
proof
let C206 , C207 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign;
assume that
L307: ( InnerVertices C206 ) misses ( InputVertices C207 );
let C208 being  Boolean  gate`2=den (Circuit of C206);
let C209 being  Boolean  gate`2=den (Circuit of C207);
let C210 being (State of ( C208 +* C209 ));
let C211 being (State of C209);
assume that
L308: C211 = ( C210 | (the carrier of C207) );
let C212 being set;
assume L309: C212 in (the carrier of C207);
let C213 being Nat;
L310: (the carrier of C207) = ( dom ( Following (C211 , C213) ) ) by CIRCUIT1:3;
L311: ( ( Following (C210 , C213) ) | (the carrier of C207) ) = ( Following (C211 , C213) ) by L307 , L308 , L290;
thus L312: thesis by L311 , L309 , L310 , FUNCT_1:47;
end;
registration
let C214 being  gate`2=den non  void non  empty ManySortedSign;
let C215 being (Gate of C214);
cluster ( C215 `2 ) ->  Function-like  Relation-like;
coherence
proof
consider C216 being MSAlgebra over C214 such that L313: C216 is  gate`2=den by CIRCCOMB:def 11;
L314: ( C215 `2 ) = ( [ ( C215 `1 ) , ( (the Charact of C216) . C215 ) ] `2 ) by L313 , CIRCCOMB:def 10
.= ( (the Charact of C216) . C215 )
.= ( Den (C215 , C216) ) by MSUALG_1:def 6;
thus L315: thesis by L314;
end;
end;
theorem
L317: (for B282 being  gate`2=den  Circuit-like non  void non  empty ManySortedSign holds (for B283 being  non-empty (Circuit of B282) holds (B283 is  gate`2=den implies (for B284 being (State of B283) holds (for B285 being (Gate of B282) holds ( ( Following B284 ) . ( the_result_sort_of B285 ) ) = ( ( B285 `2 ) . ( B284 * ( the_arity_of B285 ) ) ))))))
proof
let C217 being  gate`2=den  Circuit-like non  void non  empty ManySortedSign;
let C218 being  non-empty (Circuit of C217);
assume that
L318: (for B286 being set holds (B286 in (the carrier' of C217) implies B286 = [ ( B286 `1 ) , ( (the Charact of C218) . B286 ) ]));
let C219 being (State of C218);
let C220 being (Gate of C217);
L319: ( Den (C220 , C218) ) = ( (the Charact of C218) . C220 ) by MSUALG_1:def 6
.= ( [ ( C220 `1 ) , ( (the Charact of C218) . C220 ) ] `2 )
.= ( C220 `2 ) by L318;
set D29 = ( the_result_sort_of C220 );
L320: ( dom (the ResultSort of C217) ) = (the carrier' of C217) by FUNCT_2:def 1;
L321: ( (the ResultSort of C217) . C220 ) in ( rng (the ResultSort of C217) ) by L320 , FUNCT_1:def 3;
L322: D29 in ( InnerVertices C217 ) by L321 , MSUALG_1:def 2;
L323: (( C220 depends_on_in C219 ) = ( C219 * ( the_arity_of C220 ) ) & ( action_at D29 ) = C220) by L322 , CIRCUIT1:def 3 , MSAFREE2:def 7;
thus L324: thesis by L323 , L319 , L322 , CIRCUIT2:def 5;
end;
theorem
L325: (for B287 being  gate`1=arity  gate`2isBoolean  unsplit non  void non  empty ManySortedSign holds (for B288 being  Boolean  gate`2=den  non-empty (Circuit of B287) holds (for B289 being (State of B288) holds (for B290 being FinSequence holds (for B291 being Function holds ([ B290 , B291 ] in (the carrier' of B287) implies ( ( Following B289 ) . [ B290 , B291 ] ) = ( B291 . ( B289 * B290 ) )))))))
proof
let C221 being  gate`1=arity  gate`2isBoolean  unsplit non  void non  empty ManySortedSign;
let C222 being  Boolean  gate`2=den  non-empty (Circuit of C221);
let C223 being (State of C222);
let C224 being FinSequence;
let C225 being Function;
assume L326: [ C224 , C225 ] in (the carrier' of C221);
reconsider D30 = [ C224 , C225 ] as (Gate of C221) by L326;
L327: (( D30 `1 ) = C224 & ( D30 `2 ) = C225) by MCART_1:7;
L328: ( the_result_sort_of D30 ) = ( (the ResultSort of C221) . D30 ) by MSUALG_1:def 2
.= D30 by CIRCCOMB:44;
L329: ( the_arity_of D30 ) = ( (the Arity of C221) . D30 ) by MSUALG_1:def 1
.= ( [ ( (the Arity of C221) . D30 ) , ( D30 `2 ) ] `1 )
.= ( D30 `1 ) by CIRCCOMB:def 8;
thus L330: thesis by L329 , L327 , L328 , L317;
end;
theorem
L331: (for B292 being  gate`1=arity  gate`2isBoolean  unsplit non  void non  empty ManySortedSign holds (for B293 being  Boolean  gate`2=den  non-empty (Circuit of B292) holds (for B294 being (State of B293) holds (for B295 being FinSequence holds (for B296 being Function holds (([ B295 , B296 ] in (the carrier' of B292) & (for B297 being set holds (B297 in ( rng B295 ) implies B294 is_stable_at B297))) implies ( Following B294 ) is_stable_at [ B295 , B296 ]))))))
proof
let C226 being  gate`1=arity  gate`2isBoolean  unsplit non  void non  empty ManySortedSign;
let C227 being  Boolean  gate`2=den  non-empty (Circuit of C226);
let C228 being (State of C227);
let C229 being FinSequence;
let C230 being Function;
assume L332: [ C229 , C230 ] in (the carrier' of C226);
reconsider D31 = [ C229 , C230 ] as (Gate of C226) by L332;
L333: ( the_arity_of D31 ) = ( (the Arity of C226) . D31 ) by MSUALG_1:def 1
.= ( [ ( (the Arity of C226) . D31 ) , ( D31 `2 ) ] `1 )
.= ( D31 `1 ) by CIRCCOMB:def 8
.= C229 by MCART_1:7;
L334: ( the_result_sort_of D31 ) = ( (the ResultSort of C226) . D31 ) by MSUALG_1:def 2
.= D31 by CIRCCOMB:44;
assume L335: (for B298 being set holds (B298 in ( rng C229 ) implies C228 is_stable_at B298));
thus L336: thesis by L335 , L333 , L334 , L233;
end;
theorem
L337: (for B299 being  unsplit non  empty ManySortedSign holds ( InnerVertices B299 ) = (the carrier' of B299))
proof
let C231 being  unsplit non  empty ManySortedSign;
L338: (the ResultSort of C231) = ( id (the carrier' of C231) ) by CIRCCOMB:def 7;
thus L339: thesis by L338 , RELAT_1:45;
end;
begin
theorem
L340: (for B300 being set holds (for B301 being FinSequence holds ( InnerVertices ( 1GateCircStr (B301 , B300) ) ) is Relation))
proof
let C232 being set;
let C233 being FinSequence;
L341: ( InnerVertices ( 1GateCircStr (C233 , C232) ) ) = { [ C233 , C232 ] } by CIRCCOMB:42;
thus L342: thesis by L341;
end;
theorem
L343: (for B302 being set holds (for B303 being  nonpair-yielding FinSequence holds ( InputVertices ( 1GateCircStr (B303 , B302) ) ) is  without_pairs))
proof
let C234 being set;
let C235 being  nonpair-yielding FinSequence;
L344: ( InputVertices ( 1GateCircStr (C235 , C234) ) ) = ( rng C235 ) by CIRCCOMB:42;
thus L345: thesis by L344;
end;
theorem
L346: (for B304 being set holds (for B305 , B306 being set holds ( InputVertices ( 1GateCircStr (<* B305 , B306 *> , B304) ) ) = { B305 , B306 }))
proof
let C236 being set;
let C237 , C238 being set;
set D32 = <* C237 , C238 *>;
thus L347: ( InputVertices ( 1GateCircStr (D32 , C236) ) ) = ( rng D32 ) by CIRCCOMB:42
.= { C237 , C238 } by FINSEQ_2:127;
end;
theorem
L348: (for B307 being set holds (for B308 , B309 being non  pair set holds ( InputVertices ( 1GateCircStr (<* B308 , B309 *> , B307) ) ) is  without_pairs))
proof
let C239 being set;
let C240 , C241 being non  pair set;
set D33 = <* C240 , C241 *>;
let C242 being  pair set;
assume L349: C242 in ( InputVertices ( 1GateCircStr (D33 , C239) ) );
L350: ( InputVertices ( 1GateCircStr (D33 , C239) ) ) = { C240 , C241 } by L346;
thus L351: thesis by L350 , L349 , TARSKI:def 2;
end;
theorem
L352: (for B310 being set holds (for B311 , B312 , B313 being set holds ( InputVertices ( 1GateCircStr (<* B311 , B312 , B313 *> , B310) ) ) = { B311 , B312 , B313 }))
proof
let C243 being set;
let C244 , C245 , C246 being set;
set D34 = <* C244 , C245 , C246 *>;
thus L353: ( InputVertices ( 1GateCircStr (D34 , C243) ) ) = ( rng D34 ) by CIRCCOMB:42
.= { C244 , C245 , C246 } by FINSEQ_2:128;
end;
theorem
L354: (for B314 , B315 , B316 being set holds (B314 in (the carrier of ( 1GateCircStr (<* B314 , B315 *> , B316) )) & B315 in (the carrier of ( 1GateCircStr (<* B314 , B315 *> , B316) )) & [ <* B314 , B315 *> , B316 ] in (the carrier of ( 1GateCircStr (<* B314 , B315 *> , B316) ))))
proof
let C247 , C248 , C249 being set;
set D35 = <* C247 , C248 *>;
L355: C247 in { C247 , C248 } by TARSKI:def 2;
L356: C247 in ( rng D35 ) by L355 , FINSEQ_2:127;
L357: C248 in { C247 , C248 } by TARSKI:def 2;
L358: C248 in ( rng D35 ) by L357 , FINSEQ_2:127;
L359: ((the carrier of ( 1GateCircStr (D35 , C249) )) = ( ( rng D35 ) \/ { [ D35 , C249 ] } ) & [ D35 , C249 ] in { [ D35 , C249 ] }) by CIRCCOMB:def 6 , TARSKI:def 1;
thus L360: thesis by L359 , L356 , L358 , XBOOLE_0:def 3;
end;
theorem
L361: (for B317 , B318 , B319 , B320 being set holds (B317 in (the carrier of ( 1GateCircStr (<* B317 , B318 , B319 *> , B320) )) & B318 in (the carrier of ( 1GateCircStr (<* B317 , B318 , B319 *> , B320) )) & B319 in (the carrier of ( 1GateCircStr (<* B317 , B318 , B319 *> , B320) ))))
proof
let C250 , C251 , C252 , C253 being set;
set D36 = <* C250 , C251 , C252 *>;
set D37 = (the carrier of ( 1GateCircStr (D36 , C253) ));
L362: C251 in { C250 , C251 , C252 } by ENUMSET1:def 1;
L363: C251 in ( rng D36 ) by L362 , FINSEQ_2:128;
L364: C252 in { C250 , C251 , C252 } by ENUMSET1:def 1;
L365: C252 in ( rng D36 ) by L364 , FINSEQ_2:128;
L366: C250 in { C250 , C251 , C252 } by ENUMSET1:def 1;
L367: (D37 = ( ( rng D36 ) \/ { [ D36 , C253 ] } ) & C250 in ( rng D36 )) by L366 , CIRCCOMB:def 6 , FINSEQ_2:128;
thus L368: thesis by L367 , L363 , L365 , XBOOLE_0:def 3;
end;
theorem
L369: (for B321 , B322 being set holds (for B323 being FinSequence holds (B322 in (the carrier of ( 1GateCircStr (B323 , B321 , B322) )) & (for B324 being set holds (B324 in ( rng B323 ) implies B324 in (the carrier of ( 1GateCircStr (B323 , B321 , B322) )))))))
proof
let C254 , C255 being set;
let C256 being FinSequence;
set D38 = (the carrier of ( 1GateCircStr (C256 , C254 , C255) ));
L370: (D38 = ( ( rng C256 ) \/ { C255 } ) & C255 in { C255 }) by CIRCCOMB:def 5 , TARSKI:def 1;
thus L371: thesis by L370 , XBOOLE_0:def 3;
end;
theorem
L372: (for B325 , B326 being set holds (for B327 being FinSequence holds ( 1GateCircStr (B327 , B325 , B326) ) is  gate`1=arity  Circuit-like))
proof
let C257 , C258 being set;
let C259 being FinSequence;
set D39 = ( 1GateCircStr (C259 , C257 , C258) );
thus L373: D39 is  gate`1=arity
proof
let C260 being set;
assume L374: C260 in (the carrier' of D39);
L375: C260 in { [ C259 , C257 ] } by L374 , CIRCCOMB:def 5;
L376: C260 = [ C259 , C257 ] by L375 , TARSKI:def 1;
L377: ( [ C259 , C257 ] `2 ) = C257;
thus L378: thesis by L377 , L376 , CIRCCOMB:def 5;
end;

thus L379: D39 is  Circuit-like
proof
let C261 being non  void non  empty ManySortedSign;
assume that
L380: C261 = D39;
let C262 , C263 being (OperSymbol of C261);
L381: C262 = [ C259 , C257 ] by L380 , CIRCCOMB:37;
thus L382: thesis by L381 , L380 , CIRCCOMB:37;
end;

end;
theorem
L380: (for B328 being FinSequence holds (for B329 being set holds [ B328 , B329 ] in ( InnerVertices ( 1GateCircStr (B328 , B329) ) )))
proof
let C264 being FinSequence;
let C265 being set;
L381: ( InnerVertices ( 1GateCircStr (C264 , C265) ) ) = { [ C264 , C265 ] } by CIRCCOMB:42;
thus L382: thesis by L381 , TARSKI:def 1;
end;
definition
let C266 , C267 being set;
let C268 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
func 1GateCircuit (C266 , C267 , C268) ->  Boolean  gate`2=den  strict (Circuit of ( 1GateCircStr (<* C266 , C267 *> , C268) )) equals 
( 1GateCircuit (<* C266 , C267 *> , C268) );
coherence by CIRCCOMB:61;
end;
theorem
L384: (for R1 being set holds (for R2 being set holds (for B330 being  finite non  empty set holds (for B331 being (Function of ( 2 -tuples_on B330 ) , B330) holds (for B332 being (State of ( 1GateCircuit (<* R1 , R2 *> , B331) )) holds (( ( Following B332 ) . [ <* R1 , R2 *> , B331 ] ) = ( B331 . <* ( B332 . R1 ) , ( B332 . R2 ) *> ) & ( ( Following B332 ) . R1 ) = ( B332 . R1 ) & ( ( Following B332 ) . R2 ) = ( B332 . R2 )))))))
proof
let R1 being set;
let R2 being set;
let C269 being  finite non  empty set;
let C270 being (Function of ( 2 -tuples_on C269 ) , C269);
let C271 being (State of ( 1GateCircuit (<* R1 , R2 *> , C270) ));
set D40 = <* R1 , R2 *>;
L385: ( dom C271 ) = (the carrier of ( 1GateCircStr (D40 , C270) )) by CIRCUIT1:3;
L386: ( dom C271 ) = ( ( rng D40 ) \/ { [ D40 , C270 ] } ) by L385 , CIRCCOMB:def 6;
L387: R2 in { R1 , R2 } by TARSKI:def 2;
L388: R2 in ( rng D40 ) by L387 , FINSEQ_2:127;
L389: R2 in ( dom C271 ) by L388 , L386 , XBOOLE_0:def 3;
L390: R1 in { R1 , R2 } by TARSKI:def 2;
L391: R1 in ( rng D40 ) by L390 , FINSEQ_2:127;
L392: R1 in ( dom C271 ) by L391 , L386 , XBOOLE_0:def 3;
thus L393: ( ( Following C271 ) . [ <* R1 , R2 *> , C270 ] ) = ( C270 . ( C271 * <* R1 , R2 *> ) ) by CIRCCOMB:56
.= ( C270 . <* ( C271 . R1 ) , ( C271 . R2 ) *> ) by L392 , L389 , FINSEQ_2:125;
reconsider D41 = R1 , D42 = R2 as (Vertex of ( 1GateCircStr (D40 , C270) )) by L354;
L394: ( InputVertices ( 1GateCircStr (D40 , C270) ) ) = ( rng D40 ) by CIRCCOMB:42
.= { D41 , D42 } by FINSEQ_2:127;
L395: (D41 in ( InputVertices ( 1GateCircStr (D40 , C270) ) ) & D42 in ( InputVertices ( 1GateCircStr (D40 , C270) ) )) by L394 , TARSKI:def 2;
thus L396: thesis by L395 , CIRCUIT2:def 5;
end;
theorem
L397: (for R1 being set holds (for R2 being set holds (for B333 being  finite non  empty set holds (for B334 being (Function of ( 2 -tuples_on B333 ) , B333) holds (for B335 being (State of ( 1GateCircuit (<* R1 , R2 *> , B334) )) holds ( Following B335 ) is  stable)))))
proof
let R1 being set;
let R2 being set;
let C272 being  finite non  empty set;
let C273 being (Function of ( 2 -tuples_on C272 ) , C272);
set D43 = ( 1GateCircStr (<* R1 , R2 *> , C273) );
let C274 being (State of ( 1GateCircuit (<* R1 , R2 *> , C273) ));
set D44 = ( Following C274 );
set D45 = ( Following D44 );
set D46 = <* R1 , R2 *>;
L398: (the carrier of D43) = ( ( rng D46 ) \/ { [ D46 , C273 ] } ) by CIRCCOMB:def 6
.= ( { R1 , R2 } \/ { [ D46 , C273 ] } ) by FINSEQ_2:127;
L399:
now
let C275 being set;
L400: ( D45 . [ D46 , C273 ] ) = ( C273 . <* ( D44 . R1 ) , ( D44 . R2 ) *> ) by L384;
assume L401: C275 in (the carrier of D43);
L402: (C275 in { R1 , R2 } or C275 in { [ D46 , C273 ] }) by L401 , L398 , XBOOLE_0:def 3;
L403: (C275 = R1 or C275 = R2 or C275 = [ D46 , C273 ]) by L402 , TARSKI:def 1 , TARSKI:def 2;
L404: (( D44 . R1 ) = ( C274 . R1 ) & ( D44 . R2 ) = ( C274 . R2 )) by L384;
thus L405: ( D45 . C275 ) = ( D44 . C275 ) by L404 , L403 , L400 , L384;
end;
L406: (( dom D44 ) = (the carrier of D43) & ( dom D45 ) = (the carrier of D43)) by CIRCUIT1:3;
thus L407: ( Following C274 ) = ( Following ( Following C274 ) ) by L406 , L399 , FUNCT_1:2;
end;
theorem
L408: (for R1 being set holds (for R2 being set holds (for R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (for B336 being (State of ( 1GateCircuit (R1 , R2 , R5) )) holds (( ( Following B336 ) . [ <* R1 , R2 *> , R5 ] ) = ( R5 . <* ( B336 . R1 ) , ( B336 . R2 ) *> ) & ( ( Following B336 ) . R1 ) = ( B336 . R1 ) & ( ( Following B336 ) . R2 ) = ( B336 . R2 )))))) by L384;
theorem
L409: (for R1 being set holds (for R2 being set holds (for R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (for B337 being (State of ( 1GateCircuit (R1 , R2 , R5) )) holds ( Following B337 ) is  stable)))) by L397;
definition
let C276 , C277 , C278 being set;
let C279 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
func 1GateCircuit (C276 , C277 , C278 , C279) ->  Boolean  gate`2=den  strict (Circuit of ( 1GateCircStr (<* C276 , C277 , C278 *> , C279) )) equals 
( 1GateCircuit (<* C276 , C277 , C278 *> , C279) );
coherence by CIRCCOMB:61;
end;
theorem
L411: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for B338 being  finite non  empty set holds (for B339 being (Function of ( 3 -tuples_on B338 ) , B338) holds (for B340 being (State of ( 1GateCircuit (<* R1 , R2 , R3 *> , B339) )) holds (( ( Following B340 ) . [ <* R1 , R2 , R3 *> , B339 ] ) = ( B339 . <* ( B340 . R1 ) , ( B340 . R2 ) , ( B340 . R3 ) *> ) & ( ( Following B340 ) . R1 ) = ( B340 . R1 ) & ( ( Following B340 ) . R2 ) = ( B340 . R2 ) & ( ( Following B340 ) . R3 ) = ( B340 . R3 ))))))))
proof
let R1 being set;
let R2 being set;
let R3 being set;
let C280 being  finite non  empty set;
let C281 being (Function of ( 3 -tuples_on C280 ) , C280);
let C282 being (State of ( 1GateCircuit (<* R1 , R2 , R3 *> , C281) ));
set D47 = <* R1 , R2 , R3 *>;
L412: ( dom C282 ) = (the carrier of ( 1GateCircStr (D47 , C281) )) by CIRCUIT1:3;
L413: ( dom C282 ) = ( ( rng D47 ) \/ { [ D47 , C281 ] } ) by L412 , CIRCCOMB:def 6;
L414: R2 in { R1 , R2 , R3 } by ENUMSET1:def 1;
L415: R2 in ( rng D47 ) by L414 , FINSEQ_2:128;
L416: R2 in ( dom C282 ) by L415 , L413 , XBOOLE_0:def 3;
L417: R1 in { R1 , R2 , R3 } by ENUMSET1:def 1;
L418: R1 in ( rng D47 ) by L417 , FINSEQ_2:128;
L419: R1 in ( dom C282 ) by L418 , L413 , XBOOLE_0:def 3;
L420: R3 in { R1 , R2 , R3 } by ENUMSET1:def 1;
L421: R3 in ( rng D47 ) by L420 , FINSEQ_2:128;
L422: R3 in ( dom C282 ) by L421 , L413 , XBOOLE_0:def 3;
thus L423: ( ( Following C282 ) . [ D47 , C281 ] ) = ( C281 . ( C282 * D47 ) ) by CIRCCOMB:56
.= ( C281 . <* ( C282 . R1 ) , ( C282 . R2 ) , ( C282 . R3 ) *> ) by L419 , L416 , L422 , FINSEQ_2:126;
reconsider D48 = R1 , D49 = R2 , D50 = R3 as (Vertex of ( 1GateCircStr (D47 , C281) )) by L361;
L424: ( InputVertices ( 1GateCircStr (D47 , C281) ) ) = ( rng D47 ) by CIRCCOMB:42
.= { D48 , D49 , D50 } by FINSEQ_2:128;
L425: D50 in ( InputVertices ( 1GateCircStr (D47 , C281) ) ) by L424 , ENUMSET1:def 1;
L426: (D48 in ( InputVertices ( 1GateCircStr (D47 , C281) ) ) & D49 in ( InputVertices ( 1GateCircStr (D47 , C281) ) )) by L424 , ENUMSET1:def 1;
thus L427: thesis by L426 , L425 , CIRCUIT2:def 5;
end;
theorem
L428: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for B341 being  finite non  empty set holds (for B342 being (Function of ( 3 -tuples_on B341 ) , B341) holds (for B343 being (State of ( 1GateCircuit (<* R1 , R2 , R3 *> , B342) )) holds ( Following B343 ) is  stable))))))
proof
let R1 being set;
let R2 being set;
let R3 being set;
let C283 being  finite non  empty set;
let C284 being (Function of ( 3 -tuples_on C283 ) , C283);
set D51 = <* R1 , R2 , R3 *>;
set D52 = ( 1GateCircStr (D51 , C284) );
let C285 being (State of ( 1GateCircuit (D51 , C284) ));
set D53 = ( Following C285 );
set D54 = ( Following D53 );
L429: (the carrier of D52) = ( ( rng D51 ) \/ { [ D51 , C284 ] } ) by CIRCCOMB:def 6
.= ( { R1 , R2 , R3 } \/ { [ D51 , C284 ] } ) by FINSEQ_2:128;
L430:
now
let C286 being set;
L431: (( D53 . R3 ) = ( C285 . R3 ) & ( D54 . [ D51 , C284 ] ) = ( C284 . <* ( D53 . R1 ) , ( D53 . R2 ) , ( D53 . R3 ) *> )) by L411;
assume L432: C286 in (the carrier of D52);
L433: (C286 in { R1 , R2 , R3 } or C286 in { [ D51 , C284 ] }) by L432 , L429 , XBOOLE_0:def 3;
L434: (C286 = R1 or C286 = R2 or C286 = R3 or C286 = [ D51 , C284 ]) by L433 , ENUMSET1:def 1 , TARSKI:def 1;
L435: (( D53 . R1 ) = ( C285 . R1 ) & ( D53 . R2 ) = ( C285 . R2 )) by L411;
thus L436: ( D54 . C286 ) = ( D53 . C286 ) by L435 , L434 , L431 , L411;
end;
L437: (( dom D53 ) = (the carrier of D52) & ( dom D54 ) = (the carrier of D52)) by CIRCUIT1:3;
thus L438: ( Following C285 ) = ( Following ( Following C285 ) ) by L437 , L430 , FUNCT_1:2;
end;
theorem
L439: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for B344 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (for B345 being (State of ( 1GateCircuit (R1 , R2 , R3 , B344) )) holds (( ( Following B345 ) . [ <* R1 , R2 , R3 *> , B344 ] ) = ( B344 . <* ( B345 . R1 ) , ( B345 . R2 ) , ( B345 . R3 ) *> ) & ( ( Following B345 ) . R1 ) = ( B345 . R1 ) & ( ( Following B345 ) . R2 ) = ( B345 . R2 ) & ( ( Following B345 ) . R3 ) = ( B345 . R3 ))))))) by L411;
theorem
L440: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for B346 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (for B347 being (State of ( 1GateCircuit (R1 , R2 , R3 , B346) )) holds ( Following B347 ) is  stable))))) by L428;
begin
definition
let C287 , C288 , C289 being set;
let C290 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
func 2GatesCircStr (C287 , C288 , C289 , C290) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( 1GateCircStr (<* C287 , C288 *> , C290) ) +* ( 1GateCircStr (<* [ <* C287 , C288 *> , C290 ] , C289 *> , C290) ) );
correctness;
end;
definition
let C291 , C292 , C293 being set;
let C294 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
func 2GatesCircOutput (C291 , C292 , C293 , C294) -> (Element of ( InnerVertices ( 2GatesCircStr (C291 , C292 , C293 , C294) ) )) equals 
[ <* [ <* C291 , C292 *> , C294 ] , C293 *> , C294 ];
coherence
proof
set D55 = <* [ <* C291 , C292 *> , C294 ] , C293 *>;
set D56 = ( 1GateCircStr (D55 , C294) );
L442: [ D55 , C294 ] in ( InnerVertices D56 ) by L380;
thus L443: thesis by L442 , L251;
end;
correctness;
end;
registration
let C295 , C296 , C297 being set;
let C298 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
cluster ( 2GatesCircOutput (C295 , C296 , C297 , C298) ) ->  pair;
coherence;
end;
theorem
L446: (for R1 being set holds (for R2 being set holds (for R4 being set holds (for R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds ( InnerVertices ( 2GatesCircStr (R1 , R2 , R4 , R5) ) ) = { [ <* R1 , R2 *> , R5 ] , ( 2GatesCircOutput (R1 , R2 , R4 , R5) ) }))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
let R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
set D57 = <* [ <* R1 , R2 *> , R5 ] , R4 *>;
set D58 = ( 1GateCircStr (<* R1 , R2 *> , R5) );
set D59 = ( 1GateCircStr (D57 , R5) );
set D60 = ( 2GatesCircStr (R1 , R2 , R4 , R5) );
L447: D58 tolerates D59 by CIRCCOMB:43;
thus L448: ( InnerVertices D60 ) = ( ( InnerVertices D58 ) \/ ( InnerVertices D59 ) ) by L447 , CIRCCOMB:11
.= ( { [ <* R1 , R2 *> , R5 ] } \/ ( InnerVertices D59 ) ) by CIRCCOMB:42
.= ( { [ <* R1 , R2 *> , R5 ] } \/ { [ D57 , R5 ] } ) by CIRCCOMB:42
.= { [ <* R1 , R2 *> , R5 ] , ( 2GatesCircOutput (R1 , R2 , R4 , R5) ) } by ENUMSET1:1;
end;
theorem
L449: (for R1 being set holds (for R2 being set holds (for R4 being set holds (for R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (R4 <> [ <* R1 , R2 *> , R5 ] implies ( InputVertices ( 2GatesCircStr (R1 , R2 , R4 , R5) ) ) = { R1 , R2 , R4 })))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
let R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
assume L450: R4 <> [ <* R1 , R2 *> , R5 ];
set D61 = ( 2GatesCircStr (R1 , R2 , R4 , R5) );
set D62 = ( 1GateCircStr (<* R1 , R2 *> , R5) );
set D63 = <* [ <* R1 , R2 *> , R5 ] , R4 *>;
set D64 = ( 1GateCircStr (D63 , R5) );
set D65 = (the ResultSort of D61);
L451: (the carrier of D61) = ( (the carrier of D62) \/ (the carrier of D64) ) by CIRCCOMB:def 2;
L452: ( rng <* R1 , R2 *> ) = { R1 , R2 } by FINSEQ_2:127;
L453: (the carrier of D62) = ( { R1 , R2 } \/ { [ <* R1 , R2 *> , R5 ] } ) by L452 , CIRCCOMB:def 6;
L454: ( rng D65 ) = { [ <* R1 , R2 *> , R5 ] , ( 2GatesCircOutput (R1 , R2 , R4 , R5) ) } by L446
.= { [ <* R1 , R2 *> , R5 ] , [ D63 , R5 ] };
L455: ( rng D63 ) = { [ <* R1 , R2 *> , R5 ] , R4 } by FINSEQ_2:127;
L456: (the carrier of D64) = ( { [ <* R1 , R2 *> , R5 ] , R4 } \/ { [ D63 , R5 ] } ) by L455 , CIRCCOMB:def 6;
thus L457: ( InputVertices D61 ) c= { R1 , R2 , R4 }
proof
let C299 being set;
assume L458: C299 in ( InputVertices D61 );
L459: (C299 in (the carrier of D62) or C299 in (the carrier of D64)) by L458 , L451 , XBOOLE_0:def 3;
L460: (C299 in { R1 , R2 } or C299 in { [ <* R1 , R2 *> , R5 ] } or C299 in { [ <* R1 , R2 *> , R5 ] , R4 } or C299 in { [ D63 , R5 ] }) by L459 , L453 , L456 , XBOOLE_0:def 3;
L461: (C299 = R1 or C299 = R2 or C299 = [ <* R1 , R2 *> , R5 ] or C299 = R4 or C299 = [ D63 , R5 ]) by L460 , TARSKI:def 1 , TARSKI:def 2;
L462: (not C299 in ( rng D65 )) by L458 , XBOOLE_0:def 5;
thus L463: thesis by L462 , L454 , L461 , ENUMSET1:def 1 , TARSKI:def 2;
end;

let C300 being set;
assume L464: C300 in { R1 , R2 , R4 };
L465: (C300 = R1 or C300 = R2 or C300 = R4) by L464 , ENUMSET1:def 1;
L466: (C300 in { R1 , R2 } or C300 in ( rng D63 )) by L465 , L455 , TARSKI:def 2;
L467: (C300 in ( InputVertices D62 ) or C300 in ( InputVertices D64 )) by L466 , L452 , CIRCCOMB:42;
L468: C300 in (the carrier of D61) by L467 , L451 , XBOOLE_0:def 3;
L469: ((C300 in { R1 , R2 } & [ <* R1 , R2 *> , R5 ] in ( rng D63 )) or C300 in { R4 }) by L455 , L465 , TARSKI:def 1 , TARSKI:def 2;
L470: ((( the_rank_of C300 ) in ( the_rank_of [ <* R1 , R2 *> , R5 ] ) & ( the_rank_of [ <* R1 , R2 *> , R5 ] ) in ( the_rank_of [ D63 , R5 ] )) or (C300 = R4 & R4 in ( rng D63 ))) by L469 , L452 , L455 , CLASSES1:82 , TARSKI:def 1 , TARSKI:def 2;
L471: ( the_rank_of C300 ) in ( the_rank_of [ D63 , R5 ] ) by L470 , CLASSES1:82 , ORDINAL1:10;
L472: C300 <> [ D63 , R5 ] by L471;
L473: C300 <> [ <* R1 , R2 *> , R5 ] by L450 , L470;
L474: (not C300 in ( rng D65 )) by L473 , L454 , L472 , TARSKI:def 2;
thus L475: thesis by L474 , L468 , XBOOLE_0:def 5;
end;
definition
let C301 , C302 , C303 being set;
let C304 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
func 2GatesCircuit (C301 , C302 , C303 , C304) ->  strict  Boolean  gate`2=den (Circuit of ( 2GatesCircStr (C301 , C302 , C303 , C304) )) equals 
( ( 1GateCircuit (C301 , C302 , C304) ) +* ( 1GateCircuit ([ <* C301 , C302 *> , C304 ] , C303 , C304) ) );
coherence;
end;
theorem
L477: (for R1 being set holds (for R2 being set holds (for R4 being set holds (for R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds ( InnerVertices ( 2GatesCircStr (R1 , R2 , R4 , R5) ) ) is Relation))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
let R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
L478: ( InnerVertices ( 2GatesCircStr (R1 , R2 , R4 , R5) ) ) = { [ <* R1 , R2 *> , R5 ] , ( 2GatesCircOutput (R1 , R2 , R4 , R5) ) } by L446;
thus L479: thesis by L478;
end;
theorem
L480: (for R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (for B348 , B349 , B350 being non  pair set holds ( InputVertices ( 2GatesCircStr (B348 , B349 , B350 , R5) ) ) is  without_pairs))
proof
let R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
let C305 , C306 , C307 being non  pair set;
L481: ( InputVertices ( 2GatesCircStr (C305 , C306 , C307 , R5) ) ) = { C305 , C306 , C307 } by L449;
thus L482: thesis by L481;
end;
theorem
L483: (for R1 being set holds (for R2 being set holds (for R4 being set holds (for R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (R1 in (the carrier of ( 2GatesCircStr (R1 , R2 , R4 , R5) )) & R2 in (the carrier of ( 2GatesCircStr (R1 , R2 , R4 , R5) )) & R4 in (the carrier of ( 2GatesCircStr (R1 , R2 , R4 , R5) )))))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
let R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
set D66 = ( 1GateCircStr (<* R1 , R2 *> , R5) );
set D67 = ( 1GateCircStr (<* [ <* R1 , R2 *> , R5 ] , R4 *> , R5) );
L484: R4 in (the carrier of D67) by L354;
L485: (R1 in (the carrier of D66) & R2 in (the carrier of D66)) by L354;
thus L486: thesis by L485 , L484 , L248;
end;
theorem
L487: (for R1 being set holds (for R2 being set holds (for R4 being set holds (for R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds ([ <* R1 , R2 *> , R5 ] in (the carrier of ( 2GatesCircStr (R1 , R2 , R4 , R5) )) & [ <* [ <* R1 , R2 *> , R5 ] , R4 *> , R5 ] in (the carrier of ( 2GatesCircStr (R1 , R2 , R4 , R5) )))))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
let R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
set D68 = ( 1GateCircStr (<* R1 , R2 *> , R5) );
set D69 = ( 1GateCircStr (<* [ <* R1 , R2 *> , R5 ] , R4 *> , R5) );
L488: ([ <* R1 , R2 *> , R5 ] in (the carrier of D68) & [ <* [ <* R1 , R2 *> , R5 ] , R4 *> , R5 ] in (the carrier of D69)) by L354;
thus L489: thesis by L488 , L248;
end;
definition
let C308 being  unsplit non  void non  empty ManySortedSign;
let C309 being  Boolean (Circuit of C308);
let C310 being (State of C309);
let C311 being (Vertex of C308);
redefine func C310 . C311 -> (Element of ( BOOLEAN ));

coherence
proof
L490: ( C310 . C311 ) in ( (the Sorts of C309) . C311 ) by CIRCUIT1:4;
thus L491: thesis by L490 , CIRCCOMB:def 14;
end;
end;
L493: (for R1 being set holds (for R2 being set holds (for R4 being set holds (for R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (for R6 being (State of ( 2GatesCircuit (R1 , R2 , R4 , R5) )) holds (R4 <> [ <* R1 , R2 *> , R5 ] implies (( ( Following R6 ) . ( 2GatesCircOutput (R1 , R2 , R4 , R5) ) ) = ( R5 . <* ( R6 . [ <* R1 , R2 *> , R5 ] ) , ( R6 . R4 ) *> ) & ( ( Following R6 ) . [ <* R1 , R2 *> , R5 ] ) = ( R5 . <* ( R6 . R1 ) , ( R6 . R2 ) *> ) & ( ( Following R6 ) . R1 ) = ( R6 . R1 ) & ( ( Following R6 ) . R2 ) = ( R6 . R2 ) & ( ( Following R6 ) . R4 ) = ( R6 . R4 ))))))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
let R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
let R6 being (State of ( 2GatesCircuit (R1 , R2 , R4 , R5) ));
set D70 = ( 1GateCircStr (<* R1 , R2 *> , R5) );
set D71 = ( 1GateCircuit (R1 , R2 , R5) );
reconsider D72 = R1 , D73 = R2 as (Vertex of D70) by L354;
reconsider D74 = ( R6 | (the carrier of D70) ) as (State of D71) by L265;
set D75 = <* [ <* R1 , R2 *> , R5 ] , R4 *>;
set D76 = [ <* R1 , R2 *> , R5 ];
set D77 = ( 1GateCircStr (D75 , R5) );
set D78 = ( 1GateCircuit (D76 , R4 , R5) );
set D79 = ( 2GatesCircStr (R1 , R2 , R4 , R5) );
L494: ( dom D74 ) = (the carrier of D70) by CIRCUIT1:3;
reconsider D80 = [ D75 , R5 ] as (Element of ( InnerVertices D77 )) by L380;
L495: ( InnerVertices D79 ) = { [ <* R1 , R2 *> , R5 ] , ( 2GatesCircOutput (R1 , R2 , R4 , R5) ) } by L446;
reconsider D81 = D76 as (Element of ( InnerVertices D79 )) by L495 , TARSKI:def 2;
L496: ( rng D75 ) = { D81 , R4 } by FINSEQ_2:127;
L497: R4 in ( rng D75 ) by L496 , TARSKI:def 2;
L498: R4 in ( InputVertices D77 ) by L497 , CIRCCOMB:42;
L499: D81 in ( rng D75 ) by L496 , TARSKI:def 2;
L500: D81 in ( InputVertices D77 ) by L499 , CIRCCOMB:42;
reconsider D82 = D81 , D83 = R4 as (Vertex of D77) by L500 , L498;
reconsider D84 = D81 as (Element of ( InnerVertices D70 )) by L380;
reconsider D85 = ( R6 | (the carrier of D77) ) as (State of D78) by L265;
L501: ( dom D85 ) = (the carrier of D77) by CIRCUIT1:3;
assume L502: R4 <> [ <* R1 , R2 *> , R5 ];
L503: ( InputVertices D79 ) = { R1 , R2 , R4 } by L502 , L449;
L504: R4 in ( InputVertices D79 ) by L503 , ENUMSET1:def 1;
thus L505: ( ( Following R6 ) . ( 2GatesCircOutput (R1 , R2 , R4 , R5) ) ) = ( ( Following D85 ) . D80 ) by CIRCCOMB:64
.= ( R5 . <* ( D85 . D82 ) , ( D85 . D83 ) *> ) by L384
.= ( R5 . <* ( R6 . [ <* R1 , R2 *> , R5 ] ) , ( D85 . D83 ) *> ) by L501 , FUNCT_1:47
.= ( R5 . <* ( R6 . [ <* R1 , R2 *> , R5 ] ) , ( R6 . R4 ) *> ) by L501 , FUNCT_1:47;
thus L506: ( ( Following R6 ) . [ <* R1 , R2 *> , R5 ] ) = ( ( Following D74 ) . D84 ) by CIRCCOMB:64
.= ( R5 . <* ( D74 . D72 ) , ( D74 . D73 ) *> ) by L384
.= ( R5 . <* ( R6 . R1 ) , ( D74 . D73 ) *> ) by L494 , FUNCT_1:47
.= ( R5 . <* ( R6 . R1 ) , ( R6 . R2 ) *> ) by L494 , FUNCT_1:47;
L507: (R1 in ( InputVertices D79 ) & R2 in ( InputVertices D79 )) by L503 , ENUMSET1:def 1;
thus L508: thesis by L507 , L504 , CIRCUIT2:def 5;
end;
theorem
L509: (for R1 being set holds (for R2 being set holds (for R4 being set holds (for R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (for R6 being (State of ( 2GatesCircuit (R1 , R2 , R4 , R5) )) holds (R4 <> [ <* R1 , R2 *> , R5 ] implies (( ( Following (R6 , 2) ) . ( 2GatesCircOutput (R1 , R2 , R4 , R5) ) ) = ( R5 . <* ( R5 . <* ( R6 . R1 ) , ( R6 . R2 ) *> ) , ( R6 . R4 ) *> ) & ( ( Following (R6 , 2) ) . [ <* R1 , R2 *> , R5 ] ) = ( R5 . <* ( R6 . R1 ) , ( R6 . R2 ) *> ) & ( ( Following (R6 , 2) ) . R1 ) = ( R6 . R1 ) & ( ( Following (R6 , 2) ) . R2 ) = ( R6 . R2 ) & ( ( Following (R6 , 2) ) . R4 ) = ( R6 . R4 ))))))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
let R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
let R6 being (State of ( 2GatesCircuit (R1 , R2 , R4 , R5) ));
set D86 = ( 2GatesCircStr (R1 , R2 , R4 , R5) );
L510: ( rng <* R1 , R2 *> ) = { R1 , R2 } by FINSEQ_2:127;
reconsider D87 = R1 , D88 = R2 , D89 = R4 as (Vertex of D86) by L483;
set D90 = <* [ <* R1 , R2 *> , R5 ] , R4 *>;
set D91 = [ <* R1 , R2 *> , R5 ];
set D92 = ( 1GateCircStr (<* R1 , R2 *> , R5) );
set D93 = ( 1GateCircuit (R1 , R2 , R5) );
set D94 = ( 1GateCircStr (D90 , R5) );
set D95 = ( 1GateCircuit (D91 , R4 , R5) );
L511: R1 in { R1 , R2 } by TARSKI:def 2;
assume L512: R4 <> [ <* R1 , R2 *> , R5 ];
L513: ( InputVertices D86 ) = { R1 , R2 , R4 } by L512 , L449;
L514: R1 in ( InputVertices D86 ) by L513 , ENUMSET1:def 1;
L515: ( ( Following R6 ) . D87 ) = ( R6 . R1 ) by L514 , CIRCUIT2:def 5;
L516: ( InnerVertices D86 ) = { [ <* R1 , R2 *> , R5 ] , ( 2GatesCircOutput (R1 , R2 , R4 , R5) ) } by L446;
reconsider D96 = D91 as (Element of ( InnerVertices D86 )) by L516 , TARSKI:def 2;
L517: ( rng D90 ) = { D96 , R4 } by FINSEQ_2:127;
L518: R4 in ( rng D90 ) by L517 , TARSKI:def 2;
L519: R4 in ( InputVertices D94 ) by L518 , CIRCCOMB:42;
L520: D96 in ( rng D90 ) by L517 , TARSKI:def 2;
L521: D96 in ( InputVertices D94 ) by L520 , CIRCCOMB:42;
reconsider D97 = D96 , D98 = R4 as (Vertex of D94) by L521 , L519;
reconsider D99 = R1 , D100 = R2 as (Vertex of D92) by L354;
set D101 = ( Following R6 );
reconsider D102 = ( D101 | (the carrier of D92) ) as (State of D93) by L265;
L522: R2 in { R1 , R2 } by TARSKI:def 2;
reconsider D103 = ( D101 | (the carrier of D94) ) as (State of D95) by L265;
reconsider D104 = ( R6 | (the carrier of D92) ) as (State of D93) by L265;
L523: ( dom D103 ) = (the carrier of D94) by CIRCUIT1:3;
L524: R4 in ( InputVertices D86 ) by L513 , ENUMSET1:def 1;
L525: ( ( Following R6 ) . D89 ) = ( R6 . R4 ) by L524 , CIRCUIT2:def 5;
L526: ( ( Following ( Following R6 ) ) . D89 ) = ( R6 . R4 ) by L525 , L524 , CIRCUIT2:def 5;
reconsider D105 = D96 as (Element of ( InnerVertices D92 )) by L380;
L527: ( dom D102 ) = (the carrier of D92) by CIRCUIT1:3;
reconsider D106 = [ D90 , R5 ] as (Element of ( InnerVertices D94 )) by L380;
L528: D96 in ( InnerVertices D92 ) by L380;
L529: (( dom D104 ) = (the carrier of D92) & ( InputVertices D92 ) = ( rng <* R1 , R2 *> )) by CIRCCOMB:42 , CIRCUIT1:3;
L530: ( Following (R6 , ( 1 + 1 )) ) = ( Following ( Following R6 ) ) by L214;
thus L531: ( ( Following (R6 , 2) ) . ( 2GatesCircOutput (R1 , R2 , R4 , R5) ) ) = ( ( Following D103 ) . D106 ) by L530 , CIRCCOMB:64
.= ( R5 . <* ( D103 . D97 ) , ( D103 . D98 ) *> ) by L384
.= ( R5 . <* ( ( Following R6 ) . D96 ) , ( D103 . R4 ) *> ) by L523 , FUNCT_1:47
.= ( R5 . <* ( ( Following R6 ) . D96 ) , ( ( Following R6 ) . D98 ) *> ) by L523 , FUNCT_1:47
.= ( R5 . <* ( ( Following R6 ) . D96 ) , ( R6 . D89 ) *> ) by L524 , CIRCUIT2:def 5
.= ( R5 . <* ( ( Following D104 ) . D96 ) , ( R6 . D89 ) *> ) by L528 , CIRCCOMB:64
.= ( R5 . <* ( R5 . <* ( D104 . R1 ) , ( D104 . R2 ) *> ) , ( R6 . D89 ) *> ) by L384
.= ( R5 . <* ( R5 . <* ( R6 . R1 ) , ( D104 . R2 ) *> ) , ( R6 . D89 ) *> ) by L511 , L529 , L510 , FUNCT_1:47
.= ( R5 . <* ( R5 . <* ( R6 . R1 ) , ( R6 . R2 ) *> ) , ( R6 . R4 ) *> ) by L522 , L529 , L510 , FUNCT_1:47;
L532: R2 in ( InputVertices D86 ) by L513 , ENUMSET1:def 1;
L533: ( ( Following R6 ) . D88 ) = ( R6 . R2 ) by L532 , CIRCUIT2:def 5;
L534: ( ( Following ( Following R6 ) ) . D88 ) = ( R6 . R2 ) by L533 , L532 , CIRCUIT2:def 5;
thus L535: ( ( Following (R6 , 2) ) . [ <* R1 , R2 *> , R5 ] ) = ( ( Following D102 ) . D105 ) by L530 , CIRCCOMB:64
.= ( R5 . <* ( D102 . D99 ) , ( D102 . D100 ) *> ) by L384
.= ( R5 . <* ( R6 . R1 ) , ( D102 . D100 ) *> ) by L515 , L527 , FUNCT_1:47
.= ( R5 . <* ( R6 . R1 ) , ( R6 . R2 ) *> ) by L533 , L527 , FUNCT_1:47;
L536: ( ( Following ( Following R6 ) ) . D87 ) = ( R6 . R1 ) by L514 , L515 , CIRCUIT2:def 5;
thus L537: thesis by L536 , L534 , L526 , L214;
end;
theorem
L538: (for R1 being set holds (for R2 being set holds (for R4 being set holds (for R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (for R6 being (State of ( 2GatesCircuit (R1 , R2 , R4 , R5) )) holds (R4 <> [ <* R1 , R2 *> , R5 ] implies ( Following (R6 , 2) ) is  stable))))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
let R5 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
let R6 being (State of ( 2GatesCircuit (R1 , R2 , R4 , R5) ));
set D107 = ( 2GatesCircStr (R1 , R2 , R4 , R5) );
assume L539: R4 <> [ <* R1 , R2 *> , R5 ];
L540:
now
thus L541: (( dom ( Following ( Following (R6 , 2) ) ) ) = (the carrier of D107) & ( dom ( Following (R6 , 2) ) ) = (the carrier of D107)) by CIRCUIT1:3;
let C312 being set;
L542: ( ( InputVertices D107 ) \/ ( InnerVertices D107 ) ) = (the carrier of D107) by XBOOLE_1:45;
assume L543: C312 in (the carrier of D107);
reconsider D108 = C312 as (Vertex of D107) by L543;
L544: ( InnerVertices D107 ) = { [ <* R1 , R2 *> , R5 ] , ( 2GatesCircOutput (R1 , R2 , R4 , R5) ) } by L446;
L545: ( ( Following (R6 , 2) ) . R4 ) = ( R6 . R4 ) by L539 , L509;
L546: (( ( Following (R6 , 2) ) . R1 ) = ( R6 . R1 ) & ( ( Following (R6 , 2) ) . R2 ) = ( R6 . R2 )) by L539 , L509;
L547: (( ( Following (R6 , 2) ) . [ <* R1 , R2 *> , R5 ] ) = ( R5 . <* ( R6 . R1 ) , ( R6 . R2 ) *> ) & ( ( Following (R6 , 2) ) . ( 2GatesCircOutput (R1 , R2 , R4 , R5) ) ) = ( R5 . <* ( R5 . <* ( R6 . R1 ) , ( R6 . R2 ) *> ) , ( R6 . R4 ) *> )) by L539 , L509;
L548: ( InputVertices D107 ) = { R1 , R2 , R4 } by L539 , L449;
per cases  by L542 , XBOOLE_0:def 3;
suppose L549: D108 in ( InputVertices D107 );

L550: (D108 = R1 or D108 = R2 or D108 = R4) by L549 , L548 , ENUMSET1:def 1;
thus L551: ( ( Following ( Following (R6 , 2) ) ) . C312 ) = ( ( Following (R6 , 2) ) . C312 ) by L550 , L539 , L493;
end;
suppose L552: D108 in ( InnerVertices D107 );

L553: (D108 = [ <* R1 , R2 *> , R5 ] or D108 = ( 2GatesCircOutput (R1 , R2 , R4 , R5) )) by L552 , L544 , TARSKI:def 2;
thus L554: ( ( Following ( Following (R6 , 2) ) ) . C312 ) = ( ( Following (R6 , 2) ) . C312 ) by L553 , L539 , L547 , L546 , L545 , L493;
end;
end;
thus L556: ( Following (R6 , 2) ) = ( Following ( Following (R6 , 2) ) ) by L540 , FUNCT_1:2;
end;
theorem
L557: (for R1 being set holds (for R2 being set holds (for R4 being set holds (R4 <> [ <* R1 , R2 *> , ( 'xor' ) ] implies (for B351 being (State of ( 2GatesCircuit (R1 , R2 , R4 , ( 'xor' )) )) holds (for B352 , B353 , B354 being (Element of ( BOOLEAN )) holds ((B352 = ( B351 . R1 ) & B353 = ( B351 . R2 ) & B354 = ( B351 . R4 )) implies ( ( Following (B351 , 2) ) . ( 2GatesCircOutput (R1 , R2 , R4 , ( 'xor' )) ) ) = ( ( B352 'xor' B353 ) 'xor' B354 ))))))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
set D109 = ( 'xor' );
assume L558: R4 <> [ <* R1 , R2 *> , D109 ];
let C313 being (State of ( 2GatesCircuit (R1 , R2 , R4 , D109) ));
let C314 , C315 , C316 being (Element of ( BOOLEAN ));
assume L559: (C314 = ( C313 . R1 ) & C315 = ( C313 . R2 ) & C316 = ( C313 . R4 ));
thus L560: ( ( Following (C313 , 2) ) . ( 2GatesCircOutput (R1 , R2 , R4 , D109) ) ) = ( D109 . <* ( D109 . <* C314 , C315 *> ) , C316 *> ) by L559 , L558 , L509
.= ( D109 . <* ( C314 'xor' C315 ) , C316 *> ) by L173
.= ( ( C314 'xor' C315 ) 'xor' C316 ) by L173;
end;
theorem
L561: (for R1 being set holds (for R2 being set holds (for R4 being set holds (R4 <> [ <* R1 , R2 *> , ( 'or' ) ] implies (for B355 being (State of ( 2GatesCircuit (R1 , R2 , R4 , ( 'or' )) )) holds (for B356 , B357 , B358 being (Element of ( BOOLEAN )) holds ((B356 = ( B355 . R1 ) & B357 = ( B355 . R2 ) & B358 = ( B355 . R4 )) implies ( ( Following (B355 , 2) ) . ( 2GatesCircOutput (R1 , R2 , R4 , ( 'or' )) ) ) = ( ( B356 'or' B357 ) 'or' B358 ))))))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
set D110 = ( 'or' );
assume L562: R4 <> [ <* R1 , R2 *> , D110 ];
let C317 being (State of ( 2GatesCircuit (R1 , R2 , R4 , D110) ));
let C318 , C319 , C320 being (Element of ( BOOLEAN ));
assume L563: (C318 = ( C317 . R1 ) & C319 = ( C317 . R2 ) & C320 = ( C317 . R4 ));
thus L564: ( ( Following (C317 , 2) ) . ( 2GatesCircOutput (R1 , R2 , R4 , D110) ) ) = ( D110 . <* ( D110 . <* C318 , C319 *> ) , C320 *> ) by L563 , L562 , L509
.= ( D110 . <* ( C318 'or' C319 ) , C320 *> ) by L176
.= ( ( C318 'or' C319 ) 'or' C320 ) by L176;
end;
theorem
L565: (for R1 being set holds (for R2 being set holds (for R4 being set holds (R4 <> [ <* R1 , R2 *> , ( '&' ) ] implies (for B359 being (State of ( 2GatesCircuit (R1 , R2 , R4 , ( '&' )) )) holds (for B360 , B361 , B362 being (Element of ( BOOLEAN )) holds ((B360 = ( B359 . R1 ) & B361 = ( B359 . R2 ) & B362 = ( B359 . R4 )) implies ( ( Following (B359 , 2) ) . ( 2GatesCircOutput (R1 , R2 , R4 , ( '&' )) ) ) = ( ( B360 '&' B361 ) '&' B362 ))))))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
set D111 = ( '&' );
assume L566: R4 <> [ <* R1 , R2 *> , D111 ];
let C321 being (State of ( 2GatesCircuit (R1 , R2 , R4 , D111) ));
let C322 , C323 , C324 being (Element of ( BOOLEAN ));
assume L567: (C322 = ( C321 . R1 ) & C323 = ( C321 . R2 ) & C324 = ( C321 . R4 ));
thus L568: ( ( Following (C321 , 2) ) . ( 2GatesCircOutput (R1 , R2 , R4 , D111) ) ) = ( D111 . <* ( D111 . <* C322 , C323 *> ) , C324 *> ) by L567 , L566 , L509
.= ( D111 . <* ( C322 '&' C323 ) , C324 *> ) by L179
.= ( ( C322 '&' C323 ) '&' C324 ) by L179;
end;
begin
definition
let C325 , C326 , C327 being set;
func BitAdderOutput (C325 , C326 , C327) -> (Element of ( InnerVertices ( 2GatesCircStr (C325 , C326 , C327 , ( 'xor' )) ) )) equals 
( 2GatesCircOutput (C325 , C326 , C327 , ( 'xor' )) );
coherence;
end;
definition
let C328 , C329 , C330 being set;
func BitAdderCirc (C328 , C329 , C330) ->  strict  Boolean  gate`2=den (Circuit of ( 2GatesCircStr (C328 , C329 , C330 , ( 'xor' )) )) equals 
( 2GatesCircuit (C328 , C329 , C330 , ( 'xor' )) );
coherence;
end;
definition
let C331 , C332 , C333 being set;
func MajorityIStr (C331 , C332 , C333) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( ( 1GateCircStr (<* C331 , C332 *> , ( '&' )) ) +* ( 1GateCircStr (<* C332 , C333 *> , ( '&' )) ) ) +* ( 1GateCircStr (<* C333 , C331 *> , ( '&' )) ) );
correctness;
end;
definition
let C334 , C335 , C336 being set;
func MajorityStr (C334 , C335 , C336) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( MajorityIStr (C334 , C335 , C336) ) +* ( 1GateCircStr (<* [ <* C334 , C335 *> , ( '&' ) ] , [ <* C335 , C336 *> , ( '&' ) ] , [ <* C336 , C334 *> , ( '&' ) ] *> , ( or3 )) ) );
correctness;
end;
definition
let C337 , C338 , C339 being set;
func MajorityICirc (C337 , C338 , C339) ->  strict  Boolean  gate`2=den (Circuit of ( MajorityIStr (C337 , C338 , C339) )) equals 
( ( ( 1GateCircuit (C337 , C338 , ( '&' )) ) +* ( 1GateCircuit (C338 , C339 , ( '&' )) ) ) +* ( 1GateCircuit (C339 , C337 , ( '&' )) ) );
coherence;
end;
theorem
L574: (for R1 being set holds (for R2 being set holds (for R4 being set holds ( InnerVertices ( MajorityStr (R1 , R2 , R4) ) ) is Relation)))
proof
let R1 being set;
let R2 being set;
let R4 being set;
L575: ( InnerVertices ( 1GateCircStr (<* [ <* R1 , R2 *> , ( '&' ) ] , [ <* R2 , R4 *> , ( '&' ) ] , [ <* R4 , R1 *> , ( '&' ) ] *> , ( or3 )) ) ) is Relation by L340;
L576: (( InnerVertices ( 1GateCircStr (<* R1 , R2 *> , ( '&' )) ) ) is Relation & ( InnerVertices ( 1GateCircStr (<* R2 , R4 *> , ( '&' )) ) ) is Relation) by L340;
L577: ( InnerVertices ( ( 1GateCircStr (<* R1 , R2 *> , ( '&' )) ) +* ( 1GateCircStr (<* R2 , R4 *> , ( '&' )) ) ) ) is Relation by L576 , L79 , CIRCCOMB:47;
L578: ( InnerVertices ( 1GateCircStr (<* R4 , R1 *> , ( '&' )) ) ) is Relation by L340;
L579: ( InnerVertices ( MajorityIStr (R1 , R2 , R4) ) ) is Relation by L578 , L577 , L79 , CIRCCOMB:47;
thus L580: thesis by L579 , L575 , L79 , CIRCCOMB:47;
end;
theorem
L581: (for B363 , B364 , B365 being non  pair set holds ( InputVertices ( MajorityStr (B363 , B364 , B365) ) ) is  without_pairs)
proof
let C340 , C341 , C342 being non  pair set;
set D112 = ( MajorityStr (C340 , C341 , C342) );
set D113 = ( MajorityIStr (C340 , C341 , C342) );
set D114 = ( 1GateCircStr (<* [ <* C340 , C341 *> , ( '&' ) ] , [ <* C341 , C342 *> , ( '&' ) ] , [ <* C342 , C340 *> , ( '&' ) ] *> , ( or3 )) );
given C343 being  pair set such that
L582: C343 in ( InputVertices D112 );

L583: ( 1GateCircStr (<* C340 , C341 *> , ( '&' )) ) tolerates ( 1GateCircStr (<* C341 , C342 *> , ( '&' )) ) by CIRCCOMB:43;
L584: (( 1GateCircStr (<* C340 , C341 *> , ( '&' )) ) tolerates ( 1GateCircStr (<* C342 , C340 *> , ( '&' )) ) & ( 1GateCircStr (<* C341 , C342 *> , ( '&' )) ) tolerates ( 1GateCircStr (<* C342 , C340 *> , ( '&' )) )) by CIRCCOMB:43;
L585: ( ( 1GateCircStr (<* C340 , C341 *> , ( '&' )) ) +* ( 1GateCircStr (<* C341 , C342 *> , ( '&' )) ) ) tolerates ( 1GateCircStr (<* C342 , C340 *> , ( '&' )) ) by L584 , L583 , CIRCCOMB:3;
L586: (( InnerVertices ( 1GateCircStr (<* C340 , C341 *> , ( '&' )) ) ) = { [ <* C340 , C341 *> , ( '&' ) ] } & ( InnerVertices ( 1GateCircStr (<* C341 , C342 *> , ( '&' )) ) ) = { [ <* C341 , C342 *> , ( '&' ) ] }) by CIRCCOMB:42;
L587: (( InnerVertices ( 1GateCircStr (<* C342 , C340 *> , ( '&' )) ) ) = { [ <* C342 , C340 *> , ( '&' ) ] } & ( InnerVertices ( ( 1GateCircStr (<* C340 , C341 *> , ( '&' )) ) +* ( 1GateCircStr (<* C341 , C342 *> , ( '&' )) ) ) ) = ( { [ <* C340 , C341 *> , ( '&' ) ] } \/ { [ <* C341 , C342 *> , ( '&' ) ] } )) by L586 , L583 , CIRCCOMB:11 , CIRCCOMB:42;
L588: ( InnerVertices D113 ) = ( ( { [ <* C340 , C341 *> , ( '&' ) ] } \/ { [ <* C341 , C342 *> , ( '&' ) ] } ) \/ { [ <* C342 , C340 *> , ( '&' ) ] } ) by L587 , L585 , CIRCCOMB:11
.= ( { [ <* C340 , C341 *> , ( '&' ) ] , [ <* C341 , C342 *> , ( '&' ) ] } \/ { [ <* C342 , C340 *> , ( '&' ) ] } ) by ENUMSET1:1
.= { [ <* C340 , C341 *> , ( '&' ) ] , [ <* C341 , C342 *> , ( '&' ) ] , [ <* C342 , C340 *> , ( '&' ) ] } by ENUMSET1:3;
L589: ( InputVertices D114 ) = { [ <* C340 , C341 *> , ( '&' ) ] , [ <* C341 , C342 *> , ( '&' ) ] , [ <* C342 , C340 *> , ( '&' ) ] } by L352;
L590: ( ( InputVertices D114 ) \ ( InnerVertices D113 ) ) = ( {} ) by L589 , L588 , XBOOLE_1:37;
L591: (( InputVertices ( 1GateCircStr (<* C340 , C341 *> , ( '&' )) ) ) is  without_pairs & ( InputVertices ( 1GateCircStr (<* C341 , C342 *> , ( '&' )) ) ) is  without_pairs) by L348;
L592: ( InputVertices ( ( 1GateCircStr (<* C340 , C341 *> , ( '&' )) ) +* ( 1GateCircStr (<* C341 , C342 *> , ( '&' )) ) ) ) is  without_pairs by L591 , L129 , CIRCCOMB:47;
L593: ( InputVertices ( 1GateCircStr (<* C342 , C340 *> , ( '&' )) ) ) is  without_pairs by L348;
L594: ( InputVertices D113 ) is  without_pairs by L593 , L592 , L129 , CIRCCOMB:47;
L595: ( InnerVertices D114 ) is Relation by L340;
L596: ( InputVertices D112 ) = ( ( InputVertices D113 ) \/ ( ( InputVertices D114 ) \ ( InnerVertices D113 ) ) ) by L595 , L594 , L121;
thus L597: thesis by L596 , L594 , L582 , L590 , L11;
end;
theorem
L598: (for R1 being set holds (for R2 being set holds (for R4 being set holds (for B366 being (State of ( MajorityICirc (R1 , R2 , R4) )) holds (for B367 , B368 being (Element of ( BOOLEAN )) holds ((B367 = ( B366 . R1 ) & B368 = ( B366 . R2 )) implies ( ( Following B366 ) . [ <* R1 , R2 *> , ( '&' ) ] ) = ( B367 '&' B368 )))))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
set D115 = <* R1 , R2 *>;
set D116 = ( 1GateCircStr (D115 , ( '&' )) );
set D117 = ( 1GateCircuit (R1 , R2 , ( '&' )) );
reconsider D118 = R1 , D119 = R2 as (Vertex of D116) by L354;
reconsider D120 = [ D115 , ( '&' ) ] as (Element of ( InnerVertices D116 )) by L380;
set D121 = ( 1GateCircStr (<* R2 , R4 *> , ( '&' )) );
set D122 = ( 1GateCircuit (R2 , R4 , ( '&' )) );
set D123 = ( 1GateCircStr (<* R4 , R1 *> , ( '&' )) );
set D124 = ( 1GateCircuit (R4 , R1 , ( '&' )) );
set D125 = ( MajorityIStr (R1 , R2 , R4) );
set D126 = ( MajorityICirc (R1 , R2 , R4) );
let C344 being (State of D126);
let C345 , C346 being (Element of ( BOOLEAN ));
assume that
L599: (C345 = ( C344 . R1 ) & C346 = ( C344 . R2 ));
L600: D126 = ( D117 +* ( D122 +* D124 ) ) by L261;
reconsider D127 = ( C344 | (the carrier of D116) ) as (State of D117) by L600 , L265;
L601: D125 = ( D116 +* ( D121 +* D123 ) ) by CIRCCOMB:6;
reconsider D128 = D120 as (Element of ( InnerVertices D125 )) by L601 , L251;
reconsider D129 = D118 , D130 = D119 as (Vertex of D125) by L601 , L248;
L602: ( dom D127 ) = (the carrier of D116) by CIRCUIT1:3;
thus L603: ( ( Following C344 ) . [ D115 , ( '&' ) ] ) = ( ( Following D127 ) . D128 ) by L601 , L600 , CIRCCOMB:64
.= ( ( '&' ) . <* ( D127 . D129 ) , ( D127 . D130 ) *> ) by L384
.= ( ( '&' ) . <* ( C344 . D129 ) , ( D127 . D130 ) *> ) by L602 , FUNCT_1:47
.= ( ( '&' ) . <* ( C344 . D129 ) , ( C344 . D130 ) *> ) by L602 , FUNCT_1:47
.= ( C345 '&' C346 ) by L599 , L179;
end;
theorem
L604: (for R1 being set holds (for R2 being set holds (for R4 being set holds (for B369 being (State of ( MajorityICirc (R1 , R2 , R4) )) holds (for B370 , B371 being (Element of ( BOOLEAN )) holds ((B370 = ( B369 . R2 ) & B371 = ( B369 . R4 )) implies ( ( Following B369 ) . [ <* R2 , R4 *> , ( '&' ) ] ) = ( B370 '&' B371 )))))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
set D131 = <* R2 , R4 *>;
set D132 = ( 1GateCircStr (D131 , ( '&' )) );
set D133 = ( 1GateCircuit (R2 , R4 , ( '&' )) );
reconsider D134 = R2 , D135 = R4 as (Vertex of D132) by L354;
reconsider D136 = [ D131 , ( '&' ) ] as (Element of ( InnerVertices D132 )) by L380;
set D137 = ( 1GateCircStr (<* R1 , R2 *> , ( '&' )) );
set D138 = ( 1GateCircuit (R1 , R2 , ( '&' )) );
set D139 = ( 1GateCircStr (<* R4 , R1 *> , ( '&' )) );
set D140 = ( 1GateCircuit (R4 , R1 , ( '&' )) );
set D141 = ( MajorityIStr (R1 , R2 , R4) );
set D142 = ( MajorityICirc (R1 , R2 , R4) );
let C347 being (State of D142);
let C348 , C349 being (Element of ( BOOLEAN ));
assume that
L605: (C348 = ( C347 . R2 ) & C349 = ( C347 . R4 ));
L606: ( D137 +* D132 ) = ( D132 +* D137 ) by CIRCCOMB:5 , CIRCCOMB:47;
L607: D141 = ( D132 +* ( D137 +* D139 ) ) by L606 , CIRCCOMB:6;
reconsider D143 = D136 as (Element of ( InnerVertices D141 )) by L607 , L251;
L608: ( D138 +* D133 ) = ( D133 +* D138 ) by CIRCCOMB:22 , CIRCCOMB:60;
L609: D142 = ( D133 +* ( D138 +* D140 ) ) by L608 , L606 , L261;
reconsider D144 = ( C347 | (the carrier of D132) ) as (State of D133) by L609 , L265;
reconsider D145 = D134 , D146 = D135 as (Vertex of D141) by L607 , L248;
L610: ( dom D144 ) = (the carrier of D132) by CIRCUIT1:3;
thus L611: ( ( Following C347 ) . [ D131 , ( '&' ) ] ) = ( ( Following D144 ) . D143 ) by L607 , L609 , CIRCCOMB:64
.= ( ( '&' ) . <* ( D144 . D145 ) , ( D144 . D146 ) *> ) by L384
.= ( ( '&' ) . <* ( C347 . D145 ) , ( D144 . D146 ) *> ) by L610 , FUNCT_1:47
.= ( ( '&' ) . <* ( C347 . D145 ) , ( C347 . D146 ) *> ) by L610 , FUNCT_1:47
.= ( C348 '&' C349 ) by L605 , L179;
end;
theorem
L612: (for R1 being set holds (for R2 being set holds (for R4 being set holds (for B372 being (State of ( MajorityICirc (R1 , R2 , R4) )) holds (for B373 , B374 being (Element of ( BOOLEAN )) holds ((B373 = ( B372 . R4 ) & B374 = ( B372 . R1 )) implies ( ( Following B372 ) . [ <* R4 , R1 *> , ( '&' ) ] ) = ( B373 '&' B374 )))))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
set D147 = <* R4 , R1 *>;
set D148 = ( 1GateCircStr (D147 , ( '&' )) );
set D149 = ( 1GateCircuit (R4 , R1 , ( '&' )) );
reconsider D150 = R4 , D151 = R1 as (Vertex of D148) by L354;
reconsider D152 = [ D147 , ( '&' ) ] as (Element of ( InnerVertices D148 )) by L380;
set D153 = ( MajorityIStr (R1 , R2 , R4) );
set D154 = ( MajorityICirc (R1 , R2 , R4) );
let C350 being (State of D154);
let C351 , C352 being (Element of ( BOOLEAN ));
assume that
L613: (C351 = ( C350 . R4 ) & C352 = ( C350 . R1 ));
reconsider D155 = D150 , D156 = D151 as (Vertex of D153) by L248;
reconsider D157 = ( C350 | (the carrier of D148) ) as (State of D149) by L265;
reconsider D158 = D152 as (Element of ( InnerVertices D153 )) by L251;
L614: ( dom D157 ) = (the carrier of D148) by CIRCUIT1:3;
thus L615: ( ( Following C350 ) . [ D147 , ( '&' ) ] ) = ( ( Following D157 ) . D158 ) by CIRCCOMB:64
.= ( ( '&' ) . <* ( D157 . D155 ) , ( D157 . D156 ) *> ) by L384
.= ( ( '&' ) . <* ( C350 . D155 ) , ( D157 . D156 ) *> ) by L614 , FUNCT_1:47
.= ( ( '&' ) . <* ( C350 . D155 ) , ( C350 . D156 ) *> ) by L614 , FUNCT_1:47
.= ( C351 '&' C352 ) by L613 , L179;
end;
definition
let C353 , C354 , C355 being set;
func MajorityOutput (C353 , C354 , C355) -> (Element of ( InnerVertices ( MajorityStr (C353 , C354 , C355) ) )) equals 
[ <* [ <* C353 , C354 *> , ( '&' ) ] , [ <* C354 , C355 *> , ( '&' ) ] , [ <* C355 , C353 *> , ( '&' ) ] *> , ( or3 ) ];
coherence
proof
L616: [ <* [ <* C353 , C354 *> , ( '&' ) ] , [ <* C354 , C355 *> , ( '&' ) ] , [ <* C355 , C353 *> , ( '&' ) ] *> , ( or3 ) ] in ( InnerVertices ( 1GateCircStr (<* [ <* C353 , C354 *> , ( '&' ) ] , [ <* C354 , C355 *> , ( '&' ) ] , [ <* C355 , C353 *> , ( '&' ) ] *> , ( or3 )) ) ) by L380;
thus L617: thesis by L616 , L251;
end;
correctness;
end;
definition
let C356 , C357 , C358 being set;
func MajorityCirc (C356 , C357 , C358) ->  strict  Boolean  gate`2=den (Circuit of ( MajorityStr (C356 , C357 , C358) )) equals 
( ( MajorityICirc (C356 , C357 , C358) ) +* ( 1GateCircuit ([ <* C356 , C357 *> , ( '&' ) ] , [ <* C357 , C358 *> , ( '&' ) ] , [ <* C358 , C356 *> , ( '&' ) ] , ( or3 )) ) );
coherence;
end;
theorem
L620: (for R1 being set holds (for R2 being set holds (for R4 being set holds (R1 in (the carrier of ( MajorityStr (R1 , R2 , R4) )) & R2 in (the carrier of ( MajorityStr (R1 , R2 , R4) )) & R4 in (the carrier of ( MajorityStr (R1 , R2 , R4) ))))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
L621: R4 in (the carrier of ( 1GateCircStr (<* R4 , R1 *> , ( '&' )) )) by L354;
L622: R4 in (the carrier of ( MajorityIStr (R1 , R2 , R4) )) by L621 , L248;
L623: R2 in (the carrier of ( 1GateCircStr (<* R1 , R2 *> , ( '&' )) )) by L354;
L624: R2 in (the carrier of ( ( 1GateCircStr (<* R1 , R2 *> , ( '&' )) ) +* ( 1GateCircStr (<* R2 , R4 *> , ( '&' )) ) )) by L623 , L248;
L625: R2 in (the carrier of ( MajorityIStr (R1 , R2 , R4) )) by L624 , L248;
L626: R1 in (the carrier of ( 1GateCircStr (<* R4 , R1 *> , ( '&' )) )) by L354;
L627: R1 in (the carrier of ( MajorityIStr (R1 , R2 , R4) )) by L626 , L248;
thus L628: thesis by L627 , L625 , L622 , L248;
end;
theorem
L629: (for R1 being set holds (for R2 being set holds (for R4 being set holds ([ <* R1 , R2 *> , ( '&' ) ] in ( InnerVertices ( MajorityStr (R1 , R2 , R4) ) ) & [ <* R2 , R4 *> , ( '&' ) ] in ( InnerVertices ( MajorityStr (R1 , R2 , R4) ) ) & [ <* R4 , R1 *> , ( '&' ) ] in ( InnerVertices ( MajorityStr (R1 , R2 , R4) ) )))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
L630: [ <* R1 , R2 *> , ( '&' ) ] in ( InnerVertices ( 1GateCircStr (<* R1 , R2 *> , ( '&' )) ) ) by L380;
L631: [ <* R1 , R2 *> , ( '&' ) ] in ( InnerVertices ( ( 1GateCircStr (<* R1 , R2 *> , ( '&' )) ) +* ( 1GateCircStr (<* R2 , R4 *> , ( '&' )) ) ) ) by L630 , L251;
L632: [ <* R1 , R2 *> , ( '&' ) ] in ( InnerVertices ( MajorityIStr (R1 , R2 , R4) ) ) by L631 , L251;
L633: [ <* R2 , R4 *> , ( '&' ) ] in ( InnerVertices ( 1GateCircStr (<* R2 , R4 *> , ( '&' )) ) ) by L380;
L634: [ <* R2 , R4 *> , ( '&' ) ] in ( InnerVertices ( ( 1GateCircStr (<* R1 , R2 *> , ( '&' )) ) +* ( 1GateCircStr (<* R2 , R4 *> , ( '&' )) ) ) ) by L633 , L251;
L635: [ <* R2 , R4 *> , ( '&' ) ] in ( InnerVertices ( MajorityIStr (R1 , R2 , R4) ) ) by L634 , L251;
L636: [ <* R4 , R1 *> , ( '&' ) ] in ( InnerVertices ( 1GateCircStr (<* R4 , R1 *> , ( '&' )) ) ) by L380;
L637: [ <* R4 , R1 *> , ( '&' ) ] in ( InnerVertices ( MajorityIStr (R1 , R2 , R4) ) ) by L636 , L251;
thus L638: thesis by L637 , L632 , L635 , L251;
end;
theorem
L639: (for B375 , B376 , B377 being non  pair set holds (B375 in ( InputVertices ( MajorityStr (B375 , B376 , B377) ) ) & B376 in ( InputVertices ( MajorityStr (B375 , B376 , B377) ) ) & B377 in ( InputVertices ( MajorityStr (B375 , B376 , B377) ) )))
proof
let C359 , C360 , C361 being non  pair set;
assume L640: (not thesis);
L641: C361 in (the carrier of ( MajorityStr (C359 , C360 , C361) )) by L620;
L642: ( InnerVertices ( MajorityStr (C359 , C360 , C361) ) ) is Relation by L574;
L643: (C359 in (the carrier of ( MajorityStr (C359 , C360 , C361) )) & C360 in (the carrier of ( MajorityStr (C359 , C360 , C361) ))) by L620;
L644: (C359 in ( InnerVertices ( MajorityStr (C359 , C360 , C361) ) ) or C360 in ( InnerVertices ( MajorityStr (C359 , C360 , C361) ) ) or C361 in ( InnerVertices ( MajorityStr (C359 , C360 , C361) ) )) by L643 , L641 , L640 , XBOOLE_0:def 5;
L645: ((ex B378 , B379 being set st C359 = [ B378 , B379 ]) or (ex B380 , B381 being set st C360 = [ B380 , B381 ]) or (ex B382 , B383 being set st C361 = [ B382 , B383 ])) by L644 , L642 , RELAT_1:def 1;
thus L646: contradiction by L645;
end;
theorem
L647: (for B384 , B385 , B386 being non  pair set holds (( InputVertices ( MajorityStr (B384 , B385 , B386) ) ) = { B384 , B385 , B386 } & ( InnerVertices ( MajorityStr (B384 , B385 , B386) ) ) = ( { [ <* B384 , B385 *> , ( '&' ) ] , [ <* B385 , B386 *> , ( '&' ) ] , [ <* B386 , B384 *> , ( '&' ) ] } \/ { ( MajorityOutput (B384 , B385 , B386) ) } )))
proof
let C362 , C363 , C364 being non  pair set;
set D159 = [ <* C362 , C363 *> , ( '&' ) ];
set D160 = [ <* C363 , C364 *> , ( '&' ) ];
set D161 = [ <* C364 , C362 *> , ( '&' ) ];
set D162 = ( MajorityIStr (C362 , C363 , C364) );
set D163 = ( 1GateCircStr (<* D159 , D160 , D161 *> , ( or3 )) );
set D164 = ( MajorityStr (C362 , C363 , C364) );
L648: ( 1GateCircStr (<* C362 , C363 *> , ( '&' )) ) tolerates ( 1GateCircStr (<* C363 , C364 *> , ( '&' )) ) by CIRCCOMB:43;
L649: ( InnerVertices D163 ) is Relation by L340;
L650: ( InputVertices ( 1GateCircStr (<* C363 , C364 *> , ( '&' )) ) ) = { C363 , C364 } by L346;
L651: (( InnerVertices ( 1GateCircStr (<* C362 , C363 *> , ( '&' )) ) ) = { [ <* C362 , C363 *> , ( '&' ) ] } & ( InnerVertices ( 1GateCircStr (<* C363 , C364 *> , ( '&' )) ) ) = { [ <* C363 , C364 *> , ( '&' ) ] }) by CIRCCOMB:42;
L652: (( InnerVertices ( 1GateCircStr (<* C364 , C362 *> , ( '&' )) ) ) = { [ <* C364 , C362 *> , ( '&' ) ] } & ( InnerVertices ( ( 1GateCircStr (<* C362 , C363 *> , ( '&' )) ) +* ( 1GateCircStr (<* C363 , C364 *> , ( '&' )) ) ) ) = ( { [ <* C362 , C363 *> , ( '&' ) ] } \/ { [ <* C363 , C364 *> , ( '&' ) ] } )) by L651 , L648 , CIRCCOMB:11 , CIRCCOMB:42;
L653: (( 1GateCircStr (<* C362 , C363 *> , ( '&' )) ) tolerates ( 1GateCircStr (<* C364 , C362 *> , ( '&' )) ) & ( 1GateCircStr (<* C363 , C364 *> , ( '&' )) ) tolerates ( 1GateCircStr (<* C364 , C362 *> , ( '&' )) )) by CIRCCOMB:43;
L654: ( ( 1GateCircStr (<* C362 , C363 *> , ( '&' )) ) +* ( 1GateCircStr (<* C363 , C364 *> , ( '&' )) ) ) tolerates ( 1GateCircStr (<* C364 , C362 *> , ( '&' )) ) by L653 , L648 , CIRCCOMB:3;
L655: ( InnerVertices D162 ) = ( ( { [ <* C362 , C363 *> , ( '&' ) ] } \/ { [ <* C363 , C364 *> , ( '&' ) ] } ) \/ { [ <* C364 , C362 *> , ( '&' ) ] } ) by L654 , L652 , CIRCCOMB:11
.= ( { [ <* C362 , C363 *> , ( '&' ) ] , [ <* C363 , C364 *> , ( '&' ) ] } \/ { [ <* C364 , C362 *> , ( '&' ) ] } ) by ENUMSET1:1
.= { [ <* C362 , C363 *> , ( '&' ) ] , [ <* C363 , C364 *> , ( '&' ) ] , [ <* C364 , C362 *> , ( '&' ) ] } by ENUMSET1:3;
L656: ( InputVertices D163 ) = { [ <* C362 , C363 *> , ( '&' ) ] , [ <* C363 , C364 *> , ( '&' ) ] , [ <* C364 , C362 *> , ( '&' ) ] } by L352;
L657: ( ( InputVertices D163 ) \ ( InnerVertices D162 ) ) = ( {} ) by L656 , L655 , XBOOLE_1:37;
L658: (( InputVertices ( 1GateCircStr (<* C362 , C363 *> , ( '&' )) ) ) = { C362 , C363 } & ( InputVertices ( 1GateCircStr (<* C364 , C362 *> , ( '&' )) ) ) = { C364 , C362 }) by L346;
L659: ( InputVertices ( 1GateCircStr (<* C364 , C362 *> , ( '&' )) ) ) is  without_pairs by L348;
L660: (( InputVertices ( 1GateCircStr (<* C362 , C363 *> , ( '&' )) ) ) is  without_pairs & ( InputVertices ( 1GateCircStr (<* C363 , C364 *> , ( '&' )) ) ) is  without_pairs) by L348;
L661: ( InputVertices ( ( 1GateCircStr (<* C362 , C363 *> , ( '&' )) ) +* ( 1GateCircStr (<* C363 , C364 *> , ( '&' )) ) ) ) is  without_pairs by L660 , L129 , CIRCCOMB:47;
L662: ( InputVertices D162 ) is  without_pairs by L661 , L659 , L129 , CIRCCOMB:47;
L663: ( InputVertices D164 ) = ( ( InputVertices D162 ) \/ ( ( InputVertices D163 ) \ ( InnerVertices D162 ) ) ) by L662 , L649 , L121;
thus L664: ( InputVertices D164 ) = ( ( InputVertices ( ( 1GateCircStr (<* C362 , C363 *> , ( '&' )) ) +* ( 1GateCircStr (<* C363 , C364 *> , ( '&' )) ) ) ) \/ ( InputVertices ( 1GateCircStr (<* C364 , C362 *> , ( '&' )) ) ) ) by L663 , L659 , L661 , L652 , L657 , L125
.= ( ( ( InputVertices ( 1GateCircStr (<* C362 , C363 *> , ( '&' )) ) ) \/ ( InputVertices ( 1GateCircStr (<* C363 , C364 *> , ( '&' )) ) ) ) \/ ( InputVertices ( 1GateCircStr (<* C364 , C362 *> , ( '&' )) ) ) ) by L660 , L651 , L125
.= ( { C362 , C363 , C363 , C364 } \/ { C364 , C362 } ) by L658 , L650 , ENUMSET1:5
.= ( { C363 , C363 , C362 , C364 } \/ { C364 , C362 } ) by ENUMSET1:67
.= ( { C363 , C362 , C364 } \/ { C364 , C362 } ) by ENUMSET1:31
.= ( { C362 , C363 , C364 } \/ { C364 , C362 } ) by ENUMSET1:58
.= ( { C362 , C363 , C364 } \/ ( { C364 } \/ { C362 } ) ) by ENUMSET1:1
.= ( ( { C362 , C363 , C364 } \/ { C364 } ) \/ { C362 } ) by XBOOLE_1:4
.= ( ( { C364 , C362 , C363 } \/ { C364 } ) \/ { C362 } ) by ENUMSET1:59
.= ( { C364 , C364 , C362 , C363 } \/ { C362 } ) by ENUMSET1:4
.= ( { C364 , C362 , C363 } \/ { C362 } ) by ENUMSET1:31
.= ( { C362 , C363 , C364 } \/ { C362 } ) by ENUMSET1:59
.= { C362 , C362 , C363 , C364 } by ENUMSET1:4
.= { C362 , C363 , C364 } by ENUMSET1:31;
L665: D162 tolerates D163 by CIRCCOMB:47;
thus L666: ( InnerVertices D164 ) = ( ( InnerVertices D162 ) \/ ( InnerVertices D163 ) ) by L665 , CIRCCOMB:11
.= ( { [ <* C362 , C363 *> , ( '&' ) ] , [ <* C363 , C364 *> , ( '&' ) ] , [ <* C364 , C362 *> , ( '&' ) ] } \/ { ( MajorityOutput (C362 , C363 , C364) ) } ) by L655 , CIRCCOMB:42;
end;
L667: (for B387 , B388 , B389 being non  pair set holds (for B390 being (State of ( MajorityCirc (B387 , B388 , B389) )) holds (for B391 , B392 , B393 being (Element of ( BOOLEAN )) holds ((B391 = ( B390 . B387 ) & B392 = ( B390 . B388 ) & B393 = ( B390 . B389 )) implies (( ( Following B390 ) . [ <* B387 , B388 *> , ( '&' ) ] ) = ( B391 '&' B392 ) & ( ( Following B390 ) . [ <* B388 , B389 *> , ( '&' ) ] ) = ( B392 '&' B393 ) & ( ( Following B390 ) . [ <* B389 , B387 *> , ( '&' ) ] ) = ( B393 '&' B391 ))))))
proof
let C365 , C366 , C367 being non  pair set;
let C368 being (State of ( MajorityCirc (C365 , C366 , C367) ));
let C369 , C370 , C371 being (Element of ( BOOLEAN ));
assume that
L668: C369 = ( C368 . C365 )
and
L669: C370 = ( C368 . C366 )
and
L670: C371 = ( C368 . C367 );
set D165 = ( MajorityStr (C365 , C366 , C367) );
L671: ( dom C368 ) = (the carrier of D165) by CIRCUIT1:3;
L672: C366 in (the carrier of D165) by L620;
L673: C365 in (the carrier of D165) by L620;
L674: ( InnerVertices D165 ) = (the carrier' of D165) by L337;
L675: [ <* C365 , C366 *> , ( '&' ) ] in ( InnerVertices ( MajorityStr (C365 , C366 , C367) ) ) by L629;
thus L676: ( ( Following C368 ) . [ <* C365 , C366 *> , ( '&' ) ] ) = ( ( '&' ) . ( C368 * <* C365 , C366 *> ) ) by L675 , L674 , L325
.= ( ( '&' ) . <* C369 , C370 *> ) by L668 , L669 , L671 , L673 , L672 , FINSEQ_2:125
.= ( C369 '&' C370 ) by L179;
L677: C367 in (the carrier of D165) by L620;
L678: [ <* C366 , C367 *> , ( '&' ) ] in ( InnerVertices ( MajorityStr (C365 , C366 , C367) ) ) by L629;
thus L679: ( ( Following C368 ) . [ <* C366 , C367 *> , ( '&' ) ] ) = ( ( '&' ) . ( C368 * <* C366 , C367 *> ) ) by L678 , L674 , L325
.= ( ( '&' ) . <* C370 , C371 *> ) by L669 , L670 , L671 , L672 , L677 , FINSEQ_2:125
.= ( C370 '&' C371 ) by L179;
L680: [ <* C367 , C365 *> , ( '&' ) ] in ( InnerVertices ( MajorityStr (C365 , C366 , C367) ) ) by L629;
thus L681: ( ( Following C368 ) . [ <* C367 , C365 *> , ( '&' ) ] ) = ( ( '&' ) . ( C368 * <* C367 , C365 *> ) ) by L680 , L674 , L325
.= ( ( '&' ) . <* C371 , C369 *> ) by L668 , L670 , L671 , L673 , L677 , FINSEQ_2:125
.= ( C371 '&' C369 ) by L179;
end;
theorem
L682: (for B394 , B395 , B396 being non  pair set holds (for B397 being (State of ( MajorityCirc (B394 , B395 , B396) )) holds (for B398 , B399 being (Element of ( BOOLEAN )) holds ((B398 = ( B397 . B394 ) & B399 = ( B397 . B395 )) implies ( ( Following B397 ) . [ <* B394 , B395 *> , ( '&' ) ] ) = ( B398 '&' B399 )))))
proof
let C372 , C373 , C374 being non  pair set;
reconsider D166 = C374 as (Vertex of ( MajorityStr (C372 , C373 , C374) )) by L620;
let C375 being (State of ( MajorityCirc (C372 , C373 , C374) ));
L683: ( C375 . D166 ) is (Element of ( BOOLEAN ));
thus L684: thesis by L683 , L667;
end;
theorem
L685: (for B400 , B401 , B402 being non  pair set holds (for B403 being (State of ( MajorityCirc (B400 , B401 , B402) )) holds (for B404 , B405 being (Element of ( BOOLEAN )) holds ((B404 = ( B403 . B401 ) & B405 = ( B403 . B402 )) implies ( ( Following B403 ) . [ <* B401 , B402 *> , ( '&' ) ] ) = ( B404 '&' B405 )))))
proof
let C376 , C377 , C378 being non  pair set;
reconsider D167 = C376 as (Vertex of ( MajorityStr (C376 , C377 , C378) )) by L620;
let C379 being (State of ( MajorityCirc (C376 , C377 , C378) ));
L686: ( C379 . D167 ) is (Element of ( BOOLEAN ));
thus L687: thesis by L686 , L667;
end;
theorem
L688: (for B406 , B407 , B408 being non  pair set holds (for B409 being (State of ( MajorityCirc (B406 , B407 , B408) )) holds (for B410 , B411 being (Element of ( BOOLEAN )) holds ((B410 = ( B409 . B406 ) & B411 = ( B409 . B408 )) implies ( ( Following B409 ) . [ <* B408 , B406 *> , ( '&' ) ] ) = ( B411 '&' B410 )))))
proof
let C380 , C381 , C382 being non  pair set;
reconsider D168 = C381 as (Vertex of ( MajorityStr (C380 , C381 , C382) )) by L620;
let C383 being (State of ( MajorityCirc (C380 , C381 , C382) ));
L689: ( C383 . D168 ) is (Element of ( BOOLEAN ));
thus L690: thesis by L689 , L667;
end;
theorem
L691: (for B412 , B413 , B414 being non  pair set holds (for B415 being (State of ( MajorityCirc (B412 , B413 , B414) )) holds (for B416 , B417 , B418 being (Element of ( BOOLEAN )) holds ((B416 = ( B415 . [ <* B412 , B413 *> , ( '&' ) ] ) & B417 = ( B415 . [ <* B413 , B414 *> , ( '&' ) ] ) & B418 = ( B415 . [ <* B414 , B412 *> , ( '&' ) ] )) implies ( ( Following B415 ) . ( MajorityOutput (B412 , B413 , B414) ) ) = ( ( B416 'or' B417 ) 'or' B418 )))))
proof
let C384 , C385 , C386 being non  pair set;
set D169 = [ <* C384 , C385 *> , ( '&' ) ];
set D170 = [ <* C385 , C386 *> , ( '&' ) ];
set D171 = [ <* C386 , C384 *> , ( '&' ) ];
set D172 = ( MajorityStr (C384 , C385 , C386) );
reconsider D173 = D169 , D174 = D170 , D175 = D171 as (Element of ( InnerVertices D172 )) by L629;
let C387 being (State of ( MajorityCirc (C384 , C385 , C386) ));
let C388 , C389 , C390 being (Element of ( BOOLEAN ));
assume that
L692: (C388 = ( C387 . [ <* C384 , C385 *> , ( '&' ) ] ) & C389 = ( C387 . [ <* C385 , C386 *> , ( '&' ) ] ) & C390 = ( C387 . [ <* C386 , C384 *> , ( '&' ) ] ));
L693: ( dom C387 ) = (the carrier of D172) by CIRCUIT1:3;
L694: ( InnerVertices D172 ) = (the carrier' of D172) by L337;
thus L695: ( ( Following C387 ) . ( MajorityOutput (C384 , C385 , C386) ) ) = ( ( or3 ) . ( C387 * <* D173 , D174 , D175 *> ) ) by L694 , L325
.= ( ( or3 ) . <* C388 , C389 , C390 *> ) by L692 , L693 , FINSEQ_2:126
.= ( ( C388 'or' C389 ) 'or' C390 ) by L183;
end;
L696: (for B419 , B420 , B421 being non  pair set holds (for B422 being (State of ( MajorityCirc (B419 , B420 , B421) )) holds (for B423 , B424 , B425 being (Element of ( BOOLEAN )) holds ((B423 = ( B422 . B419 ) & B424 = ( B422 . B420 ) & B425 = ( B422 . B421 )) implies (( ( Following (B422 , 2) ) . ( MajorityOutput (B419 , B420 , B421) ) ) = ( ( ( B423 '&' B424 ) 'or' ( B424 '&' B425 ) ) 'or' ( B425 '&' B423 ) ) & ( ( Following (B422 , 2) ) . [ <* B419 , B420 *> , ( '&' ) ] ) = ( B423 '&' B424 ) & ( ( Following (B422 , 2) ) . [ <* B420 , B421 *> , ( '&' ) ] ) = ( B424 '&' B425 ) & ( ( Following (B422 , 2) ) . [ <* B421 , B419 *> , ( '&' ) ] ) = ( B425 '&' B423 ))))))
proof
let C391 , C392 , C393 being non  pair set;
set D176 = ( MajorityStr (C391 , C392 , C393) );
reconsider D177 = C391 , D178 = C392 , D179 = C393 as (Vertex of D176) by L620;
let C394 being (State of ( MajorityCirc (C391 , C392 , C393) ));
set D180 = [ <* C391 , C392 *> , ( '&' ) ];
set D181 = [ <* C392 , C393 *> , ( '&' ) ];
set D182 = [ <* C393 , C391 *> , ( '&' ) ];
L697: ( Following (C394 , 2) ) = ( Following ( Following C394 ) ) by L214;
let C395 , C396 , C397 being (Element of ( BOOLEAN ));
assume that
L698: (C395 = ( C394 . C391 ) & C396 = ( C394 . C392 ) & C397 = ( C394 . C393 ));
L699: ( ( Following C394 ) . D182 ) = ( C397 '&' C395 ) by L698 , L667;
L700: (( ( Following C394 ) . D180 ) = ( C395 '&' C396 ) & ( ( Following C394 ) . D181 ) = ( C396 '&' C397 )) by L698 , L667;
thus L701: ( ( Following (C394 , 2) ) . ( MajorityOutput (C391 , C392 , C393) ) ) = ( ( ( C395 '&' C396 ) 'or' ( C396 '&' C397 ) ) 'or' ( C397 '&' C395 ) ) by L700 , L697 , L699 , L691;
L702: C392 in ( InputVertices D176 ) by L639;
L703: ( ( Following C394 ) . D178 ) = ( C394 . C392 ) by L702 , CIRCUIT2:def 5;
L704: C393 in ( InputVertices D176 ) by L639;
L705: ( ( Following C394 ) . D179 ) = ( C394 . C393 ) by L704 , CIRCUIT2:def 5;
L706: C391 in ( InputVertices D176 ) by L639;
L707: ( ( Following C394 ) . D177 ) = ( C394 . C391 ) by L706 , CIRCUIT2:def 5;
thus L708: thesis by L707 , L698 , L703 , L705 , L697 , L667;
end;
theorem
L709: (for B426 , B427 , B428 being non  pair set holds (for B429 being (State of ( MajorityCirc (B426 , B427 , B428) )) holds (for B430 , B431 being (Element of ( BOOLEAN )) holds ((B430 = ( B429 . B426 ) & B431 = ( B429 . B427 )) implies ( ( Following (B429 , 2) ) . [ <* B426 , B427 *> , ( '&' ) ] ) = ( B430 '&' B431 )))))
proof
let C398 , C399 , C400 being non  pair set;
reconsider D183 = C400 as (Vertex of ( MajorityStr (C398 , C399 , C400) )) by L620;
let C401 being (State of ( MajorityCirc (C398 , C399 , C400) ));
L710: ( C401 . D183 ) is (Element of ( BOOLEAN ));
thus L711: thesis by L710 , L696;
end;
theorem
L712: (for B432 , B433 , B434 being non  pair set holds (for B435 being (State of ( MajorityCirc (B432 , B433 , B434) )) holds (for B436 , B437 being (Element of ( BOOLEAN )) holds ((B436 = ( B435 . B433 ) & B437 = ( B435 . B434 )) implies ( ( Following (B435 , 2) ) . [ <* B433 , B434 *> , ( '&' ) ] ) = ( B436 '&' B437 )))))
proof
let C402 , C403 , C404 being non  pair set;
reconsider D184 = C402 as (Vertex of ( MajorityStr (C402 , C403 , C404) )) by L620;
let C405 being (State of ( MajorityCirc (C402 , C403 , C404) ));
L713: ( C405 . D184 ) is (Element of ( BOOLEAN ));
thus L714: thesis by L713 , L696;
end;
theorem
L715: (for B438 , B439 , B440 being non  pair set holds (for B441 being (State of ( MajorityCirc (B438 , B439 , B440) )) holds (for B442 , B443 being (Element of ( BOOLEAN )) holds ((B442 = ( B441 . B438 ) & B443 = ( B441 . B440 )) implies ( ( Following (B441 , 2) ) . [ <* B440 , B438 *> , ( '&' ) ] ) = ( B443 '&' B442 )))))
proof
let C406 , C407 , C408 being non  pair set;
reconsider D185 = C407 as (Vertex of ( MajorityStr (C406 , C407 , C408) )) by L620;
let C409 being (State of ( MajorityCirc (C406 , C407 , C408) ));
L716: ( C409 . D185 ) is (Element of ( BOOLEAN ));
thus L717: thesis by L716 , L696;
end;
theorem
L718: (for B444 , B445 , B446 being non  pair set holds (for B447 being (State of ( MajorityCirc (B444 , B445 , B446) )) holds (for B448 , B449 , B450 being (Element of ( BOOLEAN )) holds ((B448 = ( B447 . B444 ) & B449 = ( B447 . B445 ) & B450 = ( B447 . B446 )) implies ( ( Following (B447 , 2) ) . ( MajorityOutput (B444 , B445 , B446) ) ) = ( ( ( B448 '&' B449 ) 'or' ( B449 '&' B450 ) ) 'or' ( B450 '&' B448 ) ))))) by L696;
theorem
L719: (for B451 , B452 , B453 being non  pair set holds (for B454 being (State of ( MajorityCirc (B451 , B452 , B453) )) holds ( Following (B454 , 2) ) is  stable))
proof
let C410 , C411 , C412 being non  pair set;
set D186 = ( MajorityStr (C410 , C411 , C412) );
reconsider D187 = C410 , D188 = C411 , D189 = C412 as (Vertex of D186) by L620;
let C413 being (State of ( MajorityCirc (C410 , C411 , C412) ));
set D190 = ( C413 . D187 );
set D191 = ( C413 . D188 );
set D192 = ( C413 . D189 );
set D193 = ( Following (C413 , 2) );
set D194 = ( Following D193 );
L720: D193 = ( Following ( Following C413 ) ) by L214;
L721: C411 in ( InputVertices D186 ) by L639;
L722: ( ( Following C413 ) . C411 ) = D191 by L721 , CIRCUIT2:def 5;
L723: ( D193 . C411 ) = D191 by L722 , L720 , L721 , CIRCUIT2:def 5;
L724: D191 = ( C413 . C411 );
L725: ( D193 . [ <* C412 , C410 *> , ( '&' ) ] ) = ( D192 '&' D190 ) by L724 , L696;
L726: C410 in ( InputVertices D186 ) by L639;
L727: ( ( Following C413 ) . C410 ) = D190 by L726 , CIRCUIT2:def 5;
L728: ( D193 . C410 ) = D190 by L727 , L720 , L726 , CIRCUIT2:def 5;
L729: D190 = ( C413 . C410 );
L730: ( D193 . [ <* C411 , C412 *> , ( '&' ) ] ) = ( D191 '&' D192 ) by L729 , L696;
L731: C412 in ( InputVertices D186 ) by L639;
L732: ( ( Following C413 ) . C412 ) = D192 by L731 , CIRCUIT2:def 5;
L733: ( D193 . C412 ) = D192 by L732 , L720 , L731 , CIRCUIT2:def 5;
L734: D192 = ( C413 . C412 );
L735: ( D193 . [ <* C410 , C411 *> , ( '&' ) ] ) = ( D190 '&' D191 ) by L734 , L696;
L736: ( D193 . ( MajorityOutput (C410 , C411 , C412) ) ) = ( ( ( D190 '&' D191 ) 'or' ( D191 '&' D192 ) ) 'or' ( D192 '&' D190 ) ) by L696;
L737:
now
let C414 being set;
assume L738: C414 in (the carrier of D186);
reconsider D195 = C414 as (Vertex of D186) by L738;
L739: D195 in ( ( InputVertices D186 ) \/ ( InnerVertices D186 ) ) by L738 , XBOOLE_1:45;
thus L740: ( D193 . C414 ) = ( D194 . C414 )
proof
per cases  by L739 , XBOOLE_0:def 3;
suppose L741: D195 in ( InputVertices D186 );

thus L742: thesis by L741 , CIRCUIT2:def 5;
end;
suppose L743: D195 in ( InnerVertices D186 );

L744: D195 in ( { [ <* C410 , C411 *> , ( '&' ) ] , [ <* C411 , C412 *> , ( '&' ) ] , [ <* C412 , C410 *> , ( '&' ) ] } \/ { ( MajorityOutput (C410 , C411 , C412) ) } ) by L743 , L647;
L745: (D195 in { [ <* C410 , C411 *> , ( '&' ) ] , [ <* C411 , C412 *> , ( '&' ) ] , [ <* C412 , C410 *> , ( '&' ) ] } or D195 in { ( MajorityOutput (C410 , C411 , C412) ) }) by L744 , XBOOLE_0:def 3;
L746: (D195 = [ <* C410 , C411 *> , ( '&' ) ] or D195 = [ <* C411 , C412 *> , ( '&' ) ] or D195 = [ <* C412 , C410 *> , ( '&' ) ] or D195 = ( MajorityOutput (C410 , C411 , C412) )) by L745 , ENUMSET1:def 1 , TARSKI:def 1;
thus L747: thesis by L746 , L736 , L735 , L730 , L725 , L728 , L723 , L733 , L667 , L691;
end;
end;

end;
L741: (( dom ( Following ( Following (C413 , 2) ) ) ) = (the carrier of D186) & ( dom ( Following (C413 , 2) ) ) = (the carrier of D186)) by CIRCUIT1:3;
thus L742: D193 = D194 by L741 , L737 , FUNCT_1:2;
end;
definition
let C415 , C416 , C417 being set;
func BitAdderWithOverflowStr (C415 , C416 , C417) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( 2GatesCircStr (C415 , C416 , C417 , ( 'xor' )) ) +* ( MajorityStr (C415 , C416 , C417) ) );
coherence;
end;
theorem
L744: (for B455 , B456 , B457 being non  pair set holds ( InputVertices ( BitAdderWithOverflowStr (B455 , B456 , B457) ) ) = { B455 , B456 , B457 })
proof
let C418 , C419 , C420 being non  pair set;
set D196 = ( BitAdderWithOverflowStr (C418 , C419 , C420) );
set D197 = ( 2GatesCircStr (C418 , C419 , C420 , ( 'xor' )) );
set D198 = ( MajorityStr (C418 , C419 , C420) );
L745: (( InputVertices D197 ) = { C418 , C419 , C420 } & ( InputVertices D198 ) = { C418 , C419 , C420 }) by L449 , L647;
L746: (( InnerVertices D197 ) is Relation & ( InnerVertices D198 ) is Relation) by L477 , L574;
thus L747: ( InputVertices D196 ) = ( { C418 , C419 , C420 } \/ { C418 , C419 , C420 } ) by L746 , L745 , L125
.= { C418 , C419 , C420 };
end;
theorem
L748: (for B458 , B459 , B460 being non  pair set holds ( InnerVertices ( BitAdderWithOverflowStr (B458 , B459 , B460) ) ) = ( ( { [ <* B458 , B459 *> , ( 'xor' ) ] , ( 2GatesCircOutput (B458 , B459 , B460 , ( 'xor' )) ) } \/ { [ <* B458 , B459 *> , ( '&' ) ] , [ <* B459 , B460 *> , ( '&' ) ] , [ <* B460 , B458 *> , ( '&' ) ] } ) \/ { ( MajorityOutput (B458 , B459 , B460) ) } ))
proof
let C421 , C422 , C423 being non  pair set;
set D199 = ( 2GatesCircStr (C421 , C422 , C423 , ( 'xor' )) );
set D200 = ( MajorityStr (C421 , C422 , C423) );
L749: ( InnerVertices D200 ) = ( { [ <* C421 , C422 *> , ( '&' ) ] , [ <* C422 , C423 *> , ( '&' ) ] , [ <* C423 , C421 *> , ( '&' ) ] } \/ { ( MajorityOutput (C421 , C422 , C423) ) } ) by L647;
L750: (( ( { [ <* C421 , C422 *> , ( 'xor' ) ] , ( 2GatesCircOutput (C421 , C422 , C423 , ( 'xor' )) ) } \/ { [ <* C421 , C422 *> , ( '&' ) ] , [ <* C422 , C423 *> , ( '&' ) ] , [ <* C423 , C421 *> , ( '&' ) ] } ) \/ { ( MajorityOutput (C421 , C422 , C423) ) } ) = ( { [ <* C421 , C422 *> , ( 'xor' ) ] , ( 2GatesCircOutput (C421 , C422 , C423 , ( 'xor' )) ) } \/ ( { [ <* C421 , C422 *> , ( '&' ) ] , [ <* C422 , C423 *> , ( '&' ) ] , [ <* C423 , C421 *> , ( '&' ) ] } \/ { ( MajorityOutput (C421 , C422 , C423) ) } ) ) & ( InnerVertices D199 ) = { [ <* C421 , C422 *> , ( 'xor' ) ] , ( 2GatesCircOutput (C421 , C422 , C423 , ( 'xor' )) ) }) by L446 , XBOOLE_1:4;
thus L751: thesis by L750 , L749 , L268;
end;
theorem
L752: (for R1 being set holds (for R2 being set holds (for R4 being set holds (for B461 being non  empty ManySortedSign holds (B461 = ( BitAdderWithOverflowStr (R1 , R2 , R4) ) implies (R1 in (the carrier of B461) & R2 in (the carrier of B461) & R4 in (the carrier of B461)))))))
proof
let R1 being set;
let R2 being set;
let R4 being set;
set D201 = ( 2GatesCircStr (R1 , R2 , R4 , ( 'xor' )) );
let C424 being non  empty ManySortedSign;
assume L753: C424 = ( BitAdderWithOverflowStr (R1 , R2 , R4) );
L754: R4 in (the carrier of D201) by L483;
L755: (R1 in (the carrier of D201) & R2 in (the carrier of D201)) by L483;
thus L756: thesis by L755 , L753 , L754 , L248;
end;
definition
let C425 , C426 , C427 being set;
func BitAdderWithOverflowCirc (C425 , C426 , C427) ->  strict  Boolean  gate`2=den (Circuit of ( BitAdderWithOverflowStr (C425 , C426 , C427) )) equals 
( ( BitAdderCirc (C425 , C426 , C427) ) +* ( MajorityCirc (C425 , C426 , C427) ) );
coherence;
end;
theorem
L758: (for R1 being set holds (for R2 being set holds (for R4 being set holds ( InnerVertices ( BitAdderWithOverflowStr (R1 , R2 , R4) ) ) is Relation)))
proof
let R1 being set;
let R2 being set;
let R4 being set;
L759: (( InnerVertices ( 2GatesCircStr (R1 , R2 , R4 , ( 'xor' )) ) ) is Relation & ( InnerVertices ( MajorityStr (R1 , R2 , R4) ) ) is Relation) by L477 , L574;
thus L760: thesis by L759 , L79 , CIRCCOMB:47;
end;
theorem
L761: (for B462 , B463 , B464 being non  pair set holds ( InputVertices ( BitAdderWithOverflowStr (B462 , B463 , B464) ) ) is  without_pairs)
proof
let C428 , C429 , C430 being non  pair set;
L762: ( InputVertices ( BitAdderWithOverflowStr (C428 , C429 , C430) ) ) = { C428 , C429 , C430 } by L744;
thus L763: thesis by L762;
end;
theorem
L764: (for R1 being set holds (for R2 being set holds (for R4 being set holds (( BitAdderOutput (R1 , R2 , R4) ) in ( InnerVertices ( BitAdderWithOverflowStr (R1 , R2 , R4) ) ) & ( MajorityOutput (R1 , R2 , R4) ) in ( InnerVertices ( BitAdderWithOverflowStr (R1 , R2 , R4) ) ))))) by L251;
theorem
L765: (for B465 , B466 , B467 being non  pair set holds (for B468 being (State of ( BitAdderWithOverflowCirc (B465 , B466 , B467) )) holds (for B469 , B470 , B471 being (Element of ( BOOLEAN )) holds ((B469 = ( B468 . B465 ) & B470 = ( B468 . B466 ) & B471 = ( B468 . B467 )) implies (( ( Following (B468 , 2) ) . ( BitAdderOutput (B465 , B466 , B467) ) ) = ( ( B469 'xor' B470 ) 'xor' B471 ) & ( ( Following (B468 , 2) ) . ( MajorityOutput (B465 , B466 , B467) ) ) = ( ( ( B469 '&' B470 ) 'or' ( B470 '&' B471 ) ) 'or' ( B471 '&' B469 ) ))))))
proof
let C431 , C432 , C433 being non  pair set;
set D202 = ( 2GatesCircStr (C431 , C432 , C433 , ( 'xor' )) );
set D203 = ( MajorityStr (C431 , C432 , C433) );
set D204 = ( BitAdderWithOverflowCirc (C431 , C432 , C433) );
set D205 = ( BitAdderCirc (C431 , C432 , C433) );
set D206 = ( MajorityCirc (C431 , C432 , C433) );
let C434 being (State of D204);
reconsider D207 = C434 as (State of ( D205 +* D206 ));
reconsider D208 = ( C434 | (the carrier of D202) ) as (State of D205) by L265;
set D209 = ( 'xor' );
let C435 , C436 , C437 being (Element of ( BOOLEAN ));
assume that
L766: C435 = ( C434 . C431 )
and
L767: C436 = ( C434 . C432 )
and
L768: C437 = ( C434 . C433 );
L769: ( dom D208 ) = (the carrier of D202) by CIRCUIT1:3;
L770: C432 in (the carrier of D202) by L483;
L771: C436 = ( D208 . C432 ) by L770 , L767 , L769 , FUNCT_1:47;
L772: ( InputVertices D202 ) is  without_pairs by L480;
L773: ( InnerVertices D203 ) misses ( InputVertices D202 ) by L772 , L113 , L574;
L774: ( ( Following (D207 , 2) ) . ( 2GatesCircOutput (C431 , C432 , C433 , D209) ) ) = ( ( Following (D208 , 2) ) . ( 2GatesCircOutput (C431 , C432 , C433 , D209) ) ) by L773 , L299;
L775: C433 in (the carrier of D202) by L483;
L776: C437 = ( D208 . C433 ) by L775 , L768 , L769 , FUNCT_1:47;
reconsider D210 = ( C434 | (the carrier of D203) ) as (State of D206) by L265;
L777: ( dom D210 ) = (the carrier of D203) by CIRCUIT1:3;
L778: C431 in (the carrier of D202) by L483;
L779: C435 = ( D208 . C431 ) by L778 , L766 , L769 , FUNCT_1:47;
thus L780: ( ( Following (C434 , 2) ) . ( BitAdderOutput (C431 , C432 , C433) ) ) = ( ( C435 'xor' C436 ) 'xor' C437 ) by L779 , L771 , L776 , L774 , L557;
L781: ( InputVertices D203 ) is  without_pairs by L581;
L782: ( InnerVertices D202 ) misses ( InputVertices D203 ) by L781 , L113 , L477;
L783: ( ( Following (D207 , 2) ) . ( MajorityOutput (C431 , C432 , C433) ) ) = ( ( Following (D210 , 2) ) . ( MajorityOutput (C431 , C432 , C433) ) ) by L782 , L306;
L784: C433 in (the carrier of D203) by L620;
L785: C437 = ( D210 . C433 ) by L784 , L768 , L777 , FUNCT_1:47;
L786: C432 in (the carrier of D203) by L620;
L787: C436 = ( D210 . C432 ) by L786 , L767 , L777 , FUNCT_1:47;
L788: C431 in (the carrier of D203) by L620;
L789: C435 = ( D210 . C431 ) by L788 , L766 , L777 , FUNCT_1:47;
thus L790: thesis by L789 , L787 , L785 , L783 , L696;
end;
theorem
L791: (for B472 , B473 , B474 being non  pair set holds (for B475 being (State of ( BitAdderWithOverflowCirc (B472 , B473 , B474) )) holds ( Following (B475 , 2) ) is  stable))
proof
let C438 , C439 , C440 being non  pair set;
set D211 = ( 2GatesCircStr (C438 , C439 , C440 , ( 'xor' )) );
set D212 = ( MajorityStr (C438 , C439 , C440) );
set D213 = ( BitAdderWithOverflowCirc (C438 , C439 , C440) );
set D214 = ( BitAdderCirc (C438 , C439 , C440) );
set D215 = ( MajorityCirc (C438 , C439 , C440) );
let C441 being (State of D213);
reconsider D216 = ( C441 | (the carrier of D212) ) as (State of D215) by L265;
reconsider D217 = C441 as (State of ( D214 +* D215 ));
reconsider D218 = ( C441 | (the carrier of D211) ) as (State of D214) by L265;
set D219 = ( BitAdderWithOverflowStr (C438 , C439 , C440) );
L792: ( dom ( Following (C441 , 3) ) ) = (the carrier of D219) by CIRCUIT1:3;
L793: (the carrier of D219) = ( (the carrier of D211) \/ (the carrier of D212) ) by CIRCCOMB:def 2;
L794: ( InputVertices D211 ) is  without_pairs by L480;
L795: ( InnerVertices D212 ) misses ( InputVertices D211 ) by L794 , L113 , L574;
L796: (( Following (D218 , 2) ) = ( ( Following (D217 , 2) ) | (the carrier of D211) ) & ( Following (D218 , 3) ) = ( ( Following (D217 , 3) ) | (the carrier of D211) )) by L795 , L281;
L797: ( Following (D218 , 2) ) is  stable by L538;
L798: ( Following (D218 , 2) ) = ( Following ( Following (D218 , 2) ) ) by L797 , CIRCUIT2:def 6
.= ( Following (D218 , ( 2 + 1 )) ) by L200;
L799: ( InputVertices D212 ) is  without_pairs by L581;
L800: ( InnerVertices D211 ) misses ( InputVertices D212 ) by L799 , L113 , L477;
L801: (( Following (D216 , 2) ) = ( ( Following (D217 , 2) ) | (the carrier of D212) ) & ( Following (D216 , 3) ) = ( ( Following (D217 , 3) ) | (the carrier of D212) )) by L800 , L290;
L802: ( Following (D216 , 2) ) is  stable by L719;
L803: ( Following (D216 , 2) ) = ( Following ( Following (D216 , 2) ) ) by L802 , CIRCUIT2:def 6
.= ( Following (D216 , ( 2 + 1 )) ) by L200;
L804: (( dom ( Following (D218 , 2) ) ) = (the carrier of D211) & ( dom ( Following (D216 , 2) ) ) = (the carrier of D212)) by CIRCUIT1:3;
L805:
now
let C442 being set;
assume L806: C442 in (the carrier of D219);
L807: (C442 in (the carrier of D211) or C442 in (the carrier of D212)) by L806 , L793 , XBOOLE_0:def 3;
L808: ((( ( Following (C441 , 2) ) . C442 ) = ( ( Following (D218 , 2) ) . C442 ) & ( ( Following (C441 , 3) ) . C442 ) = ( ( Following (D218 , 3) ) . C442 )) or (( ( Following (C441 , 2) ) . C442 ) = ( ( Following (D216 , 2) ) . C442 ) & ( ( Following (C441 , 3) ) . C442 ) = ( ( Following (D216 , 3) ) . C442 ))) by L807 , L796 , L801 , L798 , L803 , L804 , FUNCT_1:47;
thus L809: ( ( Following (C441 , 2) ) . C442 ) = ( ( Following ( Following (C441 , 2) ) ) . C442 ) by L808 , L798 , L803 , L200;
end;
L810: (( Following (C441 , ( 2 + 1 )) ) = ( Following ( Following (C441 , 2) ) ) & ( dom ( Following (C441 , 2) ) ) = (the carrier of D219)) by L200 , CIRCUIT1:3;
thus L811: ( Following (C441 , 2) ) = ( Following ( Following (C441 , 2) ) ) by L810 , L792 , L805 , FUNCT_1:2;
end;
