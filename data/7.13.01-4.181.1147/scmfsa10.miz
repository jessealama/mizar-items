:: On the Instructions of { \bf SCM+FSA }
::  by Artur Korni{\l}owicz
::
:: Received May 8, 2001
:: Copyright (c) 2001-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SCMFSA_2, AMI_3, AMI_1, FSM_1, ORDINAL1, INT_1,
      FUNCOP_1, SUBSET_1, SCMFSA_1, CAT_1, XBOOLE_0, GRAPHSP, FINSEQ_1,
      RELAT_1, CARD_1, AMI_2, AMISTD_2, CARD_3, FUNCT_1, AMISTD_1, CIRCUIT2,
      FUNCT_4, SETFAM_1, XXREAL_0, TARSKI, ARYTM_3, GOBOARD5, FRECHET, ARYTM_1,
      COMPLEX1, PARTFUN1, FINSEQ_2, RECDEF_2, NAT_1, COMPOS_1, GOBRD13,
      MEMSTR_0;
 notations TARSKI, XBOOLE_0,
      XTUPLE_0, SUBSET_1, SETFAM_1, RELAT_1, FUNCT_1,
      PARTFUN1, ORDINAL1, XCMPLX_0, INT_1, FUNCOP_1, FINSEQ_1, FINSEQ_2,
      FUNCT_4, FUNCT_7, COMPLEX1, CARD_1, CARD_3, XXREAL_0, NAT_1, RECDEF_2,
      VALUED_1, NUMBERS, MEMSTR_0, COMPOS_0, COMPOS_1, EXTPRO_1, AMISTD_1,
      AMISTD_2, AMI_3, SCM_INST, SCMFSA_1, SCMFSA_3, SCMFSA_2;
 constructors REAL_1, NAT_D, AMI_3, SCMFSA_3, AMISTD_2, RELSET_1, AMISTD_1,
      SCMFSA_1, PRE_POLY, FUNCT_7, DOMAIN_1;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1, NUMBERS,
      XREAL_0, NAT_1, INT_1, SCMFSA_2, AMISTD_2, RELSET_1, CARD_3, AMI_3,
      FUNCT_4, VALUED_0, EXTPRO_1, FUNCT_7, PRE_POLY, MEMSTR_0, CARD_1,
      COMPOS_0, XTUPLE_0;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;
 definitions TARSKI, SCMFSA_2, AMISTD_1, AMISTD_2, XBOOLE_0, FUNCOP_1,
      COMPOS_1, EXTPRO_1, AMI_3, NAT_1, MEMSTR_0, COMPOS_0, XTUPLE_0;
 theorems TARSKI, NAT_1, AMI_3, FUNCT_4, FUNCT_1, FUNCOP_1, SETFAM_1, AMISTD_1,
      FINSEQ_1, FUNCT_7, CARD_3, SCMFSA_2, INT_1, BVFUNC14, ABSVALUE, FINSEQ_2,
      XBOOLE_0, XBOOLE_1, NAT_D, MEMSTR_0, PARTFUN1, PBOOLE, RECDEF_2,
      VALUED_1, EXTPRO_1, AMI_2, COMPOS_0, COMPOS_1;

begin
definition
let C1 , C2 being Int-Location;
let C3 , C4 being Integer;
redefine func (C1 , C2) --> (C3 , C4) -> (PartState of ( SCM+FSA ));

coherence
proof
L1: ( Values C2 ) = ( INT ) by SCMFSA_2:11;
L2: C4 is (Element of ( INT )) by INT_1:def 2;
reconsider D1 = C4 as (Element of ( Values C2 )) by L2 , L1;
L3: ( Values C1 ) = ( INT ) by SCMFSA_2:11;
L4: C3 is (Element of ( INT )) by INT_1:def 2;
reconsider D2 = C3 as (Element of ( Values C1 )) by L4 , L3;
L5: ( (C1 , C2) --> (D2 , D1) ) is (PartState of ( SCM+FSA ));
thus L6: thesis by L5;
end;
end;
theorem
L8: (for B1 being (Object of ( SCM+FSA )) holds (B1 in ( Data-Locations ( SCM+FSA ) ) implies (B1 is Int-Location or B1 is FinSeq-Location)))
proof
let C5 being (Object of ( SCM+FSA ));
assume L9: C5 in ( Data-Locations ( SCM+FSA ) );
L10: (C5 in ( SCM-Data-Loc ) or C5 in ( SCM+FSA-Data*-Loc )) by L9 , SCMFSA_2:100 , XBOOLE_0:def 3;
thus L11: thesis by L10 , AMI_2:def 16 , SCMFSA_2:def 5;
end;
theorem
L12: (for R1 being Int-Location holds (for R2 being Int-Location holds ( R1 := R2 ) = [ 1 , ( {} ) , <* R1 , R2 *> ]))
proof
let R1 being Int-Location;
let R2 being Int-Location;
L13: (ex R7 being Data-Location st (ex R8 being Data-Location st (R1 = R7 & R2 = R8 & ( R1 := R2 ) = ( R7 := R8 )))) by SCMFSA_2:def 8;
thus L14: thesis by L13;
end;
theorem
L15: (for R1 being Int-Location holds (for R2 being Int-Location holds ( AddTo (R1 , R2) ) = [ 2 , ( {} ) , <* R1 , R2 *> ]))
proof
let R1 being Int-Location;
let R2 being Int-Location;
L16: (ex R7 being Data-Location st (ex R8 being Data-Location st (R1 = R7 & R2 = R8 & ( AddTo (R1 , R2) ) = ( AddTo (R7 , R8) )))) by SCMFSA_2:def 9;
thus L17: thesis by L16;
end;
theorem
L18: (for R1 being Int-Location holds (for R2 being Int-Location holds ( SubFrom (R1 , R2) ) = [ 3 , ( {} ) , <* R1 , R2 *> ]))
proof
let R1 being Int-Location;
let R2 being Int-Location;
L19: (ex R7 being Data-Location st (ex R8 being Data-Location st (R1 = R7 & R2 = R8 & ( SubFrom (R1 , R2) ) = ( SubFrom (R7 , R8) )))) by SCMFSA_2:def 10;
thus L20: thesis by L19;
end;
theorem
L21: (for R1 being Int-Location holds (for R2 being Int-Location holds ( MultBy (R1 , R2) ) = [ 4 , ( {} ) , <* R1 , R2 *> ]))
proof
let R1 being Int-Location;
let R2 being Int-Location;
L22: (ex R7 being Data-Location st (ex R8 being Data-Location st (R1 = R7 & R2 = R8 & ( MultBy (R1 , R2) ) = ( MultBy (R7 , R8) )))) by SCMFSA_2:def 11;
thus L23: thesis by L22;
end;
theorem
L24: (for R1 being Int-Location holds (for R2 being Int-Location holds ( Divide (R1 , R2) ) = [ 5 , ( {} ) , <* R1 , R2 *> ]))
proof
let R1 being Int-Location;
let R2 being Int-Location;
L25: (ex R7 being Data-Location st (ex R8 being Data-Location st (R1 = R7 & R2 = R8 & ( Divide (R1 , R2) ) = ( Divide (R7 , R8) )))) by SCMFSA_2:def 12;
thus L26: thesis by L25;
end;
theorem
L27: (for R1 being Int-Location holds (for R13 being (Element of ( NAT )) holds ( R1 =0_goto R13 ) = [ 7 , <* R13 *> , <* R1 *> ]))
proof
let R1 being Int-Location;
let R13 being (Element of ( NAT ));
L28: (ex R7 being Data-Location st (R7 = R1 & ( R7 =0_goto R13 ) = ( R1 =0_goto R13 ))) by SCMFSA_2:def 14;
thus L29: thesis by L28;
end;
theorem
L30: (for R1 being Int-Location holds (for R13 being (Element of ( NAT )) holds ( R1 >0_goto R13 ) = [ 8 , <* R13 *> , <* R1 *> ]))
proof
let R1 being Int-Location;
let R13 being (Element of ( NAT ));
L31: (ex R7 being Data-Location st (R7 = R1 & ( R7 >0_goto R13 ) = ( R1 >0_goto R13 ))) by SCMFSA_2:def 15;
thus L32: thesis by L31;
end;
theorem
L33: ( JumpPart ( halt ( SCM+FSA ) ) ) = ( {} );
theorem
L34: (for R31 being Int-Location holds (for R32 being Int-Location holds ( JumpPart ( R31 := R32 ) ) = ( {} )))
proof
let R31 being Int-Location;
let R32 being Int-Location;
thus L35: ( JumpPart ( R31 := R32 ) ) = ( [ 1 , ( {} ) , <* R31 , R32 *> ] `2_3 ) by L12
.= ( {} );
end;
theorem
L36: (for R31 being Int-Location holds (for R32 being Int-Location holds ( JumpPart ( AddTo (R31 , R32) ) ) = ( {} )))
proof
let R31 being Int-Location;
let R32 being Int-Location;
thus L37: ( JumpPart ( AddTo (R31 , R32) ) ) = ( [ 2 , ( {} ) , <* R31 , R32 *> ] `2_3 ) by L15
.= ( {} );
end;
theorem
L38: (for R31 being Int-Location holds (for R32 being Int-Location holds ( JumpPart ( SubFrom (R31 , R32) ) ) = ( {} )))
proof
let R31 being Int-Location;
let R32 being Int-Location;
thus L39: ( JumpPart ( SubFrom (R31 , R32) ) ) = ( [ 3 , ( {} ) , <* R31 , R32 *> ] `2_3 ) by L18
.= ( {} );
end;
theorem
L40: (for R31 being Int-Location holds (for R32 being Int-Location holds ( JumpPart ( MultBy (R31 , R32) ) ) = ( {} )))
proof
let R31 being Int-Location;
let R32 being Int-Location;
thus L41: ( JumpPart ( MultBy (R31 , R32) ) ) = ( [ 4 , ( {} ) , <* R31 , R32 *> ] `2_3 ) by L21
.= ( {} );
end;
theorem
L42: (for R31 being Int-Location holds (for R32 being Int-Location holds ( JumpPart ( Divide (R31 , R32) ) ) = ( {} )))
proof
let R31 being Int-Location;
let R32 being Int-Location;
thus L43: ( JumpPart ( Divide (R31 , R32) ) ) = ( [ 5 , ( {} ) , <* R31 , R32 *> ] `2_3 ) by L24
.= ( {} );
end;
theorem
L44: (for R14 being (Element of ( NAT )) holds (for R31 being Int-Location holds ( JumpPart ( R31 =0_goto R14 ) ) = <* R14 *>))
proof
let R14 being (Element of ( NAT ));
let R31 being Int-Location;
thus L45: ( JumpPart ( R31 =0_goto R14 ) ) = ( [ 7 , <* R14 *> , <* R31 *> ] `2_3 ) by L27
.= <* R14 *>;
end;
theorem
L46: (for R14 being (Element of ( NAT )) holds (for R31 being Int-Location holds ( JumpPart ( R31 >0_goto R14 ) ) = <* R14 *>))
proof
let R14 being (Element of ( NAT ));
let R31 being Int-Location;
thus L47: ( JumpPart ( R31 >0_goto R14 ) ) = ( [ 8 , <* R14 *> , <* R31 *> ] `2_3 ) by L30
.= <* R14 *>;
end;
theorem
L48: (for R21 being (InsType of (the InstructionsF of ( SCM+FSA ))) holds (R21 = ( 0 ) implies ( JumpParts R21 ) = { ( 0 ) }))
proof
let R21 being (InsType of (the InstructionsF of ( SCM+FSA )));
assume L49: R21 = ( 0 );
thus L50:now
let C6 being set;
assume L51: C6 in ( JumpParts R21 );
consider R17 being (Instruction of ( SCM+FSA )) such that L52: C6 = ( JumpPart R17 ) and L53: ( InsCode R17 ) = R21 by L51;
L54: R17 = ( halt ( SCM+FSA ) ) by L49 , L53 , SCMFSA_2:95;
thus L55: C6 in { ( 0 ) } by L54 , L52 , L33 , TARSKI:def 1;
end;
let C7 being set;
assume L56: C7 in { ( 0 ) };
L57: C7 = ( 0 ) by L56 , TARSKI:def 1;
L58: ( InsCode ( halt ( SCM+FSA ) ) ) = ( 0 ) by COMPOS_1:70;
thus L59: thesis by L58 , L49 , L33 , L57;
end;
theorem
L60: (for R21 being (InsType of (the InstructionsF of ( SCM+FSA ))) holds (R21 = 1 implies ( JumpParts R21 ) = { ( {} ) }))
proof
let R21 being (InsType of (the InstructionsF of ( SCM+FSA )));
assume L61: R21 = 1;
thus L62:now
let C8 being set;
assume L63: C8 in ( JumpParts R21 );
consider C9 being (Instruction of ( SCM+FSA )) such that L64: C8 = ( JumpPart C9 ) and L65: ( InsCode C9 ) = R21 by L63;
consider R31 being Int-Location, R32 being Int-Location such that L66: C9 = ( R31 := R32 ) by L61 , L65 , SCMFSA_2:30;
L67: C8 = ( {} ) by L64 , L34 , L66;
thus L68: C8 in { ( {} ) } by L67 , TARSKI:def 1;
end;
set D3 = the Int-Location;
let C10 being set;
assume L69: C10 in { ( {} ) };
L70: C10 = ( {} ) by L69 , TARSKI:def 1;
L71: C10 = ( JumpPart ( D3 := D3 ) ) by L70 , L34;
L72: ( InsCode ( D3 := D3 ) ) = 1 by SCMFSA_2:18;
thus L73: thesis by L72 , L71 , L61;
end;
theorem
L74: (for R21 being (InsType of (the InstructionsF of ( SCM+FSA ))) holds (R21 = 2 implies ( JumpParts R21 ) = { ( {} ) }))
proof
let R21 being (InsType of (the InstructionsF of ( SCM+FSA )));
assume L75: R21 = 2;
thus L76:now
let C11 being set;
assume L77: C11 in ( JumpParts R21 );
consider C12 being (Instruction of ( SCM+FSA )) such that L78: C11 = ( JumpPart C12 ) and L79: ( InsCode C12 ) = R21 by L77;
consider R31 being Int-Location, R32 being Int-Location such that L80: C12 = ( AddTo (R31 , R32) ) by L75 , L79 , SCMFSA_2:31;
L81: C11 = ( {} ) by L78 , L36 , L80;
thus L82: C11 in { ( {} ) } by L81 , TARSKI:def 1;
end;
set D4 = the Int-Location;
let C13 being set;
assume L83: C13 in { ( {} ) };
L84: C13 = ( {} ) by L83 , TARSKI:def 1;
L85: C13 = ( JumpPart ( AddTo (D4 , D4) ) ) by L84 , L36;
L86: ( InsCode ( AddTo (D4 , D4) ) ) = 2 by SCMFSA_2:19;
thus L87: thesis by L86 , L85 , L75;
end;
theorem
L88: (for R21 being (InsType of (the InstructionsF of ( SCM+FSA ))) holds (R21 = 3 implies ( JumpParts R21 ) = { ( {} ) }))
proof
let R21 being (InsType of (the InstructionsF of ( SCM+FSA )));
assume L89: R21 = 3;
thus L90:now
let C14 being set;
assume L91: C14 in ( JumpParts R21 );
consider C15 being (Instruction of ( SCM+FSA )) such that L92: C14 = ( JumpPart C15 ) and L93: ( InsCode C15 ) = R21 by L91;
consider R31 being Int-Location, R32 being Int-Location such that L94: C15 = ( SubFrom (R31 , R32) ) by L89 , L93 , SCMFSA_2:32;
L95: C14 = ( {} ) by L92 , L38 , L94;
thus L96: C14 in { ( {} ) } by L95 , TARSKI:def 1;
end;
set D5 = the Int-Location;
let C16 being set;
assume L97: C16 in { ( {} ) };
L98: C16 = ( {} ) by L97 , TARSKI:def 1;
L99: C16 = ( JumpPart ( SubFrom (D5 , D5) ) ) by L98 , L38;
L100: ( InsCode ( SubFrom (D5 , D5) ) ) = 3 by SCMFSA_2:20;
thus L101: thesis by L100 , L99 , L89;
end;
theorem
L102: (for R21 being (InsType of (the InstructionsF of ( SCM+FSA ))) holds (R21 = 4 implies ( JumpParts R21 ) = { ( {} ) }))
proof
let R21 being (InsType of (the InstructionsF of ( SCM+FSA )));
assume L103: R21 = 4;
thus L104:now
let C17 being set;
assume L105: C17 in ( JumpParts R21 );
consider C18 being (Instruction of ( SCM+FSA )) such that L106: C17 = ( JumpPart C18 ) and L107: ( InsCode C18 ) = R21 by L105;
consider R31 being Int-Location, R32 being Int-Location such that L108: C18 = ( MultBy (R31 , R32) ) by L103 , L107 , SCMFSA_2:33;
L109: C17 = ( {} ) by L106 , L40 , L108;
thus L110: C17 in { ( {} ) } by L109 , TARSKI:def 1;
end;
set D6 = the Int-Location;
let C19 being set;
assume L111: C19 in { ( {} ) };
L112: C19 = ( {} ) by L111 , TARSKI:def 1;
L113: C19 = ( JumpPart ( MultBy (D6 , D6) ) ) by L112 , L40;
L114: ( InsCode ( MultBy (D6 , D6) ) ) = 4 by SCMFSA_2:21;
thus L115: thesis by L114 , L113 , L103;
end;
theorem
L116: (for R21 being (InsType of (the InstructionsF of ( SCM+FSA ))) holds (R21 = 5 implies ( JumpParts R21 ) = { ( {} ) }))
proof
let R21 being (InsType of (the InstructionsF of ( SCM+FSA )));
assume L117: R21 = 5;
thus L118:now
let C20 being set;
assume L119: C20 in ( JumpParts R21 );
consider C21 being (Instruction of ( SCM+FSA )) such that L120: C20 = ( JumpPart C21 ) and L121: ( InsCode C21 ) = R21 by L119;
consider R31 being Int-Location, R32 being Int-Location such that L122: C21 = ( Divide (R31 , R32) ) by L117 , L121 , SCMFSA_2:34;
L123: C20 = ( {} ) by L120 , L42 , L122;
thus L124: C20 in { ( {} ) } by L123 , TARSKI:def 1;
end;
set D7 = the Int-Location;
let C22 being set;
assume L125: C22 in { ( {} ) };
L126: C22 = ( {} ) by L125 , TARSKI:def 1;
L127: C22 = ( JumpPart ( Divide (D7 , D7) ) ) by L126 , L42;
L128: ( InsCode ( Divide (D7 , D7) ) ) = 5 by SCMFSA_2:22;
thus L129: thesis by L128 , L127 , L117;
end;
theorem
L130: (for R21 being (InsType of (the InstructionsF of ( SCM+FSA ))) holds (R21 = 6 implies ( dom ( product" ( JumpParts R21 ) ) ) = { 1 }))
proof
let R21 being (InsType of (the InstructionsF of ( SCM+FSA )));
set D8 = the (Element of ( NAT ));
assume L131: R21 = 6;
L132: ( JumpPart ( goto D8 ) ) = <* D8 *> by RECDEF_2:def 2;
thus L133:now
let C23 being set;
L134: ( InsCode ( goto D8 ) ) = 6 by SCMFSA_2:23;
L135: ( JumpPart ( goto D8 ) ) in ( JumpParts R21 ) by L134 , L131;
assume L136: C23 in ( dom ( product" ( JumpParts R21 ) ) );
L137: C23 in ( DOM ( JumpParts R21 ) ) by L136 , CARD_3:def 12;
L138: C23 in ( dom ( JumpPart ( goto D8 ) ) ) by L137 , L135 , CARD_3:108;
thus L139: C23 in { 1 } by L138 , L132 , FINSEQ_1:2 , FINSEQ_1:def 8;
end;
let C24 being set;
assume L140: C24 in { 1 };
L141: (for B2 being Function holds (B2 in ( JumpParts R21 ) implies C24 in ( dom B2 )))
proof
let C25 being Function;
assume L142: C25 in ( JumpParts R21 );
consider C26 being (Instruction of ( SCM+FSA )) such that L143: C25 = ( JumpPart C26 ) and L144: ( InsCode C26 ) = R21 by L142;
consider R14 being (Element of ( NAT )) such that L145: C26 = ( goto R14 ) by L131 , L144 , SCMFSA_2:35;
L146: C25 = <* R14 *> by L143 , L145 , RECDEF_2:def 2;
thus L147: thesis by L146 , L140 , FINSEQ_1:2 , FINSEQ_1:def 8;
end;
L148: C24 in ( DOM ( JumpParts R21 ) ) by L141 , CARD_3:109;
thus L149: thesis by L148 , CARD_3:def 12;
end;
theorem
L150: (for R21 being (InsType of (the InstructionsF of ( SCM+FSA ))) holds (R21 = 7 implies ( dom ( product" ( JumpParts R21 ) ) ) = { 1 }))
proof
let R21 being (InsType of (the InstructionsF of ( SCM+FSA )));
set D9 = the (Element of ( NAT ));
set D10 = the Int-Location;
assume L151: R21 = 7;
L152: ( JumpPart ( D10 =0_goto D9 ) ) = <* D9 *> by L44;
thus L153:now
let C27 being set;
L154: ( InsCode ( D10 =0_goto D9 ) ) = 7 by SCMFSA_2:24;
L155: ( JumpPart ( D10 =0_goto D9 ) ) in ( JumpParts R21 ) by L154 , L151;
assume L156: C27 in ( dom ( product" ( JumpParts R21 ) ) );
L157: C27 in ( DOM ( JumpParts R21 ) ) by L156 , CARD_3:def 12;
L158: C27 in ( dom ( JumpPart ( D10 =0_goto D9 ) ) ) by L157 , L155 , CARD_3:108;
thus L159: C27 in { 1 } by L158 , L152 , FINSEQ_1:2 , FINSEQ_1:38;
end;
let C28 being set;
assume L160: C28 in { 1 };
L161: (for B3 being Function holds (B3 in ( JumpParts R21 ) implies C28 in ( dom B3 )))
proof
let C29 being Function;
assume L162: C29 in ( JumpParts R21 );
consider C30 being (Instruction of ( SCM+FSA )) such that L163: C29 = ( JumpPart C30 ) and L164: ( InsCode C30 ) = R21 by L162;
consider R14 being (Element of ( NAT )), R31 being Int-Location such that L165: C30 = ( R31 =0_goto R14 ) by L151 , L164 , SCMFSA_2:36;
L166: C29 = <* R14 *> by L163 , L165 , L44;
thus L167: thesis by L166 , L160 , FINSEQ_1:2 , FINSEQ_1:38;
end;
L168: C28 in ( DOM ( JumpParts R21 ) ) by L161 , CARD_3:109;
thus L169: thesis by L168 , CARD_3:def 12;
end;
theorem
L170: (for R21 being (InsType of (the InstructionsF of ( SCM+FSA ))) holds (R21 = 8 implies ( dom ( product" ( JumpParts R21 ) ) ) = { 1 }))
proof
let R21 being (InsType of (the InstructionsF of ( SCM+FSA )));
set D11 = the (Element of ( NAT ));
set D12 = the Int-Location;
assume L171: R21 = 8;
L172: ( JumpPart ( D12 >0_goto D11 ) ) = <* D11 *> by L46;
thus L173:now
let C31 being set;
L174: ( InsCode ( D12 >0_goto D11 ) ) = 8 by SCMFSA_2:25;
L175: ( JumpPart ( D12 >0_goto D11 ) ) in ( JumpParts R21 ) by L174 , L171;
assume L176: C31 in ( dom ( product" ( JumpParts R21 ) ) );
L177: C31 in ( DOM ( JumpParts R21 ) ) by L176 , CARD_3:def 12;
L178: C31 in ( dom ( JumpPart ( D12 >0_goto D11 ) ) ) by L177 , L175 , CARD_3:108;
thus L179: C31 in { 1 } by L178 , L172 , FINSEQ_1:2 , FINSEQ_1:38;
end;
let C32 being set;
assume L180: C32 in { 1 };
L181: (for B4 being Function holds (B4 in ( JumpParts R21 ) implies C32 in ( dom B4 )))
proof
let C33 being Function;
assume L182: C33 in ( JumpParts R21 );
consider C34 being (Instruction of ( SCM+FSA )) such that L183: C33 = ( JumpPart C34 ) and L184: ( InsCode C34 ) = R21 by L182;
consider R14 being (Element of ( NAT )), R31 being Int-Location such that L185: C34 = ( R31 >0_goto R14 ) by L171 , L184 , SCMFSA_2:37;
L186: C33 = <* R14 *> by L183 , L185 , L46;
thus L187: thesis by L186 , L180 , FINSEQ_1:2 , FINSEQ_1:38;
end;
L188: C32 in ( DOM ( JumpParts R21 ) ) by L181 , CARD_3:109;
thus L189: thesis by L188 , CARD_3:def 12;
end;
theorem
L190: (for R21 being (InsType of (the InstructionsF of ( SCM+FSA ))) holds (R21 = 9 implies ( JumpParts R21 ) = { ( {} ) }))
proof
let R21 being (InsType of (the InstructionsF of ( SCM+FSA )));
assume L191: R21 = 9;
thus L192:now
let C35 being set;
assume L193: C35 in ( JumpParts R21 );
consider C36 being (Instruction of ( SCM+FSA )) such that L194: C35 = ( JumpPart C36 ) and L195: ( InsCode C36 ) = R21 by L193;
consider R31 being Int-Location, R32 being Int-Location, R39 being FinSeq-Location such that L196: C36 = ( R32 := (R39 , R31) ) by L191 , L195 , SCMFSA_2:38;
L197: C35 = ( {} ) by L194 , L196 , RECDEF_2:def 2;
thus L198: C35 in { ( {} ) } by L197 , TARSKI:def 1;
end;
set D13 = the Int-Location;
set D14 = the FinSeq-Location;
let C37 being set;
assume L199: C37 in { ( {} ) };
L200: C37 = ( {} ) by L199 , TARSKI:def 1;
L201: C37 = ( JumpPart ( D13 := (D14 , D13) ) ) by L200 , RECDEF_2:def 2;
L202: ( InsCode ( D13 := (D14 , D13) ) ) = 9 by SCMFSA_2:26;
thus L203: thesis by L202 , L201 , L191;
end;
theorem
L204: (for R21 being (InsType of (the InstructionsF of ( SCM+FSA ))) holds (R21 = 10 implies ( JumpParts R21 ) = { ( {} ) }))
proof
let R21 being (InsType of (the InstructionsF of ( SCM+FSA )));
assume L205: R21 = 10;
thus L206:now
let C38 being set;
assume L207: C38 in ( JumpParts R21 );
consider C39 being (Instruction of ( SCM+FSA )) such that L208: C38 = ( JumpPart C39 ) and L209: ( InsCode C39 ) = R21 by L207;
consider R31 being Int-Location, R32 being Int-Location, R39 being FinSeq-Location such that L210: C39 = ( (R39 , R31) := R32 ) by L205 , L209 , SCMFSA_2:39;
L211: C38 = ( {} ) by L208 , L210 , RECDEF_2:def 2;
thus L212: C38 in { ( {} ) } by L211 , TARSKI:def 1;
end;
set D15 = the Int-Location;
set D16 = the FinSeq-Location;
let C40 being set;
assume L213: C40 in { ( {} ) };
L214: C40 = ( {} ) by L213 , TARSKI:def 1;
L215: C40 = ( JumpPart ( (D16 , D15) := D15 ) ) by L214 , RECDEF_2:def 2;
L216: ( InsCode ( (D16 , D15) := D15 ) ) = 10 by SCMFSA_2:27;
thus L217: thesis by L216 , L215 , L205;
end;
theorem
L218: (for R21 being (InsType of (the InstructionsF of ( SCM+FSA ))) holds (R21 = 11 implies ( JumpParts R21 ) = { ( {} ) }))
proof
let R21 being (InsType of (the InstructionsF of ( SCM+FSA )));
assume L219: R21 = 11;
thus L220:now
let C41 being set;
assume L221: C41 in ( JumpParts R21 );
consider C42 being (Instruction of ( SCM+FSA )) such that L222: C41 = ( JumpPart C42 ) and L223: ( InsCode C42 ) = R21 by L221;
consider R31 being Int-Location, R39 being FinSeq-Location such that L224: C42 = ( R31 :=len R39 ) by L219 , L223 , SCMFSA_2:40;
L225: C41 = ( {} ) by L222 , L224 , RECDEF_2:def 2;
thus L226: C41 in { ( {} ) } by L225 , TARSKI:def 1;
end;
set D17 = the Int-Location;
set D18 = the FinSeq-Location;
let C43 being set;
assume L227: C43 in { ( {} ) };
L228: C43 = ( {} ) by L227 , TARSKI:def 1;
L229: C43 = ( JumpPart ( D17 :=len D18 ) ) by L228 , RECDEF_2:def 2;
L230: ( InsCode ( D17 :=len D18 ) ) = 11 by SCMFSA_2:28;
thus L231: thesis by L230 , L229 , L219;
end;
theorem
L232: (for R21 being (InsType of (the InstructionsF of ( SCM+FSA ))) holds (R21 = 12 implies ( JumpParts R21 ) = { ( {} ) }))
proof
let R21 being (InsType of (the InstructionsF of ( SCM+FSA )));
assume L233: R21 = 12;
thus L234:now
let C44 being set;
assume L235: C44 in ( JumpParts R21 );
consider C45 being (Instruction of ( SCM+FSA )) such that L236: C44 = ( JumpPart C45 ) and L237: ( InsCode C45 ) = R21 by L235;
consider R31 being Int-Location, R39 being FinSeq-Location such that L238: C45 = ( R39 :=<0,...,0> R31 ) by L233 , L237 , SCMFSA_2:41;
L239: C44 = ( {} ) by L236 , L238 , RECDEF_2:def 2;
thus L240: C44 in { ( {} ) } by L239 , TARSKI:def 1;
end;
set D19 = the Int-Location;
set D20 = the FinSeq-Location;
let C46 being set;
assume L241: C46 in { ( {} ) };
L242: C46 = ( {} ) by L241 , TARSKI:def 1;
L243: C46 = ( JumpPart ( D20 :=<0,...,0> D19 ) ) by L242 , RECDEF_2:def 2;
L244: ( InsCode ( D20 :=<0,...,0> D19 ) ) = 12 by SCMFSA_2:29;
thus L245: thesis by L244 , L243 , L233;
end;
theorem
L246: (for R14 being (Element of ( NAT )) holds ( ( product" ( JumpParts ( InsCode ( goto R14 ) ) ) ) . 1 ) = ( NAT ))
proof
let R14 being (Element of ( NAT ));
L247: ( dom ( product" ( JumpParts ( InsCode ( goto R14 ) ) ) ) ) = { 1 } by L130 , SCMFSA_2:23;
L248: 1 in ( dom ( product" ( JumpParts ( InsCode ( goto R14 ) ) ) ) ) by L247 , TARSKI:def 1;
thus L249:now
let C47 being set;
assume L250: C47 in ( ( product" ( JumpParts ( InsCode ( goto R14 ) ) ) ) . 1 );
L251: C47 in ( pi (( JumpParts ( InsCode ( goto R14 ) ) ) , 1) ) by L250 , L248 , CARD_3:def 12;
consider C48 being Function such that L252: C48 in ( JumpParts ( InsCode ( goto R14 ) ) ) and L253: C47 = ( C48 . 1 ) by L251 , CARD_3:def 6;
consider C49 being (Instruction of ( SCM+FSA )) such that L254: C48 = ( JumpPart C49 ) and L255: ( InsCode C49 ) = ( InsCode ( goto R14 ) ) by L252;
consider R15 being (Element of ( NAT )) such that L256: C49 = ( goto R15 ) by L255 , SCMFSA_2:23 , SCMFSA_2:35;
L257: C48 = <* R15 *> by L254 , L256 , RECDEF_2:def 2;
L258: C47 = R15 by L257 , L253 , FINSEQ_1:def 8;
thus L259: C47 in ( NAT ) by L258;
end;
let C50 being set;
assume L260: C50 in ( NAT );
reconsider D21 = C50 as (Element of ( NAT )) by L260;
L261: ( <* D21 *> . 1 ) = D21 by FINSEQ_1:def 8;
L262: ( InsCode ( goto R14 ) ) = 6 by SCMFSA_2:23;
L263: ( InsCode ( goto R14 ) ) = ( InsCode ( goto D21 ) ) by L262 , SCMFSA_2:23;
L264: ( JumpPart ( goto D21 ) ) = <* D21 *> by RECDEF_2:def 2;
L265: <* D21 *> in ( JumpParts ( InsCode ( goto R14 ) ) ) by L264 , L263;
L266: D21 in ( pi (( JumpParts ( InsCode ( goto R14 ) ) ) , 1) ) by L265 , L261 , CARD_3:def 6;
thus L267: thesis by L266 , L248 , CARD_3:def 12;
end;
theorem
L268: (for R14 being (Element of ( NAT )) holds (for R31 being Int-Location holds ( ( product" ( JumpParts ( InsCode ( R31 =0_goto R14 ) ) ) ) . 1 ) = ( NAT )))
proof
let R14 being (Element of ( NAT ));
let R31 being Int-Location;
L269: ( dom ( product" ( JumpParts ( InsCode ( R31 =0_goto R14 ) ) ) ) ) = { 1 } by L150 , SCMFSA_2:24;
L270: 1 in ( dom ( product" ( JumpParts ( InsCode ( R31 =0_goto R14 ) ) ) ) ) by L269 , TARSKI:def 1;
thus L271:now
let C51 being set;
assume L272: C51 in ( ( product" ( JumpParts ( InsCode ( R31 =0_goto R14 ) ) ) ) . 1 );
L273: C51 in ( pi (( JumpParts ( InsCode ( R31 =0_goto R14 ) ) ) , 1) ) by L272 , L270 , CARD_3:def 12;
consider C52 being Function such that L274: C52 in ( JumpParts ( InsCode ( R31 =0_goto R14 ) ) ) and L275: C51 = ( C52 . 1 ) by L273 , CARD_3:def 6;
consider C53 being (Instruction of ( SCM+FSA )) such that L276: C52 = ( JumpPart C53 ) and L277: ( InsCode C53 ) = ( InsCode ( R31 =0_goto R14 ) ) by L274;
consider R15 being (Element of ( NAT )), R32 being Int-Location such that L278: C53 = ( R32 =0_goto R15 ) by L277 , SCMFSA_2:24 , SCMFSA_2:36;
L279: C52 = <* R15 *> by L276 , L278 , L44;
L280: C51 = R15 by L279 , L275 , FINSEQ_1:40;
thus L281: C51 in ( NAT ) by L280;
end;
let C54 being set;
assume L282: C54 in ( NAT );
reconsider D22 = C54 as (Element of ( NAT )) by L282;
L283: ( <* D22 *> . 1 ) = D22 by FINSEQ_1:40;
L284: ( InsCode ( R31 =0_goto R14 ) ) = 7 by SCMFSA_2:24;
L285: ( InsCode ( R31 =0_goto R14 ) ) = ( InsCode ( R31 =0_goto D22 ) ) by L284 , SCMFSA_2:24;
L286: ( JumpPart ( R31 =0_goto D22 ) ) = <* D22 *> by L44;
L287: <* D22 *> in ( JumpParts ( InsCode ( R31 =0_goto R14 ) ) ) by L286 , L285;
L288: D22 in ( pi (( JumpParts ( InsCode ( R31 =0_goto R14 ) ) ) , 1) ) by L287 , L283 , CARD_3:def 6;
thus L289: thesis by L288 , L270 , CARD_3:def 12;
end;
theorem
L290: (for R14 being (Element of ( NAT )) holds (for R31 being Int-Location holds ( ( product" ( JumpParts ( InsCode ( R31 >0_goto R14 ) ) ) ) . 1 ) = ( NAT )))
proof
let R14 being (Element of ( NAT ));
let R31 being Int-Location;
L291: ( dom ( product" ( JumpParts ( InsCode ( R31 >0_goto R14 ) ) ) ) ) = { 1 } by L170 , SCMFSA_2:25;
L292: 1 in ( dom ( product" ( JumpParts ( InsCode ( R31 >0_goto R14 ) ) ) ) ) by L291 , TARSKI:def 1;
thus L293:now
let C55 being set;
assume L294: C55 in ( ( product" ( JumpParts ( InsCode ( R31 >0_goto R14 ) ) ) ) . 1 );
L295: C55 in ( pi (( JumpParts ( InsCode ( R31 >0_goto R14 ) ) ) , 1) ) by L294 , L292 , CARD_3:def 12;
consider C56 being Function such that L296: C56 in ( JumpParts ( InsCode ( R31 >0_goto R14 ) ) ) and L297: C55 = ( C56 . 1 ) by L295 , CARD_3:def 6;
consider C57 being (Instruction of ( SCM+FSA )) such that L298: C56 = ( JumpPart C57 ) and L299: ( InsCode C57 ) = ( InsCode ( R31 >0_goto R14 ) ) by L296;
consider R15 being (Element of ( NAT )), R32 being Int-Location such that L300: C57 = ( R32 >0_goto R15 ) by L299 , SCMFSA_2:25 , SCMFSA_2:37;
L301: C56 = <* R15 *> by L298 , L300 , L46;
L302: C55 = R15 by L301 , L297 , FINSEQ_1:40;
thus L303: C55 in ( NAT ) by L302;
end;
let C58 being set;
assume L304: C58 in ( NAT );
reconsider D23 = C58 as (Element of ( NAT )) by L304;
L305: ( <* D23 *> . 1 ) = D23 by FINSEQ_1:40;
L306: ( InsCode ( R31 >0_goto R14 ) ) = 8 by SCMFSA_2:25;
L307: ( InsCode ( R31 >0_goto R14 ) ) = ( InsCode ( R31 >0_goto D23 ) ) by L306 , SCMFSA_2:25;
L308: ( JumpPart ( R31 >0_goto D23 ) ) = <* D23 *> by L46;
L309: <* D23 *> in ( JumpParts ( InsCode ( R31 >0_goto R14 ) ) ) by L308 , L307;
L310: D23 in ( pi (( JumpParts ( InsCode ( R31 >0_goto R14 ) ) ) , 1) ) by L309 , L305 , CARD_3:def 6;
thus L311: thesis by L310 , L292 , CARD_3:def 12;
end;
L312: (for B5 being (Instruction of ( SCM+FSA )) holds ((for B6 being (Element of ( NAT )) holds ( NIC (B5 , B6) ) = { ( succ B6 ) }) implies ( JUMP B5 ) is  empty))
proof
reconsider D24 = ( 0 ) , D25 = 1 as (Element of ( NAT ));
let C59 being (Instruction of ( SCM+FSA ));
assume L313: (for B7 being (Element of ( NAT )) holds ( NIC (C59 , B7) ) = { ( succ B7 ) });
set D26 = { ( NIC (C59 , B8) ) where B8 is (Element of ( NAT )) : (not contradiction) };
reconsider D27 = D24 , D28 = D25 as (Element of ( NAT ));
assume L314: (not thesis);
consider C60 being set such that L315: C60 in ( meet D26 ) by L314 , XBOOLE_0:def 1;
L316: ( NIC (C59 , D27) ) = { ( succ D27 ) } by L313;
L317: { ( succ D27 ) } in D26 by L316;
L318: C60 in { ( succ D27 ) } by L317 , L315 , SETFAM_1:def 1;
L319: C60 = ( succ D27 ) by L318 , TARSKI:def 1;
L320: ( NIC (C59 , D28) ) = { ( succ D28 ) } by L313;
L321: { ( succ D28 ) } in D26 by L320;
L322: C60 in { ( succ D28 ) } by L321 , L315 , SETFAM_1:def 1;
thus L323: contradiction by L322 , L319 , TARSKI:def 1;
end;
registration
cluster ( JUMP ( halt ( SCM+FSA ) ) ) ->  empty;
coherence;
end;
registration
let R31 being Int-Location;
let R32 being Int-Location;
cluster ( R31 := R32 ) ->  sequential;
coherence
proof
let C61 being (State of ( SCM+FSA ));
thus L325: thesis by SCMFSA_2:63;
end;
cluster ( AddTo (R31 , R32) ) ->  sequential;
coherence
proof
let C62 being (State of ( SCM+FSA ));
thus L326: thesis by SCMFSA_2:64;
end;
cluster ( SubFrom (R31 , R32) ) ->  sequential;
coherence
proof
let C63 being (State of ( SCM+FSA ));
thus L327: thesis by SCMFSA_2:65;
end;
cluster ( MultBy (R31 , R32) ) ->  sequential;
coherence
proof
let C64 being (State of ( SCM+FSA ));
thus L328: thesis by SCMFSA_2:66;
end;
cluster ( Divide (R31 , R32) ) ->  sequential;
coherence
proof
let C65 being (State of ( SCM+FSA ));
thus L329: thesis by SCMFSA_2:67;
end;
end;
registration
let R31 being Int-Location;
let R32 being Int-Location;
cluster ( JUMP ( R31 := R32 ) ) ->  empty;
coherence
proof
L331: (for B9 being (Element of ( NAT )) holds ( NIC (( R31 := R32 ) , B9) ) = { ( succ B9 ) }) by AMISTD_1:12;
thus L332: thesis by L331 , L312;
end;
cluster ( JUMP ( AddTo (R31 , R32) ) ) ->  empty;
coherence
proof
L333: (for B10 being (Element of ( NAT )) holds ( NIC (( AddTo (R31 , R32) ) , B10) ) = { ( succ B10 ) }) by AMISTD_1:12;
thus L334: thesis by L333 , L312;
end;
cluster ( JUMP ( SubFrom (R31 , R32) ) ) ->  empty;
coherence
proof
L335: (for B11 being (Element of ( NAT )) holds ( NIC (( SubFrom (R31 , R32) ) , B11) ) = { ( succ B11 ) }) by AMISTD_1:12;
thus L336: thesis by L335 , L312;
end;
cluster ( JUMP ( MultBy (R31 , R32) ) ) ->  empty;
coherence
proof
L337: (for B12 being (Element of ( NAT )) holds ( NIC (( MultBy (R31 , R32) ) , B12) ) = { ( succ B12 ) }) by AMISTD_1:12;
thus L338: thesis by L337 , L312;
end;
cluster ( JUMP ( Divide (R31 , R32) ) ) ->  empty;
coherence
proof
L339: (for B13 being (Element of ( NAT )) holds ( NIC (( Divide (R31 , R32) ) , B13) ) = { ( succ B13 ) }) by AMISTD_1:12;
thus L340: thesis by L339 , L312;
end;
end;
theorem
L342: (for R13 being (Element of ( NAT )) holds (for R14 being (Element of ( NAT )) holds ( NIC (( goto R14 ) , R13) ) = { R14 }))
proof
let R13 being (Element of ( NAT ));
let R14 being (Element of ( NAT ));
L343:
now
let C66 being set;
L344:
now
reconsider D29 = R13 as (Element of ( Values ( IC ( SCM+FSA ) ) )) by MEMSTR_0:def 6;
reconsider D30 = D29 as (Element of ( NAT ));
set D31 = ( goto R14 );
set D32 = the (State of ( SCM+FSA ));
set D33 = the (Instruction-Sequence of ( SCM+FSA ));
assume L345: C66 = R14;
reconsider D34 = ( D32 +* (( IC ( SCM+FSA ) ) , D29) ) as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
reconsider D35 = ( D33 +* (R13 , D31) ) as (Instruction-Sequence of ( SCM+FSA ));
L346: ( IC ( SCM+FSA ) ) in ( dom D32 ) by MEMSTR_0:2;
L347: ( IC D34 ) = D30 by L346 , FUNCT_7:31;
L348: ( D35 /. R13 ) = ( D35 . R13 ) by PBOOLE:143;
L349: R13 in ( NAT );
L350: R13 in ( dom D33 ) by L349 , PARTFUN1:def 2;
L351: ( D35 . D30 ) = D31 by L350 , FUNCT_7:31;
L352: ( IC ( Following (D35 , D34) ) ) = R14 by L351 , L347 , L348 , SCMFSA_2:69;
thus L353: C66 in { ( IC ( Exec (( goto R14 ) , B14) ) ) where B14 is (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) : ( IC B14 ) = R13 } by L352 , L345 , L347 , L351 , L348;
end;
L354:
now
assume L355: C66 in { ( IC ( Exec (( goto R14 ) , B15) ) ) where B15 is (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) : ( IC B15 ) = R13 };
L356: (ex B16 being (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) st (C66 = ( IC ( Exec (( goto R14 ) , B16) ) ) & ( IC B16 ) = R13)) by L355;
thus L357: C66 = R14 by L356 , SCMFSA_2:69;
end;
thus L358: (C66 in { R14 } iff C66 in { ( IC ( Exec (( goto R14 ) , B17) ) ) where B17 is (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) : ( IC B17 ) = R13 }) by L354 , L344 , TARSKI:def 1;
end;
thus L359: thesis by L343 , TARSKI:1;
end;
theorem
L360: (for R14 being (Element of ( NAT )) holds ( JUMP ( goto R14 ) ) = { R14 })
proof
let R14 being (Element of ( NAT ));
set D36 = { ( NIC (( goto R14 ) , R13) ) where R13 is (Element of ( NAT )) : (not contradiction) };
L361:
now
let C67 being set;
thus L362:now
set D37 = 1;
L363: ( NIC (( goto R14 ) , D37) ) in D36;
assume L364: C67 in ( meet D36 );
L365: C67 in ( NIC (( goto R14 ) , D37) ) by L364 , L363 , SETFAM_1:def 1;
thus L366: C67 in { R14 } by L365 , L342;
end;
assume L367: C67 in { R14 };
L368: C67 = R14 by L367 , TARSKI:def 1;
L369:
now
let C68 being set;
assume L370: C68 in D36;
consider C69 being (Element of ( NAT )) such that L371: C68 = ( NIC (( goto R14 ) , C69) ) by L370;
L372: ( NIC (( goto R14 ) , C69) ) = { R14 } by L342;
thus L373: R14 in C68 by L372 , L371 , TARSKI:def 1;
end;
L374: ( NIC (( goto R14 ) , R14) ) in D36;
thus L375: C67 in ( meet D36 ) by L374 , L368 , L369 , SETFAM_1:def 1;
end;
thus L376: thesis by L361 , TARSKI:1;
end;
registration
let R14 being (Element of ( NAT ));
cluster ( JUMP ( goto R14 ) ) -> 1 -element;
coherence
proof
L377: ( JUMP ( goto R14 ) ) = { R14 } by L360;
thus L378: thesis by L377;
end;
end;
theorem
L380: (for R13 being (Element of ( NAT )) holds (for R14 being (Element of ( NAT )) holds (for R31 being Int-Location holds ( NIC (( R31 =0_goto R14 ) , R13) ) = { R14 , ( succ R13 ) })))
proof
let R13 being (Element of ( NAT ));
let R14 being (Element of ( NAT ));
let R31 being Int-Location;
set D38 = the (State of ( SCM+FSA ));
set D39 = the (Instruction-Sequence of ( SCM+FSA ));
thus L381:now
let C70 being set;
assume L382: C70 in ( NIC (( R31 =0_goto R14 ) , R13) );
consider C71 being (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) such that L383: C70 = ( IC ( Exec (( R31 =0_goto R14 ) , C71) ) ) and L384: ( IC C71 ) = R13 by L382;
per cases ;
suppose L385: ( C71 . R31 ) = ( 0 );

L386: C70 = R14 by L385 , L383 , SCMFSA_2:70;
thus L387: C70 in { R14 , ( succ R13 ) } by L386 , TARSKI:def 2;
end;
suppose L388: ( C71 . R31 ) <> ( 0 );

L389: C70 = ( succ R13 ) by L388 , L383 , L384 , SCMFSA_2:70;
thus L390: C70 in { R14 , ( succ R13 ) } by L389 , TARSKI:def 2;
end;
end;
let C72 being set;
set D40 = ( R31 =0_goto R14 );
L392: ( IC ( SCM+FSA ) ) <> R31 by SCMFSA_2:56;
reconsider D41 = R13 as (Element of ( Values ( IC ( SCM+FSA ) ) )) by MEMSTR_0:def 6;
reconsider D42 = ( D38 +* (( IC ( SCM+FSA ) ) , D41) ) as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
reconsider D43 = ( D39 +* (R13 , D40) ) as (Instruction-Sequence of ( SCM+FSA ));
reconsider D44 = R13 as (Element of ( NAT ));
assume L393: C72 in { R14 , ( succ R13 ) };
per cases  by L393 , TARSKI:def 2;
suppose L394: C72 = R14;

reconsider D45 = ( D42 +* ( R31 .--> ( 0 ) ) ) as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
L395: ( IC ( SCM+FSA ) ) in ( dom D38 ) by MEMSTR_0:2;
L396: ( dom ( R31 .--> ( 0 ) ) ) = { R31 } by FUNCOP_1:13;
L397: (not ( IC ( SCM+FSA ) ) in ( dom ( R31 .--> ( 0 ) ) )) by L396 , L392 , TARSKI:def 1;
L398: ( IC D45 ) = ( IC D42 ) by L397 , FUNCT_4:11
.= D44 by L395 , FUNCT_7:31;
L399: ( D43 /. R13 ) = ( D43 . R13 ) by PBOOLE:143;
L400: R13 in ( NAT );
L401: R13 in ( dom D39 ) by L400 , PARTFUN1:def 2;
L402: ( D43 . R13 ) = D40 by L401 , FUNCT_7:31;
L403: R31 in ( dom ( R31 .--> ( 0 ) ) ) by L396 , TARSKI:def 1;
L404: ( D45 . R31 ) = ( ( R31 .--> ( 0 ) ) . R31 ) by L403 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L405: ( IC ( Following (D43 , D45) ) ) = R14 by L404 , L398 , L402 , L399 , SCMFSA_2:70;
thus L406: thesis by L405 , L394 , L398 , L402 , L399;
end;
suppose L407: C72 = ( succ R13 );

reconsider D46 = ( D42 +* ( R31 .--> 1 ) ) as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
L408: ( IC ( SCM+FSA ) ) in ( dom D38 ) by MEMSTR_0:2;
L409: ( dom ( R31 .--> 1 ) ) = { R31 } by FUNCOP_1:13;
L410: (not ( IC ( SCM+FSA ) ) in ( dom ( R31 .--> 1 ) )) by L409 , L392 , TARSKI:def 1;
L411: ( IC D46 ) = ( IC D42 ) by L410 , FUNCT_4:11
.= D44 by L408 , FUNCT_7:31;
L412: ( D43 /. R13 ) = ( D43 . R13 ) by PBOOLE:143;
L413: R13 in ( NAT );
L414: R13 in ( dom D39 ) by L413 , PARTFUN1:def 2;
L415: ( D43 . R13 ) = D40 by L414 , FUNCT_7:31;
L416: R31 in ( dom ( R31 .--> 1 ) ) by L409 , TARSKI:def 1;
L417: ( D46 . R31 ) = ( ( R31 .--> 1 ) . R31 ) by L416 , FUNCT_4:13
.= 1 by FUNCOP_1:72;
L418: ( IC ( Following (D43 , D46) ) ) = ( succ R13 ) by L417 , L411 , L415 , L412 , SCMFSA_2:70;
thus L419: thesis by L418 , L407 , L411 , L415 , L412;
end;
end;
theorem
L421: (for R14 being (Element of ( NAT )) holds (for R31 being Int-Location holds ( JUMP ( R31 =0_goto R14 ) ) = { R14 }))
proof
let R14 being (Element of ( NAT ));
let R31 being Int-Location;
set D47 = { ( NIC (( R31 =0_goto R14 ) , R13) ) where R13 is (Element of ( NAT )) : (not contradiction) };
L422:
now
let C73 being set;
L423:
now
let C74 being set;
assume L424: C74 in D47;
consider C75 being (Element of ( NAT )) such that L425: C74 = ( NIC (( R31 =0_goto R14 ) , C75) ) by L424;
L426: ( NIC (( R31 =0_goto R14 ) , C75) ) = { R14 , ( succ C75 ) } by L380;
thus L427: R14 in C74 by L426 , L425 , TARSKI:def 2;
end;
thus L428:now
set D48 = 1;
set D49 = 2;
assume L429: C73 in ( meet D47 );
L430: ( NIC (( R31 =0_goto R14 ) , D49) ) = { R14 , ( succ D49 ) } by L380;
L431: ( NIC (( R31 =0_goto R14 ) , D49) ) in D47;
L432: C73 in ( NIC (( R31 =0_goto R14 ) , D49) ) by L431 , L429 , SETFAM_1:def 1;
L433: (C73 = R14 or C73 = ( succ D49 )) by L432 , L430 , TARSKI:def 2;
L434: ( NIC (( R31 =0_goto R14 ) , D48) ) = { R14 , ( succ D48 ) } by L380;
L435: ( NIC (( R31 =0_goto R14 ) , D48) ) in D47;
L436: C73 in ( NIC (( R31 =0_goto R14 ) , D48) ) by L435 , L429 , SETFAM_1:def 1;
L437: (C73 = R14 or C73 = ( succ D48 )) by L436 , L434 , TARSKI:def 2;
thus L438: C73 in { R14 } by L437 , L433 , TARSKI:def 1;
end;
assume L439: C73 in { R14 };
L440: C73 = R14 by L439 , TARSKI:def 1;
L441: ( NIC (( R31 =0_goto R14 ) , R14) ) in D47;
thus L442: C73 in ( meet D47 ) by L441 , L440 , L423 , SETFAM_1:def 1;
end;
thus L443: thesis by L422 , TARSKI:1;
end;
registration
let R31 being Int-Location;
let R14 being (Element of ( NAT ));
cluster ( JUMP ( R31 =0_goto R14 ) ) -> 1 -element;
coherence
proof
L444: ( JUMP ( R31 =0_goto R14 ) ) = { R14 } by L421;
thus L445: thesis by L444;
end;
end;
theorem
L447: (for R13 being (Element of ( NAT )) holds (for R14 being (Element of ( NAT )) holds (for R31 being Int-Location holds ( NIC (( R31 >0_goto R14 ) , R13) ) = { R14 , ( succ R13 ) })))
proof
let R13 being (Element of ( NAT ));
let R14 being (Element of ( NAT ));
let R31 being Int-Location;
set D50 = the (State of ( SCM+FSA ));
set D51 = the (Instruction-Sequence of ( SCM+FSA ));
thus L448:now
let C76 being set;
assume L449: C76 in ( NIC (( R31 >0_goto R14 ) , R13) );
consider C77 being (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) such that L450: C76 = ( IC ( Exec (( R31 >0_goto R14 ) , C77) ) ) and L451: ( IC C77 ) = R13 by L449;
per cases ;
suppose L452: ( C77 . R31 ) > ( 0 );

L453: C76 = R14 by L452 , L450 , SCMFSA_2:71;
thus L454: C76 in { R14 , ( succ R13 ) } by L453 , TARSKI:def 2;
end;
suppose L455: ( C77 . R31 ) <= ( 0 );

L456: C76 = ( succ R13 ) by L455 , L450 , L451 , SCMFSA_2:71;
thus L457: C76 in { R14 , ( succ R13 ) } by L456 , TARSKI:def 2;
end;
end;
let C78 being set;
set D52 = ( R31 >0_goto R14 );
L459: ( IC ( SCM+FSA ) ) <> R31 by SCMFSA_2:56;
reconsider D53 = R13 as (Element of ( Values ( IC ( SCM+FSA ) ) )) by MEMSTR_0:def 6;
reconsider D54 = R13 as (Element of ( NAT ));
reconsider D55 = ( D50 +* (( IC ( SCM+FSA ) ) , D53) ) as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
reconsider D56 = ( D51 +* (R13 , D52) ) as (Instruction-Sequence of ( SCM+FSA ));
assume L460: C78 in { R14 , ( succ R13 ) };
per cases  by L460 , TARSKI:def 2;
suppose L461: C78 = R14;

reconsider D57 = ( D55 +* ( R31 .--> 1 ) ) as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
L462: ( IC ( SCM+FSA ) ) in ( dom D50 ) by MEMSTR_0:2;
L463: ( dom ( R31 .--> 1 ) ) = { R31 } by FUNCOP_1:13;
L464: (not ( IC ( SCM+FSA ) ) in ( dom ( R31 .--> 1 ) )) by L463 , L459 , TARSKI:def 1;
L465: ( IC D57 ) = ( IC D55 ) by L464 , FUNCT_4:11
.= D54 by L462 , FUNCT_7:31;
L466: ( D56 /. R13 ) = ( D56 . R13 ) by PBOOLE:143;
L467: R13 in ( NAT );
L468: R13 in ( dom D51 ) by L467 , PARTFUN1:def 2;
L469: ( D56 . R13 ) = D52 by L468 , FUNCT_7:31;
L470: R31 in ( dom ( R31 .--> 1 ) ) by L463 , TARSKI:def 1;
L471: ( D57 . R31 ) = ( ( R31 .--> 1 ) . R31 ) by L470 , FUNCT_4:13
.= 1 by FUNCOP_1:72;
L472: ( IC ( Following (D56 , D57) ) ) = R14 by L471 , L465 , L469 , L466 , SCMFSA_2:71;
thus L473: thesis by L472 , L461 , L465 , L469 , L466;
end;
suppose L474: C78 = ( succ R13 );

reconsider D58 = ( D55 +* ( R31 .--> ( 0 ) ) ) as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
L475: ( IC ( SCM+FSA ) ) in ( dom D50 ) by MEMSTR_0:2;
L476: ( dom ( R31 .--> ( 0 ) ) ) = { R31 } by FUNCOP_1:13;
L477: (not ( IC ( SCM+FSA ) ) in ( dom ( R31 .--> ( 0 ) ) )) by L476 , L459 , TARSKI:def 1;
L478: ( IC D58 ) = ( IC D55 ) by L477 , FUNCT_4:11
.= D54 by L475 , FUNCT_7:31;
L479: ( D56 /. R13 ) = ( D56 . R13 ) by PBOOLE:143;
L480: R13 in ( NAT );
L481: R13 in ( dom D51 ) by L480 , PARTFUN1:def 2;
L482: ( D56 . R13 ) = D52 by L481 , FUNCT_7:31;
L483: R31 in ( dom ( R31 .--> ( 0 ) ) ) by L476 , TARSKI:def 1;
L484: ( D58 . R31 ) = ( ( R31 .--> ( 0 ) ) . R31 ) by L483 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L485: ( IC ( Following (D56 , D58) ) ) = ( succ R13 ) by L484 , L478 , L482 , L479 , SCMFSA_2:71;
thus L486: thesis by L485 , L474 , L478 , L482 , L479;
end;
end;
theorem
L488: (for R14 being (Element of ( NAT )) holds (for R31 being Int-Location holds ( JUMP ( R31 >0_goto R14 ) ) = { R14 }))
proof
let R14 being (Element of ( NAT ));
let R31 being Int-Location;
set D59 = { ( NIC (( R31 >0_goto R14 ) , R13) ) where R13 is (Element of ( NAT )) : (not contradiction) };
L489:
now
let C79 being set;
L490:
now
let C80 being set;
assume L491: C80 in D59;
consider C81 being (Element of ( NAT )) such that L492: C80 = ( NIC (( R31 >0_goto R14 ) , C81) ) by L491;
L493: ( NIC (( R31 >0_goto R14 ) , C81) ) = { R14 , ( succ C81 ) } by L447;
thus L494: R14 in C80 by L493 , L492 , TARSKI:def 2;
end;
thus L495:now
set D60 = 1;
set D61 = 2;
assume L496: C79 in ( meet D59 );
L497: ( NIC (( R31 >0_goto R14 ) , D61) ) = { R14 , ( succ D61 ) } by L447;
L498: ( NIC (( R31 >0_goto R14 ) , D61) ) in D59;
L499: C79 in ( NIC (( R31 >0_goto R14 ) , D61) ) by L498 , L496 , SETFAM_1:def 1;
L500: (C79 = R14 or C79 = ( succ D61 )) by L499 , L497 , TARSKI:def 2;
L501: ( NIC (( R31 >0_goto R14 ) , D60) ) = { R14 , ( succ D60 ) } by L447;
L502: ( NIC (( R31 >0_goto R14 ) , D60) ) in D59;
L503: C79 in ( NIC (( R31 >0_goto R14 ) , D60) ) by L502 , L496 , SETFAM_1:def 1;
L504: (C79 = R14 or C79 = ( succ D60 )) by L503 , L501 , TARSKI:def 2;
thus L505: C79 in { R14 } by L504 , L500 , TARSKI:def 1;
end;
assume L506: C79 in { R14 };
L507: C79 = R14 by L506 , TARSKI:def 1;
L508: ( NIC (( R31 >0_goto R14 ) , R14) ) in D59;
thus L509: C79 in ( meet D59 ) by L508 , L507 , L490 , SETFAM_1:def 1;
end;
thus L510: thesis by L489 , TARSKI:1;
end;
registration
let R31 being Int-Location;
let R14 being (Element of ( NAT ));
cluster ( JUMP ( R31 >0_goto R14 ) ) -> 1 -element;
coherence
proof
L511: ( JUMP ( R31 >0_goto R14 ) ) = { R14 } by L488;
thus L512: thesis by L511;
end;
end;
registration
let R31 being Int-Location;
let R32 being Int-Location;
let R39 being FinSeq-Location;
cluster ( R31 := (R39 , R32) ) ->  sequential;
coherence
proof
let C82 being (State of ( SCM+FSA ));
thus L514: thesis by SCMFSA_2:72;
end;
end;
registration
let R31 being Int-Location;
let R32 being Int-Location;
let R39 being FinSeq-Location;
cluster ( JUMP ( R31 := (R39 , R32) ) ) ->  empty;
coherence
proof
L516: (for B18 being (Element of ( NAT )) holds ( NIC (( R31 := (R39 , R32) ) , B18) ) = { ( succ B18 ) }) by AMISTD_1:12;
thus L517: thesis by L516 , L312;
end;
end;
registration
let R31 being Int-Location;
let R32 being Int-Location;
let R39 being FinSeq-Location;
cluster ( (R39 , R32) := R31 ) ->  sequential;
coherence
proof
let C83 being (State of ( SCM+FSA ));
thus L519: thesis by SCMFSA_2:73;
end;
end;
registration
let R31 being Int-Location;
let R32 being Int-Location;
let R39 being FinSeq-Location;
cluster ( JUMP ( (R39 , R32) := R31 ) ) ->  empty;
coherence
proof
L521: (for B19 being (Element of ( NAT )) holds ( NIC (( (R39 , R32) := R31 ) , B19) ) = { ( succ B19 ) }) by AMISTD_1:12;
thus L522: thesis by L521 , L312;
end;
end;
registration
let R31 being Int-Location;
let R39 being FinSeq-Location;
cluster ( R31 :=len R39 ) ->  sequential;
coherence
proof
let C84 being (State of ( SCM+FSA ));
thus L524: thesis by SCMFSA_2:74;
end;
end;
registration
let R31 being Int-Location;
let R39 being FinSeq-Location;
cluster ( JUMP ( R31 :=len R39 ) ) ->  empty;
coherence
proof
L526: (for B20 being (Element of ( NAT )) holds ( NIC (( R31 :=len R39 ) , B20) ) = { ( succ B20 ) }) by AMISTD_1:12;
thus L527: thesis by L526 , L312;
end;
end;
registration
let R31 being Int-Location;
let R39 being FinSeq-Location;
cluster ( R39 :=<0,...,0> R31 ) ->  sequential;
coherence
proof
let C85 being (State of ( SCM+FSA ));
thus L529: thesis by SCMFSA_2:75;
end;
end;
registration
let R31 being Int-Location;
let R39 being FinSeq-Location;
cluster ( JUMP ( R39 :=<0,...,0> R31 ) ) ->  empty;
coherence
proof
L531: (for B21 being (Element of ( NAT )) holds ( NIC (( R39 :=<0,...,0> R31 ) , B21) ) = { ( succ B21 ) }) by AMISTD_1:12;
thus L532: thesis by L531 , L312;
end;
end;
theorem
L534: (for R13 being (Element of ( NAT )) holds ( SUCC (R13 , ( SCM+FSA )) ) = { R13 , ( succ R13 ) })
proof
let R13 being (Element of ( NAT ));
set D62 = { ( ( NIC (B22 , R13) ) \ ( JUMP B22 ) ) where B22 is (Element of (the InstructionsF of ( SCM+FSA ))) : (not contradiction) };
set D63 = { R13 , ( succ R13 ) };
L535:
now
let C86 being set;
thus L536:now
assume L537: C86 in ( union D62 );
consider C87 being set such that L538: C86 in C87 and L539: C87 in D62 by L537 , TARSKI:def 4;
consider C88 being (Element of (the InstructionsF of ( SCM+FSA ))) such that L540: C87 = ( ( NIC (C88 , R13) ) \ ( JUMP C88 ) ) by L539;
per cases  by SCMFSA_2:93;
suppose L541: C88 = [ ( 0 ) , ( {} ) , ( {} ) ];

L542: C86 in ( { R13 } \ ( JUMP ( halt ( SCM+FSA ) ) ) ) by L541 , L538 , L540 , AMISTD_1:2;
L543: C86 = R13 by L542 , TARSKI:def 1;
thus L544: C86 in D63 by L543 , TARSKI:def 2;
end;
suppose L545: (ex R31 being Int-Location st (ex R32 being Int-Location st C88 = ( R31 := R32 )));

consider R31 being Int-Location, R32 being Int-Location such that L546: C88 = ( R31 := R32 ) by L545;
L547: C86 in ( { ( succ R13 ) } \ ( JUMP ( R31 := R32 ) ) ) by L538 , L540 , L546 , AMISTD_1:12;
L548: C86 = ( succ R13 ) by L547 , TARSKI:def 1;
thus L549: C86 in D63 by L548 , TARSKI:def 2;
end;
suppose L550: (ex R31 being Int-Location st (ex R32 being Int-Location st C88 = ( AddTo (R31 , R32) )));

consider R31 being Int-Location, R32 being Int-Location such that L551: C88 = ( AddTo (R31 , R32) ) by L550;
L552: C86 in ( { ( succ R13 ) } \ ( JUMP ( AddTo (R31 , R32) ) ) ) by L538 , L540 , L551 , AMISTD_1:12;
L553: C86 = ( succ R13 ) by L552 , TARSKI:def 1;
thus L554: C86 in D63 by L553 , TARSKI:def 2;
end;
suppose L555: (ex R31 being Int-Location st (ex R32 being Int-Location st C88 = ( SubFrom (R31 , R32) )));

consider R31 being Int-Location, R32 being Int-Location such that L556: C88 = ( SubFrom (R31 , R32) ) by L555;
L557: C86 in ( { ( succ R13 ) } \ ( JUMP ( SubFrom (R31 , R32) ) ) ) by L538 , L540 , L556 , AMISTD_1:12;
L558: C86 = ( succ R13 ) by L557 , TARSKI:def 1;
thus L559: C86 in D63 by L558 , TARSKI:def 2;
end;
suppose L560: (ex R31 being Int-Location st (ex R32 being Int-Location st C88 = ( MultBy (R31 , R32) )));

consider R31 being Int-Location, R32 being Int-Location such that L561: C88 = ( MultBy (R31 , R32) ) by L560;
L562: C86 in ( { ( succ R13 ) } \ ( JUMP ( MultBy (R31 , R32) ) ) ) by L538 , L540 , L561 , AMISTD_1:12;
L563: C86 = ( succ R13 ) by L562 , TARSKI:def 1;
thus L564: C86 in D63 by L563 , TARSKI:def 2;
end;
suppose L565: (ex R31 being Int-Location st (ex R32 being Int-Location st C88 = ( Divide (R31 , R32) )));

consider R31 being Int-Location, R32 being Int-Location such that L566: C88 = ( Divide (R31 , R32) ) by L565;
L567: C86 in ( { ( succ R13 ) } \ ( JUMP ( Divide (R31 , R32) ) ) ) by L538 , L540 , L566 , AMISTD_1:12;
L568: C86 = ( succ R13 ) by L567 , TARSKI:def 1;
thus L569: C86 in D63 by L568 , TARSKI:def 2;
end;
suppose L570: (ex R14 being (Element of ( NAT )) st C88 = ( goto R14 ));

consider R14 being (Element of ( NAT )) such that L571: C88 = ( goto R14 ) by L570;
L572: C86 in ( { R14 } \ ( JUMP C88 ) ) by L538 , L540 , L571 , L342;
L573: C86 in ( { R14 } \ { R14 } ) by L572 , L571 , L360;
thus L574: C86 in D63 by L573 , XBOOLE_1:37;
end;
suppose L575: (ex R14 being (Element of ( NAT )) st (ex R31 being Int-Location st C88 = ( R31 =0_goto R14 )));

consider R14 being (Element of ( NAT )), R31 being Int-Location such that L576: C88 = ( R31 =0_goto R14 ) by L575;
L577: ( NIC (C88 , R13) ) = { R14 , ( succ R13 ) } by L576 , L380;
L578: C86 in ( NIC (C88 , R13) ) by L538 , L540 , XBOOLE_0:def 5;
L579: (C86 = R14 or C86 = ( succ R13 )) by L578 , L577 , TARSKI:def 2;
L580: C86 in ( ( NIC (C88 , R13) ) \ { R14 } ) by L538 , L540 , L576 , L421;
L581: (not C86 in { R14 }) by L580 , XBOOLE_0:def 5;
thus L582: C86 in D63 by L581 , L579 , TARSKI:def 1 , TARSKI:def 2;
end;
suppose L583: (ex R14 being (Element of ( NAT )) st (ex R31 being Int-Location st C88 = ( R31 >0_goto R14 )));

consider R14 being (Element of ( NAT )), R31 being Int-Location such that L584: C88 = ( R31 >0_goto R14 ) by L583;
L585: ( NIC (C88 , R13) ) = { R14 , ( succ R13 ) } by L584 , L447;
L586: C86 in ( NIC (C88 , R13) ) by L538 , L540 , XBOOLE_0:def 5;
L587: (C86 = R14 or C86 = ( succ R13 )) by L586 , L585 , TARSKI:def 2;
L588: C86 in ( ( NIC (C88 , R13) ) \ { R14 } ) by L538 , L540 , L584 , L488;
L589: (not C86 in { R14 }) by L588 , XBOOLE_0:def 5;
thus L590: C86 in D63 by L589 , L587 , TARSKI:def 1 , TARSKI:def 2;
end;
suppose L591: (ex R31 being Int-Location st (ex R32 being Int-Location st (ex R39 being FinSeq-Location st C88 = ( R32 := (R39 , R31) ))));

consider R31 being Int-Location, R32 being Int-Location, R39 being FinSeq-Location such that L592: C88 = ( R32 := (R39 , R31) ) by L591;
L593: C86 in ( { ( succ R13 ) } \ ( JUMP ( R32 := (R39 , R31) ) ) ) by L538 , L540 , L592 , AMISTD_1:12;
L594: C86 = ( succ R13 ) by L593 , TARSKI:def 1;
thus L595: C86 in D63 by L594 , TARSKI:def 2;
end;
suppose L596: (ex R31 being Int-Location st (ex R32 being Int-Location st (ex R39 being FinSeq-Location st C88 = ( (R39 , R31) := R32 ))));

consider R31 being Int-Location, R32 being Int-Location, R39 being FinSeq-Location such that L597: C88 = ( (R39 , R31) := R32 ) by L596;
L598: C86 in ( { ( succ R13 ) } \ ( JUMP ( (R39 , R31) := R32 ) ) ) by L538 , L540 , L597 , AMISTD_1:12;
L599: C86 = ( succ R13 ) by L598 , TARSKI:def 1;
thus L600: C86 in D63 by L599 , TARSKI:def 2;
end;
suppose L601: (ex R31 being Int-Location st (ex R39 being FinSeq-Location st C88 = ( R31 :=len R39 )));

consider R31 being Int-Location, R39 being FinSeq-Location such that L602: C88 = ( R31 :=len R39 ) by L601;
L603: C86 in ( { ( succ R13 ) } \ ( JUMP ( R31 :=len R39 ) ) ) by L538 , L540 , L602 , AMISTD_1:12;
L604: C86 = ( succ R13 ) by L603 , TARSKI:def 1;
thus L605: C86 in D63 by L604 , TARSKI:def 2;
end;
suppose L606: (ex R31 being Int-Location st (ex R39 being FinSeq-Location st C88 = ( R39 :=<0,...,0> R31 )));

consider R31 being Int-Location, R39 being FinSeq-Location such that L607: C88 = ( R39 :=<0,...,0> R31 ) by L606;
L608: C86 in ( { ( succ R13 ) } \ ( JUMP ( R39 :=<0,...,0> R31 ) ) ) by L538 , L540 , L607 , AMISTD_1:12;
L609: C86 = ( succ R13 ) by L608 , TARSKI:def 1;
thus L610: C86 in D63 by L609 , TARSKI:def 2;
end;
end;
assume L612: C86 in { R13 , ( succ R13 ) };
per cases  by L612 , TARSKI:def 2;
suppose L613: C86 = R13;

set D64 = ( halt ( SCM+FSA ) );
L614: ( ( NIC (D64 , R13) ) \ ( JUMP D64 ) ) = { R13 } by AMISTD_1:2;
L615: { R13 } in D62 by L614;
L616: C86 in { R13 } by L613 , TARSKI:def 1;
thus L617: C86 in ( union D62 ) by L616 , L615 , TARSKI:def 4;
end;
suppose L618: C86 = ( succ R13 );

set D65 = the Int-Location;
set D66 = ( AddTo (D65 , D65) );
L619: ( ( NIC (D66 , R13) ) \ ( JUMP D66 ) ) = { ( succ R13 ) } by AMISTD_1:12;
L620: { ( succ R13 ) } in D62 by L619;
L621: C86 in { ( succ R13 ) } by L618 , TARSKI:def 1;
thus L622: C86 in ( union D62 ) by L621 , L620 , TARSKI:def 4;
end;
end;
thus L624: thesis by L535 , TARSKI:1;
end;
theorem
L625: (for B23 being (Element of ( NAT )) holds (( B23 + 1 ) in ( SUCC (B23 , ( SCM+FSA )) ) & (for B24 being (Element of ( NAT )) holds (B24 in ( SUCC (B23 , ( SCM+FSA )) ) implies B23 <= B24))))
proof
let C89 being (Element of ( NAT ));
L626: ( SUCC (C89 , ( SCM+FSA )) ) = { C89 , ( succ C89 ) } by L534;
thus L627: ( C89 + 1 ) in ( SUCC (C89 , ( SCM+FSA )) ) by L626 , TARSKI:def 2;
let C90 being (Element of ( NAT ));
assume L628: C90 in ( SUCC (C89 , ( SCM+FSA )) );
per cases  by L626 , L628 , TARSKI:def 2;
suppose L629: C90 = C89;

thus L630: thesis by L629;
end;
suppose L631: C90 = ( succ C89 );

thus L632: thesis by L631 , NAT_1:11;
end;
end;
registration
cluster ( SCM+FSA ) ->  standard;
coherence by L625 , AMISTD_1:3;
end;
registration
cluster ( InsCode ( halt ( SCM+FSA ) ) ) ->  jump-only for (InsType of (the InstructionsF of ( SCM+FSA )));
coherence
proof
L635:
now
let C91 being (State of ( SCM+FSA ));
let C92 being (Object of ( SCM+FSA ));
let C93 being (Instruction of ( SCM+FSA ));
assume that
L636: ( InsCode C93 ) = ( InsCode ( halt ( SCM+FSA ) ) )
and
L637: C92 in ( Data-Locations ( SCM+FSA ) );
L638: C93 = ( halt ( SCM+FSA ) ) by L636 , SCMFSA_2:95 , COMPOS_1:70;
thus L639: ( ( Exec (C93 , C91) ) . C92 ) = ( C91 . C92 ) by L638 , EXTPRO_1:def 3;
end;
thus L640: thesis by L635 , AMISTD_1:def 1;
end;
end;
registration
cluster ( halt ( SCM+FSA ) ) ->  jump-only;
coherence
proof
thus L642: ( InsCode ( halt ( SCM+FSA ) ) ) is  jump-only;
end;
end;
registration
let R14 being (Element of ( NAT ));
cluster ( InsCode ( goto R14 ) ) ->  jump-only for (InsType of (the InstructionsF of ( SCM+FSA )));
coherence
proof
set D67 = ( SCM+FSA );
L644:
now
let C94 being (State of D67);
let C95 being (Object of D67);
let C96 being (Instruction of D67);
assume that
L645: ( InsCode C96 ) = ( InsCode ( goto R14 ) )
and
L646: C95 in ( Data-Locations D67 );
L647: (ex R15 being (Element of ( NAT )) st C96 = ( goto R15 )) by L645 , SCMFSA_2:23 , SCMFSA_2:35;
per cases  by L646 , L8;
suppose L648: C95 is Int-Location;

thus L649: ( ( Exec (C96 , C94) ) . C95 ) = ( C94 . C95 ) by L648 , L647 , SCMFSA_2:69;
end;
suppose L650: C95 is FinSeq-Location;

thus L651: ( ( Exec (C96 , C94) ) . C95 ) = ( C94 . C95 ) by L650 , L647 , SCMFSA_2:69;
end;
end;
thus L653: thesis by L644 , AMISTD_1:def 1;
end;
end;
registration
let R14 being (Element of ( NAT ));
cluster ( goto R14 ) ->  jump-only non  sequential non  ins-loc-free;
coherence
proof
thus L655: ( InsCode ( goto R14 ) ) is  jump-only;
L656: ( JUMP ( goto R14 ) ) <> ( {} );
thus L657: ( goto R14 ) is non  sequential by L656 , AMISTD_1:13;
L658: ( dom ( JumpPart ( goto R14 ) ) ) = ( dom <* R14 *> ) by RECDEF_2:def 2
.= { 1 } by FINSEQ_1:2 , FINSEQ_1:def 8;
thus L659: (not ( JumpPart ( goto R14 ) ) is  empty) by L658;
end;
end;
registration
let R31 being Int-Location;
let R14 being (Element of ( NAT ));
cluster ( InsCode ( R31 =0_goto R14 ) ) ->  jump-only for (InsType of (the InstructionsF of ( SCM+FSA )));
coherence
proof
set D68 = ( SCM+FSA );
L661:
now
let C97 being (State of D68);
let C98 being (Object of D68);
let C99 being (Instruction of D68);
assume that
L662: ( InsCode C99 ) = ( InsCode ( R31 =0_goto R14 ) )
and
L663: C98 in ( Data-Locations D68 );
L664: (ex R15 being (Element of ( NAT )) st (ex R32 being Int-Location st C99 = ( R32 =0_goto R15 ))) by L662 , SCMFSA_2:24 , SCMFSA_2:36;
per cases  by L663 , L8;
suppose L665: C98 is Int-Location;

thus L666: ( ( Exec (C99 , C97) ) . C98 ) = ( C97 . C98 ) by L665 , L664 , SCMFSA_2:70;
end;
suppose L667: C98 is FinSeq-Location;

thus L668: ( ( Exec (C99 , C97) ) . C98 ) = ( C97 . C98 ) by L667 , L664 , SCMFSA_2:70;
end;
end;
thus L670: thesis by L661 , AMISTD_1:def 1;
end;
cluster ( InsCode ( R31 >0_goto R14 ) ) ->  jump-only for (InsType of (the InstructionsF of ( SCM+FSA )));
coherence
proof
set D69 = ( SCM+FSA );
L671:
now
let C100 being (State of D69);
let C101 being (Object of D69);
let C102 being (Instruction of D69);
assume that
L672: ( InsCode C102 ) = ( InsCode ( R31 >0_goto R14 ) )
and
L673: C101 in ( Data-Locations D69 );
L674: (ex R15 being (Element of ( NAT )) st (ex R32 being Int-Location st C102 = ( R32 >0_goto R15 ))) by L672 , SCMFSA_2:25 , SCMFSA_2:37;
per cases  by L673 , L8;
suppose L675: C101 is Int-Location;

thus L676: ( ( Exec (C102 , C100) ) . C101 ) = ( C100 . C101 ) by L675 , L674 , SCMFSA_2:71;
end;
suppose L677: C101 is FinSeq-Location;

thus L678: ( ( Exec (C102 , C100) ) . C101 ) = ( C100 . C101 ) by L677 , L674 , SCMFSA_2:71;
end;
end;
thus L680: thesis by L671 , AMISTD_1:def 1;
end;
end;
registration
let R31 being Int-Location;
let R14 being (Element of ( NAT ));
cluster ( R31 =0_goto R14 ) ->  jump-only non  sequential non  ins-loc-free;
coherence
proof
thus L682: ( InsCode ( R31 =0_goto R14 ) ) is  jump-only;
L683: ( JUMP ( R31 =0_goto R14 ) ) <> ( {} );
thus L684: ( R31 =0_goto R14 ) is non  sequential by L683 , AMISTD_1:13;
L685: ( dom ( JumpPart ( R31 =0_goto R14 ) ) ) = ( dom <* R14 *> ) by L44
.= { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
thus L686: (not ( JumpPart ( R31 =0_goto R14 ) ) is  empty) by L685;
end;
cluster ( R31 >0_goto R14 ) ->  jump-only non  sequential non  ins-loc-free;
coherence
proof
thus L687: ( InsCode ( R31 >0_goto R14 ) ) is  jump-only;
L688: ( JUMP ( R31 >0_goto R14 ) ) <> ( {} );
thus L689: ( R31 >0_goto R14 ) is non  sequential by L688 , AMISTD_1:13;
L690: ( dom ( JumpPart ( R31 >0_goto R14 ) ) ) = ( dom <* R14 *> ) by L46
.= { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
thus L691: (not ( JumpPart ( R31 >0_goto R14 ) ) is  empty) by L690;
end;
end;
L693: ( intloc ( 0 ) ) <> ( intloc 1 ) by AMI_3:10;
registration
let R31 being Int-Location;
let R32 being Int-Location;
cluster ( InsCode ( R31 := R32 ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM+FSA )));
coherence
proof
set D70 = the (State of ( SCM+FSA ));
set D71 = ( D70 +* ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) );
L694: ( InsCode ( R31 := R32 ) ) = 1 by SCMFSA_2:18
.= ( InsCode ( ( intloc ( 0 ) ) := ( intloc 1 ) ) ) by SCMFSA_2:18;
L695: ( dom ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) ) = { ( intloc ( 0 ) ) , ( intloc 1 ) } by FUNCT_4:62;
L696: ( intloc 1 ) in ( dom ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) ) by L695 , TARSKI:def 2;
L697: ( intloc ( 0 ) ) in ( dom ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) ) by L695 , TARSKI:def 2;
L698: ( D71 . ( intloc ( 0 ) ) ) = ( ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) . ( intloc ( 0 ) ) ) by L697 , FUNCT_4:13
.= ( 0 ) by AMI_3:10 , FUNCT_4:63;
L699: ( intloc ( 0 ) ) in ( Int-Locations ) by AMI_2:def 16;
L700: ( intloc ( 0 ) ) in ( Data-Locations ( SCM+FSA ) ) by L699 , SCMFSA_2:100 , XBOOLE_0:def 3;
L701: ( ( Exec (( ( intloc ( 0 ) ) := ( intloc 1 ) ) , D71) ) . ( intloc ( 0 ) ) ) = ( D71 . ( intloc 1 ) ) by SCMFSA_2:63
.= ( ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) . ( intloc 1 ) ) by L696 , FUNCT_4:13
.= 1 by FUNCT_4:63;
thus L702: thesis by L701 , L694 , L698 , L700 , AMISTD_1:def 1;
end;
cluster ( InsCode ( AddTo (R31 , R32) ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM+FSA )));
coherence
proof
set D72 = the (State of ( SCM+FSA ));
set D73 = ( D72 +* ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) );
L703: ( InsCode ( AddTo (R31 , R32) ) ) = 2 by SCMFSA_2:19
.= ( InsCode ( AddTo (( intloc ( 0 ) ) , ( intloc 1 )) ) ) by SCMFSA_2:19;
L704: ( dom ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) ) = { ( intloc ( 0 ) ) , ( intloc 1 ) } by FUNCT_4:62;
L705: ( intloc ( 0 ) ) in ( dom ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) ) by L704 , TARSKI:def 2;
L706: ( D73 . ( intloc ( 0 ) ) ) = ( ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) . ( intloc ( 0 ) ) ) by L705 , FUNCT_4:13
.= ( 0 ) by AMI_3:10 , FUNCT_4:63;
L707: ( intloc ( 0 ) ) in ( Int-Locations ) by AMI_2:def 16;
L708: ( intloc ( 0 ) ) in ( Data-Locations ( SCM+FSA ) ) by L707 , SCMFSA_2:100 , XBOOLE_0:def 3;
L709: ( intloc 1 ) in ( dom ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) ) by L704 , TARSKI:def 2;
L710: ( D73 . ( intloc 1 ) ) = ( ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) . ( intloc 1 ) ) by L709 , FUNCT_4:13
.= 1 by FUNCT_4:63;
L711: ( ( Exec (( AddTo (( intloc ( 0 ) ) , ( intloc 1 )) ) , D73) ) . ( intloc ( 0 ) ) ) = ( (( 0 ) qua Nat) + 1 ) by L710 , L706 , SCMFSA_2:64;
thus L712: thesis by L711 , L703 , L706 , L708 , AMISTD_1:def 1;
end;
cluster ( InsCode ( SubFrom (R31 , R32) ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM+FSA )));
coherence
proof
set D74 = the (State of ( SCM+FSA ));
set D75 = ( D74 +* ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) );
L713: ( InsCode ( SubFrom (R31 , R32) ) ) = 3 by SCMFSA_2:20
.= ( InsCode ( SubFrom (( intloc ( 0 ) ) , ( intloc 1 )) ) ) by SCMFSA_2:20;
L714: ( dom ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) ) = { ( intloc ( 0 ) ) , ( intloc 1 ) } by FUNCT_4:62;
L715: ( intloc ( 0 ) ) in ( dom ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) ) by L714 , TARSKI:def 2;
L716: ( D75 . ( intloc ( 0 ) ) ) = ( ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) . ( intloc ( 0 ) ) ) by L715 , FUNCT_4:13
.= ( 0 ) by AMI_3:10 , FUNCT_4:63;
L717: ( intloc ( 0 ) ) in ( Int-Locations ) by AMI_2:def 16;
L718: ( intloc ( 0 ) ) in ( Data-Locations ( SCM+FSA ) ) by L717 , SCMFSA_2:100 , XBOOLE_0:def 3;
L719: ( intloc 1 ) in ( dom ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) ) by L714 , TARSKI:def 2;
L720: ( D75 . ( intloc 1 ) ) = ( ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (( 0 ) , 1) ) . ( intloc 1 ) ) by L719 , FUNCT_4:13
.= 1 by FUNCT_4:63;
L721: ( ( Exec (( SubFrom (( intloc ( 0 ) ) , ( intloc 1 )) ) , D75) ) . ( intloc ( 0 ) ) ) = ( ( D75 . ( intloc ( 0 ) ) ) - ( D75 . ( intloc 1 ) ) ) by SCMFSA_2:65
.= ( - 1 ) by L716 , L720;
thus L722: thesis by L721 , L713 , L716 , L718 , AMISTD_1:def 1;
end;
cluster ( InsCode ( MultBy (R31 , R32) ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM+FSA )));
coherence
proof
set D76 = the (State of ( SCM+FSA ));
set D77 = ( D76 +* ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (1 , ( 0 )) ) );
L723: ( InsCode ( MultBy (R31 , R32) ) ) = 4 by SCMFSA_2:21
.= ( InsCode ( MultBy (( intloc ( 0 ) ) , ( intloc 1 )) ) ) by SCMFSA_2:21;
L724: ( dom ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (1 , ( 0 )) ) ) = { ( intloc ( 0 ) ) , ( intloc 1 ) } by FUNCT_4:62;
L725: ( intloc ( 0 ) ) in ( dom ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (1 , ( 0 )) ) ) by L724 , TARSKI:def 2;
L726: ( D77 . ( intloc ( 0 ) ) ) = ( ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (1 , ( 0 )) ) . ( intloc ( 0 ) ) ) by L725 , FUNCT_4:13
.= 1 by AMI_3:10 , FUNCT_4:63;
L727: ( intloc ( 0 ) ) in ( Int-Locations ) by AMI_2:def 16;
L728: ( intloc ( 0 ) ) in ( Data-Locations ( SCM+FSA ) ) by L727 , SCMFSA_2:100 , XBOOLE_0:def 3;
L729: ( intloc 1 ) in ( dom ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (1 , ( 0 )) ) ) by L724 , TARSKI:def 2;
L730: ( D77 . ( intloc 1 ) ) = ( ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (1 , ( 0 )) ) . ( intloc 1 ) ) by L729 , FUNCT_4:13
.= ( 0 ) by FUNCT_4:63;
L731: ( ( Exec (( MultBy (( intloc ( 0 ) ) , ( intloc 1 )) ) , D77) ) . ( intloc ( 0 ) ) ) = ( ( D77 . ( intloc ( 0 ) ) ) * ( D77 . ( intloc 1 ) ) ) by SCMFSA_2:66
.= ( 0 ) by L730;
thus L732: thesis by L731 , L723 , L726 , L728 , AMISTD_1:def 1;
end;
cluster ( InsCode ( Divide (R31 , R32) ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM+FSA )));
coherence
proof
set D78 = the (State of ( SCM+FSA ));
set D79 = ( D78 +* ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (7 , 3) ) );
L733: ( InsCode ( Divide (R31 , R32) ) ) = 5 by SCMFSA_2:22
.= ( InsCode ( Divide (( intloc ( 0 ) ) , ( intloc 1 )) ) ) by SCMFSA_2:22;
L734: ( dom ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (7 , 3) ) ) = { ( intloc ( 0 ) ) , ( intloc 1 ) } by FUNCT_4:62;
L735: ( intloc ( 0 ) ) in ( dom ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (7 , 3) ) ) by L734 , TARSKI:def 2;
L736: ( D79 . ( intloc ( 0 ) ) ) = ( ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (7 , 3) ) . ( intloc ( 0 ) ) ) by L735 , FUNCT_4:13
.= 7 by AMI_3:10 , FUNCT_4:63;
L737: 7 = ( ( 2 * 3 ) + 1 );
L738: ( intloc ( 0 ) ) in ( Int-Locations ) by AMI_2:def 16;
L739: ( intloc ( 0 ) ) in ( Data-Locations ( SCM+FSA ) ) by L738 , SCMFSA_2:100 , XBOOLE_0:def 3;
L740: ( intloc 1 ) in ( dom ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (7 , 3) ) ) by L734 , TARSKI:def 2;
L741: ( D79 . ( intloc 1 ) ) = ( ( (( intloc ( 0 ) ) , ( intloc 1 )) --> (7 , 3) ) . ( intloc 1 ) ) by L740 , FUNCT_4:13
.= 3 by FUNCT_4:63;
L742: ( ( Exec (( Divide (( intloc ( 0 ) ) , ( intloc 1 )) ) , D79) ) . ( intloc ( 0 ) ) ) = ( 7 div (3 qua (Element of ( NAT ))) ) by L741 , L736 , L693 , SCMFSA_2:67
.= 2 by L737 , NAT_D:def 1;
thus L743: thesis by L742 , L733 , L736 , L739 , AMISTD_1:def 1;
end;
end;
L745: ( fsloc ( 0 ) ) <> ( intloc ( 0 ) ) by SCMFSA_2:99;
L746: ( fsloc ( 0 ) ) <> ( intloc 1 ) by SCMFSA_2:99;
registration
let R31 being Int-Location;
let R32 being Int-Location;
let R39 being FinSeq-Location;
cluster ( InsCode ( R32 := (R39 , R31) ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM+FSA )));
coherence
proof
L747: ( Values ( intloc 1 ) ) = ( INT ) by SCMFSA_2:11;
reconsider D80 = 1 as (Element of ( Values ( intloc 1 ) )) by L747 , INT_1:def 1;
L748: ( Values ( intloc ( 0 ) ) ) = ( INT ) by SCMFSA_2:11;
reconsider D81 = 1 as (Element of ( Values ( intloc ( 0 ) ) )) by L748 , INT_1:def 1;
reconsider D82 = 2 as (Element of ( INT )) by INT_1:def 1;
set D83 = the (State of ( SCM+FSA ));
L749: <* D82 *> in ( ( INT ) * ) by FINSEQ_1:def 11;
reconsider D84 = <* 2 *> as (Element of ( Values ( fsloc ( 0 ) ) )) by L749 , SCMFSA_2:12;
reconsider D85 = ( ( ( D83 +* ( ( fsloc ( 0 ) ) .--> D84 ) ) +* ( ( intloc ( 0 ) ) .--> D81 ) ) +* ( ( intloc 1 ) .--> D80 ) ) as (State of ( SCM+FSA ));
L750: ( D85 . ( intloc ( 0 ) ) ) = D81 by AMI_3:10 , BVFUNC14:12;
L751: ( D85 . ( fsloc ( 0 ) ) ) = D84 by L745 , L746 , FUNCT_7:114;
L752: ( dom ( D85 . ( fsloc ( 0 ) ) ) ) = { 1 } by L751 , FINSEQ_1:2 , FINSEQ_1:def 8;
L753: 1 in ( dom ( D85 . ( fsloc ( 0 ) ) ) ) by L752 , TARSKI:def 1;
consider C103 being (Element of ( NAT )) such that L754: C103 = ( abs ( D85 . ( intloc 1 ) ) ) and L755: ( ( Exec (( ( intloc ( 0 ) ) := (( fsloc ( 0 ) ) , ( intloc 1 )) ) , D85) ) . ( intloc ( 0 ) ) ) = ( ( D85 . ( fsloc ( 0 ) ) ) /. C103 ) by SCMFSA_2:72;
L756: ( intloc ( 0 ) ) in ( Int-Locations ) by AMI_2:def 16;
L757: ( intloc ( 0 ) ) in ( Data-Locations ( SCM+FSA ) ) by L756 , SCMFSA_2:100 , XBOOLE_0:def 3;
L758: ( D85 . ( intloc 1 ) ) = D80 by FUNCT_7:94;
L759: C103 = 1 by L758 , L754 , ABSVALUE:def 1;
L760: ( ( Exec (( ( intloc ( 0 ) ) := (( fsloc ( 0 ) ) , ( intloc 1 )) ) , D85) ) . ( intloc ( 0 ) ) ) = ( ( D85 . ( fsloc ( 0 ) ) ) . 1 ) by L759 , L755 , L753 , PARTFUN1:def 6
.= 2 by L751 , FINSEQ_1:def 8;
L761: ( InsCode ( R32 := (R39 , R31) ) ) = 9 by SCMFSA_2:26
.= ( InsCode ( ( intloc ( 0 ) ) := (( fsloc ( 0 ) ) , ( intloc 1 )) ) ) by SCMFSA_2:26;
thus L762: thesis by L761 , L750 , L760 , L757 , AMISTD_1:def 1;
end;
cluster ( InsCode ( (R39 , R31) := R32 ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM+FSA )));
coherence
proof
L763: ( Values ( intloc ( 0 ) ) ) = ( INT ) by SCMFSA_2:11;
reconsider D86 = 1 as (Element of ( Values ( intloc ( 0 ) ) )) by L763 , INT_1:def 1;
reconsider D87 = 2 as (Element of ( INT )) by INT_1:def 1;
set D88 = the (State of ( SCM+FSA ));
L764: ( InsCode ( (R39 , R31) := R32 ) ) = 10 by SCMFSA_2:27
.= ( InsCode ( (( fsloc ( 0 ) ) , ( intloc 1 )) := ( intloc ( 0 ) ) ) ) by SCMFSA_2:27;
L765: ( Values ( intloc 1 ) ) = ( INT ) by SCMFSA_2:11;
reconsider D89 = 1 as (Element of ( Values ( intloc 1 ) )) by L765 , INT_1:def 1;
L766: <* D87 *> in ( ( INT ) * ) by FINSEQ_1:def 11;
reconsider D90 = <* 2 *> as (Element of ( Values ( fsloc ( 0 ) ) )) by L766 , SCMFSA_2:12;
reconsider D91 = ( ( ( D88 +* ( ( fsloc ( 0 ) ) .--> D90 ) ) +* ( ( intloc ( 0 ) ) .--> D86 ) ) +* ( ( intloc 1 ) .--> D89 ) ) as (State of ( SCM+FSA ));
consider C104 being (Element of ( NAT )) such that L767: C104 = ( abs ( D91 . ( intloc 1 ) ) ) and L768: ( ( Exec (( (( fsloc ( 0 ) ) , ( intloc 1 )) := ( intloc ( 0 ) ) ) , D91) ) . ( fsloc ( 0 ) ) ) = ( ( D91 . ( fsloc ( 0 ) ) ) +* (C104 , ( D91 . ( intloc ( 0 ) ) )) ) by SCMFSA_2:73;
L769: ( D91 . ( intloc 1 ) ) = D89 by FUNCT_7:94;
L770: C104 = 1 by L769 , L767 , ABSVALUE:def 1;
L771: ( fsloc ( 0 ) ) in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L772: ( fsloc ( 0 ) ) in ( Data-Locations ( SCM+FSA ) ) by L771 , SCMFSA_2:100 , XBOOLE_0:def 3;
L773: D90 <> <* D86 *> by FINSEQ_1:76;
L774: ( D91 . ( fsloc ( 0 ) ) ) = D90 by L745 , L746 , FUNCT_7:114;
L775: ( D91 . ( intloc ( 0 ) ) ) = D86 by AMI_3:10 , BVFUNC14:12;
L776: ( ( Exec (( (( fsloc ( 0 ) ) , ( intloc 1 )) := ( intloc ( 0 ) ) ) , D91) ) . ( fsloc ( 0 ) ) ) = <* D86 *> by L775 , L774 , L768 , L770 , FUNCT_7:95;
thus L777: thesis by L776 , L764 , L774 , L773 , L772 , AMISTD_1:def 1;
end;
end;
registration
let R31 being Int-Location;
let R32 being Int-Location;
let R39 being FinSeq-Location;
cluster ( R32 := (R39 , R31) ) -> non  jump-only;
coherence
proof
thus L779: (not ( InsCode ( R32 := (R39 , R31) ) ) is  jump-only);
end;
cluster ( (R39 , R31) := R32 ) -> non  jump-only;
coherence
proof
thus L780: (not ( InsCode ( (R39 , R31) := R32 ) ) is  jump-only);
end;
end;
registration
let R31 being Int-Location;
let R39 being FinSeq-Location;
cluster ( InsCode ( R31 :=len R39 ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM+FSA )));
coherence
proof
L782: ( Values ( intloc ( 0 ) ) ) = ( INT ) by SCMFSA_2:11;
reconsider D92 = 3 as (Element of ( Values ( intloc ( 0 ) ) )) by L782 , INT_1:def 1;
reconsider D93 = 2 as (Element of ( INT )) by INT_1:def 1;
set D94 = the (State of ( SCM+FSA ));
L783: ( InsCode ( R31 :=len R39 ) ) = 11 by SCMFSA_2:28
.= ( InsCode ( ( intloc ( 0 ) ) :=len ( fsloc ( 0 ) ) ) ) by SCMFSA_2:28;
L784: <* D93 *> in ( ( INT ) * ) by FINSEQ_1:def 11;
reconsider D95 = <* 2 *> as (Element of ( Values ( fsloc ( 0 ) ) )) by L784 , SCMFSA_2:12;
reconsider D96 = ( ( D94 +* ( ( fsloc ( 0 ) ) .--> D95 ) ) +* ( ( intloc ( 0 ) ) .--> D92 ) ) as (State of ( SCM+FSA ));
L785: ( D96 . ( fsloc ( 0 ) ) ) = D95 by BVFUNC14:12 , SCMFSA_2:99;
L786: ( intloc ( 0 ) ) in ( Int-Locations ) by AMI_2:def 16;
L787: ( intloc ( 0 ) ) in ( Data-Locations ( SCM+FSA ) ) by L786 , SCMFSA_2:100 , XBOOLE_0:def 3;
L788: ( D96 . ( intloc ( 0 ) ) ) = D92 by FUNCT_7:94;
L789: ( ( Exec (( ( intloc ( 0 ) ) :=len ( fsloc ( 0 ) ) ) , D96) ) . ( intloc ( 0 ) ) ) = ( len ( D96 . ( fsloc ( 0 ) ) ) ) by SCMFSA_2:74
.= 1 by L785 , FINSEQ_1:39;
thus L790: thesis by L789 , L783 , L788 , L787 , AMISTD_1:def 1;
end;
cluster ( InsCode ( R39 :=<0,...,0> R31 ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM+FSA )));
coherence
proof
L791: ( Values ( intloc ( 0 ) ) ) = ( INT ) by SCMFSA_2:11;
reconsider D97 = 1 as (Element of ( Values ( intloc ( 0 ) ) )) by L791 , INT_1:def 1;
reconsider D98 = 2 as (Element of ( INT )) by INT_1:def 1;
set D99 = the (State of ( SCM+FSA ));
L792: <* D98 *> in ( ( INT ) * ) by FINSEQ_1:def 11;
reconsider D100 = <* 2 *> as (Element of ( Values ( fsloc ( 0 ) ) )) by L792 , SCMFSA_2:12;
reconsider D101 = ( ( D99 +* ( ( fsloc ( 0 ) ) .--> D100 ) ) +* ( ( intloc ( 0 ) ) .--> D97 ) ) as (State of ( SCM+FSA ));
L793: ( D101 . ( fsloc ( 0 ) ) ) = D100 by BVFUNC14:12 , SCMFSA_2:99;
L794: D100 <> <* ( 0 ) *> by FINSEQ_1:76;
consider C105 being (Element of ( NAT )) such that L795: C105 = ( abs ( D101 . ( intloc ( 0 ) ) ) ) and L796: ( ( Exec (( ( fsloc ( 0 ) ) :=<0,...,0> ( intloc ( 0 ) ) ) , D101) ) . ( fsloc ( 0 ) ) ) = ( C105 |-> ( 0 ) ) by SCMFSA_2:75;
L797: ( fsloc ( 0 ) ) in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L798: ( fsloc ( 0 ) ) in ( Data-Locations ( SCM+FSA ) ) by L797 , SCMFSA_2:100 , XBOOLE_0:def 3;
L799: ( D101 . ( intloc ( 0 ) ) ) = D97 by FUNCT_7:94;
L800: C105 = 1 by L799 , L795 , ABSVALUE:def 1;
L801: ( ( Exec (( ( fsloc ( 0 ) ) :=<0,...,0> ( intloc ( 0 ) ) ) , D101) ) . ( fsloc ( 0 ) ) ) = <* ( 0 ) *> by L800 , L796 , FINSEQ_2:59;
L802: ( InsCode ( R39 :=<0,...,0> R31 ) ) = 12 by SCMFSA_2:29
.= ( InsCode ( ( fsloc ( 0 ) ) :=<0,...,0> ( intloc ( 0 ) ) ) ) by SCMFSA_2:29;
thus L803: thesis by L802 , L793 , L794 , L801 , L798 , AMISTD_1:def 1;
end;
end;
registration
let R31 being Int-Location;
let R39 being FinSeq-Location;
cluster ( R31 :=len R39 ) -> non  jump-only;
coherence
proof
thus L805: (not ( InsCode ( R31 :=len R39 ) ) is  jump-only);
end;
cluster ( R39 :=<0,...,0> R31 ) -> non  jump-only;
coherence
proof
thus L806: (not ( InsCode ( R39 :=<0,...,0> R31 ) ) is  jump-only);
end;
end;
registration
cluster ( SCM+FSA ) ->  with_explicit_jumps;
coherence
proof
let C106 being (Instruction of ( SCM+FSA ));
thus L808: ( JUMP C106 ) c= ( rng ( JumpPart C106 ) )
proof
let C107 being set;
assume that
L809: C107 in ( JUMP C106 );
per cases  by SCMFSA_2:93;
suppose L810: C106 = [ ( 0 ) , ( {} ) , ( {} ) ];

thus L811: thesis by L810 , L809 , SCMFSA_2:96;
end;
suppose L812: (ex R31 being Int-Location st (ex R32 being Int-Location st C106 = ( R31 := R32 )));

thus L813: thesis by L812 , L809;
end;
suppose L814: (ex R31 being Int-Location st (ex R32 being Int-Location st C106 = ( AddTo (R31 , R32) )));

thus L815: thesis by L814 , L809;
end;
suppose L816: (ex R31 being Int-Location st (ex R32 being Int-Location st C106 = ( SubFrom (R31 , R32) )));

thus L817: thesis by L816 , L809;
end;
suppose L818: (ex R31 being Int-Location st (ex R32 being Int-Location st C106 = ( MultBy (R31 , R32) )));

thus L819: thesis by L818 , L809;
end;
suppose L820: (ex R31 being Int-Location st (ex R32 being Int-Location st C106 = ( Divide (R31 , R32) )));

thus L821: thesis by L820 , L809;
end;
suppose L822: (ex R14 being (Element of ( NAT )) st C106 = ( goto R14 ));

consider R14 being (Element of ( NAT )) such that L823: C106 = ( goto R14 ) by L822;
L824: ( JumpPart ( goto R14 ) ) = <* R14 *> by RECDEF_2:def 2;
L825: ( rng <* R14 *> ) = { R14 } by FINSEQ_1:39;
thus L826: thesis by L825 , L809 , L823 , L824 , L360;
end;
suppose L827: (ex R14 being (Element of ( NAT )) st (ex R31 being Int-Location st C106 = ( R31 =0_goto R14 )));

consider R31 being Int-Location, R14 being (Element of ( NAT )) such that L828: C106 = ( R31 =0_goto R14 ) by L827;
L829: ( JumpPart ( R31 =0_goto R14 ) ) = <* R14 *> by L44;
L830: ( rng <* R14 *> ) = { R14 } by FINSEQ_1:39;
thus L831: thesis by L830 , L809 , L828 , L829 , L421;
end;
suppose L832: (ex R14 being (Element of ( NAT )) st (ex R31 being Int-Location st C106 = ( R31 >0_goto R14 )));

consider R31 being Int-Location, R14 being (Element of ( NAT )) such that L833: C106 = ( R31 >0_goto R14 ) by L832;
L834: ( JumpPart ( R31 >0_goto R14 ) ) = <* R14 *> by L46;
L835: ( rng <* R14 *> ) = { R14 } by FINSEQ_1:39;
thus L836: thesis by L835 , L809 , L833 , L834 , L488;
end;
suppose L837: (ex R31 being Int-Location st (ex R32 being Int-Location st (ex R39 being FinSeq-Location st C106 = ( R32 := (R39 , R31) ))));

thus L838: thesis by L837 , L809;
end;
suppose L839: (ex R31 being Int-Location st (ex R32 being Int-Location st (ex R39 being FinSeq-Location st C106 = ( (R39 , R31) := R32 ))));

thus L840: thesis by L839 , L809;
end;
suppose L841: (ex R31 being Int-Location st (ex R39 being FinSeq-Location st C106 = ( R31 :=len R39 )));

thus L842: thesis by L841 , L809;
end;
suppose L843: (ex R31 being Int-Location st (ex R39 being FinSeq-Location st C106 = ( R39 :=<0,...,0> R31 )));

thus L844: thesis by L843 , L809;
end;
end;

let C108 being set;
assume L846: C108 in ( rng ( JumpPart C106 ) );
consider C109 being set such that L847: C109 in ( dom ( JumpPart C106 ) ) and L848: C108 = ( ( JumpPart C106 ) . C109 ) by L846 , FUNCT_1:def 3;
per cases  by SCMFSA_2:93;
suppose L849: C106 = [ ( 0 ) , ( {} ) , ( {} ) ];

L850: ( dom ( JumpPart C106 ) ) = ( dom ( {} ) ) by L849 , RECDEF_2:def 2;
thus L851: thesis by L850 , L847;
end;
suppose L852: (ex R31 being Int-Location st (ex R32 being Int-Location st C106 = ( R31 := R32 )));

consider R31 being Int-Location, R32 being Int-Location such that L853: C106 = ( R31 := R32 ) by L852;
L854: C109 in ( dom ( {} ) ) by L847 , L853 , L34;
thus L855: thesis by L854;
end;
suppose L856: (ex R31 being Int-Location st (ex R32 being Int-Location st C106 = ( AddTo (R31 , R32) )));

consider R31 being Int-Location, R32 being Int-Location such that L857: C106 = ( AddTo (R31 , R32) ) by L856;
L858: C109 in ( dom ( {} ) ) by L847 , L857 , L36;
thus L859: thesis by L858;
end;
suppose L860: (ex R31 being Int-Location st (ex R32 being Int-Location st C106 = ( SubFrom (R31 , R32) )));

consider R31 being Int-Location, R32 being Int-Location such that L861: C106 = ( SubFrom (R31 , R32) ) by L860;
L862: C109 in ( dom ( {} ) ) by L847 , L861 , L38;
thus L863: thesis by L862;
end;
suppose L864: (ex R31 being Int-Location st (ex R32 being Int-Location st C106 = ( MultBy (R31 , R32) )));

consider R31 being Int-Location, R32 being Int-Location such that L865: C106 = ( MultBy (R31 , R32) ) by L864;
L866: C109 in ( dom ( {} ) ) by L847 , L865 , L40;
thus L867: thesis by L866;
end;
suppose L868: (ex R31 being Int-Location st (ex R32 being Int-Location st C106 = ( Divide (R31 , R32) )));

consider R31 being Int-Location, R32 being Int-Location such that L869: C106 = ( Divide (R31 , R32) ) by L868;
L870: C109 in ( dom ( {} ) ) by L847 , L869 , L42;
thus L871: thesis by L870;
end;
suppose L872: (ex R14 being (Element of ( NAT )) st C106 = ( goto R14 ));

consider R14 being (Element of ( NAT )) such that L873: C106 = ( goto R14 ) by L872;
L874: ( JumpPart C106 ) = <* R14 *> by L873 , RECDEF_2:def 2;
L875: C109 = 1 by L874 , L847 , FINSEQ_1:90;
L876: C108 = R14 by L875 , L874 , L848 , FINSEQ_1:def 8;
L877: ( JUMP C106 ) = { R14 } by L873 , L360;
thus L878: thesis by L877 , L876 , TARSKI:def 1;
end;
suppose L879: (ex R14 being (Element of ( NAT )) st (ex R31 being Int-Location st C106 = ( R31 =0_goto R14 )));

consider R31 being Int-Location, R14 being (Element of ( NAT )) such that L880: C106 = ( R31 =0_goto R14 ) by L879;
L881: ( JumpPart C106 ) = <* R14 *> by L880 , L44;
L882: C109 = 1 by L881 , L847 , FINSEQ_1:90;
L883: C108 = R14 by L882 , L881 , L848 , FINSEQ_1:def 8;
L884: ( JUMP C106 ) = { R14 } by L880 , L421;
thus L885: thesis by L884 , L883 , TARSKI:def 1;
end;
suppose L886: (ex R14 being (Element of ( NAT )) st (ex R31 being Int-Location st C106 = ( R31 >0_goto R14 )));

consider R31 being Int-Location, R14 being (Element of ( NAT )) such that L887: C106 = ( R31 >0_goto R14 ) by L886;
L888: ( JumpPart C106 ) = <* R14 *> by L887 , L46;
L889: C109 = 1 by L888 , L847 , FINSEQ_1:90;
L890: C108 = R14 by L889 , L888 , L848 , FINSEQ_1:def 8;
L891: ( JUMP C106 ) = { R14 } by L887 , L488;
thus L892: thesis by L891 , L890 , TARSKI:def 1;
end;
suppose L893: (ex R31 being Int-Location st (ex R32 being Int-Location st (ex R39 being FinSeq-Location st C106 = ( R32 := (R39 , R31) ))));

consider R31 being Int-Location, R32 being Int-Location, R39 being FinSeq-Location such that L894: C106 = ( R32 := (R39 , R31) ) by L893;
L895: C109 in ( dom ( {} ) ) by L847 , L894 , RECDEF_2:def 2;
thus L896: thesis by L895;
end;
suppose L897: (ex R31 being Int-Location st (ex R32 being Int-Location st (ex R39 being FinSeq-Location st C106 = ( (R39 , R31) := R32 ))));

consider R31 being Int-Location, R32 being Int-Location, R39 being FinSeq-Location such that L898: C106 = ( (R39 , R31) := R32 ) by L897;
L899: C109 in ( dom ( {} ) ) by L847 , L898 , RECDEF_2:def 2;
thus L900: thesis by L899;
end;
suppose L901: (ex R31 being Int-Location st (ex R39 being FinSeq-Location st C106 = ( R31 :=len R39 )));

consider R31 being Int-Location, R39 being FinSeq-Location such that L902: C106 = ( R31 :=len R39 ) by L901;
L903: C109 in ( dom ( {} ) ) by L847 , L902 , RECDEF_2:def 2;
thus L904: thesis by L903;
end;
suppose L905: (ex R31 being Int-Location st (ex R39 being FinSeq-Location st C106 = ( R39 :=<0,...,0> R31 )));

consider R31 being Int-Location, R39 being FinSeq-Location such that L906: C106 = ( R39 :=<0,...,0> R31 ) by L905;
L907: C109 in ( dom ( {} ) ) by L847 , L906 , RECDEF_2:def 2;
thus L908: thesis by L907;
end;
end;
end;
theorem
L911: (for R14 being (Element of ( NAT )) holds (for R22 being Nat holds ( IncAddr (( goto R14 ) , R22) ) = ( goto ( R14 + R22 ) )))
proof
let R14 being (Element of ( NAT ));
let R22 being Nat;
L912: ( InsCode ( IncAddr (( goto R14 ) , R22) ) ) = ( InsCode ( goto R14 ) ) by COMPOS_0:def 9
.= 6 by SCMFSA_2:23
.= ( InsCode ( goto ( R14 + R22 ) ) ) by SCMFSA_2:23;
L913: ( AddressPart ( IncAddr (( goto R14 ) , R22) ) ) = ( AddressPart ( goto R14 ) ) by COMPOS_0:def 9
.= ( {} ) by RECDEF_2:def 3
.= ( AddressPart ( goto ( R14 + R22 ) ) ) by RECDEF_2:def 3;
L914: ( JumpPart ( IncAddr (( goto R14 ) , R22) ) ) = ( R22 + ( JumpPart ( goto R14 ) ) ) by COMPOS_0:def 9;
L915: ( dom ( JumpPart ( IncAddr (( goto R14 ) , R22) ) ) ) = ( dom ( JumpPart ( goto R14 ) ) ) by L914 , VALUED_1:def 2;
L916: (for B25 being set holds (B25 in ( dom ( JumpPart ( goto R14 ) ) ) implies ( ( JumpPart ( IncAddr (( goto R14 ) , R22) ) ) . B25 ) = ( ( JumpPart ( goto ( R14 + R22 ) ) ) . B25 )))
proof
let C110 being set;
assume L917: C110 in ( dom ( JumpPart ( goto R14 ) ) );
L918: C110 in ( dom <* R14 *> ) by L917 , RECDEF_2:def 2;
L919: C110 = 1 by L918 , FINSEQ_1:90;
set D102 = ( ( JumpPart ( goto R14 ) ) . C110 );
L920: ( ( JumpPart ( IncAddr (( goto R14 ) , R22) ) ) . C110 ) = ( R22 + D102 ) by L915 , L914 , L917 , VALUED_1:def 2;
L921: D102 = ( <* R14 *> . C110 ) by RECDEF_2:def 2
.= R14 by L919 , FINSEQ_1:def 8;
thus L922: ( ( JumpPart ( IncAddr (( goto R14 ) , R22) ) ) . C110 ) = ( <* ( R14 + R22 ) *> . C110 ) by L921 , L919 , L920 , FINSEQ_1:def 8
.= ( ( JumpPart ( goto ( R14 + R22 ) ) ) . C110 ) by RECDEF_2:def 2;
end;
L923: ( dom ( JumpPart ( goto ( R14 + R22 ) ) ) ) = ( dom <* ( R14 + R22 ) *> ) by RECDEF_2:def 2
.= ( Seg 1 ) by FINSEQ_1:def 8
.= ( dom <* R14 *> ) by FINSEQ_1:def 8
.= ( dom ( JumpPart ( goto R14 ) ) ) by RECDEF_2:def 2;
L924: ( JumpPart ( IncAddr (( goto R14 ) , R22) ) ) = ( JumpPart ( goto ( R14 + R22 ) ) ) by L923 , L915 , L916 , FUNCT_1:2;
thus L925: thesis by L924 , L912 , L913 , COMPOS_0:1;
end;
theorem
L926: (for R14 being (Element of ( NAT )) holds (for R22 being Nat holds (for R31 being Int-Location holds ( IncAddr (( R31 =0_goto R14 ) , R22) ) = ( R31 =0_goto ( R14 + R22 ) ))))
proof
let R14 being (Element of ( NAT ));
let R22 being Nat;
let R31 being Int-Location;
L927: ( InsCode ( IncAddr (( R31 =0_goto R14 ) , R22) ) ) = ( InsCode ( R31 =0_goto R14 ) ) by COMPOS_0:def 9
.= 7 by SCMFSA_2:24
.= ( InsCode ( R31 =0_goto ( R14 + R22 ) ) ) by SCMFSA_2:24;
L928: ( R31 =0_goto R14 ) = [ 7 , <* R14 *> , <* R31 *> ] by L27;
L929: ( R31 =0_goto ( R14 + R22 ) ) = [ 7 , <* ( R14 + R22 ) *> , <* R31 *> ] by L27;
L930: ( AddressPart ( IncAddr (( R31 =0_goto R14 ) , R22) ) ) = ( AddressPart ( R31 =0_goto R14 ) ) by COMPOS_0:def 9
.= <* R31 *> by L928 , RECDEF_2:def 3
.= ( AddressPart ( R31 =0_goto ( R14 + R22 ) ) ) by L929 , RECDEF_2:def 3;
L931: ( JumpPart ( IncAddr (( R31 =0_goto R14 ) , R22) ) ) = ( R22 + ( JumpPart ( R31 =0_goto R14 ) ) ) by COMPOS_0:def 9;
L932: ( dom ( JumpPart ( IncAddr (( R31 =0_goto R14 ) , R22) ) ) ) = ( dom ( JumpPart ( R31 =0_goto R14 ) ) ) by L931 , VALUED_1:def 2;
L933: (for B26 being set holds (B26 in ( dom ( JumpPart ( R31 =0_goto R14 ) ) ) implies ( ( JumpPart ( IncAddr (( R31 =0_goto R14 ) , R22) ) ) . B26 ) = ( ( JumpPart ( R31 =0_goto ( R14 + R22 ) ) ) . B26 )))
proof
let C111 being set;
assume L934: C111 in ( dom ( JumpPart ( R31 =0_goto R14 ) ) );
L935: C111 in ( dom <* R14 *> ) by L934 , L44;
L936: C111 = 1 by L935 , FINSEQ_1:90;
set D103 = ( ( JumpPart ( R31 =0_goto R14 ) ) . C111 );
L937: ( ( JumpPart ( IncAddr (( R31 =0_goto R14 ) , R22) ) ) . C111 ) = ( R22 + D103 ) by L932 , L931 , L934 , VALUED_1:def 2;
L938: D103 = ( <* R14 *> . C111 ) by L44
.= R14 by L936 , FINSEQ_1:40;
thus L939: ( ( JumpPart ( IncAddr (( R31 =0_goto R14 ) , R22) ) ) . C111 ) = ( <* ( R14 + R22 ) *> . C111 ) by L938 , L936 , L937 , FINSEQ_1:40
.= ( ( JumpPart ( R31 =0_goto ( R14 + R22 ) ) ) . C111 ) by L44;
end;
L940: ( dom ( JumpPart ( R31 =0_goto ( R14 + R22 ) ) ) ) = ( dom <* ( R14 + R22 ) *> ) by L44
.= ( Seg 1 ) by FINSEQ_1:38
.= ( dom <* R14 *> ) by FINSEQ_1:38
.= ( dom ( JumpPart ( R31 =0_goto R14 ) ) ) by L44;
L941: ( JumpPart ( IncAddr (( R31 =0_goto R14 ) , R22) ) ) = ( JumpPart ( R31 =0_goto ( R14 + R22 ) ) ) by L940 , L932 , L933 , FUNCT_1:2;
thus L942: thesis by L941 , L927 , L930 , COMPOS_0:1;
end;
theorem
L943: (for R14 being (Element of ( NAT )) holds (for R22 being Nat holds (for R31 being Int-Location holds ( IncAddr (( R31 >0_goto R14 ) , R22) ) = ( R31 >0_goto ( R14 + R22 ) ))))
proof
let R14 being (Element of ( NAT ));
let R22 being Nat;
let R31 being Int-Location;
L944: ( InsCode ( IncAddr (( R31 >0_goto R14 ) , R22) ) ) = ( InsCode ( R31 >0_goto R14 ) ) by COMPOS_0:def 9
.= 8 by SCMFSA_2:25
.= ( InsCode ( R31 >0_goto ( R14 + R22 ) ) ) by SCMFSA_2:25;
L945: ( R31 >0_goto R14 ) = [ 8 , <* R14 *> , <* R31 *> ] by L30;
L946: ( R31 >0_goto ( R14 + R22 ) ) = [ 8 , <* ( R14 + R22 ) *> , <* R31 *> ] by L30;
L947: ( AddressPart ( IncAddr (( R31 >0_goto R14 ) , R22) ) ) = ( AddressPart ( R31 >0_goto R14 ) ) by COMPOS_0:def 9
.= <* R31 *> by L945 , RECDEF_2:def 3
.= ( AddressPart ( R31 >0_goto ( R14 + R22 ) ) ) by L946 , RECDEF_2:def 3;
L948: ( JumpPart ( IncAddr (( R31 >0_goto R14 ) , R22) ) ) = ( R22 + ( JumpPart ( R31 >0_goto R14 ) ) ) by COMPOS_0:def 9;
L949: ( dom ( JumpPart ( IncAddr (( R31 >0_goto R14 ) , R22) ) ) ) = ( dom ( JumpPart ( R31 >0_goto R14 ) ) ) by L948 , VALUED_1:def 2;
L950: (for B27 being set holds (B27 in ( dom ( JumpPart ( R31 >0_goto R14 ) ) ) implies ( ( JumpPart ( IncAddr (( R31 >0_goto R14 ) , R22) ) ) . B27 ) = ( ( JumpPart ( R31 >0_goto ( R14 + R22 ) ) ) . B27 )))
proof
let C112 being set;
assume L951: C112 in ( dom ( JumpPart ( R31 >0_goto R14 ) ) );
L952: C112 in ( dom <* R14 *> ) by L951 , L46;
L953: C112 = 1 by L952 , FINSEQ_1:90;
set D104 = ( ( JumpPart ( R31 >0_goto R14 ) ) . 1 );
L954: ( ( JumpPart ( IncAddr (( R31 >0_goto R14 ) , R22) ) ) . 1 ) = ( R22 + D104 ) by L953 , L949 , L948 , L951 , VALUED_1:def 2;
L955: D104 = ( <* R14 *> . C112 ) by L46 , L953
.= R14 by L953 , FINSEQ_1:40;
thus L956: ( ( JumpPart ( IncAddr (( R31 >0_goto R14 ) , R22) ) ) . C112 ) = ( <* ( R14 + R22 ) *> . C112 ) by L955 , L953 , L954 , FINSEQ_1:40
.= ( ( JumpPart ( R31 >0_goto ( R14 + R22 ) ) ) . C112 ) by L46;
end;
L957: ( dom ( JumpPart ( R31 >0_goto ( R14 + R22 ) ) ) ) = ( dom <* ( R14 + R22 ) *> ) by L46
.= ( Seg 1 ) by FINSEQ_1:38
.= ( dom <* R14 *> ) by FINSEQ_1:38
.= ( dom ( JumpPart ( R31 >0_goto R14 ) ) ) by L46;
L958: ( JumpPart ( IncAddr (( R31 >0_goto R14 ) , R22) ) ) = ( JumpPart ( R31 >0_goto ( R14 + R22 ) ) ) by L957 , L949 , L950 , FUNCT_1:2;
thus L959: thesis by L958 , L944 , L947 , COMPOS_0:1;
end;
registration
cluster ( SCM+FSA ) ->  IC-relocable;
coherence
proof
let C113 being (Instruction of ( SCM+FSA ));
per cases  by SCMFSA_2:93;
suppose L960: C113 = [ ( 0 ) , ( {} ) , ( {} ) ];

thus L961: thesis by L960 , SCMFSA_2:96;
end;
suppose L962: (ex R31 being Int-Location st (ex R32 being Int-Location st C113 = ( R31 := R32 )));

thus L963: thesis by L962;
end;
suppose L964: (ex R31 being Int-Location st (ex R32 being Int-Location st C113 = ( AddTo (R31 , R32) )));

thus L965: thesis by L964;
end;
suppose L966: (ex R31 being Int-Location st (ex R32 being Int-Location st C113 = ( SubFrom (R31 , R32) )));

thus L967: thesis by L966;
end;
suppose L968: (ex R31 being Int-Location st (ex R32 being Int-Location st C113 = ( MultBy (R31 , R32) )));

thus L969: thesis by L968;
end;
suppose L970: (ex R31 being Int-Location st (ex R32 being Int-Location st C113 = ( Divide (R31 , R32) )));

thus L971: thesis by L970;
end;
suppose L972: (ex R14 being (Element of ( NAT )) st C113 = ( goto R14 ));

let C114 , C115 being Nat;
let C116 being (State of ( SCM+FSA ));
set D105 = ( IncIC (C116 , C115) );
consider R14 being (Element of ( NAT )) such that L973: C113 = ( goto R14 ) by L972;
thus L974: ( ( IC ( Exec (( IncAddr (C113 , C114) ) , C116) ) ) + C115 ) = ( ( IC ( Exec (( goto ( C114 + R14 ) ) , C116) ) ) + C115 ) by L973 , L911
.= ( ( C114 + R14 ) + C115 ) by SCMFSA_2:69
.= ( IC ( Exec (( goto ( ( C114 + C115 ) + R14 ) ) , D105) ) ) by SCMFSA_2:69
.= ( IC ( Exec (( IncAddr (C113 , ( C114 + C115 )) ) , D105) ) ) by L973 , L911;
end;
suppose L975: (ex R14 being (Element of ( NAT )) st (ex R31 being Int-Location st C113 = ( R31 =0_goto R14 )));

consider R31 being Int-Location, R14 being (Element of ( NAT )) such that L976: C113 = ( R31 =0_goto R14 ) by L975;
let C117 , C118 being Nat;
let C119 being (State of ( SCM+FSA ));
set D106 = ( IncIC (C119 , C118) );
L977: (R31 <> ( IC ( SCM+FSA ) ) & ( dom ( ( IC ( SCM+FSA ) ) .--> ( ( IC C119 ) + C118 ) ) ) = { ( IC ( SCM+FSA ) ) }) by FUNCOP_1:13 , SCMFSA_2:56;
L978: (not R31 in ( dom ( ( IC ( SCM+FSA ) ) .--> ( ( IC C119 ) + C118 ) ) )) by L977 , TARSKI:def 1;
L979: ( C119 . R31 ) = ( D106 . R31 ) by L978 , FUNCT_4:11;
per cases ;
suppose L980: ( C119 . R31 ) = ( 0 );

thus L981: ( ( IC ( Exec (( IncAddr (C113 , C117) ) , C119) ) ) + C118 ) = ( ( IC ( Exec (( R31 =0_goto ( C117 + R14 ) ) , C119) ) ) + C118 ) by L976 , L926
.= ( ( C117 + R14 ) + C118 ) by L980 , SCMFSA_2:70
.= ( IC ( Exec (( R31 =0_goto ( ( C117 + C118 ) + R14 ) ) , D106) ) ) by L979 , L980 , SCMFSA_2:70
.= ( IC ( Exec (( IncAddr (C113 , ( C117 + C118 )) ) , D106) ) ) by L976 , L926;
end;
suppose L982: ( C119 . R31 ) <> ( 0 );

L983: ( IncAddr (C113 , C117) ) = ( R31 =0_goto ( R14 + C117 ) ) by L976 , L926;
L984: ( IncAddr (C113 , ( C117 + C118 )) ) = ( R31 =0_goto ( R14 + ( C117 + C118 ) ) ) by L976 , L926;
L985: ( dom ( ( IC ( SCM+FSA ) ) .--> ( ( IC C119 ) + C118 ) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L986: ( IC ( SCM+FSA ) ) in ( dom ( ( IC ( SCM+FSA ) ) .--> ( ( IC C119 ) + C118 ) ) ) by L985 , TARSKI:def 1;
L987: ( IC D106 ) = ( ( ( IC ( SCM+FSA ) ) .--> ( ( IC C119 ) + C118 ) ) . ( IC ( SCM+FSA ) ) ) by L986 , FUNCT_4:13
.= ( ( IC C119 ) + C118 ) by FUNCOP_1:72;
thus L988: ( ( IC ( Exec (( IncAddr (C113 , C117) ) , C119) ) ) + C118 ) = ( ( succ ( IC C119 ) ) + C118 ) by L983 , L982 , SCMFSA_2:70
.= ( succ ( IC D106 ) ) by L987
.= ( IC ( Exec (( IncAddr (C113 , ( C117 + C118 )) ) , D106) ) ) by L984 , L982 , L979 , SCMFSA_2:70;
end;
end;
suppose L990: (ex R14 being (Element of ( NAT )) st (ex R31 being Int-Location st C113 = ( R31 >0_goto R14 )));

consider R14 being (Element of ( NAT )), R31 being Int-Location such that L991: C113 = ( R31 >0_goto R14 ) by L990;
let C120 , C121 being Nat;
let C122 being (State of ( SCM+FSA ));
set D107 = ( IncIC (C122 , C121) );
L992: (R31 <> ( IC ( SCM+FSA ) ) & ( dom ( ( IC ( SCM+FSA ) ) .--> ( ( IC C122 ) + C121 ) ) ) = { ( IC ( SCM+FSA ) ) }) by FUNCOP_1:13 , SCMFSA_2:56;
L993: (not R31 in ( dom ( ( IC ( SCM+FSA ) ) .--> ( ( IC C122 ) + C121 ) ) )) by L992 , TARSKI:def 1;
L994: ( C122 . R31 ) = ( D107 . R31 ) by L993 , FUNCT_4:11;
per cases ;
suppose L995: ( C122 . R31 ) > ( 0 );

thus L996: ( ( IC ( Exec (( IncAddr (C113 , C120) ) , C122) ) ) + C121 ) = ( ( IC ( Exec (( R31 >0_goto ( C120 + R14 ) ) , C122) ) ) + C121 ) by L991 , L943
.= ( ( C120 + R14 ) + C121 ) by L995 , SCMFSA_2:71
.= ( IC ( Exec (( R31 >0_goto ( ( C120 + C121 ) + R14 ) ) , D107) ) ) by L994 , L995 , SCMFSA_2:71
.= ( IC ( Exec (( IncAddr (C113 , ( C120 + C121 )) ) , D107) ) ) by L991 , L943;
end;
suppose L997: ( C122 . R31 ) <= ( 0 );

L998: ( IncAddr (C113 , C120) ) = ( R31 >0_goto ( R14 + C120 ) ) by L991 , L943;
L999: ( IncAddr (C113 , ( C120 + C121 )) ) = ( R31 >0_goto ( R14 + ( C120 + C121 ) ) ) by L991 , L943;
L1000: ( dom ( ( IC ( SCM+FSA ) ) .--> ( ( IC C122 ) + C121 ) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L1001: ( IC ( SCM+FSA ) ) in ( dom ( ( IC ( SCM+FSA ) ) .--> ( ( IC C122 ) + C121 ) ) ) by L1000 , TARSKI:def 1;
L1002: ( IC D107 ) = ( ( ( IC ( SCM+FSA ) ) .--> ( ( IC C122 ) + C121 ) ) . ( IC ( SCM+FSA ) ) ) by L1001 , FUNCT_4:13
.= ( ( IC C122 ) + C121 ) by FUNCOP_1:72;
thus L1003: ( ( IC ( Exec (( IncAddr (C113 , C120) ) , C122) ) ) + C121 ) = ( ( succ ( IC C122 ) ) + C121 ) by L998 , L997 , SCMFSA_2:71
.= ( succ ( IC D107 ) ) by L1002
.= ( IC ( Exec (( IncAddr (C113 , ( C120 + C121 )) ) , D107) ) ) by L999 , L997 , L994 , SCMFSA_2:71;
end;
end;
suppose L1005: (ex R31 being Int-Location st (ex R32 being Int-Location st (ex R39 being FinSeq-Location st C113 = ( R32 := (R39 , R31) ))));

thus L1006: thesis by L1005;
end;
suppose L1007: (ex R31 being Int-Location st (ex R32 being Int-Location st (ex R39 being FinSeq-Location st C113 = ( (R39 , R31) := R32 ))));

thus L1008: thesis by L1007;
end;
suppose L1009: (ex R31 being Int-Location st (ex R39 being FinSeq-Location st C113 = ( R31 :=len R39 )));

thus L1010: thesis by L1009;
end;
suppose L1011: (ex R31 being Int-Location st (ex R39 being FinSeq-Location st C113 = ( R39 :=<0,...,0> R31 )));

thus L1012: thesis by L1011;
end;
end;
end;
