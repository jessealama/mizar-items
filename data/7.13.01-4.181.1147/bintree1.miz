:: On Defining Functions on Binary Trees
::  by Grzegorz Bancerek and Piotr Rudnicki
::
:: Received December 30, 1993
:: Copyright (c) 1993-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, XBOOLE_0, TREES_2, SUBSET_1, FUNCT_1, TREES_4, TREES_3,
      FINSEQ_1, TREES_1, ORDINAL1, ORDINAL4, CARD_1, XXREAL_0, ARYTM_3,
      FINSET_1, RELAT_1, TARSKI, TREES_A, LANG1, TDGROUP, DTCONSTR, STRUCT_0,
      ZFMISC_1, FUNCT_2, BINTREE1;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, NUMBERS, NAT_1, RELAT_1,
      STRUCT_0, MCART_1, FUNCT_1, RELSET_1, FUNCT_2, FINSEQ_1, FINSET_1, LANG1,
      TREES_1, TREES_2, TREES_3, TREES_4, DTCONSTR, PRE_POLY, XXREAL_0;
 constructors DOMAIN_1, FINSEQOP, DTCONSTR, RELSET_1, PRE_POLY, XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, MEMBERED, FINSEQ_1,
      TREES_2, TREES_3, STRUCT_0, DTCONSTR, FINSET_1, TREES_4, TREES_1,
      RELSET_1, XTUPLE_0;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions DTCONSTR, XTUPLE_0;
 theorems TARSKI, NAT_1, MCART_1, ZFMISC_1, ENUMSET1, MODAL_1, RELSET_1,
      FUNCT_1, FUNCT_2, FINSEQ_1, FINSEQ_2, LANG1, TREES_1, TREES_2, TREES_3,
      TREES_4, DTCONSTR, FINSET_1, XTUPLE_0;
 schemes FUNCT_2, DTCONSTR, MULTOP_1;

begin
definition
let C1 being non  empty set;
let C2 being (DecoratedTree of C1);
func root-label C2 -> (Element of C1) equals 
( C2 . ( {} ) );
coherence
proof
reconsider D1 = ( {} ) as (Node of C2) by TREES_1:22;
L1: ( C2 . D1 ) is (Element of C1);
thus L2: thesis by L1;
end;
end;
theorem
L4: (for B1 being non  empty set holds (for B2 being (DecoratedTree of B1) holds ( roots <* B2 *> ) = <* ( root-label B2 ) *>)) by DTCONSTR:4;
theorem
L5: (for B3 being non  empty set holds (for B4 , B5 being (DecoratedTree of B3) holds ( roots <* B4 , B5 *> ) = <* ( root-label B4 ) , ( root-label B5 ) *>)) by DTCONSTR:6;
definition
let C3 being Tree;
attr C3 is  binary
means
:L6: (for B6 being (Element of C3) holds ((not B6 in ( Leaves C3 )) implies ( succ B6 ) = { ( B6 ^ <* ( 0 ) *> ) , ( B6 ^ <* 1 *> ) }));
end;
theorem
L8: (for B7 being Tree holds (for B8 being (Element of B7) holds (( succ B8 ) = ( {} ) iff B8 in ( Leaves B7 ))))
proof
let C4 being Tree;
let C5 being (Element of C4);
thus L9:now
assume L10: ( succ C5 ) = ( {} );
L11: (not ( C5 ^ <* ( 0 ) *> ) in { ( C5 ^ <* B9 *> ) where B9 is (Element of ( NAT )) : ( C5 ^ <* B9 *> ) in C4 }) by L10 , TREES_2:def 5;
L12: (not ( C5 ^ <* ( 0 ) *> ) in C4) by L11;
thus L13: C5 in ( Leaves C4 ) by L12 , TREES_1:54;
end;
set D2 = the (Element of ( succ C5 ));
assume L14: C5 in ( Leaves C4 );
L15: (not ( C5 ^ <* ( 0 ) *> ) in C4) by L14 , TREES_1:54;
assume L16: ( succ C5 ) <> ( {} );
L17: D2 in ( succ C5 ) by L16;
L18: D2 in { ( C5 ^ <* B10 *> ) where B10 is (Element of ( NAT )) : ( C5 ^ <* B10 *> ) in C4 } by L17 , TREES_2:def 5;
consider C6 being (Element of ( NAT )) such that L19: D2 = ( C5 ^ <* C6 *> ) and L20: ( C5 ^ <* C6 *> ) in C4 by L18;
L21: ( 0 ) <= C6 by NAT_1:2;
thus L22: contradiction by L21 , L15 , L20 , TREES_1:def 3;
end;
registration
cluster ( elementary_tree ( 0 ) ) ->  binary;
coherence
proof
set D3 = ( elementary_tree ( 0 ) );
let C7 being (Element of D3);
L23:
now
let C8 being (FinSequence of ( NAT ));
assume L24: C8 in D3;
L25: C8 = ( {} ) by L24 , TARSKI:def 1 , TREES_1:29;
thus L26: (not C7 is_a_proper_prefix_of C8) by L25 , TARSKI:def 1 , TREES_1:29;
end;
thus L27: thesis by L23 , TREES_1:def 5;
end;
cluster ( elementary_tree 2 ) ->  binary;
coherence
proof
set D4 = ( elementary_tree 2 );
let C9 being (Element of D4);
assume L28: (not C9 in ( Leaves D4 ));
per cases  by ENUMSET1:def 1 , MODAL_1:7;
suppose L29: C9 = ( {} );

L30: (for B11 being set holds (B11 in { ( C9 ^ <* B12 *> ) where B12 is (Element of ( NAT )) : ( C9 ^ <* B12 *> ) in D4 } iff B11 in { ( C9 ^ <* ( 0 ) *> ) , ( C9 ^ <* 1 *> ) }))
proof
let C10 being set;
thus L31:now
assume L32: C10 in { ( C9 ^ <* B13 *> ) where B13 is (Element of ( NAT )) : ( C9 ^ <* B13 *> ) in D4 };
L33: (ex B14 being (Element of ( NAT )) st (C10 = ( C9 ^ <* B14 *> ) & ( C9 ^ <* B14 *> ) in D4)) by L32;
reconsider D5 = C10 as FinSequence by L33;
per cases  by L33 , ENUMSET1:def 1 , MODAL_1:7;
suppose L34: C10 = ( {} );

thus L35: C10 in { ( C9 ^ <* ( 0 ) *> ) , ( C9 ^ <* 1 *> ) } by L34 , L33;
end;
suppose L36: C10 = <* ( 0 ) *>;

L37: D5 = ( C9 ^ <* ( 0 ) *> ) by L36 , L29 , FINSEQ_1:34;
thus L38: C10 in { ( C9 ^ <* ( 0 ) *> ) , ( C9 ^ <* 1 *> ) } by L37 , TARSKI:def 2;
end;
suppose L39: C10 = <* 1 *>;

L40: D5 = ( C9 ^ <* 1 *> ) by L39 , L29 , FINSEQ_1:34;
thus L41: C10 in { ( C9 ^ <* ( 0 ) *> ) , ( C9 ^ <* 1 *> ) } by L40 , TARSKI:def 2;
end;
end;
assume L43: C10 in { ( C9 ^ <* ( 0 ) *> ) , ( C9 ^ <* 1 *> ) };
reconsider D6 = C10 as FinSequence by L43 , TARSKI:def 2;
L44: (C10 = ( C9 ^ <* ( 0 ) *> ) or C10 = ( C9 ^ <* 1 *> )) by L43 , TARSKI:def 2;
L45: (D6 = <* ( 0 ) *> or D6 = <* 1 *>) by L44 , L29 , FINSEQ_1:34;
L46: D6 in D4 by L45 , ENUMSET1:def 1 , MODAL_1:7;
thus L47: thesis by L46 , L44;
end;
L48: ( succ C9 ) = { ( C9 ^ <* B15 *> ) where B15 is (Element of ( NAT )) : ( C9 ^ <* B15 *> ) in D4 } by TREES_2:def 5;
thus L49: thesis by L48 , L30 , TARSKI:1;
end;
suppose L50: C9 = <* ( 0 ) *>;

L51:
now
assume L52: ( C9 ^ <* ( 0 ) *> ) in D4;
per cases  by L52 , ENUMSET1:def 1 , MODAL_1:7;
suppose L53: ( C9 ^ <* ( 0 ) *> ) = ( {} );

thus L54: contradiction by L53;
end;
suppose L55: ( C9 ^ <* ( 0 ) *> ) = <* ( 0 ) *>;

L56: ( ( len <* ( 0 ) *> ) + ( len <* ( 0 ) *> ) ) = ( len <* ( 0 ) *> ) by L55 , L50 , FINSEQ_1:22;
thus L57: contradiction by L56 , FINSEQ_1:39;
end;
suppose L58: ( C9 ^ <* ( 0 ) *> ) = <* 1 *>;

L59: ( ( len <* ( 0 ) *> ) + ( len <* ( 0 ) *> ) ) = ( len <* 1 *> ) by L58 , L50 , FINSEQ_1:22;
L60: ( 1 + ( len <* ( 0 ) *> ) ) = ( len <* 1 *> ) by L59 , FINSEQ_1:39;
L61: ( 1 + 1 ) = ( len <* 1 *> ) by L60 , FINSEQ_1:39;
thus L62: contradiction by L61 , FINSEQ_1:39;
end;
end;
thus L64: thesis by L51 , L28 , TREES_1:54;
end;
suppose L65: C9 = <* 1 *>;

L66:
now
assume L67: ( C9 ^ <* ( 0 ) *> ) in D4;
per cases  by L67 , ENUMSET1:def 1 , MODAL_1:7;
suppose L68: ( C9 ^ <* ( 0 ) *> ) = ( {} );

thus L69: contradiction by L68;
end;
suppose L70: ( C9 ^ <* ( 0 ) *> ) = <* ( 0 ) *>;

L71: ( ( len <* 1 *> ) + ( len <* ( 0 ) *> ) ) = ( len <* ( 0 ) *> ) by L70 , L65 , FINSEQ_1:22;
thus L72: contradiction by L71 , FINSEQ_1:39;
end;
suppose L73: ( C9 ^ <* ( 0 ) *> ) = <* 1 *>;

L74: ( ( len <* 1 *> ) + ( len <* ( 0 ) *> ) ) = ( len <* 1 *> ) by L73 , L65 , FINSEQ_1:22;
thus L75: contradiction by L74 , FINSEQ_1:39;
end;
end;
thus L77: thesis by L66 , L28 , TREES_1:54;
end;
end;
end;
theorem
L80: ( elementary_tree ( 0 ) ) is  binary;
theorem
L81: ( elementary_tree 2 ) is  binary;
registration
cluster  binary  finite for Tree;
existence
proof
take ( elementary_tree ( 0 ) );
thus L82: thesis;
end;
end;
definition
let C11 being DecoratedTree;
attr C11 is  binary
means
:L84: ( dom C11 ) is  binary;
end;
registration
let C12 being non  empty set;
cluster  binary  finite for (DecoratedTree of C12);
existence
proof
set D7 = the  binary  finite Tree;
set D8 = the (Function of D7 , C12);
reconsider D9 = D8 as (DecoratedTree of C12);
take D9;
thus L86: (( dom D9 ) is  binary & D9 is  finite) by FUNCT_2:def 1;
end;
end;
registration
cluster  binary  finite for DecoratedTree;
existence
proof
set D10 = the  binary  finite (DecoratedTree of { ( {} ) });
take D10;
thus L88: thesis;
end;
end;
registration
cluster  binary ->  finite-order for Tree;
coherence
proof
let C13 being Tree;
assume L90: C13 is  binary;
L91:
now
let C14 being (Element of C13);
assume L92: ( C14 ^ <* 2 *> ) in C13;
L93: ( C14 ^ <* ( 0 ) *> ) in C13 by L92 , TREES_1:def 3;
per cases ;
suppose L94: C14 in ( Leaves C13 );

thus L95: contradiction by L94 , L93 , TREES_1:54;
end;
suppose L96: (not C14 in ( Leaves C13 ));

L97:
now
L98: ( <* 2 *> . 1 ) = 2 by FINSEQ_1:40;
assume L99: <* 2 *> = <* ( 0 ) *>;
thus L100: contradiction by L99 , L98 , FINSEQ_1:40;
end;
L101:
now
L102: ( <* 2 *> . 1 ) = 2 by FINSEQ_1:40;
assume L103: <* 2 *> = <* 1 *>;
thus L104: contradiction by L103 , L102 , FINSEQ_1:40;
end;
L105: ( C14 ^ <* 2 *> ) in { ( C14 ^ <* B16 *> ) where B16 is (Element of ( NAT )) : ( C14 ^ <* B16 *> ) in C13 } by L92;
L106: ( C14 ^ <* 2 *> ) in ( succ C14 ) by L105 , TREES_2:def 5;
L107: ( succ C14 ) = { ( C14 ^ <* ( 0 ) *> ) , ( C14 ^ <* 1 *> ) } by L90 , L96 , L6;
L108: (( C14 ^ <* 2 *> ) = ( C14 ^ <* ( 0 ) *> ) or ( C14 ^ <* 2 *> ) = ( C14 ^ <* 1 *> )) by L107 , L106 , TARSKI:def 2;
thus L109: contradiction by L108 , L97 , L101 , FINSEQ_1:33;
end;
end;
thus L111: thesis by L91 , TREES_2:def 2;
end;
end;
theorem
L113: (for B17 , B18 being Tree holds (for B19 being (Element of ( tree (B17 , B18) )) holds ((for B20 being (Element of B17) holds (B19 = ( <* ( 0 ) *> ^ B20 ) implies (B19 in ( Leaves ( tree (B17 , B18) ) ) iff B20 in ( Leaves B17 )))) & (for B21 being (Element of B18) holds (B19 = ( <* 1 *> ^ B21 ) implies (B19 in ( Leaves ( tree (B17 , B18) ) ) iff B21 in ( Leaves B18 )))))))
proof
let C15 , C16 being Tree;
let C17 being (Element of ( tree (C15 , C16) ));
set D11 = ( tree (C15 , C16) );
thus L114:now
let C18 being (Element of C15);
assume L115: C17 = ( <* ( 0 ) *> ^ C18 );
thus L116:now
assume L117: C17 in ( Leaves D11 );
assume L118: (not C18 in ( Leaves C15 ));
consider C19 being (Element of ( NAT )) such that L119: ( C18 ^ <* C19 *> ) in C15 by L118 , TREES_1:55;
L120: ( <* ( 0 ) *> ^ ( C18 ^ <* C19 *> ) ) in D11 by L119 , TREES_3:69;
L121: ( ( <* ( 0 ) *> ^ C18 ) ^ <* C19 *> ) in D11 by L120 , FINSEQ_1:32;
thus L122: contradiction by L121 , L115 , L117 , TREES_1:55;
end;
assume L123: C18 in ( Leaves C15 );
assume L124: (not C17 in ( Leaves D11 ));
consider C20 being (Element of ( NAT )) such that L125: ( C17 ^ <* C20 *> ) in D11 by L124 , TREES_1:55;
L126: ( <* ( 0 ) *> ^ ( C18 ^ <* C20 *> ) ) in D11 by L115 , L125 , FINSEQ_1:32;
L127: ( C18 ^ <* C20 *> ) in C15 by L126 , TREES_3:69;
thus L128: contradiction by L127 , L123 , TREES_1:55;
end;
let C21 being (Element of C16);
assume L129: C17 = ( <* 1 *> ^ C21 );
thus L130:now
assume L131: C17 in ( Leaves D11 );
assume L132: (not C21 in ( Leaves C16 ));
consider C22 being (Element of ( NAT )) such that L133: ( C21 ^ <* C22 *> ) in C16 by L132 , TREES_1:55;
L134: ( <* 1 *> ^ ( C21 ^ <* C22 *> ) ) in D11 by L133 , TREES_3:70;
L135: ( ( <* 1 *> ^ C21 ) ^ <* C22 *> ) in D11 by L134 , FINSEQ_1:32;
thus L136: contradiction by L135 , L129 , L131 , TREES_1:55;
end;
assume L137: C21 in ( Leaves C16 );
assume L138: (not C17 in ( Leaves D11 ));
consider C23 being (Element of ( NAT )) such that L139: ( C17 ^ <* C23 *> ) in D11 by L138 , TREES_1:55;
L140: ( <* 1 *> ^ ( C21 ^ <* C23 *> ) ) in D11 by L129 , L139 , FINSEQ_1:32;
L141: ( C21 ^ <* C23 *> ) in C16 by L140 , TREES_3:70;
thus L142: contradiction by L141 , L137 , TREES_1:55;
end;
theorem
L143: (for B22 , B23 being Tree holds (for B24 being (Element of ( tree (B22 , B23) )) holds ((B24 = ( {} ) implies ( succ B24 ) = { ( B24 ^ <* ( 0 ) *> ) , ( B24 ^ <* 1 *> ) }) & (for B25 being (Element of B22) holds (B24 = ( <* ( 0 ) *> ^ B25 ) implies (for B26 being FinSequence holds (B26 in ( succ B25 ) iff ( <* ( 0 ) *> ^ B26 ) in ( succ B24 ))))) & (for B27 being (Element of B23) holds (B24 = ( <* 1 *> ^ B27 ) implies (for B28 being FinSequence holds (B28 in ( succ B27 ) iff ( <* 1 *> ^ B28 ) in ( succ B24 ))))))))
proof
let C24 , C25 being Tree;
let C26 being (Element of ( tree (C24 , C25) ));
set D12 = ( tree (C24 , C25) );
thus L144:now
assume L145: C26 = ( {} );
L146: (( {} ) in C25 & <* 1 *> = ( <* 1 *> ^ ( {} ) )) by FINSEQ_1:34 , TREES_1:22;
L147: <* 1 *> in D12 by L146 , TREES_3:68;
L148: ( C26 ^ <* 1 *> ) in D12 by L147 , L145 , FINSEQ_1:34;
L149: ( succ C26 ) = { ( C26 ^ <* B29 *> ) where B29 is (Element of ( NAT )) : ( C26 ^ <* B29 *> ) in D12 } by TREES_2:def 5;
L150: (( {} ) in C24 & <* ( 0 ) *> = ( <* ( 0 ) *> ^ ( {} ) )) by FINSEQ_1:34 , TREES_1:22;
L151: <* ( 0 ) *> in D12 by L150 , TREES_3:68;
L152: ( C26 ^ <* ( 0 ) *> ) in D12 by L151 , L145 , FINSEQ_1:34;
L153:
now
let C27 being set;
thus L154:now
assume L155: C27 in ( succ C26 );
consider C28 being (Element of ( NAT )) such that L156: C27 = ( C26 ^ <* C28 *> ) and L157: ( C26 ^ <* C28 *> ) in D12 by L155 , L149;
reconsider D13 = C27 as FinSequence by L156;
L158: (ex B30 being FinSequence st ((B30 in C24 & D13 = ( <* ( 0 ) *> ^ B30 )) or (B30 in C25 & D13 = ( <* 1 *> ^ B30 )))) by L156 , L157 , TREES_3:68;
L159: (( D13 . 1 ) = ( 0 ) or ( D13 . 1 ) = 1) by L158 , FINSEQ_1:41;
L160: C27 = <* C28 *> by L145 , L156 , FINSEQ_1:34;
L161: (D13 = <* ( 0 ) *> or D13 = <* 1 *>) by L160 , L159 , FINSEQ_1:40;
L162: (D13 = ( C26 ^ <* ( 0 ) *> ) or D13 = ( C26 ^ <* 1 *> )) by L161 , L145 , FINSEQ_1:34;
thus L163: C27 in { ( C26 ^ <* ( 0 ) *> ) , ( C26 ^ <* 1 *> ) } by L162 , TARSKI:def 2;
end;
assume L164: C27 in { ( C26 ^ <* ( 0 ) *> ) , ( C26 ^ <* 1 *> ) };
L165: (C27 = ( C26 ^ <* ( 0 ) *> ) or C27 = ( C26 ^ <* 1 *> )) by L164 , TARSKI:def 2;
thus L166: C27 in ( succ C26 ) by L165 , L149 , L152 , L148;
end;
thus L167: ( succ C26 ) = { ( C26 ^ <* ( 0 ) *> ) , ( C26 ^ <* 1 *> ) } by L153 , TARSKI:1;
end;
thus L168:now
let C29 being (Element of C24);
assume that
L169: C26 = ( <* ( 0 ) *> ^ C29 );
let C30 being FinSequence;
thus L170:now
assume L171: C30 in ( succ C29 );
L172: C30 in { ( C29 ^ <* B31 *> ) where B31 is (Element of ( NAT )) : ( C29 ^ <* B31 *> ) in C24 } by L171 , TREES_2:def 5;
consider C31 being (Element of ( NAT )) such that L173: C30 = ( C29 ^ <* C31 *> ) and L174: ( C29 ^ <* C31 *> ) in C24 by L172;
L175: ( <* ( 0 ) *> ^ ( C29 ^ <* C31 *> ) ) in D12 by L174 , TREES_3:69;
L176: ( ( <* ( 0 ) *> ^ C29 ) ^ <* C31 *> ) in D12 by L175 , FINSEQ_1:32;
L177: ( C26 ^ <* C31 *> ) in { ( C26 ^ <* B32 *> ) where B32 is (Element of ( NAT )) : ( C26 ^ <* B32 *> ) in D12 } by L176 , L169;
L178: ( C26 ^ <* C31 *> ) in ( succ C26 ) by L177 , TREES_2:def 5;
thus L179: ( <* ( 0 ) *> ^ C30 ) in ( succ C26 ) by L178 , L169 , L173 , FINSEQ_1:32;
end;
set D14 = ( <* ( 0 ) *> ^ C30 );
assume L180: D14 in ( succ C26 );
L181: D14 in { ( C26 ^ <* B33 *> ) where B33 is (Element of ( NAT )) : ( C26 ^ <* B33 *> ) in D12 } by L180 , TREES_2:def 5;
consider C32 being (Element of ( NAT )) such that L182: D14 = ( C26 ^ <* C32 *> ) and L183: ( C26 ^ <* C32 *> ) in D12 by L181;
L184: ( <* ( 0 ) *> ^ ( C29 ^ <* C32 *> ) ) in D12 by L169 , L183 , FINSEQ_1:32;
L185: ( C29 ^ <* C32 *> ) in C24 by L184 , TREES_3:69;
L186: ( C29 ^ <* C32 *> ) in { ( C29 ^ <* B34 *> ) where B34 is (Element of ( NAT )) : ( C29 ^ <* B34 *> ) in C24 } by L185;
L187: ( C29 ^ <* C32 *> ) in ( succ C29 ) by L186 , TREES_2:def 5;
L188: ( <* ( 0 ) *> ^ C30 ) = ( <* ( 0 ) *> ^ ( C29 ^ <* C32 *> ) ) by L169 , L182 , FINSEQ_1:32;
thus L189: C30 in ( succ C29 ) by L188 , L187 , FINSEQ_1:33;
end;
let C33 being (Element of C25);
assume that
L190: C26 = ( <* 1 *> ^ C33 );
let C34 being FinSequence;
thus L191:now
assume L192: C34 in ( succ C33 );
L193: C34 in { ( C33 ^ <* B35 *> ) where B35 is (Element of ( NAT )) : ( C33 ^ <* B35 *> ) in C25 } by L192 , TREES_2:def 5;
consider C35 being (Element of ( NAT )) such that L194: C34 = ( C33 ^ <* C35 *> ) and L195: ( C33 ^ <* C35 *> ) in C25 by L193;
L196: ( <* 1 *> ^ ( C33 ^ <* C35 *> ) ) in D12 by L195 , TREES_3:70;
L197: ( ( <* 1 *> ^ C33 ) ^ <* C35 *> ) in D12 by L196 , FINSEQ_1:32;
L198: ( C26 ^ <* C35 *> ) in { ( C26 ^ <* B36 *> ) where B36 is (Element of ( NAT )) : ( C26 ^ <* B36 *> ) in D12 } by L197 , L190;
L199: ( C26 ^ <* C35 *> ) in ( succ C26 ) by L198 , TREES_2:def 5;
thus L200: ( <* 1 *> ^ C34 ) in ( succ C26 ) by L199 , L190 , L194 , FINSEQ_1:32;
end;
set D15 = ( <* 1 *> ^ C34 );
assume L201: D15 in ( succ C26 );
L202: D15 in { ( C26 ^ <* B37 *> ) where B37 is (Element of ( NAT )) : ( C26 ^ <* B37 *> ) in D12 } by L201 , TREES_2:def 5;
consider C36 being (Element of ( NAT )) such that L203: D15 = ( C26 ^ <* C36 *> ) and L204: ( C26 ^ <* C36 *> ) in D12 by L202;
L205: ( <* 1 *> ^ ( C33 ^ <* C36 *> ) ) in D12 by L190 , L204 , FINSEQ_1:32;
L206: ( C33 ^ <* C36 *> ) in C25 by L205 , TREES_3:70;
L207: ( C33 ^ <* C36 *> ) in { ( C33 ^ <* B38 *> ) where B38 is (Element of ( NAT )) : ( C33 ^ <* B38 *> ) in C25 } by L206;
L208: ( C33 ^ <* C36 *> ) in ( succ C33 ) by L207 , TREES_2:def 5;
L209: ( <* 1 *> ^ C34 ) = ( <* 1 *> ^ ( C33 ^ <* C36 *> ) ) by L190 , L203 , FINSEQ_1:32;
thus L210: thesis by L209 , L208 , FINSEQ_1:33;
end;
theorem
L211: (for B39 , B40 being Tree holds ((B39 is  binary & B40 is  binary) iff ( tree (B39 , B40) ) is  binary))
proof
let C37 , C38 being Tree;
set D16 = ( tree (C37 , C38) );
thus L212:now
assume that
L213: C37 is  binary
and
L214: C38 is  binary;
L215:
now
let C39 being (Element of D16);
assume L216: (not C39 in ( Leaves D16 ));
per cases  by TREES_3:68;
suppose L217: C39 = ( {} );

thus L218: ( succ C39 ) = { ( C39 ^ <* ( 0 ) *> ) , ( C39 ^ <* 1 *> ) } by L217 , L143;
end;
suppose L219: (ex B41 being FinSequence st ((B41 in C37 & C39 = ( <* ( 0 ) *> ^ B41 )) or (B41 in C38 & C39 = ( <* 1 *> ^ B41 ))));

consider C40 being FinSequence such that L220: ((C40 in C37 & C39 = ( <* ( 0 ) *> ^ C40 )) or (C40 in C38 & C39 = ( <* 1 *> ^ C40 ))) by L219;
L221:
now
assume that
L222: C40 in C38
and
L223: C39 = ( <* 1 *> ^ C40 );
reconsider D17 = C40 as (Element of C38) by L222;
per cases ;
suppose L224: D17 in ( Leaves C38 );

thus L225: ( succ C39 ) = { ( C39 ^ <* ( 0 ) *> ) , ( C39 ^ <* 1 *> ) } by L224 , L216 , L223 , L113;
end;
suppose L226: (not D17 in ( Leaves C38 ));

L227: ( succ D17 ) = { ( D17 ^ <* ( 0 ) *> ) , ( D17 ^ <* 1 *> ) } by L226 , L214 , L6;
L228:
now
let C41 being set;
thus L229:now
assume L230: C41 in ( succ C39 );
L231: C41 in { ( C39 ^ <* B42 *> ) where B42 is (Element of ( NAT )) : ( C39 ^ <* B42 *> ) in D16 } by L230 , TREES_2:def 5;
consider C42 being (Element of ( NAT )) such that L232: C41 = ( C39 ^ <* C42 *> ) and L233: ( C39 ^ <* C42 *> ) in D16 by L231;
L234: C41 = ( <* 1 *> ^ ( D17 ^ <* C42 *> ) ) by L223 , L232 , FINSEQ_1:32;
reconsider D18 = ( D17 ^ <* C42 *> ) as (Element of C38) by L234 , L232 , L233 , TREES_3:70;
L235: D18 in ( succ D17 ) by L223 , L230 , L234 , L143;
L236: (D18 = ( D17 ^ <* ( 0 ) *> ) or D18 = ( D17 ^ <* 1 *> )) by L235 , L227 , TARSKI:def 2;
L237: (C41 = ( C39 ^ <* ( 0 ) *> ) or C41 = ( C39 ^ <* 1 *> )) by L236 , L232 , FINSEQ_1:33;
thus L238: C41 in { ( C39 ^ <* ( 0 ) *> ) , ( C39 ^ <* 1 *> ) } by L237 , TARSKI:def 2;
end;
assume L239: C41 in { ( C39 ^ <* ( 0 ) *> ) , ( C39 ^ <* 1 *> ) };
L240: (C41 = ( ( <* 1 *> ^ D17 ) ^ <* ( 0 ) *> ) or C41 = ( ( <* 1 *> ^ D17 ) ^ <* 1 *> )) by L239 , L223 , TARSKI:def 2;
L241: (C41 = ( <* 1 *> ^ ( D17 ^ <* ( 0 ) *> ) ) or C41 = ( <* 1 *> ^ ( D17 ^ <* 1 *> ) )) by L240 , FINSEQ_1:32;
L242: (( D17 ^ <* ( 0 ) *> ) in ( succ D17 ) & ( D17 ^ <* 1 *> ) in ( succ D17 )) by L227 , TARSKI:def 2;
thus L243: C41 in ( succ C39 ) by L242 , L223 , L241 , L143;
end;
thus L244: ( succ C39 ) = { ( C39 ^ <* ( 0 ) *> ) , ( C39 ^ <* 1 *> ) } by L228 , TARSKI:1;
end;
end;
L246:
now
assume that
L247: C40 in C37
and
L248: C39 = ( <* ( 0 ) *> ^ C40 );
reconsider D19 = C40 as (Element of C37) by L247;
per cases ;
suppose L249: D19 in ( Leaves C37 );

thus L250: ( succ C39 ) = { ( C39 ^ <* ( 0 ) *> ) , ( C39 ^ <* 1 *> ) } by L249 , L216 , L248 , L113;
end;
suppose L251: (not D19 in ( Leaves C37 ));

L252: ( succ D19 ) = { ( D19 ^ <* ( 0 ) *> ) , ( D19 ^ <* 1 *> ) } by L251 , L213 , L6;
L253:
now
let C43 being set;
thus L254:now
assume L255: C43 in ( succ C39 );
L256: C43 in { ( C39 ^ <* B43 *> ) where B43 is (Element of ( NAT )) : ( C39 ^ <* B43 *> ) in D16 } by L255 , TREES_2:def 5;
consider C44 being (Element of ( NAT )) such that L257: C43 = ( C39 ^ <* C44 *> ) and L258: ( C39 ^ <* C44 *> ) in D16 by L256;
L259: C43 = ( <* ( 0 ) *> ^ ( D19 ^ <* C44 *> ) ) by L248 , L257 , FINSEQ_1:32;
reconsider D20 = ( D19 ^ <* C44 *> ) as (Element of C37) by L259 , L257 , L258 , TREES_3:69;
L260: D20 in ( succ D19 ) by L248 , L255 , L259 , L143;
L261: (D20 = ( D19 ^ <* ( 0 ) *> ) or D20 = ( D19 ^ <* 1 *> )) by L260 , L252 , TARSKI:def 2;
L262: (C43 = ( C39 ^ <* ( 0 ) *> ) or C43 = ( C39 ^ <* 1 *> )) by L261 , L257 , FINSEQ_1:33;
thus L263: C43 in { ( C39 ^ <* ( 0 ) *> ) , ( C39 ^ <* 1 *> ) } by L262 , TARSKI:def 2;
end;
assume L264: C43 in { ( C39 ^ <* ( 0 ) *> ) , ( C39 ^ <* 1 *> ) };
L265: (C43 = ( ( <* ( 0 ) *> ^ D19 ) ^ <* ( 0 ) *> ) or C43 = ( ( <* ( 0 ) *> ^ D19 ) ^ <* 1 *> )) by L264 , L248 , TARSKI:def 2;
L266: (C43 = ( <* ( 0 ) *> ^ ( D19 ^ <* ( 0 ) *> ) ) or C43 = ( <* ( 0 ) *> ^ ( D19 ^ <* 1 *> ) )) by L265 , FINSEQ_1:32;
L267: (( D19 ^ <* ( 0 ) *> ) in ( succ D19 ) & ( D19 ^ <* 1 *> ) in ( succ D19 )) by L252 , TARSKI:def 2;
thus L268: C43 in ( succ C39 ) by L267 , L248 , L266 , L143;
end;
thus L269: ( succ C39 ) = { ( C39 ^ <* ( 0 ) *> ) , ( C39 ^ <* 1 *> ) } by L253 , TARSKI:1;
end;
end;
thus L271: ( succ C39 ) = { ( C39 ^ <* ( 0 ) *> ) , ( C39 ^ <* 1 *> ) } by L246 , L220 , L221;
end;
end;
thus L273: ( tree (C37 , C38) ) is  binary by L215 , L6;
end;
assume L274: D16 is  binary;
L275:
now
let C45 being (Element of C37);
reconsider D21 = ( <* ( 0 ) *> ^ C45 ) as (Element of D16) by TREES_3:69;
assume L276: (not C45 in ( Leaves C37 ));
L277: (not D21 in ( Leaves D16 )) by L276 , L113;
L278: ( succ D21 ) = { ( ( <* ( 0 ) *> ^ C45 ) ^ <* ( 0 ) *> ) , ( ( <* ( 0 ) *> ^ C45 ) ^ <* 1 *> ) } by L277 , L274 , L6;
L279: ( succ D21 ) = { ( D21 ^ <* B44 *> ) where B44 is (Element of ( NAT )) : ( D21 ^ <* B44 *> ) in D16 } by TREES_2:def 5;
L280:
now
let C46 being set;
thus L281:now
assume L282: C46 in ( succ C45 );
L283: C46 in { ( C45 ^ <* B45 *> ) where B45 is (Element of ( NAT )) : ( C45 ^ <* B45 *> ) in C37 } by L282 , TREES_2:def 5;
consider C47 being (Element of ( NAT )) such that L284: C46 = ( C45 ^ <* C47 *> ) and L285: ( C45 ^ <* C47 *> ) in C37 by L283;
L286: ( <* ( 0 ) *> ^ ( C45 ^ <* C47 *> ) ) in D16 by L285 , TREES_3:69;
L287: ( D21 ^ <* C47 *> ) in D16 by L286 , FINSEQ_1:32;
L288: ( D21 ^ <* C47 *> ) in { ( D21 ^ <* B46 *> ) where B46 is (Element of ( NAT )) : ( D21 ^ <* B46 *> ) in D16 } by L287;
L289: (( D21 ^ <* C47 *> ) = ( D21 ^ <* ( 0 ) *> ) or ( D21 ^ <* C47 *> ) = ( D21 ^ <* 1 *> )) by L288 , L278 , L279 , TARSKI:def 2;
L290: (C46 = ( C45 ^ <* ( 0 ) *> ) or C46 = ( C45 ^ <* 1 *> )) by L289 , L284 , FINSEQ_1:33;
thus L291: C46 in { ( C45 ^ <* ( 0 ) *> ) , ( C45 ^ <* 1 *> ) } by L290 , TARSKI:def 2;
end;
assume L292: C46 in { ( C45 ^ <* ( 0 ) *> ) , ( C45 ^ <* 1 *> ) };
L293: (C46 = ( C45 ^ <* ( 0 ) *> ) or C46 = ( C45 ^ <* 1 *> )) by L292 , TARSKI:def 2;
L294: ( ( <* ( 0 ) *> ^ C45 ) ^ <* 1 *> ) in ( succ D21 ) by L278 , TARSKI:def 2;
L295: ( <* ( 0 ) *> ^ ( C45 ^ <* 1 *> ) ) in ( succ D21 ) by L294 , FINSEQ_1:32;
L296: ( ( <* ( 0 ) *> ^ C45 ) ^ <* ( 0 ) *> ) in ( succ D21 ) by L278 , TARSKI:def 2;
L297: ( <* ( 0 ) *> ^ ( C45 ^ <* ( 0 ) *> ) ) in ( succ D21 ) by L296 , FINSEQ_1:32;
thus L298: C46 in ( succ C45 ) by L297 , L293 , L295 , L143;
end;
thus L299: ( succ C45 ) = { ( C45 ^ <* ( 0 ) *> ) , ( C45 ^ <* 1 *> ) } by L280 , TARSKI:1;
end;
thus L300: C37 is  binary by L275 , L6;
L301:
now
let C48 being (Element of C38);
reconsider D22 = ( <* 1 *> ^ C48 ) as (Element of D16) by TREES_3:70;
assume L302: (not C48 in ( Leaves C38 ));
L303: (not D22 in ( Leaves D16 )) by L302 , L113;
L304: ( succ D22 ) = { ( ( <* 1 *> ^ C48 ) ^ <* ( 0 ) *> ) , ( ( <* 1 *> ^ C48 ) ^ <* 1 *> ) } by L303 , L274 , L6;
L305: ( succ D22 ) = { ( D22 ^ <* B47 *> ) where B47 is (Element of ( NAT )) : ( D22 ^ <* B47 *> ) in D16 } by TREES_2:def 5;
L306:
now
let C49 being set;
thus L307:now
assume L308: C49 in ( succ C48 );
L309: C49 in { ( C48 ^ <* B48 *> ) where B48 is (Element of ( NAT )) : ( C48 ^ <* B48 *> ) in C38 } by L308 , TREES_2:def 5;
consider C50 being (Element of ( NAT )) such that L310: C49 = ( C48 ^ <* C50 *> ) and L311: ( C48 ^ <* C50 *> ) in C38 by L309;
L312: ( <* 1 *> ^ ( C48 ^ <* C50 *> ) ) in D16 by L311 , TREES_3:70;
L313: ( D22 ^ <* C50 *> ) in D16 by L312 , FINSEQ_1:32;
L314: ( D22 ^ <* C50 *> ) in { ( D22 ^ <* B49 *> ) where B49 is (Element of ( NAT )) : ( D22 ^ <* B49 *> ) in D16 } by L313;
L315: (( D22 ^ <* C50 *> ) = ( D22 ^ <* ( 0 ) *> ) or ( D22 ^ <* C50 *> ) = ( D22 ^ <* 1 *> )) by L314 , L304 , L305 , TARSKI:def 2;
L316: (C49 = ( C48 ^ <* ( 0 ) *> ) or C49 = ( C48 ^ <* 1 *> )) by L315 , L310 , FINSEQ_1:33;
thus L317: C49 in { ( C48 ^ <* ( 0 ) *> ) , ( C48 ^ <* 1 *> ) } by L316 , TARSKI:def 2;
end;
assume L318: C49 in { ( C48 ^ <* ( 0 ) *> ) , ( C48 ^ <* 1 *> ) };
L319: (C49 = ( C48 ^ <* ( 0 ) *> ) or C49 = ( C48 ^ <* 1 *> )) by L318 , TARSKI:def 2;
L320: ( ( <* 1 *> ^ C48 ) ^ <* 1 *> ) in ( succ D22 ) by L304 , TARSKI:def 2;
L321: ( <* 1 *> ^ ( C48 ^ <* 1 *> ) ) in ( succ D22 ) by L320 , FINSEQ_1:32;
L322: ( ( <* 1 *> ^ C48 ) ^ <* ( 0 ) *> ) in ( succ D22 ) by L304 , TARSKI:def 2;
L323: ( <* 1 *> ^ ( C48 ^ <* ( 0 ) *> ) ) in ( succ D22 ) by L322 , FINSEQ_1:32;
thus L324: C49 in ( succ C48 ) by L323 , L319 , L321 , L143;
end;
thus L325: ( succ C48 ) = { ( C48 ^ <* ( 0 ) *> ) , ( C48 ^ <* 1 *> ) } by L306 , TARSKI:1;
end;
thus L326: thesis by L301 , L6;
end;
theorem
L327: (for B50 , B51 being DecoratedTree holds (for B52 being set holds ((B50 is  binary & B51 is  binary) iff ( B52 -tree (B50 , B51) ) is  binary)))
proof
let C51 , C52 being DecoratedTree;
let C53 being set;
thus L328:now
assume L329: (C51 is  binary & C52 is  binary);
L330: (( dom C51 ) is  binary & ( dom C52 ) is  binary) by L329 , L84;
L331: ( tree (( dom C51 ) , ( dom C52 )) ) is  binary by L330 , L211;
L332: ( dom ( C53 -tree (C51 , C52) ) ) = ( tree (( dom C51 ) , ( dom C52 )) ) by TREES_4:14;
thus L333: ( C53 -tree (C51 , C52) ) is  binary by L332 , L331 , L84;
end;
assume L334: ( C53 -tree (C51 , C52) ) is  binary;
L335: ( dom ( C53 -tree (C51 , C52) ) ) is  binary by L334 , L84;
L336: ( dom ( C53 -tree (C51 , C52) ) ) = ( tree (( dom C51 ) , ( dom C52 )) ) by TREES_4:14;
L337: (( dom C51 ) is  binary & ( dom C52 ) is  binary) by L336 , L335 , L211;
thus L338: thesis by L337 , L84;
end;
registration
let C54 being non  empty set;
let C55 being (Element of C54);
let C56 , C57 being  binary  finite (DecoratedTree of C54);
cluster ( C55 -tree (C56 , C57) ) ->  binary  finite C54 -valued;
coherence
proof
set D23 = <* C56 , C57 *>;
L339: ( dom C56 ) is  finite;
L340: C56 in ( FinTrees C54 ) by L339 , TREES_3:def 8;
L341: ( dom C57 ) is  finite;
L342: C57 in ( FinTrees C54 ) by L341 , TREES_3:def 8;
L343: ( rng <* C56 , C57 *> ) = ( rng ( <* C56 *> ^ <* C57 *> ) ) by FINSEQ_1:def 9
.= ( ( rng <* C56 *> ) \/ ( rng <* C57 *> ) ) by FINSEQ_1:31
.= ( { C56 } \/ ( rng <* C57 *> ) ) by FINSEQ_1:39
.= ( { C56 } \/ { C57 } ) by FINSEQ_1:39
.= { C56 , C57 } by ENUMSET1:1;
L344: (for B53 being set holds (B53 in ( rng D23 ) implies B53 in ( FinTrees C54 ))) by L343 , L340 , L342 , TARSKI:def 2;
L345: ( rng D23 ) c= ( FinTrees C54 ) by L344 , TARSKI:def 3;
reconsider D24 = D23 as (FinSequence of ( FinTrees C54 )) by L345 , FINSEQ_1:def 4;
L346: ( C55 -tree (C56 , C57) ) = ( C55 -tree D24 ) by TREES_4:def 6;
L347: ( dom ( C55 -tree (C56 , C57) ) ) is  finite by L346;
thus L348: thesis by L347 , L327 , FINSET_1:10;
end;
end;
definition
let C58 being non  empty DTConstrStr;
attr C58 is  binary
means
:L350: (for B54 being (Symbol of C58) holds (for B55 being FinSequence holds (B54 ==> B55 implies (ex B56 , B57 being (Symbol of C58) st B55 = <* B56 , B57 *>))));
end;
registration
cluster  binary  with_terminals  with_nonterminals  with_useful_nonterminals  strict for non  empty non  empty non  empty non  empty DTConstrStr;
existence
proof
reconsider D25 = { ( 0 ) , 1 } as non  empty set;
reconsider D26 = ( 0 ) , D27 = 1 as (Element of D25) by TARSKI:def 2;
reconsider D28 = ( <* D27 *> ^ <* D27 *> ) as (Element of ( D25 * ));
reconsider D29 = { [ D26 , D28 ] } as (Relation of D25 , ( D25 * )) by RELSET_1:3;
take D30 = DTConstrStr (# D25 , D29 #);
reconsider D31 = D26 , D32 = D27 as (Symbol of D30);
thus L352:now
let C59 being (Symbol of D30);
let C60 being FinSequence;
assume L353: C59 ==> C60;
take D33 = D32;
take D34 = D32;
L354: [ C59 , C60 ] in D29 by L353 , LANG1:def 1;
L355: [ C59 , C60 ] = [ ( 0 ) , D28 ] by L354 , TARSKI:def 1;
L356: C60 = D28 by L355 , XTUPLE_0:1
.= <* 1 , 1 *> by FINSEQ_1:def 9;
thus L357: C60 = <* D33 , D34 *> by L356;
end;
L358:
now
let C61 being FinSequence;
assume L359: D32 ==> C61;
L360: [ 1 , C61 ] in D29 by L359 , LANG1:def 1;
L361: [ 1 , C61 ] = [ ( 0 ) , D28 ] by L360 , TARSKI:def 1;
thus L362: contradiction by L361 , XTUPLE_0:1;
end;
L363: D32 in { B58 where B58 is (Symbol of D30) : (not (ex B59 being FinSequence st B58 ==> B59)) } by L358;
L364: D32 in ( Terminals D30 ) by L363 , LANG1:def 2;
thus L365: ( Terminals D30 ) <> ( {} ) by L363 , LANG1:def 2;
L366: [ D31 , D28 ] in D29 by TARSKI:def 1;
L367: D31 ==> D28 by L366 , LANG1:def 1;
L368: D31 in { B60 where B60 is (Symbol of D30) : (ex B61 being FinSequence st B60 ==> B61) } by L367;
thus L369: ( NonTerminals D30 ) <> ( {} ) by L368 , LANG1:def 3;
L370: { B62 where B62 is (Symbol of D30) : (ex B63 being FinSequence st B62 ==> B63) } = ( NonTerminals D30 ) by LANG1:def 3;
thus L371:now
reconsider D35 = ( TS D30 ) as non  empty set by L364 , DTCONSTR:def 1;
let C62 being (Symbol of D30);
reconsider D36 = ( root-tree D32 ) as (Element of D35) by L364 , DTCONSTR:def 1;
reconsider D37 = ( <* D36 *> ^ <* D36 *> ) as (FinSequence of ( TS D30 ));
L372: D37 = <* ( root-tree 1 ) , ( root-tree 1 ) *> by FINSEQ_1:def 9;
L373: ( roots D37 ) = <* ( ( root-tree D32 ) . ( {} ) ) , ( ( root-tree D32 ) . ( {} ) ) *> by L372 , DTCONSTR:6;
assume L374: C62 in ( NonTerminals D30 );
L375: (ex B64 being (Symbol of D30) st (C62 = B64 & (ex B65 being FinSequence st B64 ==> B65))) by L374 , L370;
consider C63 being FinSequence such that L376: C62 ==> C63 by L375;
take D38 = D37;
L377: [ C62 , C63 ] in D29 by L376 , LANG1:def 1;
L378: [ C62 , C63 ] = [ ( 0 ) , D28 ] by L377 , TARSKI:def 1;
L379: (D28 = <* 1 , 1 *> & ( ( root-tree 1 ) . ( {} ) ) = 1) by FINSEQ_1:def 9 , TREES_4:3;
thus L380: C62 ==> ( roots D38 ) by L379 , L376 , L378 , L373 , XTUPLE_0:1;
end;
thus L381: thesis;
end;
end;
scheme BinDTConstrStrEx { F1() -> non  empty set , P1[set , set , set] } : (ex B66 being  binary  strict non  empty DTConstrStr st ((the carrier of B66) = F1() & (for B67 , B68 , B69 being (Symbol of B66) holds (B67 ==> <* B68 , B69 *> iff P1[ B67 , B68 , B69 ]))))
proof
defpred S1[ set , FinSequence ] means (P1[ $1 , ( $2 . 1 ) , ( $2 . 2 ) ] & $2 = <* ( $2 . 1 ) , ( $2 . 2 ) *>);
consider C64 being  strict non  empty DTConstrStr such that L383: (the carrier of C64) = F1() and L384: (for B70 being (Symbol of C64) holds (for B71 being (FinSequence of (the carrier of C64)) holds (B70 ==> B71 iff S1[ B70 , B71 ]))) from DTCONSTR:sch 1;
L385:
now
let C65 being (Symbol of C64);
let C66 being FinSequence;
assume L386: C65 ==> C66;
L387: [ C65 , C66 ] in (the Rules of C64) by L386 , LANG1:def 1;
L388: C66 in ( (the carrier of C64) * ) by L387 , ZFMISC_1:87;
reconsider D39 = C66 as (FinSequence of (the carrier of C64)) by L388 , FINSEQ_2:def 3;
L389: D39 = <* ( D39 . 1 ) , ( D39 . 2 ) *> by L384 , L386;
L390: ( rng D39 ) = ( rng ( <* ( D39 . 1 ) *> ^ <* ( D39 . 2 ) *> ) ) by L389 , FINSEQ_1:def 9
.= ( ( rng <* ( D39 . 1 ) *> ) \/ ( rng <* ( D39 . 2 ) *> ) ) by FINSEQ_1:31
.= ( { ( D39 . 1 ) } \/ ( rng <* ( D39 . 2 ) *> ) ) by FINSEQ_1:39
.= ( { ( D39 . 1 ) } \/ { ( D39 . 2 ) } ) by FINSEQ_1:39
.= { ( D39 . 1 ) , ( D39 . 2 ) } by ENUMSET1:1;
L391: (( D39 . 1 ) in ( rng D39 ) & ( D39 . 2 ) in ( rng D39 )) by L390 , TARSKI:def 2;
reconsider D40 = ( D39 . 1 ) , D41 = ( D39 . 2 ) as (Symbol of C64) by L391;
take D42 = D40;
take D43 = D41;
thus L392: C66 = <* D42 , D43 *> by L384 , L386;
end;
L393: C64 is  binary by L385 , L350;
L394:
now
let C67 , C68 , C69 being (Symbol of C64);
reconsider D44 = <* C68 , C69 *> as (FinSequence of (the carrier of C64));
L395: (( D44 . 1 ) = C68 & ( D44 . 2 ) = C69) by FINSEQ_1:44;
thus L396: (C67 ==> <* C68 , C69 *> iff P1[ C67 , C68 , C69 ]) by L395 , L384;
end;
thus L397: thesis by L394 , L383 , L393;
end;
theorem
L398: (for B72 being  binary  with_terminals  with_nonterminals non  empty DTConstrStr holds (for B73 being (FinSequence of ( TS B72 )) holds (for B74 being (Symbol of B72) holds (B74 ==> ( roots B73 ) implies (B74 is (NonTerminal of B72) & ( dom B73 ) = { 1 , 2 } & 1 in ( dom B73 ) & 2 in ( dom B73 ) & (ex B75 , B76 being (Element of ( TS B72 )) st (( roots B73 ) = <* ( root-label B75 ) , ( root-label B76 ) *> & B75 = ( B73 . 1 ) & B76 = ( B73 . 2 ) & ( B74 -tree B73 ) = ( B74 -tree (B75 , B76) ) & B75 in ( rng B73 ) & B76 in ( rng B73 ))))))))
proof
let C70 being  binary  with_terminals  with_nonterminals non  empty DTConstrStr;
let C71 being (FinSequence of ( TS C70 ));
let C72 being (Symbol of C70);
assume L399: C72 ==> ( roots C71 );
consider C73 , C74 being (Symbol of C70) such that L400: ( roots C71 ) = <* C73 , C74 *> by L399 , L350;
L401: C72 in { B77 where B77 is (Symbol of C70) : (ex B78 being FinSequence st B77 ==> B78) } by L399;
thus L402: C72 is (NonTerminal of C70) by L401 , LANG1:def 3;
L403: ( len <* C73 , C74 *> ) = 2 by FINSEQ_1:44;
L404: ( dom <* C73 , C74 *> ) = ( dom C71 ) by L400 , TREES_3:def 18;
thus L405: ( dom C71 ) = { 1 , 2 } by L404 , L403 , FINSEQ_1:2 , FINSEQ_1:def 3;
thus L406: (1 in ( dom C71 ) & 2 in ( dom C71 )) by L405 , TARSKI:def 2;
consider C75 being DecoratedTree such that L407: C75 = ( C71 . 1 ) and L408: ( <* C73 , C74 *> . 1 ) = ( C75 . ( {} ) ) by L406 , L400 , TREES_3:def 18;
L409: (( rng C71 ) c= ( TS C70 ) & C75 in ( rng C71 )) by L406 , L407 , FINSEQ_1:def 4 , FUNCT_1:def 3;
consider C76 being DecoratedTree such that L410: C76 = ( C71 . 2 ) and L411: ( <* C73 , C74 *> . 2 ) = ( C76 . ( {} ) ) by L400 , L406 , TREES_3:def 18;
L412: C76 in ( rng C71 ) by L406 , L410 , FUNCT_1:def 3;
reconsider D45 = C75 , D46 = C76 as (Element of ( TS C70 )) by L412 , L409;
take D45;
take D46;
L413: ( <* C73 , C74 *> . 1 ) = C73 by FINSEQ_1:44;
thus L414: ( roots C71 ) = <* ( root-label D45 ) , ( root-label D46 ) *> by L413 , L400 , L408 , L411 , FINSEQ_1:44;
L415: ( Seg ( len <* C73 , C74 *> ) ) = ( dom <* C73 , C74 *> ) by FINSEQ_1:def 3
.= ( Seg ( len C71 ) ) by L404 , FINSEQ_1:def 3;
L416: ( len C71 ) = 2 by L415 , L403 , FINSEQ_1:6;
L417: C71 = <* D45 , D46 *> by L416 , L407 , L410 , FINSEQ_1:44;
thus L418: (D45 = ( C71 . 1 ) & D46 = ( C71 . 2 ) & ( C72 -tree C71 ) = ( C72 -tree (D45 , D46) )) by L417 , L407 , L410 , TREES_4:def 6;
thus L419: thesis by L406 , L407 , L410 , FUNCT_1:def 3;
end;
scheme BinDTConstrInd { F2() ->  binary  with_terminals  with_nonterminals non  empty DTConstrStr , P2[set] } : (for B79 being (Element of ( TS F2() )) holds P2[ B79 ])
provided
L420: (for B80 being (Terminal of F2()) holds P2[ ( root-tree B80 ) ])
and
L421: (for B81 being (NonTerminal of F2()) holds (for B82 , B83 being (Element of ( TS F2() )) holds ((B81 ==> <* ( root-label B82 ) , ( root-label B83 ) *> & P2[ B82 ] & P2[ B83 ]) implies P2[ ( B81 -tree (B82 , B83) ) ])))
proof
L422: (for B84 being (Symbol of F2()) holds (for B85 being (FinSequence of ( TS F2() )) holds ((B84 ==> ( roots B85 ) & (for B86 being (DecoratedTree of (the carrier of F2())) holds (B86 in ( rng B85 ) implies P2[ B86 ]))) implies P2[ ( B84 -tree B85 ) ])))
proof
let C77 being (Symbol of F2());
let C78 being (FinSequence of ( TS F2() ));
assume that
L423: C77 ==> ( roots C78 )
and
L424: (for B87 being (DecoratedTree of (the carrier of F2())) holds (B87 in ( rng C78 ) implies P2[ B87 ]));
L425: C77 is (NonTerminal of F2()) by L423 , L398;
consider C79 , C80 being (Element of ( TS F2() )) such that L426: ( roots C78 ) = <* ( root-label C79 ) , ( root-label C80 ) *> and L427: C79 = ( C78 . 1 ) and L428: C80 = ( C78 . 2 ) and L429: ( C77 -tree C78 ) = ( C77 -tree (C79 , C80) ) and L430: (C79 in ( rng C78 ) & C80 in ( rng C78 )) by L423 , L398;
L431: (P2[ C79 ] & P2[ C80 ]) by L424 , L430;
thus L432: thesis by L431 , L421 , L423 , L425 , L426 , L429;
end;
L433: (for B88 being (Symbol of F2()) holds (B88 in ( Terminals F2() ) implies P2[ ( root-tree B88 ) ])) by L420;
L434: (for B89 being (DecoratedTree of (the carrier of F2())) holds (B89 in ( TS F2() ) implies P2[ B89 ])) from DTCONSTR:sch 7(L433 , L422);
thus L435: thesis by L434;
end;
scheme BinDTConstrIndDef { F3() ->  binary  with_terminals  with_nonterminals  with_useful_nonterminals non  empty DTConstrStr , F4() -> non  empty set , F5(set) -> (Element of F4()) , F6(set , set , set , set , set) -> (Element of F4()) } : (ex B90 being (Function of ( TS F3() ) , F4()) st ((for B91 being (Terminal of F3()) holds ( B90 . ( root-tree B91 ) ) = F5(B91)) & (for B92 being (NonTerminal of F3()) holds (for B93 , B94 being (Element of ( TS F3() )) holds (for B95 , B96 being (Symbol of F3()) holds ((B95 = ( root-label B93 ) & B96 = ( root-label B94 ) & B92 ==> <* B95 , B96 *>) implies (for B97 , B98 being (Element of F4()) holds ((B97 = ( B90 . B93 ) & B98 = ( B90 . B94 )) implies ( B90 . ( B92 -tree (B93 , B94) ) ) = F6(B92 , B95 , B96 , B97 , B98)))))))))
proof
deffunc H1((Symbol of F3()) , FinSequence , (FinSequence of F4())) = F6($1 , ( $2 . 1 ) , ( $2 . 2 ) , ( $3 . 1 ) , ( $3 . 2 ));
consider C81 being (Function of ( TS F3() ) , F4()) such that L436: (for B99 being (Symbol of F3()) holds (B99 in ( Terminals F3() ) implies ( C81 . ( root-tree B99 ) ) = F5(B99))) and L437: (for B100 being (Symbol of F3()) holds (for B101 being (FinSequence of ( TS F3() )) holds (B100 ==> ( roots B101 ) implies ( C81 . ( B100 -tree B101 ) ) = H1(B100 , ( roots B101 ) , ( C81 * B101 ))))) from DTCONSTR:sch 8;
take C81;
thus L438: (for B102 being (Terminal of F3()) holds ( C81 . ( root-tree B102 ) ) = F5(B102)) by L436;
let C82 being (NonTerminal of F3());
let C83 , C84 being (Element of ( TS F3() ));
let C85 , C86 being (Symbol of F3());
assume that
L439: C85 = ( root-label C83 )
and
L440: C86 = ( root-label C84 )
and
L441: C82 ==> <* C85 , C86 *>;
reconsider D47 = <* C85 , C86 *> as FinSequence;
reconsider D48 = <* C83 , C84 *> as (FinSequence of ( TS F3() ));
L442: ( D48 . 1 ) = C83 by FINSEQ_1:44;
let C87 , C88 being (Element of F4());
L443: ( dom D48 ) = { 1 , 2 } by FINSEQ_1:2 , FINSEQ_1:89;
reconsider D49 = <* C87 , C88 *> as (FinSequence of F4());
L444: ( dom D49 ) = { 1 , 2 } by FINSEQ_1:2 , FINSEQ_1:89;
L445: ( D48 . 2 ) = C84 by FINSEQ_1:44;
L446: ( dom C81 ) = ( TS F3() ) by FUNCT_2:def 1;
L447:
now
let C89 being set;
L448:
now
assume that
L449: C89 in ( dom D48 )
and
L450: ( D48 . C89 ) in ( dom C81 );
per cases  by L443 , L449 , TARSKI:def 2;
suppose L451: C89 = 1;

thus L452: C89 in ( dom D49 ) by L451 , L444 , TARSKI:def 2;
end;
suppose L453: C89 = 2;

thus L454: C89 in ( dom D49 ) by L453 , L444 , TARSKI:def 2;
end;
end;
L456:
now
assume L457: C89 in ( dom D49 );
per cases  by L444 , L457 , TARSKI:def 2;
suppose L458: C89 = 1;

thus L459: (C89 in ( dom D48 ) & ( D48 . C89 ) in ( dom C81 )) by L458 , L446 , L442 , L443 , TARSKI:def 2;
end;
suppose L460: C89 = 2;

thus L461: (C89 in ( dom D48 ) & ( D48 . C89 ) in ( dom C81 )) by L460 , L446 , L445 , L443 , TARSKI:def 2;
end;
end;
thus L463: (C89 in ( dom D49 ) iff (C89 in ( dom D48 ) & ( D48 . C89 ) in ( dom C81 ))) by L456 , L448;
end;
assume L464: (C87 = ( C81 . C83 ) & C88 = ( C81 . C84 ));
L465:
now
let C90 being set;
assume L466: C90 in ( dom D49 );
L467: (C90 = 1 or C90 = 2) by L466 , L444 , TARSKI:def 2;
thus L468: ( D49 . C90 ) = ( C81 . ( D48 . C90 ) ) by L467 , L464 , L442 , L445 , FINSEQ_1:44;
end;
L469: D49 = ( C81 * D48 ) by L465 , L447 , FUNCT_1:10;
L470: ( D47 . 2 ) = C86 by FINSEQ_1:44;
L471: ( D47 . 1 ) = C85 by FINSEQ_1:44;
L472:
now
let C91 being (Element of ( NAT ));
assume L473: C91 in ( dom D48 );
L474: C91 in ( Seg ( len D48 ) ) by L473 , FINSEQ_1:def 3;
L475: C91 in ( Seg 2 ) by L474 , FINSEQ_1:44;
per cases  by L475 , FINSEQ_1:2 , TARSKI:def 2;
suppose L476: C91 = 1;

thus L477: (ex B103 being DecoratedTree st (B103 = ( D48 . C91 ) & ( D47 . C91 ) = ( B103 . ( {} ) ))) by L476 , L439 , L442 , L471;
end;
suppose L478: C91 = 2;

thus L479: (ex B104 being DecoratedTree st (B104 = ( D48 . C91 ) & ( D47 . C91 ) = ( B104 . ( {} ) ))) by L478 , L440 , L445 , L470;
end;
end;
L481: ( dom D47 ) = { 1 , 2 } by FINSEQ_1:2 , FINSEQ_1:89;
L482: D47 = ( roots D48 ) by L481 , L443 , L472 , TREES_3:def 18;
L483: ( C81 . ( C82 -tree D48 ) ) = F6(C82 , ( D47 . 1 ) , ( D47 . 2 ) , ( D49 . 1 ) , ( D49 . 2 )) by L482 , L437 , L441 , L469;
L484: (( D49 . 1 ) = C87 & ( D49 . 2 ) = C88) by FINSEQ_1:44;
L485: (( D47 . 1 ) = C85 & ( D47 . 2 ) = C86) by FINSEQ_1:44;
thus L486: thesis by L485 , L483 , L484 , TREES_4:def 6;
end;
scheme BinDTConstrUniqDef { F7() ->  binary  with_terminals  with_nonterminals  with_useful_nonterminals non  empty DTConstrStr , F8() -> non  empty set , F9 , F10() -> (Function of ( TS F7() ) , F8()) , F11(set) -> (Element of F8()) , F12(set , set , set , set , set) -> (Element of F8()) } : F9() = F10()
provided
L487: ((for B105 being (Terminal of F7()) holds ( F9() . ( root-tree B105 ) ) = F11(B105)) & (for B106 being (NonTerminal of F7()) holds (for B107 , B108 being (Element of ( TS F7() )) holds (for B109 , B110 being (Symbol of F7()) holds ((B109 = ( root-label B107 ) & B110 = ( root-label B108 ) & B106 ==> <* B109 , B110 *>) implies (for B111 , B112 being (Element of F8()) holds ((B111 = ( F9() . B107 ) & B112 = ( F9() . B108 )) implies ( F9() . ( B106 -tree (B107 , B108) ) ) = F12(B106 , B109 , B110 , B111 , B112))))))))
and
L488: ((for B113 being (Terminal of F7()) holds ( F10() . ( root-tree B113 ) ) = F11(B113)) & (for B114 being (NonTerminal of F7()) holds (for B115 , B116 being (Element of ( TS F7() )) holds (for B117 , B118 being (Symbol of F7()) holds ((B117 = ( root-label B115 ) & B118 = ( root-label B116 ) & B114 ==> <* B117 , B118 *>) implies (for B119 , B120 being (Element of F8()) holds ((B119 = ( F10() . B115 ) & B120 = ( F10() . B116 )) implies ( F10() . ( B114 -tree (B115 , B116) ) ) = F12(B114 , B117 , B118 , B119 , B120))))))))
proof
deffunc H2((Symbol of F7()) , FinSequence , (FinSequence of F8())) = F12($1 , ( $2 . 1 ) , ( $2 . 2 ) , ( $3 . 1 ) , ( $3 . 2 ));
L489:
now
thus L490: (for B121 being (Symbol of F7()) holds (B121 in ( Terminals F7() ) implies ( F10() . ( root-tree B121 ) ) = F11(B121))) by L488;
let C92 being (Symbol of F7());
let C93 being (FinSequence of ( TS F7() ));
set D50 = ( roots C93 );
set D51 = ( F10() * C93 );
assume L491: C92 ==> D50;
consider C94 , C95 being (Element of ( TS F7() )) such that L492: ( roots C93 ) = <* ( root-label C94 ) , ( root-label C95 ) *> and L493: C94 = ( C93 . 1 ) and L494: C95 = ( C93 . 2 ) and L495: ( C92 -tree C93 ) = ( C92 -tree (C94 , C95) ) and L496: C94 in ( rng C93 ) and L497: C95 in ( rng C93 ) by L491 , L398;
L498: C92 is (NonTerminal of F7()) by L491 , L398;
reconsider D52 = ( F10() . C95 ) as (Element of F8());
L499: 2 in ( dom C93 ) by L491 , L398;
L500: ( D51 . 2 ) = D52 by L499 , L494 , FUNCT_1:13;
reconsider D53 = ( F10() . C94 ) as (Element of F8());
L501: 1 in ( dom C93 ) by L491 , L398;
L502: ( D51 . 1 ) = D53 by L501 , L493 , FUNCT_1:13;
L503: (( root-label C94 ) = ( D50 . 1 ) & ( root-label C95 ) = ( D50 . 2 )) by L492 , FINSEQ_1:44;
thus L504: ( F10() . ( C92 -tree C93 ) ) = H2(C92 , D50 , D51) by L503 , L488 , L491 , L492 , L495 , L498 , L502 , L500;
end;
L505:
now
thus L506: (for B122 being (Symbol of F7()) holds (B122 in ( Terminals F7() ) implies ( F9() . ( root-tree B122 ) ) = F11(B122))) by L487;
let C96 being (Symbol of F7());
let C97 being (FinSequence of ( TS F7() ));
set D54 = ( roots C97 );
set D55 = ( F9() * C97 );
assume L507: C96 ==> D54;
consider C98 , C99 being (Element of ( TS F7() )) such that L508: ( roots C97 ) = <* ( root-label C98 ) , ( root-label C99 ) *> and L509: C98 = ( C97 . 1 ) and L510: C99 = ( C97 . 2 ) and L511: ( C96 -tree C97 ) = ( C96 -tree (C98 , C99) ) and L512: C98 in ( rng C97 ) and L513: C99 in ( rng C97 ) by L507 , L398;
L514: C96 is (NonTerminal of F7()) by L507 , L398;
reconsider D56 = ( F9() . C99 ) as (Element of F8());
L515: 2 in ( dom C97 ) by L507 , L398;
L516: ( D55 . 2 ) = D56 by L515 , L510 , FUNCT_1:13;
reconsider D57 = ( F9() . C98 ) as (Element of F8());
L517: 1 in ( dom C97 ) by L507 , L398;
L518: ( D55 . 1 ) = D57 by L517 , L509 , FUNCT_1:13;
L519: (( root-label C98 ) = ( D54 . 1 ) & ( root-label C99 ) = ( D54 . 2 )) by L508 , FINSEQ_1:44;
thus L520: ( F9() . ( C96 -tree C97 ) ) = H2(C96 , D54 , D55) by L519 , L487 , L507 , L508 , L511 , L514 , L518 , L516;
end;
thus L521: thesis from DTCONSTR:sch 9(L505 , L489);
end;
definition
let C100 , C101 , C102 being non  empty set;
let C103 being (Element of C100);
let C104 being (Element of C101);
let C105 being (Element of C102);
redefine func [C103 , C104 , C105 ] -> (Element of [: C100 , C101 , C102 :]);

coherence by MCART_1:69;
end;
scheme BinDTCDefLambda { F13() ->  binary  with_terminals  with_nonterminals  with_useful_nonterminals non  empty DTConstrStr , F14 , F15() -> non  empty set , F16(set , set) -> (Element of F15()) , F17(set , set , set , set) -> (Element of F15()) } : (ex B123 being (Function of ( TS F13() ) , ( Funcs (F14() , F15()) )) st ((for B124 being (Terminal of F13()) holds (ex B125 being (Function of F14() , F15()) st (B125 = ( B123 . ( root-tree B124 ) ) & (for B126 being (Element of F14()) holds ( B125 . B126 ) = F16(B124 , B126))))) & (for B127 being (NonTerminal of F13()) holds (for B128 , B129 being (Element of ( TS F13() )) holds (for B130 , B131 being (Symbol of F13()) holds ((B130 = ( root-label B128 ) & B131 = ( root-label B129 ) & B127 ==> <* B130 , B131 *>) implies (ex B132 , B133 , B134 being (Function of F14() , F15()) st (B132 = ( B123 . ( B127 -tree (B128 , B129) ) ) & B133 = ( B123 . B128 ) & B134 = ( B123 . B129 ) & (for B135 being (Element of F14()) holds ( B132 . B135 ) = F17(B127 , B133 , B134 , B135))))))))))
proof
defpred S2[ set , set , set , set ] means (for B136 being (Element of F14()) holds (for B137 being (Function of F14() , F15()) holds (B137 = $4 implies ( B137 . B136 ) = F17($1 , $2 , $3 , B136))));
defpred S3[ set , set ] means (for B138 being (Function of F14() , F15()) holds (B138 = $2 implies (for B139 being (Element of F14()) holds ( B138 . B139 ) = F16($1 , B139))));
reconsider D58 = ( Funcs (F14() , F15()) ) as non  empty set;
L523:
now
let C106 being (Element of ( Terminals F13() ));
deffunc H3(set) = F16(C106 , $1);
consider C107 being (Function of F14() , F15()) such that L524: (for B140 being (Element of F14()) holds ( C107 . B140 ) = H3(B140)) from FUNCT_2:sch 4;
L525: (F14() = ( dom C107 ) & ( rng C107 ) c= F15()) by FUNCT_2:def 1;
reconsider D59 = C107 as (Element of D58) by L525 , FUNCT_2:def 2;
take D60 = D59;
thus L526: S3[ C106 , D60 ] by L524;
end;
consider C108 being (Function of ( Terminals F13() ) , D58) such that L527: (for B141 being (Element of ( Terminals F13() )) holds S3[ B141 , ( C108 . B141 ) ]) from FUNCT_2:sch 3(L523);
deffunc H4((Terminal of F13())) = ( C108 . $1 );
L528:
now
let C109 being (Element of ( NonTerminals F13() ));
let C110 , C111 being (Element of D58);
deffunc H5(set) = F17(C109 , C110 , C111 , $1);
consider C112 being (Function of F14() , F15()) such that L529: (for B142 being (Element of F14()) holds ( C112 . B142 ) = H5(B142)) from FUNCT_2:sch 4;
L530: (F14() = ( dom C112 ) & ( rng C112 ) c= F15()) by FUNCT_2:def 1;
reconsider D61 = C112 as (Element of D58) by L530 , FUNCT_2:def 2;
take D62 = D61;
thus L531: S2[ C109 , C110 , C111 , D62 ] by L529;
end;
consider C113 being (Function of [: ( NonTerminals F13() ) , D58 , D58 :] , D58) such that L532: (for B143 being (Element of ( NonTerminals F13() )) holds (for B144 , B145 being (Element of D58) holds S2[ B143 , B144 , B145 , ( C113 . [ B143 , B144 , B145 ] ) ])) from MULTOP_1:sch 1(L528);
deffunc H6((Element of ( NonTerminals F13() )) , set , set , (Element of D58) , (Element of D58)) = ( C113 . [ $1 , $4 , $5 ] );
consider C114 being (Function of ( TS F13() ) , D58) such that L533: ((for B146 being (Terminal of F13()) holds ( C114 . ( root-tree B146 ) ) = H4(B146)) & (for B147 being (NonTerminal of F13()) holds (for B148 , B149 being (Element of ( TS F13() )) holds (for B150 , B151 being (Symbol of F13()) holds ((B150 = ( root-label B148 ) & B151 = ( root-label B149 ) & B147 ==> <* B150 , B151 *>) implies (for B152 , B153 being (Element of D58) holds ((B152 = ( C114 . B148 ) & B153 = ( C114 . B149 )) implies ( C114 . ( B147 -tree (B148 , B149) ) ) = H6(B147 , B150 , B151 , B152 , B153)))))))) from BinDTConstrIndDef;
reconsider D63 = C114 as (Function of ( TS F13() ) , ( Funcs (F14() , F15()) ));
take D63;
thus L534:now
let C115 being (Terminal of F13());
consider C116 being Function such that L535: ( C108 . C115 ) = C116 and L536: (( dom C116 ) = F14() & ( rng C116 ) c= F15()) by FUNCT_2:def 2;
reconsider D64 = C116 as (Function of F14() , F15()) by L536 , FUNCT_2:def 1 , RELSET_1:4;
take D65 = D64;
thus L537: D65 = ( D63 . ( root-tree C115 ) ) by L533 , L535;
let C117 being (Element of F14());
thus L538: ( D65 . C117 ) = F16(C115 , C117) by L527 , L535;
end;
let C118 being (NonTerminal of F13());
let C119 , C120 being (Element of ( TS F13() ));
let C121 , C122 being (Symbol of F13());
assume L539: (C121 = ( root-label C119 ) & C122 = ( root-label C120 ) & C118 ==> <* C121 , C122 *>);
L540: (ex B154 being Function st (( C114 . C120 ) = B154 & ( dom B154 ) = F14() & ( rng B154 ) c= F15())) by FUNCT_2:def 2;
reconsider D66 = ( C114 . C120 ) as (Function of F14() , F15()) by L540 , FUNCT_2:def 1 , RELSET_1:4;
L541: (ex B155 being Function st (( C114 . C119 ) = B155 & ( dom B155 ) = F14() & ( rng B155 ) c= F15())) by FUNCT_2:def 2;
reconsider D67 = ( C114 . C119 ) as (Function of F14() , F15()) by L541 , FUNCT_2:def 1 , RELSET_1:4;
L542: ( C113 . [ C118 , ( C114 . C119 ) , ( C114 . C120 ) ] ) in D58;
consider C123 being Function such that L543: C123 = ( C113 . [ C118 , D67 , D66 ] ) and L544: (( dom C123 ) = F14() & ( rng C123 ) c= F15()) by L542 , FUNCT_2:def 2;
reconsider D68 = C123 as (Function of F14() , F15()) by L544 , FUNCT_2:def 1 , RELSET_1:4;
take D68;
take D67;
take D66;
thus L545: (D68 = ( D63 . ( C118 -tree (C119 , C120) ) ) & D67 = ( D63 . C119 ) & D66 = ( D63 . C120 )) by L533 , L539 , L543;
thus L546: thesis by L532 , L543;
end;
scheme BinDTCDefLambdaUniq { F18() ->  binary  with_terminals  with_nonterminals  with_useful_nonterminals non  empty DTConstrStr , F19 , F20() -> non  empty set , F21 , F22() -> (Function of ( TS F18() ) , ( Funcs (F19() , F20()) )) , F23(set , set) -> (Element of F20()) , F24(set , set , set , set) -> (Element of F20()) } : F21() = F22()
provided
L547: ((for B156 being (Terminal of F18()) holds (ex B157 being (Function of F19() , F20()) st (B157 = ( F21() . ( root-tree B156 ) ) & (for B158 being (Element of F19()) holds ( B157 . B158 ) = F23(B156 , B158))))) & (for B159 being (NonTerminal of F18()) holds (for B160 , B161 being (Element of ( TS F18() )) holds (for B162 , B163 being (Symbol of F18()) holds ((B162 = ( root-label B160 ) & B163 = ( root-label B161 ) & B159 ==> <* B162 , B163 *>) implies (ex B164 , B165 , B166 being (Function of F19() , F20()) st (B164 = ( F21() . ( B159 -tree (B160 , B161) ) ) & B165 = ( F21() . B160 ) & B166 = ( F21() . B161 ) & (for B167 being (Element of F19()) holds ( B164 . B167 ) = F24(B159 , B165 , B166 , B167)))))))))
and
L548: ((for B168 being (Terminal of F18()) holds (ex B169 being (Function of F19() , F20()) st (B169 = ( F22() . ( root-tree B168 ) ) & (for B170 being (Element of F19()) holds ( B169 . B170 ) = F23(B168 , B170))))) & (for B171 being (NonTerminal of F18()) holds (for B172 , B173 being (Element of ( TS F18() )) holds (for B174 , B175 being (Symbol of F18()) holds ((B174 = ( root-label B172 ) & B175 = ( root-label B173 ) & B171 ==> <* B174 , B175 *>) implies (ex B176 , B177 , B178 being (Function of F19() , F20()) st (B176 = ( F22() . ( B171 -tree (B172 , B173) ) ) & B177 = ( F22() . B172 ) & B178 = ( F22() . B173 ) & (for B179 being (Element of F19()) holds ( B176 . B179 ) = F24(B171 , B177 , B178 , B179)))))))))
proof
defpred S4[ set , set , set , set ] means (for B180 being (Element of F19()) holds (for B181 being (Function of F19() , F20()) holds (B181 = $4 implies ( B181 . B180 ) = F24($1 , $2 , $3 , B180))));
defpred S5[ set , set ] means (for B182 being (Function of F19() , F20()) holds (B182 = $2 implies (for B183 being (Element of F19()) holds ( B182 . B183 ) = F23($1 , B183))));
reconsider D69 = ( Funcs (F19() , F20()) ) as non  empty set;
reconsider D70 = F22() as (Function of ( TS F18() ) , D69);
L549:
now
let C124 being (Element of ( Terminals F18() ));
deffunc H7((Element of F19())) = F23(C124 , $1);
consider C125 being (Function of F19() , F20()) such that L550: (for B184 being (Element of F19()) holds ( C125 . B184 ) = H7(B184)) from FUNCT_2:sch 4;
L551: (F19() = ( dom C125 ) & ( rng C125 ) c= F20()) by FUNCT_2:def 1;
reconsider D71 = C125 as (Element of D69) by L551 , FUNCT_2:def 2;
take D72 = D71;
thus L552: S5[ C124 , D72 ] by L550;
end;
consider C126 being (Function of ( Terminals F18() ) , D69) such that L553: (for B185 being (Element of ( Terminals F18() )) holds S5[ B185 , ( C126 . B185 ) ]) from FUNCT_2:sch 3(L549);
deffunc H8((Terminal of F18())) = ( C126 . $1 );
L554:
now
let C127 being (Element of ( NonTerminals F18() ));
let C128 , C129 being (Element of D69);
deffunc H9((Element of F19())) = F24(C127 , C128 , C129 , $1);
consider C130 being (Function of F19() , F20()) such that L555: (for B186 being (Element of F19()) holds ( C130 . B186 ) = H9(B186)) from FUNCT_2:sch 4;
L556: (F19() = ( dom C130 ) & ( rng C130 ) c= F20()) by FUNCT_2:def 1;
reconsider D73 = C130 as (Element of D69) by L556 , FUNCT_2:def 2;
take D74 = D73;
thus L557: S4[ C127 , C128 , C129 , D74 ] by L555;
end;
consider C131 being (Function of [: ( NonTerminals F18() ) , D69 , D69 :] , D69) such that L558: (for B187 being (Element of ( NonTerminals F18() )) holds (for B188 being (Element of D69) holds (for B189 being (Element of D69) holds S4[ B187 , B188 , B189 , ( C131 . [ B187 , B188 , B189 ] ) ]))) from MULTOP_1:sch 1(L554);
deffunc H10((NonTerminal of F18()) , set , set , (Element of D69) , (Element of D69)) = ( C131 . [ $1 , $4 , $5 ] );
L559:
now
thus L560:now
let C132 being (Terminal of F18());
consider C133 being Function such that L561: ( C126 . C132 ) = C133 and L562: ( dom C133 ) = F19() and L563: ( rng C133 ) c= F20() by FUNCT_2:def 2;
reconsider D75 = C133 as (Function of F19() , F20()) by L562 , L563 , FUNCT_2:def 1 , RELSET_1:4;
consider C134 being (Function of F19() , F20()) such that L564: C134 = ( F22() . ( root-tree C132 ) ) and L565: (for B190 being (Element of F19()) holds ( C134 . B190 ) = F23(C132 , B190)) by L548;
L566:
now
thus L567: F19() = ( dom C134 ) by FUNCT_2:def 1;
thus L568: F19() = ( dom D75 ) by L562;
let C135 being set;
assume L569: C135 in F19();
reconsider D76 = C135 as (Element of F19()) by L569;
L570: ( C134 . D76 ) = F23(C132 , D76) by L565
.= ( D75 . D76 ) by L553 , L561;
thus L571: ( C134 . C135 ) = ( D75 . C135 ) by L570;
end;
thus L572: ( D70 . ( root-tree C132 ) ) = H8(C132) by L566 , L564 , L561 , FUNCT_1:2;
end;
let C136 being (NonTerminal of F18());
let C137 , C138 being (Element of ( TS F18() ));
let C139 , C140 being (Symbol of F18());
assume L573: (C139 = ( root-label C137 ) & C140 = ( root-label C138 ) & C136 ==> <* C139 , C140 *>);
consider C141 , C142 , C143 being (Function of F19() , F20()) such that L574: C141 = ( F22() . ( C136 -tree (C137 , C138) ) ) and L575: (C142 = ( F22() . C137 ) & C143 = ( F22() . C138 ) & (for B191 being (Element of F19()) holds ( C141 . B191 ) = F24(C136 , C142 , C143 , B191))) by L573 , L548;
let C144 , C145 being (Element of D69);
consider C146 being Function such that L576: C146 = ( C131 . [ C136 , C144 , C145 ] ) and L577: (( dom C146 ) = F19() & ( rng C146 ) c= F20()) by FUNCT_2:def 2;
reconsider D77 = C146 as (Function of F19() , F20()) by L577 , FUNCT_2:def 1 , RELSET_1:4;
assume L578: (C144 = ( D70 . C137 ) & C145 = ( D70 . C138 ));
L579:
now
thus L580: F19() = ( dom C141 ) by FUNCT_2:def 1;
thus L581: F19() = ( dom D77 ) by FUNCT_2:def 1;
let C147 being set;
assume L582: C147 in F19();
reconsider D78 = C147 as (Element of F19()) by L582;
L583: ( C141 . D78 ) = F24(C136 , C144 , C145 , D78) by L578 , L575
.= ( D77 . D78 ) by L558 , L576;
thus L584: ( C141 . C147 ) = ( D77 . C147 ) by L583;
end;
thus L585: ( D70 . ( C136 -tree (C137 , C138) ) ) = H10(C136 , C139 , C140 , C144 , C145) by L579 , L574 , L576 , FUNCT_1:2;
end;
reconsider D79 = F21() as (Function of ( TS F18() ) , D69);
L586:
now
thus L587:now
let C148 being (Terminal of F18());
consider C149 being Function such that L588: ( C126 . C148 ) = C149 and L589: ( dom C149 ) = F19() and L590: ( rng C149 ) c= F20() by FUNCT_2:def 2;
reconsider D80 = C149 as (Function of F19() , F20()) by L589 , L590 , FUNCT_2:def 1 , RELSET_1:4;
consider C150 being (Function of F19() , F20()) such that L591: C150 = ( F21() . ( root-tree C148 ) ) and L592: (for B192 being (Element of F19()) holds ( C150 . B192 ) = F23(C148 , B192)) by L547;
L593:
now
thus L594: F19() = ( dom C150 ) by FUNCT_2:def 1;
thus L595: F19() = ( dom D80 ) by L589;
let C151 being set;
assume L596: C151 in F19();
reconsider D81 = C151 as (Element of F19()) by L596;
L597: ( C150 . D81 ) = F23(C148 , D81) by L592
.= ( D80 . D81 ) by L553 , L588;
thus L598: ( C150 . C151 ) = ( D80 . C151 ) by L597;
end;
thus L599: ( D79 . ( root-tree C148 ) ) = H8(C148) by L593 , L591 , L588 , FUNCT_1:2;
end;
let C152 being (NonTerminal of F18());
let C153 , C154 being (Element of ( TS F18() ));
let C155 , C156 being (Symbol of F18());
assume L600: (C155 = ( root-label C153 ) & C156 = ( root-label C154 ) & C152 ==> <* C155 , C156 *>);
consider C157 , C158 , C159 being (Function of F19() , F20()) such that L601: C157 = ( F21() . ( C152 -tree (C153 , C154) ) ) and L602: (C158 = ( F21() . C153 ) & C159 = ( F21() . C154 ) & (for B193 being (Element of F19()) holds ( C157 . B193 ) = F24(C152 , C158 , C159 , B193))) by L600 , L547;
let C160 , C161 being (Element of D69);
consider C162 being Function such that L603: C162 = ( C131 . [ C152 , C160 , C161 ] ) and L604: (( dom C162 ) = F19() & ( rng C162 ) c= F20()) by FUNCT_2:def 2;
reconsider D82 = C162 as (Function of F19() , F20()) by L604 , FUNCT_2:def 1 , RELSET_1:4;
assume L605: (C160 = ( D79 . C153 ) & C161 = ( D79 . C154 ));
L606:
now
thus L607: F19() = ( dom C157 ) by FUNCT_2:def 1;
thus L608: F19() = ( dom D82 ) by FUNCT_2:def 1;
let C163 being set;
assume L609: C163 in F19();
reconsider D83 = C163 as (Element of F19()) by L609;
L610: ( C157 . D83 ) = F24(C152 , C160 , C161 , D83) by L605 , L602
.= ( D82 . D83 ) by L558 , L603;
thus L611: ( C157 . C163 ) = ( D82 . C163 ) by L610;
end;
thus L612: ( D79 . ( C152 -tree (C153 , C154) ) ) = H10(C152 , C155 , C156 , C160 , C161) by L606 , L601 , L603 , FUNCT_1:2;
end;
L613: D79 = D70 from BinDTConstrUniqDef(L586 , L559);
thus L614: thesis by L613;
end;
registration
let C164 being  binary  with_terminals  with_nonterminals non  empty DTConstrStr;
cluster  ->  binary for (Element of ( TS C164 ));
coherence
proof
defpred S6[ DecoratedTree ] means $1 is  binary;
L615:
now
let C165 being (Terminal of C164);
L616: ( dom ( root-tree C165 ) ) is  binary by TREES_4:3;
thus L617: S6[ ( root-tree C165 ) ] by L616 , L84;
end;
L618: (for B194 being (NonTerminal of C164) holds (for B195 , B196 being (Element of ( TS C164 )) holds ((B194 ==> <* ( root-label B195 ) , ( root-label B196 ) *> & S6[ B195 ] & S6[ B196 ]) implies S6[ ( B194 -tree (B195 , B196) ) ]))) by L327;
thus L619: (for B197 being (Element of ( TS C164 )) holds S6[ B197 ]) from BinDTConstrInd(L615 , L618);
end;
end;
