:: Representation Theorem for Stacks
::  by Grzegorz Bancerek
::
:: Received February 22, 2011
:: Copyright (c) 2011-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies STACKS_1, XBOOLE_0, STRUCT_0, ZFMISC_1, SUBSET_1, FUNCT_1,
      NUMBERS, NAT_1, TARSKI, ARYTM_3, RELAT_1, FINSEQ_1, FINSEQ_3, ORDINAL4,
      FUNCOP_1, PARTFUN1, CARD_1, XXREAL_0, COMPLEX1, GLIB_000, RELAT_2,
      EQREL_1, FILTER_1, BINOP_1, MCART_1, ORDERS_1, WELLORD1, ARYTM_1,
      SETFAM_1, FUNCT_2, AOFA_000, PBOOLE, FUNCT_4, MATRIX_7, REWRITE1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, SETFAM_1, RELAT_1, FUNCT_1,
      RELAT_2, RELSET_1, PARTFUN1, FUNCT_2, BINOP_1, DOMAIN_1, FUNCT_3,
      FUNCOP_1, ORDERS_1, FUNCT_4, NUMBERS, XXREAL_0, ORDINAL1, NAT_1, NAT_D,
      FINSEQ_1, FINSEQ_2, EQREL_1, FINSEQ_3, PBOOLE, FUNCT_7, STRUCT_0,
      FILTER_1, REWRITE1, ABCMIZ_1, AOFA_000;
 constructors BINOP_1, DOMAIN_1, XXREAL_0, RELSET_1, FILTER_1, FUNCT_7,
      REWRITE1, ABCMIZ_1, POLYNOM3, NAT_D;
 registrations XBOOLE_0, RELSET_1, STRUCT_0, RELAT_1, FUNCT_1, FINSEQ_1,
      PARTFUN1, FUNCT_2, NAT_1, ORDINAL1, XXREAL_0, XREAL_0, CARD_1, EQREL_1,
      SUBSET_1, REWRITE1, FUNCT_4;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;
 definitions TARSKI, XBOOLE_0, RELAT_1, FUNCT_1, RELAT_2, PARTFUN1, FUNCT_2,
      FINSEQ_1, BINOP_1, FILTER_1, REWRITE1;
 theorems TARSKI, XBOOLE_1, FINSEQ_1, FINSEQ_3, FINSEQ_5, NAT_1, NAT_D,
      FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_3, FUNCOP_1, WSIERP_1, BINOP_1,
      POLYALG1, EQREL_1, WELLORD2, RELSET_1, ORDINAL1, XREAL_1, NAT_2,
      ZFMISC_1, SETFAM_1, RELAT_1, XBOOLE_0, ORDERS_1, MATRIX_7, FUNCT_7,
      FILTER_1, FUNCT_4, REWRITE1, XXREAL_0, MSUALG_8, HILBERT2, RLVECT_3,
      FINSEQOP, FINSEQ_2, XTUPLE_0;
 schemes XBOOLE_0, RELSET_1, NAT_1, FUNCT_2, BINOP_1, RECDEF_1, ALTCAT_1,
      FUNCT_1, FINSEQ_1, FINSEQ_2;

begin
definition
let C1 being set;
let C2 , C3 being (FinSequence of C1);
redefine func C2 ^ C3 -> (Element of ( C1 * ));

coherence
proof
L1: ( C2 ^ C3 ) is (FinSequence of C1);
thus L2: thesis by L1 , FINSEQ_1:def 11;
end;
end;
definition
let C4 being set;
let C5 being Nat;
let C6 being (FinSequence of C4);
redefine func Del (C6 , C5) -> (Element of ( C4 * ));

coherence
proof
L4: (( rng ( Del (C6 , C5) ) ) c= ( rng C6 ) & ( rng C6 ) c= C4) by FINSEQ_3:106;
L5: ( rng ( Del (C6 , C5) ) ) c= C4 by L4 , XBOOLE_1:1;
L6: ( Del (C6 , C5) ) is (FinSequence of C4) by L5 , FINSEQ_1:def 4;
thus L7: thesis by L6 , FINSEQ_1:def 11;
end;
end;
theorem
L9: (for R1 being Nat holds ( Del (( {} ) , R1) ) = ( {} ))
proof
let R1 being Nat;
L10: ( dom ( Del (( {} ) , R1) ) ) c= ( dom ( {} ) ) by WSIERP_1:39;
thus L11: thesis by L10;
end;
scheme IndSeqD { F1() -> non  empty set , P1[set] } : (for B1 being (FinSequence of F1()) holds P1[ B1 ])
provided
L12: P1[ ( <*> F1() ) ]
and
L13: (for B2 being (FinSequence of F1()) holds (for B3 being (Element of F1()) holds (P1[ B2 ] implies P1[ ( <* B3 *> ^ B2 ) ])))
proof
defpred S1[ set ] means (for B4 being (FinSequence of F1()) holds (( len B4 ) = $1 implies P1[ B4 ]));
L14: (for R1 being Nat holds (S1[ R1 ] implies S1[ ( R1 + 1 ) ]))
proof
let R1 being Nat;
assume that
L15: (for B5 being (FinSequence of F1()) holds (( len B5 ) = R1 implies P1[ B5 ]));
let C7 being (FinSequence of F1());
assume L16: ( len C7 ) = ( R1 + 1 );
L17: C7 <> ( {} ) by L16;
consider C8 being (FinSequence of F1()), C9 being (Element of F1()) such that L18: C7 = ( <* C9 *> ^ C8 ) by L17 , FINSEQ_2:130;
L19: ( len C7 ) = ( ( len C8 ) + 1 ) by L18 , FINSEQ_5:8;
thus L20: thesis by L19 , L13 , L15 , L16 , L18;
end;
let C10 being (FinSequence of F1());
L21: ( len C10 ) = ( len C10 );
L22: S1[ ( 0 ) ]
proof
let C11 being (FinSequence of F1());
assume L23: ( len C11 ) = ( 0 );
L24: C11 = ( <*> F1() ) by L23;
thus L25: thesis by L24 , L12;
end;
L26: (for R1 being Nat holds S1[ R1 ]) from NAT_1:sch 2(L22 , L14);
thus L27: thesis by L26 , L21;
end;
definition
let C12 , C13 being non  empty set;
let C14 being Relation;
mode BinOp of C12 , C13 , C14
 -> (Function of [: C12 , C13 :] , C13)
means :L28: (for B6 being (Element of C12) holds (for B7 , B8 being (Element of C13) holds ([ B7 , B8 ] in C14 implies [ ( it . (B6 , B7) ) , ( it . (B6 , B8) ) ] in C14)));
existence
proof
take D1 = ( pr2 (C12 , C13) );
let C15 being (Element of C12);
let C16 , C17 being (Element of C13);
L29: ( D1 . (C15 , C16) ) = C16 by FUNCT_3:def 5;
thus L30: thesis by L29 , FUNCT_3:def 5;
end;
end;
scheme LambdaD2 { F2 , F3 , F4() -> non  empty set , F5(set , set) -> (Element of F4()) } : (ex B9 being (Function of [: F2() , F3() :] , F4()) st (for B10 being (Element of F2()) holds (for B11 being (Element of F3()) holds ( B9 . (B10 , B11) ) = F5(B10 , B11))))
proof
consider C18 being (ManySortedSet of [: F2() , F3() :]) such that L32: (for B12 being (Element of F2()) holds (for B13 being (Element of F3()) holds ( C18 . (B12 , B13) ) = F5(B12 , B13))) from ALTCAT_1:sch 2;
L33: ( dom C18 ) = [: F2() , F3() :] by PARTFUN1:def 2;
L34: ( rng C18 ) c= F4()
proof
let R4 being set;
assume L35: R4 in ( rng C18 );
consider R3 being set such that L36: (R3 in ( dom C18 ) & R4 = ( C18 . R3 )) by L35 , FUNCT_1:def 3;
consider C19 , C20 being set such that L37: (C19 in F2() & C20 in F3() & R3 = [ C19 , C20 ]) by L36 , ZFMISC_1:def 2;
L38: R4 = ( C18 . (C19 , C20) ) by L36 , L37
.= F5(C19 , C20) by L32 , L37;
thus L39: thesis by L38;
end;
reconsider D2 = C18 as (Function of [: F2() , F3() :] , F4()) by L34 , L33 , FUNCT_2:2;
take D2;
thus L40: thesis by L32;
end;
definition
let C21 , C22 being non  empty set;
let C23 being (Equivalence_Relation of C22);
let C24 being (Function of [: C21 , C22 :] , C22);
assume L41: C24 is (BinOp of C21 , C22 , C23);
func C24 /\/ C23 -> (Function of [: C21 , ( Class C23 ) :] , ( Class C23 )) means 
:L42: (for B14 , B15 , B16 being set holds ((B14 in C21 & B15 in ( Class C23 ) & B16 in B15) implies ( it . (B14 , B15) ) = ( Class (C23 , ( C24 . (B14 , B16) )) )));
existence
proof
L43:
now
let C25 being set;
assume L44: C25 in ( Class C23 );
L45: (ex B17 being set st (B17 in C22 & C25 = ( Class (C23 , B17) ))) by L44 , EQREL_1:def 3;
thus L46: C25 <> ( {} ) by L45 , EQREL_1:20;
end;
consider C26 being Function such that L47: ( dom C26 ) = ( Class C23 ) and L48: (for B18 being set holds (B18 in ( Class C23 ) implies ( C26 . B18 ) in B18)) by L43 , FUNCT_1:111;
L49: ( rng C26 ) c= C22
proof
let C27 being set;
assume L50: C27 in ( rng C26 );
consider C28 being set such that L51: C28 in ( dom C26 ) and L52: C27 = ( C26 . C28 ) by L50 , FUNCT_1:def 3;
L53: C27 in C28 by L47 , L48 , L51 , L52;
thus L54: thesis by L53 , L47 , L51;
end;
deffunc H1((Element of C22)) = ( EqClass (C23 , $1) );
consider C29 being (Function of C22 , ( Class C23 )) such that L55: (for B19 being (Element of C22) holds ( C29 . B19 ) = H1(B19)) from FUNCT_2:sch 4;
reconsider D3 = C26 as (Function of ( Class C23 ) , C22) by L47 , L49 , FUNCT_2:def 1 , RELSET_1:4;
deffunc H2((Element of C21) , (Element of ( Class C23 ))) = ( C29 . ( C24 . ($1 , ( D3 . $2 )) ) );
consider C30 being (Function of [: C21 , ( Class C23 ) :] , ( Class C23 )) such that L56: (for B20 being (Element of C21) holds (for B21 being (Element of ( Class C23 )) holds ( C30 . (B20 , B21) ) = H2(B20 , B21))) from LambdaD2;
take C30;
let C31 , C32 , C33 being set;
assume that
L57: C31 in C21
and
L58: C32 in ( Class C23 )
and
L59: C33 in C32;
reconsider D4 = C31 as (Element of C21) by L57;
reconsider D5 = C32 as (Element of ( Class C23 )) by L58;
reconsider D6 = C33 as (Element of C22) by L58 , L59;
L60: (ex B22 being set st (B22 in C22 & D5 = ( Class (C23 , B22) ))) by EQREL_1:def 3;
L61: ( D3 . D5 ) in C32 by L48;
L62: [ ( D3 . D5 ) , D6 ] in C23 by L61 , L59 , L60 , EQREL_1:22;
L63: [ ( C24 . (D4 , ( D3 . D5 )) ) , ( C24 . (D4 , D6) ) ] in C23 by L62 , L41 , L28;
L64: ( C24 . (D4 , ( D3 . D5 )) ) in ( EqClass (C23 , ( C24 . (D4 , D6) )) ) by L63 , EQREL_1:19;
L65: ( C29 . ( C24 . (D4 , ( D3 . D5 )) ) ) = ( EqClass (C23 , ( C24 . (D4 , ( D3 . D5 )) )) ) by L55;
L66: ( C30 . (D4 , D5) ) = ( C29 . ( C24 . (D4 , ( D3 . D5 )) ) ) by L56;
thus L67: thesis by L66 , L64 , L65 , EQREL_1:23;
end;
uniqueness
proof
let C34 , C35 being (Function of [: C21 , ( Class C23 ) :] , ( Class C23 ));
assume that
L68: (for B23 , B24 , B25 being set holds ((B23 in C21 & B24 in ( Class C23 ) & B25 in B24) implies ( C34 . (B23 , B24) ) = ( Class (C23 , ( C24 . (B23 , B25) )) )))
and
L69: (for B26 , B27 , B28 being set holds ((B26 in C21 & B27 in ( Class C23 ) & B28 in B27) implies ( C35 . (B26 , B27) ) = ( Class (C23 , ( C24 . (B26 , B28) )) )));
L70:
now
let C36 being (Element of C21);
let C37 being (Element of ( Class C23 ));
consider C38 being set such that L71: C38 in C22 and L72: C37 = ( Class (C23 , C38) ) by EQREL_1:def 3;
L73: ( C34 . (C36 , C37) ) = ( Class (C23 , ( C24 . (C36 , C38) )) ) by L68 , L71 , L72 , EQREL_1:20;
thus L74: ( C34 . (C36 , C37) ) = ( C35 . (C36 , C37) ) by L73 , L69 , L71 , L72 , EQREL_1:20;
end;
thus L75: thesis by L70 , BINOP_1:2;
end;
end;
definition
let C39 , C40 being non  empty set;
let C41 being (Subset of C39);
let C42 being (Subset of C40);
let C43 being (Function of C39 , C40);
let C44 being (Function of C41 , C42);
redefine func C43 +* C44 -> (Function of C39 , C40);

coherence
proof
per cases ;
suppose L77: C42 = ( {} );

L78: C44 = ( {} ) by L77;
L79: ( C43 +* ( {} ) ) = C43;
thus L80: thesis by L79 , L78;
end;
suppose L81: C42 <> ( {} );

L82: ( dom ( C43 +* C44 ) ) = ( ( dom C43 ) \/ ( dom C44 ) ) by FUNCT_4:def 1
.= ( C39 \/ ( dom C44 ) ) by FUNCT_2:def 1
.= ( C39 \/ C41 ) by L81 , FUNCT_2:def 1
.= C39 by XBOOLE_1:12;
L83: ( rng ( C43 +* C44 ) ) c= ( ( rng C43 ) \/ ( rng C44 ) ) by FUNCT_4:17;
L84: (( ( rng C43 ) \/ ( rng C44 ) ) c= ( C40 \/ C42 ) & ( C40 \/ C42 ) = C40) by XBOOLE_1:12 , XBOOLE_1:13;
thus L85: thesis by L84 , L82 , L83 , FUNCT_2:2 , XBOOLE_1:1;
end;
end;
end;
begin
definition
struct (2-sorted) StackSystem(# carrier -> set , carrier' -> set , s_empty -> (Subset of the carrier') , s_push -> (Function of [: the carrier , the carrier' :] , the carrier') , s_pop -> (Function of the carrier' , the carrier') , s_top -> (Function of the carrier' , the carrier) #);
end;
registration
let C45 being non  empty set;
let C46 being set;
let C47 being (Subset of C46);
let C48 being (Function of [: C45 , C46 :] , C46);
let C49 being (Function of C46 , C46);
let C50 being (Function of C46 , C45);
cluster StackSystem (# C45 , C46 , C47 , C48 , C49 , C50 #) -> non  empty;
coherence;
end;
registration
let C51 being set;
let C52 being non  empty set;
let C53 being (Subset of C52);
let C54 being (Function of [: C51 , C52 :] , C52);
let C55 being (Function of C52 , C52);
let C56 being (Function of C52 , C51);
cluster StackSystem (# C51 , C52 , C53 , C54 , C55 , C56 #) -> non  void;
coherence;
end;
registration
cluster non  empty non  void  strict for StackSystem;
existence
proof
set D7 = the non  empty set;
set D8 = D7;
set D9 = the (Subset of D8);
set D10 = the (Function of [: D7 , D8 :] , D8);
set D11 = the (Function of D8 , D8);
set D12 = the (Function of D8 , D7);
take StackSystem (# D7 , D8 , D9 , D10 , D11 , D12 #);
thus L91: thesis;
end;
end;
definition
let C57 being StackSystem;
mode stack of C57
 is (Element of (the carrier' of C57));
end;
definition
let C58 being StackSystem;
let C59 being (stack of C58);
pred  emp C59
means
:L94: C59 in (the s_empty of C58)
;end;
definition
let C60 being non  void StackSystem;
let C61 being (stack of C60);
func pop C61 -> (stack of C60) equals 
( (the s_pop of C60) . C61 );
coherence;
func top C61 -> (Element of C60) equals 
( (the s_top of C60) . C61 );
coherence;
end;
definition
let C62 being non  empty non  void StackSystem;
let C63 being (stack of C62);
let C64 being (Element of C62);
func push (C64 , C63) -> (stack of C62) equals 
( (the s_push of C62) . (C64 , C63) );
coherence;
end;
definition
let C65 being non  empty set;
func StandardStackSystem C65 -> non  empty non  void  strict StackSystem means 
:L98: ((the carrier of it) = C65 & (the carrier' of it) = ( C65 * ) & (for B29 being (stack of it) holds (( emp B29 iff B29 is  empty) & (for B30 being FinSequence holds (B30 = B29 implies (((not  emp B29) implies (( top B29 ) = ( B30 . 1 ) & ( pop B29 ) = ( Del (B30 , 1) ))) & ( emp B29 implies (( top B29 ) = the (Element of it) & ( pop B29 ) = ( {} ))) & (for B31 being (Element of it) holds ( push (B31 , B29) ) = ( <* B31 *> ^ B30 ))))))));
existence
proof
reconsider D13 = ( <*> C65 ) as (Element of ( C65 * )) by FINSEQ_1:def 11;
set D14 = { D13 };
deffunc H3((Element of C65) , (Element of ( C65 * ))) = ( <* $1 *> ^ $2 );
deffunc H4((Element of ( C65 * ))) = ( Del ($1 , 1) );
deffunc H5((Element of ( C65 * ))) = ( IFEQ ($1 , ( {} ) , the (Element of C65) , ( $1 /. 1 )) );
consider C66 being (Function of [: C65 , ( C65 * ) :] , ( C65 * )) such that L99: (for B32 being (Element of C65) holds (for B33 being (Element of ( C65 * )) holds ( C66 . (B32 , B33) ) = H3(B32 , B33))) from BINOP_1:sch 4;
consider C67 being (Function of ( C65 * ) , ( C65 * )) such that L100: (for B34 being (Element of ( C65 * )) holds ( C67 . B34 ) = H4(B34)) from FUNCT_2:sch 4;
consider C68 being (Function of ( C65 * ) , C65) such that L101: (for B35 being (Element of ( C65 * )) holds ( C68 . B35 ) = H5(B35)) from FUNCT_2:sch 4;
take D15 = StackSystem (# C65 , ( C65 * ) , D14 , C66 , C67 , C68 #);
thus L102: ((the carrier of D15) = C65 & (the carrier' of D15) = ( C65 * ));
let C69 being (stack of D15);
L103: ( emp C69 iff C69 in D14) by L94;
thus L104: ( emp C69 iff C69 is  empty) by L103 , TARSKI:def 1;
let C70 being FinSequence;
assume L105: C70 = C69;
reconsider D16 = C70 as (Element of ( C65 * )) by L105;
thus L106:now
assume L107: (not  emp C69);
L108: 1 in ( dom D16 ) by L107 , L104 , L105 , FINSEQ_5:6;
thus L109: ( top C69 ) = ( IFEQ (C69 , ( {} ) , the (Element of C65) , ( D16 /. 1 )) ) by L101 , L105
.= ( D16 /. 1 ) by L104 , L107 , FUNCOP_1:def 8
.= ( C70 . 1 ) by L108 , PARTFUN1:def 6;
thus L110: ( pop C69 ) = ( Del (C70 , 1) ) by L105 , L100;
end;
thus L111:now
assume L112:  emp C69;
thus L113: ( top C69 ) = ( IFEQ (C69 , ( {} ) , the (Element of C65) , ( D16 /. 1 )) ) by L101 , L105
.= the (Element of D15) by L104 , L112 , FUNCOP_1:def 8;
thus L114: ( pop C69 ) = ( Del (C70 , 1) ) by L105 , L100
.= ( {} ) by L104 , L105 , L112 , L9;
end;
let C71 being (Element of D15);
thus L115: ( push (C71 , C69) ) = ( <* C71 *> ^ C70 ) by L99 , L105;
end;
uniqueness
proof
let C72 , C73 being non  empty non  void  strict StackSystem;
assume that
L116: (the carrier of C72) = C65
and
L117: (the carrier' of C72) = ( C65 * )
and
L118: (for B36 being (stack of C72) holds (( emp B36 iff B36 is  empty) & (for B37 being FinSequence holds (B37 = B36 implies (((not  emp B36) implies (( top B36 ) = ( B37 . 1 ) & ( pop B36 ) = ( Del (B37 , 1) ))) & ( emp B36 implies (( top B36 ) = the (Element of C72) & ( pop B36 ) = ( {} ))) & (for B38 being (Element of C72) holds ( push (B38 , B36) ) = ( <* B38 *> ^ B37 )))))))
and
L119: (the carrier of C73) = C65
and
L120: (the carrier' of C73) = ( C65 * )
and
L121: (for B39 being (stack of C73) holds (( emp B39 iff B39 is  empty) & (for B40 being FinSequence holds (B40 = B39 implies (((not  emp B39) implies (( top B39 ) = ( B40 . 1 ) & ( pop B39 ) = ( Del (B40 , 1) ))) & ( emp B39 implies (( top B39 ) = the (Element of C73) & ( pop B39 ) = ( {} ))) & (for B41 being (Element of C73) holds ( push (B41 , B39) ) = ( <* B41 *> ^ B40 )))))));
L122:
now
let C74 being (Element of C65);
reconsider D17 = C74 as (Element of C72) by L116;
reconsider D18 = C74 as (Element of C73) by L119;
let C75 being (Element of ( C65 * ));
reconsider D19 = C75 as (stack of C72) by L117;
reconsider D20 = C75 as (stack of C73) by L120;
thus L123: ( (the s_push of C72) . (C74 , C75) ) = ( push (D17 , D19) )
.= ( <* C74 *> ^ C75 ) by L118
.= ( push (D18 , D20) ) by L121
.= ( (the s_push of C73) . (C74 , C75) );
end;
L124: (the s_push of C72) = (the s_push of C73) by L122 , L116 , L117 , L119 , L120 , BINOP_1:2;
L125:
now
let C76 being (Element of ( C65 * ));
reconsider D21 = C76 as (stack of C72) by L117;
reconsider D22 = C76 as (stack of C73) by L120;
per cases ;
suppose L126: (not  emp D21);

L127: D21 is non  empty by L126 , L118;
L128: (not  emp D22) by L127 , L121;
thus L129: ( (the s_pop of C72) . C76 ) = ( pop D21 )
.= ( Del (C76 , 1) ) by L126 , L118
.= ( pop D22 ) by L128 , L121
.= ( (the s_pop of C73) . C76 );
end;
suppose L130:  emp D21;

L131: D21 is  empty by L130 , L118;
L132:  emp D22 by L131 , L121;
thus L133: ( (the s_pop of C72) . C76 ) = ( pop D21 )
.= ( {} ) by L130 , L118
.= ( pop D22 ) by L132 , L121
.= ( (the s_pop of C73) . C76 );
end;
end;
L135: (the s_pop of C72) = (the s_pop of C73) by L125 , L117 , L120 , FUNCT_2:63;
L136:
now
let C77 being (Element of ( C65 * ));
reconsider D23 = C77 as (stack of C72) by L117;
reconsider D24 = C77 as (stack of C73) by L120;
per cases ;
suppose L137: (not  emp D23);

L138: D23 is non  empty by L137 , L118;
L139: (not  emp D24) by L138 , L121;
thus L140: ( (the s_top of C72) . C77 ) = ( top D23 )
.= ( C77 . 1 ) by L137 , L118
.= ( top D24 ) by L139 , L121
.= ( (the s_top of C73) . C77 );
end;
suppose L141:  emp D23;

L142: D23 is  empty by L141 , L118;
L143:  emp D24 by L142 , L121;
thus L144: ( (the s_top of C72) . C77 ) = ( top D23 )
.= the (Element of C65) by L116 , L141 , L118
.= ( top D24 ) by L119 , L143 , L121
.= ( (the s_top of C73) . C77 );
end;
end;
L146: (the s_empty of C72) = (the s_empty of C73)
proof
thus L147: (the s_empty of C72) c= (the s_empty of C73)
proof
let C78 being set;
assume L148: C78 in (the s_empty of C72);
reconsider D25 = C78 as (stack of C72) by L148;
reconsider D26 = D25 as (stack of C73) by L117 , L120;
L149:  emp D25 by L148 , L94;
L150: D25 is  empty by L149 , L118;
L151:  emp D26 by L150 , L121;
thus L152: thesis by L151 , L94;
end;

let C79 being set;
assume L153: C79 in (the s_empty of C73);
reconsider D27 = C79 as (stack of C73) by L153;
reconsider D28 = D27 as (stack of C72) by L117 , L120;
L154:  emp D27 by L153 , L94;
L155: D27 is  empty by L154 , L121;
L156:  emp D28 by L155 , L118;
thus L157: thesis by L156 , L94;
end;
thus L158: thesis by L146 , L116 , L117 , L119 , L120 , L124 , L135 , L136 , FUNCT_2:63;
end;
end;
registration
let R5 being non  empty set;
cluster (the carrier' of ( StandardStackSystem R5 )) ->  functional;
coherence
proof
L160: (the carrier' of ( StandardStackSystem R5 )) = ( R5 * ) by L98;
thus L161: thesis by L160;
end;
end;
registration
let R5 being non  empty set;
cluster  ->  FinSequence-like for (stack of ( StandardStackSystem R5 ));
coherence
proof
L163: (the carrier' of ( StandardStackSystem R5 )) = ( R5 * ) by L98;
thus L164: thesis by L163;
end;
end;
::$H-
definition
let R8 being non  empty non  void StackSystem;
attr R8 is  pop-finite
means
:L166: (for B42 being (Function of ( NAT ) , (the carrier' of R8)) holds (ex B43 being Nat st (ex R9 being (stack of R8) st (( B42 . B43 ) = R9 & ((not  emp R9) implies ( B42 . ( B43 + 1 ) ) <> ( pop R9 ))))));
attr R8 is  push-pop
means
:L167: (for R9 being (stack of R8) holds ((not  emp R9) implies R9 = ( push (( top R9 ) , ( pop R9 )) )));
attr R8 is  top-push
means
:L168: (for R9 being (stack of R8) holds (for R12 being (Element of R8) holds R12 = ( top ( push (R12 , R9) ) )));
attr R8 is  pop-push
means
:L169: (for R9 being (stack of R8) holds (for R12 being (Element of R8) holds R9 = ( pop ( push (R12 , R9) ) )));
attr R8 is  push-non-empty
means
:L170: (for R9 being (stack of R8) holds (for R12 being (Element of R8) holds (not  emp ( push (R12 , R9) ))));
end;
registration
let C80 being non  empty set;
cluster ( StandardStackSystem C80 ) ->  pop-finite;
coherence
proof
set D29 = ( StandardStackSystem C80 );
let C81 being (Function of ( NAT ) , (the carrier' of D29));
assume that
L172: (for B44 being Nat holds (for B45 being (stack of D29) holds (( C81 . B44 ) = B45 implies ((not  emp B45) & ( C81 . ( B44 + 1 ) ) = ( pop B45 )))));
reconsider D30 = ( C81 . 1 ) as (Element of ( C80 * )) by L98;
defpred S2[ Nat ] means (ex R1 being Nat st (ex B46 being (Element of ( C80 * )) st (B46 = ( C81 . R1 ) & $1 = ( len B46 ))));
L173: (ex B47 being Nat st S2[ B47 ])
proof
take D31 = ( len D30 );
take D32 = 1;
take D30;
thus L174: thesis;
end;
L175: (for B48 being Nat holds ((B48 <> ( 0 ) & S2[ B48 ]) implies (ex B49 being Nat st (B49 < B48 & S2[ B49 ]))))
proof
let C82 being Nat;
assume L176: C82 <> ( 0 );
consider C83 being Nat such that L177: C82 = ( C83 + 1 ) by L176 , NAT_1:6;
given C84 being Nat , C85 being (Element of ( C80 * )) such that
L178: (C85 = ( C81 . C84 ) & C82 = ( len C85 ));

reconsider D33 = C85 as (stack of D29) by L178;
reconsider D34 = ( pop D33 ) as (Element of ( C80 * )) by L98;
take D35 = ( len D34 );
L179: D33 is non  empty by L176 , L178;
L180: (not  emp D33) by L179 , L98;
L181: (( C81 . ( C84 + 1 ) ) = ( pop D33 ) & D34 = ( Del (C85 , 1) )) by L180 , L172 , L178 , L98;
L182: 1 in ( dom C85 ) by L179 , FINSEQ_5:6;
L183: C83 = D35 by L182 , L177 , L178 , L181 , FINSEQ_3:109;
thus L184: thesis by L183 , L177 , L181 , NAT_1:13;
end;
L185: S2[ ( 0 ) ] from NAT_1:sch 7(L173 , L175);
consider C86 being Nat, C87 being (Element of ( C80 * )) such that L186: (C87 = ( C81 . C86 ) & ( 0 ) = ( len C87 )) by L185;
reconsider D36 = C87 as (stack of D29) by L186;
L187: (C87 is  empty & (not  emp D36)) by L172 , L186;
thus L188: thesis by L187 , L98;
end;
cluster ( StandardStackSystem C80 ) ->  push-pop;
coherence
proof
set D37 = ( StandardStackSystem C80 );
let C88 being (stack of D37);
reconsider D38 = C88 as (Element of ( C80 * )) by L98;
assume L189: (not  emp C88);
L190: C88 is non  empty by L189 , L98;
L191: D38 = ( <* ( D38 . 1 ) *> ^ ( Del (D38 , 1) ) ) by L190 , POLYALG1:4;
reconsider D39 = ( Del (D38 , 1) ) as (stack of D37) by L98;
L192: 1 in ( dom D38 ) by L190 , FINSEQ_5:6;
L193: ( D38 . 1 ) in C80 by L192 , FUNCT_1:102;
reconsider D40 = ( D38 . 1 ) as (Element of D37) by L193 , L98;
thus L194: C88 = ( push (D40 , D39) ) by L191 , L98
.= ( push (( top C88 ) , D39) ) by L189 , L98
.= ( push (( top C88 ) , ( pop C88 )) ) by L189 , L98;
end;
cluster ( StandardStackSystem C80 ) ->  top-push;
coherence
proof
set D41 = ( StandardStackSystem C80 );
let C89 being (stack of D41);
let C90 being (Element of D41);
reconsider D42 = C89 as (Element of ( C80 * )) by L98;
reconsider D43 = ( push (C90 , C89) ) as (Element of ( C80 * )) by L98;
L195: D43 = ( <* C90 *> ^ D42 ) by L98;
L196: (not  emp ( push (C90 , C89) )) by L195 , L98;
thus L197: C90 = ( D43 . 1 ) by L195 , FINSEQ_1:41
.= ( top ( push (C90 , C89) ) ) by L196 , L98;
end;
cluster ( StandardStackSystem C80 ) ->  pop-push;
coherence
proof
set D44 = ( StandardStackSystem C80 );
let C91 being (stack of D44);
let C92 being (Element of D44);
reconsider D45 = C91 as (Element of ( C80 * )) by L98;
reconsider D46 = ( push (C92 , C91) ) as (Element of ( C80 * )) by L98;
L198: D46 = ( <* C92 *> ^ D45 ) by L98;
L199: (not  emp ( push (C92 , C91) )) by L198 , L98;
thus L200: C91 = ( Del (( <* C92 *> ^ D45 ) , 1) ) by WSIERP_1:40
.= ( pop ( push (C92 , C91) ) ) by L198 , L199 , L98;
end;
cluster ( StandardStackSystem C80 ) ->  push-non-empty;
coherence
proof
set D47 = ( StandardStackSystem C80 );
let C93 being (stack of D47);
let C94 being (Element of D47);
reconsider D48 = C93 as (Element of ( C80 * )) by L98;
L201: ( push (C94 , C93) ) = ( <* C94 *> ^ D48 ) by L98;
thus L202: (not  emp ( push (C94 , C93) )) by L201 , L98;
end;
end;
registration
cluster  pop-finite  push-pop  top-push  pop-push  push-non-empty  strict for non  empty non  void non  empty non  void non  empty non  void non  empty non  void StackSystem;
existence
proof
take ( StandardStackSystem the non  empty set );
thus L204: thesis;
end;
end;
definition
mode StackAlgebra
 is  pop-finite  push-pop  top-push  pop-push  push-non-empty non  empty non  void StackSystem;
end;
theorem
L207: (for B50 being non  empty non  void StackSystem holds (B50 is  pop-finite implies (ex B51 being (stack of B50) st  emp B51)))
proof
let C95 being non  empty non  void StackSystem;
assume that
L208: C95 is  pop-finite;
set D49 = the (stack of C95);
defpred S3[ set , (stack of C95) , (stack of C95) ] means $3 = ( pop $2 );
L209: (for B52 being (Element of ( NAT )) holds (for B53 being (stack of C95) holds (ex B54 being (stack of C95) st S3[ B52 , B53 , B54 ])));
consider C96 being (Function of ( NAT ) , (the carrier' of C95)) such that L210: (( C96 . ( 0 ) ) = D49 & (for B55 being (Element of ( NAT )) holds S3[ B55 , ( C96 . B55 ) , ( C96 . ( B55 + 1 ) ) ])) from RECDEF_1:sch 2(L209);
consider C97 being Nat, C98 being (stack of C95) such that L211: (( C96 . C97 ) = C98 & ((not  emp C98) implies ( C96 . ( C97 + 1 ) ) <> ( pop C98 ))) by L208 , L166;
take C98;
L212: C97 is (Element of ( NAT )) by ORDINAL1:def 12;
thus L213: thesis by L212 , L210 , L211;
end;
registration
let C99 being  pop-finite non  empty non  void StackSystem;
cluster (the s_empty of C99) -> non  empty;
coherence
proof
L214: (ex B56 being (stack of C99) st  emp B56) by L207;
thus L215: thesis by L214 , L94;
end;
end;
theorem
L217: (for R8 being non  empty non  void StackSystem holds (for R10 being (stack of R8) holds (for R11 being (stack of R8) holds (for R13 being (Element of R8) holds (for R14 being (Element of R8) holds ((R8 is  top-push  pop-push & ( push (R13 , R10) ) = ( push (R14 , R11) )) implies (R13 = R14 & R10 = R11)))))))
proof
let R8 being non  empty non  void StackSystem;
let R10 being (stack of R8);
let R11 being (stack of R8);
let R13 being (Element of R8);
let R14 being (Element of R8);
assume L218: R8 is  top-push;
L219: (R13 = ( top ( push (R13 , R10) ) ) & R14 = ( top ( push (R14 , R11) ) )) by L218 , L168;
assume L220: R8 is  pop-push;
L221: (R10 = ( pop ( push (R13 , R10) ) ) & R11 = ( pop ( push (R14 , R11) ) )) by L220 , L169;
thus L222: thesis by L221 , L219;
end;
theorem
L223: (for R8 being non  empty non  void StackSystem holds (for R10 being (stack of R8) holds (for R11 being (stack of R8) holds ((R8 is  push-pop & (not  emp R10) & (not  emp R11) & ( pop R10 ) = ( pop R11 ) & ( top R10 ) = ( top R11 )) implies R10 = R11))))
proof
let R8 being non  empty non  void StackSystem;
let R10 being (stack of R8);
let R11 being (stack of R8);
assume L224: R8 is  push-pop;
assume L225: (not  emp R10);
L226: R10 = ( push (( top R10 ) , ( pop R10 )) ) by L225 , L224 , L167;
thus L227: thesis by L226 , L224 , L167;
end;
begin
scheme INDsch { F6() -> StackAlgebra , F7() -> (stack of F6()) , P2[set] } : P2[ F7() ]
provided
L228: (for B57 being (stack of F6()) holds ( emp B57 implies P2[ B57 ]))
and
L229: (for B58 being (stack of F6()) holds (for B59 being (Element of F6()) holds (P2[ B58 ] implies P2[ ( push (B59 , B58) ) ])))
proof
defpred S4[ set , (stack of F6()) , (stack of F6()) ] means $3 = ( pop $2 );
L230: (for B60 being (Element of ( NAT )) holds (for B61 being (stack of F6()) holds (ex B62 being (stack of F6()) st S4[ B60 , B61 , B62 ])));
consider C100 being (Function of ( NAT ) , (the carrier' of F6())) such that L231: (( C100 . ( 0 ) ) = F7() & (for B63 being (Element of ( NAT )) holds S4[ B63 , ( C100 . B63 ) , ( C100 . ( B63 + 1 ) ) ])) from RECDEF_1:sch 2(L230);
consider C101 being Nat, C102 being (stack of F6()) such that L232: (( C100 . C101 ) = C102 & ((not  emp C102) implies ( C100 . ( C101 + 1 ) ) <> ( pop C102 ))) by L166;
defpred S5[ Nat ] means P2[ ( C100 . ( C101 -' $1 ) ) ];
L233: ( C101 -' ( 0 ) ) = C101 by NAT_D:40;
L234: S5[ ( 0 ) ] by L233 , L232 , L231 , L228;
L235:
now
let C103 being Nat;
assume L236: S5[ C103 ];
L237: ( C101 -' ( C103 + 1 ) ) = ( ( C101 -' C103 ) -' 1 ) by NAT_2:30;
per cases ;
suppose L238: ( C101 -' C103 ) >= 1;

L239: ( ( C101 -' ( C103 + 1 ) ) + 1 ) = ( C101 -' C103 ) by L238 , L237 , XREAL_1:235;
L240: ( C100 . ( C101 -' C103 ) ) = ( pop ( C100 . ( C101 -' ( C103 + 1 ) ) ) ) by L239 , L231;
L241: ((not  emp ( C100 . ( C101 -' ( C103 + 1 ) ) )) implies ( C100 . ( C101 -' ( C103 + 1 ) ) ) = ( push (( top ( C100 . ( C101 -' ( C103 + 1 ) ) ) ) , ( C100 . ( C101 -' C103 ) )) )) by L240 , L167;
thus L242: S5[ ( C103 + 1 ) ] by L241 , L228 , L229 , L236;
end;
suppose L243: ( C101 -' C103 ) < ( ( 0 ) + 1 );

L244: ( C101 -' C103 ) <= ( 0 ) by L243 , NAT_1:13;
L245: ( C101 -' C103 ) = ( 0 ) by L243 , NAT_1:13;
L246: ( C101 -' ( C103 + 1 ) ) = ( ( 0 ) -' 1 ) by L245 , NAT_2:30
.= ( 0 ) by NAT_2:8;
thus L247: S5[ ( C103 + 1 ) ] by L246 , L236 , L244;
end;
end;
L249: (for B64 being Nat holds S5[ B64 ]) from NAT_1:sch 2(L234 , L235);
L250: S5[ C101 ] by L249;
thus L251: thesis by L250 , L231 , XREAL_1:232;
end;
scheme EXsch { F8() -> StackAlgebra , F9() -> (stack of F8()) , F10() -> non  empty set , F11() -> (Element of F10()) , F12(set , set) -> (Element of F10()) } : (ex B65 being (Element of F10()) st (ex B66 being (Function of (the carrier' of F8()) , F10()) st (B65 = ( B66 . F9() ) & (for B67 being (stack of F8()) holds ( emp B67 implies ( B66 . B67 ) = F11())) & (for B68 being (stack of F8()) holds (for B69 being (Element of F8()) holds ( B66 . ( push (B69 , B68) ) ) = F12(B69 , ( B66 . B68 )))))))
proof
defpred S6[ set ] means ((for B70 being (stack of F8()) holds ( emp B70 implies [ B70 , F11() ] in $1)) & (for B71 being (stack of F8()) holds (for B72 being (Element of F8()) holds (for B73 being (Element of F10()) holds ([ B71 , B73 ] in $1 implies [ ( push (B72 , B71) ) , F12(B72 , B73) ] in $1)))));
consider C104 being set such that L252: (for R3 being set holds (R3 in C104 iff (R3 in ( bool [: (the carrier' of F8()) , F10() :] ) & S6[ R3 ]))) from XBOOLE_0:sch 1;
L253: (S6[ [: (the carrier' of F8()) , F10() :] ] & [: (the carrier' of F8()) , F10() :] in ( bool [: (the carrier' of F8()) , F10() :] )) by ZFMISC_1:def 1;
L254: [: (the carrier' of F8()) , F10() :] in C104 by L253 , L252;
reconsider D50 = C104 as non  empty set by L252 , L253;
set D51 = ( meet D50 );
reconsider D52 = D51 as (Subset of [: (the carrier' of F8()) , F10() :]) by L254 , SETFAM_1:3;
defpred S7[ (stack of F8()) ] means (for B74 , B75 being set holds (([ $1 , B74 ] in D52 & [ $1 , B75 ] in D52) implies B74 = B75));
L255: S6[ D52 ]
proof
thus L256:now
let C105 being (stack of F8());
assume L257:  emp C105;
L258: (for B76 being set holds (B76 in D50 implies [ C105 , F11() ] in B76)) by L257 , L252;
thus L259: [ C105 , F11() ] in D52 by L258 , SETFAM_1:def 1;
end;
let C106 being (stack of F8());
let C107 being (Element of F8());
let C108 being (Element of F10());
assume L260: [ C106 , C108 ] in D52;
L261:
now
let C109 being set;
assume L262: C109 in D50;
L263: (S6[ C109 ] & [ C106 , C108 ] in C109) by L262 , L260 , L252 , SETFAM_1:def 1;
thus L264: [ ( push (C107 , C106) ) , F12(C107 , C108) ] in C109 by L263;
end;
thus L265: [ ( push (C107 , C106) ) , F12(C107 , C108) ] in D52 by L261 , SETFAM_1:def 1;
end;
defpred S8[ (stack of F8()) ] means (ex B77 being set st [ $1 , B77 ] in D52);
L266: (for B78 being (stack of F8()) holds ( emp B78 implies S8[ B78 ]))
proof
let C110 being (stack of F8());
assume L267:  emp C110;
take D53 = F11();
L268: (for B79 being set holds (B79 in D50 implies [ C110 , F11() ] in B79)) by L267 , L252;
thus L269: thesis by L268 , SETFAM_1:def 1;
end;
L270: (for B80 being (stack of F8()) holds (for B81 being (Element of F8()) holds (S8[ B80 ] implies S8[ ( push (B81 , B80) ) ])))
proof
let C111 being (stack of F8());
let C112 being (Element of F8());
given C113 being set such that
L271: [ C111 , C113 ] in D52;

reconsider D54 = C113 as (Element of F10()) by L271 , ZFMISC_1:87;
take D55 = F12(C112 , D54);
L272:
now
let C114 being set;
assume L273: C114 in D50;
L274: [ C111 , D54 ] in C114 by L273 , L271 , SETFAM_1:def 1;
thus L275: [ ( push (C112 , C111) ) , D55 ] in C114 by L274 , L273 , L252;
end;
thus L276: thesis by L272 , SETFAM_1:def 1;
end;
L277: (for B82 being (stack of F8()) holds ( emp B82 implies S7[ B82 ]))
proof
let C115 being (stack of F8());
assume L278:  emp C115;
let C116 , C117 being set;
assume L279: ([ C115 , C116 ] in D52 & [ C115 , C117 ] in D52);
set D56 = ( D52 \ { [ C115 , C116 ] } );
set D57 = ( D52 \ { [ C115 , C117 ] } );
L280:
now
assume L281: C116 <> F11();
L282: S6[ D56 ]
proof
thus L283:now
let C118 being (stack of F8());
assume L284:  emp C118;
L285: [ C118 , F11() ] in D52 by L284 , L255;
L286: [ C115 , C116 ] <> [ C118 , F11() ] by L281 , XTUPLE_0:1;
L287: [ C118 , F11() ] nin { [ C115 , C116 ] } by L286 , TARSKI:def 1;
thus L288: [ C118 , F11() ] in D56 by L287 , L285 , XBOOLE_0:def 5;
end;
let C119 being (stack of F8());
let C120 being (Element of F8());
let C121 being (Element of F10());
assume L289: [ C119 , C121 ] in D56;
L290: [ C119 , C121 ] in D52 by L289 , XBOOLE_0:def 5;
L291: [ ( push (C120 , C119) ) , F12(C120 , C121) ] in D52 by L290 , L255;
L292: ( push (C120 , C119) ) <> C115 by L278 , L170;
L293: [ C115 , C116 ] <> [ ( push (C120 , C119) ) , F12(C120 , C121) ] by L292 , XTUPLE_0:1;
L294: [ ( push (C120 , C119) ) , F12(C120 , C121) ] nin { [ C115 , C116 ] } by L293 , TARSKI:def 1;
thus L295: [ ( push (C120 , C119) ) , F12(C120 , C121) ] in D56 by L294 , L291 , XBOOLE_0:def 5;
end;
L296: D56 in D50 by L282 , L252;
L297: D52 c= D56 by L296 , SETFAM_1:3;
L298: ([ C115 , C116 ] in D56 & [ C115 , C116 ] in { [ C115 , C116 ] }) by L297 , L279 , TARSKI:def 1;
thus L299: contradiction by L298 , XBOOLE_0:def 5;
end;
L300:
now
assume L301: C117 <> F11();
L302: S6[ D57 ]
proof
thus L303:now
let C122 being (stack of F8());
assume L304:  emp C122;
L305: [ C122 , F11() ] in D52 by L304 , L255;
L306: [ C115 , C117 ] <> [ C122 , F11() ] by L301 , XTUPLE_0:1;
L307: [ C122 , F11() ] nin { [ C115 , C117 ] } by L306 , TARSKI:def 1;
thus L308: [ C122 , F11() ] in D57 by L307 , L305 , XBOOLE_0:def 5;
end;
let C123 being (stack of F8());
let C124 being (Element of F8());
let C125 being (Element of F10());
assume L309: [ C123 , C125 ] in D57;
L310: [ C123 , C125 ] in D52 by L309 , XBOOLE_0:def 5;
L311: [ ( push (C124 , C123) ) , F12(C124 , C125) ] in D52 by L310 , L255;
L312: ( push (C124 , C123) ) <> C115 by L278 , L170;
L313: [ C115 , C117 ] <> [ ( push (C124 , C123) ) , F12(C124 , C125) ] by L312 , XTUPLE_0:1;
L314: [ ( push (C124 , C123) ) , F12(C124 , C125) ] nin { [ C115 , C117 ] } by L313 , TARSKI:def 1;
thus L315: [ ( push (C124 , C123) ) , F12(C124 , C125) ] in D57 by L314 , L311 , XBOOLE_0:def 5;
end;
L316: D57 in D50 by L302 , L252;
L317: D52 c= D57 by L316 , SETFAM_1:3;
L318: ([ C115 , C117 ] in D57 & [ C115 , C117 ] in { [ C115 , C117 ] }) by L317 , L279 , TARSKI:def 1;
thus L319: contradiction by L318 , XBOOLE_0:def 5;
end;
thus L320: C116 = C117 by L300 , L280;
end;
L321: (for B83 being (stack of F8()) holds (for B84 being (Element of F8()) holds (S7[ B83 ] implies S7[ ( push (B84 , B83) ) ])))
proof
let C126 being (stack of F8());
let C127 being (Element of F8());
assume L322: S7[ C126 ];
let C128 , C129 being set;
assume L323: ([ ( push (C127 , C126) ) , C128 ] in D52 & [ ( push (C127 , C126) ) , C129 ] in D52);
L324: S8[ C126 ] from INDsch(L266 , L270);
consider C130 being set such that L325: [ C126 , C130 ] in D52 by L324;
reconsider D58 = C130 as (Element of F10()) by L325 , ZFMISC_1:87;
set D59 = ( D52 \ { [ ( push (C127 , C126) ) , C128 ] } );
set D60 = ( D52 \ { [ ( push (C127 , C126) ) , C129 ] } );
L326:
now
assume L327: C128 <> F12(C127 , D58);
L328: S6[ D59 ]
proof
thus L329:now
let C131 being (stack of F8());
assume L330:  emp C131;
L331: [ C131 , F11() ] in D52 by L330 , L255;
L332: (not  emp ( push (C127 , C126) )) by L170;
L333: [ ( push (C127 , C126) ) , C128 ] <> [ C131 , F11() ] by L332 , L330 , XTUPLE_0:1;
L334: [ C131 , F11() ] nin { [ ( push (C127 , C126) ) , C128 ] } by L333 , TARSKI:def 1;
thus L335: [ C131 , F11() ] in D59 by L334 , L331 , XBOOLE_0:def 5;
end;
let C132 being (stack of F8());
let C133 being (Element of F8());
let C134 being (Element of F10());
assume L336: [ C132 , C134 ] in D59;
L337: [ C132 , C134 ] in D52 by L336 , XBOOLE_0:def 5;
L338: [ ( push (C133 , C132) ) , F12(C133 , C134) ] in D52 by L337 , L255;
L339:
now
assume L340: [ ( push (C127 , C126) ) , C128 ] = [ ( push (C133 , C132) ) , F12(C133 , C134) ];
L341: (( push (C127 , C126) ) = ( push (C133 , C132) ) & C128 = F12(C133 , C134)) by L340 , XTUPLE_0:1;
L342: (C127 = C133 & C126 = C132) by L341 , L217;
thus L343: contradiction by L342 , L322 , L325 , L337 , L327 , L341;
end;
L344: [ ( push (C133 , C132) ) , F12(C133 , C134) ] nin { [ ( push (C127 , C126) ) , C128 ] } by L339 , TARSKI:def 1;
thus L345: [ ( push (C133 , C132) ) , F12(C133 , C134) ] in D59 by L344 , L338 , XBOOLE_0:def 5;
end;
L346: D59 in D50 by L328 , L252;
L347: D52 c= D59 by L346 , SETFAM_1:3;
L348: ([ ( push (C127 , C126) ) , C128 ] in D59 & [ ( push (C127 , C126) ) , C128 ] in { [ ( push (C127 , C126) ) , C128 ] }) by L347 , L323 , TARSKI:def 1;
thus L349: contradiction by L348 , XBOOLE_0:def 5;
end;
L350:
now
assume L351: C129 <> F12(C127 , D58);
L352: S6[ D60 ]
proof
thus L353:now
let C135 being (stack of F8());
assume L354:  emp C135;
L355: [ C135 , F11() ] in D52 by L354 , L255;
L356: (not  emp ( push (C127 , C126) )) by L170;
L357: [ ( push (C127 , C126) ) , C129 ] <> [ C135 , F11() ] by L356 , L354 , XTUPLE_0:1;
L358: [ C135 , F11() ] nin { [ ( push (C127 , C126) ) , C129 ] } by L357 , TARSKI:def 1;
thus L359: [ C135 , F11() ] in D60 by L358 , L355 , XBOOLE_0:def 5;
end;
let C136 being (stack of F8());
let C137 being (Element of F8());
let C138 being (Element of F10());
assume L360: [ C136 , C138 ] in D60;
L361: [ C136 , C138 ] in D52 by L360 , XBOOLE_0:def 5;
L362: [ ( push (C137 , C136) ) , F12(C137 , C138) ] in D52 by L361 , L255;
L363:
now
assume L364: [ ( push (C127 , C126) ) , C129 ] = [ ( push (C137 , C136) ) , F12(C137 , C138) ];
L365: (( push (C127 , C126) ) = ( push (C137 , C136) ) & C129 = F12(C137 , C138)) by L364 , XTUPLE_0:1;
L366: (C127 = C137 & C126 = C136) by L365 , L217;
thus L367: contradiction by L366 , L322 , L325 , L361 , L351 , L365;
end;
L368: [ ( push (C137 , C136) ) , F12(C137 , C138) ] nin { [ ( push (C127 , C126) ) , C129 ] } by L363 , TARSKI:def 1;
thus L369: [ ( push (C137 , C136) ) , F12(C137 , C138) ] in D60 by L368 , L362 , XBOOLE_0:def 5;
end;
L370: D60 in D50 by L352 , L252;
L371: D52 c= D60 by L370 , SETFAM_1:3;
L372: ([ ( push (C127 , C126) ) , C129 ] in D60 & [ ( push (C127 , C126) ) , C129 ] in { [ ( push (C127 , C126) ) , C129 ] }) by L371 , L323 , TARSKI:def 1;
thus L373: contradiction by L372 , XBOOLE_0:def 5;
end;
thus L374: C128 = C129 by L350 , L326;
end;
L375: D52 is  Function-like
proof
let C139 , C140 , C141 being set;
assume L376: ([ C139 , C140 ] in D52 & [ C139 , C141 ] in D52);
reconsider D61 = C139 as (stack of F8()) by L376 , ZFMISC_1:87;
L377: S7[ D61 ] from INDsch(L277 , L321);
thus L378: thesis by L377 , L376;
end;
L379: D52 is  quasi_total
proof
per cases ;
case L380: F10() <> ( {} );
thus L381: (the carrier' of F8()) c= ( dom D52 )
proof
let R3 being set;
assume L382: R3 in (the carrier' of F8());
reconsider D62 = R3 as (stack of F8()) by L382;
L383: S8[ D62 ] from INDsch(L266 , L270);
thus L384: thesis by L383 , XTUPLE_0:def 12;
end;

thus L385: thesis;
end;
case L386: F10() = ( {} );
thus L387: thesis by L386;
end;
end;
reconsider D63 = D52 as (Function of (the carrier' of F8()) , F10()) by L379 , L375;
take D64 = ( D63 . F9() );
take D63;
thus L389: D64 = ( D63 . F9() );
thus L390:now
let C142 being (stack of F8());
assume L391:  emp C142;
L392: [ C142 , F11() ] in D63 by L391 , L255;
thus L393: ( D63 . C142 ) = F11() by L392 , FUNCT_1:1;
end;
let C143 being (stack of F8());
let C144 being (Element of F8());
L394: ( dom D63 ) = (the carrier' of F8()) by FUNCT_2:def 1;
L395: [ C143 , ( D63 . C143 ) ] in D63 by L394 , FUNCT_1:def 2;
L396: [ ( push (C144 , C143) ) , F12(C144 , ( D63 . C143 )) ] in D63 by L395 , L255;
thus L397: ( D63 . ( push (C144 , C143) ) ) = F12(C144 , ( D63 . C143 )) by L396 , FUNCT_1:1;
end;
scheme UNIQsch { F13() -> StackAlgebra , F14() -> (stack of F13()) , F15() -> non  empty set , F16() -> (Element of F15()) , F17(set , set) -> (Element of F15()) } : (for B85 , B86 being (Element of F15()) holds (((ex B87 being (Function of (the carrier' of F13()) , F15()) st (B85 = ( B87 . F14() ) & (for B88 being (stack of F13()) holds ( emp B88 implies ( B87 . B88 ) = F16())) & (for B89 being (stack of F13()) holds (for B90 being (Element of F13()) holds ( B87 . ( push (B90 , B89) ) ) = F17(B90 , ( B87 . B89 )))))) & (ex B91 being (Function of (the carrier' of F13()) , F15()) st (B86 = ( B91 . F14() ) & (for B92 being (stack of F13()) holds ( emp B92 implies ( B91 . B92 ) = F16())) & (for B93 being (stack of F13()) holds (for B94 being (Element of F13()) holds ( B91 . ( push (B94 , B93) ) ) = F17(B94 , ( B91 . B93 ))))))) implies B85 = B86))
proof
let C145 , C146 being (Element of F15());
given C147 being (Function of (the carrier' of F13()) , F15()) such that
L398: (C145 = ( C147 . F14() ) & (for B95 being (stack of F13()) holds ( emp B95 implies ( C147 . B95 ) = F16())) & (for B96 being (stack of F13()) holds (for B97 being (Element of F13()) holds ( C147 . ( push (B97 , B96) ) ) = F17(B97 , ( C147 . B96 )))));

given C148 being (Function of (the carrier' of F13()) , F15()) such that
L399: (C146 = ( C148 . F14() ) & (for B98 being (stack of F13()) holds ( emp B98 implies ( C148 . B98 ) = F16())) & (for B99 being (stack of F13()) holds (for B100 being (Element of F13()) holds ( C148 . ( push (B100 , B99) ) ) = F17(B100 , ( C148 . B99 )))));

defpred S9[ (stack of F13()) ] means ( C147 . $1 ) = ( C148 . $1 );
L400:
now
let C149 being (stack of F13());
assume L401:  emp C149;
L402: (( C147 . C149 ) = F16() & ( C148 . C149 ) = F16()) by L401 , L398 , L399;
thus L403: S9[ C149 ] by L402;
end;
L404:
now
let C150 being (stack of F13());
let C151 being (Element of F13());
assume L405: S9[ C150 ];
L406: ( C147 . ( push (C151 , C150) ) ) = F17(C151 , ( C148 . C150 )) by L405 , L398;
thus L407: S9[ ( push (C151 , C150) ) ] by L406 , L399;
end;
L408: S9[ F14() ] from INDsch(L400 , L404);
thus L409: C145 = C146 by L408 , L398 , L399;
end;
begin
definition
let R15 being StackAlgebra;
let R16 being (stack of R15);
func |.R16 .| -> (Element of ( (the carrier of R15) * )) means 
:L410: (ex B101 being (Function of (the carrier' of R15) , ( (the carrier of R15) * )) st (it = ( B101 . R16 ) & (for R17 being (stack of R15) holds ( emp R17 implies ( B101 . R17 ) = ( {} ))) & (for R17 being (stack of R15) holds (for R20 being (Element of R15) holds ( B101 . ( push (R20 , R17) ) ) = ( <* R20 *> ^ ( B101 . R17 ) )))));
existence
proof
deffunc H6((Element of R15) , (Element of ( (the carrier of R15) * ))) = ( <* $1 *> ^ $2 );
reconsider D65 = ( <*> (the carrier of R15) ) as (Element of ( (the carrier of R15) * )) by FINSEQ_1:def 11;
L411: (ex B102 being (Element of ( (the carrier of R15) * )) st (ex B103 being (Function of (the carrier' of R15) , ( (the carrier of R15) * )) st (B102 = ( B103 . R16 ) & (for R17 being (stack of R15) holds ( emp R17 implies ( B103 . R17 ) = D65)) & (for R17 being (stack of R15) holds (for R20 being (Element of R15) holds ( B103 . ( push (R20 , R17) ) ) = H6(R20 , (( B103 . R17 ) qua (Element of ( (the carrier of R15) * ))))))))) from EXsch;
thus L412: thesis by L411;
end;
uniqueness
proof
deffunc H7((Element of R15) , (Element of ( (the carrier of R15) * ))) = ( <* $1 *> ^ $2 );
reconsider D66 = ( <*> (the carrier of R15) ) as (Element of ( (the carrier of R15) * )) by FINSEQ_1:def 11;
L413: (for B104 , B105 being (Element of ( (the carrier of R15) * )) holds (((ex B106 being (Function of (the carrier' of R15) , ( (the carrier of R15) * )) st (B104 = ( B106 . R16 ) & (for R17 being (stack of R15) holds ( emp R17 implies ( B106 . R17 ) = D66)) & (for R17 being (stack of R15) holds (for R20 being (Element of R15) holds ( B106 . ( push (R20 , R17) ) ) = H7(R20 , (( B106 . R17 ) qua (Element of ( (the carrier of R15) * )))))))) & (ex B107 being (Function of (the carrier' of R15) , ( (the carrier of R15) * )) st (B105 = ( B107 . R16 ) & (for R17 being (stack of R15) holds ( emp R17 implies ( B107 . R17 ) = D66)) & (for R17 being (stack of R15) holds (for R20 being (Element of R15) holds ( B107 . ( push (R20 , R17) ) ) = H7(R20 , (( B107 . R17 ) qua (Element of ( (the carrier of R15) * ))))))))) implies B104 = B105)) from UNIQsch;
thus L414: thesis by L413;
end;
end;
theorem
L416: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds ( emp R16 implies |. R16 .| = ( {} ))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
L417: (ex B108 being (Function of (the carrier' of R15) , ( (the carrier of R15) * )) st (|. R16 .| = ( B108 . R16 ) & (for R17 being (stack of R15) holds ( emp R17 implies ( B108 . R17 ) = ( {} ))) & (for R17 being (stack of R15) holds (for R20 being (Element of R15) holds ( B108 . ( push (R20 , R17) ) ) = ( <* R20 *> ^ ( B108 . R17 ) ))))) by L410;
thus L418: thesis by L417;
end;
theorem
L419: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds ((not  emp R16) implies |. R16 .| = ( <* ( top R16 ) *> ^ |. ( pop R16 ) .| ))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
consider C152 being (Function of (the carrier' of R15) , ( (the carrier of R15) * )) such that L420: (|. R16 .| = ( C152 . R16 ) & (for R17 being (stack of R15) holds ( emp R17 implies ( C152 . R17 ) = ( {} ))) & (for R17 being (stack of R15) holds (for R20 being (Element of R15) holds ( C152 . ( push (R20 , R17) ) ) = ( <* R20 *> ^ ( C152 . R17 ) )))) by L410;
L421: |. ( pop R16 ) .| = ( C152 . ( pop R16 ) ) by L420 , L410;
assume L422: (not  emp R16);
L423: R16 = ( push (( top R16 ) , ( pop R16 )) ) by L422 , L167;
thus L424: thesis by L423 , L420 , L421;
end;
theorem
L425: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds ((not  emp R16) implies |. ( pop R16 ) .| = ( Del (|. R16 .| , 1) ))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
assume L426: (not  emp R16);
L427: |. R16 .| = ( <* ( top R16 ) *> ^ |. ( pop R16 ) .| ) by L426 , L419;
thus L428: thesis by L427 , WSIERP_1:40;
end;
theorem
L429: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds (for R20 being (Element of R15) holds |. ( push (R20 , R16) ) .| = ( <* R20 *> ^ |. R16 .| ))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
let R20 being (Element of R15);
L430: (not  emp ( push (R20 , R16) )) by L170;
thus L431: |. ( push (R20 , R16) ) .| = ( <* ( top ( push (R20 , R16) ) ) *> ^ |. ( pop ( push (R20 , R16) ) ) .| ) by L430 , L419
.= ( <* R20 *> ^ |. ( pop ( push (R20 , R16) ) ) .| ) by L168
.= ( <* R20 *> ^ |. R16 .| ) by L169;
end;
theorem
L432: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds ((not  emp R16) implies ( top R16 ) = ( |. R16 .| . 1 ))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
assume L433: (not  emp R16);
L434: |. R16 .| = ( <* ( top R16 ) *> ^ |. ( pop R16 ) .| ) by L433 , L419;
thus L435: ( top R16 ) = ( |. R16 .| . 1 ) by L434 , FINSEQ_1:41;
end;
theorem
L436: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds (|. R16 .| = ( {} ) implies  emp R16)))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
assume L437: (|. R16 .| = ( {} ) & (not  emp R16));
L438: ( {} ) = ( <* ( top R16 ) *> ^ |. ( pop R16 ) .| ) by L437 , L419;
thus L439: thesis by L438;
end;
theorem
L440: (for R5 being non  empty set holds (for B109 being (stack of ( StandardStackSystem R5 )) holds |. B109 .| = B109))
proof
let R5 being non  empty set;
defpred S10[ (stack of ( StandardStackSystem R5 )) ] means |. $1 .| = $1;
L441:
now
let C153 being (stack of ( StandardStackSystem R5 ));
assume L442:  emp C153;
L443: (C153 = ( {} ) & |. C153 .| = ( {} )) by L442 , L98 , L416;
thus L444: S10[ C153 ] by L443;
end;
L445:
now
let C154 being (stack of ( StandardStackSystem R5 ));
let C155 being (Element of ( StandardStackSystem R5 ));
assume L446: S10[ C154 ];
L447: |. ( push (C155 , C154) ) .| = ( <* C155 *> ^ C154 ) by L446 , L429;
thus L448: S10[ ( push (C155 , C154) ) ] by L447 , L98;
end;
let C156 being (stack of ( StandardStackSystem R5 ));
thus L449: S10[ C156 ] from INDsch(L441 , L445);
end;
theorem
L450: (for R15 being StackAlgebra holds (for B110 being (Element of ( (the carrier of R15) * )) holds (ex R16 being (stack of R15) st |. R16 .| = B110)))
proof
let R15 being StackAlgebra;
set D67 = (the carrier of R15);
defpred S11[ (FinSequence of D67) ] means (ex R16 being (stack of R15) st |. R16 .| = $1);
L451: S11[ ( <*> D67 ) ]
proof
consider R16 being (stack of R15) such that L452:  emp R16 by L207;
take R16;
thus L453: thesis by L452 , L416;
end;
L454: (for B111 being (FinSequence of D67) holds (for B112 being (Element of D67) holds (S11[ B111 ] implies S11[ ( <* B112 *> ^ B111 ) ])))
proof
let C157 being (FinSequence of D67);
let C158 being (Element of D67);
given R16 being (stack of R15) such that
L455: |. R16 .| = C157;

take D68 = ( push (C158 , R16) );
thus L456: thesis by L455 , L429;
end;
L457: (for B113 being (FinSequence of D67) holds S11[ B113 ]) from IndSeqD(L451 , L454);
thus L458: thesis by L457;
end;
definition
let R15 being StackAlgebra;
let R17 being (stack of R15);
let R18 being (stack of R15);
pred R17 == R18
means
:L459: |. R17 .| = |. R18 .|
;reflexivity
;
symmetry
;
end;
theorem
L461: (for R15 being StackAlgebra holds (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds (for R19 being (stack of R15) holds ((R17 == R18 & R18 == R19) implies R17 == R19)))))
proof
let R15 being StackAlgebra;
let R17 being (stack of R15);
let R18 being (stack of R15);
let R19 being (stack of R15);
assume L462: (|. R17 .| = |. R18 .| & |. R18 .| = |. R19 .|);
thus L463: |. R17 .| = |. R19 .| by L462;
end;
theorem
L464: (for R15 being StackAlgebra holds (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds ((R17 == R18 &  emp R17) implies  emp R18))))
proof
let R15 being StackAlgebra;
let R17 being (stack of R15);
let R18 being (stack of R15);
assume L465: (|. R17 .| = |. R18 .| &  emp R17);
assume L466: (not  emp R18);
L467: |. R18 .| = ( <* ( top R18 ) *> ^ |. ( pop R18 ) .| ) by L466 , L419;
thus L468: thesis by L467 , L465 , L416;
end;
theorem
L469: (for R15 being StackAlgebra holds (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds (( emp R17 &  emp R18) implies R17 == R18))))
proof
let R15 being StackAlgebra;
let R17 being (stack of R15);
let R18 being (stack of R15);
assume L470: ( emp R17 &  emp R18);
L471: (|. R17 .| = ( {} ) & |. R18 .| = ( {} )) by L470 , L416;
thus L472: |. R17 .| = |. R18 .| by L471;
end;
theorem
L473: (for R15 being StackAlgebra holds (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds (for R20 being (Element of R15) holds (R17 == R18 implies ( push (R20 , R17) ) == ( push (R20 , R18) ))))))
proof
let R15 being StackAlgebra;
let R17 being (stack of R15);
let R18 being (stack of R15);
let R20 being (Element of R15);
assume L474: |. R17 .| = |. R18 .|;
thus L475: |. ( push (R20 , R17) ) .| = ( <* R20 *> ^ |. R18 .| ) by L474 , L429
.= |. ( push (R20 , R18) ) .| by L429;
end;
theorem
L476: (for R15 being StackAlgebra holds (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds ((R17 == R18 & (not  emp R17)) implies ( pop R17 ) == ( pop R18 )))))
proof
let R15 being StackAlgebra;
let R17 being (stack of R15);
let R18 being (stack of R15);
assume L477: (R17 == R18 & (not  emp R17));
L478: (|. R17 .| = |. R18 .| & (not  emp R18)) by L477 , L459 , L464;
thus L479: |. ( pop R17 ) .| = ( Del (|. R17 .| , 1) ) by L477 , L425
.= |. ( pop R18 ) .| by L478 , L425;
end;
theorem
L480: (for R15 being StackAlgebra holds (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds ((R17 == R18 & (not  emp R17)) implies ( top R17 ) = ( top R18 )))))
proof
let R15 being StackAlgebra;
let R17 being (stack of R15);
let R18 being (stack of R15);
assume L481: (R17 == R18 & (not  emp R17));
L482: (|. R17 .| = |. R18 .| & (not  emp R18)) by L481 , L459 , L464;
thus L483: ( top R17 ) = ( |. R17 .| . 1 ) by L481 , L432
.= ( top R18 ) by L482 , L432;
end;
definition
let R15 being StackAlgebra;
attr R15 is  proper-for-identity
means
:L484: (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds (R17 == R18 implies R17 = R18)));
end;
registration
let R5 being non  empty set;
cluster ( StandardStackSystem R5 ) ->  proper-for-identity;
coherence
proof
set D69 = ( StandardStackSystem R5 );
let C159 , C160 being (stack of D69);
assume L486: |. C159 .| = |. C160 .|;
thus L487: C159 = |. C160 .| by L486 , L440
.= C160 by L440;
end;
end;
definition
let R15 being StackAlgebra;
func ==_ R15 -> (Relation of (the carrier' of R15)) means 
:L489: (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds ([ R17 , R18 ] in it iff R17 == R18)));
existence
proof
defpred S12[ (stack of R15) , (stack of R15) ] means $1 == $2;
thus L490: (ex B114 being (Relation of (the carrier' of R15)) st (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds ([ R17 , R18 ] in B114 iff S12[ R17 , R18 ])))) from RELSET_1:sch 2;
end;
uniqueness
proof
defpred S13[ (stack of R15) , (stack of R15) ] means $1 == $2;
let C161 , C162 being (Relation of (the carrier' of R15));
assume that
L491: (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds ([ R17 , R18 ] in C161 iff S13[ R17 , R18 ])))
and
L492: (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds ([ R17 , R18 ] in C162 iff S13[ R17 , R18 ])));
thus L493: thesis from RELSET_1:sch 4(L491 , L492);
end;
end;
registration
let R15 being StackAlgebra;
cluster ( ==_ R15 ) ->  total  symmetric  transitive;
coherence
proof
set D70 = ( ==_ R15 );
thus L495: ( dom ( ==_ R15 ) ) = (the carrier' of R15)
proof
thus L496: ( dom D70 ) c= (the carrier' of R15);
let R3 being set;
assume L497: R3 in (the carrier' of R15);
reconsider D71 = R3 as (stack of R15) by L497;
L498: [ D71 , D71 ] in D70 by L489;
thus L499: thesis by L498 , XTUPLE_0:def 12;
end;

L500: ( field D70 ) = ( ( dom D70 ) \/ ( rng D70 ) )
.= (the carrier' of R15) by L495 , XBOOLE_1:12;
thus L501: ( ==_ R15 ) is  symmetric
proof
let C163 , C164 being set;
assume L502: (C163 in ( field D70 ) & C164 in ( field D70 ));
reconsider D72 = C163 , D73 = C164 as (stack of R15) by L502 , L500;
assume L503: [ C163 , C164 ] in D70;
L504: D72 == D73 by L503 , L489;
thus L505: thesis by L504 , L489;
end;

let C165 , C166 , C167 being set;
assume L506: (C165 in ( field D70 ) & C166 in ( field D70 ) & C167 in ( field D70 ));
reconsider D74 = C165 , D75 = C166 , D76 = C167 as (stack of R15) by L506 , L500;
assume L507: ([ C165 , C166 ] in D70 & [ C166 , C167 ] in D70);
L508: (D74 == D75 & D75 == D76) by L507 , L489;
L509: D74 == D76 by L508 , L461;
thus L510: thesis by L509 , L489;
end;
end;
theorem
L512: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds ( emp R16 implies ( Class (( ==_ R15 ) , R16) ) = (the s_empty of R15))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
assume L513:  emp R16;
thus L514: ( Class (( ==_ R15 ) , R16) ) c= (the s_empty of R15)
proof
let R3 being set;
assume L515: R3 in ( Class (( ==_ R15 ) , R16) );
reconsider D77 = R3 as (stack of R15) by L515;
L516: [ R16 , D77 ] in ( ==_ R15 ) by L515 , EQREL_1:18;
L517: R16 == D77 by L516 , L489;
L518:  emp D77 by L517 , L513 , L464;
thus L519: thesis by L518 , L94;
end;

let R3 being set;
assume L520: R3 in (the s_empty of R15);
reconsider D78 = R3 as (stack of R15) by L520;
L521:  emp D78 by L520 , L94;
L522: R16 == D78 by L521 , L513 , L469;
L523: [ R16 , D78 ] in ( ==_ R15 ) by L522 , L489;
thus L524: thesis by L523 , EQREL_1:18;
end;
definition
let R15 being StackAlgebra;
let R16 being (stack of R15);
func coset R16 -> (Subset of (the carrier' of R15)) means 
:L525: (R16 in it & (for R20 being (Element of R15) holds (for R17 being (stack of R15) holds (R17 in it implies (( push (R20 , R17) ) in it & ((not  emp R17) implies ( pop R17 ) in it))))) & (for B115 being (Subset of (the carrier' of R15)) holds ((R16 in B115 & (for R20 being (Element of R15) holds (for R17 being (stack of R15) holds (R17 in B115 implies (( push (R20 , R17) ) in B115 & ((not  emp R17) implies ( pop R17 ) in B115)))))) implies it c= B115)));
existence
proof
defpred S14[ set ] means (R16 in $1 & (for R20 being (Element of R15) holds (for R17 being (stack of R15) holds (R17 in $1 implies (( push (R20 , R17) ) in $1 & ((not  emp R17) implies ( pop R17 ) in $1))))));
consider C168 being set such that L526: (for R3 being set holds (R3 in C168 iff (R3 in ( bool (the carrier' of R15) ) & S14[ R3 ]))) from XBOOLE_0:sch 1;
set D79 = (the carrier' of R15);
L527: (S14[ (the carrier' of R15) ] & D79 in ( bool D79 )) by ZFMISC_1:def 1;
L528: (the carrier' of R15) in C168 by L527 , L526;
reconsider D80 = C168 as non  empty set by L527 , L526;
reconsider D81 = ( meet D80 ) as (Subset of D79) by L528 , SETFAM_1:3;
take D81;
L529: (for R3 being set holds (R3 in D80 implies R16 in R3)) by L526;
thus L530: R16 in D81 by L529 , SETFAM_1:def 1;
thus L531:now
let R20 being (Element of R15);
let R17 being (stack of R15);
assume L532: R17 in D81;
L533:
now
let R3 being set;
assume L534: R3 in D80;
L535: R17 in R3 by L534 , L532 , SETFAM_1:def 1;
thus L536: ( push (R20 , R17) ) in R3 by L535 , L526 , L534;
end;
thus L537: ( push (R20 , R17) ) in D81 by L533 , SETFAM_1:def 1;
assume L538: (not  emp R17);
L539:
now
let R3 being set;
assume L540: R3 in D80;
L541: R17 in R3 by L540 , L532 , SETFAM_1:def 1;
thus L542: ( pop R17 ) in R3 by L541 , L526 , L538 , L540;
end;
thus L543: ( pop R17 ) in D81 by L539 , SETFAM_1:def 1;
end;
let C169 being (Subset of (the carrier' of R15));
assume L544: S14[ C169 ];
L545: C169 in D80 by L544 , L526;
thus L546: D81 c= C169 by L545 , SETFAM_1:3;
end;
uniqueness
proof
let C170 , C171 being (Subset of (the carrier' of R15));
assume L547: (not thesis);
L548: C170 = C171
proof
thus L549: (C170 c= C171 & C171 c= C170) by L547;
end;
thus L550: thesis by L548 , L547;
end;
end;
theorem
L552: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds (for R17 being (stack of R15) holds (for R20 being (Element of R15) holds ((( push (R20 , R16) ) in ( coset R17 ) implies R16 in ( coset R17 )) & (((not  emp R16) & ( pop R16 ) in ( coset R17 )) implies R16 in ( coset R17 )))))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
let R17 being (stack of R15);
let R20 being (Element of R15);
L553: (( pop ( push (R20 , R16) ) ) = R16 & (not  emp ( push (R20 , R16) ))) by L169 , L170;
thus L554: (( push (R20 , R16) ) in ( coset R17 ) implies R16 in ( coset R17 )) by L553 , L525;
assume L555: (not  emp R16);
L556: ( push (( top R16 ) , ( pop R16 )) ) = R16 by L555 , L167;
thus L557: thesis by L556 , L525;
end;
theorem
L558: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds (for R20 being (Element of R15) holds (R16 in ( coset ( push (R20 , R16) ) ) & ((not  emp R16) implies R16 in ( coset ( pop R16 ) ))))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
let R20 being (Element of R15);
L559: (( pop ( push (R20 , R16) ) ) = R16 & (not  emp ( push (R20 , R16) )) & ( push (R20 , R16) ) in ( coset ( push (R20 , R16) ) )) by L169 , L170 , L525;
thus L560: R16 in ( coset ( push (R20 , R16) ) ) by L559 , L525;
assume L561: (not  emp R16);
L562: (( push (( top R16 ) , ( pop R16 )) ) = R16 & ( pop R16 ) in ( coset ( pop R16 ) )) by L561 , L167 , L525;
thus L563: thesis by L562 , L525;
end;
theorem
L564: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds (ex R17 being (stack of R15) st ( emp R17 & R17 in ( coset R16 )))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
deffunc H8((stack of R15)) = ( pop $1 );
defpred S15[ set , (stack of R15) , set ] means $3 = ( IFIN ($2 , (the s_empty of R15) , R16 , ( pop $2 )) );
L565: (for B116 being (Element of ( NAT )) holds (for B117 being (stack of R15) holds (ex B118 being (stack of R15) st S15[ B116 , B117 , B118 ])));
consider C172 being (Function of ( NAT ) , (the carrier' of R15)) such that L566: (( C172 . ( 0 ) ) = R16 & (for B119 being (Element of ( NAT )) holds S15[ B119 , ( C172 . B119 ) , ( C172 . ( B119 + 1 ) ) ])) from RECDEF_1:sch 2(L565);
defpred S16[ Nat ] means ( C172 . $1 ) in ( coset R16 );
L567: S16[ ( 0 ) ] by L566 , L525;
L568:
now
let R1 being Nat;
assume L569: S16[ R1 ];
L570: R1 in ( NAT ) by ORDINAL1:def 12;
L571: ( C172 . ( R1 + 1 ) ) = ( IFIN (( C172 . R1 ) , (the s_empty of R15) , R16 , ( pop ( C172 . R1 ) )) ) by L570 , L566;
L572: ((( C172 . R1 ) in (the s_empty of R15) implies ( C172 . ( R1 + 1 ) ) = R16) & (( C172 . R1 ) nin (the s_empty of R15) implies ( C172 . ( R1 + 1 ) ) = ( pop ( C172 . R1 ) ))) by L571 , MATRIX_7:def 1;
L573: (( C172 . ( R1 + 1 ) ) = R16 or ((not  emp ( C172 . R1 )) & ( C172 . ( R1 + 1 ) ) = ( pop ( C172 . R1 ) ))) by L572 , L94;
thus L574: S16[ ( R1 + 1 ) ] by L573 , L569 , L525;
end;
L575: (for R1 being Nat holds S16[ R1 ]) from NAT_1:sch 2(L567 , L568);
consider R1 being Nat, R17 being (stack of R15) such that L576: (( C172 . R1 ) = R17 & ((not  emp R17) implies ( C172 . ( R1 + 1 ) ) <> ( pop R17 ))) by L166;
take R17;
L577: R1 in ( NAT ) by ORDINAL1:def 12;
L578: ( C172 . ( R1 + 1 ) ) = ( IFIN (( C172 . R1 ) , (the s_empty of R15) , R16 , ( pop ( C172 . R1 ) )) ) by L577 , L566;
L579: ((( C172 . R1 ) in (the s_empty of R15) implies ( C172 . ( R1 + 1 ) ) = R16) & (( C172 . R1 ) nin (the s_empty of R15) implies ( C172 . ( R1 + 1 ) ) = ( pop ( C172 . R1 ) ))) by L578 , MATRIX_7:def 1;
thus L580: thesis by L579 , L576 , L575 , L94;
end;
registration
let R5 being non  empty set;
let C173 being (Relation of R5);
cluster R5 -valued for (RedSequence of C173);
existence
proof
set D82 = the (Element of R5);
reconsider D83 = <* D82 *> as (RedSequence of C173) by REWRITE1:6;
take D83;
thus L581: thesis;
end;
end;
definition
let R15 being StackAlgebra;
func ConstructionRed R15 -> (Relation of (the carrier' of R15)) means 
:L583: (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds ([ R17 , R18 ] in it iff (((not  emp R17) & R18 = ( pop R17 )) or (ex R20 being (Element of R15) st R18 = ( push (R20 , R17) ))))));
existence
proof
defpred S17[ (stack of R15) , (stack of R15) ] means (((not  emp $1) & $2 = ( pop $1 )) or (ex R20 being (Element of R15) st $2 = ( push (R20 , $1) )));
thus L584: (ex B120 being (Relation of (the carrier' of R15)) st (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds ([ R17 , R18 ] in B120 iff S17[ R17 , R18 ])))) from RELSET_1:sch 2;
end;
uniqueness
proof
defpred S18[ (stack of R15) , (stack of R15) ] means (((not  emp $1) & $2 = ( pop $1 )) or (ex R20 being (Element of R15) st $2 = ( push (R20 , $1) )));
let C174 , C175 being (Relation of (the carrier' of R15));
assume that
L585: (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds ([ R17 , R18 ] in C174 iff S18[ R17 , R18 ])))
and
L586: (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds ([ R17 , R18 ] in C175 iff S18[ R17 , R18 ])));
thus L587: thesis from RELSET_1:sch 4(L585 , L586);
end;
end;
theorem
L589: (for R5 being non  empty set holds (for B121 being (Relation of R5) holds (for B122 being (RedSequence of B121) holds (( B122 . 1 ) in R5 iff B122 is R5 -valued))))
proof
let R5 being non  empty set;
let C176 being (Relation of R5);
let C177 being (RedSequence of C176);
L590: ( rng C177 ) <> ( {} );
L591: 1 in ( dom C177 ) by L590 , FINSEQ_3:32;
L592: ( C177 . 1 ) in ( rng C177 ) by L591 , FUNCT_1:def 3;
thus L593:now
assume L594: ( C177 . 1 ) in R5;
defpred S19[ Nat ] means ($1 in ( dom C177 ) implies ( C177 . $1 ) in R5);
L595: S19[ ( 0 ) ] by FINSEQ_3:24;
L596: (for R1 being Nat holds (S19[ R1 ] implies S19[ ( R1 + 1 ) ]))
proof
let R1 being Nat;
assume L597: S19[ R1 ];
assume L598: (( R1 + 1 ) in ( dom C177 ) & ( C177 . ( R1 + 1 ) ) nin R5);
L599: (R1 = ( 0 ) or R1 >= ( ( 0 ) + 1 )) by NAT_1:13;
consider C178 being Nat such that L600: R1 = ( C178 + 1 ) by L599 , L594 , L598 , NAT_1:6;
L601: (R1 <= ( R1 + 1 ) & ( R1 + 1 ) <= ( len C177 )) by L598 , FINSEQ_3:25 , NAT_1:11;
L602: (1 <= R1 & R1 <= ( len C177 )) by L601 , L600 , NAT_1:11 , XXREAL_0:2;
L603: R1 in ( dom C177 ) by L602 , FINSEQ_3:25;
L604: [ ( C177 . R1 ) , ( C177 . ( R1 + 1 ) ) ] in C176 by L603 , L598 , REWRITE1:def 2;
thus L605: thesis by L604 , L598 , ZFMISC_1:87;
end;
L606: (for R1 being Nat holds S19[ R1 ]) from NAT_1:sch 2(L595 , L596);
thus L607: C177 is R5 -valued
proof
let R3 being set;
assume L608: R3 in ( rng C177 );
consider R4 being set such that L609: (R4 in ( dom C177 ) & R3 = ( C177 . R4 )) by L608 , FUNCT_1:def 3;
reconsider D84 = R4 as Nat by L609;
thus L610: thesis by L609 , L606;
end;

end;
assume L608: ( rng C177 ) c= R5;
thus L609: ( C177 . 1 ) in R5 by L608 , L592;
end;
scheme PathIND { F18() -> non  empty set , F19 , F20() -> (Element of F18()) , F21() -> (Relation of F18()) , P3[set] } : P3[ F20() ]
provided
L610: P3[ F19() ]
and
L611: F21() reduces F19() , F20()
and
L612: (for B123 , B124 being (Element of F18()) holds ((F21() reduces F19() , B123 & [ B123 , B124 ] in F21() & P3[ B123 ]) implies P3[ B124 ]))
proof
consider C179 being (RedSequence of F21()) such that L613: (( C179 . 1 ) = F19() & ( C179 . ( len C179 ) ) = F20()) by L611 , REWRITE1:def 3;
reconsider D85 = C179 as F18() -valued (RedSequence of F21()) by L613 , L589;
defpred S20[ Nat ] means ($1 in ( dom D85 ) implies P3[ ( D85 . $1 ) ]);
L614: S20[ ( 0 ) ] by FINSEQ_3:24;
L615:
now
let R1 being Nat;
assume L616: S20[ R1 ];
thus L617: S20[ ( R1 + 1 ) ]
proof
assume L618: (( R1 + 1 ) in ( dom D85 ) & (not P3[ ( D85 . ( R1 + 1 ) ) ]));
L619: (R1 = ( 0 ) or R1 >= ( ( 0 ) + 1 )) by NAT_1:13;
consider C180 being Nat such that L620: R1 = ( C180 + 1 ) by L619 , L610 , L613 , L618 , NAT_1:6;
L621: (R1 <= ( R1 + 1 ) & ( R1 + 1 ) <= ( len D85 )) by L618 , FINSEQ_3:25 , NAT_1:11;
L622: (1 <= R1 & R1 <= ( len D85 ) & ( rng D85 ) <> ( {} )) by L621 , L620 , NAT_1:11 , XXREAL_0:2;
L623: (R1 in ( dom D85 ) & 1 in ( dom D85 )) by L622 , FINSEQ_3:25 , FINSEQ_3:32;
L624: (( D85 . R1 ) = ( D85 /. R1 ) & ( D85 . ( R1 + 1 ) ) = ( D85 /. ( R1 + 1 ) )) by L618 , L623 , PARTFUN1:def 6;
L625: [ ( D85 /. R1 ) , ( D85 /. ( R1 + 1 ) ) ] in F21() by L624 , L618 , L623 , REWRITE1:def 2;
thus L626: thesis by L625 , L612 , L616 , L618 , L623 , L613 , L622 , L624 , REWRITE1:17;
end;

end;
L618: (for R1 being Nat holds S20[ R1 ]) from NAT_1:sch 2(L614 , L615);
L619: ( len D85 ) in ( dom D85 ) by FINSEQ_5:6;
thus L620: thesis by L619 , L613 , L618;
end;
theorem
L621: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds (for B125 being (RedSequence of ( ConstructionRed R15 )) holds (R16 = ( B125 . 1 ) implies ( rng B125 ) c= ( coset R16 )))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
set D86 = ( ConstructionRed R15 );
let C181 being (RedSequence of ( ConstructionRed R15 ));
assume L622: R16 = ( C181 . 1 );
reconsider D87 = C181 as (the carrier' of R15) -valued (RedSequence of D86) by L622 , L589;
defpred S21[ Nat ] means ($1 in ( dom C181 ) implies ( C181 . $1 ) in ( coset R16 ));
L623: S21[ ( 0 ) ] by FINSEQ_3:24;
L624:
now
let R1 being Nat;
assume L625: S21[ R1 ];
thus L626: S21[ ( R1 + 1 ) ]
proof
assume L627: (( R1 + 1 ) in ( dom C181 ) & ( C181 . ( R1 + 1 ) ) nin ( coset R16 ));
L628: (R1 = ( 0 ) or R1 >= ( ( 0 ) + 1 )) by NAT_1:13;
consider C182 being Nat such that L629: R1 = ( C182 + 1 ) by L628 , L622 , L627 , L525 , NAT_1:6;
L630: (R1 <= ( R1 + 1 ) & ( R1 + 1 ) <= ( len C181 )) by L627 , FINSEQ_3:25 , NAT_1:11;
L631: (1 <= R1 & R1 <= ( len C181 ) & ( rng C181 ) <> ( {} )) by L630 , L629 , NAT_1:11 , XXREAL_0:2;
L632: (R1 in ( dom C181 ) & 1 in ( dom C181 )) by L631 , FINSEQ_3:25 , FINSEQ_3:32;
L633: (( C181 . R1 ) = ( D87 /. R1 ) & ( C181 . ( R1 + 1 ) ) = ( D87 /. ( R1 + 1 ) )) by L632 , L627 , PARTFUN1:def 6;
L634: [ ( D87 /. R1 ) , ( D87 /. ( R1 + 1 ) ) ] in D86 by L633 , L627 , L632 , REWRITE1:def 2;
L635: (((not  emp ( D87 /. R1 )) & ( D87 /. ( R1 + 1 ) ) = ( pop ( D87 /. R1 ) )) or (ex R20 being (Element of R15) st ( D87 /. ( R1 + 1 ) ) = ( push (R20 , ( D87 /. R1 )) ))) by L634 , L583;
thus L636: thesis by L635 , L625 , L627 , L631 , L633 , L525 , FINSEQ_3:25;
end;

end;
L627: (for R1 being Nat holds S21[ R1 ]) from NAT_1:sch 2(L623 , L624);
let R3 being set;
assume L628: R3 in ( rng C181 );
L629: (ex R4 being set st (R4 in ( dom C181 ) & R3 = ( C181 . R4 ))) by L628 , FUNCT_1:def 3;
thus L630: thesis by L629 , L627;
end;
theorem
L631: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds ( coset R16 ) = { R17 where R17 is (stack of R15) : ( ConstructionRed R15 ) reduces R16 , R17 }))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
set D88 = ( ConstructionRed R15 );
L632: { R17 where R17 is (stack of R15) : D88 reduces R16 , R17 } c= (the carrier' of R15)
proof
let R3 being set;
assume L633: R3 in { R17 where R17 is (stack of R15) : D88 reduces R16 , R17 };
L634: (ex R17 being (stack of R15) st (R3 = R17 & D88 reduces R16 , R17)) by L633;
thus L635: thesis by L634;
end;
L636: D88 reduces R16 , R16 by REWRITE1:12;
L637: R16 in { R17 where R17 is (stack of R15) : D88 reduces R16 , R17 } by L636;
L638:
now
let R20 being (Element of R15);
let R18 being (stack of R15);
assume L639: R18 in { R17 where R17 is (stack of R15) : D88 reduces R16 , R17 };
L640: (ex R17 being (stack of R15) st (R18 = R17 & D88 reduces R16 , R17)) by L639;
L641: [ R18 , ( push (R20 , R18) ) ] in D88 by L583;
L642: D88 reduces R18 , ( push (R20 , R18) ) by L641 , REWRITE1:15;
L643: D88 reduces R16 , ( push (R20 , R18) ) by L642 , L640 , REWRITE1:16;
thus L644: ( push (R20 , R18) ) in { R17 where R17 is (stack of R15) : D88 reduces R16 , R17 } by L643;
assume L645: (not  emp R18);
L646: [ R18 , ( pop R18 ) ] in D88 by L645 , L583;
L647: D88 reduces R18 , ( pop R18 ) by L646 , REWRITE1:15;
L648: D88 reduces R16 , ( pop R18 ) by L647 , L640 , REWRITE1:16;
thus L649: ( pop R18 ) in { R17 where R17 is (stack of R15) : D88 reduces R16 , R17 } by L648;
end;
thus L650: ( coset R16 ) c= { R17 where R17 is (stack of R15) : D88 reduces R16 , R17 } by L638 , L632 , L637 , L525;
let R3 being set;
assume L651: R3 in { R17 where R17 is (stack of R15) : D88 reduces R16 , R17 };
consider R17 being (stack of R15) such that L652: (R3 = R17 & D88 reduces R16 , R17) by L651;
consider C183 being (RedSequence of D88) such that L653: (R16 = ( C183 . 1 ) & R17 = ( C183 . ( len C183 ) )) by L652 , REWRITE1:def 3;
L654: ( len C183 ) in ( dom C183 ) by FINSEQ_5:6;
L655: (R3 in ( rng C183 ) & ( rng C183 ) c= ( coset R16 )) by L654 , L652 , L653 , L621 , FUNCT_1:def 3;
thus L656: thesis by L655;
end;
definition
let R15 being StackAlgebra;
let R16 being (stack of R15);
func core R16 -> (stack of R15) means 
:L657: ( emp it & (ex B126 being (the carrier' of R15) -valued (RedSequence of ( ConstructionRed R15 )) st (( B126 . 1 ) = R16 & ( B126 . ( len B126 ) ) = it & (for R1 being Nat holds ((1 <= R1 & R1 < ( len B126 )) implies ((not  emp ( B126 /. R1 )) & ( B126 /. ( R1 + 1 ) ) = ( pop ( B126 /. R1 ) )))))));
existence
proof
set D89 = ( ConstructionRed R15 );
deffunc H9((stack of R15)) = ( pop $1 );
defpred S22[ set , (stack of R15) , set ] means $3 = ( IFIN ($2 , (the s_empty of R15) , R16 , ( pop $2 )) );
L658: (for B127 being (Element of ( NAT )) holds (for B128 being (stack of R15) holds (ex B129 being (stack of R15) st S22[ B127 , B128 , B129 ])));
consider C184 being (Function of ( NAT ) , (the carrier' of R15)) such that L659: (( C184 . ( 0 ) ) = R16 & (for B130 being (Element of ( NAT )) holds S22[ B130 , ( C184 . B130 ) , ( C184 . ( B130 + 1 ) ) ])) from RECDEF_1:sch 2(L658);
defpred S23[ Nat ] means (ex R17 being (stack of R15) st (( C184 . $1 ) = R17 & ((not  emp R17) implies ( C184 . ( $1 + 1 ) ) <> ( pop R17 ))));
L660: (ex R1 being Nat st S23[ R1 ]) by L166;
consider R1 being Nat such that L661: (S23[ R1 ] & (for B131 being Nat holds (S23[ B131 ] implies R1 <= B131))) from NAT_1:sch 5(L660);
deffunc H10(Nat) = ( C184 . ( $1 -' 1 ) );
consider C185 being FinSequence such that L662: (( len C185 ) = ( R1 + 1 ) & (for B132 being Nat holds (B132 in ( dom C185 ) implies ( C185 . B132 ) = H10(B132)))) from FINSEQ_1:sch 2;
consider R17 being (stack of R15) such that L663: (( C184 . R1 ) = R17 & ((not  emp R17) implies ( C184 . ( R1 + 1 ) ) <> ( pop R17 ))) by L661;
take R17;
L664: R1 in ( NAT ) by ORDINAL1:def 12;
L665: ( C184 . ( R1 + 1 ) ) = ( IFIN (( C184 . R1 ) , (the s_empty of R15) , R16 , ( pop ( C184 . R1 ) )) ) by L664 , L659;
L666: ((( C184 . R1 ) in (the s_empty of R15) implies ( C184 . ( R1 + 1 ) ) = R16) & (( C184 . R1 ) nin (the s_empty of R15) implies ( C184 . ( R1 + 1 ) ) = ( pop ( C184 . R1 ) ))) by L665 , MATRIX_7:def 1;
thus L667:  emp R17 by L666 , L663 , L94;
L668: C185 is (RedSequence of D89)
proof
thus L669: ( len C185 ) > ( 0 ) by L662;
let C186 being (Element of ( NAT ));
assume L670: (C186 in ( dom C185 ) & ( C186 + 1 ) in ( dom C185 ));
L671: (C186 >= 1 & C186 <= ( R1 + 1 ) & ( C186 + 1 ) <= ( R1 + 1 )) by L670 , L662 , FINSEQ_3:25;
L672: (( ( C186 -' 1 ) + 1 ) = C186 & ( ( C186 + 1 ) -' 1 ) = C186 & C186 <= R1) by L671 , NAT_D:34 , XREAL_1:6 , XREAL_1:235;
L673: ( C186 -' 1 ) < R1 by L672 , NAT_1:13;
L674: (not  emp ( C184 . ( C186 -' 1 ) )) by L673 , L661;
L675: ( C184 . ( C186 -' 1 ) ) nin (the s_empty of R15) by L674 , L94;
L676: (( C185 . C186 ) = ( C184 . ( C186 -' 1 ) ) & ( C185 . ( C186 + 1 ) ) = ( C184 . C186 )) by L662 , L670 , L672;
L677: S22[ ( C186 -' 1 ) , ( C184 . ( C186 -' 1 ) ) , ( C185 . ( C186 + 1 ) ) ] by L676 , L659 , L672;
L678: ( C185 . ( C186 + 1 ) ) = ( pop ( C184 . ( C186 -' 1 ) ) ) by L677 , L675 , MATRIX_7:def 1;
thus L679: [ ( C185 . C186 ) , ( C185 . ( C186 + 1 ) ) ] in D89 by L678 , L676 , L674 , L583;
end;
L680: 1 in ( dom C185 ) by L668 , FINSEQ_5:6;
L681: ( C185 . 1 ) = ( C184 . ( 1 -' 1 ) ) by L680 , L662
.= R16 by L659 , XREAL_1:232;
reconsider D90 = C185 as (the carrier' of R15) -valued (RedSequence of D89) by L681 , L668 , L589;
take D90;
thus L682: ( D90 . 1 ) = R16 by L681;
L683: ( len D90 ) in ( dom D90 ) by FINSEQ_5:6;
thus L684: ( D90 . ( len D90 ) ) = ( C184 . ( ( R1 + 1 ) -' 1 ) ) by L683 , L662
.= R17 by L663 , NAT_D:34;
let C187 being Nat;
assume L685: (1 <= C187 & C187 < ( len D90 ));
L686: C187 in ( dom D90 ) by L685 , FINSEQ_3:25;
L687: (( D90 . C187 ) = ( C184 . ( C187 -' 1 ) ) & ( D90 . C187 ) = ( D90 /. C187 )) by L686 , L662 , PARTFUN1:def 6;
L688: (1 <= ( C187 + 1 ) & ( C187 + 1 ) <= ( len D90 )) by L685 , NAT_1:13;
L689: ( C187 + 1 ) in ( dom D90 ) by L688 , FINSEQ_3:25;
L690: (( D90 . ( C187 + 1 ) ) = ( C184 . ( ( C187 + 1 ) -' 1 ) ) & ( D90 . ( C187 + 1 ) ) = ( D90 /. ( C187 + 1 ) )) by L689 , L662 , PARTFUN1:def 6;
L691: (( ( C187 -' 1 ) + 1 ) = C187 & ( ( C187 + 1 ) -' 1 ) = C187) by L685 , NAT_D:34 , XREAL_1:235;
L692: ( C187 -' 1 ) < R1 by L691 , L662 , L685 , XREAL_1:6;
thus L693: (not  emp ( D90 /. C187 )) by L692 , L661 , L687;
L694: ( D90 /. C187 ) nin (the s_empty of R15) by L693 , L94;
L695: ( C184 . C187 ) = ( IFIN (( C184 . ( C187 -' 1 ) ) , (the s_empty of R15) , R16 , ( pop ( C184 . ( C187 -' 1 ) ) )) ) by L659 , L691;
thus L696: ( D90 /. ( C187 + 1 ) ) = ( pop ( D90 /. C187 ) ) by L695 , L687 , L690 , L691 , L694 , MATRIX_7:def 1;
end;
uniqueness
proof
let C188 , C189 being (stack of R15);
assume that
L697:  emp C188;
given C190 being (the carrier' of R15) -valued (RedSequence of ( ConstructionRed R15 )) such that
L698: (( C190 . 1 ) = R16 & ( C190 . ( len C190 ) ) = C188)
and
L699: (for R1 being Nat holds ((1 <= R1 & R1 < ( len C190 )) implies ((not  emp ( C190 /. R1 )) & ( C190 /. ( R1 + 1 ) ) = ( pop ( C190 /. R1 ) ))));

assume L700:  emp C189;
given C191 being (the carrier' of R15) -valued (RedSequence of ( ConstructionRed R15 )) such that
L701: (( C191 . 1 ) = R16 & ( C191 . ( len C191 ) ) = C189)
and
L702: (for R1 being Nat holds ((1 <= R1 & R1 < ( len C191 )) implies ((not  emp ( C191 /. R1 )) & ( C191 /. ( R1 + 1 ) ) = ( pop ( C191 /. R1 ) ))));

L703: (( len C190 ) in ( dom C190 ) & ( len C191 ) in ( dom C191 ) & 1 in ( dom C190 ) & 1 in ( dom C191 )) by FINSEQ_5:6;
defpred S24[ Nat ] means (($1 in ( dom C190 ) iff $1 in ( dom C191 )) & ($1 in ( dom C190 ) implies ( C190 . $1 ) = ( C191 . $1 )));
L704: S24[ ( 0 ) ] by FINSEQ_3:24;
L705: (for R1 being Nat holds (S24[ R1 ] implies S24[ ( R1 + 1 ) ]))
proof
let R1 being Nat;
assume L706: S24[ R1 ];
per cases  by NAT_1:6;
suppose L707: R1 = ( 0 );

thus L708: thesis by L707 , L698 , L701 , FINSEQ_5:6;
end;
suppose L709: (ex R2 being Nat st R1 = ( R2 + 1 ));

consider R2 being Nat such that L710: R1 = ( R2 + 1 ) by L709;
L711: R1 >= 1 by L710 , NAT_1:11;
thus L712:now
assume L713: ( R1 + 1 ) in ( dom C190 );
L714: ( R1 + 1 ) <= ( len C190 ) by L713 , FINSEQ_3:25;
L715: R1 < ( len C190 ) by L714 , NAT_1:13;
L716: (R1 in ( dom C190 ) & (not  emp ( C190 /. R1 ))) by L715 , L699 , L711 , FINSEQ_3:25;
L717: (( len C191 ) <> R1 & R1 <= ( len C191 )) by L716 , L700 , L701 , L706 , FINSEQ_3:25 , PARTFUN1:def 6;
L718: R1 < ( len C191 ) by L717 , XXREAL_0:1;
L719: (1 <= ( R1 + 1 ) & ( R1 + 1 ) <= ( len C191 )) by L718 , NAT_1:11 , NAT_1:13;
thus L720: ( R1 + 1 ) in ( dom C191 ) by L719 , FINSEQ_3:25;
end;
thus L721:now
assume L722: ( R1 + 1 ) in ( dom C191 );
L723: ( R1 + 1 ) <= ( len C191 ) by L722 , FINSEQ_3:25;
L724: R1 < ( len C191 ) by L723 , NAT_1:13;
L725: (R1 in ( dom C191 ) & (not  emp ( C191 /. R1 ))) by L724 , L702 , L711 , FINSEQ_3:25;
L726: (( len C190 ) <> R1 & R1 <= ( len C190 )) by L725 , L697 , L698 , L706 , FINSEQ_3:25 , PARTFUN1:def 6;
L727: R1 < ( len C190 ) by L726 , XXREAL_0:1;
L728: (1 <= ( R1 + 1 ) & ( R1 + 1 ) <= ( len C190 )) by L727 , NAT_1:11 , NAT_1:13;
thus L729: ( R1 + 1 ) in ( dom C190 ) by L728 , FINSEQ_3:25;
end;
assume L730: ( R1 + 1 ) in ( dom C190 );
L731: (( R1 + 1 ) <= ( len C190 ) & ( R1 + 1 ) <= ( len C191 )) by L730 , L712 , FINSEQ_3:25;
L732: (R1 < ( len C190 ) & R1 < ( len C191 )) by L731 , NAT_1:13;
L733: (R1 in ( dom C190 ) & ( C190 /. ( R1 + 1 ) ) = ( pop ( C190 /. R1 ) ) & R1 in ( dom C191 ) & ( C191 /. ( R1 + 1 ) ) = ( pop ( C191 /. R1 ) )) by L732 , L699 , L702 , L711 , FINSEQ_3:25;
L734: (( C190 /. R1 ) = ( C190 . R1 ) & ( C191 /. R1 ) = ( C191 . R1 ) & ( C190 /. ( R1 + 1 ) ) = ( C190 . ( R1 + 1 ) ) & ( C191 /. ( R1 + 1 ) ) = ( C191 . ( R1 + 1 ) )) by L733 , L730 , L712 , PARTFUN1:def 6;
thus L735: thesis by L734 , L706 , L733;
end;
end;
L737: (for R1 being Nat holds S24[ R1 ]) from NAT_1:sch 2(L704 , L705);
L738: ( dom C190 ) = ( dom C191 )
proof
thus L739: ( dom C190 ) c= ( dom C191 )
proof
let R3 being set;
thus L740: thesis by L737;
end;

let R3 being set;
thus L741: thesis by L737;
end;
L742: ( len C190 ) = ( len C191 ) by L738 , FINSEQ_3:29;
thus L743: thesis by L742 , L698 , L701 , L703 , L737;
end;
end;
theorem
L745: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds ( emp R16 implies ( core R16 ) = R16)))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
set D91 = ( ConstructionRed R15 );
assume L746:  emp R16;
consider C192 being (the carrier' of R15) -valued (RedSequence of D91) such that L747: (( C192 . 1 ) = R16 & ( C192 . ( len C192 ) ) = ( core R16 )) and L748: (for R1 being Nat holds ((1 <= R1 & R1 < ( len C192 )) implies ((not  emp ( C192 /. R1 )) & ( C192 /. ( R1 + 1 ) ) = ( pop ( C192 /. R1 ) )))) by L657;
L749: 1 in ( dom C192 ) by FINSEQ_5:6;
L750: ( C192 /. 1 ) = ( C192 . 1 ) by L749 , PARTFUN1:def 6;
L751: (1 <= ( len C192 ) & ( len C192 ) <= 1) by L750 , L746 , L747 , L748 , L749 , FINSEQ_3:25;
thus L752: thesis by L751 , L747 , XXREAL_0:1;
end;
theorem
L753: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds (for R20 being (Element of R15) holds ( core ( push (R20 , R16) ) ) = ( core R16 ))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
let R20 being (Element of R15);
set D92 = ( ConstructionRed R15 );
set D93 = (the carrier' of R15);
L754:  emp ( core R16 ) by L657;
consider C193 being (the carrier' of R15) -valued (RedSequence of D92) such that L755: (( C193 . 1 ) = R16 & ( C193 . ( len C193 ) ) = ( core R16 )) and L756: (for R1 being Nat holds ((1 <= R1 & R1 < ( len C193 )) implies ((not  emp ( C193 /. R1 )) & ( C193 /. ( R1 + 1 ) ) = ( pop ( C193 /. R1 ) )))) by L657;
L757: ((not  emp ( push (R20 , R16) )) & ( pop ( push (R20 , R16) ) ) = R16) by L169 , L170;
L758: [ ( push (R20 , R16) ) , R16 ] in D92 by L757 , L583;
reconsider D94 = <* ( push (R20 , R16) ) , R16 *> as (RedSequence of D92) by L758 , REWRITE1:7;
L759: (( D94 . 2 ) = R16 & ( len D94 ) = 2) by FINSEQ_1:44;
reconsider D95 = ( D94 $^ C193 ) as (RedSequence of D92) by L759 , L755 , REWRITE1:8;
L760: D95 = ( <* ( push (R20 , R16) ) *> ^ C193 ) by REWRITE1:2;
L761: ( D95 . 1 ) = ( push (R20 , R16) ) by L760 , FINSEQ_1:41;
reconsider D96 = D95 as D93 -valued (RedSequence of D92) by L761 , L589;
L762: ( len <* ( push (R20 , R16) ) *> ) = 1 by FINSEQ_1:40;
L763: ( len D96 ) = ( 1 + ( len C193 ) ) by L762 , L760 , FINSEQ_1:22;
L764: ( len C193 ) in ( dom C193 ) by FINSEQ_5:6;
L765: ( D96 . ( len D96 ) ) = ( C193 . ( len C193 ) ) by L764 , L760 , L762 , L763 , FINSEQ_1:def 7;
L766:
now
let R1 being Nat;
assume L767: (1 <= R1 & R1 < ( len D96 ));
L768: R1 in ( NAT ) by ORDINAL1:def 12;
L769: (R1 in ( dom D96 ) & ( R1 + 1 ) in ( dom D96 )) by L768 , L767 , MSUALG_8:1;
L770: (( D96 /. R1 ) = ( D96 . R1 ) & ( D96 /. ( R1 + 1 ) ) = ( D96 . ( R1 + 1 ) )) by L769 , PARTFUN1:def 6;
consider R2 being Nat such that L771: R1 = ( 1 + R2 ) by L767 , NAT_1:10;
L772: R2 < ( len C193 ) by L763 , L767 , L771 , XREAL_1:6;
per cases  by L767 , XXREAL_0:1;
suppose L773: R1 = 1;

thus L774: (not  emp ( D96 /. R1 )) by L773 , L761 , L770 , L170;
L775: 1 in ( dom C193 ) by FINSEQ_5:6;
thus L776: ( D96 /. ( R1 + 1 ) ) = ( C193 . 1 ) by L775 , L760 , L762 , L770 , L773 , FINSEQ_1:def 7
.= ( pop ( D96 /. R1 ) ) by L773 , L755 , L761 , L770 , L169;
end;
suppose L777: R1 > 1;

L778: (R2 >= 1 & R2 in ( NAT )) by L777 , L771 , NAT_1:13 , ORDINAL1:def 12;
L779: (R2 in ( dom C193 ) & R1 in ( dom C193 )) by L778 , L771 , L772 , MSUALG_8:1;
L780: (( C193 . R2 ) = ( D96 . R1 ) & ( C193 /. R2 ) = ( C193 . R2 ) & ( C193 . R1 ) = ( D96 . ( R1 + 1 ) ) & ( C193 /. R1 ) = ( C193 . R1 )) by L779 , L760 , L762 , L771 , FINSEQ_1:def 7 , PARTFUN1:def 6;
thus L781: ((not  emp ( D96 /. R1 )) & ( D96 /. ( R1 + 1 ) ) = ( pop ( D96 /. R1 ) )) by L780 , L756 , L770 , L771 , L772 , L778;
end;
end;
thus L783: thesis by L766 , L754 , L755 , L761 , L765 , L657;
end;
theorem
L784: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds ((not  emp R16) implies ( core ( pop R16 ) ) = ( core R16 ))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
set D97 = ( ConstructionRed R15 );
set D98 = (the carrier' of R15);
assume L785: (not  emp R16);
L786:  emp ( core ( pop R16 ) ) by L657;
consider C194 being (the carrier' of R15) -valued (RedSequence of D97) such that L787: (( C194 . 1 ) = ( pop R16 ) & ( C194 . ( len C194 ) ) = ( core ( pop R16 ) )) and L788: (for R1 being Nat holds ((1 <= R1 & R1 < ( len C194 )) implies ((not  emp ( C194 /. R1 )) & ( C194 /. ( R1 + 1 ) ) = ( pop ( C194 /. R1 ) )))) by L657;
L789: [ R16 , ( pop R16 ) ] in D97 by L785 , L583;
reconsider D99 = <* R16 , ( pop R16 ) *> as (RedSequence of D97) by L789 , REWRITE1:7;
L790: (( D99 . 2 ) = ( pop R16 ) & ( len D99 ) = 2) by FINSEQ_1:44;
reconsider D100 = ( D99 $^ C194 ) as (RedSequence of D97) by L790 , L787 , REWRITE1:8;
L791: D100 = ( <* R16 *> ^ C194 ) by REWRITE1:2;
L792: ( D100 . 1 ) = R16 by L791 , FINSEQ_1:41;
reconsider D101 = D100 as D98 -valued (RedSequence of D97) by L792 , L589;
L793: ( len <* R16 *> ) = 1 by FINSEQ_1:40;
L794: ( len D101 ) = ( 1 + ( len C194 ) ) by L793 , L791 , FINSEQ_1:22;
L795: ( len C194 ) in ( dom C194 ) by FINSEQ_5:6;
L796: ( D101 . ( len D101 ) ) = ( C194 . ( len C194 ) ) by L795 , L791 , L793 , L794 , FINSEQ_1:def 7;
L797:
now
let R1 being Nat;
assume L798: (1 <= R1 & R1 < ( len D101 ));
L799: R1 in ( NAT ) by ORDINAL1:def 12;
L800: (R1 in ( dom D101 ) & ( R1 + 1 ) in ( dom D101 )) by L799 , L798 , MSUALG_8:1;
L801: (( D101 /. R1 ) = ( D101 . R1 ) & ( D101 /. ( R1 + 1 ) ) = ( D101 . ( R1 + 1 ) )) by L800 , PARTFUN1:def 6;
consider R2 being Nat such that L802: R1 = ( 1 + R2 ) by L798 , NAT_1:10;
L803: R2 < ( len C194 ) by L794 , L798 , L802 , XREAL_1:6;
per cases  by L798 , XXREAL_0:1;
suppose L804: R1 = 1;

thus L805: (not  emp ( D101 /. R1 )) by L804 , L785 , L791 , L801 , FINSEQ_1:41;
L806: 1 in ( dom C194 ) by FINSEQ_5:6;
thus L807: ( D101 /. ( R1 + 1 ) ) = ( C194 . 1 ) by L806 , L791 , L793 , L801 , L804 , FINSEQ_1:def 7
.= ( pop ( D101 /. R1 ) ) by L804 , L787 , L791 , L801 , FINSEQ_1:41;
end;
suppose L808: R1 > 1;

L809: (R2 >= 1 & R2 in ( NAT )) by L808 , L802 , NAT_1:13 , ORDINAL1:def 12;
L810: (R2 in ( dom C194 ) & R1 in ( dom C194 )) by L809 , L802 , L803 , MSUALG_8:1;
L811: (( C194 . R2 ) = ( D101 . R1 ) & ( C194 /. R2 ) = ( C194 . R2 ) & ( C194 . R1 ) = ( D101 . ( R1 + 1 ) ) & ( C194 /. R1 ) = ( C194 . R1 )) by L810 , L791 , L793 , L802 , FINSEQ_1:def 7 , PARTFUN1:def 6;
thus L812: ((not  emp ( D101 /. R1 )) & ( D101 /. ( R1 + 1 ) ) = ( pop ( D101 /. R1 ) )) by L811 , L788 , L801 , L802 , L803 , L809;
end;
end;
thus L814: thesis by L797 , L786 , L787 , L792 , L796 , L657;
end;
theorem
L815: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds ( core R16 ) in ( coset R16 )))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
consider C195 being (the carrier' of R15) -valued (RedSequence of ( ConstructionRed R15 )) such that L816: (( C195 . 1 ) = R16 & ( C195 . ( len C195 ) ) = ( core R16 )) and L817: (for R1 being Nat holds ((1 <= R1 & R1 < ( len C195 )) implies ((not  emp ( C195 /. R1 )) & ( C195 /. ( R1 + 1 ) ) = ( pop ( C195 /. R1 ) )))) by L657;
L818: ( ConstructionRed R15 ) reduces R16 , ( core R16 ) by L816 , REWRITE1:def 3;
L819: ( core R16 ) in { R17 where R17 is (stack of R15) : ( ConstructionRed R15 ) reduces R16 , R17 } by L818;
thus L820: thesis by L819 , L631;
end;
theorem
L821: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds (for B133 being (Element of ( (the carrier of R15) * )) holds (ex R17 being (stack of R15) st (|. R17 .| = B133 & R17 in ( coset R16 ))))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
set D102 = (the carrier of R15);
defpred S25[ (FinSequence of D102) ] means (ex R17 being (stack of R15) st (|. R17 .| = $1 & R17 in ( coset R16 )));
L822:  emp ( core R16 ) by L657;
L823: |. ( core R16 ) .| = ( {} ) by L822 , L416;
L824: S25[ ( <*> D102 ) ] by L823 , L815;
L825:
now
let C196 being (FinSequence of D102);
let C197 being (Element of D102);
assume L826: S25[ C196 ];
consider R17 being (stack of R15) such that L827: (|. R17 .| = C196 & R17 in ( coset R16 )) by L826;
thus L828: S25[ ( <* C197 *> ^ C196 ) ]
proof
take D103 = ( push (C197 , R17) );
thus L829: thesis by L827 , L429 , L525;
end;

end;
L829: (for B134 being (FinSequence of D102) holds S25[ B134 ]) from IndSeqD(L824 , L825);
thus L830: thesis by L829;
end;
theorem
L831: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds (for R17 being (stack of R15) holds (R17 in ( coset R16 ) implies ( core R17 ) = ( core R16 )))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
let R17 being (stack of R15);
assume L832: R17 in ( coset R16 );
set D104 = ( ConstructionRed R15 );
defpred S26[ (stack of R15) ] means ( core $1 ) = ( core R16 );
L833: S26[ R16 ];
L834: ( coset R16 ) = { R18 where R18 is (stack of R15) : D104 reduces R16 , R18 } by L631;
L835: (ex R18 being (stack of R15) st (R17 = R18 & D104 reduces R16 , R18)) by L834 , L832;
L836: D104 reduces R16 , R17 by L835;
L837:
now
let C198 , C199 being (stack of R15);
assume L838: (D104 reduces R16 , C198 & [ C198 , C199 ] in D104 & S26[ C198 ]);
L839: (((not  emp C198) & C199 = ( pop C198 )) or (ex R20 being (Element of R15) st C199 = ( push (R20 , C198) ))) by L838 , L583;
thus L840: S26[ C199 ] by L839 , L838 , L753 , L784;
end;
thus L841: S26[ R17 ] from PathIND(L833 , L836 , L837);
end;
theorem
L842: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds ((R17 in ( coset R16 ) & R18 in ( coset R16 ) & |. R17 .| = |. R18 .|) implies R17 = R18)))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
let R17 being (stack of R15);
let R18 being (stack of R15);
defpred S27[ (stack of R15) ] means (for R18 being (stack of R15) holds (($1 in ( coset R16 ) & R18 in ( coset R16 ) & |. $1 .| = |. R18 .|) implies $1 = R18));
L843: (for R17 being (stack of R15) holds ( emp R17 implies S27[ R17 ]))
proof
let R17 being (stack of R15);
assume L844:  emp R17;
L845: |. R17 .| = ( {} ) by L844 , L416;
let R18 being (stack of R15);
assume L846: (R17 in ( coset R16 ) & R18 in ( coset R16 ) & |. R17 .| = |. R18 .|);
L847: (( core R17 ) = ( core R16 ) & ( core R18 ) = ( core R16 ) &  emp R18) by L846 , L845 , L436 , L831;
L848: (( core R16 ) = R17 & ( core R16 ) = R18) by L847 , L844 , L745;
thus L849: thesis by L848;
end;
L850:
now
let C200 being (stack of R15);
let C201 being (Element of R15);
assume that
L851: S27[ C200 ];
thus L852: S27[ ( push (C201 , C200) ) ]
proof
let R18 being (stack of R15);
assume L853: (( push (C201 , C200) ) in ( coset R16 ) & R18 in ( coset R16 ) & |. ( push (C201 , C200) ) .| = |. R18 .|);
L854: |. R18 .| = ( <* C201 *> ^ |. C200 .| ) by L853 , L429;
L855: (not  emp R18) by L854 , L416;
L856: R18 = ( push (( top R18 ) , ( pop R18 )) ) by L855 , L167;
L857: (C200 in ( coset R16 ) & ( pop R18 ) in ( coset R16 )) by L856 , L853 , L552;
L858: |. R18 .| = ( <* ( top R18 ) *> ^ |. ( pop R18 ) .| ) by L856 , L429;
L859: (C201 = ( |. R18 .| . 1 ) & ( |. R18 .| . 1 ) = ( top R18 ) & |. C200 .| = |. ( pop R18 ) .|) by L858 , L854 , FINSEQ_1:41 , HILBERT2:2;
thus L860: thesis by L859 , L851 , L856 , L857;
end;

end;
L853: S27[ R17 ] from INDsch(L843 , L850);
thus L854: thesis by L853;
end;
theorem
L855: (for R15 being StackAlgebra holds (for R17 being (stack of R15) holds (for R18 being (stack of R15) holds (ex R16 being (stack of R15) st ( ( coset R17 ) /\ ( Class (( ==_ R15 ) , R18) ) ) = { R16 }))))
proof
let R15 being StackAlgebra;
let R17 being (stack of R15);
let R18 being (stack of R15);
consider R16 being (stack of R15) such that L856: (|. R16 .| = |. R18 .| & R16 in ( coset R17 )) by L821;
take R16;
thus L857: ( ( coset R17 ) /\ ( Class (( ==_ R15 ) , R18) ) ) c= { R16 }
proof
let R3 being set;
assume L858: R3 in ( ( coset R17 ) /\ ( Class (( ==_ R15 ) , R18) ) );
L859: (R3 in ( coset R17 ) & R3 in ( Class (( ==_ R15 ) , R18) )) by L858 , XBOOLE_0:def 4;
reconsider D105 = R3 as (stack of R15) by L858;
L860: [ R18 , D105 ] in ( ==_ R15 ) by L859 , EQREL_1:18;
L861: R18 == D105 by L860 , L489;
L862: |. R18 .| = |. D105 .| by L861 , L459;
L863: R16 = D105 by L862 , L856 , L859 , L842;
thus L864: thesis by L863 , TARSKI:def 1;
end;

L865: R16 == R18 by L856 , L459;
L866: [ R18 , R16 ] in ( ==_ R15 ) by L865 , L489;
L867: R16 in ( Class (( ==_ R15 ) , R18) ) by L866 , EQREL_1:18;
L868: ({ R16 } c= ( Class (( ==_ R15 ) , R18) ) & { R16 } c= ( coset R17 )) by L867 , L856 , ZFMISC_1:31;
thus L869: thesis by L868 , XBOOLE_1:19;
end;
begin
definition
let R15 being StackAlgebra;
func R15 /== ->  strict StackSystem means 
:L870: ((the carrier of it) = (the carrier of R15) & (the carrier' of it) = ( Class ( ==_ R15 ) ) & (the s_empty of it) = { (the s_empty of R15) } & (the s_push of it) = ( (the s_push of R15) /\/ ( ==_ R15 ) ) & (the s_pop of it) = ( ( (the s_pop of R15) +* ( id (the s_empty of R15) ) ) /\/ ( ==_ R15 ) ) & (for B135 being (Choice_Function of ( Class ( ==_ R15 ) )) holds (the s_top of it) = ( ( (the s_top of R15) * B135 ) +* ((the s_empty of R15) , the (Element of (the carrier of R15))) )));
uniqueness
proof
let C202 , C203 being  strict StackSystem;
assume that
L871: ((the carrier of C202) = (the carrier of R15) & (the carrier' of C202) = ( Class ( ==_ R15 ) ) & (the s_empty of C202) = { (the s_empty of R15) } & (the s_push of C202) = ( (the s_push of R15) /\/ ( ==_ R15 ) ) & (the s_pop of C202) = ( ( (the s_pop of R15) +* ( id (the s_empty of R15) ) ) /\/ ( ==_ R15 ) ))
and
L872: (for B136 being (Choice_Function of ( Class ( ==_ R15 ) )) holds (the s_top of C202) = ( ( (the s_top of R15) * B136 ) +* ((the s_empty of R15) , the (Element of (the carrier of R15))) ))
and
L873: ((the carrier of C203) = (the carrier of R15) & (the carrier' of C203) = ( Class ( ==_ R15 ) ) & (the s_empty of C203) = { (the s_empty of R15) } & (the s_push of C203) = ( (the s_push of R15) /\/ ( ==_ R15 ) ) & (the s_pop of C203) = ( ( (the s_pop of R15) +* ( id (the s_empty of R15) ) ) /\/ ( ==_ R15 ) ))
and
L874: (for B137 being (Choice_Function of ( Class ( ==_ R15 ) )) holds (the s_top of C203) = ( ( (the s_top of R15) * B137 ) +* ((the s_empty of R15) , the (Element of (the carrier of R15))) ));
set D106 = the (Choice_Function of ( Class ( ==_ R15 ) ));
L875: ((the s_top of C202) = ( ( (the s_top of R15) * D106 ) +* ((the s_empty of R15) , the (Element of (the carrier of R15))) ) & (the s_top of C203) = ( ( (the s_top of R15) * D106 ) +* ((the s_empty of R15) , the (Element of (the carrier of R15))) )) by L872 , L874;
thus L876: thesis by L875 , L871 , L873;
end;
existence
proof
set D107 = the (Choice_Function of ( Class ( ==_ R15 ) ));
L877: ( union ( Class ( ==_ R15 ) ) ) = (the carrier' of R15) by EQREL_1:def 4;
reconsider D108 = D107 as (Function of ( Class ( ==_ R15 ) ) , (the carrier' of R15)) by L877;
consider R16 being (stack of R15) such that L878:  emp R16 by L207;
L879: ( Class (( ==_ R15 ) , R16) ) = (the s_empty of R15) by L878 , L512;
reconsider D109 = ( Class (( ==_ R15 ) , R16) ) as (Element of ( Class ( ==_ R15 ) )) by EQREL_1:def 3;
set D110 = ( (the s_top of R15) * D108 );
take D111 = StackSystem (# (the carrier of R15) , ( Class ( ==_ R15 ) ) , { D109 } , ( (the s_push of R15) /\/ ( ==_ R15 ) ) , ( ( (the s_pop of R15) +* ( id (the s_empty of R15) ) ) /\/ ( ==_ R15 ) ) , ( D110 +* ((the s_empty of R15) , the (Element of (the carrier of R15))) ) #);
thus L880: ((the carrier of D111) = (the carrier of R15) & (the carrier' of D111) = ( Class ( ==_ R15 ) ) & (the s_empty of D111) = { (the s_empty of R15) } & (the s_push of D111) = ( (the s_push of R15) /\/ ( ==_ R15 ) ) & (the s_pop of D111) = ( ( (the s_pop of R15) +* ( id (the s_empty of R15) ) ) /\/ ( ==_ R15 ) )) by L878 , L512;
let C204 being (Choice_Function of ( Class ( ==_ R15 ) ));
reconsider D112 = C204 as (Function of ( Class ( ==_ R15 ) ) , (the carrier' of R15)) by L877;
L881:
now
let C205 being (Element of ( Class ( ==_ R15 ) ));
consider R17 being (stack of R15) such that L882: C205 = ( Class (( ==_ R15 ) , R17) ) by EQREL_1:36;
per cases ;
suppose L883:  emp R17;

L884: (R17 in (the s_empty of R15) & ( dom D110 ) = ( Class ( ==_ R15 ) ) & ( dom ( (the s_top of R15) * D112 ) ) = ( Class ( ==_ R15 ) )) by L883 , L94 , FUNCT_2:def 1;
L885: (C205 = D109 & D109 in ( dom D110 ) & D109 in ( dom ( (the s_top of R15) * D112 ) )) by L884 , L879 , L882 , EQREL_1:23;
L886: ( ( D110 +* ((the s_empty of R15) , the (Element of (the carrier of R15))) ) . C205 ) = the (Element of (the carrier of R15)) by L885 , L879 , FUNCT_7:31;
thus L887: ( ( D110 +* ((the s_empty of R15) , the (Element of (the carrier of R15))) ) . C205 ) = ( ( ( (the s_top of R15) * D112 ) +* ((the s_empty of R15) , the (Element of (the carrier of R15))) ) . C205 ) by L886 , L879 , L885 , FUNCT_7:31;
end;
suppose L888: (not  emp R17);

L889: R17 nin D109 by L888 , L879 , L94;
L890: C205 <> D109 by L889 , L882 , EQREL_1:23;
L891: ( {} ) nin ( Class ( ==_ R15 ) ) by SETFAM_1:def 8;
L892: (( D108 . C205 ) in C205 & ( C204 . C205 ) in C205) by L891 , ORDERS_1:def 1;
L893: ([ R17 , ( D108 . C205 ) ] in ( ==_ R15 ) & [ R17 , ( C204 . C205 ) ] in ( ==_ R15 )) by L892 , L882 , EQREL_1:18;
L894: (R17 == ( D108 . C205 ) & R17 == ( D112 . C205 )) by L893 , L489;
L895: (( D108 . C205 ) == ( D112 . C205 ) & (not  emp ( D108 . C205 ))) by L894 , L888 , L461 , L464;
L896: ( top ( D108 . C205 ) ) = ( top ( D112 . C205 ) ) by L895 , L480;
L897: ( D110 . C205 ) = ( top ( D112 . C205 ) ) by L896 , FUNCT_2:15;
L898: ( D110 . C205 ) = ( ( (the s_top of R15) * D112 ) . C205 ) by L897 , FUNCT_2:15;
L899: ( ( D110 +* ((the s_empty of R15) , the (Element of (the carrier of R15))) ) . C205 ) = ( ( (the s_top of R15) * D112 ) . C205 ) by L898 , L879 , L890 , FUNCT_7:32;
thus L900: ( ( D110 +* ((the s_empty of R15) , the (Element of (the carrier of R15))) ) . C205 ) = ( ( ( (the s_top of R15) * D112 ) +* ((the s_empty of R15) , the (Element of (the carrier of R15))) ) . C205 ) by L899 , L879 , L890 , FUNCT_7:32;
end;
end;
thus L902: (the s_top of D111) = ( ( (the s_top of R15) * C204 ) +* ((the s_empty of R15) , the (Element of (the carrier of R15))) ) by L881 , FUNCT_2:63;
end;
end;
registration
let R15 being StackAlgebra;
cluster ( R15 /== ) -> non  empty non  void;
coherence
proof
L904: ((the carrier of ( R15 /== )) = (the carrier of R15) & (the carrier' of ( R15 /== )) = ( Class ( ==_ R15 ) )) by L870;
thus L905: thesis by L904;
end;
end;
theorem
L907: (for R15 being StackAlgebra holds (for B138 being (stack of ( R15 /== )) holds (ex R16 being (stack of R15) st B138 = ( Class (( ==_ R15 ) , R16) ))))
proof
let R15 being StackAlgebra;
let C206 being (stack of ( R15 /== ));
L908: (the carrier' of ( R15 /== )) = ( Class ( ==_ R15 ) ) by L870;
L909: C206 in ( Class ( ==_ R15 ) ) by L908;
L910: (ex R3 being set st (R3 in (the carrier' of R15) & C206 = ( Class (( ==_ R15 ) , R3) ))) by L909 , EQREL_1:def 3;
thus L911: thesis by L910;
end;
theorem
L912: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds ( Class (( ==_ R15 ) , R16) ) is (stack of ( R15 /== ))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
L913: (the carrier' of ( R15 /== )) = ( Class ( ==_ R15 ) ) by L870;
thus L914: thesis by L913 , EQREL_1:def 3;
end;
theorem
L915: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds (for B139 being (stack of ( R15 /== )) holds (B139 = ( Class (( ==_ R15 ) , R16) ) implies ( emp R16 iff  emp B139)))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
let C207 being (stack of ( R15 /== ));
assume L916: C207 = ( Class (( ==_ R15 ) , R16) );
consider R17 being (stack of R15) such that L917:  emp R17 by L207;
L918: ( emp C207 iff C207 in (the s_empty of ( R15 /== ))) by L94;
L919: ( emp C207 iff C207 in { (the s_empty of R15) }) by L918 , L870;
L920: ( emp C207 iff C207 = (the s_empty of R15)) by L919 , TARSKI:def 1;
L921: ( emp C207 iff C207 = ( Class (( ==_ R15 ) , R17) )) by L920 , L917 , L512;
L922: ( emp C207 iff [ R16 , R17 ] in ( ==_ R15 )) by L921 , L916 , EQREL_1:35;
L923: ( emp C207 iff R16 == R17) by L922 , L489;
thus L924: ( emp R16 iff  emp C207) by L923 , L917 , L464 , L469;
end;
theorem
L925: (for R15 being StackAlgebra holds (for B140 being (stack of ( R15 /== )) holds ( emp B140 iff B140 = (the s_empty of R15))))
proof
let R15 being StackAlgebra;
let C208 being (stack of ( R15 /== ));
L926: (the carrier' of ( R15 /== )) = ( Class ( ==_ R15 ) ) by L870;
L927: C208 in ( Class ( ==_ R15 ) ) by L926;
consider R3 being set such that L928: (R3 in (the carrier' of R15) & C208 = ( Class (( ==_ R15 ) , R3) )) by L927 , EQREL_1:def 3;
reconsider D113 = R3 as (stack of R15) by L928;
thus L929:now
assume L930:  emp C208;
L931:  emp D113 by L930 , L928 , L915;
thus L932: C208 = (the s_empty of R15) by L931 , L928 , L512;
end;
assume L933: C208 = (the s_empty of R15);
L934: D113 in (the s_empty of R15) by L933 , L928 , EQREL_1:20;
L935:  emp D113 by L934 , L94;
thus L936: thesis by L935 , L928 , L915;
end;
theorem
L937: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds (for R20 being (Element of R15) holds (for B141 being (stack of ( R15 /== )) holds (for B142 being (Element of ( R15 /== )) holds ((B141 = ( Class (( ==_ R15 ) , R16) ) & B142 = R20) implies (( push (R20 , R16) ) in ( push (B142 , B141) ) & ( Class (( ==_ R15 ) , ( push (R20 , R16) )) ) = ( push (B142 , B141) ))))))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
let R20 being (Element of R15);
let C209 being (stack of ( R15 /== ));
let C210 being (Element of ( R15 /== ));
assume L938: C209 = ( Class (( ==_ R15 ) , R16) );
assume L939: C210 = R20;
L940: R16 in C209 by L938 , EQREL_1:20;
L941: C209 in ( Class ( ==_ R15 ) ) by L938 , EQREL_1:def 3;
L942: (the s_push of R15) is (BinOp of (the carrier of R15) , (the carrier' of R15) , ( ==_ R15 ))
proof
let C211 being (Element of R15);
let C212 , C213 being (stack of R15);
assume L943: [ C212 , C213 ] in ( ==_ R15 );
L944: C212 == C213 by L943 , L489;
L945: ( push (C211 , C212) ) == ( push (C211 , C213) ) by L944 , L473;
thus L946: [ ( (the s_push of R15) . (C211 , C212) ) , ( (the s_push of R15) . (C211 , C213) ) ] in ( ==_ R15 ) by L945 , L489;
end;
L947: ( push (C210 , C209) ) = ( ( (the s_push of R15) /\/ ( ==_ R15 ) ) . (C210 , C209) ) by L870
.= ( Class (( ==_ R15 ) , ( push (R20 , R16) )) ) by L939 , L940 , L941 , L942 , L42;
thus L948: thesis by L947 , EQREL_1:20;
end;
theorem
L949: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds (for B143 being (stack of ( R15 /== )) holds ((B143 = ( Class (( ==_ R15 ) , R16) ) & (not  emp R16)) implies (( pop R16 ) in ( pop B143 ) & ( Class (( ==_ R15 ) , ( pop R16 )) ) = ( pop B143 ))))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
set D114 = (the s_pop of R15);
set D115 = ( id (the s_empty of R15) );
let C214 being (stack of ( R15 /== ));
assume L950: C214 = ( Class (( ==_ R15 ) , R16) );
assume L951: (not  emp R16);
L952: R16 in C214 by L950 , EQREL_1:20;
L953: C214 in ( Class ( ==_ R15 ) ) by L950 , EQREL_1:def 3;
L954: ( dom D115 ) = (the s_empty of R15);
L955: ( D114 +* D115 ) is (UnOp of (the carrier' of R15) , ( ==_ R15 ))
proof
let C215 , C216 being (stack of R15);
assume L956: [ C215 , C216 ] in ( ==_ R15 );
L957: C215 == C216 by L956 , L489;
per cases ;
suppose L958: (not  emp C215);

L959: (not  emp C216) by L958 , L957 , L464;
L960: (C215 nin (the s_empty of R15) & C216 nin (the s_empty of R15)) by L959 , L958 , L94;
L961: (( ( D114 +* D115 ) . C215 ) = ( D114 . C215 ) & ( ( D114 +* D115 ) . C216 ) = ( D114 . C216 )) by L960 , L954 , FUNCT_4:11;
L962: ( pop C215 ) == ( pop C216 ) by L957 , L958 , L476;
thus L963: [ ( ( D114 +* D115 ) . C215 ) , ( ( D114 +* D115 ) . C216 ) ] in ( ==_ R15 ) by L962 , L961 , L489;
end;
suppose L964:  emp C215;

L965:  emp C216 by L964 , L957 , L464;
L966: (C215 in (the s_empty of R15) & C216 in (the s_empty of R15)) by L965 , L964 , L94;
L967: (( ( D114 +* D115 ) . C215 ) = ( D115 . C215 ) & ( D115 . C215 ) = C215 & ( ( D114 +* D115 ) . C216 ) = ( D115 . C216 ) & ( D115 . C216 ) = C216) by L966 , L954 , FUNCT_1:18 , FUNCT_4:13;
thus L968: thesis by L967 , L956;
end;
end;
L970: R16 nin (the s_empty of R15) by L951 , L94;
L971: ( pop C214 ) = ( ( ( D114 +* D115 ) /\/ ( ==_ R15 ) ) . C214 ) by L870
.= ( Class (( ==_ R15 ) , ( ( D114 +* D115 ) . R16 )) ) by L952 , L953 , L955 , FILTER_1:def 3
.= ( Class (( ==_ R15 ) , ( pop R16 )) ) by L954 , L970 , FUNCT_4:11;
thus L972: thesis by L971 , EQREL_1:20;
end;
theorem
L973: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds (for B144 being (stack of ( R15 /== )) holds ((B144 = ( Class (( ==_ R15 ) , R16) ) & (not  emp R16)) implies ( top B144 ) = ( top R16 )))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
set D116 = (the s_top of R15);
set D117 = (the s_empty of R15);
set D118 = the (Element of (the carrier of R15));
let C217 being (stack of ( R15 /== ));
assume L974: C217 = ( Class (( ==_ R15 ) , R16) );
assume L975: (not  emp R16);
L976: (not  emp C217) by L975 , L974 , L915;
L977: C217 <> D117 by L976 , L925;
set D119 = the (Choice_Function of ( Class ( ==_ R15 ) ));
L978: (C217 in ( Class ( ==_ R15 ) ) & ( {} ) nin ( Class ( ==_ R15 ) )) by L974 , EQREL_1:def 3 , SETFAM_1:def 8;
L979: ( D119 . C217 ) in C217 by L978 , ORDERS_1:def 1;
reconsider D120 = ( D119 . C217 ) as (stack of R15) by L979 , L974;
L980: [ R16 , D120 ] in ( ==_ R15 ) by L974 , L979 , EQREL_1:18;
L981: R16 == D120 by L980 , L489;
L982: ( dom D119 ) = ( Class ( ==_ R15 ) ) by L978 , RLVECT_3:28;
L983: (the s_top of ( R15 /== )) = ( ( D116 * D119 ) +* (D117 , D118) ) by L870;
thus L984: ( top C217 ) = ( ( D116 * D119 ) . C217 ) by L983 , L977 , FUNCT_7:32
.= ( top D120 ) by L978 , L982 , FUNCT_1:13
.= ( top R16 ) by L981 , L975 , L480;
end;
registration
let R15 being StackAlgebra;
cluster ( R15 /== ) ->  pop-finite;
coherence
proof
let C218 being (Function of ( NAT ) , (the carrier' of ( R15 /== )));
set D121 = the (stack of R15);
defpred S28[ set , set ] means $2 in ( ( coset D121 ) /\ $1 );
L985: (for R3 being set holds (R3 in ( Class ( ==_ R15 ) ) implies (ex R4 being set st (R4 in (the carrier' of R15) & S28[ R3 , R4 ]))))
proof
let R3 being set;
assume L986: R3 in ( Class ( ==_ R15 ) );
consider R18 being (stack of R15) such that L987: R3 = ( Class (( ==_ R15 ) , R18) ) by L986 , EQREL_1:36;
consider R16 being (stack of R15) such that L988: ( ( coset D121 ) /\ ( Class (( ==_ R15 ) , R18) ) ) = { R16 } by L855;
take R16;
thus L989: R16 in (the carrier' of R15);
thus L990: R16 in ( ( coset D121 ) /\ R3 ) by L987 , L988 , TARSKI:def 1;
end;
consider C219 being Function such that L991: (( dom C219 ) = ( Class ( ==_ R15 ) ) & ( rng C219 ) c= (the carrier' of R15) & (for R3 being set holds (R3 in ( Class ( ==_ R15 ) ) implies S28[ R3 , ( C219 . R3 ) ]))) from FUNCT_1:sch 5(L985);
L992: (the carrier' of ( R15 /== )) = ( Class ( ==_ R15 ) ) by L870;
reconsider D122 = C219 as (Function of (the carrier' of ( R15 /== )) , (the carrier' of R15)) by L992 , L991 , FUNCT_2:2;
consider R1 being Nat, R16 being (stack of R15) such that L993: (( ( D122 * C218 ) . R1 ) = R16 & ((not  emp R16) implies ( ( D122 * C218 ) . ( R1 + 1 ) ) <> ( pop R16 ))) by L166;
reconsider D123 = ( Class (( ==_ R15 ) , R16) ) as (stack of ( R15 /== )) by L992 , EQREL_1:def 3;
take R1;
take D123;
consider R18 being (stack of R15) such that L994: ( C218 . R1 ) = ( Class (( ==_ R15 ) , R18) ) by L992 , EQREL_1:36;
L995: R1 in ( NAT ) by ORDINAL1:def 12;
L996: R16 = ( D122 . ( C218 . R1 ) ) by L995 , L993 , FUNCT_2:15;
L997: R16 in ( ( coset D121 ) /\ ( C218 . R1 ) ) by L996 , L991 , L992;
L998: (R16 in ( coset D121 ) & R16 in ( C218 . R1 )) by L997 , XBOOLE_0:def 4;
thus L999: ( C218 . R1 ) = D123 by L998 , L994 , EQREL_1:23;
assume L1000: (not  emp D123);
L1001: (not  emp R16) by L1000 , L915;
assume L1002: ( C218 . ( R1 + 1 ) ) = ( pop D123 );
L1003: ( C218 . ( R1 + 1 ) ) = ( Class (( ==_ R15 ) , ( pop R16 )) ) by L1002 , L1001 , L949;
set D124 = ( D122 . ( C218 . ( R1 + 1 ) ) );
consider C220 being (stack of R15) such that L1004: ( ( coset D121 ) /\ ( C218 . ( R1 + 1 ) ) ) = { C220 } by L1003 , L855;
L1005: (( pop R16 ) in ( coset D121 ) & ( pop R16 ) in ( pop D123 ) & ( pop D123 ) = ( C218 . ( R1 + 1 ) )) by L998 , L1002 , L1001 , L525 , L949;
L1006: ( pop R16 ) in { C220 } by L1005 , L1004 , XBOOLE_0:def 4;
L1007: D124 in ( ( coset D121 ) /\ ( C218 . ( R1 + 1 ) ) ) by L991 , L992;
L1008: (D124 = C220 & ( pop R16 ) = C220) by L1007 , L1004 , L1006 , TARSKI:def 1;
thus L1009: thesis by L1008 , L993 , L1000 , L915 , FUNCT_2:15;
end;
cluster ( R15 /== ) ->  push-pop;
coherence
proof
let C221 being (stack of ( R15 /== ));
consider R16 being (stack of R15) such that L1010: C221 = ( Class (( ==_ R15 ) , R16) ) by L907;
assume L1011: (not  emp C221);
L1012: (not  emp R16) by L1011 , L1010 , L915;
reconsider D125 = ( Class (( ==_ R15 ) , ( pop R16 )) ) as (stack of ( R15 /== )) by L912;
reconsider D126 = ( top R16 ) as (Element of ( R15 /== )) by L870;
thus L1013: C221 = ( Class (( ==_ R15 ) , ( push (( top R16 ) , ( pop R16 )) )) ) by L1010 , L1012 , L167
.= ( push (D126 , D125) ) by L937
.= ( push (( top C221 ) , D125) ) by L1010 , L1012 , L973
.= ( push (( top C221 ) , ( pop C221 )) ) by L1010 , L1012 , L949;
end;
cluster ( R15 /== ) ->  top-push;
coherence
proof
let C222 being (stack of ( R15 /== ));
let C223 being (Element of ( R15 /== ));
consider R16 being (stack of R15) such that L1014: C222 = ( Class (( ==_ R15 ) , R16) ) by L907;
reconsider D127 = C223 as (Element of R15) by L870;
reconsider D128 = ( Class (( ==_ R15 ) , ( push (D127 , R16) )) ) as (stack of ( R15 /== )) by L912;
L1015: (not  emp ( push (D127 , R16) )) by L170;
thus L1016: C223 = ( top ( push (D127 , R16) ) ) by L168
.= ( top D128 ) by L1015 , L973
.= ( top ( push (C223 , C222) ) ) by L1014 , L937;
end;
cluster ( R15 /== ) ->  pop-push;
coherence
proof
let C224 being (stack of ( R15 /== ));
let C225 being (Element of ( R15 /== ));
consider R16 being (stack of R15) such that L1017: C224 = ( Class (( ==_ R15 ) , R16) ) by L907;
reconsider D129 = C225 as (Element of R15) by L870;
reconsider D130 = ( Class (( ==_ R15 ) , ( push (D129 , R16) )) ) as (stack of ( R15 /== )) by L912;
L1018: (not  emp ( push (D129 , R16) )) by L170;
thus L1019: C224 = ( Class (( ==_ R15 ) , ( pop ( push (D129 , R16) ) )) ) by L1017 , L169
.= ( pop D130 ) by L1018 , L949
.= ( pop ( push (C225 , C224) ) ) by L1017 , L937;
end;
cluster ( R15 /== ) ->  push-non-empty;
coherence
proof
let C226 being (stack of ( R15 /== ));
let C227 being (Element of ( R15 /== ));
consider R16 being (stack of R15) such that L1020: C226 = ( Class (( ==_ R15 ) , R16) ) by L907;
reconsider D131 = C227 as (Element of R15) by L870;
reconsider D132 = ( Class (( ==_ R15 ) , ( push (D131 , R16) )) ) as (stack of ( R15 /== )) by L912;
L1021: (not  emp ( push (D131 , R16) )) by L170;
L1022: (not  emp D132) by L1021 , L915;
thus L1023: thesis by L1022 , L1020 , L937;
end;
end;
theorem
L1025: (for R15 being StackAlgebra holds (for R16 being (stack of R15) holds (for B145 being (stack of ( R15 /== )) holds (B145 = ( Class (( ==_ R15 ) , R16) ) implies |. B145 .| = |. R16 .|))))
proof
let R15 being StackAlgebra;
let R16 being (stack of R15);
defpred S29[ (stack of R15) ] means (for B146 being (stack of ( R15 /== )) holds (B146 = ( Class (( ==_ R15 ) , $1) ) implies |. B146 .| = |. $1 .|));
L1026: (for R17 being (stack of R15) holds ( emp R17 implies S29[ R17 ]))
proof
let R17 being (stack of R15);
assume L1027:  emp R17;
let C228 being (stack of ( R15 /== ));
assume L1028: C228 = ( Class (( ==_ R15 ) , R17) );
L1029:  emp C228 by L1028 , L1027 , L915;
L1030: |. C228 .| = ( {} ) by L1029 , L416;
thus L1031: thesis by L1030 , L1027 , L416;
end;
L1032: (for R17 being (stack of R15) holds (for R20 being (Element of R15) holds (S29[ R17 ] implies S29[ ( push (R20 , R17) ) ])))
proof
let R17 being (stack of R15);
let R20 being (Element of R15);
assume L1033: S29[ R17 ];
reconsider D133 = R20 as (Element of ( R15 /== )) by L870;
let C229 being (stack of ( R15 /== ));
assume L1034: C229 = ( Class (( ==_ R15 ) , ( push (R20 , R17) )) );
reconsider D134 = ( Class (( ==_ R15 ) , R17) ) as (stack of ( R15 /== )) by L912;
L1035: C229 = ( push (D133 , D134) ) by L1034 , L937;
thus L1036: |. C229 .| = ( <* D133 *> ^ |. D134 .| ) by L1035 , L429
.= ( <* R20 *> ^ |. R17 .| ) by L1033
.= |. ( push (R20 , R17) ) .| by L429;
end;
thus L1037: S29[ R16 ] from INDsch(L1026 , L1032);
end;
registration
let R15 being StackAlgebra;
cluster ( R15 /== ) ->  proper-for-identity;
coherence
proof
let C230 , C231 being (stack of ( R15 /== ));
consider R17 being (stack of R15) such that L1038: C230 = ( Class (( ==_ R15 ) , R17) ) by L907;
consider R18 being (stack of R15) such that L1039: C231 = ( Class (( ==_ R15 ) , R18) ) by L907;
assume L1040: |. C230 .| = |. C231 .|;
L1041: |. R17 .| = |. C231 .| by L1040 , L1038 , L1025
.= |. R18 .| by L1039 , L1025;
L1042: R17 == R18 by L1041 , L459;
L1043: [ R17 , R18 ] in ( ==_ R15 ) by L1042 , L489;
L1044: R18 in C230 by L1043 , L1038 , EQREL_1:18;
thus L1045: thesis by L1044 , L1038 , L1039 , EQREL_1:23;
end;
end;
registration
cluster  proper-for-identity for StackAlgebra;
existence
proof
take ( the StackAlgebra /== );
thus L1047: thesis;
end;
end;
begin
definition
let C232 , C233 being StackAlgebra;
let C234 , C235 being Function;
pred C234 , C235 form_isomorphism_between C232 , C233
means
:L1049: (( dom C234 ) = (the carrier of C232) & ( rng C234 ) = (the carrier of C233) & C234 is  one-to-one & ( dom C235 ) = (the carrier' of C232) & ( rng C235 ) = (the carrier' of C233) & C235 is  one-to-one & (for B147 being (stack of C232) holds (for B148 being (stack of C233) holds (B148 = ( C235 . B147 ) implies (( emp B147 iff  emp B148) & ((not  emp B147) implies (( pop B148 ) = ( C235 . ( pop B147 ) ) & ( top B148 ) = ( C234 . ( top B147 ) ))) & (for B149 being (Element of C232) holds (for B150 being (Element of C233) holds (B150 = ( C234 . B149 ) implies ( push (B150 , B148) ) = ( C235 . ( push (B149 , B147) ) )))))))))
;end;
theorem
L1051: (for R15 being StackAlgebra holds ( id (the carrier of R15) ) , ( id (the carrier' of R15) ) form_isomorphism_between R15 , R15)
proof
let R15 being StackAlgebra;
set D135 = ( id (the carrier of R15) );
set D136 = ( id (the carrier' of R15) );
thus L1052: (( dom D135 ) = (the carrier of R15) & ( rng D135 ) = (the carrier of R15) & D135 is  one-to-one);
thus L1053: (( dom D136 ) = (the carrier' of R15) & ( rng D136 ) = (the carrier' of R15) & D136 is  one-to-one);
let C236 being (stack of R15);
let C237 being (stack of R15);
assume L1054: C237 = ( D136 . C236 );
L1055: C237 = C236 by L1054 , FUNCT_1:17;
thus L1056: ( emp C236 iff  emp C237) by L1054 , FUNCT_1:17;
thus L1057: ((not  emp C236) implies (( pop C237 ) = ( D136 . ( pop C236 ) ) & ( top C237 ) = ( D135 . ( top C236 ) ))) by L1055 , FUNCT_1:17;
let C238 being (Element of R15);
let C239 being (Element of R15);
assume L1058: C239 = ( D135 . C238 );
L1059: C239 = C238 by L1058 , FUNCT_1:17;
thus L1060: ( push (C239 , C237) ) = ( D136 . ( push (C238 , C236) ) ) by L1059 , L1055 , FUNCT_1:17;
end;
theorem
L1061: (for R24 being StackAlgebra holds (for R25 being StackAlgebra holds (for R27 being Function holds (for R30 being Function holds (R27 , R30 form_isomorphism_between R24 , R25 implies ( R27 " ) , ( R30 " ) form_isomorphism_between R25 , R24)))))
proof
let R24 being StackAlgebra;
let R25 being StackAlgebra;
let R27 being Function;
let R30 being Function;
assume that
L1062: (( dom R27 ) = (the carrier of R24) & ( rng R27 ) = (the carrier of R25) & R27 is  one-to-one)
and
L1063: (( dom R30 ) = (the carrier' of R24) & ( rng R30 ) = (the carrier' of R25) & R30 is  one-to-one)
and
L1064: (for B151 being (stack of R24) holds (for B152 being (stack of R25) holds (B152 = ( R30 . B151 ) implies (( emp B151 iff  emp B152) & ((not  emp B151) implies (( pop B152 ) = ( R30 . ( pop B151 ) ) & ( top B152 ) = ( R27 . ( top B151 ) ))) & (for B153 being (Element of R24) holds (for B154 being (Element of R25) holds (B154 = ( R27 . B153 ) implies ( push (B154 , B152) ) = ( R30 . ( push (B153 , B151) ) ))))))));
thus L1065: (( dom ( R27 " ) ) = (the carrier of R25) & ( rng ( R27 " ) ) = (the carrier of R24) & ( R27 " ) is  one-to-one) by L1062 , FUNCT_1:33;
thus L1066: (( dom ( R30 " ) ) = (the carrier' of R25) & ( rng ( R30 " ) ) = (the carrier' of R24) & ( R30 " ) is  one-to-one) by L1063 , FUNCT_1:33;
let C240 being (stack of R25);
let C241 being (stack of R24);
assume L1067: C241 = ( ( R30 " ) . C240 );
L1068: ( R30 . C241 ) = C240 by L1067 , L1063 , FUNCT_1:35;
thus L1069: ( emp C240 iff  emp C241) by L1068 , L1064;
thus L1070:now
assume L1071: (not  emp C240);
L1072: (( pop C240 ) = ( R30 . ( pop C241 ) ) & ( top C240 ) = ( R27 . ( top C241 ) )) by L1071 , L1064 , L1069 , L1068;
thus L1073: (( pop C241 ) = ( ( R30 " ) . ( pop C240 ) ) & ( top C241 ) = ( ( R27 " ) . ( top C240 ) )) by L1072 , L1062 , L1063 , FUNCT_1:34;
end;
let C242 being (Element of R25);
let C243 being (Element of R24);
assume L1074: C243 = ( ( R27 " ) . C242 );
L1075: ( R27 . C243 ) = C242 by L1074 , L1062 , FUNCT_1:35;
L1076: ( R30 . ( push (C243 , C241) ) ) = ( push (C242 , C240) ) by L1075 , L1064 , L1068;
thus L1077: thesis by L1076 , L1063 , FUNCT_1:34;
end;
theorem
L1078: (for R24 being StackAlgebra holds (for R25 being StackAlgebra holds (for R26 being StackAlgebra holds (for R28 being Function holds (for R29 being Function holds (for R31 being Function holds (for R32 being Function holds ((R28 , R31 form_isomorphism_between R24 , R25 & R29 , R32 form_isomorphism_between R25 , R26) implies ( R29 * R28 ) , ( R32 * R31 ) form_isomorphism_between R24 , R26))))))))
proof
let R24 being StackAlgebra;
let R25 being StackAlgebra;
let R26 being StackAlgebra;
let R28 being Function;
let R29 being Function;
let R31 being Function;
let R32 being Function;
assume that
L1079: (( dom R28 ) = (the carrier of R24) & ( rng R28 ) = (the carrier of R25) & R28 is  one-to-one)
and
L1080: (( dom R31 ) = (the carrier' of R24) & ( rng R31 ) = (the carrier' of R25) & R31 is  one-to-one)
and
L1081: (for B155 being (stack of R24) holds (for B156 being (stack of R25) holds (B156 = ( R31 . B155 ) implies (( emp B155 iff  emp B156) & ((not  emp B155) implies (( pop B156 ) = ( R31 . ( pop B155 ) ) & ( top B156 ) = ( R28 . ( top B155 ) ))) & (for B157 being (Element of R24) holds (for B158 being (Element of R25) holds (B158 = ( R28 . B157 ) implies ( push (B158 , B156) ) = ( R31 . ( push (B157 , B155) ) ))))))))
and
L1082: (( dom R29 ) = (the carrier of R25) & ( rng R29 ) = (the carrier of R26) & R29 is  one-to-one)
and
L1083: (( dom R32 ) = (the carrier' of R25) & ( rng R32 ) = (the carrier' of R26) & R32 is  one-to-one)
and
L1084: (for B159 being (stack of R25) holds (for B160 being (stack of R26) holds (B160 = ( R32 . B159 ) implies (( emp B159 iff  emp B160) & ((not  emp B159) implies (( pop B160 ) = ( R32 . ( pop B159 ) ) & ( top B160 ) = ( R29 . ( top B159 ) ))) & (for B161 being (Element of R25) holds (for B162 being (Element of R26) holds (B162 = ( R29 . B161 ) implies ( push (B162 , B160) ) = ( R32 . ( push (B161 , B159) ) ))))))));
thus L1085: (( dom ( R29 * R28 ) ) = (the carrier of R24) & ( rng ( R29 * R28 ) ) = (the carrier of R26) & ( R29 * R28 ) is  one-to-one) by L1079 , L1082 , RELAT_1:27 , RELAT_1:28;
thus L1086: (( dom ( R32 * R31 ) ) = (the carrier' of R24) & ( rng ( R32 * R31 ) ) = (the carrier' of R26) & ( R32 * R31 ) is  one-to-one) by L1080 , L1083 , RELAT_1:27 , RELAT_1:28;
let C244 being (stack of R24);
let C245 being (stack of R26);
reconsider D137 = ( R31 . C244 ) as (stack of R25) by L1080 , FUNCT_1:def 3;
assume L1087: C245 = ( ( R32 * R31 ) . C244 );
L1088: C245 = ( R32 . D137 ) by L1087 , L1080 , FUNCT_1:13;
L1089: ( emp C244 iff  emp D137) by L1081;
thus L1090: ( emp C244 iff  emp C245) by L1089 , L1084 , L1088;
thus L1091:now
assume L1092: (not  emp C244);
L1093: (( pop D137 ) = ( R31 . ( pop C244 ) ) & ( top D137 ) = ( R28 . ( top C244 ) ) & (not  emp D137)) by L1092 , L1081;
L1094: (( pop C245 ) = ( R32 . ( R31 . ( pop C244 ) ) ) & ( top C245 ) = ( R29 . ( R28 . ( top C244 ) ) )) by L1093 , L1084 , L1088;
thus L1095: (( pop C245 ) = ( ( R32 * R31 ) . ( pop C244 ) ) & ( top C245 ) = ( ( R29 * R28 ) . ( top C244 ) )) by L1094 , L1079 , L1080 , FUNCT_1:13;
end;
let C246 being (Element of R24);
let C247 being (Element of R26);
reconsider D138 = ( R28 . C246 ) as (Element of R25) by L1079 , FUNCT_1:def 3;
assume L1096: C247 = ( ( R29 * R28 ) . C246 );
L1097: C247 = ( R29 . D138 ) by L1096 , L1079 , FUNCT_1:13;
L1098: ( push (D138 , D137) ) = ( R31 . ( push (C246 , C244) ) ) by L1081;
L1099: ( push (C247 , C245) ) = ( R32 . ( R31 . ( push (C246 , C244) ) ) ) by L1098 , L1088 , L1097 , L1084;
thus L1100: ( push (C247 , C245) ) = ( ( R32 * R31 ) . ( push (C246 , C244) ) ) by L1099 , L1080 , FUNCT_1:13;
end;
theorem
L1101: (for R24 being StackAlgebra holds (for R25 being StackAlgebra holds (for R27 being Function holds (for R30 being Function holds (R27 , R30 form_isomorphism_between R24 , R25 implies (for B163 being (stack of R24) holds (for B164 being (stack of R25) holds (B164 = ( R30 . B163 ) implies |. B164 .| = ( R27 * |. B163 .| )))))))))
proof
let R24 being StackAlgebra;
let R25 being StackAlgebra;
let R27 being Function;
let R30 being Function;
assume that
L1102: (( dom R27 ) = (the carrier of R24) & ( rng R27 ) = (the carrier of R25) & R27 is  one-to-one)
and
L1103: (( dom R30 ) = (the carrier' of R24) & ( rng R30 ) = (the carrier' of R25) & R30 is  one-to-one)
and
L1104: (for B165 being (stack of R24) holds (for B166 being (stack of R25) holds (B166 = ( R30 . B165 ) implies (( emp B165 iff  emp B166) & ((not  emp B165) implies (( pop B166 ) = ( R30 . ( pop B165 ) ) & ( top B166 ) = ( R27 . ( top B165 ) ))) & (for B167 being (Element of R24) holds (for B168 being (Element of R25) holds (B168 = ( R27 . B167 ) implies ( push (B168 , B166) ) = ( R30 . ( push (B167 , B165) ) ))))))));
reconsider D139 = R27 as (Function of (the carrier of R24) , (the carrier of R25)) by L1102 , FUNCT_2:2;
reconsider D140 = R30 as (Function of (the carrier' of R24) , (the carrier' of R25)) by L1103 , FUNCT_2:2;
let C248 being (stack of R24);
defpred S30[ (stack of R24) ] means (for B169 being (stack of R25) holds (B169 = ( R30 . $1 ) implies |. B169 .| = ( R27 * |. $1 .| )));
L1105: (for B170 being (stack of R24) holds ( emp B170 implies S30[ B170 ]))
proof
let C249 being (stack of R24);
assume L1106:  emp C249;
let C250 being (stack of R25);
assume L1107: C250 = ( R30 . C249 );
L1108:  emp C250 by L1107 , L1104 , L1106;
L1109: (|. C250 .| = ( {} ) & |. C249 .| = ( {} )) by L1108 , L1106 , L416;
thus L1110: |. C250 .| = ( R27 * |. C249 .| ) by L1109;
end;
L1111: (for B171 being (stack of R24) holds (for B172 being (Element of R24) holds (S30[ B171 ] implies S30[ ( push (B172 , B171) ) ])))
proof
let C251 being (stack of R24);
let C252 being (Element of R24);
assume L1112: S30[ C251 ];
let C253 being (stack of R25);
L1113: |. ( D140 . C251 ) .| = ( R27 * |. C251 .| ) by L1112;
L1114: <* ( D139 . C252 ) *> = ( R27 * <* C252 *> ) by L1102 , FINSEQ_2:34;
assume L1115: C253 = ( R30 . ( push (C252 , C251) ) );
L1116: C253 = ( push (( D139 . C252 ) , ( D140 . C251 )) ) by L1115 , L1104;
thus L1117: |. C253 .| = ( <* ( D139 . C252 ) *> ^ |. ( D140 . C251 ) .| ) by L1116 , L429
.= ( R27 * ( <* C252 *> ^ |. C251 .| ) ) by L1113 , L1114 , FINSEQOP:9
.= ( R27 * |. ( push (C252 , C251) ) .| ) by L429;
end;
thus L1118: S30[ C248 ] from INDsch(L1105 , L1111);
end;
definition
let C254 , C255 being StackAlgebra;
pred C254 , C255 are_isomorphic 
means
(ex B173 , B174 being Function st B173 , B174 form_isomorphism_between C254 , C255)
;reflexivity
proof
let R15 being StackAlgebra;
take D141 = ( id (the carrier of R15) );
take D142 = ( id (the carrier' of R15) );
thus L1119: thesis by L1051;
end;
symmetry
proof
let R24 being StackAlgebra;
let R25 being StackAlgebra;
given R27 being Function , R30 being Function such that
L1120: R27 , R30 form_isomorphism_between R24 , R25;

take ( R27 " );
take ( R30 " );
thus L1121: thesis by L1120 , L1061;
end;
end;
theorem
L1123: (for R24 being StackAlgebra holds (for R25 being StackAlgebra holds (for R26 being StackAlgebra holds ((R24 , R25 are_isomorphic  & R25 , R26 are_isomorphic ) implies R24 , R26 are_isomorphic ))))
proof
let R24 being StackAlgebra;
let R25 being StackAlgebra;
let R26 being StackAlgebra;
given R28 being Function , R31 being Function such that
L1124: R28 , R31 form_isomorphism_between R24 , R25;

given R29 being Function , R32 being Function such that
L1125: R29 , R32 form_isomorphism_between R25 , R26;

take ( R29 * R28 );
take ( R32 * R31 );
thus L1126: thesis by L1124 , L1125 , L1078;
end;
theorem
L1127: (for R24 being StackAlgebra holds (for R25 being StackAlgebra holds ((R24 , R25 are_isomorphic  & R24 is  proper-for-identity) implies R25 is  proper-for-identity)))
proof
let R24 being StackAlgebra;
let R25 being StackAlgebra;
given R27 being Function , R30 being Function such that
L1128: R27 , R30 form_isomorphism_between R24 , R25;

assume L1129: R24 is  proper-for-identity;
let C256 , C257 being (stack of R25);
L1130: (( dom R30 ) = (the carrier' of R24) & ( rng R30 ) = (the carrier' of R25)) by L1128 , L1049;
consider C258 being set such that L1131: (C258 in ( dom R30 ) & C256 = ( R30 . C258 )) by L1130 , FUNCT_1:def 3;
consider C259 being set such that L1132: (C259 in ( dom R30 ) & C257 = ( R30 . C259 )) by L1130 , FUNCT_1:def 3;
reconsider D143 = C258 , D144 = C259 as (stack of R24) by L1128 , L1049 , L1131 , L1132;
L1133: (( dom R27 ) = (the carrier of R24) & ( rng R27 ) = (the carrier of R25) & R27 is  one-to-one) by L1128 , L1049;
L1134: (( rng |. D143 .| ) c= (the carrier of R24) & ( rng |. D144 .| ) c= (the carrier of R24));
assume L1135: |. C256 .| = |. C257 .|;
L1136: ( R27 * |. D143 .| ) = |. C257 .| by L1135 , L1128 , L1131 , L1101
.= ( R27 * |. D144 .| ) by L1128 , L1132 , L1101;
L1137: (( dom ( R27 * |. D143 .| ) ) = ( dom |. D143 .| ) & ( dom ( R27 * |. D144 .| ) ) = ( dom |. D144 .| )) by L1133 , L1134 , RELAT_1:27;
L1138: |. D143 .| = |. D144 .| by L1137 , L1133 , L1134 , L1136 , FUNCT_1:27;
L1139: D143 == D144 by L1138 , L459;
thus L1140: thesis by L1139 , L1129 , L1131 , L1132 , L484;
end;
theorem
L1141: (for B175 being  proper-for-identity StackAlgebra holds (ex R30 being Function st ((for B176 being (stack of B175) holds ( R30 . B176 ) = |. B176 .|) & ( id (the carrier of B175) ) , R30 form_isomorphism_between B175 , ( StandardStackSystem (the carrier of B175) ))))
proof
let C260 being  proper-for-identity StackAlgebra;
deffunc H11((stack of C260)) = |. $1 .|;
consider C261 being (Function of (the carrier' of C260) , ( (the carrier of C260) * )) such that L1142: (for B177 being (stack of C260) holds ( C261 . B177 ) = H11(B177)) from FUNCT_2:sch 4;
take C261;
thus L1143: (for B178 being (stack of C260) holds ( C261 . B178 ) = |. B178 .|) by L1142;
set D145 = ( id (the carrier of C260) );
set D146 = ( StandardStackSystem (the carrier of C260) );
set D147 = (the carrier of C260);
L1144: ((the carrier of D146) = D147 & (the carrier' of D146) = ( D147 * ) & (for B179 being (stack of D146) holds (( emp B179 iff B179 is  empty) & (for B180 being FinSequence holds (B180 = B179 implies (((not  emp B179) implies (( top B179 ) = ( B180 . 1 ) & ( pop B179 ) = ( Del (B180 , 1) ))) & ( emp B179 implies (( top B179 ) = the (Element of D146) & ( pop B179 ) = ( {} ))) & (for B181 being (Element of D146) holds ( push (B181 , B179) ) = ( <* B181 *> ^ B180 )))))))) by L98;
thus L1145: (( dom D145 ) = (the carrier of C260) & ( rng D145 ) = (the carrier of D146) & D145 is  one-to-one) by L1144;
thus L1146: ( dom C261 ) = (the carrier' of C260) by FUNCT_2:def 1;
thus L1147: ( rng C261 ) = (the carrier' of D146)
proof
thus L1148: ( rng C261 ) c= (the carrier' of D146) by L1144;
let R3 being set;
assume L1149: R3 in (the carrier' of D146);
reconsider D148 = R3 as (Element of ( D147 * )) by L1149 , L98;
consider C262 being (stack of C260) such that L1150: |. C262 .| = D148 by L450;
L1151: D148 = ( C261 . C262 ) by L1142 , L1150;
thus L1152: thesis by L1151 , L1146 , FUNCT_1:def 3;
end;

thus L1153: C261 is  one-to-one
proof
let R3 being set;
let R4 being set;
assume L1154: (R3 in ( dom C261 ) & R4 in ( dom C261 ));
reconsider D149 = R3 , D150 = R4 as (stack of C260) by L1154;
assume L1155: ( C261 . R3 ) = ( C261 . R4 );
L1156: |. D149 .| = ( C261 . R4 ) by L1155 , L1142
.= |. D150 .| by L1142;
L1157: D149 == D150 by L1156 , L459;
thus L1158: R3 = R4 by L1157 , L484;
end;

let C263 being (stack of C260);
let C264 being (stack of D146);
assume L1159: C264 = ( C261 . C263 );
L1160: C264 = |. C263 .| by L1159 , L1142;
thus L1161:now
assume L1162:  emp C263;
L1163: |. C263 .| = ( {} ) by L1162 , L416;
thus L1164:  emp C264 by L1163 , L1160 , L98;
end;
thus L1165:now
assume L1166:  emp C264;
L1167: C264 = ( {} ) by L1166 , L98;
thus L1168:  emp C263 by L1167 , L1160 , L436;
end;
thus L1169:now
assume L1170: (not  emp C263);
thus L1171: ( pop C264 ) = ( Del (C264 , 1) ) by L1170 , L1165 , L98
.= |. ( pop C263 ) .| by L1160 , L1170 , L425
.= ( C261 . ( pop C263 ) ) by L1142;
thus L1172: ( top C264 ) = ( C264 . 1 ) by L1170 , L1165 , L98
.= ( top C263 ) by L1160 , L1170 , L432
.= ( D145 . ( top C263 ) ) by FUNCT_1:18;
end;
let C265 being (Element of C260);
let C266 being (Element of D146);
assume L1173: C266 = ( D145 . C265 );
thus L1174: ( push (C266 , C264) ) = ( <* ( D145 . C265 ) *> ^ C264 ) by L1173 , L98
.= ( <* C265 *> ^ C264 ) by FUNCT_1:18
.= |. ( push (C265 , C263) ) .| by L1160 , L429
.= ( C261 . ( push (C265 , C263) ) ) by L1142;
end;
theorem
L1175: (for B182 being  proper-for-identity StackAlgebra holds B182 , ( StandardStackSystem (the carrier of B182) ) are_isomorphic )
proof
let C267 being  proper-for-identity StackAlgebra;
consider R30 being Function such that L1176: (for B183 being (stack of C267) holds ( R30 . B183 ) = |. B183 .|) and L1177: ( id (the carrier of C267) ) , R30 form_isomorphism_between C267 , ( StandardStackSystem (the carrier of C267) ) by L1141;
take ( id (the carrier of C267) );
take R30;
thus L1178: thesis by L1177;
end;
