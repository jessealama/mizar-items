:: Computation in { \bf SCM_FSA }
::  by Andrzej Trybulec and Yatsuka Nakamura
::
:: Received February 7, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, SCMFSA_2, AMI_1, RELAT_1, AMI_3, FSM_1,
      STRUCT_0, FUNCT_4, FUNCOP_1, XBOOLE_0, TARSKI, FUNCT_1, XXREAL_0,
      ARYTM_3, GRAPHSP, EXTPRO_1, COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2,
      CARD_1, INT_1, CIRCUIT2, ARYTM_1, ORDINAL1, AMISTD_5, FINSET_1, COMPOS_1,
      GOBRD13;
 notations TARSKI, XBOOLE_0, SUBSET_1, FINSET_1, NUMBERS, XCMPLX_0, INT_2,
      RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, INT_1, NAT_1, STRUCT_0, FUNCOP_1,
      FINSEQ_1, FINSEQ_2, MEMSTR_0, COMPOS_1, EXTPRO_1, FUNCT_7, SCMFSA_2,
      XXREAL_0, AMISTD_5;
 constructors DOMAIN_1, INT_2, AMI_3, SCMFSA_2, RELSET_1, PRE_POLY, SCMFSA_1,
      AMISTD_5, FUNCT_7;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, XREAL_0, INT_1, FINSEQ_1, STRUCT_0,
      AMI_3, SCMFSA_2, FINSET_1, ORDINAL1, COMPOS_1, EXTPRO_1, CARD_1,
      MEMSTR_0, FUNCT_4, FUNCOP_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions EXTPRO_1, FUNCOP_1, SCMFSA_2, AMISTD_5, MEMSTR_0, SCM_INST;
 theorems GRFUNC_1, FUNCOP_1, TARSKI, FUNCT_4, FUNCT_1, ZFMISC_1, INT_1,
      RELAT_1, SCMFSA_2, ABSVALUE, FINSEQ_2, XBOOLE_0, XBOOLE_1, PBOOLE,
      PARTFUN1, EXTPRO_1, AMISTD_5, NAT_1, MEMSTR_0, AMI_2;

begin
canceled 2;
theorem
L1: (for B1 being (State of ( SCM+FSA )) holds (for B2 being (Element of ( NAT )) holds (for B3 being Int-Location holds ( B1 . B3 ) = ( ( B1 +* ( Start-At (B2 , ( SCM+FSA )) ) ) . B3 ))))
proof
let C1 being (State of ( SCM+FSA ));
let C2 being (Element of ( NAT ));
let C3 being Int-Location;
L2: C3 in (the carrier of ( SCM+FSA ));
L3: C3 in ( dom C1 ) by L2 , PARTFUN1:def 2;
L4: (( dom ( Start-At (C2 , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } & C3 in ( ( dom C1 ) \/ ( dom ( Start-At (C2 , ( SCM+FSA )) ) ) )) by L3 , FUNCOP_1:13 , XBOOLE_0:def 3;
L5: C3 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L6: (not C3 in { ( IC ( SCM+FSA ) ) }) by L5 , TARSKI:def 1;
thus L7: thesis by L6 , L4 , FUNCT_4:def 1;
end;
theorem
L8: (for B4 being (State of ( SCM+FSA )) holds (for B5 being (Element of ( NAT )) holds (for B6 being FinSeq-Location holds ( B4 . B6 ) = ( ( B4 +* ( Start-At (B5 , ( SCM+FSA )) ) ) . B6 ))))
proof
let C4 being (State of ( SCM+FSA ));
let C5 being (Element of ( NAT ));
let C6 being FinSeq-Location;
L9: C6 in (the carrier of ( SCM+FSA ));
L10: C6 in ( dom C4 ) by L9 , PARTFUN1:def 2;
L11: (( dom ( Start-At (C5 , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } & C6 in ( ( dom C4 ) \/ ( dom ( Start-At (C5 , ( SCM+FSA )) ) ) )) by L10 , FUNCOP_1:13 , XBOOLE_0:def 3;
L12: C6 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:57;
L13: (not C6 in { ( IC ( SCM+FSA ) ) }) by L12 , TARSKI:def 1;
thus L14: thesis by L13 , L11 , FUNCT_4:def 1;
end;
begin
definition
let C7 being Int-Location;
let C8 being Integer;
redefine func C7 .--> C8 -> (FinPartState of ( SCM+FSA ));

coherence
proof
L15: (C8 is (Element of ( INT )) & ( Values C7 ) = ( INT )) by INT_1:def 2 , SCMFSA_2:11;
thus L16: thesis by L15;
end;
end;
registration
cluster ( SCM+FSA ) ->  IC-recognized;
coherence
proof
L18: (for B7 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function holds (for B8 being B7 -autonomic (FinPartState of ( SCM+FSA )) holds (( DataPart B8 ) <> ( {} ) implies ( IC ( SCM+FSA ) ) in ( dom B8 ))))
proof
let C9 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function;
let C10 being C9 -autonomic (FinPartState of ( SCM+FSA ));
assume L19: ( DataPart C10 ) <> ( {} );
L20: ( dom ( DataPart C10 ) ) <> ( {} ) by L19;
assume L21: (not ( IC ( SCM+FSA ) ) in ( dom C10 ));
L22: ( dom C10 ) misses { ( IC ( SCM+FSA ) ) } by L21 , ZFMISC_1:50;
L23: (not C10 is C9 -autonomic)
proof
set D1 = the (Element of ( ( NAT ) \ ( dom C9 ) ));
set D2 = the (Element of ( ( Int-Locations ) \ ( dom C10 ) ));
set D3 = the (Element of ( dom ( DataPart C10 ) ));
L24: ( dom ( DataPart C10 ) ) c= ( Data-Locations ( SCM+FSA ) ) by RELAT_1:58;
L25: (not ( NAT ) c= ( dom C9 ));
L26: ( ( NAT ) \ ( dom C9 ) ) <> ( {} ) by L25 , XBOOLE_1:37;
reconsider D4 = D1 as (Element of ( NAT )) by L26 , XBOOLE_0:def 5;
L27: (not ( Int-Locations ) c= ( dom C10 ));
L28: ( ( Int-Locations ) \ ( dom C10 ) ) <> ( {} ) by L27 , XBOOLE_1:37;
L29: D2 in ( Int-Locations ) by L28 , XBOOLE_0:def 5;
reconsider D5 = D2 as Int-Location by L29 , AMI_2:def 16;
L30: D3 in ( dom ( DataPart C10 ) ) by L20;
L31: ( DataPart C10 ) c= C10 by MEMSTR_0:12;
L32: ( dom ( DataPart C10 ) ) c= ( dom C10 ) by L31 , RELAT_1:11;
L33: ( dom ( DataPart C10 ) ) c= (the carrier of ( SCM+FSA )) by RELAT_1:def 18;
reconsider D6 = D3 as (Element of ( SCM+FSA )) by L33 , L30;
per cases  by L30 , L24 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L34: D6 in ( Int-Locations );

reconsider D7 = D6 as Int-Location by L34 , AMI_2:def 16;
set D8 = ( C10 +* ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) );
set D9 = ( C10 +* ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) );
set D10 = ( C9 +* ( D4 .--> ( D7 := D5 ) ) );
set D11 = ( C9 +* ( D4 .--> ( D7 := D5 ) ) );
consider C11 being (State of ( SCM+FSA )) such that L35: D8 c= C11 by PBOOLE:141;
consider C12 being (Instruction-Sequence of ( SCM+FSA )) such that L36: D10 c= C12 by PBOOLE:145;
L37: (not D5 in ( dom C10 )) by L28 , XBOOLE_0:def 5;
L38: ( dom C10 ) misses { D5 } by L37 , ZFMISC_1:50;
consider C13 being (State of ( SCM+FSA )) such that L39: D9 c= C13 by PBOOLE:141;
consider C14 being (Instruction-Sequence of ( SCM+FSA )) such that L40: D11 c= C14 by PBOOLE:145;
take D12 = C12;
take D13 = C14;
L41: ( dom ( D4 .--> ( D7 := D5 ) ) ) = { D4 } by FUNCOP_1:13;
L42: (not D4 in ( dom C9 )) by L26 , XBOOLE_0:def 5;
L43: ( dom ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) = ( ( dom ( D5 .--> ( 0 ) ) ) \/ ( dom ( Start-At (D4 , ( SCM+FSA )) ) ) ) by FUNCT_4:def 1
.= ( ( dom ( D5 .--> ( 0 ) ) ) \/ { ( IC ( SCM+FSA ) ) } ) by FUNCOP_1:13
.= ( { D5 } \/ { ( IC ( SCM+FSA ) ) } ) by FUNCOP_1:13;
L44: ( ( dom C10 ) /\ ( dom ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) ) = ( ( ( dom C10 ) /\ { D5 } ) \/ ( ( dom C10 ) /\ { ( IC ( SCM+FSA ) ) } ) ) by L43 , XBOOLE_1:23
.= ( ( ( dom C10 ) /\ { D5 } ) \/ ( {} ) ) by L22 , XBOOLE_0:def 7
.= ( {} ) by L38 , XBOOLE_0:def 7;
L45: ( dom C10 ) misses ( dom ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) by L44 , XBOOLE_0:def 7;
L46: C10 c= D8 by L45 , FUNCT_4:32;
L47: C10 c= C11 by L46 , L35 , XBOOLE_1:1;
L48: ( dom C9 ) misses ( dom ( D4 .--> ( D7 := D5 ) ) ) by L41 , L42 , ZFMISC_1:50;
L49: C9 c= D10 by L48 , FUNCT_4:32;
thus L50: C9 c= D12 by L49 , L36 , XBOOLE_1:1;
L51: ( dom ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) = ( ( dom ( D5 .--> 1 ) ) \/ ( dom ( Start-At (D4 , ( SCM+FSA )) ) ) ) by FUNCT_4:def 1
.= ( ( dom ( D5 .--> 1 ) ) \/ { ( IC ( SCM+FSA ) ) } ) by FUNCOP_1:13
.= ( { D5 } \/ { ( IC ( SCM+FSA ) ) } ) by FUNCOP_1:13;
L52: ( ( dom C10 ) /\ ( dom ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) ) = ( ( ( dom C10 ) /\ { D5 } ) \/ ( ( dom C10 ) /\ { ( IC ( SCM+FSA ) ) } ) ) by L51 , XBOOLE_1:23
.= ( ( ( dom C10 ) /\ { D5 } ) \/ ( {} ) ) by L22 , XBOOLE_0:def 7
.= ( {} ) by L38 , XBOOLE_0:def 7;
L53: ( dom C10 ) misses ( dom ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) by L52 , XBOOLE_0:def 7;
L54: C10 c= D9 by L53 , FUNCT_4:32;
L55: C10 c= C13 by L54 , L39 , XBOOLE_1:1;
L56: ( dom C9 ) misses ( dom ( D4 .--> ( D7 := D5 ) ) ) by L41 , L42 , ZFMISC_1:50;
L57: C9 c= D10 by L56 , FUNCT_4:32;
thus L58: C9 c= D13 by L57 , L40 , XBOOLE_1:1;
take C11;
take C13;
thus L59: C10 c= C11 by L47;
thus L60: C10 c= C13 by L55;
take 1;
L61: ( dom ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) = ( ( dom ( D5 .--> 1 ) ) \/ ( dom ( Start-At (D4 , ( SCM+FSA )) ) ) ) by FUNCT_4:def 1;
L62: ( dom C10 ) c= (the carrier of ( SCM+FSA )) by RELAT_1:def 18;
L63: ( dom ( Comput (C14 , C13 , 1) ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2;
L64: ( dom ( ( Comput (C14 , C13 , 1) ) | ( dom C10 ) ) ) = ( dom C10 ) by L62 , L63 , RELAT_1:62;
L65: ( dom ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) = ( ( dom ( D5 .--> ( 0 ) ) ) \/ ( dom ( Start-At (D4 , ( SCM+FSA )) ) ) ) by FUNCT_4:def 1;
L66: ( dom D8 ) = ( ( dom C10 ) \/ ( dom ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) ) by FUNCT_4:def 1;
L67: ( dom ( Start-At (D4 , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L68: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (D4 , ( SCM+FSA )) ) ) by L67 , TARSKI:def 1;
L69: ( IC ( SCM+FSA ) ) in ( dom ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) by L68 , L65 , XBOOLE_0:def 3;
L70: ( IC ( SCM+FSA ) ) in ( dom D8 ) by L69 , L66 , XBOOLE_0:def 3;
L71: ( IC C11 ) = ( D8 . ( IC ( SCM+FSA ) ) ) by L70 , L35 , GRFUNC_1:2
.= ( ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) . ( IC ( SCM+FSA ) ) ) by L69 , FUNCT_4:13
.= ( ( Start-At (D4 , ( SCM+FSA )) ) . ( IC ( SCM+FSA ) ) ) by L68 , FUNCT_4:13
.= D4 by FUNCOP_1:72;
L72: D5 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L73: (not D5 in ( dom ( Start-At (D4 , ( SCM+FSA )) ) )) by L72 , L67 , TARSKI:def 1;
L74: ( dom ( D5 .--> ( 0 ) ) ) = { D5 } by FUNCOP_1:13;
L75: D5 in ( dom ( D5 .--> ( 0 ) ) ) by L74 , TARSKI:def 1;
L76: D5 in ( dom ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) by L75 , L65 , XBOOLE_0:def 3;
L77: D5 in ( dom D8 ) by L76 , L66 , XBOOLE_0:def 3;
L78: ( C11 . D5 ) = ( D8 . D5 ) by L77 , L35 , GRFUNC_1:2
.= ( ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) . D5 ) by L76 , FUNCT_4:13
.= ( ( D5 .--> ( 0 ) ) . D5 ) by L73 , FUNCT_4:11
.= ( 0 ) by FUNCOP_1:72;
L79: ( dom ( D4 .--> ( D7 := D5 ) ) ) = { D4 } by FUNCOP_1:13;
L80: D4 in ( dom ( D4 .--> ( D7 := D5 ) ) ) by L79 , TARSKI:def 1;
L81: ( dom D10 ) = ( ( dom C9 ) \/ ( dom ( D4 .--> ( D7 := D5 ) ) ) ) by FUNCT_4:def 1;
L82: D4 in ( dom D10 ) by L81 , L80 , XBOOLE_0:def 3;
L83: ( C12 . D4 ) = ( D10 . D4 ) by L82 , L36 , GRFUNC_1:2
.= ( ( D4 .--> ( D7 := D5 ) ) . D4 ) by L80 , FUNCT_4:13
.= ( D7 := D5 ) by FUNCOP_1:72;
L84: ( dom C10 ) c= (the carrier of ( SCM+FSA )) by RELAT_1:def 18;
L85: ( dom ( Comput (C12 , C11 , 1) ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2;
L86: ( dom ( ( Comput (C12 , C11 , 1) ) | ( dom C10 ) ) ) = ( dom C10 ) by L84 , L85 , RELAT_1:62;
L87: ( dom D9 ) = ( ( dom C10 ) \/ ( dom ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) ) by FUNCT_4:def 1;
L88: ( dom D11 ) = ( ( dom C9 ) \/ ( dom ( D4 .--> ( D7 := D5 ) ) ) ) by FUNCT_4:def 1;
L89: ( dom ( Start-At (D4 , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L90: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (D4 , ( SCM+FSA )) ) ) by L89 , TARSKI:def 1;
L91: ( IC ( SCM+FSA ) ) in ( dom ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) by L90 , L61 , XBOOLE_0:def 3;
L92: ( IC ( SCM+FSA ) ) in ( dom D9 ) by L91 , L87 , XBOOLE_0:def 3;
L93: ( IC C13 ) = ( D9 . ( IC ( SCM+FSA ) ) ) by L92 , L39 , GRFUNC_1:2
.= ( ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) . ( IC ( SCM+FSA ) ) ) by L91 , FUNCT_4:13
.= ( ( Start-At (D4 , ( SCM+FSA )) ) . ( IC ( SCM+FSA ) ) ) by L90 , FUNCT_4:13
.= D4 by FUNCOP_1:72;
L94: D5 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L95: (not D5 in ( dom ( Start-At (D4 , ( SCM+FSA )) ) )) by L94 , L89 , TARSKI:def 1;
L96: ( dom ( D5 .--> 1 ) ) = { D5 } by FUNCOP_1:13;
L97: D5 in ( dom ( D5 .--> 1 ) ) by L96 , TARSKI:def 1;
L98: D5 in ( dom ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) by L97 , L61 , XBOOLE_0:def 3;
L99: D5 in ( dom D9 ) by L98 , L87 , XBOOLE_0:def 3;
L100: ( C13 . D5 ) = ( D9 . D5 ) by L99 , L39 , GRFUNC_1:2
.= ( ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) . D5 ) by L98 , FUNCT_4:13
.= ( ( D5 .--> 1 ) . D5 ) by L95 , FUNCT_4:11
.= 1 by FUNCOP_1:72;
L101: ( dom ( D4 .--> ( D7 := D5 ) ) ) = { D4 } by FUNCOP_1:13;
L102: D4 in ( dom ( D4 .--> ( D7 := D5 ) ) ) by L101 , TARSKI:def 1;
L103: D4 in ( dom D11 ) by L88 , L102 , XBOOLE_0:def 3;
L104: ( C14 . D4 ) = ( D11 . D4 ) by L103 , L40 , GRFUNC_1:2
.= ( ( D4 .--> ( D7 := D5 ) ) . D4 ) by L102 , FUNCT_4:13
.= ( D7 := D5 ) by FUNCOP_1:72;
L105: ( C14 /. ( IC C13 ) ) = ( C14 . ( IC C13 ) ) by PBOOLE:143;
L106: ( ( Comput (C14 , C13 , ( ( 0 ) + 1 )) ) . D7 ) = ( ( Following (C14 , ( Comput (C14 , C13 , ( 0 )) )) ) . D7 ) by EXTPRO_1:3
.= ( ( Following (C14 , C13) ) . D7 )
.= 1 by L93 , L104 , L100 , L105 , SCMFSA_2:63;
L107: ( C12 /. ( IC C11 ) ) = ( C12 . ( IC C11 ) ) by PBOOLE:143;
L108: ( ( Comput (C12 , C11 , ( ( 0 ) + 1 )) ) . D7 ) = ( ( Following (C12 , ( Comput (C12 , C11 , ( 0 )) )) ) . D7 ) by EXTPRO_1:3
.= ( ( Following (C12 , C11) ) . D7 )
.= ( 0 ) by L71 , L83 , L78 , L107 , SCMFSA_2:63;
L109: ( ( ( Comput (C12 , C11 , 1) ) | ( dom C10 ) ) . D7 ) = ( 0 ) by L108 , L32 , L86 , L30 , FUNCT_1:47;
thus L110: ( ( Comput (D12 , C11 , 1) ) | ( dom C10 ) ) <> ( ( Comput (D13 , C13 , 1) ) | ( dom C10 ) ) by L109 , L106 , L30 , L32 , L64 , FUNCT_1:47;
end;
suppose L111: D6 in ( FinSeq-Locations );

reconsider D14 = D6 as FinSeq-Location by L111 , SCMFSA_2:def 5;
set D15 = ( C10 +* ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) );
set D16 = ( C10 +* ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) );
set D17 = ( C9 +* ( D4 .--> ( D14 :=<0,...,0> D5 ) ) );
set D18 = ( C9 +* ( D4 .--> ( D14 :=<0,...,0> D5 ) ) );
consider C15 being (State of ( SCM+FSA )) such that L112: D15 c= C15 by PBOOLE:141;
consider C16 being (Instruction-Sequence of ( SCM+FSA )) such that L113: D17 c= C16 by PBOOLE:145;
L114: ( dom ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) = ( ( dom ( D5 .--> ( 0 ) ) ) \/ ( dom ( Start-At (D4 , ( SCM+FSA )) ) ) ) by FUNCT_4:def 1;
consider R1 being (Element of ( NAT )) such that L115: R1 = ( abs ( C15 . D5 ) ) and L116: ( ( Exec (( D14 :=<0,...,0> D5 ) , C15) ) . D14 ) = ( R1 |-> ( 0 ) ) by SCMFSA_2:75;
L117: ( dom D15 ) = ( ( dom C10 ) \/ ( dom ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) ) by FUNCT_4:def 1;
L118: ( dom D17 ) = ( ( dom C9 ) \/ ( dom ( D4 .--> ( D14 :=<0,...,0> D5 ) ) ) ) by FUNCT_4:def 1;
L119: ( dom ( Start-At (D4 , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L120: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (D4 , ( SCM+FSA )) ) ) by L119 , TARSKI:def 1;
L121: ( IC ( SCM+FSA ) ) in ( dom ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) by L120 , L114 , XBOOLE_0:def 3;
L122: ( IC ( SCM+FSA ) ) in ( dom D15 ) by L121 , L117 , XBOOLE_0:def 3;
L123: ( IC C15 ) = ( D15 . ( IC ( SCM+FSA ) ) ) by L122 , L112 , GRFUNC_1:2
.= ( ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) . ( IC ( SCM+FSA ) ) ) by L121 , FUNCT_4:13
.= ( ( Start-At (D4 , ( SCM+FSA )) ) . ( IC ( SCM+FSA ) ) ) by L120 , FUNCT_4:13
.= D4 by FUNCOP_1:72;
consider C17 being (State of ( SCM+FSA )) such that L124: D16 c= C17 by PBOOLE:141;
consider C18 being (Instruction-Sequence of ( SCM+FSA )) such that L125: D18 c= C18 by PBOOLE:145;
L126: D5 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L127: (not D5 in ( dom ( Start-At (D4 , ( SCM+FSA )) ) )) by L126 , L119 , TARSKI:def 1;
L128: ( dom ( D5 .--> ( 0 ) ) ) = { D5 } by FUNCOP_1:13;
L129: D5 in ( dom ( D5 .--> ( 0 ) ) ) by L128 , TARSKI:def 1;
L130: D5 in ( dom ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) by L129 , L114 , XBOOLE_0:def 3;
L131: D5 in ( dom D15 ) by L130 , L117 , XBOOLE_0:def 3;
L132: ( C15 . D5 ) = ( D15 . D5 ) by L131 , L112 , GRFUNC_1:2
.= ( ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) . D5 ) by L130 , FUNCT_4:13
.= ( ( D5 .--> ( 0 ) ) . D5 ) by L127 , FUNCT_4:11
.= ( 0 ) by FUNCOP_1:72;
L133: ( R1 |-> ( 0 ) ) = ( ( 0 ) |-> ( 0 ) ) by L132 , L115 , ABSVALUE:2
.= ( {} ) by FINSEQ_2:58;
L134: (not D5 in ( dom C10 )) by L28 , XBOOLE_0:def 5;
L135: ( dom C10 ) misses { D5 } by L134 , ZFMISC_1:50;
L136: ( dom ( D4 .--> ( D14 :=<0,...,0> D5 ) ) ) = { D4 } by FUNCOP_1:13;
L137: D4 in ( dom ( D4 .--> ( D14 :=<0,...,0> D5 ) ) ) by L136 , ZFMISC_1:31;
L138: D4 in ( dom D17 ) by L137 , L118 , XBOOLE_0:def 3;
L139: ( C16 . D4 ) = ( D17 . D4 ) by L138 , L113 , GRFUNC_1:2
.= ( ( D4 .--> ( D14 :=<0,...,0> D5 ) ) . D4 ) by L137 , FUNCT_4:13
.= ( D14 :=<0,...,0> D5 ) by FUNCOP_1:72;
L140: ( dom C10 ) c= (the carrier of ( SCM+FSA )) by RELAT_1:def 18;
L141: ( dom ( Comput (C16 , C15 , 1) ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2;
L142: ( dom ( ( Comput (C16 , C15 , 1) ) | ( dom C10 ) ) ) = ( dom C10 ) by L140 , L141 , RELAT_1:62;
consider R1 being (Element of ( NAT )) such that L143: R1 = ( abs ( C17 . D5 ) ) and L144: ( ( Exec (( D14 :=<0,...,0> D5 ) , C17) ) . D14 ) = ( R1 |-> ( 0 ) ) by SCMFSA_2:75;
L145: ( dom D16 ) = ( ( dom C10 ) \/ ( dom ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) ) by FUNCT_4:def 1;
take D19 = C16;
take D20 = C18;
L146: ( dom ( D4 .--> ( D14 :=<0,...,0> D5 ) ) ) = { D4 } by FUNCOP_1:13;
L147: (not D4 in ( dom C9 )) by L26 , XBOOLE_0:def 5;
L148: ( dom D18 ) = ( ( dom C9 ) \/ ( dom ( D4 .--> ( D14 :=<0,...,0> D5 ) ) ) ) by FUNCT_4:def 1;
L149: ( dom ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) = ( ( dom ( D5 .--> ( 0 ) ) ) \/ ( dom ( Start-At (D4 , ( SCM+FSA )) ) ) ) by FUNCT_4:def 1
.= ( ( dom ( D5 .--> ( 0 ) ) ) \/ { ( IC ( SCM+FSA ) ) } ) by FUNCOP_1:13
.= ( { D5 } \/ { ( IC ( SCM+FSA ) ) } ) by FUNCOP_1:13;
L150: ( ( dom C10 ) /\ ( dom ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) ) = ( ( ( dom C10 ) /\ { D5 } ) \/ ( ( dom C10 ) /\ { ( IC ( SCM+FSA ) ) } ) ) by L149 , XBOOLE_1:23
.= ( ( ( dom C10 ) /\ { D5 } ) \/ ( {} ) ) by L22 , XBOOLE_0:def 7
.= ( {} ) by L135 , XBOOLE_0:def 7;
L151: ( dom C10 ) misses ( dom ( ( D5 .--> ( 0 ) ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) by L150 , XBOOLE_0:def 7;
L152: C10 c= D15 by L151 , FUNCT_4:32;
L153: C10 c= C15 by L152 , L112 , XBOOLE_1:1;
L154: ( dom C9 ) misses ( dom ( D4 .--> ( D14 :=<0,...,0> D5 ) ) ) by L146 , L147 , ZFMISC_1:50;
L155: C9 c= D17 by L154 , FUNCT_4:32;
thus L156: C9 c= D19 by L155 , L113 , XBOOLE_1:1;
L157: ( dom ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) = ( ( dom ( D5 .--> 1 ) ) \/ ( dom ( Start-At (D4 , ( SCM+FSA )) ) ) ) by FUNCT_4:def 1
.= ( ( dom ( D5 .--> 1 ) ) \/ { ( IC ( SCM+FSA ) ) } ) by FUNCOP_1:13
.= ( { D5 } \/ { ( IC ( SCM+FSA ) ) } ) by FUNCOP_1:13;
L158: ( ( dom C10 ) /\ ( dom ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) ) = ( ( ( dom C10 ) /\ { D5 } ) \/ ( ( dom C10 ) /\ { ( IC ( SCM+FSA ) ) } ) ) by L157 , XBOOLE_1:23
.= ( ( ( dom C10 ) /\ { D5 } ) \/ ( {} ) ) by L22 , XBOOLE_0:def 7
.= ( {} ) by L135 , XBOOLE_0:def 7;
L159: ( dom C10 ) misses ( dom ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) by L158 , XBOOLE_0:def 7;
L160: C10 c= D16 by L159 , FUNCT_4:32;
L161: C10 c= C17 by L160 , L124 , XBOOLE_1:1;
L162: ( dom C9 ) misses ( dom ( D4 .--> ( D14 :=<0,...,0> D5 ) ) ) by L146 , L147 , ZFMISC_1:50;
L163: C9 c= D18 by L162 , FUNCT_4:32;
thus L164: C9 c= D20 by L163 , L125 , XBOOLE_1:1;
take C15;
take C17;
thus L165: C10 c= C15 by L153;
thus L166: C10 c= C17 by L161;
take 1;
L167: ( dom ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) = ( ( dom ( D5 .--> 1 ) ) \/ ( dom ( Start-At (D4 , ( SCM+FSA )) ) ) ) by FUNCT_4:def 1;
L168: ( dom ( Start-At (D4 , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L169: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (D4 , ( SCM+FSA )) ) ) by L168 , TARSKI:def 1;
L170: ( IC ( SCM+FSA ) ) in ( dom ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) by L169 , L167 , XBOOLE_0:def 3;
L171: ( IC ( SCM+FSA ) ) in ( dom D16 ) by L170 , L145 , XBOOLE_0:def 3;
L172: ( IC C17 ) = ( D16 . ( IC ( SCM+FSA ) ) ) by L171 , L124 , GRFUNC_1:2
.= ( ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) . ( IC ( SCM+FSA ) ) ) by L170 , FUNCT_4:13
.= ( ( Start-At (D4 , ( SCM+FSA )) ) . ( IC ( SCM+FSA ) ) ) by L169 , FUNCT_4:13
.= D4 by FUNCOP_1:72;
L173: D5 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L174: (not D5 in ( dom ( Start-At (D4 , ( SCM+FSA )) ) )) by L173 , L168 , TARSKI:def 1;
L175: ( dom ( D5 .--> 1 ) ) = { D5 } by FUNCOP_1:13;
L176: D5 in ( dom ( D5 .--> 1 ) ) by L175 , TARSKI:def 1;
L177: D5 in ( dom ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) ) by L176 , L167 , XBOOLE_0:def 3;
L178: D5 in ( dom D16 ) by L177 , L145 , XBOOLE_0:def 3;
L179: ( C17 . D5 ) = ( D16 . D5 ) by L178 , L124 , GRFUNC_1:2
.= ( ( ( D5 .--> 1 ) +* ( Start-At (D4 , ( SCM+FSA )) ) ) . D5 ) by L177 , FUNCT_4:13
.= ( ( D5 .--> 1 ) . D5 ) by L174 , FUNCT_4:11
.= 1 by FUNCOP_1:72;
L180: ( R1 |-> ( 0 ) ) = ( 1 |-> ( 0 ) ) by L179 , L143 , ABSVALUE:def 1
.= <* ( 0 ) *> by FINSEQ_2:59;
L181: ( dom ( D4 .--> ( D14 :=<0,...,0> D5 ) ) ) = { D4 } by FUNCOP_1:13;
L182: D4 in ( dom ( D4 .--> ( D14 :=<0,...,0> D5 ) ) ) by L181 , TARSKI:def 1;
L183: D4 in ( dom D18 ) by L182 , L148 , XBOOLE_0:def 3;
L184: ( C18 . D4 ) = ( D18 . D4 ) by L183 , L125 , GRFUNC_1:2
.= ( ( D4 .--> ( D14 :=<0,...,0> D5 ) ) . D4 ) by L182 , FUNCT_4:13
.= ( D14 :=<0,...,0> D5 ) by FUNCOP_1:72;
L185: ( ( Comput (C18 , C17 , ( ( 0 ) + 1 )) ) . D14 ) = ( ( Following (C18 , ( Comput (C18 , C17 , ( 0 )) )) ) . D14 ) by EXTPRO_1:3
.= ( ( Following (C18 , C17) ) . D14 )
.= <* ( 0 ) *> by L172 , L184 , L144 , L180 , PBOOLE:143;
L186: ( dom C10 ) c= (the carrier of ( SCM+FSA )) by RELAT_1:def 18;
L187: ( dom ( Comput (C18 , C17 , 1) ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2;
L188: ( dom ( ( Comput (C18 , C17 , 1) ) | ( dom C10 ) ) ) = ( dom C10 ) by L186 , L187 , RELAT_1:62;
L189: ( ( Comput (C16 , C15 , ( ( 0 ) + 1 )) ) . D14 ) = ( ( Following (C16 , ( Comput (C16 , C15 , ( 0 )) )) ) . D14 ) by EXTPRO_1:3
.= ( ( Following (C16 , C15) ) . D14 )
.= ( {} ) by L123 , L139 , L116 , L133 , PBOOLE:143;
L190: ( ( ( Comput (C16 , C15 , 1) ) | ( dom C10 ) ) . D14 ) = ( {} ) by L189 , L30 , L32 , L142 , FUNCT_1:47;
thus L191: ( ( Comput (D19 , C15 , 1) ) | ( dom C10 ) ) <> ( ( Comput (D20 , C17 , 1) ) | ( dom C10 ) ) by L190 , L185 , L30 , L32 , L188 , FUNCT_1:47;
end;
end;
thus L193: contradiction by L23;
end;
thus L194: thesis by L18 , AMISTD_5:3;
end;
end;
registration
cluster ( SCM+FSA ) ->  CurIns-recognized;
coherence
proof
let C19 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function;
let C20 being C19 -autonomic non  empty (FinPartState of ( SCM+FSA ));
let C21 being (State of ( SCM+FSA ));
assume that
L196: C20 c= C21;
let C22 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L197: C19 c= C22;
let C23 being (Element of ( NAT ));
set D21 = ( Comput (C22 , C21 , C23) );
set D22 = ( IC D21 );
set D23 = ( D22 + 1 );
assume L198: (not ( IC ( Comput (C22 , C21 , C23) ) ) in ( dom C19 ));
set D24 = ( ( intloc ( 0 ) ) := ( intloc ( 0 ) ) );
set D25 = ( C19 +* ( D22 .--> D24 ) );
set D26 = ( C19 +* ( D22 .--> ( halt ( SCM+FSA ) ) ) );
reconsider D27 = ( C22 +* ( D22 .--> D24 ) ) as (Instruction-Sequence of ( SCM+FSA ));
reconsider D28 = ( C22 +* ( D22 .--> ( halt ( SCM+FSA ) ) ) ) as (Instruction-Sequence of ( SCM+FSA ));
L199: ( dom ( D22 .--> ( halt ( SCM+FSA ) ) ) ) = { D22 } by FUNCOP_1:13;
L200: D22 in ( dom ( D22 .--> ( halt ( SCM+FSA ) ) ) ) by L199 , TARSKI:def 1;
L201: ( dom ( D22 .--> D24 ) ) = { D22 } by FUNCOP_1:13;
L202: D22 in ( dom ( D22 .--> D24 ) ) by L201 , TARSKI:def 1;
L203: ( dom C19 ) misses ( dom ( D22 .--> ( halt ( SCM+FSA ) ) ) ) by L198 , L199 , ZFMISC_1:50;
L204: ( dom C19 ) misses ( dom ( D22 .--> D24 ) ) by L198 , L201 , ZFMISC_1:50;
L205: D25 c= D27 by L197 , FUNCT_4:123;
L206: D26 c= D28 by L197 , FUNCT_4:123;
set D29 = ( Comput (D28 , C21 , C23) );
set D30 = ( Comput (D27 , C21 , C23) );
L207: (not C20 is C19 -autonomic)
proof
L208: ( ( D22 .--> ( halt ( SCM+FSA ) ) ) . D22 ) = ( halt ( SCM+FSA ) ) by FUNCOP_1:72;
L209: ( D28 . D22 ) = ( halt ( SCM+FSA ) ) by L208 , L200 , FUNCT_4:13;
L210: ( ( D22 .--> D24 ) . D22 ) = D24 by FUNCOP_1:72;
take D27;
take D28;
L211: C19 c= D25 by L204 , FUNCT_4:32;
thus L212: C19 c= D27 by L211 , L205 , XBOOLE_1:1;
L213: C19 c= D26 by L203 , FUNCT_4:32;
thus L214: C19 c= D28 by L213 , L206 , XBOOLE_1:1;
take C21;
take C21;
thus L215: C20 c= C21 by L196;
L216: ( D30 | ( dom C20 ) ) = ( D21 | ( dom C20 ) ) by L212 , L197 , L196 , EXTPRO_1:def 10;
thus L217: C20 c= C21 by L196;
L218: ( D30 | ( dom C20 ) ) = ( D29 | ( dom C20 ) ) by L212 , L214 , L196 , EXTPRO_1:def 10;
take D31 = ( C23 + 1 );
set D32 = ( Comput (D27 , C21 , D31) );
L219: ( IC ( SCM+FSA ) ) in ( dom C20 ) by AMISTD_5:6;
L220: ( IC D21 ) = ( IC ( D21 | ( dom C20 ) ) ) by L219 , FUNCT_1:49;
L221: ( IC D30 ) = D22 by L220 , L216 , L219 , FUNCT_1:49;
L222: ( CurInstr (D27 , D30) ) = ( D27 . D22 ) by L221 , PBOOLE:143
.= D24 by L210 , L202 , FUNCT_4:13;
L223: D32 = ( Following (D27 , D30) ) by EXTPRO_1:3
.= ( Exec (D24 , D30) ) by L222;
L224: ( IC ( Exec (D24 , D30) ) ) = ( succ ( IC D30 ) ) by SCMFSA_2:63;
L225: ( IC ( SCM+FSA ) ) in ( dom C20 ) by AMISTD_5:6;
L226: ( IC D21 ) = ( IC ( D21 | ( dom C20 ) ) ) by L225 , FUNCT_1:49;
L227: ( IC D32 ) = ( succ D22 ) by L226 , L223 , L224 , L216 , L225 , FUNCT_1:49
.= D23 by NAT_1:38;
set D33 = ( Comput (D28 , C21 , D31) );
L228: D33 = ( Following (D28 , D29) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D28 , D29) ) , D29) );
L229: ( D28 /. ( IC D29 ) ) = ( D28 . ( IC D29 ) ) by PBOOLE:143;
L230: ( IC D29 ) = D22 by L216 , L226 , L218 , L225 , FUNCT_1:49;
L231: ( IC D33 ) = D22 by L230 , L228 , L209 , L229 , EXTPRO_1:def 3;
L232: (( IC ( D32 | ( dom C20 ) ) ) = ( IC D32 ) & ( IC ( D33 | ( dom C20 ) ) ) = ( IC D33 )) by L225 , FUNCT_1:49;
thus L233: thesis by L232 , L227 , L231;
end;
thus L234: contradiction by L207;
end;
end;
theorem
L236: (for B9 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function holds (for B10 being B9 -autonomic non  empty (FinPartState of ( SCM+FSA )) holds (for B11 , B12 being (State of ( SCM+FSA )) holds ((B10 c= B11 & B10 c= B12) implies (for B13 , B14 being (Instruction-Sequence of ( SCM+FSA )) holds ((B9 c= B13 & B9 c= B14) implies (for B15 being (Element of ( NAT )) holds (for B16 , B17 being Int-Location holds ((( CurInstr (B13 , ( Comput (B13 , B11 , B15) )) ) = ( B16 := B17 ) & B16 in ( dom B10 )) implies ( ( Comput (B13 , B11 , B15) ) . B17 ) = ( ( Comput (B14 , B12 , B15) ) . B17 ))))))))))
proof
let C24 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function;
let C25 being C24 -autonomic non  empty (FinPartState of ( SCM+FSA ));
let C26 , C27 being (State of ( SCM+FSA ));
assume that
L237: (C25 c= C26 & C25 c= C27);
let C28 , C29 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L238: (C24 c= C28 & C24 c= C29);
let C30 being (Element of ( NAT ));
let C31 , C32 being Int-Location;
set D34 = ( CurInstr (C28 , ( Comput (C28 , C26 , C30) )) );
set D35 = ( Comput (C28 , C26 , C30) );
set D36 = ( Comput (C29 , C27 , C30) );
set D37 = ( Comput (C28 , C26 , ( C30 + 1 )) );
set D38 = ( Comput (C29 , C27 , ( C30 + 1 )) );
L239: D38 = ( Following (C29 , D36) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C29 , D36) ) , D36) );
L240: (C31 in ( dom C25 ) implies (( ( D37 | ( dom C25 ) ) . C31 ) = ( D37 . C31 ) & ( ( D38 | ( dom C25 ) ) . C31 ) = ( D38 . C31 ))) by FUNCT_1:49;
assume that
L241: D34 = ( C31 := C32 )
and
L242: (C31 in ( dom C25 ) & ( ( Comput (C28 , C26 , C30) ) . C32 ) <> ( ( Comput (C29 , C27 , C30) ) . C32 ));
L243: D37 = ( Following (C28 , D35) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C28 , D35) ) , D35) );
L244: ( D37 . C31 ) = ( D35 . C32 ) by L243 , L241 , SCMFSA_2:63;
L245: D34 = ( CurInstr (C29 , ( Comput (C29 , C27 , C30) )) ) by L237 , L238 , AMISTD_5:7;
L246: ( D38 . C31 ) = ( D36 . C32 ) by L245 , L239 , L241 , SCMFSA_2:63;
thus L247: contradiction by L246 , L240 , L242 , L244 , L238 , L237 , EXTPRO_1:def 10;
end;
theorem
L248: (for B18 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function holds (for B19 being B18 -autonomic non  empty (FinPartState of ( SCM+FSA )) holds (for B20 , B21 being (State of ( SCM+FSA )) holds ((B19 c= B20 & B19 c= B21) implies (for B22 , B23 being (Instruction-Sequence of ( SCM+FSA )) holds ((B18 c= B22 & B18 c= B23) implies (for B24 being (Element of ( NAT )) holds (for B25 , B26 being Int-Location holds ((( CurInstr (B22 , ( Comput (B22 , B20 , B24) )) ) = ( AddTo (B25 , B26) ) & B25 in ( dom B19 )) implies ( ( ( Comput (B22 , B20 , B24) ) . B25 ) + ( ( Comput (B22 , B20 , B24) ) . B26 ) ) = ( ( ( Comput (B23 , B21 , B24) ) . B25 ) + ( ( Comput (B23 , B21 , B24) ) . B26 ) ))))))))))
proof
let C33 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function;
let C34 being C33 -autonomic non  empty (FinPartState of ( SCM+FSA ));
let C35 , C36 being (State of ( SCM+FSA ));
assume that
L249: (C34 c= C35 & C34 c= C36);
let C37 , C38 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L250: (C33 c= C37 & C33 c= C38);
let C39 being (Element of ( NAT ));
let C40 , C41 being Int-Location;
set D39 = ( CurInstr (C37 , ( Comput (C37 , C35 , C39) )) );
set D40 = ( Comput (C37 , C35 , C39) );
set D41 = ( Comput (C38 , C36 , C39) );
set D42 = ( Comput (C37 , C35 , ( C39 + 1 )) );
set D43 = ( Comput (C38 , C36 , ( C39 + 1 )) );
L251: D43 = ( Following (C38 , D41) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C38 , D41) ) , D41) );
L252: (C40 in ( dom C34 ) implies (( ( D42 | ( dom C34 ) ) . C40 ) = ( D42 . C40 ) & ( ( D43 | ( dom C34 ) ) . C40 ) = ( D43 . C40 ))) by FUNCT_1:49;
assume that
L253: D39 = ( AddTo (C40 , C41) )
and
L254: (C40 in ( dom C34 ) & ( ( ( Comput (C37 , C35 , C39) ) . C40 ) + ( ( Comput (C37 , C35 , C39) ) . C41 ) ) <> ( ( ( Comput (C38 , C36 , C39) ) . C40 ) + ( ( Comput (C38 , C36 , C39) ) . C41 ) ));
L255: D42 = ( Following (C37 , D40) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C37 , D40) ) , D40) );
L256: ( D42 . C40 ) = ( ( D40 . C40 ) + ( D40 . C41 ) ) by L255 , L253 , SCMFSA_2:64;
L257: D39 = ( CurInstr (C38 , ( Comput (C38 , C36 , C39) )) ) by L249 , L250 , AMISTD_5:7;
L258: ( D43 . C40 ) = ( ( D41 . C40 ) + ( D41 . C41 ) ) by L257 , L251 , L253 , SCMFSA_2:64;
thus L259: contradiction by L258 , L249 , L252 , L254 , L256 , L250 , EXTPRO_1:def 10;
end;
theorem
L260: (for B27 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function holds (for B28 being B27 -autonomic non  empty (FinPartState of ( SCM+FSA )) holds (for B29 , B30 being (State of ( SCM+FSA )) holds ((B28 c= B29 & B28 c= B30) implies (for B31 , B32 being (Instruction-Sequence of ( SCM+FSA )) holds ((B27 c= B31 & B27 c= B32) implies (for B33 being (Element of ( NAT )) holds (for B34 , B35 being Int-Location holds ((( CurInstr (B31 , ( Comput (B31 , B29 , B33) )) ) = ( SubFrom (B34 , B35) ) & B34 in ( dom B28 )) implies ( ( ( Comput (B31 , B29 , B33) ) . B34 ) - ( ( Comput (B31 , B29 , B33) ) . B35 ) ) = ( ( ( Comput (B32 , B30 , B33) ) . B34 ) - ( ( Comput (B32 , B30 , B33) ) . B35 ) ))))))))))
proof
let C42 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function;
let C43 being C42 -autonomic non  empty (FinPartState of ( SCM+FSA ));
let C44 , C45 being (State of ( SCM+FSA ));
assume that
L261: (C43 c= C44 & C43 c= C45);
let C46 , C47 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L262: (C42 c= C46 & C42 c= C47);
let C48 being (Element of ( NAT ));
let C49 , C50 being Int-Location;
set D44 = ( CurInstr (C46 , ( Comput (C46 , C44 , C48) )) );
set D45 = ( Comput (C46 , C44 , C48) );
set D46 = ( Comput (C47 , C45 , C48) );
set D47 = ( Comput (C46 , C44 , ( C48 + 1 )) );
set D48 = ( Comput (C47 , C45 , ( C48 + 1 )) );
L263: D48 = ( Following (C47 , D46) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C47 , D46) ) , D46) );
L264: (C49 in ( dom C43 ) implies (( ( D47 | ( dom C43 ) ) . C49 ) = ( D47 . C49 ) & ( ( D48 | ( dom C43 ) ) . C49 ) = ( D48 . C49 ))) by FUNCT_1:49;
assume that
L265: D44 = ( SubFrom (C49 , C50) )
and
L266: (C49 in ( dom C43 ) & ( ( ( Comput (C46 , C44 , C48) ) . C49 ) - ( ( Comput (C46 , C44 , C48) ) . C50 ) ) <> ( ( ( Comput (C47 , C45 , C48) ) . C49 ) - ( ( Comput (C47 , C45 , C48) ) . C50 ) ));
L267: D47 = ( Following (C46 , D45) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C46 , D45) ) , D45) );
L268: ( D47 . C49 ) = ( ( D45 . C49 ) - ( D45 . C50 ) ) by L267 , L265 , SCMFSA_2:65;
L269: D44 = ( CurInstr (C47 , ( Comput (C47 , C45 , C48) )) ) by L261 , L262 , AMISTD_5:7;
L270: ( D48 . C49 ) = ( ( D46 . C49 ) - ( D46 . C50 ) ) by L269 , L263 , L265 , SCMFSA_2:65;
thus L271: contradiction by L270 , L261 , L264 , L266 , L268 , L262 , EXTPRO_1:def 10;
end;
theorem
L272: (for B36 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function holds (for B37 being B36 -autonomic non  empty (FinPartState of ( SCM+FSA )) holds (for B38 , B39 being (State of ( SCM+FSA )) holds ((B37 c= B38 & B37 c= B39) implies (for B40 , B41 being (Instruction-Sequence of ( SCM+FSA )) holds ((B36 c= B40 & B36 c= B41) implies (for B42 being (Element of ( NAT )) holds (for B43 , B44 being Int-Location holds ((( CurInstr (B40 , ( Comput (B40 , B38 , B42) )) ) = ( MultBy (B43 , B44) ) & B43 in ( dom B37 )) implies ( ( ( Comput (B40 , B38 , B42) ) . B43 ) * ( ( Comput (B40 , B38 , B42) ) . B44 ) ) = ( ( ( Comput (B41 , B39 , B42) ) . B43 ) * ( ( Comput (B41 , B39 , B42) ) . B44 ) ))))))))))
proof
let C51 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function;
let C52 being C51 -autonomic non  empty (FinPartState of ( SCM+FSA ));
let C53 , C54 being (State of ( SCM+FSA ));
assume that
L273: (C52 c= C53 & C52 c= C54);
let C55 , C56 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L274: (C51 c= C55 & C51 c= C56);
let C57 being (Element of ( NAT ));
let C58 , C59 being Int-Location;
set D49 = ( CurInstr (C55 , ( Comput (C55 , C53 , C57) )) );
set D50 = ( Comput (C55 , C53 , C57) );
set D51 = ( Comput (C56 , C54 , C57) );
set D52 = ( Comput (C55 , C53 , ( C57 + 1 )) );
set D53 = ( Comput (C56 , C54 , ( C57 + 1 )) );
L275: D53 = ( Following (C56 , D51) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C56 , D51) ) , D51) );
L276: (C58 in ( dom C52 ) implies (( ( D52 | ( dom C52 ) ) . C58 ) = ( D52 . C58 ) & ( ( D53 | ( dom C52 ) ) . C58 ) = ( D53 . C58 ))) by FUNCT_1:49;
assume that
L277: D49 = ( MultBy (C58 , C59) )
and
L278: (C58 in ( dom C52 ) & ( ( ( Comput (C55 , C53 , C57) ) . C58 ) * ( ( Comput (C55 , C53 , C57) ) . C59 ) ) <> ( ( ( Comput (C56 , C54 , C57) ) . C58 ) * ( ( Comput (C56 , C54 , C57) ) . C59 ) ));
L279: D52 = ( Following (C55 , D50) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C55 , D50) ) , D50) );
L280: ( D52 . C58 ) = ( ( D50 . C58 ) * ( D50 . C59 ) ) by L279 , L277 , SCMFSA_2:66;
L281: D49 = ( CurInstr (C56 , ( Comput (C56 , C54 , C57) )) ) by L273 , L274 , AMISTD_5:7;
L282: ( D53 . C58 ) = ( ( D51 . C58 ) * ( D51 . C59 ) ) by L281 , L275 , L277 , SCMFSA_2:66;
thus L283: contradiction by L282 , L273 , L276 , L278 , L280 , L274 , EXTPRO_1:def 10;
end;
theorem
L284: (for B45 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function holds (for B46 being B45 -autonomic non  empty (FinPartState of ( SCM+FSA )) holds (for B47 , B48 being (State of ( SCM+FSA )) holds ((B46 c= B47 & B46 c= B48) implies (for B49 , B50 being (Instruction-Sequence of ( SCM+FSA )) holds ((B45 c= B49 & B45 c= B50) implies (for B51 being (Element of ( NAT )) holds (for B52 , B53 being Int-Location holds ((( CurInstr (B49 , ( Comput (B49 , B47 , B51) )) ) = ( Divide (B52 , B53) ) & B52 in ( dom B46 ) & B52 <> B53) implies ( ( ( Comput (B49 , B47 , B51) ) . B52 ) div ( ( Comput (B49 , B47 , B51) ) . B53 ) ) = ( ( ( Comput (B50 , B48 , B51) ) . B52 ) div ( ( Comput (B50 , B48 , B51) ) . B53 ) ))))))))))
proof
let C60 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function;
let C61 being C60 -autonomic non  empty (FinPartState of ( SCM+FSA ));
let C62 , C63 being (State of ( SCM+FSA ));
assume that
L285: (C61 c= C62 & C61 c= C63);
let C64 , C65 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L286: (C60 c= C64 & C60 c= C65);
let C66 being (Element of ( NAT ));
let C67 , C68 being Int-Location;
set D54 = ( CurInstr (C64 , ( Comput (C64 , C62 , C66) )) );
set D55 = ( Comput (C64 , C62 , C66) );
set D56 = ( Comput (C65 , C63 , C66) );
set D57 = ( Comput (C64 , C62 , ( C66 + 1 )) );
set D58 = ( Comput (C65 , C63 , ( C66 + 1 )) );
L287: D58 = ( Following (C65 , D56) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C65 , D56) ) , D56) );
L288: (C67 in ( dom C61 ) implies (( ( D57 | ( dom C61 ) ) . C67 ) = ( D57 . C67 ) & ( ( D58 | ( dom C61 ) ) . C67 ) = ( D58 . C67 ))) by FUNCT_1:49;
assume that
L289: D54 = ( Divide (C67 , C68) )
and
L290: C67 in ( dom C61 )
and
L291: C67 <> C68
and
L292: ( ( ( Comput (C64 , C62 , C66) ) . C67 ) div ( ( Comput (C64 , C62 , C66) ) . C68 ) ) <> ( ( ( Comput (C65 , C63 , C66) ) . C67 ) div ( ( Comput (C65 , C63 , C66) ) . C68 ) );
L293: D57 = ( Following (C64 , D55) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C64 , D55) ) , D55) );
L294: ( D57 . C67 ) = ( ( D55 . C67 ) div ( D55 . C68 ) ) by L293 , L289 , L291 , SCMFSA_2:67;
L295: D54 = ( CurInstr (C65 , ( Comput (C65 , C63 , C66) )) ) by L285 , L286 , AMISTD_5:7;
L296: ( D58 . C67 ) = ( ( D56 . C67 ) div ( D56 . C68 ) ) by L295 , L287 , L289 , L291 , SCMFSA_2:67;
thus L297: contradiction by L296 , L285 , L288 , L292 , L294 , L286 , L290 , EXTPRO_1:def 10;
end;
theorem
L298: (for B54 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function holds (for B55 being B54 -autonomic non  empty (FinPartState of ( SCM+FSA )) holds (for B56 , B57 being (State of ( SCM+FSA )) holds ((B55 c= B56 & B55 c= B57) implies (for B58 , B59 being (Instruction-Sequence of ( SCM+FSA )) holds ((B54 c= B58 & B54 c= B59) implies (for B60 being (Element of ( NAT )) holds (for B61 , B62 being Int-Location holds ((( CurInstr (B58 , ( Comput (B58 , B56 , B60) )) ) = ( Divide (B61 , B62) ) & B62 in ( dom B55 )) implies ( ( ( Comput (B58 , B56 , B60) ) . B61 ) mod ( ( Comput (B58 , B56 , B60) ) . B62 ) ) = ( ( ( Comput (B59 , B57 , B60) ) . B61 ) mod ( ( Comput (B59 , B57 , B60) ) . B62 ) ))))))))))
proof
let C69 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function;
let C70 being C69 -autonomic non  empty (FinPartState of ( SCM+FSA ));
let C71 , C72 being (State of ( SCM+FSA ));
assume that
L299: (C70 c= C71 & C70 c= C72);
let C73 , C74 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L300: (C69 c= C73 & C69 c= C74);
let C75 being (Element of ( NAT ));
let C76 , C77 being Int-Location;
set D59 = ( CurInstr (C73 , ( Comput (C73 , C71 , C75) )) );
set D60 = ( Comput (C73 , C71 , C75) );
set D61 = ( Comput (C74 , C72 , C75) );
set D62 = ( Comput (C73 , C71 , ( C75 + 1 )) );
set D63 = ( Comput (C74 , C72 , ( C75 + 1 )) );
L301: D63 = ( Following (C74 , D61) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C74 , D61) ) , D61) );
assume that
L302: D59 = ( Divide (C76 , C77) )
and
L303: C77 in ( dom C70 )
and
L304: ( ( ( Comput (C73 , C71 , C75) ) . C76 ) mod ( ( Comput (C73 , C71 , C75) ) . C77 ) ) <> ( ( ( Comput (C74 , C72 , C75) ) . C76 ) mod ( ( Comput (C74 , C72 , C75) ) . C77 ) );
L305: (( ( D62 | ( dom C70 ) ) . C77 ) = ( D62 . C77 ) & ( ( D63 | ( dom C70 ) ) . C77 ) = ( D63 . C77 )) by L303 , FUNCT_1:49;
L306: D62 = ( Following (C73 , D60) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C73 , D60) ) , D60) );
L307: ( D62 . C77 ) = ( ( D60 . C76 ) mod ( D60 . C77 ) ) by L306 , L302 , SCMFSA_2:67;
L308: D59 = ( CurInstr (C74 , ( Comput (C74 , C72 , C75) )) ) by L299 , L300 , AMISTD_5:7;
L309: ( D63 . C77 ) = ( ( D61 . C76 ) mod ( D61 . C77 ) ) by L308 , L301 , L302 , SCMFSA_2:67;
thus L310: contradiction by L309 , L299 , L304 , L305 , L307 , L300 , EXTPRO_1:def 10;
end;
theorem
L311: (for B63 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function holds (for B64 being B63 -autonomic non  empty (FinPartState of ( SCM+FSA )) holds (for B65 , B66 being (State of ( SCM+FSA )) holds ((B64 c= B65 & B64 c= B66) implies (for B67 , B68 being (Instruction-Sequence of ( SCM+FSA )) holds ((B63 c= B67 & B63 c= B68) implies (for B69 being (Element of ( NAT )) holds (for B70 being Int-Location holds (for B71 being (Element of ( NAT )) holds ((( CurInstr (B67 , ( Comput (B67 , B65 , B69) )) ) = ( B70 =0_goto B71 ) & B71 <> ( succ ( IC ( Comput (B67 , B65 , B69) ) ) )) implies (( ( Comput (B67 , B65 , B69) ) . B70 ) = ( 0 ) iff ( ( Comput (B68 , B66 , B69) ) . B70 ) = ( 0 ))))))))))))
proof
let C78 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function;
let C79 being C78 -autonomic non  empty (FinPartState of ( SCM+FSA ));
let C80 , C81 being (State of ( SCM+FSA ));
assume that
L312: (C79 c= C80 & C79 c= C81);
let C82 , C83 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L313: (C78 c= C82 & C78 c= C83);
let C84 being (Element of ( NAT ));
let C85 being Int-Location;
let C86 being (Element of ( NAT ));
set D64 = ( CurInstr (C82 , ( Comput (C82 , C80 , C84) )) );
set D65 = ( Comput (C82 , C80 , C84) );
set D66 = ( Comput (C83 , C81 , C84) );
set D67 = ( Comput (C82 , C80 , ( C84 + 1 )) );
set D68 = ( Comput (C83 , C81 , ( C84 + 1 )) );
L314: D67 = ( Following (C82 , D65) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C82 , D65) ) , D65) );
L315: D68 = ( Following (C83 , D66) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C83 , D66) ) , D66) );
L316: ( IC ( SCM+FSA ) ) in ( dom C79 ) by AMISTD_5:6;
L317: (( ( D67 | ( dom C79 ) ) . ( IC ( SCM+FSA ) ) ) = ( D67 . ( IC ( SCM+FSA ) ) ) & ( ( D68 | ( dom C79 ) ) . ( IC ( SCM+FSA ) ) ) = ( D68 . ( IC ( SCM+FSA ) ) )) by L316 , FUNCT_1:49;
assume that
L318: D64 = ( C85 =0_goto C86 )
and
L319: C86 <> ( succ ( IC ( Comput (C82 , C80 , C84) ) ) );
L320: D64 = ( CurInstr (C83 , ( Comput (C83 , C81 , C84) )) ) by L312 , L313 , AMISTD_5:7;
L321:
now
assume L322: (( ( Comput (C83 , C81 , C84) ) . C85 ) = ( 0 ) & ( ( Comput (C82 , C80 , C84) ) . C85 ) <> ( 0 ));
L323: (( D68 . ( IC ( SCM+FSA ) ) ) = C86 & ( D67 . ( IC ( SCM+FSA ) ) ) = ( succ ( IC D65 ) )) by L322 , L320 , L314 , L315 , L318 , SCMFSA_2:70;
thus L324: contradiction by L323 , L312 , L317 , L319 , L313 , EXTPRO_1:def 10;
end;
L325: ( D67 | ( dom C79 ) ) = ( D68 | ( dom C79 ) ) by L312 , L313 , EXTPRO_1:def 10;
L326:
now
assume L327: (( ( Comput (C82 , C80 , C84) ) . C85 ) = ( 0 ) & ( ( Comput (C83 , C81 , C84) ) . C85 ) <> ( 0 ));
L328: (( D67 . ( IC ( SCM+FSA ) ) ) = C86 & ( D68 . ( IC ( SCM+FSA ) ) ) = ( succ ( IC D66 ) )) by L327 , L320 , L314 , L315 , L318 , SCMFSA_2:70;
thus L329: contradiction by L328 , L312 , L317 , L325 , L319 , L313 , AMISTD_5:7;
end;
thus L330: thesis by L326 , L321;
end;
theorem
L331: (for B72 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function holds (for B73 being B72 -autonomic non  empty (FinPartState of ( SCM+FSA )) holds (for B74 , B75 being (State of ( SCM+FSA )) holds ((B73 c= B74 & B73 c= B75) implies (for B76 , B77 being (Instruction-Sequence of ( SCM+FSA )) holds ((B72 c= B76 & B72 c= B77) implies (for B78 being (Element of ( NAT )) holds (for B79 being Int-Location holds (for B80 being (Element of ( NAT )) holds ((( CurInstr (B76 , ( Comput (B76 , B74 , B78) )) ) = ( B79 >0_goto B80 ) & B80 <> ( succ ( IC ( Comput (B76 , B74 , B78) ) ) )) implies (( ( Comput (B76 , B74 , B78) ) . B79 ) > ( 0 ) iff ( ( Comput (B77 , B75 , B78) ) . B79 ) > ( 0 ))))))))))))
proof
let C87 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function;
let C88 being C87 -autonomic non  empty (FinPartState of ( SCM+FSA ));
let C89 , C90 being (State of ( SCM+FSA ));
assume that
L332: (C88 c= C89 & C88 c= C90);
let C91 , C92 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L333: (C87 c= C91 & C87 c= C92);
let C93 being (Element of ( NAT ));
let C94 being Int-Location;
let C95 being (Element of ( NAT ));
set D69 = ( Comput (C91 , C89 , ( C93 + 1 )) );
set D70 = ( Comput (C92 , C90 , ( C93 + 1 )) );
L334: ( D69 | ( dom C88 ) ) = ( D70 | ( dom C88 ) ) by L332 , L333 , EXTPRO_1:def 10;
set D71 = ( Comput (C92 , C90 , C93) );
set D72 = ( Comput (C91 , C89 , C93) );
set D73 = ( CurInstr (C91 , ( Comput (C91 , C89 , C93) )) );
L335: D69 = ( Following (C91 , D72) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C91 , D72) ) , D72) );
L336: ( IC ( SCM+FSA ) ) in ( dom C88 ) by AMISTD_5:6;
L337: (( ( D69 | ( dom C88 ) ) . ( IC ( SCM+FSA ) ) ) = ( D69 . ( IC ( SCM+FSA ) ) ) & ( ( D70 | ( dom C88 ) ) . ( IC ( SCM+FSA ) ) ) = ( D70 . ( IC ( SCM+FSA ) ) )) by L336 , FUNCT_1:49;
L338: D70 = ( Following (C92 , D71) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C92 , D71) ) , D71) );
assume that
L339: D73 = ( C94 >0_goto C95 )
and
L340: C95 <> ( succ ( IC ( Comput (C91 , C89 , C93) ) ) );
L341: D73 = ( CurInstr (C92 , ( Comput (C92 , C90 , C93) )) ) by L332 , L333 , AMISTD_5:7;
L342:
now
assume that
L343: ( ( Comput (C92 , C90 , C93) ) . C94 ) > ( 0 )
and
L344: ( ( Comput (C91 , C89 , C93) ) . C94 ) <= ( 0 );
L345: ( D70 . ( IC ( SCM+FSA ) ) ) = C95 by L341 , L338 , L339 , L343 , SCMFSA_2:71;
thus L346: contradiction by L345 , L335 , L337 , L334 , L339 , L340 , L344 , SCMFSA_2:71;
end;
L347: ( IC D72 ) = ( IC D71 ) by L332 , L333 , AMISTD_5:7;
L348:
now
assume that
L349: ( ( Comput (C91 , C89 , C93) ) . C94 ) > ( 0 )
and
L350: ( ( Comput (C92 , C90 , C93) ) . C94 ) <= ( 0 );
L351: ( D69 . ( IC ( SCM+FSA ) ) ) = C95 by L335 , L339 , L349 , SCMFSA_2:71;
thus L352: contradiction by L351 , L347 , L341 , L338 , L337 , L334 , L339 , L340 , L350 , SCMFSA_2:71;
end;
thus L353: thesis by L348 , L342;
end;
theorem
L354: (for B81 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function holds (for B82 being B81 -autonomic non  empty (FinPartState of ( SCM+FSA )) holds (for B83 , B84 being (State of ( SCM+FSA )) holds ((B82 c= B83 & B82 c= B84) implies (for B85 , B86 being (Instruction-Sequence of ( SCM+FSA )) holds ((B81 c= B85 & B81 c= B86) implies (for B87 being (Element of ( NAT )) holds (for B88 , B89 being Int-Location holds (for B90 being FinSeq-Location holds ((( CurInstr (B85 , ( Comput (B85 , B83 , B87) )) ) = ( B88 := (B90 , B89) ) & B88 in ( dom B82 )) implies (for B91 , B92 being (Element of ( NAT )) holds ((B91 = ( abs ( ( Comput (B85 , B83 , B87) ) . B89 ) ) & B92 = ( abs ( ( Comput (B86 , B84 , B87) ) . B89 ) )) implies ( ( ( Comput (B85 , B83 , B87) ) . B90 ) /. B91 ) = ( ( ( Comput (B86 , B84 , B87) ) . B90 ) /. B92 )))))))))))))
proof
let C96 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function;
let C97 being C96 -autonomic non  empty (FinPartState of ( SCM+FSA ));
let C98 , C99 being (State of ( SCM+FSA ));
assume that
L355: (C97 c= C98 & C97 c= C99);
let C100 , C101 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L356: (C96 c= C100 & C96 c= C101);
let C102 being (Element of ( NAT ));
let C103 , C104 being Int-Location;
let C105 being FinSeq-Location;
set D74 = ( Comput (C100 , C98 , ( C102 + 1 )) );
set D75 = ( Comput (C101 , C99 , ( C102 + 1 )) );
L357: ( D74 | ( dom C97 ) ) = ( D75 | ( dom C97 ) ) by L355 , L356 , EXTPRO_1:def 10;
set D76 = ( Comput (C101 , C99 , C102) );
set D77 = ( Comput (C100 , C98 , C102) );
set D78 = ( CurInstr (C100 , ( Comput (C100 , C98 , C102) )) );
L358: D74 = ( Following (C100 , D77) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C100 , D77) ) , D77) );
L359: (C103 in ( dom C97 ) implies (( ( D74 | ( dom C97 ) ) . C103 ) = ( D74 . C103 ) & ( ( D75 | ( dom C97 ) ) . C103 ) = ( D75 . C103 ))) by FUNCT_1:49;
L360: D75 = ( Following (C101 , D76) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C101 , D76) ) , D76) );
assume that
L361: D78 = ( C103 := (C105 , C104) )
and
L362: C103 in ( dom C97 );
L363: ((ex B93 being (Element of ( NAT )) st (B93 = ( abs ( D77 . C104 ) ) & ( ( Exec (D78 , D77) ) . C103 ) = ( ( D77 . C105 ) /. B93 ))) & (ex B94 being (Element of ( NAT )) st (B94 = ( abs ( D76 . C104 ) ) & ( ( Exec (D78 , D76) ) . C103 ) = ( ( D76 . C105 ) /. B94 )))) by L361 , SCMFSA_2:72;
let C106 , C107 being (Element of ( NAT ));
assume L364: (C106 = ( abs ( ( Comput (C100 , C98 , C102) ) . C104 ) ) & C107 = ( abs ( ( Comput (C101 , C99 , C102) ) . C104 ) ) & ( ( ( Comput (C100 , C98 , C102) ) . C105 ) /. C106 ) <> ( ( ( Comput (C101 , C99 , C102) ) . C105 ) /. C107 ));
thus L365: contradiction by L364 , L355 , L358 , L360 , L359 , L357 , L363 , L362 , L356 , AMISTD_5:7;
end;
theorem
L366: (for B95 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function holds (for B96 being B95 -autonomic non  empty (FinPartState of ( SCM+FSA )) holds (for B97 , B98 being (State of ( SCM+FSA )) holds ((B96 c= B97 & B96 c= B98) implies (for B99 , B100 being (Instruction-Sequence of ( SCM+FSA )) holds ((B95 c= B99 & B95 c= B100) implies (for B101 being (Element of ( NAT )) holds (for B102 , B103 being Int-Location holds (for B104 being FinSeq-Location holds ((( CurInstr (B99 , ( Comput (B99 , B97 , B101) )) ) = ( (B104 , B103) := B102 ) & B104 in ( dom B96 )) implies (for B105 , B106 being (Element of ( NAT )) holds ((B105 = ( abs ( ( Comput (B99 , B97 , B101) ) . B103 ) ) & B106 = ( abs ( ( Comput (B100 , B98 , B101) ) . B103 ) )) implies ( ( ( Comput (B99 , B97 , B101) ) . B104 ) +* (B105 , ( ( Comput (B99 , B97 , B101) ) . B102 )) ) = ( ( ( Comput (B100 , B98 , B101) ) . B104 ) +* (B106 , ( ( Comput (B100 , B98 , B101) ) . B102 )) )))))))))))))
proof
let C108 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function;
let C109 being C108 -autonomic non  empty (FinPartState of ( SCM+FSA ));
let C110 , C111 being (State of ( SCM+FSA ));
assume that
L367: (C109 c= C110 & C109 c= C111);
let C112 , C113 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L368: (C108 c= C112 & C108 c= C113);
let C114 being (Element of ( NAT ));
let C115 , C116 being Int-Location;
let C117 being FinSeq-Location;
set D79 = ( Comput (C112 , C110 , ( C114 + 1 )) );
set D80 = ( Comput (C113 , C111 , ( C114 + 1 )) );
L369: ( D79 | ( dom C109 ) ) = ( D80 | ( dom C109 ) ) by L367 , L368 , EXTPRO_1:def 10;
set D81 = ( Comput (C113 , C111 , C114) );
set D82 = ( Comput (C112 , C110 , C114) );
set D83 = ( CurInstr (C112 , ( Comput (C112 , C110 , C114) )) );
L370: D79 = ( Following (C112 , D82) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C112 , D82) ) , D82) );
L371: (C117 in ( dom C109 ) implies (( ( D79 | ( dom C109 ) ) . C117 ) = ( D79 . C117 ) & ( ( D80 | ( dom C109 ) ) . C117 ) = ( D80 . C117 ))) by FUNCT_1:49;
L372: D80 = ( Following (C113 , D81) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C113 , D81) ) , D81) );
assume that
L373: D83 = ( (C117 , C116) := C115 )
and
L374: C117 in ( dom C109 );
L375: ((ex B107 being (Element of ( NAT )) st (B107 = ( abs ( D82 . C116 ) ) & ( ( Exec (D83 , D82) ) . C117 ) = ( ( D82 . C117 ) +* (B107 , ( D82 . C115 )) ))) & (ex B108 being (Element of ( NAT )) st (B108 = ( abs ( D81 . C116 ) ) & ( ( Exec (D83 , D81) ) . C117 ) = ( ( D81 . C117 ) +* (B108 , ( D81 . C115 )) )))) by L373 , SCMFSA_2:73;
let C118 , C119 being (Element of ( NAT ));
assume L376: (C118 = ( abs ( D82 . C116 ) ) & C119 = ( abs ( D81 . C116 ) ) & ( ( D82 . C117 ) +* (C118 , ( D82 . C115 )) ) <> ( ( D81 . C117 ) +* (C119 , ( D81 . C115 )) ));
thus L377: contradiction by L376 , L367 , L370 , L372 , L371 , L369 , L375 , L374 , L368 , AMISTD_5:7;
end;
theorem
L378: (for B109 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function holds (for B110 being B109 -autonomic non  empty (FinPartState of ( SCM+FSA )) holds (for B111 , B112 being (State of ( SCM+FSA )) holds ((B110 c= B111 & B110 c= B112) implies (for B113 , B114 being (Instruction-Sequence of ( SCM+FSA )) holds ((B109 c= B113 & B109 c= B114) implies (for B115 being (Element of ( NAT )) holds (for B116 being Int-Location holds (for B117 being FinSeq-Location holds ((( CurInstr (B113 , ( Comput (B113 , B111 , B115) )) ) = ( B116 :=len B117 ) & B116 in ( dom B110 )) implies ( len ( ( Comput (B113 , B111 , B115) ) . B117 ) ) = ( len ( ( Comput (B114 , B112 , B115) ) . B117 ) )))))))))))
proof
let C120 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function;
let C121 being C120 -autonomic non  empty (FinPartState of ( SCM+FSA ));
let C122 , C123 being (State of ( SCM+FSA ));
assume that
L379: (C121 c= C122 & C121 c= C123);
let C124 , C125 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L380: (C120 c= C124 & C120 c= C125);
let C126 being (Element of ( NAT ));
let C127 being Int-Location;
let C128 being FinSeq-Location;
set D84 = ( Comput (C124 , C122 , ( C126 + 1 )) );
set D85 = ( Comput (C125 , C123 , ( C126 + 1 )) );
L381: ( D84 | ( dom C121 ) ) = ( D85 | ( dom C121 ) ) by L379 , L380 , EXTPRO_1:def 10;
set D86 = ( Comput (C125 , C123 , C126) );
set D87 = ( Comput (C124 , C122 , C126) );
set D88 = ( CurInstr (C124 , ( Comput (C124 , C122 , C126) )) );
L382: D84 = ( Following (C124 , D87) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C124 , D87) ) , D87) );
L383: (C127 in ( dom C121 ) implies (( ( D84 | ( dom C121 ) ) . C127 ) = ( D84 . C127 ) & ( ( D85 | ( dom C121 ) ) . C127 ) = ( D85 . C127 ))) by FUNCT_1:49;
L384: D85 = ( Following (C125 , D86) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C125 , D86) ) , D86) );
assume that
L385: D88 = ( C127 :=len C128 )
and
L386: (C127 in ( dom C121 ) & ( len ( ( Comput (C124 , C122 , C126) ) . C128 ) ) <> ( len ( ( Comput (C125 , C123 , C126) ) . C128 ) ));
L387: (( ( Exec (D88 , D87) ) . C127 ) = ( len ( D87 . C128 ) ) & ( ( Exec (D88 , D86) ) . C127 ) = ( len ( D86 . C128 ) )) by L385 , SCMFSA_2:74;
thus L388: contradiction by L387 , L379 , L382 , L384 , L383 , L381 , L386 , L380 , AMISTD_5:7;
end;
theorem
L389: (for B118 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function holds (for B119 being B118 -autonomic non  empty (FinPartState of ( SCM+FSA )) holds (for B120 , B121 being (State of ( SCM+FSA )) holds ((B119 c= B120 & B119 c= B121) implies (for B122 , B123 being (Instruction-Sequence of ( SCM+FSA )) holds ((B118 c= B122 & B118 c= B123) implies (for B124 being (Element of ( NAT )) holds (for B125 being Int-Location holds (for B126 being FinSeq-Location holds ((( CurInstr (B122 , ( Comput (B122 , B120 , B124) )) ) = ( B126 :=<0,...,0> B125 ) & B126 in ( dom B119 )) implies (for B127 , B128 being (Element of ( NAT )) holds ((B127 = ( abs ( ( Comput (B122 , B120 , B124) ) . B125 ) ) & B128 = ( abs ( ( Comput (B123 , B121 , B124) ) . B125 ) )) implies ( B127 |-> ( 0 ) ) = ( B128 |-> ( 0 ) )))))))))))))
proof
let C129 being non  halt-free  finite (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined Function;
let C130 being C129 -autonomic non  empty (FinPartState of ( SCM+FSA ));
let C131 , C132 being (State of ( SCM+FSA ));
assume that
L390: (C130 c= C131 & C130 c= C132);
let C133 , C134 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L391: (C129 c= C133 & C129 c= C134);
let C135 being (Element of ( NAT ));
let C136 being Int-Location;
let C137 being FinSeq-Location;
set D89 = ( Comput (C133 , C131 , ( C135 + 1 )) );
set D90 = ( Comput (C134 , C132 , ( C135 + 1 )) );
L392: ( D89 | ( dom C130 ) ) = ( D90 | ( dom C130 ) ) by L390 , L391 , EXTPRO_1:def 10;
set D91 = ( Comput (C134 , C132 , C135) );
set D92 = ( Comput (C133 , C131 , C135) );
set D93 = ( CurInstr (C133 , ( Comput (C133 , C131 , C135) )) );
L393: D89 = ( Following (C133 , D92) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C133 , D92) ) , D92) );
L394: (C137 in ( dom C130 ) implies (( ( D89 | ( dom C130 ) ) . C137 ) = ( D89 . C137 ) & ( ( D90 | ( dom C130 ) ) . C137 ) = ( D90 . C137 ))) by FUNCT_1:49;
L395: D90 = ( Following (C134 , D91) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C134 , D91) ) , D91) );
assume that
L396: D93 = ( C137 :=<0,...,0> C136 )
and
L397: C137 in ( dom C130 );
L398: ((ex B129 being (Element of ( NAT )) st (B129 = ( abs ( D92 . C136 ) ) & ( ( Exec (D93 , D92) ) . C137 ) = ( B129 |-> ( 0 ) ))) & (ex B130 being (Element of ( NAT )) st (B130 = ( abs ( D91 . C136 ) ) & ( ( Exec (D93 , D91) ) . C137 ) = ( B130 |-> ( 0 ) )))) by L396 , SCMFSA_2:75;
let C138 , C139 being (Element of ( NAT ));
assume L399: (C138 = ( abs ( D92 . C136 ) ) & C139 = ( abs ( D91 . C136 ) ) & ( C138 |-> ( 0 ) ) <> ( C139 |-> ( 0 ) ));
thus L400: contradiction by L399 , L390 , L393 , L395 , L394 , L392 , L398 , L397 , L391 , AMISTD_5:7;
end;
