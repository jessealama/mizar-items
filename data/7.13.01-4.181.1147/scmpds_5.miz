:: Computation of Two Consecutive Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, AMI_1, FSM_1, INT_1, SETFAM_1,
      RELAT_1, SCMFSA_7, CARD_1, SCMPDS_4, FUNCT_1, AMISTD_2, VALUED_1,
      ARYTM_3, TARSKI, XXREAL_0, TURING_1, FUNCT_4, XBOOLE_0, SCMFSA6B,
      CIRCUIT2, GRAPHSP, MSUALG_1, AMI_2, AMI_3, SCMPDS_1, COMPLEX1, STRUCT_0,
      ARYTM_1, NAT_1, SCMPDS_5, ORDINAL1, PARTFUN1, EXTPRO_1, SCMFSA6C,
      COMPOS_1, SCMFSA6A;
 notations TARSKI, XBOOLE_0,
      XTUPLE_0, SETFAM_1, ENUMSET1, SUBSET_1, CARD_1, NUMBERS,
      XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, INT_1, ORDINAL1, NAT_1,
      STRUCT_0, MEMSTR_0, COMPOS_0, COMPOS_1, EXTPRO_1, VALUED_1, AMI_2,
      FUNCT_7, SCMPDS_I, SCMPDS_1, SCMPDS_2, INT_2, SCMPDS_4, XXREAL_0;
 constructors ENUMSET1, XXREAL_0, REAL_1, INT_2, SCMPDS_1, SCMPDS_4, PRE_POLY,
      DOMAIN_1, AMI_3, NAT_D, MEMSTR_0, RELSET_1, XTUPLE_0;
 registrations SETFAM_1, FUNCT_1, NUMBERS, XREAL_0, INT_1, SCMPDS_2, SCMPDS_4,
      ORDINAL1, XBOOLE_0, VALUED_1, AFINSQ_1, COMPOS_1, RELAT_1, EXTPRO_1,
      FUNCT_4, MEMSTR_0, AMI_3, COMPOS_0, XTUPLE_0;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, SCMPDS_4, NAT_1, AFINSQ_1, EXTPRO_1, MEMSTR_0,
      COMPOS_0, XTUPLE_0;
 theorems NAT_1, TARSKI, FUNCT_4, FUNCT_1, INT_1, RELAT_1, SCMPDS_2, SCMPDS_3,
      ENUMSET1, ABSVALUE, GRFUNC_1, SCMPDS_4, MEMSTR_0, XBOOLE_0, XBOOLE_1,
      XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0, VALUED_1, AFINSQ_1, PBOOLE,
      PARTFUN1, COMPOS_1, EXTPRO_1, AMI_2, RECDEF_2, COMPOS_0;
 schemes NAT_1;

begin
L1: ( card ( Stop ( SCMPDS ) ) ) = 1 by AFINSQ_1:33;
canceled 11;
theorem
L2: (for B1 , B2 being (Program of ( SCMPDS )) holds B1 c= ( stop ( B1 ';' B2 ) ))
proof
let C1 , C2 being (Program of ( SCMPDS ));
set D1 = ( C1 ';' ( C2 ';' ( Stop ( SCMPDS ) ) ) );
set D2 = ( stop ( C1 ';' C2 ) );
L3: C1 c= D1 by AFINSQ_1:74;
thus L4: thesis by L3 , AFINSQ_1:27;
end;
theorem
L5: (for R15 being (Program of ( SCMPDS )) holds (for R16 being (Program of ( SCMPDS )) holds ( dom ( stop R15 ) ) c= ( dom ( stop ( R15 ';' R16 ) ) )))
proof
let R15 being (Program of ( SCMPDS ));
let R16 being (Program of ( SCMPDS ));
set D3 = ( stop R15 );
set D4 = ( stop ( R15 ';' R16 ) );
L6: ( card D4 ) = ( ( card ( R15 ';' R16 ) ) + 1 ) by L1 , AFINSQ_1:17
.= ( ( ( card R15 ) + ( card R16 ) ) + 1 ) by AFINSQ_1:17
.= ( ( ( card R15 ) + 1 ) + ( card R16 ) );
L7: ( card D3 ) = ( ( card R15 ) + 1 ) by L1 , AFINSQ_1:17;
L8: ( card D3 ) <= ( card D4 ) by L7 , L6 , NAT_1:11;
L9:
now
set D5 = ( NAT );
let C3 being set;
assume L10: C3 in ( dom D3 );
L11: ( dom D3 ) c= D5 by RELAT_1:def 18;
reconsider D6 = C3 as (Element of ( NAT )) by L11 , L10;
reconsider D7 = D6 as (Element of ( NAT ));
L12: D7 < ( card D3 ) by L10 , AFINSQ_1:66;
L13: D7 < ( card D4 ) by L12 , L8 , XXREAL_0:2;
thus L14: C3 in ( dom D4 ) by L13 , AFINSQ_1:66;
end;
thus L15: thesis by L9 , TARSKI:def 3;
end;
theorem
L16: (for B3 , B4 being (Program of ( SCMPDS )) holds ( ( stop B3 ) +* ( stop ( B3 ';' B4 ) ) ) = ( stop ( B3 ';' B4 ) ))
proof
let C4 , C5 being (Program of ( SCMPDS ));
set D8 = ( stop C4 );
set D9 = D8;
set D10 = ( stop ( C4 ';' C5 ) );
set D11 = D10;
L17: ( dom D8 ) c= ( dom D10 ) by L5;
thus L18: thesis by L17 , FUNCT_4:19;
end;
set D12 = ( Start-At (( 0 ) , ( SCMPDS )) );
theorem
L19: (for R4 being Int_position holds (for R8 being (State of ( SCMPDS )) holds ( ( Initialize R8 ) . R4 ) = ( R8 . R4 )))
proof
let R4 being Int_position;
let R8 being (State of ( SCMPDS ));
L20: (not R4 in ( dom D12 )) by SCMPDS_4:18;
thus L21: ( ( Initialize R8 ) . R4 ) = ( R8 . R4 ) by L20 , FUNCT_4:11;
end;
theorem
L22: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for R20 being (Instruction-Sequence of ( SCMPDS )) holds (for B5 being ( 0 ) -started (State of ( SCMPDS )) holds (for B6 being  parahalting (Program of ( SCMPDS )) holds ((( stop B6 ) c= R19 & ( stop B6 ) c= R20) implies (for B7 being (Element of ( NAT )) holds (( Comput (R19 , B5 , B7) ) = ( Comput (R20 , B5 , B7) ) & ( CurInstr (R19 , ( Comput (R19 , B5 , B7) )) ) = ( CurInstr (R20 , ( Comput (R20 , B5 , B7) )) ))))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let R20 being (Instruction-Sequence of ( SCMPDS ));
let C6 being ( 0 ) -started (State of ( SCMPDS ));
let C7 being  parahalting (Program of ( SCMPDS ));
set D13 = ( stop C7 );
assume that
L23: D13 c= R19
and
L24: D13 c= R20;
let C8 being (Element of ( NAT ));
L25: ( IC ( Comput (R19 , C6 , C8) ) ) in ( dom D13 ) by L23 , SCMPDS_4:def 6;
L26: ( IC ( Comput (R20 , C6 , C8) ) ) in ( dom D13 ) by L24 , SCMPDS_4:def 6;
L27: (for B8 being (Element of ( NAT )) holds (B8 < C8 implies ( IC ( Comput (R20 , C6 , B8) ) ) in ( dom D13 ))) by L24 , SCMPDS_4:def 6;
thus L28: ( Comput (R19 , C6 , C8) ) = ( Comput (R20 , C6 , C8) ) by L27 , L23 , L24 , SCMPDS_4:21;
thus L29: ( CurInstr (R20 , ( Comput (R20 , C6 , C8) )) ) = ( R20 . ( IC ( Comput (R20 , C6 , C8) ) ) ) by PBOOLE:143
.= ( D13 . ( IC ( Comput (R20 , C6 , C8) ) ) ) by L24 , L26 , GRFUNC_1:2
.= ( R19 . ( IC ( Comput (R19 , C6 , C8) ) ) ) by L23 , L28 , L25 , GRFUNC_1:2
.= ( CurInstr (R19 , ( Comput (R19 , C6 , C8) )) ) by PBOOLE:143;
end;
theorem
L30: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for R20 being (Instruction-Sequence of ( SCMPDS )) holds (for B9 being ( 0 ) -started (State of ( SCMPDS )) holds (for B10 being  parahalting (Program of ( SCMPDS )) holds ((( stop B10 ) c= R19 & ( stop B10 ) c= R20) implies (( LifeSpan (R19 , B9) ) = ( LifeSpan (R20 , B9) ) & ( Result (R19 , B9) ) = ( Result (R20 , B9) )))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let R20 being (Instruction-Sequence of ( SCMPDS ));
let C9 being ( 0 ) -started (State of ( SCMPDS ));
let C10 being  parahalting (Program of ( SCMPDS ));
set D14 = ( stop C10 );
assume that
L31: D14 c= R19
and
L32: D14 c= R20;
L33: R20 halts_on C9 by L32 , SCMPDS_4:def 7;
L34: R19 halts_on C9 by L31 , SCMPDS_4:def 7;
L35:
now
let C11 being (Element of ( NAT ));
assume L36: ( CurInstr (R20 , ( Comput (R20 , C9 , C11) )) ) = ( halt ( SCMPDS ) );
L37: ( CurInstr (R19 , ( Comput (R19 , C9 , C11) )) ) = ( CurInstr (R20 , ( Comput (R20 , C9 , C11) )) ) by L31 , L32 , L22;
thus L38: ( LifeSpan (R19 , C9) ) <= C11 by L37 , L34 , L36 , EXTPRO_1:def 15;
end;
L39: ( CurInstr (R20 , ( Comput (R20 , C9 , ( LifeSpan (R19 , C9) )) )) ) = ( CurInstr (R19 , ( Comput (R19 , C9 , ( LifeSpan (R19 , C9) )) )) ) by L31 , L32 , L22
.= ( halt ( SCMPDS ) ) by L34 , EXTPRO_1:def 15;
thus L40: ( LifeSpan (R19 , C9) ) = ( LifeSpan (R20 , C9) ) by L39 , L35 , L33 , EXTPRO_1:def 15;
L41: R20 halts_on C9 by L32 , SCMPDS_4:def 7;
L42: ( Result (R20 , C9) ) = ( Comput (R20 , C9 , ( LifeSpan (R19 , C9) )) ) by L41 , L40 , EXTPRO_1:23;
L43: R19 halts_on C9 by L31 , SCMPDS_4:def 7;
L44: ( Result (R19 , C9) ) = ( Comput (R19 , C9 , ( LifeSpan (R19 , C9) )) ) by L43 , EXTPRO_1:23;
thus L45: thesis by L44 , L31 , L32 , L42 , L22;
end;
canceled 1;
theorem
L46: (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B11 being ( 0 ) -started (State of ( SCMPDS )) holds (for B12 being  parahalting (Program of ( SCMPDS )) holds (for B13 being (Program of ( SCMPDS )) holds (( stop B12 ) c= R18 implies (for R2 being (Element of ( NAT )) holds (R2 <= ( LifeSpan (R18 , B11) ) implies ( Comput (R18 , B11 , R2) ) = ( Comput (( R18 +* ( B12 ';' B13 ) ) , B11 , R2) ))))))))
proof
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C12 being ( 0 ) -started (State of ( SCMPDS ));
let C13 being  parahalting (Program of ( SCMPDS ));
let C14 being (Program of ( SCMPDS ));
set D15 = ( stop C13 );
defpred S1[ (Element of ( NAT )) ] means ($1 <= ( LifeSpan (R18 , C12) ) implies ( Comput (R18 , C12 , $1) ) = ( Comput (( R18 +* ( C13 ';' C14 ) ) , C12 , $1) ));
assume L47: D15 c= R18;
L48: R18 halts_on C12 by L47 , SCMPDS_4:def 7;
L49: (for R2 being (Element of ( NAT )) holds (S1[ R2 ] implies S1[ ( R2 + 1 ) ]))
proof
L50: ( dom ( C13 ';' C14 ) ) = ( ( dom C13 ) \/ ( dom ( Shift (C14 , ( card C13 )) ) ) ) by FUNCT_4:def 1;
L51: ( dom C13 ) c= ( dom ( C13 ';' C14 ) ) by L50 , XBOOLE_1:7;
let R2 being (Element of ( NAT ));
assume L52: (R2 <= ( LifeSpan (R18 , C12) ) implies ( Comput (R18 , C12 , R2) ) = ( Comput (( R18 +* ( C13 ';' C14 ) ) , C12 , R2) ));
assume L53: ( R2 + 1 ) <= ( LifeSpan (R18 , C12) );
L54: ( Comput (( R18 +* ( C13 ';' C14 ) ) , C12 , ( R2 + 1 )) ) = ( Following (( R18 +* ( C13 ';' C14 ) ) , ( Comput (( R18 +* ( C13 ';' C14 ) ) , C12 , R2) )) ) by EXTPRO_1:3;
L55: ( Comput (R18 , C12 , ( R2 + 1 )) ) = ( Following (R18 , ( Comput (R18 , C12 , R2) )) ) by EXTPRO_1:3;
L56: ( C13 ';' C14 ) c= ( R18 +* ( C13 ';' C14 ) ) by FUNCT_4:25;
L57: ( IC ( Comput (R18 , C12 , R2) ) ) in ( dom D15 ) by L47 , SCMPDS_4:def 6;
L58: ( R18 /. ( IC ( Comput (R18 , C12 , R2) ) ) ) = ( R18 . ( IC ( Comput (R18 , C12 , R2) ) ) ) by PBOOLE:143;
L59: ( CurInstr (R18 , ( Comput (R18 , C12 , R2) )) ) = ( D15 . ( IC ( Comput (R18 , C12 , R2) ) ) ) by L57 , L58 , L47 , GRFUNC_1:2;
L60: ( ( R18 +* ( C13 ';' C14 ) ) /. ( IC ( Comput (( R18 +* ( C13 ';' C14 ) ) , C12 , R2) ) ) ) = ( ( R18 +* ( C13 ';' C14 ) ) . ( IC ( Comput (( R18 +* ( C13 ';' C14 ) ) , C12 , R2) ) ) ) by PBOOLE:143;
L61: R2 < ( LifeSpan (R18 , C12) ) by L53 , NAT_1:13;
L62: ( D15 . ( IC ( Comput (R18 , C12 , R2) ) ) ) <> ( halt ( SCMPDS ) ) by L61 , L48 , L59 , EXTPRO_1:def 15;
L63: ( IC ( Comput (R18 , C12 , R2) ) ) in ( dom C13 ) by L62 , L57 , COMPOS_1:51;
L64: ( CurInstr (R18 , ( Comput (R18 , C12 , R2) )) ) = ( C13 . ( IC ( Comput (R18 , C12 , R2) ) ) ) by L59 , L63 , AFINSQ_1:def 3
.= ( ( C13 ';' C14 ) . ( IC ( Comput (R18 , C12 , R2) ) ) ) by L63 , AFINSQ_1:def 3
.= ( CurInstr (( R18 +* ( C13 ';' C14 ) ) , ( Comput (( R18 +* ( C13 ';' C14 ) ) , C12 , R2) )) ) by L53 , L56 , L63 , L51 , L60 , L52 , GRFUNC_1:2 , NAT_1:13;
thus L65: thesis by L64 , L52 , L53 , L55 , L54 , NAT_1:13;
end;
L66: S1[ ( 0 ) ];
thus L67: (for R2 being (Element of ( NAT )) holds S1[ R2 ]) from NAT_1:sch 1(L66 , L49);
end;
theorem
L68: (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B14 being ( 0 ) -started (State of ( SCMPDS )) holds (for B15 being  parahalting (Program of ( SCMPDS )) holds (for B16 being (Program of ( SCMPDS )) holds (( stop B15 ) c= R18 implies (for R2 being (Element of ( NAT )) holds (R2 <= ( LifeSpan (R18 , B14) ) implies ( Comput (R18 , B14 , R2) ) = ( Comput (( R18 +* ( stop ( B15 ';' B16 ) ) ) , B14 , R2) ))))))))
proof
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C15 being ( 0 ) -started (State of ( SCMPDS ));
let C16 being  parahalting (Program of ( SCMPDS ));
let C17 being (Program of ( SCMPDS ));
assume L69: ( stop C16 ) c= R18;
set D16 = ( stop ( C16 ';' C17 ) );
set D17 = ( Stop ( SCMPDS ) );
let R2 being (Element of ( NAT ));
assume L70: R2 <= ( LifeSpan (R18 , C15) );
L71: ( R18 +* D16 ) = ( R18 +* ( C16 ';' ( C17 ';' D17 ) ) ) by AFINSQ_1:27;
thus L72: thesis by L71 , L69 , L70 , L46;
end;
L73: ( Load ( ( DataLoc (( 0 ) , ( 0 )) ) := ( 0 ) ) ) is  parahalting
proof
set D18 = ( ( DataLoc (( 0 ) , ( 0 )) ) := ( 0 ) );
set D19 = ( stop ( Load D18 ) );
let C18 being ( 0 ) -started (State of ( SCMPDS ));
let R18 being (Instruction-Sequence of ( SCMPDS ));
assume that
L74: D19 c= R18;
L75: D19 = ( Macro D18 );
take 1;
L76: ( IC ( Comput (R18 , C18 , 1) ) ) in ( NAT );
thus L77: ( IC ( Comput (R18 , C18 , 1) ) ) in ( dom R18 ) by L76 , PARTFUN1:def 2;
L78: ( IC C18 ) = ( 0 ) by MEMSTR_0:def 11;
L79: ( IC ( Exec (D18 , C18) ) ) = ( succ ( 0 ) ) by L78 , SCMPDS_2:45
.= ( ( 0 ) + 1 );
L80: 1 in ( dom D19 ) by L75 , COMPOS_1:57;
L81: ( D19 . 1 ) = ( R18 . 1 ) by L80 , L74 , GRFUNC_1:2;
L82: ( R18 . 1 ) = ( halt ( SCMPDS ) ) by L81 , L75 , COMPOS_1:59;
L83: ( 0 ) in ( dom D19 ) by L75 , COMPOS_1:57;
L84: ( D19 . ( 0 ) ) = ( R18 . ( 0 ) ) by L83 , L74 , GRFUNC_1:2;
L85: ( R18 /. ( IC C18 ) ) = ( R18 . ( IC C18 ) ) by PBOOLE:143;
L86: ( Comput (R18 , C18 , ( ( 0 ) + 1 )) ) = ( Following (R18 , ( Comput (R18 , C18 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (R18 , C18) )
.= ( Exec (D18 , C18) ) by L78 , L84 , L85 , L75 , COMPOS_1:58;
thus L87: thesis by L86 , L82 , L79 , PBOOLE:143;
end;
begin
definition
canceled 1;
let C19 being (Instruction of ( SCMPDS ));
attr C19 is  parahalting
means
:L88: ( Load C19 ) is  parahalting;
end;
registration
cluster  No-StopCode  shiftable  parahalting for (Instruction of ( SCMPDS ));
existence
proof
take D20 = ( ( DataLoc (( 0 ) , ( 0 )) ) := ( 0 ) );
L90: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by COMPOS_1:70;
L91: ( InsCode D20 ) = 2 by SCMPDS_2:14;
L92: D20 <> ( halt ( SCMPDS ) ) by L91 , L90;
thus L93: D20 is  No-StopCode by L92 , COMPOS_0:def 12;
thus L94: thesis by L88 , L73;
end;
end;
theorem
L96: (for R11 being Integer holds ( goto R11 ) is  No-StopCode)
proof
let R11 being Integer;
L97: ( InsCode ( goto R11 ) ) = 14 by SCMPDS_2:12;
L98: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by COMPOS_1:70;
thus L99: ( goto R11 ) <> ( halt (the InstructionsF of ( SCMPDS )) ) by L98 , L97;
end;
registration
let R4 being Int_position;
cluster ( return R4 ) ->  No-StopCode;
coherence
proof
set D21 = ( return R4 );
L100: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by RECDEF_2:def 1;
L101: ( InsCode D21 ) = 1 by SCMPDS_2:13;
L102: D21 <> ( halt ( SCMPDS ) ) by L101 , L100;
thus L103: thesis by L102 , COMPOS_0:def 12;
end;
end;
registration
let R4 being Int_position;
let R11 being Integer;
cluster ( R4 := R11 ) ->  No-StopCode;
coherence
proof
set D22 = ( R4 := R11 );
L105: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by RECDEF_2:def 1;
L106: ( InsCode D22 ) = 2 by SCMPDS_2:14;
L107: D22 <> ( halt ( SCMPDS ) ) by L106 , L105;
thus L108: thesis by L107 , COMPOS_0:def 12;
end;
cluster ( saveIC (R4 , R11) ) ->  No-StopCode;
coherence
proof
set D23 = ( saveIC (R4 , R11) );
L109: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by RECDEF_2:def 1;
L110: ( InsCode D23 ) = 3 by SCMPDS_2:15;
L111: D23 <> ( halt ( SCMPDS ) ) by L110 , L109;
thus L112: thesis by L111 , COMPOS_0:def 12;
end;
end;
registration
let R4 being Int_position;
let R11 being Integer;
let R12 being Integer;
cluster ( (R4 , R11) <>0_goto R12 ) ->  No-StopCode;
coherence
proof
set D24 = ( (R4 , R11) <>0_goto R12 );
L114: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by RECDEF_2:def 1;
L115: ( InsCode D24 ) = 4 by SCMPDS_2:16;
L116: D24 <> ( halt ( SCMPDS ) ) by L115 , L114;
thus L117: thesis by L116 , COMPOS_0:def 12;
end;
cluster ( (R4 , R11) <=0_goto R12 ) ->  No-StopCode;
coherence
proof
set D25 = ( (R4 , R11) <=0_goto R12 );
L118: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by RECDEF_2:def 1;
L119: ( InsCode D25 ) = 5 by SCMPDS_2:17;
L120: D25 <> ( halt ( SCMPDS ) ) by L119 , L118;
thus L121: thesis by L120 , COMPOS_0:def 12;
end;
cluster ( (R4 , R11) >=0_goto R12 ) ->  No-StopCode;
coherence
proof
set D26 = ( (R4 , R11) >=0_goto R12 );
L122: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by RECDEF_2:def 1;
L123: ( InsCode D26 ) = 6 by SCMPDS_2:18;
L124: D26 <> ( halt ( SCMPDS ) ) by L123 , L122;
thus L125: thesis by L124 , COMPOS_0:def 12;
end;
cluster ( (R4 , R11) := R12 ) ->  No-StopCode;
coherence
proof
set D27 = ( (R4 , R11) := R12 );
L126: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by RECDEF_2:def 1;
L127: ( InsCode D27 ) = 7 by SCMPDS_2:19;
L128: D27 <> ( halt ( SCMPDS ) ) by L127 , L126;
thus L129: thesis by L128 , COMPOS_0:def 12;
end;
end;
registration
let R4 being Int_position;
let R11 being Integer;
let R12 being Integer;
cluster ( AddTo (R4 , R11 , R12) ) ->  No-StopCode;
coherence
proof
set D28 = ( AddTo (R4 , R11 , R12) );
L131: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by RECDEF_2:def 1;
L132: ( InsCode D28 ) = 8 by SCMPDS_2:20;
L133: D28 <> ( halt ( SCMPDS ) ) by L132 , L131;
thus L134: thesis by L133 , COMPOS_0:def 12;
end;
end;
registration
let R4 being Int_position;
let R5 being Int_position;
let R11 being Integer;
let R12 being Integer;
cluster ( AddTo (R4 , R11 , R5 , R12) ) ->  No-StopCode;
coherence
proof
set D29 = ( AddTo (R4 , R11 , R5 , R12) );
L136: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by RECDEF_2:def 1;
L137: ( InsCode D29 ) = 9 by SCMPDS_2:21;
L138: D29 <> ( halt ( SCMPDS ) ) by L137 , L136;
thus L139: thesis by L138 , COMPOS_0:def 12;
end;
cluster ( SubFrom (R4 , R11 , R5 , R12) ) ->  No-StopCode;
coherence
proof
set D30 = ( SubFrom (R4 , R11 , R5 , R12) );
L140: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by RECDEF_2:def 1;
L141: ( InsCode D30 ) = 10 by SCMPDS_2:22;
L142: D30 <> ( halt ( SCMPDS ) ) by L141 , L140;
thus L143: thesis by L142 , COMPOS_0:def 12;
end;
cluster ( MultBy (R4 , R11 , R5 , R12) ) ->  No-StopCode;
coherence
proof
set D31 = ( MultBy (R4 , R11 , R5 , R12) );
L144: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by RECDEF_2:def 1;
L145: ( InsCode D31 ) = 11 by SCMPDS_2:23;
L146: D31 <> ( halt ( SCMPDS ) ) by L145 , L144;
thus L147: thesis by L146 , COMPOS_0:def 12;
end;
cluster ( Divide (R4 , R11 , R5 , R12) ) ->  No-StopCode;
coherence
proof
set D32 = ( Divide (R4 , R11 , R5 , R12) );
L148: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by RECDEF_2:def 1;
L149: ( InsCode D32 ) = 12 by SCMPDS_2:24;
L150: D32 <> ( halt ( SCMPDS ) ) by L149 , L148;
thus L151: thesis by L150 , COMPOS_0:def 12;
end;
cluster ( (R4 , R11) := (R5 , R12) ) ->  No-StopCode;
coherence
proof
set D33 = ( (R4 , R11) := (R5 , R12) );
L152: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by RECDEF_2:def 1;
L153: ( InsCode D33 ) = 13 by SCMPDS_2:25;
L154: D33 <> ( halt ( SCMPDS ) ) by L153 , L152;
thus L155: thesis by L154 , COMPOS_0:def 12;
end;
end;
registration
cluster ( halt ( SCMPDS ) ) ->  parahalting;
coherence
proof
L157: ( Stop ( SCMPDS ) ) = ( Load ( halt ( SCMPDS ) ) );
thus L158: thesis by L157 , L88;
end;
end;
registration
let C20 being  parahalting (Instruction of ( SCMPDS ));
cluster ( Load C20 ) ->  parahalting for (Program of ( SCMPDS ));
coherence by L88;
end;
L161: (for R7 being (Instruction of ( SCMPDS )) holds ((for R8 being (State of ( SCMPDS )) holds ( ( Exec (R7 , R8) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R8 ) )) implies ( Load R7 ) is  parahalting))
proof
let R7 being (Instruction of ( SCMPDS ));
assume L162: (for R8 being (State of ( SCMPDS )) holds ( ( Exec (R7 , R8) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R8 ) ));
set D34 = ( stop ( Load R7 ) );
let C21 being ( 0 ) -started (State of ( SCMPDS ));
L163: D34 = ( Macro R7 );
let R21 being (Instruction-Sequence of ( SCMPDS ));
assume that
L164: D34 c= R21;
take 1;
L165: ( IC ( Comput (R21 , C21 , 1) ) ) in ( NAT );
thus L166: ( IC ( Comput (R21 , C21 , 1) ) ) in ( dom R21 ) by L165 , PARTFUN1:def 2;
L167: ( IC C21 ) = ( 0 ) by MEMSTR_0:def 11;
L168: ( IC ( Exec (R7 , C21) ) ) = ( succ ( 0 ) ) by L167 , L162
.= ( ( 0 ) + 1 );
L169: 1 in ( dom D34 ) by L163 , COMPOS_1:57;
L170: ( D34 . 1 ) = ( R21 . 1 ) by L169 , L164 , GRFUNC_1:2;
L171: ( R21 . 1 ) = ( halt ( SCMPDS ) ) by L170 , L163 , COMPOS_1:59;
L172: ( 0 ) in ( dom D34 ) by L163 , COMPOS_1:57;
L173: ( D34 . ( 0 ) ) = ( R21 . ( 0 ) ) by L172 , L164 , GRFUNC_1:2;
L174: ( R21 /. ( IC C21 ) ) = ( R21 . ( IC C21 ) ) by PBOOLE:143;
L175: ( Comput (R21 , C21 , ( ( 0 ) + 1 )) ) = ( Following (R21 , ( Comput (R21 , C21 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (R21 , C21) )
.= ( Exec (R7 , C21) ) by L167 , L173 , L174 , L163 , COMPOS_1:58;
thus L176: thesis by L175 , L168 , L171 , PBOOLE:143;
end;
registration
let R4 being Int_position;
let R11 being Integer;
cluster ( R4 := R11 ) ->  parahalting;
coherence
proof
set D35 = ( R4 := R11 );
L177: (for R8 being (State of ( SCMPDS )) holds ( ( Exec (D35 , R8) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R8 ) )) by SCMPDS_2:45;
L178: ( Load D35 ) is  parahalting by L177 , L161;
thus L179: thesis by L178 , L88;
end;
end;
registration
let R4 being Int_position;
let R11 being Integer;
let R12 being Integer;
cluster ( (R4 , R11) := R12 ) ->  parahalting;
coherence
proof
set D36 = ( (R4 , R11) := R12 );
L181: (for R8 being (State of ( SCMPDS )) holds ( ( Exec (D36 , R8) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R8 ) )) by SCMPDS_2:46;
L182: ( Load D36 ) is  parahalting by L181 , L161;
thus L183: thesis by L182 , L88;
end;
cluster ( AddTo (R4 , R11 , R12) ) ->  parahalting;
coherence
proof
set D37 = ( AddTo (R4 , R11 , R12) );
L184: (for R8 being (State of ( SCMPDS )) holds ( ( Exec (D37 , R8) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R8 ) )) by SCMPDS_2:48;
L185: ( Load D37 ) is  parahalting by L184 , L161;
thus L186: thesis by L185 , L88;
end;
end;
registration
let R4 being Int_position;
let R5 being Int_position;
let R11 being Integer;
let R12 being Integer;
cluster ( AddTo (R4 , R11 , R5 , R12) ) ->  parahalting;
coherence
proof
set D38 = ( AddTo (R4 , R11 , R5 , R12) );
L188: (for R8 being (State of ( SCMPDS )) holds ( ( Exec (D38 , R8) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R8 ) )) by SCMPDS_2:49;
L189: ( Load D38 ) is  parahalting by L188 , L161;
thus L190: thesis by L189 , L88;
end;
cluster ( SubFrom (R4 , R11 , R5 , R12) ) ->  parahalting;
coherence
proof
set D39 = ( SubFrom (R4 , R11 , R5 , R12) );
L191: (for R8 being (State of ( SCMPDS )) holds ( ( Exec (D39 , R8) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R8 ) )) by SCMPDS_2:50;
L192: ( Load D39 ) is  parahalting by L191 , L161;
thus L193: thesis by L192 , L88;
end;
cluster ( MultBy (R4 , R11 , R5 , R12) ) ->  parahalting;
coherence
proof
set D40 = ( MultBy (R4 , R11 , R5 , R12) );
L194: (for R8 being (State of ( SCMPDS )) holds ( ( Exec (D40 , R8) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R8 ) )) by SCMPDS_2:51;
L195: ( Load D40 ) is  parahalting by L194 , L161;
thus L196: thesis by L195 , L88;
end;
cluster ( Divide (R4 , R11 , R5 , R12) ) ->  parahalting;
coherence
proof
set D41 = ( Divide (R4 , R11 , R5 , R12) );
L197: (for R8 being (State of ( SCMPDS )) holds ( ( Exec (D41 , R8) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R8 ) )) by SCMPDS_2:52;
L198: ( Load D41 ) is  parahalting by L197 , L161;
thus L199: thesis by L198 , L88;
end;
cluster ( (R4 , R11) := (R5 , R12) ) ->  parahalting;
coherence
proof
set D42 = ( (R4 , R11) := (R5 , R12) );
L200: (for R8 being (State of ( SCMPDS )) holds ( ( Exec (D42 , R8) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R8 ) )) by SCMPDS_2:47;
L201: ( Load D42 ) is  parahalting by L200 , L161;
thus L202: thesis by L201 , L88;
end;
end;
theorem
L204: (for R7 being (Instruction of ( SCMPDS )) holds (( InsCode R7 ) = 1 implies (not R7 is  parahalting)))
proof
let R7 being (Instruction of ( SCMPDS ));
consider R8 being (State of ( SCMPDS )) such that L205: (for R4 being Int_position holds ( R8 . R4 ) = 2) by SCMPDS_2:61;
set D43 = the (Instruction-Sequence of ( SCMPDS ));
assume L206: ( InsCode R7 ) = 1;
consider R4 being Int_position such that L207: R7 = ( return R4 ) by L206 , SCMPDS_2:27;
assume L208: R7 is  parahalting;
reconsider D44 = ( Load R7 ) as  parahalting (Program of ( SCMPDS )) by L208;
set D45 = ( Macro R7 );
set D46 = ( Initialize R8 );
set D47 = ( D43 +* D45 );
L209: ( D46 . ( DataLoc (( D46 . R4 ) , ( RetIC )) ) ) = ( R8 . ( DataLoc (( D46 . R4 ) , ( RetIC )) ) ) by L19
.= 2 by L205;
L210: ( ( Exec (R7 , D46) ) . ( IC ( SCMPDS ) ) ) = ( ( abs 2 ) + 2 ) by L209 , L207 , SCMPDS_2:58
.= ( 2 + 2 ) by ABSVALUE:def 1
.= 4;
set D48 = ( Comput (D47 , D46 , 1) );
L211: ( stop D44 ) c= D47 by FUNCT_4:25;
L212: ( IC D48 ) in ( dom D45 ) by L211 , SCMPDS_4:def 6;
L213: ( 0 ) in ( dom D45 ) by COMPOS_1:57;
L214: ( D47 . ( 0 ) ) = ( D45 . ( 0 ) ) by L213 , FUNCT_4:13
.= R7 by COMPOS_1:58;
L215: ( card D45 ) = 2 by COMPOS_1:56;
L216: ( D47 /. ( IC D46 ) ) = ( D47 . ( IC D46 ) ) by PBOOLE:143;
L217: ( Comput (D47 , D46 , ( ( 0 ) + 1 )) ) = ( Following (D47 , ( Comput (D47 , D46 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D47 , D46) )
.= ( Exec (R7 , D46) ) by L214 , L216 , MEMSTR_0:47;
thus L218: contradiction by L217 , L210 , L212 , L215 , AFINSQ_1:66;
end;
registration
cluster  parahalting  shiftable  halt-free for (Program of ( SCMPDS ));
existence
proof
set D49 = ( ( DataLoc (( 0 ) , ( 0 )) ) := ( 0 ) );
take D50 = ( Load D49 );
L219:
now
let C22 being Nat;
assume L220: C22 in ( dom D50 );
L221: C22 in { ( 0 ) } by L220 , FUNCOP_1:13;
L222: C22 = ( 0 ) by L221 , TARSKI:def 1;
L223: ( D50 . C22 ) = D49 by L222 , FUNCOP_1:72;
L224: ( InsCode D49 ) = 2 by SCMPDS_2:14;
thus L225: ( D50 . C22 ) <> ( halt ( SCMPDS ) ) by L224 , L223 , COMPOS_1:70;
end;
thus L226: thesis by L219 , COMPOS_1:def 27;
end;
end;
registration
let C23 , C24 being  halt-free (Program of ( SCMPDS ));
cluster ( C23 ';' C24 ) ->  halt-free;
coherence
proof
set D51 = ( C23 ';' C24 );
set D52 = { ( R3 + ( card C23 ) ) where R3 is (Element of ( NAT )) : R3 in ( dom C24 ) };
L228: ( dom ( Shift (C24 , ( card C23 )) ) ) = D52 by VALUED_1:def 12;
L229: ( dom D51 ) = ( ( dom C23 ) \/ D52 ) by L228 , FUNCT_4:def 1;
let C25 being Nat;
assume that
L230: C25 in ( dom D51 );
per cases  by L230 , L229 , XBOOLE_0:def 3;
suppose L231: C25 in ( dom C23 );

L232: ( C23 . C25 ) = ( D51 . C25 ) by L231 , AFINSQ_1:def 3;
thus L233: ( D51 . C25 ) <> ( halt ( SCMPDS ) ) by L232 , L231 , COMPOS_1:def 27;
end;
suppose L234: C25 in D52;

consider R3 being (Element of ( NAT )) such that L235: C25 = ( R3 + ( card C23 ) ) and L236: R3 in ( dom C24 ) by L234;
L237: ( C24 . R3 ) = ( D51 . C25 ) by L235 , L236 , AFINSQ_1:def 3;
thus L238: ( D51 . C25 ) <> ( halt ( SCMPDS ) ) by L237 , L236 , COMPOS_1:def 27;
end;
end;
end;
registration
let C26 being  No-StopCode (Instruction of ( SCMPDS ));
cluster ( Load C26 ) ->  halt-free;
coherence
proof
set D53 = ( Load C26 );
L241:
now
let C27 being Nat;
assume L242: C27 in ( dom D53 );
L243: C27 = ( 0 ) by L242 , COMPOS_1:50;
L244: ( D53 . C27 ) = C26 by L243 , FUNCOP_1:72;
thus L245: ( D53 . C27 ) <> ( halt ( SCMPDS ) ) by L244 , COMPOS_0:def 12;
end;
thus L246: thesis by L241 , COMPOS_1:def 27;
end;
end;
registration
let C28 being  No-StopCode (Instruction of ( SCMPDS ));
let C29 being  halt-free (Program of ( SCMPDS ));
cluster ( C28 ';' C29 ) ->  halt-free;
coherence;
end;
registration
let C30 being  halt-free (Program of ( SCMPDS ));
let C31 being  No-StopCode (Instruction of ( SCMPDS ));
cluster ( C30 ';' C31 ) ->  halt-free;
coherence;
end;
registration
let C32 , C33 being  No-StopCode (Instruction of ( SCMPDS ));
cluster ( C32 ';' C33 ) ->  halt-free;
coherence;
end;
theorem
L251: (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B17 being ( 0 ) -started (State of ( SCMPDS )) holds (for B18 being  parahalting  halt-free (Program of ( SCMPDS )) holds (( stop B18 ) c= R18 implies ( IC ( Comput (R18 , B17 , ( LifeSpan (( R18 +* ( stop B18 ) ) , B17) )) ) ) = ( card B18 )))))
proof
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C34 being ( 0 ) -started (State of ( SCMPDS ));
let C35 being  parahalting  halt-free (Program of ( SCMPDS ));
set D54 = ( Comput (R18 , C34 , ( LifeSpan (R18 , C34) )) );
reconsider D55 = ( IC D54 ) as (Element of ( NAT ));
assume L252: ( stop C35 ) c= R18;
L253: R18 halts_on C34 by L252 , SCMPDS_4:def 7;
L254: ( R18 +* ( stop C35 ) ) = R18 by L252 , FUNCT_4:98;
L255: C35 c= ( stop C35 ) by AFINSQ_1:74;
L256: C35 c= R18 by L255 , L252 , XBOOLE_1:1;
L257:
now
assume L258: ( IC D54 ) in ( dom C35 );
L259: ( C35 . ( IC D54 ) ) = ( R18 . ( IC D54 ) ) by L258 , L256 , GRFUNC_1:2
.= ( CurInstr (R18 , D54) ) by PBOOLE:143
.= ( halt ( SCMPDS ) ) by L253 , EXTPRO_1:def 15;
thus L260: contradiction by L259 , L258 , COMPOS_1:def 27;
end;
L261: D55 >= ( card C35 ) by L257 , AFINSQ_1:66;
L262: ( card ( stop C35 ) ) = ( ( card C35 ) + 1 ) by L1 , AFINSQ_1:17;
L263: ( IC D54 ) in ( dom ( stop C35 ) ) by L252 , SCMPDS_4:def 6;
L264: D55 < ( ( card C35 ) + 1 ) by L263 , L262 , AFINSQ_1:66;
L265: D55 <= ( card C35 ) by L264 , NAT_1:13;
thus L266: thesis by L265 , L254 , L261 , XXREAL_0:1;
end;
theorem
L267: (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B19 being ( 0 ) -started (State of ( SCMPDS )) holds (for B20 being  parahalting (Program of ( SCMPDS )) holds (for B21 being (Element of ( NAT )) holds (B21 < ( LifeSpan (( R18 +* ( stop B20 ) ) , B19) ) implies ( IC ( Comput (( R18 +* ( stop B20 ) ) , B19 , B21) ) ) in ( dom B20 ))))))
proof
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C36 being ( 0 ) -started (State of ( SCMPDS ));
let C37 being  parahalting (Program of ( SCMPDS ));
let C38 being (Element of ( NAT ));
set D56 = C36;
set D57 = ( R18 +* ( stop C37 ) );
set D58 = ( LifeSpan (D57 , D56) );
set D59 = ( Comput (D57 , D56 , C38) );
set D60 = ( IC D59 );
L268: ( stop C37 ) c= D57 by FUNCT_4:25;
L269: D57 halts_on D56 by L268 , SCMPDS_4:def 7;
reconsider D61 = D60 as (Element of ( NAT ));
L270: D60 in ( dom ( stop C37 ) ) by L268 , SCMPDS_4:def 6;
L271: ( stop C37 ) c= D57 by FUNCT_4:25;
assume L272: C38 < D58;
L273:
now
assume L274: D61 = ( card C37 );
L275: ( 0 ) in ( dom ( Stop ( SCMPDS ) ) ) by COMPOS_1:3;
L276: ( ( Stop ( SCMPDS ) ) . ( 0 ) ) = ( halt ( SCMPDS ) ) by AFINSQ_1:34;
L277: ( CurInstr (D57 , D59) ) = ( D57 . D60 ) by PBOOLE:143
.= ( ( stop C37 ) . ( ( 0 ) + D61 ) ) by L270 , L271 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L274 , L276 , L275 , AFINSQ_1:def 3;
thus L278: contradiction by L277 , L272 , L269 , EXTPRO_1:def 15;
end;
L279: ( card ( stop C37 ) ) = ( ( card C37 ) + 1 ) by L1 , AFINSQ_1:17;
L280: D61 < ( ( card C37 ) + 1 ) by L279 , L270 , AFINSQ_1:66;
L281: D61 <= ( card C37 ) by L280 , INT_1:7;
L282: D61 < ( card C37 ) by L281 , L273 , XXREAL_0:1;
thus L283: thesis by L282 , AFINSQ_1:66;
end;
theorem
L284: (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B22 being ( 0 ) -started (State of ( SCMPDS )) holds (for B23 being  parahalting (Program of ( SCMPDS )) holds (for B24 being (Element of ( NAT )) holds ((B23 c= R18 & B24 <= ( LifeSpan (( R18 +* ( stop B23 ) ) , B22) )) implies ( Comput (R18 , B22 , B24) ) = ( Comput (( R18 +* ( stop B23 ) ) , B22 , B24) ))))))
proof
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C39 being ( 0 ) -started (State of ( SCMPDS ));
let C40 being  parahalting (Program of ( SCMPDS ));
let C41 being (Element of ( NAT ));
set D62 = ( LifeSpan (( R18 +* ( stop C40 ) ) , C39) );
assume that
L285: C40 c= R18
and
L286: C41 <= D62;
set D63 = C39;
set D64 = ( R18 +* ( stop C40 ) );
defpred S2[ (Element of ( NAT )) ] means ($1 <= D62 implies ( Comput (R18 , C39 , $1) ) = ( Comput (D64 , D63 , $1) ));
L287: R18 = ( R18 +* C40 ) by L285 , FUNCT_4:98;
L288:
now
let C42 being (Element of ( NAT ));
assume L289: S2[ C42 ];
L290:
now
L291: ( Comput (D64 , D63 , ( C42 + 1 )) ) = ( Following (D64 , ( Comput (D64 , D63 , C42) )) ) by EXTPRO_1:3;
L292: ( Comput (R18 , C39 , ( C42 + 1 )) ) = ( Following (R18 , ( Comput (R18 , C39 , C42) )) ) by EXTPRO_1:3;
L293: C42 < ( C42 + 1 ) by XREAL_1:29;
assume L294: ( C42 + 1 ) <= D62;
L295: C42 < D62 by L294 , L293 , XXREAL_0:2;
L296: ( IC ( Comput (D64 , D63 , C42) ) ) in ( dom C40 ) by L295 , L267;
L297: ( IC ( Comput (D64 , D63 , C42) ) ) in ( dom ( stop C40 ) ) by L296 , FUNCT_4:12;
L298: ( IC ( Comput (D64 , D63 , C42) ) ) in ( dom C40 ) by L295 , L267;
L299: ( CurInstr (R18 , ( Comput (R18 , C39 , C42) )) ) = ( R18 . ( IC ( Comput (D64 , D63 , C42) ) ) ) by L289 , L294 , L293 , PBOOLE:143 , XXREAL_0:2
.= ( C40 . ( IC ( Comput (D64 , D63 , C42) ) ) ) by L287 , L295 , L267 , FUNCT_4:13
.= ( ( stop C40 ) . ( IC ( Comput (D64 , D63 , C42) ) ) ) by L298 , AFINSQ_1:def 3
.= ( ( R18 +* ( stop C40 ) ) . ( IC ( Comput (D64 , D63 , C42) ) ) ) by L297 , FUNCT_4:13
.= ( CurInstr (D64 , ( Comput (D64 , D63 , C42) )) ) by PBOOLE:143;
thus L300: ( Comput (R18 , C39 , ( C42 + 1 )) ) = ( Comput (D64 , D63 , ( C42 + 1 )) ) by L299 , L289 , L294 , L293 , L292 , L291 , XXREAL_0:2;
end;
thus L301: S2[ ( C42 + 1 ) ] by L290;
end;
L302: S2[ ( 0 ) ];
L303: (for B25 being (Element of ( NAT )) holds S2[ B25 ]) from NAT_1:sch 1(L302 , L288);
thus L304: thesis by L303 , L286;
end;
theorem
L305: (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B26 being ( 0 ) -started (State of ( SCMPDS )) holds (for B27 being  parahalting  halt-free (Program of ( SCMPDS )) holds (B27 c= R18 implies ( IC ( Comput (R18 , B26 , ( LifeSpan (( R18 +* ( stop B27 ) ) , B26) )) ) ) = ( card B27 )))))
proof
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C43 being ( 0 ) -started (State of ( SCMPDS ));
let C44 being  parahalting  halt-free (Program of ( SCMPDS ));
set D65 = ( R18 +* ( stop C44 ) );
set D66 = ( LifeSpan (D65 , C43) );
L306: ( stop C44 ) c= D65 by FUNCT_4:25;
L307: (( ( stop C44 ) +* D65 ) = D65 & ( D65 +* ( stop C44 ) ) = D65) by L306 , FUNCT_4:97;
assume L308: C44 c= R18;
thus L309: ( IC ( Comput (R18 , C43 , D66) ) ) = ( IC ( Comput (D65 , C43 , D66) ) ) by L308 , L284
.= ( card C44 ) by L251 , L307 , FUNCT_4:25;
end;
theorem
L310: (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B28 being ( 0 ) -started (State of ( SCMPDS )) holds (for B29 being  parahalting (Program of ( SCMPDS )) holds (B29 c= R18 implies (( CurInstr (R18 , ( Comput (R18 , B28 , ( LifeSpan (( R18 +* ( stop B29 ) ) , B28) )) )) ) = ( halt ( SCMPDS ) ) or ( IC ( Comput (R18 , B28 , ( LifeSpan (( R18 +* ( stop B29 ) ) , B28) )) ) ) = ( card B29 ))))))
proof
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C45 being ( 0 ) -started (State of ( SCMPDS ));
let C46 being  parahalting (Program of ( SCMPDS ));
set D67 = ( R18 +* ( stop C46 ) );
set D68 = ( LifeSpan (D67 , C45) );
set D69 = ( Comput (R18 , C45 , D68) );
set D70 = ( Comput (D67 , C45 , ( LifeSpan (( D67 +* ( stop C46 ) ) , ( Initialize C45 )) )) );
set D71 = ( IC D70 );
L311: ( stop C46 ) c= D67 by FUNCT_4:25;
L312: D67 halts_on C45 by L311 , SCMPDS_4:def 7;
reconsider D72 = D71 as (Element of ( NAT ));
L313: D71 in ( dom ( stop C46 ) ) by L311 , SCMPDS_4:def 6;
L314: ( Initialize C45 ) = C45 by MEMSTR_0:44;
L315: ( card ( stop C46 ) ) = ( ( card C46 ) + 1 ) by L1 , AFINSQ_1:17;
L316: D72 < ( ( card C46 ) + 1 ) by L315 , L313 , AFINSQ_1:66;
L317: D72 <= ( card C46 ) by L316 , INT_1:7;
L318: ( stop C46 ) c= D67 by FUNCT_4:25;
assume L319: C46 c= R18;
L320: ( IC D69 ) = D71 by L319 , L284 , L314;
L321:
now
per cases  by L317 , XXREAL_0:1;
case L322: D72 < ( card C46 );
L323: D72 in ( dom C46 ) by L322 , AFINSQ_1:66;
thus L324: ( halt ( SCMPDS ) ) = ( CurInstr (D67 , D70) ) by L312 , L314 , EXTPRO_1:def 15
.= ( D67 . D71 ) by PBOOLE:143
.= ( ( stop C46 ) . D71 ) by L313 , L318 , GRFUNC_1:2
.= ( C46 . D71 ) by L323 , AFINSQ_1:def 3
.= ( R18 . ( IC D69 ) ) by L319 , L320 , L323 , GRFUNC_1:2
.= ( CurInstr (R18 , D69) ) by PBOOLE:143;
end;
case L325: D72 = ( card C46 );
thus L326: ( IC D69 ) = ( card C46 ) by L325 , L319 , L284 , L314;
end;
end;
thus L328: thesis by L321;
end;
theorem
L329: (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B30 being ( 0 ) -started (State of ( SCMPDS )) holds (for B31 being  parahalting  halt-free (Program of ( SCMPDS )) holds (for B32 being (Element of ( NAT )) holds ((B31 c= R18 & B32 < ( LifeSpan (( R18 +* ( stop B31 ) ) , B30) )) implies ( CurInstr (R18 , ( Comput (R18 , B30 , B32) )) ) <> ( halt ( SCMPDS ) ))))))
proof
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C47 being ( 0 ) -started (State of ( SCMPDS ));
let C48 being  parahalting  halt-free (Program of ( SCMPDS ));
let C49 being (Element of ( NAT ));
set D73 = ( R18 +* ( stop C48 ) );
set D74 = ( Comput (R18 , C47 , C49) );
set D75 = ( Comput (D73 , C47 , C49) );
assume that
L330: C48 c= R18
and
L331: C49 < ( LifeSpan (D73 , C47) );
L332: ( IC D75 ) in ( dom C48 ) by L331 , L267;
L333: ( R18 /. ( IC D74 ) ) = ( R18 . ( IC D74 ) ) by PBOOLE:143;
L334: ( CurInstr (R18 , D74) ) = ( R18 . ( IC D75 ) ) by L333 , L330 , L331 , L284
.= ( C48 . ( IC D75 ) ) by L330 , L332 , GRFUNC_1:2;
thus L335: thesis by L334 , L332 , COMPOS_1:def 27;
end;
theorem
L336: (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B33 being ( 0 ) -started (State of ( SCMPDS )) holds (for B34 being  parahalting (Program of ( SCMPDS )) holds (for B35 being (Program of ( SCMPDS )) holds (for B36 being (Element of ( NAT )) holds (B36 <= ( LifeSpan (( R18 +* ( stop B34 ) ) , B33) ) implies ( Comput (( R18 +* ( stop B34 ) ) , B33 , B36) ) = ( Comput (( R18 +* ( B34 ';' B35 ) ) , B33 , B36) )))))))
proof
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C50 being ( 0 ) -started (State of ( SCMPDS ));
let C51 being  parahalting (Program of ( SCMPDS ));
let C52 being (Program of ( SCMPDS ));
let C53 being (Element of ( NAT ));
set D76 = ( stop C51 );
set D77 = ( R18 +* D76 );
set D78 = ( R18 +* ( C51 ';' C52 ) );
set D79 = ( LifeSpan (D77 , C50) );
defpred S3[ (Element of ( NAT )) ] means ($1 <= D79 implies ( Comput (D77 , C50 , $1) ) = ( Comput (D78 , C50 , $1) ));
L337: (for B37 being (Element of ( NAT )) holds (S3[ B37 ] implies S3[ ( B37 + 1 ) ]))
proof
let C54 being (Element of ( NAT ));
assume L338: (C54 <= D79 implies ( Comput (D77 , C50 , C54) ) = ( Comput (D78 , C50 , C54) ));
L339: ( Comput (D78 , C50 , ( C54 + 1 )) ) = ( Following (D78 , ( Comput (D78 , C50 , C54) )) ) by EXTPRO_1:3;
L340: D76 c= D77 by FUNCT_4:25;
L341: ( IC ( Comput (D77 , C50 , C54) ) ) in ( dom D76 ) by L340 , SCMPDS_4:def 6;
L342: ( Comput (D77 , C50 , ( C54 + 1 )) ) = ( Following (D77 , ( Comput (D77 , C50 , C54) )) ) by EXTPRO_1:3;
assume L343: ( C54 + 1 ) <= D79;
L344: C54 < D79 by L343 , NAT_1:13;
L345: ( IC ( Comput (D77 , C50 , C54) ) ) in ( dom C51 ) by L344 , L267;
L346: ( IC ( Comput (D77 , C50 , C54) ) ) in ( dom ( C51 ';' C52 ) ) by L345 , FUNCT_4:12;
L347: ( IC ( Comput (D77 , C50 , C54) ) ) in ( dom C51 ) by L344 , L267;
L348: ( CurInstr (D77 , ( Comput (D77 , C50 , C54) )) ) = ( D77 . ( IC ( Comput (D77 , C50 , C54) ) ) ) by PBOOLE:143
.= ( D76 . ( IC ( Comput (D77 , C50 , C54) ) ) ) by L341 , FUNCT_4:13
.= ( C51 . ( IC ( Comput (D77 , C50 , C54) ) ) ) by L347 , AFINSQ_1:def 3
.= ( ( C51 ';' C52 ) . ( IC ( Comput (D77 , C50 , C54) ) ) ) by L347 , AFINSQ_1:def 3
.= ( D78 . ( IC ( Comput (D77 , C50 , C54) ) ) ) by L346 , FUNCT_4:13
.= ( CurInstr (D78 , ( Comput (D78 , C50 , C54) )) ) by L343 , L338 , NAT_1:13 , PBOOLE:143;
thus L349: thesis by L348 , L338 , L343 , L342 , L339 , NAT_1:13;
end;
L350: S3[ ( 0 ) ];
L351: (for B38 being (Element of ( NAT )) holds S3[ B38 ]) from NAT_1:sch 1(L350 , L337);
thus L352: thesis by L351;
end;
theorem
L353: (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B39 being ( 0 ) -started (State of ( SCMPDS )) holds (for B40 being  parahalting (Program of ( SCMPDS )) holds (for B41 being (Program of ( SCMPDS )) holds (for B42 being (Element of ( NAT )) holds (B42 <= ( LifeSpan (( R18 +* ( stop B40 ) ) , B39) ) implies ( Comput (( R18 +* ( stop B40 ) ) , B39 , B42) ) = ( Comput (( R18 +* ( stop ( B40 ';' B41 ) ) ) , B39 , B42) )))))))
proof
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C55 being ( 0 ) -started (State of ( SCMPDS ));
let C56 being  parahalting (Program of ( SCMPDS ));
let C57 being (Program of ( SCMPDS ));
let C58 being (Element of ( NAT ));
L354: ( stop ( C56 ';' C57 ) ) = ( C56 ';' ( C57 ';' ( Stop ( SCMPDS ) ) ) ) by AFINSQ_1:27;
thus L355: thesis by L354 , L336;
end;
registration
let C59 being  parahalting (Program of ( SCMPDS ));
let C60 being  parahalting  shiftable (Program of ( SCMPDS ));
cluster ( C59 ';' C60 ) ->  parahalting for (Program of ( SCMPDS ));
coherence
proof
let C61 being (Program of ( SCMPDS ));
assume that
L356: C61 = ( C59 ';' C60 );
let C62 being ( 0 ) -started (State of ( SCMPDS ));
let R18 being (Instruction-Sequence of ( SCMPDS ));
set D80 = ( stop C61 );
set D81 = ( stop C60 );
set D82 = ( Initialize C62 );
set D83 = ( R18 +* ( stop C59 ) );
set D84 = ( LifeSpan (D83 , D82) );
set D85 = ( Initialize ( Comput (D83 , D82 , D84) ) );
set D86 = ( D83 +* D81 );
set D87 = ( LifeSpan (D86 , D85) );
set D88 = ( SCM-Data-Loc );
L357: D81 c= D86 by FUNCT_4:25;
L358: D86 halts_on D85 by L357 , SCMPDS_4:def 7;
L359: ( DataPart ( Comput (D83 , D82 , D84) ) ) = ( DataPart D85 ) by MEMSTR_0:45;
L360: C59 c= D80 by L356 , L2;
set D89 = ( Comput (R18 , C62 , D84) );
set D90 = R18;
assume L361: D80 c= R18;
L362: C61 c= D80 by AFINSQ_1:74;
L363: C62 = ( Initialize C62 ) by MEMSTR_0:44;
L364: ( R18 +* ( C59 ';' C60 ) ) = R18 by L362 , L356 , L361 , FUNCT_4:98 , XBOOLE_1:1;
L365: ( DataPart D89 ) = ( DataPart D85 ) by L364 , L359 , L363 , L336;
per cases  by L361 , L360 , L310 , L363 , XBOOLE_1:1;
suppose L366: ( CurInstr (R18 , D89) ) = ( halt ( SCMPDS ) );

take D84;
L367: ( IC ( Comput (R18 , C62 , D84) ) ) in ( NAT );
thus L368: ( IC ( Comput (R18 , C62 , D84) ) ) in ( dom R18 ) by L367 , PARTFUN1:def 2;
thus L369: thesis by L366;
end;
suppose L370: ( IC D89 ) = ( card C59 );

reconsider D91 = ( D84 + D87 ) as (Element of ( NAT ));
take D91;
L371: ( IC ( Comput (R18 , C62 , D91) ) ) in ( NAT );
thus L372: ( IC ( Comput (R18 , C62 , D91) ) ) in ( dom R18 ) by L371 , PARTFUN1:def 2;
L373: ( Comput (R18 , C62 , ( D84 + D87 )) ) = ( Comput (R18 , ( Comput (R18 , C62 , D84) ) , D87) ) by EXTPRO_1:4;
L374: D80 = ( C59 ';' ( C60 ';' ( Stop ( SCMPDS ) ) ) ) by L356 , AFINSQ_1:27
.= ( C59 +* ( Shift (D81 , ( card C59 )) ) );
L375: ( Shift (D81 , ( card C59 )) ) c= D80 by L374 , FUNCT_4:25;
L376: ( Shift (D81 , ( card C59 )) ) c= D90 by L375 , L361 , XBOOLE_1:1;
L377: ( CurInstr (D86 , ( Comput (D86 , D85 , D87) )) ) = ( CurInstr (R18 , ( Comput (R18 , C62 , ( D84 + D87 )) )) ) by L373 , L357 , L365 , L370 , L376 , SCMPDS_4:29;
thus L378: thesis by L377 , L358 , EXTPRO_1:def 15;
end;
end;
end;
registration
let C63 being  parahalting (Instruction of ( SCMPDS ));
let C64 being  parahalting  shiftable (Program of ( SCMPDS ));
cluster ( C63 ';' C64 ) ->  parahalting;
coherence;
end;
registration
let C65 being  parahalting (Program of ( SCMPDS ));
let C66 being  parahalting  shiftable (Instruction of ( SCMPDS ));
cluster ( C65 ';' C66 ) ->  parahalting;
coherence;
end;
registration
let C67 being  parahalting (Instruction of ( SCMPDS ));
let C68 being  parahalting  shiftable (Instruction of ( SCMPDS ));
cluster ( C67 ';' C68 ) ->  parahalting;
coherence;
end;
theorem
L384: (for R2 being (Element of ( NAT )) holds (for R3 being (Element of ( NAT )) holds (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B43 being (State of ( SCMPDS )) holds (for B44 being ( 0 ) -started (State of ( SCMPDS )) holds (for B45 being  parahalting  shiftable (Program of ( SCMPDS )) holds ((( stop B45 ) c= R18 & B43 = ( Comput (( R19 +* ( stop B45 ) ) , B44 , R2) )) implies ( Exec (( CurInstr (R18 , B43) ) , ( IncIC (B43 , R3) )) ) = ( IncIC (( Following (R18 , B43) ) , R3) )))))))))
proof
let R2 being (Element of ( NAT ));
let R3 being (Element of ( NAT ));
let R18 being (Instruction-Sequence of ( SCMPDS ));
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C69 being (State of ( SCMPDS ));
let C70 being ( 0 ) -started (State of ( SCMPDS ));
let C71 being  parahalting  shiftable (Program of ( SCMPDS ));
set D92 = ( stop C71 );
set D93 = C70;
set D94 = ( R19 +* D92 );
set D95 = ( CurInstr (R18 , C69) );
set D96 = ( C69 +* ( Start-At (( ( IC C69 ) + R3 ) , ( SCMPDS )) ) );
reconsider D97 = ( IC C69 ) as (Element of ( NAT ));
reconsider D98 = ( succ ( IC C69 ) ) as (Element of ( NAT ));
L385: ( succ ( IC D96 ) ) = ( ( D97 + R3 ) + 1 ) by FUNCT_4:113
.= ( IC ( ( Exec (D95 , C69) ) +* ( Start-At (( D98 + R3 ) , ( SCMPDS )) ) ) ) by FUNCT_4:113;
assume L386: D92 c= R18;
assume L387: C69 = ( Comput (D94 , D93 , R2) );
L388: D92 c= D94 by FUNCT_4:25;
L389: ( IC C69 ) in ( dom D92 ) by L388 , L387 , SCMPDS_4:def 6;
reconsider D99 = ( IC C69 ) as (Element of ( NAT ));
set D100 = ( ( IC ( Exec (D95 , C69) ) ) + R3 );
L390: ( IC D96 ) = ( ( IC C69 ) + R3 ) by FUNCT_4:113;
L391: ( R18 /. ( IC C69 ) ) = ( R18 . ( IC C69 ) ) by PBOOLE:143;
L392: D95 = ( D92 . D99 ) by L389 , L391 , L386 , GRFUNC_1:2;
L393: ( InsCode D95 ) <> 1 by L392 , L389 , SCMPDS_4:def 9;
L394: D95 valid_at D99 by L389 , L392 , SCMPDS_4:def 9;
L395: ( InsCode D95 ) <> 3 by L389 , L392 , SCMPDS_4:def 9;
L396: ( InsCode D95 ) <= 14 by SCMPDS_2:6;
per cases  by L396 , L393 , L395 , NAT_1:60;
suppose L397: ( InsCode D95 ) = ( 0 );

L398: ( Following (R18 , C69) ) = C69 by L397 , SCMPDS_2:86;
thus L399: ( Exec (( CurInstr (R18 , C69) ) , ( IncIC (C69 , R3) )) ) = ( IncIC (C69 , R3) ) by L397 , SCMPDS_2:86
.= ( IncIC (( Following (R18 , C69) ) , R3) ) by L398;
end;
suppose L400: ( InsCode D95 ) = 14;

consider R11 being Integer such that L401: D95 = ( goto R11 ) and L402: ( D99 + R11 ) >= ( 0 ) by L400 , L394 , SCMPDS_4:def 8;
L403: ( IC ( Exec (D95 , C69) ) ) = ( ICplusConst (C69 , R11) ) by L401 , SCMPDS_2:54;
L404:
now
let R5 being Int_position;
thus L405: ( ( Exec (D95 , D96) ) . R5 ) = ( D96 . R5 ) by L401 , SCMPDS_2:54
.= ( C69 . R5 ) by SCMPDS_3:6
.= ( ( Exec (D95 , C69) ) . R5 ) by L401 , SCMPDS_2:54
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R5 ) by SCMPDS_3:6;
end;
L406: ( IC ( Exec (D95 , D96) ) ) = ( ICplusConst (D96 , R11) ) by L401 , SCMPDS_2:54
.= D100 by L390 , L402 , L403 , SCMPDS_4:27
.= ( IC ( IncIC (( Exec (D95 , C69) ) , R3) ) ) by FUNCT_4:113;
thus L407: thesis by L406 , L404 , SCMPDS_2:44;
end;
suppose L408: ( InsCode D95 ) = 2;

consider R4 being Int_position, R11 being Integer such that L409: D95 = ( R4 := R11 ) by L408 , SCMPDS_2:28;
L410:
now
let R5 being Int_position;
per cases ;
suppose L411: R4 = R5;

thus L412: ( ( Exec (D95 , D96) ) . R5 ) = R11 by L411 , L409 , SCMPDS_2:45
.= ( ( Exec (D95 , C69) ) . R5 ) by L409 , L411 , SCMPDS_2:45
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R5 ) by SCMPDS_3:6;
end;
suppose L413: R4 <> R5;

thus L414: ( ( Exec (D95 , D96) ) . R5 ) = ( D96 . R5 ) by L413 , L409 , SCMPDS_2:45
.= ( C69 . R5 ) by SCMPDS_3:6
.= ( ( Exec (D95 , C69) ) . R5 ) by L409 , L413 , SCMPDS_2:45
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R5 ) by SCMPDS_3:6;
end;
end;
L416: ( IC ( Exec (D95 , C69) ) ) = D98 by L409 , SCMPDS_2:45;
L417: ( IC ( Exec (D95 , D96) ) ) = ( IC ( IncIC (( Exec (D95 , C69) ) , R3) ) ) by L416 , L385 , L409 , SCMPDS_2:45;
thus L418: thesis by L417 , L410 , SCMPDS_2:44;
end;
suppose L419: ( InsCode D95 ) = 4;

consider R4 being Int_position, R11 being Integer, R12 being Integer such that L420: D95 = ( (R4 , R11) <>0_goto R12 ) and L421: ( D99 + R12 ) >= ( 0 ) by L419 , L394 , SCMPDS_4:def 8;
L422:
now
per cases ;
suppose L423: ( C69 . ( DataLoc (( C69 . R4 ) , R11) ) ) <> ( 0 );

L424: ( IC ( Exec (D95 , C69) ) ) = ( ICplusConst (C69 , R12) ) by L423 , L420 , SCMPDS_2:55;
L425: ( D96 . ( DataLoc (( C69 . R4 ) , R11) ) ) <> ( 0 ) by L423 , SCMPDS_3:6;
L426: ( D96 . ( DataLoc (( D96 . R4 ) , R11) ) ) <> ( 0 ) by L425 , SCMPDS_3:6;
thus L427: ( IC ( Exec (D95 , D96) ) ) = ( ICplusConst (D96 , R12) ) by L426 , L420 , SCMPDS_2:55
.= D100 by L390 , L421 , L424 , SCMPDS_4:27
.= ( IC ( IncIC (( Exec (D95 , C69) ) , R3) ) ) by FUNCT_4:113;
end;
suppose L428: ( C69 . ( DataLoc (( C69 . R4 ) , R11) ) ) = ( 0 );

L429: ( D96 . ( DataLoc (( C69 . R4 ) , R11) ) ) = ( 0 ) by L428 , SCMPDS_3:6;
L430: ( D96 . ( DataLoc (( D96 . R4 ) , R11) ) ) = ( 0 ) by L429 , SCMPDS_3:6;
L431: ( IC ( Exec (D95 , C69) ) ) = D98 by L420 , L428 , SCMPDS_2:55;
thus L432: ( IC ( Exec (D95 , D96) ) ) = ( IC ( IncIC (( Exec (D95 , C69) ) , R3) ) ) by L431 , L385 , L420 , L430 , SCMPDS_2:55;
end;
end;
L434:
now
let R5 being Int_position;
thus L435: ( ( Exec (D95 , D96) ) . R5 ) = ( D96 . R5 ) by L420 , SCMPDS_2:55
.= ( C69 . R5 ) by SCMPDS_3:6
.= ( ( Exec (D95 , C69) ) . R5 ) by L420 , SCMPDS_2:55
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R5 ) by SCMPDS_3:6;
end;
thus L436: thesis by L434 , L422 , SCMPDS_2:44;
end;
suppose L437: ( InsCode D95 ) = 5;

consider R4 being Int_position, R11 being Integer, R12 being Integer such that L438: D95 = ( (R4 , R11) <=0_goto R12 ) and L439: ( D99 + R12 ) >= ( 0 ) by L437 , L394 , SCMPDS_4:def 8;
L440:
now
per cases ;
suppose L441: ( C69 . ( DataLoc (( C69 . R4 ) , R11) ) ) <= ( 0 );

L442: ( IC ( Exec (D95 , C69) ) ) = ( ICplusConst (C69 , R12) ) by L441 , L438 , SCMPDS_2:56;
L443: ( D96 . ( DataLoc (( C69 . R4 ) , R11) ) ) <= ( 0 ) by L441 , SCMPDS_3:6;
L444: ( D96 . ( DataLoc (( D96 . R4 ) , R11) ) ) <= ( 0 ) by L443 , SCMPDS_3:6;
thus L445: ( IC ( Exec (D95 , D96) ) ) = ( ICplusConst (D96 , R12) ) by L444 , L438 , SCMPDS_2:56
.= D100 by L390 , L439 , L442 , SCMPDS_4:27
.= ( IC ( IncIC (( Exec (D95 , C69) ) , R3) ) ) by FUNCT_4:113;
end;
suppose L446: ( C69 . ( DataLoc (( C69 . R4 ) , R11) ) ) > ( 0 );

L447: ( D96 . ( DataLoc (( C69 . R4 ) , R11) ) ) > ( 0 ) by L446 , SCMPDS_3:6;
L448: ( D96 . ( DataLoc (( D96 . R4 ) , R11) ) ) > ( 0 ) by L447 , SCMPDS_3:6;
L449: ( IC ( Exec (D95 , C69) ) ) = D98 by L438 , L446 , SCMPDS_2:56;
thus L450: ( IC ( Exec (D95 , D96) ) ) = ( IC ( IncIC (( Exec (D95 , C69) ) , R3) ) ) by L449 , L385 , L438 , L448 , SCMPDS_2:56;
end;
end;
L452:
now
let R5 being Int_position;
thus L453: ( ( Exec (D95 , D96) ) . R5 ) = ( D96 . R5 ) by L438 , SCMPDS_2:56
.= ( C69 . R5 ) by SCMPDS_3:6
.= ( ( Exec (D95 , C69) ) . R5 ) by L438 , SCMPDS_2:56
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R5 ) by SCMPDS_3:6;
end;
thus L454: thesis by L452 , L440 , SCMPDS_2:44;
end;
suppose L455: ( InsCode D95 ) = 6;

consider R4 being Int_position, R11 being Integer, R12 being Integer such that L456: D95 = ( (R4 , R11) >=0_goto R12 ) and L457: ( D99 + R12 ) >= ( 0 ) by L455 , L394 , SCMPDS_4:def 8;
L458:
now
per cases ;
suppose L459: ( C69 . ( DataLoc (( C69 . R4 ) , R11) ) ) >= ( 0 );

L460: ( IC ( Exec (D95 , C69) ) ) = ( ICplusConst (C69 , R12) ) by L459 , L456 , SCMPDS_2:57;
L461: ( D96 . ( DataLoc (( C69 . R4 ) , R11) ) ) >= ( 0 ) by L459 , SCMPDS_3:6;
L462: ( D96 . ( DataLoc (( D96 . R4 ) , R11) ) ) >= ( 0 ) by L461 , SCMPDS_3:6;
thus L463: ( IC ( Exec (D95 , D96) ) ) = ( ICplusConst (D96 , R12) ) by L462 , L456 , SCMPDS_2:57
.= D100 by L390 , L457 , L460 , SCMPDS_4:27
.= ( IC ( IncIC (( Exec (D95 , C69) ) , R3) ) ) by FUNCT_4:113;
end;
suppose L464: ( C69 . ( DataLoc (( C69 . R4 ) , R11) ) ) < ( 0 );

L465: ( D96 . ( DataLoc (( C69 . R4 ) , R11) ) ) < ( 0 ) by L464 , SCMPDS_3:6;
L466: ( D96 . ( DataLoc (( D96 . R4 ) , R11) ) ) < ( 0 ) by L465 , SCMPDS_3:6;
L467: ( IC ( Exec (D95 , C69) ) ) = D98 by L456 , L464 , SCMPDS_2:57;
thus L468: ( IC ( Exec (D95 , D96) ) ) = ( IC ( IncIC (( Exec (D95 , C69) ) , R3) ) ) by L467 , L385 , L456 , L466 , SCMPDS_2:57;
end;
end;
L470:
now
let R5 being Int_position;
thus L471: ( ( Exec (D95 , D96) ) . R5 ) = ( D96 . R5 ) by L456 , SCMPDS_2:57
.= ( C69 . R5 ) by SCMPDS_3:6
.= ( ( Exec (D95 , C69) ) . R5 ) by L456 , SCMPDS_2:57
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R5 ) by SCMPDS_3:6;
end;
thus L472: thesis by L470 , L458 , SCMPDS_2:44;
end;
suppose L473: ( InsCode D95 ) = 7;

consider R4 being Int_position, R11 being Integer, R12 being Integer such that L474: D95 = ( (R4 , R11) := R12 ) by L473 , SCMPDS_2:33;
L475:
now
let R5 being Int_position;
per cases ;
suppose L476: ( DataLoc (( D96 . R4 ) , R11) ) = R5;

L477: ( DataLoc (( C69 . R4 ) , R11) ) = R5 by L476 , SCMPDS_3:6;
thus L478: ( ( Exec (D95 , D96) ) . R5 ) = R12 by L474 , L476 , SCMPDS_2:46
.= ( ( Exec (D95 , C69) ) . R5 ) by L474 , L477 , SCMPDS_2:46
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R5 ) by SCMPDS_3:6;
end;
suppose L479: ( DataLoc (( D96 . R4 ) , R11) ) <> R5;

L480: ( DataLoc (( C69 . R4 ) , R11) ) <> R5 by L479 , SCMPDS_3:6;
thus L481: ( ( Exec (D95 , D96) ) . R5 ) = ( D96 . R5 ) by L474 , L479 , SCMPDS_2:46
.= ( C69 . R5 ) by SCMPDS_3:6
.= ( ( Exec (D95 , C69) ) . R5 ) by L474 , L480 , SCMPDS_2:46
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R5 ) by SCMPDS_3:6;
end;
end;
L483: ( IC ( Exec (D95 , C69) ) ) = D98 by L474 , SCMPDS_2:46;
L484: ( IC ( Exec (D95 , D96) ) ) = ( IC ( IncIC (( Exec (D95 , C69) ) , R3) ) ) by L483 , L385 , L474 , SCMPDS_2:46;
thus L485: thesis by L484 , L475 , SCMPDS_2:44;
end;
suppose L486: ( InsCode D95 ) = 8;

consider R4 being Int_position, R11 being Integer, R12 being Integer such that L487: D95 = ( AddTo (R4 , R11 , R12) ) by L486 , SCMPDS_2:34;
L488:
now
let R5 being Int_position;
per cases ;
suppose L489: ( DataLoc (( D96 . R4 ) , R11) ) = R5;

L490: ( DataLoc (( C69 . R4 ) , R11) ) = R5 by L489 , SCMPDS_3:6;
thus L491: ( ( Exec (D95 , D96) ) . R5 ) = ( ( D96 . R5 ) + R12 ) by L487 , L489 , SCMPDS_2:48
.= ( ( C69 . R5 ) + R12 ) by SCMPDS_3:6
.= ( ( Exec (D95 , C69) ) . R5 ) by L487 , L490 , SCMPDS_2:48
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R5 ) by SCMPDS_3:6;
end;
suppose L492: ( DataLoc (( D96 . R4 ) , R11) ) <> R5;

L493: ( DataLoc (( C69 . R4 ) , R11) ) <> R5 by L492 , SCMPDS_3:6;
thus L494: ( ( Exec (D95 , D96) ) . R5 ) = ( D96 . R5 ) by L487 , L492 , SCMPDS_2:48
.= ( C69 . R5 ) by SCMPDS_3:6
.= ( ( Exec (D95 , C69) ) . R5 ) by L487 , L493 , SCMPDS_2:48
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R5 ) by SCMPDS_3:6;
end;
end;
L496: ( IC ( Exec (D95 , C69) ) ) = D98 by L487 , SCMPDS_2:48;
L497: ( IC ( Exec (D95 , D96) ) ) = ( IC ( IncIC (( Exec (D95 , C69) ) , R3) ) ) by L496 , L385 , L487 , SCMPDS_2:48;
thus L498: thesis by L497 , L488 , SCMPDS_2:44;
end;
suppose L499: ( InsCode D95 ) = 9;

consider R4 being Int_position, R5 being Int_position, R11 being Integer, R12 being Integer such that L500: D95 = ( AddTo (R4 , R11 , R5 , R12) ) by L499 , SCMPDS_2:35;
L501:
now
let R6 being Int_position;
per cases ;
suppose L502: ( DataLoc (( D96 . R4 ) , R11) ) = R6;

L503: ( DataLoc (( C69 . R4 ) , R11) ) = R6 by L502 , SCMPDS_3:6;
L504: ( D96 . ( DataLoc (( D96 . R5 ) , R12) ) ) = ( C69 . ( DataLoc (( D96 . R5 ) , R12) ) ) by SCMPDS_3:6
.= ( C69 . ( DataLoc (( C69 . R5 ) , R12) ) ) by SCMPDS_3:6;
L505: ( D96 . ( DataLoc (( D96 . R4 ) , R11) ) ) = ( C69 . ( DataLoc (( D96 . R4 ) , R11) ) ) by SCMPDS_3:6
.= ( C69 . ( DataLoc (( C69 . R4 ) , R11) ) ) by SCMPDS_3:6;
thus L506: ( ( Exec (D95 , D96) ) . R6 ) = ( ( C69 . ( DataLoc (( C69 . R4 ) , R11) ) ) + ( C69 . ( DataLoc (( C69 . R5 ) , R12) ) ) ) by L505 , L500 , L502 , L504 , SCMPDS_2:49
.= ( ( Exec (D95 , C69) ) . R6 ) by L500 , L503 , SCMPDS_2:49
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R6 ) by SCMPDS_3:6;
end;
suppose L507: ( DataLoc (( D96 . R4 ) , R11) ) <> R6;

L508: ( DataLoc (( C69 . R4 ) , R11) ) <> R6 by L507 , SCMPDS_3:6;
thus L509: ( ( Exec (D95 , D96) ) . R6 ) = ( D96 . R6 ) by L500 , L507 , SCMPDS_2:49
.= ( C69 . R6 ) by SCMPDS_3:6
.= ( ( Exec (D95 , C69) ) . R6 ) by L500 , L508 , SCMPDS_2:49
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R6 ) by SCMPDS_3:6;
end;
end;
L511: ( IC ( Exec (D95 , C69) ) ) = D98 by L500 , SCMPDS_2:49;
L512: ( IC ( Exec (D95 , D96) ) ) = ( IC ( IncIC (( Exec (D95 , C69) ) , R3) ) ) by L511 , L385 , L500 , SCMPDS_2:49;
thus L513: thesis by L512 , L501 , SCMPDS_2:44;
end;
suppose L514: ( InsCode D95 ) = 10;

consider R4 being Int_position, R5 being Int_position, R11 being Integer, R12 being Integer such that L515: D95 = ( SubFrom (R4 , R11 , R5 , R12) ) by L514 , SCMPDS_2:36;
L516:
now
let R6 being Int_position;
per cases ;
suppose L517: ( DataLoc (( D96 . R4 ) , R11) ) = R6;

L518: ( DataLoc (( C69 . R4 ) , R11) ) = R6 by L517 , SCMPDS_3:6;
L519: ( D96 . ( DataLoc (( D96 . R5 ) , R12) ) ) = ( C69 . ( DataLoc (( D96 . R5 ) , R12) ) ) by SCMPDS_3:6
.= ( C69 . ( DataLoc (( C69 . R5 ) , R12) ) ) by SCMPDS_3:6;
L520: ( D96 . ( DataLoc (( D96 . R4 ) , R11) ) ) = ( C69 . ( DataLoc (( D96 . R4 ) , R11) ) ) by SCMPDS_3:6
.= ( C69 . ( DataLoc (( C69 . R4 ) , R11) ) ) by SCMPDS_3:6;
thus L521: ( ( Exec (D95 , D96) ) . R6 ) = ( ( C69 . ( DataLoc (( C69 . R4 ) , R11) ) ) - ( C69 . ( DataLoc (( C69 . R5 ) , R12) ) ) ) by L520 , L515 , L517 , L519 , SCMPDS_2:50
.= ( ( Exec (D95 , C69) ) . R6 ) by L515 , L518 , SCMPDS_2:50
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R6 ) by SCMPDS_3:6;
end;
suppose L522: ( DataLoc (( D96 . R4 ) , R11) ) <> R6;

L523: ( DataLoc (( C69 . R4 ) , R11) ) <> R6 by L522 , SCMPDS_3:6;
thus L524: ( ( Exec (D95 , D96) ) . R6 ) = ( D96 . R6 ) by L515 , L522 , SCMPDS_2:50
.= ( C69 . R6 ) by SCMPDS_3:6
.= ( ( Exec (D95 , C69) ) . R6 ) by L515 , L523 , SCMPDS_2:50
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R6 ) by SCMPDS_3:6;
end;
end;
L526: ( IC ( Exec (D95 , C69) ) ) = D98 by L515 , SCMPDS_2:50;
L527: ( IC ( Exec (D95 , D96) ) ) = ( IC ( IncIC (( Exec (D95 , C69) ) , R3) ) ) by L526 , L385 , L515 , SCMPDS_2:50;
thus L528: thesis by L527 , L516 , SCMPDS_2:44;
end;
suppose L529: ( InsCode D95 ) = 11;

consider R4 being Int_position, R5 being Int_position, R11 being Integer, R12 being Integer such that L530: D95 = ( MultBy (R4 , R11 , R5 , R12) ) by L529 , SCMPDS_2:37;
L531:
now
let R6 being Int_position;
per cases ;
suppose L532: ( DataLoc (( D96 . R4 ) , R11) ) = R6;

L533: ( DataLoc (( C69 . R4 ) , R11) ) = R6 by L532 , SCMPDS_3:6;
L534: ( D96 . ( DataLoc (( D96 . R5 ) , R12) ) ) = ( C69 . ( DataLoc (( D96 . R5 ) , R12) ) ) by SCMPDS_3:6
.= ( C69 . ( DataLoc (( C69 . R5 ) , R12) ) ) by SCMPDS_3:6;
L535: ( D96 . ( DataLoc (( D96 . R4 ) , R11) ) ) = ( C69 . ( DataLoc (( D96 . R4 ) , R11) ) ) by SCMPDS_3:6
.= ( C69 . ( DataLoc (( C69 . R4 ) , R11) ) ) by SCMPDS_3:6;
thus L536: ( ( Exec (D95 , D96) ) . R6 ) = ( ( C69 . ( DataLoc (( C69 . R4 ) , R11) ) ) * ( C69 . ( DataLoc (( C69 . R5 ) , R12) ) ) ) by L535 , L530 , L532 , L534 , SCMPDS_2:51
.= ( ( Exec (D95 , C69) ) . R6 ) by L530 , L533 , SCMPDS_2:51
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R6 ) by SCMPDS_3:6;
end;
suppose L537: ( DataLoc (( D96 . R4 ) , R11) ) <> R6;

L538: ( DataLoc (( C69 . R4 ) , R11) ) <> R6 by L537 , SCMPDS_3:6;
thus L539: ( ( Exec (D95 , D96) ) . R6 ) = ( D96 . R6 ) by L530 , L537 , SCMPDS_2:51
.= ( C69 . R6 ) by SCMPDS_3:6
.= ( ( Exec (D95 , C69) ) . R6 ) by L530 , L538 , SCMPDS_2:51
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R6 ) by SCMPDS_3:6;
end;
end;
L541: ( IC ( Exec (D95 , C69) ) ) = D98 by L530 , SCMPDS_2:51;
L542: ( IC ( Exec (D95 , D96) ) ) = ( IC ( IncIC (( Exec (D95 , C69) ) , R3) ) ) by L541 , L385 , L530 , SCMPDS_2:51;
thus L543: thesis by L542 , L531 , SCMPDS_2:44;
end;
suppose L544: ( InsCode D95 ) = 12;

consider R4 being Int_position, R5 being Int_position, R11 being Integer, R12 being Integer such that L545: D95 = ( Divide (R4 , R11 , R5 , R12) ) by L544 , SCMPDS_2:38;
L546:
now
let R6 being Int_position;
L547: ( D96 . ( DataLoc (( D96 . R4 ) , R11) ) ) = ( C69 . ( DataLoc (( D96 . R4 ) , R11) ) ) by SCMPDS_3:6
.= ( C69 . ( DataLoc (( C69 . R4 ) , R11) ) ) by SCMPDS_3:6;
L548: ( D96 . ( DataLoc (( D96 . R5 ) , R12) ) ) = ( C69 . ( DataLoc (( D96 . R5 ) , R12) ) ) by SCMPDS_3:6
.= ( C69 . ( DataLoc (( C69 . R5 ) , R12) ) ) by SCMPDS_3:6;
per cases ;
suppose L549: ( DataLoc (( D96 . R5 ) , R12) ) = R6;

L550: ( DataLoc (( C69 . R5 ) , R12) ) = R6 by L549 , SCMPDS_3:6;
thus L551: ( ( Exec (D95 , D96) ) . R6 ) = ( ( C69 . ( DataLoc (( C69 . R4 ) , R11) ) ) mod ( C69 . ( DataLoc (( C69 . R5 ) , R12) ) ) ) by L545 , L547 , L548 , L549 , SCMPDS_2:52
.= ( ( Exec (D95 , C69) ) . R6 ) by L545 , L550 , SCMPDS_2:52
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R6 ) by SCMPDS_3:6;
end;
suppose L552: ( DataLoc (( D96 . R5 ) , R12) ) <> R6;

L553: ( DataLoc (( C69 . R5 ) , R12) ) <> R6 by L552 , SCMPDS_3:6;
thus L554:now
per cases ;
suppose L555: ( DataLoc (( D96 . R4 ) , R11) ) <> R6;

L556: ( DataLoc (( C69 . R4 ) , R11) ) <> R6 by L555 , SCMPDS_3:6;
thus L557: ( ( Exec (D95 , D96) ) . R6 ) = ( D96 . R6 ) by L545 , L552 , L555 , SCMPDS_2:52
.= ( C69 . R6 ) by SCMPDS_3:6
.= ( ( Exec (D95 , C69) ) . R6 ) by L545 , L553 , L556 , SCMPDS_2:52
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R6 ) by SCMPDS_3:6;
end;
suppose L558: ( DataLoc (( D96 . R4 ) , R11) ) = R6;

L559: ( DataLoc (( C69 . R4 ) , R11) ) = R6 by L558 , SCMPDS_3:6;
thus L560: ( ( Exec (D95 , D96) ) . R6 ) = ( ( C69 . ( DataLoc (( C69 . R4 ) , R11) ) ) div ( C69 . ( DataLoc (( C69 . R5 ) , R12) ) ) ) by L545 , L547 , L548 , L552 , L558 , SCMPDS_2:52
.= ( ( Exec (D95 , C69) ) . R6 ) by L545 , L553 , L559 , SCMPDS_2:52
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R6 ) by SCMPDS_3:6;
end;
end;
end;
end;
L556: ( IC ( Exec (D95 , C69) ) ) = D98 by L545 , SCMPDS_2:52;
L557: ( IC ( Exec (D95 , D96) ) ) = ( IC ( IncIC (( Exec (D95 , C69) ) , R3) ) ) by L556 , L385 , L545 , SCMPDS_2:52;
thus L558: thesis by L557 , L546 , SCMPDS_2:44;
end;
suppose L559: ( InsCode D95 ) = 13;

consider R4 being Int_position, R5 being Int_position, R11 being Integer, R12 being Integer such that L560: D95 = ( (R4 , R11) := (R5 , R12) ) by L559 , SCMPDS_2:39;
L561:
now
let R6 being Int_position;
per cases ;
suppose L562: ( DataLoc (( D96 . R4 ) , R11) ) = R6;

L563: ( DataLoc (( C69 . R4 ) , R11) ) = R6 by L562 , SCMPDS_3:6;
thus L564: ( ( Exec (D95 , D96) ) . R6 ) = ( D96 . ( DataLoc (( D96 . R5 ) , R12) ) ) by L560 , L562 , SCMPDS_2:47
.= ( C69 . ( DataLoc (( D96 . R5 ) , R12) ) ) by SCMPDS_3:6
.= ( C69 . ( DataLoc (( C69 . R5 ) , R12) ) ) by SCMPDS_3:6
.= ( ( Exec (D95 , C69) ) . R6 ) by L560 , L563 , SCMPDS_2:47
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R6 ) by SCMPDS_3:6;
end;
suppose L565: ( DataLoc (( D96 . R4 ) , R11) ) <> R6;

L566: ( DataLoc (( C69 . R4 ) , R11) ) <> R6 by L565 , SCMPDS_3:6;
thus L567: ( ( Exec (D95 , D96) ) . R6 ) = ( D96 . R6 ) by L560 , L565 , SCMPDS_2:47
.= ( C69 . R6 ) by SCMPDS_3:6
.= ( ( Exec (D95 , C69) ) . R6 ) by L560 , L566 , SCMPDS_2:47
.= ( ( IncIC (( Exec (D95 , C69) ) , R3) ) . R6 ) by SCMPDS_3:6;
end;
end;
L569: ( IC ( Exec (D95 , C69) ) ) = D98 by L560 , SCMPDS_2:47;
L570: ( IC ( Exec (D95 , D96) ) ) = ( IC ( IncIC (( Exec (D95 , C69) ) , R3) ) ) by L569 , L385 , L560 , SCMPDS_2:47;
thus L571: thesis by L570 , L561 , SCMPDS_2:44;
end;
end;
begin
theorem
L573: (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B46 being ( 0 ) -started (State of ( SCMPDS )) holds (for B47 being  parahalting  halt-free (Program of ( SCMPDS )) holds (for B48 being  parahalting  shiftable (Program of ( SCMPDS )) holds (for B49 being (Element of ( NAT )) holds (( stop ( B47 ';' B48 ) ) c= R18 implies ( IncIC (( Comput (( ( R18 +* ( stop B47 ) ) +* ( stop B48 ) ) , ( Initialize ( Result (( R18 +* ( stop B47 ) ) , B46) ) ) , B49) ) , ( card B47 )) ) = ( Comput (( R18 +* ( stop ( B47 ';' B48 ) ) ) , B46 , ( ( LifeSpan (( R18 +* ( stop B47 ) ) , B46) ) + B49 )) )))))))
proof
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C72 being ( 0 ) -started (State of ( SCMPDS ));
let C73 being  parahalting  halt-free (Program of ( SCMPDS ));
let C74 being  parahalting  shiftable (Program of ( SCMPDS ));
let C75 being (Element of ( NAT ));
set D101 = C72;
set D102 = ( R18 +* ( stop C73 ) );
set D103 = ( Result (D102 , D101) );
set D104 = ( stop C74 );
set D105 = ( Initialize D103 );
set D106 = ( D102 +* D104 );
set D107 = ( stop ( C73 ';' C74 ) );
set D108 = C72;
set D109 = ( R18 +* D107 );
L574: D104 c= D106 by FUNCT_4:25;
L575: ( stop C73 ) c= D102 by FUNCT_4:25;
L576: D102 halts_on D101 by L575 , SCMPDS_4:def 7;
set D110 = ( Comput (D109 , D108 , ( ( LifeSpan (D102 , D101) ) + ( 0 ) )) );
set D111 = ( D105 +* ( Start-At (( ( IC D105 ) + ( card C73 ) ) , ( SCMPDS )) ) );
set D112 = ( LifeSpan (D102 , D101) );
L577: C73 c= D107 by L2;
assume L578: D107 c= R18;
L579: ( R18 +* D107 ) = R18 by L578 , FUNCT_4:98;
L580:
now
thus L581: ( IC D111 ) = ( ( IC D105 ) + ( card C73 ) ) by FUNCT_4:113
.= ( ( 0 ) + ( card C73 ) ) by FUNCT_4:113
.= ( IC D110 ) by L578 , L577 , L305 , L579 , XBOOLE_1:1;
thus L582:now
let C76 being Int_position;
L583: (not C76 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L584: (not C76 in ( dom ( Start-At (( ( IC D105 ) + ( card C73 ) ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
thus L585: ( D111 . C76 ) = ( D105 . C76 ) by L584 , FUNCT_4:11
.= ( D103 . C76 ) by L583 , FUNCT_4:11
.= ( ( Comput (D102 , D101 , D112) ) . C76 ) by L576 , EXTPRO_1:23
.= ( D110 . C76 ) by L353;
end;
end;
defpred S4[ (Element of ( NAT )) ] means ( IncIC (( Comput (D106 , D105 , $1) ) , ( card C73 )) ) = ( Comput (D109 , D108 , ( ( LifeSpan (D102 , D101) ) + $1 )) );
L583: D107 c= D109 by FUNCT_4:25;
L584: (for B50 being (Element of ( NAT )) holds (S4[ B50 ] implies S4[ ( B50 + 1 ) ]))
proof
let C77 being (Element of ( NAT ));
set D113 = ( C77 + 1 );
set D114 = ( Comput (D106 , D105 , C77) );
set D115 = D106;
set D116 = ( IncIC (D114 , ( card C73 )) );
set D117 = ( Comput (D109 , D108 , ( ( LifeSpan (D102 , D101) ) + C77 )) );
set D118 = D109;
set D119 = ( Comput (D106 , D105 , D113) );
set D120 = ( D119 +* ( Start-At (( ( IC D119 ) + ( card C73 ) ) , ( SCMPDS )) ) );
set D121 = ( Comput (D109 , D108 , ( ( LifeSpan (D102 , D101) ) + D113 )) );
assume L585: D116 = D117;
L586: ( CurInstr (D115 , D114) ) = ( CurInstr (D118 , D117) )
proof
L587: ( CurInstr (D118 , D117) ) = ( D118 . ( IC D116 ) ) by L585 , PBOOLE:143
.= ( D118 . ( ( IC D114 ) + ( card C73 ) ) ) by FUNCT_4:113;
reconsider D122 = ( IC D114 ) as (Element of ( NAT ));
L588: D107 = ( C73 ';' D104 ) by AFINSQ_1:27;
L589: ( IC D114 ) in ( dom D104 ) by L574 , SCMPDS_4:def 6;
L590: D122 < ( card D104 ) by L589 , AFINSQ_1:66;
L591: ( D122 + ( card C73 ) ) < ( ( card D104 ) + ( card C73 ) ) by L590 , XREAL_1:6;
L592: ( D122 + ( card C73 ) ) < ( card D107 ) by L591 , L588 , AFINSQ_1:17;
L593: ( ( IC D114 ) + ( card C73 ) ) in ( dom D107 ) by L592 , AFINSQ_1:66;
L594: ( D115 /. ( IC D114 ) ) = ( D115 . ( IC D114 ) ) by PBOOLE:143;
L595: D104 c= D115 by FUNCT_4:25;
thus L596: ( CurInstr (D115 , D114) ) = ( D104 . ( IC D114 ) ) by L595 , L589 , L594 , GRFUNC_1:2
.= ( D107 . ( ( IC D114 ) + ( card C73 ) ) ) by L589 , L588 , AFINSQ_1:def 3
.= ( CurInstr (D118 , D117) ) by L587 , L583 , L593 , GRFUNC_1:2;
end;
L597: ( Exec (( CurInstr (D118 , D117) ) , D117) ) = ( IncIC (( Following (D115 , D114) ) , ( card C73 )) ) by L585 , L384 , L586 , FUNCT_4:25;
L598: D121 = ( Comput (D109 , D108 , ( ( ( LifeSpan (D102 , D101) ) + C77 ) + 1 )) );
L599: D121 = ( Following (D109 , D117) ) by L598 , EXTPRO_1:3;
L600:
now
let C78 being Int_position;
thus L601: ( D120 . C78 ) = ( D119 . C78 ) by SCMPDS_3:6
.= ( ( Following (D106 , D114) ) . C78 ) by EXTPRO_1:3
.= ( D121 . C78 ) by L599 , L597 , SCMPDS_3:6;
end;
L602: ( IC D120 ) = ( ( IC D119 ) + ( card C73 ) ) by FUNCT_4:113
.= ( ( IC ( Following (D106 , D114) ) ) + ( card C73 ) ) by EXTPRO_1:3;
L603: ( IC D120 ) = ( IC D121 ) by L602 , L599 , L597 , FUNCT_4:113;
thus L604: thesis by L603 , L600 , SCMPDS_4:2;
end;
L605: S4[ ( 0 ) ] by L580 , SCMPDS_4:2;
L606: (for B51 being (Element of ( NAT )) holds S4[ B51 ]) from NAT_1:sch 1(L605 , L584);
thus L607: thesis by L606;
end;
L608: (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B52 being  parahalting  halt-free (Program of ( SCMPDS )) holds (for B53 being  parahalting  shiftable (Program of ( SCMPDS )) holds (for B54 being ( 0 ) -started (State of ( SCMPDS )) holds ((( stop ( B52 ';' B53 ) ) c= R18 & R19 = ( R18 +* ( stop B52 ) )) implies (( IC ( Comput (R18 , B54 , ( LifeSpan (R19 , B54) )) ) ) = ( card B52 ) & ( DataPart ( Comput (R18 , B54 , ( LifeSpan (R19 , B54) )) ) ) = ( DataPart ( Initialize ( Comput (R19 , B54 , ( LifeSpan (R19 , B54) )) ) ) ) & ( Shift (( stop B53 ) , ( card B52 )) ) c= R18 & ( LifeSpan (R18 , B54) ) = ( ( LifeSpan (R19 , B54) ) + ( LifeSpan (( R19 +* ( stop B53 ) ) , ( Initialize ( Result (R19 , B54) ) )) ) ))))))))
proof
let R18 being (Instruction-Sequence of ( SCMPDS ));
let R19 being (Instruction-Sequence of ( SCMPDS ));
set D123 = ( SCM-Data-Loc );
let C79 being  parahalting  halt-free (Program of ( SCMPDS ));
let C80 being  parahalting  shiftable (Program of ( SCMPDS ));
let C81 being ( 0 ) -started (State of ( SCMPDS ));
set D124 = ( stop C80 );
set D125 = ( stop ( C79 ';' C80 ) );
set D126 = ( LifeSpan (R19 , C81) );
set D127 = ( Initialize ( Comput (R19 , C81 , D126) ) );
set D128 = ( R19 +* D124 );
set D129 = ( LifeSpan (D128 , D127) );
assume that
L609: D125 c= R18
and
L610: R19 = ( R18 +* ( stop C79 ) );
set D130 = ( Comput (R18 , C81 , D126) );
set D131 = R18;
L611: C79 c= D125 by L2;
thus L612: ( IC D130 ) = ( card C79 ) by L611 , L609 , L610 , L305 , XBOOLE_1:1;
reconsider D132 = ( D126 + D129 ) as (Element of ( NAT ));
L613: D125 = ( C79 ';' ( C80 ';' ( Stop ( SCMPDS ) ) ) ) by AFINSQ_1:27
.= ( C79 +* ( Shift (D124 , ( card C79 )) ) );
L614: ( Shift (D124 , ( card C79 )) ) c= D125 by L613 , FUNCT_4:25;
L615: D124 c= D128 by FUNCT_4:25;
L616: D128 halts_on D127 by L615 , SCMPDS_4:def 7;
L617: ( DataPart ( Comput (R19 , C81 , D126) ) ) = ( DataPart D127 ) by MEMSTR_0:45;
L618: ( C79 ';' C80 ) c= ( stop ( C79 ';' C80 ) ) by AFINSQ_1:74;
L619: ( R18 +* ( C79 ';' C80 ) ) = R18 by L618 , L609 , FUNCT_4:98 , XBOOLE_1:1;
thus L620: ( DataPart D130 ) = ( DataPart D127 ) by L619 , L617 , L610 , L336;
L621: ( Comput (R18 , C81 , ( D126 + D129 )) ) = ( Comput (R18 , ( Comput (R18 , C81 , D126) ) , D129) ) by EXTPRO_1:4;
thus L622: ( Shift (D124 , ( card C79 )) ) c= D131 by L614 , L609 , XBOOLE_1:1;
L623: ( CurInstr (D128 , ( Comput (D128 , D127 , D129) )) ) = ( CurInstr (R18 , ( Comput (R18 , C81 , ( D126 + D129 )) )) ) by L622 , L621 , L615 , L612 , L620 , SCMPDS_4:29;
L624: ( CurInstr (R18 , ( Comput (R18 , C81 , D132) )) ) = ( halt ( SCMPDS ) ) by L623 , L616 , EXTPRO_1:def 15;
L625:
now
let C82 being (Element of ( NAT ));
assume L626: ( D126 + C82 ) < D132;
L627: C82 < D129 by L626 , XREAL_1:6;
assume L628: ( CurInstr (R18 , ( Comput (R18 , C81 , ( D126 + C82 )) )) ) = ( halt ( SCMPDS ) );
L629: ( Comput (R18 , C81 , ( D126 + C82 )) ) = ( Comput (R18 , ( Comput (R18 , C81 , D126) ) , C82) ) by EXTPRO_1:4;
L630: ( CurInstr (D128 , ( Comput (D128 , D127 , C82) )) ) = ( halt ( SCMPDS ) ) by L628 , L629 , L615 , L612 , L620 , L622 , SCMPDS_4:29;
thus L631: contradiction by L630 , L616 , L627 , EXTPRO_1:def 15;
end;
L632:
now
let C83 being (Element of ( NAT ));
assume L633: C83 < D132;
per cases ;
suppose L634: C83 < D126;

thus L635: ( CurInstr (R18 , ( Comput (R18 , C81 , C83) )) ) <> ( halt ( SCMPDS ) ) by L634 , L610 , L329 , L609 , L611 , XBOOLE_1:1;
end;
suppose L636: D126 <= C83;

consider C84 being Nat such that L637: ( D126 + C84 ) = C83 by L636 , NAT_1:10;
L638: C84 in ( NAT ) by ORDINAL1:def 12;
thus L639: ( CurInstr (R18 , ( Comput (R18 , C81 , C83) )) ) <> ( halt ( SCMPDS ) ) by L638 , L625 , L633 , L637;
end;
end;
L641: (for B55 being (Element of ( NAT )) holds (( CurInstr (R18 , ( Comput (R18 , C81 , B55) )) ) = ( halt ( SCMPDS ) ) implies D132 <= B55)) by L632;
L642: ( stop C79 ) c= R19 by L610 , FUNCT_4:25;
L643: R19 halts_on C81 by L642 , SCMPDS_4:def 7;
L644: ( Result (R19 , C81) ) = ( Comput (R19 , C81 , ( LifeSpan (R19 , C81) )) ) by L643 , EXTPRO_1:23;
L645: R18 halts_on C81 by L609 , SCMPDS_4:def 7;
thus L646: thesis by L645 , L644 , L624 , L641 , EXTPRO_1:def 15;
end;
theorem
L647: (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B56 being ( 0 ) -started (State of ( SCMPDS )) holds (for B57 being  parahalting  halt-free (Program of ( SCMPDS )) holds (for B58 being  parahalting  shiftable (Program of ( SCMPDS )) holds ( LifeSpan (( R18 +* ( stop ( B57 ';' B58 ) ) ) , B56) ) = ( ( LifeSpan (( R18 +* ( stop B57 ) ) , B56) ) + ( LifeSpan (( ( R18 +* ( stop B57 ) ) +* ( stop B58 ) ) , ( Initialize ( Result (( R18 +* ( stop B57 ) ) , B56) ) )) ) )))))
proof
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C85 being ( 0 ) -started (State of ( SCMPDS ));
let C86 being  parahalting  halt-free (Program of ( SCMPDS ));
let C87 being  parahalting  shiftable (Program of ( SCMPDS ));
set D133 = ( stop C86 );
set D134 = ( stop ( C86 ';' C87 ) );
set D135 = C85;
set D136 = C85;
set D137 = ( R18 +* D134 );
set D138 = ( R18 +* ( stop C86 ) );
L648: D134 c= D137 by FUNCT_4:25;
set D139 = ( Initialize ( Result (( D137 +* ( stop C86 ) ) , D135) ) );
set D140 = ( ( D137 +* ( stop C86 ) ) +* ( stop C87 ) );
set D141 = ( Initialize ( Result (D138 , D136) ) );
set D142 = ( D138 +* ( stop C87 ) );
L649: ( stop C86 ) c= D138 by FUNCT_4:25;
L650: ( stop C87 ) c= D142 by FUNCT_4:25;
L651: ( stop C87 ) c= D140 by FUNCT_4:25;
L652: ( stop C86 ) c= ( D137 +* ( stop C86 ) ) by FUNCT_4:25;
L653: D141 = D139 by L652 , L649 , L30;
L654: ( LifeSpan (D140 , D139) ) = ( LifeSpan (D142 , D141) ) by L653 , L651 , L650 , L30;
L655: ( LifeSpan (( D137 +* ( stop C86 ) ) , D135) ) = ( LifeSpan (D138 , D136) ) by L652 , L649 , L30;
thus L656: thesis by L655 , L648 , L654 , L608;
end;
theorem
L657: (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B59 being ( 0 ) -started (State of ( SCMPDS )) holds (for B60 being  parahalting  halt-free (Program of ( SCMPDS )) holds (for B61 being  parahalting  shiftable (Program of ( SCMPDS )) holds ( IExec (( B60 ';' B61 ) , R18 , B59) ) = ( IncIC (( IExec (B61 , R18 , ( Initialize ( IExec (B60 , R18 , B59) ) )) ) , ( card B60 )) )))))
proof
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C88 being ( 0 ) -started (State of ( SCMPDS ));
let C89 being  parahalting  halt-free (Program of ( SCMPDS ));
let C90 being  parahalting  shiftable (Program of ( SCMPDS ));
set D143 = ( NAT );
set D144 = ( SCM-Data-Loc );
set D145 = ( stop C89 );
set D146 = ( stop ( C89 ';' C90 ) );
set D147 = ( R18 +* ( stop C89 ) );
set D148 = ( LifeSpan (D147 , C88) );
set D149 = ( R18 +* ( stop ( C89 ';' C90 ) ) );
set D150 = ( Initialize ( Comput (D147 , C88 , D148) ) );
set D151 = ( D147 +* ( stop C90 ) );
set D152 = ( LifeSpan (D151 , D150) );
L658: ( stop C90 ) c= D151 by FUNCT_4:25;
L659: D151 halts_on D150 by L658 , SCMPDS_4:def 7;
L660: ( stop C90 ) c= ( R18 +* ( stop C90 ) ) by FUNCT_4:25;
L661: ( stop C89 ) c= D147 by FUNCT_4:25;
L662: D147 halts_on C88 by L661 , SCMPDS_4:def 7;
L663: ( Initialize ( Comput (D147 , C88 , D148) ) ) = ( Initialize ( IExec (C89 , R18 , C88) ) ) by L662 , EXTPRO_1:23;
L664: ( Result (( R18 +* ( stop C90 ) ) , ( Initialize ( IExec (C89 , R18 , C88) ) )) ) = ( Result (D151 , D150) ) by L658 , L660 , L30 , L663;
L665: ( stop C89 ) c= ( D149 +* ( stop C89 ) ) by FUNCT_4:25;
L666: ( ( D149 +* ( stop C89 ) ) +* D146 ) = ( D149 +* ( ( stop C89 ) +* D146 ) ) by FUNCT_4:14
.= ( D149 +* D146 ) by L16;
L667: ( LifeSpan (( D149 +* ( stop C89 ) ) , C88) ) = D148 by L661 , L665 , L30;
set D153 = C88;
set D154 = ( D149 +* ( stop C89 ) );
L668: ( Comput (D147 , C88 , D148) ) = ( Comput (( D147 +* ( stop ( C89 ';' C90 ) ) ) , C88 , D148) ) by L68 , FUNCT_4:25;
L669: ( ( R18 +* ( stop C89 ) ) +* D146 ) = ( R18 +* ( ( stop C89 ) +* D146 ) ) by FUNCT_4:14
.= ( R18 +* ( D146 +* D146 ) ) by L16
.= ( ( D149 +* ( stop C89 ) ) +* D146 ) by L666;
L670: ( DataPart ( Comput (( D149 +* ( stop C89 ) ) , C88 , D148) ) ) = ( DataPart ( Comput (D147 , C88 , D148) ) ) by L669 , L668 , L667 , L68 , FUNCT_4:25;
L671: D146 c= D149 by FUNCT_4:25;
L672: ( DataPart ( Comput (D149 , C88 , D148) ) ) = ( DataPart ( Initialize ( Comput (( D149 +* ( stop C89 ) ) , C88 , D148) ) ) ) by L671 , L667 , L608
.= ( DataPart ( Comput (( D149 +* ( stop C89 ) ) , C88 , D148) ) ) by MEMSTR_0:45;
L673: ( Shift (( stop C90 ) , ( card C89 )) ) c= D149 by L671 , L665 , L608;
L674: ( IC ( Comput (D149 , C88 , D148) ) ) = ( card C89 ) by L671 , L667 , L608;
L675: ( DataPart ( Initialize ( Comput (D147 , C88 , D148) ) ) ) = ( DataPart ( Comput (D149 , C88 , D148) ) ) by L670 , L672 , MEMSTR_0:45;
L676: ( IC ( Comput (D149 , ( Comput (D149 , C88 , D148) ) , D152) ) ) = ( ( IC ( Comput (D151 , D150 , D152) ) ) + ( card C89 ) ) by L675 , L673 , L658 , L674 , SCMPDS_4:29;
L677: ( DataPart ( Comput (D149 , ( Comput (D149 , C88 , D148) ) , D152) ) ) = ( DataPart ( Comput (D151 , D150 , D152) ) ) by L674 , L673 , L658 , L675 , SCMPDS_4:29;
L678: D147 halts_on C88 by L661 , SCMPDS_4:def 7;
L679: D150 = ( Initialize ( Result (D147 , C88) ) ) by L678 , EXTPRO_1:23;
set D155 = ( ( Initialize ( Result (D147 , C88) ) ) +* ( stop C90 ) );
set D156 = ( ( Initialize ( IExec (C89 , R18 , C88) ) ) +* ( stop C90 ) );
L680: ( IC ( Result (( D147 +* ( stop C90 ) ) , ( Initialize ( Result (D147 , C88) ) )) ) ) = ( IC ( Result (( R18 +* ( stop C90 ) ) , ( Initialize ( IExec (C89 , R18 , C88) ) )) ) ) by L30 , L658 , L660;
L681: D149 halts_on C88 by L671 , SCMPDS_4:def 7;
L682: ( IC ( IExec (( C89 ';' C90 ) , R18 , C88) ) ) = ( IC ( Comput (D149 , C88 , ( LifeSpan (D149 , C88) )) ) ) by L681 , EXTPRO_1:23
.= ( IC ( Comput (D149 , C88 , ( D148 + D152 )) ) ) by L679 , L647
.= ( ( IC ( Comput (D151 , D150 , D152) ) ) + ( card C89 ) ) by L676 , EXTPRO_1:4
.= ( ( IC ( Result (D151 , D150) ) ) + ( card C89 ) ) by L659 , EXTPRO_1:23
.= ( ( IC ( IExec (C90 , R18 , ( Initialize ( IExec (C89 , R18 , C88) ) )) ) ) + ( card C89 ) ) by L680 , L678 , EXTPRO_1:23;
L683: ( IExec (( C89 ';' C90 ) , R18 , C88) ) = ( Comput (D149 , C88 , ( LifeSpan (D149 , C88) )) ) by L681 , EXTPRO_1:23
.= ( Comput (D149 , C88 , ( D148 + D152 )) ) by L679 , L647;
L684: ( DataPart ( IExec (( C89 ';' C90 ) , R18 , C88) ) ) = ( DataPart ( Comput (D151 , D150 , D152) ) ) by L683 , L677 , EXTPRO_1:4
.= ( DataPart ( IExec (C90 , R18 , ( Initialize ( IExec (C89 , R18 , C88) ) )) ) ) by L664 , L659 , EXTPRO_1:23;
thus L685:now
reconsider D157 = ( ( IC ( IExec (C90 , R18 , ( Initialize ( IExec (C89 , R18 , C88) ) )) ) ) + ( card C89 ) ) as (Element of ( NAT ));
L686: ( dom ( Start-At (D157 , ( SCMPDS )) ) ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
L687:
now
let C91 being set;
assume L688: C91 in ( dom ( IExec (( C89 ';' C90 ) , R18 , C88) ) );
per cases  by L688 , SCMPDS_4:6;
suppose L689: C91 is Int_position;

L690: C91 <> ( IC ( SCMPDS ) ) by L689 , SCMPDS_2:43;
L691: (not C91 in ( dom ( Start-At (D157 , ( SCMPDS )) ) )) by L690 , L686 , TARSKI:def 1;
L692: ( ( IExec (( C89 ';' C90 ) , R18 , C88) ) . C91 ) = ( ( IExec (C90 , R18 , ( Initialize ( IExec (C89 , R18 , C88) ) )) ) . C91 ) by L684 , L689 , SCMPDS_4:8;
thus L693: ( ( IExec (( C89 ';' C90 ) , R18 , C88) ) . C91 ) = ( ( IncIC (( IExec (C90 , R18 , ( Initialize ( IExec (C89 , R18 , C88) ) )) ) , ( card C89 )) ) . C91 ) by L692 , L691 , FUNCT_4:11;
end;
suppose L694: C91 = ( IC ( SCMPDS ) );

L695: C91 in { ( IC ( SCMPDS ) ) } by L694 , TARSKI:def 1;
L696: C91 in ( dom ( Start-At (D157 , ( SCMPDS )) ) ) by L695 , FUNCOP_1:13;
thus L697: ( ( IExec (( C89 ';' C90 ) , R18 , C88) ) . C91 ) = ( ( Start-At (D157 , ( SCMPDS )) ) . ( IC ( SCMPDS ) ) ) by L682 , L694 , FUNCOP_1:72
.= ( ( IncIC (( IExec (C90 , R18 , ( Initialize ( IExec (C89 , R18 , C88) ) )) ) , ( card C89 )) ) . C91 ) by L694 , L696 , FUNCT_4:13;
end;
end;
L699: ( dom ( IExec (( C89 ';' C90 ) , R18 , C88) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( IncIC (( IExec (C90 , R18 , ( Initialize ( IExec (C89 , R18 , C88) ) )) ) , ( card C89 )) ) ) by PARTFUN1:def 2;
thus L700: thesis by L699 , L687 , FUNCT_1:2;
end;
end;
theorem
L686: (for R4 being Int_position holds (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B62 being ( 0 ) -started (State of ( SCMPDS )) holds (for B63 being  parahalting  halt-free (Program of ( SCMPDS )) holds (for B64 being  parahalting  shiftable (Program of ( SCMPDS )) holds ( ( IExec (( B63 ';' B64 ) , R18 , B62) ) . R4 ) = ( ( IExec (B64 , R18 , ( Initialize ( IExec (B63 , R18 , B62) ) )) ) . R4 ))))))
proof
let R4 being Int_position;
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C92 being ( 0 ) -started (State of ( SCMPDS ));
let C93 being  parahalting  halt-free (Program of ( SCMPDS ));
let C94 being  parahalting  shiftable (Program of ( SCMPDS ));
L687: (not R4 in ( dom ( Start-At (( ( IC ( IExec (C94 , R18 , ( Initialize ( IExec (C93 , R18 , C92) ) )) ) ) + ( card C93 ) ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L688: ( IExec (( C93 ';' C94 ) , R18 , C92) ) = ( IncIC (( IExec (C94 , R18 , ( Initialize ( IExec (C93 , R18 , C92) ) )) ) , ( card C93 )) ) by L657;
thus L689: thesis by L688 , L687 , FUNCT_4:11;
end;
begin
canceled 1;
theorem
L690: (for R9 being (State of ( SCMPDS )) holds (for R10 being (State of ( SCMPDS )) holds (( R9 | ( ( SCM-Data-Loc ) \/ { ( IC ( SCMPDS ) ) } ) ) = ( R10 | ( ( SCM-Data-Loc ) \/ { ( IC ( SCMPDS ) ) } ) ) implies R9 = R10)))
proof
let R9 being (State of ( SCMPDS ));
let R10 being (State of ( SCMPDS ));
set D158 = ( NAT );
set D159 = ( ( SCM-Data-Loc ) \/ { ( IC ( SCMPDS ) ) } );
L691: (R9 = ( R9 | ( ( Data-Locations ( SCMPDS ) ) \/ { ( IC ( SCMPDS ) ) } ) ) & R10 = ( R10 | ( ( Data-Locations ( SCMPDS ) ) \/ { ( IC ( SCMPDS ) ) } ) )) by MEMSTR_0:33;
thus L692: thesis by L691 , SCMPDS_2:84;
end;
theorem
L693: (for R7 being (Instruction of ( SCMPDS )) holds (for R9 being (State of ( SCMPDS )) holds (for R10 being (State of ( SCMPDS )) holds ((( DataPart R9 ) = ( DataPart R10 ) & ( InsCode R7 ) <> 3) implies ( DataPart ( Exec (R7 , R9) ) ) = ( DataPart ( Exec (R7 , R10) ) )))))
proof
let R7 being (Instruction of ( SCMPDS ));
let R9 being (State of ( SCMPDS ));
let R10 being (State of ( SCMPDS ));
assume that
L694: ( DataPart R9 ) = ( DataPart R10 )
and
L695: ( InsCode R7 ) <> 3;
per cases  by L695 , NAT_1:60 , SCMPDS_2:6;
suppose L696: ( InsCode R7 ) = ( 0 );

L697: (( Exec (R7 , R9) ) = R9 & ( Exec (R7 , R10) ) = R10) by L696 , SCMPDS_2:86;
thus L698: thesis by L697 , L694;
end;
suppose L699: ( InsCode R7 ) = 14;

L700: (ex R11 being Integer st R7 = ( goto R11 )) by L699 , SCMPDS_2:26;
L701:
now
let R4 being Int_position;
thus L702: ( ( Exec (R7 , R9) ) . R4 ) = ( R9 . R4 ) by L700 , SCMPDS_2:54
.= ( R10 . R4 ) by L694 , SCMPDS_4:8
.= ( ( Exec (R7 , R10) ) . R4 ) by L700 , SCMPDS_2:54;
end;
thus L703: thesis by L701 , SCMPDS_4:8;
end;
suppose L704: ( InsCode R7 ) = 1;

consider R4 being Int_position such that L705: R7 = ( return R4 ) by L704 , SCMPDS_2:27;
L706:
now
let R5 being Int_position;
per cases ;
suppose L707: R4 = R5;

thus L708: ( ( Exec (R7 , R9) ) . R5 ) = ( R9 . ( DataLoc (( R9 . R4 ) , ( RetSP )) ) ) by L707 , L705 , SCMPDS_2:58
.= ( R10 . ( DataLoc (( R10 . R4 ) , ( RetSP )) ) ) by L694 , SCMPDS_3:2
.= ( ( Exec (R7 , R10) ) . R5 ) by L705 , L707 , SCMPDS_2:58;
end;
suppose L709: R4 <> R5;

thus L710: ( ( Exec (R7 , R9) ) . R5 ) = ( R9 . R5 ) by L709 , L705 , SCMPDS_2:58
.= ( R10 . R5 ) by L694 , SCMPDS_4:8
.= ( ( Exec (R7 , R10) ) . R5 ) by L705 , L709 , SCMPDS_2:58;
end;
end;
thus L712: thesis by L706 , SCMPDS_4:8;
end;
suppose L713: ( InsCode R7 ) = 2;

consider R4 being Int_position, R11 being Integer such that L714: R7 = ( R4 := R11 ) by L713 , SCMPDS_2:28;
L715:
now
let R5 being Int_position;
per cases ;
suppose L716: R4 = R5;

thus L717: ( ( Exec (R7 , R9) ) . R5 ) = R11 by L716 , L714 , SCMPDS_2:45
.= ( ( Exec (R7 , R10) ) . R5 ) by L714 , L716 , SCMPDS_2:45;
end;
suppose L718: R4 <> R5;

thus L719: ( ( Exec (R7 , R9) ) . R5 ) = ( R9 . R5 ) by L718 , L714 , SCMPDS_2:45
.= ( R10 . R5 ) by L694 , SCMPDS_4:8
.= ( ( Exec (R7 , R10) ) . R5 ) by L714 , L718 , SCMPDS_2:45;
end;
end;
thus L721: thesis by L715 , SCMPDS_4:8;
end;
suppose L722: ( InsCode R7 ) = 4;

L723: (ex R4 being Int_position st (ex R11 being Integer st (ex R12 being Integer st R7 = ( (R4 , R11) <>0_goto R12 )))) by L722 , SCMPDS_2:30;
L724:
now
let R4 being Int_position;
thus L725: ( ( Exec (R7 , R9) ) . R4 ) = ( R9 . R4 ) by L723 , SCMPDS_2:55
.= ( R10 . R4 ) by L694 , SCMPDS_4:8
.= ( ( Exec (R7 , R10) ) . R4 ) by L723 , SCMPDS_2:55;
end;
thus L726: thesis by L724 , SCMPDS_4:8;
end;
suppose L727: ( InsCode R7 ) = 5;

L728: (ex R4 being Int_position st (ex R11 being Integer st (ex R12 being Integer st R7 = ( (R4 , R11) <=0_goto R12 )))) by L727 , SCMPDS_2:31;
L729:
now
let R4 being Int_position;
thus L730: ( ( Exec (R7 , R9) ) . R4 ) = ( R9 . R4 ) by L728 , SCMPDS_2:56
.= ( R10 . R4 ) by L694 , SCMPDS_4:8
.= ( ( Exec (R7 , R10) ) . R4 ) by L728 , SCMPDS_2:56;
end;
thus L731: thesis by L729 , SCMPDS_4:8;
end;
suppose L732: ( InsCode R7 ) = 6;

L733: (ex R4 being Int_position st (ex R11 being Integer st (ex R12 being Integer st R7 = ( (R4 , R11) >=0_goto R12 )))) by L732 , SCMPDS_2:32;
L734:
now
let R4 being Int_position;
thus L735: ( ( Exec (R7 , R9) ) . R4 ) = ( R9 . R4 ) by L733 , SCMPDS_2:57
.= ( R10 . R4 ) by L694 , SCMPDS_4:8
.= ( ( Exec (R7 , R10) ) . R4 ) by L733 , SCMPDS_2:57;
end;
thus L736: thesis by L734 , SCMPDS_4:8;
end;
suppose L737: ( InsCode R7 ) = 7;

consider R4 being Int_position, R11 being Integer, R12 being Integer such that L738: R7 = ( (R4 , R11) := R12 ) by L737 , SCMPDS_2:33;
L739:
now
let R5 being Int_position;
per cases ;
suppose L740: ( DataLoc (( R9 . R4 ) , R11) ) = R5;

L741: ( DataLoc (( R10 . R4 ) , R11) ) = R5 by L740 , L694 , SCMPDS_4:8;
thus L742: ( ( Exec (R7 , R9) ) . R5 ) = R12 by L738 , L740 , SCMPDS_2:46
.= ( ( Exec (R7 , R10) ) . R5 ) by L738 , L741 , SCMPDS_2:46;
end;
suppose L743: ( DataLoc (( R9 . R4 ) , R11) ) <> R5;

L744: ( DataLoc (( R10 . R4 ) , R11) ) <> R5 by L743 , L694 , SCMPDS_4:8;
thus L745: ( ( Exec (R7 , R9) ) . R5 ) = ( R9 . R5 ) by L738 , L743 , SCMPDS_2:46
.= ( R10 . R5 ) by L694 , SCMPDS_4:8
.= ( ( Exec (R7 , R10) ) . R5 ) by L738 , L744 , SCMPDS_2:46;
end;
end;
thus L747: thesis by L739 , SCMPDS_4:8;
end;
suppose L748: ( InsCode R7 ) = 8;

consider R4 being Int_position, R11 being Integer, R12 being Integer such that L749: R7 = ( AddTo (R4 , R11 , R12) ) by L748 , SCMPDS_2:34;
L750:
now
let R5 being Int_position;
per cases ;
suppose L751: ( DataLoc (( R9 . R4 ) , R11) ) = R5;

L752: ( DataLoc (( R10 . R4 ) , R11) ) = R5 by L751 , L694 , SCMPDS_4:8;
thus L753: ( ( Exec (R7 , R9) ) . R5 ) = ( ( R9 . ( DataLoc (( R9 . R4 ) , R11) ) ) + R12 ) by L749 , L751 , SCMPDS_2:48
.= ( ( R10 . ( DataLoc (( R10 . R4 ) , R11) ) ) + R12 ) by L694 , SCMPDS_3:2
.= ( ( Exec (R7 , R10) ) . R5 ) by L749 , L752 , SCMPDS_2:48;
end;
suppose L754: ( DataLoc (( R9 . R4 ) , R11) ) <> R5;

L755: ( DataLoc (( R10 . R4 ) , R11) ) <> R5 by L754 , L694 , SCMPDS_4:8;
thus L756: ( ( Exec (R7 , R9) ) . R5 ) = ( R9 . R5 ) by L749 , L754 , SCMPDS_2:48
.= ( R10 . R5 ) by L694 , SCMPDS_4:8
.= ( ( Exec (R7 , R10) ) . R5 ) by L749 , L755 , SCMPDS_2:48;
end;
end;
thus L758: thesis by L750 , SCMPDS_4:8;
end;
suppose L759: ( InsCode R7 ) = 9;

consider R4 being Int_position, R5 being Int_position, R11 being Integer, R12 being Integer such that L760: R7 = ( AddTo (R4 , R11 , R5 , R12) ) by L759 , SCMPDS_2:35;
L761:
now
let R6 being Int_position;
per cases ;
suppose L762: ( DataLoc (( R9 . R4 ) , R11) ) = R6;

L763: ( DataLoc (( R10 . R4 ) , R11) ) = R6 by L762 , L694 , SCMPDS_4:8;
thus L764: ( ( Exec (R7 , R9) ) . R6 ) = ( ( R9 . ( DataLoc (( R9 . R4 ) , R11) ) ) + ( R9 . ( DataLoc (( R9 . R5 ) , R12) ) ) ) by L760 , L762 , SCMPDS_2:49
.= ( ( R10 . ( DataLoc (( R10 . R4 ) , R11) ) ) + ( R9 . ( DataLoc (( R9 . R5 ) , R12) ) ) ) by L694 , SCMPDS_3:2
.= ( ( R10 . ( DataLoc (( R10 . R4 ) , R11) ) ) + ( R10 . ( DataLoc (( R10 . R5 ) , R12) ) ) ) by L694 , SCMPDS_3:2
.= ( ( Exec (R7 , R10) ) . R6 ) by L760 , L763 , SCMPDS_2:49;
end;
suppose L765: ( DataLoc (( R9 . R4 ) , R11) ) <> R6;

L766: ( DataLoc (( R10 . R4 ) , R11) ) <> R6 by L765 , L694 , SCMPDS_4:8;
thus L767: ( ( Exec (R7 , R9) ) . R6 ) = ( R9 . R6 ) by L760 , L765 , SCMPDS_2:49
.= ( R10 . R6 ) by L694 , SCMPDS_4:8
.= ( ( Exec (R7 , R10) ) . R6 ) by L760 , L766 , SCMPDS_2:49;
end;
end;
thus L769: thesis by L761 , SCMPDS_4:8;
end;
suppose L770: ( InsCode R7 ) = 10;

consider R4 being Int_position, R5 being Int_position, R11 being Integer, R12 being Integer such that L771: R7 = ( SubFrom (R4 , R11 , R5 , R12) ) by L770 , SCMPDS_2:36;
L772:
now
let R6 being Int_position;
per cases ;
suppose L773: ( DataLoc (( R9 . R4 ) , R11) ) = R6;

L774: ( DataLoc (( R10 . R4 ) , R11) ) = R6 by L773 , L694 , SCMPDS_4:8;
thus L775: ( ( Exec (R7 , R9) ) . R6 ) = ( ( R9 . ( DataLoc (( R9 . R4 ) , R11) ) ) - ( R9 . ( DataLoc (( R9 . R5 ) , R12) ) ) ) by L771 , L773 , SCMPDS_2:50
.= ( ( R10 . ( DataLoc (( R10 . R4 ) , R11) ) ) - ( R9 . ( DataLoc (( R9 . R5 ) , R12) ) ) ) by L694 , SCMPDS_3:2
.= ( ( R10 . ( DataLoc (( R10 . R4 ) , R11) ) ) - ( R10 . ( DataLoc (( R10 . R5 ) , R12) ) ) ) by L694 , SCMPDS_3:2
.= ( ( Exec (R7 , R10) ) . R6 ) by L771 , L774 , SCMPDS_2:50;
end;
suppose L776: ( DataLoc (( R9 . R4 ) , R11) ) <> R6;

L777: ( DataLoc (( R10 . R4 ) , R11) ) <> R6 by L776 , L694 , SCMPDS_4:8;
thus L778: ( ( Exec (R7 , R9) ) . R6 ) = ( R9 . R6 ) by L771 , L776 , SCMPDS_2:50
.= ( R10 . R6 ) by L694 , SCMPDS_4:8
.= ( ( Exec (R7 , R10) ) . R6 ) by L771 , L777 , SCMPDS_2:50;
end;
end;
thus L780: thesis by L772 , SCMPDS_4:8;
end;
suppose L781: ( InsCode R7 ) = 11;

consider R4 being Int_position, R5 being Int_position, R11 being Integer, R12 being Integer such that L782: R7 = ( MultBy (R4 , R11 , R5 , R12) ) by L781 , SCMPDS_2:37;
L783:
now
let R6 being Int_position;
per cases ;
suppose L784: ( DataLoc (( R9 . R4 ) , R11) ) = R6;

L785: ( DataLoc (( R10 . R4 ) , R11) ) = R6 by L784 , L694 , SCMPDS_4:8;
thus L786: ( ( Exec (R7 , R9) ) . R6 ) = ( ( R9 . ( DataLoc (( R9 . R4 ) , R11) ) ) * ( R9 . ( DataLoc (( R9 . R5 ) , R12) ) ) ) by L782 , L784 , SCMPDS_2:51
.= ( ( R10 . ( DataLoc (( R10 . R4 ) , R11) ) ) * ( R9 . ( DataLoc (( R9 . R5 ) , R12) ) ) ) by L694 , SCMPDS_3:2
.= ( ( R10 . ( DataLoc (( R10 . R4 ) , R11) ) ) * ( R10 . ( DataLoc (( R10 . R5 ) , R12) ) ) ) by L694 , SCMPDS_3:2
.= ( ( Exec (R7 , R10) ) . R6 ) by L782 , L785 , SCMPDS_2:51;
end;
suppose L787: ( DataLoc (( R9 . R4 ) , R11) ) <> R6;

L788: ( DataLoc (( R10 . R4 ) , R11) ) <> R6 by L787 , L694 , SCMPDS_4:8;
thus L789: ( ( Exec (R7 , R9) ) . R6 ) = ( R9 . R6 ) by L782 , L787 , SCMPDS_2:51
.= ( R10 . R6 ) by L694 , SCMPDS_4:8
.= ( ( Exec (R7 , R10) ) . R6 ) by L782 , L788 , SCMPDS_2:51;
end;
end;
thus L791: thesis by L783 , SCMPDS_4:8;
end;
suppose L792: ( InsCode R7 ) = 12;

consider R4 being Int_position, R5 being Int_position, R11 being Integer, R12 being Integer such that L793: R7 = ( Divide (R4 , R11 , R5 , R12) ) by L792 , SCMPDS_2:38;
L794:
now
let R6 being Int_position;
per cases ;
suppose L795: ( DataLoc (( R9 . R5 ) , R12) ) = R6;

L796: ( DataLoc (( R10 . R5 ) , R12) ) = R6 by L795 , L694 , SCMPDS_4:8;
thus L797: ( ( Exec (R7 , R9) ) . R6 ) = ( ( R9 . ( DataLoc (( R9 . R4 ) , R11) ) ) mod ( R9 . ( DataLoc (( R9 . R5 ) , R12) ) ) ) by L793 , L795 , SCMPDS_2:52
.= ( ( R10 . ( DataLoc (( R10 . R4 ) , R11) ) ) mod ( R9 . ( DataLoc (( R9 . R5 ) , R12) ) ) ) by L694 , SCMPDS_3:2
.= ( ( R10 . ( DataLoc (( R10 . R4 ) , R11) ) ) mod ( R10 . ( DataLoc (( R10 . R5 ) , R12) ) ) ) by L694 , SCMPDS_3:2
.= ( ( Exec (R7 , R10) ) . R6 ) by L793 , L796 , SCMPDS_2:52;
end;
suppose L798: ( DataLoc (( R9 . R5 ) , R12) ) <> R6;

L799: ( DataLoc (( R10 . R5 ) , R12) ) <> R6 by L798 , L694 , SCMPDS_4:8;
thus L800:now
per cases ;
suppose L801: ( DataLoc (( R9 . R4 ) , R11) ) <> R6;

L802: ( DataLoc (( R10 . R4 ) , R11) ) <> R6 by L801 , L694 , SCMPDS_4:8;
thus L803: ( ( Exec (R7 , R9) ) . R6 ) = ( R9 . R6 ) by L793 , L798 , L801 , SCMPDS_2:52
.= ( R10 . R6 ) by L694 , SCMPDS_4:8
.= ( ( Exec (R7 , R10) ) . R6 ) by L793 , L799 , L802 , SCMPDS_2:52;
end;
suppose L804: ( DataLoc (( R9 . R4 ) , R11) ) = R6;

L805: ( DataLoc (( R10 . R4 ) , R11) ) = R6 by L804 , L694 , SCMPDS_4:8;
thus L806: ( ( Exec (R7 , R9) ) . R6 ) = ( ( R9 . ( DataLoc (( R9 . R4 ) , R11) ) ) div ( R9 . ( DataLoc (( R9 . R5 ) , R12) ) ) ) by L793 , L798 , L804 , SCMPDS_2:52
.= ( ( R10 . ( DataLoc (( R10 . R4 ) , R11) ) ) div ( R9 . ( DataLoc (( R9 . R5 ) , R12) ) ) ) by L694 , SCMPDS_3:2
.= ( ( R10 . ( DataLoc (( R10 . R4 ) , R11) ) ) div ( R10 . ( DataLoc (( R10 . R5 ) , R12) ) ) ) by L694 , SCMPDS_3:2
.= ( ( Exec (R7 , R10) ) . R6 ) by L793 , L799 , L805 , SCMPDS_2:52;
end;
end;
end;
end;
thus L802: thesis by L794 , SCMPDS_4:8;
end;
suppose L803: ( InsCode R7 ) = 13;

consider R4 being Int_position, R5 being Int_position, R11 being Integer, R12 being Integer such that L804: R7 = ( (R4 , R11) := (R5 , R12) ) by L803 , SCMPDS_2:39;
L805:
now
let R6 being Int_position;
per cases ;
suppose L806: ( DataLoc (( R9 . R4 ) , R11) ) = R6;

L807: ( DataLoc (( R10 . R4 ) , R11) ) = R6 by L806 , L694 , SCMPDS_4:8;
thus L808: ( ( Exec (R7 , R9) ) . R6 ) = ( R9 . ( DataLoc (( R9 . R5 ) , R12) ) ) by L804 , L806 , SCMPDS_2:47
.= ( R10 . ( DataLoc (( R10 . R5 ) , R12) ) ) by L694 , SCMPDS_3:2
.= ( ( Exec (R7 , R10) ) . R6 ) by L804 , L807 , SCMPDS_2:47;
end;
suppose L809: ( DataLoc (( R9 . R4 ) , R11) ) <> R6;

L810: ( DataLoc (( R10 . R4 ) , R11) ) <> R6 by L809 , L694 , SCMPDS_4:8;
thus L811: ( ( Exec (R7 , R9) ) . R6 ) = ( R9 . R6 ) by L804 , L809 , SCMPDS_2:47
.= ( R10 . R6 ) by L694 , SCMPDS_4:8
.= ( ( Exec (R7 , R10) ) . R6 ) by L804 , L810 , SCMPDS_2:47;
end;
end;
thus L813: thesis by L805 , SCMPDS_4:8;
end;
end;
theorem
L815: (for R9 being (State of ( SCMPDS )) holds (for R10 being (State of ( SCMPDS )) holds (for B65 being  shiftable (Instruction of ( SCMPDS )) holds (( DataPart R9 ) = ( DataPart R10 ) implies ( DataPart ( Exec (B65 , R9) ) ) = ( DataPart ( Exec (B65 , R10) ) )))))
proof
let R9 being (State of ( SCMPDS ));
let R10 being (State of ( SCMPDS ));
let C95 being  shiftable (Instruction of ( SCMPDS ));
L816: ( InsCode C95 ) <> 3 by SCMPDS_4:def 10;
thus L817: thesis by L816 , L693;
end;
theorem
L818: (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B66 being ( 0 ) -started (State of ( SCMPDS )) holds (for B67 being  parahalting (Instruction of ( SCMPDS )) holds ( Exec (B67 , B66) ) = ( IExec (( Load B67 ) , R18 , B66) ))))
proof
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C96 being ( 0 ) -started (State of ( SCMPDS ));
let C97 being  parahalting (Instruction of ( SCMPDS ));
set D160 = ( Load C97 );
set D161 = ( Macro C97 );
set D162 = ( R18 +* D161 );
set D163 = ( IC ( Comput (D162 , C96 , 1) ) );
L819: ( Initialize C96 ) = C96 by MEMSTR_0:44;
L820: D161 c= D162 by FUNCT_4:25;
L821: D162 halts_on C96 by L820 , SCMPDS_4:def 7;
L822: 1 in ( dom D161 ) by COMPOS_1:57;
L823: ( 0 ) in ( dom D161 ) by COMPOS_1:57;
L824: ( D161 . 1 ) = ( halt ( SCMPDS ) ) by COMPOS_1:59;
L825: ( D161 . ( 0 ) ) = C97 by COMPOS_1:58;
L826: D161 c= D162 by FUNCT_4:25;
L827: D163 in ( dom D161 ) by L826 , SCMPDS_4:def 6;
L828: ( D162 /. ( IC C96 ) ) = ( D162 . ( IC C96 ) ) by PBOOLE:143;
L829: ( Comput (D162 , C96 , ( ( 0 ) + 1 )) ) = ( Following (D162 , ( Comput (D162 , C96 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D162 , C96) )
.= ( Exec (( D162 . ( 0 ) ) , C96) ) by L828 , L819 , MEMSTR_0:47
.= ( Exec (C97 , C96) ) by L823 , L825 , L826 , GRFUNC_1:2;
per cases  by L827 , COMPOS_1:60;
suppose L830: D163 = ( 0 );

set D164 = ( InsCode C97 );
L831: ( succ ( IC C96 ) ) = ( succ ( 0 ) ) by L819 , MEMSTR_0:47
.= 1;
L832: D164 in { ( 0 ) , 1 , 4 , 5 , 6 , 14 } by L831 , L829 , L830 , SCMPDS_4:1;
L833: ( CurInstr (D162 , ( Comput (D162 , C96 , 1) )) ) = ( D162 . ( 0 ) ) by L830 , PBOOLE:143
.= C97 by L823 , L825 , L826 , GRFUNC_1:2;
L834: D164 <> 1 by L204;
thus L835:now
per cases ;
suppose L836: C97 = ( halt ( SCMPDS ) );

thus L837: thesis by L836 , L821 , L829 , L833 , EXTPRO_1:def 9;
end;
suppose L838: C97 <> ( halt ( SCMPDS ) );

L839:
now
let R5 being Int_position;
per cases  by L832 , L834 , ENUMSET1:def 4;
suppose L840: ( InsCode C97 ) = ( 0 );

thus L841: ( C96 . R5 ) = ( ( Exec (C97 , C96) ) . R5 ) by L840 , SCMPDS_2:86;
end;
suppose L842: ( InsCode C97 ) = 14;

L843: (ex R11 being Integer st C97 = ( goto R11 )) by L842 , SCMPDS_2:26;
thus L844: ( C96 . R5 ) = ( ( Exec (C97 , C96) ) . R5 ) by L843 , SCMPDS_2:54;
end;
suppose L845: ( InsCode C97 ) = 4;

L846: (ex R4 being Int_position st (ex R11 being Integer st (ex R12 being Integer st C97 = ( (R4 , R11) <>0_goto R12 )))) by L845 , SCMPDS_2:30;
thus L847: ( C96 . R5 ) = ( ( Exec (C97 , C96) ) . R5 ) by L846 , SCMPDS_2:55;
end;
suppose L848: ( InsCode C97 ) = 5;

L849: (ex R4 being Int_position st (ex R11 being Integer st (ex R12 being Integer st C97 = ( (R4 , R11) <=0_goto R12 )))) by L848 , SCMPDS_2:31;
thus L850: ( C96 . R5 ) = ( ( Exec (C97 , C96) ) . R5 ) by L849 , SCMPDS_2:56;
end;
suppose L851: ( InsCode C97 ) = 6;

L852: (ex R4 being Int_position st (ex R11 being Integer st (ex R12 being Integer st C97 = ( (R4 , R11) >=0_goto R12 )))) by L851 , SCMPDS_2:32;
thus L853: ( C96 . R5 ) = ( ( Exec (C97 , C96) ) . R5 ) by L852 , SCMPDS_2:57;
end;
end;
L855: ( Following (D162 , C96) ) = ( Following (D162 , ( Comput (D162 , C96 , ( 0 )) )) )
.= ( Exec (C97 , C96) ) by L829 , EXTPRO_1:3;
L856: ( IC C96 ) = ( IC ( Exec (C97 , C96) ) ) by L829 , L830 , L819 , MEMSTR_0:47;
L857: C96 = ( Exec (C97 , C96) ) by L856 , L839 , SCMPDS_2:44;
L858:
now
let R3 being (Element of ( NAT ));
L859: ( Comput (D162 , C96 , R3) ) = C96 by L856 , L839 , L855 , EXTPRO_1:27 , SCMPDS_2:44
.= ( Following (D162 , ( Comput (D162 , C96 , ( 0 )) )) ) by L857 , L855
.= ( Comput (D162 , C96 , ( ( 0 ) + 1 )) ) by EXTPRO_1:3;
thus L860: ( CurInstr (D162 , ( Comput (D162 , C96 , R3) )) ) <> ( halt ( SCMPDS ) ) by L859 , L833 , L838;
end;
L861: (not D162 halts_on C96) by L858 , EXTPRO_1:29;
thus L862: thesis by L861 , L826 , SCMPDS_4:def 7;
end;
end;
end;
suppose L836: D163 = 1;

L837: ( CurInstr (D162 , ( Comput (D162 , C96 , 1) )) ) = ( D162 . 1 ) by L836 , PBOOLE:143
.= ( halt ( SCMPDS ) ) by L822 , L824 , L826 , GRFUNC_1:2;
thus L838: thesis by L837 , L821 , L829 , EXTPRO_1:def 9;
end;
end;
theorem
L840: (for R4 being Int_position holds (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B68 being ( 0 ) -started (State of ( SCMPDS )) holds (for B69 being  parahalting  halt-free (Program of ( SCMPDS )) holds (for B70 being  parahalting  shiftable (Instruction of ( SCMPDS )) holds ( ( IExec (( B69 ';' B70 ) , R18 , B68) ) . R4 ) = ( ( Exec (B70 , ( IExec (B69 , R18 , B68) )) ) . R4 ))))))
proof
let R4 being Int_position;
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C98 being ( 0 ) -started (State of ( SCMPDS ));
let C99 being  parahalting  halt-free (Program of ( SCMPDS ));
let C100 being  parahalting  shiftable (Instruction of ( SCMPDS ));
set D165 = ( Load C100 );
set D166 = ( Start-At (( ( IC ( IExec (D165 , R18 , ( Initialize ( IExec (C99 , R18 , C98) ) )) ) ) + ( card C99 ) ) , ( SCMPDS )) );
L841: (not R4 in ( dom D166 )) by SCMPDS_4:18;
L842: R4 in ( SCM-Data-Loc ) by AMI_2:def 16;
L843: (for R4 being Int_position holds ( ( Initialize ( IExec (C99 , R18 , C98) ) ) . R4 ) = ( ( IExec (C99 , R18 , C98) ) . R4 )) by L19;
L844: ( DataPart ( Initialize ( IExec (C99 , R18 , C98) ) ) ) = ( DataPart ( IExec (C99 , R18 , C98) ) ) by L843 , SCMPDS_4:8;
thus L845: ( ( IExec (( C99 ';' C100 ) , R18 , C98) ) . R4 ) = ( ( IncIC (( IExec (D165 , R18 , ( Initialize ( IExec (C99 , R18 , C98) ) )) ) , ( card C99 )) ) . R4 ) by L657
.= ( ( IExec (D165 , R18 , ( Initialize ( IExec (C99 , R18 , C98) ) )) ) . R4 ) by L841 , FUNCT_4:11
.= ( ( Exec (C100 , ( Initialize ( IExec (C99 , R18 , C98) ) )) ) . R4 ) by L818
.= ( ( DataPart ( Exec (C100 , ( Initialize ( IExec (C99 , R18 , C98) ) )) ) ) . R4 ) by L842 , FUNCT_1:49 , SCMPDS_2:84
.= ( ( DataPart ( Exec (C100 , ( IExec (C99 , R18 , C98) )) ) ) . R4 ) by L844 , L815
.= ( ( Exec (C100 , ( IExec (C99 , R18 , C98) )) ) . R4 ) by L842 , FUNCT_1:49 , SCMPDS_2:84;
end;
theorem
L846: (for R4 being Int_position holds (for R18 being (Instruction-Sequence of ( SCMPDS )) holds (for B71 being ( 0 ) -started (State of ( SCMPDS )) holds (for B72 being  No-StopCode  parahalting (Instruction of ( SCMPDS )) holds (for B73 being  shiftable  parahalting (Instruction of ( SCMPDS )) holds ( ( IExec (( B72 ';' B73 ) , R18 , B71) ) . R4 ) = ( ( Exec (B73 , ( Exec (B72 , B71) )) ) . R4 ))))))
proof
let R4 being Int_position;
let R18 being (Instruction-Sequence of ( SCMPDS ));
let C101 being ( 0 ) -started (State of ( SCMPDS ));
let C102 being  No-StopCode  parahalting (Instruction of ( SCMPDS ));
let C103 being  shiftable  parahalting (Instruction of ( SCMPDS ));
set D167 = ( Load C102 );
thus L847: ( ( IExec (( C102 ';' C103 ) , R18 , C101) ) . R4 ) = ( ( IExec (( D167 ';' C103 ) , R18 , C101) ) . R4 )
.= ( ( Exec (C103 , ( IExec (D167 , R18 , C101) )) ) . R4 ) by L840
.= ( ( Exec (C103 , ( Exec (C102 , C101) )) ) . R4 ) by L818;
end;
