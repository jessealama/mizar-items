:: Domains of Submodules, Join and Meet of Finite Sequences of Submodules
:: and Quotient Modules
::  by Micha{\l} Muzalewski
::
:: Received March 29, 1993
:: Copyright (c) 1993-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies SUBSET_1, XBOOLE_0, BINOP_1, FUNCT_1, MULTOP_1, FUNCSDOM,
      VECTSP_1, VECTSP_2, RLVECT_2, RLSUB_1, FINSEQ_1, RMOD_3, ARYTM_1,
      ARYTM_3, ZFMISC_1, RLVECT_3, SUPINF_2, GROUP_1, TARSKI, CARD_3, MOD_3,
      STRUCT_0, RLSUB_2, INCSP_1, PARTFUN1, PRELAMB, SETWISEO, LATTICES,
      QC_LANG1, FINSEQ_4, ALGSTR_0, RLVECT_1, RELAT_1, LMOD_7;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, DOMAIN_1, STRUCT_0, ALGSTR_0,
      FUNCT_2, BINOP_1, FINSEQ_1, SETWISEO, SETWOP_2, LATTICES, MULTOP_1,
      RLVECT_1, GROUP_1, VECTSP_1, FUNCSDOM, VECTSP_2, VECTSP_4, VECTSP_5,
      VECTSP_6, LMOD_5, MOD_3, LMOD_6;
 constructors BINOP_1, DOMAIN_1, SETWISEO, MULTOP_1, FINSOP_1, LATTICES,
      VECTSP_6, LMOD_5, MOD_3, LMOD_6, RELSET_1;
 registrations XBOOLE_0, SUBSET_1, STRUCT_0, LATTICES, VECTSP_1, VECTSP_4,
      VECTSP_5, LATTICE2, ALGSTR_0;
 requirements BOOLE, SUBSET;
 definitions RLVECT_1, STRUCT_0, XBOOLE_0, ALGSTR_0;
 theorems BINOP_1, FUNCT_2, RLVECT_1, LMOD_5, LMOD_6, MOD_3, MULTOP_1,
      SETWISEO, SUBSET_1, TARSKI, VECTSP_1, VECTSP_4, VECTSP_5, VECTSP_6,
      ZFMISC_1, XBOOLE_0, XBOOLE_1, STRUCT_0, ALGSTR_0;
 schemes BINOP_1, DOMAIN_1, FUNCT_2, XBOOLE_0, BINOP_2;

begin
scheme ElementEq { F1() -> set , P1[set] } : (for B1 , B2 being (Element of F1()) holds (((for B3 being set holds (B3 in B1 iff P1[ B3 ])) & (for B4 being set holds (B4 in B2 iff P1[ B4 ]))) implies B1 = B2))
proof
let C1 , C2 being (Element of F1());
assume that
L1: (for B5 being set holds (B5 in C1 iff P1[ B5 ]))
and
L2: (for B6 being set holds (B6 in C2 iff P1[ B6 ]));
L3:
now
let C3 being set;
L4: (C3 in C1 iff P1[ C3 ]) by L1;
thus L5: (C3 in C1 iff C3 in C2) by L4 , L2;
end;
thus L6: thesis by L3 , TARSKI:1;
end;
scheme UnOpEq { F2() -> non  empty set , F3((Element of F2())) -> set } : (for B7 , B8 being (UnOp of F2()) holds (((for B9 being (Element of F2()) holds ( B7 . B9 ) = F3(B9)) & (for B10 being (Element of F2()) holds ( B8 . B10 ) = F3(B10))) implies B7 = B8))
proof
let C4 , C5 being (UnOp of F2());
assume that
L7: (for B11 being (Element of F2()) holds ( C4 . B11 ) = F3(B11))
and
L8: (for B12 being (Element of F2()) holds ( C5 . B12 ) = F3(B12));
L9:
now
let C6 being (Element of F2());
thus L10: ( C4 . C6 ) = F3(C6) by L7
.= ( C5 . C6 ) by L8;
end;
thus L11: thesis by L9 , FUNCT_2:63;
end;
scheme TriOpEq { F4() -> non  empty set , F5((Element of F4()) , (Element of F4()) , (Element of F4())) -> set } : (for B13 , B14 being (TriOp of F4()) holds (((for B15 , B16 , B17 being (Element of F4()) holds ( B13 . (B15 , B16 , B17) ) = F5(B15 , B16 , B17)) & (for B18 , B19 , B20 being (Element of F4()) holds ( B14 . (B18 , B19 , B20) ) = F5(B18 , B19 , B20))) implies B13 = B14))
proof
let C7 , C8 being (TriOp of F4());
assume that
L12: (for B21 , B22 , B23 being (Element of F4()) holds ( C7 . (B21 , B22 , B23) ) = F5(B21 , B22 , B23))
and
L13: (for B24 , B25 , B26 being (Element of F4()) holds ( C8 . (B24 , B25 , B26) ) = F5(B24 , B25 , B26));
L14:
now
let C9 , C10 , C11 being (Element of F4());
thus L15: ( C7 . (C9 , C10 , C11) ) = F5(C9 , C10 , C11) by L12
.= ( C8 . (C9 , C10 , C11) ) by L13;
end;
thus L16: thesis by L14 , MULTOP_1:3;
end;
scheme QuaOpEq { F6() -> non  empty set , F7((Element of F6()) , (Element of F6()) , (Element of F6()) , (Element of F6())) -> set } : (for B27 , B28 being (QuaOp of F6()) holds (((for B29 , B30 , B31 , B32 being (Element of F6()) holds ( B27 . (B29 , B30 , B31 , B32) ) = F7(B29 , B30 , B31 , B32)) & (for B33 , B34 , B35 , B36 being (Element of F6()) holds ( B28 . (B33 , B34 , B35 , B36) ) = F7(B33 , B34 , B35 , B36))) implies B27 = B28))
proof
let C12 , C13 being (QuaOp of F6());
assume that
L17: (for B37 , B38 , B39 , B40 being (Element of F6()) holds ( C12 . (B37 , B38 , B39 , B40) ) = F7(B37 , B38 , B39 , B40))
and
L18: (for B41 , B42 , B43 , B44 being (Element of F6()) holds ( C13 . (B41 , B42 , B43 , B44) ) = F7(B41 , B42 , B43 , B44));
L19:
now
let C14 , C15 , C16 , C17 being (Element of F6());
thus L20: ( C12 . (C14 , C15 , C16 , C17) ) = F7(C14 , C15 , C16 , C17) by L17
.= ( C13 . (C14 , C15 , C16 , C17) ) by L18;
end;
thus L21: thesis by L19 , MULTOP_1:6;
end;
scheme Fraenkel1Ex { F8 , F9() -> non  empty set , F10(set) -> (Element of F9()) , P2[set] } : (ex B45 being (Subset of F9()) st B45 = { F10(B46) where B46 is (Element of F8()) : P2[ B46 ] })
proof
reconsider D1 = { F10(B47) where B47 is (Element of F8()) : P2[ B47 ] } as (Subset of F9()) from DOMAIN_1:sch 8;
take D1;
thus L22: thesis;
end;
scheme Fr0 { F11() -> non  empty set , F12() -> (Element of F11()) , P3[set] } : P3[ F12() ]
provided
L23: F12() in { B48 where B48 is (Element of F11()) : P3[ B48 ] }
proof
L24: (ex B49 being (Element of F11()) st (F12() = B49 & P3[ B49 ])) by L23;
thus L25: thesis by L24;
end;
scheme Fr1 { F13() -> set , F14() -> non  empty set , F15() -> (Element of F14()) , P4[set] } : (F15() in F13() iff P4[ F15() ])
provided
L26: F13() = { B50 where B50 is (Element of F14()) : P4[ B50 ] }
proof
thus L27: (F15() in F13() implies P4[ F15() ])
proof
assume L28: F15() in F13();
L29: F15() in { B51 where B51 is (Element of F14()) : P4[ B51 ] } by L28 , L26;
thus L30: P4[ F15() ] from Fr0(L29);
end;

assume L31: P4[ F15() ];
thus L32: thesis by L31 , L26;
end;
scheme Fr2 { F16() -> set , F17() -> non  empty set , F18() -> (Element of F17()) , P5[set] } : P5[ F18() ]
provided
L33: F18() in F16()
and
L34: F16() = { B52 where B52 is (Element of F17()) : P5[ B52 ] }
proof
L35: F18() in { B53 where B53 is (Element of F17()) : P5[ B53 ] } by L33 , L34;
thus L36: P5[ F18() ] from Fr0(L35);
end;
scheme Fr3 { F19() -> set , F20() -> set , F21() -> non  empty set , P6[set] } : (F19() in F20() iff (ex B54 being (Element of F21()) st (F19() = B54 & P6[ B54 ])))
provided
L37: F20() = { B55 where B55 is (Element of F21()) : P6[ B55 ] }
proof
thus L38: thesis by L37;
end;
scheme Fr4 { F22 , F23() -> non  empty set , F24() -> set , F25() -> (Element of F22()) , F26(set) -> set , P7[set , set] , P8[set , set] } : (F25() in F26(F24()) iff (for B56 being (Element of F23()) holds (B56 in F24() implies P7[ F25() , B56 ])))
provided
L39: F26(F24()) = { B57 where B57 is (Element of F22()) : P8[ B57 , F24() ] }
and
L40: (P8[ F25() , F24() ] iff (for B58 being (Element of F23()) holds (B58 in F24() implies P7[ F25() , B58 ])))
proof
thus L41: (F25() in F26(F24()) implies (for B59 being (Element of F23()) holds (B59 in F24() implies P7[ F25() , B59 ])))
proof
defpred S1[ set ] means P8[ $1 , F24() ];
assume L42: F25() in F26(F24());
L43: F25() in { B60 where B60 is (Element of F22()) : S1[ B60 ] } by L42 , L39;
L44: S1[ F25() ] from Fr0(L43);
thus L45: thesis by L44 , L40;
end;

assume L46: (for B61 being (Element of F23()) holds (B61 in F24() implies P7[ F25() , B61 ]));
thus L47: thesis by L46 , L39 , L40;
end;
begin
L48: (for B62 being AbGroup holds (for B63 , B64 , B65 being (Element of B62) holds (( - ( B63 - B64 ) ) = ( ( - B63 ) - ( - B64 ) ) & ( ( B63 - B64 ) + B65 ) = ( ( B63 + B65 ) - B64 ))))
proof
let C18 being AbGroup;
let C19 , C20 , C21 being (Element of C18);
thus L49: ( - ( C19 - C20 ) ) = ( ( - C19 ) + C20 ) by VECTSP_1:17
.= ( ( - C19 ) - ( - C20 ) ) by RLVECT_1:17;
thus L50: thesis by RLVECT_1:def 3;
end;
theorem
L51: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R9 being (Subset of R4) holds ((R2 is non  trivial & R9 is  linearly-independent) implies (not ( 0. R4 ) in R9)))))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
let R9 being (Subset of R4);
assume that
L52: R2 is non  trivial
and
L53: R9 is  linearly-independent;
L54: ( 0. R2 ) <> ( 1_ R2 ) by L52 , LMOD_6:def 1;
thus L55: thesis by L54 , L53 , LMOD_5:2;
end;
theorem
L56: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R5 being (Vector of R4) holds (for R9 being (Subset of R4) holds (for R12 being (Linear_Combination of R9) holds ((not R5 in R9) implies ( R12 . R5 ) = ( 0. R2 )))))))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
let R5 being (Vector of R4);
let R9 being (Subset of R4);
let R12 being (Linear_Combination of R9);
assume L57: (not R5 in R9);
L58: ( Carrier R12 ) c= R9 by VECTSP_6:def 4;
L59: (not R5 in ( Carrier R12 )) by L58 , L57;
thus L60: thesis by L59 , VECTSP_6:2;
end;
theorem
L61: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R9 being (Subset of R4) holds (R2 is  trivial implies ((for R12 being (Linear_Combination of R9) holds ( Carrier R12 ) = ( {} )) & ( Lin R9 ) is  trivial)))))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
let R9 being (Subset of R4);
assume L62: R2 is  trivial;
thus L63: (for R12 being (Linear_Combination of R9) holds ( Carrier R12 ) = ( {} ))
proof
let R12 being (Linear_Combination of R9);
assume L64: ( Carrier R12 ) <> ( {} );
set D2 = the (Element of ( Carrier R12 ));
L65: (ex R5 being (Vector of R4) st (D2 = R5 & ( R12 . R5 ) <> ( 0. R2 ))) by L64 , VECTSP_6:1;
thus L66: contradiction by L65 , L62 , LMOD_6:5;
end;

L67:
now
let C22 being (Vector of ( Lin R9 ));
L68: C22 in ( Lin R9 ) by RLVECT_1:1;
consider R12 being (Linear_Combination of R9) such that L69: C22 = ( Sum R12 ) by L68 , MOD_3:4;
L70: ( Carrier R12 ) = ( {} ) by L63;
L71: C22 = ( 0. R4 ) by L70 , L69 , VECTSP_6:19;
thus L72: C22 = ( 0. ( Lin R9 ) ) by L71 , VECTSP_4:11;
end;
thus L73: thesis by L67 , STRUCT_0:def 18;
end;
theorem
L74: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (R4 is non  trivial implies (for R9 being (Subset of R4) holds (R9 is  base implies R9 <> ( {} ))))))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
assume L75: R4 is non  trivial;
let R9 being (Subset of R4);
assume that
L76: R9 is  base
and
L77: R9 = ( {} );
L78: R9 = ( {} (the carrier of R4) ) by L77;
L79: ( the VectSpStr of R4 ) = ( Lin R9 ) by L76 , MOD_3:def 2
.= ( (0). R4 ) by L78 , MOD_3:6;
thus L80: contradiction by L79 , L75 , LMOD_6:7;
end;
theorem
L81: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R10 being (Subset of R4) holds (for R11 being (Subset of R4) holds ((( R10 \/ R11 ) is  linearly-independent & R10 misses R11) implies ( ( Lin R10 ) /\ ( Lin R11 ) ) = ( (0). R4 ))))))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
let R10 being (Subset of R4);
let R11 being (Subset of R4);
assume that
L82: ( R10 \/ R11 ) is  linearly-independent
and
L83: ( R10 /\ R11 ) = ( {} );
reconsider D3 = ( ( Lin R10 ) /\ ( Lin R11 ) ) as  strict (Subspace of R4);
set D4 = (the carrier of D3);
L84: D4 = ( (the carrier of ( Lin R10 )) /\ (the carrier of ( Lin R11 )) ) by VECTSP_5:def 2;
L85:
now
let R1 being set;
assume L86: R1 in D4;
L87: R1 in (the carrier of ( Lin R10 )) by L86 , L84 , XBOOLE_0:def 4;
L88: R1 in (the carrier of ( Lin R11 )) by L84 , L86 , XBOOLE_0:def 4;
L89: R1 in ( Lin R10 ) by L87 , STRUCT_0:def 5;
L90: R1 in ( Lin R11 ) by L88 , STRUCT_0:def 5;
consider C23 being (Linear_Combination of R10) such that L91: R1 = ( Sum C23 ) by L89 , MOD_3:4;
consider C24 being (Linear_Combination of R11) such that L92: R1 = ( Sum C24 ) by L90 , MOD_3:4;
L93: ( Carrier C23 ) c= R10 by VECTSP_6:def 4;
L94: ( Carrier C24 ) c= R11 by VECTSP_6:def 4;
L95: ( ( Carrier C23 ) \/ ( Carrier C24 ) ) c= ( R10 \/ R11 ) by L94 , L93 , XBOOLE_1:13;
L96: ( Carrier ( C23 - C24 ) ) c= ( ( Carrier C23 ) \/ ( Carrier C24 ) ) by VECTSP_6:41;
L97: ( Carrier ( C23 - C24 ) ) c= ( R10 \/ R11 ) by L96 , L95 , XBOOLE_1:1;
reconsider D5 = ( C23 - C24 ) as (Linear_Combination of ( R10 \/ R11 )) by L97 , VECTSP_6:def 4;
L98: ( Sum D5 ) = ( ( Sum C23 ) - ( Sum C24 ) ) by VECTSP_6:47
.= ( 0. R4 ) by L91 , L92 , VECTSP_1:19;
L99: ( Carrier D5 ) = ( {} ) by L98 , L82 , LMOD_5:def 1;
L100: ( Carrier C23 ) = ( {} )
proof
assume L101: ( Carrier C23 ) <> ( {} );
set D6 = the (Element of ( Carrier C23 ));
consider R6 being (Vector of R4) such that L102: D6 = R6 and L103: ( C23 . R6 ) <> ( 0. R2 ) by L101 , VECTSP_6:1;
L104: R6 in R10 by L93 , L101 , L102 , TARSKI:def 3;
L105: (not R6 in R11) by L104 , L83 , XBOOLE_0:def 4;
L106: ( 0. R2 ) = ( D5 . R6 ) by L99 , VECTSP_6:2
.= ( ( C23 . R6 ) - ( C24 . R6 ) ) by VECTSP_6:40;
L107: ( C23 . R6 ) = ( C24 . R6 ) by L106 , RLVECT_1:21
.= ( 0. R2 ) by L105 , L56;
thus L108: contradiction by L107 , L103;
end;
thus L109: R1 = ( 0. R4 ) by L100 , L91 , VECTSP_6:19;
end;
L110: ( 0. R4 ) in ( ( Lin R10 ) /\ ( Lin R11 ) ) by VECTSP_4:17;
L111: (for R1 being set holds (R1 in D4 iff R1 = ( 0. R4 ))) by L110 , L85 , STRUCT_0:def 5;
L112: D4 = { ( 0. R4 ) } by L111 , TARSKI:def 1;
thus L113: thesis by L112 , VECTSP_4:def 3;
end;
theorem
L114: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R9 being (Subset of R4) holds (for R10 being (Subset of R4) holds (for R11 being (Subset of R4) holds ((R9 is  base & R9 = ( R10 \/ R11 ) & R10 misses R11) implies R4 is_the_direct_sum_of ( Lin R10 ) , ( Lin R11 )))))))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
let R9 being (Subset of R4);
let R10 being (Subset of R4);
let R11 being (Subset of R4);
assume that
L115: R9 is  base
and
L116: R9 = ( R10 \/ R11 )
and
L117: R10 misses R11;
set D7 = ( the VectSpStr of R4 );
L118: R9 is  linearly-independent by L115 , MOD_3:def 2;
L119: ( Lin R9 ) = D7 by L115 , MOD_3:def 2;
L120: D7 = ( ( Lin R10 ) + ( Lin R11 ) ) by L119 , L116 , MOD_3:12;
L121: ( ( Lin R10 ) /\ ( Lin R11 ) ) = ( (0). R4 ) by L116 , L117 , L118 , L81;
thus L122: thesis by L121 , L120 , VECTSP_5:def 4;
end;
begin
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
mode SUBMODULE_DOMAIN of R4
 -> non  empty set
means :L123: (for R1 being set holds (R1 in it implies R1 is  strict  strict  strict  strict (Subspace of R4)));
existence
proof
set D8 = the  strict (Subspace of R4);
set D9 = { D8 };
take D9;
thus L124: thesis by TARSKI:def 1;
end;
end;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
redefine func Submodules R4 -> (SUBMODULE_DOMAIN of R4);

coherence
proof
L126:
now
let R1 being set;
assume L127: R1 in ( Submodules R4 );
L128: (ex B66 being  strict (Subspace of R4) st B66 = R1) by L127 , VECTSP_5:def 3;
thus L129: R1 is  strict  strict  strict  strict (Subspace of R4) by L128;
end;
thus L130: thesis by L126 , L123;
end;
end;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
let C25 being (SUBMODULE_DOMAIN of R4);
redefine mode Element of C25
 ->  strict (Subspace of R4);
coherence by L123;
end;
registration
let R2 being Ring;
let R4 being (LeftMod of R2);
let C26 being (SUBMODULE_DOMAIN of R4);
cluster  strict for (Element of C26);
existence
proof
set D10 = the (Element of C26);
take D10;
thus L133: thesis;
end;
end;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
assume L135: R4 is non  trivial;
mode LINE of R4
 ->  strict (Subspace of R4)
means (ex R5 being (Vector of R4) st (R5 <> ( 0. R4 ) & it = <: R5 :>));
existence
proof
consider R5 being (Vector of R4) such that L136: R5 <> ( 0. R4 ) by L135 , STRUCT_0:def 18;
take <: R5 :>;
thus L137: thesis by L136;
end;
end;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
mode LINE_DOMAIN of R4
 -> non  empty set
means :L139: (for R1 being set holds (R1 in it implies R1 is (LINE of R4)));
existence
proof
set D11 = the (LINE of R4);
set D12 = { D11 };
take D12;
thus L140: thesis by TARSKI:def 1;
end;
end;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
func lines R4 -> (LINE_DOMAIN of R4) means 
(for R1 being set holds (R1 in it iff R1 is (LINE of R4)));
existence
proof
set D13 = { B67 where B67 is (Element of ( Submodules R4 )) : B67 is (LINE of R4) };
set D14 = the (LINE of R4);
reconsider D15 = D14 as (Element of ( Submodules R4 )) by VECTSP_5:def 3;
L142: D15 in D13;
reconsider D16 = D13 as non  empty set by L142;
L143:
now
let R1 being set;
assume L144: R1 in D16;
L145: (ex B68 being (Element of ( Submodules R4 )) st (R1 = B68 & B68 is (LINE of R4))) by L144;
thus L146: R1 is (LINE of R4) by L145;
end;
reconsider D17 = D16 as (LINE_DOMAIN of R4) by L143 , L139;
take D17;
L147:
now
let R1 being set;
thus L148: (R1 in D17 implies R1 is (LINE of R4)) by L143;
thus L149: (R1 is (LINE of R4) implies R1 in D17)
proof
assume L150: R1 is (LINE of R4);
reconsider D18 = R1 as (Element of ( Submodules R4 )) by L150 , VECTSP_5:def 3;
L151: D18 in D16 by L150;
thus L152: thesis by L151;
end;

end;
thus L150: thesis by L147;
end;
uniqueness
proof
let C27 , C28 being (LINE_DOMAIN of R4);
assume that
L151: (for R1 being set holds (R1 in C27 iff R1 is (LINE of R4)))
and
L152: (for R1 being set holds (R1 in C28 iff R1 is (LINE of R4)));
L153:
now
let R1 being set;
L154: (R1 in C27 iff R1 is (LINE of R4)) by L151;
thus L155: (R1 in C27 iff R1 in C28) by L154 , L152;
end;
thus L156: thesis by L153 , TARSKI:1;
end;
end;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
let C29 being (LINE_DOMAIN of R4);
redefine mode Element of C29
 -> (LINE of R4);
coherence by L139;
end;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
assume that
L159: R4 is non  trivial
and
L160: R4 is  free;
mode HIPERPLANE of R4
 ->  strict (Subspace of R4)
means (ex R5 being (Vector of R4) st (R5 <> ( 0. R4 ) & R4 is_the_direct_sum_of <: R5 :> , it));
existence
proof
consider C30 being (Subset of R4) such that L161: C30 is  base by L160 , MOD_3:def 3;
reconsider D19 = C30 as (Subset of R4);
L162: D19 is  linearly-independent by L161 , MOD_3:def 2;
L163: D19 <> ( {} ) by L159 , L161 , L74;
set D20 = the (Element of D19);
reconsider D21 = D20 as (Vector of R4) by L163 , TARSKI:def 3;
reconsider D22 = { D21 } as (Subset of R4);
set D23 = ( D19 \ D22 );
set D24 = ( Lin D23 );
L164: D22 c= D19 by L163 , ZFMISC_1:31;
L165: D19 = ( D22 \/ D23 ) by L164 , XBOOLE_1:45;
L166: D22 misses D23 by XBOOLE_1:79;
L167: R4 is_the_direct_sum_of ( Lin D22 ) , D24 by L166 , L161 , L165 , L114;
L168: (ex R5 being (Vector of R4) st (R5 <> ( 0. R4 ) & R4 is_the_direct_sum_of <: R5 :> , D24))
proof
take D21;
thus L169: thesis by L159 , L162 , L163 , L167 , L51 , LMOD_6:6 , LMOD_6:def 4;
end;
take D24;
thus L170: thesis by L168;
end;
end;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
mode HIPERPLANE_DOMAIN of R4
 -> non  empty set
means :L172: (for R1 being set holds (R1 in it implies R1 is (HIPERPLANE of R4)));
existence
proof
set D25 = the (HIPERPLANE of R4);
set D26 = { D25 };
take D26;
thus L173: thesis by TARSKI:def 1;
end;
end;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
func hiperplanes R4 -> (HIPERPLANE_DOMAIN of R4) means 
(for R1 being set holds (R1 in it iff R1 is (HIPERPLANE of R4)));
existence
proof
set D27 = { B69 where B69 is (Element of ( Submodules R4 )) : B69 is (HIPERPLANE of R4) };
set D28 = the (HIPERPLANE of R4);
reconsider D29 = D28 as (Element of ( Submodules R4 )) by VECTSP_5:def 3;
L175: D29 in D27;
reconsider D30 = D27 as non  empty set by L175;
L176:
now
let R1 being set;
assume L177: R1 in D30;
L178: (ex B70 being (Element of ( Submodules R4 )) st (R1 = B70 & B70 is (HIPERPLANE of R4))) by L177;
thus L179: R1 is (HIPERPLANE of R4) by L178;
end;
reconsider D31 = D30 as (HIPERPLANE_DOMAIN of R4) by L176 , L172;
take D31;
L180:
now
let R1 being set;
thus L181: (R1 in D31 implies R1 is (HIPERPLANE of R4)) by L176;
thus L182: (R1 is (HIPERPLANE of R4) implies R1 in D31)
proof
assume L183: R1 is (HIPERPLANE of R4);
reconsider D32 = R1 as (HIPERPLANE of R4) by L183;
reconsider D33 = D32 as (Element of ( Submodules R4 )) by VECTSP_5:def 3;
L184: D33 in D30;
thus L185: thesis by L184;
end;

end;
thus L183: thesis by L180;
end;
uniqueness
proof
let C31 , C32 being (HIPERPLANE_DOMAIN of R4);
assume that
L184: (for R1 being set holds (R1 in C31 iff R1 is (HIPERPLANE of R4)))
and
L185: (for R1 being set holds (R1 in C32 iff R1 is (HIPERPLANE of R4)));
L186:
now
let R1 being set;
L187: (R1 in C31 iff R1 is (HIPERPLANE of R4)) by L184;
thus L188: (R1 in C31 iff R1 in C32) by L187 , L185;
end;
thus L189: thesis by L186 , TARSKI:1;
end;
end;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
let C33 being (HIPERPLANE_DOMAIN of R4);
redefine mode Element of C33
 -> (HIPERPLANE of R4);
coherence by L172;
end;
begin
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
let R14 being (FinSequence of ( Submodules R4 ));
func Sum R14 -> (Element of ( Submodules R4 )) equals 
( ( SubJoin R4 ) $$ R14 );
coherence;
func /\ R14 -> (Element of ( Submodules R4 )) equals 
( ( SubMeet R4 ) $$ R14 );
coherence;
end;
theorem
L193: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (( SubJoin R4 ) is  commutative  associative & ( SubJoin R4 ) is  having_a_unity & ( (0). R4 ) = ( the_unity_wrt ( SubJoin R4 ) ))))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
set D34 = ( Submodules R4 );
set D35 = ( SubJoin R4 );
reconsider D36 = LattStr (# (D34 qua non  empty set) , (D35 qua (BinOp of D34)) , (( SubMeet R4 ) qua (BinOp of D34)) #) as Lattice by VECTSP_5:57;
L194: D35 = (the L_join of D36);
thus L195: D35 is  commutative  associative by L194;
set D37 = ( (0). R4 );
reconsider D38 = ( @ D37 ) as (Element of (D34 qua non  empty set));
L196: D38 = D37 by LMOD_6:def 2;
L197:
now
let C34 being (Element of (D34 qua non  empty set));
reconsider D39 = C34 as (Element of D34);
reconsider D40 = D39 as  strict (Subspace of R4);
thus L198: ( D35 . (D38 , C34) ) = ( D37 + D40 ) by L196 , VECTSP_5:def 7
.= C34 by VECTSP_5:9;
thus L199: ( D35 . (C34 , D38) ) = ( D40 + D37 ) by L196 , VECTSP_5:def 7
.= C34 by VECTSP_5:9;
end;
L200: D38 is_a_unity_wrt (D35 qua (BinOp of D34)) by L197 , BINOP_1:3;
thus L201: D35 is  having_a_unity by L200 , SETWISEO:def 2;
thus L202: thesis by L196 , L200 , BINOP_1:def 8;
end;
theorem
L203: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (( SubMeet R4 ) is  commutative  associative & ( SubMeet R4 ) is  having_a_unity & ( (Omega). R4 ) = ( the_unity_wrt ( SubMeet R4 ) ))))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
set D41 = ( Submodules R4 );
set D42 = ( SubMeet R4 );
reconsider D43 = LattStr (# (D41 qua non  empty set) , (( SubJoin R4 ) qua (BinOp of D41)) , (D42 qua (BinOp of D41)) #) as Lattice by VECTSP_5:57;
L204: D42 = (the L_meet of D43);
thus L205: D42 is  commutative  associative by L204;
set D44 = ( (Omega). R4 );
reconsider D45 = ( @ D44 ) as (Element of (D41 qua non  empty set));
L206: D45 = D44 by LMOD_6:def 2;
L207:
now
let C35 being (Element of (D41 qua non  empty set));
reconsider D46 = C35 as (Element of D41);
reconsider D47 = D46 as  strict (Subspace of R4);
thus L208: ( (D42 qua (BinOp of D41)) . (D45 , C35) ) = ( D44 /\ D47 ) by L206 , VECTSP_5:def 8
.= C35 by VECTSP_5:21;
thus L209: ( (D42 qua (BinOp of D41)) . (C35 , D45) ) = ( D47 /\ D44 ) by L206 , VECTSP_5:def 8
.= C35 by VECTSP_5:21;
end;
L210: D45 is_a_unity_wrt (D42 qua (BinOp of D41)) by L207 , BINOP_1:3;
thus L211: D42 is  having_a_unity by L210 , SETWISEO:def 2;
thus L212: thesis by L206 , L210 , BINOP_1:def 8;
end;
begin
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
let R10 being (Subset of R4);
let R11 being (Subset of R4);
func R10 + R11 -> (Subset of R4) means 
(for R1 being set holds (R1 in it iff (ex R7 being (Vector of R4) st (ex R8 being (Vector of R4) st (R7 in R10 & R8 in R11 & R1 = ( R7 + R8 ))))));
existence
proof
set D48 = { ( R7 + R8 ) where R7 is (Vector of R4) , R8 is (Vector of R4) : (R7 in R10 & R8 in R11) };
L213:
now
let R1 being set;
assume L214: R1 in D48;
L215: (ex R7 being (Vector of R4) st (ex R8 being (Vector of R4) st (R1 = ( R7 + R8 ) & R7 in R10 & R8 in R11))) by L214;
thus L216: (ex R7 being (Vector of R4) st (ex R8 being (Vector of R4) st (R7 in R10 & R8 in R11 & R1 = ( R7 + R8 )))) by L215;
end;
L217:
now
let R1 being set;
assume L218: R1 in D48;
L219: (ex R7 being (Vector of R4) st (ex R8 being (Vector of R4) st (R1 = ( R7 + R8 ) & R7 in R10 & R8 in R11))) by L218;
thus L220: R1 in (the carrier of R4) by L219;
end;
reconsider D49 = D48 as (Subset of R4) by L217 , TARSKI:def 3;
take D49;
thus L221: thesis by L213;
end;
uniqueness
proof
let C36 , C37 being (Subset of R4);
assume that
L222: (for R1 being set holds (R1 in C36 iff (ex R7 being (Vector of R4) st (ex R8 being (Vector of R4) st (R7 in R10 & R8 in R11 & R1 = ( R7 + R8 ))))))
and
L223: (for R1 being set holds (R1 in C37 iff (ex R7 being (Vector of R4) st (ex R8 being (Vector of R4) st (R7 in R10 & R8 in R11 & R1 = ( R7 + R8 ))))));
L224:
now
let R1 being set;
L225: (R1 in C36 iff (ex R7 being (Vector of R4) st (ex R8 being (Vector of R4) st (R7 in R10 & R8 in R11 & R1 = ( R7 + R8 ))))) by L222;
thus L226: (R1 in C36 iff R1 in C37) by L225 , L223;
end;
thus L227: thesis by L224 , TARSKI:1;
end;
end;
begin
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
let R9 being (Subset of R4);
assume L229: R9 <> ( {} );
mode Vector of R9
 -> (Vector of R4)
means :L230: it is (Element of R9);
existence
proof
consider C38 being (Element of R4) such that L231: C38 in R9 by L229 , SUBSET_1:4;
take C38;
thus L232: thesis by L231;
end;
end;
theorem
L234: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R10 being (Subset of R4) holds (for R11 being (Subset of R4) holds ((R10 <> ( {} ) & R10 c= R11) implies (for R1 being set holds (R1 is (Vector of R10) implies R1 is (Vector of R11))))))))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
let R10 being (Subset of R4);
let R11 being (Subset of R4);
assume that
L235: R10 <> ( {} )
and
L236: R10 c= R11;
let R1 being set;
assume L237: R1 is (Vector of R10);
reconsider D50 = R1 as (Vector of R10) by L237;
L238: D50 is (Element of R10) by L235 , L230;
L239: D50 in R11 by L238 , L235 , L236 , TARSKI:def 3;
thus L240: thesis by L239 , L230;
end;
theorem
L241: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R7 being (Vector of R4) holds (for R8 being (Vector of R4) holds (for R13 being (Subspace of R4) holds (R8 in ( R7 + R13 ) iff ( R7 - R8 ) in R13))))))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
let R7 being (Vector of R4);
let R8 being (Vector of R4);
let R13 being (Subspace of R4);
L242: ( R7 - ( R7 - R8 ) ) = ( ( R7 - R7 ) + R8 ) by RLVECT_1:29
.= ( ( 0. R4 ) + R8 ) by VECTSP_1:19
.= R8 by RLVECT_1:def 4;
thus L243: thesis by L242 , VECTSP_4:61;
end;
theorem
L244: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R7 being (Vector of R4) holds (for R8 being (Vector of R4) holds (for R13 being (Subspace of R4) holds (( R7 + R13 ) = ( R8 + R13 ) iff ( R7 - R8 ) in R13))))))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
let R7 being (Vector of R4);
let R8 being (Vector of R4);
let R13 being (Subspace of R4);
L245: (R8 in ( R7 + R13 ) iff ( R7 + R13 ) = ( R8 + R13 )) by VECTSP_4:55;
thus L246: thesis by L245 , L241;
end;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
func R4 .. R13 -> set means 
:L247: (for R1 being set holds (R1 in it iff (ex R5 being (Vector of R4) st R1 = ( R5 + R13 ))));
existence
proof
take { ( R5 + R13 ) where R5 is (Vector of R4) : (not contradiction) };
thus L248: thesis;
end;
uniqueness
proof
defpred S2[ set ] means (ex R5 being (Vector of R4) st $1 = ( R5 + R13 ));
thus L249: (for B71 , B72 being set holds (((for R1 being set holds (R1 in B71 iff S2[ R1 ])) & (for R1 being set holds (R1 in B72 iff S2[ R1 ]))) implies B71 = B72)) from XBOOLE_0:sch 3;
end;
end;
registration
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
cluster ( R4 .. R13 ) -> non  empty;
coherence
proof
L251: (for R5 being (Vector of R4) holds ( R5 + R13 ) in ( R4 .. R13 )) by L247;
thus L252: thesis by L251;
end;
end;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
let R5 being (Vector of R4);
func R5 .. R13 -> (Element of ( R4 .. R13 )) equals 
( R5 + R13 );
coherence by L247;
end;
theorem
L255: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R13 being (Subspace of R4) holds (for B73 being (Element of ( R4 .. R13 )) holds (ex R5 being (Vector of R4) st B73 = ( R5 .. R13 ))))))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
let C39 being (Element of ( R4 .. R13 ));
consider R5 being (Vector of R4) such that L256: C39 = ( R5 + R13 ) by L247;
take R5;
thus L257: thesis by L256;
end;
theorem
L258: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R7 being (Vector of R4) holds (for R8 being (Vector of R4) holds (for R13 being (Subspace of R4) holds (( R7 .. R13 ) = ( R8 .. R13 ) iff ( R7 - R8 ) in R13)))))) by L244;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
let R15 being (Element of ( R4 .. R13 ));
func - R15 -> (Element of ( R4 .. R13 )) means 
(for R5 being (Vector of R4) holds (R15 = ( R5 .. R13 ) implies it = ( ( - R5 ) .. R13 )));
existence
proof
consider R7 being (Vector of R4) such that L259: R15 = ( R7 .. R13 ) by L255;
L260:
now
let C40 being (Vector of R4);
assume L261: R15 = ( C40 .. R13 );
L262: ( R7 - C40 ) in R13 by L261 , L259 , L244;
L263: ( - ( R7 - C40 ) ) in R13 by L262 , VECTSP_4:22;
L264: ( ( - R7 ) - ( - C40 ) ) in R13 by L263 , L48;
thus L265: ( ( - R7 ) .. R13 ) = ( ( - C40 ) .. R13 ) by L264 , L244;
end;
take ( ( - R7 ) .. R13 );
thus L266: thesis by L260;
end;
uniqueness
proof
let C41 , C42 being (Element of ( R4 .. R13 ));
assume that
L267: (for R5 being (Vector of R4) holds (R15 = ( R5 .. R13 ) implies C41 = ( ( - R5 ) .. R13 )))
and
L268: (for R5 being (Vector of R4) holds (R15 = ( R5 .. R13 ) implies C42 = ( ( - R5 ) .. R13 )));
consider R7 being (Vector of R4) such that L269: R15 = ( R7 .. R13 ) by L255;
thus L270: C41 = ( ( - R7 ) .. R13 ) by L267 , L269
.= C42 by L268 , L269;
end;
let R16 being (Element of ( R4 .. R13 ));
func R15 + R16 -> (Element of ( R4 .. R13 )) means 
:L271: (for R7 being (Vector of R4) holds (for R8 being (Vector of R4) holds ((R15 = ( R7 .. R13 ) & R16 = ( R8 .. R13 )) implies it = ( ( R7 + R8 ) .. R13 ))));
existence
proof
consider R7 being (Vector of R4) such that L272: R15 = ( R7 .. R13 ) by L255;
consider R8 being (Vector of R4) such that L273: R16 = ( R8 .. R13 ) by L255;
L274:
now
let C43 , C44 being (Vector of R4);
assume that
L275: R15 = ( C43 .. R13 )
and
L276: R16 = ( C44 .. R13 );
L277: ( R7 - C43 ) in R13 by L272 , L275 , L244;
L278: ( R8 - C44 ) in R13 by L273 , L276 , L244;
L279: ( ( R7 - C43 ) + ( R8 - C44 ) ) in R13 by L278 , L277 , VECTSP_4:20;
L280: ( ( R7 - C43 ) + ( R8 - C44 ) ) = ( ( ( R7 - C43 ) + R8 ) - C44 ) by RLVECT_1:def 3
.= ( ( ( R7 + R8 ) - C43 ) - C44 ) by L48
.= ( ( R7 + R8 ) - ( C43 + C44 ) ) by VECTSP_1:17;
thus L281: ( ( R7 + R8 ) .. R13 ) = ( ( C43 + C44 ) .. R13 ) by L280 , L279 , L244;
end;
take ( ( R7 + R8 ) .. R13 );
thus L282: thesis by L274;
end;
uniqueness
proof
let C45 , C46 being (Element of ( R4 .. R13 ));
assume that
L283: (for R7 being (Vector of R4) holds (for R8 being (Vector of R4) holds ((R15 = ( R7 .. R13 ) & R16 = ( R8 .. R13 )) implies C45 = ( ( R7 + R8 ) .. R13 ))))
and
L284: (for R7 being (Vector of R4) holds (for R8 being (Vector of R4) holds ((R15 = ( R7 .. R13 ) & R16 = ( R8 .. R13 )) implies C46 = ( ( R7 + R8 ) .. R13 ))));
consider R7 being (Vector of R4) such that L285: R15 = ( R7 .. R13 ) by L255;
consider R8 being (Vector of R4) such that L286: R16 = ( R8 .. R13 ) by L255;
thus L287: C45 = ( ( R7 + R8 ) .. R13 ) by L283 , L285 , L286
.= C46 by L284 , L285 , L286;
end;
end;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
deffunc H1((Element of ( R4 .. R13 ))) = ( - $1 );
func COMPL R13 -> (UnOp of ( R4 .. R13 )) means 
(for R15 being (Element of ( R4 .. R13 )) holds ( it . R15 ) = ( - R15 ));
existence
proof
thus L289: (ex B74 being (UnOp of ( R4 .. R13 )) st (for R15 being (Element of ( R4 .. R13 )) holds ( B74 . R15 ) = H1(R15))) from FUNCT_2:sch 4;
end;
uniqueness
proof
thus L290: (for B75 , B76 being (UnOp of ( R4 .. R13 )) holds (((for R15 being (Element of ( R4 .. R13 )) holds ( B75 . R15 ) = H1(R15)) & (for R15 being (Element of ( R4 .. R13 )) holds ( B76 . R15 ) = H1(R15))) implies B75 = B76)) from UnOpEq;
end;
deffunc H2((Element of ( R4 .. R13 )) , (Element of ( R4 .. R13 ))) = ( $1 + $2 );
func ADD R13 -> (BinOp of ( R4 .. R13 )) means 
:L291: (for R15 being (Element of ( R4 .. R13 )) holds (for R16 being (Element of ( R4 .. R13 )) holds ( it . (R15 , R16) ) = ( R15 + R16 )));
existence
proof
thus L292: (ex B77 being (BinOp of ( R4 .. R13 )) st (for R15 being (Element of ( R4 .. R13 )) holds (for R16 being (Element of ( R4 .. R13 )) holds ( B77 . (R15 , R16) ) = H2(R15 , R16)))) from BINOP_1:sch 4;
end;
uniqueness
proof
thus L293: (for B78 , B79 being (BinOp of ( R4 .. R13 )) holds (((for R15 being (Element of ( R4 .. R13 )) holds (for R16 being (Element of ( R4 .. R13 )) holds ( B78 . (R15 , R16) ) = H2(R15 , R16))) & (for R15 being (Element of ( R4 .. R13 )) holds (for R16 being (Element of ( R4 .. R13 )) holds ( B79 . (R15 , R16) ) = H2(R15 , R16)))) implies B78 = B79)) from BINOP_2:sch 2;
end;
end;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
func R4 . R13 ->  strict addLoopStr equals 
addLoopStr (# ( R4 .. R13 ) , ( ADD R13 ) , ( ( 0. R4 ) .. R13 ) #);
coherence;
end;
registration
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
cluster ( R4 . R13 ) -> non  empty;
coherence;
end;
theorem
L297: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R5 being (Vector of R4) holds (for R13 being (Subspace of R4) holds ( R5 .. R13 ) is (Element of ( R4 . R13 ))))));
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
let R5 being (Vector of R4);
func R5 . R13 -> (Element of ( R4 . R13 )) equals 
( R5 .. R13 );
coherence;
end;
theorem
L299: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R13 being (Subspace of R4) holds (for B80 being (Element of ( R4 . R13 )) holds (ex R5 being (Vector of R4) st B80 = ( R5 . R13 ))))))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
let C47 being (Element of ( R4 . R13 ));
consider R5 being (Vector of R4) such that L300: C47 = ( R5 .. R13 ) by L255;
take R5;
thus L301: thesis by L300;
end;
theorem
L302: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R7 being (Vector of R4) holds (for R8 being (Vector of R4) holds (for R13 being (Subspace of R4) holds (( R7 . R13 ) = ( R8 . R13 ) iff ( R7 - R8 ) in R13)))))) by L244;
theorem
L303: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R5 being (Vector of R4) holds (for R6 being (Vector of R4) holds (for R13 being (Subspace of R4) holds (( ( R5 . R13 ) + ( R6 . R13 ) ) = ( ( R5 + R6 ) . R13 ) & ( 0. ( R4 . R13 ) ) = ( ( 0. R4 ) . R13 )))))))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
let R5 being (Vector of R4);
let R6 being (Vector of R4);
let R13 being (Subspace of R4);
thus L304: ( ( R5 . R13 ) + ( R6 . R13 ) ) = ( ( R5 .. R13 ) + ( R6 .. R13 ) ) by L291
.= ( ( R5 + R6 ) . R13 ) by L271;
thus L305: thesis;
end;
registration
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
cluster ( R4 . R13 ) ->  Abelian  add-associative  right_zeroed  right_complementable;
coherence
proof
set D51 = ( R4 . R13 );
thus L306:now
let C48 , C49 being (Element of D51);
consider C50 being (Vector of R4) such that L307: C48 = ( C50 . R13 ) by L299;
consider C51 being (Vector of R4) such that L308: C49 = ( C51 . R13 ) by L299;
L309: ( C48 + C49 ) = ( ( C50 + C51 ) . R13 ) by L307 , L308 , L303;
thus L310: ( C48 + C49 ) = ( C49 + C48 ) by L309 , L307 , L308 , L303;
end;
thus L311:now
let C52 , C53 , C54 being (Element of D51);
consider C55 being (Vector of R4) such that L312: C52 = ( C55 . R13 ) by L299;
consider C56 being (Vector of R4) such that L313: C53 = ( C56 . R13 ) by L299;
consider C57 being (Vector of R4) such that L314: C54 = ( C57 . R13 ) by L299;
L315: ( C52 + C53 ) = ( ( C55 + C56 ) . R13 ) by L312 , L313 , L303;
L316: ( C53 + C54 ) = ( ( C56 + C57 ) . R13 ) by L313 , L314 , L303;
thus L317: ( ( C52 + C53 ) + C54 ) = ( ( ( C55 + C56 ) + C57 ) . R13 ) by L314 , L315 , L303
.= ( ( C55 + ( C56 + C57 ) ) . R13 ) by RLVECT_1:def 3
.= ( C52 + ( C53 + C54 ) ) by L312 , L316 , L303;
end;
thus L318:now
let C58 being (Element of D51);
consider C59 being (Vector of R4) such that L319: C58 = ( C59 . R13 ) by L299;
L320: ( 0. D51 ) = ( ( 0. R4 ) . R13 );
thus L321: ( C58 + ( 0. D51 ) ) = ( ( C59 + ( 0. R4 ) ) . R13 ) by L320 , L319 , L303
.= C58 by L319 , RLVECT_1:4;
end;
let C60 being (Element of D51);
consider C61 being (Vector of R4) such that L322: C60 = ( C61 . R13 ) by L299;
consider C62 being (Vector of R4) such that L323: ( C61 + C62 ) = ( 0. R4 ) by ALGSTR_0:def 11;
reconsider D52 = ( C62 . R13 ) as (Element of D51);
take D52;
thus L324: ( C60 + D52 ) = ( ( 0. R4 ) . R13 ) by L322 , L323 , L303
.= ( 0. D51 );
end;
end;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
let R3 being (Scalar of R2);
let R17 being (Element of ( R4 . R13 ));
func R3 * R17 -> (Element of ( R4 . R13 )) means 
:L326: (for R5 being (Vector of R4) holds (R17 = ( R5 . R13 ) implies it = ( ( R3 * R5 ) . R13 )));
existence
proof
consider R7 being (Vector of R4) such that L327: R17 = ( R7 . R13 ) by L299;
L328:
now
let R5 being (Vector of R4);
assume L329: R17 = ( R5 . R13 );
L330: ( R5 - R7 ) in R13 by L329 , L327 , L244;
L331: ( R3 * ( R5 - R7 ) ) in R13 by L330 , VECTSP_4:21;
L332: ( ( R3 * R5 ) - ( R3 * R7 ) ) in R13 by L331 , VECTSP_1:23;
thus L333: ( ( R3 * R5 ) . R13 ) = ( ( R3 * R7 ) . R13 ) by L332 , L244;
end;
take ( ( R3 * R7 ) . R13 );
thus L334: thesis by L328;
end;
uniqueness
proof
let C63 , C64 being (Element of ( R4 . R13 ));
assume that
L335: (for R5 being (Vector of R4) holds (R17 = ( R5 . R13 ) implies C63 = ( ( R3 * R5 ) . R13 )))
and
L336: (for R5 being (Vector of R4) holds (R17 = ( R5 . R13 ) implies C64 = ( ( R3 * R5 ) . R13 )));
consider R7 being (Vector of R4) such that L337: R17 = ( R7 . R13 ) by L299;
thus L338: C63 = ( ( R3 * R7 ) . R13 ) by L335 , L337
.= C64 by L336 , L337;
end;
end;
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
func LMULT R13 -> (Function of [: (the carrier of R2) , (the carrier of ( R4 . R13 )) :] , (the carrier of ( R4 . R13 ))) means 
:L340: (for R3 being (Scalar of R2) holds (for R17 being (Element of ( R4 . R13 )) holds ( it . (R3 , R17) ) = ( R3 * R17 )));
existence
proof
deffunc H3((Scalar of R2) , (Element of ( R4 . R13 ))) = ( $1 * $2 );
consider C65 being (Function of [: (the carrier of R2) , (the carrier of ( R4 . R13 )) :] , (the carrier of ( R4 . R13 ))) such that L341: (for R3 being (Scalar of R2) holds (for R17 being (Element of ( R4 . R13 )) holds ( C65 . (R3 , R17) ) = H3(R3 , R17))) from BINOP_1:sch 4;
take C65;
thus L342: thesis by L341;
end;
uniqueness
proof
let C66 , C67 being (Function of [: (the carrier of R2) , (the carrier of ( R4 . R13 )) :] , (the carrier of ( R4 . R13 )));
assume that
L343: (for R3 being (Scalar of R2) holds (for R17 being (Element of ( R4 . R13 )) holds ( C66 . (R3 , R17) ) = ( R3 * R17 )))
and
L344: (for R3 being (Scalar of R2) holds (for R17 being (Element of ( R4 . R13 )) holds ( C67 . (R3 , R17) ) = ( R3 * R17 )));
L345:
now
let R3 being (Scalar of R2);
let R17 being (Element of ( R4 . R13 ));
thus L346: ( C66 . (R3 , R17) ) = ( R3 * R17 ) by L343
.= ( C67 . (R3 , R17) ) by L344;
end;
thus L347: thesis by L345 , BINOP_1:2;
end;
end;
begin
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
func R4 / R13 ->  strict VectSpStr over R2 equals 
VectSpStr (# (the carrier of ( R4 . R13 )) , (the addF of ( R4 . R13 )) , ( ( 0. R4 ) . R13 ) , ( LMULT R13 ) #);
coherence;
end;
registration
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
cluster ( R4 / R13 ) -> non  empty;
coherence;
end;
theorem
L351: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R5 being (Vector of R4) holds (for R13 being (Subspace of R4) holds ( R5 . R13 ) is (Vector of ( R4 / R13 ))))));
theorem
L352: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R13 being (Subspace of R4) holds (for B81 being (Vector of ( R4 / R13 )) holds B81 is (Element of ( R4 . R13 ))))));
definition
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
let R5 being (Vector of R4);
func R5 / R13 -> (Vector of ( R4 / R13 )) equals 
( R5 . R13 );
coherence;
end;
theorem
L354: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R13 being (Subspace of R4) holds (for B82 being (Vector of ( R4 / R13 )) holds (ex R5 being (Vector of R4) st B82 = ( R5 / R13 ))))))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
let C68 being (Vector of ( R4 / R13 ));
consider R5 being (Vector of R4) such that L355: C68 = ( R5 . R13 ) by L299;
take R5;
thus L356: thesis by L355;
end;
theorem
L357: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R7 being (Vector of R4) holds (for R8 being (Vector of R4) holds (for R13 being (Subspace of R4) holds (( R7 / R13 ) = ( R8 / R13 ) iff ( R7 - R8 ) in R13)))))) by L244;
theorem
L358: (for R2 being Ring holds (for R3 being (Scalar of R2) holds (for R4 being (LeftMod of R2) holds (for R5 being (Vector of R4) holds (for R6 being (Vector of R4) holds (for R13 being (Subspace of R4) holds (( ( R5 / R13 ) + ( R6 / R13 ) ) = ( ( R5 + R6 ) / R13 ) & ( R3 * ( R5 / R13 ) ) = ( ( R3 * R5 ) / R13 ))))))))
proof
let R2 being Ring;
let R3 being (Scalar of R2);
let R4 being (LeftMod of R2);
let R5 being (Vector of R4);
let R6 being (Vector of R4);
let R13 being (Subspace of R4);
thus L359: ( ( R5 / R13 ) + ( R6 / R13 ) ) = ( ( R5 . R13 ) + ( R6 . R13 ) )
.= ( ( R5 + R6 ) / R13 ) by L303;
thus L360: ( R3 * ( R5 / R13 ) ) = ( ( LMULT R13 ) . (R3 , ( R5 . R13 )) ) by VECTSP_1:def 12
.= ( R3 * (( R5 . R13 ) qua (Element of ( R4 . R13 ))) ) by L340
.= ( ( R3 * R5 ) / R13 ) by L326;
end;
L361: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R13 being (Subspace of R4) holds ( R4 / R13 ) is  Abelian  add-associative  right_zeroed  right_complementable)))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
L362: (for B83 , B84 , B85 being (Element of ( R4 . R13 )) holds (for B86 , B87 , B88 being (Vector of ( R4 / R13 )) holds ((B83 = B86 & B84 = B87 & B85 = B88) implies ( B83 + B84 ) = ( B86 + B87 ))));
thus L363: ( R4 / R13 ) is  Abelian
proof
let C69 , C70 being (Vector of ( R4 / R13 ));
reconsider D53 = C69 , D54 = C70 as (Element of ( R4 . R13 ));
thus L364: ( C69 + C70 ) = ( D53 + D54 )
.= ( C70 + C69 ) by L362;
end;

thus L365:now
let C71 , C72 , C73 being (Vector of ( R4 / R13 ));
reconsider D55 = C71 , D56 = C72 , D57 = C73 as (Element of ( R4 . R13 ));
thus L366: ( ( C71 + C72 ) + C73 ) = ( ( D55 + D56 ) + D57 )
.= ( D55 + ( D56 + D57 ) ) by RLVECT_1:def 3
.= ( C71 + ( C72 + C73 ) );
end;
thus L367:now
let C74 being (Vector of ( R4 / R13 ));
reconsider D58 = C74 as (Element of ( R4 . R13 ));
thus L368: ( C74 + ( 0. ( R4 / R13 ) ) ) = ( D58 + ( 0. ( R4 . R13 ) ) )
.= C74 by RLVECT_1:4;
end;
let C75 being (Vector of ( R4 / R13 ));
reconsider D59 = C75 as (Element of ( R4 . R13 ));
consider C76 being (Element of ( R4 . R13 )) such that L369: ( D59 + C76 ) = ( 0. ( R4 . R13 ) ) by ALGSTR_0:def 11;
reconsider D60 = C76 as (Vector of ( R4 / R13 ));
take D60;
thus L370: thesis by L369;
end;
theorem
L371: (for R2 being Ring holds (for R4 being (LeftMod of R2) holds (for R13 being (Subspace of R4) holds ( R4 / R13 ) is  strict  strict  strict  strict (LeftMod of R2))))
proof
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
L372:
now
let C77 , C78 being (Scalar of R2);
let C79 , C80 being (Vector of ( R4 / R13 ));
consider R5 being (Vector of R4) such that L373: C79 = ( R5 / R13 ) by L354;
consider R6 being (Vector of R4) such that L374: C80 = ( R6 / R13 ) by L354;
L375: ( ( C77 * R5 ) / R13 ) = ( C77 * C79 ) by L373 , L358;
L376: ( ( C77 * R6 ) / R13 ) = ( C77 * C80 ) by L374 , L358;
L377: ( ( C78 * R5 ) / R13 ) = ( C78 * C79 ) by L373 , L358;
thus L378: ( C77 * ( C79 + C80 ) ) = ( C77 * ( ( R5 + R6 ) / R13 ) ) by L373 , L374 , L358
.= ( ( C77 * ( R5 + R6 ) ) / R13 ) by L358
.= ( ( ( C77 * R5 ) + ( C77 * R6 ) ) / R13 ) by VECTSP_1:def 14
.= ( ( C77 * C79 ) + ( C77 * C80 ) ) by L375 , L376 , L358;
thus L379: ( ( C77 + C78 ) * C79 ) = ( ( ( C77 + C78 ) * R5 ) / R13 ) by L373 , L358
.= ( ( ( C77 * R5 ) + ( C78 * R5 ) ) / R13 ) by VECTSP_1:def 15
.= ( ( C77 * C79 ) + ( C78 * C79 ) ) by L375 , L377 , L358;
thus L380: ( ( C77 * C78 ) * C79 ) = ( ( ( C77 * C78 ) * R5 ) / R13 ) by L373 , L358
.= ( ( C77 * ( C78 * R5 ) ) / R13 ) by VECTSP_1:def 16
.= ( C77 * ( ( C78 * R5 ) / R13 ) ) by L358
.= ( C77 * ( C78 * C79 ) ) by L373 , L358;
thus L381: ( ( 1_ R2 ) * C79 ) = ( ( ( 1_ R2 ) * R5 ) / R13 ) by L373 , L358
.= C79 by L373 , VECTSP_1:def 17;
end;
thus L382: thesis by L372 , L361 , VECTSP_1:def 14 , VECTSP_1:def 15 , VECTSP_1:def 16 , VECTSP_1:def 17;
end;
registration
let R2 being Ring;
let R4 being (LeftMod of R2);
let R13 being (Subspace of R4);
cluster ( R4 / R13 ) ->  vector-distributive  scalar-distributive  scalar-associative  scalar-unital;
coherence by L371;
end;
