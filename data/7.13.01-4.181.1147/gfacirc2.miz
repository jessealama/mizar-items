:: Stability of n-bit Generalized Full Adder Circuits (GFAs). Part {II}
::  by Katsumi Wasaki
::
:: Received December 18, 2007
:: Copyright (c) 2007-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, NAT_1, FINSEQ_1, CIRCCOMB, CARD_1, FINSEQ_2, MARGREL1,
      FUNCOP_1, XBOOLEAN, STRUCT_0, XBOOLE_0, MSUALG_1, PBOOLE, FUNCT_1,
      ARYTM_3, FUNCT_4, GFACIRC1, LATTICES, CIRCUIT1, RELAT_1, SUBSET_1,
      MSAFREE2, ORDINAL4, XXREAL_0, TARSKI, FACIRC_1, TWOSCOMP, MCART_1, FSM_1,
      CIRCUIT2, GFACIRC2;
 notations TARSKI, XBOOLE_0, ENUMSET1,
      XTUPLE_0, SUBSET_1, XCMPLX_0, MCART_1, RELAT_1,
      CARD_1, STRUCT_0, FUNCT_1, FUNCT_2, FINSEQ_1, FINSEQ_2, PBOOLE, ORDINAL1,
      NAT_1, MARGREL1, MSUALG_1, MSAFREE2, CIRCUIT1, CIRCUIT2, CIRCCOMB,
      FACIRC_1, TWOSCOMP, FACIRC_2, GFACIRC1, NUMBERS, XXREAL_0;
 constructors ENUMSET1, CIRCUIT2, FACIRC_1, TWOSCOMP, GFACIRC1, SEQ_1, XREAL_0,
      RELSET_1, XTUPLE_0;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, XXREAL_0, XREAL_0, NAT_1,
      FINSEQ_1, MARGREL1, FINSEQ_2, STRUCT_0, CIRCCOMB, FACIRC_1, CIRCCMB2,
      FACIRC_2, MSAFREE2, FINSET_1, CARD_1, XTUPLE_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions MARGREL1, FACIRC_1, GFACIRC1, XTUPLE_0;
 theorems TARSKI, ENUMSET1, MCART_1, NAT_1, ORDINAL1, PBOOLE, XBOOLE_0,
      XBOOLE_1, XREAL_1, FUNCT_2, FUNCOP_1, FINSEQ_1, FINSEQ_2, CIRCCOMB,
      FACIRC_1, CIRCCMB2, FACIRC_2, GFACIRC1, PARTFUN1, CARD_1;
 schemes NAT_1, PBOOLE, CIRCCMB2;

begin
definition
let C1 being Nat;
let C2 , C3 being FinSequence;
set D1 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D2 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ];
L1: ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) ) is  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty  strict;
func C1 -BitGFA0Str (C2 , C3) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign means 
:L2: (ex B1 , B2 being (ManySortedSet of ( NAT )) st (it = ( B1 . C1 ) & ( B1 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) ) & ( B2 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ] & (for B3 being Nat holds (for B4 being non  empty ManySortedSign holds (for B5 being set holds ((B4 = ( B1 . B3 ) & B5 = ( B2 . B3 )) implies (( B1 . ( B3 + 1 ) ) = ( B4 +* ( BitGFA0Str (( C2 . ( B3 + 1 ) ) , ( C3 . ( B3 + 1 ) ) , B5) ) ) & ( B2 . ( B3 + 1 ) ) = ( GFA0CarryOutput (( C2 . ( B3 + 1 ) ) , ( C3 . ( B3 + 1 ) ) , B5) ))))))));
uniqueness
proof
reconsider D3 = C1 as Nat;
deffunc H1(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitGFA0Str (( C2 . ( $3 + 1 ) ) , ( C3 . ( $3 + 1 ) ) , $2) ) );
deffunc H2(set , Nat) = ( GFA0CarryOutput (( C2 . ( $2 + 1 ) ) , ( C3 . ( $2 + 1 ) ) , $1) );
L3: (for B6 , B7 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty  strict non  empty ManySortedSign holds (((ex B8 , B9 being (ManySortedSet of ( NAT )) st (B6 = ( B8 . D3 ) & ( B8 . ( 0 ) ) = D1 & ( B9 . ( 0 ) ) = D2 & (for B10 being Nat holds (for B11 being non  empty ManySortedSign holds (for B12 being set holds ((B11 = ( B8 . B10 ) & B12 = ( B9 . B10 )) implies (( B8 . ( B10 + 1 ) ) = H1(B11 , B12 , B10) & ( B9 . ( B10 + 1 ) ) = H2(B12 , B10)))))))) & (ex B13 , B14 being (ManySortedSet of ( NAT )) st (B7 = ( B13 . D3 ) & ( B13 . ( 0 ) ) = D1 & ( B14 . ( 0 ) ) = D2 & (for B15 being Nat holds (for B16 being non  empty ManySortedSign holds (for B17 being set holds ((B16 = ( B13 . B15 ) & B17 = ( B14 . B15 )) implies (( B13 . ( B15 + 1 ) ) = H1(B16 , B17 , B15) & ( B14 . ( B15 + 1 ) ) = H2(B17 , B15))))))))) implies B6 = B7)) from CIRCCMB2:sch 9;
thus L4: thesis by L3;
end;
existence
proof
reconsider D4 = C1 as Nat;
deffunc H3(set , Nat) = ( BitGFA0Str (( C2 . ( $2 + 1 ) ) , ( C3 . ( $2 + 1 ) ) , $1) );
deffunc H4(set , Nat) = ( GFA0CarryOutput (( C2 . ( $2 + 1 ) ) , ( C3 . ( $2 + 1 ) ) , $1) );
L5: (ex B18 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty non  empty  strict ManySortedSign st (ex B19 , B20 being (ManySortedSet of ( NAT )) st (B18 = ( B19 . D4 ) & ( B19 . ( 0 ) ) = D1 & ( B20 . ( 0 ) ) = D2 & (for B21 being Nat holds (for B22 being non  empty ManySortedSign holds (for B23 being set holds ((B22 = ( B19 . B21 ) & B23 = ( B20 . B21 )) implies (( B19 . ( B21 + 1 ) ) = ( B22 +* H3(B23 , B21) ) & ( B20 . ( B21 + 1 ) ) = H4(B23 , B21))))))))) from CIRCCMB2:sch 8(L1);
thus L6: thesis by L5;
end;
end;
definition
let C4 being Nat;
let C5 , C6 being FinSequence;
func C4 -BitGFA0Circ (C5 , C6) ->  Boolean  gate`2=den  strict (Circuit of ( C4 -BitGFA0Str (C5 , C6) )) means 
:L8: (ex B24 , B25 , B26 being (ManySortedSet of ( NAT )) st (( C4 -BitGFA0Str (C5 , C6) ) = ( B24 . C4 ) & it = ( B25 . C4 ) & ( B24 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) ) & ( B25 . ( 0 ) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) ) & ( B26 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ] & (for B27 being Nat holds (for B28 being non  empty ManySortedSign holds (for B29 being  non-empty MSAlgebra over B28 holds (for B30 being set holds ((B28 = ( B24 . B27 ) & B29 = ( B25 . B27 ) & B30 = ( B26 . B27 )) implies (( B24 . ( B27 + 1 ) ) = ( B28 +* ( BitGFA0Str (( C5 . ( B27 + 1 ) ) , ( C6 . ( B27 + 1 ) ) , B30) ) ) & ( B25 . ( B27 + 1 ) ) = ( B29 +* ( BitGFA0Circ (( C5 . ( B27 + 1 ) ) , ( C6 . ( B27 + 1 ) ) , B30) ) ) & ( B26 . ( B27 + 1 ) ) = ( GFA0CarryOutput (( C5 . ( B27 + 1 ) ) , ( C6 . ( B27 + 1 ) ) , B30) )))))))));
uniqueness
proof
set D5 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D6 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D7 = ( C4 -BitGFA0Str (C5 , C6) );
set D8 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ];
deffunc H5(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitGFA0Str (( C5 . ( $3 + 1 ) ) , ( C6 . ( $3 + 1 ) ) , $2) ) );
deffunc H6(non  empty ManySortedSign ,  non-empty MSAlgebra over $1 , set , Nat) = ( $2 +* ( BitGFA0Circ (( C5 . ( $4 + 1 ) ) , ( C6 . ( $4 + 1 ) ) , $3) ) );
deffunc H7(set , Nat) = ( GFA0CarryOutput (( C5 . ( $2 + 1 ) ) , ( C6 . ( $2 + 1 ) ) , $1) );
L9: (for B31 being non  empty ManySortedSign holds (for B32 being  non-empty MSAlgebra over B31 holds (for B33 being set holds (for B34 being Nat holds H6(B31 , B32 , B33 , B34) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over H5(B31 , B33 , B34)))));
L10: (for B35 , B36 being  Boolean  gate`2=den  strict (Circuit of D7) holds (((ex B37 , B38 , B39 being (ManySortedSet of ( NAT )) st (D7 = ( B37 . C4 ) & B35 = ( B38 . C4 ) & ( B37 . ( 0 ) ) = D5 & ( B38 . ( 0 ) ) = D6 & ( B39 . ( 0 ) ) = D8 & (for B40 being Nat holds (for B41 being non  empty ManySortedSign holds (for B42 being  non-empty MSAlgebra over B41 holds (for B43 being set holds ((B41 = ( B37 . B40 ) & B42 = ( B38 . B40 ) & B43 = ( B39 . B40 )) implies (( B37 . ( B40 + 1 ) ) = H5(B41 , B43 , B40) & ( B38 . ( B40 + 1 ) ) = H6(B41 , B42 , B43 , B40) & ( B39 . ( B40 + 1 ) ) = H7(B43 , B40))))))))) & (ex B44 , B45 , B46 being (ManySortedSet of ( NAT )) st (D7 = ( B44 . C4 ) & B36 = ( B45 . C4 ) & ( B44 . ( 0 ) ) = D5 & ( B45 . ( 0 ) ) = D6 & ( B46 . ( 0 ) ) = D8 & (for B47 being Nat holds (for B48 being non  empty ManySortedSign holds (for B49 being  non-empty MSAlgebra over B48 holds (for B50 being set holds ((B48 = ( B44 . B47 ) & B49 = ( B45 . B47 ) & B50 = ( B46 . B47 )) implies (( B44 . ( B47 + 1 ) ) = H5(B48 , B50 , B47) & ( B45 . ( B47 + 1 ) ) = H6(B48 , B49 , B50 , B47) & ( B46 . ( B47 + 1 ) ) = H7(B50 , B47)))))))))) implies B35 = B36)) from CIRCCMB2:sch 21(L9);
thus L11: thesis by L10;
end;
existence
proof
set D9 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D10 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D11 = ( C4 -BitGFA0Str (C5 , C6) );
set D12 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ];
deffunc H8(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitGFA0Str (( C5 . ( $3 + 1 ) ) , ( C6 . ( $3 + 1 ) ) , $2) ) );
deffunc H9(non  empty ManySortedSign ,  non-empty MSAlgebra over $1 , set , Nat) = ( $2 +* ( BitGFA0Circ (( C5 . ( $4 + 1 ) ) , ( C6 . ( $4 + 1 ) ) , $3) ) );
deffunc H10(set , Nat) = ( GFA0CarryOutput (( C5 . ( $2 + 1 ) ) , ( C6 . ( $2 + 1 ) ) , $1) );
L12: (for B51 being  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign holds (for B52 being set holds (for B53 being Nat holds H8(B51 , B52 , B53) is  unsplit  gate`1=arity  gate`2isBoolean non  void  strict)));
L13: (ex B54 , B55 being (ManySortedSet of ( NAT )) st (D11 = ( B54 . C4 ) & ( B54 . ( 0 ) ) = D9 & ( B55 . ( 0 ) ) = D12 & (for B56 being Nat holds (for B57 being non  empty ManySortedSign holds (for B58 being set holds ((B57 = ( B54 . B56 ) & B58 = ( B55 . B56 )) implies (( B54 . ( B56 + 1 ) ) = H8(B57 , B58 , B56) & ( B55 . ( B56 + 1 ) ) = H10(B58 , B56)))))))) by L2;
L14: (for B59 being non  empty ManySortedSign holds (for B60 being  non-empty MSAlgebra over B59 holds (for B61 being set holds (for B62 being Nat holds H9(B59 , B60 , B61 , B62) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over H8(B59 , B61 , B62)))));
L15: (for B63 , B64 being  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign holds (for B65 being  Boolean  gate`2=den  strict (Circuit of B63) holds (for B66 being set holds (for B67 being Nat holds (B64 = H8(B63 , B66 , B67) implies H9(B63 , B65 , B66 , B67) is  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict (Circuit of B64))))));
L16: (ex B68 being  Boolean  gate`2=den  strict (Circuit of D11) st (ex B69 , B70 , B71 being (ManySortedSet of ( NAT )) st (D11 = ( B69 . C4 ) & B68 = ( B70 . C4 ) & ( B69 . ( 0 ) ) = D9 & ( B70 . ( 0 ) ) = D10 & ( B71 . ( 0 ) ) = D12 & (for B72 being Nat holds (for B73 being non  empty ManySortedSign holds (for B74 being  non-empty MSAlgebra over B73 holds (for B75 being set holds ((B73 = ( B69 . B72 ) & B74 = ( B70 . B72 ) & B75 = ( B71 . B72 )) implies (( B69 . ( B72 + 1 ) ) = H8(B73 , B75 , B72) & ( B70 . ( B72 + 1 ) ) = H9(B73 , B74 , B75 , B72) & ( B71 . ( B72 + 1 ) ) = H10(B75 , B72)))))))))) from CIRCCMB2:sch 19(L12 , L13 , L14 , L15);
thus L17: thesis by L16;
end;
end;
definition
let C7 being Nat;
let C8 , C9 being FinSequence;
func C7 -BitGFA0CarryOutput (C8 , C9) -> (Element of ( InnerVertices ( C7 -BitGFA0Str (C8 , C9) ) )) means 
:L19: (ex B76 being (ManySortedSet of ( NAT )) st (it = ( B76 . C7 ) & ( B76 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ] & (for B77 being Nat holds ( B76 . ( B77 + 1 ) ) = ( GFA0CarryOutput (( C8 . ( B77 + 1 ) ) , ( C9 . ( B77 + 1 ) ) , ( B76 . B77 )) ))));
uniqueness
proof
set D13 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ];
deffunc H11(Nat , set) = ( GFA0CarryOutput (( C8 . ( $1 + 1 ) ) , ( C9 . ( $1 + 1 ) ) , $2) );
let C10 , C11 being (Element of ( InnerVertices ( C7 -BitGFA0Str (C8 , C9) ) ));
given C12 being (ManySortedSet of ( NAT )) such that
L20: C10 = ( C12 . C7 )
and
L21: ( C12 . ( 0 ) ) = D13
and
L22: (for B78 being Nat holds ( C12 . ( B78 + 1 ) ) = H11(B78 , ( C12 . B78 )));

given C13 being (ManySortedSet of ( NAT )) such that
L23: C11 = ( C13 . C7 )
and
L24: ( C13 . ( 0 ) ) = D13
and
L25: (for B79 being Nat holds ( C13 . ( B79 + 1 ) ) = H11(B79 , ( C13 . B79 )));

L26: ( dom C12 ) = ( NAT ) by PARTFUN1:def 2;
L27: ( dom C13 ) = ( NAT ) by PARTFUN1:def 2;
L28: C12 = C13 from NAT_1:sch 15(L26 , L21 , L22 , L27 , L24 , L25);
thus L29: thesis by L28 , L20 , L23;
end;
existence
proof
defpred S1[ set , set , set ] means (not contradiction);
set D14 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D15 = ( C7 -BitGFA0Str (C8 , C9) );
set D16 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ];
deffunc H12(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitGFA0Str (( C8 . ( $3 + 1 ) ) , ( C9 . ( $3 + 1 ) ) , $2) ) );
deffunc H13(set , Nat) = ( GFA0CarryOutput (( C8 . ( $2 + 1 ) ) , ( C9 . ( $2 + 1 ) ) , $1) );
consider C14 , C15 being (ManySortedSet of ( NAT )) such that L30: D15 = ( C14 . C7 ) and L31: ( C14 . ( 0 ) ) = D14 and L32: ( C15 . ( 0 ) ) = D16 and L33: (for B80 being Nat holds (for B81 being non  empty ManySortedSign holds (for B82 being set holds ((B81 = ( C14 . B80 ) & B82 = ( C15 . B80 )) implies (( C14 . ( B80 + 1 ) ) = H12(B81 , B82 , B80) & ( C15 . ( B80 + 1 ) ) = H13(B82 , B80)))))) by L2;
defpred S2[ Nat ] means (ex B83 being non  empty ManySortedSign st (B83 = ( C14 . $1 ) & ( C15 . $1 ) in ( InnerVertices B83 )));
L34: ( InnerVertices D14 ) = { D16 } by CIRCCOMB:42;
L35: D16 in ( InnerVertices D14 ) by L34 , TARSKI:def 1;
L36: S2[ ( 0 ) ] by L35 , L31 , L32;
L37: (for B84 being Nat holds (S2[ B84 ] implies S2[ ( B84 + 1 ) ]))
proof
let C16 being Nat;
assume that
L38: (ex B85 being non  empty ManySortedSign st (B85 = ( C14 . C16 ) & ( C15 . C16 ) in ( InnerVertices B85 )))
and
L39: (for B86 being non  empty ManySortedSign holds (B86 = ( C14 . ( C16 + 1 ) ) implies (not ( C15 . ( C16 + 1 ) ) in ( InnerVertices B86 ))));
consider C17 being non  empty ManySortedSign such that L40: C17 = ( C14 . C16 ) and L41: ( C15 . C16 ) in ( InnerVertices C17 ) by L38;
L42: ( GFA0CarryOutput (( C8 . ( C16 + 1 ) ) , ( C9 . ( C16 + 1 ) ) , ( C15 . C16 )) ) in ( InnerVertices ( BitGFA0Str (( C8 . ( C16 + 1 ) ) , ( C9 . ( C16 + 1 ) ) , ( C15 . C16 )) ) ) by GFACIRC1:37;
L43: ( GFA0CarryOutput (( C8 . ( C16 + 1 ) ) , ( C9 . ( C16 + 1 ) ) , ( C15 . C16 )) ) in ( InnerVertices ( C17 +* ( BitGFA0Str (( C8 . ( C16 + 1 ) ) , ( C9 . ( C16 + 1 ) ) , ( C15 . C16 )) ) ) ) by L42 , FACIRC_1:22;
L44: ( C14 . ( C16 + 1 ) ) = ( C17 +* ( BitGFA0Str (( C8 . ( C16 + 1 ) ) , ( C9 . ( C16 + 1 ) ) , ( C15 . C16 )) ) ) by L33 , L40;
L45: ( C15 . ( C16 + 1 ) ) = ( GFA0CarryOutput (( C8 . ( C16 + 1 ) ) , ( C9 . ( C16 + 1 ) ) , ( C15 . C16 )) ) by L33 , L40;
thus L46: contradiction by L45 , L39 , L43 , L44;
end;
L47: (for B87 being Nat holds S2[ B87 ]) from NAT_1:sch 2(L36 , L37);
L48: (ex B88 being non  empty ManySortedSign st (B88 = ( C14 . C7 ) & ( C15 . C7 ) in ( InnerVertices B88 ))) by L47;
reconsider D17 = ( C15 . C7 ) as (Element of ( InnerVertices D15 )) by L48 , L30;
take D17;
take C15;
thus L49: (D17 = ( C15 . C7 ) & ( C15 . ( 0 ) ) = D16) by L32;
let C18 being Nat;
L50: (ex B89 being non  empty ManySortedSign st (ex B90 being set st (B89 = ( C14 . ( 0 ) ) & B90 = ( C15 . ( 0 ) ) & S1[ B89 , B90 , ( 0 ) ]))) by L31;
L51: (for B91 being Nat holds (for B92 being non  empty ManySortedSign holds (for B93 being set holds ((B92 = ( C14 . B91 ) & B93 = ( C15 . B91 ) & S1[ B92 , B93 , B91 ]) implies S1[ H12(B92 , B93 , B91) , H13(B93 , B91) , ( B91 + 1 ) ]))));
L52: (for B94 being Nat holds (ex B95 being non  empty ManySortedSign st (B95 = ( C14 . B94 ) & S1[ B95 , ( C15 . B94 ) , B94 ]))) from CIRCCMB2:sch 2(L50 , L33 , L51);
L53: (ex B96 being non  empty ManySortedSign st B96 = ( C14 . C18 )) by L52;
thus L54: thesis by L53 , L33;
end;
end;
theorem
L56: (for B97 , B98 being FinSequence holds (for B99 , B100 , B101 being (ManySortedSet of ( NAT )) holds ((( B99 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) ) & ( B100 . ( 0 ) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) ) & ( B101 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ] & (for B102 being Nat holds (for B103 being non  empty ManySortedSign holds (for B104 being  non-empty MSAlgebra over B103 holds (for B105 being set holds ((B103 = ( B99 . B102 ) & B104 = ( B100 . B102 ) & B105 = ( B101 . B102 )) implies (( B99 . ( B102 + 1 ) ) = ( B103 +* ( BitGFA0Str (( B97 . ( B102 + 1 ) ) , ( B98 . ( B102 + 1 ) ) , B105) ) ) & ( B100 . ( B102 + 1 ) ) = ( B104 +* ( BitGFA0Circ (( B97 . ( B102 + 1 ) ) , ( B98 . ( B102 + 1 ) ) , B105) ) ) & ( B101 . ( B102 + 1 ) ) = ( GFA0CarryOutput (( B97 . ( B102 + 1 ) ) , ( B98 . ( B102 + 1 ) ) , B105) )))))))) implies (for B106 being Nat holds (( B106 -BitGFA0Str (B97 , B98) ) = ( B99 . B106 ) & ( B106 -BitGFA0Circ (B97 , B98) ) = ( B100 . B106 ) & ( B106 -BitGFA0CarryOutput (B97 , B98) ) = ( B101 . B106 ))))))
proof
let C19 , C20 being FinSequence;
let C21 , C22 , C23 being (ManySortedSet of ( NAT ));
set D18 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D19 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D20 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ];
deffunc H14(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitGFA0Str (( C19 . ( $3 + 1 ) ) , ( C20 . ( $3 + 1 ) ) , $2) ) );
deffunc H15(non  empty ManySortedSign ,  non-empty MSAlgebra over $1 , set , Nat) = ( $2 +* ( BitGFA0Circ (( C19 . ( $4 + 1 ) ) , ( C20 . ( $4 + 1 ) ) , $3) ) );
deffunc H16(set , Nat) = ( GFA0CarryOutput (( C19 . ( $2 + 1 ) ) , ( C20 . ( $2 + 1 ) ) , $1) );
deffunc H17(Nat , set) = ( GFA0CarryOutput (( C19 . ( $1 + 1 ) ) , ( C20 . ( $1 + 1 ) ) , $2) );
assume that
L57: (( C21 . ( 0 ) ) = D18 & ( C22 . ( 0 ) ) = D19)
and
L58: ( C23 . ( 0 ) ) = D20
and
L59: (for B107 being Nat holds (for B108 being non  empty ManySortedSign holds (for B109 being  non-empty MSAlgebra over B108 holds (for B110 being set holds ((B108 = ( C21 . B107 ) & B109 = ( C22 . B107 ) & B110 = ( C23 . B107 )) implies (( C21 . ( B107 + 1 ) ) = H14(B108 , B110 , B107) & ( C22 . ( B107 + 1 ) ) = H15(B108 , B109 , B110 , B107) & ( C23 . ( B107 + 1 ) ) = H16(B110 , B107)))))));
let C24 being Nat;
consider C25 , C26 , C27 being (ManySortedSet of ( NAT )) such that L60: ( C24 -BitGFA0Str (C19 , C20) ) = ( C25 . C24 ) and L61: ( C24 -BitGFA0Circ (C19 , C20) ) = ( C26 . C24 ) and L62: ( C25 . ( 0 ) ) = D18 and L63: ( C26 . ( 0 ) ) = D19 and L64: ( C27 . ( 0 ) ) = D20 and L65: (for B111 being Nat holds (for B112 being non  empty ManySortedSign holds (for B113 being  non-empty MSAlgebra over B112 holds (for B114 being set holds ((B112 = ( C25 . B111 ) & B113 = ( C26 . B111 ) & B114 = ( C27 . B111 )) implies (( C25 . ( B111 + 1 ) ) = H14(B112 , B114 , B111) & ( C26 . ( B111 + 1 ) ) = H15(B112 , B113 , B114 , B111) & ( C27 . ( B111 + 1 ) ) = H16(B114 , B111))))))) by L8;
L66: (ex B115 being non  empty ManySortedSign st (ex B116 being  non-empty MSAlgebra over B115 st (B115 = ( C21 . ( 0 ) ) & B116 = ( C22 . ( 0 ) )))) by L57;
L67: (( C21 . ( 0 ) ) = ( C25 . ( 0 ) ) & ( C22 . ( 0 ) ) = ( C26 . ( 0 ) ) & ( C23 . ( 0 ) ) = ( C27 . ( 0 ) )) by L57 , L58 , L62 , L63 , L64;
L68: (for B117 being non  empty ManySortedSign holds (for B118 being  non-empty MSAlgebra over B117 holds (for B119 being set holds (for B120 being Nat holds H15(B117 , B118 , B119 , B120) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over H14(B117 , B119 , B120)))));
L69: (C21 = C25 & C22 = C26 & C23 = C27) from CIRCCMB2:sch 14(L66 , L67 , L59 , L65 , L68);
thus L70: (( C24 -BitGFA0Str (C19 , C20) ) = ( C21 . C24 ) & ( C24 -BitGFA0Circ (C19 , C20) ) = ( C22 . C24 )) by L69 , L60 , L61;
L71: (for B121 being Nat holds (for B122 being non  empty ManySortedSign holds (for B123 being set holds ((B122 = ( C21 . B121 ) & B123 = ( C23 . B121 )) implies (( C21 . ( B121 + 1 ) ) = H14(B122 , B123 , B121) & ( C23 . ( B121 + 1 ) ) = H16(B123 , B121)))))) from CIRCCMB2:sch 15(L57 , L59 , L68);
L72: ( C21 . ( 0 ) ) = D18 by L57;
L73: (for B124 being Nat holds (for B125 being set holds (B125 = ( C23 . B124 ) implies ( C23 . ( B124 + 1 ) ) = H16(B125 , B124)))) from CIRCCMB2:sch 3(L72 , L71);
L74: ( dom C23 ) = ( NAT ) by PARTFUN1:def 2;
L75: ( C23 . ( 0 ) ) = D20 by L58;
L76: (for B126 being Nat holds ( C23 . ( B126 + 1 ) ) = H17(B126 , ( C23 . B126 ))) by L73;
consider C28 being (ManySortedSet of ( NAT )) such that L77: ( C24 -BitGFA0CarryOutput (C19 , C20) ) = ( C28 . C24 ) and L78: ( C28 . ( 0 ) ) = D20 and L79: (for B127 being Nat holds ( C28 . ( B127 + 1 ) ) = H17(B127 , ( C28 . B127 ))) by L19;
L80: ( dom C28 ) = ( NAT ) by PARTFUN1:def 2;
L81: ( C28 . ( 0 ) ) = D20 by L78;
L82: (for B128 being Nat holds ( C28 . ( B128 + 1 ) ) = H17(B128 , ( C28 . B128 ))) by L79;
L83: C23 = C28 from NAT_1:sch 15(L74 , L75 , L76 , L80 , L81 , L82);
thus L84: thesis by L83 , L77;
end;
theorem
L85: (for B129 , B130 being FinSequence holds (( ( 0 ) -BitGFA0Str (B129 , B130) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) ) & ( ( 0 ) -BitGFA0Circ (B129 , B130) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) ) & ( ( 0 ) -BitGFA0CarryOutput (B129 , B130) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ]))
proof
let C29 , C30 being FinSequence;
set D21 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D22 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D23 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ];
L86: (ex B131 , B132 , B133 being (ManySortedSet of ( NAT )) st (( ( 0 ) -BitGFA0Str (C29 , C30) ) = ( B131 . ( 0 ) ) & ( ( 0 ) -BitGFA0Circ (C29 , C30) ) = ( B132 . ( 0 ) ) & ( B131 . ( 0 ) ) = D21 & ( B132 . ( 0 ) ) = D22 & ( B133 . ( 0 ) ) = D23 & (for B134 being Nat holds (for B135 being non  empty ManySortedSign holds (for B136 being  non-empty MSAlgebra over B135 holds (for B137 being set holds ((B135 = ( B131 . B134 ) & B136 = ( B132 . B134 ) & B137 = ( B133 . B134 )) implies (( B131 . ( B134 + 1 ) ) = ( B135 +* ( BitGFA0Str (( C29 . ( B134 + 1 ) ) , ( C30 . ( B134 + 1 ) ) , B137) ) ) & ( B132 . ( B134 + 1 ) ) = ( B136 +* ( BitGFA0Circ (( C29 . ( B134 + 1 ) ) , ( C30 . ( B134 + 1 ) ) , B137) ) ) & ( B133 . ( B134 + 1 ) ) = ( GFA0CarryOutput (( C29 . ( B134 + 1 ) ) , ( C30 . ( B134 + 1 ) ) , B137) ))))))))) by L8;
thus L87: ( ( 0 ) -BitGFA0Str (C29 , C30) ) = D21 by L86;
thus L88: ( ( 0 ) -BitGFA0Circ (C29 , C30) ) = D22 by L86;
L89: ( InnerVertices ( ( 0 ) -BitGFA0Str (C29 , C30) ) ) = { D23 } by L86 , CIRCCOMB:42;
thus L90: thesis by L89 , TARSKI:def 1;
end;
theorem
L91: (for B138 , B139 being FinSequence holds (for B140 being set holds (B140 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ] implies (( 1 -BitGFA0Str (B138 , B139) ) = ( ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) ) +* ( BitGFA0Str (( B138 . 1 ) , ( B139 . 1 ) , B140) ) ) & ( 1 -BitGFA0Circ (B138 , B139) ) = ( ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) ) +* ( BitGFA0Circ (( B138 . 1 ) , ( B139 . 1 ) , B140) ) ) & ( 1 -BitGFA0CarryOutput (B138 , B139) ) = ( GFA0CarryOutput (( B138 . 1 ) , ( B139 . 1 ) , B140) )))))
proof
set D24 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D25 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D26 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ];
let C31 , C32 being FinSequence;
let C33 being set;
assume that
L92: C33 = D26;
consider C34 , C35 , C36 being (ManySortedSet of ( NAT )) such that L93: ( 1 -BitGFA0Str (C31 , C32) ) = ( C34 . 1 ) and L94: ( 1 -BitGFA0Circ (C31 , C32) ) = ( C35 . 1 ) and L95: ( C34 . ( 0 ) ) = D24 and L96: ( C35 . ( 0 ) ) = D25 and L97: ( C36 . ( 0 ) ) = C33 and L98: (for B141 being Nat holds (for B142 being non  empty ManySortedSign holds (for B143 being  non-empty MSAlgebra over B142 holds (for B144 being set holds ((B142 = ( C34 . B141 ) & B143 = ( C35 . B141 ) & B144 = ( C36 . B141 )) implies (( C34 . ( B141 + 1 ) ) = ( B142 +* ( BitGFA0Str (( C31 . ( B141 + 1 ) ) , ( C32 . ( B141 + 1 ) ) , B144) ) ) & ( C35 . ( B141 + 1 ) ) = ( B143 +* ( BitGFA0Circ (( C31 . ( B141 + 1 ) ) , ( C32 . ( B141 + 1 ) ) , B144) ) ) & ( C36 . ( B141 + 1 ) ) = ( GFA0CarryOutput (( C31 . ( B141 + 1 ) ) , ( C32 . ( B141 + 1 ) ) , B144) ))))))) by L92 , L8;
L99: ( 1 -BitGFA0CarryOutput (C31 , C32) ) = ( C36 . ( ( 0 ) + 1 ) ) by L92 , L95 , L96 , L97 , L98 , L56;
thus L100: thesis by L99 , L93 , L94 , L95 , L96 , L97 , L98;
end;
theorem
L101: (for B145 , B146 , B147 being set holds (B147 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ] implies (( 1 -BitGFA0Str (<* B145 *> , <* B146 *>) ) = ( ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) ) +* ( BitGFA0Str (B145 , B146 , B147) ) ) & ( 1 -BitGFA0Circ (<* B145 *> , <* B146 *>) ) = ( ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) ) +* ( BitGFA0Circ (B145 , B146 , B147) ) ) & ( 1 -BitGFA0CarryOutput (<* B145 *> , <* B146 *>) ) = ( GFA0CarryOutput (B145 , B146 , B147) ))))
proof
let C37 , C38 being set;
L102: ( <* C37 *> . 1 ) = C37 by FINSEQ_1:40;
L103: ( <* C38 *> . 1 ) = C38 by FINSEQ_1:40;
thus L104: thesis by L103 , L102 , L91;
end;
theorem
L105: (for B148 being Nat holds (for B149 , B150 being (FinSeqLen of B148) holds (for B151 , B152 , B153 , B154 being FinSequence holds (( B148 -BitGFA0Str (( B149 ^ B151 ) , ( B150 ^ B153 )) ) = ( B148 -BitGFA0Str (( B149 ^ B152 ) , ( B150 ^ B154 )) ) & ( B148 -BitGFA0Circ (( B149 ^ B151 ) , ( B150 ^ B153 )) ) = ( B148 -BitGFA0Circ (( B149 ^ B152 ) , ( B150 ^ B154 )) ) & ( B148 -BitGFA0CarryOutput (( B149 ^ B151 ) , ( B150 ^ B153 )) ) = ( B148 -BitGFA0CarryOutput (( B149 ^ B152 ) , ( B150 ^ B154 )) )))))
proof
let C39 being Nat;
let C40 , C41 being (FinSeqLen of C39);
let C42 , C43 , C44 , C45 being FinSequence;
set D27 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D28 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D29 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ];
set D30 = ( C39 -BitGFA0Str (( C40 ^ C42 ) , ( C41 ^ C44 )) );
set D31 = ( C39 -BitGFA0Circ (( C40 ^ C42 ) , ( C41 ^ C44 )) );
set D32 = ( C39 -BitGFA0CarryOutput (( C40 ^ C42 ) , ( C41 ^ C44 )) );
deffunc H18(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitGFA0Str (( ( C40 ^ C42 ) . ( $3 + 1 ) ) , ( ( C41 ^ C44 ) . ( $3 + 1 ) ) , $2) ) );
deffunc H19(non  empty ManySortedSign ,  non-empty MSAlgebra over $1 , set , Nat) = ( $2 +* ( BitGFA0Circ (( ( C40 ^ C42 ) . ( $4 + 1 ) ) , ( ( C41 ^ C44 ) . ( $4 + 1 ) ) , $3) ) );
deffunc H20(set , Nat) = ( GFA0CarryOutput (( ( C40 ^ C42 ) . ( $2 + 1 ) ) , ( ( C41 ^ C44 ) . ( $2 + 1 ) ) , $1) );
consider C46 , C47 , C48 being (ManySortedSet of ( NAT )) such that L106: D30 = ( C46 . C39 ) and L107: D31 = ( C47 . C39 ) and L108: ( C46 . ( 0 ) ) = D27 and L109: ( C47 . ( 0 ) ) = D28 and L110: ( C48 . ( 0 ) ) = D29 and L111: (for B155 being Nat holds (for B156 being non  empty ManySortedSign holds (for B157 being  non-empty MSAlgebra over B156 holds (for B158 being set holds ((B156 = ( C46 . B155 ) & B157 = ( C47 . B155 ) & B158 = ( C48 . B155 )) implies (( C46 . ( B155 + 1 ) ) = H18(B156 , B158 , B155) & ( C47 . ( B155 + 1 ) ) = H19(B156 , B157 , B158 , B155) & ( C48 . ( B155 + 1 ) ) = H20(B158 , B155))))))) by L8;
set D33 = ( C39 -BitGFA0Str (( C40 ^ C43 ) , ( C41 ^ C45 )) );
set D34 = ( C39 -BitGFA0Circ (( C40 ^ C43 ) , ( C41 ^ C45 )) );
set D35 = ( C39 -BitGFA0CarryOutput (( C40 ^ C43 ) , ( C41 ^ C45 )) );
deffunc H21(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitGFA0Str (( ( C40 ^ C43 ) . ( $3 + 1 ) ) , ( ( C41 ^ C45 ) . ( $3 + 1 ) ) , $2) ) );
deffunc H22(non  empty ManySortedSign ,  non-empty MSAlgebra over $1 , set , Nat) = ( $2 +* ( BitGFA0Circ (( ( C40 ^ C43 ) . ( $4 + 1 ) ) , ( ( C41 ^ C45 ) . ( $4 + 1 ) ) , $3) ) );
deffunc H23(set , Nat) = ( GFA0CarryOutput (( ( C40 ^ C43 ) . ( $2 + 1 ) ) , ( ( C41 ^ C45 ) . ( $2 + 1 ) ) , $1) );
consider C49 , C50 , C51 being (ManySortedSet of ( NAT )) such that L112: D33 = ( C49 . C39 ) and L113: D34 = ( C50 . C39 ) and L114: ( C49 . ( 0 ) ) = D27 and L115: ( C50 . ( 0 ) ) = D28 and L116: ( C51 . ( 0 ) ) = D29 and L117: (for B159 being Nat holds (for B160 being non  empty ManySortedSign holds (for B161 being  non-empty MSAlgebra over B160 holds (for B162 being set holds ((B160 = ( C49 . B159 ) & B161 = ( C50 . B159 ) & B162 = ( C51 . B159 )) implies (( C49 . ( B159 + 1 ) ) = H21(B160 , B162 , B159) & ( C50 . ( B159 + 1 ) ) = H22(B160 , B161 , B162 , B159) & ( C51 . ( B159 + 1 ) ) = H23(B162 , B159))))))) by L8;
defpred S3[ Nat ] means ($1 <= C39 implies (( C48 . $1 ) = ( C51 . $1 ) & ( C46 . $1 ) = ( C49 . $1 ) & ( C47 . $1 ) = ( C50 . $1 )));
L118: S3[ ( 0 ) ] by L108 , L109 , L110 , L114 , L115 , L116;
L119: (for B163 being Nat holds (S3[ B163 ] implies S3[ ( B163 + 1 ) ]))
proof
let C52 being Nat;
assume that
L120: (C52 <= C39 implies (( C48 . C52 ) = ( C51 . C52 ) & ( C46 . C52 ) = ( C49 . C52 ) & ( C47 . C52 ) = ( C50 . C52 )))
and
L121: ( C52 + 1 ) <= C39;
L122: ( len C40 ) = C39 by CARD_1:def 7;
L123: ( len C41 ) = C39 by CARD_1:def 7;
L124: ( dom C40 ) = ( Seg C39 ) by L122 , FINSEQ_1:def 3;
L125: ( dom C41 ) = ( Seg C39 ) by L123 , FINSEQ_1:def 3;
L126: ( ( 0 ) + 1 ) <= ( C52 + 1 ) by XREAL_1:6;
L127: ( C52 + 1 ) in ( Seg C39 ) by L126 , L121 , FINSEQ_1:1;
L128: ( ( C40 ^ C42 ) . ( C52 + 1 ) ) = ( C40 . ( C52 + 1 ) ) by L127 , L124 , FINSEQ_1:def 7;
L129: ( ( C40 ^ C43 ) . ( C52 + 1 ) ) = ( C40 . ( C52 + 1 ) ) by L124 , L127 , FINSEQ_1:def 7;
L130: ( ( C41 ^ C44 ) . ( C52 + 1 ) ) = ( C41 . ( C52 + 1 ) ) by L125 , L127 , FINSEQ_1:def 7;
L131: ( ( C41 ^ C45 ) . ( C52 + 1 ) ) = ( C41 . ( C52 + 1 ) ) by L125 , L127 , FINSEQ_1:def 7;
defpred S4[ set , set , set , set ] means (not contradiction);
L132: (ex B164 being non  empty ManySortedSign st (ex B165 being  non-empty MSAlgebra over B164 st (ex B166 being set st (B164 = ( C46 . ( 0 ) ) & B165 = ( C47 . ( 0 ) ) & B166 = ( C48 . ( 0 ) ) & S4[ B164 , B165 , B166 , ( 0 ) ])))) by L108 , L109;
L133: (for B167 being Nat holds (for B168 being non  empty ManySortedSign holds (for B169 being  non-empty MSAlgebra over B168 holds (for B170 being set holds ((B168 = ( C46 . B167 ) & B169 = ( C47 . B167 ) & B170 = ( C48 . B167 ) & S4[ B168 , B169 , B170 , B167 ]) implies S4[ H18(B168 , B170 , B167) , H19(B168 , B169 , B170 , B167) , H20(B170 , B167) , ( B167 + 1 ) ])))));
L134: (for B171 being non  empty ManySortedSign holds (for B172 being  non-empty MSAlgebra over B171 holds (for B173 being set holds (for B174 being Nat holds H19(B171 , B172 , B173 , B174) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over H18(B171 , B173 , B174)))));
L135: (for B175 being Nat holds (ex B176 being non  empty ManySortedSign st (ex B177 being  non-empty MSAlgebra over B176 st (B176 = ( C46 . B175 ) & B177 = ( C47 . B175 ) & S4[ B176 , B177 , ( C48 . B175 ) , B175 ])))) from CIRCCMB2:sch 13(L132 , L111 , L133 , L134);
consider C53 being non  empty ManySortedSign, C54 being  non-empty MSAlgebra over C53 such that L136: C53 = ( C46 . C52 ) and L137: C54 = ( C47 . C52 ) by L135;
thus L138: ( C48 . ( C52 + 1 ) ) = H23(( C51 . C52 ) , C52) by L111 , L120 , L121 , L128 , L129 , L130 , L131 , L136 , L137 , NAT_1:13
.= ( C51 . ( C52 + 1 ) ) by L117 , L120 , L121 , L136 , L137 , NAT_1:13;
thus L139: ( C46 . ( C52 + 1 ) ) = H21(C53 , ( C51 . C52 ) , C52) by L111 , L120 , L121 , L128 , L129 , L130 , L131 , L136 , L137 , NAT_1:13
.= ( C49 . ( C52 + 1 ) ) by L117 , L120 , L121 , L136 , L137 , NAT_1:13;
thus L140: ( C47 . ( C52 + 1 ) ) = H22(C53 , C54 , ( C51 . C52 ) , C52) by L111 , L120 , L121 , L128 , L129 , L130 , L131 , L136 , L137 , NAT_1:13
.= ( C50 . ( C52 + 1 ) ) by L117 , L120 , L121 , L136 , L137 , NAT_1:13;
end;
L141: (for B178 being Nat holds S3[ B178 ]) from NAT_1:sch 2(L118 , L119);
thus L142: (D30 = D33 & D31 = D34) by L141 , L106 , L107 , L112 , L113;
L143: D32 = ( C48 . C39 ) by L108 , L109 , L110 , L111 , L56;
L144: D35 = ( C51 . C39 ) by L114 , L115 , L116 , L117 , L56;
thus L145: thesis by L144 , L141 , L143;
end;
theorem
L146: (for B179 being Nat holds (for B180 , B181 being (FinSeqLen of B179) holds (for B182 , B183 being set holds (( ( B179 + 1 ) -BitGFA0Str (( B180 ^ <* B182 *> ) , ( B181 ^ <* B183 *> )) ) = ( ( B179 -BitGFA0Str (B180 , B181) ) +* ( BitGFA0Str (B182 , B183 , ( B179 -BitGFA0CarryOutput (B180 , B181) )) ) ) & ( ( B179 + 1 ) -BitGFA0Circ (( B180 ^ <* B182 *> ) , ( B181 ^ <* B183 *> )) ) = ( ( B179 -BitGFA0Circ (B180 , B181) ) +* ( BitGFA0Circ (B182 , B183 , ( B179 -BitGFA0CarryOutput (B180 , B181) )) ) ) & ( ( B179 + 1 ) -BitGFA0CarryOutput (( B180 ^ <* B182 *> ) , ( B181 ^ <* B183 *> )) ) = ( GFA0CarryOutput (B182 , B183 , ( B179 -BitGFA0CarryOutput (B180 , B181) )) )))))
proof
set D36 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D37 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D38 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ];
let C55 being Nat;
let C56 , C57 being (FinSeqLen of C55);
let C58 , C59 being set;
set D39 = ( C56 ^ <* C58 *> );
set D40 = ( C57 ^ <* C59 *> );
consider C60 , C61 , C62 being (ManySortedSet of ( NAT )) such that L147: ( C55 -BitGFA0Str (D39 , D40) ) = ( C60 . C55 ) and L148: ( C55 -BitGFA0Circ (D39 , D40) ) = ( C61 . C55 ) and L149: ( C60 . ( 0 ) ) = D36 and L150: ( C61 . ( 0 ) ) = D37 and L151: ( C62 . ( 0 ) ) = D38 and L152: (for B184 being Nat holds (for B185 being non  empty ManySortedSign holds (for B186 being  non-empty MSAlgebra over B185 holds (for B187 being set holds ((B185 = ( C60 . B184 ) & B186 = ( C61 . B184 ) & B187 = ( C62 . B184 )) implies (( C60 . ( B184 + 1 ) ) = ( B185 +* ( BitGFA0Str (( D39 . ( B184 + 1 ) ) , ( D40 . ( B184 + 1 ) ) , B187) ) ) & ( C61 . ( B184 + 1 ) ) = ( B186 +* ( BitGFA0Circ (( D39 . ( B184 + 1 ) ) , ( D40 . ( B184 + 1 ) ) , B187) ) ) & ( C62 . ( B184 + 1 ) ) = ( GFA0CarryOutput (( D39 . ( B184 + 1 ) ) , ( D40 . ( B184 + 1 ) ) , B187) ))))))) by L8;
L153: ( C55 -BitGFA0CarryOutput (( C56 ^ <* C58 *> ) , ( C57 ^ <* C59 *> )) ) = ( C62 . C55 ) by L149 , L150 , L151 , L152 , L56;
L154: ( ( C55 + 1 ) -BitGFA0Str (( C56 ^ <* C58 *> ) , ( C57 ^ <* C59 *> )) ) = ( C60 . ( C55 + 1 ) ) by L149 , L150 , L151 , L152 , L56;
L155: ( ( C55 + 1 ) -BitGFA0Circ (( C56 ^ <* C58 *> ) , ( C57 ^ <* C59 *> )) ) = ( C61 . ( C55 + 1 ) ) by L149 , L150 , L151 , L152 , L56;
L156: ( ( C55 + 1 ) -BitGFA0CarryOutput (( C56 ^ <* C58 *> ) , ( C57 ^ <* C59 *> )) ) = ( C62 . ( C55 + 1 ) ) by L149 , L150 , L151 , L152 , L56;
L157: ( len C56 ) = C55 by CARD_1:def 7;
L158: ( len C57 ) = C55 by CARD_1:def 7;
L159: ( D39 . ( C55 + 1 ) ) = C58 by L157 , FINSEQ_1:42;
L160: ( D40 . ( C55 + 1 ) ) = C59 by L158 , FINSEQ_1:42;
L161: ( C56 ^ ( <*> ) ) = C56 by FINSEQ_1:34;
L162: ( C57 ^ ( <*> ) ) = C57 by FINSEQ_1:34;
L163: ( C55 -BitGFA0Str (D39 , D40) ) = ( C55 -BitGFA0Str (C56 , C57) ) by L162 , L161 , L105;
L164: ( C55 -BitGFA0Circ (D39 , D40) ) = ( C55 -BitGFA0Circ (C56 , C57) ) by L161 , L162 , L105;
L165: ( C55 -BitGFA0CarryOutput (D39 , D40) ) = ( C55 -BitGFA0CarryOutput (C56 , C57) ) by L161 , L162 , L105;
thus L166: thesis by L165 , L147 , L148 , L152 , L153 , L154 , L155 , L156 , L159 , L160 , L163 , L164;
end;
theorem
L167: (for B188 being Nat holds (for B189 , B190 being FinSequence holds (( ( B188 + 1 ) -BitGFA0Str (B189 , B190) ) = ( ( B188 -BitGFA0Str (B189 , B190) ) +* ( BitGFA0Str (( B189 . ( B188 + 1 ) ) , ( B190 . ( B188 + 1 ) ) , ( B188 -BitGFA0CarryOutput (B189 , B190) )) ) ) & ( ( B188 + 1 ) -BitGFA0Circ (B189 , B190) ) = ( ( B188 -BitGFA0Circ (B189 , B190) ) +* ( BitGFA0Circ (( B189 . ( B188 + 1 ) ) , ( B190 . ( B188 + 1 ) ) , ( B188 -BitGFA0CarryOutput (B189 , B190) )) ) ) & ( ( B188 + 1 ) -BitGFA0CarryOutput (B189 , B190) ) = ( GFA0CarryOutput (( B189 . ( B188 + 1 ) ) , ( B190 . ( B188 + 1 ) ) , ( B188 -BitGFA0CarryOutput (B189 , B190) )) ))))
proof
set D41 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D42 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D43 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ];
let C63 being Nat;
let C64 , C65 being FinSequence;
consider C66 , C67 , C68 being (ManySortedSet of ( NAT )) such that L168: ( C63 -BitGFA0Str (C64 , C65) ) = ( C66 . C63 ) and L169: ( C63 -BitGFA0Circ (C64 , C65) ) = ( C67 . C63 ) and L170: ( C66 . ( 0 ) ) = D41 and L171: ( C67 . ( 0 ) ) = D42 and L172: ( C68 . ( 0 ) ) = D43 and L173: (for B191 being Nat holds (for B192 being non  empty ManySortedSign holds (for B193 being  non-empty MSAlgebra over B192 holds (for B194 being set holds ((B192 = ( C66 . B191 ) & B193 = ( C67 . B191 ) & B194 = ( C68 . B191 )) implies (( C66 . ( B191 + 1 ) ) = ( B192 +* ( BitGFA0Str (( C64 . ( B191 + 1 ) ) , ( C65 . ( B191 + 1 ) ) , B194) ) ) & ( C67 . ( B191 + 1 ) ) = ( B193 +* ( BitGFA0Circ (( C64 . ( B191 + 1 ) ) , ( C65 . ( B191 + 1 ) ) , B194) ) ) & ( C68 . ( B191 + 1 ) ) = ( GFA0CarryOutput (( C64 . ( B191 + 1 ) ) , ( C65 . ( B191 + 1 ) ) , B194) ))))))) by L8;
L174: ( C63 -BitGFA0CarryOutput (C64 , C65) ) = ( C68 . C63 ) by L170 , L171 , L172 , L173 , L56;
L175: ( ( C63 + 1 ) -BitGFA0Str (C64 , C65) ) = ( C66 . ( C63 + 1 ) ) by L170 , L171 , L172 , L173 , L56;
L176: ( ( C63 + 1 ) -BitGFA0Circ (C64 , C65) ) = ( C67 . ( C63 + 1 ) ) by L170 , L171 , L172 , L173 , L56;
L177: ( ( C63 + 1 ) -BitGFA0CarryOutput (C64 , C65) ) = ( C68 . ( C63 + 1 ) ) by L170 , L171 , L172 , L173 , L56;
thus L178: thesis by L177 , L168 , L169 , L173 , L174 , L175 , L176;
end;
theorem
L179: (for B195 , B196 being Nat holds (B195 <= B196 implies (for B197 , B198 being FinSequence holds ( InnerVertices ( B195 -BitGFA0Str (B197 , B198) ) ) c= ( InnerVertices ( B196 -BitGFA0Str (B197 , B198) ) ))))
proof
let C69 , C70 being Nat;
assume that
L180: C69 <= C70;
let C71 , C72 being FinSequence;
consider C73 being Nat such that L181: C70 = ( C69 + C73 ) by L180 , NAT_1:10;
defpred S5[ Nat ] means ( InnerVertices ( C69 -BitGFA0Str (C71 , C72) ) ) c= ( InnerVertices ( ( C69 + $1 ) -BitGFA0Str (C71 , C72) ) );
L182: S5[ ( 0 ) ];
L183: (for B199 being Nat holds (S5[ B199 ] implies S5[ ( B199 + 1 ) ]))
proof
let C74 being Nat;
set D44 = ( C69 -BitGFA0Str (C71 , C72) );
set D45 = ( ( C69 + C74 ) -BitGFA0Str (C71 , C72) );
set D46 = ( BitGFA0Str (( C71 . ( ( C69 + C74 ) + 1 ) ) , ( C72 . ( ( C69 + C74 ) + 1 ) ) , ( ( C69 + C74 ) -BitGFA0CarryOutput (C71 , C72) )) );
assume L184: ( InnerVertices D44 ) c= ( InnerVertices D45 );
L185: ( InnerVertices D44 ) c= ( ( InnerVertices D44 ) \/ ( InnerVertices D46 ) ) by XBOOLE_1:7;
L186: ( ( InnerVertices D44 ) \/ ( InnerVertices D46 ) ) c= ( ( InnerVertices D45 ) \/ ( InnerVertices D46 ) ) by L184 , XBOOLE_1:9;
L187: ( InnerVertices D44 ) c= ( ( InnerVertices D45 ) \/ ( InnerVertices D46 ) ) by L186 , L185 , XBOOLE_1:1;
L188: ( InnerVertices D44 ) c= ( InnerVertices ( D45 +* D46 ) ) by L187 , FACIRC_1:27;
thus L189: thesis by L188 , L167;
end;
L190: (for B200 being Nat holds S5[ B200 ]) from NAT_1:sch 2(L182 , L183);
thus L191: thesis by L190 , L181;
end;
theorem
L192: (for B201 being Nat holds (for B202 , B203 being FinSequence holds ( InnerVertices ( ( B201 + 1 ) -BitGFA0Str (B202 , B203) ) ) = ( ( InnerVertices ( B201 -BitGFA0Str (B202 , B203) ) ) \/ ( InnerVertices ( BitGFA0Str (( B202 . ( B201 + 1 ) ) , ( B203 . ( B201 + 1 ) ) , ( B201 -BitGFA0CarryOutput (B202 , B203) )) ) ) )))
proof
let C75 being Nat;
let C76 , C77 being FinSequence;
set D47 = ( C75 -BitGFA0Str (C76 , C77) );
set D48 = ( BitGFA0Str (( C76 . ( C75 + 1 ) ) , ( C77 . ( C75 + 1 ) ) , ( C75 -BitGFA0CarryOutput (C76 , C77) )) );
L193: ( InnerVertices ( D47 +* D48 ) ) = ( ( InnerVertices D47 ) \/ ( InnerVertices D48 ) ) by FACIRC_1:27;
thus L194: thesis by L193 , L167;
end;
definition
let C78 , C79 being Nat;
assume that
L195: C78 >= 1
and
L196: C78 <= C79;
let C80 , C81 being FinSequence;
func (C78 , C79) -BitGFA0AdderOutput (C80 , C81) -> (Element of ( InnerVertices ( C79 -BitGFA0Str (C80 , C81) ) )) means 
:L197: (ex B204 being Nat st (C78 = ( B204 + 1 ) & it = ( GFA0AdderOutput (( C80 . C78 ) , ( C81 . C78 ) , ( B204 -BitGFA0CarryOutput (C80 , C81) )) )));
uniqueness;
existence
proof
consider C82 being Nat such that L198: C78 = ( 1 + C82 ) by L195 , NAT_1:10;
reconsider D49 = C82 as Nat;
deffunc H24(Nat) = ( $1 -BitGFA0Str (C80 , C81) );
deffunc H25(Nat) = ( BitGFA0Str (( C80 . ( $1 + 1 ) ) , ( C81 . ( $1 + 1 ) ) , ( $1 -BitGFA0CarryOutput (C80 , C81) )) );
set D50 = ( GFA0AdderOutput (( C80 . C78 ) , ( C81 . C78 ) , ( D49 -BitGFA0CarryOutput (C80 , C81) )) );
L199: ( InnerVertices H24(C78) ) c= ( InnerVertices H24(C79) ) by L196 , L179;
L200: D50 in ( InnerVertices H25(D49) ) by L198 , GFACIRC1:37;
L201: H24(C78) = ( H24(D49) +* H25(D49) ) by L198 , L167;
reconsider D51 = D50 as (Element of H25(D49)) by L200;
L202: (the carrier of H24(C78)) = ( (the carrier of H25(D49)) \/ (the carrier of H24(D49)) ) by L201 , CIRCCOMB:def 2;
L203: D51 in (the carrier of H24(C78)) by L202 , XBOOLE_0:def 3;
L204: D51 in ( InnerVertices H24(C78) ) by L203 , L200 , L201 , CIRCCOMB:15;
thus L205: thesis by L204 , L198 , L199;
end;
end;
theorem
L207: (for B205 , B206 being Nat holds (B206 < B205 implies (for B207 , B208 being FinSequence holds ( (( B206 + 1 ) , B205) -BitGFA0AdderOutput (B207 , B208) ) = ( GFA0AdderOutput (( B207 . ( B206 + 1 ) ) , ( B208 . ( B206 + 1 ) ) , ( B206 -BitGFA0CarryOutput (B207 , B208) )) ))))
proof
let C83 , C84 being Nat;
assume that
L208: C84 < C83;
let C85 , C86 being FinSequence;
L209: ( C84 + 1 ) >= 1 by NAT_1:11;
L210: ( C84 + 1 ) <= C83 by L208 , NAT_1:13;
L211: (ex B209 being Nat st (( C84 + 1 ) = ( B209 + 1 ) & ( (( C84 + 1 ) , C83) -BitGFA0AdderOutput (C85 , C86) ) = ( GFA0AdderOutput (( C85 . ( C84 + 1 ) ) , ( C86 . ( C84 + 1 ) ) , ( B209 -BitGFA0CarryOutput (C85 , C86) )) ))) by L210 , L209 , L197;
thus L212: thesis by L211;
end;
theorem
L213: (for B210 being Nat holds (for B211 , B212 being FinSequence holds ( InnerVertices ( B210 -BitGFA0Str (B211 , B212) ) ) is Relation))
proof
let C87 being Nat;
let C88 , C89 being FinSequence;
set D52 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
deffunc H26(Nat) = ( $1 -BitGFA0Str (C88 , C89) );
deffunc H27(Nat) = ( BitGFA0Str (( C88 . ( $1 + 1 ) ) , ( C89 . ( $1 + 1 ) ) , ( $1 -BitGFA0CarryOutput (C88 , C89) )) );
defpred S6[ Nat ] means ( InnerVertices H26($1) ) is Relation;
L214: H26(( 0 )) = D52 by L85;
L215: S6[ ( 0 ) ] by L214 , FACIRC_1:38;
L216:
now
let C90 being Nat;
assume L217: S6[ C90 ];
L218: H26(( C90 + 1 )) = ( H26(C90) +* H27(C90) ) by L167;
L219: ( InnerVertices H27(C90) ) is Relation by GFACIRC1:32;
thus L220: S6[ ( C90 + 1 ) ] by L219 , L217 , L218 , FACIRC_1:3;
end;
L221: (for B213 being Nat holds S6[ B213 ]) from NAT_1:sch 2(L215 , L216);
thus L222: thesis by L221;
end;
registration
let C91 being Nat;
let C92 , C93 being FinSequence;
cluster ( C91 -BitGFA0CarryOutput (C92 , C93) ) ->  pair;
coherence
proof
set D53 = ( and2 );
set D54 = ( and2 );
set D55 = ( and2 );
set D56 = ( or3 );
set D57 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ];
deffunc H28(Nat) = ( $1 -BitGFA0CarryOutput (C92 , C93) );
L223: (ex B214 being (ManySortedSet of ( NAT )) st (H28(( 0 )) = ( B214 . ( 0 ) ) & ( B214 . ( 0 ) ) = D57 & (for B215 being Nat holds ( B214 . ( B215 + 1 ) ) = ( GFA0CarryOutput (( C92 . ( B215 + 1 ) ) , ( C93 . ( B215 + 1 ) ) , ( B214 . B215 )) )))) by L19;
defpred S7[ Nat ] means ( $1 -BitGFA0CarryOutput (C92 , C93) ) is  pair;
L224: S7[ ( 0 ) ] by L223;
L225: (for B216 being Nat holds (S7[ B216 ] implies S7[ ( B216 + 1 ) ]))
proof
let C94 being Nat;
set D58 = ( C94 -BitGFA0CarryOutput (C92 , C93) );
L226: H28(( C94 + 1 )) = ( GFA0CarryOutput (( C92 . ( C94 + 1 ) ) , ( C93 . ( C94 + 1 ) ) , D58) ) by L167
.= [ <* [ <* ( C92 . ( C94 + 1 ) ) , ( C93 . ( C94 + 1 ) ) *> , D53 ] , [ <* ( C93 . ( C94 + 1 ) ) , D58 *> , D54 ] , [ <* D58 , ( C92 . ( C94 + 1 ) ) *> , D55 ] *> , D56 ];
thus L227: thesis by L226;
end;
L228: (for B217 being Nat holds S7[ B217 ]) from NAT_1:sch 2(L224 , L225);
thus L229: thesis by L228;
end;
end;
L231: (for B218 , B219 being FinSequence holds (for B220 being Nat holds ((( ( B220 -BitGFA0CarryOutput (B218 , B219) ) `1 ) = ( <*> ) & ( ( B220 -BitGFA0CarryOutput (B218 , B219) ) `2 ) = ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) & ( proj1 ( ( B220 -BitGFA0CarryOutput (B218 , B219) ) `2 ) ) = ( ( 0 ) -tuples_on ( BOOLEAN ) )) or (( card ( ( B220 -BitGFA0CarryOutput (B218 , B219) ) `1 ) ) = 3 & ( ( B220 -BitGFA0CarryOutput (B218 , B219) ) `2 ) = ( or3 ) & ( proj1 ( ( B220 -BitGFA0CarryOutput (B218 , B219) ) `2 ) ) = ( 3 -tuples_on ( BOOLEAN ) )))))
proof
set D59 = ( and2 );
set D60 = ( and2 );
set D61 = ( and2 );
set D62 = ( or3 );
let C95 , C96 being FinSequence;
defpred S8[ Nat ] means ((( ( $1 -BitGFA0CarryOutput (C95 , C96) ) `1 ) = ( <*> ) & ( ( $1 -BitGFA0CarryOutput (C95 , C96) ) `2 ) = ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) & ( proj1 ( ( $1 -BitGFA0CarryOutput (C95 , C96) ) `2 ) ) = ( ( 0 ) -tuples_on ( BOOLEAN ) )) or (( card ( ( $1 -BitGFA0CarryOutput (C95 , C96) ) `1 ) ) = 3 & ( ( $1 -BitGFA0CarryOutput (C95 , C96) ) `2 ) = D62 & ( proj1 ( ( $1 -BitGFA0CarryOutput (C95 , C96) ) `2 ) ) = ( 3 -tuples_on ( BOOLEAN ) )));
L232: ( dom ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ) = ( ( 0 ) -tuples_on ( BOOLEAN ) ) by FUNCOP_1:13;
L233: ( ( 0 ) -BitGFA0CarryOutput (C95 , C96) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ] by L85;
L234: S8[ ( 0 ) ] by L233 , L232 , MCART_1:7;
L235:
now
let C97 being Nat;
assume L236: S8[ C97 ];
set D63 = ( C97 -BitGFA0CarryOutput (C95 , C96) );
L237: ( ( C97 + 1 ) -BitGFA0CarryOutput (C95 , C96) ) = ( GFA0CarryOutput (( C95 . ( C97 + 1 ) ) , ( C96 . ( C97 + 1 ) ) , D63) ) by L167
.= [ <* [ <* ( C95 . ( C97 + 1 ) ) , ( C96 . ( C97 + 1 ) ) *> , D59 ] , [ <* ( C96 . ( C97 + 1 ) ) , D63 *> , D60 ] , [ <* D63 , ( C95 . ( C97 + 1 ) ) *> , D61 ] *> , D62 ];
L238: ( dom D62 ) = ( 3 -tuples_on ( BOOLEAN ) ) by FUNCT_2:def 1;
L239: ( ( ( C97 + 1 ) -BitGFA0CarryOutput (C95 , C96) ) `1 ) = <* [ <* ( C95 . ( C97 + 1 ) ) , ( C96 . ( C97 + 1 ) ) *> , D59 ] , [ <* ( C96 . ( C97 + 1 ) ) , D63 *> , D60 ] , [ <* D63 , ( C95 . ( C97 + 1 ) ) *> , D61 ] *> by L237 , MCART_1:7;
thus L240: S8[ ( C97 + 1 ) ] by L239 , L237 , L238 , FINSEQ_1:45 , MCART_1:7;
end;
thus L241: (for B221 being Nat holds S8[ B221 ]) from NAT_1:sch 2(L234 , L235);
end;
L242: (for B222 being Nat holds (for B223 , B224 being FinSequence holds (for B225 being set holds (for B226 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds ( B222 -BitGFA0CarryOutput (B223 , B224) ) <> [ B225 , B226 ]))))
proof
let C98 being Nat;
let C99 , C100 being FinSequence;
let C101 being set;
let C102 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
L243: ( dom C102 ) = ( 2 -tuples_on ( BOOLEAN ) ) by FUNCT_2:def 1;
L244: ( proj1 ( [ C101 , C102 ] `2 ) ) = ( 2 -tuples_on ( BOOLEAN ) ) by L243;
L245: (( proj1 ( ( C98 -BitGFA0CarryOutput (C99 , C100) ) `2 ) ) = ( ( 0 ) -tuples_on ( BOOLEAN ) ) or ( proj1 ( ( C98 -BitGFA0CarryOutput (C99 , C100) ) `2 ) ) = ( 3 -tuples_on ( BOOLEAN ) )) by L231;
thus L246: thesis by L245 , L244 , FINSEQ_2:110;
end;
theorem
L247: (for B227 , B228 being  nonpair-yielding FinSequence holds (for B229 being Nat holds (( InputVertices ( ( B229 + 1 ) -BitGFA0Str (B227 , B228) ) ) = ( ( InputVertices ( B229 -BitGFA0Str (B227 , B228) ) ) \/ ( ( InputVertices ( BitGFA0Str (( B227 . ( B229 + 1 ) ) , ( B228 . ( B229 + 1 ) ) , ( B229 -BitGFA0CarryOutput (B227 , B228) )) ) ) \ { ( B229 -BitGFA0CarryOutput (B227 , B228) ) } ) ) & ( InnerVertices ( B229 -BitGFA0Str (B227 , B228) ) ) is Relation & ( InputVertices ( B229 -BitGFA0Str (B227 , B228) ) ) is  without_pairs)))
proof
set D64 = ( and2 );
set D65 = ( and2 );
set D66 = ( and2 );
set D67 = ( xor2 );
let C103 , C104 being  nonpair-yielding FinSequence;
deffunc H29(Nat) = ( $1 -BitGFA0Str (C103 , C104) );
deffunc H30(set , Nat) = ( BitGFA0Str (( C103 . ( $2 + 1 ) ) , ( C104 . ( $2 + 1 ) ) , $1) );
deffunc H31(Nat) = ( $1 -BitGFA0CarryOutput (C103 , C104) );
consider C105 being (ManySortedSet of ( NAT )) such that L248: (for B230 being (Element of ( NAT )) holds ( C105 . B230 ) = H31(B230)) from PBOOLE:sch 5;
deffunc H32(Nat) = ( C105 . $1 );
deffunc H33(set , Nat) = ( GFA0CarryOutput (( C103 . ( $2 + 1 ) ) , ( C104 . ( $2 + 1 ) ) , $1) );
set D68 = ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) );
L249: H29(( 0 )) = ( 1GateCircStr (( <*> ) , D68) ) by L85;
L250: ( InnerVertices H29(( 0 )) ) is Relation by L249 , FACIRC_1:38;
L251: ( InputVertices H29(( 0 )) ) is  without_pairs by L249 , FACIRC_1:39;
L252: H32(( 0 )) = H31(( 0 )) by L248;
L253: ( C105 . ( 0 ) ) in ( InnerVertices H29(( 0 )) ) by L252;
L254: (for B231 being Nat holds (for B232 being set holds ( InnerVertices H30(B232 , B231) ) is Relation)) by GFACIRC1:32;
L255:
now
let C106 being Nat;
let C107 being set;
assume that
L256: C107 = H32(C106);
L257: C106 in ( NAT ) by ORDINAL1:def 12;
L258: H32(C106) = H31(C106) by L257 , L248;
L259: C107 <> [ <* ( C103 . ( C106 + 1 ) ) , ( C104 . ( C106 + 1 ) ) *> , D64 ] by L258 , L256 , L242;
L260: C107 <> [ <* ( C103 . ( C106 + 1 ) ) , ( C104 . ( C106 + 1 ) ) *> , D67 ] by L256 , L258 , L242;
thus L261: ( InputVertices H30(C107 , C106) ) = { ( C103 . ( C106 + 1 ) ) , ( C104 . ( C106 + 1 ) ) , C107 } by L260 , L259 , GFACIRC1:33;
end;
L262: (for B233 being Nat holds (for B234 being set holds (B234 = ( C105 . B233 ) implies ( ( InputVertices H30(B234 , B233) ) \ { B234 } ) is  without_pairs)))
proof
let C108 being Nat;
let C109 being set;
assume L263: C109 = H32(C108);
L264: ( InputVertices H30(C109 , C108) ) = { ( C103 . ( C108 + 1 ) ) , ( C104 . ( C108 + 1 ) ) , C109 } by L263 , L255;
thus L265: ( ( InputVertices H30(C109 , C108) ) \ { C109 } ) is  without_pairs
proof
let C110 being  pair set;
assume L266: C110 in ( ( InputVertices H30(C109 , C108) ) \ { C109 } );
L267: C110 in ( InputVertices H30(C109 , C108) ) by L266 , XBOOLE_0:def 5;
L268: (C110 = ( C103 . ( C108 + 1 ) ) or C110 = ( C104 . ( C108 + 1 ) ) or C110 = C109) by L267 , L264 , ENUMSET1:def 1;
L269: (not C110 in { C109 }) by L266 , XBOOLE_0:def 5;
thus L270: contradiction by L269 , L268 , TARSKI:def 1;
end;

end;
L266:
now
let C111 being Nat;
let C112 being non  empty ManySortedSign;
let C113 being set;
assume that
L267: C112 = H29(C111)
and
L268: C113 = ( C105 . C111 );
L269: C111 in ( NAT ) by ORDINAL1:def 12;
L270: C113 = ( C111 -BitGFA0CarryOutput (C103 , C104) ) by L269 , L248 , L268;
L271: H32(( C111 + 1 )) = ( ( C111 + 1 ) -BitGFA0CarryOutput (C103 , C104) ) by L248;
thus L272: H29(( C111 + 1 )) = ( C112 +* H30(C113 , C111) ) by L267 , L270 , L167;
thus L273: ( C105 . ( C111 + 1 ) ) = H33(C113 , C111) by L270 , L271 , L167;
L274: ( InputVertices H30(C113 , C111) ) = { ( C103 . ( C111 + 1 ) ) , ( C104 . ( C111 + 1 ) ) , C113 } by L255 , L268;
thus L275: C113 in ( InputVertices H30(C113 , C111) ) by L274 , ENUMSET1:def 1;
L276: ( InnerVertices H30(C113 , C111) ) = ( ( ( { [ <* ( C103 . ( C111 + 1 ) ) , ( C104 . ( C111 + 1 ) ) *> , D67 ] } \/ { ( GFA0AdderOutput (( C103 . ( C111 + 1 ) ) , ( C104 . ( C111 + 1 ) ) , C113) ) } ) \/ { [ <* ( C103 . ( C111 + 1 ) ) , ( C104 . ( C111 + 1 ) ) *> , D64 ] , [ <* ( C104 . ( C111 + 1 ) ) , C113 *> , D65 ] , [ <* C113 , ( C103 . ( C111 + 1 ) ) *> , D66 ] } ) \/ { ( GFA0CarryOutput (( C103 . ( C111 + 1 ) ) , ( C104 . ( C111 + 1 ) ) , C113) ) } ) by GFACIRC1:31;
L277: H33(C113 , C111) in { H33(C113 , C111) } by TARSKI:def 1;
thus L278: H33(C113 , C111) in ( InnerVertices H30(C113 , C111) ) by L277 , L276 , XBOOLE_0:def 3;
end;
L279: (for B235 being Nat holds (( InputVertices H29(( B235 + 1 )) ) = ( ( InputVertices H29(B235) ) \/ ( ( InputVertices H30(( C105 . B235 ) , B235) ) \ { ( C105 . B235 ) } ) ) & ( InnerVertices H29(B235) ) is Relation & ( InputVertices H29(B235) ) is  without_pairs)) from CIRCCMB2:sch 11(L250 , L251 , L253 , L254 , L262 , L266);
let C114 being Nat;
L280: C114 in ( NAT ) by ORDINAL1:def 12;
L281: ( C105 . C114 ) = ( C114 -BitGFA0CarryOutput (C103 , C104) ) by L280 , L248;
thus L282: thesis by L281 , L279;
end;
theorem
L283: (for B236 being Nat holds (for B237 , B238 being  nonpair-yielding (FinSeqLen of B236) holds ( InputVertices ( B236 -BitGFA0Str (B237 , B238) ) ) = ( ( rng B237 ) \/ ( rng B238 ) )))
proof
set D69 = ( and2 );
set D70 = ( xor2 );
defpred S9[ Nat ] means (for B239 , B240 being  nonpair-yielding (FinSeqLen of $1) holds ( InputVertices ( $1 -BitGFA0Str (B239 , B240) ) ) = ( ( rng B239 ) \/ ( rng B240 ) ));
L284: S9[ ( 0 ) ]
proof
let C115 , C116 being  nonpair-yielding (FinSeqLen of ( 0 ));
set D71 = ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) );
L285: ( ( 0 ) -BitGFA0Str (C115 , C116) ) = ( 1GateCircStr (( <*> ) , D71) ) by L85;
thus L286: ( InputVertices ( ( 0 ) -BitGFA0Str (C115 , C116) ) ) = ( rng ( <*> ) ) by L285 , CIRCCOMB:42
.= ( ( rng C115 ) \/ ( rng C116 ) );
end;
L287: (for B241 being Nat holds (S9[ B241 ] implies S9[ ( B241 + 1 ) ]))
proof
let C117 being Nat;
assume that
L288: S9[ C117 ];
L289: C117 in ( NAT ) by ORDINAL1:def 12;
let C118 , C119 being  nonpair-yielding (FinSeqLen of ( C117 + 1 ));
consider C120 being  nonpair-yielding (FinSeqLen of C117), C121 being non  pair set such that L290: C118 = ( C120 ^ <* C121 *> ) by L289 , FACIRC_2:34;
consider C122 being  nonpair-yielding (FinSeqLen of C117), C123 being non  pair set such that L291: C119 = ( C122 ^ <* C123 *> ) by L289 , FACIRC_2:34;
L292: 1 in ( Seg 1 ) by FINSEQ_1:1;
L293: 1 in ( dom <* C121 *> ) by L292 , FINSEQ_1:def 8;
L294: ( len C120 ) = C117 by CARD_1:def 7;
L295: ( C118 . ( C117 + 1 ) ) = ( <* C121 *> . 1 ) by L294 , L290 , L293 , FINSEQ_1:def 7
.= C121 by FINSEQ_1:def 8;
L296: 1 in ( dom <* C123 *> ) by L292 , FINSEQ_1:def 8;
L297: ( len C122 ) = C117 by CARD_1:def 7;
L298: ( C119 . ( C117 + 1 ) ) = ( <* C123 *> . 1 ) by L297 , L291 , L296 , FINSEQ_1:def 7
.= C123 by FINSEQ_1:def 8;
deffunc H34(Nat) = ( $1 -BitGFA0CarryOutput (C118 , C119) );
L299: { C121 , C123 , H34(C117) } = { H34(C117) , C121 , C123 } by ENUMSET1:59;
L300: ( rng C118 ) = ( ( rng C120 ) \/ ( rng <* C121 *> ) ) by L290 , FINSEQ_1:31
.= ( ( rng C120 ) \/ { C121 } ) by FINSEQ_1:38;
L301: ( rng C119 ) = ( ( rng C122 ) \/ ( rng <* C123 *> ) ) by L291 , FINSEQ_1:31
.= ( ( rng C122 ) \/ { C123 } ) by FINSEQ_1:38;
L302: H34(C117) <> [ <* C121 , C123 *> , D69 ] by L242;
L303: H34(C117) <> [ <* C121 , C123 *> , D70 ] by L242;
L304: C120 = ( C120 ^ ( {} ) ) by FINSEQ_1:34;
L305: C122 = ( C122 ^ ( {} ) ) by FINSEQ_1:34;
L306: ( C117 -BitGFA0Str (C118 , C119) ) = ( C117 -BitGFA0Str (C120 , C122) ) by L305 , L290 , L291 , L304 , L105;
thus L307: ( InputVertices ( ( C117 + 1 ) -BitGFA0Str (C118 , C119) ) ) = ( ( InputVertices ( C117 -BitGFA0Str (C120 , C122) ) ) \/ ( ( InputVertices ( BitGFA0Str (C121 , C123 , H34(C117)) ) ) \ { H34(C117) } ) ) by L306 , L295 , L298 , L247
.= ( ( ( rng C120 ) \/ ( rng C122 ) ) \/ ( ( InputVertices ( BitGFA0Str (C121 , C123 , H34(C117)) ) ) \ { H34(C117) } ) ) by L288
.= ( ( ( rng C120 ) \/ ( rng C122 ) ) \/ ( { C121 , C123 , H34(C117) } \ { H34(C117) } ) ) by L302 , L303 , GFACIRC1:33
.= ( ( ( rng C120 ) \/ ( rng C122 ) ) \/ { C121 , C123 } ) by L299 , ENUMSET1:86
.= ( ( ( rng C120 ) \/ ( rng C122 ) ) \/ ( { C121 } \/ { C123 } ) ) by ENUMSET1:1
.= ( ( ( ( rng C120 ) \/ ( rng C122 ) ) \/ { C121 } ) \/ { C123 } ) by XBOOLE_1:4
.= ( ( ( ( rng C120 ) \/ { C121 } ) \/ ( rng C122 ) ) \/ { C123 } ) by XBOOLE_1:4
.= ( ( rng C118 ) \/ ( rng C119 ) ) by L300 , L301 , XBOOLE_1:4;
end;
thus L308: (for B242 being Nat holds S9[ B242 ]) from NAT_1:sch 2(L284 , L287);
end;
theorem
L309: (for B243 being Nat holds (for B244 , B245 being  nonpair-yielding (FinSeqLen of B243) holds (for B246 being (State of ( B243 -BitGFA0Circ (B244 , B245) )) holds ( Following (B246 , ( 1 + ( 2 * B243 ) )) ) is  stable)))
proof
let C124 being Nat;
let C125 , C126 being  nonpair-yielding (FinSeqLen of C124);
deffunc H35(set , Nat) = ( BitGFA0Str (( C125 . ( $2 + 1 ) ) , ( C126 . ( $2 + 1 ) ) , $1) );
deffunc H36(set , Nat) = ( BitGFA0Circ (( C125 . ( $2 + 1 ) ) , ( C126 . ( $2 + 1 ) ) , $1) );
deffunc H37(set , Nat) = ( GFA0CarryOutput (( C125 . ( $2 + 1 ) ) , ( C126 . ( $2 + 1 ) ) , $1) );
set D72 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D73 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) )) );
set D74 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) ) ];
L310: C124 in ( NAT ) by ORDINAL1:def 12;
consider C127 being (Function of ( NAT ) , ( NAT )) such that L311: ( C127 . ( 0 ) ) = 1 and L312: ( C127 . 1 ) = 2 and L313: ( C127 . 2 ) = C124 by L310 , FACIRC_2:35;
deffunc H38(Nat) = ( C127 . $1 );
L314: (for B247 being set holds (for B248 being Nat holds H36(B247 , B248) is  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict (Circuit of H35(B247 , B248))));
L315:
now
let C128 being (State of D73);
L316: ( Following (C128 , 1) ) = ( Following C128 ) by FACIRC_1:14;
thus L317: ( Following (C128 , H38(( 0 ))) ) is  stable by L316 , L311 , CIRCCMB2:2;
end;
deffunc H39(Nat) = ( $1 -BitGFA0CarryOutput (C125 , C126) );
consider C129 being (ManySortedSet of ( NAT )) such that L318: (for B249 being (Element of ( NAT )) holds ( C129 . B249 ) = H39(B249)) from PBOOLE:sch 5;
L319: (for B250 being Nat holds (for B251 being set holds (for B252 being  non-empty (Circuit of H35(B251 , B250)) holds ((B251 = ( C129 . B250 ) & B252 = H36(B251 , B250)) implies (for B253 being (State of B252) holds ( Following (B253 , H38(1)) ) is  stable)))))
proof
set D75 = ( and2 );
set D76 = ( xor2 );
let C130 being Nat;
let C131 being set;
let C132 being  non-empty (Circuit of H35(C131 , C130));
assume L320: C131 = ( C129 . C130 );
L321: C130 in ( NAT ) by ORDINAL1:def 12;
L322: C131 = H39(C130) by L321 , L318 , L320;
L323: C131 <> [ <* ( C125 . ( C130 + 1 ) ) , ( C126 . ( C130 + 1 ) ) *> , D75 ] by L322 , L242;
L324: C131 <> [ <* ( C125 . ( C130 + 1 ) ) , ( C126 . ( C130 + 1 ) ) *> , D76 ] by L322 , L242;
thus L325: thesis by L324 , L312 , L323 , GFACIRC1:40;
end;
set D77 = ( C124 -BitGFA0Str (C125 , C126) );
set D78 = ( C124 -BitGFA0Circ (C125 , C126) );
set D79 = ( ( 0 ) -BitGFA0CarryOutput (C125 , C126) );
consider C133 , C134 , C135 being (ManySortedSet of ( NAT )) such that L326: D77 = ( C133 . C124 ) and L327: D78 = ( C134 . C124 ) and L328: ( C133 . ( 0 ) ) = D72 and L329: ( C134 . ( 0 ) ) = D73 and L330: ( C135 . ( 0 ) ) = D74 and L331: (for B254 being Nat holds (for B255 being non  empty ManySortedSign holds (for B256 being  non-empty MSAlgebra over B255 holds (for B257 being set holds ((B255 = ( C133 . B254 ) & B256 = ( C134 . B254 ) & B257 = ( C135 . B254 )) implies (( C133 . ( B254 + 1 ) ) = ( B255 +* H35(B257 , B254) ) & ( C134 . ( B254 + 1 ) ) = ( B256 +* H36(B257 , B254) ) & ( C135 . ( B254 + 1 ) ) = H37(B257 , B254))))))) by L8;
L332:
now
let C136 being set;
assume L333: C136 in ( NAT );
reconsider D80 = C136 as Nat by L333;
thus L334: ( C135 . C136 ) = H39(D80) by L328 , L329 , L330 , L331 , L56
.= ( C129 . C136 ) by L318 , L333;
end;
L335: C135 = C129 by L332 , PBOOLE:3;
L336: (ex B258 , B259 being (ManySortedSet of ( NAT )) st (D77 = ( B258 . H38(2) ) & D78 = ( B259 . H38(2) ) & ( B258 . ( 0 ) ) = D72 & ( B259 . ( 0 ) ) = D73 & ( C129 . ( 0 ) ) = D79 & (for B260 being Nat holds (for B261 being non  empty ManySortedSign holds (for B262 being  non-empty MSAlgebra over B261 holds (for B263 being set holds (for B264 being  non-empty MSAlgebra over H35(B263 , B260) holds ((B261 = ( B258 . B260 ) & B262 = ( B259 . B260 ) & B263 = ( C129 . B260 ) & B264 = H36(B263 , B260)) implies (( B258 . ( B260 + 1 ) ) = ( B261 +* H35(B263 , B260) ) & ( B259 . ( B260 + 1 ) ) = ( B262 +* B264 ) & ( C129 . ( B260 + 1 ) ) = H37(B263 , B260))))))))))
proof
take C133;
take C134;
thus L337: thesis by L313 , L318 , L326 , L327 , L328 , L329 , L331 , L335;
end;
L338: (( InnerVertices D72 ) is Relation & ( InputVertices D72 ) is  without_pairs) by FACIRC_1:38 , FACIRC_1:39;
L339: D79 = D74 by L85;
L340: ( InnerVertices D72 ) = { D74 } by CIRCCOMB:42;
L341: (( C129 . ( 0 ) ) = D79 & D79 in ( InnerVertices D72 )) by L340 , L318 , L339 , TARSKI:def 1;
L342: (for B265 being Nat holds (for B266 being set holds ( InnerVertices H35(B266 , B265) ) is Relation)) by GFACIRC1:32;
L343: (for B267 being Nat holds (for B268 being set holds (B268 = ( C129 . B267 ) implies ( ( InputVertices H35(B268 , B267) ) \ { B268 } ) is  without_pairs)))
proof
set D81 = ( and2 );
set D82 = ( xor2 );
let C137 being Nat;
let C138 being set;
assume that
L344: C138 = ( C129 . C137 );
L345: C137 in ( NAT ) by ORDINAL1:def 12;
L346: C138 = H39(C137) by L345 , L318 , L344;
L347: C138 <> [ <* ( C125 . ( C137 + 1 ) ) , ( C126 . ( C137 + 1 ) ) *> , D81 ] by L346 , L242;
L348: C138 <> [ <* ( C125 . ( C137 + 1 ) ) , ( C126 . ( C137 + 1 ) ) *> , D82 ] by L346 , L242;
L349: ( InputVertices H35(C138 , C137) ) = { ( C125 . ( C137 + 1 ) ) , ( C126 . ( C137 + 1 ) ) , C138 } by L348 , L347 , GFACIRC1:33;
let C139 being  pair set;
assume L350: C139 in ( ( InputVertices H35(C138 , C137) ) \ { C138 } );
L351: C139 in { ( C125 . ( C137 + 1 ) ) , ( C126 . ( C137 + 1 ) ) , C138 } by L350 , L349 , XBOOLE_0:def 5;
L352: (not C139 in { C138 }) by L350 , XBOOLE_0:def 5;
L353: (C139 = ( C125 . ( C137 + 1 ) ) or C139 = ( C126 . ( C137 + 1 ) ) or C139 = C138) by L351 , ENUMSET1:def 1;
thus L354: thesis by L353 , L352 , TARSKI:def 1;
end;
L355: (for B269 being Nat holds (for B270 being set holds (B270 = ( C129 . B269 ) implies (( C129 . ( B269 + 1 ) ) = H37(B270 , B269) & B270 in ( InputVertices H35(B270 , B269) ) & H37(B270 , B269) in ( InnerVertices H35(B270 , B269) )))))
proof
set D83 = ( and2 );
set D84 = ( and2 );
set D85 = ( and2 );
set D86 = ( xor2 );
let C140 being Nat;
let C141 being set;
assume that
L356: C141 = ( C129 . C140 );
L357: C140 in ( NAT ) by ORDINAL1:def 12;
L358: C141 = H39(C140) by L357 , L318 , L356;
L359: ( C129 . ( C140 + 1 ) ) = H39(( C140 + 1 )) by L318;
thus L360: ( C129 . ( C140 + 1 ) ) = H37(C141 , C140) by L359 , L358 , L167;
L361: C141 <> [ <* ( C125 . ( C140 + 1 ) ) , ( C126 . ( C140 + 1 ) ) *> , D83 ] by L358 , L242;
L362: C141 <> [ <* ( C125 . ( C140 + 1 ) ) , ( C126 . ( C140 + 1 ) ) *> , D86 ] by L358 , L242;
L363: ( InputVertices H35(C141 , C140) ) = { ( C125 . ( C140 + 1 ) ) , ( C126 . ( C140 + 1 ) ) , C141 } by L362 , L361 , GFACIRC1:33;
thus L364: C141 in ( InputVertices H35(C141 , C140) ) by L363 , ENUMSET1:def 1;
L365: ( InnerVertices H35(C141 , C140) ) = ( ( ( { [ <* ( C125 . ( C140 + 1 ) ) , ( C126 . ( C140 + 1 ) ) *> , D86 ] } \/ { ( GFA0AdderOutput (( C125 . ( C140 + 1 ) ) , ( C126 . ( C140 + 1 ) ) , C141) ) } ) \/ { [ <* ( C125 . ( C140 + 1 ) ) , ( C126 . ( C140 + 1 ) ) *> , D83 ] , [ <* ( C126 . ( C140 + 1 ) ) , C141 *> , D84 ] , [ <* C141 , ( C125 . ( C140 + 1 ) ) *> , D85 ] } ) \/ { ( GFA0CarryOutput (( C125 . ( C140 + 1 ) ) , ( C126 . ( C140 + 1 ) ) , C141) ) } ) by GFACIRC1:31;
L366: H37(C141 , C140) in { H37(C141 , C140) } by TARSKI:def 1;
thus L367: thesis by L366 , L365 , XBOOLE_0:def 3;
end;
L368: (for B271 being (State of D78) holds ( Following (B271 , ( H38(( 0 )) + ( H38(2) * H38(1) ) )) ) is  stable) from CIRCCMB2:sch 22(L314 , L315 , L319 , L336 , L338 , L341 , L342 , L343 , L355);
thus L369: thesis by L368 , L311 , L312 , L313;
end;
begin
definition
let C142 being Nat;
let C143 , C144 being FinSequence;
L370: ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) is  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty  strict;
func C142 -BitGFA1Str (C143 , C144) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign means 
:L371: (ex B272 , B273 being (ManySortedSet of ( NAT )) st (it = ( B272 . C142 ) & ( B272 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( B273 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] & (for B274 being Nat holds (for B275 being non  empty ManySortedSign holds (for B276 being set holds ((B275 = ( B272 . B274 ) & B276 = ( B273 . B274 )) implies (( B272 . ( B274 + 1 ) ) = ( B275 +* ( BitGFA1Str (( C143 . ( B274 + 1 ) ) , ( C144 . ( B274 + 1 ) ) , B276) ) ) & ( B273 . ( B274 + 1 ) ) = ( GFA1CarryOutput (( C143 . ( B274 + 1 ) ) , ( C144 . ( B274 + 1 ) ) , B276) ))))))));
uniqueness
proof
reconsider D87 = C142 as Nat;
set D88 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D89 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
deffunc H40(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitGFA1Str (( C143 . ( $3 + 1 ) ) , ( C144 . ( $3 + 1 ) ) , $2) ) );
deffunc H41(set , Nat) = ( GFA1CarryOutput (( C143 . ( $2 + 1 ) ) , ( C144 . ( $2 + 1 ) ) , $1) );
L372: (for B277 , B278 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty  strict non  empty ManySortedSign holds (((ex B279 , B280 being (ManySortedSet of ( NAT )) st (B277 = ( B279 . D87 ) & ( B279 . ( 0 ) ) = D88 & ( B280 . ( 0 ) ) = D89 & (for B281 being Nat holds (for B282 being non  empty ManySortedSign holds (for B283 being set holds ((B282 = ( B279 . B281 ) & B283 = ( B280 . B281 )) implies (( B279 . ( B281 + 1 ) ) = H40(B282 , B283 , B281) & ( B280 . ( B281 + 1 ) ) = H41(B283 , B281)))))))) & (ex B284 , B285 being (ManySortedSet of ( NAT )) st (B278 = ( B284 . D87 ) & ( B284 . ( 0 ) ) = D88 & ( B285 . ( 0 ) ) = D89 & (for B286 being Nat holds (for B287 being non  empty ManySortedSign holds (for B288 being set holds ((B287 = ( B284 . B286 ) & B288 = ( B285 . B286 )) implies (( B284 . ( B286 + 1 ) ) = H40(B287 , B288 , B286) & ( B285 . ( B286 + 1 ) ) = H41(B288 , B286))))))))) implies B277 = B278)) from CIRCCMB2:sch 9;
thus L373: thesis by L372;
end;
existence
proof
reconsider D90 = C142 as Nat;
set D91 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D92 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
deffunc H42(set , Nat) = ( BitGFA1Str (( C143 . ( $2 + 1 ) ) , ( C144 . ( $2 + 1 ) ) , $1) );
deffunc H43(set , Nat) = ( GFA1CarryOutput (( C143 . ( $2 + 1 ) ) , ( C144 . ( $2 + 1 ) ) , $1) );
L374: (ex B289 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty non  empty  strict ManySortedSign st (ex B290 , B291 being (ManySortedSet of ( NAT )) st (B289 = ( B290 . D90 ) & ( B290 . ( 0 ) ) = D91 & ( B291 . ( 0 ) ) = D92 & (for B292 being Nat holds (for B293 being non  empty ManySortedSign holds (for B294 being set holds ((B293 = ( B290 . B292 ) & B294 = ( B291 . B292 )) implies (( B290 . ( B292 + 1 ) ) = ( B293 +* H42(B294 , B292) ) & ( B291 . ( B292 + 1 ) ) = H43(B294 , B292))))))))) from CIRCCMB2:sch 8(L370);
thus L375: thesis by L374;
end;
end;
definition
let C145 being Nat;
let C146 , C147 being FinSequence;
func C145 -BitGFA1Circ (C146 , C147) ->  Boolean  gate`2=den  strict (Circuit of ( C145 -BitGFA1Str (C146 , C147) )) means 
:L377: (ex B295 , B296 , B297 being (ManySortedSet of ( NAT )) st (( C145 -BitGFA1Str (C146 , C147) ) = ( B295 . C145 ) & it = ( B296 . C145 ) & ( B295 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( B296 . ( 0 ) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( B297 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] & (for B298 being Nat holds (for B299 being non  empty ManySortedSign holds (for B300 being  non-empty MSAlgebra over B299 holds (for B301 being set holds ((B299 = ( B295 . B298 ) & B300 = ( B296 . B298 ) & B301 = ( B297 . B298 )) implies (( B295 . ( B298 + 1 ) ) = ( B299 +* ( BitGFA1Str (( C146 . ( B298 + 1 ) ) , ( C147 . ( B298 + 1 ) ) , B301) ) ) & ( B296 . ( B298 + 1 ) ) = ( B300 +* ( BitGFA1Circ (( C146 . ( B298 + 1 ) ) , ( C147 . ( B298 + 1 ) ) , B301) ) ) & ( B297 . ( B298 + 1 ) ) = ( GFA1CarryOutput (( C146 . ( B298 + 1 ) ) , ( C147 . ( B298 + 1 ) ) , B301) )))))))));
uniqueness
proof
set D93 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D94 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D95 = ( C145 -BitGFA1Str (C146 , C147) );
set D96 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
deffunc H44(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitGFA1Str (( C146 . ( $3 + 1 ) ) , ( C147 . ( $3 + 1 ) ) , $2) ) );
deffunc H45(non  empty ManySortedSign ,  non-empty MSAlgebra over $1 , set , Nat) = ( $2 +* ( BitGFA1Circ (( C146 . ( $4 + 1 ) ) , ( C147 . ( $4 + 1 ) ) , $3) ) );
deffunc H46(set , Nat) = ( GFA1CarryOutput (( C146 . ( $2 + 1 ) ) , ( C147 . ( $2 + 1 ) ) , $1) );
L378: (for B302 being non  empty ManySortedSign holds (for B303 being  non-empty MSAlgebra over B302 holds (for B304 being set holds (for B305 being Nat holds H45(B302 , B303 , B304 , B305) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over H44(B302 , B304 , B305)))));
L379: (for B306 , B307 being  Boolean  gate`2=den  strict (Circuit of D95) holds (((ex B308 , B309 , B310 being (ManySortedSet of ( NAT )) st (D95 = ( B308 . C145 ) & B306 = ( B309 . C145 ) & ( B308 . ( 0 ) ) = D93 & ( B309 . ( 0 ) ) = D94 & ( B310 . ( 0 ) ) = D96 & (for B311 being Nat holds (for B312 being non  empty ManySortedSign holds (for B313 being  non-empty MSAlgebra over B312 holds (for B314 being set holds ((B312 = ( B308 . B311 ) & B313 = ( B309 . B311 ) & B314 = ( B310 . B311 )) implies (( B308 . ( B311 + 1 ) ) = H44(B312 , B314 , B311) & ( B309 . ( B311 + 1 ) ) = H45(B312 , B313 , B314 , B311) & ( B310 . ( B311 + 1 ) ) = H46(B314 , B311))))))))) & (ex B315 , B316 , B317 being (ManySortedSet of ( NAT )) st (D95 = ( B315 . C145 ) & B307 = ( B316 . C145 ) & ( B315 . ( 0 ) ) = D93 & ( B316 . ( 0 ) ) = D94 & ( B317 . ( 0 ) ) = D96 & (for B318 being Nat holds (for B319 being non  empty ManySortedSign holds (for B320 being  non-empty MSAlgebra over B319 holds (for B321 being set holds ((B319 = ( B315 . B318 ) & B320 = ( B316 . B318 ) & B321 = ( B317 . B318 )) implies (( B315 . ( B318 + 1 ) ) = H44(B319 , B321 , B318) & ( B316 . ( B318 + 1 ) ) = H45(B319 , B320 , B321 , B318) & ( B317 . ( B318 + 1 ) ) = H46(B321 , B318)))))))))) implies B306 = B307)) from CIRCCMB2:sch 21(L378);
thus L380: thesis by L379;
end;
existence
proof
set D97 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D98 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D99 = ( C145 -BitGFA1Str (C146 , C147) );
set D100 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
deffunc H47(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitGFA1Str (( C146 . ( $3 + 1 ) ) , ( C147 . ( $3 + 1 ) ) , $2) ) );
deffunc H48(non  empty ManySortedSign ,  non-empty MSAlgebra over $1 , set , Nat) = ( $2 +* ( BitGFA1Circ (( C146 . ( $4 + 1 ) ) , ( C147 . ( $4 + 1 ) ) , $3) ) );
deffunc H49(set , Nat) = ( GFA1CarryOutput (( C146 . ( $2 + 1 ) ) , ( C147 . ( $2 + 1 ) ) , $1) );
L381: (for B322 being  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign holds (for B323 being set holds (for B324 being Nat holds H47(B322 , B323 , B324) is  unsplit  gate`1=arity  gate`2isBoolean non  void  strict)));
L382: (ex B325 , B326 being (ManySortedSet of ( NAT )) st (D99 = ( B325 . C145 ) & ( B325 . ( 0 ) ) = D97 & ( B326 . ( 0 ) ) = D100 & (for B327 being Nat holds (for B328 being non  empty ManySortedSign holds (for B329 being set holds ((B328 = ( B325 . B327 ) & B329 = ( B326 . B327 )) implies (( B325 . ( B327 + 1 ) ) = H47(B328 , B329 , B327) & ( B326 . ( B327 + 1 ) ) = H49(B329 , B327)))))))) by L371;
L383: (for B330 being non  empty ManySortedSign holds (for B331 being  non-empty MSAlgebra over B330 holds (for B332 being set holds (for B333 being Nat holds H48(B330 , B331 , B332 , B333) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over H47(B330 , B332 , B333)))));
L384: (for B334 , B335 being  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign holds (for B336 being  Boolean  gate`2=den  strict (Circuit of B334) holds (for B337 being set holds (for B338 being Nat holds (B335 = H47(B334 , B337 , B338) implies H48(B334 , B336 , B337 , B338) is  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict (Circuit of B335))))));
L385: (ex B339 being  Boolean  gate`2=den  strict (Circuit of D99) st (ex B340 , B341 , B342 being (ManySortedSet of ( NAT )) st (D99 = ( B340 . C145 ) & B339 = ( B341 . C145 ) & ( B340 . ( 0 ) ) = D97 & ( B341 . ( 0 ) ) = D98 & ( B342 . ( 0 ) ) = D100 & (for B343 being Nat holds (for B344 being non  empty ManySortedSign holds (for B345 being  non-empty MSAlgebra over B344 holds (for B346 being set holds ((B344 = ( B340 . B343 ) & B345 = ( B341 . B343 ) & B346 = ( B342 . B343 )) implies (( B340 . ( B343 + 1 ) ) = H47(B344 , B346 , B343) & ( B341 . ( B343 + 1 ) ) = H48(B344 , B345 , B346 , B343) & ( B342 . ( B343 + 1 ) ) = H49(B346 , B343)))))))))) from CIRCCMB2:sch 19(L381 , L382 , L383 , L384);
thus L386: thesis by L385;
end;
end;
definition
let C148 being Nat;
let C149 , C150 being FinSequence;
func C148 -BitGFA1CarryOutput (C149 , C150) -> (Element of ( InnerVertices ( C148 -BitGFA1Str (C149 , C150) ) )) means 
:L388: (ex B347 being (ManySortedSet of ( NAT )) st (it = ( B347 . C148 ) & ( B347 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] & (for B348 being Nat holds ( B347 . ( B348 + 1 ) ) = ( GFA1CarryOutput (( C149 . ( B348 + 1 ) ) , ( C150 . ( B348 + 1 ) ) , ( B347 . B348 )) ))));
uniqueness
proof
set D101 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
deffunc H50(Nat , set) = ( GFA1CarryOutput (( C149 . ( $1 + 1 ) ) , ( C150 . ( $1 + 1 ) ) , $2) );
let C151 , C152 being (Element of ( InnerVertices ( C148 -BitGFA1Str (C149 , C150) ) ));
given C153 being (ManySortedSet of ( NAT )) such that
L389: C151 = ( C153 . C148 )
and
L390: ( C153 . ( 0 ) ) = D101
and
L391: (for B349 being Nat holds ( C153 . ( B349 + 1 ) ) = ( GFA1CarryOutput (( C149 . ( B349 + 1 ) ) , ( C150 . ( B349 + 1 ) ) , ( C153 . B349 )) ));

given C154 being (ManySortedSet of ( NAT )) such that
L392: C152 = ( C154 . C148 )
and
L393: ( C154 . ( 0 ) ) = D101
and
L394: (for B350 being Nat holds ( C154 . ( B350 + 1 ) ) = ( GFA1CarryOutput (( C149 . ( B350 + 1 ) ) , ( C150 . ( B350 + 1 ) ) , ( C154 . B350 )) ));

L395: ( dom C153 ) = ( NAT ) by PARTFUN1:def 2;
L396: ( C153 . ( 0 ) ) = D101 by L390;
L397: (for B351 being Nat holds ( C153 . ( B351 + 1 ) ) = H50(B351 , ( C153 . B351 ))) by L391;
L398: ( dom C154 ) = ( NAT ) by PARTFUN1:def 2;
L399: ( C154 . ( 0 ) ) = D101 by L393;
L400: (for B352 being Nat holds ( C154 . ( B352 + 1 ) ) = H50(B352 , ( C154 . B352 ))) by L394;
L401: C153 = C154 from NAT_1:sch 15(L395 , L396 , L397 , L398 , L399 , L400);
thus L402: thesis by L401 , L389 , L392;
end;
existence
proof
defpred S10[ set , set , set ] means (not contradiction);
set D102 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D103 = ( C148 -BitGFA1Str (C149 , C150) );
set D104 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
deffunc H51(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitGFA1Str (( C149 . ( $3 + 1 ) ) , ( C150 . ( $3 + 1 ) ) , $2) ) );
deffunc H52(set , Nat) = ( GFA1CarryOutput (( C149 . ( $2 + 1 ) ) , ( C150 . ( $2 + 1 ) ) , $1) );
consider C155 , C156 being (ManySortedSet of ( NAT )) such that L403: D103 = ( C155 . C148 ) and L404: ( C155 . ( 0 ) ) = D102 and L405: ( C156 . ( 0 ) ) = D104 and L406: (for B353 being Nat holds (for B354 being non  empty ManySortedSign holds (for B355 being set holds ((B354 = ( C155 . B353 ) & B355 = ( C156 . B353 )) implies (( C155 . ( B353 + 1 ) ) = H51(B354 , B355 , B353) & ( C156 . ( B353 + 1 ) ) = H52(B355 , B353)))))) by L371;
defpred S11[ Nat ] means (ex B356 being non  empty ManySortedSign st (B356 = ( C155 . $1 ) & ( C156 . $1 ) in ( InnerVertices B356 )));
L407: ( InnerVertices D102 ) = { D104 } by CIRCCOMB:42;
L408: D104 in ( InnerVertices D102 ) by L407 , TARSKI:def 1;
L409: S11[ ( 0 ) ] by L408 , L404 , L405;
L410: (for B357 being Nat holds (S11[ B357 ] implies S11[ ( B357 + 1 ) ]))
proof
let C157 being Nat;
assume that
L411: (ex B358 being non  empty ManySortedSign st (B358 = ( C155 . C157 ) & ( C156 . C157 ) in ( InnerVertices B358 )))
and
L412: (for B359 being non  empty ManySortedSign holds (B359 = ( C155 . ( C157 + 1 ) ) implies (not ( C156 . ( C157 + 1 ) ) in ( InnerVertices B359 ))));
consider C158 being non  empty ManySortedSign such that L413: C158 = ( C155 . C157 ) and L414: ( C156 . C157 ) in ( InnerVertices C158 ) by L411;
L415: ( GFA1CarryOutput (( C149 . ( C157 + 1 ) ) , ( C150 . ( C157 + 1 ) ) , ( C156 . C157 )) ) in ( InnerVertices ( BitGFA1Str (( C149 . ( C157 + 1 ) ) , ( C150 . ( C157 + 1 ) ) , ( C156 . C157 )) ) ) by GFACIRC1:69;
L416: ( GFA1CarryOutput (( C149 . ( C157 + 1 ) ) , ( C150 . ( C157 + 1 ) ) , ( C156 . C157 )) ) in ( InnerVertices ( C158 +* ( BitGFA1Str (( C149 . ( C157 + 1 ) ) , ( C150 . ( C157 + 1 ) ) , ( C156 . C157 )) ) ) ) by L415 , FACIRC_1:22;
L417: ( C155 . ( C157 + 1 ) ) = ( C158 +* ( BitGFA1Str (( C149 . ( C157 + 1 ) ) , ( C150 . ( C157 + 1 ) ) , ( C156 . C157 )) ) ) by L406 , L413;
L418: ( C156 . ( C157 + 1 ) ) = ( GFA1CarryOutput (( C149 . ( C157 + 1 ) ) , ( C150 . ( C157 + 1 ) ) , ( C156 . C157 )) ) by L406 , L413;
thus L419: contradiction by L418 , L412 , L416 , L417;
end;
L420: (for B360 being Nat holds S11[ B360 ]) from NAT_1:sch 2(L409 , L410);
L421: (ex B361 being non  empty ManySortedSign st (B361 = ( C155 . C148 ) & ( C156 . C148 ) in ( InnerVertices B361 ))) by L420;
reconsider D105 = ( C156 . C148 ) as (Element of ( InnerVertices D103 )) by L421 , L403;
take D105;
take C156;
thus L422: (D105 = ( C156 . C148 ) & ( C156 . ( 0 ) ) = D104) by L405;
let C159 being Nat;
L423: (ex B362 being non  empty ManySortedSign st (ex B363 being set st (B362 = ( C155 . ( 0 ) ) & B363 = ( C156 . ( 0 ) ) & S10[ B362 , B363 , ( 0 ) ]))) by L404;
L424: (for B364 being Nat holds (for B365 being non  empty ManySortedSign holds (for B366 being set holds ((B365 = ( C155 . B364 ) & B366 = ( C156 . B364 ) & S10[ B365 , B366 , B364 ]) implies S10[ H51(B365 , B366 , B364) , H52(B366 , B364) , ( B364 + 1 ) ]))));
L425: (for B367 being Nat holds (ex B368 being non  empty ManySortedSign st (B368 = ( C155 . B367 ) & S10[ B368 , ( C156 . B367 ) , B367 ]))) from CIRCCMB2:sch 2(L423 , L406 , L424);
L426: (ex B369 being non  empty ManySortedSign st B369 = ( C155 . C159 )) by L425;
thus L427: thesis by L426 , L406;
end;
end;
theorem
L429: (for B370 , B371 being FinSequence holds (for B372 , B373 , B374 being (ManySortedSet of ( NAT )) holds ((( B372 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( B373 . ( 0 ) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( B374 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] & (for B375 being Nat holds (for B376 being non  empty ManySortedSign holds (for B377 being  non-empty MSAlgebra over B376 holds (for B378 being set holds ((B376 = ( B372 . B375 ) & B377 = ( B373 . B375 ) & B378 = ( B374 . B375 )) implies (( B372 . ( B375 + 1 ) ) = ( B376 +* ( BitGFA1Str (( B370 . ( B375 + 1 ) ) , ( B371 . ( B375 + 1 ) ) , B378) ) ) & ( B373 . ( B375 + 1 ) ) = ( B377 +* ( BitGFA1Circ (( B370 . ( B375 + 1 ) ) , ( B371 . ( B375 + 1 ) ) , B378) ) ) & ( B374 . ( B375 + 1 ) ) = ( GFA1CarryOutput (( B370 . ( B375 + 1 ) ) , ( B371 . ( B375 + 1 ) ) , B378) )))))))) implies (for B379 being Nat holds (( B379 -BitGFA1Str (B370 , B371) ) = ( B372 . B379 ) & ( B379 -BitGFA1Circ (B370 , B371) ) = ( B373 . B379 ) & ( B379 -BitGFA1CarryOutput (B370 , B371) ) = ( B374 . B379 ))))))
proof
let C160 , C161 being FinSequence;
let C162 , C163 , C164 being (ManySortedSet of ( NAT ));
set D106 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D107 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D108 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
deffunc H53(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitGFA1Str (( C160 . ( $3 + 1 ) ) , ( C161 . ( $3 + 1 ) ) , $2) ) );
deffunc H54(non  empty ManySortedSign ,  non-empty MSAlgebra over $1 , set , Nat) = ( $2 +* ( BitGFA1Circ (( C160 . ( $4 + 1 ) ) , ( C161 . ( $4 + 1 ) ) , $3) ) );
deffunc H55(set , Nat) = ( GFA1CarryOutput (( C160 . ( $2 + 1 ) ) , ( C161 . ( $2 + 1 ) ) , $1) );
deffunc H56(Nat , set) = ( GFA1CarryOutput (( C160 . ( $1 + 1 ) ) , ( C161 . ( $1 + 1 ) ) , $2) );
assume that
L430: (( C162 . ( 0 ) ) = D106 & ( C163 . ( 0 ) ) = D107)
and
L431: ( C164 . ( 0 ) ) = D108
and
L432: (for B380 being Nat holds (for B381 being non  empty ManySortedSign holds (for B382 being  non-empty MSAlgebra over B381 holds (for B383 being set holds ((B381 = ( C162 . B380 ) & B382 = ( C163 . B380 ) & B383 = ( C164 . B380 )) implies (( C162 . ( B380 + 1 ) ) = H53(B381 , B383 , B380) & ( C163 . ( B380 + 1 ) ) = H54(B381 , B382 , B383 , B380) & ( C164 . ( B380 + 1 ) ) = H55(B383 , B380)))))));
let C165 being Nat;
consider C166 , C167 , C168 being (ManySortedSet of ( NAT )) such that L433: ( C165 -BitGFA1Str (C160 , C161) ) = ( C166 . C165 ) and L434: ( C165 -BitGFA1Circ (C160 , C161) ) = ( C167 . C165 ) and L435: ( C166 . ( 0 ) ) = D106 and L436: ( C167 . ( 0 ) ) = D107 and L437: ( C168 . ( 0 ) ) = D108 and L438: (for B384 being Nat holds (for B385 being non  empty ManySortedSign holds (for B386 being  non-empty MSAlgebra over B385 holds (for B387 being set holds ((B385 = ( C166 . B384 ) & B386 = ( C167 . B384 ) & B387 = ( C168 . B384 )) implies (( C166 . ( B384 + 1 ) ) = H53(B385 , B387 , B384) & ( C167 . ( B384 + 1 ) ) = H54(B385 , B386 , B387 , B384) & ( C168 . ( B384 + 1 ) ) = H55(B387 , B384))))))) by L377;
L439: (ex B388 being non  empty ManySortedSign st (ex B389 being  non-empty MSAlgebra over B388 st (B388 = ( C162 . ( 0 ) ) & B389 = ( C163 . ( 0 ) )))) by L430;
L440: (( C162 . ( 0 ) ) = ( C166 . ( 0 ) ) & ( C163 . ( 0 ) ) = ( C167 . ( 0 ) ) & ( C164 . ( 0 ) ) = ( C168 . ( 0 ) )) by L430 , L431 , L435 , L436 , L437;
L441: (for B390 being non  empty ManySortedSign holds (for B391 being  non-empty MSAlgebra over B390 holds (for B392 being set holds (for B393 being Nat holds H54(B390 , B391 , B392 , B393) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over H53(B390 , B392 , B393)))));
L442: (C162 = C166 & C163 = C167 & C164 = C168) from CIRCCMB2:sch 14(L439 , L440 , L432 , L438 , L441);
thus L443: (( C165 -BitGFA1Str (C160 , C161) ) = ( C162 . C165 ) & ( C165 -BitGFA1Circ (C160 , C161) ) = ( C163 . C165 )) by L442 , L433 , L434;
L444: (for B394 being Nat holds (for B395 being non  empty ManySortedSign holds (for B396 being set holds ((B395 = ( C162 . B394 ) & B396 = ( C164 . B394 )) implies (( C162 . ( B394 + 1 ) ) = H53(B395 , B396 , B394) & ( C164 . ( B394 + 1 ) ) = H55(B396 , B394)))))) from CIRCCMB2:sch 15(L430 , L432 , L441);
L445: ( C162 . ( 0 ) ) = D106 by L430;
L446: ( dom C164 ) = ( NAT ) by PARTFUN1:def 2;
L447: ( C164 . ( 0 ) ) = D108 by L431;
L448: (for B397 being Nat holds (for B398 being set holds (B398 = ( C164 . B397 ) implies ( C164 . ( B397 + 1 ) ) = H55(B398 , B397)))) from CIRCCMB2:sch 3(L445 , L444);
L449: (for B399 being Nat holds ( C164 . ( B399 + 1 ) ) = H56(B399 , ( C164 . B399 ))) by L448;
consider C169 being (ManySortedSet of ( NAT )) such that L450: ( C165 -BitGFA1CarryOutput (C160 , C161) ) = ( C169 . C165 ) and L451: ( C169 . ( 0 ) ) = D108 and L452: (for B400 being Nat holds ( C169 . ( B400 + 1 ) ) = ( GFA1CarryOutput (( C160 . ( B400 + 1 ) ) , ( C161 . ( B400 + 1 ) ) , ( C169 . B400 )) )) by L388;
L453: ( dom C169 ) = ( NAT ) by PARTFUN1:def 2;
L454: ( C169 . ( 0 ) ) = D108 by L451;
L455: (for B401 being Nat holds ( C169 . ( B401 + 1 ) ) = H56(B401 , ( C169 . B401 ))) by L452;
L456: C164 = C169 from NAT_1:sch 15(L446 , L447 , L449 , L453 , L454 , L455);
thus L457: thesis by L456 , L450;
end;
theorem
L458: (for B402 , B403 being FinSequence holds (( ( 0 ) -BitGFA1Str (B402 , B403) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( ( 0 ) -BitGFA1Circ (B402 , B403) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( ( 0 ) -BitGFA1CarryOutput (B402 , B403) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ]))
proof
let C170 , C171 being FinSequence;
set D109 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D110 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D111 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
L459: (ex B404 , B405 , B406 being (ManySortedSet of ( NAT )) st (( ( 0 ) -BitGFA1Str (C170 , C171) ) = ( B404 . ( 0 ) ) & ( ( 0 ) -BitGFA1Circ (C170 , C171) ) = ( B405 . ( 0 ) ) & ( B404 . ( 0 ) ) = D109 & ( B405 . ( 0 ) ) = D110 & ( B406 . ( 0 ) ) = D111 & (for B407 being Nat holds (for B408 being non  empty ManySortedSign holds (for B409 being  non-empty MSAlgebra over B408 holds (for B410 being set holds ((B408 = ( B404 . B407 ) & B409 = ( B405 . B407 ) & B410 = ( B406 . B407 )) implies (( B404 . ( B407 + 1 ) ) = ( B408 +* ( BitGFA1Str (( C170 . ( B407 + 1 ) ) , ( C171 . ( B407 + 1 ) ) , B410) ) ) & ( B405 . ( B407 + 1 ) ) = ( B409 +* ( BitGFA1Circ (( C170 . ( B407 + 1 ) ) , ( C171 . ( B407 + 1 ) ) , B410) ) ) & ( B406 . ( B407 + 1 ) ) = ( GFA1CarryOutput (( C170 . ( B407 + 1 ) ) , ( C171 . ( B407 + 1 ) ) , B410) ))))))))) by L377;
thus L460: ( ( 0 ) -BitGFA1Str (C170 , C171) ) = D109 by L459;
thus L461: ( ( 0 ) -BitGFA1Circ (C170 , C171) ) = D110 by L459;
L462: ( InnerVertices ( ( 0 ) -BitGFA1Str (C170 , C171) ) ) = { D111 } by L459 , CIRCCOMB:42;
thus L463: thesis by L462 , TARSKI:def 1;
end;
theorem
L464: (for B411 , B412 being FinSequence holds (for B413 being set holds (B413 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] implies (( 1 -BitGFA1Str (B411 , B412) ) = ( ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) +* ( BitGFA1Str (( B411 . 1 ) , ( B412 . 1 ) , B413) ) ) & ( 1 -BitGFA1Circ (B411 , B412) ) = ( ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) +* ( BitGFA1Circ (( B411 . 1 ) , ( B412 . 1 ) , B413) ) ) & ( 1 -BitGFA1CarryOutput (B411 , B412) ) = ( GFA1CarryOutput (( B411 . 1 ) , ( B412 . 1 ) , B413) )))))
proof
set D112 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D113 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D114 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
let C172 , C173 being FinSequence;
let C174 being set;
assume that
L465: C174 = D114;
consider C175 , C176 , C177 being (ManySortedSet of ( NAT )) such that L466: ( 1 -BitGFA1Str (C172 , C173) ) = ( C175 . 1 ) and L467: ( 1 -BitGFA1Circ (C172 , C173) ) = ( C176 . 1 ) and L468: ( C175 . ( 0 ) ) = D112 and L469: ( C176 . ( 0 ) ) = D113 and L470: ( C177 . ( 0 ) ) = C174 and L471: (for B414 being Nat holds (for B415 being non  empty ManySortedSign holds (for B416 being  non-empty MSAlgebra over B415 holds (for B417 being set holds ((B415 = ( C175 . B414 ) & B416 = ( C176 . B414 ) & B417 = ( C177 . B414 )) implies (( C175 . ( B414 + 1 ) ) = ( B415 +* ( BitGFA1Str (( C172 . ( B414 + 1 ) ) , ( C173 . ( B414 + 1 ) ) , B417) ) ) & ( C176 . ( B414 + 1 ) ) = ( B416 +* ( BitGFA1Circ (( C172 . ( B414 + 1 ) ) , ( C173 . ( B414 + 1 ) ) , B417) ) ) & ( C177 . ( B414 + 1 ) ) = ( GFA1CarryOutput (( C172 . ( B414 + 1 ) ) , ( C173 . ( B414 + 1 ) ) , B417) ))))))) by L465 , L377;
L472: ( 1 -BitGFA1CarryOutput (C172 , C173) ) = ( C177 . ( ( 0 ) + 1 ) ) by L465 , L468 , L469 , L470 , L471 , L429;
thus L473: thesis by L472 , L466 , L467 , L468 , L469 , L470 , L471;
end;
theorem
L474: (for B418 , B419 , B420 being set holds (B420 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] implies (( 1 -BitGFA1Str (<* B418 *> , <* B419 *>) ) = ( ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) +* ( BitGFA1Str (B418 , B419 , B420) ) ) & ( 1 -BitGFA1Circ (<* B418 *> , <* B419 *>) ) = ( ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) +* ( BitGFA1Circ (B418 , B419 , B420) ) ) & ( 1 -BitGFA1CarryOutput (<* B418 *> , <* B419 *>) ) = ( GFA1CarryOutput (B418 , B419 , B420) ))))
proof
let C178 , C179 being set;
L475: ( <* C178 *> . 1 ) = C178 by FINSEQ_1:40;
L476: ( <* C179 *> . 1 ) = C179 by FINSEQ_1:40;
thus L477: thesis by L476 , L475 , L464;
end;
theorem
L478: (for B421 being Nat holds (for B422 , B423 being (FinSeqLen of B421) holds (for B424 , B425 , B426 , B427 being FinSequence holds (( B421 -BitGFA1Str (( B422 ^ B424 ) , ( B423 ^ B426 )) ) = ( B421 -BitGFA1Str (( B422 ^ B425 ) , ( B423 ^ B427 )) ) & ( B421 -BitGFA1Circ (( B422 ^ B424 ) , ( B423 ^ B426 )) ) = ( B421 -BitGFA1Circ (( B422 ^ B425 ) , ( B423 ^ B427 )) ) & ( B421 -BitGFA1CarryOutput (( B422 ^ B424 ) , ( B423 ^ B426 )) ) = ( B421 -BitGFA1CarryOutput (( B422 ^ B425 ) , ( B423 ^ B427 )) )))))
proof
let C180 being Nat;
let C181 , C182 being (FinSeqLen of C180);
let C183 , C184 , C185 , C186 being FinSequence;
set D115 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D116 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D117 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
set D118 = ( C180 -BitGFA1Str (( C181 ^ C183 ) , ( C182 ^ C185 )) );
set D119 = ( C180 -BitGFA1Circ (( C181 ^ C183 ) , ( C182 ^ C185 )) );
set D120 = ( C180 -BitGFA1CarryOutput (( C181 ^ C183 ) , ( C182 ^ C185 )) );
deffunc H57(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitGFA1Str (( ( C181 ^ C183 ) . ( $3 + 1 ) ) , ( ( C182 ^ C185 ) . ( $3 + 1 ) ) , $2) ) );
deffunc H58(non  empty ManySortedSign ,  non-empty MSAlgebra over $1 , set , Nat) = ( $2 +* ( BitGFA1Circ (( ( C181 ^ C183 ) . ( $4 + 1 ) ) , ( ( C182 ^ C185 ) . ( $4 + 1 ) ) , $3) ) );
deffunc H59(set , Nat) = ( GFA1CarryOutput (( ( C181 ^ C183 ) . ( $2 + 1 ) ) , ( ( C182 ^ C185 ) . ( $2 + 1 ) ) , $1) );
deffunc H60(Nat , set) = ( GFA1CarryOutput (( ( C181 ^ C183 ) . ( $1 + 1 ) ) , ( ( C182 ^ C185 ) . ( $1 + 1 ) ) , $2) );
consider C187 , C188 , C189 being (ManySortedSet of ( NAT )) such that L479: D118 = ( C187 . C180 ) and L480: D119 = ( C188 . C180 ) and L481: ( C187 . ( 0 ) ) = D115 and L482: ( C188 . ( 0 ) ) = D116 and L483: ( C189 . ( 0 ) ) = D117 and L484: (for B428 being Nat holds (for B429 being non  empty ManySortedSign holds (for B430 being  non-empty MSAlgebra over B429 holds (for B431 being set holds ((B429 = ( C187 . B428 ) & B430 = ( C188 . B428 ) & B431 = ( C189 . B428 )) implies (( C187 . ( B428 + 1 ) ) = H57(B429 , B431 , B428) & ( C188 . ( B428 + 1 ) ) = H58(B429 , B430 , B431 , B428) & ( C189 . ( B428 + 1 ) ) = H59(B431 , B428))))))) by L377;
set D121 = ( C180 -BitGFA1Str (( C181 ^ C184 ) , ( C182 ^ C186 )) );
set D122 = ( C180 -BitGFA1Circ (( C181 ^ C184 ) , ( C182 ^ C186 )) );
set D123 = ( C180 -BitGFA1CarryOutput (( C181 ^ C184 ) , ( C182 ^ C186 )) );
deffunc H61(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitGFA1Str (( ( C181 ^ C184 ) . ( $3 + 1 ) ) , ( ( C182 ^ C186 ) . ( $3 + 1 ) ) , $2) ) );
deffunc H62(non  empty ManySortedSign ,  non-empty MSAlgebra over $1 , set , Nat) = ( $2 +* ( BitGFA1Circ (( ( C181 ^ C184 ) . ( $4 + 1 ) ) , ( ( C182 ^ C186 ) . ( $4 + 1 ) ) , $3) ) );
deffunc H63(set , Nat) = ( GFA1CarryOutput (( ( C181 ^ C184 ) . ( $2 + 1 ) ) , ( ( C182 ^ C186 ) . ( $2 + 1 ) ) , $1) );
deffunc H64(Nat , set) = ( GFA1CarryOutput (( ( C181 ^ C184 ) . ( $1 + 1 ) ) , ( ( C182 ^ C186 ) . ( $1 + 1 ) ) , $2) );
consider C190 , C191 , C192 being (ManySortedSet of ( NAT )) such that L485: D121 = ( C190 . C180 ) and L486: D122 = ( C191 . C180 ) and L487: ( C190 . ( 0 ) ) = D115 and L488: ( C191 . ( 0 ) ) = D116 and L489: ( C192 . ( 0 ) ) = D117 and L490: (for B432 being Nat holds (for B433 being non  empty ManySortedSign holds (for B434 being  non-empty MSAlgebra over B433 holds (for B435 being set holds ((B433 = ( C190 . B432 ) & B434 = ( C191 . B432 ) & B435 = ( C192 . B432 )) implies (( C190 . ( B432 + 1 ) ) = H61(B433 , B435 , B432) & ( C191 . ( B432 + 1 ) ) = H62(B433 , B434 , B435 , B432) & ( C192 . ( B432 + 1 ) ) = H63(B435 , B432))))))) by L377;
defpred S12[ Nat ] means ($1 <= C180 implies (( C189 . $1 ) = ( C192 . $1 ) & ( C187 . $1 ) = ( C190 . $1 ) & ( C188 . $1 ) = ( C191 . $1 )));
L491: S12[ ( 0 ) ] by L481 , L482 , L483 , L487 , L488 , L489;
L492: (for B436 being Nat holds (S12[ B436 ] implies S12[ ( B436 + 1 ) ]))
proof
let C193 being Nat;
assume that
L493: (C193 <= C180 implies (( C189 . C193 ) = ( C192 . C193 ) & ( C187 . C193 ) = ( C190 . C193 ) & ( C188 . C193 ) = ( C191 . C193 )))
and
L494: ( C193 + 1 ) <= C180;
L495: ( len C181 ) = C180 by CARD_1:def 7;
L496: ( len C182 ) = C180 by CARD_1:def 7;
L497: ( dom C181 ) = ( Seg C180 ) by L495 , FINSEQ_1:def 3;
L498: ( dom C182 ) = ( Seg C180 ) by L496 , FINSEQ_1:def 3;
L499: ( ( 0 ) + 1 ) <= ( C193 + 1 ) by XREAL_1:6;
L500: ( C193 + 1 ) in ( Seg C180 ) by L499 , L494 , FINSEQ_1:1;
L501: ( ( C181 ^ C183 ) . ( C193 + 1 ) ) = ( C181 . ( C193 + 1 ) ) by L500 , L497 , FINSEQ_1:def 7;
L502: ( ( C181 ^ C184 ) . ( C193 + 1 ) ) = ( C181 . ( C193 + 1 ) ) by L497 , L500 , FINSEQ_1:def 7;
L503: ( ( C182 ^ C185 ) . ( C193 + 1 ) ) = ( C182 . ( C193 + 1 ) ) by L498 , L500 , FINSEQ_1:def 7;
L504: ( ( C182 ^ C186 ) . ( C193 + 1 ) ) = ( C182 . ( C193 + 1 ) ) by L498 , L500 , FINSEQ_1:def 7;
defpred S13[ set , set , set , set ] means (not contradiction);
L505: (ex B437 being non  empty ManySortedSign st (ex B438 being  non-empty MSAlgebra over B437 st (ex B439 being set st (B437 = ( C187 . ( 0 ) ) & B438 = ( C188 . ( 0 ) ) & B439 = ( C189 . ( 0 ) ) & S13[ B437 , B438 , B439 , ( 0 ) ])))) by L481 , L482;
L506: (for B440 being Nat holds (for B441 being non  empty ManySortedSign holds (for B442 being  non-empty MSAlgebra over B441 holds (for B443 being set holds ((B441 = ( C187 . B440 ) & B442 = ( C188 . B440 ) & B443 = ( C189 . B440 ) & S13[ B441 , B442 , B443 , B440 ]) implies S13[ H57(B441 , B443 , B440) , H58(B441 , B442 , B443 , B440) , H59(B443 , B440) , ( B440 + 1 ) ])))));
L507: (for B444 being non  empty ManySortedSign holds (for B445 being  non-empty MSAlgebra over B444 holds (for B446 being set holds (for B447 being Nat holds H58(B444 , B445 , B446 , B447) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over H57(B444 , B446 , B447)))));
L508: (for B448 being Nat holds (ex B449 being non  empty ManySortedSign st (ex B450 being  non-empty MSAlgebra over B449 st (B449 = ( C187 . B448 ) & B450 = ( C188 . B448 ) & S13[ B449 , B450 , ( C189 . B448 ) , B448 ])))) from CIRCCMB2:sch 13(L505 , L484 , L506 , L507);
consider C194 being non  empty ManySortedSign, C195 being  non-empty MSAlgebra over C194 such that L509: C194 = ( C187 . C193 ) and L510: C195 = ( C188 . C193 ) by L508;
thus L511: ( C189 . ( C193 + 1 ) ) = H63(( C192 . C193 ) , C193) by L484 , L493 , L494 , L501 , L502 , L503 , L504 , L509 , L510 , NAT_1:13
.= ( C192 . ( C193 + 1 ) ) by L490 , L493 , L494 , L509 , L510 , NAT_1:13;
thus L512: ( C187 . ( C193 + 1 ) ) = H61(C194 , ( C192 . C193 ) , C193) by L484 , L493 , L494 , L501 , L502 , L503 , L504 , L509 , L510 , NAT_1:13
.= ( C190 . ( C193 + 1 ) ) by L490 , L493 , L494 , L509 , L510 , NAT_1:13;
thus L513: ( C188 . ( C193 + 1 ) ) = H62(C194 , C195 , ( C192 . C193 ) , C193) by L484 , L493 , L494 , L501 , L502 , L503 , L504 , L509 , L510 , NAT_1:13
.= ( C191 . ( C193 + 1 ) ) by L490 , L493 , L494 , L509 , L510 , NAT_1:13;
end;
L514: (for B451 being Nat holds S12[ B451 ]) from NAT_1:sch 2(L491 , L492);
thus L515: (D118 = D121 & D119 = D122) by L514 , L479 , L480 , L485 , L486;
L516: D120 = ( C189 . C180 ) by L481 , L482 , L483 , L484 , L429;
L517: D123 = ( C192 . C180 ) by L487 , L488 , L489 , L490 , L429;
thus L518: thesis by L517 , L514 , L516;
end;
theorem
L519: (for B452 being Nat holds (for B453 , B454 being (FinSeqLen of B452) holds (for B455 , B456 being set holds (( ( B452 + 1 ) -BitGFA1Str (( B453 ^ <* B455 *> ) , ( B454 ^ <* B456 *> )) ) = ( ( B452 -BitGFA1Str (B453 , B454) ) +* ( BitGFA1Str (B455 , B456 , ( B452 -BitGFA1CarryOutput (B453 , B454) )) ) ) & ( ( B452 + 1 ) -BitGFA1Circ (( B453 ^ <* B455 *> ) , ( B454 ^ <* B456 *> )) ) = ( ( B452 -BitGFA1Circ (B453 , B454) ) +* ( BitGFA1Circ (B455 , B456 , ( B452 -BitGFA1CarryOutput (B453 , B454) )) ) ) & ( ( B452 + 1 ) -BitGFA1CarryOutput (( B453 ^ <* B455 *> ) , ( B454 ^ <* B456 *> )) ) = ( GFA1CarryOutput (B455 , B456 , ( B452 -BitGFA1CarryOutput (B453 , B454) )) )))))
proof
set D124 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D125 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D126 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
let C196 being Nat;
let C197 , C198 being (FinSeqLen of C196);
let C199 , C200 being set;
set D127 = ( C197 ^ <* C199 *> );
set D128 = ( C198 ^ <* C200 *> );
consider C201 , C202 , C203 being (ManySortedSet of ( NAT )) such that L520: ( C196 -BitGFA1Str (D127 , D128) ) = ( C201 . C196 ) and L521: ( C196 -BitGFA1Circ (D127 , D128) ) = ( C202 . C196 ) and L522: ( C201 . ( 0 ) ) = D124 and L523: ( C202 . ( 0 ) ) = D125 and L524: ( C203 . ( 0 ) ) = D126 and L525: (for B457 being Nat holds (for B458 being non  empty ManySortedSign holds (for B459 being  non-empty MSAlgebra over B458 holds (for B460 being set holds ((B458 = ( C201 . B457 ) & B459 = ( C202 . B457 ) & B460 = ( C203 . B457 )) implies (( C201 . ( B457 + 1 ) ) = ( B458 +* ( BitGFA1Str (( D127 . ( B457 + 1 ) ) , ( D128 . ( B457 + 1 ) ) , B460) ) ) & ( C202 . ( B457 + 1 ) ) = ( B459 +* ( BitGFA1Circ (( D127 . ( B457 + 1 ) ) , ( D128 . ( B457 + 1 ) ) , B460) ) ) & ( C203 . ( B457 + 1 ) ) = ( GFA1CarryOutput (( D127 . ( B457 + 1 ) ) , ( D128 . ( B457 + 1 ) ) , B460) ))))))) by L377;
L526: ( C196 -BitGFA1CarryOutput (( C197 ^ <* C199 *> ) , ( C198 ^ <* C200 *> )) ) = ( C203 . C196 ) by L522 , L523 , L524 , L525 , L429;
L527: ( ( C196 + 1 ) -BitGFA1Str (( C197 ^ <* C199 *> ) , ( C198 ^ <* C200 *> )) ) = ( C201 . ( C196 + 1 ) ) by L522 , L523 , L524 , L525 , L429;
L528: ( ( C196 + 1 ) -BitGFA1Circ (( C197 ^ <* C199 *> ) , ( C198 ^ <* C200 *> )) ) = ( C202 . ( C196 + 1 ) ) by L522 , L523 , L524 , L525 , L429;
L529: ( ( C196 + 1 ) -BitGFA1CarryOutput (( C197 ^ <* C199 *> ) , ( C198 ^ <* C200 *> )) ) = ( C203 . ( C196 + 1 ) ) by L522 , L523 , L524 , L525 , L429;
L530: ( len C197 ) = C196 by CARD_1:def 7;
L531: ( len C198 ) = C196 by CARD_1:def 7;
L532: ( D127 . ( C196 + 1 ) ) = C199 by L530 , FINSEQ_1:42;
L533: ( D128 . ( C196 + 1 ) ) = C200 by L531 , FINSEQ_1:42;
L534: ( C197 ^ ( <*> ) ) = C197 by FINSEQ_1:34;
L535: ( C198 ^ ( <*> ) ) = C198 by FINSEQ_1:34;
L536: ( C196 -BitGFA1Str (D127 , D128) ) = ( C196 -BitGFA1Str (C197 , C198) ) by L535 , L534 , L478;
L537: ( C196 -BitGFA1Circ (D127 , D128) ) = ( C196 -BitGFA1Circ (C197 , C198) ) by L534 , L535 , L478;
L538: ( C196 -BitGFA1CarryOutput (D127 , D128) ) = ( C196 -BitGFA1CarryOutput (C197 , C198) ) by L534 , L535 , L478;
thus L539: thesis by L538 , L520 , L521 , L525 , L526 , L527 , L528 , L529 , L532 , L533 , L536 , L537;
end;
theorem
L540: (for B461 being Nat holds (for B462 , B463 being FinSequence holds (( ( B461 + 1 ) -BitGFA1Str (B462 , B463) ) = ( ( B461 -BitGFA1Str (B462 , B463) ) +* ( BitGFA1Str (( B462 . ( B461 + 1 ) ) , ( B463 . ( B461 + 1 ) ) , ( B461 -BitGFA1CarryOutput (B462 , B463) )) ) ) & ( ( B461 + 1 ) -BitGFA1Circ (B462 , B463) ) = ( ( B461 -BitGFA1Circ (B462 , B463) ) +* ( BitGFA1Circ (( B462 . ( B461 + 1 ) ) , ( B463 . ( B461 + 1 ) ) , ( B461 -BitGFA1CarryOutput (B462 , B463) )) ) ) & ( ( B461 + 1 ) -BitGFA1CarryOutput (B462 , B463) ) = ( GFA1CarryOutput (( B462 . ( B461 + 1 ) ) , ( B463 . ( B461 + 1 ) ) , ( B461 -BitGFA1CarryOutput (B462 , B463) )) ))))
proof
set D129 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D130 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D131 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
let C204 being Nat;
let C205 , C206 being FinSequence;
consider C207 , C208 , C209 being (ManySortedSet of ( NAT )) such that L541: ( C204 -BitGFA1Str (C205 , C206) ) = ( C207 . C204 ) and L542: ( C204 -BitGFA1Circ (C205 , C206) ) = ( C208 . C204 ) and L543: ( C207 . ( 0 ) ) = D129 and L544: ( C208 . ( 0 ) ) = D130 and L545: ( C209 . ( 0 ) ) = D131 and L546: (for B464 being Nat holds (for B465 being non  empty ManySortedSign holds (for B466 being  non-empty MSAlgebra over B465 holds (for B467 being set holds ((B465 = ( C207 . B464 ) & B466 = ( C208 . B464 ) & B467 = ( C209 . B464 )) implies (( C207 . ( B464 + 1 ) ) = ( B465 +* ( BitGFA1Str (( C205 . ( B464 + 1 ) ) , ( C206 . ( B464 + 1 ) ) , B467) ) ) & ( C208 . ( B464 + 1 ) ) = ( B466 +* ( BitGFA1Circ (( C205 . ( B464 + 1 ) ) , ( C206 . ( B464 + 1 ) ) , B467) ) ) & ( C209 . ( B464 + 1 ) ) = ( GFA1CarryOutput (( C205 . ( B464 + 1 ) ) , ( C206 . ( B464 + 1 ) ) , B467) ))))))) by L377;
L547: ( C204 -BitGFA1CarryOutput (C205 , C206) ) = ( C209 . C204 ) by L543 , L544 , L545 , L546 , L429;
L548: ( ( C204 + 1 ) -BitGFA1Str (C205 , C206) ) = ( C207 . ( C204 + 1 ) ) by L543 , L544 , L545 , L546 , L429;
L549: ( ( C204 + 1 ) -BitGFA1Circ (C205 , C206) ) = ( C208 . ( C204 + 1 ) ) by L543 , L544 , L545 , L546 , L429;
L550: ( ( C204 + 1 ) -BitGFA1CarryOutput (C205 , C206) ) = ( C209 . ( C204 + 1 ) ) by L543 , L544 , L545 , L546 , L429;
thus L551: thesis by L550 , L541 , L542 , L546 , L547 , L548 , L549;
end;
theorem
L552: (for B468 , B469 being Nat holds (B468 <= B469 implies (for B470 , B471 being FinSequence holds ( InnerVertices ( B468 -BitGFA1Str (B470 , B471) ) ) c= ( InnerVertices ( B469 -BitGFA1Str (B470 , B471) ) ))))
proof
let C210 , C211 being Nat;
assume that
L553: C210 <= C211;
let C212 , C213 being FinSequence;
consider C214 being Nat such that L554: C211 = ( C210 + C214 ) by L553 , NAT_1:10;
defpred S14[ Nat ] means ( InnerVertices ( C210 -BitGFA1Str (C212 , C213) ) ) c= ( InnerVertices ( ( C210 + $1 ) -BitGFA1Str (C212 , C213) ) );
L555: S14[ ( 0 ) ];
L556: (for B472 being Nat holds (S14[ B472 ] implies S14[ ( B472 + 1 ) ]))
proof
let C215 being Nat;
set D132 = ( C210 -BitGFA1Str (C212 , C213) );
set D133 = ( ( C210 + C215 ) -BitGFA1Str (C212 , C213) );
set D134 = ( BitGFA1Str (( C212 . ( ( C210 + C215 ) + 1 ) ) , ( C213 . ( ( C210 + C215 ) + 1 ) ) , ( ( C210 + C215 ) -BitGFA1CarryOutput (C212 , C213) )) );
assume L557: ( InnerVertices D132 ) c= ( InnerVertices D133 );
L558: ( InnerVertices D132 ) c= ( ( InnerVertices D132 ) \/ ( InnerVertices D134 ) ) by XBOOLE_1:7;
L559: ( ( InnerVertices D132 ) \/ ( InnerVertices D134 ) ) c= ( ( InnerVertices D133 ) \/ ( InnerVertices D134 ) ) by L557 , XBOOLE_1:9;
L560: ( InnerVertices D132 ) c= ( ( InnerVertices D133 ) \/ ( InnerVertices D134 ) ) by L559 , L558 , XBOOLE_1:1;
L561: ( InnerVertices D132 ) c= ( InnerVertices ( D133 +* D134 ) ) by L560 , FACIRC_1:27;
thus L562: thesis by L561 , L540;
end;
L563: (for B473 being Nat holds S14[ B473 ]) from NAT_1:sch 2(L555 , L556);
thus L564: thesis by L563 , L554;
end;
theorem
L565: (for B474 being Nat holds (for B475 , B476 being FinSequence holds ( InnerVertices ( ( B474 + 1 ) -BitGFA1Str (B475 , B476) ) ) = ( ( InnerVertices ( B474 -BitGFA1Str (B475 , B476) ) ) \/ ( InnerVertices ( BitGFA1Str (( B475 . ( B474 + 1 ) ) , ( B476 . ( B474 + 1 ) ) , ( B474 -BitGFA1CarryOutput (B475 , B476) )) ) ) )))
proof
let C216 being Nat;
let C217 , C218 being FinSequence;
set D135 = ( C216 -BitGFA1Str (C217 , C218) );
set D136 = ( BitGFA1Str (( C217 . ( C216 + 1 ) ) , ( C218 . ( C216 + 1 ) ) , ( C216 -BitGFA1CarryOutput (C217 , C218) )) );
L566: ( InnerVertices ( D135 +* D136 ) ) = ( ( InnerVertices D135 ) \/ ( InnerVertices D136 ) ) by FACIRC_1:27;
thus L567: thesis by L566 , L540;
end;
definition
let C219 , C220 being Nat;
assume that
L568: C219 >= 1
and
L569: C219 <= C220;
let C221 , C222 being FinSequence;
func (C219 , C220) -BitGFA1AdderOutput (C221 , C222) -> (Element of ( InnerVertices ( C220 -BitGFA1Str (C221 , C222) ) )) means 
:L570: (ex B477 being Nat st (C219 = ( B477 + 1 ) & it = ( GFA1AdderOutput (( C221 . C219 ) , ( C222 . C219 ) , ( B477 -BitGFA1CarryOutput (C221 , C222) )) )));
uniqueness;
existence
proof
consider C223 being Nat such that L571: C219 = ( 1 + C223 ) by L568 , NAT_1:10;
reconsider D137 = C223 as Nat;
deffunc H65(Nat) = ( $1 -BitGFA1Str (C221 , C222) );
deffunc H66(Nat) = ( BitGFA1Str (( C221 . ( $1 + 1 ) ) , ( C222 . ( $1 + 1 ) ) , ( $1 -BitGFA1CarryOutput (C221 , C222) )) );
set D138 = ( GFA1AdderOutput (( C221 . C219 ) , ( C222 . C219 ) , ( D137 -BitGFA1CarryOutput (C221 , C222) )) );
L572: ( InnerVertices H65(C219) ) c= ( InnerVertices H65(C220) ) by L569 , L552;
L573: D138 in ( InnerVertices H66(D137) ) by L571 , GFACIRC1:69;
L574: H65(C219) = ( H65(D137) +* H66(D137) ) by L571 , L540;
reconsider D139 = D138 as (Element of H66(D137)) by L573;
L575: (the carrier of H65(C219)) = ( (the carrier of H66(D137)) \/ (the carrier of H65(D137)) ) by L574 , CIRCCOMB:def 2;
L576: D139 in (the carrier of H65(C219)) by L575 , XBOOLE_0:def 3;
L577: D139 in ( InnerVertices H65(C219) ) by L576 , L573 , L574 , CIRCCOMB:15;
thus L578: thesis by L577 , L571 , L572;
end;
end;
theorem
L580: (for B478 , B479 being Nat holds (B479 < B478 implies (for B480 , B481 being FinSequence holds ( (( B479 + 1 ) , B478) -BitGFA1AdderOutput (B480 , B481) ) = ( GFA1AdderOutput (( B480 . ( B479 + 1 ) ) , ( B481 . ( B479 + 1 ) ) , ( B479 -BitGFA1CarryOutput (B480 , B481) )) ))))
proof
let C224 , C225 being Nat;
assume that
L581: C225 < C224;
let C226 , C227 being FinSequence;
L582: ( C225 + 1 ) >= 1 by NAT_1:11;
L583: ( C225 + 1 ) <= C224 by L581 , NAT_1:13;
L584: (ex B482 being Nat st (( C225 + 1 ) = ( B482 + 1 ) & ( (( C225 + 1 ) , C224) -BitGFA1AdderOutput (C226 , C227) ) = ( GFA1AdderOutput (( C226 . ( C225 + 1 ) ) , ( C227 . ( C225 + 1 ) ) , ( B482 -BitGFA1CarryOutput (C226 , C227) )) ))) by L583 , L582 , L570;
thus L585: thesis by L584;
end;
theorem
L586: (for B483 being Nat holds (for B484 , B485 being FinSequence holds ( InnerVertices ( B483 -BitGFA1Str (B484 , B485) ) ) is Relation))
proof
let C228 being Nat;
let C229 , C230 being FinSequence;
set D140 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
deffunc H67(Nat) = ( $1 -BitGFA1Str (C229 , C230) );
deffunc H68(Nat) = ( BitGFA1Str (( C229 . ( $1 + 1 ) ) , ( C230 . ( $1 + 1 ) ) , ( $1 -BitGFA1CarryOutput (C229 , C230) )) );
defpred S15[ Nat ] means ( InnerVertices H67($1) ) is Relation;
L587: H67(( 0 )) = D140 by L458;
L588: S15[ ( 0 ) ] by L587 , FACIRC_1:38;
L589:
now
let C231 being Nat;
assume L590: S15[ C231 ];
L591: H67(( C231 + 1 )) = ( H67(C231) +* H68(C231) ) by L540;
L592: ( InnerVertices H68(C231) ) is Relation by GFACIRC1:64;
thus L593: S15[ ( C231 + 1 ) ] by L592 , L590 , L591 , FACIRC_1:3;
end;
L594: (for B486 being Nat holds S15[ B486 ]) from NAT_1:sch 2(L588 , L589);
thus L595: thesis by L594;
end;
registration
let C232 being Nat;
let C233 , C234 being FinSequence;
cluster ( C232 -BitGFA1CarryOutput (C233 , C234) ) ->  pair;
coherence
proof
set D141 = ( and2c );
set D142 = ( and2a );
set D143 = ( and2 );
set D144 = ( or3 );
set D145 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
deffunc H69(Nat) = ( $1 -BitGFA1CarryOutput (C233 , C234) );
L596: (ex B487 being (ManySortedSet of ( NAT )) st (H69(( 0 )) = ( B487 . ( 0 ) ) & ( B487 . ( 0 ) ) = D145 & (for B488 being Nat holds ( B487 . ( B488 + 1 ) ) = ( GFA1CarryOutput (( C233 . ( B488 + 1 ) ) , ( C234 . ( B488 + 1 ) ) , ( B487 . B488 )) )))) by L388;
defpred S16[ Nat ] means ( $1 -BitGFA1CarryOutput (C233 , C234) ) is  pair;
L597: S16[ ( 0 ) ] by L596;
L598: (for B489 being Nat holds (S16[ B489 ] implies S16[ ( B489 + 1 ) ]))
proof
let C235 being Nat;
set D146 = ( C235 -BitGFA1CarryOutput (C233 , C234) );
L599: H69(( C235 + 1 )) = ( GFA1CarryOutput (( C233 . ( C235 + 1 ) ) , ( C234 . ( C235 + 1 ) ) , D146) ) by L540
.= [ <* [ <* ( C233 . ( C235 + 1 ) ) , ( C234 . ( C235 + 1 ) ) *> , D141 ] , [ <* ( C234 . ( C235 + 1 ) ) , D146 *> , D142 ] , [ <* D146 , ( C233 . ( C235 + 1 ) ) *> , D143 ] *> , D144 ];
thus L600: thesis by L599;
end;
L601: (for B490 being Nat holds S16[ B490 ]) from NAT_1:sch 2(L597 , L598);
thus L602: thesis by L601;
end;
end;
L604: (for B491 , B492 being FinSequence holds (for B493 being Nat holds ((( ( B493 -BitGFA1CarryOutput (B491 , B492) ) `1 ) = ( <*> ) & ( ( B493 -BitGFA1CarryOutput (B491 , B492) ) `2 ) = ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) & ( proj1 ( ( B493 -BitGFA1CarryOutput (B491 , B492) ) `2 ) ) = ( ( 0 ) -tuples_on ( BOOLEAN ) )) or (( card ( ( B493 -BitGFA1CarryOutput (B491 , B492) ) `1 ) ) = 3 & ( ( B493 -BitGFA1CarryOutput (B491 , B492) ) `2 ) = ( or3 ) & ( proj1 ( ( B493 -BitGFA1CarryOutput (B491 , B492) ) `2 ) ) = ( 3 -tuples_on ( BOOLEAN ) )))))
proof
set D147 = ( and2c );
set D148 = ( and2a );
set D149 = ( and2 );
set D150 = ( or3 );
let C236 , C237 being FinSequence;
defpred S17[ Nat ] means ((( ( $1 -BitGFA1CarryOutput (C236 , C237) ) `1 ) = ( <*> ) & ( ( $1 -BitGFA1CarryOutput (C236 , C237) ) `2 ) = ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) & ( proj1 ( ( $1 -BitGFA1CarryOutput (C236 , C237) ) `2 ) ) = ( ( 0 ) -tuples_on ( BOOLEAN ) )) or (( card ( ( $1 -BitGFA1CarryOutput (C236 , C237) ) `1 ) ) = 3 & ( ( $1 -BitGFA1CarryOutput (C236 , C237) ) `2 ) = D150 & ( proj1 ( ( $1 -BitGFA1CarryOutput (C236 , C237) ) `2 ) ) = ( 3 -tuples_on ( BOOLEAN ) )));
L605: ( dom ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ) = ( ( 0 ) -tuples_on ( BOOLEAN ) ) by FUNCOP_1:13;
L606: ( ( 0 ) -BitGFA1CarryOutput (C236 , C237) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] by L458;
L607: S17[ ( 0 ) ] by L606 , L605 , MCART_1:7;
L608:
now
let C238 being Nat;
assume L609: S17[ C238 ];
set D151 = ( C238 -BitGFA1CarryOutput (C236 , C237) );
L610: ( ( C238 + 1 ) -BitGFA1CarryOutput (C236 , C237) ) = ( GFA1CarryOutput (( C236 . ( C238 + 1 ) ) , ( C237 . ( C238 + 1 ) ) , D151) ) by L540
.= [ <* [ <* ( C236 . ( C238 + 1 ) ) , ( C237 . ( C238 + 1 ) ) *> , D147 ] , [ <* ( C237 . ( C238 + 1 ) ) , D151 *> , D148 ] , [ <* D151 , ( C236 . ( C238 + 1 ) ) *> , D149 ] *> , D150 ];
L611: ( dom D150 ) = ( 3 -tuples_on ( BOOLEAN ) ) by FUNCT_2:def 1;
L612: ( ( ( C238 + 1 ) -BitGFA1CarryOutput (C236 , C237) ) `1 ) = <* [ <* ( C236 . ( C238 + 1 ) ) , ( C237 . ( C238 + 1 ) ) *> , D147 ] , [ <* ( C237 . ( C238 + 1 ) ) , D151 *> , D148 ] , [ <* D151 , ( C236 . ( C238 + 1 ) ) *> , D149 ] *> by L610 , MCART_1:7;
thus L613: S17[ ( C238 + 1 ) ] by L612 , L610 , L611 , FINSEQ_1:45 , MCART_1:7;
end;
thus L614: (for B494 being Nat holds S17[ B494 ]) from NAT_1:sch 2(L607 , L608);
end;
L615: (for B495 being Nat holds (for B496 , B497 being FinSequence holds (for B498 being set holds (for B499 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds ( B495 -BitGFA1CarryOutput (B496 , B497) ) <> [ B498 , B499 ]))))
proof
let C239 being Nat;
let C240 , C241 being FinSequence;
let C242 being set;
let C243 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
L616: ( dom C243 ) = ( 2 -tuples_on ( BOOLEAN ) ) by FUNCT_2:def 1;
L617: ( proj1 ( [ C242 , C243 ] `2 ) ) = ( 2 -tuples_on ( BOOLEAN ) ) by L616;
L618: (( proj1 ( ( C239 -BitGFA1CarryOutput (C240 , C241) ) `2 ) ) = ( ( 0 ) -tuples_on ( BOOLEAN ) ) or ( proj1 ( ( C239 -BitGFA1CarryOutput (C240 , C241) ) `2 ) ) = ( 3 -tuples_on ( BOOLEAN ) )) by L604;
thus L619: thesis by L618 , L617 , FINSEQ_2:110;
end;
theorem
L620: (for B500 , B501 being  nonpair-yielding FinSequence holds (for B502 being Nat holds (( InputVertices ( ( B502 + 1 ) -BitGFA1Str (B500 , B501) ) ) = ( ( InputVertices ( B502 -BitGFA1Str (B500 , B501) ) ) \/ ( ( InputVertices ( BitGFA1Str (( B500 . ( B502 + 1 ) ) , ( B501 . ( B502 + 1 ) ) , ( B502 -BitGFA1CarryOutput (B500 , B501) )) ) ) \ { ( B502 -BitGFA1CarryOutput (B500 , B501) ) } ) ) & ( InnerVertices ( B502 -BitGFA1Str (B500 , B501) ) ) is Relation & ( InputVertices ( B502 -BitGFA1Str (B500 , B501) ) ) is  without_pairs)))
proof
set D152 = ( and2c );
set D153 = ( and2a );
set D154 = ( and2 );
set D155 = ( xor2c );
let C244 , C245 being  nonpair-yielding FinSequence;
deffunc H70(Nat) = ( $1 -BitGFA1Str (C244 , C245) );
deffunc H71(set , Nat) = ( BitGFA1Str (( C244 . ( $2 + 1 ) ) , ( C245 . ( $2 + 1 ) ) , $1) );
deffunc H72(Nat) = ( $1 -BitGFA1CarryOutput (C244 , C245) );
consider C246 being (ManySortedSet of ( NAT )) such that L621: (for B503 being (Element of ( NAT )) holds ( C246 . B503 ) = H72(B503)) from PBOOLE:sch 5;
deffunc H73(Nat) = ( C246 . $1 );
deffunc H74(set , Nat) = ( GFA1CarryOutput (( C244 . ( $2 + 1 ) ) , ( C245 . ( $2 + 1 ) ) , $1) );
set D156 = ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) );
L622: H70(( 0 )) = ( 1GateCircStr (( <*> ) , D156) ) by L458;
L623: ( InnerVertices H70(( 0 )) ) is Relation by L622 , FACIRC_1:38;
L624: ( InputVertices H70(( 0 )) ) is  without_pairs by L622 , FACIRC_1:39;
L625: H73(( 0 )) = H72(( 0 )) by L621;
L626: ( C246 . ( 0 ) ) in ( InnerVertices H70(( 0 )) ) by L625;
L627: (for B504 being Nat holds (for B505 being set holds ( InnerVertices H71(B505 , B504) ) is Relation)) by GFACIRC1:64;
L628:
now
let C247 being Nat;
let C248 being set;
assume that
L629: C248 = H73(C247);
L630: C247 in ( NAT ) by ORDINAL1:def 12;
L631: H73(C247) = H72(C247) by L630 , L621;
L632: C248 <> [ <* ( C244 . ( C247 + 1 ) ) , ( C245 . ( C247 + 1 ) ) *> , D152 ] by L631 , L629 , L615;
L633: C248 <> [ <* ( C244 . ( C247 + 1 ) ) , ( C245 . ( C247 + 1 ) ) *> , D155 ] by L629 , L631 , L615;
thus L634: ( InputVertices H71(C248 , C247) ) = { ( C244 . ( C247 + 1 ) ) , ( C245 . ( C247 + 1 ) ) , C248 } by L633 , L632 , GFACIRC1:65;
end;
L635: (for B506 being Nat holds (for B507 being set holds (B507 = ( C246 . B506 ) implies ( ( InputVertices H71(B507 , B506) ) \ { B507 } ) is  without_pairs)))
proof
let C249 being Nat;
let C250 being set;
assume L636: C250 = H73(C249);
L637: ( InputVertices H71(C250 , C249) ) = { ( C244 . ( C249 + 1 ) ) , ( C245 . ( C249 + 1 ) ) , C250 } by L636 , L628;
thus L638: ( ( InputVertices H71(C250 , C249) ) \ { C250 } ) is  without_pairs
proof
let C251 being  pair set;
assume L639: C251 in ( ( InputVertices H71(C250 , C249) ) \ { C250 } );
L640: C251 in ( InputVertices H71(C250 , C249) ) by L639 , XBOOLE_0:def 5;
L641: (C251 = ( C244 . ( C249 + 1 ) ) or C251 = ( C245 . ( C249 + 1 ) ) or C251 = C250) by L640 , L637 , ENUMSET1:def 1;
L642: (not C251 in { C250 }) by L639 , XBOOLE_0:def 5;
thus L643: contradiction by L642 , L641 , TARSKI:def 1;
end;

end;
L639:
now
let C252 being Nat;
let C253 being non  empty ManySortedSign;
let C254 being set;
assume that
L640: C253 = H70(C252)
and
L641: C254 = ( C246 . C252 );
L642: C252 in ( NAT ) by ORDINAL1:def 12;
L643: C254 = ( C252 -BitGFA1CarryOutput (C244 , C245) ) by L642 , L621 , L641;
L644: H73(( C252 + 1 )) = ( ( C252 + 1 ) -BitGFA1CarryOutput (C244 , C245) ) by L621;
thus L645: H70(( C252 + 1 )) = ( C253 +* H71(C254 , C252) ) by L640 , L643 , L540;
thus L646: ( C246 . ( C252 + 1 ) ) = H74(C254 , C252) by L643 , L644 , L540;
L647: ( InputVertices H71(C254 , C252) ) = { ( C244 . ( C252 + 1 ) ) , ( C245 . ( C252 + 1 ) ) , C254 } by L628 , L641;
thus L648: C254 in ( InputVertices H71(C254 , C252) ) by L647 , ENUMSET1:def 1;
L649: ( InnerVertices H71(C254 , C252) ) = ( ( ( { [ <* ( C244 . ( C252 + 1 ) ) , ( C245 . ( C252 + 1 ) ) *> , D155 ] } \/ { ( GFA1AdderOutput (( C244 . ( C252 + 1 ) ) , ( C245 . ( C252 + 1 ) ) , C254) ) } ) \/ { [ <* ( C244 . ( C252 + 1 ) ) , ( C245 . ( C252 + 1 ) ) *> , D152 ] , [ <* ( C245 . ( C252 + 1 ) ) , C254 *> , D153 ] , [ <* C254 , ( C244 . ( C252 + 1 ) ) *> , D154 ] } ) \/ { ( GFA1CarryOutput (( C244 . ( C252 + 1 ) ) , ( C245 . ( C252 + 1 ) ) , C254) ) } ) by GFACIRC1:63;
L650: H74(C254 , C252) in { H74(C254 , C252) } by TARSKI:def 1;
thus L651: H74(C254 , C252) in ( InnerVertices H71(C254 , C252) ) by L650 , L649 , XBOOLE_0:def 3;
end;
L652: (for B508 being Nat holds (( InputVertices H70(( B508 + 1 )) ) = ( ( InputVertices H70(B508) ) \/ ( ( InputVertices H71(( C246 . B508 ) , B508) ) \ { ( C246 . B508 ) } ) ) & ( InnerVertices H70(B508) ) is Relation & ( InputVertices H70(B508) ) is  without_pairs)) from CIRCCMB2:sch 11(L623 , L624 , L626 , L627 , L635 , L639);
let C255 being Nat;
L653: C255 in ( NAT ) by ORDINAL1:def 12;
L654: ( C246 . C255 ) = ( C255 -BitGFA1CarryOutput (C244 , C245) ) by L653 , L621;
thus L655: thesis by L654 , L652;
end;
theorem
L656: (for B509 being Nat holds (for B510 , B511 being  nonpair-yielding (FinSeqLen of B509) holds ( InputVertices ( B509 -BitGFA1Str (B510 , B511) ) ) = ( ( rng B510 ) \/ ( rng B511 ) )))
proof
set D157 = ( and2c );
set D158 = ( xor2c );
defpred S18[ Nat ] means (for B512 , B513 being  nonpair-yielding (FinSeqLen of $1) holds ( InputVertices ( $1 -BitGFA1Str (B512 , B513) ) ) = ( ( rng B512 ) \/ ( rng B513 ) ));
L657: S18[ ( 0 ) ]
proof
let C256 , C257 being  nonpair-yielding (FinSeqLen of ( 0 ));
set D159 = ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) );
L658: ( ( 0 ) -BitGFA1Str (C256 , C257) ) = ( 1GateCircStr (( <*> ) , D159) ) by L458;
thus L659: ( InputVertices ( ( 0 ) -BitGFA1Str (C256 , C257) ) ) = ( rng ( <*> ) ) by L658 , CIRCCOMB:42
.= ( ( rng C256 ) \/ ( rng C257 ) );
end;
L660: (for B514 being Nat holds (S18[ B514 ] implies S18[ ( B514 + 1 ) ]))
proof
let C258 being Nat;
assume that
L661: S18[ C258 ];
let C259 , C260 being  nonpair-yielding (FinSeqLen of ( C258 + 1 ));
L662: C258 in ( NAT ) by ORDINAL1:def 12;
consider C261 being  nonpair-yielding (FinSeqLen of C258), C262 being non  pair set such that L663: C259 = ( C261 ^ <* C262 *> ) by L662 , FACIRC_2:34;
consider C263 being  nonpair-yielding (FinSeqLen of C258), C264 being non  pair set such that L664: C260 = ( C263 ^ <* C264 *> ) by L662 , FACIRC_2:34;
L665: 1 in ( Seg 1 ) by FINSEQ_1:1;
L666: 1 in ( dom <* C262 *> ) by L665 , FINSEQ_1:def 8;
L667: ( len C261 ) = C258 by CARD_1:def 7;
L668: ( C259 . ( C258 + 1 ) ) = ( <* C262 *> . 1 ) by L667 , L663 , L666 , FINSEQ_1:def 7
.= C262 by FINSEQ_1:def 8;
L669: 1 in ( dom <* C264 *> ) by L665 , FINSEQ_1:def 8;
L670: ( len C263 ) = C258 by CARD_1:def 7;
L671: ( C260 . ( C258 + 1 ) ) = ( <* C264 *> . 1 ) by L670 , L664 , L669 , FINSEQ_1:def 7
.= C264 by FINSEQ_1:def 8;
deffunc H75(Nat) = ( $1 -BitGFA1CarryOutput (C259 , C260) );
L672: { C262 , C264 , H75(C258) } = { H75(C258) , C262 , C264 } by ENUMSET1:59;
L673: ( rng C259 ) = ( ( rng C261 ) \/ ( rng <* C262 *> ) ) by L663 , FINSEQ_1:31
.= ( ( rng C261 ) \/ { C262 } ) by FINSEQ_1:38;
L674: ( rng C260 ) = ( ( rng C263 ) \/ ( rng <* C264 *> ) ) by L664 , FINSEQ_1:31
.= ( ( rng C263 ) \/ { C264 } ) by FINSEQ_1:38;
L675: H75(C258) <> [ <* C262 , C264 *> , D157 ] by L615;
L676: H75(C258) <> [ <* C262 , C264 *> , D158 ] by L615;
L677: C261 = ( C261 ^ ( {} ) ) by FINSEQ_1:34;
L678: C263 = ( C263 ^ ( {} ) ) by FINSEQ_1:34;
L679: ( C258 -BitGFA1Str (C259 , C260) ) = ( C258 -BitGFA1Str (C261 , C263) ) by L678 , L663 , L664 , L677 , L478;
thus L680: ( InputVertices ( ( C258 + 1 ) -BitGFA1Str (C259 , C260) ) ) = ( ( InputVertices ( C258 -BitGFA1Str (C261 , C263) ) ) \/ ( ( InputVertices ( BitGFA1Str (C262 , C264 , H75(C258)) ) ) \ { H75(C258) } ) ) by L679 , L668 , L671 , L620
.= ( ( ( rng C261 ) \/ ( rng C263 ) ) \/ ( ( InputVertices ( BitGFA1Str (C262 , C264 , H75(C258)) ) ) \ { H75(C258) } ) ) by L661
.= ( ( ( rng C261 ) \/ ( rng C263 ) ) \/ ( { C262 , C264 , H75(C258) } \ { H75(C258) } ) ) by L675 , L676 , GFACIRC1:65
.= ( ( ( rng C261 ) \/ ( rng C263 ) ) \/ { C262 , C264 } ) by L672 , ENUMSET1:86
.= ( ( ( rng C261 ) \/ ( rng C263 ) ) \/ ( { C262 } \/ { C264 } ) ) by ENUMSET1:1
.= ( ( ( ( rng C261 ) \/ ( rng C263 ) ) \/ { C262 } ) \/ { C264 } ) by XBOOLE_1:4
.= ( ( ( ( rng C261 ) \/ { C262 } ) \/ ( rng C263 ) ) \/ { C264 } ) by XBOOLE_1:4
.= ( ( rng C259 ) \/ ( rng C260 ) ) by L673 , L674 , XBOOLE_1:4;
end;
thus L681: (for B515 being Nat holds S18[ B515 ]) from NAT_1:sch 2(L657 , L660);
end;
theorem
L682: (for B516 being Nat holds (for B517 , B518 being  nonpair-yielding (FinSeqLen of B516) holds (for B519 being (State of ( B516 -BitGFA1Circ (B517 , B518) )) holds ( Following (B519 , ( 1 + ( 2 * B516 ) )) ) is  stable)))
proof
let C265 being Nat;
let C266 , C267 being  nonpair-yielding (FinSeqLen of C265);
deffunc H76(set , Nat) = ( BitGFA1Str (( C266 . ( $2 + 1 ) ) , ( C267 . ( $2 + 1 ) ) , $1) );
deffunc H77(set , Nat) = ( BitGFA1Circ (( C266 . ( $2 + 1 ) ) , ( C267 . ( $2 + 1 ) ) , $1) );
deffunc H78(set , Nat) = ( GFA1CarryOutput (( C266 . ( $2 + 1 ) ) , ( C267 . ( $2 + 1 ) ) , $1) );
set D160 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D161 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D162 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
L683: C265 in ( NAT ) by ORDINAL1:def 12;
consider C268 being (Function of ( NAT ) , ( NAT )) such that L684: ( C268 . ( 0 ) ) = 1 and L685: ( C268 . 1 ) = 2 and L686: ( C268 . 2 ) = C265 by L683 , FACIRC_2:35;
deffunc H79(Nat) = ( C268 . $1 );
L687: (for B520 being set holds (for B521 being Nat holds H77(B520 , B521) is  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict (Circuit of H76(B520 , B521))));
L688:
now
let C269 being (State of D161);
L689: ( Following (C269 , 1) ) = ( Following C269 ) by FACIRC_1:14;
thus L690: ( Following (C269 , H79(( 0 ))) ) is  stable by L689 , L684 , CIRCCMB2:2;
end;
deffunc H80(Nat) = ( $1 -BitGFA1CarryOutput (C266 , C267) );
consider C270 being (ManySortedSet of ( NAT )) such that L691: (for B522 being (Element of ( NAT )) holds ( C270 . B522 ) = H80(B522)) from PBOOLE:sch 5;
L692: (for B523 being Nat holds (for B524 being set holds (for B525 being  non-empty (Circuit of H76(B524 , B523)) holds ((B524 = ( C270 . B523 ) & B525 = H77(B524 , B523)) implies (for B526 being (State of B525) holds ( Following (B526 , H79(1)) ) is  stable)))))
proof
set D163 = ( and2c );
set D164 = ( xor2c );
let C271 being Nat;
let C272 being set;
let C273 being  non-empty (Circuit of H76(C272 , C271));
assume L693: C272 = ( C270 . C271 );
L694: C271 in ( NAT ) by ORDINAL1:def 12;
L695: C272 = H80(C271) by L694 , L691 , L693;
L696: C272 <> [ <* ( C266 . ( C271 + 1 ) ) , ( C267 . ( C271 + 1 ) ) *> , D163 ] by L695 , L615;
L697: C272 <> [ <* ( C266 . ( C271 + 1 ) ) , ( C267 . ( C271 + 1 ) ) *> , D164 ] by L695 , L615;
thus L698: thesis by L697 , L685 , L696 , GFACIRC1:72;
end;
set D165 = ( C265 -BitGFA1Str (C266 , C267) );
set D166 = ( C265 -BitGFA1Circ (C266 , C267) );
set D167 = ( ( 0 ) -BitGFA1CarryOutput (C266 , C267) );
consider C274 , C275 , C276 being (ManySortedSet of ( NAT )) such that L699: D165 = ( C274 . C265 ) and L700: D166 = ( C275 . C265 ) and L701: ( C274 . ( 0 ) ) = D160 and L702: ( C275 . ( 0 ) ) = D161 and L703: ( C276 . ( 0 ) ) = D162 and L704: (for B527 being Nat holds (for B528 being non  empty ManySortedSign holds (for B529 being  non-empty MSAlgebra over B528 holds (for B530 being set holds ((B528 = ( C274 . B527 ) & B529 = ( C275 . B527 ) & B530 = ( C276 . B527 )) implies (( C274 . ( B527 + 1 ) ) = ( B528 +* H76(B530 , B527) ) & ( C275 . ( B527 + 1 ) ) = ( B529 +* H77(B530 , B527) ) & ( C276 . ( B527 + 1 ) ) = H78(B530 , B527))))))) by L377;
L705:
now
let C277 being set;
assume L706: C277 in ( NAT );
reconsider D168 = C277 as Nat by L706;
thus L707: ( C276 . C277 ) = H80(D168) by L701 , L702 , L703 , L704 , L429
.= ( C270 . C277 ) by L691 , L706;
end;
L708: C276 = C270 by L705 , PBOOLE:3;
L709: (ex B531 , B532 being (ManySortedSet of ( NAT )) st (D165 = ( B531 . H79(2) ) & D166 = ( B532 . H79(2) ) & ( B531 . ( 0 ) ) = D160 & ( B532 . ( 0 ) ) = D161 & ( C270 . ( 0 ) ) = D167 & (for B533 being Nat holds (for B534 being non  empty ManySortedSign holds (for B535 being  non-empty MSAlgebra over B534 holds (for B536 being set holds (for B537 being  non-empty MSAlgebra over H76(B536 , B533) holds ((B534 = ( B531 . B533 ) & B535 = ( B532 . B533 ) & B536 = ( C270 . B533 ) & B537 = H77(B536 , B533)) implies (( B531 . ( B533 + 1 ) ) = ( B534 +* H76(B536 , B533) ) & ( B532 . ( B533 + 1 ) ) = ( B535 +* B537 ) & ( C270 . ( B533 + 1 ) ) = H78(B536 , B533))))))))))
proof
take C274;
take C275;
thus L710: thesis by L686 , L691 , L699 , L700 , L701 , L702 , L704 , L708;
end;
L711: (( InnerVertices D160 ) is Relation & ( InputVertices D160 ) is  without_pairs) by FACIRC_1:38 , FACIRC_1:39;
L712: D167 = D162 by L458;
L713: ( InnerVertices D160 ) = { D162 } by CIRCCOMB:42;
L714: (( C270 . ( 0 ) ) = D167 & D167 in ( InnerVertices D160 )) by L713 , L691 , L712 , TARSKI:def 1;
L715: (for B538 being Nat holds (for B539 being set holds ( InnerVertices H76(B539 , B538) ) is Relation)) by GFACIRC1:64;
L716: (for B540 being Nat holds (for B541 being set holds (B541 = ( C270 . B540 ) implies ( ( InputVertices H76(B541 , B540) ) \ { B541 } ) is  without_pairs)))
proof
set D169 = ( and2c );
set D170 = ( xor2c );
let C278 being Nat;
let C279 being set;
assume that
L717: C279 = ( C270 . C278 );
L718: C278 in ( NAT ) by ORDINAL1:def 12;
L719: C279 = H80(C278) by L718 , L691 , L717;
L720: C279 <> [ <* ( C266 . ( C278 + 1 ) ) , ( C267 . ( C278 + 1 ) ) *> , D169 ] by L719 , L615;
L721: C279 <> [ <* ( C266 . ( C278 + 1 ) ) , ( C267 . ( C278 + 1 ) ) *> , D170 ] by L719 , L615;
L722: ( InputVertices H76(C279 , C278) ) = { ( C266 . ( C278 + 1 ) ) , ( C267 . ( C278 + 1 ) ) , C279 } by L721 , L720 , GFACIRC1:65;
let C280 being  pair set;
assume L723: C280 in ( ( InputVertices H76(C279 , C278) ) \ { C279 } );
L724: C280 in { ( C266 . ( C278 + 1 ) ) , ( C267 . ( C278 + 1 ) ) , C279 } by L723 , L722 , XBOOLE_0:def 5;
L725: (not C280 in { C279 }) by L723 , XBOOLE_0:def 5;
L726: (C280 = ( C266 . ( C278 + 1 ) ) or C280 = ( C267 . ( C278 + 1 ) ) or C280 = C279) by L724 , ENUMSET1:def 1;
thus L727: thesis by L726 , L725 , TARSKI:def 1;
end;
L728: (for B542 being Nat holds (for B543 being set holds (B543 = ( C270 . B542 ) implies (( C270 . ( B542 + 1 ) ) = H78(B543 , B542) & B543 in ( InputVertices H76(B543 , B542) ) & H78(B543 , B542) in ( InnerVertices H76(B543 , B542) )))))
proof
set D171 = ( and2c );
set D172 = ( and2a );
set D173 = ( and2 );
set D174 = ( xor2c );
let C281 being Nat;
let C282 being set;
assume that
L729: C282 = ( C270 . C281 );
L730: C281 in ( NAT ) by ORDINAL1:def 12;
L731: C282 = H80(C281) by L730 , L691 , L729;
L732: ( C270 . ( C281 + 1 ) ) = H80(( C281 + 1 )) by L691;
thus L733: ( C270 . ( C281 + 1 ) ) = H78(C282 , C281) by L732 , L731 , L540;
L734: C282 <> [ <* ( C266 . ( C281 + 1 ) ) , ( C267 . ( C281 + 1 ) ) *> , D171 ] by L731 , L615;
L735: C282 <> [ <* ( C266 . ( C281 + 1 ) ) , ( C267 . ( C281 + 1 ) ) *> , D174 ] by L731 , L615;
L736: ( InputVertices H76(C282 , C281) ) = { ( C266 . ( C281 + 1 ) ) , ( C267 . ( C281 + 1 ) ) , C282 } by L735 , L734 , GFACIRC1:65;
thus L737: C282 in ( InputVertices H76(C282 , C281) ) by L736 , ENUMSET1:def 1;
L738: ( InnerVertices H76(C282 , C281) ) = ( ( ( { [ <* ( C266 . ( C281 + 1 ) ) , ( C267 . ( C281 + 1 ) ) *> , D174 ] } \/ { ( GFA1AdderOutput (( C266 . ( C281 + 1 ) ) , ( C267 . ( C281 + 1 ) ) , C282) ) } ) \/ { [ <* ( C266 . ( C281 + 1 ) ) , ( C267 . ( C281 + 1 ) ) *> , D171 ] , [ <* ( C267 . ( C281 + 1 ) ) , C282 *> , D172 ] , [ <* C282 , ( C266 . ( C281 + 1 ) ) *> , D173 ] } ) \/ { ( GFA1CarryOutput (( C266 . ( C281 + 1 ) ) , ( C267 . ( C281 + 1 ) ) , C282) ) } ) by GFACIRC1:63;
L739: H78(C282 , C281) in { H78(C282 , C281) } by TARSKI:def 1;
thus L740: thesis by L739 , L738 , XBOOLE_0:def 3;
end;
L741: (for B544 being (State of D166) holds ( Following (B544 , ( H79(( 0 )) + ( H79(2) * H79(1) ) )) ) is  stable) from CIRCCMB2:sch 22(L687 , L688 , L692 , L709 , L711 , L714 , L715 , L716 , L728);
thus L742: thesis by L741 , L684 , L685 , L686;
end;
