:: Memory Structures
::  by Andrzej Trybulec
::
:: Received April 28, 2011
:: Copyright (c) 2011-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies STRUCT_0, SUBSET_1, XBOOLE_0, FUNCT_1, NUMBERS, CARD_3, CARD_1,
      FUNCOP_1, FUNCT_4, RELAT_1, TARSKI, CAT_1, FSM_1, SETFAM_1, FINSET_1,
      NAT_1, ARYTM_1, PARTFUN1, ZFMISC_1, AMI_1, ARYTM_3, COMPOS_1, SCMFSA6C,
      XXREAL_0, SUPINF_2, MEMSTR_0, PBOOLE, GOBRD13, QUANTAL1, SCMFSA9A;
 notations TARSKI, XBOOLE_0, ZFMISC_1, MCART_1, SUBSET_1, SETFAM_1, ORDINAL1,
      PBOOLE, FUNCT_7, CARD_1, CARD_3, XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1,
      FINSET_1, NUMBERS, INT_1, NAT_1, NAT_D, FUNCOP_1, FUNCT_4, AFINSQ_1,
      FINSEQ_1, FUNCT_2, DOMAIN_1, VALUED_0, VALUED_1, STRUCT_0, XXREAL_0,
      MEASURE6;
 constructors SETFAM_1, DOMAIN_1, FUNCT_4, XXREAL_0, RELSET_1, FUNCT_7,
      PRE_POLY, PBOOLE, AFINSQ_1, NAT_D, WELLORD2, STRUCT_0;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCT_2,
      FUNCOP_1, FUNCT_4, FINSET_1, XREAL_0, FINSEQ_1, CARD_3, STRUCT_0, INT_1,
      RELSET_1, GRFUNC_1, PRE_POLY, PBOOLE, AFINSQ_1, VALUED_1, XCMPLX_0,
      PARTFUN1, NUMBERS, NAT_1, MEMBERED, FUNCT_7, CARD_1, XXREAL_2, ZFMISC_1,
      SUBSET_1, VALUED_0, XXREAL_0, ORDINAL4, ORDINAL5, MEASURE6;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM, REAL;
 definitions RELAT_1, FUNCOP_1, ORDINAL1, PBOOLE, PARTFUN1, MCART_1, ZFMISC_1,
      TARSKI, STRUCT_0, XBOOLE_0, NAT_1, FUNCT_4, NAT_D, AFINSQ_1,
      VALUED_1, CARD_3, FUNCT_1;
 theorems ZFMISC_1, FUNCT_2, TARSKI, CARD_3, FUNCT_4, FUNCOP_1, FUNCT_1,
      GRFUNC_1, RELAT_1, RELSET_1, XBOOLE_0, XBOOLE_1, ORDINAL1, SUBSET_1,
      FUNCT_7, PARTFUN1, PBOOLE, XREAL_1, NAT_D, NAT_2, STRUCT_0, MEASURE6,
      XTUPLE_0;
 schemes FRAENKEL;

begin
definition
let R2 being set;
struct (ZeroStr) Mem-Struct over R2(# carrier -> set , ZeroF -> (Element of the carrier) , Object-Kind -> (Function of the carrier , R2) , ValuesF -> (ManySortedSet of R2) #);
end;
definition
let R4 being  with_zero set;
func Trivial-Mem R4 ->  strict Mem-Struct over R4 means 
:L2: ((the carrier of it) = { ( 0 ) } & (the ZeroF of it) = ( 0 ) & (the Object-Kind of it) = ( ( 0 ) .--> ( 0 ) ) & (the ValuesF of it) = ( R4 --> ( NAT ) ));
existence
proof
set D1 = ( ( 0 ) .--> ( 0 ) );
L3: ( dom D1 ) = { ( 0 ) } by FUNCOP_1:13;
L4: ( rng D1 ) c= { ( 0 ) } by FUNCOP_1:13;
L5: ( 0 ) in R4 by MEASURE6:def 2;
L6: { ( 0 ) } c= R4 by L5 , ZFMISC_1:31;
L7: ( rng D1 ) c= R4 by L6 , L4 , XBOOLE_1:1;
reconsider D2 = D1 as (Function of { ( 0 ) } , R4) by L7 , L3 , RELSET_1:4;
reconsider D3 = ( 0 ) as (Element of { ( 0 ) }) by TARSKI:def 1;
take Mem-Struct (# { ( 0 ) } , D3 , D2 , ( R4 --> ( NAT ) ) #);
thus L8: thesis;
end;
uniqueness;
end;
registration
let R4 being  with_zero set;
cluster ( Trivial-Mem R4 ) -> 1 -element;
coherence
proof
L10: (the carrier of ( Trivial-Mem R4 )) = { ( 0 ) } by L2;
thus L11: (the carrier of ( Trivial-Mem R4 )) is 1 -element by L10;
end;
end;
registration
let R4 being  with_zero set;
cluster 1 -element for Mem-Struct over R4;
existence
proof
take ( Trivial-Mem R4 );
thus L13: thesis;
end;
end;
notation
let R4 being  with_zero set;
let C1 being Mem-Struct over R4;
synonym IC C1 for 0. C1;
synonym Data-Locations C1 for NonZero C1;
end;
registration
cluster  with_zero -> non  empty for set;
coherence by MEASURE6:def 2;
end;
definition
let R4 being  with_zero set;
let C2 being Mem-Struct over R4;
func the_Values_of C2 -> (ManySortedSet of (the carrier of C2)) equals 
( (the ValuesF of C2) * (the Object-Kind of C2) );
coherence;
end;
definition
let R4 being  with_zero set;
let C3 being Mem-Struct over R4;
mode PartState of C3
 is (the carrier of C3) -defined ( the_Values_of C3 ) -compatible Function;
end;
definition
let R4 being  with_zero set;
let C4 being Mem-Struct over R4;
attr C4 is  with_non-empty_values
means
:L19: ( the_Values_of C4 ) is  non-empty;
end;
registration
let R4 being  with_zero set;
cluster ( Trivial-Mem R4 ) ->  with_non-empty_values;
coherence
proof
let C5 being set;
set D4 = ( Trivial-Mem R4 );
set D5 = ( the_Values_of D4 );
assume L21: C5 in ( dom D5 );
L22: ( (the Object-Kind of D4) . C5 ) in ( dom (the ValuesF of D4) ) by L21 , FUNCT_1:11;
L23: (the ValuesF of D4) = ( R4 --> ( NAT ) ) by L2;
L24: ( (the Object-Kind of D4) . C5 ) in R4 by L23 , L22 , FUNCOP_1:13;
L25: ( D5 . C5 ) = ( (the ValuesF of D4) . ( (the Object-Kind of D4) . C5 ) ) by L21 , FUNCT_1:12
.= ( NAT ) by L24 , L23 , FUNCOP_1:7;
thus L26: ( D5 . C5 ) is non  empty by L25;
end;
end;
registration
let R4 being  with_zero set;
cluster  with_non-empty_values for Mem-Struct over R4;
existence
proof
take ( Trivial-Mem R4 );
thus L28: thesis;
end;
end;
registration
let R4 being  with_zero set;
let C6 being  with_non-empty_values Mem-Struct over R4;
cluster ( the_Values_of C6 ) ->  non-empty;
coherence by L19;
end;
definition
let R4 being  with_zero set;
let C7 being  with_non-empty_values Mem-Struct over R4;
mode State of C7
 is  total (PartState of C7);
end;
definition
let R4 being  with_zero set;
let C8 being Mem-Struct over R4;
mode Object of C8
 is (Element of C8);
end;
begin
definition
let R4 being  with_zero set;
let C9 being non  empty Mem-Struct over R4;
let C10 being (Object of C9);
func ObjectKind C10 -> (Element of R4) equals 
( (the Object-Kind of C9) . C10 );
correctness;
end;
definition
let R4 being  with_zero set;
let C11 being non  empty Mem-Struct over R4;
let C12 being (Object of C11);
func Values C12 equals 
( ( the_Values_of C11 ) . C12 );
correctness;
end;
definition
let R4 being  with_zero set;
let C13 being non  empty Mem-Struct over R4;
attr C13 is  IC-Ins-separated
means
:L35: ( Values ( IC C13 ) ) = ( NAT );
end;
L37: (for R4 being  with_zero set holds ( the_Values_of ( Trivial-Mem R4 ) ) = ( ( 0 ) .--> ( NAT ) ))
proof
let R4 being  with_zero set;
set D6 = ( Trivial-Mem R4 );
set D7 = ( the_Values_of ( Trivial-Mem R4 ) );
set D8 = ( ( 0 ) .--> ( NAT ) );
L38: (the Object-Kind of D6) = ( ( 0 ) .--> ( 0 ) ) by L2;
L39: D7 = ( ( R4 --> ( NAT ) ) * ( ( 0 ) .--> ( 0 ) ) ) by L38 , L2;
L40: ( dom ( R4 --> ( NAT ) ) ) = R4 by FUNCOP_1:13;
L41: ( rng ( ( 0 ) .--> ( 0 ) ) ) = { ( 0 ) } by FUNCOP_1:88;
L42: ( 0 ) in R4 by MEASURE6:def 2;
L43: { ( 0 ) } c= R4 by L42 , ZFMISC_1:31;
L44: ( dom D7 ) = ( dom ( ( 0 ) .--> ( 0 ) ) ) by L43 , L39 , L40 , L41 , RELAT_1:27
.= { ( 0 ) } by FUNCOP_1:13;
thus L45: ( dom D7 ) = ( dom D8 ) by L44 , FUNCOP_1:13;
let C14 being set;
assume L46: C14 in ( dom D7 );
L47: C14 = ( 0 ) by L46 , L44 , TARSKI:def 1;
thus L48: ( D7 . C14 ) = ( ( R4 --> ( NAT ) ) . ( ( ( 0 ) .--> ( 0 ) ) . C14 ) ) by L39 , L46 , FUNCT_1:12
.= ( ( R4 --> ( NAT ) ) . ( 0 ) ) by L47 , FUNCOP_1:72
.= ( NAT ) by L42 , FUNCOP_1:7
.= ( D8 . C14 ) by L47 , FUNCOP_1:72;
end;
registration
let R4 being  with_zero set;
cluster ( Trivial-Mem R4 ) ->  IC-Ins-separated;
coherence
proof
L49: ( IC ( Trivial-Mem R4 ) ) = ( 0 ) by L2;
thus L50: ( Values ( IC ( Trivial-Mem R4 ) ) ) = ( ( ( 0 ) .--> ( NAT ) ) . ( 0 ) ) by L49 , L37
.= ( NAT ) by FUNCOP_1:72;
end;
end;
registration
let R4 being  with_zero set;
cluster  IC-Ins-separated  with_non-empty_values  strict for 1 -element 1 -element 1 -element 1 -element Mem-Struct over R4;
existence
proof
take ( Trivial-Mem R4 );
thus L52: thesis;
end;
end;
definition
let R4 being  with_zero set;
let C15 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C16 being (PartState of C15);
func IC C16 -> (Element of ( NAT )) equals 
( C16 . ( IC C15 ) );
coherence
proof
per cases ;
suppose L54: ( IC C15 ) in ( dom C16 );

consider C17 being (State of C15) such that L55: C16 c= C17 by PBOOLE:141;
reconsider D9 = C17 as (Element of ( product ( the_Values_of C15 ) )) by CARD_3:107;
L56: ( dom ( the_Values_of C15 ) ) = (the carrier of C15) by PARTFUN1:def 2;
L57: ( pi (( product ( the_Values_of C15 ) ) , ( IC C15 )) ) = ( Values ( IC C15 ) ) by L56 , CARD_3:12
.= ( NAT ) by L35;
L58: ( D9 . ( IC C15 ) ) in ( NAT ) by L57 , CARD_3:def 6;
thus L59: thesis by L58 , L54 , L55 , GRFUNC_1:2;
end;
suppose L60: (not ( IC C15 ) in ( dom C16 ));

L61: ( C16 . ( IC C15 ) ) = ( 0 ) by L60 , FUNCT_1:def 2;
thus L62: thesis by L61;
end;
end;
end;
theorem
L65: (for R4 being  with_zero set holds (for B1 being  IC-Ins-separated 1 -element  with_non-empty_values Mem-Struct over R4 holds (for B2 , B3 being (State of B1) holds (( IC B2 ) = ( IC B3 ) implies B2 = B3))))
proof
let R4 being  with_zero set;
let C18 being  IC-Ins-separated 1 -element  with_non-empty_values Mem-Struct over R4;
let C19 , C20 being (State of C18);
assume that
L66: ( IC C19 ) = ( IC C20 );
L67: ( dom C19 ) = (the carrier of C18) by PARTFUN1:def 2;
L68: ( dom C19 ) = ( dom C20 ) by L67 , PARTFUN1:def 2;
L69:
now
let C21 being set;
assume L70: C21 in ( dom C19 );
L71: C21 = ( IC C18 ) by L70 , L67 , STRUCT_0:def 10;
thus L72: ( C19 . C21 ) = ( IC C19 ) by L71
.= ( C20 . C21 ) by L66 , L71;
end;
thus L73: thesis by L69 , L68 , FUNCT_1:2;
end;
registration
let R4 being  with_zero set;
let C22 being non  empty  with_non-empty_values Mem-Struct over R4;
let C23 being (Object of C22);
cluster ( Values C23 ) -> non  empty;
coherence;
end;
registration
let R4 being  with_zero set;
let C24 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C25 being (Object of C24);
let C26 being (Element of ( Values C25 ));
cluster ( C25 .--> C26 ) -> ( the_Values_of C24 ) -compatible;
coherence
proof
set D10 = ( C25 .--> C26 );
L75: ( dom D10 ) = { C25 } by FUNCOP_1:13;
let C27 being set;
assume L76: C27 in ( dom D10 );
L77: C27 = C25 by L76 , L75 , TARSKI:def 1;
L78: ( D10 . C27 ) = C26 by L77 , FUNCOP_1:72;
thus L79: ( D10 . C27 ) in ( ( the_Values_of C24 ) . C27 ) by L78 , L77;
end;
let C28 being (Object of C24);
let C29 being (Element of ( Values C28 ));
cluster ( (C25 , C28) --> (C26 , C29) ) -> ( the_Values_of C24 ) -compatible;
coherence;
end;
theorem
L81: (for R4 being  with_zero set holds (for B4 being non  empty  with_non-empty_values Mem-Struct over R4 holds (for B5 being (State of B4) holds ( IC B4 ) in ( dom B5 ))))
proof
let R4 being  with_zero set;
let C30 being non  empty  with_non-empty_values Mem-Struct over R4;
let C31 being (State of C30);
L82: ( dom C31 ) = (the carrier of C30) by PARTFUN1:def 2;
thus L83: thesis by L82;
end;
definition
let R4 being  with_zero set;
let C32 being Mem-Struct over R4;
let C33 being (PartState of C32);
func DataPart C33 -> (PartState of C32) equals 
( C33 | ( Data-Locations C32 ) );
coherence;
projectivity
 by RELAT_1:72;
end;
definition
let R4 being  with_zero set;
let C34 being Mem-Struct over R4;
let C35 being (PartState of C34);
attr C35 is  data-only
means
:L85: ( dom C35 ) misses { ( IC C34 ) };
end;
registration
let R4 being  with_zero set;
let C36 being Mem-Struct over R4;
cluster  empty ->  data-only for (PartState of C36);
coherence
proof
let C37 being (PartState of C36);
assume L87: C37 is  empty;
thus L88: ( dom C37 ) misses { ( IC C36 ) } by L87 , RELAT_1:38 , XBOOLE_1:65;
end;
end;
registration
let R4 being  with_zero set;
let C38 being Mem-Struct over R4;
cluster  empty for (PartState of C38);
existence
proof
reconsider D11 = ( {} ) as (PartState of C38) by FUNCT_1:104 , RELAT_1:171;
take D11;
thus L90: thesis;
end;
end;
theorem
L92: (for R4 being  with_zero set holds (for B6 being Mem-Struct over R4 holds (for B7 being (PartState of B6) holds (not ( IC B6 ) in ( dom ( DataPart B7 ) )))))
proof
let R4 being  with_zero set;
let C39 being Mem-Struct over R4;
let C40 being (PartState of C39);
assume L93: ( IC C39 ) in ( dom ( DataPart C40 ) );
L94: ( dom ( DataPart C40 ) ) c= ( (the carrier of C39) \ { ( IC C39 ) } ) by RELAT_1:58;
L95: (not ( IC C39 ) in { ( IC C39 ) }) by L94 , L93 , XBOOLE_0:def 5;
thus L96: contradiction by L95 , TARSKI:def 1;
end;
theorem
L97: (for R4 being  with_zero set holds (for B8 being Mem-Struct over R4 holds (for B9 being (PartState of B8) holds { ( IC B8 ) } misses ( dom ( DataPart B9 ) )))) by L92 , ZFMISC_1:50;
theorem
L98: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B10 being  data-only (PartState of R5) holds (for B11 being (PartState of R5) holds (B10 c= B11 iff B10 c= ( DataPart B11 ))))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C41 being  data-only (PartState of R5);
let C42 being (PartState of R5);
set D12 = ( (the carrier of R5) \ { ( IC R5 ) } );
L99: ( C42 | D12 ) c= C42 by RELAT_1:59;
thus L100:now
L101: ( D12 \/ { ( IC R5 ) } ) = ( (the carrier of R5) \/ { ( IC R5 ) } ) by XBOOLE_1:39;
L102: ( dom C41 ) c= (the carrier of R5) by RELAT_1:def 18;
L103: ( dom C41 ) c= ( D12 \/ { ( IC R5 ) } ) by L102 , L101 , XBOOLE_1:10;
assume L104: C41 c= C42;
L105: ( C41 | D12 ) c= ( DataPart C42 ) by L104 , RELAT_1:76;
L106: ( dom C41 ) misses { ( IC R5 ) } by L85;
thus L107: C41 c= ( DataPart C42 ) by L106 , L105 , L103 , RELAT_1:68 , XBOOLE_1:73;
end;
thus L108: thesis by L99 , XBOOLE_1:1;
end;
registration
let R4 being  with_zero set;
let C43 being Mem-Struct over R4;
let C44 being (PartState of C43);
cluster ( DataPart C44 ) ->  data-only;
coherence
proof
thus L109: ( dom ( DataPart C44 ) ) misses { ( IC C43 ) } by L92 , ZFMISC_1:50;
end;
end;
theorem
L111: (for R4 being  with_zero set holds (for B12 being Mem-Struct over R4 holds (for B13 being (PartState of B12) holds (B13 is  data-only iff ( dom B13 ) c= ( Data-Locations B12 )))))
proof
let R4 being  with_zero set;
let C45 being Mem-Struct over R4;
let C46 being (PartState of C45);
thus L112: (C46 is  data-only implies ( dom C46 ) c= ( Data-Locations C45 ))
proof
L113: ( dom C46 ) c= (the carrier of C45) by RELAT_1:def 18;
assume L114: ( dom C46 ) misses { ( IC C45 ) };
thus L115: thesis by L114 , L113 , XBOOLE_1:86;
end;

assume L116: ( dom C46 ) c= ( Data-Locations C45 );
thus L117: ( dom C46 ) misses { ( IC C45 ) } by L116 , XBOOLE_1:106;
end;
theorem
L118: (for R4 being  with_zero set holds (for B14 being Mem-Struct over R4 holds (for B15 being  data-only (PartState of B14) holds ( DataPart B15 ) = B15)))
proof
let R4 being  with_zero set;
let C47 being Mem-Struct over R4;
let C48 being  data-only (PartState of C47);
L119: ( dom C48 ) c= ( Data-Locations C47 ) by L111;
thus L120: thesis by L119 , RELAT_1:68;
end;
theorem
L121: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for R6 being (State of R5) holds ( Data-Locations R5 ) c= ( dom R6 ))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let R6 being (State of R5);
L122: ( dom R6 ) = (the carrier of R5) by PARTFUN1:def 2;
thus L123: thesis by L122;
end;
theorem
L124: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for R6 being (State of R5) holds ( dom ( DataPart R6 ) ) = ( Data-Locations R5 ))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let R6 being (State of R5);
L125: ( Data-Locations R5 ) c= ( dom R6 ) by L121;
thus L126: thesis by L125 , RELAT_1:62;
end;
theorem
L127: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B16 being  data-only (PartState of R5) holds (not ( IC R5 ) in ( dom B16 )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C49 being  data-only (PartState of R5);
L128: ( dom C49 ) c= ( Data-Locations R5 ) by L111;
thus L129: thesis by L128 , STRUCT_0:3;
end;
theorem
L130: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B17 being (PartState of R5) holds (for B18 being  data-only (PartState of R5) holds ( IC ( B17 +* B18 ) ) = ( IC B17 )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C50 being (PartState of R5);
let C51 being  data-only (PartState of R5);
L131: (not ( IC R5 ) in ( dom C51 )) by L127;
thus L132: ( IC ( C50 +* C51 ) ) = ( IC C50 ) by L131 , FUNCT_4:11;
end;
theorem
L133: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B19 being (PartState of R5) holds ( DataPart B19 ) c= B19))) by RELAT_1:59;
theorem
L134: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for R6 being (State of R5) holds ( dom R6 ) = ( { ( IC R5 ) } \/ ( Data-Locations R5 ) ))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let R6 being (State of R5);
L135: ( dom R6 ) = (the carrier of R5) by PARTFUN1:def 2;
thus L136: thesis by L135 , STRUCT_0:4;
end;
theorem
L137: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for R7 being (PartState of R5) holds ( ( dom R7 ) /\ ( Data-Locations R5 ) ) = ( dom ( DataPart R7 ) )))) by RELAT_1:61;
registration
let R4 being  with_zero set;
let C52 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C53 being (Element of ( NAT ));
let C54 being (State of C52);
cluster ( C54 +* (( IC C52 ) , C53) ) -> ( the_Values_of C52 ) -compatible;
coherence
proof
let R1 being set;
assume L138: R1 in ( dom ( C54 +* (( IC C52 ) , C53) ) );
L139: R1 in ( dom C54 ) by L138 , FUNCT_7:30;
per cases ;
suppose L140: R1 = ( IC C52 );

L141: ( ( C54 +* (( IC C52 ) , C53) ) . R1 ) = C53 by L140 , L139 , FUNCT_7:31;
L142: ( Values ( IC C52 ) ) = ( NAT ) by L35;
thus L143: ( ( C54 +* (( IC C52 ) , C53) ) . R1 ) in ( ( the_Values_of C52 ) . R1 ) by L142 , L140 , L141;
end;
suppose L144: R1 <> ( IC C52 );

L145: ( ( C54 +* (( IC C52 ) , C53) ) . R1 ) = ( C54 . R1 ) by L144 , FUNCT_7:32;
thus L146: ( ( C54 +* (( IC C52 ) , C53) ) . R1 ) in ( ( the_Values_of C52 ) . R1 ) by L145 , L139 , FUNCT_1:def 14;
end;
end;
end;
begin
definition
let R4 being  with_zero set;
let C55 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C56 being Nat;
func Start-At (C56 , C55) -> (PartState of C55) equals 
( ( IC C55 ) .--> C56 );
correctness
proof
reconsider D13 = C56 as (Element of ( NAT )) by ORDINAL1:def 12;
L149: ( Values ( IC C55 ) ) = ( NAT ) by L35;
reconsider D14 = D13 as (Element of ( Values ( IC C55 ) )) by L149;
L150: ( ( IC C55 ) .--> D14 ) is (PartState of C55);
thus L151: thesis by L150;
end;
end;
definition
let R4 being  with_zero set;
let C57 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C58 being Nat;
let C59 being (PartState of C57);
attr C59 is C58 -started
means
:L153: (( IC C57 ) in ( dom C59 ) & ( IC C59 ) = C58);
end;
registration
let R4 being  with_zero set;
let C60 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C61 being Nat;
cluster ( Start-At (C61 , C60) ) -> C61 -started non  empty;
coherence
proof
L155: ( dom ( Start-At (C61 , C60) ) ) = { ( IC C60 ) } by FUNCOP_1:13;
thus L156: ( IC C60 ) in ( dom ( Start-At (C61 , C60) ) ) by L155 , TARSKI:def 1;
thus L157: thesis by FUNCOP_1:72;
end;
end;
theorem
L159: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B20 being Nat holds ( IC R5 ) in ( dom ( Start-At (B20 , R5) ) ))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C62 being Nat;
L160: ( dom ( Start-At (C62 , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
thus L161: thesis by L160 , TARSKI:def 1;
end;
theorem
L162: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for R7 being (PartState of R5) holds (for B21 being Nat holds ( IC ( R7 +* ( Start-At (B21 , R5) ) ) ) = B21))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let R7 being (PartState of R5);
let C63 being Nat;
L163: ( IC R5 ) in ( dom ( Start-At (C63 , R5) ) ) by L159;
L164: ( ( Start-At (C63 , R5) ) . ( IC R5 ) ) = C63 by FUNCOP_1:72;
thus L165: thesis by L164 , L163 , FUNCT_4:13;
end;
registration
let R4 being  with_zero set;
let C64 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C65 being Nat;
cluster C65 -started for (State of C64);
existence
proof
take D15 = ( the (State of C64) +* ( Start-At (C65 , C64) ) );
thus L166: ( IC C64 ) in ( dom D15 ) by L81;
thus L167: ( IC D15 ) = C65 by L162;
end;
end;
registration
let R4 being  with_zero set;
let C66 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C67 being Nat;
let C68 being (PartState of C66);
let C69 being C67 -started (PartState of C66);
cluster ( C68 +* C69 ) -> C67 -started;
coherence
proof
L169: ( IC C66 ) in ( dom C69 ) by L153;
L170: ( dom C69 ) c= ( dom ( C68 +* C69 ) ) by FUNCT_4:10;
thus L171: ( IC C66 ) in ( dom ( C68 +* C69 ) ) by L170 , L169;
L172: ( IC C69 ) = C67 by L153;
thus L173: ( IC ( C68 +* C69 ) ) = C67 by L172 , L169 , FUNCT_4:13;
end;
end;
definition
let R4 being  with_zero set;
let C70 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C71 being Nat;
let C72 being (State of C70);
redefine attr C72 is C71 -started
means
( IC C72 ) = C71;
compatibility
proof
thus L175: (C72 is C71 -started implies ( IC C72 ) = C71) by L153;
assume L176: ( IC C72 ) = C71;
thus L177: ( IC C70 ) in ( dom C72 ) by L81;
thus L178: ( IC C72 ) = C71 by L176;
end;
end;
theorem
L180: (for R4 being  with_zero set holds (for B22 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B23 being Nat holds (for B24 being B23 -started (PartState of B22) holds (for B25 being (PartState of B22) holds (B24 c= B25 implies B25 is B23 -started))))))
proof
let R4 being  with_zero set;
let C73 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C74 being Nat;
let C75 being C74 -started (PartState of C73);
L181: ( IC C73 ) in ( dom C75 ) by L153;
L182: ( IC C75 ) = C74 by L153;
let C76 being (PartState of C73);
assume L183: C75 c= C76;
L184: ( dom C75 ) c= ( dom C76 ) by L183 , RELAT_1:11;
thus L185: ( IC C73 ) in ( dom C76 ) by L184 , L181;
thus L186: ( IC C76 ) = C74 by L183 , L182 , L181 , GRFUNC_1:2;
end;
theorem
L187: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B26 being (State of R5) holds ( Start-At (( IC B26 ) , R5) ) = ( B26 | { ( IC R5 ) } ))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C77 being (State of R5);
L188: ( IC R5 ) in ( dom C77 ) by L81;
thus L189: ( Start-At (( IC C77 ) , R5) ) = { [ ( IC R5 ) , ( C77 . ( IC R5 ) ) ] } by FUNCT_4:82
.= ( C77 | { ( IC R5 ) } ) by L188 , GRFUNC_1:28;
end;
theorem
L190: (for R4 being  with_zero set holds (for B27 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B28 being (PartState of B27) holds (( IC B27 ) in ( dom B28 ) implies B28 = ( ( Start-At (( IC B28 ) , B27) ) +* ( DataPart B28 ) )))))
proof
let R4 being  with_zero set;
let C78 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C79 being (PartState of C78);
assume L191: ( IC C78 ) in ( dom C79 );
L192: { ( IC C78 ) } is (Subset of ( dom C79 )) by L191 , SUBSET_1:41;
L193: ( { ( IC C78 ) } \/ ( (the carrier of C78) \ { ( IC C78 ) } ) ) = ( (the carrier of C78) \/ { ( IC C78 ) } ) by XBOOLE_1:39
.= (the carrier of C78) by XBOOLE_1:12;
L194: ( dom C79 ) c= (the carrier of C78) by RELAT_1:def 18;
L195:
now
let C80 being set;
assume L196: C80 in ( dom C79 );
per cases  by L196 , L194 , L193 , XBOOLE_0:def 3;
suppose L197: C80 in { ( IC C78 ) };

L198: { ( IC C78 ) } = ( dom ( Start-At (( IC C79 ) , C78) ) ) by FUNCOP_1:13;
L199: ( IC C78 ) in ( dom ( Start-At (( IC C79 ) , C78) ) ) by L198 , TARSKI:def 1;
L200: ( IC C78 ) in ( ( dom ( Start-At (( IC C79 ) , C78) ) ) \/ ( dom ( DataPart C79 ) ) ) by L199 , XBOOLE_0:def 3;
L201: C80 = ( IC C78 ) by L197 , TARSKI:def 1;
L202: (not ( IC C78 ) in ( dom ( DataPart C79 ) )) by L92;
L203: ( ( ( Start-At (( IC C79 ) , C78) ) +* ( DataPart C79 ) ) . C80 ) = ( ( Start-At (( IC C79 ) , C78) ) . C80 ) by L202 , L201 , L200 , FUNCT_4:def 1
.= ( IC C79 ) by L201 , FUNCOP_1:72;
thus L204: ( C79 . C80 ) = ( ( ( Start-At (( IC C79 ) , C78) ) +* ( DataPart C79 ) ) . C80 ) by L203 , L197 , TARSKI:def 1;
end;
suppose L205: C80 in ( (the carrier of C78) \ { ( IC C78 ) } );

L206: C80 in ( ( dom C79 ) /\ ( (the carrier of C78) \ { ( IC C78 ) } ) ) by L205 , L196 , XBOOLE_0:def 4;
L207: C80 in ( dom ( C79 | ( (the carrier of C78) \ { ( IC C78 ) } ) ) ) by L206 , RELAT_1:61;
L208: ( ( ( Start-At (( IC C79 ) , C78) ) +* ( DataPart C79 ) ) . C80 ) = ( ( DataPart C79 ) . C80 ) by L207 , FUNCT_4:13
.= ( C79 . C80 ) by L207 , FUNCT_1:47;
thus L209: ( C79 . C80 ) = ( ( ( Start-At (( IC C79 ) , C78) ) +* ( DataPart C79 ) ) . C80 ) by L208;
end;
end;
L211: ( dom C79 ) c= (the carrier of C78) by RELAT_1:def 18;
L212: ( dom ( ( Start-At (( IC C79 ) , C78) ) +* ( DataPart C79 ) ) ) = ( ( dom ( Start-At (( IC C79 ) , C78) ) ) \/ ( dom ( DataPart C79 ) ) ) by FUNCT_4:def 1
.= ( { ( IC C78 ) } \/ ( dom ( DataPart C79 ) ) ) by FUNCOP_1:13
.= ( ( ( dom C79 ) /\ { ( IC C78 ) } ) \/ ( dom ( C79 | ( (the carrier of C78) \ { ( IC C78 ) } ) ) ) ) by L192 , XBOOLE_1:28
.= ( ( ( dom C79 ) /\ { ( IC C78 ) } ) \/ ( ( dom C79 ) /\ ( (the carrier of C78) \ { ( IC C78 ) } ) ) ) by RELAT_1:61
.= ( ( dom C79 ) /\ (the carrier of C78) ) by L193 , XBOOLE_1:23
.= ( dom C79 ) by L211 , XBOOLE_1:28;
thus L213: thesis by L212 , L195 , FUNCT_1:2;
end;
theorem
L214: (for R4 being  with_zero set holds (for B29 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B30 being Nat holds ( DataPart ( Start-At (B30 , B29) ) ) = ( {} ))))
proof
let R4 being  with_zero set;
let C81 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C82 being Nat;
L215: ( Data-Locations C81 ) misses { ( IC C81 ) } by XBOOLE_1:79;
L216: ( Data-Locations C81 ) misses ( dom ( Start-At (C82 , C81) ) ) by L215 , FUNCOP_1:13;
thus L217: thesis by L216 , RELAT_1:66;
end;
theorem
L218: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B31 , B32 , B33 being Nat holds (( Start-At (( B31 + B33 ) , R5) ) = ( Start-At (( B32 + B33 ) , R5) ) iff ( Start-At (B31 , R5) ) = ( Start-At (B32 , R5) )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C83 , C84 , C85 being Nat;
thus L219:now
assume L220: ( Start-At (( C83 + C85 ) , R5) ) = ( Start-At (( C84 + C85 ) , R5) );
L221: { [ ( IC R5 ) , ( C83 + C85 ) ] } = ( ( IC R5 ) .--> ( C84 + C85 ) ) by L220 , FUNCT_4:82;
L222: { [ ( IC R5 ) , ( C83 + C85 ) ] } = { [ ( IC R5 ) , ( C84 + C85 ) ] } by L221 , FUNCT_4:82;
L223: [ ( IC R5 ) , ( C83 + C85 ) ] = [ ( IC R5 ) , ( C84 + C85 ) ] by L222 , ZFMISC_1:3;
L224: ( C83 + C85 ) = ( C84 + C85 ) by L223 , XTUPLE_0:1;
thus L225: ( Start-At (C83 , R5) ) = ( Start-At (C84 , R5) ) by L224;
end;
assume L226: ( Start-At (C83 , R5) ) = ( Start-At (C84 , R5) );
L227: { [ ( IC R5 ) , C83 ] } = ( Start-At (C84 , R5) ) by L226 , FUNCT_4:82;
L228: { [ ( IC R5 ) , C83 ] } = { [ ( IC R5 ) , C84 ] } by L227 , FUNCT_4:82;
L229: [ ( IC R5 ) , C83 ] = [ ( IC R5 ) , C84 ] by L228 , ZFMISC_1:3;
thus L230: thesis by L229 , XTUPLE_0:1;
end;
theorem
L231: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B34 , B35 , B36 being Nat holds (( Start-At (B34 , R5) ) = ( Start-At (B35 , R5) ) implies ( Start-At (( B34 -' B36 ) , R5) ) = ( Start-At (( B35 -' B36 ) , R5) )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C86 , C87 , C88 being Nat;
assume L232: ( Start-At (C86 , R5) ) = ( Start-At (C87 , R5) );
L233: { [ ( IC R5 ) , C86 ] } = ( Start-At (C87 , R5) ) by L232 , FUNCT_4:82
.= { [ ( IC R5 ) , C87 ] } by FUNCT_4:82;
L234: [ ( IC R5 ) , C86 ] = [ ( IC R5 ) , C87 ] by L233 , ZFMISC_1:3;
thus L235: thesis by L234 , XTUPLE_0:1;
end;
theorem
L236: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B37 being  data-only (PartState of R5) holds (for B38 being Nat holds B37 tolerates ( Start-At (B38 , R5) )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C89 being  data-only (PartState of R5);
let C90 being Nat;
L237: ( dom ( Start-At (C90 , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L238: ( dom C89 ) misses ( dom ( Start-At (C90 , R5) ) ) by L237 , L127 , ZFMISC_1:50;
thus L239: thesis by L238 , PARTFUN1:56;
end;
theorem
L240: (for R4 being  with_zero set holds (for B39 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B40 being (PartState of B39) holds (( IC B39 ) in ( dom B40 ) implies ( dom B40 ) = ( { ( IC B39 ) } \/ ( dom ( DataPart B40 ) ) )))))
proof
let R4 being  with_zero set;
let C91 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C92 being (PartState of C91);
assume L241: ( IC C91 ) in ( dom C92 );
L242: C92 = ( ( Start-At (( IC C92 ) , C91) ) +* ( DataPart C92 ) ) by L241 , L190;
L243: ( dom C92 ) = ( ( dom ( Start-At (( IC C92 ) , C91) ) ) \/ ( dom ( DataPart C92 ) ) ) by L242 , FUNCT_4:def 1
.= ( { ( IC C91 ) } \/ ( dom ( DataPart C92 ) ) ) by FUNCOP_1:13;
thus L244: thesis by L243;
end;
theorem
L245: (for R4 being  with_zero set holds (for B41 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B42 being (State of B41) holds ( dom B42 ) = ( { ( IC B41 ) } \/ ( dom ( DataPart B42 ) ) )))) by L81 , L240;
theorem
L246: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B43 being (PartState of R5) holds (( IC R5 ) in ( dom B43 ) implies B43 = ( ( DataPart B43 ) +* ( Start-At (( IC B43 ) , R5) ) )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C93 being (PartState of R5);
L247: ( dom ( Start-At (( IC C93 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L248: ( dom ( DataPart C93 ) ) misses ( dom ( Start-At (( IC C93 ) , R5) ) ) by L247 , L92 , ZFMISC_1:50;
L249: ( dom ( Start-At (( IC C93 ) , R5) ) ) misses ( dom ( DataPart C93 ) ) by L247 , L92 , ZFMISC_1:50;
assume L250: ( IC R5 ) in ( dom C93 );
L251: C93 = ( ( Start-At (( IC C93 ) , R5) ) +* ( DataPart C93 ) ) by L250 , L190;
L252: C93 = ( ( Start-At (( IC C93 ) , R5) ) \/ ( DataPart C93 ) ) by L251 , L249 , FUNCT_4:31;
thus L253: thesis by L248 , L252 , FUNCT_4:31;
end;
theorem
L254: (for R3 being Nat holds (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for R7 being (PartState of R5) holds ( IC R5 ) in ( dom ( R7 +* ( Start-At (R3 , R5) ) ) )))))
proof
let R3 being Nat;
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let R7 being (PartState of R5);
L255: ( dom ( Start-At (R3 , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L256: ( IC R5 ) in ( dom ( Start-At (R3 , R5) ) ) by L255 , TARSKI:def 1;
thus L257: thesis by L256 , FUNCT_4:12;
end;
theorem
L258: (for R3 being Nat holds (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for R6 being (State of R5) holds (for R7 being (PartState of R5) holds (( R7 +* ( Start-At (R3 , R5) ) ) c= R6 implies ( IC R6 ) = R3))))))
proof
let R3 being Nat;
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let R6 being (State of R5);
let R7 being (PartState of R5);
assume L259: ( R7 +* ( Start-At (R3 , R5) ) ) c= R6;
L260: ( IC R5 ) in ( dom ( R7 +* ( Start-At (R3 , R5) ) ) ) by L254;
thus L261: ( IC R6 ) = ( IC ( R7 +* ( Start-At (R3 , R5) ) ) ) by L260 , L259 , GRFUNC_1:2
.= R3 by L162;
end;
theorem
L262: (for R4 being  with_zero set holds (for B44 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B45 being Nat holds (for B46 being (PartState of B44) holds (B46 is B45 -started iff ( Start-At (B45 , B44) ) c= B46)))))
proof
let R4 being  with_zero set;
let C94 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C95 being Nat;
let C96 being (PartState of C94);
L263: ( dom ( Start-At (C95 , C94) ) ) = { ( IC C94 ) } by FUNCOP_1:13;
thus L264: (C96 is C95 -started implies ( Start-At (C95 , C94) ) c= C96)
proof
assume L265: C96 is C95 -started;
L266: ( IC C94 ) in ( dom C96 ) by L265 , L153;
L267: ( dom ( Start-At (C95 , C94) ) ) c= ( dom C96 ) by L266 , L263 , ZFMISC_1:31;
L268: (for R1 being set holds (R1 in ( dom ( Start-At (C95 , C94) ) ) implies ( ( Start-At (C95 , C94) ) . R1 ) = ( C96 . R1 )))
proof
let R1 being set;
assume L269: R1 in ( dom ( Start-At (C95 , C94) ) );
thus L270: ( ( Start-At (C95 , C94) ) . R1 ) = ( IC ( Start-At (C95 , C94) ) ) by L269 , L263 , TARSKI:def 1
.= C95 by FUNCOP_1:72
.= ( IC C96 ) by L265 , L153
.= ( C96 . R1 ) by L263 , L269 , TARSKI:def 1;
end;
thus L271: ( Start-At (C95 , C94) ) c= C96 by L268 , L267 , GRFUNC_1:2;
end;

assume L272: ( Start-At (C95 , C94) ) c= C96;
L273: ( dom ( Start-At (C95 , C94) ) ) c= ( dom C96 ) by L272 , RELAT_1:11;
L274: ( IC C94 ) in ( dom ( Start-At (C95 , C94) ) ) by L263 , TARSKI:def 1;
thus L275: ( IC C94 ) in ( dom C96 ) by L274 , L273;
thus L276: ( IC C96 ) = ( IC ( Start-At (C95 , C94) ) ) by L272 , L274 , GRFUNC_1:2
.= C95 by FUNCOP_1:72;
end;
registration
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C97 being Nat;
let C98 being C97 -started (PartState of R5);
let C99 being  data-only (PartState of R5);
cluster ( C98 +* C99 ) -> C97 -started;
coherence
proof
L277: ( IC R5 ) in ( dom C98 ) by L153;
L278: ( dom ( C98 +* C99 ) ) = ( ( dom C98 ) \/ ( dom C99 ) ) by FUNCT_4:def 1;
thus L279: ( IC R5 ) in ( dom ( C98 +* C99 ) ) by L278 , L277 , XBOOLE_0:def 3;
L280: (not ( IC R5 ) in ( dom C99 )) by L127;
thus L281: ( IC ( C98 +* C99 ) ) = ( IC C98 ) by L280 , FUNCT_4:11
.= C97 by L153;
end;
end;
theorem
L283: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for R6 being (State of R5) holds ( Start-At (( IC R6 ) , R5) ) c= R6)))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let R6 being (State of R5);
L284: ( Start-At (( IC R6 ) , R5) ) = ( R6 | { ( IC R5 ) } ) by L187;
thus L285: thesis by L284 , RELAT_1:59;
end;
theorem
L286: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B47 being (State of R5) holds ( B47 +* ( Start-At (( IC B47 ) , R5) ) ) = B47))) by L283 , FUNCT_4:98;
theorem
L287: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for R7 being (PartState of R5) holds ( dom R7 ) c= ( { ( IC R5 ) } \/ ( dom ( DataPart R7 ) ) ))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let R7 being (PartState of R5);
set D16 = ( Start-At (( 0 ) , R5) );
per cases ;
suppose L288: ( IC R5 ) in ( dom R7 );

thus L289: thesis by L288 , L240;
end;
suppose L290: (not ( IC R5 ) in ( dom R7 ));

L291: ( dom D16 ) = { ( IC R5 ) } by FUNCOP_1:13;
L292: ( dom ( R7 +* D16 ) ) = ( { ( IC R5 ) } \/ ( dom ( DataPart ( R7 +* D16 ) ) ) ) by L240 , L254
.= ( { ( IC R5 ) } \/ ( dom ( ( DataPart R7 ) +* ( DataPart D16 ) ) ) ) by FUNCT_4:71
.= ( { ( IC R5 ) } \/ ( dom ( ( DataPart R7 ) +* ( {} ) ) ) ) by L214
.= ( { ( IC R5 ) } \/ ( dom ( DataPart R7 ) ) );
L293:
now
assume L294: ( dom R7 ) meets ( dom D16 );
consider R1 being set such that L295: R1 in ( dom R7 ) and L296: R1 in ( dom D16 ) by L294 , XBOOLE_0:3;
thus L297: contradiction by L295 , L290 , L291 , L296 , TARSKI:def 1;
end;
L298: R7 c= ( R7 +* D16 ) by L293 , FUNCT_4:32;
thus L299: ( dom R7 ) c= ( { ( IC R5 ) } \/ ( dom ( DataPart R7 ) ) ) by L298 , L292 , RELAT_1:11;
end;
end;
theorem
L301: (for R4 being  with_zero set holds (for B48 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B49 being (State of B48) holds B49 = ( B49 | ( ( Data-Locations B48 ) \/ { ( IC B48 ) } ) ))))
proof
let R4 being  with_zero set;
let C100 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C101 being (State of C100);
thus L302: C101 = ( C101 | ( dom C101 ) )
.= ( C101 | ( { ( IC C100 ) } \/ ( dom ( DataPart C101 ) ) ) ) by L81 , L240
.= ( C101 | ( ( Data-Locations C100 ) \/ { ( IC C100 ) } ) ) by L124;
end;
theorem
L303: (for R4 being  with_zero set holds (for B50 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B51 , B52 being (State of B50) holds (( B51 | ( ( Data-Locations B50 ) \/ { ( IC B50 ) } ) ) = ( B52 | ( ( Data-Locations B50 ) \/ { ( IC B50 ) } ) ) implies B51 = B52))))
proof
let R4 being  with_zero set;
let C102 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C103 , C104 being (State of C102);
L304: C103 = ( C103 | ( ( Data-Locations C102 ) \/ { ( IC C102 ) } ) ) by L301;
thus L305: thesis by L304 , L301;
end;
theorem
L306: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for R7 being (PartState of R5) holds (( IC R5 ) in ( dom R7 ) implies R7 = ( ( Start-At (( IC R7 ) , R5) ) +* ( DataPart R7 ) ))))) by L190;
theorem
L307: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B53 being (PartState of R5) holds (for B54 , B55 being Nat holds ( ( B53 +* ( Start-At (B54 , R5) ) ) +* ( Start-At (B55 , R5) ) ) = ( B53 +* ( Start-At (B55 , R5) ) )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C105 being (PartState of R5);
let C106 , C107 being Nat;
L308: ( dom ( Start-At (C106 , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13
.= ( dom ( Start-At (C107 , R5) ) ) by FUNCOP_1:13;
thus L309: ( ( C105 +* ( Start-At (C106 , R5) ) ) +* ( Start-At (C107 , R5) ) ) = ( C105 +* ( Start-At (C107 , R5) ) ) by L308 , FUNCT_4:74;
end;
theorem
L310: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B56 being (PartState of R5) holds (( IC R5 ) in ( dom B56 ) implies ( B56 +* ( Start-At (( IC B56 ) , R5) ) ) = B56)))) by FUNCT_4:7 , FUNCT_4:98;
theorem
L311: (for R3 being Nat holds (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for R6 being (State of R5) holds (for R7 being (PartState of R5) holds (( R7 +* ( Start-At (R3 , R5) ) ) c= R6 implies ( IC R6 ) = R3))))))
proof
let R3 being Nat;
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let R6 being (State of R5);
let R7 being (PartState of R5);
assume L312: ( R7 +* ( Start-At (R3 , R5) ) ) c= R6;
L313: ( IC R5 ) in ( dom ( R7 +* ( Start-At (R3 , R5) ) ) ) by L254;
thus L314: ( IC R6 ) = ( IC ( R7 +* ( Start-At (R3 , R5) ) ) ) by L313 , L312 , GRFUNC_1:2
.= R3 by L162;
end;
theorem
L315: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B57 being (PartState of R5) holds (( Start-At (( 0 ) , R5) ) c= B57 implies ( IC B57 ) = ( 0 )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C108 being (PartState of R5);
L316: ( IC ( Start-At (( 0 ) , R5) ) ) = ( 0 ) by L153;
L317: ( IC R5 ) in ( dom ( Start-At (( 0 ) , R5) ) ) by L153;
thus L318: thesis by L317 , L316 , GRFUNC_1:2;
end;
theorem
L319: (for R3 being Nat holds (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B58 being (PartState of R5) holds (( Start-At (R3 , R5) ) c= B58 implies ( IC B58 ) = R3)))))
proof
let R3 being Nat;
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C109 being (PartState of R5);
assume L320: ( Start-At (R3 , R5) ) c= C109;
L321: C109 is R3 -started by L320 , L262;
thus L322: ( IC C109 ) = R3 by L321 , L153;
end;
registration
let R4 being  with_zero set;
let C110 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
cluster non  empty for (PartState of C110);
existence
proof
take ( Start-At (( 0 ) , C110) );
thus L323: thesis;
end;
end;
theorem
L325: (for R4 being  with_zero set holds (for B59 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B60 being non  empty (PartState of B59) holds ( dom B60 ) meets ( { ( IC B59 ) } \/ ( Data-Locations B59 ) ))))
proof
let R4 being  with_zero set;
let C111 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C112 being non  empty (PartState of C111);
L326: ( dom C112 ) c= (the carrier of C111) by RELAT_1:def 18;
L327: ( dom C112 ) meets (the carrier of C111) by L326 , XBOOLE_1:69;
thus L328: ( dom C112 ) meets ( { ( IC C111 ) } \/ ( Data-Locations C111 ) ) by L327 , STRUCT_0:4;
end;
begin
definition
let R4 being  with_zero set;
let C113 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C114 being (PartState of C113);
func Initialize C114 -> (PartState of C113) equals 
( C114 +* ( Start-At (( 0 ) , C113) ) );
coherence;
projectivity
proof
let C115 , C116 being (PartState of C113);
assume L329: C115 = ( C116 +* ( Start-At (( 0 ) , C113) ) );
thus L330: C115 = ( ( C116 +* ( Start-At (( 0 ) , C113) ) ) +* ( Start-At (( 0 ) , C113) ) ) by L329
.= ( C115 +* ( Start-At (( 0 ) , C113) ) ) by L329;
end;
end;
registration
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C117 being (PartState of R5);
cluster ( Initialize C117 ) -> ( 0 ) -started;
coherence;
end;
theorem
L333: (for R4 being  with_zero set holds (for B61 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B62 being (PartState of B61) holds ( dom ( Initialize B62 ) ) = ( ( dom B62 ) \/ { ( IC B61 ) } ))))
proof
let R4 being  with_zero set;
let C118 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C119 being (PartState of C118);
thus L334: ( dom ( Initialize C119 ) ) = ( ( dom C119 ) \/ ( dom ( Start-At (( 0 ) , C118) ) ) ) by FUNCT_4:def 1
.= ( ( dom C119 ) \/ { ( IC C118 ) } ) by FUNCOP_1:13;
end;
theorem
L335: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for R7 being (PartState of R5) holds (for B63 being set holds (B63 in ( dom ( Initialize R7 ) ) implies (B63 in ( dom R7 ) or B63 = ( IC R5 )))))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let R7 being (PartState of R5);
let C120 being set;
assume L336: C120 in ( dom ( Initialize R7 ) );
L337: ( dom ( Initialize R7 ) ) = ( ( dom R7 ) \/ { ( IC R5 ) } ) by L333;
L338: (C120 in ( dom R7 ) or C120 in { ( IC R5 ) }) by L337 , L336 , XBOOLE_0:def 3;
thus L339: thesis by L338 , TARSKI:def 1;
end;
theorem
L340: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B64 being ( 0 ) -started (PartState of R5) holds ( Initialize B64 ) = B64)))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C121 being ( 0 ) -started (PartState of R5);
L341: (( IC R5 ) in ( dom C121 ) & ( IC C121 ) = ( 0 )) by L153;
thus L342: ( Initialize C121 ) = C121 by L341 , FUNCT_4:85 , FUNCT_4:98;
end;
theorem
L343: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B65 being (PartState of R5) holds ( DataPart ( Initialize B65 ) ) = ( DataPart B65 ))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C122 being (PartState of R5);
thus L344: ( DataPart ( Initialize C122 ) ) = ( ( DataPart C122 ) +* ( DataPart ( Start-At (( 0 ) , R5) ) ) ) by FUNCT_4:71
.= ( ( DataPart C122 ) +* ( {} ) ) by L214
.= ( DataPart C122 );
end;
theorem
L345: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B66 being (State of R5) holds (( IC B66 ) = ( 0 ) implies ( Initialize B66 ) = B66))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C123 being (State of R5);
assume L346: ( IC C123 ) = ( 0 );
L347: ( IC R5 ) in ( dom C123 ) by L81;
thus L348: ( Initialize C123 ) = C123 by L346 , L347 , FUNCT_7:109;
end;
registration
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C124 being (State of R5);
cluster ( Initialize C124 ) ->  total;
coherence;
end;
theorem
L350: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for R6 being (State of R5) holds (for B67 being (PartState of R5) holds (( Initialize B67 ) c= R6 implies ( IC R6 ) = ( 0 ))))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let R6 being (State of R5);
let C125 being (PartState of R5);
L351: ( IC ( Initialize C125 ) ) = ( 0 ) by L153;
L352: ( IC R5 ) in ( dom ( Initialize C125 ) ) by L153;
assume L353: ( Initialize C125 ) c= R6;
thus L354: thesis by L353 , L351 , L352 , GRFUNC_1:2;
end;
theorem
L355: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B68 being (PartState of R5) holds ( IC R5 ) in ( dom ( Initialize B68 ) ))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C126 being (PartState of R5);
L356: ( dom ( Initialize C126 ) ) = ( ( dom C126 ) \/ { ( IC R5 ) } ) by L333;
L357: ( IC R5 ) in { ( IC R5 ) } by TARSKI:def 1;
thus L358: ( IC R5 ) in ( dom ( Initialize C126 ) ) by L357 , L356 , XBOOLE_0:def 3;
end;
theorem
L359: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B69 , B70 being (PartState of R5) holds ( IC R5 ) in ( dom ( B69 +* ( Initialize B70 ) ) ))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C127 , C128 being (PartState of R5);
L360: ( dom ( C127 +* ( Initialize C128 ) ) ) = ( ( dom C127 ) \/ ( dom ( Initialize C128 ) ) ) by FUNCT_4:def 1;
L361: ( IC R5 ) in ( dom ( Initialize C128 ) ) by L355;
thus L362: ( IC R5 ) in ( dom ( C127 +* ( Initialize C128 ) ) ) by L361 , L360 , XBOOLE_0:def 3;
end;
theorem
L363: (for R4 being  with_zero set holds (for B71 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B72 , B73 being (PartState of B71) holds (( Initialize B72 ) c= B73 implies ( Start-At (( 0 ) , B71) ) c= B73))))
proof
let R4 being  with_zero set;
let C129 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C130 , C131 being (PartState of C129);
L364: ( Start-At (( 0 ) , C129) ) c= ( Initialize C130 ) by FUNCT_4:25;
thus L365: thesis by L364 , XBOOLE_1:1;
end;
begin
definition
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C132 being (PartState of R5);
let C133 being Nat;
func IncIC (C132 , C133) -> (PartState of R5) equals 
( C132 +* ( Start-At (( ( IC C132 ) + C133 ) , R5) ) );
correctness;
end;
theorem
L367: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B74 being (PartState of R5) holds (for B75 being Nat holds ( DataPart ( IncIC (B74 , B75) ) ) = ( DataPart B74 )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C134 being (PartState of R5);
let C135 being Nat;
thus L368: ( DataPart ( IncIC (C134 , C135) ) ) = ( ( DataPart C134 ) +* ( DataPart ( Start-At (( ( IC C134 ) + C135 ) , R5) ) ) ) by FUNCT_4:71
.= ( ( DataPart C134 ) +* ( {} ) ) by L214
.= ( DataPart C134 );
end;
theorem
L369: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B76 being (PartState of R5) holds (for B77 being Nat holds ( IC R5 ) in ( dom ( IncIC (B76 , B77) ) )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C136 being (PartState of R5);
let C137 being Nat;
L370: ( dom ( IncIC (C136 , C137) ) ) = ( ( dom C136 ) \/ ( dom ( Start-At (( ( IC C136 ) + C137 ) , R5) ) ) ) by FUNCT_4:def 1;
L371: ( IC R5 ) in ( dom ( Start-At (( ( IC C136 ) + C137 ) , R5) ) ) by L159;
thus L372: thesis by L371 , L370 , XBOOLE_0:def 3;
end;
theorem
L373: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B78 being (PartState of R5) holds (for B79 being Nat holds ( IC ( IncIC (B78 , B79) ) ) = ( ( IC B78 ) + B79 )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C138 being (PartState of R5);
let C139 being Nat;
L374: ( dom ( Start-At (( ( IC C138 ) + C139 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L375: ( IC R5 ) in ( dom ( Start-At (( ( IC C138 ) + C139 ) , R5) ) ) by L374 , TARSKI:def 1;
thus L376: ( IC ( IncIC (C138 , C139) ) ) = ( ( Start-At (( ( IC C138 ) + C139 ) , R5) ) . ( IC R5 ) ) by L375 , FUNCT_4:13
.= ( ( IC C138 ) + C139 ) by FUNCOP_1:72;
end;
theorem
L377: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for R7 being (PartState of R5) holds (for B80 being  data-only (PartState of R5) holds (for B81 being Nat holds ( IncIC (( R7 +* B80 ) , B81) ) = ( ( IncIC (R7 , B81) ) +* B80 ))))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let R7 being (PartState of R5);
let C140 being  data-only (PartState of R5);
let C141 being Nat;
L378: C140 tolerates ( Start-At (( ( IC R7 ) + C141 ) , R5) ) by L236;
thus L379: ( IncIC (( R7 +* C140 ) , C141) ) = ( ( R7 +* C140 ) +* ( Start-At (( ( IC R7 ) + C141 ) , R5) ) ) by L130
.= ( R7 +* ( C140 +* ( Start-At (( ( IC R7 ) + C141 ) , R5) ) ) ) by FUNCT_4:14
.= ( R7 +* ( ( Start-At (( ( IC R7 ) + C141 ) , R5) ) +* C140 ) ) by L378 , FUNCT_4:34
.= ( ( IncIC (R7 , C141) ) +* C140 ) by FUNCT_4:14;
end;
theorem
L380: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B82 being (PartState of R5) holds (for B83 being Nat holds ( Start-At (( ( IC B82 ) + B83 ) , R5) ) c= ( IncIC (B82 , B83) )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C142 being (PartState of R5);
let C143 being Nat;
L381: ( IC ( IncIC (C142 , C143) ) ) = ( ( IC C142 ) + C143 ) by L373;
L382: ( IC R5 ) in ( dom ( IncIC (C142 , C143) ) ) by L369;
L383: (( Start-At (( ( IC C142 ) + C143 ) , R5) ) = { [ ( IC R5 ) , ( ( IC C142 ) + C143 ) ] } & [ ( IC R5 ) , ( ( IC C142 ) + C143 ) ] in ( IncIC (C142 , C143) )) by L382 , L381 , FUNCT_1:def 2 , FUNCT_4:82;
L384: (for B84 being set holds (B84 in ( Start-At (( ( IC C142 ) + C143 ) , R5) ) implies B84 in ( IncIC (C142 , C143) ))) by L383 , TARSKI:def 1;
thus L385: thesis by L384 , TARSKI:def 3;
end;
theorem
L386: (for R3 being Nat holds (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B85 being (PartState of R5) holds (( IC R5 ) in ( dom B85 ) implies ( IncIC (B85 , R3) ) = ( ( DataPart B85 ) +* ( Start-At (( ( IC B85 ) + R3 ) , R5) ) ))))))
proof
let R3 being Nat;
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C144 being (PartState of R5);
L387: ( dom ( Start-At (( ( IC C144 ) + R3 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13
.= ( dom ( Start-At (( IC C144 ) , R5) ) ) by FUNCOP_1:13;
assume L388: ( IC R5 ) in ( dom C144 );
thus L389: ( IncIC (C144 , R3) ) = ( ( ( DataPart C144 ) +* ( Start-At (( IC C144 ) , R5) ) ) +* ( Start-At (( ( IC C144 ) + R3 ) , R5) ) ) by L388 , L246
.= ( ( DataPart C144 ) +* ( Start-At (( ( IC C144 ) + R3 ) , R5) ) ) by L387 , FUNCT_4:74;
end;
registration
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C145 being (State of R5);
let C146 being Nat;
cluster ( IncIC (C145 , C146) ) ->  total;
coherence;
end;
theorem
L391: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B86 being (PartState of R5) holds (for B87 , B88 being Nat holds ( IncIC (( IncIC (B86 , B87) ) , B88) ) = ( IncIC (B86 , ( B87 + B88 )) )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C147 being (PartState of R5);
let C148 , C149 being Nat;
thus L392: ( IncIC (( IncIC (C147 , C148) ) , C149) ) = ( ( C147 +* ( Start-At (( ( IC C147 ) + C148 ) , R5) ) ) +* ( Start-At (( ( ( IC C147 ) + C148 ) + C149 ) , R5) ) ) by L373
.= ( IncIC (C147 , ( C148 + C149 )) ) by FUNCT_4:114;
end;
theorem
L393: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B89 being (PartState of R5) holds (for B90 , B91 being Nat holds ( IncIC (( B89 +* ( Start-At (B90 , R5) ) ) , B91) ) = ( B89 +* ( Start-At (( B90 + B91 ) , R5) ) )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C150 being (PartState of R5);
let C151 , C152 being Nat;
thus L394: ( IncIC (( C150 +* ( Start-At (C151 , R5) ) ) , C152) ) = ( C150 +* ( Start-At (( ( IC ( C150 +* ( Start-At (C151 , R5) ) ) ) + C152 ) , R5) ) ) by FUNCT_4:114
.= ( C150 +* ( Start-At (( C151 + C152 ) , R5) ) ) by L162;
end;
theorem
L395: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for R6 being (State of R5) holds (for B92 being Nat holds ( ( IC ( IncIC (R6 , B92) ) ) -' B92 ) = ( IC R6 )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let R6 being (State of R5);
let C153 being Nat;
thus L396: ( ( IC ( IncIC (R6 , C153) ) ) -' C153 ) = ( ( ( IC R6 ) + C153 ) -' C153 ) by L373
.= ( IC R6 ) by NAT_D:34;
end;
theorem
L397: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B93 , B94 being (PartState of R5) holds (for B95 being Nat holds (( IC R5 ) in ( dom B94 ) implies ( IncIC (( B93 +* B94 ) , B95) ) = ( B93 +* ( IncIC (B94 , B95) ) ))))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C154 , C155 being (PartState of R5);
let C156 being Nat;
assume L398: ( IC R5 ) in ( dom C155 );
L399: ( IC ( C154 +* C155 ) ) = ( IC C155 ) by L398 , FUNCT_4:13;
thus L400: ( IncIC (( C154 +* C155 ) , C156) ) = ( C154 +* ( IncIC (C155 , C156) ) ) by L399 , FUNCT_4:14;
end;
theorem
L401: (for R4 being  with_zero set holds (for B96 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B97 being Nat holds (for B98 being (PartState of B96) holds (for B99 , B100 being (State of B96) holds ((B98 c= B99 & ( IncIC (B98 , B97) ) c= B100) implies B98 c= ( B99 +* ( DataPart B100 ) )))))))
proof
let R4 being  with_zero set;
let C157 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C158 being Nat;
let C159 being (PartState of C157);
let C160 , C161 being (State of C157);
assume that
L402: C159 c= C160
and
L403: ( IncIC (C159 , C158) ) c= C161;
set D17 = ( DataPart C161 );
reconsider D18 = ( C160 +* ( DataPart C161 ) ) as (State of C157);
L404: ( dom C159 ) c= (the carrier of C157) by RELAT_1:def 18;
L405: ( dom C159 ) c= ( { ( IC C157 ) } \/ ( Data-Locations C157 ) ) by L404 , STRUCT_0:4;
L406:
now
L407: ( Data-Locations C157 ) = ( ( dom C161 ) /\ ( Data-Locations C157 ) ) by L121 , XBOOLE_1:28;
L408: ( dom D17 ) = ( Data-Locations C157 ) by L407 , RELAT_1:61;
let C162 being set;
assume that
L409: C162 in ( dom C159 );
per cases  by L405 , L409 , XBOOLE_0:def 3;
suppose L410: C162 in { ( IC C157 ) };

L411: C162 = ( IC C157 ) by L410 , TARSKI:def 1;
L412: ( C160 . C162 ) = ( D18 . C162 ) by L411 , L408 , FUNCT_4:11 , STRUCT_0:3;
thus L413: ( C159 . C162 ) = ( D18 . C162 ) by L412 , L402 , L409 , GRFUNC_1:2;
end;
suppose L414: C162 in ( Data-Locations C157 );

set D19 = ( DataPart C159 );
L415: C162 in ( ( dom C159 ) /\ ( Data-Locations C157 ) ) by L414 , L409 , XBOOLE_0:def 4;
L416: C162 in ( dom D19 ) by L415 , RELAT_1:61;
L417: ( DataPart ( IncIC (C159 , C158) ) ) = D19 by L367;
L418: D19 c= ( IncIC (C159 , C158) ) by L417 , RELAT_1:59;
L419: D19 c= C161 by L418 , L403 , XBOOLE_1:1;
L420: ( dom D19 ) c= ( dom C161 ) by L419 , GRFUNC_1:2;
L421: C162 in ( ( dom C161 ) /\ ( Data-Locations C157 ) ) by L420 , L414 , L416 , XBOOLE_0:def 4;
L422: C162 in ( dom D17 ) by L421 , RELAT_1:61;
L423: D19 c= C159 by RELAT_1:59;
L424: ( D19 . C162 ) = ( C159 . C162 ) by L423 , L416 , GRFUNC_1:2;
L425: ( C161 . C162 ) = ( D17 . C162 ) by L414 , FUNCT_1:49;
L426: ( D19 . C162 ) = ( C161 . C162 ) by L416 , L419 , GRFUNC_1:2;
thus L427: ( C159 . C162 ) = ( D18 . C162 ) by L426 , L424 , L425 , L422 , FUNCT_4:13;
end;
end;
L429: ( dom C159 ) c= ( dom D18 ) by L404 , PARTFUN1:def 2;
thus L430: thesis by L429 , L406 , GRFUNC_1:2;
end;
theorem
L431: (for R4 being  with_zero set holds (for B101 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B102 being (PartState of B101) holds (for B103 being (Element of ( NAT )) holds ( DataPart B102 ) c= ( IncIC (B102 , B103) )))))
proof
let R4 being  with_zero set;
let C163 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C164 being (PartState of C163);
let C165 being (Element of ( NAT ));
L432: ( DataPart ( IncIC (C164 , C165) ) ) = ( DataPart C164 ) by L367;
thus L433: ( DataPart C164 ) c= ( IncIC (C164 , C165) ) by L432 , RELAT_1:59;
end;
definition
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C166 being (PartState of R5);
let C167 being Nat;
func DecIC (C166 , C167) -> (PartState of R5) equals 
( C166 +* ( Start-At (( ( IC C166 ) -' C167 ) , R5) ) );
correctness;
end;
theorem
L435: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B104 being (PartState of R5) holds (for B105 being Nat holds ( DataPart ( DecIC (B104 , B105) ) ) = ( DataPart B104 )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C168 being (PartState of R5);
let C169 being Nat;
thus L436: ( DataPart ( DecIC (C168 , C169) ) ) = ( ( DataPart C168 ) +* ( DataPart ( Start-At (( ( IC C168 ) -' C169 ) , R5) ) ) ) by FUNCT_4:71
.= ( ( DataPart C168 ) +* ( {} ) ) by L214
.= ( DataPart C168 );
end;
theorem
L437: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for R7 being (PartState of R5) holds (for B106 being Nat holds ( IC R5 ) in ( dom ( DecIC (R7 , B106) ) )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let R7 being (PartState of R5);
let C170 being Nat;
L438: ( dom ( DecIC (R7 , C170) ) ) = ( ( dom R7 ) \/ ( dom ( Start-At (( ( IC R7 ) -' C170 ) , R5) ) ) ) by FUNCT_4:def 1;
L439: ( IC R5 ) in ( dom ( Start-At (( ( IC R7 ) -' C170 ) , R5) ) ) by L159;
thus L440: thesis by L439 , L438 , XBOOLE_0:def 3;
end;
theorem
L441: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B107 being (PartState of R5) holds (for B108 being Nat holds ( IC ( DecIC (B107 , B108) ) ) = ( ( IC B107 ) -' B108 )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C171 being (PartState of R5);
let C172 being Nat;
L442: ( dom ( Start-At (( ( IC C171 ) -' C172 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13;
L443: ( IC R5 ) in ( dom ( Start-At (( ( IC C171 ) -' C172 ) , R5) ) ) by L442 , TARSKI:def 1;
thus L444: ( IC ( DecIC (C171 , C172) ) ) = ( ( Start-At (( ( IC C171 ) -' C172 ) , R5) ) . ( IC R5 ) ) by L443 , FUNCT_4:13
.= ( ( IC C171 ) -' C172 ) by FUNCOP_1:72;
end;
theorem
L445: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B109 being (PartState of R5) holds (for B110 being  data-only (PartState of R5) holds (for B111 being Nat holds ( DecIC (( B109 +* B110 ) , B111) ) = ( ( DecIC (B109 , B111) ) +* B110 ))))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C173 being (PartState of R5);
let C174 being  data-only (PartState of R5);
let C175 being Nat;
L446: C174 tolerates ( Start-At (( ( IC C173 ) -' C175 ) , R5) ) by L236;
thus L447: ( DecIC (( C173 +* C174 ) , C175) ) = ( ( C173 +* C174 ) +* ( Start-At (( ( IC C173 ) -' C175 ) , R5) ) ) by L130
.= ( C173 +* ( C174 +* ( Start-At (( ( IC C173 ) -' C175 ) , R5) ) ) ) by FUNCT_4:14
.= ( C173 +* ( ( Start-At (( ( IC C173 ) -' C175 ) , R5) ) +* C174 ) ) by L446 , FUNCT_4:34
.= ( ( DecIC (C173 , C175) ) +* C174 ) by FUNCT_4:14;
end;
theorem
L448: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B112 being (PartState of R5) holds (for B113 being Nat holds ( Start-At (( ( IC B112 ) -' B113 ) , R5) ) c= ( DecIC (B112 , B113) )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C176 being (PartState of R5);
let C177 being Nat;
L449: ( IC ( DecIC (C176 , C177) ) ) = ( ( IC C176 ) -' C177 ) by L441;
L450: ( IC R5 ) in ( dom ( DecIC (C176 , C177) ) ) by L437;
L451: (( Start-At (( ( IC C176 ) -' C177 ) , R5) ) = { [ ( IC R5 ) , ( ( IC C176 ) -' C177 ) ] } & [ ( IC R5 ) , ( ( IC C176 ) -' C177 ) ] in ( DecIC (C176 , C177) )) by L450 , L449 , FUNCT_1:def 2 , FUNCT_4:82;
L452: (for B114 being set holds (B114 in ( Start-At (( ( IC C176 ) -' C177 ) , R5) ) implies B114 in ( DecIC (C176 , C177) ))) by L451 , TARSKI:def 1;
thus L453: thesis by L452 , TARSKI:def 3;
end;
theorem
L454: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B115 being (PartState of R5) holds (for B116 being Nat holds (( IC R5 ) in ( dom B115 ) implies ( DecIC (B115 , B116) ) = ( ( DataPart B115 ) +* ( Start-At (( ( IC B115 ) -' B116 ) , R5) ) ))))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C178 being (PartState of R5);
let C179 being Nat;
L455: ( dom ( Start-At (( ( IC C178 ) -' C179 ) , R5) ) ) = { ( IC R5 ) } by FUNCOP_1:13
.= ( dom ( Start-At (( IC C178 ) , R5) ) ) by FUNCOP_1:13;
assume L456: ( IC R5 ) in ( dom C178 );
thus L457: ( DecIC (C178 , C179) ) = ( ( ( DataPart C178 ) +* ( Start-At (( IC C178 ) , R5) ) ) +* ( Start-At (( ( IC C178 ) -' C179 ) , R5) ) ) by L456 , L246
.= ( ( DataPart C178 ) +* ( Start-At (( ( IC C178 ) -' C179 ) , R5) ) ) by L455 , FUNCT_4:74;
end;
registration
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C180 being (State of R5);
let C181 being Nat;
cluster ( DecIC (C180 , C181) ) ->  total;
coherence;
end;
theorem
L459: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B117 being (PartState of R5) holds (for B118 , B119 being Nat holds ( DecIC (( DecIC (B117 , B118) ) , B119) ) = ( DecIC (B117 , ( B118 + B119 )) )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C182 being (PartState of R5);
let C183 , C184 being Nat;
thus L460: ( DecIC (( DecIC (C182 , C183) ) , C184) ) = ( ( C182 +* ( Start-At (( ( IC C182 ) -' C183 ) , R5) ) ) +* ( Start-At (( ( ( IC C182 ) -' C183 ) -' C184 ) , R5) ) ) by L441
.= ( ( C182 +* ( Start-At (( ( IC C182 ) -' C183 ) , R5) ) ) +* ( Start-At (( ( IC C182 ) -' ( C183 + C184 ) ) , R5) ) ) by NAT_2:30
.= ( DecIC (C182 , ( C183 + C184 )) ) by FUNCT_4:114;
end;
theorem
L461: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B120 being (PartState of R5) holds (for B121 , B122 being Nat holds ( DecIC (( B120 +* ( Start-At (B121 , R5) ) ) , B122) ) = ( B120 +* ( Start-At (( B121 -' B122 ) , R5) ) )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C185 being (PartState of R5);
let C186 , C187 being Nat;
thus L462: ( DecIC (( C185 +* ( Start-At (C186 , R5) ) ) , C187) ) = ( C185 +* ( Start-At (( ( IC ( C185 +* ( Start-At (C186 , R5) ) ) ) -' C187 ) , R5) ) ) by FUNCT_4:114
.= ( C185 +* ( Start-At (( C186 -' C187 ) , R5) ) ) by L162;
end;
theorem
L463: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B123 being (State of R5) holds (for B124 being Nat holds (B124 <= ( IC B123 ) implies ( ( IC ( DecIC (B123 , B124) ) ) + B124 ) = ( IC B123 ))))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C188 being (State of R5);
let C189 being Nat;
assume that
L464: C189 <= ( IC C188 );
thus L465: ( ( IC ( DecIC (C188 , C189) ) ) + C189 ) = ( ( ( IC C188 ) -' C189 ) + C189 ) by L441
.= ( IC C188 ) by L464 , XREAL_1:235;
end;
theorem
L466: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B125 , B126 being (PartState of R5) holds (for B127 being Nat holds (( IC R5 ) in ( dom B126 ) implies ( DecIC (( B125 +* B126 ) , B127) ) = ( B125 +* ( DecIC (B126 , B127) ) ))))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C190 , C191 being (PartState of R5);
let C192 being Nat;
assume L467: ( IC R5 ) in ( dom C191 );
L468: ( IC ( C190 +* C191 ) ) = ( IC C191 ) by L467 , FUNCT_4:13;
thus L469: ( DecIC (( C190 +* C191 ) , C192) ) = ( C190 +* ( DecIC (C191 , C192) ) ) by L468 , FUNCT_4:14;
end;
theorem
L470: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B128 being (PartState of R5) holds (for B129 being Nat holds (( IC R5 ) in ( dom B128 ) implies ( DecIC (( IncIC (B128 , B129) ) , B129) ) = B128)))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C193 being (PartState of R5);
let C194 being Nat;
assume that
L471: ( IC R5 ) in ( dom C193 );
thus L472: ( DecIC (( IncIC (C193 , C194) ) , C194) ) = ( ( IncIC (C193 , C194) ) +* ( Start-At (( ( ( IC C193 ) + C194 ) -' C194 ) , R5) ) ) by L373
.= ( ( IncIC (C193 , C194) ) +* ( Start-At (( IC C193 ) , R5) ) ) by NAT_D:34
.= ( C193 +* ( Start-At (( IC C193 ) , R5) ) ) by L307
.= C193 by L471 , FUNCT_4:7 , FUNCT_4:98;
end;
theorem
L473: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B130 , B131 being (PartState of R5) holds (for B132 being Nat holds (( IC R5 ) in ( dom B131 ) implies ( DecIC (( B130 +* ( IncIC (B131 , B132) ) ) , B132) ) = ( B130 +* B131 ))))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C195 , C196 being (PartState of R5);
let C197 being Nat;
assume that
L474: ( IC R5 ) in ( dom C196 );
L475: ( IC R5 ) in ( dom ( IncIC (C196 , C197) ) ) by L369;
thus L476: ( DecIC (( C195 +* ( IncIC (C196 , C197) ) ) , C197) ) = ( C195 +* ( DecIC (( IncIC (C196 , C197) ) , C197) ) ) by L475 , L466
.= ( C195 +* C196 ) by L474 , L470;
end;
registration
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C198 being Nat;
let C199 being C198 -started (PartState of R5);
cluster ( DecIC (C199 , C198) ) -> ( 0 ) -started;
coherence
proof
thus L477: ( IC R5 ) in ( dom ( DecIC (C199 , C198) ) ) by L437;
thus L478: ( IC ( DecIC (C199 , C198) ) ) = ( ( IC C199 ) -' C198 ) by L441
.= ( C198 -' C198 ) by L153
.= ( 0 ) by XREAL_1:232;
end;
end;
begin
registration
let R4 being  with_zero set;
let C200 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C201 being Nat;
cluster ( Start-At (C201 , C200) ) ->  finite;
correctness;
end;
definition
let R4 being  with_zero set;
let C202 being Mem-Struct over R4;
mode FinPartState of C202
 is  finite (PartState of C202);
end;
registration
let R4 being  with_zero set;
let C203 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C204 being Nat;
cluster C204 -started for (FinPartState of C203);
existence
proof
take ( Start-At (C204 , C203) );
thus L482: thesis;
end;
end;
registration
let R4 being  with_zero set;
let C205 being Mem-Struct over R4;
let C206 being (FinPartState of C205);
cluster ( DataPart C206 ) ->  finite;
coherence;
end;
registration
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C207 being (FinPartState of R5);
cluster ( Initialize C207 ) ->  finite;
coherence;
end;
registration
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C208 being (FinPartState of R5);
let C209 being Nat;
cluster ( IncIC (C208 , C209) ) ->  finite;
coherence;
end;
registration
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C210 being (FinPartState of R5);
let C211 being Nat;
cluster ( DecIC (C210 , C211) ) ->  finite;
coherence;
end;
definition
let R4 being  with_zero set;
let C212 being  with_non-empty_values Mem-Struct over R4;
func FinPartSt C212 -> (Subset of ( sproduct ( the_Values_of C212 ) )) equals 
{ B133 where B133 is (Element of ( sproduct ( the_Values_of C212 ) )) : B133 is  finite };
coherence
proof
defpred S1[ set ] means $1 is  finite;
L488: { B134 where B134 is (Element of ( sproduct ( the_Values_of C212 ) )) : S1[ B134 ] } c= ( sproduct ( the_Values_of C212 ) ) from FRAENKEL:sch 10;
thus L489: thesis by L488;
end;
end;
theorem
L491: (for R4 being  with_zero set holds (for B135 being  with_non-empty_values Mem-Struct over R4 holds (for B136 being (FinPartState of B135) holds B136 in ( FinPartSt B135 ))))
proof
let R4 being  with_zero set;
let C213 being  with_non-empty_values Mem-Struct over R4;
let C214 being (FinPartState of C213);
L492: C214 in ( sproduct ( the_Values_of C213 ) ) by CARD_3:103;
thus L493: thesis by L492;
end;
registration
let R4 being  with_zero set;
let C215 being  with_non-empty_values Mem-Struct over R4;
cluster ( FinPartSt C215 ) -> non  empty;
coherence by L491;
end;
theorem
L495: (for R4 being  with_zero set holds (for B137 being  with_non-empty_values Mem-Struct over R4 holds (for B138 being (Element of ( FinPartSt B137 )) holds B138 is (FinPartState of B137))))
proof
let R4 being  with_zero set;
let C216 being  with_non-empty_values Mem-Struct over R4;
let C217 being (Element of ( FinPartSt C216 ));
L496: C217 in ( FinPartSt C216 );
L497: (ex B139 being (Element of ( sproduct ( the_Values_of C216 ) )) st (B139 = C217 & B139 is  finite)) by L496;
thus L498: thesis by L497;
end;
definition
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C218 being (PartFunc of ( FinPartSt R5 ) , ( FinPartSt R5 ));
attr C218 is  data-only
means
(for B140 being (PartState of R5) holds (B140 in ( dom C218 ) implies (B140 is  data-only & (for B141 being (PartState of R5) holds (B141 = ( C218 . B140 ) implies B141 is  data-only)))));
end;
registration
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
cluster  data-only for (PartFunc of ( FinPartSt R5 ) , ( FinPartSt R5 ));
existence
proof
reconsider D20 = ( {} ) as (PartFunc of ( FinPartSt R5 ) , ( FinPartSt R5 )) by RELSET_1:12;
take D20;
let C219 being (PartState of R5);
thus L500: thesis;
end;
end;
begin
theorem
L502: (for R4 being  with_zero set holds (for B142 being non  empty  with_non-empty_values Mem-Struct over R4 holds (for B143 being (State of B142) holds (for B144 being (Object of B142) holds ( B143 . B144 ) in ( Values B144 )))))
proof
let R4 being  with_zero set;
let C220 being non  empty  with_non-empty_values Mem-Struct over R4;
let C221 being (State of C220);
let C222 being (Object of C220);
L503: ( dom C221 ) = (the carrier of C220) by PARTFUN1:def 2;
thus L504: thesis by L503 , FUNCT_1:def 14;
end;
theorem
L505: (for R4 being  with_zero set holds (for B145 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B146 , B147 being (State of B145) holds ((( IC B146 ) = ( IC B147 ) & ( DataPart B146 ) = ( DataPart B147 )) implies B146 = B147))))
proof
let R4 being  with_zero set;
let C223 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
set D21 = ( Data-Locations C223 );
let C224 , C225 being (State of C223);
assume that
L506: ( IC C224 ) = ( IC C225 )
and
L507: ( DataPart C224 ) = ( DataPart C225 );
L508: ( dom C225 ) = ( { ( IC C223 ) } \/ D21 ) by L134;
L509: ( dom C224 ) = ( { ( IC C223 ) } \/ D21 ) by L134;
L510: ( C224 | { ( IC C223 ) } ) = ( C225 | { ( IC C223 ) } ) by L509 , L506 , L508 , GRFUNC_1:29;
L511: ( C224 | ( { ( IC C223 ) } \/ D21 ) ) = ( C225 | ( { ( IC C223 ) } \/ D21 ) ) by L510 , L507 , RELAT_1:150;
L512: ( C224 | ( { ( IC C223 ) } \/ D21 ) ) = ( C225 | ( { ( IC C223 ) } \/ D21 ) ) by L511;
thus L513: C224 = ( C225 | ( dom C225 ) ) by L512 , L509 , L508 , RELAT_1:68
.= C225;
end;
theorem
L514: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B148 being (State of R5) holds (for B149 being (Element of ( NAT )) holds ( DataPart B148 ) = ( DataPart ( B148 +* ( Start-At (B149 , R5) ) ) )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C226 being (State of R5);
let C227 being (Element of ( NAT ));
thus L515: ( DataPart C226 ) = ( ( DataPart C226 ) +* ( {} ) )
.= ( ( DataPart C226 ) +* ( DataPart ( Start-At (C227 , R5) ) ) ) by L214
.= ( DataPart ( C226 +* ( Start-At (C227 , R5) ) ) ) by FUNCT_4:71;
end;
theorem
L516: (for R4 being  with_zero set holds (for R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4 holds (for B150 , B151 being (State of R5) holds (( DataPart B150 ) = ( DataPart B151 ) implies ( Initialize B150 ) = ( Initialize B151 )))))
proof
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C228 , C229 being (State of R5);
assume L517: ( DataPart C228 ) = ( DataPart C229 );
set D22 = ( Initialize C228 );
set D23 = ( Initialize C229 );
L518: (( IC D22 ) = ( 0 ) & ( IC D23 ) = ( 0 )) by L350;
L519: ( DataPart D22 ) = ( DataPart C228 ) by L343
.= ( DataPart D23 ) by L517 , L343;
thus L520: thesis by L519 , L518 , L505;
end;
theorem
L521: (for R4 being  with_zero set holds ( the_Values_of ( Trivial-Mem R4 ) ) = ( ( 0 ) .--> ( NAT ) )) by L37;
definition
let R4 being  with_zero set;
let R5 being  IC-Ins-separated non  empty  with_non-empty_values Mem-Struct over R4;
let C230 being (Function of ( product ( the_Values_of R5 ) ) , ( NAT ));
attr C230 is  on_data_only
means
(for B152 , B153 being (State of R5) holds (( DataPart B152 ) = ( DataPart B153 ) implies ( C230 . B152 ) = ( C230 . B153 )));
end;
