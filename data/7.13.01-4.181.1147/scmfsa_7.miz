:: Some Multi-instructions defined by sequence of instructions of SCM+FSA
::  by Noriko Asamoto
::
:: Received April 24, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, FINSEQ_1, ARYTM_3, ORDINAL4, ARYTM_1, AMI_1,
      SCMFSA_2, RELAT_1, FUNCT_1, PARTFUN1, TARSKI, XXREAL_0, NAT_1, CARD_1,
      XBOOLE_0, INT_1, GRAPHSP, FINSEQ_2, AMI_3, PRE_POLY, FSM_1, CIRCUIT2,
      MSUALG_1, COMPLEX1, FUNCT_4, SCMFSA_7, ORDINAL1, EXTPRO_1, AFINSQ_1,
      FUNCOP_1, PBOOLE, FINSET_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, ORDINAL1, NAT_1,
      INT_2, NAT_D, INT_1, RELAT_1, PARTFUN1, FINSET_1, FINSEQ_1, AFINSQ_1,
      FINSEQ_2, FUNCT_1, FUNCOP_1, FUNCT_7, PBOOLE, XXREAL_0, MEMSTR_0,
      COMPOS_1, EXTPRO_1, SCMFSA_2, AFINSQ_2;
 constructors REAL_1, AMI_3, SCMFSA_2, NAT_D, RELSET_1, PRE_POLY, AFINSQ_2,
      FUNCT_7;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, XXREAL_0, XREAL_0, NAT_1,
      INT_1, FINSEQ_1, FUNCT_7, SCMFSA_2, FINSEQ_2, AFINSQ_1, FUNCOP_1,
      MEMSTR_0, PBOOLE, AMI_3, COMPOS_0;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions EXTPRO_1, FINSEQ_1, SCMFSA_2, AFINSQ_1, FUNCOP_1, MEMSTR_0;
 theorems FUNCT_1, SCMFSA_2, INT_1, NAT_1, FINSEQ_1, FINSEQ_2, FINSEQ_3,
      RELAT_1, CARD_1, TARSKI, GRFUNC_1, ABSVALUE, FUNCT_7, XBOOLE_1, XREAL_1,
      XXREAL_0, FUNCOP_1, AMI_3, ORDINAL1, AFINSQ_1, AFINSQ_2, EXTPRO_1,
      PBOOLE, MEMSTR_0;
 schemes NAT_1, STIRL2_1, AFINSQ_1;

begin
L1: (for B1 , B2 , B3 , B4 being XFinSequence holds (( ( ( B1 ^ B2 ) ^ B3 ) ^ B4 ) = ( ( B1 ^ B2 ) ^ ( B3 ^ B4 ) ) & ( ( ( B1 ^ B2 ) ^ B3 ) ^ B4 ) = ( B1 ^ ( ( B2 ^ B3 ) ^ B4 ) ) & ( ( ( B1 ^ B2 ) ^ B3 ) ^ B4 ) = ( B1 ^ ( B2 ^ ( B3 ^ B4 ) ) ) & ( ( ( B1 ^ B2 ) ^ B3 ) ^ B4 ) = ( ( B1 ^ ( B2 ^ B3 ) ) ^ B4 )))
proof
let C1 , C2 , C3 , C4 being XFinSequence;
thus L2: ( ( ( C1 ^ C2 ) ^ C3 ) ^ C4 ) = ( ( C1 ^ C2 ) ^ ( C3 ^ C4 ) ) by AFINSQ_1:27;
thus L3: ( ( ( C1 ^ C2 ) ^ C3 ) ^ C4 ) = ( ( C1 ^ ( C2 ^ C3 ) ) ^ C4 ) by AFINSQ_1:27
.= ( C1 ^ ( ( C2 ^ C3 ) ^ C4 ) ) by AFINSQ_1:27;
thus L4: ( ( ( C1 ^ C2 ) ^ C3 ) ^ C4 ) = ( C1 ^ ( C2 ^ ( C3 ^ C4 ) ) ) by L3 , AFINSQ_1:27;
thus L5: thesis by AFINSQ_1:27;
end;
L6: (for B5 , B6 , B7 , B8 , B9 being XFinSequence holds (( ( ( ( B5 ^ B6 ) ^ B7 ) ^ B8 ) ^ B9 ) = ( ( ( B5 ^ B6 ) ^ B7 ) ^ ( B8 ^ B9 ) ) & ( ( ( ( B5 ^ B6 ) ^ B7 ) ^ B8 ) ^ B9 ) = ( ( B5 ^ B6 ) ^ ( ( B7 ^ B8 ) ^ B9 ) ) & ( ( ( ( B5 ^ B6 ) ^ B7 ) ^ B8 ) ^ B9 ) = ( ( B5 ^ B6 ) ^ ( B7 ^ ( B8 ^ B9 ) ) ) & ( ( ( ( B5 ^ B6 ) ^ B7 ) ^ B8 ) ^ B9 ) = ( B5 ^ ( ( ( B6 ^ B7 ) ^ B8 ) ^ B9 ) ) & ( ( ( ( B5 ^ B6 ) ^ B7 ) ^ B8 ) ^ B9 ) = ( B5 ^ ( ( B6 ^ B7 ) ^ ( B8 ^ B9 ) ) ) & ( ( ( ( B5 ^ B6 ) ^ B7 ) ^ B8 ) ^ B9 ) = ( B5 ^ ( B6 ^ ( ( B7 ^ B8 ) ^ B9 ) ) ) & ( ( ( ( B5 ^ B6 ) ^ B7 ) ^ B8 ) ^ B9 ) = ( B5 ^ ( B6 ^ ( B7 ^ ( B8 ^ B9 ) ) ) ) & ( ( ( ( B5 ^ B6 ) ^ B7 ) ^ B8 ) ^ B9 ) = ( ( ( B5 ^ B6 ) ^ ( B7 ^ B8 ) ) ^ B9 ) & ( ( ( ( B5 ^ B6 ) ^ B7 ) ^ B8 ) ^ B9 ) = ( ( B5 ^ ( ( B6 ^ B7 ) ^ B8 ) ) ^ B9 ) & ( ( ( ( B5 ^ B6 ) ^ B7 ) ^ B8 ) ^ B9 ) = ( ( B5 ^ ( B6 ^ ( B7 ^ B8 ) ) ) ^ B9 ) & ( ( ( ( B5 ^ B6 ) ^ B7 ) ^ B8 ) ^ B9 ) = ( B5 ^ ( ( B6 ^ ( B7 ^ B8 ) ) ^ B9 ) )))
proof
let C5 , C6 , C7 , C8 , C9 being XFinSequence;
thus L7: ( ( ( ( C5 ^ C6 ) ^ C7 ) ^ C8 ) ^ C9 ) = ( ( ( C5 ^ C6 ) ^ C7 ) ^ ( C8 ^ C9 ) ) by AFINSQ_1:27;
thus L8: ( ( ( ( C5 ^ C6 ) ^ C7 ) ^ C8 ) ^ C9 ) = ( ( C5 ^ C6 ) ^ ( ( C7 ^ C8 ) ^ C9 ) ) by L1;
thus L9: ( ( ( ( C5 ^ C6 ) ^ C7 ) ^ C8 ) ^ C9 ) = ( ( C5 ^ C6 ) ^ ( C7 ^ ( C8 ^ C9 ) ) ) by L1;
thus L10: ( ( ( ( C5 ^ C6 ) ^ C7 ) ^ C8 ) ^ C9 ) = ( ( C5 ^ ( ( C6 ^ C7 ) ^ C8 ) ) ^ C9 ) by L1
.= ( C5 ^ ( ( ( C6 ^ C7 ) ^ C8 ) ^ C9 ) ) by AFINSQ_1:27;
thus L11: ( ( ( ( C5 ^ C6 ) ^ C7 ) ^ C8 ) ^ C9 ) = ( C5 ^ ( ( C6 ^ C7 ) ^ ( C8 ^ C9 ) ) ) by L10 , AFINSQ_1:27;
thus L12: ( ( ( ( C5 ^ C6 ) ^ C7 ) ^ C8 ) ^ C9 ) = ( C5 ^ ( C6 ^ ( ( C7 ^ C8 ) ^ C9 ) ) ) by L10 , L1;
thus L13: ( ( ( ( C5 ^ C6 ) ^ C7 ) ^ C8 ) ^ C9 ) = ( C5 ^ ( C6 ^ ( C7 ^ ( C8 ^ C9 ) ) ) ) by L10 , L1;
thus L14: ( ( ( ( C5 ^ C6 ) ^ C7 ) ^ C8 ) ^ C9 ) = ( ( ( C5 ^ C6 ) ^ ( C7 ^ C8 ) ) ^ C9 ) by L1;
thus L15: ( ( ( ( C5 ^ C6 ) ^ C7 ) ^ C8 ) ^ C9 ) = ( ( C5 ^ ( ( C6 ^ C7 ) ^ C8 ) ) ^ C9 ) by L1;
thus L16: ( ( ( ( C5 ^ C6 ) ^ C7 ) ^ C8 ) ^ C9 ) = ( ( C5 ^ ( C6 ^ ( C7 ^ C8 ) ) ) ^ C9 ) by L1;
thus L17: thesis by L10 , L1;
end;
deffunc H1((Element of ( NAT ))) = ( $1 -' 1 );
definition
let C10 being Int-Location;
let C11 being Integer;
func C10 := C11 -> (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined  finite Function means 
:L18: (ex B10 being (Element of ( NAT )) st (( B10 + 1 ) = C11 & it = ( ( <% ( C10 := ( intloc ( 0 ) ) ) %> ^ ( B10 --> ( AddTo (C10 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> ))) if C11 > ( 0 ) otherwise (ex B11 being (Element of ( NAT )) st (( B11 + C11 ) = 1 & it = ( ( <% ( C10 := ( intloc ( 0 ) ) ) %> ^ ( B11 --> ( SubFrom (C10 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> )));
existence
proof
thus L19: (C11 > ( 0 ) implies (ex B12 being (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined  finite Function st (ex B13 being (Element of ( NAT )) st (( B13 + 1 ) = C11 & B12 = ( ( <% ( C10 := ( intloc ( 0 ) ) ) %> ^ ( B13 --> ( AddTo (C10 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> )))))
proof
assume L20: C11 > ( 0 );
L21: ( ( 0 ) + 1 ) <= C11 by L20 , INT_1:7;
reconsider D1 = ( C11 - 1 ) as (Element of ( NAT )) by L21 , INT_1:5;
set D2 = ( ( <% ( C10 := ( intloc ( 0 ) ) ) %> ^ ( D1 --> ( AddTo (C10 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> );
reconsider D3 = D2 as (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined  finite Function;
take D3;
take D1;
thus L22: ( D1 + 1 ) = C11;
thus L23: thesis;
end;

assume L24: C11 <= ( 0 );
reconsider D4 = ( 1 - C11 ) as (Element of ( NAT )) by L24 , INT_1:5;
set D5 = ( ( <% ( C10 := ( intloc ( 0 ) ) ) %> ^ ( D4 --> ( SubFrom (C10 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> );
reconsider D6 = D5 as (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined  finite Function;
take D6;
take D4;
thus L25: ( D4 + C11 ) = 1;
thus L26: thesis;
end;
uniqueness;
correctness;
end;
definition
let C12 being Int-Location;
let C13 being Integer;
func aSeq (C12 , C13) -> (XFinSequence of (the InstructionsF of ( SCM+FSA ))) means 
:L28: (ex B14 being (Element of ( NAT )) st (( B14 + 1 ) = C13 & it = ( <% ( C12 := ( intloc ( 0 ) ) ) %> ^ ( B14 --> ( AddTo (C12 , ( intloc ( 0 ) )) ) ) ))) if C13 > ( 0 ) otherwise (ex B15 being (Element of ( NAT )) st (( B15 + C13 ) = 1 & it = ( <% ( C12 := ( intloc ( 0 ) ) ) %> ^ ( B15 --> ( SubFrom (C12 , ( intloc ( 0 ) )) ) ) )));
existence
proof
thus L29: (C13 > ( 0 ) implies (ex B16 being (XFinSequence of (the InstructionsF of ( SCM+FSA ))) st (ex B17 being (Element of ( NAT )) st (( B17 + 1 ) = C13 & B16 = ( <% ( C12 := ( intloc ( 0 ) ) ) %> ^ ( B17 --> ( AddTo (C12 , ( intloc ( 0 ) )) ) ) )))))
proof
assume L30: C13 > ( 0 );
L31: ( ( 0 ) + 1 ) <= C13 by L30 , INT_1:7;
reconsider D7 = ( C13 - 1 ) as (Element of ( NAT )) by L31 , INT_1:5;
take ( <% ( C12 := ( intloc ( 0 ) ) ) %> ^ ( D7 --> ( AddTo (C12 , ( intloc ( 0 ) )) ) ) );
take D7;
thus L32: ( D7 + 1 ) = C13;
thus L33: thesis;
end;

assume L34: C13 <= ( 0 );
reconsider D8 = ( 1 - C13 ) as (Element of ( NAT )) by L34 , INT_1:5;
take ( <% ( C12 := ( intloc ( 0 ) ) ) %> ^ ( D8 --> ( SubFrom (C12 , ( intloc ( 0 ) )) ) ) );
take D8;
thus L35: ( D8 + C13 ) = 1;
thus L36: thesis;
end;
uniqueness;
correctness;
end;
theorem
L38: (for B18 being Int-Location holds (for B19 being Integer holds ( B18 := B19 ) = ( ( aSeq (B18 , B19) ) ^ <% ( halt ( SCM+FSA ) ) %> )))
proof
let C14 being Int-Location;
let C15 being Integer;
per cases ;
suppose L39: C15 > ( 0 );

L40: (ex B20 being (Element of ( NAT )) st (( B20 + 1 ) = C15 & ( C14 := C15 ) = ( ( <% ( C14 := ( intloc ( 0 ) ) ) %> ^ ( B20 --> ( AddTo (C14 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> ))) by L39 , L18;
thus L41: thesis by L40 , L28;
end;
suppose L42: C15 <= ( 0 );

L43: (ex B21 being (Element of ( NAT )) st (( B21 + C15 ) = 1 & ( C14 := C15 ) = ( ( <% ( C14 := ( intloc ( 0 ) ) ) %> ^ ( B21 --> ( SubFrom (C14 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> ))) by L42 , L18;
thus L44: thesis by L43 , L42 , L28;
end;
end;
definition
let C16 being FinSeq-Location;
let C17 being (FinSequence of ( INT ));
func aSeq (C16 , C17) -> (XFinSequence of (the InstructionsF of ( SCM+FSA ))) means 
:L46: (ex B22 being (XFinSequence of ( (the InstructionsF of ( SCM+FSA )) ^omega )) st (( len B22 ) = ( len C17 ) & (for B23 being (Element of ( NAT )) holds (B23 < ( len B22 ) implies (ex B24 being Integer st (B24 = ( C17 . ( B23 + 1 ) ) & ( B22 . B23 ) = ( ( ( aSeq (( intloc 1 ) , ( B23 + 1 )) ) ^ ( aSeq (( intloc 2 ) , B24) ) ) ^ <% ( (C16 , ( intloc 1 )) := ( intloc 2 ) ) %> ))))) & it = ( FlattenSeq B22 )));
existence
proof
defpred S1[ Integer , set ] means (ex B25 being Integer st (B25 = ( C17 . ( $1 + 1 ) ) & $2 = ( ( ( aSeq (( intloc 1 ) , ( $1 + 1 )) ) ^ ( aSeq (( intloc 2 ) , B25) ) ) ^ <% ( (C16 , ( intloc 1 )) := ( intloc 2 ) ) %> )));
set D9 = ( (the InstructionsF of ( SCM+FSA )) ^omega );
L47: (for B26 being Nat holds (B26 in ( len C17 ) implies (ex B27 being (Element of D9) st S1[ B26 , B27 ])))
proof
let C18 being Nat;
assume L48: C18 in ( len C17 );
L49: C18 < ( len C17 ) by L48 , NAT_1:44;
L50: (1 <= ( C18 + 1 ) & ( C18 + 1 ) <= ( len C17 )) by L49 , NAT_1:12 , NAT_1:13;
L51: ( C18 + 1 ) in ( dom C17 ) by L50 , FINSEQ_3:25;
L52: ( C17 . ( C18 + 1 ) ) in ( INT ) by L51 , FINSEQ_2:11;
reconsider D10 = ( C17 . ( C18 + 1 ) ) as Integer by L52;
reconsider D11 = ( ( ( aSeq (( intloc 1 ) , ( C18 + 1 )) ) ^ ( aSeq (( intloc 2 ) , D10) ) ) ^ <% ( (C16 , ( intloc 1 )) := ( intloc 2 ) ) %> ) as (Element of D9) by AFINSQ_1:def 7;
take D11;
thus L53: thesis;
end;
consider C19 being (XFinSequence of D9) such that L54: ( dom C19 ) = ( len C17 ) and L55: (for B28 being Nat holds (B28 in ( len C17 ) implies S1[ B28 , ( C19 . B28 ) ])) from STIRL2_1:sch 5(L47);
reconsider D12 = ( FlattenSeq C19 ) as (XFinSequence of (the InstructionsF of ( SCM+FSA ))) by AFINSQ_1:def 7;
take D12;
take C19;
thus L56: ( len C19 ) = ( len C17 ) by L54;
thus L57:now
let C20 being (Element of ( NAT ));
assume L58: C20 < ( len C19 );
L59: (1 <= ( C20 + 1 ) & ( C20 + 1 ) <= ( len C17 )) by L58 , L54 , NAT_1:12 , NAT_1:13;
L60: ( C20 + 1 ) in ( dom C17 ) by L59 , FINSEQ_3:25;
L61: ( C17 . ( C20 + 1 ) ) in ( INT ) by L60 , FINSEQ_2:11;
reconsider D13 = ( C17 . ( C20 + 1 ) ) as Integer by L61;
take D14 = D13;
thus L62: D14 = ( C17 . ( C20 + 1 ) );
L63: C20 in ( len C17 ) by L54 , L58 , NAT_1:44;
L64: (C20 in ( dom C19 ) & S1[ C20 , ( C19 . C20 ) ]) by L63 , L54 , L55;
thus L65: ( ( ( aSeq (( intloc 1 ) , ( C20 + 1 )) ) ^ ( aSeq (( intloc 2 ) , D14) ) ) ^ <% ( (C16 , ( intloc 1 )) := ( intloc 2 ) ) %> ) = ( C19 . C20 ) by L64;
end;
thus L66: thesis;
end;
uniqueness
proof
reconsider D15 = ( len C17 ) as (Element of ( NAT ));
let C21 , C22 being (XFinSequence of (the InstructionsF of ( SCM+FSA )));
assume that
L67: (ex B29 being (XFinSequence of ( (the InstructionsF of ( SCM+FSA )) ^omega )) st (( len B29 ) = ( len C17 ) & (for B30 being (Element of ( NAT )) holds (B30 < ( len B29 ) implies (ex B31 being Integer st (B31 = ( C17 . ( B30 + 1 ) ) & ( B29 . B30 ) = ( ( ( aSeq (( intloc 1 ) , ( B30 + 1 )) ) ^ ( aSeq (( intloc 2 ) , B31) ) ) ^ <% ( (C16 , ( intloc 1 )) := ( intloc 2 ) ) %> ))))) & C21 = ( FlattenSeq B29 )))
and
L68: (ex B32 being (XFinSequence of ( (the InstructionsF of ( SCM+FSA )) ^omega )) st (( len B32 ) = ( len C17 ) & (for B33 being (Element of ( NAT )) holds (B33 < ( len B32 ) implies (ex B34 being Integer st (B34 = ( C17 . ( B33 + 1 ) ) & ( B32 . B33 ) = ( ( ( aSeq (( intloc 1 ) , ( B33 + 1 )) ) ^ ( aSeq (( intloc 2 ) , B34) ) ) ^ <% ( (C16 , ( intloc 1 )) := ( intloc 2 ) ) %> ))))) & C22 = ( FlattenSeq B32 )));
consider C23 being (XFinSequence of ( (the InstructionsF of ( SCM+FSA )) ^omega )) such that L69: ( len C23 ) = ( len C17 ) and L70: (for B35 being (Element of ( NAT )) holds (B35 < ( len C23 ) implies (ex B36 being Integer st (B36 = ( C17 . ( B35 + 1 ) ) & ( C23 . B35 ) = ( ( ( aSeq (( intloc 1 ) , ( B35 + 1 )) ) ^ ( aSeq (( intloc 2 ) , B36) ) ) ^ <% ( (C16 , ( intloc 1 )) := ( intloc 2 ) ) %> ))))) and L71: C21 = ( FlattenSeq C23 ) by L67;
consider C24 being (XFinSequence of ( (the InstructionsF of ( SCM+FSA )) ^omega )) such that L72: ( len C24 ) = ( len C17 ) and L73: (for B37 being (Element of ( NAT )) holds (B37 < ( len C24 ) implies (ex B38 being Integer st (B38 = ( C17 . ( B37 + 1 ) ) & ( C24 . B37 ) = ( ( ( aSeq (( intloc 1 ) , ( B37 + 1 )) ) ^ ( aSeq (( intloc 2 ) , B38) ) ) ^ <% ( (C16 , ( intloc 1 )) := ( intloc 2 ) ) %> ))))) and L74: C22 = ( FlattenSeq C24 ) by L68;
L75: (for B39 being Nat holds (B39 < ( len C23 ) implies ( C23 . B39 ) = ( C24 . B39 )))
proof
let C25 being Nat;
assume L76: C25 < ( len C23 );
L77: C25 in ( NAT ) by ORDINAL1:def 12;
L78: ((ex B40 being Integer st (B40 = ( C17 . ( C25 + 1 ) ) & ( C23 . C25 ) = ( ( ( aSeq (( intloc 1 ) , ( C25 + 1 )) ) ^ ( aSeq (( intloc 2 ) , B40) ) ) ^ <% ( (C16 , ( intloc 1 )) := ( intloc 2 ) ) %> ))) & (ex B41 being Integer st (B41 = ( C17 . ( C25 + 1 ) ) & ( C24 . C25 ) = ( ( ( aSeq (( intloc 1 ) , ( C25 + 1 )) ) ^ ( aSeq (( intloc 2 ) , B41) ) ) ^ <% ( (C16 , ( intloc 1 )) := ( intloc 2 ) ) %> )))) by L77 , L70 , L73 , L76 , L69 , L72;
thus L79: ( C23 . C25 ) = ( C24 . C25 ) by L78;
end;
thus L80: thesis by L75 , L71 , L74 , L69 , L72 , AFINSQ_1:9;
end;
correctness;
end;
definition
let C26 being FinSeq-Location;
let C27 being (FinSequence of ( INT ));
func C26 := C27 -> (the InstructionsF of ( SCM+FSA )) -valued ( NAT ) -defined  finite Function equals 
( ( ( ( aSeq (( intloc 1 ) , ( len C27 )) ) ^ <% ( C26 :=<0,...,0> ( intloc 1 ) ) %> ) ^ ( aSeq (C26 , C27) ) ) ^ <% ( halt ( SCM+FSA ) ) %> );
correctness;
end;
theorem
L83: (for B42 being Int-Location holds ( B42 := 1 ) = ( <% ( B42 := ( intloc ( 0 ) ) ) %> ^ <% ( halt ( SCM+FSA ) ) %> ))
proof
let C28 being Int-Location;
L84: ( ( 0 ) + 1 ) = 1;
L85: ( <% ( C28 := ( intloc ( 0 ) ) ) %> ^ <% ( halt ( SCM+FSA ) ) %> ) = ( ( <% ( C28 := ( intloc ( 0 ) ) ) %> ^ ( {} ) ) ^ <% ( halt ( SCM+FSA ) ) %> )
.= ( ( <% ( C28 := ( intloc ( 0 ) ) ) %> ^ ( ( 0 ) --> ( AddTo (C28 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> );
thus L86: thesis by L85 , L18 , L84;
end;
theorem
L87: (for B43 being Int-Location holds ( B43 := ( 0 ) ) = ( ( <% ( B43 := ( intloc ( 0 ) ) ) %> ^ <% ( SubFrom (B43 , ( intloc ( 0 ) )) ) %> ) ^ <% ( halt ( SCM+FSA ) ) %> ))
proof
let C29 being Int-Location;
L88: (( 1 + ( 0 ) ) = 1 & ( ( <% ( C29 := ( intloc ( 0 ) ) ) %> ^ <% ( SubFrom (C29 , ( intloc ( 0 ) )) ) %> ) ^ <% ( halt ( SCM+FSA ) ) %> ) = ( ( <% ( C29 := ( intloc ( 0 ) ) ) %> ^ ( 1 --> ( SubFrom (C29 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> )) by CARD_1:49;
thus L89: thesis by L88 , L18;
end;
theorem
L90: (for R2 being (the InstructionsF of ( SCM+FSA )) -valued (ManySortedSet of ( NAT )) holds (for B44 being (Element of ( NAT )) holds (for B45 being B44 -started (State of ( SCM+FSA )) holds (( B45 . ( intloc ( 0 ) ) ) = 1 implies (for B46 being Int-Location holds (for B47 being Integer holds ((B46 <> ( intloc ( 0 ) ) & (for B48 being (Element of ( NAT )) holds (B48 in ( dom ( aSeq (B46 , B47) ) ) implies ( ( aSeq (B46 , B47) ) . B48 ) = ( R2 . ( B44 + B48 ) )))) implies ((for B49 being (Element of ( NAT )) holds (B49 <= ( len ( aSeq (B46 , B47) ) ) implies (( IC ( Comput (R2 , B45 , B49) ) ) = ( B44 + B49 ) & (for B50 being Int-Location holds (B50 <> B46 implies ( ( Comput (R2 , B45 , B49) ) . B50 ) = ( B45 . B50 ))) & (for B51 being FinSeq-Location holds ( ( Comput (R2 , B45 , B49) ) . B51 ) = ( B45 . B51 ))))) & ( ( Comput (R2 , B45 , ( len ( aSeq (B46 , B47) ) )) ) . B46 ) = B47))))))))
proof
let R2 being (the InstructionsF of ( SCM+FSA )) -valued (ManySortedSet of ( NAT ));
let C30 being (Element of ( NAT ));
let C31 being C30 -started (State of ( SCM+FSA ));
assume L91: ( C31 . ( intloc ( 0 ) ) ) = 1;
L92: ( IC C31 ) = C30 by MEMSTR_0:def 11;
let C32 being Int-Location;
let C33 being Integer;
assume that
L93: C32 <> ( intloc ( 0 ) )
and
L94: (for B52 being (Element of ( NAT )) holds (B52 in ( dom ( aSeq (C32 , C33) ) ) implies ( ( aSeq (C32 , C33) ) . B52 ) = ( R2 . ( C30 + B52 ) )));
per cases ;
suppose L95: C33 > ( 0 );

reconsider D16 = C33 as (Element of ( NAT )) by L95 , INT_1:3;
consider C34 being (Element of ( NAT )) such that L96: ( C34 + 1 ) = D16 and L97: ( aSeq (C32 , D16) ) = ( <% ( C32 := ( intloc ( 0 ) ) ) %> ^ ( C34 --> ( AddTo (C32 , ( intloc ( 0 ) )) ) ) ) by L95 , L28;
defpred S2[ Nat ] means ($1 <= D16 implies (( IC ( Comput (R2 , C31 , $1) ) ) = ( C30 + $1 ) & (1 <= $1 implies ( ( Comput (R2 , C31 , $1) ) . C32 ) = $1) & (for B53 being Int-Location holds (B53 <> C32 implies ( ( Comput (R2 , C31 , $1) ) . B53 ) = ( C31 . B53 ))) & (for B54 being FinSeq-Location holds ( ( Comput (R2 , C31 , $1) ) . B54 ) = ( C31 . B54 ))));
L98: ( len ( aSeq (C32 , D16) ) ) = ( ( len <% ( C32 := ( intloc ( 0 ) ) ) %> ) + ( len ( C34 --> ( AddTo (C32 , ( intloc ( 0 ) )) ) ) ) ) by L97 , AFINSQ_1:17
.= ( 1 + ( len ( C34 --> ( AddTo (C32 , ( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:33
.= D16 by L96 , CARD_1:64;
L99: (for B55 being (Element of ( NAT )) holds (B55 <= ( len ( aSeq (C32 , D16) ) ) implies (( IC ( Comput (R2 , C31 , B55) ) ) = ( C30 + B55 ) & (1 <= B55 implies ( ( Comput (R2 , C31 , B55) ) . C32 ) = B55) & (for B56 being Int-Location holds (B56 <> C32 implies ( ( Comput (R2 , C31 , B55) ) . B56 ) = ( C31 . B56 ))) & (for B57 being FinSeq-Location holds ( ( Comput (R2 , C31 , B55) ) . B57 ) = ( C31 . B57 )))))
proof
L100: (for B58 being (Element of ( NAT )) holds (B58 < D16 implies B58 in ( dom ( aSeq (C32 , D16) ) ))) by L98 , NAT_1:44;
L101: ( R2 . ( C30 + ( 0 ) ) ) = ( ( aSeq (C32 , D16) ) . ( 0 ) ) by L95 , L94 , L100
.= ( C32 := ( intloc ( 0 ) ) ) by L97 , AFINSQ_1:35;
L102:
now
let C35 being (Element of ( NAT ));
assume L103: C35 = ( 0 );
thus L104: ( Comput (R2 , C31 , C35) ) = C31 by L103 , EXTPRO_1:2;
thus L105: ( CurInstr (R2 , ( Comput (R2 , C31 , C35) )) ) = ( C32 := ( intloc ( 0 ) ) ) by L104 , L92 , L101 , PBOOLE:143;
thus L106: ( Comput (R2 , C31 , ( C35 + 1 )) ) = ( Following (R2 , ( Comput (R2 , C31 , C35) )) ) by EXTPRO_1:3
.= ( Exec (( C32 := ( intloc ( 0 ) ) ) , C31) ) by L92 , L101 , L104 , PBOOLE:143;
end;
L107:
now
let C36 being (Element of ( NAT ));
assume that
L108: 1 <= C36
and
L109: C36 < D16;
reconsider D17 = ( C36 - 1 ) as (Element of ( NAT )) by L108 , INT_1:5;
L110: C36 = ( D17 + 1 );
L111: D17 < C34 by L110 , L109 , L96 , XREAL_1:6;
L112: D17 in C34 by L111 , NAT_1:44;
L113: ( len ( C34 --> ( AddTo (C32 , ( intloc ( 0 ) )) ) ) ) = C34 by CARD_1:64;
L114: ( len <% ( C32 := ( intloc ( 0 ) ) ) %> ) = 1 by AFINSQ_1:33;
thus L115: ( ( aSeq (C32 , D16) ) . C36 ) = ( ( C34 --> ( AddTo (C32 , ( intloc ( 0 ) )) ) ) . ( C36 - 1 ) ) by L114 , L108 , L97 , L113 , L96 , L109 , AFINSQ_1:18
.= ( AddTo (C32 , ( intloc ( 0 ) )) ) by L112 , FUNCOP_1:7;
end;
L116:
now
let C37 being (Element of ( NAT ));
assume that
L117: ( 0 ) < C37
and
L118: C37 < D16;
L119: ( ( 0 ) + 1 ) <= C37 by L117 , NAT_1:13;
thus L120: ( R2 . ( C30 + C37 ) ) = ( ( aSeq (C32 , D16) ) . C37 ) by L94 , L100 , L118
.= ( AddTo (C32 , ( intloc ( 0 ) )) ) by L107 , L119 , L118;
end;
L121: (for B59 being (Element of ( NAT )) holds (S2[ B59 ] implies S2[ ( B59 + 1 ) ]))
proof
let C38 being (Element of ( NAT ));
assume L122: S2[ C38 ];
assume L123: ( C38 + 1 ) <= D16;
per cases ;
suppose L124: C38 = ( 0 );

thus L125: ( IC ( Comput (R2 , C31 , ( C38 + 1 )) ) ) = ( ( Exec (( C32 := ( intloc ( 0 ) ) ) , C31) ) . ( IC ( SCM+FSA ) ) ) by L124 , L102
.= ( succ ( C30 + C38 ) ) by L92 , L124 , SCMFSA_2:63
.= ( ( C30 + C38 ) + 1 ) by NAT_1:38
.= ( C30 + ( C38 + 1 ) );
thus L126:now
assume L127: 1 <= ( C38 + 1 );
thus L128: ( ( Comput (R2 , C31 , ( C38 + 1 )) ) . C32 ) = ( ( Exec (( C32 := ( intloc ( 0 ) ) ) , C31) ) . C32 ) by L102 , L124
.= ( C38 + 1 ) by L91 , L124 , SCMFSA_2:63;
end;
thus L129:now
let C39 being Int-Location;
assume L130: C39 <> C32;
thus L131: ( ( Comput (R2 , C31 , ( C38 + 1 )) ) . C39 ) = ( ( Exec (( C32 := ( intloc ( 0 ) ) ) , C31) ) . C39 ) by L102 , L124
.= ( C31 . C39 ) by L130 , SCMFSA_2:63;
end;
let C40 being FinSeq-Location;
thus L132: ( ( Comput (R2 , C31 , ( C38 + 1 )) ) . C40 ) = ( ( Exec (( C32 := ( intloc ( 0 ) ) ) , C31) ) . C40 ) by L102 , L124
.= ( C31 . C40 ) by SCMFSA_2:63;
end;
suppose L133: C38 > ( 0 );

L134: C38 < D16 by L123 , NAT_1:13;
L135: ( C38 + ( 0 ) ) <= ( C38 + 1 ) by XREAL_1:7;
L136: ( CurInstr (R2 , ( Comput (R2 , C31 , C38) )) ) = ( R2 . ( C30 + C38 ) ) by L135 , L122 , L123 , PBOOLE:143 , XXREAL_0:2
.= ( AddTo (C32 , ( intloc ( 0 ) )) ) by L116 , L133 , L134;
L137: ( Comput (R2 , C31 , ( C38 + 1 )) ) = ( Following (R2 , ( Comput (R2 , C31 , C38) )) ) by EXTPRO_1:3
.= ( Exec (( AddTo (C32 , ( intloc ( 0 ) )) ) , ( Comput (R2 , C31 , C38) )) ) by L136;
thus L138: ( IC ( Comput (R2 , C31 , ( C38 + 1 )) ) ) = ( succ ( IC ( Comput (R2 , C31 , C38) ) ) ) by L137 , SCMFSA_2:64
.= ( ( C30 + C38 ) + 1 ) by L122 , L123 , L135 , NAT_1:38 , XXREAL_0:2
.= ( C30 + ( C38 + 1 ) );
L139: ( ( 0 ) + 1 ) <= C38 by L133 , INT_1:7;
thus L140:now
assume L141: 1 <= ( C38 + 1 );
thus L142: ( ( Comput (R2 , C31 , ( C38 + 1 )) ) . C32 ) = ( C38 + ( ( Comput (R2 , C31 , C38) ) . ( intloc ( 0 ) ) ) ) by L122 , L123 , L139 , L135 , L137 , SCMFSA_2:64 , XXREAL_0:2
.= ( C38 + 1 ) by L91 , L93 , L122 , L123 , L135 , XXREAL_0:2;
end;
thus L143:now
let C41 being Int-Location;
assume L144: C41 <> C32;
thus L145: ( ( Comput (R2 , C31 , ( C38 + 1 )) ) . C41 ) = ( ( Comput (R2 , C31 , C38) ) . C41 ) by L144 , L137 , SCMFSA_2:64
.= ( C31 . C41 ) by L122 , L123 , L135 , L144 , XXREAL_0:2;
end;
let C42 being FinSeq-Location;
thus L146: ( ( Comput (R2 , C31 , ( C38 + 1 )) ) . C42 ) = ( ( Comput (R2 , C31 , C38) ) . C42 ) by L137 , SCMFSA_2:64
.= ( C31 . C42 ) by L122 , L123 , L135 , XXREAL_0:2;
end;
end;
L148: S2[ ( 0 ) ] by L92 , EXTPRO_1:2;
L149: (for B60 being (Element of ( NAT )) holds S2[ B60 ]) from NAT_1:sch 1(L148 , L121);
let C43 being (Element of ( NAT ));
assume L150: C43 <= ( len ( aSeq (C32 , D16) ) );
thus L151: thesis by L150 , L98 , L149;
end;
thus L152: (for B61 being (Element of ( NAT )) holds (B61 <= ( len ( aSeq (C32 , C33) ) ) implies (( IC ( Comput (R2 , C31 , B61) ) ) = ( C30 + B61 ) & (for B62 being Int-Location holds (B62 <> C32 implies ( ( Comput (R2 , C31 , B61) ) . B62 ) = ( C31 . B62 ))) & (for B63 being FinSeq-Location holds ( ( Comput (R2 , C31 , B61) ) . B63 ) = ( C31 . B63 ))))) by L99;
L153: 1 <= ( len ( aSeq (C32 , C33) ) ) by L96 , L98 , NAT_1:11;
thus L154: thesis by L153 , L98 , L99;
end;
suppose L155: C33 <= ( 0 );

reconsider D18 = ( - C33 ) as (Element of ( NAT )) by L155 , INT_1:3;
defpred S3[ Nat ] means ($1 <= ( ( D18 + 1 ) + 1 ) implies (( IC ( Comput (R2 , C31 , $1) ) ) = ( C30 + $1 ) & (1 <= $1 implies ( ( Comput (R2 , C31 , $1) ) . C32 ) = ( ( ( - $1 ) + 1 ) + 1 )) & (for B64 being Int-Location holds (B64 <> C32 implies ( ( Comput (R2 , C31 , $1) ) . B64 ) = ( C31 . B64 ))) & (for B65 being FinSeq-Location holds ( ( Comput (R2 , C31 , $1) ) . B65 ) = ( C31 . B65 ))));
consider C44 being (Element of ( NAT )) such that L156: ( C44 + C33 ) = 1 and L157: ( aSeq (C32 , C33) ) = ( <% ( C32 := ( intloc ( 0 ) ) ) %> ^ ( C44 --> ( SubFrom (C32 , ( intloc ( 0 ) )) ) ) ) by L155 , L28;
L158: ( len ( aSeq (C32 , C33) ) ) = ( ( len <% ( C32 := ( intloc ( 0 ) ) ) %> ) + ( len ( C44 --> ( SubFrom (C32 , ( intloc ( 0 ) )) ) ) ) ) by L157 , AFINSQ_1:17
.= ( 1 + ( len ( C44 --> ( SubFrom (C32 , ( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:33
.= ( ( D18 + 1 ) + 1 ) by L156 , CARD_1:64;
L159: (for B66 being (Element of ( NAT )) holds (B66 <= ( len ( aSeq (C32 , C33) ) ) implies (( IC ( Comput (R2 , C31 , B66) ) ) = ( C30 + B66 ) & (1 <= B66 implies ( ( Comput (R2 , C31 , B66) ) . C32 ) = ( ( ( - B66 ) + 1 ) + 1 )) & (for B67 being Int-Location holds (B67 <> C32 implies ( ( Comput (R2 , C31 , B66) ) . B67 ) = ( C31 . B67 ))) & (for B68 being FinSeq-Location holds ( ( Comput (R2 , C31 , B66) ) . B68 ) = ( C31 . B68 )))))
proof
L160: (for B69 being (Element of ( NAT )) holds (B69 < ( ( D18 + 1 ) + 1 ) implies B69 in ( dom ( aSeq (C32 , C33) ) ))) by L158 , NAT_1:44;
L161: ( R2 . ( C30 + ( 0 ) ) ) = ( ( aSeq (C32 , C33) ) . ( 0 ) ) by L94 , L160
.= ( C32 := ( intloc ( 0 ) ) ) by L157 , AFINSQ_1:35;
L162: (for B70 being (Element of ( NAT )) holds (B70 = ( 0 ) implies (( Comput (R2 , C31 , B70) ) = C31 & ( CurInstr (R2 , ( Comput (R2 , C31 , B70) )) ) = ( C32 := ( intloc ( 0 ) ) ) & ( Comput (R2 , C31 , ( B70 + 1 )) ) = ( Exec (( C32 := ( intloc ( 0 ) ) ) , C31) ))))
proof
let C45 being (Element of ( NAT ));
assume L163: C45 = ( 0 );
thus L164: ( Comput (R2 , C31 , C45) ) = C31 by L163 , EXTPRO_1:2;
thus L165: ( CurInstr (R2 , ( Comput (R2 , C31 , C45) )) ) = ( C32 := ( intloc ( 0 ) ) ) by L164 , L92 , L161 , PBOOLE:143;
thus L166: ( Comput (R2 , C31 , ( C45 + 1 )) ) = ( Following (R2 , ( Comput (R2 , C31 , C45) )) ) by EXTPRO_1:3
.= ( Exec (( C32 := ( intloc ( 0 ) ) ) , C31) ) by L92 , L161 , L164 , PBOOLE:143;
end;
L167:
now
let C46 being (Element of ( NAT ));
assume that
L168: 1 <= C46
and
L169: C46 < ( ( D18 + 1 ) + 1 );
L170: ( C46 - 1 ) < ( ( ( D18 + 1 ) + 1 ) - 1 ) by L169 , XREAL_1:9;
reconsider D19 = ( C46 - 1 ) as (Element of ( NAT )) by L168 , INT_1:5;
L171: D19 in C44 by L156 , L170 , NAT_1:44;
L172: ( len ( C44 --> ( SubFrom (C32 , ( intloc ( 0 ) )) ) ) ) = C44 by CARD_1:64;
L173: ( len <% ( C32 := ( intloc ( 0 ) ) ) %> ) = 1 by AFINSQ_1:33;
thus L174: ( ( aSeq (C32 , C33) ) . C46 ) = ( ( C44 --> ( SubFrom (C32 , ( intloc ( 0 ) )) ) ) . ( C46 - 1 ) ) by L173 , L157 , L168 , L172 , L156 , L169 , AFINSQ_1:18
.= ( SubFrom (C32 , ( intloc ( 0 ) )) ) by L171 , FUNCOP_1:7;
end;
L175:
now
let C47 being (Element of ( NAT ));
assume that
L176: ( 0 ) < C47
and
L177: C47 < ( ( D18 + 1 ) + 1 );
L178: ( ( 0 ) + 1 ) <= C47 by L176 , NAT_1:13;
thus L179: ( R2 . ( C30 + C47 ) ) = ( ( aSeq (C32 , C33) ) . C47 ) by L94 , L160 , L177
.= ( SubFrom (C32 , ( intloc ( 0 ) )) ) by L167 , L178 , L177;
end;
L180: (for B71 being (Element of ( NAT )) holds (S3[ B71 ] implies S3[ ( B71 + 1 ) ]))
proof
let C48 being (Element of ( NAT ));
assume L181: S3[ C48 ];
assume L182: ( C48 + 1 ) <= ( ( D18 + 1 ) + 1 );
per cases ;
suppose L183: C48 = ( 0 );

thus L184: ( IC ( Comput (R2 , C31 , ( C48 + 1 )) ) ) = ( ( Exec (( C32 := ( intloc ( 0 ) ) ) , C31) ) . ( IC ( SCM+FSA ) ) ) by L183 , L162
.= ( succ ( C30 + C48 ) ) by L92 , L183 , SCMFSA_2:63
.= ( ( C30 + C48 ) + 1 ) by NAT_1:38
.= ( C30 + ( C48 + 1 ) );
thus L185:now
assume L186: 1 <= ( C48 + 1 );
thus L187: ( ( Comput (R2 , C31 , ( C48 + 1 )) ) . C32 ) = ( ( Exec (( C32 := ( intloc ( 0 ) ) ) , C31) ) . C32 ) by L162 , L183
.= ( ( ( - ( C48 + 1 ) ) + 1 ) + 1 ) by L91 , L183 , SCMFSA_2:63;
end;
thus L188:now
let C49 being Int-Location;
assume L189: C49 <> C32;
thus L190: ( ( Comput (R2 , C31 , ( C48 + 1 )) ) . C49 ) = ( ( Exec (( C32 := ( intloc ( 0 ) ) ) , C31) ) . C49 ) by L162 , L183
.= ( C31 . C49 ) by L189 , SCMFSA_2:63;
end;
let C50 being FinSeq-Location;
thus L191: ( ( Comput (R2 , C31 , ( C48 + 1 )) ) . C50 ) = ( ( Exec (( C32 := ( intloc ( 0 ) ) ) , C31) ) . C50 ) by L162 , L183
.= ( C31 . C50 ) by SCMFSA_2:63;
end;
suppose L192: C48 > ( 0 );

L193: C48 < ( ( D18 + 1 ) + 1 ) by L182 , NAT_1:13;
L194: ( C48 + ( 0 ) ) <= ( C48 + 1 ) by XREAL_1:7;
L195: ( CurInstr (R2 , ( Comput (R2 , C31 , C48) )) ) = ( R2 . ( C30 + C48 ) ) by L194 , L181 , L182 , PBOOLE:143 , XXREAL_0:2
.= ( SubFrom (C32 , ( intloc ( 0 ) )) ) by L175 , L192 , L193;
L196: ( Comput (R2 , C31 , ( C48 + 1 )) ) = ( Following (R2 , ( Comput (R2 , C31 , C48) )) ) by EXTPRO_1:3
.= ( Exec (( SubFrom (C32 , ( intloc ( 0 ) )) ) , ( Comput (R2 , C31 , C48) )) ) by L195;
thus L197: ( IC ( Comput (R2 , C31 , ( C48 + 1 )) ) ) = ( succ ( IC ( Comput (R2 , C31 , C48) ) ) ) by L196 , SCMFSA_2:65
.= ( ( C30 + C48 ) + 1 ) by L181 , L182 , L194 , NAT_1:38 , XXREAL_0:2
.= ( C30 + ( C48 + 1 ) );
L198: ( ( 0 ) + 1 ) < ( C48 + 1 ) by L192 , XREAL_1:6;
thus L199:now
assume L200: 1 <= ( C48 + 1 );
thus L201: ( ( Comput (R2 , C31 , ( C48 + 1 )) ) . C32 ) = ( ( ( ( - C48 ) + 1 ) + 1 ) - ( ( Comput (R2 , C31 , C48) ) . ( intloc ( 0 ) ) ) ) by L181 , L182 , L198 , L196 , NAT_1:13 , SCMFSA_2:65
.= ( ( ( ( - C48 ) + 1 ) + 1 ) - ( C31 . ( intloc ( 0 ) ) ) ) by L93 , L181 , L182 , L194 , XXREAL_0:2
.= ( ( ( - ( C48 + 1 ) ) + 1 ) + 1 ) by L91;
end;
thus L202:now
let C51 being Int-Location;
assume L203: C51 <> C32;
thus L204: ( ( Comput (R2 , C31 , ( C48 + 1 )) ) . C51 ) = ( ( Comput (R2 , C31 , C48) ) . C51 ) by L203 , L196 , SCMFSA_2:65
.= ( C31 . C51 ) by L181 , L182 , L194 , L203 , XXREAL_0:2;
end;
let C52 being FinSeq-Location;
thus L205: ( ( Comput (R2 , C31 , ( C48 + 1 )) ) . C52 ) = ( ( Comput (R2 , C31 , C48) ) . C52 ) by L196 , SCMFSA_2:65
.= ( C31 . C52 ) by L181 , L182 , L194 , XXREAL_0:2;
end;
end;
L207: S3[ ( 0 ) ] by L92 , EXTPRO_1:2;
L208: (for B72 being (Element of ( NAT )) holds S3[ B72 ]) from NAT_1:sch 1(L207 , L180);
let C53 being (Element of ( NAT ));
assume L209: C53 <= ( len ( aSeq (C32 , C33) ) );
thus L210: thesis by L209 , L158 , L208;
end;
thus L211: (for B73 being (Element of ( NAT )) holds (B73 <= ( len ( aSeq (C32 , C33) ) ) implies (( IC ( Comput (R2 , C31 , B73) ) ) = ( C30 + B73 ) & (for B74 being Int-Location holds (B74 <> C32 implies ( ( Comput (R2 , C31 , B73) ) . B74 ) = ( C31 . B74 ))) & (for B75 being FinSeq-Location holds ( ( Comput (R2 , C31 , B73) ) . B75 ) = ( C31 . B75 ))))) by L159;
L212: 1 <= ( len ( aSeq (C32 , C33) ) ) by L158 , NAT_1:11;
thus L213: ( ( Comput (R2 , C31 , ( len ( aSeq (C32 , C33) ) )) ) . C32 ) = ( ( ( - ( ( - C33 ) + ( 1 + 1 ) ) ) + 1 ) + 1 ) by L212 , L158 , L159
.= C33;
end;
end;
theorem
L215: (for R2 being (the InstructionsF of ( SCM+FSA )) -valued (ManySortedSet of ( NAT )) holds (for B76 being ( 0 ) -started (State of ( SCM+FSA )) holds (( B76 . ( intloc ( 0 ) ) ) = 1 implies (for B77 being Int-Location holds (for B78 being Integer holds ((( aSeq (B77 , B78) ) c= R2 & B77 <> ( intloc ( 0 ) )) implies ((for B79 being (Element of ( NAT )) holds (B79 <= ( len ( aSeq (B77 , B78) ) ) implies (( IC ( Comput (R2 , B76 , B79) ) ) = B79 & (for B80 being Int-Location holds (B80 <> B77 implies ( ( Comput (R2 , B76 , B79) ) . B80 ) = ( B76 . B80 ))) & (for B81 being FinSeq-Location holds ( ( Comput (R2 , B76 , B79) ) . B81 ) = ( B76 . B81 ))))) & ( ( Comput (R2 , B76 , ( len ( aSeq (B77 , B78) ) )) ) . B77 ) = B78)))))))
proof
let R2 being (the InstructionsF of ( SCM+FSA )) -valued (ManySortedSet of ( NAT ));
let C54 being ( 0 ) -started (State of ( SCM+FSA ));
assume L216: ( C54 . ( intloc ( 0 ) ) ) = 1;
let C55 being Int-Location;
let C56 being Integer;
assume that
L217: ( aSeq (C55 , C56) ) c= R2
and
L218: C55 <> ( intloc ( 0 ) );
L219: (for B82 being (Element of ( NAT )) holds (B82 in ( dom ( aSeq (C55 , C56) ) ) implies ( ( aSeq (C55 , C56) ) . B82 ) = ( R2 . ( ( 0 ) + B82 ) ))) by L217 , GRFUNC_1:2;
thus L220:now
let C57 being (Element of ( NAT ));
assume L221: C57 <= ( len ( aSeq (C55 , C56) ) );
L222: ( IC ( Comput (R2 , C54 , C57) ) ) = ( ( 0 ) + C57 ) by L221 , L216 , L218 , L219 , L90;
thus L223: (( IC ( Comput (R2 , C54 , C57) ) ) = C57 & (for B83 being Int-Location holds (B83 <> C55 implies ( ( Comput (R2 , C54 , C57) ) . B83 ) = ( C54 . B83 ))) & (for B84 being FinSeq-Location holds ( ( Comput (R2 , C54 , C57) ) . B84 ) = ( C54 . B84 ))) by L222 , L216 , L218 , L219 , L221 , L90;
end;
thus L224: thesis by L216 , L218 , L219 , L90;
end;
theorem
L225: (for R2 being (the InstructionsF of ( SCM+FSA )) -valued (ManySortedSet of ( NAT )) holds (for B85 being ( 0 ) -started (State of ( SCM+FSA )) holds (( B85 . ( intloc ( 0 ) ) ) = 1 implies (for B86 being Int-Location holds (for B87 being Integer holds ((( B86 := B87 ) c= R2 & B86 <> ( intloc ( 0 ) )) implies (R2 halts_on B85 & ( ( Result (R2 , B85) ) . B86 ) = B87 & (for B88 being Int-Location holds (B88 <> B86 implies ( ( Result (R2 , B85) ) . B88 ) = ( B85 . B88 ))) & (for B89 being FinSeq-Location holds ( ( Result (R2 , B85) ) . B89 ) = ( B85 . B89 )))))))))
proof
let R2 being (the InstructionsF of ( SCM+FSA )) -valued (ManySortedSet of ( NAT ));
let C58 being ( 0 ) -started (State of ( SCM+FSA ));
assume that
L226: ( C58 . ( intloc ( 0 ) ) ) = 1;
L227: ( IC C58 ) = ( 0 ) by MEMSTR_0:def 11;
let C59 being Int-Location;
let C60 being Integer;
assume that
L228: ( C59 := C60 ) c= R2
and
L229: C59 <> ( intloc ( 0 ) );
per cases ;
suppose L230: C60 > ( 0 );

consider C61 being (Element of ( NAT )) such that L231: ( C61 + 1 ) = C60 and L232: ( C59 := C60 ) = ( ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( C61 --> ( AddTo (C59 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> ) by L230 , L18;
L233: ( len ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( C61 --> ( AddTo (C59 , ( intloc ( 0 ) )) ) ) ) ) = ( ( len <% ( C59 := ( intloc ( 0 ) ) ) %> ) + ( len ( C61 --> ( AddTo (C59 , ( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:17
.= ( 1 + ( len ( C61 --> ( AddTo (C59 , ( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:33
.= C60 by L231 , CARD_1:64;
reconsider D20 = C60 as (Element of ( NAT )) by L230 , INT_1:3;
defpred S4[ Nat ] means ($1 <= D20 implies ((1 <= $1 implies ( ( Comput (R2 , C58 , $1) ) . C59 ) = $1) & (for B90 being Int-Location holds (B90 <> C59 implies ( ( Comput (R2 , C58 , $1) ) . B90 ) = ( C58 . B90 ))) & (for B91 being FinSeq-Location holds ( ( Comput (R2 , C58 , $1) ) . B91 ) = ( C58 . B91 ))));
set D21 = ( ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( C61 --> ( AddTo (C59 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> );
L234: ( D21 . ( 0 ) ) = ( ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( ( C61 --> ( AddTo (C59 , ( intloc ( 0 ) )) ) ) ^ <% ( halt ( SCM+FSA ) ) %> ) ) . ( 0 ) ) by AFINSQ_1:27
.= ( C59 := ( intloc ( 0 ) ) ) by AFINSQ_1:35;
L235: ( len D21 ) = ( ( len ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( C61 --> ( AddTo (C59 , ( intloc ( 0 ) )) ) ) ) ) + ( len <% ( halt ( SCM+FSA ) ) %> ) ) by AFINSQ_1:17
.= ( D20 + 1 ) by L233 , AFINSQ_1:33;
L236:
now
let C62 being (Element of ( NAT ));
assume that
L237: C62 <= D20;
L238: C62 < ( D20 + 1 ) by L237 , NAT_1:13;
thus L239: C62 in ( dom D21 ) by L238 , L235 , NAT_1:44;
end;
L240:
now
let C63 being (Element of ( NAT ));
assume that
L241: C63 <= D20;
L242: C63 in ( dom D21 ) by L236 , L241;
thus L243: ( R2 . C63 ) = ( D21 . C63 ) by L242 , L228 , L232 , GRFUNC_1:2;
end;
L244: ( R2 . ( 0 ) ) = ( C59 := ( intloc ( 0 ) ) ) by L240 , L234;
L245:
now
let C64 being (Element of ( NAT ));
assume L246: C64 = ( 0 );
thus L247: ( Comput (R2 , C58 , C64) ) = C58 by L246 , EXTPRO_1:2;
thus L248: ( CurInstr (R2 , ( Comput (R2 , C58 , C64) )) ) = ( C59 := ( intloc ( 0 ) ) ) by L247 , L227 , L244 , PBOOLE:143;
thus L249: ( Comput (R2 , C58 , ( C64 + 1 )) ) = ( Following (R2 , ( Comput (R2 , C58 , C64) )) ) by EXTPRO_1:3
.= ( Exec (( C59 := ( intloc ( 0 ) ) ) , C58) ) by L227 , L244 , L247 , PBOOLE:143;
end;
L250:
now
let C65 being (Element of ( NAT ));
assume that
L251: 1 <= C65
and
L252: C65 < D20;
reconsider D22 = ( C65 - 1 ) as (Element of ( NAT )) by L251 , INT_1:5;
L253: ( C65 - 1 ) < ( D20 - 1 ) by L252 , XREAL_1:9;
L254: D22 in C61 by L253 , L231 , NAT_1:44;
L255: ( len <% ( C59 := ( intloc ( 0 ) ) ) %> ) = 1 by AFINSQ_1:33;
L256: ( len ( C61 --> ( AddTo (C59 , ( intloc ( 0 ) )) ) ) ) = C61 by CARD_1:64;
L257: C65 in ( dom ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( C61 --> ( AddTo (C59 , ( intloc ( 0 ) )) ) ) ) ) by L252 , L233 , NAT_1:44;
thus L258: ( D21 . C65 ) = ( ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( C61 --> ( AddTo (C59 , ( intloc ( 0 ) )) ) ) ) . C65 ) by L257 , AFINSQ_1:def 3
.= ( ( C61 --> ( AddTo (C59 , ( intloc ( 0 ) )) ) ) . ( C65 - 1 ) ) by L251 , L252 , L255 , L256 , L231 , AFINSQ_1:18
.= ( AddTo (C59 , ( intloc ( 0 ) )) ) by L254 , FUNCOP_1:7;
end;
L259:
now
let C66 being (Element of ( NAT ));
assume that
L260: ( 0 ) < C66
and
L261: C66 < D20;
L262: ( ( 0 ) + 1 ) <= C66 by L260 , NAT_1:13;
thus L263: ( R2 . C66 ) = ( D21 . C66 ) by L240 , L261
.= ( AddTo (C59 , ( intloc ( 0 ) )) ) by L250 , L262 , L261;
end;
L264: (for B92 being (Element of ( NAT )) holds (B92 <= D20 implies ( IC ( Comput (R2 , C58 , B92) ) ) = B92))
proof
defpred S5[ Nat ] means ($1 <= D20 implies ( IC ( Comput (R2 , C58 , $1) ) ) = $1);
let C67 being (Element of ( NAT ));
assume L265: C67 <= D20;
L266: (for B93 being (Element of ( NAT )) holds (S5[ B93 ] implies S5[ ( B93 + 1 ) ]))
proof
let C68 being (Element of ( NAT ));
assume L267: S5[ C68 ];
assume L268: ( C68 + 1 ) <= D20;
L269: C68 < D20 by L268 , NAT_1:13;
per cases ;
suppose L270: C68 = ( 0 );

thus L271: ( IC ( Comput (R2 , C58 , ( C68 + 1 )) ) ) = ( ( Exec (( C59 := ( intloc ( 0 ) ) ) , C58) ) . ( IC ( SCM+FSA ) ) ) by L270 , L245
.= ( succ C68 ) by L227 , L270 , SCMFSA_2:63
.= ( C68 + 1 ) by NAT_1:38;
end;
suppose L272: C68 > ( 0 );

L273: ( C68 + ( 0 ) ) <= ( C68 + 1 ) by XREAL_1:7;
L274: ( CurInstr (R2 , ( Comput (R2 , C58 , C68) )) ) = ( R2 . C68 ) by L273 , L267 , L268 , PBOOLE:143 , XXREAL_0:2
.= ( AddTo (C59 , ( intloc ( 0 ) )) ) by L259 , L269 , L272;
L275: ( Comput (R2 , C58 , ( C68 + 1 )) ) = ( Following (R2 , ( Comput (R2 , C58 , C68) )) ) by EXTPRO_1:3
.= ( Exec (( AddTo (C59 , ( intloc ( 0 ) )) ) , ( Comput (R2 , C58 , C68) )) ) by L274;
thus L276: ( IC ( Comput (R2 , C58 , ( C68 + 1 )) ) ) = ( succ ( IC ( Comput (R2 , C58 , C68) ) ) ) by L275 , SCMFSA_2:64
.= ( C68 + 1 ) by L267 , L268 , NAT_1:13 , NAT_1:38;
end;
end;
L278: S5[ ( 0 ) ] by L227 , EXTPRO_1:2;
L279: (for B94 being (Element of ( NAT )) holds S5[ B94 ]) from NAT_1:sch 1(L278 , L266);
thus L280: thesis by L279 , L265;
end;
L281: (for B95 being (Element of ( NAT )) holds (S4[ B95 ] implies S4[ ( B95 + 1 ) ]))
proof
let C69 being (Element of ( NAT ));
assume L282: S4[ C69 ];
assume L283: ( C69 + 1 ) <= D20;
per cases ;
suppose L284: C69 = ( 0 );

thus L285:now
assume L286: 1 <= ( C69 + 1 );
thus L287: ( ( Comput (R2 , C58 , ( C69 + 1 )) ) . C59 ) = ( ( Exec (( C59 := ( intloc ( 0 ) ) ) , C58) ) . C59 ) by L245 , L284
.= ( C69 + 1 ) by L226 , L284 , SCMFSA_2:63;
end;
thus L288:now
let C70 being Int-Location;
assume L289: C70 <> C59;
thus L290: ( ( Comput (R2 , C58 , ( C69 + 1 )) ) . C70 ) = ( ( Exec (( C59 := ( intloc ( 0 ) ) ) , C58) ) . C70 ) by L245 , L284
.= ( C58 . C70 ) by L289 , SCMFSA_2:63;
end;
let C71 being FinSeq-Location;
thus L291: ( ( Comput (R2 , C58 , ( C69 + 1 )) ) . C71 ) = ( ( Exec (( C59 := ( intloc ( 0 ) ) ) , C58) ) . C71 ) by L245 , L284
.= ( C58 . C71 ) by SCMFSA_2:63;
end;
suppose L292: C69 > ( 0 );

L293: C69 < D20 by L283 , NAT_1:13;
L294: ( R2 /. ( IC ( Comput (R2 , C58 , C69) ) ) ) = ( R2 . ( IC ( Comput (R2 , C58 , C69) ) ) ) by PBOOLE:143;
L295: ( C69 + ( 0 ) ) <= ( C69 + 1 ) by XREAL_1:7;
L296: ( CurInstr (R2 , ( Comput (R2 , C58 , C69) )) ) = ( R2 . C69 ) by L295 , L264 , L283 , L294 , XXREAL_0:2
.= ( R2 . C69 )
.= ( AddTo (C59 , ( intloc ( 0 ) )) ) by L259 , L292 , L293;
L297: ( Comput (R2 , C58 , ( C69 + 1 )) ) = ( Following (R2 , ( Comput (R2 , C58 , C69) )) ) by EXTPRO_1:3
.= ( Exec (( AddTo (C59 , ( intloc ( 0 ) )) ) , ( Comput (R2 , C58 , C69) )) ) by L296;
L298: ( ( 0 ) + 1 ) <= C69 by L292 , INT_1:7;
thus L299:now
assume L300: 1 <= ( C69 + 1 );
thus L301: ( ( Comput (R2 , C58 , ( C69 + 1 )) ) . C59 ) = ( C69 + ( ( Comput (R2 , C58 , C69) ) . ( intloc ( 0 ) ) ) ) by L282 , L283 , L298 , L295 , L297 , SCMFSA_2:64 , XXREAL_0:2
.= ( C69 + 1 ) by L226 , L229 , L282 , L283 , L295 , XXREAL_0:2;
end;
thus L302:now
let C72 being Int-Location;
assume L303: C72 <> C59;
thus L304: ( ( Comput (R2 , C58 , ( C69 + 1 )) ) . C72 ) = ( ( Comput (R2 , C58 , C69) ) . C72 ) by L303 , L297 , SCMFSA_2:64
.= ( C58 . C72 ) by L282 , L283 , L295 , L303 , XXREAL_0:2;
end;
let C73 being FinSeq-Location;
thus L305: ( ( Comput (R2 , C58 , ( C69 + 1 )) ) . C73 ) = ( ( Comput (R2 , C58 , C69) ) . C73 ) by L297 , SCMFSA_2:64
.= ( C58 . C73 ) by L282 , L283 , L295 , XXREAL_0:2;
end;
end;
L307: D20 < ( D20 + ( len <% ( halt ( SCM+FSA ) ) %> ) ) by XREAL_1:29;
L308: ( D21 . D20 ) = ( <% ( halt ( SCM+FSA ) ) %> . ( D20 - D20 ) ) by L307 , L233 , AFINSQ_1:18
.= ( halt ( SCM+FSA ) ) by AFINSQ_1:34;
L309: ( ( 0 ) + 1 ) < ( D20 + 1 ) by L230 , XREAL_1:6;
L310: 1 <= D20 by L309 , NAT_1:13;
L311: S4[ ( 0 ) ] by EXTPRO_1:2;
L312: (for B96 being (Element of ( NAT )) holds S4[ B96 ]) from NAT_1:sch 1(L311 , L281);
L313: ( R2 /. ( IC ( Comput (R2 , C58 , D20) ) ) ) = ( R2 . ( IC ( Comput (R2 , C58 , D20) ) ) ) by PBOOLE:143;
L314: ( CurInstr (R2 , ( Comput (R2 , C58 , D20) )) ) = ( R2 . D20 ) by L264 , L313
.= ( halt ( SCM+FSA ) ) by L308 , L240;
thus L315: R2 halts_on C58 by L314 , EXTPRO_1:29;
L316: ( Comput (R2 , C58 , D20) ) = ( Result (R2 , C58) ) by L315 , L314 , EXTPRO_1:def 9;
thus L317: thesis by L316 , L312 , L310;
end;
suppose L318: C60 <= ( 0 );

reconsider D23 = ( - C60 ) as (Element of ( NAT )) by L318 , INT_1:3;
defpred S6[ Nat ] means ($1 <= ( ( D23 + 1 ) + 1 ) implies ((1 <= $1 implies ( ( Comput (R2 , C58 , $1) ) . C59 ) = ( ( ( - $1 ) + 1 ) + 1 )) & (for B97 being Int-Location holds (B97 <> C59 implies ( ( Comput (R2 , C58 , $1) ) . B97 ) = ( C58 . B97 ))) & (for B98 being FinSeq-Location holds ( ( Comput (R2 , C58 , $1) ) . B98 ) = ( C58 . B98 ))));
consider C74 being (Element of ( NAT )) such that L319: ( C74 + C60 ) = 1 and L320: ( C59 := C60 ) = ( ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( C74 --> ( SubFrom (C59 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> ) by L318 , L18;
L321: ( len ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( C74 --> ( SubFrom (C59 , ( intloc ( 0 ) )) ) ) ) ) = ( ( len <% ( C59 := ( intloc ( 0 ) ) ) %> ) + ( len ( C74 --> ( SubFrom (C59 , ( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:17
.= ( 1 + ( len ( C74 --> ( SubFrom (C59 , ( intloc ( 0 ) )) ) ) ) ) by AFINSQ_1:33
.= ( ( D23 + 1 ) + 1 ) by L319 , CARD_1:64;
set D24 = ( ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( C74 --> ( SubFrom (C59 , ( intloc ( 0 ) )) ) ) ) ^ <% ( halt ( SCM+FSA ) ) %> );
L322: ( D24 . ( 0 ) ) = ( ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( ( C74 --> ( SubFrom (C59 , ( intloc ( 0 ) )) ) ) ^ <% ( halt ( SCM+FSA ) ) %> ) ) . ( 0 ) ) by AFINSQ_1:27
.= ( C59 := ( intloc ( 0 ) ) ) by AFINSQ_1:35;
L323: ( len D24 ) = ( ( len ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( C74 --> ( SubFrom (C59 , ( intloc ( 0 ) )) ) ) ) ) + ( len <% ( halt ( SCM+FSA ) ) %> ) ) by AFINSQ_1:17
.= ( ( ( D23 + 1 ) + 1 ) + 1 ) by L321 , AFINSQ_1:33;
L324:
now
let C75 being (Element of ( NAT ));
assume that
L325: C75 <= ( ( D23 + 1 ) + 1 );
L326: C75 < ( ( ( D23 + 1 ) + 1 ) + 1 ) by L325 , NAT_1:13;
thus L327: C75 in ( dom D24 ) by L326 , L323 , NAT_1:44;
end;
L328:
now
let C76 being (Element of ( NAT ));
assume that
L329: C76 <= ( ( D23 + 1 ) + 1 );
L330: C76 in ( dom D24 ) by L324 , L329;
thus L331: ( R2 . C76 ) = ( D24 . C76 ) by L330 , L228 , L320 , GRFUNC_1:2;
end;
L332: ( R2 . ( 0 ) ) = ( C59 := ( intloc ( 0 ) ) ) by L328 , L322;
L333:
now
let C77 being (Element of ( NAT ));
assume L334: C77 = ( 0 );
thus L335: ( Comput (R2 , C58 , C77) ) = C58 by L334 , EXTPRO_1:2;
thus L336: ( CurInstr (R2 , ( Comput (R2 , C58 , C77) )) ) = ( C59 := ( intloc ( 0 ) ) ) by L335 , L227 , L332 , PBOOLE:143;
thus L337: ( Comput (R2 , C58 , ( C77 + 1 )) ) = ( Following (R2 , ( Comput (R2 , C58 , C77) )) ) by EXTPRO_1:3
.= ( Exec (( C59 := ( intloc ( 0 ) ) ) , C58) ) by L227 , L332 , L335 , PBOOLE:143;
end;
L338:
now
L339: ( len <% ( C59 := ( intloc ( 0 ) ) ) %> ) = 1 by AFINSQ_1:33;
let C78 being (Element of ( NAT ));
assume that
L340: 1 <= C78
and
L341: C78 < ( ( D23 + 1 ) + 1 );
reconsider D25 = ( C78 - 1 ) as (Element of ( NAT )) by L340 , INT_1:5;
L342: ( C78 - 1 ) < ( ( C74 + 1 ) - 1 ) by L341 , L319 , XREAL_1:9;
L343: D25 in C74 by L342 , NAT_1:44;
L344: ( len ( C74 --> ( SubFrom (C59 , ( intloc ( 0 ) )) ) ) ) = C74 by CARD_1:64;
L345: C78 in ( dom ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( C74 --> ( SubFrom (C59 , ( intloc ( 0 ) )) ) ) ) ) by L341 , L321 , NAT_1:44;
thus L346: ( D24 . C78 ) = ( ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( C74 --> ( SubFrom (C59 , ( intloc ( 0 ) )) ) ) ) . C78 ) by L345 , AFINSQ_1:def 3
.= ( ( C74 --> ( SubFrom (C59 , ( intloc ( 0 ) )) ) ) . ( C78 - 1 ) ) by L319 , L340 , L341 , L339 , L344 , AFINSQ_1:18
.= ( SubFrom (C59 , ( intloc ( 0 ) )) ) by L343 , FUNCOP_1:7;
end;
L347:
now
let C79 being (Element of ( NAT ));
assume that
L348: ( 0 ) < C79
and
L349: C79 < ( ( D23 + 1 ) + 1 );
L350: ( ( 0 ) + 1 ) <= C79 by L348 , NAT_1:13;
thus L351: ( R2 . C79 ) = ( D24 . C79 ) by L328 , L349
.= ( SubFrom (C59 , ( intloc ( 0 ) )) ) by L338 , L350 , L349;
end;
L352: (for B99 being (Element of ( NAT )) holds (B99 <= ( ( D23 + 1 ) + 1 ) implies ( IC ( Comput (R2 , C58 , B99) ) ) = B99))
proof
defpred S7[ Nat ] means ($1 <= ( ( D23 + 1 ) + 1 ) implies ( IC ( Comput (R2 , C58 , $1) ) ) = $1);
let C80 being (Element of ( NAT ));
assume L353: C80 <= ( ( D23 + 1 ) + 1 );
L354: (for B100 being (Element of ( NAT )) holds (S7[ B100 ] implies S7[ ( B100 + 1 ) ]))
proof
let C81 being (Element of ( NAT ));
assume L355: S7[ C81 ];
assume L356: ( C81 + 1 ) <= ( ( D23 + 1 ) + 1 );
L357: C81 < ( ( D23 + 1 ) + 1 ) by L356 , NAT_1:13;
per cases ;
suppose L358: C81 = ( 0 );

thus L359: ( IC ( Comput (R2 , C58 , ( C81 + 1 )) ) ) = ( ( Exec (( C59 := ( intloc ( 0 ) ) ) , C58) ) . ( IC ( SCM+FSA ) ) ) by L358 , L333
.= ( succ C81 ) by L227 , L358 , SCMFSA_2:63
.= ( C81 + 1 ) by NAT_1:38;
end;
suppose L360: C81 > ( 0 );

L361: ( C81 + ( 0 ) ) <= ( C81 + 1 ) by XREAL_1:7;
L362: ( CurInstr (R2 , ( Comput (R2 , C58 , C81) )) ) = ( R2 . C81 ) by L361 , L355 , L356 , PBOOLE:143 , XXREAL_0:2
.= ( SubFrom (C59 , ( intloc ( 0 ) )) ) by L347 , L357 , L360;
L363: ( Comput (R2 , C58 , ( C81 + 1 )) ) = ( Following (R2 , ( Comput (R2 , C58 , C81) )) ) by EXTPRO_1:3
.= ( Exec (( SubFrom (C59 , ( intloc ( 0 ) )) ) , ( Comput (R2 , C58 , C81) )) ) by L362;
thus L364: ( IC ( Comput (R2 , C58 , ( C81 + 1 )) ) ) = ( succ ( IC ( Comput (R2 , C58 , C81) ) ) ) by L363 , SCMFSA_2:65
.= ( C81 + 1 ) by L355 , L356 , NAT_1:13 , NAT_1:38;
end;
end;
L366: S7[ ( 0 ) ] by L227 , EXTPRO_1:2;
L367: (for B101 being (Element of ( NAT )) holds S7[ B101 ]) from NAT_1:sch 1(L366 , L354);
thus L368: thesis by L367 , L353;
end;
L369: (for B102 being (Element of ( NAT )) holds (S6[ B102 ] implies S6[ ( B102 + 1 ) ]))
proof
let C82 being (Element of ( NAT ));
assume L370: S6[ C82 ];
assume L371: ( C82 + 1 ) <= ( ( D23 + 1 ) + 1 );
per cases ;
suppose L372: C82 = ( 0 );

thus L373:now
assume L374: 1 <= ( C82 + 1 );
thus L375: ( ( Comput (R2 , C58 , ( C82 + 1 )) ) . C59 ) = ( ( Exec (( C59 := ( intloc ( 0 ) ) ) , C58) ) . C59 ) by L333 , L372
.= ( ( ( - ( C82 + 1 ) ) + 1 ) + 1 ) by L226 , L372 , SCMFSA_2:63;
end;
thus L376:now
let C83 being Int-Location;
assume L377: C83 <> C59;
thus L378: ( ( Comput (R2 , C58 , ( C82 + 1 )) ) . C83 ) = ( ( Exec (( C59 := ( intloc ( 0 ) ) ) , C58) ) . C83 ) by L333 , L372
.= ( C58 . C83 ) by L377 , SCMFSA_2:63;
end;
let C84 being FinSeq-Location;
thus L379: ( ( Comput (R2 , C58 , ( C82 + 1 )) ) . C84 ) = ( ( Exec (( C59 := ( intloc ( 0 ) ) ) , C58) ) . C84 ) by L333 , L372
.= ( C58 . C84 ) by SCMFSA_2:63;
end;
suppose L380: C82 > ( 0 );

L381: C82 < ( ( D23 + 1 ) + 1 ) by L371 , NAT_1:13;
L382: ( R2 /. ( IC ( Comput (R2 , C58 , C82) ) ) ) = ( R2 . ( IC ( Comput (R2 , C58 , C82) ) ) ) by PBOOLE:143;
L383: ( C82 + ( 0 ) ) <= ( C82 + 1 ) by XREAL_1:7;
L384: ( CurInstr (R2 , ( Comput (R2 , C58 , C82) )) ) = ( R2 . C82 ) by L383 , L352 , L371 , L382 , XXREAL_0:2
.= ( R2 . C82 )
.= ( SubFrom (C59 , ( intloc ( 0 ) )) ) by L347 , L380 , L381;
L385: ( Comput (R2 , C58 , ( C82 + 1 )) ) = ( Following (R2 , ( Comput (R2 , C58 , C82) )) ) by EXTPRO_1:3
.= ( Exec (( SubFrom (C59 , ( intloc ( 0 ) )) ) , ( Comput (R2 , C58 , C82) )) ) by L384;
L386: ( ( 0 ) + 1 ) < ( C82 + 1 ) by L380 , XREAL_1:6;
thus L387:now
assume L388: 1 <= ( C82 + 1 );
thus L389: ( ( Comput (R2 , C58 , ( C82 + 1 )) ) . C59 ) = ( ( ( ( - C82 ) + 1 ) + 1 ) - ( ( Comput (R2 , C58 , C82) ) . ( intloc ( 0 ) ) ) ) by L370 , L371 , L386 , L385 , NAT_1:13 , SCMFSA_2:65
.= ( ( ( ( - C82 ) + 1 ) + 1 ) - ( C58 . ( intloc ( 0 ) ) ) ) by L229 , L370 , L371 , L383 , XXREAL_0:2
.= ( ( ( - ( C82 + 1 ) ) + 1 ) + 1 ) by L226;
end;
thus L390:now
let C85 being Int-Location;
assume L391: C85 <> C59;
thus L392: ( ( Comput (R2 , C58 , ( C82 + 1 )) ) . C85 ) = ( ( Comput (R2 , C58 , C82) ) . C85 ) by L391 , L385 , SCMFSA_2:65
.= ( C58 . C85 ) by L370 , L371 , L383 , L391 , XXREAL_0:2;
end;
let C86 being FinSeq-Location;
thus L393: ( ( Comput (R2 , C58 , ( C82 + 1 )) ) . C86 ) = ( ( Comput (R2 , C58 , C82) ) . C86 ) by L385 , SCMFSA_2:65
.= ( C58 . C86 ) by L370 , L371 , L383 , XXREAL_0:2;
end;
end;
L395: ((( len ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( C74 --> ( SubFrom (C59 , ( intloc ( 0 ) )) ) ) ) ) <= ( ( D23 + 1 ) + 1 ) & ( ( D23 + 1 ) + 1 ) < ( ( len ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( C74 --> ( SubFrom (C59 , ( intloc ( 0 ) )) ) ) ) ) + ( len <% ( halt ( SCM+FSA ) ) %> ) )) implies ( D24 . ( ( D23 + 1 ) + 1 ) ) = ( <% ( halt ( SCM+FSA ) ) %> . ( ( ( D23 + 1 ) + 1 ) - ( len ( <% ( C59 := ( intloc ( 0 ) ) ) %> ^ ( C74 --> ( SubFrom (C59 , ( intloc ( 0 ) )) ) ) ) ) ) )) by AFINSQ_1:18;
L396: ( D24 . ( ( D23 + 1 ) + 1 ) ) = ( halt ( SCM+FSA ) ) by L395 , L321 , AFINSQ_1:34 , XREAL_1:29;
L397: ( R2 /. ( IC ( Comput (R2 , C58 , ( ( D23 + 1 ) + 1 )) ) ) ) = ( R2 . ( IC ( Comput (R2 , C58 , ( ( D23 + 1 ) + 1 )) ) ) ) by PBOOLE:143;
L398: ( CurInstr (R2 , ( Comput (R2 , C58 , ( ( D23 + 1 ) + 1 )) )) ) = ( R2 . ( ( D23 + 1 ) + 1 ) ) by L352 , L397
.= ( halt ( SCM+FSA ) ) by L396 , L328;
thus L399: R2 halts_on C58 by L398 , EXTPRO_1:29;
L400: ( Comput (R2 , C58 , ( ( D23 + 1 ) + 1 )) ) = ( Result (R2 , C58) ) by L399 , L398 , EXTPRO_1:def 9;
L401: S6[ ( 0 ) ] by EXTPRO_1:2;
L402: (for B103 being (Element of ( NAT )) holds S6[ B103 ]) from NAT_1:sch 1(L401 , L369);
L403: (( ( ( - ( ( D23 + 1 ) + 1 ) ) + 1 ) + 1 ) = C60 & ( ( 0 ) + 1 ) <= ( D23 + ( 1 + 1 ) )) by XREAL_1:7;
thus L404: thesis by L403 , L402 , L400;
end;
end;
theorem
L406: (for R2 being (the InstructionsF of ( SCM+FSA )) -valued (ManySortedSet of ( NAT )) holds (for B104 being ( 0 ) -started (State of ( SCM+FSA )) holds (( B104 . ( intloc ( 0 ) ) ) = 1 implies (for B105 being FinSeq-Location holds (for B106 being (FinSequence of ( INT )) holds (( B105 := B106 ) c= R2 implies (R2 halts_on B104 & ( ( Result (R2 , B104) ) . B105 ) = B106 & (for B107 being Int-Location holds ((B107 <> ( intloc 1 ) & B107 <> ( intloc 2 )) implies ( ( Result (R2 , B104) ) . B107 ) = ( B104 . B107 ))) & (for B108 being FinSeq-Location holds (B108 <> B105 implies ( ( Result (R2 , B104) ) . B108 ) = ( B104 . B108 ))))))))))
proof
let R2 being (the InstructionsF of ( SCM+FSA )) -valued (ManySortedSet of ( NAT ));
set D26 = (the InstructionsF of ( SCM+FSA ));
set D27 = ( intloc 2 );
set D28 = ( intloc 1 );
set D29 = ( intloc ( 0 ) );
L407: D28 <> D29 by AMI_3:10;
L408: D28 <> D27 by AMI_3:10;
let C87 being ( 0 ) -started (State of ( SCM+FSA ));
assume that
L409: ( C87 . D29 ) = 1;
let C88 being FinSeq-Location;
let C89 being (FinSequence of ( INT ));
assume that
L410: ( C88 := C89 ) c= R2;
set D30 = ( ( ( ( aSeq (D28 , ( len C89 )) ) ^ <% ( C88 :=<0,...,0> D28 ) %> ) ^ ( aSeq (C88 , C89) ) ) ^ <% ( halt ( SCM+FSA ) ) %> );
L411:
now
let C90 , C91 being (Element of ( NAT ));
assume L412: C90 < ( len D30 );
L413: C90 in ( dom D30 ) by L412 , NAT_1:44;
thus L414: ( R2 . C90 ) = ( R2 . C90 )
.= ( D30 . C90 ) by L410 , L413 , GRFUNC_1:2;
end;
set D31 = ( ( aSeq (D28 , ( len C89 )) ) ^ <% ( C88 :=<0,...,0> D28 ) %> );
consider C92 being (XFinSequence of ( D26 ^omega )) such that L415: ( len C92 ) = ( len C89 ) and L416: (for B109 being (Element of ( NAT )) holds (B109 < ( len C92 ) implies (ex B110 being Integer st (B110 = ( C89 . ( B109 + 1 ) ) & ( C92 . B109 ) = ( ( ( aSeq (D28 , ( B109 + 1 )) ) ^ ( aSeq (D27 , B110) ) ) ^ <% ( (C88 , D28) := D27 ) %> ))))) and L417: ( aSeq (C88 , C89) ) = ( FlattenSeq C92 ) by L46;
L418: ( len <% ( halt ( SCM+FSA ) ) %> ) = 1 by AFINSQ_1:34;
L419: ( len D30 ) = ( ( len ( D31 ^ ( FlattenSeq C92 ) ) ) + 1 ) by L418 , L417 , AFINSQ_1:17;
L420: ( len ( D31 ^ ( FlattenSeq C92 ) ) ) < ( len D30 ) by L419 , NAT_1:13;
defpred S8[ XFinSequence ] means ($1 c= C92 implies (ex B111 being (XFinSequence of ( D26 ^omega )) st (B111 = $1 & (for B112 being (Element of ( NAT )) holds (B112 <= ( len ( D31 ^ ( FlattenSeq B111 ) ) ) implies ( IC ( Comput (R2 , C87 , B112) ) ) = B112)) & ( ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq B111 ) ) )) ) . C88 ) | ( len B111 ) ) = ( C89 | ( len B111 ) ) & ( len ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq B111 ) ) )) ) . C88 ) ) = ( len C89 ) & (for B113 being Int-Location holds ((B113 <> D28 & B113 <> D27) implies ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq B111 ) ) )) ) . B113 ) = ( C87 . B113 ))) & (for B114 being FinSeq-Location holds (B114 <> C88 implies ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq B111 ) ) )) ) . B114 ) = ( C87 . B114 ))))));
L421: D27 <> D29 by AMI_3:10;
L422: (for B115 being XFinSequence holds (for B116 being set holds (S8[ B115 ] implies S8[ ( B115 ^ <% B116 %> ) ])))
proof
let C93 being XFinSequence;
let C94 being set;
assume L423: S8[ C93 ];
set D32 = ( len C93 );
L424: ( len <% C94 %> ) = 1 by AFINSQ_1:34;
L425: ( len ( C93 ^ <% C94 %> ) ) = ( D32 + 1 ) by L424 , AFINSQ_1:17;
L426: D32 < ( len ( C93 ^ <% C94 %> ) ) by L425 , XREAL_1:29;
L427: D32 in ( dom ( C93 ^ <% C94 %> ) ) by L426 , NAT_1:44;
assume L428: ( C93 ^ <% C94 %> ) c= C92;
L429: ( dom ( C93 ^ <% C94 %> ) ) c= ( dom C92 ) by L428 , GRFUNC_1:2;
L430: D32 < ( len C92 ) by L429 , L427 , NAT_1:44;
consider C95 being Integer such that L431: C95 = ( C89 . ( D32 + 1 ) ) and L432: ( C92 . D32 ) = ( ( ( aSeq (D28 , ( D32 + 1 )) ) ^ ( aSeq (D27 , C95) ) ) ^ <% ( (C88 , D28) := D27 ) %> ) by L430 , L416;
L433: (1 <= ( D32 + 1 ) & ( D32 + 1 ) <= ( len C92 )) by L430 , NAT_1:11 , NAT_1:13;
L434: ( D32 + 1 ) in ( Seg ( len C92 ) ) by L433;
L435: C93 c= ( C93 ^ <% C94 %> ) by AFINSQ_1:74;
consider C96 being (XFinSequence of ( D26 ^omega )) such that L436: C96 = C93 and L437: (for B117 being (Element of ( NAT )) holds (B117 <= ( len ( D31 ^ ( FlattenSeq C96 ) ) ) implies ( IC ( Comput (R2 , C87 , B117) ) ) = B117)) and L438: ( ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq C96 ) ) )) ) . C88 ) | ( len C96 ) ) = ( C89 | ( len C96 ) ) and L439: ( len ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq C96 ) ) )) ) . C88 ) ) = ( len C89 ) and L440: (for B118 being Int-Location holds ((B118 <> D28 & B118 <> D27) implies ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq C96 ) ) )) ) . B118 ) = ( C87 . B118 ))) and L441: (for B119 being FinSeq-Location holds (B119 <> C88 implies ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq C96 ) ) )) ) . B119 ) = ( C87 . B119 ))) by L435 , L423 , L428 , XBOOLE_1:1;
L442: C94 = ( ( C93 ^ <% C94 %> ) . D32 ) by AFINSQ_1:36
.= ( C92 . D32 ) by L428 , L427 , GRFUNC_1:2;
L443: C94 in ( D26 ^omega ) by L442 , L427 , L429 , FUNCT_1:102;
reconsider D33 = ( C96 ^ <% C94 %> ) as (XFinSequence of ( D26 ^omega )) by L443;
take D33;
thus L444: D33 = ( C93 ^ <% C94 %> ) by L436;
reconsider D34 = C94 as (Element of ( D26 ^omega )) by L427 , L429 , L442 , FUNCT_1:102;
L445: ( FlattenSeq D33 ) = ( ( FlattenSeq C96 ) ^ ( FlattenSeq <% D34 %> ) ) by AFINSQ_2:75
.= ( ( FlattenSeq C96 ) ^ D34 ) by AFINSQ_2:73;
L446: ( Seg ( len C89 ) ) = ( dom C89 ) by FINSEQ_1:def 3;
L447: ( len D33 ) <= ( len C89 ) by L415 , L428 , L436 , NAT_1:43;
L448: ( Seg ( len D33 ) ) c= ( Seg ( len C89 ) ) by L447 , FINSEQ_1:5;
L449: ( dom ( C89 | ( Seg ( len D33 ) ) ) ) = ( Seg ( len D33 ) ) by L448 , L446 , RELAT_1:62;
set D35 = ( len ( ( D31 ^ ( FlattenSeq C96 ) ) ^ ( aSeq (D28 , ( D32 + 1 )) ) ) );
set D36 = ( len ( D31 ^ ( FlattenSeq C96 ) ) );
set D37 = ( Comput (R2 , C87 , D36) );
set D38 = ( Comput (R2 , C87 , D35) );
L450: D34 = ( ( aSeq (D28 , ( D32 + 1 )) ) ^ ( ( aSeq (D27 , C95) ) ^ <% ( (C88 , D28) := D27 ) %> ) ) by L432 , L442 , AFINSQ_1:27;
L451: ( ( len D31 ) + ( len ( FlattenSeq D33 ) ) ) = ( ( len D31 ) + ( len ( ( ( FlattenSeq C96 ) ^ ( aSeq (D28 , ( D32 + 1 )) ) ) ^ ( ( aSeq (D27 , C95) ) ^ <% ( (C88 , D28) := D27 ) %> ) ) ) ) by L450 , L445 , AFINSQ_1:27
.= ( len ( D31 ^ ( ( ( FlattenSeq C96 ) ^ ( aSeq (D28 , ( D32 + 1 )) ) ) ^ ( ( aSeq (D27 , C95) ) ^ <% ( (C88 , D28) := D27 ) %> ) ) ) ) by AFINSQ_1:17
.= ( len ( ( ( D31 ^ ( FlattenSeq C96 ) ) ^ ( aSeq (D28 , ( D32 + 1 )) ) ) ^ ( ( aSeq (D27 , C95) ) ^ <% ( (C88 , D28) := D27 ) %> ) ) ) by L6
.= ( D35 + ( len ( ( aSeq (D27 , C95) ) ^ <% ( (C88 , D28) := D27 ) %> ) ) ) by AFINSQ_1:17
.= ( D35 + ( ( len ( aSeq (D27 , C95) ) ) + ( len <% ( (C88 , D28) := D27 ) %> ) ) ) by AFINSQ_1:17
.= ( D35 + ( ( len ( aSeq (D27 , C95) ) ) + 1 ) ) by AFINSQ_1:33
.= ( ( D35 + ( len ( aSeq (D27 , C95) ) ) ) + 1 );
L452: ( len ( D31 ^ ( FlattenSeq D33 ) ) ) = ( ( D35 + ( len ( aSeq (D27 , C95) ) ) ) + 1 ) by L451 , AFINSQ_1:17;
L453: ( FlattenSeq D33 ) c= ( FlattenSeq C92 ) by L428 , L436 , AFINSQ_2:82;
L454:
now
let C97 being XFinSequence;
assume L455: C97 c= D34;
L456: ( ( FlattenSeq C96 ) ^ C97 ) c= ( ( FlattenSeq C96 ) ^ D34 ) by L455 , AFINSQ_2:81;
L457: ( ( FlattenSeq C96 ) ^ C97 ) c= ( FlattenSeq C92 ) by L456 , L453 , L445 , XBOOLE_1:1;
L458: ( D31 ^ ( ( FlattenSeq C96 ) ^ C97 ) ) c= ( D31 ^ ( FlattenSeq C92 ) ) by L457 , AFINSQ_2:81;
L459: ( ( D31 ^ ( FlattenSeq C96 ) ) ^ C97 ) c= ( D31 ^ ( FlattenSeq C92 ) ) by L458 , AFINSQ_1:27;
L460: ( D31 ^ ( FlattenSeq C92 ) ) c= D30 by L417 , AFINSQ_1:74;
thus L461: ( ( D31 ^ ( FlattenSeq C96 ) ) ^ C97 ) c= D30 by L460 , L459 , XBOOLE_1:1;
end;
L462: ( IC D37 ) = D36 by L437;
reconsider D39 = D37 as D36 -started (State of ( SCM+FSA )) by L462 , MEMSTR_0:def 12;
L463: ( D39 . D29 ) = 1 by L407 , L421 , L409 , L440;
L464: (for B120 being (Element of ( NAT )) holds (B120 in ( dom ( aSeq (D28 , ( D32 + 1 )) ) ) implies ( ( aSeq (D28 , ( D32 + 1 )) ) . B120 ) = ( R2 . ( D36 + B120 ) )))
proof
let C98 being (Element of ( NAT ));
assume L465: C98 in ( dom ( aSeq (D28 , ( D32 + 1 )) ) );
L466: ( D36 + C98 ) in ( dom ( ( D31 ^ ( FlattenSeq C96 ) ) ^ ( aSeq (D28 , ( D32 + 1 )) ) ) ) by L465 , AFINSQ_1:23;
L467: ( ( D31 ^ ( FlattenSeq C96 ) ) ^ ( aSeq (D28 , ( D32 + 1 )) ) ) c= D30 by L450 , L454 , AFINSQ_1:74;
L468: ( dom ( ( D31 ^ ( FlattenSeq C96 ) ) ^ ( aSeq (D28 , ( D32 + 1 )) ) ) ) c= ( dom D30 ) by L467 , GRFUNC_1:2;
thus L469: ( ( aSeq (D28 , ( D32 + 1 )) ) . C98 ) = ( ( ( D31 ^ ( FlattenSeq C96 ) ) ^ ( aSeq (D28 , ( D32 + 1 )) ) ) . ( D36 + C98 ) ) by L465 , AFINSQ_1:def 3
.= ( D30 . ( D36 + C98 ) ) by L467 , L466 , GRFUNC_1:2
.= ( R2 . ( D36 + C98 ) ) by L410 , L468 , L466 , GRFUNC_1:2
.= ( R2 . ( D36 + C98 ) );
end;
L470: ( ( Comput (R2 , D39 , ( len ( aSeq (D28 , ( D32 + 1 )) ) )) ) . D28 ) = ( D32 + 1 ) by L464 , L90 , L463 , L407;
L471: ( D31 ^ ( FlattenSeq D33 ) ) = ( ( D31 ^ ( FlattenSeq C96 ) ) ^ D34 ) by L445 , AFINSQ_1:27;
L472: ( len ( D31 ^ ( FlattenSeq D33 ) ) ) <= ( len D30 ) by L471 , L454 , NAT_1:43;
L473: ( D35 + ( len ( aSeq (D27 , C95) ) ) ) < ( len D30 ) by L472 , L452 , NAT_1:13;
L474:
now
let C99 being (Element of ( NAT ));
assume L475: C99 <= ( len ( aSeq (D28 , ( D32 + 1 )) ) );
thus L476: ( D36 + C99 ) = ( IC ( Comput (R2 , D39 , C99) ) ) by L475 , L464 , L90 , L463 , L407
.= ( IC ( Comput (R2 , C87 , ( D36 + C99 )) ) ) by EXTPRO_1:4;
end;
set D40 = ( len ( ( ( D31 ^ ( FlattenSeq C96 ) ) ^ ( aSeq (D28 , ( D32 + 1 )) ) ) ^ ( aSeq (D27 , C95) ) ) );
L477: D40 = ( D35 + ( len ( aSeq (D27 , C95) ) ) ) by AFINSQ_1:17;
L478: D35 = ( D36 + ( len ( aSeq (D28 , ( D32 + 1 )) ) ) ) by AFINSQ_1:17;
L479: D38 = ( Comput (R2 , ( Comput (R2 , C87 , D36) ) , ( len ( aSeq (D28 , ( D32 + 1 )) ) )) ) by L478 , EXTPRO_1:4;
L480: ( IC D38 ) = D35 by L478 , L479 , L464 , L90 , L463 , L407;
reconsider D41 = D38 as D35 -started (State of ( SCM+FSA )) by L480 , MEMSTR_0:def 12;
L481: ( D41 . D29 ) = 1 by L479 , L464 , L90 , L463 , L407;
L482: (for B121 being (Element of ( NAT )) holds (B121 in ( dom ( aSeq (D27 , C95) ) ) implies ( ( aSeq (D27 , C95) ) . B121 ) = ( R2 . ( D35 + B121 ) )))
proof
let C100 being (Element of ( NAT ));
assume L483: C100 in ( dom ( aSeq (D27 , C95) ) );
L484: ( D35 + C100 ) in ( dom ( ( ( D31 ^ ( FlattenSeq C96 ) ) ^ ( aSeq (D28 , ( D32 + 1 )) ) ) ^ ( aSeq (D27 , C95) ) ) ) by L483 , AFINSQ_1:23;
L485: ( ( D31 ^ ( FlattenSeq C96 ) ) ^ ( ( aSeq (D28 , ( D32 + 1 )) ) ^ ( aSeq (D27 , C95) ) ) ) c= D30 by L432 , L442 , L454 , AFINSQ_1:74;
L486: ( ( ( D31 ^ ( FlattenSeq C96 ) ) ^ ( aSeq (D28 , ( D32 + 1 )) ) ) ^ ( aSeq (D27 , C95) ) ) c= D30 by L485 , AFINSQ_1:27;
L487: ( dom ( ( ( D31 ^ ( FlattenSeq C96 ) ) ^ ( aSeq (D28 , ( D32 + 1 )) ) ) ^ ( aSeq (D27 , C95) ) ) ) c= ( dom D30 ) by L486 , GRFUNC_1:2;
thus L488: ( ( aSeq (D27 , C95) ) . C100 ) = ( ( ( ( D31 ^ ( FlattenSeq C96 ) ) ^ ( aSeq (D28 , ( D32 + 1 )) ) ) ^ ( aSeq (D27 , C95) ) ) . ( D35 + C100 ) ) by L483 , AFINSQ_1:def 3
.= ( D30 . ( D35 + C100 ) ) by L484 , L486 , GRFUNC_1:2
.= ( R2 . ( D35 + C100 ) ) by L410 , L487 , L484 , GRFUNC_1:2
.= ( R2 . ( D35 + C100 ) );
end;
L489: ( ( Comput (R2 , D41 , ( len ( aSeq (D27 , C95) ) )) ) . D27 ) = C95 by L482 , L90 , L481 , L421;
L490: ( ( Comput (R2 , C87 , D40) ) . C88 ) = ( ( Comput (R2 , C87 , ( D35 + ( len ( aSeq (D27 , C95) ) ) )) ) . C88 ) by AFINSQ_1:17
.= ( ( Comput (R2 , D41 , ( len ( aSeq (D27 , C95) ) )) ) . C88 ) by EXTPRO_1:4
.= ( D41 . C88 ) by L482 , L90 , L481 , L421
.= ( D39 . C88 ) by L479 , L464 , L90 , L463 , L407;
L491:
now
let C101 being (Element of ( NAT ));
assume L492: C101 <= ( len ( aSeq (D27 , C95) ) );
thus L493: ( D35 + C101 ) = ( IC ( Comput (R2 , D41 , C101) ) ) by L492 , L482 , L90 , L481 , L421
.= ( IC ( Comput (R2 , C87 , ( D35 + C101 )) ) ) by EXTPRO_1:4;
end;
L494: (for B122 being (Element of ( NAT )) holds (B122 < ( len ( D31 ^ ( FlattenSeq D33 ) ) ) implies ( IC ( Comput (R2 , C87 , B122) ) ) = B122))
proof
let C102 being (Element of ( NAT ));
assume L495: C102 < ( len ( D31 ^ ( FlattenSeq D33 ) ) );
L496:
now
L497: C102 < ( ( len D31 ) + ( len ( FlattenSeq D33 ) ) ) by L495 , AFINSQ_1:17;
assume L498: (not C102 <= D36);
assume L499: (not (( D36 + 1 ) <= C102 & C102 <= D35));
thus L500: (( D35 + 1 ) <= C102 & C102 <= ( D35 + ( len ( aSeq (D27 , C95) ) ) )) by L499 , L451 , L498 , L497 , NAT_1:13;
end;
per cases  by L496;
suppose L501: C102 <= ( len ( D31 ^ ( FlattenSeq C96 ) ) );

thus L502: thesis by L501 , L437;
end;
suppose L503: (( D36 + 1 ) <= C102 & C102 <= D35);

L504: ( ( D36 + 1 ) - D36 ) <= ( C102 - D36 ) by L503 , XREAL_1:9;
reconsider D42 = ( C102 - D36 ) as (Element of ( NAT )) by L504 , INT_1:3;
L505: ( C102 - D36 ) <= ( D35 - D36 ) by L503 , XREAL_1:9;
thus L506: C102 = ( IC ( Comput (R2 , C87 , ( D36 + D42 )) ) ) by L505 , L478 , L474
.= ( IC ( Comput (R2 , C87 , C102) ) );
end;
suppose L507: (( D35 + 1 ) <= C102 & C102 <= ( D35 + ( len ( aSeq (D27 , C95) ) ) ));

L508: ( ( D35 + 1 ) - D35 ) <= ( C102 - D35 ) by L507 , XREAL_1:9;
reconsider D43 = ( C102 - D35 ) as (Element of ( NAT )) by L508 , INT_1:3;
L509: ( C102 - D35 ) <= ( ( D35 + ( len ( aSeq (D27 , C95) ) ) ) - D35 ) by L507 , XREAL_1:9;
thus L510: C102 = ( IC ( Comput (R2 , C87 , ( D35 + D43 )) ) ) by L509 , L491
.= ( IC ( Comput (R2 , C87 , C102) ) );
end;
end;
L512: D40 = ( ( D36 + ( len ( aSeq (D28 , ( D32 + 1 )) ) ) ) + ( len ( aSeq (D27 , C95) ) ) ) by L478 , AFINSQ_1:17;
L513: ( R2 /. ( IC ( Comput (R2 , C87 , D40) ) ) ) = ( R2 . ( IC ( Comput (R2 , C87 , D40) ) ) ) by PBOOLE:143;
L514: ( ( D31 ^ ( FlattenSeq C96 ) ) ^ D34 ) c= D30 by L454;
consider C103 being (XFinSequence of D26) such that L515: ( ( ( D31 ^ ( FlattenSeq C96 ) ) ^ D34 ) ^ C103 ) = D30 by L514 , AFINSQ_2:80;
L516: ( len ( D31 ^ ( FlattenSeq D33 ) ) ) = ( ( D35 + ( len ( aSeq (D27 , C95) ) ) ) + 1 ) by L451 , AFINSQ_1:17;
L517: ( len ( D31 ^ ( FlattenSeq D33 ) ) ) > ( D35 + ( len ( aSeq (D27 , C95) ) ) ) by L516 , NAT_1:13;
L518: D40 in ( dom ( ( D31 ^ ( FlattenSeq C96 ) ) ^ D34 ) ) by L517 , L471 , L477 , AFINSQ_1:66;
L519: ( dom <% ( (C88 , D28) := D27 ) %> ) = 1 by AFINSQ_1:33;
L520: ( 0 ) in ( dom <% ( (C88 , D28) := D27 ) %> ) by L519 , CARD_1:49 , TARSKI:def 1;
L521: ( len <% ( (C88 , D28) := D27 ) %> ) = 1 by AFINSQ_1:34;
L522: ( len ( ( ( aSeq (D28 , ( D32 + 1 )) ) ^ ( aSeq (D27 , C95) ) ) ^ <% ( (C88 , D28) := D27 ) %> ) ) = ( ( len ( ( aSeq (D28 , ( D32 + 1 )) ) ^ ( aSeq (D27 , C95) ) ) ) + 1 ) by L521 , AFINSQ_1:17;
L523: ( len ( ( aSeq (D28 , ( D32 + 1 )) ) ^ ( aSeq (D27 , C95) ) ) ) < ( len ( ( ( aSeq (D28 , ( D32 + 1 )) ) ^ ( aSeq (D27 , C95) ) ) ^ <% ( (C88 , D28) := D27 ) %> ) ) by L522 , XREAL_1:29;
L524: ( len ( ( aSeq (D28 , ( D32 + 1 )) ) ^ ( aSeq (D27 , C95) ) ) ) in ( dom ( ( ( aSeq (D28 , ( D32 + 1 )) ) ^ ( aSeq (D27 , C95) ) ) ^ <% ( (C88 , D28) := D27 ) %> ) ) by L523 , AFINSQ_1:66;
L525: ( CurInstr (R2 , ( Comput (R2 , C87 , D40) )) ) = ( R2 . D40 ) by L477 , L494 , L513 , L517
.= ( D30 . D40 ) by L411 , L477 , L473
.= ( ( ( D31 ^ ( FlattenSeq C96 ) ) ^ D34 ) . ( D36 + ( ( len ( aSeq (D28 , ( D32 + 1 )) ) ) + ( len ( aSeq (D27 , C95) ) ) ) ) ) by L512 , L518 , L515 , AFINSQ_1:def 3
.= ( ( ( D31 ^ ( FlattenSeq C96 ) ) ^ D34 ) . ( D36 + ( len ( ( aSeq (D28 , ( D32 + 1 )) ) ^ ( aSeq (D27 , C95) ) ) ) ) ) by AFINSQ_1:17;
L526: ( CurInstr (R2 , ( Comput (R2 , C87 , D40) )) ) = ( ( ( D31 ^ ( FlattenSeq C96 ) ) ^ D34 ) . ( D36 + ( len ( ( aSeq (D28 , ( D32 + 1 )) ) ^ ( aSeq (D27 , C95) ) ) ) ) ) by L525
.= ( ( ( ( aSeq (D28 , ( D32 + 1 )) ) ^ ( aSeq (D27 , C95) ) ) ^ <% ( (C88 , D28) := D27 ) %> ) . ( ( len ( ( aSeq (D28 , ( D32 + 1 )) ) ^ ( aSeq (D27 , C95) ) ) ) + ( 0 ) ) ) by L524 , L432 , L442 , AFINSQ_1:def 3
.= ( <% ( (C88 , D28) := D27 ) %> . ( 0 ) ) by L520 , AFINSQ_1:def 3
.= ( (C88 , D28) := D27 ) by AFINSQ_1:34;
L527: ( Comput (R2 , C87 , ( D40 + 1 )) ) = ( Following (R2 , ( Comput (R2 , C87 , D40) )) ) by EXTPRO_1:3
.= ( Exec (( (C88 , D28) := D27 ) , ( Comput (R2 , C87 , D40) )) ) by L526;
L528: ( IC ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq D33 ) ) )) ) ) = ( succ ( IC ( Comput (R2 , C87 , D40) ) ) ) by L527 , L477 , L452 , SCMFSA_2:73
.= ( succ D40 ) by L477 , L494 , L517
.= ( len ( D31 ^ ( FlattenSeq D33 ) ) ) by L477 , L516 , NAT_1:38;
thus L529: (for B123 being (Element of ( NAT )) holds (B123 <= ( len ( D31 ^ ( FlattenSeq D33 ) ) ) implies ( IC ( Comput (R2 , C87 , B123) ) ) = B123))
proof
let C104 being (Element of ( NAT ));
assume L530: C104 <= ( len ( D31 ^ ( FlattenSeq D33 ) ) );
per cases  by L530 , XXREAL_0:1;
suppose L531: C104 < ( len ( D31 ^ ( FlattenSeq D33 ) ) );

thus L532: thesis by L531 , L494;
end;
suppose L533: C104 = ( len ( D31 ^ ( FlattenSeq D33 ) ) );

thus L534: thesis by L533 , L528;
end;
end;

L536: ( ( Comput (R2 , C87 , D40) ) . D27 ) = ( ( Comput (R2 , C87 , ( D35 + ( len ( aSeq (D27 , C95) ) ) )) ) . D27 ) by AFINSQ_1:17
.= ( C89 . ( D32 + 1 ) ) by L431 , L489 , EXTPRO_1:4;
consider C105 being (Element of ( NAT )) such that L537: C105 = ( abs ( ( Comput (R2 , C87 , D40) ) . D28 ) ) and L538: ( ( Exec (( (C88 , D28) := D27 ) , ( Comput (R2 , C87 , D40) )) ) . C88 ) = ( ( ( Comput (R2 , C87 , D40) ) . C88 ) +* (C105 , ( ( Comput (R2 , C87 , D40) ) . D27 )) ) by SCMFSA_2:73;
L539: C105 = ( abs ( ( Comput (R2 , C87 , ( D35 + ( len ( aSeq (D27 , C95) ) ) )) ) . D28 ) ) by L537 , AFINSQ_1:17
.= ( abs ( ( Comput (R2 , D41 , ( len ( aSeq (D27 , C95) ) )) ) . D28 ) ) by EXTPRO_1:4
.= ( abs ( D41 . D28 ) ) by L408 , L482 , L90 , L481 , L421
.= ( D32 + 1 ) by L479 , L470 , ABSVALUE:def 1;
L540: ( dom ( D39 . C88 ) ) = ( Seg ( len C89 ) ) by L439 , FINSEQ_1:def 3;
L541: (for B124 being (Element of ( NAT )) holds (B124 in ( Seg ( len D33 ) ) implies ( ( ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq D33 ) ) )) ) . C88 ) | ( Seg ( len D33 ) ) ) . B124 ) = ( ( C89 | ( Seg ( len D33 ) ) ) . B124 )))
proof
let C106 being (Element of ( NAT ));
assume L542: C106 in ( Seg ( len D33 ) );
L543: C106 <= ( len D33 ) by L542 , FINSEQ_1:1;
L544: ( len <% D34 %> ) = 1 by AFINSQ_1:34;
L545: ( len D33 ) = ( ( len C96 ) + 1 ) by L544 , AFINSQ_1:17;
per cases ;
suppose L546: C106 = ( len D33 );

thus L547: ( ( ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq D33 ) ) )) ) . C88 ) | ( Seg ( len D33 ) ) ) . C106 ) = ( ( ( D39 . C88 ) +* (( D32 + 1 ) , ( C89 . ( D32 + 1 ) )) ) . C106 ) by L477 , L516 , L527 , L538 , L539 , L536 , L490 , L546 , L545 , FINSEQ_1:4 , FUNCT_1:49
.= ( C89 . C106 ) by L436 , L415 , L540 , L546 , L434 , L545 , FUNCT_7:31
.= ( ( C89 | ( Seg ( len D33 ) ) ) . C106 ) by L546 , L545 , FINSEQ_1:4 , FUNCT_1:49;
end;
suppose L548: C106 <> ( len D33 );

L549: C106 < ( ( len C96 ) + 1 ) by L548 , L545 , L543 , XXREAL_0:1;
L550: C106 <= ( len C96 ) by L549 , NAT_1:13;
L551: 1 <= C106 by L542 , FINSEQ_1:1;
L552: C106 in ( Seg ( len C96 ) ) by L551 , L550;
L553: ( ( ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq D33 ) ) )) ) . C88 ) | ( Seg ( len D33 ) ) ) . C106 ) = ( ( ( D39 . C88 ) +* (( D32 + 1 ) , ( C89 . ( D32 + 1 ) )) ) . C106 ) by L477 , L516 , L527 , L538 , L539 , L536 , L490 , L542 , FUNCT_1:49
.= ( ( D39 . C88 ) . C106 ) by L545 , L436 , L548 , FUNCT_7:32;
thus L554: ( ( ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq D33 ) ) )) ) . C88 ) | ( Seg ( len D33 ) ) ) . C106 ) = ( ( C89 | ( Seg ( len C96 ) ) ) . C106 ) by L553 , L438 , L552 , FUNCT_1:49
.= ( C89 . C106 ) by L552 , FUNCT_1:49
.= ( ( C89 | ( Seg ( len D33 ) ) ) . C106 ) by L542 , FUNCT_1:49;
end;
end;
L556: (for B125 being set holds (B125 in ( Seg ( len D33 ) ) implies ( ( ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq D33 ) ) )) ) . C88 ) | ( Seg ( len D33 ) ) ) . B125 ) = ( ( C89 | ( Seg ( len D33 ) ) ) . B125 ))) by L541;
L557: ( dom ( ( D39 . C88 ) +* (( D32 + 1 ) , ( C89 . ( D32 + 1 ) )) ) ) = ( dom ( D39 . C88 ) ) by FUNCT_7:30;
L558: ( dom ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq D33 ) ) )) ) . C88 ) ) = ( dom ( ( D39 . C88 ) +* (( D32 + 1 ) , ( C89 . ( D32 + 1 ) )) ) ) by L452 , L527 , L538 , L539 , L536 , L490 , AFINSQ_1:17
.= ( Seg ( len C89 ) ) by L439 , L557 , FINSEQ_1:def 3;
L559: ( dom ( ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq D33 ) ) )) ) . C88 ) | ( Seg ( len D33 ) ) ) ) = ( Seg ( len D33 ) ) by L558 , L448 , RELAT_1:62;
thus L560: ( ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq D33 ) ) )) ) . C88 ) | ( len D33 ) ) = ( C89 | ( len D33 ) ) by L559 , L449 , L556 , FUNCT_1:2;
L561: ( len ( ( D39 . C88 ) +* (( D32 + 1 ) , ( C89 . ( D32 + 1 ) )) ) ) = ( len ( D39 . C88 ) ) by L557 , FINSEQ_3:29;
thus L562: ( len ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq D33 ) ) )) ) . C88 ) ) = ( len C89 ) by L561 , L439 , L452 , L527 , L538 , L539 , L536 , L490 , AFINSQ_1:17;
thus L563:now
let C107 being Int-Location;
assume that
L564: C107 <> D28
and
L565: C107 <> D27;
thus L566: ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq D33 ) ) )) ) . C107 ) = ( ( Comput (R2 , C87 , ( D35 + ( len ( aSeq (D27 , C95) ) ) )) ) . C107 ) by L477 , L452 , L527 , SCMFSA_2:73
.= ( ( Comput (R2 , D41 , ( len ( aSeq (D27 , C95) ) )) ) . C107 ) by EXTPRO_1:4
.= ( D41 . C107 ) by L482 , L565 , L90 , L481 , L421
.= ( D39 . C107 ) by L479 , L464 , L564 , L90 , L463 , L407
.= ( C87 . C107 ) by L440 , L564 , L565;
end;
thus L567:now
let C108 being FinSeq-Location;
assume L568: C108 <> C88;
thus L569: ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq D33 ) ) )) ) . C108 ) = ( ( Comput (R2 , C87 , ( D35 + ( len ( aSeq (D27 , C95) ) ) )) ) . C108 ) by L568 , L477 , L452 , L527 , SCMFSA_2:73
.= ( ( Comput (R2 , D41 , ( len ( aSeq (D27 , C95) ) )) ) . C108 ) by EXTPRO_1:4
.= ( D41 . C108 ) by L482 , L90 , L481 , L421
.= ( D39 . C108 ) by L479 , L464 , L90 , L463 , L407
.= ( C87 . C108 ) by L441 , L568;
end;
end;
set D44 = ( len ( aSeq (D28 , ( len C89 )) ) );
L568: ( len <% ( C88 :=<0,...,0> D28 ) %> ) = 1 by AFINSQ_1:34;
L569: ( len D31 ) = ( D44 + 1 ) by L568 , AFINSQ_1:17;
L570: D30 = ( ( ( aSeq (D28 , ( len C89 )) ) ^ <% ( C88 :=<0,...,0> D28 ) %> ) ^ ( ( aSeq (C88 , C89) ) ^ <% ( halt ( SCM+FSA ) ) %> ) ) by AFINSQ_1:27;
L571: D30 = ( ( aSeq (D28 , ( len C89 )) ) ^ ( <% ( C88 :=<0,...,0> D28 ) %> ^ ( ( aSeq (C88 , C89) ) ^ <% ( halt ( SCM+FSA ) ) %> ) ) ) by L570 , AFINSQ_1:27;
L572: ( aSeq (D28 , ( len C89 )) ) c= ( C88 := C89 ) by L571 , AFINSQ_1:74;
L573: ( aSeq (D28 , ( len C89 )) ) c= R2 by L572 , L410 , XBOOLE_1:1;
L574: ( ( Comput (R2 , C87 , ( len ( aSeq (D28 , ( len C89 )) ) )) ) . D28 ) = ( len C89 ) by L573 , L407 , L409 , L215;
L575: S8[ ( {} ) ]
proof
L576:
now
let C109 being (Element of ( NAT ));
assume that
L577: C109 < ( len D31 );
L578: (C109 < ( len D31 ) implies C109 <= ( len ( aSeq (D28 , ( len C89 )) ) )) by L569 , NAT_1:13;
thus L579: ( IC ( Comput (R2 , C87 , C109) ) ) = C109 by L578 , L407 , L409 , L573 , L577 , L215;
end;
assume L580: ( {} ) c= C92;
reconsider D45 = ( <%> ( D26 ^omega ) ) as (XFinSequence of ( D26 ^omega ));
take D45;
L581: ( D31 ^ ( FlattenSeq ( <%> ( D26 ^omega ) ) ) ) = ( D31 ^ ( <%> D26 ) ) by AFINSQ_2:74
.= ( D31 ^ ( {} ) )
.= D31;
L582: D44 < ( len D31 ) by L569 , NAT_1:13;
L583: ( IC ( Comput (R2 , C87 , D44) ) ) = D44 by L582 , L576;
L584: ( R2 /. ( IC ( Comput (R2 , C87 , D44) ) ) ) = ( R2 . ( IC ( Comput (R2 , C87 , D44) ) ) ) by PBOOLE:143;
L585: ( len D30 ) = ( ( len D31 ) + ( len ( ( aSeq (C88 , C89) ) ^ <% ( halt ( SCM+FSA ) ) %> ) ) ) by L570 , AFINSQ_1:17;
L586: ( len D31 ) <= ( len D30 ) by L585 , NAT_1:11;
L587: D44 < ( len D30 ) by L586 , L569 , NAT_1:13;
L588: D30 = ( ( ( aSeq (D28 , ( len C89 )) ) ^ <% ( C88 :=<0,...,0> D28 ) %> ) ^ ( ( aSeq (C88 , C89) ) ^ <% ( halt ( SCM+FSA ) ) %> ) ) by AFINSQ_1:27;
L589: D44 in ( dom D31 ) by L582 , AFINSQ_1:66;
L590: ( CurInstr (R2 , ( Comput (R2 , C87 , D44) )) ) = ( D30 . D44 ) by L411 , L583 , L584 , L587
.= ( D31 . D44 ) by L588 , L589 , AFINSQ_1:def 3
.= ( C88 :=<0,...,0> D28 ) by AFINSQ_1:36;
thus L591: D45 = ( {} );
L592: ( Comput (R2 , C87 , ( len D31 )) ) = ( Following (R2 , ( Comput (R2 , C87 , D44) )) ) by L569 , EXTPRO_1:3
.= ( Exec (( C88 :=<0,...,0> D28 ) , ( Comput (R2 , C87 , D44) )) ) by L590;
L593: ( IC ( Comput (R2 , C87 , ( len D31 )) ) ) = ( succ ( IC ( Comput (R2 , C87 , D44) ) ) ) by L592 , SCMFSA_2:75
.= ( len D31 ) by L569 , L583 , NAT_1:38;
L594:
now
let C110 being (Element of ( NAT ));
assume L595: C110 <= ( len D31 );
L596: (C110 < ( len D31 ) or C110 = ( len D31 )) by L595 , XXREAL_0:1;
thus L597: ( IC ( Comput (R2 , C87 , C110) ) ) = C110 by L596 , L576 , L593;
end;
thus L598: (for B126 being (Element of ( NAT )) holds (B126 <= ( len ( D31 ^ ( FlattenSeq D45 ) ) ) implies ( IC ( Comput (R2 , C87 , B126) ) ) = B126)) by L594 , L581;
consider C111 being (Element of ( NAT )) such that L599: C111 = ( abs ( ( Comput (R2 , C87 , D44) ) . D28 ) ) and L600: ( ( Exec (( C88 :=<0,...,0> D28 ) , ( Comput (R2 , C87 , D44) )) ) . C88 ) = ( C111 |-> ( 0 ) ) by SCMFSA_2:75;
L601: ( ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq D45 ) ) )) ) . C88 ) | ( 0 ) ) = ( C89 | ( len D45 ) );
thus L602: ( ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq D45 ) ) )) ) . C88 ) | ( len D45 ) ) = ( C89 | ( len D45 ) ) by L601;
L603: C111 = ( len C89 ) by L574 , L599 , ABSVALUE:def 1;
thus L604: ( len ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq D45 ) ) )) ) . C88 ) ) = ( len C89 ) by L603 , L581 , L592 , L600 , CARD_1:def 7;
L605:
now
let C112 being Int-Location;
assume that
L606: C112 <> D28
and
L607: C112 <> D27;
thus L608: ( ( Comput (R2 , C87 , ( len D31 )) ) . C112 ) = ( ( Comput (R2 , C87 , D44) ) . C112 ) by L592 , SCMFSA_2:75
.= ( C87 . C112 ) by L407 , L409 , L573 , L606 , L215;
end;
thus L609: (for B127 being Int-Location holds ((B127 <> D28 & B127 <> D27) implies ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq D45 ) ) )) ) . B127 ) = ( C87 . B127 ))) by L605 , L581;
L610:
now
let C113 being FinSeq-Location;
assume L611: C113 <> C88;
thus L612: ( ( Comput (R2 , C87 , ( len D31 )) ) . C113 ) = ( ( Comput (R2 , C87 , D44) ) . C113 ) by L611 , L592 , SCMFSA_2:75
.= ( C87 . C113 ) by L407 , L409 , L573 , L215;
end;
thus L613: thesis by L610 , L581;
end;
L614: (for B128 being XFinSequence holds S8[ B128 ]) from AFINSQ_1:sch 3(L575 , L422);
consider C114 being (XFinSequence of ( D26 ^omega )) such that L615: C114 = C92 and L616: (for B129 being (Element of ( NAT )) holds (B129 <= ( len ( D31 ^ ( FlattenSeq C114 ) ) ) implies ( IC ( Comput (R2 , C87 , B129) ) ) = B129)) and L617: ( ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq C114 ) ) )) ) . C88 ) | ( len C114 ) ) = ( C89 | ( len C114 ) ) and L618: ( len ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq C114 ) ) )) ) . C88 ) ) = ( len C89 ) and L619: ((for B130 being Int-Location holds ((B130 <> D28 & B130 <> D27) implies ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq C114 ) ) )) ) . B130 ) = ( C87 . B130 ))) & (for B131 being FinSeq-Location holds (B131 <> C88 implies ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq C114 ) ) )) ) . B131 ) = ( C87 . B131 )))) by L614;
L620: ( R2 /. ( IC ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq C92 ) ) )) ) ) ) = ( R2 . ( IC ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq C92 ) ) )) ) ) ) by PBOOLE:143;
L621: ( IC ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq C92 ) ) )) ) ) = ( len ( D31 ^ ( FlattenSeq C92 ) ) ) by L615 , L616;
L622: ( CurInstr (R2 , ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq C92 ) ) )) )) ) = ( D30 . ( len ( D31 ^ ( FlattenSeq C92 ) ) ) ) by L621 , L411 , L420 , L620
.= ( halt ( SCM+FSA ) ) by L417 , AFINSQ_1:36;
thus L623: R2 halts_on C87 by L622 , EXTPRO_1:29;
L624: ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq C92 ) ) )) ) = ( Result (R2 , C87) ) by L623 , L622 , EXTPRO_1:def 9;
L625: ( Seg ( len C114 ) ) = ( dom C89 ) by L415 , L615 , FINSEQ_1:def 3;
L626: ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq C114 ) ) )) ) . C88 ) = ( ( ( Comput (R2 , C87 , ( len ( D31 ^ ( FlattenSeq C114 ) ) )) ) . C88 ) | ( len C114 ) ) by L415 , L615 , L618 , FINSEQ_3:113;
thus L627: ( ( Result (R2 , C87) ) . C88 ) = C89 by L626 , L625 , L615 , L624 , L617 , RELAT_1:68;
thus L628: thesis by L615 , L619 , L624;
end;
