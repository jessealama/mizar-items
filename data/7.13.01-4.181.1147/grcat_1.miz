:: Categories of Groups
::  by Michal Muzalewski
::
:: Received October 3, 1991
:: Copyright (c) 1991-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, CLASSES2, TARSKI, ZFMISC_1, SUBSET_1, FUNCT_5, FUNCT_1,
      FUNCT_2, ALGSTR_0, MIDSP_2, ROBBINS1, SUPINF_2, ARYTM_3, ARYTM_1, CAT_1,
      STRUCT_0, RELAT_1, GRAPH_1, VECTSP_1, PARTFUN1, REALSET1, MIDSP_1, CAT_2,
      FUNCOP_1, MSSUBFAM, RLVECT_1, ENS_1, ALGSTR_1, GRCAT_1, MONOID_0,
      RELAT_2, BINOP_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, RELAT_1, FUNCT_1, MCART_1,
      REALSET1, PARTFUN1, FUNCT_2, ORDINAL1, CLASSES2, BINOP_1, FUNCOP_1,
      FUNCT_5,
      STRUCT_0, ALGSTR_0, GRAPH_1, CAT_1, TOPS_2, RLVECT_1, VECTSP_1,
      CAT_2, ALGSTR_1, MIDSP_2;
 constructors PARTFUN1, CLASSES1, CLASSES2, REALSET1, TOPS_2, VECTSP_2, CAT_2,
      ALGSTR_1, MIDSP_2, FUNCOP_1, RELSET_1, FUNCT_5, XTUPLE_0;
 registrations XBOOLE_0, RELSET_1, FUNCT_2, CLASSES2, STRUCT_0, ALGSTR_1,
      MIDSP_2, ALGSTR_0, CAT_2, XTUPLE_0, CAT_1, REALSET1, SUBSET_1;
 requirements SUBSET, BOOLE;
 definitions BINOP_1, STRUCT_0, ALGSTR_1, ALGSTR_0, GRAPH_1, VECTSP_1, CAT_1,
      XTUPLE_0;
 theorems CAT_1, CAT_2, CLASSES2, FUNCOP_1, FUNCT_1, FUNCT_2, MIDSP_2, MCART_1,
      VECTSP_1, TARSKI, ZFMISC_1, RLVECT_1, RELAT_1, ORDINAL1, XBOOLE_0,
      TOPS_2, BINOP_1, CARD_1, SUBSET_1, XTUPLE_0;
 schemes FUNCT_2, BINOP_1, TARSKI, XBOOLE_0;

begin
theorem
L1: (for R4 being Universe holds (for B1 , B2 , B3 , B4 being (Element of R4) holds ([ B1 , B2 , B3 ] in R4 & [ B1 , B2 , B3 , B4 ] in R4)))
proof
let R4 being Universe;
let C1 , C2 , C3 , C4 being (Element of R4);
L2: ([ C1 , C2 , C3 ] = [ [ C1 , C2 ] , C3 ] & [ C1 , C2 , C3 , C4 ] = [ [ C1 , C2 , C3 ] , C4 ]);
thus L3: thesis by L2 , CLASSES2:58;
end;
theorem
L4: (( ( op2 ) . (( {} ) , ( {} )) ) = ( {} ) & ( ( op1 ) . ( {} ) ) = ( {} ) & ( op0 ) = ( {} ))
proof
L5: [ ( {} ) , ( {} ) ] in [: { ( {} ) } , { ( {} ) } :] by ZFMISC_1:28;
thus L6: ( ( op2 ) . (( {} ) , ( {} )) ) = ( {} ) by L5 , CARD_1:49 , FUNCT_2:50;
L7: ( {} ) in { ( {} ) } by TARSKI:def 1;
thus L8: ( ( op1 ) . ( {} ) ) = ( {} ) by L7 , CARD_1:49 , FUNCT_2:50;
thus L9: thesis;
end;
theorem
L10: (for R4 being Universe holds ({ ( {} ) } in R4 & [ { ( {} ) } , { ( {} ) } ] in R4 & [: { ( {} ) } , { ( {} ) } :] in R4 & ( op2 ) in R4 & ( op1 ) in R4))
proof
let R4 being Universe;
set D1 = { ( {} ) };
thus L11: D1 in R4 by CLASSES2:56 , CLASSES2:57;
thus L12: [ D1 , D1 ] in R4 by L11 , CLASSES2:58;
L13: ( op2 ) in ( Funcs ([: D1 , D1 :] , D1) ) by CARD_1:49 , FUNCT_2:8;
thus L14: [: D1 , D1 :] in R4 by L11 , CLASSES2:61;
L15: ( Funcs ([: D1 , D1 :] , D1) ) in R4 by L14 , L11 , CLASSES2:61;
thus L16: ( op2 ) in R4 by L15 , L13 , ORDINAL1:10;
L17: ( op1 ) in ( Funcs (D1 , D1) ) by CARD_1:49 , FUNCT_2:8;
L18: ( Funcs (D1 , D1) ) in R4 by L11 , CLASSES2:61;
thus L19: thesis by L18 , L17 , ORDINAL1:10;
end;
registration
cluster ( Trivial-addLoopStr ) ->  midpoint_operator;
coherence
proof
set D2 = ( Trivial-addLoopStr );
L20: (for B5 being (Element of D2) holds (ex B6 being (Element of D2) st ( Double B6 ) = B5))
proof
set D3 = the (Element of D2);
let C5 being (Element of D2);
take D3;
thus L21: ( Double D3 ) = ( {} ) by CARD_1:49 , TARSKI:def 1
.= C5 by CARD_1:49 , TARSKI:def 1;
end;
L22: (for B7 being (Element of D2) holds (( Double B7 ) = ( 0. D2 ) implies B7 = ( 0. D2 ))) by CARD_1:49 , TARSKI:def 1;
thus L23: thesis by L22 , L20 , MIDSP_2:def 5;
end;
end;
theorem
L25: ((for B8 being (Element of ( Trivial-addLoopStr )) holds B8 = ( {} )) & (for B9 , B10 being (Element of ( Trivial-addLoopStr )) holds ( B9 + B10 ) = ( {} )) & (for B11 being (Element of ( Trivial-addLoopStr )) holds ( - B11 ) = ( {} )) & ( 0. ( Trivial-addLoopStr ) ) = ( {} )) by CARD_1:49 , TARSKI:def 1;
definition
let R5 being Category;
let R6 being non  empty (Subset of (the carrier of R5));
func Morphs R6 -> (Subset of (the carrier' of R5)) equals 
( union { ( Hom (B12 , B13) ) where B12 is (Object of R5) , B13 is (Object of R5) : (B12 in R6 & B13 in R6) } );
coherence by CAT_2:19;
end;
registration
let R5 being Category;
let R6 being non  empty (Subset of (the carrier of R5));
cluster ( Morphs R6 ) -> non  empty;
coherence by CAT_2:19;
end;
definition
let R5 being Category;
let R6 being non  empty (Subset of (the carrier of R5));
func dom R6 -> (Function of ( Morphs R6 ) , R6) equals 
( (the Source of R5) | ( Morphs R6 ) );
coherence by CAT_2:20;
func cod R6 -> (Function of ( Morphs R6 ) , R6) equals 
( (the Target of R5) | ( Morphs R6 ) );
coherence by CAT_2:20;
func comp R6 -> (PartFunc of [: ( Morphs R6 ) , ( Morphs R6 ) :] , ( Morphs R6 )) equals 
( (the Comp of R5) || ( Morphs R6 ) );
coherence by CAT_2:20;
canceled 1;
end;
definition
let R5 being Category;
let R6 being non  empty (Subset of (the carrier of R5));
func cat R6 -> (Subcategory of R5) equals 
CatStr (# R6 , ( Morphs R6 ) , ( dom R6 ) , ( cod R6 ) , ( comp R6 ) #);
coherence
proof
L29: CatStr (# R6 , ( Morphs R6 ) , ( dom R6 ) , ( cod R6 ) , ( comp R6 ) #) is  full  full  full  full (Subcategory of R5) by CAT_2:21;
thus L30: thesis by L29;
end;
end;
registration
let R5 being Category;
let R6 being non  empty (Subset of (the carrier of R5));
cluster ( cat R6 ) ->  strict;
coherence;
end;
theorem
L33: (for R5 being Category holds (for R6 being non  empty (Subset of (the carrier of R5)) holds (the carrier of ( cat R6 )) = R6));
definition
let C6 being non  empty 1-sorted;
let C7 being non  empty ZeroStr;
func ZeroMap (C6 , C7) -> (Function of C6 , C7) equals 
( (the carrier of C6) --> ( 0. C7 ) );
coherence;
end;
theorem
L35: ( comp ( Trivial-addLoopStr ) ) = ( op1 )
proof
reconsider D4 = ( comp ( Trivial-addLoopStr ) ) as (Function of { ( {} ) } , { ( {} ) }) by CARD_1:49;
L36: (for B14 being set holds (B14 in { ( {} ) } implies ( ( op1 ) . B14 ) = ( D4 . B14 )))
proof
let C8 being set;
assume L37: C8 in { ( {} ) };
reconsider D5 = C8 as (Element of ( Trivial-addLoopStr )) by L37 , CARD_1:49;
L38: D5 = ( {} ) by CARD_1:49 , TARSKI:def 1;
L39: ( ( op1 ) . D5 ) = ( - D5 ) by L38 , L4 , CARD_1:49 , TARSKI:def 1
.= ( D4 . D5 ) by VECTSP_1:def 13;
thus L40: thesis by L39;
end;
thus L41: thesis by L36 , CARD_1:49 , FUNCT_2:12;
end;
registration
let C9 being non  empty addMagma;
let C10 being  right_zeroed non  empty addLoopStr;
cluster ( ZeroMap (C9 , C10) ) ->  additive;
coherence
proof
set D6 = ( ZeroMap (C9 , C10) );
let C11 , C12 being (Element of C9);
L42: ( D6 . C12 ) = ( 0. C10 ) by FUNCOP_1:7;
L43: (( D6 . ( C11 + C12 ) ) = ( 0. C10 ) & ( D6 . C11 ) = ( 0. C10 )) by FUNCOP_1:7;
thus L44: thesis by L43 , L42 , RLVECT_1:def 4;
end;
end;
registration
let C13 being non  empty addMagma;
let C14 being  right_zeroed non  empty addLoopStr;
cluster  additive for (Function of C13 , C14);
existence
proof
take ( ZeroMap (C13 , C14) );
thus L46: thesis;
end;
end;
theorem
L48: (for B15 , B16 , B17 being non  empty addMagma holds (for B18 being (Function of B15 , B16) holds (for B19 being (Function of B16 , B17) holds ((B18 is  additive & B19 is  additive) implies ( B19 * B18 ) is  additive))))
proof
let C15 , C16 , C17 being non  empty addMagma;
let C18 being (Function of C15 , C16);
let C19 being (Function of C16 , C17);
assume that
L49: C18 is  additive
and
L50: C19 is  additive;
set D7 = ( C19 * C18 );
L51:
now
let C20 , C21 being (Element of C15);
L52: (( C19 . ( C18 . C20 ) ) = ( D7 . C20 ) & ( C19 . ( C18 . C21 ) ) = ( D7 . C21 )) by FUNCT_2:15;
thus L53: ( D7 . ( C20 + C21 ) ) = ( C19 . ( C18 . ( C20 + C21 ) ) ) by FUNCT_2:15
.= ( C19 . ( ( C18 . C20 ) + ( C18 . C21 ) ) ) by L49 , VECTSP_1:def 20
.= ( ( D7 . C20 ) + ( D7 . C21 ) ) by L50 , L52 , VECTSP_1:def 20;
end;
thus L54: thesis by L51 , VECTSP_1:def 20;
end;
registration
let C22 being non  empty addMagma;
let C23 , C24 being  right_zeroed non  empty addLoopStr;
let C25 being  additive (Function of C22 , C23);
let C26 being  additive (Function of C23 , C24);
cluster ( C26 * C25 ) ->  additive for (Function of C22 , C24);
coherence by L48;
end;
definition
struct GroupMorphismStr(# Source , Target -> AddGroup , Fun -> (Function of the Source , the Target) #);
end;
definition
canceled 1;
let C27 being GroupMorphismStr;
func dom C27 -> AddGroup equals 
(the Source of C27);
coherence;
func cod C27 -> AddGroup equals 
(the Target of C27);
coherence;
end;
definition
let C28 being GroupMorphismStr;
func fun C28 -> (Function of ( dom C28 ) , ( cod C28 )) equals 
(the Fun of C28);
coherence;
end;
theorem
L59: (for B20 being GroupMorphismStr holds (for B21 , B22 being AddGroup holds (for B23 being (Function of B21 , B22) holds (B20 = GroupMorphismStr (# B21 , B22 , B23 #) implies (( dom B20 ) = B21 & ( cod B20 ) = B22 & ( fun B20 ) = B23)))));
definition
let R7 being AddGroup;
let R8 being AddGroup;
func ZERO (R7 , R8) -> GroupMorphismStr equals 
GroupMorphismStr (# R7 , R8 , ( ZeroMap (R7 , R8) ) #);
coherence;
end;
registration
let R7 being AddGroup;
let R8 being AddGroup;
cluster ( ZERO (R7 , R8) ) ->  strict;
coherence;
end;
definition
let C29 being GroupMorphismStr;
attr C29 is  GroupMorphism-like
means
:L62: ( fun C29 ) is  additive;
end;
registration
cluster  strict  GroupMorphism-like for GroupMorphismStr;
existence
proof
set D8 = the AddGroup;
set D9 = ( ZERO (D8 , D8) );
L64: ( fun D9 ) is  additive;
L65: D9 is  GroupMorphism-like by L64 , L62;
thus L66: thesis by L65;
end;
end;
definition
mode GroupMorphism
 is  GroupMorphism-like GroupMorphismStr;
end;
theorem
L69: (for B24 being GroupMorphism holds (the Fun of B24) is  additive)
proof
let C30 being GroupMorphism;
L70: (the Fun of C30) = ( fun C30 );
thus L71: thesis by L70 , L62;
end;
registration
let R7 being AddGroup;
let R8 being AddGroup;
cluster ( ZERO (R7 , R8) ) ->  GroupMorphism-like;
coherence
proof
set D10 = ( ZERO (R7 , R8) );
L72: ( fun D10 ) is  additive;
thus L73: thesis by L72 , L62;
end;
end;
definition
let R7 being AddGroup;
let R8 being AddGroup;
mode Morphism of R7 , R8
 -> GroupMorphism
means :L75: (( dom it ) = R7 & ( cod it ) = R8);
existence
proof
take ( ZERO (R7 , R8) );
thus L76: thesis;
end;
end;
registration
let R7 being AddGroup;
let R8 being AddGroup;
cluster  strict for (Morphism of R7 , R8);
existence
proof
L78: (( dom ( ZERO (R7 , R8) ) ) = R7 & ( cod ( ZERO (R7 , R8) ) ) = R8);
L79: ( ZERO (R7 , R8) ) is (Morphism of R7 , R8) by L78 , L75;
thus L80: thesis by L79;
end;
end;
theorem
L82: (for R7 being AddGroup holds (for R8 being AddGroup holds (for B25 being  strict GroupMorphismStr holds ((( dom B25 ) = R7 & ( cod B25 ) = R8 & ( fun B25 ) is  additive) implies B25 is  strict  strict  strict  strict (Morphism of R7 , R8)))))
proof
let R7 being AddGroup;
let R8 being AddGroup;
let C31 being  strict GroupMorphismStr;
assume that
L83: (( dom C31 ) = R7 & ( cod C31 ) = R8)
and
L84: ( fun C31 ) is  additive;
reconsider D11 = C31 as  strict GroupMorphism by L84 , L62;
L85: D11 is  strict  strict  strict  strict (Morphism of R7 , R8) by L83 , L75;
thus L86: thesis by L85;
end;
theorem
L87: (for R7 being AddGroup holds (for R8 being AddGroup holds (for B26 being (Function of R7 , R8) holds (B26 is  additive implies GroupMorphismStr (# R7 , R8 , B26 #) is  strict  strict  strict  strict (Morphism of R7 , R8)))))
proof
let R7 being AddGroup;
let R8 being AddGroup;
let C32 being (Function of R7 , R8);
assume that
L88: C32 is  additive;
set D12 = GroupMorphismStr (# R7 , R8 , C32 #);
L89: ( fun D12 ) = C32;
thus L90: thesis by L89 , L88 , L82;
end;
registration
let C33 being non  empty addMagma;
cluster ( id C33 ) ->  additive;
coherence
proof
set D13 = ( id C33 );
let C34 , C35 being (Element of C33);
L91: (( D13 . ( C34 + C35 ) ) = ( C34 + C35 ) & ( D13 . C34 ) = C34) by FUNCT_1:18;
thus L92: thesis by L91 , FUNCT_1:18;
end;
end;
definition
let R7 being AddGroup;
func ID R7 -> (Morphism of R7 , R7) equals 
GroupMorphismStr (# R7 , R7 , ( id R7 ) #);
coherence
proof
set D14 = GroupMorphismStr (# R7 , R7 , ( id R7 ) #);
L94: ( fun D14 ) = ( id R7 );
thus L95: thesis by L94 , L82;
end;
end;
registration
let R7 being AddGroup;
cluster ( ID R7 ) ->  strict;
coherence;
end;
definition
let R7 being AddGroup;
let R8 being AddGroup;
redefine func ZERO (R7 , R8) ->  strict (Morphism of R7 , R8);

coherence
proof
set D15 = ( ZERO (R7 , R8) );
L98: ( fun D15 ) = ( ZeroMap (R7 , R8) );
thus L99: thesis by L98 , L82;
end;
end;
theorem
L101: (for R7 being AddGroup holds (for R8 being AddGroup holds (for B27 being (Morphism of R7 , R8) holds (ex B28 being (Function of R7 , R8) st (( the GroupMorphismStr of B27 ) = GroupMorphismStr (# R7 , R8 , B28 #) & B28 is  additive)))))
proof
let R7 being AddGroup;
let R8 being AddGroup;
let C36 being (Morphism of R7 , R8);
L102: (the Target of C36) = ( cod C36 )
.= R8 by L75;
L103: (the Source of C36) = ( dom C36 )
.= R7 by L75;
reconsider D16 = (the Fun of C36) as (Function of R7 , R8) by L103 , L102;
take D16;
thus L104: thesis by L103 , L102 , L69;
end;
theorem
L105: (for R7 being AddGroup holds (for R8 being AddGroup holds (for B29 being  strict (Morphism of R7 , R8) holds (ex B30 being (Function of R7 , R8) st B29 = GroupMorphismStr (# R7 , R8 , B30 #)))))
proof
let R7 being AddGroup;
let R8 being AddGroup;
let C37 being  strict (Morphism of R7 , R8);
consider C38 being (Function of R7 , R8) such that L106: C37 = GroupMorphismStr (# R7 , R8 , C38 #) and L107: C38 is  additive by L101;
take C38;
thus L108: thesis by L106;
end;
theorem
L109: (for B31 being GroupMorphism holds (ex R7 being AddGroup st (ex R8 being AddGroup st B31 is (Morphism of R7 , R8))))
proof
let C39 being GroupMorphism;
take D17 = (the Source of C39);
take D18 = (the Target of C39);
L110: (( dom C39 ) = D17 & ( cod C39 ) = D18);
thus L111: thesis by L110 , L75;
end;
theorem
L112: (for B32 being  strict GroupMorphism holds (ex B33 , B34 being AddGroup st (ex B35 being (Function of B33 , B34) st (B32 is (Morphism of B33 , B34) & B32 = GroupMorphismStr (# B33 , B34 , B35 #) & B35 is  additive))))
proof
let C40 being  strict GroupMorphism;
consider R7 being AddGroup, R8 being AddGroup such that L113: C40 is (Morphism of R7 , R8) by L109;
reconsider D19 = C40 as (Morphism of R7 , R8) by L113;
consider C41 being (Function of R7 , R8) such that L114: (D19 = GroupMorphismStr (# R7 , R8 , C41 #) & C41 is  additive) by L101;
take R7;
take R8;
take C41;
thus L115: thesis by L114;
end;
theorem
L116: (for B36 , B37 being GroupMorphism holds (( dom B36 ) = ( cod B37 ) implies (ex B38 , B39 , B40 being AddGroup st (B36 is (Morphism of B39 , B40) & B37 is (Morphism of B38 , B39)))))
proof
defpred S1[ GroupMorphism , GroupMorphism ] means ( dom $1 ) = ( cod $2 );
let C42 , C43 being GroupMorphism;
assume that
L117: S1[ C42 , C43 ];
consider C44 , C45 being AddGroup such that L118: C42 is (Morphism of C44 , C45) by L109;
consider C46 , C47 being AddGroup such that L119: C43 is (Morphism of C46 , C47) by L109;
L120: C47 = ( cod C43 ) by L119 , L75;
L121: C44 = ( dom C42 ) by L118 , L75;
thus L122: thesis by L121 , L117 , L118 , L119 , L120;
end;
definition
let C48 , C49 being GroupMorphism;
assume L123: ( dom C48 ) = ( cod C49 );
func C48 * C49 ->  strict GroupMorphism means 
:L124: (for B41 , B42 , B43 being AddGroup holds (for B44 being (Function of B42 , B43) holds (for B45 being (Function of B41 , B42) holds ((( the GroupMorphismStr of C48 ) = GroupMorphismStr (# B42 , B43 , B44 #) & ( the GroupMorphismStr of C49 ) = GroupMorphismStr (# B41 , B42 , B45 #)) implies it = GroupMorphismStr (# B41 , B43 , ( B44 * B45 ) #)))));
existence
proof
consider C50 , C51 , C52 being AddGroup such that L125: C48 is (Morphism of C51 , C52) and L126: C49 is (Morphism of C50 , C51) by L123 , L116;
consider C53 being (Function of C50 , C51) such that L127: ( the GroupMorphismStr of C49 ) = GroupMorphismStr (# C50 , C51 , C53 #) and L128: C53 is  additive by L126 , L101;
consider C54 being (Function of C51 , C52) such that L129: ( the GroupMorphismStr of C48 ) = GroupMorphismStr (# C51 , C52 , C54 #) and L130: C54 is  additive by L125 , L101;
L131: ( C54 * C53 ) is  additive by L130 , L128;
reconsider D20 = GroupMorphismStr (# C50 , C52 , ( C54 * C53 ) #) as  strict GroupMorphism by L131 , L87;
take D20;
thus L132: thesis by L129 , L127;
end;
uniqueness
proof
consider C55 , C56 being AddGroup such that L133: C49 is (Morphism of C55 , C56) by L109;
reconsider D21 = C49 as (Morphism of C55 , C56) by L133;
consider C57 , C58 being AddGroup such that L134: C48 is (Morphism of C57 , C58) by L109;
L135: C57 = ( dom C48 ) by L134 , L75;
reconsider D22 = D21 as (Morphism of C55 , C57) by L135 , L123 , L75;
consider C59 being (Function of C55 , C57) such that L136: ( the GroupMorphismStr of D22 ) = GroupMorphismStr (# C55 , C57 , C59 #) and L137: C59 is  additive by L101;
reconsider D23 = C48 as (Morphism of C57 , C58) by L134;
let C60 , C61 being  strict GroupMorphism;
assume that
L138: (for B46 , B47 , B48 being AddGroup holds (for B49 being (Function of B47 , B48) holds (for B50 being (Function of B46 , B47) holds ((( the GroupMorphismStr of C48 ) = GroupMorphismStr (# B47 , B48 , B49 #) & ( the GroupMorphismStr of C49 ) = GroupMorphismStr (# B46 , B47 , B50 #)) implies C60 = GroupMorphismStr (# B46 , B48 , ( B49 * B50 ) #)))))
and
L139: (for B51 , B52 , B53 being AddGroup holds (for B54 being (Function of B52 , B53) holds (for B55 being (Function of B51 , B52) holds ((( the GroupMorphismStr of C48 ) = GroupMorphismStr (# B52 , B53 , B54 #) & ( the GroupMorphismStr of C49 ) = GroupMorphismStr (# B51 , B52 , B55 #)) implies C61 = GroupMorphismStr (# B51 , B53 , ( B54 * B55 ) #)))));
consider C62 being (Function of C57 , C58) such that L140: ( the GroupMorphismStr of D23 ) = GroupMorphismStr (# C57 , C58 , C62 #) and L141: C62 is  additive by L101;
thus L142: C60 = GroupMorphismStr (# C55 , C58 , ( C62 * C59 ) #) by L138 , L140 , L136
.= C61 by L139 , L140 , L136;
end;
end;
theorem
L144: (for B56 , B57 , B58 being AddGroup holds (for B59 being (Morphism of B57 , B58) holds (for B60 being (Morphism of B56 , B57) holds ( B59 * B60 ) is (Morphism of B56 , B58))))
proof
let C63 , C64 , C65 being AddGroup;
let C66 being (Morphism of C64 , C65);
let C67 being (Morphism of C63 , C64);
consider C68 being (Function of C64 , C65) such that L145: ( the GroupMorphismStr of C66 ) = GroupMorphismStr (# C64 , C65 , C68 #) and L146: C68 is  additive by L101;
consider C69 being (Function of C63 , C64) such that L147: ( the GroupMorphismStr of C67 ) = GroupMorphismStr (# C63 , C64 , C69 #) and L148: C69 is  additive by L101;
L149: ( dom C66 ) = C64 by L75
.= ( cod C67 ) by L75;
L150: ( C66 * C67 ) = GroupMorphismStr (# C63 , C65 , ( C68 * C69 ) #) by L149 , L145 , L147 , L124;
L151: (( dom ( C66 * C67 ) ) = C63 & ( cod ( C66 * C67 ) ) = C65) by L150;
thus L152: thesis by L151 , L75;
end;
definition
let C70 , C71 , C72 being AddGroup;
let C73 being (Morphism of C71 , C72);
let C74 being (Morphism of C70 , C71);
redefine func C73 * C74 ->  strict (Morphism of C70 , C72);

coherence by L144;
end;
theorem
L154: (for B61 , B62 , B63 being AddGroup holds (for B64 being (Morphism of B62 , B63) holds (for B65 being (Morphism of B61 , B62) holds (for B66 being (Function of B62 , B63) holds (for B67 being (Function of B61 , B62) holds ((B64 = GroupMorphismStr (# B62 , B63 , B66 #) & B65 = GroupMorphismStr (# B61 , B62 , B67 #)) implies ( B64 * B65 ) = GroupMorphismStr (# B61 , B63 , ( B66 * B67 ) #)))))))
proof
let C75 , C76 , C77 being AddGroup;
let C78 being (Morphism of C76 , C77);
let C79 being (Morphism of C75 , C76);
let C80 being (Function of C76 , C77);
let C81 being (Function of C75 , C76);
assume that
L155: (C78 = GroupMorphismStr (# C76 , C77 , C80 #) & C79 = GroupMorphismStr (# C75 , C76 , C81 #));
L156: ( dom C78 ) = C76 by L75
.= ( cod C79 ) by L75;
thus L157: thesis by L156 , L155 , L124;
end;
theorem
L158: (for B68 , B69 being  strict GroupMorphism holds (( dom B69 ) = ( cod B68 ) implies (ex B70 , B71 , B72 being AddGroup st (ex B73 being (Function of B70 , B71) st (ex B74 being (Function of B71 , B72) st (B68 = GroupMorphismStr (# B70 , B71 , B73 #) & B69 = GroupMorphismStr (# B71 , B72 , B74 #) & ( B69 * B68 ) = GroupMorphismStr (# B70 , B72 , ( B74 * B73 ) #)))))))
proof
let C82 , C83 being  strict GroupMorphism;
assume that
L159: ( dom C83 ) = ( cod C82 );
set D24 = ( dom C82 );
set D25 = ( cod C82 );
set D26 = ( cod C83 );
reconsider D27 = C82 as  strict (Morphism of D24 , D25) by L75;
reconsider D28 = C83 as  strict (Morphism of D25 , D26) by L159 , L75;
consider C84 being (Function of D24 , D25) such that L160: D27 = GroupMorphismStr (# D24 , D25 , C84 #);
consider C85 being (Function of D25 , D26) such that L161: D28 = GroupMorphismStr (# D25 , D26 , C85 #) by L105;
take D24;
take D25;
take D26;
take C84;
take C85;
thus L162: thesis by L160 , L161 , L154;
end;
theorem
L163: (for B75 , B76 being  strict GroupMorphism holds (( dom B76 ) = ( cod B75 ) implies (( dom ( B76 * B75 ) ) = ( dom B75 ) & ( cod ( B76 * B75 ) ) = ( cod B76 ))))
proof
let C86 , C87 being  strict GroupMorphism;
assume L164: ( dom C87 ) = ( cod C86 );
L165: (ex B77 , B78 , B79 being AddGroup st (ex B80 being (Function of B77 , B78) st (ex B81 being (Function of B78 , B79) st (C86 = GroupMorphismStr (# B77 , B78 , B80 #) & C87 = GroupMorphismStr (# B78 , B79 , B81 #) & ( C87 * C86 ) = GroupMorphismStr (# B77 , B79 , ( B81 * B80 ) #))))) by L164 , L158;
thus L166: ( dom ( C87 * C86 ) ) = ( dom C86 ) by L165;
thus L167: thesis by L165;
end;
theorem
L168: (for B82 , B83 , B84 , B85 being AddGroup holds (for B86 being  strict (Morphism of B82 , B83) holds (for B87 being  strict (Morphism of B83 , B84) holds (for B88 being  strict (Morphism of B84 , B85) holds ( B88 * ( B87 * B86 ) ) = ( ( B88 * B87 ) * B86 )))))
proof
let C88 , C89 , C90 , C91 being AddGroup;
let C92 being  strict (Morphism of C88 , C89);
let C93 being  strict (Morphism of C89 , C90);
let C94 being  strict (Morphism of C90 , C91);
consider C95 being (Function of C88 , C89) such that L169: C92 = GroupMorphismStr (# C88 , C89 , C95 #) by L105;
consider C96 being (Function of C89 , C90) such that L170: C93 = GroupMorphismStr (# C89 , C90 , C96 #) by L105;
consider C97 being (Function of C90 , C91) such that L171: C94 = GroupMorphismStr (# C90 , C91 , C97 #) by L105;
L172: ( C94 * C93 ) = GroupMorphismStr (# C89 , C91 , ( C97 * C96 ) #) by L170 , L171 , L154;
L173: ( C93 * C92 ) = GroupMorphismStr (# C88 , C90 , ( C96 * C95 ) #) by L169 , L170 , L154;
L174: ( C94 * ( C93 * C92 ) ) = GroupMorphismStr (# C88 , C91 , ( C97 * ( C96 * C95 ) ) #) by L173 , L171 , L154
.= GroupMorphismStr (# C88 , C91 , ( ( C97 * C96 ) * C95 ) #) by RELAT_1:36
.= ( ( C94 * C93 ) * C92 ) by L169 , L172 , L154;
thus L175: thesis by L174;
end;
theorem
L176: (for B89 , B90 , B91 being  strict GroupMorphism holds ((( dom B91 ) = ( cod B90 ) & ( dom B90 ) = ( cod B89 )) implies ( B91 * ( B90 * B89 ) ) = ( ( B91 * B90 ) * B89 )))
proof
let C98 , C99 , C100 being  strict GroupMorphism;
assume that
L177: ( dom C100 ) = ( cod C99 )
and
L178: ( dom C99 ) = ( cod C98 );
set D29 = ( cod C98 );
set D30 = ( cod C99 );
reconsider D31 = C100 as (Morphism of D30 , ( cod C100 )) by L177 , L75;
reconsider D32 = C99 as (Morphism of D29 , D30) by L178 , L75;
reconsider D33 = C98 as (Morphism of ( dom C98 ) , D29) by L75;
L179: ( D31 * ( D32 * D33 ) ) = ( ( D31 * D32 ) * D33 ) by L168;
thus L180: thesis by L179;
end;
theorem
L181: (for R7 being AddGroup holds (( dom ( ID R7 ) ) = R7 & ( cod ( ID R7 ) ) = R7 & (for B92 being  strict GroupMorphism holds (( cod B92 ) = R7 implies ( ( ID R7 ) * B92 ) = B92)) & (for B93 being  strict GroupMorphism holds (( dom B93 ) = R7 implies ( B93 * ( ID R7 ) ) = B93))))
proof
let R7 being AddGroup;
set D34 = ( ID R7 );
thus L182: ( dom D34 ) = R7;
thus L183: ( cod D34 ) = R7;
thus L184: (for B94 being  strict GroupMorphism holds (( cod B94 ) = R7 implies ( D34 * B94 ) = B94))
proof
let C101 being  strict GroupMorphism;
assume that
L185: ( cod C101 ) = R7;
set D35 = ( dom C101 );
reconsider D36 = C101 as (Morphism of D35 , R7) by L185 , L75;
consider C102 being (Function of D35 , R7) such that L186: D36 = GroupMorphismStr (# D35 , R7 , C102 #) by L105;
L187: (( dom D34 ) = R7 & ( ( id R7 ) * C102 ) = C102) by FUNCT_2:17;
thus L188: thesis by L187 , L185 , L186 , L124;
end;

thus L189: (for B95 being  strict GroupMorphism holds (( dom B95 ) = R7 implies ( B95 * ( ID R7 ) ) = B95))
proof
let C103 being  strict GroupMorphism;
assume that
L190: ( dom C103 ) = R7;
set D37 = ( cod C103 );
reconsider D38 = C103 as (Morphism of R7 , D37) by L190 , L75;
consider C104 being (Function of R7 , D37) such that L191: D38 = GroupMorphismStr (# R7 , D37 , C104 #) by L105;
L192: (( cod D34 ) = R7 & ( C104 * ( id R7 ) ) = C104) by FUNCT_2:17;
thus L193: thesis by L192 , L190 , L191 , L124;
end;

end;
definition
let C105 being set;
attr C105 is  Group_DOMAIN-like
means
:L190: (for B96 being set holds (B96 in C105 implies B96 is  strict  strict  strict  strict AddGroup));
end;
registration
cluster  Group_DOMAIN-like non  empty for set;
existence
proof
set D39 = { ( Trivial-addLoopStr ) };
take D39;
L192: (for B97 being set holds (B97 in D39 implies B97 is  strict  strict  strict  strict AddGroup)) by TARSKI:def 1;
thus L193: thesis by L192 , L190;
end;
end;
definition
mode Group_DOMAIN
 is  Group_DOMAIN-like non  empty set;
end;
definition
let R9 being Group_DOMAIN;
redefine mode Element of R9
 -> AddGroup;
coherence by L190;
end;
registration
let R9 being Group_DOMAIN;
cluster  strict for (Element of R9);
existence
proof
set D40 = the (Element of R9);
L197: D40 is  strict  strict  strict  strict AddGroup by L190;
thus L198: thesis by L197;
end;
end;
definition
let C106 being set;
attr C106 is  GroupMorphism_DOMAIN-like
means
:L200: (for B98 being set holds (B98 in C106 implies B98 is  strict  strict  strict  strict GroupMorphism));
end;
registration
cluster  GroupMorphism_DOMAIN-like non  empty for set;
existence
proof
set D41 = the AddGroup;
take { ( ID D41 ) };
L202: (for B99 being set holds (B99 in { ( ID D41 ) } implies B99 is  strict  strict  strict  strict GroupMorphism)) by TARSKI:def 1;
thus L203: thesis by L202 , L200;
end;
end;
definition
mode GroupMorphism_DOMAIN
 is  GroupMorphism_DOMAIN-like non  empty set;
end;
definition
let C107 being GroupMorphism_DOMAIN;
redefine mode Element of C107
 -> GroupMorphism;
coherence by L200;
end;
registration
let C108 being GroupMorphism_DOMAIN;
cluster  strict for (Element of C108);
existence
proof
set D42 = the (Element of C108);
L207: D42 is  strict  strict  strict  strict GroupMorphism by L200;
thus L208: thesis by L207;
end;
end;
theorem
L210: (for B100 being  strict GroupMorphism holds { B100 } is GroupMorphism_DOMAIN)
proof
let C109 being  strict GroupMorphism;
L211: (for B101 being set holds (B101 in { C109 } implies B101 is  strict  strict  strict  strict GroupMorphism)) by TARSKI:def 1;
thus L212: thesis by L211 , L200;
end;
definition
let R7 being AddGroup;
let R8 being AddGroup;
mode GroupMorphism_DOMAIN of R7 , R8
 -> GroupMorphism_DOMAIN
means :L213: (for B102 being (Element of it) holds B102 is  strict  strict  strict  strict (Morphism of R7 , R8));
existence
proof
reconsider D43 = { ( ZERO (R7 , R8) ) } as GroupMorphism_DOMAIN by L210;
take D43;
thus L214: thesis by TARSKI:def 1;
end;
end;
theorem
L216: (for R3 being non  empty set holds (for R7 being AddGroup holds (for R8 being AddGroup holds (R3 is (GroupMorphism_DOMAIN of R7 , R8) iff (for B103 being (Element of R3) holds B103 is  strict  strict  strict  strict (Morphism of R7 , R8))))))
proof
let R3 being non  empty set;
let R7 being AddGroup;
let R8 being AddGroup;
thus L217: (R3 is (GroupMorphism_DOMAIN of R7 , R8) implies (for B104 being (Element of R3) holds B104 is  strict  strict  strict  strict (Morphism of R7 , R8))) by L213;
thus L218: ((for B105 being (Element of R3) holds B105 is  strict  strict  strict  strict (Morphism of R7 , R8)) implies R3 is (GroupMorphism_DOMAIN of R7 , R8))
proof
assume L219: (for B106 being (Element of R3) holds B106 is  strict  strict  strict  strict (Morphism of R7 , R8));
L220: (for B107 being set holds (B107 in R3 implies B107 is  strict  strict  strict  strict GroupMorphism)) by L219;
reconsider D44 = R3 as GroupMorphism_DOMAIN by L220 , L200;
L221: (for B108 being (Element of D44) holds B108 is  strict  strict  strict  strict (Morphism of R7 , R8)) by L219;
thus L222: thesis by L221 , L213;
end;

end;
theorem
L219: (for R7 being AddGroup holds (for R8 being AddGroup holds (for B109 being  strict (Morphism of R7 , R8) holds { B109 } is (GroupMorphism_DOMAIN of R7 , R8))))
proof
let R7 being AddGroup;
let R8 being AddGroup;
let C110 being  strict (Morphism of R7 , R8);
L220: (for B110 being (Element of { C110 }) holds B110 is  strict  strict  strict  strict (Morphism of R7 , R8)) by TARSKI:def 1;
thus L221: thesis by L220 , L216;
end;
definition
let C111 , C112 being 1-sorted;
mode MapsSet of C111 , C112
means :L222: (for B111 being set holds (B111 in it implies B111 is (Function of C111 , C112)));
existence
proof
take ( {} );
thus L223: thesis;
end;
end;
definition
let C113 , C114 being 1-sorted;
func Maps (C113 , C114) -> (MapsSet of C113 , C114) equals 
( Funcs ((the carrier of C113) , (the carrier of C114)) );
coherence
proof
let C115 being set;
assume L225: C115 in ( Funcs ((the carrier of C113) , (the carrier of C114)) );
thus L226: thesis by L225 , FUNCT_2:66;
end;
end;
registration
let C116 being 1-sorted;
let C117 being non  empty 1-sorted;
cluster ( Maps (C116 , C117) ) -> non  empty;
coherence;
end;
registration
let C118 being 1-sorted;
let C119 being non  empty 1-sorted;
cluster non  empty for (MapsSet of C118 , C119);
existence
proof
L229: ( Maps (C118 , C119) ) is non  empty;
thus L230: thesis by L229;
end;
end;
definition
let C120 being 1-sorted;
let C121 being non  empty 1-sorted;
let C122 being non  empty (MapsSet of C120 , C121);
redefine mode Element of C122
 -> (Function of C120 , C121);
coherence by L222;
end;
definition
let R7 being AddGroup;
let R8 being AddGroup;
func Morphs (R7 , R8) -> (GroupMorphism_DOMAIN of R7 , R8) means 
:L233: (for R1 being set holds (R1 in it iff R1 is  strict  strict  strict  strict (Morphism of R7 , R8)));
existence
proof
reconsider D45 = ( ZeroMap (R7 , R8) ) as (Element of ( Maps (R7 , R8) )) by FUNCT_2:8;
set D46 = { GroupMorphismStr (# R7 , R8 , B112 #) where B112 is (Element of ( Maps (R7 , R8) )) : B112 is  additive };
L234: GroupMorphismStr (# R7 , R8 , D45 #) in D46;
reconsider D47 = D46 as non  empty set by L234;
L235: (for R1 being set holds (R1 in D47 implies R1 is  strict  strict  strict  strict (Morphism of R7 , R8)))
proof
let R1 being set;
assume L236: R1 in D47;
L237: (ex B113 being (Element of ( Maps (R7 , R8) )) st (R1 = GroupMorphismStr (# R7 , R8 , B113 #) & B113 is  additive)) by L236;
thus L238: thesis by L237 , L87;
end;
L239: (for B114 being (Element of D47) holds B114 is  strict  strict  strict  strict (Morphism of R7 , R8)) by L235;
L240: (for R1 being set holds (R1 is  strict  strict  strict  strict (Morphism of R7 , R8) implies R1 in D47))
proof
let R1 being set;
assume L241: R1 is  strict  strict  strict  strict (Morphism of R7 , R8);
reconsider D48 = R1 as  strict (Morphism of R7 , R8) by L241;
L242: (( dom D48 ) = R7 & ( cod D48 ) = R8) by L75;
reconsider D49 = (the Fun of D48) as (Function of R7 , R8) by L242;
reconsider D50 = D49 as (Element of ( Maps (R7 , R8) )) by FUNCT_2:8;
L243: D48 = GroupMorphismStr (# R7 , R8 , D50 #) by L242;
L244: (the Fun of D48) is  additive by L69;
thus L245: thesis by L244 , L243;
end;
reconsider D51 = D47 as (GroupMorphism_DOMAIN of R7 , R8) by L239 , L216;
take D51;
thus L246: thesis by L235 , L240;
end;
uniqueness
proof
let C123 , C124 being (GroupMorphism_DOMAIN of R7 , R8);
assume that
L247: (for R1 being set holds (R1 in C123 iff R1 is  strict  strict  strict  strict (Morphism of R7 , R8)))
and
L248: (for R1 being set holds (R1 in C124 iff R1 is  strict  strict  strict  strict (Morphism of R7 , R8)));
L249: (for R1 being set holds (R1 in C123 iff R1 in C124))
proof
let R1 being set;
thus L250: (R1 in C123 implies R1 in C124)
proof
assume L251: R1 in C123;
L252: R1 is  strict  strict  strict  strict (Morphism of R7 , R8) by L251 , L247;
thus L253: thesis by L252 , L248;
end;

thus L254: (R1 in C124 implies R1 in C123)
proof
assume L255: R1 in C124;
L256: R1 is  strict  strict  strict  strict (Morphism of R7 , R8) by L255 , L248;
thus L257: thesis by L256 , L247;
end;

end;
thus L255: thesis by L249 , TARSKI:1;
end;
end;
definition
let R7 being AddGroup;
let R8 being AddGroup;
let C125 being (GroupMorphism_DOMAIN of R7 , R8);
redefine mode Element of C125
 -> (Morphism of R7 , R8);
coherence by L213;
end;
registration
let R7 being AddGroup;
let R8 being AddGroup;
let C126 being (GroupMorphism_DOMAIN of R7 , R8);
cluster  strict for (Element of C126);
existence
proof
set D52 = the (Element of C126);
L258: D52 is  strict  strict  strict  strict (Morphism of R7 , R8) by L213;
thus L259: thesis by L258;
end;
end;
definition
let R1 being set;
let R2 being set;
pred  GO R1 , R2
means
:L261: (ex B115 , B116 , B117 , B118 being set st (R1 = [ B115 , B116 , B117 , B118 ] & (ex B119 being  strict AddGroup st (R2 = B119 & B115 = (the carrier of B119) & B116 = (the addF of B119) & B117 = ( comp B119 ) & B118 = ( 0. B119 )))))
;end;
theorem
L263: (for B120 , B121 , B122 being set holds (( GO B120 , B121 &  GO B120 , B122) implies B121 = B122))
proof
let C127 , C128 , C129 being set;
assume that
L264:  GO C127 , C128
and
L265:  GO C127 , C129;
consider C130 , C131 , C132 , C133 being set such that L266: C127 = [ C130 , C131 , C132 , C133 ] and L267: (ex B123 being  strict AddGroup st (C128 = B123 & C130 = (the carrier of B123) & C131 = (the addF of B123) & C132 = ( comp B123 ) & C133 = ( 0. B123 ))) by L264 , L261;
consider C134 being  strict AddGroup such that L268: C128 = C134 and L269: (C130 = (the carrier of C134) & C131 = (the addF of C134)) and L270: C132 = ( comp C134 ) and L271: C133 = ( 0. C134 ) by L267;
consider C135 , C136 , C137 , C138 being set such that L272: C127 = [ C135 , C136 , C137 , C138 ] and L273: (ex B124 being  strict AddGroup st (C129 = B124 & C135 = (the carrier of B124) & C136 = (the addF of B124) & C137 = ( comp B124 ) & C138 = ( 0. B124 ))) by L265 , L261;
consider C139 being  strict AddGroup such that L274: C129 = C139 and L275: (C135 = (the carrier of C139) & C136 = (the addF of C139)) and L276: C137 = ( comp C139 ) and L277: C138 = ( 0. C139 ) by L273;
L278: ((the carrier of C134) = (the carrier of C139) & (the addF of C134) = (the addF of C139)) by L266 , L272 , L269 , L275 , XTUPLE_0:5;
thus L279: thesis by L278 , L266 , L272 , L268 , L271 , L274 , L277 , XTUPLE_0:5;
end;
theorem
L280: (for R4 being Universe holds (ex R1 being set st (R1 in R4 &  GO R1 , ( Trivial-addLoopStr ))))
proof
let R4 being Universe;
reconsider D53 = ( op2 ) as (Element of R4) by L10;
reconsider D54 = ( comp ( Trivial-addLoopStr ) ) as (Element of R4) by L10 , L35;
reconsider D55 = ( {} ) as (Element of R4) by CLASSES2:56;
set D56 = { D55 };
L281: ( Extract ( {} ) ) = D55;
reconsider D57 = ( Extract ( {} ) ) as (Element of R4) by L281;
take D58 = [ D56 , D53 , D54 , D57 ];
thus L282: D58 in R4 by L1;
take D56;
take D53;
take D54;
take D57;
thus L283: D58 = [ D56 , D53 , D54 , D57 ];
take ( Trivial-addLoopStr );
thus L284: thesis by CARD_1:49;
end;
definition
let R4 being Universe;
func GroupObjects R4 -> set means 
:L285: (for R2 being set holds (R2 in it iff (ex R1 being set st (R1 in R4 &  GO R1 , R2))));
existence
proof
defpred S2[ set , set ] means  GO $1 , $2;
L286: (for B125 , B126 , B127 being set holds ((S2[ B125 , B126 ] & S2[ B125 , B127 ]) implies B126 = B127)) by L263;
consider C140 being set such that L287: (for R2 being set holds (R2 in C140 iff (ex R1 being set st (R1 in R4 & S2[ R1 , R2 ])))) from TARSKI:sch 1(L286);
take C140;
thus L288: thesis by L287;
end;
uniqueness
proof
defpred S3[ set ] means (ex R1 being set st (R1 in R4 &  GO R1 , $1));
L289: (for B128 , B129 being set holds (((for B130 being set holds (B130 in B128 iff S3[ B130 ])) & (for B131 being set holds (B131 in B129 iff S3[ B131 ]))) implies B128 = B129)) from XBOOLE_0:sch 3;
thus L290: thesis by L289;
end;
end;
theorem
L292: (for R4 being Universe holds ( Trivial-addLoopStr ) in ( GroupObjects R4 ))
proof
let R4 being Universe;
L293: (ex R1 being set st (R1 in R4 &  GO R1 , ( Trivial-addLoopStr ))) by L280;
thus L294: thesis by L293 , L285;
end;
registration
let R4 being Universe;
cluster ( GroupObjects R4 ) -> non  empty;
coherence by L292;
end;
theorem
L296: (for R4 being Universe holds (for B132 being (Element of ( GroupObjects R4 )) holds B132 is  strict  strict  strict  strict AddGroup))
proof
let R4 being Universe;
let C141 being (Element of ( GroupObjects R4 ));
consider C142 being set such that L297: C142 in R4 and L298:  GO C142 , C141 by L285;
L299: (ex B133 , B134 , B135 , B136 being set st (C142 = [ B133 , B134 , B135 , B136 ] & (ex B137 being  strict AddGroup st (C141 = B137 & B133 = (the carrier of B137) & B134 = (the addF of B137) & B135 = ( comp B137 ) & B136 = ( 0. B137 ))))) by L298 , L261;
thus L300: thesis by L299;
end;
registration
let R4 being Universe;
cluster ( GroupObjects R4 ) ->  Group_DOMAIN-like;
coherence
proof
let R1 being set;
thus L301: thesis by L296;
end;
end;
definition
let R9 being Group_DOMAIN;
func Morphs R9 -> GroupMorphism_DOMAIN means 
:L303: (for R1 being set holds (R1 in it iff (ex B138 , B139 being  strict (Element of R9) st R1 is  strict  strict  strict  strict (Morphism of B138 , B139))));
existence
proof
set D59 = the  strict (Element of R9);
set D60 = ( Morphs (D59 , D59) );
set D61 = { ( Morphs (B140 , B141) ) where B140 is  strict (Element of R9) , B141 is  strict (Element of R9) : (not contradiction) };
L304: (( ZERO (D59 , D59) ) is (Element of D60) & D60 in D61) by L233;
reconsider D62 = ( union D61 ) as non  empty set by L304 , TARSKI:def 4;
L305: (for R1 being set holds (R1 in D62 iff (ex B142 , B143 being  strict (Element of R9) st R1 is  strict  strict  strict  strict (Morphism of B142 , B143))))
proof
let R1 being set;
thus L306: (R1 in D62 implies (ex B144 , B145 being  strict (Element of R9) st R1 is  strict  strict  strict  strict (Morphism of B144 , B145)))
proof
assume L307: R1 in D62;
consider C143 being set such that L308: R1 in C143 and L309: C143 in D61 by L307 , TARSKI:def 4;
consider C144 , C145 being  strict (Element of R9) such that L310: C143 = ( Morphs (C144 , C145) ) by L309;
take C144;
take C145;
thus L311: thesis by L308 , L310 , L233;
end;

thus L312: ((ex B146 , B147 being  strict (Element of R9) st R1 is  strict  strict  strict  strict (Morphism of B146 , B147)) implies R1 in D62)
proof
given C146 , C147 being  strict (Element of R9) such that
L313: R1 is  strict  strict  strict  strict (Morphism of C146 , C147);

set D63 = ( Morphs (C146 , C147) );
L314: D63 in D61;
L315: R1 in D63 by L313 , L233;
thus L316: thesis by L315 , L314 , TARSKI:def 4;
end;

end;
L313:
now
let C148 being set;
assume L314: C148 in D62;
L315: (ex B148 , B149 being  strict (Element of R9) st C148 is  strict  strict  strict  strict (Morphism of B148 , B149)) by L314 , L305;
thus L316: C148 is  strict  strict  strict  strict GroupMorphism by L315;
end;
reconsider D64 = D62 as GroupMorphism_DOMAIN by L313 , L200;
take D64;
thus L317: thesis by L305;
end;
uniqueness
proof
let C149 , C150 being GroupMorphism_DOMAIN;
assume that
L318: (for R1 being set holds (R1 in C149 iff (ex B150 , B151 being  strict (Element of R9) st R1 is  strict  strict  strict  strict (Morphism of B150 , B151))))
and
L319: (for R1 being set holds (R1 in C150 iff (ex B152 , B153 being  strict (Element of R9) st R1 is  strict  strict  strict  strict (Morphism of B152 , B153))));
L320:
now
let R1 being set;
L321: (R1 in C149 iff (ex B154 , B155 being  strict (Element of R9) st R1 is  strict  strict  strict  strict (Morphism of B154 , B155))) by L318;
thus L322: (R1 in C149 iff R1 in C150) by L321 , L319;
end;
thus L323: thesis by L320 , TARSKI:1;
end;
end;
definition
let R9 being Group_DOMAIN;
let C151 being (Element of ( Morphs R9 ));
redefine func dom C151 ->  strict (Element of R9);

coherence
proof
consider C152 , C153 being  strict (Element of R9) such that L325: C151 is  strict  strict  strict  strict (Morphism of C152 , C153) by L303;
reconsider D65 = C151 as (Morphism of C152 , C153) by L325;
L326: ( dom D65 ) = C152 by L75;
thus L327: thesis by L326;
end;
redefine func cod C151 ->  strict (Element of R9);

coherence
proof
consider C154 , C155 being  strict (Element of R9) such that L328: C151 is  strict  strict  strict  strict (Morphism of C154 , C155) by L303;
reconsider D66 = C151 as (Morphism of C154 , C155) by L328;
L329: ( cod D66 ) = C155 by L75;
thus L330: thesis by L329;
end;
end;
definition
let R9 being Group_DOMAIN;
let C156 being (Element of R9);
func ID C156 ->  strict (Element of ( Morphs R9 )) equals 
( ID C156 );
coherence
proof
reconsider D67 = C156 as  strict (Element of R9) by L190;
L332: ( ID D67 ) is  strict  strict  strict  strict (Element of ( Morphs R9 )) by L303;
thus L333: thesis by L332;
end;
end;
definition
let R9 being Group_DOMAIN;
func dom R9 -> (Function of ( Morphs R9 ) , R9) means 
:L335: (for B156 being (Element of ( Morphs R9 )) holds ( it . B156 ) = ( dom B156 ));
existence
proof
deffunc H1((Element of ( Morphs R9 ))) = ( dom $1 );
consider C157 being (Function of ( Morphs R9 ) , R9) such that L336: (for B157 being (Element of ( Morphs R9 )) holds ( C157 . B157 ) = H1(B157)) from FUNCT_2:sch 4;
take C157;
thus L337: thesis by L336;
end;
uniqueness
proof
let C158 , C159 being (Function of ( Morphs R9 ) , R9);
assume that
L338: (for B158 being (Element of ( Morphs R9 )) holds ( C158 . B158 ) = ( dom B158 ))
and
L339: (for B159 being (Element of ( Morphs R9 )) holds ( C159 . B159 ) = ( dom B159 ));
L340:
now
let C160 being (Element of ( Morphs R9 ));
L341: ( C158 . C160 ) = ( dom C160 ) by L338;
thus L342: ( C158 . C160 ) = ( C159 . C160 ) by L341 , L339;
end;
thus L343: thesis by L340 , FUNCT_2:63;
end;
func cod R9 -> (Function of ( Morphs R9 ) , R9) means 
:L344: (for B160 being (Element of ( Morphs R9 )) holds ( it . B160 ) = ( cod B160 ));
existence
proof
deffunc H2((Element of ( Morphs R9 ))) = ( cod $1 );
consider C161 being (Function of ( Morphs R9 ) , R9) such that L345: (for B161 being (Element of ( Morphs R9 )) holds ( C161 . B161 ) = H2(B161)) from FUNCT_2:sch 4;
take C161;
thus L346: thesis by L345;
end;
uniqueness
proof
let C162 , C163 being (Function of ( Morphs R9 ) , R9);
assume that
L347: (for B162 being (Element of ( Morphs R9 )) holds ( C162 . B162 ) = ( cod B162 ))
and
L348: (for B163 being (Element of ( Morphs R9 )) holds ( C163 . B163 ) = ( cod B163 ));
L349:
now
let C164 being (Element of ( Morphs R9 ));
L350: ( C162 . C164 ) = ( cod C164 ) by L347;
thus L351: ( C162 . C164 ) = ( C163 . C164 ) by L350 , L348;
end;
thus L352: thesis by L349 , FUNCT_2:63;
end;
end;
theorem
L354: (for R9 being Group_DOMAIN holds (for B164 , B165 being (Element of ( Morphs R9 )) holds (( dom B164 ) = ( cod B165 ) implies (ex B166 , B167 , B168 being  strict (Element of R9) st (B164 is (Morphism of B167 , B168) & B165 is (Morphism of B166 , B167))))))
proof
let R9 being Group_DOMAIN;
set D68 = ( Morphs R9 );
defpred S4[ (Element of D68) , (Element of D68) ] means ( dom $1 ) = ( cod $2 );
let C165 , C166 being (Element of D68);
assume that
L355: S4[ C165 , C166 ];
consider C167 , C168 being  strict (Element of R9) such that L356: C165 is  strict  strict  strict  strict (Morphism of C167 , C168) by L303;
consider C169 , C170 being  strict (Element of R9) such that L357: C166 is  strict  strict  strict  strict (Morphism of C169 , C170) by L303;
L358: C170 = ( cod C166 ) by L357 , L75;
L359: C167 = ( dom C165 ) by L356 , L75;
thus L360: thesis by L359 , L355 , L356 , L357 , L358;
end;
theorem
L361: (for R9 being Group_DOMAIN holds (for B169 , B170 being (Element of ( Morphs R9 )) holds (( dom B169 ) = ( cod B170 ) implies ( B169 * B170 ) in ( Morphs R9 ))))
proof
let R9 being Group_DOMAIN;
set D69 = ( Morphs R9 );
defpred S5[ (Element of D69) , (Element of D69) ] means ( dom $1 ) = ( cod $2 );
let C171 , C172 being (Element of D69);
assume L362: S5[ C171 , C172 ];
consider C173 , C174 , C175 being  strict (Element of R9) such that L363: C171 is (Morphism of C174 , C175) and L364: C172 is (Morphism of C173 , C174) by L362 , L354;
reconsider D70 = C172 as (Morphism of C173 , C174) by L364;
reconsider D71 = C171 as (Morphism of C174 , C175) by L363;
L365: ( D71 * D70 ) is (Morphism of C173 , C175);
thus L366: thesis by L365 , L303;
end;
definition
let R9 being Group_DOMAIN;
func comp R9 -> (PartFunc of [: ( Morphs R9 ) , ( Morphs R9 ) :] , ( Morphs R9 )) means 
:L367: ((for B171 , B172 being (Element of ( Morphs R9 )) holds ([ B171 , B172 ] in ( dom it ) iff ( dom B171 ) = ( cod B172 ))) & (for B173 , B174 being (Element of ( Morphs R9 )) holds ([ B173 , B174 ] in ( dom it ) implies ( it . (B173 , B174) ) = ( B173 * B174 ))));
existence
proof
set D72 = ( Morphs R9 );
defpred S6[ (Element of D72) , (Element of D72) ] means ( dom $1 ) = ( cod $2 );
deffunc H3((Element of D72) , (Element of D72)) = ( $1 * $2 );
L368: (for B175 , B176 being (Element of D72) holds (S6[ B175 , B176 ] implies H3(B175 , B176) in D72)) by L361;
consider C176 being (PartFunc of [: D72 , D72 :] , D72) such that L369: ((for B177 , B178 being (Element of D72) holds ([ B177 , B178 ] in ( dom C176 ) iff S6[ B177 , B178 ])) & (for B179 , B180 being (Element of D72) holds ([ B179 , B180 ] in ( dom C176 ) implies ( C176 . (B179 , B180) ) = H3(B179 , B180)))) from BINOP_1:sch 8(L368);
take C176;
thus L370: thesis by L369;
end;
uniqueness
proof
set D73 = ( Morphs R9 );
defpred S7[ (Element of D73) , (Element of D73) ] means ( dom $1 ) = ( cod $2 );
let C177 , C178 being (PartFunc of [: D73 , D73 :] , D73);
assume that
L371: (for B181 , B182 being (Element of D73) holds ([ B181 , B182 ] in ( dom C177 ) iff S7[ B181 , B182 ]))
and
L372: (for B183 , B184 being (Element of D73) holds ([ B183 , B184 ] in ( dom C177 ) implies ( C177 . (B183 , B184) ) = ( B183 * B184 )))
and
L373: (for B185 , B186 being (Element of D73) holds ([ B185 , B186 ] in ( dom C178 ) iff S7[ B185 , B186 ]))
and
L374: (for B187 , B188 being (Element of D73) holds ([ B187 , B188 ] in ( dom C178 ) implies ( C178 . (B187 , B188) ) = ( B187 * B188 )));
set D74 = ( dom C177 );
L375: ( dom C177 ) c= [: D73 , D73 :] by RELAT_1:def 18;
L376:
now
let R1 being set;
assume L377: R1 in ( dom C177 );
consider C179 , C180 being (Element of D73) such that L378: R1 = [ C179 , C180 ] by L377 , L375 , SUBSET_1:43;
L379: S7[ C179 , C180 ] by L371 , L377 , L378;
thus L380: R1 in ( dom C178 ) by L379 , L373 , L378;
end;
L381: ( dom C177 ) c= ( dom C178 ) by L376 , TARSKI:def 3;
L382: (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in D74 implies ( C177 . (R1 , R2) ) = ( C178 . (R1 , R2) ))))
proof
let R1 being set;
let R2 being set;
assume L383: [ R1 , R2 ] in D74;
reconsider D75 = R1 , D76 = R2 as (Element of D73) by L383 , L375 , ZFMISC_1:87;
L384: ( C177 . (D75 , D76) ) = ( D75 * D76 ) by L372 , L383;
thus L385: thesis by L384 , L374 , L381 , L383;
end;
L386:
now
let R1 being set;
assume L387: R1 in ( dom C178 );
L388: ( dom C178 ) c= [: D73 , D73 :] by RELAT_1:def 18;
consider C181 , C182 being (Element of D73) such that L389: R1 = [ C181 , C182 ] by L388 , L387 , SUBSET_1:43;
L390: S7[ C181 , C182 ] by L373 , L387 , L389;
thus L391: R1 in ( dom C177 ) by L390 , L371 , L389;
end;
L392: ( dom C178 ) c= ( dom C177 ) by L386 , TARSKI:def 3;
L393: ( dom C177 ) = ( dom C178 ) by L392 , L381 , XBOOLE_0:def 10;
thus L394: thesis by L393 , L382 , BINOP_1:20;
end;
end;
definition
let R4 being Universe;
func GroupCat R4 -> non  empty non  void  strict CatStr equals 
CatStr (# ( GroupObjects R4 ) , ( Morphs ( GroupObjects R4 ) ) , ( dom ( GroupObjects R4 ) ) , ( cod ( GroupObjects R4 ) ) , ( comp ( GroupObjects R4 ) ) #);
coherence;
end;
registration
let R4 being Universe;
cluster ( GroupCat R4 ) ->  strict non  void non  empty;
coherence;
end;
theorem
L398: (for R4 being Universe holds (for B189 , B190 being (Morphism of ( GroupCat R4 )) holds ([ B190 , B189 ] in ( dom (the Comp of ( GroupCat R4 )) ) iff ( dom B190 ) = ( cod B189 ))))
proof
let R4 being Universe;
set D77 = ( GroupCat R4 );
set D78 = ( GroupObjects R4 );
let C183 , C184 being (Morphism of D77);
reconsider D79 = C183 as (Element of ( Morphs D78 ));
reconsider D80 = C184 as (Element of ( Morphs D78 ));
L399: (( dom C184 ) = ( dom D80 ) & ( cod C183 ) = ( cod D79 )) by L335 , L344;
thus L400: thesis by L399 , L367;
end;
theorem
L401: (for R4 being Universe holds (for B191 being (Morphism of ( GroupCat R4 )) holds (for B192 being (Element of ( Morphs ( GroupObjects R4 ) )) holds (for B193 being (Object of ( GroupCat R4 )) holds (for B194 being (Element of ( GroupObjects R4 )) holds (B191 is  strict  strict  strict  strict (Element of ( Morphs ( GroupObjects R4 ) )) & B192 is (Morphism of ( GroupCat R4 )) & B193 is  strict  strict  strict  strict (Element of ( GroupObjects R4 )) & B194 is (Object of ( GroupCat R4 ))))))))
proof
let R4 being Universe;
set D81 = ( GroupCat R4 );
set D82 = ( GroupObjects R4 );
set D83 = ( Morphs D82 );
let C185 being (Morphism of D81);
let C186 being (Element of D83);
let C187 being (Object of D81);
let C188 being (Element of D82);
consider R1 being set such that L402: R1 in R4 and L403:  GO R1 , C187 by L285;
L404: (ex B195 , B196 being  strict (Element of D82) st C185 is  strict  strict  strict  strict (Morphism of B195 , B196)) by L303;
thus L405: C185 is  strict  strict  strict  strict (Element of D83) by L404;
thus L406: C186 is (Morphism of D81);
L407: (ex B197 , B198 , B199 , B200 being set st (R1 = [ B197 , B198 , B199 , B200 ] & (ex B201 being  strict AddGroup st (C187 = B201 & B197 = (the carrier of B201) & B198 = (the addF of B201) & B199 = ( comp B201 ) & B200 = ( 0. B201 ))))) by L403 , L261;
thus L408: C187 is  strict  strict  strict  strict (Element of D82) by L407;
thus L409: thesis;
end;
canceled 1;
theorem
L410: (for R4 being Universe holds (for B202 , B203 being (Morphism of ( GroupCat R4 )) holds (for B204 , B205 being (Element of ( Morphs ( GroupObjects R4 ) )) holds ((B202 = B204 & B203 = B205) implies ((( dom B203 ) = ( cod B202 ) iff ( dom B205 ) = ( cod B204 )) & (( dom B203 ) = ( cod B202 ) iff [ B205 , B204 ] in ( dom ( comp ( GroupObjects R4 ) ) )) & (( dom B203 ) = ( cod B202 ) implies ( B203 (*) B202 ) = ( B205 * B204 )) & (( dom B202 ) = ( dom B203 ) iff ( dom B204 ) = ( dom B205 )) & (( cod B202 ) = ( cod B203 ) iff ( cod B204 ) = ( cod B205 )))))))
proof
let R4 being Universe;
set D84 = ( GroupCat R4 );
set D85 = ( GroupObjects R4 );
set D86 = ( Morphs D85 );
let C189 , C190 being (Morphism of D84);
let C191 , C192 being (Element of D86);
assume that
L411: C189 = C191
and
L412: C190 = C192;
L413: ( cod C189 ) = ( cod C191 ) by L411 , L344;
thus L414: (( dom C190 ) = ( cod C189 ) iff ( dom C192 ) = ( cod C191 )) by L413 , L412 , L335;
L415: ( dom C190 ) = ( dom C192 ) by L412 , L335;
thus L416: (( dom C190 ) = ( cod C189 ) iff [ C192 , C191 ] in ( dom ( comp D85 ) )) by L415 , L413 , L367;
thus L417: (( dom C190 ) = ( cod C189 ) implies ( C190 (*) C189 ) = ( C192 * C191 ))
proof
assume L418: ( dom C190 ) = ( cod C189 );
L419: [ C190 , C189 ] in ( dom (the Comp of D84) ) by L418 , L398;
thus L420: ( C190 (*) C189 ) = ( ( comp D85 ) . (C192 , C191) ) by L419 , L411 , L412 , CAT_1:def 1
.= ( C192 * C191 ) by L416 , L418 , L367;
end;

L421: ( dom C189 ) = ( dom C191 ) by L411 , L335;
thus L422: (( dom C189 ) = ( dom C190 ) iff ( dom C191 ) = ( dom C192 )) by L421 , L412 , L335;
L423: ( cod C190 ) = ( cod C192 ) by L412 , L344;
thus L424: thesis by L423 , L411 , L344;
end;
L425: (for R4 being Universe holds (for B206 , B207 being (Morphism of ( GroupCat R4 )) holds (( dom B207 ) = ( cod B206 ) implies (( dom ( B207 (*) B206 ) ) = ( dom B206 ) & ( cod ( B207 (*) B206 ) ) = ( cod B207 )))))
proof
let R4 being Universe;
set D87 = ( Morphs ( GroupObjects R4 ) );
let C193 , C194 being (Morphism of ( GroupCat R4 ));
assume that
L426: ( dom C194 ) = ( cod C193 );
reconsider D88 = C194 as  strict (Element of D87) by L401;
reconsider D89 = C193 as  strict (Element of D87) by L401;
L427: ( dom D88 ) = ( cod D89 ) by L426 , L410;
reconsider D90 = ( D88 * D89 ) as (Element of D87) by L427 , L361;
L428: D90 = ( C194 (*) C193 ) by L426 , L410;
L429: (( dom ( D88 * D89 ) ) = ( dom D89 ) & ( cod ( D88 * D89 ) ) = ( cod D88 )) by L427 , L163;
thus L430: thesis by L429 , L428 , L410;
end;
registration
let R4 being Universe;
cluster ( GroupCat R4 ) ->  reflexive  Category-like;
coherence
proof
set D91 = ( GroupCat R4 );
thus L431: D91 is  reflexive
proof
let C195 being (Element of D91);
reconsider D92 = C195 as (Element of ( GroupObjects R4 ));
consider R1 being set such that L432: R1 in R4 and L433:  GO R1 , D92 by L285;
set D93 = ( ID D92 );
consider C196 , C197 , C198 , C199 being set such that L434: R1 = [ C196 , C197 , C198 , C199 ] and L435: (ex B208 being  strict AddGroup st (D92 = B208 & C196 = (the carrier of B208) & C197 = (the addF of B208) & C198 = ( comp B208 ) & C199 = ( 0. B208 ))) by L433 , L261;
reconsider D94 = D92 as  strict (Element of ( GroupObjects R4 )) by L435;
reconsider D95 = D93 as (Morphism of D91);
reconsider D96 = D95 as GroupMorphismStr;
L436: ( dom D95 ) = ( dom D96 ) by L335
.= C195;
L437: ( cod D95 ) = ( cod D96 ) by L344
.= C195;
L438: D95 in ( Hom (C195 , C195) ) by L437 , L436;
thus L439: ( Hom (C195 , C195) ) <> ( {} ) by L438;
end;

let C200 , C201 being (Morphism of D91);
reconsider D97 = C200 , D98 = C201 as (Element of ( Morphs ( GroupObjects R4 ) ));
thus L440: ([ C201 , C200 ] in ( dom (the Comp of D91) ) iff ( dom C201 ) = ( cod C200 )) by L410;
end;
end;
L442: (for R4 being Universe holds (for B209 being (Element of ( GroupCat R4 )) holds (for B210 being (Element of ( GroupObjects R4 )) holds (B209 = B210 implies (for B211 being (Morphism of B209 , B209) holds (B211 = ( ID B210 ) implies (for B212 being (Element of ( GroupCat R4 )) holds ((( Hom (B209 , B212) ) <> ( {} ) implies (for B213 being (Morphism of B209 , B212) holds ( B213 (*) B211 ) = B213)) & (( Hom (B212 , B209) ) <> ( {} ) implies (for B214 being (Morphism of B212 , B209) holds ( B211 (*) B214 ) = B214))))))))))
proof
let R4 being Universe;
let C202 being (Element of ( GroupCat R4 ));
let C203 being (Element of ( GroupObjects R4 ));
assume that
L443: C202 = C203;
let C204 being (Morphism of C202 , C202);
assume that
L444: C204 = ( ID C203 );
let C205 being (Element of ( GroupCat R4 ));
thus L445: (( Hom (C202 , C205) ) <> ( {} ) implies (for B215 being (Morphism of C202 , C205) holds ( B215 (*) C204 ) = B215))
proof
assume L446: ( Hom (C202 , C205) ) <> ( {} );
let C206 being (Morphism of C202 , C205);
reconsider D99 = C206 , D100 = C204 as (Element of ( Morphs ( GroupObjects R4 ) ));
consider C207 , C208 being  strict (Element of ( GroupObjects R4 )) such that L447: D99 is  strict  strict  strict  strict (Morphism of C207 , C208) by L303;
consider C209 being (Function of C207 , C208) such that L448: D99 = GroupMorphismStr (# C207 , C208 , C209 #) by L447 , L105;
L449: D100 = GroupMorphismStr (# C203 , C203 , ( id C203 ) #) by L444;
L450: ( cod D100 ) = C203 by L444;
L451: ( dom D99 ) = C207 by L448;
L452: ( Hom (C202 , C202) ) <> ( {} );
L453: ( dom C206 ) = C202 by L446 , CAT_1:5
.= ( cod C204 ) by L452 , CAT_1:5;
L454: ( dom D99 ) = ( cod D100 ) by L453 , L410;
L455: C203 = ( dom D99 ) by L454 , L450;
L456: C203 = C207 by L455 , L451;
reconsider D101 = C209 as (Function of C203 , C208) by L456;
L457: ( the GroupMorphismStr of D99 ) = GroupMorphismStr (# C203 , C208 , D101 #) by L448 , L456;
L458: [ D99 , D100 ] in ( dom ( comp ( GroupObjects R4 ) ) ) by L367 , L454;
L459: [ C206 , C204 ] in ( dom (the Comp of ( GroupCat R4 )) ) by L458;
thus L460: ( C206 (*) C204 ) = ( (the Comp of ( GroupCat R4 )) . (C206 , C204) ) by L459 , CAT_1:def 1
.= ( ( comp ( GroupObjects R4 ) ) . (C206 , C204) )
.= ( D99 * D100 ) by L458 , L367
.= GroupMorphismStr (# C203 , C208 , ( D101 * ( id C203 ) ) #) by L449 , L124 , L457 , L454
.= GroupMorphismStr (# C203 , C208 , D101 #) by FUNCT_2:17
.= C206 by L456 , L448;
end;

thus L461: (( Hom (C205 , C202) ) <> ( {} ) implies (for B216 being (Morphism of C205 , C202) holds ( C204 (*) B216 ) = B216))
proof
assume L462: ( Hom (C205 , C202) ) <> ( {} );
let C210 being (Morphism of C205 , C202);
reconsider D102 = C210 , D103 = C204 as (Element of ( Morphs ( GroupObjects R4 ) ));
consider C211 , C212 being  strict (Element of ( GroupObjects R4 )) such that L463: D102 is  strict  strict  strict  strict (Morphism of C211 , C212) by L303;
consider C213 being (Function of C211 , C212) such that L464: D102 = GroupMorphismStr (# C211 , C212 , C213 #) by L463 , L105;
L465: D103 = GroupMorphismStr (# C203 , C203 , ( id C203 ) #) by L444;
L466: ( dom D103 ) = C203 by L444;
L467: ( cod D102 ) = C212 by L464;
L468: ( Hom (C202 , C202) ) <> ( {} );
L469: ( cod C210 ) = C202 by L462 , CAT_1:5
.= ( dom C204 ) by L468 , CAT_1:5;
L470: ( cod D102 ) = ( dom D103 ) by L469 , L410;
L471: C203 = ( cod D102 ) by L470 , L466;
L472: C203 = C212 by L471 , L467;
reconsider D104 = C213 as (Function of C211 , C203) by L472;
L473: ( the GroupMorphismStr of D102 ) = GroupMorphismStr (# C211 , C203 , D104 #) by L464 , L472;
L474: [ D103 , D102 ] in ( dom ( comp ( GroupObjects R4 ) ) ) by L367 , L470;
L475: [ C204 , C210 ] in ( dom (the Comp of ( GroupCat R4 )) ) by L474;
thus L476: ( C204 (*) C210 ) = ( (the Comp of ( GroupCat R4 )) . (C204 , C210) ) by L475 , CAT_1:def 1
.= ( ( comp ( GroupObjects R4 ) ) . (C204 , C210) )
.= ( D103 * D102 ) by L474 , L367
.= GroupMorphismStr (# C211 , C203 , ( ( id C203 ) * D104 ) #) by L465 , L124 , L473 , L470
.= GroupMorphismStr (# C211 , C203 , D104 #) by FUNCT_2:17
.= C210 by L472 , L464;
end;

end;
registration
let R4 being Universe;
cluster ( GroupCat R4 ) ->  transitive  associative  with_identities;
coherence
proof
set D105 = ( GroupCat R4 );
set D106 = ( Morphs ( GroupObjects R4 ) );
thus L462: D105 is  transitive
proof
let C214 , C215 being (Morphism of ( GroupCat R4 ));
assume that
L463: ( dom C215 ) = ( cod C214 );
reconsider D107 = C215 as  strict (Element of D106) by L401;
reconsider D108 = C214 as  strict (Element of D106) by L401;
L464: ( dom D107 ) = ( cod D108 ) by L463 , L410;
reconsider D109 = ( D107 * D108 ) as (Element of D106) by L464 , L361;
L465: D109 = ( C215 (*) C214 ) by L463 , L410;
L466: (( dom ( D107 * D108 ) ) = ( dom D108 ) & ( cod ( D107 * D108 ) ) = ( cod D107 )) by L464 , L163;
thus L467: thesis by L466 , L465 , L410;
end;

thus L468: D105 is  associative
proof
let C216 , C217 , C218 being (Morphism of ( GroupCat R4 ));
assume that
L469: (( dom C218 ) = ( cod C217 ) & ( dom C217 ) = ( cod C216 ));
reconsider D110 = C216 , D111 = C217 , D112 = C218 as  strict (Element of D106) by L401;
L470: (( D112 * D111 ) = ( C218 (*) C217 ) & ( dom ( C218 (*) C217 ) ) = ( cod C216 )) by L469 , L425 , L410;
L471: (( dom D112 ) = ( cod D111 ) & ( dom D111 ) = ( cod D110 )) by L469 , L410;
reconsider D113 = ( D111 * D110 ) , D114 = ( D112 * D111 ) as (Element of D106) by L471 , L361;
L472: (( D111 * D110 ) = ( C217 (*) C216 ) & ( dom C218 ) = ( cod ( C217 (*) C216 ) )) by L469 , L425 , L410;
L473: ( C218 (*) ( C217 (*) C216 ) ) = ( D112 * D113 ) by L472 , L410
.= ( D114 * D110 ) by L471 , L176
.= ( ( C218 (*) C217 ) (*) C216 ) by L470 , L410;
thus L474: thesis by L473;
end;

thus L475: D105 is  with_identities
proof
let C219 being (Element of D105);
reconsider D115 = C219 as (Element of ( GroupObjects R4 ));
reconsider D116 = ( ID D115 ) as (Morphism of D105);
reconsider D117 = D116 as GroupMorphismStr;
L476: ( dom D116 ) = ( dom D117 ) by L335
.= C219;
L477: ( cod D116 ) = ( cod D117 ) by L344
.= C219;
reconsider D118 = D116 as (Morphism of C219 , C219) by L477 , L476 , CAT_1:4;
take D118;
thus L478: thesis by L442;
end;

end;
end;
definition
let R4 being Universe;
func AbGroupObjects R4 -> (Subset of (the carrier of ( GroupCat R4 ))) equals 
{ B217 where B217 is (Element of ( GroupCat R4 )) : (ex B218 being AbGroup st B217 = B218) };
coherence
proof
set D119 = (the carrier of ( GroupCat R4 ));
L477:
now
let C220 being set;
assume L478: C220 in { B219 where B219 is (Element of D119) : (ex B220 being AbGroup st B219 = B220) };
L479: (ex B221 being (Element of D119) st (C220 = B221 & (ex B222 being AbGroup st B221 = B222))) by L478;
thus L480: C220 in D119 by L479;
end;
thus L481: thesis by L477 , TARSKI:def 3;
end;
end;
theorem
L483: (for R4 being Universe holds ( Trivial-addLoopStr ) in ( AbGroupObjects R4 ))
proof
let R4 being Universe;
L484: ( Trivial-addLoopStr ) in (the carrier of ( GroupCat R4 )) by L292;
thus L485: thesis by L484;
end;
registration
let R4 being Universe;
cluster ( AbGroupObjects R4 ) -> non  empty;
coherence by L483;
end;
definition
let R4 being Universe;
func AbGroupCat R4 -> (Subcategory of ( GroupCat R4 )) equals 
( cat ( AbGroupObjects R4 ) );
coherence;
end;
registration
let R4 being Universe;
cluster ( AbGroupCat R4 ) ->  strict;
coherence;
end;
theorem
L489: (for R4 being Universe holds (the carrier of ( AbGroupCat R4 )) = ( AbGroupObjects R4 ));
definition
let R4 being Universe;
func MidOpGroupObjects R4 -> (Subset of (the carrier of ( AbGroupCat R4 ))) equals 
{ B223 where B223 is (Element of ( AbGroupCat R4 )) : (ex B224 being  midpoint_operator AbGroup st B223 = B224) };
coherence
proof
set D120 = (the carrier of ( AbGroupCat R4 ));
L490:
now
let C221 being set;
assume L491: C221 in { B225 where B225 is (Element of D120) : (ex B226 being  midpoint_operator AbGroup st B225 = B226) };
L492: (ex B227 being (Element of D120) st (C221 = B227 & (ex B228 being  midpoint_operator AbGroup st B227 = B228))) by L491;
thus L493: C221 in D120 by L492;
end;
thus L494: thesis by L490 , TARSKI:def 3;
end;
end;
registration
let R4 being Universe;
cluster ( MidOpGroupObjects R4 ) -> non  empty;
coherence
proof
set D121 = ( Trivial-addLoopStr );
set D122 = (the carrier of ( AbGroupCat R4 ));
set D123 = { B229 where B229 is (Element of D122) : (ex B230 being  midpoint_operator AbGroup st B229 = B230) };
L496: D121 in D122 by L483;
L497: D121 in D123 by L496;
reconsider D124 = D123 as non  empty set by L497;
L498:
now
let C222 being set;
assume L499: C222 in D124;
L500: (ex B231 being (Element of D122) st (C222 = B231 & (ex B232 being  midpoint_operator AbGroup st B231 = B232))) by L499;
thus L501: C222 in D122 by L500;
end;
thus L502: thesis by L498;
end;
end;
definition
let R4 being Universe;
func MidOpGroupCat R4 -> (Subcategory of ( AbGroupCat R4 )) equals 
( cat ( MidOpGroupObjects R4 ) );
coherence;
end;
registration
let R4 being Universe;
cluster ( MidOpGroupCat R4 ) ->  strict;
coherence;
end;
theorem
L506: (for R4 being Universe holds (the carrier of ( MidOpGroupCat R4 )) = ( MidOpGroupObjects R4 ));
theorem
L507: (for R4 being Universe holds ( Trivial-addLoopStr ) in ( MidOpGroupObjects R4 ))
proof
let R4 being Universe;
L508: ( Trivial-addLoopStr ) in (the carrier of ( AbGroupCat R4 )) by L483;
thus L509: thesis by L508;
end;
theorem
L510: (for B233 , B234 being non  empty 1-sorted holds (for B235 being (Function of B233 , B234) holds (B235 is  one-to-one  onto implies (( B235 * ( B235 " ) ) = ( id B234 ) & ( ( B235 " ) * B235 ) = ( id B233 ) & ( B235 " ) is  one-to-one  onto))))
proof
let C223 , C224 being non  empty 1-sorted;
let C225 being (Function of C223 , C224);
L511: ( [#] C224 ) = (the carrier of C224);
assume L512: C225 is  one-to-one  onto;
L513: ( rng C225 ) = (the carrier of C224) by L512 , FUNCT_2:def 3;
L514: (( dom C225 ) = (the carrier of C223) & ( rng ( C225 " ) ) = ( [#] C223 )) by L513 , L512 , L511 , FUNCT_2:def 1 , TOPS_2:49;
thus L515: thesis by L514 , L512 , L513 , L511 , FUNCT_2:def 3 , TOPS_2:50 , TOPS_2:52;
end;
theorem
L516: (for R4 being Universe holds (for B236 being (Object of ( GroupCat R4 )) holds (for B237 being (Element of ( GroupObjects R4 )) holds (B236 = B237 implies ( id B236 ) = ( ID B237 )))))
proof
let R4 being Universe;
let C226 being (Object of ( GroupCat R4 ));
let C227 being (Element of ( GroupObjects R4 ));
set D125 = ( GroupCat R4 );
assume L517: C226 = C227;
reconsider D126 = ( ID C227 ) as (Morphism of D125);
reconsider D127 = D126 as GroupMorphismStr;
L518: ( dom D126 ) = ( dom D127 ) by L335
.= C226 by L517;
L519: ( cod D126 ) = ( cod D127 ) by L344
.= C226 by L517;
reconsider D128 = D126 as (Morphism of C226 , C226) by L519 , L518 , CAT_1:4;
L520: (for B238 being (Object of D125) holds ((( Hom (C226 , B238) ) <> ( {} ) implies (for B239 being (Morphism of C226 , B238) holds ( B239 (*) D128 ) = B239)) & (( Hom (B238 , C226) ) <> ( {} ) implies (for B240 being (Morphism of B238 , C226) holds ( D128 (*) B240 ) = B240)))) by L517 , L442;
thus L521: ( id C226 ) = ( ID C227 ) by L520 , CAT_1:def 12;
end;
