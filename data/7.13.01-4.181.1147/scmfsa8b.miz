:: Conditional branch macro instructions of SCM+FSA, Part II
::  by Noriko Asamoto
::
:: Received August 27, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SCMFSA_2, AMI_1, AMISTD_2, CARD_1, TARSKI, TURING_1,
      SCMFSA6A, FUNCT_4, FSM_1, RELAT_1, UNIALG_2, CIRCUIT2, FUNCT_1, SF_MASTR,
      SUBSET_1, ARYTM_3, SCMFSA7B, SCMFSA6B, SCMFSA6C, AMI_3, SCMFSA8A, NAT_1,
      GRAPHSP, XXREAL_0, MSUALG_1, STRUCT_0, ARYTM_1, INT_1, COMPLEX1,
      PARTFUN1, FINSEQ_1, FINSEQ_2, SCMFSA8B, ORDINAL1, EXTPRO_1, RELOC,
      PBOOLE, FUNCOP_1, XBOOLE_0, COMPOS_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, ORDINAL1,
      NAT_1, INT_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCOP_1, FUNCT_4, PBOOLE,
      FUNCT_7, FINSEQ_1, FINSEQ_2, STRUCT_0, MEMSTR_0, COMPOS_0,
      COMPOS_1, EXTPRO_1,
      AMISTD_1, AMISTD_2, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C,
      SCMFSA7B, SCMFSA8A, INT_2, XXREAL_0, SCMFSA_M;
 constructors DOMAIN_1, XXREAL_0, NAT_1, INT_2, SCMFSA6A, SF_MASTR, SCMFSA6B,
      SCMFSA6C, SCMFSA8A, AMISTD_2, RELSET_1, SCMFSA7B, PRE_POLY, AMISTD_1,
      PBOOLE, FUNCOP_1, FUNCT_4, MEMSTR_0, SCMFSA_M, FUNCT_7;
 registrations SETFAM_1, FUNCT_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1,
      SCMFSA_2, SF_MASTR, SCMFSA6A, SCMFSA6B, SCMFSA6C, ORDINAL1, MEMSTR_0,
      XBOOLE_0, FINSET_1, RELSET_1, SCMFSA10, AMISTD_2, COMPOS_1, EXTPRO_1,
      PBOOLE, FUNCT_4, FUNCOP_1, AMISTD_1, RELAT_1, STRUCT_0, FINSEQ_1, AMI_3,
      COMPOS_0, SCMFSA_M;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, STRUCT_0, SCMFSA6A, MEMSTR_0,
      COMPOS_0, SCMFSA_M;
 theorems TARSKI, NAT_1, FUNCT_1, FUNCT_4, SCMFSA_2, MEMSTR_0, SCMFSA6A,
      GRFUNC_1, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, RELAT_1,
      XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0, PARTFUN1, AFINSQ_1,
      SCMFSA10, COMPOS_1, EXTPRO_1, AMISTD_2, PBOOLE, AMISTD_1,
      COMPOS_0, SCMFSA_M;
 schemes NAT_1;

begin
set D1 = ( NAT );
set D2 = ( Data-Locations ( SCM+FSA ) );
set D3 = ( Start-At (( 0 ) , ( SCM+FSA )) );
L1: (for B1 , B2 being (Program of ( SCM+FSA )) holds ( Reloc (B2 , ( card B1 )) ) c= ( B1 ";" B2 )) by FUNCT_4:25;
theorem
L2: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B3 being (Program of ( SCM+FSA )) holds (for B4 being (State of ( SCM+FSA )) holds (B3 is_closed_on B4 , R1 implies ( 0 ) in ( dom B3 )))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C1 being (Program of ( SCM+FSA ));
let C2 being (State of ( SCM+FSA ));
assume L3: C1 is_closed_on C2 , R1;
L4: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L5: ( IC ( Comput (( R1 +* C1 ) , ( Initialize C2 ) , ( 0 )) ) ) = ( ( Initialize C2 ) . ( IC ( SCM+FSA ) ) )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L4 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
thus L6: thesis by L5 , L3 , SCMFSA7B:def 6;
end;
canceled 1;
theorem
L7: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for R3 being (Instruction-Sequence of ( SCM+FSA )) holds (for B5 , B6 being (State of ( SCM+FSA )) holds (for B7 being (Program of ( SCM+FSA )) holds (( DataPart B5 ) = ( DataPart B6 ) implies (B7 is_closed_on B5 , R2 implies B7 is_closed_on B6 , R3))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let R3 being (Instruction-Sequence of ( SCM+FSA ));
let C3 , C4 being (State of ( SCM+FSA ));
let C5 being (Program of ( SCM+FSA ));
set D4 = ( Initialize C3 );
set D5 = ( Initialize C4 );
assume L8: ( DataPart C3 ) = ( DataPart C4 );
L9: ( DataPart ( Comput (( R2 +* C5 ) , D4 , ( 0 )) ) ) = ( DataPart C3 ) by MEMSTR_0:79
.= ( DataPart ( Comput (( R3 +* C5 ) , D5 , ( 0 )) ) ) by L8 , MEMSTR_0:79;
assume L10: C5 is_closed_on C3 , R2;
L11: ( 0 ) in ( dom C5 ) by L10 , L2;
defpred S1[ Nat ] means (( IC ( Comput (( R2 +* C5 ) , D4 , $1) ) ) = ( IC ( Comput (( R3 +* C5 ) , D5 , $1) ) ) & ( CurInstr (( R2 +* C5 ) , ( Comput (( R2 +* C5 ) , D4 , $1) )) ) = ( CurInstr (( R3 +* C5 ) , ( Comput (( R3 +* C5 ) , D5 , $1) )) ) & ( DataPart ( Comput (( R2 +* C5 ) , D4 , $1) ) ) = ( DataPart ( Comput (( R3 +* C5 ) , D5 , $1) ) ));
L12:
now
let C6 being (Element of ( NAT ));
L13: ( Comput (( R3 +* C5 ) , D5 , ( C6 + 1 )) ) = ( Following (( R3 +* C5 ) , ( Comput (( R3 +* C5 ) , D5 , C6) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( R3 +* C5 ) , ( Comput (( R3 +* C5 ) , D5 , C6) )) ) , ( Comput (( R3 +* C5 ) , D5 , C6) )) );
assume L14: S1[ C6 ];
L15: (for B8 being FinSeq-Location holds ( ( Comput (( R2 +* C5 ) , D4 , C6) ) . B8 ) = ( ( Comput (( R3 +* C5 ) , D5 , C6) ) . B8 )) by L14 , SCMFSA_M:2;
L16: (for B9 being Int-Location holds ( ( Comput (( R2 +* C5 ) , D4 , C6) ) . B9 ) = ( ( Comput (( R3 +* C5 ) , D5 , C6) ) . B9 )) by L14 , SCMFSA_M:2;
L17: ( Comput (( R2 +* C5 ) , D4 , C6) ) = ( Comput (( R3 +* C5 ) , D5 , C6) ) by L16 , L14 , L15 , SCMFSA_2:61;
L18: ( IC ( Comput (( R2 +* C5 ) , D4 , ( C6 + 1 )) ) ) in ( dom C5 ) by L10 , SCMFSA7B:def 6;
L19: ( Comput (( R2 +* C5 ) , D4 , ( C6 + 1 )) ) = ( Following (( R2 +* C5 ) , ( Comput (( R2 +* C5 ) , D4 , C6) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( R2 +* C5 ) , ( Comput (( R2 +* C5 ) , D4 , C6) )) ) , ( Comput (( R2 +* C5 ) , D4 , C6) )) );
L20: ( Comput (( R2 +* C5 ) , D4 , ( C6 + 1 )) ) = ( Comput (( R3 +* C5 ) , D5 , ( C6 + 1 )) ) by L19 , L14 , L17 , L13;
L21: ( IC ( Comput (( R2 +* C5 ) , D4 , ( C6 + 1 )) ) ) = ( IC ( Comput (( R3 +* C5 ) , D5 , ( C6 + 1 )) ) ) by L20;
L22: ( ( R2 +* C5 ) /. ( IC ( Comput (( R2 +* C5 ) , D4 , ( C6 + 1 )) ) ) ) = ( ( R2 +* C5 ) . ( IC ( Comput (( R2 +* C5 ) , D4 , ( C6 + 1 )) ) ) ) by PBOOLE:143;
L23: ( ( R3 +* C5 ) /. ( IC ( Comput (( R3 +* C5 ) , D5 , ( C6 + 1 )) ) ) ) = ( ( R3 +* C5 ) . ( IC ( Comput (( R3 +* C5 ) , D5 , ( C6 + 1 )) ) ) ) by PBOOLE:143;
L24: C5 c= ( R2 +* C5 ) by FUNCT_4:25;
L25: C5 c= ( R3 +* C5 ) by FUNCT_4:25;
L26: ( CurInstr (( R2 +* C5 ) , ( Comput (( R2 +* C5 ) , D4 , ( C6 + 1 )) )) ) = ( C5 . ( IC ( Comput (( R2 +* C5 ) , D4 , ( C6 + 1 )) ) ) ) by L18 , L22 , L24 , GRFUNC_1:2
.= ( CurInstr (( R3 +* C5 ) , ( Comput (( R3 +* C5 ) , D5 , ( C6 + 1 )) )) ) by L21 , L18 , L23 , L25 , GRFUNC_1:2;
thus L27: S1[ ( C6 + 1 ) ] by L26 , L20;
end;
L28: ( ( R2 +* C5 ) /. ( IC ( Comput (( R2 +* C5 ) , D4 , ( 0 )) ) ) ) = ( ( R2 +* C5 ) . ( IC ( Comput (( R2 +* C5 ) , D4 , ( 0 )) ) ) ) by PBOOLE:143;
L29: ( ( R3 +* C5 ) /. ( IC ( Comput (( R3 +* C5 ) , D5 , ( 0 )) ) ) ) = ( ( R3 +* C5 ) . ( IC ( Comput (( R3 +* C5 ) , D5 , ( 0 )) ) ) ) by PBOOLE:143;
L30: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L31: ( IC ( Comput (( R3 +* C5 ) , D5 , ( 0 )) ) ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L30 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L32: ( IC ( Comput (( R2 +* C5 ) , D4 , ( 0 )) ) ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L30 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L33: ( CurInstr (( R2 +* C5 ) , ( Comput (( R2 +* C5 ) , D4 , ( 0 )) )) ) = ( C5 . ( 0 ) ) by L32 , L11 , L28 , FUNCT_4:13
.= ( CurInstr (( R3 +* C5 ) , ( Comput (( R3 +* C5 ) , D5 , ( 0 )) )) ) by L31 , L11 , L29 , FUNCT_4:13;
L34: S1[ ( 0 ) ] by L33 , L32 , L31 , L9;
L35:
now
let C7 being (Element of ( NAT ));
L36: ( IC ( Comput (( R2 +* C5 ) , D4 , C7) ) ) in ( dom C5 ) by L10 , SCMFSA7B:def 6;
L37: (for B10 being (Element of ( NAT )) holds S1[ B10 ]) from NAT_1:sch 1(L34 , L12);
thus L38: ( IC ( Comput (( R3 +* C5 ) , D5 , C7) ) ) in ( dom C5 ) by L37 , L36;
end;
thus L39: thesis by L35 , SCMFSA7B:def 6;
end;
theorem
L40: (for B11 , B12 being (State of ( SCM+FSA )) holds (for B13 , B14 being (Program of ( SCM+FSA )) holds (( DataPart B11 ) = ( DataPart B12 ) implies ( Initialize B11 ) = ( Initialize B12 )))) by MEMSTR_0:80;
theorem
L41: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for R3 being (Instruction-Sequence of ( SCM+FSA )) holds (for B15 , B16 being (State of ( SCM+FSA )) holds (for B17 being (Program of ( SCM+FSA )) holds (( DataPart B15 ) = ( DataPart B16 ) implies ((B17 is_closed_on B15 , R2 & B17 is_halting_on B15 , R2) implies (B17 is_closed_on B16 , R3 & B17 is_halting_on B16 , R3)))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let R3 being (Instruction-Sequence of ( SCM+FSA ));
let C8 , C9 being (State of ( SCM+FSA ));
let C10 being (Program of ( SCM+FSA ));
set D6 = ( Initialize C8 );
set D7 = ( Initialize C9 );
defpred S2[ Nat ] means (( IC ( Comput (( R2 +* C10 ) , D6 , $1) ) ) = ( IC ( Comput (( R3 +* C10 ) , D7 , $1) ) ) & ( CurInstr (( R2 +* C10 ) , ( Comput (( R2 +* C10 ) , D6 , $1) )) ) = ( CurInstr (( R3 +* C10 ) , ( Comput (( R3 +* C10 ) , D7 , $1) )) ) & ( DataPart ( Comput (( R2 +* C10 ) , D6 , $1) ) ) = ( DataPart ( Comput (( R3 +* C10 ) , D7 , $1) ) ));
L42: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L43: ( IC ( Comput (( R2 +* C10 ) , D6 , ( 0 )) ) ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L42 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L44: ( IC ( Comput (( R3 +* C10 ) , D7 , ( 0 )) ) ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L42 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
assume L45: ( DataPart C8 ) = ( DataPart C9 );
L46: ( Comput (( R2 +* C10 ) , D6 , ( 0 )) ) = ( Comput (( R3 +* C10 ) , D7 , ( 0 )) ) by L45 , L40;
assume L47: C10 is_closed_on C8 , R2;
L48:
now
let C11 being (Element of ( NAT ));
L49: ( Comput (( R3 +* C10 ) , D7 , ( C11 + 1 )) ) = ( Following (( R3 +* C10 ) , ( Comput (( R3 +* C10 ) , D7 , C11) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( R3 +* C10 ) , ( Comput (( R3 +* C10 ) , D7 , C11) )) ) , ( Comput (( R3 +* C10 ) , D7 , C11) )) );
assume L50: S2[ C11 ];
L51: (for B18 being FinSeq-Location holds ( ( Comput (( R2 +* C10 ) , D6 , C11) ) . B18 ) = ( ( Comput (( R3 +* C10 ) , D7 , C11) ) . B18 )) by L50 , SCMFSA_M:2;
L52: (for B19 being Int-Location holds ( ( Comput (( R2 +* C10 ) , D6 , C11) ) . B19 ) = ( ( Comput (( R3 +* C10 ) , D7 , C11) ) . B19 )) by L50 , SCMFSA_M:2;
L53: ( Comput (( R2 +* C10 ) , D6 , C11) ) = ( Comput (( R3 +* C10 ) , D7 , C11) ) by L52 , L50 , L51 , SCMFSA_2:61;
L54: ( IC ( Comput (( R2 +* C10 ) , D6 , ( C11 + 1 )) ) ) in ( dom C10 ) by L47 , SCMFSA7B:def 6;
L55: ( Comput (( R2 +* C10 ) , D6 , ( C11 + 1 )) ) = ( Following (( R2 +* C10 ) , ( Comput (( R2 +* C10 ) , D6 , C11) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (( R2 +* C10 ) , ( Comput (( R2 +* C10 ) , D6 , C11) )) ) , ( Comput (( R2 +* C10 ) , D6 , C11) )) );
L56: ( Comput (( R2 +* C10 ) , D6 , ( C11 + 1 )) ) = ( Comput (( R3 +* C10 ) , D7 , ( C11 + 1 )) ) by L55 , L50 , L53 , L49;
L57: ( IC ( Comput (( R2 +* C10 ) , D6 , ( C11 + 1 )) ) ) = ( IC ( Comput (( R3 +* C10 ) , D7 , ( C11 + 1 )) ) ) by L56;
L58: ( ( R2 +* C10 ) /. ( IC ( Comput (( R2 +* C10 ) , D6 , ( C11 + 1 )) ) ) ) = ( ( R2 +* C10 ) . ( IC ( Comput (( R2 +* C10 ) , D6 , ( C11 + 1 )) ) ) ) by PBOOLE:143;
L59: ( ( R3 +* C10 ) /. ( IC ( Comput (( R3 +* C10 ) , D7 , ( C11 + 1 )) ) ) ) = ( ( R3 +* C10 ) . ( IC ( Comput (( R3 +* C10 ) , D7 , ( C11 + 1 )) ) ) ) by PBOOLE:143;
L60: C10 c= ( R2 +* C10 ) by FUNCT_4:25;
L61: C10 c= ( R3 +* C10 ) by FUNCT_4:25;
L62: ( CurInstr (( R2 +* C10 ) , ( Comput (( R2 +* C10 ) , D6 , ( C11 + 1 )) )) ) = ( C10 . ( IC ( Comput (( R2 +* C10 ) , D6 , ( C11 + 1 )) ) ) ) by L54 , L58 , L60 , GRFUNC_1:2
.= ( CurInstr (( R3 +* C10 ) , ( Comput (( R3 +* C10 ) , D7 , ( C11 + 1 )) )) ) by L57 , L54 , L59 , L61 , GRFUNC_1:2;
thus L63: S2[ ( C11 + 1 ) ] by L62 , L56;
end;
assume L64: C10 is_halting_on C8 , R2;
L65: ( R2 +* C10 ) halts_on ( Initialize C8 ) by L64 , SCMFSA7B:def 7;
consider C12 being (Element of ( NAT )) such that L66: ( CurInstr (( R2 +* C10 ) , ( Comput (( R2 +* C10 ) , D6 , C12) )) ) = ( halt ( SCM+FSA ) ) by L65 , EXTPRO_1:29;
L67: ( ( R2 +* C10 ) /. ( IC ( Comput (( R2 +* C10 ) , D6 , ( 0 )) ) ) ) = ( ( R2 +* C10 ) . ( IC ( Comput (( R2 +* C10 ) , D6 , ( 0 )) ) ) ) by PBOOLE:143;
L68: ( ( R3 +* C10 ) /. ( IC ( Comput (( R3 +* C10 ) , D7 , ( 0 )) ) ) ) = ( ( R3 +* C10 ) . ( IC ( Comput (( R3 +* C10 ) , D7 , ( 0 )) ) ) ) by PBOOLE:143;
L69: ( 0 ) in ( dom C10 ) by L47 , L2;
L70: ( CurInstr (( R2 +* C10 ) , ( Comput (( R2 +* C10 ) , D6 , ( 0 )) )) ) = ( C10 . ( 0 ) ) by L69 , L43 , L67 , FUNCT_4:13
.= ( CurInstr (( R3 +* C10 ) , ( Comput (( R3 +* C10 ) , D7 , ( 0 )) )) ) by L44 , L69 , L68 , FUNCT_4:13;
L71: S2[ ( 0 ) ] by L70 , L46;
L72:
now
let C13 being (Element of ( NAT ));
L73: ( IC ( Comput (( R2 +* C10 ) , D6 , C13) ) ) in ( dom C10 ) by L47 , SCMFSA7B:def 6;
L74: (for B20 being (Element of ( NAT )) holds S2[ B20 ]) from NAT_1:sch 1(L71 , L48);
thus L75: ( IC ( Comput (( R3 +* C10 ) , D7 , C13) ) ) in ( dom C10 ) by L74 , L73;
end;
thus L76: C10 is_closed_on C9 , R3 by L72 , SCMFSA7B:def 6;
L77: (for B21 being (Element of ( NAT )) holds S2[ B21 ]) from NAT_1:sch 1(L71 , L48);
L78: ( CurInstr (( R3 +* C10 ) , ( Comput (( R3 +* C10 ) , D7 , C12) )) ) = ( halt ( SCM+FSA ) ) by L77 , L66;
L79: ( R3 +* C10 ) halts_on ( Initialize C9 ) by L78 , EXTPRO_1:29;
thus L80: thesis by L79 , SCMFSA7B:def 7;
end;
theorem
L81: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B22 being (State of ( SCM+FSA )) holds (for B23 , B24 being (Program of ( SCM+FSA )) holds (B23 is_closed_on ( Initialized B22 ) , R1 iff B23 is_closed_on ( B22 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) , ( R1 +* B24 )))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C14 being (State of ( SCM+FSA ));
let C15 , C16 being (Program of ( SCM+FSA ));
L82: ( DataPart ( Initialized C14 ) ) = ( DataPart ( C14 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) );
thus L83: thesis by L82 , L7;
end;
theorem
L84: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B25 being (State of ( SCM+FSA )) holds (for B26 , B27 being (Program of ( SCM+FSA )) holds (for B28 being (Element of ( NAT )) holds (B26 is_closed_on B25 , R1 iff B26 is_closed_on ( B25 +* ( Start-At (( 0 ) , ( SCM+FSA )) ) ) , ( R1 +* B26 ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C17 being (State of ( SCM+FSA ));
let C18 , C19 being (Program of ( SCM+FSA ));
let C20 being (Element of ( NAT ));
L85: ( DataPart C17 ) = ( DataPart ( Initialize C17 ) ) by MEMSTR_0:79;
thus L86: thesis by L85 , L7;
end;
theorem
L87: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for R3 being (Instruction-Sequence of ( SCM+FSA )) holds (for B29 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B30 being (State of ( SCM+FSA )) holds (for B31 being (Program of ( SCM+FSA )) holds ((B31 is_closed_on B29 , R2 & B31 c= R2) implies (for B32 being (Element of ( NAT )) holds ((( IC B30 ) = B32 & ( DataPart B29 ) = ( DataPart B30 ) & ( Reloc (B31 , B32) ) c= R3) implies (for B33 being (Element of ( NAT )) holds (( ( IC ( Comput (R2 , B29 , B33) ) ) + B32 ) = ( IC ( Comput (R3 , B30 , B33) ) ) & ( IncAddr (( CurInstr (R2 , ( Comput (R2 , B29 , B33) )) ) , B32) ) = ( CurInstr (R3 , ( Comput (R3 , B30 , B33) )) ) & ( DataPart ( Comput (R2 , B29 , B33) ) ) = ( DataPart ( Comput (R3 , B30 , B33) ) )))))))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let R3 being (Instruction-Sequence of ( SCM+FSA ));
let C21 being ( 0 ) -started (State of ( SCM+FSA ));
let C22 being (State of ( SCM+FSA ));
let C23 being (Program of ( SCM+FSA ));
L88: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C21 by MEMSTR_0:29;
assume L89: C23 is_closed_on C21 , R2;
assume L90: C23 c= R2;
let C24 being (Element of ( NAT ));
L91: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
defpred S3[ Nat ] means (( ( IC ( Comput (R2 , C21 , $1) ) ) + C24 ) = ( IC ( Comput (R3 , C22 , $1) ) ) & ( IncAddr (( CurInstr (R2 , ( Comput (R2 , C21 , $1) )) ) , C24) ) = ( CurInstr (R3 , ( Comput (R3 , C22 , $1) )) ) & ( DataPart ( Comput (R2 , C21 , $1) ) ) = ( DataPart ( Comput (R3 , C22 , $1) ) ));
L92: ( IC ( Comput (R2 , C21 , ( 0 )) ) ) = ( IC C21 )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L88 , L91 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
assume L93: ( IC C22 ) = C24;
L94: ( 0 ) in ( dom C23 ) by L89 , L2;
L95: ( ( 0 ) + C24 ) in ( dom ( Reloc (C23 , C24) ) ) by L94 , COMPOS_1:46;
L96: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L97: ( R2 . ( IC C21 ) ) = ( R2 . ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) ) by L96 , L88 , GRFUNC_1:2
.= ( R2 . ( 0 ) ) by FUNCOP_1:72
.= ( C23 . ( 0 ) ) by L94 , L90 , GRFUNC_1:2;
assume L98: ( DataPart C21 ) = ( DataPart C22 );
L99: ( DataPart ( Comput (R2 , C21 , ( 0 )) ) ) = ( DataPart C22 ) by L98
.= ( DataPart ( Comput (R3 , C22 , ( 0 )) ) );
assume L100: ( Reloc (C23 , C24) ) c= R3;
let C25 being (Element of ( NAT ));
L101: ( R3 /. ( IC C22 ) ) = ( R3 . ( IC C22 ) ) by PBOOLE:143;
L102: ( CurInstr (R2 , C21) ) = ( C23 . ( 0 ) ) by L97 , PBOOLE:143;
L103: ( IncAddr (( CurInstr (R2 , ( Comput (R2 , C21 , ( 0 )) )) ) , C24) ) = ( IncAddr (( CurInstr (R2 , C21) ) , C24) )
.= ( ( Reloc (C23 , C24) ) . ( ( 0 ) + C24 ) ) by L102 , L94 , COMPOS_1:35
.= ( CurInstr (R3 , C22) ) by L93 , L95 , L101 , L100 , GRFUNC_1:2
.= ( CurInstr (R3 , ( Comput (R3 , C22 , ( 0 )) )) );
L104: S3[ ( 0 ) ] by L103 , L93 , L92 , L99;
L105: (for B34 being (Element of ( NAT )) holds (S3[ B34 ] implies S3[ ( B34 + 1 ) ]))
proof
let C26 being (Element of ( NAT ));
L106: ( Comput (R2 , C21 , ( C26 + 1 )) ) = ( Following (R2 , ( Comput (R2 , C21 , C26) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R2 , ( Comput (R2 , C21 , C26) )) ) , ( Comput (R2 , C21 , C26) )) );
reconsider D8 = ( IC ( Comput (R2 , C21 , ( C26 + 1 )) ) ) as (Element of ( NAT ));
reconsider D9 = ( CurInstr (R2 , ( Comput (R2 , C21 , ( C26 + 1 )) )) ) as (Instruction of ( SCM+FSA ));
L107: ( Comput (R3 , C22 , ( C26 + 1 )) ) = ( Following (R3 , ( Comput (R3 , C22 , C26) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R3 , ( Comput (R3 , C22 , C26) )) ) , ( Comput (R3 , C22 , C26) )) );
L108: ( Initialize C21 ) = C21 by L88 , FUNCT_4:98;
L109: R2 = ( R2 +* C23 ) by L90 , FUNCT_4:98;
L110: ( IC ( Comput (R2 , C21 , ( C26 + 1 )) ) ) in ( dom C23 ) by L109 , L89 , L108 , SCMFSA7B:def 6;
assume L111: S3[ C26 ];
thus L112: ( ( IC ( Comput (R2 , C21 , ( C26 + 1 )) ) ) + C24 ) = ( IC ( Comput (R3 , C22 , ( C26 + 1 )) ) ) by L111 , L106 , L107 , SCMFSA6A:8;
L113: ( IC ( Comput (R3 , C22 , ( C26 + 1 )) ) ) in ( dom ( Reloc (C23 , C24) ) ) by L112 , L110 , COMPOS_1:46;
L114: D8 in ( dom C23 ) by L108 , L89 , L109 , SCMFSA7B:def 6;
L115: D9 = ( R2 . ( IC ( Comput (R2 , C21 , ( C26 + 1 )) ) ) ) by PBOOLE:143
.= ( C23 . D8 ) by L110 , L90 , GRFUNC_1:2;
thus L116: ( IncAddr (( CurInstr (R2 , ( Comput (R2 , C21 , ( C26 + 1 )) )) ) , C24) ) = ( ( Reloc (C23 , C24) ) . ( D8 + C24 ) ) by L115 , L114 , COMPOS_1:35
.= ( R3 . ( IC ( Comput (R3 , C22 , ( C26 + 1 )) ) ) ) by L113 , L112 , L100 , GRFUNC_1:2
.= ( CurInstr (R3 , ( Comput (R3 , C22 , ( C26 + 1 )) )) ) by PBOOLE:143;
thus L117: thesis by L111 , L106 , L107 , SCMFSA6A:8;
end;
L118: (for B35 being (Element of ( NAT )) holds S3[ B35 ]) from NAT_1:sch 1(L104 , L105);
thus L119: thesis by L118;
end;
theorem
L120: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B36 being (State of ( SCM+FSA )) holds (for B37 being  keeping_0  parahalting (Instruction of ( SCM+FSA )) holds (for B38 being  parahalting (Program of ( SCM+FSA )) holds (for B39 being Int-Location holds ( ( IExec (( B37 ";" B38 ) , R1 , B36) ) . B39 ) = ( ( IExec (B38 , R1 , ( Exec (B37 , ( Initialized B36 )) )) ) . B39 ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C27 being (State of ( SCM+FSA ));
let C28 being  keeping_0  parahalting (Instruction of ( SCM+FSA ));
let C29 being  parahalting (Program of ( SCM+FSA ));
let C30 being Int-Location;
L121: ( IExec (( Macro C28 ) , R1 , C27) ) = ( Exec (C28 , ( Initialized C27 )) ) by SCMFSA6C:5;
thus L122: ( ( IExec (( C28 ";" C29 ) , R1 , C27) ) . C30 ) = ( ( IExec (C29 , R1 , ( IExec (( Macro C28 ) , R1 , C27) )) ) . C30 ) by SCMFSA6C:1
.= ( ( IExec (C29 , R1 , ( IExec (( Macro C28 ) , R1 , C27) )) ) . C30 )
.= ( ( IExec (C29 , R1 , ( Exec (C28 , ( Initialized C27 )) )) ) . C30 ) by L121
.= ( ( IExec (C29 , R1 , ( Exec (C28 , ( Initialized C27 )) )) ) . C30 );
end;
theorem
L123: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B40 being (State of ( SCM+FSA )) holds (for B41 being  keeping_0  parahalting (Instruction of ( SCM+FSA )) holds (for B42 being  parahalting (Program of ( SCM+FSA )) holds (for B43 being FinSeq-Location holds ( ( IExec (( B41 ";" B42 ) , R1 , B40) ) . B43 ) = ( ( IExec (B42 , R1 , ( Exec (B41 , ( Initialized B40 )) )) ) . B43 ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C31 being (State of ( SCM+FSA ));
let C32 being  keeping_0  parahalting (Instruction of ( SCM+FSA ));
let C33 being  parahalting (Program of ( SCM+FSA ));
let C34 being FinSeq-Location;
L124: ( IExec (( Macro C32 ) , R1 , C31) ) = ( Exec (C32 , ( Initialized C31 )) ) by SCMFSA6C:5;
thus L125: ( ( IExec (( C32 ";" C33 ) , R1 , C31) ) . C34 ) = ( ( IExec (C33 , R1 , ( IExec (( Macro C32 ) , R1 , C31) )) ) . C34 ) by SCMFSA6C:2
.= ( ( IExec (C33 , R1 , ( IExec (( Macro C32 ) , R1 , C31) )) ) . C34 )
.= ( ( IExec (C33 , R1 , ( Exec (C32 , ( Initialized C31 )) )) ) . C34 ) by L124
.= ( ( IExec (C33 , R1 , ( Exec (C32 , ( Initialized C31 )) )) ) . C34 );
end;
definition
let C35 being Int-Location;
let C36 , C37 being (Program of ( SCM+FSA ));
func if=0 (C35 , C36 , C37) -> (Program of ( SCM+FSA )) equals 
( ( ( ( ( C35 =0_goto ( ( card C37 ) + 3 ) ) ";" C37 ) ";" ( Goto ( ( card C36 ) + 1 ) ) ) ";" C36 ) ";" ( Stop ( SCM+FSA ) ) );
coherence;
func if>0 (C35 , C36 , C37) -> (Program of ( SCM+FSA )) equals 
( ( ( ( ( C35 >0_goto ( ( card C37 ) + 3 ) ) ";" C37 ) ";" ( Goto ( ( card C36 ) + 1 ) ) ) ";" C36 ) ";" ( Stop ( SCM+FSA ) ) );
coherence;
end;
definition
let C38 being Int-Location;
let C39 , C40 being (Program of ( SCM+FSA ));
func if<0 (C38 , C39 , C40) -> (Program of ( SCM+FSA )) equals 
( if=0 (C38 , C40 , ( if>0 (C38 , C40 , C39) )) );
coherence;
end;
L128: (for B44 being Int-Location holds (for B45 , B46 being (Program of ( SCM+FSA )) holds (( 0 ) in ( dom ( if=0 (B44 , B45 , B46) ) ) & 1 in ( dom ( if=0 (B44 , B45 , B46) ) ) & ( 0 ) in ( dom ( if>0 (B44 , B45 , B46) ) ) & 1 in ( dom ( if>0 (B44 , B45 , B46) ) ))))
proof
let C41 being Int-Location;
let C42 , C43 being (Program of ( SCM+FSA ));
set D10 = ( C41 =0_goto ( ( card C43 ) + 3 ) );
L129: ( if=0 (C41 , C42 , C43) ) = ( ( ( D10 ";" C43 ) ";" ( Goto ( ( card C42 ) + 1 ) ) ) ";" ( C42 ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:25
.= ( ( D10 ";" C43 ) ";" ( ( Goto ( ( card C42 ) + 1 ) ) ";" ( C42 ";" ( Stop ( SCM+FSA ) ) ) ) ) by SCMFSA6A:25
.= ( D10 ";" ( C43 ";" ( ( Goto ( ( card C42 ) + 1 ) ) ";" ( C42 ";" ( Stop ( SCM+FSA ) ) ) ) ) ) by SCMFSA6A:29
.= ( ( Macro D10 ) ";" ( C43 ";" ( ( Goto ( ( card C42 ) + 1 ) ) ";" ( C42 ";" ( Stop ( SCM+FSA ) ) ) ) ) );
L130: ( dom ( Macro D10 ) ) c= ( dom ( if=0 (C41 , C42 , C43) ) ) by L129 , SCMFSA6A:17;
L131: ( dom ( Macro D10 ) ) = { ( 0 ) , 1 } by COMPOS_1:61;
L132: 1 in ( dom ( Macro D10 ) ) by L131 , TARSKI:def 2;
L133: ( 0 ) in ( dom ( Macro D10 ) ) by L131 , TARSKI:def 2;
thus L134: (( 0 ) in ( dom ( if=0 (C41 , C42 , C43) ) ) & 1 in ( dom ( if=0 (C41 , C42 , C43) ) )) by L133 , L130 , L132;
set D11 = ( C41 >0_goto ( ( card C43 ) + 3 ) );
L135: ( if>0 (C41 , C42 , C43) ) = ( ( ( D11 ";" C43 ) ";" ( Goto ( ( card C42 ) + 1 ) ) ) ";" ( C42 ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:25
.= ( ( D11 ";" C43 ) ";" ( ( Goto ( ( card C42 ) + 1 ) ) ";" ( C42 ";" ( Stop ( SCM+FSA ) ) ) ) ) by SCMFSA6A:25
.= ( D11 ";" ( C43 ";" ( ( Goto ( ( card C42 ) + 1 ) ) ";" ( C42 ";" ( Stop ( SCM+FSA ) ) ) ) ) ) by SCMFSA6A:29
.= ( ( Macro D11 ) ";" ( C43 ";" ( ( Goto ( ( card C42 ) + 1 ) ) ";" ( C42 ";" ( Stop ( SCM+FSA ) ) ) ) ) );
L136: ( dom ( Macro D11 ) ) c= ( dom ( if>0 (C41 , C42 , C43) ) ) by L135 , SCMFSA6A:17;
L137: ( dom ( Macro D11 ) ) = { ( 0 ) , 1 } by COMPOS_1:61;
L138: 1 in ( dom ( Macro D11 ) ) by L137 , TARSKI:def 2;
L139: ( 0 ) in ( dom ( Macro D11 ) ) by L137 , TARSKI:def 2;
thus L140: thesis by L139 , L136 , L138;
end;
L141: (for B47 being Int-Location holds (for B48 , B49 being (Program of ( SCM+FSA )) holds (( ( if=0 (B47 , B48 , B49) ) . ( 0 ) ) = ( B47 =0_goto ( ( card B49 ) + 3 ) ) & ( ( if=0 (B47 , B48 , B49) ) . 1 ) = ( goto 2 ) & ( ( if>0 (B47 , B48 , B49) ) . ( 0 ) ) = ( B47 >0_goto ( ( card B49 ) + 3 ) ) & ( ( if>0 (B47 , B48 , B49) ) . 1 ) = ( goto 2 ))))
proof
let C44 being Int-Location;
let C45 , C46 being (Program of ( SCM+FSA ));
set D12 = ( C44 =0_goto ( ( card C46 ) + 3 ) );
L142: ( if=0 (C44 , C45 , C46) ) = ( ( ( D12 ";" C46 ) ";" ( Goto ( ( card C45 ) + 1 ) ) ) ";" ( C45 ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:25
.= ( ( D12 ";" C46 ) ";" ( ( Goto ( ( card C45 ) + 1 ) ) ";" ( C45 ";" ( Stop ( SCM+FSA ) ) ) ) ) by SCMFSA6A:25
.= ( D12 ";" ( C46 ";" ( ( Goto ( ( card C45 ) + 1 ) ) ";" ( C45 ";" ( Stop ( SCM+FSA ) ) ) ) ) ) by SCMFSA6A:29
.= ( ( Macro D12 ) ";" ( C46 ";" ( ( Goto ( ( card C45 ) + 1 ) ) ";" ( C45 ";" ( Stop ( SCM+FSA ) ) ) ) ) );
L143: ( dom ( Macro D12 ) ) = { ( 0 ) , 1 } by COMPOS_1:61;
L144: ( 0 ) in ( dom ( Macro D12 ) ) by L143 , TARSKI:def 2;
thus L145: ( ( if=0 (C44 , C45 , C46) ) . ( 0 ) ) = ( ( Directed ( Macro D12 ) ) . ( 0 ) ) by L144 , L142 , SCMFSA8A:14
.= D12 by SCMFSA7B:1;
L146: 1 in ( dom ( Macro D12 ) ) by L143 , TARSKI:def 2;
thus L147: ( ( if=0 (C44 , C45 , C46) ) . 1 ) = ( ( Directed ( Macro D12 ) ) . 1 ) by L146 , L142 , SCMFSA8A:14
.= ( goto 2 ) by SCMFSA7B:2;
set D13 = ( C44 >0_goto ( ( card C46 ) + 3 ) );
L148: ( if>0 (C44 , C45 , C46) ) = ( ( ( D13 ";" C46 ) ";" ( Goto ( ( card C45 ) + 1 ) ) ) ";" ( C45 ";" ( Stop ( SCM+FSA ) ) ) ) by SCMFSA6A:25
.= ( ( D13 ";" C46 ) ";" ( ( Goto ( ( card C45 ) + 1 ) ) ";" ( C45 ";" ( Stop ( SCM+FSA ) ) ) ) ) by SCMFSA6A:25
.= ( D13 ";" ( C46 ";" ( ( Goto ( ( card C45 ) + 1 ) ) ";" ( C45 ";" ( Stop ( SCM+FSA ) ) ) ) ) ) by SCMFSA6A:29
.= ( ( Macro D13 ) ";" ( C46 ";" ( ( Goto ( ( card C45 ) + 1 ) ) ";" ( C45 ";" ( Stop ( SCM+FSA ) ) ) ) ) );
L149: ( dom ( Macro D13 ) ) = { ( 0 ) , 1 } by COMPOS_1:61;
L150: ( 0 ) in ( dom ( Macro D13 ) ) by L149 , TARSKI:def 2;
thus L151: ( ( if>0 (C44 , C45 , C46) ) . ( 0 ) ) = ( ( Directed ( Macro D13 ) ) . ( 0 ) ) by L150 , L148 , SCMFSA8A:14
.= D13 by SCMFSA7B:1;
L152: 1 in ( dom ( Macro D13 ) ) by L149 , TARSKI:def 2;
thus L153: ( ( if>0 (C44 , C45 , C46) ) . 1 ) = ( ( Directed ( Macro D13 ) ) . 1 ) by L152 , L148 , SCMFSA8A:14
.= ( goto 2 ) by SCMFSA7B:2;
end;
theorem
L154: (for B50 , B51 being (Program of ( SCM+FSA )) holds (for B52 being Int-Location holds ( card ( if=0 (B52 , B50 , B51) ) ) = ( ( ( card B50 ) + ( card B51 ) ) + 4 )))
proof
let C47 , C48 being (Program of ( SCM+FSA ));
let C49 being Int-Location;
L155: ( card ( Stop ( SCM+FSA ) ) ) = 1 by COMPOS_1:4;
thus L156: ( card ( if=0 (C49 , C47 , C48) ) ) = ( ( card ( ( ( ( Macro ( C49 =0_goto ( ( card C48 ) + 3 ) ) ) ";" C48 ) ";" ( Goto ( ( card C47 ) + 1 ) ) ) ";" C47 ) ) + 1 ) by L155 , SCMFSA6A:21
.= ( ( ( card ( ( ( Macro ( C49 =0_goto ( ( card C48 ) + 3 ) ) ) ";" C48 ) ";" ( Goto ( ( card C47 ) + 1 ) ) ) ) + ( card C47 ) ) + 1 ) by SCMFSA6A:21
.= ( ( ( ( card ( ( Macro ( C49 =0_goto ( ( card C48 ) + 3 ) ) ) ";" C48 ) ) + ( card ( Goto ( ( card C47 ) + 1 ) ) ) ) + ( card C47 ) ) + 1 ) by SCMFSA6A:21
.= ( ( ( ( card ( ( Macro ( C49 =0_goto ( ( card C48 ) + 3 ) ) ) ";" C48 ) ) + 1 ) + ( card C47 ) ) + 1 ) by SCMFSA8A:15
.= ( ( ( ( ( card ( Macro ( C49 =0_goto ( ( card C48 ) + 3 ) ) ) ) + ( card C48 ) ) + 1 ) + ( card C47 ) ) + 1 ) by SCMFSA6A:21
.= ( ( ( ( 2 + ( card C48 ) ) + 1 ) + ( card C47 ) ) + 1 ) by COMPOS_1:56
.= ( ( ( card C47 ) + ( card C48 ) ) + 4 );
end;
theorem
L157: (for B53 , B54 being (Program of ( SCM+FSA )) holds (for B55 being Int-Location holds ( card ( if>0 (B55 , B53 , B54) ) ) = ( ( ( card B53 ) + ( card B54 ) ) + 4 )))
proof
let C50 , C51 being (Program of ( SCM+FSA ));
let C52 being Int-Location;
L158: ( card ( Stop ( SCM+FSA ) ) ) = 1 by COMPOS_1:4;
thus L159: ( card ( if>0 (C52 , C50 , C51) ) ) = ( ( card ( ( ( ( Macro ( C52 >0_goto ( ( card C51 ) + 3 ) ) ) ";" C51 ) ";" ( Goto ( ( card C50 ) + 1 ) ) ) ";" C50 ) ) + 1 ) by L158 , SCMFSA6A:21
.= ( ( ( card ( ( ( Macro ( C52 >0_goto ( ( card C51 ) + 3 ) ) ) ";" C51 ) ";" ( Goto ( ( card C50 ) + 1 ) ) ) ) + ( card C50 ) ) + 1 ) by SCMFSA6A:21
.= ( ( ( ( card ( ( Macro ( C52 >0_goto ( ( card C51 ) + 3 ) ) ) ";" C51 ) ) + ( card ( Goto ( ( card C50 ) + 1 ) ) ) ) + ( card C50 ) ) + 1 ) by SCMFSA6A:21
.= ( ( ( ( card ( ( Macro ( C52 >0_goto ( ( card C51 ) + 3 ) ) ) ";" C51 ) ) + 1 ) + ( card C50 ) ) + 1 ) by SCMFSA8A:15
.= ( ( ( ( ( card ( Macro ( C52 >0_goto ( ( card C51 ) + 3 ) ) ) ) + ( card C51 ) ) + 1 ) + ( card C50 ) ) + 1 ) by SCMFSA6A:21
.= ( ( ( ( 2 + ( card C51 ) ) + 1 ) + ( card C50 ) ) + 1 ) by COMPOS_1:56
.= ( ( ( card C50 ) + ( card C51 ) ) + 4 );
end;
theorem
L160: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B56 being (State of ( SCM+FSA )) holds (for B57 , B58 being (Program of ( SCM+FSA )) holds (for B59 being  read-write Int-Location holds ((( B56 . B59 ) = ( 0 ) & B57 is_closed_on B56 , R1 & B57 is_halting_on B56 , R1) implies (( if=0 (B59 , B57 , B58) ) is_closed_on B56 , R1 & ( if=0 (B59 , B57 , B58) ) is_halting_on B56 , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C53 being (State of ( SCM+FSA ));
let C54 , C55 being (Program of ( SCM+FSA ));
let C56 being  read-write Int-Location;
set D14 = ( C54 ";" ( Stop ( SCM+FSA ) ) );
set D15 = ( Initialize C53 );
set D16 = ( R1 +* D14 );
set D17 = ( Initialize C53 );
set D18 = ( R1 +* ( if=0 (C56 , C54 , C55) ) );
set D19 = ( Comput (( R1 +* ( if=0 (C56 , C54 , C55) ) ) , D17 , 1) );
set D20 = ( C56 =0_goto ( ( card C55 ) + 3 ) );
L161: (not C56 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L162: ( 0 ) in ( dom ( if=0 (C56 , C54 , C55) ) ) by L128;
L163: ( D18 . ( 0 ) ) = ( ( if=0 (C56 , C54 , C55) ) . ( 0 ) ) by L162 , FUNCT_4:13
.= D20 by L141;
L164: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L165: ( IC D17 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L164 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L166: ( if=0 (C56 , C54 , C55) ) c= D18 by FUNCT_4:25;
L167: ( if=0 (C56 , C54 , C55) ) = ( ( ( D20 ";" C55 ) ";" ( Goto ( ( card C54 ) + 1 ) ) ) ";" D14 ) by SCMFSA6A:25;
L168: ( card ( ( D20 ";" C55 ) ";" ( Goto ( ( card C54 ) + 1 ) ) ) ) = ( ( card ( ( Macro D20 ) ";" C55 ) ) + ( card ( Goto ( ( card C54 ) + 1 ) ) ) ) by SCMFSA6A:21
.= ( ( card ( ( Macro D20 ) ";" C55 ) ) + 1 ) by SCMFSA8A:15
.= ( ( ( card ( Macro D20 ) ) + ( card C55 ) ) + 1 ) by SCMFSA6A:21
.= ( ( ( card C55 ) + 2 ) + 1 ) by COMPOS_1:56
.= ( ( card C55 ) + ( 2 + 1 ) );
L169: ( Reloc (D14 , ( ( card C55 ) + 3 )) ) c= ( if=0 (C56 , C54 , C55) ) by L168 , L167 , L1;
L170: ( Reloc (D14 , ( ( card C55 ) + 3 )) ) c= D18 by L169 , L166 , XBOOLE_1:1;
L171: ( Comput (D18 , D17 , ( ( 0 ) + 1 )) ) = ( Following (D18 , ( Comput (D18 , D17 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D18 , D17) )
.= ( Exec (D20 , D17) ) by L165 , L163 , PBOOLE:143;
L172: (for B60 being FinSeq-Location holds ( D15 . B60 ) = ( D19 . B60 )) by L171 , SCMFSA_2:70;
L173: (for B61 being Int-Location holds ( D15 . B61 ) = ( D19 . B61 )) by L171 , SCMFSA_2:70;
L174: ( DataPart D15 ) = ( DataPart D19 ) by L173 , L172 , SCMFSA_M:2;
assume L175: ( C53 . C56 ) = ( 0 );
L176: ( D17 . C56 ) = ( 0 ) by L175 , L161 , FUNCT_4:11;
L177: ( IC ( Comput (D18 , D17 , 1) ) ) = ( ( card C55 ) + 3 ) by L176 , L171 , SCMFSA_2:70;
assume L178: C54 is_closed_on C53 , R1;
assume L179: C54 is_halting_on C53 , R1;
L180: D14 is_closed_on C53 , R1 by L179 , L178 , SCMFSA8A:30;
L181: D14 is_halting_on C53 , R1 by L178 , L179 , SCMFSA8A:30;
L182: D16 halts_on D15 by L181 , SCMFSA7B:def 7;
L183: ( DataPart C53 ) = ( DataPart D15 ) by MEMSTR_0:79;
L184: D14 is_closed_on D15 , D16 by L183 , L180 , L7;
L185: D14 c= D16 by FUNCT_4:25;
L186:
now
let C57 being (Element of ( NAT ));
per cases ;
suppose L187: ( 0 ) < C57;

consider C58 being Nat such that L188: ( C58 + 1 ) = C57 by L187 , NAT_1:6;
reconsider D21 = C58 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D22 = ( IC ( Comput (D16 , D15 , D21) ) ) as (Element of ( NAT ));
L189: D22 in ( dom D14 ) by L180 , SCMFSA7B:def 6;
L190: D22 < ( card D14 ) by L189 , AFINSQ_1:66;
L191: ( card ( Stop ( SCM+FSA ) ) ) = 1 by COMPOS_1:4;
L192: ( card D14 ) = ( ( card C54 ) + 1 ) by L191 , SCMFSA6A:21;
L193: ( card ( if=0 (C56 , C54 , C55) ) ) = ( ( ( card C54 ) + ( card C55 ) ) + 4 ) by L154
.= ( ( ( card C55 ) + 3 ) + ( card D14 ) ) by L192;
L194: ( D22 + ( ( card C55 ) + 3 ) ) < ( card ( if=0 (C56 , C54 , C55) ) ) by L193 , L190 , XREAL_1:6;
L195: ( IC ( Comput (D18 , D17 , C57) ) ) = ( IC ( Comput (D18 , D19 , D21) ) ) by L188 , EXTPRO_1:4
.= ( D22 + ( ( card C55 ) + 3 ) ) by L184 , L177 , L174 , L87 , L185 , L170;
thus L196: ( IC ( Comput (D18 , D17 , C57) ) ) in ( dom ( if=0 (C56 , C54 , C55) ) ) by L195 , L194 , AFINSQ_1:66;
end;
suppose L197: C57 = ( 0 );

thus L198: ( IC ( Comput (D18 , D17 , C57) ) ) in ( dom ( if=0 (C56 , C54 , C55) ) ) by L197 , L162 , L165 , EXTPRO_1:2;
end;
end;
thus L200: ( if=0 (C56 , C54 , C55) ) is_closed_on C53 , R1 by L186 , SCMFSA7B:def 6;
L201: ( CurInstr (D18 , ( Comput (D18 , D17 , ( ( LifeSpan (D16 , D15) ) + 1 )) )) ) = ( CurInstr (D18 , ( Comput (D18 , D19 , ( LifeSpan (D16 , D15) )) )) ) by EXTPRO_1:4
.= ( IncAddr (( CurInstr (D16 , ( Comput (D16 , D15 , ( LifeSpan (D16 , D15) )) )) ) , ( ( card C55 ) + 3 )) ) by L184 , L177 , L174 , L87 , L170 , L185
.= ( IncAddr (( halt ( SCM+FSA ) ) , ( ( card C55 ) + 3 )) ) by L182 , EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
L202: D18 halts_on D17 by L201 , EXTPRO_1:29;
thus L203: thesis by L202 , SCMFSA7B:def 7;
end;
theorem
L204: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B62 being (State of ( SCM+FSA )) holds (for B63 , B64 being (Program of ( SCM+FSA )) holds (for B65 being  read-write Int-Location holds ((( B62 . B65 ) = ( 0 ) & B63 is_closed_on ( Initialized B62 ) , R1 & B63 is_halting_on ( Initialized B62 ) , R1) implies ( IExec (( if=0 (B65 , B63 , B64) ) , R1 , B62) ) = ( ( IExec (B63 , R1 , B62) ) +* ( Start-At (( ( ( card B63 ) + ( card B64 ) ) + 3 ) , ( SCM+FSA )) ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C59 being (State of ( SCM+FSA ));
let C60 , C61 being (Program of ( SCM+FSA ));
let C62 being  read-write Int-Location;
set D23 = ( C60 ";" ( Stop ( SCM+FSA ) ) );
set D24 = ( Initialized C59 );
set D25 = ( R1 +* D23 );
set D26 = ( R1 +* ( if=0 (C62 , C60 , C61) ) );
L205: D23 c= D25 by FUNCT_4:25;
set D27 = ( Comput (D26 , D24 , 1) );
set D28 = ( C62 =0_goto ( ( card C61 ) + 3 ) );
L206: ( if=0 (C62 , C60 , C61) ) = ( ( ( D28 ";" C61 ) ";" ( Goto ( ( card C60 ) + 1 ) ) ) ";" D23 ) by SCMFSA6A:25;
L207: ( 0 ) in ( dom ( if=0 (C62 , C60 , C61) ) ) by L128;
L208: ( D26 . ( 0 ) ) = ( ( if=0 (C62 , C60 , C61) ) . ( 0 ) ) by L207 , FUNCT_4:13
.= D28 by L141;
L209: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = { ( intloc ( 0 ) ) , ( IC ( SCM+FSA ) ) } by SCMFSA_M:11;
L210: (C62 <> ( intloc ( 0 ) ) & C62 <> ( IC ( SCM+FSA ) )) by SCMFSA_2:56;
L211: (not C62 in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) by L210 , L209 , TARSKI:def 2;
L212: ( IC ( SCM+FSA ) ) in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by MEMSTR_0:48;
L213: ( IC D24 ) = ( IC ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L212 , FUNCT_4:13
.= ( 0 ) by MEMSTR_0:def 11;
L214: ( Comput (D26 , D24 , ( ( 0 ) + 1 )) ) = ( Following (D26 , ( Comput (D26 , D24 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D26 , D24) )
.= ( Exec (D28 , D24) ) by L213 , L208 , PBOOLE:143;
L215: ( if=0 (C62 , C60 , C61) ) c= D26 by FUNCT_4:25;
assume L216: ( C59 . C62 ) = ( 0 );
L217: ( D24 . C62 ) = ( 0 ) by L216 , L211 , FUNCT_4:11;
L218: ( IC ( Comput (D26 , D24 , 1) ) ) = ( ( card C61 ) + 3 ) by L217 , L214 , SCMFSA_2:70;
L219: (for B66 being FinSeq-Location holds ( D24 . B66 ) = ( D27 . B66 )) by L214 , SCMFSA_2:70;
L220: (for B67 being Int-Location holds ( D24 . B67 ) = ( D27 . B67 )) by L214 , SCMFSA_2:70;
L221: ( DataPart D24 ) = ( DataPart D27 ) by L220 , L219 , SCMFSA_M:2;
L222: ( card ( ( D28 ";" C61 ) ";" ( Goto ( ( card C60 ) + 1 ) ) ) ) = ( ( card ( ( Macro D28 ) ";" C61 ) ) + ( card ( Goto ( ( card C60 ) + 1 ) ) ) ) by SCMFSA6A:21
.= ( ( card ( ( Macro D28 ) ";" C61 ) ) + 1 ) by SCMFSA8A:15
.= ( ( ( card ( Macro D28 ) ) + ( card C61 ) ) + 1 ) by SCMFSA6A:21
.= ( ( ( card C61 ) + 2 ) + 1 ) by COMPOS_1:56
.= ( ( card C61 ) + ( 2 + 1 ) );
L223: ( Reloc (D23 , ( ( card C61 ) + 3 )) ) c= ( if=0 (C62 , C60 , C61) ) by L222 , L206 , L1;
L224: ( Reloc (D23 , ( ( card C61 ) + 3 )) ) c= D26 by L223 , L215 , XBOOLE_1:1;
assume L225: C60 is_closed_on ( Initialized C59 ) , R1;
assume L226: C60 is_halting_on ( Initialized C59 ) , R1;
L227: D25 halts_on D24 by L226 , L225 , SCMFSA8A:34;
L228: D23 is_closed_on ( Initialized C59 ) , R1 by L225 , L226 , SCMFSA8A:30;
L229: D23 is_closed_on D24 , D25 by L228 , L81;
L230: ( CurInstr (D26 , ( Comput (D26 , D24 , ( ( LifeSpan (D25 , D24) ) + 1 )) )) ) = ( CurInstr (D26 , ( Comput (D26 , D27 , ( LifeSpan (D25 , D24) )) )) ) by EXTPRO_1:4
.= ( IncAddr (( CurInstr (D25 , ( Comput (D25 , D24 , ( LifeSpan (D25 , D24) )) )) ) , ( ( card C61 ) + 3 )) ) by L229 , L218 , L221 , L87 , L224 , L205
.= ( IncAddr (( halt ( SCM+FSA ) ) , ( ( card C61 ) + 3 )) ) by L227 , EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
L231: D26 halts_on D24 by L230 , EXTPRO_1:29;
L232:
now
let C63 being (Element of ( NAT ));
assume L233: C63 < ( ( LifeSpan (D25 , D24) ) + 1 );
L234: ( Comput (D26 , D24 , ( 0 )) ) = D24;
per cases ;
suppose L235: C63 = ( 0 );

thus L236: ( CurInstr (D26 , ( Comput (D26 , D24 , C63) )) ) <> ( halt ( SCM+FSA ) ) by L235 , L213 , L208 , L234 , PBOOLE:143;
end;
suppose L237: C63 <> ( 0 );

consider C64 being Nat such that L238: C63 = ( C64 + 1 ) by L237 , NAT_1:6;
assume L239: ( CurInstr (D26 , ( Comput (D26 , D24 , C63) )) ) = ( halt ( SCM+FSA ) );
reconsider D29 = C64 as (Element of ( NAT )) by ORDINAL1:def 12;
L240: ( InsCode ( halt ( SCM+FSA ) ) ) = ( 0 ) by COMPOS_1:70;
L241: ( InsCode ( CurInstr (D25 , ( Comput (D25 , D24 , D29) )) ) ) = ( InsCode ( IncAddr (( CurInstr (D25 , ( Comput (D25 , D24 , D29) )) ) , ( ( card C61 ) + 3 )) ) ) by COMPOS_0:def 9
.= ( InsCode ( CurInstr (D26 , ( Comput (D26 , D27 , D29) )) ) ) by L229 , L218 , L221 , L87 , L224 , L205
.= ( 0 ) by L238 , L239 , EXTPRO_1:4 , L240;
L242: ( CurInstr (D25 , ( Comput (D25 , D24 , D29) )) ) = ( halt ( SCM+FSA ) ) by L241 , SCMFSA_2:95;
L243: D29 < ( LifeSpan (D25 , D24) ) by L233 , L238 , XREAL_1:6;
thus L244: contradiction by L243 , L227 , L242 , EXTPRO_1:def 15;
end;
end;
L246: (for B68 being (Element of ( NAT )) holds (( CurInstr (D26 , ( Comput (D26 , D24 , B68) )) ) = ( halt ( SCM+FSA ) ) implies ( ( LifeSpan (D25 , D24) ) + 1 ) <= B68)) by L232;
L247: ( LifeSpan (D26 , D24) ) = ( ( LifeSpan (D25 , D24) ) + 1 ) by L246 , L230 , L231 , EXTPRO_1:def 15;
L248: ( DataPart ( Result (D25 , D24) ) ) = ( DataPart ( Comput (D25 , D24 , ( LifeSpan (D25 , D24) )) ) ) by L225 , L226 , EXTPRO_1:23 , SCMFSA8A:34
.= ( DataPart ( Comput (D26 , D27 , ( LifeSpan (D25 , D24) )) ) ) by L229 , L218 , L221 , L87 , L205 , L224
.= ( DataPart ( Comput (D26 , D24 , ( ( LifeSpan (D25 , D24) ) + 1 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (D26 , D24) ) ) by L231 , L247 , EXTPRO_1:23;
L249:
now
let C65 being set;
L250: ( IExec (D23 , R1 , C59) ) = ( Result (D25 , D24) ) by SCMFSA6B:def 1;
L251: ( dom ( Start-At (( ( ( card C60 ) + ( card C61 ) ) + 3 ) , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L252: ( IExec (( if=0 (C62 , C60 , C61) ) , R1 , C59) ) = ( Result (D26 , D24) ) by SCMFSA6B:def 1;
assume L253: C65 in ( dom ( IExec (( if=0 (C62 , C60 , C61) ) , R1 , C59) ) );
per cases  by L253 , SCMFSA_M:1;
suppose L254: C65 is Int-Location;

L255: C65 <> ( IC ( SCM+FSA ) ) by L254 , SCMFSA_2:56;
L256: (not C65 in ( dom ( Start-At (( ( ( card C60 ) + ( card C61 ) ) + 3 ) , ( SCM+FSA )) ) )) by L255 , L251 , TARSKI:def 1;
thus L257: ( ( IExec (( if=0 (C62 , C60 , C61) ) , R1 , C59) ) . C65 ) = ( ( Result (D26 , D24) ) . C65 ) by L252
.= ( ( Result (D25 , D24) ) . C65 ) by L248 , L254 , SCMFSA_M:2
.= ( ( IExec (D23 , R1 , C59) ) . C65 ) by L250
.= ( ( ( IExec (D23 , R1 , C59) ) +* ( Start-At (( ( ( card C60 ) + ( card C61 ) ) + 3 ) , ( SCM+FSA )) ) ) . C65 ) by L256 , FUNCT_4:11;
end;
suppose L258: C65 is FinSeq-Location;

L259: C65 <> ( IC ( SCM+FSA ) ) by L258 , SCMFSA_2:57;
L260: (not C65 in ( dom ( Start-At (( ( ( card C60 ) + ( card C61 ) ) + 3 ) , ( SCM+FSA )) ) )) by L259 , L251 , TARSKI:def 1;
thus L261: ( ( IExec (( if=0 (C62 , C60 , C61) ) , R1 , C59) ) . C65 ) = ( ( Result (D26 , D24) ) . C65 ) by L252
.= ( ( Result (D25 , D24) ) . C65 ) by L248 , L258 , SCMFSA_M:2
.= ( ( IExec (D23 , R1 , C59) ) . C65 ) by L250
.= ( ( ( IExec (D23 , R1 , C59) ) +* ( Start-At (( ( ( card C60 ) + ( card C61 ) ) + 3 ) , ( SCM+FSA )) ) ) . C65 ) by L260 , FUNCT_4:11;
end;
suppose L262: C65 = ( IC ( SCM+FSA ) );

L263: C65 in ( dom ( Start-At (( ( ( card C60 ) + ( card C61 ) ) + 3 ) , ( SCM+FSA )) ) ) by L262 , L251 , TARSKI:def 1;
L264: ( IC ( Result (D25 , D24) ) ) = ( ( IExec (D23 , R1 , C59) ) . ( IC ( SCM+FSA ) ) ) by L250
.= ( IC ( ( IExec (C60 , R1 , C59) ) +* ( Start-At (( card C60 ) , ( SCM+FSA )) ) ) ) by L225 , L226 , SCMFSA8A:36
.= ( card C60 ) by FUNCT_4:113;
thus L265: ( ( IExec (( if=0 (C62 , C60 , C61) ) , R1 , C59) ) . C65 ) = ( ( Result (D26 , D24) ) . C65 ) by L252
.= ( ( Comput (D26 , D24 , ( ( LifeSpan (D25 , D24) ) + 1 )) ) . C65 ) by L231 , L247 , EXTPRO_1:23
.= ( IC ( Comput (D26 , D27 , ( LifeSpan (D25 , D24) )) ) ) by L262 , EXTPRO_1:4
.= ( ( IC ( Comput (D25 , D24 , ( LifeSpan (D25 , D24) )) ) ) + ( ( card C61 ) + 3 ) ) by L229 , L218 , L221 , L87 , L224 , L205
.= ( ( IC ( Result (D25 , D24) ) ) + ( ( card C61 ) + 3 ) ) by L225 , L226 , EXTPRO_1:23 , SCMFSA8A:34
.= ( ( Start-At (( ( card C60 ) + ( ( card C61 ) + 3 ) ) , ( SCM+FSA )) ) . ( IC ( SCM+FSA ) ) ) by L264 , FUNCOP_1:72
.= ( ( ( IExec (D23 , R1 , C59) ) +* ( Start-At (( ( ( card C60 ) + ( card C61 ) ) + 3 ) , ( SCM+FSA )) ) ) . C65 ) by L262 , L263 , FUNCT_4:13;
end;
end;
L267: ( dom ( IExec (( if=0 (C62 , C60 , C61) ) , R1 , C59) ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2
.= ( dom ( ( IExec (D23 , R1 , C59) ) +* ( Start-At (( ( ( card C60 ) + ( card C61 ) ) + 3 ) , ( SCM+FSA )) ) ) ) by PARTFUN1:def 2;
thus L268: ( IExec (( if=0 (C62 , C60 , C61) ) , R1 , C59) ) = ( ( IExec (D23 , R1 , C59) ) +* ( Start-At (( ( ( card C60 ) + ( card C61 ) ) + 3 ) , ( SCM+FSA )) ) ) by L267 , L249 , FUNCT_1:2
.= ( ( ( IExec (C60 , R1 , C59) ) +* ( Start-At (( card C60 ) , ( SCM+FSA )) ) ) +* ( Start-At (( ( ( card C60 ) + ( card C61 ) ) + 3 ) , ( SCM+FSA )) ) ) by L225 , L226 , SCMFSA8A:36
.= ( ( IExec (C60 , R1 , C59) ) +* ( Start-At (( ( ( card C60 ) + ( card C61 ) ) + 3 ) , ( SCM+FSA )) ) ) by FUNCT_4:114;
end;
theorem
L269: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B69 being (State of ( SCM+FSA )) holds (for B70 , B71 being (Program of ( SCM+FSA )) holds (for B72 being  read-write Int-Location holds ((( B69 . B72 ) <> ( 0 ) & B71 is_closed_on B69 , R1 & B71 is_halting_on B69 , R1) implies (( if=0 (B72 , B70 , B71) ) is_closed_on B69 , R1 & ( if=0 (B72 , B70 , B71) ) is_halting_on B69 , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C66 being (State of ( SCM+FSA ));
let C67 , C68 being (Program of ( SCM+FSA ));
let C69 being  read-write Int-Location;
set D30 = ( C67 ";" ( Stop ( SCM+FSA ) ) );
set D31 = ( ( ( C68 ";" ( Goto ( ( card C67 ) + 1 ) ) ) ";" C67 ) ";" ( Stop ( SCM+FSA ) ) );
set D32 = ( Initialize C66 );
set D33 = ( R1 +* D31 );
L270: D31 c= D33 by FUNCT_4:25;
set D34 = ( Initialize C66 );
set D35 = ( R1 +* ( if=0 (C69 , C67 , C68) ) );
set D36 = ( Comput (D35 , D34 , 1) );
set D37 = ( Comput (D35 , D34 , 2) );
set D38 = ( C69 =0_goto ( ( card C68 ) + 3 ) );
L271: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L272: ( IC D34 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L271 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L273: ( if=0 (C69 , C67 , C68) ) c= D35 by FUNCT_4:25;
L274: ( if=0 (C69 , C67 , C68) ) = ( ( ( D38 ";" C68 ) ";" ( Goto ( ( card C67 ) + 1 ) ) ) ";" D30 ) by SCMFSA6A:25
.= ( ( D38 ";" C68 ) ";" ( ( Goto ( ( card C67 ) + 1 ) ) ";" D30 ) ) by SCMFSA6A:25
.= ( D38 ";" ( C68 ";" ( ( Goto ( ( card C67 ) + 1 ) ) ";" D30 ) ) ) by SCMFSA6A:29
.= ( D38 ";" ( ( C68 ";" ( Goto ( ( card C67 ) + 1 ) ) ) ";" D30 ) ) by SCMFSA6A:25
.= ( ( Macro D38 ) ";" D31 ) by SCMFSA6A:25;
L275: ( Reloc (D31 , ( card ( Macro D38 ) )) ) c= ( if=0 (C69 , C67 , C68) ) by L274 , L1;
L276: ( Reloc (D31 , 2) ) c= ( if=0 (C69 , C67 , C68) ) by L275 , COMPOS_1:56;
L277: ( Reloc (D31 , 2) ) c= D35 by L276 , L273 , XBOOLE_1:1;
L278: (not C69 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L279: ( 0 ) in ( dom ( if=0 (C69 , C67 , C68) ) ) by L128;
L280: ( if=0 (C69 , C67 , C68) ) c= D35 by FUNCT_4:25;
L281: ( D35 . ( 0 ) ) = ( ( if=0 (C69 , C67 , C68) ) . ( 0 ) ) by L279 , FUNCT_4:13
.= D38 by L141;
L282: 1 in ( dom ( if=0 (C69 , C67 , C68) ) ) by L128;
L283: ( Comput (D35 , D34 , ( ( 0 ) + 1 )) ) = ( Following (D35 , ( Comput (D35 , D34 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D35 , D34) )
.= ( Exec (D38 , D34) ) by L272 , L281 , PBOOLE:143;
assume L284: ( C66 . C69 ) <> ( 0 );
L285: ( D34 . C69 ) <> ( 0 ) by L284 , L278 , FUNCT_4:11;
L286: ( IC ( Comput (D35 , D34 , 1) ) ) = ( succ ( 0 ) ) by L285 , L272 , L283 , SCMFSA_2:70
.= ( ( 0 ) + 1 );
L287: ( D35 . 1 ) = ( ( if=0 (C69 , C67 , C68) ) . 1 ) by L282 , L280 , GRFUNC_1:2
.= ( goto 2 ) by L141;
assume L288: C68 is_closed_on C66 , R1;
L289: ( Comput (D35 , D34 , ( 1 + 1 )) ) = ( Following (D35 , D36) ) by EXTPRO_1:3
.= ( Exec (( goto 2 ) , D36) ) by L286 , L287 , PBOOLE:143;
L290:
now
let C70 being FinSeq-Location;
thus L291: ( D32 . C70 ) = ( ( Comput (D35 , D34 , 1) ) . C70 ) by L283 , SCMFSA_2:70
.= ( D37 . C70 ) by L289 , SCMFSA_2:69;
end;
L292:
now
let C71 being Int-Location;
thus L293: ( D32 . C71 ) = ( ( Comput (D35 , D34 , 1) ) . C71 ) by L283 , SCMFSA_2:70
.= ( D37 . C71 ) by L289 , SCMFSA_2:69;
end;
L294: ( DataPart D32 ) = ( DataPart D37 ) by L292 , L290 , SCMFSA_M:2;
assume L295: C68 is_halting_on C66 , R1;
L296: D31 is_closed_on C66 , R1 by L295 , L288 , SCMFSA8A:37;
L297: D31 is_closed_on D32 , D33 by L296 , L84;
L298: D33 halts_on D32 by L288 , L295 , SCMFSA8A:38;
L299: ( IC D37 ) = 2 by L289 , SCMFSA_2:69;
L300:
now
let C72 being (Element of ( NAT ));
L301: (C72 = ( 0 ) or ( ( 0 ) + 1 ) < ( C72 + 1 )) by XREAL_1:6;
L302: (C72 = ( 0 ) or 1 <= C72) by L301 , NAT_1:13;
per cases  by L302 , XXREAL_0:1;
suppose L303: 1 < C72;

consider C73 being Nat such that L304: ( C73 + 1 ) = C72 by L303 , NAT_1:6;
reconsider D39 = C73 as (Element of ( NAT )) by ORDINAL1:def 12;
L305: ( ( 0 ) + 1 ) < ( D39 + 1 ) by L303 , L304;
consider C74 being Nat such that L306: ( C74 + 1 ) = D39 by L305 , NAT_1:6;
reconsider D40 = C74 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D41 = ( IC ( Comput (D33 , D32 , D40) ) ) as (Element of ( NAT ));
L307: ( card ( if=0 (C69 , C67 , C68) ) ) = ( ( card ( Macro D38 ) ) + ( card D31 ) ) by L274 , SCMFSA6A:21
.= ( 2 + ( card D31 ) ) by COMPOS_1:56;
L308: D41 in ( dom D31 ) by L296 , SCMFSA7B:def 6;
L309: D41 < ( card D31 ) by L308 , AFINSQ_1:66;
L310: ( D41 + 2 ) < ( card ( if=0 (C69 , C67 , C68) ) ) by L309 , L307 , XREAL_1:6;
L311: ( IC ( Comput (D35 , D34 , C72) ) ) = ( IC ( Comput (D35 , D36 , D39) ) ) by L304 , EXTPRO_1:4
.= ( IC ( Comput (D35 , ( Comput (D35 , D36 , 1) ) , D40) ) ) by L306 , EXTPRO_1:4
.= ( IC ( Comput (D35 , ( Comput (D35 , D34 , ( 1 + 1 )) ) , D40) ) ) by EXTPRO_1:4
.= ( D41 + 2 ) by L297 , L299 , L294 , L87 , L277 , L270;
thus L312: ( IC ( Comput (D35 , D34 , C72) ) ) in ( dom ( if=0 (C69 , C67 , C68) ) ) by L311 , L310 , AFINSQ_1:66;
end;
suppose L313: C72 = ( 0 );

thus L314: ( IC ( Comput (D35 , D34 , C72) ) ) in ( dom ( if=0 (C69 , C67 , C68) ) ) by L313 , L279 , L272 , EXTPRO_1:2;
end;
suppose L315: C72 = 1;

thus L316: ( IC ( Comput (D35 , D34 , C72) ) ) in ( dom ( if=0 (C69 , C67 , C68) ) ) by L315 , L286 , L128;
end;
end;
thus L318: ( if=0 (C69 , C67 , C68) ) is_closed_on C66 , R1 by L300 , SCMFSA7B:def 6;
L319: ( CurInstr (D35 , ( Comput (D35 , D34 , ( ( LifeSpan (D33 , D32) ) + 2 )) )) ) = ( CurInstr (D35 , ( Comput (D35 , D37 , ( LifeSpan (D33 , D32) )) )) ) by EXTPRO_1:4
.= ( IncAddr (( CurInstr (D33 , ( Comput (D33 , D32 , ( LifeSpan (D33 , D32) )) )) ) , 2) ) by L297 , L299 , L294 , L87 , L277 , L270
.= ( IncAddr (( halt ( SCM+FSA ) ) , 2) ) by L298 , EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
L320: D35 halts_on D34 by L319 , EXTPRO_1:29;
thus L321: thesis by L320 , SCMFSA7B:def 7;
end;
theorem
L322: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B73 , B74 being (Program of ( SCM+FSA )) holds (for B75 being  read-write Int-Location holds (for B76 being (State of ( SCM+FSA )) holds ((( B76 . B75 ) <> ( 0 ) & B74 is_closed_on ( Initialized B76 ) , R1 & B74 is_halting_on ( Initialized B76 ) , R1) implies ( IExec (( if=0 (B75 , B73 , B74) ) , R1 , B76) ) = ( ( IExec (B74 , R1 , B76) ) +* ( Start-At (( ( ( card B73 ) + ( card B74 ) ) + 3 ) , ( SCM+FSA )) ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C75 , C76 being (Program of ( SCM+FSA ));
let C77 being  read-write Int-Location;
let C78 being (State of ( SCM+FSA ));
set D42 = ( C75 ";" ( Stop ( SCM+FSA ) ) );
set D43 = ( ( ( C76 ";" ( Goto ( ( card C75 ) + 1 ) ) ) ";" C75 ) ";" ( Stop ( SCM+FSA ) ) );
set D44 = ( Initialized C78 );
set D45 = ( R1 +* D43 );
L323: D43 c= D45 by FUNCT_4:25;
set D46 = ( R1 +* ( if=0 (C77 , C75 , C76) ) );
set D47 = ( Comput (D46 , D44 , 1) );
set D48 = ( Comput (D46 , D44 , 2) );
set D49 = ( C77 =0_goto ( ( card C76 ) + 3 ) );
L324: ( 0 ) in ( dom ( if=0 (C77 , C75 , C76) ) ) by L128;
L325: ( D46 . ( 0 ) ) = ( ( if=0 (C77 , C75 , C76) ) . ( 0 ) ) by L324 , FUNCT_4:13
.= D49 by L141;
L326: 1 in ( dom ( if=0 (C77 , C75 , C76) ) ) by L128;
L327: ( D46 . 1 ) = ( ( if=0 (C77 , C75 , C76) ) . 1 ) by L326 , FUNCT_4:13
.= ( goto 2 ) by L141;
L328: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = { ( intloc ( 0 ) ) , ( IC ( SCM+FSA ) ) } by SCMFSA_M:11;
L329: (C77 <> ( intloc ( 0 ) ) & C77 <> ( IC ( SCM+FSA ) )) by SCMFSA_2:56;
L330: (not C77 in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) by L329 , L328 , TARSKI:def 2;
L331: ( IC ( SCM+FSA ) ) in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by MEMSTR_0:48;
L332: ( IC D44 ) = ( IC ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L331 , FUNCT_4:13
.= ( 0 ) by MEMSTR_0:def 11;
L333: ( if=0 (C77 , C75 , C76) ) = ( ( ( D49 ";" C76 ) ";" ( Goto ( ( card C75 ) + 1 ) ) ) ";" D42 ) by SCMFSA6A:25
.= ( ( D49 ";" C76 ) ";" ( ( Goto ( ( card C75 ) + 1 ) ) ";" D42 ) ) by SCMFSA6A:25
.= ( D49 ";" ( C76 ";" ( ( Goto ( ( card C75 ) + 1 ) ) ";" D42 ) ) ) by SCMFSA6A:29
.= ( D49 ";" ( ( C76 ";" ( Goto ( ( card C75 ) + 1 ) ) ) ";" D42 ) ) by SCMFSA6A:25
.= ( ( Macro D49 ) ";" D43 ) by SCMFSA6A:25;
L334: ( Reloc (D43 , ( card ( Macro D49 ) )) ) c= ( if=0 (C77 , C75 , C76) ) by L333 , L1;
L335: ( Reloc (D43 , 2) ) c= ( if=0 (C77 , C75 , C76) ) by L334 , COMPOS_1:56;
L336: ( if=0 (C77 , C75 , C76) ) c= D46 by FUNCT_4:25;
L337: ( Reloc (D43 , 2) ) c= D46 by L336 , L335 , XBOOLE_1:1;
L338: ( Comput (D46 , D44 , ( ( 0 ) + 1 )) ) = ( Following (D46 , ( Comput (D46 , D44 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D46 , D44) )
.= ( Exec (D49 , D44) ) by L332 , L325 , PBOOLE:143;
assume L339: ( C78 . C77 ) <> ( 0 );
L340: ( D44 . C77 ) <> ( 0 ) by L339 , L330 , FUNCT_4:11;
L341: ( IC ( Comput (D46 , D44 , 1) ) ) = ( succ ( 0 ) ) by L340 , L332 , L338 , SCMFSA_2:70
.= ( ( 0 ) + 1 );
assume L342: C76 is_closed_on ( Initialized C78 ) , R1;
L343: ( Comput (D46 , D44 , ( 1 + 1 )) ) = ( Following (D46 , D47) ) by EXTPRO_1:3
.= ( Exec (( goto 2 ) , D47) ) by L341 , L327 , PBOOLE:143;
L344: ( IC D48 ) = 2 by L343 , SCMFSA_2:69;
L345:
now
let C79 being FinSeq-Location;
thus L346: ( D44 . C79 ) = ( ( Comput (D46 , D44 , 1) ) . C79 ) by L338 , SCMFSA_2:70
.= ( D48 . C79 ) by L343 , SCMFSA_2:69;
end;
L347:
now
let C80 being Int-Location;
thus L348: ( D44 . C80 ) = ( ( Comput (D46 , D44 , 1) ) . C80 ) by L338 , SCMFSA_2:70
.= ( D48 . C80 ) by L343 , SCMFSA_2:69;
end;
L349: ( DataPart D44 ) = ( DataPart D48 ) by L347 , L345 , SCMFSA_M:2;
assume L350: C76 is_halting_on ( Initialized C78 ) , R1;
L351: D45 halts_on D44 by L350 , L342 , SCMFSA8A:39;
L352: D43 is_closed_on ( Initialized C78 ) , R1 by L342 , L350 , SCMFSA8A:37;
L353: D43 is_closed_on D44 , D45 by L352 , L81;
L354: ( CurInstr (D46 , ( Comput (D46 , D44 , ( ( LifeSpan (D45 , D44) ) + 2 )) )) ) = ( CurInstr (D46 , ( Comput (D46 , D48 , ( LifeSpan (D45 , D44) )) )) ) by EXTPRO_1:4
.= ( IncAddr (( CurInstr (D45 , ( Comput (D45 , D44 , ( LifeSpan (D45 , D44) )) )) ) , 2) ) by L353 , L337 , L344 , L349 , L87 , L323
.= ( IncAddr (( halt ( SCM+FSA ) ) , 2) ) by L351 , EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
L355: D46 halts_on D44 by L354 , EXTPRO_1:29;
L356:
now
let C81 being (Element of ( NAT ));
assume L357: C81 < ( ( LifeSpan (D45 , D44) ) + 2 );
L358: ( Comput (D46 , D44 , ( 0 )) ) = D44;
per cases ;
suppose L359: C81 = ( 0 );

thus L360: ( CurInstr (D46 , ( Comput (D46 , D44 , C81) )) ) <> ( halt ( SCM+FSA ) ) by L359 , L332 , L325 , L358 , PBOOLE:143;
end;
suppose L361: C81 = 1;

thus L362: ( CurInstr (D46 , ( Comput (D46 , D44 , C81) )) ) <> ( halt ( SCM+FSA ) ) by L361 , L341 , L327 , PBOOLE:143;
end;
suppose L363: (C81 <> ( 0 ) & C81 <> 1);

assume L364: ( CurInstr (D46 , ( Comput (D46 , D44 , C81) )) ) = ( halt ( SCM+FSA ) );
consider C82 being Nat such that L365: C81 = ( C82 + 1 ) by L363 , NAT_1:6;
L366: C82 <> ( 0 ) by L363 , L365;
consider C83 being Nat such that L367: C82 = ( C83 + 1 ) by L366 , NAT_1:6;
reconsider D50 = C83 as (Element of ( NAT )) by ORDINAL1:def 12;
L368: ( InsCode ( halt ( SCM+FSA ) ) ) = ( 0 ) by COMPOS_1:70;
L369: ( Comput (D46 , D44 , ( D50 + ( 1 + 1 ) )) ) = ( Comput (D46 , ( Comput (D46 , D44 , ( 1 + 1 )) ) , D50) ) by EXTPRO_1:4;
L370: ( InsCode ( CurInstr (D45 , ( Comput (D45 , D44 , D50) )) ) ) = ( InsCode ( IncAddr (( CurInstr (D45 , ( Comput (D45 , D44 , D50) )) ) , 2) ) ) by COMPOS_0:def 9
.= ( 0 ) by L365 , L367 , L364 , L369 , L353 , L344 , L349 , L87 , L337 , L323 , L368;
L371: ( CurInstr (D45 , ( Comput (D45 , D44 , D50) )) ) = ( halt ( SCM+FSA ) ) by L370 , SCMFSA_2:95;
L372: ( C82 + 1 ) < ( ( ( LifeSpan (D45 , D44) ) + 1 ) + 1 ) by L357 , L365;
L373: C82 < ( ( LifeSpan (D45 , D44) ) + 1 ) by L372 , XREAL_1:6;
L374: D50 < ( LifeSpan (D45 , D44) ) by L373 , L367 , XREAL_1:6;
thus L375: contradiction by L374 , L351 , L371 , EXTPRO_1:def 15;
end;
end;
L377: (for B77 being (Element of ( NAT )) holds (( CurInstr (D46 , ( Comput (D46 , D44 , B77) )) ) = ( halt ( SCM+FSA ) ) implies ( ( LifeSpan (D45 , D44) ) + 2 ) <= B77)) by L356;
L378: ( LifeSpan (D46 , D44) ) = ( ( LifeSpan (D45 , D44) ) + 2 ) by L377 , L354 , L355 , EXTPRO_1:def 15;
L379: ( DataPart ( Result (D45 , D44) ) ) = ( DataPart ( Comput (D45 , D44 , ( LifeSpan (D45 , D44) )) ) ) by L350 , L342 , EXTPRO_1:23 , SCMFSA8A:39
.= ( DataPart ( Comput (D46 , D48 , ( LifeSpan (D45 , D44) )) ) ) by L353 , L344 , L349 , L87 , L337 , L323
.= ( DataPart ( Comput (D46 , D44 , ( ( LifeSpan (D45 , D44) ) + 2 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (D46 , D44) ) ) by L355 , L378 , EXTPRO_1:23;
L380:
now
let C84 being set;
L381: ( dom ( Start-At (( ( ( card C75 ) + ( card C76 ) ) + 3 ) , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L382: ( IExec (( if=0 (C77 , C75 , C76) ) , R1 , C78) ) = ( Result (D46 , D44) ) by SCMFSA6B:def 1;
L383: ( IExec (D43 , R1 , C78) ) = ( Result (D45 , D44) ) by SCMFSA6B:def 1;
assume L384: C84 in ( dom ( IExec (( if=0 (C77 , C75 , C76) ) , R1 , C78) ) );
per cases  by L384 , SCMFSA_M:1;
suppose L385: C84 is Int-Location;

L386: C84 <> ( IC ( SCM+FSA ) ) by L385 , SCMFSA_2:56;
L387: (not C84 in ( dom ( Start-At (( ( ( card C75 ) + ( card C76 ) ) + 3 ) , ( SCM+FSA )) ) )) by L386 , L381 , TARSKI:def 1;
thus L388: ( ( IExec (( if=0 (C77 , C75 , C76) ) , R1 , C78) ) . C84 ) = ( ( Result (D46 , D44) ) . C84 ) by L382
.= ( ( Result (D45 , D44) ) . C84 ) by L379 , L385 , SCMFSA_M:2
.= ( ( IExec (D43 , R1 , C78) ) . C84 ) by L383
.= ( ( ( IExec (D43 , R1 , C78) ) +* ( Start-At (( ( ( card C75 ) + ( card C76 ) ) + 3 ) , ( SCM+FSA )) ) ) . C84 ) by L387 , FUNCT_4:11;
end;
suppose L389: C84 is FinSeq-Location;

L390: C84 <> ( IC ( SCM+FSA ) ) by L389 , SCMFSA_2:57;
L391: (not C84 in ( dom ( Start-At (( ( ( card C75 ) + ( card C76 ) ) + 3 ) , ( SCM+FSA )) ) )) by L390 , L381 , TARSKI:def 1;
thus L392: ( ( IExec (( if=0 (C77 , C75 , C76) ) , R1 , C78) ) . C84 ) = ( ( Result (D46 , D44) ) . C84 ) by L382
.= ( ( Result (D45 , D44) ) . C84 ) by L379 , L389 , SCMFSA_M:2
.= ( ( IExec (D43 , R1 , C78) ) . C84 ) by L383
.= ( ( ( IExec (D43 , R1 , C78) ) +* ( Start-At (( ( ( card C75 ) + ( card C76 ) ) + 3 ) , ( SCM+FSA )) ) ) . C84 ) by L391 , FUNCT_4:11;
end;
suppose L393: C84 = ( IC ( SCM+FSA ) );

L394: C84 in ( dom ( Start-At (( ( ( card C75 ) + ( card C76 ) ) + 3 ) , ( SCM+FSA )) ) ) by L393 , L381 , TARSKI:def 1;
L395: ( IC ( Result (D45 , D44) ) ) = ( IC ( IExec (D43 , R1 , C78) ) ) by L383
.= ( ( ( card C75 ) + ( card C76 ) ) + 1 ) by L342 , L350 , SCMFSA8A:40;
thus L396: ( ( IExec (( if=0 (C77 , C75 , C76) ) , R1 , C78) ) . C84 ) = ( ( Result (D46 , D44) ) . C84 ) by L382
.= ( ( Comput (D46 , D44 , ( ( LifeSpan (D45 , D44) ) + 2 )) ) . C84 ) by L355 , L378 , EXTPRO_1:23
.= ( IC ( Comput (D46 , D48 , ( LifeSpan (D45 , D44) )) ) ) by L393 , EXTPRO_1:4
.= ( ( IC ( Comput (D45 , D44 , ( LifeSpan (D45 , D44) )) ) ) + 2 ) by L353 , L344 , L349 , L87 , L337 , L323
.= ( ( IC ( Result (D45 , D44) ) ) + 2 ) by L350 , L342 , EXTPRO_1:23 , SCMFSA8A:39
.= ( ( Start-At (( ( ( ( card C75 ) + ( card C76 ) ) + 1 ) + 2 ) , ( SCM+FSA )) ) . ( IC ( SCM+FSA ) ) ) by L395 , FUNCOP_1:72
.= ( ( ( IExec (D43 , R1 , C78) ) +* ( Start-At (( ( ( card C75 ) + ( card C76 ) ) + 3 ) , ( SCM+FSA )) ) ) . C84 ) by L393 , L394 , FUNCT_4:13;
end;
end;
L398: ( dom ( IExec (( if=0 (C77 , C75 , C76) ) , R1 , C78) ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2
.= ( dom ( ( IExec (D43 , R1 , C78) ) +* ( Start-At (( ( ( card C75 ) + ( card C76 ) ) + 3 ) , ( SCM+FSA )) ) ) ) by PARTFUN1:def 2;
thus L399: ( IExec (( if=0 (C77 , C75 , C76) ) , R1 , C78) ) = ( ( IExec (D43 , R1 , C78) ) +* ( Start-At (( ( ( card C75 ) + ( card C76 ) ) + 3 ) , ( SCM+FSA )) ) ) by L398 , L380 , FUNCT_1:2
.= ( ( ( IExec (C76 , R1 , C78) ) +* ( Start-At (( ( ( card C75 ) + ( card C76 ) ) + 1 ) , ( SCM+FSA )) ) ) +* ( Start-At (( ( ( card C75 ) + ( card C76 ) ) + 3 ) , ( SCM+FSA )) ) ) by L342 , L350 , SCMFSA8A:41
.= ( ( IExec (C76 , R1 , C78) ) +* ( Start-At (( ( ( card C75 ) + ( card C76 ) ) + 3 ) , ( SCM+FSA )) ) ) by FUNCT_4:114;
end;
theorem
L400: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B78 being (State of ( SCM+FSA )) holds (for B79 , B80 being  parahalting (Program of ( SCM+FSA )) holds (for B81 being  read-write Int-Location holds (( if=0 (B81 , B79 , B80) ) is  parahalting & (( B78 . B81 ) = ( 0 ) implies ( IExec (( if=0 (B81 , B79 , B80) ) , R1 , B78) ) = ( ( IExec (B79 , R1 , B78) ) +* ( Start-At (( ( ( card B79 ) + ( card B80 ) ) + 3 ) , ( SCM+FSA )) ) )) & (( B78 . B81 ) <> ( 0 ) implies ( IExec (( if=0 (B81 , B79 , B80) ) , R1 , B78) ) = ( ( IExec (B80 , R1 , B78) ) +* ( Start-At (( ( ( card B79 ) + ( card B80 ) ) + 3 ) , ( SCM+FSA )) ) )))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C85 being (State of ( SCM+FSA ));
let C86 , C87 being  parahalting (Program of ( SCM+FSA ));
let C88 being  read-write Int-Location;
L401: C86 is_halting_on ( Initialized C85 ) , R1 by SCMFSA7B:19;
L402: (for B82 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B83 being (Instruction-Sequence of ( SCM+FSA )) holds (( if=0 (C88 , C86 , C87) ) c= B83 implies B83 halts_on B82)))
proof
let C89 being ( 0 ) -started (State of ( SCM+FSA ));
L403: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C89 by MEMSTR_0:29;
L404: C89 = ( Initialize C89 ) by L403 , FUNCT_4:98;
let C90 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L405: ( if=0 (C88 , C86 , C87) ) c= C90;
L406: ( if=0 (C88 , C86 , C87) ) c= C90 by L405;
L407: C86 is_closed_on C89 , C90 by SCMFSA7B:18;
L408: C86 is_halting_on C89 , C90 by SCMFSA7B:19;
L409: C87 is_halting_on C89 , C90 by SCMFSA7B:19;
L410: C87 is_closed_on C89 , C90 by SCMFSA7B:18;
L411: ( C90 +* ( if=0 (C88 , C86 , C87) ) ) = C90 by L406 , FUNCT_4:98;
per cases ;
suppose L412: ( C89 . C88 ) = ( 0 );

L413: ( if=0 (C88 , C86 , C87) ) is_halting_on C89 , C90 by L412 , L407 , L408 , L160;
thus L414: C90 halts_on C89 by L413 , L404 , L411 , SCMFSA7B:def 7;
end;
suppose L415: ( C89 . C88 ) <> ( 0 );

L416: ( if=0 (C88 , C86 , C87) ) is_halting_on C89 , C90 by L415 , L410 , L409 , L269;
thus L417: C90 halts_on C89 by L416 , L404 , L411 , SCMFSA7B:def 7;
end;
end;
thus L419: ( if=0 (C88 , C86 , C87) ) is  parahalting by L402 , AMISTD_1:def 11;
L420: C87 is_closed_on ( Initialized C85 ) , R1 by SCMFSA7B:18;
L421: C86 is_closed_on ( Initialized C85 ) , R1 by SCMFSA7B:18;
thus L422: (( C85 . C88 ) = ( 0 ) implies ( IExec (( if=0 (C88 , C86 , C87) ) , R1 , C85) ) = ( ( IExec (C86 , R1 , C85) ) +* ( Start-At (( ( ( card C86 ) + ( card C87 ) ) + 3 ) , ( SCM+FSA )) ) )) by L421 , L401 , L204;
L423: C87 is_halting_on ( Initialized C85 ) , R1 by SCMFSA7B:19;
thus L424: thesis by L423 , L322 , L420;
end;
theorem
L425: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B84 being (State of ( SCM+FSA )) holds (for B85 , B86 being  parahalting (Program of ( SCM+FSA )) holds (for B87 being  read-write Int-Location holds (( IC ( IExec (( if=0 (B87 , B85 , B86) ) , R1 , B84) ) ) = ( ( ( card B85 ) + ( card B86 ) ) + 3 ) & (( B84 . B87 ) = ( 0 ) implies ((for B88 being Int-Location holds ( ( IExec (( if=0 (B87 , B85 , B86) ) , R1 , B84) ) . B88 ) = ( ( IExec (B85 , R1 , B84) ) . B88 )) & (for B89 being FinSeq-Location holds ( ( IExec (( if=0 (B87 , B85 , B86) ) , R1 , B84) ) . B89 ) = ( ( IExec (B85 , R1 , B84) ) . B89 )))) & (( B84 . B87 ) <> ( 0 ) implies ((for B90 being Int-Location holds ( ( IExec (( if=0 (B87 , B85 , B86) ) , R1 , B84) ) . B90 ) = ( ( IExec (B86 , R1 , B84) ) . B90 )) & (for B91 being FinSeq-Location holds ( ( IExec (( if=0 (B87 , B85 , B86) ) , R1 , B84) ) . B91 ) = ( ( IExec (B86 , R1 , B84) ) . B91 )))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C91 being (State of ( SCM+FSA ));
let C92 , C93 being  parahalting (Program of ( SCM+FSA ));
let C94 being  read-write Int-Location;
thus L426:now
per cases ;
suppose L427: ( C91 . C94 ) = ( 0 );

L428: ( IExec (( if=0 (C94 , C92 , C93) ) , R1 , C91) ) = ( ( IExec (C92 , R1 , C91) ) +* ( Start-At (( ( ( card C92 ) + ( card C93 ) ) + 3 ) , ( SCM+FSA )) ) ) by L427 , L400;
thus L429: ( IC ( IExec (( if=0 (C94 , C92 , C93) ) , R1 , C91) ) ) = ( ( ( card C92 ) + ( card C93 ) ) + 3 ) by L428 , FUNCT_4:113;
end;
suppose L430: ( C91 . C94 ) <> ( 0 );

L431: ( IExec (( if=0 (C94 , C92 , C93) ) , R1 , C91) ) = ( ( IExec (C93 , R1 , C91) ) +* ( Start-At (( ( ( card C92 ) + ( card C93 ) ) + 3 ) , ( SCM+FSA )) ) ) by L430 , L400;
thus L432: ( IC ( IExec (( if=0 (C94 , C92 , C93) ) , R1 , C91) ) ) = ( ( ( card C92 ) + ( card C93 ) ) + 3 ) by L431 , FUNCT_4:113;
end;
end;
thus L434:now
assume L435: ( C91 . C94 ) = ( 0 );
L436: ( IExec (( if=0 (C94 , C92 , C93) ) , R1 , C91) ) = ( ( IExec (C92 , R1 , C91) ) +* ( Start-At (( ( ( card C92 ) + ( card C93 ) ) + 3 ) , ( SCM+FSA )) ) ) by L435 , L400;
thus L437:now
let C95 being Int-Location;
L438: (not C95 in ( dom ( Start-At (( ( ( card C92 ) + ( card C93 ) ) + 3 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
thus L439: ( ( IExec (( if=0 (C94 , C92 , C93) ) , R1 , C91) ) . C95 ) = ( ( IExec (C92 , R1 , C91) ) . C95 ) by L438 , L436 , FUNCT_4:11;
end;
let C96 being FinSeq-Location;
L440: (not C96 in ( dom ( Start-At (( ( ( card C92 ) + ( card C93 ) ) + 3 ) , ( SCM+FSA )) ) )) by SCMFSA_2:103;
thus L441: ( ( IExec (( if=0 (C94 , C92 , C93) ) , R1 , C91) ) . C96 ) = ( ( IExec (C92 , R1 , C91) ) . C96 ) by L440 , L436 , FUNCT_4:11;
end;
assume L442: ( C91 . C94 ) <> ( 0 );
L443: ( IExec (( if=0 (C94 , C92 , C93) ) , R1 , C91) ) = ( ( IExec (C93 , R1 , C91) ) +* ( Start-At (( ( ( card C92 ) + ( card C93 ) ) + 3 ) , ( SCM+FSA )) ) ) by L442 , L400;
thus L444:now
let C97 being Int-Location;
L445: (not C97 in ( dom ( Start-At (( ( ( card C92 ) + ( card C93 ) ) + 3 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
thus L446: ( ( IExec (( if=0 (C94 , C92 , C93) ) , R1 , C91) ) . C97 ) = ( ( IExec (C93 , R1 , C91) ) . C97 ) by L445 , L443 , FUNCT_4:11;
end;
let C98 being FinSeq-Location;
L447: (not C98 in ( dom ( Start-At (( ( ( card C92 ) + ( card C93 ) ) + 3 ) , ( SCM+FSA )) ) )) by SCMFSA_2:103;
thus L448: thesis by L447 , L443 , FUNCT_4:11;
end;
theorem
L449: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B92 being (State of ( SCM+FSA )) holds (for B93 , B94 being (Program of ( SCM+FSA )) holds (for B95 being  read-write Int-Location holds ((( B92 . B95 ) > ( 0 ) & B93 is_closed_on B92 , R1 & B93 is_halting_on B92 , R1) implies (( if>0 (B95 , B93 , B94) ) is_closed_on B92 , R1 & ( if>0 (B95 , B93 , B94) ) is_halting_on B92 , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C99 being (State of ( SCM+FSA ));
let C100 , C101 being (Program of ( SCM+FSA ));
let C102 being  read-write Int-Location;
set D51 = ( C100 ";" ( Stop ( SCM+FSA ) ) );
set D52 = ( Initialize C99 );
set D53 = ( R1 +* D51 );
set D54 = ( Initialize C99 );
set D55 = ( R1 +* ( if>0 (C102 , C100 , C101) ) );
set D56 = ( Comput (D55 , D54 , 1) );
set D57 = ( C102 >0_goto ( ( card C101 ) + 3 ) );
L450: D51 c= D53 by FUNCT_4:25;
L451: (not C102 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L452: ( 0 ) in ( dom ( if>0 (C102 , C100 , C101) ) ) by L128;
L453: ( D55 . ( 0 ) ) = ( ( if>0 (C102 , C100 , C101) ) . ( 0 ) ) by L452 , FUNCT_4:13
.= D57 by L141;
L454: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L455: ( IC D54 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L454 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L456: ( if>0 (C102 , C100 , C101) ) c= D55 by FUNCT_4:25;
L457: ( if>0 (C102 , C100 , C101) ) = ( ( ( D57 ";" C101 ) ";" ( Goto ( ( card C100 ) + 1 ) ) ) ";" D51 ) by SCMFSA6A:25;
L458: ( card ( ( D57 ";" C101 ) ";" ( Goto ( ( card C100 ) + 1 ) ) ) ) = ( ( card ( ( Macro D57 ) ";" C101 ) ) + ( card ( Goto ( ( card C100 ) + 1 ) ) ) ) by SCMFSA6A:21
.= ( ( card ( ( Macro D57 ) ";" C101 ) ) + 1 ) by SCMFSA8A:15
.= ( ( ( card ( Macro D57 ) ) + ( card C101 ) ) + 1 ) by SCMFSA6A:21
.= ( ( ( card C101 ) + 2 ) + 1 ) by COMPOS_1:56
.= ( ( card C101 ) + ( 2 + 1 ) );
L459: ( Reloc (D51 , ( ( card C101 ) + 3 )) ) c= ( if>0 (C102 , C100 , C101) ) by L458 , L457 , L1;
L460: ( Reloc (D51 , ( ( card C101 ) + 3 )) ) c= D55 by L459 , L456 , XBOOLE_1:1;
L461: ( Comput (D55 , D54 , ( ( 0 ) + 1 )) ) = ( Following (D55 , ( Comput (D55 , D54 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D55 , D54) )
.= ( Exec (D57 , D54) ) by L455 , L453 , PBOOLE:143;
L462: (for B96 being FinSeq-Location holds ( D52 . B96 ) = ( D56 . B96 )) by L461 , SCMFSA_2:71;
L463: (for B97 being Int-Location holds ( D52 . B97 ) = ( D56 . B97 )) by L461 , SCMFSA_2:71;
L464: ( DataPart D52 ) = ( DataPart D56 ) by L463 , L462 , SCMFSA_M:2;
assume L465: ( C99 . C102 ) > ( 0 );
L466: ( D54 . C102 ) > ( 0 ) by L465 , L451 , FUNCT_4:11;
L467: ( IC ( Comput (D55 , D54 , 1) ) ) = ( ( card C101 ) + 3 ) by L466 , L461 , SCMFSA_2:71;
assume L468: C100 is_closed_on C99 , R1;
assume L469: C100 is_halting_on C99 , R1;
L470: D51 is_closed_on C99 , R1 by L469 , L468 , SCMFSA8A:30;
L471: D51 is_halting_on C99 , R1 by L468 , L469 , SCMFSA8A:30;
L472: D53 halts_on D52 by L471 , SCMFSA7B:def 7;
L473: ( DataPart C99 ) = ( DataPart D52 ) by MEMSTR_0:79;
L474: D51 is_closed_on D52 , D53 by L473 , L470 , L7;
L475:
now
let C103 being (Element of ( NAT ));
per cases ;
suppose L476: ( 0 ) < C103;

consider C104 being Nat such that L477: ( C104 + 1 ) = C103 by L476 , NAT_1:6;
reconsider D58 = C104 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D59 = ( IC ( Comput (D53 , D52 , D58) ) ) as (Element of ( NAT ));
L478: D59 in ( dom D51 ) by L470 , SCMFSA7B:def 6;
L479: D59 < ( card D51 ) by L478 , AFINSQ_1:66;
L480: ( card ( Stop ( SCM+FSA ) ) ) = 1 by COMPOS_1:4;
L481: ( card D51 ) = ( ( card C100 ) + 1 ) by L480 , SCMFSA6A:21;
L482: ( card ( if>0 (C102 , C100 , C101) ) ) = ( ( ( card C100 ) + ( card C101 ) ) + 4 ) by L157
.= ( ( ( card C101 ) + 3 ) + ( card D51 ) ) by L481;
L483: ( D59 + ( ( card C101 ) + 3 ) ) < ( card ( if>0 (C102 , C100 , C101) ) ) by L482 , L479 , XREAL_1:6;
L484: ( IC ( Comput (D55 , D54 , C103) ) ) = ( IC ( Comput (D55 , D56 , D58) ) ) by L477 , EXTPRO_1:4
.= ( D59 + ( ( card C101 ) + 3 ) ) by L474 , L467 , L464 , L87 , L460 , L450;
thus L485: ( IC ( Comput (D55 , D54 , C103) ) ) in ( dom ( if>0 (C102 , C100 , C101) ) ) by L484 , L483 , AFINSQ_1:66;
end;
suppose L486: C103 = ( 0 );

thus L487: ( IC ( Comput (D55 , D54 , C103) ) ) in ( dom ( if>0 (C102 , C100 , C101) ) ) by L486 , L452 , L455 , EXTPRO_1:2;
end;
end;
thus L489: ( if>0 (C102 , C100 , C101) ) is_closed_on C99 , R1 by L475 , SCMFSA7B:def 6;
L490: ( CurInstr (D55 , ( Comput (D55 , D54 , ( ( LifeSpan (D53 , D52) ) + 1 )) )) ) = ( CurInstr (D55 , ( Comput (D55 , D56 , ( LifeSpan (D53 , D52) )) )) ) by EXTPRO_1:4
.= ( IncAddr (( CurInstr (D53 , ( Comput (D53 , D52 , ( LifeSpan (D53 , D52) )) )) ) , ( ( card C101 ) + 3 )) ) by L474 , L467 , L464 , L87 , L460 , L450
.= ( IncAddr (( halt ( SCM+FSA ) ) , ( ( card C101 ) + 3 )) ) by L472 , EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
L491: D55 halts_on D54 by L490 , EXTPRO_1:29;
thus L492: thesis by L491 , SCMFSA7B:def 7;
end;
theorem
L493: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B98 , B99 being (Program of ( SCM+FSA )) holds (for B100 being  read-write Int-Location holds (for B101 being (State of ( SCM+FSA )) holds ((( B101 . B100 ) > ( 0 ) & B98 is_closed_on ( Initialized B101 ) , R1 & B98 is_halting_on ( Initialized B101 ) , R1) implies ( IExec (( if>0 (B100 , B98 , B99) ) , R1 , B101) ) = ( ( IExec (B98 , R1 , B101) ) +* ( Start-At (( ( ( card B98 ) + ( card B99 ) ) + 3 ) , ( SCM+FSA )) ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C105 , C106 being (Program of ( SCM+FSA ));
let C107 being  read-write Int-Location;
let C108 being (State of ( SCM+FSA ));
set D60 = ( C105 ";" ( Stop ( SCM+FSA ) ) );
set D61 = ( Initialized C108 );
set D62 = ( R1 +* D60 );
set D63 = ( R1 +* ( if>0 (C107 , C105 , C106) ) );
set D64 = ( Comput (D63 , D61 , 1) );
set D65 = ( C107 >0_goto ( ( card C106 ) + 3 ) );
L494: D60 c= D62 by FUNCT_4:25;
L495: ( if>0 (C107 , C105 , C106) ) = ( ( ( D65 ";" C106 ) ";" ( Goto ( ( card C105 ) + 1 ) ) ) ";" D60 ) by SCMFSA6A:25;
L496: ( 0 ) in ( dom ( if>0 (C107 , C105 , C106) ) ) by L128;
L497: ( D63 . ( 0 ) ) = ( ( if>0 (C107 , C105 , C106) ) . ( 0 ) ) by L496 , FUNCT_4:13
.= D65 by L141;
L498: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = { ( intloc ( 0 ) ) , ( IC ( SCM+FSA ) ) } by SCMFSA_M:11;
L499: (C107 <> ( intloc ( 0 ) ) & C107 <> ( IC ( SCM+FSA ) )) by SCMFSA_2:56;
L500: (not C107 in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) by L499 , L498 , TARSKI:def 2;
L501: ( IC ( SCM+FSA ) ) in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by MEMSTR_0:48;
L502: ( IC D61 ) = ( IC ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L501 , FUNCT_4:13
.= ( 0 ) by MEMSTR_0:def 11;
L503: ( Comput (D63 , D61 , ( ( 0 ) + 1 )) ) = ( Following (D63 , ( Comput (D63 , D61 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D63 , D61) )
.= ( Exec (D65 , D61) ) by L502 , L497 , PBOOLE:143;
L504: ( if>0 (C107 , C105 , C106) ) c= D63 by FUNCT_4:25;
assume L505: ( C108 . C107 ) > ( 0 );
L506: ( D61 . C107 ) > ( 0 ) by L505 , L500 , FUNCT_4:11;
L507: ( IC ( Comput (D63 , D61 , 1) ) ) = ( ( card C106 ) + 3 ) by L506 , L503 , SCMFSA_2:71;
L508: (for B102 being FinSeq-Location holds ( D61 . B102 ) = ( D64 . B102 )) by L503 , SCMFSA_2:71;
L509: (for B103 being Int-Location holds ( D61 . B103 ) = ( D64 . B103 )) by L503 , SCMFSA_2:71;
L510: ( DataPart D61 ) = ( DataPart D64 ) by L509 , L508 , SCMFSA_M:2;
L511: ( card ( ( D65 ";" C106 ) ";" ( Goto ( ( card C105 ) + 1 ) ) ) ) = ( ( card ( ( Macro D65 ) ";" C106 ) ) + ( card ( Goto ( ( card C105 ) + 1 ) ) ) ) by SCMFSA6A:21
.= ( ( card ( ( Macro D65 ) ";" C106 ) ) + 1 ) by SCMFSA8A:15
.= ( ( ( card ( Macro D65 ) ) + ( card C106 ) ) + 1 ) by SCMFSA6A:21
.= ( ( ( card C106 ) + 2 ) + 1 ) by COMPOS_1:56
.= ( ( card C106 ) + ( 2 + 1 ) );
L512: ( Reloc (D60 , ( ( card C106 ) + 3 )) ) c= ( if>0 (C107 , C105 , C106) ) by L511 , L495 , L1;
L513: ( Reloc (D60 , ( ( card C106 ) + 3 )) ) c= D63 by L512 , L504 , XBOOLE_1:1;
assume L514: C105 is_closed_on ( Initialized C108 ) , R1;
assume L515: C105 is_halting_on ( Initialized C108 ) , R1;
L516: D62 halts_on D61 by L515 , L514 , SCMFSA8A:34;
L517: D60 is_closed_on ( Initialized C108 ) , R1 by L514 , L515 , SCMFSA8A:30;
L518: D60 is_closed_on D61 , D62 by L517 , L81;
L519: ( CurInstr (D63 , ( Comput (D63 , D61 , ( ( LifeSpan (D62 , D61) ) + 1 )) )) ) = ( CurInstr (D63 , ( Comput (D63 , D64 , ( LifeSpan (D62 , D61) )) )) ) by EXTPRO_1:4
.= ( IncAddr (( CurInstr (D62 , ( Comput (D62 , D61 , ( LifeSpan (D62 , D61) )) )) ) , ( ( card C106 ) + 3 )) ) by L518 , L507 , L510 , L87 , L513 , L494
.= ( IncAddr (( halt ( SCM+FSA ) ) , ( ( card C106 ) + 3 )) ) by L516 , EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
L520: D63 halts_on D61 by L519 , EXTPRO_1:29;
L521:
now
let C109 being (Element of ( NAT ));
assume L522: C109 < ( ( LifeSpan (D62 , D61) ) + 1 );
L523: ( Comput (D63 , D61 , ( 0 )) ) = D61;
per cases ;
suppose L524: C109 = ( 0 );

thus L525: ( CurInstr (D63 , ( Comput (D63 , D61 , C109) )) ) <> ( halt ( SCM+FSA ) ) by L524 , L502 , L497 , L523 , PBOOLE:143;
end;
suppose L526: C109 <> ( 0 );

consider C110 being Nat such that L527: C109 = ( C110 + 1 ) by L526 , NAT_1:6;
assume L528: ( CurInstr (D63 , ( Comput (D63 , D61 , C109) )) ) = ( halt ( SCM+FSA ) );
reconsider D66 = C110 as (Element of ( NAT )) by ORDINAL1:def 12;
L529: ( InsCode ( halt ( SCM+FSA ) ) ) = ( 0 ) by COMPOS_1:70;
L530: ( InsCode ( CurInstr (D62 , ( Comput (D62 , D61 , D66) )) ) ) = ( InsCode ( IncAddr (( CurInstr (D62 , ( Comput (D62 , D61 , D66) )) ) , ( ( card C106 ) + 3 )) ) ) by COMPOS_0:def 9
.= ( InsCode ( CurInstr (D63 , ( Comput (D63 , D64 , D66) )) ) ) by L518 , L507 , L510 , L87 , L513 , L494
.= ( 0 ) by L527 , L528 , EXTPRO_1:4 , L529;
L531: ( CurInstr (D62 , ( Comput (D62 , D61 , D66) )) ) = ( halt ( SCM+FSA ) ) by L530 , SCMFSA_2:95;
L532: D66 < ( LifeSpan (D62 , D61) ) by L522 , L527 , XREAL_1:6;
thus L533: contradiction by L532 , L516 , L531 , EXTPRO_1:def 15;
end;
end;
L535: (for B104 being (Element of ( NAT )) holds (( CurInstr (D63 , ( Comput (D63 , D61 , B104) )) ) = ( halt ( SCM+FSA ) ) implies ( ( LifeSpan (D62 , D61) ) + 1 ) <= B104)) by L521;
L536: ( LifeSpan (D63 , D61) ) = ( ( LifeSpan (D62 , D61) ) + 1 ) by L535 , L519 , L520 , EXTPRO_1:def 15;
L537: ( DataPart ( Result (D62 , D61) ) ) = ( DataPart ( Comput (D62 , D61 , ( LifeSpan (D62 , D61) )) ) ) by L514 , L515 , EXTPRO_1:23 , SCMFSA8A:34
.= ( DataPart ( Comput (D63 , D64 , ( LifeSpan (D62 , D61) )) ) ) by L518 , L507 , L510 , L87 , L513 , L494
.= ( DataPart ( Comput (D63 , D61 , ( ( LifeSpan (D62 , D61) ) + 1 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (D63 , D61) ) ) by L520 , L536 , EXTPRO_1:23;
L538:
now
let C111 being set;
L539: ( dom ( Start-At (( ( ( card C105 ) + ( card C106 ) ) + 3 ) , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L540: ( IExec (( if>0 (C107 , C105 , C106) ) , R1 , C108) ) = ( Result (D63 , D61) ) by SCMFSA6B:def 1;
L541: ( IExec (D60 , R1 , C108) ) = ( Result (D62 , D61) ) by SCMFSA6B:def 1;
assume L542: C111 in ( dom ( IExec (( if>0 (C107 , C105 , C106) ) , R1 , C108) ) );
per cases  by L542 , SCMFSA_M:1;
suppose L543: C111 is Int-Location;

L544: C111 <> ( IC ( SCM+FSA ) ) by L543 , SCMFSA_2:56;
L545: (not C111 in ( dom ( Start-At (( ( ( card C105 ) + ( card C106 ) ) + 3 ) , ( SCM+FSA )) ) )) by L544 , L539 , TARSKI:def 1;
thus L546: ( ( IExec (( if>0 (C107 , C105 , C106) ) , R1 , C108) ) . C111 ) = ( ( Result (D63 , D61) ) . C111 ) by L540
.= ( ( Result (D62 , D61) ) . C111 ) by L537 , L543 , SCMFSA_M:2
.= ( ( IExec (D60 , R1 , C108) ) . C111 ) by L541
.= ( ( ( IExec (D60 , R1 , C108) ) +* ( Start-At (( ( ( card C105 ) + ( card C106 ) ) + 3 ) , ( SCM+FSA )) ) ) . C111 ) by L545 , FUNCT_4:11;
end;
suppose L547: C111 is FinSeq-Location;

L548: C111 <> ( IC ( SCM+FSA ) ) by L547 , SCMFSA_2:57;
L549: (not C111 in ( dom ( Start-At (( ( ( card C105 ) + ( card C106 ) ) + 3 ) , ( SCM+FSA )) ) )) by L548 , L539 , TARSKI:def 1;
thus L550: ( ( IExec (( if>0 (C107 , C105 , C106) ) , R1 , C108) ) . C111 ) = ( ( Result (D63 , D61) ) . C111 ) by L540
.= ( ( Result (D62 , D61) ) . C111 ) by L537 , L547 , SCMFSA_M:2
.= ( ( IExec (D60 , R1 , C108) ) . C111 ) by L541
.= ( ( ( IExec (D60 , R1 , C108) ) +* ( Start-At (( ( ( card C105 ) + ( card C106 ) ) + 3 ) , ( SCM+FSA )) ) ) . C111 ) by L549 , FUNCT_4:11;
end;
suppose L551: C111 = ( IC ( SCM+FSA ) );

L552: C111 in ( dom ( Start-At (( ( ( card C105 ) + ( card C106 ) ) + 3 ) , ( SCM+FSA )) ) ) by L551 , L539 , TARSKI:def 1;
L553: ( IC ( Result (D62 , D61) ) ) = ( ( IExec (D60 , R1 , C108) ) . ( IC ( SCM+FSA ) ) ) by L541
.= ( IC ( ( IExec (C105 , R1 , C108) ) +* ( Start-At (( card C105 ) , ( SCM+FSA )) ) ) ) by L514 , L515 , SCMFSA8A:36
.= ( card C105 ) by FUNCT_4:113;
thus L554: ( ( IExec (( if>0 (C107 , C105 , C106) ) , R1 , C108) ) . C111 ) = ( ( Result (D63 , D61) ) . C111 ) by L540
.= ( ( Comput (D63 , D61 , ( ( LifeSpan (D62 , D61) ) + 1 )) ) . C111 ) by L520 , L536 , EXTPRO_1:23
.= ( IC ( Comput (D63 , D64 , ( LifeSpan (D62 , D61) )) ) ) by L551 , EXTPRO_1:4
.= ( ( IC ( Comput (D62 , D61 , ( LifeSpan (D62 , D61) )) ) ) + ( ( card C106 ) + 3 ) ) by L518 , L507 , L510 , L87 , L494 , L513
.= ( ( IC ( Result (D62 , D61) ) ) + ( ( card C106 ) + 3 ) ) by L514 , L515 , EXTPRO_1:23 , SCMFSA8A:34
.= ( ( Start-At (( ( card C105 ) + ( ( card C106 ) + 3 ) ) , ( SCM+FSA )) ) . ( IC ( SCM+FSA ) ) ) by L553 , FUNCOP_1:72
.= ( ( ( IExec (D60 , R1 , C108) ) +* ( Start-At (( ( ( card C105 ) + ( card C106 ) ) + 3 ) , ( SCM+FSA )) ) ) . C111 ) by L551 , L552 , FUNCT_4:13;
end;
end;
L556: ( dom ( IExec (( if>0 (C107 , C105 , C106) ) , R1 , C108) ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2
.= ( dom ( ( IExec (D60 , R1 , C108) ) +* ( Start-At (( ( ( card C105 ) + ( card C106 ) ) + 3 ) , ( SCM+FSA )) ) ) ) by PARTFUN1:def 2;
thus L557: ( IExec (( if>0 (C107 , C105 , C106) ) , R1 , C108) ) = ( ( IExec (D60 , R1 , C108) ) +* ( Start-At (( ( ( card C105 ) + ( card C106 ) ) + 3 ) , ( SCM+FSA )) ) ) by L556 , L538 , FUNCT_1:2
.= ( ( ( IExec (C105 , R1 , C108) ) +* ( Start-At (( card C105 ) , ( SCM+FSA )) ) ) +* ( Start-At (( ( ( card C105 ) + ( card C106 ) ) + 3 ) , ( SCM+FSA )) ) ) by L514 , L515 , SCMFSA8A:36
.= ( ( IExec (C105 , R1 , C108) ) +* ( Start-At (( ( ( card C105 ) + ( card C106 ) ) + 3 ) , ( SCM+FSA )) ) ) by FUNCT_4:114;
end;
theorem
L558: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B105 being (State of ( SCM+FSA )) holds (for B106 , B107 being (Program of ( SCM+FSA )) holds (for B108 being  read-write Int-Location holds ((( B105 . B108 ) <= ( 0 ) & B107 is_closed_on B105 , R1 & B107 is_halting_on B105 , R1) implies (( if>0 (B108 , B106 , B107) ) is_closed_on B105 , R1 & ( if>0 (B108 , B106 , B107) ) is_halting_on B105 , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C112 being (State of ( SCM+FSA ));
let C113 , C114 being (Program of ( SCM+FSA ));
let C115 being  read-write Int-Location;
set D67 = ( C113 ";" ( Stop ( SCM+FSA ) ) );
set D68 = ( ( ( C114 ";" ( Goto ( ( card C113 ) + 1 ) ) ) ";" C113 ) ";" ( Stop ( SCM+FSA ) ) );
set D69 = ( Initialize C112 );
set D70 = ( R1 +* D68 );
L559: D68 c= D70 by FUNCT_4:25;
set D71 = ( Initialize C112 );
set D72 = ( R1 +* ( if>0 (C115 , C113 , C114) ) );
set D73 = ( Comput (D72 , D71 , 1) );
set D74 = ( Comput (D72 , D71 , 2) );
set D75 = ( C115 >0_goto ( ( card C114 ) + 3 ) );
L560: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L561: ( IC D71 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L560 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L562: ( if>0 (C115 , C113 , C114) ) c= D72 by FUNCT_4:25;
L563: ( if>0 (C115 , C113 , C114) ) = ( ( ( D75 ";" C114 ) ";" ( Goto ( ( card C113 ) + 1 ) ) ) ";" D67 ) by SCMFSA6A:25
.= ( ( D75 ";" C114 ) ";" ( ( Goto ( ( card C113 ) + 1 ) ) ";" D67 ) ) by SCMFSA6A:25
.= ( D75 ";" ( C114 ";" ( ( Goto ( ( card C113 ) + 1 ) ) ";" D67 ) ) ) by SCMFSA6A:29
.= ( D75 ";" ( ( C114 ";" ( Goto ( ( card C113 ) + 1 ) ) ) ";" D67 ) ) by SCMFSA6A:25
.= ( ( Macro D75 ) ";" D68 ) by SCMFSA6A:25;
L564: ( Reloc (D68 , ( card ( Macro D75 ) )) ) c= ( if>0 (C115 , C113 , C114) ) by L563 , L1;
L565: ( card ( Macro D75 ) ) = 2 by COMPOS_1:56;
L566: ( Reloc (D68 , 2) ) c= D72 by L565 , L562 , L564 , XBOOLE_1:1;
L567: (not C115 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L568: ( 0 ) in ( dom ( if>0 (C115 , C113 , C114) ) ) by L128;
L569: ( D72 . ( 0 ) ) = ( ( if>0 (C115 , C113 , C114) ) . ( 0 ) ) by L568 , FUNCT_4:13
.= D75 by L141;
L570: 1 in ( dom ( if>0 (C115 , C113 , C114) ) ) by L128;
L571: ( Comput (D72 , D71 , ( ( 0 ) + 1 )) ) = ( Following (D72 , ( Comput (D72 , D71 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D72 , D71) )
.= ( Exec (D75 , D71) ) by L561 , L569 , PBOOLE:143;
assume L572: ( C112 . C115 ) <= ( 0 );
L573: ( D71 . C115 ) <= ( 0 ) by L572 , L567 , FUNCT_4:11;
L574: ( IC ( Comput (D72 , D71 , 1) ) ) = ( succ ( 0 ) ) by L573 , L561 , L571 , SCMFSA_2:71
.= ( ( 0 ) + 1 );
L575: ( D72 . 1 ) = ( ( if>0 (C115 , C113 , C114) ) . 1 ) by L570 , FUNCT_4:13
.= ( goto 2 ) by L141;
assume L576: C114 is_closed_on C112 , R1;
L577: ( Comput (D72 , D71 , ( 1 + 1 )) ) = ( Following (D72 , D73) ) by EXTPRO_1:3
.= ( Exec (( goto 2 ) , D73) ) by L574 , L575 , PBOOLE:143;
L578:
now
let C116 being FinSeq-Location;
thus L579: ( D69 . C116 ) = ( ( Comput (D72 , D71 , 1) ) . C116 ) by L571 , SCMFSA_2:71
.= ( D74 . C116 ) by L577 , SCMFSA_2:69;
end;
L580:
now
let C117 being Int-Location;
thus L581: ( D69 . C117 ) = ( ( Comput (D72 , D71 , 1) ) . C117 ) by L571 , SCMFSA_2:71
.= ( D74 . C117 ) by L577 , SCMFSA_2:69;
end;
L582: ( DataPart D69 ) = ( DataPart D74 ) by L580 , L578 , SCMFSA_M:2;
assume L583: C114 is_halting_on C112 , R1;
L584: D68 is_closed_on C112 , R1 by L583 , L576 , SCMFSA8A:37;
L585: D68 is_closed_on D69 , D70 by L584 , L84;
L586: D70 halts_on D69 by L576 , L583 , SCMFSA8A:38;
L587: ( IC D74 ) = 2 by L577 , SCMFSA_2:69;
L588:
now
let C118 being (Element of ( NAT ));
L589: (C118 = ( 0 ) or ( ( 0 ) + 1 ) < ( C118 + 1 )) by XREAL_1:6;
L590: (C118 = ( 0 ) or 1 <= C118) by L589 , NAT_1:13;
per cases  by L590 , XXREAL_0:1;
suppose L591: 1 < C118;

consider C119 being Nat such that L592: ( C119 + 1 ) = C118 by L591 , NAT_1:6;
L593: ( ( 0 ) + 1 ) < ( C119 + 1 ) by L591 , L592;
consider C120 being Nat such that L594: ( C120 + 1 ) = C119 by L593 , NAT_1:6;
reconsider D76 = C119 , D77 = C120 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D78 = ( IC ( Comput (D70 , D69 , D77) ) ) as (Element of ( NAT ));
L595: ( card ( if>0 (C115 , C113 , C114) ) ) = ( ( card ( Macro D75 ) ) + ( card D68 ) ) by L563 , SCMFSA6A:21
.= ( 2 + ( card D68 ) ) by COMPOS_1:56;
L596: D78 in ( dom D68 ) by L584 , SCMFSA7B:def 6;
L597: D78 < ( card D68 ) by L596 , AFINSQ_1:66;
L598: ( D78 + 2 ) < ( card ( if>0 (C115 , C113 , C114) ) ) by L597 , L595 , XREAL_1:6;
L599: ( IC ( Comput (D72 , D71 , C118) ) ) = ( IC ( Comput (D72 , D73 , D76) ) ) by L592 , EXTPRO_1:4
.= ( IC ( Comput (D72 , ( Comput (D72 , D73 , 1) ) , D77) ) ) by L594 , EXTPRO_1:4
.= ( IC ( Comput (D72 , ( Comput (D72 , D71 , ( 1 + 1 )) ) , D77) ) ) by EXTPRO_1:4
.= ( D78 + 2 ) by L585 , L587 , L582 , L87 , L566 , L559;
thus L600: ( IC ( Comput (D72 , D71 , C118) ) ) in ( dom ( if>0 (C115 , C113 , C114) ) ) by L599 , L598 , AFINSQ_1:66;
end;
suppose L601: C118 = ( 0 );

thus L602: ( IC ( Comput (D72 , D71 , C118) ) ) in ( dom ( if>0 (C115 , C113 , C114) ) ) by L601 , L568 , L561 , EXTPRO_1:2;
end;
suppose L603: C118 = 1;

thus L604: ( IC ( Comput (D72 , D71 , C118) ) ) in ( dom ( if>0 (C115 , C113 , C114) ) ) by L603 , L574 , L128;
end;
end;
thus L606: ( if>0 (C115 , C113 , C114) ) is_closed_on C112 , R1 by L588 , SCMFSA7B:def 6;
L607: ( CurInstr (D72 , ( Comput (D72 , D71 , ( ( LifeSpan (D70 , D69) ) + 2 )) )) ) = ( CurInstr (D72 , ( Comput (D72 , D74 , ( LifeSpan (D70 , D69) )) )) ) by EXTPRO_1:4
.= ( IncAddr (( CurInstr (D70 , ( Comput (D70 , D69 , ( LifeSpan (D70 , D69) )) )) ) , 2) ) by L585 , L566 , L587 , L582 , L87 , L559
.= ( IncAddr (( halt ( SCM+FSA ) ) , 2) ) by L586 , EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
L608: D72 halts_on D71 by L607 , EXTPRO_1:29;
thus L609: thesis by L608 , SCMFSA7B:def 7;
end;
theorem
L610: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B109 , B110 being (Program of ( SCM+FSA )) holds (for B111 being  read-write Int-Location holds (for B112 being (State of ( SCM+FSA )) holds ((( B112 . B111 ) <= ( 0 ) & B110 is_closed_on ( Initialized B112 ) , R1 & B110 is_halting_on ( Initialized B112 ) , R1) implies ( IExec (( if>0 (B111 , B109 , B110) ) , R1 , B112) ) = ( ( IExec (B110 , R1 , B112) ) +* ( Start-At (( ( ( card B109 ) + ( card B110 ) ) + 3 ) , ( SCM+FSA )) ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C121 , C122 being (Program of ( SCM+FSA ));
let C123 being  read-write Int-Location;
let C124 being (State of ( SCM+FSA ));
set D79 = ( C121 ";" ( Stop ( SCM+FSA ) ) );
set D80 = ( ( ( C122 ";" ( Goto ( ( card C121 ) + 1 ) ) ) ";" C121 ) ";" ( Stop ( SCM+FSA ) ) );
set D81 = ( Initialized C124 );
set D82 = ( R1 +* D80 );
L611: D80 c= D82 by FUNCT_4:25;
set D83 = ( R1 +* ( if>0 (C123 , C121 , C122) ) );
set D84 = ( Comput (D83 , D81 , 1) );
set D85 = ( Comput (D83 , D81 , 2) );
set D86 = ( C123 >0_goto ( ( card C122 ) + 3 ) );
L612: ( 0 ) in ( dom ( if>0 (C123 , C121 , C122) ) ) by L128;
L613: ( D83 . ( 0 ) ) = ( ( if>0 (C123 , C121 , C122) ) . ( 0 ) ) by L612 , FUNCT_4:13
.= D86 by L141;
L614: 1 in ( dom ( if>0 (C123 , C121 , C122) ) ) by L128;
L615: ( D83 . 1 ) = ( ( if>0 (C123 , C121 , C122) ) . 1 ) by L614 , FUNCT_4:13
.= ( goto 2 ) by L141;
L616: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = { ( intloc ( 0 ) ) , ( IC ( SCM+FSA ) ) } by SCMFSA_M:11;
L617: (C123 <> ( intloc ( 0 ) ) & C123 <> ( IC ( SCM+FSA ) )) by SCMFSA_2:56;
L618: (not C123 in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) by L617 , L616 , TARSKI:def 2;
L619: ( IC ( SCM+FSA ) ) in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by MEMSTR_0:48;
L620: ( IC D81 ) = ( IC ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L619 , FUNCT_4:13
.= ( 0 ) by MEMSTR_0:def 11;
L621: ( if>0 (C123 , C121 , C122) ) = ( ( ( D86 ";" C122 ) ";" ( Goto ( ( card C121 ) + 1 ) ) ) ";" D79 ) by SCMFSA6A:25
.= ( ( D86 ";" C122 ) ";" ( ( Goto ( ( card C121 ) + 1 ) ) ";" D79 ) ) by SCMFSA6A:25
.= ( D86 ";" ( C122 ";" ( ( Goto ( ( card C121 ) + 1 ) ) ";" D79 ) ) ) by SCMFSA6A:29
.= ( D86 ";" ( ( C122 ";" ( Goto ( ( card C121 ) + 1 ) ) ) ";" D79 ) ) by SCMFSA6A:25
.= ( ( Macro D86 ) ";" D80 ) by SCMFSA6A:25;
L622: ( Reloc (D80 , ( card ( Macro D86 ) )) ) c= ( if>0 (C123 , C121 , C122) ) by L621 , L1;
L623: ( Reloc (D80 , 2) ) c= ( if>0 (C123 , C121 , C122) ) by L622 , COMPOS_1:56;
L624: ( if>0 (C123 , C121 , C122) ) c= D83 by FUNCT_4:25;
L625: ( Reloc (D80 , 2) ) c= D83 by L624 , L623 , XBOOLE_1:1;
L626: ( Comput (D83 , D81 , ( ( 0 ) + 1 )) ) = ( Following (D83 , ( Comput (D83 , D81 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D83 , D81) )
.= ( Exec (D86 , D81) ) by L620 , L613 , PBOOLE:143;
assume L627: ( C124 . C123 ) <= ( 0 );
L628: ( D81 . C123 ) <= ( 0 ) by L627 , L618 , FUNCT_4:11;
L629: ( IC ( Comput (D83 , D81 , 1) ) ) = ( succ ( 0 ) ) by L628 , L620 , L626 , SCMFSA_2:71
.= ( ( 0 ) + 1 );
assume L630: C122 is_closed_on ( Initialized C124 ) , R1;
L631: ( Comput (D83 , D81 , ( 1 + 1 )) ) = ( Following (D83 , D84) ) by EXTPRO_1:3
.= ( Exec (( goto 2 ) , D84) ) by L629 , L615 , PBOOLE:143;
L632: ( IC D85 ) = 2 by L631 , SCMFSA_2:69;
L633:
now
let C125 being FinSeq-Location;
thus L634: ( D81 . C125 ) = ( ( Comput (D83 , D81 , 1) ) . C125 ) by L626 , SCMFSA_2:71
.= ( D85 . C125 ) by L631 , SCMFSA_2:69;
end;
L635:
now
let C126 being Int-Location;
thus L636: ( D81 . C126 ) = ( ( Comput (D83 , D81 , 1) ) . C126 ) by L626 , SCMFSA_2:71
.= ( D85 . C126 ) by L631 , SCMFSA_2:69;
end;
L637: ( DataPart D81 ) = ( DataPart D85 ) by L635 , L633 , SCMFSA_M:2;
assume L638: C122 is_halting_on ( Initialized C124 ) , R1;
L639: D82 halts_on D81 by L638 , L630 , SCMFSA8A:39;
L640: D80 is_closed_on ( Initialized C124 ) , R1 by L630 , L638 , SCMFSA8A:37;
L641: D80 is_closed_on D81 , D82 by L640 , L81;
L642: ( CurInstr (D83 , ( Comput (D83 , D81 , ( ( LifeSpan (D82 , D81) ) + 2 )) )) ) = ( CurInstr (D83 , ( Comput (D83 , D85 , ( LifeSpan (D82 , D81) )) )) ) by EXTPRO_1:4
.= ( IncAddr (( CurInstr (D82 , ( Comput (D82 , D81 , ( LifeSpan (D82 , D81) )) )) ) , 2) ) by L641 , L632 , L637 , L87 , L625 , L611
.= ( IncAddr (( halt ( SCM+FSA ) ) , 2) ) by L639 , EXTPRO_1:def 15
.= ( halt ( SCM+FSA ) ) by COMPOS_0:4;
L643: D83 halts_on D81 by L642 , EXTPRO_1:29;
L644:
now
let C127 being (Element of ( NAT ));
assume L645: C127 < ( ( LifeSpan (D82 , D81) ) + 2 );
L646: ( Comput (D83 , D81 , ( 0 )) ) = D81;
per cases ;
suppose L647: C127 = ( 0 );

thus L648: ( CurInstr (D83 , ( Comput (D83 , D81 , C127) )) ) <> ( halt ( SCM+FSA ) ) by L647 , L620 , L613 , L646 , PBOOLE:143;
end;
suppose L649: C127 = 1;

thus L650: ( CurInstr (D83 , ( Comput (D83 , D81 , C127) )) ) <> ( halt ( SCM+FSA ) ) by L649 , L629 , L615 , PBOOLE:143;
end;
suppose L651: (C127 <> ( 0 ) & C127 <> 1);

assume L652: ( CurInstr (D83 , ( Comput (D83 , D81 , C127) )) ) = ( halt ( SCM+FSA ) );
consider C128 being Nat such that L653: C127 = ( C128 + 1 ) by L651 , NAT_1:6;
L654: C128 <> ( 0 ) by L651 , L653;
consider C129 being Nat such that L655: C128 = ( C129 + 1 ) by L654 , NAT_1:6;
reconsider D87 = C129 as (Element of ( NAT )) by ORDINAL1:def 12;
L656: ( InsCode ( CurInstr (D82 , ( Comput (D82 , D81 , D87) )) ) ) = ( InsCode ( IncAddr (( CurInstr (D82 , ( Comput (D82 , D81 , D87) )) ) , 2) ) ) by COMPOS_0:def 9
.= ( InsCode ( CurInstr (D83 , ( Comput (D83 , D85 , D87) )) ) ) by L641 , L632 , L637 , L87 , L625 , L611
.= ( InsCode ( CurInstr (D83 , ( Comput (D83 , D81 , ( D87 + ( 1 + 1 ) )) )) ) ) by EXTPRO_1:4
.= ( 0 ) by L653 , L655 , L652 , COMPOS_1:70;
L657: ( CurInstr (D82 , ( Comput (D82 , D81 , D87) )) ) = ( halt ( SCM+FSA ) ) by L656 , SCMFSA_2:95;
L658: ( C128 + 1 ) < ( ( ( LifeSpan (D82 , D81) ) + 1 ) + 1 ) by L645 , L653;
L659: C128 < ( ( LifeSpan (D82 , D81) ) + 1 ) by L658 , XREAL_1:6;
L660: D87 < ( LifeSpan (D82 , D81) ) by L659 , L655 , XREAL_1:6;
thus L661: contradiction by L660 , L639 , L657 , EXTPRO_1:def 15;
end;
end;
L663: (for B113 being (Element of ( NAT )) holds (( CurInstr (D83 , ( Comput (D83 , D81 , B113) )) ) = ( halt ( SCM+FSA ) ) implies ( ( LifeSpan (D82 , D81) ) + 2 ) <= B113)) by L644;
L664: ( LifeSpan (D83 , D81) ) = ( ( LifeSpan (D82 , D81) ) + 2 ) by L663 , L642 , L643 , EXTPRO_1:def 15;
L665: ( DataPart ( Result (D82 , D81) ) ) = ( DataPart ( Comput (D82 , D81 , ( LifeSpan (D82 , D81) )) ) ) by L638 , L630 , EXTPRO_1:23 , SCMFSA8A:39
.= ( DataPart ( Comput (D83 , D85 , ( LifeSpan (D82 , D81) )) ) ) by L641 , L632 , L637 , L87 , L625 , L611
.= ( DataPart ( Comput (D83 , D81 , ( ( LifeSpan (D82 , D81) ) + 2 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (D83 , D81) ) ) by L643 , L664 , EXTPRO_1:23;
L666:
now
let C130 being set;
L667: ( dom ( Start-At (( ( ( card C121 ) + ( card C122 ) ) + 3 ) , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L668: ( IExec (( if>0 (C123 , C121 , C122) ) , R1 , C124) ) = ( Result (D83 , D81) ) by SCMFSA6B:def 1;
L669: ( IExec (D80 , R1 , C124) ) = ( Result (D82 , D81) ) by SCMFSA6B:def 1;
assume L670: C130 in ( dom ( IExec (( if>0 (C123 , C121 , C122) ) , R1 , C124) ) );
per cases  by L670 , SCMFSA_M:1;
suppose L671: C130 is Int-Location;

L672: C130 <> ( IC ( SCM+FSA ) ) by L671 , SCMFSA_2:56;
L673: (not C130 in ( dom ( Start-At (( ( ( card C121 ) + ( card C122 ) ) + 3 ) , ( SCM+FSA )) ) )) by L672 , L667 , TARSKI:def 1;
thus L674: ( ( IExec (( if>0 (C123 , C121 , C122) ) , R1 , C124) ) . C130 ) = ( ( Result (D83 , D81) ) . C130 ) by L668
.= ( ( Result (D82 , D81) ) . C130 ) by L665 , L671 , SCMFSA_M:2
.= ( ( IExec (D80 , R1 , C124) ) . C130 ) by L669
.= ( ( ( IExec (D80 , R1 , C124) ) +* ( Start-At (( ( ( card C121 ) + ( card C122 ) ) + 3 ) , ( SCM+FSA )) ) ) . C130 ) by L673 , FUNCT_4:11;
end;
suppose L675: C130 is FinSeq-Location;

L676: C130 <> ( IC ( SCM+FSA ) ) by L675 , SCMFSA_2:57;
L677: (not C130 in ( dom ( Start-At (( ( ( card C121 ) + ( card C122 ) ) + 3 ) , ( SCM+FSA )) ) )) by L676 , L667 , TARSKI:def 1;
thus L678: ( ( IExec (( if>0 (C123 , C121 , C122) ) , R1 , C124) ) . C130 ) = ( ( Result (D83 , D81) ) . C130 ) by L668
.= ( ( Result (D82 , D81) ) . C130 ) by L665 , L675 , SCMFSA_M:2
.= ( ( IExec (D80 , R1 , C124) ) . C130 ) by L669
.= ( ( ( IExec (D80 , R1 , C124) ) +* ( Start-At (( ( ( card C121 ) + ( card C122 ) ) + 3 ) , ( SCM+FSA )) ) ) . C130 ) by L677 , FUNCT_4:11;
end;
suppose L679: C130 = ( IC ( SCM+FSA ) );

L680: C130 in ( dom ( Start-At (( ( ( card C121 ) + ( card C122 ) ) + 3 ) , ( SCM+FSA )) ) ) by L679 , L667 , TARSKI:def 1;
L681: ( IC ( Result (D82 , D81) ) ) = ( IC ( IExec (D80 , R1 , C124) ) ) by L669
.= ( ( ( card C121 ) + ( card C122 ) ) + 1 ) by L630 , L638 , SCMFSA8A:40;
thus L682: ( ( IExec (( if>0 (C123 , C121 , C122) ) , R1 , C124) ) . C130 ) = ( ( Result (D83 , D81) ) . C130 ) by L668
.= ( ( Comput (D83 , D81 , ( ( LifeSpan (D82 , D81) ) + 2 )) ) . C130 ) by L643 , L664 , EXTPRO_1:23
.= ( IC ( Comput (D83 , D85 , ( LifeSpan (D82 , D81) )) ) ) by L679 , EXTPRO_1:4
.= ( ( IC ( Comput (D82 , D81 , ( LifeSpan (D82 , D81) )) ) ) + 2 ) by L641 , L632 , L637 , L87 , L625 , L611
.= ( ( IC ( Result (D82 , D81) ) ) + 2 ) by L638 , L630 , EXTPRO_1:23 , SCMFSA8A:39
.= ( ( Start-At (( ( ( ( card C121 ) + ( card C122 ) ) + 1 ) + 2 ) , ( SCM+FSA )) ) . ( IC ( SCM+FSA ) ) ) by L681 , FUNCOP_1:72
.= ( ( ( IExec (D80 , R1 , C124) ) +* ( Start-At (( ( ( card C121 ) + ( card C122 ) ) + 3 ) , ( SCM+FSA )) ) ) . C130 ) by L679 , L680 , FUNCT_4:13;
end;
end;
L684: ( dom ( IExec (( if>0 (C123 , C121 , C122) ) , R1 , C124) ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2
.= ( dom ( ( IExec (D80 , R1 , C124) ) +* ( Start-At (( ( ( card C121 ) + ( card C122 ) ) + 3 ) , ( SCM+FSA )) ) ) ) by PARTFUN1:def 2;
thus L685: ( IExec (( if>0 (C123 , C121 , C122) ) , R1 , C124) ) = ( ( IExec (D80 , R1 , C124) ) +* ( Start-At (( ( ( card C121 ) + ( card C122 ) ) + 3 ) , ( SCM+FSA )) ) ) by L684 , L666 , FUNCT_1:2
.= ( ( ( IExec (C122 , R1 , C124) ) +* ( Start-At (( ( ( card C121 ) + ( card C122 ) ) + 1 ) , ( SCM+FSA )) ) ) +* ( Start-At (( ( ( card C121 ) + ( card C122 ) ) + 3 ) , ( SCM+FSA )) ) ) by L630 , L638 , SCMFSA8A:41
.= ( ( IExec (C122 , R1 , C124) ) +* ( Start-At (( ( ( card C121 ) + ( card C122 ) ) + 3 ) , ( SCM+FSA )) ) ) by FUNCT_4:114;
end;
theorem
L686: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B114 being (State of ( SCM+FSA )) holds (for B115 , B116 being  parahalting (Program of ( SCM+FSA )) holds (for B117 being  read-write Int-Location holds (( if>0 (B117 , B115 , B116) ) is  parahalting & (( B114 . B117 ) > ( 0 ) implies ( IExec (( if>0 (B117 , B115 , B116) ) , R1 , B114) ) = ( ( IExec (B115 , R1 , B114) ) +* ( Start-At (( ( ( card B115 ) + ( card B116 ) ) + 3 ) , ( SCM+FSA )) ) )) & (( B114 . B117 ) <= ( 0 ) implies ( IExec (( if>0 (B117 , B115 , B116) ) , R1 , B114) ) = ( ( IExec (B116 , R1 , B114) ) +* ( Start-At (( ( ( card B115 ) + ( card B116 ) ) + 3 ) , ( SCM+FSA )) ) )))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C131 being (State of ( SCM+FSA ));
let C132 , C133 being  parahalting (Program of ( SCM+FSA ));
let C134 being  read-write Int-Location;
L687: C132 is_halting_on ( Initialized C131 ) , R1 by SCMFSA7B:19;
L688: (for B118 being ( 0 ) -started (State of ( SCM+FSA )) holds (for B119 being (Instruction-Sequence of ( SCM+FSA )) holds (( if>0 (C134 , C132 , C133) ) c= B119 implies B119 halts_on B118)))
proof
let C135 being ( 0 ) -started (State of ( SCM+FSA ));
L689: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C135 by MEMSTR_0:29;
L690: C135 = ( Initialize C135 ) by L689 , FUNCT_4:98;
let C136 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L691: ( if>0 (C134 , C132 , C133) ) c= C136;
L692: ( if>0 (C134 , C132 , C133) ) c= C136 by L691;
L693: C132 is_closed_on C135 , C136 by SCMFSA7B:18;
L694: C132 is_halting_on C135 , C136 by SCMFSA7B:19;
L695: C133 is_halting_on C135 , C136 by SCMFSA7B:19;
L696: C133 is_closed_on C135 , C136 by SCMFSA7B:18;
L697: ( C136 +* ( if>0 (C134 , C132 , C133) ) ) = C136 by L692 , FUNCT_4:98;
per cases ;
suppose L698: ( C135 . C134 ) > ( 0 );

L699: ( if>0 (C134 , C132 , C133) ) is_halting_on C135 , C136 by L698 , L693 , L694 , L449;
thus L700: C136 halts_on C135 by L699 , L690 , L697 , SCMFSA7B:def 7;
end;
suppose L701: ( C135 . C134 ) <= ( 0 );

L702: ( if>0 (C134 , C132 , C133) ) is_halting_on C135 , C136 by L701 , L696 , L695 , L558;
thus L703: C136 halts_on C135 by L702 , L690 , L697 , SCMFSA7B:def 7;
end;
end;
thus L705: ( if>0 (C134 , C132 , C133) ) is  parahalting by L688 , AMISTD_1:def 11;
L706: C133 is_closed_on ( Initialized C131 ) , R1 by SCMFSA7B:18;
L707: C132 is_closed_on ( Initialized C131 ) , R1 by SCMFSA7B:18;
thus L708: (( C131 . C134 ) > ( 0 ) implies ( IExec (( if>0 (C134 , C132 , C133) ) , R1 , C131) ) = ( ( IExec (C132 , R1 , C131) ) +* ( Start-At (( ( ( card C132 ) + ( card C133 ) ) + 3 ) , ( SCM+FSA )) ) )) by L707 , L687 , L493;
L709: C133 is_halting_on ( Initialized C131 ) , R1 by SCMFSA7B:19;
thus L710: thesis by L709 , L610 , L706;
end;
theorem
L711: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B120 being (State of ( SCM+FSA )) holds (for B121 , B122 being  parahalting (Program of ( SCM+FSA )) holds (for B123 being  read-write Int-Location holds (( IC ( IExec (( if>0 (B123 , B121 , B122) ) , R1 , B120) ) ) = ( ( ( card B121 ) + ( card B122 ) ) + 3 ) & (( B120 . B123 ) > ( 0 ) implies ((for B124 being Int-Location holds ( ( IExec (( if>0 (B123 , B121 , B122) ) , R1 , B120) ) . B124 ) = ( ( IExec (B121 , R1 , B120) ) . B124 )) & (for B125 being FinSeq-Location holds ( ( IExec (( if>0 (B123 , B121 , B122) ) , R1 , B120) ) . B125 ) = ( ( IExec (B121 , R1 , B120) ) . B125 )))) & (( B120 . B123 ) <= ( 0 ) implies ((for B126 being Int-Location holds ( ( IExec (( if>0 (B123 , B121 , B122) ) , R1 , B120) ) . B126 ) = ( ( IExec (B122 , R1 , B120) ) . B126 )) & (for B127 being FinSeq-Location holds ( ( IExec (( if>0 (B123 , B121 , B122) ) , R1 , B120) ) . B127 ) = ( ( IExec (B122 , R1 , B120) ) . B127 )))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C137 being (State of ( SCM+FSA ));
let C138 , C139 being  parahalting (Program of ( SCM+FSA ));
let C140 being  read-write Int-Location;
thus L712:now
per cases ;
suppose L713: ( C137 . C140 ) > ( 0 );

L714: ( IExec (( if>0 (C140 , C138 , C139) ) , R1 , C137) ) = ( ( IExec (C138 , R1 , C137) ) +* ( Start-At (( ( ( card C138 ) + ( card C139 ) ) + 3 ) , ( SCM+FSA )) ) ) by L713 , L686;
thus L715: ( IC ( IExec (( if>0 (C140 , C138 , C139) ) , R1 , C137) ) ) = ( ( ( card C138 ) + ( card C139 ) ) + 3 ) by L714 , FUNCT_4:113;
end;
suppose L716: ( C137 . C140 ) <= ( 0 );

L717: ( IExec (( if>0 (C140 , C138 , C139) ) , R1 , C137) ) = ( ( IExec (C139 , R1 , C137) ) +* ( Start-At (( ( ( card C138 ) + ( card C139 ) ) + 3 ) , ( SCM+FSA )) ) ) by L716 , L686;
thus L718: ( IC ( IExec (( if>0 (C140 , C138 , C139) ) , R1 , C137) ) ) = ( ( ( card C138 ) + ( card C139 ) ) + 3 ) by L717 , FUNCT_4:113;
end;
end;
thus L720:now
assume L721: ( C137 . C140 ) > ( 0 );
L722: ( IExec (( if>0 (C140 , C138 , C139) ) , R1 , C137) ) = ( ( IExec (C138 , R1 , C137) ) +* ( Start-At (( ( ( card C138 ) + ( card C139 ) ) + 3 ) , ( SCM+FSA )) ) ) by L721 , L686;
thus L723:now
let C141 being Int-Location;
L724: (not C141 in ( dom ( Start-At (( ( ( card C138 ) + ( card C139 ) ) + 3 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
thus L725: ( ( IExec (( if>0 (C140 , C138 , C139) ) , R1 , C137) ) . C141 ) = ( ( IExec (C138 , R1 , C137) ) . C141 ) by L724 , L722 , FUNCT_4:11;
end;
let C142 being FinSeq-Location;
L726: (not C142 in ( dom ( Start-At (( ( ( card C138 ) + ( card C139 ) ) + 3 ) , ( SCM+FSA )) ) )) by SCMFSA_2:103;
thus L727: ( ( IExec (( if>0 (C140 , C138 , C139) ) , R1 , C137) ) . C142 ) = ( ( IExec (C138 , R1 , C137) ) . C142 ) by L726 , L722 , FUNCT_4:11;
end;
assume L728: ( C137 . C140 ) <= ( 0 );
L729: ( IExec (( if>0 (C140 , C138 , C139) ) , R1 , C137) ) = ( ( IExec (C139 , R1 , C137) ) +* ( Start-At (( ( ( card C138 ) + ( card C139 ) ) + 3 ) , ( SCM+FSA )) ) ) by L728 , L686;
thus L730:now
let C143 being Int-Location;
L731: (not C143 in ( dom ( Start-At (( ( ( card C138 ) + ( card C139 ) ) + 3 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
thus L732: ( ( IExec (( if>0 (C140 , C138 , C139) ) , R1 , C137) ) . C143 ) = ( ( IExec (C139 , R1 , C137) ) . C143 ) by L731 , L729 , FUNCT_4:11;
end;
let C144 being FinSeq-Location;
L733: (not C144 in ( dom ( Start-At (( ( ( card C138 ) + ( card C139 ) ) + 3 ) , ( SCM+FSA )) ) )) by SCMFSA_2:103;
thus L734: thesis by L733 , L729 , FUNCT_4:11;
end;
theorem
L735: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B128 being (State of ( SCM+FSA )) holds (for B129 , B130 being (Program of ( SCM+FSA )) holds (for B131 being  read-write Int-Location holds ((( B128 . B131 ) < ( 0 ) & B129 is_closed_on B128 , R1 & B129 is_halting_on B128 , R1) implies (( if<0 (B131 , B129 , B130) ) is_closed_on B128 , R1 & ( if<0 (B131 , B129 , B130) ) is_halting_on B128 , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C145 being (State of ( SCM+FSA ));
let C146 , C147 being (Program of ( SCM+FSA ));
let C148 being  read-write Int-Location;
assume L736: ( C145 . C148 ) < ( 0 );
assume that
L737: C146 is_closed_on C145 , R1
and
L738: C146 is_halting_on C145 , R1;
L739: ( if>0 (C148 , C147 , C146) ) is_halting_on C145 , R1 by L736 , L737 , L738 , L558;
L740: ( if>0 (C148 , C147 , C146) ) is_closed_on C145 , R1 by L736 , L737 , L738 , L558;
thus L741: thesis by L740 , L736 , L739 , L269;
end;
theorem
L742: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B132 being (State of ( SCM+FSA )) holds (for B133 , B134 being (Program of ( SCM+FSA )) holds (for B135 being  read-write Int-Location holds ((( B132 . B135 ) < ( 0 ) & B133 is_closed_on ( Initialized B132 ) , R1 & B133 is_halting_on ( Initialized B132 ) , R1) implies ( IExec (( if<0 (B135 , B133 , B134) ) , R1 , B132) ) = ( ( IExec (B133 , R1 , B132) ) +* ( Start-At (( ( ( ( card B133 ) + ( card B134 ) ) + ( card B134 ) ) + 7 ) , ( SCM+FSA )) ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C149 being (State of ( SCM+FSA ));
let C150 , C151 being (Program of ( SCM+FSA ));
let C152 being  read-write Int-Location;
assume L743: ( C149 . C152 ) < ( 0 );
assume that
L744: C150 is_closed_on ( Initialized C149 ) , R1
and
L745: C150 is_halting_on ( Initialized C149 ) , R1;
L746: ( ( Initialized C149 ) . C152 ) <= ( 0 ) by L743 , SCMFSA_M:37;
L747: ( if>0 (C152 , C151 , C150) ) is_halting_on ( Initialized C149 ) , R1 by L746 , L744 , L745 , L558;
L748: ( if>0 (C152 , C151 , C150) ) is_closed_on ( Initialized C149 ) , R1 by L744 , L745 , L746 , L558;
thus L749: ( IExec (( if<0 (C152 , C150 , C151) ) , R1 , C149) ) = ( ( IExec (( if>0 (C152 , C151 , C150) ) , R1 , C149) ) +* ( Start-At (( ( ( card ( if>0 (C152 , C151 , C150) ) ) + ( card C151 ) ) + 3 ) , ( SCM+FSA )) ) ) by L748 , L743 , L747 , L322
.= ( ( IExec (( if>0 (C152 , C151 , C150) ) , R1 , C149) ) +* ( Start-At (( ( ( ( ( card C150 ) + ( card C151 ) ) + 4 ) + ( card C151 ) ) + 3 ) , ( SCM+FSA )) ) ) by L157
.= ( ( ( IExec (C150 , R1 , C149) ) +* ( Start-At (( ( ( card C150 ) + ( card C151 ) ) + 3 ) , ( SCM+FSA )) ) ) +* ( Start-At (( ( ( ( ( card C150 ) + ( card C151 ) ) + 4 ) + ( card C151 ) ) + 3 ) , ( SCM+FSA )) ) ) by L743 , L744 , L745 , L610
.= ( ( IExec (C150 , R1 , C149) ) +* ( Start-At (( ( ( ( card C150 ) + ( card C151 ) ) + ( card C151 ) ) + 7 ) , ( SCM+FSA )) ) ) by FUNCT_4:114;
end;
theorem
L750: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B136 being (State of ( SCM+FSA )) holds (for B137 , B138 being (Program of ( SCM+FSA )) holds (for B139 being  read-write Int-Location holds ((( B136 . B139 ) = ( 0 ) & B138 is_closed_on B136 , R1 & B138 is_halting_on B136 , R1) implies (( if<0 (B139 , B137 , B138) ) is_closed_on B136 , R1 & ( if<0 (B139 , B137 , B138) ) is_halting_on B136 , R1)))))) by L160;
theorem
L751: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B140 being (State of ( SCM+FSA )) holds (for B141 , B142 being (Program of ( SCM+FSA )) holds (for B143 being  read-write Int-Location holds ((( B140 . B143 ) = ( 0 ) & B142 is_closed_on ( Initialized B140 ) , R1 & B142 is_halting_on ( Initialized B140 ) , R1) implies ( IExec (( if<0 (B143 , B141 , B142) ) , R1 , B140) ) = ( ( IExec (B142 , R1 , B140) ) +* ( Start-At (( ( ( ( card B141 ) + ( card B142 ) ) + ( card B142 ) ) + 7 ) , ( SCM+FSA )) ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C153 being (State of ( SCM+FSA ));
let C154 , C155 being (Program of ( SCM+FSA ));
let C156 being  read-write Int-Location;
assume L752: ( C153 . C156 ) = ( 0 );
assume that
L753: C155 is_closed_on ( Initialized C153 ) , R1
and
L754: C155 is_halting_on ( Initialized C153 ) , R1;
thus L755: ( IExec (( if<0 (C156 , C154 , C155) ) , R1 , C153) ) = ( ( IExec (C155 , R1 , C153) ) +* ( Start-At (( ( ( card ( if>0 (C156 , C155 , C154) ) ) + ( card C155 ) ) + 3 ) , ( SCM+FSA )) ) ) by L752 , L753 , L754 , L204
.= ( ( IExec (C155 , R1 , C153) ) +* ( Start-At (( ( ( ( ( card C154 ) + ( card C155 ) ) + 4 ) + ( card C155 ) ) + 3 ) , ( SCM+FSA )) ) ) by L157
.= ( ( IExec (C155 , R1 , C153) ) +* ( Start-At (( ( ( ( card C154 ) + ( card C155 ) ) + ( card C155 ) ) + 7 ) , ( SCM+FSA )) ) );
end;
theorem
L756: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B144 being (State of ( SCM+FSA )) holds (for B145 , B146 being (Program of ( SCM+FSA )) holds (for B147 being  read-write Int-Location holds ((( B144 . B147 ) > ( 0 ) & B146 is_closed_on B144 , R1 & B146 is_halting_on B144 , R1) implies (( if<0 (B147 , B145 , B146) ) is_closed_on B144 , R1 & ( if<0 (B147 , B145 , B146) ) is_halting_on B144 , R1))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C157 being (State of ( SCM+FSA ));
let C158 , C159 being (Program of ( SCM+FSA ));
let C160 being  read-write Int-Location;
assume L757: ( C157 . C160 ) > ( 0 );
assume that
L758: C159 is_closed_on C157 , R1
and
L759: C159 is_halting_on C157 , R1;
L760: ( if>0 (C160 , C159 , C158) ) is_halting_on C157 , R1 by L757 , L758 , L759 , L449;
L761: ( if>0 (C160 , C159 , C158) ) is_closed_on C157 , R1 by L757 , L758 , L759 , L449;
thus L762: thesis by L761 , L757 , L760 , L269;
end;
theorem
L763: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B148 being (State of ( SCM+FSA )) holds (for B149 , B150 being (Program of ( SCM+FSA )) holds (for B151 being  read-write Int-Location holds ((( B148 . B151 ) > ( 0 ) & B150 is_closed_on ( Initialized B148 ) , R1 & B150 is_halting_on ( Initialized B148 ) , R1) implies ( IExec (( if<0 (B151 , B149 , B150) ) , R1 , B148) ) = ( ( IExec (B150 , R1 , B148) ) +* ( Start-At (( ( ( ( card B149 ) + ( card B150 ) ) + ( card B150 ) ) + 7 ) , ( SCM+FSA )) ) ))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C161 being (State of ( SCM+FSA ));
let C162 , C163 being (Program of ( SCM+FSA ));
let C164 being  read-write Int-Location;
assume L764: ( C161 . C164 ) > ( 0 );
assume that
L765: C163 is_closed_on ( Initialized C161 ) , R1
and
L766: C163 is_halting_on ( Initialized C161 ) , R1;
L767: ( ( Initialized C161 ) . C164 ) > ( 0 ) by L764 , SCMFSA_M:37;
L768: ( if>0 (C164 , C163 , C162) ) is_halting_on ( Initialized C161 ) , R1 by L767 , L765 , L766 , L449;
L769: ( if>0 (C164 , C163 , C162) ) is_closed_on ( Initialized C161 ) , R1 by L765 , L766 , L767 , L449;
thus L770: ( IExec (( if<0 (C164 , C162 , C163) ) , R1 , C161) ) = ( ( IExec (( if>0 (C164 , C163 , C162) ) , R1 , C161) ) +* ( Start-At (( ( ( card ( if>0 (C164 , C163 , C162) ) ) + ( card C163 ) ) + 3 ) , ( SCM+FSA )) ) ) by L769 , L764 , L768 , L322
.= ( ( IExec (( if>0 (C164 , C163 , C162) ) , R1 , C161) ) +* ( Start-At (( ( ( ( ( card C162 ) + ( card C163 ) ) + 4 ) + ( card C163 ) ) + 3 ) , ( SCM+FSA )) ) ) by L157
.= ( ( ( IExec (C163 , R1 , C161) ) +* ( Start-At (( ( ( card C162 ) + ( card C163 ) ) + 3 ) , ( SCM+FSA )) ) ) +* ( Start-At (( ( ( ( ( card C162 ) + ( card C163 ) ) + 4 ) + ( card C163 ) ) + 3 ) , ( SCM+FSA )) ) ) by L764 , L765 , L766 , L493
.= ( ( IExec (C163 , R1 , C161) ) +* ( Start-At (( ( ( ( card C162 ) + ( card C163 ) ) + ( card C163 ) ) + 7 ) , ( SCM+FSA )) ) ) by FUNCT_4:114;
end;
theorem
L771: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B152 being (State of ( SCM+FSA )) holds (for B153 , B154 being  parahalting (Program of ( SCM+FSA )) holds (for B155 being  read-write Int-Location holds (( if<0 (B155 , B153 , B154) ) is  parahalting & (( B152 . B155 ) < ( 0 ) implies ( IExec (( if<0 (B155 , B153 , B154) ) , R1 , B152) ) = ( ( IExec (B153 , R1 , B152) ) +* ( Start-At (( ( ( ( card B153 ) + ( card B154 ) ) + ( card B154 ) ) + 7 ) , ( SCM+FSA )) ) )) & (( B152 . B155 ) >= ( 0 ) implies ( IExec (( if<0 (B155 , B153 , B154) ) , R1 , B152) ) = ( ( IExec (B154 , R1 , B152) ) +* ( Start-At (( ( ( ( card B153 ) + ( card B154 ) ) + ( card B154 ) ) + 7 ) , ( SCM+FSA )) ) )))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C165 being (State of ( SCM+FSA ));
let C166 , C167 being  parahalting (Program of ( SCM+FSA ));
let C168 being  read-write Int-Location;
L772: ( if>0 (C168 , C167 , C166) ) is  parahalting by L686;
thus L773: ( if<0 (C168 , C166 , C167) ) is  parahalting by L772 , L400;
L774: C166 is_closed_on ( Initialized C165 ) , R1 by SCMFSA7B:18;
thus L775:now
L776: C166 is_halting_on ( Initialized C165 ) , R1 by SCMFSA7B:19;
assume L777: ( C165 . C168 ) < ( 0 );
thus L778: ( IExec (( if<0 (C168 , C166 , C167) ) , R1 , C165) ) = ( ( IExec (C166 , R1 , C165) ) +* ( Start-At (( ( ( ( card C166 ) + ( card C167 ) ) + ( card C167 ) ) + 7 ) , ( SCM+FSA )) ) ) by L777 , L776 , L742 , L774;
end;
thus L779:now
assume L780: ( C165 . C168 ) >= ( 0 );
L781: C167 is_halting_on ( Initialized C165 ) , R1 by SCMFSA7B:19;
L782: C167 is_closed_on ( Initialized C165 ) , R1 by SCMFSA7B:18;
per cases ;
suppose L783: ( C165 . C168 ) = ( 0 );

thus L784: ( IExec (( if<0 (C168 , C166 , C167) ) , R1 , C165) ) = ( ( IExec (C167 , R1 , C165) ) +* ( Start-At (( ( ( ( card C166 ) + ( card C167 ) ) + ( card C167 ) ) + 7 ) , ( SCM+FSA )) ) ) by L783 , L781 , L751 , L782;
end;
suppose L785: ( C165 . C168 ) <> ( 0 );

thus L786: ( IExec (( if<0 (C168 , C166 , C167) ) , R1 , C165) ) = ( ( IExec (C167 , R1 , C165) ) +* ( Start-At (( ( ( ( card C166 ) + ( card C167 ) ) + ( card C167 ) ) + 7 ) , ( SCM+FSA )) ) ) by L785 , L780 , L781 , L763 , L782;
end;
end;
end;
registration
let C169 , C170 being  parahalting (Program of ( SCM+FSA ));
let C171 being  read-write Int-Location;
cluster ( if=0 (C171 , C169 , C170) ) ->  parahalting;
correctness by L400;
cluster ( if>0 (C171 , C169 , C170) ) ->  parahalting;
correctness by L686;
end;
definition
let C172 , C173 being Int-Location;
let C174 , C175 being (Program of ( SCM+FSA ));
func if=0 (C172 , C173 , C174 , C175) -> (Program of ( SCM+FSA )) equals 
( ( SubFrom (C172 , C173) ) ";" ( if=0 (C172 , C174 , C175) ) );
coherence;
func if>0 (C172 , C173 , C174 , C175) -> (Program of ( SCM+FSA )) equals 
( ( SubFrom (C172 , C173) ) ";" ( if>0 (C172 , C174 , C175) ) );
coherence;
end;
registration
let C176 being Int-Location;
let C177 , C178 being (Program of ( SCM+FSA ));
cluster ( if=0 (C176 , C177 , C178) ) -> non  halt-free;
coherence;
cluster ( if>0 (C176 , C177 , C178) ) -> non  halt-free;
coherence;
cluster ( if<0 (C176 , C177 , C178) ) -> non  halt-free;
coherence;
end;
registration
let C179 , C180 being Int-Location;
let C181 , C182 being (Program of ( SCM+FSA ));
cluster ( if=0 (C179 , C180 , C181 , C182) ) -> non  halt-free;
coherence;
cluster ( if>0 (C179 , C180 , C181 , C182) ) -> non  halt-free;
coherence;
end;
notation
let C183 , C184 being Int-Location;
let C185 , C186 being (Program of ( SCM+FSA ));
synonym if<0 (C184 , C183 , C185 , C186) for if>0 (C183 , C184 , C185 , C186);
end;
registration
let C187 , C188 being  parahalting (Program of ( SCM+FSA ));
let C189 , C190 being  read-write Int-Location;
cluster ( if=0 (C189 , C190 , C187 , C188) ) ->  parahalting;
correctness;
cluster ( if>0 (C189 , C190 , C187 , C188) ) ->  parahalting;
correctness;
end;
theorem
L786: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B156 being (State of ( SCM+FSA )) holds (for B157 being (Program of ( SCM+FSA )) holds ( DataPart ( Result (( R1 +* B157 ) , ( Initialized B156 )) ) ) = ( DataPart ( IExec (B157 , R1 , B156) ) )))) by SCMFSA6B:def 1;
theorem
L787: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B158 being (State of ( SCM+FSA )) holds (for B159 being (Program of ( SCM+FSA )) holds ( Result (( R1 +* B159 ) , ( Initialized B158 )) ) = ( IExec (B159 , R1 , B158) )))) by SCMFSA6B:def 1;
theorem
L788: (for B160 , B161 being (State of ( SCM+FSA )) holds (for B162 being (Instruction of ( SCM+FSA )) holds (for B163 being Int-Location holds (((for B164 being Int-Location holds (B163 <> B164 implies ( B160 . B164 ) = ( B161 . B164 ))) & (for B165 being FinSeq-Location holds ( B160 . B165 ) = ( B161 . B165 )) & (not B162 refer B163) & ( IC B160 ) = ( IC B161 )) implies ((for B166 being Int-Location holds (B163 <> B166 implies ( ( Exec (B162 , B160) ) . B166 ) = ( ( Exec (B162 , B161) ) . B166 ))) & (for B167 being FinSeq-Location holds ( ( Exec (B162 , B160) ) . B167 ) = ( ( Exec (B162 , B161) ) . B167 )) & ( IC ( Exec (B162 , B160) ) ) = ( IC ( Exec (B162 , B161) ) ))))))
proof
let C191 , C192 being (State of ( SCM+FSA ));
let C193 being (Instruction of ( SCM+FSA ));
let C194 being Int-Location;
defpred S4[ (State of ( SCM+FSA )) , (State of ( SCM+FSA )) ] means ((for B168 being Int-Location holds (C194 <> B168 implies ( $1 . B168 ) = ( $2 . B168 ))) & (for B169 being FinSeq-Location holds ( $1 . B169 ) = ( $2 . B169 )));
assume L789: S4[ C191 , C192 ];
assume L790: (not C193 refer C194);
L791: ( InsCode C193 ) <= 12 by SCMFSA_2:16;
L792:
now
let C195 being Int-Location;
assume L793: C194 <> C195;
per cases  by L791 , NAT_1:36;
suppose L794: ( InsCode C193 ) = ( 0 );

L795: C193 = ( halt ( SCM+FSA ) ) by L794 , SCMFSA_2:95;
thus L796: ( ( Exec (C193 , C191) ) . C195 ) = ( C191 . C195 ) by L795 , EXTPRO_1:def 3
.= ( C192 . C195 ) by L789 , L793
.= ( ( Exec (C193 , C192) ) . C195 ) by L795 , EXTPRO_1:def 3;
end;
suppose L797: ( InsCode C193 ) = 1;

consider C196 , C197 being Int-Location such that L798: C193 = ( C196 := C197 ) by L797 , SCMFSA_2:30;
L799: C194 <> C197 by L790 , L798 , SCMFSA7B:def 1;
thus L800:now
per cases ;
suppose L801: C195 = C196;

thus L802: ( ( Exec (C193 , C191) ) . C195 ) = ( C191 . C197 ) by L801 , L798 , SCMFSA_2:63
.= ( C192 . C197 ) by L789 , L799
.= ( ( Exec (C193 , C192) ) . C195 ) by L798 , L801 , SCMFSA_2:63;
end;
suppose L803: C195 <> C196;

thus L804: ( ( Exec (C193 , C191) ) . C195 ) = ( C191 . C195 ) by L803 , L798 , SCMFSA_2:63
.= ( C192 . C195 ) by L789 , L793
.= ( ( Exec (C193 , C192) ) . C195 ) by L798 , L803 , SCMFSA_2:63;
end;
end;
end;
suppose L801: ( InsCode C193 ) = 2;

consider C198 , C199 being Int-Location such that L802: C193 = ( AddTo (C198 , C199) ) by L801 , SCMFSA_2:31;
L803: C194 <> C199 by L790 , L802 , SCMFSA7B:def 1;
thus L804:now
per cases ;
suppose L805: C195 = C198;

thus L806: ( ( Exec (C193 , C191) ) . C195 ) = ( ( C191 . C195 ) + ( C191 . C199 ) ) by L805 , L802 , SCMFSA_2:64
.= ( ( C192 . C195 ) + ( C191 . C199 ) ) by L789 , L793
.= ( ( C192 . C195 ) + ( C192 . C199 ) ) by L789 , L803
.= ( ( Exec (C193 , C192) ) . C195 ) by L802 , L805 , SCMFSA_2:64;
end;
suppose L807: C195 <> C198;

thus L808: ( ( Exec (C193 , C191) ) . C195 ) = ( C191 . C195 ) by L807 , L802 , SCMFSA_2:64
.= ( C192 . C195 ) by L789 , L793
.= ( ( Exec (C193 , C192) ) . C195 ) by L802 , L807 , SCMFSA_2:64;
end;
end;
end;
suppose L805: ( InsCode C193 ) = 3;

consider C200 , C201 being Int-Location such that L806: C193 = ( SubFrom (C200 , C201) ) by L805 , SCMFSA_2:32;
L807: C194 <> C201 by L790 , L806 , SCMFSA7B:def 1;
thus L808:now
per cases ;
suppose L809: C195 = C200;

thus L810: ( ( Exec (C193 , C191) ) . C195 ) = ( ( C191 . C195 ) - ( C191 . C201 ) ) by L809 , L806 , SCMFSA_2:65
.= ( ( C192 . C195 ) - ( C191 . C201 ) ) by L789 , L793
.= ( ( C192 . C195 ) - ( C192 . C201 ) ) by L789 , L807
.= ( ( Exec (C193 , C192) ) . C195 ) by L806 , L809 , SCMFSA_2:65;
end;
suppose L811: C195 <> C200;

thus L812: ( ( Exec (C193 , C191) ) . C195 ) = ( C191 . C195 ) by L811 , L806 , SCMFSA_2:65
.= ( C192 . C195 ) by L789 , L793
.= ( ( Exec (C193 , C192) ) . C195 ) by L806 , L811 , SCMFSA_2:65;
end;
end;
end;
suppose L809: ( InsCode C193 ) = 4;

consider C202 , C203 being Int-Location such that L810: C193 = ( MultBy (C202 , C203) ) by L809 , SCMFSA_2:33;
L811: C194 <> C203 by L790 , L810 , SCMFSA7B:def 1;
thus L812:now
per cases ;
suppose L813: C195 = C202;

thus L814: ( ( Exec (C193 , C191) ) . C195 ) = ( ( C191 . C195 ) * ( C191 . C203 ) ) by L813 , L810 , SCMFSA_2:66
.= ( ( C192 . C195 ) * ( C191 . C203 ) ) by L789 , L793
.= ( ( C192 . C195 ) * ( C192 . C203 ) ) by L789 , L811
.= ( ( Exec (C193 , C192) ) . C195 ) by L810 , L813 , SCMFSA_2:66;
end;
suppose L815: C195 <> C202;

thus L816: ( ( Exec (C193 , C191) ) . C195 ) = ( C191 . C195 ) by L815 , L810 , SCMFSA_2:66
.= ( C192 . C195 ) by L789 , L793
.= ( ( Exec (C193 , C192) ) . C195 ) by L810 , L815 , SCMFSA_2:66;
end;
end;
end;
suppose L813: ( InsCode C193 ) = 5;

consider C204 , C205 being Int-Location such that L814: C193 = ( Divide (C204 , C205) ) by L813 , SCMFSA_2:34;
L815: C194 <> C205 by L790 , L814 , SCMFSA7B:def 1;
L816: C194 <> C204 by L790 , L814 , SCMFSA7B:def 1;
thus L817:now
per cases ;
suppose L818: C195 = C205;

thus L819: ( ( Exec (C193 , C191) ) . C195 ) = ( ( C191 . C204 ) mod ( C191 . C205 ) ) by L818 , L814 , SCMFSA_2:67
.= ( ( C192 . C204 ) mod ( C191 . C205 ) ) by L789 , L816
.= ( ( C192 . C204 ) mod ( C192 . C205 ) ) by L789 , L815
.= ( ( Exec (C193 , C192) ) . C195 ) by L814 , L818 , SCMFSA_2:67;
end;
suppose L820: (C195 = C204 & C195 <> C205);

thus L821: ( ( Exec (C193 , C191) ) . C195 ) = ( ( C191 . C204 ) div ( C191 . C205 ) ) by L820 , L814 , SCMFSA_2:67
.= ( ( C191 . C204 ) div ( C192 . C205 ) ) by L789 , L815
.= ( ( C192 . C204 ) div ( C192 . C205 ) ) by L789 , L816
.= ( ( Exec (C193 , C192) ) . C195 ) by L814 , L820 , SCMFSA_2:67;
end;
suppose L822: (C195 <> C204 & C195 <> C205);

thus L823: ( ( Exec (C193 , C191) ) . C195 ) = ( C191 . C195 ) by L822 , L814 , SCMFSA_2:67
.= ( C192 . C195 ) by L789 , L793
.= ( ( Exec (C193 , C192) ) . C195 ) by L814 , L822 , SCMFSA_2:67;
end;
end;
end;
suppose L818: ( InsCode C193 ) = 6;

L819: (ex B170 being (Element of ( NAT )) st C193 = ( goto B170 )) by L818 , SCMFSA_2:35;
thus L820: ( ( Exec (C193 , C191) ) . C195 ) = ( C191 . C195 ) by L819 , SCMFSA_2:69
.= ( C192 . C195 ) by L789 , L793
.= ( ( Exec (C193 , C192) ) . C195 ) by L819 , SCMFSA_2:69;
end;
suppose L821: ( InsCode C193 ) = 7;

L822: (ex B171 being (Element of ( NAT )) st (ex B172 being Int-Location st C193 = ( B172 =0_goto B171 ))) by L821 , SCMFSA_2:36;
thus L823: ( ( Exec (C193 , C191) ) . C195 ) = ( C191 . C195 ) by L822 , SCMFSA_2:70
.= ( C192 . C195 ) by L789 , L793
.= ( ( Exec (C193 , C192) ) . C195 ) by L822 , SCMFSA_2:70;
end;
suppose L824: ( InsCode C193 ) = 8;

L825: (ex B173 being (Element of ( NAT )) st (ex B174 being Int-Location st C193 = ( B174 >0_goto B173 ))) by L824 , SCMFSA_2:37;
thus L826: ( ( Exec (C193 , C191) ) . C195 ) = ( C191 . C195 ) by L825 , SCMFSA_2:71
.= ( C192 . C195 ) by L789 , L793
.= ( ( Exec (C193 , C192) ) . C195 ) by L825 , SCMFSA_2:71;
end;
suppose L827: ( InsCode C193 ) = 9;

consider C206 , C207 being Int-Location, C208 being FinSeq-Location such that L828: C193 = ( C207 := (C208 , C206) ) by L827 , SCMFSA_2:38;
L829: C194 <> C206 by L790 , L828 , SCMFSA7B:def 1;
thus L830:now
per cases ;
suppose L831: C195 = C207;

consider C209 being (Element of ( NAT )) such that L832: C209 = ( abs ( C192 . C206 ) ) and L833: ( ( Exec (( C207 := (C208 , C206) ) , C192) ) . C195 ) = ( ( C192 . C208 ) /. C209 ) by L831 , SCMFSA_2:72;
consider C210 being (Element of ( NAT )) such that L834: C210 = ( abs ( C191 . C206 ) ) and L835: ( ( Exec (( C207 := (C208 , C206) ) , C191) ) . C195 ) = ( ( C191 . C208 ) /. C210 ) by L831 , SCMFSA_2:72;
L836: C210 = C209 by L789 , L829 , L834 , L832;
thus L837: ( ( Exec (C193 , C191) ) . C195 ) = ( ( Exec (C193 , C192) ) . C195 ) by L836 , L789 , L828 , L835 , L833;
end;
suppose L838: C195 <> C207;

thus L839: ( ( Exec (C193 , C191) ) . C195 ) = ( C191 . C195 ) by L838 , L828 , SCMFSA_2:72
.= ( C192 . C195 ) by L789 , L793
.= ( ( Exec (C193 , C192) ) . C195 ) by L828 , L838 , SCMFSA_2:72;
end;
end;
end;
suppose L831: ( InsCode C193 ) = 10;

L832: (ex B175 , B176 being Int-Location st (ex B177 being FinSeq-Location st C193 = ( (B177 , B175) := B176 ))) by L831 , SCMFSA_2:39;
thus L833: ( ( Exec (C193 , C191) ) . C195 ) = ( C191 . C195 ) by L832 , SCMFSA_2:73
.= ( C192 . C195 ) by L789 , L793
.= ( ( Exec (C193 , C192) ) . C195 ) by L832 , SCMFSA_2:73;
end;
suppose L834: ( InsCode C193 ) = 11;

consider C211 being Int-Location, C212 being FinSeq-Location such that L835: C193 = ( C211 :=len C212 ) by L834 , SCMFSA_2:40;
thus L836:now
per cases ;
suppose L837: C195 = C211;

thus L838: ( ( Exec (C193 , C191) ) . C195 ) = ( len ( C191 . C212 ) ) by L837 , L835 , SCMFSA_2:74
.= ( len ( C192 . C212 ) ) by L789
.= ( ( Exec (C193 , C192) ) . C195 ) by L835 , L837 , SCMFSA_2:74;
end;
suppose L839: C195 <> C211;

thus L840: ( ( Exec (C193 , C191) ) . C195 ) = ( C191 . C195 ) by L839 , L835 , SCMFSA_2:74
.= ( C192 . C195 ) by L789 , L793
.= ( ( Exec (C193 , C192) ) . C195 ) by L835 , L839 , SCMFSA_2:74;
end;
end;
end;
suppose L837: ( InsCode C193 ) = 12;

L838: (ex B178 being Int-Location st (ex B179 being FinSeq-Location st C193 = ( B179 :=<0,...,0> B178 ))) by L837 , SCMFSA_2:41;
thus L839: ( ( Exec (C193 , C191) ) . C195 ) = ( C191 . C195 ) by L838 , SCMFSA_2:75
.= ( C192 . C195 ) by L789 , L793
.= ( ( Exec (C193 , C192) ) . C195 ) by L838 , SCMFSA_2:75;
end;
end;
assume L841: ( IC C191 ) = ( IC C192 );
L842:
now
let C213 being FinSeq-Location;
per cases  by L791 , NAT_1:36;
suppose L843: ( InsCode C193 ) = ( 0 );

L844: C193 = ( halt ( SCM+FSA ) ) by L843 , SCMFSA_2:95;
thus L845: ( ( Exec (C193 , C191) ) . C213 ) = ( C191 . C213 ) by L844 , EXTPRO_1:def 3
.= ( C192 . C213 ) by L789
.= ( ( Exec (C193 , C192) ) . C213 ) by L844 , EXTPRO_1:def 3;
end;
suppose L846: ( InsCode C193 ) = 1;

L847: (ex B180 , B181 being Int-Location st C193 = ( B180 := B181 )) by L846 , SCMFSA_2:30;
thus L848: ( ( Exec (C193 , C191) ) . C213 ) = ( C191 . C213 ) by L847 , SCMFSA_2:63
.= ( C192 . C213 ) by L789
.= ( ( Exec (C193 , C192) ) . C213 ) by L847 , SCMFSA_2:63;
end;
suppose L849: ( InsCode C193 ) = 2;

L850: (ex B182 , B183 being Int-Location st C193 = ( AddTo (B182 , B183) )) by L849 , SCMFSA_2:31;
thus L851: ( ( Exec (C193 , C191) ) . C213 ) = ( C191 . C213 ) by L850 , SCMFSA_2:64
.= ( C192 . C213 ) by L789
.= ( ( Exec (C193 , C192) ) . C213 ) by L850 , SCMFSA_2:64;
end;
suppose L852: ( InsCode C193 ) = 3;

L853: (ex B184 , B185 being Int-Location st C193 = ( SubFrom (B184 , B185) )) by L852 , SCMFSA_2:32;
thus L854: ( ( Exec (C193 , C191) ) . C213 ) = ( C191 . C213 ) by L853 , SCMFSA_2:65
.= ( C192 . C213 ) by L789
.= ( ( Exec (C193 , C192) ) . C213 ) by L853 , SCMFSA_2:65;
end;
suppose L855: ( InsCode C193 ) = 4;

L856: (ex B186 , B187 being Int-Location st C193 = ( MultBy (B186 , B187) )) by L855 , SCMFSA_2:33;
thus L857: ( ( Exec (C193 , C191) ) . C213 ) = ( C191 . C213 ) by L856 , SCMFSA_2:66
.= ( C192 . C213 ) by L789
.= ( ( Exec (C193 , C192) ) . C213 ) by L856 , SCMFSA_2:66;
end;
suppose L858: ( InsCode C193 ) = 5;

L859: (ex B188 , B189 being Int-Location st C193 = ( Divide (B188 , B189) )) by L858 , SCMFSA_2:34;
thus L860: ( ( Exec (C193 , C191) ) . C213 ) = ( C191 . C213 ) by L859 , SCMFSA_2:67
.= ( C192 . C213 ) by L789
.= ( ( Exec (C193 , C192) ) . C213 ) by L859 , SCMFSA_2:67;
end;
suppose L861: ( InsCode C193 ) = 6;

L862: (ex B190 being (Element of ( NAT )) st C193 = ( goto B190 )) by L861 , SCMFSA_2:35;
thus L863: ( ( Exec (C193 , C191) ) . C213 ) = ( C191 . C213 ) by L862 , SCMFSA_2:69
.= ( C192 . C213 ) by L789
.= ( ( Exec (C193 , C192) ) . C213 ) by L862 , SCMFSA_2:69;
end;
suppose L864: ( InsCode C193 ) = 7;

L865: (ex B191 being (Element of ( NAT )) st (ex B192 being Int-Location st C193 = ( B192 =0_goto B191 ))) by L864 , SCMFSA_2:36;
thus L866: ( ( Exec (C193 , C191) ) . C213 ) = ( C191 . C213 ) by L865 , SCMFSA_2:70
.= ( C192 . C213 ) by L789
.= ( ( Exec (C193 , C192) ) . C213 ) by L865 , SCMFSA_2:70;
end;
suppose L867: ( InsCode C193 ) = 8;

L868: (ex B193 being (Element of ( NAT )) st (ex B194 being Int-Location st C193 = ( B194 >0_goto B193 ))) by L867 , SCMFSA_2:37;
thus L869: ( ( Exec (C193 , C191) ) . C213 ) = ( C191 . C213 ) by L868 , SCMFSA_2:71
.= ( C192 . C213 ) by L789
.= ( ( Exec (C193 , C192) ) . C213 ) by L868 , SCMFSA_2:71;
end;
suppose L870: ( InsCode C193 ) = 9;

L871: (ex B195 , B196 being Int-Location st (ex B197 being FinSeq-Location st C193 = ( B196 := (B197 , B195) ))) by L870 , SCMFSA_2:38;
thus L872: ( ( Exec (C193 , C191) ) . C213 ) = ( C191 . C213 ) by L871 , SCMFSA_2:72
.= ( C192 . C213 ) by L789
.= ( ( Exec (C193 , C192) ) . C213 ) by L871 , SCMFSA_2:72;
end;
suppose L873: ( InsCode C193 ) = 10;

consider C214 , C215 being Int-Location, C216 being FinSeq-Location such that L874: C193 = ( (C216 , C214) := C215 ) by L873 , SCMFSA_2:39;
L875: C194 <> C214 by L790 , L874 , SCMFSA7B:def 1;
L876: C194 <> C215 by L790 , L874 , SCMFSA7B:def 1;
thus L877:now
per cases ;
suppose L878: C213 = C216;

L879: ( C191 . C215 ) = ( C192 . C215 ) by L789 , L876;
consider C217 being (Element of ( NAT )) such that L880: C217 = ( abs ( C192 . C214 ) ) and L881: ( ( Exec (( (C216 , C214) := C215 ) , C192) ) . C216 ) = ( ( C192 . C216 ) +* (C217 , ( C192 . C215 )) ) by SCMFSA_2:73;
consider C218 being (Element of ( NAT )) such that L882: C218 = ( abs ( C191 . C214 ) ) and L883: ( ( Exec (( (C216 , C214) := C215 ) , C191) ) . C216 ) = ( ( C191 . C216 ) +* (C218 , ( C191 . C215 )) ) by SCMFSA_2:73;
L884: C218 = C217 by L789 , L875 , L882 , L880;
thus L885: ( ( Exec (C193 , C191) ) . C213 ) = ( ( Exec (C193 , C192) ) . C213 ) by L884 , L789 , L874 , L878 , L883 , L881 , L879;
end;
suppose L886: C213 <> C216;

thus L887: ( ( Exec (C193 , C191) ) . C213 ) = ( C191 . C213 ) by L886 , L874 , SCMFSA_2:73
.= ( C192 . C213 ) by L789
.= ( ( Exec (C193 , C192) ) . C213 ) by L874 , L886 , SCMFSA_2:73;
end;
end;
end;
suppose L878: ( InsCode C193 ) = 11;

L879: (ex B198 being Int-Location st (ex B199 being FinSeq-Location st C193 = ( B198 :=len B199 ))) by L878 , SCMFSA_2:40;
thus L880: ( ( Exec (C193 , C191) ) . C213 ) = ( C191 . C213 ) by L879 , SCMFSA_2:74
.= ( C192 . C213 ) by L789
.= ( ( Exec (C193 , C192) ) . C213 ) by L879 , SCMFSA_2:74;
end;
suppose L881: ( InsCode C193 ) = 12;

consider C219 being Int-Location, C220 being FinSeq-Location such that L882: C193 = ( C220 :=<0,...,0> C219 ) by L881 , SCMFSA_2:41;
L883: C194 <> C219 by L790 , L882 , SCMFSA7B:def 1;
thus L884:now
per cases ;
suppose L885: C213 = C220;

L886: (ex B200 being (Element of ( NAT )) st (B200 = ( abs ( C192 . C219 ) ) & ( ( Exec (( C220 :=<0,...,0> C219 ) , C192) ) . C220 ) = ( B200 |-> ( 0 ) ))) by SCMFSA_2:75;
L887: (ex B201 being (Element of ( NAT )) st (B201 = ( abs ( C191 . C219 ) ) & ( ( Exec (( C220 :=<0,...,0> C219 ) , C191) ) . C220 ) = ( B201 |-> ( 0 ) ))) by SCMFSA_2:75;
thus L888: ( ( Exec (C193 , C191) ) . C213 ) = ( ( Exec (C193 , C192) ) . C213 ) by L887 , L789 , L882 , L883 , L885 , L886;
end;
suppose L889: C213 <> C220;

thus L890: ( ( Exec (C193 , C191) ) . C213 ) = ( C191 . C213 ) by L889 , L882 , SCMFSA_2:75
.= ( C192 . C213 ) by L789
.= ( ( Exec (C193 , C192) ) . C213 ) by L882 , L889 , SCMFSA_2:75;
end;
end;
end;
end;
thus L886: S4[ ( Exec (C193 , C191) ) , ( Exec (C193 , C192) ) ] by L842 , L792;
L887:
now
per cases  by L791 , NAT_1:36;
suppose L888: ( InsCode C193 ) = ( 0 );

L889: C193 = ( halt ( SCM+FSA ) ) by L888 , SCMFSA_2:95;
thus L890: ( ( Exec (C193 , C191) ) . ( IC ( SCM+FSA ) ) ) = ( IC C191 ) by L889 , EXTPRO_1:def 3
.= ( ( Exec (C193 , C192) ) . ( IC ( SCM+FSA ) ) ) by L841 , L889 , EXTPRO_1:def 3;
end;
suppose L891: ( InsCode C193 ) = 1;

L892: (ex B202 , B203 being Int-Location st C193 = ( B202 := B203 )) by L891 , SCMFSA_2:30;
thus L893: ( ( Exec (C193 , C191) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC C191 ) ) by L892 , SCMFSA_2:63
.= ( ( Exec (C193 , C192) ) . ( IC ( SCM+FSA ) ) ) by L841 , L892 , SCMFSA_2:63;
end;
suppose L894: ( InsCode C193 ) = 2;

L895: (ex B204 , B205 being Int-Location st C193 = ( AddTo (B204 , B205) )) by L894 , SCMFSA_2:31;
thus L896: ( ( Exec (C193 , C191) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC C191 ) ) by L895 , SCMFSA_2:64
.= ( ( Exec (C193 , C192) ) . ( IC ( SCM+FSA ) ) ) by L841 , L895 , SCMFSA_2:64;
end;
suppose L897: ( InsCode C193 ) = 3;

L898: (ex B206 , B207 being Int-Location st C193 = ( SubFrom (B206 , B207) )) by L897 , SCMFSA_2:32;
thus L899: ( ( Exec (C193 , C191) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC C191 ) ) by L898 , SCMFSA_2:65
.= ( ( Exec (C193 , C192) ) . ( IC ( SCM+FSA ) ) ) by L841 , L898 , SCMFSA_2:65;
end;
suppose L900: ( InsCode C193 ) = 4;

L901: (ex B208 , B209 being Int-Location st C193 = ( MultBy (B208 , B209) )) by L900 , SCMFSA_2:33;
thus L902: ( ( Exec (C193 , C191) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC C191 ) ) by L901 , SCMFSA_2:66
.= ( ( Exec (C193 , C192) ) . ( IC ( SCM+FSA ) ) ) by L841 , L901 , SCMFSA_2:66;
end;
suppose L903: ( InsCode C193 ) = 5;

L904: (ex B210 , B211 being Int-Location st C193 = ( Divide (B210 , B211) )) by L903 , SCMFSA_2:34;
thus L905: ( ( Exec (C193 , C191) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC C191 ) ) by L904 , SCMFSA_2:67
.= ( ( Exec (C193 , C192) ) . ( IC ( SCM+FSA ) ) ) by L841 , L904 , SCMFSA_2:67;
end;
suppose L906: ( InsCode C193 ) = 6;

consider C221 being (Element of ( NAT )) such that L907: C193 = ( goto C221 ) by L906 , SCMFSA_2:35;
thus L908: ( ( Exec (C193 , C191) ) . ( IC ( SCM+FSA ) ) ) = C221 by L907 , SCMFSA_2:69
.= ( ( Exec (C193 , C192) ) . ( IC ( SCM+FSA ) ) ) by L907 , SCMFSA_2:69;
end;
suppose L909: ( InsCode C193 ) = 7;

consider C222 being (Element of ( NAT )), C223 being Int-Location such that L910: C193 = ( C223 =0_goto C222 ) by L909 , SCMFSA_2:36;
L911: C194 <> C223 by L790 , L910 , SCMFSA7B:def 1;
L912: ( C191 . C223 ) = ( C192 . C223 ) by L911 , L789;
thus L913:now
per cases ;
suppose L914: ( C191 . C223 ) = ( 0 );

thus L915: ( ( Exec (C193 , C191) ) . ( IC ( SCM+FSA ) ) ) = C222 by L914 , L910 , SCMFSA_2:70
.= ( ( Exec (C193 , C192) ) . ( IC ( SCM+FSA ) ) ) by L910 , L912 , L914 , SCMFSA_2:70;
end;
suppose L916: ( C191 . C223 ) <> ( 0 );

thus L917: ( ( Exec (C193 , C191) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC C191 ) ) by L916 , L910 , SCMFSA_2:70
.= ( ( Exec (C193 , C192) ) . ( IC ( SCM+FSA ) ) ) by L841 , L910 , L912 , L916 , SCMFSA_2:70;
end;
end;
end;
suppose L914: ( InsCode C193 ) = 8;

consider C224 being (Element of ( NAT )), C225 being Int-Location such that L915: C193 = ( C225 >0_goto C224 ) by L914 , SCMFSA_2:37;
L916: C194 <> C225 by L790 , L915 , SCMFSA7B:def 1;
L917: ( C191 . C225 ) = ( C192 . C225 ) by L916 , L789;
thus L918:now
per cases ;
suppose L919: ( C191 . C225 ) > ( 0 );

thus L920: ( ( Exec (C193 , C191) ) . ( IC ( SCM+FSA ) ) ) = C224 by L919 , L915 , SCMFSA_2:71
.= ( ( Exec (C193 , C192) ) . ( IC ( SCM+FSA ) ) ) by L915 , L917 , L919 , SCMFSA_2:71;
end;
suppose L921: ( C191 . C225 ) <= ( 0 );

thus L922: ( ( Exec (C193 , C191) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC C191 ) ) by L921 , L915 , SCMFSA_2:71
.= ( ( Exec (C193 , C192) ) . ( IC ( SCM+FSA ) ) ) by L841 , L915 , L917 , L921 , SCMFSA_2:71;
end;
end;
end;
suppose L919: ( InsCode C193 ) = 9;

L920: (ex B212 , B213 being Int-Location st (ex B214 being FinSeq-Location st C193 = ( B213 := (B214 , B212) ))) by L919 , SCMFSA_2:38;
thus L921: ( ( Exec (C193 , C191) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC C191 ) ) by L920 , SCMFSA_2:72
.= ( ( Exec (C193 , C192) ) . ( IC ( SCM+FSA ) ) ) by L841 , L920 , SCMFSA_2:72;
end;
suppose L922: ( InsCode C193 ) = 10;

L923: (ex B215 , B216 being Int-Location st (ex B217 being FinSeq-Location st C193 = ( (B217 , B215) := B216 ))) by L922 , SCMFSA_2:39;
thus L924: ( ( Exec (C193 , C191) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC C191 ) ) by L923 , SCMFSA_2:73
.= ( ( Exec (C193 , C192) ) . ( IC ( SCM+FSA ) ) ) by L841 , L923 , SCMFSA_2:73;
end;
suppose L925: ( InsCode C193 ) = 11;

L926: (ex B218 being Int-Location st (ex B219 being FinSeq-Location st C193 = ( B218 :=len B219 ))) by L925 , SCMFSA_2:40;
thus L927: ( ( Exec (C193 , C191) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC C191 ) ) by L926 , SCMFSA_2:74
.= ( ( Exec (C193 , C192) ) . ( IC ( SCM+FSA ) ) ) by L841 , L926 , SCMFSA_2:74;
end;
suppose L928: ( InsCode C193 ) = 12;

L929: (ex B220 being Int-Location st (ex B221 being FinSeq-Location st C193 = ( B221 :=<0,...,0> B220 ))) by L928 , SCMFSA_2:41;
thus L930: ( ( Exec (C193 , C191) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC C191 ) ) by L929 , SCMFSA_2:75
.= ( ( Exec (C193 , C192) ) . ( IC ( SCM+FSA ) ) ) by L841 , L929 , SCMFSA_2:75;
end;
end;
thus L932: thesis by L887;
end;
theorem
L933: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for R3 being (Instruction-Sequence of ( SCM+FSA )) holds (for B222 , B223 being (State of ( SCM+FSA )) holds (for B224 being (Program of ( SCM+FSA )) holds (for B225 being Int-Location holds (((not B224 refer B225) & (for B226 being Int-Location holds (B225 <> B226 implies ( B222 . B226 ) = ( B223 . B226 ))) & (for B227 being FinSeq-Location holds ( B222 . B227 ) = ( B223 . B227 )) & B224 is_closed_on B222 , R2) implies (for B228 being (Element of ( NAT )) holds ((for B229 being Int-Location holds (B225 <> B229 implies ( ( Comput (( R2 +* B224 ) , ( Initialize B222 ) , B228) ) . B229 ) = ( ( Comput (( R3 +* B224 ) , ( Initialize B223 ) , B228) ) . B229 ))) & (for B230 being FinSeq-Location holds ( ( Comput (( R2 +* B224 ) , ( Initialize B222 ) , B228) ) . B230 ) = ( ( Comput (( R3 +* B224 ) , ( Initialize B223 ) , B228) ) . B230 )) & ( IC ( Comput (( R2 +* B224 ) , ( Initialize B222 ) , B228) ) ) = ( IC ( Comput (( R3 +* B224 ) , ( Initialize B223 ) , B228) ) ) & ( CurInstr (( R2 +* B224 ) , ( Comput (( R2 +* B224 ) , ( Initialize B222 ) , B228) )) ) = ( CurInstr (( R3 +* B224 ) , ( Comput (( R3 +* B224 ) , ( Initialize B223 ) , B228) )) )))))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let R3 being (Instruction-Sequence of ( SCM+FSA ));
let C226 , C227 being (State of ( SCM+FSA ));
let C228 being (Program of ( SCM+FSA ));
let C229 being Int-Location;
assume L934: (not C228 refer C229);
set D88 = ( Initialize C227 );
set D89 = ( R3 +* C228 );
set D90 = ( Initialize C226 );
set D91 = ( R2 +* C228 );
L935: C228 c= D91 by FUNCT_4:25;
L936: C228 c= D89 by FUNCT_4:25;
defpred S5[ (State of ( SCM+FSA )) , (State of ( SCM+FSA )) ] means ((for B231 being Int-Location holds (C229 <> B231 implies ( $1 . B231 ) = ( $2 . B231 ))) & (for B232 being FinSeq-Location holds ( $1 . B232 ) = ( $2 . B232 )));
assume that
L937: (for B233 being Int-Location holds (C229 <> B233 implies ( C226 . B233 ) = ( C227 . B233 )))
and
L938: (for B234 being FinSeq-Location holds ( C226 . B234 ) = ( C227 . B234 ));
L939: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L940:
now
let C230 being FinSeq-Location;
L941: (not C230 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:103;
thus L942: ( D90 . C230 ) = ( C226 . C230 ) by L941 , FUNCT_4:11
.= ( C227 . C230 ) by L938
.= ( D88 . C230 ) by L941 , FUNCT_4:11;
end;
defpred S6[ Nat ] means (S5[ ( Comput (D91 , D90 , $1) ) , ( Comput (D89 , D88 , $1) ) ] & ( IC ( Comput (D91 , D90 , $1) ) ) = ( IC ( Comput (D89 , D88 , $1) ) ) & ( CurInstr (D91 , ( Comput (D91 , D90 , $1) )) ) = ( CurInstr (D89 , ( Comput (D89 , D88 , $1) )) ));
L943: ( IC ( Comput (D91 , D90 , ( 0 )) ) ) = ( IC D90 )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L939 , FUNCT_4:13
.= ( IC D88 ) by L939 , FUNCT_4:13
.= ( IC ( Comput (D89 , D88 , ( 0 )) ) );
L944:
now
let C231 being Int-Location;
assume L945: C229 <> C231;
L946: (not C231 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
thus L947: ( D90 . C231 ) = ( C226 . C231 ) by L946 , FUNCT_4:11
.= ( C227 . C231 ) by L937 , L945
.= ( D88 . C231 ) by L946 , FUNCT_4:11;
end;
assume that
L948: C228 is_closed_on C226 , R2;
L949: ( IC ( Comput (D91 , D90 , ( 0 )) ) ) in ( dom C228 ) by L948 , SCMFSA7B:def 6;
L950: (for B235 being (Element of ( NAT )) holds (S6[ B235 ] implies S6[ ( B235 + 1 ) ]))
proof
let C232 being (Element of ( NAT ));
L951: ( Comput (D91 , D90 , ( C232 + 1 )) ) = ( Following (D91 , ( Comput (D91 , D90 , C232) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D91 , ( Comput (D91 , D90 , C232) )) ) , ( Comput (D91 , D90 , C232) )) );
L952: ( IC ( Comput (D91 , D90 , C232) ) ) in ( dom C228 ) by L948 , SCMFSA7B:def 6;
L953: ( Comput (D89 , D88 , ( C232 + 1 )) ) = ( Following (D89 , ( Comput (D89 , D88 , C232) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D89 , ( Comput (D89 , D88 , C232) )) ) , ( Comput (D89 , D88 , C232) )) );
L954: ( D91 /. ( IC ( Comput (D91 , D90 , C232) ) ) ) = ( D91 . ( IC ( Comput (D91 , D90 , C232) ) ) ) by PBOOLE:143;
L955: ( CurInstr (D91 , ( Comput (D91 , D90 , C232) )) ) = ( C228 . ( IC ( Comput (D91 , D90 , C232) ) ) ) by L952 , L954 , L935 , GRFUNC_1:2;
L956: ( CurInstr (D91 , ( Comput (D91 , D90 , C232) )) ) in ( rng C228 ) by L955 , L952 , FUNCT_1:def 3;
L957: (not ( CurInstr (D91 , ( Comput (D91 , D90 , C232) )) ) refer C229) by L956 , L934 , SCMFSA7B:def 2;
assume L958: S6[ C232 ];
thus L959: S5[ ( Comput (D91 , D90 , ( C232 + 1 )) ) , ( Comput (D89 , D88 , ( C232 + 1 )) ) ] by L958 , L951 , L953 , L957 , L788;
thus L960: ( IC ( Comput (D91 , D90 , ( C232 + 1 )) ) ) = ( IC ( Comput (D89 , D88 , ( C232 + 1 )) ) ) by L958 , L951 , L953 , L957 , L788;
L961: ( IC ( Comput (D91 , D90 , ( C232 + 1 )) ) ) in ( dom C228 ) by L948 , SCMFSA7B:def 6;
L962: ( D91 /. ( IC ( Comput (D91 , D90 , ( C232 + 1 )) ) ) ) = ( D91 . ( IC ( Comput (D91 , D90 , ( C232 + 1 )) ) ) ) by PBOOLE:143;
L963: ( D89 /. ( IC ( Comput (D89 , D88 , ( C232 + 1 )) ) ) ) = ( D89 . ( IC ( Comput (D89 , D88 , ( C232 + 1 )) ) ) ) by PBOOLE:143;
thus L964: ( CurInstr (D91 , ( Comput (D91 , D90 , ( C232 + 1 )) )) ) = ( C228 . ( IC ( Comput (D91 , D90 , ( C232 + 1 )) ) ) ) by L961 , L962 , L935 , GRFUNC_1:2
.= ( CurInstr (D89 , ( Comput (D89 , D88 , ( C232 + 1 )) )) ) by L960 , L961 , L963 , L936 , GRFUNC_1:2;
end;
L965: ( CurInstr (D91 , ( Comput (D91 , D90 , ( 0 )) )) ) = ( D91 . ( IC ( Comput (D91 , D90 , ( 0 )) ) ) ) by PBOOLE:143
.= ( C228 . ( IC ( Comput (D91 , D90 , ( 0 )) ) ) ) by L949 , L935 , GRFUNC_1:2
.= ( D89 . ( IC ( Comput (D89 , D88 , ( 0 )) ) ) ) by L943 , L949 , L936 , GRFUNC_1:2
.= ( CurInstr (D89 , ( Comput (D89 , D88 , ( 0 )) )) ) by PBOOLE:143;
L966: S6[ ( 0 ) ] by L965 , L944 , L940 , L943;
L967: (for B236 being (Element of ( NAT )) holds S6[ B236 ]) from NAT_1:sch 1(L966 , L950);
thus L968: thesis by L967;
end;
theorem
L969: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B237 being (State of ( SCM+FSA )) holds (for B238 , B239 being (Program of ( SCM+FSA )) holds (for B240 being (Element of ( NAT )) holds ((B238 is_closed_on B237 , R1 & B238 is_halting_on B237 , R1) iff (B238 is_closed_on ( B237 +* ( Start-At (B240 , ( SCM+FSA )) ) ) , ( R1 +* B238 ) & B238 is_halting_on ( B237 +* ( Start-At (B240 , ( SCM+FSA )) ) ) , ( R1 +* B238 )))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C233 being (State of ( SCM+FSA ));
let C234 , C235 being (Program of ( SCM+FSA ));
let C236 being (Element of ( NAT ));
L970: ( DataPart C233 ) = ( DataPart ( C233 +* ( Start-At (C236 , ( SCM+FSA )) ) ) ) by MEMSTR_0:79;
thus L971: thesis by L970 , L41;
end;
theorem
L972: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for R3 being (Instruction-Sequence of ( SCM+FSA )) holds (for B241 , B242 being (State of ( SCM+FSA )) holds (for B243 being (Program of ( SCM+FSA )) holds (for B244 being Int-Location holds (((not B243 refer B244) & (for B245 being Int-Location holds (B244 <> B245 implies ( B241 . B245 ) = ( B242 . B245 ))) & (for B246 being FinSeq-Location holds ( B241 . B246 ) = ( B242 . B246 )) & B243 is_closed_on B241 , R2 & B243 is_halting_on B241 , R2) implies (B243 is_closed_on B242 , R3 & B243 is_halting_on B242 , R3)))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let R3 being (Instruction-Sequence of ( SCM+FSA ));
let C237 , C238 being (State of ( SCM+FSA ));
let C239 being (Program of ( SCM+FSA ));
let C240 being Int-Location;
assume L973: (not C239 refer C240);
set D92 = ( Initialize C238 );
set D93 = ( R3 +* C239 );
set D94 = ( Initialize C237 );
set D95 = ( R2 +* C239 );
assume L974: (for B247 being Int-Location holds (C240 <> B247 implies ( C237 . B247 ) = ( C238 . B247 )));
assume L975: (for B248 being FinSeq-Location holds ( C237 . B248 ) = ( C238 . B248 ));
assume that
L976: C239 is_closed_on C237 , R2
and
L977: C239 is_halting_on C237 , R2;
L978:
now
let C241 being (Element of ( NAT ));
L979: ( IC ( Comput (D95 , D94 , C241) ) ) in ( dom C239 ) by L976 , SCMFSA7B:def 6;
thus L980: ( IC ( Comput (D93 , D92 , C241) ) ) in ( dom C239 ) by L979 , L973 , L933 , L976 , L975 , L974;
end;
L981: D95 halts_on D94 by L977 , SCMFSA7B:def 7;
consider C242 being (Element of ( NAT )) such that L982: ( CurInstr (D95 , ( Comput (D95 , D94 , C242) )) ) = ( halt ( SCM+FSA ) ) by L981 , EXTPRO_1:29;
L983: ( CurInstr (D93 , ( Comput (D93 , D92 , C242) )) ) = ( halt ( SCM+FSA ) ) by L973 , L982 , L933 , L976 , L975 , L974;
L984: D93 halts_on D92 by L983 , EXTPRO_1:29;
thus L985: thesis by L984 , L978 , SCMFSA7B:def 6 , SCMFSA7B:def 7;
end;
theorem
L986: (for R2 being (Instruction-Sequence of ( SCM+FSA )) holds (for R3 being (Instruction-Sequence of ( SCM+FSA )) holds (for B249 , B250 being (State of ( SCM+FSA )) holds (for B251 being (Program of ( SCM+FSA )) holds (for B252 being Int-Location holds (((for B253 being  read-write Int-Location holds (B252 <> B253 implies ( B249 . B253 ) = ( B250 . B253 ))) & (for B254 being FinSeq-Location holds ( B249 . B254 ) = ( B250 . B254 )) & (not B251 refer B252) & B251 is_closed_on ( Initialized B249 ) , R2 & B251 is_halting_on ( Initialized B249 ) , R2) implies ((for B255 being Int-Location holds (B252 <> B255 implies ( ( IExec (B251 , R2 , B249) ) . B255 ) = ( ( IExec (B251 , R3 , B250) ) . B255 ))) & (for B256 being FinSeq-Location holds ( ( IExec (B251 , R2 , B249) ) . B256 ) = ( ( IExec (B251 , R3 , B250) ) . B256 )) & ( IC ( IExec (B251 , R2 , B249) ) ) = ( IC ( IExec (B251 , R3 , B250) ) ))))))))
proof
let R2 being (Instruction-Sequence of ( SCM+FSA ));
let R3 being (Instruction-Sequence of ( SCM+FSA ));
let C243 , C244 being (State of ( SCM+FSA ));
let C245 being (Program of ( SCM+FSA ));
let C246 being Int-Location;
assume that
L987: (for B257 being  read-write Int-Location holds (C246 <> B257 implies ( C243 . B257 ) = ( C244 . B257 )))
and
L988: (for B258 being FinSeq-Location holds ( C243 . B258 ) = ( C244 . B258 ));
L989:
now
let C247 being Int-Location;
assume L990: C246 <> C247;
per cases ;
suppose L991: C247 = ( intloc ( 0 ) );

thus L992: ( ( Initialized C243 ) . C247 ) = 1 by L991 , SCMFSA_M:9
.= ( ( Initialized C244 ) . C247 ) by L991 , SCMFSA_M:9;
end;
suppose L993: C247 <> ( intloc ( 0 ) );

L994: C247 is  read-write by L993 , SCMFSA_M:def 2;
thus L995: ( ( Initialized C243 ) . C247 ) = ( C243 . C247 ) by L994 , SCMFSA_M:37
.= ( C244 . C247 ) by L987 , L990 , L994
.= ( ( Initialized C244 ) . C247 ) by L994 , SCMFSA_M:37;
end;
end;
set D96 = ( Initialized C243 );
set D97 = ( R2 +* C245 );
set D98 = ( Initialized C244 );
set D99 = ( R3 +* C245 );
assume L997: (not C245 refer C246);
L998: D98 = ( Initialize ( Initialized C244 ) ) by MEMSTR_0:44;
assume that
L999: C245 is_closed_on ( Initialized C243 ) , R2
and
L1000: C245 is_halting_on ( Initialized C243 ) , R2;
L1001:
now
let C248 being FinSeq-Location;
thus L1002: ( ( Initialized C243 ) . C248 ) = ( C243 . C248 ) by SCMFSA_M:37
.= ( C244 . C248 ) by L988
.= ( ( Initialized C244 ) . C248 ) by SCMFSA_M:37;
end;
L1003: C245 is_halting_on ( Initialized C244 ) , R3 by L1001 , L997 , L999 , L1000 , L989 , L972;
L1004: D99 halts_on D98 by L1003 , L998 , SCMFSA7B:def 7;
L1005: D96 = ( Initialize ( Initialized C243 ) ) by MEMSTR_0:44;
L1006: D97 halts_on D96 by L1005 , L1000 , SCMFSA7B:def 7;
L1007:
now
let C249 being (Element of ( NAT ));
assume L1008: C249 < ( LifeSpan (D97 , D96) );
L1009: ( CurInstr (D97 , ( Comput (D97 , D96 , C249) )) ) <> ( halt ( SCM+FSA ) ) by L1008 , L1006 , EXTPRO_1:def 15;
thus L1010: ( CurInstr (D99 , ( Comput (D99 , D98 , C249) )) ) <> ( halt ( SCM+FSA ) ) by L1009 , L997 , L999 , L989 , L1001 , L1005 , L998 , L933;
end;
L1011: (for B259 being (Element of ( NAT )) holds (( CurInstr (D99 , ( Comput (D99 , D98 , B259) )) ) = ( halt ( SCM+FSA ) ) implies ( LifeSpan (D97 , D96) ) <= B259)) by L1007;
L1012: ( CurInstr (D99 , ( Comput (D99 , D98 , ( LifeSpan (D97 , D96) )) )) ) = ( CurInstr (D97 , ( Comput (D97 , D96 , ( LifeSpan (D97 , D96) )) )) ) by L997 , L999 , L989 , L1001 , L1005 , L998 , L933
.= ( halt ( SCM+FSA ) ) by L1006 , EXTPRO_1:def 15;
L1013: ( LifeSpan (D97 , D96) ) = ( LifeSpan (D99 , D98) ) by L1012 , L1004 , L1011 , EXTPRO_1:def 15;
L1014: ( Result (D99 , D98) ) = ( Comput (D99 , D98 , ( LifeSpan (D97 , D96) )) ) by L1013 , L1004 , EXTPRO_1:23;
L1015: ( Result (D97 , D96) ) = ( Comput (D97 , D96 , ( LifeSpan (D97 , D96) )) ) by L1006 , EXTPRO_1:23;
L1016: ( Result (( R2 +* C245 ) , ( Initialized C243 )) ) = ( IExec (C245 , R2 , C243) ) by L787;
L1017: ( Result (( R3 +* C245 ) , ( Initialized C244 )) ) = ( IExec (C245 , R3 , C244) ) by L787;
thus L1018: (for B260 being Int-Location holds (C246 <> B260 implies ( ( IExec (C245 , R2 , C243) ) . B260 ) = ( ( IExec (C245 , R3 , C244) ) . B260 ))) by L1017 , L1016 , L997 , L999 , L989 , L1001 , L1005 , L998 , L1014 , L1015 , L933;
thus L1019: (for B261 being FinSeq-Location holds ( ( IExec (C245 , R2 , C243) ) . B261 ) = ( ( IExec (C245 , R3 , C244) ) . B261 )) by L1017 , L1016 , L997 , L999 , L989 , L1001 , L1005 , L998 , L1014 , L1015 , L933;
thus L1020: ( IC ( IExec (C245 , R2 , C243) ) ) = ( IC ( Result (D97 , D96) ) ) by SCMFSA6B:def 1
.= ( IC ( Comput (D97 , D96 , ( LifeSpan (D97 , D96) )) ) ) by L1006 , EXTPRO_1:23
.= ( IC ( Comput (D99 , D98 , ( LifeSpan (D99 , D98) )) ) ) by L997 , L999 , L989 , L1001 , L1005 , L998 , L1013 , L933
.= ( IC ( Result (D99 , D98) ) ) by L1004 , EXTPRO_1:23
.= ( IC ( IExec (C245 , R3 , C244) ) ) by SCMFSA6B:def 1;
end;
theorem
L1021: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B262 being (State of ( SCM+FSA )) holds (for B263 , B264 being  parahalting (Program of ( SCM+FSA )) holds (for B265 , B266 being  read-write Int-Location holds (((not B263 refer B265) & (not B264 refer B265)) implies (( IC ( IExec (( if=0 (B265 , B266 , B263 , B264) ) , R1 , B262) ) ) = ( ( ( card B263 ) + ( card B264 ) ) + 5 ) & (( B262 . B265 ) = ( B262 . B266 ) implies ((for B267 being Int-Location holds (B265 <> B267 implies ( ( IExec (( if=0 (B265 , B266 , B263 , B264) ) , R1 , B262) ) . B267 ) = ( ( IExec (B263 , R1 , B262) ) . B267 ))) & (for B268 being FinSeq-Location holds ( ( IExec (( if=0 (B265 , B266 , B263 , B264) ) , R1 , B262) ) . B268 ) = ( ( IExec (B263 , R1 , B262) ) . B268 )))) & (( B262 . B265 ) <> ( B262 . B266 ) implies ((for B269 being Int-Location holds (B265 <> B269 implies ( ( IExec (( if=0 (B265 , B266 , B263 , B264) ) , R1 , B262) ) . B269 ) = ( ( IExec (B264 , R1 , B262) ) . B269 ))) & (for B270 being FinSeq-Location holds ( ( IExec (( if=0 (B265 , B266 , B263 , B264) ) , R1 , B262) ) . B270 ) = ( ( IExec (B264 , R1 , B262) ) . B270 ))))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C250 being (State of ( SCM+FSA ));
let C251 , C252 being  parahalting (Program of ( SCM+FSA ));
let C253 , C254 being  read-write Int-Location;
assume that
L1022: (not C251 refer C253)
and
L1023: (not C252 refer C253);
reconsider D100 = ( if=0 (C253 , C251 , C252) ) as  parahalting (Program of ( SCM+FSA ));
reconsider D101 = ( Macro ( SubFrom (C253 , C254) ) ) as  keeping_0  parahalting (Program of ( SCM+FSA ));
set D102 = ( SubFrom (C253 , C254) );
set D103 = ( Exec (D102 , ( Initialized C250 )) );
L1024:
now
let C255 being  read-write Int-Location;
assume L1025: C253 <> C255;
thus L1026: ( D103 . C255 ) = ( ( Initialized C250 ) . C255 ) by L1025 , SCMFSA_2:65
.= ( C250 . C255 ) by SCMFSA_M:37;
end;
L1027: ( IExec (( if=0 (C253 , C254 , C251 , C252) ) , R1 , C250) ) = ( IncIC (( IExec (D100 , R1 , ( IExec (D101 , R1 , C250) )) ) , ( card D101 )) ) by SCMFSA6B:20;
thus L1028: ( IC ( IExec (( if=0 (C253 , C254 , C251 , C252) ) , R1 , C250) ) ) = ( ( IC ( IExec (D100 , R1 , ( IExec (D101 , R1 , C250) )) ) ) + ( card D101 ) ) by L1027 , FUNCT_4:113
.= ( ( ( ( card C251 ) + ( card C252 ) ) + 3 ) + ( card D101 ) ) by L425
.= ( ( ( ( card C251 ) + ( card C252 ) ) + 3 ) + 2 ) by COMPOS_1:56
.= ( ( ( card C251 ) + ( card C252 ) ) + 5 );
L1029:
now
let C256 being FinSeq-Location;
thus L1030: ( D103 . C256 ) = ( ( Initialized C250 ) . C256 ) by SCMFSA_2:65
.= ( C250 . C256 ) by SCMFSA_M:37;
end;
thus L1031:now
assume L1032: ( C250 . C253 ) = ( C250 . C254 );
L1033: C251 is_closed_on ( Initialized C250 ) , R1 by SCMFSA7B:18;
L1034: C251 is_halting_on ( Initialized C250 ) , R1 by SCMFSA7B:19;
L1035: ( ( Exec (D102 , ( Initialized C250 )) ) . C253 ) = ( ( ( Initialized C250 ) . C253 ) - ( ( Initialized C250 ) . C254 ) ) by SCMFSA_2:65
.= ( ( C250 . C253 ) - ( ( Initialized C250 ) . C254 ) ) by SCMFSA_M:37
.= ( ( C250 . C253 ) - ( C250 . C254 ) ) by SCMFSA_M:37
.= ( 0 ) by L1032;
thus L1036:now
let C257 being Int-Location;
assume L1037: C253 <> C257;
thus L1038: ( ( IExec (( if=0 (C253 , C254 , C251 , C252) ) , R1 , C250) ) . C257 ) = ( ( IExec (D100 , R1 , ( Exec (D102 , ( Initialized C250 )) )) ) . C257 ) by L120
.= ( ( IExec (C251 , R1 , ( Exec (D102 , ( Initialized C250 )) )) ) . C257 ) by L1035 , L425
.= ( ( IExec (C251 , R1 , C250) ) . C257 ) by L1022 , L1024 , L1029 , L1033 , L1034 , L1037 , L986;
end;
let C258 being FinSeq-Location;
thus L1039: ( ( IExec (( if=0 (C253 , C254 , C251 , C252) ) , R1 , C250) ) . C258 ) = ( ( IExec (D100 , R1 , ( Exec (D102 , ( Initialized C250 )) )) ) . C258 ) by L123
.= ( ( IExec (C251 , R1 , ( Exec (D102 , ( Initialized C250 )) )) ) . C258 ) by L1035 , L425
.= ( ( IExec (C251 , R1 , C250) ) . C258 ) by L1022 , L1024 , L1029 , L1033 , L1034 , L986;
end;
L1040: ( ( Exec (D102 , ( Initialized C250 )) ) . C253 ) = ( ( ( Initialized C250 ) . C253 ) - ( ( Initialized C250 ) . C254 ) ) by SCMFSA_2:65
.= ( ( C250 . C253 ) - ( ( Initialized C250 ) . C254 ) ) by SCMFSA_M:37
.= ( ( C250 . C253 ) - ( C250 . C254 ) ) by SCMFSA_M:37;
L1041: C252 is_halting_on ( Initialized C250 ) , R1 by SCMFSA7B:19;
L1042: C252 is_closed_on ( Initialized C250 ) , R1 by SCMFSA7B:18;
assume L1043: ( C250 . C253 ) <> ( C250 . C254 );
L1044: ( ( C250 . C253 ) + ( - ( C250 . C254 ) ) ) <> ( ( C250 . C254 ) + ( - ( C250 . C254 ) ) ) by L1043;
thus L1045:now
let C259 being Int-Location;
assume L1046: C253 <> C259;
thus L1047: ( ( IExec (( if=0 (C253 , C254 , C251 , C252) ) , R1 , C250) ) . C259 ) = ( ( IExec (D100 , R1 , ( Exec (D102 , ( Initialized C250 )) )) ) . C259 ) by L120
.= ( ( IExec (C252 , R1 , ( Exec (D102 , ( Initialized C250 )) )) ) . C259 ) by L1040 , L1044 , L425
.= ( ( IExec (C252 , R1 , C250) ) . C259 ) by L1023 , L1024 , L1029 , L1042 , L1041 , L1046 , L986;
end;
let C260 being FinSeq-Location;
thus L1048: ( ( IExec (( if=0 (C253 , C254 , C251 , C252) ) , R1 , C250) ) . C260 ) = ( ( IExec (D100 , R1 , ( Exec (D102 , ( Initialized C250 )) )) ) . C260 ) by L123
.= ( ( IExec (C252 , R1 , ( Exec (D102 , ( Initialized C250 )) )) ) . C260 ) by L1040 , L1044 , L425
.= ( ( IExec (C252 , R1 , C250) ) . C260 ) by L1023 , L1024 , L1029 , L1042 , L1041 , L986;
end;
theorem
L1049: (for R1 being (Instruction-Sequence of ( SCM+FSA )) holds (for B271 being (State of ( SCM+FSA )) holds (for B272 , B273 being  parahalting (Program of ( SCM+FSA )) holds (for B274 , B275 being  read-write Int-Location holds (((not B272 refer B274) & (not B273 refer B274)) implies (( IC ( IExec (( if>0 (B274 , B275 , B272 , B273) ) , R1 , B271) ) ) = ( ( ( card B272 ) + ( card B273 ) ) + 5 ) & (( B271 . B274 ) > ( B271 . B275 ) implies ((for B276 being Int-Location holds (B274 <> B276 implies ( ( IExec (( if>0 (B274 , B275 , B272 , B273) ) , R1 , B271) ) . B276 ) = ( ( IExec (B272 , R1 , B271) ) . B276 ))) & (for B277 being FinSeq-Location holds ( ( IExec (( if>0 (B274 , B275 , B272 , B273) ) , R1 , B271) ) . B277 ) = ( ( IExec (B272 , R1 , B271) ) . B277 )))) & (( B271 . B274 ) <= ( B271 . B275 ) implies ((for B278 being Int-Location holds (B274 <> B278 implies ( ( IExec (( if>0 (B274 , B275 , B272 , B273) ) , R1 , B271) ) . B278 ) = ( ( IExec (B273 , R1 , B271) ) . B278 ))) & (for B279 being FinSeq-Location holds ( ( IExec (( if>0 (B274 , B275 , B272 , B273) ) , R1 , B271) ) . B279 ) = ( ( IExec (B273 , R1 , B271) ) . B279 ))))))))))
proof
let R1 being (Instruction-Sequence of ( SCM+FSA ));
let C261 being (State of ( SCM+FSA ));
let C262 , C263 being  parahalting (Program of ( SCM+FSA ));
let C264 , C265 being  read-write Int-Location;
assume that
L1050: (not C262 refer C264)
and
L1051: (not C263 refer C264);
reconsider D104 = ( if>0 (C264 , C262 , C263) ) as  parahalting (Program of ( SCM+FSA ));
reconsider D105 = ( Macro ( SubFrom (C264 , C265) ) ) as  keeping_0  parahalting (Program of ( SCM+FSA ));
set D106 = ( SubFrom (C264 , C265) );
set D107 = ( Exec (D106 , ( Initialized C261 )) );
L1052:
now
let C266 being  read-write Int-Location;
assume L1053: C264 <> C266;
thus L1054: ( D107 . C266 ) = ( ( Initialized C261 ) . C266 ) by L1053 , SCMFSA_2:65
.= ( C261 . C266 ) by SCMFSA_M:37;
end;
L1055: ( IExec (( if>0 (C264 , C265 , C262 , C263) ) , R1 , C261) ) = ( IncIC (( IExec (D104 , R1 , ( IExec (D105 , R1 , C261) )) ) , ( card D105 )) ) by SCMFSA6B:20;
thus L1056: ( IC ( IExec (( if>0 (C264 , C265 , C262 , C263) ) , R1 , C261) ) ) = ( ( IC ( IExec (D104 , R1 , ( IExec (D105 , R1 , C261) )) ) ) + ( card D105 ) ) by L1055 , FUNCT_4:113
.= ( ( ( ( card C262 ) + ( card C263 ) ) + 3 ) + ( card D105 ) ) by L711
.= ( ( ( ( card C262 ) + ( card C263 ) ) + 3 ) + 2 ) by COMPOS_1:56
.= ( ( ( card C262 ) + ( card C263 ) ) + 5 );
L1057:
now
let C267 being FinSeq-Location;
thus L1058: ( D107 . C267 ) = ( ( Initialized C261 ) . C267 ) by SCMFSA_2:65
.= ( C261 . C267 ) by SCMFSA_M:37;
end;
thus L1059:now
L1060: ( ( Exec (D106 , ( Initialized C261 )) ) . C264 ) = ( ( ( Initialized C261 ) . C264 ) - ( ( Initialized C261 ) . C265 ) ) by SCMFSA_2:65
.= ( ( C261 . C264 ) - ( ( Initialized C261 ) . C265 ) ) by SCMFSA_M:37
.= ( ( C261 . C264 ) - ( C261 . C265 ) ) by SCMFSA_M:37;
assume L1061: ( C261 . C264 ) > ( C261 . C265 );
L1062: ( ( Exec (D106 , ( Initialized C261 )) ) . C264 ) > ( 0 ) by L1061 , L1060 , XREAL_1:50;
L1063: C262 is_halting_on ( Initialized C261 ) , R1 by SCMFSA7B:19;
L1064: C262 is_closed_on ( Initialized C261 ) , R1 by SCMFSA7B:18;
thus L1065:now
let C268 being Int-Location;
assume L1066: C264 <> C268;
thus L1067: ( ( IExec (( if>0 (C264 , C265 , C262 , C263) ) , R1 , C261) ) . C268 ) = ( ( IExec (D104 , R1 , ( Exec (D106 , ( Initialized C261 )) )) ) . C268 ) by L120
.= ( ( IExec (C262 , R1 , ( Exec (D106 , ( Initialized C261 )) )) ) . C268 ) by L1062 , L711
.= ( ( IExec (C262 , R1 , C261) ) . C268 ) by L1050 , L1052 , L1057 , L1064 , L1063 , L1066 , L986;
end;
let C269 being FinSeq-Location;
thus L1068: ( ( IExec (( if>0 (C264 , C265 , C262 , C263) ) , R1 , C261) ) . C269 ) = ( ( IExec (D104 , R1 , ( Exec (D106 , ( Initialized C261 )) )) ) . C269 ) by L123
.= ( ( IExec (C262 , R1 , ( Exec (D106 , ( Initialized C261 )) )) ) . C269 ) by L1062 , L711
.= ( ( IExec (C262 , R1 , C261) ) . C269 ) by L1050 , L1052 , L1057 , L1064 , L1063 , L986;
end;
L1069: ( ( Exec (D106 , ( Initialized C261 )) ) . C264 ) = ( ( ( Initialized C261 ) . C264 ) - ( ( Initialized C261 ) . C265 ) ) by SCMFSA_2:65
.= ( ( C261 . C264 ) - ( ( Initialized C261 ) . C265 ) ) by SCMFSA_M:37
.= ( ( C261 . C264 ) - ( C261 . C265 ) ) by SCMFSA_M:37;
L1070: C263 is_closed_on ( Initialized C261 ) , R1 by SCMFSA7B:18;
L1071: C263 is_halting_on ( Initialized C261 ) , R1 by SCMFSA7B:19;
assume L1072: ( C261 . C264 ) <= ( C261 . C265 );
L1073: ( ( Exec (D106 , ( Initialized C261 )) ) . C264 ) <= ( 0 ) by L1072 , L1069 , XREAL_1:47;
thus L1074:now
let C270 being Int-Location;
assume L1075: C264 <> C270;
thus L1076: ( ( IExec (( if>0 (C264 , C265 , C262 , C263) ) , R1 , C261) ) . C270 ) = ( ( IExec (D104 , R1 , ( Exec (D106 , ( Initialized C261 )) )) ) . C270 ) by L120
.= ( ( IExec (C263 , R1 , ( Exec (D106 , ( Initialized C261 )) )) ) . C270 ) by L1073 , L711
.= ( ( IExec (C263 , R1 , C261) ) . C270 ) by L1051 , L1052 , L1057 , L1070 , L1071 , L1075 , L986;
end;
let C271 being FinSeq-Location;
thus L1077: ( ( IExec (( if>0 (C264 , C265 , C262 , C263) ) , R1 , C261) ) . C271 ) = ( ( IExec (D104 , R1 , ( Exec (D106 , ( Initialized C261 )) )) ) . C271 ) by L123
.= ( ( IExec (C263 , R1 , ( Exec (D106 , ( Initialized C261 )) )) ) . C271 ) by L1073 , L711
.= ( ( IExec (C263 , R1 , C261) ) . C271 ) by L1051 , L1052 , L1057 , L1070 , L1071 , L986;
end;
