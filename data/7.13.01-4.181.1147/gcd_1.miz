:: The correctness of the Generic Algorithms of Brown and Henrici
:: concerning Addition and Multiplication in Fraction Fields
::  by Christoph Schwarzweller
::
:: Received June 16, 1997
:: Copyright (c) 1997-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies BINOP_1, VECTSP_1, XBOOLE_0, ALGSTR_0, SUBSET_1, MESFUNC1,
      RELAT_1, LATTICES, ARYTM_3, FUNCSDOM, VECTSP_2, SUPINF_2, CARD_1,
      STRUCT_0, RLVECT_1, ARYTM_1, GROUP_1, EQREL_1, TARSKI, SETFAM_1,
      MSSUBFAM, INT_2, GCD_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, STRUCT_0, ALGSTR_0, RLVECT_1,
      GROUP_1, VECTSP_2, VECTSP_1, FUNCSDOM;
 constructors BINOP_2, VECTSP_2, MONOID_0;
 registrations XBOOLE_0, SUBSET_1, MEMBERED, STRUCT_0, VECTSP_1, MONOID_0;
 requirements SUBSET, BOOLE;
 definitions VECTSP_1, VECTSP_2, XBOOLE_0;
 theorems TARSKI, WELLORD2, SUBSET_1, VECTSP_1, VECTSP_2, RLVECT_1, XBOOLE_0,
      XCMPLX_1, GROUP_1, STRUCT_0;
 schemes SUBSET_1;

begin
registration
cluster  commutative  right_unital ->  left_unital for non  empty non  empty non  empty non  empty multLoopStr;
coherence
proof
let C1 being non  empty multLoopStr;
assume that
L1: C1 is  commutative
and
L2: C1 is  right_unital;
let C2 being (Element of C1);
thus L3: ( ( 1. C1 ) * C2 ) = ( C2 * ( 1. C1 ) ) by L1 , GROUP_1:def 12
.= C2 by L2 , VECTSP_1:def 4;
end;
end;
registration
cluster  commutative  right-distributive ->  distributive for non  empty non  empty non  empty non  empty doubleLoopStr;
coherence
proof
let C3 being non  empty doubleLoopStr;
assume that
L5: C3 is  commutative
and
L6: C3 is  right-distributive;
let C4 , C5 , C6 being (Element of C3);
thus L7: ( C4 * ( C5 + C6 ) ) = ( ( C4 * C5 ) + ( C4 * C6 ) ) by L6 , VECTSP_1:def 2;
thus L8: ( ( C5 + C6 ) * C4 ) = ( C4 * ( C5 + C6 ) ) by L5 , GROUP_1:def 12
.= ( ( C4 * C5 ) + ( C4 * C6 ) ) by L6 , VECTSP_1:def 2
.= ( ( C5 * C4 ) + ( C4 * C6 ) ) by L5 , GROUP_1:def 12
.= ( ( C5 * C4 ) + ( C6 * C4 ) ) by L5 , GROUP_1:def 12;
end;
cluster  commutative  left-distributive ->  distributive for non  empty non  empty non  empty non  empty doubleLoopStr;
coherence
proof
let C7 being non  empty doubleLoopStr;
assume that
L9: C7 is  commutative
and
L10: C7 is  left-distributive;
let C8 , C9 , C10 being (Element of C7);
thus L11: ( C8 * ( C9 + C10 ) ) = ( ( C9 + C10 ) * C8 ) by L9 , GROUP_1:def 12
.= ( ( C9 * C8 ) + ( C10 * C8 ) ) by L10 , VECTSP_1:def 3
.= ( ( C8 * C9 ) + ( C10 * C8 ) ) by L9 , GROUP_1:def 12
.= ( ( C8 * C9 ) + ( C8 * C10 ) ) by L9 , GROUP_1:def 12;
thus L12: thesis by L10 , VECTSP_1:def 3;
end;
end;
registration
cluster  ->  well-unital for Ring;
coherence;
end;
registration
cluster ( F_Real ) ->  domRing-like;
coherence
proof
set D1 = ( F_Real );
thus L15:now
let C11 , C12 being (Element of ( F_Real ));
L16: ( 0. D1 ) = ( 0 ) by STRUCT_0:def 6;
assume L17: (( C11 * C12 ) = ( 0. D1 ) & C11 <> ( 0. D1 ));
thus L18: C12 = ( 0. D1 ) by L17 , L16 , XCMPLX_1:6;
end;
end;
end;
registration
cluster  strict  Abelian  add-associative  right_zeroed  right_complementable  associative  commutative  domRing-like  distributive  well-unital non  degenerated  almost_left_invertible for non  empty non  empty non  empty non  empty doubleLoopStr;
existence
proof
take ( F_Real );
thus L17: thesis;
end;
end;
theorem
L19: (for B1 being  domRing-like  commutative Ring holds (for B2 , B3 , B4 being (Element of B1) holds (B2 <> ( 0. B1 ) implies ((( B2 * B3 ) = ( B2 * B4 ) implies B3 = B4) & (( B3 * B2 ) = ( B4 * B2 ) implies B3 = B4)))))
proof
let C13 being  domRing-like  commutative Ring;
let C14 , C15 , C16 being (Element of C13);
assume L20: C14 <> ( 0. C13 );
L21:
now
assume L22: ( C14 * C15 ) = ( C14 * C16 );
L23: ( 0. C13 ) = ( ( C14 * C15 ) + ( - ( C14 * C16 ) ) ) by L22 , RLVECT_1:def 10
.= ( ( C14 * C15 ) + ( C14 * ( - C16 ) ) ) by VECTSP_1:8
.= ( C14 * ( C15 + ( - C16 ) ) ) by VECTSP_1:def 2
.= ( C14 * ( C15 - C16 ) ) by RLVECT_1:def 11;
L24: ( C15 - C16 ) = ( 0. C13 ) by L23 , L20 , VECTSP_2:def 1;
L25: C16 = ( ( C15 - C16 ) + C16 ) by L24 , RLVECT_1:4
.= ( ( C15 + ( - C16 ) ) + C16 ) by RLVECT_1:def 11
.= ( C15 + ( C16 + ( - C16 ) ) ) by RLVECT_1:def 3
.= ( C15 + ( 0. C13 ) ) by RLVECT_1:def 10
.= C15 by RLVECT_1:4;
thus L26: C15 = C16 by L25;
end;
thus L27: thesis by L21;
end;
definition
let C17 being non  empty multMagma;
let C18 , C19 being (Element of C17);
pred C18 divides C19
means
:L28: (ex B5 being (Element of C17) st C19 = ( C18 * B5 ))
;end;
definition
let C20 being  right_unital non  empty multLoopStr;
let C21 , C22 being (Element of C20);
redefine pred C21 divides C22
;
reflexivity
proof
let C23 being (Element of C20);
L30: ( C23 * ( 1. C20 ) ) = C23 by VECTSP_1:def 4;
thus L31: thesis by L30 , L28;
end;
end;
definition
let C24 being non  empty multLoopStr;
let C25 being (Element of C24);
attr C25 is  unital
means
:L33: C25 divides ( 1. C24 );
end;
definition
let C26 being non  empty multLoopStr;
let C27 , C28 being (Element of C26);
pred C27 is_associated_to C28
means
:L35: (C27 divides C28 & C28 divides C27)
;symmetry
;
end;
notation
let C29 being non  empty multLoopStr;
let C30 , C31 being (Element of C29);
antonym C30 is_not_associated_to C31 for C30 is_associated_to C31;
end;
definition
let C32 being  well-unital non  empty multLoopStr;
let C33 , C34 being (Element of C32);
redefine pred C33 is_associated_to C34
;
reflexivity
proof
let C35 being (Element of C32);
thus L38: (C35 divides C35 & C35 divides C35);
end;
end;
definition
let C36 being  domRing-like  commutative Ring;
let C37 , C38 being (Element of C36);
assume L40: C38 divides C37;
assume L41: C38 <> ( 0. C36 );
func C37 / C38 -> (Element of C36) means 
:L42: ( it * C38 ) = C37;
existence
proof
L43: (ex B6 being (Element of C36) st C37 = ( C38 * B6 )) by L40 , L28;
thus L44: thesis by L43;
end;
uniqueness by L41 , L19;
end;
theorem
L46: (for B7 being  associative non  empty multLoopStr holds (for B8 , B9 , B10 being (Element of B7) holds ((B8 divides B9 & B9 divides B10) implies B8 divides B10)))
proof
let C39 being  associative non  empty multLoopStr;
let C40 , C41 , C42 being (Element of C39);
L47:
now
assume that
L48: C40 divides C41
and
L49: C41 divides C42;
consider C43 being (Element of C39) such that L50: ( C40 * C43 ) = C41 by L48 , L28;
consider C44 being (Element of C39) such that L51: ( C41 * C44 ) = C42 by L49 , L28;
L52: ( C40 * ( C43 * C44 ) ) = C42 by L50 , L51 , GROUP_1:def 3;
thus L53: thesis by L52 , L28;
end;
thus L54: thesis by L47;
end;
theorem
L55: (for B11 being  commutative  associative non  empty multLoopStr holds (for B12 , B13 , B14 , B15 being (Element of B11) holds ((B13 divides B12 & B15 divides B14) implies ( B13 * B15 ) divides ( B12 * B14 ))))
proof
let C45 being  commutative  associative non  empty multLoopStr;
let C46 , C47 , C48 , C49 being (Element of C45);
assume that
L56: C47 divides C46
and
L57: C49 divides C48;
consider C50 being (Element of C45) such that L58: ( C47 * C50 ) = C46 by L56 , L28;
consider C51 being (Element of C45) such that L59: ( C49 * C51 ) = C48 by L57 , L28;
L60: ( ( C47 * C49 ) * ( C51 * C50 ) ) = ( ( ( C47 * C49 ) * C51 ) * C50 ) by GROUP_1:def 3
.= ( ( C47 * C48 ) * C50 ) by L59 , GROUP_1:def 3
.= ( C46 * C48 ) by L58 , GROUP_1:def 3;
thus L61: thesis by L60 , L28;
end;
theorem
L62: (for B16 being  associative non  empty multLoopStr holds (for B17 , B18 , B19 being (Element of B16) holds ((B17 is_associated_to B18 & B18 is_associated_to B19) implies B17 is_associated_to B19)))
proof
let C52 being  associative non  empty multLoopStr;
let C53 , C54 , C55 being (Element of C52);
L63:
now
assume L64: (C53 is_associated_to C54 & C54 is_associated_to C55);
L65: (C54 divides C53 & C55 divides C54) by L64 , L35;
L66: C55 divides C53 by L65 , L46;
L67: (C53 divides C54 & C54 divides C55) by L64 , L35;
L68: C53 divides C55 by L67 , L46;
thus L69: thesis by L68 , L66 , L35;
end;
thus L70: thesis by L63;
end;
theorem
L71: (for B20 being  associative non  empty multLoopStr holds (for B21 , B22 , B23 being (Element of B20) holds (B21 divides B22 implies ( B23 * B21 ) divides ( B23 * B22 ))))
proof
let C56 being  associative non  empty multLoopStr;
let C57 , C58 , C59 being (Element of C56);
assume L72: C57 divides C58;
consider C60 being (Element of C56) such that L73: ( C57 * C60 ) = C58 by L72 , L28;
L74: ( ( C59 * C57 ) * C60 ) = ( C59 * C58 ) by L73 , GROUP_1:def 3;
thus L75: thesis by L74 , L28;
end;
theorem
L76: (for B24 being non  empty multLoopStr holds (for B25 , B26 being (Element of B24) holds (B25 divides ( B25 * B26 ) & (B24 is  commutative implies B26 divides ( B25 * B26 )))))
proof
let C61 being non  empty multLoopStr;
let C62 , C63 being (Element of C61);
thus L77: C62 divides ( C62 * C63 )
proof
take C63;
thus L78: thesis;
end;

assume L79: C61 is  commutative;
take C62;
thus L80: thesis by L79 , GROUP_1:def 12;
end;
theorem
L81: (for B27 being  associative non  empty multLoopStr holds (for B28 , B29 , B30 being (Element of B27) holds (B28 divides B29 implies B28 divides ( B29 * B30 ))))
proof
let C64 being  associative non  empty multLoopStr;
let C65 , C66 , C67 being (Element of C64);
assume L82: C65 divides C66;
consider C68 being (Element of C64) such that L83: ( C65 * C68 ) = C66 by L82 , L28;
L84: ( C65 * ( C68 * C67 ) ) = ( C66 * C67 ) by L83 , GROUP_1:def 3;
thus L85: thesis by L84 , L28;
end;
theorem
L86: (for R3 being  domRing-like  commutative Ring holds (for B31 , B32 being (Element of R3) holds ((B32 divides B31 & B32 <> ( 0. R3 )) implies (( B31 / B32 ) = ( 0. R3 ) iff B31 = ( 0. R3 )))))
proof
let R3 being  domRing-like  commutative Ring;
let C69 , C70 being (Element of R3);
assume that
L87: C70 divides C69
and
L88: C70 <> ( 0. R3 );
thus L89:now
assume L90: ( C69 / C70 ) = ( 0. R3 );
L91: C69 = ( ( 0. R3 ) * C70 ) by L90 , L87 , L88 , L42
.= ( 0. R3 ) by VECTSP_1:7;
thus L92: C69 = ( 0. R3 ) by L91;
end;
assume L93: C69 = ( 0. R3 );
L94: ( 0. R3 ) = ( ( C69 / C70 ) * C70 ) by L93 , L87 , L88 , L42;
thus L95: thesis by L94 , L88 , VECTSP_2:def 1;
end;
theorem
L96: (for R3 being  domRing-like  commutative Ring holds (for B33 being (Element of R3) holds (B33 <> ( 0. R3 ) implies ( B33 / B33 ) = ( 1. R3 ))))
proof
let R3 being  domRing-like  commutative Ring;
let C71 being (Element of R3);
assume L97: C71 <> ( 0. R3 );
L98: ( ( C71 / C71 ) * C71 ) = C71 by L97 , L42
.= ( ( 1. R3 ) * C71 ) by VECTSP_1:def 8;
thus L99: thesis by L98 , L97 , L19;
end;
theorem
L100: (for B34 being non  degenerated  domRing-like  commutative Ring holds (for B35 being (Element of B34) holds ( B35 / ( 1. B34 ) ) = B35))
proof
let C72 being non  degenerated  domRing-like  commutative Ring;
let C73 being (Element of C72);
set D2 = ( C73 / ( 1. C72 ) );
L101: ( ( 1. C72 ) * C73 ) = C73 by VECTSP_1:def 8;
L102: (( 1. C72 ) <> ( 0. C72 ) & ( 1. C72 ) divides C73) by L101 , L28;
L103: D2 = ( D2 * ( 1. C72 ) ) by VECTSP_1:def 4
.= C73 by L102 , L42;
thus L104: thesis by L103;
end;
theorem
L105: (for R3 being  domRing-like  commutative Ring holds (for B36 , B37 , B38 being (Element of R3) holds (B38 <> ( 0. R3 ) implies (((B38 divides ( B36 * B37 ) & B38 divides B36) implies ( ( B36 * B37 ) / B38 ) = ( ( B36 / B38 ) * B37 )) & ((B38 divides ( B36 * B37 ) & B38 divides B37) implies ( ( B36 * B37 ) / B38 ) = ( B36 * ( B37 / B38 ) ))))))
proof
let R3 being  domRing-like  commutative Ring;
let C74 , C75 , C76 being (Element of R3);
assume L106: C76 <> ( 0. R3 );
L107:
now
set D3 = ( C75 / C76 );
set D4 = ( ( C74 * C75 ) / C76 );
assume L108: (C76 divides ( C74 * C75 ) & C76 divides C75);
L109: (( D4 * C76 ) = ( C74 * C75 ) & ( D3 * C76 ) = C75) by L108 , L106 , L42;
L110: ( D4 * C76 ) = ( ( C74 * D3 ) * C76 ) by L109 , GROUP_1:def 3;
thus L111: ((C76 divides ( C74 * C75 ) & C76 divides C75) implies ( ( C74 * C75 ) / C76 ) = ( C74 * ( C75 / C76 ) )) by L110 , L106 , L19;
end;
L112:
now
set D5 = ( C74 / C76 );
set D6 = ( ( C74 * C75 ) / C76 );
assume L113: (C76 divides ( C74 * C75 ) & C76 divides C74);
L114: (( D6 * C76 ) = ( C74 * C75 ) & ( D5 * C76 ) = C74) by L113 , L106 , L42;
L115: ( D6 * C76 ) = ( ( D5 * C75 ) * C76 ) by L114 , GROUP_1:def 3;
thus L116: ((C76 divides ( C74 * C75 ) & C76 divides C74) implies ( ( C74 * C75 ) / C76 ) = ( ( C74 / C76 ) * C75 )) by L115 , L106 , L19;
end;
thus L117: thesis by L112 , L107;
end;
theorem
L118: (for R3 being  domRing-like  commutative Ring holds (for B39 , B40 , B41 being (Element of R3) holds ((B41 <> ( 0. R3 ) & B41 divides B39 & B41 divides B40 & B41 divides ( B39 + B40 )) implies ( ( B39 / B41 ) + ( B40 / B41 ) ) = ( ( B39 + B40 ) / B41 ))))
proof
let R3 being  domRing-like  commutative Ring;
let C77 , C78 , C79 being (Element of R3);
assume L119: C79 <> ( 0. R3 );
set D7 = ( C78 / C79 );
set D8 = ( C77 / C79 );
assume that
L120: (C79 divides C77 & C79 divides C78)
and
L121: C79 divides ( C77 + C78 );
L122: (( D8 * C79 ) = C77 & ( D7 * C79 ) = C78) by L119 , L120 , L42;
L123: ( C77 + C78 ) = ( ( D8 + D7 ) * C79 ) by L122 , VECTSP_1:def 3;
L124: ( ( C77 + C78 ) / C79 ) = ( ( D8 + D7 ) * ( C79 / C79 ) ) by L123 , L119 , L121 , L105
.= ( ( D8 + D7 ) * ( 1. R3 ) ) by L119 , L96
.= ( D8 + D7 ) by VECTSP_1:def 4;
thus L125: thesis by L124;
end;
theorem
L126: (for R3 being  domRing-like  commutative Ring holds (for B42 , B43 , B44 being (Element of R3) holds ((B44 <> ( 0. R3 ) & B44 divides B42 & B44 divides B43) implies (( B42 / B44 ) = ( B43 / B44 ) iff B42 = B43))))
proof
let R3 being  domRing-like  commutative Ring;
let C80 , C81 , C82 being (Element of R3);
assume L127: C82 <> ( 0. R3 );
assume that
L128: C82 divides C80
and
L129: C82 divides C81;
L130:
now
assume L131: ( C80 / C82 ) = ( C81 / C82 );
consider C83 being (Element of R3) such that L132: C83 = ( C81 / C82 );
L133: ( C83 * C82 ) = C81 by L127 , L129 , L132 , L42;
thus L134: (( C80 / C82 ) = ( C81 / C82 ) implies C80 = C81) by L133 , L127 , L128 , L132 , L42;
end;
thus L135: thesis by L130;
end;
theorem
L136: (for R3 being  domRing-like  commutative Ring holds (for B45 , B46 , B47 , B48 being (Element of R3) holds ((B46 <> ( 0. R3 ) & B48 <> ( 0. R3 ) & B46 divides B45 & B48 divides B47) implies ( ( B45 / B46 ) * ( B47 / B48 ) ) = ( ( B45 * B47 ) / ( B46 * B48 ) ))))
proof
let R3 being  domRing-like  commutative Ring;
let C84 , C85 , C86 , C87 being (Element of R3);
assume that
L137: (C85 <> ( 0. R3 ) & C87 <> ( 0. R3 ))
and
L138: (C85 divides C84 & C87 divides C86);
L139: ( C85 * C87 ) divides ( C84 * C86 ) by L138 , L55;
set D9 = ( ( C84 * C86 ) / ( C85 * C87 ) );
set D10 = ( C86 / C87 );
set D11 = ( C84 / C85 );
L140: ( C85 * C87 ) <> ( 0. R3 ) by L137 , VECTSP_2:def 1;
L141: (( D11 * C85 ) = C84 & ( D10 * C87 ) = C86) by L137 , L138 , L42;
L142: ( D9 * ( C85 * C87 ) ) = ( ( D11 * C85 ) * ( D10 * C87 ) ) by L141 , L139 , L140 , L42
.= ( D11 * ( C85 * ( D10 * C87 ) ) ) by GROUP_1:def 3
.= ( D11 * ( D10 * ( C85 * C87 ) ) ) by GROUP_1:def 3
.= ( ( D11 * D10 ) * ( C85 * C87 ) ) by GROUP_1:def 3;
thus L143: thesis by L142 , L140 , L19;
end;
theorem
L144: (for R3 being  domRing-like  commutative Ring holds (for B49 , B50 , B51 being (Element of R3) holds ((B49 <> ( 0. R3 ) & ( B49 * B50 ) divides ( B49 * B51 )) implies B50 divides B51)))
proof
let R3 being  domRing-like  commutative Ring;
let C88 , C89 , C90 being (Element of R3);
assume that
L145: C88 <> ( 0. R3 )
and
L146: ( C88 * C89 ) divides ( C88 * C90 );
consider C91 being (Element of R3) such that L147: ( ( C88 * C89 ) * C91 ) = ( C88 * C90 ) by L146 , L28;
L148: C88 divides ( C88 * C90 ) by L76;
L149: ( ( C88 * C90 ) / C88 ) = ( ( C88 / C88 ) * C90 ) by L148 , L145 , L105;
L150: C88 divides ( C88 * ( C89 * C91 ) ) by L76;
L151: ( ( C88 * ( C89 * C91 ) ) / C88 ) = ( ( C88 / C88 ) * ( C89 * C91 ) ) by L150 , L145 , L105;
L152: ( C88 * ( C89 * C91 ) ) = ( C88 * C90 ) by L147 , GROUP_1:def 3;
L153: ( C89 * C91 ) = ( ( 1. R3 ) * ( C89 * C91 ) ) by VECTSP_1:def 8
.= ( ( C88 / C88 ) * C90 ) by L145 , L152 , L151 , L149 , L96
.= ( ( 1. R3 ) * C90 ) by L145 , L96
.= C90 by VECTSP_1:def 8;
thus L154: thesis by L153 , L28;
end;
theorem
L155: (for R3 being  domRing-like  commutative Ring holds (for B52 being (Element of R3) holds (B52 is_associated_to ( 0. R3 ) implies B52 = ( 0. R3 ))))
proof
let R3 being  domRing-like  commutative Ring;
let C92 being (Element of R3);
assume L156: C92 is_associated_to ( 0. R3 );
L157: ( 0. R3 ) divides C92 by L156 , L35;
L158: (ex B53 being (Element of R3) st ( ( 0. R3 ) * B53 ) = C92) by L157 , L28;
thus L159: thesis by L158 , VECTSP_1:7;
end;
theorem
L160: (for R3 being  domRing-like  commutative Ring holds (for B54 , B55 being (Element of R3) holds ((B54 <> ( 0. R3 ) & ( B54 * B55 ) = B54) implies B55 = ( 1. R3 ))))
proof
let R3 being  domRing-like  commutative Ring;
let C93 , C94 being (Element of R3);
assume that
L161: C93 <> ( 0. R3 )
and
L162: ( C93 * C94 ) = C93;
set D12 = ( C93 / C93 );
L163: (D12 = ( 1. R3 ) & ( ( C93 * C94 ) / C93 ) = ( ( C93 / C93 ) * C94 )) by L161 , L162 , L96 , L105;
thus L164: thesis by L163 , L162 , VECTSP_1:def 8;
end;
theorem
L165: (for R3 being  domRing-like  commutative Ring holds (for B56 , B57 being (Element of R3) holds (B56 is_associated_to B57 iff (ex R4 being (Element of R3) st (R4 is  unital & ( B56 * R4 ) = B57)))))
proof
let R3 being  domRing-like  commutative Ring;
L166: (for B58 , B59 being (Element of R3) holds (B58 is_associated_to B59 implies (ex B60 being (Element of R3) st (B60 is  unital & ( B58 * B60 ) = B59))))
proof
let C95 , C96 being (Element of R3);
assume L167: C95 is_associated_to C96;
L168: C95 divides C96 by L167 , L35;
consider C97 being (Element of R3) such that L169: C96 = ( C95 * C97 ) by L168 , L28;
L170: C96 divides C95 by L167 , L35;
consider C98 being (Element of R3) such that L171: C95 = ( C96 * C98 ) by L170 , L28;
L172:
now
per cases ;
case L173: C95 <> ( 0. R3 );
L174: C95 = ( C95 * ( C97 * C98 ) ) by L169 , L171 , GROUP_1:def 3;
L175: ( C97 * C98 ) = ( 1. R3 ) by L174 , L173 , L160;
L176: C97 divides ( 1. R3 ) by L175 , L28;
L177: C97 is  unital by L176 , L33;
thus L178: thesis by L177 , L169;
end;
case L179: C95 = ( 0. R3 );
L180: ( 1. R3 ) divides ( 1. R3 );
L181: ( 1. R3 ) is  unital by L180 , L33;
L182: C96 = ( 0. R3 ) by L169 , L179 , VECTSP_1:7;
L183: C96 = ( C95 * ( 1. R3 ) ) by L182 , L179 , VECTSP_1:def 4;
thus L184: thesis by L183 , L181;
end;
end;
thus L186: thesis by L172;
end;
L187: (for B61 , B62 being (Element of R3) holds ((ex B63 being (Element of R3) st (B63 is  unital & ( B61 * B63 ) = B62)) implies B61 is_associated_to B62))
proof
let C99 , C100 being (Element of R3);
L188: ((ex R4 being (Element of R3) st (R4 is  unital & ( C99 * R4 ) = C100)) implies C99 is_associated_to C100)
proof
L189:
now
assume L190: (ex R4 being (Element of R3) st (R4 is  unital & ( C99 * R4 ) = C100));
consider C101 being (Element of R3) such that L191: C101 is  unital and L192: ( C99 * C101 ) = C100 by L190;
L193: C101 divides ( 1. R3 ) by L191 , L33;
consider C102 being (Element of R3) such that L194: ( C101 * C102 ) = ( 1. R3 ) by L193 , L28;
L195: C99 = ( C99 * ( C101 * C102 ) ) by L194 , VECTSP_1:def 4
.= ( C100 * C102 ) by L192 , GROUP_1:def 3;
L196: C100 divides C99 by L195 , L28;
L197: C99 divides C100 by L192 , L28;
thus L198: thesis by L197 , L196 , L35;
end;
thus L199: thesis by L189;
end;
thus L200: thesis by L188;
end;
thus L201: thesis by L187 , L166;
end;
theorem
L202: (for R3 being  domRing-like  commutative Ring holds (for B64 , B65 , B66 being (Element of R3) holds ((B66 <> ( 0. R3 ) & ( B66 * B64 ) is_associated_to ( B66 * B65 )) implies B64 is_associated_to B65)))
proof
let R3 being  domRing-like  commutative Ring;
let C103 , C104 , C105 being (Element of R3);
assume that
L203: C105 <> ( 0. R3 )
and
L204: ( C105 * C103 ) is_associated_to ( C105 * C104 );
L205: ( C105 * C104 ) divides ( C105 * C103 ) by L204 , L35;
L206: C104 divides C103 by L205 , L203 , L144;
L207: ( C105 * C103 ) divides ( C105 * C104 ) by L204 , L35;
L208: C103 divides C104 by L207 , L203 , L144;
thus L209: thesis by L208 , L206 , L35;
end;
begin
definition
let C106 being non  empty multLoopStr;
let C107 being (Element of C106);
func Class C107 -> (Subset of C106) means 
:L210: (for B67 being (Element of C106) holds (B67 in it iff B67 is_associated_to C107));
existence
proof
set D13 = { B68 where B68 is (Element of C106) : B68 is_associated_to C107 };
L211:
now
let C108 being set;
L212:
now
assume L213: C108 in D13;
L214: (ex B69 being (Element of C106) st (C108 = B69 & B69 is_associated_to C107)) by L213;
thus L215: (C108 in D13 implies C108 in (the carrier of C106)) by L214;
end;
thus L216: (C108 in D13 implies C108 in (the carrier of C106)) by L212;
end;
L217: D13 c= (the carrier of C106) by L211 , TARSKI:def 3;
L218:
now
let C109 being (Element of C106);
L219: (C109 in D13 implies C109 is_associated_to C107)
proof
assume L220: C109 in D13;
L221: (ex B70 being (Element of C106) st (C109 = B70 & B70 is_associated_to C107)) by L220;
thus L222: thesis by L221;
end;
thus L223: (C109 in D13 iff C109 is_associated_to C107) by L219;
end;
thus L224: thesis by L218 , L217;
end;
uniqueness
proof
defpred S1[ (Element of C106) ] means $1 is_associated_to C107;
let C110 , C111 being (Subset of C106);
assume that
L225: (for B71 being (Element of C106) holds (B71 in C110 iff S1[ B71 ]))
and
L226: (for B72 being (Element of C106) holds (B72 in C111 iff S1[ B72 ]));
thus L227: C110 = C111 from SUBSET_1:sch 2(L225 , L226);
end;
end;
registration
let C112 being  well-unital non  empty multLoopStr;
let C113 being (Element of C112);
cluster ( Class C113 ) -> non  empty;
coherence
proof
L229: C113 is_associated_to C113;
thus L230: thesis by L229 , L210;
end;
end;
theorem
L232: (for B73 being  associative non  empty multLoopStr holds (for B74 , B75 being (Element of B73) holds (( Class B74 ) meets ( Class B75 ) implies ( Class B74 ) = ( Class B75 ))))
proof
let C114 being  associative non  empty multLoopStr;
let C115 , C116 being (Element of C114);
assume L233: ( ( Class C115 ) /\ ( Class C116 ) ) <> ( {} );
L234: ( Class C115 ) meets ( Class C116 ) by L233 , XBOOLE_0:def 7;
consider C117 being set such that L235: C117 in ( Class C115 ) and L236: C117 in ( Class C116 ) by L234 , XBOOLE_0:3;
reconsider D14 = C117 as (Element of C114) by L235;
L237: D14 is_associated_to C116 by L236 , L210;
L238: D14 is_associated_to C115 by L235 , L210;
L239: (for B76 being (Element of C114) holds (B76 in ( Class C116 ) implies B76 in ( Class C115 )))
proof
let C118 being (Element of C114);
assume L240: C118 in ( Class C116 );
L241: C118 is_associated_to C116 by L240 , L210;
L242: D14 is_associated_to C118 by L241 , L237 , L62;
L243: C115 is_associated_to C118 by L242 , L238 , L62;
thus L244: thesis by L243 , L210;
end;
L245: (for B77 being (Element of C114) holds (B77 in ( Class C115 ) implies B77 in ( Class C116 )))
proof
let C119 being (Element of C114);
assume L246: C119 in ( Class C115 );
L247: C119 is_associated_to C115 by L246 , L210;
L248: D14 is_associated_to C119 by L247 , L238 , L62;
L249: C116 is_associated_to C119 by L248 , L237 , L62;
thus L250: thesis by L249 , L210;
end;
thus L251: thesis by L245 , L239 , SUBSET_1:3;
end;
definition
let C120 being non  empty multLoopStr;
func Classes C120 -> (Subset-Family of C120) means 
:L252: (for B78 being (Subset of C120) holds (B78 in it iff (ex B79 being (Element of C120) st B78 = ( Class B79 ))));
existence
proof
defpred S2[ set ] means (ex B80 being (Element of C120) st $1 = ( Class B80 ));
L253: (ex B81 being (Subset-Family of C120) st (for B82 being (Subset of C120) holds (B82 in B81 iff S2[ B82 ]))) from SUBSET_1:sch 3;
thus L254: thesis by L253;
end;
uniqueness
proof
defpred S3[ set ] means (ex B83 being (Element of C120) st $1 = ( Class B83 ));
let C121 , C122 being (Subset-Family of C120);
assume L255: (for B84 being (Subset of C120) holds (B84 in C121 iff S3[ B84 ]));
assume L256: (for B85 being (Subset of C120) holds (B85 in C122 iff S3[ B85 ]));
thus L257: thesis from SUBSET_1:sch 4(L255 , L256);
end;
end;
registration
let C123 being non  empty multLoopStr;
cluster ( Classes C123 ) -> non  empty;
coherence
proof
L259: ( Class ( 1. C123 ) ) in ( Classes C123 ) by L252;
thus L260: thesis by L259;
end;
end;
theorem
L262: (for B86 being  well-unital non  empty multLoopStr holds (for B87 being (Subset of B86) holds (B87 in ( Classes B86 ) implies B87 is non  empty)))
proof
let C124 being  well-unital non  empty multLoopStr;
let C125 being (Subset of C124);
assume L263: C125 in ( Classes C124 );
L264: (ex B88 being (Element of C124) st C125 = ( Class B88 )) by L263 , L252;
thus L265: thesis by L264;
end;
definition
let C126 being  associative  well-unital non  empty multLoopStr;
mode Am of C126
 -> non  empty (Subset of C126)
means :L266: ((for B89 being (Element of C126) holds (ex B90 being (Element of it) st B90 is_associated_to B89)) & (for B91 , B92 being (Element of it) holds (B91 <> B92 implies B91 is_not_associated_to B92)));
existence
proof
L267:
now
let C127 being  associative  well-unital non  empty multLoopStr;
reconsider D15 = ( Classes C127 ) as non  empty set;
L268: (for R1 being set holds (R1 in D15 implies R1 <> ( {} )))
proof
let C128 being set;
assume L269: C128 in D15;
L270: (ex B93 being (Element of C127) st C128 = ( Class B93 )) by L269 , L252;
thus L271: thesis by L270;
end;
L272: (for R1 being set holds (for R2 being set holds ((R1 in D15 & R2 in D15 & R1 <> R2) implies R1 misses R2)))
proof
let C129 , C130 being set;
assume that
L273: (C129 in D15 & C130 in D15)
and
L274: C129 <> C130;
assume L275: C129 meets C130;
L276: ((ex B94 being (Element of C127) st C129 = ( Class B94 )) & (ex B95 being (Element of C127) st C130 = ( Class B95 ))) by L273 , L252;
thus L277: contradiction by L276 , L274 , L275 , L232;
end;
consider C131 being set such that L278: (for R1 being set holds (R1 in D15 implies (ex B96 being set st ( C131 /\ R1 ) = { B96 }))) by L272 , L268 , WELLORD2:18;
L279: C131 is non  empty
proof
L280: ( Class ( 1. C127 ) ) in D15 by L252;
L281: (ex B97 being set st ( C131 /\ ( Class ( 1. C127 ) ) ) = { B97 }) by L280 , L278;
thus L282: thesis by L281;
end;
reconsider D16 = C131 as non  empty set by L279;
set D17 = { B98 where B98 is (Element of D16) : (ex B99 being non  empty (Subset of C127) st (B99 in D15 & ( D16 /\ B99 ) = { B98 })) };
L283: D17 is non  empty non  empty non  empty non  empty (Subset of C127)
proof
L284: D17 is non  empty
proof
L285: ( Class ( 1. C127 ) ) in D15 by L252;
consider C132 being set such that L286: ( D16 /\ ( Class ( 1. C127 ) ) ) = { C132 } by L285 , L278;
L287: C132 in { C132 } by TARSKI:def 1;
L288: C132 in D16 by L287 , L286 , XBOOLE_0:def 4;
L289: C132 in D17 by L288 , L285 , L286;
thus L290: thesis by L289;
end;
reconsider D18 = D17 as non  empty set by L284;
L291:
now
let C133 being set;
L292:
now
assume L293: C133 in D18;
consider C134 being (Element of D16) such that L294: (C133 = C134 & (ex B100 being non  empty (Subset of C127) st (B100 in D15 & ( D16 /\ B100 ) = { C134 }))) by L293;
L295: C134 in { C134 } by TARSKI:def 1;
thus L296: (C133 in D18 implies C133 in (the carrier of C127)) by L295 , L294;
end;
thus L297: (C133 in D18 implies C133 in (the carrier of C127)) by L292;
end;
thus L298: thesis by L291 , TARSKI:def 3;
end;
L299: (for B101 being (Element of D15) holds (ex B102 being (Element of D17) st ( D17 /\ B101 ) = { B102 }))
proof
let C135 being (Element of D15);
consider C136 being set such that L300: ( D16 /\ C135 ) = { C136 } by L278;
L301: C135 in ( Classes C127 );
L302: C135 is non  empty non  empty non  empty non  empty (Subset of C127) by L301 , L262;
L303: C136 in { C136 } by TARSKI:def 1;
L304: C136 in D16 by L303 , L300 , XBOOLE_0:def 4;
L305: C136 in D17 by L304 , L300 , L302;
L306: C136 in C135 by L300 , L303 , XBOOLE_0:def 4;
L307:
now
let C137 being set;
L308:
now
assume L309: C137 in ( D17 /\ C135 );
L310: C137 in D17 by L309 , XBOOLE_0:def 4;
L311: (ex B103 being (Element of D16) st (C137 = B103 & (ex B104 being non  empty (Subset of C127) st (B104 in D15 & ( D16 /\ B104 ) = { B103 })))) by L310;
L312: C137 in C135 by L309 , XBOOLE_0:def 4;
thus L313: (C137 in ( D17 /\ C135 ) implies C137 in { C136 }) by L312 , L300 , L311 , XBOOLE_0:def 4;
end;
L314:
now
assume L315: C137 in { C136 };
L316: C137 = C136 by L315 , TARSKI:def 1;
thus L317: (C137 in { C136 } implies C137 in ( D17 /\ C135 )) by L316 , L306 , L305 , XBOOLE_0:def 4;
end;
thus L318: (C137 in { C136 } iff C137 in ( D17 /\ C135 )) by L314 , L308;
end;
L319: ( D17 /\ C135 ) = { C136 } by L307 , TARSKI:1;
thus L320: thesis by L319 , L305;
end;
reconsider D19 = D17 as non  empty (Subset of C127) by L283;
L321: (for B105 , B106 being (Element of D19) holds (B105 <> B106 implies B105 is_not_associated_to B106))
proof
let C138 , C139 being (Element of D19);
assume L322: C138 <> C139;
L323: C138 is_associated_to C138;
L324: C138 in ( Class C138 ) by L323 , L210;
L325: C138 in ( D19 /\ ( Class C138 ) ) by L324 , XBOOLE_0:def 4;
L326: ( Class C138 ) in D15 by L252;
consider C140 being (Element of D19) such that L327: ( D19 /\ ( Class C138 ) ) = { C140 } by L326 , L299;
assume L328: C138 is_associated_to C139;
L329: C139 in ( Class C138 ) by L328 , L210;
L330: C139 in ( D19 /\ ( Class C138 ) ) by L329 , XBOOLE_0:def 4;
L331: C139 = C140 by L330 , L327 , TARSKI:def 1;
thus L332: thesis by L331 , L322 , L325 , L327 , TARSKI:def 1;
end;
L333: (for B107 being (Element of C127) holds (ex B108 being (Element of D19) st B108 is_associated_to B107))
proof
let C141 being (Element of C127);
reconsider D20 = ( Class C141 ) as (Element of D15) by L252;
consider C142 being (Element of D19) such that L334: ( D19 /\ D20 ) = { C142 } by L299;
L335: C142 in { C142 } by TARSKI:def 1;
L336: C142 in ( Class C141 ) by L335 , L334 , XBOOLE_0:def 4;
L337: C142 is_associated_to C141 by L336 , L210;
thus L338: thesis by L337;
end;
thus L339: (ex B109 being non  empty (Subset of C127) st ((for B110 being (Element of C127) holds (ex B111 being (Element of B109) st B111 is_associated_to B110)) & (for B112 , B113 being (Element of B109) holds (B112 <> B113 implies B112 is_not_associated_to B113)))) by L333 , L321;
end;
thus L340: thesis by L267;
end;
end;
definition
let C143 being  associative  well-unital non  empty multLoopStr;
mode AmpleSet of C143
 -> non  empty (Subset of C143)
means :L342: (it is (Am of C143) & ( 1. C143 ) in it);
existence
proof
L343:
now
let C144 being (Am of C143);
consider C145 being (Element of C144) such that L344: C145 is_associated_to ( 1. C143 ) by L266;
set D21 = ( { B114 where B114 is (Element of C144) : B114 <> C145 } \/ { ( 1. C143 ) } );
L345: ( 1. C143 ) in { ( 1. C143 ) } by TARSKI:def 1;
L346: ( 1. C143 ) in D21 by L345 , XBOOLE_0:def 3;
reconsider D22 = D21 as non  empty set;
L347: (for B115 being (Element of D22) holds (B115 = ( 1. C143 ) or B115 in C144))
proof
let C146 being (Element of D22);
L348:
now
per cases  by XBOOLE_0:def 3;
case L349: C146 in { B116 where B116 is (Element of C144) : B116 <> C145 };
L350: (ex B117 being (Element of C144) st (C146 = B117 & B117 <> C145)) by L349;
thus L351: thesis by L350;
end;
case L352: C146 in { ( 1. C143 ) };
thus L353: thesis by L352 , TARSKI:def 1;
end;
end;
thus L355: thesis by L348;
end;
L356:
now
let C147 being set;
L357:
now
assume L358: C147 in D22;
L359: C147 in (the carrier of C143)
proof
L360:
now
per cases  by L347 , L358;
case L361: C147 = ( 1. C143 );
thus L362: thesis by L361;
end;
case L363: C147 in C144;
thus L364: thesis by L363;
end;
end;
thus L366: thesis by L360;
end;
thus L367: (C147 in D22 implies C147 in (the carrier of C143)) by L359;
end;
thus L368: (C147 in D22 implies C147 in (the carrier of C143)) by L357;
end;
reconsider D23 = D22 as non  empty (Subset of C143) by L356 , TARSKI:def 3;
L369: (for B118 , B119 being (Element of D23) holds (B118 <> B119 implies B118 is_not_associated_to B119))
proof
let C148 , C149 being (Element of D23);
assume L370: C148 <> C149;
L371:
now
per cases ;
case L372: (C148 = ( 1. C143 ) & C149 = ( 1. C143 ));
thus L373: thesis by L372 , L370;
end;
case L374: (C148 = ( 1. C143 ) & C149 <> ( 1. C143 ));
assume L375: C148 is_associated_to C149;
L376: (not C149 in { ( 1. C143 ) }) by L374 , TARSKI:def 1;
L377: C149 in { B120 where B120 is (Element of C144) : B120 <> C145 } by L376 , XBOOLE_0:def 3;
L378: (ex B121 being (Element of C144) st (C149 = B121 & B121 <> C145)) by L377;
thus L379: thesis by L378 , L344 , L374 , L266 , L62;
end;
case L380: (C148 <> ( 1. C143 ) & C149 = ( 1. C143 ));
assume L381: C148 is_associated_to C149;
L382: (not C148 in { ( 1. C143 ) }) by L380 , TARSKI:def 1;
L383: C148 in { B122 where B122 is (Element of C144) : B122 <> C145 } by L382 , XBOOLE_0:def 3;
L384: (ex B123 being (Element of C144) st (C148 = B123 & B123 <> C145)) by L383;
thus L385: thesis by L384 , L344 , L380 , L266 , L62;
end;
case L386: (C148 <> ( 1. C143 ) & C149 <> ( 1. C143 ));
L387: (C148 in C144 & C149 in C144) by L386 , L347;
thus L388: thesis by L387 , L370 , L266;
end;
end;
thus L390: thesis by L371;
end;
L391: (for B124 being (Element of C143) holds (ex B125 being (Element of D23) st B125 is_associated_to B124))
proof
let C150 being (Element of C143);
L392:
now
per cases ;
case L393: C150 is_associated_to ( 1. C143 );
thus L394: thesis by L393 , L346;
end;
case L395: C150 is_not_associated_to ( 1. C143 );
consider C151 being (Element of C144) such that L396: C151 is_associated_to C150 by L266;
L397: C151 <> C145 by L344 , L395 , L396 , L62;
L398: C151 in { B126 where B126 is (Element of C144) : B126 <> C145 } by L397;
L399: C151 in D23 by L398 , XBOOLE_0:def 3;
thus L400: thesis by L399 , L396;
end;
end;
thus L402: thesis by L392;
end;
L403: D23 is (Am of C143) by L391 , L369 , L266;
thus L404: thesis by L403 , L346;
end;
thus L405: thesis by L343;
end;
end;
theorem
L407: (for B127 being  associative  well-unital non  empty multLoopStr holds (for B128 being (AmpleSet of B127) holds (( 1. B127 ) in B128 & (for B129 being (Element of B127) holds (ex B130 being (Element of B128) st B130 is_associated_to B129)) & (for B131 , B132 being (Element of B128) holds (B131 <> B132 implies B131 is_not_associated_to B132)))))
proof
let C152 being  associative  well-unital non  empty multLoopStr;
let C153 being (AmpleSet of C152);
L408: C153 is (Am of C152) by L342;
thus L409: thesis by L408 , L266 , L342;
end;
theorem
L410: (for B133 being  associative  well-unital non  empty multLoopStr holds (for B134 being (AmpleSet of B133) holds (for B135 , B136 being (Element of B134) holds (B135 is_associated_to B136 implies B135 = B136)))) by L407;
theorem
L411: (for R3 being  domRing-like  commutative Ring holds (for B137 being (AmpleSet of R3) holds ( 0. R3 ) is (Element of B137)))
proof
let R3 being  domRing-like  commutative Ring;
let C154 being (AmpleSet of R3);
consider C155 being (Element of C154) such that L412: C155 is_associated_to ( 0. R3 ) by L407;
L413: ( 0. R3 ) divides C155 by L412 , L35;
L414: (ex B138 being (Element of R3) st ( ( 0. R3 ) * B138 ) = C155) by L413 , L28;
thus L415: thesis by L414 , VECTSP_1:7;
end;
definition
let C156 being  associative  well-unital non  empty multLoopStr;
let C157 being (AmpleSet of C156);
let C158 being (Element of C156);
func NF (C158 , C157) -> (Element of C156) means 
:L416: (it in C157 & it is_associated_to C158);
existence
proof
L417:
now
let C159 being (AmpleSet of C156);
let C160 being (Element of C156);
L418: (ex B139 being (Element of C159) st B139 is_associated_to C160) by L407;
thus L419: (ex B140 being (Element of C156) st (B140 in C159 & B140 is_associated_to C160)) by L418;
end;
thus L420: thesis by L417;
end;
uniqueness by L62 , L407;
end;
theorem
L422: (for R3 being  domRing-like  commutative Ring holds (for B141 being (AmpleSet of R3) holds (( NF (( 0. R3 ) , B141) ) = ( 0. R3 ) & ( NF (( 1. R3 ) , B141) ) = ( 1. R3 ))))
proof
let R3 being  domRing-like  commutative Ring;
let C161 being (AmpleSet of R3);
L423: (( 1. R3 ) in C161 & ( 0. R3 ) is (Element of C161)) by L342 , L411;
thus L424: thesis by L423 , L416;
end;
theorem
L425: (for R3 being  domRing-like  commutative Ring holds (for B142 being (AmpleSet of R3) holds (for B143 being (Element of R3) holds (B143 in B142 iff B143 = ( NF (B143 , B142) ))))) by L416;
definition
let C162 being  associative  well-unital non  empty multLoopStr;
let C163 being (AmpleSet of C162);
attr C163 is  multiplicative
means
:L426: (for B144 , B145 being (Element of C163) holds ( B144 * B145 ) in C163);
end;
theorem
L428: (for R3 being  domRing-like  commutative Ring holds (for B146 being (AmpleSet of R3) holds (B146 is  multiplicative implies (for B147 , B148 being (Element of B146) holds ((B148 divides B147 & B148 <> ( 0. R3 )) implies ( B147 / B148 ) in B146)))))
proof
let R3 being  domRing-like  commutative Ring;
let C164 being (AmpleSet of R3);
assume L429: C164 is  multiplicative;
let C165 , C166 being (Element of C164);
assume that
L430: C166 divides C165
and
L431: C166 <> ( 0. R3 );
L432:
now
per cases ;
case L433: C165 <> ( 0. R3 );
set D24 = ( C165 / C166 );
consider C167 being (Element of C164) such that L434: C167 is_associated_to D24 by L407;
consider C168 being (Element of R3) such that L435: C168 is  unital and L436: ( D24 * C168 ) = C167 by L434 , L165;
L437: C165 = ( C166 * D24 ) by L430 , L431 , L42;
L438: ( C168 * C165 ) = ( C166 * C167 ) by L437 , L436 , GROUP_1:def 3;
L439: C165 is_associated_to ( C168 * C165 )
proof
L440: C168 divides ( 1. R3 ) by L435 , L33;
consider C169 being (Element of R3) such that L441: ( C168 * C169 ) = ( 1. R3 ) by L440 , L28;
L442: C165 divides C165;
L443: C165 divides ( C168 * C165 ) by L442 , L81;
L444: ( ( C168 * C165 ) * C169 ) = ( ( C169 * C168 ) * C165 ) by GROUP_1:def 3
.= C165 by L441 , VECTSP_1:def 8;
L445: ( C168 * C165 ) divides C165 by L444 , L28;
thus L446: thesis by L445 , L443 , L35;
end;
L447: ( C166 * C167 ) in C164 by L429 , L426;
L448: ( ( 1. R3 ) * C165 ) = C165 by VECTSP_1:def 8
.= ( C168 * C165 ) by L438 , L447 , L439 , L407;
L449: C168 = ( 1. R3 ) by L448 , L433 , L19;
L450: C167 = D24 by L449 , L436 , VECTSP_1:def 4;
thus L451: thesis by L450;
end;
case L452: C165 = ( 0. R3 );
set D25 = ( C165 / C166 );
L453: C165 = ( C166 * D25 ) by L430 , L431 , L42;
L454: D25 = ( 0. R3 ) by L453 , L431 , L452 , VECTSP_2:def 1;
L455: ( 0. R3 ) is (Element of C164) by L411;
thus L456: thesis by L455 , L454;
end;
end;
thus L458: thesis by L432;
end;
begin
definition
let C170 being non  empty multLoopStr;
attr C170 is  gcd-like
means
:L459: (for B149 , B150 being (Element of C170) holds (ex B151 being (Element of C170) st (B151 divides B149 & B151 divides B150 & (for B152 being (Element of C170) holds ((B152 divides B149 & B152 divides B150) implies B152 divides B151)))));
end;
L461:
now
let C171 being Field;
let C172 , C173 being (Element of C171);
L462:
now
per cases ;
case L463: (C172 <> ( 0. C171 ) & C173 <> ( 0. C171 ));
L464: (for B153 being (Element of C171) holds ((B153 divides C172 & B153 divides C173) implies B153 divides ( 1_ C171 )))
proof
let C174 being (Element of C171);
assume that
L465: C174 divides C172
and
L466: C174 divides C173;
L467:
now
per cases ;
case L468: C174 <> ( 0. C171 );
L469: (ex B154 being (Element of C171) st ( B154 * C174 ) = ( 1_ C171 )) by L468 , VECTSP_1:def 9;
thus L470: thesis by L469 , L28;
end;
case L471: C174 = ( 0. C171 );
assume L472: C174 divides C172;
L473: (ex B155 being (Element of C171) st ( C174 * B155 ) = C172) by L472 , L28;
thus L474: thesis by L473 , L463 , L471 , VECTSP_1:7;
end;
end;
thus L476: thesis by L467 , L465;
end;
L477: C173 = ( ( 1_ C171 ) * C173 ) by VECTSP_1:def 6;
L478: ( 1_ C171 ) divides C173 by L477 , L28;
L479: C172 = ( ( 1_ C171 ) * C172 ) by VECTSP_1:def 6;
L480: ( 1_ C171 ) divides C172 by L479 , L28;
thus L481: (ex B156 being (Element of C171) st (B156 divides C172 & B156 divides C173 & (for B157 being (Element of C171) holds ((B157 divides C172 & B157 divides C173) implies B157 divides B156)))) by L480 , L478 , L464;
end;
case L482: C172 = ( 0. C171 );
L483: ( C173 * ( 0. C171 ) ) = ( 0. C171 ) by VECTSP_1:7;
L484: C173 divides ( 0. C171 ) by L483 , L28;
L485: (for B158 being (Element of C171) holds ((B158 divides ( 0. C171 ) & B158 divides C173) implies B158 divides C173));
thus L486: (ex B159 being (Element of C171) st (B159 divides C172 & B159 divides C173 & (for B160 being (Element of C171) holds ((B160 divides C172 & B160 divides C173) implies B160 divides B159)))) by L485 , L482 , L484;
end;
case L487: C173 = ( 0. C171 );
L488: ( C172 * ( 0. C171 ) ) = ( 0. C171 ) by VECTSP_1:7;
L489: C172 divides ( 0. C171 ) by L488 , L28;
L490: (for B161 being (Element of C171) holds ((B161 divides C172 & B161 divides ( 0. C171 )) implies B161 divides C172));
thus L491: (ex B162 being (Element of C171) st (B162 divides C172 & B162 divides C173 & (for B163 being (Element of C171) holds ((B163 divides C172 & B163 divides C173) implies B163 divides B162)))) by L490 , L487 , L489;
end;
end;
thus L493: (ex B164 being (Element of C171) st (B164 divides C172 & B164 divides C173 & (for B165 being (Element of C171) holds ((B165 divides C172 & B165 divides C173) implies B165 divides B164)))) by L462;
end;
registration
cluster  gcd-like for domRing;
existence
proof
set D26 = the  strict Field;
reconsider D27 = D26 as comRing;
reconsider D28 = D27 as domRing by VECTSP_2:1;
L494: (for B166 , B167 being (Element of D28) holds (ex B168 being (Element of D28) st (B168 divides B166 & B168 divides B167 & (for B169 being (Element of D28) holds ((B169 divides B166 & B169 divides B167) implies B169 divides B168))))) by L461;
L495: D28 is  gcd-like by L494 , L459;
thus L496: thesis by L495;
end;
end;
registration
cluster  gcd-like  associative  commutative  well-unital for non  empty non  empty non  empty non  empty multLoopStr;
existence
proof
set D29 = the  strict Field;
L498: (for B170 , B171 being (Element of D29) holds (ex B172 being (Element of D29) st (B172 divides B170 & B172 divides B171 & (for B173 being (Element of D29) holds ((B173 divides B170 & B173 divides B171) implies B173 divides B172))))) by L461;
L499: D29 is  gcd-like by L498 , L459;
thus L500: thesis by L499;
end;
end;
registration
cluster  gcd-like  associative  commutative  well-unital for non  empty non  empty non  empty non  empty multLoopStr_0;
existence
proof
set D30 = the  strict Field;
L502: (for B174 , B175 being (Element of D30) holds (ex B176 being (Element of D30) st (B176 divides B174 & B176 divides B175 & (for B177 being (Element of D30) holds ((B177 divides B174 & B177 divides B175) implies B177 divides B176))))) by L461;
L503: D30 is  gcd-like by L502 , L459;
thus L504: thesis by L503;
end;
end;
registration
cluster  ->  gcd-like for  almost_left_invertible  add-associative  right_zeroed  right_complementable  left_unital  well-unital  left-distributive  right-distributive  commutative non  empty  almost_left_invertible  add-associative  right_zeroed  right_complementable  left_unital  well-unital  left-distributive  right-distributive  commutative non  empty  almost_left_invertible  add-associative  right_zeroed  right_complementable  left_unital  well-unital  left-distributive  right-distributive  commutative non  empty  almost_left_invertible  add-associative  right_zeroed  right_complementable  left_unital  well-unital  left-distributive  right-distributive  commutative non  empty doubleLoopStr;
coherence
proof
let C175 being  almost_left_invertible  add-associative  right_zeroed  right_complementable  left_unital  well-unital  left-distributive  right-distributive  commutative non  empty doubleLoopStr;
let C176 , C177 being (Element of C175);
L506:
now
per cases ;
case L507: (C176 <> ( 0. C175 ) & C177 <> ( 0. C175 ));
L508: (for B178 being (Element of C175) holds ((B178 divides C176 & B178 divides C177) implies B178 divides ( 1_ C175 )))
proof
let C178 being (Element of C175);
assume that
L509: C178 divides C176
and
L510: C178 divides C177;
L511:
now
per cases ;
case L512: C178 <> ( 0. C175 );
L513: (ex B179 being (Element of C175) st ( B179 * C178 ) = ( 1_ C175 )) by L512 , VECTSP_1:def 9;
thus L514: thesis by L513 , L28;
end;
case L515: C178 = ( 0. C175 );
assume L516: C178 divides C176;
L517: (ex B180 being (Element of C175) st ( C178 * B180 ) = C176) by L516 , L28;
thus L518: thesis by L517 , L507 , L515 , VECTSP_1:7;
end;
end;
thus L520: thesis by L511 , L509;
end;
L521: C177 = ( ( 1_ C175 ) * C177 ) by VECTSP_1:def 8;
L522: ( 1_ C175 ) divides C177 by L521 , L28;
L523: C176 = ( ( 1_ C175 ) * C176 ) by VECTSP_1:def 8;
L524: ( 1_ C175 ) divides C176 by L523 , L28;
thus L525: (ex B181 being (Element of C175) st (B181 divides C176 & B181 divides C177 & (for B182 being (Element of C175) holds ((B182 divides C176 & B182 divides C177) implies B182 divides B181)))) by L524 , L522 , L508;
end;
case L526: C176 = ( 0. C175 );
L527: ( C177 * ( 0. C175 ) ) = ( 0. C175 ) by VECTSP_1:6;
L528: C177 divides ( 0. C175 ) by L527 , L28;
L529: (for B183 being (Element of C175) holds ((B183 divides ( 0. C175 ) & B183 divides C177) implies B183 divides C177));
thus L530: (ex B184 being (Element of C175) st (B184 divides C176 & B184 divides C177 & (for B185 being (Element of C175) holds ((B185 divides C176 & B185 divides C177) implies B185 divides B184)))) by L529 , L526 , L528;
end;
case L531: C177 = ( 0. C175 );
L532: ( C176 * ( 0. C175 ) ) = ( 0. C175 ) by VECTSP_1:6;
L533: C176 divides ( 0. C175 ) by L532 , L28;
L534: (for B186 being (Element of C175) holds ((B186 divides C176 & B186 divides ( 0. C175 )) implies B186 divides C176));
thus L535: (ex B187 being (Element of C175) st (B187 divides C176 & B187 divides C177 & (for B188 being (Element of C175) holds ((B188 divides C176 & B188 divides C177) implies B188 divides B187)))) by L534 , L531 , L533;
end;
end;
thus L537: thesis by L506;
end;
end;
registration
cluster  gcd-like  associative  commutative  well-unital  domRing-like  unital  distributive non  degenerated  Abelian  add-associative  right_zeroed  right_complementable for non  empty non  empty non  empty non  empty doubleLoopStr;
existence
proof
take ( F_Real );
thus L539: thesis;
end;
end;
definition
mode gcdDomain
 is  gcd-like  domRing-like non  degenerated  commutative Ring;
end;
definition
let C179 being  gcd-like  associative  well-unital non  empty multLoopStr;
let C180 being (AmpleSet of C179);
let C181 , C182 being (Element of C179);
func gcd (C181 , C182 , C180) -> (Element of C179) means 
:L542: (it in C180 & it divides C181 & it divides C182 & (for B189 being (Element of C179) holds ((B189 divides C181 & B189 divides C182) implies B189 divides it)));
existence
proof
consider C183 being (Element of C179) such that L543: (C183 divides C181 & C183 divides C182) and L544: (for B190 being (Element of C179) holds ((B190 divides C181 & B190 divides C182) implies B190 divides C183)) by L459;
consider C184 being (Element of C180) such that L545: C184 is_associated_to C183 by L407;
L546: (for B191 being (Element of C179) holds ((B191 divides C181 & B191 divides C182) implies B191 divides C184))
proof
let C185 being (Element of C179);
assume L547: (C185 divides C181 & C185 divides C182);
L548: C185 divides C183 by L547 , L544;
L549: C183 divides C184 by L545 , L35;
thus L550: thesis by L549 , L548 , L46;
end;
L551: C184 divides C183 by L545 , L35;
L552: (C184 divides C181 & C184 divides C182) by L551 , L543 , L46;
thus L553: thesis by L552 , L546;
end;
uniqueness
proof
L554:
now
let C186 being (Element of C179);
assume that
L555: C186 in C180
and
L556: (C186 divides C181 & C186 divides C182 & (for B192 being (Element of C179) holds ((B192 divides C181 & B192 divides C182) implies B192 divides C186)));
let C187 being (Element of C179);
assume that
L557: C187 in C180
and
L558: (C187 divides C181 & C187 divides C182 & (for B193 being (Element of C179) holds ((B193 divides C181 & B193 divides C182) implies B193 divides C187)));
L559: (C186 divides C187 & C187 divides C186) by L556 , L558;
L560: C186 is_associated_to C187 by L559 , L35;
thus L561: C186 = C187 by L560 , L555 , L557 , L407;
end;
thus L562: thesis by L554;
end;
end;
theorem
L564: (for R5 being gcdDomain holds (for B194 being (AmpleSet of R5) holds (for B195 , B196 , B197 being (Element of R5) holds (B197 divides ( gcd (B195 , B196 , B194) ) implies (B197 divides B195 & B197 divides B196)))))
proof
let R5 being gcdDomain;
let C188 being (AmpleSet of R5);
let C189 , C190 , C191 being (Element of R5);
assume L565: C191 divides ( gcd (C189 , C190 , C188) );
consider C192 being (Element of R5) such that L566: ( C191 * C192 ) = ( gcd (C189 , C190 , C188) ) by L565 , L28;
L567: ( gcd (C189 , C190 , C188) ) divides C189 by L542;
consider C193 being (Element of R5) such that L568: ( ( gcd (C189 , C190 , C188) ) * C193 ) = C189 by L567 , L28;
L569: ( C191 * ( C192 * C193 ) ) = C189 by L566 , L568 , GROUP_1:def 3;
L570: ( gcd (C189 , C190 , C188) ) divides C190 by L542;
consider C194 being (Element of R5) such that L571: ( ( gcd (C189 , C190 , C188) ) * C194 ) = C190 by L570 , L28;
L572: ( C191 * ( C192 * C194 ) ) = C190 by L566 , L571 , GROUP_1:def 3;
thus L573: thesis by L572 , L569 , L28;
end;
theorem
L574: (for R5 being gcdDomain holds (for B198 being (AmpleSet of R5) holds (for B199 , B200 being (Element of R5) holds ( gcd (B199 , B200 , B198) ) = ( gcd (B200 , B199 , B198) ))))
proof
let R5 being gcdDomain;
let C195 being (AmpleSet of R5);
let C196 , C197 being (Element of R5);
set D31 = ( gcd (C196 , C197 , C195) );
L575: (D31 divides C196 & (for B201 being (Element of R5) holds ((B201 divides C197 & B201 divides C196) implies B201 divides D31))) by L542;
L576: (D31 in C195 & D31 divides C197) by L542;
thus L577: thesis by L576 , L575 , L542;
end;
theorem
L578: (for R5 being gcdDomain holds (for B202 being (AmpleSet of R5) holds (for B203 being (Element of R5) holds (( gcd (B203 , ( 0. R5 ) , B202) ) = ( NF (B203 , B202) ) & ( gcd (( 0. R5 ) , B203 , B202) ) = ( NF (B203 , B202) )))))
proof
let R5 being gcdDomain;
let C198 being (AmpleSet of R5);
let C199 being (Element of R5);
L579: ( NF (C199 , C198) ) in C198 by L416;
L580: ( ( NF (C199 , C198) ) * ( 0. R5 ) ) = ( 0. R5 ) by VECTSP_1:6;
L581: ( NF (C199 , C198) ) divides ( 0. R5 ) by L580 , L28;
L582: ( NF (C199 , C198) ) is_associated_to C199 by L416;
L583: (for B204 being (Element of R5) holds ((B204 divides C199 & B204 divides ( 0. R5 )) implies B204 divides ( NF (C199 , C198) )))
proof
let C200 being (Element of R5);
assume that
L584: C200 divides C199
and
L585: C200 divides ( 0. R5 );
L586: C199 divides ( NF (C199 , C198) ) by L582 , L35;
thus L587: thesis by L586 , L584 , L46;
end;
L588: ( NF (C199 , C198) ) divides C199 by L582 , L35;
L589: ( gcd (C199 , ( 0. R5 ) , C198) ) = ( NF (C199 , C198) ) by L588 , L581 , L583 , L579 , L542;
thus L590: thesis by L589 , L574;
end;
theorem
L591: (for R5 being gcdDomain holds (for B205 being (AmpleSet of R5) holds ( gcd (( 0. R5 ) , ( 0. R5 ) , B205) ) = ( 0. R5 )))
proof
let R5 being gcdDomain;
let C201 being (AmpleSet of R5);
L592: ( gcd (( 0. R5 ) , ( 0. R5 ) , C201) ) = ( NF (( 0. R5 ) , C201) ) by L578;
thus L593: thesis by L592 , L422;
end;
theorem
L594: (for R5 being gcdDomain holds (for B206 being (AmpleSet of R5) holds (for B207 being (Element of R5) holds (( gcd (B207 , ( 1. R5 ) , B206) ) = ( 1. R5 ) & ( gcd (( 1. R5 ) , B207 , B206) ) = ( 1. R5 )))))
proof
let R5 being gcdDomain;
let C202 being (AmpleSet of R5);
let C203 being (Element of R5);
L595: ( ( 1. R5 ) * C203 ) = C203 by VECTSP_1:def 8;
L596: ( 1. R5 ) divides C203 by L595 , L28;
L597: (( 1. R5 ) in C202 & (for B208 being (Element of R5) holds ((B208 divides C203 & B208 divides ( 1. R5 )) implies B208 divides ( 1. R5 )))) by L342;
L598: ( gcd (C203 , ( 1. R5 ) , C202) ) = ( 1. R5 ) by L597 , L596 , L542;
thus L599: thesis by L598 , L574;
end;
theorem
L600: (for R5 being gcdDomain holds (for B209 being (AmpleSet of R5) holds (for B210 , B211 being (Element of R5) holds (( gcd (B210 , B211 , B209) ) = ( 0. R5 ) iff (B210 = ( 0. R5 ) & B211 = ( 0. R5 ))))))
proof
let R5 being gcdDomain;
let C204 being (AmpleSet of R5);
let C205 , C206 being (Element of R5);
L601:
now
assume L602: ( gcd (C205 , C206 , C204) ) = ( 0. R5 );
L603: ( 0. R5 ) divides C206 by L602 , L542;
L604: (ex B212 being (Element of R5) st ( ( 0. R5 ) * B212 ) = C206) by L603 , L28;
L605: ( 0. R5 ) divides C205 by L602 , L542;
L606: (ex B213 being (Element of R5) st ( ( 0. R5 ) * B213 ) = C205) by L605 , L28;
thus L607: (( gcd (C205 , C206 , C204) ) = ( 0. R5 ) implies (C205 = ( 0. R5 ) & C206 = ( 0. R5 ))) by L606 , L604 , VECTSP_1:7;
end;
L608: ((C205 = ( 0. R5 ) & C206 = ( 0. R5 )) implies ( gcd (C205 , C206 , C204) ) = ( 0. R5 ))
proof
assume that
L609: C205 = ( 0. R5 )
and
L610: C206 = ( 0. R5 );
L611: ( gcd (C205 , C206 , C204) ) = ( NF (C205 , C204) ) by L610 , L578;
thus L612: thesis by L611 , L609 , L422;
end;
thus L613: thesis by L608 , L601;
end;
theorem
L614: (for R5 being gcdDomain holds (for B214 being (AmpleSet of R5) holds (for B215 , B216 , B217 being (Element of R5) holds (B216 is_associated_to B217 implies (( gcd (B215 , B216 , B214) ) is_associated_to ( gcd (B215 , B217 , B214) ) & ( gcd (B216 , B215 , B214) ) is_associated_to ( gcd (B217 , B215 , B214) ))))))
proof
let R5 being gcdDomain;
let C207 being (AmpleSet of R5);
let C208 , C209 , C210 being (Element of R5);
L615: ( gcd (C208 , C209 , C207) ) divides C209 by L542;
L616: ( gcd (C208 , C209 , C207) ) divides C208 by L542;
L617: ( gcd (C208 , C210 , C207) ) divides C208 by L542;
L618: ( gcd (C208 , C210 , C207) ) divides C210 by L542;
L619: ( gcd (C208 , C209 , C207) ) = ( gcd (C209 , C208 , C207) ) by L574;
assume L620: C209 is_associated_to C210;
L621: C210 divides C209 by L620 , L35;
L622: ( gcd (C208 , C210 , C207) ) divides C209 by L621 , L618 , L46;
L623: ( gcd (C208 , C210 , C207) ) divides ( gcd (C208 , C209 , C207) ) by L622 , L617 , L542;
L624: C209 divides C210 by L620 , L35;
L625: ( gcd (C208 , C209 , C207) ) divides C210 by L624 , L615 , L46;
L626: ( gcd (C208 , C209 , C207) ) divides ( gcd (C208 , C210 , C207) ) by L625 , L616 , L542;
L627: ( gcd (C208 , C209 , C207) ) is_associated_to ( gcd (C208 , C210 , C207) ) by L626 , L623 , L35;
thus L628: thesis by L627 , L619 , L574;
end;
theorem
L629: (for R5 being gcdDomain holds (for B218 being (AmpleSet of R5) holds (for B219 , B220 , B221 being (Element of R5) holds ( gcd (( gcd (B219 , B220 , B218) ) , B221 , B218) ) = ( gcd (B219 , ( gcd (B220 , B221 , B218) ) , B218) ))))
proof
let R5 being gcdDomain;
let C211 being (AmpleSet of R5);
let C212 , C213 , C214 being (Element of R5);
set D32 = ( gcd (( gcd (C212 , C213 , C211) ) , C214 , C211) );
set D33 = ( gcd (C212 , ( gcd (C213 , C214 , C211) ) , C211) );
L630: D32 divides C214 by L542;
L631: D33 divides C212 by L542;
L632: D33 divides ( gcd (C213 , C214 , C211) ) by L542;
L633: D33 divides C214 by L632 , L564;
L634: D33 divides C213 by L632 , L564;
L635: D33 divides ( gcd (C212 , C213 , C211) ) by L634 , L631 , L542;
L636: D33 divides D32 by L635 , L633 , L542;
L637: (D32 is (Element of C211) & D33 is (Element of C211)) by L542;
L638: D32 divides ( gcd (C212 , C213 , C211) ) by L542;
L639: D32 divides C212 by L638 , L564;
L640: D32 divides C213 by L638 , L564;
L641: D32 divides ( gcd (C213 , C214 , C211) ) by L640 , L630 , L542;
L642: D32 divides D33 by L641 , L639 , L542;
L643: D32 is_associated_to D33 by L642 , L636 , L35;
thus L644: thesis by L643 , L637 , L407;
end;
theorem
L645: (for R5 being gcdDomain holds (for B222 being (AmpleSet of R5) holds (for B223 , B224 , B225 being (Element of R5) holds ( gcd (( B223 * B225 ) , ( B224 * B225 ) , B222) ) is_associated_to ( B225 * ( gcd (B223 , B224 , B222) ) ))))
proof
let R5 being gcdDomain;
let C215 being (AmpleSet of R5);
let C216 , C217 , C218 being (Element of R5);
L646:
now
per cases ;
case L647: C218 <> ( 0. R5 );
set D34 = ( gcd (C216 , C217 , C215) );
L648:
now
per cases ;
case L649: D34 <> ( 0. R5 );
set D35 = ( gcd (( C216 * C218 ) , ( C217 * C218 ) , C215) );
L650: D35 divides ( C217 * C218 ) by L542;
L651: D34 divides C217 by L542;
L652: ( C218 * D34 ) divides ( C217 * C218 ) by L651 , L71;
L653: D34 divides C216 by L542;
L654: ( C218 * D34 ) divides ( C216 * C218 ) by L653 , L71;
L655: ( C218 * D34 ) divides ( gcd (( C216 * C218 ) , ( C217 * C218 ) , C215) ) by L654 , L652 , L542;
consider C219 being (Element of R5) such that L656: D35 = ( ( C218 * D34 ) * C219 ) by L655 , L28;
L657: D35 divides ( C216 * C218 ) by L542;
L658: (( D34 * C219 ) divides C216 & ( D34 * C219 ) divides C217)
proof
consider C220 being (Element of R5) such that L659: ( ( ( C218 * D34 ) * C219 ) * C220 ) = ( C216 * C218 ) by L656 , L657 , L28;
L660: ( ( C218 * ( D34 * C219 ) ) * C220 ) = ( C218 * C216 ) by L659 , GROUP_1:def 3;
L661: ( C218 * ( D34 * C219 ) ) divides ( C218 * C216 ) by L660 , L28;
consider C221 being (Element of R5) such that L662: ( ( ( C218 * D34 ) * C219 ) * C221 ) = ( C217 * C218 ) by L656 , L650 , L28;
L663: ( ( C218 * ( D34 * C219 ) ) * C221 ) = ( C218 * C217 ) by L662 , GROUP_1:def 3;
L664: ( C218 * ( D34 * C219 ) ) divides ( C218 * C217 ) by L663 , L28;
thus L665: thesis by L664 , L647 , L661 , L144;
end;
L666: ( D34 * C219 ) divides D34 by L658 , L542;
L667: D34 = ( D34 * ( 1. R5 ) ) by VECTSP_1:def 4;
L668: C219 divides ( 1. R5 ) by L667 , L649 , L666 , L144;
L669: C219 is  unital by L668 , L33;
thus L670: thesis by L669 , L656 , L165;
end;
case L671: D34 = ( 0. R5 );
L672: ( C218 * ( gcd (C216 , C217 , C215) ) ) = ( 0. R5 ) by L671 , VECTSP_1:7;
L673: (C216 = ( 0. R5 ) & C217 = ( 0. R5 )) by L671 , L600;
L674: ( gcd (( C216 * C218 ) , ( C217 * C218 ) , C215) ) = ( gcd (( 0. R5 ) , ( ( 0. R5 ) * C218 ) , C215) ) by L673 , VECTSP_1:7
.= ( gcd (( 0. R5 ) , ( 0. R5 ) , C215) ) by VECTSP_1:7
.= ( C218 * ( gcd (C216 , C217 , C215) ) ) by L672 , L591;
thus L675: thesis by L674;
end;
end;
thus L677: thesis by L648;
end;
case L678: C218 = ( 0. R5 );
L679: (( C216 * C218 ) = ( 0. R5 ) & ( C217 * C218 ) = ( 0. R5 )) by L678 , VECTSP_1:7;
L680: ( gcd (( C216 * C218 ) , ( C217 * C218 ) , C215) ) = ( 0. R5 ) by L679 , L591
.= ( C218 * ( gcd (C216 , C217 , C215) ) ) by L678 , VECTSP_1:7;
thus L681: thesis by L680;
end;
end;
thus L683: thesis by L646;
end;
theorem
L684: (for R5 being gcdDomain holds (for B226 being (AmpleSet of R5) holds (for B227 , B228 , B229 being (Element of R5) holds (( gcd (B227 , B228 , B226) ) = ( 1. R5 ) implies ( gcd (B227 , ( B228 * B229 ) , B226) ) = ( gcd (B227 , B229 , B226) )))))
proof
let R5 being gcdDomain;
let C222 being (AmpleSet of R5);
let C223 , C224 , C225 being (Element of R5);
assume L685: ( gcd (C223 , C224 , C222) ) = ( 1. R5 );
L686: ( C225 * ( gcd (C223 , C224 , C222) ) ) = C225 by L685 , VECTSP_1:def 4;
L687: ( gcd (( C223 * C225 ) , ( C224 * C225 ) , C222) ) is_associated_to ( C225 * ( gcd (C223 , C224 , C222) ) ) by L645;
L688: ( gcd (C223 , C225 , C222) ) is_associated_to ( gcd (C223 , ( gcd (( C223 * C225 ) , ( C224 * C225 ) , C222) ) , C222) ) by L687 , L686 , L614;
L689: ( gcd (C223 , C225 , C222) ) is_associated_to ( gcd (( gcd (C223 , ( C223 * C225 ) , C222) ) , ( C224 * C225 ) , C222) ) by L688 , L629;
L690: ( C223 * ( gcd (( 1. R5 ) , C225 , C222) ) ) = ( C223 * ( 1. R5 ) ) by L594
.= C223 by VECTSP_1:def 4;
L691: ( gcd (( C223 * ( 1. R5 ) ) , ( C223 * C225 ) , C222) ) is_associated_to ( C223 * ( gcd (( 1. R5 ) , C225 , C222) ) ) by L645;
L692: ( gcd (C223 , ( C223 * C225 ) , C222) ) is_associated_to C223 by L691 , L690 , VECTSP_1:def 4;
L693: ( gcd (( gcd (C223 , ( C223 * C225 ) , C222) ) , ( C224 * C225 ) , C222) ) is_associated_to ( gcd (C223 , ( C224 * C225 ) , C222) ) by L692 , L614;
L694: (( gcd (C223 , ( C224 * C225 ) , C222) ) is (Element of C222) & ( gcd (C223 , C225 , C222) ) is (Element of C222)) by L542;
thus L695: thesis by L694 , L689 , L693 , L62 , L407;
end;
theorem
L696: (for R5 being gcdDomain holds (for B230 being (AmpleSet of R5) holds (for B231 , B232 , B233 being (Element of R5) holds ((B233 = ( gcd (B231 , B232 , B230) ) & B233 <> ( 0. R5 )) implies ( gcd (( B231 / B233 ) , ( B232 / B233 ) , B230) ) = ( 1. R5 )))))
proof
let R5 being gcdDomain;
let C226 being (AmpleSet of R5);
let C227 , C228 , C229 being (Element of R5);
assume that
L697: C229 = ( gcd (C227 , C228 , C226) )
and
L698: C229 <> ( 0. R5 );
set D36 = ( C227 / C229 );
L699: C229 divides C227 by L697 , L542;
L700: ( D36 * C229 ) = C227 by L699 , L698 , L42;
set D37 = ( C228 / C229 );
L701: ( gcd (( D36 * C229 ) , ( D37 * C229 ) , C226) ) is_associated_to ( C229 * ( gcd (D36 , D37 , C226) ) ) by L645;
L702: (( gcd (D36 , D37 , C226) ) is (Element of C226) & ( 1. R5 ) is (Element of C226)) by L342 , L542;
L703: C229 divides C228 by L697 , L542;
L704: ( gcd (C227 , C228 , C226) ) = ( gcd (( D36 * C229 ) , ( D37 * C229 ) , C226) ) by L703 , L698 , L700 , L42;
L705: ( C229 * ( 1. R5 ) ) is_associated_to ( C229 * ( gcd (D36 , D37 , C226) ) ) by L704 , L697 , L701 , VECTSP_1:def 4;
thus L706: thesis by L705 , L698 , L702 , L202 , L407;
end;
theorem
L707: (for R5 being gcdDomain holds (for B234 being (AmpleSet of R5) holds (for B235 , B236 , B237 being (Element of R5) holds ( gcd (( B235 + ( B236 * B237 ) ) , B237 , B234) ) = ( gcd (B235 , B237 , B234) ))))
proof
let R5 being gcdDomain;
let C230 being (AmpleSet of R5);
let C231 , C232 , C233 being (Element of R5);
set D38 = ( gcd (C231 , C233 , C230) );
L708: D38 divides C231 by L542;
consider C234 being (Element of R5) such that L709: ( D38 * C234 ) = C231 by L708 , L28;
L710: D38 divides C233 by L542;
consider C235 being (Element of R5) such that L711: ( D38 * C235 ) = C233 by L710 , L28;
L712: (for B238 being (Element of R5) holds ((B238 divides ( C231 + ( C232 * C233 ) ) & B238 divides C233) implies B238 divides D38))
proof
let C236 being (Element of R5);
assume that
L713: C236 divides ( C231 + ( C232 * C233 ) )
and
L714: C236 divides C233;
consider C237 being (Element of R5) such that L715: ( C236 * C237 ) = C233 by L714 , L28;
consider C238 being (Element of R5) such that L716: ( C236 * C238 ) = ( C231 + ( C232 * C233 ) ) by L713 , L28;
L717: ( C236 * ( C238 + ( - ( C232 * C237 ) ) ) ) = ( ( C236 * C238 ) + ( C236 * ( - ( C232 * C237 ) ) ) ) by VECTSP_1:def 2
.= ( ( C236 * C238 ) + ( - ( C236 * ( C237 * C232 ) ) ) ) by VECTSP_1:8
.= ( ( C231 + ( C232 * C233 ) ) + ( - ( C233 * C232 ) ) ) by L715 , L716 , GROUP_1:def 3
.= ( C231 + ( ( C232 * C233 ) + ( - ( C233 * C232 ) ) ) ) by RLVECT_1:def 3
.= ( C231 + ( 0. R5 ) ) by RLVECT_1:def 10
.= C231 by RLVECT_1:4;
L718: C236 divides C231 by L717 , L28;
thus L719: thesis by L718 , L714 , L542;
end;
L720: ( D38 * ( C234 + ( C235 * C232 ) ) ) = ( ( D38 * C234 ) + ( D38 * ( C235 * C232 ) ) ) by VECTSP_1:def 2
.= ( C231 + ( C232 * C233 ) ) by L709 , L711 , GROUP_1:def 3;
L721: D38 divides ( C231 + ( C232 * C233 ) ) by L720 , L28;
L722: D38 is (Element of C230) by L542;
thus L723: thesis by L722 , L710 , L721 , L712 , L542;
end;
begin
::$N Brown Theorem
theorem
L724: (for R5 being gcdDomain holds (for B239 being (AmpleSet of R5) holds (for B240 , B241 , B242 , B243 being (Element of R5) holds ((( gcd (B240 , B241 , B239) ) = ( 1. R5 ) & ( gcd (B242 , B243 , B239) ) = ( 1. R5 ) & B241 <> ( 0. R5 )) implies ( gcd (( ( B240 * ( B243 / ( gcd (B241 , B243 , B239) ) ) ) + ( B242 * ( B241 / ( gcd (B241 , B243 , B239) ) ) ) ) , ( B241 * ( B243 / ( gcd (B241 , B243 , B239) ) ) ) , B239) ) = ( gcd (( ( B240 * ( B243 / ( gcd (B241 , B243 , B239) ) ) ) + ( B242 * ( B241 / ( gcd (B241 , B243 , B239) ) ) ) ) , ( gcd (B241 , B243 , B239) ) , B239) )))))
proof
let R5 being gcdDomain;
let C239 being (AmpleSet of R5);
let C240 , C241 , C242 , C243 being (Element of R5);
assume that
L725: ( gcd (C240 , C241 , C239) ) = ( 1. R5 )
and
L726: ( gcd (C242 , C243 , C239) ) = ( 1. R5 )
and
L727: C241 <> ( 0. R5 );
set D39 = ( gcd (C241 , C243 , C239) );
set D40 = ( C241 / D39 );
set D41 = ( C243 / D39 );
L728: D39 <> ( 0. R5 ) by L727 , L600;
L729: ( gcd (D40 , D41 , C239) ) = ( 1. R5 ) by L728 , L696;
L730: D39 divides C243 by L542;
L731: ( gcd (D41 , C242 , C239) ) = ( 1. R5 )
proof
L732: ( gcd (D41 , C242 , C239) ) divides D41 by L542;
consider C244 being (Element of R5) such that L733: ( ( gcd (D41 , C242 , C239) ) * C244 ) = D41 by L732 , L28;
L734: ( ( gcd (D41 , C242 , C239) ) * ( C244 * D39 ) ) = ( D41 * D39 ) by L733 , GROUP_1:def 3
.= C243 by L730 , L728 , L42;
L735: ( gcd (D41 , C242 , C239) ) divides C243 by L734 , L28;
L736: (( gcd (D41 , C242 , C239) ) is (Element of C239) & ( 1. R5 ) is (Element of C239)) by L342 , L542;
L737: ( ( 1. R5 ) * ( gcd (D41 , C242 , C239) ) ) = ( gcd (D41 , C242 , C239) ) by VECTSP_1:def 8;
L738: ( 1. R5 ) divides ( gcd (D41 , C242 , C239) ) by L737 , L28;
L739: ( gcd (D41 , C242 , C239) ) divides C242 by L542;
L740: ( gcd (D41 , C242 , C239) ) divides ( gcd (C242 , C243 , C239) ) by L739 , L735 , L542;
L741: ( gcd (D41 , C242 , C239) ) is_associated_to ( 1. R5 ) by L740 , L726 , L738 , L35;
thus L742: thesis by L741 , L736 , L407;
end;
L743: ( gcd (D41 , ( C242 * D40 ) , C239) ) = ( gcd (D41 , D40 , C239) ) by L731 , L684;
L744: ( gcd (( ( C240 * D41 ) + ( C242 * D40 ) ) , D41 , C239) ) = ( gcd (( C242 * D40 ) , D41 , C239) ) by L707;
L745: ( gcd (( ( C240 * D41 ) + ( C242 * D40 ) ) , D41 , C239) ) = ( gcd (D41 , ( C242 * D40 ) , C239) ) by L744 , L574
.= ( 1. R5 ) by L743 , L729 , L574;
L746: D39 divides ( D39 * C241 ) by L76;
L747: D39 divides C241 by L542;
L748: ( gcd (D40 , C240 , C239) ) = ( 1. R5 )
proof
L749: ( gcd (D40 , C240 , C239) ) divides D40 by L542;
consider C245 being (Element of R5) such that L750: ( ( gcd (D40 , C240 , C239) ) * C245 ) = D40 by L749 , L28;
L751: ( ( gcd (D40 , C240 , C239) ) * ( C245 * D39 ) ) = ( D40 * D39 ) by L750 , GROUP_1:def 3
.= C241 by L747 , L728 , L42;
L752: ( gcd (D40 , C240 , C239) ) divides C241 by L751 , L28;
L753: (( gcd (D40 , C240 , C239) ) is (Element of C239) & ( 1. R5 ) is (Element of C239)) by L342 , L542;
L754: ( ( 1. R5 ) * ( gcd (D40 , C240 , C239) ) ) = ( gcd (D40 , C240 , C239) ) by VECTSP_1:def 8;
L755: ( 1. R5 ) divides ( gcd (D40 , C240 , C239) ) by L754 , L28;
L756: ( gcd (D40 , C240 , C239) ) divides C240 by L542;
L757: ( gcd (D40 , C240 , C239) ) divides ( gcd (C240 , C241 , C239) ) by L756 , L752 , L542;
L758: ( gcd (D40 , C240 , C239) ) is_associated_to ( 1. R5 ) by L757 , L725 , L755 , L35;
thus L759: thesis by L758 , L753 , L407;
end;
L760: ( gcd (D40 , ( C240 * D41 ) , C239) ) = ( gcd (D40 , D41 , C239) ) by L748 , L684;
L761: ( gcd (( ( C240 * D41 ) + ( C242 * D40 ) ) , D40 , C239) ) = ( gcd (( C240 * D41 ) , D40 , C239) ) by L707;
L762: ( gcd (D40 , D41 , C239) ) = ( 1. R5 ) by L728 , L696;
L763: ( gcd (( ( C240 * D41 ) + ( C242 * D40 ) ) , ( D39 * D40 ) , C239) ) = ( gcd (( ( C240 * D41 ) + ( C242 * D40 ) ) , D39 , C239) ) by L762 , L761 , L760 , L574 , L684;
L764: ( C241 * D41 ) = ( ( ( 1. R5 ) * C241 ) * D41 ) by VECTSP_1:def 8
.= ( ( ( D39 / D39 ) * C241 ) * D41 ) by L728 , L96
.= ( ( ( D39 * C241 ) / D39 ) * D41 ) by L728 , L746 , L105
.= ( D41 * ( D39 * D40 ) ) by L747 , L728 , L746 , L105;
thus L765: thesis by L764 , L745 , L763 , L684;
end;
::$N Henrici Theorem
theorem
L766: (for R5 being gcdDomain holds (for B244 being (AmpleSet of R5) holds (for B245 , B246 , B247 , B248 being (Element of R5) holds ((( gcd (B245 , B246 , B244) ) = ( 1. R5 ) & ( gcd (B247 , B248 , B244) ) = ( 1. R5 ) & B246 <> ( 0. R5 ) & B248 <> ( 0. R5 )) implies ( gcd (( ( B245 / ( gcd (B245 , B248 , B244) ) ) * ( B247 / ( gcd (B247 , B246 , B244) ) ) ) , ( ( B246 / ( gcd (B247 , B246 , B244) ) ) * ( B248 / ( gcd (B245 , B248 , B244) ) ) ) , B244) ) = ( 1. R5 )))))
proof
let R5 being gcdDomain;
let C246 being (AmpleSet of R5);
let C247 , C248 , C249 , C250 being (Element of R5);
assume that
L767: ( gcd (C247 , C248 , C246) ) = ( 1. R5 )
and
L768: ( gcd (C249 , C250 , C246) ) = ( 1. R5 )
and
L769: C248 <> ( 0. R5 )
and
L770: C250 <> ( 0. R5 );
set D42 = ( gcd (C247 , C250 , C246) );
L771: D42 <> ( 0. R5 ) by L770 , L600;
set D43 = ( gcd (C249 , C248 , C246) );
set D44 = ( C249 / D43 );
set D45 = ( C248 / D43 );
L772: D43 <> ( 0. R5 ) by L769 , L600;
L773: ( gcd (D44 , D45 , C246) ) = ( 1. R5 ) by L772 , L696;
set D46 = ( C247 / D42 );
L774: ( gcd (D46 , D45 , C246) ) divides D45 by L542;
L775: D43 divides C248 by L542;
L776: ( D45 * D43 ) = C248 by L775 , L772 , L42;
L777: D45 divides C248 by L776 , L28;
L778: ( gcd (D46 , D45 , C246) ) divides C248 by L777 , L774 , L46;
L779: (( gcd (D46 , D45 , C246) ) is (Element of C246) & ( 1. R5 ) is (Element of C246)) by L342 , L542;
L780: D42 divides C247 by L542;
L781: ( D46 * D42 ) = C247 by L780 , L771 , L42;
L782: D46 divides C247 by L781 , L28;
L783: ( ( 1. R5 ) * ( gcd (D46 , D45 , C246) ) ) = ( gcd (D46 , D45 , C246) ) by VECTSP_1:def 8;
L784: ( 1. R5 ) divides ( gcd (D46 , D45 , C246) ) by L783 , L28;
L785: ( gcd (D46 , D45 , C246) ) divides D46 by L542;
L786: ( gcd (D46 , D45 , C246) ) divides C247 by L785 , L782 , L46;
L787: ( gcd (D46 , D45 , C246) ) divides ( gcd (C247 , C248 , C246) ) by L786 , L778 , L542;
L788: ( gcd (D46 , D45 , C246) ) is_associated_to ( 1. R5 ) by L787 , L767 , L784 , L35;
L789: ( gcd (D46 , D45 , C246) ) = ( 1. R5 ) by L788 , L779 , L407;
L790: ( gcd (D45 , D46 , C246) ) = ( 1. R5 ) by L789 , L574;
set D47 = ( C250 / D42 );
L791: ( gcd (D44 , D47 , C246) ) divides D47 by L542;
L792: D42 divides C250 by L542;
L793: ( D47 * D42 ) = C250 by L792 , L771 , L42;
L794: D47 divides C250 by L793 , L28;
L795: ( gcd (D44 , D47 , C246) ) divides C250 by L794 , L791 , L46;
L796: (( gcd (D44 , D47 , C246) ) is (Element of C246) & ( 1. R5 ) is (Element of C246)) by L342 , L542;
L797: D43 divides C249 by L542;
L798: ( D44 * D43 ) = C249 by L797 , L772 , L42;
L799: D44 divides C249 by L798 , L28;
L800: ( ( 1. R5 ) * ( gcd (D44 , D47 , C246) ) ) = ( gcd (D44 , D47 , C246) ) by VECTSP_1:def 8;
L801: ( 1. R5 ) divides ( gcd (D44 , D47 , C246) ) by L800 , L28;
L802: ( gcd (D44 , D47 , C246) ) divides D44 by L542;
L803: ( gcd (D44 , D47 , C246) ) divides C249 by L802 , L799 , L46;
L804: ( gcd (D44 , D47 , C246) ) divides ( gcd (C249 , C250 , C246) ) by L803 , L795 , L542;
L805: ( gcd (D44 , D47 , C246) ) is_associated_to ( 1. R5 ) by L804 , L768 , L801 , L35;
L806: ( gcd (D44 , D47 , C246) ) = ( 1. R5 ) by L805 , L796 , L407;
L807: ( gcd (D47 , D46 , C246) ) = ( gcd (( C247 / D42 ) , ( C250 / D42 ) , C246) ) by L574
.= ( 1. R5 ) by L771 , L696;
L808: ( gcd (( D46 * D44 ) , D45 , C246) ) = ( gcd (D45 , ( D46 * D44 ) , C246) ) by L574
.= ( gcd (D45 , D44 , C246) ) by L790 , L684
.= ( 1. R5 ) by L773 , L574;
L809: ( gcd (( D46 * D44 ) , ( D45 * D47 ) , C246) ) = ( gcd (( D46 * D44 ) , D47 , C246) ) by L808 , L684
.= ( gcd (D47 , ( D46 * D44 ) , C246) ) by L574
.= ( gcd (D47 , D44 , C246) ) by L807 , L684
.= ( 1. R5 ) by L806 , L574;
thus L810: thesis by L809;
end;
begin
definition
let C251 being  gcd-like  associative  well-unital non  empty multLoopStr;
let C252 being (AmpleSet of C251);
let C253 , C254 being (Element of C251);
pred C253 , C254 are_canonical_wrt C252
means
:L811: ( gcd (C253 , C254 , C252) ) = ( 1. C251 )
;end;
theorem
L813: (for R5 being gcdDomain holds (for B249 , B250 being (AmpleSet of R5) holds (for B251 , B252 being (Element of R5) holds (B251 , B252 are_canonical_wrt B249 implies B251 , B252 are_canonical_wrt B250))))
proof
let R5 being gcdDomain;
let C255 , C256 being (AmpleSet of R5);
let C257 , C258 being (Element of R5);
L814: ( ( 1. R5 ) * C257 ) = C257 by VECTSP_1:def 8;
L815: ( 1. R5 ) divides C257 by L814 , L28;
L816: ( ( 1. R5 ) * C258 ) = C258 by VECTSP_1:def 8;
L817: ( 1. R5 ) divides C258 by L816 , L28;
assume L818: C257 , C258 are_canonical_wrt C255;
L819: ( gcd (C257 , C258 , C255) ) = ( 1. R5 ) by L818 , L811;
L820: (for B253 being (Element of R5) holds ((B253 divides C257 & B253 divides C258) implies B253 divides ( 1. R5 ))) by L819 , L542;
L821: ( 1. R5 ) in C256 by L342;
L822: ( gcd (C257 , C258 , C256) ) = ( 1. R5 ) by L821 , L820 , L815 , L817 , L542;
thus L823: thesis by L822 , L811;
end;
definition
let C259 being  gcd-like  associative  well-unital non  empty multLoopStr;
let C260 , C261 being (Element of C259);
pred C260 , C261 are_co-prime 
means
:L824: (ex B254 being (AmpleSet of C259) st ( gcd (C260 , C261 , B254) ) = ( 1. C259 ))
;end;
definition
let C262 being gcdDomain;
let C263 , C264 being (Element of C262);
redefine pred C263 , C264 are_co-prime 
;
symmetry
proof
let C265 , C266 being (Element of C262);
given C267 being (AmpleSet of C262) such that
L826: ( gcd (C265 , C266 , C267) ) = ( 1. C262 );

L827: ( gcd (C266 , C265 , C267) ) = ( 1. C262 ) by L826 , L574;
thus L828: thesis by L827 , L824;
end;
end;
theorem
L830: (for R5 being gcdDomain holds (for B255 being (AmpleSet of R5) holds (for B256 , B257 being (Element of R5) holds (B256 , B257 are_co-prime  implies ( gcd (B256 , B257 , B255) ) = ( 1. R5 )))))
proof
let R5 being gcdDomain;
let C268 being (AmpleSet of R5);
let C269 , C270 being (Element of R5);
assume L831: C269 , C270 are_co-prime ;
consider C271 being (AmpleSet of R5) such that L832: ( gcd (C269 , C270 , C271) ) = ( 1. R5 ) by L831 , L824;
L833: C269 , C270 are_canonical_wrt C271 by L832 , L811;
L834: C269 , C270 are_canonical_wrt C268 by L833 , L813;
thus L835: thesis by L834 , L811;
end;
definition
let C272 being  gcd-like  associative  well-unital non  empty multLoopStr_0;
let C273 being (AmpleSet of C272);
let C274 , C275 being (Element of C272);
pred C274 , C275 are_normalized_wrt C273
means
:L836: (( gcd (C274 , C275 , C273) ) = ( 1. C272 ) & C275 in C273 & C275 <> ( 0. C272 ))
;end;
definition
let C276 being gcdDomain;
let C277 being (AmpleSet of C276);
let C278 , C279 , C280 , C281 being (Element of C276);
assume that
L838: C278 , C279 are_co-prime 
and
L839: C280 , C281 are_co-prime 
and
L840: C279 = ( NF (C279 , C277) )
and
L841: C281 = ( NF (C281 , C277) );
func add1 (C278 , C279 , C280 , C281 , C277) -> (Element of C276) equals 
:L842: C280 if C278 = ( 0. C276 ) , C278 if C280 = ( 0. C276 ) , ( ( C278 * C281 ) + ( C279 * C280 ) ) if ( gcd (C279 , C281 , C277) ) = ( 1. C276 ) , ( 0. C276 ) if ( ( C278 * ( C281 / ( gcd (C279 , C281 , C277) ) ) ) + ( C280 * ( C279 / ( gcd (C279 , C281 , C277) ) ) ) ) = ( 0. C276 ) otherwise ( ( ( C278 * ( C281 / ( gcd (C279 , C281 , C277) ) ) ) + ( C280 * ( C279 / ( gcd (C279 , C281 , C277) ) ) ) ) / ( gcd (( ( C278 * ( C281 / ( gcd (C279 , C281 , C277) ) ) ) + ( C280 * ( C279 / ( gcd (C279 , C281 , C277) ) ) ) ) , ( gcd (C279 , C281 , C277) ) , C277) ) );
coherence;
consistency
proof
L843: ( gcd (C280 , C281 , C277) ) = ( 1. C276 ) by L839 , L830;
L844: ((C280 = ( 0. C276 ) & ( gcd (C279 , C281 , C277) ) = ( 1. C276 )) implies (for B258 being (Element of C276) holds (B258 = C278 iff B258 = ( ( C278 * C281 ) + ( C279 * C280 ) ))))
proof
assume that
L845: C280 = ( 0. C276 )
and
L846: ( gcd (C279 , C281 , C277) ) = ( 1. C276 );
L847: C281 = ( 1. C276 ) by L841 , L843 , L845 , L578;
let C282 being (Element of C276);
L848: ( ( C278 * C281 ) + ( C279 * C280 ) ) = ( ( C278 * C281 ) + ( 0. C276 ) ) by L845 , VECTSP_1:7
.= ( C278 * ( 1. C276 ) ) by L847 , RLVECT_1:4
.= C278 by VECTSP_1:def 4;
thus L849: thesis by L848;
end;
L850: ((C280 = ( 0. C276 ) & ( ( C278 * ( C281 / ( gcd (C279 , C281 , C277) ) ) ) + ( C280 * ( C279 / ( gcd (C279 , C281 , C277) ) ) ) ) = ( 0. C276 )) implies (for B259 being (Element of C276) holds (B259 = C278 iff B259 = ( 0. C276 ))))
proof
L851: ( 1. C276 ) <> ( 0. C276 );
assume that
L852: C280 = ( 0. C276 )
and
L853: ( ( C278 * ( C281 / ( gcd (C279 , C281 , C277) ) ) ) + ( C280 * ( C279 / ( gcd (C279 , C281 , C277) ) ) ) ) = ( 0. C276 );
let C283 being (Element of C276);
L854: C281 = ( 1. C276 ) by L841 , L843 , L852 , L578;
L855: ( gcd (C279 , C281 , C277) ) = ( 1. C276 ) by L854 , L594;
L856: ( 0. C276 ) = ( ( C278 * ( C281 / ( gcd (C279 , C281 , C277) ) ) ) + ( 0. C276 ) ) by L852 , L853 , VECTSP_1:7
.= ( C278 * ( ( 1. C276 ) / ( gcd (C279 , C281 , C277) ) ) ) by L854 , RLVECT_1:4
.= ( C278 * ( 1. C276 ) ) by L855 , L851 , L96
.= C278 by VECTSP_1:def 4;
thus L857: thesis by L856;
end;
L858: ( gcd (C278 , C279 , C277) ) = ( 1. C276 ) by L838 , L830;
L859: ((C278 = ( 0. C276 ) & ( gcd (C279 , C281 , C277) ) = ( 1. C276 )) implies (for B260 being (Element of C276) holds (B260 = C280 iff B260 = ( ( C278 * C281 ) + ( C279 * C280 ) ))))
proof
assume that
L860: C278 = ( 0. C276 )
and
L861: ( gcd (C279 , C281 , C277) ) = ( 1. C276 );
L862: C279 = ( 1. C276 ) by L840 , L858 , L860 , L578;
let C284 being (Element of C276);
L863: ( ( C278 * C281 ) + ( C279 * C280 ) ) = ( ( 0. C276 ) + ( C279 * C280 ) ) by L860 , VECTSP_1:7
.= ( ( 1. C276 ) * C280 ) by L862 , RLVECT_1:4
.= C280 by VECTSP_1:def 8;
thus L864: thesis by L863;
end;
L865: ((C278 = ( 0. C276 ) & ( ( C278 * ( C281 / ( gcd (C279 , C281 , C277) ) ) ) + ( C280 * ( C279 / ( gcd (C279 , C281 , C277) ) ) ) ) = ( 0. C276 )) implies (for B261 being (Element of C276) holds (B261 = C280 iff B261 = ( 0. C276 ))))
proof
L866: ( 1. C276 ) <> ( 0. C276 );
assume that
L867: C278 = ( 0. C276 )
and
L868: ( ( C278 * ( C281 / ( gcd (C279 , C281 , C277) ) ) ) + ( C280 * ( C279 / ( gcd (C279 , C281 , C277) ) ) ) ) = ( 0. C276 );
let C285 being (Element of C276);
L869: C279 = ( 1. C276 ) by L840 , L858 , L867 , L578;
L870: ( gcd (C279 , C281 , C277) ) = ( 1. C276 ) by L869 , L594;
L871: ( 0. C276 ) = ( ( 0. C276 ) + ( C280 * ( C279 / ( gcd (C279 , C281 , C277) ) ) ) ) by L867 , L868 , VECTSP_1:7
.= ( C280 * ( ( 1. C276 ) / ( gcd (C279 , C281 , C277) ) ) ) by L869 , RLVECT_1:4
.= ( C280 * ( 1. C276 ) ) by L870 , L866 , L96
.= C280 by VECTSP_1:def 4;
thus L872: thesis by L871;
end;
L873: ((( gcd (C279 , C281 , C277) ) = ( 1. C276 ) & ( ( C278 * ( C281 / ( gcd (C279 , C281 , C277) ) ) ) + ( C280 * ( C279 / ( gcd (C279 , C281 , C277) ) ) ) ) = ( 0. C276 )) implies (for B262 being (Element of C276) holds (B262 = ( ( C278 * C281 ) + ( C279 * C280 ) ) iff B262 = ( 0. C276 ))))
proof
assume L874: (( gcd (C279 , C281 , C277) ) = ( 1. C276 ) & ( ( C278 * ( C281 / ( gcd (C279 , C281 , C277) ) ) ) + ( C280 * ( C279 / ( gcd (C279 , C281 , C277) ) ) ) ) = ( 0. C276 ));
let C286 being (Element of C276);
L875: ( 0. C276 ) = ( ( C278 * C281 ) + ( C280 * ( C279 / ( 1. C276 ) ) ) ) by L874 , L100
.= ( ( C278 * C281 ) + ( C280 * C279 ) ) by L100;
thus L876: thesis by L875;
end;
thus L877: thesis by L873 , L859 , L865 , L844 , L850;
end;
end;
definition
let C287 being gcdDomain;
let C288 being (AmpleSet of C287);
let C289 , C290 , C291 , C292 being (Element of C287);
assume that
L879: C289 , C290 are_co-prime 
and
L880: C291 , C292 are_co-prime 
and
L881: C290 = ( NF (C290 , C288) )
and
L882: C292 = ( NF (C292 , C288) );
func add2 (C289 , C290 , C291 , C292 , C288) -> (Element of C287) equals 
:L883: C292 if C289 = ( 0. C287 ) , C290 if C291 = ( 0. C287 ) , ( C290 * C292 ) if ( gcd (C290 , C292 , C288) ) = ( 1. C287 ) , ( 1. C287 ) if ( ( C289 * ( C292 / ( gcd (C290 , C292 , C288) ) ) ) + ( C291 * ( C290 / ( gcd (C290 , C292 , C288) ) ) ) ) = ( 0. C287 ) otherwise ( ( C290 * ( C292 / ( gcd (C290 , C292 , C288) ) ) ) / ( gcd (( ( C289 * ( C292 / ( gcd (C290 , C292 , C288) ) ) ) + ( C291 * ( C290 / ( gcd (C290 , C292 , C288) ) ) ) ) , ( gcd (C290 , C292 , C288) ) , C288) ) );
coherence;
consistency
proof
L884: ((( gcd (C290 , C292 , C288) ) = ( 1. C287 ) & ( ( C289 * ( C292 / ( gcd (C290 , C292 , C288) ) ) ) + ( C291 * ( C290 / ( gcd (C290 , C292 , C288) ) ) ) ) = ( 0. C287 )) implies (for B263 being (Element of C287) holds (B263 = ( C290 * C292 ) iff B263 = ( 1. C287 ))))
proof
assume that
L885: ( gcd (C290 , C292 , C288) ) = ( 1. C287 )
and
L886: ( ( C289 * ( C292 / ( gcd (C290 , C292 , C288) ) ) ) + ( C291 * ( C290 / ( gcd (C290 , C292 , C288) ) ) ) ) = ( 0. C287 );
L887: ( 0. C287 ) = ( ( C289 * C292 ) + ( C291 * ( C290 / ( 1. C287 ) ) ) ) by L885 , L886 , L100
.= ( ( C289 * C292 ) + ( C291 * C290 ) ) by L100;
L888: ( C289 * C292 ) = ( - ( C291 * C290 ) ) by L887 , RLVECT_1:6;
L889: ( C291 * C290 ) = ( - ( C289 * C292 ) ) by L887 , RLVECT_1:6;
L890: ( gcd (C292 , C291 , C288) ) = ( 1. C287 ) by L880 , L830;
L891: ( gcd (C292 , ( C291 * C290 ) , C288) ) = ( gcd (C292 , C290 , C288) ) by L890 , L684
.= ( 1. C287 ) by L885 , L574;
L892: ( 1. C287 ) = ( gcd (( ( 1. C287 ) * C292 ) , ( - ( C289 * C292 ) ) , C288) ) by L891 , L889 , VECTSP_1:def 8
.= ( gcd (( ( 1. C287 ) * C292 ) , ( ( - C289 ) * C292 ) , C288) ) by VECTSP_1:8;
L893: ( 1. C287 ) is_associated_to ( C292 * ( gcd (( 1. C287 ) , ( - C289 ) , C288) ) ) by L892 , L645;
let C293 being (Element of C287);
L894: ( 1. C287 ) in C288 by L407;
L895: ( gcd (C290 , C289 , C288) ) = ( 1. C287 ) by L879 , L830;
L896: ( gcd (C290 , ( C289 * C292 ) , C288) ) = ( 1. C287 ) by L895 , L885 , L684;
L897: ( 1. C287 ) = ( gcd (( ( 1. C287 ) * C290 ) , ( - ( C291 * C290 ) ) , C288) ) by L896 , L888 , VECTSP_1:def 8
.= ( gcd (( ( 1. C287 ) * C290 ) , ( ( - C291 ) * C290 ) , C288) ) by VECTSP_1:8;
L898: ( 1. C287 ) is_associated_to ( C290 * ( gcd (( 1. C287 ) , ( - C291 ) , C288) ) ) by L897 , L645;
L899: ( C292 * ( gcd (( 1. C287 ) , ( - C289 ) , C288) ) ) = ( C292 * ( 1. C287 ) ) by L594
.= C292 by VECTSP_1:def 4;
L900: C292 = ( 1. C287 ) by L899 , L882 , L894 , L893 , L416;
L901: ( C290 * ( gcd (( 1. C287 ) , ( - C291 ) , C288) ) ) = ( C290 * ( 1. C287 ) ) by L594
.= C290 by VECTSP_1:def 4;
L902: C290 = ( 1. C287 ) by L901 , L881 , L898 , L894 , L416;
thus L903: thesis by L902 , L900 , VECTSP_1:def 4;
end;
L904: ( gcd (C289 , C290 , C288) ) = ( 1. C287 ) by L879 , L830;
L905: ((C289 = ( 0. C287 ) & ( gcd (C290 , C292 , C288) ) = ( 1. C287 )) implies (for B264 being (Element of C287) holds (B264 = C292 iff B264 = ( C290 * C292 ))))
proof
assume that
L906: C289 = ( 0. C287 )
and
L907: ( gcd (C290 , C292 , C288) ) = ( 1. C287 );
let C294 being (Element of C287);
L908: C290 = ( 1. C287 ) by L881 , L904 , L906 , L578;
thus L909: thesis by L908 , VECTSP_1:def 8;
end;
L910: ( gcd (C291 , C292 , C288) ) = ( 1. C287 ) by L880 , L830;
L911: ((C291 = ( 0. C287 ) & ( gcd (C290 , C292 , C288) ) = ( 1. C287 )) implies (for B265 being (Element of C287) holds (B265 = C290 iff B265 = ( C290 * C292 ))))
proof
assume that
L912: C291 = ( 0. C287 )
and
L913: ( gcd (C290 , C292 , C288) ) = ( 1. C287 );
let C295 being (Element of C287);
L914: C292 = ( 1. C287 ) by L882 , L910 , L912 , L578;
thus L915: thesis by L914 , VECTSP_1:def 4;
end;
L916: ((C291 = ( 0. C287 ) & ( ( C289 * ( C292 / ( gcd (C290 , C292 , C288) ) ) ) + ( C291 * ( C290 / ( gcd (C290 , C292 , C288) ) ) ) ) = ( 0. C287 )) implies (for B266 being (Element of C287) holds (B266 = C290 iff B266 = ( 1. C287 ))))
proof
L917: ( 1. C287 ) <> ( 0. C287 );
assume that
L918: C291 = ( 0. C287 )
and
L919: ( ( C289 * ( C292 / ( gcd (C290 , C292 , C288) ) ) ) + ( C291 * ( C290 / ( gcd (C290 , C292 , C288) ) ) ) ) = ( 0. C287 );
let C296 being (Element of C287);
L920: C292 = ( 1. C287 ) by L882 , L910 , L918 , L578;
L921: ( gcd (C290 , C292 , C288) ) = ( 1. C287 ) by L920 , L594;
L922: ( 0. C287 ) = ( ( C289 * ( C292 / ( gcd (C290 , C292 , C288) ) ) ) + ( 0. C287 ) ) by L918 , L919 , VECTSP_1:7
.= ( C289 * ( ( 1. C287 ) / ( gcd (C290 , C292 , C288) ) ) ) by L920 , RLVECT_1:4
.= ( C289 * ( 1. C287 ) ) by L921 , L917 , L96
.= C289 by VECTSP_1:def 4;
thus L923: thesis by L922 , L881 , L904 , L578;
end;
L924: ((C289 = ( 0. C287 ) & ( ( C289 * ( C292 / ( gcd (C290 , C292 , C288) ) ) ) + ( C291 * ( C290 / ( gcd (C290 , C292 , C288) ) ) ) ) = ( 0. C287 )) implies (for B267 being (Element of C287) holds (B267 = C292 iff B267 = ( 1. C287 ))))
proof
L925: ( 1. C287 ) <> ( 0. C287 );
assume that
L926: C289 = ( 0. C287 )
and
L927: ( ( C289 * ( C292 / ( gcd (C290 , C292 , C288) ) ) ) + ( C291 * ( C290 / ( gcd (C290 , C292 , C288) ) ) ) ) = ( 0. C287 );
let C297 being (Element of C287);
L928: C290 = ( 1. C287 ) by L881 , L904 , L926 , L578;
L929: ( gcd (C290 , C292 , C288) ) = ( 1. C287 ) by L928 , L594;
L930: ( 0. C287 ) = ( ( 0. C287 ) + ( C291 * ( C290 / ( gcd (C290 , C292 , C288) ) ) ) ) by L926 , L927 , VECTSP_1:7
.= ( C291 * ( ( 1. C287 ) / ( gcd (C290 , C292 , C288) ) ) ) by L928 , RLVECT_1:4
.= ( C291 * ( 1. C287 ) ) by L929 , L925 , L96
.= C291 by VECTSP_1:def 4;
thus L931: thesis by L930 , L882 , L910 , L578;
end;
L932: ((C289 = ( 0. C287 ) & C291 = ( 0. C287 )) implies (for B268 being (Element of C287) holds (B268 = C292 iff B268 = C290)))
proof
assume that
L933: C289 = ( 0. C287 )
and
L934: C291 = ( 0. C287 );
let C298 being (Element of C287);
L935: C290 = ( 1. C287 ) by L881 , L904 , L933 , L578;
thus L936: thesis by L935 , L882 , L910 , L934 , L578;
end;
thus L937: thesis by L932 , L905 , L924 , L911 , L916 , L884;
end;
end;
theorem
L939: (for R5 being gcdDomain holds (for B269 being (AmpleSet of R5) holds (for B270 , B271 , B272 , B273 being (Element of R5) holds ((B269 is  multiplicative & B270 , B271 are_normalized_wrt B269 & B272 , B273 are_normalized_wrt B269) implies ( add1 (B270 , B271 , B272 , B273 , B269) ) , ( add2 (B270 , B271 , B272 , B273 , B269) ) are_normalized_wrt B269))))
proof
let R5 being gcdDomain;
let C299 being (AmpleSet of R5);
let C300 , C301 , C302 , C303 being (Element of R5);
assume that
L940: C299 is  multiplicative
and
L941: C300 , C301 are_normalized_wrt C299
and
L942: C302 , C303 are_normalized_wrt C299;
L943: C301 <> ( 0. R5 ) by L941 , L836;
L944: C301 in C299 by L941 , L836;
L945: C301 = ( NF (C301 , C299) ) by L944 , L416;
L946: C303 in C299 by L942 , L836;
L947: C303 = ( NF (C303 , C299) ) by L946 , L416;
L948: ( gcd (C300 , C301 , C299) ) = ( 1. R5 ) by L941 , L836;
L949: C300 , C301 are_co-prime  by L948 , L824;
L950: ( gcd (C302 , C303 , C299) ) = ( 1. R5 ) by L942 , L836;
L951: C302 , C303 are_co-prime  by L950 , L824;
L952: C303 <> ( 0. R5 ) by L942 , L836;
L953:
now
per cases ;
case L954: C300 = ( 0. R5 );
L955: ( add2 (C300 , C301 , C302 , C303 , C299) ) = C303 by L954 , L945 , L947 , L949 , L951 , L883;
thus L956: thesis by L955 , L942 , L945 , L947 , L949 , L951 , L954 , L842;
end;
case L957: C302 = ( 0. R5 );
L958: ( add2 (C300 , C301 , C302 , C303 , C299) ) = C301 by L957 , L945 , L947 , L949 , L951 , L883;
thus L959: thesis by L958 , L941 , L945 , L947 , L949 , L951 , L957 , L842;
end;
case L960: ( gcd (C301 , C303 , C299) ) = ( 1. R5 );
L961: ( add2 (C300 , C301 , C302 , C303 , C299) ) = ( C301 * C303 ) by L960 , L945 , L947 , L949 , L951 , L883;
L962: ( add1 (C300 , C301 , C302 , C303 , C299) ) = ( ( C300 * C303 ) + ( C301 * C302 ) ) by L945 , L947 , L949 , L951 , L960 , L842;
L963: ( gcd (( add1 (C300 , C301 , C302 , C303 , C299) ) , ( add2 (C300 , C301 , C302 , C303 , C299) ) , C299) ) = ( gcd (( ( C300 * ( C303 / ( 1. R5 ) ) ) + ( C302 * C301 ) ) , ( C301 * C303 ) , C299) ) by L962 , L961 , L100
.= ( gcd (( ( C300 * ( C303 / ( 1. R5 ) ) ) + ( C302 * ( C301 / ( 1. R5 ) ) ) ) , ( C301 * C303 ) , C299) ) by L100
.= ( gcd (( ( C300 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) + ( C302 * ( C301 / ( gcd (C301 , C303 , C299) ) ) ) ) , ( C301 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) , C299) ) by L960 , L100
.= ( gcd (( ( C300 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) + ( C302 * ( C301 / ( gcd (C301 , C303 , C299) ) ) ) ) , ( gcd (C301 , C303 , C299) ) , C299) ) by L943 , L948 , L950 , L724
.= ( 1. R5 ) by L960 , L594;
reconsider D48 = C301 , D49 = C303 as (Element of C299) by L941 , L942 , L836;
L964: (( D48 * D49 ) in C299 & ( D48 * D49 ) <> ( 0. R5 )) by L940 , L943 , L952 , L426 , VECTSP_2:def 1;
thus L965: thesis by L964 , L961 , L963 , L836;
end;
case L966: ( ( C300 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) + ( C302 * ( C301 / ( gcd (C301 , C303 , C299) ) ) ) ) = ( 0. R5 );
L967: (( 1. R5 ) in C299 & ( 1. R5 ) <> ( 0. R5 )) by L407;
L968: ( add2 (C300 , C301 , C302 , C303 , C299) ) = ( 1. R5 ) by L945 , L947 , L949 , L951 , L966 , L883;
L969: ( gcd (( add1 (C300 , C301 , C302 , C303 , C299) ) , ( add2 (C300 , C301 , C302 , C303 , C299) ) , C299) ) = ( 1. R5 ) by L968 , L594;
thus L970: thesis by L969 , L968 , L967 , L836;
end;
case L971: (C300 <> ( 0. R5 ) & C302 <> ( 0. R5 ) & ( gcd (C301 , C303 , C299) ) <> ( 1. R5 ) & ( ( C300 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) + ( C302 * ( C301 / ( gcd (C301 , C303 , C299) ) ) ) ) <> ( 0. R5 ));
L972: (( add1 (C300 , C301 , C302 , C303 , C299) ) = ( ( ( C300 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) + ( C302 * ( C301 / ( gcd (C301 , C303 , C299) ) ) ) ) / ( gcd (( ( C300 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) + ( C302 * ( C301 / ( gcd (C301 , C303 , C299) ) ) ) ) , ( gcd (C301 , C303 , C299) ) , C299) ) ) & ( add2 (C300 , C301 , C302 , C303 , C299) ) = ( ( C301 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) / ( gcd (( ( C300 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) + ( C302 * ( C301 / ( gcd (C301 , C303 , C299) ) ) ) ) , ( gcd (C301 , C303 , C299) ) , C299) ) )) by L971 , L945 , L947 , L949 , L951 , L842 , L883;
L973: ( gcd (C301 , C303 , C299) ) <> ( 0. R5 ) by L943 , L600;
L974: ( gcd (( ( C300 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) + ( C302 * ( C301 / ( gcd (C301 , C303 , C299) ) ) ) ) , ( gcd (C301 , C303 , C299) ) , C299) ) <> ( 0. R5 ) by L973 , L600;
L975: ( gcd (( ( C300 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) + ( C302 * ( C301 / ( gcd (C301 , C303 , C299) ) ) ) ) , ( C301 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) , C299) ) = ( gcd (( ( C300 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) + ( C302 * ( C301 / ( gcd (C301 , C303 , C299) ) ) ) ) , ( gcd (C301 , C303 , C299) ) , C299) ) by L943 , L948 , L950 , L724;
L976: ( gcd (( ( ( C300 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) + ( C302 * ( C301 / ( gcd (C301 , C303 , C299) ) ) ) ) / ( gcd (( ( C300 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) + ( C302 * ( C301 / ( gcd (C301 , C303 , C299) ) ) ) ) , ( gcd (C301 , C303 , C299) ) , C299) ) ) , ( ( C301 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) / ( gcd (( ( C300 * ( C303 / ( gcd (C301 , C303 , C299) ) ) ) + ( C302 * ( C301 / ( gcd (C301 , C303 , C299) ) ) ) ) , ( gcd (C301 , C303 , C299) ) , C299) ) ) , C299) ) = ( 1. R5 ) by L975 , L974 , L696;
reconsider D50 = C301 , D51 = C303 as (Element of C299) by L941 , L942 , L836;
L977: ( gcd (D50 , D51 , C299) ) divides D51 by L542;
reconsider D52 = ( gcd (( ( C300 * ( D51 / ( gcd (D50 , D51 , C299) ) ) ) + ( C302 * ( D50 / ( gcd (D50 , D51 , C299) ) ) ) ) , ( gcd (D50 , D51 , C299) ) , C299) ) as (Element of C299) by L542;
L978: ( gcd (D50 , D51 , C299) ) <> ( 0. R5 ) by L943 , L600;
L979: D52 <> ( 0. R5 ) by L978 , L600;
L980: ( gcd (D50 , D51 , C299) ) in C299 by L542;
reconsider D53 = ( D51 / ( gcd (D50 , D51 , C299) ) ) as (Element of C299) by L980 , L940 , L977 , L978 , L428;
L981: ( D50 * D53 ) in C299 by L940 , L426;
reconsider D54 = ( D50 * ( D51 / ( gcd (D50 , D51 , C299) ) ) ) as (Element of C299) by L981;
L982: ( D50 * D51 ) <> ( 0. R5 ) by L943 , L952 , VECTSP_2:def 1;
L983: ( gcd (D50 , D51 , C299) ) divides ( D50 * D51 ) by L977 , L81;
L984: D54 = ( ( D50 * D51 ) / ( gcd (D50 , D51 , C299) ) ) by L983 , L977 , L978 , L105;
L985: D54 <> ( 0. R5 ) by L984 , L978 , L982 , L983 , L86;
L986: (D52 divides ( gcd (D50 , D51 , C299) ) & ( gcd (D50 , D51 , C299) ) divides D50) by L542;
L987: D52 divides D50 by L986 , L46;
L988: D52 divides D54 by L987 , L81;
L989: ( D54 / D52 ) <> ( 0. R5 ) by L988 , L979 , L985 , L86;
L990: ( D54 / D52 ) in C299 by L940 , L987 , L979 , L81 , L428;
thus L991: thesis by L990 , L972 , L976 , L989 , L836;
end;
end;
thus L993: thesis by L953;
end;
theorem
L994: (for R5 being gcdDomain holds (for B274 being (AmpleSet of R5) holds (for B275 , B276 , B277 , B278 being (Element of R5) holds ((B275 , B276 are_normalized_wrt B274 & B277 , B278 are_normalized_wrt B274) implies ( ( add1 (B275 , B276 , B277 , B278 , B274) ) * ( B276 * B278 ) ) = ( ( add2 (B275 , B276 , B277 , B278 , B274) ) * ( ( B275 * B278 ) + ( B277 * B276 ) ) )))))
proof
let R5 being gcdDomain;
let C304 being (AmpleSet of R5);
let C305 , C306 , C307 , C308 being (Element of R5);
assume that
L995: C305 , C306 are_normalized_wrt C304
and
L996: C307 , C308 are_normalized_wrt C304;
L997: ( gcd (C305 , C306 , C304) ) = ( 1. R5 ) by L995 , L836;
L998: C305 , C306 are_co-prime  by L997 , L824;
L999: C308 in C304 by L996 , L836;
L1000: C308 = ( NF (C308 , C304) ) by L999 , L416;
L1001: ( gcd (C307 , C308 , C304) ) = ( 1. R5 ) by L996 , L836;
L1002: C307 , C308 are_co-prime  by L1001 , L824;
L1003: C306 in C304 by L995 , L836;
L1004: C306 = ( NF (C306 , C304) ) by L1003 , L416;
L1005: C306 <> ( 0. R5 ) by L995 , L836;
L1006:
now
per cases ;
case L1007: C305 = ( 0. R5 );
L1008: ( add1 (C305 , C306 , C307 , C308 , C304) ) = C307 by L1007 , L998 , L1002 , L1004 , L1000 , L842;
L1009: ( add2 (C305 , C306 , C307 , C308 , C304) ) = C308 by L998 , L1002 , L1004 , L1000 , L1007 , L883;
L1010: ( ( add2 (C305 , C306 , C307 , C308 , C304) ) * ( ( C305 * C308 ) + ( C307 * C306 ) ) ) = ( C308 * ( ( 0. R5 ) + ( C307 * C306 ) ) ) by L1009 , L1007 , VECTSP_1:7
.= ( C308 * ( C307 * C306 ) ) by RLVECT_1:4
.= ( ( add1 (C305 , C306 , C307 , C308 , C304) ) * ( C306 * C308 ) ) by L1008 , GROUP_1:def 3;
thus L1011: thesis by L1010;
end;
case L1012: C307 = ( 0. R5 );
L1013: ( add1 (C305 , C306 , C307 , C308 , C304) ) = C305 by L1012 , L998 , L1002 , L1004 , L1000 , L842;
L1014: ( add2 (C305 , C306 , C307 , C308 , C304) ) = C306 by L998 , L1002 , L1004 , L1000 , L1012 , L883;
L1015: ( ( add2 (C305 , C306 , C307 , C308 , C304) ) * ( ( C305 * C308 ) + ( C307 * C306 ) ) ) = ( C306 * ( ( C305 * C308 ) + ( 0. R5 ) ) ) by L1014 , L1012 , VECTSP_1:7
.= ( C306 * ( C305 * C308 ) ) by RLVECT_1:4
.= ( ( add1 (C305 , C306 , C307 , C308 , C304) ) * ( C306 * C308 ) ) by L1013 , GROUP_1:def 3;
thus L1016: thesis by L1015;
end;
case L1017: ( gcd (C306 , C308 , C304) ) = ( 1. R5 );
L1018: ( add2 (C305 , C306 , C307 , C308 , C304) ) = ( C306 * C308 ) by L1017 , L998 , L1002 , L1004 , L1000 , L883;
thus L1019: thesis by L1018 , L998 , L1002 , L1004 , L1000 , L1017 , L842;
end;
case L1020: ( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) = ( 0. R5 );
L1021: ( ( C305 * C308 ) + ( C307 * C306 ) ) = ( 0. R5 )
proof
L1022: ( gcd (C306 , C308 , C304) ) divides C306 by L542;
L1023: ( gcd (C306 , C308 , C304) ) divides ( C307 * C306 ) by L1022 , L81;
L1024: ( gcd (C306 , C308 , C304) ) divides C308 by L542;
consider C309 being (Element of R5) such that L1025: ( ( gcd (C306 , C308 , C304) ) * C309 ) = C308 by L1024 , L28;
L1026: ( gcd (C306 , C308 , C304) ) <> ( 0. R5 ) by L1005 , L600;
consider C310 being (Element of R5) such that L1027: ( ( gcd (C306 , C308 , C304) ) * C310 ) = C306 by L1022 , L28;
L1028: ( ( gcd (C306 , C308 , C304) ) * ( ( C310 * C307 ) + ( C309 * C305 ) ) ) = ( ( ( gcd (C306 , C308 , C304) ) * ( C310 * C307 ) ) + ( ( gcd (C306 , C308 , C304) ) * ( C309 * C305 ) ) ) by VECTSP_1:def 2
.= ( ( ( ( gcd (C306 , C308 , C304) ) * C310 ) * C307 ) + ( ( gcd (C306 , C308 , C304) ) * ( C309 * C305 ) ) ) by GROUP_1:def 3
.= ( ( C305 * C308 ) + ( C307 * C306 ) ) by L1027 , L1025 , GROUP_1:def 3;
L1029: ( gcd (C306 , C308 , C304) ) divides ( ( C305 * C308 ) + ( C307 * C306 ) ) by L1028 , L28;
L1030: ( gcd (C306 , C308 , C304) ) divides ( C305 * C308 ) by L1024 , L81;
L1031: ( 0. R5 ) = ( ( ( C305 * C308 ) / ( gcd (C306 , C308 , C304) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) by L1030 , L1020 , L1026 , L1024 , L105
.= ( ( ( C305 * C308 ) / ( gcd (C306 , C308 , C304) ) ) + ( ( C307 * C306 ) / ( gcd (C306 , C308 , C304) ) ) ) by L1026 , L1022 , L1023 , L105;
L1032: ( 0. R5 ) = ( ( ( C305 * C308 ) + ( C307 * C306 ) ) / ( gcd (C306 , C308 , C304) ) ) by L1031 , L1026 , L1030 , L1023 , L1029 , L118;
L1033: ( 0. R5 ) = ( ( 0. R5 ) * ( gcd (C306 , C308 , C304) ) ) by VECTSP_1:7
.= ( ( C305 * C308 ) + ( C307 * C306 ) ) by L1026 , L1029 , L1032 , L42;
thus L1034: thesis by L1033;
end;
L1035: ( add1 (C305 , C306 , C307 , C308 , C304) ) = ( 0. R5 ) by L998 , L1002 , L1004 , L1000 , L1020 , L842;
L1036: ( ( add1 (C305 , C306 , C307 , C308 , C304) ) * ( C306 * C308 ) ) = ( 0. R5 ) by L1035 , VECTSP_1:7
.= ( ( add2 (C305 , C306 , C307 , C308 , C304) ) * ( ( C305 * C308 ) + ( C307 * C306 ) ) ) by L1021 , VECTSP_1:7;
thus L1037: thesis by L1036;
end;
case L1038: (C305 <> ( 0. R5 ) & C307 <> ( 0. R5 ) & ( gcd (C306 , C308 , C304) ) <> ( 1. R5 ) & ( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) <> ( 0. R5 ));
L1039: ( gcd (C306 , C308 , C304) ) divides C308 by L542;
L1040: ( gcd (C306 , C308 , C304) ) divides ( C305 * C308 ) by L1039 , L81;
L1041: ( gcd (C306 , C308 , C304) ) divides ( ( C305 * C308 ) * C306 ) by L1040 , L81;
L1042: ( gcd (C306 , C308 , C304) ) divides ( ( ( C305 * C308 ) * C306 ) * C308 ) by L1041 , L81;
L1043: ( add1 (C305 , C306 , C307 , C308 , C304) ) = ( ( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) / ( gcd (( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) , ( gcd (C306 , C308 , C304) ) , C304) ) ) by L998 , L1002 , L1004 , L1000 , L1038 , L842;
L1044: ( gcd (C306 , C308 , C304) ) divides C306 by L542;
L1045: ( gcd (C306 , C308 , C304) ) divides ( C307 * C306 ) by L1044 , L81;
L1046: ( gcd (( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) , ( gcd (C306 , C308 , C304) ) , C304) ) divides ( gcd (C306 , C308 , C304) ) by L542;
L1047: ( gcd (( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) , ( gcd (C306 , C308 , C304) ) , C304) ) divides C306 by L1046 , L1044 , L46;
L1048: ( gcd (( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) , ( gcd (C306 , C308 , C304) ) , C304) ) divides ( C306 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) by L1047 , L81;
L1049: ( gcd (( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) , ( gcd (C306 , C308 , C304) ) , C304) ) divides ( ( C306 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) * ( ( C305 * C308 ) + ( C307 * C306 ) ) ) by L1048 , L81;
L1050: ( gcd (C306 , C308 , C304) ) divides ( ( C307 * C306 ) * C306 ) by L1044 , L81;
L1051: ( gcd (C306 , C308 , C304) ) divides ( ( ( C307 * C306 ) * C306 ) * C308 ) by L1050 , L81;
L1052: ( gcd (C306 , C308 , C304) ) divides ( C306 * C308 ) by L1044 , L81;
L1053: ( gcd (C306 , C308 , C304) ) divides ( ( C306 * C308 ) * C305 ) by L1052 , L81;
L1054: ( gcd (C306 , C308 , C304) ) divides ( ( ( C306 * C308 ) * C305 ) * C308 ) by L1053 , L81;
L1055: ( gcd (C306 , C308 , C304) ) divides ( ( C306 * C308 ) * C307 ) by L1052 , L81;
L1056: ( gcd (C306 , C308 , C304) ) divides ( ( ( C306 * C308 ) * C307 ) * C306 ) by L1055 , L81;
L1057: ( add2 (C305 , C306 , C307 , C308 , C304) ) = ( ( C306 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) / ( gcd (( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) , ( gcd (C306 , C308 , C304) ) , C304) ) ) by L998 , L1002 , L1004 , L1000 , L1038 , L883;
L1058: ( gcd (C306 , C308 , C304) ) <> ( 0. R5 ) by L1005 , L600;
L1059: ( gcd (( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) , ( gcd (C306 , C308 , C304) ) , C304) ) <> ( 0. R5 ) by L1058 , L600;
L1060: ( ( C306 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) * ( ( C305 * C308 ) + ( C307 * C306 ) ) ) = ( ( ( C306 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) * ( C305 * C308 ) ) + ( ( C306 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) * ( C307 * C306 ) ) ) by VECTSP_1:def 2
.= ( ( ( ( C306 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) * C305 ) * C308 ) + ( ( C306 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) * ( C307 * C306 ) ) ) by GROUP_1:def 3
.= ( ( ( ( C306 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) * C305 ) * C308 ) + ( ( ( C306 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) * C307 ) * C306 ) ) by GROUP_1:def 3
.= ( ( ( ( ( C306 * C308 ) / ( gcd (C306 , C308 , C304) ) ) * C305 ) * C308 ) + ( ( ( C306 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) * C307 ) * C306 ) ) by L1058 , L1039 , L1052 , L105
.= ( ( ( ( ( C306 * C308 ) / ( gcd (C306 , C308 , C304) ) ) * C305 ) * C308 ) + ( ( ( ( C306 * C308 ) / ( gcd (C306 , C308 , C304) ) ) * C307 ) * C306 ) ) by L1058 , L1039 , L1052 , L105
.= ( ( ( ( ( C306 * C308 ) * C305 ) / ( gcd (C306 , C308 , C304) ) ) * C308 ) + ( ( ( ( C306 * C308 ) / ( gcd (C306 , C308 , C304) ) ) * C307 ) * C306 ) ) by L1058 , L1052 , L1053 , L105
.= ( ( ( ( ( C306 * C308 ) * C305 ) / ( gcd (C306 , C308 , C304) ) ) * C308 ) + ( ( ( ( C306 * C308 ) * C307 ) / ( gcd (C306 , C308 , C304) ) ) * C306 ) ) by L1058 , L1052 , L1055 , L105
.= ( ( ( ( ( C306 * C308 ) * C305 ) * C308 ) / ( gcd (C306 , C308 , C304) ) ) + ( ( ( ( C306 * C308 ) * C307 ) / ( gcd (C306 , C308 , C304) ) ) * C306 ) ) by L1058 , L1053 , L1054 , L105
.= ( ( ( ( C305 * ( C308 * C306 ) ) * C308 ) / ( gcd (C306 , C308 , C304) ) ) + ( ( ( ( C306 * C308 ) * C307 ) * C306 ) / ( gcd (C306 , C308 , C304) ) ) ) by L1058 , L1055 , L1056 , L105
.= ( ( ( ( ( C305 * C308 ) * C306 ) * C308 ) / ( gcd (C306 , C308 , C304) ) ) + ( ( ( ( C306 * C308 ) * C307 ) * C306 ) / ( gcd (C306 , C308 , C304) ) ) ) by GROUP_1:def 3
.= ( ( ( ( ( C305 * C308 ) * C306 ) * C308 ) / ( gcd (C306 , C308 , C304) ) ) + ( ( C307 * ( ( C306 * C308 ) * C306 ) ) / ( gcd (C306 , C308 , C304) ) ) ) by GROUP_1:def 3
.= ( ( ( ( ( C305 * C308 ) * C306 ) * C308 ) / ( gcd (C306 , C308 , C304) ) ) + ( ( C307 * ( ( C306 * C306 ) * C308 ) ) / ( gcd (C306 , C308 , C304) ) ) ) by GROUP_1:def 3
.= ( ( ( ( ( C305 * C308 ) * C306 ) * C308 ) / ( gcd (C306 , C308 , C304) ) ) + ( ( ( C307 * ( C306 * C306 ) ) * C308 ) / ( gcd (C306 , C308 , C304) ) ) ) by GROUP_1:def 3
.= ( ( ( ( ( C305 * C308 ) * C306 ) * C308 ) / ( gcd (C306 , C308 , C304) ) ) + ( ( ( ( C307 * C306 ) * C306 ) * C308 ) / ( gcd (C306 , C308 , C304) ) ) ) by GROUP_1:def 3;
L1061: ( ( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) * ( C306 * C308 ) ) = ( ( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) * ( C306 * C308 ) ) + ( ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) * ( C306 * C308 ) ) ) by VECTSP_1:def 7
.= ( ( ( ( C305 * C308 ) / ( gcd (C306 , C308 , C304) ) ) * ( C306 * C308 ) ) + ( ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) * ( C306 * C308 ) ) ) by L1058 , L1039 , L1040 , L105
.= ( ( ( ( C305 * C308 ) / ( gcd (C306 , C308 , C304) ) ) * ( C306 * C308 ) ) + ( ( ( C307 * C306 ) / ( gcd (C306 , C308 , C304) ) ) * ( C306 * C308 ) ) ) by L1058 , L1044 , L1045 , L105
.= ( ( ( ( ( C305 * C308 ) / ( gcd (C306 , C308 , C304) ) ) * C306 ) * C308 ) + ( ( ( C307 * C306 ) / ( gcd (C306 , C308 , C304) ) ) * ( C306 * C308 ) ) ) by GROUP_1:def 3
.= ( ( ( ( ( C305 * C308 ) / ( gcd (C306 , C308 , C304) ) ) * C306 ) * C308 ) + ( ( ( ( C307 * C306 ) / ( gcd (C306 , C308 , C304) ) ) * C306 ) * C308 ) ) by GROUP_1:def 3
.= ( ( ( ( ( C305 * C308 ) * C306 ) / ( gcd (C306 , C308 , C304) ) ) * C308 ) + ( ( ( ( C307 * C306 ) / ( gcd (C306 , C308 , C304) ) ) * C306 ) * C308 ) ) by L1058 , L1040 , L1041 , L105
.= ( ( ( ( ( C305 * C308 ) * C306 ) / ( gcd (C306 , C308 , C304) ) ) * C308 ) + ( ( ( ( C307 * C306 ) * C306 ) / ( gcd (C306 , C308 , C304) ) ) * C308 ) ) by L1058 , L1045 , L1050 , L105
.= ( ( ( ( ( C305 * C308 ) * C306 ) * C308 ) / ( gcd (C306 , C308 , C304) ) ) + ( ( ( ( C307 * C306 ) * C306 ) / ( gcd (C306 , C308 , C304) ) ) * C308 ) ) by L1058 , L1041 , L1042 , L105
.= ( ( ( ( ( C305 * C308 ) * C306 ) * C308 ) / ( gcd (C306 , C308 , C304) ) ) + ( ( ( ( C307 * C306 ) * C306 ) * C308 ) / ( gcd (C306 , C308 , C304) ) ) ) by L1058 , L1050 , L1051 , L105;
L1062: ( gcd (( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) , ( gcd (C306 , C308 , C304) ) , C304) ) divides ( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) by L542;
L1063: ( gcd (( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) , ( gcd (C306 , C308 , C304) ) , C304) ) divides ( ( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) * ( C306 * C308 ) ) by L1062 , L81;
L1064: ( ( add1 (C305 , C306 , C307 , C308 , C304) ) * ( C306 * C308 ) ) = ( ( ( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) * ( C306 * C308 ) ) / ( gcd (( ( C305 * ( C308 / ( gcd (C306 , C308 , C304) ) ) ) + ( C307 * ( C306 / ( gcd (C306 , C308 , C304) ) ) ) ) , ( gcd (C306 , C308 , C304) ) , C304) ) ) by L1063 , L1043 , L1059 , L1062 , L105
.= ( ( add2 (C305 , C306 , C307 , C308 , C304) ) * ( ( C305 * C308 ) + ( C307 * C306 ) ) ) by L1057 , L1061 , L1060 , L1059 , L1048 , L1049 , L105;
thus L1065: thesis by L1064;
end;
end;
thus L1067: thesis by L1006;
end;
definition
let C311 being gcdDomain;
let C312 being (AmpleSet of C311);
let C313 , C314 , C315 , C316 being (Element of C311);
func mult1 (C313 , C314 , C315 , C316 , C312) -> (Element of C311) equals 
:L1068: ( 0. C311 ) if (C313 = ( 0. C311 ) or C315 = ( 0. C311 )) , ( C313 * C315 ) if (C314 = ( 1. C311 ) & C316 = ( 1. C311 )) , ( ( C313 * C315 ) / ( gcd (C313 , C316 , C312) ) ) if (C316 <> ( 0. C311 ) & C314 = ( 1. C311 )) , ( ( C313 * C315 ) / ( gcd (C315 , C314 , C312) ) ) if (C314 <> ( 0. C311 ) & C316 = ( 1. C311 )) otherwise ( ( C313 / ( gcd (C313 , C316 , C312) ) ) * ( C315 / ( gcd (C315 , C314 , C312) ) ) );
coherence;
consistency
proof
L1069: (((C313 = ( 0. C311 ) or C315 = ( 0. C311 )) & C314 <> ( 0. C311 ) & C316 = ( 1. C311 )) implies (for B279 being (Element of C311) holds (B279 = ( 0. C311 ) iff B279 = ( ( C313 * C315 ) / ( gcd (C315 , C314 , C312) ) ))))
proof
set D55 = ( ( C313 * C315 ) / ( gcd (C315 , C314 , C312) ) );
assume that
L1070: (C313 = ( 0. C311 ) or C315 = ( 0. C311 ))
and
L1071: C314 <> ( 0. C311 )
and
L1072: C316 = ( 1. C311 );
L1073: ( gcd (C315 , C314 , C312) ) <> ( 0. C311 ) by L1071 , L600;
let C317 being (Element of C311);
L1074: ( C313 * C315 ) = ( 0. C311 )
proof
L1075:
now
per cases  by L1070;
case L1076: C313 = ( 0. C311 );
thus L1077: thesis by L1076 , VECTSP_1:7;
end;
case L1078: C315 = ( 0. C311 );
thus L1079: thesis by L1078 , VECTSP_1:7;
end;
end;
thus L1081: thesis by L1075;
end;
L1082: ( gcd (C315 , C314 , C312) ) divides C315 by L542;
L1083: ( gcd (C315 , C314 , C312) ) divides ( C313 * C315 ) by L1082 , L81;
L1084: ( D55 * ( gcd (C315 , C314 , C312) ) ) = ( 0. C311 ) by L1083 , L1074 , L1073 , L42;
thus L1085: thesis by L1084 , L1073 , VECTSP_2:def 1;
end;
L1086: (((C313 = ( 0. C311 ) or C315 = ( 0. C311 )) & C316 <> ( 0. C311 ) & C314 = ( 1. C311 )) implies (for B280 being (Element of C311) holds (B280 = ( 0. C311 ) iff B280 = ( ( C313 * C315 ) / ( gcd (C313 , C316 , C312) ) ))))
proof
set D56 = ( ( C313 * C315 ) / ( gcd (C313 , C316 , C312) ) );
assume that
L1087: (C313 = ( 0. C311 ) or C315 = ( 0. C311 ))
and
L1088: C316 <> ( 0. C311 )
and
L1089: C314 = ( 1. C311 );
L1090: ( gcd (C313 , C316 , C312) ) <> ( 0. C311 ) by L1088 , L600;
let C318 being (Element of C311);
L1091: ( C313 * C315 ) = ( 0. C311 )
proof
L1092:
now
per cases  by L1087;
case L1093: C313 = ( 0. C311 );
thus L1094: thesis by L1093 , VECTSP_1:7;
end;
case L1095: C315 = ( 0. C311 );
thus L1096: thesis by L1095 , VECTSP_1:7;
end;
end;
thus L1098: thesis by L1092;
end;
L1099: ( gcd (C313 , C316 , C312) ) divides C313 by L542;
L1100: ( gcd (C313 , C316 , C312) ) divides ( C313 * C315 ) by L1099 , L81;
L1101: ( D56 * ( gcd (C313 , C316 , C312) ) ) = ( 0. C311 ) by L1100 , L1091 , L1090 , L42;
thus L1102: thesis by L1101 , L1090 , VECTSP_2:def 1;
end;
L1103: ((C314 = ( 1. C311 ) & C316 = ( 1. C311 ) & C314 <> ( 0. C311 ) & C316 = ( 1. C311 )) implies (for B281 being (Element of C311) holds (B281 = ( C313 * C315 ) iff B281 = ( ( C313 * C315 ) / ( gcd (C315 , C314 , C312) ) ))))
proof
assume that
L1104: C314 = ( 1. C311 )
and
L1105: C316 = ( 1. C311 )
and
L1106: C314 <> ( 0. C311 )
and
L1107: C316 = ( 1. C311 );
L1108: ( gcd (C315 , C314 , C312) ) = ( 1. C311 ) by L1104 , L594;
thus L1109: thesis by L1108 , L100;
end;
L1110: ((C314 = ( 1. C311 ) & C316 = ( 1. C311 ) & C316 <> ( 0. C311 ) & C314 = ( 1. C311 )) implies (for B282 being (Element of C311) holds (B282 = ( C313 * C315 ) iff B282 = ( ( C313 * C315 ) / ( gcd (C313 , C316 , C312) ) ))))
proof
assume that
L1111: C314 = ( 1. C311 )
and
L1112: C316 = ( 1. C311 )
and
L1113: C316 <> ( 0. C311 )
and
L1114: C314 = ( 1. C311 );
L1115: ( gcd (C313 , C316 , C312) ) = ( 1. C311 ) by L1112 , L594;
thus L1116: thesis by L1115 , L100;
end;
thus L1117: thesis by L1110 , L1086 , L1069 , L1103;
end;
end;
definition
let C319 being gcdDomain;
let C320 being (AmpleSet of C319);
let C321 , C322 , C323 , C324 being (Element of C319);
assume that
L1119: C321 , C322 are_co-prime 
and
L1120: C323 , C324 are_co-prime 
and
L1121: C322 = ( NF (C322 , C320) )
and
L1122: C324 = ( NF (C324 , C320) );
func mult2 (C321 , C322 , C323 , C324 , C320) -> (Element of C319) equals 
:L1123: ( 1. C319 ) if (C321 = ( 0. C319 ) or C323 = ( 0. C319 )) , ( 1. C319 ) if (C322 = ( 1. C319 ) & C324 = ( 1. C319 )) , ( C324 / ( gcd (C321 , C324 , C320) ) ) if (C324 <> ( 0. C319 ) & C322 = ( 1. C319 )) , ( C322 / ( gcd (C323 , C322 , C320) ) ) if (C322 <> ( 0. C319 ) & C324 = ( 1. C319 )) otherwise ( ( C322 / ( gcd (C323 , C322 , C320) ) ) * ( C324 / ( gcd (C321 , C324 , C320) ) ) );
coherence;
consistency
proof
L1124: ( gcd (C323 , C324 , C320) ) = ( 1. C319 ) by L1120 , L830;
L1125: (((C321 = ( 0. C319 ) or C323 = ( 0. C319 )) & C324 <> ( 0. C319 ) & C322 = ( 1. C319 )) implies (for B283 being (Element of C319) holds (B283 = ( 1. C319 ) iff B283 = ( C324 / ( gcd (C321 , C324 , C320) ) ))))
proof
assume that
L1126: (C321 = ( 0. C319 ) or C323 = ( 0. C319 ))
and
L1127: C324 <> ( 0. C319 )
and
L1128: C322 = ( 1. C319 );
L1129:
now
per cases  by L1126;
case L1130: C321 = ( 0. C319 );
L1131: ( gcd (C321 , C324 , C320) ) = C324 by L1130 , L1122 , L578;
thus L1132: thesis by L1131 , L1127 , L96;
end;
case L1133: C323 = ( 0. C319 );
L1134: ( 1. C319 ) <> ( 0. C319 );
L1135: ( 1. C319 ) = C324 by L1122 , L1124 , L1133 , L578;
L1136: ( gcd (C321 , C324 , C320) ) = ( 1. C319 ) by L1135 , L594;
thus L1137: thesis by L1136 , L1135 , L1134 , L96;
end;
end;
thus L1139: thesis by L1129;
end;
L1140: ( gcd (C321 , C322 , C320) ) = ( 1. C319 ) by L1119 , L830;
L1141: (((C321 = ( 0. C319 ) or C323 = ( 0. C319 )) & C322 <> ( 0. C319 ) & C324 = ( 1. C319 )) implies (for B284 being (Element of C319) holds (B284 = ( 1. C319 ) iff B284 = ( C322 / ( gcd (C323 , C322 , C320) ) ))))
proof
assume that
L1142: (C321 = ( 0. C319 ) or C323 = ( 0. C319 ))
and
L1143: C322 <> ( 0. C319 )
and
L1144: C324 = ( 1. C319 );
L1145:
now
per cases  by L1142;
case L1146: C323 = ( 0. C319 );
L1147: ( gcd (C323 , C322 , C320) ) = C322 by L1146 , L1121 , L578;
thus L1148: thesis by L1147 , L1143 , L96;
end;
case L1149: C321 = ( 0. C319 );
L1150: ( 1. C319 ) <> ( 0. C319 );
L1151: ( 1. C319 ) = C322 by L1121 , L1140 , L1149 , L578;
L1152: ( gcd (C323 , C322 , C320) ) = ( 1. C319 ) by L1151 , L594;
thus L1153: thesis by L1152 , L1151 , L1150 , L96;
end;
end;
thus L1155: thesis by L1145;
end;
L1156: ((C322 = ( 1. C319 ) & C324 = ( 1. C319 ) & C322 <> ( 0. C319 ) & C324 = ( 1. C319 )) implies (for B285 being (Element of C319) holds (B285 = ( 1. C319 ) iff B285 = ( C322 / ( gcd (C323 , C322 , C320) ) ))))
proof
assume that
L1157: C322 = ( 1. C319 )
and
L1158: C324 = ( 1. C319 )
and
L1159: C322 <> ( 0. C319 )
and
L1160: C324 = ( 1. C319 );
L1161: ( gcd (C323 , C322 , C320) ) = ( 1. C319 ) by L1157 , L594;
thus L1162: thesis by L1161 , L1157 , L1159 , L96;
end;
L1163: ((C322 = ( 1. C319 ) & C324 = ( 1. C319 ) & C324 <> ( 0. C319 ) & C322 = ( 1. C319 )) implies (for B286 being (Element of C319) holds (B286 = ( 1. C319 ) iff B286 = ( C324 / ( gcd (C321 , C324 , C320) ) ))))
proof
assume that
L1164: C322 = ( 1. C319 )
and
L1165: C324 = ( 1. C319 )
and
L1166: C324 <> ( 0. C319 )
and
L1167: C322 = ( 1. C319 );
L1168: ( gcd (C321 , C324 , C320) ) = ( 1. C319 ) by L1165 , L594;
thus L1169: thesis by L1168 , L1165 , L1166 , L96;
end;
thus L1170: thesis by L1163 , L1125 , L1141 , L1156;
end;
end;
theorem
L1172: (for R5 being gcdDomain holds (for B287 being (AmpleSet of R5) holds (for B288 , B289 , B290 , B291 being (Element of R5) holds ((B287 is  multiplicative & B288 , B289 are_normalized_wrt B287 & B290 , B291 are_normalized_wrt B287) implies ( mult1 (B288 , B289 , B290 , B291 , B287) ) , ( mult2 (B288 , B289 , B290 , B291 , B287) ) are_normalized_wrt B287))))
proof
let R5 being gcdDomain;
let C325 being (AmpleSet of R5);
let C326 , C327 , C328 , C329 being (Element of R5);
assume that
L1173: C325 is  multiplicative
and
L1174: C326 , C327 are_normalized_wrt C325
and
L1175: C328 , C329 are_normalized_wrt C325;
L1176: ( gcd (C326 , C327 , C325) ) = ( 1. R5 ) by L1174 , L836;
L1177: C326 , C327 are_co-prime  by L1176 , L824;
L1178: C329 in C325 by L1175 , L836;
L1179: C329 = ( NF (C329 , C325) ) by L1178 , L416;
L1180: C327 in C325 by L1174 , L836;
L1181: C327 = ( NF (C327 , C325) ) by L1180 , L416;
L1182: C327 <> ( 0. R5 ) by L1174 , L836;
L1183: ( gcd (C328 , C327 , C325) ) <> ( 0. R5 ) by L1182 , L600;
L1184: ( gcd (C328 , C329 , C325) ) = ( 1. R5 ) by L1175 , L836;
L1185: C328 , C329 are_co-prime  by L1184 , L824;
L1186: C329 <> ( 0. R5 ) by L1175 , L836;
L1187: ( gcd (C326 , C329 , C325) ) <> ( 0. R5 ) by L1186 , L600;
L1188:
now
per cases ;
case L1189: (C326 = ( 0. R5 ) or C328 = ( 0. R5 ));
L1190: (( 1. R5 ) in C325 & ( 1. R5 ) <> ( 0. R5 )) by L407;
L1191: ( mult2 (C326 , C327 , C328 , C329 , C325) ) = ( 1. R5 ) by L1177 , L1185 , L1181 , L1179 , L1189 , L1123;
L1192: ( gcd (( mult1 (C326 , C327 , C328 , C329 , C325) ) , ( mult2 (C326 , C327 , C328 , C329 , C325) ) , C325) ) = ( 1. R5 ) by L1191 , L594;
thus L1193: thesis by L1192 , L1191 , L1190 , L836;
end;
case L1194: (C327 = ( 1. R5 ) & C329 = ( 1. R5 ));
L1195: (( 1. R5 ) in C325 & ( 1. R5 ) <> ( 0. R5 )) by L407;
L1196: ( mult2 (C326 , C327 , C328 , C329 , C325) ) = ( 1. R5 ) by L1177 , L1185 , L1181 , L1194 , L1123;
L1197: ( gcd (( mult1 (C326 , C327 , C328 , C329 , C325) ) , ( mult2 (C326 , C327 , C328 , C329 , C325) ) , C325) ) = ( 1. R5 ) by L1196 , L594;
thus L1198: thesis by L1197 , L1196 , L1195 , L836;
end;
case L1199: (C329 <> ( 0. R5 ) & C327 = ( 1. R5 ));
L1200: ( gcd (C328 , C327 , C325) ) = ( 1. R5 ) by L1199 , L594;
L1201: ( C327 / ( gcd (C328 , C327 , C325) ) ) = ( 1. R5 ) by L1200 , L1199 , L96;
L1202: ( C329 / ( gcd (C326 , C329 , C325) ) ) = ( ( C329 / ( gcd (C326 , C329 , C325) ) ) * ( C327 / ( gcd (C328 , C327 , C325) ) ) ) by L1201 , VECTSP_1:def 4;
L1203: ( gcd (C326 , C329 , C325) ) divides C326 by L542;
L1204: ( gcd (C326 , C329 , C325) ) divides ( C326 * C328 ) by L1203 , L81;
L1205: ( ( C326 * C328 ) / ( gcd (C326 , C329 , C325) ) ) = ( ( C326 / ( gcd (C326 , C329 , C325) ) ) * C328 ) by L1204 , L1187 , L1203 , L105
.= ( ( C326 / ( gcd (C326 , C329 , C325) ) ) * ( C328 / ( gcd (C328 , C327 , C325) ) ) ) by L1200 , L100;
L1206: ( mult2 (C326 , C327 , C328 , C329 , C325) ) = ( C329 / ( gcd (C326 , C329 , C325) ) ) by L1177 , L1185 , L1181 , L1179 , L1199 , L1123;
reconsider D57 = ( gcd (C326 , C329 , C325) ) as (Element of C325) by L542;
L1207: (( gcd (C326 , C329 , C325) ) divides C329 & ( gcd (C326 , C329 , C325) ) <> ( 0. R5 )) by L1186 , L542 , L600;
L1208: ( C329 / ( gcd (C326 , C329 , C325) ) ) <> ( 0. R5 ) by L1207 , L1186 , L86;
L1209: ( mult1 (C326 , C327 , C328 , C329 , C325) ) = ( ( C326 * C328 ) / ( gcd (C326 , C329 , C325) ) ) by L1199 , L1068;
L1210: ( gcd (( mult1 (C326 , C327 , C328 , C329 , C325) ) , ( mult2 (C326 , C327 , C328 , C329 , C325) ) , C325) ) = ( 1. R5 ) by L1209 , L1176 , L1184 , L1182 , L1186 , L1206 , L1205 , L1202 , L766;
reconsider D58 = C329 as (Element of C325) by L1175 , L836;
L1211: ( D58 / D57 ) in C325 by L1173 , L1207 , L428;
thus L1212: thesis by L1211 , L1206 , L1210 , L1208 , L836;
end;
case L1213: (C327 <> ( 0. R5 ) & C329 = ( 1. R5 ));
L1214: ( gcd (C326 , C329 , C325) ) = ( 1. R5 ) by L1213 , L594;
L1215: ( C329 / ( gcd (C326 , C329 , C325) ) ) = ( 1. R5 ) by L1214 , L1213 , L96;
L1216: ( C327 / ( gcd (C328 , C327 , C325) ) ) = ( ( C327 / ( gcd (C328 , C327 , C325) ) ) * ( C329 / ( gcd (C326 , C329 , C325) ) ) ) by L1215 , VECTSP_1:def 4;
L1217: ( gcd (C328 , C327 , C325) ) divides C328 by L542;
L1218: ( gcd (C328 , C327 , C325) ) divides ( C326 * C328 ) by L1217 , L81;
L1219: ( ( C326 * C328 ) / ( gcd (C328 , C327 , C325) ) ) = ( C326 * ( C328 / ( gcd (C328 , C327 , C325) ) ) ) by L1218 , L1183 , L1217 , L105
.= ( ( C326 / ( gcd (C326 , C329 , C325) ) ) * ( C328 / ( gcd (C328 , C327 , C325) ) ) ) by L1214 , L100;
L1220: ( mult2 (C326 , C327 , C328 , C329 , C325) ) = ( C327 / ( gcd (C328 , C327 , C325) ) ) by L1177 , L1185 , L1181 , L1179 , L1213 , L1123;
reconsider D59 = ( gcd (C328 , C327 , C325) ) as (Element of C325) by L542;
L1221: (( gcd (C328 , C327 , C325) ) divides C327 & ( gcd (C328 , C327 , C325) ) <> ( 0. R5 )) by L1182 , L542 , L600;
L1222: ( C327 / ( gcd (C328 , C327 , C325) ) ) <> ( 0. R5 ) by L1221 , L1182 , L86;
L1223: ( mult1 (C326 , C327 , C328 , C329 , C325) ) = ( ( C326 * C328 ) / ( gcd (C328 , C327 , C325) ) ) by L1213 , L1068;
L1224: ( gcd (( mult1 (C326 , C327 , C328 , C329 , C325) ) , ( mult2 (C326 , C327 , C328 , C329 , C325) ) , C325) ) = ( 1. R5 ) by L1223 , L1176 , L1184 , L1182 , L1186 , L1220 , L1219 , L1216 , L766;
reconsider D60 = C327 as (Element of C325) by L1174 , L836;
L1225: ( D60 / D59 ) in C325 by L1173 , L1221 , L428;
thus L1226: thesis by L1225 , L1220 , L1224 , L1222 , L836;
end;
case L1227: ((not (C326 = ( 0. R5 ) or C328 = ( 0. R5 ))) & (not (C327 = ( 1. R5 ) & C329 = ( 1. R5 ))) & (not (C329 <> ( 0. R5 ) & C327 = ( 1. R5 ))) & (not (C327 <> ( 0. R5 ) & C329 = ( 1. R5 ))));
reconsider D61 = ( gcd (C328 , C327 , C325) ) as (Element of C325) by L542;
reconsider D62 = ( gcd (C326 , C329 , C325) ) as (Element of C325) by L542;
L1228: (( gcd (C326 , C329 , C325) ) divides C329 & ( gcd (C326 , C329 , C325) ) <> ( 0. R5 )) by L1186 , L542 , L600;
L1229: ( C329 / ( gcd (C326 , C329 , C325) ) ) <> ( 0. R5 ) by L1228 , L1186 , L86;
L1230: ( mult2 (C326 , C327 , C328 , C329 , C325) ) = ( ( C327 / ( gcd (C328 , C327 , C325) ) ) * ( C329 / ( gcd (C326 , C329 , C325) ) ) ) by L1177 , L1185 , L1181 , L1179 , L1227 , L1123;
L1231: ( mult1 (C326 , C327 , C328 , C329 , C325) ) = ( ( C326 / ( gcd (C326 , C329 , C325) ) ) * ( C328 / ( gcd (C328 , C327 , C325) ) ) ) by L1227 , L1068;
L1232: ( gcd (( mult1 (C326 , C327 , C328 , C329 , C325) ) , ( mult2 (C326 , C327 , C328 , C329 , C325) ) , C325) ) = ( 1. R5 ) by L1231 , L1176 , L1184 , L1182 , L1186 , L1230 , L766;
L1233: (( gcd (C328 , C327 , C325) ) divides C327 & ( gcd (C328 , C327 , C325) ) <> ( 0. R5 )) by L1182 , L542 , L600;
L1234: ( C327 / ( gcd (C328 , C327 , C325) ) ) <> ( 0. R5 ) by L1233 , L1182 , L86;
reconsider D63 = C329 as (Element of C325) by L1175 , L836;
reconsider D64 = ( D63 / D62 ) as (Element of C325) by L1173 , L1228 , L428;
reconsider D65 = C327 as (Element of C325) by L1174 , L836;
reconsider D66 = ( D65 / D61 ) as (Element of C325) by L1173 , L1233 , L428;
L1235: ( D66 * D64 ) <> ( 0. R5 ) by L1229 , L1234 , VECTSP_2:def 1;
L1236: ( D66 * D64 ) in C325 by L1173 , L426;
thus L1237: thesis by L1236 , L1230 , L1232 , L1235 , L836;
end;
end;
thus L1239: thesis by L1188;
end;
theorem
L1240: (for R5 being gcdDomain holds (for B292 being (AmpleSet of R5) holds (for B293 , B294 , B295 , B296 being (Element of R5) holds ((B293 , B294 are_normalized_wrt B292 & B295 , B296 are_normalized_wrt B292) implies ( ( mult1 (B293 , B294 , B295 , B296 , B292) ) * ( B294 * B296 ) ) = ( ( mult2 (B293 , B294 , B295 , B296 , B292) ) * ( B293 * B295 ) )))))
proof
let R5 being gcdDomain;
let C330 being (AmpleSet of R5);
let C331 , C332 , C333 , C334 being (Element of R5);
assume that
L1241: C331 , C332 are_normalized_wrt C330
and
L1242: C333 , C334 are_normalized_wrt C330;
L1243: ( gcd (C331 , C332 , C330) ) = ( 1. R5 ) by L1241 , L836;
L1244: C331 , C332 are_co-prime  by L1243 , L824;
L1245: C334 <> ( 0. R5 ) by L1242 , L836;
L1246: ( gcd (C331 , C334 , C330) ) <> ( 0. R5 ) by L1245 , L600;
L1247: C332 in C330 by L1241 , L836;
L1248: C332 = ( NF (C332 , C330) ) by L1247 , L416;
L1249: ( gcd (C333 , C334 , C330) ) = ( 1. R5 ) by L1242 , L836;
L1250: C333 , C334 are_co-prime  by L1249 , L824;
L1251: C332 <> ( 0. R5 ) by L1241 , L836;
L1252: ( gcd (C333 , C332 , C330) ) <> ( 0. R5 ) by L1251 , L600;
L1253: C334 in C330 by L1242 , L836;
L1254: C334 = ( NF (C334 , C330) ) by L1253 , L416;
L1255:
now
per cases ;
case L1256: (C331 = ( 0. R5 ) or C333 = ( 0. R5 ));
L1257: ( mult1 (C331 , C332 , C333 , C334 , C330) ) = ( 0. R5 ) by L1256 , L1068;
L1258:
now
per cases  by L1256;
case L1259: C331 = ( 0. R5 );
L1260: ( ( mult2 (C331 , C332 , C333 , C334 , C330) ) * ( C331 * C333 ) ) = ( ( mult2 (C331 , C332 , C333 , C334 , C330) ) * ( 0. R5 ) ) by L1259 , VECTSP_1:7
.= ( 0. R5 ) by VECTSP_1:7;
thus L1261: thesis by L1260 , L1257 , VECTSP_1:7;
end;
case L1262: C333 = ( 0. R5 );
L1263: ( ( mult2 (C331 , C332 , C333 , C334 , C330) ) * ( C331 * C333 ) ) = ( ( mult2 (C331 , C332 , C333 , C334 , C330) ) * ( 0. R5 ) ) by L1262 , VECTSP_1:7
.= ( 0. R5 ) by VECTSP_1:7;
thus L1264: thesis by L1263 , L1257 , VECTSP_1:7;
end;
end;
thus L1266: thesis by L1258;
end;
case L1267: (C332 = ( 1. R5 ) & C334 = ( 1. R5 ));
L1268: (( mult1 (C331 , C332 , C333 , C334 , C330) ) = ( C331 * C333 ) & ( mult2 (C331 , C332 , C333 , C334 , C330) ) = ( 1. R5 )) by L1267 , L1244 , L1250 , L1248 , L1068 , L1123;
thus L1269: thesis by L1268 , L1267 , VECTSP_1:def 4;
end;
case L1270: (C334 <> ( 0. R5 ) & C332 = ( 1. R5 ));
L1271: ( gcd (C331 , C334 , C330) ) divides C331 by L542;
L1272: ( gcd (C331 , C334 , C330) ) divides ( C331 * C333 ) by L1271 , L81;
L1273: ( gcd (C331 , C334 , C330) ) divides ( ( C331 * C333 ) * C334 ) by L1272 , L81;
L1274: ( ( ( C331 * C333 ) / ( gcd (C331 , C334 , C330) ) ) * ( C332 * C334 ) ) = ( ( ( C331 * C333 ) / ( gcd (C331 , C334 , C330) ) ) * C334 ) by L1270 , VECTSP_1:def 8
.= ( ( ( C331 * C333 ) * C334 ) / ( gcd (C331 , C334 , C330) ) ) by L1246 , L1272 , L1273 , L105;
L1275: ( mult2 (C331 , C332 , C333 , C334 , C330) ) = ( C334 / ( gcd (C331 , C334 , C330) ) ) by L1244 , L1250 , L1248 , L1254 , L1270 , L1123;
L1276: ( gcd (C331 , C334 , C330) ) divides C334 by L542;
L1277: ( gcd (C331 , C334 , C330) ) divides ( C334 * C331 ) by L1276 , L81;
L1278: ( gcd (C331 , C334 , C330) ) divides ( ( C334 * C331 ) * C333 ) by L1277 , L81;
L1279: ( ( C334 / ( gcd (C331 , C334 , C330) ) ) * ( C331 * C333 ) ) = ( ( ( C334 / ( gcd (C331 , C334 , C330) ) ) * C331 ) * C333 ) by GROUP_1:def 3
.= ( ( ( C334 * C331 ) / ( gcd (C331 , C334 , C330) ) ) * C333 ) by L1246 , L1276 , L1277 , L105
.= ( ( ( C334 * C331 ) * C333 ) / ( gcd (C331 , C334 , C330) ) ) by L1246 , L1277 , L1278 , L105
.= ( ( ( C331 * C333 ) * C334 ) / ( gcd (C331 , C334 , C330) ) ) by GROUP_1:def 3;
thus L1280: thesis by L1279 , L1270 , L1275 , L1274 , L1068;
end;
case L1281: (C332 <> ( 0. R5 ) & C334 = ( 1. R5 ));
L1282: ( gcd (C333 , C332 , C330) ) divides C333 by L542;
L1283: ( gcd (C333 , C332 , C330) ) divides ( C333 * C331 ) by L1282 , L81;
L1284: ( gcd (C333 , C332 , C330) ) divides ( ( C333 * C331 ) * C332 ) by L1283 , L81;
L1285: ( ( ( C331 * C333 ) / ( gcd (C333 , C332 , C330) ) ) * ( C332 * C334 ) ) = ( ( ( C331 * C333 ) / ( gcd (C333 , C332 , C330) ) ) * C332 ) by L1281 , VECTSP_1:def 4
.= ( ( ( C331 * C333 ) * C332 ) / ( gcd (C333 , C332 , C330) ) ) by L1252 , L1283 , L1284 , L105;
L1286: ( mult2 (C331 , C332 , C333 , C334 , C330) ) = ( C332 / ( gcd (C333 , C332 , C330) ) ) by L1244 , L1250 , L1248 , L1254 , L1281 , L1123;
L1287: ( gcd (C333 , C332 , C330) ) divides C332 by L542;
L1288: ( gcd (C333 , C332 , C330) ) divides ( C332 * C331 ) by L1287 , L81;
L1289: ( gcd (C333 , C332 , C330) ) divides ( ( C332 * C331 ) * C333 ) by L1288 , L81;
L1290: ( ( C332 / ( gcd (C333 , C332 , C330) ) ) * ( C331 * C333 ) ) = ( ( ( C332 / ( gcd (C333 , C332 , C330) ) ) * C331 ) * C333 ) by GROUP_1:def 3
.= ( ( ( C332 * C331 ) / ( gcd (C333 , C332 , C330) ) ) * C333 ) by L1252 , L1287 , L1288 , L105
.= ( ( ( C332 * C331 ) * C333 ) / ( gcd (C333 , C332 , C330) ) ) by L1252 , L1288 , L1289 , L105
.= ( ( ( C331 * C333 ) * C332 ) / ( gcd (C333 , C332 , C330) ) ) by GROUP_1:def 3;
thus L1291: thesis by L1290 , L1281 , L1286 , L1285 , L1068;
end;
case L1292: ((not (C331 = ( 0. R5 ) or C333 = ( 0. R5 ))) & (not (C332 = ( 1. R5 ) & C334 = ( 1. R5 ))) & (not (C334 <> ( 0. R5 ) & C332 = ( 1. R5 ))) & (not (C332 <> ( 0. R5 ) & C334 = ( 1. R5 ))));
L1293: (( gcd (C333 , C332 , C330) ) divides C332 & ( gcd (C331 , C334 , C330) ) divides C334) by L542;
L1294: ( ( gcd (C333 , C332 , C330) ) * ( gcd (C331 , C334 , C330) ) ) divides ( C332 * C334 ) by L1293 , L55;
L1295: ( ( gcd (C333 , C332 , C330) ) * ( gcd (C331 , C334 , C330) ) ) divides ( ( C332 * C334 ) * C331 ) by L1294 , L81;
L1296: ( ( gcd (C333 , C332 , C330) ) * ( gcd (C331 , C334 , C330) ) ) divides ( ( ( C332 * C334 ) * C331 ) * C333 ) by L1295 , L81;
L1297: (( gcd (C331 , C334 , C330) ) divides C331 & ( gcd (C333 , C332 , C330) ) divides C333) by L542;
L1298: ( ( gcd (C331 , C334 , C330) ) * ( gcd (C333 , C332 , C330) ) ) divides ( C331 * C333 ) by L1297 , L55;
L1299: ( ( gcd (C331 , C334 , C330) ) * ( gcd (C333 , C332 , C330) ) ) divides ( ( C331 * C333 ) * C332 ) by L1298 , L81;
L1300: ( ( gcd (C331 , C334 , C330) ) * ( gcd (C333 , C332 , C330) ) ) divides ( ( ( C331 * C333 ) * C332 ) * C334 ) by L1299 , L81;
L1301: ( mult2 (C331 , C332 , C333 , C334 , C330) ) = ( ( C332 / ( gcd (C333 , C332 , C330) ) ) * ( C334 / ( gcd (C331 , C334 , C330) ) ) ) by L1244 , L1250 , L1248 , L1254 , L1292 , L1123;
L1302: ( ( gcd (C331 , C334 , C330) ) * ( gcd (C333 , C332 , C330) ) ) <> ( 0. R5 ) by L1246 , L1252 , VECTSP_2:def 1;
L1303: ( ( ( C332 / ( gcd (C333 , C332 , C330) ) ) * ( C334 / ( gcd (C331 , C334 , C330) ) ) ) * ( C331 * C333 ) ) = ( ( ( C332 * C334 ) / ( ( gcd (C333 , C332 , C330) ) * ( gcd (C331 , C334 , C330) ) ) ) * ( C331 * C333 ) ) by L1246 , L1252 , L1293 , L136
.= ( ( ( ( C332 * C334 ) / ( ( gcd (C333 , C332 , C330) ) * ( gcd (C331 , C334 , C330) ) ) ) * C331 ) * C333 ) by GROUP_1:def 3
.= ( ( ( ( C332 * C334 ) * C331 ) / ( ( gcd (C333 , C332 , C330) ) * ( gcd (C331 , C334 , C330) ) ) ) * C333 ) by L1302 , L1294 , L1295 , L105
.= ( ( ( ( C332 * C334 ) * C331 ) * C333 ) / ( ( gcd (C333 , C332 , C330) ) * ( gcd (C331 , C334 , C330) ) ) ) by L1302 , L1295 , L1296 , L105
.= ( ( C331 * ( ( C332 * C334 ) * C333 ) ) / ( ( gcd (C333 , C332 , C330) ) * ( gcd (C331 , C334 , C330) ) ) ) by GROUP_1:def 3
.= ( ( C331 * ( ( C333 * C332 ) * C334 ) ) / ( ( gcd (C333 , C332 , C330) ) * ( gcd (C331 , C334 , C330) ) ) ) by GROUP_1:def 3
.= ( ( ( C331 * ( C333 * C332 ) ) * C334 ) / ( ( gcd (C333 , C332 , C330) ) * ( gcd (C331 , C334 , C330) ) ) ) by GROUP_1:def 3
.= ( ( ( ( C331 * C333 ) * C332 ) * C334 ) / ( ( gcd (C333 , C332 , C330) ) * ( gcd (C331 , C334 , C330) ) ) ) by GROUP_1:def 3;
L1304: ( ( ( C331 / ( gcd (C331 , C334 , C330) ) ) * ( C333 / ( gcd (C333 , C332 , C330) ) ) ) * ( C332 * C334 ) ) = ( ( ( C331 * C333 ) / ( ( gcd (C331 , C334 , C330) ) * ( gcd (C333 , C332 , C330) ) ) ) * ( C332 * C334 ) ) by L1246 , L1252 , L1297 , L136
.= ( ( ( ( C331 * C333 ) / ( ( gcd (C331 , C334 , C330) ) * ( gcd (C333 , C332 , C330) ) ) ) * C332 ) * C334 ) by GROUP_1:def 3
.= ( ( ( ( C331 * C333 ) * C332 ) / ( ( gcd (C331 , C334 , C330) ) * ( gcd (C333 , C332 , C330) ) ) ) * C334 ) by L1298 , L1299 , L1302 , L105
.= ( ( ( ( C331 * C333 ) * C332 ) * C334 ) / ( ( gcd (C331 , C334 , C330) ) * ( gcd (C333 , C332 , C330) ) ) ) by L1299 , L1300 , L1302 , L105;
thus L1305: thesis by L1304 , L1292 , L1301 , L1303 , L1068;
end;
end;
thus L1307: thesis by L1255;
end;
theorem
L1308: (for B297 being  add-associative  right_zeroed  right_complementable  Abelian  distributive non  empty doubleLoopStr holds (for B298 , B299 being (Element of B297) holds (( ( - B298 ) * B299 ) = ( - ( B298 * B299 ) ) & ( B298 * ( - B299 ) ) = ( - ( B298 * B299 ) )))) by VECTSP_1:8 , VECTSP_1:9;
theorem
L1309: (for B300 being  almost_left_invertible  commutative Ring holds (for B301 , B302 being (Element of B300) holds ((B301 <> ( 0. B300 ) & B302 <> ( 0. B300 )) implies ( ( B301 " ) * ( B302 " ) ) = ( ( B302 * B301 ) " ))))
proof
let C335 being  almost_left_invertible  commutative Ring;
let C336 , C337 being (Element of C335);
assume that
L1310: C336 <> ( 0. C335 )
and
L1311: C337 <> ( 0. C335 );
L1312: ( ( C337 * C336 ) * ( ( C336 " ) * ( C337 " ) ) ) = ( ( ( C337 * C336 ) * ( C336 " ) ) * ( C337 " ) ) by GROUP_1:def 3
.= ( ( C337 * ( C336 * ( C336 " ) ) ) * ( C337 " ) ) by GROUP_1:def 3
.= ( ( C337 * ( 1_ C335 ) ) * ( C337 " ) ) by L1310 , VECTSP_1:def 10
.= ( C337 * ( C337 " ) ) by VECTSP_1:def 4
.= ( 1_ C335 ) by L1311 , VECTSP_1:def 10;
L1313: ( C337 * C336 ) <> ( 0. C335 ) by L1310 , L1311 , VECTSP_1:12;
thus L1314: thesis by L1313 , L1312 , VECTSP_1:def 10;
end;
