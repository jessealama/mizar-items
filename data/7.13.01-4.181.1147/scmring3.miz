:: The Properties of Instructions of { \bf SCM } over Ring
::  by Artur Korni{\l}owicz
::
:: Received April 14, 2000
:: Copyright (c) 2000-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FUNCSDOM, SUBSET_1, AMI_3, AMI_1, FSM_1, ORDINAL1,
      STRUCT_0, AMI_2, TARSKI, ZFMISC_1, RELAT_1, FUNCOP_1, XBOOLE_0, CAT_1,
      FUNCT_1, CARD_1, GRAPHSP, FINSEQ_1, AMISTD_2, CARD_3, AMISTD_1, CIRCUIT2,
      FUNCT_4, SETFAM_1, SUPINF_2, ARYTM_3, XXREAL_0, GOBOARD5, ARYTM_1,
      GROUP_1, FRECHET, PARTFUN1, COMPOS_1, NAT_1, GOBRD13, MEMSTR_0;
 notations TARSKI, XBOOLE_0, SUBSET_1, ENUMSET1, XTUPLE_0, MCART_1, SETFAM_1,
      RELAT_1, FUNCT_1, XXREAL_0, VALUED_1, STRUCT_0, ALGSTR_0, FUNCSDOM,
      ORDINAL1, CARD_1, NUMBERS, XCMPLX_0, NAT_1, FUNCOP_1, FINSEQ_1, PARTFUN1,
      FUNCT_4, CARD_3, FUNCT_7, GROUP_1, MEMSTR_0, COMPOS_0, COMPOS_1,
      EXTPRO_1, AMI_2, AMI_3, SCMRING1, SCMRING2, AMISTD_1, AMISTD_2, SCMRINGI;
 constructors FINSEQ_4, REALSET2, AMI_3, SCMRING2, AMISTD_2, RELSET_1,
      AMISTD_1, FUNCT_7, PRE_POLY, SCMRING1, XTUPLE_0;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1, XREAL_0, CARD_3,
      STRUCT_0, VECTSP_1, FINSET_1, AMI_3, SCMRING2, AMISTD_2, FUNCT_4,
      VALUED_0, EXTPRO_1, NAT_1, FUNCT_7, PRE_POLY, MEMSTR_0, CARD_1, COMPOS_0,
      XTUPLE_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, SCMRING2, AMISTD_1, AMISTD_2, XBOOLE_0, FUNCOP_1,
      COMPOS_1, EXTPRO_1, NAT_1, MEMSTR_0, MCART_1, COMPOS_0, SCMRINGI,
      XTUPLE_0;
 theorems TARSKI, NAT_1, SCMRING2, AMI_3, FUNCT_4, FUNCT_1, ZFMISC_1, FUNCOP_1,
      SCMRING1, SETFAM_1, AMISTD_1, STRUCT_0, AMI_2, RLVECT_1,
      VECTSP_1, LMOD_6, FINSEQ_1, CARD_3, ORDINAL1, XBOOLE_0, XBOOLE_1,
      ENUMSET1, PARTFUN1, PBOOLE, RECDEF_2, VALUED_1, EXTPRO_1,
      FUNCT_7, MEMSTR_0, COMPOS_0, COMPOS_1, XTUPLE_0;

begin
theorem
L1: (for R1 being Ring holds (for R3 being (Data-Location of R1) holds ( Values R3 ) = (the carrier of R1)))
proof
let R1 being Ring;
let R3 being (Data-Location of R1);
L2: (R3 in ( Data-Locations ( SCM ) ) & ( the_Values_of ( SCM R1 ) ) = ( ( SCM-VAL R1 ) * ( SCM-OK ) )) by SCMRING2:1 , SCMRING2:24;
thus L3: thesis by L2 , AMI_3:27 , SCMRING1:4;
end;
definition
let C1 being Ring;
let C2 , C3 being (Data-Location of C1);
let C4 , C5 being (Element of C1);
redefine func (C2 , C3) --> (C4 , C5) -> (FinPartState of ( SCM C1 ));

coherence
proof
reconsider D1 = C5 as (Element of ( Values C3 )) by L1;
reconsider D2 = C4 as (Element of ( Values C2 )) by L1;
L4: ( (C2 , C3) --> (D2 , D1) ) is (FinPartState of ( SCM C1 ));
thus L5: thesis by L4;
end;
end;
theorem
L7: (for R1 being Ring holds (for R3 being (Data-Location of R1) holds R3 <> ( IC ( SCM R1 ) )))
proof
let R1 being Ring;
let R3 being (Data-Location of R1);
L8: R3 in ( SCM-Data-Loc ) by AMI_2:def 16;
L9: R3 <> ( NAT ) by L8 , AMI_2:20;
thus L10: thesis by L9 , SCMRING2:8;
end;
theorem
L11: (for R1 being Ring holds (for B1 being (Object of ( SCM R1 )) holds (B1 = ( IC ( SCM R1 ) ) or B1 is (Data-Location of R1))))
proof
let R1 being Ring;
let C6 being (Object of ( SCM R1 ));
assume L12: C6 <> ( IC ( SCM R1 ) );
L13: (not C6 in { ( IC ( SCM R1 ) ) }) by L12 , TARSKI:def 1;
L14: (not C6 in { ( NAT ) }) by L13 , SCMRING2:8;
L15: (not C6 in { ( NAT ) }) by L14;
L16: C6 in ( (the carrier of ( SCM R1 )) \ { ( NAT ) } ) by L15 , XBOOLE_0:def 5;
L17: C6 in ( SCM-Data-Loc ) by L16 , SCMRING2:25;
thus L18: thesis by L17 , AMI_2:def 16;
end;
canceled 1;
theorem
L19: (for R1 being Ring holds (for R3 being (Data-Location of R1) holds (for R4 being (Data-Location of R1) holds ( InsCode ( R3 := R4 ) ) = 1))) by RECDEF_2:def 1;
theorem
L20: (for R1 being Ring holds (for R3 being (Data-Location of R1) holds (for R4 being (Data-Location of R1) holds ( InsCode ( AddTo (R3 , R4) ) ) = 2))) by RECDEF_2:def 1;
theorem
L21: (for R1 being Ring holds (for R3 being (Data-Location of R1) holds (for R4 being (Data-Location of R1) holds ( InsCode ( SubFrom (R3 , R4) ) ) = 3))) by RECDEF_2:def 1;
theorem
L22: (for R1 being Ring holds (for R3 being (Data-Location of R1) holds (for R4 being (Data-Location of R1) holds ( InsCode ( MultBy (R3 , R4) ) ) = 4))) by RECDEF_2:def 1;
theorem
L23: (for R1 being Ring holds (for R2 being (Element of R1) holds (for R3 being (Data-Location of R1) holds ( InsCode ( R3 := R2 ) ) = 5))) by RECDEF_2:def 1;
theorem
L24: (for R1 being Ring holds (for R8 being (Element of ( NAT )) holds ( InsCode ( goto (R8 , R1) ) ) = 6)) by RECDEF_2:def 1;
theorem
L25: (for R1 being Ring holds (for R3 being (Data-Location of R1) holds (for R8 being (Element of ( NAT )) holds ( InsCode ( R3 =0_goto R8 ) ) = 7))) by RECDEF_2:def 1;
theorem
L26: (for R1 being Ring holds (for R10 being (Instruction of ( SCM R1 )) holds (( InsCode R10 ) = ( 0 ) implies R10 = ( halt ( SCM R1 ) ))))
proof
let R1 being Ring;
let R10 being (Instruction of ( SCM R1 ));
L27: (R10 = [ ( 0 ) , ( {} ) , ( {} ) ] or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( R3 := R4 ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( AddTo (R3 , R4) ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( SubFrom (R3 , R4) ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( MultBy (R3 , R4) ))) or (ex R8 being (Element of ( NAT )) st R10 = ( goto (R8 , R1) )) or (ex R3 being (Data-Location of R1) st (ex R8 being (Element of ( NAT )) st R10 = ( R3 =0_goto R8 ))) or (ex R3 being (Data-Location of R1) st (ex R2 being (Element of R1) st R10 = ( R3 := R2 )))) by SCMRING2:7;
assume L28: ( InsCode R10 ) = ( 0 );
thus L29: thesis by L28 , L27 , RECDEF_2:def 1;
end;
theorem
L30: (for R1 being Ring holds (for R10 being (Instruction of ( SCM R1 )) holds (( InsCode R10 ) = 1 implies (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( R3 := R4 ))))))
proof
let R1 being Ring;
let R10 being (Instruction of ( SCM R1 ));
L31: (R10 = [ ( 0 ) , ( {} ) , ( {} ) ] or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( R3 := R4 ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( AddTo (R3 , R4) ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( SubFrom (R3 , R4) ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( MultBy (R3 , R4) ))) or (ex R8 being (Element of ( NAT )) st R10 = ( goto (R8 , R1) )) or (ex R3 being (Data-Location of R1) st (ex R8 being (Element of ( NAT )) st R10 = ( R3 =0_goto R8 ))) or (ex R3 being (Data-Location of R1) st (ex R2 being (Element of R1) st R10 = ( R3 := R2 )))) by SCMRING2:7;
assume L32: ( InsCode R10 ) = 1;
thus L33: thesis by L32 , L31 , RECDEF_2:def 1;
end;
theorem
L34: (for R1 being Ring holds (for R10 being (Instruction of ( SCM R1 )) holds (( InsCode R10 ) = 2 implies (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( AddTo (R3 , R4) ))))))
proof
let R1 being Ring;
let R10 being (Instruction of ( SCM R1 ));
L35: (R10 = [ ( 0 ) , ( {} ) , ( {} ) ] or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( R3 := R4 ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( AddTo (R3 , R4) ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( SubFrom (R3 , R4) ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( MultBy (R3 , R4) ))) or (ex R8 being (Element of ( NAT )) st R10 = ( goto (R8 , R1) )) or (ex R3 being (Data-Location of R1) st (ex R8 being (Element of ( NAT )) st R10 = ( R3 =0_goto R8 ))) or (ex R3 being (Data-Location of R1) st (ex R2 being (Element of R1) st R10 = ( R3 := R2 )))) by SCMRING2:7;
assume L36: ( InsCode R10 ) = 2;
thus L37: thesis by L36 , L35 , RECDEF_2:def 1;
end;
theorem
L38: (for R1 being Ring holds (for R10 being (Instruction of ( SCM R1 )) holds (( InsCode R10 ) = 3 implies (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( SubFrom (R3 , R4) ))))))
proof
let R1 being Ring;
let R10 being (Instruction of ( SCM R1 ));
L39: (R10 = [ ( 0 ) , ( {} ) , ( {} ) ] or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( R3 := R4 ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( AddTo (R3 , R4) ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( SubFrom (R3 , R4) ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( MultBy (R3 , R4) ))) or (ex R8 being (Element of ( NAT )) st R10 = ( goto (R8 , R1) )) or (ex R3 being (Data-Location of R1) st (ex R8 being (Element of ( NAT )) st R10 = ( R3 =0_goto R8 ))) or (ex R3 being (Data-Location of R1) st (ex R2 being (Element of R1) st R10 = ( R3 := R2 )))) by SCMRING2:7;
assume L40: ( InsCode R10 ) = 3;
thus L41: thesis by L40 , L39 , RECDEF_2:def 1;
end;
theorem
L42: (for R1 being Ring holds (for R10 being (Instruction of ( SCM R1 )) holds (( InsCode R10 ) = 4 implies (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( MultBy (R3 , R4) ))))))
proof
let R1 being Ring;
let R10 being (Instruction of ( SCM R1 ));
L43: (R10 = [ ( 0 ) , ( {} ) , ( {} ) ] or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( R3 := R4 ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( AddTo (R3 , R4) ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( SubFrom (R3 , R4) ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( MultBy (R3 , R4) ))) or (ex R8 being (Element of ( NAT )) st R10 = ( goto (R8 , R1) )) or (ex R3 being (Data-Location of R1) st (ex R8 being (Element of ( NAT )) st R10 = ( R3 =0_goto R8 ))) or (ex R3 being (Data-Location of R1) st (ex R2 being (Element of R1) st R10 = ( R3 := R2 )))) by SCMRING2:7;
assume L44: ( InsCode R10 ) = 4;
thus L45: thesis by L44 , L43 , RECDEF_2:def 1;
end;
theorem
L46: (for R1 being Ring holds (for R10 being (Instruction of ( SCM R1 )) holds (( InsCode R10 ) = 5 implies (ex R3 being (Data-Location of R1) st (ex R2 being (Element of R1) st R10 = ( R3 := R2 ))))))
proof
let R1 being Ring;
let R10 being (Instruction of ( SCM R1 ));
L47: (R10 = [ ( 0 ) , ( {} ) , ( {} ) ] or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( R3 := R4 ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( AddTo (R3 , R4) ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( SubFrom (R3 , R4) ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( MultBy (R3 , R4) ))) or (ex R8 being (Element of ( NAT )) st R10 = ( goto (R8 , R1) )) or (ex R3 being (Data-Location of R1) st (ex R8 being (Element of ( NAT )) st R10 = ( R3 =0_goto R8 ))) or (ex R3 being (Data-Location of R1) st (ex R2 being (Element of R1) st R10 = ( R3 := R2 )))) by SCMRING2:7;
assume L48: ( InsCode R10 ) = 5;
thus L49: thesis by L48 , L47 , RECDEF_2:def 1;
end;
theorem
L50: (for R1 being Ring holds (for R10 being (Instruction of ( SCM R1 )) holds (( InsCode R10 ) = 6 implies (ex R9 being (Element of ( NAT )) st R10 = ( goto (R9 , R1) )))))
proof
let R1 being Ring;
let R10 being (Instruction of ( SCM R1 ));
L51: (R10 = [ ( 0 ) , ( {} ) , ( {} ) ] or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( R3 := R4 ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( AddTo (R3 , R4) ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( SubFrom (R3 , R4) ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( MultBy (R3 , R4) ))) or (ex R8 being (Element of ( NAT )) st R10 = ( goto (R8 , R1) )) or (ex R3 being (Data-Location of R1) st (ex R8 being (Element of ( NAT )) st R10 = ( R3 =0_goto R8 ))) or (ex R3 being (Data-Location of R1) st (ex R2 being (Element of R1) st R10 = ( R3 := R2 )))) by SCMRING2:7;
assume L52: ( InsCode R10 ) = 6;
thus L53: thesis by L52 , L51 , RECDEF_2:def 1;
end;
theorem
L54: (for R1 being Ring holds (for R10 being (Instruction of ( SCM R1 )) holds (( InsCode R10 ) = 7 implies (ex R3 being (Data-Location of R1) st (ex R8 being (Element of ( NAT )) st R10 = ( R3 =0_goto R8 ))))))
proof
let R1 being Ring;
let R10 being (Instruction of ( SCM R1 ));
L55: (R10 = [ ( 0 ) , ( {} ) , ( {} ) ] or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( R3 := R4 ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( AddTo (R3 , R4) ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( SubFrom (R3 , R4) ))) or (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st R10 = ( MultBy (R3 , R4) ))) or (ex R8 being (Element of ( NAT )) st R10 = ( goto (R8 , R1) )) or (ex R3 being (Data-Location of R1) st (ex R8 being (Element of ( NAT )) st R10 = ( R3 =0_goto R8 ))) or (ex R3 being (Data-Location of R1) st (ex R2 being (Element of R1) st R10 = ( R3 := R2 )))) by SCMRING2:7;
assume L56: ( InsCode R10 ) = 7;
thus L57: thesis by L56 , L55 , RECDEF_2:def 1;
end;
L58: (for B2 , B3 being set holds (B2 in ( dom <* B3 *> ) implies B2 = 1))
proof
let C7 , C8 being set;
assume L59: C7 in ( dom <* C8 *> );
L60: C7 in ( Seg 1 ) by L59 , FINSEQ_1:def 8;
thus L61: thesis by L60 , FINSEQ_1:2 , TARSKI:def 1;
end;
L62: (for R1 being Ring holds (for R14 being (InsType of (the InstructionsF of ( SCM R1 ))) holds (R14 = ( 0 ) or R14 = 1 or R14 = 2 or R14 = 3 or R14 = 4 or R14 = 5 or R14 = 6 or R14 = 7)))
proof
let R1 being Ring;
let R14 being (InsType of (the InstructionsF of ( SCM R1 )));
consider C9 being set such that L63: [ R14 , C9 ] in ( proj1 (the InstructionsF of ( SCM R1 )) ) by XTUPLE_0:def 12;
consider C10 being set such that L64: [ [ R14 , C9 ] , C10 ] in (the InstructionsF of ( SCM R1 )) by L63 , XTUPLE_0:def 12;
L65: [ R14 , C9 , C10 ] in ( SCM-Instr R1 ) by L64 , SCMRING2:def 1;
L66: ([ R14 , C9 , C10 ] in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B4 , ( {} ) , <* B5 , B6 *> ] where B4 is (Element of ( Segm 8 )) , B5 , B6 is (Element of ( Data-Locations ( SCM ) )) : B4 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B7 *> , ( {} ) ] where B7 is (Element of ( NAT )) : (not contradiction) } ) \/ { [ 7 , <* B8 *> , <* B9 *> ] where B8 is (Element of ( NAT )) , B9 is (Element of ( Data-Locations ( SCM ) )) : (not contradiction) } ) or [ R14 , C9 , C10 ] in { [ 5 , ( {} ) , <* B10 , B11 *> ] where B10 is (Element of ( Data-Locations ( SCM ) )) , B11 is (Element of R1) : (not contradiction) }) by L65 , AMI_3:27 , XBOOLE_0:def 3;
L67: ([ R14 , C9 , C10 ] in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B12 , ( {} ) , <* B13 , B14 *> ] where B12 is (Element of ( Segm 8 )) , B13 , B14 is (Element of ( Data-Locations ( SCM ) )) : B12 in { 1 , 2 , 3 , 4 } } ) \/ { [ 6 , <* B15 *> , ( {} ) ] where B15 is (Element of ( NAT )) : (not contradiction) } ) or [ R14 , C9 , C10 ] in { [ 7 , <* B16 *> , <* B17 *> ] where B16 is (Element of ( NAT )) , B17 is (Element of ( Data-Locations ( SCM ) )) : (not contradiction) } or [ R14 , C9 , C10 ] in { [ 5 , ( {} ) , <* B18 , B19 *> ] where B18 is (Element of ( Data-Locations ( SCM ) )) , B19 is (Element of R1) : (not contradiction) }) by L66 , XBOOLE_0:def 3;
L68: ([ R14 , C9 , C10 ] in ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ B20 , ( {} ) , <* B21 , B22 *> ] where B20 is (Element of ( Segm 8 )) , B21 , B22 is (Element of ( Data-Locations ( SCM ) )) : B20 in { 1 , 2 , 3 , 4 } } ) or [ R14 , C9 , C10 ] in { [ 6 , <* B23 *> , ( {} ) ] where B23 is (Element of ( NAT )) : (not contradiction) } or [ R14 , C9 , C10 ] in { [ 7 , <* B24 *> , <* B25 *> ] where B24 is (Element of ( NAT )) , B25 is (Element of ( Data-Locations ( SCM ) )) : (not contradiction) } or [ R14 , C9 , C10 ] in { [ 5 , ( {} ) , <* B26 , B27 *> ] where B26 is (Element of ( Data-Locations ( SCM ) )) , B27 is (Element of R1) : (not contradiction) }) by L67 , XBOOLE_0:def 3;
per cases  by L68 , XBOOLE_0:def 3;
suppose L69: [ R14 , C9 , C10 ] in { [ ( 0 ) , ( {} ) , ( {} ) ] };

L70: [ R14 , C9 , C10 ] = [ ( 0 ) , ( {} ) , ( {} ) ] by L69 , TARSKI:def 1;
thus L71: thesis by L70 , XTUPLE_0:3;
end;
suppose L72: [ R14 , C9 , C10 ] in { [ B28 , ( {} ) , <* B29 , B30 *> ] where B28 is (Element of ( Segm 8 )) , B29 , B30 is (Element of ( Data-Locations ( SCM ) )) : B28 in { 1 , 2 , 3 , 4 } };

L73: (ex B31 being (Element of ( Segm 8 )) st (ex B32 , B33 being (Element of ( Data-Locations ( SCM ) )) st ([ R14 , C9 , C10 ] = [ B31 , ( {} ) , <* B32 , B33 *> ] & B31 in { 1 , 2 , 3 , 4 }))) by L72;
L74: R14 in { 1 , 2 , 3 , 4 } by L73 , XTUPLE_0:3;
thus L75: thesis by L74 , ENUMSET1:def 2;
end;
suppose L76: [ R14 , C9 , C10 ] in { [ 6 , <* B34 *> , ( {} ) ] where B34 is (Element of ( NAT )) : (not contradiction) };

L77: (ex B35 being (Element of ( NAT )) st [ R14 , C9 , C10 ] = [ 6 , <* B35 *> , ( {} ) ]) by L76;
thus L78: thesis by L77 , XTUPLE_0:3;
end;
suppose L79: [ R14 , C9 , C10 ] in { [ 7 , <* B36 *> , <* B37 *> ] where B36 is (Element of ( NAT )) , B37 is (Element of ( Data-Locations ( SCM ) )) : (not contradiction) };

L80: (ex B38 being (Element of ( NAT )) st (ex B39 being (Element of ( Data-Locations ( SCM ) )) st [ R14 , C9 , C10 ] = [ 7 , <* B38 *> , <* B39 *> ])) by L79;
thus L81: thesis by L80 , XTUPLE_0:3;
end;
suppose L82: [ R14 , C9 , C10 ] in { [ 5 , ( {} ) , <* B40 , B41 *> ] where B40 is (Element of ( Data-Locations ( SCM ) )) , B41 is (Element of R1) : (not contradiction) };

L83: (ex B42 being (Element of ( Data-Locations ( SCM ) )) st (ex B43 being (Element of R1) st [ R14 , C9 , C10 ] = [ 5 , ( {} ) , <* B42 , B43 *> ])) by L82;
thus L84: thesis by L83 , XTUPLE_0:3;
end;
end;
theorem
L86: (for R1 being Ring holds (for R14 being (InsType of (the InstructionsF of ( SCM R1 ))) holds (R14 = ( 0 ) implies ( JumpParts R14 ) = { ( 0 ) })))
proof
let R1 being Ring;
let R14 being (InsType of (the InstructionsF of ( SCM R1 )));
assume L87: R14 = ( 0 );
thus L88:now
let C11 being set;
assume L89: C11 in ( JumpParts R14 );
consider R10 being (Instruction of ( SCM R1 )) such that L90: C11 = ( JumpPart R10 ) and L91: ( InsCode R10 ) = R14 by L89;
L92: R10 = ( halt ( SCM R1 ) ) by L87 , L91 , L26;
L93: C11 = ( {} ) by L92 , L90;
thus L94: C11 in { ( 0 ) } by L93 , TARSKI:def 1;
end;
let C12 being set;
assume L95: C12 in { ( 0 ) };
L96: C12 = ( 0 ) by L95 , TARSKI:def 1;
L97: (( InsCode ( halt ( SCM R1 ) ) ) = ( 0 ) & ( JumpPart ( halt ( SCM R1 ) ) ) = ( 0 )) by COMPOS_1:70;
thus L98: thesis by L97 , L87 , L96;
end;
theorem
L99: (for R1 being Ring holds (for R14 being (InsType of (the InstructionsF of ( SCM R1 ))) holds (R14 = 1 implies ( JumpParts R14 ) = { ( {} ) })))
proof
let R1 being Ring;
let R14 being (InsType of (the InstructionsF of ( SCM R1 )));
assume L100: R14 = 1;
thus L101:now
let C13 being set;
assume L102: C13 in ( JumpParts R14 );
consider C14 being (Instruction of ( SCM R1 )) such that L103: C13 = ( JumpPart C14 ) and L104: ( InsCode C14 ) = R14 by L102;
consider R3 being (Data-Location of R1), R4 being (Data-Location of R1) such that L105: C14 = ( R3 := R4 ) by L100 , L104 , L30;
L106: C13 = ( {} ) by L103 , L105 , RECDEF_2:def 2;
thus L107: C13 in { ( {} ) } by L106 , TARSKI:def 1;
end;
set D3 = the (Data-Location of R1);
let C15 being set;
assume L108: C15 in { ( {} ) };
L109: C15 = ( {} ) by L108 , TARSKI:def 1;
L110: C15 = ( JumpPart ( D3 := D3 ) ) by L109 , RECDEF_2:def 2;
L111: ( InsCode ( D3 := D3 ) ) = 1 by RECDEF_2:def 1;
thus L112: thesis by L111 , L110 , L100;
end;
theorem
L113: (for R1 being Ring holds (for R14 being (InsType of (the InstructionsF of ( SCM R1 ))) holds (R14 = 2 implies ( JumpParts R14 ) = { ( {} ) })))
proof
let R1 being Ring;
let R14 being (InsType of (the InstructionsF of ( SCM R1 )));
assume L114: R14 = 2;
thus L115:now
let C16 being set;
assume L116: C16 in ( JumpParts R14 );
consider C17 being (Instruction of ( SCM R1 )) such that L117: C16 = ( JumpPart C17 ) and L118: ( InsCode C17 ) = R14 by L116;
consider R3 being (Data-Location of R1), R4 being (Data-Location of R1) such that L119: C17 = ( AddTo (R3 , R4) ) by L114 , L118 , L34;
L120: C16 = ( {} ) by L117 , L119 , RECDEF_2:def 2;
thus L121: C16 in { ( {} ) } by L120 , TARSKI:def 1;
end;
set D4 = the (Data-Location of R1);
let C18 being set;
assume L122: C18 in { ( {} ) };
L123: C18 = ( {} ) by L122 , TARSKI:def 1;
L124: C18 = ( JumpPart ( AddTo (D4 , D4) ) ) by L123 , RECDEF_2:def 2;
L125: ( InsCode ( AddTo (D4 , D4) ) ) = 2 by RECDEF_2:def 1;
thus L126: thesis by L125 , L124 , L114;
end;
theorem
L127: (for R1 being Ring holds (for R14 being (InsType of (the InstructionsF of ( SCM R1 ))) holds (R14 = 3 implies ( JumpParts R14 ) = { ( {} ) })))
proof
let R1 being Ring;
let R14 being (InsType of (the InstructionsF of ( SCM R1 )));
assume L128: R14 = 3;
thus L129:now
let C19 being set;
assume L130: C19 in ( JumpParts R14 );
consider C20 being (Instruction of ( SCM R1 )) such that L131: C19 = ( JumpPart C20 ) and L132: ( InsCode C20 ) = R14 by L130;
consider R3 being (Data-Location of R1), R4 being (Data-Location of R1) such that L133: C20 = ( SubFrom (R3 , R4) ) by L128 , L132 , L38;
L134: C19 = ( {} ) by L131 , L133 , RECDEF_2:def 2;
thus L135: C19 in { ( {} ) } by L134 , TARSKI:def 1;
end;
set D5 = the (Data-Location of R1);
let C21 being set;
assume L136: C21 in { ( {} ) };
L137: C21 = ( {} ) by L136 , TARSKI:def 1;
L138: C21 = ( JumpPart ( SubFrom (D5 , D5) ) ) by L137 , RECDEF_2:def 2;
L139: ( InsCode ( SubFrom (D5 , D5) ) ) = 3 by RECDEF_2:def 1;
thus L140: thesis by L139 , L138 , L128;
end;
theorem
L141: (for R1 being Ring holds (for R14 being (InsType of (the InstructionsF of ( SCM R1 ))) holds (R14 = 4 implies ( JumpParts R14 ) = { ( {} ) })))
proof
let R1 being Ring;
let R14 being (InsType of (the InstructionsF of ( SCM R1 )));
assume L142: R14 = 4;
thus L143:now
let C22 being set;
assume L144: C22 in ( JumpParts R14 );
consider C23 being (Instruction of ( SCM R1 )) such that L145: C22 = ( JumpPart C23 ) and L146: ( InsCode C23 ) = R14 by L144;
consider R3 being (Data-Location of R1), R4 being (Data-Location of R1) such that L147: C23 = ( MultBy (R3 , R4) ) by L142 , L146 , L42;
L148: C22 = ( {} ) by L145 , L147 , RECDEF_2:def 2;
thus L149: C22 in { ( {} ) } by L148 , TARSKI:def 1;
end;
set D6 = the (Data-Location of R1);
let C24 being set;
assume L150: C24 in { ( {} ) };
L151: C24 = ( {} ) by L150 , TARSKI:def 1;
L152: C24 = ( JumpPart ( MultBy (D6 , D6) ) ) by L151 , RECDEF_2:def 2;
L153: ( InsCode ( MultBy (D6 , D6) ) ) = 4 by RECDEF_2:def 1;
thus L154: thesis by L153 , L152 , L142;
end;
theorem
L155: (for R1 being Ring holds (for R14 being (InsType of (the InstructionsF of ( SCM R1 ))) holds (R14 = 5 implies ( JumpParts R14 ) = { ( {} ) })))
proof
let R1 being Ring;
let R14 being (InsType of (the InstructionsF of ( SCM R1 )));
assume L156: R14 = 5;
thus L157:now
let C25 being set;
assume L158: C25 in ( JumpParts R14 );
consider C26 being (Instruction of ( SCM R1 )) such that L159: C25 = ( JumpPart C26 ) and L160: ( InsCode C26 ) = R14 by L158;
consider R3 being (Data-Location of R1), R2 being (Element of R1) such that L161: C26 = ( R3 := R2 ) by L156 , L160 , L46;
L162: C25 = ( {} ) by L159 , L161 , RECDEF_2:def 2;
thus L163: C25 in { ( {} ) } by L162 , TARSKI:def 1;
end;
set D7 = the (Data-Location of R1);
set D8 = the (Element of R1);
let C27 being set;
assume L164: C27 in { ( {} ) };
L165: C27 = ( {} ) by L164 , TARSKI:def 1;
L166: C27 = ( JumpPart ( D7 := D8 ) ) by L165 , RECDEF_2:def 2;
L167: ( InsCode ( D7 := D8 ) ) = 5 by RECDEF_2:def 1;
thus L168: thesis by L167 , L166 , L156;
end;
theorem
L169: (for R1 being Ring holds (for R14 being (InsType of (the InstructionsF of ( SCM R1 ))) holds (R14 = 6 implies ( dom ( product" ( JumpParts R14 ) ) ) = { 1 })))
proof
let R1 being Ring;
let R14 being (InsType of (the InstructionsF of ( SCM R1 )));
set D9 = the (Element of ( NAT ));
assume L170: R14 = 6;
L171: ( JumpPart ( goto (D9 , R1) ) ) = <* D9 *> by RECDEF_2:def 2;
thus L172:now
let C28 being set;
L173: ( InsCode ( goto (D9 , R1) ) ) = 6 by RECDEF_2:def 1;
L174: ( JumpPart ( goto (D9 , R1) ) ) in ( JumpParts R14 ) by L173 , L170;
assume L175: C28 in ( dom ( product" ( JumpParts R14 ) ) );
L176: C28 in ( DOM ( JumpParts R14 ) ) by L175 , CARD_3:def 12;
L177: C28 in ( dom ( JumpPart ( goto (D9 , R1) ) ) ) by L176 , L174 , CARD_3:108;
thus L178: C28 in { 1 } by L177 , L171 , FINSEQ_1:2 , FINSEQ_1:def 8;
end;
let C29 being set;
assume L179: C29 in { 1 };
L180: (for B44 being Function holds (B44 in ( JumpParts R14 ) implies C29 in ( dom B44 )))
proof
let C30 being Function;
assume L181: C30 in ( JumpParts R14 );
consider C31 being (Instruction of ( SCM R1 )) such that L182: C30 = ( JumpPart C31 ) and L183: ( InsCode C31 ) = R14 by L181;
consider R8 being (Element of ( NAT )) such that L184: C31 = ( goto (R8 , R1) ) by L170 , L183 , L50;
L185: C30 = <* R8 *> by L182 , L184 , RECDEF_2:def 2;
thus L186: thesis by L185 , L179 , FINSEQ_1:2 , FINSEQ_1:def 8;
end;
L187: C29 in ( DOM ( JumpParts R14 ) ) by L180 , CARD_3:109;
thus L188: thesis by L187 , CARD_3:def 12;
end;
theorem
L189: (for R1 being Ring holds (for R14 being (InsType of (the InstructionsF of ( SCM R1 ))) holds (R14 = 7 implies ( dom ( product" ( JumpParts R14 ) ) ) = { 1 })))
proof
let R1 being Ring;
let R14 being (InsType of (the InstructionsF of ( SCM R1 )));
set D10 = the (Element of ( NAT ));
set D11 = the (Data-Location of R1);
assume L190: R14 = 7;
L191: ( JumpPart ( D11 =0_goto D10 ) ) = <* D10 *> by RECDEF_2:def 2;
thus L192:now
let C32 being set;
L193: ( InsCode ( D11 =0_goto D10 ) ) = 7 by RECDEF_2:def 1;
L194: ( JumpPart ( D11 =0_goto D10 ) ) in ( JumpParts R14 ) by L193 , L190;
assume L195: C32 in ( dom ( product" ( JumpParts R14 ) ) );
L196: C32 in ( DOM ( JumpParts R14 ) ) by L195 , CARD_3:def 12;
L197: C32 in ( dom ( JumpPart ( D11 =0_goto D10 ) ) ) by L196 , L194 , CARD_3:108;
thus L198: C32 in { 1 } by L197 , L191 , FINSEQ_1:2 , FINSEQ_1:38;
end;
let C33 being set;
assume L199: C33 in { 1 };
L200: (for B45 being Function holds (B45 in ( JumpParts R14 ) implies C33 in ( dom B45 )))
proof
let C34 being Function;
assume L201: C34 in ( JumpParts R14 );
consider C35 being (Instruction of ( SCM R1 )) such that L202: C34 = ( JumpPart C35 ) and L203: ( InsCode C35 ) = R14 by L201;
consider R3 being (Data-Location of R1), R8 being (Element of ( NAT )) such that L204: C35 = ( R3 =0_goto R8 ) by L190 , L203 , L54;
L205: C34 = <* R8 *> by L202 , L204 , RECDEF_2:def 2;
thus L206: thesis by L205 , L199 , FINSEQ_1:2 , FINSEQ_1:38;
end;
L207: C33 in ( DOM ( JumpParts R14 ) ) by L200 , CARD_3:109;
thus L208: thesis by L207 , CARD_3:def 12;
end;
theorem
L209: (for R1 being Ring holds (for R8 being (Element of ( NAT )) holds ( ( product" ( JumpParts ( InsCode ( goto (R8 , R1) ) ) ) ) . 1 ) = ( NAT )))
proof
let R1 being Ring;
let R8 being (Element of ( NAT ));
L210: ( dom ( product" ( JumpParts ( InsCode ( goto (R8 , R1) ) ) ) ) ) = { 1 } by L24 , L169;
L211: 1 in ( dom ( product" ( JumpParts ( InsCode ( goto (R8 , R1) ) ) ) ) ) by L210 , TARSKI:def 1;
L212: ( InsCode ( goto (R8 , R1) ) ) = 6 by RECDEF_2:def 1;
thus L213:now
let C36 being set;
assume L214: C36 in ( ( product" ( JumpParts ( InsCode ( goto (R8 , R1) ) ) ) ) . 1 );
L215: C36 in ( pi (( JumpParts ( InsCode ( goto (R8 , R1) ) ) ) , 1) ) by L214 , L211 , CARD_3:def 12;
consider C37 being Function such that L216: C37 in ( JumpParts ( InsCode ( goto (R8 , R1) ) ) ) and L217: C36 = ( C37 . 1 ) by L215 , CARD_3:def 6;
consider C38 being (Instruction of ( SCM R1 )) such that L218: C37 = ( JumpPart C38 ) and L219: ( InsCode C38 ) = ( InsCode ( goto (R8 , R1) ) ) by L216;
consider R9 being (Element of ( NAT )) such that L220: C38 = ( goto (R9 , R1) ) by L212 , L219 , L50;
L221: C37 = <* R9 *> by L218 , L220 , RECDEF_2:def 2;
L222: C36 = R9 by L221 , L217 , FINSEQ_1:def 8;
thus L223: C36 in ( NAT ) by L222;
end;
let C39 being set;
assume L224: C39 in ( NAT );
reconsider D12 = C39 as (Element of ( NAT )) by L224;
L225: (( JumpPart ( goto (D12 , R1) ) ) = <* D12 *> & ( InsCode ( goto (R8 , R1) ) ) = ( InsCode ( goto (D12 , R1) ) )) by L212 , RECDEF_2:def 1 , RECDEF_2:def 2;
L226: <* D12 *> in ( JumpParts ( InsCode ( goto (R8 , R1) ) ) ) by L225;
L227: ( <* D12 *> . 1 ) = D12 by FINSEQ_1:def 8;
L228: D12 in ( pi (( JumpParts ( InsCode ( goto (R8 , R1) ) ) ) , 1) ) by L227 , L226 , CARD_3:def 6;
thus L229: thesis by L228 , L211 , CARD_3:def 12;
end;
theorem
L230: (for R1 being Ring holds (for R3 being (Data-Location of R1) holds (for R8 being (Element of ( NAT )) holds ( ( product" ( JumpParts ( InsCode ( R3 =0_goto R8 ) ) ) ) . 1 ) = ( NAT ))))
proof
let R1 being Ring;
let R3 being (Data-Location of R1);
let R8 being (Element of ( NAT ));
L231: ( dom ( product" ( JumpParts ( InsCode ( R3 =0_goto R8 ) ) ) ) ) = { 1 } by L25 , L189;
L232: 1 in ( dom ( product" ( JumpParts ( InsCode ( R3 =0_goto R8 ) ) ) ) ) by L231 , TARSKI:def 1;
L233: ( InsCode ( R3 =0_goto R8 ) ) = 7 by RECDEF_2:def 1;
thus L234:now
let C40 being set;
assume L235: C40 in ( ( product" ( JumpParts ( InsCode ( R3 =0_goto R8 ) ) ) ) . 1 );
L236: C40 in ( pi (( JumpParts ( InsCode ( R3 =0_goto R8 ) ) ) , 1) ) by L235 , L232 , CARD_3:def 12;
consider C41 being Function such that L237: C41 in ( JumpParts ( InsCode ( R3 =0_goto R8 ) ) ) and L238: C40 = ( C41 . 1 ) by L236 , CARD_3:def 6;
consider C42 being (Instruction of ( SCM R1 )) such that L239: C41 = ( JumpPart C42 ) and L240: ( InsCode C42 ) = ( InsCode ( R3 =0_goto R8 ) ) by L237;
consider R4 being (Data-Location of R1), R9 being (Element of ( NAT )) such that L241: C42 = ( R4 =0_goto R9 ) by L233 , L240 , L54;
L242: C41 = <* R9 *> by L239 , L241 , RECDEF_2:def 2;
L243: C40 = R9 by L242 , L238 , FINSEQ_1:40;
thus L244: C40 in ( NAT ) by L243;
end;
let C43 being set;
assume L245: C43 in ( NAT );
reconsider D13 = C43 as (Element of ( NAT )) by L245;
L246: (( JumpPart ( R3 =0_goto D13 ) ) = <* D13 *> & ( InsCode ( R3 =0_goto R8 ) ) = ( InsCode ( R3 =0_goto D13 ) )) by L233 , RECDEF_2:def 1 , RECDEF_2:def 2;
L247: <* D13 *> in ( JumpParts ( InsCode ( R3 =0_goto R8 ) ) ) by L246;
L248: ( <* D13 *> . 1 ) = D13 by FINSEQ_1:40;
L249: D13 in ( pi (( JumpParts ( InsCode ( R3 =0_goto R8 ) ) ) , 1) ) by L248 , L247 , CARD_3:def 6;
thus L250: thesis by L249 , L232 , CARD_3:def 12;
end;
L251: (for R1 being Ring holds (for B46 being (Instruction of ( SCM R1 )) holds ((for B47 being (Element of ( NAT )) holds ( NIC (B46 , B47) ) = { ( succ B47 ) }) implies ( JUMP B46 ) is  empty)))
proof
let R1 being Ring;
set D14 = 1;
set D15 = 2;
let C44 being (Instruction of ( SCM R1 ));
assume L252: (for B48 being (Element of ( NAT )) holds ( NIC (C44 , B48) ) = { ( succ B48 ) });
set D16 = { ( NIC (C44 , B49) ) where B49 is (Element of ( NAT )) : (not contradiction) };
reconsider D17 = D14 , D18 = D15 as (Element of ( NAT ));
assume L253: (not thesis);
consider C45 being set such that L254: C45 in ( meet D16 ) by L253 , XBOOLE_0:def 1;
L255: ( NIC (C44 , D17) ) = { ( succ D17 ) } by L252;
L256: { ( succ D17 ) } in D16 by L255;
L257: C45 in { ( succ D17 ) } by L256 , L254 , SETFAM_1:def 1;
L258: C45 = ( succ D17 ) by L257 , TARSKI:def 1;
L259: ( NIC (C44 , D18) ) = { ( succ D18 ) } by L252;
L260: { ( succ D18 ) } in D16 by L259;
L261: C45 in { ( succ D18 ) } by L260 , L254 , SETFAM_1:def 1;
thus L262: contradiction by L261 , L258 , TARSKI:def 1;
end;
registration
let R1 being Ring;
cluster ( JUMP ( halt ( SCM R1 ) ) ) ->  empty;
coherence;
end;
registration
let R1 being Ring;
let R3 being (Data-Location of R1);
let R4 being (Data-Location of R1);
cluster ( R3 := R4 ) ->  sequential;
coherence
proof
let C46 being (State of ( SCM R1 ));
thus L264: thesis by SCMRING2:11;
end;
cluster ( AddTo (R3 , R4) ) ->  sequential;
coherence
proof
let C47 being (State of ( SCM R1 ));
thus L265: thesis by SCMRING2:12;
end;
cluster ( SubFrom (R3 , R4) ) ->  sequential;
coherence
proof
let C48 being (State of ( SCM R1 ));
thus L266: thesis by SCMRING2:13;
end;
cluster ( MultBy (R3 , R4) ) ->  sequential;
coherence
proof
let C49 being (State of ( SCM R1 ));
thus L267: thesis by SCMRING2:14;
end;
end;
registration
let R1 being Ring;
let R3 being (Data-Location of R1);
let R2 being (Element of R1);
cluster ( R3 := R2 ) ->  sequential;
coherence
proof
let C50 being (State of ( SCM R1 ));
thus L269: thesis by SCMRING2:17;
end;
end;
registration
let R1 being Ring;
let R3 being (Data-Location of R1);
let R4 being (Data-Location of R1);
cluster ( JUMP ( R3 := R4 ) ) ->  empty;
coherence
proof
L271: (for B50 being (Element of ( NAT )) holds ( NIC (( R3 := R4 ) , B50) ) = { ( succ B50 ) }) by AMISTD_1:12;
thus L272: thesis by L271 , L251;
end;
end;
registration
let R1 being Ring;
let R3 being (Data-Location of R1);
let R4 being (Data-Location of R1);
cluster ( JUMP ( AddTo (R3 , R4) ) ) ->  empty;
coherence
proof
L274: (for B51 being (Element of ( NAT )) holds ( NIC (( AddTo (R3 , R4) ) , B51) ) = { ( succ B51 ) }) by AMISTD_1:12;
thus L275: thesis by L274 , L251;
end;
end;
registration
let R1 being Ring;
let R3 being (Data-Location of R1);
let R4 being (Data-Location of R1);
cluster ( JUMP ( SubFrom (R3 , R4) ) ) ->  empty;
coherence
proof
L277: (for B52 being (Element of ( NAT )) holds ( NIC (( SubFrom (R3 , R4) ) , B52) ) = { ( succ B52 ) }) by AMISTD_1:12;
thus L278: thesis by L277 , L251;
end;
end;
registration
let R1 being Ring;
let R3 being (Data-Location of R1);
let R4 being (Data-Location of R1);
cluster ( JUMP ( MultBy (R3 , R4) ) ) ->  empty;
coherence
proof
L280: (for B53 being (Element of ( NAT )) holds ( NIC (( MultBy (R3 , R4) ) , B53) ) = { ( succ B53 ) }) by AMISTD_1:12;
thus L281: thesis by L280 , L251;
end;
end;
registration
let R1 being Ring;
let R3 being (Data-Location of R1);
let R2 being (Element of R1);
cluster ( JUMP ( R3 := R2 ) ) ->  empty;
coherence
proof
L283: (for B54 being (Element of ( NAT )) holds ( NIC (( R3 := R2 ) , B54) ) = { ( succ B54 ) }) by AMISTD_1:12;
thus L284: thesis by L283 , L251;
end;
end;
theorem
L286: (for R1 being Ring holds (for R7 being (Element of ( NAT )) holds (for R8 being (Element of ( NAT )) holds ( NIC (( goto (R8 , R1) ) , R7) ) = { R8 })))
proof
let R1 being Ring;
let R7 being (Element of ( NAT ));
let R8 being (Element of ( NAT ));
L287:
now
let C51 being set;
L288:
now
reconsider D19 = R7 as (Element of ( Values ( IC ( SCM R1 ) ) )) by MEMSTR_0:def 6;
set D20 = ( goto (R8 , R1) );
set D21 = the (State of ( SCM R1 ));
set D22 = the (Instruction-Sequence of ( SCM R1 ));
assume L289: C51 = R8;
reconsider D23 = ( D21 +* (( IC ( SCM R1 ) ) , D19) ) as (Element of ( product ( the_Values_of ( SCM R1 ) ) )) by CARD_3:107;
reconsider D24 = ( D22 +* (R7 , D20) ) as (Instruction-Sequence of ( SCM R1 ));
L290: ( D24 /. R7 ) = ( D24 . R7 ) by PBOOLE:143;
L291: ( IC ( SCM R1 ) ) in ( dom D21 ) by MEMSTR_0:2;
L292: ( IC D23 ) = R7 by L291 , FUNCT_7:31;
L293: R7 in ( NAT );
L294: R7 in ( dom D22 ) by L293 , PARTFUN1:def 2;
L295: ( D24 . R7 ) = D20 by L294 , FUNCT_7:31;
L296: ( IC ( Following (D24 , D23) ) ) = R8 by L295 , L292 , L290 , SCMRING2:15;
thus L297: C51 in { ( IC ( Exec (( goto (R8 , R1) ) , B55) ) ) where B55 is (Element of ( product ( the_Values_of ( SCM R1 ) ) )) : ( IC B55 ) = R7 } by L296 , L289 , L290 , L292 , L295;
end;
L298:
now
assume L299: C51 in { ( IC ( Exec (( goto (R8 , R1) ) , B56) ) ) where B56 is (Element of ( product ( the_Values_of ( SCM R1 ) ) )) : ( IC B56 ) = R7 };
L300: (ex B57 being (Element of ( product ( the_Values_of ( SCM R1 ) ) )) st (C51 = ( IC ( Exec (( goto (R8 , R1) ) , B57) ) ) & ( IC B57 ) = R7)) by L299;
thus L301: C51 = R8 by L300 , SCMRING2:15;
end;
thus L302: (C51 in { R8 } iff C51 in { ( IC ( Exec (( goto (R8 , R1) ) , B58) ) ) where B58 is (Element of ( product ( the_Values_of ( SCM R1 ) ) )) : ( IC B58 ) = R7 }) by L298 , L288 , TARSKI:def 1;
end;
thus L303: thesis by L287 , TARSKI:1;
end;
theorem
L304: (for R1 being Ring holds (for R8 being (Element of ( NAT )) holds ( JUMP ( goto (R8 , R1) ) ) = { R8 }))
proof
let R1 being Ring;
let R8 being (Element of ( NAT ));
set D25 = { ( NIC (( goto (R8 , R1) ) , R7) ) where R7 is (Element of ( NAT )) : (not contradiction) };
L305:
now
let C52 being set;
thus L306:now
reconsider D26 = 1 as (Element of ( NAT ));
L307: ( NIC (( goto (R8 , R1) ) , D26) ) in D25;
assume L308: C52 in ( meet D25 );
L309: C52 in ( NIC (( goto (R8 , R1) ) , D26) ) by L308 , L307 , SETFAM_1:def 1;
thus L310: C52 in { R8 } by L309 , L286;
end;
assume L311: C52 in { R8 };
L312: C52 = R8 by L311 , TARSKI:def 1;
L313:
now
let C53 being set;
assume L314: C53 in D25;
consider C54 being (Element of ( NAT )) such that L315: C53 = ( NIC (( goto (R8 , R1) ) , C54) ) by L314;
L316: ( NIC (( goto (R8 , R1) ) , C54) ) = { R8 } by L286;
thus L317: R8 in C53 by L316 , L315 , TARSKI:def 1;
end;
L318: ( NIC (( goto (R8 , R1) ) , R8) ) in D25;
thus L319: C52 in ( meet D25 ) by L318 , L312 , L313 , SETFAM_1:def 1;
end;
thus L320: thesis by L305 , TARSKI:1;
end;
registration
let R1 being Ring;
let R8 being (Element of ( NAT ));
cluster ( JUMP ( goto (R8 , R1) ) ) -> 1 -element;
coherence
proof
L321: ( JUMP ( goto (R8 , R1) ) ) = { R8 } by L304;
thus L322: thesis by L321;
end;
end;
theorem
L324: (for R1 being Ring holds (for R3 being (Data-Location of R1) holds (for R7 being (Element of ( NAT )) holds (for R8 being (Element of ( NAT )) holds (R8 in ( NIC (( R3 =0_goto R8 ) , R7) ) & ( NIC (( R3 =0_goto R8 ) , R7) ) c= { R8 , ( succ R7 ) })))))
proof
let R1 being Ring;
let R3 being (Data-Location of R1);
let R7 being (Element of ( NAT ));
let R8 being (Element of ( NAT ));
set D27 = the (State of ( SCM R1 ));
set D28 = the (Instruction-Sequence of ( SCM R1 ));
set D29 = ( R3 =0_goto R8 );
reconsider D30 = R3 as (Element of ( Data-Locations ( SCM ) )) by SCMRING2:1;
reconsider D31 = R7 as (Element of ( Values ( IC ( SCM R1 ) ) )) by MEMSTR_0:def 6;
L325: ( Values R3 ) = ( ( ( SCM-VAL R1 ) * ( SCM-OK ) ) . D30 ) by SCMRING2:24
.= (the carrier of R1) by AMI_3:27 , SCMRING1:4;
reconsider D32 = ( 0. R1 ) as (Element of ( Values R3 )) by L325;
reconsider D33 = ( D27 +* (( IC ( SCM R1 ) ) , D31) ) as (Element of ( product ( the_Values_of ( SCM R1 ) ) )) by CARD_3:107;
reconsider D34 = ( D28 +* (R7 , D29) ) as (Instruction-Sequence of ( SCM R1 ));
reconsider D35 = ( D33 +* ( R3 .--> D32 ) ) as (Element of ( product ( the_Values_of ( SCM R1 ) ) )) by CARD_3:107;
L326: ( IC ( SCM R1 ) ) in ( dom D27 ) by MEMSTR_0:2;
L327: ( dom ( R3 .--> D32 ) ) = { R3 } by FUNCOP_1:13;
L328: ( IC ( SCM R1 ) ) <> R3 by L7;
L329: (not ( IC ( SCM R1 ) ) in ( dom ( R3 .--> D32 ) )) by L328 , L327 , TARSKI:def 1;
L330: ( IC D35 ) = ( IC D33 ) by L329 , FUNCT_4:11
.= R7 by L326 , FUNCT_7:31;
L331: ( D34 /. R7 ) = ( D34 . R7 ) by PBOOLE:143;
L332: R7 in ( NAT );
L333: R7 in ( dom D28 ) by L332 , PARTFUN1:def 2;
L334: ( D34 . R7 ) = D29 by L333 , FUNCT_7:31;
L335: R3 in ( dom ( R3 .--> D32 ) ) by L327 , TARSKI:def 1;
L336: ( D35 . R3 ) = ( ( R3 .--> D32 ) . R3 ) by L335 , FUNCT_4:13
.= ( 0. R1 ) by FUNCOP_1:72;
L337: ( IC ( Following (D34 , D35) ) ) = R8 by L336 , L330 , L334 , L331 , SCMRING2:16;
thus L338: R8 in ( NIC (( R3 =0_goto R8 ) , R7) ) by L337 , L330 , L334 , L331;
let C55 being set;
assume L339: C55 in ( NIC (( R3 =0_goto R8 ) , R7) );
consider C56 being (Element of ( product ( the_Values_of ( SCM R1 ) ) )) such that L340: (C55 = ( IC ( Exec (( R3 =0_goto R8 ) , C56) ) ) & ( IC C56 ) = R7) by L339;
per cases ;
suppose L341: ( C56 . R3 ) = ( 0. R1 );

L342: C55 = R8 by L341 , L340 , SCMRING2:16;
thus L343: thesis by L342 , TARSKI:def 2;
end;
suppose L344: ( C56 . R3 ) <> ( 0. R1 );

L345: C55 = ( succ R7 ) by L344 , L340 , SCMRING2:16;
thus L346: thesis by L345 , TARSKI:def 2;
end;
end;
theorem
L348: (for B59 being non  trivial Ring holds (for B60 being (Data-Location of B59) holds (for B61 , B62 being (Element of ( NAT )) holds ( NIC (( B60 =0_goto B62 ) , B61) ) = { B62 , ( succ B61 ) })))
proof
let C57 being non  trivial Ring;
let C58 being (Data-Location of C57);
let C59 , C60 being (Element of ( NAT ));
set D36 = the (State of ( SCM C57 ));
set D37 = the (Instruction-Sequence of ( SCM C57 ));
set D38 = ( C58 =0_goto C60 );
reconsider D39 = C58 as (Element of ( Data-Locations ( SCM ) )) by SCMRING2:1;
L349: ( Values C58 ) = ( ( ( SCM-VAL C57 ) * ( SCM-OK ) ) . D39 ) by SCMRING2:24
.= (the carrier of C57) by AMI_3:27 , SCMRING1:4;
reconsider D40 = C59 as (Element of ( Values ( IC ( SCM C57 ) ) )) by MEMSTR_0:def 6;
thus L350: ( NIC (( C58 =0_goto C60 ) , C59) ) c= { C60 , ( succ C59 ) } by L324;
reconsider D41 = ( D36 +* (( IC ( SCM C57 ) ) , D40) ) as (Element of ( product ( the_Values_of ( SCM C57 ) ) )) by CARD_3:107;
reconsider D42 = ( D37 +* (C59 , D38) ) as (Instruction-Sequence of ( SCM C57 ));
let C61 being set;
L351: ( IC ( SCM C57 ) ) <> C58 by L7;
L352: ( IC ( SCM C57 ) ) in ( dom D36 ) by MEMSTR_0:2;
assume L353: C61 in { C60 , ( succ C59 ) };
per cases  by L353 , TARSKI:def 2;
suppose L354: C61 = C60;

reconsider D43 = ( 0. C57 ) as (Element of ( Values C58 )) by L349;
reconsider D44 = ( D41 +* ( C58 .--> D43 ) ) as (Element of ( product ( the_Values_of ( SCM C57 ) ) )) by CARD_3:107;
L355: ( dom ( C58 .--> D43 ) ) = { C58 } by FUNCOP_1:13;
L356: (not ( IC ( SCM C57 ) ) in ( dom ( C58 .--> D43 ) )) by L355 , L351 , TARSKI:def 1;
L357: ( IC D44 ) = ( IC D41 ) by L356 , FUNCT_4:11
.= C59 by L352 , FUNCT_7:31;
L358: ( D42 /. C59 ) = ( D42 . C59 ) by PBOOLE:143;
L359: C59 in ( NAT );
L360: C59 in ( dom D37 ) by L359 , PARTFUN1:def 2;
L361: ( D42 . C59 ) = D38 by L360 , FUNCT_7:31;
L362: C58 in ( dom ( C58 .--> D43 ) ) by L355 , TARSKI:def 1;
L363: ( D44 . C58 ) = ( ( C58 .--> D43 ) . C58 ) by L362 , FUNCT_4:13
.= ( 0. C57 ) by FUNCOP_1:72;
L364: ( IC ( Following (D42 , D44) ) ) = C60 by L363 , L357 , L358 , L361 , SCMRING2:16;
thus L365: thesis by L364 , L354 , L357 , L358 , L361;
end;
suppose L366: C61 = ( succ C59 );

consider C62 being (Element of C57) such that L367: C62 <> ( 0. C57 ) by STRUCT_0:def 18;
reconsider D45 = C62 as (Element of ( Values C58 )) by L349;
reconsider D46 = ( D41 +* ( C58 .--> D45 ) ) as (Element of ( product ( the_Values_of ( SCM C57 ) ) )) by CARD_3:107;
L368: ( dom ( C58 .--> D45 ) ) = { C58 } by FUNCOP_1:13;
L369: (not ( IC ( SCM C57 ) ) in ( dom ( C58 .--> D45 ) )) by L368 , L351 , TARSKI:def 1;
L370: ( IC D46 ) = ( IC D41 ) by L369 , FUNCT_4:11
.= C59 by L352 , FUNCT_7:31;
L371: ( D42 /. C59 ) = ( D42 . C59 ) by PBOOLE:143;
L372: C59 in ( NAT );
L373: C59 in ( dom D37 ) by L372 , PARTFUN1:def 2;
L374: ( D42 . C59 ) = D38 by L373 , FUNCT_7:31;
L375: C58 in ( dom ( C58 .--> D45 ) ) by L368 , TARSKI:def 1;
L376: ( D46 . C58 ) = ( ( C58 .--> D45 ) . C58 ) by L375 , FUNCT_4:13
.= D45 by FUNCOP_1:72;
L377: ( IC ( Following (D42 , D46) ) ) = ( succ C59 ) by L376 , L367 , L370 , L371 , L374 , SCMRING2:16;
thus L378: thesis by L377 , L366 , L370 , L371 , L374;
end;
end;
theorem
L380: (for R1 being Ring holds (for R3 being (Data-Location of R1) holds (for R8 being (Element of ( NAT )) holds ( JUMP ( R3 =0_goto R8 ) ) = { R8 })))
proof
let R1 being Ring;
let R3 being (Data-Location of R1);
let R8 being (Element of ( NAT ));
set D47 = { ( NIC (( R3 =0_goto R8 ) , R7) ) where R7 is (Element of ( NAT )) : (not contradiction) };
L381:
now
let C63 being set;
L382:
now
let C64 being set;
assume L383: C64 in D47;
L384: (ex B63 being (Element of ( NAT )) st C64 = ( NIC (( R3 =0_goto R8 ) , B63) )) by L383;
thus L385: R8 in C64 by L384 , L324;
end;
thus L386:now
reconsider D48 = 1 , D49 = 2 as (Element of ( NAT ));
assume L387: C63 in ( meet D47 );
L388: ( NIC (( R3 =0_goto R8 ) , D49) ) c= { R8 , ( succ D49 ) } by L324;
L389: ( NIC (( R3 =0_goto R8 ) , D49) ) in D47;
L390: C63 in ( NIC (( R3 =0_goto R8 ) , D49) ) by L389 , L387 , SETFAM_1:def 1;
L391: (C63 = R8 or C63 = ( succ D49 )) by L390 , L388 , TARSKI:def 2;
L392: ( NIC (( R3 =0_goto R8 ) , D48) ) c= { R8 , ( succ D48 ) } by L324;
L393: ( NIC (( R3 =0_goto R8 ) , D48) ) in D47;
L394: C63 in ( NIC (( R3 =0_goto R8 ) , D48) ) by L393 , L387 , SETFAM_1:def 1;
L395: (C63 = R8 or C63 = ( succ D48 )) by L394 , L392 , TARSKI:def 2;
thus L396: C63 in { R8 } by L395 , L391 , TARSKI:def 1;
end;
assume L397: C63 in { R8 };
L398: C63 = R8 by L397 , TARSKI:def 1;
L399: ( NIC (( R3 =0_goto R8 ) , R8) ) in D47;
thus L400: C63 in ( meet D47 ) by L399 , L398 , L382 , SETFAM_1:def 1;
end;
thus L401: thesis by L381 , TARSKI:1;
end;
registration
let R1 being Ring;
let R3 being (Data-Location of R1);
let R8 being (Element of ( NAT ));
cluster ( JUMP ( R3 =0_goto R8 ) ) -> 1 -element;
coherence
proof
L402: ( JUMP ( R3 =0_goto R8 ) ) = { R8 } by L380;
thus L403: thesis by L402;
end;
end;
theorem
L405: (for R1 being Ring holds (for R7 being (Element of ( NAT )) holds ( SUCC (R7 , ( SCM R1 )) ) = { R7 , ( succ R7 ) }))
proof
let R1 being Ring;
let R7 being (Element of ( NAT ));
set D50 = { ( ( NIC (B64 , R7) ) \ ( JUMP B64 ) ) where B64 is (Element of (the InstructionsF of ( SCM R1 ))) : (not contradiction) };
set D51 = { R7 , ( succ R7 ) };
L406:
now
let C65 being set;
thus L407:now
assume L408: C65 in ( union D50 );
consider C66 being set such that L409: C65 in C66 and L410: C66 in D50 by L408 , TARSKI:def 4;
consider C67 being (Element of (the InstructionsF of ( SCM R1 ))) such that L411: C66 = ( ( NIC (C67 , R7) ) \ ( JUMP C67 ) ) by L410;
per cases  by SCMRING2:7;
suppose L412: C67 = [ ( 0 ) , ( {} ) , ( {} ) ];

L413: C67 = ( halt ( SCM R1 ) ) by L412;
L414: C65 in ( { R7 } \ ( JUMP ( halt ( SCM R1 ) ) ) ) by L413 , L409 , L411 , AMISTD_1:2;
L415: C65 = R7 by L414 , TARSKI:def 1;
thus L416: C65 in D51 by L415 , TARSKI:def 2;
end;
suppose L417: (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st C67 = ( R3 := R4 )));

consider R3 being (Data-Location of R1), R4 being (Data-Location of R1) such that L418: C67 = ( R3 := R4 ) by L417;
L419: C65 in ( { ( succ R7 ) } \ ( JUMP ( R3 := R4 ) ) ) by L409 , L411 , L418 , AMISTD_1:12;
L420: C65 = ( succ R7 ) by L419 , TARSKI:def 1;
thus L421: C65 in D51 by L420 , TARSKI:def 2;
end;
suppose L422: (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st C67 = ( AddTo (R3 , R4) )));

consider R3 being (Data-Location of R1), R4 being (Data-Location of R1) such that L423: C67 = ( AddTo (R3 , R4) ) by L422;
L424: C65 in ( { ( succ R7 ) } \ ( JUMP ( AddTo (R3 , R4) ) ) ) by L409 , L411 , L423 , AMISTD_1:12;
L425: C65 = ( succ R7 ) by L424 , TARSKI:def 1;
thus L426: C65 in D51 by L425 , TARSKI:def 2;
end;
suppose L427: (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st C67 = ( SubFrom (R3 , R4) )));

consider R3 being (Data-Location of R1), R4 being (Data-Location of R1) such that L428: C67 = ( SubFrom (R3 , R4) ) by L427;
L429: C65 in ( { ( succ R7 ) } \ ( JUMP ( SubFrom (R3 , R4) ) ) ) by L409 , L411 , L428 , AMISTD_1:12;
L430: C65 = ( succ R7 ) by L429 , TARSKI:def 1;
thus L431: C65 in D51 by L430 , TARSKI:def 2;
end;
suppose L432: (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st C67 = ( MultBy (R3 , R4) )));

consider R3 being (Data-Location of R1), R4 being (Data-Location of R1) such that L433: C67 = ( MultBy (R3 , R4) ) by L432;
L434: C65 in ( { ( succ R7 ) } \ ( JUMP ( MultBy (R3 , R4) ) ) ) by L409 , L411 , L433 , AMISTD_1:12;
L435: C65 = ( succ R7 ) by L434 , TARSKI:def 1;
thus L436: C65 in D51 by L435 , TARSKI:def 2;
end;
suppose L437: (ex R8 being (Element of ( NAT )) st C67 = ( goto (R8 , R1) ));

consider R8 being (Element of ( NAT )) such that L438: C67 = ( goto (R8 , R1) ) by L437;
L439: C65 in ( { R8 } \ ( JUMP C67 ) ) by L409 , L411 , L438 , L286;
L440: C65 in ( { R8 } \ { R8 } ) by L439 , L438 , L304;
thus L441: C65 in D51 by L440 , XBOOLE_1:37;
end;
suppose L442: (ex R3 being (Data-Location of R1) st (ex R8 being (Element of ( NAT )) st C67 = ( R3 =0_goto R8 )));

consider R3 being (Data-Location of R1), R8 being (Element of ( NAT )) such that L443: C67 = ( R3 =0_goto R8 ) by L442;
L444: ( NIC (C67 , R7) ) c= { R8 , ( succ R7 ) } by L443 , L324;
L445: C65 in ( NIC (C67 , R7) ) by L409 , L411 , XBOOLE_0:def 5;
L446: (C65 = R8 or C65 = ( succ R7 )) by L445 , L444 , TARSKI:def 2;
L447: C65 in ( ( NIC (C67 , R7) ) \ { R8 } ) by L409 , L411 , L443 , L380;
L448: (not C65 in { R8 }) by L447 , XBOOLE_0:def 5;
thus L449: C65 in D51 by L448 , L446 , TARSKI:def 1 , TARSKI:def 2;
end;
suppose L450: (ex R3 being (Data-Location of R1) st (ex R2 being (Element of R1) st C67 = ( R3 := R2 )));

consider R3 being (Data-Location of R1), R2 being (Element of R1) such that L451: C67 = ( R3 := R2 ) by L450;
L452: C65 in ( { ( succ R7 ) } \ ( JUMP ( R3 := R2 ) ) ) by L409 , L411 , L451 , AMISTD_1:12;
L453: C65 = ( succ R7 ) by L452 , TARSKI:def 1;
thus L454: C65 in D51 by L453 , TARSKI:def 2;
end;
end;
assume L456: C65 in { R7 , ( succ R7 ) };
per cases  by L456 , TARSKI:def 2;
suppose L457: C65 = R7;

set D52 = ( halt ( SCM R1 ) );
L458: ( ( NIC (D52 , R7) ) \ ( JUMP D52 ) ) = { R7 } by AMISTD_1:2;
L459: { R7 } in D50 by L458;
L460: C65 in { R7 } by L457 , TARSKI:def 1;
thus L461: C65 in ( union D50 ) by L460 , L459 , TARSKI:def 4;
end;
suppose L462: C65 = ( succ R7 );

set D53 = the (Data-Location of R1);
set D54 = ( AddTo (D53 , D53) );
L463: ( ( NIC (D54 , R7) ) \ ( JUMP D54 ) ) = { ( succ R7 ) } by AMISTD_1:12;
L464: { ( succ R7 ) } in D50 by L463;
L465: C65 in { ( succ R7 ) } by L462 , TARSKI:def 1;
thus L466: C65 in ( union D50 ) by L465 , L464 , TARSKI:def 4;
end;
end;
thus L468: thesis by L406 , TARSKI:1;
end;
theorem
L469: (for R1 being Ring holds (for B65 being (Element of ( NAT )) holds (( B65 + 1 ) in ( SUCC (B65 , ( SCM R1 )) ) & (for B66 being (Element of ( NAT )) holds (B66 in ( SUCC (B65 , ( SCM R1 )) ) implies B65 <= B66)))))
proof
let R1 being Ring;
let C68 being (Element of ( NAT ));
reconsider D55 = C68 as (Element of ( NAT ));
L470: ( SUCC (C68 , ( SCM R1 )) ) = { C68 , ( succ D55 ) } by L405;
thus L471: ( C68 + 1 ) in ( SUCC (C68 , ( SCM R1 )) ) by L470 , TARSKI:def 2;
let C69 being (Element of ( NAT ));
assume L472: C69 in ( SUCC (C68 , ( SCM R1 )) );
reconsider D56 = C68 as (Element of ( NAT ));
per cases  by L470 , L472 , TARSKI:def 2;
suppose L473: C69 = C68;

thus L474: thesis by L473;
end;
suppose L475: C69 = ( succ D56 );

thus L476: thesis by L475 , NAT_1:11;
end;
end;
registration
let R1 being Ring;
cluster ( SCM R1 ) ->  standard;
coherence
proof
deffunc H1((Element of ( NAT ))) = $1;
L478: (for B67 being (Element of ( NAT )) holds (( B67 + 1 ) in ( SUCC (B67 , ( SCM R1 )) ) & (for B68 being (Element of ( NAT )) holds (B68 in ( SUCC (B67 , ( SCM R1 )) ) implies B67 <= B68)))) by L469;
thus L479: thesis by L478 , AMISTD_1:3;
end;
end;
definition
let C70 being Ring;
let C71 being (Element of ( NAT ));
func dl. (C70 , C71) -> (Data-Location of C70) equals 
( dl. C71 );
coherence
proof
L481: ( dl. C71 ) in ( Data-Locations ( SCM ) ) by AMI_2:def 16 , AMI_3:27;
thus L482: thesis by L481 , SCMRING2:1;
end;
end;
registration
let R1 being Ring;
cluster ( InsCode ( halt ( SCM R1 ) ) ) ->  jump-only for (InsType of (the InstructionsF of ( SCM R1 )));
coherence
proof
L484:
now
let C72 being (State of ( SCM R1 ));
let C73 being (Object of ( SCM R1 ));
let C74 being (Instruction of ( SCM R1 ));
assume that
L485: ( InsCode C74 ) = ( InsCode ( halt ( SCM R1 ) ) )
and
L486: C73 in ( Data-Locations ( SCM R1 ) );
L487: C74 = ( halt ( SCM R1 ) ) by L485 , L26 , COMPOS_1:70;
thus L488: ( ( Exec (C74 , C72) ) . C73 ) = ( C72 . C73 ) by L487 , EXTPRO_1:def 3;
end;
thus L489: thesis by L484 , AMISTD_1:def 1;
end;
end;
registration
let R1 being Ring;
cluster ( halt ( SCM R1 ) ) ->  jump-only;
coherence
proof
thus L491: ( InsCode ( halt ( SCM R1 ) ) ) is  jump-only;
end;
end;
registration
let R1 being Ring;
let R8 being (Element of ( NAT ));
cluster ( InsCode ( goto (R8 , R1) ) ) ->  jump-only for (InsType of (the InstructionsF of ( SCM R1 )));
coherence
proof
set D57 = ( SCM R1 );
L493:
now
let C75 being (State of D57);
let C76 being (Object of D57);
let C77 being (Instruction of D57);
assume that
L494: ( InsCode C77 ) = ( InsCode ( goto (R8 , R1) ) )
and
L495: C76 in ( Data-Locations ( SCM R1 ) );
L496: ( InsCode ( goto (R8 , R1) ) ) = 6 by RECDEF_2:def 1;
L497: (ex R9 being (Element of ( NAT )) st C77 = ( goto (R9 , R1) )) by L496 , L494 , L50;
L498: C76 in ( Data-Locations ( SCM ) ) by L495 , SCMRING2:22;
L499: C76 is (Data-Location of R1) by L498 , SCMRING2:1;
thus L500: ( ( Exec (C77 , C75) ) . C76 ) = ( C75 . C76 ) by L499 , L497 , SCMRING2:15;
end;
thus L501: thesis by L493 , AMISTD_1:def 1;
end;
end;
registration
let R1 being Ring;
let R8 being (Element of ( NAT ));
cluster ( goto (R8 , R1) ) ->  jump-only;
coherence
proof
thus L503: ( InsCode ( goto (R8 , R1) ) ) is  jump-only;
end;
end;
registration
let R1 being Ring;
let R3 being (Data-Location of R1);
let R8 being (Element of ( NAT ));
cluster ( InsCode ( R3 =0_goto R8 ) ) ->  jump-only for (InsType of (the InstructionsF of ( SCM R1 )));
coherence
proof
set D58 = ( SCM R1 );
L505:
now
let C78 being (State of D58);
let C79 being (Object of D58);
let C80 being (Instruction of D58);
assume that
L506: ( InsCode C80 ) = ( InsCode ( R3 =0_goto R8 ) )
and
L507: C79 in ( Data-Locations ( SCM R1 ) );
L508: ( InsCode ( R3 =0_goto R8 ) ) = 7 by RECDEF_2:def 1;
L509: (ex R4 being (Data-Location of R1) st (ex R9 being (Element of ( NAT )) st C80 = ( R4 =0_goto R9 ))) by L508 , L506 , L54;
L510: C79 in ( Data-Locations ( SCM ) ) by L507 , SCMRING2:22;
L511: C79 is (Data-Location of R1) by L510 , SCMRING2:1;
thus L512: ( ( Exec (C80 , C78) ) . C79 ) = ( C78 . C79 ) by L511 , L509 , SCMRING2:16;
end;
thus L513: thesis by L505 , AMISTD_1:def 1;
end;
end;
registration
let R1 being Ring;
let R3 being (Data-Location of R1);
let R8 being (Element of ( NAT ));
cluster ( R3 =0_goto R8 ) ->  jump-only;
coherence
proof
thus L515: ( InsCode ( R3 =0_goto R8 ) ) is  jump-only;
end;
end;
registration
let R16 being non  trivial Ring;
let R17 being (Data-Location of R16);
let R18 being (Data-Location of R16);
cluster ( InsCode ( R17 := R18 ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM R16 )));
coherence
proof
set D59 = the (State of ( SCM R16 ));
consider C81 being (Element of R16) such that L517: C81 <> ( 0. R16 ) by STRUCT_0:def 18;
reconsider D60 = C81 as (Element of R16);
set D61 = ( D59 +* ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D60) ) );
L518: ( dom ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D60) ) ) = { ( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) ) } by FUNCT_4:62;
L519: ( dl. (R16 , 1) ) in ( dom ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D60) ) ) by L518 , TARSKI:def 2;
L520: ( InsCode ( R17 := R18 ) ) = 1 by RECDEF_2:def 1
.= ( InsCode ( ( dl. (R16 , ( 0 )) ) := ( dl. (R16 , 1) ) ) ) by RECDEF_2:def 1;
L521: ( dl. (R16 , ( 0 )) ) in ( Data-Locations ( SCM ) ) by SCMRING2:1;
L522: ( dl. (R16 , ( 0 )) ) in ( Data-Locations ( SCM R16 ) ) by L521 , SCMRING2:22;
L523: ( dl. (R16 , ( 0 )) ) in ( dom ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D60) ) ) by L518 , TARSKI:def 2;
L524: ( D61 . ( dl. (R16 , ( 0 )) ) ) = ( ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D60) ) . ( dl. (R16 , ( 0 )) ) ) by L523 , FUNCT_4:13
.= ( 0. R16 ) by AMI_3:10 , FUNCT_4:63;
L525: ( ( Exec (( ( dl. (R16 , ( 0 )) ) := ( dl. (R16 , 1) ) ) , D61) ) . ( dl. (R16 , ( 0 )) ) ) = ( D61 . ( dl. (R16 , 1) ) ) by SCMRING2:11
.= ( ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D60) ) . ( dl. (R16 , 1) ) ) by L519 , FUNCT_4:13
.= D60 by FUNCT_4:63;
thus L526: thesis by L525 , L517 , L520 , L524 , L522 , AMISTD_1:def 1;
end;
end;
registration
let R16 being non  trivial Ring;
let R17 being (Data-Location of R16);
let R18 being (Data-Location of R16);
cluster ( R17 := R18 ) -> non  jump-only;
coherence
proof
thus L528: (not ( InsCode ( R17 := R18 ) ) is  jump-only);
end;
end;
registration
let R16 being non  trivial Ring;
let R17 being (Data-Location of R16);
let R18 being (Data-Location of R16);
cluster ( InsCode ( AddTo (R17 , R18) ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM R16 )));
coherence
proof
set D62 = the (State of ( SCM R16 ));
consider C82 being (Element of R16) such that L530: C82 <> ( 0. R16 ) by STRUCT_0:def 18;
reconsider D63 = C82 as (Element of R16);
set D64 = ( D62 +* ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D63) ) );
L531: ( dom ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D63) ) ) = { ( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) ) } by FUNCT_4:62;
L532: ( dl. (R16 , ( 0 )) ) in ( dom ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D63) ) ) by L531 , TARSKI:def 2;
L533: ( D64 . ( dl. (R16 , ( 0 )) ) ) = ( ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D63) ) . ( dl. (R16 , ( 0 )) ) ) by L532 , FUNCT_4:13
.= ( 0. R16 ) by AMI_3:10 , FUNCT_4:63;
L534: ( InsCode ( AddTo (R17 , R18) ) ) = 2 by RECDEF_2:def 1
.= ( InsCode ( AddTo (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) ) ) by RECDEF_2:def 1;
L535: ( dl. (R16 , 1) ) in ( dom ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D63) ) ) by L531 , TARSKI:def 2;
L536: ( D64 . ( dl. (R16 , 1) ) ) = ( ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D63) ) . ( dl. (R16 , 1) ) ) by L535 , FUNCT_4:13
.= D63 by FUNCT_4:63;
L537: ( dl. (R16 , ( 0 )) ) in ( Data-Locations ( SCM ) ) by SCMRING2:1;
L538: ( dl. (R16 , ( 0 )) ) in ( Data-Locations ( SCM R16 ) ) by L537 , SCMRING2:22;
L539: ( ( Exec (( AddTo (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) ) , D64) ) . ( dl. (R16 , ( 0 )) ) ) = ( ( D64 . ( dl. (R16 , ( 0 )) ) ) + ( D64 . ( dl. (R16 , 1) ) ) ) by SCMRING2:12
.= D63 by L533 , L536 , RLVECT_1:4;
thus L540: thesis by L539 , L530 , L534 , L533 , L538 , AMISTD_1:def 1;
end;
end;
registration
let R16 being non  trivial Ring;
let R17 being (Data-Location of R16);
let R18 being (Data-Location of R16);
cluster ( AddTo (R17 , R18) ) -> non  jump-only;
coherence
proof
thus L542: (not ( InsCode ( AddTo (R17 , R18) ) ) is  jump-only);
end;
end;
registration
let R16 being non  trivial Ring;
let R17 being (Data-Location of R16);
let R18 being (Data-Location of R16);
cluster ( InsCode ( SubFrom (R17 , R18) ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM R16 )));
coherence
proof
set D65 = the (State of ( SCM R16 ));
consider C83 being (Element of R16) such that L544: C83 <> ( 0. R16 ) by STRUCT_0:def 18;
reconsider D66 = C83 as (Element of R16);
L545:
now
assume L546: ( - D66 ) = ( 0. R16 );
L547: D66 = ( - ( 0. R16 ) ) by L546 , RLVECT_1:17;
thus L548: contradiction by L547 , L544 , RLVECT_1:12;
end;
set D67 = ( D65 +* ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D66) ) );
L549: ( InsCode ( SubFrom (R17 , R18) ) ) = 3 by RECDEF_2:def 1
.= ( InsCode ( SubFrom (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) ) ) by RECDEF_2:def 1;
L550: ( dom ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D66) ) ) = { ( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) ) } by FUNCT_4:62;
L551: ( dl. (R16 , ( 0 )) ) in ( dom ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D66) ) ) by L550 , TARSKI:def 2;
L552: ( D67 . ( dl. (R16 , ( 0 )) ) ) = ( ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D66) ) . ( dl. (R16 , ( 0 )) ) ) by L551 , FUNCT_4:13
.= ( 0. R16 ) by AMI_3:10 , FUNCT_4:63;
L553: ( dl. (R16 , 1) ) in ( dom ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D66) ) ) by L550 , TARSKI:def 2;
L554: ( D67 . ( dl. (R16 , 1) ) ) = ( ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 0. R16 ) , D66) ) . ( dl. (R16 , 1) ) ) by L553 , FUNCT_4:13
.= D66 by FUNCT_4:63;
L555: ( dl. (R16 , ( 0 )) ) in ( Data-Locations ( SCM ) ) by SCMRING2:1;
L556: ( dl. (R16 , ( 0 )) ) in ( Data-Locations ( SCM R16 ) ) by L555 , SCMRING2:22;
L557: ( ( Exec (( SubFrom (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) ) , D67) ) . ( dl. (R16 , ( 0 )) ) ) = ( ( D67 . ( dl. (R16 , ( 0 )) ) ) - ( D67 . ( dl. (R16 , 1) ) ) ) by SCMRING2:13
.= ( - D66 ) by L552 , L554 , RLVECT_1:14;
thus L558: thesis by L557 , L549 , L552 , L545 , L556 , AMISTD_1:def 1;
end;
end;
registration
let R16 being non  trivial Ring;
let R17 being (Data-Location of R16);
let R18 being (Data-Location of R16);
cluster ( SubFrom (R17 , R18) ) -> non  jump-only;
coherence
proof
thus L560: (not ( InsCode ( SubFrom (R17 , R18) ) ) is  jump-only);
end;
end;
registration
let R16 being non  trivial Ring;
let R17 being (Data-Location of R16);
let R18 being (Data-Location of R16);
cluster ( InsCode ( MultBy (R17 , R18) ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM R16 )));
coherence
proof
L562: ( IC ( SCM R16 ) ) = ( IC ( SCM ) ) by AMI_3:1 , SCMRING2:8;
L563: (( 0. R16 ) <> ( 1_ R16 ) & ( dl. (R16 , ( 0 )) ) <> ( IC ( SCM R16 ) )) by L562 , AMI_3:13 , LMOD_6:def 1;
set D68 = the (State of ( SCM R16 ));
set D69 = ( D68 +* ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 1_ R16 ) , ( 0. R16 )) ) );
L564: ( InsCode ( MultBy (R17 , R18) ) ) = 4 by RECDEF_2:def 1
.= ( InsCode ( MultBy (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) ) ) by RECDEF_2:def 1;
L565: ( dom ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 1_ R16 ) , ( 0. R16 )) ) ) = { ( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) ) } by FUNCT_4:62;
L566: ( dl. (R16 , ( 0 )) ) in ( dom ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 1_ R16 ) , ( 0. R16 )) ) ) by L565 , TARSKI:def 2;
L567: ( D69 . ( dl. (R16 , ( 0 )) ) ) = ( ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 1_ R16 ) , ( 0. R16 )) ) . ( dl. (R16 , ( 0 )) ) ) by L566 , FUNCT_4:13
.= ( 1_ R16 ) by AMI_3:10 , FUNCT_4:63;
L568: ( dl. (R16 , 1) ) in ( dom ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 1_ R16 ) , ( 0. R16 )) ) ) by L565 , TARSKI:def 2;
L569: ( D69 . ( dl. (R16 , 1) ) ) = ( ( (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) --> (( 1_ R16 ) , ( 0. R16 )) ) . ( dl. (R16 , 1) ) ) by L568 , FUNCT_4:13
.= ( 0. R16 ) by FUNCT_4:63;
L570: ( dl. (R16 , ( 0 )) ) in ( Data-Locations ( SCM ) ) by SCMRING2:1;
L571: ( dl. (R16 , ( 0 )) ) in ( Data-Locations ( SCM R16 ) ) by L570 , SCMRING2:22;
L572: ( ( Exec (( MultBy (( dl. (R16 , ( 0 )) ) , ( dl. (R16 , 1) )) ) , D69) ) . ( dl. (R16 , ( 0 )) ) ) = ( ( D69 . ( dl. (R16 , ( 0 )) ) ) * ( D69 . ( dl. (R16 , 1) ) ) ) by SCMRING2:14
.= ( 0. R16 ) by L569 , VECTSP_1:6;
thus L573: thesis by L572 , L564 , L563 , L567 , L571 , AMISTD_1:def 1;
end;
end;
registration
let R16 being non  trivial Ring;
let R17 being (Data-Location of R16);
let R18 being (Data-Location of R16);
cluster ( MultBy (R17 , R18) ) -> non  jump-only;
coherence
proof
thus L575: (not ( InsCode ( MultBy (R17 , R18) ) ) is  jump-only);
end;
end;
registration
let R16 being non  trivial Ring;
let R17 being (Data-Location of R16);
let R19 being (Element of R16);
cluster ( InsCode ( R17 := R19 ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM R16 )));
coherence
proof
set D70 = the (State of ( SCM R16 ));
L577: ( InsCode ( R17 := R19 ) ) = 5 by RECDEF_2:def 1
.= ( InsCode ( ( dl. (R16 , ( 0 )) ) := R19 ) ) by RECDEF_2:def 1;
L578: (the carrier of R16) <> { R19 };
consider C84 being set such that L579: C84 in (the carrier of R16) and L580: C84 <> R19 by L578 , ZFMISC_1:35;
L581: ( Values ( dl. (R16 , ( 0 )) ) ) = (the carrier of R16) by L1;
reconsider D71 = C84 as (Element of ( Values ( dl. (R16 , ( 0 )) ) )) by L581 , L579;
reconsider D72 = ( ( dl. (R16 , ( 0 )) ) .--> D71 ) as (PartState of ( SCM R16 ));
set D73 = ( D70 +* D72 );
L582: ( dom ( ( dl. (R16 , ( 0 )) ) .--> D71 ) ) = { ( dl. (R16 , ( 0 )) ) } by FUNCOP_1:13;
L583: ( dl. (R16 , ( 0 )) ) in ( dom ( ( dl. (R16 , ( 0 )) ) .--> D71 ) ) by L582 , TARSKI:def 1;
L584: ( D73 . ( dl. (R16 , ( 0 )) ) ) = ( ( ( dl. (R16 , ( 0 )) ) .--> D71 ) . ( dl. (R16 , ( 0 )) ) ) by L583 , FUNCT_4:13
.= D71 by FUNCOP_1:72;
L585: ( dl. (R16 , ( 0 )) ) in ( Data-Locations ( SCM ) ) by SCMRING2:1;
L586: ( dl. (R16 , ( 0 )) ) in ( Data-Locations ( SCM R16 ) ) by L585 , SCMRING2:22;
L587: ( ( Exec (( ( dl. (R16 , ( 0 )) ) := R19 ) , D73) ) . ( dl. (R16 , ( 0 )) ) ) = R19 by SCMRING2:17;
thus L588: thesis by L587 , L580 , L577 , L584 , L586 , AMISTD_1:def 1;
end;
end;
registration
let R16 being non  trivial Ring;
let R17 being (Data-Location of R16);
let R19 being (Element of R16);
cluster ( R17 := R19 ) -> non  jump-only;
coherence
proof
thus L590: (not ( InsCode ( R17 := R19 ) ) is  jump-only);
end;
end;
registration
let R1 being Ring;
let R8 being (Element of ( NAT ));
cluster ( goto (R8 , R1) ) -> non  sequential;
coherence
proof
L592: ( JUMP ( goto (R8 , R1) ) ) <> ( {} );
thus L593: thesis by L592 , AMISTD_1:13;
end;
end;
registration
let R1 being Ring;
let R3 being (Data-Location of R1);
let R8 being (Element of ( NAT ));
cluster ( R3 =0_goto R8 ) -> non  sequential;
coherence
proof
L595: ( JUMP ( R3 =0_goto R8 ) ) <> ( {} );
thus L596: thesis by L595 , AMISTD_1:13;
end;
end;
registration
let R1 being Ring;
let R8 being (Element of ( NAT ));
cluster ( goto (R8 , R1) ) -> non  ins-loc-free;
coherence
proof
L598: ( dom ( JumpPart ( goto (R8 , R1) ) ) ) = ( dom <* R8 *> ) by RECDEF_2:def 2
.= { 1 } by FINSEQ_1:2 , FINSEQ_1:def 8;
thus L599: (not ( JumpPart ( goto (R8 , R1) ) ) is  empty) by L598;
end;
end;
registration
let R1 being Ring;
let R3 being (Data-Location of R1);
let R8 being (Element of ( NAT ));
cluster ( R3 =0_goto R8 ) -> non  ins-loc-free;
coherence
proof
L601: ( dom ( JumpPart ( R3 =0_goto R8 ) ) ) = ( dom <* R8 *> ) by RECDEF_2:def 2
.= { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
thus L602: (not ( JumpPart ( R3 =0_goto R8 ) ) is  empty) by L601;
end;
end;
registration
let R1 being Ring;
cluster ( SCM R1 ) ->  with_explicit_jumps;
coherence
proof
let C85 being (Instruction of ( SCM R1 ));
thus L604: ( JUMP C85 ) c= ( rng ( JumpPart C85 ) )
proof
let C86 being set;
assume that
L605: C86 in ( JUMP C85 );
per cases  by SCMRING2:7;
suppose L606: C85 = [ ( 0 ) , ( {} ) , ( {} ) ];

L607: ( JUMP ( halt ( SCM R1 ) ) ) is  empty;
thus L608: thesis by L607 , L605 , L606;
end;
suppose L609: (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st C85 = ( R3 := R4 )));

thus L610: thesis by L609 , L605;
end;
suppose L611: (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st C85 = ( AddTo (R3 , R4) )));

thus L612: thesis by L611 , L605;
end;
suppose L613: (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st C85 = ( SubFrom (R3 , R4) )));

thus L614: thesis by L613 , L605;
end;
suppose L615: (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st C85 = ( MultBy (R3 , R4) )));

thus L616: thesis by L615 , L605;
end;
suppose L617: (ex R8 being (Element of ( NAT )) st C85 = ( goto (R8 , R1) ));

consider R8 being (Element of ( NAT )) such that L618: C85 = ( goto (R8 , R1) ) by L617;
L619: ( JumpPart ( goto (R8 , R1) ) ) = <* R8 *> by RECDEF_2:def 2;
L620: ( rng <* R8 *> ) = { R8 } by FINSEQ_1:39;
thus L621: C86 in ( rng ( JumpPart C85 ) ) by L620 , L605 , L618 , L619 , L304;
end;
suppose L622: (ex R3 being (Data-Location of R1) st (ex R8 being (Element of ( NAT )) st C85 = ( R3 =0_goto R8 )));

consider R3 being (Data-Location of R1), R8 being (Element of ( NAT )) such that L623: C85 = ( R3 =0_goto R8 ) by L622;
L624: ( JumpPart ( R3 =0_goto R8 ) ) = <* R8 *> by RECDEF_2:def 2;
L625: ( rng <* R8 *> ) = { R8 } by FINSEQ_1:39;
thus L626: thesis by L625 , L605 , L623 , L624 , L380;
end;
suppose L627: (ex R3 being (Data-Location of R1) st (ex R2 being (Element of R1) st C85 = ( R3 := R2 )));

thus L628: thesis by L627 , L605;
end;
end;

let C87 being set;
assume L630: C87 in ( rng ( JumpPart C85 ) );
consider C88 being set such that L631: C88 in ( dom ( JumpPart C85 ) ) and L632: C87 = ( ( JumpPart C85 ) . C88 ) by L630 , FUNCT_1:def 3;
per cases  by SCMRING2:7;
suppose L633: C85 = [ ( 0 ) , ( {} ) , ( {} ) ];

L634: C85 = ( halt ( SCM R1 ) ) by L633;
thus L635: thesis by L634 , L631;
end;
suppose L636: (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st C85 = ( R3 := R4 )));

consider R3 being (Data-Location of R1), R4 being (Data-Location of R1) such that L637: C85 = ( R3 := R4 ) by L636;
L638: C88 in ( dom ( {} ) ) by L631 , L637 , RECDEF_2:def 2;
thus L639: thesis by L638;
end;
suppose L640: (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st C85 = ( AddTo (R3 , R4) )));

consider R3 being (Data-Location of R1), R4 being (Data-Location of R1) such that L641: C85 = ( AddTo (R3 , R4) ) by L640;
L642: C88 in ( dom ( {} ) ) by L631 , L641 , RECDEF_2:def 2;
thus L643: thesis by L642;
end;
suppose L644: (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st C85 = ( SubFrom (R3 , R4) )));

consider R3 being (Data-Location of R1), R4 being (Data-Location of R1) such that L645: C85 = ( SubFrom (R3 , R4) ) by L644;
L646: C88 in ( dom ( {} ) ) by L631 , L645 , RECDEF_2:def 2;
thus L647: thesis by L646;
end;
suppose L648: (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st C85 = ( MultBy (R3 , R4) )));

consider R3 being (Data-Location of R1), R4 being (Data-Location of R1) such that L649: C85 = ( MultBy (R3 , R4) ) by L648;
L650: C88 in ( dom ( {} ) ) by L631 , L649 , RECDEF_2:def 2;
thus L651: thesis by L650;
end;
suppose L652: (ex R8 being (Element of ( NAT )) st C85 = ( goto (R8 , R1) ));

consider R8 being (Element of ( NAT )) such that L653: C85 = ( goto (R8 , R1) ) by L652;
L654: ( JumpPart C85 ) = <* R8 *> by L653 , RECDEF_2:def 2;
L655: C88 = 1 by L654 , L631 , L58;
L656: C87 = R8 by L655 , L654 , L632 , FINSEQ_1:def 8;
L657: ( JUMP C85 ) = { R8 } by L653 , L304;
thus L658: thesis by L657 , L656 , TARSKI:def 1;
end;
suppose L659: (ex R3 being (Data-Location of R1) st (ex R8 being (Element of ( NAT )) st C85 = ( R3 =0_goto R8 )));

consider R3 being (Data-Location of R1), R8 being (Element of ( NAT )) such that L660: C85 = ( R3 =0_goto R8 ) by L659;
L661: ( JumpPart C85 ) = <* R8 *> by L660 , RECDEF_2:def 2;
L662: C88 = 1 by L661 , L631 , L58;
L663: C87 = R8 by L662 , L661 , L632 , FINSEQ_1:40;
L664: ( JUMP C85 ) = { R8 } by L660 , L380;
thus L665: thesis by L664 , L663 , TARSKI:def 1;
end;
suppose L666: (ex R3 being (Data-Location of R1) st (ex R2 being (Element of R1) st C85 = ( R3 := R2 )));

consider R3 being (Data-Location of R1), R2 being (Element of R1) such that L667: C85 = ( R3 := R2 ) by L666;
L668: C88 in ( dom ( {} ) ) by L631 , L667 , RECDEF_2:def 2;
thus L669: thesis by L668;
end;
end;
end;
theorem
L672: (for R1 being Ring holds (for R8 being (Element of ( NAT )) holds (for R15 being Nat holds ( IncAddr (( goto (R8 , R1) ) , R15) ) = ( goto (( R8 + R15 ) , R1) ))))
proof
let R1 being Ring;
let R8 being (Element of ( NAT ));
let R15 being Nat;
L673: ( JumpPart ( IncAddr (( goto (R8 , R1) ) , R15) ) ) = ( R15 + ( JumpPart ( goto (R8 , R1) ) ) ) by COMPOS_0:def 9;
L674: ( dom ( JumpPart ( IncAddr (( goto (R8 , R1) ) , R15) ) ) ) = ( dom ( JumpPart ( goto (R8 , R1) ) ) ) by L673 , VALUED_1:def 2;
L675: ( dom ( JumpPart ( goto (( R8 + R15 ) , R1) ) ) ) = ( dom <* ( R8 + R15 ) *> ) by RECDEF_2:def 2
.= ( Seg 1 ) by FINSEQ_1:def 8
.= ( dom <* R8 *> ) by FINSEQ_1:def 8
.= ( dom ( JumpPart ( goto (R8 , R1) ) ) ) by RECDEF_2:def 2;
L676: (for B69 being set holds (B69 in ( dom ( JumpPart ( goto (R8 , R1) ) ) ) implies ( ( JumpPart ( IncAddr (( goto (R8 , R1) ) , R15) ) ) . B69 ) = ( ( JumpPart ( goto (( R8 + R15 ) , R1) ) ) . B69 )))
proof
let C89 being set;
assume L677: C89 in ( dom ( JumpPart ( goto (R8 , R1) ) ) );
L678: C89 in ( dom <* R8 *> ) by L677 , RECDEF_2:def 2;
L679: C89 = 1 by L678 , L58;
reconsider D74 = ( ( JumpPart ( goto (R8 , R1) ) ) . C89 ) as (Element of ( NAT )) by ORDINAL1:def 12;
L680: ( ( JumpPart ( IncAddr (( goto (R8 , R1) ) , R15) ) ) . C89 ) = ( R15 + D74 ) by L677 , L673 , L674 , VALUED_1:def 2;
L681: D74 = ( <* R8 *> . C89 ) by RECDEF_2:def 2
.= R8 by L679 , FINSEQ_1:def 8;
thus L682: ( ( JumpPart ( IncAddr (( goto (R8 , R1) ) , R15) ) ) . C89 ) = ( <* ( R8 + R15 ) *> . C89 ) by L681 , L679 , L680 , FINSEQ_1:def 8
.= ( ( JumpPart ( goto (( R8 + R15 ) , R1) ) ) . C89 ) by RECDEF_2:def 2;
end;
L683: ( InsCode ( IncAddr (( goto (R8 , R1) ) , R15) ) ) = ( InsCode ( goto (R8 , R1) ) ) by COMPOS_0:def 9
.= 6 by RECDEF_2:def 1
.= ( InsCode ( goto (( R8 + R15 ) , R1) ) ) by RECDEF_2:def 1;
L684: ( AddressPart ( IncAddr (( goto (R8 , R1) ) , R15) ) ) = ( AddressPart ( goto (R8 , R1) ) ) by COMPOS_0:def 9
.= ( {} ) by RECDEF_2:def 3
.= ( AddressPart ( goto (( R8 + R15 ) , R1) ) ) by RECDEF_2:def 3;
L685: ( JumpPart ( IncAddr (( goto (R8 , R1) ) , R15) ) ) = ( JumpPart ( goto (( R8 + R15 ) , R1) ) ) by L674 , L675 , L676 , FUNCT_1:2;
thus L686: thesis by L685 , L683 , L684 , COMPOS_0:1;
end;
theorem
L687: (for R1 being Ring holds (for R3 being (Data-Location of R1) holds (for R8 being (Element of ( NAT )) holds (for R15 being Nat holds ( IncAddr (( R3 =0_goto R8 ) , R15) ) = ( R3 =0_goto ( R8 + R15 ) )))))
proof
let R1 being Ring;
let R3 being (Data-Location of R1);
let R8 being (Element of ( NAT ));
let R15 being Nat;
L688: ( JumpPart ( IncAddr (( R3 =0_goto R8 ) , R15) ) ) = ( R15 + ( JumpPart ( R3 =0_goto R8 ) ) ) by COMPOS_0:def 9;
L689: ( dom ( JumpPart ( IncAddr (( R3 =0_goto R8 ) , R15) ) ) ) = ( dom ( JumpPart ( R3 =0_goto R8 ) ) ) by L688 , VALUED_1:def 2;
L690: ( dom ( JumpPart ( R3 =0_goto ( R8 + R15 ) ) ) ) = ( dom <* ( R8 + R15 ) *> ) by RECDEF_2:def 2
.= ( Seg 1 ) by FINSEQ_1:38
.= ( dom <* R8 *> ) by FINSEQ_1:38
.= ( dom ( JumpPart ( R3 =0_goto R8 ) ) ) by RECDEF_2:def 2;
L691: (for B70 being set holds (B70 in ( dom ( JumpPart ( R3 =0_goto R8 ) ) ) implies ( ( JumpPart ( IncAddr (( R3 =0_goto R8 ) , R15) ) ) . B70 ) = ( ( JumpPart ( R3 =0_goto ( R8 + R15 ) ) ) . B70 )))
proof
let C90 being set;
assume L692: C90 in ( dom ( JumpPart ( R3 =0_goto R8 ) ) );
L693: C90 in ( dom <* R8 *> ) by L692 , RECDEF_2:def 2;
L694: C90 = 1 by L693 , FINSEQ_1:90;
reconsider D75 = ( ( JumpPart ( R3 =0_goto R8 ) ) . C90 ) as (Element of ( NAT )) by ORDINAL1:def 12;
L695: ( ( JumpPart ( IncAddr (( R3 =0_goto R8 ) , R15) ) ) . C90 ) = ( R15 + D75 ) by L692 , L688 , L689 , VALUED_1:def 2;
L696: D75 = ( <* R8 *> . C90 ) by RECDEF_2:def 2
.= R8 by L694 , FINSEQ_1:40;
thus L697: ( ( JumpPart ( IncAddr (( R3 =0_goto R8 ) , R15) ) ) . C90 ) = ( <* ( R8 + R15 ) *> . C90 ) by L696 , L694 , L695 , FINSEQ_1:40
.= ( ( JumpPart ( R3 =0_goto ( R8 + R15 ) ) ) . C90 ) by RECDEF_2:def 2;
end;
L698: ( InsCode ( IncAddr (( R3 =0_goto R8 ) , R15) ) ) = ( InsCode ( R3 =0_goto R8 ) ) by COMPOS_0:def 9
.= 7 by RECDEF_2:def 1
.= ( InsCode ( R3 =0_goto ( R8 + R15 ) ) ) by RECDEF_2:def 1;
L699: ( AddressPart ( IncAddr (( R3 =0_goto R8 ) , R15) ) ) = ( AddressPart ( R3 =0_goto R8 ) ) by COMPOS_0:def 9
.= <* R3 *> by RECDEF_2:def 3
.= ( AddressPart ( R3 =0_goto ( R8 + R15 ) ) ) by RECDEF_2:def 3;
L700: ( JumpPart ( IncAddr (( R3 =0_goto R8 ) , R15) ) ) = ( JumpPart ( R3 =0_goto ( R8 + R15 ) ) ) by L689 , L690 , L691 , FUNCT_1:2;
thus L701: thesis by L700 , L698 , L699 , COMPOS_0:1;
end;
registration
let R1 being Ring;
cluster ( SCM R1 ) ->  IC-relocable;
coherence
proof
thus L702: ( SCM R1 ) is  IC-relocable
proof
let C91 being (Instruction of ( SCM R1 ));
per cases  by SCMRING2:7;
suppose L703: C91 = [ ( 0 ) , ( {} ) , ( {} ) ];

L704: C91 = ( halt ( SCM R1 ) ) by L703;
thus L705: thesis by L704;
end;
suppose L706: (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st C91 = ( R3 := R4 )));

thus L707: thesis by L706;
end;
suppose L708: (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st C91 = ( AddTo (R3 , R4) )));

thus L709: thesis by L708;
end;
suppose L710: (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st C91 = ( SubFrom (R3 , R4) )));

thus L711: thesis by L710;
end;
suppose L712: (ex R3 being (Data-Location of R1) st (ex R4 being (Data-Location of R1) st C91 = ( MultBy (R3 , R4) )));

thus L713: thesis by L712;
end;
suppose L714: (ex R8 being (Element of ( NAT )) st C91 = ( goto (R8 , R1) ));

let C92 , C93 being Nat;
let C94 being (State of ( SCM R1 ));
set D76 = ( IncIC (C94 , C93) );
consider R8 being (Element of ( NAT )) such that L715: C91 = ( goto (R8 , R1) ) by L714;
thus L716: ( ( IC ( Exec (( IncAddr (C91 , C92) ) , C94) ) ) + C93 ) = ( ( IC ( Exec (( goto (( C92 + R8 ) , R1) ) , C94) ) ) + C93 ) by L715 , L672
.= ( ( C92 + R8 ) + C93 ) by SCMRING2:15
.= ( IC ( Exec (( goto (( ( C92 + R8 ) + C93 ) , R1) ) , D76) ) ) by SCMRING2:15
.= ( IC ( Exec (( goto (( ( C92 + C93 ) + R8 ) , R1) ) , D76) ) )
.= ( IC ( Exec (( IncAddr (C91 , ( C92 + C93 )) ) , D76) ) ) by L715 , L672;
end;
suppose L717: (ex R3 being (Data-Location of R1) st (ex R8 being (Element of ( NAT )) st C91 = ( R3 =0_goto R8 )));

consider R3 being (Data-Location of R1), R8 being (Element of ( NAT )) such that L718: C91 = ( R3 =0_goto R8 ) by L717;
let C95 , C96 being Nat;
let C97 being (State of ( SCM R1 ));
set D77 = ( IncIC (C97 , C96) );
L719: (R3 <> ( IC ( SCM R1 ) ) & ( dom ( ( IC ( SCM R1 ) ) .--> ( ( IC C97 ) + C96 ) ) ) = { ( IC ( SCM R1 ) ) }) by L7 , FUNCOP_1:13;
L720: (not R3 in ( dom ( ( IC ( SCM R1 ) ) .--> ( ( IC C97 ) + C96 ) ) )) by L719 , TARSKI:def 1;
L721: ( C97 . R3 ) = ( D77 . R3 ) by L720 , FUNCT_4:11;
per cases ;
suppose L722: ( C97 . R3 ) = ( 0. R1 );

thus L723: ( ( IC ( Exec (( IncAddr (C91 , C95) ) , C97) ) ) + C96 ) = ( ( IC ( Exec (( R3 =0_goto ( C95 + R8 ) ) , C97) ) ) + C96 ) by L718 , L687
.= ( ( C95 + R8 ) + C96 ) by L722 , SCMRING2:16
.= ( IC ( Exec (( R3 =0_goto ( ( C95 + R8 ) + C96 ) ) , D77) ) ) by L721 , L722 , SCMRING2:16
.= ( IC ( Exec (( R3 =0_goto ( ( C95 + C96 ) + R8 ) ) , D77) ) )
.= ( IC ( Exec (( IncAddr (C91 , ( C95 + C96 )) ) , D77) ) ) by L718 , L687;
end;
suppose L724: ( C97 . R3 ) <> ( 0. R1 );

L725: ( IncAddr (C91 , C95) ) = ( R3 =0_goto ( R8 + C95 ) ) by L718 , L687;
L726: ( IncAddr (C91 , ( C95 + C96 )) ) = ( R3 =0_goto ( R8 + ( C95 + C96 ) ) ) by L718 , L687;
L727: ( dom ( ( IC ( SCM R1 ) ) .--> ( ( IC C97 ) + C96 ) ) ) = { ( IC ( SCM R1 ) ) } by FUNCOP_1:13;
L728: ( IC ( SCM R1 ) ) in ( dom ( ( IC ( SCM R1 ) ) .--> ( ( IC C97 ) + C96 ) ) ) by L727 , TARSKI:def 1;
L729: ( IC D77 ) = ( ( ( IC ( SCM R1 ) ) .--> ( ( IC C97 ) + C96 ) ) . ( IC ( SCM R1 ) ) ) by L728 , FUNCT_4:13
.= ( ( IC C97 ) + C96 ) by FUNCOP_1:72;
thus L730: ( ( IC ( Exec (( IncAddr (C91 , C95) ) , C97) ) ) + C96 ) = ( ( succ ( IC C97 ) ) + C96 ) by L725 , L724 , SCMRING2:16
.= ( ( ( IC C97 ) + 1 ) + C96 )
.= ( succ ( IC D77 ) ) by L729
.= ( IC ( Exec (( IncAddr (C91 , ( C95 + C96 )) ) , D77) ) ) by L726 , L724 , L721 , SCMRING2:16;
end;
end;
suppose L732: (ex R3 being (Data-Location of R1) st (ex R2 being (Element of R1) st C91 = ( R3 := R2 )));

thus L733: thesis by L732;
end;
end;

end;
end;
theorem
L704: (for R1 being Ring holds (for R10 being (Instruction of ( SCM R1 )) holds ( InsCode R10 ) <= 7))
proof
let R1 being Ring;
let R10 being (Instruction of ( SCM R1 ));
set D78 = ( InsCode R10 );
L705: (D78 = ( 0 ) or D78 = 1 or D78 = 2 or D78 = 3 or D78 = 4 or D78 = 5 or D78 = 6 or D78 = 7) by L62;
thus L706: thesis by L705;
end;
