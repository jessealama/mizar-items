:: Insert Sort on SCM+FSA
::  by JingChao Chen
::
:: Received March 13, 1999
:: Copyright (c) 1999-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.
::, SCMFSA6A;

environ

 vocabularies NUMBERS, SCMFSA7B, AMI_1, SCMFSA_2, SCMFSA6A, CARD_1, SF_MASTR,
      AMI_3, EXTPRO_1, RELAT_1, FUNCT_1, FUNCT_4, FUNCOP_1, FINSUB_1, CARD_3,
      SUBSET_1, TARSKI, SCMFSA8B, TURING_1, SCMFSA8A, AMISTD_2, ARYTM_3,
      VALUED_1, XBOOLE_0, FSM_1, SCMFSA_9, SCMFSA6C, SCMFSA6B, CIRCUIT2,
      GRAPHSP, MSUALG_1, SCM_HALT, XXREAL_0, UNIALG_2, NAT_1, SCMFSA8C,
      FINSEQ_1, ARYTM_1, INT_1, COMPLEX1, PARTFUN1, CLASSES1,
      VALUED_0, SCMBSORT, STRUCT_0, SCMISORT, PBOOLE, ORDINAL1, RELOC,
      COMPOS_1, MEMSTR_0, SCMPDS_4;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      FUNCOP_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_4, FUNCT_7,
      FINSEQ_1, CARD_3, VALUED_1, PBOOLE, STRUCT_0, MEMSTR_0, COMPOS_0,
      COMPOS_1,
      EXTPRO_1, AMISTD_2, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C,
      SCMFSA7B, SCMFSA8A, SCMFSA_9, SCMFSA8B, INT_1, SCMBSORT, FINSUB_1,
      SCMFSA8C, CLASSES1, RFINSEQ, SCM_HALT, INT_2, ORDINAL1, NAT_1, XXREAL_0,
      SCMFSA_M;
 constructors DOMAIN_1, SETWISEO, XXREAL_0, REAL_1, SEQ_1, INT_2, MEMSTR_0,
      SCMFSA6A, SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMFSA8C, SCMFSA_9,
      SFMASTR1, SCM_HALT, SCMBSORT, CLASSES1, AMISTD_2, RELSET_1, PRE_POLY,
      PBOOLE, SCMFSA7B, AMISTD_1, SCMFSA_3, FUNCT_4, SCMFSA_1, SF_MASTR,
      SCMFSA_M, FUNCT_7;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, RELSET_1, FUNCOP_1, FINSUB_1,
      NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, STRUCT_0, SCMFSA_2,
      SF_MASTR, SCMFSA8C, SCMFSA6C, SCMFSA8A, SCMFSA_9, SCM_HALT, VALUED_0,
      ORDINAL1, FINSET_1, VALUED_1, FUNCT_2, FUNCT_4, RELAT_1, MEMSTR_0,
      AMISTD_2, SCMFSA10, SCMFSA6A, COMPOS_1, SFMASTR1, EXTPRO_1, PBOOLE,
      FINSEQ_1, AMI_3, COMPOS_0, SCMFSA_M;
 requirements BOOLE, REAL, NUMERALS, SUBSET, ARITHM;
 definitions EXTPRO_1, COMPOS_1, FUNCOP_1, PBOOLE, AMISTD_2, MEMSTR_0,
      SCM_HALT, CARD_3, SCMFSA_2, SCMFSA_M;
 theorems SF_MASTR, FUNCT_1, FUNCT_7, FUNCOP_1, RELAT_1, FUNCT_2, SCMFSA6A,
      FUNCT_4, FINSEQ_3, ENUMSET1, NAT_1, TARSKI, INT_1, GRFUNC_1, RFINSEQ,
      SCMFSA_2, SCMFSA6B, SCMFSA7B, SCMFSA8B, SCMFSA8A, SCMFSA8C, SCMFSA_4,
      SCMFSA6C, SCM_HALT, ABSVALUE, FINSEQ_4, SCMBSORT, SCMFSA_9, SCMFSA9A,
      XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, XXREAL_0, VALUED_1, CLASSES1,
      PBOOLE, PARTFUN1, AFINSQ_1, ZFMISC_1, COMPOS_1, EXTPRO_1,
      AMISTD_2, MEMSTR_0, CARD_3, AMI_2, SCMFSA_M;
 schemes NAT_1;

begin
theorem
L1: (for B1 being (preProgram of ( SCM+FSA )) holds (for B2 being (Element of ( NAT )) holds (for B3 being (Instruction of ( SCM+FSA )) holds ((B2 in ( dom B1 ) & (ex B4 being (Instruction of ( SCM+FSA )) st (B4 = ( B1 . B2 ) & ( UsedIntLoc B4 ) = ( UsedIntLoc B3 )))) implies ( UsedIntLoc B1 ) = ( UsedIntLoc ( B1 +* ( B2 .--> B3 ) ) )))))
proof
let C1 being (preProgram of ( SCM+FSA ));
let C2 being (Element of ( NAT ));
let C3 being (Instruction of ( SCM+FSA ));
set D1 = ( C1 +* ( C2 .--> C3 ) );
assume that
L2: C2 in ( dom C1 )
and
L3: (ex B5 being (Instruction of ( SCM+FSA )) st (B5 = ( C1 . C2 ) & ( UsedIntLoc B5 ) = ( UsedIntLoc C3 )));
consider C4 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L4: (for B6 being (Instruction of ( SCM+FSA )) holds ( C4 . B6 ) = ( UsedIntLoc B6 )) and L5: ( UsedIntLoc C1 ) = ( Union ( C4 * C1 ) ) by SF_MASTR:def 2;
set D2 = ( C4 * C1 );
set D3 = ( C4 * D1 );
consider C5 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L6: (for B7 being (Instruction of ( SCM+FSA )) holds ( C5 . B7 ) = ( UsedIntLoc B7 )) and L7: ( UsedIntLoc D1 ) = ( Union ( C5 * D1 ) ) by SF_MASTR:def 2;
L8: (for B8 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C4 . B8 ) = ( C5 . B8 ))
proof
let C6 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D4 = C6 as (Instruction of ( SCM+FSA ));
thus L9: ( C4 . C6 ) = ( UsedIntLoc D4 ) by L4
.= ( C5 . C6 ) by L6;
end;
L10: C4 = C5 by L8 , FUNCT_2:63;
L11: ( D1 . C2 ) = ( ( C1 +* (C2 , C3) ) . C2 ) by L2 , FUNCT_7:def 3
.= C3 by L2 , FUNCT_7:31;
L12:
now
L13: ( dom C4 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
L14: ( rng C1 ) c= ( dom C4 ) by L13 , RELAT_1:def 19;
L15: ( dom D2 ) = ( dom C1 ) by L14 , RELAT_1:27;
L16: ( dom C1 ) = ( dom D1 ) by L2 , FUNCT_7:112;
L17: ( rng D1 ) c= ( dom C4 ) by L13 , RELAT_1:def 19;
thus L18: ( dom D2 ) = ( dom D3 ) by L17 , L16 , L15 , RELAT_1:27;
let C7 being set;
assume L19: C7 in ( dom D2 );
L20: ( D1 . C7 ) in ( rng D1 ) by L19 , L16 , L15 , FUNCT_1:def 3;
reconsider D5 = ( D1 . C7 ) as (Instruction of ( SCM+FSA )) by L20 , L17 , FUNCT_2:def 1;
per cases ;
suppose L21: C7 <> C2;

L22: (not C7 in { C2 }) by L21 , TARSKI:def 1;
L23: (not C7 in ( dom ( C2 .--> C3 ) )) by L22 , FUNCOP_1:13;
L24: ( C1 . C7 ) = ( D1 . C7 ) by L23 , FUNCT_4:11;
thus L25: ( D2 . C7 ) = ( C4 . D5 ) by L24 , L19 , FUNCT_1:12
.= ( D3 . C7 ) by L16 , L15 , L19 , FUNCT_1:13;
end;
suppose L26: C7 = C2;

thus L27: ( D2 . C7 ) = ( C4 . ( C1 . C7 ) ) by L19 , FUNCT_1:12
.= ( UsedIntLoc D5 ) by L3 , L11 , L4 , L26
.= ( C4 . D5 ) by L6 , L10
.= ( D3 . C7 ) by L16 , L15 , L19 , FUNCT_1:13;
end;
end;
thus L29: thesis by L12 , L5 , L7 , L10 , FUNCT_1:2;
end;
theorem
L30: (for B9 being Int-Location holds (for B10 being (Program of ( SCM+FSA )) holds ( ( if>0 (B9 , ( B10 ";" ( Goto ( 0 ) ) ) , ( Stop ( SCM+FSA ) )) ) . ( ( card B10 ) + 4 ) ) = ( goto ( ( card B10 ) + 4 ) )))
proof
let C8 being Int-Location;
let C9 being (Program of ( SCM+FSA ));
set D6 = ( ( card C9 ) + 4 );
set D7 = D6;
set D8 = ( Goto ( 0 ) );
set D9 = ( Stop ( SCM+FSA ) );
set D10 = ( C9 ";" D8 );
set D11 = ( if>0 (C8 , D10 , D9) );
set D12 = ( C8 >0_goto ( ( card D9 ) + 3 ) );
set D13 = ( ( ( D12 ";" D9 ) ";" ( Goto ( ( card D10 ) + 1 ) ) ) ";" C9 );
set D14 = ( D8 ";" D9 );
L31: D6 < ( ( card C9 ) + 6 ) by XREAL_1:6;
L32: ( card D11 ) = ( ( card C9 ) + 6 ) by SCMFSA_9:2;
L33: D7 in ( dom D11 ) by L32 , L31 , AFINSQ_1:66;
L34: ( ( 0 ) + D6 ) = ( ( 0 ) + D6 );
L35: ( D8 . ( 0 ) ) = ( goto ( 0 ) ) by SCMFSA8A:31;
L36: ( 0 ) in ( dom D8 ) by SCMFSA8A:31;
L37: ( D14 . ( 0 ) ) = ( ( Directed D8 ) . ( 0 ) ) by L36 , SCMFSA8A:14
.= ( goto ( 0 ) ) by L36 , L35 , SCMFSA8A:16;
L38: ( card ( Stop ( SCM+FSA ) ) ) = 1 by COMPOS_1:4;
L39: ( card D14 ) = ( ( card D8 ) + ( card D9 ) ) by SCMFSA6A:21
.= ( 1 + 1 ) by L38 , SCMFSA8A:15
.= 2;
L40: ( 0 ) in ( dom D14 ) by L39 , AFINSQ_1:66;
L41: ( ( 0 ) + D6 ) in { ( B11 + D6 ) where B11 is (Element of ( NAT )) : B11 in ( dom D14 ) } by L40;
L42: D7 in ( dom ( Shift (D14 , D6) ) ) by L41 , VALUED_1:def 12;
L43: ( ( Shift (D14 , D6) ) /. D7 ) = ( ( Shift (D14 , D6) ) . ( ( 0 ) + D6 ) ) by L42 , PARTFUN1:def 6
.= ( goto ( 0 ) ) by L37 , L40 , VALUED_1:def 12;
L44: ( card ( Stop ( SCM+FSA ) ) ) = 1 by COMPOS_1:4;
L45: ( card D13 ) = ( ( card ( ( D12 ";" D9 ) ";" ( Goto ( ( card D10 ) + 1 ) ) ) ) + ( card C9 ) ) by SCMFSA6A:21
.= ( ( ( card ( D12 ";" D9 ) ) + ( card ( Goto ( ( card D10 ) + 1 ) ) ) ) + ( card C9 ) ) by SCMFSA6A:21
.= ( ( ( card ( D12 ";" D9 ) ) + 1 ) + ( card C9 ) ) by SCMFSA8A:15
.= ( ( ( 2 + 1 ) + 1 ) + ( card C9 ) ) by L44 , SCMFSA6A:33
.= D6;
L46: (not D7 in ( dom D13 )) by L45 , AFINSQ_1:66;
L47: ( Reloc (D14 , D6) ) = ( IncAddr (( Shift (D14 , D6) ) , D6) ) by COMPOS_1:34;
L48: ( CutLastLoc ( stop D13 ) ) = D13;
L49: D11 = ( ( ( ( D12 ";" D9 ) ";" ( Goto ( ( card D10 ) + 1 ) ) ) ";" D10 ) ";" D9 ) by SCMFSA8B:def 2
.= ( ( D13 ";" D8 ) ";" D9 ) by SCMFSA6A:25
.= ( D13 ";" D14 ) by SCMFSA6A:25
.= ( ( Directed D13 ) +* ( Reloc (D14 , D6) ) ) by L45 , L48 , SCMFSA6A:def 4;
L50: ( dom D11 ) = ( ( dom ( Directed D13 ) ) \/ ( dom ( Reloc (D14 , D6) ) ) ) by L49 , FUNCT_4:def 1;
L51: ( dom D11 ) = ( ( dom ( Directed (D13 , ( card D13 )) ) ) \/ ( dom ( Reloc (D14 , D6) ) ) ) by L50 , SCMFSA6A:def 2
.= ( ( dom ( D13 +~ (( halt ( SCM+FSA ) ) , ( goto ( card D13 ) )) ) ) \/ ( dom ( Reloc (D14 , D6) ) ) ) by SCMFSA6A:def 1
.= ( ( dom D13 ) \/ ( dom ( Reloc (D14 , D6) ) ) ) by FUNCT_4:99;
L52: D7 in ( dom ( Reloc (D14 , D6) ) ) by L51 , L33 , L46 , XBOOLE_0:def 3;
thus L53: ( D11 . D7 ) = ( ( Reloc (D14 , D6) ) . D7 ) by L52 , L33 , L49 , L50 , FUNCT_4:def 1
.= ( IncAddr (( goto ( 0 ) ) , D6) ) by L42 , L43 , L47 , COMPOS_1:def 21
.= ( goto D6 ) by L34 , SCMFSA_4:1;
end;
theorem
L54: (for B12 being (preProgram of ( SCM+FSA )) holds (for B13 being (Element of ( NAT )) holds (for B14 being (Instruction of ( SCM+FSA )) holds ((B13 in ( dom B12 ) & (ex B15 being (Instruction of ( SCM+FSA )) st (B15 = ( B12 . B13 ) & ( UsedInt*Loc B15 ) = ( UsedInt*Loc B14 )))) implies ( UsedInt*Loc B12 ) = ( UsedInt*Loc ( B12 +* ( B13 .--> B14 ) ) )))))
proof
let C10 being (preProgram of ( SCM+FSA ));
let C11 being (Element of ( NAT ));
let C12 being (Instruction of ( SCM+FSA ));
set D15 = ( C10 +* ( C11 .--> C12 ) );
assume that
L55: C11 in ( dom C10 )
and
L56: (ex B16 being (Instruction of ( SCM+FSA )) st (B16 = ( C10 . C11 ) & ( UsedInt*Loc B16 ) = ( UsedInt*Loc C12 )));
consider C13 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L57: (for B17 being (Instruction of ( SCM+FSA )) holds ( C13 . B17 ) = ( UsedInt*Loc B17 )) and L58: ( UsedInt*Loc C10 ) = ( Union ( C13 * C10 ) ) by SF_MASTR:def 4;
set D16 = ( C13 * C10 );
set D17 = ( C13 * D15 );
consider C14 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L59: (for B18 being (Instruction of ( SCM+FSA )) holds ( C14 . B18 ) = ( UsedInt*Loc B18 )) and L60: ( UsedInt*Loc D15 ) = ( Union ( C14 * D15 ) ) by SF_MASTR:def 4;
L61: (for B19 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C13 . B19 ) = ( C14 . B19 ))
proof
let C15 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D18 = C15 as (Instruction of ( SCM+FSA ));
thus L62: ( C13 . C15 ) = ( UsedInt*Loc D18 ) by L57
.= ( C14 . C15 ) by L59;
end;
L63: C13 = C14 by L61 , FUNCT_2:63;
L64: ( D15 . C11 ) = ( ( C10 +* (C11 , C12) ) . C11 ) by L55 , FUNCT_7:def 3
.= C12 by L55 , FUNCT_7:31;
L65:
now
L66: ( dom C13 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
L67: ( rng C10 ) c= ( dom C13 ) by L66 , RELAT_1:def 19;
L68: ( dom D16 ) = ( dom C10 ) by L67 , RELAT_1:27;
L69: ( dom C10 ) = ( dom D15 ) by L55 , FUNCT_7:112;
L70: ( rng D15 ) c= ( dom C13 ) by L66 , RELAT_1:def 19;
thus L71: ( dom D16 ) = ( dom D17 ) by L70 , L69 , L68 , RELAT_1:27;
let C16 being set;
assume L72: C16 in ( dom D16 );
L73: ( D15 . C16 ) in ( rng D15 ) by L72 , L69 , L68 , FUNCT_1:def 3;
reconsider D19 = ( D15 . C16 ) as (Instruction of ( SCM+FSA )) by L73 , L70 , FUNCT_2:def 1;
per cases ;
suppose L74: C16 <> C11;

L75: (not C16 in { C11 }) by L74 , TARSKI:def 1;
L76: (not C16 in ( dom ( C11 .--> C12 ) )) by L75 , FUNCOP_1:13;
L77: ( C10 . C16 ) = ( D15 . C16 ) by L76 , FUNCT_4:11;
thus L78: ( D16 . C16 ) = ( C13 . D19 ) by L77 , L72 , FUNCT_1:12
.= ( D17 . C16 ) by L69 , L68 , L72 , FUNCT_1:13;
end;
suppose L79: C16 = C11;

thus L80: ( D16 . C16 ) = ( C13 . ( C10 . C16 ) ) by L72 , FUNCT_1:12
.= ( UsedInt*Loc D19 ) by L56 , L64 , L57 , L79
.= ( C13 . D19 ) by L59 , L63
.= ( D17 . C16 ) by L69 , L68 , L72 , FUNCT_1:13;
end;
end;
thus L82: thesis by L65 , L58 , L60 , L63 , FUNCT_1:2;
end;
theorem
L83: (for B20 being (Program of ( SCM+FSA )) holds (for B21 , B22 being Int-Location holds ((not B20 destroy B22) implies (not ( while>0 (B21 , B20) ) destroy B22))))
proof
let C17 being (Program of ( SCM+FSA ));
let C18 , C19 being Int-Location;
set D20 = ( ( ( card C17 ) + 4 ) .--> ( goto ( 0 ) ) );
set D21 = ( Goto ( 0 ) );
set D22 = ( Stop ( SCM+FSA ) );
set D23 = ( if>0 (C18 , ( C17 ";" D21 ) , D22) );
L84: (not D21 destroy C19) by SCMFSA8C:57;
L85: (not D22 destroy C19) by SCMFSA8C:56;
assume L86: (not C17 destroy C19);
L87: (not ( C17 ";" D21 ) destroy C19) by L86 , L84 , SCMFSA8C:52;
L88: (not D23 destroy C19) by L87 , L85 , SCMFSA8C:88;
L89: ( while>0 (C18 , C17) ) = ( D23 +* D20 ) by SCMFSA_9:def 2;
L90: (not D20 destroy C19) by SCMFSA_9:30;
thus L91: thesis by L90 , L88 , L89 , SCMFSA8A:11;
end;
theorem
L92: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B23 being (State of ( SCM+FSA )) holds (for B24 being (Program of ( SCM+FSA )) holds (B24 is_halting_on ( Initialized B23 ) , R8 implies (for B25 being Int-Location holds ( ( IExec (B24 , R8 , B23) ) . B25 ) = ( ( Comput (( R8 +* B24 ) , ( Initialize ( Initialized B23 ) ) , ( LifeSpan (( R8 +* B24 ) , ( Initialize ( Initialized B23 ) )) )) ) . B25 ))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C20 being (State of ( SCM+FSA ));
let C21 being (Program of ( SCM+FSA ));
set D24 = ( Initialized C20 );
set D25 = ( Initialize D24 );
set D26 = ( NAT );
set D27 = ( R8 +* C21 );
assume L93: C21 is_halting_on D24 , R8;
L94: D27 halts_on D25 by L93 , SCMFSA7B:def 7;
thus L95:now
let C22 being Int-Location;
L96: ( Initialized C20 ) = D25 by MEMSTR_0:44;
thus L97: ( ( IExec (C21 , R8 , C20) ) . C22 ) = ( ( Result (D27 , D25) ) . C22 ) by L96 , SCMFSA6B:def 1
.= ( ( Comput (D27 , D25 , ( LifeSpan (D27 , D25) )) ) . C22 ) by L94 , EXTPRO_1:23;
end;
end;
theorem
L96: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (Instruction-Sequence of ( SCM+FSA )) holds (for B26 being (State of ( SCM+FSA )) holds (for B27 being  InitHalting (Program of ( SCM+FSA )) holds ((( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= B26 & B27 c= R9 & B27 c= R10) implies (for B28 being (Element of ( NAT )) holds (( Comput (R9 , B26 , B28) ) = ( Comput (R10 , B26 , B28) ) & ( CurInstr (R9 , ( Comput (R9 , B26 , B28) )) ) = ( CurInstr (R10 , ( Comput (R10 , B26 , B28) )) ))))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (Instruction-Sequence of ( SCM+FSA ));
let C23 being (State of ( SCM+FSA ));
let C24 being  InitHalting (Program of ( SCM+FSA ));
assume that
L97: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= C23
and
L98: C24 c= R9
and
L99: C24 c= R10;
thus L100:now
let C25 being (Element of ( NAT ));
L101: ( IC ( Comput (R9 , C23 , C25) ) ) in ( dom C24 ) by L97 , L98 , SCM_HALT:def 1;
L102: ( IC ( Comput (R10 , C23 , C25) ) ) in ( dom C24 ) by L97 , L99 , SCM_HALT:def 1;
L103: (for B29 being (Element of ( NAT )) holds (B29 < C25 implies ( IC ( Comput (R10 , C23 , B29) ) ) in ( dom C24 ))) by L97 , L99 , SCM_HALT:def 1;
thus L104: ( Comput (R9 , C23 , C25) ) = ( Comput (R10 , C23 , C25) ) by L103 , L98 , L99 , AMISTD_2:10;
L105: ( IC ( Comput (R9 , C23 , C25) ) ) = ( IC ( Comput (R10 , C23 , C25) ) ) by L104;
thus L106: ( CurInstr (R10 , ( Comput (R10 , C23 , C25) )) ) = ( R10 . ( IC ( Comput (R10 , C23 , C25) ) ) ) by PBOOLE:143
.= ( C24 . ( IC ( Comput (R10 , C23 , C25) ) ) ) by L102 , L99 , GRFUNC_1:2
.= ( R9 . ( IC ( Comput (R9 , C23 , C25) ) ) ) by L105 , L101 , L98 , GRFUNC_1:2
.= ( CurInstr (R9 , ( Comput (R9 , C23 , C25) )) ) by PBOOLE:143;
end;
end;
theorem
L101: (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (Instruction-Sequence of ( SCM+FSA )) holds (for B30 being (State of ( SCM+FSA )) holds (for B31 being  InitHalting (Program of ( SCM+FSA )) holds ((( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= B30 & B31 c= R9 & B31 c= R10) implies (( LifeSpan (R9 , B30) ) = ( LifeSpan (R10 , B30) ) & ( Result (R9 , B30) ) = ( Result (R10 , B30) )))))))
proof
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (Instruction-Sequence of ( SCM+FSA ));
let C26 being (State of ( SCM+FSA ));
let C27 being  InitHalting (Program of ( SCM+FSA ));
assume that
L102: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= C26
and
L103: C27 c= R9
and
L104: C27 c= R10;
L105: R10 halts_on C26 by L102 , L104 , SCM_HALT:def 2;
L106: R9 halts_on C26 by L102 , L103 , SCM_HALT:def 2;
L107:
now
let C28 being (Element of ( NAT ));
assume L108: ( CurInstr (R10 , ( Comput (R10 , C26 , C28) )) ) = ( halt ( SCM+FSA ) );
L109: ( CurInstr (R9 , ( Comput (R9 , C26 , C28) )) ) = ( CurInstr (R10 , ( Comput (R10 , C26 , C28) )) ) by L102 , L96 , L103 , L104;
thus L110: ( LifeSpan (R9 , C26) ) <= C28 by L109 , L106 , L108 , EXTPRO_1:def 15;
end;
L111: ( CurInstr (R10 , ( Comput (R10 , C26 , ( LifeSpan (R9 , C26) )) )) ) = ( CurInstr (R9 , ( Comput (R9 , C26 , ( LifeSpan (R9 , C26) )) )) ) by L102 , L96 , L103 , L104
.= ( halt ( SCM+FSA ) ) by L106 , EXTPRO_1:def 15;
thus L112: ( LifeSpan (R9 , C26) ) = ( LifeSpan (R10 , C26) ) by L111 , L107 , L105 , EXTPRO_1:def 15;
L113: R10 halts_on C26 by L102 , L104 , SCM_HALT:def 2;
L114: ( Result (R10 , C26) ) = ( Comput (R10 , C26 , ( LifeSpan (R9 , C26) )) ) by L113 , L112 , EXTPRO_1:23;
L115: R9 halts_on C26 by L102 , L103 , SCM_HALT:def 2;
L116: ( Result (R9 , C26) ) = ( Comput (R9 , C26 , ( LifeSpan (R9 , C26) )) ) by L115 , EXTPRO_1:23;
thus L117: thesis by L116 , L102 , L114 , L96 , L103 , L104;
end;
begin
theorem
L118: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B32 being (State of ( SCM+FSA )) holds (for B33 being (Program of ( SCM+FSA )) holds (for B34 being  read-write Int-Location holds (( B32 . B34 ) <= ( 0 ) implies (( while>0 (B34 , B33) ) is_halting_onInit B32 , R8 & ( while>0 (B34 , B33) ) is_closed_onInit B32 , R8))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C29 being (State of ( SCM+FSA ));
let C30 being (Program of ( SCM+FSA ));
let C31 being  read-write Int-Location;
set D28 = ( Initialized C29 );
assume L119: ( C29 . C31 ) <= ( 0 );
L120: ( D28 . C31 ) <= ( 0 ) by L119 , SCMFSA_M:37;
L121: ( while>0 (C31 , C30) ) is_closed_on D28 , R8 by L120 , SCMFSA_9:38;
L122: ( while>0 (C31 , C30) ) is_halting_on D28 , R8 by L120 , SCMFSA_9:38;
thus L123: thesis by L122 , L121 , SCM_HALT:30 , SCM_HALT:31;
end;
theorem
L124: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B35 being Int-Location holds (for B36 being (Program of ( SCM+FSA )) holds (for B37 being (State of ( SCM+FSA )) holds (for B38 being (Element of ( NAT )) holds ((B36 is_closed_onInit B37 , R8 & B36 is_halting_onInit B37 , R8 & B38 < ( LifeSpan (( R8 +* B36 ) , ( Initialized B37 )) ) & ( IC ( Comput (( R8 +* ( while>0 (B35 , B36) ) ) , ( Initialized B37 ) , ( 1 + B38 )) ) ) = ( ( IC ( Comput (( R8 +* B36 ) , ( Initialized B37 ) , B38) ) ) + 4 ) & ( DataPart ( Comput (( R8 +* ( while>0 (B35 , B36) ) ) , ( Initialized B37 ) , ( 1 + B38 )) ) ) = ( DataPart ( Comput (( R8 +* B36 ) , ( Initialized B37 ) , B38) ) )) implies (( IC ( Comput (( R8 +* ( while>0 (B35 , B36) ) ) , ( Initialized B37 ) , ( ( 1 + B38 ) + 1 )) ) ) = ( ( IC ( Comput (( R8 +* B36 ) , ( Initialized B37 ) , ( B38 + 1 )) ) ) + 4 ) & ( DataPart ( Comput (( R8 +* ( while>0 (B35 , B36) ) ) , ( Initialized B37 ) , ( ( 1 + B38 ) + 1 )) ) ) = ( DataPart ( Comput (( R8 +* B36 ) , ( Initialized B37 ) , ( B38 + 1 )) ) ))))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C32 being Int-Location;
let C33 being (Program of ( SCM+FSA ));
set D29 = ( Data-Locations ( SCM+FSA ) );
let C34 being (State of ( SCM+FSA ));
let C35 being (Element of ( NAT ));
set D30 = ( Initialized C34 );
set D31 = ( R8 +* ( while>0 (C32 , C33) ) );
set D32 = ( R8 +* C33 );
set D33 = ( Initialize D30 );
set D34 = ( Comput (D31 , D30 , ( 1 + C35 )) );
set D35 = ( Comput (D32 , D30 , C35) );
set D36 = ( IC ( Comput (D32 , D30 , C35) ) );
L125: D30 = D33 by MEMSTR_0:44;
assume L126: C33 is_closed_onInit C34 , R8;
L127: C33 is_closed_on D30 , R8 by L126 , SCM_HALT:30;
assume L128: C33 is_halting_onInit C34 , R8;
L129: C33 is_halting_on D30 , R8 by L128 , SCM_HALT:31;
assume L130: C35 < ( LifeSpan (D32 , D30) );
assume L131: ( IC ( Comput (D31 , D30 , ( 1 + C35 )) ) ) = ( D36 + 4 );
assume L132: ( DataPart D34 ) = ( DataPart D35 );
thus L133: ( IC ( Comput (D31 , D30 , ( ( 1 + C35 ) + 1 )) ) ) = ( ( IC ( Comput (D32 , D30 , ( C35 + 1 )) ) ) + 4 ) by L132 , L130 , L131 , L127 , L129 , L125 , SCMFSA_9:39;
thus L134: thesis by L130 , L131 , L132 , L127 , L129 , L125 , SCMFSA_9:39;
end;
theorem
L135: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B39 being Int-Location holds (for B40 being (Program of ( SCM+FSA )) holds (for B41 being (State of ( SCM+FSA )) holds ((B40 is_closed_onInit B41 , R8 & B40 is_halting_onInit B41 , R8 & ( IC ( Comput (( R8 +* ( while>0 (B39 , B40) ) ) , ( Initialized B41 ) , ( 1 + ( LifeSpan (( R8 +* B40 ) , ( Initialized B41 )) ) )) ) ) = ( ( IC ( Comput (( R8 +* B40 ) , ( Initialized B41 ) , ( LifeSpan (( R8 +* B40 ) , ( Initialized B41 )) )) ) ) + 4 )) implies ( CurInstr (( R8 +* ( while>0 (B39 , B40) ) ) , ( Comput (( R8 +* ( while>0 (B39 , B40) ) ) , ( Initialized B41 ) , ( 1 + ( LifeSpan (( R8 +* B40 ) , ( Initialized B41 )) ) )) )) ) = ( goto ( ( card B40 ) + 4 ) ))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C36 being Int-Location;
let C37 being (Program of ( SCM+FSA ));
let C38 being (State of ( SCM+FSA ));
set D37 = ( Initialized C38 );
set D38 = ( Initialized C38 );
set D39 = ( R8 +* ( while>0 (C36 , C37) ) );
set D40 = ( R8 +* C37 );
set D41 = ( Initialize D37 );
L136: D38 = D41 by MEMSTR_0:44;
assume L137: C37 is_closed_onInit C38 , R8;
L138: C37 is_closed_on D37 , R8 by L137 , SCM_HALT:30;
assume L139: C37 is_halting_onInit C38 , R8;
L140: C37 is_halting_on D37 , R8 by L139 , SCM_HALT:31;
assume L141: ( IC ( Comput (D39 , D38 , ( 1 + ( LifeSpan (D40 , D38) ) )) ) ) = ( ( IC ( Comput (D40 , D38 , ( LifeSpan (D40 , D38) )) ) ) + 4 );
thus L142: thesis by L141 , L138 , L140 , L136 , SCMFSA_9:40;
end;
theorem
L143: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B42 being (State of ( SCM+FSA )) holds (for B43 being (Program of ( SCM+FSA )) holds (for B44 being  read-write Int-Location holds ((B43 is_closed_onInit B42 , R8 & B43 is_halting_onInit B42 , R8 & ( B42 . B44 ) > ( 0 )) implies (( IC ( Comput (( R8 +* ( while>0 (B44 , B43) ) ) , ( Initialized B42 ) , ( ( LifeSpan (( R8 +* B43 ) , ( Initialized B42 )) ) + 3 )) ) ) = ( 0 ) & (for B45 being (Element of ( NAT )) holds (B45 <= ( ( LifeSpan (( R8 +* B43 ) , ( Initialized B42 )) ) + 3 ) implies ( IC ( Comput (( R8 +* ( while>0 (B44 , B43) ) ) , ( Initialized B42 ) , B45) ) ) in ( dom ( while>0 (B44 , B43) ) )))))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C39 being (State of ( SCM+FSA ));
let C40 being (Program of ( SCM+FSA ));
let C41 being  read-write Int-Location;
set D42 = ( Initialized C39 );
set D43 = ( Initialized C39 );
set D44 = ( R8 +* ( while>0 (C41 , C40) ) );
set D45 = ( R8 +* C40 );
set D46 = ( Initialize D42 );
L144: D43 = D46 by MEMSTR_0:44;
assume L145: C40 is_closed_onInit C39 , R8;
L146: C40 is_closed_on D42 , R8 by L145 , SCM_HALT:30;
assume L147: C40 is_halting_onInit C39 , R8;
L148: C40 is_halting_on D42 , R8 by L147 , SCM_HALT:31;
assume L149: ( C39 . C41 ) > ( 0 );
L150: ( D42 . C41 ) > ( 0 ) by L149 , SCMFSA_M:37;
thus L151: ( IC ( Comput (D44 , D43 , ( ( LifeSpan (D45 , D43) ) + 3 )) ) ) = ( 0 ) by L150 , L146 , L148 , L144 , SCMFSA_9:42;
thus L152: thesis by L146 , L148 , L150 , L144 , SCMFSA_9:42;
end;
theorem
L153: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B46 being (State of ( SCM+FSA )) holds (for B47 being (Program of ( SCM+FSA )) holds (for B48 being  read-write Int-Location holds ((B47 is_closed_onInit B46 , R8 & B47 is_halting_onInit B46 , R8 & ( B46 . B48 ) > ( 0 )) implies (for B49 being (Element of ( NAT )) holds (B49 <= ( ( LifeSpan (( R8 +* B47 ) , ( Initialized B46 )) ) + 3 ) implies ( IC ( Comput (( R8 +* ( while>0 (B48 , B47) ) ) , ( Initialized B46 ) , B49) ) ) in ( dom ( while>0 (B48 , B47) ) ))))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C42 being (State of ( SCM+FSA ));
let C43 being (Program of ( SCM+FSA ));
let C44 being  read-write Int-Location;
set D47 = ( Initialized C42 );
set D48 = ( Start-At (( 0 ) , ( SCM+FSA )) );
assume L154: C43 is_closed_onInit C42 , R8;
L155: ( Initialize D47 ) = ( Initialize ( Initialized C42 ) )
.= ( Initialize ( Initialized C42 ) )
.= ( Initialized C42 ) by MEMSTR_0:44;
L156: (for B50 being (Element of ( NAT )) holds ( IC ( Comput (( R8 +* C43 ) , ( Initialize D47 ) , B50) ) ) in ( dom C43 )) by L154 , L155 , SCM_HALT:def 4;
L157: C43 is_closed_on D47 , R8 by L156 , SCMFSA7B:def 6;
assume L158: C43 is_halting_onInit C42 , R8;
L159: ( R8 +* C43 ) halts_on ( Initialized C42 ) by L158 , SCM_HALT:def 5;
L160: ( Initialized C42 ) = ( Initialize ( Initialized C42 ) ) by MEMSTR_0:44;
L161: C43 is_halting_on D47 , R8 by L160 , L159 , SCMFSA7B:def 7;
assume L162: ( C42 . C44 ) > ( 0 );
L163: ( D47 . C44 ) > ( 0 ) by L162 , SCMFSA_M:37;
thus L164:now
let C45 being (Element of ( NAT ));
L165: ( Initialized C42 ) = ( Initialize ( Initialized C42 ) ) by MEMSTR_0:44;
assume L166: C45 <= ( ( LifeSpan (( R8 +* C43 ) , ( Initialized C42 )) ) + 3 );
thus L167: ( IC ( Comput (( R8 +* ( while>0 (C44 , C43) ) ) , ( Initialized C42 ) , C45) ) ) in ( dom ( while>0 (C44 , C43) ) ) by L166 , L165 , L157 , L161 , L163 , SCMFSA_9:42;
end;
end;
theorem
L165: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B51 being (State of ( SCM+FSA )) holds (for B52 being (Program of ( SCM+FSA )) holds (for B53 being  read-write Int-Location holds ((B52 is_closed_onInit B51 , R8 & B52 is_halting_onInit B51 , R8 & ( B51 . B53 ) > ( 0 )) implies (( IC ( Comput (( R8 +* ( while>0 (B53 , B52) ) ) , ( Initialized B51 ) , ( ( LifeSpan (( R8 +* B52 ) , ( Initialized B51 )) ) + 3 )) ) ) = ( 0 ) & ( DataPart ( Comput (( R8 +* ( while>0 (B53 , B52) ) ) , ( Initialized B51 ) , ( ( LifeSpan (( R8 +* B52 ) , ( Initialized B51 )) ) + 3 )) ) ) = ( DataPart ( Comput (( R8 +* B52 ) , ( Initialized B51 ) , ( LifeSpan (( R8 +* B52 ) , ( Initialized B51 )) )) ) )))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C46 being (State of ( SCM+FSA ));
let C47 being (Program of ( SCM+FSA ));
let C48 being  read-write Int-Location;
set D49 = ( Data-Locations ( SCM+FSA ) );
set D50 = ( Initialized C46 );
set D51 = ( Initialize D50 );
set D52 = ( R8 +* ( while>0 (C48 , C47) ) );
set D53 = ( R8 +* C47 );
set D54 = ( Comput (D52 , D51 , 1) );
set D55 = ( C48 >0_goto 4 );
L166: ( while>0 (C48 , C47) ) c= D52 by FUNCT_4:25;
defpred S1[ Nat ] means ($1 <= ( LifeSpan (D53 , D51) ) implies (( IC ( Comput (D52 , D51 , ( 1 + $1 )) ) ) = ( ( IC ( Comput (D53 , D51 , $1) ) ) + 4 ) & ( DataPart ( Comput (D52 , D51 , ( 1 + $1 )) ) ) = ( DataPart ( Comput (D53 , D51 , $1) ) )));
set D56 = ( ( card C47 ) + 4 );
set D57 = ( Comput (D52 , D51 , ( ( 1 + ( LifeSpan (D53 , D51) ) ) + 1 )) );
L167: D56 in ( dom ( while>0 (C48 , C47) ) ) by SCMFSA_9:33;
assume L168: C47 is_closed_onInit C46 , R8;
L169: ( Initialize D50 ) = ( Initialize ( Initialized C46 ) )
.= ( Initialize ( Initialized C46 ) )
.= ( Initialized C46 ) by MEMSTR_0:44;
L170: (for B54 being (Element of ( NAT )) holds ( IC ( Comput (( R8 +* C47 ) , ( Initialize D50 ) , B54) ) ) in ( dom C47 )) by L168 , L169 , SCM_HALT:def 4;
L171: C47 is_closed_on D50 , R8 by L170 , SCMFSA7B:def 6;
assume L172: C47 is_halting_onInit C46 , R8;
L173: ( R8 +* C47 ) halts_on ( Initialized C46 ) by L172 , SCM_HALT:def 5;
L174: C47 is_halting_on D50 , R8 by L173 , L169 , SCMFSA7B:def 7;
L175:
now
let C49 being (Element of ( NAT ));
assume L176: S1[ C49 ];
L177:
now
L178: ( C49 + ( 0 ) ) < ( C49 + 1 ) by XREAL_1:6;
assume L179: ( C49 + 1 ) <= ( LifeSpan (D53 , D51) );
L180: C49 < ( LifeSpan (D53 , D51) ) by L179 , L178 , XXREAL_0:2;
thus L181: (( IC ( Comput (D52 , D51 , ( ( 1 + C49 ) + 1 )) ) ) = ( ( IC ( Comput (D53 , D51 , ( C49 + 1 )) ) ) + 4 ) & ( DataPart ( Comput (D52 , D51 , ( ( 1 + C49 ) + 1 )) ) ) = ( DataPart ( Comput (D53 , D51 , ( C49 + 1 )) ) )) by L180 , L171 , L174 , L176 , SCMFSA_9:39;
end;
thus L182: S1[ ( C49 + 1 ) ] by L177;
end;
L183: ( 0 ) in ( dom ( while>0 (C48 , C47) ) ) by SCMFSA_9:10;
L184: ( D52 . ( 0 ) ) = ( ( while>0 (C48 , C47) ) . ( 0 ) ) by L183 , L166 , GRFUNC_1:2
.= D55 by SCMFSA_9:11;
L185: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L186: ( IC D51 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L185 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L187: ( Comput (D52 , D51 , ( ( 0 ) + 1 )) ) = ( Following (D52 , ( Comput (D52 , D51 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D52 , D51) )
.= ( Exec (D55 , D51) ) by L186 , L184 , PBOOLE:143;
L188: (for B55 being FinSeq-Location holds ( D54 . B55 ) = ( D51 . B55 )) by L187 , SCMFSA_2:71;
L189: (for B56 being Int-Location holds ( D54 . B56 ) = ( D51 . B56 )) by L187 , SCMFSA_2:71;
L190: ( DataPart D54 ) = ( DataPart D51 ) by L189 , L188 , SCMFSA_M:2
.= ( DataPart D51 );
set D58 = ( Comput (D52 , D51 , ( ( ( 1 + ( LifeSpan (D53 , D51) ) ) + 1 ) + 1 )) );
set D59 = ( Comput (D52 , D51 , ( 1 + ( LifeSpan (D53 , D51) ) )) );
L191: (not C48 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L192: ( D51 . C48 ) = ( D50 . C48 ) by L191 , FUNCT_4:11;
assume L193: ( C46 . C48 ) > ( 0 );
L194: ( D50 . C48 ) > ( 0 ) by L193 , SCMFSA_M:37;
L195: S1[ ( 0 ) ]
proof
assume L196: ( 0 ) <= ( LifeSpan (D53 , D51) );
L197: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L198: ( IC ( Comput (D53 , D51 , ( 0 )) ) ) = ( IC D51 )
.= ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L197 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
thus L199: thesis by L198 , L194 , L187 , L192 , L190 , SCMFSA_2:71;
end;
L200: (for B57 being (Element of ( NAT )) holds S1[ B57 ]) from NAT_1:sch 1(L195 , L175);
L201: S1[ ( LifeSpan (D53 , D51) ) ] by L200;
L202: D57 = ( Following (D52 , D59) ) by EXTPRO_1:3
.= ( Exec (( goto D56 ) , D59) ) by L171 , L174 , L201 , SCMFSA_9:40;
L203: (for B58 being FinSeq-Location holds ( D57 . B58 ) = ( D59 . B58 )) by L202 , SCMFSA_2:69;
L204: ( D52 . D56 ) = ( ( while>0 (C48 , C47) ) . D56 ) by L167 , L166 , GRFUNC_1:2
.= ( goto ( 0 ) ) by SCMFSA_9:41;
L205: ( D52 /. ( IC D57 ) ) = ( D52 . ( IC D57 ) ) by PBOOLE:143;
L206: D58 = ( Following (D52 , D57) ) by EXTPRO_1:3
.= ( Exec (( goto ( 0 ) ) , D57) ) by L202 , L204 , L205 , SCMFSA_2:69;
L207: (for B59 being FinSeq-Location holds ( D58 . B59 ) = ( D57 . B59 )) by L206 , SCMFSA_2:69;
L208: (for B60 being Int-Location holds ( D57 . B60 ) = ( D59 . B60 )) by L202 , SCMFSA_2:69;
L209: ( DataPart D57 ) = ( DataPart D59 ) by L208 , L203 , SCMFSA_M:2;
L210: ( Initialized C46 ) = ( Initialize ( Initialized C46 ) ) by MEMSTR_0:44;
L211: ( Comput (( R8 +* ( while>0 (C48 , C47) ) ) , ( Initialized C46 ) , ( ( LifeSpan (( R8 +* C47 ) , ( Initialized C46 )) ) + 3 )) ) = D58 by L210;
thus L212: ( IC ( Comput (( R8 +* ( while>0 (C48 , C47) ) ) , ( Initialized C46 ) , ( ( LifeSpan (( R8 +* C47 ) , ( Initialized C46 )) ) + 3 )) ) ) = ( 0 ) by L211 , L206 , SCMFSA_2:69;
L213: D51 = ( Initialized C46 ) by MEMSTR_0:44;
L214: (for B61 being Int-Location holds ( D58 . B61 ) = ( D57 . B61 )) by L206 , SCMFSA_2:69;
thus L215: ( DataPart ( Comput (( R8 +* ( while>0 (C48 , C47) ) ) , ( Initialized C46 ) , ( ( LifeSpan (( R8 +* C47 ) , ( Initialized C46 )) ) + 3 )) ) ) = ( DataPart ( Comput (( R8 +* C47 ) , ( Initialized C46 ) , ( LifeSpan (( R8 +* C47 ) , ( Initialized C46 )) )) ) ) by L214 , L213 , L201 , L209 , L207 , SCMFSA_M:2;
end;
theorem
L216: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B62 being (State of ( SCM+FSA )) holds (for B63 being  InitHalting (Program of ( SCM+FSA )) holds (for B64 being  read-write Int-Location holds (( B62 . B64 ) > ( 0 ) implies (ex B65 being (State of ( SCM+FSA )) st (ex B66 being (Element of ( NAT )) st (B65 = ( Initialized B62 ) & B66 = ( ( LifeSpan (( R8 +* B63 ) , ( Initialized B62 )) ) + 3 ) & ( IC ( Comput (( R8 +* ( while>0 (B64 , B63) ) ) , B65 , B66) ) ) = ( 0 ) & (for B67 being Int-Location holds ( ( Comput (( R8 +* ( while>0 (B64 , B63) ) ) , B65 , B66) ) . B67 ) = ( ( IExec (B63 , R8 , B62) ) . B67 )) & (for B68 being FinSeq-Location holds ( ( Comput (( R8 +* ( while>0 (B64 , B63) ) ) , B65 , B66) ) . B68 ) = ( ( IExec (B63 , R8 , B62) ) . B68 ))))))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C50 being (State of ( SCM+FSA ));
let C51 being  InitHalting (Program of ( SCM+FSA ));
set D60 = ( Data-Locations ( SCM+FSA ) );
let C52 being  read-write Int-Location;
assume L217: ( C50 . C52 ) > ( 0 );
set D61 = ( Initialize ( Initialized C50 ) );
set D62 = ( while>0 (C52 , C51) );
set D63 = ( Initialized C50 );
set D64 = ( R8 +* C51 );
take D63;
set D65 = ( R8 +* D62 );
take D66 = ( ( LifeSpan (D64 , D63) ) + 3 );
thus L218: (D63 = ( Initialized C50 ) & D66 = ( ( LifeSpan (D64 , D63) ) + 3 ));
L219: C51 is_halting_onInit C50 , R8 by SCM_HALT:26;
L220: D64 halts_on D63 by L219 , SCM_HALT:def 5;
L221: ( Initialized C50 ) = ( Initialize ( Initialized C50 ) ) by MEMSTR_0:44
.= ( Initialize ( Initialized C50 ) )
.= ( Initialize ( Initialized C50 ) );
L222: ( R8 +* C51 ) halts_on ( Initialize ( Initialized C50 ) ) by L221 , L220;
L223: C51 is_halting_on ( Initialized C50 ) , R8 by L222 , SCMFSA7B:def 7;
L224: C51 is_closed_onInit C50 , R8 by SCM_HALT:25;
thus L225: ( IC ( Comput (D65 , D63 , D66) ) ) = ( 0 ) by L224 , L217 , L219 , L165;
set D67 = ( Comput (D65 , D63 , D66) );
set D68 = ( Comput (D64 , D63 , ( LifeSpan (D64 , D63) )) );
L226: ( Initialized C50 ) = ( Initialize ( Initialized C50 ) ) by MEMSTR_0:44;
L227: D68 = ( Comput (D64 , D61 , ( LifeSpan (D64 , D61) )) ) by L226;
L228: ( DataPart D67 ) = ( DataPart D68 ) by L217 , L219 , L224 , L165;
thus L229:now
let C53 being Int-Location;
thus L230: ( D67 . C53 ) = ( ( Comput (D64 , D61 , ( LifeSpan (D64 , D61) )) ) . C53 ) by L227 , L228 , SCMFSA_M:2
.= ( ( IExec (C51 , R8 , C50) ) . C53 ) by L223 , L92;
end;
thus L231:now
let C54 being FinSeq-Location;
thus L232: ( D67 . C54 ) = ( ( Comput (D64 , D61 , ( LifeSpan (D64 , D61) )) ) . C54 ) by L227 , L228 , SCMFSA_M:2
.= ( ( IExec (C51 , R8 , C50) ) . C54 ) by L223 , SCMFSA8C:58;
end;
end;
definition
let R1 being (State of ( SCM+FSA ));
let R2 being (Program of ( SCM+FSA ));
let R3 being  read-write Int-Location;
let R8 being (Instruction-Sequence of ( SCM+FSA ));
deffunc H1(Nat , (Element of ( product ( the_Values_of ( SCM+FSA ) ) ))) = ( Comput (( R8 +* ( while>0 (R3 , R2) ) ) , ( Initialized $2 ) , ( ( LifeSpan (( ( R8 +* ( while>0 (R3 , R2) ) ) +* R2 ) , ( Initialized $2 )) ) + 3 )) );
deffunc H2(Nat , (Element of ( product ( the_Values_of ( SCM+FSA ) ) ))) = ( down H1($1 , $2) );
func StepWhile>0 (R3 , R8 , R1 , R2) -> (Function of ( NAT ) , ( product ( the_Values_of ( SCM+FSA ) ) )) means 
:L232: (( it . ( 0 ) ) = R1 & (for B69 being Nat holds ( it . ( B69 + 1 ) ) = ( Comput (( R8 +* ( while>0 (R3 , R2) ) ) , ( Initialized ( it . B69 ) ) , ( ( LifeSpan (( ( R8 +* ( while>0 (R3 , R2) ) ) +* R2 ) , ( Initialized ( it . B69 ) )) ) + 3 )) )));
existence
proof
reconsider D69 = R1 as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
consider C55 being (Function of ( NAT ) , ( product ( the_Values_of ( SCM+FSA ) ) )) such that L233: ( C55 . ( 0 ) ) = D69 and L234: (for B70 being Nat holds ( C55 . ( B70 + 1 ) ) = H2(B70 , ( C55 . B70 ))) from NAT_1:sch 12;
take C55;
thus L235: ( C55 . ( 0 ) ) = R1 by L233;
let C56 being Nat;
L236: ( C55 . ( C56 + 1 ) ) = H2(C56 , ( C55 . C56 )) by L234;
thus L237: thesis by L236;
end;
uniqueness
proof
let C57 , C58 being (Function of ( NAT ) , ( product ( the_Values_of ( SCM+FSA ) ) ));
assume that
L238: ( C57 . ( 0 ) ) = R1
and
L239: (for B71 being Nat holds ( C57 . ( B71 + 1 ) ) = H1(B71 , ( C57 . B71 )))
and
L240: ( C58 . ( 0 ) ) = R1
and
L241: (for B72 being Nat holds ( C58 . ( B72 + 1 ) ) = H1(B72 , ( C58 . B72 )));
reconsider D70 = R1 as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
L242: ( C57 . ( 0 ) ) = D70 by L238;
L243: (for B73 being Nat holds ( C57 . ( B73 + 1 ) ) = H2(B73 , ( C57 . B73 ))) by L239;
L244: ( C58 . ( 0 ) ) = D70 by L240;
L245: (for B74 being Nat holds ( C58 . ( B74 + 1 ) ) = H2(B74 , ( C58 . B74 ))) by L241;
L246: C57 = C58 from NAT_1:sch 16(L242 , L243 , L244 , L245);
thus L247: thesis by L246;
end;
end;
theorem
L249: (for R1 being (State of ( SCM+FSA )) holds (for R2 being (Program of ( SCM+FSA )) holds (for R3 being  read-write Int-Location holds (for R6 being (Element of ( NAT )) holds (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds ( ( StepWhile>0 (R3 , R8 , R1 , R2) ) . ( R6 + 1 ) ) = ( ( StepWhile>0 (R3 , R8 , ( ( StepWhile>0 (R3 , R8 , R1 , R2) ) . R6 ) , R2) ) . 1 ))))))
proof
let R1 being (State of ( SCM+FSA ));
let R2 being (Program of ( SCM+FSA ));
let R3 being  read-write Int-Location;
let R6 being (Element of ( NAT ));
let R8 being (Instruction-Sequence of ( SCM+FSA ));
set D71 = ( ( StepWhile>0 (R3 , R8 , R1 , R2) ) . R6 );
set D72 = ( ( StepWhile>0 (R3 , R8 , D71 , R2) ) . ( 0 ) );
L250: D72 = D71 by L232;
thus L251: ( ( StepWhile>0 (R3 , R8 , R1 , R2) ) . ( R6 + 1 ) ) = ( Comput (( R8 +* ( while>0 (R3 , R2) ) ) , ( Initialized D72 ) , ( ( LifeSpan (( ( R8 +* ( while>0 (R3 , R2) ) ) +* R2 ) , ( Initialized D72 )) ) + 3 )) ) by L250 , L232
.= ( ( StepWhile>0 (R3 , R8 , D71 , R2) ) . ( ( 0 ) + 1 ) ) by L232
.= ( ( StepWhile>0 (R3 , R8 , D71 , R2) ) . 1 );
end;
theorem
L252: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B75 being (Program of ( SCM+FSA )) holds (for B76 being  read-write Int-Location holds (for B77 being (State of ( SCM+FSA )) holds ( ( StepWhile>0 (B76 , R8 , B77 , B75) ) . ( ( 0 ) + 1 ) ) = ( Comput (( R8 +* ( while>0 (B76 , B75) ) ) , ( Initialized B77 ) , ( ( LifeSpan (( ( R8 +* ( while>0 (B76 , B75) ) ) +* B75 ) , ( Initialized B77 )) ) + 3 )) )))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C59 being (Program of ( SCM+FSA ));
let C60 being  read-write Int-Location;
let C61 being (State of ( SCM+FSA ));
L253: ( ( StepWhile>0 (C60 , R8 , C61 , C59) ) . ( 0 ) ) = C61 by L232;
thus L254: ( ( StepWhile>0 (C60 , R8 , C61 , C59) ) . ( ( 0 ) + 1 ) ) = ( Comput (( R8 +* ( while>0 (C60 , C59) ) ) , ( Initialized ( ( StepWhile>0 (C60 , R8 , C61 , C59) ) . ( 0 ) ) ) , ( ( LifeSpan (( ( R8 +* ( while>0 (C60 , C59) ) ) +* C59 ) , ( Initialized ( ( StepWhile>0 (C60 , R8 , C61 , C59) ) . ( 0 ) ) )) ) + 3 )) ) by L232
.= ( Comput (( R8 +* ( while>0 (C60 , C59) ) ) , ( Initialized C61 ) , ( ( LifeSpan (( ( R8 +* ( while>0 (C60 , C59) ) ) +* C59 ) , ( Initialized C61 )) ) + 3 )) ) by L253;
end;
theorem
L255: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B78 being (Program of ( SCM+FSA )) holds (for B79 being  read-write Int-Location holds (for B80 being (State of ( SCM+FSA )) holds (for B81 , B82 being (Element of ( NAT )) holds ((( IC ( ( StepWhile>0 (B79 , R8 , B80 , B78) ) . B81 ) ) = ( 0 ) & ( ( StepWhile>0 (B79 , R8 , B80 , B78) ) . B81 ) = ( Comput (( R8 +* ( while>0 (B79 , B78) ) ) , ( Initialized B80 ) , B82) ) & ( ( ( StepWhile>0 (B79 , R8 , B80 , B78) ) . B81 ) . ( intloc ( 0 ) ) ) = 1) implies (( ( StepWhile>0 (B79 , R8 , B80 , B78) ) . B81 ) = ( Initialized ( ( StepWhile>0 (B79 , R8 , B80 , B78) ) . B81 ) ) & ( ( StepWhile>0 (B79 , R8 , B80 , B78) ) . ( B81 + 1 ) ) = ( Comput (( R8 +* ( while>0 (B79 , B78) ) ) , ( Initialized B80 ) , ( B82 + ( ( LifeSpan (( ( R8 +* ( while>0 (B79 , B78) ) ) +* B78 ) , ( Initialized ( ( StepWhile>0 (B79 , R8 , B80 , B78) ) . B81 ) )) ) + 3 ) )) ))))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C62 being (Program of ( SCM+FSA ));
let C63 being  read-write Int-Location;
let C64 being (State of ( SCM+FSA ));
let C65 , C66 being (Element of ( NAT ));
set D73 = ( Data-Locations ( SCM+FSA ) );
set D74 = ( Initialized C64 );
set D75 = ( R8 +* ( while>0 (C63 , C62) ) );
set D76 = ( ( StepWhile>0 (C63 , R8 , C64 , C62) ) . C65 );
set D77 = ( Initialized D76 );
set D78 = ( Initialize D77 );
set D79 = ( Initialized D76 );
assume L256: ( IC D76 ) = ( 0 );
assume L257: D76 = ( Comput (D75 , D74 , C66) );
assume L258: ( D76 . ( intloc ( 0 ) ) ) = 1;
thus L259: D79 = ( Initialized D76 )
.= D76 by L258 , L256 , SCMFSA_M:8;
thus L260: ( ( StepWhile>0 (C63 , R8 , C64 , C62) ) . ( C65 + 1 ) ) = ( Comput (D75 , D76 , ( ( LifeSpan (( D75 +* C62 ) , ( Initialized D76 )) ) + 3 )) ) by L259 , L232
.= ( Comput (D75 , D74 , ( C66 + ( ( LifeSpan (( D75 +* C62 ) , ( Initialized D76 )) ) + 3 ) )) ) by L257 , EXTPRO_1:4;
end;
theorem
L261: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B83 being (Program of ( SCM+FSA )) holds (for B84 being  read-write Int-Location holds (for B85 being (State of ( SCM+FSA )) holds ((ex B86 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) st (for B87 being (Element of ( NAT )) holds ((( B86 . ( ( StepWhile>0 (B84 , R8 , B85 , B83) ) . B87 ) ) <> ( 0 ) implies (( B86 . ( ( StepWhile>0 (B84 , R8 , B85 , B83) ) . ( B87 + 1 ) ) ) < ( B86 . ( ( StepWhile>0 (B84 , R8 , B85 , B83) ) . B87 ) ) & B83 is_closed_onInit ( ( StepWhile>0 (B84 , R8 , B85 , B83) ) . B87 ) , ( R8 +* ( while>0 (B84 , B83) ) ) & B83 is_halting_onInit ( ( StepWhile>0 (B84 , R8 , B85 , B83) ) . B87 ) , ( R8 +* ( while>0 (B84 , B83) ) ))) & ( ( ( StepWhile>0 (B84 , R8 , B85 , B83) ) . ( B87 + 1 ) ) . ( intloc ( 0 ) ) ) = 1 & (( B86 . ( ( StepWhile>0 (B84 , R8 , B85 , B83) ) . B87 ) ) = ( 0 ) iff ( ( ( StepWhile>0 (B84 , R8 , B85 , B83) ) . B87 ) . B84 ) <= ( 0 ))))) implies (( while>0 (B84 , B83) ) is_halting_onInit B85 , R8 & ( while>0 (B84 , B83) ) is_closed_onInit B85 , R8))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C67 being (Program of ( SCM+FSA ));
let C68 being  read-write Int-Location;
let C69 being (State of ( SCM+FSA ));
set D80 = ( Data-Locations ( SCM+FSA ) );
given C70 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that
L262: (for B88 being (Element of ( NAT )) holds ((( C70 . ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . B88 ) ) <> ( 0 ) implies (( C70 . ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . ( B88 + 1 ) ) ) < ( C70 . ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . B88 ) ) & C67 is_closed_onInit ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . B88 ) , ( R8 +* ( while>0 (C68 , C67) ) ) & C67 is_halting_onInit ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . B88 ) , ( R8 +* ( while>0 (C68 , C67) ) ))) & ( ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . ( B88 + 1 ) ) . ( intloc ( 0 ) ) ) = 1 & (( C70 . ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . B88 ) ) = ( 0 ) iff ( ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . B88 ) . C68 ) <= ( 0 ))));

set D81 = ( Initialized C69 );
set D82 = ( R8 +* ( while>0 (C68 , C67) ) );
L263: ( D82 +* ( while>0 (C68 , C67) ) ) = D82;
deffunc H3(Nat) = ( C70 . ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . $1 ) );
L264: (for B89 being Nat holds (H3(( B89 + 1 )) < H3(B89) or H3(B89) = ( 0 )))
proof
let C71 being Nat;
L265: C71 in ( NAT ) by ORDINAL1:def 12;
thus L266: thesis by L265 , L262;
end;
consider C72 being Nat such that L267: H3(C72) = ( 0 ) and L268: (for B90 being Nat holds (H3(B90) = ( 0 ) implies C72 <= B90)) from NAT_1:sch 17(L264);
reconsider D83 = C72 as (Element of ( NAT )) by ORDINAL1:def 12;
defpred S2[ (Element of ( NAT )) ] means (( $1 + 1 ) <= D83 implies (ex R6 being (Element of ( NAT )) st ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . ( $1 + 1 ) ) = ( Comput (D82 , D81 , R6) )));
L269: S2[ ( 0 ) ]
proof
assume L270: ( ( 0 ) + 1 ) <= D83;
take D84 = ( ( LifeSpan (( ( R8 +* ( while>0 (C68 , C67) ) ) +* C67 ) , ( Initialized C69 )) ) + 3 );
thus L271: thesis by L252;
end;
L272:
now
let C73 being (Element of ( NAT ));
assume L273: C73 < D83;
L274: H3(C73) <> ( 0 ) by L273 , L268;
thus L275: (C67 is_closed_onInit ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . C73 ) , ( R8 +* ( while>0 (C68 , C67) ) ) & C67 is_halting_onInit ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . C73 ) , ( R8 +* ( while>0 (C68 , C67) ) )) by L274 , L262;
end;
L276:
now
let C74 being (Element of ( NAT ));
assume L277: S2[ C74 ];
L278:
now
set D85 = ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . C74 );
set D86 = ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . ( C74 + 1 ) );
assume L279: ( ( C74 + 1 ) + 1 ) <= D83;
L280: ( ( C74 + 1 ) + ( 0 ) ) < ( ( C74 + 1 ) + 1 ) by XREAL_1:6;
consider C75 being (Element of ( NAT )) such that L281: D86 = ( Comput (D82 , D81 , C75) ) by L280 , L277 , L279 , XXREAL_0:2;
L282: ( D86 . ( intloc ( 0 ) ) ) = 1 by L262;
L283: ( C74 + ( 0 ) ) < ( C74 + ( 1 + 1 ) ) by XREAL_1:6;
L284: C74 < D83 by L283 , L279 , XXREAL_0:2;
L285: C67 is_halting_onInit D85 , D82 by L284 , L272;
L286: H3(C74) <> ( 0 ) by L268 , L284;
L287: ( D85 . C68 ) > ( 0 ) by L286 , L262;
take D87 = ( C75 + ( ( LifeSpan (( ( R8 +* ( while>0 (C68 , C67) ) ) +* C67 ) , ( Initialized D86 )) ) + 3 ) );
L288: ( ( R8 +* ( while>0 (C68 , C67) ) ) +* ( while>0 (C68 , C67) ) ) = ( R8 +* ( while>0 (C68 , C67) ) );
L289: D86 = ( Comput (( R8 +* ( while>0 (C68 , C67) ) ) , ( Initialized D85 ) , ( ( LifeSpan (( ( R8 +* ( while>0 (C68 , C67) ) ) +* C67 ) , ( Initialized D85 )) ) + 3 )) ) by L232;
L290: C67 is_closed_onInit D85 , D82 by L272 , L284;
L291: ( IC D86 ) = ( 0 ) by L290 , L289 , L285 , L287 , L143 , L288;
L292: ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . ( ( C74 + 1 ) + 1 ) ) = ( Comput (D82 , ( Initialized C69 ) , ( C75 + ( ( LifeSpan (( ( R8 +* ( while>0 (C68 , C67) ) ) +* C67 ) , ( Initialized ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . ( C74 + 1 ) ) )) ) + 3 ) )) ) by L291 , L281 , L282 , L255;
thus L293: ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . ( ( C74 + 1 ) + 1 ) ) = ( Comput (D82 , D81 , D87) ) by L292;
end;
thus L294: S2[ ( C74 + 1 ) ] by L278;
end;
L295: (for B91 being (Element of ( NAT )) holds S2[ B91 ]) from NAT_1:sch 1(L269 , L276);
per cases ;
suppose L296: D83 = ( 0 );

L297: ( ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . ( 0 ) ) . C68 ) <= ( 0 ) by L296 , L262 , L267;
L298: ( C69 . C68 ) <= ( 0 ) by L297 , L232;
thus L299: thesis by L298 , L118;
end;
suppose L300: D83 <> ( 0 );

consider C76 being Nat such that L301: D83 = ( C76 + 1 ) by L300 , NAT_1:6;
reconsider D88 = C76 as (Element of ( NAT )) by ORDINAL1:def 12;
set D89 = ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . D88 );
set D90 = ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . D83 );
set D91 = ( Initialized D90 );
set D92 = ( Initialize D90 );
L302: D88 < D83 by L301 , XREAL_1:29;
L303: C67 is_closed_onInit D89 , ( R8 +* ( while>0 (C68 , C67) ) ) by L302 , L272;
L304: D88 < D83 by L301 , NAT_1:13;
L305: H3(D88) <> ( 0 ) by L304 , L268;
L306: ( D89 . C68 ) > ( 0 ) by L305 , L262;
L307: C67 is_halting_onInit D89 , ( R8 +* ( while>0 (C68 , C67) ) ) by L272 , L302;
L308: D90 = ( Comput (( R8 +* ( while>0 (C68 , C67) ) ) , ( Initialized D89 ) , ( ( LifeSpan (( ( R8 +* ( while>0 (C68 , C67) ) ) +* C67 ) , ( Initialized D89 )) ) + 3 )) ) by L301 , L232;
L309: ( IC D90 ) = ( 0 ) by L308 , L303 , L307 , L306 , L143 , L263;
L310: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= D90 by L309 , MEMSTR_0:30;
L311: ( ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . ( D88 + 1 ) ) . ( intloc ( 0 ) ) ) = 1 by L262;
L312: D91 = D92 by L311 , L301 , SCMFSA_M:18;
set D93 = ( ( LifeSpan (( ( R8 +* ( while>0 (C68 , C67) ) ) +* C67 ) , ( Initialized C69 )) ) + 3 );
L313: D83 = ( D88 + 1 ) by L301;
consider C77 being (Element of ( NAT )) such that L314: D90 = ( Comput (D82 , D81 , C77) ) by L313 , L295;
L315: D91 = D90 by L312 , L310 , FUNCT_4:98;
L316: ( D90 . C68 ) <= ( 0 ) by L262 , L267;
L317: ( while>0 (C68 , C67) ) is_halting_onInit D90 , ( R8 +* ( while>0 (C68 , C67) ) ) by L316 , L118;
L318: ( R8 +* ( while>0 (C68 , C67) ) ) halts_on D91 by L317 , L263 , SCM_HALT:def 5;
consider C78 being (Element of ( NAT )) such that L319: ( CurInstr (( R8 +* ( while>0 (C68 , C67) ) ) , ( Comput (( R8 +* ( while>0 (C68 , C67) ) ) , D90 , C78) )) ) = ( halt ( SCM+FSA ) ) by L318 , L315 , EXTPRO_1:29;
L320: ( Comput (D82 , D81 , ( C78 + C77 )) ) = ( Comput (D82 , ( Comput (D82 , D81 , C77) ) , C78) ) by EXTPRO_1:4;
L321: D82 halts_on D81 by L314 , L319 , L320 , EXTPRO_1:29;
thus L322: ( while>0 (C68 , C67) ) is_halting_onInit C69 , R8 by L321 , SCM_HALT:def 5;
L323:
now
let C79 being (Element of ( NAT ));
per cases ;
suppose L324: C79 <= D93;

L325: ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . ( 0 ) ) = C69 by L232;
L326: C67 is_halting_onInit C69 , ( R8 +* ( while>0 (C68 , C67) ) ) by L325 , L272 , L300;
L327: H3(( 0 )) <> ( 0 ) by L268 , L300;
L328: ( C69 . C68 ) > ( 0 ) by L327 , L262 , L325;
L329: C67 is_closed_onInit C69 , ( R8 +* ( while>0 (C68 , C67) ) ) by L272 , L300 , L325;
thus L330: ( IC ( Comput (D82 , D81 , C79) ) ) in ( dom ( while>0 (C68 , C67) ) ) by L329 , L324 , L328 , L326 , L143 , L263;
end;
suppose L331: C79 > D93;

L332:
now
take D94 = D93;
thus L333: (( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . 1 ) = ( Comput (D82 , D81 , D94) ) & D94 <= C79) by L331 , L252;
end;
defpred S3[ Nat ] means ($1 <= D83 & $1 <> ( 0 ) & (ex R6 being (Element of ( NAT )) st (( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . $1 ) = ( Comput (D82 , D81 , R6) ) & R6 <= C79)));
L334: (for B92 being Nat holds (S3[ B92 ] implies B92 <= D83));
L335: ( ( 0 ) + 1 ) < ( D83 + 1 ) by L300 , XREAL_1:6;
L336: 1 <= D83 by L335 , NAT_1:13;
L337: (ex B93 being Nat st S3[ B93 ]) by L336 , L332;
consider C80 being Nat such that L338: (S3[ C80 ] & (for B94 being Nat holds (S3[ B94 ] implies B94 <= C80))) from NAT_1:sch 6(L334 , L337);
reconsider D95 = C80 as (Element of ( NAT )) by ORDINAL1:def 12;
L339:
now
per cases ;
suppose L340: D95 = D83;

consider C81 being (Element of ( NAT )) such that L341: D90 = ( Comput (D82 , D81 , C81) ) and L342: C81 <= C79 by L340 , L338;
consider C82 being Nat such that L343: C79 = ( C81 + C82 ) by L342 , NAT_1:10;
L344: ( while>0 (C68 , C67) ) is_closed_onInit D90 , ( R8 +* ( while>0 (C68 , C67) ) ) by L316 , L118;
reconsider D96 = C82 as (Element of ( NAT )) by ORDINAL1:def 12;
L345: ( Comput (D82 , D81 , C79) ) = ( Comput (D82 , D91 , D96) ) by L315 , L341 , L343 , EXTPRO_1:4;
thus L346: ( IC ( Comput (D82 , D81 , C79) ) ) in ( dom ( while>0 (C68 , C67) ) ) by L345 , L344 , L263 , SCM_HALT:def 4;
end;
suppose L347: D95 <> D83;

set D97 = ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . D95 );
L348: D95 < D83 by L338 , L347 , XXREAL_0:1;
L349: C67 is_closed_onInit D97 , ( R8 +* ( while>0 (C68 , C67) ) ) by L348 , L272;
L350: C67 is_halting_onInit D97 , ( R8 +* ( while>0 (C68 , C67) ) ) by L272 , L348;
consider C83 being Nat such that L351: D95 = ( C83 + 1 ) by L338 , NAT_1:6;
reconsider D98 = C83 as (Element of ( NAT )) by ORDINAL1:def 12;
L352: D95 = ( D98 + 1 ) by L351;
L353: ( ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . D95 ) . ( intloc ( 0 ) ) ) = 1 by L352 , L262;
L354: H3(D95) <> ( 0 ) by L268 , L348;
L355: ( D97 . C68 ) > ( 0 ) by L354 , L262;
consider C84 being (Element of ( NAT )) such that L356: ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . D95 ) = ( Comput (D82 , D81 , C84) ) and L357: C84 <= C79 by L338;
set D99 = ( C84 + ( ( LifeSpan (( ( R8 +* ( while>0 (C68 , C67) ) ) +* C67 ) , ( Initialized D97 )) ) + 3 ) );
consider C85 being Nat such that L358: C79 = ( C84 + C85 ) by L357 , NAT_1:10;
set D100 = ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . D98 );
L359: ( D98 + ( 0 ) ) < D95 by L351 , XREAL_1:6;
L360: D98 < D83 by L359 , L338 , XXREAL_0:2;
L361: C67 is_closed_onInit D100 , ( R8 +* ( while>0 (C68 , C67) ) ) by L360 , L272;
L362: H3(D98) <> ( 0 ) by L268 , L360;
L363: ( D100 . C68 ) > ( 0 ) by L362 , L262;
L364: C67 is_halting_onInit D100 , ( R8 +* ( while>0 (C68 , C67) ) ) by L272 , L360;
reconsider D101 = C85 as (Element of ( NAT )) by ORDINAL1:def 12;
L365: D97 = ( Comput (( R8 +* ( while>0 (C68 , C67) ) ) , ( Initialized D100 ) , ( ( LifeSpan (( ( R8 +* ( while>0 (C68 , C67) ) ) +* C67 ) , ( Initialized D100 )) ) + 3 )) ) by L351 , L232;
L366: ( IC D97 ) = ( 0 ) by L365 , L361 , L364 , L363 , L143 , L263;
L367: D97 = ( Initialized D97 ) by L353 , L356 , L366 , L255;
L368:
now
assume L369: D99 <= C79;
L370:
now
take D102 = D99;
thus L371: ( ( StepWhile>0 (C68 , R8 , C69 , C67) ) . ( D95 + 1 ) ) = ( Comput (D82 , D81 , D102) ) by L353 , L356 , L366 , L255;
thus L372: D102 <= C79 by L369;
end;
L373: ( D95 + 1 ) <= D83 by L348 , NAT_1:13;
thus L374: contradiction by L373 , L338 , L370 , XREAL_1:29;
end;
L375: D101 < ( ( LifeSpan (( ( R8 +* ( while>0 (C68 , C67) ) ) +* C67 ) , ( Initialized D97 )) ) + 3 ) by L368 , L358 , XREAL_1:6;
L376: ( Comput (D82 , D81 , C79) ) = ( Comput (( R8 +* ( while>0 (C68 , C67) ) ) , ( Initialized D97 ) , D101) ) by L367 , L356 , L358 , EXTPRO_1:4;
thus L377: ( IC ( Comput (D82 , D81 , C79) ) ) in ( dom ( while>0 (C68 , C67) ) ) by L376 , L375 , L349 , L350 , L355 , L143 , L263;
end;
end;
thus L379: ( IC ( Comput (D82 , D81 , C79) ) ) in ( dom ( while>0 (C68 , C67) ) ) by L339;
end;
end;
thus L381: ( while>0 (C68 , C67) ) is_closed_onInit C69 , R8 by L323 , SCM_HALT:def 4;
end;
end;
theorem
L383: (for B95 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B96 being  read-write Int-Location holds ((for B97 being (State of ( SCM+FSA )) holds (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (( B97 . B96 ) > ( 0 ) implies ( ( IExec (B95 , R8 , B97) ) . B96 ) < ( B97 . B96 )))) implies ( while>0 (B96 , B95) ) is  InitHalting)))
proof
let C86 being  good  InitHalting (Program of ( SCM+FSA ));
let C87 being  read-write Int-Location;
set D103 = ( Data-Locations ( SCM+FSA ) );
defpred S4[ (Element of ( NAT )) ] means (for B98 being (State of ( SCM+FSA )) holds (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds (( B98 . C87 ) <= $1 implies ( while>0 (C87 , C86) ) is_halting_onInit B98 , R11)));
assume L384: (for B99 being (State of ( SCM+FSA )) holds (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (( B99 . C87 ) > ( 0 ) implies ( ( IExec (C86 , R8 , B99) ) . C87 ) < ( B99 . C87 ))));
L385:
now
let C88 being (Element of ( NAT ));
assume L386: S4[ C88 ];
L387:
now
let C89 being (State of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
assume L388: ( C89 . C87 ) <= ( C88 + 1 );
per cases ;
suppose L389: ( C89 . C87 ) <> ( C88 + 1 );

L390: ( C89 . C87 ) < ( C88 + 1 ) by L389 , L388 , XXREAL_0:1;
thus L391: ( while>0 (C87 , C86) ) is_halting_onInit C89 , R11 by L390 , L386 , INT_1:7;
end;
suppose L392: ( C89 . C87 ) = ( C88 + 1 );

set D104 = ( intloc ( 0 ) );
set D105 = ( Initialized C89 );
set D106 = ( R11 +* ( while>0 (C87 , C86) ) );
set D107 = ( Initialized C89 );
set D108 = ( R11 +* C86 );
set D109 = ( Comput (D106 , D105 , ( ( LifeSpan (D108 , D107) ) + 3 )) );
set D110 = ( NAT );
set D111 = ( Comput (D108 , D107 , ( LifeSpan (D108 , D107) )) );
L393: C86 is_halting_onInit C89 , R11 by SCM_HALT:26;
L394: ( R11 +* C86 ) halts_on ( Initialized C89 ) by L393 , SCM_HALT:def 5;
L395: D108 halts_on D107 by L394;
L396: C86 is_closed_onInit C89 , R11 by SCM_HALT:25;
L397: ( DataPart D109 ) = ( DataPart D111 ) by L396 , L392 , L393 , L165;
L398: ( D109 . D104 ) = ( D111 . D104 ) by L397 , SCMFSA_M:2
.= ( ( Result (D108 , D107) ) . D104 ) by L395 , EXTPRO_1:23
.= ( ( Result (D108 , D107) ) . D104 )
.= ( ( IExec (C86 , R11 , C89) ) . D104 ) by SCMFSA6B:def 1
.= 1 by SCM_HALT:9;
L399: ( D109 . C87 ) = ( D111 . C87 ) by L397 , SCMFSA_M:2
.= ( ( Result (D108 , D107) ) . C87 ) by L395 , EXTPRO_1:23
.= ( ( Result (D108 , D107) ) . C87 )
.= ( ( IExec (C86 , R11 , C89) ) . C87 ) by SCMFSA6B:def 1;
L400: ( D109 . C87 ) < ( C88 + 1 ) by L399 , L384 , L392;
L401: ( while>0 (C87 , C86) ) is_halting_onInit D109 , D106 by L400 , L386 , INT_1:7;
L402: ( D106 +* ( while>0 (C87 , C86) ) ) halts_on ( Initialized D109 ) by L401 , SCM_HALT:def 5;
L403: ( D106 +* ( while>0 (C87 , C86) ) ) halts_on ( Initialized D109 ) by L402;
L404: ( IC D109 ) = ( 0 ) by L392 , L396 , L393 , L165;
L405: ( Initialized D109 ) = D109 by L404 , L398 , SCMFSA_M:8;
L406:
now
consider C90 being (Element of ( NAT )) such that L407: ( CurInstr (D106 , ( Comput (D106 , D109 , C90) )) ) = ( halt ( SCM+FSA ) ) by L405 , L403 , EXTPRO_1:29;
take D112 = ( ( ( LifeSpan (D108 , D107) ) + 3 ) + C90 );
thus L408: ( CurInstr (D106 , ( Comput (D106 , D105 , D112) )) ) = ( halt ( SCM+FSA ) ) by L407 , EXTPRO_1:4;
end;
L409: D106 halts_on D105 by L406 , EXTPRO_1:29;
L410: ( R11 +* ( while>0 (C87 , C86) ) ) halts_on ( Initialized C89 ) by L409;
thus L411: ( while>0 (C87 , C86) ) is_halting_onInit C89 , R11 by L410 , SCM_HALT:def 5;
end;
end;
thus L413: S4[ ( C88 + 1 ) ] by L387;
end;
L414: S4[ ( 0 ) ] by L118;
L415: (for B100 being (Element of ( NAT )) holds S4[ B100 ]) from NAT_1:sch 1(L414 , L385);
L416:
now
let C91 being (State of ( SCM+FSA ));
per cases ;
suppose L417: ( C91 . C87 ) <= ( 0 );

thus L418: (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds ( while>0 (C87 , C86) ) is_halting_onInit C91 , R11) by L417 , L118;
end;
suppose L419: ( C91 . C87 ) > ( 0 );

reconsider D113 = ( C91 . C87 ) as (Element of ( NAT )) by L419 , INT_1:3;
L420: S4[ D113 ] by L415;
thus L421: (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds ( while>0 (C87 , C86) ) is_halting_onInit C91 , R11) by L420;
end;
end;
thus L423: thesis by L416 , SCM_HALT:26;
end;
theorem
L424: (for B101 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B102 being  read-write Int-Location holds ((for B103 being (State of ( SCM+FSA )) holds (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (( ( IExec (B101 , R8 , B103) ) . B102 ) < ( B103 . B102 ) or ( ( IExec (B101 , R8 , B103) ) . B102 ) <= ( 0 )))) implies ( while>0 (B102 , B101) ) is  InitHalting)))
proof
let C92 being  good  InitHalting (Program of ( SCM+FSA ));
let C93 being  read-write Int-Location;
assume L425: (for B104 being (State of ( SCM+FSA )) holds (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (( ( IExec (C92 , R8 , B104) ) . C93 ) < ( B104 . C93 ) or ( ( IExec (C92 , R8 , B104) ) . C93 ) <= ( 0 ))));
L426:
now
let C94 being (State of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
assume L427: ( C94 . C93 ) > ( 0 );
per cases  by L425;
suppose L428: ( ( IExec (C92 , R11 , C94) ) . C93 ) < ( C94 . C93 );

thus L429: ( ( IExec (C92 , R11 , C94) ) . C93 ) < ( C94 . C93 ) by L428;
end;
suppose L430: ( ( IExec (C92 , R11 , C94) ) . C93 ) <= ( 0 );

thus L431: ( ( IExec (C92 , R11 , C94) ) . C93 ) < ( C94 . C93 ) by L430 , L427;
end;
end;
thus L433: thesis by L426 , L383;
end;
theorem
L434: (for B105 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B106 being  read-write Int-Location holds ((ex B107 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( INT )) st (for B108 , B109 being (State of ( SCM+FSA )) holds (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds ((( B107 . B108 ) > ( 0 ) implies ( B107 . ( IExec (B105 , R8 , B108) ) ) < ( B107 . B108 )) & (( DataPart B108 ) = ( DataPart B109 ) implies ( B107 . B108 ) = ( B107 . B109 )) & (( B107 . B108 ) <= ( 0 ) iff ( B108 . B106 ) <= ( 0 )))))) implies ( while>0 (B106 , B105) ) is  InitHalting)))
proof
let C95 being  good  InitHalting (Program of ( SCM+FSA ));
let C96 being  read-write Int-Location;
set D114 = ( Data-Locations ( SCM+FSA ) );
given C97 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( INT )) such that
L435: (for B110 , B111 being (State of ( SCM+FSA )) holds (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds ((( C97 . B110 ) > ( 0 ) implies ( C97 . ( IExec (C95 , R8 , B110) ) ) < ( C97 . B110 )) & (( DataPart B110 ) = ( DataPart B111 ) implies ( C97 . B110 ) = ( C97 . B111 )) & (( C97 . B110 ) <= ( 0 ) iff ( B110 . C96 ) <= ( 0 )))));

defpred S5[ (Element of ( NAT )) ] means (for B112 being (State of ( SCM+FSA )) holds (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds (( C97 . B112 ) <= $1 implies ( while>0 (C96 , C95) ) is_halting_onInit B112 , R11)));
L436:
now
let C98 being (Element of ( NAT ));
assume L437: S5[ C98 ];
L438:
now
let C99 being (State of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
assume L439: ( C97 . C99 ) <= ( C98 + 1 );
per cases ;
suppose L440: ( C97 . C99 ) <> ( C98 + 1 );

L441: ( C97 . C99 ) < ( C98 + 1 ) by L440 , L439 , XXREAL_0:1;
thus L442: ( while>0 (C96 , C95) ) is_halting_onInit C99 , R11 by L441 , L437 , INT_1:7;
end;
suppose L443: ( C97 . C99 ) = ( C98 + 1 );

set D115 = ( intloc ( 0 ) );
set D116 = ( Initialized C99 );
set D117 = ( R11 +* ( while>0 (C96 , C95) ) );
set D118 = ( Initialized C99 );
set D119 = ( R11 +* C95 );
set D120 = ( Comput (D117 , D116 , ( ( LifeSpan (D119 , D118) ) + 3 )) );
set D121 = ( Comput (D119 , D118 , ( LifeSpan (D119 , D118) )) );
L444: C95 is_closed_onInit C99 , R11 by SCM_HALT:25;
L445: C95 is_halting_onInit C99 , R11 by SCM_HALT:26;
L446: D119 halts_on D118 by L445 , SCM_HALT:def 5;
L447: (not ( C99 . C96 ) <= ( 0 )) by L435 , L443;
L448: ( DataPart D120 ) = ( DataPart D121 ) by L447 , L444 , L445 , L165;
L449: ( D120 . D115 ) = ( D121 . D115 ) by L448 , SCMFSA_M:2
.= ( ( Result (D119 , D118) ) . D115 ) by L446 , EXTPRO_1:23
.= ( ( Result (D119 , D118) ) . D115 )
.= ( ( IExec (C95 , R11 , C99) ) . D115 ) by SCMFSA6B:def 1
.= 1 by SCM_HALT:9;
L450: ( DataPart D120 ) = ( DataPart ( Result (D119 , D118) ) ) by L448 , L446 , EXTPRO_1:23
.= ( DataPart ( Result (D119 , D118) ) )
.= ( DataPart ( IExec (C95 , R11 , C99) ) ) by SCMFSA6B:def 1;
L451: ( C97 . D120 ) = ( C97 . ( IExec (C95 , R11 , C99) ) ) by L450 , L435;
L452: ( C97 . D120 ) < ( C98 + 1 ) by L451 , L435 , L443;
L453: ( while>0 (C96 , C95) ) is_halting_onInit D120 , D117 by L452 , L437 , INT_1:7;
L454: ( D117 +* ( while>0 (C96 , C95) ) ) halts_on ( Initialized D120 ) by L453 , SCM_HALT:def 5;
L455: ( IC D120 ) = ( 0 ) by L447 , L444 , L445 , L165;
L456: ( Initialized D120 ) = D120 by L455 , L449 , SCMFSA_M:8;
L457:
now
consider C100 being (Element of ( NAT )) such that L458: ( CurInstr (D117 , ( Comput (D117 , D120 , C100) )) ) = ( halt ( SCM+FSA ) ) by L456 , L454 , EXTPRO_1:29;
take D122 = ( ( ( LifeSpan (D119 , D118) ) + 3 ) + C100 );
thus L459: ( CurInstr (D117 , ( Comput (D117 , D116 , D122) )) ) = ( halt ( SCM+FSA ) ) by L458 , EXTPRO_1:4;
end;
L460: D117 halts_on D116 by L457 , EXTPRO_1:29;
thus L461: ( while>0 (C96 , C95) ) is_halting_onInit C99 , R11 by L460 , SCM_HALT:def 5;
end;
end;
thus L463: S5[ ( C98 + 1 ) ] by L438;
end;
L464: S5[ ( 0 ) ]
proof
let C101 being (State of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
assume L465: ( C97 . C101 ) <= ( 0 );
L466: ( C101 . C96 ) <= ( 0 ) by L465 , L435;
thus L467: thesis by L466 , L118;
end;
L468: (for B113 being (Element of ( NAT )) holds S5[ B113 ]) from NAT_1:sch 1(L464 , L436);
L469:
now
let C102 being (State of ( SCM+FSA ));
per cases ;
suppose L470: ( C97 . C102 ) <= ( 0 );

L471: ( C102 . C96 ) <= ( 0 ) by L470 , L435;
thus L472: (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds ( while>0 (C96 , C95) ) is_halting_onInit C102 , R11) by L471 , L118;
end;
suppose L473: ( C97 . C102 ) > ( 0 );

reconsider D123 = ( C97 . C102 ) as (Element of ( NAT )) by L473 , INT_1:3;
L474: S5[ D123 ] by L468;
thus L475: (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds ( while>0 (C96 , C95) ) is_halting_onInit C102 , R11) by L474;
end;
end;
thus L477: thesis by L469 , SCM_HALT:26;
end;
theorem
L478: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B114 being (State of ( SCM+FSA )) holds (for B115 being (Program of ( SCM+FSA )) holds (for B116 being  read-write Int-Location holds (( B114 . B116 ) <= ( 0 ) implies ( DataPart ( IExec (( while>0 (B116 , B115) ) , R8 , B114) ) ) = ( DataPart ( Initialized B114 ) ))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C103 being (State of ( SCM+FSA ));
let C104 being (Program of ( SCM+FSA ));
let C105 being  read-write Int-Location;
set D124 = ( Data-Locations ( SCM+FSA ) );
set D125 = ( Initialized C103 );
set D126 = ( Initialize D125 );
set D127 = ( R8 +* ( while>0 (C105 , C104) ) );
L479: ( while>0 (C105 , C104) ) c= D127 by FUNCT_4:25;
set D128 = ( Comput (D127 , D126 , 1) );
set D129 = ( Comput (D127 , D126 , 2) );
set D130 = ( Comput (D127 , D126 , 3) );
set D131 = ( Comput (D127 , D126 , 4) );
set D132 = ( C105 >0_goto 4 );
L480: 1 in ( dom ( while>0 (C105 , C104) ) ) by SCMFSA_9:10;
L481: ( D127 . 1 ) = ( ( while>0 (C105 , C104) ) . 1 ) by L480 , L479 , GRFUNC_1:2
.= ( goto 2 ) by SCMFSA_9:11;
L482: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
L483: ( IC D126 ) = ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by L482 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L484: ( 0 ) in ( dom ( while>0 (C105 , C104) ) ) by SCMFSA_9:10;
L485: ( D127 . ( 0 ) ) = ( ( while>0 (C105 , C104) ) . ( 0 ) ) by L484 , L479 , GRFUNC_1:2
.= D132 by SCMFSA_9:11;
L486: ( CurInstr (D127 , D126) ) = D132 by L485 , L483 , PBOOLE:143;
L487: ( Comput (D127 , D126 , ( ( 0 ) + 1 )) ) = ( Following (D127 , ( Comput (D127 , D126 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D127 , D126) )
.= ( Exec (D132 , D126) ) by L483 , L485 , PBOOLE:143;
set D133 = ( ( card C104 ) + 5 );
L488: 2 in ( dom ( while>0 (C105 , C104) ) ) by SCMFSA_9:32;
L489: ( D127 . 2 ) = ( ( while>0 (C105 , C104) ) . 2 ) by L488 , L479 , GRFUNC_1:2
.= ( goto 3 ) by SCMFSA_9:36;
L490: D133 in ( dom ( while>0 (C105 , C104) ) ) by SCMFSA_9:33;
L491: (not C105 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L492: ( D126 . C105 ) = ( D125 . C105 ) by L491 , FUNCT_4:11;
L493: 3 in ( dom ( while>0 (C105 , C104) ) ) by SCMFSA_9:32;
assume L494: ( C103 . C105 ) <= ( 0 );
L495: ( D125 . C105 ) <= ( 0 ) by L494 , SCMFSA_M:37;
L496: ( IC ( Comput (D127 , D126 , 1) ) ) = ( succ ( 0 ) ) by L495 , L483 , L487 , L492 , SCMFSA_2:71
.= ( ( 0 ) + 1 );
L497: ( Comput (D127 , D126 , ( 1 + 1 )) ) = ( Following (D127 , D128) ) by EXTPRO_1:3
.= ( Exec (( goto 2 ) , D128) ) by L496 , L481 , PBOOLE:143;
L498: ( IC D129 ) = 2 by L497 , SCMFSA_2:69;
L499: ( D127 /. ( IC D129 ) ) = ( D127 . ( IC D129 ) ) by PBOOLE:143;
L500: ( Comput (D127 , D126 , ( 2 + 1 )) ) = ( Following (D127 , D129) ) by EXTPRO_1:3
.= ( Exec (( goto 3 ) , D129) ) by L497 , L489 , L499 , SCMFSA_2:69;
L501: ( D127 . 3 ) = ( ( while>0 (C105 , C104) ) . 3 ) by L493 , L479 , GRFUNC_1:2
.= ( goto D133 ) by SCMFSA_9:35;
L502: ( D127 /. ( IC D130 ) ) = ( D127 . ( IC D130 ) ) by PBOOLE:143;
L503: ( Comput (D127 , D126 , ( 3 + 1 )) ) = ( Following (D127 , D130) ) by EXTPRO_1:3
.= ( Exec (( goto D133 ) , D130) ) by L500 , L501 , L502 , SCMFSA_2:69;
L504: ( D127 /. ( IC D131 ) ) = ( D127 . ( IC D131 ) ) by PBOOLE:143;
L505: ( D127 . D133 ) = ( ( while>0 (C105 , C104) ) . D133 ) by L490 , L479 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by SCMFSA_9:34;
L506: ( CurInstr (D127 , D131) ) = ( halt ( SCM+FSA ) ) by L505 , L503 , L504 , SCMFSA_2:69;
L507: D127 halts_on D126 by L506 , EXTPRO_1:29;
L508: ( D127 /. ( IC D130 ) ) = ( D127 . ( IC D130 ) ) by PBOOLE:143;
L509: ( CurInstr (D127 , D130) ) = ( goto D133 ) by L500 , L501 , L508 , SCMFSA_2:69;
L510:
now
let C106 being (Element of ( NAT ));
assume L511: ( CurInstr (D127 , ( Comput (D127 , D126 , C106) )) ) = ( halt ( SCM+FSA ) );
L512: C106 <> 2 by L511 , L498 , L489 , PBOOLE:143;
L513: C106 <> ( 0 ) by L511 , L486 , EXTPRO_1:2;
L514: C106 <> 1 by L496 , L481 , L511 , PBOOLE:143;
L515: 3 < C106 by L513 , L512 , L514 , L509 , L511 , NAT_1:27;
thus L516: ( 3 + 1 ) <= C106 by L515 , INT_1:7;
end;
L517: ( LifeSpan (D127 , D126) ) = 4 by L510 , L506 , L507 , EXTPRO_1:def 15;
L518: ( Initialized D125 ) = ( Initialize ( Initialized D125 ) ) by MEMSTR_0:44
.= D126;
L519: D126 = D125 by L518;
L520:
now
let C107 being Int-Location;
thus L521: ( D125 . C107 ) = ( D128 . C107 ) by L487 , L519 , SCMFSA_2:71
.= ( D129 . C107 ) by L497 , SCMFSA_2:69
.= ( D130 . C107 ) by L500 , SCMFSA_2:69
.= ( D131 . C107 ) by L503 , SCMFSA_2:69;
end;
L522:
now
let C108 being FinSeq-Location;
thus L523: ( D125 . C108 ) = ( D128 . C108 ) by L487 , L519 , SCMFSA_2:71
.= ( D129 . C108 ) by L497 , SCMFSA_2:69
.= ( D130 . C108 ) by L500 , SCMFSA_2:69
.= ( D131 . C108 ) by L503 , SCMFSA_2:69;
end;
thus L524: ( DataPart ( IExec (( while>0 (C105 , C104) ) , R8 , C103) ) ) = ( DataPart ( IExec (( while>0 (C105 , C104) ) , R8 , D125) ) ) by SCMFSA8C:3
.= ( DataPart ( Result (( R8 +* ( while>0 (C105 , C104) ) ) , ( Initialized D125 )) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Result (D127 , D126) ) ) by L518
.= ( DataPart D131 ) by L507 , L517 , EXTPRO_1:23
.= ( DataPart D125 ) by L520 , L522 , SCMFSA_M:2;
end;
theorem
L525: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B117 being (State of ( SCM+FSA )) holds (for B118 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B119 being  read-write Int-Location holds ((( B117 . B119 ) > ( 0 ) & ( while>0 (B119 , B118) ) is  InitHalting) implies ( DataPart ( IExec (( while>0 (B119 , B118) ) , R8 , B117) ) ) = ( DataPart ( IExec (( while>0 (B119 , B118) ) , R8 , ( IExec (B118 , R8 , B117) )) ) ))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C109 being (State of ( SCM+FSA ));
let C110 being  good  InitHalting (Program of ( SCM+FSA ));
let C111 being  read-write Int-Location;
set D134 = ( Data-Locations ( SCM+FSA ) );
assume that
L526: ( C109 . C111 ) > ( 0 )
and
L527: ( while>0 (C111 , C110) ) is  InitHalting;
set D135 = ( Initialized C109 );
set D136 = ( R8 +* C110 );
set D137 = ( R8 +* ( while>0 (C111 , C110) ) );
set D138 = ( Initialized ( Comput (D136 , D135 , ( LifeSpan (D136 , D135) )) ) );
set D139 = ( D136 +* ( while>0 (C111 , C110) ) );
set D140 = ( LifeSpan (D136 , D135) );
set D141 = ( LifeSpan (D139 , D138) );
L528: C110 c= D136 by FUNCT_4:25;
L529: ( while>0 (C111 , C110) ) c= D139 by FUNCT_4:25;
L530: ( while>0 (C111 , C110) ) c= D137 by FUNCT_4:25;
L531: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= D135 by SCMFSA_M:13;
L532: D137 halts_on D135 by L531 , L527 , L530 , SCM_HALT:def 2;
set D142 = ( LifeSpan (D137 , D135) );
L533: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= D138 by SCMFSA_M:13;
L534: D139 halts_on D138 by L533 , L527 , L529 , SCM_HALT:def 2;
L535: ( DataPart ( Comput (D137 , ( Comput (D137 , D135 , ( D140 + 3 )) ) , ( D141 + D142 )) ) ) = ( DataPart ( Comput (D139 , D138 , D141) ) )
proof
reconsider D143 = ( while>0 (C111 , C110) ) as  good  InitHalting (Program of ( SCM+FSA )) by L527;
set D144 = ( Comput (D137 , D135 , ( D140 + 3 )) );
L536: C110 is_halting_onInit C109 , R8 by SCM_HALT:26;
L537: C110 is_closed_onInit C109 , R8 by SCM_HALT:25;
L538: ( IC D144 ) = ( 0 ) by L537 , L526 , L536 , L165;
L539: ( DataPart D144 ) = ( DataPart ( Comput (D136 , D135 , D140) ) ) by L526 , L537 , L536 , L165
.= ( DataPart ( Comput (D136 , D135 , D140) ) );
L540:
now
let C112 being FinSeq-Location;
L541: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = { ( intloc ( 0 ) ) , ( IC ( SCM+FSA ) ) } by SCMFSA_M:11;
L542: (C112 <> ( intloc ( 0 ) ) & C112 <> ( IC ( SCM+FSA ) )) by SCMFSA_2:57 , SCMFSA_2:58;
L543: (not C112 in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) by L542 , L541 , TARSKI:def 2;
thus L544: ( D138 . C112 ) = ( ( Comput (D136 , D135 , D140) ) . C112 ) by L543 , FUNCT_4:11
.= ( D144 . C112 ) by L539 , SCMFSA_M:2;
end;
L545: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= D135 by SCMFSA_M:13;
L546: ( D144 . ( intloc ( 0 ) ) ) = 1 by L545 , L530 , L527 , SCM_HALT:def 3;
L547:
now
let C113 being Int-Location;
per cases ;
suppose L548: C113 <> ( intloc ( 0 ) );

L549: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = { ( intloc ( 0 ) ) , ( IC ( SCM+FSA ) ) } by SCMFSA_M:11;
L550: C113 <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L551: (not C113 in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) by L550 , L548 , L549 , TARSKI:def 2;
thus L552: ( D138 . C113 ) = ( ( Comput (D136 , D135 , D140) ) . C113 ) by L551 , FUNCT_4:11
.= ( D144 . C113 ) by L539 , SCMFSA_M:2;
end;
suppose L553: C113 = ( intloc ( 0 ) );

thus L554: ( D138 . C113 ) = ( D144 . C113 ) by L553 , L546 , SCMFSA_M:13 , SCMFSA_M:30;
end;
end;
L556: ( Initialized D144 ) = D144 by L538 , L546 , SCMFSA_M:8;
L557: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= D144 by L556 , SCMFSA_M:13;
L558: D137 halts_on D144 by L557 , L527 , L530 , SCM_HALT:def 2;
L559: ( IC D144 ) = ( IC D138 ) by L538 , MEMSTR_0:28 , SCMFSA_M:13;
L560: D144 = D138 by L559 , L540 , L547 , SCMFSA_2:61;
L561: ( Result (D137 , D144) ) = ( Result (D139 , D138) ) by L560 , L527 , L533 , L101 , L530 , L529;
L562: ( LifeSpan (D137 , D144) ) = D141 by L527 , L533 , L101 , L530 , L529 , L560;
thus L563: ( DataPart ( Comput (D137 , D144 , ( D141 + D142 )) ) ) = ( DataPart ( Comput (D137 , D144 , ( LifeSpan (D137 , D144) )) ) ) by L562 , L558 , EXTPRO_1:25 , NAT_1:11
.= ( DataPart ( Result (D137 , D144) ) ) by L558 , EXTPRO_1:23
.= ( DataPart ( Result (D139 , D138) ) ) by L561
.= ( DataPart ( Comput (D139 , D138 , D141) ) ) by L534 , EXTPRO_1:23;
end;
L564: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= D135 by SCMFSA_M:13;
L565: ( R8 +* C110 ) halts_on D135 by L564 , L528 , SCM_HALT:def 2;
L566: ( IExec (C110 , R8 , C109) ) = ( Result (( R8 +* C110 ) , ( Initialized C109 )) ) by SCMFSA6B:def 1
.= ( Comput (D136 , D135 , D140) ) by L565 , EXTPRO_1:23;
L567: ( Result (D137 , ( Initialized ( IExec (C110 , R8 , C109) ) )) ) = ( Result (D139 , D138) ) by L566 , L527 , L533 , L101 , L530 , L529;
L568: ( Result (D137 , ( Initialized ( IExec (C110 , R8 , C109) ) )) ) = ( Result (D139 , D138) ) by L567;
L569: ( IExec (( while>0 (C111 , C110) ) , R8 , ( IExec (C110 , R8 , C109) )) ) = ( Result (D137 , ( Initialized ( IExec (C110 , R8 , C109) ) )) ) by SCMFSA6B:def 1
.= ( Comput (D139 , D138 , D141) ) by L534 , L568 , EXTPRO_1:23;
L570: D142 <= ( ( ( D140 + 3 ) + D141 ) + D142 ) by NAT_1:11;
L571: ( IExec (( while>0 (C111 , C110) ) , R8 , C109) ) = ( Result (D137 , ( Initialized C109 )) ) by SCMFSA6B:def 1
.= ( Comput (D137 , D135 , D142) ) by L532 , EXTPRO_1:23
.= ( Comput (D137 , D135 , ( ( D140 + 3 ) + ( D141 + D142 ) )) ) by L532 , L570 , EXTPRO_1:25;
L572: ( DataPart ( IExec (( while>0 (C111 , C110) ) , R8 , C109) ) ) = ( DataPart ( Comput (D137 , D135 , ( ( D140 + 3 ) + ( D141 + D142 ) )) ) ) by L571
.= ( DataPart ( Comput (D139 , D138 , D141) ) ) by L535 , EXTPRO_1:4
.= ( DataPart ( IExec (( while>0 (C111 , C110) ) , R8 , ( IExec (C110 , R8 , C109) )) ) ) by L569;
thus L573: ( DataPart ( IExec (( while>0 (C111 , C110) ) , R8 , C109) ) ) = ( DataPart ( IExec (( while>0 (C111 , C110) ) , R8 , ( IExec (C110 , R8 , C109) )) ) ) by L572;
end;
theorem
L574: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B120 being (State of ( SCM+FSA )) holds (for B121 being (Program of ( SCM+FSA )) holds (for B122 being FinSeq-Location holds (for B123 being  read-write Int-Location holds (( B120 . B123 ) <= ( 0 ) implies ( ( IExec (( while>0 (B123 , B121) ) , R8 , B120) ) . B122 ) = ( B120 . B122 )))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C114 being (State of ( SCM+FSA ));
let C115 being (Program of ( SCM+FSA ));
let C116 being FinSeq-Location;
let C117 being  read-write Int-Location;
set D145 = ( Data-Locations ( SCM+FSA ) );
assume L575: ( C114 . C117 ) <= ( 0 );
L576: C116 in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L577: C116 in D145 by L576 , SCMFSA_2:100 , XBOOLE_0:def 3;
thus L578: ( ( IExec (( while>0 (C117 , C115) ) , R8 , C114) ) . C116 ) = ( ( DataPart ( IExec (( while>0 (C117 , C115) ) , R8 , C114) ) ) . C116 ) by L577 , FUNCT_1:49
.= ( ( DataPart ( Initialized C114 ) ) . C116 ) by L575 , L478
.= ( ( Initialized C114 ) . C116 ) by L577 , FUNCT_1:49
.= ( C114 . C116 ) by SCMFSA_M:37;
end;
theorem
L579: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B124 being (State of ( SCM+FSA )) holds (for B125 being (Program of ( SCM+FSA )) holds (for B126 being Int-Location holds (for B127 being  read-write Int-Location holds (( B124 . B127 ) <= ( 0 ) implies ( ( IExec (( while>0 (B127 , B125) ) , R8 , B124) ) . B126 ) = ( ( Initialized B124 ) . B126 )))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C118 being (State of ( SCM+FSA ));
let C119 being (Program of ( SCM+FSA ));
let C120 being Int-Location;
let C121 being  read-write Int-Location;
set D146 = ( Data-Locations ( SCM+FSA ) );
assume L580: ( C118 . C121 ) <= ( 0 );
L581: C120 in ( Int-Locations ) by AMI_2:def 16;
L582: C120 in D146 by L581 , SCMFSA_2:100 , XBOOLE_0:def 3;
thus L583: ( ( IExec (( while>0 (C121 , C119) ) , R8 , C118) ) . C120 ) = ( ( DataPart ( IExec (( while>0 (C121 , C119) ) , R8 , C118) ) ) . C120 ) by L582 , FUNCT_1:49
.= ( ( DataPart ( Initialized C118 ) ) . C120 ) by L580 , L478
.= ( ( Initialized C118 ) . C120 ) by L582 , FUNCT_1:49;
end;
theorem
L584: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B128 being (State of ( SCM+FSA )) holds (for B129 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B130 being FinSeq-Location holds (for B131 being  read-write Int-Location holds ((( B128 . B131 ) > ( 0 ) & ( while>0 (B131 , B129) ) is  InitHalting) implies ( ( IExec (( while>0 (B131 , B129) ) , R8 , B128) ) . B130 ) = ( ( IExec (( while>0 (B131 , B129) ) , R8 , ( IExec (B129 , R8 , B128) )) ) . B130 )))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C122 being (State of ( SCM+FSA ));
let C123 being  good  InitHalting (Program of ( SCM+FSA ));
let C124 being FinSeq-Location;
let C125 being  read-write Int-Location;
set D147 = ( Data-Locations ( SCM+FSA ) );
assume that
L585: ( C122 . C125 ) > ( 0 )
and
L586: ( while>0 (C125 , C123) ) is  InitHalting;
L587: C124 in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L588: C124 in D147 by L587 , SCMFSA_2:100 , XBOOLE_0:def 3;
L589: ( ( IExec (( while>0 (C125 , C123) ) , R8 , C122) ) . C124 ) = ( ( DataPart ( IExec (( while>0 (C125 , C123) ) , R8 , C122) ) ) . C124 ) by L588 , FUNCT_1:49
.= ( ( DataPart ( IExec (( while>0 (C125 , C123) ) , R8 , ( IExec (C123 , R8 , C122) )) ) ) . C124 ) by L585 , L586 , L525;
thus L590: thesis by L589 , L588 , FUNCT_1:49;
end;
theorem
L591: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B132 being (State of ( SCM+FSA )) holds (for B133 being  good  InitHalting (Program of ( SCM+FSA )) holds (for B134 being Int-Location holds (for B135 being  read-write Int-Location holds ((( B132 . B135 ) > ( 0 ) & ( while>0 (B135 , B133) ) is  InitHalting) implies ( ( IExec (( while>0 (B135 , B133) ) , R8 , B132) ) . B134 ) = ( ( IExec (( while>0 (B135 , B133) ) , R8 , ( IExec (B133 , R8 , B132) )) ) . B134 )))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C126 being (State of ( SCM+FSA ));
let C127 being  good  InitHalting (Program of ( SCM+FSA ));
let C128 being Int-Location;
let C129 being  read-write Int-Location;
set D148 = ( Data-Locations ( SCM+FSA ) );
assume that
L592: ( C126 . C129 ) > ( 0 )
and
L593: ( while>0 (C129 , C127) ) is  InitHalting;
L594: C128 in ( Int-Locations ) by AMI_2:def 16;
L595: C128 in D148 by L594 , SCMFSA_2:100 , XBOOLE_0:def 3;
L596: ( ( IExec (( while>0 (C129 , C127) ) , R8 , C126) ) . C128 ) = ( ( DataPart ( IExec (( while>0 (C129 , C127) ) , R8 , C126) ) ) . C128 ) by L595 , FUNCT_1:49
.= ( ( DataPart ( IExec (( while>0 (C129 , C127) ) , R8 , ( IExec (C127 , R8 , C126) )) ) ) . C128 ) by L592 , L593 , L525;
thus L597: thesis by L596 , L595 , FUNCT_1:49;
end;
begin
set D149 = ( intloc ( 0 ) );
set D150 = ( intloc 1 );
set D151 = ( intloc 2 );
set D152 = ( intloc 3 );
set D153 = ( intloc 4 );
set D154 = ( intloc 5 );
set D155 = ( intloc 6 );
set D156 = ( ( ( ( ( ( intloc 2 ) := ( intloc ( 0 ) ) ) ";" ( ( intloc 3 ) := ( intloc ( 0 ) ) ) ) ";" ( ( intloc 4 ) := ( intloc ( 0 ) ) ) ) ";" ( ( intloc 5 ) := ( intloc ( 0 ) ) ) ) ";" ( ( intloc 6 ) := ( intloc ( 0 ) ) ) );
definition
let C130 being FinSeq-Location;
func insert-sort C130 -> (Program of ( SCM+FSA )) equals 
( ( ( ( ( ( ( ( ( intloc 2 ) := ( intloc ( 0 ) ) ) ";" ( ( intloc 3 ) := ( intloc ( 0 ) ) ) ) ";" ( ( intloc 4 ) := ( intloc ( 0 ) ) ) ) ";" ( ( intloc 5 ) := ( intloc ( 0 ) ) ) ) ";" ( ( intloc 6 ) := ( intloc ( 0 ) ) ) ) ";" ( ( intloc 1 ) :=len C130 ) ) ";" ( SubFrom (( intloc 1 ) , ( intloc ( 0 ) )) ) ) ";" ( Times (( intloc 1 ) , ( ( ( ( ( ( ( ( ( intloc 2 ) :=len C130 ) ";" ( SubFrom (( intloc 2 ) , ( intloc 1 )) ) ) ";" ( ( intloc 3 ) := ( intloc 2 ) ) ) ";" ( AddTo (( intloc 3 ) , ( intloc ( 0 ) )) ) ) ";" ( ( intloc 6 ) := (C130 , ( intloc 3 )) ) ) ";" ( SubFrom (( intloc 4 ) , ( intloc 4 )) ) ) ";" ( while>0 (( intloc 2 ) , ( ( ( ( intloc 5 ) := (C130 , ( intloc 2 )) ) ";" ( SubFrom (( intloc 5 ) , ( intloc 6 )) ) ) ";" ( if>0 (( intloc 5 ) , ( Macro ( SubFrom (( intloc 2 ) , ( intloc 2 )) ) ) , ( ( AddTo (( intloc 4 ) , ( intloc ( 0 ) )) ) ";" ( SubFrom (( intloc 2 ) , ( intloc ( 0 ) )) ) )) ) )) ) ) ";" ( Times (( intloc 4 ) , ( ( ( ( ( ( ( intloc 2 ) := ( intloc 3 ) ) ";" ( SubFrom (( intloc 3 ) , ( intloc ( 0 ) )) ) ) ";" ( ( intloc 5 ) := (C130 , ( intloc 2 )) ) ) ";" ( ( intloc 6 ) := (C130 , ( intloc 3 )) ) ) ";" ( (C130 , ( intloc 2 )) := ( intloc 6 ) ) ) ";" ( (C130 , ( intloc 3 )) := ( intloc 5 ) ) )) ) )) ) );
coherence;
end;
definition
func Insert-Sort-Algorithm -> (Program of ( SCM+FSA )) equals 
( insert-sort ( fsloc ( 0 ) ) );
coherence;
end;
theorem
L600: (for B136 being FinSeq-Location holds ( UsedIntLoc ( insert-sort B136 ) ) = { ( intloc ( 0 ) ) , ( intloc 1 ) , ( intloc 2 ) , ( intloc 3 ) , ( intloc 4 ) , ( intloc 5 ) , ( intloc 6 ) })
proof
set D157 = ( SubFrom (D151 , D151) );
set D158 = ( Macro D157 );
set D159 = ( AddTo (D153 , D149) );
set D160 = ( SubFrom (D151 , D149) );
set D161 = ( if>0 (D154 , D158 , ( D159 ";" D160 )) );
set D162 = ( UsedIntLoc D161 );
set D163 = ( D151 := D149 );
set D164 = ( D152 := D149 );
set D165 = ( D153 := D149 );
set D166 = ( D154 := D149 );
let C131 being FinSeq-Location;
set D167 = ( D151 := D152 );
set D168 = ( SubFrom (D152 , D149) );
set D169 = ( D154 := (C131 , D151) );
set D170 = ( D155 := (C131 , D152) );
set D171 = ( (C131 , D151) := D155 );
set D172 = ( (C131 , D152) := D154 );
set D173 = ( ( ( ( ( D167 ";" D168 ) ";" D169 ) ";" D170 ) ";" D171 ) ";" D172 );
set D174 = ( UsedIntLoc ( ( D167 ";" D168 ) ";" D169 ) );
set D175 = ( UsedIntLoc ( D167 ";" D168 ) );
set D176 = ( UsedIntLoc D173 );
L601: D176 = ( ( UsedIntLoc ( ( ( ( D167 ";" D168 ) ";" D169 ) ";" D170 ) ";" D171 ) ) \/ ( UsedIntLoc D172 ) ) by SF_MASTR:30
.= ( ( UsedIntLoc ( ( ( ( D167 ";" D168 ) ";" D169 ) ";" D170 ) ";" D171 ) ) \/ { D152 , D154 } ) by SF_MASTR:17
.= ( ( ( UsedIntLoc ( ( ( D167 ";" D168 ) ";" D169 ) ";" D170 ) ) \/ ( UsedIntLoc D171 ) ) \/ { D152 , D154 } ) by SF_MASTR:30
.= ( ( ( UsedIntLoc ( ( ( D167 ";" D168 ) ";" D169 ) ";" D170 ) ) \/ { D151 , D155 } ) \/ { D152 , D154 } ) by SF_MASTR:17
.= ( ( ( D174 \/ ( UsedIntLoc D170 ) ) \/ { D151 , D155 } ) \/ { D152 , D154 } ) by SF_MASTR:30
.= ( ( ( D174 \/ { D155 , D152 } ) \/ { D151 , D155 } ) \/ { D152 , D154 } ) by SF_MASTR:17
.= ( ( D174 \/ ( { D155 , D152 } \/ { D151 , D155 } ) ) \/ { D152 , D154 } ) by XBOOLE_1:4
.= ( ( D174 \/ { D155 , D152 , D151 , D155 } ) \/ { D152 , D154 } ) by ENUMSET1:5
.= ( ( D174 \/ { D155 , D155 , D151 , D152 } ) \/ { D152 , D154 } ) by ENUMSET1:64
.= ( ( D174 \/ { D155 , D151 , D152 } ) \/ { D152 , D154 } ) by ENUMSET1:31
.= ( ( D174 \/ ( { D155 , D151 } \/ { D152 } ) ) \/ { D152 , D154 } ) by ENUMSET1:3
.= ( ( ( D174 \/ { D155 , D151 } ) \/ { D152 } ) \/ { D152 , D154 } ) by XBOOLE_1:4
.= ( ( D174 \/ { D155 , D151 } ) \/ ( { D152 } \/ { D152 , D154 } ) ) by XBOOLE_1:4
.= ( ( D174 \/ { D155 , D151 } ) \/ { D152 , D152 , D154 } ) by ENUMSET1:2
.= ( ( D174 \/ { D155 , D151 } ) \/ { D152 , D154 } ) by ENUMSET1:30
.= ( ( ( D175 \/ ( UsedIntLoc D169 ) ) \/ { D155 , D151 } ) \/ { D152 , D154 } ) by SF_MASTR:30
.= ( ( ( D175 \/ { D154 , D151 } ) \/ { D155 , D151 } ) \/ { D152 , D154 } ) by SF_MASTR:17
.= ( ( D175 \/ ( { D154 , D151 } \/ { D155 , D151 } ) ) \/ { D152 , D154 } ) by XBOOLE_1:4
.= ( ( D175 \/ { D154 , D151 , D155 , D151 } ) \/ { D152 , D154 } ) by ENUMSET1:5
.= ( ( D175 \/ { D151 , D151 , D155 , D154 } ) \/ { D152 , D154 } ) by ENUMSET1:75
.= ( ( D175 \/ { D151 , D155 , D154 } ) \/ { D152 , D154 } ) by ENUMSET1:31
.= ( ( D175 \/ ( { D151 , D155 } \/ { D154 } ) ) \/ { D152 , D154 } ) by ENUMSET1:3
.= ( ( ( D175 \/ { D151 , D155 } ) \/ { D154 } ) \/ { D152 , D154 } ) by XBOOLE_1:4
.= ( ( D175 \/ { D151 , D155 } ) \/ ( { D154 } \/ { D152 , D154 } ) ) by XBOOLE_1:4
.= ( ( D175 \/ { D151 , D155 } ) \/ { D154 , D152 , D154 } ) by ENUMSET1:3
.= ( ( D175 \/ { D151 , D155 } ) \/ { D154 , D154 , D152 } ) by ENUMSET1:57
.= ( ( D175 \/ { D151 , D155 } ) \/ { D154 , D152 } ) by ENUMSET1:30
.= ( ( ( ( UsedIntLoc D167 ) \/ ( UsedIntLoc D168 ) ) \/ { D151 , D155 } ) \/ { D154 , D152 } ) by SF_MASTR:31
.= ( ( ( { D151 , D152 } \/ ( UsedIntLoc D168 ) ) \/ { D151 , D155 } ) \/ { D154 , D152 } ) by SF_MASTR:14
.= ( ( ( { D151 , D152 } \/ { D152 , D149 } ) \/ { D151 , D155 } ) \/ { D154 , D152 } ) by SF_MASTR:14
.= ( ( { D151 , D152 , D152 , D149 } \/ { D151 , D155 } ) \/ { D154 , D152 } ) by ENUMSET1:5
.= ( ( { D152 , D152 , D151 , D149 } \/ { D151 , D155 } ) \/ { D154 , D152 } ) by ENUMSET1:71
.= ( ( { D152 , D151 , D149 } \/ { D151 , D155 } ) \/ { D154 , D152 } ) by ENUMSET1:31
.= ( ( ( { D152 } \/ { D151 , D149 } ) \/ { D151 , D155 } ) \/ { D154 , D152 } ) by ENUMSET1:2
.= ( ( { D152 } \/ ( { D151 , D149 } \/ { D151 , D155 } ) ) \/ { D154 , D152 } ) by XBOOLE_1:4
.= ( ( { D152 } \/ { D151 , D149 , D151 , D155 } ) \/ { D154 , D152 } ) by ENUMSET1:5
.= ( ( { D152 } \/ { D151 , D151 , D149 , D155 } ) \/ { D154 , D152 } ) by ENUMSET1:62
.= ( ( { D152 } \/ { D151 , D149 , D155 } ) \/ { D154 , D152 } ) by ENUMSET1:31
.= ( ( { D152 } \/ { D154 , D152 } ) \/ { D151 , D149 , D155 } ) by XBOOLE_1:4
.= ( { D152 , D154 , D152 } \/ { D151 , D149 , D155 } ) by ENUMSET1:3
.= ( { D152 , D152 , D154 } \/ { D151 , D149 , D155 } ) by ENUMSET1:57
.= ( { D152 , D154 } \/ { D151 , D149 , D155 } ) by ENUMSET1:30;
set D177 = ( D154 := (C131 , D151) );
set D178 = ( SubFrom (D154 , D155) );
set D179 = ( ( D177 ";" D178 ) ";" D161 );
set D180 = ( UsedIntLoc D179 );
L602: D162 = ( ( { D154 } \/ ( UsedIntLoc D158 ) ) \/ ( UsedIntLoc ( D159 ";" D160 ) ) ) by SCMBSORT:16
.= ( ( { D154 } \/ ( UsedIntLoc D157 ) ) \/ ( UsedIntLoc ( D159 ";" D160 ) ) ) by SF_MASTR:28
.= ( ( { D154 } \/ { D151 , D151 } ) \/ ( UsedIntLoc ( D159 ";" D160 ) ) ) by SF_MASTR:14
.= ( ( { D154 } \/ { D151 , D151 } ) \/ ( ( UsedIntLoc D159 ) \/ ( UsedIntLoc D160 ) ) ) by SF_MASTR:31
.= ( ( { D154 } \/ { D151 , D151 } ) \/ ( { D153 , D149 } \/ ( UsedIntLoc D160 ) ) ) by SF_MASTR:14
.= ( ( { D154 } \/ { D151 , D151 } ) \/ ( { D153 , D149 } \/ { D151 , D149 } ) ) by SF_MASTR:14
.= ( ( { D154 } \/ { D151 } ) \/ ( { D153 , D149 } \/ { D151 , D149 } ) ) by ENUMSET1:29
.= ( ( ( { D154 } \/ { D151 } ) \/ { D151 , D149 } ) \/ { D153 , D149 } ) by XBOOLE_1:4
.= ( ( { D151 , D154 } \/ { D151 , D149 } ) \/ { D153 , D149 } ) by ENUMSET1:1
.= ( { D151 , D154 , D151 , D149 } \/ { D153 , D149 } ) by ENUMSET1:5
.= ( { D151 , D151 , D154 , D149 } \/ { D153 , D149 } ) by ENUMSET1:62
.= ( { D151 , D154 , D149 } \/ { D153 , D149 } ) by ENUMSET1:31
.= { D151 , D154 , D149 , D153 , D149 } by ENUMSET1:9
.= ( { D151 } \/ { D154 , D149 , D153 , D149 } ) by ENUMSET1:7
.= ( { D151 } \/ { D149 , D149 , D153 , D154 } ) by ENUMSET1:75
.= ( { D151 } \/ { D149 , D153 , D154 } ) by ENUMSET1:31
.= { D151 , D149 , D153 , D154 } by ENUMSET1:4
.= { D151 , D154 , D153 , D149 } by ENUMSET1:64
.= ( { D151 , D154 } \/ { D153 , D149 } ) by ENUMSET1:5;
set D181 = D156;
set D182 = ( D150 :=len C131 );
set D183 = ( SubFrom (D150 , D149) );
set D184 = ( UsedIntLoc ( D181 ";" D182 ) );
L603: ( UsedIntLoc D156 ) = ( ( UsedIntLoc ( ( ( D163 ";" D164 ) ";" D165 ) ";" D166 ) ) \/ ( UsedIntLoc ( D155 := D149 ) ) ) by SF_MASTR:30
.= ( ( UsedIntLoc ( ( ( D163 ";" D164 ) ";" D165 ) ";" D166 ) ) \/ { D155 , D149 } ) by SF_MASTR:14
.= ( ( ( UsedIntLoc ( ( D163 ";" D164 ) ";" D165 ) ) \/ ( UsedIntLoc D166 ) ) \/ { D155 , D149 } ) by SF_MASTR:30
.= ( ( ( UsedIntLoc ( ( D163 ";" D164 ) ";" D165 ) ) \/ { D154 , D149 } ) \/ { D155 , D149 } ) by SF_MASTR:14
.= ( ( ( ( UsedIntLoc ( D163 ";" D164 ) ) \/ ( UsedIntLoc D165 ) ) \/ { D154 , D149 } ) \/ { D155 , D149 } ) by SF_MASTR:30
.= ( ( ( ( UsedIntLoc ( D163 ";" D164 ) ) \/ { D153 , D149 } ) \/ { D154 , D149 } ) \/ { D155 , D149 } ) by SF_MASTR:14
.= ( ( ( ( ( UsedIntLoc D163 ) \/ ( UsedIntLoc D164 ) ) \/ { D153 , D149 } ) \/ { D154 , D149 } ) \/ { D155 , D149 } ) by SF_MASTR:31
.= ( ( ( ( ( UsedIntLoc D163 ) \/ { D152 , D149 } ) \/ { D153 , D149 } ) \/ { D154 , D149 } ) \/ { D155 , D149 } ) by SF_MASTR:14
.= ( ( ( ( { D151 , D149 } \/ { D152 , D149 } ) \/ { D153 , D149 } ) \/ { D154 , D149 } ) \/ { D155 , D149 } ) by SF_MASTR:14
.= ( ( ( { D151 , D149 } \/ { D152 , D149 } ) \/ { D153 , D149 } ) \/ ( { D154 , D149 } \/ { D155 , D149 } ) ) by XBOOLE_1:4
.= ( ( ( { D151 , D149 } \/ { D152 , D149 } ) \/ { D153 , D149 } ) \/ { D149 , D154 , D155 } ) by ENUMSET1:87
.= ( ( { D149 , D151 , D152 } \/ { D153 , D149 } ) \/ { D149 , D154 , D155 } ) by ENUMSET1:87
.= ( ( { D149 , D151 , D152 } \/ { D153 , D149 } ) \/ ( { D149 } \/ { D154 , D155 } ) ) by ENUMSET1:2
.= ( ( ( { D149 , D151 , D152 } \/ { D153 , D149 } ) \/ { D149 } ) \/ { D154 , D155 } ) by XBOOLE_1:4
.= ( ( { D149 , D151 , D152 } \/ ( { D153 , D149 } \/ { D149 } ) ) \/ { D154 , D155 } ) by XBOOLE_1:4
.= ( ( { D149 , D151 , D152 } \/ { D153 , D149 , D149 } ) \/ { D154 , D155 } ) by ENUMSET1:3
.= ( ( { D149 , D151 , D152 } \/ ( { D149 , D149 } \/ { D153 } ) ) \/ { D154 , D155 } ) by ENUMSET1:2
.= ( ( ( { D149 , D151 , D152 } \/ { D149 , D149 } ) \/ { D153 } ) \/ { D154 , D155 } ) by XBOOLE_1:4
.= ( ( { D149 , D149 , D149 , D151 , D152 } \/ { D153 } ) \/ { D154 , D155 } ) by ENUMSET1:8
.= ( ( { D149 , D151 , D152 } \/ { D153 } ) \/ { D154 , D155 } ) by ENUMSET1:38
.= ( { D149 , D151 , D152 , D153 } \/ { D154 , D155 } ) by ENUMSET1:6
.= { D149 , D151 , D152 , D153 , D154 , D155 } by ENUMSET1:14
.= ( { D149 } \/ { D151 , D152 , D153 , D154 , D155 } ) by ENUMSET1:11;
set D185 = ( Times (D153 , D173) );
set D186 = ( D151 :=len C131 );
set D187 = ( SubFrom (D151 , D150) );
set D188 = ( D152 := D151 );
set D189 = ( AddTo (D152 , D149) );
set D190 = ( D155 := (C131 , D152) );
set D191 = ( SubFrom (D153 , D153) );
set D192 = ( while>0 (D151 , D179) );
set D193 = ( ( ( ( ( D186 ";" D187 ) ";" D188 ) ";" D189 ) ";" D190 ) ";" D191 );
set D194 = ( ( D193 ";" D192 ) ";" D185 );
set D195 = ( UsedIntLoc D194 );
set D196 = ( UsedIntLoc D193 );
L604: D196 = ( ( UsedIntLoc ( ( ( ( D186 ";" D187 ) ";" D188 ) ";" D189 ) ";" D190 ) ) \/ ( UsedIntLoc D191 ) ) by SF_MASTR:30
.= ( ( UsedIntLoc ( ( ( ( D186 ";" D187 ) ";" D188 ) ";" D189 ) ";" D190 ) ) \/ { D153 , D153 } ) by SF_MASTR:14
.= ( ( ( UsedIntLoc ( ( ( D186 ";" D187 ) ";" D188 ) ";" D189 ) ) \/ ( UsedIntLoc D190 ) ) \/ { D153 , D153 } ) by SF_MASTR:30
.= ( ( ( UsedIntLoc ( ( ( D186 ";" D187 ) ";" D188 ) ";" D189 ) ) \/ { D152 , D155 } ) \/ { D153 , D153 } ) by SF_MASTR:17
.= ( ( ( ( UsedIntLoc ( ( D186 ";" D187 ) ";" D188 ) ) \/ ( UsedIntLoc D189 ) ) \/ { D152 , D155 } ) \/ { D153 , D153 } ) by SF_MASTR:30
.= ( ( ( ( UsedIntLoc ( ( D186 ";" D187 ) ";" D188 ) ) \/ { D152 , D149 } ) \/ { D152 , D155 } ) \/ { D153 , D153 } ) by SF_MASTR:14
.= ( ( ( ( ( UsedIntLoc ( D186 ";" D187 ) ) \/ ( UsedIntLoc D188 ) ) \/ { D152 , D149 } ) \/ { D152 , D155 } ) \/ { D153 , D153 } ) by SF_MASTR:30
.= ( ( ( ( ( UsedIntLoc ( D186 ";" D187 ) ) \/ { D152 , D151 } ) \/ { D152 , D149 } ) \/ { D152 , D155 } ) \/ { D153 , D153 } ) by SF_MASTR:14
.= ( ( ( ( ( ( UsedIntLoc D186 ) \/ ( UsedIntLoc D187 ) ) \/ { D152 , D151 } ) \/ { D152 , D149 } ) \/ { D152 , D155 } ) \/ { D153 , D153 } ) by SF_MASTR:31
.= ( ( ( ( ( { D151 } \/ ( UsedIntLoc D187 ) ) \/ { D152 , D151 } ) \/ { D152 , D149 } ) \/ { D152 , D155 } ) \/ { D153 , D153 } ) by SF_MASTR:18
.= ( ( ( ( ( { D151 } \/ { D151 , D150 } ) \/ { D152 , D151 } ) \/ { D152 , D149 } ) \/ { D152 , D155 } ) \/ { D153 , D153 } ) by SF_MASTR:14
.= ( ( ( ( { D151 , D151 , D150 } \/ { D152 , D151 } ) \/ { D152 , D149 } ) \/ { D152 , D155 } ) \/ { D153 , D153 } ) by ENUMSET1:2
.= ( ( ( ( { D151 , D150 } \/ { D152 , D151 } ) \/ { D152 , D149 } ) \/ { D152 , D155 } ) \/ { D153 , D153 } ) by ENUMSET1:30
.= ( ( ( { D151 , D150 , D152 , D151 } \/ { D152 , D149 } ) \/ { D152 , D155 } ) \/ { D153 , D153 } ) by ENUMSET1:5
.= ( ( ( { D151 , D151 , D152 , D150 } \/ { D152 , D149 } ) \/ { D152 , D155 } ) \/ { D153 , D153 } ) by ENUMSET1:64
.= ( ( ( { D151 , D152 , D150 } \/ { D152 , D149 } ) \/ { D152 , D155 } ) \/ { D153 , D153 } ) by ENUMSET1:31
.= ( ( { D151 , D152 , D150 , D152 , D149 } \/ { D152 , D155 } ) \/ { D153 , D153 } ) by ENUMSET1:9
.= ( ( ( { D151 , D152 , D150 , D152 } \/ { D149 } ) \/ { D152 , D155 } ) \/ { D153 , D153 } ) by ENUMSET1:10
.= ( ( ( { D152 , D152 , D150 , D151 } \/ { D149 } ) \/ { D152 , D155 } ) \/ { D153 , D153 } ) by ENUMSET1:75
.= ( ( ( { D152 , D150 , D151 } \/ { D149 } ) \/ { D152 , D155 } ) \/ { D153 , D153 } ) by ENUMSET1:31
.= ( ( ( { D152 , D150 , D151 } \/ { D149 } ) \/ { D152 , D155 } ) \/ { D153 } ) by ENUMSET1:29
.= ( ( ( { D152 , D150 , D151 } \/ { D152 , D155 } ) \/ { D149 } ) \/ { D153 } ) by XBOOLE_1:4
.= ( ( { D152 , D150 , D151 , D152 , D155 } \/ { D149 } ) \/ { D153 } ) by ENUMSET1:9
.= ( ( ( { D152 , D150 , D151 , D152 } \/ { D155 } ) \/ { D149 } ) \/ { D153 } ) by ENUMSET1:10
.= ( ( ( { D152 , D152 , D151 , D150 } \/ { D155 } ) \/ { D149 } ) \/ { D153 } ) by ENUMSET1:64
.= ( ( ( { D152 , D151 , D150 } \/ { D155 } ) \/ { D149 } ) \/ { D153 } ) by ENUMSET1:31
.= ( ( { D152 , D151 , D150 } \/ ( { D155 } \/ { D149 } ) ) \/ { D153 } ) by XBOOLE_1:4
.= ( ( { D152 , D151 , D150 } \/ { D155 , D149 } ) \/ { D153 } ) by ENUMSET1:1
.= ( { D152 , D151 , D150 } \/ ( { D155 , D149 } \/ { D153 } ) ) by XBOOLE_1:4
.= ( { D152 , D151 , D150 } \/ { D155 , D149 , D153 } ) by ENUMSET1:3
.= ( { D152 , D151 , D150 } \/ { D155 , D153 , D149 } ) by ENUMSET1:57;
L605: D180 = ( ( UsedIntLoc ( D177 ";" D178 ) ) \/ D162 ) by SF_MASTR:27
.= ( ( ( UsedIntLoc D177 ) \/ ( UsedIntLoc D178 ) ) \/ D162 ) by SF_MASTR:31
.= ( ( { D151 , D154 } \/ ( UsedIntLoc D178 ) ) \/ D162 ) by SF_MASTR:17
.= ( ( { D151 , D154 } \/ { D154 , D155 } ) \/ D162 ) by SF_MASTR:14
.= ( { D151 , D154 , D154 , D155 } \/ D162 ) by ENUMSET1:5
.= ( { D154 , D154 , D151 , D155 } \/ D162 ) by ENUMSET1:71
.= ( { D154 , D151 , D155 } \/ ( { D151 , D154 } \/ { D153 , D149 } ) ) by L602 , ENUMSET1:31
.= ( ( { D154 , D151 , D155 } \/ { D151 , D154 } ) \/ { D153 , D149 } ) by XBOOLE_1:4
.= ( { D151 , D154 , D154 , D151 , D155 } \/ { D153 , D149 } ) by ENUMSET1:8
.= ( ( { D151 , D154 , D154 , D151 } \/ { D155 } ) \/ { D153 , D149 } ) by ENUMSET1:10
.= ( ( { D151 , D151 , D154 , D154 } \/ { D155 } ) \/ { D153 , D149 } ) by ENUMSET1:64
.= ( ( { D151 , D154 , D154 } \/ { D155 } ) \/ { D153 , D149 } ) by ENUMSET1:31
.= ( ( { D154 , D154 , D151 } \/ { D155 } ) \/ { D153 , D149 } ) by ENUMSET1:60
.= ( ( { D154 , D151 } \/ { D155 } ) \/ { D153 , D149 } ) by ENUMSET1:30
.= ( { D154 , D151 , D155 } \/ { D153 , D149 } ) by ENUMSET1:3
.= { D154 , D151 , D155 , D153 , D149 } by ENUMSET1:9;
L606: D195 = ( ( UsedIntLoc ( D193 ";" D192 ) ) \/ ( UsedIntLoc D185 ) ) by SF_MASTR:27
.= ( ( UsedIntLoc ( D193 ";" D192 ) ) \/ ( D176 \/ { D153 , D149 } ) ) by SCMBSORT:18
.= ( ( D196 \/ ( UsedIntLoc D192 ) ) \/ ( D176 \/ { D153 , D149 } ) ) by SF_MASTR:27
.= ( ( D196 \/ ( { D154 , D151 , D155 , D153 , D149 } \/ { D151 } ) ) \/ ( D176 \/ { D153 , D149 } ) ) by L605 , SCMFSA9A:24
.= ( ( D196 \/ { D151 , D154 , D151 , D155 , D153 , D149 } ) \/ ( D176 \/ { D153 , D149 } ) ) by ENUMSET1:11
.= ( ( D196 \/ ( { D151 , D154 , D151 , D155 } \/ { D153 , D149 } ) ) \/ ( D176 \/ { D153 , D149 } ) ) by ENUMSET1:14
.= ( ( D196 \/ ( { D151 , D151 , D154 , D155 } \/ { D153 , D149 } ) ) \/ ( D176 \/ { D153 , D149 } ) ) by ENUMSET1:62
.= ( ( D196 \/ ( { D151 , D154 , D155 } \/ { D153 , D149 } ) ) \/ ( D176 \/ { D153 , D149 } ) ) by ENUMSET1:31
.= ( ( D196 \/ { D151 , D154 , D155 , D153 , D149 } ) \/ ( D176 \/ { D153 , D149 } ) ) by ENUMSET1:9
.= ( ( D196 \/ ( { D155 , D153 , D149 } \/ { D151 , D154 } ) ) \/ ( D176 \/ { D153 , D149 } ) ) by ENUMSET1:8
.= ( ( ( ( { D152 , D151 , D150 } \/ { D155 , D153 , D149 } ) \/ { D155 , D153 , D149 } ) \/ { D151 , D154 } ) \/ ( D176 \/ { D153 , D149 } ) ) by L604 , XBOOLE_1:4
.= ( ( ( { D152 , D151 , D150 } \/ ( { D155 , D153 , D149 } \/ { D155 , D153 , D149 } ) ) \/ { D151 , D154 } ) \/ ( D176 \/ { D153 , D149 } ) ) by XBOOLE_1:4
.= ( ( ( { D152 , D151 , D150 } \/ { D155 , D153 , D149 } ) \/ { D151 , D154 } ) \/ ( { D152 , D154 } \/ ( { D151 , D149 , D155 } \/ { D153 , D149 } ) ) ) by L601 , XBOOLE_1:4
.= ( ( ( { D152 , D151 , D150 } \/ { D155 , D153 , D149 } ) \/ { D151 , D154 } ) \/ ( { D152 , D154 } \/ { D151 , D149 , D155 , D153 , D149 } ) ) by ENUMSET1:9
.= ( ( ( { D152 , D151 , D150 } \/ { D155 , D153 , D149 } ) \/ { D151 , D154 } ) \/ ( { D152 , D154 } \/ ( { D151 } \/ { D149 , D155 , D153 , D149 } ) ) ) by ENUMSET1:7
.= ( ( ( { D152 , D151 , D150 } \/ { D155 , D153 , D149 } ) \/ { D151 , D154 } ) \/ ( { D152 , D154 } \/ ( { D151 } \/ { D149 , D149 , D153 , D155 } ) ) ) by ENUMSET1:64
.= ( ( ( { D152 , D151 , D150 } \/ { D155 , D153 , D149 } ) \/ { D151 , D154 } ) \/ ( { D152 , D154 } \/ ( { D151 } \/ { D149 , D153 , D155 } ) ) ) by ENUMSET1:31
.= ( ( ( { D152 , D151 , D150 } \/ { D155 , D153 , D149 } ) \/ { D151 , D154 } ) \/ ( { D152 , D154 } \/ { D151 , D149 , D153 , D155 } ) ) by ENUMSET1:4
.= ( ( ( { D152 , D151 , D150 } \/ { D155 , D153 , D149 } ) \/ { D151 , D154 } ) \/ { D152 , D154 , D151 , D149 , D153 , D155 } ) by ENUMSET1:12
.= ( ( ( { D152 , D151 , D150 } \/ { D149 , D153 , D155 } ) \/ { D154 , D151 } ) \/ { D152 , D154 , D151 , D149 , D153 , D155 } ) by ENUMSET1:60
.= ( ( { D152 , D151 , D150 } \/ ( { D149 , D153 , D155 } \/ { D154 , D151 } ) ) \/ { D152 , D154 , D151 , D149 , D153 , D155 } ) by XBOOLE_1:4
.= ( ( { D152 , D151 , D150 } \/ { D154 , D151 , D149 , D153 , D155 } ) \/ { D152 , D154 , D151 , D149 , D153 , D155 } ) by ENUMSET1:8
.= ( ( { D152 , D151 , D150 } \/ { D154 , D151 , D149 , D153 , D155 } ) \/ ( { D154 , D151 , D149 , D153 , D155 } \/ { D152 } ) ) by ENUMSET1:11
.= ( ( ( { D152 , D151 , D150 } \/ { D154 , D151 , D149 , D153 , D155 } ) \/ { D154 , D151 , D149 , D153 , D155 } ) \/ { D152 } ) by XBOOLE_1:4
.= ( ( { D152 , D151 , D150 } \/ ( { D154 , D151 , D149 , D153 , D155 } \/ { D154 , D151 , D149 , D153 , D155 } ) ) \/ { D152 } ) by XBOOLE_1:4
.= ( { D152 , D151 , D150 , D154 , D151 , D149 , D153 , D155 } \/ { D152 } ) by ENUMSET1:24
.= ( ( { D152 , D151 , D150 , D154 , D151 } \/ { D149 , D153 , D155 } ) \/ { D152 } ) by ENUMSET1:26
.= ( ( ( { D152 } \/ { D151 , D150 , D154 , D151 } ) \/ { D149 , D153 , D155 } ) \/ { D152 } ) by ENUMSET1:7
.= ( ( ( { D152 } \/ { D151 , D151 , D154 , D150 } ) \/ { D149 , D153 , D155 } ) \/ { D152 } ) by ENUMSET1:64
.= ( ( ( { D152 } \/ { D151 , D154 , D150 } ) \/ { D149 , D153 , D155 } ) \/ { D152 } ) by ENUMSET1:31
.= ( ( { D152 , D151 , D154 , D150 } \/ { D149 , D153 , D155 } ) \/ { D152 } ) by ENUMSET1:4
.= ( ( { D150 , D154 , D151 , D152 } \/ { D149 , D153 , D155 } ) \/ { D152 } ) by ENUMSET1:76
.= ( { D150 , D154 , D151 , D152 , D149 , D153 , D155 } \/ { D152 } ) by ENUMSET1:19
.= ( ( { D150 } \/ { D154 , D151 , D152 , D149 , D153 , D155 } ) \/ { D152 } ) by ENUMSET1:16
.= ( ( { D150 } \/ ( { D154 , D151 , D152 , D149 , D153 } \/ { D155 } ) ) \/ { D152 } ) by ENUMSET1:15
.= ( ( ( { D150 } \/ { D154 , D151 , D152 , D149 , D153 } ) \/ { D155 } ) \/ { D152 } ) by XBOOLE_1:4
.= ( ( ( { D150 } \/ { D154 , D151 , D152 , D149 , D153 } ) \/ { D152 } ) \/ { D155 } ) by XBOOLE_1:4
.= ( ( { D150 } \/ ( { D154 , D151 , D152 , D149 , D153 } \/ { D152 } ) ) \/ { D155 } ) by XBOOLE_1:4
.= ( ( { D150 } \/ { D154 , D151 , D152 , D149 , D153 , D152 } ) \/ { D155 } ) by ENUMSET1:15
.= ( ( { D150 } \/ ( { D154 , D151 } \/ { D152 , D149 , D153 , D152 } ) ) \/ { D155 } ) by ENUMSET1:12
.= ( ( { D150 } \/ ( { D154 , D151 } \/ { D152 , D152 , D153 , D149 } ) ) \/ { D155 } ) by ENUMSET1:64
.= ( ( { D150 } \/ ( { D154 , D151 } \/ { D152 , D153 , D149 } ) ) \/ { D155 } ) by ENUMSET1:31
.= ( ( { D150 } \/ { D154 , D151 , D152 , D153 , D149 } ) \/ { D155 } ) by ENUMSET1:8
.= ( ( { D150 } \/ ( { D149 } \/ { D154 , D151 , D152 , D153 } ) ) \/ { D155 } ) by ENUMSET1:10
.= ( ( ( { D150 } \/ { D149 } ) \/ { D154 , D151 , D152 , D153 } ) \/ { D155 } ) by XBOOLE_1:4
.= ( ( { D149 , D150 } \/ { D154 , D151 , D152 , D153 } ) \/ { D155 } ) by ENUMSET1:1
.= ( ( { D149 , D150 } \/ { D151 , D152 , D153 , D154 } ) \/ { D155 } ) by ENUMSET1:68
.= ( { D149 , D150 , D151 , D152 , D153 , D154 } \/ { D155 } ) by ENUMSET1:12
.= { D149 , D150 , D151 , D152 , D153 , D154 , D155 } by ENUMSET1:21;
thus L607: ( UsedIntLoc ( insert-sort C131 ) ) = ( ( UsedIntLoc ( ( D181 ";" D182 ) ";" D183 ) ) \/ ( UsedIntLoc ( Times (D150 , D194) ) ) ) by SF_MASTR:27
.= ( ( UsedIntLoc ( ( D181 ";" D182 ) ";" D183 ) ) \/ ( D195 \/ { D150 , D149 } ) ) by SCMBSORT:18
.= ( ( D184 \/ ( UsedIntLoc D183 ) ) \/ ( D195 \/ { D150 , D149 } ) ) by SF_MASTR:30
.= ( ( D184 \/ { D150 , D149 } ) \/ ( D195 \/ { D150 , D149 } ) ) by SF_MASTR:14
.= ( ( ( D184 \/ { D150 , D149 } ) \/ { D150 , D149 } ) \/ D195 ) by XBOOLE_1:4
.= ( ( D184 \/ ( { D150 , D149 } \/ { D150 , D149 } ) ) \/ D195 ) by XBOOLE_1:4
.= ( ( ( ( UsedIntLoc D181 ) \/ ( UsedIntLoc D182 ) ) \/ { D150 , D149 } ) \/ D195 ) by SF_MASTR:30
.= ( ( ( ( { D151 , D152 , D153 , D154 , D155 } \/ { D149 } ) \/ { D150 } ) \/ { D150 , D149 } ) \/ D195 ) by L603 , SF_MASTR:18
.= ( ( ( { D151 , D152 , D153 , D154 , D155 } \/ ( { D149 } \/ { D150 } ) ) \/ { D150 , D149 } ) \/ D195 ) by XBOOLE_1:4
.= ( ( ( { D151 , D152 , D153 , D154 , D155 } \/ { D150 , D149 } ) \/ { D150 , D149 } ) \/ D195 ) by ENUMSET1:1
.= ( ( { D151 , D152 , D153 , D154 , D155 } \/ ( { D150 , D149 } \/ { D150 , D149 } ) ) \/ D195 ) by XBOOLE_1:4
.= ( { D149 , D150 , D151 , D152 , D153 , D154 , D155 } \/ { D149 , D150 , D151 , D152 , D153 , D154 , D155 } ) by L606 , ENUMSET1:17
.= { D149 , D150 , D151 , D152 , D153 , D154 , D155 };
end;
theorem
L608: (for B137 being FinSeq-Location holds ( UsedInt*Loc ( insert-sort B137 ) ) = { B137 })
proof
set D197 = ( SubFrom (D151 , D151) );
set D198 = ( Macro D197 );
set D199 = ( AddTo (D153 , D149) );
set D200 = ( SubFrom (D151 , D149) );
set D201 = ( if>0 (D154 , D198 , ( D199 ";" D200 )) );
set D202 = ( UsedInt*Loc D201 );
set D203 = ( D151 := D149 );
set D204 = ( D152 := D149 );
set D205 = ( D153 := D149 );
set D206 = ( D154 := D149 );
let C132 being FinSeq-Location;
set D207 = ( D151 := D152 );
set D208 = ( SubFrom (D152 , D149) );
set D209 = ( D154 := (C132 , D151) );
set D210 = ( D155 := (C132 , D152) );
set D211 = ( (C132 , D151) := D155 );
set D212 = ( (C132 , D152) := D154 );
set D213 = ( ( ( ( ( D207 ";" D208 ) ";" D209 ) ";" D210 ) ";" D211 ) ";" D212 );
set D214 = ( UsedInt*Loc D213 );
L609: D214 = ( ( UsedInt*Loc ( ( ( ( D207 ";" D208 ) ";" D209 ) ";" D210 ) ";" D211 ) ) \/ ( UsedInt*Loc D212 ) ) by SF_MASTR:46
.= ( ( UsedInt*Loc ( ( ( ( D207 ";" D208 ) ";" D209 ) ";" D210 ) ";" D211 ) ) \/ { C132 } ) by SF_MASTR:33
.= ( ( ( UsedInt*Loc ( ( ( D207 ";" D208 ) ";" D209 ) ";" D210 ) ) \/ ( UsedInt*Loc D211 ) ) \/ { C132 } ) by SF_MASTR:46
.= ( ( ( UsedInt*Loc ( ( ( D207 ";" D208 ) ";" D209 ) ";" D210 ) ) \/ { C132 } ) \/ { C132 } ) by SF_MASTR:33
.= ( ( ( ( UsedInt*Loc ( ( D207 ";" D208 ) ";" D209 ) ) \/ ( UsedInt*Loc D210 ) ) \/ { C132 } ) \/ { C132 } ) by SF_MASTR:46
.= ( ( ( ( UsedInt*Loc ( ( D207 ";" D208 ) ";" D209 ) ) \/ { C132 } ) \/ { C132 } ) \/ { C132 } ) by SF_MASTR:33
.= ( ( ( ( ( UsedInt*Loc ( D207 ";" D208 ) ) \/ ( UsedInt*Loc D209 ) ) \/ { C132 } ) \/ { C132 } ) \/ { C132 } ) by SF_MASTR:46
.= ( ( ( ( ( UsedInt*Loc ( D207 ";" D208 ) ) \/ { C132 } ) \/ { C132 } ) \/ { C132 } ) \/ { C132 } ) by SF_MASTR:33
.= ( ( ( ( ( ( UsedInt*Loc D207 ) \/ ( UsedInt*Loc D208 ) ) \/ { C132 } ) \/ { C132 } ) \/ { C132 } ) \/ { C132 } ) by SF_MASTR:47
.= ( ( ( ( ( ( {} ) \/ ( UsedInt*Loc D208 ) ) \/ { C132 } ) \/ { C132 } ) \/ { C132 } ) \/ { C132 } ) by SF_MASTR:32
.= ( ( ( ( ( {} ) \/ { C132 } ) \/ { C132 } ) \/ { C132 } ) \/ { C132 } ) by SF_MASTR:32
.= { C132 };
set D215 = ( D154 := (C132 , D151) );
set D216 = ( SubFrom (D154 , D155) );
set D217 = ( ( D215 ";" D216 ) ";" D201 );
set D218 = ( UsedInt*Loc D217 );
L610: D202 = ( ( UsedInt*Loc D198 ) \/ ( UsedInt*Loc ( D199 ";" D200 ) ) ) by SCMFSA9A:10
.= ( ( UsedInt*Loc D197 ) \/ ( UsedInt*Loc ( D199 ";" D200 ) ) ) by SF_MASTR:44
.= ( ( {} ) \/ ( UsedInt*Loc ( D199 ";" D200 ) ) ) by SF_MASTR:32
.= ( ( {} ) \/ ( ( UsedInt*Loc D199 ) \/ ( UsedInt*Loc D200 ) ) ) by SF_MASTR:47
.= ( ( {} ) \/ ( ( {} ) \/ ( UsedInt*Loc D200 ) ) ) by SF_MASTR:32
.= ( {} ) by SF_MASTR:32;
set D219 = D156;
set D220 = ( D150 :=len C132 );
set D221 = ( SubFrom (D150 , D149) );
L611: ( UsedInt*Loc D156 ) = ( ( UsedInt*Loc ( ( ( D203 ";" D204 ) ";" D205 ) ";" D206 ) ) \/ ( UsedInt*Loc ( D155 := D149 ) ) ) by SF_MASTR:46
.= ( ( UsedInt*Loc ( ( ( D203 ";" D204 ) ";" D205 ) ";" D206 ) ) \/ ( {} ) ) by SF_MASTR:32
.= ( ( UsedInt*Loc ( ( D203 ";" D204 ) ";" D205 ) ) \/ ( UsedInt*Loc D206 ) ) by SF_MASTR:46
.= ( ( UsedInt*Loc ( ( D203 ";" D204 ) ";" D205 ) ) \/ ( {} ) ) by SF_MASTR:32
.= ( ( UsedInt*Loc ( D203 ";" D204 ) ) \/ ( UsedInt*Loc D205 ) ) by SF_MASTR:46
.= ( ( UsedInt*Loc ( D203 ";" D204 ) ) \/ ( {} ) ) by SF_MASTR:32
.= ( ( UsedInt*Loc D203 ) \/ ( UsedInt*Loc D204 ) ) by SF_MASTR:47
.= ( ( UsedInt*Loc D203 ) \/ ( {} ) ) by SF_MASTR:32
.= ( {} ) by SF_MASTR:32;
set D222 = ( Times (D153 , D213) );
set D223 = ( D151 :=len C132 );
set D224 = ( SubFrom (D151 , D150) );
set D225 = ( D152 := D151 );
set D226 = ( AddTo (D152 , D149) );
set D227 = ( D155 := (C132 , D152) );
set D228 = ( SubFrom (D153 , D153) );
set D229 = ( while>0 (D151 , D217) );
set D230 = ( ( ( ( ( D223 ";" D224 ) ";" D225 ) ";" D226 ) ";" D227 ) ";" D228 );
set D231 = ( ( D230 ";" D229 ) ";" D222 );
set D232 = ( UsedInt*Loc D231 );
set D233 = ( UsedInt*Loc D230 );
L612: D233 = ( ( UsedInt*Loc ( ( ( ( D223 ";" D224 ) ";" D225 ) ";" D226 ) ";" D227 ) ) \/ ( UsedInt*Loc D228 ) ) by SF_MASTR:46
.= ( ( UsedInt*Loc ( ( ( ( D223 ";" D224 ) ";" D225 ) ";" D226 ) ";" D227 ) ) \/ ( {} ) ) by SF_MASTR:32
.= ( ( ( UsedInt*Loc ( ( ( D223 ";" D224 ) ";" D225 ) ";" D226 ) ) \/ ( UsedInt*Loc D227 ) ) \/ ( {} ) ) by SF_MASTR:46
.= ( ( ( UsedInt*Loc ( ( ( D223 ";" D224 ) ";" D225 ) ";" D226 ) ) \/ { C132 } ) \/ ( {} ) ) by SF_MASTR:33
.= ( ( ( ( UsedInt*Loc ( ( D223 ";" D224 ) ";" D225 ) ) \/ ( UsedInt*Loc D226 ) ) \/ { C132 } ) \/ ( {} ) ) by SF_MASTR:46
.= ( ( ( ( UsedInt*Loc ( ( D223 ";" D224 ) ";" D225 ) ) \/ ( {} ) ) \/ { C132 } ) \/ ( {} ) ) by SF_MASTR:32
.= ( ( ( ( ( UsedInt*Loc ( D223 ";" D224 ) ) \/ ( UsedInt*Loc D225 ) ) \/ ( {} ) ) \/ { C132 } ) \/ ( {} ) ) by SF_MASTR:46
.= ( ( ( ( ( UsedInt*Loc ( D223 ";" D224 ) ) \/ ( {} ) ) \/ ( {} ) ) \/ { C132 } ) \/ ( {} ) ) by SF_MASTR:32
.= ( ( ( ( ( ( UsedInt*Loc D223 ) \/ ( UsedInt*Loc D224 ) ) \/ ( {} ) ) \/ ( {} ) ) \/ { C132 } ) \/ ( {} ) ) by SF_MASTR:47
.= ( ( ( ( ( { C132 } \/ ( UsedInt*Loc D224 ) ) \/ ( {} ) ) \/ ( {} ) ) \/ { C132 } ) \/ ( {} ) ) by SF_MASTR:34
.= ( ( { C132 } \/ { C132 } ) \/ ( {} ) ) by SF_MASTR:32
.= { C132 };
L613: D218 = ( ( UsedInt*Loc ( D215 ";" D216 ) ) \/ D202 ) by SF_MASTR:43
.= ( ( ( UsedInt*Loc D215 ) \/ ( UsedInt*Loc D216 ) ) \/ D202 ) by SF_MASTR:47
.= ( ( { C132 } \/ ( UsedInt*Loc D216 ) ) \/ D202 ) by SF_MASTR:33
.= ( { C132 } \/ ( {} ) ) by L610 , SF_MASTR:32
.= { C132 };
L614: ( UsedInt*Loc D231 ) = ( ( UsedInt*Loc ( D230 ";" D229 ) ) \/ ( UsedInt*Loc D222 ) ) by SF_MASTR:43
.= ( ( UsedInt*Loc ( D230 ";" D229 ) ) \/ { C132 } ) by L609 , SCMBSORT:20
.= ( ( ( UsedInt*Loc D230 ) \/ ( UsedInt*Loc D229 ) ) \/ { C132 } ) by SF_MASTR:43
.= ( { C132 } \/ { C132 } ) by L613 , L612 , SCMFSA9A:25
.= { C132 };
thus L615: ( UsedInt*Loc ( insert-sort C132 ) ) = ( ( UsedInt*Loc ( ( D219 ";" D220 ) ";" D221 ) ) \/ ( UsedInt*Loc ( Times (D150 , D231) ) ) ) by SF_MASTR:43
.= ( ( UsedInt*Loc ( ( D219 ";" D220 ) ";" D221 ) ) \/ { C132 } ) by L614 , SCMBSORT:20
.= ( ( ( UsedInt*Loc ( D219 ";" D220 ) ) \/ ( UsedInt*Loc D221 ) ) \/ { C132 } ) by SF_MASTR:46
.= ( ( ( UsedInt*Loc ( D219 ";" D220 ) ) \/ ( {} ) ) \/ { C132 } ) by SF_MASTR:32
.= ( ( ( ( UsedInt*Loc D219 ) \/ ( UsedInt*Loc D220 ) ) \/ ( {} ) ) \/ { C132 } ) by SF_MASTR:46
.= ( { C132 } \/ { C132 } ) by L611 , SF_MASTR:34
.= { C132 };
end;
theorem
L616: (for B138 , B139 , B140 , B141 being (Instruction of ( SCM+FSA )) holds ( card ( ( ( B138 ";" B139 ) ";" B140 ) ";" B141 ) ) = 8)
proof
let C133 , C134 , C135 , C136 being (Instruction of ( SCM+FSA ));
thus L617: ( card ( ( ( C133 ";" C134 ) ";" C135 ) ";" C136 ) ) = ( ( card ( ( C133 ";" C134 ) ";" C135 ) ) + 2 ) by SCMFSA6A:34
.= ( 6 + 2 ) by SCMBSORT:23
.= 8;
end;
theorem
L618: (for B142 , B143 , B144 , B145 , B146 being (Instruction of ( SCM+FSA )) holds ( card ( ( ( ( B142 ";" B143 ) ";" B144 ) ";" B145 ) ";" B146 ) ) = 10)
proof
let C137 , C138 , C139 , C140 , C141 being (Instruction of ( SCM+FSA ));
thus L619: ( card ( ( ( ( C137 ";" C138 ) ";" C139 ) ";" C140 ) ";" C141 ) ) = ( ( card ( ( ( C137 ";" C138 ) ";" C139 ) ";" C140 ) ) + 2 ) by SCMFSA6A:34
.= ( 8 + 2 ) by L616
.= 10;
end;
theorem
L620: (for B147 being FinSeq-Location holds ( card ( insert-sort B147 ) ) = 82)
proof
set D234 = ( Macro ( SubFrom (D151 , D151) ) );
set D235 = ( AddTo (D153 , D149) );
set D236 = ( SubFrom (D151 , D149) );
set D237 = ( if>0 (D154 , D234 , ( D235 ";" D236 )) );
let C142 being FinSeq-Location;
set D238 = ( D151 := D152 );
set D239 = ( SubFrom (D152 , D149) );
set D240 = ( D154 := (C142 , D151) );
set D241 = ( D155 := (C142 , D152) );
set D242 = ( (C142 , D151) := D155 );
set D243 = ( (C142 , D152) := D154 );
set D244 = ( ( ( ( ( D238 ";" D239 ) ";" D240 ) ";" D241 ) ";" D242 ) ";" D243 );
L621: ( card D237 ) = ( ( ( card D234 ) + ( card ( D235 ";" D236 ) ) ) + 4 ) by SCMFSA8B:12
.= ( ( 2 + ( card ( D235 ";" D236 ) ) ) + 4 ) by COMPOS_1:56
.= ( ( 2 + ( 2 + 2 ) ) + 4 ) by SCMFSA6A:35
.= 10;
set D245 = ( D154 := (C142 , D151) );
set D246 = ( SubFrom (D154 , D155) );
set D247 = ( ( D245 ";" D246 ) ";" D237 );
L622: ( card D247 ) = ( ( card ( D245 ";" D246 ) ) + ( card D237 ) ) by SCMFSA6A:21
.= ( ( 2 + 2 ) + 10 ) by L621 , SCMFSA6A:35
.= 14;
set D248 = D156;
set D249 = ( D150 :=len C142 );
set D250 = ( SubFrom (D150 , D149) );
set D251 = ( Times (D153 , D244) );
set D252 = ( D151 :=len C142 );
set D253 = ( SubFrom (D151 , D150) );
set D254 = ( D152 := D151 );
set D255 = ( AddTo (D152 , D149) );
set D256 = ( D155 := (C142 , D152) );
set D257 = ( SubFrom (D153 , D153) );
set D258 = ( while>0 (D151 , D247) );
set D259 = ( ( ( ( ( D252 ";" D253 ) ";" D254 ) ";" D255 ) ";" D256 ) ";" D257 );
set D260 = ( ( D259 ";" D258 ) ";" D251 );
L623: ( card D244 ) = ( ( card ( ( ( ( D238 ";" D239 ) ";" D240 ) ";" D241 ) ";" D242 ) ) + 2 ) by SCMFSA6A:34
.= ( 10 + 2 ) by L618
.= 12;
L624: ( card D260 ) = ( ( card ( D259 ";" D258 ) ) + ( card D251 ) ) by SCMFSA6A:21
.= ( ( ( card D259 ) + ( card D258 ) ) + ( card D251 ) ) by SCMFSA6A:21
.= ( ( ( ( card ( ( ( ( D252 ";" D253 ) ";" D254 ) ";" D255 ) ";" D256 ) ) + 2 ) + ( card D258 ) ) + ( card D251 ) ) by SCMFSA6A:34
.= ( ( ( 10 + 2 ) + ( card D258 ) ) + ( card D251 ) ) by L618
.= ( ( ( 10 + 2 ) + ( 14 + 6 ) ) + ( card D251 ) ) by L622 , SCMFSA_9:5
.= ( ( ( 10 + 2 ) + ( 14 + 6 ) ) + ( 12 + 12 ) ) by L623 , SCMBSORT:22
.= 56;
thus L625: ( card ( insert-sort C142 ) ) = ( ( card ( ( D248 ";" D249 ) ";" D250 ) ) + ( card ( Times (D150 , D260) ) ) ) by SCMFSA6A:21
.= ( ( card ( ( D248 ";" D249 ) ";" D250 ) ) + ( 56 + 12 ) ) by L624 , SCMBSORT:22
.= ( ( ( card ( D248 ";" D249 ) ) + 2 ) + ( 56 + 12 ) ) by SCMFSA6A:34
.= ( ( ( ( card D248 ) + 2 ) + 2 ) + ( 56 + 12 ) ) by SCMFSA6A:34
.= ( ( ( 10 + 2 ) + 2 ) + 68 ) by L618
.= 82;
end;
theorem
L626: (for B148 being FinSeq-Location holds (for B149 being (Element of ( NAT )) holds (B149 < 82 implies B149 in ( dom ( insert-sort B148 ) ))))
proof
let C143 being FinSeq-Location;
let C144 being (Element of ( NAT ));
assume L627: C144 < 82;
L628: ( card ( insert-sort C143 ) ) = 82 by L620;
thus L629: thesis by L628 , L627 , AFINSQ_1:66;
end;
L630: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (( Insert-Sort-Algorithm ) c= R8 implies (( R8 . ( 0 ) ) = ( D151 := D149 ) & ( R8 . 1 ) = ( goto 2 ) & ( R8 . 2 ) = ( D152 := D149 ) & ( R8 . 3 ) = ( goto 4 ) & ( R8 . 4 ) = ( D153 := D149 ) & ( R8 . 5 ) = ( goto 6 ) & ( R8 . 6 ) = ( D154 := D149 ) & ( R8 . 7 ) = ( goto 8 ) & ( R8 . 8 ) = ( D155 := D149 ) & ( R8 . 9 ) = ( goto 10 ) & ( R8 . 10 ) = ( D150 :=len ( fsloc ( 0 ) ) ) & ( R8 . 11 ) = ( goto 12 ))))
proof
set D261 = ( fsloc ( 0 ) );
set D262 = ( Times (D150 , ( ( ( ( ( ( ( ( D151 :=len D261 ) ";" ( SubFrom (D151 , D150) ) ) ";" ( D152 := D151 ) ) ";" ( AddTo (D152 , D149) ) ) ";" ( D155 := (D261 , D152) ) ) ";" ( SubFrom (D153 , D153) ) ) ";" ( while>0 (D151 , ( ( ( D154 := (D261 , D151) ) ";" ( SubFrom (D154 , D155) ) ) ";" ( if>0 (D154 , ( Macro ( SubFrom (D151 , D151) ) ) , ( ( AddTo (D153 , D149) ) ";" ( SubFrom (D151 , D149) ) )) ) )) ) ) ";" ( Times (D153 , ( ( ( ( ( ( D151 := D152 ) ";" ( SubFrom (D152 , D149) ) ) ";" ( D154 := (D261 , D151) ) ) ";" ( D155 := (D261 , D152) ) ) ";" ( (D261 , D151) := D155 ) ) ";" ( (D261 , D152) := D154 ) )) ) )) );
set D263 = ( Insert-Sort-Algorithm );
set D264 = ( insert-sort D261 );
set D265 = ( D151 := D149 );
set D266 = ( D152 := D149 );
set D267 = ( D153 := D149 );
set D268 = ( D154 := D149 );
set D269 = ( D155 := D149 );
set D270 = ( D150 :=len D261 );
set D271 = ( SubFrom (D150 , D149) );
set D272 = ( D271 ";" D262 );
set D273 = ( D270 ";" D272 );
set D274 = ( D269 ";" D273 );
set D275 = ( D268 ";" D274 );
set D276 = ( D267 ";" D275 );
set D277 = ( D266 ";" D276 );
set D278 = ( D265 ";" D266 );
set D279 = ( D278 ";" D267 );
set D280 = ( D279 ";" D268 );
set D281 = ( D280 ";" D269 );
L631: ( dom ( Macro D265 ) ) = { ( 0 ) , 1 } by COMPOS_1:61;
L632: ( 0 ) in ( dom ( Macro D265 ) ) by L631 , TARSKI:def 2;
L633: 1 in ( dom ( Macro D265 ) ) by L631 , TARSKI:def 2;
L634: ( card D278 ) = 4 by SCMFSA6A:35;
L635: D264 = ( ( D281 ";" D270 ) ";" D272 ) by SCMFSA6A:27;
L636: D264 = ( ( D280 ";" D269 ) ";" D273 ) by L635 , SCMFSA6A:27;
L637: D264 = ( ( D279 ";" D268 ) ";" D274 ) by L636 , SCMFSA6A:27;
L638: D264 = ( ( D278 ";" D267 ) ";" D275 ) by L637 , SCMFSA6A:27;
L639: D264 = ( ( D265 ";" D266 ) ";" D276 ) by L638 , SCMFSA6A:27
.= ( ( ( Macro D265 ) ";" D266 ) ";" D276 ) by SCMFSA6A:19;
L640: D264 = ( ( D265 ";" D266 ) ";" D276 ) by L638 , SCMFSA6A:27;
L641: D264 = ( D265 ";" D277 ) by L640 , SCMFSA6A:31
.= ( ( Macro D265 ) ";" D277 ) by SCMFSA6A:def 5;
let R8 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L642: D263 c= R8;
L643:
now
let C145 being (Element of ( NAT ));
assume L644: C145 < 82;
L645: C145 in ( dom D264 ) by L644 , L626;
thus L646: ( D264 . C145 ) = ( R8 . C145 ) by L645 , L642 , GRFUNC_1:2;
end;
thus L647: ( R8 . ( 0 ) ) = ( ( ( Macro D265 ) ";" D277 ) . ( 0 ) ) by L643 , L641
.= ( ( Directed ( Macro D265 ) ) . ( 0 ) ) by L632 , SCMFSA8A:14
.= D265 by SCMFSA7B:1;
L648: ( card ( Macro D265 ) ) = 2 by COMPOS_1:56;
L649: ( card D279 ) = 6 by SCMBSORT:23;
L650: ( card D280 ) = ( 6 + 2 ) by L649 , SCMFSA6A:34
.= 8;
L651: ( card D281 ) = ( 8 + 2 ) by L650 , SCMFSA6A:34
.= 10;
thus L652: ( R8 . 1 ) = ( D264 . 1 ) by L643
.= ( ( Directed ( Macro D265 ) ) . 1 ) by L641 , L633 , SCMFSA8A:14
.= ( goto 2 ) by SCMFSA7B:2;
thus L653: ( R8 . 2 ) = ( D264 . 2 ) by L643
.= D266 by L639 , L648 , SCMBSORT:27;
thus L654: ( R8 . 3 ) = ( D264 . ( 2 + 1 ) ) by L643
.= ( goto ( 2 + 2 ) ) by L639 , L648 , SCMBSORT:28
.= ( goto 4 );
thus L655: ( R8 . 4 ) = ( D264 . 4 ) by L643
.= D267 by L638 , L634 , SCMBSORT:27;
thus L656: ( R8 . 5 ) = ( D264 . ( 4 + 1 ) ) by L643
.= ( goto ( 4 + 2 ) ) by L638 , L634 , SCMBSORT:28
.= ( goto 6 );
thus L657: ( R8 . 6 ) = ( D264 . 6 ) by L643
.= D268 by L637 , L649 , SCMBSORT:27;
thus L658: ( R8 . 7 ) = ( D264 . ( 6 + 1 ) ) by L643
.= ( goto ( 6 + 2 ) ) by L637 , L649 , SCMBSORT:28
.= ( goto 8 );
thus L659: ( R8 . 8 ) = ( D264 . 8 ) by L643
.= D269 by L636 , L650 , SCMBSORT:27;
thus L660: ( R8 . 9 ) = ( D264 . ( 8 + 1 ) ) by L643
.= ( goto ( 8 + 2 ) ) by L636 , L650 , SCMBSORT:28
.= ( goto 10 );
thus L661: ( R8 . 10 ) = ( D264 . 10 ) by L643
.= D270 by L635 , L651 , SCMBSORT:27;
thus L662: ( R8 . 11 ) = ( D264 . ( 10 + 1 ) ) by L643
.= ( goto ( 10 + 2 ) ) by L635 , L651 , SCMBSORT:28
.= ( goto 12 );
end;
set D282 = ( fsloc ( 0 ) );
set D283 = ( intloc ( ( 0 ) + 1 ) );
set D284 = ( intloc ( 1 + 1 ) );
set D285 = ( intloc ( 2 + 1 ) );
set D286 = ( intloc ( 3 + 1 ) );
set D287 = ( intloc ( 4 + 1 ) );
set D288 = ( intloc ( 5 + 1 ) );
set D289 = ( D284 := D285 );
set D290 = ( SubFrom (D285 , D149) );
set D291 = ( D287 := (D282 , D284) );
set D292 = ( D288 := (D282 , D285) );
set D293 = ( (D282 , D284) := D288 );
set D294 = ( (D282 , D285) := D287 );
set D295 = ( ( ( ( ( D289 ";" D290 ) ";" D291 ) ";" D292 ) ";" D293 ) ";" D294 );
set D296 = ( D284 := D149 );
set D297 = ( D285 := D149 );
set D298 = ( D286 := D149 );
set D299 = ( D287 := D149 );
set D300 = ( D288 := D149 );
set D301 = ( Times (D286 , D295) );
set D302 = ( SubFrom (D284 , D284) );
set D303 = ( Macro D302 );
set D304 = ( AddTo (D286 , D149) );
set D305 = ( SubFrom (D284 , D149) );
set D306 = ( if>0 (D287 , D303 , ( D304 ";" D305 )) );
set D307 = ( D287 := (D282 , D284) );
set D308 = ( SubFrom (D287 , D288) );
set D309 = ( ( D307 ";" D308 ) ";" D306 );
set D310 = ( D284 :=len D282 );
set D311 = ( SubFrom (D284 , D283) );
set D312 = ( D285 := D284 );
set D313 = ( AddTo (D285 , D149) );
set D314 = ( D288 := (D282 , D285) );
set D315 = ( SubFrom (D286 , D286) );
set D316 = ( while>0 (D284 , D309) );
set D317 = ( ( ( ( ( D310 ";" D311 ) ";" D312 ) ";" D313 ) ";" D314 ) ";" D315 );
set D318 = ( ( D317 ";" D316 ) ";" D301 );
set D319 = D156;
set D320 = ( D283 :=len D282 );
set D321 = ( SubFrom (D283 , D149) );
L663: (for B150 being ( 0 ) -started (State of ( SCM+FSA )) holds (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (( Insert-Sort-Algorithm ) c= R8 implies ((for B151 being (Element of ( NAT )) holds ((B151 > ( 0 ) & B151 < 12) implies (( ( Comput (R8 , B150 , B151) ) . ( IC ( SCM+FSA ) ) ) = B151 & ( ( Comput (R8 , B150 , B151) ) . D149 ) = ( B150 . D149 ) & ( ( Comput (R8 , B150 , B151) ) . ( fsloc ( 0 ) ) ) = ( B150 . ( fsloc ( 0 ) ) )))) & ( ( Comput (R8 , B150 , 11) ) . D150 ) = ( len ( B150 . ( fsloc ( 0 ) ) ) ) & ( ( Comput (R8 , B150 , 11) ) . D151 ) = ( B150 . D149 ) & ( ( Comput (R8 , B150 , 11) ) . D152 ) = ( B150 . D149 ) & ( ( Comput (R8 , B150 , 11) ) . D153 ) = ( B150 . D149 ) & ( ( Comput (R8 , B150 , 11) ) . D154 ) = ( B150 . D149 ) & ( ( Comput (R8 , B150 , 11) ) . D155 ) = ( B150 . D149 )))))
proof
let C146 being ( 0 ) -started (State of ( SCM+FSA ));
let R8 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L664: ( Insert-Sort-Algorithm ) c= R8;
L665: ( IC ( Comput (R8 , C146 , ( 0 )) ) ) = ( 0 ) by MEMSTR_0:def 11;
L666: ( Comput (R8 , C146 , ( ( 0 ) + 1 )) ) = ( Exec (( R8 . ( 0 ) ) , ( Comput (R8 , C146 , ( 0 )) )) ) by L665 , EXTPRO_1:6
.= ( Exec (( D151 := D149 ) , ( Comput (R8 , C146 , ( 0 )) )) ) by L664 , L630;
L667: ( ( Comput (R8 , C146 , 1) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC ( Comput (R8 , C146 , ( 0 )) ) ) ) by L666 , SCMFSA_2:63
.= 1 by L665;
L668: ( IC ( Comput (R8 , C146 , 1) ) ) = 1 by L667;
L669: ( Comput (R8 , C146 , ( 1 + 1 )) ) = ( Exec (( R8 . 1 ) , ( Comput (R8 , C146 , 1) )) ) by L668 , EXTPRO_1:6
.= ( Exec (( goto 2 ) , ( Comput (R8 , C146 , 1) )) ) by L664 , L630;
L670: ( ( Comput (R8 , C146 , 2) ) . ( IC ( SCM+FSA ) ) ) = 2 by L669 , SCMFSA_2:69;
L671: ( IC ( Comput (R8 , C146 , 2) ) ) = 2 by L669 , SCMFSA_2:69;
L672: ( Comput (R8 , C146 , ( 2 + 1 )) ) = ( Exec (( R8 . 2 ) , ( Comput (R8 , C146 , 2) )) ) by L671 , EXTPRO_1:6
.= ( Exec (( D152 := D149 ) , ( Comput (R8 , C146 , 2) )) ) by L664 , L630;
L673: ( ( Comput (R8 , C146 , 3) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC ( Comput (R8 , C146 , 2) ) ) ) by L672 , SCMFSA_2:63
.= 3 by L670;
L674: ( IC ( Comput (R8 , C146 , 3) ) ) = 3 by L673;
L675: ( Comput (R8 , C146 , ( 3 + 1 )) ) = ( Exec (( R8 . 3 ) , ( Comput (R8 , C146 , 3) )) ) by L674 , EXTPRO_1:6
.= ( Exec (( goto 4 ) , ( Comput (R8 , C146 , 3) )) ) by L664 , L630;
L676: ( ( Comput (R8 , C146 , 4) ) . ( IC ( SCM+FSA ) ) ) = 4 by L675 , SCMFSA_2:69;
L677: D151 <> D149 by SCMFSA_2:101;
L678: ( ( Comput (R8 , C146 , 1) ) . D149 ) = ( C146 . D149 ) by L677 , L666 , SCMFSA_2:63;
L679: ( ( Comput (R8 , C146 , 2) ) . D149 ) = ( C146 . D149 ) by L678 , L669 , SCMFSA_2:69;
L680: ( ( Comput (R8 , C146 , 3) ) . D152 ) = ( C146 . D149 ) by L679 , L672 , SCMFSA_2:63;
L681: ( ( Comput (R8 , C146 , 4) ) . D152 ) = ( C146 . D149 ) by L680 , L675 , SCMFSA_2:69;
L682: ( IC ( Comput (R8 , C146 , 4) ) ) = 4 by L675 , SCMFSA_2:69;
L683: ( Comput (R8 , C146 , ( 4 + 1 )) ) = ( Exec (( R8 . 4 ) , ( Comput (R8 , C146 , 4) )) ) by L682 , EXTPRO_1:6
.= ( Exec (( D153 := D149 ) , ( Comput (R8 , C146 , 4) )) ) by L664 , L630;
L684: ( ( Comput (R8 , C146 , 5) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC ( Comput (R8 , C146 , 4) ) ) ) by L683 , SCMFSA_2:63
.= 5 by L676;
L685: ( IC ( Comput (R8 , C146 , 5) ) ) = 5 by L684;
L686: ( Comput (R8 , C146 , ( 5 + 1 )) ) = ( Exec (( R8 . 5 ) , ( Comput (R8 , C146 , 5) )) ) by L685 , EXTPRO_1:6
.= ( Exec (( goto 6 ) , ( Comput (R8 , C146 , 5) )) ) by L664 , L630;
L687: ( ( Comput (R8 , C146 , 6) ) . ( IC ( SCM+FSA ) ) ) = 6 by L686 , SCMFSA_2:69;
L688: ( IC ( Comput (R8 , C146 , 6) ) ) = 6 by L686 , SCMFSA_2:69;
L689: ( Comput (R8 , C146 , ( 6 + 1 )) ) = ( Exec (( R8 . 6 ) , ( Comput (R8 , C146 , 6) )) ) by L688 , EXTPRO_1:6
.= ( Exec (( D154 := D149 ) , ( Comput (R8 , C146 , 6) )) ) by L664 , L630;
L690: ( ( Comput (R8 , C146 , 7) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC ( Comput (R8 , C146 , 6) ) ) ) by L689 , SCMFSA_2:63
.= 7 by L687;
L691: ( IC ( Comput (R8 , C146 , 7) ) ) = 7 by L690;
L692: ( Comput (R8 , C146 , ( 7 + 1 )) ) = ( Exec (( R8 . 7 ) , ( Comput (R8 , C146 , 7) )) ) by L691 , EXTPRO_1:6
.= ( Exec (( goto 8 ) , ( Comput (R8 , C146 , 7) )) ) by L664 , L630;
L693: ( ( Comput (R8 , C146 , 8) ) . ( IC ( SCM+FSA ) ) ) = 8 by L692 , SCMFSA_2:69;
L694: ( IC ( Comput (R8 , C146 , 8) ) ) = 8 by L692 , SCMFSA_2:69;
L695: ( Comput (R8 , C146 , ( 8 + 1 )) ) = ( Exec (( R8 . 8 ) , ( Comput (R8 , C146 , 8) )) ) by L694 , EXTPRO_1:6
.= ( Exec (( D155 := D149 ) , ( Comput (R8 , C146 , 8) )) ) by L664 , L630;
L696: ( ( Comput (R8 , C146 , 9) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC ( Comput (R8 , C146 , 8) ) ) ) by L695 , SCMFSA_2:63
.= 9 by L693;
L697: ( IC ( Comput (R8 , C146 , 9) ) ) = 9 by L696;
L698: ( Comput (R8 , C146 , ( 9 + 1 )) ) = ( Exec (( R8 . 9 ) , ( Comput (R8 , C146 , 9) )) ) by L697 , EXTPRO_1:6
.= ( Exec (( goto 10 ) , ( Comput (R8 , C146 , 9) )) ) by L664 , L630;
L699: ( ( Comput (R8 , C146 , 10) ) . ( IC ( SCM+FSA ) ) ) = 10 by L698 , SCMFSA_2:69;
L700: ( ( Comput (R8 , C146 , 1) ) . ( fsloc ( 0 ) ) ) = ( C146 . ( fsloc ( 0 ) ) ) by L666 , SCMFSA_2:63;
L701: ( ( Comput (R8 , C146 , 2) ) . ( fsloc ( 0 ) ) ) = ( C146 . ( fsloc ( 0 ) ) ) by L700 , L669 , SCMFSA_2:69;
L702: ( ( Comput (R8 , C146 , 3) ) . ( fsloc ( 0 ) ) ) = ( C146 . ( fsloc ( 0 ) ) ) by L701 , L672 , SCMFSA_2:63;
L703: ( ( Comput (R8 , C146 , 4) ) . ( fsloc ( 0 ) ) ) = ( C146 . ( fsloc ( 0 ) ) ) by L702 , L675 , SCMFSA_2:69;
L704: ( ( Comput (R8 , C146 , 5) ) . ( fsloc ( 0 ) ) ) = ( C146 . ( fsloc ( 0 ) ) ) by L703 , L683 , SCMFSA_2:63;
L705: ( ( Comput (R8 , C146 , 6) ) . ( fsloc ( 0 ) ) ) = ( C146 . ( fsloc ( 0 ) ) ) by L704 , L686 , SCMFSA_2:69;
L706: ( ( Comput (R8 , C146 , 7) ) . ( fsloc ( 0 ) ) ) = ( C146 . ( fsloc ( 0 ) ) ) by L705 , L689 , SCMFSA_2:63;
L707: ( ( Comput (R8 , C146 , 8) ) . ( fsloc ( 0 ) ) ) = ( C146 . ( fsloc ( 0 ) ) ) by L706 , L692 , SCMFSA_2:69;
L708: ( ( Comput (R8 , C146 , 9) ) . ( fsloc ( 0 ) ) ) = ( C146 . ( fsloc ( 0 ) ) ) by L707 , L695 , SCMFSA_2:63;
L709: ( ( Comput (R8 , C146 , 10) ) . ( fsloc ( 0 ) ) ) = ( C146 . ( fsloc ( 0 ) ) ) by L708 , L698 , SCMFSA_2:69;
L710: ( ( Comput (R8 , C146 , 3) ) . D149 ) = ( C146 . D149 ) by L679 , L672 , SCMFSA_2:63;
L711: ( ( Comput (R8 , C146 , 4) ) . D149 ) = ( C146 . D149 ) by L710 , L675 , SCMFSA_2:69;
L712: ( ( Comput (R8 , C146 , 5) ) . D153 ) = ( C146 . D149 ) by L711 , L683 , SCMFSA_2:63;
L713: ( ( Comput (R8 , C146 , 6) ) . D153 ) = ( C146 . D149 ) by L712 , L686 , SCMFSA_2:69;
L714: D153 <> D149 by SCMFSA_2:101;
L715: ( ( Comput (R8 , C146 , 5) ) . D149 ) = ( C146 . D149 ) by L714 , L711 , L683 , SCMFSA_2:63;
L716: ( ( Comput (R8 , C146 , 6) ) . D149 ) = ( C146 . D149 ) by L715 , L686 , SCMFSA_2:69;
L717: ( ( Comput (R8 , C146 , 7) ) . D154 ) = ( C146 . D149 ) by L716 , L689 , SCMFSA_2:63;
L718: ( ( Comput (R8 , C146 , 8) ) . D154 ) = ( C146 . D149 ) by L717 , L692 , SCMFSA_2:69;
L719: D153 <> D154 by SCMFSA_2:101;
L720: ( ( Comput (R8 , C146 , 7) ) . D153 ) = ( C146 . D149 ) by L719 , L713 , L689 , SCMFSA_2:63;
L721: ( ( Comput (R8 , C146 , 8) ) . D153 ) = ( C146 . D149 ) by L720 , L692 , SCMFSA_2:69;
L722: D153 <> D155 by SCMFSA_2:101;
L723: ( ( Comput (R8 , C146 , 9) ) . D153 ) = ( C146 . D149 ) by L722 , L721 , L695 , SCMFSA_2:63;
L724: ( ( Comput (R8 , C146 , 10) ) . D153 ) = ( C146 . D149 ) by L723 , L698 , SCMFSA_2:69;
L725: D154 <> D155 by SCMFSA_2:101;
L726: ( ( Comput (R8 , C146 , 9) ) . D154 ) = ( C146 . D149 ) by L725 , L718 , L695 , SCMFSA_2:63;
L727: ( ( Comput (R8 , C146 , 10) ) . D154 ) = ( C146 . D149 ) by L726 , L698 , SCMFSA_2:69;
L728: D154 <> D149 by SCMFSA_2:101;
L729: ( ( Comput (R8 , C146 , 7) ) . D149 ) = ( C146 . D149 ) by L728 , L716 , L689 , SCMFSA_2:63;
L730: ( ( Comput (R8 , C146 , 8) ) . D149 ) = ( C146 . D149 ) by L729 , L692 , SCMFSA_2:69;
L731: ( ( Comput (R8 , C146 , 9) ) . D155 ) = ( C146 . D149 ) by L730 , L695 , SCMFSA_2:63;
L732: ( ( Comput (R8 , C146 , 10) ) . D155 ) = ( C146 . D149 ) by L731 , L698 , SCMFSA_2:69;
L733: ( IC ( Comput (R8 , C146 , 10) ) ) = 10 by L698 , SCMFSA_2:69;
L734: ( Comput (R8 , C146 , ( 10 + 1 )) ) = ( Exec (( R8 . 10 ) , ( Comput (R8 , C146 , 10) )) ) by L733 , EXTPRO_1:6
.= ( Exec (( D150 :=len ( fsloc ( 0 ) ) ) , ( Comput (R8 , C146 , 10) )) ) by L664 , L630;
L735: ( ( Comput (R8 , C146 , 11) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC ( Comput (R8 , C146 , 10) ) ) ) by L734 , SCMFSA_2:74
.= 11 by L699;
L736: D155 <> D149 by SCMFSA_2:101;
L737: ( ( Comput (R8 , C146 , 9) ) . D149 ) = ( C146 . D149 ) by L736 , L730 , L695 , SCMFSA_2:63;
L738: ( ( Comput (R8 , C146 , 10) ) . D149 ) = ( C146 . D149 ) by L737 , L698 , SCMFSA_2:69;
thus L739:now
let C147 being (Element of ( NAT ));
assume that
L740: C147 > ( 0 )
and
L741: C147 < 12;
set D322 = ( ( Comput (R8 , C146 , C147) ) . ( IC ( SCM+FSA ) ) );
set D323 = C147;
set D324 = ( ( Comput (R8 , C146 , C147) ) . D149 );
set D325 = ( C146 . D149 );
set D326 = ( ( Comput (R8 , C146 , C147) ) . ( fsloc ( 0 ) ) );
set D327 = ( C146 . ( fsloc ( 0 ) ) );
L742: C147 < ( 11 + 1 ) by L741;
L743: C147 <= 11 by L742 , NAT_1:13;
per cases  by L740 , L743 , NAT_1:35;
suppose L744: C147 = 1;

thus L745: (D322 = D323 & D324 = D325 & D326 = D327) by L744 , L666 , L667 , L677 , SCMFSA_2:63;
end;
suppose L746: C147 = 2;

thus L747: (D322 = D323 & D324 = D325 & D326 = D327) by L746 , L678 , L700 , L669 , SCMFSA_2:69;
end;
suppose L748: C147 = 3;

thus L749: (D322 = D323 & D324 = D325 & D326 = D327) by L748 , L679 , L701 , L672 , L673 , SCMFSA_2:63;
end;
suppose L750: C147 = 4;

thus L751: (D322 = D323 & D324 = D325 & D326 = D327) by L750 , L710 , L702 , L675 , SCMFSA_2:69;
end;
suppose L752: C147 = 5;

thus L753: (D322 = D323 & D324 = D325 & D326 = D327) by L752 , L711 , L703 , L683 , L684 , L714 , SCMFSA_2:63;
end;
suppose L754: C147 = 6;

thus L755: (D322 = D323 & D324 = D325 & D326 = D327) by L754 , L715 , L704 , L686 , SCMFSA_2:69;
end;
suppose L756: C147 = 7;

thus L757: (D322 = D323 & D324 = D325 & D326 = D327) by L756 , L716 , L705 , L689 , L690 , L728 , SCMFSA_2:63;
end;
suppose L758: C147 = 8;

thus L759: (D322 = D323 & D324 = D325 & D326 = D327) by L758 , L729 , L706 , L692 , SCMFSA_2:69;
end;
suppose L760: C147 = 9;

thus L761: (D322 = D323 & D324 = D325 & D326 = D327) by L760 , L730 , L707 , L695 , L696 , L736 , SCMFSA_2:63;
end;
suppose L762: C147 = 10;

thus L763: (D322 = D323 & D324 = D325 & D326 = D327) by L762 , L737 , L708 , L698 , SCMFSA_2:69;
end;
suppose L764: C147 = 11;

thus L765: D322 = D323 by L764 , L735;
thus L766: D324 = D325 by L738 , L734 , L764 , SCMFSA_2:74;
thus L767: D326 = D327 by L709 , L734 , L764 , SCMFSA_2:74;
end;
end;
thus L769: ( ( Comput (R8 , C146 , 11) ) . D150 ) = ( len ( C146 . ( fsloc ( 0 ) ) ) ) by L709 , L734 , SCMFSA_2:74;
L770: ( ( Comput (R8 , C146 , 1) ) . D151 ) = ( C146 . D149 ) by L666 , SCMFSA_2:63;
L771: ( ( Comput (R8 , C146 , 2) ) . D151 ) = ( C146 . D149 ) by L770 , L669 , SCMFSA_2:69;
L772: D151 <> D152 by SCMFSA_2:101;
L773: ( ( Comput (R8 , C146 , 3) ) . D151 ) = ( C146 . D149 ) by L772 , L771 , L672 , SCMFSA_2:63;
L774: ( ( Comput (R8 , C146 , 4) ) . D151 ) = ( C146 . D149 ) by L773 , L675 , SCMFSA_2:69;
L775: D151 <> D153 by SCMFSA_2:101;
L776: ( ( Comput (R8 , C146 , 5) ) . D151 ) = ( C146 . D149 ) by L775 , L774 , L683 , SCMFSA_2:63;
L777: ( ( Comput (R8 , C146 , 6) ) . D151 ) = ( C146 . D149 ) by L776 , L686 , SCMFSA_2:69;
L778: D151 <> D154 by SCMFSA_2:101;
L779: ( ( Comput (R8 , C146 , 7) ) . D151 ) = ( C146 . D149 ) by L778 , L777 , L689 , SCMFSA_2:63;
L780: ( ( Comput (R8 , C146 , 8) ) . D151 ) = ( C146 . D149 ) by L779 , L692 , SCMFSA_2:69;
L781: D151 <> D155 by SCMFSA_2:101;
L782: ( ( Comput (R8 , C146 , 9) ) . D151 ) = ( C146 . D149 ) by L781 , L780 , L695 , SCMFSA_2:63;
L783: ( ( Comput (R8 , C146 , 10) ) . D151 ) = ( C146 . D149 ) by L782 , L698 , SCMFSA_2:69;
L784: D152 <> D153 by SCMFSA_2:101;
L785: ( ( Comput (R8 , C146 , 5) ) . D152 ) = ( C146 . D149 ) by L784 , L681 , L683 , SCMFSA_2:63;
L786: ( ( Comput (R8 , C146 , 6) ) . D152 ) = ( C146 . D149 ) by L785 , L686 , SCMFSA_2:69;
L787: D152 <> D154 by SCMFSA_2:101;
L788: ( ( Comput (R8 , C146 , 7) ) . D152 ) = ( C146 . D149 ) by L787 , L786 , L689 , SCMFSA_2:63;
L789: ( ( Comput (R8 , C146 , 8) ) . D152 ) = ( C146 . D149 ) by L788 , L692 , SCMFSA_2:69;
L790: D152 <> D155 by SCMFSA_2:101;
L791: ( ( Comput (R8 , C146 , 9) ) . D152 ) = ( C146 . D149 ) by L790 , L789 , L695 , SCMFSA_2:63;
L792: ( ( Comput (R8 , C146 , 10) ) . D152 ) = ( C146 . D149 ) by L791 , L698 , SCMFSA_2:69;
L793: D151 <> D150 by SCMFSA_2:101;
thus L794: ( ( Comput (R8 , C146 , 11) ) . D151 ) = ( C146 . D149 ) by L793 , L783 , L734 , SCMFSA_2:74;
L795: D152 <> D150 by SCMFSA_2:101;
thus L796: ( ( Comput (R8 , C146 , 11) ) . D152 ) = ( C146 . D149 ) by L795 , L792 , L734 , SCMFSA_2:74;
L797: D153 <> D150 by SCMFSA_2:101;
thus L798: ( ( Comput (R8 , C146 , 11) ) . D153 ) = ( C146 . D149 ) by L797 , L724 , L734 , SCMFSA_2:74;
L799: D154 <> D150 by SCMFSA_2:101;
thus L800: ( ( Comput (R8 , C146 , 11) ) . D154 ) = ( C146 . D149 ) by L799 , L727 , L734 , SCMFSA_2:74;
L801: D155 <> D150 by SCMFSA_2:101;
thus L802: thesis by L801 , L732 , L734 , SCMFSA_2:74;
end;
L803: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B152 being (State of ( SCM+FSA )) holds ((( B152 . D287 ) > ( 0 ) implies ( ( IExec (D306 , R8 , B152) ) . D284 ) = ( 0 )) & (( B152 . D287 ) <= ( 0 ) implies ( ( IExec (D306 , R8 , B152) ) . D284 ) = ( ( B152 . D284 ) - 1 )))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C148 being (State of ( SCM+FSA ));
set D328 = ( Initialized C148 );
set D329 = ( Exec (D304 , D328) );
thus L804:now
assume L805: ( C148 . D287 ) > ( 0 );
thus L806: ( ( IExec (D306 , R8 , C148) ) . D284 ) = ( ( IExec (D303 , R8 , C148) ) . D284 ) by L805 , SCM_HALT:44
.= ( ( IExec (D303 , R8 , C148) ) . D284 )
.= ( ( Exec (D302 , ( Initialized C148 )) ) . D284 ) by SCMFSA6C:5
.= ( ( Exec (D302 , ( Initialized C148 )) ) . D284 )
.= ( ( D328 . D284 ) - ( D328 . D284 ) ) by SCMFSA_2:65
.= ( 0 );
end;
L807: D284 <> D286 by SCMFSA_2:101;
L808: ( D329 . D284 ) = ( D328 . D284 ) by L807 , SCMFSA_2:64
.= ( C148 . D284 ) by SCMFSA_M:37;
L809: ( D329 . D149 ) = ( D328 . D149 ) by SCMFSA_2:64
.= 1 by SCMFSA_M:9;
thus L810:now
assume L811: ( C148 . D287 ) <= ( 0 );
thus L812: ( ( IExec (D306 , R8 , C148) ) . D284 ) = ( ( IExec (( D304 ";" D305 ) , R8 , C148) ) . D284 ) by L811 , SCM_HALT:44
.= ( ( Exec (D305 , D329) ) . D284 ) by SCMFSA6C:8
.= ( ( C148 . D284 ) - 1 ) by L808 , L809 , SCMFSA_2:65;
end;
end;
L811: (for B153 being (State of ( SCM+FSA )) holds (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (( ( IExec (D309 , R8 , B153) ) . D284 ) < ( B153 . D284 ) or ( ( IExec (D309 , R8 , B153) ) . D284 ) <= ( 0 ))))
proof
let C149 being (State of ( SCM+FSA ));
let R8 being (Instruction-Sequence of ( SCM+FSA ));
set D330 = ( Initialized C149 );
set D331 = ( Exec (D307 , D330) );
set D332 = ( IExec (( D307 ";" D308 ) , R8 , C149) );
L812: D287 <> D284 by SCMFSA_2:101;
L813: ( D332 . D284 ) = ( ( Exec (D308 , D331) ) . D284 ) by SCMFSA6C:8
.= ( D331 . D284 ) by L812 , SCMFSA_2:65
.= ( D330 . D284 ) by L812 , SCMFSA_2:72
.= ( C149 . D284 ) by SCMFSA_M:37;
per cases ;
suppose L814: ( D332 . D287 ) > ( 0 );

L815: ( ( IExec (D309 , R8 , C149) ) . D284 ) = ( ( IExec (D306 , R8 , D332) ) . D284 ) by SCM_HALT:20
.= ( 0 ) by L814 , L803;
thus L816: thesis by L815;
end;
suppose L817: ( D332 . D287 ) <= ( 0 );

L818: ( ( IExec (D309 , R8 , C149) ) . D284 ) = ( ( IExec (D306 , R8 , D332) ) . D284 ) by SCM_HALT:20
.= ( ( C149 . D284 ) - 1 ) by L813 , L817 , L803;
thus L819: thesis by L818 , XREAL_1:146;
end;
end;
L821: ( while>0 (D284 , D309) ) is  good  InitHalting  good  InitHalting  good  InitHalting  good  InitHalting (Program of ( SCM+FSA )) by L811 , L424;
L822: (not D295 destroy D286)
proof
L823: D286 <> D288 by SCMFSA_2:101;
L824: (not D291 destroy D286) by SCMFSA7B:14 , SCMFSA_2:101;
L825: (not D290 destroy D286) by SCMFSA7B:8 , SCMFSA_2:101;
L826: (not D289 destroy D286) by SCMFSA7B:6 , SCMFSA_2:101;
L827: (not ( ( D289 ";" D290 ) ";" D291 ) destroy D286) by L826 , L825 , L824 , SCMFSA8C:54 , SCMFSA8C:55;
L828: (not ( ( ( D289 ";" D290 ) ";" D291 ) ";" D292 ) destroy D286) by L827 , L823 , SCMFSA7B:14 , SCMFSA8C:54;
L829: (not ( ( ( ( D289 ";" D290 ) ";" D291 ) ";" D292 ) ";" D293 ) destroy D286) by L828 , SCMFSA7B:15 , SCMFSA8C:54;
thus L830: thesis by L829 , SCMFSA7B:15 , SCMFSA8C:54;
end;
L831: (not D295 destroy D283)
proof
L832: D283 <> D288 by SCMFSA_2:101;
L833: (not D291 destroy D283) by SCMFSA7B:14 , SCMFSA_2:101;
L834: (not D290 destroy D283) by SCMFSA7B:8 , SCMFSA_2:101;
L835: (not D289 destroy D283) by SCMFSA7B:6 , SCMFSA_2:101;
L836: (not ( ( D289 ";" D290 ) ";" D291 ) destroy D283) by L835 , L834 , L833 , SCMFSA8C:54 , SCMFSA8C:55;
L837: (not ( ( ( D289 ";" D290 ) ";" D291 ) ";" D292 ) destroy D283) by L836 , L832 , SCMFSA7B:14 , SCMFSA8C:54;
L838: (not ( ( ( ( D289 ";" D290 ) ";" D291 ) ";" D292 ) ";" D293 ) destroy D283) by L837 , SCMFSA7B:15 , SCMFSA8C:54;
thus L839: thesis by L838 , SCMFSA7B:15 , SCMFSA8C:54;
end;
L840: (not D309 destroy D283)
proof
L841: D283 <> D284 by SCMFSA_2:101;
L842: (not D303 destroy D283) by L841 , SCMFSA7B:8 , SCMFSA8C:48;
L843: (not D305 destroy D283) by SCMFSA7B:8 , SCMFSA_2:101;
L844: (not D304 destroy D283) by SCMFSA7B:7 , SCMFSA_2:101;
L845: (not ( D304 ";" D305 ) destroy D283) by L844 , L843 , SCMFSA8C:55;
L846: (not D306 destroy D283) by L845 , L842 , SCMFSA8C:88;
L847: (not D308 destroy D283) by SCMFSA7B:8 , SCMFSA_2:101;
L848: (not D307 destroy D283) by SCMFSA7B:14 , SCMFSA_2:101;
L849: (not ( D307 ";" D308 ) destroy D283) by L848 , L847 , SCMFSA8C:55;
thus L850: thesis by L849 , L846 , SCMFSA8C:52;
end;
L851: (not D318 destroy D283)
proof
L852: (not D312 destroy D283) by SCMFSA7B:6 , SCMFSA_2:101;
L853: D283 <> D285 by SCMFSA_2:101;
L854: (not D311 destroy D283) by SCMFSA7B:8 , SCMFSA_2:101;
L855: (not D310 destroy D283) by SCMFSA7B:16 , SCMFSA_2:101;
L856: (not ( ( D310 ";" D311 ) ";" D312 ) destroy D283) by L855 , L854 , L852 , SCMFSA8C:54 , SCMFSA8C:55;
L857: (not ( ( ( D310 ";" D311 ) ";" D312 ) ";" D313 ) destroy D283) by L856 , L853 , SCMFSA7B:7 , SCMFSA8C:54;
L858: D283 <> D286 by SCMFSA_2:101;
L859: D283 <> D288 by SCMFSA_2:101;
L860: (not ( ( ( ( D310 ";" D311 ) ";" D312 ) ";" D313 ) ";" D314 ) destroy D283) by L859 , L857 , SCMFSA7B:14 , SCMFSA8C:54;
L861: (not D317 destroy D283) by L860 , L858 , SCMFSA7B:8 , SCMFSA8C:54;
L862: (not D316 destroy D283) by L840 , L83;
L863: (not ( D317 ";" D316 ) destroy D283) by L862 , L861 , SCMFSA8C:52;
L864: (not D301 destroy D283) by L831 , SCMBSORT:1 , SCMFSA_2:101;
thus L865: thesis by L864 , L863 , SCMFSA8C:52;
end;
L866: ( Times (D286 , D295) ) is  good  InitHalting
proof
thus L867: ( Times (D286 , D295) ) is  good;
let C150 being (State of ( SCM+FSA ));
assume that
L868: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= C150;
let C151 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L869: ( Times (D286 , D295) ) c= C151;
L870: ( C151 +* ( Times (D286 , D295) ) ) = C151 by L869 , FUNCT_4:98;
L871: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCT_4:25;
L872: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C150 by L871 , L868 , XBOOLE_1:1;
L873: ( Initialize C150 ) = C150 by L872 , FUNCT_4:98;
L874: (not D295 destroy D286) by L822;
L875: ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) = { ( intloc ( 0 ) ) } by FUNCOP_1:13;
L876: ( intloc ( 0 ) ) in ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) by L875 , TARSKI:def 1;
L877: ( IC ( SCM+FSA ) ) <> ( intloc ( 0 ) ) by SCMFSA_2:56;
L878: ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L879: (not ( intloc ( 0 ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L878 , L877 , TARSKI:def 1;
L880: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) \/ ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) ) by FUNCT_4:def 1;
L881: ( intloc ( 0 ) ) in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L880 , L876 , XBOOLE_0:def 3;
L882: ( C150 . ( intloc ( 0 ) ) ) = ( ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) . ( intloc ( 0 ) ) ) by L881 , L868 , GRFUNC_1:2
.= ( ( ( intloc ( 0 ) ) .--> 1 ) . ( intloc ( 0 ) ) ) by L879 , FUNCT_4:11
.= 1 by FUNCOP_1:72;
L883: ( Times (D286 , D295) ) is_halting_on C150 , C151 by L882 , L874 , SCM_HALT:62;
L884: ( C151 +* ( Times (D286 , D295) ) ) halts_on ( Initialize C150 ) by L883 , SCMFSA7B:def 7;
thus L885: C151 halts_on C150 by L884 , L870 , L873;
end;
L886: D318 is  good  InitHalting  good  InitHalting  good  InitHalting  good  InitHalting (Program of ( SCM+FSA ))
proof
reconsider D333 = D301 as  good  InitHalting (Program of ( SCM+FSA )) by L866;
reconsider D334 = D316 as  good  InitHalting (Program of ( SCM+FSA )) by L811 , L424;
reconsider D335 = ( ( ( D310 ";" D311 ) ";" D312 ) ";" D313 ) as  good  InitHalting (Program of ( SCM+FSA ));
reconsider D336 = ( ( D335 ";" D314 ) ";" D315 ) as  good  InitHalting (Program of ( SCM+FSA ));
L887: ( ( D336 ";" D334 ) ";" D333 ) is  good  InitHalting;
thus L888: thesis by L887;
end;
L889: ( Times (D283 , D318) ) is  good  InitHalting
proof
thus L890: ( Times (D283 , D318) ) is  good;
let C152 being (State of ( SCM+FSA ));
assume that
L891: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= C152;
let C153 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L892: ( Times (D283 , D318) ) c= C153;
L893: ( C153 +* ( Times (D283 , D318) ) ) = C153 by L892 , FUNCT_4:98;
L894: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCT_4:25;
L895: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C152 by L894 , L891 , XBOOLE_1:1;
L896: ( Initialize C152 ) = C152 by L895 , FUNCT_4:98;
L897: (not D318 destroy D283) by L851;
L898: ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) = { ( intloc ( 0 ) ) } by FUNCOP_1:13;
L899: ( intloc ( 0 ) ) in ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) by L898 , TARSKI:def 1;
L900: ( IC ( SCM+FSA ) ) <> ( intloc ( 0 ) ) by SCMFSA_2:56;
L901: ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L902: (not ( intloc ( 0 ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by L901 , L900 , TARSKI:def 1;
L903: D318 is  good  InitHalting  good  InitHalting  good  InitHalting  good  InitHalting (Program of ( SCM+FSA )) by L886;
L904: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) \/ ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) ) by FUNCT_4:def 1;
L905: ( intloc ( 0 ) ) in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L904 , L899 , XBOOLE_0:def 3;
L906: ( C152 . ( intloc ( 0 ) ) ) = ( ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) . ( intloc ( 0 ) ) ) by L905 , L891 , GRFUNC_1:2
.= ( ( ( intloc ( 0 ) ) .--> 1 ) . ( intloc ( 0 ) ) ) by L902 , FUNCT_4:11
.= 1 by FUNCOP_1:72;
L907: ( Times (D283 , D318) ) is_halting_on C152 , C153 by L906 , L897 , L903 , SCM_HALT:62;
L908: ( C153 +* ( Times (D283 , D318) ) ) halts_on ( Initialize C152 ) by L907 , SCMFSA7B:def 7;
thus L909: C153 halts_on C152 by L908 , L893 , L896;
end;
theorem
L910: ( insert-sort ( fsloc ( 0 ) ) ) is  keepInt0_1  InitHalting by L889;
L911: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B154 being (State of ( SCM+FSA )) holds ( ( IExec (D306 , R8 , B154) ) . D282 ) = ( B154 . D282 )))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C154 being (State of ( SCM+FSA ));
set D337 = ( Initialized C154 );
per cases ;
suppose L912: ( C154 . D287 ) > ( 0 );

thus L913: ( ( IExec (D306 , R8 , C154) ) . D282 ) = ( ( IExec (D303 , R8 , C154) ) . D282 ) by L912 , SCM_HALT:44
.= ( ( IExec (D303 , R8 , C154) ) . D282 )
.= ( ( Exec (D302 , D337) ) . D282 ) by SCMFSA6C:5
.= ( ( Exec (D302 , D337) ) . D282 )
.= ( D337 . D282 ) by SCMFSA_2:65
.= ( C154 . D282 ) by SCMFSA_M:37;
end;
suppose L914: ( C154 . D287 ) <= ( 0 );

thus L915: ( ( IExec (D306 , R8 , C154) ) . D282 ) = ( ( IExec (( D304 ";" D305 ) , R8 , C154) ) . D282 ) by L914 , SCM_HALT:44
.= ( ( Exec (D305 , ( Exec (D304 , D337) )) ) . D282 ) by SCMFSA6C:9
.= ( ( Exec (D304 , D337) ) . D282 ) by SCMFSA_2:65
.= ( D337 . D282 ) by SCMFSA_2:64
.= ( C154 . D282 ) by SCMFSA_M:37;
end;
end;
L917: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B155 being (State of ( SCM+FSA )) holds ((( B155 . D287 ) > ( 0 ) implies ( ( IExec (D306 , R8 , B155) ) . D286 ) = ( B155 . D286 )) & (( B155 . D287 ) <= ( 0 ) implies ( ( IExec (D306 , R8 , B155) ) . D286 ) = ( ( B155 . D286 ) + 1 )))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C155 being (State of ( SCM+FSA ));
set D338 = ( Initialized C155 );
L918: D284 <> D286 by SCMFSA_2:101;
thus L919:now
assume L920: ( C155 . D287 ) > ( 0 );
thus L921: ( ( IExec (D306 , R8 , C155) ) . D286 ) = ( ( IExec (D303 , R8 , C155) ) . D286 ) by L920 , SCM_HALT:44
.= ( ( IExec (D303 , R8 , C155) ) . D286 )
.= ( ( Exec (D302 , D338) ) . D286 ) by SCMFSA6C:5
.= ( ( Exec (D302 , D338) ) . D286 )
.= ( D338 . D286 ) by L918 , SCMFSA_2:65
.= ( C155 . D286 ) by SCMFSA_M:37;
end;
assume L922: ( C155 . D287 ) <= ( 0 );
thus L923: ( ( IExec (D306 , R8 , C155) ) . D286 ) = ( ( IExec (( D304 ";" D305 ) , R8 , C155) ) . D286 ) by L922 , SCM_HALT:44
.= ( ( Exec (D305 , ( Exec (D304 , D338) )) ) . D286 ) by SCMFSA6C:8
.= ( ( Exec (D304 , D338) ) . D286 ) by L918 , SCMFSA_2:65
.= ( ( D338 . D286 ) + ( D338 . D149 ) ) by SCMFSA_2:64
.= ( ( D338 . D286 ) + 1 ) by SCMFSA_M:9
.= ( ( C155 . D286 ) + 1 ) by SCMFSA_M:37;
end;
L924: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B156 being  read-write Int-Location holds (for B157 being (State of ( SCM+FSA )) holds ((B156 <> D286 & B156 <> D284) implies ( ( IExec (D306 , R8 , B157) ) . B156 ) = ( B157 . B156 )))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C156 being  read-write Int-Location;
let C157 being (State of ( SCM+FSA ));
assume that
L925: C156 <> D286
and
L926: C156 <> D284;
set D339 = ( Exec (D304 , ( Initialized C157 )) );
set D340 = ( IExec (( D304 ";" D305 ) , R8 , C157) );
L927: ( D339 . C156 ) = ( ( Initialized C157 ) . C156 ) by L925 , SCMFSA_2:64
.= ( C157 . C156 ) by SCMFSA_M:37;
L928: ( D340 . C156 ) = ( ( Exec (D305 , D339) ) . C156 ) by SCMFSA6C:8
.= ( C157 . C156 ) by L926 , L927 , SCMFSA_2:65;
per cases ;
suppose L929: ( C157 . D287 ) > ( 0 );

thus L930: ( ( IExec (D306 , R8 , C157) ) . C156 ) = ( ( IExec (D303 , R8 , C157) ) . C156 ) by L929 , SCM_HALT:44
.= ( ( IExec (D303 , R8 , C157) ) . C156 )
.= ( ( Exec (D302 , ( Initialized C157 )) ) . C156 ) by SCMFSA6C:5
.= ( ( Exec (D302 , ( Initialized C157 )) ) . C156 )
.= ( ( Initialized C157 ) . C156 ) by L926 , SCMFSA_2:65
.= ( C157 . C156 ) by SCMFSA_M:37;
end;
suppose L931: ( C157 . D287 ) <= ( 0 );

thus L932: thesis by L931 , L928 , SCM_HALT:44;
end;
end;
L934: (for B158 being (State of ( SCM+FSA )) holds (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds ((( B158 . D284 ) >= 1 & ( B158 . D284 ) <= ( len ( B158 . D282 ) )) implies (( ( IExec (D309 , R11 , B158) ) . D285 ) = ( B158 . D285 ) & ( ( IExec (D309 , R11 , B158) ) . D288 ) = ( B158 . D288 ) & ( ( IExec (D309 , R11 , B158) ) . D282 ) = ( B158 . D282 ) & (ex B159 being Integer st (B159 = ( ( B158 . D282 ) . ( B158 . D284 ) ) & (( B159 - ( B158 . D288 ) ) > ( 0 ) implies (( ( IExec (D309 , R11 , B158) ) . D284 ) = ( 0 ) & ( ( IExec (D309 , R11 , B158) ) . D286 ) = ( B158 . D286 ))) & (( B159 - ( B158 . D288 ) ) <= ( 0 ) implies (( ( IExec (D309 , R11 , B158) ) . D284 ) = ( ( B158 . D284 ) - 1 ) & ( ( IExec (D309 , R11 , B158) ) . D286 ) = ( ( B158 . D286 ) + 1 )))))))))
proof
let C158 being (State of ( SCM+FSA ));
let R8 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L935: ( C158 . D284 ) >= 1
and
L936: ( C158 . D284 ) <= ( len ( C158 . D282 ) );
L937: ( abs ( C158 . D284 ) ) = ( C158 . D284 ) by L935 , ABSVALUE:def 1;
set D341 = ( Initialized C158 );
set D342 = ( Exec (D307 , D341) );
set D343 = ( IExec (( D307 ";" D308 ) , R8 , C158) );
L938: D286 <> D285 by SCMFSA_2:101;
reconsider D344 = ( C158 . D284 ) as (Element of ( NAT )) by L935 , INT_1:3;
reconsider D345 = ( ( C158 . D282 ) . D344 ) as Integer;
L939: ( ( C158 . D282 ) /. D344 ) = D345 by L935 , L936 , FINSEQ_4:15;
L940: ( D342 . D287 ) = ( ( D341 . D282 ) /. ( abs ( D341 . D284 ) ) ) by SCMBSORT:2
.= ( ( D341 . D282 ) /. ( abs ( C158 . D284 ) ) ) by SCMFSA_M:37
.= D345 by L937 , L939 , SCMFSA_M:37;
L941: D284 <> D285 by SCMFSA_2:101;
L942: D287 <> D288 by SCMFSA_2:101;
L943: ( D342 . D288 ) = ( D341 . D288 ) by L942 , SCMFSA_2:72
.= ( C158 . D288 ) by SCMFSA_M:37;
L944: D287 <> D285 by SCMFSA_2:101;
L945: ( D343 . D287 ) = ( ( Exec (D308 , D342) ) . D287 ) by SCMFSA6C:8
.= ( D345 - ( C158 . D288 ) ) by L943 , L940 , SCMFSA_2:65;
thus L946: ( ( IExec (D309 , R8 , C158) ) . D285 ) = ( ( IExec (D306 , R8 , D343) ) . D285 ) by SCM_HALT:20
.= ( D343 . D285 ) by L938 , L941 , L924
.= ( ( Exec (D308 , D342) ) . D285 ) by SCMFSA6C:8
.= ( D342 . D285 ) by L944 , SCMFSA_2:65
.= ( D341 . D285 ) by L944 , SCMFSA_2:72
.= ( C158 . D285 ) by SCMFSA_M:37;
L947: D286 <> D288 by SCMFSA_2:101;
L948: D284 <> D288 by SCMFSA_2:101;
thus L949: ( ( IExec (D309 , R8 , C158) ) . D288 ) = ( ( IExec (D306 , R8 , D343) ) . D288 ) by SCM_HALT:20
.= ( D343 . D288 ) by L947 , L948 , L924
.= ( ( Exec (D308 , D342) ) . D288 ) by SCMFSA6C:8
.= ( C158 . D288 ) by L942 , L943 , SCMFSA_2:65;
L950: D287 <> D286 by SCMFSA_2:101;
thus L951: ( ( IExec (D309 , R8 , C158) ) . D282 ) = ( ( IExec (D306 , R8 , D343) ) . D282 ) by SCM_HALT:21
.= ( D343 . D282 ) by L911
.= ( ( Exec (D308 , D342) ) . D282 ) by SCMFSA6C:9
.= ( D342 . D282 ) by SCMFSA_2:65
.= ( D341 . D282 ) by SCMFSA_2:72
.= ( C158 . D282 ) by SCMFSA_M:37;
take D345;
L952: D287 <> D284 by SCMFSA_2:101;
thus L953: D345 = ( ( C158 . D282 ) . ( C158 . D284 ) );
L954: ( D343 . D286 ) = ( ( Exec (D308 , D342) ) . D286 ) by SCMFSA6C:8
.= ( D342 . D286 ) by L950 , SCMFSA_2:65
.= ( D341 . D286 ) by L950 , SCMFSA_2:72
.= ( C158 . D286 ) by SCMFSA_M:37;
thus L955:now
assume L956: ( D345 - ( C158 . D288 ) ) > ( 0 );
thus L957: ( ( IExec (D309 , R8 , C158) ) . D284 ) = ( ( IExec (D306 , R8 , D343) ) . D284 ) by SCM_HALT:20
.= ( 0 ) by L945 , L956 , L803;
thus L958: ( ( IExec (D309 , R8 , C158) ) . D286 ) = ( ( IExec (D306 , R8 , D343) ) . D286 ) by SCM_HALT:20
.= ( C158 . D286 ) by L954 , L945 , L956 , L917;
end;
L959: ( D343 . D284 ) = ( ( Exec (D308 , D342) ) . D284 ) by SCMFSA6C:8
.= ( D342 . D284 ) by L952 , SCMFSA_2:65
.= ( D341 . D284 ) by L952 , SCMFSA_2:72
.= ( C158 . D284 ) by SCMFSA_M:37;
assume L960: ( D345 - ( C158 . D288 ) ) <= ( 0 );
thus L961: ( ( IExec (D309 , R8 , C158) ) . D284 ) = ( ( IExec (D306 , R8 , D343) ) . D284 ) by SCM_HALT:20
.= ( ( C158 . D284 ) - 1 ) by L959 , L945 , L960 , L803;
thus L962: ( ( IExec (D309 , R8 , C158) ) . D286 ) = ( ( IExec (D306 , R8 , D343) ) . D286 ) by SCM_HALT:20
.= ( ( C158 . D286 ) + 1 ) by L954 , L945 , L960 , L917;
end;
L963: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B160 being (Element of ( NAT )) holds (for B161 being (State of ( SCM+FSA )) holds ((( B161 . D284 ) = B160 & ( B161 . D284 ) <= ( len ( B161 . D282 ) )) implies (( B161 . D282 ) = ( ( IExec (D316 , R8 , B161) ) . D282 ) & ( B161 . D285 ) = ( ( IExec (D316 , R8 , B161) ) . D285 ) & (B160 = ( 0 ) or (ex B162 being (Element of ( NAT )) st (ex B163 being Integer st (B162 = ( ( ( IExec (D316 , R8 , B161) ) . D286 ) - ( B161 . D286 ) ) & B162 <= B160 & (( B160 - B162 ) >= 1 implies (B163 = ( ( B161 . D282 ) . ( B160 - B162 ) ) & B163 >= ( B161 . D288 ))) & (for B164 being (Element of ( NAT )) holds ((B164 > ( B160 - B162 ) & B164 < ( B160 + 1 )) implies (ex B165 being Integer st (B165 = ( ( B161 . D282 ) . B164 ) & B165 <= ( B161 . D288 ))))))))))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
defpred S6[ (Element of ( NAT )) ] means (for B166 being (State of ( SCM+FSA )) holds ((( B166 . D284 ) = $1 & ( B166 . D284 ) <= ( len ( B166 . D282 ) )) implies (( ( IExec (D316 , R8 , B166) ) . D282 ) = ( B166 . D282 ) & ( ( IExec (D316 , R8 , B166) ) . D285 ) = ( B166 . D285 ) & ($1 = ( 0 ) or (ex B167 being (Element of ( NAT )) st (ex B168 being Integer st (B167 = ( ( ( IExec (D316 , R8 , B166) ) . D286 ) - ( B166 . D286 ) ) & B167 <= $1 & (( $1 - B167 ) >= 1 implies (B168 = ( ( B166 . D282 ) . ( $1 - B167 ) ) & B168 >= ( B166 . D288 ))) & (for B169 being (Element of ( NAT )) holds ((B169 > ( $1 - B167 ) & B169 < ( $1 + 1 )) implies (ex B170 being Integer st (B170 = ( ( B166 . D282 ) . B169 ) & B170 <= ( B166 . D288 ))))))))))));
L964:
now
let C159 being (Element of ( NAT ));
assume L965: S6[ C159 ];
L966:
now
let C160 being (State of ( SCM+FSA ));
assume that
L967: ( C160 . D284 ) = ( C159 + 1 )
and
L968: ( C160 . D284 ) <= ( len ( C160 . D282 ) );
set D346 = ( IExec (D309 , R8 , C160) );
set D347 = ( Initialized D346 );
L969: ( C160 . D284 ) >= ( 1 + ( 0 ) ) by L967 , INT_1:7;
consider C161 being Integer such that L970: C161 = ( ( C160 . D282 ) . ( C160 . D284 ) ) and L971: (( C161 - ( C160 . D288 ) ) > ( 0 ) implies (( D346 . D284 ) = ( 0 ) & ( D346 . D286 ) = ( C160 . D286 ))) and L972: (( C161 - ( C160 . D288 ) ) <= ( 0 ) implies (( D346 . D284 ) = ( ( C160 . D284 ) - 1 ) & ( D346 . D286 ) = ( ( C160 . D286 ) + 1 ))) by L969 , L968 , L934;
reconsider D348 = D316 as  good  InitHalting (Program of ( SCM+FSA )) by L811 , L424;
per cases ;
suppose L973: ( C161 - ( C160 . D288 ) ) > ( 0 );

thus L974: ( ( IExec (D316 , R8 , C160) ) . D282 ) = ( ( IExec (D348 , R8 , D346) ) . D282 ) by L967 , L584
.= ( D346 . D282 ) by L971 , L973 , L574
.= ( C160 . D282 ) by L968 , L969 , L934;
thus L975: ( ( IExec (D316 , R8 , C160) ) . D285 ) = ( ( IExec (D348 , R8 , D346) ) . D285 ) by L967 , L591
.= ( D347 . D285 ) by L971 , L973 , L579
.= ( D346 . D285 ) by SCMFSA_M:37
.= ( C160 . D285 ) by L968 , L969 , L934;
L976: ( ( IExec (D316 , R8 , C160) ) . D286 ) = ( ( IExec (D348 , R8 , D346) ) . D286 ) by L967 , L591
.= ( D347 . D286 ) by L971 , L973 , L579
.= ( C160 . D286 ) by L971 , L973 , SCMFSA_M:37;
L977:
now
take D349 = ( 0 );
take D350 = C161;
thus L978: D349 = ( ( ( IExec (D316 , R8 , C160) ) . D286 ) - ( C160 . D286 ) ) by L976;
thus L979: D349 <= ( C159 + 1 );
thus L980: (( ( C159 + 1 ) - D349 ) >= 1 implies (D350 = ( ( C160 . D282 ) . ( ( C159 + 1 ) - D349 ) ) & D350 >= ( (( 0 ) qua Nat) + ( C160 . D288 ) ))) by L967 , L970 , L973 , XREAL_1:19;
thus L981: (for B171 being (Element of ( NAT )) holds ((B171 > ( ( C159 + 1 ) - D349 ) & B171 < ( ( C159 + 1 ) + 1 )) implies (ex B172 being Integer st (B172 = ( ( C160 . D282 ) . B171 ) & B172 <= ( C160 . D288 ))))) by INT_1:7;
end;
thus L982: (( C159 + 1 ) = ( 0 ) or (ex B173 being (Element of ( NAT )) st (ex B174 being Integer st (B173 = ( ( ( IExec (D316 , R8 , C160) ) . D286 ) - ( C160 . D286 ) ) & B173 <= ( C159 + 1 ) & (( ( C159 + 1 ) - B173 ) >= 1 implies (B174 = ( ( C160 . D282 ) . ( ( C159 + 1 ) - B173 ) ) & B174 >= ( C160 . D288 ))) & (for B175 being (Element of ( NAT )) holds ((B175 > ( ( C159 + 1 ) - B173 ) & B175 < ( ( C159 + 1 ) + 1 )) implies (ex B176 being Integer st (B176 = ( ( C160 . D282 ) . B175 ) & B176 <= ( C160 . D288 ))))))))) by L977;
end;
suppose L983: ( C161 - ( C160 . D288 ) ) <= ( 0 );

L984: ( D346 . D284 ) < ( C159 + 1 ) by L967 , L971 , L972 , XREAL_1:29;
L985: ( D346 . D284 ) <= ( len ( C160 . D282 ) ) by L984 , L967 , L968 , XXREAL_0:2;
L986: ( D346 . D282 ) = ( C160 . D282 ) by L968 , L969 , L934;
thus L987: ( ( IExec (D316 , R8 , C160) ) . D282 ) = ( ( IExec (D348 , R8 , D346) ) . D282 ) by L967 , L584
.= ( C160 . D282 ) by L965 , L967 , L972 , L983 , L986 , L985;
thus L988: ( ( IExec (D316 , R8 , C160) ) . D285 ) = ( ( IExec (D348 , R8 , D346) ) . D285 ) by L967 , L591
.= ( D346 . D285 ) by L965 , L967 , L972 , L983 , L986 , L985
.= ( C160 . D285 ) by L968 , L969 , L934;
thus L989:now
per cases ;
suppose L990: C159 <> ( 0 );

consider C162 being (Element of ( NAT )), C163 being Integer such that L991: C162 = ( ( ( IExec (D316 , R8 , D346) ) . D286 ) - ( D346 . D286 ) ) and L992: C162 <= C159 and L993: (( C159 - C162 ) >= 1 implies (C163 = ( ( D346 . D282 ) . ( C159 - C162 ) ) & C163 >= ( D346 . D288 ))) and L994: (for B177 being (Element of ( NAT )) holds ((B177 > ( C159 - C162 ) & B177 < ( C159 + 1 )) implies (ex B178 being Integer st (B178 = ( ( D346 . D282 ) . B177 ) & B178 <= ( D346 . D288 ))))) by L990 , L965 , L967 , L972 , L983 , L986 , L985;
L995: ( ( IExec (D348 , R8 , C160) ) . D286 ) = ( ( C160 . D286 ) + ( 1 + C162 ) ) by L967 , L972 , L983 , L991 , L591;
L996:
now
take D351 = ( 1 + C162 );
take D352 = C163;
thus L997: D351 = ( ( ( IExec (D316 , R8 , C160) ) . D286 ) - ( C160 . D286 ) ) by L995;
thus L998: D351 <= ( C159 + 1 ) by L992 , XREAL_1:6;
thus L999: (( ( C159 + 1 ) - D351 ) >= 1 implies (D352 = ( ( C160 . D282 ) . ( ( C159 + 1 ) - D351 ) ) & D352 >= ( C160 . D288 ))) by L968 , L969 , L993 , L934;
L1000:
now
let C164 being (Element of ( NAT ));
assume that
L1001: C164 > ( ( C159 + 1 ) - D351 )
and
L1002: C164 < ( ( C159 + 1 ) + 1 );
per cases ;
suppose L1003: C164 = ( C159 + 1 );

take D353 = C161;
thus L1004: D353 = ( ( C160 . D282 ) . C164 ) by L967 , L970 , L1003;
L1005: D353 <= ( (( 0 ) qua Nat) + ( C160 . D288 ) ) by L983 , XREAL_1:20;
thus L1006: D353 <= ( C160 . D288 ) by L1005;
end;
suppose L1007: C164 <> ( C159 + 1 );

L1008: C164 <= ( C159 + 1 ) by L1002 , INT_1:7;
L1009: C164 < ( C159 + 1 ) by L1008 , L1007 , XXREAL_0:1;
consider C165 being Integer such that L1010: C165 = ( ( D346 . D282 ) . C164 ) and L1011: C165 <= ( D346 . D288 ) by L1009 , L994 , L1001;
take D354 = C165;
thus L1012: D354 = ( ( C160 . D282 ) . C164 ) by L968 , L969 , L1010 , L934;
thus L1013: D354 <= ( C160 . D288 ) by L968 , L969 , L1011 , L934;
end;
end;
thus L1015: (for B179 being (Element of ( NAT )) holds ((B179 > ( ( C159 + 1 ) - D351 ) & B179 < ( ( C159 + 1 ) + 1 )) implies (ex B180 being Integer st (B180 = ( ( C160 . D282 ) . B179 ) & B180 <= ( C160 . D288 ))))) by L1000;
end;
thus L1016: (( C159 + 1 ) = ( 0 ) or (ex B181 being (Element of ( NAT )) st (ex B182 being Integer st (B181 = ( ( ( IExec (D316 , R8 , C160) ) . D286 ) - ( C160 . D286 ) ) & B181 <= ( C159 + 1 ) & (( ( C159 + 1 ) - B181 ) >= 1 implies (B182 = ( ( C160 . D282 ) . ( ( C159 + 1 ) - B181 ) ) & B182 >= ( C160 . D288 ))) & (for B183 being (Element of ( NAT )) holds ((B183 > ( ( C159 + 1 ) - B181 ) & B183 < ( ( C159 + 1 ) + 1 )) implies (ex B184 being Integer st (B184 = ( ( C160 . D282 ) . B183 ) & B184 <= ( C160 . D288 ))))))))) by L996;
end;
suppose L1017: C159 = ( 0 );

L1018: ( ( IExec (D348 , R8 , C160) ) . D286 ) = ( ( IExec (D316 , R8 , D346) ) . D286 ) by L967 , L591
.= ( D347 . D286 ) by L967 , L971 , L972 , L1017 , L579
.= ( ( C160 . D286 ) + 1 ) by L972 , L983 , SCMFSA_M:37;
L1019:
now
take D355 = 1;
take D356 = ( 0 );
thus L1020: D355 = ( ( ( IExec (D316 , R8 , C160) ) . D286 ) - ( C160 . D286 ) ) by L1018;
thus L1021: D355 <= ( C159 + 1 ) by L1017;
thus L1022: (( ( C159 + 1 ) - D355 ) >= 1 implies (D356 = ( ( C160 . D282 ) . ( ( C159 + 1 ) - D355 ) ) & D356 >= ( C160 . D288 ))) by L1017;
thus L1023:now
let C166 being (Element of ( NAT ));
assume that
L1024: C166 > ( ( C159 + 1 ) - D355 )
and
L1025: C166 < ( ( C159 + 1 ) + 1 );
take D357 = C161;
L1026: C166 >= ( ( 0 ) + 1 ) by L1024 , INT_1:7;
L1027: C166 <= 1 by L1017 , L1025 , INT_1:7;
thus L1028: D357 = ( ( C160 . D282 ) . C166 ) by L1027 , L967 , L970 , L1017 , L1026 , XXREAL_0:1;
L1029: D357 <= ( (( 0 ) qua Nat) + ( C160 . D288 ) ) by L983 , XREAL_1:20;
thus L1030: D357 <= ( C160 . D288 ) by L1029;
end;
end;
thus L1024: (( C159 + 1 ) = ( 0 ) or (ex B185 being (Element of ( NAT )) st (ex B186 being Integer st (B185 = ( ( ( IExec (D316 , R8 , C160) ) . D286 ) - ( C160 . D286 ) ) & B185 <= ( C159 + 1 ) & (( ( C159 + 1 ) - B185 ) >= 1 implies (B186 = ( ( C160 . D282 ) . ( ( C159 + 1 ) - B185 ) ) & B186 >= ( C160 . D288 ))) & (for B187 being (Element of ( NAT )) holds ((B187 > ( ( C159 + 1 ) - B185 ) & B187 < ( ( C159 + 1 ) + 1 )) implies (ex B188 being Integer st (B188 = ( ( C160 . D282 ) . B187 ) & B188 <= ( C160 . D288 ))))))))) by L1019;
end;
end;
end;
end;
thus L991: S6[ ( C159 + 1 ) ] by L966;
end;
L992: S6[ ( 0 ) ]
proof
let C167 being (State of ( SCM+FSA ));
set D358 = ( Initialized C167 );
assume that
L993: ( C167 . D284 ) = ( 0 )
and
L994: ( C167 . D284 ) <= ( len ( C167 . D282 ) );
thus L995: ( ( IExec (D316 , R8 , C167) ) . D282 ) = ( C167 . D282 ) by L993 , L574;
thus L996: ( ( IExec (D316 , R8 , C167) ) . D285 ) = ( D358 . D285 ) by L993 , L579
.= ( C167 . D285 ) by SCMFSA_M:37;
thus L997: thesis;
end;
L998: (for B189 being (Element of ( NAT )) holds S6[ B189 ]) from NAT_1:sch 1(L992 , L964);
thus L999: thesis by L998;
end;
L1000: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B190 being (State of ( SCM+FSA )) holds (( ( IExec (D295 , R8 , B190) ) . D285 ) = ( ( B190 . D285 ) - 1 ) & ( ( IExec (D295 , R8 , B190) ) . D282 ) = ( ( ( B190 . D282 ) +* (( abs ( B190 . D285 ) ) , ( ( B190 . D282 ) /. ( abs ( ( B190 . D285 ) - 1 ) ) )) ) +* (( abs ( ( B190 . D285 ) - 1 ) ) , ( ( B190 . D282 ) /. ( abs ( B190 . D285 ) ) )) ))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C168 being (State of ( SCM+FSA ));
set D359 = ( Initialized C168 );
set D360 = ( Exec (D289 , D359) );
set D361 = ( IExec (( D289 ";" D290 ) , R8 , C168) );
set D362 = ( IExec (( ( D289 ";" D290 ) ";" D291 ) , R8 , C168) );
set D363 = ( IExec (( ( ( D289 ";" D290 ) ";" D291 ) ";" D292 ) , R8 , C168) );
set D364 = ( IExec (( ( ( ( D289 ";" D290 ) ";" D291 ) ";" D292 ) ";" D293 ) , R8 , C168) );
set D365 = ( IExec (D295 , R8 , C168) );
L1001: D288 <> D285 by SCMFSA_2:101;
L1002: ( D360 . D149 ) = ( D359 . D149 ) by SCMFSA_2:63
.= 1 by SCMFSA_M:9;
L1003: D288 <> D284 by SCMFSA_2:101;
L1004: D284 <> D285 by SCMFSA_2:101;
L1005: D288 <> D287 by SCMFSA_2:101;
L1006: D287 <> D284 by SCMFSA_2:101;
L1007: ( D361 . D284 ) = ( ( Exec (D290 , D360) ) . D284 ) by SCMFSA6C:8
.= ( D360 . D284 ) by L1004 , SCMFSA_2:65
.= ( D359 . D285 ) by SCMFSA_2:63
.= ( C168 . D285 ) by SCMFSA_M:37;
L1008: ( D363 . D284 ) = ( ( Exec (D292 , D362) ) . D284 ) by SCMFSA6C:6
.= ( D362 . D284 ) by L1003 , SCMFSA_2:72
.= ( ( Exec (D291 , D361) ) . D284 ) by SCMFSA6C:6
.= ( C168 . D285 ) by L1006 , L1007 , SCMFSA_2:72;
L1009: D287 <> D285 by SCMFSA_2:101;
L1010: ( D362 . D285 ) = ( ( Exec (D291 , D361) ) . D285 ) by SCMFSA6C:6
.= ( D361 . D285 ) by L1009 , SCMFSA_2:72
.= ( ( Exec (D290 , D360) ) . D285 ) by SCMFSA6C:8
.= ( ( D360 . D285 ) - ( D360 . D149 ) ) by SCMFSA_2:65
.= ( ( D359 . D285 ) - ( D360 . D149 ) ) by L1004 , SCMFSA_2:63
.= ( ( C168 . D285 ) - 1 ) by L1002 , SCMFSA_M:37;
L1011: ( D364 . D285 ) = ( ( Exec (D293 , D363) ) . D285 ) by SCMFSA6C:6
.= ( D363 . D285 ) by SCMFSA_2:73
.= ( ( Exec (D292 , D362) ) . D285 ) by SCMFSA6C:6
.= ( ( C168 . D285 ) - 1 ) by L1001 , L1010 , SCMFSA_2:72;
thus L1012: ( D365 . D285 ) = ( ( Exec (D294 , D364) ) . D285 ) by SCMFSA6C:6
.= ( ( C168 . D285 ) - 1 ) by L1011 , SCMFSA_2:73;
L1013: ( D361 . D282 ) = ( ( Exec (D290 , D360) ) . D282 ) by SCMFSA6C:9
.= ( D360 . D282 ) by SCMFSA_2:65
.= ( D359 . D282 ) by SCMFSA_2:63
.= ( C168 . D282 ) by SCMFSA_M:37;
L1014: ( D362 . D282 ) = ( ( Exec (D291 , D361) ) . D282 ) by SCMFSA6C:7
.= ( C168 . D282 ) by L1013 , SCMFSA_2:72;
L1015: ( D363 . D282 ) = ( ( Exec (D292 , D362) ) . D282 ) by SCMFSA6C:7
.= ( C168 . D282 ) by L1014 , SCMFSA_2:72;
L1016: ( D363 . D288 ) = ( ( Exec (D292 , D362) ) . D288 ) by SCMFSA6C:6
.= ( ( C168 . D282 ) /. ( abs ( ( C168 . D285 ) - 1 ) ) ) by L1010 , L1014 , SCMBSORT:2;
L1017: ( D364 . D282 ) = ( ( Exec (D293 , D363) ) . D282 ) by SCMFSA6C:7
.= ( ( C168 . D282 ) +* (( abs ( C168 . D285 ) ) , ( ( C168 . D282 ) /. ( abs ( ( C168 . D285 ) - 1 ) ) )) ) by L1015 , L1008 , L1016 , SCMBSORT:3;
L1018: ( D364 . D287 ) = ( ( Exec (D293 , D363) ) . D287 ) by SCMFSA6C:6
.= ( D363 . D287 ) by SCMFSA_2:73
.= ( ( Exec (D292 , D362) ) . D287 ) by SCMFSA6C:6
.= ( D362 . D287 ) by L1005 , SCMFSA_2:72
.= ( ( Exec (D291 , D361) ) . D287 ) by SCMFSA6C:6
.= ( ( C168 . D282 ) /. ( abs ( C168 . D285 ) ) ) by L1013 , L1007 , SCMBSORT:2;
thus L1019: ( D365 . D282 ) = ( ( Exec (D294 , D364) ) . D282 ) by SCMFSA6C:7
.= ( ( ( C168 . D282 ) +* (( abs ( C168 . D285 ) ) , ( ( C168 . D282 ) /. ( abs ( ( C168 . D285 ) - 1 ) ) )) ) +* (( abs ( ( C168 . D285 ) - 1 ) ) , ( ( C168 . D282 ) /. ( abs ( C168 . D285 ) ) )) ) by L1011 , L1018 , L1017 , SCMBSORT:3;
end;
L1020: (for B191 being (Element of ( NAT )) holds (for B192 being (State of ( SCM+FSA )) holds (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds ((( B192 . D286 ) = B191 & B191 < ( B192 . D285 ) & ( B192 . D285 ) <= ( len ( B192 . D282 ) )) implies (( B192 . D282 ) , ( ( IExec (D301 , R8 , B192) ) . D282 ) are_fiberwise_equipotent  & ( ( IExec (D301 , R8 , B192) ) . D285 ) = ( ( B192 . D285 ) - B191 ) & ( ( ( IExec (D301 , R8 , B192) ) . D282 ) . ( ( B192 . D285 ) - B191 ) ) = ( ( B192 . D282 ) . ( B192 . D285 ) ) & (for B193 being (Element of ( NAT )) holds ((( ( B192 . D285 ) - B191 ) < B193 & B193 <= ( B192 . D285 )) implies ( ( ( IExec (D301 , R8 , B192) ) . D282 ) . B193 ) = ( ( B192 . D282 ) . ( B193 - 1 ) ))) & (for B194 being (Element of ( NAT )) holds ((( B192 . D285 ) < B194 & B194 <= ( len ( B192 . D282 ) )) implies ( ( ( IExec (D301 , R8 , B192) ) . D282 ) . B194 ) = ( ( B192 . D282 ) . B194 ))) & (for B195 being (Element of ( NAT )) holds ((1 <= B195 & B195 < ( ( B192 . D285 ) - B191 )) implies ( ( ( IExec (D301 , R8 , B192) ) . D282 ) . B195 ) = ( ( B192 . D282 ) . B195 ))))))))
proof
defpred S7[ (Element of ( NAT )) ] means (for B196 being (State of ( SCM+FSA )) holds (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds ((( B196 . D286 ) = $1 & $1 < ( B196 . D285 ) & ( B196 . D285 ) <= ( len ( B196 . D282 ) )) implies (( B196 . D282 ) , ( ( IExec (D301 , R8 , B196) ) . D282 ) are_fiberwise_equipotent  & ( ( IExec (D301 , R8 , B196) ) . D285 ) = ( ( B196 . D285 ) - $1 ) & ( ( ( IExec (D301 , R8 , B196) ) . D282 ) . ( ( B196 . D285 ) - $1 ) ) = ( ( B196 . D282 ) . ( B196 . D285 ) ) & (for B197 being (Element of ( NAT )) holds ((( ( B196 . D285 ) - $1 ) < B197 & B197 <= ( B196 . D285 )) implies ( ( ( IExec (D301 , R8 , B196) ) . D282 ) . B197 ) = ( ( B196 . D282 ) . ( B197 - 1 ) ))) & (for B198 being (Element of ( NAT )) holds ((( B196 . D285 ) < B198 & B198 <= ( len ( B196 . D282 ) )) implies ( ( ( IExec (D301 , R8 , B196) ) . D282 ) . B198 ) = ( ( B196 . D282 ) . B198 ))) & (for B199 being (Element of ( NAT )) holds ((1 <= B199 & B199 < ( ( B196 . D285 ) - $1 )) implies ( ( ( IExec (D301 , R8 , B196) ) . D282 ) . B199 ) = ( ( B196 . D282 ) . B199 )))))));
L1021:
now
set D366 = ( SubFrom (D286 , D149) );
let C169 being (Element of ( NAT ));
assume L1022: S7[ C169 ];
L1023:
now
L1024: D286 <> D285 by SCMFSA_2:101;
let C170 being (State of ( SCM+FSA ));
let R8 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L1025: ( C170 . D286 ) = ( C169 + 1 )
and
L1026: ( C169 + 1 ) < ( C170 . D285 )
and
L1027: ( C170 . D285 ) <= ( len ( C170 . D282 ) );
L1028: ( ( C169 + 1 ) - 1 ) < ( ( C170 . D285 ) - 1 ) by L1026 , XREAL_1:9;
reconsider D367 = ( ( C170 . D285 ) - 1 ) as (Element of ( NAT )) by L1028 , INT_1:3;
L1029: D367 <= ( len ( C170 . D282 ) ) by L1027 , XREAL_1:146 , XXREAL_0:2;
set D368 = ( IExec (( D295 ";" D366 ) , R8 , C170) );
set D369 = ( IExec (D295 , R8 , C170) );
set D370 = ( C170 . D282 );
set D371 = ( D369 . D282 );
L1030: ( D368 . D286 ) = ( ( Exec (D366 , D369) ) . D286 ) by SCMFSA6C:6
.= ( ( D369 . D286 ) - ( D369 . D149 ) ) by SCMFSA_2:65
.= ( ( D369 . D286 ) - 1 ) by SCMFSA6B:11
.= ( ( ( Initialized C170 ) . D286 ) - 1 ) by L822 , SCMFSA8C:62
.= ( ( C169 + 1 ) - 1 ) by L1025 , SCMFSA_M:37
.= C169;
reconsider D372 = ( C170 . D285 ) as (Element of ( NAT )) by L1026 , INT_1:3;
L1031: ( ( 0 ) + 1 ) <= ( C169 + 1 ) by XREAL_1:6;
L1032: 1 <= D372 by L1031 , L1026 , XXREAL_0:2;
L1033: ( abs ( C170 . D285 ) ) = D372 by ABSVALUE:def 1;
L1034: ( ( C169 + 1 ) + 1 ) <= D372 by L1026 , INT_1:7;
L1035: ( ( ( C169 + 1 ) + 1 ) - 1 ) <= D367 by L1034 , XREAL_1:9;
L1036: 1 <= D367 by L1035 , L1031 , XXREAL_0:2;
L1037: ( ( IExec (D301 , R8 , C170) ) . D282 ) = ( ( IExec (D301 , R8 , D368) ) . D282 ) by L1025 , L822 , SCM_HALT:69;
L1038: ( D368 . D285 ) = ( ( Exec (D366 , D369) ) . D285 ) by SCMFSA6C:6
.= ( D369 . D285 ) by L1024 , SCMFSA_2:65
.= ( ( C170 . D285 ) - 1 ) by L1000;
L1039: ( ( D368 . D285 ) - C169 ) = ( ( C170 . D285 ) - ( C169 + 1 ) ) by L1038;
L1040: ( abs ( ( C170 . D285 ) - 1 ) ) = D367 by ABSVALUE:def 1;
L1041: ( D369 . D282 ) = ( ( ( C170 . D282 ) +* (D372 , ( ( C170 . D282 ) /. D367 )) ) +* (D367 , ( ( C170 . D282 ) /. D372 )) ) by L1040 , L1033 , L1000;
L1042: ( D370 . D372 ) = ( D371 . D367 ) by L1041 , L1027 , L1032 , L1036 , L1029 , FUNCT_7:113;
L1043: ( D368 . D282 ) = ( ( Exec (D366 , D369) ) . D282 ) by SCMFSA6C:7
.= ( D369 . D282 ) by SCMFSA_2:65;
L1044: D370 , ( D368 . D282 ) are_fiberwise_equipotent  by L1043 , L1027 , L1032 , L1036 , L1029 , L1041 , FUNCT_7:113;
L1045: D367 <= ( len ( D368 . D282 ) ) by L1044 , L1029 , RFINSEQ:3;
L1046: ( D368 . D282 ) , ( ( IExec (D301 , R8 , D368) ) . D282 ) are_fiberwise_equipotent  by L1045 , L1022 , L1030 , L1038 , L1028;
thus L1047: D370 , ( ( IExec (D301 , R8 , C170) ) . D282 ) are_fiberwise_equipotent  by L1046 , L1044 , L1037 , CLASSES1:76;
L1048: D370 , D371 are_fiberwise_equipotent  by L1027 , L1032 , L1036 , L1029 , L1041 , FUNCT_7:113;
L1049: ( len D370 ) = ( len ( D368 . D282 ) ) by L1048 , L1043 , RFINSEQ:3;
L1050: ( ( IExec (D301 , R8 , D368) ) . D285 ) = ( ( D368 . D285 ) - C169 ) by L1022 , L1030 , L1038 , L1028 , L1045;
thus L1051: ( ( IExec (D301 , R8 , C170) ) . D285 ) = ( ( C170 . D285 ) - ( C169 + 1 ) ) by L1050 , L1025 , L1038 , L822 , SCM_HALT:70;
L1052: ( ( ( IExec (D301 , R8 , D368) ) . D282 ) . ( ( D368 . D285 ) - C169 ) ) = ( ( D368 . D282 ) . ( D368 . D285 ) ) by L1022 , L1030 , L1038 , L1028 , L1045;
thus L1053: ( ( ( IExec (D301 , R8 , C170) ) . D282 ) . ( ( C170 . D285 ) - ( C169 + 1 ) ) ) = ( ( C170 . D282 ) . ( C170 . D285 ) ) by L1052 , L1025 , L1038 , L1043 , L1042 , L822 , SCM_HALT:69;
L1054: ( D370 . D367 ) = ( D371 . D372 ) by L1027 , L1032 , L1036 , L1029 , L1041 , FUNCT_7:113;
thus L1055:now
let C171 being (Element of ( NAT ));
assume that
L1056: ( ( C170 . D285 ) - ( C169 + 1 ) ) < C171
and
L1057: C171 <= ( C170 . D285 );
per cases ;
suppose L1058: C171 = ( C170 . D285 );

L1059: ( D368 . D285 ) < C171 by L1058 , L1038 , XREAL_1:146;
thus L1060: ( ( ( IExec (D301 , R8 , C170) ) . D282 ) . C171 ) = ( ( ( IExec (D301 , R8 , D368) ) . D282 ) . C171 ) by L1025 , L822 , SCM_HALT:69
.= ( ( C170 . D282 ) . ( C171 - 1 ) ) by L1022 , L1027 , L1030 , L1038 , L1028 , L1043 , L1029 , L1054 , L1049 , L1058 , L1059;
end;
suppose L1061: C171 <> ( C170 . D285 );

L1062: C171 < ( C170 . D285 ) by L1061 , L1057 , XXREAL_0:1;
L1063: ( C171 + 1 ) <= ( C170 . D285 ) by L1062 , INT_1:7;
L1064: C171 <= ( ( C170 . D285 ) - 1 ) by L1063 , XREAL_1:19;
L1065: C171 <= ( D368 . D285 ) by L1038 , L1063 , XREAL_1:19;
L1066: ( ( ( C170 . D285 ) - ( C169 + 1 ) ) + 1 ) <= C171 by L1056 , INT_1:7;
L1067: ( ( ( ( C170 . D285 ) - ( C169 + 1 ) ) + 1 ) - 1 ) <= ( C171 - 1 ) by L1066 , XREAL_1:9;
L1068: ( ( C169 + 1 ) - ( C169 + 1 ) ) < ( ( C170 . D285 ) - ( C169 + 1 ) ) by L1026 , XREAL_1:9;
reconsider D373 = ( C171 - 1 ) as (Element of ( NAT )) by L1068 , L1067 , INT_1:3;
L1069: ( C171 - 1 ) < ( C170 . D285 ) by L1057 , XREAL_1:146 , XXREAL_0:2;
L1070: D373 <= ( len ( C170 . D282 ) ) by L1069 , L1027 , XXREAL_0:2;
L1071: ( 1 + ( 0 ) ) <= ( ( C170 . D285 ) - ( C169 + 1 ) ) by L1068 , INT_1:7;
L1072: 1 <= ( C171 - 1 ) by L1071 , L1067 , XXREAL_0:2;
L1073: D373 in ( dom D370 ) by L1072 , L1070 , FINSEQ_3:25;
L1074: ( C171 - 1 ) < C171 by XREAL_1:146;
thus L1075: ( ( ( IExec (D301 , R8 , C170) ) . D282 ) . C171 ) = ( ( ( IExec (D301 , R8 , D368) ) . D282 ) . C171 ) by L1025 , L822 , SCM_HALT:69
.= ( ( D369 . D282 ) . ( C171 - 1 ) ) by L1022 , L1030 , L1028 , L1043 , L1029 , L1049 , L1039 , L1056 , L1065
.= ( ( C170 . D282 ) . ( C171 - 1 ) ) by L1027 , L1032 , L1036 , L1029 , L1041 , L1057 , L1064 , L1074 , L1073 , FUNCT_7:113;
end;
end;
thus L1077:now
L1078: 1 <= ( C169 + 1 ) by NAT_1:11;
let C172 being (Element of ( NAT ));
assume that
L1079: ( C170 . D285 ) < C172
and
L1080: C172 <= ( len ( C170 . D282 ) );
L1081: D367 <> C172 by L1079 , XREAL_1:146;
L1082: ( C169 + 1 ) < C172 by L1026 , L1079 , XXREAL_0:2;
L1083: 1 <= C172 by L1082 , L1078 , XXREAL_0:2;
L1084: C172 in ( dom D370 ) by L1083 , L1080 , FINSEQ_3:25;
L1085: ( D368 . D285 ) < C172 by L1038 , L1079 , XREAL_1:146 , XXREAL_0:2;
thus L1086: ( ( ( IExec (D301 , R8 , C170) ) . D282 ) . C172 ) = ( ( ( IExec (D301 , R8 , D368) ) . D282 ) . C172 ) by L1025 , L822 , SCM_HALT:69
.= ( ( D369 . D282 ) . C172 ) by L1022 , L1030 , L1038 , L1028 , L1043 , L1029 , L1049 , L1080 , L1085
.= ( ( C170 . D282 ) . C172 ) by L1027 , L1032 , L1036 , L1029 , L1041 , L1079 , L1081 , L1084 , FUNCT_7:113;
end;
thus L1087:now
let C173 being (Element of ( NAT ));
assume that
L1088: 1 <= C173
and
L1089: C173 < ( ( C170 . D285 ) - ( C169 + 1 ) );
L1090: ( ( ( C170 . D285 ) - 1 ) - C169 ) <= ( ( ( C170 . D285 ) - 1 ) - ( 0 ) ) by XREAL_1:13;
L1091: C173 <> D372 by L1090 , L1089 , XREAL_1:146 , XXREAL_0:2;
L1092: C173 < ( ( C170 . D285 ) - 1 ) by L1089 , L1090 , XXREAL_0:2;
L1093: C173 < ( C170 . D285 ) by L1092 , XREAL_1:146 , XXREAL_0:2;
L1094: C173 <= ( len ( C170 . D282 ) ) by L1093 , L1027 , XXREAL_0:2;
L1095: C173 in ( dom D370 ) by L1094 , L1088 , FINSEQ_3:25;
L1096: C173 < ( ( D368 . D285 ) - C169 ) by L1038 , L1089;
thus L1097: ( ( ( IExec (D301 , R8 , C170) ) . D282 ) . C173 ) = ( ( ( IExec (D301 , R8 , D368) ) . D282 ) . C173 ) by L1025 , L822 , SCM_HALT:69
.= ( ( D369 . D282 ) . C173 ) by L1022 , L1030 , L1038 , L1028 , L1043 , L1029 , L1049 , L1088 , L1096
.= ( ( C170 . D282 ) . C173 ) by L1027 , L1032 , L1036 , L1029 , L1041 , L1089 , L1090 , L1091 , L1095 , FUNCT_7:113;
end;
end;
thus L1088: S7[ ( C169 + 1 ) ] by L1023;
end;
L1089: S7[ ( 0 ) ]
proof
let C174 being (State of ( SCM+FSA ));
let R8 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L1090: ( C174 . D286 ) = ( 0 )
and
L1091: ( 0 ) < ( C174 . D285 )
and
L1092: ( C174 . D285 ) <= ( len ( C174 . D282 ) );
thus L1093: ( C174 . D282 ) , ( ( IExec (D301 , R8 , C174) ) . D282 ) are_fiberwise_equipotent  by L1090 , SCM_HALT:67;
thus L1094: ( ( IExec (D301 , R8 , C174) ) . D285 ) = ( ( Initialized C174 ) . D285 ) by L1090 , SCM_HALT:68
.= ( ( C174 . D285 ) - ( 0 ) ) by SCMFSA_M:37;
thus L1095: ( ( ( IExec (D301 , R8 , C174) ) . D282 ) . ( ( C174 . D285 ) - ( 0 ) ) ) = ( ( C174 . D282 ) . ( C174 . D285 ) ) by L1090 , SCM_HALT:67;
thus L1096: (for B200 being (Element of ( NAT )) holds ((( ( C174 . D285 ) - ( 0 ) ) < B200 & B200 <= ( C174 . D285 )) implies ( ( ( IExec (D301 , R8 , C174) ) . D282 ) . B200 ) = ( ( C174 . D282 ) . ( B200 - 1 ) )));
thus L1097: (for B201 being (Element of ( NAT )) holds ((( C174 . D285 ) < B201 & B201 <= ( len ( C174 . D282 ) )) implies ( ( ( IExec (D301 , R8 , C174) ) . D282 ) . B201 ) = ( ( C174 . D282 ) . B201 ))) by L1090 , SCM_HALT:67;
thus L1098: thesis by L1090 , SCM_HALT:67;
end;
L1099: (for B202 being (Element of ( NAT )) holds S7[ B202 ]) from NAT_1:sch 1(L1089 , L1021);
thus L1100: thesis by L1099;
end;
L1101: (for B203 being (State of ( SCM+FSA )) holds (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (( ( IExec (D317 , R8 , B203) ) . D284 ) = ( ( len ( B203 . D282 ) ) - ( B203 . D283 ) ) & ( ( IExec (D317 , R8 , B203) ) . D285 ) = ( ( ( len ( B203 . D282 ) ) - ( B203 . D283 ) ) + 1 ) & ( ( IExec (D317 , R8 , B203) ) . D282 ) = ( B203 . D282 ) & ( ( IExec (D317 , R8 , B203) ) . D286 ) = ( 0 ) & ( ( IExec (D317 , R8 , B203) ) . D288 ) = ( ( B203 . D282 ) /. ( abs ( ( ( len ( B203 . D282 ) ) - ( B203 . D283 ) ) + 1 ) ) ))))
proof
let C175 being (State of ( SCM+FSA ));
let R8 being (Instruction-Sequence of ( SCM+FSA ));
set D374 = ( Initialized C175 );
set D375 = ( Exec (D310 , D374) );
set D376 = ( IExec (( D310 ";" D311 ) , R8 , C175) );
set D377 = ( IExec (( ( D310 ";" D311 ) ";" D312 ) , R8 , C175) );
set D378 = ( IExec (( ( ( D310 ";" D311 ) ";" D312 ) ";" D313 ) , R8 , C175) );
set D379 = ( IExec (( ( ( ( D310 ";" D311 ) ";" D312 ) ";" D313 ) ";" D314 ) , R8 , C175) );
set D380 = ( IExec (D317 , R8 , C175) );
L1102: D286 <> D285 by SCMFSA_2:101;
L1103: D286 <> D284 by SCMFSA_2:101;
L1104: D288 <> D284 by SCMFSA_2:101;
L1105: D288 <> D285 by SCMFSA_2:101;
L1106: D284 <> D283 by SCMFSA_2:101;
L1107: D284 <> D285 by SCMFSA_2:101;
L1108: ( D376 . D284 ) = ( ( Exec (D311 , D375) ) . D284 ) by SCMFSA6C:8
.= ( ( D375 . D284 ) - ( D375 . D283 ) ) by SCMFSA_2:65
.= ( ( len ( D374 . D282 ) ) - ( D375 . D283 ) ) by SCMFSA_2:74
.= ( ( len ( D374 . D282 ) ) - ( D374 . D283 ) ) by L1106 , SCMFSA_2:74
.= ( ( len ( C175 . D282 ) ) - ( D374 . D283 ) ) by SCMFSA_M:37
.= ( ( len ( C175 . D282 ) ) - ( C175 . D283 ) ) by SCMFSA_M:37;
thus L1109: ( D380 . D284 ) = ( ( Exec (D315 , D379) ) . D284 ) by SCMFSA6C:6
.= ( D379 . D284 ) by L1103 , SCMFSA_2:65
.= ( ( Exec (D314 , D378) ) . D284 ) by SCMFSA6C:6
.= ( D378 . D284 ) by L1104 , SCMFSA_2:72
.= ( ( Exec (D313 , D377) ) . D284 ) by SCMFSA6C:6
.= ( D377 . D284 ) by L1107 , SCMFSA_2:64
.= ( ( Exec (D312 , D376) ) . D284 ) by SCMFSA6C:6
.= ( ( len ( C175 . D282 ) ) - ( C175 . D283 ) ) by L1107 , L1108 , SCMFSA_2:63;
L1110: ( D377 . D149 ) = 1 by SCMFSA6B:11;
L1111: ( D378 . D285 ) = ( ( Exec (D313 , D377) ) . D285 ) by SCMFSA6C:6
.= ( ( D377 . D285 ) + 1 ) by L1110 , SCMFSA_2:64
.= ( ( ( Exec (D312 , D376) ) . D285 ) + 1 ) by SCMFSA6C:6
.= ( ( ( len ( C175 . D282 ) ) - ( C175 . D283 ) ) + 1 ) by L1108 , SCMFSA_2:63;
thus L1112: ( D380 . D285 ) = ( ( Exec (D315 , D379) ) . D285 ) by SCMFSA6C:6
.= ( D379 . D285 ) by L1102 , SCMFSA_2:65
.= ( ( Exec (D314 , D378) ) . D285 ) by SCMFSA6C:6
.= ( ( ( len ( C175 . D282 ) ) - ( C175 . D283 ) ) + 1 ) by L1105 , L1111 , SCMFSA_2:72;
L1113: D288 <> D286 by SCMFSA_2:101;
L1114: ( D378 . D282 ) = ( ( Exec (D313 , D377) ) . D282 ) by SCMFSA6C:7
.= ( D377 . D282 ) by SCMFSA_2:64
.= ( ( Exec (D312 , D376) ) . D282 ) by SCMFSA6C:7
.= ( D376 . D282 ) by SCMFSA_2:63
.= ( ( Exec (D311 , D375) ) . D282 ) by SCMFSA6C:9
.= ( D375 . D282 ) by SCMFSA_2:65
.= ( D374 . D282 ) by SCMFSA_2:74
.= ( C175 . D282 ) by SCMFSA_M:37;
thus L1115: ( D380 . D282 ) = ( ( Exec (D315 , D379) ) . D282 ) by SCMFSA6C:7
.= ( D379 . D282 ) by SCMFSA_2:65
.= ( ( Exec (D314 , D378) ) . D282 ) by SCMFSA6C:7
.= ( C175 . D282 ) by L1114 , SCMFSA_2:72;
thus L1116: ( D380 . D286 ) = ( ( Exec (D315 , D379) ) . D286 ) by SCMFSA6C:6
.= ( ( D379 . D286 ) - ( D379 . D286 ) ) by SCMFSA_2:65
.= ( 0 );
thus L1117: ( D380 . D288 ) = ( ( Exec (D315 , D379) ) . D288 ) by SCMFSA6C:6
.= ( D379 . D288 ) by L1113 , SCMFSA_2:65
.= ( ( Exec (D314 , D378) ) . D288 ) by SCMFSA6C:6
.= ( ( C175 . D282 ) /. ( abs ( ( ( len ( C175 . D282 ) ) - ( C175 . D283 ) ) + 1 ) ) ) by L1111 , L1114 , SCMBSORT:2;
end;
set D381 = ( Times (D283 , D318) );
L1118: (for B204 being (State of ( SCM+FSA )) holds (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (( B204 . D283 ) = ( ( len ( B204 . D282 ) ) - 1 ) implies (( B204 . D282 ) , ( ( IExec (D381 , R8 , B204) ) . D282 ) are_fiberwise_equipotent  & (for B205 , B206 being (Element of ( NAT )) holds ((B205 >= 1 & B206 <= ( len ( B204 . D282 ) ) & B205 < B206) implies (for B207 , B208 being Integer holds ((B207 = ( ( ( IExec (D381 , R8 , B204) ) . D282 ) . B205 ) & B208 = ( ( ( IExec (D381 , R8 , B204) ) . D282 ) . B206 )) implies B207 >= B208))))))))
proof
reconsider D382 = ( ( ( D310 ";" D311 ) ";" D312 ) ";" D313 ) as  good  InitHalting (Program of ( SCM+FSA ));
reconsider D383 = ( ( D382 ";" D314 ) ";" D315 ) as  good  InitHalting (Program of ( SCM+FSA ));
reconsider D384 = D316 as  good  InitHalting (Program of ( SCM+FSA )) by L811 , L424;
let C176 being (State of ( SCM+FSA ));
let R8 being (Instruction-Sequence of ( SCM+FSA ));
assume L1119: ( C176 . D283 ) = ( ( len ( C176 . D282 ) ) - 1 );
L1120: ( D383 ";" D384 ) is  good  InitHalting  good  InitHalting  good  InitHalting  good  InitHalting (Program of ( SCM+FSA ));
per cases ;
suppose L1121: ( len ( C176 . D282 ) ) <= 1;

thus L1122: ( C176 . D282 ) , ( ( IExec (D381 , R8 , C176) ) . D282 ) are_fiberwise_equipotent  by L1121 , L1119 , L886 , SCM_HALT:67 , XREAL_1:47;
L1123:
now
let C177 , C178 being (Element of ( NAT ));
assume that
L1124: C177 >= 1
and
L1125: C178 <= ( len ( C176 . D282 ) )
and
L1126: C177 < C178;
L1127: C178 <= 1 by L1121 , L1125 , XXREAL_0:2;
thus L1128: contradiction by L1127 , L1124 , L1126 , XXREAL_0:2;
end;
thus L1129: thesis by L1123;
end;
suppose L1130: ( len ( C176 . D282 ) ) > 1;

L1131: ( 1 - 1 ) < ( ( len ( C176 . D282 ) ) - 1 ) by L1130 , XREAL_1:9;
reconsider D385 = ( ( len ( C176 . D282 ) ) - 1 ) as (Element of ( NAT )) by L1131 , INT_1:3;
defpred S8[ (Element of ( NAT )) ] means (for B209 being (State of ( SCM+FSA )) holds (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds ((( B209 . D283 ) = $1 & ( B209 . D283 ) <= ( ( len ( B209 . D282 ) ) - 1 )) implies ((for B210 , B211 being (Element of ( NAT )) holds ((B210 >= 1 & B211 <= ( ( len ( B209 . D282 ) ) - ( B209 . D283 ) ) & B210 < B211) implies (for B212 , B213 being Integer holds ((B212 = ( ( B209 . D282 ) . B210 ) & B213 = ( ( B209 . D282 ) . B211 )) implies B212 >= B213)))) implies (( B209 . D282 ) , ( ( IExec (D381 , R11 , B209) ) . D282 ) are_fiberwise_equipotent  & (for B214 , B215 being (Element of ( NAT )) holds ((B214 >= 1 & B215 <= ( len ( B209 . D282 ) ) & B214 < B215) implies (for B216 , B217 being Integer holds ((B216 = ( ( ( IExec (D381 , R11 , B209) ) . D282 ) . B214 ) & B217 = ( ( ( IExec (D381 , R11 , B209) ) . D282 ) . B215 )) implies B216 >= B217)))))))));
L1132:
now
let C179 being (Element of ( NAT ));
assume L1133: S8[ C179 ];
L1134:
now
let C180 being (State of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L1135: ( C180 . D283 ) = ( C179 + 1 )
and
L1136: ( C180 . D283 ) <= ( ( len ( C180 . D282 ) ) - 1 );
L1137: ( len ( C180 . D282 ) ) < ( ( len ( C180 . D282 ) ) + ( C180 . D283 ) ) by L1135 , XREAL_1:29;
L1138: ( ( len ( C180 . D282 ) ) - ( C180 . D283 ) ) < ( ( ( len ( C180 . D282 ) ) + ( C180 . D283 ) ) - ( C180 . D283 ) ) by L1137 , XREAL_1:9;
L1139: ( ( ( len ( C180 . D282 ) ) - ( C180 . D283 ) ) + 1 ) <= ( len ( C180 . D282 ) ) by L1138 , INT_1:7;
L1140: ( - ( ( len ( C180 . D282 ) ) - 1 ) ) <= ( - ( C180 . D283 ) ) by L1136 , XREAL_1:24;
L1141: ( ( len ( C180 . D282 ) ) + ( - ( ( len ( C180 . D282 ) ) - 1 ) ) ) <= ( ( len ( C180 . D282 ) ) + ( - ( C180 . D283 ) ) ) by L1140 , XREAL_1:6;
reconsider D386 = ( ( len ( C180 . D282 ) ) - ( C180 . D283 ) ) as (Element of ( NAT )) by L1141 , INT_1:3;
set D387 = ( IExec (( D383 ";" D316 ) , R11 , C180) );
set D388 = ( IExec (D383 , R11 , C180) );
set D389 = ( SubFrom (D283 , D149) );
set D390 = ( IExec (( D318 ";" D389 ) , R11 , C180) );
L1142: ( D388 . D282 ) = ( C180 . D282 ) by L1101;
L1143: ( D388 . D284 ) = ( ( len ( C180 . D282 ) ) - ( C180 . D283 ) ) by L1101;
L1144: ( D388 . D284 ) <= ( len ( D388 . D282 ) ) by L1143 , L1138 , L1101;
consider C181 being (Element of ( NAT )), C182 being Integer such that L1145: C181 = ( ( ( IExec (D316 , R11 , D388) ) . D286 ) - ( D388 . D286 ) ) and L1146: C181 <= D386 and L1147: (( D386 - C181 ) >= 1 implies (C182 = ( ( D388 . D282 ) . ( D386 - C181 ) ) & C182 >= ( D388 . D288 ))) and L1148: (for B218 being (Element of ( NAT )) holds ((B218 > ( D386 - C181 ) & B218 < ( D386 + 1 )) implies (ex B219 being Integer st (B219 = ( ( D388 . D282 ) . B218 ) & B219 <= ( D388 . D288 ))))) by L1144 , L1143 , L1141 , L963;
L1149: D386 < ( D386 + 1 ) by XREAL_1:29;
L1150: C181 < ( D386 + 1 ) by L1149 , L1146 , XXREAL_0:2;
L1151: ( C181 - C181 ) < ( ( D386 + 1 ) - C181 ) by L1150 , XREAL_1:9;
reconsider D391 = ( ( C180 . D282 ) . ( D386 + 1 ) ) as Integer;
L1152: ( 1 + ( 0 ) ) <= ( D386 + 1 ) by INT_1:7;
L1153: ( D390 . D282 ) = ( ( Exec (D389 , ( IExec (D318 , R11 , C180) )) ) . D282 ) by L886 , SCM_HALT:24
.= ( ( IExec (D318 , R11 , C180) ) . D282 ) by SCMFSA_2:65
.= ( ( IExec (D301 , R11 , D387) ) . D282 ) by L1120 , L866 , SCM_HALT:21;
set D392 = ( ( D386 + 1 ) - C181 );
L1154: ( abs ( D386 + 1 ) ) = ( D386 + 1 ) by ABSVALUE:def 1;
L1155: ( D388 . D288 ) = ( ( C180 . D282 ) /. ( D386 + 1 ) ) by L1154 , L1101
.= D391 by L1139 , L1152 , FINSEQ_4:15;
L1156: (( D386 - C181 ) >= 1 implies (C182 = ( ( C180 . D282 ) . ( D386 - C181 ) ) & C182 >= D391)) by L1155 , L1147 , L1101;
L1157: ( D388 . D284 ) = D386 by L1101;
L1158: ( D387 . D282 ) = ( ( IExec (D316 , R11 , D388) ) . D282 ) by L821 , SCM_HALT:21
.= ( C180 . D282 ) by L1142 , L1138 , L1157 , L963;
L1159: ( D387 . D285 ) = ( ( IExec (D316 , R11 , D388) ) . D285 ) by L821 , SCM_HALT:20
.= ( D388 . D285 ) by L1142 , L1138 , L1157 , L963
.= ( D386 + 1 ) by L1101;
L1160: ( D387 . D285 ) <= ( len ( D387 . D282 ) ) by L1159 , L1138 , L1158 , INT_1:7;
L1161: ( D387 . D286 ) = ( C181 + ( D388 . D286 ) ) by L1145 , L821 , SCM_HALT:20
.= ( C181 + ( 0 ) ) by L1101
.= C181;
L1162: ( D387 . D282 ) , ( ( IExec (D301 , R11 , D387) ) . D282 ) are_fiberwise_equipotent  by L1161 , L1158 , L1159 , L1150 , L1139 , L1020;
L1163: C181 < ( D387 . D285 ) by L1146 , L1159 , L1149 , XXREAL_0:2;
L1164: ( D387 . D282 ) , ( D390 . D282 ) are_fiberwise_equipotent  by L1163 , L1158 , L1153 , L1161 , L1159 , L1139 , L1020;
L1165: ( len ( D390 . D282 ) ) = ( len ( C180 . D282 ) ) by L1164 , L1158 , RFINSEQ:3;
L1166: ( D390 . D283 ) = ( ( C179 + 1 ) - 1 ) by L1135 , L851 , L886 , SCM_HALT:66
.= C179;
L1167: ( D390 . D283 ) < ( C180 . D283 ) by L1166 , L1135 , XREAL_1:29;
L1168: ( D390 . D283 ) <= ( ( len ( D390 . D282 ) ) - 1 ) by L1167 , L1136 , L1165 , XXREAL_0:2;
L1169: ( ( ( IExec (D301 , R11 , D387) ) . D282 ) . D392 ) = ( ( D387 . D282 ) . ( D386 + 1 ) ) by L1158 , L1161 , L1159 , L1150 , L1139 , L1020;
thus L1170:now
L1171: ( ( IExec (D381 , R11 , C180) ) . D282 ) = ( ( IExec (D381 , R11 , D390) ) . D282 ) by L1135 , L851 , L886 , SCM_HALT:69;
assume L1172: (for B220 , B221 being (Element of ( NAT )) holds ((B220 >= 1 & B221 <= ( ( len ( C180 . D282 ) ) - ( C180 . D283 ) ) & B220 < B221) implies (for B222 , B223 being Integer holds ((B222 = ( ( C180 . D282 ) . B220 ) & B223 = ( ( C180 . D282 ) . B221 )) implies B222 >= B223))));
L1173:
now
L1174: ( ( D386 + 1 ) - C181 ) <= ( ( D386 + 1 ) - ( 0 ) ) by XREAL_1:13;
L1175: ( ( D386 - C181 ) + 1 ) <= ( D386 + 1 ) by L1174;
L1176: ( D386 - C181 ) <= D386 by L1175 , XREAL_1:6;
let C183 , C184 being (Element of ( NAT ));
assume that
L1177: C183 >= 1
and
L1178: C184 <= ( ( len ( D390 . D282 ) ) - ( D390 . D283 ) )
and
L1179: C183 < C184;
L1180: 1 <= C184 by L1177 , L1179 , XXREAL_0:2;
L1181: ( ( len ( D390 . D282 ) ) - ( D390 . D283 ) ) = ( D386 + 1 ) by L1135 , L1166 , L1165;
L1182: ( C184 - 1 ) <= D386 by L1181 , L1178 , XREAL_1:20;
L1183: ( 1 - 1 ) <= ( C183 - 1 ) by L1177 , XREAL_1:9;
reconsider D393 = ( C183 - 1 ) as (Element of ( NAT )) by L1183 , INT_1:3;
L1184: ( C183 - 1 ) < ( C184 - 1 ) by L1179 , XREAL_1:9;
reconsider D394 = ( C184 - 1 ) as (Element of ( NAT )) by L1184 , L1183 , INT_1:3;
let C185 , C186 being Integer;
assume that
L1185: C185 = ( ( D390 . D282 ) . C183 )
and
L1186: C186 = ( ( D390 . D282 ) . C184 );
per cases  by XXREAL_0:1;
suppose L1187: C183 < D392;

L1188: C185 = ( ( C180 . D282 ) . C183 ) by L1187 , L1158 , L1153 , L1161 , L1159 , L1150 , L1160 , L1177 , L1185 , L1020;
thus L1189:now
per cases  by XXREAL_0:1;
suppose L1190: C184 < D392;

L1191: C184 < ( D386 + 1 ) by L1190 , L1174 , XXREAL_0:2;
L1192: C184 <= D386 by L1191 , INT_1:7;
L1193: C186 = ( ( C180 . D282 ) . C184 ) by L1158 , L1153 , L1161 , L1159 , L1150 , L1160 , L1186 , L1180 , L1190 , L1020;
thus L1194: C185 >= C186 by L1193 , L1172 , L1177 , L1179 , L1188 , L1192;
end;
suppose L1195: C184 > D392;

L1196: ( D392 + 1 ) <= C184 by L1195 , INT_1:7;
L1197: D392 <= D394 by L1196 , XREAL_1:19;
L1198: C183 < D394 by L1197 , L1187 , XXREAL_0:2;
L1199: C186 = ( ( C180 . D282 ) . D394 ) by L1135 , L1166 , L1158 , L1153 , L1161 , L1159 , L1150 , L1160 , L1165 , L1178 , L1186 , L1195 , L1020;
thus L1200: C185 >= C186 by L1199 , L1172 , L1177 , L1182 , L1188 , L1198;
end;
suppose L1201: C184 = D392;

L1202: C183 < ( ( D386 - C181 ) + 1 ) by L1187;
L1203: C183 <= ( D386 - C181 ) by L1202 , INT_1:7;
L1204: C186 = ( ( C180 . D282 ) . ( D386 + 1 ) ) by L1158 , L1153 , L1161 , L1159 , L1163 , L1139 , L1186 , L1201 , L1020;
thus L1205:now
reconsider D395 = ( D386 - C181 ) as (Element of ( NAT )) by L1202 , INT_1:3 , INT_1:7;
L1206: ( ( C180 . D282 ) . D395 ) = C182 by L1147 , L1177 , L1203 , L1101 , XXREAL_0:2;
per cases ;
suppose L1207: C183 = D395;

thus L1208: C185 >= C186 by L1207 , L1147 , L1158 , L1153 , L1161 , L1159 , L1150 , L1139 , L1155 , L1177 , L1185 , L1187 , L1204 , L1206 , L1020;
end;
suppose L1209: C183 <> D395;

L1210: C183 < D395 by L1209 , L1203 , XXREAL_0:1;
L1211: C185 >= C182 by L1210 , L1156 , L1172 , L1177 , L1176 , L1188 , XXREAL_0:2;
thus L1212: C185 >= C186 by L1211 , L1147 , L1158 , L1153 , L1155 , L1169 , L1177 , L1186 , L1201 , L1203 , XXREAL_0:2;
end;
end;
end;
end;
end;
suppose L1190: C183 > D392;

L1191: ( D392 + 1 ) <= C183 by L1190 , INT_1:7;
L1192: ( 0 ) < D393 by L1191 , L1151 , XREAL_1:19;
L1193: ( 1 + ( 0 ) ) <= D393 by L1192 , INT_1:7;
L1194: D392 < C184 by L1179 , L1190 , XXREAL_0:2;
L1195: C186 = ( ( C180 . D282 ) . D394 ) by L1194 , L1135 , L1166 , L1158 , L1153 , L1161 , L1159 , L1150 , L1160 , L1165 , L1178 , L1186 , L1020;
L1196: C183 <= ( D386 + 1 ) by L1135 , L1166 , L1165 , L1178 , L1179 , XXREAL_0:2;
L1197: C185 = ( ( C180 . D282 ) . D393 ) by L1196 , L1158 , L1153 , L1161 , L1159 , L1150 , L1160 , L1185 , L1190 , L1020;
thus L1198: C185 >= C186 by L1197 , L1172 , L1182 , L1184 , L1195 , L1193;
end;
suppose L1199: C183 = D392;

L1200: D386 < ( D386 + 1 ) by XREAL_1:29;
L1201: D394 < ( D386 + 1 ) by L1200 , L1182 , XXREAL_0:2;
L1202: ( D392 - 1 ) < D394 by L1179 , L1199 , XREAL_1:9;
L1203: (ex B224 being Integer st (B224 = ( ( C180 . D282 ) . D394 ) & B224 <= D391)) by L1202 , L1142 , L1148 , L1155 , L1201;
L1204: C186 = ( ( C180 . D282 ) . D394 ) by L1135 , L1166 , L1158 , L1153 , L1161 , L1159 , L1163 , L1160 , L1165 , L1178 , L1179 , L1186 , L1199 , L1020;
thus L1205: C185 >= C186 by L1204 , L1158 , L1153 , L1161 , L1159 , L1163 , L1160 , L1185 , L1199 , L1203 , L1020;
end;
end;
L1207: ( D390 . D282 ) , ( ( IExec (D381 , R11 , D390) ) . D282 ) are_fiberwise_equipotent  by L1173 , L1133 , L1166 , L1168;
thus L1208: ( C180 . D282 ) , ( ( IExec (D381 , R11 , C180) ) . D282 ) are_fiberwise_equipotent  by L1207 , L1158 , L1153 , L1162 , L1171 , CLASSES1:76;
let C187 , C188 being (Element of ( NAT ));
assume that
L1209: C187 >= 1
and
L1210: C188 <= ( len ( C180 . D282 ) )
and
L1211: C187 < C188;
let C189 , C190 being Integer;
assume that
L1212: C189 = ( ( ( IExec (D381 , R11 , C180) ) . D282 ) . C187 )
and
L1213: C190 = ( ( ( IExec (D381 , R11 , C180) ) . D282 ) . C188 );
L1214: C188 <= ( len ( D390 . D282 ) ) by L1158 , L1153 , L1162 , L1210 , RFINSEQ:3;
thus L1215: C189 >= C190 by L1214 , L1133 , L1166 , L1168 , L1173 , L1171 , L1209 , L1211 , L1212 , L1213;
end;
end;
thus L1171: S8[ ( C179 + 1 ) ] by L1134;
end;
L1172: S8[ ( 0 ) ]
proof
let C191 being (State of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L1173: ( C191 . D283 ) = ( 0 )
and
L1174: ( C191 . D283 ) <= ( ( len ( C191 . D282 ) ) - 1 );
L1175: ( ( IExec (D381 , R11 , C191) ) . D282 ) = ( C191 . D282 ) by L1173 , L886 , SCM_HALT:67;
thus L1176: thesis by L1175 , L1173;
end;
L1177: (for B225 being (Element of ( NAT )) holds S8[ B225 ]) from NAT_1:sch 1(L1172 , L1132);
L1178: S8[ D385 ] by L1177;
L1179: ((for B226 , B227 being (Element of ( NAT )) holds ((B226 >= 1 & B227 <= ( ( len ( C176 . D282 ) ) - ( C176 . D283 ) ) & B226 < B227) implies (for B228 , B229 being Integer holds ((B228 = ( ( C176 . D282 ) . B226 ) & B229 = ( ( C176 . D282 ) . B227 )) implies B228 >= B229)))) implies (( C176 . D282 ) , ( ( IExec (D381 , R8 , C176) ) . D282 ) are_fiberwise_equipotent  & (for B230 , B231 being (Element of ( NAT )) holds ((B230 >= 1 & B231 <= ( len ( C176 . D282 ) ) & B230 < B231) implies (for B232 , B233 being Integer holds ((B232 = ( ( ( IExec (D381 , R8 , C176) ) . D282 ) . B230 ) & B233 = ( ( ( IExec (D381 , R8 , C176) ) . D282 ) . B231 )) implies B232 >= B233)))))) by L1178 , L1119;
thus L1180: ( C176 . D282 ) , ( ( IExec (D381 , R8 , C176) ) . D282 ) are_fiberwise_equipotent  by L1179 , L1119 , XXREAL_0:2;
L1181: (for B234 , B235 being (Element of ( NAT )) holds ((B234 >= 1 & B235 <= ( ( len ( C176 . D282 ) ) - ( C176 . D283 ) ) & B234 < B235) implies (for B236 , B237 being Integer holds ((B236 = ( ( C176 . D282 ) . B234 ) & B237 = ( ( C176 . D282 ) . B235 )) implies B236 >= B237)))) by L1119 , XXREAL_0:2;
thus L1182: thesis by L1181 , L1119 , L1178;
end;
end;
theorem
L1184: (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds (for B238 being (State of ( SCM+FSA )) holds (( B238 . ( fsloc ( 0 ) ) ) , ( ( IExec (( insert-sort ( fsloc ( 0 ) ) ) , R8 , B238) ) . ( fsloc ( 0 ) ) ) are_fiberwise_equipotent  & (for B239 , B240 being (Element of ( NAT )) holds ((B239 >= 1 & B240 <= ( len ( B238 . ( fsloc ( 0 ) ) ) ) & B239 < B240) implies (for B241 , B242 being Integer holds ((B241 = ( ( ( IExec (( insert-sort ( fsloc ( 0 ) ) ) , R8 , B238) ) . ( fsloc ( 0 ) ) ) . B239 ) & B242 = ( ( ( IExec (( insert-sort ( fsloc ( 0 ) ) ) , R8 , B238) ) . ( fsloc ( 0 ) ) ) . B240 )) implies B241 >= B242)))))))
proof
let R8 being (Instruction-Sequence of ( SCM+FSA ));
let C192 being (State of ( SCM+FSA ));
set D396 = ( ( ( ( ( ( D296 ";" D297 ) ";" D298 ) ";" D299 ) ";" D300 ) ";" D320 ) ";" D321 );
set D397 = ( Initialized C192 );
set D398 = ( Exec (D296 , D397) );
set D399 = ( IExec (( D296 ";" D297 ) , R8 , C192) );
set D400 = ( IExec (( ( D296 ";" D297 ) ";" D298 ) , R8 , C192) );
set D401 = ( IExec (( ( ( D296 ";" D297 ) ";" D298 ) ";" D299 ) , R8 , C192) );
set D402 = ( IExec (( ( ( ( D296 ";" D297 ) ";" D298 ) ";" D299 ) ";" D300 ) , R8 , C192) );
set D403 = ( IExec (( ( ( ( ( D296 ";" D297 ) ";" D298 ) ";" D299 ) ";" D300 ) ";" D320 ) , R8 , C192) );
set D404 = ( IExec (D396 , R8 , C192) );
L1185: ( D402 . D282 ) = ( ( Exec (D300 , D401) ) . D282 ) by SCMFSA6C:7
.= ( D401 . D282 ) by SCMFSA_2:63
.= ( ( Exec (D299 , D400) ) . D282 ) by SCMFSA6C:7
.= ( D400 . D282 ) by SCMFSA_2:63
.= ( ( Exec (D298 , D399) ) . D282 ) by SCMFSA6C:7
.= ( D399 . D282 ) by SCMFSA_2:63
.= ( ( Exec (D297 , D398) ) . D282 ) by SCMFSA6C:9
.= ( D398 . D282 ) by SCMFSA_2:63
.= ( D397 . D282 ) by SCMFSA_2:63
.= ( C192 . D282 ) by SCMFSA_M:37;
L1186: ( D403 . D282 ) = ( ( Exec (D320 , D402) ) . D282 ) by SCMFSA6C:7
.= ( C192 . D282 ) by L1185 , SCMFSA_2:74;
L1187: ( ( IExec (D396 , R8 , C192) ) . D282 ) = ( ( Exec (D321 , D403) ) . D282 ) by SCMFSA6C:7
.= ( C192 . D282 ) by L1186 , SCMFSA_2:65;
L1188: ( ( IExec (( insert-sort D282 ) , R8 , C192) ) . D282 ) = ( ( IExec (D381 , R8 , D404) ) . D282 ) by L889 , SCM_HALT:21;
L1189: ( D403 . D283 ) = ( ( Exec (D320 , D402) ) . D283 ) by SCMFSA6C:6
.= ( len ( D404 . D282 ) ) by L1185 , L1187 , SCMFSA_2:74;
L1190: ( D404 . D283 ) = ( ( Exec (D321 , D403) ) . D283 ) by SCMFSA6C:6
.= ( ( D403 . D283 ) - ( D403 . D149 ) ) by SCMFSA_2:65
.= ( ( len ( D404 . D282 ) ) - 1 ) by L1189 , SCM_HALT:9;
thus L1191: ( C192 . D282 ) , ( ( IExec (( insert-sort D282 ) , R8 , C192) ) . D282 ) are_fiberwise_equipotent  by L1190 , L1187 , L1188 , L1118;
let C193 , C194 being (Element of ( NAT ));
assume that
L1192: C193 >= 1
and
L1193: C194 <= ( len ( C192 . D282 ) )
and
L1194: C193 < C194;
thus L1195: thesis by L1187 , L1190 , L1188 , L1192 , L1193 , L1194 , L1118;
end;
theorem
L1196: (for B243 being (Element of ( NAT )) holds (for B244 being (State of ( SCM+FSA )) holds (for B245 being (Instruction-Sequence of ( SCM+FSA )) holds (( Insert-Sort-Algorithm ) c= B245 implies (for B246 being (FinSequence of ( INT )) holds (( Initialized ( ( fsloc ( 0 ) ) .--> B246 ) ) c= B244 implies ( IC ( Comput (B245 , B244 , B243) ) ) in ( dom ( Insert-Sort-Algorithm ) )))))))
proof
set D405 = ( Insert-Sort-Algorithm );
let C195 being (Element of ( NAT ));
let C196 being (State of ( SCM+FSA ));
let C197 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L1197: ( Insert-Sort-Algorithm ) c= C197;
let C198 being (FinSequence of ( INT ));
set D406 = ( ( fsloc ( 0 ) ) .--> C198 );
assume L1198: ( Initialized D406 ) c= C196;
set D407 = ( Bubble-Sort-Algorithm );
L1199: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= ( Initialized D406 ) by FUNCT_4:25;
L1200: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= C196 by L1199 , L1198 , XBOOLE_1:1;
thus L1201: thesis by L1200 , L889 , L1197 , SCM_HALT:def 1;
end;
theorem
L1202: (for B247 being (State of ( SCM+FSA )) holds (for B248 being (FinSequence of ( INT )) holds (for R8 being (Instruction-Sequence of ( SCM+FSA )) holds ((( ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) +* ( ( fsloc ( 0 ) ) .--> B248 ) ) c= B247 & ( Insert-Sort-Algorithm ) c= R8) implies (ex B249 being (FinSequence of ( REAL )) st (B248 , B249 are_fiberwise_equipotent  & B249 is  non-increasing & B249 is (FinSequence of ( INT )) & ( ( Result (R8 , B247) ) . ( fsloc ( 0 ) ) ) = B249))))))
proof
let C199 being (State of ( SCM+FSA ));
let C200 being (FinSequence of ( INT ));
let R8 being (Instruction-Sequence of ( SCM+FSA ));
set D408 = ( Insert-Sort-Algorithm );
set D409 = ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) );
set D410 = ( ( fsloc ( 0 ) ) .--> C200 );
set D411 = ( ( IExec (( insert-sort D282 ) , R8 , C199) ) . D282 );
assume that
L1203: ( D409 +* D410 ) c= C199
and
L1204: D408 c= R8;
L1205: ( R8 +* D408 ) = R8 by L1204 , FUNCT_4:98;
reconsider D412 = D411 as (FinSequence of ( REAL )) by FINSEQ_3:117;
take D412;
L1206: ( dom D410 ) = { D282 } by FUNCOP_1:13;
L1207: D282 in ( dom D410 ) by L1206 , TARSKI:def 1;
L1208: D282 in ( dom ( D409 +* D410 ) ) by L1207 , FUNCT_4:12;
L1209: ( C199 . D282 ) = ( ( D409 +* D410 ) . D282 ) by L1208 , L1203 , GRFUNC_1:2
.= ( D410 . D282 ) by L1207 , FUNCT_4:13
.= C200 by FUNCOP_1:72;
thus L1210: C200 , D412 are_fiberwise_equipotent  by L1209 , L1184;
L1211: ( C199 . D282 ) , D411 are_fiberwise_equipotent  by L1184;
L1212: ( dom ( C199 . D282 ) ) = ( dom D412 ) by L1211 , RFINSEQ:3;
L1213:
now
let C201 , C202 being (Element of ( NAT ));
assume that
L1214: C201 in ( dom D412 )
and
L1215: C202 in ( dom D412 )
and
L1216: C201 < C202;
L1217: C201 >= 1 by L1214 , FINSEQ_3:25;
L1218: C202 <= ( len ( C199 . D282 ) ) by L1212 , L1215 , FINSEQ_3:25;
thus L1219: ( D412 . C201 ) >= ( D412 . C202 ) by L1218 , L1216 , L1217 , L1184;
reconsider D413 = ( D411 . C202 ) as Integer;
reconsider D414 = ( D411 . C201 ) as Integer;
end;
thus L1221: D412 is  non-increasing by L1213 , RFINSEQ:19;
thus L1222: D412 is (FinSequence of ( INT ));
L1223: ( dom D409 ) = { ( intloc ( 0 ) ) , ( IC ( SCM+FSA ) ) } by SCMFSA_M:11;
L1224: (D282 <> ( intloc ( 0 ) ) & D282 <> ( IC ( SCM+FSA ) )) by SCMFSA_2:57 , SCMFSA_2:58;
L1225: (not D282 in ( dom D409 )) by L1224 , L1223 , TARSKI:def 2;
L1226: ( dom D409 ) misses ( dom D410 ) by L1225 , L1206 , ZFMISC_1:50;
L1227: D409 c= ( D409 +* D410 ) by L1226 , FUNCT_4:32;
L1228: D409 c= C199 by L1227 , L1203 , XBOOLE_1:1;
L1229: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= C199 by L1228;
L1230: C199 = ( C199 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L1229 , FUNCT_4:98;
L1231: C199 = ( Initialized C199 ) by L1230;
L1232: ( ( Result (( R8 +* D408 ) , ( Initialized C199 )) ) . ( fsloc ( 0 ) ) ) = ( ( IExec (D408 , R8 , C199) ) . ( fsloc ( 0 ) ) ) by SCMBSORT:33;
thus L1233: thesis by L1232 , L1205 , L1231;
end;
theorem
L1234: (for B250 being (FinSequence of ( INT )) holds ( Initialized ( ( fsloc ( 0 ) ) .--> B250 ) ) is ( Insert-Sort-Algorithm ) -autonomic)
proof
set D415 = { ( intloc ( 0 ) ) , ( IC ( SCM+FSA ) ) , ( fsloc ( 0 ) ) };
let C203 being (FinSequence of ( INT ));
set D416 = ( Initialized ( ( fsloc ( 0 ) ) .--> C203 ) );
set D417 = ( Insert-Sort-Algorithm );
set D418 = { ( fsloc ( 0 ) ) , D149 , D150 , D151 , D152 , D153 , D154 , D155 };
set D419 = ( ( UsedInt*Loc D417 ) \/ ( UsedIntLoc D417 ) );
L1235: ( UsedIntLoc D417 ) = { D149 , D150 , D151 , D152 , D153 , D154 , D155 } by L600;
L1236: ( UsedInt*Loc D417 ) = { ( fsloc ( 0 ) ) } by L608;
L1237: D419 = D418 by L1236 , L1235 , ENUMSET1:22;
L1238: (for B251 being (Element of ( NAT )) holds (for B252 , B253 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (Instruction-Sequence of ( SCM+FSA )) holds ((11 <= B251 & D416 c= B252 & D416 c= B253 & D417 c= R9 & D417 c= R10) implies (( ( Comput (R9 , B252 , B251) ) | D419 ) = ( ( Comput (R10 , B253 , B251) ) | D419 ) & ( ( Comput (R9 , B252 , B251) ) . ( IC ( SCM+FSA ) ) ) = ( ( Comput (R10 , B253 , B251) ) . ( IC ( SCM+FSA ) ) )))))))
proof
let C204 being (Element of ( NAT ));
let C205 , C206 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L1239: 11 <= C204
and
L1240: D416 c= C205
and
L1241: D416 c= C206
and
L1242: D417 c= R9
and
L1243: D417 c= R10;
L1244: ( C205 . ( intloc ( 0 ) ) ) = 1 by L1240 , SCMFSA_M:33
.= ( C206 . ( intloc ( 0 ) ) ) by L1241 , SCMFSA_M:33;
L1245: C206 is ( 0 ) -started by L1241 , MEMSTR_0:17;
set D420 = ( Comput (R9 , C205 , 11) );
set D421 = ( Comput (R10 , C206 , 11) );
L1246: C205 is ( 0 ) -started by L1240 , MEMSTR_0:17;
L1247: ( C205 . ( fsloc ( 0 ) ) ) = C203 by L1240 , SCMFSA_M:33
.= ( C206 . ( fsloc ( 0 ) ) ) by L1241 , SCMFSA_M:33;
L1248:
now
let C207 being set;
assume L1249: C207 in D419;
L1250: C207 in D418 by L1249 , L1236 , L1235 , ENUMSET1:22;
per cases  by L1250 , ENUMSET1:def 6;
suppose L1251: C207 = ( fsloc ( 0 ) );

thus L1252: ( D420 . C207 ) = ( C205 . ( fsloc ( 0 ) ) ) by L1251 , L1246 , L663 , L1242
.= ( D421 . C207 ) by L1245 , L1247 , L1251 , L663 , L1243;
end;
suppose L1253: C207 = D149;

thus L1254: ( D420 . C207 ) = ( C205 . D149 ) by L1253 , L1246 , L663 , L1242
.= ( D421 . C207 ) by L1245 , L1244 , L1253 , L663 , L1243;
end;
suppose L1255: C207 = D150;

thus L1256: ( D420 . C207 ) = ( len ( C205 . ( fsloc ( 0 ) ) ) ) by L1255 , L1246 , L663 , L1242
.= ( D421 . C207 ) by L1245 , L1247 , L1255 , L663 , L1243;
end;
suppose L1257: C207 = D151;

thus L1258: ( D420 . C207 ) = ( C205 . D149 ) by L1257 , L1246 , L663 , L1242
.= ( D421 . C207 ) by L1245 , L1244 , L1257 , L663 , L1243;
end;
suppose L1259: C207 = D152;

thus L1260: ( D420 . C207 ) = ( C205 . D149 ) by L1259 , L1246 , L663 , L1242
.= ( D421 . C207 ) by L1245 , L1244 , L1259 , L663 , L1243;
end;
suppose L1261: C207 = D153;

thus L1262: ( D420 . C207 ) = ( C205 . D149 ) by L1261 , L1246 , L663 , L1242
.= ( D421 . C207 ) by L1245 , L1244 , L1261 , L663 , L1243;
end;
suppose L1263: C207 = D154;

thus L1264: ( D420 . C207 ) = ( C205 . D149 ) by L1263 , L1246 , L663 , L1242
.= ( D421 . C207 ) by L1245 , L1244 , L1263 , L663 , L1243;
end;
suppose L1265: C207 = D155;

thus L1266: ( D420 . C207 ) = ( C205 . D149 ) by L1265 , L1246 , L663 , L1242
.= ( D421 . C207 ) by L1245 , L1244 , L1265 , L663 , L1243;
end;
end;
L1268: (for R4 being (Element of ( NAT )) holds ( IC ( Comput (R10 , C206 , R4) ) ) in ( dom D417 )) by L1241 , L1196 , L1243;
L1269: (for R4 being (Element of ( NAT )) holds ( IC ( Comput (R9 , C205 , R4) ) ) in ( dom D417 )) by L1240 , L1196 , L1242;
L1270: D419 c= ( dom D421 ) by SCMBSORT:32;
L1271: D419 c= ( dom D420 ) by SCMBSORT:32;
L1272: ( D420 | D419 ) = ( D421 | D419 ) by L1271 , L1270 , L1248 , FUNCT_1:95;
L1273: ( D420 . ( IC ( SCM+FSA ) ) ) = 11 by L1246 , L663 , L1242
.= ( D421 . ( IC ( SCM+FSA ) ) ) by L1245 , L663 , L1243;
thus L1274: thesis by L1273 , L1239 , L1272 , L1269 , L1268 , L1242 , L1243 , SCMBSORT:15;
end;
L1275: (for B254 , B255 being (State of ( SCM+FSA )) holds (for R9 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (Instruction-Sequence of ( SCM+FSA )) holds (for R4 being (Element of ( NAT )) holds ((D416 c= B254 & D416 c= B255 & D417 c= R9 & D417 c= R10 & R4 <= 10) implies (( ( Comput (R9 , B254 , R4) ) . ( intloc ( 0 ) ) ) = ( ( Comput (R10 , B255 , R4) ) . ( intloc ( 0 ) ) ) & ( ( Comput (R9 , B254 , R4) ) . ( IC ( SCM+FSA ) ) ) = ( ( Comput (R10 , B255 , R4) ) . ( IC ( SCM+FSA ) ) ) & ( ( Comput (R9 , B254 , R4) ) . ( fsloc ( 0 ) ) ) = ( ( Comput (R10 , B255 , R4) ) . ( fsloc ( 0 ) ) )))))))
proof
let C208 , C209 being (State of ( SCM+FSA ));
let R9 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (Instruction-Sequence of ( SCM+FSA ));
let R4 being (Element of ( NAT ));
assume that
L1276: D416 c= C208
and
L1277: D416 c= C209
and
L1278: D417 c= R9
and
L1279: D417 c= R10
and
L1280: R4 <= 10;
L1281: C209 is ( 0 ) -started by L1277 , MEMSTR_0:17;
L1282: ( C208 . ( fsloc ( 0 ) ) ) = C203 by L1276 , SCMFSA_M:33
.= ( C209 . ( fsloc ( 0 ) ) ) by L1277 , SCMFSA_M:33;
L1283: ( C208 . ( intloc ( 0 ) ) ) = 1 by L1276 , SCMFSA_M:33
.= ( C209 . ( intloc ( 0 ) ) ) by L1277 , SCMFSA_M:33;
L1284: ( Comput (R9 , C208 , ( 0 )) ) = C208;
L1285: C208 is ( 0 ) -started by L1276 , MEMSTR_0:17;
L1286: ( IC C208 ) = ( 0 ) by L1285 , MEMSTR_0:def 11
.= ( IC C209 ) by L1281 , MEMSTR_0:def 11;
per cases  by L1280 , NAT_1:34;
suppose L1287: R4 = ( 0 );

thus L1288: ( ( Comput (R9 , C208 , R4) ) . ( intloc ( 0 ) ) ) = ( ( Comput (R10 , C209 , R4) ) . ( intloc ( 0 ) ) ) by L1287 , L1284 , L1283 , EXTPRO_1:2;
thus L1289: ( ( Comput (R9 , C208 , R4) ) . ( IC ( SCM+FSA ) ) ) = ( ( Comput (R10 , C209 , R4) ) . ( IC ( SCM+FSA ) ) ) by L1284 , L1286 , L1287 , EXTPRO_1:2;
thus L1290: thesis by L1284 , L1282 , L1287 , EXTPRO_1:2;
end;
suppose L1291: R4 = 1;

thus L1292: ( ( Comput (R9 , C208 , R4) ) . ( intloc ( 0 ) ) ) = ( C208 . ( intloc ( 0 ) ) ) by L1291 , L1285 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( intloc ( 0 ) ) ) by L1281 , L1283 , L1291 , L663 , L1279;
thus L1293: ( ( Comput (R9 , C208 , R4) ) . ( IC ( SCM+FSA ) ) ) = 1 by L1285 , L1291 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( IC ( SCM+FSA ) ) ) by L1281 , L1291 , L663 , L1279;
thus L1294: ( ( Comput (R9 , C208 , R4) ) . ( fsloc ( 0 ) ) ) = ( C208 . ( fsloc ( 0 ) ) ) by L1285 , L1291 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( fsloc ( 0 ) ) ) by L1281 , L1282 , L1291 , L663 , L1279;
end;
suppose L1295: R4 = 2;

thus L1296: ( ( Comput (R9 , C208 , R4) ) . ( intloc ( 0 ) ) ) = ( C208 . ( intloc ( 0 ) ) ) by L1295 , L1285 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( intloc ( 0 ) ) ) by L1281 , L1283 , L1295 , L663 , L1279;
thus L1297: ( ( Comput (R9 , C208 , R4) ) . ( IC ( SCM+FSA ) ) ) = 2 by L1285 , L1295 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( IC ( SCM+FSA ) ) ) by L1281 , L1295 , L663 , L1279;
thus L1298: ( ( Comput (R9 , C208 , R4) ) . ( fsloc ( 0 ) ) ) = ( C208 . ( fsloc ( 0 ) ) ) by L1285 , L1295 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( fsloc ( 0 ) ) ) by L1281 , L1282 , L1295 , L663 , L1279;
end;
suppose L1299: R4 = 3;

thus L1300: ( ( Comput (R9 , C208 , R4) ) . ( intloc ( 0 ) ) ) = ( C208 . ( intloc ( 0 ) ) ) by L1299 , L1285 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( intloc ( 0 ) ) ) by L1281 , L1283 , L1299 , L663 , L1279;
thus L1301: ( ( Comput (R9 , C208 , R4) ) . ( IC ( SCM+FSA ) ) ) = 3 by L1285 , L1299 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( IC ( SCM+FSA ) ) ) by L1281 , L1299 , L663 , L1279;
thus L1302: ( ( Comput (R9 , C208 , R4) ) . ( fsloc ( 0 ) ) ) = ( C208 . ( fsloc ( 0 ) ) ) by L1285 , L1299 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( fsloc ( 0 ) ) ) by L1281 , L1282 , L1299 , L663 , L1279;
end;
suppose L1303: R4 = 4;

thus L1304: ( ( Comput (R9 , C208 , R4) ) . ( intloc ( 0 ) ) ) = ( C208 . ( intloc ( 0 ) ) ) by L1303 , L1285 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( intloc ( 0 ) ) ) by L1281 , L1283 , L1303 , L663 , L1279;
thus L1305: ( ( Comput (R9 , C208 , R4) ) . ( IC ( SCM+FSA ) ) ) = 4 by L1285 , L1303 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( IC ( SCM+FSA ) ) ) by L1281 , L1303 , L663 , L1279;
thus L1306: ( ( Comput (R9 , C208 , R4) ) . ( fsloc ( 0 ) ) ) = ( C208 . ( fsloc ( 0 ) ) ) by L1285 , L1303 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( fsloc ( 0 ) ) ) by L1281 , L1282 , L1303 , L663 , L1279;
end;
suppose L1307: R4 = 5;

thus L1308: ( ( Comput (R9 , C208 , R4) ) . ( intloc ( 0 ) ) ) = ( C208 . ( intloc ( 0 ) ) ) by L1307 , L1285 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( intloc ( 0 ) ) ) by L1281 , L1283 , L1307 , L663 , L1279;
thus L1309: ( ( Comput (R9 , C208 , R4) ) . ( IC ( SCM+FSA ) ) ) = 5 by L1285 , L1307 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( IC ( SCM+FSA ) ) ) by L1281 , L1307 , L663 , L1279;
thus L1310: ( ( Comput (R9 , C208 , R4) ) . ( fsloc ( 0 ) ) ) = ( C208 . ( fsloc ( 0 ) ) ) by L1285 , L1307 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( fsloc ( 0 ) ) ) by L1281 , L1282 , L1307 , L663 , L1279;
end;
suppose L1311: R4 = 6;

thus L1312: ( ( Comput (R9 , C208 , R4) ) . ( intloc ( 0 ) ) ) = ( C208 . ( intloc ( 0 ) ) ) by L1311 , L1285 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( intloc ( 0 ) ) ) by L1281 , L1283 , L1311 , L663 , L1279;
thus L1313: ( ( Comput (R9 , C208 , R4) ) . ( IC ( SCM+FSA ) ) ) = 6 by L1285 , L1311 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( IC ( SCM+FSA ) ) ) by L1281 , L1311 , L663 , L1279;
thus L1314: ( ( Comput (R9 , C208 , R4) ) . ( fsloc ( 0 ) ) ) = ( C208 . ( fsloc ( 0 ) ) ) by L1285 , L1311 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( fsloc ( 0 ) ) ) by L1281 , L1282 , L1311 , L663 , L1279;
end;
suppose L1315: R4 = 7;

thus L1316: ( ( Comput (R9 , C208 , R4) ) . ( intloc ( 0 ) ) ) = ( C208 . ( intloc ( 0 ) ) ) by L1315 , L1285 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( intloc ( 0 ) ) ) by L1281 , L1283 , L1315 , L663 , L1279;
thus L1317: ( ( Comput (R9 , C208 , R4) ) . ( IC ( SCM+FSA ) ) ) = 7 by L1285 , L1315 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( IC ( SCM+FSA ) ) ) by L1281 , L1315 , L663 , L1279;
thus L1318: ( ( Comput (R9 , C208 , R4) ) . ( fsloc ( 0 ) ) ) = ( C208 . ( fsloc ( 0 ) ) ) by L1285 , L1315 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( fsloc ( 0 ) ) ) by L1281 , L1282 , L1315 , L663 , L1279;
end;
suppose L1319: R4 = 8;

thus L1320: ( ( Comput (R9 , C208 , R4) ) . ( intloc ( 0 ) ) ) = ( C208 . ( intloc ( 0 ) ) ) by L1319 , L1285 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( intloc ( 0 ) ) ) by L1281 , L1283 , L1319 , L663 , L1279;
thus L1321: ( ( Comput (R9 , C208 , R4) ) . ( IC ( SCM+FSA ) ) ) = 8 by L1285 , L1319 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( IC ( SCM+FSA ) ) ) by L1281 , L1319 , L663 , L1279;
thus L1322: ( ( Comput (R9 , C208 , R4) ) . ( fsloc ( 0 ) ) ) = ( C208 . ( fsloc ( 0 ) ) ) by L1285 , L1319 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( fsloc ( 0 ) ) ) by L1281 , L1282 , L1319 , L663 , L1279;
end;
suppose L1323: R4 = 9;

thus L1324: ( ( Comput (R9 , C208 , R4) ) . ( intloc ( 0 ) ) ) = ( C208 . ( intloc ( 0 ) ) ) by L1323 , L1285 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( intloc ( 0 ) ) ) by L1281 , L1283 , L1323 , L663 , L1279;
thus L1325: ( ( Comput (R9 , C208 , R4) ) . ( IC ( SCM+FSA ) ) ) = 9 by L1285 , L1323 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( IC ( SCM+FSA ) ) ) by L1281 , L1323 , L663 , L1279;
thus L1326: ( ( Comput (R9 , C208 , R4) ) . ( fsloc ( 0 ) ) ) = ( C208 . ( fsloc ( 0 ) ) ) by L1285 , L1323 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( fsloc ( 0 ) ) ) by L1281 , L1282 , L1323 , L663 , L1279;
end;
suppose L1327: R4 = 10;

thus L1328: ( ( Comput (R9 , C208 , R4) ) . ( intloc ( 0 ) ) ) = ( C208 . ( intloc ( 0 ) ) ) by L1327 , L1285 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( intloc ( 0 ) ) ) by L1281 , L1283 , L1327 , L663 , L1279;
thus L1329: ( ( Comput (R9 , C208 , R4) ) . ( IC ( SCM+FSA ) ) ) = 10 by L1285 , L1327 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( IC ( SCM+FSA ) ) ) by L1281 , L1327 , L663 , L1279;
thus L1330: ( ( Comput (R9 , C208 , R4) ) . ( fsloc ( 0 ) ) ) = ( C208 . ( fsloc ( 0 ) ) ) by L1285 , L1327 , L663 , L1278
.= ( ( Comput (R10 , C209 , R4) ) . ( fsloc ( 0 ) ) ) by L1281 , L1282 , L1327 , L663 , L1279;
end;
end;
L1332: ( dom D416 ) = D415 by SCMFSA_M:31;
reconsider D422 = ( ( intloc ( 0 ) ) .--> 1 ) as  data-only (FinPartState of ( SCM+FSA ));
L1333: (for B256 , B257 being (Instruction-Sequence of ( SCM+FSA )) holds ((D417 c= B256 & D417 c= B257) implies (for B258 , B259 being (State of ( SCM+FSA )) holds ((D416 c= B258 & D416 c= B259) implies (for R4 being (Element of ( NAT )) holds ( ( Comput (B256 , B258 , R4) ) | ( dom D416 ) ) = ( ( Comput (B257 , B259 , R4) ) | ( dom D416 ) ))))))
proof
let C210 , C211 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L1334: D417 c= C210
and
L1335: D417 c= C211;
let C212 , C213 being (State of ( SCM+FSA ));
assume that
L1336: D416 c= C212
and
L1337: D416 c= C213;
let R4 being (Element of ( NAT ));
set D423 = ( Comput (C210 , C212 , R4) );
set D424 = ( Comput (C211 , C213 , R4) );
L1338: D419 c= ( dom D423 ) by SCMBSORT:32;
L1339: ( fsloc ( 0 ) ) in D419 by L1237 , ENUMSET1:def 6;
L1340: D419 c= ( dom D424 ) by SCMBSORT:32;
L1341: (R4 > 10 implies ( 10 + 1 ) < ( R4 + 1 )) by XREAL_1:6;
L1342: ( intloc ( 0 ) ) in D419 by L1237 , ENUMSET1:def 6;
L1343:
now
let C214 being set;
assume L1344: C214 in D415;
per cases  by L1344 , ENUMSET1:def 1;
suppose L1345: C214 = ( intloc ( 0 ) );

per cases ;
suppose L1346: R4 <= 10;

thus L1347: ( D423 . C214 ) = ( D424 . C214 ) by L1346 , L1275 , L1336 , L1337 , L1345 , L1334 , L1335;
end;
suppose L1348: R4 > 10;

L1349: 11 <= R4 by L1348 , L1341 , NAT_1:13;
L1350: ( D423 | D419 ) = ( D424 | D419 ) by L1349 , L1238 , L1336 , L1337 , L1334 , L1335;
thus L1351: ( D423 . C214 ) = ( D424 . C214 ) by L1350 , L1342 , L1338 , L1340 , L1345 , FUNCT_1:95;
end;
end;
suppose L1353: C214 = ( IC ( SCM+FSA ) );

per cases ;
suppose L1354: R4 <= 10;

thus L1355: ( D423 . C214 ) = ( D424 . C214 ) by L1354 , L1275 , L1336 , L1337 , L1353 , L1334 , L1335;
end;
suppose L1356: R4 > 10;

L1357: 11 <= R4 by L1356 , L1341 , NAT_1:13;
thus L1358: ( D423 . C214 ) = ( D424 . C214 ) by L1357 , L1238 , L1336 , L1337 , L1353 , L1334 , L1335;
end;
end;
suppose L1360: C214 = ( fsloc ( 0 ) );

per cases ;
suppose L1361: R4 <= 10;

thus L1362: ( D423 . C214 ) = ( D424 . C214 ) by L1361 , L1275 , L1336 , L1337 , L1360 , L1334 , L1335;
end;
suppose L1363: R4 > 10;

L1364: 11 <= R4 by L1363 , L1341 , NAT_1:13;
L1365: ( D423 | D419 ) = ( D424 | D419 ) by L1364 , L1238 , L1336 , L1337 , L1334 , L1335;
thus L1366: ( D423 . C214 ) = ( D424 . C214 ) by L1365 , L1339 , L1338 , L1340 , L1360 , FUNCT_1:95;
end;
end;
end;
L1369: D415 c= ( dom D424 ) by SCMFSA_M:34;
L1370: D415 c= ( dom D423 ) by SCMFSA_M:34;
L1371: ( D423 | D415 ) = ( D424 | D415 ) by L1370 , L1369 , L1343 , FUNCT_1:95;
thus L1372: ( D423 | ( dom D416 ) ) = ( D424 | ( dom D416 ) ) by L1371 , L1332;
end;
thus L1373: thesis by L1333 , EXTPRO_1:def 10;
end;
registration
cluster ( Insert-Sort-Algorithm ) -> non  halt-free;
coherence;
end;
theorem
L1375: ( Insert-Sort-Algorithm ) , ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) computes ( Sorting-Function )
proof
set D425 = ( Insert-Sort-Algorithm );
set D426 = ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) );
let C215 being set;
assume L1376: C215 in ( dom ( Sorting-Function ) );
consider C216 being (FinSequence of ( INT )) such that L1377: C215 = ( ( fsloc ( 0 ) ) .--> C216 ) by L1376 , SCMFSA_M:35;
reconsider D427 = C215 as  data-only (FinPartState of ( SCM+FSA )) by L1377;
L1378: ( dom D427 ) = { ( fsloc ( 0 ) ) } by L1377 , FUNCOP_1:13;
consider C217 being (State of ( SCM+FSA )) such that L1379: ( D426 +* D427 ) c= C217 by PBOOLE:141;
consider C218 being (Instruction-Sequence of ( SCM+FSA )) such that L1380: D425 c= C218 by PBOOLE:145;
L1381: ( fsloc ( 0 ) ) <> ( IC ( SCM+FSA ) ) by SCMFSA_2:57;
L1382: ( dom D427 ) misses { ( IC ( SCM+FSA ) ) } by L1381 , L1378 , ZFMISC_1:11;
L1383: ( fsloc ( 0 ) ) <> ( intloc ( 0 ) ) by SCMFSA_2:58;
L1384: ( dom D427 ) misses { ( intloc ( 0 ) ) } by L1383 , L1378 , ZFMISC_1:11;
L1385: ( dom D426 ) = ( ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) \/ { ( IC ( SCM+FSA ) ) } ) by MEMSTR_0:42
.= ( { ( IC ( SCM+FSA ) ) } \/ { ( intloc ( 0 ) ) } ) by FUNCOP_1:13;
L1386: ( dom D427 ) misses ( dom D426 ) by L1385 , L1382 , L1384 , XBOOLE_1:70;
L1387: ( D427 +* D426 ) = ( D426 +* D427 ) by L1386 , FUNCT_4:35;
L1388:
now
let C219 being (State of ( SCM+FSA ));
assume L1389: ( D426 +* D427 ) c= C219;
let C220 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L1390: D425 c= C220;
set D428 = ( insert-sort ( fsloc ( 0 ) ) );
L1391: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= ( D426 +* D427 ) by L1387 , FUNCT_4:25;
L1392: ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= C219 by L1391 , L1389 , XBOOLE_1:1;
thus L1393: C220 halts_on C219 by L1392 , L889 , L1390 , SCM_HALT:def 2;
end;
take D427;
thus L1394: C215 = D427;
L1395: ( Initialized D427 ) = ( D427 +* D426 )
.= ( D426 +* D427 ) by L1386 , FUNCT_4:35
.= ( D426 +* D427 )
.= ( D426 +* D427 );
L1396: ( D426 +* D427 ) is D425 -halted D425 -autonomic by L1395 , L1377 , L1388 , L1234 , EXTPRO_1:def 11;
thus L1397: ( D426 +* D427 ) is (Autonomy of D425) by L1396 , EXTPRO_1:def 12;
L1398: ( fsloc ( 0 ) ) in (the carrier of ( SCM+FSA ));
L1399: ( fsloc ( 0 ) ) in ( dom ( Result (C218 , C217) ) ) by L1398 , PARTFUN1:def 2;
L1400: ( D426 +* D427 ) c= C217 by L1379;
L1401: ( Result (D425 , ( D426 +* D427 )) ) = ( ( Result (C218 , C217) ) | ( dom ( D426 +* D427 ) ) ) by L1400 , L1397 , L1380 , EXTPRO_1:def 13;
L1402: ( ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) +* ( ( fsloc ( 0 ) ) .--> C216 ) ) c= ( D426 +* D427 ) by L1377;
L1403: ( ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) +* ( ( fsloc ( 0 ) ) .--> C216 ) ) c= C217 by L1402 , L1379 , XBOOLE_1:1;
consider C221 being (FinSequence of ( REAL )) such that L1404: C216 , C221 are_fiberwise_equipotent  and L1405: C221 is  non-increasing and L1406: C221 is (FinSequence of ( INT )) and L1407: ( ( Result (C218 , C217) ) . ( fsloc ( 0 ) ) ) = C221 by L1403 , L1202 , L1380;
consider C222 being (FinSequence of ( REAL )) such that L1408: C216 , C222 are_fiberwise_equipotent  and L1409: C222 is  non-increasing and L1410: C222 is (FinSequence of ( INT )) and L1411: ( ( Sorting-Function ) . D427 ) = ( ( fsloc ( 0 ) ) .--> C222 ) by L1377 , SCMFSA_M:36;
L1412: D427 c= ( D426 +* D427 ) by FUNCT_4:25;
L1413: ( dom D427 ) c= ( dom ( D426 +* D427 ) ) by L1412 , RELAT_1:11;
L1414: ( dom ( ( fsloc ( 0 ) ) .--> C222 ) ) = { ( fsloc ( 0 ) ) } by FUNCOP_1:13;
L1415: C221 = C222 by L1408 , L1409 , L1404 , L1405 , CLASSES1:76 , RFINSEQ:23;
L1416: ( ( fsloc ( 0 ) ) .--> C221 ) c= ( Result (C218 , C217) ) by L1407 , L1399 , FUNCT_4:85;
L1417: ( dom ( ( fsloc ( 0 ) ) .--> C222 ) ) c= ( dom ( D426 +* D427 ) ) by L1377 , L1414 , L1413 , FUNCOP_1:13;
L1418: ( ( fsloc ( 0 ) ) .--> C222 ) c= ( ( Result (C218 , C217) ) | ( dom ( D426 +* D427 ) ) ) by L1417 , L1416 , L1415 , RELAT_1:151;
thus L1419: thesis by L1418 , L1411 , L1401;
end;
