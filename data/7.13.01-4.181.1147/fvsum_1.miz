:: Sum and Product of Finite Sequences of Elements of a Field
::  by Katarzyna Zawadzka
::
:: Received December 29, 1992
:: Copyright (c) 1992-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, RLVECT_1, XBOOLE_0, ALGSTR_0, BINOP_1,
      FUNCT_1, ARYTM_3, RELAT_1, VECTSP_1, MESFUNC1, ALGSTR_1, SUPINF_2,
      SETWISEO, LATTICES, STRUCT_0, FUNCOP_1, ARYTM_1, FINSEQOP, FINSEQ_1,
      FINSEQ_2, TARSKI, RVSUM_1, ORDINAL4, XXREAL_0, NAT_1, CARD_3, FINSUB_1,
      FINSEQ_4, SETWOP_2, FINSET_1, CARD_1, PARTFUN1, FINSOP_1, GROUP_1,
      FVSUM_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, ORDINAL1, NAT_1,
      RELAT_1, FUNCT_1, STRUCT_0, ALGSTR_0, PARTFUN1, FUNCT_2, FINSEQ_1,
      FINSEQ_4, BINOP_1, FUNCOP_1, RLVECT_1, SETWISEO, FINSOP_1, FINSEQ_2,
      FINSEQOP, SETWOP_2, GROUP_1, ALGSTR_1, GROUP_4, VECTSP_1, FINSET_1,
      FINSUB_1, MATRIX_2, XXREAL_0;
 constructors PARTFUN1, BINOP_1, SETWISEO, SQUARE_1, NAT_1, FINSEQOP, FINSEQ_4,
      FINSOP_1, SETWOP_2, ALGSTR_1, GROUP_4, MATRIX_2, RELSET_1;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, FUNCT_2, FINSET_1,
      FINSUB_1, XREAL_0, NAT_1, FINSEQ_1, FINSEQ_2, STRUCT_0, VECTSP_1,
      ALGSTR_1, CARD_1, GROUP_1;
 requirements NUMERALS, REAL, BOOLE, SUBSET;
 definitions SETWISEO, ALGSTR_1, GROUP_4, RLVECT_1, ALGSTR_0;
 theorems FINSEQ_1, FINSEQ_2, TARSKI, FUNCT_1, FUNCT_2, NAT_1, BINOP_1,
      FINSEQOP, VECTSP_1, FUNCOP_1, SETWOP_2, RLVECT_1, RELAT_1, SETWISEO,
      FINSEQ_3, ZFMISC_1, FINSEQ_4, ALGSTR_1, FINSOP_1, XBOOLE_0, XBOOLE_1,
      XCMPLX_1, ORDINAL1, GROUP_4, XXREAL_0, PARTFUN1, CARD_1;
 schemes NAT_1, FUNCT_2;

begin
theorem
L1: (for B1 being  Abelian non  empty addLoopStr holds (the addF of B1) is  commutative)
proof
let C1 being  Abelian non  empty addLoopStr;
L2:
now
let C2 , C3 being (Element of C1);
thus L3: ( (the addF of C1) . (C2 , C3) ) = ( C2 + C3 )
.= ( (the addF of C1) . (C3 , C2) ) by RLVECT_1:2;
end;
thus L4: thesis by L2 , BINOP_1:def 2;
end;
theorem
L5: (for B2 being  add-associative non  empty addLoopStr holds (the addF of B2) is  associative)
proof
let C4 being  add-associative non  empty addLoopStr;
L6:
now
let C5 , C6 , C7 being (Element of C4);
thus L7: ( (the addF of C4) . (C5 , ( (the addF of C4) . (C6 , C7) )) ) = ( C5 + ( C6 + C7 ) )
.= ( ( C5 + C6 ) + C7 ) by RLVECT_1:def 3
.= ( (the addF of C4) . (( (the addF of C4) . (C5 , C6) ) , C7) );
end;
thus L8: thesis by L6 , BINOP_1:def 3;
end;
theorem
L9: (for B3 being  commutative non  empty multMagma holds (the multF of B3) is  commutative)
proof
let C8 being  commutative non  empty multMagma;
L10:
now
let C9 , C10 being (Element of C8);
thus L11: ( (the multF of C8) . (C9 , C10) ) = ( C9 * C10 )
.= ( C10 * C9 )
.= ( (the multF of C8) . (C10 , C9) );
end;
thus L12: thesis by L10 , BINOP_1:def 2;
end;
registration
let C11 being  Abelian non  empty addLoopStr;
cluster (the addF of C11) ->  commutative;
coherence by L1;
end;
registration
let C12 being  add-associative non  empty addLoopStr;
cluster (the addF of C12) ->  associative;
coherence by L5;
end;
registration
let C13 being  commutative non  empty multMagma;
cluster (the multF of C13) ->  commutative;
coherence by L9;
end;
theorem
L16: (for B4 being  commutative  left_unital non  empty multLoopStr holds ( 1. B4 ) is_a_unity_wrt (the multF of B4))
proof
let C14 being  commutative  left_unital non  empty multLoopStr;
set D1 = (the multF of C14);
L17:
now
let C15 being (Element of C14);
thus L18: ( D1 . (( 1. C14 ) , C15) ) = ( ( 1. C14 ) * C15 )
.= C15 by VECTSP_1:def 8;
thus L19: ( D1 . (C15 , ( 1. C14 )) ) = ( C15 * ( 1. C14 ) )
.= C15 by VECTSP_1:def 8;
end;
thus L20: thesis by L17 , BINOP_1:3;
end;
theorem
L21: (for B5 being  commutative  left_unital non  empty multLoopStr holds ( the_unity_wrt (the multF of B5) ) = ( 1. B5 ))
proof
let C16 being  commutative  left_unital non  empty multLoopStr;
reconsider D2 = ( 1. C16 ) as (Element of C16);
L22: D2 is_a_unity_wrt (the multF of C16) by L16;
thus L23: thesis by L22 , BINOP_1:def 8;
end;
theorem
L24: (for B6 being  left_zeroed  right_zeroed non  empty addLoopStr holds ( 0. B6 ) is_a_unity_wrt (the addF of B6))
proof
let C17 being  left_zeroed  right_zeroed non  empty addLoopStr;
L25:
now
let C18 being (Element of C17);
thus L26: ( (the addF of C17) . (( 0. C17 ) , C18) ) = ( ( 0. C17 ) + C18 )
.= C18 by ALGSTR_1:def 2;
thus L27: ( (the addF of C17) . (C18 , ( 0. C17 )) ) = ( C18 + ( 0. C17 ) )
.= C18 by RLVECT_1:def 4;
end;
thus L28: thesis by L25 , BINOP_1:3;
end;
theorem
L29: (for B7 being  left_zeroed  right_zeroed non  empty addLoopStr holds ( the_unity_wrt (the addF of B7) ) = ( 0. B7 ))
proof
let C19 being  left_zeroed  right_zeroed non  empty addLoopStr;
reconsider D3 = ( 0. C19 ) as (Element of C19);
L30: D3 is_a_unity_wrt (the addF of C19) by L24;
thus L31: thesis by L30 , BINOP_1:def 8;
end;
theorem
L32: (for B8 being  left_zeroed  right_zeroed non  empty addLoopStr holds (the addF of B8) is  having_a_unity)
proof
let C20 being  left_zeroed  right_zeroed non  empty addLoopStr;
take ( 0. C20 );
thus L33: thesis by L24;
end;
theorem
L34: (for B9 being  commutative  left_unital non  empty multLoopStr holds (the multF of B9) is  having_a_unity);
theorem
L35: (for B10 being  distributive non  empty doubleLoopStr holds (the multF of B10) is_distributive_wrt (the addF of B10))
proof
let C21 being  distributive non  empty doubleLoopStr;
L36:
now
let C22 , C23 , C24 being (Element of C21);
thus L37: ( (the multF of C21) . (C22 , ( (the addF of C21) . (C23 , C24) )) ) = ( C22 * ( C23 + C24 ) )
.= ( ( C22 * C23 ) + ( C22 * C24 ) ) by VECTSP_1:def 7
.= ( (the addF of C21) . (( (the multF of C21) . (C22 , C23) ) , ( (the multF of C21) . (C22 , C24) )) );
thus L38: ( (the multF of C21) . (( (the addF of C21) . (C22 , C23) ) , C24) ) = ( ( C22 + C23 ) * C24 )
.= ( ( C22 * C24 ) + ( C23 * C24 ) ) by VECTSP_1:def 7
.= ( (the addF of C21) . (( (the multF of C21) . (C22 , C24) ) , ( (the multF of C21) . (C23 , C24) )) );
end;
thus L39: thesis by L36 , BINOP_1:11;
end;
definition
let C25 being non  empty multMagma;
let C26 being (Element of C25);
func C26 multfield -> (UnOp of (the carrier of C25)) equals 
( (the multF of C25) [;] (C26 , ( id (the carrier of C25) )) );
coherence;
end;
definition
let C27 being non  empty addLoopStr;
func diffield C27 -> (BinOp of (the carrier of C27)) equals 
( (the addF of C27) * (( id (the carrier of C27) ) , ( comp C27 )) );
correctness;
end;
theorem
L42: (for B11 being non  empty addLoopStr holds (for B12 , B13 being (Element of B11) holds ( ( diffield B11 ) . (B12 , B13) ) = ( B12 - B13 )))
proof
let C28 being non  empty addLoopStr;
let C29 , C30 being (Element of C28);
thus L43: ( ( diffield C28 ) . (C29 , C30) ) = ( (the addF of C28) . (C29 , ( ( comp C28 ) . C30 )) ) by FINSEQOP:82
.= ( C29 - C30 ) by VECTSP_1:def 13;
end;
L44: (for B14 being non  empty multMagma holds (for B15 , B16 being (Element of B14) holds ( ( (the multF of B14) [;] (B16 , ( id (the carrier of B14) )) ) . B15 ) = ( B16 * B15 )))
proof
let C31 being non  empty multMagma;
let C32 , C33 being (Element of C31);
thus L45: ( ( (the multF of C31) [;] (C33 , ( id (the carrier of C31) )) ) . C32 ) = ( (the multF of C31) . (C33 , ( ( id (the carrier of C31) ) . C32 )) ) by FUNCOP_1:53
.= ( C33 * C32 ) by FUNCT_1:18;
end;
theorem
L46: (for B17 being  distributive non  empty doubleLoopStr holds (for B18 being (Element of B17) holds ( B18 multfield ) is_distributive_wrt (the addF of B17))) by L35 , FINSEQOP:54;
theorem
L47: (for B19 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds ( comp B19 ) is_an_inverseOp_wrt (the addF of B19))
proof
let C34 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
L48:
now
let C35 being (Element of C34);
thus L49: ( (the addF of C34) . (C35 , ( ( comp C34 ) . C35 )) ) = ( C35 + ( - C35 ) ) by VECTSP_1:def 13
.= ( 0. C34 ) by RLVECT_1:5
.= ( the_unity_wrt (the addF of C34) ) by L29;
thus L50: ( (the addF of C34) . (( ( comp C34 ) . C35 ) , C35) ) = ( ( - C35 ) + C35 ) by VECTSP_1:def 13
.= ( 0. C34 ) by RLVECT_1:5
.= ( the_unity_wrt (the addF of C34) ) by L29;
end;
thus L51: thesis by L48 , FINSEQOP:def 1;
end;
theorem
L52: (for B20 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (the addF of B20) is  having_an_inverseOp)
proof
let C36 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
L53: ( comp C36 ) is_an_inverseOp_wrt (the addF of C36) by L47;
thus L54: thesis by L53 , FINSEQOP:def 2;
end;
theorem
L55: (for B21 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds ( the_inverseOp_wrt (the addF of B21) ) = ( comp B21 ))
proof
let C37 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
L56: ( comp C37 ) is_an_inverseOp_wrt (the addF of C37) by L47;
L57: ((the addF of C37) is  having_a_unity & (the addF of C37) is  having_an_inverseOp) by L32 , L52;
thus L58: thesis by L57 , L56 , FINSEQOP:def 3;
end;
theorem
L59: (for B22 being  right_zeroed  add-associative  right_complementable  Abelian non  empty addLoopStr holds ( comp B22 ) is_distributive_wrt (the addF of B22))
proof
let C38 being  right_zeroed  add-associative  right_complementable  Abelian non  empty addLoopStr;
L60: (the addF of C38) is  having_a_unity by L32;
L61: ( the_inverseOp_wrt (the addF of C38) ) is_distributive_wrt (the addF of C38) by L60 , L52 , FINSEQOP:63;
thus L62: thesis by L61 , L55;
end;
begin
definition
let C39 being non  empty addLoopStr;
let C40 , C41 being (FinSequence of (the carrier of C39));
func C40 + C41 -> (FinSequence of (the carrier of C39)) equals 
( (the addF of C39) .: (C40 , C41) );
correctness;
end;
theorem
L64: (for B23 being non  empty addLoopStr holds (for B24 , B25 being (FinSequence of (the carrier of B23)) holds (for B26 , B27 being (Element of B23) holds (for B28 being (Element of ( NAT )) holds ((B28 in ( dom ( B24 + B25 ) ) & B26 = ( B24 . B28 ) & B27 = ( B25 . B28 )) implies ( ( B24 + B25 ) . B28 ) = ( B26 + B27 )))))) by FUNCOP_1:22;
definition
let R1 being (Element of ( NAT ));
let C42 being non  empty addLoopStr;
let C43 , C44 being (Element of ( R1 -tuples_on (the carrier of C42) ));
redefine func C43 + C44 -> (Element of ( R1 -tuples_on (the carrier of C42) ));

coherence by FINSEQ_2:120;
end;
theorem
L66: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for B29 being non  empty addLoopStr holds (for B30 , B31 being (Element of B29) holds (for B32 , B33 being (Element of ( R1 -tuples_on (the carrier of B29) )) holds ((R2 in ( Seg R1 ) & B30 = ( B32 . R2 ) & B31 = ( B33 . R2 )) implies ( ( B32 + B33 ) . R2 ) = ( B30 + B31 )))))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let C45 being non  empty addLoopStr;
let C46 , C47 being (Element of C45);
let C48 , C49 being (Element of ( R1 -tuples_on (the carrier of C45) ));
assume L67: R2 in ( Seg R1 );
L68: R2 in ( Seg ( len ( C48 + C49 ) ) ) by L67 , CARD_1:def 7;
L69: R2 in ( dom ( C48 + C49 ) ) by L68 , FINSEQ_1:def 3;
thus L70: thesis by L69 , FUNCOP_1:22;
end;
theorem
L71: (for B34 being non  empty addLoopStr holds (for B35 , B36 being (Element of B34) holds ( <* B35 *> + <* B36 *> ) = <* ( B35 + B36 ) *>)) by FINSEQ_2:74;
theorem
L72: (for R1 being (Element of ( NAT )) holds (for B37 being non  empty addLoopStr holds (for B38 , B39 being (Element of B37) holds ( ( R1 |-> B38 ) + ( R1 |-> B39 ) ) = ( R1 |-> ( B38 + B39 ) )))) by FINSEQOP:17;
L73: (for R1 being (Element of ( NAT )) holds (for B40 being  left_zeroed  right_zeroed non  empty addLoopStr holds (for B41 being (Element of ( R1 -tuples_on (the carrier of B40) )) holds ( B41 + ( R1 |-> ( 0. B40 ) ) ) = B41)))
proof
let R1 being (Element of ( NAT ));
let C50 being  left_zeroed  right_zeroed non  empty addLoopStr;
let C51 being (Element of ( R1 -tuples_on (the carrier of C50) ));
L74: (( the_unity_wrt (the addF of C50) ) = ( 0. C50 ) & (the addF of C50) is  having_a_unity) by L29 , L32;
thus L75: thesis by L74 , FINSEQOP:56;
end;
theorem
L76: (for R1 being (Element of ( NAT )) holds (for B42 being  Abelian  left_zeroed  right_zeroed non  empty addLoopStr holds (for B43 being (Element of ( R1 -tuples_on (the carrier of B42) )) holds (( B43 + ( R1 |-> ( 0. B42 ) ) ) = B43 & B43 = ( ( R1 |-> ( 0. B42 ) ) + B43 )))))
proof
let R1 being (Element of ( NAT ));
let C52 being  Abelian  left_zeroed  right_zeroed non  empty addLoopStr;
let C53 being (Element of ( R1 -tuples_on (the carrier of C52) ));
thus L77: ( C53 + ( R1 |-> ( 0. C52 ) ) ) = C53 by L73;
thus L78: thesis by L77 , FINSEQOP:33;
end;
definition
let C54 being non  empty addLoopStr;
let C55 being (FinSequence of (the carrier of C54));
func - C55 -> (FinSequence of (the carrier of C54)) equals 
( ( comp C54 ) * C55 );
correctness;
end;
theorem
L80: (for R1 being (Element of ( NAT )) holds (for R4 being non  empty addLoopStr holds (for R5 being (Element of R4) holds (for R6 being (FinSequence of (the carrier of R4)) holds ((R1 in ( dom ( - R6 ) ) & R5 = ( R6 . R1 )) implies ( ( - R6 ) . R1 ) = ( - R5 ))))))
proof
let R1 being (Element of ( NAT ));
let R4 being non  empty addLoopStr;
let R5 being (Element of R4);
let R6 being (FinSequence of (the carrier of R4));
assume L81: (R1 in ( dom ( - R6 ) ) & R5 = ( R6 . R1 ));
L82: ( ( - R6 ) . R1 ) = ( ( comp R4 ) . R5 ) by L81 , FUNCT_1:12;
thus L83: thesis by L82 , VECTSP_1:def 13;
end;
definition
let R1 being (Element of ( NAT ));
let C56 being non  empty addLoopStr;
let C57 being (Element of ( R1 -tuples_on (the carrier of C56) ));
redefine func - C57 -> (Element of ( R1 -tuples_on (the carrier of C56) ));

coherence by FINSEQ_2:113;
end;
theorem
L85: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R4 being non  empty addLoopStr holds (for R5 being (Element of R4) holds (for R7 being (Element of ( R1 -tuples_on (the carrier of R4) )) holds ((R2 in ( Seg R1 ) & R5 = ( R7 . R2 )) implies ( ( - R7 ) . R2 ) = ( - R5 )))))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R4 being non  empty addLoopStr;
let R5 being (Element of R4);
let R7 being (Element of ( R1 -tuples_on (the carrier of R4) ));
assume L86: R2 in ( Seg R1 );
L87: R2 in ( Seg ( len ( - R7 ) ) ) by L86 , CARD_1:def 7;
L88: R2 in ( dom ( - R7 ) ) by L87 , FINSEQ_1:def 3;
thus L89: thesis by L88 , L80;
end;
theorem
L90: (for R4 being non  empty addLoopStr holds (for R5 being (Element of R4) holds ( - <* R5 *> ) = <* ( - R5 ) *>))
proof
let R4 being non  empty addLoopStr;
let R5 being (Element of R4);
thus L91: ( - <* R5 *> ) = <* ( ( comp R4 ) . R5 ) *> by FINSEQ_2:35
.= <* ( - R5 ) *> by VECTSP_1:def 13;
end;
theorem
L92: (for R1 being (Element of ( NAT )) holds (for R4 being non  empty addLoopStr holds (for R5 being (Element of R4) holds ( - ( R1 |-> R5 ) ) = ( R1 |-> ( - R5 ) ))))
proof
let R1 being (Element of ( NAT ));
let R4 being non  empty addLoopStr;
let R5 being (Element of R4);
thus L93: ( - ( R1 |-> R5 ) ) = ( R1 |-> ( ( comp R4 ) . R5 ) ) by FINSEQOP:16
.= ( R1 |-> ( - R5 ) ) by VECTSP_1:def 13;
end;
L94: (for R1 being (Element of ( NAT )) holds (for B44 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for B45 being (Element of ( R1 -tuples_on (the carrier of B44) )) holds ( B45 + ( - B45 ) ) = ( R1 |-> ( 0. B44 ) ))))
proof
let R1 being (Element of ( NAT ));
let C58 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let C59 being (Element of ( R1 -tuples_on (the carrier of C58) ));
L95: ((the addF of C58) is  having_an_inverseOp & (the addF of C58) is  having_a_unity) by L32 , L52;
thus L96: ( C59 + ( - C59 ) ) = ( (the addF of C58) .: (C59 , ( ( the_inverseOp_wrt (the addF of C58) ) * C59 )) ) by L55
.= ( R1 |-> ( the_unity_wrt (the addF of C58) ) ) by L95 , FINSEQOP:73
.= ( R1 |-> ( 0. C58 ) ) by L29;
end;
theorem
L97: (for R1 being (Element of ( NAT )) holds (for B46 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for B47 being (Element of ( R1 -tuples_on (the carrier of B46) )) holds (( B47 + ( - B47 ) ) = ( R1 |-> ( 0. B46 ) ) & ( ( - B47 ) + B47 ) = ( R1 |-> ( 0. B46 ) )))))
proof
let R1 being (Element of ( NAT ));
let C60 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let C61 being (Element of ( R1 -tuples_on (the carrier of C60) ));
thus L98: ( C61 + ( - C61 ) ) = ( R1 |-> ( 0. C60 ) ) by L94;
thus L99: thesis by L98 , FINSEQOP:33;
end;
theorem
L100: (for R1 being (Element of ( NAT )) holds (for R8 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for R10 being (Element of ( R1 -tuples_on (the carrier of R8) )) holds (for R11 being (Element of ( R1 -tuples_on (the carrier of R8) )) holds (( R10 + R11 ) = ( R1 |-> ( 0. R8 ) ) implies (R10 = ( - R11 ) & R11 = ( - R10 )))))))
proof
let R1 being (Element of ( NAT ));
let R8 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let R10 being (Element of ( R1 -tuples_on (the carrier of R8) ));
let R11 being (Element of ( R1 -tuples_on (the carrier of R8) ));
L101: ((the addF of R8) is  having_an_inverseOp & ( the_inverseOp_wrt (the addF of R8) ) = ( comp R8 )) by L52 , L55;
L102: (( the_unity_wrt (the addF of R8) ) = ( 0. R8 ) & (the addF of R8) is  having_a_unity) by L29 , L32;
thus L103: thesis by L102 , L101 , FINSEQOP:74;
end;
theorem
L104: (for R1 being (Element of ( NAT )) holds (for R8 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for R9 being (Element of ( R1 -tuples_on (the carrier of R8) )) holds ( - ( - R9 ) ) = R9)))
proof
let R1 being (Element of ( NAT ));
let R8 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let R9 being (Element of ( R1 -tuples_on (the carrier of R8) ));
L105: ( R9 + ( - R9 ) ) = ( R1 |-> ( 0. R8 ) ) by L94;
thus L106: thesis by L105 , L100;
end;
theorem
L107: (for R1 being (Element of ( NAT )) holds (for R8 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for R10 being (Element of ( R1 -tuples_on (the carrier of R8) )) holds (for R11 being (Element of ( R1 -tuples_on (the carrier of R8) )) holds (( - R10 ) = ( - R11 ) implies R10 = R11)))))
proof
let R1 being (Element of ( NAT ));
let R8 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let R10 being (Element of ( R1 -tuples_on (the carrier of R8) ));
let R11 being (Element of ( R1 -tuples_on (the carrier of R8) ));
assume L108: ( - R10 ) = ( - R11 );
thus L109: R10 = ( - ( - R11 ) ) by L108 , L104
.= R11 by L104;
end;
L110: (for R1 being (Element of ( NAT )) holds (for R8 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for R9 being (Element of ( R1 -tuples_on (the carrier of R8) )) holds (for R10 being (Element of ( R1 -tuples_on (the carrier of R8) )) holds (for R11 being (Element of ( R1 -tuples_on (the carrier of R8) )) holds (( R10 + R9 ) = ( R11 + R9 ) implies R10 = R11))))))
proof
let R1 being (Element of ( NAT ));
let R8 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let R9 being (Element of ( R1 -tuples_on (the carrier of R8) ));
let R10 being (Element of ( R1 -tuples_on (the carrier of R8) ));
let R11 being (Element of ( R1 -tuples_on (the carrier of R8) ));
assume L111: ( R10 + R9 ) = ( R11 + R9 );
L112: ( R10 + ( R9 + ( - R9 ) ) ) = ( ( R11 + R9 ) + ( - R9 ) ) by L111 , FINSEQOP:28;
L113: ( R10 + ( R9 + ( - R9 ) ) ) = ( R11 + ( R9 + ( - R9 ) ) ) by L112 , FINSEQOP:28;
L114: ( R9 + ( - R9 ) ) = ( R1 |-> ( 0. R8 ) ) by L94;
L115: R10 = ( R11 + ( R1 |-> ( 0. R8 ) ) ) by L114 , L113 , L73;
thus L116: thesis by L115 , L73;
end;
theorem
L117: (for R1 being (Element of ( NAT )) holds (for B48 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for B49 , B50 , B51 being (Element of ( R1 -tuples_on (the carrier of B48) )) holds ((( B50 + B49 ) = ( B51 + B49 ) or ( B50 + B49 ) = ( B49 + B51 )) implies B50 = B51))))
proof
let R1 being (Element of ( NAT ));
let C62 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let C63 , C64 , C65 being (Element of ( R1 -tuples_on (the carrier of C62) ));
L118: (( C64 + C63 ) = ( C65 + C63 ) iff ( C64 + C63 ) = ( C63 + C65 )) by FINSEQOP:33;
thus L119: thesis by L118 , L110;
end;
theorem
L120: (for R1 being (Element of ( NAT )) holds (for B52 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for B53 , B54 being (Element of ( R1 -tuples_on (the carrier of B52) )) holds ( - ( B53 + B54 ) ) = ( ( - B53 ) + ( - B54 ) ))))
proof
let R1 being (Element of ( NAT ));
let C66 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let C67 , C68 being (Element of ( R1 -tuples_on (the carrier of C66) ));
L121: ( ( C67 + C68 ) + ( ( - C67 ) + ( - C68 ) ) ) = ( ( ( C67 + C68 ) + ( - C67 ) ) + ( - C68 ) ) by FINSEQOP:28
.= ( ( ( C68 + C67 ) + ( - C67 ) ) + ( - C68 ) ) by FINSEQOP:33
.= ( ( C68 + ( C67 + ( - C67 ) ) ) + ( - C68 ) ) by FINSEQOP:28
.= ( ( C68 + ( R1 |-> ( 0. C66 ) ) ) + ( - C68 ) ) by L94
.= ( C68 + ( - C68 ) ) by L73
.= ( R1 |-> ( 0. C66 ) ) by L94;
thus L122: thesis by L121 , L100;
end;
definition
let C69 being non  empty addLoopStr;
let C70 , C71 being (FinSequence of (the carrier of C69));
func C70 - C71 -> (FinSequence of (the carrier of C69)) equals 
( ( diffield C69 ) .: (C70 , C71) );
correctness;
end;
theorem
L124: (for R1 being (Element of ( NAT )) holds (for R12 being non  empty addLoopStr holds (for R13 being (Element of R12) holds (for R14 being (Element of R12) holds (for R15 being (FinSequence of (the carrier of R12)) holds (for R16 being (FinSequence of (the carrier of R12)) holds ((R1 in ( dom ( R15 - R16 ) ) & R13 = ( R15 . R1 ) & R14 = ( R16 . R1 )) implies ( ( R15 - R16 ) . R1 ) = ( R13 - R14 ))))))))
proof
let R1 being (Element of ( NAT ));
let R12 being non  empty addLoopStr;
let R13 being (Element of R12);
let R14 being (Element of R12);
let R15 being (FinSequence of (the carrier of R12));
let R16 being (FinSequence of (the carrier of R12));
assume L125: (R1 in ( dom ( R15 - R16 ) ) & R13 = ( R15 . R1 ) & R14 = ( R16 . R1 ));
L126: ( ( R15 - R16 ) . R1 ) = ( ( diffield R12 ) . (R13 , R14) ) by L125 , FUNCOP_1:22;
thus L127: thesis by L126 , L42;
end;
definition
let R1 being (Element of ( NAT ));
let C72 being non  empty addLoopStr;
let C73 , C74 being (Element of ( R1 -tuples_on (the carrier of C72) ));
redefine func C73 - C74 -> (Element of ( R1 -tuples_on (the carrier of C72) ));

coherence by FINSEQ_2:120;
end;
theorem
L129: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R12 being non  empty addLoopStr holds (for R13 being (Element of R12) holds (for R14 being (Element of R12) holds (for R17 being (Element of ( R1 -tuples_on (the carrier of R12) )) holds (for R18 being (Element of ( R1 -tuples_on (the carrier of R12) )) holds ((R2 in ( Seg R1 ) & R13 = ( R17 . R2 ) & R14 = ( R18 . R2 )) implies ( ( R17 - R18 ) . R2 ) = ( R13 - R14 )))))))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R12 being non  empty addLoopStr;
let R13 being (Element of R12);
let R14 being (Element of R12);
let R17 being (Element of ( R1 -tuples_on (the carrier of R12) ));
let R18 being (Element of ( R1 -tuples_on (the carrier of R12) ));
assume L130: R2 in ( Seg R1 );
L131: R2 in ( Seg ( len ( R17 - R18 ) ) ) by L130 , CARD_1:def 7;
L132: R2 in ( dom ( R17 - R18 ) ) by L131 , FINSEQ_1:def 3;
thus L133: thesis by L132 , L124;
end;
theorem
L134: (for R12 being non  empty addLoopStr holds (for R13 being (Element of R12) holds (for R14 being (Element of R12) holds ( <* R13 *> - <* R14 *> ) = <* ( R13 - R14 ) *>)))
proof
let R12 being non  empty addLoopStr;
let R13 being (Element of R12);
let R14 being (Element of R12);
thus L135: ( <* R13 *> - <* R14 *> ) = <* ( ( diffield R12 ) . (R13 , R14) ) *> by FINSEQ_2:74
.= <* ( R13 - R14 ) *> by L42;
end;
theorem
L136: (for R1 being (Element of ( NAT )) holds (for R12 being non  empty addLoopStr holds (for R13 being (Element of R12) holds (for R14 being (Element of R12) holds ( ( R1 |-> R13 ) - ( R1 |-> R14 ) ) = ( R1 |-> ( R13 - R14 ) )))))
proof
let R1 being (Element of ( NAT ));
let R12 being non  empty addLoopStr;
let R13 being (Element of R12);
let R14 being (Element of R12);
thus L137: ( ( R1 |-> R13 ) - ( R1 |-> R14 ) ) = ( R1 |-> ( ( diffield R12 ) . (R13 , R14) ) ) by FINSEQOP:17
.= ( R1 |-> ( R13 - R14 ) ) by L42;
end;
theorem
L138: (for R1 being (Element of ( NAT )) holds (for B55 being  add-associative  right_complementable  left_zeroed  right_zeroed non  empty addLoopStr holds (for B56 being (Element of ( R1 -tuples_on (the carrier of B55) )) holds ( B56 - ( R1 |-> ( 0. B55 ) ) ) = B56)))
proof
let R1 being (Element of ( NAT ));
let C75 being  add-associative  right_complementable  left_zeroed  right_zeroed non  empty addLoopStr;
let C76 being (Element of ( R1 -tuples_on (the carrier of C75) ));
thus L139: ( C76 - ( R1 |-> ( 0. C75 ) ) ) = ( C76 + ( - ( R1 |-> ( 0. C75 ) ) ) ) by FINSEQOP:84
.= ( C76 + ( R1 |-> ( - ( 0. C75 ) ) ) ) by L92
.= ( C76 + ( R1 |-> ( 0. C75 ) ) ) by RLVECT_1:12
.= C76 by L73;
end;
theorem
L140: (for R1 being (Element of ( NAT )) holds (for B57 being  Abelian  left_zeroed  right_zeroed non  empty addLoopStr holds (for B58 being (Element of ( R1 -tuples_on (the carrier of B57) )) holds ( ( R1 |-> ( 0. B57 ) ) - B58 ) = ( - B58 ))))
proof
let R1 being (Element of ( NAT ));
let C77 being  Abelian  left_zeroed  right_zeroed non  empty addLoopStr;
let C78 being (Element of ( R1 -tuples_on (the carrier of C77) ));
thus L141: ( ( R1 |-> ( 0. C77 ) ) - C78 ) = ( ( R1 |-> ( 0. C77 ) ) + ( - C78 ) ) by FINSEQOP:84
.= ( - C78 ) by L76;
end;
theorem
L142: (for R1 being (Element of ( NAT )) holds (for B59 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for B60 , B61 being (Element of ( R1 -tuples_on (the carrier of B59) )) holds ( B60 - ( - B61 ) ) = ( B60 + B61 ))))
proof
let R1 being (Element of ( NAT ));
let C79 being  left_zeroed  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let C80 , C81 being (Element of ( R1 -tuples_on (the carrier of C79) ));
thus L143: ( C80 - ( - C81 ) ) = ( C80 + ( - ( - C81 ) ) ) by FINSEQOP:84
.= ( C80 + C81 ) by L104;
end;
theorem
L144: (for R1 being (Element of ( NAT )) holds (for R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for R21 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds (for R22 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds ( - ( R21 - R22 ) ) = ( R22 - R21 )))))
proof
let R1 being (Element of ( NAT ));
let R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let R21 being (Element of ( R1 -tuples_on (the carrier of R19) ));
let R22 being (Element of ( R1 -tuples_on (the carrier of R19) ));
thus L145: ( - ( R21 - R22 ) ) = ( - ( R21 + ( - R22 ) ) ) by FINSEQOP:84
.= ( ( - R21 ) + ( - ( - R22 ) ) ) by L120
.= ( ( - R21 ) + R22 ) by L104
.= ( R22 + ( - R21 ) ) by FINSEQOP:33
.= ( R22 - R21 ) by FINSEQOP:84;
end;
theorem
L146: (for R1 being (Element of ( NAT )) holds (for R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for R21 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds (for R22 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds ( - ( R21 - R22 ) ) = ( ( - R21 ) + R22 )))))
proof
let R1 being (Element of ( NAT ));
let R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let R21 being (Element of ( R1 -tuples_on (the carrier of R19) ));
let R22 being (Element of ( R1 -tuples_on (the carrier of R19) ));
thus L147: ( - ( R21 - R22 ) ) = ( - ( R21 + ( - R22 ) ) ) by FINSEQOP:84
.= ( ( - R21 ) + ( - ( - R22 ) ) ) by L120
.= ( ( - R21 ) + R22 ) by L104;
end;
theorem
L148: (for R1 being (Element of ( NAT )) holds (for R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for R20 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds ( R20 - R20 ) = ( R1 |-> ( 0. R19 ) ))))
proof
let R1 being (Element of ( NAT ));
let R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let R20 being (Element of ( R1 -tuples_on (the carrier of R19) ));
thus L149: ( R20 - R20 ) = ( R20 + ( - R20 ) ) by FINSEQOP:84
.= ( R1 |-> ( 0. R19 ) ) by L94;
end;
theorem
L150: (for R1 being (Element of ( NAT )) holds (for R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for R21 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds (for R22 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds (( R21 - R22 ) = ( R1 |-> ( 0. R19 ) ) implies R21 = R22)))))
proof
let R1 being (Element of ( NAT ));
let R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let R21 being (Element of ( R1 -tuples_on (the carrier of R19) ));
let R22 being (Element of ( R1 -tuples_on (the carrier of R19) ));
assume L151: ( R21 - R22 ) = ( R1 |-> ( 0. R19 ) );
L152: ( R21 + ( - R22 ) ) = ( R1 |-> ( 0. R19 ) ) by L151 , FINSEQOP:84;
L153: R21 = ( - ( - R22 ) ) by L152 , L100;
thus L154: thesis by L153 , L104;
end;
theorem
L155: (for R1 being (Element of ( NAT )) holds (for R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for R21 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds (for R22 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds (for R23 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds ( ( R21 - R22 ) - R23 ) = ( R21 - ( R22 + R23 ) ))))))
proof
let R1 being (Element of ( NAT ));
let R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let R21 being (Element of ( R1 -tuples_on (the carrier of R19) ));
let R22 being (Element of ( R1 -tuples_on (the carrier of R19) ));
let R23 being (Element of ( R1 -tuples_on (the carrier of R19) ));
thus L156: ( ( R21 - R22 ) - R23 ) = ( ( R21 - R22 ) + ( - R23 ) ) by FINSEQOP:84
.= ( ( R21 + ( - R22 ) ) + ( - R23 ) ) by FINSEQOP:84
.= ( R21 + ( ( - R22 ) + ( - R23 ) ) ) by FINSEQOP:28
.= ( R21 + ( - ( R22 + R23 ) ) ) by L120
.= ( R21 - ( R22 + R23 ) ) by FINSEQOP:84;
end;
theorem
L157: (for R1 being (Element of ( NAT )) holds (for R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for R21 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds (for R22 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds (for R23 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds ( R21 + ( R22 - R23 ) ) = ( ( R21 + R22 ) - R23 ))))))
proof
let R1 being (Element of ( NAT ));
let R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let R21 being (Element of ( R1 -tuples_on (the carrier of R19) ));
let R22 being (Element of ( R1 -tuples_on (the carrier of R19) ));
let R23 being (Element of ( R1 -tuples_on (the carrier of R19) ));
thus L158: ( R21 + ( R22 - R23 ) ) = ( R21 + ( R22 + ( - R23 ) ) ) by FINSEQOP:84
.= ( ( R21 + R22 ) + ( - R23 ) ) by FINSEQOP:28
.= ( ( R21 + R22 ) - R23 ) by FINSEQOP:84;
end;
theorem
L159: (for R1 being (Element of ( NAT )) holds (for R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for R21 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds (for R22 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds (for R23 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds ( R21 - ( R22 - R23 ) ) = ( ( R21 - R22 ) + R23 ))))))
proof
let R1 being (Element of ( NAT ));
let R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let R21 being (Element of ( R1 -tuples_on (the carrier of R19) ));
let R22 being (Element of ( R1 -tuples_on (the carrier of R19) ));
let R23 being (Element of ( R1 -tuples_on (the carrier of R19) ));
thus L160: ( R21 - ( R22 - R23 ) ) = ( R21 + ( - ( R22 - R23 ) ) ) by FINSEQOP:84
.= ( R21 + ( ( - R22 ) + R23 ) ) by L146
.= ( ( R21 + ( - R22 ) ) + R23 ) by FINSEQOP:28
.= ( ( R21 - R22 ) + R23 ) by FINSEQOP:84;
end;
theorem
L161: (for R1 being (Element of ( NAT )) holds (for R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for R20 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds (for R21 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds R21 = ( ( R21 + R20 ) - R20 )))))
proof
let R1 being (Element of ( NAT ));
let R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let R20 being (Element of ( R1 -tuples_on (the carrier of R19) ));
let R21 being (Element of ( R1 -tuples_on (the carrier of R19) ));
thus L162: R21 = ( R21 + ( R1 |-> ( 0. R19 ) ) ) by L73
.= ( R21 + ( R20 - R20 ) ) by L148
.= ( ( R21 + R20 ) - R20 ) by L157;
end;
theorem
L163: (for R1 being (Element of ( NAT )) holds (for R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for R20 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds (for R21 being (Element of ( R1 -tuples_on (the carrier of R19) )) holds R21 = ( ( R21 - R20 ) + R20 )))))
proof
let R1 being (Element of ( NAT ));
let R19 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let R20 being (Element of ( R1 -tuples_on (the carrier of R19) ));
let R21 being (Element of ( R1 -tuples_on (the carrier of R19) ));
thus L164: R21 = ( R21 + ( R1 |-> ( 0. R19 ) ) ) by L73
.= ( R21 + ( ( - R20 ) + R20 ) ) by L97
.= ( ( R21 + ( - R20 ) ) + R20 ) by FINSEQOP:28
.= ( ( R21 - R20 ) + R20 ) by FINSEQOP:84;
end;
theorem
L165: (for R24 being non  empty multMagma holds (for B62 , B63 being (Element of R24) holds ( ( (the multF of R24) [;] (B62 , ( id (the carrier of R24) )) ) . B63 ) = ( B62 * B63 )))
proof
let R24 being non  empty multMagma;
let C82 , C83 being (Element of R24);
thus L166: ( ( (the multF of R24) [;] (C82 , ( id (the carrier of R24) )) ) . C83 ) = ( (the multF of R24) . (C82 , ( ( id (the carrier of R24) ) . C83 )) ) by FUNCOP_1:53
.= ( C82 * C83 ) by FUNCT_1:18;
end;
theorem
L167: (for R24 being non  empty multMagma holds (for B64 , B65 being (Element of R24) holds ( ( B64 multfield ) . B65 ) = ( B64 * B65 ))) by L165;
definition
let C84 being non  empty multMagma;
let C85 being (FinSequence of (the carrier of C84));
let C86 being (Element of C84);
func C86 * C85 -> (FinSequence of (the carrier of C84)) equals 
( ( C86 multfield ) * C85 );
correctness;
end;
theorem
L169: (for R1 being (Element of ( NAT )) holds (for R24 being non  empty multMagma holds (for R25 being (Element of R24) holds (for R26 being (Element of R24) holds (for R29 being (FinSequence of (the carrier of R24)) holds ((R1 in ( dom ( R25 * R29 ) ) & R26 = ( R29 . R1 )) implies ( ( R25 * R29 ) . R1 ) = ( R25 * R26 )))))))
proof
let R1 being (Element of ( NAT ));
let R24 being non  empty multMagma;
let R25 being (Element of R24);
let R26 being (Element of R24);
let R29 being (FinSequence of (the carrier of R24));
assume L170: (R1 in ( dom ( R25 * R29 ) ) & R26 = ( R29 . R1 ));
L171: R26 in ( dom ( (the multF of R24) [;] (R25 , ( id (the carrier of R24) )) ) ) by L170 , FUNCT_1:11;
thus L172: ( ( R25 * R29 ) . R1 ) = ( ( (the multF of R24) [;] (R25 , ( id (the carrier of R24) )) ) . R26 ) by L170 , FUNCT_1:12
.= ( (the multF of R24) . (R25 , ( ( id (the carrier of R24) ) . R26 )) ) by L171 , FUNCOP_1:32
.= ( R25 * R26 ) by FUNCT_1:18;
end;
definition
let R1 being (Element of ( NAT ));
let C87 being non  empty multMagma;
let C88 being (Element of ( R1 -tuples_on (the carrier of C87) ));
let C89 being (Element of C87);
redefine func C89 * C88 -> (Element of ( R1 -tuples_on (the carrier of C87) ));

coherence by FINSEQ_2:113;
end;
theorem
L174: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R24 being non  empty multMagma holds (for R25 being (Element of R24) holds (for R26 being (Element of R24) holds (for R30 being (Element of ( R1 -tuples_on (the carrier of R24) )) holds ((R2 in ( Seg R1 ) & R26 = ( R30 . R2 )) implies ( ( R25 * R30 ) . R2 ) = ( R25 * R26 ))))))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R24 being non  empty multMagma;
let R25 being (Element of R24);
let R26 being (Element of R24);
let R30 being (Element of ( R1 -tuples_on (the carrier of R24) ));
assume L175: R2 in ( Seg R1 );
L176: R2 in ( Seg ( len ( R25 * R30 ) ) ) by L175 , CARD_1:def 7;
L177: R2 in ( dom ( R25 * R30 ) ) by L176 , FINSEQ_1:def 3;
thus L178: thesis by L177 , L169;
end;
theorem
L179: (for R24 being non  empty multMagma holds (for R25 being (Element of R24) holds (for R27 being (Element of R24) holds ( R25 * <* R27 *> ) = <* ( R25 * R27 ) *>)))
proof
let R24 being non  empty multMagma;
let R25 being (Element of R24);
let R27 being (Element of R24);
thus L180: ( R25 * <* R27 *> ) = <* ( ( (the multF of R24) [;] (R25 , ( id (the carrier of R24) )) ) . R27 ) *> by FINSEQ_2:35
.= <* ( R25 * R27 ) *> by L165;
end;
theorem
L181: (for R1 being (Element of ( NAT )) holds (for R24 being non  empty multMagma holds (for R27 being (Element of R24) holds (for R28 being (Element of R24) holds ( R27 * ( R1 |-> R28 ) ) = ( R1 |-> ( R27 * R28 ) )))))
proof
let R1 being (Element of ( NAT ));
let R24 being non  empty multMagma;
let R27 being (Element of R24);
let R28 being (Element of R24);
thus L182: ( R27 * ( R1 |-> R28 ) ) = ( R1 |-> ( ( (the multF of R24) [;] (R27 , ( id (the carrier of R24) )) ) . R28 ) ) by FINSEQOP:16
.= ( R1 |-> ( R27 * R28 ) ) by L165;
end;
theorem
L183: (for R1 being (Element of ( NAT )) holds (for B66 being  associative non  empty multMagma holds (for B67 , B68 being (Element of B66) holds (for B69 being (Element of ( R1 -tuples_on (the carrier of B66) )) holds ( ( B67 * B68 ) * B69 ) = ( B67 * ( B68 * B69 ) )))))
proof
let R1 being (Element of ( NAT ));
let C90 being  associative non  empty multMagma;
let C91 , C92 being (Element of C90);
let C93 being (Element of ( R1 -tuples_on (the carrier of C90) ));
set D4 = (the multF of C90);
set D5 = ( id (the carrier of C90) );
thus L184: ( ( C91 * C92 ) * C93 ) = ( ( D4 [;] (C91 , ( D4 [;] (C92 , D5) )) ) * C93 ) by FUNCOP_1:62
.= ( ( ( (the multF of C90) [;] (C91 , ( id (the carrier of C90) )) ) * ( (the multF of C90) [;] (C92 , ( id (the carrier of C90) )) ) ) * C93 ) by FUNCOP_1:55
.= ( C91 * ( C92 * C93 ) ) by RELAT_1:36;
end;
theorem
L185: (for R1 being (Element of ( NAT )) holds (for R31 being  distributive non  empty doubleLoopStr holds (for R33 being (Element of R31) holds (for R34 being (Element of R31) holds (for R35 being (Element of ( R1 -tuples_on (the carrier of R31) )) holds ( ( R33 + R34 ) * R35 ) = ( ( R33 * R35 ) + ( R34 * R35 ) ))))))
proof
let R1 being (Element of ( NAT ));
let R31 being  distributive non  empty doubleLoopStr;
let R33 being (Element of R31);
let R34 being (Element of R31);
let R35 being (Element of ( R1 -tuples_on (the carrier of R31) ));
thus L186: ( ( R33 + R34 ) * R35 ) = ( ( (the addF of R31) .: (( (the multF of R31) [;] (R33 , ( id (the carrier of R31) )) ) , ( (the multF of R31) [;] (R34 , ( id (the carrier of R31) )) )) ) * R35 ) by L35 , FINSEQOP:35
.= ( ( R33 * R35 ) + ( R34 * R35 ) ) by FUNCOP_1:25;
end;
theorem
L187: (for R1 being (Element of ( NAT )) holds (for R31 being  distributive non  empty doubleLoopStr holds (for R32 being (Element of R31) holds (for R36 being (Element of ( R1 -tuples_on (the carrier of R31) )) holds (for R37 being (Element of ( R1 -tuples_on (the carrier of R31) )) holds ( R32 * ( R36 + R37 ) ) = ( ( R32 * R36 ) + ( R32 * R37 ) )))))) by L46 , FINSEQOP:51;
theorem
L188: (for R1 being (Element of ( NAT )) holds (for B70 being  distributive  commutative  left_unital non  empty doubleLoopStr holds (for B71 being (Element of ( R1 -tuples_on (the carrier of B70) )) holds ( ( 1. B70 ) * B71 ) = B71)))
proof
let R1 being (Element of ( NAT ));
let C94 being  distributive  commutative  left_unital non  empty doubleLoopStr;
let C95 being (Element of ( R1 -tuples_on (the carrier of C94) ));
L189: ( rng C95 ) c= (the carrier of C94) by FINSEQ_1:def 4;
L190: ( the_unity_wrt (the multF of C94) ) = ( 1. C94 ) by L21;
thus L191: ( ( 1. C94 ) * C95 ) = ( ( id (the carrier of C94) ) * C95 ) by L190 , FINSEQOP:44
.= C95 by L189 , RELAT_1:53;
end;
theorem
L192: (for R1 being (Element of ( NAT )) holds (for B72 being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr holds (for B73 being (Element of ( R1 -tuples_on (the carrier of B72) )) holds ( ( 0. B72 ) * B73 ) = ( R1 |-> ( 0. B72 ) ))))
proof
let R1 being (Element of ( NAT ));
let C96 being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr;
let C97 being (Element of ( R1 -tuples_on (the carrier of C96) ));
L193: ( rng C97 ) c= (the carrier of C96) by FINSEQ_1:def 4;
L194: (the addF of C96) is  having_an_inverseOp by L52;
L195: (( the_unity_wrt (the addF of C96) ) = ( 0. C96 ) & (the addF of C96) is  having_a_unity) by L29 , L32;
thus L196: ( ( 0. C96 ) * C97 ) = ( (the multF of C96) [;] (( 0. C96 ) , ( ( id (the carrier of C96) ) * C97 )) ) by FUNCOP_1:34
.= ( (the multF of C96) [;] (( 0. C96 ) , C97) ) by L193 , RELAT_1:53
.= ( R1 |-> ( 0. C96 ) ) by L195 , L194 , L35 , FINSEQOP:76;
end;
theorem
L197: (for R1 being (Element of ( NAT )) holds (for B74 being  add-associative  right_zeroed  right_complementable  commutative  left_unital  distributive non  empty doubleLoopStr holds (for B75 being (Element of ( R1 -tuples_on (the carrier of B74) )) holds ( ( - ( 1. B74 ) ) * B75 ) = ( - B75 ))))
proof
let R1 being (Element of ( NAT ));
let C98 being  add-associative  right_zeroed  right_complementable  commutative  left_unital  distributive non  empty doubleLoopStr;
let C99 being (Element of ( R1 -tuples_on (the carrier of C98) ));
L198: (( ( comp C98 ) . ( 1. C98 ) ) = ( - ( 1. C98 ) ) & ( the_unity_wrt (the multF of C98) ) = ( 1. C98 )) by L21 , VECTSP_1:def 13;
L199: ((the addF of C98) is  having_an_inverseOp & ( the_inverseOp_wrt (the addF of C98) ) = ( comp C98 )) by L52 , L55;
L200: ((the multF of C98) is  having_a_unity & (the addF of C98) is  having_a_unity) by L32;
thus L201: thesis by L200 , L198 , L199 , L35 , FINSEQOP:68;
end;
definition
let C100 being non  empty multMagma;
let C101 , C102 being (FinSequence of (the carrier of C100));
func mlt (C101 , C102) -> (FinSequence of (the carrier of C100)) equals 
( (the multF of C100) .: (C101 , C102) );
correctness;
end;
theorem
L203: (for R1 being (Element of ( NAT )) holds (for R38 being non  empty multMagma holds (for R39 being (Element of R38) holds (for R40 being (Element of R38) holds (for R43 being (FinSequence of (the carrier of R38)) holds (for R44 being (FinSequence of (the carrier of R38)) holds ((R1 in ( dom ( mlt (R43 , R44) ) ) & R39 = ( R43 . R1 ) & R40 = ( R44 . R1 )) implies ( ( mlt (R43 , R44) ) . R1 ) = ( R39 * R40 )))))))) by FUNCOP_1:22;
definition
let R1 being (Element of ( NAT ));
let C103 being non  empty multMagma;
let C104 , C105 being (Element of ( R1 -tuples_on (the carrier of C103) ));
redefine func mlt (C104 , C105) -> (Element of ( R1 -tuples_on (the carrier of C103) ));

coherence by FINSEQ_2:120;
end;
theorem
L205: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R38 being non  empty multMagma holds (for R39 being (Element of R38) holds (for R40 being (Element of R38) holds (for R45 being (Element of ( R1 -tuples_on (the carrier of R38) )) holds (for R46 being (Element of ( R1 -tuples_on (the carrier of R38) )) holds ((R2 in ( Seg R1 ) & R39 = ( R45 . R2 ) & R40 = ( R46 . R2 )) implies ( ( mlt (R45 , R46) ) . R2 ) = ( R39 * R40 )))))))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R38 being non  empty multMagma;
let R39 being (Element of R38);
let R40 being (Element of R38);
let R45 being (Element of ( R1 -tuples_on (the carrier of R38) ));
let R46 being (Element of ( R1 -tuples_on (the carrier of R38) ));
assume L206: R2 in ( Seg R1 );
L207: R2 in ( Seg ( len ( mlt (R45 , R46) ) ) ) by L206 , CARD_1:def 7;
L208: R2 in ( dom ( mlt (R45 , R46) ) ) by L207 , FINSEQ_1:def 3;
thus L209: thesis by L208 , FUNCOP_1:22;
end;
theorem
L210: (for R38 being non  empty multMagma holds (for R39 being (Element of R38) holds (for R40 being (Element of R38) holds ( mlt (<* R39 *> , <* R40 *>) ) = <* ( R39 * R40 ) *>))) by FINSEQ_2:74;
L211: (for R38 being non  empty multMagma holds (for R39 being (Element of R38) holds (for R40 being (Element of R38) holds (for R41 being (Element of R38) holds (for R42 being (Element of R38) holds ( mlt (<* R39 , R40 *> , <* R41 , R42 *>) ) = <* ( R39 * R41 ) , ( R40 * R42 ) *>)))))
proof
let R38 being non  empty multMagma;
let R39 being (Element of R38);
let R40 being (Element of R38);
let R41 being (Element of R38);
let R42 being (Element of R38);
L212: (<* R39 , R40 *> = ( <* R39 *> ^ <* R40 *> ) & <* R41 , R42 *> = ( <* R41 *> ^ <* R42 *> )) by FINSEQ_1:def 9;
thus L213: ( mlt (<* R39 , R40 *> , <* R41 , R42 *>) ) = ( ( mlt (<* R39 *> , <* R41 *>) ) ^ <* ( R40 * R42 ) *> ) by L212 , FINSEQOP:10
.= ( <* ( R39 * R41 ) *> ^ <* ( R40 * R42 ) *> ) by FINSEQ_2:74
.= <* ( R39 * R41 ) , ( R40 * R42 ) *> by FINSEQ_1:def 9;
end;
theorem
L214: (for R1 being (Element of ( NAT )) holds (for R47 being  commutative non  empty multMagma holds (for R50 being (Element of ( R1 -tuples_on (the carrier of R47) )) holds (for R51 being (Element of ( R1 -tuples_on (the carrier of R47) )) holds ( mlt (R50 , R51) ) = ( mlt (R51 , R50) ))))) by FINSEQOP:33;
theorem
L215: (for R47 being  commutative non  empty multMagma holds (for R48 being (FinSequence of (the carrier of R47)) holds (for R49 being (FinSequence of (the carrier of R47)) holds ( mlt (R48 , R49) ) = ( mlt (R49 , R48) ))))
proof
let R47 being  commutative non  empty multMagma;
let R48 being (FinSequence of (the carrier of R47));
let R49 being (FinSequence of (the carrier of R47));
reconsider D6 = ( mlt (R48 , R49) ) as (FinSequence of (the carrier of R47));
reconsider D7 = ( mlt (R49 , R48) ) as (FinSequence of (the carrier of R47));
reconsider D8 = ( min (( len R48 ) , ( len R49 )) ) as (Element of ( NAT )) by XXREAL_0:15;
L216: ( len D6 ) = ( min (( len R48 ) , ( len R49 )) ) by FINSEQ_2:71;
L217: ( dom D6 ) = ( Seg D8 ) by L216 , FINSEQ_1:def 3;
L218: ( min (( len R48 ) , ( len R49 )) ) <= ( len R49 ) by XXREAL_0:17;
L219: ( Seg D8 ) c= ( Seg ( len R49 ) ) by L218 , FINSEQ_1:5;
L220: ( Seg D8 ) c= ( dom R49 ) by L219 , FINSEQ_1:def 3;
L221: ( min (( len R48 ) , ( len R49 )) ) <= ( len R48 ) by XXREAL_0:17;
L222: ( Seg D8 ) c= ( Seg ( len R48 ) ) by L221 , FINSEQ_1:5;
L223: ( Seg D8 ) c= ( dom R48 ) by L222 , FINSEQ_1:def 3;
L224: ( len D7 ) = ( min (( len R49 ) , ( len R48 )) ) by FINSEQ_2:71;
L225: ( dom D7 ) = ( Seg D8 ) by L224 , FINSEQ_1:def 3;
L226: ( dom D6 ) = ( Seg D8 ) by L216 , FINSEQ_1:def 3;
L227:
now
let C106 being Nat;
assume L228: C106 in ( dom D6 );
reconsider D9 = ( R48 . C106 ) , D10 = ( R49 . C106 ) as (Element of R47) by L228 , L223 , L220 , L217 , FINSEQ_2:11;
thus L229: ( D6 . C106 ) = ( D9 * D10 ) by L228 , FUNCOP_1:22
.= ( D10 * D9 )
.= ( D7 . C106 ) by L226 , L225 , L228 , FUNCOP_1:22;
end;
thus L230: thesis by L227 , L216 , L224 , FINSEQ_2:9;
end;
theorem
L231: (for R1 being (Element of ( NAT )) holds (for B76 being  associative non  empty multMagma holds (for B77 , B78 , B79 being (Element of ( R1 -tuples_on (the carrier of B76) )) holds ( mlt (B77 , ( mlt (B78 , B79) )) ) = ( mlt (( mlt (B77 , B78) ) , B79) )))) by FINSEQOP:28;
theorem
L232: (for R1 being (Element of ( NAT )) holds (for R52 being  commutative  associative non  empty multMagma holds (for R53 being (Element of R52) holds (for R56 being (Element of ( R1 -tuples_on (the carrier of R52) )) holds (( mlt (( R1 |-> R53 ) , R56) ) = ( R53 * R56 ) & ( mlt (R56 , ( R1 |-> R53 )) ) = ( R53 * R56 ))))))
proof
let R1 being (Element of ( NAT ));
let R52 being  commutative  associative non  empty multMagma;
let R53 being (Element of R52);
let R56 being (Element of ( R1 -tuples_on (the carrier of R52) ));
thus L233: ( mlt (( R1 |-> R53 ) , R56) ) = ( (the multF of R52) [;] (R53 , R56) ) by FINSEQOP:20
.= ( R53 * R56 ) by FINSEQOP:22;
thus L234: thesis by L233 , FINSEQOP:33;
end;
theorem
L235: (for R1 being (Element of ( NAT )) holds (for R52 being  commutative  associative non  empty multMagma holds (for R54 being (Element of R52) holds (for R55 being (Element of R52) holds ( mlt (( R1 |-> R54 ) , ( R1 |-> R55 )) ) = ( R1 |-> ( R54 * R55 ) )))))
proof
let R1 being (Element of ( NAT ));
let R52 being  commutative  associative non  empty multMagma;
let R54 being (Element of R52);
let R55 being (Element of R52);
thus L236: ( mlt (( R1 |-> R54 ) , ( R1 |-> R55 )) ) = ( R54 * ( R1 |-> R55 ) ) by L232
.= ( R1 |-> ( R54 * R55 ) ) by L181;
end;
theorem
L237: (for R1 being (Element of ( NAT )) holds (for B80 being  associative non  empty multMagma holds (for B81 being (Element of B80) holds (for B82 , B83 being (Element of ( R1 -tuples_on (the carrier of B80) )) holds ( B81 * ( mlt (B82 , B83) ) ) = ( mlt (( B81 * B82 ) , B83) ))))) by FINSEQOP:26;
theorem
L238: (for R1 being (Element of ( NAT )) holds (for R57 being  commutative  associative non  empty multMagma holds (for R58 being (Element of R57) holds (for R60 being (Element of ( R1 -tuples_on (the carrier of R57) )) holds (for R61 being (Element of ( R1 -tuples_on (the carrier of R57) )) holds (( R58 * ( mlt (R60 , R61) ) ) = ( mlt (( R58 * R60 ) , R61) ) & ( R58 * ( mlt (R60 , R61) ) ) = ( mlt (R60 , ( R58 * R61 )) )))))))
proof
let R1 being (Element of ( NAT ));
let R57 being  commutative  associative non  empty multMagma;
let R58 being (Element of R57);
let R60 being (Element of ( R1 -tuples_on (the carrier of R57) ));
let R61 being (Element of ( R1 -tuples_on (the carrier of R57) ));
thus L239: ( R58 * ( mlt (R60 , R61) ) ) = ( mlt (( R58 * R60 ) , R61) ) by FINSEQOP:26;
thus L240: ( R58 * ( mlt (R60 , R61) ) ) = ( R58 * ( mlt (R61 , R60) ) ) by FINSEQOP:33
.= ( mlt (( R58 * R61 ) , R60) ) by FINSEQOP:26
.= ( mlt (R60 , ( R58 * R61 )) ) by FINSEQOP:33;
end;
theorem
L241: (for R1 being (Element of ( NAT )) holds (for R57 being  commutative  associative non  empty multMagma holds (for R58 being (Element of R57) holds (for R59 being (Element of ( R1 -tuples_on (the carrier of R57) )) holds ( R58 * R59 ) = ( mlt (( R1 |-> R58 ) , R59) ))))) by L232;
begin
registration
cluster  Abelian  right_zeroed ->  left_zeroed for non  empty non  empty non  empty non  empty addLoopStr;
coherence
proof
let C107 being non  empty addLoopStr;
assume that
L242: C107 is  Abelian
and
L243: C107 is  right_zeroed;
let C108 being (Element of C107);
thus L244: ( ( 0. C107 ) + C108 ) = ( C108 + ( 0. C107 ) ) by L242 , RLVECT_1:def 2
.= C108 by L243 , RLVECT_1:def 4;
end;
end;
definition
let C109 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C110 being (FinSequence of (the carrier of C109));
redefine func Sum C110 equals 
( (the addF of C109) $$ C110 );
compatibility
proof
set D11 = ( <*> (the carrier of C109) );
deffunc H1((Element of ( NAT ))) = ( (the addF of C109) $$ ( C110 | $1 ) );
let C111 being (Element of C109);
consider C112 being (Function of ( NAT ) , (the carrier of C109)) such that L246: (for R1 being (Element of ( NAT )) holds ( C112 . R1 ) = H1(R1)) from FUNCT_2:sch 4;
thus L247:now
defpred S1[ set , set ] means (ex B84 being (FinSequence of (the carrier of C109)) st (B84 = ( C110 * ( Sgm ( dom ( C110 | $1 ) ) ) ) & $2 = ( Sum B84 )));
assume L248: C111 = ( Sum C110 );
L249: (for B85 being (Element of ( Fin ( NAT ) )) holds (ex B86 being (Element of C109) st S1[ B85 , B86 ]))
proof
let C113 being (Element of ( Fin ( NAT ) ));
per cases ;
suppose L250: ( dom C110 ) = ( {} );

reconsider D12 = ( Sum ( <*> (the carrier of C109) ) ) as (Element of C109);
reconsider D13 = ( <*> (the carrier of C109) ) as (FinSequence of (the carrier of C109));
take D12;
take D13;
L251: C110 = ( {} ) by L250;
thus L252: D13 = ( C110 * ( Sgm ( dom ( C110 | C113 ) ) ) ) by L251;
thus L253: thesis;
end;
suppose L254: ( dom C110 ) <> ( {} );

reconsider D14 = ( dom C110 ) as non  empty set by L254;
reconsider D15 = C110 as (Function of D14 , (the carrier of C109)) by FINSEQ_2:26;
L255: ( dom ( C110 | C113 ) ) c= ( dom C110 ) by RELAT_1:60;
reconsider D16 = ( C110 | C113 ) as FinSubsequence;
L256: ( rng ( Sgm ( dom D16 ) ) ) = ( dom D16 ) by FINSEQ_1:50;
reconsider D17 = ( Sgm ( dom ( C110 | C113 ) ) ) as (FinSequence of D14) by L256 , L255 , FINSEQ_1:def 4;
reconsider D18 = ( D15 * D17 ) as (FinSequence of (the carrier of C109));
reconsider D19 = ( Sum D18 ) as (Element of C109);
take D19;
take D18;
thus L257: thesis;
end;
end;
consider C114 being (Function of ( Fin ( NAT ) ) , (the carrier of C109)) such that L259: (for B87 being (Element of ( Fin ( NAT ) )) holds S1[ B87 , ( C114 . B87 ) ]) from FUNCT_2:sch 3(L249);
L260:
now
let C115 being (Element of ( Fin ( NAT ) ));
assume that
L261: C115 c= ( dom C110 )
and
L262: C115 <> ( {} );
let C116 being (Element of ( NAT ));
set D20 = ( Sgm ( dom ( C110 | ( C115 \/ { C116 } ) ) ) );
set D21 = ( D20 -| C116 );
set D22 = ( D20 |-- C116 );
reconsider D23 = ( ( finSeg ( len D20 ) ) \ ( D20 " { C116 } ) ) as  finite set;
L263: ( Seg ( len D20 ) ) = ( dom D20 ) by FINSEQ_1:def 3;
set D24 = ( rng ( D20 | D23 ) );
set D25 = ( D20 * ( Sgm D23 ) );
L264: ( rng ( Sgm D23 ) ) = D23 by FINSEQ_1:def 13;
L265: ( dom ( Sgm D23 ) ) = ( finSeg ( card D23 ) ) by FINSEQ_3:40;
L266: ( dom D25 ) = ( Seg ( card D23 ) ) by L265 , L263 , L264 , RELAT_1:27;
reconsider D26 = D25 as FinSequence by L266 , FINSEQ_1:def 2;
L267: (( rng D20 ) c= ( NAT ) & ( rng D26 ) c= ( rng D20 )) by FINSEQ_1:def 4 , RELAT_1:26;
L268: ( rng D26 ) c= ( NAT ) by L267 , XBOOLE_1:1;
reconsider D27 = ( D20 * ( Sgm D23 ) ) as (FinSequence of ( NAT )) by L268 , FINSEQ_1:def 4;
L269:
now
let C117 being set;
thus L270:now
assume L271: C117 in ( rng D27 );
consider C118 being set such that L272: C118 in ( dom D27 ) and L273: C117 = ( D27 . C118 ) by L271 , FUNCT_1:def 3;
L274: C118 in ( dom ( Sgm D23 ) ) by L272 , FUNCT_1:11;
L275: ( ( Sgm D23 ) . C118 ) in D23 by L274 , L264 , FUNCT_1:def 3;
L276: C117 = ( D20 . ( ( Sgm D23 ) . C118 ) ) by L272 , L273 , FUNCT_1:12;
thus L277: C117 in D24 by L276 , L263 , L275 , FUNCT_1:50;
end;
assume L278: C117 in D24;
consider C119 being set such that L279: C119 in ( dom ( D20 | D23 ) ) and L280: C117 = ( ( D20 | D23 ) . C119 ) by L278 , FUNCT_1:def 3;
L281: C119 in ( ( dom D20 ) /\ D23 ) by L279 , RELAT_1:61;
L282: C119 in D23 by L281 , XBOOLE_0:def 4;
consider C120 being set such that L283: C120 in ( dom ( Sgm D23 ) ) and L284: C119 = ( ( Sgm D23 ) . C120 ) by L282 , L264 , FUNCT_1:def 3;
L285: C119 in ( dom D20 ) by L281 , XBOOLE_0:def 4;
L286: C120 in ( dom ( D20 * ( Sgm D23 ) ) ) by L285 , L283 , L284 , FUNCT_1:11;
L287: ( D27 . C120 ) = ( D20 . ( ( Sgm D23 ) . C120 ) ) by L286 , FUNCT_1:12
.= C117 by L280 , L282 , L284 , FUNCT_1:49;
thus L288: C117 in ( rng D27 ) by L287 , L286 , FUNCT_1:def 3;
end;
L289: ( rng D27 ) = D24 by L269 , TARSKI:1;
L290: C116 in { C116 } by TARSKI:def 1;
L291: C116 in ( C115 \/ { C116 } ) by L290 , XBOOLE_0:def 3;
L292: ( dom ( C110 | ( C115 \/ { C116 } ) ) ) = ( ( dom C110 ) /\ ( C115 \/ { C116 } ) ) by RELAT_1:61;
L293: ( dom ( C110 | ( C115 \/ { C116 } ) ) ) c= ( dom C110 ) by L292 , XBOOLE_1:17;
L294: ( dom ( C110 | ( C115 \/ { C116 } ) ) ) c= ( Seg ( len C110 ) ) by L293 , FINSEQ_1:def 3;
reconsider D28 = ( C110 | ( C115 \/ { C116 } ) ) as FinSubsequence;
L295: ( rng D20 ) c= ( Seg ( len C110 ) ) by L294 , FINSEQ_1:def 13;
L296: ( rng D20 ) c= ( dom C110 ) by L295 , FINSEQ_1:def 3;
L297: D24 c= ( rng D20 ) by RELAT_1:70;
L298: D24 c= ( dom C110 ) by L297 , L296 , XBOOLE_1:1;
L299: D24 c= ( Seg ( len C110 ) ) by L298 , FINSEQ_1:def 3;
reconsider D29 = ( C110 | ( C115 \/ { C116 } ) ) as FinSubsequence;
L300: ( dom ( C110 | C115 ) ) = ( ( dom C110 ) /\ C115 ) by RELAT_1:61;
L301:
now
let C121 , C122 , C123 , C124 being Nat;
assume that
L302: 1 <= C121
and
L303: C121 < C122
and
L304: C122 <= ( len D27 )
and
L305: (C123 = ( D27 . C121 ) & C124 = ( D27 . C122 ));
L306: C121 <= ( len D27 ) by L303 , L304 , XXREAL_0:2;
L307: C121 in ( dom D27 ) by L306 , L302 , FINSEQ_3:25;
L308: ( D27 . C121 ) = ( D20 . ( ( Sgm D23 ) . C121 ) ) by L307 , FUNCT_1:12;
L309: ( ( Sgm D23 ) . C121 ) in ( dom D20 ) by L307 , FUNCT_1:11;
L310: 1 <= C122 by L302 , L303 , XXREAL_0:2;
L311: C122 in ( dom D27 ) by L310 , L304 , FINSEQ_3:25;
L312: ( D27 . C122 ) = ( D20 . ( ( Sgm D23 ) . C122 ) ) by L311 , FUNCT_1:12;
L313: C122 in ( dom ( Sgm D23 ) ) by L311 , FUNCT_1:11;
L314: C122 <= ( len ( Sgm D23 ) ) by L313 , FINSEQ_3:25;
L315: ( ( Sgm D23 ) . C122 ) in ( dom D20 ) by L311 , FUNCT_1:11;
reconsider D30 = C121 , D31 = C122 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D32 = ( ( Sgm D23 ) . D30 ) , D33 = ( ( Sgm D23 ) . D31 ) as (Element of ( NAT )) by L309 , L315;
L316: 1 <= D32 by L309 , FINSEQ_3:25;
L317: D33 <= ( len D20 ) by L315 , FINSEQ_3:25;
L318: D32 < D33 by L302 , L303 , L314 , FINSEQ_1:def 13;
thus L319: C123 < C124 by L318 , L294 , L305 , L308 , L312 , L316 , L317 , FINSEQ_1:def 13;
end;
assume L320: C116 in ( ( dom C110 ) \ C115 );
L321: C116 in ( dom C110 ) by L320 , XBOOLE_0:def 5;
reconsider D34 = ( dom C110 ) , D35 = ( rng C110 ) as non  empty set by L321 , RELAT_1:42;
L322: C116 in ( dom C110 ) by L320 , XBOOLE_0:def 5;
L323: { C116 } c= ( dom C110 ) by L322 , ZFMISC_1:31;
L324: ( C110 . C116 ) = ( C110 /. C116 ) by L321 , PARTFUN1:def 6;
reconsider D36 = ( C110 . C116 ) as (Element of C109) by L324;
L325: ( dom <* D36 *> ) = ( Seg 1 ) by FINSEQ_1:38;
L326: ( rng <* C116 *> ) = { C116 } by FINSEQ_1:38;
L327: (( dom <* C116 *> ) = ( Seg 1 ) & ( rng <* C116 *> ) c= ( dom C110 )) by L326 , L321 , FINSEQ_1:38 , ZFMISC_1:31;
L328: ( dom ( C110 * <* C116 *> ) ) = ( dom <* D36 *> ) by L327 , L325 , RELAT_1:27;
L329:
now
let C125 being set;
assume L330: C125 in ( dom <* D36 *> );
L331: C125 = 1 by L330 , L325 , FINSEQ_1:2 , TARSKI:def 1;
thus L332: ( ( C110 * <* C116 *> ) . C125 ) = ( C110 . ( <* C116 *> . C125 ) ) by L328 , L330 , FUNCT_1:12
.= ( C110 . C116 ) by L331 , FINSEQ_1:40
.= ( <* D36 *> . C125 ) by L331 , FINSEQ_1:40;
end;
reconsider D37 = C116 as (Element of D34) by L320 , XBOOLE_0:def 5;
reconsider D38 = C110 as (Function of D34 , D35) by FUNCT_2:1;
L333: D35 c= (the carrier of C109) by FINSEQ_1:def 4;
L334: (not C116 in C115) by L320 , XBOOLE_0:def 5;
L335: (not C116 in ( dom ( C110 | C115 ) )) by L334 , L300 , XBOOLE_0:def 4;
L336: ( rng ( Sgm ( dom D29 ) ) ) = ( dom D29 ) by FINSEQ_1:50;
L337: ( rng D20 ) c= ( dom C110 ) by L336 , RELAT_1:60;
L338: ( dom D29 ) = ( ( dom C110 ) /\ ( C115 \/ { C116 } ) ) by RELAT_1:61;
L339: C116 in ( rng D20 ) by L338 , L336 , L321 , L291 , XBOOLE_0:def 4;
L340: ( rng D22 ) c= ( rng D20 ) by L339 , FINSEQ_4:44;
L341: ( rng D22 ) c= D34 by L340 , L337 , XBOOLE_1:1;
L342: ( rng D21 ) c= ( rng D20 ) by L339 , FINSEQ_4:39;
L343: ( rng D21 ) c= D34 by L342 , L337 , XBOOLE_1:1;
reconsider D39 = D21 , D40 = D22 as (FinSequence of D34) by L343 , L341 , FINSEQ_1:def 4;
consider C126 being (FinSequence of (the carrier of C109)) such that L344: C126 = ( C110 * ( Sgm ( dom ( C110 | ( C115 \/ { C116 } ) ) ) ) ) and L345: ( C114 . ( C115 \/ {. C116 .} ) ) = ( Sum C126 ) by L259;
reconsider D41 = ( D38 * D39 ) , D42 = ( D38 * D40 ) as (FinSequence of D35);
L346: ( rng D41 ) c= D35 by FINSEQ_1:def 4;
L347: ( rng D41 ) c= (the carrier of C109) by L346 , L333 , XBOOLE_1:1;
L348: ( rng D42 ) c= D35 by FINSEQ_1:def 4;
L349: ( rng D42 ) c= (the carrier of C109) by L348 , L333 , XBOOLE_1:1;
reconsider D43 = D41 , D44 = D42 as (FinSequence of (the carrier of C109)) by L349 , L347 , FINSEQ_1:def 4;
consider C127 being (FinSequence of (the carrier of C109)) such that L350: C127 = ( C110 * ( Sgm ( dom ( C110 | C115 ) ) ) ) and L351: ( C114 . C115 ) = ( Sum C127 ) by L259;
L352: D20 is  one-to-one by L294 , FINSEQ_3:92;
L353: ( rng ( ( Sgm ( dom ( C110 | ( C115 \/ { C116 } ) ) ) ) | ( ( Seg ( len D20 ) ) \ ( D20 " { C116 } ) ) ) ) = ( ( Sgm ( dom ( C110 | ( C115 \/ { C116 } ) ) ) ) .: ( ( Seg ( len D20 ) ) \ ( D20 " { C116 } ) ) ) by RELAT_1:115
.= ( ( Sgm ( dom ( C110 | ( C115 \/ { C116 } ) ) ) ) .: ( ( dom D20 ) \ ( D20 " { C116 } ) ) ) by FINSEQ_1:def 3
.= ( ( ( Sgm ( dom ( C110 | ( C115 \/ { C116 } ) ) ) ) .: ( dom D20 ) ) \ { C116 } ) by SETWISEO:6
.= ( ( rng ( Sgm ( dom D28 ) ) ) \ { C116 } ) by RELAT_1:113
.= ( ( dom ( C110 | ( C115 \/ { C116 } ) ) ) \ { C116 } ) by FINSEQ_1:50
.= ( ( ( dom C110 ) /\ ( C115 \/ { C116 } ) ) \ { C116 } ) by RELAT_1:61
.= ( ( ( ( dom C110 ) /\ C115 ) \/ ( ( dom C110 ) /\ { C116 } ) ) \ { C116 } ) by XBOOLE_1:23
.= ( ( ( ( dom C110 ) /\ C115 ) \/ { C116 } ) \ { C116 } ) by L323 , XBOOLE_1:28
.= ( ( dom ( C110 | C115 ) ) \ { C116 } ) by L300 , XBOOLE_1:40
.= ( dom ( C110 | C115 ) ) by L335 , ZFMISC_1:57;
L354: ( Sgm ( dom ( C110 | C115 ) ) ) = ( D20 * ( Sgm ( ( Seg ( len D20 ) ) \ ( D20 " { C116 } ) ) ) ) by L353 , L299 , L289 , L301 , FINSEQ_1:def 13
.= ( D20 * ( Sgm ( ( dom D20 ) \ ( D20 " { C116 } ) ) ) ) by FINSEQ_1:def 3
.= ( D20 - { C116 } ) by FINSEQ_3:def 1
.= ( D21 ^ D22 ) by L339 , L352 , FINSEQ_4:55;
L355: C127 = ( D43 ^ D44 ) by L354 , L350 , FINSEQOP:9;
L356: C126 = ( D38 * ( ( D39 ^ <* D37 *> ) ^ D40 ) ) by L344 , L339 , FINSEQ_4:51
.= ( ( D38 * ( D39 ^ <* D37 *> ) ) ^ ( D38 * D40 ) ) by FINSEQOP:9
.= ( ( ( D38 * D39 ) ^ ( D38 * <* D37 *> ) ) ^ ( D38 * D40 ) ) by FINSEQOP:9
.= ( ( D43 ^ <* D36 *> ) ^ D44 ) by L328 , L329 , FUNCT_1:2;
thus L357: ( C114 . ( C115 \/ { C116 } ) ) = ( ( Sum ( D43 ^ <* D36 *> ) ) + ( Sum D44 ) ) by L356 , L345 , RLVECT_1:41
.= ( ( ( Sum D43 ) + ( Sum <* D36 *> ) ) + ( Sum D44 ) ) by RLVECT_1:41
.= ( ( ( Sum D43 ) + ( Sum D44 ) ) + ( Sum <* D36 *> ) ) by RLVECT_1:def 3
.= ( ( Sum C127 ) + ( Sum <* D36 *> ) ) by L355 , RLVECT_1:41
.= ( (the addF of C109) . (( Sum C127 ) , D36) ) by RLVECT_1:44
.= ( (the addF of C109) . (( C114 . C115 ) , ( ( [#] (C110 , ( the_unity_wrt (the addF of C109) )) ) . C116 )) ) by L351 , L321 , SETWOP_2:20;
end;
L358:
now
let C128 being (Element of ( NAT ));
consider C129 being (FinSequence of (the carrier of C109)) such that L359: C129 = ( C110 * ( Sgm ( dom ( C110 | { C128 } ) ) ) ) and L360: ( C114 . {. C128 .} ) = ( Sum C129 ) by L259;
L361: ( {} ) c= ( Seg ( 0 ) );
per cases ;
suppose L362: (not C128 in ( dom C110 ));

L363: ( dom C110 ) misses { C128 } by L362 , ZFMISC_1:50;
L364: ( ( dom C110 ) /\ { C128 } ) = ( {} ) by L363 , XBOOLE_0:def 7;
L365: C129 = ( C110 * ( Sgm ( {} ) ) ) by L364 , L359 , RELAT_1:61
.= ( C110 * ( {} ) ) by L361 , FINSEQ_1:51
.= ( <*> (the carrier of C109) );
thus L366: ( C114 . { C128 } ) = ( 0. C109 ) by L365 , L360 , RLVECT_1:43
.= ( the_unity_wrt (the addF of C109) ) by L29
.= ( ( [#] (C110 , ( the_unity_wrt (the addF of C109) )) ) . C128 ) by L362 , SETWOP_2:20;
end;
suppose L367: C128 in ( dom C110 );

L368: ( C110 . C128 ) = ( C110 /. C128 ) by L367 , PARTFUN1:def 6;
reconsider D45 = ( C110 . C128 ) as (Element of C109) by L368;
L369: ( dom <* D45 *> ) = ( Seg 1 ) by FINSEQ_1:38;
L370: ( rng <* C128 *> ) = { C128 } by FINSEQ_1:38;
L371: (( dom <* C128 *> ) = ( Seg 1 ) & ( rng <* C128 *> ) c= ( dom C110 )) by L370 , L367 , FINSEQ_1:38 , ZFMISC_1:31;
L372: ( dom ( C110 * <* C128 *> ) ) = ( dom <* D45 *> ) by L371 , L369 , RELAT_1:27;
L373:
now
let C130 being set;
assume L374: C130 in ( dom <* D45 *> );
L375: C130 = 1 by L374 , L369 , FINSEQ_1:2 , TARSKI:def 1;
thus L376: ( ( C110 * <* C128 *> ) . C130 ) = ( C110 . ( <* C128 *> . C130 ) ) by L372 , L374 , FUNCT_1:12
.= ( C110 . C128 ) by L375 , FINSEQ_1:40
.= ( <* D45 *> . C130 ) by L375 , FINSEQ_1:40;
end;
L377: C128 <> ( 0 ) by L367 , FINSEQ_3:25;
L378: C129 = ( C110 * ( Sgm ( ( dom C110 ) /\ { C128 } ) ) ) by L359 , RELAT_1:61
.= ( C110 * ( Sgm { C128 } ) ) by L367 , ZFMISC_1:46
.= ( C110 * <* C128 *> ) by L377 , FINSEQ_3:44
.= <* D45 *> by L372 , L373 , FUNCT_1:2;
thus L379: ( C114 . { C128 } ) = D45 by L378 , L360 , RLVECT_1:44
.= ( ( [#] (C110 , ( the_unity_wrt (the addF of C109) )) ) . C128 ) by L367 , SETWOP_2:20;
end;
end;
L381:
now
let C131 being (Element of C109);
assume L382: C131 is_a_unity_wrt (the addF of C109);
L383: ( 0. C109 ) is_a_unity_wrt (the addF of C109) by L24;
L384: C131 = ( 0. C109 ) by L383 , L382 , BINOP_1:10;
L385: ( {} ) c= ( Seg ( 0 ) );
consider C132 being (FinSequence of (the carrier of C109)) such that L386: C132 = ( C110 * ( Sgm ( dom ( C110 | (( {}. ( NAT ) ) qua set) ) ) ) ) and L387: ( C114 . ( {}. ( NAT ) ) ) = ( Sum C132 ) by L259;
L388: C132 = ( C110 * ( Sgm ( dom ( {} ) ) ) ) by L386
.= ( C110 * ( {} ) ) by L385 , FINSEQ_1:51
.= ( <*> (the carrier of C109) );
thus L389: C131 = ( C114 . ( {} ) ) by L388 , L387 , L384 , RLVECT_1:43;
end;
consider C133 being (FinSequence of (the carrier of C109)) such that L390: C133 = ( C110 * ( Sgm ( dom ( C110 | ( dom C110 ) ) ) ) ) and L391: ( C114 . ( findom C110 ) ) = ( Sum C133 ) by L259;
L392: (the addF of C109) is  having_a_unity by L32;
L393: C133 = ( C110 * ( Sgm ( dom C110 ) ) ) by L390
.= ( C110 * ( Sgm ( Seg ( len C110 ) ) ) ) by FINSEQ_1:def 3
.= ( C110 * ( idseq ( len C110 ) ) ) by FINSEQ_3:48
.= C110 by FINSEQ_2:54;
thus L394: C111 = ( (the addF of C109) $$ (( findom C110 ) , ( [#] (C110 , ( the_unity_wrt (the addF of C109) )) )) ) by L393 , L248 , L392 , L391 , L381 , L358 , L260 , SETWISEO:def 3
.= ( (the addF of C109) $$ C110 ) by L32 , SETWOP_2:def 2;
end;
L395: ( C110 | ( len C110 ) ) = ( C110 | ( Seg ( len C110 ) ) ) by FINSEQ_1:def 15
.= ( C110 | ( dom C110 ) ) by FINSEQ_1:def 3
.= C110;
L396:
now
let R2 being (Element of ( NAT ));
let C134 being (Element of C109);
assume that
L397: R2 < ( len C110 )
and
L398: C134 = ( C110 . ( R2 + 1 ) );
L399: ( R2 + 1 ) <= ( len C110 ) by L397 , NAT_1:13;
L400: ( len ( C110 | ( R2 + 1 ) ) ) = ( R2 + 1 ) by L399 , FINSEQ_1:59;
L401: R2 <= ( R2 + 1 ) by NAT_1:11;
L402: ( Seg R2 ) c= ( Seg ( R2 + 1 ) ) by L401 , FINSEQ_1:5;
L403: ( C110 | R2 ) = ( C110 | ( Seg R2 ) ) by FINSEQ_1:def 15
.= ( ( C110 | ( Seg ( R2 + 1 ) ) ) | ( Seg R2 ) ) by L402 , RELAT_1:74
.= ( ( C110 | ( R2 + 1 ) ) | ( Seg R2 ) ) by FINSEQ_1:def 15;
L404: 1 <= ( R2 + 1 ) by NAT_1:11;
L405: ( R2 + 1 ) in ( dom ( C110 | ( R2 + 1 ) ) ) by L404 , L400 , FINSEQ_3:25;
L406: ( R2 + 1 ) in ( dom C110 ) by L399 , L404 , FINSEQ_3:25;
L407: C134 = ( C110 /. ( R2 + 1 ) ) by L406 , L398 , PARTFUN1:def 6
.= ( ( C110 | ( R2 + 1 ) ) /. ( R2 + 1 ) ) by L405 , FINSEQ_4:70
.= ( ( C110 | ( R2 + 1 ) ) . ( R2 + 1 ) ) by L405 , PARTFUN1:def 6;
L408: ( C110 | ( R2 + 1 ) ) = ( ( C110 | R2 ) ^ <* C134 *> ) by L407 , L400 , L403 , FINSEQ_3:55;
thus L409: ( C112 . ( R2 + 1 ) ) = ( (the addF of C109) $$ ( ( C110 | R2 ) ^ <* C134 *> ) ) by L408 , L246
.= ( (the addF of C109) . (( (the addF of C109) $$ ( C110 | R2 ) ) , C134) ) by L32 , FINSOP_1:4
.= ( ( C112 . R2 ) + C134 ) by L246;
end;
L410: ( C110 | ( 0 ) ) = D11;
L411: ( C112 . ( 0 ) ) = ( (the addF of C109) $$ D11 ) by L410 , L246
.= ( the_unity_wrt (the addF of C109) ) by L32 , FINSOP_1:10
.= ( 0. C109 ) by L29;
assume L412: C111 = ( (the addF of C109) $$ C110 );
L413: C111 = ( C112 . ( len C110 ) ) by L412 , L246 , L395;
thus L414: thesis by L413 , L411 , L396 , RLVECT_1:def 12;
end;
end;
theorem
L416: (for R62 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R63 being (Element of R62) holds (for R64 being (FinSequence of (the carrier of R62)) holds ( Sum ( R64 ^ <* R63 *> ) ) = ( ( Sum R64 ) + R63 ))))
proof
let R62 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R63 being (Element of R62);
let R64 being (FinSequence of (the carrier of R62));
thus L417: ( Sum ( R64 ^ <* R63 *> ) ) = ( ( Sum R64 ) + ( Sum <* R63 *> ) ) by RLVECT_1:41
.= ( ( Sum R64 ) + R63 ) by RLVECT_1:44;
end;
theorem
L418: (for R62 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R63 being (Element of R62) holds (for R64 being (FinSequence of (the carrier of R62)) holds ( Sum ( <* R63 *> ^ R64 ) ) = ( R63 + ( Sum R64 ) ))))
proof
let R62 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R63 being (Element of R62);
let R64 being (FinSequence of (the carrier of R62));
thus L419: ( Sum ( <* R63 *> ^ R64 ) ) = ( ( Sum <* R63 *> ) + ( Sum R64 ) ) by RLVECT_1:41
.= ( R63 + ( Sum R64 ) ) by RLVECT_1:44;
end;
theorem
L420: (for B88 being  Abelian  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr holds (for B89 being (Element of B88) holds (for B90 being (FinSequence of (the carrier of B88)) holds ( Sum ( B89 * B90 ) ) = ( B89 * ( Sum B90 ) ))))
proof
let C135 being  Abelian  add-associative  right_zeroed  distributive  right_complementable non  empty doubleLoopStr;
let C136 being (Element of C135);
let C137 being (FinSequence of (the carrier of C135));
set D46 = ( (the multF of C135) [;] (C136 , ( id (the carrier of C135) )) );
L421: ((the addF of C135) is  having_a_unity & (the multF of C135) is_distributive_wrt (the addF of C135)) by L32 , L35;
thus L422: ( Sum ( C136 * C137 ) ) = ( D46 . ( Sum C137 ) ) by L421 , L52 , SETWOP_2:30
.= ( C136 * ( Sum C137 ) ) by L44;
end;
theorem
L423: (for B91 being non  empty addLoopStr holds (for B92 being (Element of ( ( 0 ) -tuples_on (the carrier of B91) )) holds ( Sum B92 ) = ( 0. B91 )))
proof
let C138 being non  empty addLoopStr;
let C139 being (Element of ( ( 0 ) -tuples_on (the carrier of C138) ));
L424: C139 = ( <*> (the carrier of C138) );
thus L425: thesis by L424 , RLVECT_1:43;
end;
theorem
L426: (for R65 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R66 being (FinSequence of (the carrier of R65)) holds ( Sum ( - R66 ) ) = ( - ( Sum R66 ) )))
proof
let R65 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R66 being (FinSequence of (the carrier of R65));
L427: ((the addF of R65) is  having_an_inverseOp & ( the_inverseOp_wrt (the addF of R65) ) = ( comp R65 )) by L52 , L55;
thus L428: ( Sum ( - R66 ) ) = ( ( comp R65 ) . ( Sum R66 ) ) by L427 , L32 , SETWOP_2:31
.= ( - ( Sum R66 ) ) by VECTSP_1:def 13;
end;
theorem
L429: (for R1 being (Element of ( NAT )) holds (for R65 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R67 being (Element of ( R1 -tuples_on (the carrier of R65) )) holds (for R68 being (Element of ( R1 -tuples_on (the carrier of R65) )) holds ( Sum ( R67 + R68 ) ) = ( ( Sum R67 ) + ( Sum R68 ) ))))) by L32 , SETWOP_2:35;
theorem
L430: (for R1 being (Element of ( NAT )) holds (for R65 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R67 being (Element of ( R1 -tuples_on (the carrier of R65) )) holds (for R68 being (Element of ( R1 -tuples_on (the carrier of R65) )) holds ( Sum ( R67 - R68 ) ) = ( ( Sum R67 ) - ( Sum R68 ) )))))
proof
let R1 being (Element of ( NAT ));
let R65 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R67 being (Element of ( R1 -tuples_on (the carrier of R65) ));
let R68 being (Element of ( R1 -tuples_on (the carrier of R65) ));
L431: ((the addF of R65) is  having_an_inverseOp & ( the_inverseOp_wrt (the addF of R65) ) = ( comp R65 )) by L52 , L55;
thus L432: ( Sum ( R67 - R68 ) ) = ( ( diffield R65 ) . (( Sum R67 ) , ( (the addF of R65) $$ R68 )) ) by L431 , L32 , SETWOP_2:37
.= ( ( Sum R67 ) - ( Sum R68 ) ) by L42;
end;
begin
L433: (for B93 being  commutative  well-unital non  empty multLoopStr holds ( Product ( <*> (the carrier of B93) ) ) = ( 1. B93 ))
proof
let C140 being  commutative  well-unital non  empty multLoopStr;
L434: ( 1. C140 ) = ( 1_ C140 );
thus L435: thesis by L434 , GROUP_4:8;
end;
theorem
L436: (for R69 being  commutative  associative  well-unital non  empty doubleLoopStr holds (for R70 being (Element of R69) holds (for R74 being (FinSequence of (the carrier of R69)) holds ( Product ( <* R70 *> ^ R74 ) ) = ( R70 * ( Product R74 ) ))))
proof
let R69 being  commutative  associative  well-unital non  empty doubleLoopStr;
let R70 being (Element of R69);
let R74 being (FinSequence of (the carrier of R69));
thus L437: ( Product ( <* R70 *> ^ R74 ) ) = ( ( Product <* R70 *> ) * ( Product R74 ) ) by GROUP_4:5
.= ( R70 * ( Product R74 ) ) by FINSOP_1:11;
end;
theorem
L438: (for R69 being  commutative  associative  well-unital non  empty doubleLoopStr holds (for R71 being (Element of R69) holds (for R72 being (Element of R69) holds (for R73 being (Element of R69) holds ( Product <* R71 , R72 , R73 *> ) = ( ( R71 * R72 ) * R73 )))))
proof
let R69 being  commutative  associative  well-unital non  empty doubleLoopStr;
let R71 being (Element of R69);
let R72 being (Element of R69);
let R73 being (Element of R69);
thus L439: ( Product <* R71 , R72 , R73 *> ) = ( Product ( <* R71 , R72 *> ^ <* R73 *> ) ) by FINSEQ_1:43
.= ( ( Product <* R71 , R72 *> ) * R73 ) by GROUP_4:6
.= ( ( R71 * R72 ) * R73 ) by FINSOP_1:12;
end;
theorem
L440: (for R69 being  commutative  associative  well-unital non  empty doubleLoopStr holds (for B94 being (Element of ( ( 0 ) -tuples_on (the carrier of R69) )) holds ( Product B94 ) = ( 1. R69 )))
proof
let R69 being  commutative  associative  well-unital non  empty doubleLoopStr;
let C141 being (Element of ( ( 0 ) -tuples_on (the carrier of R69) ));
L441: C141 = ( <*> (the carrier of R69) );
thus L442: thesis by L441 , L433;
end;
theorem
L443: (for R1 being (Element of ( NAT )) holds (for R69 being  commutative  associative  well-unital non  empty doubleLoopStr holds ( Product ( R1 |-> ( 1_ R69 ) ) ) = ( 1_ R69 )))
proof
let R1 being (Element of ( NAT ));
let R69 being  commutative  associative  well-unital non  empty doubleLoopStr;
L444: ( the_unity_wrt (the multF of R69) ) = ( 1_ R69 ) by L21;
thus L445: thesis by L444 , SETWOP_2:25;
end;
theorem
L446: (for B95 being  add-associative  right_zeroed  right_complementable  Abelian  commutative  associative  well-unital  distributive  almost_left_invertible non  degenerated non  empty doubleLoopStr holds (for B96 being (FinSequence of (the carrier of B95)) holds ((ex R3 being (Element of ( NAT )) st (R3 in ( dom B96 ) & ( B96 . R3 ) = ( 0. B95 ))) iff ( Product B96 ) = ( 0. B95 ))))
proof
let C142 being  add-associative  right_zeroed  right_complementable  Abelian  commutative  associative  well-unital  distributive  almost_left_invertible non  degenerated non  empty doubleLoopStr;
let C143 being (FinSequence of (the carrier of C142));
defpred S2[ (Element of ( NAT )) ] means (for B97 being (FinSequence of (the carrier of C142)) holds (( len B97 ) = $1 implies ((ex R3 being (Element of ( NAT )) st (R3 in ( Seg $1 ) & ( B97 . R3 ) = ( 0. C142 ))) iff ( Product B97 ) = ( 0. C142 ))));
L447: (for R1 being (Element of ( NAT )) holds (S2[ R1 ] implies S2[ ( R1 + 1 ) ]))
proof
let R1 being (Element of ( NAT ));
assume that
L448: (for B98 being (FinSequence of (the carrier of C142)) holds (( len B98 ) = R1 implies ((ex R3 being (Element of ( NAT )) st (R3 in ( Seg R1 ) & ( B98 . R3 ) = ( 0. C142 ))) iff ( Product B98 ) = ( 0. C142 ))));
let C144 being (FinSequence of (the carrier of C142));
assume L449: ( len C144 ) = ( R1 + 1 );
consider C145 being (FinSequence of (the carrier of C142)), C146 being (Element of C142) such that L450: C144 = ( C145 ^ <* C146 *> ) by L449 , FINSEQ_2:19;
L451: ( R1 + 1 ) = ( ( len C145 ) + 1 ) by L449 , L450 , FINSEQ_2:16;
L452: R1 = ( len C145 ) by L451 , XCMPLX_1:2;
L453: ( Product C144 ) = ( ( Product C145 ) * C146 ) by L450 , GROUP_4:6;
thus L454: ((ex R3 being (Element of ( NAT )) st (R3 in ( Seg ( R1 + 1 ) ) & ( C144 . R3 ) = ( 0. C142 ))) implies ( Product C144 ) = ( 0. C142 ))
proof
given R3 being (Element of ( NAT )) such that
L455: R3 in ( Seg ( R1 + 1 ) )
and
L456: ( C144 . R3 ) = ( 0. C142 );

L457:
now
per cases  by L455 , FINSEQ_2:7;
suppose L458: R3 in ( Seg R1 );

L459: R3 in ( dom C145 ) by L458 , L452 , FINSEQ_1:def 3;
L460: ( C145 . R3 ) = ( C144 . R3 ) by L459 , L450 , FINSEQ_1:def 7;
L461: ( Product C145 ) = ( 0. C142 ) by L460 , L448 , L452 , L456 , L458;
thus L462: thesis by L461 , L453 , VECTSP_1:7;
end;
suppose L463: R3 = ( R1 + 1 );

L464: C146 = ( 0. C142 ) by L463 , L450 , L451 , L456 , FINSEQ_1:42;
thus L465: thesis by L464 , L453 , VECTSP_1:7;
end;
end;
thus L467: thesis by L457;
end;

assume L468: ( Product C144 ) = ( 0. C142 );
per cases  by L453 , L468 , VECTSP_1:12;
suppose L469: ( Product C145 ) = ( 0. C142 );

consider R3 being (Element of ( NAT )) such that L470: R3 in ( Seg R1 ) and L471: ( C145 . R3 ) = ( 0. C142 ) by L469 , L448 , L452;
L472: R3 in ( dom C145 ) by L452 , L470 , FINSEQ_1:def 3;
L473: ( C144 . R3 ) = ( 0. C142 ) by L472 , L450 , L471 , FINSEQ_1:def 7;
thus L474: thesis by L473 , L470 , FINSEQ_2:8;
end;
suppose L475: C146 = ( 0. C142 );

L476: ( C144 . ( R1 + 1 ) ) = ( 0. C142 ) by L475 , L450 , L451 , FINSEQ_1:42;
thus L477: thesis by L476 , FINSEQ_1:4;
end;
end;
L479: ( Seg ( len C143 ) ) = ( dom C143 ) by FINSEQ_1:def 3;
L480: S2[ ( 0 ) ]
proof
let C147 being (FinSequence of (the carrier of C142));
assume L481: ( len C147 ) = ( 0 );
L482: C147 = ( <*> (the carrier of C142) ) by L481;
L483: ( Product C147 ) = ( 1. C142 ) by L482 , L433;
thus L484: ((ex R3 being (Element of ( NAT )) st (R3 in ( Seg ( 0 ) ) & ( C147 . R3 ) = ( 0. C142 ))) implies ( Product C147 ) = ( 0. C142 ));
assume L485: ( Product C147 ) = ( 0. C142 );
thus L486: thesis by L485 , L483;
end;
L487: (for R1 being (Element of ( NAT )) holds S2[ R1 ]) from NAT_1:sch 1(L480 , L447);
thus L488: thesis by L487 , L479;
end;
theorem
L489: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R69 being  commutative  associative  well-unital non  empty doubleLoopStr holds (for R70 being (Element of R69) holds ( Product ( ( R1 + R2 ) |-> R70 ) ) = ( ( Product ( R1 |-> R70 ) ) * ( Product ( R2 |-> R70 ) ) ))))) by SETWOP_2:26;
theorem
L490: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R69 being  commutative  associative  well-unital non  empty doubleLoopStr holds (for R70 being (Element of R69) holds ( Product ( ( R1 * R2 ) |-> R70 ) ) = ( Product ( R2 |-> ( Product ( R1 |-> R70 ) ) ) ))))) by SETWOP_2:27;
theorem
L491: (for R1 being (Element of ( NAT )) holds (for R69 being  commutative  associative  well-unital non  empty doubleLoopStr holds (for R71 being (Element of R69) holds (for R72 being (Element of R69) holds ( Product ( R1 |-> ( R71 * R72 ) ) ) = ( ( Product ( R1 |-> R71 ) ) * ( Product ( R1 |-> R72 ) ) ))))) by SETWOP_2:36;
theorem
L492: (for R1 being (Element of ( NAT )) holds (for R69 being  commutative  associative  well-unital non  empty doubleLoopStr holds (for R75 being (Element of ( R1 -tuples_on (the carrier of R69) )) holds (for R76 being (Element of ( R1 -tuples_on (the carrier of R69) )) holds ( Product ( mlt (R75 , R76) ) ) = ( ( Product R75 ) * ( Product R76 ) ))))) by SETWOP_2:35;
theorem
L493: (for R1 being (Element of ( NAT )) holds (for R69 being  commutative  associative  well-unital non  empty doubleLoopStr holds (for R70 being (Element of R69) holds (for R75 being (Element of ( R1 -tuples_on (the carrier of R69) )) holds ( Product ( R70 * R75 ) ) = ( ( Product ( R1 |-> R70 ) ) * ( Product R75 ) )))))
proof
let R1 being (Element of ( NAT ));
let R69 being  commutative  associative  well-unital non  empty doubleLoopStr;
let R70 being (Element of R69);
let R75 being (Element of ( R1 -tuples_on (the carrier of R69) ));
thus L494: ( Product ( R70 * R75 ) ) = ( Product ( mlt (( R1 |-> R70 ) , R75) ) ) by L232
.= ( ( Product ( R1 |-> R70 ) ) * ( Product R75 ) ) by L492;
end;
begin
definition
let C148 being non  empty doubleLoopStr;
let C149 , C150 being (FinSequence of (the carrier of C148));
func C149 "*" C150 -> (Element of C148) equals 
( Sum ( mlt (C149 , C150) ) );
coherence;
end;
theorem
L496: (for B99 being  commutative  associative  left_unital  Abelian  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds (for B100 , B101 being (Element of B99) holds ( <* B100 *> "*" <* B101 *> ) = ( B100 * B101 )))
proof
let C151 being  commutative  associative  left_unital  Abelian  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let C152 , C153 being (Element of C151);
set D47 = <* C152 *>;
set D48 = <* C153 *>;
set D49 = ( mlt (D47 , D48) );
L497: D49 = <* ( C152 * C153 ) *> by FINSEQ_2:74;
L498: D49 = ( 1 |-> ( C152 * C153 ) ) by L497 , FINSEQ_2:59;
thus L499: thesis by L498 , FINSOP_1:16;
end;
theorem
L500: (for B102 being  commutative  associative  left_unital  Abelian  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds (for B103 , B104 , B105 , B106 being (Element of B102) holds ( <* B103 , B104 *> "*" <* B105 , B106 *> ) = ( ( B103 * B105 ) + ( B104 * B106 ) )))
proof
let C154 being  commutative  associative  left_unital  Abelian  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let C155 , C156 , C157 , C158 being (Element of C154);
set D50 = <* C155 , C156 *>;
set D51 = <* C157 , C158 *>;
L501: ( (the addF of C154) $$ ( mlt (D50 , D51) ) ) = ( (the addF of C154) $$ <* ( C155 * C157 ) , ( C156 * C158 ) *> ) by L211
.= ( ( C155 * C157 ) + ( C156 * C158 ) ) by FINSOP_1:12;
thus L502: thesis by L501;
end;
theorem
L503: (for R69 being  commutative  associative  well-unital non  empty doubleLoopStr holds (for B107 , B108 being (FinSequence of (the carrier of R69)) holds ( B107 "*" B108 ) = ( B108 "*" B107 ))) by L215;
