:: Term Orders
::  by Christoph Schwarzweller
::
:: Received December 20, 2002
:: Copyright (c) 2002-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, ZFMISC_1, ALGSTR_0, VECTSP_1, RLVECT_1, PRE_POLY,
      XCMPLX_0, ARYTM_3, FUNCT_1, XXREAL_0, ARYTM_1, CARD_1, XBOOLE_0,
      SUBSET_1, MCART_1, RELAT_1, PBOOLE, TARSKI, ORDINAL1, LATTICES, POLYNOM1,
      FINSEQ_1, CARD_3, PARTFUN1, NAT_1, SUPINF_2, POLYNOM7, STRUCT_0,
      VECTSP_2, CAT_3, BAGORDER, RELAT_2, WELLORD1, FINSET_1, BROUWER,
      VALUED_0, ORDERS_1, ALGSTR_1, TERMORD;
 notations NUMBERS, XCMPLX_0, TARSKI, XBOOLE_0, SUBSET_1, ORDERS_1, RELAT_1,
      CARD_1, BAGORDER, RELSET_1, FUNCT_1, PARTFUN1, FINSET_1, XXREAL_0,
      ORDINAL1, ALGSTR_1, PBOOLE, FINSEQ_1, PRE_POLY, STRUCT_0, ALGSTR_0,
      RLVECT_1, VFUNCT_1, XTUPLE_0, MCART_1, VECTSP_1, VECTSP_2, RELAT_2,
      POLYNOM1, NAT_D, WELLORD1, POLYNOM7;
 constructors VECTSP_2, ALGSTR_1, TRIANG_1, POLYNOM7, BAGORDER, WELLORD2,
      RELSET_1, POLYNOM1, BINOP_2, VFUNCT_1, XTUPLE_0;
 registrations XBOOLE_0, ORDINAL1, RELSET_1, FINSET_1, XXREAL_0, XREAL_0,
      NAT_1, CARD_1, FINSEQ_1, STRUCT_0, VECTSP_1, ALGSTR_1, POLYNOM1,
      POLYNOM2, POLYNOM7, BAGORDER, VALUED_0, PRE_POLY, VFUNCT_1, FUNCT_2,
      FUNCT_1, XTUPLE_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions XTUPLE_0;
 theorems TARSKI, FINSEQ_1, FUNCT_1, FUNCT_2, RELAT_1, POLYNOM1, NAT_1, BINOM,
      RLVECT_1, VECTSP_2, POLYNOM7, POLYNOM2, NAT_2, RELAT_2, CARD_1, CARD_2,
      MATRLIN, XBOOLE_0, XBOOLE_1, ORDERS_1, MCART_1, BAGORDER, WELLORD1,
      VECTSP_1, XREAL_1, PARTFUN1, VALUED_0, STRUCT_0, XREAL_0, PRE_POLY,
      XTUPLE_0;
 schemes NAT_1;

begin
registration
cluster non  trivial for addLoopStr;
existence
proof
take the Field;
thus L1: thesis;
end;
end;
registration
cluster  add-associative  right_complementable  right_zeroed for non  trivial non  trivial non  trivial non  trivial addLoopStr;
existence
proof
set D1 = the Field;
take D1;
thus L3: thesis;
end;
end;
definition
let C1 being set;
let C2 being (bag of C1);
attr C2 is  zero
means
C2 = ( EmptyBag C1 );
end;
theorem
L6: (for B1 being set holds (for B2 , B3 being (bag of B1) holds (B2 divides B3 iff (ex B4 being (bag of B1) st B3 = ( B2 + B4 )))))
proof
let C3 being set;
let C4 , C5 being (bag of C3);
L7:
now
assume L8: C4 divides C5;
L9:
now
let C6 being set;
L10: ( C4 . C6 ) <= ( C5 . C6 ) by L8 , PRE_POLY:def 11;
L11: ( ( C4 . C6 ) - ( C4 . C6 ) ) <= ( ( C5 . C6 ) - ( C4 . C6 ) ) by L10 , XREAL_1:9;
thus L12: ( 0 ) <= ( ( C5 . C6 ) - ( C4 . C6 ) ) by L11;
end;
L13:
now
per cases ;
case L14: C3 = ( {} );
L15: ( C4 + ( EmptyBag C3 ) ) = ( EmptyBag C3 ) by L14 , POLYNOM7:3
.= C5 by L14 , POLYNOM7:3;
thus L16: (ex B5 being (bag of C3) st C5 = ( C4 + B5 )) by L15;
end;
case L17: C3 <> ( {} );
reconsider D2 = C3 as non  empty set by L17;
set D3 = { [ B6 , ( ( C5 . B6 ) -' ( C4 . B6 ) ) ] where B6 is (Element of D2) : (not contradiction) };
L18:
now
let C7 being set;
assume L19: C7 in D3;
L20: (ex B7 being (Element of D2) st C7 = [ B7 , ( ( C5 . B7 ) -' ( C4 . B7 ) ) ]) by L19;
thus L21: (ex B8 , B9 being set st C7 = [ B8 , B9 ]) by L20;
end;
L22:
now
let C8 , C9 , C10 being set;
assume that
L23: [ C8 , C9 ] in D3
and
L24: [ C8 , C10 ] in D3;
consider C11 being (Element of D2) such that L25: [ C8 , C9 ] = [ C11 , ( ( C5 . C11 ) -' ( C4 . C11 ) ) ] by L23;
consider C12 being (Element of D2) such that L26: [ C8 , C10 ] = [ C12 , ( ( C5 . C12 ) -' ( C4 . C12 ) ) ] by L24;
L27: C11 = C8 by L25 , XTUPLE_0:1
.= C12 by L26 , XTUPLE_0:1;
thus L28: C9 = C10 by L27 , L25 , L26 , XTUPLE_0:1;
end;
reconsider D4 = D3 as Function by L22 , L18 , FUNCT_1:def 1 , RELAT_1:def 1;
L29:
now
let C13 being set;
assume L30: C13 in ( dom D4 );
consider C14 being set such that L31: [ C13 , C14 ] in D4 by L30 , XTUPLE_0:def 12;
consider C15 being (Element of D2) such that L32: [ C13 , C14 ] = [ C15 , ( ( C5 . C15 ) -' ( C4 . C15 ) ) ] by L31;
L33: C13 = C15 by L32 , XTUPLE_0:1;
thus L34: C13 in D2 by L33;
end;
L35:
now
let C16 being set;
assume L36: C16 in D2;
reconsider D5 = C16 as (Element of D2) by L36;
L37: [ D5 , ( ( C5 . D5 ) -' ( C4 . D5 ) ) ] in D4;
thus L38: C16 in ( dom D4 ) by L37 , XTUPLE_0:def 12;
end;
L39: ( dom D4 ) = D2 by L35 , L29 , TARSKI:1;
reconsider D6 = D4 as (ManySortedSet of D2) by L39 , PARTFUN1:def 2 , RELAT_1:def 18;
L40:
now
let C17 being set;
assume L41: C17 in C3;
consider C18 being set such that L42: [ C17 , C18 ] in D6 by L41 , L39 , XTUPLE_0:def 12;
consider C19 being (Element of D2) such that L43: [ C17 , C18 ] = [ C19 , ( ( C5 . C19 ) -' ( C4 . C19 ) ) ] by L42;
L44: C18 = ( ( C5 . C19 ) -' ( C4 . C19 ) ) by L43 , XTUPLE_0:1;
L45: C17 = C19 by L43 , XTUPLE_0:1;
thus L46: ( D6 . C17 ) = ( ( C5 . C17 ) -' ( C4 . C17 ) ) by L45 , L42 , L44 , FUNCT_1:1;
end;
L47:
now
let C20 being set;
L48: ( support D6 ) c= ( dom D6 ) by PRE_POLY:37;
assume L49: C20 in ( support D6 );
L50: ( D6 . C20 ) <> ( 0 ) by L49 , PRE_POLY:def 7;
L51:
now
assume L52: (not C20 in ( support C5 ));
L53: ( C5 . C20 ) = ( 0 ) by L52 , PRE_POLY:def 7;
L54: ( 0 ) = ( ( C5 . C20 ) -' ( C4 . C20 ) ) by L53 , NAT_2:8;
thus L55: contradiction by L54 , L39 , L40 , L49 , L50 , L48;
end;
thus L56: C20 in ( support C5 ) by L51;
end;
L57: ( support D6 ) c= ( support C5 ) by L47 , TARSKI:def 3;
L58:
now
let C21 being set;
assume L59: C21 in ( rng D6 );
consider C22 being set such that L60: [ C22 , C21 ] in D6 by L59 , XTUPLE_0:def 13;
consider C23 being (Element of D2) such that L61: [ C22 , C21 ] = [ C23 , ( ( C5 . C23 ) -' ( C4 . C23 ) ) ] by L60;
L62: C21 = ( ( C5 . C23 ) -' ( C4 . C23 ) ) by L61 , XTUPLE_0:1;
thus L63: C21 in ( NAT ) by L62;
end;
L64: ( rng D6 ) c= ( NAT ) by L58 , TARSKI:def 3;
reconsider D7 = D6 as (bag of C3) by L64 , L57 , PRE_POLY:def 8 , VALUED_0:def 6;
take D8 = D7;
L65:
now
let C24 being set;
L66: ( 0 ) <= ( ( C5 . C24 ) - ( C4 . C24 ) ) by L9;
assume L67: C24 in C3;
thus L68: ( ( C4 . C24 ) + ( D8 . C24 ) ) = ( ( C4 . C24 ) + ( ( C5 . C24 ) -' ( C4 . C24 ) ) ) by L67 , L40
.= ( ( C4 . C24 ) + ( ( C5 . C24 ) + ( - ( C4 . C24 ) ) ) ) by L66 , XREAL_0:def 2
.= ( C5 . C24 );
end;
L69: C5 = ( C4 + D8 ) by L65 , PRE_POLY:33;
thus L70: (ex B10 being (bag of C3) st C5 = ( C4 + B10 )) by L69;
end;
end;
thus L72: (ex B11 being (bag of C3) st C5 = ( C4 + B11 )) by L13;
end;
thus L73: thesis by L7 , PRE_POLY:50;
end;
theorem
L74: (for B12 being Ordinal holds (for B13 being  add-associative  right_complementable  right_zeroed  well-unital  distributive non  empty doubleLoopStr holds (for B14 being (Series of B12 , B13) holds ( ( 0_ (B12 , B13) ) *' B14 ) = ( 0_ (B12 , B13) ))))
proof
let C25 being Ordinal;
let C26 being  add-associative  right_complementable  right_zeroed  well-unital  distributive non  empty doubleLoopStr;
let C27 being (Series of C25 , C26);
set D9 = ( 0_ (C25 , C26) );
L75:
now
let C28 being (Element of ( Bags C25 ));
consider C29 being (FinSequence of C26) such that L76: ( ( D9 *' C27 ) . C28 ) = ( Sum C29 ) and L77: ( len C29 ) = ( len ( decomp C28 ) ) and L78: (for B15 being (Element of ( NAT )) holds (B15 in ( dom C29 ) implies (ex B16 , B17 being (bag of C25) st (( ( decomp C28 ) /. B15 ) = <* B16 , B17 *> & ( C29 /. B15 ) = ( ( D9 . B16 ) * ( C27 . B17 ) ))))) by POLYNOM1:def 9;
L79:
now
let C30 being Nat;
assume L80: C30 in ( dom C29 );
consider C31 , C32 being (bag of C25) such that L81: ( ( decomp C28 ) /. C30 ) = <* C31 , C32 *> and L82: ( C29 /. C30 ) = ( ( D9 . C31 ) * ( C27 . C32 ) ) by L80 , L78;
thus L83: ( C29 /. C30 ) = ( ( 0. C26 ) * ( C27 . C32 ) ) by L82 , POLYNOM1:22
.= ( 0. C26 ) by VECTSP_1:7;
end;
L84: ( Sum C29 ) = ( 0. C26 ) by L79 , MATRLIN:11;
thus L85: ( ( D9 *' C27 ) . C28 ) = ( D9 . C28 ) by L84 , L76 , POLYNOM1:22;
end;
thus L86: thesis by L75 , FUNCT_2:63;
end;
registration
let C33 being Ordinal;
let C34 being  add-associative  right_complementable  right_zeroed  well-unital  distributive non  empty doubleLoopStr;
let C35 , C36 being (Monomial of C33 , C34);
cluster ( C35 *' C36 ) ->  monomial-like;
coherence
proof
per cases ;
suppose L87: ( Support ( C35 *' C36 ) ) = ( {} );

thus L88: thesis by L87 , POLYNOM7:6;
end;
suppose L89: ( Support ( C35 *' C36 ) ) <> ( {} );

L90:
now
per cases ;
case L91: (( Support C35 ) <> ( {} ) & ( Support C36 ) <> ( {} ));
consider C37 being (bag of C33) such that L92: ( Support C36 ) = { C37 } by L91 , POLYNOM7:6;
L93: C37 in ( Support C36 ) by L92 , TARSKI:def 1;
L94: ( C36 . C37 ) <> ( 0. C34 ) by L93 , POLYNOM1:def 3;
L95:
now
let C38 being (bag of C33);
assume L96: C38 <> C37;
consider C39 being (bag of C33) such that L97: (for B18 being (bag of C33) holds (B18 <> C39 implies ( C36 . B18 ) = ( 0. C34 ))) by POLYNOM7:def 3;
L98: C39 = C37 by L94 , L97;
thus L99: ( C36 . C38 ) = ( 0. C34 ) by L98 , L96 , L97;
end;
consider C40 being (bag of C33) such that L100: ( Support C35 ) = { C40 } by L91 , POLYNOM7:6;
L101: C40 in ( Support C35 ) by L100 , TARSKI:def 1;
L102: ( C35 . C40 ) <> ( 0. C34 ) by L101 , POLYNOM1:def 3;
L103:
now
let C41 being (bag of C33);
assume L104: C41 <> C40;
consider C42 being (bag of C33) such that L105: (for B19 being (bag of C33) holds (B19 <> C42 implies ( C35 . B19 ) = ( 0. C34 ))) by POLYNOM7:def 3;
L106: C42 = C40 by L102 , L105;
thus L107: ( C35 . C41 ) = ( 0. C34 ) by L106 , L104 , L105;
end;
set D10 = the (Element of ( Support ( C35 *' C36 ) ));
L108: D10 in ( Support ( C35 *' C36 ) ) by L89;
L109: D10 is (Element of ( Bags C33 )) by L108;
reconsider D11 = D10 as (bag of C33) by L109;
consider C43 being (FinSequence of C34) such that L110: ( ( C35 *' C36 ) . D11 ) = ( Sum C43 ) and L111: ( len C43 ) = ( len ( decomp D11 ) ) and L112: (for B20 being (Element of ( NAT )) holds (B20 in ( dom C43 ) implies (ex B21 , B22 being (bag of C33) st (( ( decomp D11 ) /. B20 ) = <* B21 , B22 *> & ( C43 /. B20 ) = ( ( C35 . B21 ) * ( C36 . B22 ) ))))) by POLYNOM1:def 9;
L113: ( dom C43 ) = ( Seg ( len ( decomp D11 ) ) ) by L111 , FINSEQ_1:def 3
.= ( dom ( decomp D11 ) ) by FINSEQ_1:def 3;
L114:
now
assume L115: D11 <> ( C40 + C37 );
L116:
now
let C44 being (Element of ( NAT ));
assume L117: C44 in ( dom C43 );
consider C45 , C46 being (bag of C33) such that L118: ( ( decomp D11 ) /. C44 ) = <* C45 , C46 *> and L119: ( C43 /. C44 ) = ( ( C35 . C45 ) * ( C36 . C46 ) ) by L117 , L112;
consider C47 , C48 being (bag of C33) such that L120: ( ( decomp D11 ) /. C44 ) = <* C47 , C48 *> and L121: D11 = ( C47 + C48 ) by L113 , L117 , PRE_POLY:68;
L122: C46 = ( <* C47 , C48 *> . 2 ) by L118 , L120 , FINSEQ_1:44
.= C48 by FINSEQ_1:44;
L123: C45 = ( <* C47 , C48 *> . 1 ) by L118 , L120 , FINSEQ_1:44
.= C47 by FINSEQ_1:44;
L124:
now
per cases  by L115 , L121 , L123 , L122;
case L125: C45 <> C40;
L126: ( C35 . C45 ) = ( 0. C34 ) by L125 , L103;
thus L127: ( ( C35 . C45 ) * ( C36 . C46 ) ) = ( 0. C34 ) by L126 , BINOM:1;
end;
case L128: C46 <> C37;
L129: ( C36 . C46 ) = ( 0. C34 ) by L128 , L95;
thus L130: ( ( C35 . C45 ) * ( C36 . C46 ) ) = ( 0. C34 ) by L129 , BINOM:2;
end;
end;
thus L132: ( C43 /. C44 ) = ( 0. C34 ) by L124 , L119;
end;
L133:
now
per cases ;
case L134: ( dom C43 ) = ( {} );
L135: C43 = ( <*> (the carrier of C34) ) by L134 , RELAT_1:41;
thus L136: ( ( C35 *' C36 ) . D11 ) = ( 0. C34 ) by L135 , L111;
end;
case L137: ( dom C43 ) <> ( {} );
set D12 = the (Element of ( dom C43 ));
L138: D12 in ( dom C43 ) by L137;
L139: (for B23 being (Element of ( NAT )) holds ((B23 in ( dom C43 ) & B23 <> D12) implies ( C43 /. B23 ) = ( 0. C34 ))) by L116;
L140: ( C43 /. D12 ) = ( ( C35 *' C36 ) . D11 ) by L139 , L110 , L138 , POLYNOM2:3;
thus L141: ( ( C35 *' C36 ) . D11 ) = ( 0. C34 ) by L140 , L116 , L138;
end;
end;
thus L143: contradiction by L133 , L108 , POLYNOM1:def 3;
end;
L144:
now
let C49 being (bag of C33);
assume L145: C49 <> D11;
consider C50 being (FinSequence of C34) such that L146: ( ( C35 *' C36 ) . C49 ) = ( Sum C50 ) and L147: ( len C50 ) = ( len ( decomp C49 ) ) and L148: (for B24 being (Element of ( NAT )) holds (B24 in ( dom C50 ) implies (ex B25 , B26 being (bag of C33) st (( ( decomp C49 ) /. B24 ) = <* B25 , B26 *> & ( C50 /. B24 ) = ( ( C35 . B25 ) * ( C36 . B26 ) ))))) by POLYNOM1:def 9;
L149: ( dom C50 ) = ( Seg ( len ( decomp C49 ) ) ) by L147 , FINSEQ_1:def 3
.= ( dom ( decomp C49 ) ) by FINSEQ_1:def 3;
L150:
now
let C51 being (Element of ( NAT ));
assume L151: C51 in ( dom C50 );
consider C52 , C53 being (bag of C33) such that L152: ( ( decomp C49 ) /. C51 ) = <* C52 , C53 *> and L153: ( C50 /. C51 ) = ( ( C35 . C52 ) * ( C36 . C53 ) ) by L151 , L148;
consider C54 , C55 being (bag of C33) such that L154: ( ( decomp C49 ) /. C51 ) = <* C54 , C55 *> and L155: C49 = ( C54 + C55 ) by L149 , L151 , PRE_POLY:68;
L156: C53 = ( <* C54 , C55 *> . 2 ) by L152 , L154 , FINSEQ_1:44
.= C55 by FINSEQ_1:44;
L157: C52 = ( <* C54 , C55 *> . 1 ) by L152 , L154 , FINSEQ_1:44
.= C54 by FINSEQ_1:44;
L158:
now
per cases  by L114 , L145 , L155 , L157 , L156;
case L159: C52 <> C40;
L160: ( C35 . C52 ) = ( 0. C34 ) by L159 , L103;
thus L161: ( ( C35 . C52 ) * ( C36 . C53 ) ) = ( 0. C34 ) by L160 , BINOM:1;
end;
case L162: C53 <> C37;
L163: ( C36 . C53 ) = ( 0. C34 ) by L162 , L95;
thus L164: ( ( C35 . C52 ) * ( C36 . C53 ) ) = ( 0. C34 ) by L163 , BINOM:2;
end;
end;
thus L166: ( C50 /. C51 ) = ( 0. C34 ) by L158 , L153;
end;
L167:
now
per cases ;
case L168: ( dom C50 ) = ( {} );
L169: C50 = ( <*> (the carrier of C34) ) by L168 , RELAT_1:41;
thus L170: ( ( C35 *' C36 ) . C49 ) = ( 0. C34 ) by L169 , L147;
end;
case L171: ( dom C50 ) <> ( {} );
set D13 = the (Element of ( dom C50 ));
L172: D13 in ( dom C50 ) by L171;
L173: (for B27 being (Element of ( NAT )) holds ((B27 in ( dom C50 ) & B27 <> D13) implies ( C50 /. B27 ) = ( 0. C34 ))) by L150;
L174: ( C50 /. D13 ) = ( ( C35 *' C36 ) . C49 ) by L173 , L146 , L172 , POLYNOM2:3;
thus L175: ( ( C35 *' C36 ) . C49 ) = ( 0. C34 ) by L174 , L150 , L172;
end;
end;
thus L177: ( ( C35 *' C36 ) . C49 ) = ( 0. C34 ) by L167;
end;
thus L178: thesis by L144 , POLYNOM7:def 3;
end;
case L179: (( Support C35 ) = ( {} ) or ( Support C36 ) = ( {} ));
L180:
now
per cases  by L179;
case L181: ( Support C35 ) = ( {} );
L182: C35 = ( 0_ (C33 , C34) ) by L181 , POLYNOM7:1;
thus L183: thesis by L182 , L74;
end;
case L184: ( Support C36 ) = ( {} );
L185: C36 = ( 0_ (C33 , C34) ) by L184 , POLYNOM7:1;
thus L186: thesis by L185 , POLYNOM1:28;
end;
end;
thus L188: thesis by L180;
end;
end;
thus L190: thesis by L90;
end;
end;
end;
registration
let C56 being Ordinal;
let C57 being  add-associative  right_complementable  right_zeroed  distributive non  empty doubleLoopStr;
let C58 , C59 being (ConstPoly of C56 , C57);
cluster ( C58 *' C59 ) ->  Constant;
coherence
proof
set D14 = ( C58 *' C59 );
L193:
now
let C60 being (bag of C56);
assume L194: C60 <> ( EmptyBag C56 );
consider C61 being (FinSequence of C57) such that L195: ( D14 . C60 ) = ( Sum C61 ) and L196: ( len C61 ) = ( len ( decomp C60 ) ) and L197: (for B28 being (Element of ( NAT )) holds (B28 in ( dom C61 ) implies (ex B29 , B30 being (bag of C56) st (( ( decomp C60 ) /. B28 ) = <* B29 , B30 *> & ( C61 /. B28 ) = ( ( C58 . B29 ) * ( C59 . B30 ) ))))) by POLYNOM1:def 9;
L198: ( dom C61 ) = ( Seg ( len ( decomp C60 ) ) ) by L196 , FINSEQ_1:def 3
.= ( dom ( decomp C60 ) ) by FINSEQ_1:def 3;
L199:
now
let C62 being (Element of ( NAT ));
assume L200: C62 in ( dom C61 );
consider C63 , C64 being (bag of C56) such that L201: ( ( decomp C60 ) /. C62 ) = <* C63 , C64 *> and L202: ( C61 /. C62 ) = ( ( C58 . C63 ) * ( C59 . C64 ) ) by L200 , L197;
consider C65 , C66 being (bag of C56) such that L203: ( ( decomp C60 ) /. C62 ) = <* C65 , C66 *> and L204: C60 = ( C65 + C66 ) by L198 , L200 , PRE_POLY:68;
L205: C64 = ( <* C65 , C66 *> . 2 ) by L201 , L203 , FINSEQ_1:44
.= C66 by FINSEQ_1:44;
L206: C63 = ( <* C65 , C66 *> . 1 ) by L201 , L203 , FINSEQ_1:44
.= C65 by FINSEQ_1:44;
L207: (C63 <> ( EmptyBag C56 ) or C64 <> ( EmptyBag C56 )) by L206 , L194 , L204 , L205 , PRE_POLY:53;
L208:
now
per cases  by L207 , POLYNOM7:def 7;
case L209: ( C58 . C63 ) = ( 0. C57 );
thus L210: ( C61 /. C62 ) = ( 0. C57 ) by L209 , L202 , BINOM:1;
end;
case L211: ( C59 . C64 ) = ( 0. C57 );
thus L212: ( C61 /. C62 ) = ( 0. C57 ) by L211 , L202 , BINOM:2;
end;
end;
thus L214: ( C61 /. C62 ) = ( 0. C57 ) by L208;
end;
L215:
now
per cases ;
case L216: ( dom C61 ) = ( {} );
L217: C61 = ( <*> (the carrier of C57) ) by L216 , RELAT_1:41;
thus L218: ( D14 . C60 ) = ( 0. C57 ) by L217 , L196;
end;
case L219: ( dom C61 ) <> ( {} );
set D15 = the (Element of ( dom C61 ));
L220: D15 in ( dom C61 ) by L219;
L221: (for B31 being (Element of ( NAT )) holds ((B31 in ( dom C61 ) & B31 <> D15) implies ( C61 /. B31 ) = ( 0. C57 ))) by L199;
L222: ( Sum C61 ) = ( C61 /. D15 ) by L221 , L220 , POLYNOM2:3;
thus L223: ( D14 . C60 ) = ( 0. C57 ) by L222 , L195 , L199 , L220;
end;
end;
thus L225: ( D14 . C60 ) = ( 0. C57 ) by L215;
end;
thus L226: thesis by L193 , POLYNOM7:def 7;
end;
end;
theorem
L228: (for B32 being Ordinal holds (for B33 being  add-associative  right_complementable  right_zeroed  well-unital  distributive  domRing-like non  trivial doubleLoopStr holds (for B34 , B35 being (bag of B32) holds (for B36 , B37 being non  zero (Element of B33) holds ( Monom (( B36 * B37 ) , ( B34 + B35 )) ) = ( ( Monom (B36 , B34) ) *' ( Monom (B37 , B35) ) )))))
proof
let C67 being Ordinal;
let C68 being  add-associative  right_complementable  right_zeroed  well-unital  distributive  domRing-like non  trivial doubleLoopStr;
let C69 , C70 being (bag of C67);
let C71 , C72 being non  zero (Element of C68);
set D16 = ( Monom (C71 , C69) );
set D17 = ( Monom (C72 , C70) );
set D18 = ( Monom (( C71 * C72 ) , ( C69 + C70 )) );
set D19 = ( D16 *' D17 );
consider C73 being (FinSequence of C68) such that L229: ( D19 . ( C69 + C70 ) ) = ( Sum C73 ) and L230: ( len C73 ) = ( len ( decomp ( C69 + C70 ) ) ) and L231: (for B38 being (Element of ( NAT )) holds (B38 in ( dom C73 ) implies (ex B39 , B40 being (bag of C67) st (( ( decomp ( C69 + C70 ) ) /. B38 ) = <* B39 , B40 *> & ( C73 /. B38 ) = ( ( D16 . B39 ) * ( D17 . B40 ) ))))) by POLYNOM1:def 9;
set D20 = ( C69 + C70 );
consider C74 being (Element of ( NAT )) such that L232: C74 in ( dom ( decomp D20 ) ) and L233: ( ( decomp D20 ) /. C74 ) = <* C69 , C70 *> by PRE_POLY:69;
L234: ( dom C73 ) = ( Seg ( len ( decomp ( C69 + C70 ) ) ) ) by L230 , FINSEQ_1:def 3
.= ( dom ( decomp ( C69 + C70 ) ) ) by FINSEQ_1:def 3;
consider C75 , C76 being (bag of C67) such that L235: ( ( decomp D20 ) /. C74 ) = <* C75 , C76 *> and L236: ( C73 /. C74 ) = ( ( D16 . C75 ) * ( D17 . C76 ) ) by L234 , L231 , L232;
L237: C75 = ( <* C69 , C70 *> . 1 ) by L233 , L235 , FINSEQ_1:44
.= C69 by FINSEQ_1:44;
L238: C76 = ( <* C69 , C70 *> . 2 ) by L233 , L235 , FINSEQ_1:44
.= C70 by FINSEQ_1:44;
L239: ( D17 . C70 ) = ( D17 . ( term D17 ) ) by POLYNOM7:10
.= ( coefficient D17 ) by POLYNOM7:def 6
.= C72 by POLYNOM7:9;
L240:
now
L241: ( D17 . C70 ) <> ( 0. C68 ) by L239;
let C77 being (bag of C67);
assume L242: C77 <> C70;
consider C78 being (bag of C67) such that L243: (for B41 being (bag of C67) holds (B41 <> C78 implies ( D17 . B41 ) = ( 0. C68 ))) by POLYNOM7:def 3;
assume L244: ( D17 . C77 ) <> ( 0. C68 );
L245: C77 = C78 by L244 , L243;
thus L246: contradiction by L245 , L242 , L243 , L241;
end;
L247: ( C71 * C72 ) <> ( 0. C68 ) by VECTSP_2:def 1;
L248: ( C71 * C72 ) is non  zero by L247 , STRUCT_0:def 12;
L249: ( D16 . C69 ) = ( D16 . ( term D16 ) ) by POLYNOM7:10
.= ( coefficient D16 ) by POLYNOM7:def 6
.= C71 by POLYNOM7:9;
L250:
now
L251: ( D16 . C69 ) <> ( 0. C68 ) by L249;
let C79 being (bag of C67);
assume L252: C79 <> C69;
consider C80 being (bag of C67) such that L253: (for B42 being (bag of C67) holds (B42 <> C80 implies ( D16 . B42 ) = ( 0. C68 ))) by POLYNOM7:def 3;
assume L254: ( D16 . C79 ) <> ( 0. C68 );
L255: C79 = C80 by L254 , L253;
thus L256: contradiction by L255 , L252 , L253 , L251;
end;
L257:
now
let C81 being (Element of ( NAT ));
assume that
L258: C81 in ( dom C73 )
and
L259: C81 <> C74;
consider C82 , C83 being (bag of C67) such that L260: ( ( decomp D20 ) /. C81 ) = <* C82 , C83 *> and L261: ( C73 /. C81 ) = ( ( D16 . C82 ) * ( D17 . C83 ) ) by L231 , L258;
L262:
now
assume L263: (C82 = C69 & C83 = C70);
L264: ( ( decomp D20 ) . C81 ) = ( ( decomp D20 ) /. C81 ) by L234 , L258 , PARTFUN1:def 6
.= ( ( decomp D20 ) . C74 ) by L232 , L233 , L260 , L263 , PARTFUN1:def 6;
thus L265: contradiction by L264 , L234 , L232 , L258 , L259 , FUNCT_1:def 4;
end;
L266:
now
per cases  by L262;
case L267: C82 <> C69;
L268: ( D16 . C82 ) = ( 0. C68 ) by L267 , L250;
thus L269: ( ( D16 . C82 ) * ( D17 . C83 ) ) = ( 0. C68 ) by L268 , BINOM:1;
end;
case L270: C83 <> C70;
L271: ( D17 . C83 ) = ( 0. C68 ) by L270 , L240;
thus L272: ( ( D16 . C82 ) * ( D17 . C83 ) ) = ( 0. C68 ) by L271 , BINOM:2;
end;
end;
thus L274: ( C73 /. C81 ) = ( 0. C68 ) by L266 , L261;
end;
L275: ( Sum C73 ) = ( C73 /. C74 ) by L257 , L234 , L232 , POLYNOM2:3;
L276: ( D19 . ( C69 + C70 ) ) <> ( 0. C68 ) by L275 , L249 , L239 , L229 , L236 , L237 , L238 , VECTSP_2:def 1;
L277: ( term D19 ) = ( C69 + C70 ) by L276 , POLYNOM7:def 5
.= ( term D18 ) by L248 , POLYNOM7:10;
L278: ( coefficient D19 ) = ( D19 . ( term D19 ) ) by POLYNOM7:def 6
.= ( D19 . ( C69 + C70 ) ) by L276 , POLYNOM7:def 5
.= ( C71 * C72 ) by L249 , L239 , L229 , L234 , L232 , L236 , L237 , L238 , L257 , POLYNOM2:3
.= ( coefficient D18 ) by POLYNOM7:9;
thus L279: D18 = ( Monom (( coefficient D18 ) , ( term D18 )) ) by POLYNOM7:11
.= D19 by L277 , L278 , POLYNOM7:11;
end;
theorem
L280: (for B43 being Ordinal holds (for B44 being  add-associative  right_complementable  right_zeroed  well-unital  distributive  domRing-like non  trivial doubleLoopStr holds (for B45 , B46 being (Element of B44) holds ( ( B45 * B46 ) | (B43 , B44) ) = ( ( B45 | (B43 , B44) ) *' ( B46 | (B43 , B44) ) ))))
proof
let C84 being Ordinal;
let C85 being  add-associative  right_complementable  right_zeroed  well-unital  distributive  domRing-like non  trivial doubleLoopStr;
let C86 , C87 being (Element of C85);
per cases ;
suppose L281: (C86 is non  zero & C87 is non  zero);

L282: (( term ( ( C86 * C87 ) | (C84 , C85) ) ) = ( EmptyBag C84 ) & ( coefficient ( ( C86 * C87 ) | (C84 , C85) ) ) = ( C86 * C87 )) by POLYNOM7:23;
L283: ( ( C86 * C87 ) | (C84 , C85) ) = ( Monom (( C86 * C87 ) , ( EmptyBag C84 )) ) by L282 , POLYNOM7:11;
L284: (( term ( C87 | (C84 , C85) ) ) = ( EmptyBag C84 ) & ( coefficient ( C87 | (C84 , C85) ) ) = C87) by POLYNOM7:23;
L285: ( C87 | (C84 , C85) ) = ( Monom (C87 , ( EmptyBag C84 )) ) by L284 , POLYNOM7:11;
L286: (( term ( C86 | (C84 , C85) ) ) = ( EmptyBag C84 ) & ( coefficient ( C86 | (C84 , C85) ) ) = C86) by POLYNOM7:23;
L287: ( C86 | (C84 , C85) ) = ( Monom (C86 , ( EmptyBag C84 )) ) by L286 , POLYNOM7:11;
L288: ( ( EmptyBag C84 ) + ( EmptyBag C84 ) ) = ( EmptyBag C84 ) by PRE_POLY:53;
thus L289: thesis by L288 , L281 , L283 , L287 , L285 , L228;
end;
suppose L290: (not (C86 is non  zero & C87 is non  zero));

L291:
now
per cases  by L290 , STRUCT_0:def 12;
case L292: C86 = ( 0. C85 );
L293: ( C86 * C87 ) = ( 0. C85 ) by L292 , BINOM:1;
L294: ( ( C86 * C87 ) | (C84 , C85) ) = ( 0_ (C84 , C85) ) by L293 , POLYNOM7:19;
L295: ( C86 | (C84 , C85) ) = ( 0_ (C84 , C85) ) by L292 , POLYNOM7:19;
thus L296: thesis by L295 , L294 , L74;
end;
case L297: C87 = ( 0. C85 );
L298: ( C86 * C87 ) = ( 0. C85 ) by L297 , BINOM:2;
L299: ( ( C86 * C87 ) | (C84 , C85) ) = ( 0_ (C84 , C85) ) by L298 , POLYNOM7:19;
L300: ( C87 | (C84 , C85) ) = ( 0_ (C84 , C85) ) by L297 , POLYNOM7:19;
thus L301: thesis by L300 , L299 , POLYNOM1:28;
end;
end;
thus L303: thesis by L291;
end;
end;
begin
L305: (for B47 being Ordinal holds (for B48 being (TermOrder of B47) holds (for B49 being set holds (B49 in ( field B48 ) implies B49 is (bag of B47)))))
proof
let C88 being Ordinal;
let C89 being (TermOrder of C88);
let C90 being set;
assume L306: C90 in ( field C89 );
L307: C90 in ( ( dom C89 ) \/ ( rng C89 ) ) by L306 , RELAT_1:def 6;
per cases  by L307 , XBOOLE_0:def 3;
suppose L308: C90 in ( dom C89 );

L309: C90 is (Element of ( Bags C88 )) by L308;
thus L310: thesis by L309;
end;
suppose L311: C90 in ( rng C89 );

L312: C90 is (Element of ( Bags C88 )) by L311;
thus L313: thesis by L312;
end;
end;
registration
let C91 being Ordinal;
cluster  admissible  connected for (TermOrder of C91);
existence
proof
set D21 = ( LexOrder C91 );
take D21;
L315:
now
let C92 , C93 being set;
assume that
L316: (C92 in ( field D21 ) & C93 in ( field D21 ))
and
L317: C92 <> C93;
reconsider D22 = C92 , D23 = C93 as (bag of C91) by L316 , L305;
L318: (D22 <=' D23 or D23 <=' D22) by PRE_POLY:45;
thus L319: ([ C92 , C93 ] in D21 or [ C93 , C92 ] in D21) by L318 , PRE_POLY:def 14;
end;
L320: D21 is_connected_in ( field D21 ) by L315 , RELAT_2:def 6;
thus L321: thesis by L320 , RELAT_2:def 14;
end;
end;
registration
let C94 being Nat;
cluster  ->  well_founded for  admissible  admissible  admissible  admissible (TermOrder of C94);
coherence
proof
let C95 being  admissible (TermOrder of C94);
L323: C95 is  well-ordering by BAGORDER:34;
thus L324: thesis by L323 , WELLORD1:def 4;
end;
end;
definition
let C96 being Ordinal;
let C97 being (TermOrder of C96);
let C98 , C99 being (bag of C96);
pred C98 <= C99 , C97
means
:L326: [ C98 , C99 ] in C97
;end;
definition
let C100 being Ordinal;
let C101 being (TermOrder of C100);
let C102 , C103 being (bag of C100);
pred C102 < C103 , C101
means
:L328: (C102 <= C103 , C101 & C102 <> C103)
;end;
definition
let C104 being Ordinal;
let C105 being (TermOrder of C104);
let C106 , C107 being (bag of C104);
func min (C106 , C107 , C105) -> (bag of C104) equals 
:L330: C106 if C106 <= C107 , C105 otherwise C107;
correctness;
func max (C106 , C107 , C105) -> (bag of C104) equals 
:L331: C106 if C107 <= C106 , C105 otherwise C107;
correctness;
end;
L333: (for B50 being Ordinal holds (for B51 being (TermOrder of B50) holds (for B52 being (bag of B50) holds B52 <= B52 , B51)))
proof
let C108 being Ordinal;
let C109 being (TermOrder of C108);
let C110 being (bag of C108);
L334: ( field C109 ) = ( Bags C108 ) by ORDERS_1:12;
L335: C109 is_reflexive_in ( Bags C108 ) by L334 , RELAT_2:def 9;
L336: C110 is (Element of ( Bags C108 )) by PRE_POLY:def 12;
L337: [ C110 , C110 ] in C109 by L336 , L335 , RELAT_2:def 1;
thus L338: thesis by L337 , L326;
end;
L339: (for B53 being Ordinal holds (for B54 being (TermOrder of B53) holds (for B55 , B56 being (bag of B53) holds ((B55 <= B56 , B54 & B56 <= B55 , B54) implies B55 = B56))))
proof
let C111 being Ordinal;
let C112 being (TermOrder of C111);
let C113 , C114 being (bag of C111);
L340: ( field C112 ) = ( Bags C111 ) by ORDERS_1:12;
L341: C112 is_antisymmetric_in ( Bags C111 ) by L340 , RELAT_2:def 12;
assume L342: (C113 <= C114 , C112 & C114 <= C113 , C112);
L343: ([ C113 , C114 ] in C112 & [ C114 , C113 ] in C112) by L342 , L326;
L344: (C113 is (Element of ( Bags C111 )) & C114 is (Element of ( Bags C111 ))) by PRE_POLY:def 12;
thus L345: thesis by L344 , L343 , L341 , RELAT_2:def 4;
end;
L346: (for B57 being Ordinal holds (for B58 being (TermOrder of B57) holds (for B59 being (bag of B57) holds B59 in ( field B58 ))))
proof
let C115 being Ordinal;
let C116 being (TermOrder of C115);
let C117 being (bag of C115);
L347: ( field C116 ) = ( Bags C115 ) by ORDERS_1:12;
L348: C116 is_reflexive_in ( Bags C115 ) by L347 , RELAT_2:def 9;
L349: C117 is (Element of ( Bags C115 )) by PRE_POLY:def 12;
L350: [ C117 , C117 ] in C116 by L349 , L348 , RELAT_2:def 1;
thus L351: thesis by L350 , RELAT_1:15;
end;
theorem
L352: (for B60 being Ordinal holds (for B61 being  connected (TermOrder of B60) holds (for B62 , B63 being (bag of B60) holds (B62 <= B63 , B61 iff (not B63 < B62 , B61)))))
proof
let C118 being Ordinal;
let C119 being  connected (TermOrder of C118);
let C120 , C121 being (bag of C118);
L353: C119 is_connected_in ( field C119 ) by RELAT_2:def 14;
per cases ;
suppose L354: C120 = C121;

thus L355: thesis by L354 , L328 , L333;
end;
suppose L356: C120 <> C121;

L357: ((not C121 < C120 , C119) implies C120 <= C121 , C119)
proof
assume L358: (not C121 < C120 , C119);
L359:
now
per cases  by L358 , L328;
case L360: (not C121 <= C120 , C119);
L361: (C120 in ( field C119 ) & C121 in ( field C119 )) by L346;
L362: (not [ C121 , C120 ] in C119) by L360 , L326;
L363: [ C120 , C121 ] in C119 by L362 , L353 , L356 , L361 , RELAT_2:def 6;
thus L364: thesis by L363 , L326;
end;
case L365: C120 = C121;
thus L366: thesis by L365 , L356;
end;
end;
thus L368: thesis by L359;
end;
L369: (C120 <= C121 , C119 implies (not C121 < C120 , C119))
proof
assume L370: C120 <= C121 , C119;
assume L371: C121 < C120 , C119;
L372: (C121 <= C120 , C119 & C120 <> C121) by L371 , L328;
thus L373: thesis by L372 , L370 , L339;
end;
thus L374: thesis by L369 , L357;
end;
end;
L376: (for B64 being Ordinal holds (for B65 being  connected (TermOrder of B64) holds (for B66 , B67 being (bag of B64) holds (B66 <= B67 , B65 or B67 <= B66 , B65))))
proof
let C122 being Ordinal;
let C123 being  connected (TermOrder of C122);
let C124 , C125 being (bag of C122);
L377: C123 is_connected_in ( field C123 ) by RELAT_2:def 14;
per cases ;
suppose L378: C124 = C125;

L379: ( field C123 ) = ( Bags C122 ) by ORDERS_1:12;
L380: C123 is_reflexive_in ( Bags C122 ) by L379 , RELAT_2:def 9;
L381: C124 is (Element of ( Bags C122 )) by PRE_POLY:def 12;
L382: [ C124 , C125 ] in C123 by L381 , L378 , L380 , RELAT_2:def 1;
thus L383: thesis by L382 , L326;
end;
suppose L384: C124 <> C125;

assume L385: (not C124 <= C125 , C123);
L386: (not [ C124 , C125 ] in C123) by L385 , L326;
L387: (C124 in ( field C123 ) & C125 in ( field C123 )) by L346;
L388: [ C125 , C124 ] in C123 by L387 , L377 , L384 , L386 , RELAT_2:def 6;
thus L389: thesis by L388 , L326;
end;
end;
theorem
L391: (for B68 being Ordinal holds (for B69 being (TermOrder of B68) holds (for B70 being (bag of B68) holds B70 <= B70 , B69))) by L333;
theorem
L392: (for B71 being Ordinal holds (for B72 being (TermOrder of B71) holds (for B73 , B74 being (bag of B71) holds ((B73 <= B74 , B72 & B74 <= B73 , B72) implies B73 = B74)))) by L339;
theorem
L393: (for B75 being Ordinal holds (for B76 being (TermOrder of B75) holds (for B77 , B78 , B79 being (bag of B75) holds ((B77 <= B78 , B76 & B78 <= B79 , B76) implies B77 <= B79 , B76))))
proof
let C126 being Ordinal;
let C127 being (TermOrder of C126);
let C128 , C129 , C130 being (bag of C126);
L394: C130 is (Element of ( Bags C126 )) by PRE_POLY:def 12;
L395: ( field C127 ) = ( Bags C126 ) by ORDERS_1:12;
L396: C127 is_transitive_in ( Bags C126 ) by L395 , RELAT_2:def 16;
assume L397: (C128 <= C129 , C127 & C129 <= C130 , C127);
L398: ([ C128 , C129 ] in C127 & [ C129 , C130 ] in C127) by L397 , L326;
L399: (C128 is (Element of ( Bags C126 )) & C129 is (Element of ( Bags C126 ))) by PRE_POLY:def 12;
L400: [ C128 , C130 ] in C127 by L399 , L398 , L396 , L394 , RELAT_2:def 8;
thus L401: thesis by L400 , L326;
end;
theorem
L402: (for B80 being Ordinal holds (for B81 being  admissible (TermOrder of B80) holds (for B82 being (bag of B80) holds ( EmptyBag B80 ) <= B82 , B81)))
proof
let C131 being Ordinal;
let C132 being  admissible (TermOrder of C131);
let C133 being (bag of C131);
L403: [ ( EmptyBag C131 ) , C133 ] in C132 by BAGORDER:def 5;
thus L404: thesis by L403 , L326;
end;
theorem
L405: (for B83 being Ordinal holds (for B84 being  admissible (TermOrder of B83) holds (for B85 , B86 being (bag of B83) holds (B85 divides B86 implies B85 <= B86 , B84))))
proof
let C134 being Ordinal;
let C135 being  admissible (TermOrder of C134);
let C136 , C137 being (bag of C134);
assume L406: C136 divides C137;
consider C138 being (bag of C134) such that L407: C137 = ( C136 + C138 ) by L406 , L6;
L408: ( EmptyBag C134 ) <= C138 , C135 by L402;
L409: [ ( EmptyBag C134 ) , C138 ] in C135 by L408 , L326;
L410: [ ( ( EmptyBag C134 ) + C136 ) , C137 ] in C135 by L409 , L407 , BAGORDER:def 5;
L411: [ C136 , C137 ] in C135 by L410 , PRE_POLY:53;
thus L412: thesis by L411 , L326;
end;
theorem
L413: (for B87 being Ordinal holds (for B88 being (TermOrder of B87) holds (for B89 , B90 being (bag of B87) holds (( min (B89 , B90 , B88) ) = B89 or ( min (B89 , B90 , B88) ) = B90))))
proof
let C139 being Ordinal;
let C140 being (TermOrder of C139);
let C141 , C142 being (bag of C139);
assume L414: ( min (C141 , C142 , C140) ) <> C141;
L415:
now
per cases  by L414 , L330;
case L416: (not C141 <= C142 , C140);
thus L417: thesis by L416 , L330;
end;
case L418: C141 = C142;
L419: C141 <= C142 , C140 by L418 , L333;
thus L420: contradiction by L419 , L414 , L330;
end;
end;
thus L422: thesis by L415;
end;
theorem
L423: (for B91 being Ordinal holds (for B92 being (TermOrder of B91) holds (for B93 , B94 being (bag of B91) holds (( max (B93 , B94 , B92) ) = B93 or ( max (B93 , B94 , B92) ) = B94))))
proof
let C143 being Ordinal;
let C144 being (TermOrder of C143);
let C145 , C146 being (bag of C143);
assume L424: ( max (C145 , C146 , C144) ) <> C145;
L425:
now
per cases  by L424 , L331;
case L426: (not C146 <= C145 , C144);
thus L427: thesis by L426 , L331;
end;
case L428: C145 = C146;
L429: C146 <= C145 , C144 by L428 , L333;
thus L430: contradiction by L429 , L424 , L331;
end;
end;
thus L432: thesis by L425;
end;
L433: (for B95 being Ordinal holds (for B96 being (TermOrder of B95) holds (for B97 being (bag of B95) holds (( min (B97 , B97 , B96) ) = B97 & ( max (B97 , B97 , B96) ) = B97))))
proof
let C147 being Ordinal;
let C148 being (TermOrder of C147);
let C149 being (bag of C147);
thus L434: ( min (C149 , C149 , C148) ) = C149 by L330;
thus L435: thesis by L331;
end;
theorem
L436: (for B98 being Ordinal holds (for B99 being  connected (TermOrder of B98) holds (for B100 , B101 being (bag of B98) holds (( min (B100 , B101 , B99) ) <= B100 , B99 & ( min (B100 , B101 , B99) ) <= B101 , B99))))
proof
let C150 being Ordinal;
let C151 being  connected (TermOrder of C150);
let C152 , C153 being (bag of C150);
per cases  by L376;
suppose L437: C152 <= C153 , C151;

L438: ( min (C152 , C153 , C151) ) = C152 by L437 , L330;
thus L439: thesis by L438 , L437 , L333;
end;
suppose L440: C153 <= C152 , C151;

L441:
now
per cases ;
case L442: C152 = C153;
L443: ( min (C152 , C153 , C151) ) = C152 by L442 , L433;
thus L444: thesis by L443 , L442 , L333;
end;
case L445: C152 <> C153;
L446: C153 < C152 , C151 by L445 , L440 , L328;
L447: (not C152 <= C153 , C151) by L446 , L352;
L448: ( min (C152 , C153 , C151) ) = C153 by L447 , L330;
thus L449: thesis by L448 , L440 , L333;
end;
end;
thus L451: thesis by L441;
end;
end;
theorem
L453: (for B102 being Ordinal holds (for B103 being  connected (TermOrder of B102) holds (for B104 , B105 being (bag of B102) holds (B104 <= ( max (B104 , B105 , B103) ) , B103 & B105 <= ( max (B104 , B105 , B103) ) , B103))))
proof
let C154 being Ordinal;
let C155 being  connected (TermOrder of C154);
let C156 , C157 being (bag of C154);
per cases  by L376;
suppose L454: C157 <= C156 , C155;

L455: ( max (C156 , C157 , C155) ) = C156 by L454 , L331;
thus L456: thesis by L455 , L454 , L333;
end;
suppose L457: C156 <= C157 , C155;

L458:
now
per cases ;
case L459: C156 = C157;
L460: ( max (C156 , C157 , C155) ) = C156 by L459 , L433;
thus L461: thesis by L460 , L459 , L333;
end;
case L462: C156 <> C157;
L463: C156 < C157 , C155 by L462 , L457 , L328;
L464: (not C157 <= C156 , C155) by L463 , L352;
L465: ( max (C156 , C157 , C155) ) = C157 by L464 , L331;
thus L466: thesis by L465 , L457 , L333;
end;
end;
thus L468: thesis by L458;
end;
end;
theorem
L470: (for B106 being Ordinal holds (for B107 being  connected (TermOrder of B106) holds (for B108 , B109 being (bag of B106) holds (( min (B108 , B109 , B107) ) = ( min (B109 , B108 , B107) ) & ( max (B108 , B109 , B107) ) = ( max (B109 , B108 , B107) )))))
proof
let C158 being Ordinal;
let C159 being  connected (TermOrder of C158);
let C160 , C161 being (bag of C158);
L471:
now
per cases ;
case L472: ( min (C160 , C161 , C159) ) = C160;
L473:
now
per cases  by L472 , L330;
case L474: C160 <= C161 , C159;
L475:
now
per cases ;
case L476: C160 = C161;
thus L477: ( min (C161 , C160 , C159) ) = ( min (C160 , C161 , C159) ) by L476;
end;
case L478: C160 <> C161;
L479: (not C161 <= C160 , C159) by L478 , L474 , L339;
thus L480: ( min (C161 , C160 , C159) ) = ( min (C160 , C161 , C159) ) by L479 , L472 , L330;
end;
end;
thus L482: ( min (C160 , C161 , C159) ) = ( min (C161 , C160 , C159) ) by L475;
end;
case L483: C160 = C161;
thus L484: ( min (C161 , C160 , C159) ) = ( min (C160 , C161 , C159) ) by L483;
end;
end;
thus L486: ( min (C160 , C161 , C159) ) = ( min (C161 , C160 , C159) ) by L473;
end;
case L487: ( min (C160 , C161 , C159) ) <> C160;
L488:
now
assume L489: (not C161 <= C160 , C159);
L490: C160 <= C161 , C159 by L489 , L376;
thus L491: contradiction by L490 , L487 , L330;
end;
thus L492: ( min (C160 , C161 , C159) ) = C161 by L487 , L413
.= ( min (C161 , C160 , C159) ) by L488 , L330;
end;
end;
thus L494: ( min (C160 , C161 , C159) ) = ( min (C161 , C160 , C159) ) by L471;
L495:
now
per cases ;
case L496: ( max (C160 , C161 , C159) ) = C160;
L497:
now
per cases  by L496 , L331;
case L498: C161 <= C160 , C159;
L499:
now
per cases ;
case L500: C160 = C161;
thus L501: ( max (C161 , C160 , C159) ) = ( max (C160 , C161 , C159) ) by L500;
end;
case L502: C160 <> C161;
L503: (not C160 <= C161 , C159) by L502 , L498 , L339;
thus L504: ( max (C161 , C160 , C159) ) = ( max (C160 , C161 , C159) ) by L503 , L496 , L331;
end;
end;
thus L506: thesis by L499;
end;
case L507: C160 = C161;
thus L508: ( max (C161 , C160 , C159) ) = ( max (C160 , C161 , C159) ) by L507;
end;
end;
thus L510: thesis by L497;
end;
case L511: ( max (C160 , C161 , C159) ) <> C160;
L512:
now
per cases  by L376;
case L513: C160 <= C161 , C159;
thus L514: ( max (C161 , C160 , C159) ) = C161 by L513 , L331
.= ( max (C160 , C161 , C159) ) by L511 , L423;
end;
case L515: C161 <= C160 , C159;
thus L516: ( max (C161 , C160 , C159) ) = ( max (C160 , C161 , C159) ) by L515 , L511 , L331;
end;
end;
thus L518: ( max (C161 , C160 , C159) ) = ( max (C160 , C161 , C159) ) by L512;
end;
end;
thus L520: thesis by L495;
end;
theorem
L521: (for B110 being Ordinal holds (for B111 being  connected (TermOrder of B110) holds (for B112 , B113 being (bag of B110) holds (( min (B112 , B113 , B111) ) = B112 iff ( max (B112 , B113 , B111) ) = B113))))
proof
let C162 being Ordinal;
let C163 being  connected (TermOrder of C162);
let C164 , C165 being (bag of C162);
L522:
now
assume L523: ( max (C164 , C165 , C163) ) = C165;
L524:
now
per cases  by L523 , L331;
case L525: (not C165 <= C164 , C163);
L526: C164 <= C165 , C163 by L525 , L376;
thus L527: ( min (C164 , C165 , C163) ) = C164 by L526 , L330;
end;
case L528: C164 = C165;
thus L529: ( min (C164 , C165 , C163) ) = C164 by L528 , L413;
end;
end;
thus L531: ( min (C164 , C165 , C163) ) = C164 by L524;
end;
L532:
now
assume L533: ( min (C164 , C165 , C163) ) = C164;
L534:
now
per cases  by L533 , L330;
case L535: C164 <= C165 , C163;
L536: ( max (C165 , C164 , C163) ) = C165 by L535 , L331;
thus L537: ( max (C164 , C165 , C163) ) = C165 by L536 , L470;
end;
case L538: C164 = C165;
thus L539: ( max (C164 , C165 , C163) ) = C165 by L538 , L423;
end;
end;
thus L541: ( max (C164 , C165 , C163) ) = C165 by L534;
end;
thus L542: thesis by L532 , L522;
end;
begin
definition
let C166 being Ordinal;
let C167 being  connected (TermOrder of C166);
let C168 being non  empty ZeroStr;
let C169 being (Polynomial of C166 , C168);
func HT (C169 , C167) -> (Element of ( Bags C166 )) means 
:L543: ((( Support C169 ) = ( {} ) & it = ( EmptyBag C166 )) or (it in ( Support C169 ) & (for B114 being (bag of C166) holds (B114 in ( Support C169 ) implies B114 <= it , C167))));
existence
proof
set D24 = C167;
per cases ;
suppose L544: ( Support C169 ) = ( {} );

thus L545: thesis by L544;
end;
suppose L546: ( Support C169 ) <> ( {} );

reconsider D25 = ( Support C169 ) as  finite set by POLYNOM1:def 4;
L547: ( card D25 ) is  finite;
consider C170 being Nat such that L548: ( card ( Support C169 ) ) = ( card C170 ) by L547 , CARD_1:48;
reconsider D26 = ( Support C169 ) as  finite (Subset of ( Bags C166 )) by POLYNOM1:def 4;
defpred S1[ Nat ] means (for B115 being  finite (Subset of ( Bags C166 )) holds (( card B115 ) = $1 implies (ex B116 being (bag of C166) st (B116 in B115 & (for B117 being (bag of C166) holds (B117 in B115 implies [ B117 , B116 ] in D24))))));
L549: (for B118 being Nat holds (1 <= B118 implies (S1[ B118 ] implies S1[ ( B118 + 1 ) ])))
proof
let C171 being Nat;
assume L550: 1 <= C171;
thus L551: (S1[ C171 ] implies S1[ ( C171 + 1 ) ])
proof
assume L552: S1[ C171 ];
thus L553: S1[ ( C171 + 1 ) ]
proof
let C172 being  finite (Subset of ( Bags C166 ));
assume L554: ( card C172 ) = ( C171 + 1 );
reconsider D27 = C172 as non  empty  finite (Subset of ( Bags C166 )) by L554;
set D28 = the (Element of D27);
reconsider D29 = D28 as (Element of ( Bags C166 ));
reconsider D30 = D29 as (bag of C166);
set D31 = ( D27 \ { D30 } );
L555:
now
let C173 being set;
assume L556: C173 in { D30 };
L557: C173 = D30 by L556 , TARSKI:def 1;
thus L558: C173 in D27 by L557;
end;
L559: { D30 } c= D27 by L555 , TARSKI:def 3;
L560: D27 = ( { D30 } \/ D27 ) by L559 , XBOOLE_1:12
.= ( { D30 } \/ D31 ) by XBOOLE_1:39;
L561: (D30 in D31 iff (D30 in D27 & (not D30 in { D30 }))) by XBOOLE_0:def 5;
L562: ( ( card D31 ) + 1 ) = ( C171 + 1 ) by L561 , L554 , L560 , CARD_2:41 , TARSKI:def 1;
reconsider D32 = D31 as non  empty set by L562 , L550;
consider C174 being (bag of C166) such that L563: C174 in D32 and L564: (for B119 being (bag of C166) holds (B119 in D32 implies [ B119 , C174 ] in D24)) by L552 , L562;
L565: D24 is_connected_in ( field D24 ) by RELAT_2:def 14;
L566:
now
per cases ;
case L567: D30 = C174;
L568:
now
let C175 being (bag of C166);
assume L569: C175 in D27;
L570:
now
per cases ;
case L571: C175 in D32;
thus L572: [ C175 , C174 ] in D24 by L571 , L564;
end;
case L573: (not C175 in D32);
L574: C175 in { D30 } by L573 , L560 , L569 , XBOOLE_0:def 3;
L575: C175 = D30 by L574 , TARSKI:def 1;
thus L576: [ C175 , C174 ] in D24 by L575 , L567 , ORDERS_1:3;
end;
end;
thus L578: [ C175 , C174 ] in D24 by L570;
end;
take D33 = C174;
L579: D32 c= D27 by XBOOLE_1:36;
thus L580: thesis by L579 , L563 , L568;
end;
case L581: D30 <> C174;
L582: C174 is (Element of ( Bags C166 )) by PRE_POLY:def 12;
L583: [ C174 , C174 ] in D24 by L582 , ORDERS_1:3;
L584: C174 in ( field D24 ) by L583 , RELAT_1:15;
L585: [ D30 , D30 ] in D24 by ORDERS_1:3;
L586: D30 in ( field D24 ) by L585 , RELAT_1:15;
L587:
now
per cases  by L565 , L581 , L586 , L584 , RELAT_2:def 6;
case L588: [ D30 , C174 ] in D24;
thus L589: (ex B120 being (bag of C166) st (B120 in D27 & (for B121 being (bag of C166) holds (B121 in D27 implies [ B121 , B120 ] in D24))))
proof
take C174;
L590: (for B122 being (bag of C166) holds (B122 in D27 implies [ B122 , C174 ] in D24))
proof
let C176 being (bag of C166);
assume L591: C176 in D27;
L592:
now
per cases ;
case L593: C176 <> D30;
L594: (not C176 in { D30 }) by L593 , TARSKI:def 1;
L595: C176 in D32 by L594 , L591 , XBOOLE_0:def 5;
thus L596: thesis by L595 , L564;
end;
case L597: C176 = D30;
thus L598: thesis by L597 , L588;
end;
end;
thus L600: thesis by L592;
end;
thus L601: thesis by L590 , L563 , XBOOLE_0:def 5;
end;

end;
case L590: [ C174 , D30 ] in D24;
thus L591: (ex B123 being (bag of C166) st (B123 in D27 & (for B124 being (bag of C166) holds (B124 in D27 implies [ B124 , B123 ] in D24))))
proof
take D30;
L592: (for B125 being (bag of C166) holds (B125 in D27 implies [ B125 , D30 ] in D24))
proof
let C177 being (bag of C166);
assume L593: C177 in D27;
L594:
now
per cases ;
case L595: C177 <> D30;
L596: (not C177 in { D30 }) by L595 , TARSKI:def 1;
L597: C177 in D32 by L596 , L593 , XBOOLE_0:def 5;
L598: [ C177 , C174 ] in D24 by L597 , L564;
L599: (C177 is (Element of ( Bags C166 )) & C174 is (Element of ( Bags C166 ))) by PRE_POLY:def 12;
thus L600: thesis by L599 , L590 , L598 , ORDERS_1:5;
end;
case L601: C177 = D30;
thus L602: thesis by L601 , ORDERS_1:3;
end;
end;
thus L604: thesis by L594;
end;
thus L605: thesis by L592;
end;

end;
end;
thus L593: thesis by L587;
end;
end;
thus L595: thesis by L566;
end;

end;

end;
L552: C170 <> ( 0 ) by L546 , L548;
L553: 1 <= C170 by L552 , NAT_1:14;
L554: ( card ( Support C169 ) ) = C170 by L548 , CARD_1:def 2;
L555: S1[ 1 ]
proof
let C178 being  finite (Subset of ( Bags C166 ));
assume L556: ( card C178 ) = 1;
L557: ( card { ( {} ) } ) = ( card C178 ) by L556 , CARD_1:30;
consider C179 being set such that L558: C178 = { C179 } by L557 , CARD_1:29;
L559: C179 in C178 by L558 , TARSKI:def 1;
reconsider D34 = C179 as (Element of ( Bags C166 )) by L559;
reconsider D35 = D34 as (bag of C166);
L560:
now
let C180 being (bag of C166);
assume L561: C180 in C178;
L562: C180 = D35 by L561 , L558 , TARSKI:def 1;
thus L563: [ C180 , D35 ] in D24 by L562 , ORDERS_1:3;
end;
thus L564: thesis by L560 , L559;
end;
L565: (for B126 being Nat holds (1 <= B126 implies S1[ B126 ])) from NAT_1:sch 8(L555 , L549);
consider C181 being (bag of C166) such that L566: C181 in D26 and L567: (for B127 being (bag of C166) holds (B127 in D26 implies [ B127 , C181 ] in D24)) by L565 , L554 , L553;
take C181;
L568:
now
let C182 being (bag of C166);
assume L569: C182 in D26;
L570: [ C182 , C181 ] in D24 by L569 , L567;
thus L571: C182 <= C181 , D24 by L570 , L326;
end;
thus L572: thesis by L568 , L566;
end;
end;
uniqueness
proof
let C183 , C184 being (Element of ( Bags C166 ));
set D36 = C167;
assume L574: ((( Support C169 ) = ( {} ) & C183 = ( EmptyBag C166 )) or (C183 in ( Support C169 ) & (for B128 being (bag of C166) holds (B128 in ( Support C169 ) implies B128 <= C183 , D36))));
assume L575: ((( Support C169 ) = ( {} ) & C184 = ( EmptyBag C166 )) or (C184 in ( Support C169 ) & (for B129 being (bag of C166) holds (B129 in ( Support C169 ) implies B129 <= C184 , D36))));
per cases ;
suppose L576: ( Support C169 ) = ( {} );

thus L577: C183 = C184 by L576 , L574 , L575;
end;
suppose L578: ( Support C169 ) <> ( {} );

L579: C183 <= C184 , D36 by L578 , L574 , L575;
L580: [ C183 , C184 ] in D36 by L579 , L326;
L581: C184 <= C183 , D36 by L574 , L575 , L578;
L582: [ C184 , C183 ] in D36 by L581 , L326;
thus L583: C183 = C184 by L582 , L580 , ORDERS_1:4;
end;
end;
end;
definition
let C185 being Ordinal;
let C186 being  connected (TermOrder of C185);
let C187 being non  empty ZeroStr;
let C188 being (Polynomial of C185 , C187);
func HC (C188 , C186) -> (Element of C187) equals 
( C188 . ( HT (C188 , C186) ) );
correctness;
end;
definition
let C189 being Ordinal;
let C190 being  connected (TermOrder of C189);
let C191 being non  empty ZeroStr;
let C192 being (Polynomial of C189 , C191);
func HM (C192 , C190) -> (Monomial of C189 , C191) equals 
( Monom (( HC (C192 , C190) ) , ( HT (C192 , C190) )) );
correctness;
end;
L588: (for B130 being Ordinal holds (for B131 being  connected (TermOrder of B130) holds (for B132 being non  empty ZeroStr holds (for B133 being (Polynomial of B130 , B132) holds (( HC (B133 , B131) ) = ( 0. B132 ) iff B133 = ( 0_ (B130 , B132) ))))))
proof
let C193 being Ordinal;
let C194 being  connected (TermOrder of C193);
let C195 being non  empty ZeroStr;
let C196 being (Polynomial of C193 , C195);
L589:
now
assume L590: ( HC (C196 , C194) ) = ( 0. C195 );
L591: (not ( HT (C196 , C194) ) in ( Support C196 )) by L590 , POLYNOM1:def 3;
L592: ( Support C196 ) = ( {} ) by L591 , L543;
thus L593: C196 = ( 0_ (C193 , C195) ) by L592 , POLYNOM7:1;
end;
thus L594: thesis by L589 , POLYNOM1:22;
end;
L595: (for B134 being Ordinal holds (for B135 being  connected (TermOrder of B134) holds (for B136 being non  trivial ZeroStr holds (for B137 being (Polynomial of B134 , B136) holds ( ( HM (B137 , B135) ) . ( HT (B137 , B135) ) ) = ( B137 . ( HT (B137 , B135) ) )))))
proof
let C197 being Ordinal;
let C198 being  connected (TermOrder of C197);
let C199 being non  trivial ZeroStr;
let C200 being (Polynomial of C197 , C199);
L596:
now
per cases ;
case L597: ( HC (C200 , C198) ) <> ( 0. C199 );
L598: ( HC (C200 , C198) ) is non  zero by L597 , STRUCT_0:def 12;
thus L599: ( term ( HM (C200 , C198) ) ) = ( HT (C200 , C198) ) by L598 , POLYNOM7:10;
end;
case L600: ( HC (C200 , C198) ) = ( 0. C199 );
L601: C200 = ( 0_ (C197 , C199) ) by L600 , L588;
L602: ( Support C200 ) = ( {} ) by L601 , POLYNOM7:1;
L603: ( HT (C200 , C198) ) = ( EmptyBag C197 ) by L602 , L543;
thus L604: ( term ( HM (C200 , C198) ) ) = ( HT (C200 , C198) ) by L603 , L600 , POLYNOM7:8;
end;
end;
L606: ( C200 . ( HT (C200 , C198) ) ) = ( coefficient ( HM (C200 , C198) ) ) by POLYNOM7:9
.= ( ( HM (C200 , C198) ) . ( term ( HM (C200 , C198) ) ) ) by POLYNOM7:def 6;
thus L607: thesis by L606 , L596;
end;
L608: (for B138 being Ordinal holds (for B139 being  connected (TermOrder of B138) holds (for B140 being non  trivial ZeroStr holds (for B141 being (Polynomial of B138 , B140) holds (( HC (B141 , B139) ) <> ( 0. B140 ) implies ( HT (B141 , B139) ) in ( Support ( HM (B141 , B139) ) ))))))
proof
let C201 being Ordinal;
let C202 being  connected (TermOrder of C201);
let C203 being non  trivial ZeroStr;
let C204 being (Polynomial of C201 , C203);
assume L609: ( HC (C204 , C202) ) <> ( 0. C203 );
L610: ( ( HM (C204 , C202) ) . ( HT (C204 , C202) ) ) <> ( 0. C203 ) by L609 , L595;
thus L611: thesis by L610 , POLYNOM1:def 3;
end;
L612: (for B142 being Ordinal holds (for B143 being  connected (TermOrder of B142) holds (for B144 being non  trivial ZeroStr holds (for B145 being (Polynomial of B142 , B144) holds (( HC (B145 , B143) ) = ( 0. B144 ) implies ( Support ( HM (B145 , B143) ) ) = ( {} ))))))
proof
let C205 being Ordinal;
let C206 being  connected (TermOrder of C205);
let C207 being non  trivial ZeroStr;
let C208 being (Polynomial of C205 , C207);
assume L613: ( HC (C208 , C206) ) = ( 0. C207 );
L614: C208 = ( 0_ (C205 , C207) ) by L613 , L588;
L615: ( Support C208 ) = ( {} ) by L614 , POLYNOM7:1;
L616: ( HT (C208 , C206) ) = ( EmptyBag C205 ) by L615 , L543;
L617: ( term ( HM (C208 , C206) ) ) = ( EmptyBag C205 ) by L613 , POLYNOM7:8;
L618:
now
assume L619: ( Support ( HM (C208 , C206) ) ) <> ( {} );
L620: ( Support ( HM (C208 , C206) ) ) = { ( term ( HM (C208 , C206) ) ) } by L619 , POLYNOM7:7;
L621: ( term ( HM (C208 , C206) ) ) in ( Support ( HM (C208 , C206) ) ) by L620 , TARSKI:def 1;
L622: ( ( HM (C208 , C206) ) . ( EmptyBag C205 ) ) <> ( 0. C207 ) by L621 , L617 , POLYNOM1:def 3;
thus L623: contradiction by L622 , L613 , L616 , L595;
end;
thus L624: thesis by L618;
end;
registration
let C209 being Ordinal;
let C210 being  connected (TermOrder of C209);
let C211 being non  trivial ZeroStr;
let C212 being  non-zero (Polynomial of C209 , C211);
cluster ( HM (C212 , C210) ) ->  non-zero;
coherence
proof
set D37 = C210;
L625:
now
per cases ;
case L626: ( HC (C212 , D37) ) <> ( 0. C211 );
L627: ( HT (C212 , D37) ) in ( Support ( HM (C212 , D37) ) ) by L626 , L608;
L628: ( HM (C212 , D37) ) <> ( 0_ (C209 , C211) ) by L627 , POLYNOM7:1;
thus L629: thesis by L628 , POLYNOM7:def 1;
end;
case L630: ( HC (C212 , D37) ) = ( 0. C211 );
L631: C212 = ( 0_ (C209 , C211) ) by L630 , L588;
thus L632: thesis by L631 , POLYNOM7:def 1;
end;
end;
thus L634: thesis by L625;
end;
cluster ( HC (C212 , C210) ) -> non  zero;
coherence
proof
set D38 = C210;
set D39 = ( HC (C212 , D38) );
L635:
now
assume L636: D39 = ( 0. C211 );
L637: (not ( HT (C212 , D38) ) in ( Support C212 )) by L636 , POLYNOM1:def 3;
L638: ( Support C212 ) = ( {} ) by L637 , L543;
L639: C212 = ( 0_ (C209 , C211) ) by L638 , POLYNOM7:1;
thus L640: contradiction by L639 , POLYNOM7:def 1;
end;
thus L641: thesis by L635 , STRUCT_0:def 12;
end;
end;
L643: (for B146 being Ordinal holds (for B147 being  connected (TermOrder of B146) holds (for B148 being non  empty ZeroStr holds (for B149 being (Monomial of B146 , B148) holds (( HT (B149 , B147) ) = ( term B149 ) & ( HC (B149 , B147) ) = ( coefficient B149 ) & ( HM (B149 , B147) ) = B149)))))
proof
let C213 being Ordinal;
let C214 being  connected (TermOrder of C213);
let C215 being non  empty ZeroStr;
let C216 being (Monomial of C213 , C215);
per cases  by POLYNOM7:6;
suppose L644: ( Support C216 ) = ( {} );

thus L645: ( term C216 ) = ( EmptyBag C213 ) by L644 , POLYNOM7:def 5
.= ( HT (C216 , C214) ) by L644 , L543;
thus L646: ( HC (C216 , C214) ) = ( coefficient C216 ) by L645 , POLYNOM7:def 6;
thus L647: thesis by L646 , L645 , POLYNOM7:11;
end;
suppose L648: (ex B150 being (bag of C213) st ( Support C216 ) = { B150 });

consider C217 being (bag of C213) such that L649: ( Support C216 ) = { C217 } by L648;
L650: C217 in ( Support C216 ) by L649 , TARSKI:def 1;
L651: ( C216 . C217 ) <> ( 0. C215 ) by L650 , POLYNOM1:def 3;
L652: ( HT (C216 , C214) ) in ( Support C216 ) by L648 , L543;
thus L653: ( HT (C216 , C214) ) = C217 by L652 , L649 , TARSKI:def 1
.= ( term C216 ) by L651 , POLYNOM7:def 5;
thus L654: ( HC (C216 , C214) ) = ( coefficient C216 ) by L653 , POLYNOM7:def 6;
thus L655: thesis by L654 , L653 , POLYNOM7:11;
end;
end;
theorem
L657: (for B151 being Ordinal holds (for B152 being  connected (TermOrder of B151) holds (for B153 being non  empty ZeroStr holds (for B154 being (Polynomial of B151 , B153) holds (( HC (B154 , B152) ) = ( 0. B153 ) iff B154 = ( 0_ (B151 , B153) )))))) by L588;
theorem
L658: (for B155 being Ordinal holds (for B156 being  connected (TermOrder of B155) holds (for B157 being non  trivial ZeroStr holds (for B158 being (Polynomial of B155 , B157) holds ( ( HM (B158 , B156) ) . ( HT (B158 , B156) ) ) = ( B158 . ( HT (B158 , B156) ) ))))) by L595;
theorem
L659: (for B159 being Ordinal holds (for B160 being  connected (TermOrder of B159) holds (for B161 being non  trivial ZeroStr holds (for B162 being (Polynomial of B159 , B161) holds (for B163 being (bag of B159) holds (B163 <> ( HT (B162 , B160) ) implies ( ( HM (B162 , B160) ) . B163 ) = ( 0. B161 )))))))
proof
let C218 being Ordinal;
let C219 being  connected (TermOrder of C218);
let C220 being non  trivial ZeroStr;
let C221 being (Polynomial of C218 , C220);
let C222 being (bag of C218);
assume L660: C222 <> ( HT (C221 , C219) );
per cases  by POLYNOM7:6;
suppose L661: ( Support ( HM (C221 , C219) ) ) = ( {} );

L662: ( HM (C221 , C219) ) = ( 0_ (C218 , C220) ) by L661 , POLYNOM7:1;
thus L663: thesis by L662 , POLYNOM1:22;
end;
suppose L664: (ex B164 being (bag of C218) st ( Support ( HM (C221 , C219) ) ) = { B164 });

consider C223 being (bag of C218) such that L665: ( Support ( HM (C221 , C219) ) ) = { C223 } by L664;
L666: C222 is (Element of ( Bags C218 )) by PRE_POLY:def 12;
L667:
now
per cases ;
case L668: ( HC (C221 , C219) ) <> ( 0. C220 );
L669: ( HT (C221 , C219) ) in { C223 } by L668 , L665 , L608;
L670: C223 <> C222 by L669 , L660 , TARSKI:def 1;
L671: (not C222 in { C223 }) by L670 , TARSKI:def 1;
thus L672: thesis by L671 , L665 , L666 , POLYNOM1:def 3;
end;
case L673: ( HC (C221 , C219) ) = ( 0. C220 );
L674: ( Support ( HM (C221 , C219) ) ) = ( {} ) by L673 , L612;
L675: ( HM (C221 , C219) ) = ( 0_ (C218 , C220) ) by L674 , POLYNOM7:1;
thus L676: thesis by L675 , POLYNOM1:22;
end;
end;
thus L678: thesis by L667;
end;
end;
L680: (for B165 being Ordinal holds (for B166 being  connected (TermOrder of B165) holds (for B167 being non  trivial ZeroStr holds (for B168 being (Polynomial of B165 , B167) holds (( Support ( HM (B168 , B166) ) ) = ( {} ) or ( Support ( HM (B168 , B166) ) ) = { ( HT (B168 , B166) ) })))))
proof
let C224 being Ordinal;
let C225 being  connected (TermOrder of C224);
let C226 being non  trivial ZeroStr;
let C227 being (Polynomial of C224 , C226);
assume L681: (not ( Support ( HM (C227 , C225) ) ) = ( {} ));
L682: (ex B169 being (bag of C224) st ( Support ( HM (C227 , C225) ) ) = { B169 }) by L681 , POLYNOM7:6;
L683:
now
per cases ;
case L684: ( HC (C227 , C225) ) = ( 0. C226 );
thus L685: thesis by L684 , L681 , L612;
end;
case L686: ( HC (C227 , C225) ) <> ( 0. C226 );
L687: ( HT (C227 , C225) ) in ( Support ( HM (C227 , C225) ) ) by L686 , L608;
thus L688: thesis by L687 , L682 , TARSKI:def 1;
end;
end;
thus L690: thesis by L683;
end;
theorem
L691: (for B170 being Ordinal holds (for B171 being  connected (TermOrder of B170) holds (for B172 being non  trivial ZeroStr holds (for B173 being (Polynomial of B170 , B172) holds ( Support ( HM (B173 , B171) ) ) c= ( Support B173 )))))
proof
let C228 being Ordinal;
let C229 being  connected (TermOrder of C228);
let C230 being non  trivial ZeroStr;
let C231 being (Polynomial of C228 , C230);
L692:
now
let C232 being set;
assume L693: C232 in ( Support ( HM (C231 , C229) ) );
L694:
now
per cases  by L693 , L680;
case L695: C232 in ( {} );
thus L696: C232 in ( Support C231 ) by L695;
end;
case L697: C232 in { ( HT (C231 , C229) ) };
L698: C232 = ( HT (C231 , C229) ) by L697 , TARSKI:def 1;
L699:
now
per cases ;
case L700: ( HC (C231 , C229) ) = ( 0. C230 );
L701: ( ( HM (C231 , C229) ) . ( HT (C231 , C229) ) ) = ( 0. C230 ) by L700 , L595;
thus L702: contradiction by L701 , L693 , L698 , POLYNOM1:def 3;
end;
case L703: ( HC (C231 , C229) ) <> ( 0. C230 );
thus L704: C232 in ( Support C231 ) by L703 , L698 , POLYNOM1:def 3;
end;
end;
thus L706: C232 in ( Support C231 ) by L699;
end;
end;
thus L708: C232 in ( Support C231 ) by L694;
end;
thus L709: thesis by L692 , TARSKI:def 3;
end;
theorem
L710: (for B174 being Ordinal holds (for B175 being  connected (TermOrder of B174) holds (for B176 being non  trivial ZeroStr holds (for B177 being (Polynomial of B174 , B176) holds (( Support ( HM (B177 , B175) ) ) = ( {} ) or ( Support ( HM (B177 , B175) ) ) = { ( HT (B177 , B175) ) }))))) by L680;
theorem
L711: (for B178 being Ordinal holds (for B179 being  connected (TermOrder of B178) holds (for B180 being non  trivial ZeroStr holds (for B181 being (Polynomial of B178 , B180) holds (( term ( HM (B181 , B179) ) ) = ( HT (B181 , B179) ) & ( coefficient ( HM (B181 , B179) ) ) = ( HC (B181 , B179) ))))))
proof
let C233 being Ordinal;
let C234 being  connected (TermOrder of C233);
let C235 being non  trivial ZeroStr;
let C236 being (Polynomial of C233 , C235);
per cases ;
suppose L712: ( HC (C236 , C234) ) is non  zero;

reconsider D40 = ( HC (C236 , C234) ) as non  zero (Element of C235) by L712;
L713: ( term ( Monom (D40 , ( HT (C236 , C234) )) ) ) = ( HT (C236 , C234) ) by POLYNOM7:10;
thus L714: thesis by L713 , POLYNOM7:9;
end;
suppose L715: (not ( HC (C236 , C234) ) is non  zero);

L716:
now
per cases ;
case L717: (not C236 is  non-zero);
L718: C236 = ( 0_ (C233 , C235) ) by L717 , POLYNOM7:def 1;
L719: ( Support C236 ) = ( {} ) by L718 , POLYNOM7:1;
L720: ( HT (C236 , C234) ) = ( EmptyBag C233 ) by L719 , L543
.= ( term ( Monom (( 0. C235 ) , ( HT (C236 , C234) )) ) ) by POLYNOM7:8
.= ( term ( HM (C236 , C234) ) ) by L715 , STRUCT_0:def 12;
thus L721: thesis by L720 , POLYNOM7:9;
end;
case L722: C236 is  non-zero;
reconsider D41 = C236 as  non-zero (Polynomial of C233 , C235) by L722;
L723: ( HC (D41 , C234) ) is non  zero;
thus L724: thesis by L723 , L715;
end;
end;
thus L726: thesis by L716;
end;
end;
theorem
L728: (for B182 being Ordinal holds (for B183 being  connected (TermOrder of B182) holds (for B184 being non  empty ZeroStr holds (for B185 being (Monomial of B182 , B184) holds (( HT (B185 , B183) ) = ( term B185 ) & ( HC (B185 , B183) ) = ( coefficient B185 ) & ( HM (B185 , B183) ) = B185))))) by L643;
theorem
L729: (for B186 being Ordinal holds (for B187 being  connected (TermOrder of B186) holds (for B188 being non  empty ZeroStr holds (for B189 being (ConstPoly of B186 , B188) holds (( HT (B189 , B187) ) = ( EmptyBag B186 ) & ( HC (B189 , B187) ) = ( B189 . ( EmptyBag B186 ) ))))))
proof
let C237 being Ordinal;
let C238 being  connected (TermOrder of C237);
let C239 being non  empty ZeroStr;
let C240 being (ConstPoly of C237 , C239);
thus L730: ( HT (C240 , C238) ) = ( term C240 ) by L643
.= ( EmptyBag C237 ) by POLYNOM7:16;
thus L731: ( HC (C240 , C238) ) = ( coefficient C240 ) by L643
.= ( C240 . ( EmptyBag C237 ) ) by POLYNOM7:16;
end;
theorem
L732: (for B190 being Ordinal holds (for B191 being  connected (TermOrder of B190) holds (for B192 being non  empty ZeroStr holds (for B193 being (Element of B192) holds (( HT (( B193 | (B190 , B192) ) , B191) ) = ( EmptyBag B190 ) & ( HC (( B193 | (B190 , B192) ) , B191) ) = B193)))))
proof
let C241 being Ordinal;
let C242 being  connected (TermOrder of C241);
let C243 being non  empty ZeroStr;
let C244 being (Element of C243);
set D42 = ( C244 | (C241 , C243) );
thus L733: ( HT (D42 , C242) ) = ( term D42 ) by L643
.= ( EmptyBag C241 ) by POLYNOM7:23;
thus L734: ( HC (D42 , C242) ) = ( coefficient D42 ) by L643
.= C244 by POLYNOM7:23;
end;
theorem
L735: (for B194 being Ordinal holds (for B195 being  connected (TermOrder of B194) holds (for B196 being non  trivial ZeroStr holds (for B197 being (Polynomial of B194 , B196) holds ( HT (( HM (B197 , B195) ) , B195) ) = ( HT (B197 , B195) )))))
proof
let C245 being Ordinal;
let C246 being  connected (TermOrder of C245);
let C247 being non  trivial ZeroStr;
let C248 being (Polynomial of C245 , C247);
per cases ;
suppose L736: ( HC (C248 , C246) ) is non  zero;

reconsider D43 = ( HC (C248 , C246) ) as non  zero (Element of C247) by L736;
thus L737: ( HT (( HM (C248 , C246) ) , C246) ) = ( term ( Monom (D43 , ( HT (C248 , C246) )) ) ) by L643
.= ( HT (C248 , C246) ) by POLYNOM7:10;
end;
suppose L738: (not ( HC (C248 , C246) ) is non  zero);

L739:
now
per cases ;
case L740: (not C248 is  non-zero);
L741: C248 = ( 0_ (C245 , C247) ) by L740 , POLYNOM7:def 1;
L742: ( Support C248 ) = ( {} ) by L741 , POLYNOM7:1;
L743: ( HT (C248 , C246) ) = ( EmptyBag C245 ) by L742 , L543
.= ( term ( Monom (( 0. C247 ) , ( HT (C248 , C246) )) ) ) by POLYNOM7:8
.= ( term ( HM (C248 , C246) ) ) by L738 , STRUCT_0:def 12;
thus L744: thesis by L743 , L643;
end;
case L745: C248 is  non-zero;
reconsider D44 = C248 as  non-zero (Polynomial of C245 , C247) by L745;
L746: ( HC (D44 , C246) ) is non  zero;
thus L747: thesis by L746 , L738;
end;
end;
thus L749: thesis by L739;
end;
end;
theorem
L751: (for B198 being Ordinal holds (for B199 being  connected (TermOrder of B198) holds (for B200 being non  trivial ZeroStr holds (for B201 being (Polynomial of B198 , B200) holds ( HC (( HM (B201 , B199) ) , B199) ) = ( HC (B201 , B199) )))))
proof
let C249 being Ordinal;
let C250 being  connected (TermOrder of C249);
let C251 being non  trivial ZeroStr;
let C252 being (Polynomial of C249 , C251);
thus L752: ( HC (( HM (C252 , C250) ) , C250) ) = ( ( HM (C252 , C250) ) . ( HT (C252 , C250) ) ) by L735
.= ( HC (C252 , C250) ) by L595;
end;
theorem
L753: (for B202 being Ordinal holds (for B203 being  connected (TermOrder of B202) holds (for B204 being non  empty ZeroStr holds (for B205 being (Polynomial of B202 , B204) holds ( HM (( HM (B205 , B203) ) , B203) ) = ( HM (B205 , B203) ))))) by L643;
L754: (for B206 being set holds (for B207 being (Subset of B206) holds (for B208 being (Order of B206) holds (B208 is  being_linear-order implies B208 linearly_orders B207))))
proof
let C253 being set;
let C254 being (Subset of C253);
let C255 being (Order of C253);
L755: C254 c= C253;
L756: C254 c= ( field C255 ) by L755 , ORDERS_1:15;
assume L757: C255 is  being_linear-order;
thus L758: thesis by L757 , L756 , ORDERS_1:37 , ORDERS_1:38;
end;
L759: (for B209 being Ordinal holds (for B210 being  admissible  connected (TermOrder of B209) holds (for B211 being  add-associative  right_complementable  left_zeroed  right_zeroed  well-unital  distributive non  trivial doubleLoopStr holds (for B212 , B213 being  non-zero (Polynomial of B209 , B211) holds ( ( B212 *' B213 ) . ( ( HT (B212 , B210) ) + ( HT (B213 , B210) ) ) ) = ( ( B212 . ( HT (B212 , B210) ) ) * ( B213 . ( HT (B213 , B210) ) ) )))))
proof
let C256 being Ordinal;
let C257 being  admissible  connected (TermOrder of C256);
let C258 being  add-associative  right_complementable  right_zeroed  left_zeroed  well-unital  distributive non  trivial doubleLoopStr;
let C259 , C260 being  non-zero (Polynomial of C256 , C258);
set D45 = ( ( HT (C259 , C257) ) + ( HT (C260 , C257) ) );
consider C261 being (FinSequence of C258) such that L760: ( ( C259 *' C260 ) . D45 ) = ( Sum C261 ) and L761: ( len C261 ) = ( len ( decomp D45 ) ) and L762: (for B214 being (Element of ( NAT )) holds (B214 in ( dom C261 ) implies (ex B215 , B216 being (bag of C256) st (( ( decomp D45 ) /. B214 ) = <* B215 , B216 *> & ( C261 /. B214 ) = ( ( C259 . B215 ) * ( C260 . B216 ) ))))) by POLYNOM1:def 9;
consider C262 being non  empty  finite (Subset of ( Bags C256 )) such that L763: ( divisors D45 ) = ( SgmX (( BagOrder C256 ) , C262) ) and L764: (for B217 being (bag of C256) holds (B217 in C262 iff B217 divides D45)) by PRE_POLY:def 16;
set D46 = ( SgmX (( BagOrder C256 ) , C262) );
L765: ( BagOrder C256 ) linearly_orders C262 by L754;
L766: ( HT (C259 , C257) ) divides D45 by PRE_POLY:50;
L767: ( HT (C259 , C257) ) in C262 by L766 , L764;
L768: ( HT (C259 , C257) ) in ( rng D46 ) by L767 , L765 , PRE_POLY:def 2;
consider C263 being set such that L769: C263 in ( dom D46 ) and L770: ( D46 . C263 ) = ( HT (C259 , C257) ) by L768 , FUNCT_1:def 3;
L771: C263 in ( dom ( decomp D45 ) ) by L763 , L769 , PRE_POLY:def 17;
L772: ( ( divisors D45 ) /. C263 ) = ( HT (C259 , C257) ) by L763 , L769 , L770 , PARTFUN1:def 6;
L773: ( ( decomp D45 ) /. C263 ) = <* ( HT (C259 , C257) ) , ( D45 -' ( HT (C259 , C257) ) ) *> by L772 , L771 , PRE_POLY:def 17;
L774: ( ( decomp D45 ) /. C263 ) = <* ( HT (C259 , C257) ) , ( HT (C260 , C257) ) *> by L773 , PRE_POLY:48;
L775: ( dom C261 ) = ( Seg ( len ( decomp D45 ) ) ) by L761 , FINSEQ_1:def 3
.= ( dom ( decomp D45 ) ) by FINSEQ_1:def 3;
L776: C263 in ( dom C261 ) by L775 , L763 , L769 , PRE_POLY:def 17;
reconsider D47 = C263 as (Element of ( NAT )) by L769;
consider C264 , C265 being (bag of C256) such that L777: ( ( decomp D45 ) /. D47 ) = <* C264 , C265 *> and L778: ( C261 /. D47 ) = ( ( C259 . C264 ) * ( C260 . C265 ) ) by L762 , L776;
L779: C265 = ( <* ( HT (C259 , C257) ) , ( HT (C260 , C257) ) *> . 2 ) by L774 , L777 , FINSEQ_1:44
.= ( HT (C260 , C257) ) by FINSEQ_1:44;
L780:
now
let C266 being (Element of ( NAT ));
assume that
L781: C266 in ( dom C261 )
and
L782: C266 <> D47;
consider C267 , C268 being (bag of C256) such that L783: ( ( decomp D45 ) /. C266 ) = <* C267 , C268 *> and L784: ( C261 /. C266 ) = ( ( C259 . C267 ) * ( C260 . C268 ) ) by L762 , L781;
consider C269 , C270 being (bag of C256) such that L785: ( ( decomp D45 ) /. C266 ) = <* C269 , C270 *> and L786: D45 = ( C269 + C270 ) by L775 , L781 , PRE_POLY:68;
L787: C268 = ( <* C269 , C270 *> . 2 ) by L785 , L783 , FINSEQ_1:44
.= C270 by FINSEQ_1:44;
L788: C267 = ( <* C269 , C270 *> . 1 ) by L785 , L783 , FINSEQ_1:44
.= C269 by FINSEQ_1:44;
L789:
now
assume that
L790: ( C259 . C267 ) <> ( 0. C258 )
and
L791: ( C260 . C268 ) <> ( 0. C258 );
L792: C267 is (Element of ( Bags C256 )) by PRE_POLY:def 12;
L793: C267 in ( Support C259 ) by L792 , L790 , POLYNOM1:def 3;
L794: C267 <= ( HT (C259 , C257) ) , C257 by L793 , L543;
L795: [ C267 , ( HT (C259 , C257) ) ] in C257 by L794 , L326;
L796: C268 is (Element of ( Bags C256 )) by PRE_POLY:def 12;
L797: C268 in ( Support C260 ) by L796 , L791 , POLYNOM1:def 3;
L798: C268 <= ( HT (C260 , C257) ) , C257 by L797 , L543;
L799: [ C268 , ( HT (C260 , C257) ) ] in C257 by L798 , L326;
L800:
now
assume L801: (C267 = ( HT (C259 , C257) ) & C268 = ( HT (C260 , C257) ));
L802: ( ( decomp D45 ) . C266 ) = <* ( HT (C259 , C257) ) , ( HT (C260 , C257) ) *> by L801 , L775 , L781 , L783 , PARTFUN1:def 6
.= ( ( decomp D45 ) /. D47 ) by L773 , PRE_POLY:48
.= ( ( decomp D45 ) . D47 ) by L771 , PARTFUN1:def 6;
thus L803: contradiction by L802 , L771 , L775 , L781 , L782 , FUNCT_1:def 4;
end;
L804:
now
per cases  by L800;
case L805: C267 <> ( HT (C259 , C257) );
L806:
now
assume L807: ( C267 + C268 ) = ( ( HT (C259 , C257) ) + C268 );
L808: C267 = ( ( ( HT (C259 , C257) ) + C268 ) -' C268 ) by L807 , PRE_POLY:48;
thus L809: contradiction by L808 , L805 , PRE_POLY:48;
end;
L810: (( ( HT (C259 , C257) ) + C268 ) is (Element of ( Bags C256 )) & ( ( HT (C259 , C257) ) + ( HT (C260 , C257) ) ) is (Element of ( Bags C256 ))) by PRE_POLY:def 12;
L811: ([ ( ( HT (C259 , C257) ) + ( HT (C260 , C257) ) ) , ( ( HT (C259 , C257) ) + C268 ) ] in C257 & [ ( ( HT (C259 , C257) ) + C268 ) , ( ( HT (C259 , C257) ) + ( HT (C260 , C257) ) ) ] in C257) by L786 , L788 , L787 , L795 , L799 , BAGORDER:def 5;
thus L812: contradiction by L811 , L786 , L788 , L787 , L806 , L810 , ORDERS_1:4;
end;
case L813: C268 <> ( HT (C260 , C257) );
L814:
now
assume L815: ( C268 + C267 ) = ( ( HT (C260 , C257) ) + C267 );
L816: C268 = ( ( ( HT (C260 , C257) ) + C267 ) -' C267 ) by L815 , PRE_POLY:48;
thus L817: contradiction by L816 , L813 , PRE_POLY:48;
end;
L818: (( ( HT (C260 , C257) ) + C267 ) is (Element of ( Bags C256 )) & ( ( HT (C259 , C257) ) + ( HT (C260 , C257) ) ) is (Element of ( Bags C256 ))) by PRE_POLY:def 12;
L819: ([ ( ( HT (C259 , C257) ) + ( HT (C260 , C257) ) ) , ( ( HT (C260 , C257) ) + C267 ) ] in C257 & [ ( ( HT (C260 , C257) ) + C267 ) , ( ( HT (C259 , C257) ) + ( HT (C260 , C257) ) ) ] in C257) by L786 , L788 , L787 , L795 , L799 , BAGORDER:def 5;
thus L820: contradiction by L819 , L786 , L788 , L787 , L814 , L818 , ORDERS_1:4;
end;
end;
thus L822: contradiction by L804;
end;
L823:
now
per cases  by L789;
case L824: ( C259 . C267 ) = ( 0. C258 );
thus L825: ( ( C259 . C267 ) * ( C260 . C268 ) ) = ( 0. C258 ) by L824 , BINOM:1;
end;
case L826: ( C260 . C268 ) = ( 0. C258 );
thus L827: ( ( C259 . C267 ) * ( C260 . C268 ) ) = ( 0. C258 ) by L826 , BINOM:2;
end;
end;
thus L829: ( C261 /. C266 ) = ( 0. C258 ) by L823 , L784;
end;
L830: C264 = ( <* ( HT (C259 , C257) ) , ( HT (C260 , C257) ) *> . 1 ) by L774 , L777 , FINSEQ_1:44
.= ( HT (C259 , C257) ) by FINSEQ_1:44;
thus L831: thesis by L830 , L760 , L776 , L780 , L778 , L779 , POLYNOM2:3;
end;
theorem
L832: (for B218 being Ordinal holds (for B219 being  admissible  connected (TermOrder of B218) holds (for B220 being  add-associative  right_complementable  left_zeroed  right_zeroed  well-unital  distributive  domRing-like non  trivial doubleLoopStr holds (for B221 , B222 being  non-zero (Polynomial of B218 , B220) holds ( ( HT (B221 , B219) ) + ( HT (B222 , B219) ) ) in ( Support ( B221 *' B222 ) )))))
proof
let C271 being Ordinal;
let C272 being  admissible  connected (TermOrder of C271);
let C273 being  add-associative  right_complementable  right_zeroed  left_zeroed  well-unital  distributive  domRing-like non  trivial doubleLoopStr;
let C274 , C275 being  non-zero (Polynomial of C271 , C273);
set D48 = ( ( HT (C274 , C272) ) + ( HT (C275 , C272) ) );
assume L833: (not ( ( HT (C274 , C272) ) + ( HT (C275 , C272) ) ) in ( Support ( C274 *' C275 ) ));
L834: C274 <> ( 0_ (C271 , C273) ) by POLYNOM7:def 1;
L835: ( Support C274 ) <> ( {} ) by L834 , POLYNOM7:1;
L836: ( HT (C274 , C272) ) in ( Support C274 ) by L835 , L543;
L837: ( C274 . ( HT (C274 , C272) ) ) <> ( 0. C273 ) by L836 , POLYNOM1:def 3;
L838: C275 <> ( 0_ (C271 , C273) ) by POLYNOM7:def 1;
L839: ( Support C275 ) <> ( {} ) by L838 , POLYNOM7:1;
L840: ( HT (C275 , C272) ) in ( Support C275 ) by L839 , L543;
L841: ( C275 . ( HT (C275 , C272) ) ) <> ( 0. C273 ) by L840 , POLYNOM1:def 3;
L842: D48 is (Element of ( Bags C271 )) by PRE_POLY:def 12;
L843: ( ( C274 *' C275 ) . ( ( HT (C274 , C272) ) + ( HT (C275 , C272) ) ) ) = ( 0. C273 ) by L842 , L833 , POLYNOM1:def 3;
L844: ( ( C274 . ( HT (C274 , C272) ) ) * ( C275 . ( HT (C275 , C272) ) ) ) = ( 0. C273 ) by L843 , L759;
thus L845: thesis by L844 , L837 , L841 , VECTSP_2:def 1;
end;
theorem
L846: (for B223 being Ordinal holds (for B224 being  add-associative  right_complementable  right_zeroed  well-unital  distributive non  empty doubleLoopStr holds (for B225 , B226 being (Polynomial of B223 , B224) holds ( Support ( B225 *' B226 ) ) c= { ( B227 + B228 ) where B227 , B228 is (Element of ( Bags B223 )) : (B227 in ( Support B225 ) & B228 in ( Support B226 )) })))
proof
let C276 being Ordinal;
let C277 being  add-associative  right_complementable  right_zeroed  well-unital  distributive non  empty doubleLoopStr;
let C278 , C279 being (Polynomial of C276 , C277);
L847:
now
let C280 being (bag of C276);
consider C281 being (FinSequence of C277) such that L848: ( ( C278 *' C279 ) . C280 ) = ( Sum C281 ) and L849: ( len C281 ) = ( len ( decomp C280 ) ) and L850: (for B229 being (Element of ( NAT )) holds (B229 in ( dom C281 ) implies (ex B230 , B231 being (bag of C276) st (( ( decomp C280 ) /. B229 ) = <* B230 , B231 *> & ( C281 /. B229 ) = ( ( C278 . B230 ) * ( C279 . B231 ) ))))) by POLYNOM1:def 9;
L851: ( dom C281 ) = ( Seg ( len ( decomp C280 ) ) ) by L849 , FINSEQ_1:def 3
.= ( dom ( decomp C280 ) ) by FINSEQ_1:def 3;
assume L852: C280 in ( Support ( C278 *' C279 ) );
L853:
now
per cases ;
case L854: ( dom C281 ) = ( {} );
L855: ( Seg ( len C281 ) ) = ( {} ) by L854 , FINSEQ_1:def 3;
L856: ( len C281 ) = ( 0 ) by L855;
thus L857: contradiction by L856 , L849;
end;
case L858: ( dom C281 ) <> ( {} );
set D49 = the (Element of ( dom C281 ));
L859: D49 in ( dom C281 ) by L858;
reconsider D50 = D49 as (Element of ( NAT )) by L859;
L860:
now
assume L861: (not (ex B232 being (Element of ( dom ( decomp C280 ) )) st (ex B233 , B234 being (bag of C276) st (( ( decomp C280 ) /. B232 ) = <* B233 , B234 *> & ( C278 . B233 ) <> ( 0. C277 ) & ( C279 . B234 ) <> ( 0. C277 )))));
L862: (for B235 being Nat holds (B235 in ( dom C281 ) implies ( C281 /. B235 ) = ( 0. C277 )))
proof
let C282 being Nat;
assume L863: C282 in ( dom C281 );
consider C283 , C284 being (bag of C276) such that L864: ( ( decomp C280 ) /. C282 ) = <* C283 , C284 *> and L865: ( C281 /. C282 ) = ( ( C278 . C283 ) * ( C279 . C284 ) ) by L863 , L850;
L866:
now
per cases  by L851 , L861 , L863 , L864;
case L867: ( C278 . C283 ) = ( 0. C277 );
thus L868: thesis by L867 , L865 , BINOM:1;
end;
case L869: ( C279 . C284 ) = ( 0. C277 );
thus L870: thesis by L869 , L865 , BINOM:2;
end;
end;
thus L872: thesis by L866;
end;
L873: (for B236 being (Element of ( NAT )) holds ((B236 in ( dom C281 ) & B236 <> D50) implies ( C281 /. B236 ) = ( 0. C277 ))) by L862;
L874: ( Sum C281 ) = ( C281 /. D50 ) by L873 , L858 , POLYNOM2:3
.= ( 0. C277 ) by L858 , L862;
thus L875: contradiction by L874 , L852 , L848 , POLYNOM1:def 3;
end;
consider C285 being (Element of ( dom ( decomp C280 ) )), C286 , C287 being (bag of C276) such that L876: ( ( decomp C280 ) /. C285 ) = <* C286 , C287 *> and L877: ( C278 . C286 ) <> ( 0. C277 ) and L878: ( C279 . C287 ) <> ( 0. C277 ) by L860;
L879: C285 in ( dom ( decomp C280 ) ) by L851 , L858;
reconsider D51 = C285 as (Element of ( NAT )) by L879;
consider C288 , C289 being (bag of C276) such that L880: ( ( decomp C280 ) /. D51 ) = <* C288 , C289 *> and L881: C280 = ( C288 + C289 ) by L851 , L858 , PRE_POLY:68;
L882: C289 = ( <* C286 , C287 *> . 2 ) by L876 , L880 , FINSEQ_1:44
.= C287 by FINSEQ_1:44;
L883: C287 is (Element of ( Bags C276 )) by PRE_POLY:def 12;
L884: C287 in ( Support C279 ) by L883 , L878 , POLYNOM1:def 3;
L885: C286 is (Element of ( Bags C276 )) by PRE_POLY:def 12;
L886: C286 in ( Support C278 ) by L885 , L877 , POLYNOM1:def 3;
L887: C288 = ( <* C286 , C287 *> . 1 ) by L876 , L880 , FINSEQ_1:44
.= C286 by FINSEQ_1:44;
thus L888: (ex B237 , B238 being (bag of C276) st (B237 in ( Support C278 ) & B238 in ( Support C279 ) & C280 = ( B237 + B238 ))) by L887 , L886 , L884 , L881 , L882;
end;
end;
thus L890: (ex B239 , B240 being (bag of C276) st (B239 in ( Support C278 ) & B240 in ( Support C279 ) & C280 = ( B239 + B240 ))) by L853;
end;
L891:
now
let C290 being set;
assume L892: C290 in ( Support ( C278 *' C279 ) );
reconsider D52 = C290 as (Element of ( Bags C276 )) by L892;
L893: (ex B241 , B242 being (bag of C276) st (B241 in ( Support C278 ) & B242 in ( Support C279 ) & D52 = ( B241 + B242 ))) by L847 , L892;
thus L894: C290 in { ( B243 + B244 ) where B243 , B244 is (Element of ( Bags C276 )) : (B243 in ( Support C278 ) & B244 in ( Support C279 )) } by L893;
end;
thus L895: thesis by L891 , TARSKI:def 3;
end;
theorem
L896: (for B245 being Ordinal holds (for B246 being  admissible  connected (TermOrder of B245) holds (for B247 being  add-associative  right_complementable  right_zeroed  well-unital  distributive  domRing-like non  trivial doubleLoopStr holds (for B248 , B249 being  non-zero (Polynomial of B245 , B247) holds ( HT (( B248 *' B249 ) , B246) ) = ( ( HT (B248 , B246) ) + ( HT (B249 , B246) ) )))))
proof
let C291 being Ordinal;
let C292 being  admissible  connected (TermOrder of C291);
let C293 being  add-associative  right_complementable  right_zeroed  well-unital  distributive  domRing-like non  trivial doubleLoopStr;
let C294 , C295 being  non-zero (Polynomial of C291 , C293);
L897: ( ( HT (C294 , C292) ) + ( HT (C295 , C292) ) ) is (Element of ( Bags C291 )) by PRE_POLY:def 12;
L898: ( ( HT (C294 , C292) ) + ( HT (C295 , C292) ) ) in ( Support ( C294 *' C295 ) ) by L832;
L899: ( ( HT (C294 , C292) ) + ( HT (C295 , C292) ) ) <= ( HT (( C294 *' C295 ) , C292) ) , C292 by L898 , L543;
L900: [ ( ( HT (C294 , C292) ) + ( HT (C295 , C292) ) ) , ( HT (( C294 *' C295 ) , C292) ) ] in C292 by L899 , L326;
L901: ( Support ( C294 *' C295 ) ) <> ( {} ) by L832;
L902: ( HT (( C294 *' C295 ) , C292) ) in ( Support ( C294 *' C295 ) ) by L901 , L543;
L903: ( Support ( C294 *' C295 ) ) c= { ( B250 + B251 ) where B250 , B251 is (Element of ( Bags C291 )) : (B250 in ( Support C294 ) & B251 in ( Support C295 )) } by L846;
L904: ( HT (( C294 *' C295 ) , C292) ) in { ( B252 + B253 ) where B252 , B253 is (Element of ( Bags C291 )) : (B252 in ( Support C294 ) & B253 in ( Support C295 )) } by L903 , L902;
consider C296 , C297 being (Element of ( Bags C291 )) such that L905: ( HT (( C294 *' C295 ) , C292) ) = ( C296 + C297 ) and L906: C296 in ( Support C294 ) and L907: C297 in ( Support C295 ) by L904;
L908: C296 <= ( HT (C294 , C292) ) , C292 by L906 , L543;
L909: [ C296 , ( HT (C294 , C292) ) ] in C292 by L908 , L326;
L910: [ ( C296 + C297 ) , ( ( HT (C294 , C292) ) + C297 ) ] in C292 by L909 , BAGORDER:def 5;
L911: C297 <= ( HT (C295 , C292) ) , C292 by L907 , L543;
L912: [ C297 , ( HT (C295 , C292) ) ] in C292 by L911 , L326;
L913: [ ( C297 + ( HT (C294 , C292) ) ) , ( ( HT (C294 , C292) ) + ( HT (C295 , C292) ) ) ] in C292 by L912 , BAGORDER:def 5;
L914: (( C296 + C297 ) is (Element of ( Bags C291 )) & ( ( HT (C294 , C292) ) + C297 ) is (Element of ( Bags C291 ))) by PRE_POLY:def 12;
L915: [ ( C296 + C297 ) , ( ( HT (C294 , C292) ) + ( HT (C295 , C292) ) ) ] in C292 by L914 , L897 , L910 , L913 , ORDERS_1:5;
thus L916: thesis by L915 , L900 , L905 , L897 , ORDERS_1:4;
end;
theorem
L917: (for B254 being Ordinal holds (for B255 being  admissible  connected (TermOrder of B254) holds (for B256 being  add-associative  right_complementable  right_zeroed  well-unital  distributive  domRing-like non  trivial doubleLoopStr holds (for B257 , B258 being  non-zero (Polynomial of B254 , B256) holds ( HC (( B257 *' B258 ) , B255) ) = ( ( HC (B257 , B255) ) * ( HC (B258 , B255) ) )))))
proof
let C298 being Ordinal;
let C299 being  admissible  connected (TermOrder of C298);
let C300 being  add-associative  right_complementable  right_zeroed  well-unital  distributive  domRing-like non  trivial doubleLoopStr;
let C301 , C302 being  non-zero (Polynomial of C298 , C300);
thus L918: ( HC (( C301 *' C302 ) , C299) ) = ( ( C301 *' C302 ) . ( ( HT (C301 , C299) ) + ( HT (C302 , C299) ) ) ) by L896
.= ( ( HC (C301 , C299) ) * ( HC (C302 , C299) ) ) by L759;
end;
theorem
L919: (for B259 being Ordinal holds (for B260 being  admissible  connected (TermOrder of B259) holds (for B261 being  add-associative  right_complementable  right_zeroed  well-unital  distributive  domRing-like non  trivial doubleLoopStr holds (for B262 , B263 being  non-zero (Polynomial of B259 , B261) holds ( HM (( B262 *' B263 ) , B260) ) = ( ( HM (B262 , B260) ) *' ( HM (B263 , B260) ) )))))
proof
let C303 being Ordinal;
let C304 being  admissible  connected (TermOrder of C303);
let C305 being  add-associative  right_complementable  right_zeroed  well-unital  distributive  domRing-like non  trivial doubleLoopStr;
let C306 , C307 being  non-zero (Polynomial of C303 , C305);
thus L920: ( HM (( C306 *' C307 ) , C304) ) = ( Monom (( ( HC (C306 , C304) ) * ( HC (C307 , C304) ) ) , ( HT (( C306 *' C307 ) , C304) )) ) by L917
.= ( Monom (( ( HC (C306 , C304) ) * ( HC (C307 , C304) ) ) , ( ( HT (C306 , C304) ) + ( HT (C307 , C304) ) )) ) by L896
.= ( ( HM (C306 , C304) ) *' ( HM (C307 , C304) ) ) by L228;
end;
theorem
L921: (for B264 being Ordinal holds (for B265 being  admissible  connected (TermOrder of B264) holds (for B266 being  right_zeroed non  empty addLoopStr holds (for B267 , B268 being (Polynomial of B264 , B266) holds ( HT (( B267 + B268 ) , B265) ) <= ( max (( HT (B267 , B265) ) , ( HT (B268 , B265) ) , B265) ) , B265))))
proof
let C308 being Ordinal;
let C309 being  admissible  connected (TermOrder of C308);
let C310 being  right_zeroed non  empty addLoopStr;
let C311 , C312 being (Polynomial of C308 , C310);
per cases ;
suppose L922: ( HT (( C311 + C312 ) , C309) ) in ( Support ( C311 + C312 ) );

L923: ( Support ( C311 + C312 ) ) c= ( ( Support C311 ) \/ ( Support C312 ) ) by POLYNOM1:20;
L924:
now
per cases  by L922 , L923 , XBOOLE_0:def 3;
case L925: ( HT (( C311 + C312 ) , C309) ) in ( Support C311 );
L926: ( HT (( C311 + C312 ) , C309) ) <= ( HT (C311 , C309) ) , C309 by L925 , L543;
L927:
now
per cases  by L423;
case L928: ( max (( HT (C311 , C309) ) , ( HT (C312 , C309) ) , C309) ) = ( HT (C311 , C309) );
thus L929: thesis by L928 , L925 , L543;
end;
case L930: ( max (( HT (C311 , C309) ) , ( HT (C312 , C309) ) , C309) ) = ( HT (C312 , C309) );
L931: ( HT (C311 , C309) ) <= ( HT (C312 , C309) ) , C309 by L930 , L453;
thus L932: thesis by L931 , L926 , L930 , L393;
end;
end;
thus L934: thesis by L927;
end;
case L935: ( HT (( C311 + C312 ) , C309) ) in ( Support C312 );
L936: ( HT (( C311 + C312 ) , C309) ) <= ( HT (C312 , C309) ) , C309 by L935 , L543;
L937:
now
per cases  by L423;
case L938: ( max (( HT (C311 , C309) ) , ( HT (C312 , C309) ) , C309) ) = ( HT (C312 , C309) );
thus L939: thesis by L938 , L935 , L543;
end;
case L940: ( max (( HT (C311 , C309) ) , ( HT (C312 , C309) ) , C309) ) = ( HT (C311 , C309) );
L941: ( HT (C312 , C309) ) <= ( HT (C311 , C309) ) , C309 by L940 , L453;
thus L942: thesis by L941 , L936 , L940 , L393;
end;
end;
thus L944: thesis by L937;
end;
end;
thus L946: thesis by L924;
end;
suppose L947: (not ( HT (( C311 + C312 ) , C309) ) in ( Support ( C311 + C312 ) ));

L948: ( HT (( C311 + C312 ) , C309) ) = ( EmptyBag C308 ) by L947 , L543;
L949: [ ( HT (( C311 + C312 ) , C309) ) , ( max (( HT (C311 , C309) ) , ( HT (C312 , C309) ) , C309) ) ] in C309 by L948 , BAGORDER:def 5;
thus L950: thesis by L949 , L326;
end;
end;
begin
definition
let C313 being Ordinal;
let C314 being  connected (TermOrder of C313);
let C315 being  add-associative  right_complementable  right_zeroed non  empty addLoopStr;
let C316 being (Polynomial of C313 , C315);
func Red (C316 , C314) -> (Polynomial of C313 , C315) equals 
( C316 - ( HM (C316 , C314) ) );
coherence;
end;
L953: (for B269 being Ordinal holds (for B270 being  connected (TermOrder of B269) holds (for B271 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr holds (for B272 being (Polynomial of B269 , B271) holds (not ( HT (B272 , B270) ) in ( Support ( Red (B272 , B270) ) ))))))
proof
let C317 being Ordinal;
let C318 being  connected (TermOrder of C317);
let C319 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr;
let C320 being (Polynomial of C317 , C319);
assume L954: ( HT (C320 , C318) ) in ( Support ( Red (C320 , C318) ) );
L955: ( ( Red (C320 , C318) ) . ( HT (C320 , C318) ) ) <> ( 0. C319 ) by L954 , POLYNOM1:def 3;
L956: ( ( C320 + ( - ( HM (C320 , C318) ) ) ) . ( HT (C320 , C318) ) ) <> ( 0. C319 ) by L955 , POLYNOM1:def 6;
L957: ( ( C320 . ( HT (C320 , C318) ) ) + ( ( - ( HM (C320 , C318) ) ) . ( HT (C320 , C318) ) ) ) <> ( 0. C319 ) by L956 , POLYNOM1:15;
L958: ( ( C320 . ( HT (C320 , C318) ) ) + ( - ( ( HM (C320 , C318) ) . ( HT (C320 , C318) ) ) ) ) <> ( 0. C319 ) by L957 , POLYNOM1:17;
L959: ( ( HM (C320 , C318) ) . ( HT (C320 , C318) ) ) = ( C320 . ( HT (C320 , C318) ) ) by L595;
thus L960: thesis by L959 , L958 , RLVECT_1:def 10;
end;
L961: (for B273 being Ordinal holds (for B274 being  connected (TermOrder of B273) holds (for B275 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr holds (for B276 being (Polynomial of B273 , B275) holds (for B277 being (bag of B273) holds ((B277 in ( Support B276 ) & B277 <> ( HT (B276 , B274) )) implies B277 in ( Support ( Red (B276 , B274) ) )))))))
proof
let C321 being Ordinal;
let C322 being  connected (TermOrder of C321);
let C323 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr;
let C324 being (Polynomial of C321 , C323);
let C325 being (bag of C321);
assume that
L962: C325 in ( Support C324 )
and
L963: C325 <> ( HT (C324 , C322) );
L964: ( ( Red (C324 , C322) ) . C325 ) = ( ( C324 + ( - ( HM (C324 , C322) ) ) ) . C325 ) by POLYNOM1:def 6
.= ( ( C324 . C325 ) + ( ( - ( HM (C324 , C322) ) ) . C325 ) ) by POLYNOM1:15
.= ( ( C324 . C325 ) + ( - ( ( HM (C324 , C322) ) . C325 ) ) ) by POLYNOM1:17
.= ( ( C324 . C325 ) + ( - ( 0. C323 ) ) ) by L963 , L659
.= ( ( C324 . C325 ) + ( 0. C323 ) ) by RLVECT_1:12
.= ( C324 . C325 ) by RLVECT_1:4;
L965: (C325 is (Element of ( Bags C321 )) & ( ( Red (C324 , C322) ) . C325 ) <> ( 0. C323 )) by L964 , L962 , POLYNOM1:def 3;
thus L966: thesis by L965 , POLYNOM1:def 3;
end;
L967: (for B278 being Ordinal holds (for B279 being  connected (TermOrder of B278) holds (for B280 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr holds (for B281 being (Polynomial of B278 , B280) holds ( Support ( Red (B281 , B279) ) ) = ( ( Support B281 ) \ { ( HT (B281 , B279) ) } )))))
proof
let C326 being Ordinal;
let C327 being  connected (TermOrder of C326);
let C328 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr;
let C329 being (Polynomial of C326 , C328);
L968:
now
let C330 being set;
assume L969: C330 in ( Support ( Red (C329 , C327) ) );
reconsider D53 = C330 as (Element of ( Bags C326 )) by L969;
reconsider D54 = D53 as (bag of C326);
L970: ( ( C329 - ( HM (C329 , C327) ) ) . D54 ) <> ( 0. C328 ) by L969 , POLYNOM1:def 3;
L971: (not D54 = ( HT (C329 , C327) )) by L969 , L953;
L972: ( ( C329 + ( - ( HM (C329 , C327) ) ) ) . D54 ) = ( ( C329 . D54 ) + ( ( - ( HM (C329 , C327) ) ) . D54 ) ) by POLYNOM1:15
.= ( ( C329 . D54 ) + ( - ( ( HM (C329 , C327) ) . D54 ) ) ) by POLYNOM1:17;
L973: ( ( C329 + ( - ( HM (C329 , C327) ) ) ) . D54 ) = ( ( C329 . D54 ) + ( - ( 0. C328 ) ) ) by L972 , L971 , L659
.= ( ( C329 . D54 ) + ( 0. C328 ) ) by RLVECT_1:12
.= ( C329 . D54 ) by RLVECT_1:4;
L974: ( C329 . D54 ) <> ( 0. C328 ) by L973 , L970 , POLYNOM1:def 6;
L975: D54 in ( Support C329 ) by L974 , POLYNOM1:def 3;
L976: (not D54 in { ( HT (C329 , C327) ) }) by L971 , TARSKI:def 1;
thus L977: C330 in ( ( Support C329 ) \ { ( HT (C329 , C327) ) } ) by L976 , L975 , XBOOLE_0:def 5;
end;
L978:
now
let C331 being set;
assume L979: C331 in ( ( Support C329 ) \ { ( HT (C329 , C327) ) } );
reconsider D55 = C331 as (Element of ( Bags C326 )) by L979;
reconsider D56 = D55 as (bag of C326);
L980: (not C331 in { ( HT (C329 , C327) ) }) by L979 , XBOOLE_0:def 5;
L981: D56 <> ( HT (C329 , C327) ) by L980 , TARSKI:def 1;
L982: C331 in ( Support C329 ) by L979 , XBOOLE_0:def 5;
thus L983: C331 in ( Support ( Red (C329 , C327) ) ) by L982 , L981 , L961;
end;
thus L984: thesis by L978 , L968 , TARSKI:1;
end;
theorem
L985: (for B282 being Ordinal holds (for B283 being  connected (TermOrder of B282) holds (for B284 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr holds (for B285 being (Polynomial of B282 , B284) holds ( Support ( Red (B285 , B283) ) ) c= ( Support B285 )))))
proof
let C332 being Ordinal;
let C333 being  connected (TermOrder of C332);
let C334 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr;
let C335 being (Polynomial of C332 , C334);
L986: ( Support ( Red (C335 , C333) ) ) = ( ( Support C335 ) \ { ( HT (C335 , C333) ) } ) by L967;
thus L987: thesis by L986 , XBOOLE_1:36;
end;
theorem
L988: (for B286 being Ordinal holds (for B287 being  connected (TermOrder of B286) holds (for B288 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr holds (for B289 being (Polynomial of B286 , B288) holds ( Support ( Red (B289 , B287) ) ) = ( ( Support B289 ) \ { ( HT (B289 , B287) ) } ))))) by L967;
L989: (for B290 being Ordinal holds (for B291 being  connected (TermOrder of B290) holds (for B292 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr holds (for B293 being (Polynomial of B290 , B292) holds ( ( Red (B293 , B291) ) . ( HT (B293 , B291) ) ) = ( 0. B292 )))))
proof
let C336 being Ordinal;
let C337 being  connected (TermOrder of C336);
let C338 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr;
let C339 being (Polynomial of C336 , C338);
L990: (( HT (C339 , C337) ) in { ( HT (C339 , C337) ) } & ( Support ( Red (C339 , C337) ) ) = ( ( Support C339 ) \ { ( HT (C339 , C337) ) } )) by L967 , TARSKI:def 1;
L991: (not ( HT (C339 , C337) ) in ( Support ( Red (C339 , C337) ) )) by L990 , XBOOLE_0:def 5;
thus L992: thesis by L991 , POLYNOM1:def 3;
end;
L993: (for B294 being Ordinal holds (for B295 being  connected (TermOrder of B294) holds (for B296 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr holds (for B297 being (Polynomial of B294 , B296) holds (for B298 being (bag of B294) holds (B298 <> ( HT (B297 , B295) ) implies ( ( Red (B297 , B295) ) . B298 ) = ( B297 . B298 )))))))
proof
let C340 being Ordinal;
let C341 being  connected (TermOrder of C340);
let C342 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr;
let C343 being (Polynomial of C340 , C342);
let C344 being (bag of C340);
L994: C344 is (Element of ( Bags C340 )) by PRE_POLY:def 12;
assume L995: C344 <> ( HT (C343 , C341) );
L996: (not C344 in { ( HT (C343 , C341) ) }) by L995 , TARSKI:def 1;
L997: (not C344 in ( Support ( HM (C343 , C341) ) )) by L996 , L680;
thus L998: ( ( Red (C343 , C341) ) . C344 ) = ( ( C343 + ( - ( HM (C343 , C341) ) ) ) . C344 ) by POLYNOM1:def 6
.= ( ( C343 . C344 ) + ( ( - ( HM (C343 , C341) ) ) . C344 ) ) by POLYNOM1:15
.= ( ( C343 . C344 ) + ( - ( ( HM (C343 , C341) ) . C344 ) ) ) by POLYNOM1:17
.= ( ( C343 . C344 ) + ( - ( 0. C342 ) ) ) by L997 , L994 , POLYNOM1:def 3
.= ( ( C343 . C344 ) + ( 0. C342 ) ) by RLVECT_1:12
.= ( C343 . C344 ) by RLVECT_1:4;
end;
theorem
L999: (for B299 being Ordinal holds (for B300 being  connected (TermOrder of B299) holds (for B301 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr holds (for B302 being (Polynomial of B299 , B301) holds ( Support ( ( HM (B302 , B300) ) + ( Red (B302 , B300) ) ) ) = ( Support B302 )))))
proof
let C345 being Ordinal;
let C346 being  connected (TermOrder of C345);
let C347 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr;
let C348 being (Polynomial of C345 , C347);
L1000:
now
let C349 being set;
assume L1001: C349 in ( Support C348 );
reconsider D57 = C349 as (Element of ( Bags C345 )) by L1001;
reconsider D58 = D57 as (bag of C345);
L1002: ( C348 . D58 ) <> ( 0. C347 ) by L1001 , POLYNOM1:def 3;
L1003:
now
per cases ;
case L1004: D58 = ( HT (C348 , C346) );
L1005: ( C348 . ( HT (C348 , C346) ) ) <> ( 0. C347 ) by L1004 , L1001 , POLYNOM1:def 3;
L1006: ( ( ( HM (C348 , C346) ) + ( Red (C348 , C346) ) ) . D58 ) = ( ( ( HM (C348 , C346) ) . D58 ) + ( ( Red (C348 , C346) ) . D58 ) ) by POLYNOM1:15
.= ( ( ( HM (C348 , C346) ) . D58 ) + ( 0. C347 ) ) by L1004 , L989
.= ( ( HM (C348 , C346) ) . D58 ) by RLVECT_1:4
.= ( HC (C348 , C346) ) by L1004 , L595;
thus L1007: D58 in ( Support ( ( HM (C348 , C346) ) + ( Red (C348 , C346) ) ) ) by L1006 , L1005 , POLYNOM1:def 3;
end;
case L1008: D58 <> ( HT (C348 , C346) );
L1009: ( ( ( HM (C348 , C346) ) + ( Red (C348 , C346) ) ) . D58 ) = ( ( ( HM (C348 , C346) ) . D58 ) + ( ( Red (C348 , C346) ) . D58 ) ) by POLYNOM1:15
.= ( ( ( HM (C348 , C346) ) . D58 ) + ( C348 . D58 ) ) by L1008 , L993
.= ( ( 0. C347 ) + ( C348 . D58 ) ) by L1008 , L659
.= ( C348 . D58 ) by RLVECT_1:4;
thus L1010: D58 in ( Support ( ( HM (C348 , C346) ) + ( Red (C348 , C346) ) ) ) by L1009 , L1002 , POLYNOM1:def 3;
end;
end;
thus L1012: C349 in ( Support ( ( HM (C348 , C346) ) + ( Red (C348 , C346) ) ) ) by L1003;
end;
L1013:
now
let C350 being set;
assume L1014: C350 in ( Support ( ( HM (C348 , C346) ) + ( Red (C348 , C346) ) ) );
reconsider D59 = C350 as (Element of ( Bags C345 )) by L1014;
reconsider D60 = D59 as (bag of C345);
L1015: ( ( ( HM (C348 , C346) ) + ( Red (C348 , C346) ) ) . D60 ) <> ( 0. C347 ) by L1014 , POLYNOM1:def 3;
L1016:
now
per cases ;
case L1017: D60 = ( HT (C348 , C346) );
L1018: ( ( ( HM (C348 , C346) ) + ( Red (C348 , C346) ) ) . D60 ) = ( ( ( HM (C348 , C346) ) . D60 ) + ( ( Red (C348 , C346) ) . D60 ) ) by POLYNOM1:15
.= ( ( ( HM (C348 , C346) ) . ( HT (C348 , C346) ) ) + ( 0. C347 ) ) by L1017 , L989
.= ( ( HM (C348 , C346) ) . ( HT (C348 , C346) ) ) by RLVECT_1:4
.= ( C348 . D60 ) by L1017 , L595;
thus L1019: D60 in ( Support C348 ) by L1018 , L1015 , POLYNOM1:def 3;
end;
case L1020: D60 <> ( HT (C348 , C346) );
L1021: ( ( ( HM (C348 , C346) ) + ( Red (C348 , C346) ) ) . D60 ) = ( ( ( HM (C348 , C346) ) . D60 ) + ( ( Red (C348 , C346) ) . D60 ) ) by POLYNOM1:15
.= ( ( 0. C347 ) + ( ( Red (C348 , C346) ) . D60 ) ) by L1020 , L659
.= ( ( Red (C348 , C346) ) . D60 ) by RLVECT_1:4
.= ( C348 . C350 ) by L1020 , L993;
thus L1022: D60 in ( Support C348 ) by L1021 , L1015 , POLYNOM1:def 3;
end;
end;
thus L1024: C350 in ( Support C348 ) by L1016;
end;
thus L1025: thesis by L1013 , L1000 , TARSKI:1;
end;
theorem
L1026: (for B303 being Ordinal holds (for B304 being  connected (TermOrder of B303) holds (for B305 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr holds (for B306 being (Polynomial of B303 , B305) holds ( ( HM (B306 , B304) ) + ( Red (B306 , B304) ) ) = B306))))
proof
let C351 being Ordinal;
let C352 being  connected (TermOrder of C351);
let C353 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr;
let C354 being (Polynomial of C351 , C353);
L1027:
now
let C355 being set;
assume L1028: C355 in ( Bags C351 );
reconsider D61 = C355 as (Element of ( Bags C351 )) by L1028;
L1029:
now
per cases ;
case L1030: C355 = ( HT (C354 , C352) );
thus L1031: ( ( ( HM (C354 , C352) ) + ( Red (C354 , C352) ) ) . C355 ) = ( ( ( HM (C354 , C352) ) . ( HT (C354 , C352) ) ) + ( ( Red (C354 , C352) ) . ( HT (C354 , C352) ) ) ) by L1030 , POLYNOM1:15
.= ( ( ( HM (C354 , C352) ) . ( HT (C354 , C352) ) ) + ( 0. C353 ) ) by L989
.= ( ( HM (C354 , C352) ) . ( HT (C354 , C352) ) ) by RLVECT_1:4
.= ( C354 . C355 ) by L1030 , L595;
end;
case L1032: C355 <> ( HT (C354 , C352) );
L1033: ( ( ( HM (C354 , C352) ) + ( Red (C354 , C352) ) ) . D61 ) = ( ( ( HM (C354 , C352) ) . D61 ) + ( ( Red (C354 , C352) ) . D61 ) ) by POLYNOM1:15
.= ( ( ( HM (C354 , C352) ) . D61 ) + ( C354 . D61 ) ) by L1032 , L993
.= ( ( 0. C353 ) + ( C354 . D61 ) ) by L1032 , L659
.= ( C354 . D61 ) by RLVECT_1:4;
thus L1034: ( C354 . C355 ) = ( ( ( HM (C354 , C352) ) + ( Red (C354 , C352) ) ) . C355 ) by L1033;
end;
end;
thus L1036: ( C354 . C355 ) = ( ( ( HM (C354 , C352) ) + ( Red (C354 , C352) ) ) . C355 ) by L1029;
end;
L1037: (( dom C354 ) = ( Bags C351 ) & ( dom ( ( HM (C354 , C352) ) + ( Red (C354 , C352) ) ) ) = ( Bags C351 )) by FUNCT_2:def 1;
thus L1038: thesis by L1037 , L1027 , FUNCT_1:2;
end;
theorem
L1039: (for B307 being Ordinal holds (for B308 being  connected (TermOrder of B307) holds (for B309 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr holds (for B310 being (Polynomial of B307 , B309) holds ( ( Red (B310 , B308) ) . ( HT (B310 , B308) ) ) = ( 0. B309 ))))) by L989;
theorem
L1040: (for B311 being Ordinal holds (for B312 being  connected (TermOrder of B311) holds (for B313 being  add-associative  right_complementable  right_zeroed non  trivial addLoopStr holds (for B314 being (Polynomial of B311 , B313) holds (for B315 being (bag of B311) holds ((B315 in ( Support B314 ) & B315 <> ( HT (B314 , B312) )) implies ( ( Red (B314 , B312) ) . B315 ) = ( B314 . B315 ))))))) by L993;
